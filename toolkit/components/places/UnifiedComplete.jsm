"
use
strict
"
;
const
MS_PER_DAY
=
86400000
;
const
QUERYTYPE_FILTERED
=
0
;
const
QUERYTYPE_AUTOFILL_ORIGIN
=
1
;
const
QUERYTYPE_AUTOFILL_URL
=
2
;
const
QUERYTYPE_ADAPTIVE
=
3
;
const
TITLE_TAGS_SEPARATOR
=
"
\
u2013
"
;
const
TELEMETRY_1ST_RESULT
=
"
PLACES_AUTOCOMPLETE_1ST_RESULT_TIME_MS
"
;
const
TELEMETRY_6_FIRST_RESULTS
=
"
PLACES_AUTOCOMPLETE_6_FIRST_RESULTS_TIME_MS
"
;
const
FRECENCY_DEFAULT
=
1000
;
const
MAXIMUM_ALLOWED_EXTENSION_TIME_MS
=
3000
;
const
RECENT_REMOTE_TAB_THRESHOLD_MS
=
259200000
;
const
REGEXP_USER_CONTEXT_ID
=
/
(
?
:
^
|
)
user
-
context
-
id
:
(
\
d
+
)
/
;
const
REGEXP_MAX_RESULTS
=
/
(
?
:
^
|
)
max
-
results
:
(
\
d
+
)
/
;
const
REGEXP_INSERT_METHOD
=
/
(
?
:
^
|
)
insert
-
method
:
(
\
d
+
)
/
;
const
REGEXP_SPACES
=
/
\
s
+
/
;
const
REGEXP_STRIP_PREFIX
=
/
^
[
a
-
z
]
+
:
(
?
:
\
/
)
{
0
2
}
/
i
;
const
NOTIFYRESULT_DELAY_MS
=
16
;
const
QUERYINDEX_QUERYTYPE
=
0
;
const
QUERYINDEX_URL
=
1
;
const
QUERYINDEX_TITLE
=
2
;
const
QUERYINDEX_BOOKMARKED
=
3
;
const
QUERYINDEX_BOOKMARKTITLE
=
4
;
const
QUERYINDEX_TAGS
=
5
;
const
QUERYINDEX_PLACEID
=
8
;
const
QUERYINDEX_SWITCHTAB
=
9
;
const
QUERYINDEX_FRECENCY
=
10
;
const
DISALLOWED_URLLIKE_PREFIXES
=
[
"
http
"
"
https
"
"
ftp
"
]
;
const
SQL_BOOKMARK_TAGS_FRAGMENT
=
EXISTS
(
SELECT
1
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
)
AS
bookmarked
(
SELECT
title
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
AND
title
NOTNULL
ORDER
BY
lastModified
DESC
LIMIT
1
)
AS
btitle
(
SELECT
GROUP_CONCAT
(
t
.
title
'
'
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
ON
t
.
id
=
+
b
.
parent
AND
t
.
parent
=
:
parent
WHERE
b
.
fk
=
h
.
id
)
AS
tags
;
function
defaultQuery
(
conditions
=
"
"
)
{
let
query
=
SELECT
:
query_type
h
.
url
h
.
title
{
SQL_BOOKMARK_TAGS_FRAGMENT
}
h
.
visit_count
h
.
typed
h
.
id
t
.
open_count
h
.
frecency
FROM
moz_places
h
LEFT
JOIN
moz_openpages_temp
t
ON
t
.
url
=
h
.
url
AND
t
.
userContextId
=
:
userContextId
WHERE
h
.
frecency
<
>
0
AND
CASE
WHEN
bookmarked
THEN
AUTOCOMPLETE_MATCH
(
:
searchString
h
.
url
IFNULL
(
btitle
h
.
title
)
tags
h
.
visit_count
h
.
typed
1
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ELSE
AUTOCOMPLETE_MATCH
(
:
searchString
h
.
url
h
.
title
'
'
h
.
visit_count
h
.
typed
0
t
.
open_count
:
matchBehavior
:
searchBehavior
)
END
{
conditions
}
ORDER
BY
h
.
frecency
DESC
h
.
id
DESC
LIMIT
:
maxResults
;
return
query
;
}
const
SQL_SWITCHTAB_QUERY
=
SELECT
:
query_type
t
.
url
t
.
url
NULL
NULL
NULL
NULL
NULL
NULL
t
.
open_count
NULL
FROM
moz_openpages_temp
t
LEFT
JOIN
moz_places
h
ON
h
.
url_hash
=
hash
(
t
.
url
)
AND
h
.
url
=
t
.
url
WHERE
h
.
id
IS
NULL
AND
t
.
userContextId
=
:
userContextId
AND
AUTOCOMPLETE_MATCH
(
:
searchString
t
.
url
t
.
url
NULL
NULL
NULL
NULL
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ORDER
BY
t
.
ROWID
DESC
LIMIT
:
maxResults
;
const
SQL_ADAPTIVE_QUERY
=
/
*
do
not
warn
(
bug
487789
)
*
/
SELECT
:
query_type
h
.
url
h
.
title
{
SQL_BOOKMARK_TAGS_FRAGMENT
}
h
.
visit_count
h
.
typed
h
.
id
t
.
open_count
h
.
frecency
FROM
(
SELECT
ROUND
(
MAX
(
use_count
)
*
(
1
+
(
input
=
:
search_string
)
)
1
)
AS
rank
place_id
FROM
moz_inputhistory
WHERE
input
BETWEEN
:
search_string
AND
:
search_string
|
|
X
'
FFFF
'
GROUP
BY
place_id
)
AS
i
JOIN
moz_places
h
ON
h
.
id
=
i
.
place_id
LEFT
JOIN
moz_openpages_temp
t
ON
t
.
url
=
h
.
url
AND
t
.
userContextId
=
:
userContextId
WHERE
AUTOCOMPLETE_MATCH
(
NULL
h
.
url
IFNULL
(
btitle
h
.
title
)
tags
h
.
visit_count
h
.
typed
bookmarked
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ORDER
BY
rank
DESC
h
.
frecency
DESC
LIMIT
:
maxResults
;
const
QUERYINDEX_ORIGIN_AUTOFILLED_VALUE
=
1
;
const
QUERYINDEX_ORIGIN_URL
=
2
;
const
QUERYINDEX_ORIGIN_FRECENCY
=
3
;
const
SQL_AUTOFILL_WITH
=
WITH
frecency_stats
(
count
sum
squares
)
AS
(
SELECT
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
"
origin_frecency_count
"
)
AS
REAL
)
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
"
origin_frecency_sum
"
)
AS
REAL
)
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
"
origin_frecency_sum_of_squares
"
)
AS
REAL
)
)
autofill_frecency_threshold
(
value
)
AS
(
SELECT
CASE
count
WHEN
0
THEN
0
.
0
WHEN
1
THEN
sum
ELSE
(
sum
/
count
)
+
(
:
stddevMultiplier
*
sqrt
(
(
squares
-
(
(
sum
*
sum
)
/
count
)
)
/
count
)
)
END
FROM
frecency_stats
)
;
const
SQL_AUTOFILL_FRECENCY_THRESHOLD
=
(
SELECT
value
FROM
autofill_frecency_threshold
)
;
function
originQuery
(
conditions
=
"
"
bookmarkedFragment
=
"
NULL
"
)
{
return
{
SQL_AUTOFILL_WITH
}
SELECT
:
query_type
fixed_up_host
|
|
'
/
'
IFNULL
(
:
prefix
prefix
)
|
|
moz_origins
.
host
|
|
'
/
'
frecency
bookmarked
id
FROM
(
SELECT
host
host
AS
fixed_up_host
TOTAL
(
frecency
)
AS
host_frecency
(
SELECT
TOTAL
(
foreign_count
)
>
0
FROM
moz_places
WHERE
moz_places
.
origin_id
=
moz_origins
.
id
)
AS
bookmarked
FROM
moz_origins
WHERE
host
BETWEEN
:
searchString
AND
:
searchString
|
|
X
'
FFFF
'
{
conditions
}
GROUP
BY
host
HAVING
host_frecency
>
=
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
OR
bookmarked
UNION
ALL
SELECT
host
fixup_url
(
host
)
AS
fixed_up_host
TOTAL
(
frecency
)
AS
host_frecency
(
SELECT
TOTAL
(
foreign_count
)
>
0
FROM
moz_places
WHERE
moz_places
.
origin_id
=
moz_origins
.
id
)
AS
bookmarked
FROM
moz_origins
WHERE
host
BETWEEN
'
www
.
'
|
|
:
searchString
AND
'
www
.
'
|
|
:
searchString
|
|
X
'
FFFF
'
{
conditions
}
GROUP
BY
host
HAVING
host_frecency
>
=
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
OR
bookmarked
)
AS
grouped_hosts
JOIN
moz_origins
ON
moz_origins
.
host
=
grouped_hosts
.
host
ORDER
BY
frecency
DESC
id
DESC
LIMIT
1
;
}
const
SQL_ORIGIN_QUERY
=
originQuery
(
)
;
const
SQL_ORIGIN_PREFIX_QUERY
=
originQuery
(
AND
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
)
;
const
SQL_ORIGIN_BOOKMARKED_QUERY
=
originQuery
(
AND
bookmarked
)
;
const
SQL_ORIGIN_PREFIX_BOOKMARKED_QUERY
=
originQuery
(
AND
bookmarked
AND
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
)
;
const
QUERYINDEX_URL_URL
=
1
;
const
QUERYINDEX_URL_STRIPPED_URL
=
2
;
const
QUERYINDEX_URL_FRECENCY
=
3
;
function
urlQuery
(
conditions1
conditions2
)
{
return
/
*
do
not
warn
(
bug
no
)
:
cannot
use
an
index
to
sort
*
/
SELECT
:
query_type
url
:
strippedURL
frecency
foreign_count
>
0
AS
bookmarked
id
FROM
moz_places
WHERE
rev_host
=
:
revHost
AND
(
bookmarked
OR
frecency
>
20
)
{
conditions1
}
UNION
ALL
SELECT
:
query_type
url
:
strippedURL
frecency
foreign_count
>
0
AS
bookmarked
id
FROM
moz_places
WHERE
rev_host
=
:
revHost
|
|
'
www
.
'
AND
(
bookmarked
OR
frecency
>
20
)
{
conditions2
}
ORDER
BY
frecency
DESC
id
DESC
LIMIT
1
;
}
const
SQL_URL_QUERY
=
urlQuery
(
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
SQL_URL_PREFIX_QUERY
=
urlQuery
(
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
SQL_URL_BOOKMARKED_QUERY
=
urlQuery
(
AND
bookmarked
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
bookmarked
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
SQL_URL_PREFIX_BOOKMARKED_QUERY
=
urlQuery
(
AND
bookmarked
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
bookmarked
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AboutPagesUtils
:
"
resource
:
/
/
gre
/
modules
/
AboutPagesUtils
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
ExtensionSearchHandler
:
"
resource
:
/
/
gre
/
modules
/
ExtensionSearchHandler
.
jsm
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
PlacesRemoteTabsAutocompleteProvider
:
"
resource
:
/
/
gre
/
modules
/
PlacesRemoteTabsAutocompleteProvider
.
jsm
"
PlacesSearchAutocompleteProvider
:
"
resource
:
/
/
gre
/
modules
/
PlacesSearchAutocompleteProvider
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
ProfileAge
:
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
UrlbarPrefs
:
"
resource
:
/
/
/
modules
/
UrlbarPrefs
.
jsm
"
UrlbarProviderOpenTabs
:
"
resource
:
/
/
/
modules
/
UrlbarProviderOpenTabs
.
jsm
"
UrlbarProvidersManager
:
"
resource
:
/
/
/
modules
/
UrlbarProvidersManager
.
jsm
"
UrlbarTokenizer
:
"
resource
:
/
/
/
modules
/
UrlbarTokenizer
.
jsm
"
UrlbarUtils
:
"
resource
:
/
/
/
modules
/
UrlbarUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
syncUsernamePref
"
"
services
.
sync
.
username
"
)
;
function
setTimeout
(
callback
ms
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
callback
ms
timer
.
TYPE_ONE_SHOT
)
;
return
timer
;
}
const
kProtocolsWithIcons
=
[
"
chrome
:
"
"
moz
-
extension
:
"
"
about
:
"
"
http
:
"
"
https
:
"
"
ftp
:
"
]
;
function
iconHelper
(
url
)
{
if
(
typeof
url
=
=
"
string
"
)
{
return
kProtocolsWithIcons
.
some
(
p
=
>
url
.
startsWith
(
p
)
)
?
"
page
-
icon
:
"
+
url
:
PlacesUtils
.
favicons
.
defaultFavicon
.
spec
;
}
if
(
url
&
&
url
instanceof
URL
&
&
kProtocolsWithIcons
.
includes
(
url
.
protocol
)
)
{
return
"
page
-
icon
:
"
+
url
.
href
;
}
return
PlacesUtils
.
favicons
.
defaultFavicon
.
spec
;
}
function
PreloadedSite
(
url
title
)
{
this
.
uri
=
Services
.
io
.
newURI
(
url
)
;
this
.
title
=
title
;
this
.
_matchTitle
=
title
.
toLowerCase
(
)
;
this
.
_hasWWW
=
this
.
uri
.
host
.
startsWith
(
"
www
.
"
)
;
this
.
_hostWithoutWWW
=
this
.
_hasWWW
?
this
.
uri
.
host
.
slice
(
4
)
:
this
.
uri
.
host
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
PreloadedSiteStorage
"
(
)
=
>
Object
.
seal
(
{
sites
:
[
]
add
(
url
title
)
{
let
site
=
new
PreloadedSite
(
url
title
)
;
this
.
sites
.
push
(
site
)
;
}
populate
(
sites
)
{
this
.
sites
=
[
]
;
for
(
let
site
of
sites
)
{
this
.
add
(
site
[
0
]
site
[
1
]
)
;
}
}
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ProfileAgeCreatedPromise
"
async
(
)
=
>
{
let
times
=
await
ProfileAge
(
)
;
return
times
.
created
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
typeToBehaviorMap
"
(
)
=
>
{
return
new
Map
(
[
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_HISTORY
"
history
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_BOOKMARK
"
bookmark
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_TAG
"
tag
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_OPENPAGE
"
openpage
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
"
search
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_TITLE
"
title
"
]
[
UrlbarTokenizer
.
TYPE
.
RESTRICT_URL
"
url
"
]
]
)
;
}
)
;
function
stripPrefix
(
str
)
{
let
match
=
REGEXP_STRIP_PREFIX
.
exec
(
str
)
;
if
(
!
match
)
{
return
[
"
"
str
]
;
}
let
prefix
=
match
[
0
]
;
if
(
prefix
.
length
<
str
.
length
&
&
str
[
prefix
.
length
]
=
=
"
"
)
{
return
[
"
"
str
]
;
}
return
[
prefix
str
.
substr
(
prefix
.
length
)
]
;
}
function
stripHttpAndTrim
(
spec
trimSlash
=
true
)
{
if
(
spec
.
startsWith
(
"
http
:
/
/
"
)
)
{
spec
=
spec
.
slice
(
7
)
;
}
if
(
spec
.
endsWith
(
"
?
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
}
if
(
trimSlash
&
&
spec
.
endsWith
(
"
/
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
}
return
spec
;
}
function
makeKeyForMatch
(
match
)
{
if
(
match
.
hasOwnProperty
(
"
style
"
)
&
&
match
.
style
.
includes
(
"
autofill
"
)
)
{
return
[
stripHttpAndTrim
(
match
.
comment
)
null
]
;
}
let
action
=
PlacesUtils
.
parseActionUrl
(
match
.
value
)
;
if
(
!
action
)
{
return
[
stripHttpAndTrim
(
match
.
value
)
null
]
;
}
let
key
;
switch
(
action
.
type
)
{
case
"
searchengine
"
:
key
=
[
action
.
type
action
.
params
.
engineName
(
action
.
params
.
searchSuggestion
|
|
action
.
params
.
searchQuery
)
.
toLocaleLowerCase
(
)
]
;
break
;
default
:
key
=
stripHttpAndTrim
(
action
.
params
.
url
|
|
match
.
value
)
;
break
;
}
return
[
key
action
]
;
}
function
looksLikeUrl
(
str
ignoreAlphanumericHosts
=
false
)
{
return
!
REGEXP_SPACES
.
test
(
str
)
&
&
(
[
"
/
"
"
"
"
:
"
"
[
"
]
.
some
(
c
=
>
str
.
includes
(
c
)
)
|
|
(
ignoreAlphanumericHosts
?
/
^
(
[
\
[
\
]
A
-
Z0
-
9
.
:
-
]
+
[
\
.
:
]
)
{
3
}
[
\
[
\
]
A
-
Z0
-
9
.
:
-
]
+
/
i
.
test
(
str
)
:
str
.
includes
(
"
.
"
)
)
)
;
}
function
substringAt
(
sourceStr
targetStr
)
{
let
index
=
sourceStr
.
indexOf
(
targetStr
)
;
return
index
<
0
?
"
"
:
sourceStr
.
substr
(
index
)
;
}
function
substringAfter
(
sourceStr
targetStr
)
{
let
index
=
sourceStr
.
indexOf
(
targetStr
)
;
return
index
<
0
?
"
"
:
sourceStr
.
substr
(
index
+
targetStr
.
length
)
;
}
function
Search
(
searchString
searchParam
autocompleteListener
autocompleteSearch
prohibitSearchSuggestions
previousResult
)
{
this
.
_originalSearchString
=
searchString
;
this
.
_trimmedOriginalSearchString
=
searchString
.
trim
(
)
;
let
unescapedSearchString
=
Services
.
textToSubURI
.
unEscapeURIForUI
(
"
UTF
-
8
"
this
.
_trimmedOriginalSearchString
)
;
let
[
prefix
suffix
]
=
stripPrefix
(
unescapedSearchString
)
;
this
.
_searchString
=
suffix
;
this
.
_strippedPrefix
=
prefix
.
toLowerCase
(
)
;
this
.
_matchBehavior
=
Ci
.
mozIPlacesAutoComplete
.
MATCH_BOUNDARY
;
this
.
_behavior
=
this
.
_searchString
?
UrlbarPrefs
.
get
(
"
defaultBehavior
"
)
:
UrlbarPrefs
.
get
(
"
emptySearchDefaultBehavior
"
)
;
let
params
=
new
Set
(
searchParam
.
split
(
"
"
)
)
;
this
.
_enableActions
=
params
.
has
(
"
enable
-
actions
"
)
;
this
.
_disablePrivateActions
=
params
.
has
(
"
disable
-
private
-
actions
"
)
;
this
.
_inPrivateWindow
=
params
.
has
(
"
private
-
window
"
)
;
this
.
_prohibitAutoFill
=
params
.
has
(
"
prohibit
-
autofill
"
)
;
this
.
_disableTelemetry
=
params
.
has
(
"
disable
-
telemetry
"
)
;
let
maxResults
=
searchParam
.
match
(
REGEXP_MAX_RESULTS
)
;
this
.
_maxResults
=
maxResults
?
parseInt
(
maxResults
[
1
]
)
:
UrlbarPrefs
.
get
(
"
maxRichResults
"
)
;
let
userContextId
=
searchParam
.
match
(
REGEXP_USER_CONTEXT_ID
)
;
this
.
_userContextId
=
userContextId
?
parseInt
(
userContextId
[
1
]
10
)
:
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
let
{
tokens
}
=
UrlbarTokenizer
.
tokenize
(
{
searchString
:
unescapedSearchString
}
)
;
this
.
_leadingRestrictionToken
=
null
;
this
.
_trailingRestrictionToken
=
null
;
if
(
tokens
.
length
>
0
)
{
if
(
UrlbarTokenizer
.
isRestrictionToken
(
tokens
[
0
]
)
&
&
(
tokens
.
length
>
1
|
|
tokens
[
0
]
.
type
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
)
)
{
this
.
_leadingRestrictionToken
=
tokens
[
0
]
.
value
;
}
if
(
UrlbarTokenizer
.
isRestrictionToken
(
tokens
[
tokens
.
length
-
1
]
)
&
&
(
tokens
.
length
>
1
|
|
tokens
[
tokens
.
length
-
1
]
.
type
=
=
UrlbarTokenizer
.
TYPE
.
RESTRICT_SEARCH
)
)
{
this
.
_trailingRestrictionToken
=
tokens
[
tokens
.
length
-
1
]
.
value
;
}
if
(
prefix
&
&
tokens
[
0
]
.
value
.
length
>
prefix
.
length
)
{
tokens
[
0
]
.
value
=
tokens
[
0
]
.
value
.
substring
(
prefix
.
length
)
;
}
}
this
.
_searchTokens
=
this
.
filterTokens
(
tokens
)
;
let
firstToken
=
this
.
_searchTokens
.
length
>
0
&
&
this
.
_searchTokens
[
0
]
.
value
;
this
.
_heuristicToken
=
firstToken
&
&
this
.
_trimmedOriginalSearchString
.
startsWith
(
firstToken
)
?
firstToken
:
null
;
this
.
_keywordSubstitute
=
null
;
this
.
_prohibitSearchSuggestions
=
prohibitSearchSuggestions
;
this
.
_listener
=
autocompleteListener
;
this
.
_autocompleteSearch
=
autocompleteSearch
;
let
result
=
previousResult
|
|
Cc
[
"
mozilla
.
org
/
autocomplete
/
simple
-
result
;
1
"
]
.
createInstance
(
Ci
.
nsIAutoCompleteSimpleResult
)
;
result
.
setSearchString
(
searchString
)
;
result
.
setListener
(
{
onValueRemoved
(
result
spec
removeFromDB
)
{
if
(
removeFromDB
)
{
PlacesUtils
.
history
.
remove
(
spec
)
.
catch
(
Cu
.
reportError
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteSimpleResultListener
]
)
}
)
;
result
.
setDefaultIndex
(
-
1
)
;
this
.
_result
=
result
;
this
.
_previousSearchMatchTypes
=
[
]
;
for
(
let
i
=
0
;
previousResult
&
&
i
<
previousResult
.
matchCount
;
+
+
i
)
{
let
style
=
previousResult
.
getStyleAt
(
i
)
;
if
(
style
.
includes
(
"
heuristic
"
)
)
{
this
.
_previousSearchMatchTypes
.
push
(
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
)
;
}
else
if
(
style
.
includes
(
"
suggestion
"
)
)
{
this
.
_previousSearchMatchTypes
.
push
(
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
)
;
}
else
if
(
style
.
includes
(
"
extension
"
)
)
{
this
.
_previousSearchMatchTypes
.
push
(
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
)
;
}
else
{
this
.
_previousSearchMatchTypes
.
push
(
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
)
;
}
}
this
.
_adaptiveCount
=
0
;
this
.
_extraAdaptiveRows
=
[
]
;
this
.
_extraRemoteTabRows
=
[
]
;
this
.
_currentMatchCount
=
0
;
this
.
_usedURLs
=
[
]
;
this
.
_usedPlaceIds
=
new
Set
(
)
;
this
.
_counts
=
Object
.
values
(
UrlbarUtils
.
RESULT_GROUP
)
.
reduce
(
(
o
p
)
=
>
{
o
[
p
]
=
0
;
return
o
;
}
{
}
)
;
}
Search
.
prototype
=
{
setBehavior
(
type
)
{
type
=
type
.
toUpperCase
(
)
;
this
.
_behavior
|
=
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
type
]
;
}
hasBehavior
(
type
)
{
let
behavior
=
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
type
.
toUpperCase
(
)
]
;
if
(
this
.
_disablePrivateActions
&
&
behavior
=
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_OPENPAGE
)
{
return
false
;
}
return
this
.
_behavior
&
behavior
;
}
_sleepResolve
:
null
_sleep
(
aTimeMs
)
{
if
(
!
this
.
_sleepTimer
)
this
.
_sleepTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
return
new
Promise
(
resolve
=
>
{
this
.
_sleepResolve
=
resolve
;
this
.
_sleepTimer
.
initWithCallback
(
resolve
aTimeMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
)
;
}
filterTokens
(
tokens
)
{
let
foundToken
=
false
;
let
filtered
=
[
]
;
for
(
let
token
of
tokens
)
{
if
(
!
UrlbarTokenizer
.
isRestrictionToken
(
token
)
)
{
filtered
.
push
(
token
)
;
continue
;
}
let
behavior
=
typeToBehaviorMap
.
get
(
token
.
type
)
;
if
(
!
behavior
)
{
throw
new
Error
(
Unknown
token
type
{
token
.
type
}
)
;
}
if
(
behavior
!
=
"
openpage
"
|
|
this
.
_enableActions
)
{
if
(
!
foundToken
)
{
foundToken
=
true
;
this
.
_behavior
=
0
;
this
.
setBehavior
(
"
restrict
"
)
;
}
this
.
setBehavior
(
behavior
)
;
}
}
if
(
!
UrlbarPrefs
.
get
(
"
filter
.
javascript
"
)
)
{
this
.
setBehavior
(
"
javascript
"
)
;
}
return
filtered
;
}
stop
(
)
{
if
(
!
this
.
pending
)
return
;
if
(
this
.
_notifyTimer
)
this
.
_notifyTimer
.
cancel
(
)
;
this
.
_notifyDelaysCount
=
0
;
if
(
this
.
_sleepTimer
)
this
.
_sleepTimer
.
cancel
(
)
;
if
(
this
.
_sleepResolve
)
{
this
.
_sleepResolve
(
)
;
this
.
_sleepResolve
=
null
;
}
if
(
this
.
_suggestionsFetch
)
{
this
.
_suggestionsFetch
.
stop
(
)
;
this
.
_suggestionsFetch
=
null
;
}
if
(
typeof
this
.
interrupt
=
=
"
function
"
)
{
this
.
interrupt
(
)
;
}
this
.
pending
=
false
;
}
pending
:
true
async
execute
(
conn
)
{
if
(
!
this
.
pending
)
return
;
this
.
interrupt
=
(
)
=
>
{
if
(
!
UrlbarProvidersManager
.
interruptLevel
)
{
conn
.
interrupt
(
)
;
}
}
;
if
(
!
this
.
_disableTelemetry
)
{
TelemetryStopwatch
.
start
(
TELEMETRY_1ST_RESULT
this
)
;
TelemetryStopwatch
.
start
(
TELEMETRY_6_FIRST_RESULTS
this
)
;
}
await
PlacesSearchAutocompleteProvider
.
ensureInitialized
(
)
;
if
(
!
this
.
pending
)
return
;
await
this
.
_checkPreloadedSitesExpiry
(
)
;
if
(
this
.
_trimmedOriginalSearchString
=
=
"
"
)
{
let
added
=
await
this
.
_addSearchEngineTokenAliasMatches
(
)
;
if
(
added
)
{
this
.
_cleanUpNonCurrentMatches
(
null
)
;
this
.
_autocompleteSearch
.
finishSearch
(
true
)
;
return
;
}
}
this
.
_addingHeuristicFirstMatch
=
true
;
let
hasHeuristic
=
await
this
.
_matchFirstHeuristicResult
(
conn
)
;
this
.
_addingHeuristicFirstMatch
=
false
;
this
.
_cleanUpNonCurrentMatches
(
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
)
;
if
(
!
this
.
pending
)
return
;
if
(
hasHeuristic
)
{
await
this
.
_sleep
(
UrlbarPrefs
.
get
(
"
delay
"
)
)
;
if
(
!
this
.
pending
)
return
;
let
emptyQueryTokenAlias
=
this
.
_searchEngineAliasMatch
&
&
this
.
_searchEngineAliasMatch
.
isTokenAlias
&
&
!
this
.
_searchEngineAliasMatch
.
query
;
let
emptySearchRestriction
=
this
.
_trimmedOriginalSearchString
.
length
<
=
3
&
&
this
.
_leadingRestrictionToken
=
=
UrlbarTokenizer
.
RESTRICT
.
SEARCH
&
&
/
\
s
*
\
S
?
/
.
test
(
this
.
_trimmedOriginalSearchString
)
;
if
(
emptySearchRestriction
|
|
emptyQueryTokenAlias
)
{
this
.
_cleanUpNonCurrentMatches
(
null
false
)
;
this
.
_autocompleteSearch
.
finishSearch
(
true
)
;
return
;
}
}
let
extensionsCompletePromise
=
Promise
.
resolve
(
)
;
if
(
this
.
_heuristicToken
&
&
ExtensionSearchHandler
.
isKeywordRegistered
(
this
.
_heuristicToken
)
&
&
substringAfter
(
this
.
_originalSearchString
this
.
_heuristicToken
)
&
&
!
this
.
_searchEngineAliasMatch
)
{
extensionsCompletePromise
=
this
.
_matchExtensionSuggestions
(
)
;
}
else
if
(
ExtensionSearchHandler
.
hasActiveInputSession
(
)
)
{
ExtensionSearchHandler
.
handleInputCancelled
(
)
;
}
let
searchSuggestionsCompletePromise
=
Promise
.
resolve
(
)
;
if
(
this
.
_enableActions
&
&
this
.
hasBehavior
(
"
search
"
)
&
&
!
this
.
_inPrivateWindow
)
{
let
query
=
this
.
_searchEngineAliasMatch
?
this
.
_searchEngineAliasMatch
.
query
:
substringAt
(
this
.
_originalSearchString
this
.
_searchTokens
[
0
]
.
value
)
;
if
(
query
)
{
query
=
query
.
substr
(
0
UrlbarPrefs
.
get
(
"
maxCharsForSearchSuggestions
"
)
)
;
if
(
!
this
.
_prohibitSearchSuggestionsFor
(
query
)
)
{
let
engine
;
if
(
this
.
_searchEngineAliasMatch
)
{
engine
=
this
.
_searchEngineAliasMatch
.
engine
;
}
else
{
engine
=
await
PlacesSearchAutocompleteProvider
.
currentEngine
(
)
;
if
(
!
this
.
pending
)
{
return
;
}
}
let
alias
=
this
.
_searchEngineAliasMatch
&
&
this
.
_searchEngineAliasMatch
.
alias
|
|
"
"
;
searchSuggestionsCompletePromise
=
this
.
_matchSearchSuggestions
(
engine
query
alias
)
;
}
}
}
if
(
(
this
.
_searchEngineAliasMatch
&
&
this
.
_searchEngineAliasMatch
.
isTokenAlias
)
|
|
(
this
.
_enableActions
&
&
this
.
hasBehavior
(
"
search
"
)
&
&
this
.
hasBehavior
(
"
restrict
"
)
)
)
{
await
searchSuggestionsCompletePromise
;
this
.
_cleanUpNonCurrentMatches
(
null
)
;
this
.
_autocompleteSearch
.
finishSearch
(
true
)
;
return
;
}
searchSuggestionsCompletePromise
.
then
(
(
)
=
>
{
this
.
_cleanUpNonCurrentMatches
(
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
)
;
}
)
;
await
conn
.
executeCached
(
this
.
_adaptiveQuery
[
0
]
this
.
_adaptiveQuery
[
1
]
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
return
;
if
(
this
.
_enableActions
&
&
this
.
hasBehavior
(
"
openpage
"
)
)
{
await
this
.
_matchRemoteTabs
(
)
;
if
(
!
this
.
pending
)
return
;
}
let
queries
=
[
]
;
if
(
this
.
hasBehavior
(
"
openpage
"
)
)
{
queries
.
push
(
this
.
_switchToTabQuery
)
;
}
queries
.
push
(
this
.
_searchQuery
)
;
for
(
let
[
query
params
]
of
queries
)
{
await
conn
.
executeCached
(
query
params
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
return
;
}
while
(
this
.
_extraAdaptiveRows
.
length
&
&
this
.
_currentMatchCount
<
this
.
_maxResults
)
{
this
.
_addFilteredQueryMatch
(
this
.
_extraAdaptiveRows
.
shift
(
)
)
;
}
while
(
this
.
_extraRemoteTabRows
.
length
&
&
this
.
_currentMatchCount
<
this
.
_maxResults
)
{
this
.
_addMatch
(
this
.
_extraRemoteTabRows
.
shift
(
)
)
;
}
this
.
_cleanUpNonCurrentMatches
(
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
)
;
this
.
_matchAboutPages
(
)
;
let
count
=
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
]
+
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
]
;
if
(
count
<
this
.
_maxResults
)
{
this
.
_matchBehavior
=
Ci
.
mozIPlacesAutoComplete
.
MATCH_ANYWHERE
;
for
(
let
[
query
params
]
of
[
this
.
_adaptiveQuery
this
.
_searchQuery
]
)
{
await
conn
.
executeCached
(
query
params
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
return
;
}
}
this
.
_matchPreloadedSites
(
)
;
await
searchSuggestionsCompletePromise
;
await
extensionsCompletePromise
;
}
_shouldMatchAboutPages
(
)
{
return
(
this
.
_strippedPrefix
=
=
"
about
:
"
&
&
this
.
_searchString
)
;
}
_matchAboutPages
(
)
{
if
(
!
this
.
_shouldMatchAboutPages
(
)
)
{
return
;
}
for
(
const
url
of
AboutPagesUtils
.
visibleAboutUrls
)
{
if
(
url
.
startsWith
(
about
:
{
this
.
_searchString
}
)
)
{
this
.
_addMatch
(
{
value
:
url
comment
:
url
frecency
:
FRECENCY_DEFAULT
}
)
;
}
}
}
_matchAboutPageForAutofill
(
)
{
if
(
!
this
.
_shouldMatchAboutPages
(
)
)
{
return
false
;
}
for
(
const
url
of
AboutPagesUtils
.
visibleAboutUrls
)
{
if
(
url
.
startsWith
(
about
:
{
this
.
_searchString
.
toLowerCase
(
)
}
)
)
{
this
.
_result
.
setDefaultIndex
(
0
)
;
this
.
_addAutofillMatch
(
url
.
substr
(
6
)
url
)
;
return
true
;
}
}
return
false
;
}
async
_checkPreloadedSitesExpiry
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
return
;
let
profileCreationDate
=
await
ProfileAgeCreatedPromise
;
let
daysSinceProfileCreation
=
(
Date
.
now
(
)
-
profileCreationDate
)
/
MS_PER_DAY
;
if
(
daysSinceProfileCreation
>
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
expire_days
"
)
)
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
usepreloadedtopurls
.
enabled
"
false
)
;
}
_matchPreloadedSites
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
return
;
}
if
(
!
this
.
_searchString
)
{
return
;
}
for
(
let
site
of
PreloadedSiteStorage
.
sites
)
{
let
url
=
site
.
uri
.
spec
;
if
(
(
!
this
.
_strippedPrefix
|
|
url
.
startsWith
(
this
.
_strippedPrefix
)
)
&
&
(
site
.
uri
.
host
.
includes
(
this
.
_searchString
)
|
|
site
.
_matchTitle
.
includes
(
this
.
_searchString
)
)
)
{
this
.
_addMatch
(
{
value
:
url
comment
:
site
.
title
style
:
"
preloaded
-
top
-
site
"
frecency
:
FRECENCY_DEFAULT
-
1
}
)
;
}
}
}
_matchPreloadedSiteForAutofill
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
return
false
;
}
let
matchedSite
=
PreloadedSiteStorage
.
sites
.
find
(
site
=
>
{
return
(
!
this
.
_strippedPrefix
|
|
site
.
uri
.
spec
.
startsWith
(
this
.
_strippedPrefix
)
)
&
&
(
site
.
uri
.
host
.
startsWith
(
this
.
_searchString
)
|
|
site
.
uri
.
host
.
startsWith
(
"
www
.
"
+
this
.
_searchString
)
)
;
}
)
;
if
(
!
matchedSite
)
{
return
false
;
}
this
.
_result
.
setDefaultIndex
(
0
)
;
let
url
=
matchedSite
.
uri
.
spec
;
let
value
=
stripPrefix
(
url
)
[
1
]
;
value
=
value
.
substr
(
value
.
indexOf
(
this
.
_searchString
)
)
;
this
.
_addAutofillMatch
(
value
url
Infinity
[
"
preloaded
-
top
-
site
"
]
)
;
return
true
;
}
async
_addSearchEngineTokenAliasMatches
(
)
{
let
engines
=
await
PlacesSearchAutocompleteProvider
.
tokenAliasEngines
(
)
;
if
(
!
engines
|
|
!
engines
.
length
)
{
return
false
;
}
for
(
let
{
engine
tokenAliases
}
of
engines
)
{
this
.
_addSearchEngineMatch
(
{
engine
alias
:
tokenAliases
[
0
]
}
)
;
}
return
true
;
}
async
_matchSearchEngineTokenAliasForAutofill
(
)
{
let
token
=
this
.
_heuristicToken
;
if
(
!
token
|
|
token
.
length
=
=
1
|
|
!
token
.
startsWith
(
"
"
)
)
{
return
false
;
}
let
engines
=
await
PlacesSearchAutocompleteProvider
.
tokenAliasEngines
(
)
;
for
(
let
{
engine
tokenAliases
}
of
engines
)
{
for
(
let
alias
of
tokenAliases
)
{
if
(
alias
.
startsWith
(
token
.
toLocaleLowerCase
(
)
)
)
{
let
aliasPreservingUserCase
=
token
+
alias
.
substr
(
token
.
length
)
;
let
value
=
aliasPreservingUserCase
+
"
"
;
this
.
_result
.
setDefaultIndex
(
0
)
;
this
.
_addMatch
(
{
value
finalCompleteValue
:
PlacesUtils
.
mozActionURI
(
"
searchengine
"
{
engineName
:
engine
.
name
alias
:
aliasPreservingUserCase
input
:
value
searchQuery
:
"
"
}
)
comment
:
engine
.
name
frecency
:
FRECENCY_DEFAULT
style
:
"
autofill
action
searchengine
"
icon
:
engine
.
iconURI
?
engine
.
iconURI
.
spec
:
null
}
)
;
this
.
_searchEngineAliasMatch
=
{
engine
alias
:
aliasPreservingUserCase
query
:
"
"
isTokenAlias
:
true
}
;
return
true
;
}
}
}
return
false
;
}
async
_matchFirstHeuristicResult
(
conn
)
{
let
hasSearchTerms
=
this
.
_searchTokens
.
length
>
0
;
if
(
hasSearchTerms
)
{
let
matched
=
await
this
.
_matchExtensionHeuristicResult
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
_enableActions
&
&
hasSearchTerms
)
{
let
matched
=
await
this
.
_matchSearchEngineAlias
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
hasSearchTerms
)
{
let
matched
=
await
this
.
_matchPlacesKeyword
(
)
;
if
(
matched
)
{
return
true
;
}
}
let
shouldAutofill
=
this
.
_shouldAutofill
;
if
(
this
.
pending
&
&
shouldAutofill
)
{
let
matched
=
await
this
.
_matchAboutPageForAutofill
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
shouldAutofill
)
{
let
matched
=
await
this
.
_matchKnownUrl
(
conn
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
shouldAutofill
)
{
let
matched
=
await
this
.
_matchSearchEngineDomain
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
shouldAutofill
)
{
let
matched
=
this
.
_matchPreloadedSiteForAutofill
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
shouldAutofill
)
{
let
matched
=
await
this
.
_matchSearchEngineTokenAliasForAutofill
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
hasSearchTerms
&
&
this
.
_enableActions
)
{
let
matched
=
await
this
.
_matchUnknownUrl
(
)
;
if
(
matched
)
{
this
.
_prohibitSearchSuggestions
=
true
;
try
{
new
URL
(
this
.
_originalSearchString
)
;
}
catch
(
ex
)
{
if
(
UrlbarPrefs
.
get
(
"
keyword
.
enabled
"
)
&
&
!
looksLikeUrl
(
this
.
_originalSearchString
true
)
)
{
this
.
_addingHeuristicFirstMatch
=
false
;
await
this
.
_matchCurrentSearchEngine
(
)
;
this
.
_addingHeuristicFirstMatch
=
true
;
}
}
return
true
;
}
}
if
(
this
.
pending
&
&
this
.
_enableActions
&
&
this
.
_originalSearchString
)
{
let
matched
=
await
this
.
_matchCurrentSearchEngine
(
)
;
if
(
matched
)
{
return
true
;
}
}
return
false
;
}
_matchSearchSuggestions
(
engine
searchString
alias
)
{
this
.
_suggestionsFetch
=
PlacesSearchAutocompleteProvider
.
newSuggestionsFetch
(
engine
searchString
this
.
_inPrivateWindow
UrlbarPrefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
this
.
_maxResults
-
UrlbarPrefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
this
.
_userContextId
)
;
return
this
.
_suggestionsFetch
.
fetchCompletePromise
.
then
(
(
)
=
>
{
if
(
!
this
.
_suggestionsFetch
)
{
return
;
}
if
(
this
.
_suggestionsFetch
.
resultsCount
>
=
0
&
&
this
.
_suggestionsFetch
.
resultsCount
<
2
)
{
this
.
_lastLowResultsSearchSuggestion
=
this
.
_originalSearchString
;
}
while
(
this
.
pending
)
{
let
result
=
this
.
_suggestionsFetch
.
consume
(
)
;
if
(
!
result
)
break
;
let
{
suggestion
historical
}
=
result
;
if
(
!
looksLikeUrl
(
suggestion
)
)
{
this
.
_addSearchEngineMatch
(
{
engine
alias
query
:
searchString
suggestion
historical
}
)
;
}
}
}
)
.
catch
(
Cu
.
reportError
)
;
}
_prohibitSearchSuggestionsFor
(
searchString
)
{
if
(
this
.
_prohibitSearchSuggestions
)
return
true
;
if
(
this
.
_searchEngineAliasMatch
&
&
this
.
_searchEngineAliasMatch
.
isTokenAlias
)
{
return
false
;
}
if
(
searchString
.
length
<
2
)
return
true
;
if
(
this
.
_searchTokens
.
length
=
=
1
&
&
this
.
_searchTokens
[
0
]
.
type
=
=
UrlbarTokenizer
.
TYPE
.
POSSIBLE_ORIGIN
&
&
Services
.
uriFixup
.
isDomainWhitelisted
(
this
.
_searchTokens
[
0
]
.
value
-
1
)
)
{
return
true
;
}
if
(
DISALLOWED_URLLIKE_PREFIXES
.
some
(
prefix
=
>
this
.
_trimmedOriginalSearchString
=
=
prefix
)
|
|
DISALLOWED_URLLIKE_PREFIXES
.
some
(
prefix
=
>
this
.
_trimmedOriginalSearchString
.
startsWith
(
prefix
+
"
:
"
)
)
)
{
return
true
;
}
return
this
.
_searchTokens
.
some
(
t
=
>
{
return
t
.
type
=
=
UrlbarTokenizer
.
TYPE
.
POSSIBLE_URL
|
|
(
t
.
type
=
=
UrlbarTokenizer
.
TYPE
.
POSSIBLE_ORIGIN
&
&
!
/
^
[
a
-
z0
-
9
-
]
+
/
i
.
test
(
t
.
value
)
)
;
}
)
;
}
async
_matchKnownUrl
(
conn
)
{
let
gotResult
=
false
;
let
query
params
;
if
(
UrlbarTokenizer
.
looksLikeOrigin
(
this
.
_searchString
)
)
{
[
query
params
]
=
this
.
_originQuery
;
}
else
{
[
query
params
]
=
this
.
_urlQuery
;
}
if
(
query
)
{
await
conn
.
executeCached
(
query
params
(
row
cancel
)
=
>
{
gotResult
=
true
;
this
.
_onResultRow
(
row
cancel
)
;
}
)
;
}
return
gotResult
;
}
_matchExtensionHeuristicResult
(
)
{
if
(
this
.
_heuristicToken
&
&
ExtensionSearchHandler
.
isKeywordRegistered
(
this
.
_heuristicToken
)
&
&
substringAfter
(
this
.
_originalSearchString
this
.
_heuristicToken
)
)
{
let
description
=
ExtensionSearchHandler
.
getDescription
(
this
.
_heuristicToken
)
;
this
.
_addExtensionMatch
(
this
.
_originalSearchString
description
)
;
return
true
;
}
return
false
;
}
async
_matchPlacesKeyword
(
)
{
if
(
!
this
.
_heuristicToken
)
{
return
false
;
}
let
keyword
=
this
.
_heuristicToken
;
let
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
keyword
)
;
if
(
!
entry
)
{
return
false
;
}
let
searchString
=
substringAfter
(
this
.
_originalSearchString
keyword
)
.
trim
(
)
;
let
url
=
null
postData
=
null
;
try
{
[
url
postData
]
=
await
BrowserUtils
.
parseUrlAndPostData
(
entry
.
url
.
href
entry
.
postData
searchString
)
;
}
catch
(
ex
)
{
return
false
;
}
let
style
=
"
keyword
"
;
let
value
=
url
;
if
(
this
.
_enableActions
)
{
style
=
"
action
"
+
style
;
value
=
PlacesUtils
.
mozActionURI
(
"
keyword
"
{
url
keyword
input
:
this
.
_originalSearchString
postData
}
)
;
}
let
comment
=
entry
.
url
.
host
;
this
.
_addMatch
(
{
value
comment
icon
:
iconHelper
(
entry
.
url
)
style
frecency
:
Infinity
}
)
;
if
(
!
this
.
_keywordSubstitute
)
{
this
.
_keywordSubstitute
=
entry
.
url
.
host
;
}
return
true
;
}
async
_matchSearchEngineDomain
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
autoFill
.
searchEngines
"
)
)
{
return
false
;
}
if
(
!
this
.
_searchString
)
{
return
false
;
}
let
searchStr
=
this
.
_searchString
;
if
(
searchStr
.
indexOf
(
"
/
"
)
=
=
searchStr
.
length
-
1
)
{
searchStr
=
searchStr
.
slice
(
0
-
1
)
;
}
if
(
!
UrlbarTokenizer
.
looksLikeOrigin
(
searchStr
)
)
{
return
false
;
}
let
engine
=
await
PlacesSearchAutocompleteProvider
.
engineForDomainPrefix
(
searchStr
)
;
if
(
!
engine
)
{
return
false
;
}
let
url
=
engine
.
searchForm
;
let
domain
=
engine
.
getResultDomain
(
)
;
if
(
(
this
.
_strippedPrefix
&
&
!
url
.
startsWith
(
this
.
_strippedPrefix
)
)
|
|
!
(
domain
+
"
/
"
)
.
includes
(
this
.
_searchString
)
)
{
return
false
;
}
let
value
=
this
.
_strippedPrefix
+
domain
.
substr
(
domain
.
indexOf
(
searchStr
)
)
+
"
/
"
;
let
finalCompleteValue
=
url
;
try
{
let
fixupInfo
=
Services
.
uriFixup
.
getFixupURIInfo
(
url
0
)
;
if
(
fixupInfo
.
fixedURI
)
{
finalCompleteValue
=
fixupInfo
.
fixedURI
.
spec
;
}
}
catch
(
ex
)
{
}
this
.
_result
.
setDefaultIndex
(
0
)
;
this
.
_addMatch
(
{
value
finalCompleteValue
comment
:
engine
.
name
icon
:
engine
.
iconURI
?
engine
.
iconURI
.
spec
:
null
style
:
"
priority
-
search
"
frecency
:
Infinity
}
)
;
return
true
;
}
async
_matchSearchEngineAlias
(
)
{
if
(
!
this
.
_heuristicToken
)
{
return
false
;
}
let
alias
=
this
.
_heuristicToken
;
let
engine
=
await
PlacesSearchAutocompleteProvider
.
engineForAlias
(
alias
)
;
if
(
!
engine
)
{
return
false
;
}
this
.
_searchEngineAliasMatch
=
{
engine
alias
query
:
substringAfter
(
this
.
_originalSearchString
alias
)
.
trim
(
)
isTokenAlias
:
alias
.
startsWith
(
"
"
)
}
;
this
.
_addSearchEngineMatch
(
this
.
_searchEngineAliasMatch
)
;
if
(
!
this
.
_keywordSubstitute
)
{
this
.
_keywordSubstitute
=
engine
.
getResultDomain
(
)
;
}
return
true
;
}
async
_matchCurrentSearchEngine
(
)
{
let
engine
=
await
PlacesSearchAutocompleteProvider
.
currentEngine
(
)
;
if
(
!
engine
|
|
!
this
.
pending
)
{
return
false
;
}
let
query
=
this
.
_trimmedOriginalSearchString
;
if
(
this
.
_leadingRestrictionToken
)
{
query
=
substringAfter
(
query
this
.
_leadingRestrictionToken
)
.
trim
(
)
;
}
if
(
this
.
_trailingRestrictionToken
)
{
query
=
query
.
substring
(
0
query
.
lastIndexOf
(
this
.
_trailingRestrictionToken
)
)
;
}
this
.
_addSearchEngineMatch
(
{
engine
query
}
)
;
return
true
;
}
_addExtensionMatch
(
content
comment
)
{
let
count
=
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
]
+
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
]
;
if
(
count
>
=
UrlbarUtils
.
MAXIMUM_ALLOWED_EXTENSION_MATCHES
)
{
return
;
}
this
.
_addMatch
(
{
value
:
PlacesUtils
.
mozActionURI
(
"
extension
"
{
content
keyword
:
this
.
_heuristicToken
}
)
comment
icon
:
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
style
:
"
action
extension
"
frecency
:
Infinity
type
:
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
}
)
;
}
_addSearchEngineMatch
(
{
engine
query
=
"
"
alias
=
undefined
suggestion
=
undefined
historical
=
false
}
)
{
let
actionURLParams
=
{
engineName
:
engine
.
name
searchQuery
:
query
}
;
if
(
suggestion
)
{
actionURLParams
.
input
=
(
alias
?
{
alias
}
:
"
"
)
+
suggestion
;
}
else
if
(
alias
&
&
!
query
)
{
actionURLParams
.
input
=
{
alias
}
;
}
else
{
actionURLParams
.
input
=
this
.
_originalSearchString
;
}
let
match
=
{
comment
:
engine
.
name
icon
:
engine
.
iconURI
&
&
!
suggestion
?
engine
.
iconURI
.
spec
:
null
style
:
"
action
searchengine
"
frecency
:
FRECENCY_DEFAULT
}
;
if
(
alias
)
{
actionURLParams
.
alias
=
alias
;
match
.
style
+
=
"
alias
"
;
}
if
(
suggestion
)
{
actionURLParams
.
searchSuggestion
=
suggestion
;
match
.
style
+
=
"
suggestion
"
;
match
.
type
=
UrlbarUtils
.
RESULT_GROUP
.
SUGGESTION
;
}
match
.
value
=
PlacesUtils
.
mozActionURI
(
"
searchengine
"
actionURLParams
)
;
this
.
_addMatch
(
match
)
;
}
_matchExtensionSuggestions
(
)
{
let
data
=
{
keyword
:
this
.
_heuristicToken
text
:
this
.
_originalSearchString
inPrivateWindow
:
this
.
_inPrivateWindow
}
;
let
promise
=
ExtensionSearchHandler
.
handleSearch
(
data
suggestions
=
>
{
for
(
let
suggestion
of
suggestions
)
{
let
content
=
{
this
.
_heuristicToken
}
{
suggestion
.
content
}
;
this
.
_addExtensionMatch
(
content
suggestion
.
description
)
;
}
}
)
;
setTimeout
(
(
)
=
>
this
.
_cleanUpNonCurrentMatches
(
UrlbarUtils
.
RESULT_GROUP
.
EXTENSION
)
100
)
;
let
timeoutPromise
=
new
Promise
(
resolve
=
>
{
let
timer
=
setTimeout
(
resolve
MAXIMUM_ALLOWED_EXTENSION_TIME_MS
)
;
promise
.
then
(
timer
.
cancel
)
;
}
)
;
return
Promise
.
race
(
[
timeoutPromise
promise
]
)
.
catch
(
Cu
.
reportError
)
;
}
async
_matchRemoteTabs
(
)
{
if
(
!
syncUsernamePref
)
{
return
;
}
let
matches
=
await
PlacesRemoteTabsAutocompleteProvider
.
getMatches
(
this
.
_originalSearchString
)
;
for
(
let
{
url
title
icon
deviceName
lastUsed
}
of
matches
)
{
if
(
!
icon
)
{
icon
=
iconHelper
(
url
)
;
}
else
{
icon
=
PlacesUtils
.
favicons
.
getFaviconLinkForIcon
(
Services
.
io
.
newURI
(
icon
)
)
.
spec
;
}
let
match
=
{
value
:
PlacesUtils
.
mozActionURI
(
"
remotetab
"
{
url
deviceName
}
)
comment
:
title
|
|
url
style
:
"
action
remotetab
"
frecency
:
FRECENCY_DEFAULT
+
1
icon
}
;
if
(
lastUsed
>
(
Date
.
now
(
)
-
RECENT_REMOTE_TAB_THRESHOLD_MS
)
)
{
this
.
_addMatch
(
match
)
;
}
else
{
this
.
_extraRemoteTabRows
.
push
(
match
)
;
}
}
}
_matchUnknownUrl
(
)
{
if
(
!
this
.
_searchString
&
&
this
.
_strippedPrefix
)
{
return
false
;
}
if
(
this
.
hasBehavior
(
"
search
"
)
&
&
this
.
hasBehavior
(
"
restrict
"
)
)
{
return
false
;
}
let
flags
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
|
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
let
fixupInfo
=
null
;
let
searchUrl
=
this
.
_trimmedOriginalSearchString
;
try
{
fixupInfo
=
Services
.
uriFixup
.
getFixupURIInfo
(
searchUrl
flags
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_MALFORMED_URI
&
&
!
UrlbarPrefs
.
get
(
"
keyword
.
enabled
"
)
)
{
let
value
=
PlacesUtils
.
mozActionURI
(
"
visiturl
"
{
url
:
searchUrl
input
:
searchUrl
}
)
;
this
.
_addMatch
(
{
value
comment
:
searchUrl
style
:
"
action
visiturl
"
frecency
:
Infinity
}
)
;
return
true
;
}
return
false
;
}
if
(
!
fixupInfo
.
fixedURI
|
|
fixupInfo
.
keywordAsSent
)
return
false
;
let
uri
=
fixupInfo
.
fixedURI
;
let
hostExpected
=
[
"
http
"
"
https
"
"
ftp
"
"
chrome
"
]
.
includes
(
uri
.
scheme
)
;
if
(
hostExpected
&
&
!
uri
.
host
)
return
false
;
let
escapedURL
=
uri
.
displaySpec
;
let
displayURL
=
Services
.
textToSubURI
.
unEscapeURIForUI
(
"
UTF
-
8
"
escapedURL
)
;
let
value
=
PlacesUtils
.
mozActionURI
(
"
visiturl
"
{
url
:
escapedURL
input
:
searchUrl
}
)
;
let
match
=
{
value
comment
:
displayURL
style
:
"
action
visiturl
"
frecency
:
Infinity
}
;
if
(
hostExpected
&
&
(
searchUrl
.
endsWith
(
"
/
"
)
|
|
uri
.
pathQueryRef
.
length
>
1
)
)
{
match
.
icon
=
page
-
icon
:
{
uri
.
prePath
}
/
;
}
this
.
_addMatch
(
match
)
;
return
true
;
}
_onResultRow
(
row
cancel
)
{
let
queryType
=
row
.
getResultByIndex
(
QUERYINDEX_QUERYTYPE
)
;
switch
(
queryType
)
{
case
QUERYTYPE_AUTOFILL_ORIGIN
:
this
.
_result
.
setDefaultIndex
(
0
)
;
this
.
_addOriginAutofillMatch
(
row
)
;
break
;
case
QUERYTYPE_AUTOFILL_URL
:
this
.
_result
.
setDefaultIndex
(
0
)
;
this
.
_addURLAutofillMatch
(
row
)
;
break
;
case
QUERYTYPE_ADAPTIVE
:
this
.
_addAdaptiveQueryMatch
(
row
)
;
break
;
case
QUERYTYPE_FILTERED
:
this
.
_addFilteredQueryMatch
(
row
)
;
break
;
}
let
count
=
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
]
+
this
.
_counts
[
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
]
;
if
(
!
this
.
pending
|
|
count
>
=
this
.
_maxResults
)
{
cancel
(
)
;
}
}
_maybeRestyleSearchMatch
(
match
)
{
let
parseResult
=
PlacesSearchAutocompleteProvider
.
parseSubmissionURL
(
match
.
value
)
;
if
(
!
parseResult
)
{
return
;
}
let
terms
=
parseResult
.
terms
.
toLowerCase
(
)
;
if
(
this
.
_searchTokens
.
length
>
0
&
&
this
.
_searchTokens
.
every
(
token
=
>
!
terms
.
includes
(
token
.
value
)
)
)
{
return
;
}
match
.
value
=
PlacesUtils
.
mozActionURI
(
"
searchengine
"
{
engineName
:
parseResult
.
engineName
input
:
parseResult
.
terms
searchQuery
:
parseResult
.
terms
}
)
;
match
.
comment
=
parseResult
.
engineName
;
match
.
icon
=
match
.
icon
|
|
match
.
iconUrl
;
match
.
style
=
"
action
searchengine
favicon
"
;
}
_addMatch
(
match
)
{
if
(
typeof
match
.
frecency
!
=
"
number
"
)
throw
new
Error
(
"
Frecency
not
provided
"
)
;
if
(
this
.
_addingHeuristicFirstMatch
)
match
.
type
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
;
else
if
(
typeof
match
.
type
!
=
"
string
"
)
match
.
type
=
UrlbarUtils
.
RESULT_GROUP
.
GENERAL
;
if
(
!
this
.
pending
)
return
;
match
.
style
=
match
.
style
|
|
"
favicon
"
;
if
(
UrlbarPrefs
.
get
(
"
restyleSearches
"
)
&
&
match
.
style
=
=
"
favicon
"
)
{
this
.
_maybeRestyleSearchMatch
(
match
)
;
}
if
(
this
.
_addingHeuristicFirstMatch
)
{
match
.
style
+
=
"
heuristic
"
;
}
match
.
icon
=
match
.
icon
|
|
"
"
;
match
.
finalCompleteValue
=
match
.
finalCompleteValue
|
|
"
"
;
let
{
index
replace
}
=
this
.
_getInsertIndexForMatch
(
match
)
;
if
(
index
=
=
-
1
)
return
;
if
(
replace
)
{
this
.
_result
.
removeMatchAt
(
index
)
;
}
this
.
_result
.
insertMatchAt
(
index
match
.
value
match
.
comment
match
.
icon
match
.
style
match
.
finalCompleteValue
)
;
this
.
_currentMatchCount
+
+
;
this
.
_counts
[
match
.
type
]
+
+
;
if
(
!
this
.
_disableTelemetry
)
{
if
(
this
.
_currentMatchCount
=
=
1
)
TelemetryStopwatch
.
finish
(
TELEMETRY_1ST_RESULT
this
)
;
if
(
this
.
_currentMatchCount
=
=
6
)
TelemetryStopwatch
.
finish
(
TELEMETRY_6_FIRST_RESULTS
this
)
;
}
this
.
notifyResult
(
true
match
.
type
=
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
)
;
}
_getInsertIndexForMatch
(
match
)
{
let
[
urlMapKey
action
]
=
makeKeyForMatch
(
match
)
;
if
(
(
match
.
placeId
&
&
this
.
_usedPlaceIds
.
has
(
match
.
placeId
)
)
|
|
this
.
_usedURLs
.
some
(
e
=
>
ObjectUtils
.
deepEqual
(
e
.
key
urlMapKey
)
)
)
{
let
isDupe
=
true
;
if
(
action
&
&
[
"
switchtab
"
"
remotetab
"
]
.
includes
(
action
.
type
)
)
{
for
(
let
i
=
0
;
i
<
this
.
_usedURLs
.
length
;
+
+
i
)
{
let
{
key
:
matchKey
action
:
matchAction
type
:
matchType
}
=
this
.
_usedURLs
[
i
]
;
if
(
ObjectUtils
.
deepEqual
(
matchKey
urlMapKey
)
)
{
isDupe
=
true
;
if
(
matchType
=
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
&
&
action
.
type
=
=
"
switchtab
"
)
{
isDupe
=
false
;
continue
;
}
if
(
!
matchAction
|
|
action
.
type
=
=
"
switchtab
"
)
{
this
.
_usedURLs
[
i
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
}
;
return
{
index
:
i
replace
:
true
}
;
}
break
;
}
}
}
if
(
isDupe
)
{
return
{
index
:
-
1
replace
:
false
}
;
}
}
if
(
match
.
placeId
)
this
.
_usedPlaceIds
.
add
(
match
.
placeId
)
;
let
index
=
0
;
if
(
!
this
.
_buckets
)
{
let
buckets
=
match
.
type
=
=
UrlbarUtils
.
RESULT_GROUP
.
HEURISTIC
&
&
match
.
style
.
includes
(
"
searchengine
"
)
?
UrlbarPrefs
.
get
(
"
matchBucketsSearch
"
)
:
UrlbarPrefs
.
get
(
"
matchBuckets
"
)
;
this
.
_buckets
=
buckets
.
map
(
(
[
type
available
]
)
=
>
(
{
type
available
insertIndex
:
0
count
:
0
}
)
)
;
if
(
this
.
_previousSearchMatchTypes
.
length
>
0
)
{
for
(
let
type
of
this
.
_previousSearchMatchTypes
)
{
for
(
let
bucket
of
this
.
_buckets
)
{
if
(
type
=
=
bucket
.
type
&
&
bucket
.
count
<
bucket
.
available
)
{
bucket
.
count
+
+
;
break
;
}
}
}
}
}
let
replace
=
0
;
for
(
let
bucket
of
this
.
_buckets
)
{
if
(
match
.
type
!
=
bucket
.
type
|
|
!
bucket
.
available
)
{
index
+
=
bucket
.
count
;
continue
;
}
index
+
=
bucket
.
insertIndex
;
bucket
.
available
-
-
;
if
(
bucket
.
insertIndex
<
bucket
.
count
)
{
replace
=
true
;
}
else
{
bucket
.
count
+
+
;
}
bucket
.
insertIndex
+
+
;
break
;
}
this
.
_usedURLs
[
index
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
}
;
return
{
index
replace
}
;
}
_cleanUpNonCurrentMatches
(
type
notify
=
true
)
{
if
(
this
.
_previousSearchMatchTypes
.
length
=
=
0
|
|
!
this
.
pending
)
return
;
let
index
=
0
;
let
changed
=
false
;
if
(
!
this
.
_buckets
)
{
while
(
this
.
_previousSearchMatchTypes
.
length
&
&
(
!
type
|
|
this
.
_previousSearchMatchTypes
[
0
]
=
=
type
)
)
{
this
.
_previousSearchMatchTypes
.
shift
(
)
;
this
.
_result
.
removeMatchAt
(
0
)
;
changed
=
true
;
}
}
else
{
for
(
let
bucket
of
this
.
_buckets
)
{
if
(
type
&
&
bucket
.
type
!
=
type
)
{
index
+
=
bucket
.
count
;
continue
;
}
index
+
=
bucket
.
insertIndex
;
while
(
bucket
.
count
>
bucket
.
insertIndex
)
{
this
.
_result
.
removeMatchAt
(
index
)
;
changed
=
true
;
bucket
.
count
-
-
;
}
}
}
if
(
changed
&
&
notify
)
{
this
.
notifyResult
(
true
)
;
}
}
cleanUpRestrictNonCurrentMatches
(
)
{
if
(
this
.
hasBehavior
(
"
restrict
"
)
&
&
this
.
_previousSearchMatchTypes
.
length
>
0
)
{
for
(
let
type
of
new
Set
(
this
.
_previousSearchMatchTypes
)
)
{
if
(
this
.
_counts
[
type
]
=
=
0
)
{
this
.
_cleanUpNonCurrentMatches
(
type
false
)
;
}
}
}
}
_addOriginAutofillMatch
(
row
)
{
this
.
_addAutofillMatch
(
row
.
getResultByIndex
(
QUERYINDEX_ORIGIN_AUTOFILLED_VALUE
)
row
.
getResultByIndex
(
QUERYINDEX_ORIGIN_URL
)
row
.
getResultByIndex
(
QUERYINDEX_ORIGIN_FRECENCY
)
)
;
}
_addURLAutofillMatch
(
row
)
{
let
url
=
row
.
getResultByIndex
(
QUERYINDEX_URL_URL
)
;
let
strippedURL
=
row
.
getResultByIndex
(
QUERYINDEX_URL_STRIPPED_URL
)
;
let
value
;
let
strippedURLIndex
=
url
.
indexOf
(
strippedURL
)
;
let
strippedPrefix
=
url
.
substr
(
0
strippedURLIndex
)
;
let
nextSlashIndex
=
url
.
indexOf
(
"
/
"
strippedURLIndex
+
strippedURL
.
length
-
1
)
;
if
(
nextSlashIndex
=
=
-
1
)
{
value
=
url
.
substr
(
strippedURLIndex
)
;
}
else
{
value
=
url
.
substring
(
strippedURLIndex
nextSlashIndex
+
1
)
;
}
this
.
_addAutofillMatch
(
value
strippedPrefix
+
value
row
.
getResultByIndex
(
QUERYINDEX_URL_FRECENCY
)
)
;
}
_addAutofillMatch
(
autofilledValue
finalCompleteValue
frecency
=
Infinity
extraStyles
=
[
]
)
{
let
comment
=
stripHttpAndTrim
(
finalCompleteValue
!
this
.
_searchString
.
includes
(
"
/
"
)
)
;
this
.
_addMatch
(
{
value
:
this
.
_strippedPrefix
+
autofilledValue
finalCompleteValue
comment
frecency
style
:
[
"
autofill
"
]
.
concat
(
extraStyles
)
.
join
(
"
"
)
icon
:
iconHelper
(
finalCompleteValue
)
}
)
;
}
_addAdaptiveQueryMatch
(
row
)
{
if
(
this
.
_adaptiveCount
<
Math
.
ceil
(
this
.
_maxResults
/
4
)
)
{
this
.
_addFilteredQueryMatch
(
row
)
;
}
else
{
this
.
_extraAdaptiveRows
.
push
(
row
)
;
}
this
.
_adaptiveCount
+
+
;
}
_addFilteredQueryMatch
(
row
)
{
let
match
=
{
}
;
match
.
placeId
=
row
.
getResultByIndex
(
QUERYINDEX_PLACEID
)
;
let
escapedURL
=
row
.
getResultByIndex
(
QUERYINDEX_URL
)
;
let
openPageCount
=
row
.
getResultByIndex
(
QUERYINDEX_SWITCHTAB
)
|
|
0
;
let
historyTitle
=
row
.
getResultByIndex
(
QUERYINDEX_TITLE
)
|
|
"
"
;
let
bookmarked
=
row
.
getResultByIndex
(
QUERYINDEX_BOOKMARKED
)
;
let
bookmarkTitle
=
bookmarked
?
row
.
getResultByIndex
(
QUERYINDEX_BOOKMARKTITLE
)
:
null
;
let
tags
=
row
.
getResultByIndex
(
QUERYINDEX_TAGS
)
|
|
"
"
;
let
frecency
=
row
.
getResultByIndex
(
QUERYINDEX_FRECENCY
)
;
let
url
=
escapedURL
;
let
action
=
null
;
if
(
this
.
_enableActions
&
&
openPageCount
>
0
&
&
this
.
hasBehavior
(
"
openpage
"
)
)
{
url
=
PlacesUtils
.
mozActionURI
(
"
switchtab
"
{
url
:
escapedURL
}
)
;
action
=
"
switchtab
"
;
if
(
frecency
=
=
null
)
frecency
=
FRECENCY_DEFAULT
;
}
let
title
=
bookmarkTitle
|
|
historyTitle
;
let
showTags
=
!
!
tags
&
&
!
action
;
if
(
this
.
hasBehavior
(
"
history
"
)
&
&
!
this
.
hasBehavior
(
"
bookmark
"
)
&
&
!
showTags
)
{
showTags
=
false
;
match
.
style
=
"
favicon
"
;
}
if
(
showTags
)
{
title
+
=
TITLE_TAGS_SEPARATOR
+
tags
;
}
if
(
!
match
.
style
)
{
if
(
showTags
)
{
match
.
style
=
this
.
hasBehavior
(
"
bookmark
"
)
?
"
bookmark
-
tag
"
:
"
tag
"
;
}
else
if
(
bookmarked
)
{
match
.
style
=
"
bookmark
"
;
}
}
if
(
action
)
match
.
style
=
"
action
"
+
action
;
match
.
value
=
url
;
match
.
comment
=
title
;
match
.
icon
=
iconHelper
(
escapedURL
)
;
match
.
frecency
=
frecency
;
this
.
_addMatch
(
match
)
;
}
get
_suggestionPrefQuery
(
)
{
if
(
!
this
.
hasBehavior
(
"
restrict
"
)
&
&
this
.
hasBehavior
(
"
history
"
)
&
&
this
.
hasBehavior
(
"
bookmark
"
)
)
{
return
defaultQuery
(
)
;
}
let
conditions
=
[
]
;
if
(
this
.
hasBehavior
(
"
history
"
)
)
{
conditions
.
push
(
"
+
h
.
visit_count
>
0
"
)
;
}
if
(
this
.
hasBehavior
(
"
bookmark
"
)
)
{
conditions
.
push
(
"
bookmarked
"
)
;
}
if
(
this
.
hasBehavior
(
"
tag
"
)
)
{
conditions
.
push
(
"
tags
NOTNULL
"
)
;
}
return
conditions
.
length
?
defaultQuery
(
"
AND
"
+
conditions
.
join
(
"
AND
"
)
)
:
defaultQuery
(
)
;
}
get
_keywordSubstitutedSearchString
(
)
{
let
tokens
=
this
.
_searchTokens
.
map
(
t
=
>
t
.
value
)
;
if
(
this
.
_keywordSubstitute
)
{
tokens
=
[
this
.
_keywordSubstitute
.
.
.
tokens
.
slice
(
1
)
]
;
}
return
tokens
.
join
(
"
"
)
;
}
get
_searchQuery
(
)
{
let
query
=
this
.
_suggestionPrefQuery
;
return
[
query
{
parent
:
PlacesUtils
.
tagsFolderId
query_type
:
QUERYTYPE_FILTERED
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
searchString
:
this
.
_keywordSubstitutedSearchString
userContextId
:
this
.
_userContextId
maxResults
:
this
.
_maxResults
}
]
;
}
get
_switchToTabQuery
(
)
{
return
[
SQL_SWITCHTAB_QUERY
{
query_type
:
QUERYTYPE_FILTERED
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
searchString
:
this
.
_keywordSubstitutedSearchString
userContextId
:
this
.
_userContextId
maxResults
:
this
.
_maxResults
}
]
;
}
get
_adaptiveQuery
(
)
{
return
[
SQL_ADAPTIVE_QUERY
{
parent
:
PlacesUtils
.
tagsFolderId
search_string
:
this
.
_searchString
query_type
:
QUERYTYPE_ADAPTIVE
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
userContextId
:
this
.
_userContextId
maxResults
:
this
.
_maxResults
}
]
;
}
get
_shouldAutofill
(
)
{
if
(
!
UrlbarPrefs
.
get
(
"
autoFill
"
)
)
return
false
;
if
(
this
.
_searchTokens
.
length
!
=
1
)
return
false
;
if
(
!
this
.
hasBehavior
(
"
history
"
)
&
&
!
this
.
hasBehavior
(
"
bookmark
"
)
)
return
false
;
if
(
this
.
hasBehavior
(
"
title
"
)
|
|
this
.
hasBehavior
(
"
tag
"
)
)
return
false
;
if
(
REGEXP_SPACES
.
test
(
this
.
_originalSearchString
)
)
return
false
;
if
(
this
.
_searchString
.
length
=
=
0
)
return
false
;
if
(
this
.
_prohibitAutoFill
)
return
false
;
return
true
;
}
get
_originQuery
(
)
{
let
searchStr
=
this
.
_searchString
.
endsWith
(
"
/
"
)
?
this
.
_searchString
.
slice
(
0
-
1
)
:
this
.
_searchString
;
let
opts
=
{
query_type
:
QUERYTYPE_AUTOFILL_ORIGIN
searchString
:
searchStr
.
toLowerCase
(
)
stddevMultiplier
:
UrlbarPrefs
.
get
(
"
autoFill
.
stddevMultiplier
"
)
}
;
let
bookmarked
=
this
.
hasBehavior
(
"
bookmark
"
)
&
&
!
this
.
hasBehavior
(
"
history
"
)
;
if
(
this
.
_strippedPrefix
)
{
opts
.
prefix
=
this
.
_strippedPrefix
;
if
(
bookmarked
)
{
return
[
SQL_ORIGIN_PREFIX_BOOKMARKED_QUERY
opts
]
;
}
return
[
SQL_ORIGIN_PREFIX_QUERY
opts
]
;
}
if
(
bookmarked
)
{
return
[
SQL_ORIGIN_BOOKMARKED_QUERY
opts
]
;
}
return
[
SQL_ORIGIN_QUERY
opts
]
;
}
get
_urlQuery
(
)
{
if
(
!
this
.
_urlQueryHostRegexp
)
{
this
.
_urlQueryHostRegexp
=
/
^
[
^
/
:
?
]
+
/
;
}
let
hostMatch
=
this
.
_urlQueryHostRegexp
.
exec
(
this
.
_searchString
)
;
if
(
!
hostMatch
)
{
return
[
null
null
]
;
}
let
host
=
hostMatch
[
0
]
.
toLowerCase
(
)
;
let
revHost
=
host
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
+
"
.
"
;
let
strippedURL
=
this
.
_trimmedOriginalSearchString
;
if
(
this
.
_strippedPrefix
)
{
strippedURL
=
strippedURL
.
substr
(
this
.
_strippedPrefix
.
length
)
;
}
strippedURL
=
host
+
strippedURL
.
substr
(
host
.
length
)
;
let
opts
=
{
query_type
:
QUERYTYPE_AUTOFILL_URL
revHost
strippedURL
}
;
let
bookmarked
=
this
.
hasBehavior
(
"
bookmark
"
)
&
&
!
this
.
hasBehavior
(
"
history
"
)
;
if
(
this
.
_strippedPrefix
)
{
opts
.
prefix
=
this
.
_strippedPrefix
;
if
(
bookmarked
)
{
return
[
SQL_URL_PREFIX_BOOKMARKED_QUERY
opts
]
;
}
return
[
SQL_URL_PREFIX_QUERY
opts
]
;
}
if
(
bookmarked
)
{
return
[
SQL_URL_BOOKMARKED_QUERY
opts
]
;
}
return
[
SQL_URL_QUERY
opts
]
;
}
_notifyTimer
:
null
_notifyDelaysCount
:
0
notifyResult
(
searchOngoing
skipDelay
=
false
)
{
let
notify
=
(
)
=
>
{
if
(
!
this
.
pending
)
return
;
this
.
_notifyDelaysCount
=
0
;
let
resultCode
=
this
.
_currentMatchCount
?
"
RESULT_SUCCESS
"
:
"
RESULT_NOMATCH
"
;
if
(
searchOngoing
)
{
resultCode
+
=
"
_ONGOING
"
;
}
let
result
=
this
.
_result
;
result
.
setSearchResult
(
Ci
.
nsIAutoCompleteResult
[
resultCode
]
)
;
this
.
_listener
.
onSearchResult
(
this
.
_autocompleteSearch
result
)
;
if
(
!
searchOngoing
)
{
this
.
_listener
=
null
;
this
.
_autocompleteSearch
=
null
;
this
.
stop
(
)
;
}
}
;
if
(
this
.
_notifyTimer
)
{
this
.
_notifyTimer
.
cancel
(
)
;
}
if
(
skipDelay
|
|
this
.
_notifyDelaysCount
>
3
)
{
notify
(
)
;
}
else
{
this
.
_notifyDelaysCount
+
+
;
this
.
_notifyTimer
=
setTimeout
(
notify
NOTIFYRESULT_DELAY_MS
)
;
}
}
}
;
function
UnifiedComplete
(
)
{
if
(
UrlbarPrefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
ProfileAgeCreatedPromise
;
fetch
(
"
chrome
:
/
/
global
/
content
/
unifiedcomplete
-
top
-
urls
.
json
"
)
.
then
(
response
=
>
response
.
json
(
)
)
.
then
(
sites
=
>
PreloadedSiteStorage
.
populate
(
sites
)
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
}
}
UnifiedComplete
.
prototype
=
{
_promiseDatabase
:
null
getDatabaseHandle
(
)
{
if
(
!
this
.
_promiseDatabase
)
{
this
.
_promiseDatabase
=
(
async
(
)
=
>
{
let
conn
=
await
PlacesUtils
.
promiseLargeCacheDBConnection
(
)
;
try
{
Sqlite
.
shutdown
.
addBlocker
(
"
Places
UnifiedComplete
.
js
closing
"
(
)
=
>
{
this
.
_currentSearch
=
null
;
}
)
;
}
catch
(
ex
)
{
throw
ex
;
}
await
UrlbarProviderOpenTabs
.
promiseDb
(
)
;
return
conn
;
}
)
(
)
.
catch
(
ex
=
>
{
dump
(
"
Couldn
'
t
get
database
handle
:
"
+
ex
+
"
\
n
"
)
;
Cu
.
reportError
(
ex
)
;
}
)
;
}
return
this
.
_promiseDatabase
;
}
populatePreloadedSiteStorage
(
json
)
{
PreloadedSiteStorage
.
populate
(
json
)
;
}
startSearch
(
searchString
searchParam
acPreviousResult
listener
)
{
if
(
this
.
_currentSearch
)
{
this
.
stopSearch
(
)
;
}
let
prohibitSearchSuggestions
=
!
!
this
.
_lastLowResultsSearchSuggestion
&
&
searchString
.
length
>
this
.
_lastLowResultsSearchSuggestion
.
length
&
&
searchString
.
startsWith
(
this
.
_lastLowResultsSearchSuggestion
)
;
let
insertMethod
=
searchParam
.
match
(
REGEXP_INSERT_METHOD
)
;
insertMethod
=
insertMethod
?
parseInt
(
insertMethod
[
1
]
)
:
UrlbarPrefs
.
get
(
"
insertMethod
"
)
;
let
previousResult
=
null
;
if
(
this
.
_currentSearch
&
&
insertMethod
!
=
UrlbarUtils
.
INSERTMETHOD
.
APPEND
)
{
let
result
=
this
.
_currentSearch
.
_result
;
let
previousSearchString
=
result
.
searchString
;
let
stringsRelated
=
previousSearchString
.
length
>
0
&
&
searchString
.
length
>
0
&
&
(
previousSearchString
.
includes
(
searchString
)
|
|
searchString
.
includes
(
previousSearchString
)
)
;
if
(
insertMethod
=
=
UrlbarUtils
.
INSERTMETHOD
.
MERGE
|
|
stringsRelated
)
{
previousResult
=
result
;
}
}
let
search
=
this
.
_currentSearch
=
new
Search
(
searchString
searchParam
listener
this
prohibitSearchSuggestions
previousResult
)
;
this
.
getDatabaseHandle
(
)
.
then
(
conn
=
>
search
.
execute
(
conn
)
)
.
catch
(
ex
=
>
{
dump
(
Query
failed
:
{
ex
}
\
n
)
;
Cu
.
reportError
(
ex
)
;
}
)
.
then
(
(
)
=
>
{
if
(
search
=
=
this
.
_currentSearch
)
{
this
.
finishSearch
(
true
)
;
}
}
)
;
}
stopSearch
(
)
{
if
(
this
.
_currentSearch
)
{
this
.
_currentSearch
.
stop
(
)
;
}
this
.
finishSearch
(
)
;
}
finishSearch
(
notify
=
false
)
{
if
(
!
this
.
_disableTelemetry
)
{
TelemetryStopwatch
.
cancel
(
TELEMETRY_1ST_RESULT
this
)
;
TelemetryStopwatch
.
cancel
(
TELEMETRY_6_FIRST_RESULTS
this
)
;
}
let
search
=
this
.
_currentSearch
;
if
(
!
search
)
return
;
this
.
_lastLowResultsSearchSuggestion
=
search
.
_lastLowResultsSearchSuggestion
;
if
(
!
notify
|
|
!
search
.
pending
)
return
;
search
.
cleanUpRestrictNonCurrentMatches
(
)
;
search
.
notifyResult
(
false
)
;
}
get
searchType
(
)
{
return
Ci
.
nsIAutoCompleteSearchDescriptor
.
SEARCH_TYPE_IMMEDIATE
;
}
get
clearingAutoFillSearchesAgain
(
)
{
return
true
;
}
classID
:
Components
.
ID
(
"
f964a319
-
397a
-
4d21
-
8be6
-
5cdd1ee3e3ae
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteSearch
Ci
.
nsIAutoCompleteSearchDescriptor
Ci
.
mozIPlacesAutoComplete
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
var
EXPORTED_SYMBOLS
=
[
"
UnifiedComplete
"
]
;
