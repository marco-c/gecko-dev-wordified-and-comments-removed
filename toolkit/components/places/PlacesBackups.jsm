var
EXPORTED_SYMBOLS
=
[
"
PlacesBackups
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
BookmarkJSONUtils
:
"
resource
:
/
/
gre
/
modules
/
BookmarkJSONUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
filenamesRegex
"
(
)
=
>
/
^
bookmarks
-
(
[
0
-
9
-
]
+
)
(
?
:
_
(
[
0
-
9
]
+
)
)
{
0
1
}
(
?
:
_
(
[
a
-
z0
-
9
=
+
-
]
{
24
}
)
)
{
0
1
}
\
.
(
json
(
lz4
)
?
)
/
i
)
;
async
function
limitBackups
(
aMaxBackups
backupFiles
)
{
if
(
typeof
aMaxBackups
=
=
"
number
"
&
&
aMaxBackups
>
-
1
&
&
backupFiles
.
length
>
=
aMaxBackups
)
{
let
numberOfBackupsToDelete
=
backupFiles
.
length
-
aMaxBackups
;
while
(
numberOfBackupsToDelete
-
-
)
{
let
oldestBackup
=
backupFiles
.
pop
(
)
;
await
OS
.
File
.
remove
(
oldestBackup
)
;
}
}
}
function
appendMetaDataToFilename
(
aFilename
aMetaData
)
{
let
matches
=
aFilename
.
match
(
filenamesRegex
)
;
return
"
bookmarks
-
"
+
matches
[
1
]
+
"
_
"
+
aMetaData
.
count
+
"
_
"
+
aMetaData
.
hash
+
"
.
"
+
matches
[
4
]
;
}
function
getHashFromFilename
(
aFilename
)
{
let
matches
=
aFilename
.
match
(
filenamesRegex
)
;
if
(
matches
&
&
matches
[
3
]
)
return
matches
[
3
]
;
return
null
;
}
function
isFilenameWithSameDate
(
aSourceName
aTargetName
)
{
let
sourceMatches
=
aSourceName
.
match
(
filenamesRegex
)
;
let
targetMatches
=
aTargetName
.
match
(
filenamesRegex
)
;
return
sourceMatches
&
&
targetMatches
&
&
sourceMatches
[
1
]
=
=
targetMatches
[
1
]
;
}
function
getBackupFileForSameDate
(
aFilename
)
{
return
(
async
function
(
)
{
let
backupFiles
=
await
PlacesBackups
.
getBackupFiles
(
)
;
for
(
let
backupFile
of
backupFiles
)
{
if
(
isFilenameWithSameDate
(
OS
.
Path
.
basename
(
backupFile
)
aFilename
)
)
return
backupFile
;
}
return
null
;
}
)
(
)
;
}
var
PlacesBackups
=
{
get
filenamesRegex
(
)
{
return
filenamesRegex
;
}
getBackupFolder
:
function
PB_getBackupFolder
(
)
{
return
(
async
(
)
=
>
{
if
(
this
.
_backupFolder
)
{
return
this
.
_backupFolder
;
}
let
profileDir
=
OS
.
Constants
.
Path
.
profileDir
;
let
backupsDirPath
=
OS
.
Path
.
join
(
profileDir
this
.
profileRelativeFolderPath
)
;
await
OS
.
File
.
makeDir
(
backupsDirPath
{
ignoreExisting
:
true
}
)
;
return
this
.
_backupFolder
=
backupsDirPath
;
}
)
(
)
;
}
get
profileRelativeFolderPath
(
)
{
return
"
bookmarkbackups
"
;
}
getBackupFiles
:
function
PB_getBackupFiles
(
)
{
return
(
async
(
)
=
>
{
if
(
this
.
_backupFiles
)
return
this
.
_backupFiles
;
this
.
_backupFiles
=
[
]
;
let
backupFolderPath
=
await
this
.
getBackupFolder
(
)
;
let
iterator
=
new
OS
.
File
.
DirectoryIterator
(
backupFolderPath
)
;
await
iterator
.
forEach
(
aEntry
=
>
{
if
(
aEntry
.
name
.
endsWith
(
"
.
tmp
"
)
)
{
OS
.
File
.
remove
(
aEntry
.
path
)
;
return
undefined
;
}
if
(
filenamesRegex
.
test
(
aEntry
.
name
)
)
{
let
filePath
=
aEntry
.
path
;
if
(
this
.
getDateForFile
(
filePath
)
>
new
Date
(
)
)
{
return
OS
.
File
.
remove
(
filePath
)
;
}
this
.
_backupFiles
.
push
(
filePath
)
;
}
return
undefined
;
}
)
;
iterator
.
close
(
)
;
this
.
_backupFiles
.
sort
(
(
a
b
)
=
>
{
let
aDate
=
this
.
getDateForFile
(
a
)
;
let
bDate
=
this
.
getDateForFile
(
b
)
;
return
bDate
-
aDate
;
}
)
;
return
this
.
_backupFiles
;
}
)
(
)
;
}
toISODateString
:
function
toISODateString
(
dateObj
)
{
if
(
!
dateObj
|
|
dateObj
.
constructor
.
name
!
=
"
Date
"
|
|
!
dateObj
.
getTime
(
)
)
throw
new
Error
(
"
invalid
date
object
"
)
;
let
padDate
=
val
=
>
(
"
0
"
+
val
)
.
substr
(
-
2
2
)
;
return
[
dateObj
.
getFullYear
(
)
padDate
(
dateObj
.
getMonth
(
)
+
1
)
padDate
(
dateObj
.
getDate
(
)
)
]
.
join
(
"
-
"
)
;
}
getFilenameForDate
:
function
PB_getFilenameForDate
(
aDateObj
aCompress
)
{
let
dateObj
=
aDateObj
|
|
new
Date
(
)
;
return
"
bookmarks
-
"
+
PlacesBackups
.
toISODateString
(
dateObj
)
+
"
.
json
"
+
(
aCompress
?
"
lz4
"
:
"
"
)
;
}
getDateForFile
:
function
PB_getDateForFile
(
aBackupFile
)
{
let
filename
=
OS
.
Path
.
basename
(
aBackupFile
)
;
let
matches
=
filename
.
match
(
filenamesRegex
)
;
if
(
!
matches
)
throw
new
Error
(
Invalid
backup
file
name
:
{
filename
}
)
;
return
new
Date
(
matches
[
1
]
.
replace
(
/
-
/
g
"
/
"
)
)
;
}
getMostRecentBackup
:
function
PB_getMostRecentBackup
(
)
{
return
(
async
(
)
=
>
{
let
entries
=
await
this
.
getBackupFiles
(
)
;
for
(
let
entry
of
entries
)
{
let
rx
=
/
\
.
json
(
lz4
)
?
/
;
if
(
OS
.
Path
.
basename
(
entry
)
.
match
(
rx
)
)
{
return
entry
;
}
}
return
null
;
}
)
(
)
;
}
async
saveBookmarksToJSONFile
(
aFilePath
)
{
let
{
count
:
nodeCount
hash
:
hash
}
=
await
BookmarkJSONUtils
.
exportToFile
(
aFilePath
)
;
let
backupFolderPath
=
await
this
.
getBackupFolder
(
)
;
if
(
OS
.
Path
.
dirname
(
aFilePath
)
=
=
backupFolderPath
)
{
if
(
!
this
.
_backupFiles
)
{
await
this
.
getBackupFiles
(
)
;
}
this
.
_backupFiles
.
unshift
(
aFilePath
)
;
}
else
{
let
aMaxBackup
=
Services
.
prefs
.
getIntPref
(
"
browser
.
bookmarks
.
max_backups
"
)
;
if
(
aMaxBackup
=
=
=
0
)
{
if
(
!
this
.
_backupFiles
)
await
this
.
getBackupFiles
(
)
;
limitBackups
(
aMaxBackup
this
.
_backupFiles
)
;
return
nodeCount
;
}
let
mostRecentBackupFile
=
await
this
.
getMostRecentBackup
(
)
;
if
(
!
mostRecentBackupFile
|
|
hash
!
=
getHashFromFilename
(
OS
.
Path
.
basename
(
mostRecentBackupFile
)
)
)
{
let
name
=
this
.
getFilenameForDate
(
undefined
true
)
;
let
newFilename
=
appendMetaDataToFilename
(
name
{
count
:
nodeCount
hash
}
)
;
let
newFilePath
=
OS
.
Path
.
join
(
backupFolderPath
newFilename
)
;
let
backupFile
=
await
getBackupFileForSameDate
(
name
)
;
if
(
backupFile
)
{
await
OS
.
File
.
remove
(
backupFile
{
ignoreAbsent
:
true
}
)
;
if
(
!
this
.
_backupFiles
)
await
this
.
getBackupFiles
(
)
;
else
this
.
_backupFiles
.
shift
(
)
;
this
.
_backupFiles
.
unshift
(
newFilePath
)
;
}
else
{
if
(
!
this
.
_backupFiles
)
await
this
.
getBackupFiles
(
)
;
this
.
_backupFiles
.
unshift
(
newFilePath
)
;
}
let
jsonString
=
await
OS
.
File
.
read
(
aFilePath
)
;
await
OS
.
File
.
writeAtomic
(
newFilePath
jsonString
{
compression
:
"
lz4
"
}
)
;
await
limitBackups
(
aMaxBackup
this
.
_backupFiles
)
;
}
}
return
nodeCount
;
}
create
:
function
PB_create
(
aMaxBackups
aForceBackup
)
{
return
(
async
(
)
=
>
{
if
(
aMaxBackups
=
=
=
0
)
{
if
(
!
this
.
_backupFiles
)
await
this
.
getBackupFiles
(
)
;
await
limitBackups
(
0
this
.
_backupFiles
)
;
return
;
}
if
(
!
this
.
_backupFiles
)
await
this
.
getBackupFiles
(
)
;
let
newBackupFilename
=
this
.
getFilenameForDate
(
undefined
true
)
;
let
backupFile
=
await
getBackupFileForSameDate
(
newBackupFilename
)
;
if
(
backupFile
&
&
!
aForceBackup
)
return
;
if
(
backupFile
)
{
this
.
_backupFiles
.
shift
(
)
;
await
OS
.
File
.
remove
(
backupFile
{
ignoreAbsent
:
true
}
)
;
}
let
mostRecentBackupFile
=
await
this
.
getMostRecentBackup
(
)
;
let
mostRecentHash
=
mostRecentBackupFile
&
&
getHashFromFilename
(
OS
.
Path
.
basename
(
mostRecentBackupFile
)
)
;
let
backupFolder
=
await
this
.
getBackupFolder
(
)
;
let
newBackupFile
=
OS
.
Path
.
join
(
backupFolder
newBackupFilename
)
;
let
newFilenameWithMetaData
;
try
{
let
{
count
:
nodeCount
hash
:
hash
}
=
await
BookmarkJSONUtils
.
exportToFile
(
newBackupFile
{
compress
:
true
failIfHashIs
:
mostRecentHash
}
)
;
newFilenameWithMetaData
=
appendMetaDataToFilename
(
newBackupFilename
{
count
:
nodeCount
hash
}
)
;
}
catch
(
ex
)
{
if
(
!
ex
.
becauseSameHash
)
{
throw
ex
;
}
this
.
_backupFiles
.
shift
(
)
;
newBackupFile
=
mostRecentBackupFile
;
if
(
/
\
.
json
/
.
test
(
OS
.
Path
.
basename
(
mostRecentBackupFile
)
)
)
newBackupFilename
=
this
.
getFilenameForDate
(
)
;
newFilenameWithMetaData
=
appendMetaDataToFilename
(
newBackupFilename
{
count
:
this
.
getBookmarkCountForFile
(
mostRecentBackupFile
)
hash
:
mostRecentHash
}
)
;
}
let
newBackupFileWithMetadata
=
OS
.
Path
.
join
(
backupFolder
newFilenameWithMetaData
)
;
await
OS
.
File
.
move
(
newBackupFile
newBackupFileWithMetadata
)
;
this
.
_backupFiles
.
unshift
(
newBackupFileWithMetadata
)
;
await
limitBackups
(
aMaxBackups
this
.
_backupFiles
)
;
}
)
(
)
;
}
getBookmarkCountForFile
:
function
PB_getBookmarkCountForFile
(
aFilePath
)
{
let
count
=
null
;
let
filename
=
OS
.
Path
.
basename
(
aFilePath
)
;
let
matches
=
filename
.
match
(
filenamesRegex
)
;
if
(
matches
&
&
matches
[
2
]
)
count
=
matches
[
2
]
;
return
count
;
}
async
getBookmarksTree
(
)
{
let
startTime
=
Date
.
now
(
)
;
let
root
=
await
PlacesUtils
.
promiseBookmarksTree
(
PlacesUtils
.
bookmarks
.
rootGuid
{
includeItemIds
:
true
}
)
;
try
{
Services
.
telemetry
.
getHistogramById
(
"
PLACES_BACKUPS_BOOKMARKSTREE_MS
"
)
.
add
(
Date
.
now
(
)
-
startTime
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Unable
to
report
telemetry
.
"
)
;
}
return
[
root
root
.
itemsCount
]
;
}
}
;
