ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
TOPIC_PREF_CHANGED
=
"
nsPref
:
changed
"
;
const
TOPIC_DEBUG_START_EXPIRATION
=
"
places
-
debug
-
start
-
expiration
"
;
const
TOPIC_EXPIRATION_FINISHED
=
"
places
-
expiration
-
finished
"
;
const
TOPIC_IDLE_BEGIN
=
"
idle
"
;
const
TOPIC_IDLE_END
=
"
active
"
;
const
TOPIC_IDLE_DAILY
=
"
idle
-
daily
"
;
const
TOPIC_TESTING_MODE
=
"
testing
-
mode
"
;
const
TOPIC_TEST_INTERVAL_CHANGED
=
"
test
-
interval
-
changed
"
;
const
PREF_BRANCH
=
"
places
.
history
.
expiration
.
"
;
const
PREF_MAX_URIS
=
"
max_pages
"
;
const
PREF_MAX_URIS_NOTSET
=
-
1
;
const
PREF_READONLY_CALCULATED_MAX_URIS
=
"
transient_current_max_pages
"
;
const
PREF_INTERVAL_SECONDS
=
"
interval_seconds
"
;
const
PREF_INTERVAL_SECONDS_NOTSET
=
3
*
60
;
const
DATABASE_TO_MEMORY_PERC
=
4
;
const
DATABASE_TO_DISK_PERC
=
2
;
const
DATABASE_MAX_SIZE
=
73400320
;
const
MEMSIZE_FALLBACK_BYTES
=
268435456
;
const
DISKSIZE_FALLBACK_BYTES
=
268435456
;
const
EXPIRE_LIMIT_PER_STEP
=
6
;
const
EXPIRE_LIMIT_PER_LARGE_STEP_MULTIPLIER
=
10
;
const
EXPIRE_AGGRESSIVITY_MULTIPLIER
=
3
;
const
URIENTRY_AVG_SIZE
=
700
;
const
IDLE_TIMEOUT_SECONDS
=
5
*
60
;
const
OVERLIMIT_PAGES_THRESHOLD
=
1000
;
const
MSECS_PER_DAY
=
86400000
;
const
ANNOS_EXPIRE_POLICIES
=
[
{
bind
:
"
expire_days
"
type
:
Ci
.
nsIAnnotationService
.
EXPIRE_DAYS
time
:
7
*
1000
*
MSECS_PER_DAY
}
{
bind
:
"
expire_weeks
"
type
:
Ci
.
nsIAnnotationService
.
EXPIRE_WEEKS
time
:
30
*
1000
*
MSECS_PER_DAY
}
{
bind
:
"
expire_months
"
type
:
Ci
.
nsIAnnotationService
.
EXPIRE_MONTHS
time
:
180
*
1000
*
MSECS_PER_DAY
}
]
;
const
LIMIT
=
{
SMALL
:
0
LARGE
:
1
UNLIMITED
:
2
DEBUG
:
3
}
;
const
STATUS
=
{
CLEAN
:
0
DIRTY
:
1
UNKNOWN
:
2
}
;
const
ACTION
=
{
TIMED
:
1
<
<
0
TIMED_OVERLIMIT
:
1
<
<
1
SHUTDOWN_DIRTY
:
1
<
<
2
IDLE_DIRTY
:
1
<
<
3
IDLE_DAILY
:
1
<
<
4
DEBUG
:
1
<
<
5
}
;
const
EXPIRATION_QUERIES
=
{
QUERY_FIND_EXOTIC_VISITS_TO_EXPIRE
:
{
sql
:
INSERT
INTO
expiration_notify
(
v_id
url
guid
visit_date
reason
)
SELECT
v
.
id
h
.
url
h
.
guid
v
.
visit_date
"
exotic
"
FROM
moz_historyvisits
v
JOIN
moz_places
h
ON
h
.
id
=
v
.
place_id
WHERE
visit_date
<
strftime
(
'
%
s
'
'
now
'
'
localtime
'
'
start
of
day
'
'
-
60
days
'
'
utc
'
)
*
1000000
AND
(
LENGTH
(
h
.
url
)
>
255
OR
v
.
visit_type
=
7
)
ORDER
BY
v
.
visit_date
ASC
LIMIT
:
limit_visits
actions
:
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_FIND_VISITS_TO_EXPIRE
:
{
sql
:
INSERT
INTO
expiration_notify
(
v_id
url
guid
visit_date
expected_results
)
SELECT
v
.
id
h
.
url
h
.
guid
v
.
visit_date
:
limit_visits
FROM
moz_historyvisits
v
JOIN
moz_places
h
ON
h
.
id
=
v
.
place_id
WHERE
(
SELECT
COUNT
(
*
)
FROM
moz_places
)
>
:
max_uris
AND
visit_date
<
strftime
(
'
%
s
'
'
now
'
'
localtime
'
'
start
of
day
'
'
-
7
days
'
'
utc
'
)
*
1000000
ORDER
BY
v
.
visit_date
ASC
LIMIT
:
limit_visits
actions
:
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_VISITS
:
{
sql
:
DELETE
FROM
moz_historyvisits
WHERE
id
IN
(
SELECT
v_id
FROM
expiration_notify
WHERE
v_id
NOTNULL
)
actions
:
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_FIND_URIS_TO_EXPIRE
:
{
sql
:
INSERT
INTO
expiration_notify
(
p_id
url
guid
visit_date
)
SELECT
h
.
id
h
.
url
h
.
guid
h
.
last_visit_date
FROM
moz_places
h
LEFT
JOIN
moz_historyvisits
v
ON
h
.
id
=
v
.
place_id
WHERE
h
.
last_visit_date
IS
NULL
AND
h
.
foreign_count
=
0
AND
v
.
id
IS
NULL
AND
frecency
<
>
-
1
LIMIT
:
limit_uris
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_URIS
:
{
sql
:
DELETE
FROM
moz_places
WHERE
id
IN
(
SELECT
p_id
FROM
expiration_notify
WHERE
p_id
NOTNULL
)
AND
foreign_count
=
0
AND
last_visit_date
ISNULL
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_UPDATE_HOSTS
:
{
sql
:
DELETE
FROM
moz_updatehostsdelete_temp
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_FAVICONS_PAGES
:
{
sql
:
DELETE
FROM
moz_pages_w_icons
WHERE
page_url_hash
NOT
IN
(
SELECT
url_hash
FROM
moz_places
)
actions
:
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_FAVICONS
:
{
sql
:
DELETE
FROM
moz_icons
WHERE
id
IN
(
SELECT
id
FROM
moz_icons
WHERE
root
=
0
EXCEPT
SELECT
icon_id
FROM
moz_icons_to_pages
)
actions
:
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_ANNOS
:
{
sql
:
DELETE
FROM
moz_annos
WHERE
id
in
(
SELECT
a
.
id
FROM
moz_annos
a
LEFT
JOIN
moz_places
h
ON
a
.
place_id
=
h
.
id
WHERE
h
.
id
IS
NULL
LIMIT
:
limit_annos
)
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_ANNOS_WITH_POLICY
:
{
sql
:
DELETE
FROM
moz_annos
WHERE
(
expiration
=
:
expire_days
AND
:
expire_days_time
>
MAX
(
lastModified
dateAdded
)
)
OR
(
expiration
=
:
expire_weeks
AND
:
expire_weeks_time
>
MAX
(
lastModified
dateAdded
)
)
OR
(
expiration
=
:
expire_months
AND
:
expire_months_time
>
MAX
(
lastModified
dateAdded
)
)
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_ITEMS_ANNOS_WITH_POLICY
:
{
sql
:
DELETE
FROM
moz_items_annos
WHERE
(
expiration
=
:
expire_days
AND
:
expire_days_time
>
MAX
(
lastModified
dateAdded
)
)
OR
(
expiration
=
:
expire_weeks
AND
:
expire_weeks_time
>
MAX
(
lastModified
dateAdded
)
)
OR
(
expiration
=
:
expire_months
AND
:
expire_months_time
>
MAX
(
lastModified
dateAdded
)
)
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_ANNOS_WITH_HISTORY
:
{
sql
:
DELETE
FROM
moz_annos
WHERE
expiration
=
:
expire_with_history
AND
NOT
EXISTS
(
SELECT
id
FROM
moz_historyvisits
WHERE
place_id
=
moz_annos
.
place_id
LIMIT
1
)
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_ITEMS_ANNOS
:
{
sql
:
DELETE
FROM
moz_items_annos
WHERE
id
IN
(
SELECT
a
.
id
FROM
moz_items_annos
a
LEFT
JOIN
moz_bookmarks
b
ON
a
.
item_id
=
b
.
id
WHERE
b
.
id
IS
NULL
LIMIT
:
limit_annos
)
actions
:
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_ANNO_ATTRIBUTES
:
{
sql
:
DELETE
FROM
moz_anno_attributes
WHERE
id
IN
(
SELECT
n
.
id
FROM
moz_anno_attributes
n
LEFT
JOIN
moz_annos
a
ON
n
.
id
=
a
.
anno_attribute_id
LEFT
JOIN
moz_items_annos
t
ON
n
.
id
=
t
.
anno_attribute_id
WHERE
a
.
anno_attribute_id
IS
NULL
AND
t
.
anno_attribute_id
IS
NULL
LIMIT
:
limit_annos
)
actions
:
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_EXPIRE_INPUTHISTORY
:
{
sql
:
DELETE
FROM
moz_inputhistory
WHERE
place_id
IN
(
SELECT
i
.
place_id
FROM
moz_inputhistory
i
LEFT
JOIN
moz_places
h
ON
h
.
id
=
i
.
place_id
WHERE
h
.
id
IS
NULL
LIMIT
:
limit_inputhistory
)
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_SELECT_NOTIFICATIONS
:
{
sql
:
SELECT
url
guid
MAX
(
visit_date
)
AS
visit_date
MAX
(
IFNULL
(
MIN
(
p_id
1
)
MIN
(
v_id
0
)
)
)
AS
whole_entry
MAX
(
expected_results
)
AS
expected_results
(
SELECT
MAX
(
visit_date
)
FROM
expiration_notify
WHERE
reason
=
"
expired
"
AND
url
=
n
.
url
AND
p_id
ISNULL
)
AS
most_recent_expired_visit
FROM
expiration_notify
n
GROUP
BY
url
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
QUERY_DELETE_NOTIFICATIONS
:
{
sql
:
"
DELETE
FROM
expiration_notify
"
actions
:
ACTION
.
TIMED
|
ACTION
.
TIMED_OVERLIMIT
|
ACTION
.
SHUTDOWN_DIRTY
|
ACTION
.
IDLE_DIRTY
|
ACTION
.
IDLE_DAILY
|
ACTION
.
DEBUG
}
}
;
function
notify
(
observers
notification
args
=
[
]
)
{
for
(
let
observer
of
observers
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
function
nsPlacesExpiration
(
)
{
XPCOMUtils
.
defineLazyGetter
(
this
"
_db
"
function
(
)
{
let
db
=
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsPIPlacesDatabase
)
.
DBConnection
;
let
stmt
=
db
.
createAsyncStatement
(
CREATE
TEMP
TABLE
expiration_notify
(
id
INTEGER
PRIMARY
KEY
v_id
INTEGER
p_id
INTEGER
url
TEXT
NOT
NULL
guid
TEXT
NOT
NULL
visit_date
INTEGER
expected_results
INTEGER
NOT
NULL
DEFAULT
0
reason
TEXT
NOT
NULL
DEFAULT
"
expired
"
)
)
;
stmt
.
executeAsync
(
)
;
stmt
.
finalize
(
)
;
return
db
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
_idle
"
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
"
nsIIdleService
"
)
;
this
.
_prefBranch
=
Services
.
prefs
.
getBranch
(
PREF_BRANCH
)
;
this
.
_loadPrefsPromise
=
this
.
_loadPrefs
(
)
.
then
(
(
)
=
>
{
this
.
_prefBranch
.
addObserver
(
"
"
this
true
)
;
this
.
_newTimer
(
)
;
}
Cu
.
reportError
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_DEBUG_START_EXPIRATION
true
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_IDLE_DAILY
true
)
;
let
shutdownClient
=
PlacesUtils
.
history
.
connectionShutdownClient
.
jsclient
;
shutdownClient
.
addBlocker
(
"
Places
Expiration
:
shutdown
"
(
)
=
>
{
if
(
this
.
_shuttingDown
)
{
return
;
}
this
.
_shuttingDown
=
true
;
this
.
expireOnIdle
=
false
;
if
(
this
.
_timer
)
{
this
.
_timer
.
cancel
(
)
;
this
.
_timer
=
null
;
}
if
(
this
.
status
=
=
STATUS
.
DIRTY
)
{
this
.
_expireWithActionAndLimit
(
ACTION
.
SHUTDOWN_DIRTY
LIMIT
.
LARGE
)
;
}
this
.
_finalizeInternalStatements
(
)
;
}
)
;
}
nsPlacesExpiration
.
prototype
=
{
observe
:
function
PEX_observe
(
aSubject
aTopic
aData
)
{
if
(
this
.
_shuttingDown
)
{
return
;
}
if
(
aTopic
=
=
TOPIC_PREF_CHANGED
)
{
this
.
_loadPrefsPromise
=
this
.
_loadPrefs
(
)
.
then
(
(
)
=
>
{
if
(
aData
=
=
PREF_INTERVAL_SECONDS
)
{
this
.
_newTimer
(
)
;
}
}
Cu
.
reportError
)
;
}
else
if
(
aTopic
=
=
TOPIC_DEBUG_START_EXPIRATION
)
{
let
limit
=
parseInt
(
aData
)
;
if
(
limit
=
=
-
1
)
{
this
.
_expireWithActionAndLimit
(
ACTION
.
DEBUG
LIMIT
.
UNLIMITED
)
;
}
else
if
(
limit
>
0
)
{
this
.
_debugLimit
=
limit
;
this
.
_expireWithActionAndLimit
(
ACTION
.
DEBUG
LIMIT
.
DEBUG
)
;
}
else
{
this
.
_debugLimit
=
-
1
;
this
.
_expireWithActionAndLimit
(
ACTION
.
DEBUG
LIMIT
.
DEBUG
)
;
}
}
else
if
(
aTopic
=
=
TOPIC_IDLE_BEGIN
)
{
if
(
this
.
_timer
)
{
this
.
_timer
.
cancel
(
)
;
this
.
_timer
=
null
;
}
if
(
this
.
expireOnIdle
)
this
.
_expireWithActionAndLimit
(
ACTION
.
IDLE_DIRTY
LIMIT
.
LARGE
)
;
}
else
if
(
aTopic
=
=
TOPIC_IDLE_END
)
{
if
(
!
this
.
_timer
)
this
.
_newTimer
(
)
;
}
else
if
(
aTopic
=
=
TOPIC_IDLE_DAILY
)
{
this
.
_expireWithActionAndLimit
(
ACTION
.
IDLE_DAILY
LIMIT
.
LARGE
)
;
}
else
if
(
aTopic
=
=
TOPIC_TESTING_MODE
)
{
this
.
_testingMode
=
true
;
}
else
if
(
aTopic
=
=
PlacesUtils
.
TOPIC_INIT_COMPLETE
)
{
PlacesUtils
.
history
.
addObserver
(
this
true
)
;
}
}
_inBatchMode
:
false
onBeginUpdateBatch
:
function
PEX_onBeginUpdateBatch
(
)
{
this
.
_inBatchMode
=
true
;
if
(
this
.
_timer
)
{
this
.
_timer
.
cancel
(
)
;
this
.
_timer
=
null
;
}
}
onEndUpdateBatch
:
function
PEX_onEndUpdateBatch
(
)
{
this
.
_inBatchMode
=
false
;
if
(
!
this
.
_timer
)
this
.
_newTimer
(
)
;
}
onClearHistory
:
function
PEX_onClearHistory
(
)
{
this
.
status
=
STATUS
.
CLEAN
;
}
onVisits
(
)
{
}
onTitleChanged
(
)
{
}
onDeleteURI
(
)
{
}
onPageChanged
(
)
{
}
onDeleteVisits
(
)
{
}
notify
:
function
PEX_timerCallback
(
)
{
this
.
_getPagesStats
(
(
aPagesCount
)
=
>
{
let
overLimitPages
=
aPagesCount
-
this
.
_urisLimit
;
this
.
_overLimit
=
overLimitPages
>
0
;
let
action
=
this
.
_overLimit
?
ACTION
.
TIMED_OVERLIMIT
:
ACTION
.
TIMED
;
let
limit
=
overLimitPages
>
OVERLIMIT_PAGES_THRESHOLD
?
LIMIT
.
LARGE
:
LIMIT
.
SMALL
;
this
.
_expireWithActionAndLimit
(
action
limit
)
;
}
)
;
}
handleResult
:
function
PEX_handleResult
(
aResultSet
)
{
if
(
this
.
_shuttingDown
)
return
;
let
row
;
while
(
(
row
=
aResultSet
.
getNextRow
(
)
)
)
{
let
expectedResults
=
row
.
getResultByName
(
"
expected_results
"
)
;
if
(
expectedResults
>
0
)
{
if
(
!
(
"
_expectedResultsCount
"
in
this
)
)
{
this
.
_expectedResultsCount
=
expectedResults
;
}
if
(
this
.
_expectedResultsCount
>
0
)
{
this
.
_expectedResultsCount
-
-
;
}
}
let
uri
=
Services
.
io
.
newURI
(
row
.
getResultByName
(
"
url
"
)
)
;
let
guid
=
row
.
getResultByName
(
"
guid
"
)
;
let
visitDate
=
row
.
getResultByName
(
"
visit_date
"
)
;
let
wholeEntry
=
row
.
getResultByName
(
"
whole_entry
"
)
;
let
mostRecentExpiredVisit
=
row
.
getResultByName
(
"
most_recent_expired_visit
"
)
;
let
reason
=
Ci
.
nsINavHistoryObserver
.
REASON_EXPIRED
;
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
if
(
mostRecentExpiredVisit
)
{
let
days
=
parseInt
(
(
Date
.
now
(
)
-
(
mostRecentExpiredVisit
/
1000
)
)
/
MSECS_PER_DAY
)
;
if
(
!
this
.
_mostRecentExpiredVisitDays
)
{
this
.
_mostRecentExpiredVisitDays
=
days
;
}
else
if
(
days
<
this
.
_mostRecentExpiredVisitDays
)
{
this
.
_mostRecentExpiredVisitDays
=
days
;
}
}
if
(
wholeEntry
)
{
notify
(
observers
"
onDeleteURI
"
[
uri
guid
reason
]
)
;
}
else
{
notify
(
observers
"
onDeleteVisits
"
[
uri
visitDate
guid
reason
0
]
)
;
}
}
}
handleError
:
function
PEX_handleError
(
aError
)
{
Cu
.
reportError
(
"
Async
statement
execution
returned
with
'
"
+
aError
.
result
+
"
'
'
"
+
aError
.
message
+
"
'
"
)
;
}
_telemetrySteps
:
1
handleCompletion
:
function
PEX_handleCompletion
(
aReason
)
{
if
(
aReason
=
=
Ci
.
mozIStorageStatementCallback
.
REASON_FINISHED
)
{
if
(
this
.
_mostRecentExpiredVisitDays
)
{
try
{
Services
.
telemetry
.
getHistogramById
(
"
PLACES_MOST_RECENT_EXPIRED_VISIT_DAYS
"
)
.
add
(
this
.
_mostRecentExpiredVisitDays
)
;
}
catch
(
ex
)
{
Components
.
utils
.
reportError
(
"
Unable
to
report
telemetry
.
"
)
;
}
finally
{
delete
this
.
_mostRecentExpiredVisitDays
;
}
}
if
(
"
_expectedResultsCount
"
in
this
)
{
let
oldStatus
=
this
.
status
;
this
.
status
=
this
.
_expectedResultsCount
=
=
0
?
STATUS
.
DIRTY
:
STATUS
.
CLEAN
;
if
(
this
.
status
=
=
STATUS
.
DIRTY
)
{
this
.
_telemetrySteps
+
+
;
}
else
{
if
(
oldStatus
=
=
STATUS
.
DIRTY
)
{
try
{
Services
.
telemetry
.
getHistogramById
(
"
PLACES_EXPIRATION_STEPS_TO_CLEAN2
"
)
.
add
(
this
.
_telemetrySteps
)
;
}
catch
(
ex
)
{
Components
.
utils
.
reportError
(
"
Unable
to
report
telemetry
.
"
)
;
}
}
this
.
_telemetrySteps
=
1
;
}
delete
this
.
_expectedResultsCount
;
}
Services
.
obs
.
notifyObservers
(
null
TOPIC_EXPIRATION_FINISHED
)
;
}
}
_urisLimit
:
PREF_MAX_URIS_NOTSET
_interval
:
PREF_INTERVAL_SECONDS_NOTSET
_shuttingDown
:
false
_status
:
STATUS
.
UNKNOWN
set
status
(
aNewStatus
)
{
if
(
aNewStatus
!
=
this
.
_status
)
{
this
.
_status
=
aNewStatus
;
this
.
_newTimer
(
)
;
this
.
expireOnIdle
=
aNewStatus
=
=
STATUS
.
DIRTY
;
}
return
aNewStatus
;
}
get
status
(
)
{
return
this
.
_status
;
}
_isIdleObserver
:
false
_expireOnIdle
:
false
set
expireOnIdle
(
aExpireOnIdle
)
{
if
(
!
this
.
_isIdleObserver
&
&
!
this
.
_shuttingDown
)
{
this
.
_idle
.
addIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
this
.
_isIdleObserver
=
true
;
}
else
if
(
this
.
_isIdleObserver
&
&
this
.
_shuttingDown
)
{
this
.
_idle
.
removeIdleObserver
(
this
IDLE_TIMEOUT_SECONDS
)
;
this
.
_isIdleObserver
=
false
;
}
if
(
this
.
_debugLimit
!
=
=
undefined
)
this
.
_expireOnIdle
=
false
;
else
this
.
_expireOnIdle
=
aExpireOnIdle
;
return
this
.
_expireOnIdle
;
}
get
expireOnIdle
(
)
{
return
this
.
_expireOnIdle
;
}
async
_loadPrefs
(
)
{
this
.
_urisLimit
=
this
.
_prefBranch
.
getIntPref
(
PREF_MAX_URIS
PREF_MAX_URIS_NOTSET
)
;
if
(
this
.
_urisLimit
<
0
)
{
this
.
_urisLimit
=
100000
;
let
memSizeBytes
=
MEMSIZE_FALLBACK_BYTES
;
try
{
memSizeBytes
=
Services
.
sysinfo
.
getProperty
(
"
memsize
"
)
;
}
catch
(
ex
)
{
}
if
(
memSizeBytes
<
=
0
)
{
memSizeBytes
=
MEMSIZE_FALLBACK_BYTES
;
}
let
diskAvailableBytes
=
DISKSIZE_FALLBACK_BYTES
;
try
{
let
dbFile
=
this
.
_db
.
databaseFile
;
dbFile
.
QueryInterface
(
Ci
.
nsIFile
)
;
diskAvailableBytes
=
dbFile
.
diskSpaceAvailable
;
}
catch
(
ex
)
{
}
if
(
diskAvailableBytes
<
=
0
)
{
diskAvailableBytes
=
DISKSIZE_FALLBACK_BYTES
;
}
let
optimalDatabaseSize
=
Math
.
min
(
memSizeBytes
*
DATABASE_TO_MEMORY_PERC
/
100
diskAvailableBytes
*
DATABASE_TO_DISK_PERC
/
100
DATABASE_MAX_SIZE
)
;
let
db
;
try
{
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
if
(
db
)
{
let
row
=
(
await
db
.
execute
(
SELECT
*
FROM
pragma_page_size
(
)
pragma_page_count
(
)
pragma_freelist_count
(
)
(
SELECT
count
(
*
)
FROM
moz_places
)
)
)
[
0
]
;
let
pageSize
=
row
.
getResultByIndex
(
0
)
;
let
pageCount
=
row
.
getResultByIndex
(
1
)
;
let
freelistCount
=
row
.
getResultByIndex
(
2
)
;
let
uriCount
=
row
.
getResultByIndex
(
3
)
;
let
dbSize
=
(
pageCount
-
freelistCount
)
*
pageSize
;
let
avgURISize
=
Math
.
ceil
(
dbSize
/
uriCount
)
;
if
(
avgURISize
>
(
URIENTRY_AVG_SIZE
*
3
)
)
{
avgURISize
=
URIENTRY_AVG_SIZE
;
}
this
.
_urisLimit
=
Math
.
ceil
(
optimalDatabaseSize
/
avgURISize
)
;
}
}
catch
(
ex
)
{
}
}
this
.
_prefBranch
.
setIntPref
(
PREF_READONLY_CALCULATED_MAX_URIS
this
.
_urisLimit
)
;
this
.
_interval
=
this
.
_prefBranch
.
getIntPref
(
PREF_INTERVAL_SECONDS
PREF_INTERVAL_SECONDS_NOTSET
)
;
if
(
this
.
_interval
<
=
0
)
{
this
.
_interval
=
PREF_INTERVAL_SECONDS_NOTSET
;
}
}
_getPagesStats
:
function
PEX__getPagesStats
(
aCallback
)
{
if
(
!
this
.
_cachedStatements
.
LIMIT_COUNT
)
{
this
.
_cachedStatements
.
LIMIT_COUNT
=
this
.
_db
.
createAsyncStatement
(
SELECT
COUNT
(
*
)
FROM
moz_places
)
;
}
this
.
_cachedStatements
.
LIMIT_COUNT
.
executeAsync
(
{
_pagesCount
:
0
handleResult
(
aResults
)
{
let
row
=
aResults
.
getNextRow
(
)
;
this
.
_pagesCount
=
row
.
getResultByIndex
(
0
)
;
}
handleCompletion
(
aReason
)
{
if
(
aReason
=
=
Ci
.
mozIStorageStatementCallback
.
REASON_FINISHED
)
{
aCallback
(
this
.
_pagesCount
)
;
}
}
handleError
(
aError
)
{
Cu
.
reportError
(
"
Async
statement
execution
returned
with
'
"
+
aError
.
result
+
"
'
'
"
+
aError
.
message
+
"
'
"
)
;
}
}
)
;
}
_expireWithActionAndLimit
:
function
PEX__expireWithActionAndLimit
(
aAction
aLimit
)
{
(
async
(
)
=
>
{
if
(
!
this
.
_shuttingDown
)
await
this
.
_loadPrefsPromise
;
if
(
this
.
_inBatchMode
)
return
;
if
(
this
.
_shuttingDown
&
&
aAction
!
=
ACTION
.
SHUTDOWN_DIRTY
)
{
return
;
}
let
boundStatements
=
[
]
;
for
(
let
queryType
in
EXPIRATION_QUERIES
)
{
if
(
EXPIRATION_QUERIES
[
queryType
]
.
actions
&
aAction
)
boundStatements
.
push
(
this
.
_getBoundStatement
(
queryType
aLimit
aAction
)
)
;
}
this
.
_db
.
executeAsync
(
boundStatements
boundStatements
.
length
this
)
;
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
_finalizeInternalStatements
:
function
PEX__finalizeInternalStatements
(
)
{
for
(
let
queryType
in
this
.
_cachedStatements
)
{
let
stmt
=
this
.
_cachedStatements
[
queryType
]
;
stmt
.
finalize
(
)
;
}
}
_cachedStatements
:
{
}
_getBoundStatement
:
function
PEX__getBoundStatement
(
aQueryType
aLimit
aAction
)
{
let
stmt
=
this
.
_cachedStatements
[
aQueryType
]
;
if
(
stmt
=
=
=
undefined
)
{
stmt
=
this
.
_cachedStatements
[
aQueryType
]
=
this
.
_db
.
createAsyncStatement
(
EXPIRATION_QUERIES
[
aQueryType
]
.
sql
)
;
}
let
baseLimit
;
switch
(
aLimit
)
{
case
LIMIT
.
UNLIMITED
:
baseLimit
=
-
1
;
break
;
case
LIMIT
.
SMALL
:
baseLimit
=
EXPIRE_LIMIT_PER_STEP
;
break
;
case
LIMIT
.
LARGE
:
baseLimit
=
EXPIRE_LIMIT_PER_STEP
*
EXPIRE_LIMIT_PER_LARGE_STEP_MULTIPLIER
;
break
;
case
LIMIT
.
DEBUG
:
baseLimit
=
this
.
_debugLimit
;
break
;
}
if
(
this
.
status
=
=
STATUS
.
DIRTY
&
&
aAction
!
=
ACTION
.
DEBUG
&
&
baseLimit
>
0
)
{
baseLimit
*
=
EXPIRE_AGGRESSIVITY_MULTIPLIER
;
}
let
params
=
stmt
.
params
;
switch
(
aQueryType
)
{
case
"
QUERY_FIND_EXOTIC_VISITS_TO_EXPIRE
"
:
params
.
limit_visits
=
aLimit
=
=
LIMIT
.
DEBUG
&
&
baseLimit
=
=
-
1
?
0
:
baseLimit
;
break
;
case
"
QUERY_FIND_VISITS_TO_EXPIRE
"
:
params
.
max_uris
=
this
.
_urisLimit
;
params
.
limit_visits
=
aLimit
=
=
LIMIT
.
DEBUG
&
&
baseLimit
=
=
-
1
?
0
:
baseLimit
;
break
;
case
"
QUERY_FIND_URIS_TO_EXPIRE
"
:
params
.
limit_uris
=
baseLimit
;
break
;
case
"
QUERY_EXPIRE_ANNOS
"
:
params
.
limit_annos
=
baseLimit
*
EXPIRE_AGGRESSIVITY_MULTIPLIER
;
break
;
case
"
QUERY_EXPIRE_ANNOS_WITH_POLICY
"
:
case
"
QUERY_EXPIRE_ITEMS_ANNOS_WITH_POLICY
"
:
let
microNow
=
Date
.
now
(
)
*
1000
;
ANNOS_EXPIRE_POLICIES
.
forEach
(
function
(
policy
)
{
params
[
policy
.
bind
]
=
policy
.
type
;
params
[
policy
.
bind
+
"
_time
"
]
=
microNow
-
policy
.
time
;
}
)
;
break
;
case
"
QUERY_EXPIRE_ANNOS_WITH_HISTORY
"
:
params
.
expire_with_history
=
Ci
.
nsIAnnotationService
.
EXPIRE_WITH_HISTORY
;
break
;
case
"
QUERY_EXPIRE_ITEMS_ANNOS
"
:
params
.
limit_annos
=
baseLimit
;
break
;
case
"
QUERY_EXPIRE_ANNO_ATTRIBUTES
"
:
params
.
limit_annos
=
baseLimit
;
break
;
case
"
QUERY_EXPIRE_INPUTHISTORY
"
:
params
.
limit_inputhistory
=
baseLimit
;
break
;
}
return
stmt
;
}
_newTimer
:
function
PEX__newTimer
(
)
{
if
(
this
.
_timer
)
this
.
_timer
.
cancel
(
)
;
if
(
this
.
_shuttingDown
)
return
undefined
;
let
interval
=
this
.
status
!
=
STATUS
.
DIRTY
?
this
.
_interval
*
EXPIRE_AGGRESSIVITY_MULTIPLIER
:
this
.
_interval
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
this
interval
*
1000
Ci
.
nsITimer
.
TYPE_REPEATING_SLACK_LOW_PRIORITY
)
;
if
(
this
.
_testingMode
)
{
Services
.
obs
.
notifyObservers
(
null
TOPIC_TEST_INTERVAL_CHANGED
interval
)
;
}
return
this
.
_timer
=
timer
;
}
classID
:
Components
.
ID
(
"
705a423f
-
2f69
-
42f3
-
b9fe
-
1517e0dee56f
"
)
_xpcom_factory
:
XPCOMUtils
.
generateSingletonFactory
(
nsPlacesExpiration
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsINavHistoryObserver
Ci
.
nsITimerCallback
Ci
.
mozIStorageStatementCallback
Ci
.
nsISupportsWeakReference
]
)
}
;
var
components
=
[
nsPlacesExpiration
]
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
components
)
;
