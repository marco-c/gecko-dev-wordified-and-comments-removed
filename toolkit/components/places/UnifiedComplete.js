"
use
strict
"
;
const
MS_PER_DAY
=
86400000
;
const
{
MATCH_ANYWHERE
MATCH_BOUNDARY_ANYWHERE
MATCH_BOUNDARY
MATCH_BEGINNING
MATCH_BEGINNING_CASE_SENSITIVE
}
=
Ci
.
mozIPlacesAutoComplete
;
const
INSERTMETHOD
=
{
APPEND
:
0
MERGE_RELATED
:
1
MERGE
:
2
}
;
const
PREF_URLBAR_BRANCH
=
"
browser
.
urlbar
.
"
;
const
PREF_URLBAR_DEFAULTS
=
new
Map
(
[
[
"
autocomplete
.
enabled
"
true
]
[
"
autoFill
"
true
]
[
"
autoFill
.
searchEngines
"
false
]
[
"
restyleSearches
"
false
]
[
"
delay
"
50
]
[
"
matchBehavior
"
MATCH_BOUNDARY_ANYWHERE
]
[
"
filter
.
javascript
"
true
]
[
"
maxRichResults
"
10
]
[
"
suggest
.
history
"
true
]
[
"
suggest
.
bookmark
"
true
]
[
"
suggest
.
openpage
"
true
]
[
"
suggest
.
history
.
onlyTyped
"
false
]
[
"
suggest
.
searches
"
false
]
[
"
maxCharsForSearchSuggestions
"
20
]
[
"
maxHistoricalSearchSuggestions
"
0
]
[
"
usepreloadedtopurls
.
enabled
"
true
]
[
"
usepreloadedtopurls
.
expire_days
"
14
]
[
"
matchBuckets
"
"
suggestion
:
4
general
:
Infinity
"
]
[
"
matchBucketsSearch
"
"
"
]
[
"
insertMethod
"
INSERTMETHOD
.
MERGE_RELATED
]
]
)
;
const
PREF_OTHER_DEFAULTS
=
new
Map
(
[
[
"
keyword
.
enabled
"
true
]
]
)
;
const
QUERYTYPE_FILTERED
=
0
;
const
QUERYTYPE_AUTOFILL_ORIGIN
=
1
;
const
QUERYTYPE_AUTOFILL_URL
=
2
;
const
QUERYTYPE_ADAPTIVE
=
3
;
const
TITLE_TAGS_SEPARATOR
=
"
\
u2013
"
;
const
TELEMETRY_1ST_RESULT
=
"
PLACES_AUTOCOMPLETE_1ST_RESULT_TIME_MS
"
;
const
TELEMETRY_6_FIRST_RESULTS
=
"
PLACES_AUTOCOMPLETE_6_FIRST_RESULTS_TIME_MS
"
;
const
FRECENCY_DEFAULT
=
1000
;
const
MAXIMUM_ALLOWED_EXTENSION_MATCHES
=
6
;
const
MAXIMUM_ALLOWED_EXTENSION_TIME_MS
=
3000
;
const
RECENT_REMOTE_TAB_THRESHOLD_MS
=
259200000
;
const
REGEXP_SINGLEWORD_HOST
=
new
RegExp
(
"
^
[
a
-
z0
-
9
-
]
+
"
"
i
"
)
;
const
REGEXP_USER_CONTEXT_ID
=
/
(
?
:
^
|
)
user
-
context
-
id
:
(
\
d
+
)
/
;
const
REGEXP_SPACES
=
/
\
s
+
/
;
const
REGEXP_STRIP_PREFIX
=
/
^
[
a
-
zA
-
Z
]
+
:
(
?
:
\
/
\
/
)
?
/
;
const
REGEXP_ORIGIN
=
/
^
[
^
\
s
\
/
\
?
\
#
]
+
/
;
const
NOTIFYRESULT_DELAY_MS
=
16
;
const
QUERYINDEX_QUERYTYPE
=
0
;
const
QUERYINDEX_URL
=
1
;
const
QUERYINDEX_TITLE
=
2
;
const
QUERYINDEX_BOOKMARKED
=
3
;
const
QUERYINDEX_BOOKMARKTITLE
=
4
;
const
QUERYINDEX_TAGS
=
5
;
const
QUERYINDEX_VISITCOUNT
=
6
;
const
QUERYINDEX_TYPED
=
7
;
const
QUERYINDEX_PLACEID
=
8
;
const
QUERYINDEX_SWITCHTAB
=
9
;
const
QUERYINDEX_FRECENCY
=
10
;
const
TOKEN_TO_BEHAVIOR_MAP
=
new
Map
(
[
[
"
^
"
"
history
"
]
[
"
*
"
"
bookmark
"
]
[
"
+
"
"
tag
"
]
[
"
%
"
"
openpage
"
]
[
"
~
"
"
typed
"
]
[
"
"
"
searches
"
]
[
"
#
"
"
title
"
]
[
"
"
"
url
"
]
]
)
;
const
MATCHTYPE
=
{
HEURISTIC
:
"
heuristic
"
GENERAL
:
"
general
"
SUGGESTION
:
"
suggestion
"
EXTENSION
:
"
extension
"
}
;
const
DEFAULT_BUCKETS_BEFORE
=
[
[
MATCHTYPE
.
HEURISTIC
1
]
[
MATCHTYPE
.
EXTENSION
MAXIMUM_ALLOWED_EXTENSION_MATCHES
-
1
]
]
;
const
DEFAULT_BUCKETS_AFTER
=
[
[
MATCHTYPE
.
SUGGESTION
Infinity
]
[
MATCHTYPE
.
GENERAL
Infinity
]
]
;
const
DISALLOWED_URLLIKE_PREFIXES
=
[
"
http
"
"
https
"
"
ftp
"
]
;
const
SQL_BOOKMARK_TAGS_FRAGMENT
=
EXISTS
(
SELECT
1
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
)
AS
bookmarked
(
SELECT
title
FROM
moz_bookmarks
WHERE
fk
=
h
.
id
AND
title
NOTNULL
ORDER
BY
lastModified
DESC
LIMIT
1
)
AS
btitle
(
SELECT
GROUP_CONCAT
(
t
.
title
'
'
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
ON
t
.
id
=
+
b
.
parent
AND
t
.
parent
=
:
parent
WHERE
b
.
fk
=
h
.
id
)
AS
tags
;
function
defaultQuery
(
conditions
=
"
"
)
{
let
query
=
SELECT
:
query_type
h
.
url
h
.
title
{
SQL_BOOKMARK_TAGS_FRAGMENT
}
h
.
visit_count
h
.
typed
h
.
id
t
.
open_count
h
.
frecency
FROM
moz_places
h
LEFT
JOIN
moz_openpages_temp
t
ON
t
.
url
=
h
.
url
AND
t
.
userContextId
=
:
userContextId
WHERE
h
.
frecency
<
>
0
AND
CASE
WHEN
bookmarked
THEN
AUTOCOMPLETE_MATCH
(
:
searchString
h
.
url
IFNULL
(
btitle
h
.
title
)
tags
h
.
visit_count
h
.
typed
1
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ELSE
AUTOCOMPLETE_MATCH
(
:
searchString
h
.
url
h
.
title
'
'
h
.
visit_count
h
.
typed
0
t
.
open_count
:
matchBehavior
:
searchBehavior
)
END
{
conditions
}
ORDER
BY
h
.
frecency
DESC
h
.
id
DESC
LIMIT
:
maxResults
;
return
query
;
}
const
SQL_SWITCHTAB_QUERY
=
SELECT
:
query_type
t
.
url
t
.
url
NULL
NULL
NULL
NULL
NULL
NULL
t
.
open_count
NULL
FROM
moz_openpages_temp
t
LEFT
JOIN
moz_places
h
ON
h
.
url_hash
=
hash
(
t
.
url
)
AND
h
.
url
=
t
.
url
WHERE
h
.
id
IS
NULL
AND
t
.
userContextId
=
:
userContextId
AND
AUTOCOMPLETE_MATCH
(
:
searchString
t
.
url
t
.
url
NULL
NULL
NULL
NULL
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ORDER
BY
t
.
ROWID
DESC
LIMIT
:
maxResults
;
const
SQL_ADAPTIVE_QUERY
=
/
*
do
not
warn
(
bug
487789
)
*
/
SELECT
:
query_type
h
.
url
h
.
title
{
SQL_BOOKMARK_TAGS_FRAGMENT
}
h
.
visit_count
h
.
typed
h
.
id
t
.
open_count
h
.
frecency
FROM
(
SELECT
ROUND
(
MAX
(
use_count
)
*
(
1
+
(
input
=
:
search_string
)
)
1
)
AS
rank
place_id
FROM
moz_inputhistory
WHERE
input
BETWEEN
:
search_string
AND
:
search_string
|
|
X
'
FFFF
'
GROUP
BY
place_id
)
AS
i
JOIN
moz_places
h
ON
h
.
id
=
i
.
place_id
LEFT
JOIN
moz_openpages_temp
t
ON
t
.
url
=
h
.
url
AND
t
.
userContextId
=
:
userContextId
WHERE
AUTOCOMPLETE_MATCH
(
NULL
h
.
url
IFNULL
(
btitle
h
.
title
)
tags
h
.
visit_count
h
.
typed
bookmarked
t
.
open_count
:
matchBehavior
:
searchBehavior
)
ORDER
BY
rank
DESC
h
.
frecency
DESC
LIMIT
:
maxResults
;
const
QUERYINDEX_ORIGIN_AUTOFILLED_VALUE
=
1
;
const
QUERYINDEX_ORIGIN_URL
=
2
;
const
QUERYINDEX_ORIGIN_FRECENCY
=
3
;
const
SQL_AUTOFILL_WITH
=
WITH
frecency_stats
(
count
sum
squares
)
AS
(
SELECT
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
"
origin_frecency_count
"
)
AS
REAL
)
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
"
origin_frecency_sum
"
)
AS
REAL
)
CAST
(
(
SELECT
IFNULL
(
value
0
.
0
)
FROM
moz_meta
WHERE
key
=
"
origin_frecency_sum_of_squares
"
)
AS
REAL
)
)
autofill_frecency_threshold
(
value
)
AS
(
SELECT
MAX
(
1
CASE
count
WHEN
0
THEN
0
.
0
WHEN
1
THEN
sum
ELSE
(
sum
/
count
)
+
sqrt
(
(
squares
-
(
(
sum
*
sum
)
/
count
)
)
/
count
)
END
)
FROM
frecency_stats
)
;
const
SQL_AUTOFILL_FRECENCY_THRESHOLD
=
(
SELECT
value
FROM
autofill_frecency_threshold
)
;
function
originQuery
(
conditions
=
"
"
bookmarkedFragment
=
"
NULL
"
)
{
return
{
SQL_AUTOFILL_WITH
}
SELECT
:
query_type
host
|
|
'
/
'
prefix
|
|
host
|
|
'
/
'
frecency
{
bookmarkedFragment
}
AS
bookmarked
id
FROM
moz_origins
WHERE
host
BETWEEN
:
searchString
AND
:
searchString
|
|
X
'
FFFF
'
AND
frecency
>
=
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
{
conditions
}
UNION
ALL
SELECT
:
query_type
fixup_url
(
host
)
|
|
'
/
'
prefix
|
|
host
|
|
'
/
'
frecency
{
bookmarkedFragment
}
AS
bookmarked
id
FROM
moz_origins
WHERE
host
BETWEEN
'
www
.
'
|
|
:
searchString
AND
'
www
.
'
|
|
:
searchString
|
|
X
'
FFFF
'
AND
frecency
>
=
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
{
conditions
}
ORDER
BY
frecency
DESC
id
DESC
LIMIT
1
;
}
const
SQL_ORIGIN_QUERY
=
originQuery
(
)
;
const
SQL_ORIGIN_PREFIX_QUERY
=
originQuery
(
AND
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
)
;
const
SQL_ORIGIN_BOOKMARKED_QUERY
=
originQuery
(
AND
bookmarked
(
SELECT
foreign_count
>
0
FROM
moz_places
WHERE
moz_places
.
origin_id
=
moz_origins
.
id
)
)
;
const
SQL_ORIGIN_PREFIX_BOOKMARKED_QUERY
=
originQuery
(
AND
bookmarked
AND
prefix
BETWEEN
:
prefix
AND
:
prefix
|
|
X
'
FFFF
'
(
SELECT
foreign_count
>
0
FROM
moz_places
WHERE
moz_places
.
origin_id
=
moz_origins
.
id
)
)
;
const
QUERYINDEX_URL_URL
=
1
;
const
QUERYINDEX_URL_STRIPPED_URL
=
2
;
const
QUERYINDEX_URL_FRECENCY
=
3
;
function
urlQuery
(
conditions1
conditions2
)
{
return
/
*
do
not
warn
(
bug
no
)
:
cannot
use
an
index
to
sort
*
/
{
SQL_AUTOFILL_WITH
}
SELECT
:
query_type
url
:
strippedURL
frecency
foreign_count
>
0
AS
bookmarked
id
FROM
moz_places
WHERE
rev_host
=
:
revHost
AND
frecency
>
=
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
{
conditions1
}
UNION
ALL
SELECT
:
query_type
url
:
strippedURL
frecency
foreign_count
>
0
AS
bookmarked
id
FROM
moz_places
WHERE
rev_host
=
:
revHost
|
|
'
www
.
'
AND
frecency
>
=
{
SQL_AUTOFILL_FRECENCY_THRESHOLD
}
{
conditions2
}
ORDER
BY
frecency
DESC
id
DESC
LIMIT
1
;
}
const
SQL_URL_QUERY
=
urlQuery
(
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
SQL_URL_PREFIX_QUERY
=
urlQuery
(
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
SQL_URL_BOOKMARKED_QUERY
=
urlQuery
(
AND
bookmarked
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
:
strippedURL
AND
:
strippedURL
|
|
X
'
FFFF
'
AND
bookmarked
AND
strip_prefix_and_userinfo
(
url
)
BETWEEN
'
www
.
'
|
|
:
strippedURL
AND
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
const
SQL_URL_PREFIX_BOOKMARKED_QUERY
=
urlQuery
(
AND
bookmarked
AND
url
BETWEEN
:
prefix
|
|
:
strippedURL
AND
:
prefix
|
|
:
strippedURL
|
|
X
'
FFFF
'
AND
bookmarked
AND
url
BETWEEN
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
AND
:
prefix
|
|
'
www
.
'
|
|
:
strippedURL
|
|
X
'
FFFF
'
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
TelemetryStopwatch
:
"
resource
:
/
/
gre
/
modules
/
TelemetryStopwatch
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
ExtensionSearchHandler
:
"
resource
:
/
/
gre
/
modules
/
ExtensionSearchHandler
.
jsm
"
PlacesSearchAutocompleteProvider
:
"
resource
:
/
/
gre
/
modules
/
PlacesSearchAutocompleteProvider
.
jsm
"
PlacesRemoteTabsAutocompleteProvider
:
"
resource
:
/
/
gre
/
modules
/
PlacesRemoteTabsAutocompleteProvider
.
jsm
"
BrowserUtils
:
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
ProfileAge
:
"
resource
:
/
/
gre
/
modules
/
ProfileAge
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
syncUsernamePref
"
"
services
.
sync
.
username
"
)
;
function
setTimeout
(
callback
ms
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
callback
ms
timer
.
TYPE_ONE_SHOT
)
;
return
timer
;
}
const
kProtocolsWithIcons
=
[
"
chrome
:
"
"
moz
-
extension
:
"
"
about
:
"
"
http
:
"
"
https
:
"
"
ftp
:
"
]
;
function
iconHelper
(
url
)
{
if
(
typeof
url
=
=
"
string
"
)
{
return
kProtocolsWithIcons
.
some
(
p
=
>
url
.
startsWith
(
p
)
)
?
"
page
-
icon
:
"
+
url
:
PlacesUtils
.
favicons
.
defaultFavicon
.
spec
;
}
if
(
url
&
&
url
instanceof
URL
&
&
kProtocolsWithIcons
.
includes
(
url
.
protocol
)
)
{
return
"
page
-
icon
:
"
+
url
.
href
;
}
return
PlacesUtils
.
favicons
.
defaultFavicon
.
spec
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
SwitchToTabStorage
"
(
)
=
>
Object
.
seal
(
{
_conn
:
null
_queue
:
new
Map
(
)
_updatingLevel
:
0
get
updating
(
)
{
return
this
.
_updatingLevel
>
0
;
}
async
initDatabase
(
conn
)
{
await
conn
.
execute
(
CREATE
TEMP
TABLE
moz_openpages_temp
(
url
TEXT
userContextId
INTEGER
open_count
INTEGER
PRIMARY
KEY
(
url
userContextId
)
)
)
;
await
conn
.
execute
(
CREATE
TEMPORARY
TRIGGER
moz_openpages_temp_afterupdate_trigger
AFTER
UPDATE
OF
open_count
ON
moz_openpages_temp
FOR
EACH
ROW
WHEN
NEW
.
open_count
=
0
BEGIN
DELETE
FROM
moz_openpages_temp
WHERE
url
=
NEW
.
url
AND
userContextId
=
NEW
.
userContextId
;
END
)
;
this
.
_conn
=
conn
;
for
(
let
[
userContextId
uris
]
of
this
.
_queue
)
{
for
(
let
uri
of
uris
)
{
this
.
add
(
uri
userContextId
)
.
catch
(
Cu
.
reportError
)
;
}
}
this
.
_queue
.
clear
(
)
;
}
async
add
(
uri
userContextId
)
{
if
(
!
this
.
_conn
)
{
if
(
!
this
.
_queue
.
has
(
userContextId
)
)
{
this
.
_queue
.
set
(
userContextId
new
Set
(
)
)
;
}
this
.
_queue
.
get
(
userContextId
)
.
add
(
uri
)
;
return
;
}
try
{
this
.
_updatingLevel
+
+
;
await
this
.
_conn
.
executeCached
(
INSERT
OR
REPLACE
INTO
moz_openpages_temp
(
url
userContextId
open_count
)
VALUES
(
:
url
:
userContextId
IFNULL
(
(
SELECT
open_count
+
1
FROM
moz_openpages_temp
WHERE
url
=
:
url
AND
userContextId
=
:
userContextId
)
1
)
)
{
url
:
uri
.
spec
userContextId
}
)
;
}
finally
{
this
.
_updatingLevel
-
-
;
}
}
async
delete
(
uri
userContextId
)
{
if
(
!
this
.
_conn
)
{
if
(
!
this
.
_queue
.
has
(
userContextId
)
)
{
throw
new
Error
(
"
Unknown
userContextId
!
"
)
;
}
this
.
_queue
.
get
(
userContextId
)
.
delete
(
uri
)
;
if
(
this
.
_queue
.
get
(
userContextId
)
.
size
=
=
0
)
{
this
.
_queue
.
delete
(
userContextId
)
;
}
return
;
}
try
{
this
.
_updatingLevel
+
+
;
await
this
.
_conn
.
executeCached
(
UPDATE
moz_openpages_temp
SET
open_count
=
open_count
-
1
WHERE
url
=
:
url
AND
userContextId
=
:
userContextId
{
url
:
uri
.
spec
userContextId
}
)
;
}
finally
{
this
.
_updatingLevel
-
-
;
}
}
shutdown
(
)
{
this
.
_conn
=
null
;
this
.
_queue
.
clear
(
)
;
}
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Prefs
"
(
)
=
>
{
let
branch
=
Services
.
prefs
.
getBranch
(
PREF_URLBAR_BRANCH
)
;
let
types
=
[
"
history
"
"
bookmark
"
"
openpage
"
"
searches
"
]
;
let
prefTypes
=
new
Map
(
[
[
"
boolean
"
"
Bool
"
]
[
"
string
"
"
Char
"
]
[
"
number
"
"
Int
"
]
]
)
;
function
readPref
(
pref
)
{
let
prefs
=
branch
;
let
def
=
PREF_URLBAR_DEFAULTS
.
get
(
pref
)
;
if
(
def
=
=
=
undefined
)
{
prefs
=
Services
.
prefs
;
def
=
PREF_OTHER_DEFAULTS
.
get
(
pref
)
;
}
if
(
def
=
=
=
undefined
)
throw
new
Error
(
"
Trying
to
access
an
unknown
pref
"
+
pref
)
;
return
prefs
[
get
{
prefTypes
.
get
(
typeof
def
)
}
Pref
]
(
pref
def
)
;
}
function
getPrefValue
(
pref
)
{
switch
(
pref
)
{
case
"
matchBuckets
"
:
{
let
val
=
readPref
(
pref
)
;
try
{
val
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
val
)
;
}
catch
(
ex
)
{
val
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
PREF_URLBAR_DEFAULTS
.
get
(
pref
)
)
;
}
return
[
.
.
.
DEFAULT_BUCKETS_BEFORE
.
.
.
val
.
.
.
DEFAULT_BUCKETS_AFTER
]
;
}
case
"
matchBucketsSearch
"
:
{
let
val
=
readPref
(
pref
)
;
if
(
val
)
{
try
{
val
=
PlacesUtils
.
convertMatchBucketsStringToArray
(
val
)
;
return
[
.
.
.
DEFAULT_BUCKETS_BEFORE
.
.
.
val
.
.
.
DEFAULT_BUCKETS_AFTER
]
;
}
catch
(
ex
)
{
}
}
return
store
.
get
(
"
matchBuckets
"
)
;
}
case
"
suggest
.
history
.
onlyTyped
"
:
{
return
store
.
get
(
"
suggest
.
history
"
)
&
&
readPref
(
pref
)
;
}
case
"
defaultBehavior
"
:
{
let
val
=
0
;
for
(
let
type
of
[
.
.
.
types
"
history
.
onlyTyped
"
]
)
{
let
behavior
=
type
=
=
"
history
.
onlyTyped
"
?
"
TYPED
"
:
type
.
toUpperCase
(
)
;
val
|
=
store
.
get
(
"
suggest
.
"
+
type
)
&
&
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
behavior
]
;
}
return
val
;
}
case
"
emptySearchDefaultBehavior
"
:
{
let
val
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_RESTRICT
;
if
(
store
.
get
(
"
suggest
.
history
"
)
)
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_HISTORY
|
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_TYPED
;
}
else
if
(
store
.
get
(
"
suggest
.
bookmark
"
)
)
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_BOOKMARK
;
}
else
{
val
|
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_OPENPAGE
;
}
return
val
;
}
case
"
matchBehavior
"
:
{
let
val
=
readPref
(
pref
)
;
if
(
!
[
MATCH_ANYWHERE
MATCH_BOUNDARY
MATCH_BEGINNING
]
.
includes
(
val
)
)
{
val
=
MATCH_BOUNDARY_ANYWHERE
;
}
return
val
;
}
}
return
readPref
(
pref
)
;
}
let
linkingPrefs
=
false
;
function
updateLinkedPrefs
(
changedPref
=
"
"
)
{
if
(
linkingPrefs
)
return
;
linkingPrefs
=
true
;
try
{
if
(
changedPref
.
startsWith
(
"
suggest
.
"
)
)
{
branch
.
setBoolPref
(
"
autocomplete
.
enabled
"
types
.
some
(
type
=
>
store
.
get
(
"
suggest
.
"
+
type
)
)
)
;
}
else
if
(
store
.
get
(
"
autocomplete
.
enabled
"
)
)
{
if
(
types
.
every
(
type
=
>
!
store
.
get
(
"
suggest
.
"
+
type
)
)
)
{
for
(
let
type
of
types
)
{
let
def
=
PREF_URLBAR_DEFAULTS
.
get
(
"
suggest
.
"
+
type
)
;
branch
.
setBoolPref
(
"
suggest
.
"
+
type
def
)
;
}
}
}
else
{
for
(
let
type
of
types
)
{
branch
.
setBoolPref
(
"
suggest
.
"
+
type
false
)
;
}
}
}
finally
{
linkingPrefs
=
false
;
}
}
let
store
=
{
_map
:
new
Map
(
)
get
(
pref
)
{
if
(
!
this
.
_map
.
has
(
pref
)
)
this
.
_map
.
set
(
pref
getPrefValue
(
pref
)
)
;
return
this
.
_map
.
get
(
pref
)
;
}
observe
(
subject
topic
data
)
{
let
pref
=
data
.
replace
(
PREF_URLBAR_BRANCH
"
"
)
;
if
(
!
PREF_URLBAR_DEFAULTS
.
has
(
pref
)
&
&
!
PREF_OTHER_DEFAULTS
.
has
(
pref
)
)
return
;
this
.
_map
.
delete
(
pref
)
;
if
(
pref
=
=
"
matchBuckets
"
)
{
this
.
_map
.
delete
(
"
matchBucketsSearch
"
)
;
}
else
if
(
pref
=
=
"
suggest
.
history
"
)
{
this
.
_map
.
delete
(
"
suggest
.
history
.
onlyTyped
"
)
;
}
if
(
pref
=
=
"
autocomplete
.
enabled
"
|
|
pref
.
startsWith
(
"
suggest
.
"
)
)
{
this
.
_map
.
delete
(
"
defaultBehavior
"
)
;
this
.
_map
.
delete
(
"
emptySearchDefaultBehavior
"
)
;
updateLinkedPrefs
(
pref
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
Services
.
prefs
.
addObserver
(
PREF_URLBAR_BRANCH
store
true
)
;
Services
.
prefs
.
addObserver
(
"
keyword
.
enabled
"
store
true
)
;
updateLinkedPrefs
(
)
;
return
store
;
}
)
;
function
PreloadedSite
(
url
title
)
{
this
.
uri
=
Services
.
io
.
newURI
(
url
)
;
this
.
title
=
title
;
this
.
_matchTitle
=
title
.
toLowerCase
(
)
;
this
.
_hasWWW
=
this
.
uri
.
host
.
startsWith
(
"
www
.
"
)
;
this
.
_hostWithoutWWW
=
this
.
_hasWWW
?
this
.
uri
.
host
.
slice
(
4
)
:
this
.
uri
.
host
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
PreloadedSiteStorage
"
(
)
=
>
Object
.
seal
(
{
sites
:
[
]
add
(
url
title
)
{
let
site
=
new
PreloadedSite
(
url
title
)
;
this
.
sites
.
push
(
site
)
;
}
populate
(
sites
)
{
this
.
sites
=
[
]
;
for
(
let
site
of
sites
)
{
this
.
add
(
site
[
0
]
site
[
1
]
)
;
}
}
}
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ProfileAgeCreatedPromise
"
(
)
=
>
{
return
(
new
ProfileAge
(
null
null
)
)
.
created
;
}
)
;
function
getUnfilteredSearchTokens
(
searchString
)
{
return
searchString
.
length
?
searchString
.
split
(
REGEXP_SPACES
)
:
[
]
;
}
function
stripPrefix
(
str
)
{
let
match
=
REGEXP_STRIP_PREFIX
.
exec
(
str
)
;
if
(
!
match
)
{
return
[
"
"
str
]
;
}
let
prefix
=
match
[
0
]
;
if
(
prefix
.
length
<
str
.
length
&
&
str
[
prefix
.
length
]
=
=
"
"
)
{
return
[
"
"
str
]
;
}
return
[
prefix
str
.
substr
(
prefix
.
length
)
]
;
}
function
stripHttpAndTrim
(
spec
trimSlash
=
true
)
{
if
(
spec
.
startsWith
(
"
http
:
/
/
"
)
)
{
spec
=
spec
.
slice
(
7
)
;
}
if
(
spec
.
endsWith
(
"
?
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
}
if
(
trimSlash
&
&
spec
.
endsWith
(
"
/
"
)
)
{
spec
=
spec
.
slice
(
0
-
1
)
;
}
return
spec
;
}
function
makeKeyForURL
(
match
)
{
let
url
=
match
.
value
;
let
action
=
PlacesUtils
.
parseActionUrl
(
url
)
;
if
(
!
action
|
|
!
(
"
url
"
in
action
.
params
)
)
{
if
(
match
.
hasOwnProperty
(
"
style
"
)
&
&
match
.
style
.
includes
(
"
autofill
"
)
)
{
url
=
match
.
comment
;
}
return
[
stripHttpAndTrim
(
url
)
null
]
;
}
return
[
stripHttpAndTrim
(
action
.
params
.
url
)
action
]
;
}
function
looksLikeUrl
(
str
ignoreAlphanumericHosts
=
false
)
{
return
!
REGEXP_SPACES
.
test
(
str
)
&
&
(
[
"
/
"
"
"
"
:
"
"
[
"
]
.
some
(
c
=
>
str
.
includes
(
c
)
)
|
|
(
ignoreAlphanumericHosts
?
/
(
.
*
\
.
.
*
)
{
3
}
/
.
test
(
str
)
:
str
.
includes
(
"
.
"
)
)
)
;
}
function
looksLikeOrigin
(
str
)
{
return
REGEXP_ORIGIN
.
test
(
str
)
;
}
function
Search
(
searchString
searchParam
autocompleteListener
autocompleteSearch
prohibitSearchSuggestions
previousResult
)
{
this
.
_originalSearchString
=
searchString
;
this
.
_trimmedOriginalSearchString
=
searchString
.
trim
(
)
;
let
[
prefix
suffix
]
=
stripPrefix
(
this
.
_trimmedOriginalSearchString
)
;
this
.
_searchString
=
Services
.
textToSubURI
.
unEscapeURIForUI
(
"
UTF
-
8
"
suffix
)
;
this
.
_strippedPrefix
=
prefix
.
toLowerCase
(
)
;
this
.
_matchBehavior
=
Prefs
.
get
(
"
matchBehavior
"
)
;
this
.
_behavior
=
this
.
_searchString
?
Prefs
.
get
(
"
defaultBehavior
"
)
:
Prefs
.
get
(
"
emptySearchDefaultBehavior
"
)
;
let
params
=
new
Set
(
searchParam
.
split
(
"
"
)
)
;
this
.
_enableActions
=
params
.
has
(
"
enable
-
actions
"
)
;
this
.
_disablePrivateActions
=
params
.
has
(
"
disable
-
private
-
actions
"
)
;
this
.
_inPrivateWindow
=
params
.
has
(
"
private
-
window
"
)
;
this
.
_prohibitAutoFill
=
params
.
has
(
"
prohibit
-
autofill
"
)
;
let
userContextId
=
searchParam
.
match
(
REGEXP_USER_CONTEXT_ID
)
;
this
.
_userContextId
=
userContextId
?
parseInt
(
userContextId
[
1
]
10
)
:
Ci
.
nsIScriptSecurityManager
.
DEFAULT_USER_CONTEXT_ID
;
this
.
_searchTokens
=
this
.
filterTokens
(
getUnfilteredSearchTokens
(
this
.
_searchString
)
)
;
this
.
_keywordSubstitute
=
null
;
this
.
_prohibitSearchSuggestions
=
prohibitSearchSuggestions
;
this
.
_listener
=
autocompleteListener
;
this
.
_autocompleteSearch
=
autocompleteSearch
;
let
result
=
previousResult
|
|
Cc
[
"
mozilla
.
org
/
autocomplete
/
simple
-
result
;
1
"
]
.
createInstance
(
Ci
.
nsIAutoCompleteSimpleResult
)
;
result
.
setSearchString
(
searchString
)
;
result
.
setListener
(
{
onValueRemoved
(
result
spec
removeFromDB
)
{
if
(
removeFromDB
)
{
PlacesUtils
.
history
.
remove
(
spec
)
.
catch
(
Cu
.
reportError
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteSimpleResultListener
]
)
}
)
;
result
.
setDefaultIndex
(
-
1
)
;
this
.
_result
=
result
;
this
.
_previousSearchMatchTypes
=
[
]
;
for
(
let
i
=
0
;
previousResult
&
&
i
<
previousResult
.
matchCount
;
+
+
i
)
{
let
style
=
previousResult
.
getStyleAt
(
i
)
;
if
(
style
.
includes
(
"
heuristic
"
)
)
{
this
.
_previousSearchMatchTypes
.
push
(
MATCHTYPE
.
HEURISTIC
)
;
}
else
if
(
style
.
includes
(
"
suggestion
"
)
)
{
this
.
_previousSearchMatchTypes
.
push
(
MATCHTYPE
.
SUGGESTION
)
;
}
else
if
(
style
.
includes
(
"
extension
"
)
)
{
this
.
_previousSearchMatchTypes
.
push
(
MATCHTYPE
.
EXTENSION
)
;
}
else
{
this
.
_previousSearchMatchTypes
.
push
(
MATCHTYPE
.
GENERAL
)
;
}
}
this
.
_adaptiveCount
=
0
;
this
.
_extraAdaptiveRows
=
[
]
;
this
.
_extraRemoteTabRows
=
[
]
;
this
.
_currentMatchCount
=
0
;
this
.
_usedURLs
=
[
]
;
this
.
_usedPlaceIds
=
new
Set
(
)
;
this
.
_counts
=
Object
.
values
(
MATCHTYPE
)
.
reduce
(
(
o
p
)
=
>
{
o
[
p
]
=
0
;
return
o
;
}
{
}
)
;
}
Search
.
prototype
=
{
setBehavior
(
type
)
{
type
=
type
.
toUpperCase
(
)
;
this
.
_behavior
|
=
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
type
]
;
if
(
type
=
=
"
TYPED
"
)
{
this
.
setBehavior
(
"
history
"
)
;
}
}
hasBehavior
(
type
)
{
let
behavior
=
Ci
.
mozIPlacesAutoComplete
[
"
BEHAVIOR_
"
+
type
.
toUpperCase
(
)
]
;
if
(
this
.
_disablePrivateActions
&
&
behavior
=
=
Ci
.
mozIPlacesAutoComplete
.
BEHAVIOR_OPENPAGE
)
{
return
false
;
}
return
this
.
_behavior
&
behavior
;
}
_sleepResolve
:
null
_sleep
(
aTimeMs
)
{
if
(
!
this
.
_sleepTimer
)
this
.
_sleepTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
return
new
Promise
(
resolve
=
>
{
this
.
_sleepResolve
=
resolve
;
this
.
_sleepTimer
.
initWithCallback
(
resolve
aTimeMs
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
)
;
}
filterTokens
(
tokens
)
{
let
foundToken
=
false
;
for
(
let
i
=
tokens
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
behavior
=
TOKEN_TO_BEHAVIOR_MAP
.
get
(
tokens
[
i
]
)
;
if
(
behavior
&
&
(
behavior
!
=
"
openpage
"
|
|
this
.
_enableActions
)
)
{
if
(
!
foundToken
)
{
foundToken
=
true
;
this
.
_behavior
=
0
;
this
.
setBehavior
(
"
restrict
"
)
;
}
this
.
setBehavior
(
behavior
)
;
tokens
.
splice
(
i
1
)
;
}
}
if
(
!
Prefs
.
get
(
"
filter
.
javascript
"
)
)
{
this
.
setBehavior
(
"
javascript
"
)
;
}
return
tokens
;
}
stop
(
)
{
if
(
!
this
.
pending
)
return
;
if
(
this
.
_notifyTimer
)
this
.
_notifyTimer
.
cancel
(
)
;
this
.
_notifyDelaysCount
=
0
;
if
(
this
.
_sleepTimer
)
this
.
_sleepTimer
.
cancel
(
)
;
if
(
this
.
_sleepResolve
)
{
this
.
_sleepResolve
(
)
;
this
.
_sleepResolve
=
null
;
}
if
(
this
.
_searchSuggestionController
)
{
this
.
_searchSuggestionController
.
stop
(
)
;
this
.
_searchSuggestionController
=
null
;
}
if
(
typeof
this
.
interrupt
=
=
"
function
"
)
{
this
.
interrupt
(
)
;
}
this
.
pending
=
false
;
}
pending
:
true
async
execute
(
conn
)
{
if
(
!
this
.
pending
)
return
;
this
.
interrupt
=
(
)
=
>
{
if
(
!
SwitchToTabStorage
.
updating
)
{
conn
.
interrupt
(
)
;
}
}
;
TelemetryStopwatch
.
start
(
TELEMETRY_1ST_RESULT
this
)
;
TelemetryStopwatch
.
start
(
TELEMETRY_6_FIRST_RESULTS
this
)
;
await
PlacesSearchAutocompleteProvider
.
ensureInitialized
(
)
;
if
(
!
this
.
pending
)
return
;
await
this
.
_checkPreloadedSitesExpiry
(
)
;
this
.
_addingHeuristicFirstMatch
=
true
;
let
hasHeuristic
=
await
this
.
_matchFirstHeuristicResult
(
conn
)
;
this
.
_addingHeuristicFirstMatch
=
false
;
this
.
_cleanUpNonCurrentMatches
(
MATCHTYPE
.
HEURISTIC
)
;
if
(
!
this
.
pending
)
return
;
if
(
hasHeuristic
)
{
await
this
.
_sleep
(
Prefs
.
get
(
"
delay
"
)
)
;
if
(
!
this
.
pending
)
return
;
}
let
extensionsCompletePromise
=
Promise
.
resolve
(
)
;
if
(
this
.
_searchTokens
.
length
>
0
&
&
ExtensionSearchHandler
.
isKeywordRegistered
(
this
.
_searchTokens
[
0
]
)
&
&
this
.
_originalSearchString
.
length
>
this
.
_searchTokens
[
0
]
.
length
)
{
extensionsCompletePromise
=
this
.
_matchExtensionSuggestions
(
)
;
}
else
if
(
ExtensionSearchHandler
.
hasActiveInputSession
(
)
)
{
ExtensionSearchHandler
.
handleInputCancelled
(
)
;
}
let
searchSuggestionsCompletePromise
=
Promise
.
resolve
(
)
;
if
(
this
.
_enableActions
&
&
this
.
_searchTokens
.
length
>
0
)
{
let
searchString
=
this
.
_searchTokens
.
join
(
"
"
)
.
substr
(
0
Prefs
.
get
(
"
maxCharsForSearchSuggestions
"
)
)
;
if
(
this
.
hasBehavior
(
"
searches
"
)
&
&
!
this
.
_inPrivateWindow
&
&
!
this
.
_prohibitSearchSuggestionsFor
(
searchString
)
)
{
searchSuggestionsCompletePromise
=
this
.
_matchSearchSuggestions
(
searchString
)
;
if
(
this
.
hasBehavior
(
"
restrict
"
)
)
{
await
searchSuggestionsCompletePromise
;
this
.
_cleanUpNonCurrentMatches
(
MATCHTYPE
.
SUGGESTION
)
;
this
.
_autocompleteSearch
.
finishSearch
(
true
)
;
return
;
}
}
}
searchSuggestionsCompletePromise
.
then
(
(
)
=
>
{
this
.
_cleanUpNonCurrentMatches
(
MATCHTYPE
.
SUGGESTION
)
;
}
)
;
await
conn
.
executeCached
(
this
.
_adaptiveQuery
[
0
]
this
.
_adaptiveQuery
[
1
]
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
return
;
if
(
this
.
_enableActions
&
&
this
.
hasBehavior
(
"
openpage
"
)
)
{
await
this
.
_matchRemoteTabs
(
)
;
if
(
!
this
.
pending
)
return
;
}
let
queries
=
[
]
;
if
(
this
.
hasBehavior
(
"
openpage
"
)
)
{
queries
.
push
(
this
.
_switchToTabQuery
)
;
}
queries
.
push
(
this
.
_searchQuery
)
;
for
(
let
[
query
params
]
of
queries
)
{
await
conn
.
executeCached
(
query
params
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
return
;
}
while
(
this
.
_extraAdaptiveRows
.
length
&
&
this
.
_currentMatchCount
<
Prefs
.
get
(
"
maxRichResults
"
)
)
{
this
.
_addFilteredQueryMatch
(
this
.
_extraAdaptiveRows
.
shift
(
)
)
;
}
while
(
this
.
_extraRemoteTabRows
.
length
&
&
this
.
_currentMatchCount
<
Prefs
.
get
(
"
maxRichResults
"
)
)
{
this
.
_addMatch
(
this
.
_extraRemoteTabRows
.
shift
(
)
)
;
}
this
.
_cleanUpNonCurrentMatches
(
MATCHTYPE
.
GENERAL
)
;
let
count
=
this
.
_counts
[
MATCHTYPE
.
GENERAL
]
+
this
.
_counts
[
MATCHTYPE
.
HEURISTIC
]
;
if
(
this
.
_matchBehavior
=
=
MATCH_BOUNDARY_ANYWHERE
&
&
count
<
Prefs
.
get
(
"
maxRichResults
"
)
)
{
this
.
_matchBehavior
=
MATCH_ANYWHERE
;
for
(
let
[
query
params
]
of
[
this
.
_adaptiveQuery
this
.
_searchQuery
]
)
{
await
conn
.
executeCached
(
query
params
this
.
_onResultRow
.
bind
(
this
)
)
;
if
(
!
this
.
pending
)
return
;
}
}
this
.
_matchPreloadedSites
(
)
;
await
searchSuggestionsCompletePromise
;
await
extensionsCompletePromise
;
}
async
_checkPreloadedSitesExpiry
(
)
{
if
(
!
Prefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
return
;
let
profileCreationDate
=
await
ProfileAgeCreatedPromise
;
let
daysSinceProfileCreation
=
(
Date
.
now
(
)
-
profileCreationDate
)
/
MS_PER_DAY
;
if
(
daysSinceProfileCreation
>
Prefs
.
get
(
"
usepreloadedtopurls
.
expire_days
"
)
)
Services
.
prefs
.
setBoolPref
(
"
browser
.
urlbar
.
usepreloadedtopurls
.
enabled
"
false
)
;
}
_matchPreloadedSites
(
)
{
if
(
!
Prefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
return
;
}
if
(
!
this
.
_searchString
)
{
return
;
}
for
(
let
site
of
PreloadedSiteStorage
.
sites
)
{
let
url
=
site
.
uri
.
spec
;
if
(
(
!
this
.
_strippedPrefix
|
|
url
.
startsWith
(
this
.
_strippedPrefix
)
)
&
&
(
site
.
uri
.
host
.
includes
(
this
.
_searchString
)
|
|
site
.
_matchTitle
.
includes
(
this
.
_searchString
)
)
)
{
this
.
_addMatch
(
{
value
:
url
comment
:
site
.
title
style
:
"
preloaded
-
top
-
site
"
frecency
:
FRECENCY_DEFAULT
-
1
}
)
;
}
}
}
_matchPreloadedSiteForAutofill
(
)
{
if
(
!
Prefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
return
false
;
}
let
matchedSite
=
PreloadedSiteStorage
.
sites
.
find
(
site
=
>
{
return
(
!
this
.
_strippedPrefix
|
|
site
.
uri
.
spec
.
startsWith
(
this
.
_strippedPrefix
)
)
&
&
(
site
.
uri
.
host
.
startsWith
(
this
.
_searchString
)
|
|
site
.
uri
.
host
.
startsWith
(
"
www
.
"
+
this
.
_searchString
)
)
;
}
)
;
if
(
!
matchedSite
)
{
return
false
;
}
this
.
_result
.
setDefaultIndex
(
0
)
;
let
url
=
matchedSite
.
uri
.
spec
;
let
value
=
stripPrefix
(
url
)
[
1
]
;
value
=
value
.
substr
(
value
.
indexOf
(
this
.
_searchString
)
)
;
this
.
_addAutofillMatch
(
value
url
Infinity
[
"
preloaded
-
top
-
site
"
]
)
;
return
true
;
}
async
_matchFirstHeuristicResult
(
conn
)
{
let
hasSearchTerms
=
this
.
_searchTokens
.
length
>
0
;
if
(
hasSearchTerms
)
{
let
matched
=
await
this
.
_matchExtensionHeuristicResult
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
_enableActions
&
&
hasSearchTerms
)
{
let
matched
=
await
this
.
_matchSearchEngineAlias
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
hasSearchTerms
)
{
let
matched
=
await
this
.
_matchPlacesKeyword
(
)
;
if
(
matched
)
{
return
true
;
}
}
let
shouldAutofill
=
this
.
_shouldAutofill
;
if
(
this
.
pending
&
&
shouldAutofill
)
{
let
matched
=
await
this
.
_matchKnownUrl
(
conn
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
shouldAutofill
)
{
let
matched
=
await
this
.
_matchSearchEngineDomain
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
shouldAutofill
)
{
let
matched
=
this
.
_matchPreloadedSiteForAutofill
(
)
;
if
(
matched
)
{
return
true
;
}
}
if
(
this
.
pending
&
&
hasSearchTerms
&
&
this
.
_enableActions
)
{
let
matched
=
await
this
.
_matchUnknownUrl
(
)
;
if
(
matched
)
{
try
{
new
URL
(
this
.
_originalSearchString
)
;
}
catch
(
ex
)
{
if
(
Prefs
.
get
(
"
keyword
.
enabled
"
)
&
&
!
looksLikeUrl
(
this
.
_originalSearchString
true
)
)
{
this
.
_addingHeuristicFirstMatch
=
false
;
await
this
.
_matchCurrentSearchEngine
(
)
;
this
.
_addingHeuristicFirstMatch
=
true
;
}
}
return
true
;
}
}
if
(
this
.
pending
&
&
this
.
_enableActions
&
&
this
.
_originalSearchString
)
{
let
matched
=
await
this
.
_matchCurrentSearchEngine
(
)
;
if
(
matched
)
{
return
true
;
}
}
return
false
;
}
_matchSearchSuggestions
(
searchString
)
{
this
.
_searchSuggestionController
=
PlacesSearchAutocompleteProvider
.
getSuggestionController
(
searchString
this
.
_inPrivateWindow
Prefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
Prefs
.
get
(
"
maxRichResults
"
)
-
Prefs
.
get
(
"
maxHistoricalSearchSuggestions
"
)
this
.
_userContextId
)
;
return
this
.
_searchSuggestionController
.
fetchCompletePromise
.
then
(
(
)
=
>
{
if
(
!
this
.
_searchSuggestionController
)
return
;
if
(
this
.
_searchSuggestionController
.
resultsCount
>
=
0
&
&
this
.
_searchSuggestionController
.
resultsCount
<
2
)
{
this
.
_lastLowResultsSearchSuggestion
=
this
.
_originalSearchString
;
}
while
(
this
.
pending
)
{
let
result
=
this
.
_searchSuggestionController
.
consume
(
)
;
if
(
!
result
)
break
;
let
{
match
suggestion
historical
}
=
result
;
if
(
!
looksLikeUrl
(
suggestion
)
)
{
let
searchString
=
this
.
_searchTokens
.
join
(
"
"
)
;
this
.
_addSearchEngineMatch
(
match
searchString
suggestion
historical
)
;
}
}
}
)
.
catch
(
Cu
.
reportError
)
;
}
_prohibitSearchSuggestionsFor
(
searchString
)
{
if
(
this
.
_prohibitSearchSuggestions
)
return
true
;
if
(
searchString
.
length
<
2
)
return
true
;
if
(
this
.
_searchTokens
.
length
=
=
1
&
&
REGEXP_SINGLEWORD_HOST
.
test
(
this
.
_searchTokens
[
0
]
)
&
&
Services
.
uriFixup
.
isDomainWhitelisted
(
this
.
_searchTokens
[
0
]
-
1
)
)
{
return
true
;
}
if
(
DISALLOWED_URLLIKE_PREFIXES
.
some
(
prefix
=
>
this
.
_trimmedOriginalSearchString
=
=
prefix
)
|
|
DISALLOWED_URLLIKE_PREFIXES
.
some
(
prefix
=
>
this
.
_trimmedOriginalSearchString
.
startsWith
(
prefix
+
"
:
"
)
)
)
{
return
true
;
}
return
this
.
_searchTokens
.
some
(
looksLikeUrl
)
;
}
async
_matchKnownUrl
(
conn
)
{
let
gotResult
=
false
;
let
query
params
;
if
(
looksLikeOrigin
(
this
.
_searchString
)
)
{
[
query
params
]
=
this
.
_originQuery
;
}
else
{
[
query
params
]
=
this
.
_urlQuery
;
}
if
(
query
)
{
await
conn
.
executeCached
(
query
params
(
row
cancel
)
=
>
{
gotResult
=
true
;
this
.
_onResultRow
(
row
cancel
)
;
}
)
;
}
return
gotResult
;
}
_matchExtensionHeuristicResult
(
)
{
if
(
ExtensionSearchHandler
.
isKeywordRegistered
(
this
.
_searchTokens
[
0
]
)
&
&
this
.
_originalSearchString
.
length
>
this
.
_searchTokens
[
0
]
.
length
)
{
let
description
=
ExtensionSearchHandler
.
getDescription
(
this
.
_searchTokens
[
0
]
)
;
this
.
_addExtensionMatch
(
this
.
_originalSearchString
description
)
;
return
true
;
}
return
false
;
}
async
_matchPlacesKeyword
(
)
{
let
keyword
=
this
.
_searchTokens
[
0
]
;
let
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
keyword
)
;
if
(
!
entry
)
return
false
;
let
searchString
=
this
.
_trimmedOriginalSearchString
.
substr
(
keyword
.
length
+
1
)
;
let
url
=
null
postData
=
null
;
try
{
[
url
postData
]
=
await
BrowserUtils
.
parseUrlAndPostData
(
entry
.
url
.
href
entry
.
postData
searchString
)
;
}
catch
(
ex
)
{
return
false
;
}
let
style
=
"
keyword
"
;
let
value
=
url
;
if
(
this
.
_enableActions
)
{
style
=
"
action
"
+
style
;
value
=
PlacesUtils
.
mozActionURI
(
"
keyword
"
{
url
input
:
this
.
_originalSearchString
postData
}
)
;
}
let
comment
=
entry
.
url
.
host
;
this
.
_addMatch
(
{
value
comment
icon
:
iconHelper
(
entry
.
url
)
style
frecency
:
Infinity
}
)
;
if
(
!
this
.
_keywordSubstitute
)
{
this
.
_keywordSubstitute
=
entry
.
url
.
host
;
}
return
true
;
}
async
_matchSearchEngineDomain
(
)
{
if
(
!
Prefs
.
get
(
"
autoFill
.
searchEngines
"
)
)
{
return
false
;
}
if
(
!
this
.
_searchString
)
{
return
false
;
}
let
searchStr
=
this
.
_searchString
;
if
(
searchStr
.
indexOf
(
"
/
"
)
=
=
searchStr
.
length
-
1
)
{
searchStr
=
searchStr
.
slice
(
0
-
1
)
;
}
if
(
!
looksLikeOrigin
(
searchStr
)
)
{
return
false
;
}
let
match
=
await
PlacesSearchAutocompleteProvider
.
findMatchByToken
(
searchStr
)
;
if
(
!
match
|
|
(
this
.
_strippedPrefix
&
&
!
match
.
url
.
startsWith
(
this
.
_strippedPrefix
)
)
|
|
!
(
match
.
token
+
"
/
"
)
.
includes
(
this
.
_searchString
)
)
{
return
false
;
}
let
value
=
this
.
_strippedPrefix
+
match
.
token
.
substr
(
match
.
token
.
indexOf
(
searchStr
)
)
+
"
/
"
;
let
finalCompleteValue
=
match
.
url
;
try
{
let
fixupInfo
=
Services
.
uriFixup
.
getFixupURIInfo
(
match
.
url
0
)
;
if
(
fixupInfo
.
fixedURI
)
{
finalCompleteValue
=
fixupInfo
.
fixedURI
.
spec
;
}
}
catch
(
ex
)
{
}
this
.
_result
.
setDefaultIndex
(
0
)
;
this
.
_addMatch
(
{
value
finalCompleteValue
comment
:
match
.
engineName
icon
:
match
.
iconUrl
style
:
"
priority
-
search
"
frecency
:
Infinity
}
)
;
return
true
;
}
async
_matchSearchEngineAlias
(
)
{
if
(
this
.
_searchTokens
.
length
<
1
)
return
false
;
let
alias
=
this
.
_searchTokens
[
0
]
;
let
match
=
await
PlacesSearchAutocompleteProvider
.
findMatchByAlias
(
alias
)
;
if
(
!
match
)
return
false
;
match
.
engineAlias
=
alias
;
let
query
=
this
.
_trimmedOriginalSearchString
.
substr
(
alias
.
length
+
1
)
;
this
.
_addSearchEngineMatch
(
match
query
)
;
if
(
!
this
.
_keywordSubstitute
)
{
this
.
_keywordSubstitute
=
match
.
resultDomain
;
}
return
true
;
}
async
_matchCurrentSearchEngine
(
)
{
let
match
=
await
PlacesSearchAutocompleteProvider
.
getDefaultMatch
(
)
;
if
(
!
match
)
return
false
;
let
query
=
this
.
_originalSearchString
;
this
.
_addSearchEngineMatch
(
match
query
)
;
return
true
;
}
_addExtensionMatch
(
content
comment
)
{
let
count
=
this
.
_counts
[
MATCHTYPE
.
EXTENSION
]
+
this
.
_counts
[
MATCHTYPE
.
HEURISTIC
]
;
if
(
count
>
=
MAXIMUM_ALLOWED_EXTENSION_MATCHES
)
{
return
;
}
this
.
_addMatch
(
{
value
:
PlacesUtils
.
mozActionURI
(
"
extension
"
{
content
keyword
:
this
.
_searchTokens
[
0
]
}
)
comment
icon
:
"
chrome
:
/
/
browser
/
content
/
extension
.
svg
"
style
:
"
action
extension
"
frecency
:
Infinity
type
:
MATCHTYPE
.
EXTENSION
}
)
;
}
_addSearchEngineMatch
(
searchMatch
query
suggestion
=
"
"
historical
=
false
)
{
let
actionURLParams
=
{
engineName
:
searchMatch
.
engineName
input
:
suggestion
|
|
this
.
_originalSearchString
searchQuery
:
query
}
;
if
(
suggestion
)
actionURLParams
.
searchSuggestion
=
suggestion
;
if
(
searchMatch
.
engineAlias
)
{
actionURLParams
.
alias
=
searchMatch
.
engineAlias
;
}
let
value
=
PlacesUtils
.
mozActionURI
(
"
searchengine
"
actionURLParams
)
;
let
match
=
{
value
comment
:
searchMatch
.
engineName
icon
:
searchMatch
.
iconUrl
style
:
"
action
searchengine
"
frecency
:
FRECENCY_DEFAULT
}
;
if
(
suggestion
)
{
match
.
style
+
=
"
suggestion
"
;
match
.
type
=
MATCHTYPE
.
SUGGESTION
;
}
this
.
_addMatch
(
match
)
;
}
_matchExtensionSuggestions
(
)
{
let
promise
=
ExtensionSearchHandler
.
handleSearch
(
this
.
_searchTokens
[
0
]
this
.
_originalSearchString
suggestions
=
>
{
for
(
let
suggestion
of
suggestions
)
{
let
content
=
{
this
.
_searchTokens
[
0
]
}
{
suggestion
.
content
}
;
this
.
_addExtensionMatch
(
content
suggestion
.
description
)
;
}
}
)
;
setTimeout
(
(
)
=
>
this
.
_cleanUpNonCurrentMatches
(
MATCHTYPE
.
EXTENSION
)
100
)
;
let
timeoutPromise
=
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
MAXIMUM_ALLOWED_EXTENSION_TIME_MS
)
;
}
)
;
return
Promise
.
race
(
[
timeoutPromise
promise
]
)
.
catch
(
Cu
.
reportError
)
;
}
async
_matchRemoteTabs
(
)
{
if
(
!
syncUsernamePref
)
{
return
;
}
let
matches
=
await
PlacesRemoteTabsAutocompleteProvider
.
getMatches
(
this
.
_originalSearchString
)
;
for
(
let
{
url
title
icon
deviceName
lastUsed
}
of
matches
)
{
if
(
!
icon
)
{
icon
=
iconHelper
(
url
)
;
}
else
{
icon
=
PlacesUtils
.
favicons
.
getFaviconLinkForIcon
(
Services
.
io
.
newURI
(
icon
)
)
.
spec
;
}
let
match
=
{
value
:
PlacesUtils
.
mozActionURI
(
"
remotetab
"
{
url
deviceName
}
)
comment
:
title
|
|
url
style
:
"
action
remotetab
"
frecency
:
FRECENCY_DEFAULT
+
1
icon
}
;
if
(
lastUsed
>
(
Date
.
now
(
)
-
RECENT_REMOTE_TAB_THRESHOLD_MS
)
)
{
this
.
_addMatch
(
match
)
;
}
else
{
this
.
_extraRemoteTabRows
.
push
(
match
)
;
}
}
}
_matchUnknownUrl
(
)
{
let
flags
=
Ci
.
nsIURIFixup
.
FIXUP_FLAG_FIX_SCHEME_TYPOS
|
Ci
.
nsIURIFixup
.
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
let
fixupInfo
=
null
;
let
searchUrl
=
this
.
_trimmedOriginalSearchString
;
try
{
fixupInfo
=
Services
.
uriFixup
.
getFixupURIInfo
(
searchUrl
flags
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_MALFORMED_URI
&
&
!
Prefs
.
get
(
"
keyword
.
enabled
"
)
)
{
let
value
=
PlacesUtils
.
mozActionURI
(
"
visiturl
"
{
url
:
searchUrl
input
:
searchUrl
}
)
;
this
.
_addMatch
(
{
value
comment
:
searchUrl
style
:
"
action
visiturl
"
frecency
:
Infinity
}
)
;
return
true
;
}
return
false
;
}
if
(
!
fixupInfo
.
fixedURI
|
|
fixupInfo
.
keywordAsSent
)
return
false
;
let
uri
=
fixupInfo
.
fixedURI
;
let
hostExpected
=
[
"
http
"
"
https
"
"
ftp
"
"
chrome
"
]
.
includes
(
uri
.
scheme
)
;
if
(
hostExpected
&
&
!
uri
.
host
)
return
false
;
let
escapedURL
=
uri
.
displaySpec
;
let
displayURL
=
Services
.
textToSubURI
.
unEscapeURIForUI
(
"
UTF
-
8
"
escapedURL
)
;
let
value
=
PlacesUtils
.
mozActionURI
(
"
visiturl
"
{
url
:
escapedURL
input
:
searchUrl
}
)
;
let
match
=
{
value
comment
:
displayURL
style
:
"
action
visiturl
"
frecency
:
Infinity
}
;
if
(
hostExpected
&
&
(
searchUrl
.
endsWith
(
"
/
"
)
|
|
uri
.
pathQueryRef
.
length
>
1
)
)
{
match
.
icon
=
page
-
icon
:
{
uri
.
prePath
}
/
;
}
this
.
_addMatch
(
match
)
;
return
true
;
}
_onResultRow
(
row
cancel
)
{
let
queryType
=
row
.
getResultByIndex
(
QUERYINDEX_QUERYTYPE
)
;
switch
(
queryType
)
{
case
QUERYTYPE_AUTOFILL_ORIGIN
:
this
.
_result
.
setDefaultIndex
(
0
)
;
this
.
_addOriginAutofillMatch
(
row
)
;
break
;
case
QUERYTYPE_AUTOFILL_URL
:
this
.
_result
.
setDefaultIndex
(
0
)
;
this
.
_addURLAutofillMatch
(
row
)
;
break
;
case
QUERYTYPE_ADAPTIVE
:
this
.
_addAdaptiveQueryMatch
(
row
)
;
break
;
case
QUERYTYPE_FILTERED
:
this
.
_addFilteredQueryMatch
(
row
)
;
break
;
}
let
count
=
this
.
_counts
[
MATCHTYPE
.
GENERAL
]
+
this
.
_counts
[
MATCHTYPE
.
HEURISTIC
]
;
if
(
!
this
.
pending
|
|
count
>
=
Prefs
.
get
(
"
maxRichResults
"
)
)
{
cancel
(
)
;
}
}
_maybeRestyleSearchMatch
(
match
)
{
let
parseResult
=
PlacesSearchAutocompleteProvider
.
parseSubmissionURL
(
match
.
value
)
;
if
(
!
parseResult
)
{
return
;
}
let
terms
=
parseResult
.
terms
.
toLowerCase
(
)
;
if
(
this
.
_searchTokens
.
length
>
0
&
&
this
.
_searchTokens
.
every
(
token
=
>
!
terms
.
includes
(
token
)
)
)
{
return
;
}
match
.
value
=
PlacesUtils
.
mozActionURI
(
"
searchengine
"
{
engineName
:
parseResult
.
engineName
input
:
parseResult
.
terms
searchQuery
:
parseResult
.
terms
}
)
;
match
.
comment
=
parseResult
.
engineName
;
match
.
icon
=
match
.
icon
|
|
match
.
iconUrl
;
match
.
style
=
"
action
searchengine
favicon
"
;
}
_addMatch
(
match
)
{
if
(
typeof
match
.
frecency
!
=
"
number
"
)
throw
new
Error
(
"
Frecency
not
provided
"
)
;
if
(
this
.
_addingHeuristicFirstMatch
)
match
.
type
=
MATCHTYPE
.
HEURISTIC
;
else
if
(
typeof
match
.
type
!
=
"
string
"
)
match
.
type
=
MATCHTYPE
.
GENERAL
;
if
(
!
this
.
pending
)
return
;
match
.
style
=
match
.
style
|
|
"
favicon
"
;
if
(
Prefs
.
get
(
"
restyleSearches
"
)
&
&
match
.
style
=
=
"
favicon
"
)
{
this
.
_maybeRestyleSearchMatch
(
match
)
;
}
if
(
this
.
_addingHeuristicFirstMatch
)
{
match
.
style
+
=
"
heuristic
"
;
}
match
.
icon
=
match
.
icon
|
|
"
"
;
match
.
finalCompleteValue
=
match
.
finalCompleteValue
|
|
"
"
;
let
{
index
replace
}
=
this
.
_getInsertIndexForMatch
(
match
)
;
if
(
index
=
=
-
1
)
return
;
if
(
replace
)
{
this
.
_result
.
removeMatchAt
(
index
)
;
}
this
.
_result
.
insertMatchAt
(
index
match
.
value
match
.
comment
match
.
icon
match
.
style
match
.
finalCompleteValue
)
;
this
.
_currentMatchCount
+
+
;
this
.
_counts
[
match
.
type
]
+
+
;
if
(
this
.
_currentMatchCount
=
=
1
)
TelemetryStopwatch
.
finish
(
TELEMETRY_1ST_RESULT
this
)
;
if
(
this
.
_currentMatchCount
=
=
6
)
TelemetryStopwatch
.
finish
(
TELEMETRY_6_FIRST_RESULTS
this
)
;
this
.
notifyResult
(
true
match
.
type
=
=
MATCHTYPE
.
HEURISTIC
)
;
}
_getInsertIndexForMatch
(
match
)
{
let
[
urlMapKey
action
]
=
makeKeyForURL
(
match
)
;
if
(
(
match
.
placeId
&
&
this
.
_usedPlaceIds
.
has
(
match
.
placeId
)
)
|
|
this
.
_usedURLs
.
map
(
e
=
>
e
.
key
)
.
includes
(
urlMapKey
)
)
{
let
isDupe
=
true
;
if
(
action
&
&
[
"
switchtab
"
"
remotetab
"
]
.
includes
(
action
.
type
)
)
{
for
(
let
i
=
0
;
i
<
this
.
_usedURLs
.
length
;
+
+
i
)
{
let
{
key
:
matchKey
action
:
matchAction
type
:
matchType
}
=
this
.
_usedURLs
[
i
]
;
if
(
matchKey
=
=
urlMapKey
)
{
isDupe
=
true
;
if
(
matchType
=
=
MATCHTYPE
.
HEURISTIC
&
&
action
.
type
=
=
"
switchtab
"
)
{
isDupe
=
false
;
continue
;
}
if
(
!
matchAction
|
|
action
.
type
=
=
"
switchtab
"
)
{
this
.
_usedURLs
[
i
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
}
;
return
{
index
:
i
replace
:
true
}
;
}
break
;
}
}
}
if
(
isDupe
)
{
return
{
index
:
-
1
replace
:
false
}
;
}
}
if
(
match
.
placeId
)
this
.
_usedPlaceIds
.
add
(
match
.
placeId
)
;
let
index
=
0
;
if
(
!
this
.
_buckets
)
{
let
buckets
=
match
.
type
=
=
MATCHTYPE
.
HEURISTIC
&
&
match
.
style
.
includes
(
"
searchengine
"
)
?
Prefs
.
get
(
"
matchBucketsSearch
"
)
:
Prefs
.
get
(
"
matchBuckets
"
)
;
this
.
_buckets
=
buckets
.
map
(
(
[
type
available
]
)
=
>
(
{
type
available
insertIndex
:
0
count
:
0
}
)
)
;
if
(
this
.
_previousSearchMatchTypes
.
length
>
0
)
{
for
(
let
type
of
this
.
_previousSearchMatchTypes
)
{
for
(
let
bucket
of
this
.
_buckets
)
{
if
(
type
=
=
bucket
.
type
&
&
bucket
.
count
<
bucket
.
available
)
{
bucket
.
count
+
+
;
break
;
}
}
}
}
}
let
replace
=
0
;
for
(
let
bucket
of
this
.
_buckets
)
{
if
(
match
.
type
!
=
bucket
.
type
|
|
!
bucket
.
available
)
{
index
+
=
bucket
.
count
;
continue
;
}
index
+
=
bucket
.
insertIndex
;
bucket
.
available
-
-
;
if
(
bucket
.
insertIndex
<
bucket
.
count
)
{
replace
=
true
;
}
else
{
bucket
.
count
+
+
;
}
bucket
.
insertIndex
+
+
;
break
;
}
this
.
_usedURLs
[
index
]
=
{
key
:
urlMapKey
action
type
:
match
.
type
}
;
return
{
index
replace
}
;
}
_cleanUpNonCurrentMatches
(
type
notify
=
true
)
{
if
(
this
.
_previousSearchMatchTypes
.
length
=
=
0
|
|
!
this
.
pending
)
return
;
let
index
=
0
;
let
changed
=
false
;
if
(
!
this
.
_buckets
)
{
while
(
this
.
_previousSearchMatchTypes
.
length
&
&
this
.
_previousSearchMatchTypes
[
0
]
=
=
type
)
{
this
.
_previousSearchMatchTypes
.
shift
(
)
;
this
.
_result
.
removeMatchAt
(
0
)
;
changed
=
true
;
}
}
else
{
for
(
let
bucket
of
this
.
_buckets
)
{
if
(
bucket
.
type
!
=
type
)
{
index
+
=
bucket
.
count
;
continue
;
}
index
+
=
bucket
.
insertIndex
;
while
(
bucket
.
count
>
bucket
.
insertIndex
)
{
this
.
_result
.
removeMatchAt
(
index
)
;
changed
=
true
;
bucket
.
count
-
-
;
}
}
}
if
(
changed
&
&
notify
)
{
this
.
notifyResult
(
true
)
;
}
}
cleanUpRestrictNonCurrentMatches
(
)
{
if
(
this
.
hasBehavior
(
"
restrict
"
)
&
&
this
.
_previousSearchMatchTypes
.
length
>
0
)
{
for
(
let
type
of
new
Set
(
this
.
_previousSearchMatchTypes
)
)
{
if
(
this
.
_counts
[
type
]
=
=
0
)
{
this
.
_cleanUpNonCurrentMatches
(
type
false
)
;
}
}
}
}
_addOriginAutofillMatch
(
row
)
{
this
.
_addAutofillMatch
(
row
.
getResultByIndex
(
QUERYINDEX_ORIGIN_AUTOFILLED_VALUE
)
row
.
getResultByIndex
(
QUERYINDEX_ORIGIN_URL
)
row
.
getResultByIndex
(
QUERYINDEX_ORIGIN_FRECENCY
)
)
;
}
_addURLAutofillMatch
(
row
)
{
let
url
=
row
.
getResultByIndex
(
QUERYINDEX_URL_URL
)
;
let
strippedURL
=
row
.
getResultByIndex
(
QUERYINDEX_URL_STRIPPED_URL
)
;
let
value
;
let
strippedURLIndex
=
url
.
indexOf
(
strippedURL
)
;
let
strippedPrefix
=
url
.
substr
(
0
strippedURLIndex
)
;
let
nextSlashIndex
=
url
.
indexOf
(
"
/
"
strippedURLIndex
+
strippedURL
.
length
-
1
)
;
if
(
nextSlashIndex
=
=
-
1
)
{
value
=
url
.
substr
(
strippedURLIndex
)
;
}
else
{
value
=
url
.
substring
(
strippedURLIndex
nextSlashIndex
+
1
)
;
}
this
.
_addAutofillMatch
(
value
strippedPrefix
+
value
row
.
getResultByIndex
(
QUERYINDEX_URL_FRECENCY
)
)
;
}
_addAutofillMatch
(
autofilledValue
finalCompleteValue
frecency
extraStyles
=
[
]
)
{
let
comment
=
stripHttpAndTrim
(
finalCompleteValue
!
this
.
_searchString
.
includes
(
"
/
"
)
)
;
this
.
_addMatch
(
{
value
:
this
.
_strippedPrefix
+
autofilledValue
finalCompleteValue
comment
frecency
style
:
[
"
autofill
"
]
.
concat
(
extraStyles
)
.
join
(
"
"
)
icon
:
iconHelper
(
finalCompleteValue
)
}
)
;
}
_addAdaptiveQueryMatch
(
row
)
{
if
(
this
.
_adaptiveCount
<
Math
.
ceil
(
Prefs
.
get
(
"
maxRichResults
"
)
/
4
)
)
{
this
.
_addFilteredQueryMatch
(
row
)
;
}
else
{
this
.
_extraAdaptiveRows
.
push
(
row
)
;
}
this
.
_adaptiveCount
+
+
;
}
_addFilteredQueryMatch
(
row
)
{
let
match
=
{
}
;
match
.
placeId
=
row
.
getResultByIndex
(
QUERYINDEX_PLACEID
)
;
let
escapedURL
=
row
.
getResultByIndex
(
QUERYINDEX_URL
)
;
let
openPageCount
=
row
.
getResultByIndex
(
QUERYINDEX_SWITCHTAB
)
|
|
0
;
let
historyTitle
=
row
.
getResultByIndex
(
QUERYINDEX_TITLE
)
|
|
"
"
;
let
bookmarked
=
row
.
getResultByIndex
(
QUERYINDEX_BOOKMARKED
)
;
let
bookmarkTitle
=
bookmarked
?
row
.
getResultByIndex
(
QUERYINDEX_BOOKMARKTITLE
)
:
null
;
let
tags
=
row
.
getResultByIndex
(
QUERYINDEX_TAGS
)
|
|
"
"
;
let
frecency
=
row
.
getResultByIndex
(
QUERYINDEX_FRECENCY
)
;
let
url
=
escapedURL
;
let
action
=
null
;
if
(
this
.
_enableActions
&
&
openPageCount
>
0
&
&
this
.
hasBehavior
(
"
openpage
"
)
)
{
url
=
PlacesUtils
.
mozActionURI
(
"
switchtab
"
{
url
:
escapedURL
}
)
;
action
=
"
switchtab
"
;
if
(
frecency
=
=
null
)
frecency
=
FRECENCY_DEFAULT
;
}
let
title
=
bookmarkTitle
|
|
historyTitle
;
let
showTags
=
!
!
tags
;
if
(
this
.
hasBehavior
(
"
history
"
)
&
&
!
this
.
hasBehavior
(
"
bookmark
"
)
&
&
!
showTags
)
{
showTags
=
false
;
match
.
style
=
"
favicon
"
;
}
if
(
showTags
)
{
title
+
=
TITLE_TAGS_SEPARATOR
+
tags
;
}
if
(
!
match
.
style
)
{
if
(
showTags
)
{
match
.
style
=
this
.
hasBehavior
(
"
bookmark
"
)
?
"
bookmark
-
tag
"
:
"
tag
"
;
}
else
if
(
bookmarked
)
{
match
.
style
=
"
bookmark
"
;
}
}
if
(
action
)
match
.
style
=
"
action
"
+
action
;
match
.
value
=
url
;
match
.
comment
=
title
;
match
.
icon
=
iconHelper
(
escapedURL
)
;
match
.
frecency
=
frecency
;
this
.
_addMatch
(
match
)
;
}
get
_suggestionPrefQuery
(
)
{
if
(
!
this
.
hasBehavior
(
"
restrict
"
)
&
&
this
.
hasBehavior
(
"
history
"
)
&
&
this
.
hasBehavior
(
"
bookmark
"
)
)
{
return
this
.
hasBehavior
(
"
typed
"
)
?
defaultQuery
(
"
AND
h
.
typed
=
1
"
)
:
defaultQuery
(
)
;
}
let
conditions
=
[
]
;
if
(
this
.
hasBehavior
(
"
history
"
)
)
{
conditions
.
push
(
"
+
h
.
visit_count
>
0
"
)
;
}
if
(
this
.
hasBehavior
(
"
typed
"
)
)
{
conditions
.
push
(
"
h
.
typed
=
1
"
)
;
}
if
(
this
.
hasBehavior
(
"
bookmark
"
)
)
{
conditions
.
push
(
"
bookmarked
"
)
;
}
if
(
this
.
hasBehavior
(
"
tag
"
)
)
{
conditions
.
push
(
"
tags
NOTNULL
"
)
;
}
return
conditions
.
length
?
defaultQuery
(
"
AND
"
+
conditions
.
join
(
"
AND
"
)
)
:
defaultQuery
(
)
;
}
get
_keywordSubstitutedSearchString
(
)
{
let
tokens
=
this
.
_searchTokens
;
if
(
this
.
_keywordSubstitute
)
{
tokens
=
[
this
.
_keywordSubstitute
.
.
.
this
.
_searchTokens
.
slice
(
1
)
]
;
}
return
tokens
.
join
(
"
"
)
;
}
get
_searchQuery
(
)
{
let
query
=
this
.
_suggestionPrefQuery
;
return
[
query
{
parent
:
PlacesUtils
.
tagsFolderId
query_type
:
QUERYTYPE_FILTERED
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
searchString
:
this
.
_keywordSubstitutedSearchString
userContextId
:
this
.
_userContextId
maxResults
:
Prefs
.
get
(
"
maxRichResults
"
)
}
]
;
}
get
_switchToTabQuery
(
)
{
return
[
SQL_SWITCHTAB_QUERY
{
query_type
:
QUERYTYPE_FILTERED
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
searchString
:
this
.
_keywordSubstitutedSearchString
userContextId
:
this
.
_userContextId
maxResults
:
Prefs
.
get
(
"
maxRichResults
"
)
}
]
;
}
get
_adaptiveQuery
(
)
{
return
[
SQL_ADAPTIVE_QUERY
{
parent
:
PlacesUtils
.
tagsFolderId
search_string
:
this
.
_searchString
query_type
:
QUERYTYPE_ADAPTIVE
matchBehavior
:
this
.
_matchBehavior
searchBehavior
:
this
.
_behavior
userContextId
:
this
.
_userContextId
maxResults
:
Prefs
.
get
(
"
maxRichResults
"
)
}
]
;
}
get
_shouldAutofill
(
)
{
if
(
!
Prefs
.
get
(
"
autoFill
"
)
)
return
false
;
if
(
this
.
_searchTokens
.
length
!
=
1
)
return
false
;
if
(
!
this
.
hasBehavior
(
"
history
"
)
&
&
!
this
.
hasBehavior
(
"
bookmark
"
)
)
return
false
;
if
(
this
.
hasBehavior
(
"
title
"
)
|
|
this
.
hasBehavior
(
"
tag
"
)
)
return
false
;
if
(
REGEXP_SPACES
.
test
(
this
.
_originalSearchString
)
)
return
false
;
if
(
this
.
_searchString
.
length
=
=
0
)
return
false
;
if
(
this
.
_prohibitAutoFill
)
return
false
;
return
true
;
}
get
_originQuery
(
)
{
let
searchStr
=
this
.
_searchString
.
endsWith
(
"
/
"
)
?
this
.
_searchString
.
slice
(
0
-
1
)
:
this
.
_searchString
;
let
opts
=
{
query_type
:
QUERYTYPE_AUTOFILL_ORIGIN
searchString
:
searchStr
.
toLowerCase
(
)
}
;
let
bookmarked
=
this
.
hasBehavior
(
"
bookmark
"
)
&
&
!
this
.
hasBehavior
(
"
history
"
)
;
if
(
this
.
_strippedPrefix
)
{
opts
.
prefix
=
this
.
_strippedPrefix
;
if
(
bookmarked
)
{
return
[
SQL_ORIGIN_PREFIX_BOOKMARKED_QUERY
opts
]
;
}
return
[
SQL_ORIGIN_PREFIX_QUERY
opts
]
;
}
if
(
bookmarked
)
{
return
[
SQL_ORIGIN_BOOKMARKED_QUERY
opts
]
;
}
return
[
SQL_ORIGIN_QUERY
opts
]
;
}
get
_urlQuery
(
)
{
if
(
!
this
.
_urlQueryHostRegexp
)
{
this
.
_urlQueryHostRegexp
=
/
^
[
^
/
:
?
]
+
/
;
}
let
hostMatch
=
this
.
_urlQueryHostRegexp
.
exec
(
this
.
_searchString
)
;
if
(
!
hostMatch
)
{
return
[
null
null
]
;
}
let
host
=
hostMatch
[
0
]
.
toLowerCase
(
)
;
let
revHost
=
host
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
+
"
.
"
;
let
strippedURL
=
this
.
_trimmedOriginalSearchString
;
if
(
this
.
_strippedPrefix
)
{
strippedURL
=
strippedURL
.
substr
(
this
.
_strippedPrefix
.
length
)
;
}
strippedURL
=
host
+
strippedURL
.
substr
(
host
.
length
)
;
let
opts
=
{
query_type
:
QUERYTYPE_AUTOFILL_URL
revHost
strippedURL
}
;
let
bookmarked
=
this
.
hasBehavior
(
"
bookmark
"
)
&
&
!
this
.
hasBehavior
(
"
history
"
)
;
if
(
this
.
_strippedPrefix
)
{
opts
.
prefix
=
this
.
_strippedPrefix
;
if
(
bookmarked
)
{
return
[
SQL_URL_PREFIX_BOOKMARKED_QUERY
opts
]
;
}
return
[
SQL_URL_PREFIX_QUERY
opts
]
;
}
if
(
bookmarked
)
{
return
[
SQL_URL_BOOKMARKED_QUERY
opts
]
;
}
return
[
SQL_URL_QUERY
opts
]
;
}
_notifyTimer
:
null
_notifyDelaysCount
:
0
notifyResult
(
searchOngoing
skipDelay
=
false
)
{
let
notify
=
(
)
=
>
{
if
(
!
this
.
pending
)
return
;
this
.
_notifyDelaysCount
=
0
;
let
resultCode
=
this
.
_currentMatchCount
?
"
RESULT_SUCCESS
"
:
"
RESULT_NOMATCH
"
;
if
(
searchOngoing
)
{
resultCode
+
=
"
_ONGOING
"
;
}
let
result
=
this
.
_result
;
result
.
setSearchResult
(
Ci
.
nsIAutoCompleteResult
[
resultCode
]
)
;
this
.
_listener
.
onSearchResult
(
this
.
_autocompleteSearch
result
)
;
if
(
!
searchOngoing
)
{
this
.
_listener
=
null
;
this
.
_autocompleteSearch
=
null
;
this
.
stop
(
)
;
}
}
;
if
(
this
.
_notifyTimer
)
{
this
.
_notifyTimer
.
cancel
(
)
;
}
if
(
skipDelay
|
|
this
.
_notifyDelaysCount
>
3
)
{
notify
(
)
;
}
else
{
this
.
_notifyDelaysCount
+
+
;
this
.
_notifyTimer
=
setTimeout
(
notify
NOTIFYRESULT_DELAY_MS
)
;
}
}
}
;
function
UnifiedComplete
(
)
{
Prefs
;
if
(
Prefs
.
get
(
"
usepreloadedtopurls
.
enabled
"
)
)
{
ProfileAgeCreatedPromise
;
fetch
(
"
chrome
:
/
/
global
/
content
/
unifiedcomplete
-
top
-
urls
.
json
"
)
.
then
(
response
=
>
response
.
json
(
)
)
.
then
(
sites
=
>
PreloadedSiteStorage
.
populate
(
sites
)
)
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
}
}
UnifiedComplete
.
prototype
=
{
_promiseDatabase
:
null
getDatabaseHandle
(
)
{
if
(
Prefs
.
get
(
"
autocomplete
.
enabled
"
)
&
&
!
this
.
_promiseDatabase
)
{
this
.
_promiseDatabase
=
(
async
(
)
=
>
{
let
conn
=
await
Sqlite
.
cloneStorageConnection
(
{
connection
:
PlacesUtils
.
history
.
DBConnection
readOnly
:
true
}
)
;
try
{
Sqlite
.
shutdown
.
addBlocker
(
"
Places
UnifiedComplete
.
js
clone
closing
"
async
(
)
=
>
{
this
.
_currentSearch
=
null
;
SwitchToTabStorage
.
shutdown
(
)
;
await
conn
.
close
(
)
;
}
)
;
}
catch
(
ex
)
{
await
conn
.
close
(
)
;
throw
ex
;
}
await
conn
.
execute
(
"
PRAGMA
cache_size
=
-
6144
"
)
;
await
SwitchToTabStorage
.
initDatabase
(
conn
)
;
return
conn
;
}
)
(
)
.
catch
(
ex
=
>
{
dump
(
"
Couldn
'
t
get
database
handle
:
"
+
ex
+
"
\
n
"
)
;
Cu
.
reportError
(
ex
)
;
}
)
;
}
return
this
.
_promiseDatabase
;
}
registerOpenPage
(
uri
userContextId
)
{
SwitchToTabStorage
.
add
(
uri
userContextId
)
.
catch
(
Cu
.
reportError
)
;
}
unregisterOpenPage
(
uri
userContextId
)
{
SwitchToTabStorage
.
delete
(
uri
userContextId
)
.
catch
(
Cu
.
reportError
)
;
}
populatePreloadedSiteStorage
(
json
)
{
PreloadedSiteStorage
.
populate
(
json
)
;
}
startSearch
(
searchString
searchParam
acPreviousResult
listener
)
{
if
(
this
.
_currentSearch
)
{
this
.
stopSearch
(
)
;
}
let
prohibitSearchSuggestions
=
!
!
this
.
_lastLowResultsSearchSuggestion
&
&
searchString
.
length
>
this
.
_lastLowResultsSearchSuggestion
.
length
&
&
searchString
.
startsWith
(
this
.
_lastLowResultsSearchSuggestion
)
;
let
previousResult
=
null
;
let
insertMethod
=
Prefs
.
get
(
"
insertMethod
"
)
;
if
(
this
.
_currentSearch
&
&
insertMethod
!
=
INSERTMETHOD
.
APPEND
)
{
let
result
=
this
.
_currentSearch
.
_result
;
let
previousSearchString
=
result
.
searchString
;
let
stringsRelated
=
previousSearchString
.
length
>
0
&
&
searchString
.
length
>
0
&
&
(
previousSearchString
.
includes
(
searchString
)
|
|
searchString
.
includes
(
previousSearchString
)
)
;
if
(
insertMethod
=
=
INSERTMETHOD
.
MERGE
|
|
stringsRelated
)
{
previousResult
=
result
;
}
}
this
.
_currentSearch
=
new
Search
(
searchString
searchParam
listener
this
prohibitSearchSuggestions
previousResult
)
;
if
(
!
Prefs
.
get
(
"
autocomplete
.
enabled
"
)
)
{
this
.
finishSearch
(
true
)
;
return
;
}
let
search
=
this
.
_currentSearch
;
this
.
getDatabaseHandle
(
)
.
then
(
conn
=
>
search
.
execute
(
conn
)
)
.
catch
(
ex
=
>
{
dump
(
Query
failed
:
{
ex
}
\
n
)
;
Cu
.
reportError
(
ex
)
;
}
)
.
then
(
(
)
=
>
{
if
(
search
=
=
this
.
_currentSearch
)
{
this
.
finishSearch
(
true
)
;
}
}
)
;
}
stopSearch
(
)
{
if
(
this
.
_currentSearch
)
{
this
.
_currentSearch
.
stop
(
)
;
}
this
.
finishSearch
(
)
;
}
finishSearch
(
notify
=
false
)
{
TelemetryStopwatch
.
cancel
(
TELEMETRY_1ST_RESULT
this
)
;
TelemetryStopwatch
.
cancel
(
TELEMETRY_6_FIRST_RESULTS
this
)
;
let
search
=
this
.
_currentSearch
;
if
(
!
search
)
return
;
this
.
_lastLowResultsSearchSuggestion
=
search
.
_lastLowResultsSearchSuggestion
;
if
(
!
notify
|
|
!
search
.
pending
)
return
;
search
.
cleanUpRestrictNonCurrentMatches
(
)
;
search
.
notifyResult
(
false
)
;
}
get
searchType
(
)
{
return
Ci
.
nsIAutoCompleteSearchDescriptor
.
SEARCH_TYPE_IMMEDIATE
;
}
get
clearingAutoFillSearchesAgain
(
)
{
return
true
;
}
classID
:
Components
.
ID
(
"
f964a319
-
397a
-
4d21
-
8be6
-
5cdd1ee3e3ae
"
)
_xpcom_factory
:
XPCOMUtils
.
generateSingletonFactory
(
UnifiedComplete
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteSearch
Ci
.
nsIAutoCompleteSearchDescriptor
Ci
.
mozIPlacesAutoComplete
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
UnifiedComplete
]
)
;
