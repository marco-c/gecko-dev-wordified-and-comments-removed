var
EXPORTED_SYMBOLS
=
[
"
PlacesUtils
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
Sqlite
:
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
Bookmarks
:
"
resource
:
/
/
gre
/
modules
/
Bookmarks
.
jsm
"
History
:
"
resource
:
/
/
gre
/
modules
/
History
.
jsm
"
PlacesSyncUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
MOZ_ACTION_REGEX
"
(
)
=
>
{
return
/
^
moz
-
action
:
(
[
^
]
+
)
(
.
*
)
/
;
}
)
;
const
NEWLINE
=
AppConstants
.
platform
=
=
"
macosx
"
?
"
\
n
"
:
"
\
r
\
n
"
;
const
TIMERS_RESOLUTION_SKEW_MS
=
16
;
function
QI_node
(
aNode
aIID
)
{
try
{
return
aNode
.
QueryInterface
(
aIID
)
;
}
catch
(
ex
)
{
}
return
null
;
}
function
asContainer
(
aNode
)
{
return
QI_node
(
aNode
Ci
.
nsINavHistoryContainerResultNode
)
;
}
function
asQuery
(
aNode
)
{
return
QI_node
(
aNode
Ci
.
nsINavHistoryQueryResultNode
)
;
}
function
notify
(
observers
notification
args
)
{
for
(
let
observer
of
observers
)
{
try
{
observer
[
notification
]
(
.
.
.
args
)
;
}
catch
(
ex
)
{
}
}
}
async
function
notifyKeywordChange
(
url
keyword
source
)
{
let
bookmarks
=
[
]
;
await
PlacesUtils
.
bookmarks
.
fetch
(
{
url
}
b
=
>
bookmarks
.
push
(
b
)
)
;
for
(
let
bookmark
of
bookmarks
)
{
let
ids
=
await
PlacesUtils
.
promiseManyItemIds
(
[
bookmark
.
guid
bookmark
.
parentGuid
]
)
;
bookmark
.
id
=
ids
.
get
(
bookmark
.
guid
)
;
bookmark
.
parentId
=
ids
.
get
(
bookmark
.
parentGuid
)
;
}
let
observers
=
PlacesUtils
.
bookmarks
.
getObservers
(
)
;
for
(
let
bookmark
of
bookmarks
)
{
notify
(
observers
"
onItemChanged
"
[
bookmark
.
id
"
keyword
"
false
keyword
bookmark
.
lastModified
*
1000
bookmark
.
type
bookmark
.
parentId
bookmark
.
guid
bookmark
.
parentGuid
"
"
source
]
)
;
}
}
function
getAnnotationsForItem
(
aItemId
)
{
var
annos
=
[
]
;
var
annoNames
=
PlacesUtils
.
annotations
.
getItemAnnotationNames
(
aItemId
)
;
for
(
let
name
of
annoNames
)
{
let
value
=
{
}
flags
=
{
}
exp
=
{
}
storageType
=
{
}
;
PlacesUtils
.
annotations
.
getItemAnnotationInfo
(
aItemId
name
value
flags
exp
storageType
)
;
annos
.
push
(
{
name
flags
:
flags
.
value
expires
:
exp
.
value
value
:
value
.
value
}
)
;
}
return
annos
;
}
function
serializeNode
(
aNode
aIsLivemark
)
{
let
data
=
{
}
;
data
.
title
=
aNode
.
title
;
data
.
id
=
aNode
.
itemId
;
data
.
itemGuid
=
aNode
.
bookmarkGuid
;
data
.
livemark
=
aIsLivemark
;
data
.
instanceId
=
PlacesUtils
.
instanceId
;
let
guid
=
aNode
.
bookmarkGuid
;
if
(
guid
&
&
!
PlacesUtils
.
bookmarks
.
isVirtualRootItem
(
guid
)
&
&
!
PlacesUtils
.
isVirtualLeftPaneItem
(
guid
)
)
{
if
(
aNode
.
parent
)
{
data
.
parent
=
aNode
.
parent
.
itemId
;
data
.
parentGuid
=
aNode
.
parent
.
bookmarkGuid
;
}
data
.
dateAdded
=
aNode
.
dateAdded
;
data
.
lastModified
=
aNode
.
lastModified
;
let
annos
=
getAnnotationsForItem
(
data
.
id
)
;
if
(
annos
.
length
>
0
)
data
.
annos
=
annos
;
}
if
(
PlacesUtils
.
nodeIsURI
(
aNode
)
)
{
new
URL
(
aNode
.
uri
)
;
data
.
type
=
PlacesUtils
.
TYPE_X_MOZ_PLACE
;
data
.
uri
=
aNode
.
uri
;
if
(
aNode
.
tags
)
data
.
tags
=
aNode
.
tags
;
}
else
if
(
PlacesUtils
.
nodeIsFolder
(
aNode
)
)
{
if
(
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
)
{
data
.
type
=
PlacesUtils
.
TYPE_X_MOZ_PLACE
;
data
.
uri
=
aNode
.
uri
;
data
.
concreteId
=
PlacesUtils
.
getConcreteItemId
(
aNode
)
;
data
.
concreteGuid
=
PlacesUtils
.
getConcreteItemGuid
(
aNode
)
;
}
else
{
data
.
type
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
;
}
}
else
if
(
PlacesUtils
.
nodeIsQuery
(
aNode
)
)
{
data
.
type
=
PlacesUtils
.
TYPE_X_MOZ_PLACE
;
data
.
uri
=
aNode
.
uri
;
}
else
if
(
PlacesUtils
.
nodeIsSeparator
(
aNode
)
)
{
data
.
type
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
;
}
return
JSON
.
stringify
(
data
)
;
}
const
DB_URL_LENGTH_MAX
=
65536
;
const
DB_TITLE_LENGTH_MAX
=
4096
;
const
DB_DESCRIPTION_LENGTH_MAX
=
256
;
function
simpleValidateFunc
(
boolValidateFn
)
{
return
(
v
input
)
=
>
{
if
(
!
boolValidateFn
(
v
input
)
)
throw
new
Error
(
"
Invalid
value
"
)
;
return
v
;
}
;
}
const
BOOKMARK_VALIDATORS
=
Object
.
freeze
(
{
guid
:
simpleValidateFunc
(
v
=
>
PlacesUtils
.
isValidGuid
(
v
)
)
parentGuid
:
simpleValidateFunc
(
v
=
>
PlacesUtils
.
isValidGuid
(
v
)
)
guidPrefix
:
simpleValidateFunc
(
v
=
>
PlacesUtils
.
isValidGuidPrefix
(
v
)
)
index
:
simpleValidateFunc
(
v
=
>
Number
.
isInteger
(
v
)
&
&
v
>
=
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
)
dateAdded
:
simpleValidateFunc
(
v
=
>
v
.
constructor
.
name
=
=
"
Date
"
)
lastModified
:
simpleValidateFunc
(
v
=
>
v
.
constructor
.
name
=
=
"
Date
"
)
type
:
simpleValidateFunc
(
v
=
>
Number
.
isInteger
(
v
)
&
&
[
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
]
.
includes
(
v
)
)
title
:
v
=
>
{
if
(
v
=
=
=
null
)
{
return
"
"
;
}
if
(
typeof
(
v
)
=
=
"
string
"
)
{
return
v
.
slice
(
0
DB_TITLE_LENGTH_MAX
)
;
}
throw
new
Error
(
"
Invalid
title
"
)
;
}
url
:
v
=
>
{
simpleValidateFunc
(
val
=
>
(
typeof
(
val
)
=
=
"
string
"
&
&
val
.
length
<
=
DB_URL_LENGTH_MAX
)
|
|
(
val
instanceof
Ci
.
nsIURI
&
&
val
.
spec
.
length
<
=
DB_URL_LENGTH_MAX
)
|
|
(
val
instanceof
URL
&
&
val
.
href
.
length
<
=
DB_URL_LENGTH_MAX
)
)
.
call
(
this
v
)
;
if
(
typeof
(
v
)
=
=
=
"
string
"
)
return
new
URL
(
v
)
;
if
(
v
instanceof
Ci
.
nsIURI
)
return
new
URL
(
v
.
spec
)
;
return
v
;
}
source
:
simpleValidateFunc
(
v
=
>
Number
.
isInteger
(
v
)
&
&
Object
.
values
(
PlacesUtils
.
bookmarks
.
SOURCES
)
.
includes
(
v
)
)
annos
:
simpleValidateFunc
(
v
=
>
Array
.
isArray
(
v
)
&
&
v
.
length
)
keyword
:
simpleValidateFunc
(
v
=
>
(
typeof
(
v
)
=
=
"
string
"
)
&
&
v
.
length
)
charset
:
simpleValidateFunc
(
v
=
>
(
typeof
(
v
)
=
=
"
string
"
)
&
&
v
.
length
)
postData
:
simpleValidateFunc
(
v
=
>
(
typeof
(
v
)
=
=
"
string
"
)
&
&
v
.
length
)
tags
:
simpleValidateFunc
(
v
=
>
Array
.
isArray
(
v
)
&
&
v
.
length
&
&
v
.
every
(
item
=
>
item
&
&
typeof
item
=
=
"
string
"
)
)
}
)
;
const
SYNC_BOOKMARK_VALIDATORS
=
Object
.
freeze
(
{
recordId
:
simpleValidateFunc
(
v
=
>
typeof
v
=
=
"
string
"
&
&
(
(
PlacesSyncUtils
.
bookmarks
.
ROOTS
.
includes
(
v
)
|
|
PlacesUtils
.
isValidGuid
(
v
)
)
)
)
parentRecordId
:
v
=
>
SYNC_BOOKMARK_VALIDATORS
.
recordId
(
v
)
kind
:
simpleValidateFunc
(
v
=
>
typeof
v
=
=
"
string
"
&
&
Object
.
values
(
PlacesSyncUtils
.
bookmarks
.
KINDS
)
.
includes
(
v
)
)
query
:
simpleValidateFunc
(
v
=
>
v
=
=
=
null
|
|
(
typeof
v
=
=
"
string
"
&
&
v
)
)
folder
:
simpleValidateFunc
(
v
=
>
typeof
v
=
=
"
string
"
&
&
v
&
&
v
.
length
<
=
PlacesUtils
.
bookmarks
.
MAX_TAG_LENGTH
)
tags
:
v
=
>
{
if
(
v
=
=
=
null
)
{
return
[
]
;
}
if
(
!
Array
.
isArray
(
v
)
)
{
throw
new
Error
(
"
Invalid
tag
array
"
)
;
}
for
(
let
tag
of
v
)
{
if
(
typeof
tag
!
=
"
string
"
|
|
!
tag
|
|
tag
.
length
>
PlacesUtils
.
bookmarks
.
MAX_TAG_LENGTH
)
{
throw
new
Error
(
Invalid
tag
:
{
tag
}
)
;
}
}
return
v
;
}
keyword
:
simpleValidateFunc
(
v
=
>
v
=
=
=
null
|
|
typeof
v
=
=
"
string
"
)
dateAdded
:
simpleValidateFunc
(
v
=
>
typeof
v
=
=
=
"
number
"
&
&
v
>
PlacesSyncUtils
.
bookmarks
.
EARLIEST_BOOKMARK_TIMESTAMP
)
feed
:
v
=
>
v
=
=
=
null
?
v
:
BOOKMARK_VALIDATORS
.
url
(
v
)
site
:
v
=
>
v
=
=
=
null
?
v
:
BOOKMARK_VALIDATORS
.
url
(
v
)
title
:
BOOKMARK_VALIDATORS
.
title
url
:
BOOKMARK_VALIDATORS
.
url
}
)
;
const
SYNC_CHANGE_RECORD_VALIDATORS
=
Object
.
freeze
(
{
modified
:
simpleValidateFunc
(
v
=
>
typeof
v
=
=
"
number
"
&
&
v
>
=
0
)
counter
:
simpleValidateFunc
(
v
=
>
typeof
v
=
=
"
number
"
&
&
v
>
=
0
)
status
:
simpleValidateFunc
(
v
=
>
typeof
v
=
=
"
number
"
&
&
Object
.
values
(
PlacesUtils
.
bookmarks
.
SYNC_STATUS
)
.
includes
(
v
)
)
tombstone
:
simpleValidateFunc
(
v
=
>
v
=
=
=
true
|
|
v
=
=
=
false
)
synced
:
simpleValidateFunc
(
v
=
>
v
=
=
=
true
|
|
v
=
=
=
false
)
}
)
;
var
PlacesUtils
=
{
TYPE_X_MOZ_PLACE_CONTAINER
:
"
text
/
x
-
moz
-
place
-
container
"
TYPE_X_MOZ_PLACE_SEPARATOR
:
"
text
/
x
-
moz
-
place
-
separator
"
TYPE_X_MOZ_PLACE
:
"
text
/
x
-
moz
-
place
"
TYPE_X_MOZ_URL
:
"
text
/
x
-
moz
-
url
"
TYPE_HTML
:
"
text
/
html
"
TYPE_UNICODE
:
"
text
/
unicode
"
TYPE_X_MOZ_PLACE_ACTION
:
"
text
/
x
-
moz
-
place
-
action
"
LMANNO_FEEDURI
:
"
livemark
/
feedURI
"
LMANNO_SITEURI
:
"
livemark
/
siteURI
"
CHARSET_ANNO
:
"
URIProperties
/
characterSet
"
MOBILE_ROOT_ANNO
:
"
mobile
/
bookmarksRoot
"
TOPIC_SHUTDOWN
:
"
places
-
shutdown
"
TOPIC_INIT_COMPLETE
:
"
places
-
init
-
complete
"
TOPIC_DATABASE_LOCKED
:
"
places
-
database
-
locked
"
TOPIC_EXPIRATION_FINISHED
:
"
places
-
expiration
-
finished
"
TOPIC_FEEDBACK_UPDATED
:
"
places
-
autocomplete
-
feedback
-
updated
"
TOPIC_FAVICONS_EXPIRED
:
"
places
-
favicons
-
expired
"
TOPIC_VACUUM_STARTING
:
"
places
-
vacuum
-
starting
"
TOPIC_BOOKMARKS_RESTORE_BEGIN
:
"
bookmarks
-
restore
-
begin
"
TOPIC_BOOKMARKS_RESTORE_SUCCESS
:
"
bookmarks
-
restore
-
success
"
TOPIC_BOOKMARKS_RESTORE_FAILED
:
"
bookmarks
-
restore
-
failed
"
ACTION_SCHEME
:
"
moz
-
action
:
"
observers
:
PlacesObservers
virtualAllBookmarksGuid
:
"
allbms_____v
"
virtualHistoryGuid
:
"
history____v
"
virtualDownloadsGuid
:
"
downloads__v
"
virtualTagsGuid
:
"
tags_______v
"
isVirtualLeftPaneItem
(
guid
)
{
return
guid
=
=
PlacesUtils
.
virtualAllBookmarksGuid
|
|
guid
=
=
PlacesUtils
.
virtualHistoryGuid
|
|
guid
=
=
PlacesUtils
.
virtualDownloadsGuid
|
|
guid
=
=
PlacesUtils
.
virtualTagsGuid
;
}
asContainer
:
aNode
=
>
asContainer
(
aNode
)
asQuery
:
aNode
=
>
asQuery
(
aNode
)
endl
:
NEWLINE
isValidGuid
(
guid
)
{
return
typeof
guid
=
=
"
string
"
&
&
guid
&
&
(
/
^
[
a
-
zA
-
Z0
-
9
\
-
_
]
{
12
}
/
.
test
(
guid
)
)
;
}
isValidGuidPrefix
(
guidPrefix
)
{
return
typeof
guidPrefix
=
=
"
string
"
&
&
guidPrefix
&
&
(
/
^
[
a
-
zA
-
Z0
-
9
\
-
_
]
{
1
11
}
/
.
test
(
guidPrefix
)
)
;
}
toURI
(
url
)
{
url
=
(
url
instanceof
URL
)
?
url
.
href
:
url
;
return
NetUtil
.
newURI
(
url
)
;
}
toPRTime
(
date
)
{
if
(
typeof
date
!
=
"
number
"
&
&
date
.
constructor
.
name
!
=
"
Date
"
)
throw
new
Error
(
"
Invalid
value
passed
to
toPRTime
"
)
;
return
date
*
1000
;
}
toDate
(
time
)
{
if
(
typeof
time
!
=
"
number
"
)
throw
new
Error
(
"
Invalid
value
passed
to
toDate
"
)
;
return
new
Date
(
parseInt
(
time
/
1000
)
)
;
}
toISupportsString
:
function
PU_toISupportsString
(
aString
)
{
let
s
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
s
.
data
=
aString
;
return
s
;
}
getFormattedString
:
function
PU_getFormattedString
(
key
params
)
{
return
bundle
.
formatStringFromName
(
key
params
params
.
length
)
;
}
getString
:
function
PU_getString
(
key
)
{
return
bundle
.
GetStringFromName
(
key
)
;
}
mozActionURI
(
type
params
)
{
let
encodedParams
=
{
}
;
for
(
let
key
in
params
)
{
if
(
params
[
key
]
=
=
=
null
|
|
params
[
key
]
=
=
=
undefined
)
{
continue
;
}
encodedParams
[
key
]
=
encodeURIComponent
(
params
[
key
]
)
;
}
return
this
.
ACTION_SCHEME
+
type
+
"
"
+
JSON
.
stringify
(
encodedParams
)
;
}
parseActionUrl
(
url
)
{
if
(
url
instanceof
Ci
.
nsIURI
)
url
=
url
.
spec
;
else
if
(
url
instanceof
URL
)
url
=
url
.
href
;
if
(
!
url
.
startsWith
(
this
.
ACTION_SCHEME
)
)
return
null
;
try
{
let
[
type
params
]
=
url
.
match
(
MOZ_ACTION_REGEX
)
;
let
action
=
{
type
params
:
JSON
.
parse
(
params
)
}
;
for
(
let
key
in
action
.
params
)
{
action
.
params
[
key
]
=
decodeURIComponent
(
action
.
params
[
key
]
)
;
}
return
action
;
}
catch
(
ex
)
{
Cu
.
reportError
(
Invalid
action
url
"
{
url
}
"
)
;
return
null
;
}
}
convertMatchBucketsStringToArray
(
str
)
{
return
str
.
split
(
"
"
)
.
map
(
v
=
>
{
let
bucket
=
v
.
split
(
"
:
"
)
;
return
[
bucket
[
0
]
.
trim
(
)
.
toLowerCase
(
)
Number
(
bucket
[
1
]
)
]
;
}
)
;
}
isQueryGeneratedFolder
(
node
)
{
if
(
!
node
.
parent
)
{
return
false
;
}
return
this
.
nodeIsFolder
(
node
)
&
&
this
.
nodeIsQuery
(
node
.
parent
)
;
}
nodeIsFolder
:
function
PU_nodeIsFolder
(
aNode
)
{
return
(
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER
|
|
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
)
;
}
nodeIsBookmark
:
function
PU_nodeIsBookmark
(
aNode
)
{
return
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_URI
&
&
aNode
.
itemId
!
=
-
1
;
}
nodeIsSeparator
:
function
PU_nodeIsSeparator
(
aNode
)
{
return
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_SEPARATOR
;
}
nodeIsURI
:
function
PU_nodeIsURI
(
aNode
)
{
return
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_URI
;
}
nodeIsQuery
:
function
PU_nodeIsQuery
(
aNode
)
{
return
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_QUERY
;
}
nodeAncestors
:
function
*
PU_nodeAncestors
(
aNode
)
{
let
node
=
aNode
.
parent
;
while
(
node
)
{
yield
node
;
node
=
node
.
parent
;
}
}
validateItemProperties
(
name
validators
props
behavior
=
{
}
)
{
if
(
!
props
)
throw
new
Error
(
{
name
}
:
Input
should
be
a
valid
object
)
;
let
input
=
Object
.
assign
(
{
}
props
)
;
let
normalizedInput
=
{
}
;
let
required
=
new
Set
(
)
;
for
(
let
prop
in
behavior
)
{
if
(
behavior
[
prop
]
.
hasOwnProperty
(
"
required
"
)
&
&
behavior
[
prop
]
.
required
)
{
required
.
add
(
prop
)
;
}
if
(
behavior
[
prop
]
.
hasOwnProperty
(
"
requiredIf
"
)
&
&
behavior
[
prop
]
.
requiredIf
(
input
)
)
{
required
.
add
(
prop
)
;
}
if
(
behavior
[
prop
]
.
hasOwnProperty
(
"
validIf
"
)
&
&
input
[
prop
]
!
=
=
undefined
&
&
!
behavior
[
prop
]
.
validIf
(
input
)
)
{
if
(
behavior
[
prop
]
.
hasOwnProperty
(
"
fixup
"
)
)
{
behavior
[
prop
]
.
fixup
(
input
)
;
}
else
{
throw
new
Error
(
{
name
}
:
Invalid
value
for
property
'
{
prop
}
'
:
{
JSON
.
stringify
(
input
[
prop
]
)
}
)
;
}
}
if
(
behavior
[
prop
]
.
hasOwnProperty
(
"
defaultValue
"
)
&
&
input
[
prop
]
=
=
=
undefined
)
{
input
[
prop
]
=
behavior
[
prop
]
.
defaultValue
;
}
if
(
behavior
[
prop
]
.
hasOwnProperty
(
"
replaceWith
"
)
)
{
input
[
prop
]
=
behavior
[
prop
]
.
replaceWith
;
}
}
for
(
let
prop
in
input
)
{
if
(
required
.
has
(
prop
)
)
{
required
.
delete
(
prop
)
;
}
else
if
(
input
[
prop
]
=
=
=
undefined
)
{
continue
;
}
if
(
validators
.
hasOwnProperty
(
prop
)
)
{
try
{
normalizedInput
[
prop
]
=
validators
[
prop
]
(
input
[
prop
]
input
)
;
}
catch
(
ex
)
{
if
(
behavior
.
hasOwnProperty
(
prop
)
&
&
behavior
[
prop
]
.
hasOwnProperty
(
"
fixup
"
)
)
{
behavior
[
prop
]
.
fixup
(
input
)
;
normalizedInput
[
prop
]
=
input
[
prop
]
;
}
else
{
throw
new
Error
(
{
name
}
:
Invalid
value
for
property
'
{
prop
}
'
:
{
JSON
.
stringify
(
input
[
prop
]
)
}
)
;
}
}
}
}
if
(
required
.
size
>
0
)
throw
new
Error
(
{
name
}
:
The
following
properties
were
expected
:
{
[
.
.
.
required
]
.
join
(
"
"
)
}
)
;
return
normalizedInput
;
}
BOOKMARK_VALIDATORS
SYNC_BOOKMARK_VALIDATORS
SYNC_CHANGE_RECORD_VALIDATORS
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
_shutdownFunctions
:
[
]
registerShutdownFunction
:
function
PU_registerShutdownFunction
(
aFunc
)
{
if
(
this
.
_shutdownFunctions
.
length
=
=
0
)
{
Services
.
obs
.
addObserver
(
this
this
.
TOPIC_SHUTDOWN
)
;
}
this
.
_shutdownFunctions
.
push
(
aFunc
)
;
}
observe
:
function
PU_observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
this
.
TOPIC_SHUTDOWN
:
Services
.
obs
.
removeObserver
(
this
this
.
TOPIC_SHUTDOWN
)
;
while
(
this
.
_shutdownFunctions
.
length
>
0
)
{
this
.
_shutdownFunctions
.
shift
(
)
.
apply
(
this
)
;
}
break
;
}
}
nodeIsHost
:
function
PU_nodeIsHost
(
aNode
)
{
return
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_QUERY
&
&
aNode
.
parent
&
&
asQuery
(
aNode
.
parent
)
.
queryOptions
.
resultType
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_SITE_QUERY
;
}
nodeIsDay
:
function
PU_nodeIsDay
(
aNode
)
{
var
resultType
;
return
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_QUERY
&
&
aNode
.
parent
&
&
(
(
resultType
=
asQuery
(
aNode
.
parent
)
.
queryOptions
.
resultType
)
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_DATE_QUERY
|
|
resultType
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_DATE_SITE_QUERY
)
;
}
nodeIsTagQuery
:
function
PU_nodeIsTagQuery
(
aNode
)
{
if
(
aNode
.
type
!
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_QUERY
)
return
false
;
let
parent
=
aNode
.
parent
;
if
(
parent
&
&
PlacesUtils
.
asQuery
(
parent
)
.
queryOptions
.
resultType
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAGS_ROOT
)
return
true
;
if
(
!
parent
&
&
aNode
=
=
aNode
.
parentResult
.
root
&
&
PlacesUtils
.
asQuery
(
aNode
)
.
query
.
tags
.
length
=
=
1
)
return
true
;
return
false
;
}
containerTypes
:
[
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_QUERY
]
nodeIsContainer
:
function
PU_nodeIsContainer
(
aNode
)
{
return
this
.
containerTypes
.
includes
(
aNode
.
type
)
;
}
nodeIsHistoryContainer
:
function
PU_nodeIsHistoryContainer
(
aNode
)
{
var
resultType
;
return
this
.
nodeIsQuery
(
aNode
)
&
&
(
(
resultType
=
asQuery
(
aNode
)
.
queryOptions
.
resultType
)
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_DATE_SITE_QUERY
|
|
resultType
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_DATE_QUERY
|
|
resultType
=
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_SITE_QUERY
|
|
this
.
nodeIsDay
(
aNode
)
|
|
this
.
nodeIsHost
(
aNode
)
)
;
}
getConcreteItemId
:
function
PU_getConcreteItemId
(
aNode
)
{
return
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
?
asQuery
(
aNode
)
.
folderItemId
:
aNode
.
itemId
;
}
getConcreteItemGuid
(
aNode
)
{
if
(
aNode
.
type
=
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
)
return
asQuery
(
aNode
)
.
targetFolderGuid
;
return
aNode
.
bookmarkGuid
;
}
getReversedHost
(
url
)
{
return
url
.
host
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
+
"
.
"
;
}
wrapNode
(
aNode
aType
aFeedURI
)
{
function
gatherDataFromNode
(
node
gatherDataFunc
)
{
if
(
PlacesUtils
.
nodeIsFolder
(
node
)
&
&
node
.
type
!
=
Ci
.
nsINavHistoryResultNode
.
RESULT_TYPE_FOLDER_SHORTCUT
&
&
asQuery
(
node
)
.
queryOptions
.
excludeItems
)
{
let
folderRoot
=
PlacesUtils
.
getFolderContents
(
node
.
bookmarkGuid
false
true
)
.
root
;
try
{
return
gatherDataFunc
(
folderRoot
)
;
}
finally
{
folderRoot
.
containerOpen
=
false
;
}
}
return
gatherDataFunc
(
node
)
;
}
function
gatherDataHtml
(
node
)
{
let
htmlEscape
=
s
=
>
s
.
replace
(
/
&
/
g
"
&
amp
;
"
)
.
replace
(
/
>
/
g
"
&
gt
;
"
)
.
replace
(
/
<
/
g
"
&
lt
;
"
)
.
replace
(
/
"
/
g
"
&
quot
;
"
)
.
replace
(
/
'
/
g
"
&
apos
;
"
)
;
let
escapedTitle
=
node
.
title
?
htmlEscape
(
node
.
title
)
:
"
"
;
if
(
aFeedURI
)
{
return
<
A
HREF
=
"
{
aFeedURI
}
"
>
{
escapedTitle
}
<
/
A
>
{
NEWLINE
}
;
}
if
(
PlacesUtils
.
nodeIsContainer
(
node
)
)
{
asContainer
(
node
)
;
let
wasOpen
=
node
.
containerOpen
;
if
(
!
wasOpen
)
node
.
containerOpen
=
true
;
let
childString
=
"
<
DL
>
<
DT
>
"
+
escapedTitle
+
"
<
/
DT
>
"
+
NEWLINE
;
let
cc
=
node
.
childCount
;
for
(
let
i
=
0
;
i
<
cc
;
+
+
i
)
{
childString
+
=
"
<
DD
>
"
+
NEWLINE
+
gatherDataHtml
(
node
.
getChild
(
i
)
)
+
"
<
/
DD
>
"
+
NEWLINE
;
}
node
.
containerOpen
=
wasOpen
;
return
childString
+
"
<
/
DL
>
"
+
NEWLINE
;
}
if
(
PlacesUtils
.
nodeIsURI
(
node
)
)
return
<
A
HREF
=
"
{
node
.
uri
}
"
>
{
escapedTitle
}
<
/
A
>
{
NEWLINE
}
;
if
(
PlacesUtils
.
nodeIsSeparator
(
node
)
)
return
"
<
HR
>
"
+
NEWLINE
;
return
"
"
;
}
function
gatherDataText
(
node
)
{
if
(
aFeedURI
)
{
return
aFeedURI
;
}
if
(
PlacesUtils
.
nodeIsContainer
(
node
)
)
{
asContainer
(
node
)
;
let
wasOpen
=
node
.
containerOpen
;
if
(
!
wasOpen
)
node
.
containerOpen
=
true
;
let
childString
=
node
.
title
+
NEWLINE
;
let
cc
=
node
.
childCount
;
for
(
let
i
=
0
;
i
<
cc
;
+
+
i
)
{
let
child
=
node
.
getChild
(
i
)
;
let
suffix
=
i
<
(
cc
-
1
)
?
NEWLINE
:
"
"
;
childString
+
=
gatherDataText
(
child
)
+
suffix
;
}
node
.
containerOpen
=
wasOpen
;
return
childString
;
}
if
(
PlacesUtils
.
nodeIsURI
(
node
)
)
return
node
.
uri
;
if
(
PlacesUtils
.
nodeIsSeparator
(
node
)
)
return
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
;
return
"
"
;
}
switch
(
aType
)
{
case
this
.
TYPE_X_MOZ_PLACE
:
case
this
.
TYPE_X_MOZ_PLACE_SEPARATOR
:
case
this
.
TYPE_X_MOZ_PLACE_CONTAINER
:
{
return
serializeNode
(
aNode
aFeedURI
)
;
}
case
this
.
TYPE_X_MOZ_URL
:
{
if
(
aFeedURI
|
|
PlacesUtils
.
nodeIsURI
(
aNode
)
)
return
(
aFeedURI
|
|
aNode
.
uri
)
+
NEWLINE
+
aNode
.
title
;
if
(
PlacesUtils
.
nodeIsContainer
(
aNode
)
)
{
return
PlacesUtils
.
getURLsForContainerNode
(
aNode
)
.
map
(
item
=
>
item
.
uri
+
"
\
n
"
+
item
.
title
)
.
join
(
"
\
n
"
)
;
}
return
"
"
;
}
case
this
.
TYPE_HTML
:
{
return
gatherDataFromNode
(
aNode
gatherDataHtml
)
;
}
}
return
gatherDataFromNode
(
aNode
gatherDataText
)
;
}
unwrapNodes
:
function
PU_unwrapNodes
(
blob
type
)
{
var
nodes
=
[
]
;
switch
(
type
)
{
case
this
.
TYPE_X_MOZ_PLACE
:
case
this
.
TYPE_X_MOZ_PLACE_SEPARATOR
:
case
this
.
TYPE_X_MOZ_PLACE_CONTAINER
:
nodes
=
JSON
.
parse
(
"
[
"
+
blob
+
"
]
"
)
;
break
;
case
this
.
TYPE_X_MOZ_URL
:
{
let
parts
=
blob
.
split
(
"
\
n
"
)
;
if
(
parts
.
length
!
=
1
&
&
parts
.
length
%
2
)
break
;
for
(
let
i
=
0
;
i
<
parts
.
length
;
i
=
i
+
2
)
{
let
uriString
=
parts
[
i
]
;
let
titleString
=
"
"
;
if
(
parts
.
length
>
i
+
1
)
titleString
=
parts
[
i
+
1
]
;
else
{
try
{
titleString
=
Services
.
io
.
newURI
(
uriString
)
.
QueryInterface
(
Ci
.
nsIURL
)
.
fileName
;
}
catch
(
ex
)
{
}
}
if
(
Services
.
io
.
newURI
(
uriString
)
)
{
nodes
.
push
(
{
uri
:
uriString
title
:
titleString
?
titleString
:
uriString
type
:
this
.
TYPE_X_MOZ_URL
}
)
;
}
}
break
;
}
case
this
.
TYPE_UNICODE
:
{
let
parts
=
blob
.
split
(
"
\
n
"
)
;
for
(
let
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
let
uriString
=
parts
[
i
]
;
if
(
uriString
.
substr
(
0
1
)
=
=
"
\
x23
"
)
continue
;
if
(
uriString
!
=
"
"
&
&
Services
.
io
.
newURI
(
uriString
)
)
nodes
.
push
(
{
uri
:
uriString
title
:
uriString
type
:
this
.
TYPE_X_MOZ_URL
}
)
;
}
break
;
}
default
:
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
return
nodes
;
}
validatePageInfo
(
pageInfo
validateVisits
=
true
)
{
let
info
=
{
visits
:
[
]
}
;
if
(
typeof
pageInfo
!
=
"
object
"
|
|
!
pageInfo
)
{
throw
new
TypeError
(
"
pageInfo
must
be
an
object
"
)
;
}
if
(
!
pageInfo
.
url
)
{
throw
new
TypeError
(
"
PageInfo
object
must
have
a
url
property
"
)
;
}
info
.
url
=
this
.
normalizeToURLOrGUID
(
pageInfo
.
url
)
;
if
(
typeof
pageInfo
.
guid
=
=
=
"
string
"
&
&
this
.
isValidGuid
(
pageInfo
.
guid
)
)
{
info
.
guid
=
pageInfo
.
guid
;
}
else
if
(
pageInfo
.
guid
)
{
throw
new
TypeError
(
guid
property
of
PageInfo
object
:
{
pageInfo
.
guid
}
is
invalid
)
;
}
if
(
typeof
pageInfo
.
title
=
=
=
"
string
"
)
{
info
.
title
=
pageInfo
.
title
;
}
else
if
(
pageInfo
.
title
!
=
null
&
&
pageInfo
.
title
!
=
undefined
)
{
throw
new
TypeError
(
title
property
of
PageInfo
object
:
{
pageInfo
.
title
}
must
be
a
string
if
provided
)
;
}
if
(
typeof
pageInfo
.
description
=
=
=
"
string
"
|
|
pageInfo
.
description
=
=
=
null
)
{
info
.
description
=
pageInfo
.
description
?
pageInfo
.
description
.
slice
(
0
DB_DESCRIPTION_LENGTH_MAX
)
:
null
;
}
else
if
(
pageInfo
.
description
!
=
=
undefined
)
{
throw
new
TypeError
(
description
property
of
pageInfo
object
:
{
pageInfo
.
description
}
must
be
either
a
string
or
null
if
provided
)
;
}
if
(
pageInfo
.
previewImageURL
|
|
pageInfo
.
previewImageURL
=
=
=
null
)
{
let
previewImageURL
=
pageInfo
.
previewImageURL
;
if
(
previewImageURL
=
=
=
null
)
{
info
.
previewImageURL
=
null
;
}
else
if
(
typeof
(
previewImageURL
)
=
=
=
"
string
"
&
&
previewImageURL
.
length
<
=
DB_URL_LENGTH_MAX
)
{
info
.
previewImageURL
=
new
URL
(
previewImageURL
)
;
}
else
if
(
previewImageURL
instanceof
Ci
.
nsIURI
&
&
previewImageURL
.
spec
.
length
<
=
DB_URL_LENGTH_MAX
)
{
info
.
previewImageURL
=
new
URL
(
previewImageURL
.
spec
)
;
}
else
if
(
previewImageURL
instanceof
URL
&
&
previewImageURL
.
href
.
length
<
=
DB_URL_LENGTH_MAX
)
{
info
.
previewImageURL
=
previewImageURL
;
}
else
{
throw
new
TypeError
(
"
previewImageURL
property
of
pageInfo
object
:
{
previewImageURL
}
is
invalid
"
)
;
}
}
if
(
pageInfo
.
annotations
)
{
if
(
typeof
pageInfo
.
annotations
!
=
"
object
"
|
|
pageInfo
.
annotations
.
constructor
.
name
!
=
"
Map
"
)
{
throw
new
TypeError
(
"
annotations
must
be
a
Map
"
)
;
}
if
(
pageInfo
.
annotations
.
size
=
=
0
)
{
throw
new
TypeError
(
"
there
must
be
at
least
one
annotation
"
)
;
}
for
(
let
[
key
value
]
of
pageInfo
.
annotations
.
entries
(
)
)
{
if
(
typeof
key
!
=
"
string
"
)
{
throw
new
TypeError
(
"
all
annotation
keys
must
be
strings
"
)
;
}
if
(
typeof
value
!
=
"
string
"
&
&
typeof
value
!
=
"
number
"
&
&
typeof
value
!
=
"
boolean
"
&
&
value
!
=
=
null
&
&
value
!
=
=
undefined
)
{
throw
new
TypeError
(
"
all
annotation
values
must
be
Boolean
Numbers
or
Strings
"
)
;
}
}
info
.
annotations
=
pageInfo
.
annotations
;
}
if
(
!
validateVisits
)
{
return
info
;
}
if
(
!
pageInfo
.
visits
|
|
!
Array
.
isArray
(
pageInfo
.
visits
)
|
|
!
pageInfo
.
visits
.
length
)
{
throw
new
TypeError
(
"
PageInfo
object
must
have
an
array
of
visits
"
)
;
}
for
(
let
inVisit
of
pageInfo
.
visits
)
{
let
visit
=
{
date
:
new
Date
(
)
transition
:
inVisit
.
transition
|
|
History
.
TRANSITIONS
.
LINK
}
;
if
(
!
PlacesUtils
.
history
.
isValidTransition
(
visit
.
transition
)
)
{
throw
new
TypeError
(
transition
:
{
visit
.
transition
}
is
not
a
valid
transition
type
)
;
}
if
(
inVisit
.
date
)
{
PlacesUtils
.
history
.
ensureDate
(
inVisit
.
date
)
;
if
(
inVisit
.
date
>
(
Date
.
now
(
)
+
TIMERS_RESOLUTION_SKEW_MS
)
)
{
throw
new
TypeError
(
date
:
{
inVisit
.
date
}
cannot
be
a
future
date
)
;
}
visit
.
date
=
inVisit
.
date
;
}
if
(
inVisit
.
referrer
)
{
visit
.
referrer
=
this
.
normalizeToURLOrGUID
(
inVisit
.
referrer
)
;
}
info
.
visits
.
push
(
visit
)
;
}
return
info
;
}
normalizeToURLOrGUID
(
key
)
{
if
(
typeof
key
=
=
=
"
string
"
)
{
if
(
this
.
isValidGuid
(
key
)
)
{
return
key
;
}
return
new
URL
(
key
)
;
}
if
(
key
instanceof
URL
)
{
return
key
;
}
if
(
key
instanceof
Ci
.
nsIURI
)
{
return
new
URL
(
key
.
spec
)
;
}
throw
new
TypeError
(
"
Invalid
url
or
guid
:
"
+
key
)
;
}
getFolderContents
(
aFolderGuid
aExcludeItems
aExpandQueries
)
{
if
(
!
this
.
isValidGuid
(
aFolderGuid
)
)
{
throw
new
Error
(
"
aFolderGuid
should
be
a
valid
GUID
.
"
)
;
}
var
query
=
this
.
history
.
getNewQuery
(
)
;
query
.
setParents
(
[
aFolderGuid
]
1
)
;
var
options
=
this
.
history
.
getNewQueryOptions
(
)
;
options
.
excludeItems
=
aExcludeItems
;
options
.
expandQueries
=
aExpandQueries
;
var
result
=
this
.
history
.
executeQuery
(
query
options
)
;
result
.
root
.
containerOpen
=
true
;
return
result
;
}
async
promiseAnnotationsForItem
(
itemId
)
{
let
db
=
await
PlacesUtils
.
promiseDBConnection
(
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
n
.
name
a
.
content
a
.
expiration
a
.
flags
FROM
moz_items_annos
a
JOIN
moz_anno_attributes
n
ON
a
.
anno_attribute_id
=
n
.
id
WHERE
a
.
item_id
=
:
itemId
{
itemId
}
)
;
let
result
=
[
]
;
for
(
let
row
of
rows
)
{
let
anno
=
{
name
:
row
.
getResultByName
(
"
name
"
)
value
:
row
.
getResultByName
(
"
content
"
)
expires
:
row
.
getResultByName
(
"
expiration
"
)
flags
:
row
.
getResultByName
(
"
flags
"
)
}
;
result
.
push
(
anno
)
;
}
return
result
;
}
setAnnotationsForItem
:
function
PU_setAnnotationsForItem
(
aItemId
aAnnos
aSource
aDontUpdateLastModified
)
{
var
annosvc
=
this
.
annotations
;
aAnnos
.
forEach
(
function
(
anno
)
{
if
(
anno
.
value
=
=
=
undefined
|
|
anno
.
value
=
=
=
null
)
{
annosvc
.
removeItemAnnotation
(
aItemId
anno
.
name
aSource
)
;
}
else
{
let
flags
=
(
"
flags
"
in
anno
)
?
anno
.
flags
:
0
;
let
expires
=
(
"
expires
"
in
anno
)
?
anno
.
expires
:
Ci
.
nsIAnnotationService
.
EXPIRE_NEVER
;
annosvc
.
setItemAnnotation
(
aItemId
anno
.
name
anno
.
value
flags
expires
aSource
aDontUpdateLastModified
)
;
}
}
)
;
}
get
placesRootId
(
)
{
delete
this
.
placesRootId
;
return
this
.
placesRootId
=
this
.
bookmarks
.
placesRoot
;
}
get
bookmarksMenuFolderId
(
)
{
delete
this
.
bookmarksMenuFolderId
;
return
this
.
bookmarksMenuFolderId
=
this
.
bookmarks
.
bookmarksMenuFolder
;
}
get
toolbarFolderId
(
)
{
delete
this
.
toolbarFolderId
;
return
this
.
toolbarFolderId
=
this
.
bookmarks
.
toolbarFolder
;
}
get
tagsFolderId
(
)
{
delete
this
.
tagsFolderId
;
return
this
.
tagsFolderId
=
this
.
bookmarks
.
tagsFolder
;
}
get
unfiledBookmarksFolderId
(
)
{
delete
this
.
unfiledBookmarksFolderId
;
return
this
.
unfiledBookmarksFolderId
=
this
.
bookmarks
.
unfiledBookmarksFolder
;
}
get
mobileFolderId
(
)
{
delete
this
.
mobileFolderId
;
return
this
.
mobileFolderId
=
this
.
bookmarks
.
mobileFolder
;
}
isRootItem
(
guid
)
{
if
(
typeof
guid
=
=
=
"
string
"
)
{
return
guid
=
=
PlacesUtils
.
bookmarks
.
menuGuid
|
|
guid
=
=
PlacesUtils
.
bookmarks
.
toolbarGuid
|
|
guid
=
=
PlacesUtils
.
bookmarks
.
unfiledGuid
|
|
guid
=
=
PlacesUtils
.
bookmarks
.
tagsGuid
|
|
guid
=
=
PlacesUtils
.
bookmarks
.
rootGuid
|
|
guid
=
=
PlacesUtils
.
bookmarks
.
mobileGuid
;
}
return
guid
=
=
PlacesUtils
.
bookmarksMenuFolderId
|
|
guid
=
=
PlacesUtils
.
toolbarFolderId
|
|
guid
=
=
PlacesUtils
.
unfiledBookmarksFolderId
|
|
guid
=
=
PlacesUtils
.
tagsFolderId
|
|
guid
=
=
PlacesUtils
.
placesRootId
|
|
guid
=
=
PlacesUtils
.
mobileFolderId
;
}
getContainerNodeWithOptions
:
function
PU_getContainerNodeWithOptions
(
aNode
aExcludeItems
aExpandQueries
)
{
if
(
!
this
.
nodeIsContainer
(
aNode
)
)
throw
Cr
.
NS_ERROR_INVALID_ARG
;
var
excludeItems
=
asQuery
(
aNode
)
.
queryOptions
.
excludeItems
|
|
asQuery
(
aNode
.
parentResult
.
root
)
.
queryOptions
.
excludeItems
;
var
expandQueries
=
asQuery
(
aNode
)
.
queryOptions
.
expandQueries
&
&
asQuery
(
aNode
.
parentResult
.
root
)
.
queryOptions
.
expandQueries
;
if
(
excludeItems
=
=
aExcludeItems
&
&
expandQueries
=
=
aExpandQueries
)
return
aNode
;
var
query
=
{
}
options
=
{
}
;
this
.
history
.
queryStringToQuery
(
aNode
.
uri
query
options
)
;
options
.
value
.
excludeItems
=
aExcludeItems
;
options
.
value
.
expandQueries
=
aExpandQueries
;
return
this
.
history
.
executeQuery
(
query
.
value
options
.
value
)
.
root
;
}
hasChildURIs
:
function
PU_hasChildURIs
(
aNode
)
{
if
(
!
this
.
nodeIsContainer
(
aNode
)
)
return
false
;
let
root
=
this
.
getContainerNodeWithOptions
(
aNode
false
true
)
;
let
result
=
root
.
parentResult
;
let
didSuppressNotifications
=
false
;
let
wasOpen
=
root
.
containerOpen
;
if
(
!
wasOpen
)
{
didSuppressNotifications
=
result
.
suppressNotifications
;
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
true
;
root
.
containerOpen
=
true
;
}
let
found
=
false
;
for
(
let
i
=
0
;
i
<
root
.
childCount
&
&
!
found
;
i
+
+
)
{
let
child
=
root
.
getChild
(
i
)
;
if
(
this
.
nodeIsURI
(
child
)
)
found
=
true
;
}
if
(
!
wasOpen
)
{
root
.
containerOpen
=
false
;
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
false
;
}
return
found
;
}
getURLsForContainerNode
:
function
PU_getURLsForContainerNode
(
aNode
)
{
let
urls
=
[
]
;
if
(
!
this
.
nodeIsContainer
(
aNode
)
)
return
urls
;
let
root
=
this
.
getContainerNodeWithOptions
(
aNode
false
true
)
;
let
result
=
root
.
parentResult
;
let
wasOpen
=
root
.
containerOpen
;
let
didSuppressNotifications
=
false
;
if
(
!
wasOpen
)
{
didSuppressNotifications
=
result
.
suppressNotifications
;
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
true
;
root
.
containerOpen
=
true
;
}
for
(
let
i
=
0
;
i
<
root
.
childCount
;
+
+
i
)
{
let
child
=
root
.
getChild
(
i
)
;
if
(
this
.
nodeIsURI
(
child
)
)
urls
.
push
(
{
uri
:
child
.
uri
isBookmark
:
this
.
nodeIsBookmark
(
child
)
title
:
child
.
title
}
)
;
}
if
(
!
wasOpen
)
{
root
.
containerOpen
=
false
;
if
(
!
didSuppressNotifications
)
result
.
suppressNotifications
=
false
;
}
return
urls
;
}
promiseDBConnection
:
(
)
=
>
gAsyncDBConnPromised
async
withConnectionWrapper
(
name
task
)
{
if
(
!
name
)
{
throw
new
TypeError
(
"
Expecting
a
user
-
readable
name
"
)
;
}
let
db
=
await
gAsyncDBWrapperPromised
;
return
db
.
executeBeforeShutdown
(
name
task
)
;
}
promiseFaviconData
(
aPageUrl
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
PlacesUtils
.
favicons
.
getFaviconDataForPage
(
NetUtil
.
newURI
(
aPageUrl
)
function
(
uri
dataLen
data
mimeType
)
{
if
(
uri
)
{
resolve
(
{
uri
dataLen
data
mimeType
}
)
;
}
else
{
reject
(
)
;
}
}
)
;
}
)
;
}
urlWithSizeRef
(
window
href
size
)
{
return
href
+
(
href
.
includes
(
"
#
"
)
?
"
&
"
:
"
#
"
)
+
"
size
=
"
+
(
Math
.
round
(
size
)
*
window
.
devicePixelRatio
)
;
}
promiseItemGuid
(
aItemId
)
{
return
GuidHelper
.
getItemGuid
(
aItemId
)
;
}
promiseItemId
(
aGuid
)
{
return
GuidHelper
.
getItemId
(
aGuid
)
;
}
promiseManyItemIds
(
aGuids
)
{
return
GuidHelper
.
getManyItemIds
(
aGuids
)
;
}
invalidateCachedGuidFor
(
aItemId
)
{
GuidHelper
.
invalidateCacheForItemId
(
aItemId
)
;
}
async
promiseBookmarksTree
(
aItemGuid
=
"
"
aOptions
=
{
}
)
{
let
createItemInfoObject
=
async
function
(
aRow
aIncludeParentGuid
)
{
let
item
=
{
}
;
let
copyProps
=
(
.
.
.
props
)
=
>
{
for
(
let
prop
of
props
)
{
let
val
=
aRow
.
getResultByName
(
prop
)
;
if
(
val
!
=
=
null
)
item
[
prop
]
=
val
;
}
}
;
copyProps
(
"
guid
"
"
title
"
"
index
"
"
dateAdded
"
"
lastModified
"
)
;
if
(
aIncludeParentGuid
)
copyProps
(
"
parentGuid
"
)
;
let
itemId
=
aRow
.
getResultByName
(
"
id
"
)
;
if
(
aOptions
.
includeItemIds
)
item
.
id
=
itemId
;
GuidHelper
.
updateCache
(
itemId
item
.
guid
)
;
let
type
=
aRow
.
getResultByName
(
"
type
"
)
;
item
.
typeCode
=
type
;
if
(
type
=
=
Ci
.
nsINavBookmarksService
.
TYPE_BOOKMARK
)
copyProps
(
"
charset
"
"
tags
"
"
iconuri
"
)
;
if
(
aRow
.
getResultByName
(
"
has_annos
"
)
)
{
try
{
item
.
annos
=
await
PlacesUtils
.
promiseAnnotationsForItem
(
itemId
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Unexpected
error
while
reading
annotations
"
+
ex
)
;
}
}
switch
(
type
)
{
case
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
:
item
.
type
=
PlacesUtils
.
TYPE_X_MOZ_PLACE
;
item
.
uri
=
NetUtil
.
newURI
(
aRow
.
getResultByName
(
"
url
"
)
)
.
spec
;
let
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
{
url
:
item
.
uri
}
)
;
if
(
entry
)
{
item
.
keyword
=
entry
.
keyword
;
item
.
postData
=
entry
.
postData
;
}
break
;
case
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
:
item
.
type
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
;
if
(
itemId
=
=
PlacesUtils
.
placesRootId
)
item
.
root
=
"
placesRoot
"
;
else
if
(
itemId
=
=
PlacesUtils
.
bookmarksMenuFolderId
)
item
.
root
=
"
bookmarksMenuFolder
"
;
else
if
(
itemId
=
=
PlacesUtils
.
unfiledBookmarksFolderId
)
item
.
root
=
"
unfiledBookmarksFolder
"
;
else
if
(
itemId
=
=
PlacesUtils
.
toolbarFolderId
)
item
.
root
=
"
toolbarFolder
"
;
else
if
(
itemId
=
=
PlacesUtils
.
mobileFolderId
)
item
.
root
=
"
mobileFolder
"
;
break
;
case
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
:
item
.
type
=
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
;
break
;
default
:
Cu
.
reportError
(
Unexpected
bookmark
type
{
type
}
)
;
break
;
}
return
item
;
}
;
const
QUERY_STR
=
/
*
do
not
warn
(
bug
no
)
:
cannot
use
an
index
*
/
WITH
RECURSIVE
descendants
(
fk
level
type
id
guid
parent
parentGuid
position
title
dateAdded
lastModified
)
AS
(
SELECT
b1
.
fk
0
b1
.
type
b1
.
id
b1
.
guid
b1
.
parent
(
SELECT
guid
FROM
moz_bookmarks
WHERE
id
=
b1
.
parent
)
b1
.
position
b1
.
title
b1
.
dateAdded
b1
.
lastModified
FROM
moz_bookmarks
b1
WHERE
b1
.
guid
=
:
item_guid
UNION
ALL
SELECT
b2
.
fk
level
+
1
b2
.
type
b2
.
id
b2
.
guid
b2
.
parent
descendants
.
guid
b2
.
position
b2
.
title
b2
.
dateAdded
b2
.
lastModified
FROM
moz_bookmarks
b2
JOIN
descendants
ON
b2
.
parent
=
descendants
.
id
AND
b2
.
id
<
>
:
tags_folder
)
SELECT
d
.
level
d
.
id
d
.
guid
d
.
parent
d
.
parentGuid
d
.
type
d
.
position
AS
[
index
]
IFNULL
(
d
.
title
"
"
)
AS
title
d
.
dateAdded
d
.
lastModified
h
.
url
(
SELECT
icon_url
FROM
moz_icons
i
JOIN
moz_icons_to_pages
ON
icon_id
=
i
.
id
JOIN
moz_pages_w_icons
pi
ON
page_id
=
pi
.
id
WHERE
pi
.
page_url_hash
=
hash
(
h
.
url
)
AND
pi
.
page_url
=
h
.
url
ORDER
BY
width
DESC
LIMIT
1
)
AS
iconuri
(
SELECT
GROUP_CONCAT
(
t
.
title
'
'
)
FROM
moz_bookmarks
b2
JOIN
moz_bookmarks
t
ON
t
.
id
=
+
b2
.
parent
AND
t
.
parent
=
:
tags_folder
WHERE
b2
.
fk
=
h
.
id
)
AS
tags
EXISTS
(
SELECT
1
FROM
moz_items_annos
WHERE
item_id
=
d
.
id
LIMIT
1
)
AS
has_annos
(
SELECT
a
.
content
FROM
moz_annos
a
JOIN
moz_anno_attributes
n
ON
a
.
anno_attribute_id
=
n
.
id
WHERE
place_id
=
h
.
id
AND
n
.
name
=
:
charset_anno
)
AS
charset
FROM
descendants
d
LEFT
JOIN
moz_bookmarks
b3
ON
b3
.
id
=
d
.
parent
LEFT
JOIN
moz_places
h
ON
h
.
id
=
d
.
fk
ORDER
BY
d
.
level
d
.
parent
d
.
position
;
if
(
!
aItemGuid
)
aItemGuid
=
this
.
bookmarks
.
rootGuid
;
let
hasExcludeItemsCallback
=
aOptions
.
hasOwnProperty
(
"
excludeItemsCallback
"
)
;
let
excludedParents
=
new
Set
(
)
;
let
shouldExcludeItem
=
(
aItem
aParentGuid
)
=
>
{
let
exclude
=
excludedParents
.
has
(
aParentGuid
)
|
|
aOptions
.
excludeItemsCallback
(
aItem
)
;
if
(
exclude
)
{
if
(
aItem
.
type
=
=
this
.
TYPE_X_MOZ_PLACE_CONTAINER
)
excludedParents
.
add
(
aItem
.
guid
)
;
}
return
exclude
;
}
;
let
rootItem
=
null
;
let
parentsMap
=
new
Map
(
)
;
let
conn
=
await
this
.
promiseDBConnection
(
)
;
let
rows
=
await
conn
.
executeCached
(
QUERY_STR
{
tags_folder
:
PlacesUtils
.
tagsFolderId
charset_anno
:
PlacesUtils
.
CHARSET_ANNO
item_guid
:
aItemGuid
}
)
;
let
yieldCounter
=
0
;
for
(
let
row
of
rows
)
{
let
item
;
if
(
!
rootItem
)
{
try
{
rootItem
=
item
=
await
createItemInfoObject
(
row
true
)
;
Object
.
defineProperty
(
rootItem
"
itemsCount
"
{
value
:
1
writable
:
true
enumerable
:
false
configurable
:
false
}
)
;
}
catch
(
ex
)
{
throw
new
Error
(
"
Failed
to
fetch
the
data
for
the
root
item
"
+
ex
)
;
}
}
else
{
try
{
item
=
await
createItemInfoObject
(
row
false
)
;
let
parentGuid
=
row
.
getResultByName
(
"
parentGuid
"
)
;
if
(
hasExcludeItemsCallback
&
&
shouldExcludeItem
(
item
parentGuid
)
)
continue
;
let
parentItem
=
parentsMap
.
get
(
parentGuid
)
;
if
(
"
children
"
in
parentItem
)
parentItem
.
children
.
push
(
item
)
;
else
parentItem
.
children
=
[
item
]
;
rootItem
.
itemsCount
+
+
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Failed
to
fetch
the
data
for
an
item
"
+
ex
)
;
continue
;
}
}
if
(
item
.
type
=
=
this
.
TYPE_X_MOZ_PLACE_CONTAINER
)
parentsMap
.
set
(
item
.
guid
item
)
;
if
(
+
+
yieldCounter
%
50
=
=
0
)
{
await
new
Promise
(
resolve
=
>
{
Services
.
tm
.
dispatchToMainThread
(
resolve
)
;
}
)
;
}
}
return
rootItem
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUtils
"
history
"
function
(
)
{
let
hs
=
Cc
[
"
mozilla
.
org
/
browser
/
nav
-
history
-
service
;
1
"
]
.
getService
(
Ci
.
nsINavHistoryService
)
;
return
Object
.
freeze
(
new
Proxy
(
hs
{
get
(
target
name
)
{
let
property
object
;
if
(
name
in
target
)
{
property
=
target
[
name
]
;
object
=
target
;
}
else
{
property
=
History
[
name
]
;
object
=
History
;
}
if
(
typeof
property
=
=
"
function
"
)
{
return
property
.
bind
(
object
)
;
}
return
property
;
}
}
)
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
PlacesUtils
"
favicons
"
"
mozilla
.
org
/
browser
/
favicon
-
service
;
1
"
"
nsIFaviconService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
bmsvc
"
"
mozilla
.
org
/
browser
/
nav
-
bookmarks
-
service
;
1
"
"
nsINavBookmarksService
"
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUtils
"
bookmarks
"
(
)
=
>
{
return
Object
.
freeze
(
new
Proxy
(
Bookmarks
{
get
:
(
target
name
)
=
>
Bookmarks
.
hasOwnProperty
(
name
)
?
Bookmarks
[
name
]
:
bmsvc
[
name
]
}
)
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
PlacesUtils
"
annotations
"
"
mozilla
.
org
/
browser
/
annotation
-
service
;
1
"
"
nsIAnnotationService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
PlacesUtils
"
tagging
"
"
mozilla
.
org
/
browser
/
tagging
-
service
;
1
"
"
nsITaggingService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
PlacesUtils
"
livemarks
"
"
mozilla
.
org
/
browser
/
livemark
-
service
;
2
"
"
mozIAsyncLivemarks
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
bundle
"
function
(
)
{
const
PLACES_STRING_BUNDLE_URI
=
"
chrome
:
/
/
places
/
locale
/
places
.
properties
"
;
return
Services
.
strings
.
createBundle
(
PLACES_STRING_BUNDLE_URI
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PlacesUtils
"
instanceId
"
(
)
=
>
{
return
PlacesUtils
.
history
.
makeGuid
(
)
;
}
)
;
function
setupDbForShutdown
(
conn
name
)
{
try
{
let
state
=
"
0
.
Not
started
.
"
;
let
promiseClosed
=
new
Promise
(
(
resolve
reject
)
=
>
{
try
{
PlacesUtils
.
history
.
connectionShutdownClient
.
jsclient
.
addBlocker
(
{
name
}
closing
as
part
of
Places
shutdown
async
function
(
)
{
state
=
"
1
.
Service
has
initiated
shutdown
"
;
await
conn
.
close
(
)
;
state
=
"
2
.
Closed
Sqlite
.
jsm
connection
.
"
;
resolve
(
)
;
}
(
)
=
>
state
)
;
}
catch
(
ex
)
{
conn
.
close
(
)
;
reject
(
ex
)
;
}
}
)
;
Sqlite
.
shutdown
.
addBlocker
(
{
name
}
must
be
closed
before
Sqlite
.
jsm
(
)
=
>
promiseClosed
.
catch
(
Cu
.
reportError
)
(
)
=
>
state
)
;
}
catch
(
ex
)
{
conn
.
close
(
)
;
throw
ex
;
}
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gAsyncDBConnPromised
"
(
)
=
>
Sqlite
.
cloneStorageConnection
(
{
connection
:
PlacesUtils
.
history
.
DBConnection
readOnly
:
true
}
)
.
then
(
conn
=
>
{
setupDbForShutdown
(
conn
"
PlacesUtils
read
-
only
connection
"
)
;
return
conn
;
}
)
.
catch
(
Cu
.
reportError
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAsyncDBWrapperPromised
"
(
)
=
>
Sqlite
.
wrapStorageConnection
(
{
connection
:
PlacesUtils
.
history
.
DBConnection
}
)
.
then
(
conn
=
>
{
setupDbForShutdown
(
conn
"
PlacesUtils
wrapped
connection
"
)
;
return
conn
;
}
)
.
catch
(
Cu
.
reportError
)
)
;
PlacesUtils
.
metadata
=
{
cache
:
new
Map
(
)
jsonPrefix
:
"
data
:
application
/
json
;
base64
"
get
(
key
defaultValue
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUtils
.
metadata
.
get
"
db
=
>
this
.
getWithConnection
(
db
key
defaultValue
)
)
;
}
set
(
key
value
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUtils
.
metadata
.
set
"
db
=
>
this
.
setWithConnection
(
db
key
value
)
)
;
}
delete
(
.
.
.
keys
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUtils
.
metadata
.
delete
"
db
=
>
this
.
deleteWithConnection
(
db
.
.
.
keys
)
)
;
}
async
getWithConnection
(
db
key
defaultValue
)
{
key
=
this
.
canonicalizeKey
(
key
)
;
if
(
this
.
cache
.
has
(
key
)
)
{
return
this
.
cache
.
get
(
key
)
;
}
let
rows
=
await
db
.
executeCached
(
SELECT
value
FROM
moz_meta
WHERE
key
=
:
key
{
key
}
)
;
let
value
=
null
;
if
(
rows
.
length
)
{
let
row
=
rows
[
0
]
;
let
rawValue
=
row
.
getResultByName
(
"
value
"
)
;
if
(
row
.
getTypeOfIndex
(
0
)
=
=
row
.
VALUE_TYPE_BLOB
)
{
value
=
new
Uint8Array
(
rawValue
)
;
}
else
if
(
typeof
rawValue
=
=
"
string
"
&
&
rawValue
.
startsWith
(
this
.
jsonPrefix
)
)
{
try
{
value
=
JSON
.
parse
(
this
.
_base64Decode
(
rawValue
.
substr
(
this
.
jsonPrefix
.
length
)
)
)
;
}
catch
(
ex
)
{
if
(
defaultValue
!
=
=
undefined
)
{
value
=
defaultValue
;
}
else
{
throw
ex
;
}
}
}
else
{
value
=
rawValue
;
}
}
else
if
(
defaultValue
!
=
=
undefined
)
{
value
=
defaultValue
;
}
else
{
throw
new
Error
(
No
data
stored
for
key
{
key
}
)
;
}
this
.
cache
.
set
(
key
value
)
;
return
value
;
}
async
setWithConnection
(
db
key
value
)
{
if
(
value
=
=
=
null
)
{
await
this
.
deleteWithConnection
(
db
key
)
;
return
;
}
let
cacheValue
=
value
;
if
(
typeof
value
=
=
"
object
"
&
&
ChromeUtils
.
getClassName
(
value
)
!
=
"
Uint8Array
"
)
{
value
=
this
.
jsonPrefix
+
this
.
_base64Encode
(
JSON
.
stringify
(
value
)
)
;
}
key
=
this
.
canonicalizeKey
(
key
)
;
await
db
.
executeCached
(
REPLACE
INTO
moz_meta
(
key
value
)
VALUES
(
:
key
:
value
)
{
key
value
}
)
;
this
.
cache
.
set
(
key
cacheValue
)
;
}
async
deleteWithConnection
(
db
.
.
.
keys
)
{
keys
=
keys
.
map
(
this
.
canonicalizeKey
)
;
if
(
!
keys
.
length
)
{
return
;
}
await
db
.
execute
(
DELETE
FROM
moz_meta
WHERE
key
IN
(
{
new
Array
(
keys
.
length
)
.
fill
(
"
?
"
)
.
join
(
"
"
)
}
)
keys
)
;
for
(
let
key
of
keys
)
{
this
.
cache
.
delete
(
key
)
;
}
}
canonicalizeKey
(
key
)
{
if
(
typeof
key
!
=
"
string
"
|
|
!
/
^
[
a
-
zA
-
Z0
-
9
\
/
]
+
/
.
test
(
key
)
)
{
throw
new
TypeError
(
"
Invalid
metadata
key
:
"
+
key
)
;
}
return
key
.
toLowerCase
(
)
;
}
_base64Encode
(
str
)
{
return
ChromeUtils
.
base64URLEncode
(
new
TextEncoder
(
"
utf
-
8
"
)
.
encode
(
str
)
{
pad
:
true
}
)
;
}
_base64Decode
(
str
)
{
return
new
TextDecoder
(
"
utf
-
8
"
)
.
decode
(
ChromeUtils
.
base64URLDecode
(
str
{
padding
:
"
require
"
}
)
)
;
}
}
;
PlacesUtils
.
keywords
=
{
fetch
(
keywordOrEntry
onResult
=
null
)
{
if
(
typeof
(
keywordOrEntry
)
=
=
"
string
"
)
keywordOrEntry
=
{
keyword
:
keywordOrEntry
}
;
if
(
keywordOrEntry
=
=
=
null
|
|
typeof
(
keywordOrEntry
)
!
=
"
object
"
|
|
(
(
"
keyword
"
in
keywordOrEntry
)
&
&
typeof
(
keywordOrEntry
.
keyword
)
!
=
"
string
"
)
)
throw
new
Error
(
"
Invalid
keyword
"
)
;
let
hasKeyword
=
"
keyword
"
in
keywordOrEntry
;
let
hasUrl
=
"
url
"
in
keywordOrEntry
;
if
(
!
hasKeyword
&
&
!
hasUrl
)
throw
new
Error
(
"
At
least
keyword
or
url
must
be
provided
"
)
;
if
(
onResult
&
&
typeof
onResult
!
=
"
function
"
)
throw
new
Error
(
"
onResult
callback
must
be
a
valid
function
"
)
;
if
(
hasUrl
)
{
try
{
keywordOrEntry
.
url
=
BOOKMARK_VALIDATORS
.
url
(
keywordOrEntry
.
url
)
;
}
catch
(
ex
)
{
throw
new
Error
(
keywordOrEntry
.
url
+
"
is
not
a
valid
URL
"
)
;
}
}
if
(
hasKeyword
)
keywordOrEntry
.
keyword
=
keywordOrEntry
.
keyword
.
trim
(
)
.
toLowerCase
(
)
;
let
safeOnResult
=
entry
=
>
{
if
(
onResult
)
{
try
{
onResult
(
entry
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
;
return
promiseKeywordsCache
(
)
.
then
(
cache
=
>
{
let
entries
=
[
]
;
if
(
hasKeyword
)
{
let
entry
=
cache
.
get
(
keywordOrEntry
.
keyword
)
;
if
(
entry
)
entries
.
push
(
entry
)
;
}
if
(
hasUrl
)
{
for
(
let
entry
of
cache
.
values
(
)
)
{
if
(
entry
.
url
.
href
=
=
keywordOrEntry
.
url
.
href
)
entries
.
push
(
entry
)
;
}
}
entries
=
entries
.
filter
(
e
=
>
{
return
(
!
hasUrl
|
|
e
.
url
.
href
=
=
keywordOrEntry
.
url
.
href
)
&
&
(
!
hasKeyword
|
|
e
.
keyword
=
=
keywordOrEntry
.
keyword
)
;
}
)
;
entries
.
forEach
(
safeOnResult
)
;
return
entries
.
length
?
entries
[
0
]
:
null
;
}
)
;
}
insert
(
keywordEntry
)
{
if
(
!
keywordEntry
|
|
typeof
keywordEntry
!
=
"
object
"
)
throw
new
Error
(
"
Input
should
be
a
valid
object
"
)
;
if
(
!
(
"
keyword
"
in
keywordEntry
)
|
|
!
keywordEntry
.
keyword
|
|
typeof
(
keywordEntry
.
keyword
)
!
=
"
string
"
)
throw
new
Error
(
"
Invalid
keyword
"
)
;
if
(
(
"
postData
"
in
keywordEntry
)
&
&
keywordEntry
.
postData
&
&
typeof
(
keywordEntry
.
postData
)
!
=
"
string
"
)
throw
new
Error
(
"
Invalid
POST
data
"
)
;
if
(
!
(
"
url
"
in
keywordEntry
)
)
throw
new
Error
(
"
undefined
is
not
a
valid
URL
"
)
;
if
(
!
(
"
source
"
in
keywordEntry
)
)
{
keywordEntry
.
source
=
PlacesUtils
.
bookmarks
.
SOURCES
.
DEFAULT
;
}
let
{
keyword
url
source
}
=
keywordEntry
;
keyword
=
keyword
.
trim
(
)
.
toLowerCase
(
)
;
let
postData
=
keywordEntry
.
postData
|
|
"
"
;
try
{
url
=
BOOKMARK_VALIDATORS
.
url
(
url
)
;
}
catch
(
ex
)
{
throw
new
Error
(
url
+
"
is
not
a
valid
URL
"
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUtils
.
keywords
.
insert
"
async
db
=
>
{
let
cache
=
await
promiseKeywordsCache
(
)
;
let
oldEntry
=
cache
.
get
(
keyword
)
;
if
(
oldEntry
&
&
oldEntry
.
url
.
href
=
=
url
.
href
&
&
(
oldEntry
.
postData
|
|
"
"
)
=
=
postData
)
{
return
;
}
if
(
oldEntry
)
{
await
db
.
executeCached
(
UPDATE
moz_keywords
SET
place_id
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
post_data
=
:
post_data
WHERE
keyword
=
:
keyword
{
url
:
url
.
href
keyword
post_data
:
postData
}
)
;
await
notifyKeywordChange
(
oldEntry
.
url
.
href
"
"
source
)
;
}
else
{
await
db
.
executeTransaction
(
async
(
)
=
>
{
await
db
.
executeCached
(
INSERT
OR
IGNORE
INTO
moz_places
(
url
url_hash
rev_host
hidden
frecency
guid
)
VALUES
(
:
url
hash
(
:
url
)
:
rev_host
0
:
frecency
IFNULL
(
(
SELECT
guid
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
GENERATE_GUID
(
)
)
)
{
url
:
url
.
href
rev_host
:
PlacesUtils
.
getReversedHost
(
url
)
frecency
:
url
.
protocol
=
=
"
place
:
"
?
0
:
-
1
}
)
;
await
db
.
executeCached
(
"
DELETE
FROM
moz_updateoriginsinsert_temp
"
)
;
let
oldKeywords
=
[
]
;
for
(
let
entry
of
cache
.
values
(
)
)
{
if
(
entry
.
url
.
href
=
=
url
.
href
&
&
(
entry
.
postData
|
|
"
"
)
=
=
postData
)
oldKeywords
.
push
(
entry
.
keyword
)
;
}
if
(
oldKeywords
.
length
)
{
for
(
let
oldKeyword
of
oldKeywords
)
{
await
db
.
executeCached
(
DELETE
FROM
moz_keywords
WHERE
keyword
=
:
oldKeyword
{
oldKeyword
}
)
;
cache
.
delete
(
oldKeyword
)
;
}
}
await
db
.
executeCached
(
INSERT
INTO
moz_keywords
(
keyword
place_id
post_data
)
VALUES
(
:
keyword
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
:
post_data
)
{
url
:
url
.
href
keyword
post_data
:
postData
}
)
;
await
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
url
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
source
)
)
;
}
)
;
}
cache
.
set
(
keyword
{
keyword
url
postData
:
postData
|
|
null
}
)
;
await
notifyKeywordChange
(
url
.
href
keyword
source
)
;
}
)
;
}
remove
(
keywordOrEntry
)
{
if
(
typeof
(
keywordOrEntry
)
=
=
"
string
"
)
{
keywordOrEntry
=
{
keyword
:
keywordOrEntry
source
:
Ci
.
nsINavBookmarksService
.
SOURCE_DEFAULT
}
;
}
if
(
keywordOrEntry
=
=
=
null
|
|
typeof
(
keywordOrEntry
)
!
=
"
object
"
|
|
!
keywordOrEntry
.
keyword
|
|
typeof
keywordOrEntry
.
keyword
!
=
"
string
"
)
throw
new
Error
(
"
Invalid
keyword
"
)
;
let
{
keyword
source
=
Ci
.
nsINavBookmarksService
.
SOURCE_DEFAULT
}
=
keywordOrEntry
;
keyword
=
keywordOrEntry
.
keyword
.
trim
(
)
.
toLowerCase
(
)
;
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUtils
.
keywords
.
remove
"
async
db
=
>
{
let
cache
=
await
promiseKeywordsCache
(
)
;
if
(
!
cache
.
has
(
keyword
)
)
return
;
let
{
url
}
=
cache
.
get
(
keyword
)
;
cache
.
delete
(
keyword
)
;
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
execute
(
DELETE
FROM
moz_keywords
WHERE
keyword
=
:
keyword
{
keyword
}
)
;
await
PlacesSyncUtils
.
bookmarks
.
addSyncChangesForBookmarksWithURL
(
db
url
PlacesSyncUtils
.
bookmarks
.
determineSyncChangeDelta
(
source
)
)
;
}
)
;
await
notifyKeywordChange
(
url
.
href
"
"
source
)
;
}
)
;
}
reassign
(
oldURL
newURL
source
=
PlacesUtils
.
bookmarks
.
SOURCES
.
DEFAULT
)
{
try
{
oldURL
=
BOOKMARK_VALIDATORS
.
url
(
oldURL
)
;
}
catch
(
ex
)
{
throw
new
Error
(
oldURL
+
"
is
not
a
valid
source
URL
"
)
;
}
try
{
newURL
=
BOOKMARK_VALIDATORS
.
url
(
newURL
)
;
}
catch
(
ex
)
{
throw
new
Error
(
oldURL
+
"
is
not
a
valid
destination
URL
"
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUtils
.
keywords
.
reassign
"
async
function
(
db
)
{
let
keywordsToReassign
=
[
]
;
let
keywordsToRemove
=
[
]
;
let
cache
=
await
promiseKeywordsCache
(
)
;
for
(
let
[
keyword
entry
]
of
cache
)
{
if
(
entry
.
url
.
href
=
=
oldURL
.
href
)
{
keywordsToReassign
.
push
(
keyword
)
;
}
if
(
entry
.
url
.
href
=
=
newURL
.
href
)
{
keywordsToRemove
.
push
(
keyword
)
;
}
}
if
(
!
keywordsToReassign
.
length
)
{
return
;
}
await
db
.
executeTransaction
(
async
function
(
)
{
await
db
.
executeCached
(
DELETE
FROM
moz_keywords
WHERE
keyword
=
:
keyword
keywordsToRemove
.
map
(
keyword
=
>
(
{
keyword
}
)
)
)
;
await
db
.
executeCached
(
UPDATE
moz_keywords
SET
place_id
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
newURL
)
AND
url
=
:
newURL
)
WHERE
place_id
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
oldURL
)
AND
url
=
:
oldURL
)
{
newURL
:
newURL
.
href
oldURL
:
oldURL
.
href
}
)
;
}
)
;
for
(
let
keyword
of
keywordsToReassign
)
{
let
entry
=
cache
.
get
(
keyword
)
;
entry
.
url
=
newURL
;
}
for
(
let
keyword
of
keywordsToRemove
)
{
cache
.
delete
(
keyword
)
;
}
if
(
keywordsToReassign
.
length
)
{
await
notifyKeywordChange
(
oldURL
"
"
source
)
;
await
notifyKeywordChange
(
newURL
"
"
source
)
;
for
(
let
keyword
of
keywordsToReassign
)
{
await
notifyKeywordChange
(
newURL
keyword
source
)
;
}
}
else
if
(
keywordsToRemove
.
length
)
{
await
notifyKeywordChange
(
oldURL
"
"
source
)
;
}
}
)
;
}
removeFromURLsIfNotBookmarked
(
urls
)
{
let
hrefs
=
new
Set
(
)
;
for
(
let
url
of
urls
)
{
try
{
url
=
BOOKMARK_VALIDATORS
.
url
(
url
)
;
}
catch
(
ex
)
{
throw
new
Error
(
url
+
"
is
not
a
valid
URL
"
)
;
}
hrefs
.
add
(
url
.
href
)
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUtils
.
keywords
.
removeFromURLsIfNotBookmarked
"
async
function
(
db
)
{
let
keywordsByHref
=
new
Map
(
)
;
let
cache
=
await
promiseKeywordsCache
(
)
;
for
(
let
[
keyword
entry
]
of
cache
)
{
let
href
=
entry
.
url
.
href
;
if
(
!
hrefs
.
has
(
href
)
)
{
continue
;
}
if
(
!
keywordsByHref
.
has
(
href
)
)
{
keywordsByHref
.
set
(
href
[
keyword
]
)
;
continue
;
}
let
existingKeywords
=
keywordsByHref
.
get
(
href
)
;
existingKeywords
.
push
(
keyword
)
;
}
if
(
!
keywordsByHref
.
size
)
{
return
;
}
let
placeInfosToRemove
=
[
]
;
let
rows
=
await
db
.
execute
(
SELECT
h
.
id
h
.
url
FROM
moz_places
h
JOIN
moz_keywords
k
ON
k
.
place_id
=
h
.
id
GROUP
BY
h
.
id
HAVING
h
.
foreign_count
=
count
(
*
)
+
(
SELECT
count
(
*
)
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
p
ON
b
.
parent
=
p
.
id
WHERE
p
.
parent
=
:
tags_root
AND
b
.
fk
=
h
.
id
)
{
tags_root
:
PlacesUtils
.
tagsFolderId
}
)
;
for
(
let
row
of
rows
)
{
placeInfosToRemove
.
push
(
{
placeId
:
row
.
getResultByName
(
"
id
"
)
href
:
row
.
getResultByName
(
"
url
"
)
}
)
;
}
if
(
!
placeInfosToRemove
.
length
)
{
return
;
}
await
db
.
execute
(
DELETE
FROM
moz_keywords
WHERE
place_id
IN
(
{
Array
.
from
(
placeInfosToRemove
.
map
(
info
=
>
info
.
placeId
)
)
.
join
(
)
}
)
)
;
for
(
let
{
href
}
of
placeInfosToRemove
)
{
let
keywords
=
keywordsByHref
.
get
(
href
)
;
for
(
let
keyword
of
keywords
)
{
cache
.
delete
(
keyword
)
;
}
}
}
)
;
}
eraseEverything
(
)
{
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUtils
.
keywords
.
eraseEverything
"
async
function
(
db
)
{
let
cache
=
await
promiseKeywordsCache
(
)
;
if
(
!
cache
.
size
)
{
return
;
}
await
db
.
executeCached
(
DELETE
FROM
moz_keywords
)
;
cache
.
clear
(
)
;
}
)
;
}
invalidateCachedKeywords
(
)
{
gKeywordsCachePromise
=
gKeywordsCachePromise
.
then
(
_
=
>
null
)
;
return
gKeywordsCachePromise
;
}
}
;
var
gKeywordsCachePromise
=
Promise
.
resolve
(
)
;
function
promiseKeywordsCache
(
)
{
let
promise
=
gKeywordsCachePromise
.
then
(
function
(
cache
)
{
if
(
cache
)
{
return
cache
;
}
return
PlacesUtils
.
withConnectionWrapper
(
"
PlacesUtils
:
promiseKeywordsCache
"
async
db
=
>
{
let
cache
=
new
Map
(
)
;
let
rows
=
await
db
.
execute
(
SELECT
keyword
url
post_data
FROM
moz_keywords
k
JOIN
moz_places
h
ON
h
.
id
=
k
.
place_id
)
;
let
brokenKeywords
=
[
]
;
for
(
let
row
of
rows
)
{
let
keyword
=
row
.
getResultByName
(
"
keyword
"
)
;
try
{
let
entry
=
{
keyword
url
:
new
URL
(
row
.
getResultByName
(
"
url
"
)
)
postData
:
row
.
getResultByName
(
"
post_data
"
)
|
|
null
}
;
cache
.
set
(
keyword
entry
)
;
}
catch
(
ex
)
{
brokenKeywords
.
push
(
keyword
)
;
}
}
if
(
brokenKeywords
.
length
)
{
await
db
.
execute
(
DELETE
FROM
moz_keywords
WHERE
keyword
IN
(
{
brokenKeywords
.
map
(
JSON
.
stringify
)
.
join
(
"
"
)
}
)
)
;
}
return
cache
;
}
)
;
}
)
;
gKeywordsCachePromise
=
promise
.
catch
(
_
=
>
{
}
)
;
return
promise
;
}
var
GuidHelper
=
{
guidsForIds
:
new
Map
(
)
idsForGuids
:
new
Map
(
)
async
getItemId
(
aGuid
)
{
let
cached
=
this
.
idsForGuids
.
get
(
aGuid
)
;
if
(
cached
!
=
=
undefined
)
return
cached
;
let
itemId
=
await
PlacesUtils
.
withConnectionWrapper
(
"
GuidHelper
.
getItemId
"
async
function
(
db
)
{
let
rows
=
await
db
.
executeCached
(
"
SELECT
b
.
id
b
.
guid
from
moz_bookmarks
b
WHERE
b
.
guid
=
:
guid
LIMIT
1
"
{
guid
:
aGuid
}
)
;
if
(
rows
.
length
=
=
0
)
throw
new
Error
(
"
no
item
found
for
the
given
GUID
"
)
;
return
rows
[
0
]
.
getResultByName
(
"
id
"
)
;
}
)
;
this
.
updateCache
(
itemId
aGuid
)
;
return
itemId
;
}
async
getManyItemIds
(
aGuids
)
{
let
uncachedGuids
=
aGuids
.
filter
(
guid
=
>
!
this
.
idsForGuids
.
has
(
guid
)
)
;
if
(
uncachedGuids
.
length
)
{
await
PlacesUtils
.
withConnectionWrapper
(
"
GuidHelper
.
getItemId
"
async
db
=
>
{
while
(
uncachedGuids
.
length
)
{
let
chunk
=
uncachedGuids
.
splice
(
0
100
)
;
let
rows
=
await
db
.
executeCached
(
SELECT
b
.
id
b
.
guid
from
moz_bookmarks
b
WHERE
b
.
guid
IN
(
{
"
?
"
.
repeat
(
chunk
.
length
-
1
)
+
"
?
"
}
)
LIMIT
{
chunk
.
length
}
chunk
)
;
if
(
rows
.
length
<
chunk
.
length
)
throw
new
Error
(
"
Not
all
items
were
found
!
"
)
;
for
(
let
row
of
rows
)
{
this
.
updateCache
(
row
.
getResultByIndex
(
0
)
row
.
getResultByIndex
(
1
)
)
;
}
}
}
)
;
}
return
new
Map
(
aGuids
.
map
(
guid
=
>
[
guid
this
.
idsForGuids
.
get
(
guid
)
]
)
)
;
}
async
getItemGuid
(
aItemId
)
{
let
cached
=
this
.
guidsForIds
.
get
(
aItemId
)
;
if
(
cached
!
=
=
undefined
)
return
cached
;
let
guid
=
await
PlacesUtils
.
withConnectionWrapper
(
"
GuidHelper
.
getItemGuid
"
async
function
(
db
)
{
let
rows
=
await
db
.
executeCached
(
"
SELECT
b
.
id
b
.
guid
from
moz_bookmarks
b
WHERE
b
.
id
=
:
id
LIMIT
1
"
{
id
:
aItemId
}
)
;
if
(
rows
.
length
=
=
0
)
throw
new
Error
(
"
no
item
found
for
the
given
itemId
"
)
;
return
rows
[
0
]
.
getResultByName
(
"
guid
"
)
;
}
)
;
this
.
updateCache
(
aItemId
guid
)
;
return
guid
;
}
updateCache
(
aItemId
aGuid
)
{
if
(
typeof
(
aItemId
)
!
=
"
number
"
|
|
aItemId
<
=
0
)
throw
new
Error
(
"
Trying
to
update
the
GUIDs
cache
with
an
invalid
itemId
"
)
;
if
(
!
PlacesUtils
.
isValidGuid
(
aGuid
)
)
throw
new
Error
(
"
Trying
to
update
the
GUIDs
cache
with
an
invalid
GUID
"
)
;
this
.
ensureObservingRemovedItems
(
)
;
this
.
guidsForIds
.
set
(
aItemId
aGuid
)
;
this
.
idsForGuids
.
set
(
aGuid
aItemId
)
;
}
invalidateCacheForItemId
(
aItemId
)
{
let
guid
=
this
.
guidsForIds
.
get
(
aItemId
)
;
this
.
guidsForIds
.
delete
(
aItemId
)
;
this
.
idsForGuids
.
delete
(
guid
)
;
}
ensureObservingRemovedItems
(
)
{
if
(
!
(
"
observer
"
in
this
)
)
{
this
.
observer
=
{
onItemAdded
:
(
aItemId
aParentId
aIndex
aItemType
aURI
aTitle
aDateAdded
aGuid
aParentGuid
)
=
>
{
this
.
updateCache
(
aItemId
aGuid
)
;
this
.
updateCache
(
aParentId
aParentGuid
)
;
}
onItemRemoved
:
(
aItemId
aParentId
aIndex
aItemTyep
aURI
aGuid
aParentGuid
)
=
>
{
this
.
guidsForIds
.
delete
(
aItemId
)
;
this
.
idsForGuids
.
delete
(
aGuid
)
;
this
.
updateCache
(
aParentId
aParentGuid
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsINavBookmarkObserver
]
)
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onItemChanged
(
)
{
}
onItemVisited
(
)
{
}
onItemMoved
(
)
{
}
}
;
PlacesUtils
.
bookmarks
.
addObserver
(
this
.
observer
)
;
PlacesUtils
.
registerShutdownFunction
(
(
)
=
>
{
PlacesUtils
.
bookmarks
.
removeObserver
(
this
.
observer
)
;
}
)
;
}
}
}
;
