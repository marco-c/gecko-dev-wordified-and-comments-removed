#
pragma
once
#
include
"
nsIFaviconService
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
mozIPlacesPendingOperation
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
PlacesCompletionCallback
.
h
"
class
nsIPrincipal
;
#
include
"
Database
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
define
ICON_STATUS_UNKNOWN
0
#
define
ICON_STATUS_CHANGED
1
<
<
0
#
define
ICON_STATUS_SAVED
1
<
<
1
#
define
ICON_STATUS_ASSOCIATED
1
<
<
2
#
define
ICON_STATUS_CACHED
1
<
<
3
#
define
TO_CHARBUFFER
(
_buffer
)
\
reinterpret_cast
<
char
*
>
(
const_cast
<
uint8_t
*
>
(
_buffer
)
)
#
define
TO_INTBUFFER
(
_string
)
\
reinterpret_cast
<
uint8_t
*
>
(
const_cast
<
char
*
>
(
_string
.
get
(
)
)
)
#
define
PNG_MIME_TYPE
"
image
/
png
"
#
define
SVG_MIME_TYPE
"
image
/
svg
+
xml
"
#
define
MIN_FAVICON_EXPIRATION
(
(
PRTime
)
1
*
24
*
60
*
60
*
PR_USEC_PER_SEC
)
#
define
MAX_FAVICON_EXPIRATION
(
(
PRTime
)
7
*
24
*
60
*
60
*
PR_USEC_PER_SEC
)
namespace
mozilla
{
namespace
places
{
enum
AsyncFaviconFetchMode
{
FETCH_NEVER
=
0
FETCH_IF_MISSING
FETCH_ALWAYS
}
;
struct
IconPayload
{
IconPayload
(
)
:
id
(
0
)
width
(
0
)
{
data
.
SetIsVoid
(
true
)
;
mimeType
.
SetIsVoid
(
true
)
;
}
int64_t
id
;
uint16_t
width
;
nsCString
data
;
nsCString
mimeType
;
}
;
struct
IconData
{
IconData
(
)
:
expiration
(
0
)
fetchMode
(
FETCH_NEVER
)
status
(
ICON_STATUS_UNKNOWN
)
rootIcon
(
0
)
flags
(
0
)
{
}
nsCString
spec
;
nsCString
host
;
PRTime
expiration
;
enum
AsyncFaviconFetchMode
fetchMode
;
uint16_t
status
;
uint8_t
rootIcon
;
CopyableTArray
<
IconPayload
>
payloads
;
uint16_t
flags
;
}
;
struct
PageData
{
PageData
(
)
:
id
(
0
)
placeId
(
0
)
canAddToHistory
(
true
)
{
guid
.
SetIsVoid
(
true
)
;
}
int64_t
id
;
int64_t
placeId
;
nsCString
spec
;
nsCString
host
;
nsCString
bookmarkedSpec
;
bool
canAddToHistory
;
nsCString
guid
;
}
;
struct
FrameData
{
FrameData
(
uint16_t
aIndex
uint16_t
aWidth
)
:
index
(
aIndex
)
width
(
aWidth
)
{
}
uint16_t
index
;
uint16_t
width
;
}
;
class
AsyncFetchAndSetIconForPage
final
:
public
Runnable
public
nsIStreamListener
public
nsIInterfaceRequestor
public
nsIChannelEventSink
public
mozIPlacesPendingOperation
{
public
:
NS_DECL_NSIRUNNABLE
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_MOZIPLACESPENDINGOPERATION
NS_DECL_ISUPPORTS_INHERITED
AsyncFetchAndSetIconForPage
(
IconData
&
aIcon
PageData
&
aPage
bool
aFaviconLoadPrivate
nsIFaviconDataCallback
*
aCallback
nsIPrincipal
*
aLoadingPrincipal
uint64_t
aRequestContextID
)
;
private
:
nsresult
FetchFromNetwork
(
)
;
virtual
~
AsyncFetchAndSetIconForPage
(
)
=
default
;
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
IconData
mIcon
;
PageData
mPage
;
const
bool
mFaviconLoadPrivate
;
nsMainThreadPtrHandle
<
nsIPrincipal
>
mLoadingPrincipal
;
bool
mCanceled
;
nsCOMPtr
<
nsIRequest
>
mRequest
;
uint64_t
mRequestContextID
;
}
;
class
AsyncAssociateIconToPage
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
AsyncAssociateIconToPage
(
const
IconData
&
aIcon
const
PageData
&
aPage
const
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
&
aCallback
)
;
private
:
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
IconData
mIcon
;
PageData
mPage
;
}
;
class
AsyncSetIconForPage
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
AsyncSetIconForPage
(
const
IconData
&
aIcon
const
PageData
&
aPage
PlacesCompletionCallback
*
aCallback
)
;
private
:
nsMainThreadPtrHandle
<
PlacesCompletionCallback
>
mCallback
;
IconData
mIcon
;
PageData
mPage
;
}
;
class
AsyncGetFaviconURLForPage
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
AsyncGetFaviconURLForPage
(
const
nsACString
&
aPageSpec
const
nsACString
&
aPageHost
uint16_t
aPreferredWidth
nsIFaviconDataCallback
*
aCallback
)
;
private
:
uint16_t
mPreferredWidth
;
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
nsCString
mPageSpec
;
nsCString
mPageHost
;
}
;
class
AsyncGetFaviconDataForPage
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
AsyncGetFaviconDataForPage
(
const
nsACString
&
aPageSpec
const
nsACString
&
aPageHost
uint16_t
aPreferredWidth
nsIFaviconDataCallback
*
aCallback
)
;
private
:
uint16_t
mPreferredWidth
;
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
nsCString
mPageSpec
;
nsCString
mPageHost
;
}
;
class
NotifyIconObservers
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
NotifyIconObservers
(
const
IconData
&
aIcon
const
PageData
&
aPage
const
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
&
aCallback
)
;
private
:
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
IconData
mIcon
;
PageData
mPage
;
}
;
class
AsyncCopyFavicons
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
AsyncCopyFavicons
(
PageData
&
aFromPage
PageData
&
aToPage
nsIFaviconDataCallback
*
aCallback
)
;
private
:
PageData
mFromPage
;
PageData
mToPage
;
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
}
;
}
}
