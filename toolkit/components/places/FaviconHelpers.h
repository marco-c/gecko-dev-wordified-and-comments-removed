#
pragma
once
#
include
"
nsIFaviconService
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
mozIPlacesPendingOperation
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsProxyRelease
.
h
"
class
nsIPrincipal
;
#
include
"
Database
.
h
"
#
include
"
mozilla
/
storage
.
h
"
#
define
ICON_STATUS_UNKNOWN
0
#
define
ICON_STATUS_CHANGED
1
<
<
0
#
define
ICON_STATUS_SAVED
1
<
<
1
#
define
ICON_STATUS_ASSOCIATED
1
<
<
2
#
define
ICON_STATUS_CACHED
1
<
<
3
#
define
TO_CHARBUFFER
(
_buffer
)
\
reinterpret_cast
<
char
*
>
(
const_cast
<
uint8_t
*
>
(
_buffer
)
)
#
define
TO_INTBUFFER
(
_string
)
\
reinterpret_cast
<
uint8_t
*
>
(
const_cast
<
char
*
>
(
_string
.
get
(
)
)
)
#
define
MAX_FAVICON_EXPIRATION
(
(
PRTime
)
7
*
24
*
60
*
60
*
PR_USEC_PER_SEC
)
namespace
mozilla
{
namespace
places
{
enum
AsyncFaviconFetchMode
{
FETCH_NEVER
=
0
FETCH_IF_MISSING
FETCH_ALWAYS
}
;
struct
IconData
{
IconData
(
)
:
id
(
0
)
expiration
(
0
)
fetchMode
(
FETCH_NEVER
)
status
(
ICON_STATUS_UNKNOWN
)
{
}
int64_t
id
;
nsCString
spec
;
nsCString
data
;
nsCString
mimeType
;
PRTime
expiration
;
enum
AsyncFaviconFetchMode
fetchMode
;
uint16_t
status
;
}
;
struct
PageData
{
PageData
(
)
:
id
(
0
)
canAddToHistory
(
true
)
iconId
(
0
)
{
guid
.
SetIsVoid
(
true
)
;
}
int64_t
id
;
nsCString
spec
;
nsCString
bookmarkedSpec
;
nsString
revHost
;
bool
canAddToHistory
;
int64_t
iconId
;
nsCString
guid
;
}
;
class
AsyncFetchAndSetIconForPage
final
:
public
Runnable
public
nsIStreamListener
public
nsIInterfaceRequestor
public
nsIChannelEventSink
public
mozIPlacesPendingOperation
{
public
:
NS_DECL_NSIRUNNABLE
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_MOZIPLACESPENDINGOPERATION
NS_DECL_ISUPPORTS_INHERITED
AsyncFetchAndSetIconForPage
(
IconData
&
aIcon
PageData
&
aPage
bool
aFaviconLoadPrivate
nsIFaviconDataCallback
*
aCallback
nsIPrincipal
*
aLoadingPrincipal
)
;
private
:
nsresult
FetchFromNetwork
(
)
;
virtual
~
AsyncFetchAndSetIconForPage
(
)
{
}
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
IconData
mIcon
;
PageData
mPage
;
const
bool
mFaviconLoadPrivate
;
nsMainThreadPtrHandle
<
nsIPrincipal
>
mLoadingPrincipal
;
bool
mCanceled
;
nsCOMPtr
<
nsIRequest
>
mRequest
;
}
;
class
AsyncAssociateIconToPage
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
AsyncAssociateIconToPage
(
const
IconData
&
aIcon
const
PageData
&
aPage
const
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
&
aCallback
)
;
private
:
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
IconData
mIcon
;
PageData
mPage
;
}
;
class
AsyncGetFaviconURLForPage
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
AsyncGetFaviconURLForPage
(
const
nsACString
&
aPageSpec
nsIFaviconDataCallback
*
aCallback
)
;
private
:
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
nsCString
mPageSpec
;
}
;
class
AsyncGetFaviconDataForPage
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
AsyncGetFaviconDataForPage
(
const
nsACString
&
aPageSpec
nsIFaviconDataCallback
*
aCallback
)
;
private
:
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
nsCString
mPageSpec
;
}
;
class
AsyncReplaceFaviconData
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
explicit
AsyncReplaceFaviconData
(
const
IconData
&
aIcon
)
;
private
:
nsresult
RemoveIconDataCacheEntry
(
)
;
IconData
mIcon
;
}
;
class
NotifyIconObservers
final
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
NotifyIconObservers
(
const
IconData
&
aIcon
const
PageData
&
aPage
const
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
&
aCallback
)
;
private
:
nsMainThreadPtrHandle
<
nsIFaviconDataCallback
>
mCallback
;
IconData
mIcon
;
PageData
mPage
;
void
SendGlobalNotifications
(
nsIURI
*
aIconURI
)
;
}
;
}
}
