#
ifndef
mozilla_places_History_h_
#
define
mozilla_places_History_h_
#
include
"
mozilla
/
IHistory
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozIAsyncHistory
.
h
"
#
include
"
nsIDownloadHistory
.
h
"
#
include
"
Database
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
mozilla
/
ipc
/
URIParams
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
mozIStorageConnection
.
h
"
namespace
mozilla
{
namespace
places
{
struct
VisitData
;
class
ConcurrentStatementsHolder
;
#
define
NS_HISTORYSERVICE_CID
\
{
0x0937a705
0x91a6
0x417a
{
0x82
0x92
0xb2
0x2e
0xb1
0x0d
0xa8
0x6c
}
}
#
define
RECENTLY_VISITED_URIS_SIZE
64
#
define
RECENTLY_VISITED_URIS_MAX_AGE
6
*
60
*
PR_USEC_PER_SEC
#
define
NOTIFY_VISITS_CHUNK_SIZE
100
class
History
final
:
public
IHistory
public
nsIDownloadHistory
public
mozIAsyncHistory
public
nsIObserver
public
nsIMemoryReporter
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_IHISTORY
NS_DECL_NSIDOWNLOADHISTORY
NS_DECL_MOZIASYNCHISTORY
NS_DECL_NSIOBSERVER
NS_DECL_NSIMEMORYREPORTER
History
(
)
;
nsresult
GetIsVisitedStatement
(
mozIStorageCompletionCallback
*
aCallback
)
;
nsresult
InsertPlace
(
VisitData
&
aVisitData
bool
aShouldNotifyFrecencyChanged
=
true
)
;
nsresult
UpdatePlace
(
const
VisitData
&
aVisitData
)
;
nsresult
FetchPageInfo
(
VisitData
&
_place
bool
*
_exists
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
;
static
History
*
GetService
(
)
;
static
already_AddRefed
<
History
>
GetSingleton
(
)
;
template
<
int
N
>
already_AddRefed
<
mozIStorageStatement
>
GetStatement
(
const
char
(
&
aQuery
)
[
N
]
)
{
const
mozIStorageConnection
*
dbConn
=
GetConstDBConn
(
)
;
NS_ENSURE_TRUE
(
dbConn
nullptr
)
;
return
mDB
-
>
GetStatement
(
aQuery
)
;
}
already_AddRefed
<
mozIStorageStatement
>
GetStatement
(
const
nsACString
&
aQuery
)
{
const
mozIStorageConnection
*
dbConn
=
GetConstDBConn
(
)
;
NS_ENSURE_TRUE
(
dbConn
nullptr
)
;
return
mDB
-
>
GetStatement
(
aQuery
)
;
}
bool
IsShuttingDown
(
)
const
{
return
mShuttingDown
;
}
Mutex
&
GetShutdownMutex
(
)
{
return
mShutdownMutex
;
}
void
AppendToRecentlyVisitedURIs
(
nsIURI
*
aURI
)
;
void
NotifyVisitedParent
(
const
nsTArray
<
mozilla
:
:
ipc
:
:
URIParams
>
&
aURIs
)
;
private
:
virtual
~
History
(
)
;
void
InitMemoryReporter
(
)
;
mozIStorageConnection
*
GetDBConn
(
)
;
const
mozIStorageConnection
*
GetConstDBConn
(
)
;
void
NotifyVisitedForDocument
(
nsIURI
*
aURI
nsIDocument
*
aDocument
)
;
void
DispatchNotifyVisited
(
nsIURI
*
aURI
nsIDocument
*
aDocument
)
;
RefPtr
<
mozilla
:
:
places
:
:
Database
>
mDB
;
RefPtr
<
ConcurrentStatementsHolder
>
mConcurrentStatementsHolder
;
void
Shutdown
(
)
;
static
History
*
gService
;
bool
mShuttingDown
;
Mutex
mShutdownMutex
;
typedef
nsTObserverArray
<
mozilla
:
:
dom
:
:
Link
*
>
ObserverArray
;
class
KeyClass
:
public
nsURIHashKey
{
public
:
explicit
KeyClass
(
const
nsIURI
*
aURI
)
:
nsURIHashKey
(
aURI
)
{
}
KeyClass
(
KeyClass
&
&
aOther
)
:
nsURIHashKey
(
std
:
:
move
(
aOther
)
)
array
(
std
:
:
move
(
aOther
.
array
)
)
mVisited
(
std
:
:
move
(
aOther
.
mVisited
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Do
not
call
me
!
"
)
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
array
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
ObserverArray
array
;
bool
mVisited
=
false
;
}
;
nsTHashtable
<
KeyClass
>
mObservers
;
class
RecentURIKey
:
public
nsURIHashKey
{
public
:
explicit
RecentURIKey
(
const
nsIURI
*
aURI
)
:
nsURIHashKey
(
aURI
)
{
}
RecentURIKey
(
RecentURIKey
&
&
aOther
)
:
nsURIHashKey
(
std
:
:
move
(
aOther
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Do
not
call
me
!
"
)
;
}
MOZ_INIT_OUTSIDE_CTOR
PRTime
time
;
}
;
nsTHashtable
<
RecentURIKey
>
mRecentlyVisitedURIs
;
bool
IsRecentlyVisitedURI
(
nsIURI
*
aURI
)
;
}
;
}
}
#
endif
