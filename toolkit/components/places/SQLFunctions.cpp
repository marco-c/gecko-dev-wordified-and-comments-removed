#
include
"
mozilla
/
storage
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWhitespaceTokenizer
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
mozIPlacesAutoComplete
.
h
"
#
include
"
SQLFunctions
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
nsINavHistoryService
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsNavHistory
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
define
MAX_CHARS_TO_SEARCH_THROUGH
255
using
namespace
mozilla
:
:
storage
;
namespace
{
typedef
nsACString
:
:
const_char_iterator
const_char_iterator
;
static
MOZ_ALWAYS_INLINE
const_char_iterator
nextWordBoundary
(
const_char_iterator
const
aStart
const_char_iterator
const
aNext
const_char_iterator
const
aEnd
)
{
const_char_iterator
cur
=
aStart
;
if
(
(
'
a
'
<
=
*
cur
&
&
*
cur
<
=
'
z
'
)
|
|
(
'
A
'
<
=
*
cur
&
&
*
cur
<
=
'
Z
'
)
)
{
do
{
cur
+
+
;
}
while
(
cur
<
aEnd
&
&
'
a
'
<
=
*
cur
&
&
*
cur
<
=
'
z
'
)
;
}
else
{
cur
=
aNext
;
}
return
cur
;
}
enum
FindInStringBehavior
{
eFindOnBoundary
eFindAnywhere
}
;
static
MOZ_ALWAYS_INLINE
bool
findInString
(
const
nsDependentCSubstring
&
aToken
const
nsACString
&
aSourceString
FindInStringBehavior
aBehavior
)
{
NS_PRECONDITION
(
!
aToken
.
IsEmpty
(
)
"
Don
'
t
search
for
an
empty
token
!
"
)
;
if
(
aSourceString
.
IsEmpty
(
)
)
{
return
false
;
}
const_char_iterator
tokenStart
(
aToken
.
BeginReading
(
)
)
tokenEnd
(
aToken
.
EndReading
(
)
)
sourceStart
(
aSourceString
.
BeginReading
(
)
)
sourceEnd
(
aSourceString
.
EndReading
(
)
)
;
do
{
const_char_iterator
sourceNext
tokenCur
;
bool
error
;
if
(
CaseInsensitiveUTF8CharsEqual
(
sourceStart
tokenStart
sourceEnd
tokenEnd
&
sourceNext
&
tokenCur
&
error
)
)
{
const_char_iterator
sourceCur
=
sourceNext
;
while
(
true
)
{
if
(
tokenCur
>
=
tokenEnd
)
{
return
true
;
}
if
(
sourceCur
>
=
sourceEnd
)
{
return
false
;
}
if
(
!
CaseInsensitiveUTF8CharsEqual
(
sourceCur
tokenCur
sourceEnd
tokenEnd
&
sourceCur
&
tokenCur
&
error
)
)
{
break
;
}
}
}
if
(
MOZ_UNLIKELY
(
error
)
)
{
return
false
;
}
if
(
aBehavior
=
=
eFindOnBoundary
)
{
sourceStart
=
nextWordBoundary
(
sourceStart
sourceNext
sourceEnd
)
;
}
else
{
sourceStart
=
sourceNext
;
}
}
while
(
sourceStart
<
sourceEnd
)
;
return
false
;
}
static
MOZ_ALWAYS_INLINE
nsDependentCString
getSharedString
(
mozIStorageValueArray
*
aValues
uint32_t
aIndex
)
{
uint32_t
len
;
const
char
*
str
=
aValues
-
>
AsSharedUTF8String
(
aIndex
&
len
)
;
if
(
!
str
)
{
return
nsDependentCString
(
"
"
(
uint32_t
)
0
)
;
}
return
nsDependentCString
(
str
len
)
;
}
}
namespace
mozilla
{
namespace
places
{
nsresult
MatchAutoCompleteFunction
:
:
create
(
mozIStorageConnection
*
aDBConn
)
{
RefPtr
<
MatchAutoCompleteFunction
>
function
=
new
MatchAutoCompleteFunction
(
)
;
nsresult
rv
=
aDBConn
-
>
CreateFunction
(
NS_LITERAL_CSTRING
(
"
autocomplete_match
"
)
kArgIndexLength
function
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsDependentCSubstring
MatchAutoCompleteFunction
:
:
fixupURISpec
(
const
nsACString
&
aURISpec
int32_t
aMatchBehavior
nsACString
&
aSpecBuf
)
{
nsDependentCSubstring
fixedSpec
;
bool
unescaped
=
NS_UnescapeURL
(
aURISpec
.
BeginReading
(
)
aURISpec
.
Length
(
)
esc_SkipControl
aSpecBuf
)
;
if
(
unescaped
&
&
IsUTF8
(
aSpecBuf
)
)
{
fixedSpec
.
Rebind
(
aSpecBuf
0
)
;
}
else
{
fixedSpec
.
Rebind
(
aURISpec
0
)
;
}
if
(
aMatchBehavior
=
=
mozIPlacesAutoComplete
:
:
MATCH_ANYWHERE_UNMODIFIED
)
return
fixedSpec
;
if
(
StringBeginsWith
(
fixedSpec
NS_LITERAL_CSTRING
(
"
http
:
/
/
"
)
)
)
{
fixedSpec
.
Rebind
(
fixedSpec
7
)
;
}
else
if
(
StringBeginsWith
(
fixedSpec
NS_LITERAL_CSTRING
(
"
https
:
/
/
"
)
)
)
{
fixedSpec
.
Rebind
(
fixedSpec
8
)
;
}
else
if
(
StringBeginsWith
(
fixedSpec
NS_LITERAL_CSTRING
(
"
ftp
:
/
/
"
)
)
)
{
fixedSpec
.
Rebind
(
fixedSpec
6
)
;
}
if
(
StringBeginsWith
(
fixedSpec
NS_LITERAL_CSTRING
(
"
www
.
"
)
)
)
{
fixedSpec
.
Rebind
(
fixedSpec
4
)
;
}
return
fixedSpec
;
}
bool
MatchAutoCompleteFunction
:
:
findAnywhere
(
const
nsDependentCSubstring
&
aToken
const
nsACString
&
aSourceString
)
{
return
findInString
(
aToken
aSourceString
eFindAnywhere
)
;
}
bool
MatchAutoCompleteFunction
:
:
findOnBoundary
(
const
nsDependentCSubstring
&
aToken
const
nsACString
&
aSourceString
)
{
return
findInString
(
aToken
aSourceString
eFindOnBoundary
)
;
}
bool
MatchAutoCompleteFunction
:
:
findBeginning
(
const
nsDependentCSubstring
&
aToken
const
nsACString
&
aSourceString
)
{
NS_PRECONDITION
(
!
aToken
.
IsEmpty
(
)
"
Don
'
t
search
for
an
empty
token
!
"
)
;
const_char_iterator
tokenStart
(
aToken
.
BeginReading
(
)
)
tokenEnd
(
aToken
.
EndReading
(
)
)
sourceStart
(
aSourceString
.
BeginReading
(
)
)
sourceEnd
(
aSourceString
.
EndReading
(
)
)
;
bool
dummy
;
while
(
sourceStart
<
sourceEnd
&
&
CaseInsensitiveUTF8CharsEqual
(
sourceStart
tokenStart
sourceEnd
tokenEnd
&
sourceStart
&
tokenStart
&
dummy
)
)
{
if
(
tokenStart
>
=
tokenEnd
)
{
return
true
;
}
}
return
false
;
}
bool
MatchAutoCompleteFunction
:
:
findBeginningCaseSensitive
(
const
nsDependentCSubstring
&
aToken
const
nsACString
&
aSourceString
)
{
NS_PRECONDITION
(
!
aToken
.
IsEmpty
(
)
"
Don
'
t
search
for
an
empty
token
!
"
)
;
return
StringBeginsWith
(
aSourceString
aToken
)
;
}
MatchAutoCompleteFunction
:
:
searchFunctionPtr
MatchAutoCompleteFunction
:
:
getSearchFunction
(
int32_t
aBehavior
)
{
switch
(
aBehavior
)
{
case
mozIPlacesAutoComplete
:
:
MATCH_ANYWHERE
:
case
mozIPlacesAutoComplete
:
:
MATCH_ANYWHERE_UNMODIFIED
:
return
findAnywhere
;
case
mozIPlacesAutoComplete
:
:
MATCH_BEGINNING
:
return
findBeginning
;
case
mozIPlacesAutoComplete
:
:
MATCH_BEGINNING_CASE_SENSITIVE
:
return
findBeginningCaseSensitive
;
case
mozIPlacesAutoComplete
:
:
MATCH_BOUNDARY
:
default
:
return
findOnBoundary
;
}
;
}
NS_IMPL_ISUPPORTS
(
MatchAutoCompleteFunction
mozIStorageFunction
)
NS_IMETHODIMP
MatchAutoCompleteFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aArguments
nsIVariant
*
*
_result
)
{
int32_t
searchBehavior
=
aArguments
-
>
AsInt32
(
kArgIndexSearchBehavior
)
;
#
define
HAS_BEHAVIOR
(
aBitName
)
\
(
searchBehavior
&
mozIPlacesAutoComplete
:
:
BEHAVIOR_
#
#
aBitName
)
nsDependentCString
searchString
=
getSharedString
(
aArguments
kArgSearchString
)
;
nsDependentCString
url
=
getSharedString
(
aArguments
kArgIndexURL
)
;
int32_t
matchBehavior
=
aArguments
-
>
AsInt32
(
kArgIndexMatchBehavior
)
;
if
(
matchBehavior
!
=
mozIPlacesAutoComplete
:
:
MATCH_ANYWHERE_UNMODIFIED
&
&
StringBeginsWith
(
url
NS_LITERAL_CSTRING
(
"
javascript
:
"
)
)
&
&
!
HAS_BEHAVIOR
(
JAVASCRIPT
)
&
&
!
StringBeginsWith
(
searchString
NS_LITERAL_CSTRING
(
"
javascript
:
"
)
)
)
{
NS_ADDREF
(
*
_result
=
new
IntegerVariant
(
0
)
)
;
return
NS_OK
;
}
int32_t
visitCount
=
aArguments
-
>
AsInt32
(
kArgIndexVisitCount
)
;
bool
typed
=
aArguments
-
>
AsInt32
(
kArgIndexTyped
)
?
true
:
false
;
bool
bookmark
=
aArguments
-
>
AsInt32
(
kArgIndexBookmark
)
?
true
:
false
;
nsDependentCString
tags
=
getSharedString
(
aArguments
kArgIndexTags
)
;
int32_t
openPageCount
=
aArguments
-
>
AsInt32
(
kArgIndexOpenPageCount
)
;
bool
matches
=
false
;
if
(
HAS_BEHAVIOR
(
RESTRICT
)
)
{
matches
=
(
!
HAS_BEHAVIOR
(
HISTORY
)
|
|
visitCount
>
0
)
&
&
(
!
HAS_BEHAVIOR
(
TYPED
)
|
|
typed
)
&
&
(
!
HAS_BEHAVIOR
(
BOOKMARK
)
|
|
bookmark
)
&
&
(
!
HAS_BEHAVIOR
(
TAG
)
|
|
!
tags
.
IsVoid
(
)
)
&
&
(
!
HAS_BEHAVIOR
(
OPENPAGE
)
|
|
openPageCount
>
0
)
;
}
else
{
matches
=
(
HAS_BEHAVIOR
(
HISTORY
)
&
&
visitCount
>
0
)
|
|
(
HAS_BEHAVIOR
(
TYPED
)
&
&
typed
)
|
|
(
HAS_BEHAVIOR
(
BOOKMARK
)
&
&
bookmark
)
|
|
(
HAS_BEHAVIOR
(
TAG
)
&
&
!
tags
.
IsVoid
(
)
)
|
|
(
HAS_BEHAVIOR
(
OPENPAGE
)
&
&
openPageCount
>
0
)
;
}
if
(
!
matches
)
{
NS_ADDREF
(
*
_result
=
new
IntegerVariant
(
0
)
)
;
return
NS_OK
;
}
searchFunctionPtr
searchFunction
=
getSearchFunction
(
matchBehavior
)
;
nsCString
fixedUrlBuf
;
nsDependentCSubstring
fixedUrl
=
fixupURISpec
(
url
matchBehavior
fixedUrlBuf
)
;
const
nsDependentCSubstring
&
trimmedUrl
=
Substring
(
fixedUrl
0
MAX_CHARS_TO_SEARCH_THROUGH
)
;
nsDependentCString
title
=
getSharedString
(
aArguments
kArgIndexTitle
)
;
const
nsDependentCSubstring
&
trimmedTitle
=
Substring
(
title
0
MAX_CHARS_TO_SEARCH_THROUGH
)
;
nsCWhitespaceTokenizer
tokenizer
(
searchString
)
;
while
(
matches
&
&
tokenizer
.
hasMoreTokens
(
)
)
{
const
nsDependentCSubstring
&
token
=
tokenizer
.
nextToken
(
)
;
if
(
HAS_BEHAVIOR
(
TITLE
)
&
&
HAS_BEHAVIOR
(
URL
)
)
{
matches
=
(
searchFunction
(
token
trimmedTitle
)
|
|
searchFunction
(
token
tags
)
)
&
&
searchFunction
(
token
trimmedUrl
)
;
}
else
if
(
HAS_BEHAVIOR
(
TITLE
)
)
{
matches
=
searchFunction
(
token
trimmedTitle
)
|
|
searchFunction
(
token
tags
)
;
}
else
if
(
HAS_BEHAVIOR
(
URL
)
)
{
matches
=
searchFunction
(
token
trimmedUrl
)
;
}
else
{
matches
=
searchFunction
(
token
trimmedTitle
)
|
|
searchFunction
(
token
tags
)
|
|
searchFunction
(
token
trimmedUrl
)
;
}
}
NS_ADDREF
(
*
_result
=
new
IntegerVariant
(
matches
?
1
:
0
)
)
;
return
NS_OK
;
#
undef
HAS_BEHAVIOR
}
nsresult
CalculateFrecencyFunction
:
:
create
(
mozIStorageConnection
*
aDBConn
)
{
RefPtr
<
CalculateFrecencyFunction
>
function
=
new
CalculateFrecencyFunction
(
)
;
nsresult
rv
=
aDBConn
-
>
CreateFunction
(
NS_LITERAL_CSTRING
(
"
calculate_frecency
"
)
1
function
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
CalculateFrecencyFunction
mozIStorageFunction
)
NS_IMETHODIMP
CalculateFrecencyFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aArguments
nsIVariant
*
*
_result
)
{
uint32_t
numEntries
;
nsresult
rv
=
aArguments
-
>
GetNumEntries
(
&
numEntries
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
numEntries
=
=
1
"
unexpected
number
of
arguments
"
)
;
int64_t
pageId
=
aArguments
-
>
AsInt64
(
0
)
;
MOZ_ASSERT
(
pageId
>
0
"
Should
always
pass
a
valid
page
id
"
)
;
if
(
pageId
<
=
0
)
{
NS_ADDREF
(
*
_result
=
new
IntegerVariant
(
0
)
)
;
return
NS_OK
;
}
int32_t
typed
=
0
;
int32_t
visitCount
=
0
;
bool
hasBookmark
=
false
;
int32_t
isQuery
=
0
;
float
pointsForSampledVisits
=
0
.
0
;
int32_t
numSampledVisits
=
0
;
int32_t
bonus
=
0
;
const
nsNavHistory
*
history
=
nsNavHistory
:
:
GetConstHistoryService
(
)
;
NS_ENSURE_STATE
(
history
)
;
RefPtr
<
Database
>
DB
=
Database
:
:
GetDatabase
(
)
;
NS_ENSURE_STATE
(
DB
)
;
{
RefPtr
<
mozIStorageStatement
>
getPageInfo
=
DB
-
>
GetStatement
(
"
SELECT
typed
visit_count
foreign_count
"
"
(
substr
(
url
0
7
)
=
'
place
:
'
)
"
"
FROM
moz_places
"
"
WHERE
id
=
:
page_id
"
)
;
NS_ENSURE_STATE
(
getPageInfo
)
;
mozStorageStatementScoper
infoScoper
(
getPageInfo
)
;
rv
=
getPageInfo
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
page_id
"
)
pageId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasResult
=
false
;
rv
=
getPageInfo
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_TRUE
(
NS_SUCCEEDED
(
rv
)
&
&
hasResult
NS_ERROR_UNEXPECTED
)
;
rv
=
getPageInfo
-
>
GetInt32
(
0
&
typed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
getPageInfo
-
>
GetInt32
(
1
&
visitCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
foreignCount
=
0
;
rv
=
getPageInfo
-
>
GetInt32
(
2
&
foreignCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
hasBookmark
=
foreignCount
>
0
;
rv
=
getPageInfo
-
>
GetInt32
(
3
&
isQuery
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
visitCount
>
0
)
{
nsCOMPtr
<
mozIStorageStatement
>
getVisits
=
DB
-
>
GetStatement
(
NS_LITERAL_CSTRING
(
"
/
*
do
not
warn
(
bug
659740
-
SQLite
may
ignore
index
if
few
visits
exist
)
*
/
"
"
SELECT
"
"
ROUND
(
(
strftime
(
'
%
s
'
'
now
'
'
localtime
'
'
utc
'
)
-
v
.
visit_date
/
1000000
)
/
86400
)
"
"
IFNULL
(
r
.
visit_type
v
.
visit_type
)
"
"
v
.
visit_date
"
"
FROM
moz_historyvisits
v
"
"
LEFT
JOIN
moz_historyvisits
r
ON
r
.
id
=
v
.
from_visit
AND
v
.
visit_type
BETWEEN
"
)
+
nsPrintfCString
(
"
%
d
AND
%
d
"
nsINavHistoryService
:
:
TRANSITION_REDIRECT_PERMANENT
nsINavHistoryService
:
:
TRANSITION_REDIRECT_TEMPORARY
)
+
NS_LITERAL_CSTRING
(
"
WHERE
v
.
place_id
=
:
page_id
"
"
ORDER
BY
v
.
visit_date
DESC
"
)
)
;
NS_ENSURE_STATE
(
getVisits
)
;
mozStorageStatementScoper
visitsScoper
(
getVisits
)
;
rv
=
getVisits
-
>
BindInt64ByName
(
NS_LITERAL_CSTRING
(
"
page_id
"
)
pageId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasResult
=
false
;
for
(
int32_t
maxVisits
=
history
-
>
GetNumVisitsForFrecency
(
)
;
numSampledVisits
<
maxVisits
&
&
NS_SUCCEEDED
(
getVisits
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
;
numSampledVisits
+
+
)
{
int32_t
visitType
;
rv
=
getVisits
-
>
GetInt32
(
1
&
visitType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bonus
=
history
-
>
GetFrecencyTransitionBonus
(
visitType
true
)
;
if
(
hasBookmark
)
{
bonus
+
=
history
-
>
GetFrecencyTransitionBonus
(
nsINavHistoryService
:
:
TRANSITION_BOOKMARK
true
)
;
}
if
(
bonus
)
{
int32_t
ageInDays
=
getVisits
-
>
AsInt32
(
0
)
;
int32_t
weight
=
history
-
>
GetFrecencyAgedWeight
(
ageInDays
)
;
pointsForSampledVisits
+
=
(
float
)
(
weight
*
(
bonus
/
100
.
0
)
)
;
}
}
}
if
(
numSampledVisits
)
{
if
(
!
pointsForSampledVisits
)
{
NS_ADDREF
(
*
_result
=
new
IntegerVariant
(
-
1
)
)
;
}
else
{
NS_ADDREF
(
*
_result
=
new
IntegerVariant
(
(
int32_t
)
ceilf
(
visitCount
*
ceilf
(
pointsForSampledVisits
)
/
numSampledVisits
)
)
)
;
}
return
NS_OK
;
}
if
(
!
hasBookmark
|
|
isQuery
)
{
NS_ADDREF
(
*
_result
=
new
IntegerVariant
(
0
)
)
;
return
NS_OK
;
}
visitCount
=
1
;
bonus
+
=
history
-
>
GetFrecencyTransitionBonus
(
nsINavHistoryService
:
:
TRANSITION_BOOKMARK
false
)
;
if
(
typed
)
{
bonus
+
=
history
-
>
GetFrecencyTransitionBonus
(
nsINavHistoryService
:
:
TRANSITION_TYPED
false
)
;
}
pointsForSampledVisits
=
history
-
>
GetFrecencyBucketWeight
(
1
)
*
(
bonus
/
(
float
)
100
.
0
)
;
NS_ADDREF
(
*
_result
=
new
IntegerVariant
(
(
int32_t
)
ceilf
(
visitCount
*
ceilf
(
pointsForSampledVisits
)
)
)
)
;
return
NS_OK
;
}
nsresult
GenerateGUIDFunction
:
:
create
(
mozIStorageConnection
*
aDBConn
)
{
RefPtr
<
GenerateGUIDFunction
>
function
=
new
GenerateGUIDFunction
(
)
;
nsresult
rv
=
aDBConn
-
>
CreateFunction
(
NS_LITERAL_CSTRING
(
"
generate_guid
"
)
0
function
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
GenerateGUIDFunction
mozIStorageFunction
)
NS_IMETHODIMP
GenerateGUIDFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aArguments
nsIVariant
*
*
_result
)
{
nsAutoCString
guid
;
nsresult
rv
=
GenerateGUID
(
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ADDREF
(
*
_result
=
new
UTF8TextVariant
(
guid
)
)
;
return
NS_OK
;
}
nsresult
GetUnreversedHostFunction
:
:
create
(
mozIStorageConnection
*
aDBConn
)
{
RefPtr
<
GetUnreversedHostFunction
>
function
=
new
GetUnreversedHostFunction
(
)
;
nsresult
rv
=
aDBConn
-
>
CreateFunction
(
NS_LITERAL_CSTRING
(
"
get_unreversed_host
"
)
1
function
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
GetUnreversedHostFunction
mozIStorageFunction
)
NS_IMETHODIMP
GetUnreversedHostFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aArguments
nsIVariant
*
*
_result
)
{
MOZ_ASSERT
(
aArguments
)
;
nsAutoString
src
;
aArguments
-
>
GetString
(
0
src
)
;
RefPtr
<
nsVariant
>
result
=
new
nsVariant
(
)
;
if
(
src
.
Length
(
)
>
1
)
{
src
.
Truncate
(
src
.
Length
(
)
-
1
)
;
nsAutoString
dest
;
ReverseString
(
src
dest
)
;
result
-
>
SetAsAString
(
dest
)
;
}
else
{
result
-
>
SetAsAString
(
EmptyString
(
)
)
;
}
result
.
forget
(
_result
)
;
return
NS_OK
;
}
nsresult
FixupURLFunction
:
:
create
(
mozIStorageConnection
*
aDBConn
)
{
RefPtr
<
FixupURLFunction
>
function
=
new
FixupURLFunction
(
)
;
nsresult
rv
=
aDBConn
-
>
CreateFunction
(
NS_LITERAL_CSTRING
(
"
fixup_url
"
)
1
function
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
FixupURLFunction
mozIStorageFunction
)
NS_IMETHODIMP
FixupURLFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aArguments
nsIVariant
*
*
_result
)
{
MOZ_ASSERT
(
aArguments
)
;
nsAutoString
src
;
aArguments
-
>
GetString
(
0
src
)
;
RefPtr
<
nsVariant
>
result
=
new
nsVariant
(
)
;
if
(
StringBeginsWith
(
src
NS_LITERAL_STRING
(
"
http
:
/
/
"
)
)
)
src
.
Cut
(
0
7
)
;
else
if
(
StringBeginsWith
(
src
NS_LITERAL_STRING
(
"
https
:
/
/
"
)
)
)
src
.
Cut
(
0
8
)
;
else
if
(
StringBeginsWith
(
src
NS_LITERAL_STRING
(
"
ftp
:
/
/
"
)
)
)
src
.
Cut
(
0
6
)
;
if
(
StringBeginsWith
(
src
NS_LITERAL_STRING
(
"
www
.
"
)
)
)
{
src
.
Cut
(
0
4
)
;
}
result
-
>
SetAsAString
(
src
)
;
result
.
forget
(
_result
)
;
return
NS_OK
;
}
nsresult
FrecencyNotificationFunction
:
:
create
(
mozIStorageConnection
*
aDBConn
)
{
RefPtr
<
FrecencyNotificationFunction
>
function
=
new
FrecencyNotificationFunction
(
)
;
nsresult
rv
=
aDBConn
-
>
CreateFunction
(
NS_LITERAL_CSTRING
(
"
notify_frecency
"
)
5
function
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
FrecencyNotificationFunction
mozIStorageFunction
)
NS_IMETHODIMP
FrecencyNotificationFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aArgs
nsIVariant
*
*
_result
)
{
uint32_t
numArgs
;
nsresult
rv
=
aArgs
-
>
GetNumEntries
(
&
numArgs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
numArgs
=
=
5
)
;
int32_t
newFrecency
=
aArgs
-
>
AsInt32
(
0
)
;
nsAutoCString
spec
;
rv
=
aArgs
-
>
GetUTF8String
(
1
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
guid
;
rv
=
aArgs
-
>
GetUTF8String
(
2
guid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hidden
=
static_cast
<
bool
>
(
aArgs
-
>
AsInt32
(
3
)
)
;
PRTime
lastVisitDate
=
static_cast
<
PRTime
>
(
aArgs
-
>
AsInt64
(
4
)
)
;
const
nsNavHistory
*
navHistory
=
nsNavHistory
:
:
GetConstHistoryService
(
)
;
NS_ENSURE_STATE
(
navHistory
)
;
navHistory
-
>
DispatchFrecencyChangedNotification
(
spec
newFrecency
guid
hidden
lastVisitDate
)
;
RefPtr
<
nsVariant
>
result
=
new
nsVariant
(
)
;
rv
=
result
-
>
SetAsInt32
(
newFrecency
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
result
.
forget
(
_result
)
;
return
NS_OK
;
}
nsresult
StoreLastInsertedIdFunction
:
:
create
(
mozIStorageConnection
*
aDBConn
)
{
RefPtr
<
StoreLastInsertedIdFunction
>
function
=
new
StoreLastInsertedIdFunction
(
)
;
nsresult
rv
=
aDBConn
-
>
CreateFunction
(
NS_LITERAL_CSTRING
(
"
store_last_inserted_id
"
)
2
function
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
StoreLastInsertedIdFunction
mozIStorageFunction
)
NS_IMETHODIMP
StoreLastInsertedIdFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aArgs
nsIVariant
*
*
_result
)
{
uint32_t
numArgs
;
nsresult
rv
=
aArgs
-
>
GetNumEntries
(
&
numArgs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
numArgs
=
=
2
)
;
nsAutoCString
table
;
rv
=
aArgs
-
>
GetUTF8String
(
0
table
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
lastInsertedId
=
aArgs
-
>
AsInt64
(
1
)
;
nsNavHistory
:
:
StoreLastInsertedId
(
table
lastInsertedId
)
;
RefPtr
<
nsVariant
>
result
=
new
nsVariant
(
)
;
rv
=
result
-
>
SetAsInt64
(
lastInsertedId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
result
.
forget
(
_result
)
;
return
NS_OK
;
}
nsresult
HashFunction
:
:
create
(
mozIStorageConnection
*
aDBConn
)
{
RefPtr
<
HashFunction
>
function
=
new
HashFunction
(
)
;
return
aDBConn
-
>
CreateFunction
(
NS_LITERAL_CSTRING
(
"
hash
"
)
-
1
function
)
;
}
NS_IMPL_ISUPPORTS
(
HashFunction
mozIStorageFunction
)
NS_IMETHODIMP
HashFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aArguments
nsIVariant
*
*
_result
)
{
MOZ_ASSERT
(
aArguments
)
;
uint32_t
numEntries
;
nsresult
rv
=
aArguments
-
>
GetNumEntries
(
&
numEntries
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
numEntries
>
=
1
&
&
numEntries
<
=
2
NS_ERROR_FAILURE
)
;
nsString
str
;
aArguments
-
>
GetString
(
0
str
)
;
nsAutoCString
mode
;
if
(
numEntries
>
1
)
{
aArguments
-
>
GetUTF8String
(
1
mode
)
;
}
RefPtr
<
nsVariant
>
result
=
new
nsVariant
(
)
;
if
(
mode
.
IsEmpty
(
)
)
{
nsAString
:
:
const_iterator
start
tip
end
;
str
.
BeginReading
(
tip
)
;
start
=
tip
;
str
.
EndReading
(
end
)
;
if
(
FindInReadable
(
NS_LITERAL_STRING
(
"
:
"
)
tip
end
)
)
{
const
nsDependentSubstring
&
prefix
=
Substring
(
start
tip
)
;
uint64_t
prefixHash
=
static_cast
<
uint64_t
>
(
HashString
(
prefix
)
&
0x0000FFFF
)
;
uint32_t
srcHash
=
HashString
(
str
)
;
uint64_t
hash
=
(
prefixHash
<
<
32
)
+
srcHash
;
result
-
>
SetAsInt64
(
hash
)
;
}
else
{
uint32_t
hash
=
HashString
(
str
)
;
result
-
>
SetAsInt64
(
hash
)
;
}
}
else
if
(
mode
.
Equals
(
NS_LITERAL_CSTRING
(
"
prefix_lo
"
)
)
)
{
uint64_t
hash
=
static_cast
<
uint64_t
>
(
HashString
(
str
)
&
0x0000FFFF
)
<
<
32
;
result
-
>
SetAsInt64
(
hash
)
;
}
else
if
(
mode
.
Equals
(
NS_LITERAL_CSTRING
(
"
prefix_hi
"
)
)
)
{
uint64_t
hash
=
static_cast
<
uint64_t
>
(
HashString
(
str
)
&
0x0000FFFF
)
<
<
32
;
hash
+
=
0xFFFFFFFF
;
result
-
>
SetAsInt64
(
hash
)
;
}
else
{
return
NS_ERROR_FAILURE
;
}
result
.
forget
(
_result
)
;
return
NS_OK
;
}
}
}
