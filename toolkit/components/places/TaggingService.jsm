const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
PlacesUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
TOPIC_SHUTDOWN
=
"
places
-
shutdown
"
;
function
TaggingService
(
)
{
this
.
handlePlacesEvents
=
this
.
handlePlacesEvents
.
bind
(
this
)
;
PlacesUtils
.
bookmarks
.
addObserver
(
this
)
;
PlacesUtils
.
observers
.
addListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
]
this
.
handlePlacesEvents
)
;
Services
.
obs
.
addObserver
(
this
TOPIC_SHUTDOWN
)
;
}
TaggingService
.
prototype
=
{
_createTag
:
function
TS__createTag
(
aTagName
aSource
)
{
var
newFolderId
=
PlacesUtils
.
bookmarks
.
createFolder
(
PlacesUtils
.
tagsFolderId
aTagName
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
null
aSource
)
;
this
.
_tagFolders
[
newFolderId
]
=
aTagName
;
return
newFolderId
;
}
_getItemIdForTaggedURI
:
function
TS__getItemIdForTaggedURI
(
aURI
aTagName
)
{
var
tagId
=
this
.
_getItemIdForTag
(
aTagName
)
;
if
(
tagId
=
=
-
1
)
{
return
-
1
;
}
let
db
=
PlacesUtils
.
history
.
DBConnection
;
let
stmt
=
db
.
createStatement
(
SELECT
id
FROM
moz_bookmarks
WHERE
parent
=
:
tag_id
AND
fk
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
page_url
)
AND
url
=
:
page_url
)
)
;
stmt
.
params
.
tag_id
=
tagId
;
stmt
.
params
.
page_url
=
aURI
.
spec
;
try
{
if
(
stmt
.
executeStep
(
)
)
{
return
stmt
.
row
.
id
;
}
}
finally
{
stmt
.
finalize
(
)
;
}
return
-
1
;
}
_getItemIdForTag
:
function
TS_getItemIdForTag
(
aTagName
)
{
for
(
var
i
in
this
.
_tagFolders
)
{
if
(
aTagName
.
toLowerCase
(
)
=
=
this
.
_tagFolders
[
i
]
.
toLowerCase
(
)
)
{
return
parseInt
(
i
)
;
}
}
return
-
1
;
}
_convertInputMixedTagsArray
(
aTags
trim
=
false
)
{
return
aTags
.
filter
(
tag
=
>
tag
!
=
=
undefined
)
.
map
(
idOrName
=
>
{
let
tag
=
{
}
;
if
(
typeof
idOrName
=
=
"
number
"
&
&
this
.
_tagFolders
[
idOrName
]
)
{
tag
.
id
=
idOrName
;
tag
.
__defineGetter__
(
"
name
"
(
)
=
>
this
.
_tagFolders
[
tag
.
id
]
)
;
}
else
if
(
typeof
idOrName
=
=
"
string
"
&
&
!
!
idOrName
.
length
&
&
idOrName
.
length
<
=
PlacesUtils
.
bookmarks
.
MAX_TAG_LENGTH
)
{
tag
.
name
=
trim
?
idOrName
.
trim
(
)
:
idOrName
;
tag
.
__defineGetter__
(
"
id
"
(
)
=
>
this
.
_getItemIdForTag
(
tag
.
name
)
)
;
}
else
{
throw
Components
.
Exception
(
"
Invalid
tag
value
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
return
tag
;
}
)
;
}
tagURI
:
function
TS_tagURI
(
aURI
aTags
aSource
)
{
if
(
!
aURI
|
|
!
aTags
|
|
!
Array
.
isArray
(
aTags
)
|
|
!
aTags
.
length
)
{
throw
Components
.
Exception
(
"
Invalid
value
for
tags
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
tags
=
this
.
_convertInputMixedTagsArray
(
aTags
true
)
;
for
(
let
tag
of
tags
)
{
if
(
tag
.
id
=
=
-
1
)
{
this
.
_createTag
(
tag
.
name
aSource
)
;
}
let
itemId
=
this
.
_getItemIdForTaggedURI
(
aURI
tag
.
name
)
;
if
(
itemId
=
=
-
1
)
{
PlacesUtils
.
bookmarks
.
insertBookmark
(
tag
.
id
aURI
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
null
null
aSource
)
;
}
else
{
PlacesUtils
.
bookmarks
.
setItemLastModified
(
itemId
PlacesUtils
.
toPRTime
(
Date
.
now
(
)
)
aSource
)
;
}
if
(
PlacesUtils
.
bookmarks
.
getItemTitle
(
tag
.
id
)
!
=
tag
.
name
)
{
PlacesUtils
.
bookmarks
.
setItemTitle
(
tag
.
id
tag
.
name
aSource
)
;
}
}
}
_removeTagIfEmpty
:
function
TS__removeTagIfEmpty
(
aTagId
aSource
)
{
let
count
=
0
;
let
db
=
PlacesUtils
.
history
.
DBConnection
;
let
stmt
=
db
.
createStatement
(
SELECT
count
(
*
)
AS
count
FROM
moz_bookmarks
WHERE
parent
=
:
tag_id
)
;
stmt
.
params
.
tag_id
=
aTagId
;
try
{
if
(
stmt
.
executeStep
(
)
)
{
count
=
stmt
.
row
.
count
;
}
}
finally
{
stmt
.
finalize
(
)
;
}
if
(
count
=
=
0
)
{
PlacesUtils
.
bookmarks
.
removeItem
(
aTagId
aSource
)
;
}
}
untagURI
:
function
TS_untagURI
(
aURI
aTags
aSource
)
{
if
(
!
aURI
|
|
(
aTags
&
&
(
!
Array
.
isArray
(
aTags
)
|
|
!
aTags
.
length
)
)
)
{
throw
Components
.
Exception
(
"
Invalid
value
for
tags
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
aTags
)
{
aTags
=
this
.
getTagsForURI
(
aURI
)
;
}
let
tags
=
this
.
_convertInputMixedTagsArray
(
aTags
)
;
let
isAnyTagNotTrimmed
=
tags
.
some
(
tag
=
>
/
^
\
s
|
\
s
/
.
test
(
tag
.
name
)
)
;
if
(
isAnyTagNotTrimmed
)
{
throw
Components
.
Exception
(
"
At
least
one
tag
passed
to
untagURI
was
not
trimmed
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
for
(
let
tag
of
tags
)
{
if
(
tag
.
id
!
=
-
1
)
{
let
itemId
=
this
.
_getItemIdForTaggedURI
(
aURI
tag
.
name
)
;
if
(
itemId
!
=
-
1
)
{
PlacesUtils
.
bookmarks
.
removeItem
(
itemId
aSource
)
;
}
}
}
}
getTagsForURI
:
function
TS_getTagsForURI
(
aURI
)
{
if
(
!
aURI
)
{
throw
Components
.
Exception
(
"
Invalid
uri
"
Cr
.
NS_ERROR_INVALID_ARG
)
;
}
let
tags
=
[
]
;
let
db
=
PlacesUtils
.
history
.
DBConnection
;
let
stmt
=
db
.
createStatement
(
SELECT
t
.
id
AS
folderId
FROM
moz_bookmarks
b
JOIN
moz_bookmarks
t
on
t
.
id
=
b
.
parent
WHERE
b
.
fk
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
url
)
AND
url
=
:
url
)
AND
t
.
parent
=
:
tags_root
ORDER
BY
b
.
lastModified
DESC
b
.
id
DESC
)
;
stmt
.
params
.
url
=
aURI
.
spec
;
stmt
.
params
.
tags_root
=
PlacesUtils
.
tagsFolderId
;
try
{
while
(
stmt
.
executeStep
(
)
)
{
try
{
tags
.
push
(
this
.
_tagFolders
[
stmt
.
row
.
folderId
]
)
;
}
catch
(
ex
)
{
}
}
}
finally
{
stmt
.
finalize
(
)
;
}
tags
.
sort
(
function
(
a
b
)
{
return
a
.
toLowerCase
(
)
.
localeCompare
(
b
.
toLowerCase
(
)
)
;
}
)
;
return
tags
;
}
__tagFolders
:
null
get
_tagFolders
(
)
{
if
(
!
this
.
__tagFolders
)
{
this
.
__tagFolders
=
[
]
;
let
db
=
PlacesUtils
.
history
.
DBConnection
;
let
stmt
=
db
.
createStatement
(
"
SELECT
id
title
FROM
moz_bookmarks
WHERE
parent
=
:
tags_root
"
)
;
stmt
.
params
.
tags_root
=
PlacesUtils
.
tagsFolderId
;
try
{
while
(
stmt
.
executeStep
(
)
)
{
this
.
__tagFolders
[
stmt
.
row
.
id
]
=
stmt
.
row
.
title
;
}
}
finally
{
stmt
.
finalize
(
)
;
}
}
return
this
.
__tagFolders
;
}
observe
:
function
TS_observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
TOPIC_SHUTDOWN
)
{
PlacesUtils
.
bookmarks
.
removeObserver
(
this
)
;
PlacesUtils
.
observers
.
removeListener
(
[
"
bookmark
-
added
"
"
bookmark
-
removed
"
]
this
.
handlePlacesEvents
)
;
Services
.
obs
.
removeObserver
(
this
TOPIC_SHUTDOWN
)
;
}
}
_getTaggedItemIdsIfUnbookmarkedURI
:
function
TS__getTaggedItemIdsIfUnbookmarkedURI
(
url
)
{
var
itemIds
=
[
]
;
var
isBookmarked
=
false
;
let
db
=
PlacesUtils
.
history
.
DBConnection
;
let
stmt
=
db
.
createStatement
(
SELECT
id
parent
FROM
moz_bookmarks
WHERE
fk
=
(
SELECT
id
FROM
moz_places
WHERE
url_hash
=
hash
(
:
page_url
)
AND
url
=
:
page_url
)
)
;
stmt
.
params
.
page_url
=
url
;
try
{
while
(
stmt
.
executeStep
(
)
&
&
!
isBookmarked
)
{
if
(
this
.
_tagFolders
[
stmt
.
row
.
parent
]
)
{
itemIds
.
push
(
stmt
.
row
.
id
)
;
}
else
{
isBookmarked
=
true
;
}
}
}
finally
{
stmt
.
finalize
(
)
;
}
return
isBookmarked
?
[
]
:
itemIds
;
}
handlePlacesEvents
(
events
)
{
for
(
let
event
of
events
)
{
switch
(
event
.
type
)
{
case
"
bookmark
-
added
"
:
if
(
!
event
.
isTagging
|
|
event
.
itemType
!
=
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
)
{
continue
;
}
this
.
_tagFolders
[
event
.
id
]
=
event
.
title
;
break
;
case
"
bookmark
-
removed
"
:
if
(
event
.
parentId
=
=
PlacesUtils
.
tagsFolderId
&
&
this
.
_tagFolders
[
event
.
id
]
)
{
delete
this
.
_tagFolders
[
event
.
id
]
;
break
;
}
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
if
(
event
.
url
&
&
!
this
.
_tagFolders
[
event
.
parentId
]
)
{
let
itemIds
=
this
.
_getTaggedItemIdsIfUnbookmarkedURI
(
event
.
url
)
;
for
(
let
i
=
0
;
i
<
itemIds
.
length
;
i
+
+
)
{
try
{
PlacesUtils
.
bookmarks
.
removeItem
(
itemIds
[
i
]
event
.
source
)
;
}
catch
(
ex
)
{
}
}
}
else
if
(
event
.
url
&
&
this
.
_tagFolders
[
event
.
parentId
]
)
{
this
.
_removeTagIfEmpty
(
event
.
parentId
event
.
source
)
;
}
}
)
;
break
;
}
}
}
onItemChanged
:
function
TS_onItemChanged
(
aItemId
aProperty
aIsAnnotationProperty
aNewValue
aLastModified
aItemType
)
{
if
(
aProperty
=
=
"
title
"
&
&
this
.
_tagFolders
[
aItemId
]
)
{
this
.
_tagFolders
[
aItemId
]
=
aNewValue
;
}
}
onItemMoved
:
function
TS_onItemMoved
(
aItemId
aOldParent
aOldIndex
aNewParent
aNewIndex
aItemType
)
{
if
(
this
.
_tagFolders
[
aItemId
]
&
&
PlacesUtils
.
tagsFolderId
=
=
aOldParent
&
&
PlacesUtils
.
tagsFolderId
!
=
aNewParent
)
{
delete
this
.
_tagFolders
[
aItemId
]
;
}
}
onItemVisited
(
)
{
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
classID
:
Components
.
ID
(
"
{
bbc23860
-
2553
-
479d
-
8b78
-
94d9038334f7
}
"
)
_xpcom_factory
:
XPCOMUtils
.
generateSingletonFactory
(
TaggingService
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsITaggingService
"
"
nsINavBookmarkObserver
"
"
nsIObserver
"
]
)
}
;
class
TagSearch
{
constructor
(
searchString
autocompleteSearch
listener
)
{
this
.
_result
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
simple
-
result
;
1
"
]
.
createInstance
(
Ci
.
nsIAutoCompleteSimpleResult
)
;
this
.
_result
.
setDefaultIndex
(
0
)
;
this
.
_result
.
setSearchString
(
searchString
)
;
this
.
_autocompleteSearch
=
autocompleteSearch
;
this
.
_listener
=
listener
;
}
async
start
(
)
{
if
(
this
.
_canceled
)
{
throw
new
Error
(
"
Can
'
t
restart
a
canceled
search
"
)
;
}
let
searchString
=
this
.
_result
.
searchString
;
let
index
=
Math
.
max
(
searchString
.
lastIndexOf
(
"
"
)
searchString
.
lastIndexOf
(
"
;
"
)
)
;
let
before
=
"
"
;
if
(
index
!
=
-
1
)
{
before
=
searchString
.
slice
(
0
index
+
1
)
;
searchString
=
searchString
.
slice
(
index
+
1
)
;
var
m
=
searchString
.
match
(
/
\
s
+
/
)
;
if
(
m
)
{
before
+
=
m
[
0
]
;
searchString
=
searchString
.
slice
(
m
[
0
]
.
length
)
;
}
}
if
(
searchString
.
length
)
{
let
tags
=
await
PlacesUtils
.
bookmarks
.
fetchTags
(
)
;
if
(
this
.
_canceled
)
{
return
;
}
let
lcSearchString
=
searchString
.
toLowerCase
(
)
;
let
matchingTags
=
tags
.
filter
(
t
=
>
t
.
name
.
toLowerCase
(
)
.
startsWith
(
lcSearchString
)
)
.
map
(
t
=
>
t
.
name
)
;
for
(
let
i
=
0
;
i
<
matchingTags
.
length
;
+
+
i
)
{
let
tag
=
matchingTags
[
i
]
;
this
.
_result
.
appendMatch
(
before
+
tag
tag
)
;
if
(
i
%
10
=
=
0
)
{
this
.
_notifyResult
(
true
)
;
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
if
(
this
.
_canceled
)
{
return
;
}
}
}
}
this
.
_notifyResult
(
false
)
;
}
cancel
(
)
{
this
.
_canceled
=
true
;
}
_notifyResult
(
searchOngoing
)
{
let
resultCode
=
this
.
_result
.
matchCount
?
"
RESULT_SUCCESS
"
:
"
RESULT_NOMATCH
"
;
if
(
searchOngoing
)
{
resultCode
+
=
"
_ONGOING
"
;
}
this
.
_result
.
setSearchResult
(
Ci
.
nsIAutoCompleteResult
[
resultCode
]
)
;
this
.
_listener
.
onSearchResult
(
this
.
_autocompleteSearch
this
.
_result
)
;
}
}
function
TagAutoCompleteSearch
(
)
{
}
TagAutoCompleteSearch
.
prototype
=
{
startSearch
(
searchString
searchParam
previousResult
listener
)
{
if
(
this
.
_search
)
{
this
.
_search
.
cancel
(
)
;
}
this
.
_search
=
new
TagSearch
(
searchString
this
listener
)
;
this
.
_search
.
start
(
)
.
catch
(
Cu
.
reportError
)
;
}
stopSearch
(
)
{
this
.
_search
.
cancel
(
)
;
this
.
_search
=
null
;
}
classID
:
Components
.
ID
(
"
{
1dcc23b0
-
d4cb
-
11dc
-
9ad6
-
479d56d89593
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIAutoCompleteSearch
"
]
)
}
;
var
EXPORTED_SYMBOLS
=
[
"
TaggingService
"
"
TagAutoCompleteSearch
"
]
;
