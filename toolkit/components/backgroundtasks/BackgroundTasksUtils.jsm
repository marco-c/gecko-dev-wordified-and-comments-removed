var
EXPORTED_SYMBOLS
=
[
"
BackgroundTasksUtils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
let
consoleOptions
=
{
maxLogLevel
:
"
error
"
maxLogLevelPref
:
"
toolkit
.
backgroundtasks
.
loglevel
"
prefix
:
"
BackgroundTasksUtils
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
ProfileService
"
"
mozilla
.
org
/
toolkit
/
profile
-
service
;
1
"
"
nsIToolkitProfileService
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ASRouter
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouter
.
jsm
"
ASRouterDefaultConfig
:
"
resource
:
/
/
activity
-
stream
/
lib
/
ASRouterDefaultConfig
.
jsm
"
ExperimentManager
:
"
resource
:
/
/
nimbus
/
lib
/
ExperimentManager
.
jsm
"
RemoteSettingsExperimentLoader
:
"
resource
:
/
/
nimbus
/
lib
/
RemoteSettingsExperimentLoader
.
jsm
"
}
)
;
class
CannotLockProfileError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
CannotLockProfileError
"
;
}
}
var
BackgroundTasksUtils
=
{
_defaultProfileInitialized
:
false
_defaultProfile
:
null
getDefaultProfile
(
)
{
if
(
!
this
.
_defaultProfileInitialized
)
{
this
.
_defaultProfileInitialized
=
true
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
defaultProfilePath
=
env
.
get
(
"
MOZ_BACKGROUNDTASKS_DEFAULT_PROFILE_PATH
"
)
;
let
noDefaultProfile
=
env
.
get
(
"
MOZ_BACKGROUNDTASKS_NO_DEFAULT_PROFILE
"
)
;
if
(
defaultProfilePath
)
{
lazy
.
log
.
info
(
getDefaultProfile
:
using
default
profile
path
{
defaultProfilePath
}
)
;
var
tmpd
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
tmpd
.
initWithPath
(
defaultProfilePath
)
;
this
.
_defaultProfile
=
lazy
.
ProfileService
.
createProfile
(
tmpd
MOZ_BACKGROUNDTASKS_DEFAULT_PROFILE_PATH
-
{
Date
.
now
(
)
}
)
;
}
else
if
(
noDefaultProfile
)
{
lazy
.
log
.
info
(
getDefaultProfile
:
setting
default
profile
to
null
)
;
this
.
_defaultProfile
=
null
;
}
else
{
try
{
lazy
.
log
.
info
(
getDefaultProfile
:
using
ProfileService
.
defaultProfile
)
;
this
.
_defaultProfile
=
lazy
.
ProfileService
.
defaultProfile
;
}
catch
(
e
)
{
}
}
}
return
this
.
_defaultProfile
;
}
hasDefaultProfile
(
)
{
return
this
.
getDefaultProfile
(
)
!
=
null
;
}
currentProfileIsDefaultProfile
(
)
{
let
defaultProfile
=
this
.
getDefaultProfile
(
)
;
let
currentProfile
=
lazy
.
ProfileService
.
currentProfile
;
let
isDefaultProfile
=
defaultProfile
&
&
currentProfile
=
=
defaultProfile
;
return
isDefaultProfile
;
}
_throwIfNotLocked
(
lock
)
{
if
(
!
(
lock
instanceof
Ci
.
nsIProfileLock
)
)
{
throw
new
Error
(
"
Passed
lock
was
not
an
instance
of
nsIProfileLock
"
)
;
}
try
{
if
(
lock
.
directory
)
{
return
;
}
}
catch
(
e
)
{
if
(
!
(
e
instanceof
Ci
.
nsIException
&
&
e
.
result
=
=
Cr
.
NS_ERROR_NOT_INITIALIZED
)
)
{
throw
e
;
}
}
throw
new
Error
(
"
Profile
is
not
locked
"
)
;
}
async
withProfileLock
(
callback
profile
=
this
.
getDefaultProfile
(
)
)
{
if
(
!
profile
)
{
throw
new
Error
(
"
No
default
profile
exists
"
)
;
}
let
lock
;
try
{
lock
=
profile
.
lock
(
{
}
)
;
lazy
.
log
.
info
(
withProfileLock
:
locked
profile
at
{
lock
.
directory
.
path
}
)
;
}
catch
(
e
)
{
throw
new
CannotLockProfileError
(
Cannot
lock
profile
:
{
e
}
)
;
}
try
{
return
await
callback
(
lock
)
;
}
finally
{
try
{
lazy
.
log
.
info
(
withProfileLock
:
unlocking
profile
at
{
lock
.
directory
.
path
}
)
;
lock
.
unlock
(
)
;
lazy
.
log
.
info
(
withProfileLock
:
unlocked
profile
)
;
}
catch
(
e
)
{
lazy
.
log
.
warn
(
withProfileLock
:
error
unlocking
profile
e
)
;
}
}
}
async
readPreferences
(
predicate
=
null
lock
=
null
)
{
if
(
!
lock
)
{
return
this
.
withProfileLock
(
profileLock
=
>
this
.
readPreferences
(
predicate
profileLock
)
)
;
}
this
.
_throwIfNotLocked
(
lock
)
;
lazy
.
log
.
info
(
readPreferences
:
profile
is
locked
)
;
let
prefs
=
{
}
;
let
addPref
=
(
kind
name
value
sticky
locked
)
=
>
{
if
(
predicate
&
&
!
predicate
(
name
)
)
{
return
;
}
prefs
[
name
]
=
value
;
}
;
let
prefsFile
=
lock
.
directory
.
clone
(
)
;
prefsFile
.
append
(
"
prefs
.
js
"
)
;
lazy
.
log
.
info
(
readPreferences
:
will
parse
prefs
{
prefsFile
.
path
}
)
;
let
data
=
await
IOUtils
.
read
(
prefsFile
.
path
)
;
lazy
.
log
.
debug
(
readPreferences
:
parsing
prefs
from
buffer
of
length
{
data
.
length
}
)
;
Services
.
prefs
.
parsePrefsFromBuffer
(
data
{
onStringPref
:
addPref
onIntPref
:
addPref
onBoolPref
:
addPref
onError
(
message
)
{
lazy
.
log
.
error
(
message
)
;
}
}
prefsFile
.
path
)
;
lazy
.
log
.
debug
(
readPreferences
:
parsed
prefs
from
buffer
prefs
)
;
return
prefs
;
}
async
readFirefoxMessagingSystemTargetingSnapshot
(
lock
=
null
)
{
if
(
!
lock
)
{
return
this
.
withProfileLock
(
profileLock
=
>
this
.
readFirefoxMessagingSystemTargetingSnapshot
(
profileLock
)
)
;
}
this
.
_throwIfNotLocked
(
lock
)
;
let
snapshotFile
=
lock
.
directory
.
clone
(
)
;
snapshotFile
.
append
(
"
targeting
.
snapshot
.
json
"
)
;
lazy
.
log
.
info
(
readFirefoxMessagingSystemTargetingSnapshot
:
will
read
Firefox
Messaging
+
System
targeting
snapshot
from
{
snapshotFile
.
path
}
)
;
return
IOUtils
.
readJSON
(
snapshotFile
.
path
)
;
}
async
readTelemetryClientID
(
lock
=
null
)
{
if
(
!
lock
)
{
return
this
.
withProfileLock
(
profileLock
=
>
this
.
readTelemetryClientID
(
profileLock
)
)
;
}
this
.
_throwIfNotLocked
(
lock
)
;
let
stateFile
=
lock
.
directory
.
clone
(
)
;
stateFile
.
append
(
"
datareporting
"
)
;
stateFile
.
append
(
"
state
.
json
"
)
;
lazy
.
log
.
info
(
readPreferences
:
will
read
Telemetry
client
ID
from
{
stateFile
.
path
}
)
;
let
state
=
await
IOUtils
.
readJSON
(
stateFile
.
path
)
;
return
state
.
clientID
;
}
async
enableNimbus
(
commandLine
defaultProfile
=
{
}
)
{
try
{
await
lazy
.
ExperimentManager
.
onStartup
(
{
defaultProfile
}
)
;
}
catch
(
err
)
{
lazy
.
log
.
error
(
"
Failed
to
initialize
ExperimentManager
:
"
err
)
;
throw
err
;
}
try
{
await
lazy
.
RemoteSettingsExperimentLoader
.
init
(
)
;
}
catch
(
err
)
{
lazy
.
log
.
error
(
"
Failed
to
initialize
RemoteSettingsExperimentLoader
:
"
err
)
;
throw
err
;
}
let
ar
;
while
(
(
ar
=
commandLine
?
.
handleFlagWithParam
(
"
url
"
false
)
)
)
{
let
uri
=
commandLine
.
resolveURI
(
ar
)
;
const
params
=
new
URLSearchParams
(
uri
.
query
)
;
if
(
uri
.
schemeIs
(
"
about
"
)
&
&
uri
.
filePath
=
=
"
studies
"
)
{
Services
.
prefs
.
setBoolPref
(
"
nimbus
.
debug
"
true
)
;
const
data
=
{
slug
:
params
.
get
(
"
optin_slug
"
)
branch
:
params
.
get
(
"
optin_branch
"
)
collection
:
params
.
get
(
"
optin_collection
"
)
}
;
await
lazy
.
RemoteSettingsExperimentLoader
.
optInToExperiment
(
data
)
;
lazy
.
log
.
info
(
Opted
in
to
experiment
:
{
JSON
.
stringify
(
data
)
}
)
;
}
if
(
uri
.
schemeIs
(
"
file
"
)
)
{
let
branchSlug
=
params
.
get
(
"
optin_branch
"
)
;
let
path
=
decodeURIComponent
(
uri
.
filePath
)
;
let
response
=
await
fetch
(
uri
.
spec
)
;
let
recipe
=
await
response
.
json
(
)
;
if
(
recipe
.
permissions
)
{
recipe
=
recipe
.
data
;
}
let
branch
=
recipe
.
branches
.
find
(
b
=
>
b
.
slug
=
=
branchSlug
)
;
lazy
.
ExperimentManager
.
forceEnroll
(
recipe
branch
)
;
lazy
.
log
.
info
(
Forced
enrollment
into
:
{
path
}
branch
:
{
branchSlug
}
)
;
}
}
}
async
enableFirefoxMessagingSystem
(
defaultProfile
=
{
}
)
{
function
logArgs
(
tag
.
.
.
args
)
{
lazy
.
log
.
debug
(
FxMS
invoked
{
tag
}
:
{
JSON
.
stringify
(
args
)
}
)
;
}
let
{
messageHandler
router
createStorage
}
=
lazy
.
ASRouterDefaultConfig
(
)
;
if
(
!
router
.
initialized
)
{
const
storage
=
await
createStorage
(
)
;
await
router
.
init
(
{
storage
sendTelemetry
:
logArgs
.
bind
(
null
"
sendTelemetry
"
)
dispatchCFRAction
:
messageHandler
.
handleCFRAction
.
bind
(
messageHandler
)
clearChildMessages
:
logArgs
.
bind
(
null
"
clearChildMessages
"
)
clearChildProviders
:
logArgs
.
bind
(
null
"
clearChildProviders
"
)
updateAdminState
:
(
)
=
>
{
}
}
)
;
}
await
lazy
.
ASRouter
.
waitForInitialized
;
const
triggerId
=
"
backgroundTask
"
;
await
lazy
.
ASRouter
.
sendTriggerMessage
(
{
browser
:
null
id
:
triggerId
context
:
{
defaultProfile
}
}
)
;
lazy
.
log
.
info
(
"
Triggered
Firefox
Messaging
System
with
trigger
id
'
backgroundTask
'
"
)
;
}
}
;
