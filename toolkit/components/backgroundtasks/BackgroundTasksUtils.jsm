var
EXPORTED_SYMBOLS
=
[
"
BackgroundTasksUtils
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
ConsoleAPI
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
let
consoleOptions
=
{
maxLogLevel
:
"
error
"
maxLogLevelPref
:
"
toolkit
.
backgroundtasks
.
loglevel
"
prefix
:
"
BackgroundTasksUtils
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
ProfileService
"
"
mozilla
.
org
/
toolkit
/
profile
-
service
;
1
"
"
nsIToolkitProfileService
"
)
;
class
CannotLockProfileError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
CannotLockProfileError
"
;
}
}
var
BackgroundTasksUtils
=
{
_defaultProfileInitialized
:
false
_defaultProfile
:
null
getDefaultProfile
(
)
{
if
(
!
this
.
_defaultProfileInitialized
)
{
this
.
_defaultProfileInitialized
=
true
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
defaultProfilePath
=
env
.
get
(
"
MOZ_BACKGROUNDTASKS_DEFAULT_PROFILE_PATH
"
)
;
let
noDefaultProfile
=
env
.
get
(
"
MOZ_BACKGROUNDTASKS_NO_DEFAULT_PROFILE
"
)
;
if
(
defaultProfilePath
)
{
log
.
info
(
getDefaultProfile
:
using
default
profile
path
{
defaultProfilePath
}
)
;
var
tmpd
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
tmpd
.
initWithPath
(
defaultProfilePath
)
;
this
.
_defaultProfile
=
ProfileService
.
createProfile
(
tmpd
MOZ_BACKGROUNDTASKS_DEFAULT_PROFILE_PATH
-
{
Date
.
now
(
)
}
)
;
}
else
if
(
noDefaultProfile
)
{
log
.
info
(
getDefaultProfile
:
setting
default
profile
to
null
)
;
this
.
_defaultProfile
=
null
;
}
else
{
try
{
log
.
info
(
getDefaultProfile
:
using
ProfileService
.
defaultProfile
)
;
this
.
_defaultProfile
=
ProfileService
.
defaultProfile
;
}
catch
(
e
)
{
}
}
}
return
this
.
_defaultProfile
;
}
hasDefaultProfile
(
)
{
return
this
.
getDefaultProfile
(
)
!
=
null
;
}
currentProfileIsDefaultProfile
(
)
{
let
defaultProfile
=
this
.
getDefaultProfile
(
)
;
let
currentProfile
=
ProfileService
.
currentProfile
;
let
isDefaultProfile
=
defaultProfile
&
&
currentProfile
=
=
defaultProfile
;
return
isDefaultProfile
;
}
_throwIfNotLocked
(
lock
)
{
if
(
!
(
lock
instanceof
Ci
.
nsIProfileLock
)
)
{
throw
new
Error
(
"
Passed
lock
was
not
an
instance
of
nsIProfileLock
"
)
;
}
try
{
if
(
lock
.
directory
)
{
return
;
}
}
catch
(
e
)
{
if
(
!
(
e
instanceof
Ci
.
nsIException
&
&
e
.
result
=
=
Cr
.
NS_ERROR_NOT_INITIALIZED
)
)
{
throw
e
;
}
}
throw
new
Error
(
"
Profile
is
not
locked
"
)
;
}
async
withProfileLock
(
callback
profile
=
this
.
getDefaultProfile
(
)
)
{
if
(
!
profile
)
{
throw
new
Error
(
"
No
default
profile
exists
"
)
;
}
let
lock
;
try
{
lock
=
profile
.
lock
(
{
}
)
;
log
.
info
(
withProfileLock
:
locked
profile
at
{
lock
.
directory
.
path
}
)
;
}
catch
(
e
)
{
throw
new
CannotLockProfileError
(
Cannot
lock
profile
:
{
e
}
)
;
}
try
{
return
await
callback
(
lock
)
;
}
finally
{
try
{
log
.
info
(
withProfileLock
:
unlocking
profile
at
{
lock
.
directory
.
path
}
)
;
lock
.
unlock
(
)
;
log
.
info
(
withProfileLock
:
unlocked
profile
)
;
}
catch
(
e
)
{
log
.
warn
(
withProfileLock
:
error
unlocking
profile
e
)
;
}
}
}
async
readPreferences
(
predicate
=
null
lock
=
null
)
{
if
(
!
lock
)
{
return
this
.
withProfileLock
(
profileLock
=
>
this
.
readPreferences
(
predicate
profileLock
)
)
;
}
this
.
_throwIfNotLocked
(
lock
)
;
log
.
info
(
readPreferences
:
profile
is
locked
)
;
let
prefs
=
{
}
;
let
addPref
=
(
kind
name
value
sticky
locked
)
=
>
{
if
(
predicate
&
&
!
predicate
(
name
)
)
{
return
;
}
prefs
[
name
]
=
value
;
}
;
let
prefsFile
=
lock
.
directory
.
clone
(
)
;
prefsFile
.
append
(
"
prefs
.
js
"
)
;
log
.
info
(
readPreferences
:
will
parse
prefs
{
prefsFile
.
path
}
)
;
let
data
=
await
IOUtils
.
read
(
prefsFile
.
path
)
;
log
.
debug
(
readPreferences
:
parsing
prefs
from
buffer
of
length
{
data
.
length
}
)
;
Services
.
prefs
.
parsePrefsFromBuffer
(
data
{
onStringPref
:
addPref
onIntPref
:
addPref
onBoolPref
:
addPref
onError
(
message
)
{
log
.
error
(
message
)
;
}
}
prefsFile
.
path
)
;
log
.
debug
(
readPreferences
:
parsed
prefs
from
buffer
prefs
)
;
return
prefs
;
}
async
readTelemetryClientID
(
lock
=
null
)
{
if
(
!
lock
)
{
return
this
.
withProfileLock
(
profileLock
=
>
this
.
readTelemetryClientID
(
profileLock
)
)
;
}
this
.
_throwIfNotLocked
(
lock
)
;
let
stateFile
=
lock
.
directory
.
clone
(
)
;
stateFile
.
append
(
"
datareporting
"
)
;
stateFile
.
append
(
"
state
.
json
"
)
;
log
.
info
(
readPreferences
:
will
read
Telemetry
client
ID
from
{
stateFile
.
path
}
)
;
let
data
=
await
IOUtils
.
readUTF8
(
stateFile
.
path
)
;
let
state
=
JSON
.
parse
(
data
)
;
return
state
.
clientID
;
}
}
;
