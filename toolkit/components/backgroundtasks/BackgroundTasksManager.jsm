var
EXPORTED_SYMBOLS
=
[
"
BackgroundTasksManager
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
let
ConsoleAPI
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
.
ConsoleAPI
;
let
consoleOptions
=
{
maxLogLevel
:
"
error
"
maxLogLevelPref
:
"
toolkit
.
backgroundtasks
.
loglevel
"
prefix
:
"
BackgroundTasksManager
"
}
;
return
new
ConsoleAPI
(
consoleOptions
)
;
}
)
;
function
registerModulesProtocolHandler
(
)
{
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
_TESTING_MODULES_URI
=
env
.
get
(
"
XPCSHELL_TESTING_MODULES_URI
"
"
"
)
;
if
(
!
_TESTING_MODULES_URI
)
{
return
false
;
}
let
protocolHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
protocolHandler
.
setSubstitution
(
"
testing
-
common
"
Services
.
io
.
newURI
(
_TESTING_MODULES_URI
)
)
;
log
.
error
(
Substitution
set
:
resource
:
/
/
testing
-
common
aliases
{
_TESTING_MODULES_URI
}
)
;
return
true
;
}
function
locationsForBackgroundTaskNamed
(
name
)
{
const
subModules
=
[
"
resource
:
/
/
/
modules
"
"
resource
:
/
/
gre
/
modules
"
]
;
if
(
registerModulesProtocolHandler
(
)
)
{
subModules
.
push
(
"
resource
:
/
/
testing
-
common
"
)
;
}
let
locations
=
[
]
;
for
(
const
subModule
of
subModules
)
{
let
URI
=
{
subModule
}
/
backgroundtasks
/
BackgroundTask_
{
name
}
.
jsm
;
locations
.
push
(
URI
)
;
}
return
locations
;
}
function
findBackgroundTaskModule
(
name
)
{
for
(
const
URI
of
locationsForBackgroundTaskNamed
(
name
)
)
{
log
.
debug
(
Looking
for
background
task
at
URI
:
{
URI
}
)
;
try
{
const
taskModule
=
ChromeUtils
.
import
(
URI
)
;
log
.
info
(
Found
background
task
at
URI
:
{
URI
}
)
;
return
taskModule
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
throw
ex
;
}
}
}
log
.
warn
(
No
backgroundtask
named
'
{
name
}
'
registered
)
;
throw
new
Components
.
Exception
(
No
backgroundtask
named
'
{
name
}
'
registered
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
class
BackgroundTasksManager
{
helpInfo
=
"
-
-
jsdebugger
[
<
path
>
]
Open
the
Browser
Toolbox
.
Defaults
to
the
local
build
\
n
"
+
"
but
can
be
overridden
by
a
firefox
path
.
\
n
"
+
"
-
-
wait
-
for
-
jsdebugger
Spin
event
loop
until
JS
debugger
connects
.
\
n
"
+
"
Enables
debugging
(
some
)
application
startup
code
paths
.
\
n
"
+
"
Only
has
an
effect
when
-
-
jsdebugger
is
also
supplied
.
\
n
"
+
"
-
-
start
-
debugger
-
server
[
ws
:
]
[
<
port
>
|
<
path
>
]
Start
the
devtools
server
on
\
n
"
+
"
a
TCP
port
or
Unix
domain
socket
path
.
Defaults
to
TCP
port
\
n
"
+
"
6000
.
Use
WebSocket
protocol
if
ws
:
prefix
is
specified
.
\
n
"
;
handle
(
commandLine
)
{
const
bts
=
Cc
[
"
mozilla
.
org
/
backgroundtasks
;
1
"
]
.
getService
(
Ci
.
nsIBackgroundTasks
)
;
if
(
!
bts
.
isBackgroundTaskMode
)
{
log
.
info
(
{
Services
.
appinfo
.
processID
}
:
!
isBackgroundTaskMode
exiting
)
;
return
;
}
const
name
=
bts
.
backgroundTaskName
(
)
;
log
.
info
(
{
Services
.
appinfo
.
processID
}
:
Preparing
to
run
background
task
named
'
{
name
}
'
+
(
with
{
commandLine
.
length
}
arguments
)
)
;
if
(
!
(
"
mozilla
.
org
/
devtools
/
startup
-
clh
;
1
"
in
Cc
)
)
{
return
;
}
const
CASE_INSENSITIVE
=
false
;
if
(
commandLine
.
findFlag
(
"
jsdebugger
"
CASE_INSENSITIVE
)
<
0
&
&
commandLine
.
findFlag
(
"
start
-
debugger
-
server
"
CASE_INSENSITIVE
)
<
0
)
{
log
.
info
(
{
Services
.
appinfo
.
processID
}
:
No
devtools
flag
found
;
not
preparing
devtools
thread
)
;
return
;
}
const
waitFlag
=
commandLine
.
findFlag
(
"
wait
-
for
-
jsdebugger
"
CASE_INSENSITIVE
)
!
=
-
1
;
if
(
waitFlag
)
{
function
onDevtoolsThreadReady
(
subject
topic
data
)
{
log
.
info
(
{
Services
.
appinfo
.
processID
}
:
Setting
breakpoints
for
background
task
named
'
{
name
}
'
+
(
with
{
commandLine
.
length
}
arguments
)
)
;
const
threadActor
=
subject
.
wrappedJSObject
;
threadActor
.
setBreakpointOnLoad
(
locationsForBackgroundTaskNamed
(
name
)
)
;
Services
.
obs
.
removeObserver
(
onDevtoolsThreadReady
topic
)
;
}
Services
.
obs
.
addObserver
(
onDevtoolsThreadReady
"
devtools
-
thread
-
ready
"
)
;
}
const
DevToolsStartup
=
Cc
[
"
mozilla
.
org
/
devtools
/
startup
-
clh
;
1
"
]
.
getService
(
Ci
.
nsICommandLineHandler
)
;
DevToolsStartup
.
handle
(
commandLine
)
;
}
async
runBackgroundTaskNamed
(
name
commandLine
)
{
function
addMarker
(
markerName
)
{
return
ChromeUtils
.
addProfilerMarker
(
markerName
undefined
name
)
;
}
addMarker
(
"
BackgroundTasksManager
:
AfterRunBackgroundTaskNamed
"
)
;
log
.
info
(
{
Services
.
appinfo
.
processID
}
:
Running
background
task
named
'
{
name
}
'
+
(
with
{
commandLine
.
length
}
arguments
)
)
;
let
exitCode
=
BackgroundTasksManager
.
EXIT_CODE
.
NOT_FOUND
;
try
{
let
taskModule
=
findBackgroundTaskModule
(
name
)
;
addMarker
(
"
BackgroundTasksManager
:
AfterFindRunBackgroundTask
"
)
;
let
timeoutSec
=
Services
.
prefs
.
getIntPref
(
"
toolkit
.
backgroundtasks
.
defaultTimeoutSec
"
10
*
60
)
;
if
(
taskModule
.
backgroundTaskTimeoutSec
)
{
timeoutSec
=
taskModule
.
backgroundTaskTimeoutSec
;
}
try
{
exitCode
=
await
Promise
.
race
(
[
new
Promise
(
resolve
=
>
setTimeout
(
(
)
=
>
{
log
.
error
(
Background
task
named
'
{
name
}
'
timed
out
)
;
resolve
(
BackgroundTasksManager
.
EXIT_CODE
.
TIMEOUT
)
;
}
timeoutSec
*
1000
)
)
taskModule
.
runBackgroundTask
(
commandLine
)
]
)
;
log
.
info
(
Backgroundtask
named
'
{
name
}
'
completed
with
exit
code
{
exitCode
}
)
;
}
catch
(
e
)
{
log
.
error
(
Backgroundtask
named
'
{
name
}
'
threw
exception
e
)
;
exitCode
=
BackgroundTasksManager
.
EXIT_CODE
.
EXCEPTION
;
}
}
finally
{
addMarker
(
"
BackgroundTasksManager
:
AfterAwaitRunBackgroundTask
"
)
;
log
.
info
(
Invoking
Services
.
startup
.
quit
(
.
.
.
{
exitCode
}
)
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eForceQuit
exitCode
)
;
}
return
exitCode
;
}
classID
=
Components
.
ID
(
"
{
4d48c536
-
e16f
-
4699
-
8f9c
-
add4f28f92f0
}
"
)
;
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIBackgroundTasksManager
"
"
nsICommandLineHandler
"
]
)
;
}
BackgroundTasksManager
.
EXIT_CODE
=
{
SUCCESS
:
0
NOT_FOUND
:
2
EXCEPTION
:
3
TIMEOUT
:
4
LAST_RESERVED
:
10
}
;
