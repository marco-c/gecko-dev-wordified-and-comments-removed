const
{
ASRouterTargeting
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
/
modules
/
asrouter
/
ASRouterTargeting
.
sys
.
mjs
"
)
;
const
{
ExperimentFakes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
NimbusTestUtils
.
sys
.
mjs
"
)
;
const
BRANCH_MAP
=
{
"
treatment
-
a
"
:
{
randomizationId
:
"
d0e95fc3
-
fb15
-
4bc4
-
8151
-
a89582a56e29
"
title
:
"
Treatment
A
"
text
:
"
Body
A
"
}
"
treatment
-
b
"
:
{
randomizationId
:
"
90a60347
-
66cc
-
4716
-
9fef
-
cf49dd992d51
"
title
:
"
Treatment
B
"
text
:
"
Body
B
"
}
}
;
setupProfileService
(
)
;
let
taskProfile
;
let
manager
;
add_setup
(
async
(
)
=
>
{
info
(
"
Setting
up
profile
service
"
)
;
let
profileService
=
Cc
[
"
mozilla
.
org
/
toolkit
/
profile
-
service
;
1
"
]
.
getService
(
Ci
.
nsIToolkitProfileService
)
;
let
taskProfD
=
do_get_profile
(
)
;
taskProfD
.
append
(
"
test_backgroundtask_experiments_task
"
)
;
taskProfile
=
profileService
.
createUniqueProfile
(
taskProfD
"
test_backgroundtask_experiments_task
"
)
;
registerCleanupFunction
(
(
)
=
>
{
taskProfile
.
remove
(
true
)
;
}
)
;
manager
=
ExperimentFakes
.
manager
(
)
;
await
manager
.
onStartup
(
)
;
await
manager
.
store
.
addEnrollment
(
ExperimentFakes
.
experiment
(
"
foo
"
)
)
;
manager
.
unenroll
(
"
foo
"
"
some
-
reason
"
)
;
await
manager
.
store
.
addEnrollment
(
ExperimentFakes
.
experiment
(
"
bar
"
{
active
:
false
}
)
)
;
await
manager
.
store
.
addEnrollment
(
ExperimentFakes
.
experiment
(
"
baz
"
{
active
:
true
}
)
)
;
manager
.
store
.
addEnrollment
(
ExperimentFakes
.
rollout
(
"
rol1
"
)
)
;
manager
.
unenroll
(
"
rol1
"
"
some
-
reason
"
)
;
manager
.
store
.
addEnrollment
(
ExperimentFakes
.
rollout
(
"
rol2
"
)
)
;
}
)
;
function
resetProfile
(
profile
)
{
profile
.
rootDir
.
remove
(
true
)
;
profile
.
rootDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o700
)
;
info
(
Reset
profile
'
{
profile
.
rootDir
.
path
}
'
)
;
}
async
function
doMessage
(
{
extraArgs
=
[
]
extraEnv
=
{
}
}
=
{
}
)
{
let
sentinel
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
;
sentinel
=
sentinel
.
substring
(
1
sentinel
.
length
-
1
)
;
let
infoArray
=
[
]
;
let
exitCode
=
await
do_backgroundtask
(
"
message
"
{
extraArgs
:
[
"
-
-
sentinel
"
sentinel
"
-
-
profile
"
taskProfile
.
rootDir
.
path
"
-
-
disable
-
alerts
-
service
"
"
-
-
no
-
experiments
"
.
.
.
extraArgs
]
extraEnv
:
{
MOZ_LOG
:
"
Dump
:
5
BackgroundTasks
:
5
"
.
.
.
extraEnv
}
onStdoutLine
:
line
=
>
{
if
(
line
.
includes
(
sentinel
)
)
{
let
info
=
JSON
.
parse
(
line
.
split
(
sentinel
)
[
1
]
)
;
infoArray
.
push
(
info
)
;
}
}
}
)
;
Assert
.
equal
(
0
exitCode
"
The
message
background
task
exited
with
exit
code
0
"
)
;
let
infoMap
=
Object
.
assign
(
{
}
.
.
.
infoArray
)
;
return
{
infoArray
infoMap
}
;
}
add_task
(
async
function
test_backgroundtask_caps
(
)
{
let
experimentFile
=
do_get_file
(
"
experiment
.
json
"
)
;
let
experimentFileURI
=
Services
.
io
.
newFileURI
(
experimentFile
)
;
let
{
infoMap
}
=
await
doMessage
(
{
extraArgs
:
[
"
-
-
url
"
{
experimentFileURI
.
spec
}
?
optin_branch
=
treatment
-
a
]
}
)
;
let
impressions
=
infoMap
.
ASRouterState
.
messageImpressions
;
Assert
.
deepEqual
(
Object
.
keys
(
impressions
)
[
"
test
-
experiment
:
treatment
-
a
"
]
)
;
Assert
.
equal
(
impressions
[
"
test
-
experiment
:
treatment
-
a
"
]
.
length
1
)
;
let
alert
=
infoMap
.
showAlert
.
args
[
0
]
;
Assert
.
equal
(
alert
.
title
"
Treatment
A
"
)
;
Assert
.
equal
(
alert
.
text
"
Body
A
"
)
;
Assert
.
equal
(
alert
.
name
"
optin
-
test
-
experiment
:
treatment
-
a
"
)
;
(
{
infoMap
}
=
await
doMessage
(
{
}
)
)
;
impressions
=
infoMap
.
ASRouterState
.
messageImpressions
;
Assert
.
deepEqual
(
Object
.
keys
(
impressions
)
[
"
test
-
experiment
:
treatment
-
a
"
]
)
;
Assert
.
equal
(
impressions
[
"
test
-
experiment
:
treatment
-
a
"
]
.
length
2
)
;
alert
=
infoMap
.
showAlert
.
args
[
0
]
;
Assert
.
equal
(
alert
.
title
"
Treatment
A
"
)
;
Assert
.
equal
(
alert
.
text
"
Body
A
"
)
;
Assert
.
equal
(
alert
.
name
"
optin
-
test
-
experiment
:
treatment
-
a
"
)
;
(
{
infoMap
}
=
await
doMessage
(
{
}
)
)
;
impressions
=
infoMap
.
ASRouterState
.
messageImpressions
;
Assert
.
deepEqual
(
Object
.
keys
(
impressions
)
[
"
test
-
experiment
:
treatment
-
a
"
]
)
;
Assert
.
equal
(
impressions
[
"
test
-
experiment
:
treatment
-
a
"
]
.
length
2
)
;
Assert
.
ok
(
!
(
"
showAlert
"
in
infoMap
)
"
No
alert
shown
"
)
;
}
)
;
add_task
(
async
function
test_backgroundtask_randomization
(
)
{
let
experimentFile
=
do_get_file
(
"
experiment
.
json
"
)
;
for
(
let
[
branchSlug
branchDetails
]
of
Object
.
entries
(
BRANCH_MAP
)
)
{
resetProfile
(
taskProfile
)
;
for
(
let
count
=
1
;
count
<
=
2
;
count
+
+
)
{
let
{
infoMap
}
=
await
doMessage
(
{
extraArgs
:
[
"
-
-
experiments
"
experimentFile
.
path
"
-
-
randomizationId
"
branchDetails
.
randomizationId
]
}
)
;
let
impressions
=
infoMap
.
ASRouterState
.
messageImpressions
;
Assert
.
deepEqual
(
Object
.
keys
(
impressions
)
[
test
-
experiment
:
{
branchSlug
}
]
)
;
Assert
.
equal
(
impressions
[
test
-
experiment
:
{
branchSlug
}
]
.
length
count
)
;
let
alert
=
infoMap
.
showAlert
.
args
[
0
]
;
Assert
.
equal
(
alert
.
title
branchDetails
.
title
"
Title
is
correct
"
)
;
Assert
.
equal
(
alert
.
text
branchDetails
.
text
"
Text
is
correct
"
)
;
Assert
.
equal
(
alert
.
name
test
-
experiment
:
{
branchSlug
}
"
Name
(
tag
)
is
correct
"
)
;
}
}
}
)
;
add_task
(
async
function
test_backgroundtask_optout_preferences
(
)
{
let
experimentFile
=
do_get_file
(
"
experiment
.
json
"
)
;
let
OPTION_MAP
=
{
"
-
-
no
-
datareporting
"
:
{
"
datareporting
.
healthreport
.
uploadEnabled
"
:
false
"
app
.
shield
.
optoutstudies
.
enabled
"
:
true
}
"
-
-
no
-
optoutstudies
"
:
{
"
datareporting
.
healthreport
.
uploadEnabled
"
:
true
"
app
.
shield
.
optoutstudies
.
enabled
"
:
false
}
}
;
for
(
let
[
option
expectedPrefs
]
of
Object
.
entries
(
OPTION_MAP
)
)
{
resetProfile
(
taskProfile
)
;
let
{
infoMap
}
=
await
doMessage
(
{
extraArgs
:
[
option
"
-
-
experiments
"
experimentFile
.
path
]
}
)
;
Assert
.
deepEqual
(
infoMap
.
taskProfilePrefs
expectedPrefs
)
;
let
impressions
=
infoMap
.
ASRouterState
.
messageImpressions
;
Assert
.
deepEqual
(
impressions
[
]
No
impressions
generated
with
{
option
}
)
;
Assert
.
ok
(
!
(
"
showAlert
"
in
infoMap
)
No
alert
shown
with
{
option
}
)
;
}
}
)
;
const
TARGETING_LIST
=
[
[
"
isBackgroundTaskMode
"
1
]
[
"
backgroundTaskName
=
=
'
message
'
"
1
]
[
"
backgroundTaskName
=
=
'
unrecognized
'
"
0
]
[
"
(
currentDate
|
date
-
defaultProfile
.
currentDate
|
date
)
>
0
"
1
]
[
"
(
currentDate
|
date
-
defaultProfile
.
currentDate
|
date
)
>
999999
"
0
]
[
"
'
baz
'
in
defaultProfile
.
activeExperiments
"
1
]
[
"
'
bar
'
in
defaultProfile
.
previousExperiments
"
1
]
[
"
'
rol2
'
in
defaultProfile
.
activeRollouts
"
1
]
[
"
'
rol1
'
in
defaultProfile
.
previousRollouts
"
1
]
[
"
defaultProfile
.
enrollmentsMap
[
'
baz
'
]
=
=
'
treatment
'
"
1
]
[
"
defaultProfile
.
enrollmentsMap
[
'
bar
'
]
=
=
'
treatment
'
"
1
]
[
"
'
unknown
'
in
defaultProfile
.
enrollmentsMap
"
0
]
]
;
add_task
(
async
function
test_backgroundtask_Nimbus_targeting
(
)
{
let
experimentFile
=
do_get_file
(
"
experiment
.
json
"
)
;
let
experimentData
=
await
IOUtils
.
readJSON
(
experimentFile
.
path
)
;
let
target
=
{
currentDate
:
ASRouterTargeting
.
Environment
.
currentDate
firefoxVersion
:
ASRouterTargeting
.
Environment
.
firefoxVersion
}
;
let
targetSnapshot
=
await
ASRouterTargeting
.
getEnvironmentSnapshot
(
{
targets
:
[
manager
.
createTargetingContext
(
)
target
]
}
)
;
for
(
let
[
targeting
expectedLength
]
of
TARGETING_LIST
)
{
resetProfile
(
taskProfile
)
;
let
snapshotFile
=
taskProfile
.
rootDir
.
clone
(
)
;
snapshotFile
.
append
(
"
targeting
.
snapshot
.
json
"
)
;
await
IOUtils
.
writeJSON
(
snapshotFile
.
path
targetSnapshot
)
;
experimentData
.
data
.
targeting
=
targeting
;
let
targetingExperimentFile
=
taskProfile
.
rootDir
.
clone
(
)
;
targetingExperimentFile
.
append
(
"
targeting
.
experiment
.
json
"
)
;
await
IOUtils
.
writeJSON
(
targetingExperimentFile
.
path
experimentData
)
;
let
{
infoMap
}
=
await
doMessage
(
{
extraArgs
:
[
"
-
-
experiments
"
targetingExperimentFile
.
path
"
-
-
targeting
-
snapshot
"
snapshotFile
.
path
]
}
)
;
let
impressions
=
infoMap
.
ASRouterState
.
messageImpressions
;
Assert
.
equal
(
Object
.
keys
(
impressions
)
.
length
expectedLength
{
expectedLength
}
impressions
generated
with
targeting
'
{
targeting
}
'
)
;
}
}
)
;
add_task
(
async
function
test_backgroundtask_Messaging_targeting
(
)
{
let
treatmentARandomizationId
=
BRANCH_MAP
[
"
treatment
-
a
"
]
.
randomizationId
;
let
experimentFile
=
do_get_file
(
"
experiment
.
json
"
)
;
let
experimentData
=
await
IOUtils
.
readJSON
(
experimentFile
.
path
)
;
let
target
=
{
currentDate
:
ASRouterTargeting
.
Environment
.
currentDate
firefoxVersion
:
ASRouterTargeting
.
Environment
.
firefoxVersion
}
;
let
targetSnapshot
=
await
ASRouterTargeting
.
getEnvironmentSnapshot
(
{
targets
:
[
manager
.
createTargetingContext
(
)
target
]
}
)
;
for
(
let
[
targeting
expectedLength
]
of
TARGETING_LIST
)
{
resetProfile
(
taskProfile
)
;
let
snapshotFile
=
taskProfile
.
rootDir
.
clone
(
)
;
snapshotFile
.
append
(
"
targeting
.
snapshot
.
json
"
)
;
await
IOUtils
.
writeJSON
(
snapshotFile
.
path
targetSnapshot
)
;
experimentData
.
data
.
targeting
=
"
true
"
;
experimentData
.
data
.
branches
[
0
]
.
features
[
0
]
.
value
.
targeting
=
targeting
;
let
targetingExperimentFile
=
taskProfile
.
rootDir
.
clone
(
)
;
targetingExperimentFile
.
append
(
"
targeting
.
experiment
.
json
"
)
;
await
IOUtils
.
writeJSON
(
targetingExperimentFile
.
path
experimentData
)
;
let
{
infoMap
}
=
await
doMessage
(
{
extraArgs
:
[
"
-
-
experiments
"
targetingExperimentFile
.
path
"
-
-
targeting
-
snapshot
"
snapshotFile
.
path
"
-
-
randomizationId
"
treatmentARandomizationId
]
}
)
;
let
impressions
=
infoMap
.
ASRouterState
.
messageImpressions
;
Assert
.
equal
(
Object
.
keys
(
impressions
)
.
length
expectedLength
{
expectedLength
}
impressions
generated
with
targeting
'
{
targeting
}
'
)
;
if
(
expectedLength
>
0
)
{
let
alert
=
infoMap
.
showAlert
.
args
[
0
]
;
Assert
.
equal
(
alert
.
title
BRANCH_MAP
[
"
treatment
-
a
"
]
.
title
"
Title
is
correct
"
)
;
Assert
.
equal
(
alert
.
text
BRANCH_MAP
[
"
treatment
-
a
"
]
.
text
"
Text
is
correct
"
)
;
Assert
.
equal
(
alert
.
name
test
-
experiment
:
treatment
-
a
"
Name
(
tag
)
is
correct
"
)
;
}
}
}
)
;
add_task
(
async
function
test_backgroundtask_RemoteSettingsClient_invokes_sync
(
)
{
let
{
infoArray
infoMap
}
=
await
doMessage
(
{
}
)
;
Assert
.
ok
(
"
RemoteSettingsClient
.
get
"
in
infoMap
"
RemoteSettingsClient
.
get
was
invoked
"
)
;
for
(
let
info
of
infoArray
)
{
if
(
"
RemoteSettingsClient
.
get
"
in
info
)
{
const
{
options
:
calledOptions
}
=
info
[
"
RemoteSettingsClient
.
get
"
]
;
Assert
.
ok
(
calledOptions
.
forceSync
"
RemoteSettingsClient
.
get
was
first
called
with
forceSync
"
)
;
return
;
}
}
}
)
;
