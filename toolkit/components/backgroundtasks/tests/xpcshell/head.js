"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
Subprocess
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Subprocess
.
jsm
"
)
;
function
getFirefoxExecutableFilename
(
)
{
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
return
AppConstants
.
MOZ_APP_NAME
+
"
.
exe
"
;
}
return
AppConstants
.
MOZ_APP_NAME
;
}
function
getFirefoxExecutableFile
(
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
=
Services
.
dirsvc
.
get
(
"
GreBinD
"
Ci
.
nsIFile
)
;
file
.
append
(
getFirefoxExecutableFilename
(
)
)
;
return
file
;
}
async
function
do_backgroundtask
(
task
options
=
{
extraArgs
:
[
]
extraEnv
:
{
}
stdoutLines
:
null
}
)
{
options
=
Object
.
assign
(
{
}
options
)
;
options
.
extraArgs
=
options
.
extraArgs
|
|
[
]
;
options
.
extraEnv
=
options
.
extraEnv
|
|
{
}
;
let
command
=
getFirefoxExecutableFile
(
)
.
path
;
let
args
=
[
"
-
-
backgroundtask
"
task
]
;
args
.
push
(
.
.
.
options
.
extraArgs
)
;
let
protocolHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
let
uri
=
protocolHandler
.
getSubstitution
(
"
testing
-
common
"
)
;
Assert
.
ok
(
!
!
uri
"
resource
:
/
/
testing
-
common
is
not
substituted
"
)
;
options
.
extraEnv
.
XPCSHELL_TESTING_MODULES_URI
=
uri
.
spec
;
info
(
launching
child
process
{
command
}
with
args
:
{
args
}
and
extra
environment
:
{
JSON
.
stringify
(
options
.
extraEnv
)
}
)
;
let
stdoutChunks
=
[
]
;
let
proc
=
await
Subprocess
.
call
(
{
command
arguments
:
args
environment
:
options
.
extraEnv
environmentAppend
:
true
stderr
:
"
stdout
"
}
)
.
then
(
p
=
>
{
p
.
stdin
.
close
(
)
;
const
dumpPipe
=
async
pipe
=
>
{
let
data
=
await
pipe
.
readString
(
)
;
while
(
data
)
{
stdoutChunks
.
push
(
data
)
;
data
=
await
pipe
.
readString
(
)
;
}
}
;
dumpPipe
(
p
.
stdout
)
;
return
p
;
}
)
;
let
{
exitCode
}
=
await
proc
.
wait
(
)
;
let
stdout
=
stdoutChunks
.
join
(
"
"
)
;
for
(
let
line
of
stdout
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
.
slice
(
0
-
1
)
)
{
dump
(
"
>
"
+
line
+
"
\
n
"
)
;
if
(
options
.
stdoutLines
!
=
=
null
&
&
options
.
stdoutLines
!
=
=
undefined
)
{
options
.
stdoutLines
.
push
(
line
)
;
}
}
return
exitCode
;
}
function
setupProfileService
(
)
{
let
gProfD
=
do_get_profile
(
)
;
let
gDataHome
=
gProfD
.
clone
(
)
;
gDataHome
.
append
(
"
data
"
)
;
gDataHome
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
let
gDataHomeLocal
=
gProfD
.
clone
(
)
;
gDataHomeLocal
.
append
(
"
local
"
)
;
gDataHomeLocal
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
let
xreDirProvider
=
Cc
[
"
mozilla
.
org
/
xre
/
directory
-
provider
;
1
"
]
.
getService
(
Ci
.
nsIXREDirProvider
)
;
xreDirProvider
.
setUserDataDirectory
(
gDataHome
false
)
;
xreDirProvider
.
setUserDataDirectory
(
gDataHomeLocal
true
)
;
}
