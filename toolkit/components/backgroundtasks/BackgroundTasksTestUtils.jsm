"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BackgroundTasksTestUtils
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Subprocess
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Subprocess
.
jsm
"
)
;
function
getFirefoxExecutableFilename
(
)
{
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
return
AppConstants
.
MOZ_APP_NAME
+
"
.
exe
"
;
}
if
(
AppConstants
.
platform
=
=
"
linux
"
)
{
return
AppConstants
.
MOZ_APP_NAME
+
"
-
bin
"
;
}
return
AppConstants
.
MOZ_APP_NAME
;
}
function
getFirefoxExecutableFile
(
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
=
Services
.
dirsvc
.
get
(
"
GreBinD
"
Ci
.
nsIFile
)
;
file
.
append
(
getFirefoxExecutableFilename
(
)
)
;
return
file
;
}
var
BackgroundTasksTestUtils
=
{
init
(
scope
)
{
this
.
testScope
=
scope
;
}
async
do_backgroundtask
(
task
options
=
{
extraArgs
:
[
]
extraEnv
:
{
}
onStdoutLine
:
null
}
)
{
options
=
Object
.
assign
(
{
}
options
)
;
options
.
extraArgs
=
options
.
extraArgs
|
|
[
]
;
options
.
extraEnv
=
options
.
extraEnv
|
|
{
}
;
let
command
=
getFirefoxExecutableFile
(
)
.
path
;
let
args
=
[
"
-
-
backgroundtask
"
task
]
;
args
.
push
(
.
.
.
options
.
extraArgs
)
;
let
protocolHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
let
uri
=
protocolHandler
.
getSubstitution
(
"
testing
-
common
"
)
;
const
{
Assert
}
=
this
.
testScope
;
Assert
.
ok
(
!
!
uri
"
resource
:
/
/
testing
-
common
is
not
substituted
"
)
;
options
.
extraEnv
.
XPCSHELL_TESTING_MODULES_URI
=
uri
.
spec
;
console
.
info
(
launching
background
task
{
command
args
extraEnv
:
options
.
extraEnv
}
)
;
let
{
proc
readPromise
}
=
await
Subprocess
.
call
(
{
command
arguments
:
args
environment
:
options
.
extraEnv
environmentAppend
:
true
stderr
:
"
stdout
"
}
)
.
then
(
p
=
>
{
p
.
stdin
.
close
(
)
.
catch
(
(
)
=
>
{
}
)
;
const
dumpPipe
=
async
pipe
=
>
{
let
leftover
=
"
"
;
let
data
=
await
pipe
.
readString
(
)
;
while
(
data
)
{
data
=
leftover
+
data
;
let
lines
=
data
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
;
for
(
let
line
of
lines
.
slice
(
0
-
1
)
)
{
dump
(
{
p
.
pid
}
>
{
line
}
\
n
)
;
if
(
options
.
onStdoutLine
)
{
options
.
onStdoutLine
(
line
p
)
;
}
}
leftover
=
lines
[
lines
.
length
-
1
]
;
data
=
await
pipe
.
readString
(
)
;
}
if
(
leftover
.
length
)
{
dump
(
{
p
.
pid
}
>
{
leftover
}
\
n
)
;
if
(
options
.
onStdoutLine
)
{
options
.
onStdoutLine
(
leftover
p
)
;
}
}
}
;
let
readPromise
=
dumpPipe
(
p
.
stdout
)
;
return
{
proc
:
p
readPromise
}
;
}
)
;
let
{
exitCode
}
=
await
proc
.
wait
(
)
;
try
{
await
readPromise
;
}
catch
(
e
)
{
if
(
e
.
message
!
=
=
"
File
closed
"
)
{
throw
e
;
}
}
return
exitCode
;
}
setupProfileService
(
)
{
let
gProfD
=
this
.
testScope
.
do_get_profile
(
)
;
let
gDataHome
=
gProfD
.
clone
(
)
;
gDataHome
.
append
(
"
data
"
)
;
gDataHome
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
let
gDataHomeLocal
=
gProfD
.
clone
(
)
;
gDataHomeLocal
.
append
(
"
local
"
)
;
gDataHomeLocal
.
createUnique
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
let
xreDirProvider
=
Cc
[
"
mozilla
.
org
/
xre
/
directory
-
provider
;
1
"
]
.
getService
(
Ci
.
nsIXREDirProvider
)
;
xreDirProvider
.
setUserDataDirectory
(
gDataHome
false
)
;
xreDirProvider
.
setUserDataDirectory
(
gDataHomeLocal
true
)
;
}
}
;
