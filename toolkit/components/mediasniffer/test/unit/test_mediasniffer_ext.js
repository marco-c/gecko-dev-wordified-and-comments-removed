var
CC
=
Components
.
Constructor
;
var
BinaryOutputStream
=
CC
(
"
mozilla
.
org
/
binaryoutputstream
;
1
"
"
nsIBinaryOutputStream
"
"
setOutputStream
"
)
;
const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
{
NetUtil
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
var
httpserver
=
new
HttpServer
(
)
;
var
testRan
=
0
;
const
tests
=
[
{
path
:
"
data
/
file
.
webm
"
expected
:
"
video
/
webm
"
}
{
path
:
"
data
/
file
.
mkv
"
expected
:
"
application
/
octet
-
stream
"
}
{
path
:
"
data
/
id3tags
.
mp3
"
expected
:
"
audio
/
mpeg
"
}
{
path
:
"
data
/
notags
.
mp3
"
expected
:
"
audio
/
mpeg
"
}
{
path
:
"
data
/
detodos
.
mp3
"
expected
:
"
audio
/
mpeg
"
}
{
path
:
"
data
/
notags
-
bad
.
mp3
"
expected
:
"
application
/
octet
-
stream
"
}
{
path
:
"
data
/
notags
-
scan
.
mp3
"
expected
:
"
application
/
octet
-
stream
"
}
{
path
:
"
data
/
he_free
.
mp3
"
expected
:
"
application
/
octet
-
stream
"
}
{
path
:
"
data
/
fl10
.
mp2
"
expected
:
"
application
/
octet
-
stream
"
}
{
path
:
"
data
/
ff
-
inst
.
exe
"
expected
:
"
application
/
octet
-
stream
"
}
{
path
:
"
data
/
bug1079747
.
mp4
"
expected
:
"
application
/
octet
-
stream
"
}
]
;
var
listener
=
{
onStartRequest
(
request
context
)
{
info
(
"
Sniffing
"
+
tests
[
testRan
]
.
path
)
;
Assert
.
equal
(
request
.
QueryInterface
(
Ci
.
nsIChannel
)
.
contentType
tests
[
testRan
]
.
expected
)
;
}
onDataAvailable
(
request
context
stream
offset
count
)
{
try
{
var
bis
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
bis
.
setInputStream
(
stream
)
;
bis
.
readByteArray
(
bis
.
available
(
)
)
;
}
catch
(
ex
)
{
do_throw
(
"
Error
in
onDataAvailable
:
"
+
ex
)
;
}
}
onStopRequest
(
request
context
status
)
{
testRan
+
+
;
runNext
(
)
;
}
}
;
function
setupChannel
(
url
)
{
var
chan
=
NetUtil
.
newChannel
(
{
uri
:
"
http
:
/
/
localhost
:
"
+
httpserver
.
identity
.
primaryPort
+
url
loadUsingSystemPrincipal
:
true
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_MEDIA
}
)
;
var
httpChan
=
chan
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
return
httpChan
;
}
function
runNext
(
)
{
if
(
testRan
=
=
tests
.
length
)
{
do_test_finished
(
)
;
return
;
}
var
channel
=
setupChannel
(
"
/
"
)
;
channel
.
asyncOpen2
(
listener
)
;
}
function
getFileContents
(
aFile
)
{
var
fileStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
fileStream
.
init
(
aFile
1
-
1
null
)
;
var
bis
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
bis
.
setInputStream
(
fileStream
)
;
var
data
=
bis
.
readByteArray
(
bis
.
available
(
)
)
;
return
data
;
}
function
handler
(
metadata
response
)
{
response
.
setStatusLine
(
metadata
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
"
false
)
;
var
body
=
getFileContents
(
do_get_file
(
tests
[
testRan
]
.
path
)
)
;
var
bos
=
new
BinaryOutputStream
(
response
.
bodyOutputStream
)
;
bos
.
writeByteArray
(
body
body
.
length
)
;
}
function
run_test
(
)
{
httpserver
.
registerPathHandler
(
"
/
"
handler
)
;
httpserver
.
start
(
-
1
)
;
do_test_pending
(
)
;
try
{
runNext
(
)
;
}
catch
(
e
)
{
print
(
"
ERROR
-
"
+
e
+
"
\
n
"
)
;
}
}
