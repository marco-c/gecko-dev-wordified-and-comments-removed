"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ContentPrefServiceParent
"
]
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
_methodsCallableFromChild
"
"
resource
:
/
/
gre
/
modules
/
ContentPrefUtils
.
jsm
"
)
;
let
loadContext
=
Cc
[
"
mozilla
.
org
/
loadcontext
;
1
"
]
.
createInstance
(
Ci
.
nsILoadContext
)
;
let
privateLoadContext
=
Cc
[
"
mozilla
.
org
/
privateloadcontext
;
1
"
]
.
createInstance
(
Ci
.
nsILoadContext
)
;
function
contextArg
(
context
)
{
return
(
context
&
&
context
.
usePrivateBrowsing
)
?
privateLoadContext
:
loadContext
;
}
var
ContentPrefServiceParent
=
{
alwaysInit
(
)
{
let
globalMM
=
Cc
[
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageListenerManager
)
;
globalMM
.
addMessageListener
(
"
child
-
process
-
shutdown
"
this
)
;
}
init
(
)
{
let
globalMM
=
Cc
[
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageListenerManager
)
;
globalMM
.
addMessageListener
(
"
ContentPrefs
:
FunctionCall
"
this
)
;
globalMM
.
addMessageListener
(
"
ContentPrefs
:
AddObserverForName
"
this
)
;
globalMM
.
addMessageListener
(
"
ContentPrefs
:
RemoveObserverForName
"
this
)
;
this
.
alwaysInit
(
)
;
}
_observers
:
new
Map
(
)
handleObserverChange
(
msg
)
{
let
observer
=
this
.
_observers
.
get
(
msg
.
target
)
;
if
(
msg
.
name
=
=
=
"
child
-
process
-
shutdown
"
)
{
if
(
!
observer
)
return
;
for
(
let
i
of
observer
.
_names
)
{
this
.
_cps2
.
removeObserverForName
(
i
observer
)
;
}
this
.
_observers
.
delete
(
msg
.
target
)
;
return
;
}
let
prefName
=
msg
.
data
.
name
;
if
(
msg
.
name
=
=
=
"
ContentPrefs
:
AddObserverForName
"
)
{
if
(
!
observer
)
{
observer
=
{
onContentPrefSet
(
group
name
value
isPrivate
)
{
msg
.
target
.
sendAsyncMessage
(
"
ContentPrefs
:
NotifyObservers
"
{
name
callback
:
"
onContentPrefSet
"
args
:
[
group
name
value
isPrivate
]
}
)
;
}
onContentPrefRemoved
(
group
name
isPrivate
)
{
msg
.
target
.
sendAsyncMessage
(
"
ContentPrefs
:
NotifyObservers
"
{
name
callback
:
"
onContentPrefRemoved
"
args
:
[
group
name
isPrivate
]
}
)
;
}
_names
:
new
Set
(
)
}
;
this
.
_observers
.
set
(
msg
.
target
observer
)
;
}
observer
.
_names
.
add
(
prefName
)
;
this
.
_cps2
.
addObserverForName
(
prefName
observer
)
;
}
else
{
this
.
_cps2
.
removeObserverForName
(
prefName
observer
)
;
observer
.
_names
.
delete
(
prefName
)
;
if
(
observer
.
_names
.
size
=
=
=
0
)
{
this
.
_observers
.
delete
(
msg
.
target
)
;
}
}
}
receiveMessage
(
msg
)
{
if
(
msg
.
name
!
=
"
ContentPrefs
:
FunctionCall
"
)
{
this
.
handleObserverChange
(
msg
)
;
return
;
}
let
data
=
msg
.
data
;
let
signature
;
if
(
!
_methodsCallableFromChild
.
some
(
(
[
method
args
]
)
=
>
{
if
(
method
=
=
data
.
call
)
{
signature
=
args
;
return
true
;
}
return
false
;
}
)
)
{
throw
new
Error
(
Can
'
t
call
{
data
.
call
}
from
child
!
)
;
}
let
args
=
data
.
args
;
let
requestId
=
data
.
requestId
;
let
listener
=
{
handleResult
(
pref
)
{
msg
.
target
.
sendAsyncMessage
(
"
ContentPrefs
:
HandleResult
"
{
requestId
contentPref
:
{
domain
:
pref
.
domain
name
:
pref
.
name
value
:
pref
.
value
}
}
)
;
}
handleError
(
error
)
{
msg
.
target
.
sendAsyncMessage
(
"
ContentPrefs
:
HandleError
"
{
requestId
error
}
)
;
}
handleCompletion
(
reason
)
{
msg
.
target
.
sendAsyncMessage
(
"
ContentPrefs
:
HandleCompletion
"
{
requestId
reason
}
)
;
}
}
;
args
.
push
(
listener
)
;
let
contextIndex
=
signature
.
indexOf
(
"
context
"
)
;
if
(
contextIndex
>
-
1
)
{
args
[
contextIndex
]
=
contextArg
(
args
[
contextIndex
]
)
;
}
this
.
_cps2
[
data
.
call
]
(
.
.
.
args
)
;
}
}
;
XPCOMUtils
.
defineLazyServiceGetter
(
ContentPrefServiceParent
"
_cps2
"
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
"
nsIContentPrefService2
"
)
;
