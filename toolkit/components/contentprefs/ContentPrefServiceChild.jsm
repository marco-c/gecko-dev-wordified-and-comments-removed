"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ContentPrefServiceChild
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ContentPrefUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ContentPrefStore
.
jsm
"
)
;
function
contextArg
(
context
)
{
return
(
context
&
&
context
.
usePrivateBrowsing
)
?
{
usePrivateBrowsing
:
true
}
:
null
;
}
function
NYI
(
)
{
throw
new
Error
(
"
Do
not
add
any
new
users
of
these
functions
"
)
;
}
function
CallbackCaller
(
callback
)
{
this
.
_callback
=
callback
;
}
CallbackCaller
.
prototype
=
{
handleResult
(
contentPref
)
{
cbHandleResult
(
this
.
_callback
new
ContentPref
(
contentPref
.
domain
contentPref
.
name
contentPref
.
value
)
)
;
}
handleError
(
result
)
{
cbHandleError
(
this
.
_callback
result
)
;
}
handleCompletion
(
reason
)
{
cbHandleCompletion
(
this
.
_callback
reason
)
;
}
}
;
var
ContentPrefServiceChild
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIContentPrefService2
]
)
_observers
:
new
Map
(
)
_mm
:
Cc
[
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageSender
)
_getRandomId
(
)
{
return
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
}
_requests
:
new
Map
(
)
init
(
)
{
this
.
_mm
.
addMessageListener
(
"
ContentPrefs
:
HandleResult
"
this
)
;
this
.
_mm
.
addMessageListener
(
"
ContentPrefs
:
HandleError
"
this
)
;
this
.
_mm
.
addMessageListener
(
"
ContentPrefs
:
HandleCompletion
"
this
)
;
}
receiveMessage
(
msg
)
{
let
data
=
msg
.
data
;
let
callback
;
switch
(
msg
.
name
)
{
case
"
ContentPrefs
:
HandleResult
"
:
callback
=
this
.
_requests
.
get
(
data
.
requestId
)
;
callback
.
handleResult
(
data
.
contentPref
)
;
break
;
case
"
ContentPrefs
:
HandleError
"
:
callback
=
this
.
_requests
.
get
(
data
.
requestId
)
;
callback
.
handleError
(
data
.
error
)
;
break
;
case
"
ContentPrefs
:
HandleCompletion
"
:
callback
=
this
.
_requests
.
get
(
data
.
requestId
)
;
this
.
_requests
.
delete
(
data
.
requestId
)
;
callback
.
handleCompletion
(
data
.
reason
)
;
break
;
case
"
ContentPrefs
:
NotifyObservers
"
:
{
let
observerList
=
this
.
_observers
.
get
(
data
.
name
)
;
if
(
!
observerList
)
break
;
for
(
let
observer
of
observerList
)
{
safeCallback
(
observer
data
.
callback
data
.
args
)
;
}
break
;
}
}
}
_callFunction
(
call
args
callback
)
{
let
requestId
=
this
.
_getRandomId
(
)
;
let
data
=
{
call
args
requestId
}
;
this
.
_mm
.
sendAsyncMessage
(
"
ContentPrefs
:
FunctionCall
"
data
)
;
this
.
_requests
.
set
(
requestId
new
CallbackCaller
(
callback
)
)
;
}
getCachedByDomainAndName
:
NYI
getCachedBySubdomainAndName
:
NYI
getCachedGlobal
:
NYI
addObserverForName
(
name
observer
)
{
let
set
=
this
.
_observers
.
get
(
name
)
;
if
(
!
set
)
{
set
=
new
Set
(
)
;
if
(
this
.
_observers
.
size
=
=
=
0
)
{
this
.
_mm
.
addMessageListener
(
"
ContentPrefs
:
NotifyObservers
"
this
)
;
}
this
.
_mm
.
sendAsyncMessage
(
"
ContentPrefs
:
AddObserverForName
"
{
name
}
)
;
this
.
_observers
.
set
(
name
set
)
;
}
set
.
add
(
observer
)
;
}
removeObserverForName
(
name
observer
)
{
let
set
=
this
.
_observers
.
get
(
name
)
;
if
(
!
set
)
return
;
set
.
delete
(
observer
)
;
if
(
set
.
size
=
=
=
0
)
{
this
.
_mm
.
sendAsyncMessage
(
"
ContentPrefs
:
RemoveObserverForName
"
{
name
}
)
;
this
.
_observers
.
delete
(
name
)
;
if
(
this
.
_observers
.
size
=
=
=
0
)
{
this
.
_mm
.
removeMessageListener
(
"
ContentPrefs
:
NotifyObservers
"
this
)
;
}
}
}
extractDomain
:
NYI
}
;
function
forwardMethodToParent
(
method
signature
.
.
.
args
)
{
args
=
args
.
slice
(
0
signature
.
length
)
;
let
contextIndex
=
signature
.
indexOf
(
"
context
"
)
;
if
(
contextIndex
>
-
1
)
{
args
[
contextIndex
]
=
contextArg
(
args
[
contextIndex
]
)
;
}
let
callbackIndex
=
signature
.
indexOf
(
"
callback
"
)
;
let
callback
=
null
;
if
(
callbackIndex
>
-
1
&
&
args
.
length
>
callbackIndex
)
{
callback
=
args
.
splice
(
callbackIndex
1
)
[
0
]
;
}
this
.
_callFunction
(
method
args
callback
)
;
}
for
(
let
[
method
signature
]
of
_methodsCallableFromChild
)
{
ContentPrefServiceChild
[
method
]
=
forwardMethodToParent
.
bind
(
ContentPrefServiceChild
method
signature
)
;
}
ContentPrefServiceChild
.
init
(
)
;
