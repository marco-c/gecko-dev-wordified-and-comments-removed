"
use
strict
"
;
var
SharedAll
;
var
Primitives
;
if
(
typeof
Components
!
=
"
undefined
"
)
{
SharedAll
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
osfile_shared_allthreads
.
jsm
"
SharedAll
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
lz4_internal
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
Lz4
"
]
;
this
.
exports
=
{
}
;
}
else
if
(
typeof
module
!
=
"
undefined
"
&
&
typeof
require
!
=
"
undefined
"
)
{
SharedAll
=
require
(
"
resource
:
/
/
gre
/
modules
/
osfile
/
osfile_shared_allthreads
.
jsm
"
)
;
Primitives
=
require
(
"
resource
:
/
/
gre
/
modules
/
lz4_internal
.
js
"
)
;
}
else
{
throw
new
Error
(
"
Please
load
this
module
with
Component
.
utils
.
import
or
with
require
(
)
"
)
;
}
const
MAGIC_NUMBER
=
new
Uint8Array
(
[
109
111
122
76
122
52
48
0
]
)
;
const
BYTES_IN_SIZE_HEADER
=
ctypes
.
uint32_t
.
size
;
const
HEADER_SIZE
=
MAGIC_NUMBER
.
byteLength
+
BYTES_IN_SIZE_HEADER
;
function
LZError
(
operation
reason
message
)
{
SharedAll
.
OSError
.
call
(
this
)
;
this
.
operation
=
operation
;
this
[
reason
]
=
true
;
this
.
message
=
message
;
}
LZError
.
prototype
=
Object
.
create
(
SharedAll
.
OSError
)
;
LZError
.
prototype
.
toString
=
function
toString
(
)
{
return
this
.
message
;
}
;
exports
.
Error
=
LZError
;
function
compressFileContent
(
array
options
=
{
}
)
{
let
inputBytes
;
if
(
SharedAll
.
isTypedArray
(
array
)
&
&
!
(
options
&
&
"
bytes
"
in
options
)
)
{
inputBytes
=
array
.
byteLength
;
}
else
if
(
options
&
&
options
.
bytes
)
{
inputBytes
=
options
.
bytes
;
}
else
{
throw
new
TypeError
(
"
compressFileContent
requires
a
size
"
)
;
}
let
maxCompressedSize
=
Primitives
.
maxCompressedSize
(
inputBytes
)
;
let
outputArray
=
new
Uint8Array
(
HEADER_SIZE
+
maxCompressedSize
)
;
let
payload
=
new
Uint8Array
(
outputArray
.
buffer
outputArray
.
byteOffset
+
HEADER_SIZE
)
;
let
compressedSize
=
Primitives
.
compress
(
array
inputBytes
payload
)
;
outputArray
.
set
(
MAGIC_NUMBER
)
;
let
view
=
new
DataView
(
outputArray
.
buffer
)
;
view
.
setUint32
(
MAGIC_NUMBER
.
byteLength
inputBytes
true
)
;
return
new
Uint8Array
(
outputArray
.
buffer
0
HEADER_SIZE
+
compressedSize
)
;
}
exports
.
compressFileContent
=
compressFileContent
;
function
decompressFileContent
(
array
options
=
{
}
)
{
let
bytes
=
SharedAll
.
normalizeBufferArgs
(
array
options
.
bytes
|
|
null
)
;
if
(
bytes
<
HEADER_SIZE
)
{
throw
new
LZError
(
"
decompress
"
"
becauseLZNoHeader
"
Buffer
is
too
short
(
no
header
)
-
Data
:
{
options
.
path
|
|
array
}
)
;
}
let
expectMagicNumber
=
new
DataView
(
array
.
buffer
0
MAGIC_NUMBER
.
byteLength
)
;
for
(
let
i
=
0
;
i
<
MAGIC_NUMBER
.
byteLength
;
+
+
i
)
{
if
(
expectMagicNumber
.
getUint8
(
i
)
!
=
MAGIC_NUMBER
[
i
]
)
{
throw
new
LZError
(
"
decompress
"
"
becauseLZWrongMagicNumber
"
Invalid
header
(
no
magic
number
)
-
Data
:
{
options
.
path
|
|
array
}
)
;
}
}
let
sizeBuf
=
new
DataView
(
array
.
buffer
MAGIC_NUMBER
.
byteLength
BYTES_IN_SIZE_HEADER
)
;
let
expectDecompressedSize
=
sizeBuf
.
getUint8
(
0
)
+
(
sizeBuf
.
getUint8
(
1
)
<
<
8
)
+
(
sizeBuf
.
getUint8
(
2
)
<
<
16
)
+
(
sizeBuf
.
getUint8
(
3
)
<
<
24
)
;
if
(
expectDecompressedSize
=
=
0
)
{
return
new
Uint8Array
(
0
)
;
}
let
inputData
=
new
DataView
(
array
.
buffer
HEADER_SIZE
)
;
let
outputBuffer
=
new
Uint8Array
(
expectDecompressedSize
)
;
let
decompressedBytes
=
(
new
SharedAll
.
Type
.
size_t
.
implementation
(
0
)
)
;
let
success
=
Primitives
.
decompress
(
inputData
bytes
-
HEADER_SIZE
outputBuffer
outputBuffer
.
byteLength
decompressedBytes
.
address
(
)
)
;
if
(
!
success
)
{
throw
new
LZError
(
"
decompress
"
"
becauseLZInvalidContent
"
Invalid
content
:
Decompression
stopped
at
{
decompressedBytes
.
value
}
-
Data
:
{
options
.
path
|
|
array
}
)
;
}
return
new
Uint8Array
(
outputBuffer
.
buffer
outputBuffer
.
byteOffset
decompressedBytes
.
value
)
;
}
exports
.
decompressFileContent
=
decompressFileContent
;
if
(
typeof
Components
!
=
"
undefined
"
)
{
this
.
Lz4
=
{
compressFileContent
decompressFileContent
}
;
}
