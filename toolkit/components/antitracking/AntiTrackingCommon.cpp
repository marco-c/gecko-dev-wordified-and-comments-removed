#
include
"
AntiTrackingCommon
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MruCache
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
mozilla
/
StaticPrefs_extensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsICookiePermission
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIParentChannel
.
h
"
#
include
"
nsIPermission
.
h
"
#
include
"
nsPermissionManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURIFixup
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
prtime
.
h
"
#
define
ANTITRACKING_PERM_KEY
"
3rdPartyStorage
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
ContentChild
;
using
mozilla
:
:
dom
:
:
Document
;
static
LazyLogModule
gAntiTrackingLog
(
"
AntiTracking
"
)
;
static
const
nsCString
:
:
size_type
sMaxSpecLength
=
128
;
static
const
uint32_t
kMaxConsoleOutputDelayMs
=
100
;
#
define
LOG
(
format
)
MOZ_LOG
(
gAntiTrackingLog
mozilla
:
:
LogLevel
:
:
Debug
format
)
#
define
LOG_SPEC
(
format
uri
)
\
PR_BEGIN_MACRO
\
if
(
MOZ_LOG_TEST
(
gAntiTrackingLog
mozilla
:
:
LogLevel
:
:
Debug
)
)
{
\
nsAutoCString
_specStr
(
NS_LITERAL_CSTRING
(
"
(
null
)
"
)
)
;
\
_specStr
.
Truncate
(
std
:
:
min
(
_specStr
.
Length
(
)
sMaxSpecLength
)
)
;
\
if
(
uri
)
{
\
_specStr
=
uri
-
>
GetSpecOrDefault
(
)
;
\
}
\
const
char
*
_spec
=
_specStr
.
get
(
)
;
\
LOG
(
format
)
;
\
}
\
PR_END_MACRO
namespace
{
UniquePtr
<
nsTArray
<
AntiTrackingCommon
:
:
AntiTrackingSettingsChangedCallback
>
>
gSettingsChangedCallbacks
;
bool
GetParentPrincipalAndTrackingOrigin
(
nsGlobalWindowInner
*
a3rdPartyTrackingWindow
uint32_t
aBehavior
nsIPrincipal
*
*
aTopLevelStoragePrincipal
nsACString
&
aTrackingOrigin
nsIURI
*
*
aTrackingURI
nsIPrincipal
*
*
aTrackingPrincipal
)
{
Document
*
doc
=
a3rdPartyTrackingWindow
-
>
GetDocument
(
)
;
if
(
doc
&
&
(
doc
-
>
StorageAccessSandboxed
(
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsIPrincipal
>
topLevelStoragePrincipal
=
(
aBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
?
a3rdPartyTrackingWindow
-
>
GetTopLevelStorageAreaPrincipal
(
)
:
a3rdPartyTrackingWindow
-
>
GetTopLevelPrincipal
(
)
;
if
(
!
topLevelStoragePrincipal
)
{
LOG
(
(
"
No
top
-
level
storage
area
principal
at
hand
"
)
)
;
return
false
;
}
nsCOMPtr
<
nsIPrincipal
>
trackingPrincipal
=
a3rdPartyTrackingWindow
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
trackingPrincipal
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
trackingURI
;
nsresult
rv
=
trackingPrincipal
-
>
GetURI
(
getter_AddRefs
(
trackingURI
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
rv
=
trackingPrincipal
-
>
GetOriginNoSuffix
(
aTrackingOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
topLevelStoragePrincipal
.
forget
(
aTopLevelStoragePrincipal
)
;
if
(
aTrackingURI
)
{
trackingURI
.
forget
(
aTrackingURI
)
;
}
if
(
aTrackingPrincipal
)
{
trackingPrincipal
.
forget
(
aTrackingPrincipal
)
;
}
return
true
;
}
;
void
CreatePermissionKey
(
const
nsCString
&
aTrackingOrigin
nsACString
&
aPermissionKey
)
{
MOZ_ASSERT
(
aPermissionKey
.
IsEmpty
(
)
)
;
static
const
nsLiteralCString
prefix
=
NS_LITERAL_CSTRING
(
ANTITRACKING_PERM_KEY
"
^
"
)
;
aPermissionKey
.
SetCapacity
(
prefix
.
Length
(
)
+
aTrackingOrigin
.
Length
(
)
)
;
aPermissionKey
.
Append
(
prefix
)
;
aPermissionKey
.
Append
(
aTrackingOrigin
)
;
}
void
CreatePermissionKey
(
const
nsCString
&
aTrackingOrigin
const
nsCString
&
aGrantedOrigin
nsACString
&
aPermissionKey
)
{
MOZ_ASSERT
(
aPermissionKey
.
IsEmpty
(
)
)
;
if
(
aTrackingOrigin
=
=
aGrantedOrigin
)
{
CreatePermissionKey
(
aTrackingOrigin
aPermissionKey
)
;
return
;
}
static
const
nsLiteralCString
prefix
=
NS_LITERAL_CSTRING
(
ANTITRACKING_PERM_KEY
"
^
"
)
;
aPermissionKey
.
SetCapacity
(
prefix
.
Length
(
)
+
1
+
aTrackingOrigin
.
Length
(
)
+
aGrantedOrigin
.
Length
(
)
)
;
aPermissionKey
.
Append
(
prefix
)
;
aPermissionKey
.
Append
(
aTrackingOrigin
)
;
aPermissionKey
.
AppendLiteral
(
"
^
"
)
;
aPermissionKey
.
Append
(
aGrantedOrigin
)
;
}
uint32_t
CheckCookiePermissionForPrincipal
(
nsICookieSettings
*
aCookieSettings
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aCookieSettings
)
;
MOZ_ASSERT
(
aPrincipal
)
;
uint32_t
cookiePermission
=
nsICookiePermission
:
:
ACCESS_DEFAULT
;
if
(
!
aPrincipal
-
>
GetIsContentPrincipal
(
)
)
{
return
cookiePermission
;
}
nsresult
rv
=
aCookieSettings
-
>
CookiePermission
(
aPrincipal
&
cookiePermission
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nsICookiePermission
:
:
ACCESS_DEFAULT
;
}
return
cookiePermission
;
}
int32_t
CookiesBehavior
(
Document
*
aTopLevelDocument
Document
*
a3rdPartyDocument
)
{
MOZ_ASSERT
(
aTopLevelDocument
)
;
MOZ_ASSERT
(
a3rdPartyDocument
)
;
if
(
StaticPrefs
:
:
extensions_cookiesBehavior_overrideOnTopLevel
(
)
&
&
BasePrincipal
:
:
Cast
(
aTopLevelDocument
-
>
NodePrincipal
(
)
)
-
>
AddonPolicy
(
)
)
{
return
nsICookieService
:
:
BEHAVIOR_ACCEPT
;
}
if
(
BasePrincipal
:
:
Cast
(
a3rdPartyDocument
-
>
NodePrincipal
(
)
)
-
>
AddonPolicy
(
)
)
{
return
nsICookieService
:
:
BEHAVIOR_ACCEPT
;
}
return
a3rdPartyDocument
-
>
CookieSettings
(
)
-
>
GetCookieBehavior
(
)
;
}
int32_t
CookiesBehavior
(
nsILoadInfo
*
aLoadInfo
nsIPrincipal
*
aTopLevelPrincipal
nsIURI
*
a3rdPartyURI
)
{
MOZ_ASSERT
(
aLoadInfo
)
;
MOZ_ASSERT
(
aTopLevelPrincipal
)
;
MOZ_ASSERT
(
a3rdPartyURI
)
;
if
(
StaticPrefs
:
:
extensions_cookiesBehavior_overrideOnTopLevel
(
)
&
&
BasePrincipal
:
:
Cast
(
aTopLevelPrincipal
)
-
>
AddonPolicy
(
)
)
{
return
nsICookieService
:
:
BEHAVIOR_ACCEPT
;
}
if
(
a3rdPartyURI
-
>
SchemeIs
(
"
moz
-
extension
"
)
)
{
return
nsICookieService
:
:
BEHAVIOR_ACCEPT
;
}
nsCOMPtr
<
nsICookieSettings
>
cookieSettings
;
nsresult
rv
=
aLoadInfo
-
>
GetCookieSettings
(
getter_AddRefs
(
cookieSettings
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nsICookieService
:
:
BEHAVIOR_REJECT
;
}
return
cookieSettings
-
>
GetCookieBehavior
(
)
;
}
int32_t
CookiesBehavior
(
nsIPrincipal
*
aPrincipal
nsICookieSettings
*
aCookieSettings
)
{
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aCookieSettings
)
;
if
(
BasePrincipal
:
:
Cast
(
aPrincipal
)
-
>
AddonPolicy
(
)
)
{
return
nsICookieService
:
:
BEHAVIOR_ACCEPT
;
}
return
aCookieSettings
-
>
GetCookieBehavior
(
)
;
}
struct
ContentBlockingAllowListKey
{
ContentBlockingAllowListKey
(
)
:
mHash
(
mozilla
:
:
HashGeneric
(
uintptr_t
(
0
)
)
)
{
}
explicit
ContentBlockingAllowListKey
(
nsPIDOMWindowInner
*
aWindow
)
:
mHash
(
mozilla
:
:
AddToHash
(
aWindow
-
>
WindowID
(
)
mozilla
:
:
HashString
(
"
window
"
)
)
)
{
}
explicit
ContentBlockingAllowListKey
(
nsIHttpChannel
*
aChannel
)
:
mHash
(
mozilla
:
:
AddToHash
(
aChannel
-
>
ChannelId
(
)
mozilla
:
:
HashString
(
"
channel
"
)
)
)
{
}
ContentBlockingAllowListKey
(
const
ContentBlockingAllowListKey
&
aRHS
)
:
mHash
(
aRHS
.
mHash
)
{
}
bool
operator
=
=
(
const
ContentBlockingAllowListKey
&
aRHS
)
const
{
return
mHash
=
=
aRHS
.
mHash
;
}
HashNumber
GetHash
(
)
const
{
return
mHash
;
}
private
:
HashNumber
mHash
;
}
;
struct
ContentBlockingAllowListEntry
{
ContentBlockingAllowListEntry
(
)
:
mResult
(
false
)
{
}
ContentBlockingAllowListEntry
(
nsPIDOMWindowInner
*
aWindow
bool
aResult
)
:
mKey
(
aWindow
)
mResult
(
aResult
)
{
}
ContentBlockingAllowListEntry
(
nsIHttpChannel
*
aChannel
bool
aResult
)
:
mKey
(
aChannel
)
mResult
(
aResult
)
{
}
ContentBlockingAllowListKey
mKey
;
bool
mResult
;
}
;
struct
ContentBlockingAllowListCache
:
MruCache
<
ContentBlockingAllowListKey
ContentBlockingAllowListEntry
ContentBlockingAllowListCache
>
{
static
HashNumber
Hash
(
const
ContentBlockingAllowListKey
&
aKey
)
{
return
aKey
.
GetHash
(
)
;
}
static
bool
Match
(
const
ContentBlockingAllowListKey
&
aKey
const
ContentBlockingAllowListEntry
&
aValue
)
{
return
aValue
.
mKey
=
=
aKey
;
}
}
;
ContentBlockingAllowListCache
&
GetContentBlockingAllowListCache
(
)
{
static
bool
initialized
=
false
;
static
ContentBlockingAllowListCache
cache
;
if
(
!
initialized
)
{
AntiTrackingCommon
:
:
OnAntiTrackingSettingsChanged
(
[
&
]
{
cache
.
Clear
(
)
;
}
)
;
initialized
=
true
;
}
return
cache
;
}
bool
CheckContentBlockingAllowList
(
nsIURI
*
aTopWinURI
bool
aIsPrivateBrowsing
)
{
bool
isAllowed
=
false
;
nsresult
rv
=
AntiTrackingCommon
:
:
IsOnContentBlockingAllowList
(
aTopWinURI
aIsPrivateBrowsing
isAllowed
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isAllowed
)
{
LOG_SPEC
(
(
"
The
top
-
level
window
(
%
s
)
is
on
the
content
blocking
allow
list
"
"
bail
out
early
"
_spec
)
aTopWinURI
)
;
return
true
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG_SPEC
(
(
"
Checking
the
content
blocking
allow
list
for
%
s
failed
with
%
"
PRIx32
_spec
static_cast
<
uint32_t
>
(
rv
)
)
aTopWinURI
)
;
}
return
false
;
}
bool
CheckContentBlockingAllowList
(
nsPIDOMWindowInner
*
aWindow
)
{
ContentBlockingAllowListKey
cacheKey
(
aWindow
)
;
auto
entry
=
GetContentBlockingAllowListCache
(
)
.
Lookup
(
cacheKey
)
;
if
(
entry
)
{
return
entry
.
Data
(
)
.
mResult
;
}
nsPIDOMWindowOuter
*
top
=
aWindow
-
>
GetInProcessScriptableTop
(
)
;
if
(
top
)
{
nsIURI
*
topWinURI
=
top
-
>
GetDocumentURI
(
)
;
Document
*
doc
=
top
-
>
GetExtantDoc
(
)
;
bool
isPrivateBrowsing
=
doc
?
nsContentUtils
:
:
IsInPrivateBrowsing
(
doc
)
:
false
;
const
bool
result
=
CheckContentBlockingAllowList
(
topWinURI
isPrivateBrowsing
)
;
entry
.
Set
(
ContentBlockingAllowListEntry
(
aWindow
result
)
)
;
return
result
;
}
LOG
(
(
"
Could
not
check
the
content
blocking
allow
list
because
the
top
"
"
window
wasn
'
t
accessible
"
)
)
;
entry
.
Set
(
ContentBlockingAllowListEntry
(
aWindow
false
)
)
;
return
false
;
}
bool
CheckContentBlockingAllowList
(
nsIHttpChannel
*
aChannel
)
{
ContentBlockingAllowListKey
cacheKey
(
aChannel
)
;
auto
entry
=
GetContentBlockingAllowListCache
(
)
.
Lookup
(
cacheKey
)
;
if
(
entry
)
{
return
entry
.
Data
(
)
.
mResult
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsContentPolicyType
contentPolicyType
=
loadInfo
-
>
GetExternalContentPolicyType
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
{
nsresult
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
!
uri
)
{
LOG
(
(
"
Could
not
check
the
content
blocking
allow
list
because
the
"
"
channel
URI
is
not
accessible
"
)
)
;
entry
.
Set
(
ContentBlockingAllowListEntry
(
aChannel
false
)
)
;
return
false
;
}
}
else
{
nsCOMPtr
<
nsIHttpChannelInternal
>
chan
=
do_QueryInterface
(
aChannel
)
;
MOZ_ASSERT
(
chan
)
;
nsresult
rv
=
chan
-
>
GetTopWindowURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
uri
)
{
LOG
(
(
"
Could
not
check
the
content
blocking
allow
list
because
the
top
"
"
window
wasn
'
t
accessible
"
)
)
;
entry
.
Set
(
ContentBlockingAllowListEntry
(
aChannel
false
)
)
;
return
false
;
}
}
MOZ_ASSERT
(
uri
)
;
const
bool
result
=
CheckContentBlockingAllowList
(
uri
NS_UsePrivateBrowsing
(
aChannel
)
)
;
entry
.
Set
(
ContentBlockingAllowListEntry
(
aChannel
result
)
)
;
return
result
;
}
void
ReportBlockingToConsole
(
nsPIDOMWindowOuter
*
aWindow
nsIURI
*
aURI
uint32_t
aRejectedReason
)
{
MOZ_ASSERT
(
aWindow
&
&
aURI
)
;
MOZ_ASSERT
(
aRejectedReason
=
=
0
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_PARTITIONED_FOREIGN
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
;
if
(
NS_WARN_IF
(
!
docShell
)
)
{
return
;
}
RefPtr
<
Document
>
doc
=
docShell
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
;
}
nsAutoString
sourceLine
;
uint32_t
lineNumber
=
0
columnNumber
=
0
;
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
;
if
(
cx
)
{
nsJSUtils
:
:
GetCallingLocation
(
cx
sourceLine
&
lineNumber
&
columnNumber
)
;
}
nsCOMPtr
<
nsIURI
>
uri
(
aURI
)
;
nsresult
rv
=
NS_DispatchToCurrentThreadQueue
(
NS_NewRunnableFunction
(
"
ReportBlockingToConsoleDelayed
"
[
doc
sourceLine
lineNumber
columnNumber
uri
aRejectedReason
]
(
)
{
const
char
*
message
=
nullptr
;
nsAutoCString
category
;
switch
(
aRejectedReason
)
{
case
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
:
message
=
"
CookieBlockedByPermission
"
;
category
=
NS_LITERAL_CSTRING
(
"
cookieBlockedPermission
"
)
;
break
;
case
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
:
message
=
"
CookieBlockedTracker
"
;
category
=
NS_LITERAL_CSTRING
(
"
cookieBlockedTracker
"
)
;
break
;
case
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
:
message
=
"
CookieBlockedAll
"
;
category
=
NS_LITERAL_CSTRING
(
"
cookieBlockedAll
"
)
;
break
;
case
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
:
message
=
"
CookieBlockedForeign
"
;
category
=
NS_LITERAL_CSTRING
(
"
cookieBlockedForeign
"
)
;
break
;
default
:
return
;
}
MOZ_ASSERT
(
message
)
;
nsCOMPtr
<
nsIURIFixup
>
urifixup
=
services
:
:
GetURIFixup
(
)
;
NS_ENSURE_TRUE_VOID
(
urifixup
)
;
nsCOMPtr
<
nsIURI
>
exposableURI
;
nsresult
rv
=
urifixup
-
>
CreateExposableURI
(
uri
getter_AddRefs
(
exposableURI
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
AutoTArray
<
nsString
1
>
params
;
CopyUTF8toUTF16
(
exposableURI
-
>
GetSpecOrDefault
(
)
*
params
.
AppendElement
(
)
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
category
doc
nsContentUtils
:
:
eNECKO_PROPERTIES
message
params
nullptr
sourceLine
lineNumber
columnNumber
)
;
}
)
kMaxConsoleOutputDelayMs
EventQueuePriority
:
:
Idle
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
void
ReportUnblockingToConsole
(
nsPIDOMWindowInner
*
aWindow
const
nsAString
&
aTrackingOrigin
const
nsAString
&
aGrantedOrigin
AntiTrackingCommon
:
:
StorageAccessGrantedReason
aReason
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
nsGlobalWindowInner
:
:
Cast
(
aWindow
)
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
;
if
(
NS_WARN_IF
(
!
docShell
)
)
{
return
;
}
RefPtr
<
Document
>
doc
=
docShell
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
;
}
nsAutoString
trackingOrigin
(
aTrackingOrigin
)
;
nsAutoString
grantedOrigin
(
aGrantedOrigin
)
;
nsAutoString
sourceLine
;
uint32_t
lineNumber
=
0
columnNumber
=
0
;
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
;
if
(
cx
)
{
nsJSUtils
:
:
GetCallingLocation
(
cx
sourceLine
&
lineNumber
&
columnNumber
)
;
}
nsresult
rv
=
NS_DispatchToCurrentThreadQueue
(
NS_NewRunnableFunction
(
"
ReportUnblockingToConsoleDelayed
"
[
doc
principal
trackingOrigin
grantedOrigin
sourceLine
lineNumber
columnNumber
aReason
]
(
)
{
nsAutoString
origin
;
nsresult
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
principal
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
AutoTArray
<
nsString
3
>
params
=
{
origin
trackingOrigin
}
;
const
char
*
messageWithDifferentOrigin
=
nullptr
;
const
char
*
messageWithSameOrigin
=
nullptr
;
switch
(
aReason
)
{
case
AntiTrackingCommon
:
:
eStorageAccessAPI
:
messageWithDifferentOrigin
=
"
CookieAllowedForOriginOnTrackerByStorageAccessAPI
"
;
messageWithSameOrigin
=
"
CookieAllowedForTrackerByStorageAccessAPI
"
;
break
;
case
AntiTrackingCommon
:
:
eOpenerAfterUserInteraction
:
MOZ_FALLTHROUGH
;
case
AntiTrackingCommon
:
:
eOpener
:
messageWithDifferentOrigin
=
"
CookieAllowedForOriginOnTrackerByHeuristic
"
;
messageWithSameOrigin
=
"
CookieAllowedForTrackerByHeuristic
"
;
break
;
}
if
(
trackingOrigin
=
=
grantedOrigin
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Content
Blocking
"
)
doc
nsContentUtils
:
:
eNECKO_PROPERTIES
messageWithSameOrigin
params
nullptr
sourceLine
lineNumber
columnNumber
)
;
}
else
{
params
.
AppendElement
(
grantedOrigin
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Content
Blocking
"
)
doc
nsContentUtils
:
:
eNECKO_PROPERTIES
messageWithDifferentOrigin
params
nullptr
sourceLine
lineNumber
columnNumber
)
;
}
}
)
kMaxConsoleOutputDelayMs
EventQueuePriority
:
:
Idle
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
already_AddRefed
<
nsPIDOMWindowOuter
>
GetTopWindow
(
nsPIDOMWindowInner
*
aWindow
)
{
Document
*
document
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
!
document
)
{
return
nullptr
;
}
nsIChannel
*
channel
=
document
-
>
GetChannel
(
)
;
if
(
!
channel
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwin
;
auto
*
outer
=
nsGlobalWindowOuter
:
:
Cast
(
aWindow
-
>
GetOuterWindow
(
)
)
;
if
(
outer
)
{
pwin
=
outer
-
>
GetInProcessScriptableTop
(
)
;
}
if
(
!
pwin
)
{
return
nullptr
;
}
return
pwin
.
forget
(
)
;
}
class
TemporaryAccessGrantCacheKey
:
public
PLDHashEntryHdr
{
public
:
typedef
Pair
<
nsCOMPtr
<
nsIPrincipal
>
nsCString
>
KeyType
;
typedef
const
KeyType
*
KeyTypePointer
;
explicit
TemporaryAccessGrantCacheKey
(
KeyTypePointer
aKey
)
:
mPrincipal
(
aKey
-
>
first
(
)
)
mType
(
aKey
-
>
second
(
)
)
{
}
TemporaryAccessGrantCacheKey
(
TemporaryAccessGrantCacheKey
&
&
aOther
)
=
default
;
~
TemporaryAccessGrantCacheKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
MakePair
(
mPrincipal
mType
)
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
!
!
mPrincipal
=
=
!
!
aKey
-
>
first
(
)
&
&
mType
=
=
aKey
-
>
second
(
)
&
&
(
mPrincipal
?
(
mPrincipal
-
>
Equals
(
aKey
-
>
first
(
)
)
)
:
true
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
&
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
if
(
!
aKey
)
{
return
0
;
}
BasePrincipal
*
bp
=
BasePrincipal
:
:
Cast
(
aKey
-
>
first
(
)
)
;
return
HashGeneric
(
bp
-
>
GetOriginNoSuffixHash
(
)
bp
-
>
GetOriginSuffixHash
(
)
HashString
(
aKey
-
>
second
(
)
)
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCString
mType
;
}
;
class
TemporaryAccessGrantObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
static
void
Create
(
nsPermissionManager
*
aPM
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
sObservers
)
{
sObservers
=
MakeUnique
<
ObserversTable
>
(
)
;
}
Unused
<
<
sObservers
-
>
LookupForAdd
(
MakePair
(
nsCOMPtr
<
nsIPrincipal
>
(
aPrincipal
)
nsCString
(
aType
)
)
)
.
OrInsert
(
[
&
]
(
)
-
>
nsITimer
*
{
nsCOMPtr
<
nsITimer
>
timer
;
RefPtr
<
TemporaryAccessGrantObserver
>
observer
=
new
TemporaryAccessGrantObserver
(
aPM
aPrincipal
aType
)
;
nsresult
rv
=
NS_NewTimerWithObserver
(
getter_AddRefs
(
timer
)
observer
24
*
60
*
60
*
1000
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
observer
-
>
SetTimer
(
timer
)
;
return
timer
;
}
timer
-
>
Cancel
(
)
;
return
nullptr
;
}
)
;
}
void
SetTimer
(
nsITimer
*
aTimer
)
{
mTimer
=
aTimer
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
}
}
private
:
TemporaryAccessGrantObserver
(
nsPermissionManager
*
aPM
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
)
:
mPM
(
aPM
)
mPrincipal
(
aPrincipal
)
mType
(
aType
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Enforcing
temporary
access
grant
lifetimes
can
only
be
done
in
"
"
the
parent
process
"
)
;
}
~
TemporaryAccessGrantObserver
(
)
=
default
;
private
:
typedef
nsDataHashtable
<
TemporaryAccessGrantCacheKey
nsCOMPtr
<
nsITimer
>
>
ObserversTable
;
static
UniquePtr
<
ObserversTable
>
sObservers
;
nsCOMPtr
<
nsITimer
>
mTimer
;
RefPtr
<
nsPermissionManager
>
mPM
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCString
mType
;
}
;
UniquePtr
<
TemporaryAccessGrantObserver
:
:
ObserversTable
>
TemporaryAccessGrantObserver
:
:
sObservers
;
NS_IMPL_ISUPPORTS
(
TemporaryAccessGrantObserver
nsIObserver
)
NS_IMETHODIMP
TemporaryAccessGrantObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
NS_TIMER_CALLBACK_TOPIC
)
=
=
0
)
{
Unused
<
<
mPM
-
>
RemoveFromPrincipal
(
mPrincipal
mType
)
;
MOZ_ASSERT
(
sObservers
)
;
sObservers
-
>
Remove
(
MakePair
(
mPrincipal
mType
)
)
;
}
else
if
(
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
sObservers
.
reset
(
)
;
}
return
NS_OK
;
}
class
SettingsChangeObserver
final
:
public
nsIObserver
{
~
SettingsChangeObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
static
void
PrivacyPrefChanged
(
const
char
*
aPref
=
nullptr
void
*
=
nullptr
)
;
private
:
static
void
RunAntiTrackingSettingsChangedCallbacks
(
)
;
}
;
NS_IMPL_ISUPPORTS
(
SettingsChangeObserver
nsIObserver
)
NS_IMETHODIMP
SettingsChangeObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
perm
-
added
"
)
;
obs
-
>
RemoveObserver
(
this
"
perm
-
changed
"
)
;
obs
-
>
RemoveObserver
(
this
"
perm
-
cleared
"
)
;
obs
-
>
RemoveObserver
(
this
"
perm
-
deleted
"
)
;
obs
-
>
RemoveObserver
(
this
"
xpcom
-
shutdown
"
)
;
Preferences
:
:
UnregisterPrefixCallback
(
SettingsChangeObserver
:
:
PrivacyPrefChanged
"
browser
.
contentblocking
.
"
)
;
Preferences
:
:
UnregisterPrefixCallback
(
SettingsChangeObserver
:
:
PrivacyPrefChanged
"
network
.
cookie
.
"
)
;
Preferences
:
:
UnregisterPrefixCallback
(
SettingsChangeObserver
:
:
PrivacyPrefChanged
"
privacy
.
"
)
;
gSettingsChangedCallbacks
=
nullptr
;
}
}
else
{
nsCOMPtr
<
nsIPermission
>
perm
=
do_QueryInterface
(
aSubject
)
;
if
(
perm
)
{
nsAutoCString
type
;
nsresult
rv
=
perm
-
>
GetType
(
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
type
.
Equals
(
USER_INTERACTION_PERM
)
)
{
return
NS_OK
;
}
}
RunAntiTrackingSettingsChangedCallbacks
(
)
;
}
return
NS_OK
;
}
void
SettingsChangeObserver
:
:
PrivacyPrefChanged
(
const
char
*
aPref
void
*
aClosure
)
{
RunAntiTrackingSettingsChangedCallbacks
(
)
;
}
void
SettingsChangeObserver
:
:
RunAntiTrackingSettingsChangedCallbacks
(
)
{
if
(
gSettingsChangedCallbacks
)
{
for
(
auto
&
callback
:
*
gSettingsChangedCallbacks
)
{
callback
(
)
;
}
}
}
bool
CheckAntiTrackingPermission
(
nsIPrincipal
*
aPrincipal
const
nsAutoCString
&
aType
bool
aIsInPrivateBrowsing
uint32_t
*
aRejectedReason
uint32_t
aBlockedReason
nsIURI
*
aPrincipalURI
)
{
nsPermissionManager
*
permManager
=
nsPermissionManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
permManager
)
)
{
LOG
(
(
"
Failed
to
obtain
the
permission
manager
"
)
)
;
return
false
;
}
uint32_t
result
=
0
;
if
(
aIsInPrivateBrowsing
)
{
LOG_SPEC
(
(
"
Querying
the
permissions
for
private
modei
looking
for
a
"
"
permission
of
type
%
s
for
%
s
"
aType
.
get
(
)
_spec
)
aPrincipalURI
)
;
nsCOMPtr
<
nsISimpleEnumerator
>
se
;
nsresult
rv
=
permManager
-
>
GetAllForPrincipal
(
aPrincipal
getter_AddRefs
(
se
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
Failed
to
get
the
list
of
permissions
"
)
)
;
return
false
;
}
bool
more
=
false
;
bool
found
=
false
;
while
(
NS_SUCCEEDED
(
se
-
>
HasMoreElements
(
&
more
)
)
&
&
more
)
{
nsCOMPtr
<
nsISupports
>
supports
;
Unused
<
<
se
-
>
GetNext
(
getter_AddRefs
(
supports
)
)
;
nsCOMPtr
<
nsIPermission
>
permission
=
do_QueryInterface
(
supports
)
;
if
(
!
permission
)
{
LOG
(
(
"
Couldn
'
t
get
the
permission
for
unknown
reasons
"
)
)
;
continue
;
}
nsAutoCString
permissionType
;
if
(
NS_SUCCEEDED
(
permission
-
>
GetType
(
permissionType
)
)
&
&
permissionType
!
=
aType
)
{
LOG
(
(
"
Non
-
matching
permission
type
:
%
s
"
aType
.
get
(
)
)
)
;
continue
;
}
uint32_t
capability
=
0
;
if
(
NS_SUCCEEDED
(
permission
-
>
GetCapability
(
&
capability
)
)
&
&
capability
!
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
LOG
(
(
"
Non
-
matching
permission
capability
:
%
d
"
capability
)
)
;
continue
;
}
uint32_t
expirationType
=
0
;
if
(
NS_SUCCEEDED
(
permission
-
>
GetExpireType
(
&
expirationType
)
)
&
&
expirationType
!
=
nsIPermissionManager
:
:
EXPIRE_SESSION
)
{
LOG
(
(
"
Non
-
matching
permission
expiration
type
:
%
d
"
expirationType
)
)
;
continue
;
}
int64_t
expirationTime
=
0
;
if
(
NS_SUCCEEDED
(
permission
-
>
GetExpireTime
(
&
expirationTime
)
)
&
&
expirationTime
!
=
0
)
{
LOG
(
(
"
Non
-
matching
permission
expiration
time
:
%
"
PRId64
expirationTime
)
)
;
continue
;
}
LOG
(
(
"
Found
a
matching
permission
"
)
)
;
found
=
true
;
}
if
(
!
found
)
{
if
(
aRejectedReason
)
{
*
aRejectedReason
=
aBlockedReason
;
}
return
false
;
}
}
else
{
nsresult
rv
=
permManager
-
>
TestPermissionWithoutDefaultsFromPrincipal
(
aPrincipal
aType
&
result
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
Failed
to
test
the
permission
"
)
)
;
return
false
;
}
LOG_SPEC
(
(
"
Testing
permission
type
%
s
for
%
s
resulted
in
%
d
(
%
s
)
"
aType
.
get
(
)
_spec
int
(
result
)
result
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
?
"
success
"
:
"
failure
"
)
aPrincipalURI
)
;
if
(
result
!
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
if
(
aRejectedReason
)
{
*
aRejectedReason
=
aBlockedReason
;
}
return
false
;
}
}
return
true
;
}
}
RefPtr
<
AntiTrackingCommon
:
:
StorageAccessGrantPromise
>
AntiTrackingCommon
:
:
AddFirstPartyStorageAccessGrantedFor
(
nsIPrincipal
*
aPrincipal
nsPIDOMWindowInner
*
aParentWindow
StorageAccessGrantedReason
aReason
const
AntiTrackingCommon
:
:
PerformFinalChecks
&
aPerformFinalChecks
)
{
MOZ_ASSERT
(
aParentWindow
)
;
nsCOMPtr
<
nsIURI
>
uri
;
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
!
uri
)
)
{
LOG
(
(
"
Can
'
t
get
the
URI
from
the
principal
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
nsAutoCString
origin
;
nsresult
rv
=
nsContentUtils
:
:
GetASCIIOrigin
(
uri
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
Can
'
t
get
the
origin
from
the
URI
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
LOG
(
(
"
Adding
a
first
-
party
storage
exception
for
%
s
.
.
.
"
PromiseFlatCString
(
origin
)
.
get
(
)
)
)
;
Document
*
parentDoc
=
aParentWindow
-
>
GetExtantDoc
(
)
;
if
(
!
parentDoc
)
{
LOG
(
(
"
Parent
window
has
no
doc
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
int32_t
behavior
=
parentDoc
-
>
CookieSettings
(
)
-
>
GetCookieBehavior
(
)
;
if
(
!
parentDoc
-
>
CookieSettings
(
)
-
>
GetRejectThirdPartyTrackers
(
)
)
{
LOG
(
(
"
Disabled
by
network
.
cookie
.
cookieBehavior
pref
(
%
d
)
bailing
out
"
"
early
"
behavior
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
MOZ_ASSERT
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
|
|
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
if
(
CheckContentBlockingAllowList
(
aParentWindow
)
)
{
return
StorageAccessGrantPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
nsCOMPtr
<
nsIPrincipal
>
topLevelStoragePrincipal
;
nsCOMPtr
<
nsIURI
>
trackingURI
;
nsAutoCString
trackingOrigin
;
nsCOMPtr
<
nsIPrincipal
>
trackingPrincipal
;
RefPtr
<
nsGlobalWindowInner
>
parentWindow
=
nsGlobalWindowInner
:
:
Cast
(
aParentWindow
)
;
nsGlobalWindowOuter
*
outerParentWindow
=
nsGlobalWindowOuter
:
:
Cast
(
parentWindow
-
>
GetOuterWindow
(
)
)
;
if
(
NS_WARN_IF
(
!
outerParentWindow
)
)
{
LOG
(
(
"
No
outer
window
found
for
our
parent
window
bailing
out
early
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
LOG
(
(
"
The
current
resource
is
%
s
-
party
"
outerParentWindow
-
>
IsTopLevelWindow
(
)
?
"
first
"
:
"
third
"
)
)
;
if
(
outerParentWindow
-
>
IsTopLevelWindow
(
)
)
{
trackingOrigin
=
origin
;
trackingPrincipal
=
aPrincipal
;
rv
=
trackingPrincipal
-
>
GetURI
(
getter_AddRefs
(
trackingURI
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
Couldn
'
t
get
the
tracking
principal
URI
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
topLevelStoragePrincipal
=
parentWindow
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
topLevelStoragePrincipal
)
)
{
LOG
(
(
"
Top
-
level
storage
area
principal
not
found
bailing
out
early
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
}
else
{
bool
isThirdParty
=
false
;
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
{
isThirdParty
=
nsContentUtils
:
:
IsThirdPartyTrackingResourceWindow
(
parentWindow
)
;
}
else
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
{
isThirdParty
=
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
parentWindow
nullptr
nullptr
)
;
}
if
(
!
isThirdParty
)
{
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
{
LOG
(
(
"
Our
window
isn
'
t
a
third
-
party
tracking
window
"
)
)
;
}
else
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
{
LOG
(
(
"
Our
window
isn
'
t
a
third
-
party
window
"
)
)
;
}
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
!
GetParentPrincipalAndTrackingOrigin
(
parentWindow
behavior
getter_AddRefs
(
topLevelStoragePrincipal
)
trackingOrigin
getter_AddRefs
(
trackingURI
)
getter_AddRefs
(
trackingPrincipal
)
)
)
{
LOG
(
(
"
Error
while
computing
the
parent
principal
and
tracking
origin
"
"
bailing
out
early
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
topOuterWindow
=
outerParentWindow
-
>
GetInProcessTop
(
)
;
nsGlobalWindowOuter
*
topWindow
=
nsGlobalWindowOuter
:
:
Cast
(
topOuterWindow
)
;
if
(
NS_WARN_IF
(
!
topWindow
)
)
{
LOG
(
(
"
No
top
outer
window
.
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
nsPIDOMWindowInner
*
topInnerWindow
=
topWindow
-
>
GetCurrentInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
topInnerWindow
)
)
{
LOG
(
(
"
No
top
inner
window
.
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
enum
:
uint32_t
{
blockReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
}
;
if
(
nsContentUtils
:
:
IsURIInPrefList
(
trackingURI
"
privacy
.
restrict3rdpartystorage
.
"
"
userInteractionRequiredForHosts
"
)
&
&
!
HasUserInteraction
(
trackingPrincipal
)
)
{
LOG_SPEC
(
(
"
Tracking
principal
(
%
s
)
hasn
'
t
been
interacted
with
before
"
"
refusing
to
add
a
first
-
party
storage
permission
to
access
it
"
_spec
)
trackingURI
)
;
NotifyBlockingDecision
(
aParentWindow
BlockingDecision
:
:
eBlock
blockReason
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwin
=
GetTopWindow
(
parentWindow
)
;
if
(
!
pwin
)
{
LOG
(
(
"
Couldn
'
t
get
the
top
window
"
)
)
;
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
auto
storePermission
=
[
pwin
parentWindow
origin
trackingOrigin
trackingPrincipal
trackingURI
topInnerWindow
topLevelStoragePrincipal
aReason
]
(
int
aAllowMode
)
-
>
RefPtr
<
StorageAccessGrantPromise
>
{
nsAutoCString
permissionKey
;
CreatePermissionKey
(
trackingOrigin
origin
permissionKey
)
;
topInnerWindow
-
>
SaveStorageAccessGranted
(
permissionKey
)
;
parentWindow
-
>
StorageAccessGranted
(
)
;
nsIChannel
*
channel
=
pwin
-
>
GetCurrentInnerWindow
(
)
-
>
GetExtantDoc
(
)
-
>
GetChannel
(
)
;
pwin
-
>
NotifyContentBlockingEvent
(
blockReason
channel
false
trackingURI
parentWindow
-
>
GetExtantDoc
(
)
-
>
GetChannel
(
)
Some
(
aReason
)
)
;
ReportUnblockingToConsole
(
parentWindow
NS_ConvertUTF8toUTF16
(
trackingOrigin
)
NS_ConvertUTF8toUTF16
(
origin
)
aReason
)
;
if
(
XRE_IsParentProcess
(
)
)
{
LOG
(
(
"
Saving
the
permission
:
trackingOrigin
=
%
s
grantedOrigin
=
%
s
"
trackingOrigin
.
get
(
)
origin
.
get
(
)
)
)
;
return
SaveFirstPartyStorageAccessGrantedForOriginOnParentProcess
(
topLevelStoragePrincipal
trackingPrincipal
trackingOrigin
origin
aAllowMode
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
]
(
FirstPartyStorageAccessGrantPromise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
return
StorageAccessGrantPromise
:
:
CreateAndResolve
(
NS_SUCCEEDED
(
aValue
.
ResolveValue
(
)
)
?
eAllowOnAnySite
:
eAllow
__func__
)
;
}
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cc
)
;
LOG
(
(
"
Asking
the
parent
process
to
save
the
permission
for
us
:
"
"
trackingOrigin
=
%
s
grantedOrigin
=
%
s
"
trackingOrigin
.
get
(
)
origin
.
get
(
)
)
)
;
return
cc
-
>
SendFirstPartyStorageAccessGrantedForOrigin
(
IPC
:
:
Principal
(
topLevelStoragePrincipal
)
IPC
:
:
Principal
(
trackingPrincipal
)
trackingOrigin
origin
aAllowMode
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
]
(
const
ContentChild
:
:
FirstPartyStorageAccessGrantedForOriginPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
return
StorageAccessGrantPromise
:
:
CreateAndResolve
(
aValue
.
ResolveValue
(
)
__func__
)
;
}
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
;
if
(
aPerformFinalChecks
)
{
return
aPerformFinalChecks
(
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
storePermission
]
(
StorageAccessGrantPromise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
return
storePermission
(
aValue
.
ResolveValue
(
)
)
;
}
return
StorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
return
storePermission
(
false
)
;
}
RefPtr
<
mozilla
:
:
AntiTrackingCommon
:
:
FirstPartyStorageAccessGrantPromise
>
AntiTrackingCommon
:
:
SaveFirstPartyStorageAccessGrantedForOriginOnParentProcess
(
nsIPrincipal
*
aParentPrincipal
nsIPrincipal
*
aTrackingPrincipal
const
nsCString
&
aTrackingOrigin
const
nsCString
&
aGrantedOrigin
int
aAllowMode
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
aAllowMode
=
=
eAllow
|
|
aAllowMode
=
=
eAllowAutoGrant
|
|
aAllowMode
=
=
eAllowOnAnySite
)
;
nsCOMPtr
<
nsIURI
>
parentPrincipalURI
;
Unused
<
<
aParentPrincipal
-
>
GetURI
(
getter_AddRefs
(
parentPrincipalURI
)
)
;
LOG_SPEC
(
(
"
Saving
a
first
-
party
storage
permission
on
%
s
for
"
"
trackingOrigin
=
%
s
grantedOrigin
=
%
s
"
_spec
aTrackingOrigin
.
get
(
)
aGrantedOrigin
.
get
(
)
)
parentPrincipalURI
)
;
if
(
NS_WARN_IF
(
!
aParentPrincipal
)
)
{
LOG
(
(
"
aParentPrincipal
is
null
bailing
out
early
"
)
)
;
return
FirstPartyStorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
nsPermissionManager
*
permManager
=
nsPermissionManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
permManager
)
)
{
LOG
(
(
"
Permission
manager
is
null
bailing
out
early
"
)
)
;
return
FirstPartyStorageAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
uint32_t
expirationType
=
nsIPermissionManager
:
:
EXPIRE_TIME
;
uint32_t
expirationTime
=
StaticPrefs
:
:
privacy_restrict3rdpartystorage_expiration
(
)
*
1000
;
int64_t
when
=
(
PR_Now
(
)
/
PR_USEC_PER_MSEC
)
+
expirationTime
;
nsresult
rv
;
if
(
aAllowMode
=
=
eAllowOnAnySite
)
{
uint32_t
privateBrowsingId
=
0
;
rv
=
aTrackingPrincipal
-
>
GetPrivateBrowsingId
(
&
privateBrowsingId
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
&
&
privateBrowsingId
>
0
)
{
expirationType
=
nsIPermissionManager
:
:
EXPIRE_SESSION
;
when
=
0
;
}
LOG
(
(
"
Setting
'
any
site
'
permission
expiry
:
%
u
proceeding
to
save
in
the
"
"
permission
manager
"
expirationTime
)
)
;
rv
=
permManager
-
>
AddFromPrincipal
(
aTrackingPrincipal
NS_LITERAL_CSTRING
(
"
cookie
"
)
nsICookiePermission
:
:
ACCESS_ALLOW
expirationType
when
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
uint32_t
privateBrowsingId
=
0
;
rv
=
aParentPrincipal
-
>
GetPrivateBrowsingId
(
&
privateBrowsingId
)
;
if
(
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
&
&
privateBrowsingId
>
0
)
|
|
(
aAllowMode
=
=
eAllowAutoGrant
)
)
{
expirationType
=
nsIPermissionManager
:
:
EXPIRE_SESSION
;
when
=
0
;
}
nsAutoCString
type
;
CreatePermissionKey
(
aTrackingOrigin
aGrantedOrigin
type
)
;
LOG
(
(
"
Computed
permission
key
:
%
s
expiry
:
%
u
proceeding
to
save
in
the
"
"
permission
manager
"
type
.
get
(
)
expirationTime
)
)
;
rv
=
permManager
-
>
AddFromPrincipal
(
aParentPrincipal
type
nsIPermissionManager
:
:
ALLOW_ACTION
expirationType
when
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
aAllowMode
=
=
eAllowAutoGrant
)
)
{
TemporaryAccessGrantObserver
:
:
Create
(
permManager
aParentPrincipal
type
)
;
}
LOG
(
(
"
Result
:
%
s
"
NS_SUCCEEDED
(
rv
)
?
"
success
"
:
"
failure
"
)
)
;
return
FirstPartyStorageAccessGrantPromise
:
:
CreateAndResolve
(
rv
__func__
)
;
}
bool
AntiTrackingCommon
:
:
CreateStoragePermissionKey
(
nsIPrincipal
*
aPrincipal
nsACString
&
aKey
)
{
MOZ_ASSERT
(
aPrincipal
)
;
nsAutoCString
origin
;
nsresult
rv
=
aPrincipal
-
>
GetOriginNoSuffix
(
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
CreatePermissionKey
(
origin
aKey
)
;
return
true
;
}
bool
AntiTrackingCommon
:
:
IsStorageAccessPermission
(
nsIPermission
*
aPermission
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aPermission
)
;
MOZ_ASSERT
(
aPrincipal
)
;
nsAutoCString
permissionKey
;
bool
result
=
CreateStoragePermissionKey
(
aPrincipal
permissionKey
)
;
if
(
NS_WARN_IF
(
!
result
)
)
{
return
false
;
}
nsAutoCString
type
;
nsresult
rv
=
aPermission
-
>
GetType
(
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
StringBeginsWith
(
type
permissionKey
)
;
}
bool
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
nsPIDOMWindowInner
*
aWindow
nsIURI
*
aURI
uint32_t
*
aRejectedReason
)
{
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
aURI
)
;
uint32_t
rejectedReason
=
0
;
if
(
!
aRejectedReason
)
{
aRejectedReason
=
&
rejectedReason
;
}
LOG_SPEC
(
(
"
Computing
whether
window
%
p
has
access
to
URI
%
s
"
aWindow
_spec
)
aURI
)
;
nsGlobalWindowInner
*
innerWindow
=
nsGlobalWindowInner
:
:
Cast
(
aWindow
)
;
Document
*
document
=
innerWindow
-
>
GetExtantDoc
(
)
;
if
(
!
document
)
{
LOG
(
(
"
Our
window
has
no
document
"
)
)
;
return
false
;
}
nsGlobalWindowOuter
*
outerWindow
=
nsGlobalWindowOuter
:
:
Cast
(
aWindow
-
>
GetOuterWindow
(
)
)
;
if
(
!
outerWindow
)
{
LOG
(
(
"
Our
window
has
no
outer
window
"
)
)
;
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
topOuterWindow
=
outerWindow
-
>
GetInProcessTop
(
)
;
nsGlobalWindowOuter
*
topWindow
=
nsGlobalWindowOuter
:
:
Cast
(
topOuterWindow
)
;
if
(
NS_WARN_IF
(
!
topWindow
)
)
{
LOG
(
(
"
No
top
outer
window
"
)
)
;
return
false
;
}
nsPIDOMWindowInner
*
topInnerWindow
=
topWindow
-
>
GetCurrentInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
topInnerWindow
)
)
{
LOG
(
(
"
No
top
inner
window
.
"
)
)
;
return
false
;
}
Document
*
toplevelDocument
=
topInnerWindow
-
>
GetExtantDoc
(
)
;
if
(
!
toplevelDocument
)
{
LOG
(
(
"
No
top
level
document
.
"
)
)
;
return
false
;
}
MOZ_ASSERT
(
toplevelDocument
)
;
uint32_t
cookiePermission
=
CheckCookiePermissionForPrincipal
(
document
-
>
CookieSettings
(
)
document
-
>
NodePrincipal
(
)
)
;
if
(
cookiePermission
!
=
nsICookiePermission
:
:
ACCESS_DEFAULT
)
{
LOG
(
(
"
CheckCookiePermissionForPrincipal
(
)
returned
a
non
-
default
access
"
"
code
(
%
d
)
for
window
'
s
principal
returning
%
s
"
int
(
cookiePermission
)
cookiePermission
!
=
nsICookiePermission
:
:
ACCESS_DENY
?
"
success
"
:
"
failure
"
)
)
;
if
(
cookiePermission
!
=
nsICookiePermission
:
:
ACCESS_DENY
)
{
return
true
;
}
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
;
return
false
;
}
int32_t
behavior
=
CookiesBehavior
(
toplevelDocument
document
)
;
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_ACCEPT
)
{
LOG
(
(
"
The
cookie
behavior
pref
mandates
accepting
all
cookies
!
"
)
)
;
return
true
;
}
if
(
CheckContentBlockingAllowList
(
aWindow
)
)
{
return
true
;
}
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT
)
{
LOG
(
(
"
The
cookie
behavior
pref
mandates
rejecting
all
cookies
!
"
)
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
;
return
false
;
}
if
(
behavior
!
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
&
&
behavior
!
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
{
if
(
!
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
aWindow
nullptr
aURI
)
)
{
LOG
(
(
"
Our
window
isn
'
t
a
third
-
party
window
"
)
)
;
return
true
;
}
}
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_FOREIGN
|
|
behavior
=
=
nsICookieService
:
:
BEHAVIOR_LIMIT_FOREIGN
)
{
LOG
(
(
"
Nothing
more
to
do
due
to
the
behavior
code
%
d
"
int
(
behavior
)
)
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
false
;
}
MOZ_ASSERT
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
|
|
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
uint32_t
blockedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
;
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
{
if
(
!
nsContentUtils
:
:
IsThirdPartyTrackingResourceWindow
(
aWindow
)
)
{
LOG
(
(
"
Our
window
isn
'
t
a
third
-
party
tracking
window
"
)
)
;
return
true
;
}
}
else
{
MOZ_ASSERT
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
if
(
nsContentUtils
:
:
IsThirdPartyTrackingResourceWindow
(
aWindow
)
)
{
}
else
if
(
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
aWindow
nullptr
aURI
)
)
{
LOG
(
(
"
We
'
re
in
the
third
-
party
context
storage
should
be
partitioned
"
)
)
;
blockedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_PARTITIONED_FOREIGN
;
}
else
{
LOG
(
(
"
Our
window
isn
'
t
a
third
-
party
window
storage
is
allowed
"
)
)
;
return
true
;
}
}
#
ifdef
DEBUG
nsCOMPtr
<
mozIThirdPartyUtil
>
thirdPartyUtil
=
services
:
:
GetThirdPartyUtil
(
)
;
if
(
thirdPartyUtil
)
{
bool
thirdParty
=
false
;
nsresult
rv
=
thirdPartyUtil
-
>
IsThirdPartyWindow
(
aWindow
-
>
GetOuterWindow
(
)
aURI
&
thirdParty
)
;
MOZ_ASSERT_IF
(
NS_SUCCEEDED
(
rv
)
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
aWindow
nullptr
aURI
)
=
=
thirdParty
)
;
}
#
endif
nsCOMPtr
<
nsIPrincipal
>
parentPrincipal
;
nsCOMPtr
<
nsIURI
>
parentPrincipalURI
;
nsCOMPtr
<
nsIURI
>
trackingURI
;
nsAutoCString
trackingOrigin
;
if
(
!
GetParentPrincipalAndTrackingOrigin
(
nsGlobalWindowInner
:
:
Cast
(
aWindow
)
behavior
getter_AddRefs
(
parentPrincipal
)
trackingOrigin
getter_AddRefs
(
trackingURI
)
nullptr
)
)
{
LOG
(
(
"
Failed
to
obtain
the
parent
principal
and
the
tracking
origin
"
)
)
;
*
aRejectedReason
=
blockedReason
;
return
false
;
}
Unused
<
<
parentPrincipal
-
>
GetURI
(
getter_AddRefs
(
parentPrincipalURI
)
)
;
nsAutoCString
grantedOrigin
;
nsresult
rv
=
nsContentUtils
:
:
GetASCIIOrigin
(
aURI
grantedOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG_SPEC
(
(
"
Failed
to
compute
the
origin
from
%
s
"
_spec
)
aURI
)
;
return
false
;
}
nsAutoCString
type
;
CreatePermissionKey
(
trackingOrigin
grantedOrigin
type
)
;
if
(
topInnerWindow
-
>
HasStorageAccessGranted
(
type
)
)
{
LOG
(
(
"
Permission
stored
in
the
window
.
All
good
.
"
)
)
;
return
true
;
}
return
CheckAntiTrackingPermission
(
parentPrincipal
type
nsContentUtils
:
:
IsInPrivateBrowsing
(
document
)
aRejectedReason
blockedReason
parentPrincipalURI
)
;
}
bool
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
nsIChannel
*
aChannel
nsIURI
*
aURI
uint32_t
*
aRejectedReason
)
{
MOZ_ASSERT
(
aURI
)
;
MOZ_ASSERT
(
aChannel
)
;
uint32_t
rejectedReason
=
0
;
if
(
!
aRejectedReason
)
{
aRejectedReason
=
&
rejectedReason
;
}
nsIScriptSecurityManager
*
ssm
=
nsScriptSecurityManager
:
:
GetScriptSecurityManager
(
)
;
MOZ_ASSERT
(
ssm
)
;
nsCOMPtr
<
nsIURI
>
channelURI
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
get
the
channel
final
URI
bail
out
early
"
)
)
;
return
true
;
}
LOG_SPEC
(
(
"
Computing
whether
channel
%
p
has
access
to
URI
%
s
"
aChannel
_spec
)
channelURI
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsCOMPtr
<
nsIPrincipal
>
toplevelPrincipal
=
loadInfo
-
>
GetTopLevelPrincipal
(
)
;
if
(
!
toplevelPrincipal
)
{
LOG
(
(
"
Our
loadInfo
lacks
a
top
-
level
principal
use
the
loadInfo
'
s
loading
"
"
principal
instead
"
)
)
;
toplevelPrincipal
=
loadInfo
-
>
LoadingPrincipal
(
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
!
toplevelPrincipal
)
{
LOG
(
(
"
We
don
'
t
have
a
loading
principal
let
'
s
see
if
this
is
a
document
"
"
channel
"
"
that
belongs
to
a
top
-
level
window
"
)
)
;
bool
isDocument
=
false
;
if
(
httpChannel
)
{
rv
=
httpChannel
-
>
GetIsMainDocumentChannel
(
&
isDocument
)
;
}
if
(
httpChannel
&
&
NS_SUCCEEDED
(
rv
)
&
&
isDocument
)
{
rv
=
ssm
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
toplevelPrincipal
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
Yes
we
guessed
right
!
"
)
)
;
}
else
{
LOG
(
(
"
Yes
we
guessed
right
but
minting
the
channel
result
principal
"
"
failed
"
)
)
;
}
}
else
{
LOG
(
(
"
No
we
guessed
wrong
!
"
)
)
;
}
}
if
(
!
toplevelPrincipal
)
{
LOG
(
(
"
Our
loadInfo
lacks
a
top
-
level
principal
use
the
loadInfo
'
s
"
"
triggering
principal
instead
"
)
)
;
toplevelPrincipal
=
loadInfo
-
>
TriggeringPrincipal
(
)
;
}
if
(
NS_WARN_IF
(
!
toplevelPrincipal
)
)
{
LOG
(
(
"
No
top
-
level
principal
!
Bail
out
early
"
)
)
;
return
false
;
}
nsCOMPtr
<
nsICookieSettings
>
cookieSettings
;
rv
=
loadInfo
-
>
GetCookieSettings
(
getter_AddRefs
(
cookieSettings
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
Failed
to
get
the
cookie
settings
from
the
loadinfo
bail
out
"
"
early
"
)
)
;
return
true
;
}
nsCOMPtr
<
nsIPrincipal
>
channelPrincipal
;
rv
=
ssm
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
channelPrincipal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
No
channel
principal
bail
out
early
"
)
)
;
return
false
;
}
uint32_t
cookiePermission
=
CheckCookiePermissionForPrincipal
(
cookieSettings
channelPrincipal
)
;
if
(
cookiePermission
!
=
nsICookiePermission
:
:
ACCESS_DEFAULT
)
{
LOG
(
(
"
CheckCookiePermissionForPrincipal
(
)
returned
a
non
-
default
access
"
"
code
(
%
d
)
for
channel
'
s
principal
returning
%
s
"
int
(
cookiePermission
)
cookiePermission
!
=
nsICookiePermission
:
:
ACCESS_DENY
?
"
success
"
:
"
failure
"
)
)
;
if
(
cookiePermission
!
=
nsICookiePermission
:
:
ACCESS_DENY
)
{
return
true
;
}
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
;
return
false
;
}
if
(
!
channelURI
)
{
LOG
(
(
"
No
channel
uri
bail
out
early
"
)
)
;
return
false
;
}
int32_t
behavior
=
CookiesBehavior
(
loadInfo
toplevelPrincipal
channelURI
)
;
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_ACCEPT
)
{
LOG
(
(
"
The
cookie
behavior
pref
mandates
accepting
all
cookies
!
"
)
)
;
return
true
;
}
if
(
httpChannel
&
&
CheckContentBlockingAllowList
(
httpChannel
)
)
{
return
true
;
}
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT
)
{
LOG
(
(
"
The
cookie
behavior
pref
mandates
rejecting
all
cookies
!
"
)
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
;
return
false
;
}
nsCOMPtr
<
mozIThirdPartyUtil
>
thirdPartyUtil
=
services
:
:
GetThirdPartyUtil
(
)
;
if
(
!
thirdPartyUtil
)
{
LOG
(
(
"
No
thirdPartyUtil
bail
out
early
"
)
)
;
return
true
;
}
bool
thirdParty
=
false
;
rv
=
thirdPartyUtil
-
>
IsThirdPartyChannel
(
aChannel
aURI
&
thirdParty
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
thirdParty
)
{
LOG
(
(
"
Our
channel
isn
'
t
a
third
-
party
channel
"
)
)
;
return
true
;
}
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_FOREIGN
|
|
behavior
=
=
nsICookieService
:
:
BEHAVIOR_LIMIT_FOREIGN
)
{
LOG
(
(
"
Nothing
more
to
do
due
to
the
behavior
code
%
d
"
int
(
behavior
)
)
)
;
*
aRejectedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
;
return
false
;
}
MOZ_ASSERT
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
|
|
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
uint32_t
blockedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
;
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
{
if
(
httpChannel
&
&
!
httpChannel
-
>
IsThirdPartyTrackingResource
(
)
)
{
LOG
(
(
"
Our
channel
isn
'
t
a
third
-
party
tracking
channel
"
)
)
;
return
true
;
}
}
else
{
MOZ_ASSERT
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
if
(
httpChannel
&
&
httpChannel
-
>
IsThirdPartyTrackingResource
(
)
)
{
}
else
if
(
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
nullptr
aChannel
aURI
)
)
{
LOG
(
(
"
We
'
re
in
the
third
-
party
context
storage
should
be
partitioned
"
)
)
;
blockedReason
=
nsIWebProgressListener
:
:
STATE_COOKIES_PARTITIONED_FOREIGN
;
}
else
{
LOG
(
(
"
Our
channel
isn
'
t
a
third
-
party
channel
storage
is
allowed
"
)
)
;
return
true
;
}
}
nsIPrincipal
*
parentPrincipal
=
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
?
loadInfo
-
>
GetTopLevelStorageAreaPrincipal
(
)
:
loadInfo
-
>
GetTopLevelPrincipal
(
)
;
if
(
!
parentPrincipal
)
{
LOG
(
(
"
No
top
-
level
storage
area
principal
at
hand
"
)
)
;
if
(
loadInfo
-
>
GetTopLevelPrincipal
(
)
)
{
LOG
(
(
"
Parent
window
is
the
top
-
level
window
bail
out
early
"
)
)
;
*
aRejectedReason
=
blockedReason
;
return
false
;
}
parentPrincipal
=
toplevelPrincipal
;
if
(
NS_WARN_IF
(
!
parentPrincipal
)
)
{
LOG
(
(
"
No
triggering
principal
this
shouldn
'
t
be
happening
!
Bail
out
"
"
early
"
)
)
;
return
true
;
}
}
nsCOMPtr
<
nsIURI
>
parentPrincipalURI
;
Unused
<
<
parentPrincipal
-
>
GetURI
(
getter_AddRefs
(
parentPrincipalURI
)
)
;
nsCOMPtr
<
nsIURI
>
trackingURI
;
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
trackingURI
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
Failed
to
get
the
channel
URI
"
)
)
;
return
true
;
}
nsAutoCString
trackingOrigin
;
rv
=
nsContentUtils
:
:
GetASCIIOrigin
(
trackingURI
trackingOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG_SPEC
(
(
"
Failed
to
compute
the
origin
from
%
s
"
_spec
)
trackingURI
)
;
return
false
;
}
nsAutoCString
origin
;
rv
=
nsContentUtils
:
:
GetASCIIOrigin
(
aURI
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG_SPEC
(
(
"
Failed
to
compute
the
origin
from
%
s
"
_spec
)
aURI
)
;
return
false
;
}
nsAutoCString
type
;
CreatePermissionKey
(
trackingOrigin
origin
type
)
;
uint32_t
privateBrowsingId
=
0
;
rv
=
channelPrincipal
-
>
GetPrivateBrowsingId
(
&
privateBrowsingId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
Failed
to
get
the
channel
principal
'
s
private
browsing
ID
"
)
)
;
return
false
;
}
return
CheckAntiTrackingPermission
(
parentPrincipal
type
!
!
privateBrowsingId
aRejectedReason
blockedReason
parentPrincipalURI
)
;
}
bool
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
nsIPrincipal
*
aPrincipal
nsICookieSettings
*
aCookieSettings
)
{
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aCookieSettings
)
;
uint32_t
access
=
nsICookiePermission
:
:
ACCESS_DEFAULT
;
if
(
aPrincipal
-
>
GetIsContentPrincipal
(
)
)
{
nsPermissionManager
*
permManager
=
nsPermissionManager
:
:
GetInstance
(
)
;
if
(
permManager
)
{
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
permManager
-
>
TestPermissionFromPrincipal
(
aPrincipal
NS_LITERAL_CSTRING
(
"
cookie
"
)
&
access
)
)
)
;
}
}
if
(
access
!
=
nsICookiePermission
:
:
ACCESS_DEFAULT
)
{
return
access
!
=
nsICookiePermission
:
:
ACCESS_DENY
;
}
int32_t
behavior
=
CookiesBehavior
(
aPrincipal
aCookieSettings
)
;
return
behavior
!
=
nsICookieService
:
:
BEHAVIOR_REJECT
;
}
bool
AntiTrackingCommon
:
:
MaybeIsFirstPartyStorageAccessGrantedFor
(
nsPIDOMWindowInner
*
aFirstPartyWindow
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aFirstPartyWindow
)
;
MOZ_ASSERT
(
aURI
)
;
LOG_SPEC
(
(
"
Computing
a
best
guess
as
to
whether
window
%
p
has
access
to
URI
%
s
"
aFirstPartyWindow
_spec
)
aURI
)
;
Document
*
parentDocument
=
nsGlobalWindowInner
:
:
Cast
(
aFirstPartyWindow
)
-
>
GetExtantDoc
(
)
;
if
(
NS_WARN_IF
(
!
parentDocument
)
)
{
LOG
(
(
"
Failed
to
get
the
first
party
window
'
s
document
"
)
)
;
return
false
;
}
if
(
!
parentDocument
-
>
CookieSettings
(
)
-
>
GetRejectThirdPartyTrackers
(
)
)
{
LOG
(
(
"
Disabled
by
the
pref
(
%
d
)
bail
out
early
"
parentDocument
-
>
CookieSettings
(
)
-
>
GetCookieBehavior
(
)
)
)
;
return
true
;
}
if
(
CheckContentBlockingAllowList
(
aFirstPartyWindow
)
)
{
return
true
;
}
if
(
!
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
aFirstPartyWindow
nullptr
aURI
)
)
{
LOG
(
(
"
Our
window
isn
'
t
a
third
-
party
window
"
)
)
;
return
true
;
}
uint32_t
cookiePermission
=
CheckCookiePermissionForPrincipal
(
parentDocument
-
>
CookieSettings
(
)
parentDocument
-
>
NodePrincipal
(
)
)
;
if
(
cookiePermission
!
=
nsICookiePermission
:
:
ACCESS_DEFAULT
)
{
LOG
(
(
"
CheckCookiePermissionForPrincipal
(
)
returned
a
non
-
default
access
"
"
code
(
%
d
)
returning
%
s
"
int
(
cookiePermission
)
cookiePermission
!
=
nsICookiePermission
:
:
ACCESS_DENY
?
"
success
"
:
"
failure
"
)
)
;
return
cookiePermission
!
=
nsICookiePermission
:
:
ACCESS_DENY
;
}
nsAutoCString
origin
;
nsresult
rv
=
nsContentUtils
:
:
GetASCIIOrigin
(
aURI
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG_SPEC
(
(
"
Failed
to
compute
the
origin
from
%
s
"
_spec
)
aURI
)
;
return
false
;
}
nsIPrincipal
*
parentPrincipal
=
parentDocument
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIURI
>
parentPrincipalURI
;
Unused
<
<
parentPrincipal
-
>
GetURI
(
getter_AddRefs
(
parentPrincipalURI
)
)
;
nsAutoCString
type
;
CreatePermissionKey
(
origin
type
)
;
return
CheckAntiTrackingPermission
(
parentPrincipal
type
nsContentUtils
:
:
IsInPrivateBrowsing
(
parentDocument
)
nullptr
0
parentPrincipalURI
)
;
}
nsresult
AntiTrackingCommon
:
:
IsOnContentBlockingAllowList
(
nsIURI
*
aTopWinURI
bool
aIsPrivateBrowsing
bool
&
aIsAllowListed
)
{
aIsAllowListed
=
false
;
LOG_SPEC
(
(
"
Deciding
whether
the
user
has
overridden
content
blocking
for
%
s
"
_spec
)
aTopWinURI
)
;
nsAutoCString
escaped
(
NS_LITERAL_CSTRING
(
"
https
:
/
/
"
)
)
;
nsAutoCString
temp
;
nsresult
rv
=
aTopWinURI
?
aTopWinURI
-
>
GetHostPort
(
temp
)
:
NS_ERROR_FAILURE
;
if
(
NS_FAILED
(
rv
)
|
|
temp
.
IsEmpty
(
)
)
{
return
rv
;
}
escaped
.
Append
(
temp
)
;
nsPermissionManager
*
permManager
=
nsPermissionManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE
(
permManager
NS_ERROR_FAILURE
)
;
Pair
<
const
nsLiteralCString
bool
>
types
[
]
=
{
{
NS_LITERAL_CSTRING
(
"
trackingprotection
"
)
false
}
{
NS_LITERAL_CSTRING
(
"
trackingprotection
-
pb
"
)
true
}
}
;
auto
topWinURI
=
PromiseFlatCString
(
escaped
)
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
types
)
;
+
+
i
)
{
if
(
aIsPrivateBrowsing
!
=
types
[
i
]
.
second
(
)
)
{
continue
;
}
uint32_t
permissions
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
rv
=
permManager
-
>
TestPermissionOriginNoSuffix
(
topWinURI
types
[
i
]
.
first
(
)
&
permissions
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
permissions
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
aIsAllowListed
=
true
;
LOG
(
(
"
Found
user
override
type
%
s
for
%
s
"
types
[
i
]
.
first
(
)
.
get
(
)
topWinURI
.
get
(
)
)
)
;
break
;
}
}
if
(
!
aIsAllowListed
)
{
LOG
(
(
"
No
user
override
found
"
)
)
;
}
return
NS_OK
;
}
void
AntiTrackingCommon
:
:
NotifyBlockingDecision
(
nsIChannel
*
aChannel
BlockingDecision
aDecision
uint32_t
aRejectedReason
)
{
MOZ_ASSERT
(
aRejectedReason
=
=
0
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_PARTITIONED_FOREIGN
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
)
;
MOZ_ASSERT
(
aDecision
=
=
BlockingDecision
:
:
eBlock
|
|
aDecision
=
=
BlockingDecision
:
:
eAllow
)
;
if
(
!
aChannel
)
{
return
;
}
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
aChannel
parentChannel
)
;
if
(
parentChannel
)
{
if
(
aDecision
=
=
BlockingDecision
:
:
eBlock
)
{
parentChannel
-
>
NotifyCookieBlocked
(
aRejectedReason
)
;
}
else
{
parentChannel
-
>
NotifyCookieAllowed
(
)
;
}
}
return
;
}
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
nsCOMPtr
<
mozIThirdPartyUtil
>
thirdPartyUtil
=
services
:
:
GetThirdPartyUtil
(
)
;
if
(
!
thirdPartyUtil
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uriBeingLoaded
=
MaybeGetDocumentURIBeingLoaded
(
aChannel
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
win
;
nsresult
rv
=
thirdPartyUtil
-
>
GetTopWindowForChannel
(
aChannel
uriBeingLoaded
getter_AddRefs
(
win
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwin
=
nsPIDOMWindowOuter
:
:
From
(
win
)
;
if
(
!
pwin
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
aDecision
=
=
BlockingDecision
:
:
eBlock
)
{
pwin
-
>
NotifyContentBlockingEvent
(
aRejectedReason
aChannel
true
uri
aChannel
)
;
ReportBlockingToConsole
(
pwin
uri
aRejectedReason
)
;
}
pwin
-
>
NotifyContentBlockingEvent
(
nsIWebProgressListener
:
:
STATE_COOKIES_LOADED
aChannel
false
uri
aChannel
)
;
}
void
AntiTrackingCommon
:
:
NotifyBlockingDecision
(
nsPIDOMWindowInner
*
aWindow
BlockingDecision
aDecision
uint32_t
aRejectedReason
)
{
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
aRejectedReason
=
=
0
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_PARTITIONED_FOREIGN
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
|
|
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
)
;
MOZ_ASSERT
(
aDecision
=
=
BlockingDecision
:
:
eBlock
|
|
aDecision
=
=
BlockingDecision
:
:
eAllow
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwin
=
GetTopWindow
(
aWindow
)
;
if
(
!
pwin
)
{
return
;
}
nsPIDOMWindowInner
*
inner
=
pwin
-
>
GetCurrentInnerWindow
(
)
;
if
(
!
inner
)
{
return
;
}
Document
*
pwinDoc
=
inner
-
>
GetExtantDoc
(
)
;
if
(
!
pwinDoc
)
{
return
;
}
nsIChannel
*
channel
=
pwinDoc
-
>
GetChannel
(
)
;
if
(
!
channel
)
{
return
;
}
Document
*
document
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
!
document
)
{
return
;
}
nsIURI
*
uri
=
document
-
>
GetDocumentURI
(
)
;
nsIChannel
*
trackingChannel
=
document
-
>
GetChannel
(
)
;
if
(
aDecision
=
=
BlockingDecision
:
:
eBlock
)
{
pwin
-
>
NotifyContentBlockingEvent
(
aRejectedReason
channel
true
uri
trackingChannel
)
;
ReportBlockingToConsole
(
pwin
uri
aRejectedReason
)
;
}
pwin
-
>
NotifyContentBlockingEvent
(
nsIWebProgressListener
:
:
STATE_COOKIES_LOADED
channel
false
uri
trackingChannel
)
;
}
void
AntiTrackingCommon
:
:
StoreUserInteractionFor
(
nsIPrincipal
*
aPrincipal
)
{
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
Unused
<
<
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
LOG_SPEC
(
(
"
Saving
the
userInteraction
for
%
s
"
_spec
)
uri
)
;
nsPermissionManager
*
permManager
=
nsPermissionManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
permManager
)
)
{
LOG
(
(
"
Permission
manager
is
null
bailing
out
early
"
)
)
;
return
;
}
uint32_t
expirationType
=
nsIPermissionManager
:
:
EXPIRE_TIME
;
uint32_t
expirationTime
=
StaticPrefs
:
:
privacy_userInteraction_expiration
(
)
*
1000
;
int64_t
when
=
(
PR_Now
(
)
/
PR_USEC_PER_MSEC
)
+
expirationTime
;
uint32_t
privateBrowsingId
=
0
;
nsresult
rv
=
aPrincipal
-
>
GetPrivateBrowsingId
(
&
privateBrowsingId
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
&
&
privateBrowsingId
>
0
)
{
expirationType
=
nsIPermissionManager
:
:
EXPIRE_SESSION
;
when
=
0
;
}
rv
=
permManager
-
>
AddFromPrincipal
(
aPrincipal
USER_INTERACTION_PERM
nsIPermissionManager
:
:
ALLOW_ACTION
expirationType
when
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
;
}
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cc
)
;
nsCOMPtr
<
nsIURI
>
uri
;
Unused
<
<
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
LOG_SPEC
(
(
"
Asking
the
parent
process
to
save
the
user
-
interaction
for
us
:
%
s
"
_spec
)
uri
)
;
cc
-
>
SendStoreUserInteractionAsPermission
(
IPC
:
:
Principal
(
aPrincipal
)
)
;
}
bool
AntiTrackingCommon
:
:
HasUserInteraction
(
nsIPrincipal
*
aPrincipal
)
{
nsPermissionManager
*
permManager
=
nsPermissionManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
permManager
)
)
{
return
false
;
}
uint32_t
result
=
0
;
nsresult
rv
=
permManager
-
>
TestPermissionWithoutDefaultsFromPrincipal
(
aPrincipal
USER_INTERACTION_PERM
&
result
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
result
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
;
}
void
AntiTrackingCommon
:
:
OnAntiTrackingSettingsChanged
(
const
AntiTrackingCommon
:
:
AntiTrackingSettingsChangedCallback
&
aCallback
)
{
static
bool
initialized
=
false
;
if
(
!
initialized
)
{
Preferences
:
:
RegisterPrefixCallback
(
SettingsChangeObserver
:
:
PrivacyPrefChanged
"
browser
.
contentblocking
.
"
)
;
Preferences
:
:
RegisterPrefixCallback
(
SettingsChangeObserver
:
:
PrivacyPrefChanged
"
network
.
cookie
.
"
)
;
Preferences
:
:
RegisterPrefixCallback
(
SettingsChangeObserver
:
:
PrivacyPrefChanged
"
privacy
.
"
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
RefPtr
<
SettingsChangeObserver
>
observer
=
new
SettingsChangeObserver
(
)
;
obs
-
>
AddObserver
(
observer
"
perm
-
added
"
false
)
;
obs
-
>
AddObserver
(
observer
"
perm
-
changed
"
false
)
;
obs
-
>
AddObserver
(
observer
"
perm
-
cleared
"
false
)
;
obs
-
>
AddObserver
(
observer
"
perm
-
deleted
"
false
)
;
obs
-
>
AddObserver
(
observer
"
xpcom
-
shutdown
"
false
)
;
}
gSettingsChangedCallbacks
=
MakeUnique
<
nsTArray
<
AntiTrackingSettingsChangedCallback
>
>
(
)
;
initialized
=
true
;
}
gSettingsChangedCallbacks
-
>
AppendElement
(
aCallback
)
;
}
already_AddRefed
<
nsIURI
>
AntiTrackingCommon
:
:
MaybeGetDocumentURIBeingLoaded
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIURI
>
uriBeingLoaded
;
nsLoadFlags
loadFlags
=
0
;
nsresult
rv
=
aChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
if
(
loadFlags
&
nsIChannel
:
:
LOAD_DOCUMENT_URI
)
{
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uriBeingLoaded
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
return
uriBeingLoaded
.
forget
(
)
;
}
