#
include
"
AntiTrackingLog
.
h
"
#
include
"
ContentBlockingAllowList
.
h
"
#
include
"
ContentBlockingAllowListCache
.
h
"
#
include
"
SettingsChangeObserver
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsPermissionManager
.
h
"
using
namespace
mozilla
;
ContentBlockingAllowListCache
&
ContentBlockingAllowList
:
:
Cache
(
)
{
static
bool
initialized
=
false
;
static
ContentBlockingAllowListCache
cache
;
if
(
!
initialized
)
{
SettingsChangeObserver
:
:
OnAntiTrackingSettingsChanged
(
[
&
]
{
cache
.
Clear
(
)
;
}
)
;
initialized
=
true
;
}
return
cache
;
}
bool
ContentBlockingAllowList
:
:
Check
(
nsIPrincipal
*
aTopWinPrincipal
bool
aIsPrivateBrowsing
)
{
bool
isAllowed
=
false
;
nsresult
rv
=
Check
(
aTopWinPrincipal
aIsPrivateBrowsing
isAllowed
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isAllowed
)
{
LOG
(
(
"
The
top
-
level
window
is
on
the
content
blocking
allow
list
"
"
bail
out
early
"
)
)
;
return
true
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Checking
the
content
blocking
allow
list
for
failed
with
%
"
PRIx32
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
return
false
;
}
bool
ContentBlockingAllowList
:
:
Check
(
nsPIDOMWindowInner
*
aWindow
)
{
ContentBlockingAllowListKey
cacheKey
(
aWindow
)
;
auto
entry
=
Cache
(
)
.
Lookup
(
cacheKey
)
;
if
(
entry
)
{
return
entry
.
Data
(
)
.
mResult
;
}
nsPIDOMWindowOuter
*
top
=
aWindow
-
>
GetBrowsingContext
(
)
-
>
Top
(
)
-
>
GetDOMWindow
(
)
;
dom
:
:
Document
*
doc
=
top
?
top
-
>
GetExtantDoc
(
)
:
nullptr
;
if
(
doc
)
{
bool
isPrivateBrowsing
=
nsContentUtils
:
:
IsInPrivateBrowsing
(
doc
)
;
const
bool
result
=
ContentBlockingAllowList
:
:
Check
(
doc
-
>
GetContentBlockingAllowListPrincipal
(
)
isPrivateBrowsing
)
;
entry
.
Set
(
ContentBlockingAllowListEntry
(
aWindow
result
)
)
;
return
result
;
}
LOG
(
(
"
Could
not
check
the
content
blocking
allow
list
because
the
top
"
"
window
wasn
'
t
accessible
"
)
)
;
entry
.
Set
(
ContentBlockingAllowListEntry
(
aWindow
false
)
)
;
return
false
;
}
bool
ContentBlockingAllowList
:
:
Check
(
nsIHttpChannel
*
aChannel
)
{
ContentBlockingAllowListKey
cacheKey
(
aChannel
)
;
auto
entry
=
Cache
(
)
.
Lookup
(
cacheKey
)
;
if
(
entry
)
{
return
entry
.
Data
(
)
.
mResult
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChan
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChan
)
{
nsresult
rv
=
httpChan
-
>
GetContentBlockingAllowListPrincipal
(
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
principal
)
{
LOG
(
(
"
Could
not
check
the
content
blocking
allow
list
because
the
top
"
"
window
wasn
'
t
accessible
"
)
)
;
entry
.
Set
(
ContentBlockingAllowListEntry
(
aChannel
false
)
)
;
return
false
;
}
}
const
bool
result
=
ContentBlockingAllowList
:
:
Check
(
principal
NS_UsePrivateBrowsing
(
aChannel
)
)
;
entry
.
Set
(
ContentBlockingAllowListEntry
(
aChannel
result
)
)
;
return
result
;
}
nsresult
ContentBlockingAllowList
:
:
Check
(
nsIPrincipal
*
aContentBlockingAllowListPrincipal
bool
aIsPrivateBrowsing
bool
&
aIsAllowListed
)
{
aIsAllowListed
=
false
;
if
(
!
aContentBlockingAllowListPrincipal
)
{
return
NS_OK
;
}
LOG_PRIN
(
(
"
Deciding
whether
the
user
has
overridden
content
blocking
for
%
s
"
_spec
)
aContentBlockingAllowListPrincipal
)
;
nsPermissionManager
*
permManager
=
nsPermissionManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE
(
permManager
NS_ERROR_FAILURE
)
;
std
:
:
pair
<
const
nsLiteralCString
bool
>
types
[
]
=
{
{
NS_LITERAL_CSTRING
(
"
trackingprotection
"
)
false
}
{
NS_LITERAL_CSTRING
(
"
trackingprotection
-
pb
"
)
true
}
}
;
for
(
const
auto
&
type
:
types
)
{
if
(
aIsPrivateBrowsing
!
=
type
.
second
)
{
continue
;
}
uint32_t
permissions
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
nsresult
rv
=
permManager
-
>
TestPermissionFromPrincipal
(
aContentBlockingAllowListPrincipal
type
.
first
&
permissions
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
permissions
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
aIsAllowListed
=
true
;
LOG
(
(
"
Found
user
override
type
%
s
"
type
.
first
.
get
(
)
)
)
;
break
;
}
}
if
(
!
aIsAllowListed
)
{
LOG
(
(
"
No
user
override
found
"
)
)
;
}
return
NS_OK
;
}
void
ContentBlockingAllowList
:
:
ComputePrincipal
(
nsIPrincipal
*
aDocumentPrincipal
nsIPrincipal
*
*
aPrincipal
)
{
MOZ_ASSERT
(
aPrincipal
)
;
auto
returnInputArgument
=
MakeScopeExit
(
[
&
]
{
NS_IF_ADDREF
(
*
aPrincipal
=
aDocumentPrincipal
)
;
}
)
;
BasePrincipal
*
bp
=
BasePrincipal
:
:
Cast
(
aDocumentPrincipal
)
;
if
(
!
bp
|
|
!
bp
-
>
IsContentPrincipal
(
)
)
{
return
;
}
nsAutoCString
escaped
(
NS_LITERAL_CSTRING
(
"
https
:
/
/
"
)
)
;
nsAutoCString
temp
;
nsresult
rv
=
aDocumentPrincipal
-
>
GetHostPort
(
temp
)
;
if
(
NS_FAILED
(
rv
)
&
&
!
aDocumentPrincipal
-
>
SchemeIs
(
"
view
-
source
"
)
)
{
return
;
}
if
(
temp
.
IsEmpty
(
)
)
{
returnInputArgument
.
release
(
)
;
*
aPrincipal
=
nullptr
;
return
;
}
escaped
.
Append
(
temp
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
escaped
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
uri
aDocumentPrincipal
-
>
OriginAttributesRef
(
)
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
return
;
}
returnInputArgument
.
release
(
)
;
principal
.
forget
(
aPrincipal
)
;
}
void
ContentBlockingAllowList
:
:
RecomputePrincipal
(
nsIURI
*
aURIBeingLoaded
const
OriginAttributes
&
aAttrs
nsIPrincipal
*
*
aPrincipal
)
{
MOZ_ASSERT
(
aPrincipal
)
;
auto
returnInputArgument
=
MakeScopeExit
(
[
&
]
{
*
aPrincipal
=
nullptr
;
}
)
;
nsAutoCString
escaped
(
NS_LITERAL_CSTRING
(
"
https
:
/
/
"
)
)
;
nsAutoCString
temp
;
nsresult
rv
=
aURIBeingLoaded
-
>
GetHostPort
(
temp
)
;
if
(
NS_FAILED
(
rv
)
&
&
!
aURIBeingLoaded
-
>
SchemeIs
(
"
view
-
source
"
)
)
{
return
;
}
if
(
temp
.
IsEmpty
(
)
)
{
return
;
}
escaped
.
Append
(
temp
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
escaped
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
uri
aAttrs
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
return
;
}
returnInputArgument
.
release
(
)
;
principal
.
forget
(
aPrincipal
)
;
}
