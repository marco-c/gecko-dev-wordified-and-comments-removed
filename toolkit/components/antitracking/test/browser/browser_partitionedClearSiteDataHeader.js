"
use
strict
"
;
const
{
SiteDataTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
SiteDataTestUtils
.
jsm
"
)
;
const
HOST_A
=
"
example
.
com
"
;
const
HOST_B
=
"
example
.
org
"
;
const
ORIGIN_A
=
https
:
/
/
{
HOST_A
}
;
const
ORIGIN_B
=
https
:
/
/
{
HOST_B
}
;
const
CLEAR_SITE_DATA_PATH
=
/
{
TEST_PATH
}
clearSiteData
.
sjs
;
const
CLEAR_SITE_DATA_URL_ORIGIN_B
=
ORIGIN_B
+
CLEAR_SITE_DATA_PATH
;
const
CLEAR_SITE_DATA_URL_ORIGIN_A
=
ORIGIN_A
+
CLEAR_SITE_DATA_PATH
;
const
THIRD_PARTY_FRAME_ID_ORIGIN_B
=
"
thirdPartyFrame
"
;
const
THIRD_PARTY_FRAME_ID_ORIGIN_A
=
"
thirdPartyFrame2
"
;
const
STORAGE_KEY
=
"
testKey
"
;
const
skipLocalStorageTests
=
!
Services
.
prefs
.
getBoolPref
(
"
dom
.
storage
.
next_gen
"
)
;
function
createFrame
(
browser
src
id
sandbox
)
{
return
SpecialPowers
.
spawn
(
browser
[
{
page
:
src
frameId
:
id
sandbox
}
]
async
function
(
obj
)
{
await
new
content
.
Promise
(
resolve
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
if
(
obj
.
sandbox
)
{
frame
.
setAttribute
(
"
sandbox
"
"
allow
-
scripts
"
)
;
}
frame
.
src
=
obj
.
page
;
frame
.
id
=
obj
.
frameId
;
frame
.
addEventListener
(
"
load
"
resolve
{
once
:
true
}
)
;
content
.
document
.
body
.
appendChild
(
frame
)
;
}
)
;
}
)
;
}
async
function
createTabWithFrame
(
firstPartyUrl
thirdPartyUrl
frameId
sandbox
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
firstPartyUrl
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
await
createFrame
(
tab
.
linkedBrowser
thirdPartyUrl
frameId
sandbox
)
;
return
{
tab
frameBC
:
tab
.
linkedBrowser
.
browsingContext
.
children
[
0
]
}
;
}
async
function
runClearSiteDataTest
(
cbPreClear
cbPostClear
clearDataContext
sandboxFrame
=
false
)
{
let
[
{
frameBC
:
frameContextB
tab
:
tabA
}
{
frameBC
:
frameContextA
tab
:
tabB
}
]
=
await
Promise
.
all
(
[
createTabWithFrame
(
ORIGIN_A
ORIGIN_B
THIRD_PARTY_FRAME_ID_ORIGIN_B
sandboxFrame
)
createTabWithFrame
(
ORIGIN_B
ORIGIN_A
THIRD_PARTY_FRAME_ID_ORIGIN_A
sandboxFrame
)
]
)
;
let
browserA
=
tabA
.
linkedBrowser
;
let
contextA
=
browserA
.
browsingContext
;
let
browserB
=
tabB
.
linkedBrowser
;
let
contextB
=
browserB
.
browsingContext
;
if
(
cbPreClear
)
{
await
cbPreClear
(
contextA
contextB
frameContextB
frameContextA
)
;
}
info
(
Opening
path
with
clear
-
site
-
data
-
header
for
{
clearDataContext
}
)
;
if
(
clearDataContext
=
=
"
firstParty
"
)
{
await
BrowserTestUtils
.
withNewTab
(
CLEAR_SITE_DATA_URL_ORIGIN_A
(
)
=
>
{
}
)
;
}
else
if
(
clearDataContext
=
=
"
thirdPartyPartitioned
"
)
{
await
SpecialPowers
.
spawn
(
browserA
[
{
page
:
CLEAR_SITE_DATA_URL_ORIGIN_B
frameId
:
THIRD_PARTY_FRAME_ID_ORIGIN_B
}
]
async
function
(
obj
)
{
await
new
content
.
Promise
(
resolve
=
>
{
let
frame
=
content
.
document
.
getElementById
(
obj
.
frameId
)
;
frame
.
addEventListener
(
"
load
"
resolve
{
once
:
true
}
)
;
frame
.
src
=
obj
.
page
;
}
)
;
}
)
;
}
else
{
ok
(
false
"
Invalid
context
requested
for
clear
-
site
-
data
"
)
;
}
if
(
cbPostClear
)
{
await
cbPostClear
(
contextA
contextB
frameContextB
frameContextA
)
;
}
info
(
"
Cleaning
up
.
"
)
;
BrowserTestUtils
.
removeTab
(
tabA
)
;
BrowserTestUtils
.
removeTab
(
tabB
)
;
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
resolve
)
;
}
)
;
}
function
getOrigin
(
originNoSuffix
firstParty
)
{
let
origin
=
originNoSuffix
;
if
(
firstParty
)
{
let
[
scheme
host
]
=
firstParty
.
split
(
"
:
/
/
"
)
;
origin
+
=
^
partitionKey
=
(
{
scheme
}
{
host
}
)
;
}
return
origin
;
}
function
setStorageEntry
(
storageType
originNoSuffix
firstParty
key
value
)
{
if
(
storageType
!
=
"
cookie
"
&
&
storageType
!
=
"
localStorage
"
)
{
ok
(
false
"
Invalid
storageType
passed
"
)
;
return
;
}
let
origin
=
getOrigin
(
originNoSuffix
firstParty
)
;
if
(
storageType
=
=
"
cookie
"
)
{
SiteDataTestUtils
.
addToCookies
(
{
origin
name
:
key
value
}
)
;
return
;
}
SiteDataTestUtils
.
addToLocalStorage
(
origin
key
value
)
;
}
function
testHasCookie
(
hasCookie
originNoSuffix
firstParty
key
value
)
{
let
origin
=
getOrigin
(
originNoSuffix
firstParty
)
;
let
label
=
{
originNoSuffix
}
{
firstParty
?
(
partitioned
under
{
firstParty
}
)
:
"
"
}
;
if
(
!
hasCookie
)
{
ok
(
!
SiteDataTestUtils
.
hasCookies
(
origin
)
Cookie
for
{
label
}
is
not
set
for
key
{
key
}
)
;
return
;
}
ok
(
SiteDataTestUtils
.
hasCookies
(
origin
[
{
key
value
}
]
)
Cookie
for
{
label
}
is
set
{
key
}
=
{
value
}
)
;
}
function
testHasLocalStorageEntry
(
hasEntry
originNoSuffix
firstParty
key
expectedValue
)
{
if
(
key
=
=
null
)
{
ok
(
false
"
localStorage
key
is
mandatory
"
)
;
return
;
}
let
label
=
{
originNoSuffix
}
{
firstParty
?
(
partitioned
under
{
firstParty
}
)
:
"
"
}
;
let
origin
=
getOrigin
(
originNoSuffix
firstParty
)
;
if
(
hasEntry
)
{
let
hasEntry
=
SiteDataTestUtils
.
hasLocalStorage
(
origin
[
{
key
value
:
expectedValue
}
]
)
;
ok
(
hasEntry
localStorage
for
{
label
}
has
expected
value
{
key
}
=
{
expectedValue
}
)
;
}
else
{
let
hasEntry
=
SiteDataTestUtils
.
hasLocalStorage
(
origin
)
;
ok
(
!
hasEntry
localStorage
for
{
label
}
is
not
set
for
key
{
key
}
)
;
}
}
async
function
setupInitialStorageState
(
storageType
)
{
if
(
storageType
!
=
"
cookie
"
&
&
storageType
!
=
"
localStorage
"
)
{
ok
(
false
"
Invalid
storageType
passed
"
)
;
return
;
}
setStorageEntry
(
storageType
ORIGIN_A
null
STORAGE_KEY
"
firstParty
"
)
;
setStorageEntry
(
storageType
ORIGIN_B
ORIGIN_A
STORAGE_KEY
"
thirdPartyPartitioned
"
)
;
setStorageEntry
(
storageType
ORIGIN_B
null
STORAGE_KEY
"
thirdParty
"
)
;
setStorageEntry
(
storageType
ORIGIN_A
ORIGIN_B
STORAGE_KEY
"
thirdPartyPartitioned2
"
)
;
info
(
"
Test
that
storage
entries
are
set
for
all
contexts
"
)
;
if
(
storageType
=
=
"
cookie
"
)
{
testHasCookie
(
true
ORIGIN_A
null
STORAGE_KEY
"
firstParty
"
)
;
testHasCookie
(
true
ORIGIN_B
null
STORAGE_KEY
"
thirdParty
"
)
;
testHasCookie
(
true
ORIGIN_B
ORIGIN_A
STORAGE_KEY
"
thirdPartyPartitioned
"
)
;
testHasCookie
(
true
ORIGIN_A
ORIGIN_B
STORAGE_KEY
"
thirdPartyPartitioned2
"
)
;
return
;
}
testHasLocalStorageEntry
(
true
ORIGIN_A
null
STORAGE_KEY
"
firstParty
"
)
;
testHasLocalStorageEntry
(
true
ORIGIN_B
null
STORAGE_KEY
"
thirdParty
"
)
;
testHasLocalStorageEntry
(
true
ORIGIN_B
ORIGIN_A
STORAGE_KEY
"
thirdPartyPartitioned
"
)
;
testHasLocalStorageEntry
(
true
ORIGIN_A
ORIGIN_B
STORAGE_KEY
"
thirdPartyPartitioned2
"
)
;
}
add_task
(
async
function
setup
(
)
{
info
(
"
Starting
ClearSiteData
test
"
)
;
await
SpecialPowers
.
flushPrefEnv
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
storage_access
.
enabled
"
true
]
[
"
network
.
cookie
.
cookieBehavior
"
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
]
[
"
network
.
cookie
.
cookieBehavior
.
pbmode
"
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
]
[
"
privacy
.
trackingprotection
.
enabled
"
false
]
[
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
false
]
[
"
dom
.
storage
.
client_validation
"
false
]
]
}
)
;
}
)
;
add_task
(
async
function
cookieClearThirdParty
(
)
{
await
runClearSiteDataTest
(
(
)
=
>
setupInitialStorageState
(
"
cookie
"
)
(
)
=
>
{
info
(
"
Testing
:
First
party
cookie
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_A
null
STORAGE_KEY
"
firstParty
"
)
;
info
(
"
Testing
:
Unpartitioned
cookie
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_B
null
STORAGE_KEY
"
thirdParty
"
)
;
info
(
"
Testing
:
Partitioned
cookie
for
HOST_B
(
HOST_A
)
has
been
cleared
"
)
;
testHasCookie
(
false
ORIGIN_B
ORIGIN_A
)
;
info
(
"
Testing
:
Partitioned
cookie
for
HOST_A
(
HOST_B
)
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_A
ORIGIN_B
STORAGE_KEY
"
thirdPartyPartitioned2
"
)
;
}
"
thirdPartyPartitioned
"
)
;
}
)
;
add_task
(
async
function
cookieClearThirdPartySandbox
(
)
{
await
runClearSiteDataTest
(
(
)
=
>
setupInitialStorageState
(
"
cookie
"
)
(
)
=
>
{
info
(
"
Testing
:
First
party
cookie
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_A
null
STORAGE_KEY
"
firstParty
"
)
;
info
(
"
Testing
:
Unpartitioned
cookie
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_B
null
STORAGE_KEY
"
thirdParty
"
)
;
info
(
"
Testing
:
Partitioned
cookie
for
HOST_B
(
HOST_A
)
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_B
ORIGIN_A
STORAGE_KEY
"
thirdPartyPartitioned
"
)
;
info
(
"
Testing
:
Partitioned
cookie
for
HOST_A
(
HOST_B
)
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_A
ORIGIN_B
STORAGE_KEY
"
thirdPartyPartitioned2
"
)
;
}
"
thirdPartyPartitioned
"
true
)
;
}
)
;
add_task
(
async
function
cookieClearFirstParty
(
)
{
await
runClearSiteDataTest
(
(
)
=
>
setupInitialStorageState
(
"
cookie
"
)
(
)
=
>
{
info
(
"
Testing
:
First
party
cookie
has
been
cleared
"
)
;
testHasCookie
(
false
ORIGIN_A
null
)
;
info
(
"
Testing
:
Unpartitioned
cookie
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_B
null
STORAGE_KEY
"
thirdParty
"
)
;
info
(
"
Testing
:
Partitioned
cookie
for
HOST_B
(
HOST_A
)
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_B
ORIGIN_A
STORAGE_KEY
"
thirdPartyPartitioned
"
)
;
info
(
"
Testing
:
Partitioned
cookie
for
HOST_A
(
HOST_B
)
has
not
changed
"
)
;
testHasCookie
(
true
ORIGIN_A
ORIGIN_B
STORAGE_KEY
"
thirdPartyPartitioned2
"
)
;
}
"
firstParty
"
)
;
}
)
;
add_task
(
async
function
localStorageClearThirdParty
(
)
{
if
(
skipLocalStorageTests
)
{
info
(
"
Skipping
test
"
)
;
return
;
}
await
runClearSiteDataTest
(
(
)
=
>
setupInitialStorageState
(
"
localStorage
"
)
async
(
)
=
>
{
info
(
"
Testing
:
First
party
localStorage
has
not
changed
"
)
;
testHasLocalStorageEntry
(
true
ORIGIN_A
null
STORAGE_KEY
"
firstParty
"
)
;
info
(
"
Testing
:
Unpartitioned
localStorage
has
not
changed
"
)
;
testHasLocalStorageEntry
(
true
ORIGIN_B
null
STORAGE_KEY
"
thirdParty
"
)
;
info
(
"
Testing
:
Partitioned
localStorage
for
HOST_B
(
HOST_A
)
has
been
cleared
"
)
;
testHasLocalStorageEntry
(
false
ORIGIN_B
ORIGIN_A
STORAGE_KEY
)
;
info
(
"
Testing
:
Partitioned
localStorage
for
HOST_A
(
HOST_B
)
has
not
changed
"
)
;
testHasLocalStorageEntry
(
true
ORIGIN_A
ORIGIN_B
STORAGE_KEY
"
thirdPartyPartitioned2
"
)
;
}
"
thirdPartyPartitioned
"
)
;
}
)
;
add_task
(
async
function
localStorageClearFirstParty
(
)
{
if
(
skipLocalStorageTests
)
{
info
(
"
Skipping
test
"
)
;
return
;
}
await
runClearSiteDataTest
(
(
)
=
>
setupInitialStorageState
(
"
localStorage
"
)
(
)
=
>
{
info
(
"
Testing
:
First
party
localStorage
has
been
cleared
"
)
;
testHasLocalStorageEntry
(
false
ORIGIN_A
null
STORAGE_KEY
)
;
info
(
"
Testing
:
Unpartitioned
thirdParty
localStorage
has
not
changed
"
)
;
testHasLocalStorageEntry
(
true
ORIGIN_B
null
STORAGE_KEY
"
thirdParty
"
)
;
info
(
"
Testing
:
Partitioned
localStorage
for
HOST_B
(
HOST_A
)
has
not
changed
"
)
;
testHasLocalStorageEntry
(
true
ORIGIN_B
ORIGIN_A
STORAGE_KEY
"
thirdPartyPartitioned
"
)
;
info
(
"
Testing
:
Partitioned
localStorage
for
HOST_A
(
HOST_B
)
has
not
changed
"
)
;
testHasLocalStorageEntry
(
true
ORIGIN_A
ORIGIN_B
STORAGE_KEY
"
thirdPartyPartitioned2
"
)
;
}
"
firstParty
"
)
;
}
)
;
