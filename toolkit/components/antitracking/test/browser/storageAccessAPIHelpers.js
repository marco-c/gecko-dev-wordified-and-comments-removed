async
function
hasStorageAccessInitially
(
)
{
let
hasAccess
=
await
document
.
hasStorageAccess
(
)
;
ok
(
hasAccess
"
Has
storage
access
"
)
;
}
async
function
noStorageAccessInitially
(
)
{
let
hasAccess
=
await
document
.
hasStorageAccess
(
)
;
ok
(
!
hasAccess
"
Doesn
'
t
yet
have
storage
access
"
)
;
}
async
function
stillNoStorageAccess
(
)
{
let
hasAccess
=
await
document
.
hasStorageAccess
(
)
;
ok
(
!
hasAccess
"
Still
doesn
'
t
have
storage
access
"
)
;
}
async
function
callRequestStorageAccess
(
callback
expectFail
)
{
SpecialPowers
.
wrap
(
document
)
.
notifyUserGestureActivation
(
)
;
let
origin
=
new
URL
(
location
.
href
)
.
origin
;
let
effectiveCookieBehavior
=
SpecialPowers
.
isContentWindowPrivate
(
window
)
?
SpecialPowers
.
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
cookieBehavior
.
pbmode
"
)
:
SpecialPowers
.
Services
.
prefs
.
getIntPref
(
"
network
.
cookie
.
cookieBehavior
"
)
;
let
success
=
true
;
let
rejectTrackers
=
[
SpecialPowers
.
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
SpecialPowers
.
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
]
.
includes
(
effectiveCookieBehavior
)
&
&
!
isOnContentBlockingAllowList
(
)
;
const
TEST_ANOTHER_3RD_PARTY_ORIGIN
=
SpecialPowers
.
useRemoteSubframes
?
"
http
:
/
/
another
-
tracking
.
example
.
net
"
:
"
https
:
/
/
another
-
tracking
.
example
.
net
"
;
if
(
origin
!
=
TEST_ANOTHER_3RD_PARTY_ORIGIN
)
{
if
(
rejectTrackers
)
{
let
p
;
let
threw
=
false
;
try
{
p
=
document
.
requestStorageAccess
(
)
;
}
catch
(
e
)
{
threw
=
true
;
}
ok
(
!
threw
"
requestStorageAccess
should
not
throw
"
)
;
try
{
if
(
callback
)
{
if
(
expectFail
)
{
await
p
.
catch
(
_
=
>
callback
(
)
)
;
success
=
false
;
}
else
{
await
p
.
then
(
_
=
>
callback
(
)
)
;
}
}
else
{
await
p
;
}
}
catch
(
e
)
{
success
=
false
;
}
finally
{
SpecialPowers
.
wrap
(
document
)
.
clearUserGestureActivation
(
)
;
}
ok
(
!
success
"
Should
not
have
worked
without
user
interaction
"
)
;
await
noStorageAccessInitially
(
)
;
await
interactWithTracker
(
)
;
SpecialPowers
.
wrap
(
document
)
.
notifyUserGestureActivation
(
)
;
}
if
(
effectiveCookieBehavior
=
=
SpecialPowers
.
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
&
&
!
isOnContentBlockingAllowList
(
)
)
{
try
{
if
(
callback
)
{
if
(
expectFail
)
{
await
document
.
requestStorageAccess
(
)
.
catch
(
_
=
>
callback
(
)
)
;
success
=
false
;
}
else
{
await
document
.
requestStorageAccess
(
)
.
then
(
_
=
>
callback
(
)
)
;
}
}
else
{
await
document
.
requestStorageAccess
(
)
;
}
}
catch
(
e
)
{
success
=
false
;
}
finally
{
SpecialPowers
.
wrap
(
document
)
.
clearUserGestureActivation
(
)
;
}
ok
(
success
"
Should
not
have
thrown
"
)
;
await
hasStorageAccessInitially
(
)
;
await
interactWithTracker
(
)
;
SpecialPowers
.
wrap
(
document
)
.
notifyUserGestureActivation
(
)
;
}
}
let
p
;
let
threw
=
false
;
try
{
p
=
document
.
requestStorageAccess
(
)
;
}
catch
(
e
)
{
threw
=
true
;
}
let
rejected
=
false
;
try
{
if
(
callback
)
{
if
(
expectFail
)
{
await
p
.
catch
(
_
=
>
callback
(
)
)
;
rejected
=
true
;
}
else
{
await
p
.
then
(
_
=
>
callback
(
)
)
;
}
}
else
{
await
p
;
}
}
catch
(
e
)
{
rejected
=
true
;
}
finally
{
SpecialPowers
.
wrap
(
document
)
.
clearUserGestureActivation
(
)
;
}
success
=
!
threw
&
&
!
rejected
;
let
hasAccess
=
await
document
.
hasStorageAccess
(
)
;
is
(
hasAccess
success
"
Should
"
+
(
success
?
"
"
:
"
not
"
)
+
"
have
storage
access
now
"
)
;
if
(
success
&
&
rejectTrackers
&
&
window
.
location
.
search
!
=
"
?
disableWaitUntilPermission
"
&
&
origin
!
=
TEST_ANOTHER_3RD_PARTY_ORIGIN
)
{
await
waitUntilPermission
(
"
http
:
/
/
example
.
net
/
browser
/
toolkit
/
components
/
antitracking
/
test
/
browser
/
page
.
html
"
"
3rdPartyStorage
^
"
+
window
.
origin
)
;
}
return
[
threw
rejected
]
;
}
async
function
waitUntilPermission
(
url
name
)
{
let
originAttributes
=
SpecialPowers
.
isContentWindowPrivate
(
window
)
?
{
privateBrowsingId
:
1
}
:
{
}
;
await
new
Promise
(
resolve
=
>
{
let
id
=
setInterval
(
async
_
=
>
{
if
(
await
SpecialPowers
.
testPermission
(
name
SpecialPowers
.
Services
.
perms
.
ALLOW_ACTION
{
url
originAttributes
}
)
)
{
clearInterval
(
id
)
;
resolve
(
)
;
}
}
0
)
;
}
)
;
}
async
function
interactWithTracker
(
)
{
await
new
Promise
(
resolve
=
>
{
let
orionmessage
=
onmessage
;
onmessage
=
_
=
>
{
onmessage
=
orionmessage
;
resolve
(
)
;
}
;
info
(
"
Let
'
s
interact
with
the
tracker
"
)
;
window
.
open
(
"
/
browser
/
toolkit
/
components
/
antitracking
/
test
/
browser
/
3rdPartyOpenUI
.
html
?
messageme
"
)
;
}
)
;
await
waitUntilPermission
(
window
.
origin
"
storageAccessAPI
"
)
;
}
function
isOnContentBlockingAllowList
(
)
{
return
window
.
allowListed
;
}
