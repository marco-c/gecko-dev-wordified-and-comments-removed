"
use
strict
"
;
const
TEST_TRACKER_DOMAIN
=
"
https
:
/
/
tracking
.
example
.
com
/
"
;
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
trackingprotection
.
enabled
"
true
]
]
}
)
;
await
UrlClassifierTestUtils
.
addTestTrackers
(
)
;
registerCleanupFunction
(
_
=
>
{
UrlClassifierTestUtils
.
cleanupTestTrackers
(
)
;
}
)
;
}
)
;
add_task
(
async
function
test_workerFetch
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_TOP_PAGE_HTTPS
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
TEST_TRACKER_DOMAIN
+
TEST_PATH
+
"
corsAllowed
.
html
"
TEST_4TH_PARTY_DOMAIN_HTTPS
+
TEST_PATH
+
"
corsAllowed
.
html
"
]
async
(
trackingUrl
nonTrackingUrl
)
=
>
{
let
worker
=
new
content
.
Worker
(
"
workerFetch
.
js
"
)
;
let
result
=
await
new
content
.
Promise
(
resolve
=
>
{
worker
.
addEventListener
(
"
message
"
function
handler
(
e
)
{
if
(
e
.
data
.
type
=
=
=
"
FetchResult
"
)
{
if
(
e
.
data
.
success
)
{
resolve
(
true
)
;
}
else
{
resolve
(
false
)
;
}
worker
.
removeEventListener
(
"
message
"
handler
)
;
}
}
)
;
worker
.
postMessage
(
{
type
:
"
Fetch
"
url
:
trackingUrl
}
)
;
}
)
;
ok
(
!
result
"
Dedicated
worker
fetch
to
a
tracker
domain
should
be
blocked
by
tracking
protection
"
)
;
result
=
await
new
content
.
Promise
(
resolve
=
>
{
worker
.
addEventListener
(
"
message
"
function
handler
(
e
)
{
if
(
e
.
data
.
type
=
=
=
"
FetchResult
"
)
{
if
(
e
.
data
.
success
)
{
resolve
(
true
)
;
}
else
{
resolve
(
false
)
;
}
worker
.
removeEventListener
(
"
message
"
handler
)
;
}
}
)
;
worker
.
postMessage
(
{
type
:
"
Fetch
"
url
:
nonTrackingUrl
}
)
;
}
)
;
ok
(
result
"
Dedicated
worker
fetch
to
non
-
tracking
domain
should
succeed
"
)
;
worker
.
terminate
(
)
;
}
)
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_sharedWorkerFetch
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_TOP_PAGE_HTTPS
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
TEST_TRACKER_DOMAIN
+
TEST_PATH
+
"
corsAllowed
.
html
"
TEST_4TH_PARTY_DOMAIN_HTTPS
+
TEST_PATH
+
"
corsAllowed
.
html
"
]
async
(
trackingUrl
nonTrackingUrl
)
=
>
{
let
worker
=
new
content
.
SharedWorker
(
"
sharedWorkerFetch
.
js
"
)
;
let
result
=
await
new
content
.
Promise
(
resolve
=
>
{
worker
.
port
.
addEventListener
(
"
message
"
function
handler
(
e
)
{
if
(
e
.
data
.
type
=
=
=
"
FetchResult
"
)
{
if
(
e
.
data
.
success
)
{
resolve
(
true
)
;
}
else
{
resolve
(
false
)
;
}
worker
.
port
.
removeEventListener
(
"
message
"
handler
)
;
}
}
)
;
worker
.
port
.
start
(
)
;
worker
.
port
.
postMessage
(
{
type
:
"
Fetch
"
url
:
trackingUrl
}
)
;
}
)
;
ok
(
!
result
"
Shared
worker
fetch
to
a
tracker
domain
should
be
blocked
by
tracking
protection
"
)
;
result
=
await
new
content
.
Promise
(
resolve
=
>
{
worker
.
port
.
addEventListener
(
"
message
"
function
handler
(
e
)
{
if
(
e
.
data
.
type
=
=
=
"
FetchResult
"
)
{
if
(
e
.
data
.
success
)
{
resolve
(
true
)
;
}
else
{
resolve
(
false
)
;
}
worker
.
port
.
removeEventListener
(
"
message
"
handler
)
;
}
}
)
;
worker
.
port
.
postMessage
(
{
type
:
"
Fetch
"
url
:
nonTrackingUrl
}
)
;
}
)
;
ok
(
result
"
Shared
worker
fetch
to
non
-
tracking
domain
should
succeed
"
)
;
worker
.
port
.
close
(
)
;
}
)
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_serviceWorkerFetch
(
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_TOP_PAGE_HTTPS
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
TEST_TRACKER_DOMAIN
+
TEST_PATH
+
"
corsAllowed
.
html
"
TEST_4TH_PARTY_DOMAIN_HTTPS
+
TEST_PATH
+
"
corsAllowed
.
html
"
]
async
(
trackingUrl
nonTrackingUrl
)
=
>
{
let
reg
=
await
content
.
navigator
.
serviceWorker
.
register
(
"
serviceWorkerFetch
.
js
"
)
;
if
(
reg
.
installing
.
state
!
=
=
"
activated
"
)
{
await
new
content
.
Promise
(
resolve
=
>
{
let
w
=
reg
.
installing
;
w
.
addEventListener
(
"
statechange
"
function
onStateChange
(
)
{
if
(
w
.
state
=
=
=
"
activated
"
)
{
w
.
removeEventListener
(
"
statechange
"
onStateChange
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
let
result
=
await
new
content
.
Promise
(
resolve
=
>
{
content
.
navigator
.
serviceWorker
.
addEventListener
(
"
message
"
function
handler
(
e
)
{
if
(
e
.
data
.
type
=
=
=
"
FetchResult
"
)
{
if
(
e
.
data
.
success
)
{
resolve
(
true
)
;
}
else
{
resolve
(
false
)
;
}
content
.
navigator
.
serviceWorker
.
removeEventListener
(
"
message
"
handler
)
;
}
}
)
;
reg
.
active
.
postMessage
(
{
type
:
"
Fetch
"
url
:
trackingUrl
}
)
;
}
)
;
ok
(
!
result
"
Service
worker
fetch
to
a
tracker
domain
should
be
blocked
by
tracking
protection
"
)
;
result
=
await
new
content
.
Promise
(
resolve
=
>
{
content
.
navigator
.
serviceWorker
.
addEventListener
(
"
message
"
function
handler
(
e
)
{
if
(
e
.
data
.
type
=
=
=
"
FetchResult
"
)
{
if
(
e
.
data
.
success
)
{
resolve
(
true
)
;
}
else
{
resolve
(
false
)
;
}
content
.
navigator
.
serviceWorker
.
removeEventListener
(
"
message
"
handler
)
;
}
}
)
;
reg
.
active
.
postMessage
(
{
type
:
"
Fetch
"
url
:
nonTrackingUrl
}
)
;
}
)
;
ok
(
result
"
Service
worker
fetch
to
a
non
-
tracking
domain
should
succeed
.
"
)
;
await
reg
.
unregister
(
)
;
}
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
