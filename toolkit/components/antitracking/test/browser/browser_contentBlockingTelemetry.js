"
use
strict
"
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
)
;
const
LABEL_STORAGE_GRANTED
=
0
;
const
LABEL_STORAGE_ACCESS_API
=
1
;
const
LABEL_OPENER_AFTER_UI
=
2
;
const
LABEL_OPENER
=
3
;
const
LABEL_REDIRECT
=
4
;
function
clearTelemetry
(
)
{
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
true
)
;
Services
.
telemetry
.
getHistogramById
(
"
STORAGE_ACCESS_REMAINING_DAYS
"
)
.
clear
(
)
;
}
async
function
testTelemetry
(
aProbeInParent
aExpectedCnt
aLabel
aExpectedIdx
)
{
info
(
"
Trigger
the
'
idle
-
daily
'
to
trigger
the
telemetry
probe
.
"
)
;
let
cbts
=
Cc
[
"
mozilla
.
org
/
content
-
blocking
-
telemetry
-
service
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
cbts
.
observe
(
null
"
idle
-
daily
"
null
)
;
let
storageAccessGrantedHistogram
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
let
histograms
;
if
(
aProbeInParent
)
{
histograms
=
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
.
parent
;
}
else
{
histograms
=
Services
.
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
.
content
;
}
storageAccessGrantedHistogram
=
histograms
.
STORAGE_ACCESS_GRANTED_COUNT
;
return
(
!
!
storageAccessGrantedHistogram
&
&
storageAccessGrantedHistogram
.
values
[
LABEL_STORAGE_GRANTED
]
=
=
aExpectedCnt
)
;
}
)
;
is
(
storageAccessGrantedHistogram
.
values
[
LABEL_STORAGE_GRANTED
]
aExpectedCnt
"
There
should
be
expected
storage
access
granted
count
in
telemetry
.
"
)
;
is
(
storageAccessGrantedHistogram
.
values
[
aLabel
]
1
"
There
should
be
one
reason
count
in
telemetry
.
"
)
;
let
storageAccessRemainingDaysHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
STORAGE_ACCESS_REMAINING_DAYS
"
)
;
TelemetryTestUtils
.
assertHistogram
(
storageAccessRemainingDaysHistogram
aExpectedIdx
1
)
;
clearTelemetry
(
)
;
}
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
network
.
cookie
.
cookieBehavior
"
BEHAVIOR_REJECT_TRACKER
]
[
"
network
.
cookie
.
cookieBehavior
.
pbmode
"
BEHAVIOR_REJECT_TRACKER
]
[
"
privacy
.
trackingprotection
.
annotate_channels
"
true
]
[
"
privacy
.
restrict3rdpartystorage
.
userInteractionRequiredForHosts
"
"
tracking
.
example
.
com
tracking
.
example
.
org
"
]
[
"
privacy
.
restrict3rdpartystorage
.
heuristic
.
redirect
"
true
]
[
"
toolkit
.
telemetry
.
ipcBatchTimeout
"
0
]
]
}
)
;
clearTelemetry
(
)
;
await
UrlClassifierTestUtils
.
addTestTrackers
(
)
;
registerCleanupFunction
(
_
=
>
{
Services
.
perms
.
removeAll
(
)
;
}
)
;
}
)
;
add_task
(
async
function
testTelemetryForStorageAccessAPI
(
)
{
info
(
"
Starting
testing
if
storage
access
API
send
telemetry
probe
.
.
.
"
)
;
Services
.
perms
.
removeAll
(
)
;
info
(
"
Creating
a
new
tab
"
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
TEST_TOP_PAGE
)
;
gBrowser
.
selectedTab
=
tab
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
info
(
"
Loading
the
tracking
iframe
and
call
the
RequestStorageAccess
.
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
{
page
:
TEST_3RD_PARTY_PAGE_UI
}
]
async
obj
=
>
{
let
msg
=
{
}
;
msg
.
callback
=
(
async
_
=
>
{
await
callRequestStorageAccess
(
)
;
}
)
.
toString
(
)
;
await
new
content
.
Promise
(
resolve
=
>
{
let
ifr
=
content
.
document
.
createElement
(
"
iframe
"
)
;
ifr
.
onload
=
function
(
)
{
info
(
"
Sending
code
to
the
3rd
party
content
"
)
;
ifr
.
contentWindow
.
postMessage
(
msg
"
*
"
)
;
}
;
content
.
addEventListener
(
"
message
"
function
msg
(
event
)
{
if
(
event
.
data
.
type
=
=
"
finish
"
)
{
content
.
removeEventListener
(
"
message
"
msg
)
;
resolve
(
)
;
return
;
}
if
(
event
.
data
.
type
=
=
"
ok
"
)
{
ok
(
event
.
data
.
what
event
.
data
.
msg
)
;
return
;
}
if
(
event
.
data
.
type
=
=
"
info
"
)
{
info
(
event
.
data
.
msg
)
;
return
;
}
ok
(
false
"
Unknown
message
"
)
;
}
)
;
content
.
document
.
body
.
appendChild
(
ifr
)
;
ifr
.
src
=
obj
.
page
;
}
)
;
}
)
;
info
(
"
Removing
the
tab
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
testTelemetry
(
false
1
LABEL_STORAGE_ACCESS_API
29
)
;
}
)
;
add_task
(
async
function
testTelemetryForWindowOpenHeuristic
(
)
{
info
(
"
Starting
testing
if
window
open
heuristic
send
telemetry
probe
.
.
.
"
)
;
Services
.
perms
.
removeAll
(
)
;
info
(
"
Creating
a
new
tab
"
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
TEST_TOP_PAGE
)
;
gBrowser
.
selectedTab
=
tab
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
info
(
"
Loading
the
tracking
iframe
and
trigger
the
heuristic
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
{
page
:
TEST_3RD_PARTY_PAGE_WO
}
]
async
obj
=
>
{
let
msg
=
{
}
;
msg
.
blockingCallback
=
(
async
_
=
>
{
await
noStorageAccessInitially
(
)
;
}
)
.
toString
(
)
;
msg
.
nonBlockingCallback
=
(
async
_
=
>
{
await
hasStorageAccessInitially
(
)
;
}
)
.
toString
(
)
;
info
(
"
Checking
if
storage
access
is
denied
"
)
;
await
new
content
.
Promise
(
resolve
=
>
{
let
ifr
=
content
.
document
.
createElement
(
"
iframe
"
)
;
ifr
.
onload
=
function
(
)
{
info
(
"
Sending
code
to
the
3rd
party
content
"
)
;
ifr
.
contentWindow
.
postMessage
(
msg
"
*
"
)
;
}
;
content
.
addEventListener
(
"
message
"
function
msg
(
event
)
{
if
(
event
.
data
.
type
=
=
"
finish
"
)
{
content
.
removeEventListener
(
"
message
"
msg
)
;
resolve
(
)
;
return
;
}
if
(
event
.
data
.
type
=
=
"
ok
"
)
{
ok
(
event
.
data
.
what
event
.
data
.
msg
)
;
return
;
}
if
(
event
.
data
.
type
=
=
"
info
"
)
{
info
(
event
.
data
.
msg
)
;
return
;
}
ok
(
false
"
Unknown
message
"
)
;
}
)
;
content
.
document
.
body
.
appendChild
(
ifr
)
;
ifr
.
src
=
obj
.
page
;
}
)
;
}
)
;
info
(
"
Removing
the
tab
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
testTelemetry
(
false
1
LABEL_OPENER
29
)
;
}
)
;
add_task
(
async
function
testTelemetryForUserInteractionHeuristic
(
)
{
info
(
"
Starting
testing
if
UserInteraction
heuristic
send
telemetry
probe
.
.
.
"
)
;
Services
.
perms
.
removeAll
(
)
;
info
(
"
Creating
a
new
tab
"
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
TEST_TOP_PAGE
)
;
gBrowser
.
selectedTab
=
tab
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
info
(
"
Interact
with
the
tracker
in
top
-
level
.
"
)
;
await
AntiTracking
.
interactWithTracker
(
)
;
info
(
"
Loading
the
tracking
iframe
and
trigger
the
heuristic
"
)
;
await
SpecialPowers
.
spawn
(
browser
[
{
page
:
TEST_3RD_PARTY_PAGE_UI
popup
:
TEST_POPUP_PAGE
}
]
async
obj
=
>
{
let
msg
=
{
}
;
msg
.
blockingCallback
=
(
async
_
=
>
{
await
noStorageAccessInitially
(
)
;
}
)
.
toString
(
)
;
msg
.
nonBlockingCallback
=
(
async
_
=
>
{
await
hasStorageAccessInitially
(
)
;
}
)
.
toString
(
)
;
let
ifr
=
content
.
document
.
createElement
(
"
iframe
"
)
;
let
loading
=
new
content
.
Promise
(
resolve
=
>
{
ifr
.
onload
=
resolve
;
}
)
;
content
.
document
.
body
.
appendChild
(
ifr
)
;
ifr
.
src
=
obj
.
page
;
await
loading
;
info
(
"
Opening
a
window
from
the
iframe
.
"
)
;
await
SpecialPowers
.
spawn
(
ifr
[
obj
.
popup
]
async
popup
=
>
{
let
windowClosed
=
new
content
.
Promise
(
resolve
=
>
{
Services
.
ww
.
registerNotification
(
function
notification
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
domwindowclosed
"
&
&
aSubject
.
document
.
documentURI
=
=
"
https
:
/
/
tracking
.
example
.
org
/
browser
/
toolkit
/
components
/
antitracking
/
test
/
browser
/
3rdPartyOpenUI
.
html
"
)
{
Services
.
ww
.
unregisterNotification
(
notification
)
;
resolve
(
)
;
}
}
)
;
}
)
;
content
.
open
(
popup
)
;
info
(
"
Let
'
s
wait
for
the
window
to
be
closed
"
)
;
await
windowClosed
;
}
)
;
}
)
;
info
(
"
Removing
the
tab
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
testTelemetry
(
false
2
LABEL_OPENER_AFTER_UI
29
)
;
}
)
;
add_task
(
async
function
testTelemetryForRedirectHeuristic
(
)
{
info
(
"
Starting
testing
if
redirect
heuristic
send
telemetry
probe
.
.
.
"
)
;
const
TEST_TRACKING_PAGE
=
TEST_3RD_PARTY_DOMAIN
+
TEST_PATH
+
"
page
.
html
"
;
const
TEST_REDIRECT_PAGE
=
TEST_3RD_PARTY_DOMAIN
+
TEST_PATH
+
"
redirect
.
sjs
?
"
+
TEST_TOP_PAGE
;
Services
.
perms
.
removeAll
(
)
;
info
(
"
Creating
a
new
tab
"
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
TEST_TRACKING_PAGE
)
;
gBrowser
.
selectedTab
=
tab
;
let
browser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
info
(
"
Loading
the
tracking
page
and
trigger
the
redirect
.
"
)
;
SpecialPowers
.
spawn
(
browser
[
TEST_REDIRECT_PAGE
]
async
url
=
>
{
content
.
document
.
userInteractionForTesting
(
)
;
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
appendChild
(
content
.
document
.
createTextNode
(
"
click
me
!
"
)
)
;
link
.
href
=
url
;
content
.
document
.
body
.
appendChild
(
link
)
;
link
.
click
(
)
;
}
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
TEST_TOP_PAGE
)
;
info
(
"
Removing
the
tab
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
testTelemetry
(
true
1
LABEL_REDIRECT
0
)
;
}
)
;
