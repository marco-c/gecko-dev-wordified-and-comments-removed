"
use
strict
"
;
const
FIRST_PARTY_A
=
"
http
:
/
/
example
.
com
"
;
const
FIRST_PARTY_B
=
"
http
:
/
/
example
.
org
"
;
const
THIRD_PARTY
=
"
http
:
/
/
example
.
net
"
;
const
WS_ENDPOINT_HOST
=
"
mochi
.
test
:
8888
"
;
function
getWSTestUrlForHost
(
host
)
{
return
(
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
ws
:
/
/
{
host
}
)
+
file_ws_handshake_delay
)
;
}
function
connect
(
browsingContext
host
protocol
)
{
let
url
=
getWSTestUrlForHost
(
host
)
;
info
(
"
Creating
websocket
with
endpoint
"
+
url
)
;
let
createPromise
=
SpecialPowers
.
spawn
(
browsingContext
.
children
[
0
]
[
url
protocol
]
(
url
protocol
)
=
>
{
let
ws
=
new
content
.
WebSocket
(
url
[
protocol
]
)
;
ws
.
addEventListener
(
"
error
"
(
)
=
>
{
ws
.
_testError
=
true
;
}
)
;
if
(
!
content
.
ws
)
{
content
.
ws
=
{
}
;
}
content
.
ws
[
protocol
]
=
ws
;
}
)
;
let
openPromise
=
createPromise
.
then
(
(
)
=
>
SpecialPowers
.
spawn
(
browsingContext
.
children
[
0
]
[
protocol
]
async
protocol
=
>
{
let
ws
=
content
.
ws
[
protocol
]
;
if
(
ws
.
readyState
!
=
0
)
{
return
!
ws
.
_testError
;
}
let
result
=
await
Promise
.
race
(
[
ContentTaskUtils
.
waitForEvent
(
ws
"
open
"
)
ContentTaskUtils
.
waitForEvent
(
ws
"
error
"
)
]
)
;
return
result
.
type
!
=
"
error
"
;
}
)
)
;
let
result
=
{
createPromise
openPromise
}
;
return
result
;
}
async
function
runTest
(
partitioned
)
{
let
prefs
=
[
[
"
privacy
.
partition
.
network_state
.
ws_connection_queue
"
partitioned
]
]
;
if
(
partitioned
)
{
prefs
.
push
(
[
"
privacy
.
partition
.
network_state
"
partitioned
]
)
;
}
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
prefs
}
)
;
let
tabA
=
BrowserTestUtils
.
addTab
(
gBrowser
FIRST_PARTY_A
)
;
await
BrowserTestUtils
.
browserLoaded
(
tabA
.
linkedBrowser
)
;
let
tabB
=
BrowserTestUtils
.
addTab
(
gBrowser
FIRST_PARTY_B
)
;
await
BrowserTestUtils
.
browserLoaded
(
tabB
.
linkedBrowser
)
;
for
(
let
tab
of
[
tabA
tabB
]
)
{
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
THIRD_PARTY
]
async
src
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
frame
.
src
=
src
;
let
loadPromise
=
ContentTaskUtils
.
waitForEvent
(
frame
"
load
"
)
;
content
.
document
.
body
.
appendChild
(
frame
)
;
await
loadPromise
;
}
)
;
}
let
{
openPromise
createPromise
}
=
await
connect
(
tabA
.
linkedBrowser
.
browsingContext
WS_ENDPOINT_HOST
false
)
;
await
createPromise
;
let
openPromiseResult
=
await
openPromise
;
ok
(
openPromiseResult
"
Websocket
endpoint
accepts
connections
.
"
)
;
let
openedA
;
let
openedB
;
let
openedC
;
let
{
createPromise
:
createPromiseA
openPromise
:
openPromiseA
}
=
connect
(
tabA
.
linkedBrowser
.
browsingContext
WS_ENDPOINT_HOST
"
test
-
6
"
)
;
openPromiseA
=
openPromiseA
.
then
(
opened
=
>
{
openedA
=
opened
;
info
(
"
Completed
WS
connection
A
"
)
;
if
(
partitioned
)
{
ok
(
openedA
"
Should
have
opened
A
"
)
;
ok
(
openedB
"
Should
have
opened
B
"
)
;
}
else
{
ok
(
openedA
"
Should
have
opened
A
"
)
;
ok
(
openedB
=
=
null
"
B
should
be
pending
"
)
;
}
}
)
;
await
createPromiseA
;
let
{
createPromise
:
createPromiseB
openPromise
:
openPromiseB
}
=
connect
(
tabB
.
linkedBrowser
.
browsingContext
WS_ENDPOINT_HOST
"
test
-
3
"
)
;
openPromiseB
=
openPromiseB
.
then
(
opened
=
>
{
openedB
=
opened
;
info
(
"
Completed
WS
connection
B
"
)
;
if
(
partitioned
)
{
ok
(
openedA
=
=
null
"
A
should
be
pending
"
)
;
ok
(
openedB
"
Should
have
opened
B
"
)
;
ok
(
openedC
=
=
null
"
C
should
be
pending
"
)
;
}
else
{
ok
(
openedA
"
Should
have
opened
A
"
)
;
ok
(
openedB
"
Should
have
opened
B
"
)
;
ok
(
openedC
=
=
null
"
C
should
be
pending
"
)
;
}
}
)
;
await
createPromiseB
;
let
{
createPromise
:
createPromiseC
openPromise
:
openPromiseC
}
=
connect
(
tabB
.
linkedBrowser
.
browsingContext
WS_ENDPOINT_HOST
"
test
-
0
"
)
;
openPromiseC
=
openPromiseC
.
then
(
opened
=
>
{
openedC
=
opened
;
info
(
"
Completed
WS
connection
C
"
)
;
if
(
partitioned
)
{
ok
(
openedB
"
Should
have
opened
B
"
)
;
ok
(
openedC
"
Should
have
opened
C
"
)
;
}
else
{
ok
(
opened
"
Should
have
opened
B
"
)
;
ok
(
opened
"
Should
have
opened
C
"
)
;
}
}
)
;
await
createPromiseC
;
await
Promise
.
all
(
[
openPromiseA
openPromiseB
openPromiseC
]
)
;
BrowserTestUtils
.
removeTab
(
tabA
)
;
BrowserTestUtils
.
removeTab
(
tabB
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
network
.
websocket
.
timeout
.
open
"
20
]
]
}
)
;
}
)
;
add_task
(
async
function
test_non_partitioned
(
)
{
await
runTest
(
false
)
;
}
)
;
add_task
(
async
function
test_partitioned
(
)
{
await
runTest
(
true
)
;
}
)
;
