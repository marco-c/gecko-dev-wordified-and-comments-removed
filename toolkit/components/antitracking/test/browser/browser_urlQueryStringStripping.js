"
use
strict
"
;
requestLongerTimeout
(
6
)
;
const
TEST_THIRD_PARTY_DOMAIN
=
TEST_DOMAIN_2
;
const
TEST_THIRD_PARTY_SUB_DOMAIN
=
"
http
:
/
/
sub1
.
xn
-
-
exmple
-
cua
.
test
/
"
;
const
TEST_URI
=
TEST_DOMAIN
+
TEST_PATH
+
"
file_stripping
.
html
"
;
const
TEST_THIRD_PARTY_URI
=
TEST_THIRD_PARTY_DOMAIN
+
TEST_PATH
+
"
file_stripping
.
html
"
;
const
TEST_REDIRECT_URI
=
TEST_DOMAIN
+
TEST_PATH
+
"
redirect
.
sjs
"
;
const
TEST_CASES
=
[
{
testQueryString
:
"
paramToStrip1
=
123
"
strippedQueryString
:
"
"
}
{
testQueryString
:
"
PARAMTOSTRIP1
=
123
&
paramToStrip2
=
456
"
strippedQueryString
:
"
"
}
{
testQueryString
:
"
paramToStrip1
=
123
&
paramToKeep
=
456
"
strippedQueryString
:
"
paramToKeep
=
456
"
}
{
testQueryString
:
"
paramToStrip1
=
123
&
paramToKeep
=
456
&
paramToStrip2
=
abc
"
strippedQueryString
:
"
paramToKeep
=
456
"
}
{
testQueryString
:
"
paramToKeep
=
123
"
strippedQueryString
:
"
paramToKeep
=
123
"
}
{
testQueryString
:
"
paramToStrip1
=
123
&
paramToKeep
=
?
!
%
"
strippedQueryString
:
"
paramToKeep
=
?
!
%
"
}
]
;
let
listService
;
function
observeChannel
(
uri
expected
)
{
return
TestUtils
.
topicObserved
(
"
http
-
on
-
modify
-
request
"
(
subject
data
)
=
>
{
let
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
let
channelURI
=
channel
.
URI
;
if
(
channelURI
.
spec
.
startsWith
(
uri
)
)
{
is
(
channelURI
.
query
expected
"
The
loading
channel
has
the
expected
query
string
.
"
)
;
return
true
;
}
return
false
;
}
)
;
}
async
function
verifyQueryString
(
browser
expected
)
{
await
SpecialPowers
.
spawn
(
browser
[
expected
]
expected
=
>
{
let
search
=
content
.
location
.
search
.
slice
(
1
)
;
is
(
search
expected
"
The
query
string
is
correct
.
"
)
;
}
)
;
}
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
query_stripping
.
strip_list
"
"
paramToStrip1
paramToStrip2
"
]
[
"
privacy
.
query_stripping
.
redirect
"
true
]
[
"
privacy
.
query_stripping
.
listService
.
logLevel
"
"
Debug
"
]
[
"
privacy
.
query_stripping
.
strip_on_share
.
enabled
"
false
]
]
}
)
;
listService
=
Cc
[
"
mozilla
.
org
/
query
-
stripping
-
list
-
service
;
1
"
]
.
getService
(
Ci
.
nsIURLQueryStrippingListService
)
;
await
listService
.
testWaitForInit
(
)
;
}
)
;
async
function
waitForListServiceInit
(
strippingEnabled
)
{
info
(
"
Waiting
for
nsIURLQueryStrippingListService
to
be
initialized
.
"
)
;
let
isInitialized
=
await
listService
.
testWaitForInit
(
)
;
is
(
isInitialized
strippingEnabled
"
nsIURLQueryStrippingListService
should
be
initialized
when
the
feature
is
enabled
.
"
)
;
}
add_task
(
async
function
doTestsForTabOpen
(
)
{
info
(
"
Start
testing
query
stripping
for
tab
open
.
"
)
;
for
(
const
strippingEnabled
of
[
false
true
]
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
query_stripping
.
enabled
"
strippingEnabled
]
]
}
)
;
await
waitForListServiceInit
(
strippingEnabled
)
;
for
(
const
test
of
TEST_CASES
)
{
let
testURI
=
TEST_URI
+
"
?
"
+
test
.
testQueryString
;
let
expected
=
strippingEnabled
?
test
.
strippedQueryString
:
test
.
testQueryString
;
let
networkPromise
=
observeChannel
(
TEST_URI
expected
)
;
await
BrowserTestUtils
.
withNewTab
(
testURI
async
browser
=
>
{
await
verifyQueryString
(
browser
expected
)
;
}
)
;
await
networkPromise
;
}
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
)
;
add_task
(
async
function
doTestsForWindowOpen
(
)
{
info
(
"
Start
testing
query
stripping
for
window
.
open
(
)
.
"
)
;
for
(
const
strippingEnabled
of
[
false
true
]
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
query_stripping
.
enabled
"
strippingEnabled
]
]
}
)
;
await
waitForListServiceInit
(
strippingEnabled
)
;
for
(
const
test
of
TEST_CASES
)
{
let
testFirstPartyURI
=
TEST_URI
+
"
?
"
+
test
.
testQueryString
;
let
testThirdPartyURI
=
TEST_THIRD_PARTY_URI
+
"
?
"
+
test
.
testQueryString
;
let
originalQueryString
=
test
.
testQueryString
;
let
expectedQueryString
=
strippingEnabled
?
test
.
strippedQueryString
:
test
.
testQueryString
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
networkPromise
=
observeChannel
(
TEST_URI
originalQueryString
)
;
let
newTabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
url
=
>
{
return
url
.
startsWith
(
TEST_URI
)
;
}
)
;
await
SpecialPowers
.
spawn
(
browser
[
testFirstPartyURI
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
window
-
open
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
let
newTab
=
await
newTabPromise
;
await
verifyQueryString
(
newTab
.
linkedBrowser
originalQueryString
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
networkPromise
=
observeChannel
(
TEST_THIRD_PARTY_URI
expectedQueryString
)
;
newTabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
url
=
>
{
return
url
.
startsWith
(
TEST_THIRD_PARTY_URI
)
;
}
)
;
await
SpecialPowers
.
spawn
(
browser
[
testThirdPartyURI
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
window
-
open
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
newTab
=
await
newTabPromise
;
await
verifyQueryString
(
newTab
.
linkedBrowser
expectedQueryString
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
}
)
;
}
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
)
;
add_task
(
async
function
doTestsForLinkClick
(
)
{
info
(
"
Start
testing
query
stripping
for
link
navigation
.
"
)
;
for
(
const
strippingEnabled
of
[
false
true
]
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
query_stripping
.
enabled
"
strippingEnabled
]
]
}
)
;
await
waitForListServiceInit
(
strippingEnabled
)
;
for
(
const
test
of
TEST_CASES
)
{
let
testFirstPartyURI
=
TEST_URI
+
"
?
"
+
test
.
testQueryString
;
let
testThirdPartyURI
=
TEST_THIRD_PARTY_URI
+
"
?
"
+
test
.
testQueryString
;
let
originalQueryString
=
test
.
testQueryString
;
let
expectedQueryString
=
strippingEnabled
?
test
.
strippedQueryString
:
test
.
testQueryString
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
networkPromise
=
observeChannel
(
TEST_URI
originalQueryString
)
;
let
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
testFirstPartyURI
)
;
await
SpecialPowers
.
spawn
(
browser
[
testFirstPartyURI
]
async
uri
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
setAttribute
(
"
href
"
uri
)
;
link
.
textContent
=
"
Link
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
link
.
click
(
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
browser
originalQueryString
)
;
networkPromise
=
observeChannel
(
TEST_THIRD_PARTY_URI
expectedQueryString
)
;
let
targetURI
=
expectedQueryString
?
{
TEST_THIRD_PARTY_URI
}
?
{
expectedQueryString
}
:
TEST_THIRD_PARTY_URI
;
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
targetURI
)
;
await
SpecialPowers
.
spawn
(
browser
[
testThirdPartyURI
]
async
uri
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
setAttribute
(
"
href
"
uri
)
;
link
.
textContent
=
"
Link
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
link
.
click
(
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
browser
expectedQueryString
)
;
}
)
;
}
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
)
;
add_task
(
async
function
doTestsForLinkClickInIframe
(
)
{
info
(
"
Start
testing
query
stripping
for
link
navigation
in
iframe
.
"
)
;
for
(
const
strippingEnabled
of
[
false
true
]
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
query_stripping
.
enabled
"
strippingEnabled
]
]
}
)
;
await
waitForListServiceInit
(
strippingEnabled
)
;
for
(
const
test
of
TEST_CASES
)
{
let
testFirstPartyURI
=
TEST_URI
+
"
?
"
+
test
.
testQueryString
;
let
testThirdPartyURI
=
TEST_THIRD_PARTY_URI
+
"
?
"
+
test
.
testQueryString
;
let
originalQueryString
=
test
.
testQueryString
;
let
expectedQueryString
=
strippingEnabled
?
test
.
strippedQueryString
:
test
.
testQueryString
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
iframeBC
=
await
SpecialPowers
.
spawn
(
browser
[
TEST_URI
]
async
url
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
content
.
document
.
body
.
appendChild
(
frame
)
;
await
new
Promise
(
done
=
>
{
frame
.
addEventListener
(
"
load
"
function
(
)
{
done
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
frame
.
setAttribute
(
"
src
"
url
)
;
}
)
;
return
frame
.
browsingContext
;
}
)
;
let
networkPromise
=
observeChannel
(
TEST_URI
originalQueryString
)
;
let
newTabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
testFirstPartyURI
)
;
await
SpecialPowers
.
spawn
(
iframeBC
[
testFirstPartyURI
]
async
uri
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
setAttribute
(
"
href
"
uri
)
;
link
.
setAttribute
(
"
target
"
"
_blank
"
)
;
link
.
textContent
=
"
Link
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
link
.
click
(
)
;
}
)
;
await
networkPromise
;
let
newOpenedTab
=
await
newTabPromise
;
await
verifyQueryString
(
newOpenedTab
.
linkedBrowser
originalQueryString
)
;
BrowserTestUtils
.
removeTab
(
newOpenedTab
)
;
networkPromise
=
observeChannel
(
TEST_THIRD_PARTY_URI
expectedQueryString
)
;
let
targetURI
=
expectedQueryString
?
{
TEST_THIRD_PARTY_URI
}
?
{
expectedQueryString
}
:
TEST_THIRD_PARTY_URI
;
newTabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
targetURI
)
;
await
SpecialPowers
.
spawn
(
iframeBC
[
testThirdPartyURI
]
async
uri
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
setAttribute
(
"
href
"
uri
)
;
link
.
setAttribute
(
"
target
"
"
_blank
"
)
;
link
.
textContent
=
"
Link
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
link
.
click
(
)
;
}
)
;
await
networkPromise
;
newOpenedTab
=
await
newTabPromise
;
await
verifyQueryString
(
newOpenedTab
.
linkedBrowser
expectedQueryString
)
;
BrowserTestUtils
.
removeTab
(
newOpenedTab
)
;
}
)
;
}
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
)
;
add_task
(
async
function
doTestsForScriptNavigation
(
)
{
info
(
"
Start
testing
query
stripping
for
script
navigation
.
"
)
;
for
(
const
strippingEnabled
of
[
false
true
]
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
query_stripping
.
enabled
"
strippingEnabled
]
]
}
)
;
await
waitForListServiceInit
(
strippingEnabled
)
;
for
(
const
test
of
TEST_CASES
)
{
let
testFirstPartyURI
=
TEST_URI
+
"
?
"
+
test
.
testQueryString
;
let
testThirdPartyURI
=
TEST_THIRD_PARTY_URI
+
"
?
"
+
test
.
testQueryString
;
let
originalQueryString
=
test
.
testQueryString
;
let
expectedQueryString
=
strippingEnabled
?
test
.
strippedQueryString
:
test
.
testQueryString
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
networkPromise
=
observeChannel
(
TEST_URI
originalQueryString
)
;
let
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
testFirstPartyURI
)
;
await
SpecialPowers
.
spawn
(
browser
[
testFirstPartyURI
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
script
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
browser
originalQueryString
)
;
let
targetURI
=
expectedQueryString
?
{
TEST_THIRD_PARTY_URI
}
?
{
expectedQueryString
}
:
TEST_THIRD_PARTY_URI
;
networkPromise
=
observeChannel
(
TEST_THIRD_PARTY_URI
expectedQueryString
)
;
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
targetURI
)
;
await
SpecialPowers
.
spawn
(
browser
[
testThirdPartyURI
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
script
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
browser
expectedQueryString
)
;
}
)
;
}
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
)
;
add_task
(
async
function
doTestsForNoStrippingForIframeNavigation
(
)
{
info
(
"
Start
testing
no
query
stripping
for
iframe
navigation
.
"
)
;
for
(
const
strippingEnabled
of
[
false
true
]
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
query_stripping
.
enabled
"
strippingEnabled
]
]
}
)
;
await
waitForListServiceInit
(
strippingEnabled
)
;
for
(
const
test
of
TEST_CASES
)
{
let
testFirstPartyURI
=
TEST_URI
+
"
?
"
+
test
.
testQueryString
;
let
testThirdPartyURI
=
TEST_THIRD_PARTY_URI
+
"
?
"
+
test
.
testQueryString
;
let
originalQueryString
=
test
.
testQueryString
;
let
expectedQueryString
=
test
.
testQueryString
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
iframeBC
=
await
SpecialPowers
.
spawn
(
browser
[
TEST_URI
]
async
url
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
content
.
document
.
body
.
appendChild
(
frame
)
;
await
new
Promise
(
done
=
>
{
frame
.
addEventListener
(
"
load
"
function
(
)
{
done
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
frame
.
setAttribute
(
"
src
"
url
)
;
}
)
;
return
frame
.
browsingContext
;
}
)
;
let
networkPromise
=
observeChannel
(
TEST_URI
originalQueryString
)
;
let
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
testFirstPartyURI
)
;
await
SpecialPowers
.
spawn
(
iframeBC
[
testFirstPartyURI
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
script
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
iframeBC
originalQueryString
)
;
let
targetURI
=
expectedQueryString
?
{
TEST_THIRD_PARTY_URI
}
?
{
expectedQueryString
}
:
TEST_THIRD_PARTY_URI
;
networkPromise
=
observeChannel
(
TEST_THIRD_PARTY_URI
expectedQueryString
)
;
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
targetURI
)
;
await
SpecialPowers
.
spawn
(
iframeBC
[
testThirdPartyURI
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
script
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
iframeBC
expectedQueryString
)
;
}
)
;
}
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
)
;
add_task
(
async
function
doTestsForRedirect
(
)
{
info
(
"
Start
testing
query
stripping
for
redirects
.
"
)
;
for
(
const
strippingEnabled
of
[
false
true
]
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
query_stripping
.
enabled
"
strippingEnabled
]
]
}
)
;
await
waitForListServiceInit
(
strippingEnabled
)
;
for
(
const
test
of
TEST_CASES
)
{
let
testFirstPartyURI
=
TEST_REDIRECT_URI
+
"
?
"
+
TEST_URI
+
"
?
"
+
test
.
testQueryString
;
let
testThirdPartyURI
=
{
TEST_REDIRECT_URI
}
?
{
TEST_THIRD_PARTY_URI
}
?
{
test
.
testQueryString
}
;
let
originalQueryString
=
test
.
testQueryString
;
let
expectedQueryString
=
strippingEnabled
?
test
.
strippedQueryString
:
test
.
testQueryString
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
networkPromise
=
observeChannel
(
TEST_URI
originalQueryString
)
;
let
targetURI
=
{
TEST_URI
}
?
{
originalQueryString
}
;
let
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
targetURI
)
;
await
SpecialPowers
.
spawn
(
browser
[
testFirstPartyURI
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
script
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
browser
originalQueryString
)
;
targetURI
=
expectedQueryString
?
{
TEST_THIRD_PARTY_URI
}
?
{
expectedQueryString
}
:
TEST_THIRD_PARTY_URI
;
networkPromise
=
observeChannel
(
TEST_THIRD_PARTY_URI
expectedQueryString
)
;
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
targetURI
)
;
await
SpecialPowers
.
spawn
(
browser
[
testThirdPartyURI
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
script
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
browser
expectedQueryString
)
;
}
)
;
}
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
)
;
add_task
(
async
function
doTestForAllowList
(
)
{
info
(
"
Start
testing
query
stripping
allow
list
.
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
query_stripping
.
enabled
"
true
]
[
"
privacy
.
query_stripping
.
allow_list
"
"
xn
-
-
exmple
-
cua
.
test
"
]
]
}
)
;
await
waitForListServiceInit
(
true
)
;
const
expected
=
"
paramToStrip1
=
123
"
;
for
(
const
domain
of
[
TEST_THIRD_PARTY_DOMAIN
TEST_THIRD_PARTY_SUB_DOMAIN
]
)
{
let
testURI
=
{
domain
}
{
TEST_PATH
}
file_stripping
.
html
;
let
testURIWithQueryString
=
{
testURI
}
?
{
expected
}
;
info
(
"
Run
tab
open
test
.
"
)
;
let
networkPromise
=
observeChannel
(
testURI
expected
)
;
await
BrowserTestUtils
.
withNewTab
(
testURIWithQueryString
async
browser
=
>
{
await
verifyQueryString
(
browser
expected
)
;
}
)
;
await
networkPromise
;
info
(
"
Run
window
open
test
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
networkPromise
=
observeChannel
(
testURI
expected
)
;
let
newTabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
url
=
>
{
return
url
.
startsWith
(
testURI
)
;
}
)
;
await
SpecialPowers
.
spawn
(
browser
[
testURIWithQueryString
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
window
-
open
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
let
newTab
=
await
newTabPromise
;
await
verifyQueryString
(
newTab
.
linkedBrowser
expected
)
;
BrowserTestUtils
.
removeTab
(
newTab
)
;
}
)
;
info
(
"
Run
link
click
test
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
networkPromise
=
observeChannel
(
testURI
expected
)
;
let
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
testURIWithQueryString
)
;
await
SpecialPowers
.
spawn
(
browser
[
testURIWithQueryString
]
async
url
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
setAttribute
(
"
href
"
url
)
;
link
.
textContent
=
"
Link
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
link
.
click
(
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
browser
expected
)
;
}
)
;
info
(
"
Run
link
click
in
iframe
test
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
iframeBC
=
await
SpecialPowers
.
spawn
(
browser
[
TEST_URI
]
async
url
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
content
.
document
.
body
.
appendChild
(
frame
)
;
await
new
Promise
(
done
=
>
{
frame
.
addEventListener
(
"
load
"
function
(
)
{
done
(
)
;
}
{
capture
:
true
once
:
true
}
)
;
frame
.
setAttribute
(
"
src
"
url
)
;
}
)
;
return
frame
.
browsingContext
;
}
)
;
let
networkPromise
=
observeChannel
(
testURI
expected
)
;
let
newTabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
testURIWithQueryString
)
;
await
SpecialPowers
.
spawn
(
iframeBC
[
testURIWithQueryString
]
async
uri
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
setAttribute
(
"
href
"
uri
)
;
link
.
setAttribute
(
"
target
"
"
_blank
"
)
;
link
.
textContent
=
"
Link
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
link
.
click
(
)
;
}
)
;
await
networkPromise
;
let
newOpenedTab
=
await
newTabPromise
;
await
verifyQueryString
(
newOpenedTab
.
linkedBrowser
expected
)
;
BrowserTestUtils
.
removeTab
(
newOpenedTab
)
;
info
(
"
Run
script
navigation
test
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
networkPromise
=
observeChannel
(
testURI
expected
)
;
let
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
testURIWithQueryString
)
;
await
SpecialPowers
.
spawn
(
browser
[
testURIWithQueryString
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
script
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
browser
expected
)
;
}
)
;
info
(
"
Run
redirect
test
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
TEST_URI
async
browser
=
>
{
let
networkPromise
=
observeChannel
(
testURI
expected
)
;
let
locationChangePromise
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
testURIWithQueryString
)
;
let
testRedirectURI
=
{
TEST_REDIRECT_URI
}
?
{
testURI
}
?
{
expected
}
;
await
SpecialPowers
.
spawn
(
browser
[
testRedirectURI
]
async
url
=
>
{
content
.
postMessage
(
{
type
:
"
script
"
url
}
"
*
"
)
;
}
)
;
await
networkPromise
;
await
locationChangePromise
;
await
verifyQueryString
(
browser
expected
)
;
}
)
;
}
)
;
}
}
)
;
