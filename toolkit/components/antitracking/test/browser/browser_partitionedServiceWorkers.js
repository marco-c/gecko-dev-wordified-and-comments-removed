PartitionedStorageHelper
.
runTest
(
"
ServiceWorkers
-
disable
partitioning
"
async
(
win3rdParty
win1stParty
allowed
)
=
>
{
await
win3rdParty
.
navigator
.
serviceWorker
.
register
(
"
empty
.
js
"
)
.
then
(
_
=
>
{
ok
(
allowed
"
Success
:
ServiceWorker
cannot
be
used
!
"
)
;
}
_
=
>
{
ok
(
!
allowed
"
Failed
:
ServiceWorker
cannot
be
used
!
"
)
;
}
)
;
await
win1stParty
.
navigator
.
serviceWorker
.
register
(
"
empty
.
js
"
)
.
then
(
_
=
>
{
ok
(
true
"
Success
:
ServiceWorker
should
be
available
!
"
)
;
}
_
=
>
{
ok
(
false
"
Failed
:
ServiceWorker
should
be
available
!
"
)
;
}
)
;
}
async
_
=
>
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
value
=
>
resolve
(
)
)
;
}
)
;
}
[
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
privacy
.
partition
.
serviceWorkers
"
false
]
]
)
;
PartitionedStorageHelper
.
runTest
(
"
ServiceWorkers
-
enable
partitioning
"
async
(
win3rdParty
win1stParty
allowed
)
=
>
{
await
win3rdParty
.
navigator
.
serviceWorker
.
register
(
"
empty
.
js
"
)
.
then
(
_
=
>
{
ok
(
true
"
Success
:
ServiceWorker
should
be
available
in
third
parties
.
"
)
;
}
_
=
>
{
ok
(
false
"
Failed
:
ServiceWorker
should
be
available
in
third
parties
.
"
)
;
}
)
;
await
win1stParty
.
navigator
.
serviceWorker
.
register
(
"
empty
.
js
"
)
.
then
(
_
=
>
{
ok
(
true
"
Success
:
ServiceWorker
should
be
available
!
"
)
;
}
_
=
>
{
ok
(
false
"
Failed
:
ServiceWorker
should
be
available
!
"
)
;
}
)
;
}
async
_
=
>
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
value
=
>
resolve
(
)
)
;
}
)
;
}
[
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
privacy
.
partition
.
serviceWorkers
"
true
]
]
)
;
PartitionedStorageHelper
.
runTest
(
"
ServiceWorkers
-
MatchAll
"
async
(
win3rdParty
win1stParty
allowed
)
=
>
{
if
(
!
win1stParty
.
sw
)
{
win1stParty
.
sw
=
await
registerServiceWorker
(
win1stParty
"
matchAll
.
js
"
)
;
}
let
msgPromise
=
new
Promise
(
resolve
=
>
{
win1stParty
.
navigator
.
serviceWorker
.
addEventListener
(
"
message
"
msg
=
>
{
resolve
(
msg
.
data
)
;
}
)
;
}
)
;
win1stParty
.
sw
.
postMessage
(
win3rdParty
.
location
.
href
)
;
let
msg
=
await
msgPromise
;
is
(
false
msg
"
We
won
'
t
have
the
3rd
party
window
controlled
regardless
of
StorageAccess
.
"
)
;
}
async
_
=
>
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
value
=
>
resolve
(
)
)
;
}
)
;
}
[
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
privacy
.
partition
.
serviceWorkers
"
true
]
]
)
;
PartitionedStorageHelper
.
runTest
(
"
ServiceWorkers
-
Partition
ScriptContext
"
async
(
win3rdParty
win1stParty
allowed
)
=
>
{
if
(
!
win1stParty
.
sw
)
{
win1stParty
.
sw
=
await
registerServiceWorker
(
win1stParty
"
serviceWorker
.
js
"
)
;
}
if
(
!
win3rdParty
.
sw
)
{
win3rdParty
.
sw
=
await
registerServiceWorker
(
win3rdParty
"
serviceWorker
.
js
"
)
;
}
let
res
=
await
sendAndWaitWorkerMessage
(
win1stParty
.
sw
win1stParty
.
navigator
.
serviceWorker
{
type
:
"
SetScriptValue
"
value
:
"
1stParty
"
}
)
;
ok
(
res
.
result
"
OK
"
"
Set
script
value
to
first
-
party
service
worker
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win3rdParty
.
sw
win3rdParty
.
navigator
.
serviceWorker
{
type
:
"
SetScriptValue
"
value
:
"
3rdParty
"
}
)
;
ok
(
res
.
result
"
OK
"
"
Set
script
value
to
third
-
party
service
worker
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win1stParty
.
sw
win1stParty
.
navigator
.
serviceWorker
{
type
:
"
GetScriptValue
"
}
)
;
is
(
res
.
value
"
1stParty
"
"
The
script
value
in
first
party
window
is
correct
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win3rdParty
.
sw
win3rdParty
.
navigator
.
serviceWorker
{
type
:
"
GetScriptValue
"
}
)
;
is
(
res
.
value
"
3rdParty
"
"
The
script
value
in
third
party
window
is
correct
"
)
;
}
async
_
=
>
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
value
=
>
resolve
(
)
)
;
}
)
;
}
[
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
privacy
.
partition
.
serviceWorkers
"
true
]
]
)
;
PartitionedStorageHelper
.
runTest
(
"
ServiceWorkers
-
Partition
DOM
Cache
"
async
(
win3rdParty
win1stParty
allowed
)
=
>
{
if
(
!
win1stParty
.
sw
)
{
win1stParty
.
sw
=
await
registerServiceWorker
(
win1stParty
"
serviceWorker
.
js
"
)
;
}
if
(
!
win3rdParty
.
sw
)
{
win3rdParty
.
sw
=
await
registerServiceWorker
(
win3rdParty
"
serviceWorker
.
js
"
)
;
}
let
res
=
await
sendAndWaitWorkerMessage
(
win1stParty
.
sw
win1stParty
.
navigator
.
serviceWorker
{
type
:
"
SetCache
"
value
:
"
1stParty
"
}
)
;
ok
(
res
.
result
"
OK
"
"
Set
cache
to
first
-
party
service
worker
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win3rdParty
.
sw
win3rdParty
.
navigator
.
serviceWorker
{
type
:
"
SetCache
"
value
:
"
3rdParty
"
}
)
;
ok
(
res
.
result
"
OK
"
"
Set
cache
to
third
-
party
service
worker
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win1stParty
.
sw
win1stParty
.
navigator
.
serviceWorker
{
type
:
"
HasCache
"
value
:
"
1stParty
"
}
)
;
ok
(
res
.
value
"
The
'
1stParty
'
cache
storage
should
exist
for
the
first
-
party
window
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win1stParty
.
sw
win1stParty
.
navigator
.
serviceWorker
{
type
:
"
HasCache
"
value
:
"
3rdParty
"
}
)
;
ok
(
!
res
.
value
"
The
'
3rdParty
'
cache
storage
should
not
exist
for
the
first
-
party
window
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win3rdParty
.
sw
win3rdParty
.
navigator
.
serviceWorker
{
type
:
"
HasCache
"
value
:
"
1stParty
"
}
)
;
ok
(
!
res
.
value
"
The
'
1stParty
'
cache
storage
should
not
exist
for
the
third
-
party
window
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win3rdParty
.
sw
win3rdParty
.
navigator
.
serviceWorker
{
type
:
"
HasCache
"
value
:
"
3rdParty
"
}
)
;
ok
(
res
.
value
"
The
'
3rdParty
'
cache
storage
should
exist
for
the
third
-
party
window
.
"
)
;
}
async
_
=
>
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
value
=
>
resolve
(
)
)
;
}
)
;
}
[
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
privacy
.
partition
.
serviceWorkers
"
true
]
]
)
;
PartitionedStorageHelper
.
runTest
(
"
ServiceWorkers
-
Partition
IndexedDB
"
async
(
win3rdParty
win1stParty
allowed
)
=
>
{
if
(
!
win1stParty
.
sw
)
{
win1stParty
.
sw
=
await
registerServiceWorker
(
win1stParty
"
serviceWorker
.
js
"
)
;
}
if
(
!
win3rdParty
.
sw
)
{
win3rdParty
.
sw
=
await
registerServiceWorker
(
win3rdParty
"
serviceWorker
.
js
"
)
;
}
let
res
=
await
sendAndWaitWorkerMessage
(
win1stParty
.
sw
win1stParty
.
navigator
.
serviceWorker
{
type
:
"
SetIndexedDB
"
value
:
"
1stParty
"
}
)
;
ok
(
res
.
result
"
OK
"
"
Set
cache
to
first
-
party
service
worker
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win3rdParty
.
sw
win3rdParty
.
navigator
.
serviceWorker
{
type
:
"
SetIndexedDB
"
value
:
"
3rdParty
"
}
)
;
ok
(
res
.
result
"
OK
"
"
Set
cache
to
third
-
party
service
worker
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win1stParty
.
sw
win1stParty
.
navigator
.
serviceWorker
{
type
:
"
GetIndexedDB
"
}
)
;
is
(
res
.
value
"
1stParty
"
"
The
indexedDB
value
in
first
party
window
is
correct
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win3rdParty
.
sw
win3rdParty
.
navigator
.
serviceWorker
{
type
:
"
GetIndexedDB
"
}
)
;
is
(
res
.
value
"
3rdParty
"
"
The
indexedDB
value
in
third
party
window
is
correct
"
)
;
}
async
_
=
>
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
value
=
>
resolve
(
)
)
;
}
)
;
}
[
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
privacy
.
partition
.
serviceWorkers
"
true
]
]
)
;
PartitionedStorageHelper
.
runTest
(
"
ServiceWorkers
-
Partition
Intercept
"
async
(
win3rdParty
win1stParty
allowed
)
=
>
{
if
(
!
win1stParty
.
sw
)
{
win1stParty
.
sw
=
await
registerServiceWorker
(
win1stParty
"
serviceWorker
.
js
"
)
;
}
if
(
!
win3rdParty
.
sw
)
{
win3rdParty
.
sw
=
await
registerServiceWorker
(
win3rdParty
"
serviceWorker
.
js
"
)
;
}
await
win1stParty
.
fetch
(
"
empty
.
js
"
)
;
let
res
=
await
sendAndWaitWorkerMessage
(
win1stParty
.
sw
win1stParty
.
navigator
.
serviceWorker
{
type
:
"
GetFetchURL
"
}
)
;
is
(
res
.
value
"
http
:
/
/
not
-
tracking
.
example
.
com
/
browser
/
toolkit
/
components
/
antitracking
/
test
/
browser
/
empty
.
js
"
"
The
first
-
party
service
worker
received
fetch
event
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win3rdParty
.
sw
win3rdParty
.
navigator
.
serviceWorker
{
type
:
"
GetFetchURL
"
}
)
;
is
(
res
.
value
"
"
"
The
third
-
party
service
worker
received
no
fetch
event
.
"
)
;
await
win3rdParty
.
fetch
(
"
empty
.
js
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win1stParty
.
sw
win1stParty
.
navigator
.
serviceWorker
{
type
:
"
GetFetchURL
"
}
)
;
is
(
res
.
value
"
"
"
The
first
-
party
service
worker
received
no
fetch
event
.
"
)
;
res
=
await
sendAndWaitWorkerMessage
(
win3rdParty
.
sw
win3rdParty
.
navigator
.
serviceWorker
{
type
:
"
GetFetchURL
"
}
)
;
is
(
res
.
value
"
http
:
/
/
not
-
tracking
.
example
.
com
/
browser
/
toolkit
/
components
/
antitracking
/
test
/
browser
/
empty
.
js
"
"
The
third
-
party
service
worker
received
fetch
event
.
"
)
;
}
async
_
=
>
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
value
=
>
resolve
(
)
)
;
}
)
;
}
[
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
privacy
.
partition
.
serviceWorkers
"
true
]
]
)
;
PartitionedStorageHelper
.
runTest
(
"
ServiceWorkers
-
Create
Dedicated
Worker
"
async
(
win3rdParty
win1stParty
allowed
)
=
>
{
if
(
!
allowed
)
{
return
;
}
if
(
!
win1stParty
.
sw
)
{
win1stParty
.
sw
=
await
registerServiceWorker
(
win1stParty
"
serviceWorker
.
js
"
)
;
}
if
(
!
win3rdParty
.
sw
)
{
win3rdParty
.
sw
=
await
registerServiceWorker
(
win3rdParty
"
serviceWorker
.
js
"
)
;
}
let
firstPartyWorker
=
new
win1stParty
.
Worker
(
"
dedicatedWorker
.
js
"
)
;
await
new
Promise
(
resolve
=
>
{
firstPartyWorker
.
addEventListener
(
"
message
"
msg
=
>
{
if
(
msg
.
data
=
=
"
1stParty
"
)
{
resolve
(
)
;
}
}
)
;
firstPartyWorker
.
postMessage
(
"
1stParty
"
)
;
}
)
;
let
thirdPartyWorker
=
new
win3rdParty
.
Worker
(
"
dedicatedWorker
.
js
"
)
;
await
new
Promise
(
resolve
=
>
{
thirdPartyWorker
.
addEventListener
(
"
message
"
msg
=
>
{
if
(
msg
.
data
=
=
"
3rdParty
"
)
{
resolve
(
)
;
}
}
)
;
thirdPartyWorker
.
postMessage
(
"
3rdParty
"
)
;
}
)
;
firstPartyWorker
.
terminate
(
)
;
thirdPartyWorker
.
terminate
(
)
;
}
async
_
=
>
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
value
=
>
resolve
(
)
)
;
}
)
;
}
[
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
]
)
;
