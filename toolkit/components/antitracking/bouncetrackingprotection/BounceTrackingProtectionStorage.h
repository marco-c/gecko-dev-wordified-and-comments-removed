#
ifndef
mozilla_BounceTrackingProtectionStorage_h__
#
define
mozilla_BounceTrackingProtectionStorage_h__
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
ThreadSafety
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
FlippedOnce
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
mozilla
/
OriginAttributesHashKey
.
h
"
class
nsIPrincipal
;
class
mozIStorageConnection
;
namespace
mozilla
{
class
BounceTrackingStateGlobal
;
class
BounceTrackingState
;
class
OriginAttributes
;
extern
LazyLogModule
gBounceTrackingProtectionLog
;
class
BounceTrackingProtectionStorage
final
:
public
nsIObserver
public
nsIAsyncShutdownBlocker
public
SupportsWeakPtr
{
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSIASYNCSHUTDOWNBLOCKER
public
:
BounceTrackingProtectionStorage
(
)
:
mMonitor
(
"
mozilla
:
:
BounceTrackingProtectionStorage
:
:
mMonitor
"
)
mPendingWrites
(
0
)
{
}
;
nsresult
Init
(
)
;
BounceTrackingStateGlobal
*
GetOrCreateStateGlobal
(
const
OriginAttributes
&
aOriginAttributes
)
;
BounceTrackingStateGlobal
*
GetOrCreateStateGlobal
(
nsIPrincipal
*
aPrincipal
)
;
BounceTrackingStateGlobal
*
GetOrCreateStateGlobal
(
BounceTrackingState
*
aBounceTrackingState
)
;
using
StateGlobalMap
=
nsTHashMap
<
OriginAttributesHashKey
RefPtr
<
BounceTrackingStateGlobal
>
>
;
const
StateGlobalMap
&
StateGlobalMapRef
(
)
{
return
mStateGlobal
;
}
enum
class
EntryType
:
uint8_t
{
BounceTracker
=
0
UserActivation
=
1
}
;
nsresult
UpdateEntry
(
const
OriginAttributes
&
aOriginAttributes
const
nsACString
&
aSiteHost
EntryType
aEntryType
PRTime
aTimeStamp
)
;
nsresult
DeleteEntry
(
const
OriginAttributes
&
aOriginAttributes
const
nsACString
&
aSiteHost
)
;
nsresult
DeleteEntriesBefore
(
const
OriginAttributes
&
aOriginAttributes
PRTime
aTime
Maybe
<
EntryType
>
aEntryType
=
Nothing
{
}
)
;
nsresult
Clear
(
)
;
private
:
~
BounceTrackingProtectionStorage
(
)
=
default
;
nsCOMPtr
<
nsISerialEventTarget
>
mBackgroundThread
;
RefPtr
<
mozIStorageConnection
>
mDatabaseConnection
;
nsresult
WaitForInitialization
(
)
;
void
Finalize
(
)
;
already_AddRefed
<
nsIAsyncShutdownClient
>
GetAsyncShutdownBarrier
(
)
const
;
nsresult
CreateDatabaseConnection
(
)
;
nsresult
EnsureTable
(
)
;
struct
ImportEntry
{
OriginAttributes
mOriginAttributes
;
nsCString
mSiteHost
;
EntryType
mEntryType
;
PRTime
mTimeStamp
;
}
;
nsresult
LoadMemoryStateFromDisk
(
)
;
void
IncrementPendingWrites
(
)
;
void
DecrementPendingWrites
(
)
;
static
nsresult
UpsertData
(
mozIStorageConnection
*
aDatabaseConnection
const
OriginAttributes
&
aOriginAttributes
const
nsACString
&
aSiteHost
EntryType
aEntryType
PRTime
aTimeStamp
)
;
static
nsresult
DeleteData
(
mozIStorageConnection
*
aDatabaseConnection
const
OriginAttributes
&
aOriginAttributes
const
nsACString
&
aSiteHost
)
;
static
nsresult
DeleteDataBefore
(
mozIStorageConnection
*
aDatabaseConnection
PRTime
aTime
Maybe
<
BounceTrackingProtectionStorage
:
:
EntryType
>
aEntryType
=
Nothing
{
}
)
;
static
nsresult
ClearData
(
mozIStorageConnection
*
aDatabaseConnection
)
;
Monitor
mMonitor
;
FlippedOnce
<
false
>
mInitialized
MOZ_GUARDED_BY
(
mMonitor
)
;
FlippedOnce
<
false
>
mErrored
MOZ_GUARDED_BY
(
mMonitor
)
;
FlippedOnce
<
false
>
mShuttingDown
MOZ_GUARDED_BY
(
mMonitor
)
;
FlippedOnce
<
false
>
mFinalized
MOZ_GUARDED_BY
(
mMonitor
)
;
uint32_t
mPendingWrites
MOZ_GUARDED_BY
(
mMonitor
)
;
nsCOMPtr
<
nsIFile
>
mDatabaseFile
;
StateGlobalMap
mStateGlobal
{
}
;
}
;
}
#
endif
