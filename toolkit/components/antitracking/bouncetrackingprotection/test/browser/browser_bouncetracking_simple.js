"
use
strict
"
;
const
SITE_A
=
"
example
.
com
"
;
const
ORIGIN_A
=
https
:
/
/
{
SITE_A
}
;
const
SITE_B
=
"
example
.
org
"
;
const
ORIGIN_B
=
https
:
/
/
{
SITE_B
}
;
const
SITE_C
=
"
example
.
net
"
;
const
ORIGIN_C
=
https
:
/
/
{
SITE_C
}
;
const
SITE_TRACKER
=
"
itisatracker
.
org
"
;
const
ORIGIN_TRACKER
=
https
:
/
/
{
SITE_TRACKER
}
;
const
SITE_TRACKER_B
=
"
trackertest
.
org
"
;
const
ORIGIN_TRACKER_B
=
http
:
/
/
{
SITE_TRACKER_B
}
;
const
OBSERVER_MSG_RECORD_BOUNCES_FINISHED
=
"
test
-
record
-
bounces
-
finished
"
;
const
ROOT_DIR
=
getRootDirectory
(
gTestPath
)
;
let
bounceTrackingProtection
;
function
getBaseUrl
(
origin
)
{
return
ROOT_DIR
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
origin
)
;
}
function
getBounceURL
(
{
bounceType
bounceOrigin
=
ORIGIN_TRACKER
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
doStatefulBounce
=
false
statusCode
=
302
redirectDelayMS
=
50
}
)
{
if
(
!
[
"
server
"
"
client
"
]
.
includes
(
bounceType
)
)
{
throw
new
Error
(
"
Invalid
bounceType
"
)
;
}
let
bounceFile
=
bounceType
=
=
"
client
"
?
"
file_bounce
.
html
"
:
"
file_bounce
.
sjs
"
;
let
bounceUrl
=
new
URL
(
getBaseUrl
(
bounceOrigin
)
+
bounceFile
)
;
let
{
searchParams
}
=
bounceUrl
;
searchParams
.
set
(
"
target
"
targetURL
.
href
)
;
if
(
doStatefulBounce
)
{
searchParams
.
set
(
"
setCookie
"
"
true
"
)
;
}
if
(
bounceType
=
=
"
server
"
)
{
searchParams
.
set
(
"
statusCode
"
statusCode
)
;
}
else
if
(
bounceType
=
=
"
client
"
)
{
searchParams
.
set
(
"
redirectDelay
"
redirectDelayMS
)
;
}
return
bounceUrl
;
}
async
function
navigateLinkClick
(
browser
targetURL
)
{
await
SpecialPowers
.
spawn
(
browser
[
targetURL
.
href
]
targetURL
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
href
=
targetURL
;
link
.
textContent
=
targetURL
;
link
.
style
.
display
=
"
block
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
}
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
a
[
href
]
"
{
}
browser
)
;
}
async
function
waitForObserverMessage
(
message
conditionFn
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
topic
!
=
message
)
{
return
;
}
if
(
conditionFn
(
subject
topic
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
message
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
message
)
;
}
)
;
}
async
function
waitForRecordBounces
(
browser
)
{
return
waitForObserverMessage
(
OBSERVER_MSG_RECORD_BOUNCES_FINISHED
subject
=
>
{
let
propBag
=
subject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
let
browserId
=
propBag
.
getProperty
(
"
browserId
"
)
;
return
browser
.
browsingContext
.
browserId
=
=
browserId
;
}
)
;
}
async
function
runTestBounceSimple
(
bounceType
)
{
Assert
.
equal
(
bounceTrackingProtection
.
bounceTrackerCandidateHosts
.
length
0
"
No
bounce
tracker
hosts
initially
.
"
)
;
Assert
.
equal
(
bounceTrackingProtection
.
userActivationHosts
.
length
0
"
No
user
activation
hosts
initially
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
getBaseUrl
(
ORIGIN_A
)
+
"
file_start
.
html
"
async
browser
=
>
{
let
promiseRecordBounces
=
waitForRecordBounces
(
browser
)
;
let
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
;
await
navigateLinkClick
(
browser
getBounceURL
(
{
bounceType
targetURL
}
)
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
targetURL
)
;
await
navigateLinkClick
(
browser
new
URL
(
getBaseUrl
(
ORIGIN_C
)
+
"
file_start
.
html
"
)
)
;
await
promiseRecordBounces
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
bounceTrackerCandidateHosts
[
SITE_TRACKER
]
Identified
{
SITE_TRACKER
}
as
a
bounce
tracker
.
)
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
userActivationHosts
.
sort
(
)
[
SITE_A
SITE_B
]
.
sort
(
)
"
Should
only
have
user
activation
for
sites
where
we
clicked
links
.
"
)
;
bounceTrackingProtection
.
reset
(
)
;
}
)
;
}
add_setup
(
async
function
(
)
{
bounceTrackingProtection
=
Cc
[
"
mozilla
.
org
/
bounce
-
tracking
-
protection
;
1
"
]
.
getService
(
Ci
.
nsIBounceTrackingProtection
)
;
}
)
;
add_task
(
async
function
test_client_bounce_simple
(
)
{
await
runTestBounceSimple
(
"
client
"
)
;
}
)
;
add_task
(
async
function
test_server_bounce_simple
(
)
{
await
runTestBounceSimple
(
"
server
"
)
;
}
)
;
add_task
(
async
function
test_bounce_chain
(
)
{
Assert
.
equal
(
bounceTrackingProtection
.
bounceTrackerCandidateHosts
.
length
0
"
No
bounce
tracker
hosts
initially
.
"
)
;
Assert
.
equal
(
bounceTrackingProtection
.
userActivationHosts
.
length
0
"
No
user
activation
hosts
initially
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
getBaseUrl
(
ORIGIN_A
)
+
"
file_start
.
html
"
async
browser
=
>
{
let
promiseRecordBounces
=
waitForRecordBounces
(
browser
)
;
let
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
;
let
bounceChainUrlEnd
=
getBounceURL
(
{
bounceType
:
"
server
"
targetURL
}
)
;
let
bounceChainUrlFull
=
getBounceURL
(
{
bounceType
:
"
client
"
redirectDelayMS
:
100
bounceOrigin
:
ORIGIN_TRACKER_B
targetURL
:
bounceChainUrlEnd
}
)
;
info
(
"
bounceChainUrl
:
"
+
bounceChainUrlFull
.
href
)
;
await
navigateLinkClick
(
browser
bounceChainUrlFull
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
targetURL
)
;
await
navigateLinkClick
(
browser
new
URL
(
getBaseUrl
(
ORIGIN_C
)
+
"
file_start
.
html
"
)
)
;
await
promiseRecordBounces
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
bounceTrackerCandidateHosts
.
sort
(
)
[
SITE_TRACKER_B
SITE_TRACKER
]
.
sort
(
)
Identified
all
bounce
trackers
in
the
redirect
chain
.
)
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
userActivationHosts
.
sort
(
)
[
SITE_A
SITE_B
]
.
sort
(
)
"
Should
only
have
user
activation
for
sites
where
we
clicked
links
.
"
)
;
bounceTrackingProtection
.
reset
(
)
;
}
)
;
}
)
;
