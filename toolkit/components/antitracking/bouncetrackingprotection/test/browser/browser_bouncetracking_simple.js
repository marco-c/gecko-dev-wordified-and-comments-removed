"
use
strict
"
;
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
bounceTrackingProtection
.
requireStatefulBounces
"
false
]
[
"
privacy
.
bounceTrackingProtection
.
bounceTrackingGracePeriodSec
"
0
]
]
}
)
;
}
)
;
add_task
(
async
function
test_client_bounce_simple
(
)
{
await
runTestBounce
(
{
bounceType
:
"
client
"
}
)
;
}
)
;
add_task
(
async
function
test_server_bounce_simple
(
)
{
await
runTestBounce
(
{
bounceType
:
"
server
"
}
)
;
}
)
;
add_task
(
async
function
test_bounce_chain
(
)
{
Assert
.
equal
(
bounceTrackingProtection
.
bounceTrackerCandidateHosts
.
length
0
"
No
bounce
tracker
hosts
initially
.
"
)
;
Assert
.
equal
(
bounceTrackingProtection
.
userActivationHosts
.
length
0
"
No
user
activation
hosts
initially
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
getBaseUrl
(
ORIGIN_A
)
+
"
file_start
.
html
"
async
browser
=
>
{
let
promiseRecordBounces
=
waitForRecordBounces
(
browser
)
;
let
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
;
let
bounceChainUrlEnd
=
getBounceURL
(
{
bounceType
:
"
server
"
targetURL
}
)
;
let
bounceChainUrlFull
=
getBounceURL
(
{
bounceType
:
"
client
"
redirectDelayMS
:
100
bounceOrigin
:
ORIGIN_TRACKER_B
targetURL
:
bounceChainUrlEnd
}
)
;
info
(
"
bounceChainUrl
:
"
+
bounceChainUrlFull
.
href
)
;
await
navigateLinkClick
(
browser
bounceChainUrlFull
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
targetURL
)
;
await
navigateLinkClick
(
browser
new
URL
(
getBaseUrl
(
ORIGIN_C
)
+
"
file_start
.
html
"
)
)
;
await
promiseRecordBounces
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
bounceTrackerCandidateHosts
.
sort
(
)
[
SITE_TRACKER_B
SITE_TRACKER
]
.
sort
(
)
Identified
all
bounce
trackers
in
the
redirect
chain
.
)
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
userActivationHosts
.
sort
(
)
[
SITE_A
SITE_B
]
.
sort
(
)
"
Should
only
have
user
activation
for
sites
where
we
clicked
links
.
"
)
;
bounceTrackingProtection
.
reset
(
)
;
}
)
;
}
)
;
