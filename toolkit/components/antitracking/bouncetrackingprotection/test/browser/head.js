"
use
strict
"
;
const
SITE_A
=
"
example
.
com
"
;
const
ORIGIN_A
=
https
:
/
/
{
SITE_A
}
;
const
SITE_B
=
"
example
.
org
"
;
const
ORIGIN_B
=
https
:
/
/
{
SITE_B
}
;
const
SITE_C
=
"
example
.
net
"
;
const
ORIGIN_C
=
https
:
/
/
{
SITE_C
}
;
const
SITE_TRACKER
=
"
itisatracker
.
org
"
;
const
ORIGIN_TRACKER
=
https
:
/
/
{
SITE_TRACKER
}
;
const
SITE_TRACKER_B
=
"
trackertest
.
org
"
;
const
ORIGIN_TRACKER_B
=
http
:
/
/
{
SITE_TRACKER_B
}
;
const
OBSERVER_MSG_RECORD_BOUNCES_FINISHED
=
"
test
-
record
-
bounces
-
finished
"
;
const
ROOT_DIR
=
getRootDirectory
(
gTestPath
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
bounceTrackingProtection
"
"
mozilla
.
org
/
bounce
-
tracking
-
protection
;
1
"
"
nsIBounceTrackingProtection
"
)
;
function
getBaseUrl
(
origin
)
{
return
ROOT_DIR
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
origin
)
;
}
function
getBounceURL
(
{
bounceType
bounceOrigin
=
ORIGIN_TRACKER
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
setState
=
null
setStateSameSiteFrame
=
false
setStateInWebWorker
=
false
statusCode
=
302
redirectDelayMS
=
50
}
)
{
if
(
!
[
"
server
"
"
client
"
]
.
includes
(
bounceType
)
)
{
throw
new
Error
(
"
Invalid
bounceType
"
)
;
}
let
bounceFile
=
bounceType
=
=
"
client
"
?
"
file_bounce
.
html
"
:
"
file_bounce
.
sjs
"
;
let
bounceUrl
=
new
URL
(
getBaseUrl
(
bounceOrigin
)
+
bounceFile
)
;
let
{
searchParams
}
=
bounceUrl
;
searchParams
.
set
(
"
target
"
targetURL
.
href
)
;
if
(
setState
)
{
searchParams
.
set
(
"
setState
"
setState
)
;
}
if
(
setStateSameSiteFrame
)
{
searchParams
.
set
(
"
setStateSameSiteFrame
"
setStateSameSiteFrame
)
;
}
if
(
setStateInWebWorker
)
{
if
(
setState
!
=
"
indexedDB
"
)
{
throw
new
Error
(
"
setStateInWebWorker
only
supports
setState
=
=
'
indexedDB
'
"
)
;
}
searchParams
.
set
(
"
setStateInWebWorker
"
setStateInWebWorker
)
;
}
if
(
bounceType
=
=
"
server
"
)
{
searchParams
.
set
(
"
statusCode
"
statusCode
)
;
}
else
if
(
bounceType
=
=
"
client
"
)
{
searchParams
.
set
(
"
redirectDelay
"
redirectDelayMS
)
;
}
return
bounceUrl
;
}
async
function
navigateLinkClick
(
browser
targetURL
)
{
await
SpecialPowers
.
spawn
(
browser
[
targetURL
.
href
]
targetURL
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
href
=
targetURL
;
link
.
textContent
=
targetURL
;
link
.
style
.
display
=
"
block
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
}
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
a
[
href
]
"
{
}
browser
)
;
}
async
function
waitForRecordBounces
(
browser
)
{
return
TestUtils
.
topicObserved
(
OBSERVER_MSG_RECORD_BOUNCES_FINISHED
subject
=
>
{
let
propBag
=
subject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
let
browserId
=
propBag
.
getProperty
(
"
browserId
"
)
;
return
browser
.
browsingContext
.
browserId
=
=
browserId
;
}
)
;
}
async
function
runTestBounce
(
options
=
{
}
)
{
let
{
bounceType
setState
=
null
setStateSameSiteFrame
=
false
setStateInWebWorker
=
false
expectCandidate
=
true
expectPurge
=
true
originAttributes
=
{
}
postBounceCallback
=
(
)
=
>
{
}
}
=
options
;
info
(
runTestBounce
{
JSON
.
stringify
(
options
)
}
)
;
Assert
.
equal
(
bounceTrackingProtection
.
testGetBounceTrackerCandidateHosts
(
originAttributes
)
.
length
0
"
No
bounce
tracker
hosts
initially
.
"
)
;
Assert
.
equal
(
bounceTrackingProtection
.
testGetUserActivationHosts
(
originAttributes
)
.
length
0
"
No
user
activation
hosts
initially
.
"
)
;
let
win
=
window
;
let
{
privateBrowsingId
userContextId
}
=
originAttributes
;
let
usePrivateWindow
=
privateBrowsingId
!
=
null
&
&
privateBrowsingId
!
=
Services
.
scriptSecurityManager
.
DEFAULT_PRIVATE_BROWSING_ID
;
if
(
userContextId
!
=
null
&
&
userContextId
>
0
&
&
usePrivateWindow
)
{
throw
new
Error
(
"
userContextId
is
not
supported
in
private
windows
"
)
;
}
if
(
usePrivateWindow
)
{
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
}
let
tab
=
win
.
gBrowser
.
addTab
(
getBaseUrl
(
ORIGIN_A
)
+
"
file_start
.
html
"
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
userContextId
}
)
;
win
.
gBrowser
.
selectedTab
=
tab
;
let
browser
=
tab
.
linkedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
let
promiseRecordBounces
=
waitForRecordBounces
(
browser
)
;
let
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
;
await
navigateLinkClick
(
browser
getBounceURL
(
{
bounceType
targetURL
setState
setStateSameSiteFrame
setStateInWebWorker
}
)
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
targetURL
)
;
await
navigateLinkClick
(
browser
new
URL
(
getBaseUrl
(
ORIGIN_C
)
+
"
file_start
.
html
"
)
)
;
await
promiseRecordBounces
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
testGetBounceTrackerCandidateHosts
(
originAttributes
)
expectCandidate
?
[
SITE_TRACKER
]
:
[
]
Should
{
expectCandidate
?
"
"
:
"
not
"
}
have
identified
{
SITE_TRACKER
}
as
a
bounce
tracker
.
)
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
testGetUserActivationHosts
(
originAttributes
)
.
sort
(
)
[
SITE_A
SITE_B
]
.
sort
(
)
"
Should
only
have
user
activation
for
sites
where
we
clicked
links
.
"
)
;
await
postBounceCallback
(
)
;
Assert
.
deepEqual
(
await
bounceTrackingProtection
.
testRunPurgeBounceTrackers
(
)
expectPurge
?
[
SITE_TRACKER
]
:
[
]
Should
{
expectPurge
?
"
"
:
"
not
"
}
purge
state
for
{
SITE_TRACKER
}
.
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
if
(
usePrivateWindow
)
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
info
(
"
Closing
the
last
PBM
window
should
trigger
a
purge
of
all
PBM
state
.
"
)
;
Assert
.
ok
(
!
bounceTrackingProtection
.
testGetBounceTrackerCandidateHosts
(
originAttributes
)
.
length
"
No
bounce
tracker
hosts
after
closing
private
window
.
"
)
;
Assert
.
ok
(
!
bounceTrackingProtection
.
testGetUserActivationHosts
(
originAttributes
)
.
length
"
No
user
activation
hosts
after
closing
private
window
.
"
)
;
}
bounceTrackingProtection
.
clearAll
(
)
;
}
