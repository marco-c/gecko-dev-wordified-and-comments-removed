"
use
strict
"
;
const
{
SiteDataTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
SiteDataTestUtils
.
sys
.
mjs
"
)
;
const
SITE_A
=
"
example
.
com
"
;
const
ORIGIN_A
=
https
:
/
/
{
SITE_A
}
;
const
SITE_B
=
"
example
.
org
"
;
const
ORIGIN_B
=
https
:
/
/
{
SITE_B
}
;
const
SITE_C
=
"
example
.
net
"
;
const
ORIGIN_C
=
https
:
/
/
{
SITE_C
}
;
const
SITE_TRACKER
=
"
itisatracker
.
org
"
;
const
ORIGIN_TRACKER
=
https
:
/
/
{
SITE_TRACKER
}
;
const
SITE_TRACKER_B
=
"
trackertest
.
org
"
;
const
ORIGIN_TRACKER_B
=
http
:
/
/
{
SITE_TRACKER_B
}
;
const
OBSERVER_MSG_RECORD_BOUNCES_FINISHED
=
"
test
-
record
-
bounces
-
finished
"
;
const
ROOT_DIR
=
getRootDirectory
(
gTestPath
)
;
function
getBaseUrl
(
origin
)
{
return
ROOT_DIR
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
origin
)
;
}
function
getBounceURL
(
{
bounceType
bounceOrigin
=
ORIGIN_TRACKER
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
setState
=
null
setStateSameSiteFrame
=
false
setStateCrossSiteFrame
=
false
setStateInWebWorker
=
false
setStateInNestedWebWorker
=
false
setCookieViaImage
=
null
statusCode
=
302
redirectDelayMS
=
50
}
)
{
if
(
!
[
"
server
"
"
client
"
]
.
includes
(
bounceType
)
)
{
throw
new
Error
(
"
Invalid
bounceType
"
)
;
}
let
bounceFile
=
bounceType
=
=
"
client
"
?
"
file_bounce
.
html
"
:
"
file_bounce
.
sjs
"
;
let
bounceUrl
=
new
URL
(
getBaseUrl
(
bounceOrigin
)
+
bounceFile
)
;
let
{
searchParams
}
=
bounceUrl
;
searchParams
.
set
(
"
target
"
targetURL
.
href
)
;
if
(
setState
)
{
searchParams
.
set
(
"
setState
"
setState
)
;
}
if
(
setStateInWebWorker
)
{
if
(
setState
!
=
"
indexedDB
"
)
{
throw
new
Error
(
"
setStateInWebWorker
only
supports
setState
=
=
'
indexedDB
'
"
)
;
}
searchParams
.
set
(
"
setStateInWebWorker
"
setStateInWebWorker
)
;
}
if
(
setStateInNestedWebWorker
)
{
if
(
setState
!
=
"
indexedDB
"
)
{
throw
new
Error
(
"
setStateInNestedWebWorker
only
supports
setState
=
=
'
indexedDB
'
"
)
;
}
searchParams
.
set
(
"
setStateInNestedWebWorker
"
setStateInNestedWebWorker
)
;
}
if
(
bounceType
=
=
"
server
"
)
{
searchParams
.
set
(
"
statusCode
"
statusCode
)
;
}
else
if
(
bounceType
=
=
"
client
"
)
{
searchParams
.
set
(
"
redirectDelay
"
redirectDelayMS
)
;
}
if
(
setStateSameSiteFrame
|
|
setStateCrossSiteFrame
)
{
let
bounceUrlIframe
=
new
URL
(
bounceUrl
.
href
)
;
bounceUrlIframe
.
searchParams
.
set
(
"
isThirdParty
"
true
)
;
if
(
setState
=
=
"
cookie
-
server
"
)
{
bounceUrlIframe
.
pathname
=
bounceUrlIframe
.
pathname
.
replace
(
"
file_bounce
.
html
"
"
file_bounce
.
sjs
"
)
;
}
if
(
setStateSameSiteFrame
)
{
searchParams
.
set
(
"
setStateInFrameWithURI
"
bounceUrlIframe
.
href
)
;
}
else
{
bounceUrlIframe
.
host
=
SITE_C
;
searchParams
.
set
(
"
setStateInFrameWithURI
"
bounceUrlIframe
.
href
)
;
}
}
else
if
(
setCookieViaImage
)
{
let
imageOrigin
=
setCookieViaImage
=
=
"
same
-
site
"
?
bounceOrigin
:
ORIGIN_C
;
let
imageURL
=
new
URL
(
getBaseUrl
(
imageOrigin
)
+
"
file_image
.
png
"
)
;
if
(
setState
!
=
"
cookie
-
server
"
)
{
throw
new
Error
(
"
setCookieViaImage
only
supports
setState
=
=
'
cookie
-
server
'
"
)
;
}
searchParams
.
set
(
"
setCookieViaImageWithURI
"
imageURL
.
href
)
;
}
return
bounceUrl
;
}
async
function
navigateLinkClick
(
browser
targetURL
{
spawnWindow
=
null
}
=
{
}
)
{
if
(
spawnWindow
&
&
!
[
"
newTab
"
"
popup
"
]
.
includes
(
spawnWindow
)
)
{
throw
new
Error
(
Invalid
option
'
{
spawnWindow
}
'
for
spawnWindow
)
;
}
await
SpecialPowers
.
spawn
(
browser
[
targetURL
.
href
spawnWindow
]
async
(
targetURL
spawnWindow
)
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
id
=
"
link
"
;
link
.
textContent
=
"
Click
Me
"
;
link
.
style
.
display
=
"
block
"
;
link
.
style
.
fontSize
=
"
40px
"
;
if
(
spawnWindow
)
{
link
.
href
=
"
#
"
;
link
.
addEventListener
(
"
click
"
event
=
>
{
event
.
preventDefault
(
)
;
if
(
spawnWindow
=
=
"
newTab
"
)
{
content
.
window
.
open
(
targetURL
"
bounce
"
)
;
}
else
{
content
.
window
.
open
(
targetURL
"
bounce
"
"
height
=
200
width
=
200
"
)
;
}
}
)
;
}
else
{
link
.
href
=
targetURL
;
}
content
.
document
.
body
.
appendChild
(
link
)
;
SpecialPowers
.
wrap
(
content
.
document
)
.
notifyUserGestureActivation
(
)
;
content
.
document
.
userInteractionForTesting
(
)
;
link
.
click
(
)
;
}
)
;
}
async
function
waitForRecordBounces
(
browser
)
{
let
{
browserId
}
=
browser
.
browsingContext
;
info
(
waitForRecordBounces
:
Waiting
for
record
bounces
for
browser
:
{
browserId
}
.
)
;
await
TestUtils
.
topicObserved
(
OBSERVER_MSG_RECORD_BOUNCES_FINISHED
subject
=
>
{
let
propBag
=
subject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
return
browserId
=
=
propBag
.
getProperty
(
"
browserId
"
)
;
}
)
;
info
(
waitForRecordBounces
:
Recorded
bounces
for
browser
{
browserId
}
.
)
;
}
async
function
runTestBounce
(
options
=
{
}
)
{
let
{
bounceType
setState
=
null
setStateSameSiteFrame
=
false
setStateCrossSiteFrame
=
false
setStateInWebWorker
=
false
setStateInNestedWebWorker
=
false
setCookieViaImage
=
null
expectRecordBounces
=
true
expectCandidate
=
true
expectPurge
=
true
originAttributes
=
{
}
postBounceCallback
=
(
)
=
>
{
}
skipStateChecks
=
false
skipSiteDataCleanup
=
false
skipBounceTrackingProtectionCleanup
=
false
closeTabAfterBounce
=
false
}
=
options
;
info
(
runTestBounce
{
JSON
.
stringify
(
options
)
}
)
;
let
btpIsDisabled
=
Services
.
prefs
.
getIntPref
(
"
privacy
.
bounceTrackingProtection
.
mode
"
)
=
=
Ci
.
nsIBounceTrackingProtection
.
MODE_DISABLED
;
let
bounceTrackingProtection
;
try
{
bounceTrackingProtection
=
Cc
[
"
mozilla
.
org
/
bounce
-
tracking
-
protection
;
1
"
]
.
getService
(
Ci
.
nsIBounceTrackingProtection
)
;
}
catch
(
error
)
{
if
(
!
btpIsDisabled
)
{
throw
error
;
}
}
if
(
!
skipStateChecks
)
{
if
(
btpIsDisabled
)
{
Assert
.
ok
(
!
expectCandidate
"
Expect
no
classification
in
disabled
mode
.
"
)
;
Assert
.
ok
(
!
expectRecordBounces
"
Expect
no
record
bounces
in
disabled
mode
.
"
)
;
Assert
.
ok
(
!
expectPurge
"
Expect
no
purge
in
disabled
mode
.
"
)
;
}
else
{
Assert
.
ok
(
bounceTrackingProtection
"
BTP
singleton
must
be
available
in
any
of
the
'
enabled
'
modes
.
"
)
;
}
if
(
bounceTrackingProtection
)
{
Assert
.
equal
(
bounceTrackingProtection
.
testGetBounceTrackerCandidateHosts
(
originAttributes
)
.
length
0
"
No
bounce
tracker
hosts
initially
.
"
)
;
Assert
.
equal
(
bounceTrackingProtection
.
testGetUserActivationHosts
(
originAttributes
)
.
length
0
"
No
user
activation
hosts
initially
.
"
)
;
}
}
let
win
=
window
;
let
{
privateBrowsingId
userContextId
}
=
originAttributes
;
let
usePrivateWindow
=
privateBrowsingId
!
=
null
&
&
privateBrowsingId
!
=
Services
.
scriptSecurityManager
.
DEFAULT_PRIVATE_BROWSING_ID
;
if
(
userContextId
!
=
null
&
&
userContextId
>
0
&
&
usePrivateWindow
)
{
throw
new
Error
(
"
userContextId
is
not
supported
in
private
windows
"
)
;
}
if
(
usePrivateWindow
)
{
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
}
let
initialURL
=
getBaseUrl
(
ORIGIN_A
)
+
"
file_start
.
html
"
;
let
tab
=
win
.
gBrowser
.
addTab
(
initialURL
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
userContextId
}
)
;
win
.
gBrowser
.
selectedTab
=
tab
;
let
browser
=
tab
.
linkedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
browser
true
initialURL
)
;
let
promiseRecordBounces
;
if
(
expectRecordBounces
)
{
promiseRecordBounces
=
waitForRecordBounces
(
browser
)
;
}
let
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
;
let
targetURLLoadedPromise
=
BrowserTestUtils
.
browserLoaded
(
browser
false
targetURL
)
;
await
navigateLinkClick
(
browser
getBounceURL
(
{
bounceType
targetURL
setState
setStateSameSiteFrame
setStateCrossSiteFrame
setStateInWebWorker
setStateInNestedWebWorker
setCookieViaImage
}
)
)
;
await
targetURLLoadedPromise
;
if
(
closeTabAfterBounce
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
tab
=
null
;
browser
=
null
;
}
else
{
let
finalTargetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_C
)
+
"
file_start
.
html
"
)
;
let
finalLoadPromise
=
BrowserTestUtils
.
browserLoaded
(
browser
true
initialURL
.
href
)
;
await
navigateLinkClick
(
browser
finalTargetURL
)
;
await
finalLoadPromise
;
}
if
(
expectRecordBounces
)
{
info
(
"
Waiting
for
record
-
bounces
to
complete
.
"
)
;
await
promiseRecordBounces
;
}
else
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
if
(
!
skipStateChecks
)
{
if
(
btpIsDisabled
)
{
if
(
bounceTrackingProtection
)
{
Assert
.
deepEqual
(
bounceTrackingProtection
.
testGetBounceTrackerCandidateHosts
(
originAttributes
)
.
map
(
entry
=
>
entry
.
siteHost
)
[
]
"
Should
not
have
identified
any
bounce
trackers
"
)
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
testGetUserActivationHosts
(
originAttributes
)
.
map
(
entry
=
>
entry
.
siteHost
)
[
]
"
Should
not
have
recorded
any
user
activation
"
)
;
}
else
{
info
(
"
BTP
singleton
is
unavailable
because
mode
is
MODE_DISABLED
.
"
)
;
}
}
else
{
Assert
.
deepEqual
(
bounceTrackingProtection
.
testGetBounceTrackerCandidateHosts
(
originAttributes
)
.
map
(
entry
=
>
entry
.
siteHost
)
expectCandidate
?
[
SITE_TRACKER
]
:
[
]
Should
{
expectCandidate
?
"
"
:
"
not
"
}
have
identified
{
SITE_TRACKER
}
as
a
bounce
tracker
.
)
;
let
expectedUserActivationHosts
=
[
SITE_A
]
;
if
(
!
closeTabAfterBounce
)
{
expectedUserActivationHosts
.
push
(
SITE_B
)
;
}
Assert
.
deepEqual
(
bounceTrackingProtection
.
testGetUserActivationHosts
(
originAttributes
)
.
map
(
entry
=
>
entry
.
siteHost
)
.
sort
(
)
expectedUserActivationHosts
.
sort
(
)
"
Should
only
have
user
activation
for
sites
where
we
clicked
links
.
"
)
;
}
}
await
postBounceCallback
(
)
;
if
(
bounceTrackingProtection
)
{
let
mode
=
Services
.
prefs
.
getIntPref
(
"
privacy
.
bounceTrackingProtection
.
mode
"
)
;
let
expectPurgingToThrow
=
mode
!
=
Ci
.
nsIBounceTrackingProtection
.
MODE_ENABLED
&
&
mode
!
=
Ci
.
nsIBounceTrackingProtection
.
MODE_ENABLED_DRY_RUN
;
if
(
expectPurgingToThrow
)
{
await
Assert
.
rejects
(
bounceTrackingProtection
.
testRunPurgeBounceTrackers
(
)
/
NS_ERROR_NOT_AVAILABLE
/
"
testRunPurgeBounceTrackers
should
reject
when
BTP
is
disabled
.
"
)
;
}
else
{
let
purgedHosts
=
await
bounceTrackingProtection
.
testRunPurgeBounceTrackers
(
)
;
if
(
!
skipStateChecks
)
{
Assert
.
deepEqual
(
purgedHosts
expectPurge
?
[
SITE_TRACKER
]
:
[
]
Should
{
expectPurge
?
"
"
:
"
not
"
}
purge
state
for
{
SITE_TRACKER
}
.
)
;
info
(
"
Testing
the
purge
log
.
"
)
;
let
purgeLog
=
bounceTrackingProtection
.
testGetRecentlyPurgedTrackers
(
originAttributes
)
;
if
(
expectPurge
&
&
mode
=
=
Ci
.
nsIBounceTrackingProtection
.
MODE_ENABLED
)
{
Assert
.
equal
(
purgeLog
.
length
1
"
Should
have
one
tracker
in
purge
log
.
"
)
;
let
{
siteHost
timeStamp
purgeTime
}
=
purgeLog
[
0
]
;
Assert
.
equal
(
siteHost
SITE_TRACKER
The
purge
log
entry
should
be
for
site
host
'
{
SITE_TRACKER
}
'
)
;
Assert
.
greater
(
timeStamp
0
"
The
purge
log
entry
should
have
a
valid
timestamp
for
bounce
time
.
"
)
;
Assert
.
greater
(
purgeTime
0
"
The
purge
log
entry
should
have
a
valid
timestamp
for
purge
time
.
"
)
;
Assert
.
greaterOrEqual
(
purgeTime
timeStamp
"
The
purge
time
should
be
greater
or
equal
to
bounce
time
.
"
)
;
}
else
{
Assert
.
equal
(
purgeLog
.
length
0
"
Should
have
no
trackers
in
purge
log
.
"
)
;
}
}
}
}
else
{
info
(
"
BTP
is
disabled
.
Skipping
purge
call
.
"
)
;
}
if
(
tab
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
if
(
usePrivateWindow
)
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
if
(
bounceTrackingProtection
)
{
info
(
"
Closing
the
last
PBM
window
should
trigger
a
purge
of
all
PBM
state
.
"
)
;
Assert
.
ok
(
!
bounceTrackingProtection
.
testGetBounceTrackerCandidateHosts
(
originAttributes
)
.
length
"
No
bounce
tracker
hosts
after
closing
private
window
.
"
)
;
Assert
.
ok
(
!
bounceTrackingProtection
.
testGetUserActivationHosts
(
originAttributes
)
.
length
"
No
user
activation
hosts
after
closing
private
window
.
"
)
;
}
}
if
(
!
skipBounceTrackingProtectionCleanup
)
{
bounceTrackingProtection
?
.
clearAll
(
)
;
}
if
(
!
skipSiteDataCleanup
)
{
await
SiteDataTestUtils
.
clear
(
)
;
}
}
