"
use
strict
"
;
const
SITE_A
=
"
example
.
com
"
;
const
ORIGIN_A
=
https
:
/
/
{
SITE_A
}
;
const
SITE_B
=
"
example
.
org
"
;
const
ORIGIN_B
=
https
:
/
/
{
SITE_B
}
;
const
SITE_C
=
"
example
.
net
"
;
const
ORIGIN_C
=
https
:
/
/
{
SITE_C
}
;
const
SITE_TRACKER
=
"
itisatracker
.
org
"
;
const
ORIGIN_TRACKER
=
https
:
/
/
{
SITE_TRACKER
}
;
const
SITE_TRACKER_B
=
"
trackertest
.
org
"
;
const
ORIGIN_TRACKER_B
=
http
:
/
/
{
SITE_TRACKER_B
}
;
const
OBSERVER_MSG_RECORD_BOUNCES_FINISHED
=
"
test
-
record
-
bounces
-
finished
"
;
const
ROOT_DIR
=
getRootDirectory
(
gTestPath
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
bounceTrackingProtection
"
"
mozilla
.
org
/
bounce
-
tracking
-
protection
;
1
"
"
nsIBounceTrackingProtection
"
)
;
function
getBaseUrl
(
origin
)
{
return
ROOT_DIR
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
origin
)
;
}
function
getBounceURL
(
{
bounceType
bounceOrigin
=
ORIGIN_TRACKER
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
setState
=
null
statusCode
=
302
redirectDelayMS
=
50
}
)
{
if
(
!
[
"
server
"
"
client
"
]
.
includes
(
bounceType
)
)
{
throw
new
Error
(
"
Invalid
bounceType
"
)
;
}
let
bounceFile
=
bounceType
=
=
"
client
"
?
"
file_bounce
.
html
"
:
"
file_bounce
.
sjs
"
;
let
bounceUrl
=
new
URL
(
getBaseUrl
(
bounceOrigin
)
+
bounceFile
)
;
let
{
searchParams
}
=
bounceUrl
;
searchParams
.
set
(
"
target
"
targetURL
.
href
)
;
if
(
setState
)
{
searchParams
.
set
(
"
setState
"
setState
)
;
}
if
(
bounceType
=
=
"
server
"
)
{
searchParams
.
set
(
"
statusCode
"
statusCode
)
;
}
else
if
(
bounceType
=
=
"
client
"
)
{
searchParams
.
set
(
"
redirectDelay
"
redirectDelayMS
)
;
}
return
bounceUrl
;
}
async
function
navigateLinkClick
(
browser
targetURL
)
{
await
SpecialPowers
.
spawn
(
browser
[
targetURL
.
href
]
targetURL
=
>
{
let
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
href
=
targetURL
;
link
.
textContent
=
targetURL
;
link
.
style
.
display
=
"
block
"
;
content
.
document
.
body
.
appendChild
(
link
)
;
}
)
;
await
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
a
[
href
]
"
{
}
browser
)
;
}
async
function
waitForObserverMessage
(
message
conditionFn
=
(
)
=
>
true
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
(
subject
topic
data
)
=
>
{
if
(
topic
!
=
message
)
{
return
;
}
if
(
conditionFn
(
subject
topic
data
)
)
{
Services
.
obs
.
removeObserver
(
observer
message
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
message
)
;
}
)
;
}
async
function
waitForRecordBounces
(
browser
)
{
return
waitForObserverMessage
(
OBSERVER_MSG_RECORD_BOUNCES_FINISHED
subject
=
>
{
let
propBag
=
subject
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
let
browserId
=
propBag
.
getProperty
(
"
browserId
"
)
;
return
browser
.
browsingContext
.
browserId
=
=
browserId
;
}
)
;
}
async
function
runTestBounce
(
options
=
{
}
)
{
let
{
bounceType
setState
=
null
expectCandidate
=
true
expectPurge
=
true
}
=
options
;
info
(
runTestBounce
{
JSON
.
stringify
(
options
)
}
)
;
Assert
.
equal
(
bounceTrackingProtection
.
bounceTrackerCandidateHosts
.
length
0
"
No
bounce
tracker
hosts
initially
.
"
)
;
Assert
.
equal
(
bounceTrackingProtection
.
userActivationHosts
.
length
0
"
No
user
activation
hosts
initially
.
"
)
;
await
BrowserTestUtils
.
withNewTab
(
getBaseUrl
(
ORIGIN_A
)
+
"
file_start
.
html
"
async
browser
=
>
{
let
promiseRecordBounces
=
waitForRecordBounces
(
browser
)
;
let
targetURL
=
new
URL
(
getBaseUrl
(
ORIGIN_B
)
+
"
file_start
.
html
"
)
;
await
navigateLinkClick
(
browser
getBounceURL
(
{
bounceType
targetURL
setState
}
)
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
targetURL
)
;
await
navigateLinkClick
(
browser
new
URL
(
getBaseUrl
(
ORIGIN_C
)
+
"
file_start
.
html
"
)
)
;
await
promiseRecordBounces
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
bounceTrackerCandidateHosts
expectCandidate
?
[
SITE_TRACKER
]
:
[
]
Should
{
expectCandidate
?
"
"
:
"
not
"
}
have
identified
{
SITE_TRACKER
}
as
a
bounce
tracker
.
)
;
Assert
.
deepEqual
(
bounceTrackingProtection
.
userActivationHosts
.
sort
(
)
[
SITE_A
SITE_B
]
.
sort
(
)
"
Should
only
have
user
activation
for
sites
where
we
clicked
links
.
"
)
;
Assert
.
deepEqual
(
await
bounceTrackingProtection
.
testRunPurgeBounceTrackers
(
)
expectPurge
?
[
SITE_TRACKER
]
:
[
]
Should
{
expectPurge
?
"
"
:
"
not
"
}
purge
state
for
{
SITE_TRACKER
}
.
)
;
bounceTrackingProtection
.
reset
(
)
;
}
)
;
}
