"
use
strict
"
;
const
{
Sqlite
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
sys
.
mjs
"
)
;
let
databasePath
;
async
function
countDatabaseEntries
(
)
{
let
db
=
await
Sqlite
.
openConnection
(
{
path
:
databasePath
}
)
;
let
result
=
await
db
.
execute
(
"
SELECT
COUNT
(
*
)
as
count
FROM
sites
"
)
;
await
db
.
close
(
)
;
return
result
[
0
]
.
getInt64
(
"
count
"
)
;
}
const
MAX_PENDING_UPDATES
=
Services
.
prefs
.
getIntPref
(
"
privacy
.
bounceTrackingProtection
.
storage
.
maxPendingUpdates
"
)
;
function
waitForObserverMessage
(
topic
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
{
observe
(
subject
observedTopic
data
)
{
if
(
observedTopic
=
=
=
topic
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
topic
data
}
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
observer
topic
)
;
}
)
;
}
async
function
waitForDBFlush
(
)
{
await
waitForObserverMessage
(
"
bounce
-
tracking
-
protection
-
storage
-
flushed
"
)
;
}
async
function
waitForDBSkipFlush
(
)
{
let
{
data
}
=
await
waitForObserverMessage
(
"
bounce
-
tracking
-
protection
-
storage
-
flush
-
skipped
"
)
;
return
Number
.
parseInt
(
data
10
)
;
}
add_setup
(
async
function
(
)
{
do_get_profile
(
)
;
let
profileDir
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
let
dbFile
=
profileDir
.
clone
(
)
;
dbFile
.
append
(
"
bounce
-
tracking
-
protection
.
sqlite
"
)
;
databasePath
=
dbFile
.
path
;
Services
.
prefs
.
setIntPref
(
"
privacy
.
bounceTrackingProtection
.
mode
"
Ci
.
nsIBounceTrackingProtection
.
MODE_ENABLED
)
;
Services
.
prefs
.
setBoolPref
(
"
privacy
.
bounceTrackingProtection
.
enableTestMode
"
true
)
;
}
)
;
add_task
(
async
function
test_batch_write_basic
(
)
{
let
btp
=
Cc
[
"
mozilla
.
org
/
bounce
-
tracking
-
protection
;
1
"
]
.
getService
(
Ci
.
nsIBounceTrackingProtection
)
;
btp
.
clearAll
(
)
;
let
count
=
await
countDatabaseEntries
(
)
;
Assert
.
equal
(
count
0
"
Database
should
be
empty
after
clearAll
"
)
;
let
halfBatch
=
Math
.
floor
(
(
MAX_PENDING_UPDATES
-
1
)
/
2
)
;
for
(
let
i
=
0
;
i
<
halfBatch
;
i
+
+
)
{
let
skipFlushPromise
=
waitForDBSkipFlush
(
)
;
btp
.
testAddUserActivation
(
{
}
example
-
foo
{
i
}
.
com
Date
.
now
(
)
*
1000
)
;
await
skipFlushPromise
;
skipFlushPromise
=
waitForDBSkipFlush
(
)
;
btp
.
testAddBounceTrackerCandidate
(
{
}
example
-
bar
{
i
}
.
com
Date
.
now
(
)
*
1000
)
;
let
pendingUpdatesCount
=
await
skipFlushPromise
;
let
expectedPendingUpdatesCount
=
(
i
+
1
)
*
2
;
Assert
.
equal
(
pendingUpdatesCount
expectedPendingUpdatesCount
Should
have
{
expectedPendingUpdatesCount
}
pending
updates
.
)
;
}
info
(
Added
{
halfBatch
*
2
}
entries
(
{
halfBatch
}
user
activations
and
{
halfBatch
}
bounce
trackers
)
)
;
count
=
await
countDatabaseEntries
(
)
;
Assert
.
equal
(
count
0
"
Database
should
still
be
empty
before
reaching
maxPendingUpdates
"
)
;
let
dbWritePromise
=
waitForDBFlush
(
)
;
info
(
"
Adding
final
entry
to
trigger
flush
"
)
;
btp
.
testAddUserActivation
(
{
}
"
example
-
foo
-
final
.
com
"
Date
.
now
(
)
*
1000
)
;
await
dbWritePromise
;
info
(
"
Database
write
completed
"
)
;
count
=
await
countDatabaseEntries
(
)
;
Assert
.
equal
(
count
MAX_PENDING_UPDATES
"
Database
should
have
all
entries
after
flush
"
)
;
info
(
Verified
database
has
all
{
MAX_PENDING_UPDATES
}
entries
after
flush
)
;
btp
.
clearAll
(
)
;
}
)
;
add_task
(
async
function
test_batch_write_multiple_flushes
(
)
{
let
btp
=
Cc
[
"
mozilla
.
org
/
bounce
-
tracking
-
protection
;
1
"
]
.
getService
(
Ci
.
nsIBounceTrackingProtection
)
;
btp
.
clearAll
(
)
;
info
(
Testing
multiple
flushes
with
maxPendingUpdates
=
{
MAX_PENDING_UPDATES
}
)
;
for
(
let
batch
=
0
;
batch
<
3
;
batch
+
+
)
{
info
(
Starting
batch
{
batch
+
1
}
of
3
)
;
let
halfBatch
=
Math
.
floor
(
(
MAX_PENDING_UPDATES
-
1
)
/
2
)
;
for
(
let
i
=
0
;
i
<
halfBatch
;
i
+
+
)
{
let
skipFlushPromise
=
waitForDBSkipFlush
(
)
;
btp
.
testAddUserActivation
(
{
}
example
-
foo
{
batch
}
_
{
i
}
.
com
Date
.
now
(
)
*
1000
)
;
await
skipFlushPromise
;
skipFlushPromise
=
waitForDBSkipFlush
(
)
;
btp
.
testAddBounceTrackerCandidate
(
{
}
example
-
bar
{
batch
}
_
{
i
}
.
com
Date
.
now
(
)
*
1000
)
;
await
skipFlushPromise
;
}
info
(
Added
{
halfBatch
*
2
}
entries
for
batch
{
batch
+
1
}
)
;
let
count
=
await
countDatabaseEntries
(
)
;
Assert
.
equal
(
count
batch
*
MAX_PENDING_UPDATES
Database
should
have
{
batch
*
MAX_PENDING_UPDATES
}
entries
before
next
flush
)
;
let
dbWritePromise
=
waitForDBFlush
(
)
;
info
(
Adding
final
entry
for
batch
{
batch
+
1
}
to
trigger
flush
)
;
btp
.
testAddUserActivation
(
{
}
example
{
batch
}
_final
.
com
Date
.
now
(
)
*
1000
)
;
await
dbWritePromise
;
info
(
Batch
{
batch
+
1
}
write
completed
)
;
count
=
await
countDatabaseEntries
(
)
;
Assert
.
equal
(
count
(
batch
+
1
)
*
MAX_PENDING_UPDATES
Database
should
have
{
(
batch
+
1
)
*
MAX_PENDING_UPDATES
}
entries
after
flush
)
;
}
btp
.
clearAll
(
)
;
}
)
;
add_task
(
async
function
test_batch_write_clear_behavior
(
)
{
let
btp
=
Cc
[
"
mozilla
.
org
/
bounce
-
tracking
-
protection
;
1
"
]
.
getService
(
Ci
.
nsIBounceTrackingProtection
)
;
btp
.
clearAll
(
)
;
info
(
Testing
clear
behavior
with
maxPendingUpdates
=
{
MAX_PENDING_UPDATES
}
)
;
let
halfBatch
=
Math
.
floor
(
(
MAX_PENDING_UPDATES
-
1
)
/
2
)
;
for
(
let
i
=
0
;
i
<
halfBatch
;
i
+
+
)
{
btp
.
testAddUserActivation
(
{
}
example
-
foo
{
i
}
.
com
Date
.
now
(
)
*
1000
)
;
btp
.
testAddBounceTrackerCandidate
(
{
}
example
-
bar
{
i
}
.
com
Date
.
now
(
)
*
1000
)
;
}
info
(
Added
{
halfBatch
*
2
}
entries
(
{
halfBatch
}
user
activations
and
{
halfBatch
}
bounce
trackers
)
)
;
info
(
"
Clearing
all
state
"
)
;
btp
.
clearAll
(
)
;
info
(
"
Adding
entry
after
clearAll
to
check
if
pending
updates
were
cleared
"
)
;
let
flushSkipPromise
=
waitForDBSkipFlush
(
)
;
btp
.
testAddUserActivation
(
{
}
"
example
-
after
-
clear
.
com
"
Date
.
now
(
)
*
1000
)
;
let
pendingUpdatesCount
=
await
flushSkipPromise
;
Assert
.
equal
(
pendingUpdatesCount
1
"
Should
only
have
1
pending
update
.
"
)
;
let
count
=
await
countDatabaseEntries
(
)
;
Assert
.
equal
(
count
0
"
Database
should
still
be
empty
after
clearAll
with
pending
updates
"
)
;
btp
.
clearAll
(
)
;
}
)
;
