#
include
"
URLQueryStringStripper
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsEffectiveTLDService
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
dom
/
StripOnShareRuleBinding
.
h
"
namespace
{
mozilla
:
:
StaticRefPtr
<
mozilla
:
:
URLQueryStringStripper
>
gQueryStringStripper
;
static
const
char
kQueryStrippingEnabledPref
[
]
=
"
privacy
.
query_stripping
.
enabled
"
;
static
const
char
kQueryStrippingEnabledPBMPref
[
]
=
"
privacy
.
query_stripping
.
enabled
.
pbmode
"
;
static
const
char
kQueryStrippingOnShareEnabledPref
[
]
=
"
privacy
.
query_stripping
.
strip_on_share
.
enabled
"
;
}
namespace
mozilla
{
NS_IMPL_ISUPPORTS
(
URLQueryStringStripper
nsIObserver
nsIURLQueryStringStripper
nsIURLQueryStrippingListObserver
)
already_AddRefed
<
URLQueryStringStripper
>
URLQueryStringStripper
:
:
GetSingleton
(
)
{
if
(
!
gQueryStringStripper
)
{
gQueryStringStripper
=
new
URLQueryStringStripper
(
)
;
URLQueryStringStripper
:
:
OnPrefChange
(
nullptr
nullptr
)
;
RunOnShutdown
(
[
&
]
{
DebugOnly
<
nsresult
>
rv
=
gQueryStringStripper
-
>
Shutdown
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
URLQueryStringStripper
:
:
Shutdown
failed
"
)
;
gQueryStringStripper
=
nullptr
;
}
ShutdownPhase
:
:
XPCOMShutdown
)
;
}
return
do_AddRef
(
gQueryStringStripper
)
;
}
URLQueryStringStripper
:
:
URLQueryStringStripper
(
)
{
mIsInitialized
=
false
;
nsresult
rv
=
Preferences
:
:
RegisterCallback
(
&
URLQueryStringStripper
:
:
OnPrefChange
kQueryStrippingEnabledPBMPref
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
rv
=
Preferences
:
:
RegisterCallback
(
&
URLQueryStringStripper
:
:
OnPrefChange
kQueryStrippingEnabledPref
)
;
rv
=
Preferences
:
:
RegisterCallback
(
&
URLQueryStringStripper
:
:
OnPrefChange
kQueryStrippingOnShareEnabledPref
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
NS_IMETHODIMP
URLQueryStringStripper
:
:
StripForCopyOrShare
(
nsIURI
*
aURI
nsIURI
*
*
strippedURI
)
{
if
(
!
StaticPrefs
:
:
privacy_query_stripping_strip_on_share_enabled
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_ENSURE_ARG_POINTER
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
strippedURI
)
;
int
aStripCount
=
0
;
nsresult
rv
=
StripForCopyOrShareInternal
(
aURI
strippedURI
aStripCount
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
STRIP_ON_SHARE_PARAMS_REMOVED
aStripCount
)
;
if
(
!
aStripCount
)
{
return
NS_OK
;
}
nsAutoCString
specOriginalURI
;
nsAutoCString
specStrippedURI
;
rv
=
aURI
-
>
GetDisplaySpec
(
specOriginalURI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
*
strippedURI
)
;
rv
=
(
*
strippedURI
)
-
>
GetDisplaySpec
(
specStrippedURI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
lengthDiff
=
specOriginalURI
.
Length
(
)
-
specStrippedURI
.
Length
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
STRIP_ON_SHARE_LENGTH_DECREASE
lengthDiff
)
;
return
NS_OK
;
}
NS_IMETHODIMP
URLQueryStringStripper
:
:
CanStripForShare
(
nsIURI
*
aURI
bool
*
aCanStrip
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
aCanStrip
)
;
*
aCanStrip
=
false
;
return
CanStripForCopyOrShareInternal
(
aURI
aCanStrip
true
)
;
}
NS_IMETHODIMP
URLQueryStringStripper
:
:
Strip
(
nsIURI
*
aURI
bool
aIsPBM
nsIURI
*
*
aOutput
uint32_t
*
aStripCount
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
aOutput
)
;
NS_ENSURE_ARG_POINTER
(
aStripCount
)
;
*
aStripCount
=
0
;
if
(
aIsPBM
)
{
if
(
!
StaticPrefs
:
:
privacy_query_stripping_enabled_pbmode
(
)
)
{
return
NS_OK
;
}
}
else
{
if
(
!
StaticPrefs
:
:
privacy_query_stripping_enabled
(
)
)
{
return
NS_OK
;
}
}
if
(
CheckAllowList
(
aURI
)
)
{
return
NS_OK
;
}
return
StripQueryString
(
aURI
aOutput
aStripCount
)
;
}
void
URLQueryStringStripper
:
:
OnPrefChange
(
const
char
*
aPref
void
*
aData
)
{
MOZ_ASSERT
(
gQueryStringStripper
)
;
bool
prefEnablesComponent
=
StaticPrefs
:
:
privacy_query_stripping_enabled
(
)
|
|
StaticPrefs
:
:
privacy_query_stripping_enabled_pbmode
(
)
|
|
StaticPrefs
:
:
privacy_query_stripping_strip_on_share_enabled
(
)
;
nsresult
rv
;
if
(
prefEnablesComponent
)
{
rv
=
gQueryStringStripper
-
>
Init
(
)
;
}
else
{
rv
=
gQueryStringStripper
-
>
Shutdown
(
)
;
}
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
nsresult
URLQueryStringStripper
:
:
Init
(
)
{
nsresult
rv
;
if
(
mIsInitialized
)
{
rv
=
gQueryStringStripper
-
>
ManageObservers
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
mIsInitialized
=
true
;
mListService
=
do_GetService
(
"
mozilla
.
org
/
query
-
stripping
-
list
-
service
;
1
"
)
;
NS_ENSURE_TRUE
(
mListService
NS_ERROR_FAILURE
)
;
rv
=
gQueryStringStripper
-
>
ManageObservers
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
URLQueryStringStripper
:
:
ManageObservers
(
)
{
MOZ_ASSERT
(
mListService
)
;
nsresult
rv
;
if
(
!
mObservingQPS
)
{
if
(
StaticPrefs
:
:
privacy_query_stripping_enabled
(
)
|
|
StaticPrefs
:
:
privacy_query_stripping_enabled_pbmode
(
)
)
{
rv
=
mListService
-
>
RegisterAndRunObserver
(
gQueryStringStripper
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mObservingQPS
=
true
;
}
}
else
{
if
(
!
StaticPrefs
:
:
privacy_query_stripping_enabled
(
)
&
&
!
StaticPrefs
:
:
privacy_query_stripping_enabled_pbmode
(
)
)
{
mList
.
Clear
(
)
;
mAllowList
.
Clear
(
)
;
rv
=
mListService
-
>
UnregisterObserver
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mObservingQPS
=
false
;
}
}
if
(
!
mObservingStripOnShare
)
{
if
(
StaticPrefs
:
:
privacy_query_stripping_strip_on_share_enabled
(
)
)
{
rv
=
mListService
-
>
RegisterAndRunObserverStripOnShare
(
gQueryStringStripper
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mObservingStripOnShare
=
true
;
}
}
else
{
if
(
!
StaticPrefs
:
:
privacy_query_stripping_strip_on_share_enabled
(
)
)
{
mStripOnShareMap
.
Clear
(
)
;
rv
=
mListService
-
>
UnregisterStripOnShareObserver
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mObservingStripOnShare
=
false
;
}
}
return
NS_OK
;
}
nsresult
URLQueryStringStripper
:
:
Shutdown
(
)
{
if
(
!
mIsInitialized
)
{
return
NS_OK
;
}
nsresult
rv
=
gQueryStringStripper
-
>
ManageObservers
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIsInitialized
=
false
;
mListService
=
nullptr
;
return
NS_OK
;
}
nsresult
URLQueryStringStripper
:
:
StripQueryString
(
nsIURI
*
aURI
nsIURI
*
*
aOutput
uint32_t
*
aStripCount
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
aOutput
)
;
NS_ENSURE_ARG_POINTER
(
aStripCount
)
;
*
aStripCount
=
0
;
nsCOMPtr
<
nsIURI
>
uri
(
aURI
)
;
nsAutoCString
query
;
nsresult
rv
=
aURI
-
>
GetQuery
(
query
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
query
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
URLParams
params
;
URLParams
:
:
Parse
(
query
false
[
&
]
(
nsCString
&
&
name
nsCString
&
&
value
)
{
nsAutoCString
lowerCaseName
;
ToLowerCase
(
name
lowerCaseName
)
;
if
(
mList
.
Contains
(
lowerCaseName
)
)
{
*
aStripCount
+
=
1
;
nsAutoCString
telemetryLabel
(
"
param_
"
)
;
telemetryLabel
.
Append
(
lowerCaseName
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
QUERY_STRIPPING_COUNT_BY_PARAM
telemetryLabel
)
;
return
true
;
}
params
.
Append
(
name
value
)
;
return
true
;
}
)
;
if
(
!
*
aStripCount
)
{
return
NS_OK
;
}
nsAutoCString
newQuery
;
params
.
Serialize
(
newQuery
false
)
;
Unused
<
<
NS_MutateURI
(
uri
)
.
SetQuery
(
newQuery
)
.
Finalize
(
aOutput
)
;
return
NS_OK
;
}
bool
URLQueryStringStripper
:
:
CheckAllowList
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
)
;
nsAutoCString
baseDomain
;
nsresult
rv
=
nsEffectiveTLDService
:
:
GetInstance
(
)
-
>
GetBaseDomain
(
aURI
0
baseDomain
)
;
if
(
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
return
false
;
}
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
mAllowList
.
Contains
(
baseDomain
)
;
}
void
URLQueryStringStripper
:
:
PopulateStripList
(
const
nsACString
&
aList
)
{
mList
.
Clear
(
)
;
for
(
const
nsACString
&
item
:
aList
.
Split
(
'
'
)
)
{
mList
.
Insert
(
item
)
;
}
}
void
URLQueryStringStripper
:
:
PopulateAllowList
(
const
nsACString
&
aList
)
{
mAllowList
.
Clear
(
)
;
for
(
const
nsACString
&
item
:
aList
.
Split
(
'
'
)
)
{
mAllowList
.
Insert
(
item
)
;
}
}
NS_IMETHODIMP
URLQueryStringStripper
:
:
OnQueryStrippingListUpdate
(
const
nsACString
&
aStripList
const
nsACString
&
aAllowList
)
{
PopulateStripList
(
aStripList
)
;
PopulateAllowList
(
aAllowList
)
;
return
NS_OK
;
}
NS_IMETHODIMP
URLQueryStringStripper
:
:
OnStripOnShareUpdate
(
const
nsTArray
<
nsString
>
&
aArgs
JSContext
*
aCx
)
{
for
(
const
auto
&
ruleString
:
aArgs
)
{
dom
:
:
StripRule
rule
;
if
(
NS_WARN_IF
(
!
rule
.
Init
(
ruleString
)
)
)
{
continue
;
}
for
(
const
auto
&
topLevelSite
:
rule
.
mTopLevelSites
)
{
mStripOnShareMap
.
InsertOrUpdate
(
topLevelSite
rule
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
URLQueryStringStripper
:
:
TestGetStripList
(
nsACString
&
aStripList
)
{
aStripList
.
Truncate
(
)
;
StringJoinAppend
(
aStripList
"
"
_ns
mList
[
]
(
auto
&
aResult
const
auto
&
aValue
)
{
aResult
.
Append
(
aValue
)
;
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
URLQueryStringStripper
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
MOZ_ASSERT
(
strcmp
(
aTopic
"
profile
-
after
-
change
"
)
=
=
0
)
;
return
NS_OK
;
}
nsresult
URLQueryStringStripper
:
:
StripForCopyOrShareInternal
(
nsIURI
*
aURI
nsIURI
*
*
strippedURI
int
&
aStripCount
bool
aStripNestedURIs
)
{
nsAutoCString
query
;
nsresult
rv
=
aURI
-
>
GetQuery
(
query
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
query
.
IsEmpty
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
STRIP_ON_SHARE_PARAMS_REMOVED
0
)
;
return
NS_OK
;
}
nsAutoCString
host
;
rv
=
aURI
-
>
GetHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
URLParams
params
;
URLParams
:
:
Parse
(
query
false
[
&
]
(
nsCString
&
&
name
nsCString
&
&
value
)
{
nsAutoCString
lowerCaseName
;
ToLowerCase
(
name
lowerCaseName
)
;
dom
:
:
StripRule
globalRule
;
bool
keyExists
=
mStripOnShareMap
.
Get
(
"
*
"
_ns
&
globalRule
)
;
MOZ_ASSERT
(
keyExists
)
;
for
(
const
auto
&
param
:
globalRule
.
mQueryParams
)
{
if
(
param
=
=
lowerCaseName
)
{
aStripCount
+
+
;
return
true
;
}
}
dom
:
:
StripRule
siteSpecificRule
;
keyExists
=
mStripOnShareMap
.
Get
(
host
&
siteSpecificRule
)
;
if
(
keyExists
)
{
for
(
const
auto
&
param
:
siteSpecificRule
.
mQueryParams
)
{
if
(
param
=
=
lowerCaseName
)
{
aStripCount
+
+
;
return
true
;
}
}
}
if
(
!
aStripNestedURIs
)
{
nsAutoCString
decodeValue
;
URLParams
:
:
DecodeString
(
value
decodeValue
)
;
nsCOMPtr
<
nsIURI
>
nestedURI
;
rv
=
NS_NewURI
(
getter_AddRefs
(
nestedURI
)
decodeValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
params
.
Append
(
name
value
)
;
return
true
;
}
nsCOMPtr
<
nsIURI
>
strippedNestedURI
;
rv
=
StripForCopyOrShareInternal
(
nestedURI
getter_AddRefs
(
strippedNestedURI
)
aStripCount
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
params
.
Append
(
name
value
)
;
return
true
;
}
if
(
!
strippedNestedURI
)
{
params
.
Append
(
name
value
)
;
return
true
;
}
nsAutoCString
nestedURIString
;
rv
=
strippedNestedURI
-
>
GetSpec
(
nestedURIString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
params
.
Append
(
name
value
)
;
return
true
;
}
nsAutoCString
encodedURI
;
URLParams
:
:
SerializeString
(
nestedURIString
encodedURI
)
;
params
.
Append
(
name
encodedURI
)
;
return
true
;
}
params
.
Append
(
name
value
)
;
return
true
;
}
)
;
if
(
!
aStripCount
)
{
return
NS_OK
;
}
nsAutoCString
newQuery
;
params
.
Serialize
(
newQuery
false
)
;
return
NS_MutateURI
(
aURI
)
.
SetQuery
(
newQuery
)
.
Finalize
(
strippedURI
)
;
}
nsresult
URLQueryStringStripper
:
:
CanStripForCopyOrShareInternal
(
nsIURI
*
aURI
bool
*
aCanStrip
bool
aStripNestedURIs
)
{
*
aCanStrip
=
false
;
nsAutoCString
query
;
nsresult
rv
=
aURI
-
>
GetQuery
(
query
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
query
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsAutoCString
host
;
rv
=
aURI
-
>
GetHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
URLParams
params
;
URLParams
:
:
Parse
(
query
false
[
&
]
(
nsCString
&
&
name
nsCString
&
&
value
)
{
nsAutoCString
lowerCaseName
;
ToLowerCase
(
name
lowerCaseName
)
;
dom
:
:
StripRule
globalRule
;
bool
keyExists
=
mStripOnShareMap
.
Get
(
"
*
"
_ns
&
globalRule
)
;
MOZ_ASSERT
(
keyExists
)
;
for
(
const
auto
&
param
:
globalRule
.
mQueryParams
)
{
if
(
param
=
=
lowerCaseName
)
{
*
aCanStrip
=
true
;
return
false
;
}
}
dom
:
:
StripRule
siteSpecificRule
;
keyExists
=
mStripOnShareMap
.
Get
(
host
&
siteSpecificRule
)
;
if
(
keyExists
)
{
for
(
const
auto
&
param
:
siteSpecificRule
.
mQueryParams
)
{
if
(
param
=
=
lowerCaseName
)
{
*
aCanStrip
=
true
;
return
false
;
}
}
}
if
(
aStripNestedURIs
)
{
nsresult
nestedRv
;
nsAutoCString
decodeValue
;
URLParams
:
:
DecodeString
(
value
decodeValue
)
;
nsCOMPtr
<
nsIURI
>
nestedURI
;
nestedRv
=
NS_NewURI
(
getter_AddRefs
(
nestedURI
)
decodeValue
)
;
if
(
NS_FAILED
(
nestedRv
)
)
{
return
true
;
}
nestedRv
=
CanStripForCopyOrShareInternal
(
nestedURI
aCanStrip
false
)
;
if
(
NS_FAILED
(
nestedRv
)
)
{
return
true
;
}
if
(
*
aCanStrip
)
{
return
false
;
}
}
return
true
;
}
)
;
return
rv
;
}
}
