"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PurgeTrackerService
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
THREE_DAYS_MS
=
3
*
24
*
60
*
1000
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gClassifier
"
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
"
nsIURIClassifier
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gStorageActivityService
"
"
mozilla
.
org
/
storage
/
activity
-
service
;
1
"
"
nsIStorageActivityService
"
)
;
this
.
PurgeTrackerService
=
function
(
)
{
}
;
PurgeTrackerService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
90d1fd17
-
2018
-
4e16
-
b73c
-
a04a26fa6dd4
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIPurgeTrackerService
]
)
_firstIteration
:
true
_trackingState
:
new
Map
(
)
collator
:
new
Intl
.
Collator
(
undefined
{
numeric
:
true
sensitivity
:
"
base
"
}
)
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
idle
-
daily
"
:
Services
.
obs
.
removeObserver
(
this
"
idle
-
daily
"
)
;
this
.
purgeTrackingCookieJars
(
)
;
break
;
case
"
profile
-
after
-
change
"
:
Services
.
obs
.
addObserver
(
this
"
idle
-
daily
"
)
;
break
;
}
}
async
isTracker
(
principal
feature
)
{
if
(
principal
.
isNullPrincipal
|
|
principal
.
isSystemPrincipal
)
{
return
false
;
}
let
host
;
try
{
host
=
principal
.
asciiHost
;
}
catch
(
error
)
{
return
false
;
}
if
(
!
this
.
_trackingState
.
has
(
host
)
)
{
this
.
_trackingState
.
set
(
host
false
)
;
await
new
Promise
(
resolve
=
>
{
try
{
gClassifier
.
asyncClassifyLocalWithFeatures
(
principal
.
URI
[
feature
]
Ci
.
nsIUrlClassifierFeature
.
blacklist
list
=
>
{
if
(
list
.
length
)
{
this
.
_trackingState
.
set
(
host
true
)
;
}
resolve
(
)
;
}
)
;
}
catch
{
this
.
_trackingState
.
set
(
host
false
)
;
resolve
(
)
;
}
}
)
;
}
return
this
.
_trackingState
.
get
(
host
)
;
}
resetPurgeList
(
)
{
Services
.
obs
.
addObserver
(
this
"
idle
-
daily
"
)
;
Services
.
prefs
.
setStringPref
(
"
privacy
.
purge_trackers
.
date_in_cookie_database
"
"
0
"
)
;
}
submitTelemetry
(
)
{
let
{
numPurged
notPurged
durationIntervals
}
=
this
.
_telemetryData
;
let
now
=
Date
.
now
(
)
;
let
lastPurge
=
Number
(
Services
.
prefs
.
getStringPref
(
"
privacy
.
purge_trackers
.
last_purge
"
now
)
)
;
let
intervalHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_INTERVAL_HOURS
"
)
;
let
hoursBetween
=
Math
.
floor
(
(
now
-
lastPurge
)
/
1000
/
60
/
60
)
;
intervalHistogram
.
add
(
hoursBetween
)
;
Services
.
prefs
.
setIntPref
(
"
privacy
.
purge_trackers
.
last_purge
"
now
.
toString
(
)
)
;
let
purgedHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_ORIGINS_PURGED
"
)
;
purgedHistogram
.
add
(
numPurged
)
;
let
notPurgedHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_TRACKERS_WITH_USER_INTERACTION
"
)
;
notPurgedHistogram
.
add
(
notPurged
)
;
let
duration
=
durationIntervals
.
map
(
(
[
start
end
]
)
=
>
end
-
start
)
.
reduce
(
(
acc
cur
)
=
>
acc
+
cur
0
)
;
let
durationHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_DURATION_MS
"
)
;
durationHistogram
.
add
(
duration
)
;
}
async
purgeTrackingCookieJars
(
)
{
let
purgeEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
purge_trackers
.
enabled
"
false
)
;
let
cookieBehavior
=
Services
.
cookies
.
cookieBehavior
;
let
etpActive
=
cookieBehavior
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
|
|
cookieBehavior
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
;
if
(
!
etpActive
|
|
!
purgeEnabled
)
{
LOG
(
returning
early
etpActive
:
{
etpActive
}
purgeEnabled
:
{
purgeEnabled
}
)
;
this
.
resetPurgeList
(
)
;
return
;
}
LOG
(
"
Purging
trackers
enabled
beginning
batch
.
"
)
;
const
MAX_PURGE_COUNT
=
Services
.
prefs
.
getIntPref
(
"
privacy
.
purge_trackers
.
max_purge_count
"
100
)
;
if
(
this
.
_firstIteration
)
{
this
.
_telemetryData
=
{
durationIntervals
:
[
]
numPurged
:
0
notPurged
:
0
}
;
}
let
duration
=
[
Cu
.
now
(
)
]
;
let
saved_date
=
Services
.
prefs
.
getStringPref
(
"
privacy
.
purge_trackers
.
date_in_cookie_database
"
"
0
"
)
;
let
maybeClearPrincipals
=
new
Map
(
)
;
let
cookies
=
Services
.
cookies
.
cookies
;
cookies
=
cookies
.
filter
(
cookie
=
>
{
return
(
cookie
.
creationTime
&
&
this
.
collator
.
compare
(
cookie
.
creationTime
saved_date
)
>
0
)
;
}
)
;
cookies
.
sort
(
(
a
b
)
=
>
this
.
collator
.
compare
(
a
.
creationTime
b
.
creationTime
)
)
;
cookies
=
cookies
.
slice
(
0
MAX_PURGE_COUNT
)
;
for
(
let
cookie
of
cookies
)
{
let
httpPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
"
http
:
/
/
"
+
cookie
.
rawHost
+
ChromeUtils
.
originAttributesToSuffix
(
cookie
.
originAttributes
)
)
;
let
httpsPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
"
https
:
/
/
"
+
cookie
.
rawHost
+
ChromeUtils
.
originAttributesToSuffix
(
cookie
.
originAttributes
)
)
;
maybeClearPrincipals
.
set
(
httpPrincipal
.
origin
httpPrincipal
)
;
maybeClearPrincipals
.
set
(
httpsPrincipal
.
origin
httpsPrincipal
)
;
saved_date
=
cookie
.
creationTime
;
}
if
(
this
.
_firstIteration
)
{
let
startDate
=
Date
.
now
(
)
-
THREE_DAYS_MS
;
let
storagePrincipals
=
gStorageActivityService
.
getActiveOrigins
(
startDate
*
1000
Date
.
now
(
)
*
1000
)
;
for
(
let
principal
of
storagePrincipals
.
enumerate
(
)
)
{
maybeClearPrincipals
.
set
(
principal
.
origin
principal
)
;
}
}
let
feature
=
gClassifier
.
getFeatureByName
(
"
tracking
-
annotation
"
)
;
if
(
!
feature
)
{
LOG
(
"
returning
early
feature
undefined
.
"
)
;
this
.
resetPurgeList
(
)
;
return
;
}
let
baseDomainsWithInteraction
=
new
Map
(
)
;
for
(
let
perm
of
Services
.
perms
.
getAllWithTypePrefix
(
"
storageAccessAPI
"
)
)
{
baseDomainsWithInteraction
.
set
(
perm
.
principal
.
baseDomain
perm
.
expireTime
)
;
}
let
permissionAgeHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_TRACKERS_USER_INTERACTION_REMAINING_DAYS
"
)
;
for
(
let
principal
of
maybeClearPrincipals
.
values
(
)
)
{
if
(
!
baseDomainsWithInteraction
.
has
(
principal
.
baseDomain
)
)
{
let
isTracker
=
await
this
.
isTracker
(
principal
feature
)
;
if
(
isTracker
)
{
LOG
(
"
tracking
cookie
found
with
no
interaction
permission
deleting
related
data
.
"
principal
.
origin
)
;
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteDataFromPrincipal
(
principal
false
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
|
Ci
.
nsIClearDataService
.
CLEAR_COOKIES
|
Ci
.
nsIClearDataService
.
CLEAR_DOM_STORAGES
|
Ci
.
nsIClearDataService
.
CLEAR_SECURITY_SETTINGS
|
Ci
.
nsIClearDataService
.
CLEAR_EME
|
Ci
.
nsIClearDataService
.
CLEAR_PLUGIN_DATA
|
Ci
.
nsIClearDataService
.
CLEAR_MEDIA_DEVICES
|
Ci
.
nsIClearDataService
.
CLEAR_STORAGE_ACCESS
|
Ci
.
nsIClearDataService
.
CLEAR_AUTH_TOKENS
|
Ci
.
nsIClearDataService
.
CLEAR_AUTH_CACHE
resolve
)
;
}
)
;
this
.
_telemetryData
.
numPurged
+
+
;
LOG
(
Data
deleted
from
:
principal
.
origin
)
;
}
}
else
if
(
Services
.
telemetry
.
canRecordPrereleaseData
)
{
let
isTracker
=
await
this
.
isTracker
(
principal
feature
)
;
if
(
isTracker
)
{
let
expireTimeMs
=
baseDomainsWithInteraction
.
get
(
principal
.
baseDomain
)
;
let
timeRemaining
=
Math
.
floor
(
(
expireTimeMs
-
Date
.
now
(
)
)
/
1000
/
60
/
60
/
24
)
;
permissionAgeHistogram
.
add
(
timeRemaining
)
;
this
.
_telemetryData
.
notPurged
+
+
;
}
}
}
Services
.
prefs
.
setStringPref
(
"
privacy
.
purge_trackers
.
date_in_cookie_database
"
saved_date
)
;
duration
.
push
(
Cu
.
now
(
)
)
;
this
.
_telemetryData
.
durationIntervals
.
push
(
duration
)
;
if
(
!
cookies
.
length
|
|
cookies
.
length
<
100
)
{
LOG
(
"
All
cookie
purging
finished
resetting
list
until
tomorrow
.
"
)
;
this
.
resetPurgeList
(
)
;
this
.
submitTelemetry
(
)
;
this
.
_firstIteration
=
true
;
return
;
}
LOG
(
"
Batch
finished
queueing
next
batch
.
"
)
;
this
.
_firstIteration
=
false
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
this
.
purgeTrackingCookieJars
(
)
;
}
)
;
}
}
;
var
logConsole
;
function
LOG
(
.
.
.
args
)
{
if
(
!
logConsole
)
{
logConsole
=
console
.
createInstance
(
{
prefix
:
"
*
*
*
PurgeTrackerService
:
"
maxLogLevelPref
:
"
privacy
.
purge_trackers
.
logging
.
level
"
}
)
;
}
logConsole
.
log
(
.
.
.
args
)
;
}
