"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PurgeTrackerService
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
THREE_DAYS_MS
=
3
*
24
*
60
*
1000
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gClassifier
"
"
mozilla
.
org
/
url
-
classifier
/
dbservice
;
1
"
"
nsIURIClassifier
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gStorageActivityService
"
"
mozilla
.
org
/
storage
/
activity
-
service
;
1
"
"
nsIStorageActivityService
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gClassifierFeature
"
(
)
=
>
{
return
gClassifier
.
getFeatureByName
(
"
tracking
-
annotation
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
*
*
*
PurgeTrackerService
:
"
maxLogLevelPref
:
"
privacy
.
purge_trackers
.
logging
.
level
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gConsiderEntityList
"
"
privacy
.
purge_trackers
.
consider_entity_list
"
)
;
this
.
PurgeTrackerService
=
function
(
)
{
}
;
PurgeTrackerService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
90d1fd17
-
2018
-
4e16
-
b73c
-
a04a26fa6dd4
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIPurgeTrackerService
"
]
)
_firstIteration
:
true
_trackingState
:
new
Map
(
)
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
idle
-
daily
"
:
Services
.
obs
.
removeObserver
(
this
"
idle
-
daily
"
)
;
this
.
purgeTrackingCookieJars
(
)
;
break
;
case
"
profile
-
after
-
change
"
:
Services
.
obs
.
addObserver
(
this
"
idle
-
daily
"
)
;
break
;
}
}
async
isTracker
(
principal
)
{
if
(
principal
.
isNullPrincipal
|
|
principal
.
isSystemPrincipal
)
{
return
false
;
}
let
host
;
try
{
host
=
principal
.
asciiHost
;
}
catch
(
error
)
{
return
false
;
}
if
(
!
this
.
_trackingState
.
has
(
host
)
)
{
this
.
_trackingState
.
set
(
host
false
)
;
await
new
Promise
(
resolve
=
>
{
try
{
gClassifier
.
asyncClassifyLocalWithFeatures
(
principal
.
URI
[
gClassifierFeature
]
Ci
.
nsIUrlClassifierFeature
.
blocklist
list
=
>
{
if
(
list
.
length
)
{
this
.
_trackingState
.
set
(
host
true
)
;
}
resolve
(
)
;
}
)
;
}
catch
{
this
.
_trackingState
.
set
(
host
false
)
;
resolve
(
)
;
}
}
)
;
}
return
this
.
_trackingState
.
get
(
host
)
;
}
isAllowedThirdParty
(
firstPartyOriginNoSuffix
thirdPartyHost
)
{
let
uri
=
Services
.
io
.
newURI
(
{
firstPartyOriginNoSuffix
}
/
?
resource
=
{
thirdPartyHost
}
)
;
logger
.
debug
(
Checking
entity
list
state
for
uri
.
spec
)
;
return
new
Promise
(
resolve
=
>
{
try
{
gClassifier
.
asyncClassifyLocalWithFeatures
(
uri
[
gClassifierFeature
]
Ci
.
nsIUrlClassifierFeature
.
entitylist
list
=
>
{
let
sameList
=
!
!
list
.
length
;
logger
.
debug
(
Is
{
uri
.
spec
}
on
the
entity
list
?
sameList
)
;
resolve
(
sameList
)
;
}
)
;
}
catch
{
resolve
(
false
)
;
}
}
)
;
}
async
maybePurgePrincipal
(
principal
)
{
let
origin
=
principal
.
origin
;
logger
.
debug
(
Maybe
purging
{
origin
}
.
)
;
let
hasInteraction
=
this
.
_baseDomainsWithInteraction
.
has
(
principal
.
baseDomain
)
;
if
(
hasInteraction
&
&
!
Services
.
telemetry
.
canRecordPrereleaseData
)
{
logger
.
debug
(
{
origin
}
has
user
interaction
exiting
.
)
;
return
;
}
let
isTracker
=
await
this
.
isTracker
(
principal
)
;
if
(
!
isTracker
)
{
logger
.
debug
(
{
origin
}
is
not
a
tracker
exiting
.
)
;
return
;
}
if
(
hasInteraction
)
{
let
expireTimeMs
=
this
.
_baseDomainsWithInteraction
.
get
(
principal
.
baseDomain
)
;
let
timeRemaining
=
Math
.
floor
(
(
expireTimeMs
-
Date
.
now
(
)
)
/
1000
/
60
/
60
/
24
)
;
let
permissionAgeHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_TRACKERS_USER_INTERACTION_REMAINING_DAYS
"
)
;
permissionAgeHistogram
.
add
(
timeRemaining
)
;
this
.
_telemetryData
.
notPurged
.
add
(
principal
.
baseDomain
)
;
logger
.
debug
(
{
origin
}
is
a
tracker
with
interaction
exiting
.
)
;
return
;
}
let
isAllowedThirdParty
=
false
;
if
(
gConsiderEntityList
|
|
Services
.
telemetry
.
canRecordPrereleaseData
)
{
for
(
let
firstPartyPrincipal
of
this
.
_principalsWithInteraction
)
{
if
(
await
this
.
isAllowedThirdParty
(
firstPartyPrincipal
.
originNoSuffix
principal
.
asciiHost
)
)
{
isAllowedThirdParty
=
true
;
break
;
}
}
}
if
(
isAllowedThirdParty
&
&
gConsiderEntityList
)
{
logger
.
debug
(
{
origin
}
has
interaction
on
the
entity
list
exiting
.
)
;
return
;
}
logger
.
log
(
"
Deleting
data
from
:
"
origin
)
;
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteDataFromPrincipal
(
principal
false
Ci
.
nsIClearDataService
.
CLEAR_ALL_CACHES
|
Ci
.
nsIClearDataService
.
CLEAR_COOKIES
|
Ci
.
nsIClearDataService
.
CLEAR_DOM_STORAGES
|
Ci
.
nsIClearDataService
.
CLEAR_SECURITY_SETTINGS
|
Ci
.
nsIClearDataService
.
CLEAR_EME
|
Ci
.
nsIClearDataService
.
CLEAR_PLUGIN_DATA
|
Ci
.
nsIClearDataService
.
CLEAR_MEDIA_DEVICES
|
Ci
.
nsIClearDataService
.
CLEAR_STORAGE_ACCESS
|
Ci
.
nsIClearDataService
.
CLEAR_AUTH_TOKENS
|
Ci
.
nsIClearDataService
.
CLEAR_AUTH_CACHE
resolve
)
;
}
)
;
logger
.
log
(
Data
deleted
from
:
origin
)
;
this
.
_telemetryData
.
purged
.
add
(
principal
.
baseDomain
)
;
}
resetPurgeList
(
)
{
Services
.
obs
.
addObserver
(
this
"
idle
-
daily
"
)
;
Services
.
prefs
.
setStringPref
(
"
privacy
.
purge_trackers
.
date_in_cookie_database
"
"
0
"
)
;
}
submitTelemetry
(
)
{
let
{
purged
notPurged
durationIntervals
}
=
this
.
_telemetryData
;
let
now
=
Date
.
now
(
)
;
let
lastPurge
=
Number
(
Services
.
prefs
.
getStringPref
(
"
privacy
.
purge_trackers
.
last_purge
"
now
)
)
;
let
intervalHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_INTERVAL_HOURS
"
)
;
let
hoursBetween
=
Math
.
floor
(
(
now
-
lastPurge
)
/
1000
/
60
/
60
)
;
intervalHistogram
.
add
(
hoursBetween
)
;
Services
.
prefs
.
setStringPref
(
"
privacy
.
purge_trackers
.
last_purge
"
now
.
toString
(
)
)
;
let
purgedHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_ORIGINS_PURGED
"
)
;
purgedHistogram
.
add
(
purged
.
size
)
;
let
notPurgedHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_TRACKERS_WITH_USER_INTERACTION
"
)
;
notPurgedHistogram
.
add
(
notPurged
.
size
)
;
let
duration
=
durationIntervals
.
map
(
(
[
start
end
]
)
=
>
end
-
start
)
.
reduce
(
(
acc
cur
)
=
>
acc
+
cur
0
)
;
let
durationHistogram
=
Services
.
telemetry
.
getHistogramById
(
"
COOKIE_PURGING_DURATION_MS
"
)
;
durationHistogram
.
add
(
duration
)
;
}
async
purgeTrackingCookieJars
(
)
{
let
purgeEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
purge_trackers
.
enabled
"
false
)
;
let
sanitizeOnShutdownEnabled
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
sanitize
.
sanitizeOnShutdown
"
false
)
;
let
clearHistoryOnShutdown
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
history
"
false
)
;
let
clearSiteSettingsOnShutdown
=
Services
.
prefs
.
getBoolPref
(
"
privacy
.
clearOnShutdown
.
siteSettings
"
false
)
;
if
(
sanitizeOnShutdownEnabled
&
&
(
clearHistoryOnShutdown
|
|
clearSiteSettingsOnShutdown
)
)
{
logger
.
log
(
Purging
canceled
because
interaction
permissions
are
cleared
on
shutdown
.
sanitizeOnShutdownEnabled
:
{
sanitizeOnShutdownEnabled
}
clearHistoryOnShutdown
:
{
clearHistoryOnShutdown
}
clearSiteSettingsOnShutdown
:
{
clearSiteSettingsOnShutdown
}
)
;
this
.
resetPurgeList
(
)
;
return
;
}
let
cookieBehavior
=
Services
.
cookies
.
cookieBehavior
;
let
activeWithCookieBehavior
=
cookieBehavior
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_FOREIGN
|
|
cookieBehavior
=
=
Ci
.
nsICookieService
.
BEHAVIOR_LIMIT_FOREIGN
|
|
cookieBehavior
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
|
|
cookieBehavior
=
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
;
if
(
!
activeWithCookieBehavior
|
|
!
purgeEnabled
)
{
logger
.
log
(
returning
early
activeWithCookieBehavior
:
{
activeWithCookieBehavior
}
purgeEnabled
:
{
purgeEnabled
}
)
;
this
.
resetPurgeList
(
)
;
return
;
}
logger
.
log
(
"
Purging
trackers
enabled
beginning
batch
.
"
)
;
const
MAX_PURGE_COUNT
=
Services
.
prefs
.
getIntPref
(
"
privacy
.
purge_trackers
.
max_purge_count
"
100
)
;
if
(
this
.
_firstIteration
)
{
this
.
_telemetryData
=
{
durationIntervals
:
[
]
purged
:
new
Set
(
)
notPurged
:
new
Set
(
)
}
;
this
.
_baseDomainsWithInteraction
=
new
Map
(
)
;
this
.
_principalsWithInteraction
=
[
]
;
for
(
let
perm
of
Services
.
perms
.
getAllWithTypePrefix
(
"
storageAccessAPI
"
)
)
{
this
.
_baseDomainsWithInteraction
.
set
(
perm
.
principal
.
baseDomain
perm
.
expireTime
)
;
this
.
_principalsWithInteraction
.
push
(
perm
.
principal
)
;
}
}
let
duration
=
[
Cu
.
now
(
)
]
;
let
saved_date
=
Services
.
prefs
.
getStringPref
(
"
privacy
.
purge_trackers
.
date_in_cookie_database
"
"
0
"
)
;
let
maybeClearPrincipals
=
new
Map
(
)
;
let
cookies
=
Services
.
cookies
.
getCookiesSince
(
saved_date
)
;
cookies
=
cookies
.
slice
(
0
MAX_PURGE_COUNT
)
;
for
(
let
cookie
of
cookies
)
{
let
httpPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
"
http
:
/
/
"
+
cookie
.
rawHost
+
ChromeUtils
.
originAttributesToSuffix
(
cookie
.
originAttributes
)
)
;
let
httpsPrincipal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
"
https
:
/
/
"
+
cookie
.
rawHost
+
ChromeUtils
.
originAttributesToSuffix
(
cookie
.
originAttributes
)
)
;
maybeClearPrincipals
.
set
(
httpPrincipal
.
origin
httpPrincipal
)
;
maybeClearPrincipals
.
set
(
httpsPrincipal
.
origin
httpsPrincipal
)
;
saved_date
=
cookie
.
creationTime
;
}
if
(
this
.
_firstIteration
)
{
let
startDate
=
Date
.
now
(
)
-
THREE_DAYS_MS
;
let
storagePrincipals
=
gStorageActivityService
.
getActiveOrigins
(
startDate
*
1000
Date
.
now
(
)
*
1000
)
;
for
(
let
principal
of
storagePrincipals
.
enumerate
(
)
)
{
maybeClearPrincipals
.
set
(
principal
.
origin
principal
)
;
}
}
for
(
let
principal
of
maybeClearPrincipals
.
values
(
)
)
{
await
this
.
maybePurgePrincipal
(
principal
)
;
}
Services
.
prefs
.
setStringPref
(
"
privacy
.
purge_trackers
.
date_in_cookie_database
"
saved_date
)
;
duration
.
push
(
Cu
.
now
(
)
)
;
this
.
_telemetryData
.
durationIntervals
.
push
(
duration
)
;
if
(
!
cookies
.
length
|
|
cookies
.
length
<
100
)
{
logger
.
log
(
"
All
cookie
purging
finished
resetting
list
until
tomorrow
.
"
)
;
this
.
resetPurgeList
(
)
;
this
.
submitTelemetry
(
)
;
this
.
_firstIteration
=
true
;
return
;
}
logger
.
log
(
"
Batch
finished
queueing
next
batch
.
"
)
;
this
.
_firstIteration
=
false
;
Services
.
tm
.
idleDispatchToMainThread
(
(
)
=
>
{
this
.
purgeTrackingCookieJars
(
)
;
}
)
;
}
}
;
