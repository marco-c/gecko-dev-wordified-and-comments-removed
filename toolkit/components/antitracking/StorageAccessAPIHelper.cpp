#
include
"
AntiTrackingLog
.
h
"
#
include
"
StorageAccessAPIHelper
.
h
"
#
include
"
AntiTrackingUtils
.
h
"
#
include
"
TemporaryAccessGrantObserver
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
ContentBlockingAllowList
.
h
"
#
include
"
mozilla
/
ContentBlockingUserInteraction
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
PermissionManager
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsIClassifiedChannel
.
h
"
#
include
"
nsICookiePermission
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
nsIPermission
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURIClassifier
.
h
"
#
include
"
nsIUrlClassifierFeature
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
RejectForeignAllowList
.
h
"
namespace
mozilla
{
LazyLogModule
gAntiTrackingLog
(
"
AntiTracking
"
)
;
}
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
BrowsingContext
;
using
mozilla
:
:
dom
:
:
ContentChild
;
using
mozilla
:
:
dom
:
:
Document
;
using
mozilla
:
:
dom
:
:
WindowGlobalParent
;
using
mozilla
:
:
net
:
:
CookieJarSettings
;
namespace
{
bool
GetTopLevelWindowId
(
BrowsingContext
*
aParentContext
uint32_t
aBehavior
uint64_t
&
aTopLevelInnerWindowId
)
{
MOZ_ASSERT
(
aParentContext
)
;
aTopLevelInnerWindowId
=
(
aBehavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
?
AntiTrackingUtils
:
:
GetTopLevelStorageAreaWindowId
(
aParentContext
)
:
AntiTrackingUtils
:
:
GetTopLevelAntiTrackingWindowId
(
aParentContext
)
;
return
aTopLevelInnerWindowId
!
=
0
;
}
}
RefPtr
<
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
>
StorageAccessAPIHelper
:
:
AllowAccessFor
(
nsIPrincipal
*
aPrincipal
dom
:
:
BrowsingContext
*
aParentContext
ContentBlockingNotifier
:
:
StorageAccessPermissionGrantedReason
aReason
const
StorageAccessAPIHelper
:
:
PerformFinalChecks
&
aPerformFinalChecks
)
{
MOZ_ASSERT
(
aParentContext
)
;
switch
(
aReason
)
{
case
ContentBlockingNotifier
:
:
eOpener
:
if
(
!
StaticPrefs
:
:
privacy_antitracking_enableWebcompat
(
)
|
|
!
StaticPrefs
:
:
privacy_restrict3rdpartystorage_heuristic_window_open
(
)
)
{
LOG
(
(
"
Bailing
out
early
because
the
window
open
heuristic
is
disabled
"
"
by
pref
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
break
;
case
ContentBlockingNotifier
:
:
eOpenerAfterUserInteraction
:
if
(
!
StaticPrefs
:
:
privacy_antitracking_enableWebcompat
(
)
|
|
!
StaticPrefs
:
:
privacy_restrict3rdpartystorage_heuristic_opened_window_after_interaction
(
)
)
{
LOG
(
(
"
Bailing
out
early
because
the
window
open
after
interaction
"
"
heuristic
is
disabled
by
pref
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
break
;
default
:
break
;
}
if
(
MOZ_LOG_TEST
(
gAntiTrackingLog
mozilla
:
:
LogLevel
:
:
Debug
)
)
{
nsAutoCString
origin
;
aPrincipal
-
>
GetAsciiOrigin
(
origin
)
;
LOG
(
(
"
Adding
a
first
-
party
storage
exception
for
%
s
triggered
by
%
s
"
PromiseFlatCString
(
origin
)
.
get
(
)
AntiTrackingUtils
:
:
GrantedReasonToString
(
aReason
)
.
get
(
)
)
)
;
}
RefPtr
<
dom
:
:
WindowContext
>
parentWindowContext
=
aParentContext
-
>
GetCurrentWindowContext
(
)
;
if
(
!
parentWindowContext
)
{
LOG
(
(
"
No
window
context
found
for
our
parent
browsing
context
bailing
out
"
"
early
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
parentWindowContext
-
>
GetCookieBehavior
(
)
.
isNothing
(
)
)
{
LOG
(
(
"
No
cookie
behaviour
found
for
our
parent
window
context
bailing
"
"
out
early
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
uint32_t
behavior
=
*
parentWindowContext
-
>
GetCookieBehavior
(
)
;
if
(
!
CookieJarSettings
:
:
IsRejectThirdPartyContexts
(
behavior
)
)
{
LOG
(
(
"
Disabled
by
network
.
cookie
.
cookieBehavior
pref
(
%
d
)
bailing
out
"
"
early
"
behavior
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
MOZ_ASSERT
(
CookieJarSettings
:
:
IsRejectThirdPartyWithExceptions
(
behavior
)
|
|
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
|
|
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
;
if
(
parentWindowContext
-
>
GetIsOnContentBlockingAllowList
(
)
)
{
return
StorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
if
(
!
aParentContext
-
>
IsTopContent
(
)
&
&
Document
:
:
StorageAccessSandboxed
(
aParentContext
-
>
GetSandboxFlags
(
)
)
)
{
LOG
(
(
"
Our
document
is
sandboxed
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
bool
isParentThirdParty
=
parentWindowContext
-
>
GetIsThirdPartyWindow
(
)
;
uint64_t
topLevelWindowId
;
nsAutoCString
trackingOrigin
;
nsCOMPtr
<
nsIPrincipal
>
trackingPrincipal
;
LOG
(
(
"
The
current
resource
is
%
s
-
party
"
isParentThirdParty
?
"
third
"
:
"
first
"
)
)
;
if
(
!
isParentThirdParty
)
{
nsAutoCString
origin
;
nsresult
rv
=
aPrincipal
-
>
GetAsciiOrigin
(
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LOG
(
(
"
Can
'
t
get
the
origin
from
the
URI
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
trackingOrigin
=
origin
;
trackingPrincipal
=
aPrincipal
;
topLevelWindowId
=
aParentContext
-
>
GetCurrentInnerWindowId
(
)
;
if
(
NS_WARN_IF
(
!
topLevelWindowId
)
)
{
LOG
(
(
"
Top
-
level
storage
area
window
id
not
found
bailing
out
early
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
}
else
{
if
(
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
&
&
!
parentWindowContext
-
>
GetIsThirdPartyTrackingResourceWindow
(
)
)
{
LOG
(
(
"
Our
window
isn
'
t
a
third
-
party
tracking
window
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
(
CookieJarSettings
:
:
IsRejectThirdPartyWithExceptions
(
behavior
)
|
|
behavior
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
)
&
&
!
isParentThirdParty
)
{
LOG
(
(
"
Our
window
isn
'
t
a
third
-
party
window
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
!
GetTopLevelWindowId
(
aParentContext
nsICookieService
:
:
BEHAVIOR_ACCEPT
topLevelWindowId
)
)
{
LOG
(
(
"
Error
while
retrieving
the
parent
window
id
bailing
out
early
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
aParentContext
-
>
IsInProcess
(
)
)
{
if
(
!
AntiTrackingUtils
:
:
GetPrincipalAndTrackingOrigin
(
aParentContext
getter_AddRefs
(
trackingPrincipal
)
trackingOrigin
)
)
{
LOG
(
(
"
Error
while
computing
the
parent
principal
and
tracking
origin
"
"
bailing
out
early
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
}
}
MOZ_ASSERT_IF
(
!
aParentContext
-
>
IsInProcess
(
)
aReason
=
=
ContentBlockingNotifier
:
:
eOpenerAfterUserInteraction
)
;
bool
runInSameProcess
;
if
(
XRE_IsParentProcess
(
)
)
{
runInSameProcess
=
true
;
}
else
{
if
(
aParentContext
-
>
IsInProcess
(
)
)
{
bool
isThirdParty
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
AntiTrackingUtils
:
:
GetPrincipal
(
aParentContext
)
;
if
(
!
principal
)
{
LOG
(
(
"
Can
'
t
get
the
principal
from
the
browsing
context
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
Unused
<
<
trackingPrincipal
-
>
IsThirdPartyPrincipal
(
principal
&
isThirdParty
)
;
runInSameProcess
=
aReason
=
=
ContentBlockingNotifier
:
:
ePrivilegeStorageAccessForOriginAPI
|
|
!
isThirdParty
;
}
else
{
runInSameProcess
=
false
;
}
}
if
(
runInSameProcess
)
{
return
StorageAccessAPIHelper
:
:
CompleteAllowAccessFor
(
aParentContext
topLevelWindowId
trackingPrincipal
trackingOrigin
behavior
aReason
aPerformFinalChecks
)
;
}
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_ASSERT
(
!
aPerformFinalChecks
)
;
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cc
)
;
RefPtr
<
BrowsingContext
>
bc
=
aParentContext
;
return
cc
-
>
SendCompleteAllowAccessFor
(
aParentContext
topLevelWindowId
trackingPrincipal
trackingOrigin
behavior
aReason
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
bc
trackingOrigin
behavior
aReason
]
(
const
ContentChild
:
:
CompleteAllowAccessForPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
&
&
aValue
.
ResolveValue
(
)
.
isSome
(
)
)
{
if
(
aReason
=
=
ContentBlockingNotifier
:
:
eOpener
&
&
!
bc
-
>
IsDiscarded
(
)
)
{
MOZ_ASSERT
(
bc
-
>
IsInProcess
(
)
)
;
StorageAccessAPIHelper
:
:
OnAllowAccessFor
(
bc
trackingOrigin
behavior
aReason
)
;
}
return
StorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
aValue
.
ResolveValue
(
)
.
value
(
)
__func__
)
;
}
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
RefPtr
<
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
>
StorageAccessAPIHelper
:
:
CompleteAllowAccessFor
(
dom
:
:
BrowsingContext
*
aParentContext
uint64_t
aTopLevelWindowId
nsIPrincipal
*
aTrackingPrincipal
const
nsACString
&
aTrackingOrigin
uint32_t
aCookieBehavior
ContentBlockingNotifier
:
:
StorageAccessPermissionGrantedReason
aReason
const
PerformFinalChecks
&
aPerformFinalChecks
)
{
MOZ_ASSERT
(
aParentContext
)
;
MOZ_ASSERT_IF
(
XRE_IsContentProcess
(
)
aParentContext
-
>
IsInProcess
(
)
)
;
nsCOMPtr
<
nsIPrincipal
>
trackingPrincipal
;
nsAutoCString
trackingOrigin
;
if
(
!
aTrackingPrincipal
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
&
&
aReason
=
=
ContentBlockingNotifier
:
:
eOpenerAfterUserInteraction
)
;
if
(
!
AntiTrackingUtils
:
:
GetPrincipalAndTrackingOrigin
(
aParentContext
getter_AddRefs
(
trackingPrincipal
)
trackingOrigin
)
)
{
LOG
(
(
"
Error
while
computing
the
parent
principal
and
tracking
origin
"
"
bailing
out
early
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
}
else
{
trackingPrincipal
=
aTrackingPrincipal
;
trackingOrigin
=
aTrackingOrigin
;
}
LOG
(
(
"
Tracking
origin
is
%
s
"
PromiseFlatCString
(
trackingOrigin
)
.
get
(
)
)
)
;
bool
isInPrefList
=
false
;
trackingPrincipal
-
>
IsURIInPrefList
(
"
privacy
.
restrict3rdpartystorage
.
"
"
userInteractionRequiredForHosts
"
&
isInPrefList
)
;
if
(
aReason
!
=
ContentBlockingNotifier
:
:
ePrivilegeStorageAccessForOriginAPI
&
&
isInPrefList
&
&
!
ContentBlockingUserInteraction
:
:
Exists
(
trackingPrincipal
)
)
{
LOG_PRIN
(
(
"
Tracking
principal
(
%
s
)
hasn
'
t
been
interacted
with
before
"
"
refusing
to
add
a
first
-
party
storage
permission
to
access
it
"
_spec
)
trackingPrincipal
)
;
ContentBlockingNotifier
:
:
OnDecision
(
aParentContext
ContentBlockingNotifier
:
:
BlockingDecision
:
:
eBlock
CookieJarSettings
:
:
IsRejectThirdPartyWithExceptions
(
aCookieBehavior
)
?
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
:
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
aParentContext
-
>
IsInProcess
(
)
&
&
(
!
aParentContext
-
>
GetDOMWindow
(
)
|
|
!
aParentContext
-
>
GetDOMWindow
(
)
-
>
GetCurrentInnerWindow
(
)
)
)
{
LOG
(
(
"
No
window
found
for
our
parent
browsing
context
bailing
out
"
"
early
"
)
)
;
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
auto
storePermission
=
[
aParentContext
aTopLevelWindowId
trackingOrigin
trackingPrincipal
aCookieBehavior
aReason
]
(
int
aAllowMode
)
-
>
RefPtr
<
StorageAccessPermissionGrantPromise
>
{
if
(
aParentContext
-
>
IsInProcess
(
)
)
{
StorageAccessAPIHelper
:
:
OnAllowAccessFor
(
aParentContext
trackingOrigin
aCookieBehavior
aReason
)
;
}
else
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
aReason
!
=
ContentBlockingNotifier
:
:
eOpener
)
{
ContentParent
*
cp
=
aParentContext
-
>
Canonical
(
)
-
>
GetContentParent
(
)
;
Unused
<
<
cp
-
>
SendOnAllowAccessFor
(
aParentContext
trackingOrigin
aCookieBehavior
aReason
)
;
}
}
Maybe
<
ContentBlockingNotifier
:
:
StorageAccessPermissionGrantedReason
>
reportReason
;
if
(
XRE_IsParentProcess
(
)
|
|
aParentContext
-
>
Top
(
)
-
>
IsInProcess
(
)
)
{
ContentBlockingNotifier
:
:
ReportUnblockingToConsole
(
aParentContext
NS_ConvertUTF8toUTF16
(
trackingOrigin
)
aReason
)
;
reportReason
=
Nothing
(
)
;
}
else
{
reportReason
.
emplace
(
aReason
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
LOG
(
(
"
Saving
the
permission
:
trackingOrigin
=
%
s
"
trackingOrigin
.
get
(
)
)
)
;
return
SaveAccessForOriginOnParentProcess
(
aTopLevelWindowId
aParentContext
trackingPrincipal
aAllowMode
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
aReason
trackingPrincipal
]
(
ParentAccessGrantPromise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
if
(
!
aValue
.
IsResolve
(
)
)
{
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
aReason
=
=
ContentBlockingNotifier
:
:
eStorageAccessAPI
)
{
ContentBlockingUserInteraction
:
:
Observe
(
trackingPrincipal
)
;
}
return
StorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
StorageAccessAPIHelper
:
:
eAllow
__func__
)
;
}
)
;
}
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cc
)
;
LOG
(
(
"
Asking
the
parent
process
to
save
the
permission
for
us
:
"
"
trackingOrigin
=
%
s
"
trackingOrigin
.
get
(
)
)
)
;
return
cc
-
>
SendStorageAccessPermissionGrantedForOrigin
(
aTopLevelWindowId
aParentContext
trackingPrincipal
trackingOrigin
aAllowMode
reportReason
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
aReason
trackingPrincipal
]
(
const
ContentChild
:
:
StorageAccessPermissionGrantedForOriginPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
if
(
aValue
.
ResolveValue
(
)
&
&
(
aReason
=
=
ContentBlockingNotifier
:
:
eStorageAccessAPI
)
)
{
ContentBlockingUserInteraction
:
:
Observe
(
trackingPrincipal
)
;
}
return
StorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
aValue
.
ResolveValue
(
)
__func__
)
;
}
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
;
if
(
aPerformFinalChecks
)
{
return
aPerformFinalChecks
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
storePermission
]
(
StorageAccessPermissionGrantPromise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
return
storePermission
(
aValue
.
ResolveValue
(
)
)
;
}
return
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
return
storePermission
(
false
)
;
}
void
StorageAccessAPIHelper
:
:
OnAllowAccessFor
(
dom
:
:
BrowsingContext
*
aParentContext
const
nsACString
&
aTrackingOrigin
uint32_t
aCookieBehavior
ContentBlockingNotifier
:
:
StorageAccessPermissionGrantedReason
aReason
)
{
MOZ_ASSERT
(
aParentContext
-
>
IsInProcess
(
)
)
;
StorageAccessAPIHelper
:
:
UpdateAllowAccessOnCurrentProcess
(
aParentContext
aTrackingOrigin
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
parentInner
=
AntiTrackingUtils
:
:
GetInnerWindow
(
aParentContext
)
;
if
(
NS_WARN_IF
(
!
parentInner
)
)
{
return
;
}
Document
*
doc
=
parentInner
-
>
GetExtantDoc
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
;
}
if
(
!
doc
-
>
GetChannel
(
)
)
{
return
;
}
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_STORAGE_ACCESS_GRANTED_COUNT
:
:
StorageGranted
)
;
switch
(
aReason
)
{
case
ContentBlockingNotifier
:
:
StorageAccessPermissionGrantedReason
:
:
eStorageAccessAPI
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_STORAGE_ACCESS_GRANTED_COUNT
:
:
StorageAccessAPI
)
;
break
;
case
ContentBlockingNotifier
:
:
StorageAccessPermissionGrantedReason
:
:
eOpenerAfterUserInteraction
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_STORAGE_ACCESS_GRANTED_COUNT
:
:
OpenerAfterUI
)
;
break
;
case
ContentBlockingNotifier
:
:
StorageAccessPermissionGrantedReason
:
:
eOpener
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_STORAGE_ACCESS_GRANTED_COUNT
:
:
Opener
)
;
break
;
default
:
break
;
}
ContentBlockingNotifier
:
:
OnEvent
(
doc
-
>
GetChannel
(
)
false
CookieJarSettings
:
:
IsRejectThirdPartyWithExceptions
(
aCookieBehavior
)
?
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
:
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
aTrackingOrigin
Some
(
aReason
)
)
;
}
RefPtr
<
mozilla
:
:
StorageAccessAPIHelper
:
:
ParentAccessGrantPromise
>
StorageAccessAPIHelper
:
:
SaveAccessForOriginOnParentProcess
(
uint64_t
aTopLevelWindowId
BrowsingContext
*
aParentContext
nsIPrincipal
*
aTrackingPrincipal
int
aAllowMode
uint64_t
aExpirationTime
)
{
MOZ_ASSERT
(
aTopLevelWindowId
!
=
0
)
;
MOZ_ASSERT
(
aTrackingPrincipal
)
;
if
(
!
aTrackingPrincipal
|
|
aTrackingPrincipal
-
>
IsSystemPrincipal
(
)
|
|
aTrackingPrincipal
-
>
GetIsNullPrincipal
(
)
|
|
aTrackingPrincipal
-
>
GetIsExpandedPrincipal
(
)
)
{
LOG
(
(
"
aTrackingPrincipal
is
of
invalid
principal
type
"
)
)
;
return
ParentAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
nsAutoCString
trackingOrigin
;
nsresult
rv
=
aTrackingPrincipal
-
>
GetOriginNoSuffix
(
trackingOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ParentAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
RefPtr
<
WindowGlobalParent
>
wgp
=
WindowGlobalParent
:
:
GetByInnerWindowId
(
aTopLevelWindowId
)
;
if
(
!
wgp
)
{
LOG
(
(
"
Can
'
t
get
window
global
parent
"
)
)
;
return
ParentAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
StorageAccessAPIHelper
:
:
UpdateAllowAccessOnParentProcess
(
aParentContext
trackingOrigin
)
;
return
StorageAccessAPIHelper
:
:
SaveAccessForOriginOnParentProcess
(
wgp
-
>
DocumentPrincipal
(
)
aTrackingPrincipal
aAllowMode
aExpirationTime
)
;
}
RefPtr
<
mozilla
:
:
StorageAccessAPIHelper
:
:
ParentAccessGrantPromise
>
StorageAccessAPIHelper
:
:
SaveAccessForOriginOnParentProcess
(
nsIPrincipal
*
aParentPrincipal
nsIPrincipal
*
aTrackingPrincipal
int
aAllowMode
uint64_t
aExpirationTime
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
aAllowMode
=
=
eAllow
|
|
aAllowMode
=
=
eAllowAutoGrant
)
;
if
(
!
aParentPrincipal
|
|
!
aTrackingPrincipal
)
{
LOG
(
(
"
Invalid
input
arguments
passed
"
)
)
;
return
ParentAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
;
if
(
aTrackingPrincipal
-
>
IsSystemPrincipal
(
)
|
|
aTrackingPrincipal
-
>
GetIsNullPrincipal
(
)
|
|
aTrackingPrincipal
-
>
GetIsExpandedPrincipal
(
)
)
{
LOG
(
(
"
aTrackingPrincipal
is
of
invalid
principal
type
"
)
)
;
return
ParentAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
nsAutoCString
trackingOrigin
;
nsresult
rv
=
aTrackingPrincipal
-
>
GetOriginNoSuffix
(
trackingOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ParentAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
LOG_PRIN
(
(
"
Saving
a
first
-
party
storage
permission
on
%
s
for
"
"
trackingOrigin
=
%
s
"
_spec
trackingOrigin
.
get
(
)
)
aParentPrincipal
)
;
if
(
NS_WARN_IF
(
!
aParentPrincipal
)
)
{
LOG
(
(
"
aParentPrincipal
is
null
bailing
out
early
"
)
)
;
return
ParentAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
PermissionManager
*
permManager
=
PermissionManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
permManager
)
)
{
LOG
(
(
"
Permission
manager
is
null
bailing
out
early
"
)
)
;
return
ParentAccessGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
uint32_t
expirationType
=
nsIPermissionManager
:
:
EXPIRE_TIME
;
uint32_t
expirationTime
=
aExpirationTime
*
1000
;
int64_t
when
=
(
PR_Now
(
)
/
PR_USEC_PER_MSEC
)
+
expirationTime
;
uint32_t
privateBrowsingId
=
0
;
rv
=
aParentPrincipal
-
>
GetPrivateBrowsingId
(
&
privateBrowsingId
)
;
if
(
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
&
&
privateBrowsingId
>
0
)
|
|
(
aAllowMode
=
=
eAllowAutoGrant
)
)
{
expirationType
=
nsIPermissionManager
:
:
EXPIRE_SESSION
;
when
=
0
;
}
nsAutoCString
type
;
AntiTrackingUtils
:
:
CreateStoragePermissionKey
(
trackingOrigin
type
)
;
LOG
(
(
"
Computed
permission
key
:
%
s
expiry
:
%
u
proceeding
to
save
in
the
"
"
permission
manager
"
type
.
get
(
)
expirationTime
)
)
;
rv
=
permManager
-
>
AddFromPrincipal
(
aParentPrincipal
type
nsIPermissionManager
:
:
ALLOW_ACTION
expirationType
when
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
if
(
StaticPrefs
:
:
privacy_antitracking_testing
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
obs
-
>
NotifyObservers
(
nullptr
"
antitracking
-
test
-
storage
-
access
-
perm
-
added
"
nullptr
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
aAllowMode
=
=
eAllowAutoGrant
)
)
{
TemporaryAccessGrantObserver
:
:
Create
(
permManager
aParentPrincipal
type
)
;
}
LOG
(
(
"
Result
:
%
s
"
NS_SUCCEEDED
(
rv
)
?
"
success
"
:
"
failure
"
)
)
;
return
ParentAccessGrantPromise
:
:
CreateAndResolve
(
rv
__func__
)
;
}
Maybe
<
bool
>
StorageAccessAPIHelper
:
:
CheckCookiesPermittedDecidesStorageAccessAPI
(
nsICookieJarSettings
*
aCookieJarSettings
nsIPrincipal
*
aRequestingPrincipal
)
{
MOZ_ASSERT
(
aCookieJarSettings
)
;
MOZ_ASSERT
(
aRequestingPrincipal
)
;
uint32_t
cookiePermission
=
CheckCookiePermissionForPrincipal
(
aCookieJarSettings
aRequestingPrincipal
)
;
if
(
cookiePermission
=
=
nsICookiePermission
:
:
ACCESS_ALLOW
|
|
cookiePermission
=
=
nsICookiePermission
:
:
ACCESS_SESSION
)
{
return
Some
(
true
)
;
}
else
if
(
cookiePermission
=
=
nsICookiePermission
:
:
ACCESS_DENY
)
{
return
Some
(
false
)
;
}
if
(
ContentBlockingAllowList
:
:
Check
(
aCookieJarSettings
)
)
{
return
Some
(
true
)
;
}
return
Nothing
(
)
;
}
RefPtr
<
MozPromise
<
Maybe
<
bool
>
nsresult
true
>
>
StorageAccessAPIHelper
:
:
AsyncCheckCookiesPermittedDecidesStorageAccessAPI
(
dom
:
:
BrowsingContext
*
aBrowsingContext
nsIPrincipal
*
aRequestingPrincipal
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cc
)
;
return
cc
-
>
SendTestCookiePermissionDecided
(
aBrowsingContext
aRequestingPrincipal
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
]
(
const
ContentChild
:
:
TestCookiePermissionDecidedPromise
:
:
ResolveOrRejectValue
&
aPromise
)
{
if
(
aPromise
.
IsResolve
(
)
)
{
return
MozPromise
<
Maybe
<
bool
>
nsresult
true
>
:
:
CreateAndResolve
(
aPromise
.
ResolveValue
(
)
__func__
)
;
}
return
MozPromise
<
Maybe
<
bool
>
nsresult
true
>
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
)
;
}
Maybe
<
bool
>
StorageAccessAPIHelper
:
:
CheckBrowserSettingsDecidesStorageAccessAPI
(
nsICookieJarSettings
*
aCookieJarSettings
bool
aThirdParty
bool
aOnRejectForeignAllowlist
bool
aIsOnThirdPartySkipList
bool
aIsThirdPartyTracker
)
{
MOZ_ASSERT
(
aCookieJarSettings
)
;
uint32_t
behavior
=
aCookieJarSettings
-
>
GetCookieBehavior
(
)
;
switch
(
behavior
)
{
case
nsICookieService
:
:
BEHAVIOR_ACCEPT
:
return
Some
(
true
)
;
case
nsICookieService
:
:
BEHAVIOR_REJECT_FOREIGN
:
if
(
!
aThirdParty
)
{
return
Some
(
true
)
;
}
if
(
!
StaticPrefs
:
:
network_cookie_rejectForeignWithExceptions_enabled
(
)
)
{
return
Some
(
false
)
;
}
return
Some
(
aOnRejectForeignAllowlist
)
;
case
nsICookieService
:
:
BEHAVIOR_REJECT
:
return
Some
(
false
)
;
case
nsICookieService
:
:
BEHAVIOR_LIMIT_FOREIGN
:
if
(
!
aThirdParty
)
{
return
Some
(
true
)
;
}
return
Some
(
false
)
;
case
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
:
if
(
!
aIsThirdPartyTracker
)
{
return
Some
(
true
)
;
}
if
(
aIsOnThirdPartySkipList
)
{
return
Some
(
true
)
;
}
return
Nothing
(
)
;
case
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
:
if
(
!
aThirdParty
)
{
return
Some
(
true
)
;
}
if
(
aIsOnThirdPartySkipList
)
{
return
Some
(
true
)
;
}
return
Nothing
(
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Must
not
have
undefined
cookie
behavior
"
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Must
not
have
undefined
cookie
behavior
"
)
;
return
Nothing
(
)
;
}
Maybe
<
bool
>
StorageAccessAPIHelper
:
:
CheckCallingContextDecidesStorageAccessAPI
(
Document
*
aDocument
bool
aRequestingStorageAccess
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
aRequestingStorageAccess
)
{
if
(
!
aDocument
-
>
HasValidTransientUserGestureActivation
(
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
nsLiteralCString
(
"
requestStorageAccess
"
)
aDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
RequestStorageAccessUserGesture
"
)
;
return
Some
(
false
)
;
}
}
if
(
aDocument
-
>
IsTopLevelContentDocument
(
)
)
{
return
Some
(
true
)
;
}
RefPtr
<
BrowsingContext
>
bc
=
aDocument
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
Some
(
false
)
;
}
if
(
bc
-
>
Top
(
)
-
>
IsInProcess
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
topOuter
=
bc
-
>
Top
(
)
-
>
GetDOMWindow
(
)
;
if
(
!
topOuter
)
{
return
Some
(
false
)
;
}
nsCOMPtr
<
Document
>
topLevelDoc
=
topOuter
-
>
GetExtantDoc
(
)
;
if
(
!
topLevelDoc
)
{
return
Some
(
false
)
;
}
if
(
topLevelDoc
-
>
NodePrincipal
(
)
-
>
Equals
(
aDocument
-
>
NodePrincipal
(
)
)
)
{
return
Some
(
true
)
;
}
}
if
(
aDocument
-
>
NodePrincipal
(
)
-
>
GetIsNullPrincipal
(
)
)
{
if
(
aRequestingStorageAccess
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
nsLiteralCString
(
"
requestStorageAccess
"
)
aDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
RequestStorageAccessNullPrincipal
"
)
;
}
return
Some
(
false
)
;
}
if
(
aRequestingStorageAccess
)
{
if
(
aDocument
-
>
StorageAccessSandboxed
(
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
nsLiteralCString
(
"
requestStorageAccess
"
)
aDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
RequestStorageAccessSandboxed
"
)
;
return
Some
(
false
)
;
}
}
return
Nothing
(
)
;
}
Maybe
<
bool
>
StorageAccessAPIHelper
:
:
CheckSameSiteCallingContextDecidesStorageAccessAPI
(
dom
:
:
Document
*
aDocument
bool
aRequireUserActivation
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
aRequireUserActivation
)
{
if
(
!
aDocument
-
>
HasValidTransientUserGestureActivation
(
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
nsLiteralCString
(
"
requestStorageAccess
"
)
aDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
RequestStorageAccessUserGesture
"
)
;
return
Some
(
false
)
;
}
}
nsIChannel
*
chan
=
aDocument
-
>
GetChannel
(
)
;
if
(
!
chan
)
{
return
Some
(
false
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
chan
-
>
LoadInfo
(
)
;
if
(
loadInfo
-
>
GetIsThirdPartyContextToTopWindow
(
)
)
{
return
Some
(
false
)
;
}
if
(
aDocument
-
>
NodePrincipal
(
)
-
>
GetIsNullPrincipal
(
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
nsLiteralCString
(
"
requestStorageAccess
"
)
aDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
RequestStorageAccessNullPrincipal
"
)
;
return
Some
(
false
)
;
}
return
Maybe
<
bool
>
(
)
;
}
Maybe
<
bool
>
StorageAccessAPIHelper
:
:
CheckExistingPermissionDecidesStorageAccessAPI
(
dom
:
:
Document
*
aDocument
bool
aRequestingStorageAccess
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
aDocument
-
>
StorageAccessSandboxed
(
)
)
{
if
(
aRequestingStorageAccess
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
nsLiteralCString
(
"
requestStorageAccess
"
)
aDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
RequestStorageAccessSandboxed
"
)
;
}
return
Some
(
false
)
;
}
if
(
aDocument
-
>
HasStorageAccessPermissionGranted
(
)
)
{
return
Some
(
true
)
;
}
return
Nothing
(
)
;
}
void
StorageAccessAPIHelper
:
:
UpdateAllowAccessOnCurrentProcess
(
BrowsingContext
*
aParentContext
const
nsACString
&
aTrackingOrigin
)
{
MOZ_ASSERT
(
aParentContext
&
&
aParentContext
-
>
IsInProcess
(
)
)
;
bool
useRemoteSubframes
;
aParentContext
-
>
GetUseRemoteSubframes
(
&
useRemoteSubframes
)
;
if
(
useRemoteSubframes
&
&
aParentContext
-
>
IsTopContent
(
)
)
{
return
;
}
BrowsingContext
*
top
=
aParentContext
-
>
Top
(
)
;
top
-
>
PreOrderWalk
(
[
&
]
(
BrowsingContext
*
aContext
)
{
if
(
aContext
-
>
IsInProcess
(
)
)
{
nsAutoCString
origin
;
Unused
<
<
AntiTrackingUtils
:
:
GetPrincipalAndTrackingOrigin
(
aContext
nullptr
origin
)
;
if
(
aTrackingOrigin
=
=
origin
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
AntiTrackingUtils
:
:
GetInnerWindow
(
aContext
)
;
if
(
inner
)
{
inner
-
>
SaveStorageAccessPermissionGranted
(
)
;
}
}
}
}
)
;
}
void
StorageAccessAPIHelper
:
:
UpdateAllowAccessOnParentProcess
(
BrowsingContext
*
aParentContext
const
nsACString
&
aTrackingOrigin
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsAutoCString
topKey
;
nsCOMPtr
<
nsIPrincipal
>
topPrincipal
=
AntiTrackingUtils
:
:
GetPrincipal
(
aParentContext
-
>
Top
(
)
)
;
PermissionManager
:
:
GetKeyForPrincipal
(
topPrincipal
false
true
topKey
)
;
for
(
const
auto
&
topContext
:
aParentContext
-
>
Group
(
)
-
>
Toplevels
(
)
)
{
if
(
topContext
=
=
aParentContext
-
>
Top
(
)
)
{
bool
useRemoteSubframes
;
aParentContext
-
>
GetUseRemoteSubframes
(
&
useRemoteSubframes
)
;
if
(
!
useRemoteSubframes
)
{
continue
;
}
RefPtr
<
dom
:
:
WindowContext
>
ctx
=
aParentContext
-
>
GetCurrentWindowContext
(
)
;
if
(
ctx
&
&
ctx
-
>
GetIsThirdPartyWindow
(
)
)
{
continue
;
}
}
else
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
AntiTrackingUtils
:
:
GetPrincipal
(
topContext
)
;
if
(
!
principal
)
{
continue
;
}
nsAutoCString
key
;
PermissionManager
:
:
GetKeyForPrincipal
(
principal
false
true
key
)
;
if
(
topKey
!
=
key
)
{
continue
;
}
}
topContext
-
>
PreOrderWalk
(
[
&
]
(
BrowsingContext
*
aContext
)
{
WindowGlobalParent
*
wgp
=
aContext
-
>
Canonical
(
)
-
>
GetCurrentWindowGlobal
(
)
;
if
(
!
wgp
)
{
return
;
}
nsAutoCString
origin
;
AntiTrackingUtils
:
:
GetPrincipalAndTrackingOrigin
(
aContext
nullptr
origin
)
;
if
(
aTrackingOrigin
=
=
origin
)
{
Unused
<
<
wgp
-
>
SendSaveStorageAccessPermissionGranted
(
)
;
}
}
)
;
}
}
