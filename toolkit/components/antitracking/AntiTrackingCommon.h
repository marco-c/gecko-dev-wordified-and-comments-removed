#
ifndef
mozilla_antitrackingservice_h
#
define
mozilla_antitrackingservice_h
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
define
USER_INTERACTION_PERM
NS_LITERAL_CSTRING
(
"
storageAccessAPI
"
)
class
nsIChannel
;
class
nsICookieSettings
;
class
nsIPermission
;
class
nsIPrincipal
;
class
nsIURI
;
class
nsPIDOMWindowInner
;
class
nsPIDOMWindowOuter
;
namespace
mozilla
{
class
OriginAttributes
;
class
AntiTrackingCommon
final
{
public
:
typedef
std
:
:
function
<
void
(
const
bool
&
)
>
FirstPartyStorageAccessGrantedForOriginResolver
;
static
bool
IsFirstPartyStorageAccessGrantedFor
(
nsPIDOMWindowInner
*
a3rdPartyTrackingWindow
nsIURI
*
aURI
uint32_t
*
aRejectedReason
)
;
static
bool
MaybeIsFirstPartyStorageAccessGrantedFor
(
nsPIDOMWindowInner
*
aFirstPartyWindow
nsIURI
*
aURI
)
;
static
bool
IsFirstPartyStorageAccessGrantedFor
(
nsIChannel
*
aChannel
nsIURI
*
aURI
uint32_t
*
aRejectedReason
)
;
static
bool
IsFirstPartyStorageAccessGrantedFor
(
nsIPrincipal
*
aPrincipal
nsICookieSettings
*
aCookieSettings
)
;
enum
StorageAccessGrantedReason
{
eStorageAccessAPI
eOpenerAfterUserInteraction
eOpener
}
;
enum
StorageAccessPromptChoices
{
eAllow
eAllowAutoGrant
}
;
typedef
MozPromise
<
int
bool
true
>
StorageAccessFinalCheckPromise
;
typedef
std
:
:
function
<
RefPtr
<
StorageAccessFinalCheckPromise
>
(
)
>
PerformFinalChecks
;
typedef
MozPromise
<
int
bool
true
>
StorageAccessGrantPromise
;
static
MOZ_MUST_USE
RefPtr
<
StorageAccessGrantPromise
>
AddFirstPartyStorageAccessGrantedFor
(
nsIPrincipal
*
aPrincipal
nsPIDOMWindowInner
*
aParentWindow
StorageAccessGrantedReason
aReason
const
PerformFinalChecks
&
aPerformFinalChecks
=
nullptr
)
;
static
bool
CreateStoragePermissionKey
(
nsIPrincipal
*
aPrincipal
nsACString
&
aKey
)
;
static
bool
IsStorageAccessPermission
(
nsIPermission
*
aPermission
nsIPrincipal
*
aPrincipal
)
;
static
void
StoreUserInteractionFor
(
nsIPrincipal
*
aPrincipal
)
;
static
bool
HasUserInteraction
(
nsIPrincipal
*
aPrincipal
)
;
typedef
std
:
:
function
<
void
(
)
>
AntiTrackingSettingsChangedCallback
;
static
void
OnAntiTrackingSettingsChanged
(
const
AntiTrackingSettingsChangedCallback
&
aCallback
)
;
typedef
MozPromise
<
nsresult
bool
true
>
FirstPartyStorageAccessGrantPromise
;
static
RefPtr
<
FirstPartyStorageAccessGrantPromise
>
SaveFirstPartyStorageAccessGrantedForOriginOnParentProcess
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aTrackingPrinciapl
const
nsCString
&
aTrackingOrigin
int
aAllowMode
uint64_t
aExpirationTime
=
StaticPrefs
:
:
privacy_restrict3rdpartystorage_expiration
(
)
)
;
static
nsresult
IsOnContentBlockingAllowList
(
nsIPrincipal
*
aTopWinPrincipal
bool
aIsPrivateBrowsing
bool
&
aIsAllowListed
)
;
static
void
ComputeContentBlockingAllowListPrincipal
(
nsIPrincipal
*
aDocumentPrincipal
nsIPrincipal
*
*
aPrincipal
)
;
static
void
RecomputeContentBlockingAllowListPrincipal
(
nsIURI
*
aURIBeingLoaded
const
OriginAttributes
&
aAttrs
nsIPrincipal
*
*
aPrincipal
)
;
enum
class
BlockingDecision
{
eBlock
eAllow
}
;
static
void
NotifyBlockingDecision
(
nsIChannel
*
aChannel
BlockingDecision
aDecision
uint32_t
aRejectedReason
)
;
static
void
NotifyBlockingDecision
(
nsPIDOMWindowInner
*
aWindow
BlockingDecision
aDecision
uint32_t
aRejectedReason
)
;
static
already_AddRefed
<
nsIURI
>
MaybeGetDocumentURIBeingLoaded
(
nsIChannel
*
aChannel
)
;
static
void
NotifyContentBlockingEvent
(
nsIChannel
*
aChannel
uint32_t
aRejectedReason
)
;
static
void
NotifyContentBlockingEvent
(
nsPIDOMWindowOuter
*
aWindow
nsIChannel
*
aReportingChannel
nsIChannel
*
aTrackingChannel
bool
aBlocked
uint32_t
aRejectedReason
const
nsACString
&
aTrackingOrigin
const
Maybe
<
StorageAccessGrantedReason
>
&
aReason
=
Nothing
(
)
)
;
static
void
RedirectHeuristic
(
nsIChannel
*
aOldChannel
nsIURI
*
aOldURI
nsIChannel
*
aNewChannel
nsIURI
*
aNewURI
)
;
}
;
}
#
endif
