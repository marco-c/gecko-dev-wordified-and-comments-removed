#
ifndef
mozilla_antitrackingservice_h
#
define
mozilla_antitrackingservice_h
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
define
USER_INTERACTION_PERM
NS_LITERAL_CSTRING
(
"
storageAccessAPI
"
)
class
nsIChannel
;
class
nsIHttpChannel
;
class
nsIPermission
;
class
nsIPrincipal
;
class
nsIURI
;
class
nsPIDOMWindowInner
;
namespace
mozilla
{
class
AntiTrackingCommon
final
{
public
:
typedef
std
:
:
function
<
void
(
const
bool
&
)
>
FirstPartyStorageAccessGrantedForOriginResolver
;
static
bool
IsFirstPartyStorageAccessGrantedFor
(
nsPIDOMWindowInner
*
a3rdPartyTrackingWindow
nsIURI
*
aURI
uint32_t
*
aRejectedReason
)
;
static
bool
MaybeIsFirstPartyStorageAccessGrantedFor
(
nsPIDOMWindowInner
*
aFirstPartyWindow
nsIURI
*
aURI
)
;
static
bool
IsFirstPartyStorageAccessGrantedFor
(
nsIHttpChannel
*
aChannel
nsIURI
*
aURI
uint32_t
*
aRejectedReason
)
;
static
bool
IsFirstPartyStorageAccessGrantedFor
(
nsIPrincipal
*
aPrincipal
)
;
enum
StorageAccessGrantedReason
{
eStorageAccessAPI
eOpenerAfterUserInteraction
eOpener
}
;
enum
StorageAccessPromptChoices
{
eAllow
eAllowAutoGrant
eAllowOnAnySite
}
;
typedef
MozPromise
<
int
bool
true
>
StorageAccessFinalCheckPromise
;
typedef
std
:
:
function
<
RefPtr
<
StorageAccessFinalCheckPromise
>
(
)
>
PerformFinalChecks
;
typedef
MozPromise
<
int
bool
true
>
StorageAccessGrantPromise
;
static
MOZ_MUST_USE
RefPtr
<
StorageAccessGrantPromise
>
AddFirstPartyStorageAccessGrantedFor
(
nsIPrincipal
*
aPrincipal
nsPIDOMWindowInner
*
aParentWindow
StorageAccessGrantedReason
aReason
const
PerformFinalChecks
&
aPerformFinalChecks
=
nullptr
)
;
static
bool
IsStorageAccessPermission
(
nsIPermission
*
aPermission
nsIPrincipal
*
aPrincipal
)
;
static
void
StoreUserInteractionFor
(
nsIPrincipal
*
aPrincipal
)
;
static
bool
HasUserInteraction
(
nsIPrincipal
*
aPrincipal
)
;
typedef
std
:
:
function
<
void
(
)
>
AntiTrackingSettingsChangedCallback
;
static
void
OnAntiTrackingSettingsChanged
(
const
AntiTrackingSettingsChangedCallback
&
aCallback
)
;
typedef
MozPromise
<
nsresult
bool
true
>
FirstPartyStorageAccessGrantPromise
;
static
RefPtr
<
FirstPartyStorageAccessGrantPromise
>
SaveFirstPartyStorageAccessGrantedForOriginOnParentProcess
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aTrackingPrinciapl
const
nsCString
&
aParentOrigin
const
nsCString
&
aGrantedOrigin
int
aAllowMode
)
;
enum
ContentBlockingAllowListPurpose
{
eStorageChecks
eTrackingProtection
eTrackingAnnotations
eFingerprinting
eCryptomining
}
;
static
nsresult
IsOnContentBlockingAllowList
(
nsIURI
*
aTopWinURI
bool
aIsPrivateBrowsing
ContentBlockingAllowListPurpose
aPurpose
bool
&
aIsAllowListed
)
;
enum
class
BlockingDecision
{
eBlock
eAllow
}
;
static
void
NotifyBlockingDecision
(
nsIChannel
*
aChannel
BlockingDecision
aDecision
uint32_t
aRejectedReason
)
;
static
void
NotifyBlockingDecision
(
nsPIDOMWindowInner
*
aWindow
BlockingDecision
aDecision
uint32_t
aRejectedReason
)
;
static
already_AddRefed
<
nsIURI
>
MaybeGetDocumentURIBeingLoaded
(
nsIChannel
*
aChannel
)
;
}
;
}
#
endif
