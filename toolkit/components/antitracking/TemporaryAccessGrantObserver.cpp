#
include
"
TemporaryAccessGrantObserver
.
h
"
#
include
"
AntiTrackingCommon
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsPermissionManager
.
h
"
#
include
"
nsTHashtable
.
h
"
using
namespace
mozilla
;
UniquePtr
<
TemporaryAccessGrantObserver
:
:
ObserversTable
>
TemporaryAccessGrantObserver
:
:
sObservers
;
TemporaryAccessGrantObserver
:
:
TemporaryAccessGrantObserver
(
nsPermissionManager
*
aPM
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
)
:
mPM
(
aPM
)
mPrincipal
(
aPrincipal
)
mType
(
aType
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Enforcing
temporary
access
grant
lifetimes
can
only
be
done
in
"
"
the
parent
process
"
)
;
}
NS_IMPL_ISUPPORTS
(
TemporaryAccessGrantObserver
nsIObserver
)
void
TemporaryAccessGrantObserver
:
:
Create
(
nsPermissionManager
*
aPM
nsIPrincipal
*
aPrincipal
const
nsACString
&
aType
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
sObservers
)
{
sObservers
=
MakeUnique
<
ObserversTable
>
(
)
;
}
Unused
<
<
sObservers
-
>
LookupForAdd
(
MakePair
(
nsCOMPtr
<
nsIPrincipal
>
(
aPrincipal
)
nsCString
(
aType
)
)
)
.
OrInsert
(
[
&
]
(
)
-
>
nsITimer
*
{
nsCOMPtr
<
nsITimer
>
timer
;
RefPtr
<
TemporaryAccessGrantObserver
>
observer
=
new
TemporaryAccessGrantObserver
(
aPM
aPrincipal
aType
)
;
nsresult
rv
=
NS_NewTimerWithObserver
(
getter_AddRefs
(
timer
)
observer
24
*
60
*
60
*
1000
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
observer
-
>
SetTimer
(
timer
)
;
return
timer
;
}
timer
-
>
Cancel
(
)
;
return
nullptr
;
}
)
;
}
void
TemporaryAccessGrantObserver
:
:
SetTimer
(
nsITimer
*
aTimer
)
{
mTimer
=
aTimer
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
}
}
NS_IMETHODIMP
TemporaryAccessGrantObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
NS_TIMER_CALLBACK_TOPIC
)
=
=
0
)
{
Unused
<
<
mPM
-
>
RemoveFromPrincipal
(
mPrincipal
mType
)
;
MOZ_ASSERT
(
sObservers
)
;
sObservers
-
>
Remove
(
MakePair
(
mPrincipal
mType
)
)
;
}
else
if
(
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
sObservers
.
reset
(
)
;
}
return
NS_OK
;
}
