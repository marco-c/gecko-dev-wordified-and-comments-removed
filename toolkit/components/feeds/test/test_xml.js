"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
function
FeedListener
(
testcase
)
{
this
.
testcase
=
testcase
;
}
FeedListener
.
prototype
=
{
handleResult
(
result
)
{
var
feed
=
result
.
doc
;
try
{
info
(
"
Testing
feed
"
+
this
.
testcase
.
file
.
path
)
;
Assert
.
ok
(
isIID
(
feed
Ci
.
nsIFeed
)
"
Has
feed
interface
"
)
;
if
(
!
eval
(
this
.
testcase
.
expect
)
)
{
Assert
.
ok
(
false
"
expect
failed
for
"
+
this
.
testcase
.
desc
)
;
}
else
{
Assert
.
ok
(
true
"
expect
passed
for
"
+
this
.
testcase
.
desc
)
;
}
}
catch
(
e
)
{
Assert
.
ok
(
false
"
expect
failed
for
"
+
this
.
testcase
.
desc
+
"
-
-
-
-
"
+
e
.
message
)
;
}
run_next_test
(
)
;
}
}
;
function
createTest
(
data
)
{
return
function
(
)
{
var
uri
;
if
(
data
.
base
=
=
null
)
{
uri
=
NetUtil
.
newURI
(
"
http
:
/
/
example
.
org
/
"
+
data
.
path
)
;
}
else
{
uri
=
data
.
base
;
}
info
(
"
Testing
"
+
data
.
file
.
leafName
)
;
var
parser
=
Cc
[
"
mozilla
.
org
/
feed
-
processor
;
1
"
]
.
createInstance
(
Ci
.
nsIFeedProcessor
)
;
var
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
data
.
file
0x01
parseInt
(
"
0444
"
8
)
0
)
;
var
bStream
=
Cc
[
"
mozilla
.
org
/
network
/
buffered
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIBufferedInputStream
)
;
bStream
.
init
(
stream
4096
)
;
parser
.
listener
=
new
FeedListener
(
data
)
;
try
{
let
channel
=
Cc
[
"
mozilla
.
org
/
network
/
input
-
stream
-
channel
;
1
"
]
.
createInstance
(
Ci
.
nsIInputStreamChannel
)
;
channel
.
setURI
(
uri
)
;
channel
.
contentStream
=
bStream
;
channel
.
QueryInterface
(
Ci
.
nsIChannel
)
;
channel
.
contentType
=
"
text
/
xml
"
;
parser
.
parseAsync
(
null
uri
)
;
parser
.
onStartRequest
(
channel
uri
)
;
let
pos
=
0
;
let
count
=
bStream
.
available
(
)
;
while
(
count
>
0
)
{
parser
.
onDataAvailable
(
channel
null
bStream
pos
count
)
;
pos
+
=
count
;
count
=
bStream
.
available
(
)
;
}
parser
.
onStopRequest
(
channel
null
Cr
.
NS_OK
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
"
parse
failed
for
"
+
data
.
file
.
leafName
+
"
-
-
-
-
"
+
e
.
message
)
;
run_next_test
(
)
;
}
finally
{
bStream
.
close
(
)
;
}
}
;
}
function
run_test
(
)
{
var
topDir
=
Services
.
dirsvc
.
get
(
"
CurWorkD
"
Ci
.
nsIFile
)
;
topDir
.
append
(
"
xml
"
)
;
iterateDir
(
topDir
true
file
=
>
{
var
data
=
readTestData
(
file
)
;
add_test
(
createTest
(
data
)
)
;
}
)
;
run_next_test
(
)
;
}
