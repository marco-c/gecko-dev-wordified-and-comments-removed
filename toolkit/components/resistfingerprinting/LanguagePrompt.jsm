"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
LanguagePrompt
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
kPrefResistFingerprinting
=
"
privacy
.
resistFingerprinting
"
;
const
kPrefSpoofEnglish
=
"
privacy
.
spoof_english
"
;
const
kTopicHttpOnModifyRequest
=
"
http
-
on
-
modify
-
request
"
;
class
_LanguagePrompt
{
constructor
(
)
{
this
.
_initialized
=
false
;
}
init
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
Services
.
prefs
.
addObserver
(
kPrefResistFingerprinting
this
)
;
this
.
_handleResistFingerprintingChanged
(
)
;
}
uninit
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
false
;
Services
.
prefs
.
removeObserver
(
kPrefResistFingerprinting
this
)
;
this
.
_removeObservers
(
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
nsPref
:
changed
"
:
this
.
_handlePrefChanged
(
data
)
;
break
;
case
kTopicHttpOnModifyRequest
:
this
.
_handleHttpOnModifyRequest
(
subject
data
)
;
break
;
default
:
break
;
}
}
_removeObservers
(
)
{
try
{
Services
.
pref
.
removeObserver
(
kPrefSpoofEnglish
this
)
;
}
catch
(
e
)
{
}
try
{
Services
.
obs
.
removeObserver
(
this
kTopicHttpOnModifyRequest
)
;
}
catch
(
e
)
{
}
}
_shouldPromptForLanguagePref
(
)
{
return
(
Services
.
locale
.
getAppLocaleAsLangTag
(
)
.
substr
(
0
2
)
!
=
=
"
en
"
)
&
&
(
Services
.
prefs
.
getIntPref
(
kPrefSpoofEnglish
)
=
=
=
0
)
;
}
_handlePrefChanged
(
data
)
{
switch
(
data
)
{
case
kPrefResistFingerprinting
:
this
.
_handleResistFingerprintingChanged
(
)
;
break
;
case
kPrefSpoofEnglish
:
this
.
_handleSpoofEnglishChanged
(
)
;
break
;
default
:
break
;
}
}
_handleResistFingerprintingChanged
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
kPrefResistFingerprinting
)
)
{
Services
.
prefs
.
addObserver
(
kPrefSpoofEnglish
this
)
;
if
(
this
.
_shouldPromptForLanguagePref
(
)
)
{
Services
.
obs
.
addObserver
(
this
kTopicHttpOnModifyRequest
)
;
}
}
else
{
this
.
_removeObservers
(
)
;
}
}
_handleSpoofEnglishChanged
(
)
{
switch
(
Services
.
prefs
.
getIntPref
(
kPrefSpoofEnglish
)
)
{
case
0
:
case
1
:
if
(
Services
.
prefs
.
prefHasUserValue
(
"
javascript
.
use_us_english_locale
"
)
)
{
Services
.
prefs
.
clearUserPref
(
"
javascript
.
use_us_english_locale
"
)
;
}
break
;
case
2
:
Services
.
prefs
.
setCharPref
(
"
intl
.
accept_languages
"
"
en
-
US
en
"
)
;
Services
.
prefs
.
setBoolPref
(
"
javascript
.
use_us_english_locale
"
true
)
;
break
;
default
:
break
;
}
}
_handleHttpOnModifyRequest
(
subject
data
)
{
let
httpChannel
;
try
{
httpChannel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
}
catch
(
e
)
{
return
;
}
if
(
!
httpChannel
)
{
return
;
}
let
notificationCallbacks
=
httpChannel
.
notificationCallbacks
;
if
(
!
notificationCallbacks
)
{
return
;
}
let
loadContext
=
notificationCallbacks
.
getInterface
(
Ci
.
nsILoadContext
)
;
if
(
!
loadContext
|
|
!
loadContext
.
isContent
)
{
return
;
}
if
(
!
subject
.
URI
.
schemeIs
(
"
http
"
)
&
&
!
subject
.
URI
.
schemeIs
(
"
https
"
)
)
{
return
;
}
Services
.
obs
.
removeObserver
(
this
kTopicHttpOnModifyRequest
)
;
if
(
!
this
.
_shouldPromptForLanguagePref
(
)
)
{
return
;
}
this
.
_promptForLanguagePreference
(
)
;
let
val
=
this
.
_getCurrentAcceptLanguageValue
(
subject
.
URI
)
;
if
(
val
)
{
httpChannel
.
setRequestHeader
(
"
Accept
-
Language
"
val
false
)
;
}
}
_promptForLanguagePreference
(
)
{
let
flags
=
Services
.
prompt
.
STD_YES_NO_BUTTONS
;
let
brandBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
let
brandShortName
=
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
let
navigatorBundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
browser
.
properties
"
)
;
let
message
=
navigatorBundle
.
formatStringFromName
(
"
privacy
.
spoof_english
"
[
brandShortName
]
1
)
;
let
response
=
Services
.
prompt
.
confirmEx
(
null
"
"
message
flags
null
null
null
null
{
value
:
false
}
)
;
Services
.
prefs
.
setIntPref
(
kPrefSpoofEnglish
(
response
=
=
0
)
?
2
:
1
)
;
}
_getCurrentAcceptLanguageValue
(
uri
)
{
let
channel
=
Services
.
io
.
newChannelFromURI2
(
uri
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
Ci
.
nsIContentPolicy
.
TYPE_OTHER
)
;
let
httpChannel
;
try
{
httpChannel
=
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
}
catch
(
e
)
{
return
null
;
}
return
httpChannel
.
getRequestHeader
(
"
Accept
-
Language
"
)
;
}
}
let
LanguagePrompt
=
new
_LanguagePrompt
(
)
;
