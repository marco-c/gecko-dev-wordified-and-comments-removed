let
{
ForgetAboutSite
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ForgetAboutSite
.
sys
.
mjs
"
)
;
requestLongerTimeout
(
2
)
;
const
TEST_DOMAIN
=
"
https
:
/
/
example
.
com
"
;
const
TEST_DOMAIN_ANOTHER
=
"
https
:
/
/
example
.
org
"
;
const
TEST_DOMAIN_THIRD
=
"
https
:
/
/
example
.
net
"
;
const
TEST_PAGE
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
TEST_DOMAIN
)
+
"
testPage
.
html
"
;
const
TEST_DOMAIN_ANOTHER_PAGE
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
TEST_DOMAIN_ANOTHER
)
+
"
testPage
.
html
"
;
const
TEST_DOMAIN_THIRD_PAGE
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
TEST_DOMAIN_THIRD
)
+
"
testPage
.
html
"
;
async
function
getRandomKeyHexFromBrowser
(
browser
firstPartyDomain
thirdPartyDomain
)
{
let
key
=
browser
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
let
keyHex
=
key
.
map
(
bytes
=
>
bytes
.
toString
(
16
)
.
padStart
(
2
"
0
"
)
)
.
join
(
"
"
)
;
let
keyTop
=
await
SpecialPowers
.
spawn
(
browser
[
]
_
=
>
{
return
content
.
document
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
}
)
;
let
keyTopHex
=
keyTop
.
map
(
bytes
=
>
bytes
.
toString
(
16
)
.
padStart
(
2
"
0
"
)
)
.
join
(
"
"
)
;
is
(
keyTopHex
keyHex
"
The
fingerprinting
random
key
should
match
between
the
browser
element
and
the
top
-
level
document
.
"
)
;
let
keyAboutBlank
=
await
SpecialPowers
.
spawn
(
browser
[
]
async
_
=
>
{
let
ifr
=
content
.
document
.
createElement
(
"
iframe
"
)
;
let
loaded
=
new
content
.
Promise
(
resolve
=
>
{
ifr
.
onload
=
resolve
;
}
)
;
content
.
document
.
body
.
appendChild
(
ifr
)
;
ifr
.
src
=
"
about
:
blank
"
;
await
loaded
;
return
SpecialPowers
.
spawn
(
ifr
[
]
_
=
>
{
return
content
.
document
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
}
)
;
}
)
;
let
keyAboutBlankHex
=
keyAboutBlank
.
map
(
bytes
=
>
bytes
.
toString
(
16
)
.
padStart
(
2
"
0
"
)
)
.
join
(
"
"
)
;
is
(
keyAboutBlankHex
keyHex
"
The
fingerprinting
random
key
should
match
between
the
browser
element
and
the
about
:
blank
iframe
document
.
"
)
;
let
keyJavascriptURL
=
await
SpecialPowers
.
spawn
(
browser
[
]
async
_
=
>
{
let
ifr
=
content
.
document
.
getElementById
(
"
testFrame
"
)
;
return
ifr
.
contentDocument
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
}
)
;
let
keyJavascriptURLHex
=
keyJavascriptURL
.
map
(
bytes
=
>
bytes
.
toString
(
16
)
.
padStart
(
2
"
0
"
)
)
.
join
(
"
"
)
;
is
(
keyJavascriptURLHex
keyHex
"
The
fingerprinting
random
key
should
match
between
the
browser
element
and
the
javascript
URL
iframe
document
.
"
)
;
let
keyFirstPartyFrame
=
await
SpecialPowers
.
spawn
(
browser
[
firstPartyDomain
]
async
domain
=
>
{
let
ifr
=
content
.
document
.
createElement
(
"
iframe
"
)
;
let
loaded
=
new
content
.
Promise
(
resolve
=
>
{
ifr
.
onload
=
resolve
;
}
)
;
content
.
document
.
body
.
appendChild
(
ifr
)
;
ifr
.
src
=
domain
;
await
loaded
;
return
SpecialPowers
.
spawn
(
ifr
[
]
_
=
>
{
return
content
.
document
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
}
)
;
}
)
;
let
keyFirstPartyFrameHex
=
keyFirstPartyFrame
.
map
(
bytes
=
>
bytes
.
toString
(
16
)
.
padStart
(
2
"
0
"
)
)
.
join
(
"
"
)
;
is
(
keyFirstPartyFrameHex
keyHex
"
The
fingerprinting
random
key
should
match
between
the
browser
element
and
the
first
-
party
iframe
document
.
"
)
;
let
keyThirdPartyFrame
=
await
SpecialPowers
.
spawn
(
browser
[
thirdPartyDomain
]
async
domain
=
>
{
let
ifr
=
content
.
document
.
createElement
(
"
iframe
"
)
;
let
loaded
=
new
content
.
Promise
(
resolve
=
>
{
ifr
.
onload
=
resolve
;
}
)
;
content
.
document
.
body
.
appendChild
(
ifr
)
;
ifr
.
src
=
domain
;
await
loaded
;
return
SpecialPowers
.
spawn
(
ifr
[
]
_
=
>
{
return
content
.
document
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
}
)
;
}
)
;
let
keyThirdPartyFrameHex
=
keyThirdPartyFrame
.
map
(
bytes
=
>
bytes
.
toString
(
16
)
.
padStart
(
2
"
0
"
)
)
.
join
(
"
"
)
;
is
(
keyThirdPartyFrameHex
keyHex
"
The
fingerprinting
random
key
should
match
between
the
browser
element
and
the
third
-
party
iframe
document
.
"
)
;
return
keyHex
;
}
add_task
(
async
function
test_randomization_disabled_with_rfp_disabled
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
false
]
[
"
privacy
.
resistFingerprinting
.
pbmode
"
false
]
[
"
privacy
.
fingerprintingProtection
"
false
]
[
"
privacy
.
fingerprintingProtection
.
pbmode
"
false
]
]
}
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PAGE
)
;
try
{
let
key
=
tab
.
linkedBrowser
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
ok
(
false
Accessing
the
fingerprinting
randomization
key
should
throw
when
fingerprinting
resistance
is
disabled
.
{
key
}
)
;
}
catch
(
e
)
{
ok
(
true
"
It
should
throw
when
getting
the
key
when
fingerprinting
resistance
is
disabled
.
"
)
;
}
try
{
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
_
=
>
{
return
content
.
document
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
}
)
;
}
catch
(
e
)
{
ok
(
true
"
It
should
throw
when
getting
the
key
when
fingerprinting
resistance
is
disabled
.
"
)
;
}
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
test_generate_randomization_key
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
true
]
[
"
privacy
.
resistFingerprinting
.
principalCheckEnabled
"
false
]
]
}
)
;
for
(
let
testPrivateWin
of
[
true
false
]
)
{
let
win
=
window
;
if
(
testPrivateWin
)
{
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
}
let
tabOne
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
TEST_PAGE
)
;
let
keyHexOne
;
try
{
keyHexOne
=
await
getRandomKeyHexFromBrowser
(
tabOne
.
linkedBrowser
TEST_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
ok
(
true
The
fingerprinting
random
key
:
{
keyHexOne
}
)
;
}
catch
(
e
)
{
ok
(
false
"
Shouldn
'
t
fail
when
getting
the
random
key
from
the
cookieJarSettings
"
)
;
}
let
tabTwo
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
TEST_PAGE
)
;
try
{
let
keyHexTwo
=
await
getRandomKeyHexFromBrowser
(
tabTwo
.
linkedBrowser
TEST_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
is
(
keyHexTwo
keyHexOne
The
key
should
remain
the
same
after
reopening
the
tab
.
)
;
}
catch
(
e
)
{
ok
(
false
"
Shouldn
'
t
fail
when
getting
the
random
key
from
the
cookieJarSettings
"
)
;
}
let
tabAnother
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
TEST_DOMAIN_ANOTHER_PAGE
)
;
try
{
let
keyHexAnother
=
await
getRandomKeyHexFromBrowser
(
tabAnother
.
linkedBrowser
TEST_DOMAIN_ANOTHER_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
isnot
(
keyHexAnother
keyHexOne
The
key
should
be
different
when
loading
a
different
domain
)
;
}
catch
(
e
)
{
ok
(
false
"
Shouldn
'
t
fail
when
getting
the
random
key
from
the
cookieJarSettings
"
)
;
}
BrowserTestUtils
.
removeTab
(
tabOne
)
;
BrowserTestUtils
.
removeTab
(
tabTwo
)
;
BrowserTestUtils
.
removeTab
(
tabAnother
)
;
if
(
testPrivateWin
)
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
}
}
)
;
add_task
(
async
function
test_reset_key_after_pbm_session_ends
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
true
]
[
"
privacy
.
resistFingerprinting
.
principalCheckEnabled
"
false
]
]
}
)
;
let
privateWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
privateWin
.
gBrowser
TEST_PAGE
)
;
let
keyHex
=
await
getRandomKeyHexFromBrowser
(
tab
.
linkedBrowser
TEST_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
let
promisePBExit
=
TestUtils
.
topicObserved
(
"
last
-
pb
-
context
-
exited
"
)
;
await
BrowserTestUtils
.
closeWindow
(
privateWin
)
;
await
promisePBExit
;
privateWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
privateWin
.
gBrowser
TEST_PAGE
)
;
let
keyHexNew
=
await
getRandomKeyHexFromBrowser
(
tab
.
linkedBrowser
TEST_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
isnot
(
keyHexNew
keyHex
"
Ensure
the
new
key
is
different
from
the
old
one
.
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
BrowserTestUtils
.
closeWindow
(
privateWin
)
;
}
)
;
add_task
(
async
function
test_randomization_with_exempted_normal_window
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
false
]
[
"
privacy
.
resistFingerprinting
.
pbmode
"
true
]
[
"
privacy
.
fingerprintingProtection
"
false
]
[
"
privacy
.
fingerprintingProtection
.
pbmode
"
false
]
[
"
privacy
.
resistFingerprinting
.
principalCheckEnabled
"
false
]
]
}
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PAGE
)
;
try
{
let
key
=
tab
.
linkedBrowser
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
ok
(
false
Accessing
the
fingerprinting
randomization
key
should
throw
when
fingerprinting
resistance
is
exempted
in
normal
windows
.
{
key
}
)
;
}
catch
(
e
)
{
ok
(
true
"
It
should
throw
when
getting
the
key
when
fingerprinting
resistance
is
exempted
in
normal
windows
.
"
)
;
}
try
{
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
_
=
>
{
return
content
.
document
.
cookieJarSettings
.
fingerprintingRandomizationKey
;
}
)
;
}
catch
(
e
)
{
ok
(
true
"
It
should
throw
when
getting
the
key
when
fingerprinting
resistance
is
exempted
in
normal
windows
.
"
)
;
}
BrowserTestUtils
.
removeTab
(
tab
)
;
let
privateWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
private
:
true
}
)
;
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
privateWin
.
gBrowser
TEST_PAGE
)
;
await
getRandomKeyHexFromBrowser
(
tab
.
linkedBrowser
TEST_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
BrowserTestUtils
.
closeWindow
(
privateWin
)
;
}
)
;
add_task
(
async
function
test_reset_random_key_when_clear_site_data
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
privacy
.
resistFingerprinting
"
true
]
[
"
privacy
.
resistFingerprinting
.
principalCheckEnabled
"
false
]
]
}
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PAGE
)
;
let
keyHex
=
await
getRandomKeyHexFromBrowser
(
tab
.
linkedBrowser
TEST_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
let
anotherTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_DOMAIN_ANOTHER_PAGE
)
;
let
keyHexAnother
=
await
getRandomKeyHexFromBrowser
(
anotherTab
.
linkedBrowser
TEST_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
BrowserTestUtils
.
removeTab
(
anotherTab
)
;
await
ForgetAboutSite
.
removeDataFromBaseDomain
(
"
example
.
com
"
)
;
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_PAGE
)
;
let
keyHexNew
=
await
getRandomKeyHexFromBrowser
(
tab
.
linkedBrowser
TEST_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
anotherTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
TEST_DOMAIN_ANOTHER_PAGE
)
;
let
keyHexAnotherNew
=
await
getRandomKeyHexFromBrowser
(
anotherTab
.
linkedBrowser
TEST_PAGE
TEST_DOMAIN_THIRD_PAGE
)
;
isnot
(
keyHexNew
keyHex
"
Ensure
the
new
key
is
different
from
the
old
one
.
"
)
;
is
(
keyHexAnother
keyHexAnotherNew
"
Ensure
the
key
of
another
domain
isn
'
t
reset
.
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
BrowserTestUtils
.
removeTab
(
anotherTab
)
;
}
)
;
