#
include
"
nsRFPService
.
h
"
#
include
<
algorithm
>
#
include
<
cfloat
>
#
include
<
cinttypes
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
<
ctime
>
#
include
<
new
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
mozilla
/
ArrayIterator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HelperMacros
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
OriginAttributes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_javascript
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
XorShift128PlusRNG
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFlags
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTLiteralString
.
h
"
#
include
"
nsTPromiseFlatString
.
h
"
#
include
"
nsTStringRepr
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsICookieJarSettings
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIRandomGenerator
.
h
"
#
include
"
nsIUserIdleService
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nscore
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prtime
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
js
/
Date
.
h
"
using
namespace
mozilla
;
static
mozilla
:
:
LazyLogModule
gResistFingerprintingLog
(
"
nsResistFingerprinting
"
)
;
#
define
RESIST_FINGERPRINTING_PREF
"
privacy
.
resistFingerprinting
"
#
define
RESIST_FINGERPRINTING_PBMODE_PREF
"
privacy
.
resistFingerprinting
.
pbmode
"
#
define
RESIST_FINGERPRINTINGPROTECTION_PREF
"
privacy
.
fingerprintingProtection
"
#
define
RESIST_FINGERPRINTINGPROTECTION_PBMODE_PREF
\
"
privacy
.
fingerprintingProtection
.
pbmode
"
#
define
RESIST_FINGERPRINTINGPROTECTION_OVERRIDE_PREF
\
"
privacy
.
fingerprintingProtection
.
overrides
"
#
define
RFP_TIMER_UNCONDITIONAL_VALUE
20
#
define
PROFILE_INITIALIZED_TOPIC
"
profile
-
initial
-
state
"
#
define
LAST_PB_SESSION_EXITED_TOPIC
"
last
-
pb
-
context
-
exited
"
static
constexpr
uint32_t
kVideoFramesPerSec
=
30
;
static
constexpr
uint32_t
kVideoDroppedRatio
=
5
;
#
define
RFP_DEFAULT_SPOOFING_KEYBOARD_LANG
KeyboardLang
:
:
EN
#
define
RFP_DEFAULT_SPOOFING_KEYBOARD_REGION
KeyboardRegion
:
:
US
static
nsTArray
<
mozilla
:
:
RFPTarget
>
sFPPTargets
=
{
RFPTarget
:
:
IsAlwaysEnabledForPrecompute
RFPTarget
:
:
Unknown
}
;
NS_IMPL_ISUPPORTS
(
nsRFPService
nsIObserver
)
static
StaticRefPtr
<
nsRFPService
>
sRFPService
;
static
bool
sInitialized
=
false
;
static
nsTArray
<
mozilla
:
:
RFPTarget
>
sTargetOverrideAdditions
;
static
nsTArray
<
mozilla
:
:
RFPTarget
>
sTargetOverrideSubtractions
;
nsRFPService
*
nsRFPService
:
:
GetOrCreate
(
)
{
if
(
!
sInitialized
)
{
sRFPService
=
new
nsRFPService
(
)
;
nsresult
rv
=
sRFPService
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
sRFPService
=
nullptr
;
return
nullptr
;
}
ClearOnShutdown
(
&
sRFPService
)
;
sInitialized
=
true
;
}
return
sRFPService
;
}
static
const
char
*
gCallbackPrefs
[
]
=
{
RESIST_FINGERPRINTING_PREF
RESIST_FINGERPRINTING_PBMODE_PREF
RESIST_FINGERPRINTINGPROTECTION_PREF
RESIST_FINGERPRINTINGPROTECTION_PBMODE_PREF
RESIST_FINGERPRINTINGPROTECTION_OVERRIDE_PREF
nullptr
}
;
nsresult
nsRFPService
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE
(
obs
NS_ERROR_NOT_AVAILABLE
)
;
rv
=
obs
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
XRE_IsParentProcess
(
)
)
{
rv
=
obs
-
>
AddObserver
(
this
LAST_PB_SESSION_EXITED_TOPIC
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
obs
-
>
AddObserver
(
this
OBSERVER_TOPIC_IDLE_DAILY
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
if
defined
(
XP_WIN
)
rv
=
obs
-
>
AddObserver
(
this
PROFILE_INITIALIZED_TOPIC
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
endif
Preferences
:
:
RegisterCallbacks
(
nsRFPService
:
:
PrefChanged
gCallbackPrefs
this
)
;
const
char
*
tzValue
=
PR_GetEnv
(
"
TZ
"
)
;
if
(
tzValue
!
=
nullptr
)
{
mInitialTZValue
=
nsCString
(
tzValue
)
;
}
UpdateRFPPref
(
)
;
UpdateFPPOverrideList
(
)
;
return
rv
;
}
bool
nsRFPService
:
:
IsRFPEnabledFor
(
RFPTarget
aTarget
)
{
if
(
StaticPrefs
:
:
privacy_resistFingerprinting_DoNotUseDirectly
(
)
|
|
StaticPrefs
:
:
privacy_resistFingerprinting_pbmode_DoNotUseDirectly
(
)
)
{
return
true
;
}
if
(
StaticPrefs
:
:
privacy_fingerprintingProtection_DoNotUseDirectly
(
)
|
|
StaticPrefs
:
:
privacy_fingerprintingProtection_pbmode_DoNotUseDirectly
(
)
)
{
if
(
sTargetOverrideAdditions
.
Contains
(
aTarget
)
)
{
return
true
;
}
if
(
sTargetOverrideSubtractions
.
Contains
(
aTarget
)
)
{
return
false
;
}
if
(
sFPPTargets
.
Contains
(
aTarget
)
)
{
return
true
;
}
return
false
;
}
return
false
;
}
void
nsRFPService
:
:
UpdateRFPPref
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
resistFingerprinting
=
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
;
JS
:
:
SetReduceMicrosecondTimePrecisionCallback
(
nsRFPService
:
:
ReduceTimePrecisionAsUSecsWrapper
)
;
if
(
!
StaticPrefs
:
:
privacy_resistFingerprinting_testing_setTZtoUTC
(
)
)
{
return
;
}
if
(
resistFingerprinting
)
{
PR_SetEnv
(
"
TZ
=
UTC
"
)
;
}
else
if
(
sInitialized
)
{
if
(
!
mInitialTZValue
.
IsEmpty
(
)
)
{
nsAutoCString
tzValue
=
"
TZ
=
"
_ns
+
mInitialTZValue
;
static
char
*
tz
=
nullptr
;
if
(
tz
!
=
nullptr
)
{
free
(
tz
)
;
}
tz
=
ToNewCString
(
tzValue
mozilla
:
:
fallible
)
;
if
(
tz
!
=
nullptr
)
{
PR_SetEnv
(
tz
)
;
}
}
else
{
#
if
defined
(
XP_WIN
)
PR_SetEnv
(
"
TZ
=
"
)
;
#
else
PR_SetEnv
(
"
TZ
=
:
/
etc
/
localtime
"
)
;
#
endif
}
}
if
(
resistFingerprinting
|
|
sInitialized
)
{
#
if
defined
(
XP_WIN
)
_tzset
(
)
;
#
else
tzset
(
)
;
#
endif
nsJSUtils
:
:
ResetTimeZone
(
)
;
}
}
void
nsRFPService
:
:
UpdateFPPOverrideList
(
)
{
nsAutoString
targetOverrides
;
nsresult
rv
=
Preferences
:
:
GetString
(
RESIST_FINGERPRINTINGPROTECTION_OVERRIDE_PREF
targetOverrides
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
|
|
targetOverrides
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Warning
(
"
Could
not
map
any
values
"
)
)
;
return
;
}
sTargetOverrideAdditions
.
Clear
(
)
;
sTargetOverrideSubtractions
.
Clear
(
)
;
for
(
const
nsAString
&
each
:
targetOverrides
.
Split
(
'
'
)
)
{
Maybe
<
RFPTarget
>
mappedValue
=
nsRFPService
:
:
TextToRFPTarget
(
Substring
(
each
1
each
.
Length
(
)
-
1
)
)
;
if
(
mappedValue
.
isSome
(
)
)
{
if
(
each
[
0
]
=
=
'
+
'
)
{
sTargetOverrideAdditions
.
AppendElement
(
mappedValue
.
value
(
)
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Warning
(
"
Mapped
value
%
s
(
%
X
)
to
an
addition
now
we
have
%
zu
"
NS_ConvertUTF16toUTF8
(
each
)
.
get
(
)
unsigned
(
mappedValue
.
value
(
)
)
sTargetOverrideAdditions
.
Length
(
)
)
)
;
}
else
if
(
each
[
0
]
=
=
'
-
'
)
{
sTargetOverrideSubtractions
.
AppendElement
(
mappedValue
.
value
(
)
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Warning
(
"
Mapped
value
%
s
(
%
X
)
to
a
subtraction
now
we
have
%
zu
"
NS_ConvertUTF16toUTF8
(
each
)
.
get
(
)
unsigned
(
mappedValue
.
value
(
)
)
sTargetOverrideSubtractions
.
Length
(
)
)
)
;
}
else
{
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Warning
(
"
Mapped
value
%
s
(
%
X
)
to
an
RFPTarget
Enum
but
the
first
"
"
character
wasn
'
t
+
or
-
"
NS_ConvertUTF16toUTF8
(
each
)
.
get
(
)
unsigned
(
mappedValue
.
value
(
)
)
)
)
;
}
}
else
{
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Warning
(
"
Could
not
map
the
value
%
s
to
an
RFPTarget
Enum
"
NS_ConvertUTF16toUTF8
(
each
)
.
get
(
)
)
)
;
}
}
}
Maybe
<
RFPTarget
>
nsRFPService
:
:
TextToRFPTarget
(
const
nsAString
&
aText
)
{
#
define
ITEM_VALUE
(
name
value
)
\
if
(
aText
.
EqualsLiteral
(
#
name
)
)
{
\
return
Some
(
RFPTarget
:
:
name
)
;
\
}
#
include
"
RFPTargets
.
inc
"
#
undef
ITEM_VALUE
return
Nothing
(
)
;
}
void
nsRFPService
:
:
StartShutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
if
(
XRE_IsParentProcess
(
)
)
{
obs
-
>
RemoveObserver
(
this
LAST_PB_SESSION_EXITED_TOPIC
)
;
obs
-
>
RemoveObserver
(
this
OBSERVER_TOPIC_IDLE_DAILY
)
;
}
}
Preferences
:
:
UnregisterCallbacks
(
nsRFPService
:
:
PrefChanged
gCallbackPrefs
this
)
;
}
void
nsRFPService
:
:
PrefChanged
(
const
char
*
aPref
void
*
aSelf
)
{
static_cast
<
nsRFPService
*
>
(
aSelf
)
-
>
PrefChanged
(
aPref
)
;
}
void
nsRFPService
:
:
PrefChanged
(
const
char
*
aPref
)
{
nsDependentCString
pref
(
aPref
)
;
if
(
pref
.
EqualsLiteral
(
RESIST_FINGERPRINTINGPROTECTION_OVERRIDE_PREF
)
)
{
UpdateFPPOverrideList
(
)
;
}
else
{
UpdateRFPPref
(
)
;
#
if
defined
(
XP_WIN
)
if
(
StaticPrefs
:
:
privacy_resistFingerprinting_testing_setTZtoUTC
(
)
&
&
!
XRE_IsE10sParentProcess
(
)
)
{
_tzset
(
)
;
}
#
endif
}
}
NS_IMETHODIMP
nsRFPService
:
:
Observe
(
nsISupports
*
aObject
const
char
*
aTopic
const
char16_t
*
aMessage
)
{
if
(
strcmp
(
NS_XPCOM_SHUTDOWN_OBSERVER_ID
aTopic
)
=
=
0
)
{
StartShutdown
(
)
;
}
#
if
defined
(
XP_WIN
)
else
if
(
!
strcmp
(
PROFILE_INITIALIZED_TOPIC
aTopic
)
)
{
if
(
XRE_IsParentProcess
(
)
&
&
!
XRE_IsE10sParentProcess
(
)
)
{
_tzset
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE
(
obs
NS_ERROR_NOT_AVAILABLE
)
;
nsresult
rv
=
obs
-
>
RemoveObserver
(
this
PROFILE_INITIALIZED_TOPIC
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
endif
if
(
strcmp
(
LAST_PB_SESSION_EXITED_TOPIC
aTopic
)
=
=
0
)
{
ClearSessionKey
(
true
)
;
}
if
(
!
strcmp
(
OBSERVER_TOPIC_IDLE_DAILY
aTopic
)
)
{
if
(
StaticPrefs
:
:
privacy_resistFingerprinting_randomization_daily_reset_enabled
(
)
)
{
ClearSessionKey
(
false
)
;
}
if
(
StaticPrefs
:
:
privacy_resistFingerprinting_randomization_daily_reset_private_enabled
(
)
)
{
ClearSessionKey
(
true
)
;
}
}
return
NS_OK
;
}
constexpr
double
RFP_TIME_ATOM_MS
=
16
.
667
;
double
nsRFPService
:
:
TimerResolution
(
RTPCallerType
aRTPCallerType
)
{
double
prefValue
=
StaticPrefs
:
:
privacy_resistFingerprinting_reduceTimerPrecision_microseconds
(
)
;
if
(
aRTPCallerType
=
=
RTPCallerType
:
:
ResistFingerprinting
)
{
return
std
:
:
max
(
RFP_TIME_ATOM_MS
*
1000
.
0
prefValue
)
;
}
return
prefValue
;
}
nsresult
nsRFPService
:
:
RandomMidpoint
(
long
long
aClampedTimeUSec
long
long
aResolutionUSec
int64_t
aContextMixin
long
long
*
aMidpointOut
uint8_t
*
aSecretSeed
)
{
nsresult
rv
;
const
int
kSeedSize
=
16
;
static
Atomic
<
uint8_t
*
>
sSecretMidpointSeed
;
if
(
MOZ_UNLIKELY
(
!
aMidpointOut
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
MOZ_UNLIKELY
(
!
sSecretMidpointSeed
)
)
{
nsCOMPtr
<
nsIRandomGenerator
>
randomGenerator
=
do_GetService
(
"
mozilla
.
org
/
security
/
random
-
generator
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uint8_t
*
temp
=
nullptr
;
rv
=
randomGenerator
-
>
GenerateRandomBytes
(
kSeedSize
&
temp
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
MOZ_UNLIKELY
(
!
sSecretMidpointSeed
.
compareExchange
(
nullptr
temp
)
)
)
{
delete
[
]
temp
;
}
}
uint8_t
*
seed
=
sSecretMidpointSeed
;
MOZ_RELEASE_ASSERT
(
seed
)
;
if
(
MOZ_UNLIKELY
(
aSecretSeed
!
=
nullptr
)
)
{
memcpy
(
seed
aSecretSeed
kSeedSize
)
;
}
non_crypto
:
:
XorShift128PlusRNG
rng
(
aContextMixin
^
*
(
uint64_t
*
)
(
seed
)
aClampedTimeUSec
^
*
(
uint64_t
*
)
(
seed
+
8
)
)
;
if
(
MOZ_UNLIKELY
(
aResolutionUSec
<
=
0
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aMidpointOut
=
rng
.
next
(
)
%
aResolutionUSec
;
return
NS_OK
;
}
double
nsRFPService
:
:
ReduceTimePrecisionImpl
(
double
aTime
TimeScale
aTimeScale
double
aResolutionUSec
int64_t
aContextMixin
TimerPrecisionType
aType
)
{
if
(
aType
=
=
TimerPrecisionType
:
:
DangerouslyNone
)
{
return
aTime
;
}
bool
unconditionalClamping
=
false
;
if
(
aType
=
=
UnconditionalAKAHighRes
|
|
aResolutionUSec
<
=
0
)
{
unconditionalClamping
=
true
;
aResolutionUSec
=
RFP_TIMER_UNCONDITIONAL_VALUE
;
aContextMixin
=
0
;
}
double
timeScaled
=
aTime
*
(
1000000
/
aTimeScale
)
;
long
long
timeAsInt
=
timeScaled
;
const
long
long
kFeb282008
=
1204233985000
;
if
(
aContextMixin
=
=
0
&
&
timeAsInt
<
kFeb282008
&
&
!
unconditionalClamping
&
&
aType
!
=
TimerPrecisionType
:
:
RFP
)
{
nsAutoCString
type
;
TypeToText
(
aType
type
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Error
(
"
About
to
assert
.
aTime
=
%
lli
<
%
lli
aContextMixin
=
%
"
PRId64
"
aType
=
%
s
"
timeAsInt
kFeb282008
aContextMixin
type
.
get
(
)
)
)
;
MOZ_ASSERT
(
false
"
ReduceTimePrecisionImpl
was
given
a
relative
time
"
"
with
an
empty
context
mix
-
in
(
or
your
clock
is
10
+
years
off
.
)
"
"
Run
this
with
MOZ_LOG
=
nsResistFingerprinting
:
1
to
get
more
details
.
"
)
;
}
long
long
resolutionAsInt
=
aResolutionUSec
;
long
long
clamped
=
floor
(
double
(
timeAsInt
)
/
resolutionAsInt
)
*
resolutionAsInt
;
long
long
midpoint
=
0
;
long
long
clampedAndJittered
=
clamped
;
if
(
!
unconditionalClamping
&
&
StaticPrefs
:
:
privacy_resistFingerprinting_reduceTimerPrecision_jitter
(
)
)
{
if
(
!
NS_FAILED
(
RandomMidpoint
(
clamped
resolutionAsInt
aContextMixin
&
midpoint
)
)
&
&
timeAsInt
>
=
clamped
+
midpoint
)
{
clampedAndJittered
+
=
resolutionAsInt
;
}
}
double
ret
=
double
(
clampedAndJittered
)
/
(
1000000
.
0
/
double
(
aTimeScale
)
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Verbose
(
"
Given
:
(
%
.
*
f
Scaled
:
%
.
*
f
Converted
:
%
lli
)
Rounding
%
s
with
(
%
lli
"
"
Originally
%
.
*
f
)
"
"
Intermediate
:
(
%
lli
)
Clamped
:
(
%
lli
)
Jitter
:
(
%
i
Context
:
%
"
PRId64
"
Midpoint
:
%
lli
)
"
"
Final
:
(
%
lli
Converted
:
%
.
*
f
)
"
DBL_DIG
-
1
aTime
DBL_DIG
-
1
timeScaled
timeAsInt
(
unconditionalClamping
?
"
unconditionally
"
:
"
normally
"
)
resolutionAsInt
DBL_DIG
-
1
aResolutionUSec
(
long
long
)
floor
(
double
(
timeAsInt
)
/
resolutionAsInt
)
clamped
StaticPrefs
:
:
privacy_resistFingerprinting_reduceTimerPrecision_jitter
(
)
aContextMixin
midpoint
clampedAndJittered
DBL_DIG
-
1
ret
)
)
;
return
ret
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsUSecs
(
double
aTime
int64_t
aContextMixin
RTPCallerType
aRTPCallerType
)
{
const
auto
type
=
GetTimerPrecisionType
(
aRTPCallerType
)
;
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
MicroSeconds
TimerResolution
(
aRTPCallerType
)
aContextMixin
type
)
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsMSecs
(
double
aTime
int64_t
aContextMixin
RTPCallerType
aRTPCallerType
)
{
const
auto
type
=
GetTimerPrecisionType
(
aRTPCallerType
)
;
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
MilliSeconds
TimerResolution
(
aRTPCallerType
)
aContextMixin
type
)
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsMSecsRFPOnly
(
double
aTime
int64_t
aContextMixin
RTPCallerType
aRTPCallerType
)
{
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
MilliSeconds
TimerResolution
(
aRTPCallerType
)
aContextMixin
GetTimerPrecisionTypeRFPOnly
(
aRTPCallerType
)
)
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsSecs
(
double
aTime
int64_t
aContextMixin
RTPCallerType
aRTPCallerType
)
{
const
auto
type
=
GetTimerPrecisionType
(
aRTPCallerType
)
;
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
Seconds
TimerResolution
(
aRTPCallerType
)
aContextMixin
type
)
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsSecsRFPOnly
(
double
aTime
int64_t
aContextMixin
RTPCallerType
aRTPCallerType
)
{
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
Seconds
TimerResolution
(
aRTPCallerType
)
aContextMixin
GetTimerPrecisionTypeRFPOnly
(
aRTPCallerType
)
)
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsUSecsWrapper
(
double
aTime
bool
aShouldResistFingerprinting
JSContext
*
aCx
)
{
MOZ_ASSERT
(
aCx
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
MOZ_ASSERT
(
global
)
;
RTPCallerType
callerType
;
if
(
aShouldResistFingerprinting
)
{
callerType
=
RTPCallerType
:
:
ResistFingerprinting
;
}
else
if
(
global
-
>
CrossOriginIsolated
(
)
)
{
callerType
=
RTPCallerType
:
:
CrossOriginIsolated
;
}
else
{
callerType
=
RTPCallerType
:
:
Normal
;
}
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
MicroSeconds
TimerResolution
(
callerType
)
0
GetTimerPrecisionType
(
callerType
)
)
;
}
TimerPrecisionType
nsRFPService
:
:
GetTimerPrecisionType
(
RTPCallerType
aRTPCallerType
)
{
if
(
aRTPCallerType
=
=
RTPCallerType
:
:
SystemPrincipal
)
{
return
DangerouslyNone
;
}
if
(
aRTPCallerType
=
=
RTPCallerType
:
:
ResistFingerprinting
)
{
return
RFP
;
}
if
(
StaticPrefs
:
:
privacy_reduceTimerPrecision
(
)
&
&
aRTPCallerType
=
=
RTPCallerType
:
:
CrossOriginIsolated
)
{
return
UnconditionalAKAHighRes
;
}
if
(
StaticPrefs
:
:
privacy_reduceTimerPrecision
(
)
)
{
return
Normal
;
}
if
(
StaticPrefs
:
:
privacy_reduceTimerPrecision_unconditional
(
)
)
{
return
UnconditionalAKAHighRes
;
}
return
DangerouslyNone
;
}
TimerPrecisionType
nsRFPService
:
:
GetTimerPrecisionTypeRFPOnly
(
RTPCallerType
aRTPCallerType
)
{
if
(
aRTPCallerType
=
=
RTPCallerType
:
:
ResistFingerprinting
)
{
return
RFP
;
}
if
(
StaticPrefs
:
:
privacy_reduceTimerPrecision_unconditional
(
)
&
&
aRTPCallerType
!
=
RTPCallerType
:
:
SystemPrincipal
)
{
return
UnconditionalAKAHighRes
;
}
return
DangerouslyNone
;
}
void
nsRFPService
:
:
TypeToText
(
TimerPrecisionType
aType
nsACString
&
aText
)
{
switch
(
aType
)
{
case
TimerPrecisionType
:
:
DangerouslyNone
:
aText
.
AssignLiteral
(
"
DangerouslyNone
"
)
;
return
;
case
TimerPrecisionType
:
:
Normal
:
aText
.
AssignLiteral
(
"
Normal
"
)
;
return
;
case
TimerPrecisionType
:
:
RFP
:
aText
.
AssignLiteral
(
"
RFP
"
)
;
return
;
case
TimerPrecisionType
:
:
UnconditionalAKAHighRes
:
aText
.
AssignLiteral
(
"
UnconditionalAKAHighRes
"
)
;
return
;
default
:
MOZ_ASSERT
(
false
"
Shouldn
'
t
go
here
"
)
;
aText
.
AssignLiteral
(
"
Unknown
Enum
Value
"
)
;
return
;
}
}
uint32_t
nsRFPService
:
:
CalculateTargetVideoResolution
(
uint32_t
aVideoQuality
)
{
return
aVideoQuality
*
NSToIntCeil
(
aVideoQuality
*
16
/
9
.
0
)
;
}
uint32_t
nsRFPService
:
:
GetSpoofedTotalFrames
(
double
aTime
)
{
double
precision
=
TimerResolution
(
RTPCallerType
:
:
ResistFingerprinting
)
/
1000
/
1000
;
double
time
=
floor
(
aTime
/
precision
)
*
precision
;
return
NSToIntFloor
(
time
*
kVideoFramesPerSec
)
;
}
uint32_t
nsRFPService
:
:
GetSpoofedDroppedFrames
(
double
aTime
uint32_t
aWidth
uint32_t
aHeight
)
{
uint32_t
targetRes
=
CalculateTargetVideoResolution
(
StaticPrefs
:
:
privacy_resistFingerprinting_target_video_res
(
)
)
;
if
(
targetRes
>
=
aWidth
*
aHeight
)
{
return
0
;
}
double
precision
=
TimerResolution
(
RTPCallerType
:
:
ResistFingerprinting
)
/
1000
/
1000
;
double
time
=
floor
(
aTime
/
precision
)
*
precision
;
uint32_t
boundedDroppedRatio
=
std
:
:
min
(
kVideoDroppedRatio
100U
)
;
return
NSToIntFloor
(
time
*
kVideoFramesPerSec
*
(
boundedDroppedRatio
/
100
.
0
)
)
;
}
uint32_t
nsRFPService
:
:
GetSpoofedPresentedFrames
(
double
aTime
uint32_t
aWidth
uint32_t
aHeight
)
{
uint32_t
targetRes
=
CalculateTargetVideoResolution
(
StaticPrefs
:
:
privacy_resistFingerprinting_target_video_res
(
)
)
;
if
(
targetRes
>
=
aWidth
*
aHeight
)
{
return
GetSpoofedTotalFrames
(
aTime
)
;
}
double
precision
=
TimerResolution
(
RTPCallerType
:
:
ResistFingerprinting
)
/
1000
/
1000
;
double
time
=
floor
(
aTime
/
precision
)
*
precision
;
uint32_t
boundedDroppedRatio
=
std
:
:
min
(
kVideoDroppedRatio
100U
)
;
return
NSToIntFloor
(
time
*
kVideoFramesPerSec
*
(
(
100
-
boundedDroppedRatio
)
/
100
.
0
)
)
;
}
static
const
char
*
GetSpoofedVersion
(
)
{
#
ifdef
ANDROID
return
"
102
.
0
"
;
#
else
return
MOZILLA_UAVERSION
;
#
endif
}
void
nsRFPService
:
:
GetSpoofedUserAgent
(
nsACString
&
userAgent
bool
isForHTTPHeader
)
{
size_t
preallocatedLength
=
13
+
(
isForHTTPHeader
?
mozilla
:
:
ArrayLength
(
SPOOFED_HTTP_UA_OS
)
:
mozilla
:
:
ArrayLength
(
SPOOFED_UA_OS
)
)
-
1
+
5
+
3
+
10
+
mozilla
:
:
ArrayLength
(
LEGACY_UA_GECKO_TRAIL
)
-
1
+
9
+
3
+
2
;
userAgent
.
SetCapacity
(
preallocatedLength
)
;
const
char
*
spoofedVersion
=
GetSpoofedVersion
(
)
;
userAgent
.
AssignLiteral
(
"
Mozilla
/
5
.
0
(
"
)
;
if
(
isForHTTPHeader
)
{
userAgent
.
AppendLiteral
(
SPOOFED_HTTP_UA_OS
)
;
}
else
{
userAgent
.
AppendLiteral
(
SPOOFED_UA_OS
)
;
}
userAgent
.
AppendLiteral
(
"
;
rv
:
"
)
;
userAgent
.
Append
(
spoofedVersion
)
;
userAgent
.
AppendLiteral
(
"
)
Gecko
/
"
)
;
#
if
defined
(
ANDROID
)
userAgent
.
Append
(
spoofedVersion
)
;
#
else
userAgent
.
AppendLiteral
(
LEGACY_UA_GECKO_TRAIL
)
;
#
endif
userAgent
.
AppendLiteral
(
"
Firefox
/
"
)
;
userAgent
.
Append
(
spoofedVersion
)
;
MOZ_ASSERT
(
userAgent
.
Length
(
)
<
=
preallocatedLength
)
;
}
nsTHashMap
<
KeyboardHashKey
const
SpoofingKeyboardCode
*
>
*
nsRFPService
:
:
sSpoofingKeyboardCodes
=
nullptr
;
KeyboardHashKey
:
:
KeyboardHashKey
(
const
KeyboardLangs
aLang
const
KeyboardRegions
aRegion
const
KeyNameIndexType
aKeyIdx
const
nsAString
&
aKey
)
:
mLang
(
aLang
)
mRegion
(
aRegion
)
mKeyIdx
(
aKeyIdx
)
mKey
(
aKey
)
{
}
KeyboardHashKey
:
:
KeyboardHashKey
(
KeyTypePointer
aOther
)
:
mLang
(
aOther
-
>
mLang
)
mRegion
(
aOther
-
>
mRegion
)
mKeyIdx
(
aOther
-
>
mKeyIdx
)
mKey
(
aOther
-
>
mKey
)
{
}
KeyboardHashKey
:
:
KeyboardHashKey
(
KeyboardHashKey
&
&
aOther
)
noexcept
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mLang
(
std
:
:
move
(
aOther
.
mLang
)
)
mRegion
(
std
:
:
move
(
aOther
.
mRegion
)
)
mKeyIdx
(
std
:
:
move
(
aOther
.
mKeyIdx
)
)
mKey
(
std
:
:
move
(
aOther
.
mKey
)
)
{
}
KeyboardHashKey
:
:
~
KeyboardHashKey
(
)
=
default
;
bool
KeyboardHashKey
:
:
KeyEquals
(
KeyTypePointer
aOther
)
const
{
return
mLang
=
=
aOther
-
>
mLang
&
&
mRegion
=
=
aOther
-
>
mRegion
&
&
mKeyIdx
=
=
aOther
-
>
mKeyIdx
&
&
mKey
=
=
aOther
-
>
mKey
;
}
KeyboardHashKey
:
:
KeyTypePointer
KeyboardHashKey
:
:
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
PLDHashNumber
KeyboardHashKey
:
:
HashKey
(
KeyTypePointer
aKey
)
{
PLDHashNumber
hash
=
mozilla
:
:
HashString
(
aKey
-
>
mKey
)
;
return
mozilla
:
:
AddToHash
(
hash
aKey
-
>
mRegion
aKey
-
>
mKeyIdx
aKey
-
>
mLang
)
;
}
void
nsRFPService
:
:
MaybeCreateSpoofingKeyCodes
(
const
KeyboardLangs
aLang
const
KeyboardRegions
aRegion
)
{
if
(
sSpoofingKeyboardCodes
=
=
nullptr
)
{
sSpoofingKeyboardCodes
=
new
nsTHashMap
<
KeyboardHashKey
const
SpoofingKeyboardCode
*
>
(
)
;
}
if
(
KeyboardLang
:
:
EN
=
=
aLang
)
{
switch
(
aRegion
)
{
case
KeyboardRegion
:
:
US
:
MaybeCreateSpoofingKeyCodesForEnUS
(
)
;
break
;
}
}
}
void
nsRFPService
:
:
MaybeCreateSpoofingKeyCodesForEnUS
(
)
{
MOZ_ASSERT
(
sSpoofingKeyboardCodes
)
;
static
bool
sInitialized
=
false
;
const
KeyboardLangs
lang
=
KeyboardLang
:
:
EN
;
const
KeyboardRegions
reg
=
KeyboardRegion
:
:
US
;
if
(
sInitialized
)
{
return
;
}
static
const
SpoofingKeyboardInfo
spoofingKeyboardInfoTable
[
]
=
{
#
define
KEY
(
key_
_codeNameIdx
_keyCode
_modifier
)
\
{
NS_LITERAL_STRING_FROM_CSTRING
(
key_
)
\
KEY_NAME_INDEX_USE_STRING
\
{
CODE_NAME_INDEX_
#
#
_codeNameIdx
_keyCode
_modifier
}
}
#
define
CONTROL
(
keyNameIdx_
_codeNameIdx
_keyCode
)
\
{
u
"
"
_ns
\
KEY_NAME_INDEX_
#
#
keyNameIdx_
\
{
CODE_NAME_INDEX_
#
#
_codeNameIdx
_keyCode
MODIFIER_NONE
}
}
#
include
"
KeyCodeConsensus_En_US
.
h
"
#
undef
CONTROL
#
undef
KEY
}
;
for
(
const
auto
&
keyboardInfo
:
spoofingKeyboardInfoTable
)
{
KeyboardHashKey
key
(
lang
reg
keyboardInfo
.
mKeyIdx
keyboardInfo
.
mKey
)
;
MOZ_ASSERT
(
!
sSpoofingKeyboardCodes
-
>
Contains
(
key
)
"
Double
-
defining
key
code
;
fix
your
KeyCodeConsensus
file
"
)
;
sSpoofingKeyboardCodes
-
>
InsertOrUpdate
(
key
&
keyboardInfo
.
mSpoofingCode
)
;
}
sInitialized
=
true
;
}
void
nsRFPService
:
:
GetKeyboardLangAndRegion
(
const
nsAString
&
aLanguage
KeyboardLangs
&
aLocale
KeyboardRegions
&
aRegion
)
{
nsAutoString
langStr
;
nsAutoString
regionStr
;
uint32_t
partNum
=
0
;
for
(
const
nsAString
&
part
:
aLanguage
.
Split
(
'
-
'
)
)
{
if
(
partNum
=
=
0
)
{
langStr
=
part
;
}
else
{
regionStr
=
part
;
break
;
}
partNum
+
+
;
}
if
(
langStr
.
EqualsLiteral
(
RFP_KEYBOARD_LANG_STRING_EN
)
)
{
aLocale
=
KeyboardLang
:
:
EN
;
aRegion
=
KeyboardRegion
:
:
US
;
if
(
regionStr
.
EqualsLiteral
(
RFP_KEYBOARD_REGION_STRING_US
)
)
{
aRegion
=
KeyboardRegion
:
:
US
;
}
}
else
{
aLocale
=
RFP_DEFAULT_SPOOFING_KEYBOARD_LANG
;
aRegion
=
RFP_DEFAULT_SPOOFING_KEYBOARD_REGION
;
}
}
bool
nsRFPService
:
:
GetSpoofedKeyCodeInfo
(
const
dom
:
:
Document
*
aDoc
const
WidgetKeyboardEvent
*
aKeyboardEvent
SpoofingKeyboardCode
&
aOut
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
KeyboardLangs
keyboardLang
=
RFP_DEFAULT_SPOOFING_KEYBOARD_LANG
;
KeyboardRegions
keyboardRegion
=
RFP_DEFAULT_SPOOFING_KEYBOARD_REGION
;
if
(
aDoc
!
=
nullptr
)
{
nsAutoString
language
;
aDoc
-
>
GetContentLanguage
(
language
)
;
if
(
language
.
IsEmpty
(
)
)
{
dom
:
:
Element
*
elm
=
aDoc
-
>
GetHtmlElement
(
)
;
if
(
elm
!
=
nullptr
)
{
elm
-
>
GetLang
(
language
)
;
}
}
if
(
!
language
.
IsEmpty
(
)
&
&
!
language
.
Contains
(
char16_t
(
'
'
)
)
)
{
language
.
StripWhitespace
(
)
;
GetKeyboardLangAndRegion
(
language
keyboardLang
keyboardRegion
)
;
}
}
MaybeCreateSpoofingKeyCodes
(
keyboardLang
keyboardRegion
)
;
KeyNameIndex
keyIdx
=
aKeyboardEvent
-
>
mKeyNameIndex
;
nsAutoString
keyName
;
if
(
keyIdx
=
=
KEY_NAME_INDEX_USE_STRING
)
{
keyName
=
aKeyboardEvent
-
>
mKeyValue
;
}
KeyboardHashKey
key
(
keyboardLang
keyboardRegion
keyIdx
keyName
)
;
const
SpoofingKeyboardCode
*
keyboardCode
=
sSpoofingKeyboardCodes
-
>
Get
(
key
)
;
if
(
keyboardCode
!
=
nullptr
)
{
aOut
=
*
keyboardCode
;
return
true
;
}
return
false
;
}
bool
nsRFPService
:
:
GetSpoofedModifierStates
(
const
dom
:
:
Document
*
aDoc
const
WidgetKeyboardEvent
*
aKeyboardEvent
const
Modifiers
aModifier
bool
&
aOut
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
if
(
aKeyboardEvent
-
>
mKeyNameIndex
!
=
KEY_NAME_INDEX_USE_STRING
)
{
return
false
;
}
if
(
(
aModifier
&
(
MODIFIER_ALT
|
MODIFIER_SHIFT
|
MODIFIER_ALTGRAPH
)
)
!
=
0
)
{
SpoofingKeyboardCode
keyCodeInfo
;
if
(
GetSpoofedKeyCodeInfo
(
aDoc
aKeyboardEvent
keyCodeInfo
)
)
{
aOut
=
(
(
keyCodeInfo
.
mModifierStates
&
aModifier
)
!
=
0
)
;
return
true
;
}
}
return
false
;
}
bool
nsRFPService
:
:
GetSpoofedCode
(
const
dom
:
:
Document
*
aDoc
const
WidgetKeyboardEvent
*
aKeyboardEvent
nsAString
&
aOut
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
SpoofingKeyboardCode
keyCodeInfo
;
if
(
!
GetSpoofedKeyCodeInfo
(
aDoc
aKeyboardEvent
keyCodeInfo
)
)
{
return
false
;
}
WidgetKeyboardEvent
:
:
GetDOMCodeName
(
keyCodeInfo
.
mCode
aOut
)
;
if
(
aKeyboardEvent
-
>
mLocation
=
=
dom
:
:
KeyboardEvent_Binding
:
:
DOM_KEY_LOCATION_RIGHT
&
&
StringEndsWith
(
aOut
u
"
Left
"
_ns
)
)
{
aOut
.
ReplaceLiteral
(
aOut
.
Length
(
)
-
4
4
u
"
Right
"
)
;
}
return
true
;
}
bool
nsRFPService
:
:
GetSpoofedKeyCode
(
const
dom
:
:
Document
*
aDoc
const
WidgetKeyboardEvent
*
aKeyboardEvent
uint32_t
&
aOut
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
SpoofingKeyboardCode
keyCodeInfo
;
if
(
GetSpoofedKeyCodeInfo
(
aDoc
aKeyboardEvent
keyCodeInfo
)
)
{
aOut
=
keyCodeInfo
.
mKeyCode
;
return
true
;
}
return
false
;
}
nsresult
nsRFPService
:
:
EnsureSessionKey
(
bool
aIsPrivate
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Info
(
"
Ensure
the
session
key
for
%
s
browsing
session
\
n
"
aIsPrivate
?
"
private
"
:
"
normal
"
)
)
;
if
(
!
StaticPrefs
:
:
privacy_resistFingerprinting_randomization_enabled
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
Maybe
<
nsID
>
&
sessionKey
=
aIsPrivate
?
mPrivateBrowsingSessionKey
:
mBrowsingSessionKey
;
if
(
sessionKey
)
{
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Info
(
"
The
%
s
session
key
exists
:
%
s
\
n
"
aIsPrivate
?
"
private
"
:
"
normal
"
sessionKey
.
ref
(
)
.
ToString
(
)
.
get
(
)
)
)
;
return
NS_OK
;
}
sessionKey
.
emplace
(
nsID
:
:
GenerateUUID
(
)
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Debug
(
"
Generated
%
s
session
key
:
%
s
\
n
"
aIsPrivate
?
"
private
"
:
"
normal
"
sessionKey
.
ref
(
)
.
ToString
(
)
.
get
(
)
)
)
;
return
NS_OK
;
}
void
nsRFPService
:
:
ClearSessionKey
(
bool
aIsPrivate
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
Maybe
<
nsID
>
&
sessionKey
=
aIsPrivate
?
mPrivateBrowsingSessionKey
:
mBrowsingSessionKey
;
sessionKey
.
reset
(
)
;
}
Maybe
<
nsTArray
<
uint8_t
>
>
nsRFPService
:
:
GenerateKey
(
nsIURI
*
aTopLevelURI
bool
aIsPrivate
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
aTopLevelURI
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Debug
(
"
Generating
%
s
randomization
key
for
top
-
level
URI
:
%
s
\
n
"
aIsPrivate
?
"
private
"
:
"
normal
"
aTopLevelURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
RefPtr
<
nsRFPService
>
service
=
GetOrCreate
(
)
;
if
(
NS_FAILED
(
service
-
>
EnsureSessionKey
(
aIsPrivate
)
)
)
{
return
Nothing
(
)
;
}
if
(
!
nsContentUtils
:
:
ShouldResistFingerprinting
(
"
Coarse
Efficiency
Check
"
)
|
|
(
!
aIsPrivate
&
&
StaticPrefs
:
:
privacy_resistFingerprinting_testGranularityMask
(
)
&
0x02
)
)
{
return
Nothing
(
)
;
}
const
nsID
&
sessionKey
=
aIsPrivate
?
service
-
>
mPrivateBrowsingSessionKey
.
ref
(
)
:
service
-
>
mBrowsingSessionKey
.
ref
(
)
;
auto
sessionKeyStr
=
sessionKey
.
ToString
(
)
;
OriginAttributes
attrs
;
attrs
.
SetPartitionKey
(
aTopLevelURI
)
;
HMAC
hmac
;
nsresult
rv
=
hmac
.
Begin
(
SEC_OID_SHA256
Span
(
reinterpret_cast
<
const
uint8_t
*
>
(
sessionKeyStr
.
get
(
)
)
NSID_LENGTH
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Nothing
(
)
;
}
NS_ConvertUTF16toUTF8
topLevelSite
(
attrs
.
mPartitionKey
)
;
rv
=
hmac
.
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
topLevelSite
.
get
(
)
)
topLevelSite
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Nothing
(
)
;
}
Maybe
<
nsTArray
<
uint8_t
>
>
key
;
key
.
emplace
(
)
;
rv
=
hmac
.
End
(
key
.
ref
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Nothing
(
)
;
}
return
key
;
}
nsresult
nsRFPService
:
:
GenerateCanvasKeyFromImageData
(
nsICookieJarSettings
*
aCookieJarSettings
uint8_t
*
aImageData
uint32_t
aSize
nsTArray
<
uint8_t
>
&
aCanvasKey
)
{
NS_ENSURE_ARG_POINTER
(
aCookieJarSettings
)
;
nsTArray
<
uint8_t
>
randomKey
;
nsresult
rv
=
aCookieJarSettings
-
>
GetFingerprintingRandomizationKey
(
randomKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
HMAC
hmac
;
rv
=
hmac
.
Begin
(
SEC_OID_SHA256
Span
(
randomKey
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hmac
.
Update
(
aImageData
aSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hmac
.
End
(
aCanvasKey
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsRFPService
:
:
RandomizePixels
(
nsICookieJarSettings
*
aCookieJarSettings
uint8_t
*
aData
uint32_t
aSize
gfx
:
:
SurfaceFormat
aSurfaceFormat
)
{
NS_ENSURE_ARG_POINTER
(
aData
)
;
if
(
!
aCookieJarSettings
)
{
return
NS_OK
;
}
if
(
aSize
=
=
0
)
{
return
NS_OK
;
}
nsTArray
<
uint8_t
>
canvasKey
;
nsresult
rv
=
GenerateCanvasKeyFromImageData
(
aCookieJarSettings
aData
aSize
canvasKey
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
pixelCnt
=
aSize
/
4
;
non_crypto
:
:
XorShift128PlusRNG
rng1
(
*
reinterpret_cast
<
uint64_t
*
>
(
canvasKey
.
Elements
(
)
)
*
reinterpret_cast
<
uint64_t
*
>
(
canvasKey
.
Elements
(
)
+
8
)
)
;
uint8_t
rnd3
=
canvasKey
.
LastElement
(
)
;
canvasKey
.
ReplaceElementAt
(
canvasKey
.
Length
(
)
-
1
0
)
;
non_crypto
:
:
XorShift128PlusRNG
rng2
(
*
reinterpret_cast
<
uint64_t
*
>
(
canvasKey
.
Elements
(
)
+
16
)
*
reinterpret_cast
<
uint64_t
*
>
(
canvasKey
.
Elements
(
)
+
24
)
)
;
uint8_t
numNoises
=
std
:
:
clamp
<
uint8_t
>
(
rnd3
15
255
)
;
for
(
uint8_t
i
=
0
;
i
<
=
numNoises
;
i
+
+
)
{
uint32_t
channel
;
if
(
aSurfaceFormat
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
{
channel
=
rng1
.
next
(
)
%
3
;
}
else
if
(
aSurfaceFormat
=
=
gfx
:
:
SurfaceFormat
:
:
A8R8G8B8
)
{
channel
=
rng1
.
next
(
)
%
3
+
1
;
}
else
{
return
NS_ERROR_INVALID_ARG
;
}
uint32_t
idx
=
4
*
(
rng1
.
next
(
)
%
pixelCnt
)
+
channel
;
uint8_t
bit
=
rng2
.
next
(
)
;
aData
[
idx
]
=
aData
[
idx
]
^
(
bit
&
0x1
)
;
}
return
NS_OK
;
}
