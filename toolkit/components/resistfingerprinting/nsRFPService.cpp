#
include
"
nsRFPService
.
h
"
#
include
<
algorithm
>
#
include
<
time
.
h
>
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
prenv
.
h
"
#
include
"
js
/
Date
.
h
"
using
namespace
mozilla
;
using
namespace
std
;
#
define
RESIST_FINGERPRINTING_PREF
"
privacy
.
resistFingerprinting
"
#
define
RFP_SPOOFED_FRAMES_PER_SEC_PREF
"
privacy
.
resistFingerprinting
.
video_frames_per_sec
"
#
define
RFP_SPOOFED_DROPPED_RATIO_PREF
"
privacy
.
resistFingerprinting
.
video_dropped_ratio
"
#
define
RFP_TARGET_VIDEO_RES_PREF
"
privacy
.
resistFingerprinting
.
target_video_res
"
#
define
RFP_SPOOFED_FRAMES_PER_SEC_DEFAULT
30
#
define
RFP_SPOOFED_DROPPED_RATIO_DEFAULT
5
#
define
RFP_TARGET_VIDEO_RES_DEFAULT
480
#
define
PROFILE_INITIALIZED_TOPIC
"
profile
-
initial
-
state
"
NS_IMPL_ISUPPORTS
(
nsRFPService
nsIObserver
)
static
StaticRefPtr
<
nsRFPService
>
sRFPService
;
static
bool
sInitialized
=
false
;
Atomic
<
bool
ReleaseAcquire
>
nsRFPService
:
:
sPrivacyResistFingerprinting
;
static
uint32_t
kResolutionUSec
=
100000
;
static
uint32_t
sVideoFramesPerSec
;
static
uint32_t
sVideoDroppedRatio
;
static
uint32_t
sTargetVideoRes
;
nsRFPService
*
nsRFPService
:
:
GetOrCreate
(
)
{
if
(
!
sInitialized
)
{
sRFPService
=
new
nsRFPService
(
)
;
nsresult
rv
=
sRFPService
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
sRFPService
=
nullptr
;
return
nullptr
;
}
ClearOnShutdown
(
&
sRFPService
)
;
sInitialized
=
true
;
}
return
sRFPService
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsMSecs
(
double
aTime
)
{
if
(
!
IsResistFingerprintingEnabled
(
)
)
{
return
aTime
;
}
const
double
resolutionMSec
=
kResolutionUSec
/
1000
.
0
;
return
floor
(
aTime
/
resolutionMSec
)
*
resolutionMSec
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsUSecs
(
double
aTime
)
{
if
(
!
IsResistFingerprintingEnabled
(
)
)
{
return
aTime
;
}
return
floor
(
aTime
/
kResolutionUSec
)
*
kResolutionUSec
;
}
uint32_t
nsRFPService
:
:
CalculateTargetVideoResolution
(
uint32_t
aVideoQuality
)
{
return
aVideoQuality
*
NSToIntCeil
(
aVideoQuality
*
16
/
9
.
0
)
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsSecs
(
double
aTime
)
{
if
(
!
IsResistFingerprintingEnabled
(
)
)
{
return
aTime
;
}
if
(
kResolutionUSec
<
1000000
)
{
const
double
resolutionSecReciprocal
=
1000000
.
0
/
kResolutionUSec
;
return
floor
(
aTime
*
resolutionSecReciprocal
)
/
resolutionSecReciprocal
;
}
const
double
resolutionSec
=
kResolutionUSec
/
1000000
.
0
;
return
floor
(
aTime
/
resolutionSec
)
*
resolutionSec
;
}
uint32_t
nsRFPService
:
:
GetSpoofedTotalFrames
(
double
aTime
)
{
double
time
=
ReduceTimePrecisionAsSecs
(
aTime
)
;
return
NSToIntFloor
(
time
*
sVideoFramesPerSec
)
;
}
uint32_t
nsRFPService
:
:
GetSpoofedDroppedFrames
(
double
aTime
uint32_t
aWidth
uint32_t
aHeight
)
{
uint32_t
targetRes
=
CalculateTargetVideoResolution
(
sTargetVideoRes
)
;
if
(
targetRes
>
=
aWidth
*
aHeight
)
{
return
0
;
}
double
time
=
ReduceTimePrecisionAsSecs
(
aTime
)
;
uint32_t
boundedDroppedRatio
=
min
(
sVideoDroppedRatio
100u
)
;
return
NSToIntFloor
(
time
*
sVideoFramesPerSec
*
(
boundedDroppedRatio
/
100
.
0
)
)
;
}
uint32_t
nsRFPService
:
:
GetSpoofedPresentedFrames
(
double
aTime
uint32_t
aWidth
uint32_t
aHeight
)
{
uint32_t
targetRes
=
CalculateTargetVideoResolution
(
sTargetVideoRes
)
;
if
(
targetRes
>
=
aWidth
*
aHeight
)
{
return
GetSpoofedTotalFrames
(
aTime
)
;
}
double
time
=
ReduceTimePrecisionAsSecs
(
aTime
)
;
uint32_t
boundedDroppedRatio
=
min
(
sVideoDroppedRatio
100u
)
;
return
NSToIntFloor
(
time
*
sVideoFramesPerSec
*
(
(
100
-
boundedDroppedRatio
)
/
100
.
0
)
)
;
}
nsresult
nsRFPService
:
:
GetSpoofedUserAgent
(
nsACString
&
userAgent
)
{
nsresult
rv
;
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
appVersion
;
rv
=
appInfo
-
>
GetVersion
(
appVersion
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
firefoxVersion
=
appVersion
.
ToInteger
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIXULRuntime
>
runtime
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
updateChannel
;
rv
=
runtime
-
>
GetDefaultUpdateChannel
(
updateChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
updateChannel
.
EqualsLiteral
(
"
esr
"
)
)
{
MOZ_ASSERT
(
(
(
firefoxVersion
%
7
)
=
=
3
)
"
Please
udpate
ESR
version
formula
in
nsRFPService
.
cpp
"
)
;
}
uint32_t
spoofedVersion
=
firefoxVersion
-
(
(
firefoxVersion
-
3
)
%
7
)
;
userAgent
.
Assign
(
nsPrintfCString
(
"
Mozilla
/
5
.
0
(
%
s
;
rv
:
%
d
.
0
)
Gecko
/
%
s
Firefox
/
%
d
.
0
"
SPOOFED_UA_OS
spoofedVersion
LEGACY_BUILD_ID
spoofedVersion
)
)
;
return
rv
;
}
nsresult
nsRFPService
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE
(
obs
NS_ERROR_NOT_AVAILABLE
)
;
rv
=
obs
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
if
defined
(
XP_WIN
)
rv
=
obs
-
>
AddObserver
(
this
PROFILE_INITIALIZED_TOPIC
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
endif
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
prefs
NS_ERROR_NOT_AVAILABLE
)
;
rv
=
prefs
-
>
AddObserver
(
RESIST_FINGERPRINTING_PREF
this
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Preferences
:
:
AddUintVarCache
(
&
sVideoFramesPerSec
RFP_SPOOFED_FRAMES_PER_SEC_PREF
RFP_SPOOFED_FRAMES_PER_SEC_DEFAULT
)
;
Preferences
:
:
AddUintVarCache
(
&
sVideoDroppedRatio
RFP_SPOOFED_DROPPED_RATIO_PREF
RFP_SPOOFED_DROPPED_RATIO_DEFAULT
)
;
Preferences
:
:
AddUintVarCache
(
&
sTargetVideoRes
RFP_TARGET_VIDEO_RES_PREF
RFP_TARGET_VIDEO_RES_DEFAULT
)
;
const
char
*
tzValue
=
PR_GetEnv
(
"
TZ
"
)
;
if
(
tzValue
)
{
mInitialTZValue
=
nsCString
(
tzValue
)
;
}
UpdatePref
(
)
;
return
rv
;
}
void
nsRFPService
:
:
UpdatePref
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sPrivacyResistFingerprinting
=
Preferences
:
:
GetBool
(
RESIST_FINGERPRINTING_PREF
)
;
if
(
sPrivacyResistFingerprinting
)
{
PR_SetEnv
(
"
TZ
=
UTC
"
)
;
JS
:
:
SetTimeResolutionUsec
(
kResolutionUSec
)
;
}
else
if
(
sInitialized
)
{
JS
:
:
SetTimeResolutionUsec
(
0
)
;
if
(
!
mInitialTZValue
.
IsEmpty
(
)
)
{
nsAutoCString
tzValue
=
NS_LITERAL_CSTRING
(
"
TZ
=
"
)
+
mInitialTZValue
;
static
char
*
tz
=
nullptr
;
if
(
tz
)
{
free
(
tz
)
;
}
tz
=
ToNewCString
(
tzValue
)
;
if
(
tz
)
{
PR_SetEnv
(
tz
)
;
}
}
else
{
#
if
defined
(
XP_WIN
)
PR_SetEnv
(
"
TZ
=
"
)
;
#
else
PR_SetEnv
(
"
TZ
=
:
/
etc
/
localtime
"
)
;
#
endif
}
}
nsJSUtils
:
:
ResetTimeZone
(
)
;
}
void
nsRFPService
:
:
StartShutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
{
prefs
-
>
RemoveObserver
(
RESIST_FINGERPRINTING_PREF
this
)
;
}
}
}
NS_IMETHODIMP
nsRFPService
:
:
Observe
(
nsISupports
*
aObject
const
char
*
aTopic
const
char16_t
*
aMessage
)
{
if
(
!
strcmp
(
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
aTopic
)
)
{
NS_ConvertUTF16toUTF8
pref
(
aMessage
)
;
if
(
pref
.
EqualsLiteral
(
RESIST_FINGERPRINTING_PREF
)
)
{
UpdatePref
(
)
;
#
if
defined
(
XP_WIN
)
if
(
!
XRE_IsE10sParentProcess
(
)
)
{
_tzset
(
)
;
}
#
endif
}
}
if
(
!
strcmp
(
NS_XPCOM_SHUTDOWN_OBSERVER_ID
aTopic
)
)
{
StartShutdown
(
)
;
}
#
if
defined
(
XP_WIN
)
else
if
(
!
strcmp
(
PROFILE_INITIALIZED_TOPIC
aTopic
)
)
{
if
(
XRE_IsParentProcess
(
)
&
&
!
XRE_IsE10sParentProcess
(
)
)
{
_tzset
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE
(
obs
NS_ERROR_NOT_AVAILABLE
)
;
nsresult
rv
=
obs
-
>
RemoveObserver
(
this
PROFILE_INITIALIZED_TOPIC
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
endif
return
NS_OK
;
}
