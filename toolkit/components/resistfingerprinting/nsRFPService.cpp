#
include
"
nsRFPService
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
time
.
h
>
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIRandomGenerator
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nss
.
h
"
#
include
"
js
/
Date
.
h
"
using
namespace
mozilla
;
static
mozilla
:
:
LazyLogModule
gResistFingerprintingLog
(
"
nsResistFingerprinting
"
)
;
#
define
RESIST_FINGERPRINTING_PREF
"
privacy
.
resistFingerprinting
"
#
define
RFP_TIMER_PREF
"
privacy
.
reduceTimerPrecision
"
#
define
RFP_TIMER_UNCONDITIONAL_PREF
\
"
privacy
.
reduceTimerPrecision
.
unconditional
"
#
define
RFP_TIMER_UNCONDITIONAL_VALUE
20
#
define
RFP_TIMER_VALUE_PREF
\
"
privacy
.
resistFingerprinting
.
reduceTimerPrecision
.
microseconds
"
#
define
RFP_JITTER_VALUE_PREF
\
"
privacy
.
resistFingerprinting
.
reduceTimerPrecision
.
jitter
"
#
define
PROFILE_INITIALIZED_TOPIC
"
profile
-
initial
-
state
"
static
constexpr
uint32_t
kVideoFramesPerSec
=
30
;
static
constexpr
uint32_t
kVideoDroppedRatio
=
5
;
#
define
RFP_DEFAULT_SPOOFING_KEYBOARD_LANG
KeyboardLang
:
:
EN
#
define
RFP_DEFAULT_SPOOFING_KEYBOARD_REGION
KeyboardRegion
:
:
US
NS_IMPL_ISUPPORTS
(
nsRFPService
nsIObserver
)
static
StaticRefPtr
<
nsRFPService
>
sRFPService
;
static
bool
sInitialized
=
false
;
nsDataHashtable
<
KeyboardHashKey
const
SpoofingKeyboardCode
*
>
*
nsRFPService
:
:
sSpoofingKeyboardCodes
=
nullptr
;
static
mozilla
:
:
StaticMutex
sLock
;
nsRFPService
*
nsRFPService
:
:
GetOrCreate
(
)
{
if
(
!
sInitialized
)
{
sRFPService
=
new
nsRFPService
(
)
;
nsresult
rv
=
sRFPService
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
sRFPService
=
nullptr
;
return
nullptr
;
}
ClearOnShutdown
(
&
sRFPService
)
;
sInitialized
=
true
;
}
return
sRFPService
;
}
double
nsRFPService
:
:
TimerResolution
(
)
{
double
prefValue
=
StaticPrefs
:
:
privacy_resistFingerprinting_reduceTimerPrecision_microseconds
(
)
;
if
(
nsRFPService
:
:
IsResistFingerprintingEnabled
(
)
)
{
return
std
:
:
max
(
100000
.
0
prefValue
)
;
}
return
prefValue
;
}
bool
nsRFPService
:
:
IsResistFingerprintingEnabled
(
)
{
return
StaticPrefs
:
:
privacy_resistFingerprinting
(
)
;
}
bool
nsRFPService
:
:
IsTimerPrecisionReductionEnabled
(
TimerPrecisionType
aType
)
{
if
(
aType
=
=
TimerPrecisionType
:
:
RFPOnly
)
{
return
IsResistFingerprintingEnabled
(
)
;
}
return
(
StaticPrefs
:
:
privacy_reduceTimerPrecision
(
)
|
|
IsResistFingerprintingEnabled
(
)
)
&
&
TimerResolution
(
)
>
0
;
}
#
define
LRU_CACHE_SIZE
(
45
)
#
define
HASH_DIGEST_SIZE_BITS
(
256
)
#
define
HASH_DIGEST_SIZE_BYTES
(
HASH_DIGEST_SIZE_BITS
/
8
)
class
LRUCache
final
{
public
:
LRUCache
(
)
:
mLock
(
"
mozilla
.
resistFingerprinting
.
LRUCache
"
)
{
this
-
>
cache
.
SetLength
(
LRU_CACHE_SIZE
)
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
LRUCache
)
nsCString
Get
(
long
long
aKeyPart1
long
long
aKeyPart2
)
{
for
(
auto
&
cacheEntry
:
this
-
>
cache
)
{
if
(
cacheEntry
.
keyPart1
=
=
aKeyPart1
&
&
cacheEntry
.
keyPart2
=
=
aKeyPart2
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
MOZ_UNLIKELY
(
cacheEntry
.
keyPart1
!
=
aKeyPart1
|
|
cacheEntry
.
keyPart2
!
=
aKeyPart2
)
)
{
long
long
tmp_keyPart1
=
cacheEntry
.
keyPart1
;
long
long
tmp_keyPart2
=
cacheEntry
.
keyPart2
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Verbose
(
"
LRU
Cache
HIT
-
MISS
with
%
lli
!
=
%
lli
and
%
lli
!
=
%
lli
"
aKeyPart1
tmp_keyPart1
aKeyPart2
tmp_keyPart2
)
)
;
return
EmptyCString
(
)
;
}
cacheEntry
.
accessTime
=
PR_Now
(
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Verbose
(
"
LRU
Cache
HIT
with
%
lli
%
lli
"
aKeyPart1
aKeyPart2
)
)
;
return
cacheEntry
.
data
;
}
}
return
EmptyCString
(
)
;
}
void
Store
(
long
long
aKeyPart1
long
long
aKeyPart2
const
nsCString
&
aValue
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aValue
.
Length
(
)
=
=
HASH_DIGEST_SIZE_BYTES
)
;
MutexAutoLock
lock
(
mLock
)
;
CacheEntry
*
lowestKey
=
&
this
-
>
cache
[
0
]
;
for
(
auto
&
cacheEntry
:
this
-
>
cache
)
{
if
(
MOZ_UNLIKELY
(
cacheEntry
.
keyPart1
=
=
aKeyPart1
&
&
cacheEntry
.
keyPart2
=
=
aKeyPart2
)
)
{
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Verbose
(
"
LRU
Cache
DOUBLE
STORE
with
%
lli
%
lli
"
aKeyPart1
aKeyPart2
)
)
;
return
;
}
if
(
cacheEntry
.
accessTime
<
lowestKey
-
>
accessTime
)
{
lowestKey
=
&
cacheEntry
;
}
}
lowestKey
-
>
keyPart1
=
aKeyPart1
;
lowestKey
-
>
keyPart2
=
aKeyPart2
;
lowestKey
-
>
data
=
aValue
;
lowestKey
-
>
accessTime
=
PR_Now
(
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Verbose
(
"
LRU
Cache
STORE
with
%
lli
%
lli
"
aKeyPart1
aKeyPart2
)
)
;
}
private
:
~
LRUCache
(
)
=
default
;
struct
CacheEntry
{
Atomic
<
long
long
Relaxed
>
keyPart1
;
Atomic
<
long
long
Relaxed
>
keyPart2
;
PRTime
accessTime
=
0
;
nsCString
data
;
CacheEntry
(
)
{
this
-
>
keyPart1
=
0xFFFFFFFFFFFFFFFF
;
this
-
>
keyPart2
=
0xFFFFFFFFFFFFFFFF
;
this
-
>
accessTime
=
0
;
this
-
>
data
=
nullptr
;
}
CacheEntry
(
const
CacheEntry
&
obj
)
{
this
-
>
keyPart1
.
exchange
(
obj
.
keyPart1
)
;
this
-
>
keyPart2
.
exchange
(
obj
.
keyPart2
)
;
this
-
>
accessTime
=
obj
.
accessTime
;
this
-
>
data
=
obj
.
data
;
}
}
;
AutoTArray
<
CacheEntry
LRU_CACHE_SIZE
>
cache
;
mozilla
:
:
Mutex
mLock
;
}
;
static
StaticRefPtr
<
LRUCache
>
sCache
;
nsresult
nsRFPService
:
:
RandomMidpoint
(
long
long
aClampedTimeUSec
long
long
aResolutionUSec
int64_t
aContextMixin
long
long
*
aMidpointOut
uint8_t
*
aSecretSeed
)
{
nsresult
rv
;
const
int
kSeedSize
=
16
;
const
int
kClampTimesPerDigest
=
HASH_DIGEST_SIZE_BITS
/
32
;
static
uint8_t
*
sSecretMidpointSeed
=
nullptr
;
if
(
MOZ_UNLIKELY
(
!
aMidpointOut
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
LRUCache
>
cache
;
{
StaticMutexAutoLock
lock
(
sLock
)
;
cache
=
sCache
;
}
if
(
!
cache
)
{
return
NS_ERROR_FAILURE
;
}
long
long
reducedResolution
=
aResolutionUSec
*
kClampTimesPerDigest
;
long
long
extraClampedTime
=
(
aClampedTimeUSec
/
reducedResolution
)
*
reducedResolution
;
nsCString
hashResult
=
cache
-
>
Get
(
extraClampedTime
aContextMixin
)
;
if
(
hashResult
.
Length
(
)
!
=
HASH_DIGEST_SIZE_BYTES
)
{
if
(
aSecretSeed
!
=
nullptr
)
{
StaticMutexAutoLock
lock
(
sLock
)
;
delete
[
]
sSecretMidpointSeed
;
sSecretMidpointSeed
=
new
uint8_t
[
kSeedSize
]
;
memcpy
(
sSecretMidpointSeed
aSecretSeed
kSeedSize
)
;
}
if
(
MOZ_UNLIKELY
(
!
sSecretMidpointSeed
)
)
{
nsCOMPtr
<
nsIRandomGenerator
>
randomGenerator
=
do_GetService
(
"
mozilla
.
org
/
security
/
random
-
generator
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
StaticMutexAutoLock
lock
(
sLock
)
;
if
(
MOZ_LIKELY
(
!
sSecretMidpointSeed
)
)
{
rv
=
randomGenerator
-
>
GenerateRandomBytes
(
kSeedSize
&
sSecretMidpointSeed
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsCOMPtr
<
nsICryptoHash
>
hasher
=
do_CreateInstance
(
"
mozilla
.
org
/
security
/
hash
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hasher
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hasher
-
>
Update
(
sSecretMidpointSeed
kSeedSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hasher
-
>
Update
(
(
const
uint8_t
*
)
&
aContextMixin
sizeof
(
aContextMixin
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
hasher
-
>
Update
(
(
const
uint8_t
*
)
&
extraClampedTime
sizeof
(
extraClampedTime
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCStringN
<
HASH_DIGEST_SIZE_BYTES
>
derivedSecret
;
rv
=
hasher
-
>
Finish
(
false
derivedSecret
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
cache
-
>
Store
(
extraClampedTime
aContextMixin
derivedSecret
)
;
hashResult
=
derivedSecret
;
}
int
byteOffset
=
abs
(
(
(
aClampedTimeUSec
-
extraClampedTime
)
/
aResolutionUSec
)
*
4
)
;
if
(
MOZ_UNLIKELY
(
byteOffset
>
(
HASH_DIGEST_SIZE_BYTES
-
4
)
)
)
{
byteOffset
=
0
;
}
uint32_t
deterministiclyRandomValue
=
*
BitwiseCast
<
uint32_t
*
>
(
PromiseFlatCString
(
hashResult
)
.
get
(
)
+
byteOffset
)
;
deterministiclyRandomValue
%
=
aResolutionUSec
;
*
aMidpointOut
=
deterministiclyRandomValue
;
return
NS_OK
;
}
double
nsRFPService
:
:
ReduceTimePrecisionImpl
(
double
aTime
TimeScale
aTimeScale
double
aResolutionUSec
int64_t
aContextMixin
TimerPrecisionType
aType
)
{
bool
unconditionalClamping
=
false
;
if
(
!
IsTimerPrecisionReductionEnabled
(
aType
)
)
{
if
(
!
StaticPrefs
:
:
privacy_reduceTimerPrecision_unconditional
(
)
)
{
return
aTime
;
}
unconditionalClamping
=
true
;
aResolutionUSec
=
RFP_TIMER_UNCONDITIONAL_VALUE
;
aContextMixin
=
0
;
}
if
(
aResolutionUSec
<
=
0
)
{
return
aTime
;
}
double
timeScaled
=
aTime
*
(
1000000
/
aTimeScale
)
;
long
long
timeAsInt
=
timeScaled
;
const
long
long
kFeb282008
=
1204233985000
;
if
(
!
unconditionalClamping
&
&
aContextMixin
=
=
0
&
&
aType
=
=
TimerPrecisionType
:
:
All
&
&
timeAsInt
<
kFeb282008
)
{
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Error
(
"
About
to
assert
.
aTime
=
%
lli
<
%
lli
aContextMixin
=
%
"
PRId64
"
aType
=
%
s
"
timeAsInt
kFeb282008
aContextMixin
(
aType
=
=
TimerPrecisionType
:
:
RFPOnly
?
"
RFPOnly
"
:
"
All
"
)
)
)
;
MOZ_ASSERT
(
false
"
ReduceTimePrecisionImpl
was
given
a
relative
time
"
"
with
an
empty
context
mix
-
in
(
or
your
clock
is
10
+
years
off
.
)
"
"
Run
this
with
MOZ_LOG
=
nsResistFingerprinting
:
1
to
get
more
details
.
"
)
;
}
long
long
resolutionAsInt
=
aResolutionUSec
;
long
long
clamped
=
floor
(
double
(
timeAsInt
)
/
resolutionAsInt
)
*
resolutionAsInt
;
long
long
midpoint
=
0
;
long
long
clampedAndJittered
=
clamped
;
if
(
!
unconditionalClamping
&
&
StaticPrefs
:
:
privacy_resistFingerprinting_reduceTimerPrecision_jitter
(
)
)
{
if
(
!
NS_FAILED
(
RandomMidpoint
(
clamped
resolutionAsInt
aContextMixin
&
midpoint
)
)
&
&
timeAsInt
>
=
clamped
+
midpoint
)
{
clampedAndJittered
+
=
resolutionAsInt
;
}
}
double
ret
=
double
(
clampedAndJittered
)
/
(
1000000
.
0
/
aTimeScale
)
;
MOZ_LOG
(
gResistFingerprintingLog
LogLevel
:
:
Verbose
(
"
Given
:
(
%
.
*
f
Scaled
:
%
.
*
f
Converted
:
%
lli
)
Rounding
%
s
with
(
%
lli
"
"
Originally
%
.
*
f
)
"
"
Intermediate
:
(
%
lli
)
Clamped
:
(
%
lli
)
Jitter
:
(
%
i
Context
:
%
"
PRId64
"
Midpoint
:
%
lli
)
"
"
Final
:
(
%
lli
Converted
:
%
.
*
f
)
"
DBL_DIG
-
1
aTime
DBL_DIG
-
1
timeScaled
timeAsInt
(
unconditionalClamping
?
"
unconditionally
"
:
"
normally
"
)
resolutionAsInt
DBL_DIG
-
1
aResolutionUSec
(
long
long
)
floor
(
double
(
timeAsInt
)
/
resolutionAsInt
)
clamped
StaticPrefs
:
:
privacy_resistFingerprinting_reduceTimerPrecision_jitter
(
)
aContextMixin
midpoint
clampedAndJittered
DBL_DIG
-
1
ret
)
)
;
return
ret
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsUSecs
(
double
aTime
int64_t
aContextMixin
TimerPrecisionType
aType
)
{
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
MicroSeconds
TimerResolution
(
)
aContextMixin
aType
)
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsUSecsWrapper
(
double
aTime
)
{
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
MicroSeconds
TimerResolution
(
)
0
TimerPrecisionType
:
:
All
)
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsMSecs
(
double
aTime
int64_t
aContextMixin
TimerPrecisionType
aType
)
{
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
MilliSeconds
TimerResolution
(
)
aContextMixin
aType
)
;
}
double
nsRFPService
:
:
ReduceTimePrecisionAsSecs
(
double
aTime
int64_t
aContextMixin
TimerPrecisionType
aType
)
{
return
nsRFPService
:
:
ReduceTimePrecisionImpl
(
aTime
Seconds
TimerResolution
(
)
aContextMixin
aType
)
;
}
uint32_t
nsRFPService
:
:
CalculateTargetVideoResolution
(
uint32_t
aVideoQuality
)
{
return
aVideoQuality
*
NSToIntCeil
(
aVideoQuality
*
16
/
9
.
0
)
;
}
uint32_t
nsRFPService
:
:
GetSpoofedTotalFrames
(
double
aTime
)
{
double
precision
=
TimerResolution
(
)
/
1000
/
1000
;
double
time
=
floor
(
aTime
/
precision
)
*
precision
;
return
NSToIntFloor
(
time
*
kVideoFramesPerSec
)
;
}
uint32_t
nsRFPService
:
:
GetSpoofedDroppedFrames
(
double
aTime
uint32_t
aWidth
uint32_t
aHeight
)
{
uint32_t
targetRes
=
CalculateTargetVideoResolution
(
StaticPrefs
:
:
privacy_resistFingerprinting_target_video_res
(
)
)
;
if
(
targetRes
>
=
aWidth
*
aHeight
)
{
return
0
;
}
double
precision
=
TimerResolution
(
)
/
1000
/
1000
;
double
time
=
floor
(
aTime
/
precision
)
*
precision
;
uint32_t
boundedDroppedRatio
=
std
:
:
min
(
kVideoDroppedRatio
100U
)
;
return
NSToIntFloor
(
time
*
kVideoFramesPerSec
*
(
boundedDroppedRatio
/
100
.
0
)
)
;
}
uint32_t
nsRFPService
:
:
GetSpoofedPresentedFrames
(
double
aTime
uint32_t
aWidth
uint32_t
aHeight
)
{
uint32_t
targetRes
=
CalculateTargetVideoResolution
(
StaticPrefs
:
:
privacy_resistFingerprinting_target_video_res
(
)
)
;
if
(
targetRes
>
=
aWidth
*
aHeight
)
{
return
GetSpoofedTotalFrames
(
aTime
)
;
}
double
precision
=
TimerResolution
(
)
/
1000
/
1000
;
double
time
=
floor
(
aTime
/
precision
)
*
precision
;
uint32_t
boundedDroppedRatio
=
std
:
:
min
(
kVideoDroppedRatio
100U
)
;
return
NSToIntFloor
(
time
*
kVideoFramesPerSec
*
(
(
100
-
boundedDroppedRatio
)
/
100
.
0
)
)
;
}
static
uint32_t
GetSpoofedVersion
(
)
{
const
uint32_t
kKnownEsrVersion
=
60
;
nsresult
rv
;
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
kKnownEsrVersion
)
;
nsAutoCString
appVersion
;
rv
=
appInfo
-
>
GetVersion
(
appVersion
)
;
NS_ENSURE_SUCCESS
(
rv
kKnownEsrVersion
)
;
uint32_t
firefoxVersion
=
appVersion
.
ToInteger
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
kKnownEsrVersion
)
;
#
ifdef
DEBUG
if
(
!
strcmp
(
NS_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
"
esr
"
)
)
{
MOZ_ASSERT
(
(
(
firefoxVersion
%
8
)
=
=
4
)
"
Please
update
ESR
version
formula
in
nsRFPService
.
cpp
"
)
;
}
#
endif
return
firefoxVersion
-
(
(
firefoxVersion
-
4
)
%
8
)
;
}
void
nsRFPService
:
:
GetSpoofedUserAgent
(
nsACString
&
userAgent
bool
isForHTTPHeader
)
{
uint32_t
spoofedVersion
=
GetSpoofedVersion
(
)
;
const
char
*
spoofedOS
=
isForHTTPHeader
?
SPOOFED_HTTP_UA_OS
:
SPOOFED_UA_OS
;
userAgent
.
Assign
(
nsPrintfCString
(
"
Mozilla
/
5
.
0
(
%
s
;
rv
:
%
d
.
0
)
Gecko
/
%
s
Firefox
/
%
d
.
0
"
spoofedOS
spoofedVersion
LEGACY_UA_GECKO_TRAIL
spoofedVersion
)
)
;
}
static
const
char
*
gCallbackPrefs
[
]
=
{
RESIST_FINGERPRINTING_PREF
RFP_TIMER_PREF
RFP_TIMER_UNCONDITIONAL_PREF
RFP_TIMER_VALUE_PREF
RFP_JITTER_VALUE_PREF
nullptr
}
;
nsresult
nsRFPService
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE
(
obs
NS_ERROR_NOT_AVAILABLE
)
;
rv
=
obs
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
if
defined
(
XP_WIN
)
rv
=
obs
-
>
AddObserver
(
this
PROFILE_INITIALIZED_TOPIC
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
#
endif
Preferences
:
:
RegisterCallbacks
(
PREF_CHANGE_METHOD
(
nsRFPService
:
:
PrefChanged
)
gCallbackPrefs
this
)
;
const
char
*
tzValue
=
PR_GetEnv
(
"
TZ
"
)
;
if
(
tzValue
!
=
nullptr
)
{
mInitialTZValue
=
nsCString
(
tzValue
)
;
}
UpdateRFPPref
(
)
;
if
(
sCache
=
=
nullptr
)
{
sCache
=
new
LRUCache
(
)
;
}
return
rv
;
}
void
nsRFPService
:
:
UpdateTimers
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
StaticPrefs
:
:
privacy_resistFingerprinting
(
)
|
|
StaticPrefs
:
:
privacy_reduceTimerPrecision
(
)
)
{
JS
:
:
SetTimeResolutionUsec
(
TimerResolution
(
)
StaticPrefs
:
:
privacy_resistFingerprinting_reduceTimerPrecision_jitter
(
)
)
;
JS
:
:
SetReduceMicrosecondTimePrecisionCallback
(
nsRFPService
:
:
ReduceTimePrecisionAsUSecsWrapper
)
;
}
else
if
(
StaticPrefs
:
:
privacy_reduceTimerPrecision_unconditional
(
)
)
{
JS
:
:
SetTimeResolutionUsec
(
RFP_TIMER_UNCONDITIONAL_VALUE
false
)
;
JS
:
:
SetReduceMicrosecondTimePrecisionCallback
(
nsRFPService
:
:
ReduceTimePrecisionAsUSecsWrapper
)
;
}
else
if
(
sInitialized
)
{
JS
:
:
SetTimeResolutionUsec
(
0
false
)
;
}
}
void
nsRFPService
:
:
UpdateRFPPref
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
UpdateTimers
(
)
;
bool
privacyResistFingerprinting
=
StaticPrefs
:
:
privacy_resistFingerprinting
(
)
;
if
(
privacyResistFingerprinting
)
{
PR_SetEnv
(
"
TZ
=
UTC
"
)
;
}
else
if
(
sInitialized
)
{
if
(
!
mInitialTZValue
.
IsEmpty
(
)
)
{
nsAutoCString
tzValue
=
NS_LITERAL_CSTRING
(
"
TZ
=
"
)
+
mInitialTZValue
;
static
char
*
tz
=
nullptr
;
if
(
tz
!
=
nullptr
)
{
free
(
tz
)
;
}
tz
=
ToNewCString
(
tzValue
)
;
if
(
tz
!
=
nullptr
)
{
PR_SetEnv
(
tz
)
;
}
}
else
{
#
if
defined
(
XP_WIN
)
PR_SetEnv
(
"
TZ
=
"
)
;
#
else
PR_SetEnv
(
"
TZ
=
:
/
etc
/
localtime
"
)
;
#
endif
}
}
if
(
privacyResistFingerprinting
|
|
sInitialized
)
{
#
if
defined
(
XP_WIN
)
_tzset
(
)
;
#
else
tzset
(
)
;
#
endif
nsJSUtils
:
:
ResetTimeZone
(
)
;
}
}
void
nsRFPService
:
:
StartShutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
StaticMutexAutoLock
lock
(
sLock
)
;
{
sCache
=
nullptr
;
}
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
Preferences
:
:
UnregisterCallbacks
(
PREF_CHANGE_METHOD
(
nsRFPService
:
:
PrefChanged
)
gCallbackPrefs
this
)
;
}
void
nsRFPService
:
:
MaybeCreateSpoofingKeyCodes
(
const
KeyboardLangs
aLang
const
KeyboardRegions
aRegion
)
{
if
(
sSpoofingKeyboardCodes
=
=
nullptr
)
{
sSpoofingKeyboardCodes
=
new
nsDataHashtable
<
KeyboardHashKey
const
SpoofingKeyboardCode
*
>
(
)
;
}
if
(
KeyboardLang
:
:
EN
=
=
aLang
)
{
switch
(
aRegion
)
{
case
KeyboardRegion
:
:
US
:
MaybeCreateSpoofingKeyCodesForEnUS
(
)
;
break
;
}
}
}
void
nsRFPService
:
:
MaybeCreateSpoofingKeyCodesForEnUS
(
)
{
MOZ_ASSERT
(
sSpoofingKeyboardCodes
)
;
static
bool
sInitialized
=
false
;
const
KeyboardLangs
lang
=
KeyboardLang
:
:
EN
;
const
KeyboardRegions
reg
=
KeyboardRegion
:
:
US
;
if
(
sInitialized
)
{
return
;
}
static
const
SpoofingKeyboardInfo
spoofingKeyboardInfoTable
[
]
=
{
#
define
KEY
(
key_
_codeNameIdx
_keyCode
_modifier
)
\
{
KEY_NAME_INDEX_USE_STRING
\
NS_LITERAL_STRING
(
key_
)
\
{
CODE_NAME_INDEX_
#
#
_codeNameIdx
_keyCode
_modifier
}
}
#
define
CONTROL
(
keyNameIdx_
_codeNameIdx
_keyCode
)
\
{
KEY_NAME_INDEX_
#
#
keyNameIdx_
\
EmptyString
(
)
\
{
CODE_NAME_INDEX_
#
#
_codeNameIdx
_keyCode
MODIFIER_NONE
}
}
#
include
"
KeyCodeConsensus_En_US
.
h
"
#
undef
CONTROL
#
undef
KEY
}
;
for
(
const
auto
&
keyboardInfo
:
spoofingKeyboardInfoTable
)
{
KeyboardHashKey
key
(
lang
reg
keyboardInfo
.
mKeyIdx
keyboardInfo
.
mKey
)
;
MOZ_ASSERT
(
!
sSpoofingKeyboardCodes
-
>
Lookup
(
key
)
"
Double
-
defining
key
code
;
fix
your
KeyCodeConsensus
file
"
)
;
sSpoofingKeyboardCodes
-
>
Put
(
key
&
keyboardInfo
.
mSpoofingCode
)
;
}
sInitialized
=
true
;
}
void
nsRFPService
:
:
GetKeyboardLangAndRegion
(
const
nsAString
&
aLanguage
KeyboardLangs
&
aLocale
KeyboardRegions
&
aRegion
)
{
nsAutoString
langStr
;
nsAutoString
regionStr
;
uint32_t
partNum
=
0
;
for
(
const
nsAString
&
part
:
aLanguage
.
Split
(
'
-
'
)
)
{
if
(
partNum
=
=
0
)
{
langStr
=
part
;
}
else
{
regionStr
=
part
;
break
;
}
partNum
+
+
;
}
if
(
langStr
.
EqualsLiteral
(
RFP_KEYBOARD_LANG_STRING_EN
)
)
{
aLocale
=
KeyboardLang
:
:
EN
;
aRegion
=
KeyboardRegion
:
:
US
;
if
(
regionStr
.
EqualsLiteral
(
RFP_KEYBOARD_REGION_STRING_US
)
)
{
aRegion
=
KeyboardRegion
:
:
US
;
}
}
else
{
aLocale
=
RFP_DEFAULT_SPOOFING_KEYBOARD_LANG
;
aRegion
=
RFP_DEFAULT_SPOOFING_KEYBOARD_REGION
;
}
}
bool
nsRFPService
:
:
GetSpoofedKeyCodeInfo
(
const
dom
:
:
Document
*
aDoc
const
WidgetKeyboardEvent
*
aKeyboardEvent
SpoofingKeyboardCode
&
aOut
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
KeyboardLangs
keyboardLang
=
RFP_DEFAULT_SPOOFING_KEYBOARD_LANG
;
KeyboardRegions
keyboardRegion
=
RFP_DEFAULT_SPOOFING_KEYBOARD_REGION
;
if
(
aDoc
!
=
nullptr
)
{
nsAutoString
language
;
aDoc
-
>
GetContentLanguage
(
language
)
;
if
(
language
.
IsEmpty
(
)
)
{
dom
:
:
Element
*
elm
=
aDoc
-
>
GetHtmlElement
(
)
;
if
(
elm
!
=
nullptr
)
{
elm
-
>
GetLang
(
language
)
;
}
}
if
(
!
language
.
IsEmpty
(
)
&
&
!
language
.
Contains
(
char16_t
(
'
'
)
)
)
{
language
.
StripWhitespace
(
)
;
GetKeyboardLangAndRegion
(
language
keyboardLang
keyboardRegion
)
;
}
}
MaybeCreateSpoofingKeyCodes
(
keyboardLang
keyboardRegion
)
;
KeyNameIndex
keyIdx
=
aKeyboardEvent
-
>
mKeyNameIndex
;
nsAutoString
keyName
;
if
(
keyIdx
=
=
KEY_NAME_INDEX_USE_STRING
)
{
keyName
=
aKeyboardEvent
-
>
mKeyValue
;
}
KeyboardHashKey
key
(
keyboardLang
keyboardRegion
keyIdx
keyName
)
;
const
SpoofingKeyboardCode
*
keyboardCode
=
sSpoofingKeyboardCodes
-
>
Get
(
key
)
;
if
(
keyboardCode
!
=
nullptr
)
{
aOut
=
*
keyboardCode
;
return
true
;
}
return
false
;
}
bool
nsRFPService
:
:
GetSpoofedModifierStates
(
const
dom
:
:
Document
*
aDoc
const
WidgetKeyboardEvent
*
aKeyboardEvent
const
Modifiers
aModifier
bool
&
aOut
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
if
(
aKeyboardEvent
-
>
mKeyNameIndex
!
=
KEY_NAME_INDEX_USE_STRING
)
{
return
false
;
}
if
(
(
aModifier
&
(
MODIFIER_ALT
|
MODIFIER_SHIFT
|
MODIFIER_ALTGRAPH
)
)
!
=
0
)
{
SpoofingKeyboardCode
keyCodeInfo
;
if
(
GetSpoofedKeyCodeInfo
(
aDoc
aKeyboardEvent
keyCodeInfo
)
)
{
aOut
=
(
(
keyCodeInfo
.
mModifierStates
&
aModifier
)
!
=
0
)
;
return
true
;
}
}
return
false
;
}
bool
nsRFPService
:
:
GetSpoofedCode
(
const
dom
:
:
Document
*
aDoc
const
WidgetKeyboardEvent
*
aKeyboardEvent
nsAString
&
aOut
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
SpoofingKeyboardCode
keyCodeInfo
;
if
(
!
GetSpoofedKeyCodeInfo
(
aDoc
aKeyboardEvent
keyCodeInfo
)
)
{
return
false
;
}
WidgetKeyboardEvent
:
:
GetDOMCodeName
(
keyCodeInfo
.
mCode
aOut
)
;
if
(
aKeyboardEvent
-
>
mLocation
=
=
dom
:
:
KeyboardEvent_Binding
:
:
DOM_KEY_LOCATION_RIGHT
&
&
StringEndsWith
(
aOut
NS_LITERAL_STRING
(
"
Left
"
)
)
)
{
aOut
.
ReplaceLiteral
(
aOut
.
Length
(
)
-
4
4
u
"
Right
"
)
;
}
return
true
;
}
bool
nsRFPService
:
:
GetSpoofedKeyCode
(
const
dom
:
:
Document
*
aDoc
const
WidgetKeyboardEvent
*
aKeyboardEvent
uint32_t
&
aOut
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
SpoofingKeyboardCode
keyCodeInfo
;
if
(
GetSpoofedKeyCodeInfo
(
aDoc
aKeyboardEvent
keyCodeInfo
)
)
{
aOut
=
keyCodeInfo
.
mKeyCode
;
return
true
;
}
return
false
;
}
void
nsRFPService
:
:
PrefChanged
(
const
char
*
aPref
)
{
nsDependentCString
pref
(
aPref
)
;
if
(
pref
.
EqualsLiteral
(
RFP_TIMER_PREF
)
|
|
pref
.
EqualsLiteral
(
RFP_TIMER_UNCONDITIONAL_PREF
)
|
|
pref
.
EqualsLiteral
(
RFP_TIMER_VALUE_PREF
)
|
|
pref
.
EqualsLiteral
(
RFP_JITTER_VALUE_PREF
)
)
{
UpdateTimers
(
)
;
}
else
if
(
pref
.
EqualsLiteral
(
RESIST_FINGERPRINTING_PREF
)
)
{
UpdateRFPPref
(
)
;
#
if
defined
(
XP_WIN
)
if
(
!
XRE_IsE10sParentProcess
(
)
)
{
_tzset
(
)
;
}
#
endif
}
}
NS_IMETHODIMP
nsRFPService
:
:
Observe
(
nsISupports
*
aObject
const
char
*
aTopic
const
char16_t
*
aMessage
)
{
if
(
strcmp
(
NS_XPCOM_SHUTDOWN_OBSERVER_ID
aTopic
)
=
=
0
)
{
StartShutdown
(
)
;
}
#
if
defined
(
XP_WIN
)
else
if
(
!
strcmp
(
PROFILE_INITIALIZED_TOPIC
aTopic
)
)
{
if
(
XRE_IsParentProcess
(
)
&
&
!
XRE_IsE10sParentProcess
(
)
)
{
_tzset
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE
(
obs
NS_ERROR_NOT_AVAILABLE
)
;
nsresult
rv
=
obs
-
>
RemoveObserver
(
this
PROFILE_INITIALIZED_TOPIC
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
endif
return
NS_OK
;
}
