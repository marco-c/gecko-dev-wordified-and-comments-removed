"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ReaderMode
"
]
;
const
DOWNLOAD_SUCCESS
=
0
;
const
DOWNLOAD_ERROR_XHR
=
1
;
const
DOWNLOAD_ERROR_NO_DOC
=
2
;
const
PARSE_SUCCESS
=
0
;
const
PARSE_ERROR_TOO_MANY_ELEMENTS
=
1
;
const
PARSE_ERROR_WORKER
=
2
;
const
PARSE_ERROR_NO_ARTICLE
=
3
;
const
CLASSES_TO_PRESERVE
=
[
"
caption
"
"
emoji
"
"
hidden
"
"
invisible
"
"
sr
-
only
"
"
visually
-
hidden
"
"
visuallyhidden
"
"
wp
-
caption
"
"
wp
-
caption
-
text
"
"
wp
-
smiley
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
ReaderWorker
"
"
resource
:
/
/
gre
/
modules
/
reader
/
ReaderWorker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
LanguageDetector
"
"
resource
:
/
/
gre
/
modules
/
translation
/
LanguageDetector
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
Readerable
"
"
resource
:
/
/
gre
/
modules
/
Readerable
.
jsm
"
)
;
const
gIsFirefoxDesktop
=
Services
.
appinfo
.
ID
=
=
"
{
ec8030f7
-
c20a
-
464f
-
9b0e
-
13a3a9e97384
}
"
;
Services
.
telemetry
.
setEventRecordingEnabled
(
"
readermode
"
true
)
;
var
ReaderMode
=
{
DEBUG
:
0
enterTime
:
undefined
leaveTime
:
undefined
enterReaderMode
(
docShell
win
)
{
this
.
enterTime
=
Date
.
now
(
)
;
Services
.
telemetry
.
recordEvent
(
"
readermode
"
"
view
"
"
on
"
null
{
subcategory
:
"
feature
"
}
)
;
let
url
=
win
.
document
.
location
.
href
;
let
readerURL
=
"
about
:
reader
?
url
=
"
+
encodeURIComponent
(
url
)
;
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
let
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
sh
=
webNav
.
sessionHistory
;
if
(
webNav
.
canGoForward
)
{
let
forwardEntry
=
sh
.
legacySHistory
.
getEntryAtIndex
(
sh
.
index
+
1
)
;
let
forwardURL
=
forwardEntry
.
URI
.
spec
;
if
(
forwardURL
&
&
(
forwardURL
=
=
readerURL
|
|
!
readerURL
)
)
{
webNav
.
goForward
(
)
;
return
;
}
}
}
win
.
document
.
location
=
readerURL
;
}
leaveReaderMode
(
docShell
win
)
{
this
.
leaveTime
=
Date
.
now
(
)
;
let
timeSpentInReaderMode
=
Math
.
floor
(
(
this
.
leaveTime
-
this
.
enterTime
)
/
1000
)
;
let
scrollPosition
=
Math
.
floor
(
(
(
win
.
scrollY
+
win
.
innerHeight
)
/
win
.
document
.
body
.
clientHeight
)
*
100
)
;
Services
.
telemetry
.
recordEvent
(
"
readermode
"
"
view
"
"
off
"
null
{
subcategory
:
"
feature
"
reader_time
:
{
timeSpentInReaderMode
}
scroll_position
:
{
scrollPosition
}
}
)
;
let
url
=
win
.
document
.
location
.
href
;
let
originalURL
=
this
.
getOriginalUrl
(
url
)
;
let
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
if
(
!
Services
.
appinfo
.
sessionHistoryInParent
)
{
let
sh
=
webNav
.
sessionHistory
;
if
(
webNav
.
canGoBack
)
{
let
prevEntry
=
sh
.
legacySHistory
.
getEntryAtIndex
(
sh
.
index
-
1
)
;
let
prevURL
=
prevEntry
.
URI
.
spec
;
if
(
prevURL
&
&
(
prevURL
=
=
originalURL
|
|
!
originalURL
)
)
{
webNav
.
goBack
(
)
;
return
;
}
}
}
let
referrerURI
principal
;
try
{
referrerURI
=
Services
.
io
.
newURI
(
url
)
;
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
referrerURI
win
.
document
.
nodePrincipal
.
originAttributes
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
;
}
let
loadFlags
=
webNav
.
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
let
ReferrerInfo
=
Components
.
Constructor
(
"
mozilla
.
org
/
referrer
-
info
;
1
"
"
nsIReferrerInfo
"
"
init
"
)
;
let
loadURIOptions
=
{
triggeringPrincipal
:
principal
loadFlags
referrerInfo
:
new
ReferrerInfo
(
Ci
.
nsIReferrerInfo
.
EMPTY
true
referrerURI
)
}
;
webNav
.
loadURI
(
originalURL
loadURIOptions
)
;
}
getOriginalUrl
(
url
)
{
if
(
!
url
.
startsWith
(
"
about
:
reader
?
"
)
)
{
return
null
;
}
let
outerHash
=
"
"
;
try
{
let
uriObj
=
Services
.
io
.
newURI
(
url
)
;
url
=
uriObj
.
specIgnoringRef
;
outerHash
=
uriObj
.
ref
;
}
catch
(
ex
)
{
}
let
searchParams
=
new
URLSearchParams
(
url
.
substring
(
"
about
:
reader
?
"
.
length
)
)
;
if
(
!
searchParams
.
has
(
"
url
"
)
)
{
return
null
;
}
let
originalUrl
=
searchParams
.
get
(
"
url
"
)
;
if
(
outerHash
)
{
try
{
let
uriObj
=
Services
.
io
.
newURI
(
originalUrl
)
;
uriObj
=
Services
.
io
.
newURI
(
"
#
"
+
outerHash
null
uriObj
)
;
originalUrl
=
uriObj
.
spec
;
}
catch
(
ex
)
{
}
}
return
originalUrl
;
}
getOriginalUrlObjectForDisplay
(
url
)
{
let
originalUrl
=
this
.
getOriginalUrl
(
url
)
;
if
(
originalUrl
)
{
let
uriObj
;
try
{
uriObj
=
Services
.
uriFixup
.
getFixupURIInfo
(
originalUrl
)
.
preferredURI
;
}
catch
(
ex
)
{
return
null
;
}
try
{
return
Services
.
io
.
createExposableURI
(
uriObj
)
;
}
catch
(
ex
)
{
return
null
;
}
}
return
null
;
}
parseDocument
(
doc
)
{
if
(
!
lazy
.
Readerable
.
shouldCheckUri
(
doc
.
documentURIObject
)
|
|
!
lazy
.
Readerable
.
shouldCheckUri
(
doc
.
baseURIObject
true
)
)
{
this
.
log
(
"
Reader
mode
disabled
for
URI
"
)
;
return
null
;
}
return
this
.
_readerParse
(
doc
)
;
}
async
downloadAndParseDocument
(
url
docContentType
=
"
document
"
)
{
let
result
=
await
this
.
_downloadDocument
(
url
docContentType
)
;
if
(
!
result
?
.
doc
)
{
return
null
;
}
let
{
doc
newURL
}
=
result
;
if
(
!
lazy
.
Readerable
.
shouldCheckUri
(
doc
.
documentURIObject
)
|
|
!
lazy
.
Readerable
.
shouldCheckUri
(
doc
.
baseURIObject
true
)
)
{
this
.
log
(
"
Reader
mode
disabled
for
URI
"
)
;
return
null
;
}
let
article
=
await
this
.
_readerParse
(
doc
)
;
if
(
newURL
)
{
return
Promise
.
reject
(
{
newURL
article
}
)
;
}
return
article
;
}
_downloadDocument
(
url
docContentType
=
"
document
"
)
{
try
{
if
(
!
lazy
.
Readerable
.
shouldCheckUri
(
Services
.
io
.
newURI
(
url
)
)
)
{
return
null
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
new
Error
(
Couldn
'
t
create
URI
from
{
url
}
to
download
:
{
ex
}
)
)
;
return
null
;
}
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
READER_MODE_DOWNLOAD_RESULT
"
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
url
true
)
;
xhr
.
onerror
=
evt
=
>
reject
(
evt
.
error
)
;
xhr
.
responseType
=
docContentType
=
=
=
"
text
/
plain
"
?
"
text
"
:
"
document
"
;
xhr
.
onload
=
evt
=
>
{
if
(
xhr
.
status
!
=
=
200
)
{
reject
(
"
Reader
mode
XHR
failed
with
status
:
"
+
xhr
.
status
)
;
histogram
.
add
(
DOWNLOAD_ERROR_XHR
)
;
return
;
}
let
doc
=
xhr
.
responseType
=
=
=
"
text
"
?
xhr
.
responseText
:
xhr
.
responseXML
;
if
(
!
doc
)
{
reject
(
"
Reader
mode
XHR
didn
'
t
return
a
document
"
)
;
histogram
.
add
(
DOWNLOAD_ERROR_NO_DOC
)
;
return
;
}
let
responseURL
=
xhr
.
responseURL
;
let
givenURL
=
url
;
try
{
responseURL
=
Services
.
io
.
newURI
(
responseURL
)
.
specIgnoringRef
;
}
catch
(
ex
)
{
}
try
{
givenURL
=
Services
.
io
.
newURI
(
givenURL
)
.
specIgnoringRef
;
}
catch
(
ex
)
{
}
if
(
xhr
.
responseType
!
=
"
document
"
)
{
let
initialText
=
doc
;
let
parser
=
new
DOMParser
(
)
;
doc
=
parser
.
parseFromString
(
<
pre
>
<
/
pre
>
"
text
/
html
"
)
;
doc
.
querySelector
(
"
pre
"
)
.
textContent
=
initialText
;
}
histogram
.
add
(
DOWNLOAD_SUCCESS
)
;
let
result
=
{
doc
}
;
if
(
responseURL
!
=
givenURL
)
{
result
.
newURL
=
xhr
.
responseURL
;
}
resolve
(
result
)
;
}
;
xhr
.
send
(
)
;
}
)
;
}
log
(
msg
)
{
if
(
this
.
DEBUG
)
{
dump
(
"
Reader
:
"
+
msg
)
;
}
}
async
_readerParse
(
doc
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
READER_MODE_PARSE_RESULT
"
)
;
if
(
this
.
parseNodeLimit
)
{
let
numTags
=
doc
.
getElementsByTagName
(
"
*
"
)
.
length
;
if
(
numTags
>
this
.
parseNodeLimit
)
{
this
.
log
(
"
Aborting
parse
for
"
+
doc
.
baseURIObject
.
spec
+
"
;
"
+
numTags
+
"
elements
found
"
)
;
histogram
.
add
(
PARSE_ERROR_TOO_MANY_ELEMENTS
)
;
return
null
;
}
}
let
{
documentURI
}
=
doc
;
let
uriParam
;
uriParam
=
{
spec
:
doc
.
baseURIObject
.
spec
prePath
:
doc
.
baseURIObject
.
prePath
scheme
:
doc
.
baseURIObject
.
scheme
host
:
documentURI
pathBase
:
documentURI
}
;
try
{
uriParam
.
host
=
doc
.
baseURIObject
.
host
;
uriParam
.
pathBase
=
Services
.
io
.
newURI
(
"
.
"
null
doc
.
baseURIObject
)
.
spec
;
}
catch
(
ex
)
{
console
.
warn
(
"
Error
accessing
host
name
:
"
ex
)
;
}
if
(
this
.
_isDocumentPlainText
(
doc
)
)
{
doc
=
this
.
_convertPlainTextDocument
(
doc
)
;
}
let
serializer
=
new
XMLSerializer
(
)
;
let
serializedDoc
=
serializer
.
serializeToString
(
doc
)
;
doc
=
null
;
let
options
=
{
classesToPreserve
:
CLASSES_TO_PRESERVE
}
;
let
article
=
null
;
try
{
article
=
await
lazy
.
ReaderWorker
.
post
(
"
parseDocument
"
[
uriParam
serializedDoc
options
]
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
in
ReaderWorker
:
"
+
e
)
;
histogram
.
add
(
PARSE_ERROR_WORKER
)
;
}
if
(
!
article
)
{
this
.
log
(
"
Worker
did
not
return
an
article
"
)
;
histogram
.
add
(
PARSE_ERROR_NO_ARTICLE
)
;
return
null
;
}
article
.
url
=
documentURI
;
delete
article
.
uri
;
let
flags
=
Ci
.
nsIDocumentEncoder
.
OutputSelectionOnly
|
Ci
.
nsIDocumentEncoder
.
OutputAbsoluteLinks
;
article
.
title
=
Cc
[
"
mozilla
.
org
/
parserutils
;
1
"
]
.
getService
(
Ci
.
nsIParserUtils
)
.
convertToPlainText
(
article
.
title
flags
0
)
;
if
(
gIsFirefoxDesktop
)
{
await
this
.
_assignLanguage
(
article
)
;
this
.
_maybeAssignTextDirection
(
article
)
;
}
this
.
_assignReadTime
(
article
)
;
histogram
.
add
(
PARSE_SUCCESS
)
;
return
article
;
}
_assignLanguage
(
article
)
{
return
lazy
.
LanguageDetector
.
detectLanguage
(
article
.
textContent
)
.
then
(
result
=
>
{
article
.
language
=
result
.
confident
?
result
.
language
:
null
;
}
)
;
}
_maybeAssignTextDirection
(
article
)
{
if
(
!
article
.
dir
&
&
[
"
ar
"
"
fa
"
"
he
"
"
ug
"
"
ur
"
]
.
includes
(
article
.
language
)
)
{
article
.
dir
=
"
rtl
"
;
}
}
_assignReadTime
(
article
)
{
let
lang
=
article
.
language
|
|
"
en
"
;
const
readingSpeed
=
this
.
_getReadingSpeedForLanguage
(
lang
)
;
const
charactersPerMinuteLow
=
readingSpeed
.
cpm
-
readingSpeed
.
variance
;
const
charactersPerMinuteHigh
=
readingSpeed
.
cpm
+
readingSpeed
.
variance
;
const
length
=
article
.
length
;
article
.
readingTimeMinsSlow
=
Math
.
ceil
(
length
/
charactersPerMinuteLow
)
;
article
.
readingTimeMinsFast
=
Math
.
ceil
(
length
/
charactersPerMinuteHigh
)
;
}
_getReadingSpeedForLanguage
(
lang
)
{
const
readingSpeed
=
new
Map
(
[
[
"
en
"
{
cpm
:
987
variance
:
118
}
]
[
"
ar
"
{
cpm
:
612
variance
:
88
}
]
[
"
de
"
{
cpm
:
920
variance
:
86
}
]
[
"
es
"
{
cpm
:
1025
variance
:
127
}
]
[
"
fi
"
{
cpm
:
1078
variance
:
121
}
]
[
"
fr
"
{
cpm
:
998
variance
:
126
}
]
[
"
he
"
{
cpm
:
833
variance
:
130
}
]
[
"
it
"
{
cpm
:
950
variance
:
140
}
]
[
"
jw
"
{
cpm
:
357
variance
:
56
}
]
[
"
nl
"
{
cpm
:
978
variance
:
143
}
]
[
"
pl
"
{
cpm
:
916
variance
:
126
}
]
[
"
pt
"
{
cpm
:
913
variance
:
145
}
]
[
"
ru
"
{
cpm
:
986
variance
:
175
}
]
[
"
sk
"
{
cpm
:
885
variance
:
145
}
]
[
"
sv
"
{
cpm
:
917
variance
:
156
}
]
[
"
tr
"
{
cpm
:
1054
variance
:
156
}
]
[
"
zh
"
{
cpm
:
255
variance
:
29
}
]
]
)
;
return
readingSpeed
.
get
(
lang
)
|
|
readingSpeed
.
get
(
"
en
"
)
;
}
_isDocumentPlainText
(
doc
)
{
return
doc
.
contentType
=
=
"
text
/
plain
"
;
}
_convertPlainTextDocument
(
doc
)
{
let
preTag
=
doc
.
querySelector
(
"
pre
"
)
;
let
docFrag
=
doc
.
createDocumentFragment
(
)
;
let
content
=
preTag
.
textContent
;
let
paragraphs
=
content
.
split
(
/
\
r
?
\
n
\
r
?
\
n
/
)
;
for
(
let
para
of
paragraphs
)
{
let
pElem
=
doc
.
createElement
(
"
p
"
)
;
let
lines
=
para
.
split
(
/
\
n
/
)
;
for
(
let
line
of
lines
)
{
pElem
.
append
(
line
)
;
let
brElem
=
doc
.
createElement
(
"
br
"
)
;
pElem
.
append
(
brElem
)
;
}
docFrag
.
append
(
pElem
)
;
}
let
clone
=
doc
.
documentElement
.
cloneNode
(
true
)
;
clone
.
querySelector
(
"
pre
"
)
.
replaceWith
(
docFrag
)
;
return
clone
;
}
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
ReaderMode
"
maxElemsToParse
"
"
reader
.
parse
-
node
-
limit
"
0
)
;
