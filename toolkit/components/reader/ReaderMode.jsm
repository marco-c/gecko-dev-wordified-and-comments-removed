"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ReaderMode
"
]
;
const
DOWNLOAD_SUCCESS
=
0
;
const
DOWNLOAD_ERROR_XHR
=
1
;
const
DOWNLOAD_ERROR_NO_DOC
=
2
;
const
PARSE_SUCCESS
=
0
;
const
PARSE_ERROR_TOO_MANY_ELEMENTS
=
1
;
const
PARSE_ERROR_WORKER
=
2
;
const
PARSE_ERROR_NO_ARTICLE
=
3
;
const
CLASSES_TO_PRESERVE
=
[
"
caption
"
"
emoji
"
"
hidden
"
"
invisble
"
"
sr
-
only
"
"
visually
-
hidden
"
"
visuallyhidden
"
"
wp
-
caption
"
"
wp
-
caption
-
text
"
"
wp
-
smiley
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
XMLHttpRequest
"
"
XMLSerializer
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CommonUtils
"
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
EventDispatcher
"
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ReaderWorker
"
"
resource
:
/
/
gre
/
modules
/
reader
/
ReaderWorker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LanguageDetector
"
"
resource
:
/
/
/
modules
/
translation
/
LanguageDetector
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Readability
"
function
(
)
{
let
scope
=
{
}
;
scope
.
dump
=
this
.
dump
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
gre
/
modules
/
reader
/
Readability
.
js
"
scope
)
;
return
scope
.
Readability
;
}
)
;
const
gIsFirefoxDesktop
=
Services
.
appinfo
.
ID
=
=
"
{
ec8030f7
-
c20a
-
464f
-
9b0e
-
13a3a9e97384
}
"
;
var
ReaderMode
=
{
CACHE_VERSION
:
1
DEBUG
:
0
get
maxElemsToParse
(
)
{
delete
this
.
parseNodeLimit
;
Services
.
prefs
.
addObserver
(
"
reader
.
parse
-
node
-
limit
"
this
)
;
return
this
.
parseNodeLimit
=
Services
.
prefs
.
getIntPref
(
"
reader
.
parse
-
node
-
limit
"
)
;
}
get
isEnabledForParseOnLoad
(
)
{
delete
this
.
isEnabledForParseOnLoad
;
Services
.
prefs
.
addObserver
(
"
reader
.
parse
-
on
-
load
.
"
this
)
;
return
this
.
isEnabledForParseOnLoad
=
this
.
_getStateForParseOnLoad
(
)
;
}
_getStateForParseOnLoad
(
)
{
let
isEnabled
=
Services
.
prefs
.
getBoolPref
(
"
reader
.
parse
-
on
-
load
.
enabled
"
)
;
let
isForceEnabled
=
Services
.
prefs
.
getBoolPref
(
"
reader
.
parse
-
on
-
load
.
force
-
enabled
"
)
;
return
isForceEnabled
|
|
isEnabled
;
}
observe
(
aMessage
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
nsPref
:
changed
"
:
if
(
aData
.
startsWith
(
"
reader
.
parse
-
on
-
load
.
"
)
)
{
this
.
isEnabledForParseOnLoad
=
this
.
_getStateForParseOnLoad
(
)
;
}
else
if
(
aData
=
=
=
"
reader
.
parse
-
node
-
limit
"
)
{
this
.
parseNodeLimit
=
Services
.
prefs
.
getIntPref
(
aData
)
;
}
break
;
}
}
enterReaderMode
(
docShell
win
)
{
Services
.
telemetry
.
recordEvent
(
"
savant
"
"
readermode
"
"
on
"
null
{
subcategory
:
"
feature
"
}
)
;
let
url
=
win
.
document
.
location
.
href
;
let
readerURL
=
"
about
:
reader
?
url
=
"
+
encodeURIComponent
(
url
)
;
let
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
sh
=
webNav
.
sessionHistory
;
if
(
webNav
.
canGoForward
)
{
let
forwardEntry
=
sh
.
legacySHistory
.
getEntryAtIndex
(
sh
.
index
+
1
false
)
;
let
forwardURL
=
forwardEntry
.
URI
.
spec
;
if
(
forwardURL
&
&
(
forwardURL
=
=
readerURL
|
|
!
readerURL
)
)
{
webNav
.
goForward
(
)
;
return
;
}
}
win
.
document
.
location
=
readerURL
;
}
leaveReaderMode
(
docShell
win
)
{
Services
.
telemetry
.
recordEvent
(
"
savant
"
"
readermode
"
"
off
"
null
{
subcategory
:
"
feature
"
}
)
;
let
url
=
win
.
document
.
location
.
href
;
let
originalURL
=
this
.
getOriginalUrl
(
url
)
;
let
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
sh
=
webNav
.
sessionHistory
;
if
(
webNav
.
canGoBack
)
{
let
prevEntry
=
sh
.
legacySHistory
.
getEntryAtIndex
(
sh
.
index
-
1
false
)
;
let
prevURL
=
prevEntry
.
URI
.
spec
;
if
(
prevURL
&
&
(
prevURL
=
=
originalURL
|
|
!
originalURL
)
)
{
webNav
.
goBack
(
)
;
return
;
}
}
let
referrerURI
principal
;
try
{
referrerURI
=
Services
.
io
.
newURI
(
url
)
;
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
referrerURI
win
.
document
.
nodePrincipal
.
originAttributes
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
return
;
}
let
flags
=
webNav
.
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
|
webNav
.
LOAD_FLAGS_DISALLOW_INHERIT_OWNER
;
webNav
.
loadURI
(
originalURL
flags
referrerURI
null
null
principal
)
;
}
getOriginalUrl
(
url
)
{
if
(
!
url
.
startsWith
(
"
about
:
reader
?
"
)
)
{
return
null
;
}
let
outerHash
=
"
"
;
try
{
let
uriObj
=
Services
.
io
.
newURI
(
url
)
;
url
=
uriObj
.
specIgnoringRef
;
outerHash
=
uriObj
.
ref
;
}
catch
(
ex
)
{
}
let
searchParams
=
new
URLSearchParams
(
url
.
substring
(
"
about
:
reader
?
"
.
length
)
)
;
if
(
!
searchParams
.
has
(
"
url
"
)
)
{
return
null
;
}
let
originalUrl
=
searchParams
.
get
(
"
url
"
)
;
if
(
outerHash
)
{
try
{
let
uriObj
=
Services
.
io
.
newURI
(
originalUrl
)
;
uriObj
=
Services
.
io
.
newURI
(
"
#
"
+
outerHash
null
uriObj
)
;
originalUrl
=
uriObj
.
spec
;
}
catch
(
ex
)
{
}
}
return
originalUrl
;
}
getOriginalUrlObjectForDisplay
(
url
)
{
let
originalUrl
=
this
.
getOriginalUrl
(
url
)
;
if
(
originalUrl
)
{
let
uriObj
;
try
{
uriObj
=
Services
.
uriFixup
.
createFixupURI
(
originalUrl
Services
.
uriFixup
.
FIXUP_FLAG_NONE
)
;
}
catch
(
ex
)
{
return
null
;
}
try
{
return
Services
.
uriFixup
.
createExposableURI
(
uriObj
)
;
}
catch
(
ex
)
{
return
null
;
}
}
return
null
;
}
isProbablyReaderable
(
doc
)
{
if
(
doc
.
mozSyntheticDocument
|
|
!
(
doc
instanceof
doc
.
defaultView
.
HTMLDocument
)
)
{
return
false
;
}
let
uri
=
Services
.
io
.
newURI
(
doc
.
location
.
href
)
;
if
(
!
this
.
_shouldCheckUri
(
uri
)
)
{
return
false
;
}
let
utils
=
this
.
getUtilsForWin
(
doc
.
defaultView
)
;
return
new
Readability
(
doc
)
.
isProbablyReaderable
(
this
.
isNodeVisible
.
bind
(
this
utils
)
)
;
}
isNodeVisible
(
utils
node
)
{
let
bounds
=
utils
.
getBoundsWithoutFlushing
(
node
)
;
return
bounds
.
height
>
0
&
&
bounds
.
width
>
0
;
}
getUtilsForWin
(
win
)
{
return
win
.
windowUtils
;
}
parseDocument
(
doc
)
{
if
(
!
this
.
_shouldCheckUri
(
doc
.
documentURIObject
)
|
|
!
this
.
_shouldCheckUri
(
doc
.
baseURIObject
true
)
)
{
this
.
log
(
"
Reader
mode
disabled
for
URI
"
)
;
return
null
;
}
return
this
.
_readerParse
(
doc
)
;
}
async
downloadAndParseDocument
(
url
)
{
let
doc
=
await
this
.
_downloadDocument
(
url
)
;
if
(
!
doc
)
{
return
null
;
}
if
(
!
this
.
_shouldCheckUri
(
doc
.
documentURIObject
)
|
|
!
this
.
_shouldCheckUri
(
doc
.
baseURIObject
true
)
)
{
this
.
log
(
"
Reader
mode
disabled
for
URI
"
)
;
return
null
;
}
return
this
.
_readerParse
(
doc
)
;
}
_downloadDocument
(
url
)
{
try
{
if
(
!
this
.
_shouldCheckUri
(
Services
.
io
.
newURI
(
url
)
)
)
{
return
null
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
new
Error
(
Couldn
'
t
create
URI
from
{
url
}
to
download
:
{
ex
}
)
)
;
return
null
;
}
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
READER_MODE_DOWNLOAD_RESULT
"
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
url
true
)
;
xhr
.
onerror
=
evt
=
>
reject
(
evt
.
error
)
;
xhr
.
responseType
=
"
document
"
;
xhr
.
onload
=
evt
=
>
{
if
(
xhr
.
status
!
=
=
200
)
{
reject
(
"
Reader
mode
XHR
failed
with
status
:
"
+
xhr
.
status
)
;
histogram
.
add
(
DOWNLOAD_ERROR_XHR
)
;
return
;
}
let
doc
=
xhr
.
responseXML
;
if
(
!
doc
)
{
reject
(
"
Reader
mode
XHR
didn
'
t
return
a
document
"
)
;
histogram
.
add
(
DOWNLOAD_ERROR_NO_DOC
)
;
return
;
}
let
meta
=
doc
.
querySelector
(
"
meta
[
http
-
equiv
=
refresh
]
"
)
;
if
(
meta
)
{
let
content
=
meta
.
getAttribute
(
"
content
"
)
;
if
(
content
)
{
let
urlIndex
=
content
.
toUpperCase
(
)
.
indexOf
(
"
URL
=
"
)
;
if
(
urlIndex
>
-
1
)
{
let
baseURI
=
Services
.
io
.
newURI
(
url
)
;
let
newURI
=
Services
.
io
.
newURI
(
content
.
substring
(
urlIndex
+
4
)
null
baseURI
)
;
let
newURL
=
newURI
.
spec
;
let
ssm
=
Services
.
scriptSecurityManager
;
let
flags
=
ssm
.
LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT
|
ssm
.
DISALLOW_INHERIT_PRINCIPAL
;
try
{
ssm
.
checkLoadURIStrWithPrincipal
(
doc
.
nodePrincipal
newURL
flags
)
;
}
catch
(
ex
)
{
let
errorMsg
=
"
Reader
mode
disallowed
meta
refresh
(
reason
:
"
+
ex
+
"
)
.
"
;
if
(
Services
.
prefs
.
getBoolPref
(
"
reader
.
errors
.
includeURLs
"
)
)
errorMsg
+
=
"
Refresh
target
URI
:
'
"
+
newURL
+
"
'
.
"
;
reject
(
errorMsg
)
;
return
;
}
if
(
!
baseURI
.
equalsExceptRef
(
newURI
)
)
{
reject
(
{
newURL
}
)
;
return
;
}
}
}
}
let
responseURL
=
xhr
.
responseURL
;
let
givenURL
=
url
;
try
{
responseURL
=
Services
.
io
.
newURI
(
responseURL
)
.
specIgnoringRef
;
}
catch
(
ex
)
{
}
try
{
givenURL
=
Services
.
io
.
newURI
(
givenURL
)
.
specIgnoringRef
;
}
catch
(
ex
)
{
}
if
(
responseURL
!
=
givenURL
)
{
reject
(
{
newURL
:
xhr
.
responseURL
}
)
;
return
;
}
resolve
(
doc
)
;
histogram
.
add
(
DOWNLOAD_SUCCESS
)
;
}
;
xhr
.
send
(
)
;
}
)
;
}
async
getArticleFromCache
(
url
)
{
let
path
=
this
.
_toHashedPath
(
url
)
;
try
{
let
array
=
await
OS
.
File
.
read
(
path
)
;
return
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
array
)
)
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
OS
.
File
.
Error
)
|
|
!
e
.
becauseNoSuchFile
)
throw
e
;
return
null
;
}
}
async
storeArticleInCache
(
article
)
{
let
array
=
new
TextEncoder
(
)
.
encode
(
JSON
.
stringify
(
article
)
)
;
let
path
=
this
.
_toHashedPath
(
article
.
url
)
;
await
this
.
_ensureCacheDir
(
)
;
return
OS
.
File
.
writeAtomic
(
path
array
{
tmpPath
:
path
+
"
.
tmp
"
}
)
.
then
(
success
=
>
{
OS
.
File
.
stat
(
path
)
.
then
(
info
=
>
{
return
EventDispatcher
.
instance
.
sendRequest
(
{
type
:
"
Reader
:
AddedToCache
"
url
:
article
.
url
size
:
info
.
size
path
}
)
;
}
)
;
}
)
;
}
async
removeArticleFromCache
(
url
)
{
let
path
=
this
.
_toHashedPath
(
url
)
;
await
OS
.
File
.
remove
(
path
)
;
}
log
(
msg
)
{
if
(
this
.
DEBUG
)
dump
(
"
Reader
:
"
+
msg
)
;
}
_blockedHosts
:
[
"
amazon
.
com
"
"
github
.
com
"
"
mail
.
google
.
com
"
"
pinterest
.
com
"
"
reddit
.
com
"
"
twitter
.
com
"
"
youtube
.
com
"
]
_shouldCheckUri
(
uri
isBaseUri
=
false
)
{
if
(
!
(
uri
.
schemeIs
(
"
http
"
)
|
|
uri
.
schemeIs
(
"
https
"
)
)
)
{
this
.
log
(
"
Not
parsing
URI
scheme
:
"
+
uri
.
scheme
)
;
return
false
;
}
try
{
uri
.
QueryInterface
(
Ci
.
nsIURL
)
;
}
catch
(
ex
)
{
return
false
;
}
let
asciiHost
=
uri
.
asciiHost
;
if
(
!
isBaseUri
&
&
this
.
_blockedHosts
.
some
(
blockedHost
=
>
asciiHost
.
endsWith
(
blockedHost
)
)
)
{
return
false
;
}
if
(
!
isBaseUri
&
&
(
!
uri
.
filePath
|
|
uri
.
filePath
=
=
"
/
"
)
)
{
this
.
log
(
"
Not
parsing
home
page
:
"
+
uri
.
spec
)
;
return
false
;
}
return
true
;
}
async
_readerParse
(
doc
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
READER_MODE_PARSE_RESULT
"
)
;
if
(
this
.
parseNodeLimit
)
{
let
numTags
=
doc
.
getElementsByTagName
(
"
*
"
)
.
length
;
if
(
numTags
>
this
.
parseNodeLimit
)
{
this
.
log
(
"
Aborting
parse
for
"
+
doc
.
baseURIObject
.
spec
+
"
;
"
+
numTags
+
"
elements
found
"
)
;
histogram
.
add
(
PARSE_ERROR_TOO_MANY_ELEMENTS
)
;
return
null
;
}
}
let
{
documentURI
}
=
doc
;
let
uriParam
=
{
spec
:
doc
.
baseURIObject
.
spec
host
:
doc
.
baseURIObject
.
host
prePath
:
doc
.
baseURIObject
.
prePath
scheme
:
doc
.
baseURIObject
.
scheme
pathBase
:
Services
.
io
.
newURI
(
"
.
"
null
doc
.
baseURIObject
)
.
spec
}
;
let
serializer
=
new
XMLSerializer
(
)
;
let
serializedDoc
=
serializer
.
serializeToString
(
doc
)
;
let
options
=
{
classesToPreserve
:
CLASSES_TO_PRESERVE
}
;
let
article
=
null
;
try
{
article
=
await
ReaderWorker
.
post
(
"
parseDocument
"
[
uriParam
serializedDoc
options
]
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
in
ReaderWorker
:
"
+
e
)
;
histogram
.
add
(
PARSE_ERROR_WORKER
)
;
}
doc
=
null
;
if
(
!
article
)
{
this
.
log
(
"
Worker
did
not
return
an
article
"
)
;
histogram
.
add
(
PARSE_ERROR_NO_ARTICLE
)
;
return
null
;
}
article
.
url
=
documentURI
;
delete
article
.
uri
;
let
flags
=
Ci
.
nsIDocumentEncoder
.
OutputSelectionOnly
|
Ci
.
nsIDocumentEncoder
.
OutputAbsoluteLinks
;
article
.
title
=
Cc
[
"
mozilla
.
org
/
parserutils
;
1
"
]
.
getService
(
Ci
.
nsIParserUtils
)
.
convertToPlainText
(
article
.
title
flags
0
)
;
if
(
gIsFirefoxDesktop
)
{
await
this
.
_assignLanguage
(
article
)
;
this
.
_maybeAssignTextDirection
(
article
)
;
}
this
.
_assignReadTime
(
article
)
;
histogram
.
add
(
PARSE_SUCCESS
)
;
return
article
;
}
get
_cryptoHash
(
)
{
delete
this
.
_cryptoHash
;
return
this
.
_cryptoHash
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
}
get
_unicodeConverter
(
)
{
delete
this
.
_unicodeConverter
;
this
.
_unicodeConverter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
this
.
_unicodeConverter
.
charset
=
"
utf8
"
;
return
this
.
_unicodeConverter
;
}
_toHashedPath
(
url
)
{
let
value
=
this
.
_unicodeConverter
.
convertToByteArray
(
url
)
;
this
.
_cryptoHash
.
init
(
this
.
_cryptoHash
.
MD5
)
;
this
.
_cryptoHash
.
update
(
value
value
.
length
)
;
let
hash
=
CommonUtils
.
encodeBase32
(
this
.
_cryptoHash
.
finish
(
false
)
)
;
let
fileName
=
hash
.
substring
(
0
hash
.
indexOf
(
"
=
"
)
)
+
"
.
json
"
;
return
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
readercache
"
fileName
)
;
}
_ensureCacheDir
(
)
{
let
dir
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
readercache
"
)
;
return
OS
.
File
.
exists
(
dir
)
.
then
(
exists
=
>
{
if
(
!
exists
)
{
return
OS
.
File
.
makeDir
(
dir
)
;
}
return
undefined
;
}
)
;
}
_assignLanguage
(
article
)
{
return
LanguageDetector
.
detectLanguage
(
article
.
textContent
)
.
then
(
result
=
>
{
article
.
language
=
result
.
confident
?
result
.
language
:
null
;
}
)
;
}
_maybeAssignTextDirection
(
article
)
{
if
(
!
article
.
dir
&
&
[
"
ar
"
"
fa
"
"
he
"
"
ug
"
"
ur
"
]
.
includes
(
article
.
language
)
)
{
article
.
dir
=
"
rtl
"
;
}
}
_assignReadTime
(
article
)
{
let
lang
=
article
.
language
|
|
"
en
"
;
const
readingSpeed
=
this
.
_getReadingSpeedForLanguage
(
lang
)
;
const
charactersPerMinuteLow
=
readingSpeed
.
cpm
-
readingSpeed
.
variance
;
const
charactersPerMinuteHigh
=
readingSpeed
.
cpm
+
readingSpeed
.
variance
;
const
length
=
article
.
length
;
article
.
readingTimeMinsSlow
=
Math
.
ceil
(
length
/
charactersPerMinuteLow
)
;
article
.
readingTimeMinsFast
=
Math
.
ceil
(
length
/
charactersPerMinuteHigh
)
;
}
_getReadingSpeedForLanguage
(
lang
)
{
const
readingSpeed
=
new
Map
(
[
[
"
en
"
{
cpm
:
987
variance
:
118
}
]
[
"
ar
"
{
cpm
:
612
variance
:
88
}
]
[
"
de
"
{
cpm
:
920
variance
:
86
}
]
[
"
es
"
{
cpm
:
1025
variance
:
127
}
]
[
"
fi
"
{
cpm
:
1078
variance
:
121
}
]
[
"
fr
"
{
cpm
:
998
variance
:
126
}
]
[
"
he
"
{
cpm
:
833
variance
:
130
}
]
[
"
it
"
{
cpm
:
950
variance
:
140
}
]
[
"
jw
"
{
cpm
:
357
variance
:
56
}
]
[
"
nl
"
{
cpm
:
978
variance
:
143
}
]
[
"
pl
"
{
cpm
:
916
variance
:
126
}
]
[
"
pt
"
{
cpm
:
913
variance
:
145
}
]
[
"
ru
"
{
cpm
:
986
variance
:
175
}
]
[
"
sk
"
{
cpm
:
885
variance
:
145
}
]
[
"
sv
"
{
cpm
:
917
variance
:
156
}
]
[
"
tr
"
{
cpm
:
1054
variance
:
156
}
]
[
"
zh
"
{
cpm
:
255
variance
:
29
}
]
]
)
;
return
readingSpeed
.
get
(
lang
)
|
|
readingSpeed
.
get
(
"
en
"
)
;
}
}
;
