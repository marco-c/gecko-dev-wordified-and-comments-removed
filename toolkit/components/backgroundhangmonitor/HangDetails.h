#
ifndef
mozilla_HangDetails_h
#
define
mozilla_HangDetails_h
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
mozilla
/
ProcessedStack
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
HangStack
.
h
"
#
include
"
mozilla
/
HangAnnotations
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIHangDetails
.
h
"
namespace
mozilla
{
class
HangDetails
{
public
:
HangDetails
(
)
:
mDuration
(
0
)
mProcess
(
GeckoProcessType_Invalid
)
{
}
HangDetails
(
const
HangDetails
&
aOther
)
;
HangDetails
(
HangDetails
&
&
aOther
)
=
default
;
HangDetails
(
uint32_t
aDuration
GeckoProcessType
aProcess
const
nsACString
&
aThreadName
const
nsACString
&
aRunnableName
HangStack
&
&
aPseudoStack
UniquePtr
<
HangMonitor
:
:
HangAnnotations
>
&
&
aAnnotations
)
:
mDuration
(
aDuration
)
mProcess
(
aProcess
)
mThreadName
(
aThreadName
)
mRunnableName
(
aRunnableName
)
mPseudoStack
(
Move
(
aPseudoStack
)
)
mAnnotations
(
Move
(
aAnnotations
)
)
{
}
uint32_t
mDuration
;
GeckoProcessType
mProcess
;
nsCString
mThreadName
;
nsCString
mRunnableName
;
HangStack
mPseudoStack
;
UniquePtr
<
HangMonitor
:
:
HangAnnotations
>
mAnnotations
;
Telemetry
:
:
ProcessedStack
mStack
;
}
;
class
nsHangDetails
:
public
nsIHangDetails
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIHANGDETAILS
explicit
nsHangDetails
(
HangDetails
&
&
aDetails
)
:
mDetails
(
Move
(
aDetails
)
)
{
}
void
Submit
(
)
;
private
:
virtual
~
nsHangDetails
(
)
{
}
HangDetails
mDetails
;
}
;
class
ProcessHangStackRunnable
final
:
public
Runnable
{
public
:
ProcessHangStackRunnable
(
HangDetails
&
&
aHangDetails
std
:
:
vector
<
uintptr_t
>
&
&
aNativeStack
)
:
Runnable
(
"
ProcessHangStackRunnable
"
)
mHangDetails
(
Move
(
aHangDetails
)
)
mNativeStack
(
Move
(
aNativeStack
)
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
HangDetails
mHangDetails
;
std
:
:
vector
<
uintptr_t
>
mNativeStack
;
}
;
}
namespace
IPC
{
template
<
>
class
ParamTraits
<
mozilla
:
:
HangDetails
>
{
public
:
typedef
mozilla
:
:
HangDetails
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
;
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
;
}
;
}
#
endif
