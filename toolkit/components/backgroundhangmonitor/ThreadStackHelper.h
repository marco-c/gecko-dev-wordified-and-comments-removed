#
ifndef
mozilla_ThreadStackHelper_h
#
define
mozilla_ThreadStackHelper_h
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
HangDetails
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
nsThread
.
h
"
#
include
<
stddef
.
h
>
#
if
defined
(
XP_LINUX
)
#
include
<
signal
.
h
>
#
include
<
semaphore
.
h
>
#
include
<
sys
/
types
.
h
>
#
elif
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
elif
defined
(
XP_MACOSX
)
#
include
<
mach
/
mach
.
h
>
#
endif
#
if
defined
(
XP_LINUX
)
|
|
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
#
define
MOZ_THREADSTACKHELPER_PROFILING_STACK
#
define
MOZ_THREADSTACKHELPER_NATIVE_STACK
#
endif
#
if
defined
(
__ANDROID__
)
&
&
defined
(
__arm__
)
#
undef
MOZ_THREADSTACKHELPER_PROFILING_STACK
#
undef
MOZ_THREADSTACKHELPER_NATIVE_STACK
#
endif
namespace
mozilla
{
class
ThreadStackHelper
:
public
ProfilerStackCollector
{
private
:
HangStack
*
mStackToFill
;
Array
<
char
nsThread
:
:
kRunnableNameBufSize
>
*
mRunnableNameBuffer
;
size_t
mMaxStackSize
;
size_t
mMaxBufferSize
;
size_t
mDesiredStackSize
;
size_t
mDesiredBufferSize
;
bool
PrepareStackBuffer
(
HangStack
&
aStack
)
;
public
:
ThreadStackHelper
(
)
;
void
GetStack
(
HangStack
&
aStack
nsACString
&
aRunnableName
bool
aStackWalk
)
;
ProfilerThreadId
GetThreadId
(
)
const
{
return
mThreadId
;
}
protected
:
virtual
void
SetIsMainThread
(
)
override
;
virtual
void
CollectNativeLeafAddr
(
void
*
aAddr
)
override
;
virtual
void
CollectJitReturnAddr
(
void
*
aAddr
)
override
;
virtual
void
CollectWasmOrSyncJITFrame
(
JS
:
:
ProfilingCategoryPair
aCategory
const
char
*
aLabel
uint32_t
aSourceId
)
override
;
virtual
void
CollectProfilingStackFrame
(
const
js
:
:
ProfilingStackFrame
&
aEntry
)
override
;
private
:
bool
MaybeAppendDynamicStackFrame
(
mozilla
:
:
Span
<
const
char
>
aBuf
)
;
void
TryAppendFrame
(
mozilla
:
:
HangEntry
aFrame
)
;
ProfilerThreadId
mThreadId
;
}
;
}
#
endif
#
endif
