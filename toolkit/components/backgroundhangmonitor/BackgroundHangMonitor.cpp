#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
<
utility
>
#
include
"
GeckoProfiler
.
h
"
#
include
"
HangDetails
.
h
"
#
include
"
ThreadStackHelper
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CPUUsageWatcher
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_toolkit
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
RemoteType
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
prthread
.
h
"
#
include
<
algorithm
>
#
define
BHR_BETA_MOD
INT32_MAX
;
static
const
size_t
kMaxThreadHangStackDepth
=
30
;
static
const
int32_t
kCheckCPUIntervalMilliseconds
=
2000
;
bool
StackScriptEntriesCollapser
(
const
char
*
aStackEntry
const
char
*
aAnotherStackEntry
)
{
return
!
strcmp
(
aStackEntry
aAnotherStackEntry
)
&
&
(
!
strcmp
(
aStackEntry
"
(
chrome
script
)
"
)
|
|
!
strcmp
(
aStackEntry
"
(
content
script
)
"
)
)
;
}
namespace
mozilla
{
class
BackgroundHangManager
:
public
nsIObserver
{
private
:
bool
mShutdown
;
BackgroundHangManager
(
const
BackgroundHangManager
&
)
;
BackgroundHangManager
&
operator
=
(
const
BackgroundHangManager
&
)
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
static
StaticRefPtr
<
BackgroundHangManager
>
sInstance
;
static
bool
sDisabled
;
Monitor
mLock
MOZ_UNANNOTATED
;
LinkedList
<
BackgroundHangThread
>
mHangThreads
;
nsCOMPtr
<
nsIThread
>
mHangProcessingThread
;
nsCOMPtr
<
nsIThread
>
mHangMonitorThread
;
ProfilerThreadId
mHangMonitorProfilerThreadId
;
void
SetMonitorThreadId
(
)
{
mHangMonitorProfilerThreadId
=
profiler_current_thread_id
(
)
;
}
nsCOMPtr
<
nsIFile
>
mPermahangFile
;
CPUUsageWatcher
mCPUUsageWatcher
;
TimeStamp
mLastCheckedCPUUsage
;
void
CollectCPUUsage
(
TimeStamp
aNow
bool
aForce
=
false
)
{
if
(
aForce
|
|
aNow
-
mLastCheckedCPUUsage
>
TimeDuration
:
:
FromMilliseconds
(
kCheckCPUIntervalMilliseconds
)
)
{
Unused
<
<
NS_WARN_IF
(
mCPUUsageWatcher
.
CollectCPUUsage
(
)
.
isErr
(
)
)
;
mLastCheckedCPUUsage
=
aNow
;
}
}
void
Shutdown
(
)
{
MonitorAutoLock
autoLock
(
mLock
)
;
mShutdown
=
true
;
}
BackgroundHangManager
(
)
;
private
:
virtual
~
BackgroundHangManager
(
)
;
}
;
NS_IMPL_ISUPPORTS
(
BackgroundHangManager
nsIObserver
)
NS_IMETHODIMP
BackgroundHangManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
browser
-
delayed
-
startup
-
finished
"
)
)
{
MonitorAutoLock
autoLock
(
mLock
)
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
mPermahangFile
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPermahangFile
-
>
AppendNative
(
"
last_permahang
.
bin
"
_ns
)
;
}
else
{
mPermahangFile
=
nullptr
;
}
if
(
mHangProcessingThread
&
&
mPermahangFile
)
{
nsCOMPtr
<
nsIRunnable
>
submitRunnable
=
new
SubmitPersistedPermahangRunnable
(
mPermahangFile
)
;
mHangProcessingThread
-
>
Dispatch
(
submitRunnable
.
forget
(
)
)
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
observerService
-
>
RemoveObserver
(
BackgroundHangManager
:
:
sInstance
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
else
if
(
!
strcmp
(
aTopic
"
profile
-
after
-
change
"
)
)
{
BackgroundHangMonitor
:
:
DisableOnBeta
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
observerService
-
>
RemoveObserver
(
BackgroundHangManager
:
:
sInstance
"
profile
-
after
-
change
"
)
;
}
else
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
class
BackgroundHangThread
final
:
public
LinkedListElement
<
BackgroundHangThread
>
public
nsITimerCallback
public
nsINamed
{
private
:
static
MOZ_THREAD_LOCAL
(
BackgroundHangThread
*
)
sTlsKey
;
static
bool
sTlsKeyInitialized
;
BackgroundHangThread
(
const
BackgroundHangThread
&
)
;
BackgroundHangThread
&
operator
=
(
const
BackgroundHangThread
&
)
;
~
BackgroundHangThread
(
)
;
const
RefPtr
<
BackgroundHangManager
>
mManager
;
const
PRThread
*
mThreadID
;
RefPtr
<
nsITimer
>
mTimer
;
TimeStamp
mExpectedTimerNotification
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
static
BackgroundHangThread
*
FindThread
(
)
;
static
void
Startup
(
)
{
sTlsKeyInitialized
=
sTlsKey
.
init
(
)
;
}
const
TimeDuration
mTimeout
;
const
TimeDuration
mMaxTimeout
;
TimeStamp
mLastActivity
;
TimeStamp
mHangStart
;
bool
mHanging
;
bool
mWaiting
;
BackgroundHangMonitor
:
:
ThreadType
mThreadType
;
#
ifdef
MOZ_GECKO_PROFILER
ThreadStackHelper
mStackHelper
;
#
endif
HangStack
mHangStack
;
BackgroundHangAnnotations
mAnnotations
;
BackgroundHangAnnotators
mAnnotators
;
nsCString
mRunnableName
;
nsCString
mThreadName
;
BackgroundHangThread
(
const
char
*
aName
uint32_t
aTimeoutMs
uint32_t
aMaxTimeoutMs
BackgroundHangMonitor
:
:
ThreadType
aThreadType
=
BackgroundHangMonitor
:
:
THREAD_SHARED
)
;
void
ReportHang
(
TimeDuration
aHangTime
PersistedToDisk
aPersistedToDisk
=
PersistedToDisk
:
:
No
)
;
void
ReportPermaHang
(
)
;
void
NotifyActivity
(
)
{
if
(
MOZ_UNLIKELY
(
!
mTimer
)
)
{
return
;
}
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
PROFILER_MARKER_UNTYPED
(
"
NotifyActivity
"
OTHER
MarkerThreadId
(
mManager
-
>
mHangMonitorProfilerThreadId
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
mWaiting
)
{
mWaiting
=
false
;
}
else
if
(
mHanging
)
{
ReportHang
(
now
-
mHangStart
)
;
mHanging
=
false
;
}
mLastActivity
=
now
;
BackgroundHangManager
:
:
sInstance
-
>
CollectCPUUsage
(
now
)
;
mExpectedTimerNotification
=
now
+
mTimeout
;
mTimer
-
>
InitHighResolutionWithCallback
(
this
mTimeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
void
NotifyWait
(
)
{
if
(
MOZ_UNLIKELY
(
!
mTimer
)
)
{
return
;
}
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
PROFILER_MARKER_UNTYPED
(
"
NotifyWait
"
OTHER
MarkerThreadId
(
mManager
-
>
mHangMonitorProfilerThreadId
)
)
;
if
(
mWaiting
)
{
return
;
}
mTimer
-
>
Cancel
(
)
;
mLastActivity
=
TimeStamp
:
:
Now
(
)
;
if
(
mHanging
)
{
ReportHang
(
mLastActivity
-
mHangStart
)
;
mHanging
=
false
;
}
mWaiting
=
true
;
}
bool
IsShared
(
)
{
return
mThreadType
=
=
BackgroundHangMonitor
:
:
THREAD_SHARED
;
}
}
;
NS_IMPL_ISUPPORTS
(
BackgroundHangThread
nsITimerCallback
nsINamed
)
NS_IMETHODIMP
BackgroundHangThread
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
BackgroundHangThread_timer
"
)
;
return
NS_OK
;
}
StaticRefPtr
<
BackgroundHangManager
>
BackgroundHangManager
:
:
sInstance
;
bool
BackgroundHangManager
:
:
sDisabled
=
false
;
MOZ_THREAD_LOCAL
(
BackgroundHangThread
*
)
BackgroundHangThread
:
:
sTlsKey
;
bool
BackgroundHangThread
:
:
sTlsKeyInitialized
;
BackgroundHangManager
:
:
BackgroundHangManager
(
)
:
mShutdown
(
false
)
mLock
(
"
BackgroundHangManager
"
)
{
sInstance
=
this
;
DebugOnly
<
nsresult
>
rv
=
NS_NewNamedThread
(
"
BHMgr
Monitor
"
getter_AddRefs
(
mHangMonitorThread
)
mozilla
:
:
NewRunnableMethod
(
"
BackgroundHangManager
:
:
SetMonitorThreadId
"
this
&
BackgroundHangManager
:
:
SetMonitorThreadId
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
&
&
mHangMonitorThread
"
Failed
to
create
BHR
processing
thread
"
)
;
rv
=
NS_NewNamedThread
(
"
BHMgr
Processor
"
getter_AddRefs
(
mHangProcessingThread
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
&
&
mHangProcessingThread
"
Failed
to
create
BHR
processing
thread
"
)
;
}
BackgroundHangManager
:
:
~
BackgroundHangManager
(
)
{
MOZ_ASSERT
(
mShutdown
"
Destruction
without
Shutdown
call
"
)
;
MOZ_ASSERT
(
mHangThreads
.
isEmpty
(
)
"
Destruction
with
outstanding
monitors
"
)
;
MOZ_ASSERT
(
mHangMonitorThread
"
No
monitor
thread
"
)
;
MOZ_ASSERT
(
mHangProcessingThread
"
No
processing
thread
"
)
;
if
(
mHangMonitorThread
)
{
mHangMonitorThread
-
>
Shutdown
(
)
;
}
if
(
mHangProcessingThread
)
{
mHangProcessingThread
-
>
Shutdown
(
)
;
}
}
BackgroundHangThread
:
:
BackgroundHangThread
(
const
char
*
aName
uint32_t
aTimeoutMs
uint32_t
aMaxTimeoutMs
BackgroundHangMonitor
:
:
ThreadType
aThreadType
)
:
mManager
(
BackgroundHangManager
:
:
sInstance
)
mThreadID
(
PR_GetCurrentThread
(
)
)
mTimeout
(
aTimeoutMs
=
=
BackgroundHangMonitor
:
:
kNoTimeout
?
TimeDuration
:
:
Forever
(
)
:
TimeDuration
:
:
FromMilliseconds
(
aTimeoutMs
)
)
mMaxTimeout
(
aMaxTimeoutMs
=
=
BackgroundHangMonitor
:
:
kNoTimeout
?
TimeDuration
:
:
Forever
(
)
:
TimeDuration
:
:
FromMilliseconds
(
aMaxTimeoutMs
)
)
mHanging
(
false
)
mWaiting
(
true
)
mThreadType
(
aThreadType
)
mThreadName
(
aName
)
{
if
(
sTlsKeyInitialized
&
&
IsShared
(
)
)
{
sTlsKey
.
set
(
this
)
;
}
if
(
mManager
-
>
mHangMonitorThread
)
{
mTimer
=
NS_NewTimer
(
mManager
-
>
mHangMonitorThread
)
;
}
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
mManager
-
>
mHangThreads
.
insertBack
(
this
)
;
}
BackgroundHangThread
:
:
~
BackgroundHangThread
(
)
{
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
remove
(
)
;
if
(
sTlsKeyInitialized
&
&
IsShared
(
)
)
{
sTlsKey
.
set
(
nullptr
)
;
}
}
void
BackgroundHangThread
:
:
ReportHang
(
TimeDuration
aHangTime
PersistedToDisk
aPersistedToDisk
)
{
HangDetails
hangDetails
(
aHangTime
nsDependentCString
(
XRE_GetProcessTypeString
(
)
)
NOT_REMOTE_TYPE
mThreadName
mRunnableName
std
:
:
move
(
mHangStack
)
std
:
:
move
(
mAnnotations
)
)
;
PersistedToDisk
persistedToDisk
=
aPersistedToDisk
;
if
(
aPersistedToDisk
=
=
PersistedToDisk
:
:
Yes
&
&
XRE_IsParentProcess
(
)
&
&
mManager
-
>
mPermahangFile
)
{
auto
res
=
WriteHangDetailsToFile
(
hangDetails
mManager
-
>
mPermahangFile
)
;
persistedToDisk
=
res
.
isOk
(
)
?
PersistedToDisk
:
:
Yes
:
PersistedToDisk
:
:
No
;
}
if
(
mManager
-
>
mHangProcessingThread
)
{
nsCOMPtr
<
nsIRunnable
>
processHangStackRunnable
=
new
ProcessHangStackRunnable
(
std
:
:
move
(
hangDetails
)
persistedToDisk
)
;
mManager
-
>
mHangProcessingThread
-
>
Dispatch
(
processHangStackRunnable
.
forget
(
)
)
;
}
else
{
NS_WARNING
(
"
Unable
to
report
native
stack
without
a
BHR
processing
thread
"
)
;
RefPtr
<
nsHangDetails
>
hd
=
new
nsHangDetails
(
std
:
:
move
(
hangDetails
)
persistedToDisk
)
;
hd
-
>
Submit
(
)
;
}
#
ifdef
MOZ_GECKO_PROFILER
if
(
profiler_thread_is_being_profiled_for_markers
(
mStackHelper
.
GetThreadId
(
)
)
)
{
struct
HangMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
BHR
-
detected
hang
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
)
{
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
return
schema
;
}
}
;
const
TimeStamp
endTime
=
TimeStamp
:
:
Now
(
)
;
const
TimeStamp
startTime
=
endTime
-
aHangTime
;
profiler_add_marker
(
"
BHR
-
detected
hang
"
geckoprofiler
:
:
category
:
:
OTHER
{
MarkerThreadId
(
mStackHelper
.
GetThreadId
(
)
)
MarkerTiming
:
:
Interval
(
startTime
endTime
)
}
HangMarker
{
}
)
;
}
#
endif
}
void
BackgroundHangThread
:
:
ReportPermaHang
(
)
{
ReportHang
(
mMaxTimeout
PersistedToDisk
:
:
Yes
)
;
}
NS_IMETHODIMP
BackgroundHangThread
:
:
Notify
(
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
profiler_current_thread_id
(
)
=
=
mManager
-
>
mHangMonitorProfilerThreadId
)
;
MonitorAutoLock
autoLock
(
mManager
-
>
mLock
)
;
PROFILER_MARKER_UNTYPED
(
"
TimerNotify
"
OTHER
{
}
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
MOZ_UNLIKELY
(
(
now
-
mExpectedTimerNotification
)
*
2
>
mTimeout
)
)
{
mWaiting
=
true
;
mHanging
=
false
;
return
NS_OK
;
}
TimeDuration
hangTime
=
now
-
mLastActivity
;
if
(
MOZ_UNLIKELY
(
hangTime
>
=
mMaxTimeout
)
)
{
mWaiting
=
true
;
mHanging
=
false
;
ReportPermaHang
(
)
;
return
NS_OK
;
}
if
(
MOZ_LIKELY
(
!
mHanging
&
&
hangTime
>
=
mTimeout
)
)
{
#
ifdef
MOZ_GECKO_PROFILER
mStackHelper
.
GetStack
(
mHangStack
mRunnableName
true
)
;
#
endif
BackgroundHangManager
:
:
sInstance
-
>
CollectCPUUsage
(
now
true
)
;
mHangStart
=
mLastActivity
;
mHanging
=
true
;
mAnnotations
=
mAnnotators
.
GatherAnnotations
(
)
;
}
TimeDuration
nextRecheck
=
mMaxTimeout
-
hangTime
;
mExpectedTimerNotification
=
now
+
nextRecheck
;
return
mTimer
-
>
InitHighResolutionWithCallback
(
this
nextRecheck
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
BackgroundHangThread
*
BackgroundHangThread
:
:
FindThread
(
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
BackgroundHangManager
:
:
sInstance
=
=
nullptr
)
{
MOZ_ASSERT
(
BackgroundHangManager
:
:
sDisabled
"
BackgroundHandleManager
is
not
initialized
"
)
;
return
nullptr
;
}
if
(
sTlsKeyInitialized
)
{
return
sTlsKey
.
get
(
)
;
}
RefPtr
<
BackgroundHangManager
>
manager
(
BackgroundHangManager
:
:
sInstance
)
;
MOZ_ASSERT
(
manager
"
Creating
BackgroundHangMonitor
after
shutdown
"
)
;
PRThread
*
threadID
=
PR_GetCurrentThread
(
)
;
MonitorAutoLock
autoLock
(
manager
-
>
mLock
)
;
for
(
BackgroundHangThread
*
thread
=
manager
-
>
mHangThreads
.
getFirst
(
)
;
thread
;
thread
=
thread
-
>
getNext
(
)
)
{
if
(
thread
-
>
mThreadID
=
=
threadID
&
&
thread
-
>
IsShared
(
)
)
{
return
thread
;
}
}
#
endif
return
nullptr
;
}
bool
BackgroundHangMonitor
:
:
ShouldDisableOnBeta
(
const
nsCString
&
clientID
)
{
MOZ_ASSERT
(
clientID
.
Length
(
)
=
=
36
"
clientID
is
invalid
"
)
;
const
char
*
suffix
=
clientID
.
get
(
)
+
clientID
.
Length
(
)
-
4
;
return
strtol
(
suffix
NULL
16
)
%
BHR_BETA_MOD
;
}
bool
BackgroundHangMonitor
:
:
DisableOnBeta
(
)
{
nsAutoCString
clientID
;
nsresult
rv
=
Preferences
:
:
GetCString
(
"
toolkit
.
telemetry
.
cachedClientID
"
clientID
)
;
bool
telemetryEnabled
=
Telemetry
:
:
CanRecordPrereleaseData
(
)
;
if
(
!
telemetryEnabled
|
|
NS_FAILED
(
rv
)
|
|
BackgroundHangMonitor
:
:
ShouldDisableOnBeta
(
clientID
)
)
{
if
(
XRE_IsParentProcess
(
)
)
{
BackgroundHangMonitor
:
:
Shutdown
(
)
;
}
else
{
BackgroundHangManager
:
:
sDisabled
=
true
;
}
return
true
;
}
return
false
;
}
void
BackgroundHangMonitor
:
:
Startup
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
MOZ_ASSERT
(
!
BackgroundHangManager
:
:
sInstance
"
Already
initialized
"
)
;
if
(
XRE_IsContentProcess
(
)
&
&
StaticPrefs
:
:
toolkit_content_background_hang_monitor_disabled
(
)
)
{
BackgroundHangManager
:
:
sDisabled
=
true
;
return
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
observerService
)
;
if
(
!
strcmp
(
MOZ_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
"
beta
"
)
)
{
if
(
XRE_IsParentProcess
(
)
)
{
BackgroundHangThread
:
:
Startup
(
)
;
new
BackgroundHangManager
(
)
;
Unused
<
<
NS_WARN_IF
(
BackgroundHangManager
:
:
sInstance
-
>
mCPUUsageWatcher
.
Init
(
)
.
isErr
(
)
)
;
observerService
-
>
AddObserver
(
BackgroundHangManager
:
:
sInstance
"
profile
-
after
-
change
"
false
)
;
return
;
}
else
if
(
DisableOnBeta
(
)
)
{
return
;
}
}
BackgroundHangThread
:
:
Startup
(
)
;
new
BackgroundHangManager
(
)
;
Unused
<
<
NS_WARN_IF
(
BackgroundHangManager
:
:
sInstance
-
>
mCPUUsageWatcher
.
Init
(
)
.
isErr
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
observerService
-
>
AddObserver
(
BackgroundHangManager
:
:
sInstance
"
browser
-
delayed
-
startup
-
finished
"
false
)
;
}
#
endif
}
void
BackgroundHangMonitor
:
:
Shutdown
(
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
BackgroundHangManager
:
:
sDisabled
)
{
MOZ_ASSERT
(
!
BackgroundHangManager
:
:
sInstance
"
Initialized
"
)
;
return
;
}
MOZ_ASSERT
(
BackgroundHangManager
:
:
sInstance
"
Not
initialized
"
)
;
BackgroundHangManager
:
:
sInstance
-
>
mCPUUsageWatcher
.
Uninit
(
)
;
BackgroundHangManager
:
:
sInstance
-
>
Shutdown
(
)
;
BackgroundHangManager
:
:
sInstance
=
nullptr
;
BackgroundHangManager
:
:
sDisabled
=
true
;
#
endif
}
BackgroundHangMonitor
:
:
BackgroundHangMonitor
(
const
char
*
aName
uint32_t
aTimeoutMs
uint32_t
aMaxTimeoutMs
ThreadType
aThreadType
)
:
mThread
(
aThreadType
=
=
THREAD_SHARED
?
BackgroundHangThread
:
:
FindThread
(
)
:
nullptr
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
#
ifdef
MOZ_VALGRIND
if
(
RUNNING_ON_VALGRIND
)
{
const
uint32_t
scaleUp
=
30
;
const
uint32_t
extraMs
=
6000
;
if
(
aTimeoutMs
!
=
BackgroundHangMonitor
:
:
kNoTimeout
)
{
aTimeoutMs
*
=
scaleUp
;
aTimeoutMs
+
=
extraMs
;
}
if
(
aMaxTimeoutMs
!
=
BackgroundHangMonitor
:
:
kNoTimeout
)
{
aMaxTimeoutMs
*
=
scaleUp
;
aMaxTimeoutMs
+
=
extraMs
;
}
}
#
endif
if
(
!
BackgroundHangManager
:
:
sDisabled
&
&
!
mThread
)
{
mThread
=
new
BackgroundHangThread
(
aName
aTimeoutMs
aMaxTimeoutMs
aThreadType
)
;
}
#
endif
}
BackgroundHangMonitor
:
:
BackgroundHangMonitor
(
)
:
mThread
(
BackgroundHangThread
:
:
FindThread
(
)
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
BackgroundHangManager
:
:
sDisabled
)
{
return
;
}
#
endif
}
BackgroundHangMonitor
:
:
~
BackgroundHangMonitor
(
)
=
default
;
void
BackgroundHangMonitor
:
:
NotifyActivity
(
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
mThread
=
=
nullptr
)
{
MOZ_ASSERT
(
BackgroundHangManager
:
:
sDisabled
"
This
thread
is
not
initialized
for
hang
monitoring
"
)
;
return
;
}
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
mThread
-
>
NotifyActivity
(
)
;
}
#
endif
}
void
BackgroundHangMonitor
:
:
NotifyWait
(
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
if
(
mThread
=
=
nullptr
)
{
MOZ_ASSERT
(
BackgroundHangManager
:
:
sDisabled
"
This
thread
is
not
initialized
for
hang
monitoring
"
)
;
return
;
}
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
mThread
-
>
NotifyWait
(
)
;
}
#
endif
}
bool
BackgroundHangMonitor
:
:
RegisterAnnotator
(
BackgroundHangAnnotator
&
aAnnotator
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
BackgroundHangThread
*
thisThread
=
BackgroundHangThread
:
:
FindThread
(
)
;
if
(
!
thisThread
)
{
return
false
;
}
return
thisThread
-
>
mAnnotators
.
Register
(
aAnnotator
)
;
#
else
return
false
;
#
endif
}
bool
BackgroundHangMonitor
:
:
UnregisterAnnotator
(
BackgroundHangAnnotator
&
aAnnotator
)
{
#
ifdef
MOZ_ENABLE_BACKGROUND_HANG_MONITOR
BackgroundHangThread
*
thisThread
=
BackgroundHangThread
:
:
FindThread
(
)
;
if
(
!
thisThread
)
{
return
false
;
}
return
thisThread
-
>
mAnnotators
.
Unregister
(
aAnnotator
)
;
#
else
return
false
;
#
endif
}
}
