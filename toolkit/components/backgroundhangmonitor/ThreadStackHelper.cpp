#
include
"
ThreadStackHelper
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
ifdef
MOZ_THREADSTACKHELPER_PROFILING_STACK
#
include
"
js
/
ProfilingStack
.
h
"
#
endif
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
HangTypes
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsThread
.
h
"
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wshadow
"
#
endif
#
if
defined
(
MOZ_VALGRIND
)
#
include
<
valgrind
/
valgrind
.
h
>
#
endif
#
include
<
string
.
h
>
#
include
<
vector
>
#
include
<
cstdlib
>
#
ifdef
XP_LINUX
#
include
<
ucontext
.
h
>
#
include
<
unistd
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
endif
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
/
/
-
Wshadow
#
endif
#
if
defined
(
XP_LINUX
)
|
|
defined
(
XP_MACOSX
)
#
include
<
pthread
.
h
>
#
endif
#
ifdef
ANDROID
#
ifndef
SYS_gettid
#
define
SYS_gettid
__NR_gettid
#
endif
#
if
defined
(
__arm__
)
&
&
!
defined
(
__NR_rt_tgsigqueueinfo
)
#
define
__NR_rt_tgsigqueueinfo
(
__NR_SYSCALL_BASE
+
363
)
#
endif
#
ifndef
SYS_rt_tgsigqueueinfo
#
define
SYS_rt_tgsigqueueinfo
__NR_rt_tgsigqueueinfo
#
endif
#
endif
namespace
mozilla
{
const
char
kTruncationIndicator
=
'
'
;
ThreadStackHelper
:
:
ThreadStackHelper
(
)
:
mStackToFill
(
nullptr
)
mMaxStackSize
(
16
)
mMaxBufferSize
(
512
)
mDesiredStackSize
(
0
)
mDesiredBufferSize
(
0
)
{
mThreadId
=
profiler_current_thread_id
(
)
;
}
bool
ThreadStackHelper
:
:
PrepareStackBuffer
(
HangStack
&
aStack
)
{
if
(
mDesiredBufferSize
>
mMaxBufferSize
)
{
mMaxBufferSize
=
mDesiredBufferSize
;
}
if
(
mDesiredStackSize
>
mMaxStackSize
)
{
mMaxStackSize
=
mDesiredStackSize
;
}
mDesiredBufferSize
=
0
;
mDesiredStackSize
=
0
;
aStack
.
stack
(
)
.
ClearAndRetainStorage
(
)
;
aStack
.
strbuffer
(
)
.
ClearAndRetainStorage
(
)
;
aStack
.
modules
(
)
.
Clear
(
)
;
#
ifdef
MOZ_THREADSTACKHELPER_PROFILING_STACK
if
(
!
aStack
.
stack
(
)
.
SetCapacity
(
mMaxStackSize
fallible
)
|
|
!
aStack
.
strbuffer
(
)
.
SetCapacity
(
mMaxBufferSize
fallible
)
)
{
return
false
;
}
return
true
;
#
else
return
false
;
#
endif
}
namespace
{
template
<
typename
T
>
class
ScopedSetPtr
{
private
:
T
*
&
mPtr
;
public
:
ScopedSetPtr
(
T
*
&
p
T
*
val
)
:
mPtr
(
p
)
{
mPtr
=
val
;
}
~
ScopedSetPtr
(
)
{
mPtr
=
nullptr
;
}
}
;
}
void
ThreadStackHelper
:
:
GetStack
(
HangStack
&
aStack
nsACString
&
aRunnableName
bool
aStackWalk
)
{
aRunnableName
.
AssignLiteral
(
"
?
?
?
"
)
;
if
(
!
PrepareStackBuffer
(
aStack
)
)
{
return
;
}
Array
<
char
nsThread
:
:
kRunnableNameBufSize
>
runnableName
;
runnableName
[
0
]
=
'
\
0
'
;
ScopedSetPtr
<
HangStack
>
_stackGuard
(
mStackToFill
&
aStack
)
;
ScopedSetPtr
<
Array
<
char
nsThread
:
:
kRunnableNameBufSize
>
>
_runnableGuard
(
mRunnableNameBuffer
&
runnableName
)
;
profiler_suspend_and_sample_thread
(
mThreadId
0
*
this
aStackWalk
)
;
runnableName
[
nsThread
:
:
kRunnableNameBufSize
-
1
]
=
'
\
0
'
;
aRunnableName
.
AssignASCII
(
runnableName
.
cbegin
(
)
)
;
}
void
ThreadStackHelper
:
:
SetIsMainThread
(
)
{
MOZ_RELEASE_ASSERT
(
mRunnableNameBuffer
)
;
*
mRunnableNameBuffer
=
nsThread
:
:
sMainThreadRunnableName
;
}
void
ThreadStackHelper
:
:
TryAppendFrame
(
HangEntry
aFrame
)
{
MOZ_RELEASE_ASSERT
(
mStackToFill
)
;
switch
(
aFrame
.
type
(
)
)
{
case
HangEntry
:
:
THangEntryContent
:
case
HangEntry
:
:
THangEntryJit
:
case
HangEntry
:
:
THangEntryWasm
:
case
HangEntry
:
:
THangEntryChromeScript
:
case
HangEntry
:
:
THangEntrySuppressed
:
if
(
!
mStackToFill
-
>
stack
(
)
.
IsEmpty
(
)
&
&
mStackToFill
-
>
stack
(
)
.
LastElement
(
)
.
type
(
)
=
=
aFrame
.
type
(
)
)
{
return
;
}
break
;
default
:
break
;
}
mDesiredStackSize
+
=
1
;
if
(
mStackToFill
-
>
stack
(
)
.
Capacity
(
)
>
mStackToFill
-
>
stack
(
)
.
Length
(
)
)
{
mStackToFill
-
>
stack
(
)
.
AppendElement
(
std
:
:
move
(
aFrame
)
)
;
}
}
void
ThreadStackHelper
:
:
CollectNativeLeafAddr
(
void
*
aAddr
)
{
MOZ_RELEASE_ASSERT
(
mStackToFill
)
;
TryAppendFrame
(
HangEntryProgCounter
(
reinterpret_cast
<
uintptr_t
>
(
aAddr
)
)
)
;
}
void
ThreadStackHelper
:
:
CollectJitReturnAddr
(
void
*
aAddr
)
{
MOZ_RELEASE_ASSERT
(
mStackToFill
)
;
TryAppendFrame
(
HangEntryJit
(
)
)
;
}
void
ThreadStackHelper
:
:
CollectWasmFrame
(
JS
:
:
ProfilingCategoryPair
aCategory
const
char
*
aLabel
)
{
MOZ_RELEASE_ASSERT
(
mStackToFill
)
;
TryAppendFrame
(
HangEntryWasm
(
)
)
;
}
namespace
{
bool
IsChromeJSScript
(
JSScript
*
aScript
)
{
JSPrincipals
*
const
principals
=
JS_GetScriptPrincipals
(
aScript
)
;
return
nsJSPrincipals
:
:
get
(
principals
)
-
>
IsSystemPrincipal
(
)
;
}
template
<
size_t
LEN
>
const
char
*
GetFullPathForScheme
(
const
char
*
filename
const
char
(
&
scheme
)
[
LEN
]
)
{
if
(
!
strncmp
(
filename
scheme
LEN
-
1
)
)
{
return
filename
+
LEN
-
1
;
}
return
nullptr
;
}
template
<
size_t
LEN
>
const
char
*
GetPathAfterComponent
(
const
char
*
filename
const
char
(
&
component
)
[
LEN
]
)
{
const
char
*
found
=
nullptr
;
const
char
*
next
=
strstr
(
filename
component
)
;
while
(
next
)
{
found
=
next
+
LEN
-
1
;
next
=
strstr
(
found
-
1
component
)
;
}
return
found
;
}
}
bool
ThreadStackHelper
:
:
MaybeAppendDynamicStackFrame
(
Span
<
const
char
>
aBuf
)
{
mDesiredBufferSize
+
=
aBuf
.
Length
(
)
+
1
;
if
(
mStackToFill
-
>
stack
(
)
.
Capacity
(
)
>
mStackToFill
-
>
stack
(
)
.
Length
(
)
&
&
(
mStackToFill
-
>
strbuffer
(
)
.
Capacity
(
)
-
mStackToFill
-
>
strbuffer
(
)
.
Length
(
)
)
>
aBuf
.
Length
(
)
+
1
)
{
mDesiredStackSize
+
=
1
;
uint32_t
start
=
mStackToFill
-
>
strbuffer
(
)
.
Length
(
)
;
mStackToFill
-
>
strbuffer
(
)
.
AppendElements
(
aBuf
.
Elements
(
)
aBuf
.
Length
(
)
)
;
mStackToFill
-
>
strbuffer
(
)
.
AppendElement
(
'
\
0
'
)
;
mStackToFill
-
>
stack
(
)
.
AppendElement
(
HangEntryBufOffset
(
start
)
)
;
return
true
;
}
return
false
;
}
void
ThreadStackHelper
:
:
CollectProfilingStackFrame
(
const
js
:
:
ProfilingStackFrame
&
aFrame
)
{
if
(
!
aFrame
.
isJsFrame
(
)
)
{
const
char
*
frameLabel
=
aFrame
.
label
(
)
;
if
(
aFrame
.
isNonsensitive
(
)
&
&
aFrame
.
dynamicString
(
)
)
{
const
char
*
dynamicString
=
aFrame
.
dynamicString
(
)
;
char
buffer
[
128
]
;
size_t
len
=
SprintfLiteral
(
buffer
"
%
s
%
s
"
frameLabel
dynamicString
)
;
if
(
len
>
sizeof
(
buffer
)
)
{
buffer
[
sizeof
(
buffer
)
-
1
]
=
kTruncationIndicator
;
len
=
sizeof
(
buffer
)
;
}
if
(
MaybeAppendDynamicStackFrame
(
Span
(
buffer
len
)
)
)
{
return
;
}
}
nsCString
label
;
label
.
AssignLiteral
(
frameLabel
strlen
(
frameLabel
)
)
;
MOZ_RELEASE_ASSERT
(
label
.
BeginReading
(
)
=
=
frameLabel
"
String
copy
performed
during
"
"
ThreadStackHelper
:
:
CollectProfilingStackFrame
"
)
;
TryAppendFrame
(
label
)
;
return
;
}
if
(
!
aFrame
.
script
(
)
)
{
TryAppendFrame
(
HangEntrySuppressed
(
)
)
;
return
;
}
if
(
!
IsChromeJSScript
(
aFrame
.
script
(
)
)
)
{
TryAppendFrame
(
HangEntryContent
(
)
)
;
return
;
}
const
char
*
filename
=
JS_GetScriptFilename
(
aFrame
.
script
(
)
)
;
char
buffer
[
256
]
;
size_t
len
=
0
;
if
(
JSFunction
*
func
=
aFrame
.
function
(
)
)
{
if
(
JSString
*
str
=
JS_GetMaybePartialFunctionDisplayId
(
func
)
)
{
JSLinearString
*
linear
=
JS_ASSERT_STRING_IS_LINEAR
(
str
)
;
len
=
JS
:
:
GetLinearStringLength
(
linear
)
;
JS
:
:
LossyCopyLinearStringChars
(
buffer
linear
std
:
:
min
(
len
sizeof
(
buffer
)
)
)
;
if
(
len
>
=
sizeof
(
buffer
)
)
{
len
=
sizeof
(
buffer
)
;
buffer
[
sizeof
(
buffer
)
-
1
]
=
kTruncationIndicator
;
}
else
{
buffer
[
len
+
+
]
=
'
'
;
}
}
}
unsigned
lineno
=
JS_PCToLineNumber
(
aFrame
.
script
(
)
aFrame
.
pc
(
)
)
;
const
char
*
basename
=
GetPathAfterComponent
(
filename
"
-
>
"
)
;
if
(
basename
)
{
filename
=
basename
;
}
basename
=
GetFullPathForScheme
(
filename
"
chrome
:
/
/
"
)
;
if
(
!
basename
)
{
basename
=
GetFullPathForScheme
(
filename
"
resource
:
/
/
"
)
;
}
if
(
!
basename
)
{
basename
=
GetPathAfterComponent
(
filename
"
/
extensions
/
"
)
;
}
if
(
!
basename
)
{
basename
=
strrchr
(
filename
'
/
'
)
;
basename
=
basename
?
basename
+
1
:
filename
;
filename
=
strrchr
(
basename
'
\
\
'
)
;
if
(
filename
)
{
basename
=
filename
+
1
;
}
}
len
+
=
SprintfBuf
(
buffer
+
len
sizeof
(
buffer
)
-
len
"
%
s
:
%
u
"
basename
lineno
)
;
if
(
len
>
sizeof
(
buffer
)
)
{
buffer
[
sizeof
(
buffer
)
-
1
]
=
kTruncationIndicator
;
len
=
sizeof
(
buffer
)
;
}
if
(
MaybeAppendDynamicStackFrame
(
Span
(
buffer
len
)
)
)
{
return
;
}
TryAppendFrame
(
HangEntryChromeScript
(
)
)
;
}
}
