#
include
"
ThreadStackHelper
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
jsfriendapi
.
h
"
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
#
include
"
js
/
ProfilingStack
.
h
"
#
endif
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsThread
.
h
"
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
push
#
pragma
GCC
diagnostic
ignored
"
-
Wshadow
"
#
endif
#
if
defined
(
MOZ_VALGRIND
)
#
include
<
valgrind
/
valgrind
.
h
>
#
endif
#
include
<
string
.
h
>
#
include
<
vector
>
#
include
<
cstdlib
>
#
ifdef
XP_LINUX
#
include
<
ucontext
.
h
>
#
include
<
unistd
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
endif
#
ifdef
__GNUC__
#
pragma
GCC
diagnostic
pop
/
/
-
Wshadow
#
endif
#
if
defined
(
XP_LINUX
)
|
|
defined
(
XP_MACOSX
)
#
include
<
pthread
.
h
>
#
endif
#
ifdef
ANDROID
#
ifndef
SYS_gettid
#
define
SYS_gettid
__NR_gettid
#
endif
#
if
defined
(
__arm__
)
&
&
!
defined
(
__NR_rt_tgsigqueueinfo
)
#
define
__NR_rt_tgsigqueueinfo
(
__NR_SYSCALL_BASE
+
363
)
#
endif
#
ifndef
SYS_rt_tgsigqueueinfo
#
define
SYS_rt_tgsigqueueinfo
__NR_rt_tgsigqueueinfo
#
endif
#
endif
namespace
mozilla
{
ThreadStackHelper
:
:
ThreadStackHelper
(
)
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
:
mStackToFill
(
nullptr
)
mPseudoStack
(
profiler_get_pseudo_stack
(
)
)
mMaxStackSize
(
Stack
:
:
sMaxInlineStorage
)
mMaxBufferSize
(
512
)
#
endif
#
ifdef
MOZ_THREADSTACKHELPER_NATIVE
mNativeStackToFill
(
nullptr
)
#
endif
{
mThreadId
=
profiler_current_thread_id
(
)
;
}
namespace
{
template
<
typename
T
>
class
ScopedSetPtr
{
private
:
T
*
&
mPtr
;
public
:
ScopedSetPtr
(
T
*
&
p
T
*
val
)
:
mPtr
(
p
)
{
mPtr
=
val
;
}
~
ScopedSetPtr
(
)
{
mPtr
=
nullptr
;
}
}
;
}
void
ThreadStackHelper
:
:
GetPseudoStack
(
Stack
&
aStack
nsACString
&
aRunnableName
)
{
GetStacksInternal
(
&
aStack
nullptr
aRunnableName
)
;
}
void
ThreadStackHelper
:
:
GetNativeStack
(
NativeStack
&
aNativeStack
nsACString
&
aRunnableName
)
{
GetStacksInternal
(
nullptr
&
aNativeStack
aRunnableName
)
;
}
void
ThreadStackHelper
:
:
GetPseudoAndNativeStack
(
Stack
&
aStack
NativeStack
&
aNativeStack
nsACString
&
aRunnableName
)
{
GetStacksInternal
(
&
aStack
&
aNativeStack
aRunnableName
)
;
}
void
ThreadStackHelper
:
:
GetStacksInternal
(
Stack
*
aStack
NativeStack
*
aNativeStack
nsACString
&
aRunnableName
)
{
aRunnableName
.
AssignLiteral
(
"
?
?
?
"
)
;
#
if
defined
(
MOZ_THREADSTACKHELPER_PSEUDO
)
|
|
defined
(
MOZ_THREADSTACKHELPER_NATIVE
)
if
(
aStack
&
&
!
PrepareStackBuffer
(
*
aStack
)
)
{
return
;
}
if
(
aNativeStack
)
{
aNativeStack
-
>
clear
(
)
;
aNativeStack
-
>
reserve
(
Telemetry
:
:
HangStack
:
:
sMaxNativeFrames
)
;
}
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
ScopedSetPtr
<
Stack
>
stackPtr
(
mStackToFill
aStack
)
;
#
endif
#
ifdef
MOZ_THREADSTACKHELPER_NATIVE
ScopedSetPtr
<
NativeStack
>
nativeStackPtr
(
mNativeStackToFill
aNativeStack
)
;
#
endif
Array
<
char
nsThread
:
:
kRunnableNameBufSize
>
runnableName
;
runnableName
[
0
]
=
'
\
0
'
;
auto
callback
=
[
&
this
]
(
void
*
*
aPCs
size_t
aCount
bool
aIsMainThread
)
{
if
(
aIsMainThread
)
{
runnableName
=
nsThread
:
:
sMainThreadRunnableName
;
}
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
if
(
mStackToFill
)
{
FillStackBuffer
(
)
;
}
#
endif
#
ifdef
MOZ_THREADSTACKHELPER_NATIVE
if
(
mNativeStackToFill
)
{
while
(
aCount
-
-
&
&
mNativeStackToFill
-
>
size
(
)
<
mNativeStackToFill
-
>
capacity
(
)
)
{
mNativeStackToFill
-
>
push_back
(
reinterpret_cast
<
uintptr_t
>
(
aPCs
[
aCount
]
)
)
;
}
}
#
endif
}
;
if
(
mStackToFill
|
|
mNativeStackToFill
)
{
profiler_suspend_and_sample_thread
(
mThreadId
callback
!
!
aNativeStack
)
;
}
runnableName
[
nsThread
:
:
kRunnableNameBufSize
-
1
]
=
'
\
0
'
;
aRunnableName
.
AssignASCII
(
runnableName
.
cbegin
(
)
)
;
#
endif
}
bool
ThreadStackHelper
:
:
PrepareStackBuffer
(
Stack
&
aStack
)
{
aStack
.
clear
(
)
;
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
MOZ_ASSERT
(
mPseudoStack
)
;
if
(
!
aStack
.
reserve
(
mMaxStackSize
)
|
|
!
aStack
.
reserve
(
aStack
.
capacity
(
)
)
|
|
!
aStack
.
EnsureBufferCapacity
(
mMaxBufferSize
)
)
{
return
false
;
}
return
true
;
#
else
return
false
;
#
endif
}
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
namespace
{
bool
IsChromeJSScript
(
JSScript
*
aScript
)
{
nsIScriptSecurityManager
*
const
secman
=
nsScriptSecurityManager
:
:
GetScriptSecurityManager
(
)
;
NS_ENSURE_TRUE
(
secman
false
)
;
JSPrincipals
*
const
principals
=
JS_GetScriptPrincipals
(
aScript
)
;
return
secman
-
>
IsSystemPrincipal
(
nsJSPrincipals
:
:
get
(
principals
)
)
;
}
template
<
size_t
LEN
>
const
char
*
GetFullPathForScheme
(
const
char
*
filename
const
char
(
&
scheme
)
[
LEN
]
)
{
if
(
!
strncmp
(
filename
scheme
LEN
-
1
)
)
{
return
filename
+
LEN
-
1
;
}
return
nullptr
;
}
template
<
size_t
LEN
>
const
char
*
GetPathAfterComponent
(
const
char
*
filename
const
char
(
&
component
)
[
LEN
]
)
{
const
char
*
found
=
nullptr
;
const
char
*
next
=
strstr
(
filename
component
)
;
while
(
next
)
{
found
=
next
+
LEN
-
1
;
next
=
strstr
(
found
-
1
component
)
;
}
return
found
;
}
}
const
char
*
ThreadStackHelper
:
:
AppendJSEntry
(
const
js
:
:
ProfileEntry
*
aEntry
intptr_t
&
aAvailableBufferSize
const
char
*
aPrevLabel
)
{
MOZ_ASSERT
(
aEntry
-
>
isJs
(
)
)
;
const
char
*
label
;
JSScript
*
script
=
aEntry
-
>
script
(
)
;
if
(
!
script
)
{
label
=
"
(
profiling
suppressed
)
"
;
}
else
if
(
IsChromeJSScript
(
aEntry
-
>
script
(
)
)
)
{
const
char
*
filename
=
JS_GetScriptFilename
(
aEntry
-
>
script
(
)
)
;
const
unsigned
lineno
=
JS_PCToLineNumber
(
aEntry
-
>
script
(
)
aEntry
-
>
pc
(
)
)
;
MOZ_ASSERT
(
filename
)
;
char
buffer
[
128
]
;
const
char
*
basename
=
GetPathAfterComponent
(
filename
"
-
>
"
)
;
if
(
basename
)
{
filename
=
basename
;
}
basename
=
GetFullPathForScheme
(
filename
"
chrome
:
/
/
"
)
;
if
(
!
basename
)
{
basename
=
GetFullPathForScheme
(
filename
"
resource
:
/
/
"
)
;
}
if
(
!
basename
)
{
basename
=
GetPathAfterComponent
(
filename
"
/
extensions
/
"
)
;
}
if
(
!
basename
)
{
basename
=
strrchr
(
filename
'
/
'
)
;
basename
=
basename
?
basename
+
1
:
filename
;
filename
=
strrchr
(
basename
'
\
\
'
)
;
if
(
filename
)
{
basename
=
filename
+
1
;
}
}
size_t
len
=
SprintfLiteral
(
buffer
"
%
s
:
%
u
"
basename
lineno
)
;
if
(
len
<
sizeof
(
buffer
)
)
{
if
(
mStackToFill
-
>
IsSameAsEntry
(
aPrevLabel
buffer
)
)
{
return
aPrevLabel
;
}
aAvailableBufferSize
-
=
(
len
+
1
)
;
if
(
aAvailableBufferSize
>
=
0
)
{
return
mStackToFill
-
>
InfallibleAppendViaBuffer
(
buffer
len
)
;
}
}
label
=
"
(
chrome
script
)
"
;
}
else
{
label
=
"
(
content
script
)
"
;
}
if
(
mStackToFill
-
>
IsSameAsEntry
(
aPrevLabel
label
)
)
{
return
aPrevLabel
;
}
mStackToFill
-
>
infallibleAppend
(
label
)
;
return
label
;
}
#
endif
void
ThreadStackHelper
:
:
FillStackBuffer
(
)
{
#
ifdef
MOZ_THREADSTACKHELPER_PSEUDO
MOZ_ASSERT
(
mStackToFill
-
>
empty
(
)
)
;
size_t
reservedSize
=
mStackToFill
-
>
capacity
(
)
;
size_t
reservedBufferSize
=
mStackToFill
-
>
AvailableBufferSize
(
)
;
intptr_t
availableBufferSize
=
intptr_t
(
reservedBufferSize
)
;
const
js
:
:
ProfileEntry
*
entry
=
mPseudoStack
-
>
entries
;
const
js
:
:
ProfileEntry
*
end
=
entry
+
mPseudoStack
-
>
stackSize
(
)
;
const
char
*
prevLabel
=
nullptr
;
for
(
;
reservedSize
-
-
&
&
entry
!
=
end
;
entry
+
+
)
{
if
(
entry
-
>
isJs
(
)
)
{
prevLabel
=
AppendJSEntry
(
entry
availableBufferSize
prevLabel
)
;
continue
;
}
const
char
*
const
label
=
entry
-
>
label
(
)
;
if
(
mStackToFill
-
>
IsSameAsEntry
(
prevLabel
label
)
)
{
continue
;
}
mStackToFill
-
>
infallibleAppend
(
label
)
;
prevLabel
=
label
;
}
mMaxStackSize
=
mStackToFill
-
>
capacity
(
)
+
(
end
-
entry
)
;
if
(
availableBufferSize
<
0
)
{
mMaxBufferSize
=
reservedBufferSize
-
availableBufferSize
;
}
#
endif
}
}
