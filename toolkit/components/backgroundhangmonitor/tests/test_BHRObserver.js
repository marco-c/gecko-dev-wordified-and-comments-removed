const
{
TelemetryUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
sys
.
mjs
"
)
;
const
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
function
ensureProfilerInitialized
(
)
{
if
(
Services
.
profiler
.
IsActive
(
)
)
{
return
;
}
let
features
=
[
"
stackwalk
"
]
;
Services
.
profiler
.
StartProfiler
(
1000
10
features
)
;
Services
.
profiler
.
StopProfiler
(
)
;
}
add_task
(
async
function
test_BHRObserver
(
)
{
if
(
!
Services
.
telemetry
.
canRecordExtended
)
{
ok
(
"
Hang
reporting
not
enabled
.
"
)
;
return
;
}
ensureProfilerInitialized
(
)
;
do_get_profile
(
)
;
Services
.
fog
.
initializeFOG
(
)
;
Assert
.
equal
(
null
Glean
.
hangs
.
modules
.
testGetValue
(
)
"
no
module
reported
to
glean
before
the
beginning
of
the
test
"
)
;
Assert
.
equal
(
null
Glean
.
hangs
.
reports
.
testGetValue
(
)
"
no
hang
reported
to
glean
before
the
beginning
of
the
test
"
)
;
let
telSvc
=
Cc
[
"
mozilla
.
org
/
bhr
-
telemetry
-
service
;
1
"
]
.
getService
(
)
.
wrappedJSObject
;
ok
(
telSvc
"
Should
have
BHRTelemetryService
"
)
;
let
beforeLen
=
telSvc
.
payload
.
hangs
.
length
;
if
(
Services
.
appinfo
.
OS
=
=
=
"
Linux
"
|
|
Services
.
appinfo
.
OS
=
=
=
"
Android
"
)
{
let
kernel
=
Services
.
sysinfo
.
get
(
"
kernel_version
"
)
|
|
Services
.
sysinfo
.
get
(
"
version
"
)
;
if
(
Services
.
vc
.
compare
(
kernel
"
2
.
6
.
31
"
)
<
0
)
{
ok
(
"
Hang
reporting
not
supported
for
old
kernel
.
"
)
;
return
;
}
}
let
hangsPromise
=
new
Promise
(
resolve
=
>
{
let
hangs
=
[
]
;
const
onThreadHang
=
subject
=
>
{
let
hang
=
subject
.
QueryInterface
(
Ci
.
nsIHangDetails
)
;
if
(
hang
.
thread
.
startsWith
(
"
Gecko
"
)
)
{
hangs
.
push
(
hang
)
;
if
(
hangs
.
length
>
=
3
)
{
Services
.
obs
.
removeObserver
(
onThreadHang
"
bhr
-
thread
-
hang
"
)
;
resolve
(
hangs
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
onThreadHang
"
bhr
-
thread
-
hang
"
)
;
}
)
;
UserInteraction
.
start
(
"
testing
.
interaction
"
"
val
"
)
;
setTimeout
(
(
)
=
>
{
UserInteraction
.
finish
(
"
testing
.
interaction
"
)
;
}
2000
)
;
executeSoon
(
(
)
=
>
{
let
startTime
=
Date
.
now
(
)
;
while
(
Date
.
now
(
)
-
startTime
<
10000
)
{
}
}
)
;
executeSoon
(
(
)
=
>
{
let
startTime
=
Date
.
now
(
)
;
while
(
Date
.
now
(
)
-
startTime
<
1000
)
{
}
}
)
;
Services
.
prefs
.
setBoolPref
(
TelemetryUtils
.
Preferences
.
OverridePreRelease
true
)
;
let
childDone
=
run_test_in_child
(
"
child_cause_hang
.
js
"
)
;
let
hangs
=
await
hangsPromise
;
equal
(
hangs
.
length
3
)
;
hangs
.
forEach
(
hang
=
>
{
Assert
.
greater
(
hang
.
duration
0
)
;
ok
(
hang
.
thread
=
=
"
Gecko
"
|
|
hang
.
thread
=
=
"
Gecko_Child
"
)
;
equal
(
typeof
hang
.
runnableName
"
string
"
)
;
ok
(
Array
.
isArray
(
hang
.
stack
)
)
;
ok
(
!
!
hang
.
stack
.
length
)
;
hang
.
stack
.
forEach
(
entry
=
>
{
if
(
Array
.
isArray
(
entry
)
)
{
equal
(
entry
.
length
2
)
;
equal
(
typeof
entry
[
0
]
"
number
"
)
;
equal
(
typeof
entry
[
1
]
"
string
"
)
;
}
else
{
equal
(
typeof
entry
"
string
"
)
;
}
}
)
;
ok
(
Array
.
isArray
(
hang
.
modules
)
)
;
hang
.
modules
.
forEach
(
module
=
>
{
ok
(
Array
.
isArray
(
module
)
)
;
equal
(
module
.
length
2
)
;
equal
(
typeof
module
[
0
]
"
string
"
)
;
equal
(
typeof
module
[
1
]
"
string
"
)
;
}
)
;
ok
(
Array
.
isArray
(
hang
.
annotations
)
)
;
hang
.
annotations
.
forEach
(
annotation
=
>
{
ok
(
Array
.
isArray
(
annotation
)
)
;
equal
(
annotation
.
length
2
)
;
equal
(
typeof
annotation
[
0
]
"
string
"
)
;
equal
(
typeof
annotation
[
1
]
"
string
"
)
;
}
)
;
}
)
;
let
hasHangWithAnnotations
=
hangs
.
some
(
hang
=
>
!
!
hang
.
annotations
.
length
)
;
(
hasHangWithAnnotations
?
ok
:
todo_check_true
)
(
hasHangWithAnnotations
"
at
least
one
hang
has
annotations
"
)
;
ok
(
hangs
.
some
(
hang
=
>
!
hang
.
annotations
.
length
)
"
at
least
one
hang
has
no
annotation
"
)
;
Assert
.
greaterOrEqual
(
telSvc
.
payload
.
hangs
.
length
-
beforeLen
3
)
;
ok
(
Array
.
isArray
(
telSvc
.
payload
.
modules
)
)
;
telSvc
.
payload
.
modules
.
forEach
(
module
=
>
{
ok
(
Array
.
isArray
(
module
)
)
;
equal
(
module
.
length
2
)
;
equal
(
typeof
module
[
0
]
"
string
"
)
;
equal
(
typeof
module
[
1
]
"
string
"
)
;
}
)
;
telSvc
.
payload
.
hangs
.
forEach
(
hang
=
>
{
Assert
.
greater
(
hang
.
duration
0
)
;
ok
(
hang
.
thread
=
=
"
Gecko
"
|
|
hang
.
thread
=
=
"
Gecko_Child
"
)
;
equal
(
typeof
hang
.
runnableName
"
string
"
)
;
ok
(
Array
.
isArray
(
hang
.
stack
)
)
;
ok
(
!
!
hang
.
stack
.
length
)
;
hang
.
stack
.
forEach
(
entry
=
>
{
if
(
Array
.
isArray
(
entry
)
)
{
equal
(
entry
.
length
2
)
;
equal
(
typeof
entry
[
0
]
"
number
"
)
;
Assert
.
less
(
entry
[
0
]
telSvc
.
payload
.
modules
.
length
)
;
equal
(
typeof
entry
[
1
]
"
string
"
)
;
}
else
{
equal
(
typeof
entry
"
string
"
)
;
}
}
)
;
ok
(
Array
.
isArray
(
hang
.
annotations
)
)
;
hang
.
annotations
.
forEach
(
annotation
=
>
{
ok
(
Array
.
isArray
(
annotation
)
)
;
equal
(
annotation
.
length
2
)
;
equal
(
typeof
annotation
[
0
]
"
string
"
)
;
equal
(
typeof
annotation
[
1
]
"
string
"
)
;
}
)
;
}
)
;
do_send_remote_message
(
"
bhr_hangs_detected
"
)
;
await
childDone
;
let
pingSubmitted
=
false
;
GleanPings
.
hangReport
.
testBeforeNextSubmit
(
(
)
=
>
{
Assert
.
deepEqual
(
telSvc
.
payload
.
modules
Glean
.
hangs
.
modules
.
testGetValue
(
)
)
;
let
hangs
=
telSvc
.
payload
.
hangs
;
let
gleanHangs
=
Glean
.
hangs
.
reports
.
testGetValue
(
)
;
Assert
.
equal
(
hangs
.
length
gleanHangs
.
length
"
the
expected
hang
count
has
been
reported
"
)
;
for
(
let
i
=
0
;
i
<
hangs
.
length
;
+
+
i
)
{
let
hang
=
hangs
[
i
]
;
let
gleanHang
=
gleanHangs
[
i
]
;
Assert
.
equal
(
Math
.
round
(
hang
.
duration
)
gleanHang
.
duration
"
the
hang
duration
is
correct
"
)
;
Assert
.
equal
(
Math
.
round
(
hang
.
stack
.
length
)
gleanHang
.
stack
.
length
"
the
reported
stack
has
the
expected
length
"
)
;
for
(
let
j
=
0
;
j
<
hang
.
stack
.
length
;
+
+
j
)
{
let
frame
=
hang
.
stack
[
j
]
;
let
gleanFrame
=
gleanHang
.
stack
[
j
]
;
if
(
typeof
frame
=
=
"
string
"
)
{
Assert
.
deepEqual
(
{
frame
}
gleanFrame
"
label
or
JS
frame
is
correct
"
)
;
}
else
{
let
module
;
[
module
frame
]
=
frame
;
Assert
.
deepEqual
(
{
frame
module
}
gleanFrame
"
native
frame
is
correct
"
)
;
}
}
if
(
hang
.
annotations
.
length
)
{
Assert
.
deepEqual
(
hang
.
annotations
gleanHang
.
annotations
"
annotations
have
been
copied
to
glean
"
)
;
}
else
{
Assert
.
equal
(
"
undefined
"
typeof
gleanHang
.
annotations
"
no
annotation
"
)
;
}
for
(
let
field
of
[
"
process
"
"
thread
"
"
runnableName
"
]
)
{
Assert
.
equal
(
hang
[
field
]
gleanHang
[
field
]
the
{
field
}
is
correct
)
;
}
if
(
hang
.
remoteType
)
{
Assert
.
equal
(
hang
.
remoteType
gleanHang
.
remoteType
"
the
remote
type
is
correct
"
)
;
}
else
{
Assert
.
equal
(
"
undefined
"
typeof
gleanHang
.
remoteType
"
no
remote
type
"
)
;
}
}
pingSubmitted
=
true
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
bhrPing
.
enabled
"
true
)
;
telSvc
.
submit
(
)
;
Assert
.
ok
(
pingSubmitted
"
the
glean
'
hang
-
report
'
ping
has
been
submitted
"
)
;
}
)
;
