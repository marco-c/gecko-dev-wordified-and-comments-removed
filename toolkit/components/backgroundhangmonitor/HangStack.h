#
ifndef
mozilla_HangStack_h
#
define
mozilla_HangStack_h
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
mozilla
/
ProcessedStack
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIHangDetails
.
h
"
namespace
mozilla
{
typedef
std
:
:
vector
<
uintptr_t
>
NativeHangStack
;
class
HangStack
{
public
:
static
const
size_t
sMaxInlineStorage
=
8
;
static
const
size_t
sMaxNativeFrames
=
150
;
private
:
typedef
mozilla
:
:
Vector
<
const
char
*
sMaxInlineStorage
>
Impl
;
Impl
mImpl
;
mozilla
:
:
Vector
<
char
0
>
mBuffer
;
public
:
HangStack
(
)
{
}
HangStack
(
const
HangStack
&
aOther
)
;
HangStack
(
HangStack
&
&
aOther
)
:
mImpl
(
mozilla
:
:
Move
(
aOther
.
mImpl
)
)
mBuffer
(
mozilla
:
:
Move
(
aOther
.
mBuffer
)
)
{
}
HangStack
&
operator
=
(
HangStack
&
&
aOther
)
{
mImpl
=
mozilla
:
:
Move
(
aOther
.
mImpl
)
;
mBuffer
=
mozilla
:
:
Move
(
aOther
.
mBuffer
)
;
return
*
this
;
}
bool
operator
=
=
(
const
HangStack
&
aOther
)
const
{
for
(
size_t
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
if
(
!
IsSameAsEntry
(
operator
[
]
(
i
)
aOther
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
HangStack
&
aOther
)
const
{
return
!
operator
=
=
(
aOther
)
;
}
const
char
*
&
operator
[
]
(
size_t
aIndex
)
{
return
mImpl
[
aIndex
]
;
}
const
char
*
const
&
operator
[
]
(
size_t
aIndex
)
const
{
return
mImpl
[
aIndex
]
;
}
size_t
capacity
(
)
const
{
return
mImpl
.
capacity
(
)
;
}
size_t
length
(
)
const
{
return
mImpl
.
length
(
)
;
}
bool
empty
(
)
const
{
return
mImpl
.
empty
(
)
;
}
bool
canAppendWithoutRealloc
(
size_t
aNeeded
)
const
{
return
mImpl
.
canAppendWithoutRealloc
(
aNeeded
)
;
}
void
infallibleAppend
(
const
char
*
aEntry
)
{
mImpl
.
infallibleAppend
(
aEntry
)
;
}
bool
reserve
(
size_t
aRequest
)
{
return
mImpl
.
reserve
(
aRequest
)
;
}
const
char
*
*
begin
(
)
{
return
mImpl
.
begin
(
)
;
}
const
char
*
const
*
begin
(
)
const
{
return
mImpl
.
begin
(
)
;
}
const
char
*
*
end
(
)
{
return
mImpl
.
end
(
)
;
}
const
char
*
const
*
end
(
)
const
{
return
mImpl
.
end
(
)
;
}
const
char
*
&
back
(
)
{
return
mImpl
.
back
(
)
;
}
void
erase
(
const
char
*
*
aEntry
)
{
mImpl
.
erase
(
aEntry
)
;
}
void
erase
(
const
char
*
*
aBegin
const
char
*
*
aEnd
)
{
mImpl
.
erase
(
aBegin
aEnd
)
;
}
void
clear
(
)
{
mImpl
.
clear
(
)
;
mBuffer
.
clear
(
)
;
}
bool
IsInBuffer
(
const
char
*
aEntry
)
const
{
return
aEntry
>
=
mBuffer
.
begin
(
)
&
&
aEntry
<
mBuffer
.
end
(
)
;
}
bool
IsSameAsEntry
(
const
char
*
aEntry
const
char
*
aOther
)
const
{
return
IsInBuffer
(
aEntry
)
?
!
strcmp
(
aEntry
aOther
)
:
(
aEntry
=
=
aOther
)
;
}
size_t
AvailableBufferSize
(
)
const
{
return
mBuffer
.
capacity
(
)
-
mBuffer
.
length
(
)
;
}
bool
EnsureBufferCapacity
(
size_t
aCapacity
)
{
return
mBuffer
.
reserve
(
aCapacity
)
&
&
mBuffer
.
reserve
(
mBuffer
.
capacity
(
)
)
;
}
const
char
*
InfallibleAppendViaBuffer
(
const
char
*
aText
size_t
aLength
)
;
const
char
*
AppendViaBuffer
(
const
char
*
aText
size_t
aLength
)
;
}
;
}
namespace
IPC
{
template
<
>
class
ParamTraits
<
mozilla
:
:
HangStack
>
{
public
:
typedef
mozilla
:
:
HangStack
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
;
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
;
}
;
}
#
endif
