#
ifndef
mozilla_HangStack_h
#
define
mozilla_HangStack_h
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
mozilla
/
ProcessedStack
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIHangDetails
.
h
"
namespace
mozilla
{
typedef
std
:
:
vector
<
uintptr_t
>
NativeHangStack
;
class
HangStack
{
public
:
static
const
size_t
sMaxInlineStorage
=
8
;
static
const
size_t
sMaxNativeFrames
=
150
;
struct
ModOffset
{
uint32_t
mModule
;
uint32_t
mOffset
;
bool
operator
=
=
(
const
ModOffset
&
aOther
)
const
{
return
mModule
=
=
aOther
.
mModule
&
&
mOffset
=
=
aOther
.
mOffset
;
}
}
;
class
Frame
{
public
:
enum
class
Kind
{
STRING
MODOFFSET
PC
END
}
;
Frame
(
)
:
mKind
(
Kind
:
:
STRING
)
mString
(
"
"
)
{
}
explicit
Frame
(
const
char
*
aString
)
:
mKind
(
Kind
:
:
STRING
)
mString
(
aString
)
{
}
explicit
Frame
(
ModOffset
aModOffset
)
:
mKind
(
Kind
:
:
MODOFFSET
)
mModOffset
(
aModOffset
)
{
}
explicit
Frame
(
uintptr_t
aPC
)
:
mKind
(
Kind
:
:
PC
)
mPC
(
aPC
)
{
}
Kind
GetKind
(
)
const
{
return
mKind
;
}
const
char
*
&
AsString
(
)
{
MOZ_ASSERT
(
mKind
=
=
Kind
:
:
STRING
)
;
return
mString
;
}
const
char
*
const
&
AsString
(
)
const
{
MOZ_ASSERT
(
mKind
=
=
Kind
:
:
STRING
)
;
return
mString
;
}
const
ModOffset
&
AsModOffset
(
)
const
{
MOZ_ASSERT
(
mKind
=
=
Kind
:
:
MODOFFSET
)
;
return
mModOffset
;
}
const
uintptr_t
&
AsPC
(
)
const
{
MOZ_ASSERT
(
mKind
=
=
Kind
:
:
PC
)
;
return
mPC
;
}
private
:
Kind
mKind
;
union
{
const
char
*
mString
;
ModOffset
mModOffset
;
uintptr_t
mPC
;
}
;
}
;
private
:
typedef
mozilla
:
:
Vector
<
Frame
sMaxInlineStorage
>
Impl
;
Impl
mImpl
;
mozilla
:
:
Vector
<
char
0
>
mBuffer
;
public
:
HangStack
(
)
{
}
HangStack
(
const
HangStack
&
aOther
)
;
HangStack
(
HangStack
&
&
aOther
)
:
mImpl
(
mozilla
:
:
Move
(
aOther
.
mImpl
)
)
mBuffer
(
mozilla
:
:
Move
(
aOther
.
mBuffer
)
)
{
}
HangStack
&
operator
=
(
HangStack
&
&
aOther
)
{
mImpl
=
mozilla
:
:
Move
(
aOther
.
mImpl
)
;
mBuffer
=
mozilla
:
:
Move
(
aOther
.
mBuffer
)
;
return
*
this
;
}
bool
operator
=
=
(
const
HangStack
&
aOther
)
const
{
for
(
size_t
i
=
0
;
i
<
length
(
)
;
i
+
+
)
{
if
(
!
IsSameAsEntry
(
operator
[
]
(
i
)
aOther
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
HangStack
&
aOther
)
const
{
return
!
operator
=
=
(
aOther
)
;
}
Frame
&
operator
[
]
(
size_t
aIndex
)
{
return
mImpl
[
aIndex
]
;
}
Frame
const
&
operator
[
]
(
size_t
aIndex
)
const
{
return
mImpl
[
aIndex
]
;
}
size_t
capacity
(
)
const
{
return
mImpl
.
capacity
(
)
;
}
size_t
length
(
)
const
{
return
mImpl
.
length
(
)
;
}
bool
empty
(
)
const
{
return
mImpl
.
empty
(
)
;
}
bool
canAppendWithoutRealloc
(
size_t
aNeeded
)
const
{
return
mImpl
.
canAppendWithoutRealloc
(
aNeeded
)
;
}
void
infallibleAppend
(
Frame
aEntry
)
{
mImpl
.
infallibleAppend
(
aEntry
)
;
}
bool
reserve
(
size_t
aRequest
)
{
return
mImpl
.
reserve
(
aRequest
)
;
}
Frame
*
begin
(
)
{
return
mImpl
.
begin
(
)
;
}
Frame
const
*
begin
(
)
const
{
return
mImpl
.
begin
(
)
;
}
Frame
*
end
(
)
{
return
mImpl
.
end
(
)
;
}
Frame
const
*
end
(
)
const
{
return
mImpl
.
end
(
)
;
}
Frame
&
back
(
)
{
return
mImpl
.
back
(
)
;
}
void
erase
(
Frame
*
aEntry
)
{
mImpl
.
erase
(
aEntry
)
;
}
void
erase
(
Frame
*
aBegin
Frame
*
aEnd
)
{
mImpl
.
erase
(
aBegin
aEnd
)
;
}
void
clear
(
)
{
mImpl
.
clear
(
)
;
mBuffer
.
clear
(
)
;
}
bool
IsInBuffer
(
const
char
*
aEntry
)
const
{
return
aEntry
>
=
mBuffer
.
begin
(
)
&
&
aEntry
<
mBuffer
.
end
(
)
;
}
bool
IsSameAsEntry
(
const
Frame
&
aFrame
const
Frame
&
aOther
)
const
{
if
(
aFrame
.
GetKind
(
)
!
=
aOther
.
GetKind
(
)
)
{
return
false
;
}
switch
(
aFrame
.
GetKind
(
)
)
{
case
Frame
:
:
Kind
:
:
STRING
:
return
IsInBuffer
(
aFrame
.
AsString
(
)
)
?
!
strcmp
(
aFrame
.
AsString
(
)
aOther
.
AsString
(
)
)
:
(
aFrame
.
AsString
(
)
=
=
aOther
.
AsString
(
)
)
;
case
Frame
:
:
Kind
:
:
MODOFFSET
:
return
aFrame
.
AsModOffset
(
)
=
=
aOther
.
AsModOffset
(
)
;
case
Frame
:
:
Kind
:
:
PC
:
return
aFrame
.
AsPC
(
)
=
=
aOther
.
AsPC
(
)
;
default
:
MOZ_CRASH
(
)
;
}
}
bool
IsSameAsEntry
(
const
char
*
aEntry
const
char
*
aOther
)
const
{
return
IsInBuffer
(
aEntry
)
?
!
strcmp
(
aEntry
aOther
)
:
(
aEntry
=
=
aOther
)
;
}
size_t
AvailableBufferSize
(
)
const
{
return
mBuffer
.
capacity
(
)
-
mBuffer
.
length
(
)
;
}
bool
EnsureBufferCapacity
(
size_t
aCapacity
)
{
return
mBuffer
.
reserve
(
aCapacity
)
&
&
mBuffer
.
reserve
(
mBuffer
.
capacity
(
)
)
;
}
void
InfallibleAppendViaBuffer
(
const
char
*
aText
size_t
aLength
)
;
bool
AppendViaBuffer
(
const
char
*
aText
size_t
aLength
)
;
}
;
}
namespace
IPC
{
template
<
>
class
ParamTraits
<
mozilla
:
:
HangStack
:
:
ModOffset
>
{
public
:
typedef
mozilla
:
:
HangStack
:
:
ModOffset
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
;
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
;
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
HangStack
:
:
Frame
:
:
Kind
>
:
public
ContiguousEnumSerializer
<
mozilla
:
:
HangStack
:
:
Frame
:
:
Kind
mozilla
:
:
HangStack
:
:
Frame
:
:
Kind
:
:
STRING
mozilla
:
:
HangStack
:
:
Frame
:
:
Kind
:
:
END
>
{
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
HangStack
>
{
typedef
mozilla
:
:
HangStack
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
;
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
;
}
;
}
#
endif
