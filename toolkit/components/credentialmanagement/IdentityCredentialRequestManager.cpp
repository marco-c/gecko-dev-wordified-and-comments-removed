#
include
"
IdentityCredentialRequestManager
.
h
"
#
include
"
mozilla
/
dom
/
IdentityCredentialBinding
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
namespace
mozilla
{
NS_IMPL_ISUPPORTS0
(
IdentityCredentialRequestManager
)
;
StaticRefPtr
<
IdentityCredentialRequestManager
>
IdentityCredentialRequestManager
:
:
sSingleton
;
IdentityCredentialRequestManager
*
IdentityCredentialRequestManager
:
:
GetInstance
(
)
{
if
(
!
sSingleton
)
{
sSingleton
=
new
IdentityCredentialRequestManager
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
return
sSingleton
;
}
nsresult
IdentityCredentialRequestManager
:
:
StorePendingRequest
(
const
nsCOMPtr
<
nsIPrincipal
>
&
aRPPrincipal
const
dom
:
:
IdentityCredentialRequestOptions
&
aRequest
const
RefPtr
<
dom
:
:
IdentityCredential
:
:
GetIPCIdentityCredentialPromise
:
:
Private
>
&
aPromise
const
RefPtr
<
dom
:
:
CanonicalBrowsingContext
>
&
aBrowsingContext
)
{
MOZ_ASSERT
(
aRPPrincipal
)
;
if
(
!
aRequest
.
mProviders
.
WasPassed
(
)
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
for
(
const
auto
&
provider
:
aRequest
.
mProviders
.
Value
(
)
)
{
if
(
!
provider
.
mLoginURL
.
WasPassed
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIURI
>
idpOriginURI
;
nsAutoCString
idpOriginString
;
if
(
provider
.
mOrigin
.
WasPassed
(
)
)
{
idpOriginString
=
provider
.
mOrigin
.
Value
(
)
;
}
else
{
idpOriginString
=
provider
.
mLoginURL
.
Value
(
)
;
}
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
idpOriginURI
)
idpOriginString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_DOM_BAD_URI
;
}
nsCOMPtr
<
nsIPrincipal
>
idpPrincipal
=
BasePrincipal
:
:
CreateContentPrincipal
(
idpOriginURI
aRPPrincipal
-
>
OriginAttributesRef
(
)
)
;
NS_ENSURE_TRUE
(
idpPrincipal
NS_ERROR_FAILURE
)
;
nsTArray
<
PendingRequestEntry
>
&
list
=
mPendingRequests
.
LookupOrInsert
(
idpPrincipal
)
;
list
.
AppendElement
(
PendingRequestEntry
(
aRPPrincipal
aRequest
aPromise
aBrowsingContext
)
)
;
}
return
NS_OK
;
}
void
IdentityCredentialRequestManager
:
:
NotifyOfStoredCredential
(
const
nsCOMPtr
<
nsIPrincipal
>
&
aIDPPrincipal
const
dom
:
:
IPCIdentityCredential
&
aCredential
)
{
MOZ_ASSERT
(
aIDPPrincipal
)
;
auto
listLookup
=
mPendingRequests
.
Lookup
(
aIDPPrincipal
)
;
if
(
listLookup
)
{
for
(
auto
&
entry
:
listLookup
.
Data
(
)
)
{
if
(
!
entry
.
mBrowsingContext
|
|
!
entry
.
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
|
|
entry
.
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
-
>
IsDiscarded
(
)
|
|
!
entry
.
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
-
>
IsCurrent
(
)
|
|
!
entry
.
mBrowsingContext
-
>
AncestorsAreCurrent
(
)
|
|
entry
.
mBrowsingContext
-
>
IsInBFCache
(
)
)
{
continue
;
}
dom
:
:
IdentityCredential
:
:
AllowedToCollectCredential
(
entry
.
mRPPrincipal
entry
.
mBrowsingContext
entry
.
mRequestOptions
aCredential
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
aCredential
entry
]
(
bool
effectiveCredential
)
{
if
(
effectiveCredential
)
{
entry
.
mPromise
-
>
Resolve
(
aCredential
__func__
)
;
}
}
[
]
(
)
{
}
)
;
}
}
}
}
