"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AddressesEngine
"
"
CreditCardsEngine
"
"
sanitizeStorageObject
"
"
AutofillRecord
"
]
;
const
{
Changeset
Store
SyncEngine
Tracker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
const
{
CryptoWrapper
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
const
{
Utils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
const
{
SCORE_INCREMENT_XLARGE
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
formAutofillStorage
:
"
resource
:
/
/
autofill
/
FormAutofillStorage
.
jsm
"
}
)
;
function
sanitizeStorageObject
(
ob
)
{
if
(
!
ob
)
{
return
null
;
}
const
allowList
=
[
"
timeCreated
"
"
timeLastUsed
"
"
timeLastModified
"
]
;
let
result
=
{
}
;
for
(
let
key
of
Object
.
keys
(
ob
)
)
{
let
origVal
=
ob
[
key
]
;
if
(
allowList
.
includes
(
key
)
)
{
result
[
key
]
=
origVal
;
}
else
if
(
typeof
origVal
=
=
"
string
"
)
{
result
[
key
]
=
"
X
"
.
repeat
(
origVal
.
length
)
;
}
else
{
result
[
key
]
=
typeof
origVal
;
}
}
return
result
;
}
function
AutofillRecord
(
collection
id
)
{
CryptoWrapper
.
call
(
this
collection
id
)
;
}
AutofillRecord
.
prototype
=
{
toEntry
(
)
{
return
Object
.
assign
(
{
guid
:
this
.
id
}
this
.
entry
)
;
}
fromEntry
(
entry
)
{
this
.
id
=
entry
.
guid
;
this
.
entry
=
entry
;
delete
this
.
entry
.
guid
;
}
cleartextToString
(
)
{
let
record
=
this
.
cleartext
;
return
JSON
.
stringify
(
{
entry
:
sanitizeStorageObject
(
record
.
entry
)
}
)
;
}
}
;
Object
.
setPrototypeOf
(
AutofillRecord
.
prototype
CryptoWrapper
.
prototype
)
;
Utils
.
deferGetSet
(
AutofillRecord
"
cleartext
"
[
"
entry
"
]
)
;
function
FormAutofillStore
(
name
engine
)
{
Store
.
call
(
this
name
engine
)
;
}
FormAutofillStore
.
prototype
=
{
_subStorageName
:
null
_storage
:
null
get
storage
(
)
{
if
(
!
this
.
_storage
)
{
this
.
_storage
=
lazy
.
formAutofillStorage
[
this
.
_subStorageName
]
;
}
return
this
.
_storage
;
}
async
getAllIDs
(
)
{
let
result
=
{
}
;
for
(
let
{
guid
}
of
await
this
.
storage
.
getAll
(
{
includeDeleted
:
true
}
)
)
{
result
[
guid
]
=
true
;
}
return
result
;
}
async
changeItemID
(
oldID
newID
)
{
this
.
storage
.
changeGUID
(
oldID
newID
)
;
}
async
itemExists
(
id
)
{
return
Boolean
(
await
this
.
storage
.
get
(
id
)
)
;
}
async
applyIncoming
(
remoteRecord
)
{
if
(
remoteRecord
.
deleted
)
{
this
.
_log
.
trace
(
"
Deleting
record
"
remoteRecord
)
;
this
.
storage
.
remove
(
remoteRecord
.
id
{
sourceSync
:
true
}
)
;
return
;
}
if
(
await
this
.
itemExists
(
remoteRecord
.
id
)
)
{
await
this
.
_doUpdateRecord
(
remoteRecord
)
;
return
;
}
let
localDupeID
=
await
this
.
storage
.
findDuplicateGUID
(
remoteRecord
.
toEntry
(
)
)
;
if
(
localDupeID
)
{
this
.
_log
.
trace
(
Deduping
local
record
{
localDupeID
}
to
remote
remoteRecord
)
;
await
this
.
changeItemID
(
localDupeID
remoteRecord
.
id
)
;
await
this
.
_doUpdateRecord
(
remoteRecord
)
;
return
;
}
this
.
_log
.
trace
(
"
Add
record
"
remoteRecord
)
;
let
entry
=
remoteRecord
.
toEntry
(
)
;
await
this
.
storage
.
add
(
entry
{
sourceSync
:
true
}
)
;
}
async
createRecord
(
id
collection
)
{
this
.
_log
.
trace
(
"
Create
record
"
id
)
;
let
record
=
new
AutofillRecord
(
collection
id
)
;
let
entry
=
await
this
.
storage
.
get
(
id
{
rawData
:
true
}
)
;
if
(
entry
)
{
record
.
fromEntry
(
entry
)
;
}
else
{
this
.
_log
.
debug
(
Failed
to
get
autofill
record
with
id
"
{
id
}
"
assuming
deleted
)
;
record
.
deleted
=
true
;
}
return
record
;
}
async
_doUpdateRecord
(
record
)
{
this
.
_log
.
trace
(
"
Updating
record
"
record
)
;
let
entry
=
record
.
toEntry
(
)
;
let
{
forkedGUID
}
=
await
this
.
storage
.
reconcile
(
entry
)
;
if
(
this
.
_log
.
level
<
=
lazy
.
Log
.
Level
.
Debug
)
{
let
forkedRecord
=
forkedGUID
?
await
this
.
storage
.
get
(
forkedGUID
)
:
null
;
let
reconciledRecord
=
await
this
.
storage
.
get
(
record
.
id
)
;
this
.
_log
.
debug
(
"
Updated
local
record
"
{
forked
:
sanitizeStorageObject
(
forkedRecord
)
updated
:
sanitizeStorageObject
(
reconciledRecord
)
}
)
;
}
}
}
;
Object
.
setPrototypeOf
(
FormAutofillStore
.
prototype
Store
.
prototype
)
;
function
FormAutofillTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
}
FormAutofillTracker
.
prototype
=
{
async
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
formautofill
-
storage
-
changed
"
)
{
return
;
}
if
(
subject
&
&
subject
.
wrappedJSObject
&
&
subject
.
wrappedJSObject
.
sourceSync
)
{
return
;
}
switch
(
data
)
{
case
"
add
"
:
case
"
update
"
:
case
"
remove
"
:
this
.
score
+
=
SCORE_INCREMENT_XLARGE
;
break
;
default
:
this
.
_log
.
debug
(
"
unrecognized
autofill
notification
"
data
)
;
break
;
}
}
onStart
(
)
{
Services
.
obs
.
addObserver
(
this
"
formautofill
-
storage
-
changed
"
)
;
}
onStop
(
)
{
Services
.
obs
.
removeObserver
(
this
"
formautofill
-
storage
-
changed
"
)
;
}
}
;
Object
.
setPrototypeOf
(
FormAutofillTracker
.
prototype
Tracker
.
prototype
)
;
class
AutofillChangeset
extends
Changeset
{
constructor
(
)
{
super
(
)
;
}
getModifiedTimestamp
(
id
)
{
throw
new
Error
(
"
Don
'
t
use
timestamps
to
resolve
autofill
merge
conflicts
"
)
;
}
has
(
id
)
{
let
change
=
this
.
changes
[
id
]
;
if
(
change
)
{
return
!
change
.
synced
;
}
return
false
;
}
delete
(
id
)
{
let
change
=
this
.
changes
[
id
]
;
if
(
change
)
{
change
.
synced
=
true
;
}
}
}
function
FormAutofillEngine
(
service
name
)
{
SyncEngine
.
call
(
this
name
service
)
;
}
FormAutofillEngine
.
prototype
=
{
syncPriority
:
5
async
_syncStartup
(
)
{
await
lazy
.
formAutofillStorage
.
initialize
(
)
;
await
SyncEngine
.
prototype
.
_syncStartup
.
call
(
this
)
;
}
async
_reconcile
(
)
{
return
true
;
}
emptyChangeset
(
)
{
return
new
AutofillChangeset
(
)
;
}
async
_uploadOutgoing
(
)
{
this
.
_modified
.
replace
(
this
.
_store
.
storage
.
pullSyncChanges
(
)
)
;
await
SyncEngine
.
prototype
.
_uploadOutgoing
.
call
(
this
)
;
}
async
pullAllChanges
(
)
{
return
{
}
;
}
async
pullNewChanges
(
)
{
return
{
}
;
}
async
trackRemainingChanges
(
)
{
this
.
_store
.
storage
.
pushSyncChanges
(
this
.
_modified
.
changes
)
;
}
_deleteId
(
id
)
{
this
.
_noteDeletedId
(
id
)
;
}
async
_resetClient
(
)
{
await
lazy
.
formAutofillStorage
.
initialize
(
)
;
this
.
_store
.
storage
.
resetSync
(
)
;
}
async
_wipeClient
(
)
{
await
lazy
.
formAutofillStorage
.
initialize
(
)
;
this
.
_store
.
storage
.
removeAll
(
{
sourceSync
:
true
}
)
;
}
}
;
Object
.
setPrototypeOf
(
FormAutofillEngine
.
prototype
SyncEngine
.
prototype
)
;
function
AddressesRecord
(
collection
id
)
{
AutofillRecord
.
call
(
this
collection
id
)
;
}
AddressesRecord
.
prototype
=
{
_logName
:
"
Sync
.
Record
.
Addresses
"
}
;
Object
.
setPrototypeOf
(
AddressesRecord
.
prototype
AutofillRecord
.
prototype
)
;
function
AddressesStore
(
name
engine
)
{
FormAutofillStore
.
call
(
this
name
engine
)
;
}
AddressesStore
.
prototype
=
{
_subStorageName
:
"
addresses
"
}
;
Object
.
setPrototypeOf
(
AddressesStore
.
prototype
FormAutofillStore
.
prototype
)
;
function
AddressesEngine
(
service
)
{
FormAutofillEngine
.
call
(
this
service
"
Addresses
"
)
;
}
AddressesEngine
.
prototype
=
{
_trackerObj
:
FormAutofillTracker
_storeObj
:
AddressesStore
_recordObj
:
AddressesRecord
get
prefName
(
)
{
return
"
addresses
"
;
}
}
;
Object
.
setPrototypeOf
(
AddressesEngine
.
prototype
FormAutofillEngine
.
prototype
)
;
function
CreditCardsRecord
(
collection
id
)
{
AutofillRecord
.
call
(
this
collection
id
)
;
}
CreditCardsRecord
.
prototype
=
{
_logName
:
"
Sync
.
Record
.
CreditCards
"
}
;
Object
.
setPrototypeOf
(
CreditCardsRecord
.
prototype
AutofillRecord
.
prototype
)
;
function
CreditCardsStore
(
name
engine
)
{
FormAutofillStore
.
call
(
this
name
engine
)
;
}
CreditCardsStore
.
prototype
=
{
_subStorageName
:
"
creditCards
"
}
;
Object
.
setPrototypeOf
(
CreditCardsStore
.
prototype
FormAutofillStore
.
prototype
)
;
function
CreditCardsEngine
(
service
)
{
FormAutofillEngine
.
call
(
this
service
"
CreditCards
"
)
;
}
CreditCardsEngine
.
prototype
=
{
_trackerObj
:
FormAutofillTracker
_storeObj
:
CreditCardsStore
_recordObj
:
CreditCardsRecord
get
prefName
(
)
{
return
"
creditcards
"
;
}
}
;
Object
.
setPrototypeOf
(
CreditCardsEngine
.
prototype
FormAutofillEngine
.
prototype
)
;
