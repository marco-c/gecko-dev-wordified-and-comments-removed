"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
formAutofillStorage
"
"
FormAutofillStorage
"
]
;
const
{
FormAutofill
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
autofill
/
FormAutofill
.
jsm
"
)
;
const
{
FormAutofillStorageBase
CreditCardsBase
AddressesBase
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
autofill
/
FormAutofillStorageBase
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
CreditCard
:
"
resource
:
/
/
gre
/
modules
/
CreditCard
.
jsm
"
FormAutofillUtils
:
"
resource
:
/
/
autofill
/
FormAutofillUtils
.
jsm
"
JSONFile
:
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
OSKeyStore
:
"
resource
:
/
/
gre
/
modules
/
OSKeyStore
.
jsm
"
}
)
;
const
PROFILE_JSON_FILE_NAME
=
"
autofill
-
profiles
.
json
"
;
class
Addresses
extends
AddressesBase
{
async
mergeIfPossible
(
guid
address
strict
)
{
this
.
log
.
debug
(
mergeIfPossible
:
{
guid
}
)
;
let
addressFound
=
this
.
_findByGUID
(
guid
)
;
if
(
!
addressFound
)
{
throw
new
Error
(
"
No
matching
address
.
"
)
;
}
let
addressToMerge
=
this
.
_clone
(
address
)
;
this
.
_normalizeRecord
(
addressToMerge
strict
)
;
let
hasMatchingField
=
false
;
let
country
=
addressFound
.
country
|
|
addressToMerge
.
country
|
|
FormAutofill
.
DEFAULT_REGION
;
let
collators
=
lazy
.
FormAutofillUtils
.
getSearchCollators
(
country
)
;
for
(
let
field
of
this
.
VALID_FIELDS
)
{
let
existingField
=
addressFound
[
field
]
;
let
incomingField
=
addressToMerge
[
field
]
;
if
(
incomingField
!
=
=
undefined
&
&
existingField
!
=
=
undefined
)
{
if
(
incomingField
!
=
existingField
)
{
if
(
field
=
=
"
street
-
address
"
&
&
lazy
.
FormAutofillUtils
.
compareStreetAddress
(
existingField
incomingField
collators
)
)
{
if
(
existingField
.
split
(
"
\
n
"
)
.
length
>
=
incomingField
.
split
(
"
\
n
"
)
.
length
)
{
addressToMerge
[
field
]
=
existingField
;
}
}
else
if
(
field
!
=
"
street
-
address
"
&
&
lazy
.
FormAutofillUtils
.
strCompare
(
existingField
incomingField
collators
)
)
{
addressToMerge
[
field
]
=
existingField
;
}
else
{
this
.
log
.
debug
(
"
Conflicts
:
field
"
field
"
has
different
value
.
"
)
;
return
false
;
}
}
hasMatchingField
=
true
;
}
}
if
(
!
hasMatchingField
)
{
this
.
log
.
debug
(
"
Unable
to
merge
because
no
field
has
the
same
value
"
)
;
return
false
;
}
let
noNeedToUpdate
=
this
.
VALID_FIELDS
.
every
(
field
=
>
{
if
(
addressFound
[
field
]
=
=
=
undefined
)
{
return
!
addressToMerge
[
field
]
;
}
return
(
addressToMerge
[
field
]
=
=
=
undefined
|
|
addressFound
[
field
]
=
=
=
addressToMerge
[
field
]
)
;
}
)
;
if
(
noNeedToUpdate
)
{
return
true
;
}
await
this
.
update
(
guid
addressToMerge
true
)
;
return
true
;
}
}
class
CreditCards
extends
CreditCardsBase
{
constructor
(
store
)
{
super
(
store
)
;
}
async
_encryptNumber
(
creditCard
)
{
if
(
!
(
"
cc
-
number
-
encrypted
"
in
creditCard
)
)
{
if
(
"
cc
-
number
"
in
creditCard
)
{
let
ccNumber
=
creditCard
[
"
cc
-
number
"
]
;
if
(
lazy
.
CreditCard
.
isValidNumber
(
ccNumber
)
)
{
creditCard
[
"
cc
-
number
"
]
=
lazy
.
CreditCard
.
getLongMaskedNumber
(
ccNumber
)
;
}
else
{
creditCard
[
"
cc
-
number
"
]
=
"
*
"
.
repeat
(
ccNumber
.
length
)
;
}
creditCard
[
"
cc
-
number
-
encrypted
"
]
=
await
lazy
.
OSKeyStore
.
encrypt
(
ccNumber
)
;
}
else
{
creditCard
[
"
cc
-
number
-
encrypted
"
]
=
"
"
;
}
}
}
async
mergeIfPossible
(
guid
creditCard
)
{
this
.
log
.
debug
(
mergeIfPossible
:
{
guid
}
)
;
if
(
!
creditCard
[
"
cc
-
number
"
]
)
{
return
false
;
}
let
creditCardFound
=
await
this
.
get
(
guid
{
rawData
:
true
}
)
;
if
(
!
creditCardFound
)
{
throw
new
Error
(
"
No
matching
credit
card
.
"
)
;
}
let
creditCardToMerge
=
this
.
_clone
(
creditCard
)
;
this
.
_normalizeRecord
(
creditCardToMerge
)
;
for
(
let
field
of
this
.
VALID_FIELDS
)
{
let
existingField
=
creditCardFound
[
field
]
;
if
(
field
=
=
"
cc
-
number
"
&
&
(
!
existingField
|
|
!
creditCardToMerge
[
field
]
)
)
{
return
false
;
}
if
(
!
creditCardToMerge
[
field
]
&
&
typeof
existingField
!
=
"
undefined
"
)
{
creditCardToMerge
[
field
]
=
existingField
;
}
let
incomingField
=
creditCardToMerge
[
field
]
;
if
(
incomingField
&
&
existingField
)
{
if
(
incomingField
!
=
existingField
)
{
this
.
log
.
debug
(
"
Conflicts
:
field
"
field
"
has
different
value
.
"
)
;
return
false
;
}
}
}
let
exactlyMatch
=
this
.
VALID_FIELDS
.
every
(
field
=
>
creditCardFound
[
field
]
=
=
=
creditCardToMerge
[
field
]
)
;
if
(
exactlyMatch
)
{
return
true
;
}
await
this
.
update
(
guid
creditCardToMerge
true
)
;
return
true
;
}
}
class
FormAutofillStorage
extends
FormAutofillStorageBase
{
constructor
(
path
)
{
super
(
path
)
;
}
getAddresses
(
)
{
if
(
!
this
.
_addresses
)
{
this
.
_store
.
ensureDataReady
(
)
;
this
.
_addresses
=
new
Addresses
(
this
.
_store
)
;
}
return
this
.
_addresses
;
}
getCreditCards
(
)
{
if
(
!
this
.
_creditCards
)
{
this
.
_store
.
ensureDataReady
(
)
;
this
.
_creditCards
=
new
CreditCards
(
this
.
_store
)
;
}
return
this
.
_creditCards
;
}
_initializeStore
(
)
{
return
new
lazy
.
JSONFile
(
{
path
:
this
.
_path
dataPostProcessor
:
this
.
_dataPostProcessor
.
bind
(
this
)
}
)
;
}
_dataPostProcessor
(
data
)
{
data
.
version
=
this
.
version
;
if
(
!
data
.
addresses
)
{
data
.
addresses
=
[
]
;
}
if
(
!
data
.
creditCards
)
{
data
.
creditCards
=
[
]
;
}
return
data
;
}
}
const
formAutofillStorage
=
new
FormAutofillStorage
(
PathUtils
.
join
(
PathUtils
.
profileDir
PROFILE_JSON_FILE_NAME
)
)
;
