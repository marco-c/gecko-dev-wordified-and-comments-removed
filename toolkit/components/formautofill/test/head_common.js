"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
DownloadPaths
"
"
resource
:
/
/
gre
/
modules
/
DownloadPaths
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FormAutofill
"
"
resource
:
/
/
gre
/
modules
/
FormAutofill
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
var
TestUtils
=
{
waitForTick
(
)
{
return
new
Promise
(
resolve
=
>
executeSoon
(
resolve
)
)
;
}
waitMs
(
aTimeMs
)
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
aTimeMs
)
)
;
}
waitForNotification
(
aTopic
)
{
Output
.
print
(
"
Waiting
for
notification
:
'
"
+
aTopic
+
"
'
.
"
)
;
return
new
Promise
(
resolve
=
>
Services
.
obs
.
addObserver
(
function
observe
(
aSubject
aTopic
aData
)
{
Services
.
obs
.
removeObserver
(
observe
aTopic
)
;
resolve
(
[
aSubject
aData
]
)
;
}
aTopic
)
)
;
}
waitForEvent
(
aTarget
aEventName
aUseCapture
=
false
)
{
Output
.
print
(
"
Waiting
for
event
:
'
"
+
aEventName
+
"
'
on
"
+
aTarget
+
"
.
"
)
;
return
new
Promise
(
resolve
=
>
aTarget
.
addEventListener
(
aEventName
function
(
.
.
.
aArgs
)
{
resolve
(
.
.
.
aArgs
)
;
}
{
capture
:
aUseCapture
once
:
true
}
)
)
;
}
_fileCounter
:
Math
.
floor
(
Math
.
random
(
)
*
1000000
)
async
getTempFile
(
aLeafName
)
{
let
[
base
ext
]
=
DownloadPaths
.
splitBaseNameAndExtension
(
aLeafName
)
;
let
leafName
=
base
+
"
-
"
+
this
.
_fileCounter
+
ext
;
this
.
_fileCounter
+
+
;
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
tmpDir
leafName
)
;
Assert
.
ok
(
!
(
await
OS
.
File
.
exists
(
path
)
)
)
;
add_termination_task
(
async
function
(
)
{
if
(
await
OS
.
File
.
exists
(
path
)
)
{
await
OS
.
File
.
remove
(
path
)
;
}
}
)
;
return
path
;
}
}
;
var
FormAutofillTest
=
{
requestAutocompleteResponse
:
null
async
showUI
(
aFormAutofillData
)
{
Output
.
print
(
"
Opening
UI
with
data
:
"
+
JSON
.
stringify
(
aFormAutofillData
)
)
;
let
promiseUIWindow
=
TestUtils
.
waitForNotification
(
"
formautofill
-
window
-
initialized
"
)
;
let
ui
=
await
FormAutofill
.
integration
.
createRequestAutocompleteUI
(
aFormAutofillData
)
;
let
promiseResult
=
ui
.
show
(
)
;
return
{
uiWindow
:
(
await
promiseUIWindow
)
[
0
]
promiseResult
}
;
}
}
;
var
TestData
=
{
get
requestEmailOnly
(
)
{
return
{
sections
:
[
{
name
:
"
"
addressSections
:
[
{
addressType
:
"
"
fields
:
[
{
fieldName
:
"
email
"
contactType
:
"
"
}
]
}
]
}
]
}
;
}
}
;
add_task_in_parent_process
(
function
(
)
{
let
mockIntegrationFn
=
base
=
>
(
{
async
createRequestAutocompleteUI
(
)
{
if
(
FormAutofillTest
.
requestAutocompleteResponse
=
=
=
null
)
{
return
await
base
.
createRequestAutocompleteUI
.
apply
(
this
arguments
)
;
}
return
{
async
show
(
)
{
let
response
=
FormAutofillTest
.
requestAutocompleteResponse
;
Output
.
print
(
"
Mock
UI
response
:
"
+
JSON
.
stringify
(
response
)
)
;
return
response
;
}
}
;
}
}
)
;
FormAutofill
.
registerIntegration
(
mockIntegrationFn
)
;
add_termination_task
(
function
(
)
{
FormAutofill
.
unregisterIntegration
(
mockIntegrationFn
)
;
}
)
;
}
)
;
add_task_in_both_processes
(
function
(
)
{
Services
.
prefs
.
setBoolPref
(
"
dom
.
forms
.
requestAutocomplete
"
true
)
;
add_termination_task
(
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
dom
.
forms
.
requestAutocomplete
"
)
;
}
)
;
}
)
;
