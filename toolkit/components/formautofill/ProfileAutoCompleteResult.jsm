"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AddressResult
"
"
CreditCardResult
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
CreditCard
:
"
resource
:
/
/
gre
/
modules
/
CreditCard
.
jsm
"
FormAutofillUtils
:
"
resource
:
/
/
autofill
/
FormAutofillUtils
.
jsm
"
}
)
;
class
ProfileAutoCompleteResult
{
constructor
(
searchString
focusedFieldName
allFieldNames
matchingProfiles
{
resultCode
=
null
isSecure
=
true
isInputAutofilled
=
false
}
)
{
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIAutoCompleteResult
"
]
)
;
this
.
searchString
=
searchString
;
this
.
_focusedFieldName
=
focusedFieldName
;
this
.
_matchingProfiles
=
matchingProfiles
;
this
.
defaultIndex
=
0
;
this
.
errorDescription
=
"
"
;
this
.
_isSecure
=
isSecure
;
this
.
_isInputAutofilled
=
isInputAutofilled
;
this
.
_allFieldNames
=
[
.
.
.
this
.
_matchingProfiles
.
reduce
(
(
fieldSet
curProfile
)
=
>
{
for
(
let
field
of
Object
.
keys
(
curProfile
)
)
{
fieldSet
.
add
(
field
)
;
}
return
fieldSet
;
}
new
Set
(
)
)
]
.
filter
(
field
=
>
allFieldNames
.
includes
(
field
)
)
;
if
(
isInputAutofilled
)
{
resultCode
=
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
;
}
if
(
resultCode
)
{
this
.
searchResult
=
resultCode
;
}
else
if
(
matchingProfiles
.
length
)
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_SUCCESS
;
}
else
{
this
.
searchResult
=
Ci
.
nsIAutoCompleteResult
.
RESULT_NOMATCH
;
}
this
.
_popupLabels
=
this
.
_generateLabels
(
this
.
_focusedFieldName
this
.
_allFieldNames
this
.
_matchingProfiles
)
;
}
get
matchCount
(
)
{
return
this
.
_popupLabels
.
length
;
}
_checkIndexBounds
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
_popupLabels
.
length
)
{
throw
Components
.
Exception
(
"
Index
out
of
range
.
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
}
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
{
return
"
"
;
}
_generateLabels
(
focusedFieldName
allFieldNames
profiles
)
{
}
getValueAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
"
"
;
}
getLabelAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
let
label
=
this
.
_popupLabels
[
index
]
;
if
(
typeof
label
=
=
"
string
"
)
{
return
label
;
}
return
JSON
.
stringify
(
label
)
;
}
getCommentAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
JSON
.
stringify
(
this
.
_matchingProfiles
[
index
]
)
;
}
getStyleAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
if
(
index
=
=
this
.
matchCount
-
1
)
{
return
"
autofill
-
footer
"
;
}
if
(
this
.
_isInputAutofilled
)
{
return
"
autofill
-
clear
-
button
"
;
}
return
"
autofill
-
profile
"
;
}
getImageAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
return
"
"
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
getValueAt
(
index
)
;
}
isRemovableAt
(
index
)
{
return
true
;
}
removeValueAt
(
index
)
{
}
}
class
AddressResult
extends
ProfileAutoCompleteResult
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
}
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
{
const
GROUP_FIELDS
=
{
name
:
[
"
name
"
"
given
-
name
"
"
additional
-
name
"
"
family
-
name
"
]
"
street
-
address
"
:
[
"
street
-
address
"
"
address
-
line1
"
"
address
-
line2
"
"
address
-
line3
"
]
"
country
-
name
"
:
[
"
country
"
"
country
-
name
"
]
tel
:
[
"
tel
"
"
tel
-
country
-
code
"
"
tel
-
national
"
"
tel
-
area
-
code
"
"
tel
-
local
"
"
tel
-
local
-
prefix
"
"
tel
-
local
-
suffix
"
]
}
;
const
secondaryLabelOrder
=
[
"
street
-
address
"
"
name
"
"
address
-
level3
"
"
address
-
level2
"
"
organization
"
"
address
-
level1
"
"
country
-
name
"
"
postal
-
code
"
"
tel
"
"
email
"
]
;
for
(
let
field
in
GROUP_FIELDS
)
{
if
(
GROUP_FIELDS
[
field
]
.
includes
(
focusedFieldName
)
)
{
focusedFieldName
=
field
;
break
;
}
}
for
(
const
currentFieldName
of
secondaryLabelOrder
)
{
if
(
focusedFieldName
=
=
currentFieldName
|
|
!
profile
[
currentFieldName
]
)
{
continue
;
}
let
matching
=
GROUP_FIELDS
[
currentFieldName
]
?
allFieldNames
.
some
(
fieldName
=
>
GROUP_FIELDS
[
currentFieldName
]
.
includes
(
fieldName
)
)
:
allFieldNames
.
includes
(
currentFieldName
)
;
if
(
matching
)
{
if
(
currentFieldName
=
=
"
street
-
address
"
&
&
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
)
{
return
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
;
}
return
profile
[
currentFieldName
]
;
}
}
return
"
"
;
}
_generateLabels
(
focusedFieldName
allFieldNames
profiles
)
{
if
(
this
.
_isInputAutofilled
)
{
return
[
{
primary
:
"
"
secondary
:
"
"
}
{
primary
:
"
"
secondary
:
"
"
}
]
;
}
let
labels
=
profiles
.
filter
(
profile
=
>
{
return
!
!
profile
[
focusedFieldName
]
;
}
)
.
map
(
profile
=
>
{
let
primaryLabel
=
profile
[
focusedFieldName
]
;
if
(
focusedFieldName
=
=
"
street
-
address
"
&
&
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
)
{
primaryLabel
=
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
;
}
return
{
primary
:
primaryLabel
secondary
:
this
.
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
}
;
}
)
;
labels
.
push
(
{
primary
:
"
"
secondary
:
"
"
categories
:
lazy
.
FormAutofillUtils
.
getCategoriesFromFieldNames
(
this
.
_allFieldNames
)
focusedCategory
:
lazy
.
FormAutofillUtils
.
getCategoryFromFieldName
(
this
.
_focusedFieldName
)
}
)
;
return
labels
;
}
}
class
CreditCardResult
extends
ProfileAutoCompleteResult
{
constructor
(
.
.
.
args
)
{
super
(
.
.
.
args
)
;
this
.
_cardTypes
=
this
.
_generateCardTypes
(
this
.
_focusedFieldName
this
.
_allFieldNames
this
.
_matchingProfiles
)
;
}
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
{
const
GROUP_FIELDS
=
{
"
cc
-
name
"
:
[
"
cc
-
name
"
"
cc
-
given
-
name
"
"
cc
-
additional
-
name
"
"
cc
-
family
-
name
"
]
"
cc
-
exp
"
:
[
"
cc
-
exp
"
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
]
}
;
const
secondaryLabelOrder
=
[
"
cc
-
number
"
"
cc
-
name
"
"
cc
-
exp
"
]
;
for
(
let
field
in
GROUP_FIELDS
)
{
if
(
GROUP_FIELDS
[
field
]
.
includes
(
focusedFieldName
)
)
{
focusedFieldName
=
field
;
break
;
}
}
for
(
const
currentFieldName
of
secondaryLabelOrder
)
{
if
(
focusedFieldName
=
=
currentFieldName
|
|
!
profile
[
currentFieldName
]
)
{
continue
;
}
let
matching
=
GROUP_FIELDS
[
currentFieldName
]
?
allFieldNames
.
some
(
fieldName
=
>
GROUP_FIELDS
[
currentFieldName
]
.
includes
(
fieldName
)
)
:
allFieldNames
.
includes
(
currentFieldName
)
;
if
(
matching
)
{
if
(
currentFieldName
=
=
"
cc
-
number
"
)
{
let
{
affix
label
}
=
lazy
.
CreditCard
.
formatMaskedNumber
(
profile
[
currentFieldName
]
)
;
return
affix
+
label
;
}
return
profile
[
currentFieldName
]
;
}
}
return
"
"
;
}
_generateLabels
(
focusedFieldName
allFieldNames
profiles
)
{
if
(
!
this
.
_isSecure
)
{
let
brandName
=
lazy
.
FormAutofillUtils
.
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
return
[
lazy
.
FormAutofillUtils
.
stringBundle
.
formatStringFromName
(
"
insecureFieldWarningDescription
"
[
brandName
]
)
]
;
}
if
(
this
.
_isInputAutofilled
)
{
return
[
{
primary
:
"
"
secondary
:
"
"
}
{
primary
:
"
"
secondary
:
"
"
}
]
;
}
let
labels
=
profiles
.
filter
(
profile
=
>
{
return
!
!
profile
[
focusedFieldName
]
;
}
)
.
map
(
profile
=
>
{
let
primaryAffix
;
let
primary
=
profile
[
focusedFieldName
]
;
if
(
focusedFieldName
=
=
"
cc
-
number
"
)
{
let
{
affix
label
}
=
lazy
.
CreditCard
.
formatMaskedNumber
(
primary
)
;
primaryAffix
=
affix
;
primary
=
label
;
}
const
secondary
=
this
.
_getSecondaryLabel
(
focusedFieldName
allFieldNames
profile
)
;
let
ccTypeName
;
try
{
ccTypeName
=
lazy
.
FormAutofillUtils
.
stringBundle
.
GetStringFromName
(
cardNetwork
.
{
profile
[
"
cc
-
type
"
]
}
)
;
}
catch
(
e
)
{
ccTypeName
=
null
;
}
const
ariaLabel
=
[
ccTypeName
primaryAffix
primary
secondary
]
.
filter
(
chunk
=
>
!
!
chunk
)
.
join
(
"
"
)
;
return
{
primaryAffix
primary
secondary
ariaLabel
}
;
}
)
;
labels
.
push
(
{
primary
:
"
"
secondary
:
"
"
}
)
;
return
labels
;
}
_generateCardTypes
(
focusedFieldName
allFieldNames
profiles
)
{
if
(
this
.
_isInputAutofilled
)
{
return
[
"
"
"
"
]
;
}
let
cardTypes
=
profiles
.
filter
(
profile
=
>
{
return
!
!
profile
[
focusedFieldName
]
;
}
)
.
map
(
profile
=
>
profile
[
"
cc
-
type
"
]
)
;
cardTypes
.
push
(
"
"
)
;
return
cardTypes
;
}
getStyleAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
if
(
!
this
.
_isSecure
)
{
return
"
autofill
-
insecureWarning
"
;
}
return
super
.
getStyleAt
(
index
)
;
}
getImageAt
(
index
)
{
this
.
_checkIndexBounds
(
index
)
;
let
network
=
this
.
_cardTypes
[
index
]
;
return
lazy
.
CreditCard
.
getCreditCardLogo
(
network
)
;
}
}
