"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
FormAutofillHeuristics
"
"
FieldScanner
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
FormAutofill
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
autofill
/
FormAutofill
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormAutofillUtils
"
"
resource
:
/
/
autofill
/
FormAutofillUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
CreditCard
:
"
resource
:
/
/
gre
/
modules
/
CreditCard
.
jsm
"
creditCardRulesets
:
"
resource
:
/
/
autofill
/
CreditCardRuleset
.
jsm
"
FormAutofillUtils
:
"
resource
:
/
/
autofill
/
FormAutofillUtils
.
jsm
"
LabelUtils
:
"
resource
:
/
/
autofill
/
FormAutofillUtils
.
jsm
"
}
)
;
this
.
log
=
null
;
FormAutofill
.
defineLazyLogGetter
(
this
EXPORTED_SYMBOLS
[
0
]
)
;
const
PREF_HEURISTICS_ENABLED
=
"
extensions
.
formautofill
.
heuristics
.
enabled
"
;
const
PREF_SECTION_ENABLED
=
"
extensions
.
formautofill
.
section
.
enabled
"
;
const
DEFAULT_SECTION_NAME
=
"
-
moz
-
section
-
default
"
;
const
MULTI_FIELD_NAMES
=
[
"
address
-
level3
"
"
address
-
level2
"
"
address
-
level1
"
"
tel
"
"
postal
-
code
"
"
email
"
"
street
-
address
"
]
;
const
MULTI_N_FIELD_NAMES
=
{
"
cc
-
number
"
:
4
}
;
class
FieldScanner
{
constructor
(
elements
{
allowDuplicates
=
false
sectionEnabled
=
true
}
)
{
this
.
_elementsWeakRef
=
Cu
.
getWeakReference
(
elements
)
;
this
.
fieldDetails
=
[
]
;
this
.
_parsingIndex
=
0
;
this
.
_sections
=
[
]
;
this
.
_allowDuplicates
=
allowDuplicates
;
this
.
_sectionEnabled
=
sectionEnabled
;
}
get
_elements
(
)
{
return
this
.
_elementsWeakRef
.
get
(
)
;
}
get
parsingIndex
(
)
{
return
this
.
_parsingIndex
;
}
set
parsingIndex
(
index
)
{
if
(
index
>
this
.
_elements
.
length
)
{
throw
new
Error
(
"
The
parsing
index
is
out
of
range
.
"
)
;
}
this
.
_parsingIndex
=
index
;
}
getFieldDetailByIndex
(
index
)
{
if
(
index
>
=
this
.
_elements
.
length
)
{
throw
new
Error
(
The
index
{
index
}
is
out
of
range
.
(
{
this
.
_elements
.
length
}
)
)
;
}
if
(
index
<
this
.
fieldDetails
.
length
)
{
return
this
.
fieldDetails
[
index
]
;
}
for
(
let
i
=
this
.
fieldDetails
.
length
;
i
<
index
+
1
;
i
+
+
)
{
this
.
pushDetail
(
)
;
}
return
this
.
fieldDetails
[
index
]
;
}
get
parsingFinished
(
)
{
return
this
.
parsingIndex
>
=
this
.
_elements
.
length
;
}
_pushToSection
(
name
fieldDetail
)
{
for
(
let
section
of
this
.
_sections
)
{
if
(
section
.
name
=
=
name
)
{
section
.
fieldDetails
.
push
(
fieldDetail
)
;
return
;
}
}
this
.
_sections
.
push
(
{
name
fieldDetails
:
[
fieldDetail
]
}
)
;
}
_mergeNextNFields
(
mergeNextNFields
currentType
fieldDetails
i
createNewSection
)
{
if
(
mergeNextNFields
)
{
mergeNextNFields
-
-
;
}
else
{
let
nextN
=
MULTI_N_FIELD_NAMES
[
currentType
]
-
2
;
let
array
=
fieldDetails
.
slice
(
i
+
1
i
+
1
+
nextN
)
;
if
(
array
.
length
=
=
nextN
&
&
array
.
every
(
detail
=
>
detail
.
fieldName
=
=
currentType
)
)
{
mergeNextNFields
=
nextN
;
}
else
{
createNewSection
=
true
;
}
}
return
{
mergeNextNFields
createNewSection
}
;
}
_classifySections
(
)
{
let
fieldDetails
=
this
.
_sections
[
0
]
.
fieldDetails
;
this
.
_sections
=
[
]
;
let
seenTypes
=
new
Set
(
)
;
let
previousType
;
let
sectionCount
=
0
;
let
mergeNextNFields
=
0
;
for
(
let
i
=
0
;
i
<
fieldDetails
.
length
;
i
+
+
)
{
let
currentType
=
fieldDetails
[
i
]
.
fieldName
;
if
(
!
currentType
)
{
continue
;
}
let
createNewSection
=
false
;
if
(
seenTypes
.
has
(
currentType
)
)
{
if
(
previousType
!
=
currentType
)
{
createNewSection
=
true
;
}
else
if
(
MULTI_FIELD_NAMES
.
includes
(
currentType
)
)
{
}
else
if
(
currentType
in
MULTI_N_FIELD_NAMES
)
{
(
{
mergeNextNFields
createNewSection
}
=
this
.
_mergeNextNFields
(
mergeNextNFields
currentType
fieldDetails
i
createNewSection
)
)
;
}
else
{
createNewSection
=
true
;
}
}
if
(
createNewSection
)
{
mergeNextNFields
=
0
;
seenTypes
.
clear
(
)
;
sectionCount
+
+
;
}
previousType
=
currentType
;
seenTypes
.
add
(
currentType
)
;
this
.
_pushToSection
(
DEFAULT_SECTION_NAME
+
"
-
"
+
sectionCount
fieldDetails
[
i
]
)
;
}
}
getSectionFieldDetails
(
)
{
if
(
!
this
.
_sectionEnabled
)
{
return
this
.
_getFinalDetails
(
this
.
fieldDetails
)
;
}
if
(
!
this
.
_sections
.
length
)
{
return
[
]
;
}
if
(
this
.
_sections
.
length
=
=
1
&
&
this
.
_sections
[
0
]
.
name
=
=
DEFAULT_SECTION_NAME
)
{
this
.
_classifySections
(
)
;
}
return
this
.
_sections
.
reduce
(
(
sections
current
)
=
>
{
sections
.
push
(
.
.
.
this
.
_getFinalDetails
(
current
.
fieldDetails
)
)
;
return
sections
;
}
[
]
)
;
}
pushDetail
(
)
{
let
elementIndex
=
this
.
fieldDetails
.
length
;
if
(
elementIndex
>
=
this
.
_elements
.
length
)
{
throw
new
Error
(
"
Try
to
push
the
non
-
existing
element
info
.
"
)
;
}
let
element
=
this
.
_elements
[
elementIndex
]
;
let
info
=
FormAutofillHeuristics
.
getInfo
(
element
this
)
;
let
fieldInfo
=
{
section
:
info
?
info
.
section
:
"
"
addressType
:
info
?
info
.
addressType
:
"
"
contactType
:
info
?
info
.
contactType
:
"
"
fieldName
:
info
?
info
.
fieldName
:
"
"
elementWeakRef
:
Cu
.
getWeakReference
(
element
)
}
;
if
(
info
&
&
info
.
_reason
)
{
fieldInfo
.
_reason
=
info
.
_reason
;
}
this
.
fieldDetails
.
push
(
fieldInfo
)
;
this
.
_pushToSection
(
this
.
_getSectionName
(
fieldInfo
)
fieldInfo
)
;
}
_getSectionName
(
info
)
{
let
names
=
[
]
;
if
(
info
.
section
)
{
names
.
push
(
info
.
section
)
;
}
if
(
info
.
addressType
)
{
names
.
push
(
info
.
addressType
)
;
}
return
names
.
length
?
names
.
join
(
"
"
)
:
DEFAULT_SECTION_NAME
;
}
updateFieldName
(
index
fieldName
)
{
if
(
index
>
=
this
.
fieldDetails
.
length
)
{
throw
new
Error
(
"
Try
to
update
the
non
-
existing
field
detail
.
"
)
;
}
this
.
fieldDetails
[
index
]
.
fieldName
=
fieldName
;
}
_isSameField
(
field1
field2
)
{
return
(
field1
.
section
=
=
field2
.
section
&
&
field1
.
addressType
=
=
field2
.
addressType
&
&
field1
.
fieldName
=
=
field2
.
fieldName
&
&
!
field1
.
transform
&
&
!
field2
.
transform
)
;
}
_transformCCNumberForMultipleFields
(
creditCardFieldDetails
)
{
let
ccNumberFields
=
creditCardFieldDetails
.
filter
(
field
=
>
field
.
fieldName
=
=
"
cc
-
number
"
&
&
field
.
elementWeakRef
.
get
(
)
.
maxLength
=
=
4
)
;
if
(
ccNumberFields
.
length
=
=
4
)
{
ccNumberFields
[
0
]
.
transform
=
fullCCNumber
=
>
fullCCNumber
.
slice
(
0
4
)
;
ccNumberFields
[
1
]
.
transform
=
fullCCNumber
=
>
fullCCNumber
.
slice
(
4
8
)
;
ccNumberFields
[
2
]
.
transform
=
fullCCNumber
=
>
fullCCNumber
.
slice
(
8
12
)
;
ccNumberFields
[
3
]
.
transform
=
fullCCNumber
=
>
fullCCNumber
.
slice
(
12
16
)
;
}
}
_getFinalDetails
(
fieldDetails
)
{
let
addressFieldDetails
=
[
]
;
let
creditCardFieldDetails
=
[
]
;
for
(
let
fieldDetail
of
fieldDetails
)
{
let
fieldName
=
fieldDetail
.
fieldName
;
if
(
FormAutofillUtils
.
isAddressField
(
fieldName
)
)
{
addressFieldDetails
.
push
(
fieldDetail
)
;
}
else
if
(
FormAutofillUtils
.
isCreditCardField
(
fieldName
)
)
{
creditCardFieldDetails
.
push
(
fieldDetail
)
;
}
else
{
log
.
debug
(
"
Not
collecting
a
field
with
a
unknown
fieldName
"
fieldDetail
)
;
}
}
this
.
_transformCCNumberForMultipleFields
(
creditCardFieldDetails
)
;
return
[
{
type
:
FormAutofillUtils
.
SECTION_TYPES
.
ADDRESS
fieldDetails
:
addressFieldDetails
}
{
type
:
FormAutofillUtils
.
SECTION_TYPES
.
CREDIT_CARD
fieldDetails
:
creditCardFieldDetails
}
]
.
map
(
section
=
>
{
if
(
this
.
_allowDuplicates
)
{
return
section
;
}
let
details
=
section
.
fieldDetails
;
section
.
fieldDetails
=
details
.
filter
(
(
detail
index
)
=
>
{
let
previousFields
=
details
.
slice
(
0
index
)
;
return
!
previousFields
.
find
(
f
=
>
this
.
_isSameField
(
detail
f
)
)
;
}
)
;
return
section
;
}
)
.
filter
(
section
=
>
!
!
section
.
fieldDetails
.
length
)
;
}
elementExisting
(
index
)
{
return
index
<
this
.
_elements
.
length
;
}
getFathomField
(
element
fields
)
{
if
(
!
fields
.
length
)
{
return
null
;
}
if
(
!
this
.
_fathomConfidences
?
.
get
(
element
)
)
{
this
.
_fathomConfidences
=
new
Map
(
)
;
let
elements
=
[
]
;
if
(
this
.
_elements
?
.
includes
(
element
)
)
{
elements
=
this
.
_elements
;
}
else
{
elements
=
[
element
]
;
}
let
confidences
=
FieldScanner
.
getFormAutofillConfidences
(
elements
)
;
for
(
let
i
=
0
;
i
<
elements
.
length
;
i
+
+
)
{
this
.
_fathomConfidences
.
set
(
elements
[
i
]
confidences
[
i
]
)
;
}
}
let
elementConfidences
=
this
.
_fathomConfidences
.
get
(
element
)
;
if
(
!
elementConfidences
)
{
return
null
;
}
let
highestField
=
null
;
let
highestConfidence
=
FormAutofillUtils
.
ccHeuristicsThreshold
;
for
(
let
[
key
value
]
of
Object
.
entries
(
elementConfidences
)
)
{
if
(
!
fields
.
includes
(
key
)
)
{
continue
;
}
if
(
value
>
highestConfidence
)
{
highestConfidence
=
value
;
highestField
=
key
;
}
}
return
highestField
;
}
static
getFormAutofillConfidences
(
elements
)
{
if
(
FormAutofillUtils
.
ccHeuristicsMode
=
=
FormAutofillUtils
.
CC_FATHOM_NATIVE
)
{
let
confidences
=
ChromeUtils
.
getFormAutofillConfidences
(
elements
)
;
const
fieldNameMap
=
{
ccNumber
:
"
cc
-
number
"
ccName
:
"
cc
-
name
"
ccType
:
"
cc
-
type
"
ccExp
:
"
cc
-
exp
"
ccExpMonth
:
"
cc
-
exp
-
month
"
ccExpYear
:
"
cc
-
exp
-
year
"
}
;
return
confidences
.
map
(
c
=
>
{
let
result
=
{
}
;
for
(
let
[
fieldName
confidence
]
of
Object
.
entries
(
c
)
)
{
result
[
fieldNameMap
[
fieldName
]
]
=
confidence
;
}
return
result
;
}
)
;
}
return
elements
.
map
(
element
=
>
{
function
confidence
(
fieldName
)
{
const
ruleset
=
creditCardRulesets
[
fieldName
]
;
const
fnodes
=
ruleset
.
against
(
element
)
.
get
(
fieldName
)
;
return
fnodes
.
length
?
fnodes
[
0
]
.
scoreFor
(
fieldName
)
:
0
;
}
let
confidences
=
{
}
;
creditCardRulesets
.
types
.
map
(
fieldName
=
>
{
confidences
[
fieldName
]
=
confidence
(
fieldName
)
;
}
)
;
return
confidences
;
}
)
;
}
}
this
.
FormAutofillHeuristics
=
{
RULES
:
null
_matchContiguousSubArray
(
array
subArray
)
{
return
array
.
some
(
(
elm
i
)
=
>
subArray
.
every
(
(
sElem
j
)
=
>
sElem
=
=
array
[
i
+
j
]
)
)
;
}
_isExpirationMonthLikely
(
element
)
{
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLSelectElement
"
)
{
return
false
;
}
const
options
=
[
.
.
.
element
.
options
]
;
const
desiredValues
=
Array
(
12
)
.
fill
(
1
)
.
map
(
(
v
i
)
=
>
v
+
i
)
;
if
(
options
.
length
<
12
|
|
options
.
length
>
13
)
{
return
false
;
}
return
(
this
.
_matchContiguousSubArray
(
options
.
map
(
e
=
>
+
e
.
value
)
desiredValues
)
|
|
this
.
_matchContiguousSubArray
(
options
.
map
(
e
=
>
+
e
.
label
)
desiredValues
)
)
;
}
_isExpirationYearLikely
(
element
)
{
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLSelectElement
"
)
{
return
false
;
}
const
options
=
[
.
.
.
element
.
options
]
;
const
curYear
=
new
Date
(
)
.
getFullYear
(
)
;
const
desiredValues
=
Array
(
3
)
.
fill
(
0
)
.
map
(
(
v
i
)
=
>
v
+
curYear
+
i
)
;
return
(
this
.
_matchContiguousSubArray
(
options
.
map
(
e
=
>
+
e
.
value
)
desiredValues
)
|
|
this
.
_matchContiguousSubArray
(
options
.
map
(
e
=
>
+
e
.
label
)
desiredValues
)
)
;
}
_parsePhoneFields
(
fieldScanner
)
{
let
matchingResult
;
const
GRAMMARS
=
this
.
PHONE_FIELD_GRAMMARS
;
for
(
let
i
=
0
;
i
<
GRAMMARS
.
length
;
i
+
+
)
{
let
detailStart
=
fieldScanner
.
parsingIndex
;
let
ruleStart
=
i
;
for
(
;
i
<
GRAMMARS
.
length
&
&
GRAMMARS
[
i
]
[
0
]
&
&
fieldScanner
.
elementExisting
(
detailStart
)
;
i
+
+
detailStart
+
+
)
{
let
detail
=
fieldScanner
.
getFieldDetailByIndex
(
detailStart
)
;
if
(
!
detail
|
|
GRAMMARS
[
i
]
[
0
]
!
=
detail
.
fieldName
|
|
(
detail
.
_reason
&
&
detail
.
_reason
=
=
"
autocomplete
"
)
)
{
break
;
}
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
break
;
}
if
(
GRAMMARS
[
i
]
[
2
]
&
&
(
!
element
.
maxLength
|
|
GRAMMARS
[
i
]
[
2
]
<
element
.
maxLength
)
)
{
break
;
}
}
if
(
i
>
=
GRAMMARS
.
length
)
{
break
;
}
if
(
!
GRAMMARS
[
i
]
[
0
]
)
{
matchingResult
=
{
ruleFrom
:
ruleStart
ruleTo
:
i
}
;
break
;
}
for
(
;
i
<
GRAMMARS
.
length
;
i
+
+
)
{
if
(
!
GRAMMARS
[
i
]
[
0
]
)
{
break
;
}
}
}
let
parsedField
=
false
;
if
(
matchingResult
)
{
let
{
ruleFrom
ruleTo
}
=
matchingResult
;
let
detailStart
=
fieldScanner
.
parsingIndex
;
for
(
let
i
=
ruleFrom
;
i
<
ruleTo
;
i
+
+
)
{
fieldScanner
.
updateFieldName
(
detailStart
GRAMMARS
[
i
]
[
1
]
)
;
fieldScanner
.
parsingIndex
+
+
;
detailStart
+
+
;
parsedField
=
true
;
}
}
if
(
fieldScanner
.
parsingFinished
)
{
return
parsedField
;
}
let
nextField
=
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
)
;
if
(
nextField
&
&
nextField
.
_reason
!
=
"
autocomplete
"
&
&
fieldScanner
.
parsingIndex
>
0
)
{
const
regExpTelExtension
=
new
RegExp
(
"
\
\
bext
|
ext
\
\
b
|
extension
|
ramal
"
"
iu
"
)
;
const
previousField
=
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
-
1
)
;
const
previousFieldType
=
FormAutofillUtils
.
getCategoryFromFieldName
(
previousField
.
fieldName
)
;
if
(
previousField
&
&
previousFieldType
=
=
"
tel
"
&
&
this
.
_matchRegexp
(
nextField
.
elementWeakRef
.
get
(
)
regExpTelExtension
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
tel
-
extension
"
)
;
fieldScanner
.
parsingIndex
+
+
;
parsedField
=
true
;
}
}
return
parsedField
;
}
_parseAddressFields
(
fieldScanner
)
{
let
parsedFields
=
false
;
const
addressLines
=
[
"
address
-
line1
"
"
address
-
line2
"
"
address
-
line3
"
]
;
const
addressLineRegexps
=
{
"
address
-
line1
"
:
new
RegExp
(
"
address
[
_
-
]
?
line
(
1
|
one
)
|
address1
|
addr1
"
+
"
|
addrline1
|
address_1
"
+
"
|
indirizzo1
"
+
"
|
1
"
+
"
|
1
"
+
"
|
.
?
1
"
"
iu
"
)
"
address
-
line2
"
:
new
RegExp
(
"
address
[
_
-
]
?
line
(
2
|
two
)
|
address2
|
addr2
"
+
"
|
addrline2
|
address_2
"
+
"
|
indirizzo2
"
+
"
|
2
"
+
"
|
2
"
+
"
|
.
?
2
"
"
iu
"
)
"
address
-
line3
"
:
new
RegExp
(
"
address
[
_
-
]
?
line
(
3
|
three
)
|
address3
|
addr3
"
+
"
|
addrline3
|
address_3
"
+
"
|
indirizzo3
"
+
"
|
3
"
+
"
|
3
"
+
"
|
.
?
3
"
"
iu
"
)
}
;
while
(
!
fieldScanner
.
parsingFinished
)
{
let
detail
=
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
)
;
if
(
!
detail
|
|
!
addressLines
.
includes
(
detail
.
fieldName
)
|
|
detail
.
_reason
=
=
"
autocomplete
"
)
{
break
;
}
const
elem
=
detail
.
elementWeakRef
.
get
(
)
;
for
(
let
regexp
of
Object
.
keys
(
addressLineRegexps
)
)
{
if
(
this
.
_matchRegexp
(
elem
addressLineRegexps
[
regexp
]
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
regexp
)
;
parsedFields
=
true
;
}
}
fieldScanner
.
parsingIndex
+
+
;
}
return
parsedFields
;
}
_parseCreditCardFields
(
fieldScanner
)
{
if
(
fieldScanner
.
parsingFinished
)
{
return
false
;
}
const
savedIndex
=
fieldScanner
.
parsingIndex
;
const
detail
=
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
)
;
if
(
!
detail
|
|
(
detail
.
_reason
&
&
detail
.
_reason
=
=
"
autocomplete
"
)
)
{
return
false
;
}
const
monthAndYearFieldNames
=
[
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
]
;
if
(
!
[
"
cc
-
exp
"
"
cc
-
type
"
.
.
.
monthAndYearFieldNames
]
.
includes
(
detail
.
fieldName
)
)
{
return
false
;
}
if
(
FormAutofillUtils
.
isFathomCreditCardsEnabled
(
)
)
{
return
true
;
}
const
element
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
ChromeUtils
.
getClassName
(
element
)
=
=
"
HTMLSelectElement
"
)
{
for
(
let
option
of
element
.
querySelectorAll
(
"
option
"
)
)
{
if
(
CreditCard
.
getNetworkFromName
(
option
.
value
)
|
|
CreditCard
.
getNetworkFromName
(
option
.
text
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
type
"
)
;
fieldScanner
.
parsingIndex
+
+
;
return
true
;
}
}
}
if
(
element
.
type
=
=
"
month
"
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
exp
"
)
;
fieldScanner
.
parsingIndex
+
+
;
return
true
;
}
if
(
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
+
+
)
.
fieldName
=
=
"
cc
-
exp
-
month
"
&
&
!
fieldScanner
.
parsingFinished
&
&
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
+
+
)
.
fieldName
=
=
"
cc
-
exp
-
year
"
)
{
return
true
;
}
fieldScanner
.
parsingIndex
=
savedIndex
;
if
(
this
.
_isExpirationMonthLikely
(
element
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
exp
-
month
"
)
;
fieldScanner
.
parsingIndex
+
+
;
if
(
!
fieldScanner
.
parsingFinished
)
{
const
nextDetail
=
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
)
;
const
nextElement
=
nextDetail
.
elementWeakRef
.
get
(
)
;
if
(
this
.
_isExpirationYearLikely
(
nextElement
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
exp
-
year
"
)
;
fieldScanner
.
parsingIndex
+
+
;
return
true
;
}
}
}
fieldScanner
.
parsingIndex
=
savedIndex
;
if
(
this
.
_findMatchedFieldName
(
element
[
"
cc
-
exp
-
month
"
]
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
exp
-
month
"
)
;
fieldScanner
.
parsingIndex
+
+
;
if
(
!
fieldScanner
.
parsingFinished
)
{
const
nextDetail
=
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
)
;
const
nextElement
=
nextDetail
.
elementWeakRef
.
get
(
)
;
if
(
this
.
_findMatchedFieldName
(
nextElement
[
"
cc
-
exp
-
year
"
]
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
exp
-
year
"
)
;
fieldScanner
.
parsingIndex
+
+
;
return
true
;
}
}
}
fieldScanner
.
parsingIndex
=
savedIndex
;
if
(
this
.
_matchRegexp
(
element
/
^
mm
/
gi
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
exp
-
month
"
)
;
fieldScanner
.
parsingIndex
+
+
;
if
(
!
fieldScanner
.
parsingFinished
)
{
const
nextDetail
=
fieldScanner
.
getFieldDetailByIndex
(
fieldScanner
.
parsingIndex
)
;
const
nextElement
=
nextDetail
.
elementWeakRef
.
get
(
)
;
if
(
this
.
_matchRegexp
(
nextElement
/
^
(
yy
|
yyyy
)
/
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
exp
-
year
"
)
;
fieldScanner
.
parsingIndex
+
+
;
return
true
;
}
}
}
fieldScanner
.
parsingIndex
=
savedIndex
;
if
(
this
.
_matchRegexp
(
element
/
(
?
:
exp
.
*
date
[
^
y
\
\
n
\
\
r
]
*
|
mm
\
\
s
*
[
-
/
]
?
\
\
s
*
)
yy
(
?
:
[
^
y
]
|
)
/
gi
)
|
|
this
.
_matchRegexp
(
element
/
(
?
:
exp
.
*
date
[
^
y
\
\
n
\
\
r
]
*
|
mm
\
\
s
*
[
-
/
]
?
\
\
s
*
)
yyyy
(
?
:
[
^
y
]
|
)
/
gi
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
exp
"
)
;
fieldScanner
.
parsingIndex
+
+
;
return
true
;
}
fieldScanner
.
parsingIndex
=
savedIndex
;
if
(
this
.
_findMatchedFieldName
(
element
[
"
cc
-
exp
"
]
)
)
{
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
"
cc
-
exp
"
)
;
fieldScanner
.
parsingIndex
+
+
;
return
true
;
}
fieldScanner
.
parsingIndex
=
savedIndex
;
fieldScanner
.
updateFieldName
(
fieldScanner
.
parsingIndex
null
)
;
fieldScanner
.
parsingIndex
+
+
;
return
true
;
}
getFormInfo
(
form
allowDuplicates
=
false
)
{
const
eligibleFields
=
Array
.
from
(
form
.
elements
)
.
filter
(
elem
=
>
FormAutofillUtils
.
isFieldEligibleForAutofill
(
elem
)
)
;
if
(
eligibleFields
.
length
<
=
0
)
{
return
[
]
;
}
let
fieldScanner
=
new
FieldScanner
(
eligibleFields
{
allowDuplicates
sectionEnabled
:
this
.
_sectionEnabled
}
)
;
while
(
!
fieldScanner
.
parsingFinished
)
{
let
parsedPhoneFields
=
this
.
_parsePhoneFields
(
fieldScanner
)
;
let
parsedAddressFields
=
this
.
_parseAddressFields
(
fieldScanner
)
;
let
parsedExpirationDateFields
=
this
.
_parseCreditCardFields
(
fieldScanner
)
;
if
(
!
parsedPhoneFields
&
&
!
parsedAddressFields
&
&
!
parsedExpirationDateFields
)
{
fieldScanner
.
parsingIndex
+
+
;
}
}
LabelUtils
.
clearLabelMap
(
)
;
return
fieldScanner
.
getSectionFieldDetails
(
)
;
}
_regExpTableHashValue
(
.
.
.
signBits
)
{
return
signBits
.
reduce
(
(
p
c
i
)
=
>
p
|
(
!
!
c
<
<
i
)
0
)
;
}
_setRegExpListCache
(
regexps
b0
b1
b2
)
{
if
(
!
this
.
_regexpList
)
{
this
.
_regexpList
=
[
]
;
}
this
.
_regexpList
[
this
.
_regExpTableHashValue
(
b0
b1
b2
)
]
=
regexps
;
}
_getRegExpListCache
(
b0
b1
b2
)
{
if
(
!
this
.
_regexpList
)
{
return
null
;
}
return
this
.
_regexpList
[
this
.
_regExpTableHashValue
(
b0
b1
b2
)
]
|
|
null
;
}
_getPossibleFieldNames
(
isAutoCompleteOff
elementTagName
)
{
let
isSelectElem
=
elementTagName
=
=
"
SELECT
"
;
let
regExpListCache
=
this
.
_getRegExpListCache
(
isAutoCompleteOff
FormAutofill
.
isAutofillCreditCardsAvailable
isSelectElem
)
;
if
(
regExpListCache
)
{
return
regExpListCache
;
}
const
FIELDNAMES_IGNORING_AUTOCOMPLETE_OFF
=
[
"
cc
-
name
"
"
cc
-
number
"
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
"
cc
-
exp
"
"
cc
-
type
"
]
;
let
regexps
=
isAutoCompleteOff
?
FIELDNAMES_IGNORING_AUTOCOMPLETE_OFF
:
Object
.
keys
(
this
.
RULES
)
;
if
(
!
FormAutofill
.
isAutofillCreditCardsAvailable
)
{
regexps
=
regexps
.
filter
(
name
=
>
!
FormAutofillUtils
.
isCreditCardField
(
name
)
)
;
}
if
(
isSelectElem
)
{
const
FIELDNAMES_FOR_SELECT_ELEMENT
=
[
"
address
-
level1
"
"
address
-
level2
"
"
country
"
"
cc
-
exp
-
month
"
"
cc
-
exp
-
year
"
"
cc
-
exp
"
"
cc
-
type
"
]
;
regexps
=
regexps
.
filter
(
name
=
>
FIELDNAMES_FOR_SELECT_ELEMENT
.
includes
(
name
)
)
;
}
this
.
_setRegExpListCache
(
regexps
isAutoCompleteOff
FormAutofill
.
isAutofillCreditCardsAvailable
isSelectElem
)
;
return
regexps
;
}
getInfo
(
element
sacnner
)
{
function
infoRecordWithFieldName
(
fieldName
)
{
return
{
fieldName
section
:
"
"
addressType
:
"
"
contactType
:
"
"
}
;
}
let
info
=
element
.
getAutocompleteInfo
(
)
;
if
(
info
&
&
info
.
fieldName
&
&
info
.
fieldName
!
=
"
on
"
&
&
info
.
fieldName
!
=
"
off
"
)
{
info
.
_reason
=
"
autocomplete
"
;
return
info
;
}
if
(
!
this
.
_prefEnabled
)
{
return
null
;
}
let
isAutoCompleteOff
=
element
.
autocomplete
=
=
"
off
"
|
|
(
element
.
form
&
&
element
.
form
.
autocomplete
=
=
"
off
"
)
;
if
(
element
.
type
=
=
"
email
"
&
&
!
isAutoCompleteOff
)
{
return
infoRecordWithFieldName
(
"
email
"
)
;
}
let
fields
=
this
.
_getPossibleFieldNames
(
isAutoCompleteOff
element
.
tagName
)
;
if
(
FormAutofillUtils
.
isFathomCreditCardsEnabled
(
)
)
{
let
fathomFields
=
fields
.
filter
(
r
=
>
creditCardRulesets
.
types
.
includes
(
r
)
)
;
let
fathomField
=
sacnner
.
getFathomField
(
element
fathomFields
)
;
if
(
fathomField
)
{
return
infoRecordWithFieldName
(
fathomField
)
;
}
fields
=
fields
.
filter
(
r
=
>
!
creditCardRulesets
.
types
.
includes
(
r
)
)
;
}
if
(
fields
.
length
)
{
let
matchedFieldName
=
this
.
_findMatchedFieldName
(
element
fields
)
;
if
(
matchedFieldName
)
{
return
infoRecordWithFieldName
(
matchedFieldName
)
;
}
}
return
null
;
}
_getElementStrings
(
element
)
{
return
{
*
[
Symbol
.
iterator
]
(
)
{
yield
element
.
id
;
yield
element
.
name
;
const
labels
=
LabelUtils
.
findLabelElements
(
element
)
;
for
(
let
label
of
labels
)
{
yield
*
LabelUtils
.
extractLabelStrings
(
label
)
;
}
}
}
;
}
_findMatchedFieldName
(
element
regexps
)
{
const
getElementStrings
=
this
.
_getElementStrings
(
element
)
;
for
(
let
regexp
of
regexps
)
{
for
(
let
string
of
getElementStrings
)
{
if
(
this
.
RULES
[
regexp
]
.
test
(
string
.
toLowerCase
(
)
)
)
{
return
regexp
;
}
}
}
return
null
;
}
_matchRegexp
(
element
regexp
)
{
const
elemStrings
=
this
.
_getElementStrings
(
element
)
;
for
(
const
str
of
elemStrings
)
{
if
(
regexp
.
test
(
str
)
)
{
return
true
;
}
}
return
false
;
}
PHONE_FIELD_GRAMMARS
:
[
[
"
tel
"
"
tel
-
country
-
code
"
3
]
[
"
tel
"
"
tel
-
area
-
code
"
3
]
[
"
tel
"
"
tel
-
local
-
prefix
"
3
]
[
"
tel
"
"
tel
-
local
-
suffix
"
4
]
[
null
null
0
]
[
"
tel
"
"
tel
-
area
-
code
"
0
]
[
"
tel
"
"
tel
-
local
-
prefix
"
3
]
[
"
tel
"
"
tel
-
local
-
suffix
"
4
]
[
null
null
0
]
]
}
;
XPCOMUtils
.
defineLazyGetter
(
FormAutofillHeuristics
"
RULES
"
(
)
=
>
{
let
sandbox
=
{
}
;
const
HEURISTICS_REGEXP
=
"
resource
:
/
/
autofill
/
content
/
heuristicsRegexp
.
js
"
;
Services
.
scriptloader
.
loadSubScript
(
HEURISTICS_REGEXP
sandbox
)
;
return
sandbox
.
HeuristicsRegExp
.
RULES
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
FormAutofillHeuristics
"
_prefEnabled
"
(
)
=
>
{
return
Services
.
prefs
.
getBoolPref
(
PREF_HEURISTICS_ENABLED
)
;
}
)
;
Services
.
prefs
.
addObserver
(
PREF_HEURISTICS_ENABLED
(
)
=
>
{
FormAutofillHeuristics
.
_prefEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_HEURISTICS_ENABLED
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
FormAutofillHeuristics
"
_sectionEnabled
"
(
)
=
>
{
return
Services
.
prefs
.
getBoolPref
(
PREF_SECTION_ENABLED
)
;
}
)
;
Services
.
prefs
.
addObserver
(
PREF_SECTION_ENABLED
(
)
=
>
{
FormAutofillHeuristics
.
_sectionEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_SECTION_ENABLED
)
;
}
)
;
