"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
AddressComparison
"
"
AddressComponent
"
]
;
const
{
FormAutofill
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
autofill
/
FormAutofill
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
FormAutofillUtils
:
"
resource
:
/
/
autofill
/
FormAutofillUtils
.
jsm
"
PhoneNumber
:
"
resource
:
/
/
autofill
/
phonenumberutils
/
PhoneNumber
.
jsm
"
}
)
;
class
AddressField
{
constructor
(
collator
)
{
this
.
collator
=
collator
;
}
isEmpty
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
isSame
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
include
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
toString
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
}
class
StreetAddress
extends
AddressField
{
street_address
=
null
;
constructor
(
record
collator
)
{
super
(
collator
)
;
this
.
street_address
=
record
[
"
street
-
address
"
]
;
}
isEmpty
(
)
{
return
!
this
.
street_address
;
}
isSame
(
field
)
{
return
lazy
.
FormAutofillUtils
.
compareStreetAddress
(
this
.
street_address
field
.
street_address
this
.
collator
)
;
}
include
(
field
)
{
return
this
.
isSame
(
field
)
;
}
toString
(
)
{
return
Street
Address
:
{
this
.
street_address
}
\
n
;
}
}
class
PostalCode
extends
AddressField
{
postal_code
=
null
;
constructor
(
record
collator
)
{
super
(
collator
)
;
this
.
postal_code
=
record
[
"
postal
-
code
"
]
;
}
isEmpty
(
)
{
return
!
this
.
postal_code
;
}
isSame
(
field
)
{
return
this
.
postal_code
=
=
field
.
postal_code
;
}
include
(
field
)
{
return
this
.
isSame
(
field
)
;
}
toString
(
)
{
return
Postal
Code
:
{
this
.
postal_code
}
\
n
;
}
}
class
Country
extends
AddressField
{
country
=
null
;
constructor
(
record
collator
)
{
super
(
collator
)
;
this
.
country
=
record
.
country
;
}
isEmpty
(
)
{
return
!
this
.
country
;
}
isSame
(
field
)
{
return
this
.
country
?
.
toLowerCase
(
)
=
=
field
.
country
?
.
toLowerCase
(
)
;
}
include
(
field
)
{
return
this
.
isSame
(
field
)
;
}
toString
(
)
{
return
Country
:
{
this
.
country
}
\
n
;
}
}
class
Name
extends
AddressField
{
given
=
null
;
additional
=
null
;
family
=
null
;
constructor
(
record
collator
)
{
super
(
collator
)
;
this
.
given
=
record
[
"
given
-
name
"
]
?
?
"
"
;
this
.
additional
=
record
[
"
additional
-
name
"
]
?
?
"
"
;
this
.
family
=
record
[
"
family
-
name
"
]
?
?
"
"
;
}
isEmpty
(
)
{
return
!
this
.
given
&
&
!
this
.
additional
&
&
!
this
.
family
;
}
isSame
(
field
)
{
return
(
lazy
.
FormAutofillUtils
.
strCompare
(
this
.
given
field
.
given
this
.
collator
)
&
&
lazy
.
FormAutofillUtils
.
strCompare
(
this
.
additional
field
.
additional
this
.
collator
)
&
&
lazy
.
FormAutofillUtils
.
strCompare
(
this
.
family
field
.
family
this
.
collator
)
)
;
}
include
(
field
)
{
return
(
(
!
field
.
given
|
|
lazy
.
FormAutofillUtils
.
strInclude
(
this
.
given
field
.
given
this
.
collator
)
)
&
&
(
!
field
.
additional
|
|
lazy
.
FormAutofillUtils
.
strInclude
(
this
.
additional
field
.
additional
this
.
collator
)
)
&
&
(
!
field
.
family
|
|
lazy
.
FormAutofillUtils
.
strInclude
(
this
.
family
field
.
family
this
.
collator
)
)
)
;
}
toString
(
)
{
return
(
Given
Name
:
{
this
.
given
}
\
n
+
Middle
Name
:
{
this
.
additional
}
\
n
+
Family
Name
:
{
this
.
family
}
\
n
)
;
}
}
class
Tel
extends
AddressField
{
country
=
null
;
national
=
null
;
constructor
(
record
collator
)
{
super
(
collator
)
;
let
parsedTel
=
lazy
.
PhoneNumber
.
Parse
(
record
.
tel
)
;
this
.
country
=
parsedTel
?
.
countryCode
;
this
.
national
=
parsedTel
?
.
nationalNumber
;
}
isEmpty
(
)
{
return
!
this
.
country
&
&
!
this
.
national
;
}
isSame
(
field
)
{
return
this
.
country
=
=
field
.
country
&
&
this
.
national
=
=
field
.
national
;
}
include
(
field
)
{
if
(
this
.
country
!
=
field
.
country
&
&
field
.
country
)
{
return
false
;
}
return
this
.
national
=
=
field
.
national
;
}
toString
(
)
{
return
Telephone
Number
:
{
this
.
country
}
{
this
.
national
}
\
n
;
}
}
class
Organization
extends
AddressField
{
constructor
(
record
collator
)
{
super
(
collator
)
;
this
.
organization
=
record
.
organization
?
?
"
"
;
}
isEmpty
(
)
{
return
!
this
.
organization
;
}
isSame
(
field
)
{
let
x
=
lazy
.
FormAutofillUtils
.
strCompare
(
this
.
organization
field
.
organization
this
.
collator
)
;
return
x
;
}
include
(
field
)
{
return
lazy
.
FormAutofillUtils
.
strInclude
(
this
.
organization
field
.
organization
this
.
collator
)
;
}
toString
(
)
{
return
Company
Name
:
{
this
.
organization
}
\
n
;
}
}
class
Email
extends
AddressField
{
constructor
(
record
collator
)
{
super
(
collator
)
;
this
.
email
=
record
.
email
?
?
"
"
;
}
isEmpty
(
)
{
return
!
this
.
email
;
}
isSame
(
field
)
{
return
this
.
email
?
.
toLowerCase
(
)
=
=
field
?
.
email
.
toLowerCase
(
)
;
}
include
(
field
)
{
return
this
.
isSame
(
field
)
;
}
toString
(
)
{
return
Email
:
{
this
.
email
}
\
n
;
}
}
class
AddressComparison
{
#
result
=
{
}
;
constructor
(
addressA
addressB
)
{
for
(
const
fieldA
of
addressA
.
getAllFields
(
)
)
{
const
fieldName
=
fieldA
.
constructor
.
name
;
let
fieldB
=
addressB
.
getField
(
fieldName
)
;
this
.
#
result
[
fieldName
]
=
AddressComparison
.
compareFields
(
fieldA
fieldB
)
;
}
}
static
BOTH_EMPTY
=
0
;
static
A_IS_EMPTY
=
1
;
static
B_IS_EMPTY
=
2
;
static
A_IS_SUBSET_OF_B
=
3
;
static
A_IS_SUPERSET_OF_B
=
4
;
static
SAME
=
5
;
static
DIFFERENT
=
6
;
static
isFieldDifferent
(
result
)
{
return
[
AddressComparison
.
DIFFERENT
]
.
includes
(
result
)
;
}
static
isFieldMergeable
(
result
)
{
return
[
AddressComparison
.
A_IS_SUPERSET_OF_B
AddressComparison
.
B_IS_EMPTY
]
.
includes
(
result
)
;
}
static
compareFields
(
fieldA
fieldB
)
{
if
(
fieldA
.
isEmpty
(
)
)
{
return
fieldB
.
isEmpty
(
)
?
AddressComparison
.
BOTH_EMPTY
:
AddressComparison
.
A_IS_EMPTY
;
}
else
if
(
fieldB
.
isEmpty
(
)
)
{
return
AddressComparison
.
B_IS_EMPTY
;
}
if
(
fieldA
.
isSame
(
fieldB
)
)
{
return
AddressComparison
.
SAME
;
}
if
(
fieldB
.
include
(
fieldA
)
)
{
return
AddressComparison
.
A_IS_SUBSET_OF_B
;
}
if
(
fieldA
.
include
(
fieldB
)
)
{
return
AddressComparison
.
A_IS_SUPERSET_OF_B
;
}
return
AddressComparison
.
DIFFERENT
;
}
isDuplicate
(
)
{
return
Object
.
values
(
this
.
#
result
)
.
every
(
v
=
>
[
AddressComparison
.
BOTH_EMPTY
AddressComparison
.
SAME
AddressComparison
.
A_IS_EMPTY
AddressComparison
.
A_IS_SUBSET_OF_B
]
.
includes
(
v
)
)
;
}
isMergeable
(
)
{
let
hasMergeableField
=
false
;
for
(
const
result
of
Object
.
values
(
this
.
#
result
)
)
{
if
(
AddressComparison
.
isFieldDifferent
(
result
)
)
{
return
false
;
}
else
if
(
AddressComparison
.
isFieldMergeable
(
result
)
)
{
hasMergeableField
=
true
;
}
}
return
hasMergeableField
;
}
getMergeableFields
(
)
{
return
Object
.
entries
(
this
.
#
result
)
.
filter
(
e
=
>
AddressComparison
.
isFieldMergeable
(
e
[
1
]
)
)
.
map
(
e
=
>
e
[
0
]
)
;
}
toString
(
)
{
function
resultToString
(
result
)
{
switch
(
result
)
{
case
AddressComparison
.
BOTH_EMPTY
:
return
"
both
fields
are
empty
"
;
case
AddressComparison
.
A_IS_EMPTY
:
return
"
field
A
is
empty
"
;
case
AddressComparison
.
B_IS_EMPTY
:
return
"
field
B
is
empty
"
;
case
AddressComparison
.
A_IS_SUBSET_OF_B
:
return
"
field
A
is
a
subset
of
field
B
"
;
case
AddressComparison
.
A_IS_SUPERSET_OF_B
:
return
"
field
A
is
a
superset
of
field
B
"
;
case
AddressComparison
.
SAME
:
return
"
two
fields
are
the
same
"
;
case
AddressComparison
.
DIFFERENT
:
return
"
two
fields
are
different
"
;
}
return
"
"
;
}
let
ret
=
"
Comparison
Result
:
\
n
"
;
for
(
const
[
name
result
]
of
Object
.
entries
(
this
.
#
result
)
)
{
ret
+
=
{
name
}
:
{
resultToString
(
result
)
}
\
n
;
}
return
ret
;
}
}
class
AddressComponent
{
#
fields
=
[
]
;
constructor
(
record
)
{
const
region
=
record
.
country
?
?
FormAutofill
.
DEFAULT_REGION
;
const
collator
=
lazy
.
FormAutofillUtils
.
getSearchCollators
(
region
)
;
this
.
#
fields
.
push
(
new
StreetAddress
(
record
collator
)
)
;
this
.
#
fields
.
push
(
new
Country
(
record
collator
)
)
;
this
.
#
fields
.
push
(
new
PostalCode
(
record
collator
)
)
;
this
.
#
fields
.
push
(
new
Name
(
record
collator
)
)
;
this
.
#
fields
.
push
(
new
Tel
(
record
collator
)
)
;
this
.
#
fields
.
push
(
new
Organization
(
record
collator
)
)
;
this
.
#
fields
.
push
(
new
Email
(
record
collator
)
)
;
}
getField
(
name
)
{
return
this
.
#
fields
.
find
(
field
=
>
field
.
constructor
.
name
=
=
name
)
;
}
getAllFields
(
)
{
return
this
.
#
fields
;
}
toString
(
)
{
let
ret
=
"
"
;
for
(
const
field
of
this
.
#
fields
)
{
ret
+
=
field
.
toString
(
)
;
}
return
ret
;
}
}
