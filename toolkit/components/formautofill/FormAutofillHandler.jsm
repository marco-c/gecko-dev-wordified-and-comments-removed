"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
FormAutofillHandler
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
FormAutofill
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
autofill
/
FormAutofill
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormAutofillUtils
"
"
resource
:
/
/
autofill
/
FormAutofillUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormAutofillHeuristics
"
"
resource
:
/
/
autofill
/
FormAutofillHeuristics
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FormLikeFactory
"
"
resource
:
/
/
gre
/
modules
/
FormLikeFactory
.
jsm
"
)
;
const
formFillController
=
Cc
[
"
mozilla
.
org
/
satchel
/
form
-
fill
-
controller
;
1
"
]
.
getService
(
Ci
.
nsIFormFillController
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
reauthPasswordPromptMessage
"
(
)
=
>
{
const
brandShortName
=
FormAutofillUtils
.
brandBundle
.
GetStringFromName
(
"
brandShortName
"
)
;
const
platform
=
AppConstants
.
platform
.
replace
(
"
macosx
"
"
macos
"
)
;
return
FormAutofillUtils
.
stringBundle
.
formatStringFromName
(
useCreditCardPasswordPrompt
.
{
platform
}
[
brandShortName
]
)
;
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
CreditCard
:
"
resource
:
/
/
gre
/
modules
/
CreditCard
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
this
{
gUUIDGenerator
:
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
]
}
)
;
this
.
log
=
null
;
FormAutofill
.
defineLazyLogGetter
(
this
EXPORTED_SYMBOLS
[
0
]
)
;
const
{
FIELD_STATES
}
=
FormAutofillUtils
;
class
FormAutofillSection
{
constructor
(
fieldDetails
winUtils
)
{
this
.
fieldDetails
=
fieldDetails
;
this
.
filledRecordGUID
=
null
;
this
.
winUtils
=
winUtils
;
this
.
_FIELD_STATE_ENUM
=
{
[
FIELD_STATES
.
NORMAL
]
:
null
[
FIELD_STATES
.
AUTO_FILLED
]
:
"
autofill
"
[
FIELD_STATES
.
PREVIEW
]
:
"
-
moz
-
autofill
-
preview
"
}
;
if
(
!
this
.
isValidSection
(
)
)
{
this
.
fieldDetails
=
[
]
;
log
.
debug
(
Ignoring
{
this
.
constructor
.
name
}
related
fields
since
it
is
an
invalid
section
)
;
}
this
.
_cacheValue
=
{
allFieldNames
:
null
matchingSelectOption
:
null
}
;
}
isValidSection
(
)
{
throw
new
TypeError
(
"
isValidSection
method
must
be
overrided
"
)
;
}
isEnabled
(
)
{
throw
new
TypeError
(
"
isEnabled
method
must
be
overrided
"
)
;
}
isRecordCreatable
(
record
)
{
throw
new
TypeError
(
"
isRecordCreatable
method
must
be
overrided
"
)
;
}
applyTransformers
(
profile
)
{
}
preparePreviewProfile
(
profile
)
{
}
async
prepareFillingProfile
(
profile
)
{
return
true
;
}
normalizeCreatingRecord
(
data
)
{
}
computeFillingValue
(
value
fieldName
element
)
{
return
value
;
}
set
focusedInput
(
element
)
{
this
.
_focusedDetail
=
this
.
getFieldDetailByElement
(
element
)
;
}
getFieldDetailByElement
(
element
)
{
return
this
.
fieldDetails
.
find
(
detail
=
>
detail
.
elementWeakRef
.
get
(
)
=
=
element
)
;
}
get
allFieldNames
(
)
{
if
(
!
this
.
_cacheValue
.
allFieldNames
)
{
this
.
_cacheValue
.
allFieldNames
=
this
.
fieldDetails
.
map
(
record
=
>
record
.
fieldName
)
;
}
return
this
.
_cacheValue
.
allFieldNames
;
}
getFieldDetailByName
(
fieldName
)
{
return
this
.
fieldDetails
.
find
(
detail
=
>
detail
.
fieldName
=
=
fieldName
)
;
}
matchSelectOptions
(
profile
)
{
if
(
!
this
.
_cacheValue
.
matchingSelectOption
)
{
this
.
_cacheValue
.
matchingSelectOption
=
new
WeakMap
(
)
;
}
for
(
let
fieldName
in
profile
)
{
let
fieldDetail
=
this
.
getFieldDetailByName
(
fieldName
)
;
if
(
!
fieldDetail
)
{
continue
;
}
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLSelectElement
"
)
{
continue
;
}
let
cache
=
this
.
_cacheValue
.
matchingSelectOption
.
get
(
element
)
|
|
{
}
;
let
value
=
profile
[
fieldName
]
;
if
(
cache
[
value
]
&
&
cache
[
value
]
.
get
(
)
)
{
continue
;
}
let
option
=
FormAutofillUtils
.
findSelectOption
(
element
profile
fieldName
)
;
if
(
option
)
{
cache
[
value
]
=
Cu
.
getWeakReference
(
option
)
;
this
.
_cacheValue
.
matchingSelectOption
.
set
(
element
cache
)
;
}
else
{
if
(
cache
[
value
]
)
{
delete
cache
[
value
]
;
this
.
_cacheValue
.
matchingSelectOption
.
set
(
element
cache
)
;
}
delete
profile
[
fieldName
]
;
}
}
}
adaptFieldMaxLength
(
profile
)
{
for
(
let
key
in
profile
)
{
let
detail
=
this
.
getFieldDetailByName
(
key
)
;
if
(
!
detail
)
{
continue
;
}
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
continue
;
}
let
maxLength
=
element
.
maxLength
;
if
(
maxLength
=
=
=
undefined
|
|
maxLength
<
0
|
|
profile
[
key
]
.
toString
(
)
.
length
<
=
maxLength
)
{
continue
;
}
if
(
maxLength
)
{
switch
(
typeof
profile
[
key
]
)
{
case
"
string
"
:
if
(
key
=
=
"
cc
-
exp
"
&
&
maxLength
=
=
5
)
{
const
month2Digits
=
(
"
0
"
+
profile
[
"
cc
-
exp
-
month
"
]
.
toString
(
)
)
.
slice
(
-
2
)
;
const
year2Digits
=
profile
[
"
cc
-
exp
-
year
"
]
.
toString
(
)
.
slice
(
-
2
)
;
profile
[
key
]
=
{
month2Digits
}
/
{
year2Digits
}
;
}
else
{
profile
[
key
]
=
profile
[
key
]
.
substr
(
0
maxLength
)
;
}
break
;
case
"
number
"
:
if
(
maxLength
<
1
)
{
maxLength
=
1
;
}
profile
[
key
]
=
profile
[
key
]
%
Math
.
pow
(
10
maxLength
)
;
break
;
default
:
log
.
warn
(
"
adaptFieldMaxLength
:
Don
'
t
know
how
to
truncate
"
typeof
profile
[
key
]
profile
[
key
]
)
;
}
}
else
{
delete
profile
[
key
]
;
}
}
}
getAdaptedProfiles
(
originalProfiles
)
{
for
(
let
profile
of
originalProfiles
)
{
this
.
applyTransformers
(
profile
)
;
}
return
originalProfiles
;
}
async
autofillFields
(
profile
)
{
let
focusedDetail
=
this
.
_focusedDetail
;
if
(
!
focusedDetail
)
{
throw
new
Error
(
"
No
fieldDetail
for
the
focused
input
.
"
)
;
}
if
(
!
(
await
this
.
prepareFillingProfile
(
profile
)
)
)
{
log
.
debug
(
"
profile
cannot
be
filled
"
profile
)
;
return
false
;
}
log
.
debug
(
"
profile
in
autofillFields
:
"
profile
)
;
let
focusedInput
=
focusedDetail
.
elementWeakRef
.
get
(
)
;
this
.
filledRecordGUID
=
profile
.
guid
;
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
continue
;
}
element
.
previewValue
=
"
"
;
let
value
=
profile
[
{
fieldDetail
.
fieldName
}
-
formatted
]
|
|
profile
[
fieldDetail
.
fieldName
]
;
if
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLInputElement
"
&
&
value
)
{
if
(
element
=
=
focusedInput
|
|
(
element
!
=
focusedInput
&
&
(
!
element
.
value
|
|
element
.
value
=
=
element
.
defaultValue
)
)
|
|
fieldDetail
.
state
=
=
FIELD_STATES
.
AUTO_FILLED
)
{
element
.
focus
(
{
preventScroll
:
true
}
)
;
element
.
setUserInput
(
value
)
;
this
.
_changeFieldState
(
fieldDetail
FIELD_STATES
.
AUTO_FILLED
)
;
}
}
else
if
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLSelectElement
"
)
{
let
cache
=
this
.
_cacheValue
.
matchingSelectOption
.
get
(
element
)
|
|
{
}
;
let
option
=
cache
[
value
]
&
&
cache
[
value
]
.
get
(
)
;
if
(
!
option
)
{
continue
;
}
if
(
!
option
.
selected
)
{
option
.
selected
=
true
;
element
.
focus
(
{
preventScroll
:
true
}
)
;
element
.
dispatchEvent
(
new
element
.
ownerGlobal
.
Event
(
"
input
"
{
bubbles
:
true
}
)
)
;
element
.
dispatchEvent
(
new
element
.
ownerGlobal
.
Event
(
"
change
"
{
bubbles
:
true
}
)
)
;
}
this
.
_changeFieldState
(
fieldDetail
FIELD_STATES
.
AUTO_FILLED
)
;
}
}
focusedInput
.
focus
(
{
preventScroll
:
true
}
)
;
return
true
;
}
previewFormFields
(
profile
)
{
log
.
debug
(
"
preview
profile
:
"
profile
)
;
this
.
preparePreviewProfile
(
profile
)
;
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
let
value
=
profile
[
fieldDetail
.
fieldName
]
|
|
"
"
;
if
(
!
element
)
{
continue
;
}
if
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLSelectElement
"
)
{
if
(
value
)
{
let
cache
=
this
.
_cacheValue
.
matchingSelectOption
.
get
(
element
)
|
|
{
}
;
let
option
=
cache
[
value
]
&
&
cache
[
value
]
.
get
(
)
;
if
(
option
)
{
value
=
option
.
text
|
|
"
"
;
}
else
{
value
=
"
"
;
}
}
}
else
if
(
element
.
value
&
&
element
.
value
!
=
element
.
defaultValue
)
{
continue
;
}
element
.
previewValue
=
value
;
this
.
_changeFieldState
(
fieldDetail
value
?
FIELD_STATES
.
PREVIEW
:
FIELD_STATES
.
NORMAL
)
;
}
}
clearPreviewedFormFields
(
)
{
log
.
debug
(
"
clear
previewed
fields
in
:
"
this
.
form
)
;
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
"
)
;
continue
;
}
element
.
previewValue
=
"
"
;
if
(
fieldDetail
.
state
=
=
FIELD_STATES
.
AUTO_FILLED
)
{
continue
;
}
this
.
_changeFieldState
(
fieldDetail
FIELD_STATES
.
NORMAL
)
;
}
}
clearPopulatedForm
(
)
{
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
"
)
;
continue
;
}
if
(
fieldDetail
.
state
=
=
FIELD_STATES
.
AUTO_FILLED
&
&
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLInputElement
"
)
{
element
.
setUserInput
(
"
"
)
;
}
}
}
_changeFieldState
(
fieldDetail
nextState
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
!
element
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
unreachable
while
changing
state
"
)
;
return
;
}
if
(
!
(
nextState
in
this
.
_FIELD_STATE_ENUM
)
)
{
log
.
warn
(
fieldDetail
.
fieldName
"
is
trying
to
change
to
an
invalid
state
"
)
;
return
;
}
if
(
fieldDetail
.
state
=
=
nextState
)
{
return
;
}
let
nextStateValue
=
null
;
for
(
let
[
state
mmStateValue
]
of
Object
.
entries
(
this
.
_FIELD_STATE_ENUM
)
)
{
if
(
!
mmStateValue
)
{
continue
;
}
if
(
state
=
=
nextState
)
{
nextStateValue
=
mmStateValue
;
}
else
{
this
.
winUtils
.
removeManuallyManagedState
(
element
mmStateValue
)
;
}
}
if
(
nextStateValue
)
{
this
.
winUtils
.
addManuallyManagedState
(
element
nextStateValue
)
;
}
if
(
nextState
=
=
FIELD_STATES
.
AUTO_FILLED
)
{
element
.
addEventListener
(
"
input
"
this
{
mozSystemGroup
:
true
}
)
;
}
fieldDetail
.
state
=
nextState
;
}
resetFieldStates
(
)
{
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
const
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
element
.
removeEventListener
(
"
input
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
_changeFieldState
(
fieldDetail
FIELD_STATES
.
NORMAL
)
;
}
this
.
filledRecordGUID
=
null
;
}
isFilled
(
)
{
return
!
!
this
.
filledRecordGUID
;
}
createRecord
(
)
{
let
details
=
this
.
fieldDetails
;
if
(
!
this
.
isEnabled
(
)
|
|
!
details
|
|
!
details
.
length
)
{
return
null
;
}
let
data
=
{
guid
:
this
.
filledRecordGUID
record
:
{
}
untouchedFields
:
[
]
}
;
if
(
this
.
flowId
)
{
data
.
flowId
=
this
.
flowId
;
}
details
.
forEach
(
detail
=
>
{
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
let
value
=
element
&
&
element
.
value
.
trim
(
)
;
value
=
this
.
computeFillingValue
(
value
detail
element
)
;
if
(
!
value
|
|
value
.
length
>
FormAutofillUtils
.
MAX_FIELD_VALUE_LENGTH
)
{
data
.
record
[
detail
.
fieldName
]
=
"
"
;
return
;
}
data
.
record
[
detail
.
fieldName
]
=
value
;
if
(
detail
.
state
=
=
FIELD_STATES
.
AUTO_FILLED
)
{
data
.
untouchedFields
.
push
(
detail
.
fieldName
)
;
}
}
)
;
this
.
normalizeCreatingRecord
(
data
)
;
if
(
!
this
.
isRecordCreatable
(
data
.
record
)
)
{
return
null
;
}
return
data
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
input
"
:
{
if
(
!
event
.
isTrusted
)
{
return
;
}
const
target
=
event
.
target
;
const
targetFieldDetail
=
this
.
getFieldDetailByElement
(
target
)
;
const
isCreditCardField
=
FormAutofillUtils
.
isCreditCardField
(
targetFieldDetail
.
fieldName
)
;
if
(
ChromeUtils
.
getClassName
(
target
)
!
=
=
"
HTMLSelectElement
"
&
&
isCreditCardField
&
&
target
.
value
=
=
=
"
"
)
{
formFillController
.
showPopup
(
)
;
}
if
(
targetFieldDetail
.
state
=
=
FIELD_STATES
.
NORMAL
)
{
return
;
}
this
.
_changeFieldState
(
targetFieldDetail
FIELD_STATES
.
NORMAL
)
;
if
(
isCreditCardField
)
{
Services
.
telemetry
.
recordEvent
(
"
creditcard
"
"
filled_modified
"
"
cc_form
"
this
.
flowId
{
field_name
:
targetFieldDetail
.
fieldName
}
)
;
}
let
isAutofilled
=
false
;
let
dimFieldDetails
=
[
]
;
for
(
const
fieldDetail
of
this
.
fieldDetails
)
{
const
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLSelectElement
"
)
{
dimFieldDetails
.
push
(
fieldDetail
)
;
}
else
{
isAutofilled
|
=
fieldDetail
.
state
=
=
FIELD_STATES
.
AUTO_FILLED
;
}
}
if
(
!
isAutofilled
)
{
for
(
const
fieldDetail
of
dimFieldDetails
)
{
this
.
_changeFieldState
(
fieldDetail
FIELD_STATES
.
NORMAL
)
;
}
this
.
filledRecordGUID
=
null
;
}
break
;
}
}
}
}
class
FormAutofillAddressSection
extends
FormAutofillSection
{
constructor
(
fieldDetails
winUtils
)
{
super
(
fieldDetails
winUtils
)
;
this
.
_cacheValue
.
oneLineStreetAddress
=
null
;
}
isValidSection
(
)
{
return
(
this
.
fieldDetails
.
length
>
=
FormAutofillUtils
.
AUTOFILL_FIELDS_THRESHOLD
)
;
}
isEnabled
(
)
{
return
FormAutofill
.
isAutofillAddressesEnabled
;
}
isRecordCreatable
(
record
)
{
if
(
record
.
country
&
&
!
FormAutofill
.
supportedCountries
.
includes
(
record
.
country
)
)
{
log
.
warn
(
"
isRecordCreatable
:
Country
not
supported
:
"
record
.
country
)
;
return
false
;
}
let
hasName
=
0
;
let
length
=
0
;
for
(
let
key
of
Object
.
keys
(
record
)
)
{
if
(
!
record
[
key
]
)
{
continue
;
}
if
(
FormAutofillUtils
.
getCategoryFromFieldName
(
key
)
=
=
"
name
"
)
{
hasName
=
1
;
continue
;
}
length
+
+
;
}
return
length
+
hasName
>
=
FormAutofillUtils
.
AUTOFILL_FIELDS_THRESHOLD
;
}
_getOneLineStreetAddress
(
address
)
{
if
(
!
this
.
_cacheValue
.
oneLineStreetAddress
)
{
this
.
_cacheValue
.
oneLineStreetAddress
=
{
}
;
}
if
(
!
this
.
_cacheValue
.
oneLineStreetAddress
[
address
]
)
{
this
.
_cacheValue
.
oneLineStreetAddress
[
address
]
=
FormAutofillUtils
.
toOneLineAddress
(
address
)
;
}
return
this
.
_cacheValue
.
oneLineStreetAddress
[
address
]
;
}
addressTransformer
(
profile
)
{
if
(
profile
[
"
street
-
address
"
]
)
{
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
=
this
.
_getOneLineStreetAddress
(
profile
[
"
street
-
address
"
]
)
;
let
streetAddressDetail
=
this
.
getFieldDetailByName
(
"
street
-
address
"
)
;
if
(
streetAddressDetail
&
&
ChromeUtils
.
getClassName
(
streetAddressDetail
.
elementWeakRef
.
get
(
)
)
=
=
=
"
HTMLInputElement
"
)
{
profile
[
"
street
-
address
"
]
=
profile
[
"
-
moz
-
street
-
address
-
one
-
line
"
]
;
}
let
waitForConcat
=
[
]
;
for
(
let
f
of
[
"
address
-
line3
"
"
address
-
line2
"
"
address
-
line1
"
]
)
{
waitForConcat
.
unshift
(
profile
[
f
]
)
;
if
(
this
.
getFieldDetailByName
(
f
)
)
{
if
(
waitForConcat
.
length
>
1
)
{
profile
[
f
]
=
FormAutofillUtils
.
toOneLineAddress
(
waitForConcat
)
;
}
waitForConcat
=
[
]
;
}
}
}
}
telTransformer
(
profile
)
{
if
(
!
profile
.
tel
|
|
!
profile
[
"
tel
-
national
"
]
)
{
return
;
}
let
detail
=
this
.
getFieldDetailByName
(
"
tel
"
)
;
if
(
!
detail
)
{
return
;
}
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
let
_pattern
;
let
testPattern
=
str
=
>
{
if
(
!
_pattern
)
{
_pattern
=
new
RegExp
(
"
^
(
?
:
"
+
element
.
pattern
+
"
)
"
"
u
"
)
;
}
return
_pattern
.
test
(
str
)
;
}
;
if
(
element
.
pattern
)
{
if
(
testPattern
(
profile
.
tel
)
)
{
return
;
}
}
else
if
(
element
.
maxLength
)
{
if
(
detail
.
_reason
=
=
"
autocomplete
"
&
&
profile
.
tel
.
length
<
=
element
.
maxLength
)
{
return
;
}
}
if
(
detail
.
_reason
!
=
"
autocomplete
"
)
{
profile
.
tel
=
profile
[
"
tel
-
national
"
]
;
}
else
if
(
element
.
pattern
)
{
if
(
testPattern
(
profile
[
"
tel
-
national
"
]
)
)
{
profile
.
tel
=
profile
[
"
tel
-
national
"
]
;
}
}
else
if
(
element
.
maxLength
)
{
if
(
profile
[
"
tel
-
national
"
]
.
length
<
=
element
.
maxLength
)
{
profile
.
tel
=
profile
[
"
tel
-
national
"
]
;
}
}
}
applyTransformers
(
profile
)
{
this
.
addressTransformer
(
profile
)
;
this
.
telTransformer
(
profile
)
;
this
.
matchSelectOptions
(
profile
)
;
this
.
adaptFieldMaxLength
(
profile
)
;
}
computeFillingValue
(
value
fieldDetail
element
)
{
if
(
fieldDetail
.
fieldName
=
=
"
address
-
level1
"
&
&
ChromeUtils
.
getClassName
(
element
)
=
=
=
"
HTMLSelectElement
"
)
{
if
(
!
value
|
|
element
.
selectedOptions
.
length
!
=
1
)
{
value
=
"
"
;
}
else
{
let
text
=
element
.
selectedOptions
[
0
]
.
text
.
trim
(
)
;
value
=
FormAutofillUtils
.
getAbbreviatedSubregionName
(
[
value
text
]
)
|
|
text
;
}
}
return
value
;
}
normalizeCreatingRecord
(
address
)
{
if
(
!
address
)
{
return
;
}
if
(
address
.
record
.
country
)
{
let
detail
=
this
.
getFieldDetailByName
(
"
country
"
)
;
if
(
detail
.
_reason
!
=
"
autocomplete
"
)
{
let
countryCode
=
FormAutofillUtils
.
identifyCountryCode
(
address
.
record
.
country
)
;
if
(
countryCode
)
{
address
.
record
.
country
=
countryCode
;
}
}
}
FormAutofillUtils
.
compressTel
(
address
.
record
)
;
if
(
address
.
record
.
tel
)
{
let
allTelComponentsAreUntouched
=
Object
.
keys
(
address
.
record
)
.
filter
(
field
=
>
FormAutofillUtils
.
getCategoryFromFieldName
(
field
)
=
=
"
tel
"
)
.
every
(
field
=
>
address
.
untouchedFields
.
includes
(
field
)
)
;
if
(
allTelComponentsAreUntouched
)
{
if
(
!
address
.
untouchedFields
.
includes
(
"
tel
"
)
)
{
address
.
untouchedFields
.
push
(
"
tel
"
)
;
}
}
else
{
let
strippedNumber
=
address
.
record
.
tel
.
replace
(
/
[
\
s
\
(
\
)
-
]
/
g
"
"
)
;
if
(
!
/
^
(
\
+
?
)
[
\
da
-
zA
-
Z
]
{
5
15
}
/
.
test
(
strippedNumber
)
)
{
address
.
record
.
tel
=
"
"
;
}
}
}
}
}
class
FormAutofillCreditCardSection
extends
FormAutofillSection
{
constructor
(
fieldDetails
winUtils
handler
)
{
super
(
fieldDetails
winUtils
)
;
this
.
handler
=
handler
;
this
.
flowId
=
gUUIDGenerator
.
generateUUID
(
)
.
toString
(
)
;
log
.
debug
(
"
Creating
new
credit
card
section
with
flowId
=
"
this
.
flowId
)
;
if
(
!
this
.
isValidSection
(
)
)
{
return
;
}
let
identified
=
new
Set
(
)
;
fieldDetails
.
forEach
(
detail
=
>
identified
.
add
(
detail
.
fieldName
)
)
;
Services
.
telemetry
.
recordEvent
(
"
creditcard
"
"
detected
"
"
cc_form
"
this
.
flowId
{
cc_name_found
:
identified
.
has
(
"
cc
-
name
"
)
?
"
true
"
:
"
false
"
cc_number_found
:
identified
.
has
(
"
cc
-
number
"
)
?
"
true
"
:
"
false
"
cc_exp_found
:
identified
.
has
(
"
cc
-
exp
"
)
|
|
(
identified
.
has
(
"
cc
-
exp
-
month
"
)
&
&
identified
.
has
(
"
cc
-
exp
-
year
"
)
)
?
"
true
"
:
"
false
"
}
)
;
Services
.
telemetry
.
scalarAdd
(
"
formautofill
.
creditCards
.
detected_sections_count
"
1
)
;
if
(
handler
.
window
.
location
!
=
handler
.
window
.
parent
?
.
location
)
{
log
.
debug
(
"
Credit
card
form
is
in
an
iframe
-
-
watching
for
pagehide
"
fieldDetails
)
;
handler
.
window
.
addEventListener
(
"
pagehide
"
this
.
_handlePageHide
.
bind
(
this
)
)
;
}
}
_handlePageHide
(
event
)
{
this
.
handler
.
window
.
removeEventListener
(
"
pagehide
"
this
.
_handlePageHide
.
bind
(
this
)
)
;
log
.
debug
(
"
Credit
card
subframe
is
pagehideing
"
this
.
handler
.
form
)
;
this
.
handler
.
onFormSubmitted
(
)
;
}
isValidSection
(
)
{
let
ccNumberReason
=
"
"
;
let
hasCCNumber
=
false
;
let
hasExpiryDate
=
false
;
let
hasCCName
=
false
;
for
(
let
detail
of
this
.
fieldDetails
)
{
switch
(
detail
.
fieldName
)
{
case
"
cc
-
number
"
:
hasCCNumber
=
true
;
ccNumberReason
=
detail
.
_reason
;
break
;
case
"
cc
-
name
"
:
case
"
cc
-
given
-
name
"
:
case
"
cc
-
additional
-
name
"
:
case
"
cc
-
family
-
name
"
:
hasCCName
=
true
;
break
;
case
"
cc
-
exp
"
:
case
"
cc
-
exp
-
month
"
:
case
"
cc
-
exp
-
year
"
:
hasExpiryDate
=
true
;
break
;
}
}
return
(
hasCCNumber
&
&
(
ccNumberReason
=
=
"
autocomplete
"
|
|
hasExpiryDate
|
|
hasCCName
)
)
;
}
isEnabled
(
)
{
return
FormAutofill
.
isAutofillCreditCardsEnabled
;
}
isRecordCreatable
(
record
)
{
return
(
record
[
"
cc
-
number
"
]
&
&
FormAutofillUtils
.
isCCNumber
(
record
[
"
cc
-
number
"
]
)
)
;
}
creditCardExpDateTransformer
(
profile
)
{
if
(
!
profile
[
"
cc
-
exp
"
]
)
{
return
;
}
let
detail
=
this
.
getFieldDetailByName
(
"
cc
-
exp
"
)
;
if
(
!
detail
)
{
return
;
}
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
element
.
tagName
!
=
"
INPUT
"
|
|
!
element
.
placeholder
)
{
return
;
}
let
result
ccExpMonth
=
profile
[
"
cc
-
exp
-
month
"
]
ccExpYear
=
profile
[
"
cc
-
exp
-
year
"
]
placeholder
=
element
.
placeholder
;
let
monthChars
=
"
m
"
;
let
yearChars
=
"
ya
"
;
let
monthFirstCheck
=
new
RegExp
(
"
(
?
:
\
\
b
|
^
)
(
(
?
:
[
"
+
monthChars
+
"
]
{
2
}
)
{
1
2
}
)
\
\
s
*
(
[
\
\
-
/
]
)
\
\
s
*
(
(
?
:
[
"
+
yearChars
+
"
]
{
2
}
)
{
1
2
}
)
(
?
:
\
\
b
|
)
"
"
i
"
)
;
result
=
monthFirstCheck
.
exec
(
placeholder
)
;
if
(
result
)
{
profile
[
"
cc
-
exp
"
]
=
ccExpMonth
.
toString
(
)
.
padStart
(
result
[
1
]
.
length
"
0
"
)
+
result
[
2
]
+
ccExpYear
.
toString
(
)
.
substr
(
-
1
*
result
[
3
]
.
length
)
;
return
;
}
let
yearFirstCheck
=
new
RegExp
(
"
(
?
:
\
\
b
|
^
)
(
(
?
:
[
"
+
yearChars
+
"
]
{
2
}
)
{
1
2
}
)
\
\
s
*
(
[
\
\
-
/
]
)
\
\
s
*
(
(
?
:
[
"
+
monthChars
+
"
]
)
{
1
2
}
)
(
?
:
\
\
b
|
)
"
"
i
"
)
;
result
=
yearFirstCheck
.
exec
(
placeholder
)
;
if
(
result
)
{
profile
[
"
cc
-
exp
"
]
=
ccExpYear
.
toString
(
)
.
substr
(
-
1
*
result
[
1
]
.
length
)
+
result
[
2
]
+
ccExpMonth
.
toString
(
)
.
padStart
(
result
[
3
]
.
length
"
0
"
)
;
}
}
creditCardExpMonthTransformer
(
profile
)
{
if
(
!
profile
[
"
cc
-
exp
-
month
"
]
)
{
return
;
}
let
detail
=
this
.
getFieldDetailByName
(
"
cc
-
exp
-
month
"
)
;
if
(
!
detail
)
{
return
;
}
let
element
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
element
.
tagName
=
=
=
"
INPUT
"
)
{
let
placeholder
=
element
.
placeholder
;
let
result
=
/
(
?
<
!
.
)
mm
(
?
!
.
)
/
i
.
test
(
placeholder
)
;
if
(
result
)
{
profile
[
"
cc
-
exp
-
month
-
formatted
"
]
=
profile
[
"
cc
-
exp
-
month
"
]
.
toString
(
)
.
padStart
(
2
"
0
"
)
;
}
}
}
async
_decrypt
(
cipherText
reauth
)
{
let
window
;
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
if
(
element
)
{
window
=
element
.
ownerGlobal
;
break
;
}
}
if
(
!
window
)
{
return
null
;
}
let
actor
=
window
.
windowGlobalChild
.
getActor
(
"
FormAutofill
"
)
;
return
actor
.
sendQuery
(
"
FormAutofill
:
GetDecryptedString
"
{
cipherText
reauth
}
)
;
}
applyTransformers
(
profile
)
{
this
.
matchSelectOptions
(
profile
)
;
this
.
creditCardExpDateTransformer
(
profile
)
;
this
.
creditCardExpMonthTransformer
(
profile
)
;
this
.
adaptFieldMaxLength
(
profile
)
;
}
computeFillingValue
(
value
fieldDetail
element
)
{
if
(
fieldDetail
.
fieldName
!
=
"
cc
-
type
"
|
|
ChromeUtils
.
getClassName
(
element
)
!
=
=
"
HTMLSelectElement
"
)
{
return
value
;
}
if
(
CreditCard
.
isValidNetwork
(
value
)
)
{
return
value
;
}
if
(
value
&
&
element
.
selectedOptions
.
length
=
=
1
)
{
let
selectedOption
=
element
.
selectedOptions
[
0
]
;
let
networkType
=
CreditCard
.
getNetworkFromName
(
selectedOption
.
text
)
?
?
CreditCard
.
getNetworkFromName
(
selectedOption
.
value
)
;
if
(
networkType
)
{
return
networkType
;
}
}
return
value
;
}
preparePreviewProfile
(
profile
)
{
if
(
profile
[
"
cc
-
number
-
decrypted
"
]
)
{
profile
[
"
cc
-
number
"
]
=
profile
[
"
cc
-
number
-
decrypted
"
]
;
}
}
async
prepareFillingProfile
(
profile
)
{
if
(
profile
[
"
cc
-
number
-
encrypted
"
]
)
{
let
decrypted
=
await
this
.
_decrypt
(
profile
[
"
cc
-
number
-
encrypted
"
]
reauthPasswordPromptMessage
)
;
if
(
!
decrypted
)
{
return
false
;
}
profile
[
"
cc
-
number
"
]
=
decrypted
;
}
return
true
;
}
async
autofillFields
(
profile
)
{
if
(
!
(
await
super
.
autofillFields
(
profile
)
)
)
{
return
false
;
}
let
extra
=
{
cc_name
:
"
unavailable
"
cc_number
:
"
unavailable
"
cc_exp
:
"
unavailable
"
}
;
for
(
let
fieldDetail
of
this
.
fieldDetails
)
{
let
element
=
fieldDetail
.
elementWeakRef
.
get
(
)
;
let
state
=
profile
[
fieldDetail
.
fieldName
]
?
"
filled
"
:
"
not_filled
"
;
if
(
fieldDetail
.
state
=
=
FIELD_STATES
.
NORMAL
&
&
(
ChromeUtils
.
getClassName
(
element
)
=
=
"
HTMLSelectElement
"
|
|
(
ChromeUtils
.
getClassName
(
element
)
=
=
"
HTMLInputElement
"
&
&
element
.
value
.
length
)
)
)
{
state
=
"
user_filled
"
;
}
switch
(
fieldDetail
.
fieldName
)
{
case
"
cc
-
name
"
:
extra
.
cc_name
=
state
;
break
;
case
"
cc
-
number
"
:
extra
.
cc_number
=
state
;
break
;
case
"
cc
-
exp
"
:
case
"
cc
-
exp
-
month
"
:
case
"
cc
-
exp
-
year
"
:
extra
.
cc_exp
=
state
;
break
;
}
}
Services
.
telemetry
.
recordEvent
(
"
creditcard
"
"
filled
"
"
cc_form
"
this
.
flowId
extra
)
;
return
true
;
}
}
class
FormAutofillHandler
{
constructor
(
form
onFormSubmitted
=
(
)
=
>
{
}
)
{
this
.
_updateForm
(
form
)
;
this
.
window
=
this
.
form
.
rootElement
.
ownerGlobal
;
this
.
winUtils
=
this
.
window
.
windowUtils
;
this
.
timeStartedFillingMS
=
null
;
this
.
onFormSubmitted
=
(
)
=
>
{
onFormSubmitted
(
this
.
form
this
.
window
this
)
;
}
;
}
set
focusedInput
(
element
)
{
let
section
=
this
.
_sectionCache
.
get
(
element
)
;
if
(
!
section
)
{
section
=
this
.
sections
.
find
(
s
=
>
s
.
getFieldDetailByElement
(
element
)
)
;
this
.
_sectionCache
.
set
(
element
section
)
;
}
this
.
_focusedSection
=
section
;
if
(
section
)
{
section
.
focusedInput
=
element
;
}
}
get
activeSection
(
)
{
return
this
.
_focusedSection
;
}
updateFormIfNeeded
(
element
)
{
let
_formLike
;
let
getFormLike
=
(
)
=
>
{
if
(
!
_formLike
)
{
_formLike
=
FormLikeFactory
.
createFromField
(
element
)
;
}
return
_formLike
;
}
;
let
currentForm
=
element
.
form
;
if
(
!
currentForm
)
{
currentForm
=
getFormLike
(
)
;
}
if
(
currentForm
.
elements
.
length
!
=
this
.
form
.
elements
.
length
)
{
log
.
debug
(
"
The
count
of
form
elements
is
changed
.
"
)
;
this
.
_updateForm
(
getFormLike
(
)
)
;
return
true
;
}
if
(
!
this
.
form
.
elements
.
includes
(
element
)
)
{
log
.
debug
(
"
The
element
can
not
be
found
in
the
current
form
.
"
)
;
this
.
_updateForm
(
getFormLike
(
)
)
;
return
true
;
}
return
false
;
}
_updateForm
(
form
)
{
this
.
form
=
form
;
this
.
fieldDetails
=
null
;
this
.
sections
=
[
]
;
this
.
_sectionCache
=
new
WeakMap
(
)
;
}
collectFormFields
(
allowDuplicates
=
false
)
{
let
sections
=
FormAutofillHeuristics
.
getFormInfo
(
this
.
form
allowDuplicates
)
;
let
allValidDetails
=
[
]
;
for
(
let
{
fieldDetails
type
}
of
sections
)
{
let
section
;
if
(
type
=
=
FormAutofillUtils
.
SECTION_TYPES
.
ADDRESS
)
{
section
=
new
FormAutofillAddressSection
(
fieldDetails
this
.
winUtils
)
;
}
else
if
(
type
=
=
FormAutofillUtils
.
SECTION_TYPES
.
CREDIT_CARD
)
{
section
=
new
FormAutofillCreditCardSection
(
fieldDetails
this
.
winUtils
this
)
;
}
else
{
throw
new
Error
(
"
Unknown
field
type
.
"
)
;
}
this
.
sections
.
push
(
section
)
;
allValidDetails
.
push
(
.
.
.
section
.
fieldDetails
)
;
}
for
(
let
detail
of
allValidDetails
)
{
let
input
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
!
input
)
{
continue
;
}
input
.
addEventListener
(
"
input
"
this
{
mozSystemGroup
:
true
}
)
;
}
this
.
fieldDetails
=
allValidDetails
;
return
allValidDetails
;
}
_hasFilledSection
(
)
{
return
this
.
sections
.
some
(
section
=
>
section
.
isFilled
(
)
)
;
}
async
autofillFormFields
(
profile
)
{
let
noFilledSectionsPreviously
=
!
this
.
_hasFilledSection
(
)
;
await
this
.
activeSection
.
autofillFields
(
profile
)
;
const
onChangeHandler
=
e
=
>
{
if
(
!
e
.
isTrusted
)
{
return
;
}
if
(
e
.
type
=
=
"
reset
"
)
{
for
(
let
section
of
this
.
sections
)
{
section
.
resetFieldStates
(
)
;
}
}
if
(
!
this
.
_hasFilledSection
(
)
)
{
this
.
form
.
rootElement
.
removeEventListener
(
"
input
"
onChangeHandler
{
mozSystemGroup
:
true
}
)
;
this
.
form
.
rootElement
.
removeEventListener
(
"
reset
"
onChangeHandler
{
mozSystemGroup
:
true
}
)
;
}
}
;
if
(
noFilledSectionsPreviously
)
{
log
.
debug
(
"
register
change
handler
for
filled
form
:
"
this
.
form
)
;
this
.
form
.
rootElement
.
addEventListener
(
"
input
"
onChangeHandler
{
mozSystemGroup
:
true
}
)
;
this
.
form
.
rootElement
.
addEventListener
(
"
reset
"
onChangeHandler
{
mozSystemGroup
:
true
}
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
input
"
:
if
(
!
event
.
isTrusted
)
{
return
;
}
for
(
let
detail
of
this
.
fieldDetails
)
{
let
input
=
detail
.
elementWeakRef
.
get
(
)
;
if
(
!
input
)
{
continue
;
}
input
.
removeEventListener
(
"
input
"
this
{
mozSystemGroup
:
true
}
)
;
}
this
.
timeStartedFillingMS
=
Date
.
now
(
)
;
break
;
}
}
createRecords
(
)
{
const
records
=
{
address
:
[
]
creditCard
:
[
]
}
;
for
(
const
section
of
this
.
sections
)
{
const
secRecord
=
section
.
createRecord
(
)
;
if
(
!
secRecord
)
{
continue
;
}
if
(
section
instanceof
FormAutofillAddressSection
)
{
records
.
address
.
push
(
secRecord
)
;
}
else
if
(
section
instanceof
FormAutofillCreditCardSection
)
{
records
.
creditCard
.
push
(
secRecord
)
;
}
else
{
throw
new
Error
(
"
Unknown
section
type
"
)
;
}
}
log
.
debug
(
"
Create
records
:
"
records
)
;
return
records
;
}
}
