this
.
EXPORTED_SYMBOLS
=
[
"
RemoteAddonsChild
"
]
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Prefetcher
"
"
resource
:
/
/
gre
/
modules
/
Prefetcher
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
SystemPrincipal
"
"
mozilla
.
org
/
systemprincipal
;
1
"
"
nsIPrincipal
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
contentSecManager
"
"
mozilla
.
org
/
contentsecuritymanager
;
1
"
"
nsIContentSecurityManager
"
)
;
const
TELEMETRY_SHOULD_LOAD_LOADING_KEY
=
"
ADDON_CONTENT_POLICY_SHIM_BLOCKING_LOADING_MS
"
;
const
TELEMETRY_SHOULD_LOAD_LOADED_KEY
=
"
ADDON_CONTENT_POLICY_SHIM_BLOCKING_LOADED_MS
"
;
function
setDefault
(
dict
key
default_
)
{
if
(
key
in
dict
)
{
return
dict
[
key
]
;
}
dict
[
key
]
=
default_
;
return
default_
;
}
var
NotificationTracker
=
{
init
(
)
{
let
cpmm
=
Cc
[
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsISyncMessageSender
)
;
cpmm
.
addMessageListener
(
"
Addons
:
ChangeNotification
"
this
)
;
this
.
_paths
=
cpmm
.
initialProcessData
.
remoteAddonsNotificationPaths
;
this
.
_registered
=
new
Map
(
)
;
this
.
_watchers
=
{
}
;
}
receiveMessage
(
msg
)
{
let
path
=
msg
.
data
.
path
;
let
count
=
msg
.
data
.
count
;
let
tracked
=
this
.
_paths
;
for
(
let
component
of
path
)
{
tracked
=
setDefault
(
tracked
component
{
}
)
;
}
tracked
.
_count
=
count
;
if
(
this
.
_watchers
[
path
[
0
]
]
)
{
for
(
let
watcher
of
this
.
_watchers
[
path
[
0
]
]
)
{
this
.
runCallback
(
watcher
path
count
)
;
}
}
}
runCallback
(
watcher
path
count
)
{
let
pathString
=
path
.
join
(
"
/
"
)
;
let
registeredSet
=
this
.
_registered
.
get
(
watcher
)
;
let
registered
=
registeredSet
.
has
(
pathString
)
;
if
(
count
&
&
!
registered
)
{
watcher
.
track
(
path
true
)
;
registeredSet
.
add
(
pathString
)
;
}
else
if
(
!
count
&
&
registered
)
{
watcher
.
track
(
path
false
)
;
registeredSet
.
delete
(
pathString
)
;
}
}
findPaths
(
prefix
)
{
if
(
!
this
.
_paths
)
{
return
[
]
;
}
let
tracked
=
this
.
_paths
;
for
(
let
component
of
prefix
)
{
tracked
=
setDefault
(
tracked
component
{
}
)
;
}
let
result
=
[
]
;
let
enumerate
=
(
tracked
curPath
)
=
>
{
for
(
let
component
in
tracked
)
{
if
(
component
=
=
"
_count
"
)
{
result
.
push
(
[
curPath
tracked
.
_count
]
)
;
}
else
{
let
path
=
curPath
.
slice
(
)
;
if
(
component
=
=
=
"
true
"
)
{
component
=
true
;
}
else
if
(
component
=
=
=
"
false
"
)
{
component
=
false
;
}
path
.
push
(
component
)
;
enumerate
(
tracked
[
component
]
path
)
;
}
}
}
;
enumerate
(
tracked
prefix
)
;
return
result
;
}
findSuffixes
(
prefix
)
{
let
paths
=
this
.
findPaths
(
prefix
)
;
return
paths
.
map
(
(
[
path
count
]
)
=
>
path
[
path
.
length
-
1
]
)
;
}
watch
(
component1
watcher
)
{
setDefault
(
this
.
_watchers
component1
[
]
)
.
push
(
watcher
)
;
this
.
_registered
.
set
(
watcher
new
Set
(
)
)
;
let
paths
=
this
.
findPaths
(
[
component1
]
)
;
for
(
let
[
path
count
]
of
paths
)
{
this
.
runCallback
(
watcher
path
count
)
;
}
}
unwatch
(
component1
watcher
)
{
let
watchers
=
this
.
_watchers
[
component1
]
;
let
index
=
watchers
.
lastIndexOf
(
watcher
)
;
if
(
index
>
-
1
)
{
watchers
.
splice
(
index
1
)
;
}
this
.
_registered
.
delete
(
watcher
)
;
}
getCount
(
component1
)
{
return
this
.
findPaths
(
[
component1
]
)
.
length
;
}
}
;
var
ContentPolicyChild
=
{
_classDescription
:
"
Addon
shim
content
policy
"
_classID
:
Components
.
ID
(
"
6e869130
-
635c
-
11e2
-
bcfd
-
0800200c9a66
"
)
_contractID
:
"
mozilla
.
org
/
addon
-
child
/
policy
;
1
"
timings
:
new
WeakMap
(
)
init
(
)
{
let
registrar
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
registrar
.
registerFactory
(
this
.
_classID
this
.
_classDescription
this
.
_contractID
this
)
;
this
.
loadingHistogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
TELEMETRY_SHOULD_LOAD_LOADING_KEY
)
;
this
.
loadedHistogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
TELEMETRY_SHOULD_LOAD_LOADED_KEY
)
;
NotificationTracker
.
watch
(
"
content
-
policy
"
this
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIContentPolicy
Ci
.
nsIObserver
Ci
.
nsIChannelEventSink
Ci
.
nsIFactory
Ci
.
nsISupportsWeakReference
]
)
track
(
path
register
)
{
let
catMan
=
Cc
[
"
mozilla
.
org
/
categorymanager
;
1
"
]
.
getService
(
Ci
.
nsICategoryManager
)
;
if
(
register
)
{
catMan
.
addCategoryEntry
(
"
content
-
policy
"
this
.
_contractID
this
.
_contractID
false
true
)
;
}
else
{
catMan
.
deleteCategoryEntry
(
"
content
-
policy
"
this
.
_contractID
false
)
;
}
}
getTimings
(
context
)
{
if
(
!
Services
.
telemetry
.
canRecordExtended
)
{
return
null
;
}
let
doc
;
if
(
context
instanceof
Ci
.
nsIDOMNode
)
{
doc
=
context
.
ownerDocument
;
}
else
if
(
context
instanceof
Ci
.
nsIDOMDocument
)
{
doc
=
context
;
}
else
if
(
context
instanceof
Ci
.
nsIDOMWindow
)
{
doc
=
context
.
document
;
}
if
(
!
doc
)
{
return
null
;
}
let
map
=
this
.
timings
.
get
(
doc
)
;
if
(
!
map
)
{
map
=
new
Map
(
)
;
this
.
timings
.
set
(
doc
map
)
;
let
eventName
=
doc
.
readyState
=
=
"
complete
"
?
"
pagehide
"
:
"
load
"
;
let
listener
=
event
=
>
{
if
(
event
.
target
=
=
doc
)
{
event
.
currentTarget
.
removeEventListener
(
eventName
listener
true
)
;
this
.
logTelemetry
(
doc
eventName
)
;
}
}
;
doc
.
defaultView
.
addEventListener
(
eventName
listener
true
)
;
}
return
map
;
}
logTelemetry
(
doc
eventName
)
{
let
map
=
this
.
timings
.
get
(
doc
)
;
this
.
timings
.
delete
(
doc
)
;
let
histogram
=
eventName
=
=
"
load
"
?
this
.
loadingHistogram
:
this
.
loadedHistogram
;
for
(
let
[
addon
time
]
of
map
.
entries
(
)
)
{
histogram
.
add
(
addon
time
)
;
}
}
shouldLoad
(
contentType
contentLocation
requestOrigin
node
mimeTypeGuess
extra
requestPrincipal
)
{
let
startTime
=
Cu
.
now
(
)
;
let
addons
=
NotificationTracker
.
findSuffixes
(
[
"
content
-
policy
"
]
)
;
let
[
prefetched
cpows
]
=
Prefetcher
.
prefetch
(
"
ContentPolicy
.
shouldLoad
"
addons
{
InitNode
:
node
}
)
;
cpows
.
node
=
node
;
let
cpmm
=
Cc
[
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsISyncMessageSender
)
;
let
rval
=
cpmm
.
sendRpcMessage
(
"
Addons
:
ContentPolicy
:
Run
"
{
contentType
contentLocation
:
contentLocation
.
spec
requestOrigin
:
requestOrigin
?
requestOrigin
.
spec
:
null
mimeTypeGuess
requestPrincipal
prefetched
}
cpows
)
;
let
timings
=
this
.
getTimings
(
node
)
;
if
(
timings
)
{
let
delta
=
Cu
.
now
(
)
-
startTime
;
for
(
let
addon
of
addons
)
{
let
old
=
timings
.
get
(
addon
)
|
|
0
;
timings
.
set
(
addon
old
+
delta
)
;
}
}
if
(
rval
.
length
!
=
1
)
{
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
return
rval
[
0
]
;
}
shouldProcess
(
contentType
contentLocation
requestOrigin
insecNode
mimeType
extra
)
{
return
Ci
.
nsIContentPolicy
.
ACCEPT
;
}
createInstance
(
outer
iid
)
{
if
(
outer
)
{
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
}
return
this
.
QueryInterface
(
iid
)
;
}
}
;
function
AboutProtocolChannel
(
uri
contractID
loadInfo
)
{
this
.
URI
=
uri
;
this
.
originalURI
=
uri
;
this
.
_contractID
=
contractID
;
this
.
_loadingPrincipal
=
loadInfo
.
loadingPrincipal
;
this
.
_securityFlags
=
loadInfo
.
securityFlags
;
this
.
_contentPolicyType
=
loadInfo
.
externalContentPolicyType
;
}
AboutProtocolChannel
.
prototype
=
{
contentCharset
:
"
utf
-
8
"
contentLength
:
0
owner
:
SystemPrincipal
securityInfo
:
null
notificationCallbacks
:
null
loadFlags
:
0
loadGroup
:
null
name
:
null
status
:
Cr
.
NS_OK
asyncOpen
(
listener
context
)
{
let
cpmm
=
Cc
[
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsISyncMessageSender
)
;
let
rval
=
cpmm
.
sendRpcMessage
(
"
Addons
:
AboutProtocol
:
OpenChannel
"
{
uri
:
this
.
URI
.
spec
contractID
:
this
.
_contractID
loadingPrincipal
:
this
.
_loadingPrincipal
securityFlags
:
this
.
_securityFlags
contentPolicyType
:
this
.
_contentPolicyType
}
{
notificationCallbacks
:
this
.
notificationCallbacks
loadGroupNotificationCallbacks
:
this
.
loadGroup
?
this
.
loadGroup
.
notificationCallbacks
:
null
}
)
;
if
(
rval
.
length
!
=
1
)
{
throw
Cr
.
NS_ERROR_FAILURE
;
}
let
{
data
contentType
}
=
rval
[
0
]
;
this
.
contentType
=
contentType
;
let
stream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stream
.
setData
(
data
data
.
length
)
;
let
runnable
=
{
run
:
(
)
=
>
{
try
{
listener
.
onStartRequest
(
this
context
)
;
}
catch
(
e
)
{
}
try
{
listener
.
onDataAvailable
(
this
context
stream
0
stream
.
available
(
)
)
;
}
catch
(
e
)
{
}
try
{
listener
.
onStopRequest
(
this
context
Cr
.
NS_OK
)
;
}
catch
(
e
)
{
}
}
}
;
Services
.
tm
.
dispatchToMainThread
(
runnable
)
;
}
asyncOpen2
(
listener
)
{
var
outListener
=
contentSecManager
.
performSecurityCheck
(
this
listener
)
;
this
.
asyncOpen
(
outListener
null
)
;
}
open
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
open2
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
isPending
(
)
{
return
false
;
}
cancel
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
suspend
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
resume
(
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIChannel
Ci
.
nsIRequest
]
)
}
;
function
AboutProtocolInstance
(
contractID
)
{
this
.
_contractID
=
contractID
;
this
.
_uriFlags
=
undefined
;
}
AboutProtocolInstance
.
prototype
=
{
createInstance
(
outer
iid
)
{
if
(
outer
!
=
null
)
{
throw
Cr
.
NS_ERROR_NO_AGGREGATION
;
}
return
this
.
QueryInterface
(
iid
)
;
}
getURIFlags
(
uri
)
{
if
(
this
.
_uriFlags
!
=
=
undefined
)
{
return
this
.
_uriFlags
;
}
let
cpmm
=
Cc
[
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsISyncMessageSender
)
;
let
rval
=
cpmm
.
sendRpcMessage
(
"
Addons
:
AboutProtocol
:
GetURIFlags
"
{
uri
:
uri
.
spec
contractID
:
this
.
_contractID
}
)
;
if
(
rval
.
length
!
=
1
)
{
throw
Cr
.
NS_ERROR_FAILURE
;
}
this
.
_uriFlags
=
rval
[
0
]
;
return
this
.
_uriFlags
;
}
newChannel
(
uri
loadInfo
)
{
return
new
AboutProtocolChannel
(
uri
this
.
_contractID
loadInfo
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIFactory
Ci
.
nsIAboutModule
]
)
}
;
var
AboutProtocolChild
=
{
_classDescription
:
"
Addon
shim
about
:
protocol
handler
"
init
(
)
{
this
.
_instances
=
new
Map
(
)
;
this
.
_classIDs
=
new
Map
(
)
;
NotificationTracker
.
watch
(
"
about
-
protocol
"
this
)
;
}
track
(
path
register
)
{
let
contractID
=
path
[
1
]
;
let
registrar
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
if
(
register
)
{
let
instance
=
new
AboutProtocolInstance
(
contractID
)
;
let
classID
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
;
this
.
_instances
.
set
(
contractID
instance
)
;
this
.
_classIDs
.
set
(
contractID
classID
)
;
registrar
.
registerFactory
(
classID
this
.
_classDescription
contractID
instance
)
;
}
else
{
let
instance
=
this
.
_instances
.
get
(
contractID
)
;
let
classID
=
this
.
_classIDs
.
get
(
contractID
)
;
registrar
.
unregisterFactory
(
classID
instance
)
;
this
.
_instances
.
delete
(
contractID
)
;
this
.
_classIDs
.
delete
(
contractID
)
;
}
}
}
;
var
ObserverChild
=
{
init
(
)
{
NotificationTracker
.
watch
(
"
observer
"
this
)
;
}
track
(
path
register
)
{
let
topic
=
path
[
1
]
;
if
(
register
)
{
Services
.
obs
.
addObserver
(
this
topic
)
;
}
else
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
}
}
observe
(
subject
topic
data
)
{
let
cpmm
=
Cc
[
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsISyncMessageSender
)
;
cpmm
.
sendRpcMessage
(
"
Addons
:
Observer
:
Run
"
{
}
{
topic
subject
data
}
)
;
}
}
;
function
EventTargetChild
(
childGlobal
)
{
this
.
_childGlobal
=
childGlobal
;
this
.
capturingHandler
=
(
event
)
=
>
this
.
handleEvent
(
true
event
)
;
this
.
nonCapturingHandler
=
(
event
)
=
>
this
.
handleEvent
(
false
event
)
;
NotificationTracker
.
watch
(
"
event
"
this
)
;
}
EventTargetChild
.
prototype
=
{
uninit
(
)
{
NotificationTracker
.
unwatch
(
"
event
"
this
)
;
}
track
(
path
register
)
{
let
eventType
=
path
[
1
]
;
let
useCapture
=
path
[
2
]
;
let
listener
=
useCapture
?
this
.
capturingHandler
:
this
.
nonCapturingHandler
;
if
(
register
)
{
this
.
_childGlobal
.
addEventListener
(
eventType
listener
useCapture
true
)
;
}
else
{
this
.
_childGlobal
.
removeEventListener
(
eventType
listener
useCapture
)
;
}
}
handleEvent
(
capturing
event
)
{
let
addons
=
NotificationTracker
.
findSuffixes
(
[
"
event
"
event
.
type
capturing
]
)
;
let
[
prefetched
cpows
]
=
Prefetcher
.
prefetch
(
"
EventTarget
.
handleEvent
"
addons
{
Event
:
event
Window
:
this
.
_childGlobal
.
content
}
)
;
cpows
.
event
=
event
;
cpows
.
eventTarget
=
event
.
target
;
this
.
_childGlobal
.
sendRpcMessage
(
"
Addons
:
Event
:
Run
"
{
type
:
event
.
type
capturing
isTrusted
:
event
.
isTrusted
prefetched
}
cpows
)
;
}
}
;
function
SandboxChild
(
chromeGlobal
)
{
this
.
chromeGlobal
=
chromeGlobal
;
this
.
sandboxes
=
[
]
;
}
SandboxChild
.
prototype
=
{
uninit
(
)
{
this
.
clearSandboxes
(
)
;
}
addListener
(
)
{
let
webProgress
=
this
.
chromeGlobal
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
}
removeListener
(
)
{
let
webProgress
=
this
.
chromeGlobal
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
removeProgressListener
(
this
)
;
}
onLocationChange
(
webProgress
request
location
flags
)
{
this
.
clearSandboxes
(
)
;
}
addSandbox
(
sandbox
)
{
if
(
this
.
sandboxes
.
length
=
=
0
)
{
this
.
addListener
(
)
;
}
this
.
sandboxes
.
push
(
sandbox
)
;
}
clearSandboxes
(
)
{
if
(
this
.
sandboxes
.
length
)
{
this
.
removeListener
(
)
;
}
this
.
sandboxes
=
[
]
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
}
;
var
RemoteAddonsChild
=
{
_ready
:
false
makeReady
(
)
{
let
shims
=
[
Prefetcher
NotificationTracker
ContentPolicyChild
AboutProtocolChild
ObserverChild
]
;
for
(
let
shim
of
shims
)
{
try
{
shim
.
init
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
init
(
global
)
{
if
(
!
this
.
_ready
)
{
if
(
!
Services
.
cpmm
.
initialProcessData
.
remoteAddonsParentInitted
)
{
return
null
;
}
this
.
makeReady
(
)
;
this
.
_ready
=
true
;
}
global
.
sendAsyncMessage
(
"
Addons
:
RegisterGlobal
"
{
}
{
global
}
)
;
let
sandboxChild
=
new
SandboxChild
(
global
)
;
global
.
addSandbox
=
sandboxChild
.
addSandbox
.
bind
(
sandboxChild
)
;
return
[
new
EventTargetChild
(
global
)
sandboxChild
]
;
}
uninit
(
perTabShims
)
{
for
(
let
shim
of
perTabShims
)
{
try
{
shim
.
uninit
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
get
useSyncWebProgress
(
)
{
return
NotificationTracker
.
getCount
(
"
web
-
progress
"
)
>
0
;
}
}
;
