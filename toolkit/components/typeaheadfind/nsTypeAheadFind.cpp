#
include
"
nsCOMPtr
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
ModuleUtils
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsCURILoader
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsFrameTraversal
.
h
"
#
include
"
nsIImageDocument
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsLayoutCID
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsTypeAheadFind
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsTypeAheadFind
)
NS_INTERFACE_MAP_ENTRY
(
nsITypeAheadFind
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsITypeAheadFind
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsTypeAheadFind
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsTypeAheadFind
)
NS_IMPL_CYCLE_COLLECTION
(
nsTypeAheadFind
mFoundLink
mFoundEditable
mCurrentWindow
mStartFindRange
mSearchRange
mStartPointRange
mEndPointRange
mSoundInterface
mFind
mFoundRange
)
static
NS_DEFINE_CID
(
kFrameTraversalCID
NS_FRAMETRAVERSAL_CID
)
;
#
define
NS_FIND_CONTRACTID
"
mozilla
.
org
/
embedcomp
/
rangefind
;
1
"
nsTypeAheadFind
:
:
nsTypeAheadFind
(
)
:
mStartLinksOnlyPref
(
false
)
mCaretBrowsingOn
(
false
)
mDidAddObservers
(
false
)
mLastFindLength
(
0
)
mIsSoundInitialized
(
false
)
mCaseSensitive
(
false
)
mEntireWord
(
false
)
{
}
nsTypeAheadFind
:
:
~
nsTypeAheadFind
(
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefInternal
(
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
)
;
if
(
prefInternal
)
{
prefInternal
-
>
RemoveObserver
(
"
accessibility
.
typeaheadfind
"
this
)
;
prefInternal
-
>
RemoveObserver
(
"
accessibility
.
browsewithcaret
"
this
)
;
}
}
nsresult
nsTypeAheadFind
:
:
Init
(
nsIDocShell
*
aDocShell
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefInternal
(
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
)
;
mSearchRange
=
nullptr
;
mStartPointRange
=
nullptr
;
mEndPointRange
=
nullptr
;
if
(
!
prefInternal
|
|
!
EnsureFind
(
)
)
return
NS_ERROR_FAILURE
;
SetDocShell
(
aDocShell
)
;
if
(
!
mDidAddObservers
)
{
mDidAddObservers
=
true
;
nsresult
rv
=
prefInternal
-
>
AddObserver
(
"
accessibility
.
browsewithcaret
"
this
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
prefInternal
-
>
AddObserver
(
"
accessibility
.
typeaheadfind
"
this
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PrefsReset
(
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
DOM_WINDOW_DESTROYED_TOPIC
true
)
;
}
}
if
(
!
mIsSoundInitialized
&
&
!
mNotFoundSoundURL
.
IsEmpty
(
)
)
{
mIsSoundInitialized
=
true
;
mSoundInterface
=
do_CreateInstance
(
"
mozilla
.
org
/
sound
;
1
"
)
;
if
(
mSoundInterface
&
&
!
mNotFoundSoundURL
.
EqualsLiteral
(
"
beep
"
)
)
{
mSoundInterface
-
>
Init
(
)
;
}
}
return
NS_OK
;
}
nsresult
nsTypeAheadFind
:
:
PrefsReset
(
)
{
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
(
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
)
;
NS_ENSURE_TRUE
(
prefBranch
NS_ERROR_FAILURE
)
;
prefBranch
-
>
GetBoolPref
(
"
accessibility
.
typeaheadfind
.
startlinksonly
"
&
mStartLinksOnlyPref
)
;
bool
isSoundEnabled
=
true
;
prefBranch
-
>
GetBoolPref
(
"
accessibility
.
typeaheadfind
.
enablesound
"
&
isSoundEnabled
)
;
nsAutoCString
soundStr
;
if
(
isSoundEnabled
)
prefBranch
-
>
GetCharPref
(
"
accessibility
.
typeaheadfind
.
soundURL
"
soundStr
)
;
mNotFoundSoundURL
=
soundStr
;
if
(
!
mNotFoundSoundURL
.
IsEmpty
(
)
&
&
!
mNotFoundSoundURL
.
EqualsLiteral
(
"
beep
"
)
)
{
if
(
!
mSoundInterface
)
{
mSoundInterface
=
do_CreateInstance
(
"
mozilla
.
org
/
sound
;
1
"
)
;
}
if
(
mSoundInterface
)
{
mIsSoundInitialized
=
true
;
mSoundInterface
-
>
Init
(
)
;
}
}
prefBranch
-
>
GetBoolPref
(
"
accessibility
.
browsewithcaret
"
&
mCaretBrowsingOn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
SetCaseSensitive
(
bool
isCaseSensitive
)
{
mCaseSensitive
=
isCaseSensitive
;
if
(
mFind
)
{
mFind
-
>
SetCaseSensitive
(
mCaseSensitive
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
GetCaseSensitive
(
bool
*
isCaseSensitive
)
{
*
isCaseSensitive
=
mCaseSensitive
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
SetEntireWord
(
bool
isEntireWord
)
{
mEntireWord
=
isEntireWord
;
if
(
mFind
)
{
mFind
-
>
SetEntireWord
(
mEntireWord
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
GetEntireWord
(
bool
*
isEntireWord
)
{
*
isEntireWord
=
mEntireWord
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
SetDocShell
(
nsIDocShell
*
aDocShell
)
{
mDocShell
=
do_GetWeakReference
(
aDocShell
)
;
mWebBrowserFind
=
do_GetInterface
(
aDocShell
)
;
NS_ENSURE_TRUE
(
mWebBrowserFind
NS_ERROR_FAILURE
)
;
mPresShell
=
do_GetWeakReference
(
aDocShell
-
>
GetPresShell
(
)
)
;
ReleaseStrongMemberVariables
(
)
;
return
NS_OK
;
}
void
nsTypeAheadFind
:
:
ReleaseStrongMemberVariables
(
)
{
mStartFindRange
=
nullptr
;
mStartPointRange
=
nullptr
;
mSearchRange
=
nullptr
;
mEndPointRange
=
nullptr
;
mFoundLink
=
nullptr
;
mFoundEditable
=
nullptr
;
mFoundRange
=
nullptr
;
mCurrentWindow
=
nullptr
;
mSelectionController
=
nullptr
;
mFind
=
nullptr
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
SetSelectionModeAndRepaint
(
int16_t
aToggle
)
{
nsCOMPtr
<
nsISelectionController
>
selectionController
=
do_QueryReferent
(
mSelectionController
)
;
if
(
!
selectionController
)
{
return
NS_OK
;
}
selectionController
-
>
SetDisplaySelection
(
aToggle
)
;
selectionController
-
>
RepaintSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
CollapseSelection
(
)
{
nsCOMPtr
<
nsISelectionController
>
selectionController
=
do_QueryReferent
(
mSelectionController
)
;
if
(
!
selectionController
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
selectionController
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
selection
)
{
selection
-
>
CollapseToStart
(
IgnoreErrors
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
return
PrefsReset
(
)
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
DOM_WINDOW_DESTROYED_TOPIC
)
&
&
SameCOMIdentity
(
aSubject
mCurrentWindow
)
)
{
ReleaseStrongMemberVariables
(
)
;
}
return
NS_OK
;
}
void
nsTypeAheadFind
:
:
SaveFind
(
)
{
if
(
mWebBrowserFind
)
mWebBrowserFind
-
>
SetSearchString
(
mTypeAheadBuffer
)
;
mLastFindLength
=
mTypeAheadBuffer
.
Length
(
)
;
}
void
nsTypeAheadFind
:
:
PlayNotFoundSound
(
)
{
if
(
mNotFoundSoundURL
.
IsEmpty
(
)
)
return
;
if
(
!
mSoundInterface
)
mSoundInterface
=
do_CreateInstance
(
"
mozilla
.
org
/
sound
;
1
"
)
;
if
(
mSoundInterface
)
{
mIsSoundInitialized
=
true
;
if
(
mNotFoundSoundURL
.
EqualsLiteral
(
"
beep
"
)
)
{
mSoundInterface
-
>
Beep
(
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
soundURI
;
if
(
mNotFoundSoundURL
.
EqualsLiteral
(
"
default
"
)
)
NS_NewURI
(
getter_AddRefs
(
soundURI
)
NS_LITERAL_CSTRING
(
TYPEAHEADFIND_NOTFOUND_WAV_URL
)
)
;
else
NS_NewURI
(
getter_AddRefs
(
soundURI
)
mNotFoundSoundURL
)
;
nsCOMPtr
<
nsIURL
>
soundURL
(
do_QueryInterface
(
soundURI
)
)
;
if
(
soundURL
)
mSoundInterface
-
>
Play
(
soundURL
)
;
}
}
nsresult
nsTypeAheadFind
:
:
FindItNow
(
uint32_t
aMode
bool
aIsLinksOnly
bool
aIsFirstVisiblePreferred
bool
aDontIterateFrames
uint16_t
*
aResult
)
{
*
aResult
=
FIND_NOTFOUND
;
mFoundLink
=
nullptr
;
mFoundEditable
=
nullptr
;
mFoundRange
=
nullptr
;
mCurrentWindow
=
nullptr
;
RefPtr
<
PresShell
>
startingPresShell
=
GetPresShell
(
)
;
if
(
!
startingPresShell
)
{
nsCOMPtr
<
nsIDocShell
>
ds
=
do_QueryReferent
(
mDocShell
)
;
NS_ENSURE_TRUE
(
ds
NS_ERROR_FAILURE
)
;
startingPresShell
=
ds
-
>
GetPresShell
(
)
;
mPresShell
=
do_GetWeakReference
(
startingPresShell
)
;
}
RefPtr
<
PresShell
>
presShell
=
startingPresShell
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
presShell
-
>
FlushPendingNotifications
(
mozilla
:
:
FlushType
:
:
Layout
)
;
RefPtr
<
nsPresContext
>
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
return
NS_ERROR_FAILURE
;
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsISelectionController
>
selectionController
=
do_QueryReferent
(
mSelectionController
)
;
if
(
!
selectionController
)
{
GetSelection
(
presShell
getter_AddRefs
(
selectionController
)
getter_AddRefs
(
selection
)
)
;
mSelectionController
=
do_GetWeakReference
(
selectionController
)
;
}
else
{
selection
=
selectionController
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
}
nsCOMPtr
<
nsIDocShell
>
startingDocShell
(
presContext
-
>
GetDocShell
(
)
)
;
NS_ASSERTION
(
startingDocShell
"
Bug
175321
Crashes
with
Type
Ahead
Find
[
nsTypeAheadFind
:
:
FindItNow
]
"
)
;
if
(
!
startingDocShell
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIDocShell
>
currentDocShell
;
nsCOMPtr
<
nsISupports
>
currentContainer
;
nsCOMPtr
<
nsISimpleEnumerator
>
docShellEnumerator
;
nsCOMPtr
<
nsIDocShellTreeItem
>
rootContentTreeItem
;
nsCOMPtr
<
nsIDocShell
>
rootContentDocShell
;
if
(
!
aDontIterateFrames
)
{
startingDocShell
-
>
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
rootContentTreeItem
)
)
;
rootContentDocShell
=
do_QueryInterface
(
rootContentTreeItem
)
;
if
(
!
rootContentDocShell
)
return
NS_ERROR_FAILURE
;
rootContentDocShell
-
>
GetDocShellEnumerator
(
nsIDocShellTreeItem
:
:
typeContent
nsIDocShell
:
:
ENUMERATE_FORWARDS
getter_AddRefs
(
docShellEnumerator
)
)
;
currentContainer
=
do_QueryInterface
(
rootContentDocShell
)
;
bool
hasMoreDocShells
;
while
(
NS_SUCCEEDED
(
docShellEnumerator
-
>
HasMoreElements
(
&
hasMoreDocShells
)
)
&
&
hasMoreDocShells
)
{
docShellEnumerator
-
>
GetNext
(
getter_AddRefs
(
currentContainer
)
)
;
currentDocShell
=
do_QueryInterface
(
currentContainer
)
;
if
(
!
currentDocShell
|
|
currentDocShell
=
=
startingDocShell
|
|
aIsFirstVisiblePreferred
)
break
;
}
}
else
{
currentContainer
=
currentDocShell
=
startingDocShell
;
}
bool
findPrev
=
(
aMode
=
=
FIND_PREVIOUS
|
|
aMode
=
=
FIND_LAST
)
;
bool
useSelection
=
(
aMode
!
=
FIND_FIRST
&
&
aMode
!
=
FIND_LAST
)
&
&
(
!
aIsFirstVisiblePreferred
|
|
mStartFindRange
)
;
RefPtr
<
nsRange
>
returnRange
;
if
(
NS_FAILED
(
GetSearchContainers
(
currentContainer
useSelection
?
selectionController
.
get
(
)
:
nullptr
aIsFirstVisiblePreferred
findPrev
getter_AddRefs
(
presShell
)
getter_AddRefs
(
presContext
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mStartPointRange
)
{
mStartPointRange
=
new
nsRange
(
presShell
-
>
GetDocument
(
)
)
;
}
int16_t
rangeCompareResult
=
mStartPointRange
-
>
CompareBoundaryPoints
(
Range_Binding
:
:
START_TO_START
*
mSearchRange
IgnoreErrors
(
)
)
;
bool
hasWrapped
=
(
rangeCompareResult
<
0
)
;
if
(
mTypeAheadBuffer
.
IsEmpty
(
)
|
|
!
EnsureFind
(
)
)
return
NS_ERROR_FAILURE
;
mFind
-
>
SetFindBackwards
(
findPrev
)
;
while
(
true
)
{
while
(
true
)
{
mFind
-
>
Find
(
mTypeAheadBuffer
mSearchRange
mStartPointRange
mEndPointRange
getter_AddRefs
(
returnRange
)
)
;
if
(
!
returnRange
)
{
break
;
}
bool
isInsideLink
=
false
isStartingLink
=
false
;
if
(
aIsLinksOnly
)
{
RangeStartsInsideLink
(
returnRange
&
isInsideLink
&
isStartingLink
)
;
}
bool
usesIndependentSelection
;
bool
canSeeRange
=
IsRangeVisible
(
returnRange
aIsFirstVisiblePreferred
false
getter_AddRefs
(
mStartPointRange
)
&
usesIndependentSelection
)
;
if
(
(
!
canSeeRange
&
&
!
usesIndependentSelection
)
|
|
(
aIsLinksOnly
&
&
!
isInsideLink
)
|
|
(
mStartLinksOnlyPref
&
&
aIsLinksOnly
&
&
!
isStartingLink
)
)
{
if
(
findPrev
)
{
IgnoredErrorResult
rv
;
int16_t
compareResult
=
mStartPointRange
-
>
CompareBoundaryPoints
(
Range_Binding
:
:
START_TO_END
*
returnRange
rv
)
;
if
(
!
rv
.
Failed
(
)
&
&
compareResult
<
=
0
)
{
mStartPointRange
-
>
Collapse
(
false
)
;
}
else
{
mStartPointRange
=
returnRange
-
>
CloneRange
(
)
;
mStartPointRange
-
>
Collapse
(
true
)
;
}
}
else
{
IgnoredErrorResult
rv
;
int16_t
compareResult
=
mStartPointRange
-
>
CompareBoundaryPoints
(
Range_Binding
:
:
END_TO_START
*
returnRange
rv
)
;
if
(
!
rv
.
Failed
(
)
&
&
compareResult
>
=
0
)
{
mStartPointRange
-
>
Collapse
(
true
)
;
}
else
{
mStartPointRange
=
returnRange
-
>
CloneRange
(
)
;
mStartPointRange
-
>
Collapse
(
false
)
;
}
}
continue
;
}
mFoundRange
=
returnRange
;
if
(
selection
)
{
selection
-
>
CollapseToStart
(
IgnoreErrors
(
)
)
;
SetSelectionModeAndRepaint
(
nsISelectionController
:
:
SELECTION_ON
)
;
}
if
(
presShell
!
=
startingPresShell
)
{
mPresShell
=
do_GetWeakReference
(
presShell
)
;
}
RefPtr
<
Document
>
document
=
presShell
-
>
GetDocument
(
)
;
NS_ASSERTION
(
document
"
Wow
presShell
doesn
'
t
have
document
!
"
)
;
if
(
!
document
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
document
-
>
GetInnerWindow
(
)
;
NS_ASSERTION
(
window
"
document
has
no
window
"
)
;
if
(
!
window
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIFocusManager
>
fm
=
do_GetService
(
FOCUSMANAGER_CONTRACTID
)
;
if
(
usesIndependentSelection
)
{
bool
shouldFocusEditableElement
=
false
;
if
(
fm
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
nsresult
rv
=
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
focusedWindow
)
{
auto
*
fwPI
=
nsPIDOMWindowOuter
:
:
From
(
focusedWindow
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
fwTreeItem
(
fwPI
-
>
GetDocShell
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
fwRootTreeItem
;
rv
=
fwTreeItem
-
>
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
fwRootTreeItem
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
fwRootTreeItem
=
=
rootContentTreeItem
)
shouldFocusEditableElement
=
true
;
}
}
}
nsCOMPtr
<
nsINode
>
node
=
returnRange
-
>
GetStartContainer
(
)
;
while
(
node
)
{
nsCOMPtr
<
nsIEditor
>
editor
;
if
(
auto
input
=
HTMLInputElement
:
:
FromNode
(
node
)
)
{
editor
=
input
-
>
GetEditor
(
)
;
}
else
if
(
auto
textarea
=
HTMLTextAreaElement
:
:
FromNode
(
node
)
)
{
editor
=
textarea
-
>
GetEditor
(
)
;
}
else
{
node
=
node
-
>
GetParentNode
(
)
;
continue
;
}
NS_ASSERTION
(
editor
"
Editable
element
has
no
editor
!
"
)
;
if
(
!
editor
)
{
break
;
}
editor
-
>
GetSelectionController
(
getter_AddRefs
(
selectionController
)
)
;
if
(
selectionController
)
{
selection
=
selectionController
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
}
mFoundEditable
=
node
-
>
AsElement
(
)
;
if
(
!
shouldFocusEditableElement
)
{
break
;
}
if
(
fm
)
{
fm
-
>
SetFocus
(
mFoundEditable
0
)
;
}
break
;
}
}
if
(
!
mFoundEditable
)
{
GetSelection
(
presShell
getter_AddRefs
(
selectionController
)
getter_AddRefs
(
selection
)
)
;
}
mSelectionController
=
do_GetWeakReference
(
selectionController
)
;
if
(
selection
)
{
selection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
selection
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
returnRange
IgnoreErrors
(
)
)
;
}
if
(
!
mFoundEditable
&
&
fm
)
{
fm
-
>
MoveFocus
(
window
-
>
GetOuterWindow
(
)
nullptr
nsIFocusManager
:
:
MOVEFOCUS_CARET
nsIFocusManager
:
:
FLAG_NOSCROLL
|
nsIFocusManager
:
:
FLAG_NOSWITCHFRAME
getter_AddRefs
(
mFoundLink
)
)
;
}
if
(
selectionController
)
{
SetSelectionModeAndRepaint
(
nsISelectionController
:
:
SELECTION_ATTENTION
)
;
selectionController
-
>
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_WHOLE_SELECTION
nsISelectionController
:
:
SCROLL_CENTER_VERTICALLY
|
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
)
;
}
mCurrentWindow
=
window
;
*
aResult
=
hasWrapped
?
FIND_WRAPPED
:
FIND_FOUND
;
return
NS_OK
;
}
if
(
aDontIterateFrames
)
{
return
NS_OK
;
}
bool
hasTriedFirstDoc
=
false
;
do
{
bool
hasMoreDocShells
;
if
(
NS_SUCCEEDED
(
docShellEnumerator
-
>
HasMoreElements
(
&
hasMoreDocShells
)
)
&
&
hasMoreDocShells
)
{
docShellEnumerator
-
>
GetNext
(
getter_AddRefs
(
currentContainer
)
)
;
NS_ASSERTION
(
currentContainer
"
HasMoreElements
lied
to
us
!
"
)
;
currentDocShell
=
do_QueryInterface
(
currentContainer
)
;
if
(
currentDocShell
)
break
;
}
else
if
(
hasTriedFirstDoc
)
return
NS_ERROR_FAILURE
;
rootContentDocShell
-
>
GetDocShellEnumerator
(
nsIDocShellTreeItem
:
:
typeContent
nsIDocShell
:
:
ENUMERATE_FORWARDS
getter_AddRefs
(
docShellEnumerator
)
)
;
hasTriedFirstDoc
=
true
;
}
while
(
docShellEnumerator
)
;
bool
continueLoop
=
false
;
if
(
currentDocShell
!
=
startingDocShell
)
continueLoop
=
true
;
else
if
(
!
hasWrapped
|
|
aIsFirstVisiblePreferred
)
{
aIsFirstVisiblePreferred
=
false
;
hasWrapped
=
true
;
continueLoop
=
true
;
}
if
(
continueLoop
)
{
if
(
NS_FAILED
(
GetSearchContainers
(
currentContainer
nullptr
aIsFirstVisiblePreferred
findPrev
getter_AddRefs
(
presShell
)
getter_AddRefs
(
presContext
)
)
)
)
{
continue
;
}
if
(
findPrev
)
{
RefPtr
<
nsRange
>
tempRange
=
mStartPointRange
-
>
CloneRange
(
)
;
if
(
!
mEndPointRange
)
{
mEndPointRange
=
new
nsRange
(
presShell
-
>
GetDocument
(
)
)
;
}
mStartPointRange
=
mEndPointRange
;
mEndPointRange
=
tempRange
;
}
continue
;
}
break
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
GetSearchString
(
nsAString
&
aSearchString
)
{
aSearchString
=
mTypeAheadBuffer
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
GetFoundLink
(
Element
*
*
aFoundLink
)
{
NS_ENSURE_ARG_POINTER
(
aFoundLink
)
;
*
aFoundLink
=
mFoundLink
;
NS_IF_ADDREF
(
*
aFoundLink
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
GetFoundEditable
(
Element
*
*
aFoundEditable
)
{
NS_ENSURE_ARG_POINTER
(
aFoundEditable
)
;
*
aFoundEditable
=
mFoundEditable
;
NS_IF_ADDREF
(
*
aFoundEditable
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
GetCurrentWindow
(
mozIDOMWindow
*
*
aCurrentWindow
)
{
NS_ENSURE_ARG_POINTER
(
aCurrentWindow
)
;
*
aCurrentWindow
=
mCurrentWindow
;
NS_IF_ADDREF
(
*
aCurrentWindow
)
;
return
NS_OK
;
}
nsresult
nsTypeAheadFind
:
:
GetSearchContainers
(
nsISupports
*
aContainer
nsISelectionController
*
aSelectionController
bool
aIsFirstVisiblePreferred
bool
aFindPrev
PresShell
*
*
aPresShell
nsPresContext
*
*
aPresContext
)
{
NS_ENSURE_ARG_POINTER
(
aContainer
)
;
NS_ENSURE_ARG_POINTER
(
aPresShell
)
;
NS_ENSURE_ARG_POINTER
(
aPresContext
)
;
*
aPresShell
=
nullptr
;
*
aPresContext
=
nullptr
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
do_QueryInterface
(
aContainer
)
)
;
if
(
!
docShell
)
return
NS_ERROR_FAILURE
;
RefPtr
<
PresShell
>
presShell
=
docShell
-
>
GetPresShell
(
)
;
RefPtr
<
nsPresContext
>
presContext
=
docShell
-
>
GetPresContext
(
)
;
if
(
!
presShell
|
|
!
presContext
)
return
NS_ERROR_FAILURE
;
Document
*
doc
=
presShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIContent
>
rootContent
;
if
(
doc
-
>
IsHTMLOrXHTML
(
)
)
{
rootContent
=
doc
-
>
GetBody
(
)
;
}
if
(
!
rootContent
)
{
rootContent
=
doc
-
>
GetRootElement
(
)
;
if
(
!
rootContent
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
mSearchRange
)
{
mSearchRange
=
new
nsRange
(
doc
)
;
}
nsCOMPtr
<
nsINode
>
searchRootNode
(
rootContent
)
;
mSearchRange
-
>
SelectNodeContents
(
*
searchRootNode
IgnoreErrors
(
)
)
;
if
(
!
mStartPointRange
)
{
mStartPointRange
=
new
nsRange
(
doc
)
;
}
mStartPointRange
-
>
SetStart
(
*
searchRootNode
0
IgnoreErrors
(
)
)
;
mStartPointRange
-
>
Collapse
(
true
)
;
if
(
!
mEndPointRange
)
{
mEndPointRange
=
new
nsRange
(
doc
)
;
}
mEndPointRange
-
>
SetEnd
(
*
searchRootNode
searchRootNode
-
>
Length
(
)
IgnoreErrors
(
)
)
;
mEndPointRange
-
>
Collapse
(
false
)
;
RefPtr
<
nsRange
>
currentSelectionRange
;
RefPtr
<
PresShell
>
selectionPresShell
=
GetPresShell
(
)
;
if
(
aSelectionController
&
&
selectionPresShell
&
&
selectionPresShell
=
=
presShell
)
{
RefPtr
<
Selection
>
selection
=
aSelectionController
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
selection
)
{
currentSelectionRange
=
selection
-
>
GetRangeAt
(
0
)
;
}
}
if
(
!
currentSelectionRange
)
{
IsRangeVisible
(
mSearchRange
aIsFirstVisiblePreferred
true
getter_AddRefs
(
mStartPointRange
)
nullptr
)
;
}
else
{
uint32_t
startOffset
;
nsCOMPtr
<
nsINode
>
startNode
;
if
(
aFindPrev
)
{
startNode
=
currentSelectionRange
-
>
GetStartContainer
(
)
;
startOffset
=
currentSelectionRange
-
>
StartOffset
(
)
;
}
else
{
startNode
=
currentSelectionRange
-
>
GetEndContainer
(
)
;
startOffset
=
currentSelectionRange
-
>
EndOffset
(
)
;
}
if
(
!
startNode
)
{
startNode
=
rootContent
;
}
mStartPointRange
-
>
SelectNode
(
*
startNode
IgnoreErrors
(
)
)
;
mStartPointRange
-
>
SetStart
(
*
startNode
startOffset
IgnoreErrors
(
)
)
;
}
mStartPointRange
-
>
Collapse
(
true
)
;
presShell
.
forget
(
aPresShell
)
;
presContext
.
forget
(
aPresContext
)
;
return
NS_OK
;
}
void
nsTypeAheadFind
:
:
RangeStartsInsideLink
(
nsRange
*
aRange
bool
*
aIsInsideLink
bool
*
aIsStartingLink
)
{
*
aIsInsideLink
=
false
;
*
aIsStartingLink
=
true
;
uint32_t
startOffset
=
aRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsIContent
>
startContent
=
do_QueryInterface
(
aRange
-
>
GetStartContainer
(
)
)
;
if
(
!
startContent
)
{
MOZ_ASSERT_UNREACHABLE
(
"
startContent
should
never
be
null
"
)
;
return
;
}
nsCOMPtr
<
nsIContent
>
origContent
=
startContent
;
if
(
startContent
-
>
IsElement
(
)
)
{
nsIContent
*
childContent
=
aRange
-
>
GetChildAtStartOffset
(
)
;
if
(
childContent
)
{
startContent
=
childContent
;
}
}
else
if
(
startOffset
>
0
)
{
const
nsTextFragment
*
textFrag
=
startContent
-
>
GetText
(
)
;
if
(
textFrag
)
{
for
(
uint32_t
index
=
0
;
index
<
startOffset
;
index
+
+
)
{
if
(
!
mozilla
:
:
dom
:
:
IsSpaceCharacter
(
textFrag
-
>
CharAt
(
static_cast
<
int32_t
>
(
index
)
)
)
)
{
*
aIsStartingLink
=
false
;
break
;
}
}
}
}
while
(
true
)
{
if
(
startContent
-
>
IsHTMLElement
(
)
)
{
nsCOMPtr
<
mozilla
:
:
dom
:
:
Link
>
link
(
do_QueryInterface
(
startContent
)
)
;
if
(
link
)
{
*
aIsInsideLink
=
startContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
)
;
return
;
}
}
else
{
*
aIsInsideLink
=
startContent
-
>
IsElement
(
)
&
&
startContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_XLink
nsGkAtoms
:
:
href
)
;
if
(
*
aIsInsideLink
)
{
if
(
!
startContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_XLink
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
simple
"
)
eCaseMatters
)
)
{
*
aIsInsideLink
=
false
;
}
return
;
}
}
nsCOMPtr
<
nsIContent
>
parent
=
startContent
-
>
GetParent
(
)
;
if
(
!
parent
)
break
;
nsIContent
*
parentsFirstChild
=
parent
-
>
GetFirstChild
(
)
;
if
(
parentsFirstChild
&
&
parentsFirstChild
-
>
TextIsOnlyWhitespace
(
)
)
{
parentsFirstChild
=
parentsFirstChild
-
>
GetNextSibling
(
)
;
}
if
(
parentsFirstChild
!
=
startContent
)
{
*
aIsStartingLink
=
false
;
}
startContent
=
parent
;
}
*
aIsStartingLink
=
false
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
Find
(
const
nsAString
&
aSearchString
bool
aLinksOnly
uint32_t
aMode
bool
aDontIterateFrames
uint16_t
*
aResult
)
{
if
(
aMode
=
=
nsITypeAheadFind
:
:
FIND_PREVIOUS
|
|
aMode
=
=
nsITypeAheadFind
:
:
FIND_NEXT
)
{
if
(
mTypeAheadBuffer
.
IsEmpty
(
)
)
{
*
aResult
=
FIND_NOTFOUND
;
}
else
{
FindItNow
(
aMode
aLinksOnly
false
aDontIterateFrames
aResult
)
;
}
return
NS_OK
;
}
nsresult
rv
=
FindInternal
(
aMode
aSearchString
aLinksOnly
aDontIterateFrames
aResult
)
;
return
(
aMode
=
=
nsITypeAheadFind
:
:
FIND_INITIAL
)
?
rv
:
NS_OK
;
}
nsresult
nsTypeAheadFind
:
:
FindInternal
(
uint32_t
aMode
const
nsAString
&
aSearchString
bool
aLinksOnly
bool
aDontIterateFrames
uint16_t
*
aResult
)
{
*
aResult
=
FIND_NOTFOUND
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
nsCOMPtr
<
nsIDocShell
>
ds
(
do_QueryReferent
(
mDocShell
)
)
;
NS_ENSURE_TRUE
(
ds
NS_ERROR_FAILURE
)
;
presShell
=
ds
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
mPresShell
=
do_GetWeakReference
(
presShell
)
;
}
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsISelectionController
>
selectionController
=
do_QueryReferent
(
mSelectionController
)
;
if
(
!
selectionController
)
{
GetSelection
(
presShell
getter_AddRefs
(
selectionController
)
getter_AddRefs
(
selection
)
)
;
mSelectionController
=
do_GetWeakReference
(
selectionController
)
;
}
else
{
selection
=
selectionController
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
}
if
(
selection
)
{
selection
-
>
CollapseToStart
(
IgnoreErrors
(
)
)
;
}
if
(
aSearchString
.
IsEmpty
(
)
)
{
mTypeAheadBuffer
.
Truncate
(
)
;
mStartFindRange
=
nullptr
;
mSelectionController
=
nullptr
;
*
aResult
=
FIND_FOUND
;
return
NS_OK
;
}
bool
atEnd
=
false
;
bool
isInitial
=
aMode
=
=
nsITypeAheadFind
:
:
FIND_INITIAL
;
if
(
isInitial
)
{
if
(
mTypeAheadBuffer
.
Length
(
)
)
{
const
nsAString
&
oldStr
=
Substring
(
mTypeAheadBuffer
0
mTypeAheadBuffer
.
Length
(
)
)
;
const
nsAString
&
newStr
=
Substring
(
aSearchString
0
mTypeAheadBuffer
.
Length
(
)
)
;
if
(
oldStr
.
Equals
(
newStr
)
)
atEnd
=
true
;
const
nsAString
&
newStr2
=
Substring
(
aSearchString
0
aSearchString
.
Length
(
)
)
;
const
nsAString
&
oldStr2
=
Substring
(
mTypeAheadBuffer
0
aSearchString
.
Length
(
)
)
;
if
(
oldStr2
.
Equals
(
newStr2
)
)
atEnd
=
true
;
if
(
!
atEnd
)
mStartFindRange
=
nullptr
;
}
}
int32_t
bufferLength
=
mTypeAheadBuffer
.
Length
(
)
;
mTypeAheadBuffer
=
aSearchString
;
bool
isFirstVisiblePreferred
=
false
;
if
(
bufferLength
=
=
0
&
&
isInitial
)
{
bool
isSelectionCollapsed
=
!
selection
|
|
selection
-
>
IsCollapsed
(
)
;
isFirstVisiblePreferred
=
!
atEnd
&
&
!
mCaretBrowsingOn
&
&
isSelectionCollapsed
;
if
(
isFirstVisiblePreferred
)
{
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
NS_OK
)
;
nsCOMPtr
<
Document
>
document
=
presShell
-
>
GetDocument
(
)
;
if
(
!
document
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIFocusManager
>
fm
=
do_GetService
(
FOCUSMANAGER_CONTRACTID
)
;
if
(
fm
)
{
nsPIDOMWindowOuter
*
window
=
document
-
>
GetWindow
(
)
;
RefPtr
<
Element
>
focusedElement
;
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedElementForWindow
(
window
false
getter_AddRefs
(
focusedWindow
)
getter_AddRefs
(
focusedElement
)
)
;
if
(
focusedElement
&
&
focusedElement
!
=
document
-
>
GetRootElement
(
)
)
{
fm
-
>
MoveCaretToFocus
(
window
)
;
isFirstVisiblePreferred
=
false
;
}
}
}
}
nsresult
rv
=
FindItNow
(
aMode
aLinksOnly
isFirstVisiblePreferred
aDontIterateFrames
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
mTypeAheadBuffer
.
Length
(
)
=
=
1
)
{
mStartFindRange
=
nullptr
;
if
(
selection
)
{
RefPtr
<
nsRange
>
startFindRange
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
startFindRange
)
{
mStartFindRange
=
startFindRange
-
>
CloneRange
(
)
;
}
}
}
}
else
if
(
isInitial
)
{
if
(
!
mEntireWord
&
&
mTypeAheadBuffer
.
Length
(
)
>
mLastFindLength
)
PlayNotFoundSound
(
)
;
}
SaveFind
(
)
;
return
NS_OK
;
}
void
nsTypeAheadFind
:
:
GetSelection
(
PresShell
*
aPresShell
nsISelectionController
*
*
aSelCon
Selection
*
*
aDOMSel
)
{
if
(
!
aPresShell
)
return
;
*
aDOMSel
=
nullptr
;
nsPresContext
*
presContext
=
aPresShell
-
>
GetPresContext
(
)
;
nsIFrame
*
frame
=
aPresShell
-
>
GetRootFrame
(
)
;
if
(
presContext
&
&
frame
)
{
frame
-
>
GetSelectionController
(
presContext
aSelCon
)
;
if
(
*
aSelCon
)
{
RefPtr
<
Selection
>
sel
=
(
*
aSelCon
)
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
sel
.
forget
(
aDOMSel
)
;
}
}
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
GetFoundRange
(
nsRange
*
*
aFoundRange
)
{
NS_ENSURE_ARG_POINTER
(
aFoundRange
)
;
if
(
mFoundRange
=
=
nullptr
)
{
*
aFoundRange
=
nullptr
;
return
NS_OK
;
}
*
aFoundRange
=
mFoundRange
-
>
CloneRange
(
)
.
take
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
IsRangeVisible
(
nsRange
*
aRange
bool
aMustBeInViewPort
bool
*
aResult
)
{
RefPtr
<
nsRange
>
ignored
;
*
aResult
=
IsRangeVisible
(
aRange
aMustBeInViewPort
false
getter_AddRefs
(
ignored
)
nullptr
)
;
return
NS_OK
;
}
enum
class
RectVisibility
{
Visible
AboveViewport
BelowViewport
LeftOfViewport
RightOfViewport
}
;
static
RectVisibility
GetRectVisibility
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
nscoord
aMinTwips
)
{
PresShell
*
ps
=
aFrame
-
>
PresShell
(
)
;
nsIFrame
*
rootFrame
=
ps
-
>
GetRootFrame
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
rootFrame
"
How
can
someone
have
a
frame
for
this
presshell
when
there
'
s
no
root
?
"
)
;
nsIScrollableFrame
*
sf
=
ps
-
>
GetRootScrollFrameAsScrollable
(
)
;
nsRect
scrollPortRect
;
if
(
sf
)
{
scrollPortRect
=
sf
-
>
GetScrollPortRect
(
)
;
nsIFrame
*
f
=
do_QueryFrame
(
sf
)
;
scrollPortRect
+
=
f
-
>
GetOffsetTo
(
rootFrame
)
;
}
else
{
scrollPortRect
=
nsRect
(
nsPoint
(
0
0
)
rootFrame
-
>
GetSize
(
)
)
;
}
nsRect
visibleAreaRect
(
scrollPortRect
)
;
nsIScrollableFrame
*
scrollAncestorFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
aFrame
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
while
(
scrollAncestorFrame
)
{
nsRect
scrollAncestorRect
=
scrollAncestorFrame
-
>
GetScrollPortRect
(
)
;
nsIFrame
*
f
=
do_QueryFrame
(
scrollAncestorFrame
)
;
scrollAncestorRect
+
=
f
-
>
GetOffsetTo
(
rootFrame
)
;
visibleAreaRect
=
visibleAreaRect
.
Intersect
(
scrollAncestorRect
)
;
scrollAncestorFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
f
-
>
GetParent
(
)
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
}
nsRect
r
=
aRect
+
aFrame
-
>
GetOffsetTo
(
rootFrame
)
;
if
(
visibleAreaRect
.
Contains
(
r
)
)
{
return
RectVisibility
:
:
Visible
;
}
nsRect
insetRect
=
visibleAreaRect
;
insetRect
.
Deflate
(
aMinTwips
aMinTwips
)
;
if
(
r
.
YMost
(
)
<
=
insetRect
.
y
)
{
return
RectVisibility
:
:
AboveViewport
;
}
if
(
r
.
y
>
=
insetRect
.
YMost
(
)
)
{
return
RectVisibility
:
:
BelowViewport
;
}
if
(
r
.
XMost
(
)
<
=
insetRect
.
x
)
{
return
RectVisibility
:
:
LeftOfViewport
;
}
if
(
r
.
x
>
=
insetRect
.
XMost
(
)
)
{
return
RectVisibility
:
:
RightOfViewport
;
}
return
RectVisibility
:
:
Visible
;
}
bool
nsTypeAheadFind
:
:
IsRangeVisible
(
nsRange
*
aRange
bool
aMustBeInViewPort
bool
aGetTopVisibleLeaf
nsRange
*
*
aFirstVisibleRange
bool
*
aUsesIndependentSelection
)
{
NS_ASSERTION
(
aRange
&
&
aFirstVisibleRange
"
params
are
invalid
"
)
;
*
aFirstVisibleRange
=
aRange
-
>
CloneRange
(
)
.
take
(
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aRange
-
>
GetStartContainer
(
)
)
;
if
(
!
content
)
{
return
false
;
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
false
;
}
if
(
!
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
if
(
aUsesIndependentSelection
)
{
*
aUsesIndependentSelection
=
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_INDEPENDENT_SELECTION
)
;
}
int32_t
startFrameOffset
endFrameOffset
;
uint32_t
startRangeOffset
=
aRange
-
>
StartOffset
(
)
;
while
(
true
)
{
frame
-
>
GetOffsets
(
startFrameOffset
endFrameOffset
)
;
if
(
static_cast
<
int32_t
>
(
startRangeOffset
)
<
endFrameOffset
)
{
break
;
}
nsIFrame
*
nextContinuationFrame
=
frame
-
>
GetNextContinuation
(
)
;
if
(
nextContinuationFrame
)
frame
=
nextContinuationFrame
;
else
break
;
}
const
uint16_t
kMinPixels
=
12
;
nscoord
minDistance
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
kMinPixels
)
;
RectVisibility
rectVisibility
=
RectVisibility
:
:
AboveViewport
;
if
(
!
aGetTopVisibleLeaf
&
&
!
frame
-
>
GetRect
(
)
.
IsEmpty
(
)
)
{
rectVisibility
=
GetRectVisibility
(
frame
frame
-
>
GetRectRelativeToSelf
(
)
minDistance
)
;
if
(
rectVisibility
=
=
RectVisibility
:
:
Visible
)
{
bool
atLeastOneRangeRectVisible
=
false
;
nsIFrame
*
containerFrame
=
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
frame
)
;
RefPtr
<
DOMRectList
>
rects
=
aRange
-
>
GetClientRects
(
true
true
)
;
for
(
uint32_t
i
=
0
;
i
<
rects
-
>
Length
(
)
;
+
+
i
)
{
RefPtr
<
DOMRect
>
rect
=
rects
-
>
Item
(
i
)
;
nsRect
r
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
rect
-
>
X
(
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
rect
-
>
Y
(
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
rect
-
>
Width
(
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
rect
-
>
Height
(
)
)
)
;
nsLayoutUtils
:
:
TransformResult
res
=
nsLayoutUtils
:
:
TransformRect
(
containerFrame
frame
r
)
;
if
(
res
=
=
nsLayoutUtils
:
:
TransformResult
:
:
TRANSFORM_SUCCEEDED
)
{
RectVisibility
rangeRectVisibility
=
GetRectVisibility
(
frame
r
minDistance
)
;
if
(
rangeRectVisibility
=
=
RectVisibility
:
:
Visible
)
{
atLeastOneRangeRectVisible
=
true
;
break
;
}
}
}
if
(
atLeastOneRangeRectVisible
)
{
return
IsRangeRendered
(
aRange
)
;
}
}
}
if
(
!
aMustBeInViewPort
)
{
return
true
;
}
nsCOMPtr
<
nsIFrameEnumerator
>
frameTraversal
;
nsCOMPtr
<
nsIFrameTraversal
>
trav
(
do_CreateInstance
(
kFrameTraversalCID
)
)
;
if
(
trav
)
trav
-
>
NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
frame
-
>
PresContext
(
)
frame
eLeaf
false
false
false
false
)
;
if
(
!
frameTraversal
)
{
return
false
;
}
while
(
rectVisibility
=
=
RectVisibility
:
:
AboveViewport
)
{
frameTraversal
-
>
Next
(
)
;
frame
=
frameTraversal
-
>
CurrentItem
(
)
;
if
(
!
frame
)
{
return
false
;
}
while
(
frame
-
>
GetContent
(
)
&
&
frame
-
>
GetContent
(
)
-
>
IsInNativeAnonymousSubtree
(
)
)
{
frame
=
frame
-
>
GetParent
(
)
;
}
if
(
frame
-
>
GetRect
(
)
.
IsEmpty
(
)
)
{
continue
;
}
rectVisibility
=
GetRectVisibility
(
frame
nsRect
(
nsPoint
(
0
0
)
frame
-
>
GetSize
(
)
)
minDistance
)
;
}
if
(
frame
)
{
nsINode
*
firstVisibleNode
=
frame
-
>
GetContent
(
)
;
if
(
firstVisibleNode
)
{
frame
-
>
GetOffsets
(
startFrameOffset
endFrameOffset
)
;
(
*
aFirstVisibleRange
)
-
>
SetStart
(
*
firstVisibleNode
startFrameOffset
IgnoreErrors
(
)
)
;
(
*
aFirstVisibleRange
)
-
>
SetEnd
(
*
firstVisibleNode
endFrameOffset
IgnoreErrors
(
)
)
;
}
}
return
false
;
}
NS_IMETHODIMP
nsTypeAheadFind
:
:
IsRangeRendered
(
nsRange
*
aRange
bool
*
aResult
)
{
*
aResult
=
IsRangeRendered
(
aRange
)
;
return
NS_OK
;
}
bool
nsTypeAheadFind
:
:
IsRangeRendered
(
nsRange
*
aRange
)
{
using
FrameForPointOption
=
nsLayoutUtils
:
:
FrameForPointOption
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aRange
-
>
GetCommonAncestor
(
)
)
;
if
(
!
content
)
{
return
false
;
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
false
;
}
if
(
!
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
AutoTArray
<
nsIFrame
*
8
>
frames
;
nsIFrame
*
rootFrame
=
frame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
RefPtr
<
nsRange
>
range
=
static_cast
<
nsRange
*
>
(
aRange
)
;
RefPtr
<
mozilla
:
:
dom
:
:
DOMRectList
>
rects
=
range
-
>
GetClientRects
(
true
false
)
;
for
(
uint32_t
i
=
0
;
i
<
rects
-
>
Length
(
)
;
+
+
i
)
{
RefPtr
<
mozilla
:
:
dom
:
:
DOMRect
>
rect
=
rects
-
>
Item
(
i
)
;
nsRect
r
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
rect
-
>
X
(
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
rect
-
>
Y
(
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
rect
-
>
Width
(
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
rect
-
>
Height
(
)
)
)
;
nsLayoutUtils
:
:
GetFramesForArea
(
rootFrame
r
frames
{
FrameForPointOption
:
:
IgnorePaintSuppression
FrameForPointOption
:
:
IgnoreRootScrollFrame
FrameForPointOption
:
:
OnlyVisible
}
)
;
for
(
const
auto
&
f
:
frames
)
{
if
(
f
-
>
GetContent
(
)
=
=
content
)
{
return
true
;
}
}
frames
.
ClearAndRetainStorage
(
)
;
}
return
false
;
}
already_AddRefed
<
PresShell
>
nsTypeAheadFind
:
:
GetPresShell
(
)
{
if
(
!
mPresShell
)
{
return
nullptr
;
}
RefPtr
<
PresShell
>
presShell
=
do_QueryReferent
(
mPresShell
)
;
if
(
presShell
)
{
nsPresContext
*
pc
=
presShell
-
>
GetPresContext
(
)
;
if
(
!
pc
|
|
!
pc
-
>
GetContainerWeak
(
)
)
{
return
nullptr
;
}
}
return
presShell
.
forget
(
)
;
}
