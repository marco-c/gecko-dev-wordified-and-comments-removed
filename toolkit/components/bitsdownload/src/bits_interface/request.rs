use
super
:
:
{
action
:
:
{
Action
ServiceAction
}
error
:
:
{
ErrorStage
:
:
{
MainThread
Pretask
}
ErrorType
ErrorType
:
:
{
BitsStateCancelled
FailedToDispatchRunnable
FailedToStartThread
InvalidArgument
OperationAlreadyInProgress
TransferAlreadyComplete
}
}
monitor
:
:
MonitorRunnable
task
:
:
{
CancelTask
ChangeMonitorIntervalTask
CompleteTask
Priority
ResumeTask
SetNoProgressTimeoutTask
SetPriorityTask
SuspendTask
}
BitsService
BitsTaskError
}
;
use
nsIBitsRequest_method
;
use
bits_client
:
:
{
BitsMonitorClient
Guid
}
;
use
log
:
:
{
error
info
warn
}
;
use
moz_task
:
:
create_thread
;
use
nserror
:
:
{
nsresult
NS_ERROR_ABORT
NS_ERROR_NOT_IMPLEMENTED
NS_OK
}
;
use
nsstring
:
:
{
nsACString
nsCString
}
;
use
std
:
:
{
cell
:
:
Cell
fmt
ptr
}
;
use
xpcom
:
:
{
interfaces
:
:
{
nsIBits
nsIBitsCallback
nsILoadGroup
nsIProgressEventSink
nsIRequestObserver
nsISupports
nsIThread
nsLoadFlags
}
xpcom
xpcom_method
RefPtr
XpCom
}
;
#
[
derive
(
Clone
Copy
PartialEq
)
]
enum
CancelAction
{
NotInProgress
InProgress
(
Option
<
nsresult
>
)
RequestEndedWhileInProgress
(
Option
<
nsresult
>
)
RequestEndPending
}
#
[
derive
(
xpcom
)
]
#
[
xpimplements
(
nsIBitsRequest
)
]
#
[
refcnt
=
"
nonatomic
"
]
pub
struct
InitBitsRequest
{
bits_id
:
Guid
bits_service
:
RefPtr
<
BitsService
>
download_pending
:
Cell
<
bool
>
download_status_nsresult
:
Cell
<
nsresult
>
download_status_error_type
:
Cell
<
Option
<
ErrorType
>
>
monitor_thread
:
Cell
<
Option
<
RefPtr
<
nsIThread
>
>
>
monitor_timeout_ms
:
u32
observer
:
RefPtr
<
nsIRequestObserver
>
started
:
Cell
<
bool
>
finished
:
Cell
<
bool
>
cancel_action
:
Cell
<
CancelAction
>
}
impl
fmt
:
:
Debug
for
BitsRequest
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
BitsRequest
{
{
id
:
{
}
}
}
"
self
.
bits_id
)
}
}
impl
BitsRequest
{
pub
fn
new
(
id
:
Guid
bits_service
:
RefPtr
<
BitsService
>
monitor_timeout_ms
:
u32
observer
:
RefPtr
<
nsIRequestObserver
>
context
:
Option
<
RefPtr
<
nsISupports
>
>
monitor_client
:
BitsMonitorClient
action
:
ServiceAction
)
-
>
Result
<
RefPtr
<
BitsRequest
>
BitsTaskError
>
{
let
action
:
Action
=
action
.
into
(
)
;
let
monitor_thread
=
create_thread
(
&
format
!
(
"
BitsMonitor
{
}
"
id
)
)
.
map_err
(
|
rv
|
{
BitsTaskError
:
:
from_nsresult
(
FailedToStartThread
action
MainThread
rv
)
}
)
?
;
bits_service
.
inc_request_count
(
)
;
let
request
:
RefPtr
<
BitsRequest
>
=
BitsRequest
:
:
allocate
(
InitBitsRequest
{
bits_id
:
id
.
clone
(
)
bits_service
download_pending
:
Cell
:
:
new
(
true
)
download_status_nsresult
:
Cell
:
:
new
(
NS_OK
)
download_status_error_type
:
Cell
:
:
new
(
None
)
monitor_thread
:
Cell
:
:
new
(
Some
(
monitor_thread
.
clone
(
)
)
)
monitor_timeout_ms
observer
started
:
Cell
:
:
new
(
false
)
finished
:
Cell
:
:
new
(
false
)
cancel_action
:
Cell
:
:
new
(
CancelAction
:
:
NotInProgress
)
}
)
;
let
monitor_runnable
=
MonitorRunnable
:
:
new
(
request
.
clone
(
)
id
monitor_timeout_ms
monitor_client
)
;
if
let
Err
(
rv
)
=
monitor_runnable
.
dispatch
(
monitor_thread
.
clone
(
)
)
{
request
.
shutdown_monitor_thread
(
)
;
return
Err
(
BitsTaskError
:
:
from_nsresult
(
FailedToDispatchRunnable
action
MainThread
rv
)
)
;
}
Ok
(
request
)
}
pub
fn
get_monitor_thread
(
&
self
)
-
>
Option
<
RefPtr
<
nsIThread
>
>
{
let
monitor_thread
=
self
.
monitor_thread
.
take
(
)
;
self
.
monitor_thread
.
set
(
monitor_thread
.
clone
(
)
)
;
monitor_thread
}
fn
has_monitor_thread
(
&
self
)
-
>
bool
{
let
maybe_monitor_thread
=
self
.
monitor_thread
.
take
(
)
;
let
transferred
=
maybe_monitor_thread
.
is_some
(
)
;
self
.
monitor_thread
.
set
(
maybe_monitor_thread
)
;
transferred
}
fn
request_has_transferred
(
&
self
)
-
>
bool
{
self
.
request_has_completed
(
)
|
|
!
self
.
has_monitor_thread
(
)
}
fn
request_has_completed
(
&
self
)
-
>
bool
{
self
.
finished
.
get
(
)
}
fn
shutdown_monitor_thread
(
&
self
)
{
if
let
Some
(
monitor_thread
)
=
self
.
monitor_thread
.
take
(
)
{
if
let
Err
(
rv
)
=
unsafe
{
monitor_thread
.
AsyncShutdown
(
)
}
.
to_result
(
)
{
warn
!
(
"
Failed
to
shut
down
monitor
thread
:
{
:
?
}
"
rv
)
;
warn
!
(
"
Releasing
reference
to
thread
that
failed
to
shut
down
!
"
)
;
}
}
}
pub
fn
on_start
(
&
self
)
{
if
self
.
started
.
get
(
)
{
return
;
}
self
.
started
.
set
(
true
)
;
if
let
Err
(
rv
)
=
unsafe
{
self
.
observer
.
OnStartRequest
(
self
.
coerce
(
)
)
}
.
to_result
(
)
{
info
!
(
"
Cancelling
download
because
OnStartRequest
rejected
with
:
{
:
?
}
"
rv
)
;
if
let
Err
(
rv
)
=
self
.
cancel
(
NS_ERROR_ABORT
None
)
{
warn
!
(
"
Failed
to
cancel
download
:
{
:
?
}
"
rv
)
;
}
}
}
pub
fn
on_progress
(
&
self
transferred_bytes
:
i64
total_bytes
:
i64
)
{
if
let
Some
(
progress_event_sink
)
=
self
.
observer
.
query_interface
:
:
<
nsIProgressEventSink
>
(
)
{
unsafe
{
progress_event_sink
.
OnProgress
(
self
.
coerce
(
)
transferred_bytes
total_bytes
)
;
}
}
}
pub
fn
on_stop
(
&
self
maybe_status
:
Option
<
(
nsresult
Option
<
ErrorType
>
)
>
)
{
if
!
self
.
has_monitor_thread
(
)
{
return
;
}
match
self
.
cancel_action
.
get
(
)
{
CancelAction
:
:
InProgress
(
saved_status
)
|
CancelAction
:
:
RequestEndedWhileInProgress
(
saved_status
)
=
>
{
if
let
Some
(
(
status
result
)
)
=
maybe_status
{
self
.
download_status_nsresult
.
set
(
status
)
;
self
.
download_status_error_type
.
set
(
result
)
;
}
info
!
(
"
Deferring
OnStopRequest
until
Cancel
Task
completes
"
)
;
self
.
cancel_action
.
set
(
CancelAction
:
:
RequestEndedWhileInProgress
(
saved_status
)
)
;
return
;
}
CancelAction
:
:
NotInProgress
=
>
{
if
let
Some
(
(
status
result
)
)
=
maybe_status
{
self
.
download_status_nsresult
.
set
(
status
)
;
self
.
download_status_error_type
.
set
(
result
)
;
}
}
CancelAction
:
:
RequestEndPending
=
>
{
}
}
self
.
download_pending
.
set
(
false
)
;
self
.
shutdown_monitor_thread
(
)
;
unsafe
{
self
.
observer
.
OnStopRequest
(
self
.
coerce
(
)
self
.
download_status_nsresult
.
get
(
)
)
;
}
}
pub
fn
on_finished
(
&
self
)
{
if
self
.
finished
.
get
(
)
{
return
;
}
self
.
finished
.
set
(
true
)
;
self
.
bits_service
.
dec_request_count
(
)
;
}
xpcom_method
!
(
maybe_get_bits_id
=
>
GetBitsId
(
)
-
>
nsACString
)
;
xpcom_method
!
(
maybe_get_bits_id
=
>
GetName
(
)
-
>
nsACString
)
;
fn
maybe_get_bits_id
(
&
self
)
-
>
Result
<
nsCString
nsresult
>
{
Ok
(
self
.
get_bits_id
(
)
)
}
pub
fn
get_bits_id
(
&
self
)
-
>
nsCString
{
nsCString
:
:
from
(
self
.
bits_id
.
to_string
(
)
)
}
xpcom_method
!
(
get_bits_transfer_error_nsIBitsRequest
=
>
GetTransferError
(
)
-
>
i32
)
;
#
[
allow
(
non_snake_case
)
]
fn
get_bits_transfer_error_nsIBitsRequest
(
&
self
)
-
>
Result
<
i32
nsresult
>
{
let
error_type
=
match
self
.
download_status_error_type
.
get
(
)
{
None
=
>
nsIBits
:
:
ERROR_TYPE_SUCCESS
as
i32
Some
(
error_type
)
=
>
error_type
.
bits_code
(
)
}
;
Ok
(
error_type
)
}
xpcom_method
!
(
is_pending
=
>
IsPending
(
)
-
>
bool
)
;
fn
is_pending
(
&
self
)
-
>
Result
<
bool
nsresult
>
{
Ok
(
self
.
download_pending
.
get
(
)
)
}
xpcom_method
!
(
get_status_nsIRequest
=
>
GetStatus
(
)
-
>
nsresult
)
;
#
[
allow
(
non_snake_case
)
]
fn
get_status_nsIRequest
(
&
self
)
-
>
Result
<
nsresult
nsresult
>
{
Ok
(
self
.
get_status
(
)
)
}
pub
fn
get_status
(
&
self
)
-
>
nsresult
{
self
.
download_status_nsresult
.
get
(
)
}
nsIBitsRequest_method
!
(
[
Action
:
:
SetMonitorInterval
]
change_monitor_interval
=
>
ChangeMonitorInterval
(
update_interval_ms
:
u32
)
)
;
fn
change_monitor_interval
(
&
self
update_interval_ms
:
u32
callback
:
&
nsIBitsCallback
)
-
>
Result
<
(
)
BitsTaskError
>
{
if
update_interval_ms
=
=
0
|
|
update_interval_ms
>
=
self
.
monitor_timeout_ms
{
return
Err
(
BitsTaskError
:
:
new
(
InvalidArgument
Action
:
:
SetMonitorInterval
Pretask
)
)
;
}
if
self
.
request_has_transferred
(
)
{
return
Err
(
BitsTaskError
:
:
new
(
TransferAlreadyComplete
Action
:
:
SetMonitorInterval
Pretask
)
)
;
}
let
task
:
Box
<
ChangeMonitorIntervalTask
>
=
Box
:
:
new
(
ChangeMonitorIntervalTask
:
:
new
(
RefPtr
:
:
new
(
self
)
self
.
bits_id
.
clone
(
)
update_interval_ms
RefPtr
:
:
new
(
callback
)
)
)
;
self
.
bits_service
.
dispatch_runnable_to_command_thread
(
task
"
BitsRequest
:
:
change_monitor_interval
"
Action
:
:
SetMonitorInterval
)
}
nsIBitsRequest_method
!
(
[
Action
:
:
Cancel
]
cancel_nsIBitsRequest
=
>
CancelAsync
(
status
:
nsresult
)
)
;
#
[
allow
(
non_snake_case
)
]
fn
cancel_nsIBitsRequest
(
&
self
status
:
nsresult
callback
:
&
nsIBitsCallback
)
-
>
Result
<
(
)
BitsTaskError
>
{
self
.
cancel
(
status
Some
(
RefPtr
:
:
new
(
callback
)
)
)
}
xpcom_method
!
(
cancel_nsIRequest
=
>
Cancel
(
status
:
nsresult
)
)
;
#
[
allow
(
non_snake_case
)
]
fn
cancel_nsIRequest
(
&
self
status
:
nsresult
)
-
>
Result
<
(
)
BitsTaskError
>
{
self
.
cancel
(
status
None
)
}
fn
cancel
(
&
self
status
:
nsresult
callback
:
Option
<
RefPtr
<
nsIBitsCallback
>
>
)
-
>
Result
<
(
)
BitsTaskError
>
{
if
status
.
clone
(
)
.
succeeded
(
)
{
return
Err
(
BitsTaskError
:
:
new
(
InvalidArgument
Action
:
:
Cancel
Pretask
)
)
;
}
if
self
.
request_has_completed
(
)
{
return
Err
(
BitsTaskError
:
:
new
(
TransferAlreadyComplete
Action
:
:
Cancel
Pretask
)
)
;
}
let
maybe_status
:
Option
<
nsresult
>
=
if
self
.
download_status_nsresult
.
get
(
)
.
failed
(
)
{
None
}
else
{
Some
(
status
)
}
;
if
self
.
cancel_action
.
get
(
)
!
=
CancelAction
:
:
NotInProgress
{
return
Err
(
BitsTaskError
:
:
new
(
OperationAlreadyInProgress
Action
:
:
Cancel
Pretask
)
)
;
}
self
.
cancel_action
.
set
(
CancelAction
:
:
InProgress
(
maybe_status
)
)
;
let
task
:
Box
<
CancelTask
>
=
Box
:
:
new
(
CancelTask
:
:
new
(
RefPtr
:
:
new
(
self
)
self
.
bits_id
.
clone
(
)
callback
)
)
;
self
.
bits_service
.
dispatch_runnable_to_command_thread
(
task
"
BitsRequest
:
:
cancel
"
Action
:
:
Cancel
)
}
pub
fn
finish_cancel_action
(
&
self
cancelled_successfully
:
bool
)
{
let
(
maybe_status
transfer_ended
)
=
match
self
.
cancel_action
.
get
(
)
{
CancelAction
:
:
InProgress
(
maybe_status
)
=
>
(
maybe_status
false
)
CancelAction
:
:
RequestEndedWhileInProgress
(
maybe_status
)
=
>
(
maybe_status
true
)
_
=
>
{
error
!
(
"
End
of
cancel
action
but
cancel
action
is
not
in
progress
!
"
)
;
return
;
}
}
;
info
!
(
"
Finishing
cancel
action
.
cancel
success
=
{
}
"
cancelled_successfully
)
;
if
cancelled_successfully
{
if
let
Some
(
status
)
=
maybe_status
{
self
.
download_status_nsresult
.
set
(
status
)
;
self
.
download_status_error_type
.
set
(
Some
(
BitsStateCancelled
)
)
;
}
}
let
next_stage
=
if
cancelled_successfully
&
&
!
transfer_ended
{
CancelAction
:
:
RequestEndPending
}
else
{
CancelAction
:
:
NotInProgress
}
;
self
.
cancel_action
.
set
(
next_stage
)
;
if
cancelled_successfully
{
self
.
on_finished
(
)
;
}
if
transfer_ended
{
info
!
(
"
Running
deferred
OnStopRequest
"
)
;
self
.
on_stop
(
None
)
;
}
}
nsIBitsRequest_method
!
(
[
Action
:
:
SetPriority
]
set_priority_high
=
>
SetPriorityHigh
(
)
)
;
fn
set_priority_high
(
&
self
callback
:
&
nsIBitsCallback
)
-
>
Result
<
(
)
BitsTaskError
>
{
self
.
set_priority
(
Priority
:
:
High
callback
)
}
nsIBitsRequest_method
!
(
[
Action
:
:
SetPriority
]
set_priority_low
=
>
SetPriorityLow
(
)
)
;
fn
set_priority_low
(
&
self
callback
:
&
nsIBitsCallback
)
-
>
Result
<
(
)
BitsTaskError
>
{
self
.
set_priority
(
Priority
:
:
Low
callback
)
}
fn
set_priority
(
&
self
priority
:
Priority
callback
:
&
nsIBitsCallback
)
-
>
Result
<
(
)
BitsTaskError
>
{
if
self
.
request_has_transferred
(
)
{
return
Err
(
BitsTaskError
:
:
new
(
TransferAlreadyComplete
Action
:
:
SetPriority
Pretask
)
)
;
}
let
task
:
Box
<
SetPriorityTask
>
=
Box
:
:
new
(
SetPriorityTask
:
:
new
(
RefPtr
:
:
new
(
self
)
self
.
bits_id
.
clone
(
)
priority
RefPtr
:
:
new
(
callback
)
)
)
;
self
.
bits_service
.
dispatch_runnable_to_command_thread
(
task
"
BitsRequest
:
:
set_priority
"
Action
:
:
SetPriority
)
}
nsIBitsRequest_method
!
(
[
Action
:
:
SetNoProgressTimeout
]
set_no_progress_timeout
=
>
SetNoProgressTimeout
(
timeout_secs
:
u32
)
)
;
fn
set_no_progress_timeout
(
&
self
timeout_secs
:
u32
callback
:
&
nsIBitsCallback
)
-
>
Result
<
(
)
BitsTaskError
>
{
if
self
.
request_has_transferred
(
)
{
return
Err
(
BitsTaskError
:
:
new
(
TransferAlreadyComplete
Action
:
:
SetNoProgressTimeout
Pretask
)
)
;
}
let
task
:
Box
<
SetNoProgressTimeoutTask
>
=
Box
:
:
new
(
SetNoProgressTimeoutTask
:
:
new
(
RefPtr
:
:
new
(
self
)
self
.
bits_id
.
clone
(
)
timeout_secs
RefPtr
:
:
new
(
callback
)
)
)
;
self
.
bits_service
.
dispatch_runnable_to_command_thread
(
task
"
BitsRequest
:
:
set_no_progress_timeout
"
Action
:
:
SetNoProgressTimeout
)
}
nsIBitsRequest_method
!
(
[
Action
:
:
Complete
]
complete
=
>
Complete
(
)
)
;
fn
complete
(
&
self
callback
:
&
nsIBitsCallback
)
-
>
Result
<
(
)
BitsTaskError
>
{
if
self
.
request_has_completed
(
)
{
return
Err
(
BitsTaskError
:
:
new
(
TransferAlreadyComplete
Action
:
:
Complete
Pretask
)
)
;
}
let
task
:
Box
<
CompleteTask
>
=
Box
:
:
new
(
CompleteTask
:
:
new
(
RefPtr
:
:
new
(
self
)
self
.
bits_id
.
clone
(
)
RefPtr
:
:
new
(
callback
)
)
)
;
self
.
bits_service
.
dispatch_runnable_to_command_thread
(
task
"
BitsRequest
:
:
complete
"
Action
:
:
Complete
)
}
nsIBitsRequest_method
!
(
[
Action
:
:
Suspend
]
suspend_nsIBitsRequest
=
>
SuspendAsync
(
)
)
;
#
[
allow
(
non_snake_case
)
]
fn
suspend_nsIBitsRequest
(
&
self
callback
:
&
nsIBitsCallback
)
-
>
Result
<
(
)
BitsTaskError
>
{
self
.
suspend
(
Some
(
RefPtr
:
:
new
(
callback
)
)
)
}
xpcom_method
!
(
suspend_nsIRequest
=
>
Suspend
(
)
)
;
#
[
allow
(
non_snake_case
)
]
fn
suspend_nsIRequest
(
&
self
)
-
>
Result
<
(
)
BitsTaskError
>
{
self
.
suspend
(
None
)
}
fn
suspend
(
&
self
callback
:
Option
<
RefPtr
<
nsIBitsCallback
>
>
)
-
>
Result
<
(
)
BitsTaskError
>
{
if
self
.
request_has_transferred
(
)
{
return
Err
(
BitsTaskError
:
:
new
(
TransferAlreadyComplete
Action
:
:
Suspend
Pretask
)
)
;
}
let
task
:
Box
<
SuspendTask
>
=
Box
:
:
new
(
SuspendTask
:
:
new
(
RefPtr
:
:
new
(
self
)
self
.
bits_id
.
clone
(
)
callback
)
)
;
self
.
bits_service
.
dispatch_runnable_to_command_thread
(
task
"
BitsRequest
:
:
suspend
"
Action
:
:
Suspend
)
}
nsIBitsRequest_method
!
(
[
Action
:
:
Resume
]
resume_nsIBitsRequest
=
>
ResumeAsync
(
)
)
;
#
[
allow
(
non_snake_case
)
]
fn
resume_nsIBitsRequest
(
&
self
callback
:
&
nsIBitsCallback
)
-
>
Result
<
(
)
BitsTaskError
>
{
self
.
resume
(
Some
(
RefPtr
:
:
new
(
callback
)
)
)
}
xpcom_method
!
(
resume_nsIRequest
=
>
Resume
(
)
)
;
#
[
allow
(
non_snake_case
)
]
fn
resume_nsIRequest
(
&
self
)
-
>
Result
<
(
)
BitsTaskError
>
{
self
.
resume
(
None
)
}
fn
resume
(
&
self
callback
:
Option
<
RefPtr
<
nsIBitsCallback
>
>
)
-
>
Result
<
(
)
BitsTaskError
>
{
if
self
.
request_has_transferred
(
)
{
return
Err
(
BitsTaskError
:
:
new
(
TransferAlreadyComplete
Action
:
:
Resume
Pretask
)
)
;
}
let
task
:
Box
<
ResumeTask
>
=
Box
:
:
new
(
ResumeTask
:
:
new
(
RefPtr
:
:
new
(
self
)
self
.
bits_id
.
clone
(
)
callback
)
)
;
self
.
bits_service
.
dispatch_runnable_to_command_thread
(
task
"
BitsRequest
:
:
resume
"
Action
:
:
Resume
)
}
xpcom_method
!
(
get_load_group
=
>
GetLoadGroup
(
)
-
>
*
const
nsILoadGroup
)
;
fn
get_load_group
(
&
self
)
-
>
Result
<
RefPtr
<
nsILoadGroup
>
nsresult
>
{
Err
(
NS_ERROR_NOT_IMPLEMENTED
)
}
xpcom_method
!
(
set_load_group
=
>
SetLoadGroup
(
_load_group
:
*
const
nsILoadGroup
)
)
;
fn
set_load_group
(
&
self
_load_group
:
&
nsILoadGroup
)
-
>
Result
<
(
)
nsresult
>
{
Err
(
NS_ERROR_NOT_IMPLEMENTED
)
}
xpcom_method
!
(
get_load_flags
=
>
GetLoadFlags
(
)
-
>
nsLoadFlags
)
;
fn
get_load_flags
(
&
self
)
-
>
Result
<
nsLoadFlags
nsresult
>
{
Err
(
NS_ERROR_NOT_IMPLEMENTED
)
}
xpcom_method
!
(
set_load_flags
=
>
SetLoadFlags
(
_load_flags
:
nsLoadFlags
)
)
;
fn
set_load_flags
(
&
self
_load_flags
:
nsLoadFlags
)
-
>
Result
<
(
)
nsresult
>
{
Err
(
NS_ERROR_NOT_IMPLEMENTED
)
}
xpcom_method
!
(
get_trr_mode
=
>
GetTRRMode
(
)
-
>
u8
)
;
fn
get_trr_mode
(
&
self
)
-
>
Result
<
u8
nsresult
>
{
Err
(
NS_ERROR_NOT_IMPLEMENTED
)
}
xpcom_method
!
(
set_trr_mode
=
>
SetTRRMode
(
_trr_mode
:
u8
)
)
;
fn
set_trr_mode
(
&
self
_trr_mode
:
u8
)
-
>
Result
<
(
)
nsresult
>
{
Err
(
NS_ERROR_NOT_IMPLEMENTED
)
}
}
impl
Drop
for
BitsRequest
{
fn
drop
(
&
mut
self
)
{
self
.
shutdown_monitor_thread
(
)
;
self
.
on_finished
(
)
;
}
}
