#
[
macro_export
]
macro_rules
!
nsIBits_method
{
(
ensure_param
[
optional
]
name
:
ident
action
:
expr
callback
:
ident
)
=
>
{
let
name
=
match
Ensure
:
:
ensure
(
name
)
{
Ok
(
val
)
=
>
Some
(
val
)
Err
(
_
)
=
>
None
}
;
}
;
(
ensure_param
name
:
ident
action
:
expr
callback
:
ident
)
=
>
{
let
name
=
match
Ensure
:
:
ensure
(
name
)
{
Ok
(
val
)
=
>
val
Err
(
_
)
=
>
{
dispatch_pretask_interface_error
(
BitsTaskError
:
:
new
(
NullArgument
action
.
into
(
)
Pretask
)
callback
)
;
return
NS_OK
;
}
}
;
}
;
(
[
action
:
expr
]
rust_name
:
ident
=
>
xpcom_name
:
ident
(
(
(
[
param_required
:
ident
]
)
*
param_name
:
ident
:
param_type
:
ty
(
)
*
)
*
)
)
=
>
{
#
[
allow
(
non_snake_case
)
]
unsafe
fn
xpcom_name
(
&
self
(
param_name
:
param_type
)
*
callback
:
*
const
nsIBitsNewRequestCallback
)
-
>
nsresult
{
use
xpcom
:
:
Ensure
;
use
nserror
:
:
NS_OK
;
/
/
When
no
params
are
passed
the
imports
below
will
not
be
used
so
silence
the
/
/
warning
#
[
allow
(
unused_imports
)
]
use
bits_interface
:
:
{
dispatch_callback
:
:
dispatch_pretask_interface_error
error
:
:
{
BitsTaskError
ErrorStage
:
:
Pretask
ErrorType
:
:
NullArgument
}
}
;
let
callback
:
&
nsIBitsNewRequestCallback
=
match
Ensure
:
:
ensure
(
callback
)
{
Ok
(
val
)
=
>
val
Err
(
result
)
=
>
return
result
}
;
(
nsIBits_method
!
(
ensure_param
(
[
param_required
]
)
*
param_name
action
callback
)
;
)
*
if
let
Err
(
error
)
=
self
.
rust_name
(
(
param_name
)
*
callback
)
{
dispatch_pretask_interface_error
(
error
callback
)
;
}
NS_OK
}
}
;
}
#
[
macro_export
]
macro_rules
!
nsIBitsRequest_method
{
(
ensure_param
[
optional
]
name
:
ident
action
:
expr
callback
:
ident
)
=
>
{
let
name
=
match
Ensure
:
:
ensure
(
name
)
{
Ok
(
val
)
=
>
Some
(
val
)
Err
(
_
)
=
>
None
}
;
}
;
(
ensure_param
name
:
ident
action
:
expr
callback
:
ident
)
=
>
{
let
name
=
match
Ensure
:
:
ensure
(
name
)
{
Ok
(
val
)
=
>
val
Err
(
_
)
=
>
{
dispatch_pretask_request_error
(
BitsTaskError
:
:
new
(
NullArgument
action
.
into
(
)
Pretask
)
callback
)
;
return
NS_OK
;
}
}
;
}
;
(
[
action
:
expr
]
rust_name
:
ident
=
>
xpcom_name
:
ident
(
(
(
[
param_required
:
ident
]
)
*
param_name
:
ident
:
param_type
:
ty
(
)
*
)
*
)
)
=
>
{
#
[
allow
(
non_snake_case
)
]
unsafe
fn
xpcom_name
(
&
self
(
param_name
:
param_type
)
*
callback
:
*
const
nsIBitsCallback
)
-
>
nsresult
{
use
xpcom
:
:
Ensure
;
use
nserror
:
:
NS_OK
;
/
/
When
no
params
are
passed
the
imports
below
will
not
be
used
so
silence
the
/
/
warning
#
[
allow
(
unused_imports
)
]
use
bits_interface
:
:
{
dispatch_callback
:
:
dispatch_pretask_request_error
error
:
:
{
BitsTaskError
ErrorStage
:
:
Pretask
ErrorType
:
:
NullArgument
}
}
;
let
callback
:
&
nsIBitsCallback
=
match
Ensure
:
:
ensure
(
callback
)
{
Ok
(
val
)
=
>
val
Err
(
result
)
=
>
return
result
}
;
(
nsIBitsRequest_method
!
(
ensure_param
(
[
param_required
]
)
*
param_name
action
callback
)
;
)
*
if
let
Err
(
error
)
=
self
.
rust_name
(
(
param_name
)
*
callback
)
{
dispatch_pretask_request_error
(
error
callback
)
;
}
NS_OK
}
}
;
}
