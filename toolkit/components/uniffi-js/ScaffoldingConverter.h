#
ifndef
mozilla_ScaffoldingConverter_h
#
define
mozilla_ScaffoldingConverter_h
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
dom
/
OwnedRustBuffer
.
h
"
#
include
"
mozilla
/
dom
/
PrimitiveConversions
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIBinding
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIPointer
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIPointerType
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIRust
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIScaffolding
.
h
"
namespace
mozilla
:
:
uniffi
{
template
<
typename
T
>
class
ScaffoldingConverter
{
public
:
using
RustType
=
T
;
using
IntermediateType
=
T
;
static
mozilla
:
:
Result
<
IntermediateType
nsCString
>
FromJs
(
const
dom
:
:
UniFFIScaffoldingValue
&
aValue
)
{
if
(
!
aValue
.
IsDouble
(
)
)
{
return
Err
(
"
Bad
argument
type
"
_ns
)
;
}
double
value
=
aValue
.
GetAsDouble
(
)
;
if
(
std
:
:
isnan
(
value
)
)
{
return
Err
(
"
NaN
not
allowed
"
_ns
)
;
}
if
constexpr
(
std
:
:
is_integral
<
RustType
>
:
:
value
)
{
if
(
value
<
dom
:
:
PrimitiveConversionTraits_Limits
<
RustType
>
:
:
min
(
)
|
|
value
>
dom
:
:
PrimitiveConversionTraits_Limits
<
RustType
>
:
:
max
(
)
)
{
return
Err
(
"
Out
of
bounds
"
_ns
)
;
}
}
RustType
rv
=
static_cast
<
RustType
>
(
value
)
;
if
constexpr
(
std
:
:
is_integral
<
RustType
>
:
:
value
)
{
if
(
rv
!
=
value
)
{
return
Err
(
"
Not
an
integer
"
_ns
)
;
}
}
return
rv
;
}
static
RustType
IntoRust
(
IntermediateType
aValue
)
{
return
aValue
;
}
static
mozilla
:
:
Result
<
IntermediateType
nsCString
>
FromRust
(
RustType
aValue
)
{
if
constexpr
(
std
:
:
is_same
<
RustType
int64_t
>
:
:
value
|
|
std
:
:
is_same
<
RustType
uint64_t
>
:
:
value
)
{
if
(
aValue
<
dom
:
:
PrimitiveConversionTraits_Limits
<
RustType
>
:
:
min
(
)
|
|
aValue
>
dom
:
:
PrimitiveConversionTraits_Limits
<
RustType
>
:
:
max
(
)
)
{
return
Err
(
"
Out
of
bounds
"
_ns
)
;
}
}
if
constexpr
(
std
:
:
is_floating_point
<
RustType
>
:
:
value
)
{
if
(
std
:
:
isnan
(
aValue
)
)
{
return
Err
(
"
NaN
not
allowed
"
_ns
)
;
}
}
return
aValue
;
}
static
void
IntoJs
(
JSContext
*
aContext
IntermediateType
&
&
aValue
dom
:
:
UniFFIScaffoldingValue
&
aDest
)
{
aDest
.
SetAsDouble
(
)
=
aValue
;
}
}
;
template
<
>
class
ScaffoldingConverter
<
RustBuffer
>
{
public
:
using
RustType
=
RustBuffer
;
using
IntermediateType
=
OwnedRustBuffer
;
static
mozilla
:
:
Result
<
OwnedRustBuffer
nsCString
>
FromJs
(
const
dom
:
:
UniFFIScaffoldingValue
&
aValue
)
{
if
(
!
aValue
.
IsArrayBuffer
(
)
)
{
return
Err
(
"
Bad
argument
type
"
_ns
)
;
}
return
OwnedRustBuffer
:
:
FromArrayBuffer
(
aValue
.
GetAsArrayBuffer
(
)
)
;
}
static
RustBuffer
IntoRust
(
OwnedRustBuffer
&
&
aValue
)
{
return
aValue
.
IntoRustBuffer
(
)
;
}
static
mozilla
:
:
Result
<
OwnedRustBuffer
nsCString
>
FromRust
(
RustBuffer
aValue
)
{
return
OwnedRustBuffer
(
aValue
)
;
}
static
void
IntoJs
(
JSContext
*
aContext
OwnedRustBuffer
&
&
aValue
dom
:
:
UniFFIScaffoldingValue
&
aDest
)
{
aDest
.
SetAsArrayBuffer
(
)
.
Init
(
aValue
.
IntoArrayBuffer
(
aContext
)
)
;
}
}
;
template
<
const
UniFFIPointerType
*
PointerType
>
class
ScaffoldingObjectConverter
{
public
:
using
RustType
=
void
*
;
using
IntermediateType
=
void
*
;
static
mozilla
:
:
Result
<
void
*
nsCString
>
FromJs
(
const
dom
:
:
UniFFIScaffoldingValue
&
aValue
)
{
if
(
!
aValue
.
IsUniFFIPointer
(
)
)
{
return
Err
(
"
Bad
argument
type
"
_ns
)
;
}
dom
:
:
UniFFIPointer
&
value
=
aValue
.
GetAsUniFFIPointer
(
)
;
if
(
!
value
.
IsSamePtrType
(
PointerType
)
)
{
return
Err
(
"
Bad
pointer
type
"
_ns
)
;
}
return
value
.
ClonePtr
(
)
;
}
static
void
*
IntoRust
(
void
*
aValue
)
{
return
aValue
;
}
static
mozilla
:
:
Result
<
void
*
nsCString
>
FromRust
(
void
*
aValue
)
{
return
aValue
;
}
static
void
IntoJs
(
JSContext
*
aContext
void
*
aValue
dom
:
:
UniFFIScaffoldingValue
&
aDest
)
{
aDest
.
SetAsUniFFIPointer
(
)
=
dom
:
:
UniFFIPointer
:
:
Create
(
aValue
PointerType
)
;
}
}
;
template
<
>
class
ScaffoldingConverter
<
void
>
{
public
:
using
RustType
=
void
;
}
;
}
#
endif
