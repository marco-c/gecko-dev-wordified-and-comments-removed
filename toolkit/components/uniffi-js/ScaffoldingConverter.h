#
ifndef
mozilla_ScaffoldingConverter_h
#
define
mozilla_ScaffoldingConverter_h
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
dom
/
OwnedRustBuffer
.
h
"
#
include
"
mozilla
/
dom
/
PrimitiveConversions
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIBinding
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIPointer
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIPointerType
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIRust
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIScaffolding
.
h
"
namespace
mozilla
:
:
uniffi
{
template
<
typename
T
>
class
ScaffoldingConverter
{
public
:
using
RustType
=
T
;
using
IntermediateType
=
T
;
static
void
FromJs
(
const
dom
:
:
UniFFIScaffoldingValue
&
aValue
IntermediateType
*
aResult
ErrorResult
&
aError
)
{
if
(
!
aValue
.
IsDouble
(
)
)
{
aError
.
ThrowTypeError
(
"
Bad
argument
type
"
_ns
)
;
return
;
}
double
value
=
aValue
.
GetAsDouble
(
)
;
if
(
std
:
:
isnan
(
value
)
)
{
aError
.
ThrowUnknownError
(
"
NaN
not
allowed
"
_ns
)
;
return
;
}
if
constexpr
(
std
:
:
is_integral
<
RustType
>
:
:
value
)
{
if
(
value
<
dom
:
:
PrimitiveConversionTraits_Limits
<
RustType
>
:
:
min
(
)
|
|
value
>
dom
:
:
PrimitiveConversionTraits_Limits
<
RustType
>
:
:
max
(
)
)
{
aError
.
ThrowRangeError
(
"
UniFFI
return
value
cannot
be
precisely
represented
in
JS
"
_ns
)
;
return
;
}
}
IntermediateType
rv
=
static_cast
<
IntermediateType
>
(
value
)
;
if
constexpr
(
std
:
:
is_integral
<
IntermediateType
>
:
:
value
)
{
if
(
rv
!
=
value
)
{
aError
.
ThrowTypeError
(
"
Not
an
integer
"
_ns
)
;
return
;
}
}
*
aResult
=
rv
;
}
static
RustType
IntoRust
(
IntermediateType
aValue
)
{
return
aValue
;
}
static
IntermediateType
FromRust
(
RustType
aValue
)
{
return
aValue
;
}
static
void
IntoJs
(
JSContext
*
aContext
IntermediateType
&
&
aValue
dom
:
:
Optional
<
dom
:
:
UniFFIScaffoldingValue
>
&
aDest
ErrorResult
&
aError
)
{
if
constexpr
(
std
:
:
is_same
<
RustType
int64_t
>
:
:
value
|
|
std
:
:
is_same
<
RustType
uint64_t
>
:
:
value
)
{
if
(
aValue
<
dom
:
:
PrimitiveConversionTraits_Limits
<
RustType
>
:
:
min
(
)
|
|
aValue
>
dom
:
:
PrimitiveConversionTraits_Limits
<
RustType
>
:
:
max
(
)
)
{
aError
.
ThrowRangeError
(
"
UniFFI
return
value
cannot
be
precisely
represented
in
JS
"
_ns
)
;
return
;
}
}
if
constexpr
(
std
:
:
is_floating_point
<
RustType
>
:
:
value
)
{
if
(
std
:
:
isnan
(
aValue
)
)
{
aError
.
ThrowUnknownError
(
"
NaN
not
allowed
"
_ns
)
;
return
;
}
}
aDest
.
Construct
(
)
.
SetAsDouble
(
)
=
aValue
;
}
}
;
template
<
>
class
ScaffoldingConverter
<
RustBuffer
>
{
public
:
using
RustType
=
RustBuffer
;
using
IntermediateType
=
OwnedRustBuffer
;
static
void
FromJs
(
const
dom
:
:
UniFFIScaffoldingValue
&
aValue
OwnedRustBuffer
*
aResult
ErrorResult
&
aError
)
{
if
(
!
aValue
.
IsArrayBuffer
(
)
)
{
aError
.
ThrowTypeError
(
"
Expected
ArrayBuffer
argument
"
_ns
)
;
return
;
}
*
aResult
=
OwnedRustBuffer
:
:
FromArrayBuffer
(
aValue
.
GetAsArrayBuffer
(
)
)
;
}
static
RustBuffer
IntoRust
(
OwnedRustBuffer
&
&
aValue
)
{
return
aValue
.
IntoRustBuffer
(
)
;
}
static
OwnedRustBuffer
FromRust
(
RustBuffer
aValue
)
{
return
OwnedRustBuffer
(
aValue
)
;
}
static
void
IntoJs
(
JSContext
*
aContext
OwnedRustBuffer
&
&
aValue
dom
:
:
Optional
<
dom
:
:
UniFFIScaffoldingValue
>
&
aDest
ErrorResult
&
aError
)
{
aDest
.
Construct
(
)
.
SetAsArrayBuffer
(
)
.
Init
(
aValue
.
IntoArrayBuffer
(
aContext
aError
)
)
;
}
}
;
template
<
const
UniFFIPointerType
*
PointerType
>
class
ScaffoldingObjectConverter
{
public
:
using
RustType
=
void
*
;
using
IntermediateType
=
void
*
;
static
void
FromJs
(
const
dom
:
:
UniFFIScaffoldingValue
&
aValue
void
*
*
aResult
ErrorResult
&
aError
)
{
if
(
!
aValue
.
IsUniFFIPointer
(
)
)
{
aError
.
ThrowTypeError
(
"
Expected
UniFFI
pointer
argument
"
_ns
)
;
return
;
}
dom
:
:
UniFFIPointer
&
value
=
aValue
.
GetAsUniFFIPointer
(
)
;
if
(
!
value
.
IsSamePtrType
(
PointerType
)
)
{
aError
.
ThrowTypeError
(
"
Incorrect
UniFFI
pointer
type
"
_ns
)
;
return
;
}
*
aResult
=
value
.
ClonePtr
(
)
;
}
static
void
*
IntoRust
(
void
*
aValue
)
{
return
aValue
;
}
static
void
*
FromRust
(
void
*
aValue
)
{
return
aValue
;
}
static
void
IntoJs
(
JSContext
*
aContext
void
*
aValue
dom
:
:
Optional
<
dom
:
:
UniFFIScaffoldingValue
>
&
aDest
ErrorResult
&
aError
)
{
aDest
.
Construct
(
)
.
SetAsUniFFIPointer
(
)
=
dom
:
:
UniFFIPointer
:
:
Create
(
aValue
PointerType
)
;
}
}
;
template
<
>
class
ScaffoldingConverter
<
void
>
{
public
:
using
RustType
=
void
;
}
;
}
#
endif
