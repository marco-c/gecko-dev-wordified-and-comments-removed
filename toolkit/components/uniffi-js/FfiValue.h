#
ifndef
mozilla_UniFFIFfiConverter_h
#
define
mozilla_UniFFIFfiConverter_h
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
dom
/
PrimitiveConversions
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIBinding
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIPointer
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIScaffolding
.
h
"
#
include
"
mozilla
/
uniffi
/
OwnedRustBuffer
.
h
"
#
include
"
mozilla
/
uniffi
/
PointerType
.
h
"
#
include
"
mozilla
/
uniffi
/
Rust
.
h
"
namespace
mozilla
:
:
uniffi
{
template
<
typename
T
>
class
FfiValueInt
{
private
:
T
mValue
=
0
;
public
:
FfiValueInt
(
)
=
default
;
explicit
FfiValueInt
(
T
aValue
)
:
mValue
(
aValue
)
{
}
void
Lower
(
const
dom
:
:
OwningUniFFIScaffoldingValue
&
aValue
ErrorResult
&
aError
)
{
if
(
!
aValue
.
IsDouble
(
)
)
{
aError
.
ThrowTypeError
(
"
Bad
argument
type
"
_ns
)
;
return
;
}
double
floatValue
=
aValue
.
GetAsDouble
(
)
;
if
(
floatValue
<
dom
:
:
PrimitiveConversionTraits_Limits
<
T
>
:
:
min
(
)
|
|
floatValue
>
dom
:
:
PrimitiveConversionTraits_Limits
<
T
>
:
:
max
(
)
)
{
aError
.
ThrowRangeError
(
"
Integer
value
is
out
of
range
"
_ns
)
;
return
;
}
T
intValue
=
static_cast
<
T
>
(
floatValue
)
;
if
(
intValue
!
=
floatValue
)
{
aError
.
ThrowTypeError
(
"
Not
an
integer
"
_ns
)
;
return
;
}
mValue
=
intValue
;
}
void
Lift
(
JSContext
*
aContext
dom
:
:
OwningUniFFIScaffoldingValue
*
aDest
ErrorResult
&
aError
)
{
if
(
mValue
<
dom
:
:
PrimitiveConversionTraits_Limits
<
T
>
:
:
min
(
)
|
|
mValue
>
dom
:
:
PrimitiveConversionTraits_Limits
<
T
>
:
:
max
(
)
)
{
aError
.
ThrowRangeError
(
"
64
-
bit
value
cannot
be
precisely
represented
in
JS
"
_ns
)
;
return
;
}
aDest
-
>
SetAsDouble
(
)
=
mValue
;
}
T
IntoRust
(
)
{
return
mValue
;
}
static
FfiValueInt
FromRust
(
T
aValue
)
{
return
FfiValueInt
(
aValue
)
;
}
;
}
;
template
<
typename
T
>
class
FfiValueFloat
{
private
:
T
mValue
=
0
.
0
;
public
:
FfiValueFloat
(
)
=
default
;
explicit
FfiValueFloat
(
T
aValue
)
:
mValue
(
aValue
)
{
}
void
Lower
(
const
dom
:
:
OwningUniFFIScaffoldingValue
&
aValue
ErrorResult
&
aError
)
{
if
(
!
aValue
.
IsDouble
(
)
)
{
aError
.
ThrowTypeError
(
"
Bad
argument
type
"
_ns
)
;
return
;
}
mValue
=
aValue
.
GetAsDouble
(
)
;
}
void
Lift
(
JSContext
*
aContext
dom
:
:
OwningUniFFIScaffoldingValue
*
aDest
ErrorResult
&
aError
)
{
aDest
-
>
SetAsDouble
(
)
=
mValue
;
}
T
IntoRust
(
)
{
return
mValue
;
}
static
FfiValueFloat
FromRust
(
T
aValue
)
{
return
FfiValueFloat
(
aValue
)
;
}
}
;
class
FfiValueRustBuffer
{
private
:
OwnedRustBuffer
mValue
;
public
:
FfiValueRustBuffer
(
)
=
default
;
explicit
FfiValueRustBuffer
(
RustBuffer
aValue
)
:
mValue
(
OwnedRustBuffer
(
aValue
)
)
{
}
explicit
FfiValueRustBuffer
(
OwnedRustBuffer
aValue
)
:
mValue
(
std
:
:
move
(
aValue
)
)
{
}
void
Lower
(
const
dom
:
:
OwningUniFFIScaffoldingValue
&
aValue
ErrorResult
&
aError
)
{
if
(
!
aValue
.
IsArrayBuffer
(
)
)
{
aError
.
ThrowTypeError
(
"
Expected
ArrayBuffer
argument
"
_ns
)
;
return
;
}
mValue
=
OwnedRustBuffer
:
:
FromArrayBuffer
(
aValue
.
GetAsArrayBuffer
(
)
)
;
}
void
Lift
(
JSContext
*
aContext
dom
:
:
OwningUniFFIScaffoldingValue
*
aDest
ErrorResult
&
aError
)
{
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aContext
)
;
mValue
.
IntoArrayBuffer
(
aContext
&
obj
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
aDest
-
>
SetAsArrayBuffer
(
)
.
Init
(
obj
)
;
}
RustBuffer
IntoRust
(
)
{
return
mValue
.
IntoRustBuffer
(
)
;
}
static
FfiValueRustBuffer
FromRust
(
RustBuffer
aValue
)
{
return
FfiValueRustBuffer
(
OwnedRustBuffer
(
aValue
)
)
;
}
bool
IsSet
(
)
{
return
mValue
.
IsValid
(
)
;
}
}
;
template
<
const
UniFFIPointerType
*
PointerType
>
class
FfiValueObjectHandle
{
private
:
void
*
mValue
=
nullptr
;
public
:
FfiValueObjectHandle
(
)
=
default
;
explicit
FfiValueObjectHandle
(
void
*
aValue
)
:
mValue
(
aValue
)
{
}
FfiValueObjectHandle
(
const
FfiValueObjectHandle
&
)
=
delete
;
FfiValueObjectHandle
&
operator
=
(
const
FfiValueObjectHandle
&
)
=
delete
;
FfiValueObjectHandle
&
operator
=
(
FfiValueObjectHandle
&
&
aOther
)
{
if
(
mValue
&
&
mValue
!
=
aOther
.
mValue
)
{
FreeHandle
(
)
;
}
mValue
=
aOther
.
mValue
;
aOther
.
mValue
=
nullptr
;
return
*
this
;
}
void
Lower
(
const
dom
:
:
OwningUniFFIScaffoldingValue
&
aValue
ErrorResult
&
aError
)
{
if
(
!
aValue
.
IsUniFFIPointer
(
)
)
{
aError
.
ThrowTypeError
(
"
Expected
UniFFI
pointer
argument
"
_ns
)
;
return
;
}
dom
:
:
UniFFIPointer
&
value
=
aValue
.
GetAsUniFFIPointer
(
)
;
if
(
!
value
.
IsSamePtrType
(
PointerType
)
)
{
aError
.
ThrowTypeError
(
"
Incorrect
UniFFI
pointer
type
"
_ns
)
;
return
;
}
FreeHandle
(
)
;
mValue
=
value
.
ClonePtr
(
)
;
}
void
Lift
(
JSContext
*
aContext
dom
:
:
OwningUniFFIScaffoldingValue
*
aDest
ErrorResult
&
aError
)
{
aDest
-
>
SetAsUniFFIPointer
(
)
=
dom
:
:
UniFFIPointer
:
:
Create
(
mValue
PointerType
)
;
mValue
=
nullptr
;
}
void
*
IntoRust
(
)
{
auto
temp
=
mValue
;
mValue
=
nullptr
;
return
temp
;
}
static
FfiValueObjectHandle
FromRust
(
void
*
aValue
)
{
return
FfiValueObjectHandle
(
aValue
)
;
}
void
FreeHandle
(
)
{
if
(
mValue
)
{
RustCallStatus
callStatus
{
}
;
(
PointerType
-
>
destructor
)
(
mValue
&
callStatus
)
;
}
}
~
FfiValueObjectHandle
(
)
{
FreeHandle
(
)
;
}
}
;
}
#
endif
