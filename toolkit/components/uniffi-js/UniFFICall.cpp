#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
dom
/
UniFFICall
.
h
"
namespace
mozilla
:
:
uniffi
{
using
dom
:
:
GlobalObject
;
using
dom
:
:
RootedDictionary
;
using
dom
:
:
Sequence
;
using
dom
:
:
UniFFIScaffoldingCallResult
;
using
dom
:
:
UniFFIScaffoldingValue
;
void
UniffiSyncCallHandler
:
:
CallSync
(
UniquePtr
<
UniffiSyncCallHandler
>
aHandler
const
GlobalObject
&
aGlobal
const
Sequence
<
UniFFIScaffoldingValue
>
&
aArgs
RootedDictionary
<
UniFFIScaffoldingCallResult
>
&
aReturnValue
ErrorResult
&
aError
)
{
aHandler
-
>
PrepareRustArgs
(
aArgs
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
aHandler
-
>
MakeRustCall
(
)
;
aHandler
-
>
ExtractCallResult
(
aGlobal
.
Context
(
)
aReturnValue
aError
)
;
}
already_AddRefed
<
dom
:
:
Promise
>
UniffiSyncCallHandler
:
:
CallAsyncWrapper
(
UniquePtr
<
UniffiSyncCallHandler
>
aHandler
const
dom
:
:
GlobalObject
&
aGlobal
const
dom
:
:
Sequence
<
dom
:
:
UniFFIScaffoldingValue
>
&
aArgs
ErrorResult
&
aError
)
{
aHandler
-
>
PrepareRustArgs
(
aArgs
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIGlobalObject
>
xpcomGlobal
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
dom
:
:
Promise
>
returnPromise
=
dom
:
:
Promise
:
:
Create
(
xpcomGlobal
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
taskPromise
=
new
MozPromise
<
UniquePtr
<
UniffiSyncCallHandler
>
nsresult
true
>
:
:
Private
(
__func__
)
;
nsresult
dispatchResult
=
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
__func__
[
handler
=
std
:
:
move
(
aHandler
)
taskPromise
]
(
)
mutable
{
handler
-
>
MakeRustCall
(
)
;
taskPromise
-
>
Resolve
(
std
:
:
move
(
handler
)
__func__
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
if
(
NS_FAILED
(
dispatchResult
)
)
{
taskPromise
-
>
Reject
(
dispatchResult
__func__
)
;
}
taskPromise
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
xpcomGlobal
returnPromise
]
(
typename
MozPromise
<
UniquePtr
<
UniffiSyncCallHandler
>
nsresult
true
>
:
:
ResolveOrRejectValue
&
&
aResult
)
{
if
(
!
aResult
.
IsResolve
(
)
)
{
returnPromise
-
>
MaybeRejectWithUnknownError
(
__func__
)
;
return
;
}
auto
handler
=
std
:
:
move
(
aResult
.
ResolveValue
(
)
)
;
dom
:
:
AutoEntryScript
aes
(
xpcomGlobal
__func__
)
;
dom
:
:
RootedDictionary
<
dom
:
:
UniFFIScaffoldingCallResult
>
returnValue
(
aes
.
cx
(
)
)
;
ErrorResult
error
;
handler
-
>
ExtractCallResult
(
aes
.
cx
(
)
returnValue
error
)
;
error
.
WouldReportJSException
(
)
;
if
(
error
.
Failed
(
)
)
{
returnPromise
-
>
MaybeReject
(
std
:
:
move
(
error
)
)
;
}
else
{
returnPromise
-
>
MaybeResolve
(
returnValue
)
;
}
}
)
;
return
returnPromise
.
forget
(
)
;
}
void
UniffiSyncCallHandler
:
:
ExtractCallResult
(
JSContext
*
aCx
dom
:
:
RootedDictionary
<
dom
:
:
UniFFIScaffoldingCallResult
>
&
aDest
ErrorResult
&
aError
)
{
switch
(
mUniffiCallStatusCode
)
{
case
RUST_CALL_SUCCESS
:
{
aDest
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Success
;
ExtractSuccessfulCallResult
(
aCx
aDest
.
mData
aError
)
;
break
;
}
case
RUST_CALL_ERROR
:
{
aDest
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Error
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
)
;
mUniffiCallStatusErrorBuf
.
IntoArrayBuffer
(
aCx
&
obj
aError
)
;
if
(
aError
.
Failed
(
)
)
{
break
;
}
aDest
.
mData
.
Construct
(
)
.
SetAsArrayBuffer
(
)
.
Init
(
obj
)
;
break
;
}
default
:
{
aDest
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Internal_error
;
if
(
mUniffiCallStatusErrorBuf
.
IsValid
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
)
;
mUniffiCallStatusErrorBuf
.
IntoArrayBuffer
(
aCx
&
obj
aError
)
;
if
(
aError
.
Failed
(
)
)
{
break
;
}
aDest
.
mData
.
Construct
(
)
.
SetAsArrayBuffer
(
)
.
Init
(
obj
)
;
}
break
;
}
}
}
}
