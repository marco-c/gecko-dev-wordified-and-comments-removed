#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
uniffi
/
Call
.
h
"
namespace
mozilla
:
:
uniffi
{
extern
mozilla
:
:
LazyLogModule
gUniffiLogger
;
using
dom
:
:
GlobalObject
;
using
dom
:
:
OwningUniFFIScaffoldingValue
;
using
dom
:
:
RootedDictionary
;
using
dom
:
:
Sequence
;
using
dom
:
:
UniFFIScaffoldingCallResult
;
void
UniffiSyncCallHandler
:
:
CallSync
(
UniquePtr
<
UniffiSyncCallHandler
>
aHandler
const
GlobalObject
&
aGlobal
const
Sequence
<
OwningUniFFIScaffoldingValue
>
&
aArgs
RootedDictionary
<
UniFFIScaffoldingCallResult
>
&
aReturnValue
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aHandler
-
>
PrepareRustArgs
(
aArgs
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
RustCallStatus
callStatus
{
}
;
aHandler
-
>
MakeRustCall
(
&
callStatus
)
;
aHandler
-
>
mUniffiCallStatusCode
=
callStatus
.
code
;
if
(
callStatus
.
error_buf
.
data
)
{
aHandler
-
>
mUniffiCallStatusErrorBuf
=
FfiValueRustBuffer
(
callStatus
.
error_buf
)
;
}
aHandler
-
>
ExtractCallResult
(
aGlobal
.
Context
(
)
aReturnValue
aError
)
;
}
already_AddRefed
<
dom
:
:
Promise
>
UniffiSyncCallHandler
:
:
CallAsyncWrapper
(
UniquePtr
<
UniffiSyncCallHandler
>
aHandler
const
dom
:
:
GlobalObject
&
aGlobal
const
dom
:
:
Sequence
<
dom
:
:
OwningUniFFIScaffoldingValue
>
&
aArgs
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aHandler
-
>
PrepareRustArgs
(
aArgs
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIGlobalObject
>
xpcomGlobal
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
dom
:
:
Promise
>
returnPromise
=
dom
:
:
Promise
:
:
Create
(
xpcomGlobal
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
taskPromise
=
new
MozPromise
<
UniquePtr
<
UniffiSyncCallHandler
>
nsresult
true
>
:
:
Private
(
__func__
)
;
nsresult
dispatchResult
=
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
__func__
[
handler
=
std
:
:
move
(
aHandler
)
taskPromise
]
(
)
mutable
{
RustCallStatus
callStatus
{
}
;
handler
-
>
MakeRustCall
(
&
callStatus
)
;
handler
-
>
mUniffiCallStatusCode
=
callStatus
.
code
;
if
(
callStatus
.
error_buf
.
data
)
{
handler
-
>
mUniffiCallStatusErrorBuf
=
FfiValueRustBuffer
(
callStatus
.
error_buf
)
;
}
taskPromise
-
>
Resolve
(
std
:
:
move
(
handler
)
__func__
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
if
(
NS_FAILED
(
dispatchResult
)
)
{
taskPromise
-
>
Reject
(
dispatchResult
__func__
)
;
}
taskPromise
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
xpcomGlobal
returnPromise
]
(
typename
MozPromise
<
UniquePtr
<
UniffiSyncCallHandler
>
nsresult
true
>
:
:
ResolveOrRejectValue
&
&
aResult
)
{
if
(
!
aResult
.
IsResolve
(
)
)
{
returnPromise
-
>
MaybeRejectWithUnknownError
(
__func__
)
;
return
;
}
auto
handler
=
std
:
:
move
(
aResult
.
ResolveValue
(
)
)
;
dom
:
:
AutoEntryScript
aes
(
xpcomGlobal
"
UniffiSyncCallHandler
:
:
CallAsyncWrapper
"
)
;
dom
:
:
RootedDictionary
<
dom
:
:
UniFFIScaffoldingCallResult
>
returnValue
(
aes
.
cx
(
)
)
;
ErrorResult
error
;
handler
-
>
ExtractCallResult
(
aes
.
cx
(
)
returnValue
error
)
;
error
.
WouldReportJSException
(
)
;
if
(
error
.
Failed
(
)
)
{
returnPromise
-
>
MaybeReject
(
std
:
:
move
(
error
)
)
;
}
else
{
returnPromise
-
>
MaybeResolve
(
returnValue
)
;
}
}
)
;
return
returnPromise
.
forget
(
)
;
}
void
UniffiCallHandlerBase
:
:
ExtractCallResult
(
JSContext
*
aCx
dom
:
:
RootedDictionary
<
dom
:
:
UniFFIScaffoldingCallResult
>
&
aDest
ErrorResult
&
aError
)
{
switch
(
mUniffiCallStatusCode
)
{
case
RUST_CALL_SUCCESS
:
{
aDest
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Success
;
ExtractSuccessfulCallResult
(
aCx
aDest
.
mData
aError
)
;
break
;
}
case
RUST_CALL_ERROR
:
{
aDest
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Error
;
mUniffiCallStatusErrorBuf
.
Lift
(
aCx
&
aDest
.
mData
.
Construct
(
)
aError
)
;
break
;
}
default
:
{
aDest
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Internal_error
;
if
(
mUniffiCallStatusErrorBuf
.
IsSet
(
)
)
{
mUniffiCallStatusErrorBuf
.
Lift
(
aCx
&
aDest
.
mData
.
Construct
(
)
aError
)
;
}
break
;
}
}
}
already_AddRefed
<
dom
:
:
Promise
>
UniffiAsyncCallHandler
:
:
CallAsync
(
UniquePtr
<
UniffiAsyncCallHandler
>
aHandler
const
dom
:
:
GlobalObject
&
aGlobal
const
dom
:
:
Sequence
<
dom
:
:
OwningUniFFIScaffoldingValue
>
&
aArgs
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aHandler
-
>
PrepareArgsAndMakeRustCall
(
aArgs
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
(
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
)
;
aHandler
-
>
mPromise
=
dom
:
:
Promise
:
:
Create
(
global
aError
)
;
RefPtr
<
dom
:
:
Promise
>
returnPromise
(
aHandler
-
>
mPromise
)
;
if
(
aError
.
Failed
(
)
)
{
aError
.
ThrowUnknownError
(
"
[
UniFFI
]
dom
:
:
Promise
:
:
Create
failed
"
_ns
)
;
return
nullptr
;
}
nsresult
dispatchResult
=
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
__func__
[
handler
=
std
:
:
move
(
aHandler
)
]
(
)
mutable
{
UniffiAsyncCallHandler
:
:
Poll
(
std
:
:
move
(
handler
)
)
;
}
)
)
;
if
(
NS_FAILED
(
dispatchResult
)
)
{
aError
.
ThrowUnknownError
(
"
[
UniFFI
]
UniffiAsyncCallHandler
:
:
CallAsync
-
Error
scheduling
background
task
"
_ns
)
;
return
nullptr
;
}
return
returnPromise
.
forget
(
)
;
}
void
UniffiAsyncCallHandler
:
:
FutureCallback
(
uint64_t
aCallHandlerHandle
int8_t
aCode
)
{
UniquePtr
<
UniffiAsyncCallHandler
>
handler
(
reinterpret_cast
<
UniffiAsyncCallHandler
*
>
(
static_cast
<
uintptr_t
>
(
aCallHandlerHandle
)
)
)
;
switch
(
aCode
)
{
case
UNIFFI_FUTURE_READY
:
{
nsresult
dispatchResult
=
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
handler
=
std
:
:
move
(
handler
)
]
(
)
mutable
{
UniffiAsyncCallHandler
:
:
Finish
(
std
:
:
move
(
handler
)
)
;
}
)
)
;
if
(
NS_FAILED
(
dispatchResult
)
)
{
MOZ_LOG
(
gUniffiLogger
LogLevel
:
:
Error
(
"
[
UniFFI
]
NS_DispatchToMainThread
failed
in
"
"
UniffiAsyncCallHandler
:
:
FutureCallback
"
)
)
;
}
break
;
}
case
UNIFFI_FUTURE_MAYBE_READY
:
{
nsresult
dispatchResult
=
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
__func__
[
handler
=
std
:
:
move
(
handler
)
]
(
)
mutable
{
UniffiAsyncCallHandler
:
:
Poll
(
std
:
:
move
(
handler
)
)
;
}
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
dispatchResult
)
)
{
MOZ_LOG
(
gUniffiLogger
LogLevel
:
:
Error
(
"
[
UniFFI
]
NS_DispatchBackgroundTask
failed
in
"
"
UniffiAsyncCallHandler
:
:
FutureCallback
"
)
)
;
}
break
;
}
default
:
{
MOZ_LOG
(
gUniffiLogger
LogLevel
:
:
Error
(
"
[
UniFFI
]
Invalid
poll
code
in
"
"
UniffiAsyncCallHandler
:
:
FutureCallback
%
d
"
aCode
)
)
;
handler
-
>
mPromise
-
>
MaybeRejectWithUndefined
(
)
;
break
;
}
}
;
}
void
UniffiAsyncCallHandler
:
:
Poll
(
UniquePtr
<
UniffiAsyncCallHandler
>
aHandler
)
{
auto
futureHandle
=
aHandler
-
>
mFutureHandle
;
auto
pollFn
=
aHandler
-
>
mPollFn
;
uint64_t
selfHandle
=
static_cast
<
uint64_t
>
(
reinterpret_cast
<
uintptr_t
>
(
aHandler
.
release
(
)
)
)
;
pollFn
(
futureHandle
UniffiAsyncCallHandler
:
:
FutureCallback
selfHandle
)
;
}
void
UniffiAsyncCallHandler
:
:
Finish
(
UniquePtr
<
UniffiAsyncCallHandler
>
aHandler
)
{
RefPtr
<
dom
:
:
Promise
>
promise
=
aHandler
-
>
mPromise
;
if
(
!
promise
)
{
return
;
}
dom
:
:
AutoEntryScript
aes
(
promise
-
>
GetGlobalObject
(
)
"
UniffiAsyncCallHandler
:
:
Finish
"
)
;
dom
:
:
RootedDictionary
<
dom
:
:
UniFFIScaffoldingCallResult
>
returnValue
(
aes
.
cx
(
)
)
;
ErrorResult
error
;
RustCallStatus
callStatus
{
}
;
aHandler
-
>
CallCompleteFn
(
&
callStatus
)
;
aHandler
-
>
mUniffiCallStatusCode
=
callStatus
.
code
;
if
(
callStatus
.
error_buf
.
data
)
{
aHandler
-
>
mUniffiCallStatusErrorBuf
=
FfiValueRustBuffer
(
callStatus
.
error_buf
)
;
}
aHandler
-
>
ExtractCallResult
(
aes
.
cx
(
)
returnValue
error
)
;
error
.
WouldReportJSException
(
)
;
if
(
error
.
Failed
(
)
)
{
aHandler
-
>
mPromise
-
>
MaybeReject
(
std
:
:
move
(
error
)
)
;
}
else
{
aHandler
-
>
mPromise
-
>
MaybeResolve
(
returnValue
)
;
}
}
UniffiAsyncCallHandler
:
:
~
UniffiAsyncCallHandler
(
)
{
mFreeFn
(
mFutureHandle
)
;
}
}
