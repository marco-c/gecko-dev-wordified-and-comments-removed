#
ifndef
mozilla_ScaffoldingCall_h
#
define
mozilla_ScaffoldingCall_h
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
dom
/
OwnedRustBuffer
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ScaffoldingConverter
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIBinding
.
h
"
#
include
"
mozilla
/
dom
/
UniFFIRust
.
h
"
namespace
mozilla
:
:
uniffi
{
template
<
typename
ReturnType
>
struct
RustCallResult
{
ReturnType
mReturnValue
;
RustCallStatus
mCallStatus
=
{
}
;
}
;
template
<
>
struct
RustCallResult
<
void
>
{
RustCallStatus
mCallStatus
=
{
}
;
}
;
template
<
typename
ReturnConverter
typename
.
.
.
ArgConverters
>
class
ScaffoldingCallHandler
{
public
:
using
ScaffoldingFunc
=
typename
ReturnConverter
:
:
RustType
(
*
)
(
typename
ArgConverters
:
:
RustType
.
.
.
RustCallStatus
*
)
;
static
already_AddRefed
<
dom
:
:
Promise
>
CallAsync
(
ScaffoldingFunc
aScaffoldingFunc
const
dom
:
:
GlobalObject
&
aGlobal
const
dom
:
:
Sequence
<
dom
:
:
ScaffoldingType
>
&
aArgs
const
nsLiteralCString
&
aFuncName
ErrorResult
&
aError
)
{
auto
convertResult
=
ConvertJsArgs
(
aArgs
)
;
if
(
convertResult
.
isErr
(
)
)
{
aError
.
ThrowUnknownError
(
aFuncName
+
convertResult
.
unwrapErr
(
)
)
;
return
nullptr
;
}
auto
convertedArgs
=
convertResult
.
unwrap
(
)
;
nsCOMPtr
<
nsIGlobalObject
>
xpcomGlobal
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
dom
:
:
Promise
>
returnPromise
=
dom
:
:
Promise
:
:
Create
(
xpcomGlobal
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
taskPromise
=
new
typename
TaskPromiseType
:
:
Private
(
aFuncName
.
get
(
)
)
;
nsresult
dispatchResult
=
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
aFuncName
.
get
(
)
[
args
=
std
:
:
move
(
convertedArgs
)
taskPromise
aScaffoldingFunc
aFuncName
]
(
)
mutable
{
auto
callResult
=
CallScaffoldingFunc
(
aScaffoldingFunc
std
:
:
move
(
args
)
)
;
taskPromise
-
>
Resolve
(
std
:
:
move
(
callResult
)
aFuncName
.
get
(
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
if
(
NS_FAILED
(
dispatchResult
)
)
{
taskPromise
-
>
Reject
(
dispatchResult
aFuncName
.
get
(
)
)
;
}
taskPromise
-
>
Then
(
GetCurrentSerialEventTarget
(
)
aFuncName
.
get
(
)
[
xpcomGlobal
returnPromise
aFuncName
]
(
typename
TaskPromiseType
:
:
ResolveOrRejectValue
&
&
aResult
)
{
if
(
!
aResult
.
IsResolve
(
)
)
{
returnPromise
-
>
MaybeRejectWithUnknownError
(
aFuncName
)
;
return
;
}
dom
:
:
AutoEntryScript
aes
(
xpcomGlobal
aFuncName
.
get
(
)
)
;
dom
:
:
RootedDictionary
<
dom
:
:
UniFFIScaffoldingCallResult
>
returnValue
(
aes
.
cx
(
)
)
;
ReturnResult
(
aes
.
cx
(
)
aResult
.
ResolveValue
(
)
returnValue
aFuncName
)
;
returnPromise
-
>
MaybeResolve
(
returnValue
)
;
}
)
;
return
returnPromise
.
forget
(
)
;
}
static
void
CallSync
(
ScaffoldingFunc
aScaffoldingFunc
const
dom
:
:
GlobalObject
&
aGlobal
const
dom
:
:
Sequence
<
dom
:
:
ScaffoldingType
>
&
aArgs
dom
:
:
RootedDictionary
<
dom
:
:
UniFFIScaffoldingCallResult
>
&
aReturnValue
const
nsLiteralCString
&
aFuncName
ErrorResult
&
aError
)
{
auto
convertResult
=
ConvertJsArgs
(
aArgs
)
;
if
(
convertResult
.
isErr
(
)
)
{
aError
.
ThrowUnknownError
(
aFuncName
+
convertResult
.
unwrapErr
(
)
)
;
return
;
}
auto
callResult
=
CallScaffoldingFunc
(
aScaffoldingFunc
std
:
:
move
(
convertResult
.
unwrap
(
)
)
)
;
ReturnResult
(
aGlobal
.
Context
(
)
callResult
aReturnValue
aFuncName
)
;
}
private
:
using
RustArgs
=
std
:
:
tuple
<
typename
ArgConverters
:
:
RustType
.
.
.
>
;
using
IntermediateArgs
=
std
:
:
tuple
<
typename
ArgConverters
:
:
IntermediateType
.
.
.
>
;
using
RustCallResult
=
RustCallResult
<
typename
ReturnConverter
:
:
RustType
>
;
using
TaskPromiseType
=
MozPromise
<
RustCallResult
nsresult
true
>
;
template
<
size_t
I
>
using
NthArgConverter
=
typename
std
:
:
tuple_element
<
I
std
:
:
tuple
<
ArgConverters
.
.
.
>
>
:
:
type
;
static
Result
<
IntermediateArgs
nsCString
>
ConvertJsArgs
(
const
dom
:
:
Sequence
<
dom
:
:
ScaffoldingType
>
&
aArgs
)
{
IntermediateArgs
convertedArgs
;
if
(
aArgs
.
Length
(
)
!
=
std
:
:
tuple_size_v
<
IntermediateArgs
>
)
{
return
mozilla
:
:
Err
(
"
Wrong
argument
count
"
_ns
)
;
}
auto
result
=
PrepareArgsHelper
<
0
>
(
aArgs
convertedArgs
)
;
return
result
.
map
(
[
&
]
(
auto
_
)
{
return
std
:
:
move
(
convertedArgs
)
;
}
)
;
}
template
<
size_t
I
=
0
>
static
Result
<
mozilla
:
:
Ok
nsCString
>
PrepareArgsHelper
(
const
dom
:
:
Sequence
<
dom
:
:
ScaffoldingType
>
&
aArgs
IntermediateArgs
&
aConvertedArgs
)
{
if
constexpr
(
I
>
=
sizeof
.
.
.
(
ArgConverters
)
)
{
return
mozilla
:
:
Ok
(
)
;
}
else
{
auto
result
=
NthArgConverter
<
I
>
:
:
FromJs
(
aArgs
[
I
]
)
;
if
(
result
.
isOk
(
)
)
{
std
:
:
get
<
I
>
(
aConvertedArgs
)
=
result
.
unwrap
(
)
;
return
PrepareArgsHelper
<
I
+
1
>
(
aArgs
aConvertedArgs
)
;
}
else
{
return
mozilla
:
:
Err
(
result
.
unwrapErr
(
)
+
nsPrintfCString
(
"
(
arg
%
ld
)
"
I
)
)
;
}
}
}
static
RustCallResult
CallScaffoldingFunc
(
ScaffoldingFunc
aFunc
IntermediateArgs
&
&
aArgs
)
{
return
CallScaffoldingFuncHelper
(
aFunc
std
:
:
move
(
aArgs
)
std
:
:
index_sequence_for
<
ArgConverters
.
.
.
>
(
)
)
;
}
template
<
size_t
.
.
.
Is
>
static
RustCallResult
CallScaffoldingFuncHelper
(
ScaffoldingFunc
aFunc
IntermediateArgs
&
&
aArgs
std
:
:
index_sequence
<
Is
.
.
.
>
seq
)
{
RustCallResult
result
;
auto
makeCall
=
[
&
]
(
)
mutable
{
return
aFunc
(
NthArgConverter
<
Is
>
:
:
IntoRust
(
std
:
:
move
(
std
:
:
get
<
Is
>
(
aArgs
)
)
)
.
.
.
&
result
.
mCallStatus
)
;
}
;
if
constexpr
(
std
:
:
is_void_v
<
typename
ReturnConverter
:
:
RustType
>
)
{
makeCall
(
)
;
}
else
{
result
.
mReturnValue
=
makeCall
(
)
;
}
return
result
;
}
static
void
ReturnResult
(
JSContext
*
aContext
RustCallResult
&
aCallResult
dom
:
:
RootedDictionary
<
dom
:
:
UniFFIScaffoldingCallResult
>
&
aReturnValue
const
nsLiteralCString
&
aFuncName
)
{
switch
(
aCallResult
.
mCallStatus
.
code
)
{
case
RUST_CALL_SUCCESS
:
{
aReturnValue
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Success
;
if
constexpr
(
!
std
:
:
is_void_v
<
typename
ReturnConverter
:
:
RustType
>
)
{
auto
convertResult
=
ReturnConverter
:
:
FromRust
(
aCallResult
.
mReturnValue
)
;
if
(
convertResult
.
isOk
(
)
)
{
ReturnConverter
:
:
IntoJs
(
aContext
std
:
:
move
(
convertResult
.
unwrap
(
)
)
aReturnValue
.
mData
.
Construct
(
)
)
;
}
else
{
aReturnValue
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Internal_error
;
aReturnValue
.
mInternalErrorMessage
.
Construct
(
aFuncName
+
"
converting
result
:
"
_ns
+
convertResult
.
unwrapErr
(
)
)
;
}
}
break
;
}
case
RUST_CALL_ERROR
:
{
aReturnValue
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Error
;
aReturnValue
.
mData
.
Construct
(
)
.
SetAsArrayBuffer
(
)
.
Init
(
OwnedRustBuffer
(
aCallResult
.
mCallStatus
.
error_buf
)
.
IntoArrayBuffer
(
aContext
)
)
;
break
;
}
default
:
{
aReturnValue
.
mCode
=
dom
:
:
UniFFIScaffoldingCallCode
:
:
Internal_error
;
aReturnValue
.
mInternalErrorMessage
.
Construct
(
aFuncName
+
"
Unexpected
Error
"
_ns
)
;
break
;
}
}
}
}
;
}
#
endif
