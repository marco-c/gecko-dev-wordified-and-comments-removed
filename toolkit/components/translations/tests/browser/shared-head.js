"
use
strict
"
;
const
BLANK_PAGE
=
"
data
:
text
/
html
;
charset
=
utf
-
8
<
!
DOCTYPE
html
>
<
title
>
Blank
<
/
title
>
Blank
page
"
;
const
URL_PREFIX
=
"
https
:
/
/
example
.
com
/
browser
/
"
;
const
CHROME_URL_PREFIX
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
;
const
DIR_PATH
=
"
toolkit
/
components
/
translations
/
tests
/
browser
/
"
;
const
TRANSLATIONS_TESTER_EN
=
URL_PREFIX
+
DIR_PATH
+
"
translations
-
tester
-
en
.
html
"
;
const
TRANSLATIONS_TESTER_ES
=
URL_PREFIX
+
DIR_PATH
+
"
translations
-
tester
-
es
.
html
"
;
const
TRANSLATIONS_TESTER_NO_TAG
=
URL_PREFIX
+
DIR_PATH
+
"
translations
-
tester
-
no
-
tag
.
html
"
;
async
function
openAboutTranslations
(
{
dataForContent
disabled
runInPage
detectedLanguageConfidence
detectedLanguageLabel
languagePairs
prefs
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
translations
.
enable
"
!
disabled
]
[
"
browser
.
translations
.
logLevel
"
"
All
"
]
.
.
.
(
prefs
?
?
[
]
)
]
}
)
;
const
selectors
=
{
pageHeader
:
'
[
data
-
l10n
-
id
=
"
about
-
translations
-
header
"
]
'
fromLanguageSelect
:
"
select
#
language
-
from
"
toLanguageSelect
:
"
select
#
language
-
to
"
translationTextarea
:
"
textarea
#
translation
-
from
"
translationResult
:
"
#
translation
-
to
"
translationResultBlank
:
"
#
translation
-
to
-
blank
"
translationInfo
:
"
#
translation
-
info
"
noSupportMessage
:
"
[
data
-
l10n
-
id
=
'
about
-
translations
-
no
-
support
'
]
"
}
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
BLANK_PAGE
true
)
;
if
(
languagePairs
)
{
TranslationsParent
.
mockLanguagePairs
(
languagePairs
)
;
}
TranslationsParent
.
mockLanguageIdentification
(
detectedLanguageLabel
?
?
"
en
"
detectedLanguageConfidence
?
?
"
0
.
5
"
)
;
BrowserTestUtils
.
loadURIString
(
tab
.
linkedBrowser
"
about
:
translations
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
dataForContent
selectors
}
runInPage
)
;
if
(
languagePairs
)
{
TranslationsParent
.
mockLanguagePairs
(
null
)
;
}
if
(
detectedLanguageLabel
&
&
detectedLanguageConfidence
)
{
TranslationsParent
.
mockLanguageIdentification
(
null
null
)
;
}
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
function
naivelyPrettify
(
html
)
{
let
result
=
"
"
;
let
indent
=
0
;
function
addText
(
actualEndIndex
)
{
const
text
=
html
.
slice
(
startIndex
actualEndIndex
)
.
trim
(
)
;
if
(
text
)
{
for
(
let
i
=
0
;
i
<
indent
;
i
+
+
)
{
result
+
=
"
"
;
}
result
+
=
text
+
"
\
n
"
;
}
startIndex
=
actualEndIndex
;
}
let
startIndex
=
0
;
let
endIndex
=
0
;
for
(
;
endIndex
<
html
.
length
;
endIndex
+
+
)
{
if
(
html
[
endIndex
]
=
=
=
"
"
|
|
html
[
endIndex
]
=
=
=
"
\
t
"
|
|
html
[
endIndex
]
=
=
=
"
n
"
)
{
startIndex
=
endIndex
;
continue
;
}
while
(
endIndex
<
html
.
length
&
&
html
[
endIndex
]
!
=
=
"
<
"
)
{
endIndex
+
+
;
}
addText
(
endIndex
)
;
if
(
html
[
endIndex
]
=
=
=
"
<
"
)
{
if
(
html
[
endIndex
+
1
]
=
=
=
"
/
"
)
{
while
(
endIndex
<
html
.
length
&
&
html
[
endIndex
]
!
=
=
"
>
"
)
{
endIndex
+
+
;
}
indent
-
-
;
addText
(
endIndex
+
1
)
;
}
else
{
while
(
endIndex
<
html
.
length
&
&
html
[
endIndex
]
!
=
=
"
>
"
)
{
endIndex
+
+
;
}
addText
(
endIndex
+
1
)
;
indent
+
+
;
}
}
}
return
result
.
trim
(
)
;
}
function
createBatchFakeTranslator
(
)
{
let
letter
=
"
a
"
;
return
async
function
fakeTranslator
(
message
)
{
function
transformNode
(
node
)
{
if
(
typeof
node
.
nodeValue
=
=
=
"
string
"
)
{
node
.
nodeValue
=
node
.
nodeValue
.
replace
(
/
\
w
/
g
letter
)
;
}
for
(
const
childNode
of
node
.
childNodes
)
{
transformNode
(
childNode
)
;
}
}
const
parser
=
new
DOMParser
(
)
;
const
translatedDoc
=
parser
.
parseFromString
(
message
"
text
/
html
"
)
;
transformNode
(
translatedDoc
.
body
)
;
letter
=
String
.
fromCodePoint
(
letter
.
codePointAt
(
0
)
+
1
)
;
return
[
translatedDoc
.
body
.
innerHTML
]
;
}
;
}
async
function
reorderingTranslator
(
message
)
{
function
transformNode
(
node
)
{
if
(
typeof
node
.
nodeValue
=
=
=
"
string
"
)
{
node
.
nodeValue
=
node
.
nodeValue
.
toUpperCase
(
)
;
}
const
nodes
=
[
.
.
.
node
.
childNodes
]
;
nodes
.
sort
(
(
a
b
)
=
>
(
a
.
textContent
?
.
trim
(
)
?
?
"
"
)
.
localeCompare
(
b
.
textContent
?
.
trim
(
)
?
?
"
"
)
)
;
for
(
const
childNode
of
nodes
)
{
childNode
.
remove
(
)
;
}
for
(
const
childNode
of
nodes
)
{
node
.
appendChild
(
childNode
)
;
transformNode
(
childNode
)
;
}
}
const
parser
=
new
DOMParser
(
)
;
const
translatedDoc
=
parser
.
parseFromString
(
message
"
text
/
html
"
)
;
transformNode
(
translatedDoc
.
body
)
;
return
[
translatedDoc
.
body
.
innerHTML
]
;
}
async
function
setupActorTest
(
{
languagePairs
prefs
detectedLanguageConfidence
detectedLanguageLabel
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
translations
.
enable
"
true
]
[
"
browser
.
translations
.
logLevel
"
"
All
"
]
.
.
.
(
prefs
?
?
[
]
)
]
}
)
;
if
(
languagePairs
)
{
const
translationModels
=
await
createTranslationModelsRemoteClient
(
languagePairs
)
;
TranslationsParent
.
translationModelsRemoteClient
=
translationModels
.
client
;
}
if
(
detectedLanguageLabel
&
&
detectedLanguageConfidence
)
{
TranslationsParent
.
mockLanguageIdentification
(
detectedLanguageLabel
detectedLanguageConfidence
)
;
}
const
actor
=
gBrowser
.
selectedBrowser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
Translations
"
)
;
return
{
actor
cleanup
(
)
{
TranslationsParent
.
translationModelsRemoteClient
=
null
;
TranslationsParent
.
mockLanguageIdentification
(
null
null
)
;
return
SpecialPowers
.
popPrefEnv
(
)
;
}
}
;
}
async
function
loadTestPage
(
{
languagePairs
detectedLanguageConfidence
detectedLanguageLabel
page
prefs
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
translations
.
enable
"
true
]
[
"
browser
.
translations
.
logLevel
"
"
All
"
]
.
.
.
(
prefs
?
?
[
]
)
]
}
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
BLANK_PAGE
true
)
;
if
(
languagePairs
)
{
TranslationsParent
.
mockLanguagePairs
(
languagePairs
)
;
}
if
(
detectedLanguageLabel
&
&
detectedLanguageConfidence
)
{
TranslationsParent
.
mockLanguageIdentification
(
detectedLanguageLabel
detectedLanguageConfidence
)
;
}
BrowserTestUtils
.
loadURIString
(
tab
.
linkedBrowser
page
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
return
{
tab
cleanup
(
)
{
if
(
languagePairs
)
{
TranslationsParent
.
mockLanguagePairs
(
null
)
;
}
if
(
detectedLanguageLabel
&
&
detectedLanguageConfidence
)
{
TranslationsParent
.
mockLanguageIdentification
(
null
null
)
;
}
BrowserTestUtils
.
removeTab
(
tab
)
;
return
SpecialPowers
.
popPrefEnv
(
)
;
}
runInPage
(
callback
)
{
const
fn
=
new
Function
(
const
TranslationsTest
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
components
/
translations
/
tests
/
browser
/
translations
-
test
.
mjs
"
)
;
/
/
Pass
in
the
values
that
get
injected
by
the
task
runner
.
TranslationsTest
.
setup
(
{
Assert
ContentTaskUtils
content
}
)
;
return
(
{
callback
.
toString
(
)
}
)
(
TranslationsTest
)
;
)
;
return
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
}
fn
)
;
}
}
;
}
async
function
loadTestPageAndRun
(
options
)
{
const
{
cleanup
runInPage
}
=
await
loadTestPage
(
options
)
;
await
runInPage
(
options
.
runInPage
)
;
await
cleanup
(
)
;
}
function
createAttachmentMock
(
client
)
{
const
pendingDownloads
=
[
]
;
client
.
attachments
.
download
=
record
=
>
new
Promise
(
(
resolve
reject
)
=
>
{
pendingDownloads
.
push
(
{
record
resolve
reject
}
)
;
}
)
;
function
waitForDownloads
(
)
{
return
TestUtils
.
waitForCondition
(
(
)
=
>
!
!
pendingDownloads
.
length
"
Waiting
for
a
pending
download
to
be
added
"
)
;
}
function
resolvePendingDownloads
(
)
{
info
(
"
Resolving
downloads
"
)
;
return
downloadHandler
(
download
=
>
download
.
resolve
(
{
buffer
:
new
ArrayBuffer
(
)
}
)
)
;
}
function
rejectPendingDownloads
(
)
{
info
(
"
Rejecting
downloads
"
)
;
return
downloadHandler
(
download
=
>
download
.
reject
(
)
)
;
}
async
function
downloadHandler
(
action
)
{
await
waitForDownloads
(
)
;
const
names
=
[
]
;
while
(
true
)
{
await
null
;
let
download
=
pendingDownloads
.
shift
(
)
;
if
(
!
download
)
{
break
;
}
action
(
download
)
;
names
.
push
(
download
.
record
.
name
)
;
}
return
names
.
sort
(
(
a
b
)
=
>
a
.
localeCompare
(
b
)
)
;
}
async
function
assertNoNewDownloads
(
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
is
(
pendingDownloads
.
length
0
No
downloads
happened
for
"
{
client
.
collectionName
}
"
)
;
}
return
{
client
pendingDownloads
resolvePendingDownloads
rejectPendingDownloads
assertNoNewDownloads
}
;
}
async
function
createTranslationModelsRemoteClient
(
langPairs
)
{
const
records
=
[
]
;
for
(
const
{
fromLang
toLang
}
of
langPairs
)
{
const
lang
=
fromLang
+
toLang
;
const
models
=
[
{
fileType
:
"
model
"
name
:
model
.
{
lang
}
.
intgemm
.
alphas
.
bin
}
{
fileType
:
"
lex
"
name
:
lex
.
50
.
50
.
{
lang
}
.
s2t
.
bin
}
{
fileType
:
"
qualityModel
"
name
:
qualityModel
.
{
lang
}
.
bin
}
{
fileType
:
"
vocab
"
name
:
vocab
.
{
lang
}
.
spm
}
]
;
for
(
const
{
fileType
name
}
of
models
)
{
records
.
push
(
{
id
:
crypto
.
randomUUID
(
)
name
fromLang
toLang
fileType
version
:
"
1
.
0
"
last_modified
:
Date
.
now
(
)
schema
:
Date
.
now
(
)
}
)
;
}
}
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
const
client
=
RemoteSettings
(
"
test
-
translation
-
models
"
)
;
const
metadata
=
{
}
;
await
client
.
db
.
clear
(
)
;
await
client
.
db
.
importChanges
(
metadata
Date
.
now
(
)
records
)
;
return
createAttachmentMock
(
client
)
;
}
async
function
createTranslationsWasmRemoteClient
(
)
{
const
records
=
[
"
bergamot
-
translator
"
"
fasttext
-
wasm
"
]
.
map
(
name
=
>
(
{
id
:
crypto
.
randomUUID
(
)
name
version
:
"
1
.
0
"
last_modified
:
Date
.
now
(
)
schema
:
Date
.
now
(
)
}
)
)
;
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
const
client
=
RemoteSettings
(
"
test
-
translations
-
wasm
"
)
;
const
metadata
=
{
}
;
await
client
.
db
.
clear
(
)
;
await
client
.
db
.
importChanges
(
metadata
Date
.
now
(
)
records
)
;
return
createAttachmentMock
(
client
)
;
}
async
function
createLanguageIdModelsRemoteClient
(
)
{
const
records
=
[
{
id
:
crypto
.
randomUUID
(
)
name
:
"
lid
.
176
.
ftz
"
version
:
"
1
.
0
"
last_modified
:
Date
.
now
(
)
schema
:
Date
.
now
(
)
}
]
;
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
const
client
=
RemoteSettings
(
"
test
-
language
-
id
-
models
"
)
;
const
metadata
=
{
}
;
await
client
.
db
.
clear
(
)
;
await
client
.
db
.
importChanges
(
metadata
Date
.
now
(
)
records
)
;
return
createAttachmentMock
(
client
)
;
}
