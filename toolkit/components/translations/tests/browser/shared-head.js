"
use
strict
"
;
const
{
EngineProcess
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
global
/
content
/
ml
/
EngineProcess
.
sys
.
mjs
"
)
;
const
{
TranslationsPanelShared
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
browser
/
content
/
translations
/
TranslationsPanelShared
.
sys
.
mjs
"
)
;
const
{
TranslationsUtils
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
global
/
content
/
translations
/
TranslationsUtils
.
mjs
"
)
;
const
{
getInferenceProcessInfo
:
fetchInferenceProcessInfo
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
global
/
content
/
ml
/
Utils
.
sys
.
mjs
"
)
;
const
BLANK_PAGE
=
"
data
:
text
/
html
;
charset
=
utf
-
8
<
!
DOCTYPE
html
>
<
title
>
Blank
<
/
title
>
Blank
page
"
;
const
URL_COM_PREFIX
=
"
https
:
/
/
example
.
com
/
browser
/
"
;
const
URL_ORG_PREFIX
=
"
https
:
/
/
example
.
org
/
browser
/
"
;
const
CHROME_URL_PREFIX
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
;
const
DIR_PATH
=
"
toolkit
/
components
/
translations
/
tests
/
browser
/
"
;
function
_url
(
path
)
{
return
URL_COM_PREFIX
+
DIR_PATH
+
path
;
}
const
BLANK_PAGE_URL
=
_url
(
"
translations
-
tester
-
blank
.
html
"
)
;
const
SPANISH_PAGE_URL
=
_url
(
"
translations
-
tester
-
es
.
html
"
)
;
const
SPANISH_PAGE_URL_2
=
_url
(
"
translations
-
tester
-
es
-
2
.
html
"
)
;
const
SPANISH_PAGE_SHORT_URL
=
_url
(
"
translations
-
tester
-
es
-
short
.
html
"
)
;
const
SPANISH_PAGE_MISMATCH_URL
=
_url
(
"
translations
-
tester
-
es
-
mismatch
.
html
"
)
;
const
SPANISH_PAGE_MISMATCH_SHORT_URL
=
_url
(
"
translations
-
tester
-
es
-
mismatch
-
short
.
html
"
)
;
const
SPANISH_PAGE_UNDECLARED_URL
=
_url
(
"
translations
-
tester
-
es
-
undeclared
.
html
"
)
;
const
SPANISH_PAGE_UNDECLARED_SHORT_URL
=
_url
(
"
translations
-
tester
-
es
-
undeclared
-
short
.
html
"
)
;
const
ENGLISH_PAGE_URL
=
_url
(
"
translations
-
tester
-
en
.
html
"
)
;
const
FRENCH_PAGE_URL
=
_url
(
"
translations
-
tester
-
fr
.
html
"
)
;
const
NO_LANGUAGE_URL
=
_url
(
"
translations
-
tester
-
no
-
tag
.
html
"
)
;
const
PDF_TEST_PAGE_URL
=
_url
(
"
translations
-
tester
-
pdf
-
file
.
pdf
"
)
;
const
SELECT_TEST_PAGE_URL
=
_url
(
"
translations
-
tester
-
select
.
html
"
)
;
const
TEXT_CLEANING_URL
=
_url
(
"
translations
-
text
-
cleaning
.
html
"
)
;
const
ENGLISH_BENCHMARK_PAGE_URL
=
_url
(
"
translations
-
bencher
-
en
.
html
"
)
;
const
SPANISH_PAGE_URL_DOT_ORG
=
URL_ORG_PREFIX
+
DIR_PATH
+
"
translations
-
tester
-
es
.
html
"
;
const
PIVOT_LANGUAGE
=
"
en
"
;
const
LANGUAGE_PAIRS
=
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
es
"
}
{
fromLang
:
"
es
"
toLang
:
PIVOT_LANGUAGE
}
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
fr
"
}
{
fromLang
:
"
fr
"
toLang
:
PIVOT_LANGUAGE
}
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
uk
"
}
{
fromLang
:
"
uk
"
toLang
:
PIVOT_LANGUAGE
}
]
;
const
TRANSLATIONS_PERMISSION
=
"
translations
"
;
const
ALWAYS_TRANSLATE_LANGS_PREF
=
"
browser
.
translations
.
alwaysTranslateLanguages
"
;
const
NEVER_TRANSLATE_LANGS_PREF
=
"
browser
.
translations
.
neverTranslateLanguages
"
;
const
USE_LEXICAL_SHORTLIST_PREF
=
"
browser
.
translations
.
useLexicalShortlist
"
;
function
logAction
(
.
.
.
params
)
{
const
error
=
new
Error
(
)
;
const
stackLines
=
error
.
stack
.
split
(
"
\
n
"
)
;
const
actionName
=
stackLines
[
1
]
?
.
split
(
"
"
)
[
0
]
?
?
"
"
;
const
taskFileLocation
=
stackLines
[
2
]
?
.
split
(
"
"
)
[
1
]
?
?
"
"
;
if
(
taskFileLocation
.
includes
(
"
head
.
js
"
)
)
{
return
;
}
info
(
Action
:
{
actionName
}
(
{
params
.
join
(
"
"
)
}
)
)
;
info
(
Source
:
{
taskFileLocation
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
"
"
)
}
)
;
}
function
languageModelNames
(
languagePairs
)
{
return
languagePairs
.
flatMap
(
(
{
fromLang
toLang
}
)
=
>
[
model
.
{
fromLang
}
{
toLang
}
.
intgemm
.
alphas
.
bin
vocab
.
{
fromLang
}
{
toLang
}
.
spm
.
.
.
(
Services
.
prefs
.
getBoolPref
(
USE_LEXICAL_SHORTLIST_PREF
)
?
[
lex
.
50
.
50
.
{
fromLang
}
{
toLang
}
.
s2t
.
bin
]
:
[
]
)
]
)
.
sort
(
)
;
}
async
function
loadNewPage
(
browser
url
)
{
BrowserTestUtils
.
startLoadingURIString
(
browser
url
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
false
url
)
;
}
async
function
openAboutTranslations
(
{
disabled
languagePairs
=
LANGUAGE_PAIRS
prefs
autoDownloadFromRemoteSettings
=
false
}
=
{
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
translations
.
enable
"
!
disabled
]
[
"
browser
.
translations
.
logLevel
"
"
All
"
]
[
"
browser
.
translations
.
mostRecentTargetLanguages
"
"
"
]
[
USE_LEXICAL_SHORTLIST_PREF
false
]
.
.
.
(
prefs
?
?
[
]
)
]
}
)
;
const
selectors
=
{
pageHeader
:
"
header
#
about
-
translations
-
header
"
mainUserInterface
:
"
section
#
about
-
translations
-
main
-
user
-
interface
"
sourceLanguageSelector
:
"
select
#
about
-
translations
-
source
-
select
"
targetLanguageSelector
:
"
select
#
about
-
translations
-
target
-
select
"
detectLanguageOption
:
"
option
#
about
-
translations
-
detect
-
language
-
option
"
swapLanguagesButton
:
"
moz
-
button
#
about
-
translations
-
swap
-
languages
-
button
"
sourceTextArea
:
"
textarea
#
about
-
translations
-
source
-
textarea
"
targetTextArea
:
"
textarea
#
about
-
translations
-
target
-
textarea
"
unsupportedInfoMessage
:
"
moz
-
message
-
bar
#
about
-
translations
-
unsupported
-
info
-
message
"
languageLoadErrorMessage
:
"
moz
-
message
-
bar
#
about
-
translations
-
language
-
load
-
error
-
message
"
}
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
BLANK_PAGE
true
)
;
const
{
removeMocks
remoteClients
}
=
await
createAndMockRemoteSettings
(
{
languagePairs
autoDownloadFromRemoteSettings
}
)
;
await
loadNewPage
(
tab
.
linkedBrowser
"
about
:
translations
"
)
;
await
ensureWindowSize
(
window
1600
*
Math
.
SQRT1_2
900
*
Math
.
SQRT1_2
)
;
FullZoom
.
setZoom
(
Math
.
SQRT1_2
tab
.
linkedBrowser
)
;
const
resolveDownloads
=
async
count
=
>
{
await
remoteClients
.
translationsWasm
.
resolvePendingDownloads
(
1
)
;
await
remoteClients
.
translationModels
.
resolvePendingDownloads
(
downloadedFilesPerLanguagePair
(
)
*
count
)
;
}
;
const
rejectDownloads
=
async
count
=
>
{
await
remoteClients
.
translationsWasm
.
rejectPendingDownloads
(
1
)
;
await
remoteClients
.
translationModels
.
rejectPendingDownloads
(
downloadedFilesPerLanguagePair
(
)
*
count
)
;
}
;
const
runInPage
=
(
callback
data
=
{
}
)
=
>
{
return
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
selectors
contentData
:
data
callbackSource
:
callback
.
toString
(
)
}
function
(
{
selectors
contentData
callbackSource
}
)
{
const
contentCallback
=
eval
(
(
{
callbackSource
}
)
)
;
return
contentCallback
(
selectors
contentData
)
;
}
)
;
}
;
const
aboutTranslationsTestUtils
=
new
AboutTranslationsTestUtils
(
runInPage
resolveDownloads
rejectDownloads
autoDownloadFromRemoteSettings
)
;
if
(
!
disabled
)
{
await
aboutTranslationsTestUtils
.
waitForReady
(
)
;
}
return
{
aboutTranslationsTestUtils
async
cleanup
(
)
{
await
loadBlankPage
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
removeMocks
(
)
;
await
EngineProcess
.
destroyTranslationsEngine
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
TestTranslationsTelemetry
.
reset
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
}
}
;
}
function
naivelyPrettify
(
html
)
{
let
result
=
"
"
;
let
indent
=
0
;
function
addText
(
actualEndIndex
)
{
const
text
=
html
.
slice
(
startIndex
actualEndIndex
)
.
trim
(
)
;
if
(
text
)
{
for
(
let
i
=
0
;
i
<
indent
;
i
+
+
)
{
result
+
=
"
"
;
}
result
+
=
text
+
"
\
n
"
;
}
startIndex
=
actualEndIndex
;
}
let
startIndex
=
0
;
let
endIndex
=
0
;
for
(
;
endIndex
<
html
.
length
;
endIndex
+
+
)
{
if
(
html
[
endIndex
]
=
=
=
"
"
|
|
html
[
endIndex
]
=
=
=
"
\
t
"
|
|
html
[
endIndex
]
=
=
=
"
n
"
)
{
startIndex
=
endIndex
;
continue
;
}
while
(
endIndex
<
html
.
length
&
&
html
[
endIndex
]
!
=
=
"
<
"
)
{
endIndex
+
+
;
}
addText
(
endIndex
)
;
if
(
html
[
endIndex
]
=
=
=
"
<
"
)
{
if
(
html
[
endIndex
+
1
]
=
=
=
"
/
"
)
{
while
(
endIndex
<
html
.
length
&
&
html
[
endIndex
]
!
=
=
"
>
"
)
{
endIndex
+
+
;
}
indent
-
-
;
addText
(
endIndex
+
1
)
;
}
else
{
while
(
endIndex
<
html
.
length
&
&
html
[
endIndex
]
!
=
=
"
>
"
)
{
endIndex
+
+
;
}
addText
(
endIndex
+
1
)
;
indent
+
+
;
}
}
}
return
result
.
trim
(
)
;
}
function
upperCaseNode
(
node
)
{
if
(
typeof
node
.
nodeValue
=
=
=
"
string
"
)
{
node
.
nodeValue
=
node
.
nodeValue
.
toUpperCase
(
)
;
}
for
(
const
childNode
of
node
.
childNodes
)
{
upperCaseNode
(
childNode
)
;
}
}
function
diacriticizeNode
(
node
)
{
if
(
typeof
node
.
nodeValue
=
=
=
"
string
"
)
{
let
result
=
"
"
;
for
(
let
i
=
0
;
i
<
node
.
nodeValue
.
length
;
i
+
+
)
{
const
ch
=
node
.
nodeValue
[
i
]
;
result
+
=
ch
;
if
(
"
abcdefghijklmnopqrstuvwxyz
"
.
includes
(
ch
.
toLowerCase
(
)
)
)
{
result
+
=
"
\
u0305
"
;
}
}
node
.
nodeValue
=
result
;
}
for
(
const
childNode
of
node
.
childNodes
)
{
diacriticizeNode
(
childNode
)
;
}
}
function
createMockedTranslatorPort
(
transformNode
=
upperCaseNode
delay
=
0
)
{
const
parser
=
new
DOMParser
(
)
;
const
mockedPort
=
{
async
postMessage
(
message
)
{
await
TestUtils
.
waitForTick
(
)
;
switch
(
message
.
type
)
{
case
"
TranslationsPort
:
GetEngineStatusRequest
"
:
{
mockedPort
.
onmessage
(
{
data
:
{
type
:
"
TranslationsPort
:
GetEngineStatusResponse
"
status
:
"
ready
"
}
}
)
;
break
;
}
case
"
TranslationsPort
:
Passthrough
"
:
{
const
{
translationId
}
=
message
;
mockedPort
.
onmessage
(
{
data
:
{
type
:
"
TranslationsPort
:
TranslationResponse
"
translationId
targetText
:
null
}
}
)
;
break
;
}
case
"
TranslationsPort
:
CachedTranslation
"
:
{
const
{
cachedTranslation
translationId
}
=
message
;
mockedPort
.
onmessage
(
{
data
:
{
type
:
"
TranslationsPort
:
TranslationResponse
"
translationId
targetText
:
cachedTranslation
}
}
)
;
break
;
}
case
"
TranslationsPort
:
TranslationRequest
"
:
{
const
{
translationId
sourceText
}
=
message
;
const
translatedDoc
=
parser
.
parseFromString
(
sourceText
"
text
/
html
"
)
;
transformNode
(
translatedDoc
.
body
)
;
if
(
delay
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
delay
)
)
;
}
mockedPort
.
onmessage
(
{
data
:
{
type
:
"
TranslationsPort
:
TranslationResponse
"
targetText
:
translatedDoc
.
body
.
innerHTML
translationId
}
}
)
;
break
;
}
default
:
{
throw
new
Error
(
"
Unexpected
mock
translator
message
:
"
message
.
type
)
;
}
}
}
}
;
return
mockedPort
;
}
class
TranslationResolver
{
resolvers
=
Promise
.
withResolvers
(
)
;
resolveCount
=
0
;
getPromise
(
)
{
return
this
.
resolvers
.
promise
;
}
}
function
createControlledTranslatorPort
(
)
{
const
parser
=
new
DOMParser
(
)
;
const
canceledTranslations
=
new
Set
(
)
;
let
resolvers
=
[
]
;
let
engineStatusCount
=
0
;
let
cancelCount
=
0
;
let
passthroughCount
=
0
;
let
cachedCount
=
0
;
let
requestCount
=
0
;
function
resolveRequests
(
)
{
const
resolvedCount
=
resolvers
.
length
;
let
resolver
=
resolvers
.
pop
(
)
;
while
(
resolver
)
{
let
{
translationId
resolve
debugText
}
=
resolver
;
info
(
Resolving
promise
for
request
(
id
:
{
translationId
}
)
:
{
debugText
}
)
;
resolve
(
)
;
resolver
=
resolvers
.
pop
(
)
;
}
return
resolvedCount
;
}
function
resetPortData
(
)
{
if
(
resolveRequests
(
)
>
0
)
{
throw
new
Error
(
"
Attempt
to
collect
port
data
with
pending
translation
requests
.
"
)
;
}
engineStatusCount
=
0
;
cancelCount
=
0
;
passthroughCount
=
0
;
cachedCount
=
0
;
requestCount
=
0
;
}
function
collectPortData
(
resetCounters
=
true
)
{
info
(
"
Collecting
data
from
port
messages
"
)
;
const
portData
=
{
engineStatusCount
cancelCount
passthroughCount
cachedCount
requestCount
}
;
if
(
resetCounters
)
{
resetPortData
(
)
;
}
return
portData
;
}
const
mockedTranslatorPort
=
{
async
postMessage
(
message
)
{
switch
(
message
.
type
)
{
case
"
TranslationsPort
:
GetEngineStatusRequest
"
:
{
engineStatusCount
+
+
;
mockedTranslatorPort
.
onmessage
(
{
data
:
{
type
:
"
TranslationsPort
:
GetEngineStatusResponse
"
status
:
"
ready
"
}
}
)
;
break
;
}
case
"
TranslationsPort
:
CancelSingleTranslation
"
:
{
cancelCount
+
+
;
info
(
"
Canceling
translation
id
:
"
+
message
.
translationId
)
;
canceledTranslations
.
add
(
message
.
translationId
)
;
break
;
}
case
"
TranslationsPort
:
Passthrough
"
:
{
passthroughCount
+
+
;
const
{
translationId
}
=
message
;
let
debugText
=
null
;
info
(
Translation
requested
for
(
id
:
{
translationId
}
)
:
"
{
debugText
}
"
)
;
const
{
promise
resolve
}
=
Promise
.
withResolvers
(
)
;
resolvers
.
push
(
{
translationId
resolve
debugText
}
)
;
info
(
Waiting
for
promise
for
(
id
:
{
translationId
}
)
to
resolve
:
"
{
debugText
}
)
;
await
promise
;
info
(
Promise
for
(
id
:
{
translationId
}
)
resolved
:
"
{
debugText
}
)
;
mockedTranslatorPort
.
onmessage
(
{
data
:
{
type
:
"
TranslationsPort
:
TranslationResponse
"
translationId
targetText
:
null
}
}
)
;
break
;
}
case
"
TranslationsPort
:
CachedTranslation
"
:
{
cachedCount
+
+
;
const
{
cachedTranslation
translationId
}
=
message
;
let
debugText
=
cachedTranslation
.
trim
(
)
.
replaceAll
(
"
\
n
"
"
"
)
;
if
(
debugText
.
length
>
50
)
{
debugText
=
debugText
.
slice
(
0
50
)
+
"
.
.
.
"
;
}
info
(
Translation
requested
for
(
id
:
{
translationId
}
)
:
"
{
debugText
}
"
)
;
const
{
promise
resolve
}
=
Promise
.
withResolvers
(
)
;
resolvers
.
push
(
{
translationId
resolve
debugText
}
)
;
info
(
Waiting
for
promise
for
(
id
:
{
translationId
}
)
to
resolve
:
"
{
debugText
}
)
;
await
promise
;
info
(
Promise
for
(
id
:
{
translationId
}
)
resolved
:
"
{
debugText
}
)
;
mockedTranslatorPort
.
onmessage
(
{
data
:
{
type
:
"
TranslationsPort
:
TranslationResponse
"
translationId
targetText
:
cachedTranslation
}
}
)
;
break
;
}
case
"
TranslationsPort
:
TranslationRequest
"
:
{
requestCount
+
+
;
const
{
translationId
sourceText
}
=
message
;
let
debugText
=
sourceText
.
trim
(
)
.
replaceAll
(
"
\
n
"
"
"
)
;
if
(
debugText
.
length
>
50
)
{
debugText
=
debugText
.
slice
(
0
50
)
+
"
.
.
.
"
;
}
info
(
Translation
requested
for
(
id
:
{
translationId
}
)
:
"
{
debugText
}
"
)
;
const
{
promise
resolve
}
=
Promise
.
withResolvers
(
)
;
resolvers
.
push
(
{
translationId
resolve
debugText
}
)
;
info
(
Waiting
for
promise
for
(
id
:
{
translationId
}
)
to
resolve
:
"
{
debugText
}
)
;
await
promise
;
info
(
Promise
for
(
id
:
{
translationId
}
)
resolved
:
"
{
debugText
}
)
;
if
(
canceledTranslations
.
has
(
translationId
)
)
{
info
(
Cancelled
translation
for
request
(
id
:
{
translationId
}
)
)
;
}
else
{
info
(
Translation
completed
for
request
(
id
:
{
translationId
}
)
)
;
const
translatedDoc
=
parser
.
parseFromString
(
sourceText
"
text
/
html
"
)
;
diacriticizeNode
(
translatedDoc
.
body
)
;
const
targetText
=
translatedDoc
.
body
.
innerHTML
.
trim
(
)
+
(
id
:
{
translationId
}
)
;
info
(
"
Translation
response
:
"
+
targetText
.
replaceAll
(
"
\
n
"
"
"
)
)
;
mockedTranslatorPort
.
onmessage
(
{
data
:
{
type
:
"
TranslationsPort
:
TranslationResponse
"
targetText
translationId
}
}
)
;
}
}
}
}
}
;
return
{
mockedTranslatorPort
resolveRequests
collectPortData
}
;
}
const
{
TranslationsDocument
LRUCache
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
global
/
content
/
translations
/
translations
-
document
.
sys
.
mjs
"
)
;
async
function
createTranslationsDoc
(
html
options
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
translations
.
enable
"
true
]
[
"
browser
.
translations
.
logLevel
"
"
All
"
]
[
USE_LEXICAL_SHORTLIST_PREF
false
]
]
}
)
;
const
parser
=
new
DOMParser
(
)
;
const
document
=
parser
.
parseFromString
(
html
"
text
/
html
"
)
;
document
.
body
.
style
.
display
=
"
block
"
;
let
translationsDoc
=
null
;
const
translate
=
(
)
=
>
{
info
(
"
Creating
the
TranslationsDocument
.
"
)
;
translationsDoc
=
new
TranslationsDocument
(
document
"
en
"
"
EN
"
0
options
?
.
mockedTranslatorPort
?
?
createMockedTranslatorPort
(
)
(
)
=
>
{
throw
new
Error
(
"
Cannot
request
a
new
port
"
)
;
}
options
?
.
mockedReportVisibleChange
?
?
(
(
)
=
>
{
}
)
new
LRUCache
(
)
false
)
;
translationsDoc
.
simulateIntersectionObservationForNonPendingNodes
(
)
;
return
translationsDoc
;
}
;
function
expectedHtmlToRegex
(
html
)
{
const
ESCAPABLE_CHARACTERS
=
/
[
.
*
+
?
^
{
}
(
)
|
[
\
]
\
\
]
/
g
;
const
REGEX_LITERAL
=
/
\
{
\
{
(
.
*
?
)
\
}
\
}
/
gsu
;
const
ESCAPED_REGEX_LITERAL
=
/
\
\
\
{
\
\
\
{
.
*
?
\
\
\
}
\
\
\
}
/
su
;
const
regexLiterals
=
[
.
.
.
html
.
matchAll
(
REGEX_LITERAL
)
]
.
map
(
match
=
>
match
[
1
]
)
;
let
pattern
=
html
.
replaceAll
(
ESCAPABLE_CHARACTERS
"
\
\
&
"
)
.
replaceAll
(
/
\
s
*
<
/
g
"
\
\
s
*
<
"
)
.
replaceAll
(
/
>
\
s
*
/
g
"
>
\
\
s
*
"
)
.
replaceAll
(
/
\
s
\
s
+
/
g
"
\
\
s
+
"
)
.
replace
(
/
^
\
\
s
\
+
/
"
\
\
s
*
"
)
.
replace
(
/
\
\
s
\
+
/
"
\
\
s
*
"
)
;
for
(
const
regexLiteral
of
regexLiterals
)
{
pattern
=
pattern
.
replace
(
ESCAPED_REGEX_LITERAL
regexLiteral
.
trim
(
)
)
;
}
return
new
RegExp
(
^
{
pattern
}
"
su
"
)
;
}
async
function
htmlMatches
(
message
expectedHtml
sourceDoc
=
document
resolveRequests
)
{
const
prettyHtml
=
naivelyPrettify
(
expectedHtml
)
;
const
expected
=
expectedHtmlToRegex
(
expectedHtml
)
;
let
didSimulateIntersectionObservation
=
false
;
try
{
await
waitForCondition
(
async
(
)
=
>
{
await
waitForCondition
(
(
)
=
>
!
translationsDoc
.
hasPendingCallbackOnEventLoop
(
)
)
;
while
(
translationsDoc
.
hasPendingCallbackOnEventLoop
(
)
|
|
translationsDoc
.
hasPendingTranslationRequests
(
)
)
{
if
(
resolveRequests
)
{
await
waitForCondition
(
(
)
=
>
resolveRequests
(
)
|
|
(
!
translationsDoc
.
hasPendingCallbackOnEventLoop
(
)
&
&
!
translationsDoc
.
hasPendingTranslationRequests
(
)
)
"
Manually
resolving
requests
as
they
come
in
.
.
.
"
)
;
}
else
{
await
waitForCondition
(
(
)
=
>
!
translationsDoc
.
hasPendingCallbackOnEventLoop
(
)
&
&
!
translationsDoc
.
hasPendingTranslationRequests
(
)
"
Waiting
for
all
requests
to
come
in
.
.
.
"
)
;
}
}
await
waitForCondition
(
(
)
=
>
!
translationsDoc
.
hasPendingCallbackOnEventLoop
(
)
)
;
const
actualHtml
=
naivelyPrettify
(
sourceDoc
.
body
.
innerHTML
)
;
const
htmlMatches
=
expected
.
test
(
actualHtml
)
;
if
(
!
htmlMatches
&
&
!
didSimulateIntersectionObservation
)
{
didSimulateIntersectionObservation
=
true
;
translationsDoc
.
simulateIntersectionObservationForNonPendingNodes
(
)
;
}
if
(
htmlMatches
)
{
await
waitForCondition
(
(
)
=
>
!
translationsDoc
.
hasPendingCallbackOnEventLoop
(
)
&
&
!
translationsDoc
.
hasPendingTranslationRequests
(
)
&
&
!
translationsDoc
.
isObservingAnyElementForContentIntersection
(
)
&
&
!
translationsDoc
.
isObservingAnyElementForAttributeIntersection
(
)
"
Ensuring
that
the
entire
document
is
translated
.
"
)
;
}
return
htmlMatches
;
}
"
Waiting
for
HTML
to
match
.
"
)
;
ok
(
true
message
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
const
actual
=
naivelyPrettify
(
sourceDoc
.
body
.
innerHTML
)
;
ok
(
false
{
message
}
\
n
\
nExpected
HTML
:
\
n
\
n
{
prettyHtml
}
\
n
\
nActual
HTML
:
\
n
\
n
{
actual
}
\
n
\
n
{
String
(
error
)
}
)
;
}
}
function
cleanup
(
)
{
SpecialPowers
.
popPrefEnv
(
)
;
}
return
{
htmlMatches
cleanup
translate
document
}
;
}
function
doubleRaf
(
doc
)
{
return
new
Promise
(
resolve
=
>
{
doc
.
ownerGlobal
.
requestAnimationFrame
(
(
)
=
>
{
doc
.
ownerGlobal
.
requestAnimationFrame
(
(
)
=
>
{
resolve
(
TestUtils
.
waitForTick
(
)
)
;
}
)
;
}
)
;
}
)
;
}
function
createBatchedMockedTranslatorPort
(
)
{
let
letter
=
"
a
"
;
function
transformNode
(
node
)
{
if
(
typeof
node
.
nodeValue
=
=
=
"
string
"
)
{
node
.
nodeValue
=
node
.
nodeValue
.
replace
(
/
\
w
/
g
letter
)
;
}
for
(
const
childNode
of
node
.
childNodes
)
{
transformNode
(
childNode
)
;
}
}
return
createMockedTranslatorPort
(
node
=
>
{
transformNode
(
node
)
;
letter
=
String
.
fromCodePoint
(
letter
.
codePointAt
(
0
)
+
1
)
;
}
)
;
}
function
createdReorderingMockedTranslatorPort
(
)
{
function
transformNode
(
node
)
{
if
(
typeof
node
.
nodeValue
=
=
=
"
string
"
)
{
node
.
nodeValue
=
node
.
nodeValue
.
toUpperCase
(
)
;
}
const
nodes
=
[
.
.
.
node
.
childNodes
]
;
nodes
.
sort
(
(
a
b
)
=
>
(
a
.
textContent
?
.
trim
(
)
?
?
"
"
)
.
localeCompare
(
b
.
textContent
?
.
trim
(
)
?
?
"
"
)
)
;
for
(
const
childNode
of
nodes
)
{
childNode
.
remove
(
)
;
}
for
(
const
childNode
of
nodes
)
{
node
.
appendChild
(
childNode
)
;
transformNode
(
childNode
)
;
}
}
return
createMockedTranslatorPort
(
transformNode
)
;
}
function
getTranslationsParent
(
win
=
window
)
{
return
TranslationsParent
.
getTranslationsActor
(
win
.
gBrowser
.
selectedBrowser
)
;
}
async
function
closeAllOpenPanelsAndMenus
(
win
)
{
await
closeFullPagePanelSettingsMenuIfOpen
(
win
)
;
await
closeFullPageTranslationsPanelIfOpen
(
win
)
;
await
closeSelectPanelSettingsMenuIfOpen
(
win
)
;
await
closeSelectTranslationsPanelIfOpen
(
win
)
;
await
closeContextMenuIfOpen
(
win
)
;
}
async
function
closePopupIfOpen
(
popupElementId
win
=
window
)
{
await
waitForCondition
(
async
(
)
=
>
{
const
popupElement
=
win
.
document
.
getElementById
(
popupElementId
)
;
if
(
!
popupElement
)
{
return
true
;
}
if
(
popupElement
.
state
=
=
=
"
closed
"
)
{
return
true
;
}
let
popuphiddenPromise
=
BrowserTestUtils
.
waitForEvent
(
popupElement
"
popuphidden
"
)
;
popupElement
.
hidePopup
(
)
;
PanelMultiView
.
hidePopup
(
popupElement
)
;
await
popuphiddenPromise
;
return
false
;
}
)
;
}
async
function
closeContextMenuIfOpen
(
win
)
{
await
closePopupIfOpen
(
"
contentAreaContextMenu
"
win
)
;
}
async
function
closeFullPagePanelSettingsMenuIfOpen
(
win
)
{
await
closePopupIfOpen
(
"
full
-
page
-
translations
-
panel
-
settings
-
menupopup
"
win
)
;
}
async
function
closeSelectPanelSettingsMenuIfOpen
(
win
)
{
await
closePopupIfOpen
(
"
select
-
translations
-
panel
-
settings
-
menupopup
"
win
)
;
}
async
function
closeFullPageTranslationsPanelIfOpen
(
win
)
{
await
closePopupIfOpen
(
"
full
-
page
-
translations
-
panel
"
win
)
;
}
async
function
closeSelectTranslationsPanelIfOpen
(
win
)
{
await
closePopupIfOpen
(
"
select
-
translations
-
panel
"
win
)
;
}
async
function
setupActorTest
(
{
languagePairs
prefs
autoDownloadFromRemoteSettings
=
false
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
translations
.
enable
"
true
]
[
"
browser
.
translations
.
logLevel
"
"
All
"
]
[
USE_LEXICAL_SHORTLIST_PREF
false
]
.
.
.
(
prefs
?
?
[
]
)
]
}
)
;
const
{
remoteClients
removeMocks
}
=
await
createAndMockRemoteSettings
(
{
languagePairs
autoDownloadFromRemoteSettings
}
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
ENGLISH_PAGE_URL
true
)
;
const
actor
=
getTranslationsParent
(
)
;
return
{
actor
remoteClients
async
cleanup
(
)
{
await
closeAllOpenPanelsAndMenus
(
)
;
await
loadBlankPage
(
)
;
await
EngineProcess
.
destroyTranslationsEngine
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
removeMocks
(
)
;
TestTranslationsTelemetry
.
reset
(
)
;
return
SpecialPowers
.
popPrefEnv
(
)
;
}
}
;
}
async
function
createAndMockRemoteSettings
(
{
languagePairs
=
LANGUAGE_PAIRS
useMockedTranslator
=
true
autoDownloadFromRemoteSettings
=
false
}
)
{
if
(
TranslationsParent
.
isTranslationsEngineMocked
(
)
)
{
info
(
"
Attempt
to
mock
the
Translations
Engine
when
it
is
already
mocked
.
"
)
;
}
const
remoteClients
=
{
translationModels
:
await
createTranslationModelsRemoteClient
(
autoDownloadFromRemoteSettings
languagePairs
)
translationsWasm
:
await
createTranslationsWasmRemoteClient
(
autoDownloadFromRemoteSettings
)
}
;
TranslationsParent
.
clearCache
(
)
;
TranslationsPanelShared
.
clearLanguageListsCache
(
)
;
TranslationsParent
.
applyTestingMocks
(
{
useMockedTranslator
translationModelsRemoteClient
:
remoteClients
.
translationModels
.
client
translationsWasmRemoteClient
:
remoteClients
.
translationsWasm
.
client
}
)
;
return
{
async
removeMocks
(
)
{
await
remoteClients
.
translationModels
.
client
.
attachments
.
deleteAll
(
)
;
await
remoteClients
.
translationModels
.
client
.
db
.
clear
(
)
;
await
remoteClients
.
translationsWasm
.
client
.
db
.
clear
(
)
;
TranslationsParent
.
removeTestingMocks
(
)
;
TranslationsParent
.
clearCache
(
)
;
TranslationsPanelShared
.
clearLanguageListsCache
(
)
;
}
remoteClients
}
;
}
function
normalizePathForOS
(
path
)
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
)
{
return
path
.
replace
(
/
\
/
/
g
"
\
\
"
)
;
}
return
path
.
replace
(
/
\
\
/
g
"
/
"
)
;
}
async
function
pathExists
(
path
)
{
try
{
return
await
IOUtils
.
exists
(
path
)
;
}
catch
(
e
)
{
return
false
;
}
}
async
function
createFileSystemRemoteSettings
(
languagePairs
architecture
)
{
const
{
removeMocks
remoteClients
}
=
await
createAndMockRemoteSettings
(
{
languagePairs
useMockedTranslator
:
false
autoDownloadFromRemoteSettings
:
true
}
)
;
const
artifactDirectory
=
normalizePathForOS
(
{
Services
.
env
.
get
(
"
MOZ_FETCHES_DIR
"
)
}
)
;
if
(
!
artifactDirectory
)
{
await
removeMocks
(
)
;
throw
new
Error
(
The
MOZ_FETCHES_DIR
environment
variable
is
not
set
If
you
are
running
a
Translations
end
-
to
-
end
test
locally
you
will
need
to
download
the
required
artifacts
to
MOZ_FETCHES_DIR
.
To
configure
MOZ_FETCHES_DIR
to
run
Translations
end
-
to
-
end
tests
locally
please
run
the
following
script
:
python3
toolkit
/
components
/
translations
/
tests
/
scripts
/
download
-
translations
-
artifacts
.
py
)
;
}
if
(
!
PathUtils
.
isAbsolute
(
artifactDirectory
)
)
{
await
removeMocks
(
)
;
throw
new
Error
(
The
path
exported
to
MOZ_FETCHES_DIR
environment
variable
is
a
relative
path
.
Please
export
an
absolute
path
to
MOZ_FETCHES_DIR
.
)
;
}
const
download
=
async
record
=
>
{
const
recordPath
=
normalizePathForOS
(
record
.
name
=
=
=
"
bergamot
-
translator
"
?
{
artifactDirectory
}
/
{
record
.
name
}
.
zst
:
{
artifactDirectory
}
/
{
architecture
}
.
{
record
.
name
}
.
zst
)
;
if
(
!
(
await
pathExists
(
recordPath
)
)
)
{
throw
new
Error
(
The
record
{
record
.
name
}
was
not
found
in
{
artifactDirectory
}
specified
by
MOZ_FETCHES_DIR
at
the
expected
path
:
{
recordPath
}
If
you
are
running
a
Translations
end
-
to
-
end
test
locally
you
will
need
to
download
the
required
artifacts
to
MOZ_FETCHES_DIR
.
To
configure
MOZ_FETCHES_DIR
to
run
Translations
end
-
to
-
end
tests
locally
please
run
toolkit
/
components
/
translations
/
tests
/
scripts
/
download
-
translations
-
artifacts
.
py
)
;
}
const
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
recordPath
)
;
return
{
blob
:
await
File
.
createFromNsIFile
(
file
)
}
;
}
;
remoteClients
.
translationsWasm
.
client
.
attachments
.
download
=
download
;
remoteClients
.
translationModels
.
client
.
attachments
.
download
=
download
;
return
{
removeMocks
remoteClients
}
;
}
class
MockedA11yUtils
{
static
announceCalls
=
[
]
;
static
mockForWindow
(
window
)
{
const
realA11yUtils
=
window
.
A11yUtils
;
window
.
A11yUtils
=
MockedA11yUtils
;
return
(
)
=
>
{
MockedA11yUtils
.
announceCalls
=
[
]
;
window
.
A11yUtils
=
realA11yUtils
;
}
;
}
static
announce
(
{
id
raw
}
)
{
MockedA11yUtils
.
announceCalls
.
push
(
{
id
raw
}
)
;
}
static
assertMostRecentAnnounceCall
(
{
expectedCallNumber
expectedArgs
}
)
{
is
(
MockedA11yUtils
.
announceCalls
.
length
expectedCallNumber
"
The
most
recent
A11yUtils
announce
should
match
the
expected
call
number
.
"
)
;
const
{
id
raw
}
=
MockedA11yUtils
.
announceCalls
.
at
(
-
1
)
;
const
{
id
:
expectedId
raw
:
expectedRaw
}
=
expectedArgs
;
is
(
id
expectedId
"
A11yUtils
announce
arg
id
should
match
the
expected
arg
id
.
"
)
;
is
(
raw
expectedRaw
"
A11yUtils
announce
arg
raw
should
match
the
expected
arg
raw
.
"
)
;
}
}
async
function
ensureWindowSize
(
win
width
height
)
{
if
(
Math
.
abs
(
win
.
outerWidth
-
width
)
<
1
&
&
Math
.
abs
(
win
.
outerHeight
-
height
)
<
1
)
{
return
;
}
const
resizePromise
=
BrowserTestUtils
.
waitForEvent
(
win
"
resize
"
)
;
win
.
resizeTo
(
width
height
)
;
await
resizePromise
;
}
async
function
loadTestPage
(
{
languagePairs
endToEndTest
=
false
autoDownloadFromRemoteSettings
=
false
page
prefs
autoOffer
permissionsUrls
systemLocales
=
[
"
en
"
]
appLocales
webLanguages
architecture
contentEagerMode
=
false
win
=
window
}
)
{
info
(
Loading
test
page
starting
at
url
:
{
page
}
)
;
const
isFirstTimeSetup
=
win
=
=
=
window
;
let
remoteClients
=
null
;
let
removeMocks
=
(
)
=
>
{
}
;
const
restoreA11yUtils
=
MockedA11yUtils
.
mockForWindow
(
win
)
;
if
(
isFirstTimeSetup
)
{
await
ensureWindowSize
(
win
1000
600
)
;
await
EngineProcess
.
destroyTranslationsEngine
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
translations
.
enable
"
true
]
[
"
browser
.
translations
.
logLevel
"
"
All
"
]
[
"
browser
.
translations
.
automaticallyPopup
"
true
]
[
"
browser
.
translations
.
alwaysTranslateLanguages
"
"
"
]
[
"
browser
.
translations
.
neverTranslateLanguages
"
"
"
]
[
"
browser
.
translations
.
mostRecentTargetLanguages
"
"
"
]
[
USE_LEXICAL_SHORTLIST_PREF
false
]
[
"
accessibility
.
tabfocus_applies_to_xul
"
false
]
.
.
.
(
prefs
?
?
[
]
)
]
}
)
;
await
SpecialPowers
.
pushPermissions
(
[
ENGLISH_PAGE_URL
FRENCH_PAGE_URL
NO_LANGUAGE_URL
SPANISH_PAGE_URL
SPANISH_PAGE_URL_2
SPANISH_PAGE_URL_DOT_ORG
.
.
.
(
permissionsUrls
|
|
[
]
)
]
.
map
(
url
=
>
(
{
type
:
TRANSLATIONS_PERMISSION
allow
:
true
context
:
url
}
)
)
)
;
const
result
=
endToEndTest
?
await
createFileSystemRemoteSettings
(
languagePairs
architecture
)
:
await
createAndMockRemoteSettings
(
{
languagePairs
autoDownloadFromRemoteSettings
}
)
;
remoteClients
=
result
.
remoteClients
;
removeMocks
=
result
.
removeMocks
;
}
if
(
autoOffer
)
{
TranslationsParent
.
testAutomaticPopup
=
true
;
}
let
cleanupLocales
;
if
(
systemLocales
|
|
appLocales
|
|
webLanguages
)
{
cleanupLocales
=
await
mockLocales
(
{
systemLocales
appLocales
webLanguages
}
)
;
}
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
win
.
gBrowser
BLANK_PAGE
true
)
;
if
(
contentEagerMode
)
{
info
(
"
Triggering
content
-
eager
translations
mode
by
opening
the
find
bar
.
"
)
;
await
openFindBar
(
tab
)
;
await
loadNewPage
(
tab
.
linkedBrowser
BLANK_PAGE_URL
)
;
const
actor
=
getTranslationsParent
(
win
)
;
await
waitForCondition
(
(
)
=
>
actor
.
findBar
"
Waiting
for
the
TranslationsParent
actor
to
register
its
findBar
"
)
;
}
await
loadNewPage
(
tab
.
linkedBrowser
page
)
;
if
(
autoOffer
&
&
TranslationsParent
.
shouldAlwaysOfferTranslations
(
)
)
{
info
(
"
Waiting
for
the
popup
to
be
automatically
shown
.
"
)
;
await
waitForCondition
(
(
)
=
>
{
const
panel
=
document
.
getElementById
(
"
full
-
page
-
translations
-
panel
"
)
;
return
panel
&
&
panel
.
state
=
=
=
"
open
"
;
}
)
;
}
return
{
tab
remoteClients
async
resolveDownloads
(
count
)
{
await
remoteClients
.
translationsWasm
.
resolvePendingDownloads
(
1
)
;
await
remoteClients
.
translationModels
.
resolvePendingDownloads
(
downloadedFilesPerLanguagePair
(
)
*
count
)
;
}
async
rejectDownloads
(
count
)
{
await
remoteClients
.
translationsWasm
.
rejectPendingDownloads
(
1
)
;
await
remoteClients
.
translationModels
.
rejectPendingDownloads
(
downloadedFilesPerLanguagePair
(
)
*
count
)
;
}
async
resolveBulkDownloads
(
{
expectedWasmDownloads
expectedLanguagePairDownloads
}
)
{
await
remoteClients
.
translationsWasm
.
resolvePendingDownloads
(
expectedWasmDownloads
)
;
await
remoteClients
.
translationModels
.
resolvePendingDownloads
(
downloadedFilesPerLanguagePair
(
)
*
expectedLanguagePairDownloads
)
;
}
async
rejectBulkDownloads
(
{
expectedWasmDownloads
expectedLanguagePairDownloads
}
)
{
await
remoteClients
.
translationsWasm
.
rejectPendingDownloads
(
expectedWasmDownloads
)
;
await
remoteClients
.
translationModels
.
rejectPendingDownloads
(
downloadedFilesPerLanguagePair
(
)
*
expectedLanguagePairDownloads
)
;
}
async
cleanup
(
)
{
await
closeAllOpenPanelsAndMenus
(
)
;
await
loadBlankPage
(
)
;
await
EngineProcess
.
destroyTranslationsEngine
(
)
;
await
removeMocks
(
)
;
if
(
cleanupLocales
)
{
await
cleanupLocales
(
)
;
}
restoreA11yUtils
(
)
;
Services
.
fog
.
testResetFOG
(
)
;
TranslationsParent
.
testAutomaticPopup
=
false
;
TranslationsParent
.
resetHostsOffered
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
TestTranslationsTelemetry
.
reset
(
)
;
return
Promise
.
all
(
[
SpecialPowers
.
popPrefEnv
(
)
SpecialPowers
.
popPermissions
(
)
]
)
;
}
runInPage
(
callback
data
=
{
}
)
{
return
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
contentData
:
data
callbackSource
:
callback
.
toString
(
)
}
function
(
{
contentData
callbackSource
}
)
{
const
TranslationsTest
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
components
/
translations
/
tests
/
browser
/
translations
-
test
.
mjs
"
)
;
TranslationsTest
.
setup
(
{
Assert
ContentTaskUtils
content
}
)
;
let
contentCallback
=
eval
(
(
{
callbackSource
}
)
)
;
return
contentCallback
(
TranslationsTest
contentData
)
;
}
)
;
}
}
;
}
async
function
captureTranslationsError
(
callback
)
{
const
{
reportError
}
=
TranslationsParent
;
let
errors
=
[
]
;
TranslationsParent
.
reportError
=
(
error
.
.
.
args
)
=
>
{
errors
.
push
(
{
error
args
}
)
;
}
;
await
callback
(
)
;
TranslationsParent
.
reportError
=
reportError
;
return
errors
;
}
async
function
openFindBar
(
tab
win
=
window
)
{
info
(
"
Opening
the
find
bar
in
the
current
tab
.
"
)
;
const
findBar
=
await
win
.
gBrowser
.
getFindBar
(
tab
)
;
const
{
promise
resolve
}
=
Promise
.
withResolvers
(
)
;
findBar
.
addEventListener
(
"
findbaropen
"
(
)
=
>
{
resolve
(
)
;
}
{
once
:
true
}
)
;
findBar
.
open
(
)
;
await
promise
;
}
async
function
closeFindBar
(
tab
win
=
window
)
{
info
(
"
Closing
the
find
bar
in
the
current
tab
.
"
)
;
const
findBar
=
await
win
.
gBrowser
.
getFindBar
(
tab
)
;
const
{
promise
resolve
}
=
Promise
.
withResolvers
(
)
;
findBar
.
addEventListener
(
"
findbarclose
"
(
)
=
>
{
resolve
(
)
;
}
{
once
:
true
}
)
;
findBar
.
close
(
)
;
await
promise
;
}
async
function
autoTranslatePage
(
options
)
{
const
{
prefs
languagePairs
.
.
.
otherOptions
}
=
options
;
const
fromLangs
=
languagePairs
.
map
(
language
=
>
language
.
fromLang
)
.
join
(
"
"
)
;
const
{
cleanup
runInPage
}
=
await
loadTestPage
(
{
autoDownloadFromRemoteSettings
:
true
prefs
:
[
[
"
browser
.
translations
.
alwaysTranslateLanguages
"
fromLangs
]
.
.
.
(
prefs
?
?
[
]
)
]
.
.
.
otherOptions
}
)
;
await
runInPage
(
options
.
runInPage
)
;
await
cleanup
(
)
;
}
function
createAttachmentMock
(
client
mockedCollectionName
autoDownloadFromRemoteSettings
)
{
const
pendingDownloads
=
[
]
;
client
.
attachments
.
download
=
record
=
>
new
Promise
(
(
resolve
reject
)
=
>
{
console
.
log
(
"
Download
requested
:
"
client
.
collectionName
record
.
name
)
;
if
(
autoDownloadFromRemoteSettings
)
{
const
encoder
=
new
TextEncoder
(
)
;
const
{
buffer
}
=
encoder
.
encode
(
Mocked
download
:
{
mockedCollectionName
}
{
record
.
name
}
{
record
.
version
}
)
;
resolve
(
{
buffer
}
)
;
}
else
{
pendingDownloads
.
push
(
{
record
resolve
reject
}
)
;
}
}
)
;
function
resolvePendingDownloads
(
expectedDownloadCount
)
{
info
(
Resolving
{
expectedDownloadCount
}
mocked
downloads
for
"
{
client
.
collectionName
}
"
)
;
return
downloadHandler
(
expectedDownloadCount
download
=
>
download
.
resolve
(
{
buffer
:
new
ArrayBuffer
(
)
}
)
)
;
}
async
function
rejectPendingDownloads
(
expectedDownloadCount
)
{
info
(
Intentionally
rejecting
{
expectedDownloadCount
}
mocked
downloads
for
"
{
client
.
collectionName
}
"
)
;
const
attempts
=
TranslationsParent
.
MAX_DOWNLOAD_RETRIES
+
1
;
return
downloadHandler
(
expectedDownloadCount
*
attempts
download
=
>
download
.
reject
(
new
Error
(
"
Intentionally
rejecting
downloads
.
"
)
)
)
;
}
async
function
downloadHandler
(
expectedDownloadCount
action
)
{
const
names
=
[
]
;
let
maxTries
=
100
;
while
(
names
.
length
<
expectedDownloadCount
&
&
maxTries
-
-
>
0
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
let
download
=
pendingDownloads
.
shift
(
)
;
if
(
!
download
)
{
continue
;
}
console
.
log
(
Handling
download
:
client
.
collectionName
)
;
action
(
download
)
;
names
.
push
(
download
.
record
.
name
)
;
}
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
if
(
pendingDownloads
.
length
)
{
throw
new
Error
(
An
unexpected
download
was
found
only
expected
{
expectedDownloadCount
}
downloads
)
;
}
return
names
.
sort
(
(
a
b
)
=
>
a
.
localeCompare
(
b
)
)
;
}
async
function
assertNoNewDownloads
(
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
is
(
pendingDownloads
.
length
0
No
downloads
happened
for
"
{
client
.
collectionName
}
"
)
;
}
return
{
client
pendingDownloads
resolvePendingDownloads
rejectPendingDownloads
assertNoNewDownloads
}
;
}
const
RECORDS_PER_LANGUAGE_PAIR_SHARED_VOCAB
=
3
;
const
RECORDS_PER_LANGUAGE_PAIR_SPLIT_VOCAB
=
4
;
function
downloadedFilesPerLanguagePair
(
splitVocab
=
false
)
{
const
expectedRecords
=
splitVocab
?
RECORDS_PER_LANGUAGE_PAIR_SPLIT_VOCAB
:
RECORDS_PER_LANGUAGE_PAIR_SHARED_VOCAB
;
return
Services
.
prefs
.
getBoolPref
(
USE_LEXICAL_SHORTLIST_PREF
)
?
expectedRecords
:
expectedRecords
-
1
;
}
function
createRecordsForLanguagePair
(
fromLang
toLang
splitVocab
=
false
)
{
const
records
=
[
]
;
const
lang
=
fromLang
+
toLang
;
const
models
=
[
{
fileType
:
"
model
"
name
:
model
.
{
lang
}
.
intgemm
.
alphas
.
bin
}
{
fileType
:
"
lex
"
name
:
lex
.
50
.
50
.
{
lang
}
.
s2t
.
bin
}
.
.
.
(
splitVocab
?
[
{
fileType
:
"
srcvocab
"
name
:
srcvocab
.
{
lang
}
.
spm
}
{
fileType
:
"
trgvocab
"
name
:
trgvocab
.
{
lang
}
.
spm
}
]
:
[
{
fileType
:
"
vocab
"
name
:
vocab
.
{
lang
}
.
spm
}
]
)
]
;
const
attachment
=
{
hash
:
{
crypto
.
randomUUID
(
)
}
size
:
123
filename
:
model
.
{
lang
}
.
intgemm
.
alphas
.
bin
location
:
main
-
workspace
/
translations
-
models
/
{
crypto
.
randomUUID
(
)
}
.
bin
mimetype
:
"
application
/
octet
-
stream
"
isDownloaded
:
false
}
;
const
expectedLength
=
splitVocab
?
RECORDS_PER_LANGUAGE_PAIR_SPLIT_VOCAB
:
RECORDS_PER_LANGUAGE_PAIR_SHARED_VOCAB
;
is
(
models
.
length
expectedLength
"
The
number
of
records
per
language
pair
should
match
the
expected
length
.
"
)
;
for
(
const
{
fileType
name
}
of
models
)
{
records
.
push
(
{
id
:
crypto
.
randomUUID
(
)
name
sourceLanguage
:
fromLang
targetLanguage
:
toLang
fileType
version
:
TranslationsParent
.
LANGUAGE_MODEL_MAJOR_VERSION_MAX
+
"
.
0
"
last_modified
:
Date
.
now
(
)
schema
:
Date
.
now
(
)
attachment
:
JSON
.
parse
(
JSON
.
stringify
(
attachment
)
)
}
)
;
}
return
records
;
}
function
createWasmRecord
(
)
{
return
{
id
:
crypto
.
randomUUID
(
)
name
:
"
bergamot
-
translator
"
version
:
TranslationsParent
.
BERGAMOT_MAJOR_VERSION
+
"
.
0
"
last_modified
:
Date
.
now
(
)
schema
:
Date
.
now
(
)
}
;
}
let
_remoteSettingsMockId
=
0
;
async
function
createTranslationModelsRemoteClient
(
autoDownloadFromRemoteSettings
langPairs
)
{
const
records
=
[
]
;
for
(
const
{
fromLang
toLang
}
of
langPairs
)
{
records
.
push
(
.
.
.
createRecordsForLanguagePair
(
fromLang
toLang
)
)
;
}
const
{
RemoteSettings
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
sys
.
mjs
"
)
;
const
mockedCollectionName
=
"
test
-
translation
-
models
"
;
const
client
=
RemoteSettings
(
{
mockedCollectionName
}
-
{
_remoteSettingsMockId
+
+
}
)
;
const
metadata
=
{
}
;
await
client
.
db
.
clear
(
)
;
await
client
.
db
.
importChanges
(
metadata
Date
.
now
(
)
records
)
;
return
createAttachmentMock
(
client
mockedCollectionName
autoDownloadFromRemoteSettings
)
;
}
async
function
createTranslationsWasmRemoteClient
(
autoDownloadFromRemoteSettings
)
{
const
records
=
[
createWasmRecord
(
)
]
;
const
{
RemoteSettings
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
sys
.
mjs
"
)
;
const
mockedCollectionName
=
"
test
-
translation
-
wasm
"
;
const
client
=
RemoteSettings
(
{
mockedCollectionName
}
-
{
_remoteSettingsMockId
+
+
}
)
;
const
metadata
=
{
}
;
await
client
.
db
.
clear
(
)
;
await
client
.
db
.
importChanges
(
metadata
Date
.
now
(
)
records
)
;
return
createAttachmentMock
(
client
mockedCollectionName
autoDownloadFromRemoteSettings
)
;
}
async
function
modifyRemoteSettingsRecords
(
remoteSettingsClient
{
recordsToCreate
=
[
]
recordsToDelete
=
[
]
expectedCreatedRecordsCount
=
0
expectedUpdatedRecordsCount
=
0
expectedDeletedRecordsCount
=
0
}
)
{
for
(
const
recordToCreate
of
recordsToCreate
)
{
for
(
const
recordToDelete
of
recordsToDelete
)
{
isnot
(
recordToCreate
.
id
recordToDelete
.
id
Attempt
to
both
create
and
delete
the
same
record
from
Remote
Settings
database
:
'
{
recordToCreate
.
name
}
'
)
;
}
}
let
created
=
[
]
;
let
updated
=
[
]
;
let
deleted
=
[
]
;
const
existingRecords
=
await
remoteSettingsClient
.
get
(
)
;
for
(
const
newRecord
of
recordsToCreate
)
{
const
existingRecord
=
existingRecords
.
find
(
existingRecord
=
>
existingRecord
.
id
=
=
=
newRecord
.
id
)
;
if
(
existingRecord
)
{
updated
.
push
(
{
old
:
existingRecord
new
:
newRecord
}
)
;
}
else
{
created
.
push
(
newRecord
)
;
}
}
if
(
recordsToCreate
.
length
)
{
info
(
"
Storing
new
and
updated
records
in
mocked
Remote
Settings
database
"
)
;
await
remoteSettingsClient
.
db
.
importChanges
(
{
}
Date
.
now
(
)
recordsToCreate
)
;
}
if
(
recordsToDelete
.
length
)
{
info
(
"
Storing
new
and
updated
records
in
mocked
Remote
Settings
database
"
)
;
for
(
const
recordToDelete
of
recordsToDelete
)
{
ok
(
existingRecords
.
find
(
existingRecord
=
>
existingRecord
.
id
=
=
=
recordToDelete
.
id
)
The
record
to
delete
'
{
recordToDelete
.
name
}
'
should
be
found
in
the
database
.
)
;
await
remoteSettingsClient
.
db
.
delete
(
recordToDelete
.
id
)
;
deleted
.
push
(
recordToDelete
)
;
}
}
is
(
created
.
length
expectedCreatedRecordsCount
"
Expected
the
correct
number
of
created
records
"
)
;
is
(
updated
.
length
expectedUpdatedRecordsCount
"
Expected
the
correct
number
of
updated
records
"
)
;
is
(
deleted
.
length
expectedDeletedRecordsCount
"
Expected
the
correct
number
of
deleted
records
"
)
;
info
(
'
Emitting
a
remote
client
"
sync
"
event
.
'
)
;
await
remoteSettingsClient
.
emit
(
"
sync
"
{
data
:
{
created
updated
deleted
}
}
)
;
}
async
function
selectAboutPreferencesElements
(
)
{
const
document
=
gBrowser
.
selectedBrowser
.
contentDocument
;
const
settingsButton
=
document
.
getElementById
(
"
translations
-
manage
-
settings
-
button
"
)
;
const
rows
=
await
waitForCondition
(
(
)
=
>
{
const
elements
=
document
.
querySelectorAll
(
"
.
translations
-
manage
-
language
"
)
;
if
(
elements
.
length
!
=
=
4
)
{
return
false
;
}
return
elements
;
}
"
Waiting
for
manage
language
rows
.
"
)
;
const
[
downloadAllRow
frenchRow
spanishRow
ukrainianRow
]
=
rows
;
const
downloadAllLabel
=
downloadAllRow
.
querySelector
(
"
label
"
)
;
const
downloadAll
=
downloadAllRow
.
querySelector
(
"
#
translations
-
manage
-
install
-
all
"
)
;
const
deleteAll
=
downloadAllRow
.
querySelector
(
"
#
translations
-
manage
-
delete
-
all
"
)
;
const
frenchLabel
=
frenchRow
.
querySelector
(
"
label
"
)
;
const
frenchDownload
=
frenchRow
.
querySelector
(
[
data
-
l10n
-
id
=
"
translations
-
manage
-
language
-
download
-
button
"
]
)
;
const
frenchDelete
=
frenchRow
.
querySelector
(
[
data
-
l10n
-
id
=
"
translations
-
manage
-
language
-
remove
-
button
"
]
)
;
const
spanishLabel
=
spanishRow
.
querySelector
(
"
label
"
)
;
const
spanishDownload
=
spanishRow
.
querySelector
(
[
data
-
l10n
-
id
=
"
translations
-
manage
-
language
-
download
-
button
"
]
)
;
const
spanishDelete
=
spanishRow
.
querySelector
(
[
data
-
l10n
-
id
=
"
translations
-
manage
-
language
-
remove
-
button
"
]
)
;
const
ukrainianLabel
=
ukrainianRow
.
querySelector
(
"
label
"
)
;
const
ukrainianDownload
=
ukrainianRow
.
querySelector
(
[
data
-
l10n
-
id
=
"
translations
-
manage
-
language
-
download
-
button
"
]
)
;
const
ukrainianDelete
=
ukrainianRow
.
querySelector
(
[
data
-
l10n
-
id
=
"
translations
-
manage
-
language
-
remove
-
button
"
]
)
;
return
{
document
downloadAllLabel
downloadAll
deleteAll
frenchLabel
frenchDownload
frenchDelete
ukrainianLabel
ukrainianDownload
ukrainianDelete
settingsButton
spanishLabel
spanishDownload
spanishDelete
}
;
}
function
click
(
button
message
)
{
info
(
message
)
;
if
(
button
.
hidden
)
{
throw
new
Error
(
"
The
button
was
hidden
when
trying
to
click
it
.
"
)
;
}
button
.
click
(
)
;
}
function
hitEnterKey
(
button
message
)
{
info
(
message
)
;
button
.
dispatchEvent
(
new
KeyboardEvent
(
"
keypress
"
{
key
:
"
Enter
"
keyCode
:
KeyboardEvent
.
DOM_VK_RETURN
}
)
)
;
}
async
function
ensureVisibility
(
{
message
=
null
visible
=
{
}
hidden
=
{
}
}
)
{
try
{
await
waitForCondition
(
(
)
=
>
{
for
(
const
element
of
Object
.
values
(
visible
)
)
{
if
(
BrowserTestUtils
.
isHidden
(
element
)
)
{
return
false
;
}
}
for
(
const
element
of
Object
.
values
(
hidden
)
)
{
if
(
BrowserTestUtils
.
isVisible
(
element
)
)
{
return
false
;
}
}
return
true
;
}
)
;
}
catch
(
error
)
{
}
assertVisibility
(
{
message
visible
hidden
}
)
;
}
function
assertVisibility
(
{
message
=
null
visible
=
{
}
hidden
=
{
}
}
)
{
if
(
message
)
{
info
(
message
)
;
}
for
(
const
[
name
element
]
of
Object
.
entries
(
visible
)
)
{
ok
(
BrowserTestUtils
.
isVisible
(
element
)
{
name
}
is
visible
.
)
;
}
for
(
const
[
name
element
]
of
Object
.
entries
(
hidden
)
)
{
ok
(
BrowserTestUtils
.
isHidden
(
element
)
{
name
}
is
hidden
.
)
;
}
}
async
function
setupAboutPreferences
(
languagePairs
{
prefs
=
[
]
permissionsUrls
=
[
]
}
=
{
}
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
translations
.
enable
"
true
]
[
"
browser
.
translations
.
logLevel
"
"
All
"
]
[
USE_LEXICAL_SHORTLIST_PREF
false
]
.
.
.
prefs
]
}
)
;
await
SpecialPowers
.
pushPermissions
(
permissionsUrls
.
map
(
url
=
>
(
{
type
:
TRANSLATIONS_PERMISSION
allow
:
true
context
:
url
}
)
)
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
BLANK_PAGE
true
)
;
let
initTranslationsEvent
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
translations
.
newSettingsUI
.
enable
"
)
)
{
initTranslationsEvent
=
BrowserTestUtils
.
waitForEvent
(
document
"
translationsSettingsInit
"
)
;
}
const
{
remoteClients
removeMocks
}
=
await
createAndMockRemoteSettings
(
{
languagePairs
}
)
;
await
loadNewPage
(
tab
.
linkedBrowser
"
about
:
preferences
"
)
;
const
elements
=
await
selectAboutPreferencesElements
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
translations
.
newSettingsUI
.
enable
"
)
)
{
await
initTranslationsEvent
;
}
async
function
cleanup
(
)
{
Services
.
prefs
.
setCharPref
(
NEVER_TRANSLATE_LANGS_PREF
"
"
)
;
Services
.
prefs
.
setCharPref
(
ALWAYS_TRANSLATE_LANGS_PREF
"
"
)
;
Services
.
perms
.
removeAll
(
)
;
await
closeAllOpenPanelsAndMenus
(
)
;
await
loadBlankPage
(
)
;
await
EngineProcess
.
destroyTranslationsEngine
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
removeMocks
(
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
TestTranslationsTelemetry
.
reset
(
)
;
}
return
{
cleanup
remoteClients
elements
}
;
}
async
function
testWithAndWithoutLexicalShortlist
(
callback
)
{
for
(
const
prefs
of
[
[
[
USE_LEXICAL_SHORTLIST_PREF
true
]
]
[
[
USE_LEXICAL_SHORTLIST_PREF
false
]
]
]
)
{
await
callback
(
prefs
)
;
}
}
async
function
waitForTranslationModelRecordsChanged
(
callback
)
{
const
{
promise
resolve
}
=
Promise
.
withResolvers
(
)
;
function
onChange
(
)
{
Services
.
obs
.
removeObserver
(
onChange
"
translations
:
model
-
records
-
changed
"
)
;
resolve
(
)
;
}
Services
.
obs
.
addObserver
(
onChange
"
translations
:
model
-
records
-
changed
"
)
;
if
(
callback
)
{
await
callback
(
)
;
}
await
promise
;
}
function
waitForAppLocaleChanged
(
)
{
new
Promise
(
resolve
=
>
{
function
onChange
(
)
{
Services
.
obs
.
removeObserver
(
onChange
"
intl
:
app
-
locales
-
changed
"
)
;
resolve
(
)
;
}
Services
.
obs
.
addObserver
(
onChange
"
intl
:
app
-
locales
-
changed
"
)
;
}
)
;
}
async
function
mockLocales
(
{
systemLocales
appLocales
webLanguages
}
)
{
if
(
systemLocales
)
{
TranslationsParent
.
mockedSystemLocales
=
systemLocales
;
}
const
{
availableLocales
requestedLocales
}
=
Services
.
locale
;
if
(
appLocales
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
intl
.
locale
.
requested
"
"
en
"
]
]
}
)
;
const
appLocaleChanged
=
waitForAppLocaleChanged
(
)
;
info
(
"
Mocking
locales
so
expect
potential
.
ftl
resource
errors
.
"
)
;
Services
.
locale
.
availableLocales
=
appLocales
;
Services
.
locale
.
requestedLocales
=
appLocales
;
await
appLocaleChanged
;
}
if
(
webLanguages
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
intl
.
accept_languages
"
webLanguages
.
join
(
"
"
)
]
]
}
)
;
}
return
async
(
)
=
>
{
if
(
webLanguages
)
{
await
SpecialPowers
.
popPrefEnv
(
)
;
}
if
(
appLocales
)
{
const
appLocaleChanged
=
waitForAppLocaleChanged
(
)
;
Services
.
locale
.
availableLocales
=
availableLocales
;
Services
.
locale
.
requestedLocales
=
requestedLocales
;
await
appLocaleChanged
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
if
(
systemLocales
)
{
TranslationsParent
.
mockedSystemLocales
=
null
;
}
}
;
}
class
TestTranslationsTelemetry
{
static
#
previousFlowId
=
null
;
static
reset
(
)
{
TestTranslationsTelemetry
.
#
previousFlowId
=
null
;
}
static
async
assertCounter
(
name
counter
expectedCount
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
const
count
=
counter
.
testGetValue
(
)
?
?
0
;
is
(
count
expectedCount
Telemetry
counter
{
name
}
should
have
expected
count
)
;
}
static
async
assertLabeledCounter
(
counter
expectations
)
{
for
(
const
[
label
expectedCount
]
of
expectations
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
const
count
=
counter
[
label
]
.
testGetValue
(
)
?
?
0
;
is
(
count
expectedCount
Telemetry
counter
with
label
{
label
}
should
have
expected
count
.
)
;
}
}
static
async
assertEvent
(
event
{
expectedEventCount
expectNewFlowId
=
null
assertForAllEvents
=
{
}
assertForMostRecentEvent
=
{
}
}
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
const
events
=
event
.
testGetValue
(
)
?
?
[
]
;
const
eventCount
=
events
.
length
;
const
name
=
eventCount
>
0
?
{
events
[
0
]
.
category
}
.
{
events
[
0
]
.
name
}
:
null
;
if
(
eventCount
>
0
&
&
expectNewFlowId
!
=
=
null
)
{
const
flowId
=
events
[
eventCount
-
1
]
.
extra
.
flow_id
;
if
(
expectNewFlowId
)
{
is
(
events
[
eventCount
-
1
]
.
extra
.
flow_id
!
=
=
TestTranslationsTelemetry
.
#
previousFlowId
true
The
newest
flowId
{
flowId
}
should
be
different
than
the
previous
flowId
{
TestTranslationsTelemetry
.
#
previousFlowId
}
)
;
}
else
{
is
(
events
[
eventCount
-
1
]
.
extra
.
flow_id
=
=
=
TestTranslationsTelemetry
.
#
previousFlowId
true
The
newest
flowId
{
flowId
}
should
be
equal
to
the
previous
flowId
{
TestTranslationsTelemetry
.
#
previousFlowId
}
)
;
}
TestTranslationsTelemetry
.
#
previousFlowId
=
flowId
;
}
if
(
eventCount
!
=
=
expectedEventCount
)
{
console
.
error
(
"
Actual
events
:
"
events
)
;
}
is
(
eventCount
expectedEventCount
There
should
be
{
expectedEventCount
}
telemetry
events
of
type
{
name
}
)
;
if
(
Object
.
keys
(
assertForAllEvents
)
.
length
!
=
=
0
)
{
is
(
eventCount
>
0
true
Telemetry
event
{
name
}
should
contain
values
if
assertForMostRecentEvent
are
specified
)
;
for
(
const
[
key
expected
]
of
Object
.
entries
(
assertForAllEvents
)
)
{
for
(
const
event
of
events
)
{
if
(
typeof
expected
=
=
=
"
function
"
)
{
ok
(
expected
(
event
.
extra
[
key
]
)
Telemetry
event
{
name
}
value
for
{
key
}
should
match
the
expected
predicate
)
;
}
else
{
is
(
event
.
extra
[
key
]
String
(
expected
)
Telemetry
event
{
name
}
value
for
{
key
}
should
match
the
expected
entry
)
;
}
}
}
}
if
(
Object
.
keys
(
assertForMostRecentEvent
)
.
length
!
=
=
0
)
{
is
(
eventCount
>
0
true
Telemetry
event
{
name
}
should
contain
values
if
assertForMostRecentEvent
are
specified
)
;
for
(
const
[
key
expected
]
of
Object
.
entries
(
assertForMostRecentEvent
)
)
{
if
(
typeof
expected
=
=
=
"
function
"
)
{
ok
(
expected
(
events
[
eventCount
-
1
]
.
extra
[
key
]
)
Telemetry
event
{
name
}
value
for
{
key
}
should
match
the
expected
predicate
)
;
}
else
{
is
(
events
[
eventCount
-
1
]
.
extra
[
key
]
String
(
expected
)
Telemetry
event
{
name
}
value
for
{
key
}
should
match
the
expected
entry
)
;
}
}
}
}
static
async
assertRate
(
name
rate
{
expectedNumerator
expectedDenominator
}
)
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
const
{
numerator
=
0
denominator
=
0
}
=
rate
.
testGetValue
(
)
?
?
{
}
;
is
(
numerator
expectedNumerator
Telemetry
rate
{
name
}
should
have
expected
numerator
)
;
is
(
denominator
expectedDenominator
Telemetry
rate
{
name
}
should
have
expected
denominator
)
;
}
static
async
assertTranslationsEnginePerformance
(
{
expectedEventCount
}
)
{
info
(
"
Destroying
the
TranslationsEngine
.
"
)
;
await
EngineProcess
.
destroyTranslationsEngine
(
)
;
const
isNotEmptyString
=
entry
=
>
typeof
entry
=
=
=
"
string
"
&
&
entry
!
=
=
"
"
;
const
isGreaterThanZero
=
entry
=
>
parseFloat
(
entry
)
>
0
;
const
assertForAllEvents
=
expectedEventCount
=
=
=
0
?
{
}
:
{
from_language
:
isNotEmptyString
to_language
:
isNotEmptyString
average_words_per_request
:
isGreaterThanZero
average_words_per_second
:
isGreaterThanZero
total_completed_requests
:
isGreaterThanZero
total_inference_seconds
:
isGreaterThanZero
total_translated_words
:
isGreaterThanZero
}
;
await
TestTranslationsTelemetry
.
assertEvent
(
Glean
.
translations
.
enginePerformance
{
expectedEventCount
assertForAllEvents
}
)
;
}
}
function
waitForCondition
(
callback
message
)
{
const
interval
=
100
;
const
maxTries
=
50
*
4
;
return
TestUtils
.
waitForCondition
(
callback
message
interval
maxTries
)
;
}
function
getAlwaysTranslateLanguagesFromPref
(
)
{
let
langs
=
Services
.
prefs
.
getCharPref
(
ALWAYS_TRANSLATE_LANGS_PREF
)
;
return
langs
?
langs
.
split
(
"
"
)
:
[
]
;
}
function
getNeverTranslateLanguagesFromPref
(
)
{
let
langs
=
Services
.
prefs
.
getCharPref
(
NEVER_TRANSLATE_LANGS_PREF
)
;
return
langs
?
langs
.
split
(
"
"
)
:
[
]
;
}
function
getNeverTranslateSitesFromPerms
(
)
{
let
results
=
[
]
;
for
(
let
perm
of
Services
.
perms
.
all
)
{
if
(
perm
.
type
=
=
TRANSLATIONS_PERMISSION
&
&
perm
.
capability
=
=
Services
.
perms
.
DENY_ACTION
)
{
results
.
push
(
perm
.
principal
)
;
}
}
return
results
;
}
async
function
waitForOpenDialogWindow
(
dialogUrl
callback
)
{
const
dialogLoaded
=
promiseLoadSubDialog
(
dialogUrl
)
;
await
callback
(
)
;
const
dialogWindow
=
await
dialogLoaded
;
return
dialogWindow
;
}
async
function
waitForCloseDialogWindow
(
dialogWindow
)
{
const
closePromise
=
BrowserTestUtils
.
waitForEvent
(
content
.
gSubDialog
.
_dialogStack
"
dialogclose
"
)
;
dialogWindow
.
close
(
)
;
await
closePromise
;
}
function
promiseLoadSubDialog
(
aURL
)
{
return
new
Promise
(
resolve
=
>
{
content
.
gSubDialog
.
_dialogStack
.
addEventListener
(
"
dialogopen
"
function
dialogopen
(
aEvent
)
{
if
(
aEvent
.
detail
.
dialog
.
_frame
.
contentWindow
.
location
=
=
"
about
:
blank
"
)
{
return
;
}
content
.
gSubDialog
.
_dialogStack
.
removeEventListener
(
"
dialogopen
"
dialogopen
)
;
Assert
.
equal
(
aEvent
.
detail
.
dialog
.
_frame
.
contentWindow
.
location
.
toString
(
)
aURL
"
Check
the
proper
URL
is
loaded
"
)
;
isnot
(
aEvent
.
detail
.
dialog
.
_overlay
null
"
Element
should
not
be
null
when
checking
visibility
"
)
;
Assert
.
ok
(
!
BrowserTestUtils
.
isHidden
(
aEvent
.
detail
.
dialog
.
_overlay
)
"
The
element
is
visible
"
)
;
let
expectedStyleSheetURLs
=
aEvent
.
detail
.
dialog
.
_injectedStyleSheets
.
slice
(
0
)
;
for
(
let
styleSheet
of
aEvent
.
detail
.
dialog
.
_frame
.
contentDocument
.
styleSheets
)
{
let
i
=
expectedStyleSheetURLs
.
indexOf
(
styleSheet
.
href
)
;
if
(
i
>
=
0
)
{
info
(
"
found
"
+
styleSheet
.
href
)
;
expectedStyleSheetURLs
.
splice
(
i
1
)
;
}
}
Assert
.
equal
(
expectedStyleSheetURLs
.
length
0
"
All
expectedStyleSheetURLs
should
have
been
found
"
)
;
executeSoon
(
(
)
=
>
resolve
(
aEvent
.
detail
.
dialog
.
_frame
.
contentWindow
)
)
;
}
)
;
}
)
;
}
async
function
loadBlankPage
(
)
{
await
loadNewPage
(
gBrowser
.
selectedBrowser
BLANK_PAGE
)
;
}
async
function
destroyTranslationsEngine
(
)
{
await
EngineProcess
.
destroyTranslationsEngine
(
)
;
}
class
AboutTranslationsTestUtils
{
static
Events
=
class
Events
{
static
DetectedLanguageUpdated
=
"
AboutTranslationsTest
:
DetectedLanguageUpdated
"
;
static
SwapLanguagesButtonDisabled
=
"
AboutTranslationsTest
:
SwapLanguagesButtonDisabled
"
;
static
SwapLanguagesButtonEnabled
=
"
AboutTranslationsTest
:
SwapLanguagesButtonEnabled
"
;
static
ShowTranslatingPlaceholder
=
"
AboutTranslationsTest
:
ShowTranslatingPlaceholder
"
;
static
URLUpdatedFromUI
=
"
AboutTranslationsTest
:
URLUpdatedFromUI
"
;
static
TranslationRequested
=
"
AboutTranslationsTest
:
TranslationRequested
"
;
static
TranslationComplete
=
"
AboutTranslationsTest
:
TranslationComplete
"
;
static
PageOrientationChanged
=
"
AboutTranslationsTest
:
PageOrientationChanged
"
;
static
TextAreaHeightsChanged
=
"
AboutTranslationsTest
:
TextAreaHeightsChanged
"
;
static
ClearTargetText
=
"
AboutTranslationsTest
:
ClearTargetText
"
;
}
;
#
runInPage
;
#
resolveDownloads
;
#
rejectDownloads
;
#
autoDownloadFromRemoteSettings
;
constructor
(
runInPage
resolveDownloads
rejectDownloads
autoDownloadFromRemoteSettings
)
{
this
.
#
runInPage
=
runInPage
;
this
.
#
resolveDownloads
=
resolveDownloads
;
this
.
#
rejectDownloads
=
rejectDownloads
;
this
.
#
autoDownloadFromRemoteSettings
=
autoDownloadFromRemoteSettings
;
}
static
#
reportTestFailure
(
error
)
{
ok
(
false
String
(
error
)
)
;
}
async
waitForReady
(
)
{
try
{
await
this
.
#
runInPage
(
async
(
)
=
>
{
const
{
document
}
=
content
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
document
.
body
.
hasAttribute
(
"
ready
-
for
-
testing
"
)
"
Waiting
for
the
about
:
translations
document
to
be
ready
for
tests
.
"
)
;
}
)
;
ok
(
true
"
about
:
translations
is
ready
.
"
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
async
loadNewPage
(
{
sourceLanguage
targetLanguage
sourceText
}
=
{
}
)
{
const
url
=
new
URL
(
"
about
:
translations
"
)
;
const
searchParams
=
new
URLSearchParams
(
)
;
if
(
sourceLanguage
)
{
searchParams
.
set
(
"
src
"
sourceLanguage
)
;
}
if
(
targetLanguage
)
{
searchParams
.
set
(
"
trg
"
targetLanguage
)
;
}
if
(
sourceText
)
{
searchParams
.
set
(
"
text
"
sourceText
)
;
}
const
hashString
=
searchParams
.
toString
(
)
;
url
.
hash
=
hashString
?
hashString
:
"
src
=
detect
"
;
logAction
(
url
)
;
await
this
.
#
runInPage
(
async
(
_
{
url
}
)
=
>
{
const
{
window
document
:
oldDocument
}
=
content
;
window
.
location
.
assign
(
url
)
;
window
.
location
.
reload
(
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
window
.
document
!
=
=
oldDocument
"
Waiting
for
the
old
document
to
be
destroyed
.
"
)
;
}
{
url
}
)
;
await
this
.
waitForReady
(
)
;
}
async
setDebounceDelay
(
ms
)
{
logAction
(
ms
)
;
try
{
await
this
.
#
runInPage
(
(
_
{
ms
}
)
=
>
{
const
{
window
}
=
content
;
Cu
.
waiveXrays
(
window
)
.
DEBOUNCE_DELAY
=
ms
;
}
{
ms
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
async
resolveDownloads
(
count
)
{
if
(
this
.
#
autoDownloadFromRemoteSettings
)
{
throw
new
Error
(
"
Cannot
manually
resolve
downloads
when
autoDownloadFromRemoteSettings
is
enabled
.
"
)
;
}
try
{
this
.
#
resolveDownloads
(
count
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
async
rejectDownloads
(
requestCount
)
{
if
(
this
.
#
autoDownloadFromRemoteSettings
)
{
throw
new
Error
(
"
Cannot
manually
reject
downloads
when
autoDownloadFromRemoteSettings
is
enabled
.
"
)
;
}
try
{
this
.
#
rejectDownloads
(
requestCount
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
async
setSourceLanguageSelectorValue
(
language
)
{
logAction
(
language
)
;
try
{
await
this
.
#
runInPage
(
(
selectors
{
language
}
)
=
>
{
const
selector
=
content
.
document
.
querySelector
(
selectors
.
sourceLanguageSelector
)
;
selector
.
value
=
language
;
selector
.
dispatchEvent
(
new
content
.
Event
(
"
input
"
)
)
;
}
{
language
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
async
setTargetLanguageSelectorValue
(
language
)
{
logAction
(
language
)
;
try
{
await
this
.
#
runInPage
(
(
selectors
{
language
}
)
=
>
{
const
selector
=
content
.
document
.
querySelector
(
selectors
.
targetLanguageSelector
)
;
selector
.
value
=
language
;
selector
.
dispatchEvent
(
new
content
.
Event
(
"
input
"
)
)
;
}
{
language
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
async
setSourceTextAreaValue
(
value
)
{
logAction
(
value
)
;
try
{
await
this
.
#
runInPage
(
(
selectors
{
value
}
)
=
>
{
const
textArea
=
content
.
document
.
querySelector
(
selectors
.
sourceTextArea
)
;
textArea
.
value
=
value
;
textArea
.
dispatchEvent
(
new
content
.
Event
(
"
input
"
)
)
;
}
{
value
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
async
clickSwapLanguagesButton
(
)
{
logAction
(
)
;
try
{
await
this
.
#
runInPage
(
selectors
=
>
{
const
button
=
content
.
document
.
querySelector
(
selectors
.
swapLanguagesButton
)
;
button
.
click
(
)
;
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
async
waitForEvent
(
eventName
)
{
const
detail
=
await
this
.
#
runInPage
(
(
_
{
eventName
}
)
=
>
{
const
{
document
}
=
content
;
const
eventPromise
=
new
Promise
(
resolve
=
>
{
document
.
addEventListener
(
eventName
event
=
>
resolve
(
{
.
.
.
(
event
.
detail
?
?
{
}
)
}
)
{
once
:
true
}
)
;
}
)
;
const
timeoutPromise
=
new
Promise
(
(
_
reject
)
=
>
{
setTimeout
(
(
)
=
>
reject
(
new
Error
(
Event
"
{
eventName
}
"
did
not
fire
within
three
seconds
.
)
)
3000
)
;
}
)
;
return
Promise
.
race
(
[
eventPromise
timeoutPromise
]
)
;
}
{
eventName
}
)
;
return
detail
;
}
async
assertEvents
(
{
expected
=
[
]
unexpected
=
[
]
}
=
{
}
callback
)
{
await
doubleRaf
(
document
)
;
try
{
const
expectedEventWaiters
=
Object
.
fromEntries
(
expected
.
map
(
(
[
eventName
]
)
=
>
[
eventName
this
.
waitForEvent
(
eventName
)
]
)
)
;
const
unexpectedEventMap
=
{
}
;
for
(
const
eventName
of
unexpected
)
{
unexpectedEventMap
[
eventName
]
=
false
;
this
.
waitForEvent
(
eventName
)
.
then
(
(
)
=
>
{
unexpectedEventMap
[
eventName
]
=
true
;
}
)
.
catch
(
(
)
=
>
{
}
)
;
}
await
callback
(
)
;
for
(
const
[
eventName
expectedDetail
]
of
expected
)
{
const
actualDetail
=
await
expectedEventWaiters
[
eventName
]
;
is
(
JSON
.
stringify
(
actualDetail
?
?
{
}
)
JSON
.
stringify
(
expectedDetail
?
?
{
}
)
Expected
detail
for
"
{
eventName
}
"
to
match
.
)
;
}
await
TestUtils
.
waitForTick
(
)
;
await
TestUtils
.
waitForTick
(
)
;
for
(
const
eventName
of
unexpected
)
{
if
(
unexpectedEventMap
[
eventName
]
)
{
throw
new
Error
(
Unexpected
event
{
eventName
}
fired
during
callback
.
)
;
}
}
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
await
doubleRaf
(
document
)
;
}
async
assertSourceTextArea
(
{
value
showsPlaceholder
scriptDirection
}
=
{
}
)
{
await
doubleRaf
(
document
)
;
let
pageResult
=
{
}
;
try
{
pageResult
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
textArea
=
content
.
document
.
querySelector
(
selectors
.
sourceTextArea
)
;
return
{
hasPlaceholder
:
textArea
.
hasAttribute
(
"
placeholder
"
)
actualValue
:
textArea
.
value
actualScriptDirection
:
textArea
.
getAttribute
(
"
dir
"
)
}
;
}
{
value
showsPlaceholder
scriptDirection
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
const
{
hasPlaceholder
actualValue
actualScriptDirection
}
=
pageResult
;
if
(
showsPlaceholder
!
=
=
undefined
)
{
if
(
showsPlaceholder
)
{
ok
(
hasPlaceholder
"
Expected
placeholder
on
source
textarea
.
"
)
;
is
(
actualValue
"
"
"
Expected
source
textarea
to
have
no
value
when
showing
placeholder
.
"
)
;
}
else
{
ok
(
actualValue
"
Expected
source
textarea
to
have
a
value
.
"
)
;
}
}
if
(
value
!
=
=
undefined
)
{
is
(
actualValue
value
Expected
source
textarea
value
to
be
"
{
value
}
"
but
got
"
{
actualValue
}
"
.
)
;
}
if
(
scriptDirection
!
=
=
undefined
)
{
is
(
actualScriptDirection
scriptDirection
Expected
source
textarea
"
dir
"
attribute
to
be
"
{
scriptDirection
}
"
but
got
"
{
actualScriptDirection
}
"
.
)
;
}
}
async
assertTargetTextArea
(
{
value
showsPlaceholder
scriptDirection
}
=
{
}
)
{
await
doubleRaf
(
document
)
;
let
pageResult
=
{
}
;
try
{
pageResult
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
textArea
=
content
.
document
.
querySelector
(
selectors
.
targetTextArea
)
;
return
{
hasPlaceholder
:
textArea
.
hasAttribute
(
"
placeholder
"
)
actualValue
:
textArea
.
value
actualScriptDirection
:
textArea
.
getAttribute
(
"
dir
"
)
}
;
}
{
value
showsPlaceholder
scriptDirection
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
const
{
hasPlaceholder
actualValue
actualScriptDirection
}
=
pageResult
;
if
(
showsPlaceholder
!
=
=
undefined
)
{
if
(
showsPlaceholder
)
{
ok
(
hasPlaceholder
"
Expected
placeholder
on
target
textarea
.
"
)
;
is
(
actualValue
"
"
"
Expected
target
textarea
to
have
no
value
when
showing
placeholder
.
"
)
;
}
else
{
ok
(
actualValue
"
Expected
target
textarea
to
have
a
value
.
"
)
;
}
}
if
(
value
!
=
=
undefined
)
{
is
(
actualValue
value
Expected
target
textarea
value
to
be
"
{
value
}
"
but
got
"
{
actualValue
}
"
.
)
;
}
if
(
scriptDirection
!
=
=
undefined
)
{
is
(
actualScriptDirection
scriptDirection
Expected
target
textarea
"
dir
"
attribute
to
be
"
{
scriptDirection
}
"
but
got
"
{
actualScriptDirection
}
"
.
)
;
}
}
async
assertSourceLanguageSelector
(
{
value
options
detectedLanguage
}
=
{
}
)
{
await
doubleRaf
(
document
)
;
let
pageResult
=
{
}
;
try
{
pageResult
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
selector
=
content
.
document
.
querySelector
(
selectors
.
sourceLanguageSelector
)
;
const
detectOptionElement
=
content
.
document
.
querySelector
(
selectors
.
detectLanguageOption
)
;
return
{
actualValue
:
selector
.
value
optionValues
:
Array
.
from
(
selector
.
options
)
.
map
(
option
=
>
option
.
value
)
detectLanguageAttribute
:
detectOptionElement
?
.
getAttribute
(
"
language
"
)
?
?
null
}
;
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
const
{
actualValue
optionValues
detectLanguageAttribute
}
=
pageResult
;
if
(
value
!
=
=
undefined
)
{
is
(
actualValue
value
Expected
source
-
language
selector
value
to
be
"
{
value
}
"
but
got
"
{
actualValue
}
"
.
)
;
}
if
(
Array
.
isArray
(
options
)
)
{
is
(
optionValues
.
length
options
.
length
Expected
source
-
language
selector
to
have
{
options
.
length
}
options
but
got
{
optionValues
.
length
}
.
)
;
for
(
let
index
=
0
;
index
<
options
.
length
;
index
+
+
)
{
is
(
optionValues
[
index
]
options
[
index
]
Expected
source
-
language
selector
option
at
index
{
index
}
to
be
"
{
options
[
index
]
}
"
but
got
"
{
optionValues
[
index
]
}
"
.
)
;
}
}
if
(
detectedLanguage
!
=
=
undefined
)
{
is
(
actualValue
"
detect
"
With
detectedLanguage
set
expected
selector
value
to
be
"
detect
"
but
got
"
{
actualValue
}
"
.
)
;
is
(
detectLanguageAttribute
detectedLanguage
Expected
detect
-
language
option
"
language
"
attribute
to
be
"
{
detectedLanguage
}
"
but
got
"
{
detectLanguageAttribute
}
"
.
)
;
}
}
async
assertTargetLanguageSelector
(
{
value
options
}
=
{
}
)
{
await
doubleRaf
(
document
)
;
let
pageResult
=
{
}
;
try
{
pageResult
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
selector
=
content
.
document
.
querySelector
(
selectors
.
targetLanguageSelector
)
;
const
optionValues
=
Array
.
from
(
selector
.
options
)
.
map
(
option
=
>
option
.
value
)
;
return
{
actualValue
:
selector
.
value
optionValues
}
;
}
{
value
options
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
const
{
actualValue
optionValues
}
=
pageResult
;
if
(
value
!
=
=
undefined
)
{
is
(
actualValue
value
Expected
target
-
language
selector
value
to
be
"
{
value
}
"
but
got
"
{
actualValue
}
"
.
)
;
}
if
(
Array
.
isArray
(
options
)
)
{
is
(
optionValues
.
length
options
.
length
Expected
target
-
language
selector
to
have
{
options
.
length
}
options
but
got
{
optionValues
.
length
}
.
)
;
for
(
let
index
=
0
;
index
<
options
.
length
;
index
+
+
)
{
is
(
optionValues
[
index
]
options
[
index
]
Expected
target
-
language
selector
option
at
index
{
index
}
to
be
"
{
options
[
index
]
}
"
but
got
"
{
optionValues
[
index
]
}
"
.
)
;
}
}
}
async
assertDetectLanguageOption
(
{
isSelected
defaultValue
language
}
=
{
}
)
{
await
doubleRaf
(
document
)
;
if
(
language
!
=
=
undefined
&
&
defaultValue
)
{
throw
new
Error
(
"
assertDetectLanguageOption
:
language
and
defaultValue
:
true
are
mutually
exclusive
.
"
)
;
}
if
(
isSelected
!
=
=
undefined
)
{
if
(
isSelected
)
{
await
this
.
assertSourceLanguageSelector
(
{
value
:
"
detect
"
}
)
;
}
else
{
let
pageResult
=
{
}
;
try
{
pageResult
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
selector
=
content
.
document
.
querySelector
(
selectors
.
sourceLanguageSelector
)
;
return
{
actualValue
:
selector
.
value
}
;
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
const
{
actualValue
}
=
pageResult
;
Assert
.
notStrictEqual
(
actualValue
"
detect
"
Expected
source
-
language
selector
value
not
to
be
"
detect
"
but
got
"
{
actualValue
}
"
.
)
;
}
}
let
pageResult
=
{
}
;
try
{
pageResult
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
detectOptionElement
=
content
.
document
.
querySelector
(
selectors
.
detectLanguageOption
)
;
return
{
localizationId
:
detectOptionElement
?
.
getAttribute
(
"
data
-
l10n
-
id
"
)
languageAttributeValue
:
detectOptionElement
?
.
getAttribute
(
"
language
"
)
}
;
}
{
defaultValue
language
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
const
{
localizationId
languageAttributeValue
}
=
pageResult
;
if
(
defaultValue
!
=
=
undefined
)
{
const
expectedIdentifier
=
defaultValue
?
"
about
-
translations
-
detect
-
default
"
:
"
about
-
translations
-
detect
-
language
"
;
is
(
localizationId
expectedIdentifier
Expected
detect
-
language
option
"
data
-
l10n
-
id
"
to
be
"
{
expectedIdentifier
}
"
but
got
"
{
localizationId
}
"
.
)
;
}
if
(
language
!
=
=
undefined
)
{
is
(
languageAttributeValue
language
Expected
detect
-
language
option
"
language
"
attribute
to
be
"
{
language
}
"
but
got
"
{
languageAttributeValue
}
"
.
)
;
}
}
async
assertSwapLanguagesButton
(
{
enabled
}
=
{
}
)
{
await
doubleRaf
(
document
)
;
let
pageResult
=
{
}
;
try
{
pageResult
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
button
=
content
.
document
.
querySelector
(
selectors
.
swapLanguagesButton
)
;
return
{
isDisabled
:
button
.
hasAttribute
(
"
disabled
"
)
}
;
}
{
enabled
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
const
{
isDisabled
}
=
pageResult
;
if
(
enabled
!
=
=
undefined
)
{
if
(
enabled
)
{
ok
(
!
isDisabled
"
Expected
swap
-
languages
button
to
be
enabled
.
"
)
;
}
else
{
ok
(
isDisabled
"
Expected
swap
-
languages
button
to
be
disabled
.
"
)
;
}
}
}
async
assertTranslatingPlaceholder
(
)
{
await
doubleRaf
(
document
)
;
let
actualValue
;
try
{
actualValue
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
textarea
=
content
.
document
.
querySelector
(
selectors
.
targetTextArea
)
;
return
textarea
.
value
;
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
is
(
actualValue
"
Translating
"
Expected
target
textarea
to
show
"
Translating
"
but
got
"
{
actualValue
}
"
.
)
;
}
async
assertTranslatedText
(
{
sourceLanguage
detectedLanguage
targetLanguage
sourceText
}
)
{
await
doubleRaf
(
document
)
;
if
(
sourceLanguage
!
=
=
undefined
&
&
detectedLanguage
!
=
=
undefined
)
{
throw
new
Error
(
"
assertTranslatedText
:
sourceLanguage
and
detectedLanguage
are
mutually
exclusive
assertion
options
.
"
)
;
}
if
(
detectedLanguage
!
=
=
undefined
)
{
await
this
.
assertSourceLanguageSelector
(
{
detectedLanguage
}
)
;
}
else
{
await
this
.
assertSourceLanguageSelector
(
{
value
:
sourceLanguage
}
)
;
}
await
this
.
assertTargetLanguageSelector
(
{
value
:
targetLanguage
}
)
;
await
this
.
assertSourceTextArea
(
{
value
:
sourceText
}
)
;
const
actualSourceLanguage
=
detectedLanguage
?
?
sourceLanguage
;
const
expectedValue
=
actualSourceLanguage
=
=
=
targetLanguage
?
sourceText
:
{
sourceText
.
toUpperCase
(
)
}
[
{
actualSourceLanguage
}
to
{
targetLanguage
}
]
;
let
actualValue
;
try
{
actualValue
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
textarea
=
content
.
document
.
querySelector
(
selectors
.
targetTextArea
)
;
return
textarea
.
value
;
}
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
is
(
actualValue
expectedValue
Expected
translated
text
to
be
"
{
expectedValue
}
"
but
got
"
{
actualValue
}
"
.
)
;
}
async
assertURLMatchesUI
(
{
sourceLanguage
=
"
detect
"
targetLanguage
=
"
"
sourceText
=
"
"
}
=
{
}
)
{
await
doubleRaf
(
document
)
;
try
{
await
this
.
assertSourceLanguageSelector
(
{
value
:
sourceLanguage
}
)
;
await
this
.
assertTargetLanguageSelector
(
{
value
:
targetLanguage
}
)
;
await
this
.
assertSourceTextArea
(
{
value
:
sourceText
}
)
;
const
{
href
sourceParam
targetParam
textParam
}
=
await
this
.
#
runInPage
(
(
)
=
>
{
const
{
location
}
=
content
.
window
;
const
currentURL
=
new
URL
(
location
.
href
)
;
const
hashSubstring
=
currentURL
.
hash
.
startsWith
(
"
#
"
)
?
currentURL
.
hash
.
slice
(
1
)
:
currentURL
.
hash
;
const
urlSearchParams
=
new
URLSearchParams
(
hashSubstring
)
;
return
{
href
:
currentURL
.
href
sourceParam
:
urlSearchParams
.
get
(
"
src
"
)
?
?
"
detect
"
targetParam
:
urlSearchParams
.
get
(
"
trg
"
)
?
?
"
"
textParam
:
urlSearchParams
.
get
(
"
text
"
)
?
?
"
"
}
;
}
)
;
is
(
sourceParam
sourceLanguage
Expected
URL
parameter
"
src
"
to
be
"
{
sourceLanguage
}
"
but
got
"
{
sourceParam
}
"
.
)
;
is
(
targetParam
targetLanguage
Expected
URL
parameter
"
trg
"
to
be
"
{
targetLanguage
}
"
but
got
"
{
targetParam
}
"
.
)
;
is
(
textParam
sourceText
Expected
URL
parameter
"
text
"
to
be
"
{
sourceText
}
"
but
got
"
{
textParam
}
"
.
)
;
const
expectedURL
=
new
URL
(
"
about
:
translations
"
)
;
const
expectedParams
=
new
URLSearchParams
(
)
;
if
(
sourceLanguage
)
{
expectedParams
.
set
(
"
src
"
sourceLanguage
)
;
}
if
(
targetLanguage
)
{
expectedParams
.
set
(
"
trg
"
targetLanguage
)
;
}
if
(
sourceText
)
{
expectedParams
.
set
(
"
text
"
sourceText
)
;
}
expectedURL
.
hash
=
expectedParams
.
toString
(
)
;
is
(
href
expectedURL
.
href
Expected
full
URL
to
be
"
{
expectedURL
.
href
}
"
but
got
"
{
href
}
"
.
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
async
assertIsVisible
(
{
pageHeader
=
false
mainUserInterface
=
false
sourceLanguageSelector
=
false
targetLanguageSelector
=
false
swapLanguagesButton
=
false
sourceTextArea
=
false
targetTextArea
=
false
unsupportedInfoMessage
=
false
languageLoadErrorMessage
=
false
}
=
{
}
)
{
await
doubleRaf
(
document
)
;
try
{
const
visibilityMap
=
await
this
.
#
runInPage
(
selectors
=
>
{
const
{
document
window
}
=
content
;
const
isElementVisible
=
selector
=
>
{
const
element
=
document
.
querySelector
(
selector
)
;
if
(
element
.
offsetParent
=
=
=
null
)
{
return
false
;
}
const
computedStyle
=
window
.
getComputedStyle
(
element
)
;
if
(
!
computedStyle
)
{
return
false
;
}
const
{
display
visibility
}
=
computedStyle
;
return
!
(
display
=
=
=
"
none
"
|
|
visibility
=
=
=
"
hidden
"
)
;
}
;
return
{
pageHeader
:
isElementVisible
(
selectors
.
pageHeader
)
mainUserInterface
:
isElementVisible
(
selectors
.
mainUserInterface
)
sourceLanguageSelector
:
isElementVisible
(
selectors
.
sourceLanguageSelector
)
targetLanguageSelector
:
isElementVisible
(
selectors
.
targetLanguageSelector
)
swapLanguagesButton
:
isElementVisible
(
selectors
.
swapLanguagesButton
)
sourceTextArea
:
isElementVisible
(
selectors
.
sourceTextArea
)
targetTextArea
:
isElementVisible
(
selectors
.
targetTextArea
)
unsupportedInfoMessage
:
isElementVisible
(
selectors
.
unsupportedInfoMessage
)
languageLoadErrorMessage
:
isElementVisible
(
selectors
.
languageLoadErrorMessage
)
}
;
}
)
;
const
assertVisibility
=
(
expectedVisibility
actualVisibility
label
)
=
>
expectedVisibility
?
ok
(
actualVisibility
Expected
{
label
}
to
be
visible
.
)
:
ok
(
!
actualVisibility
Expected
{
label
}
to
be
hidden
.
)
;
assertVisibility
(
pageHeader
visibilityMap
.
pageHeader
"
page
header
"
)
;
assertVisibility
(
mainUserInterface
visibilityMap
.
mainUserInterface
"
main
user
interface
"
)
;
assertVisibility
(
sourceLanguageSelector
visibilityMap
.
sourceLanguageSelector
"
source
-
language
selector
"
)
;
assertVisibility
(
targetLanguageSelector
visibilityMap
.
targetLanguageSelector
"
target
-
language
selector
"
)
;
assertVisibility
(
swapLanguagesButton
visibilityMap
.
swapLanguagesButton
"
swap
-
languages
button
"
)
;
assertVisibility
(
sourceTextArea
visibilityMap
.
sourceTextArea
"
source
textarea
"
)
;
assertVisibility
(
targetTextArea
visibilityMap
.
targetTextArea
"
target
textarea
"
)
;
assertVisibility
(
unsupportedInfoMessage
visibilityMap
.
unsupportedInfoMessage
"
unsupported
info
message
"
)
;
assertVisibility
(
languageLoadErrorMessage
visibilityMap
.
languageLoadErrorMessage
"
language
-
load
error
message
"
)
;
}
catch
(
error
)
{
AboutTranslationsTestUtils
.
#
reportTestFailure
(
error
)
;
}
}
}
