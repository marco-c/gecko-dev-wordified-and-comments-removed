"
use
strict
"
;
add_task
(
async
function
test_detected_language
(
)
{
const
{
cleanup
tab
}
=
await
loadTestPage
(
{
page
:
ENGLISH_PAGE_URL
autoDownloadFromRemoteSettings
:
true
languagePairs
:
[
{
fromLang
:
"
es
"
toLang
:
"
en
"
}
{
fromLang
:
"
en
"
toLang
:
"
es
"
}
{
fromLang
:
"
fr
"
toLang
:
"
en
"
}
{
fromLang
:
"
en
"
toLang
:
"
fr
"
}
]
}
)
;
async
function
getDetectedLanguagesFor
(
langTag
)
{
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
langTag
}
function
changeLanguage
(
{
langTag
}
)
{
content
.
document
.
body
.
parentNode
.
setAttribute
(
"
lang
"
langTag
)
;
}
)
;
getTranslationsParent
(
)
.
languageState
.
detectedLanguages
=
null
;
const
{
docLangTag
userLangTag
isDocLangTagSupported
}
=
await
getTranslationsParent
(
)
.
getDetectedLanguages
(
langTag
)
;
return
{
docLangTag
userLangTag
isDocLangTagSupported
}
;
}
{
const
cleanupLocales
=
await
mockLocales
(
{
systemLocales
:
[
"
en
"
]
appLocales
:
[
"
en
"
]
webLanguages
:
[
"
"
]
}
)
;
Assert
.
deepEqual
(
await
getDetectedLanguagesFor
(
"
en
"
)
{
docLangTag
:
"
en
"
userLangTag
:
null
isDocLangTagSupported
:
true
}
"
If
the
web
languages
are
empty
do
not
offer
a
language
matching
the
app
locale
.
"
)
;
await
cleanupLocales
(
)
;
}
{
const
cleanupLocales
=
await
mockLocales
(
{
systemLocales
:
[
"
en
"
"
es
"
]
appLocales
:
[
"
en
"
]
webLanguages
:
[
"
"
]
}
)
;
Assert
.
deepEqual
(
await
getDetectedLanguagesFor
(
"
en
"
)
{
docLangTag
:
"
en
"
userLangTag
:
null
isDocLangTagSupported
:
true
}
"
When
there
are
multiple
system
locales
the
app
locale
is
used
.
"
)
;
Assert
.
deepEqual
(
await
getDetectedLanguagesFor
(
"
es
"
)
{
docLangTag
:
"
es
"
userLangTag
:
"
en
"
isDocLangTagSupported
:
true
}
"
When
there
are
multiple
system
locales
the
app
locale
is
used
.
"
)
;
await
cleanupLocales
(
)
;
}
return
cleanup
(
)
;
}
)
;
