"
use
strict
"
;
const
{
RemoteSettings
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
)
;
const
firefoxFullVersion
=
AppConstants
.
MOZ_APP_VERSION
;
const
firefoxMajorVersion
=
firefoxFullVersion
.
match
(
/
\
d
+
/
)
;
const
firefoxAlphaZeroVersion
=
{
firefoxMajorVersion
}
.
a0
;
async
function
createRemoteSettingsClient
(
mockedKey
)
{
const
client
=
RemoteSettings
(
mockedKey
)
;
await
client
.
db
.
clear
(
)
;
await
client
.
db
.
importChanges
(
{
}
Date
.
now
(
)
)
;
return
client
;
}
add_task
(
async
function
test_filter_current_firefox_version
(
)
{
let
client
=
await
createRemoteSettingsClient
(
"
test_filter_current_firefox_version
"
)
;
const
expectedPresentRecords
=
[
{
name
:
undefined
filter
expression
filter_expression
:
undefined
}
{
name
:
null
filter
expression
filter_expression
:
null
}
{
name
:
empty
filter
expression
filter_expression
:
}
{
name
:
env
.
version
=
=
{
firefoxFullVersion
}
filter_expression
:
env
.
version
|
versionCompare
(
'
{
firefoxFullVersion
}
'
)
=
=
0
}
{
name
:
env
.
version
<
=
{
firefoxMajorVersion
}
filter_expression
:
env
.
version
|
versionCompare
(
'
{
firefoxMajorVersion
}
'
)
<
=
0
}
{
name
:
env
.
version
>
{
firefoxAlphaZeroVersion
}
filter_expression
:
env
.
version
|
versionCompare
(
'
{
firefoxAlphaZeroVersion
}
'
)
>
0
}
]
;
for
(
let
record
of
expectedPresentRecords
)
{
client
.
db
.
create
(
record
)
;
}
const
expectedAbsentRecords
=
[
{
name
:
env
.
version
<
1
filter_expression
:
env
.
version
|
versionCompare
(
'
1
'
)
<
0
}
]
;
for
(
let
record
of
expectedAbsentRecords
)
{
client
.
db
.
create
(
record
)
;
}
const
retrievedRecords
=
await
client
.
get
(
)
;
for
(
let
expectedPresentRecord
of
expectedPresentRecords
)
{
is
(
retrievedRecords
.
some
(
record
=
>
record
.
name
=
=
expectedPresentRecord
.
name
)
true
The
following
record
was
expected
to
be
present
but
was
not
found
:
{
expectedPresentRecord
.
name
}
\
n
)
;
}
for
(
let
expectedAbsentRecord
of
expectedAbsentRecords
)
{
is
(
retrievedRecords
.
some
(
record
=
>
record
.
name
=
=
expectedAbsentRecord
.
name
)
false
The
following
record
was
expected
to
be
absent
but
was
found
:
{
expectedAbsentRecord
.
name
}
\
n
)
;
}
is
(
retrievedRecords
.
length
expectedPresentRecords
.
length
Expected
{
expectedPresentRecords
.
length
}
items
but
got
{
retrievedRecords
.
length
}
items
\
n
)
;
}
)
;
add_task
(
async
function
test_get_records_with_multiple_versions
(
)
{
let
client
=
await
createRemoteSettingsClient
(
"
test_get_translation_model_records
"
)
;
const
lookupKey
=
record
=
>
{
record
.
name
}
{
record
.
fromLang
}
{
record
.
toLang
}
;
const
maxVersionMap
=
{
}
;
const
versionOneRecords
=
[
{
id
:
crypto
.
randomUUID
(
)
name
:
"
qualityModel
.
enes
.
bin
"
fromLang
:
"
en
"
toLang
:
"
es
"
fileType
:
"
qualityModel
"
version
:
"
1
.
0
"
}
{
id
:
crypto
.
randomUUID
(
)
name
:
"
vocab
.
esen
.
spm
"
fromLang
:
"
en
"
toLang
:
"
es
"
fileType
:
"
vocab
"
version
:
"
1
.
0
"
}
{
id
:
crypto
.
randomUUID
(
)
name
:
"
vocab
.
esen
.
spm
"
fromLang
:
"
es
"
toLang
:
"
en
"
fileType
:
"
vocab
"
version
:
"
1
.
0
"
}
{
id
:
crypto
.
randomUUID
(
)
name
:
"
lex
.
50
.
50
.
enes
.
s2t
.
bin
"
fromLang
:
"
en
"
toLang
:
"
es
"
fileType
:
"
lex
"
version
:
"
1
.
0
"
}
{
id
:
crypto
.
randomUUID
(
)
name
:
"
model
.
enes
.
intgemm
.
alphas
.
bin
"
fromLang
:
"
en
"
toLang
:
"
es
"
fileType
:
"
model
"
version
:
"
1
.
0
"
}
{
id
:
crypto
.
randomUUID
(
)
name
:
"
vocab
.
deen
.
spm
"
fromLang
:
"
en
"
toLang
:
"
de
"
fileType
:
"
vocab
"
version
:
"
1
.
0
"
}
{
id
:
crypto
.
randomUUID
(
)
name
:
"
lex
.
50
.
50
.
ende
.
s2t
.
bin
"
fromLang
:
"
en
"
toLang
:
"
de
"
fileType
:
"
lex
"
version
:
"
1
.
0
"
}
{
id
:
crypto
.
randomUUID
(
)
name
:
"
model
.
ende
.
intgemm
.
alphas
.
bin
"
fromLang
:
"
en
"
toLang
:
"
de
"
fileType
:
"
model
"
version
:
"
1
.
0
"
}
]
;
versionOneRecords
.
reduce
(
(
map
record
)
=
>
{
map
[
lookupKey
(
record
)
]
=
record
.
version
;
return
map
;
}
maxVersionMap
)
;
for
(
const
record
of
versionOneRecords
)
{
client
.
db
.
create
(
record
)
;
}
const
higherVersionRecords
=
[
{
id
:
crypto
.
randomUUID
(
)
name
:
"
qualityModel
.
enes
.
bin
"
fromLang
:
"
en
"
toLang
:
"
es
"
fileType
:
"
qualityModel
"
version
:
"
1
.
1
"
}
{
id
:
crypto
.
randomUUID
(
)
name
:
"
qualityModel
.
enes
.
bin
"
fromLang
:
"
en
"
toLang
:
"
es
"
fileType
:
"
qualityModel
"
version
:
"
1
.
2
"
}
{
id
:
crypto
.
randomUUID
(
)
name
:
"
vocab
.
esen
.
spm
"
fromLang
:
"
en
"
toLang
:
"
es
"
fileType
:
"
vocab
"
version
:
"
1
.
1
"
}
]
;
higherVersionRecords
.
reduce
(
(
map
record
)
=
>
{
const
key
=
lookupKey
(
record
)
;
if
(
record
.
version
>
map
[
key
]
)
{
map
[
key
]
=
record
.
version
;
}
return
map
;
}
maxVersionMap
)
;
for
(
const
record
of
higherVersionRecords
)
{
client
.
db
.
create
(
record
)
;
}
TranslationsParent
.
mockRemoteSettingsClient
(
client
)
;
const
retrievedRecords
=
await
TranslationsParent
.
getMaxVersionRecords
(
client
{
lookupKey
}
)
;
for
(
const
record
of
retrievedRecords
)
{
is
(
lookupKey
(
record
)
in
maxVersionMap
true
Expected
record
{
record
.
name
}
to
be
contained
in
the
nameToVersionMap
but
found
none
\
n
)
;
is
(
record
.
version
maxVersionMap
[
lookupKey
(
record
)
]
Expected
record
{
record
.
name
}
to
be
version
{
maxVersionMap
[
lookupKey
(
record
)
]
}
but
found
version
{
record
.
version
}
\
n
)
;
}
const
expectedSize
=
Object
.
keys
(
maxVersionMap
)
.
length
;
is
(
retrievedRecords
.
length
expectedSize
Expected
retrieved
records
to
be
the
same
size
as
the
name
-
to
-
version
map
(
{
expectedSize
}
)
but
found
{
retrievedRecords
.
length
}
\
n
)
;
TranslationsParent
.
mockRemoteSettingsClient
(
null
)
;
}
)
;
