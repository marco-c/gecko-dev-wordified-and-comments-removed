"
use
strict
"
;
add_task
(
async
function
test_pivot_language_behavior
(
)
{
info
(
"
Expect
4
console
.
error
messages
notifying
of
the
lack
of
a
pivot
language
.
"
)
;
const
fromLanguagePairs
=
[
{
fromLang
:
"
en
"
toLang
:
"
es
"
}
{
fromLang
:
"
es
"
toLang
:
"
en
"
}
{
fromLang
:
"
en
"
toLang
:
"
yue
"
}
{
fromLang
:
"
yue
"
toLang
:
"
en
"
}
{
fromLang
:
"
is
"
toLang
:
"
en
"
}
{
fromLang
:
"
zh
"
toLang
:
"
ja
"
}
{
fromLang
:
"
ja
"
toLang
:
"
zh
"
}
]
;
function
sort
(
list
)
{
return
list
.
sort
(
(
a
b
)
=
>
{
a
.
fromLang
}
-
{
a
.
toLang
}
.
localeCompare
(
{
b
.
fromLang
}
-
{
b
.
toLang
}
)
)
;
}
const
{
cleanup
}
=
await
setupActorTest
(
{
languagePairs
:
fromLanguagePairs
}
)
;
const
{
languagePairs
}
=
await
TranslationsParent
.
getSupportedLanguages
(
)
;
languagePairs
.
sort
(
(
a
b
)
=
>
TranslationsParent
.
languagePairKey
(
a
.
fromLang
a
.
toLang
)
.
localeCompare
(
TranslationsParent
.
languagePairKey
(
b
.
fromLang
b
.
toLang
)
)
)
;
if
(
SpecialPowers
.
isDebugBuild
)
{
Assert
.
deepEqual
(
sort
(
languagePairs
)
sort
(
[
{
fromLang
:
"
en
"
toLang
:
"
es
"
}
{
fromLang
:
"
en
"
toLang
:
"
yue
"
}
{
fromLang
:
"
es
"
toLang
:
"
en
"
}
{
fromLang
:
"
is
"
toLang
:
"
en
"
}
{
fromLang
:
"
yue
"
toLang
:
"
en
"
}
]
)
"
Non
-
pivot
languages
were
removed
on
debug
builds
.
"
)
;
}
else
{
Assert
.
deepEqual
(
sort
(
languagePairs
)
sort
(
fromLanguagePairs
)
"
Non
-
pivot
languages
are
retained
on
non
-
debug
builds
.
"
)
;
}
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_language_support_checks
(
)
{
const
{
cleanup
}
=
await
setupActorTest
(
{
languagePairs
:
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
es
"
}
{
fromLang
:
"
es
"
toLang
:
PIVOT_LANGUAGE
}
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
fr
"
}
{
fromLang
:
"
fr
"
toLang
:
PIVOT_LANGUAGE
}
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
pl
"
}
{
fromLang
:
"
pl
"
toLang
:
PIVOT_LANGUAGE
}
{
fromLang
:
"
fi
"
toLang
:
PIVOT_LANGUAGE
}
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
sl
"
}
]
}
)
;
const
{
languagePairs
}
=
await
TranslationsParent
.
getSupportedLanguages
(
)
;
for
(
const
{
fromLang
toLang
}
of
languagePairs
)
{
ok
(
await
TranslationsParent
.
findCompatibleSourceLangTag
(
fromLang
)
"
Each
from
-
language
should
be
supported
as
a
translation
source
language
.
"
)
;
ok
(
await
TranslationsParent
.
findCompatibleTargetLangTag
(
toLang
)
"
Each
to
-
language
should
be
supported
as
a
translation
target
language
.
"
)
;
is
(
Boolean
(
await
TranslationsParent
.
findCompatibleTargetLangTag
(
fromLang
)
)
languagePairs
.
some
(
(
{
toLang
}
)
=
>
toLang
=
=
=
fromLang
)
"
A
from
-
language
should
be
supported
as
a
to
-
language
if
it
also
exists
in
the
to
-
language
list
.
"
)
;
is
(
Boolean
(
await
TranslationsParent
.
findCompatibleSourceLangTag
(
toLang
)
)
languagePairs
.
some
(
(
{
fromLang
}
)
=
>
fromLang
=
=
=
toLang
)
"
A
to
-
language
should
be
supported
as
a
from
-
language
if
it
also
exists
in
the
from
-
language
list
.
"
)
;
}
await
usingAppLocale
(
"
en
"
async
(
)
=
>
{
const
expected
=
"
en
"
;
const
actual
=
await
TranslationsParent
.
getTopPreferredSupportedToLang
(
)
;
is
(
actual
expected
"
The
top
supported
to
-
language
should
match
the
expected
language
tag
"
)
;
}
)
;
await
usingAppLocale
(
"
es
"
async
(
)
=
>
{
const
expected
=
"
es
"
;
const
actual
=
await
TranslationsParent
.
getTopPreferredSupportedToLang
(
)
;
is
(
actual
expected
"
The
top
supported
to
-
language
should
match
the
expected
language
tag
"
)
;
}
)
;
await
usingAppLocale
(
"
fi
"
async
(
)
=
>
{
const
expected
=
"
en
"
;
const
actual
=
await
TranslationsParent
.
getTopPreferredSupportedToLang
(
)
;
is
(
actual
expected
"
The
top
supported
to
-
language
should
match
the
expected
language
tag
"
)
;
}
)
;
await
usingAppLocale
(
"
sl
"
async
(
)
=
>
{
const
expected
=
"
sl
"
;
const
actual
=
await
TranslationsParent
.
getTopPreferredSupportedToLang
(
)
;
is
(
actual
expected
"
The
top
supported
to
-
language
should
match
the
expected
language
tag
"
)
;
}
)
;
await
usingAppLocale
(
"
ja
"
async
(
)
=
>
{
const
expected
=
"
en
"
;
const
actual
=
await
TranslationsParent
.
getTopPreferredSupportedToLang
(
)
;
is
(
actual
expected
"
The
top
supported
to
-
language
should
match
the
expected
language
tag
"
)
;
}
)
;
await
cleanup
(
)
;
}
)
;
async
function
usingAppLocale
(
locale
callback
)
{
info
(
Mocking
the
locale
"
{
locale
}
"
expect
missing
resource
errors
.
)
;
const
cleanupLocales
=
await
mockLocales
(
{
appLocales
:
[
locale
]
}
)
;
if
(
Services
.
locale
.
appLocaleAsBCP47
!
=
=
locale
)
{
throw
new
Error
(
"
Unable
to
change
the
app
locale
.
"
)
;
}
await
callback
(
)
;
await
cleanupLocales
(
)
;
}
add_task
(
async
function
test_translating_to_and_from_app_language
(
)
{
const
PIVOT_LANGUAGE
=
"
en
"
;
const
{
cleanup
}
=
await
setupActorTest
(
{
languagePairs
:
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
es
"
}
{
fromLang
:
"
es
"
toLang
:
PIVOT_LANGUAGE
}
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
fr
"
}
{
fromLang
:
"
fr
"
toLang
:
PIVOT_LANGUAGE
}
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
pl
"
}
{
fromLang
:
"
pl
"
toLang
:
PIVOT_LANGUAGE
}
]
}
)
;
function
getUniqueLanguagePairs
(
records
)
{
const
langPairs
=
new
Set
(
)
;
for
(
const
{
fromLang
toLang
}
of
records
)
{
langPairs
.
add
(
TranslationsParent
.
languagePairKey
(
fromLang
toLang
)
)
;
}
return
Array
.
from
(
langPairs
)
.
sort
(
)
.
map
(
langPair
=
>
{
const
[
fromLang
toLang
]
=
langPair
.
split
(
"
"
)
;
return
{
fromLang
toLang
}
;
}
)
;
}
function
assertLanguagePairs
(
{
app
requested
message
languagePairs
includePivotRecords
}
)
{
return
usingAppLocale
(
app
async
(
)
=
>
{
Assert
.
deepEqual
(
getUniqueLanguagePairs
(
await
TranslationsParent
.
getRecordsForTranslatingToAndFromAppLanguage
(
requested
includePivotRecords
)
)
languagePairs
message
)
;
}
)
;
}
await
assertLanguagePairs
(
{
message
:
"
When
the
app
locale
is
the
pivot
language
download
another
language
.
"
app
:
PIVOT_LANGUAGE
requested
:
"
fr
"
includePivotRecords
:
true
languagePairs
:
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
fr
"
}
{
fromLang
:
"
fr
"
toLang
:
PIVOT_LANGUAGE
}
]
}
)
;
await
assertLanguagePairs
(
{
message
:
"
When
a
pivot
language
is
required
they
are
both
downloaded
.
"
app
:
"
fr
"
requested
:
"
pl
"
includePivotRecords
:
true
languagePairs
:
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
fr
"
}
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
pl
"
}
{
fromLang
:
"
fr
"
toLang
:
PIVOT_LANGUAGE
}
{
fromLang
:
"
pl
"
toLang
:
PIVOT_LANGUAGE
}
]
}
)
;
await
assertLanguagePairs
(
{
message
:
"
When
downloading
the
pivot
language
only
download
the
one
for
the
app
'
s
locale
.
"
app
:
"
es
"
requested
:
PIVOT_LANGUAGE
includePivotRecords
:
true
languagePairs
:
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
es
"
}
{
fromLang
:
"
es
"
toLang
:
PIVOT_LANGUAGE
}
]
}
)
;
await
assertLanguagePairs
(
{
message
:
"
Delete
just
the
requested
language
when
the
app
locale
is
the
pivot
language
"
app
:
PIVOT_LANGUAGE
requested
:
"
fr
"
includePivotRecords
:
false
languagePairs
:
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
fr
"
}
{
fromLang
:
"
fr
"
toLang
:
PIVOT_LANGUAGE
}
]
}
)
;
await
assertLanguagePairs
(
{
message
:
"
Delete
just
the
requested
language
and
not
the
pivot
.
"
app
:
"
fr
"
requested
:
"
pl
"
includePivotRecords
:
false
languagePairs
:
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
pl
"
}
{
fromLang
:
"
pl
"
toLang
:
PIVOT_LANGUAGE
}
]
}
)
;
await
assertLanguagePairs
(
{
message
:
"
Delete
just
the
requested
language
and
not
the
pivot
.
"
app
:
"
fr
"
requested
:
"
pl
"
includePivotRecords
:
false
languagePairs
:
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
pl
"
}
{
fromLang
:
"
pl
"
toLang
:
PIVOT_LANGUAGE
}
]
}
)
;
await
assertLanguagePairs
(
{
message
:
"
Delete
just
the
pivot
app
and
app
pivot
.
"
app
:
"
es
"
requested
:
PIVOT_LANGUAGE
includePivotRecords
:
false
languagePairs
:
[
{
fromLang
:
PIVOT_LANGUAGE
toLang
:
"
es
"
}
{
fromLang
:
"
es
"
toLang
:
PIVOT_LANGUAGE
}
]
}
)
;
await
assertLanguagePairs
(
{
message
:
"
If
the
app
and
request
language
are
the
same
nothing
is
returned
.
"
app
:
"
fr
"
requested
:
"
fr
"
includePivotRecords
:
true
languagePairs
:
[
]
}
)
;
await
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_firstVisualChange
(
)
{
const
{
cleanup
}
=
await
setupActorTest
(
{
languagePairs
:
[
{
fromLang
:
"
en
"
toLang
:
"
es
"
}
]
}
)
;
const
parent
=
getTranslationsParent
(
)
;
Assert
.
equal
(
parent
.
languageState
.
hasVisibleChange
false
"
No
visual
translation
change
has
occurred
yet
"
)
;
parent
.
receiveMessage
(
{
name
:
"
Translations
:
ReportFirstVisibleChange
"
}
)
;
Assert
.
equal
(
parent
.
languageState
.
hasVisibleChange
true
"
A
change
occurred
.
"
)
;
await
cleanup
(
)
;
}
)
;
