"
use
strict
"
;
const
{
TranslationsTelemetry
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
global
/
content
/
translations
/
TranslationsTelemetry
.
sys
.
mjs
"
)
;
add_task
(
function
test_sampling_across_channels
(
)
{
const
sampleRates
=
{
applyInAutomation
:
true
default
:
1
/
10
nightly
:
1
/
100
beta
:
1
/
1_000
esr
:
1
/
10_000
release
:
1
/
100_000
}
;
const
outcomes
=
{
default
:
{
recordedCount
:
0
skippedCount
:
0
}
nightly
:
{
recordedCount
:
0
skippedCount
:
0
}
beta
:
{
recordedCount
:
0
skippedCount
:
0
}
esr
:
{
recordedCount
:
0
skippedCount
:
0
}
release
:
{
recordedCount
:
0
skippedCount
:
0
}
}
;
const
channels
=
Object
.
keys
(
outcomes
)
;
const
iterations
=
1_000_000
;
info
(
Collecting
{
iterations
}
outcomes
for
each
channel
.
)
;
for
(
let
iteration
=
0
;
iteration
<
iterations
;
iteration
+
+
)
{
const
flowContext
=
TranslationsTelemetry
.
createFlowContext
(
)
;
for
(
const
channel
of
channels
)
{
const
shouldSkip
=
TranslationsTelemetry
.
shouldSkipSample
(
sampleRates
flowContext
channel
)
;
if
(
shouldSkip
)
{
outcomes
[
channel
]
.
skippedCount
+
+
;
}
else
{
outcomes
[
channel
]
.
recordedCount
+
+
;
}
}
}
info
(
Checking
that
all
{
iterations
}
outcomes
are
present
for
each
channel
.
)
;
for
(
const
channel
of
channels
)
{
const
{
recordedCount
:
recourdedCount
skippedCount
}
=
outcomes
[
channel
]
;
equal
(
recourdedCount
+
skippedCount
iterations
The
total
outcomes
for
the
"
{
channel
}
"
channel
should
cover
every
iteration
.
)
;
}
info
(
Checking
that
channels
with
a
higher
probability
to
record
have
more
recorded
events
.
)
;
for
(
let
index
=
0
;
index
<
channels
.
length
-
1
;
index
+
+
)
{
const
current
=
channels
[
index
]
;
const
next
=
channels
[
index
+
1
]
;
Assert
.
greater
(
outcomes
[
current
]
.
recordedCount
outcomes
[
next
]
.
recordedCount
The
recorded
count
for
the
"
{
current
}
"
channel
should
be
greater
than
the
"
{
next
}
"
channel
.
)
;
}
const
multiplier
=
6
;
info
(
"
Checking
that
each
channel
'
s
recorded
event
count
is
within
the
expected
statistical
tolerance
.
"
)
;
for
(
const
channel
of
channels
)
{
const
sampleRate
=
sampleRates
[
channel
]
;
const
{
recordedCount
}
=
outcomes
[
channel
]
;
const
expectedRecordedCount
=
iterations
*
sampleRate
;
const
deviation
=
Math
.
abs
(
recordedCount
-
expectedRecordedCount
)
;
const
standardDeviation
=
Math
.
sqrt
(
iterations
*
sampleRate
*
(
1
-
sampleRate
)
)
;
const
tolerance
=
multiplier
*
standardDeviation
;
info
(
Channel
(
"
{
channel
}
"
)
:
expected
(
{
expectedRecordedCount
}
)
recorded
(
{
recordedCount
}
)
deviation
(
{
deviation
.
toFixed
(
1
)
}
)
tolerance
(
{
tolerance
.
toFixed
(
1
)
}
)
)
;
Assert
.
lessOrEqual
(
deviation
tolerance
The
recorded
count
for
"
{
channel
}
"
remains
within
+
/
-
{
multiplier
}
x
of
the
expected
standard
deviation
.
)
;
}
}
)
;
