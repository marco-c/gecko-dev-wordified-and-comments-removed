let
fastTextModule
;
const
_initFastTextModule
=
async
function
(
wasmModule
)
{
try
{
fastTextModule
=
await
loadFastTextModule
(
wasmModule
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
return
true
}
let
postRunFunc
=
null
;
const
addOnPostRun
=
function
(
func
)
{
postRunFunc
=
func
;
}
;
const
loadFastText
=
(
wasmModule
)
=
>
{
_initFastTextModule
(
wasmModule
)
.
then
(
(
res
)
=
>
{
if
(
postRunFunc
)
{
postRunFunc
(
)
;
}
}
)
}
const
thisModule
=
this
;
const
trainFileInWasmFs
=
'
train
.
txt
'
;
const
testFileInWasmFs
=
'
test
.
txt
'
;
const
modelFileInWasmFs
=
'
model
.
bin
'
;
const
getFloat32ArrayFromHeap
=
(
len
)
=
>
{
const
dataBytes
=
len
*
Float32Array
.
BYTES_PER_ELEMENT
;
const
dataPtr
=
fastTextModule
.
_malloc
(
dataBytes
)
;
const
dataHeap
=
new
Uint8Array
(
fastTextModule
.
HEAPU8
.
buffer
dataPtr
dataBytes
)
;
return
{
'
ptr
'
:
dataHeap
.
byteOffset
'
size
'
:
len
'
buffer
'
:
dataHeap
.
buffer
}
;
}
;
const
heapToFloat32
=
(
r
)
=
>
new
Float32Array
(
r
.
buffer
r
.
ptr
r
.
size
)
;
class
FastText
{
constructor
(
fastTextModule
)
{
this
.
f
=
new
fastTextModule
.
FastText
(
)
;
}
loadModel
(
url
)
{
const
fetchFunc
=
(
thisModule
&
&
thisModule
.
fetch
)
|
|
fetch
;
const
fastTextNative
=
this
.
f
;
return
new
Promise
(
function
(
resolve
reject
)
{
fetchFunc
(
url
)
.
then
(
response
=
>
{
return
response
.
arrayBuffer
(
)
;
}
)
.
then
(
bytes
=
>
{
const
byteArray
=
new
Uint8Array
(
bytes
)
;
const
FS
=
fastTextModule
.
FS
;
FS
.
writeFile
(
modelFileInWasmFs
byteArray
)
;
}
)
.
then
(
(
)
=
>
{
fastTextNative
.
loadModel
(
modelFileInWasmFs
)
;
resolve
(
new
FastTextModel
(
fastTextNative
)
)
;
}
)
.
catch
(
error
=
>
{
reject
(
error
)
;
}
)
;
}
)
;
}
loadModelBinary
(
buffer
)
{
const
fastTextNative
=
this
.
f
;
const
byteArray
=
new
Uint8Array
(
buffer
)
;
const
FS
=
fastTextModule
.
FS
;
FS
.
writeFile
(
modelFileInWasmFs
byteArray
)
;
fastTextNative
.
loadModel
(
modelFileInWasmFs
)
;
return
new
FastTextModel
(
fastTextNative
)
;
}
_train
(
url
modelName
kwargs
=
{
}
callback
=
null
)
{
const
fetchFunc
=
(
thisModule
&
&
thisModule
.
fetch
)
|
|
fetch
;
const
fastTextNative
=
this
.
f
;
return
new
Promise
(
function
(
resolve
reject
)
{
fetchFunc
(
url
)
.
then
(
response
=
>
{
return
response
.
arrayBuffer
(
)
;
}
)
.
then
(
bytes
=
>
{
const
byteArray
=
new
Uint8Array
(
bytes
)
;
const
FS
=
fastTextModule
.
FS
;
FS
.
writeFile
(
trainFileInWasmFs
byteArray
)
;
}
)
.
then
(
(
)
=
>
{
const
argsList
=
[
'
lr
'
'
lrUpdateRate
'
'
dim
'
'
ws
'
'
epoch
'
'
minCount
'
'
minCountLabel
'
'
neg
'
'
wordNgrams
'
'
loss
'
'
model
'
'
bucket
'
'
minn
'
'
maxn
'
'
t
'
'
label
'
'
verbose
'
'
pretrainedVectors
'
'
saveOutput
'
'
seed
'
'
qout
'
'
retrain
'
'
qnorm
'
'
cutoff
'
'
dsub
'
'
qnorm
'
'
autotuneValidationFile
'
'
autotuneMetric
'
'
autotunePredictions
'
'
autotuneDuration
'
'
autotuneModelSize
'
]
;
const
args
=
new
fastTextModule
.
Args
(
)
;
argsList
.
forEach
(
k
=
>
{
if
(
k
in
kwargs
)
{
args
[
k
]
=
kwargs
[
k
]
;
}
}
)
;
args
.
model
=
fastTextModule
.
ModelName
[
modelName
]
;
args
.
loss
=
(
'
loss
'
in
kwargs
)
?
fastTextModule
.
LossName
[
kwargs
[
'
loss
'
]
]
:
'
hs
'
;
args
.
thread
=
1
;
args
.
input
=
trainFileInWasmFs
;
fastTextNative
.
train
(
args
callback
)
;
resolve
(
new
FastTextModel
(
fastTextNative
)
)
;
}
)
.
catch
(
error
=
>
{
reject
(
error
)
;
}
)
;
}
)
;
}
trainSupervised
(
url
kwargs
=
{
}
callback
)
{
const
self
=
this
;
return
new
Promise
(
function
(
resolve
reject
)
{
self
.
_train
(
url
'
supervised
'
kwargs
callback
)
.
then
(
model
=
>
{
resolve
(
model
)
;
}
)
.
catch
(
error
=
>
{
reject
(
error
)
;
}
)
;
}
)
;
}
trainUnsupervised
(
url
modelName
kwargs
=
{
}
callback
)
{
const
self
=
this
;
return
new
Promise
(
function
(
resolve
reject
)
{
self
.
_train
(
url
modelName
kwargs
callback
)
.
then
(
model
=
>
{
resolve
(
model
)
;
}
)
.
catch
(
error
=
>
{
reject
(
error
)
;
}
)
;
}
)
;
}
}
class
FastTextModel
{
constructor
(
fastTextNative
)
{
this
.
f
=
fastTextNative
;
}
isQuant
(
)
{
return
this
.
f
.
isQuant
;
}
getDimension
(
)
{
return
this
.
f
.
args
.
dim
;
}
getWordVector
(
word
)
{
const
b
=
getFloat32ArrayFromHeap
(
this
.
getDimension
(
)
)
;
this
.
f
.
getWordVector
(
b
word
)
;
return
heapToFloat32
(
b
)
;
}
getSentenceVector
(
text
)
{
if
(
text
.
indexOf
(
'
\
n
'
)
!
=
-
1
)
{
"
sentence
vector
processes
one
line
at
a
time
(
remove
'
\
\
n
'
)
"
;
}
text
+
=
'
\
n
'
;
const
b
=
getFloat32ArrayFromHeap
(
this
.
getDimension
(
)
)
;
this
.
f
.
getSentenceVector
(
b
text
)
;
return
heapToFloat32
(
b
)
;
}
getNearestNeighbors
(
word
k
=
10
)
{
return
this
.
f
.
getNN
(
word
k
)
;
}
getAnalogies
(
wordA
wordB
wordC
k
)
{
return
this
.
f
.
getAnalogies
(
k
wordA
wordB
wordC
)
;
}
getWordId
(
word
)
{
return
this
.
f
.
getWordId
(
word
)
;
}
getSubwordId
(
subword
)
{
return
this
.
f
.
getSubwordId
(
subword
)
;
}
getSubwords
(
word
)
{
return
this
.
f
.
getSubwords
(
word
)
;
}
getInputVector
(
ind
)
{
const
b
=
getFloat32ArrayFromHeap
(
this
.
getDimension
(
)
)
;
this
.
f
.
getInputVector
(
b
ind
)
;
return
heapToFloat32
(
b
)
;
}
predict
(
text
k
=
1
threshold
=
0
.
0
)
{
return
this
.
f
.
predict
(
text
k
threshold
)
;
}
getInputMatrix
(
)
{
if
(
this
.
isQuant
(
)
)
{
throw
new
Error
(
"
Can
'
t
get
quantized
Matrix
"
)
;
}
return
this
.
f
.
getInputMatrix
(
)
;
}
getOutputMatrix
(
)
{
if
(
this
.
isQuant
(
)
)
{
throw
new
Error
(
"
Can
'
t
get
quantized
Matrix
"
)
;
}
return
this
.
f
.
getOutputMatrix
(
)
;
}
getWords
(
)
{
return
this
.
f
.
getWords
(
)
;
}
getLabels
(
)
{
return
this
.
f
.
getLabels
(
)
;
}
getLine
(
text
)
{
return
this
.
f
.
getLine
(
text
)
;
}
saveModel
(
)
{
this
.
f
.
saveModel
(
modelFileInWasmFs
)
;
const
content
=
fastTextModule
.
FS
.
readFile
(
modelFileInWasmFs
{
encoding
:
'
binary
'
}
)
;
return
new
Blob
(
[
new
Uint8Array
(
content
content
.
byteOffset
content
.
length
)
]
{
type
:
'
application
/
octet
-
stream
'
}
)
;
}
test
(
url
k
threshold
)
{
const
fetchFunc
=
(
thisModule
&
&
thisModule
.
fetch
)
|
|
fetch
;
const
fastTextNative
=
this
.
f
;
return
new
Promise
(
function
(
resolve
reject
)
{
fetchFunc
(
url
)
.
then
(
response
=
>
{
return
response
.
arrayBuffer
(
)
;
}
)
.
then
(
bytes
=
>
{
const
byteArray
=
new
Uint8Array
(
bytes
)
;
const
FS
=
fastTextModule
.
FS
;
FS
.
writeFile
(
testFileInWasmFs
byteArray
)
;
}
)
.
then
(
(
)
=
>
{
const
meter
=
fastTextNative
.
test
(
testFileInWasmFs
k
threshold
)
;
resolve
(
meter
)
;
}
)
.
catch
(
error
=
>
{
reject
(
error
)
;
}
)
;
}
)
;
}
}
