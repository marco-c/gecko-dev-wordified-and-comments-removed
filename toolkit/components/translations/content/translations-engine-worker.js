"
use
strict
"
;
importScripts
(
"
chrome
:
/
/
global
/
content
/
translations
/
bergamot
-
translator
.
js
"
)
;
let
_isLoggingEnabled
=
false
;
function
log
(
.
.
.
args
)
{
if
(
_isLoggingEnabled
)
{
console
.
log
(
"
Translations
:
"
.
.
.
args
)
;
}
}
self
.
addEventListener
(
"
unhandledrejection
"
event
=
>
{
throw
event
.
reason
;
}
)
;
const
MODEL_FILE_ALIGNMENTS
=
{
model
:
256
lex
:
64
vocab
:
64
qualityModel
:
64
srcvocab
:
64
trgvocab
:
64
}
;
addEventListener
(
"
message
"
handleInitializationMessage
)
;
async
function
handleInitializationMessage
(
{
data
}
)
{
if
(
data
.
type
!
=
=
"
initialize
"
)
{
console
.
error
(
"
The
TranslationEngine
worker
received
a
message
before
it
was
initialized
.
"
)
;
return
;
}
try
{
const
{
fromLanguage
toLanguage
enginePayload
isLoggingEnabled
}
=
data
;
if
(
!
fromLanguage
)
{
throw
new
Error
(
'
Worker
initialization
missing
"
fromLanguage
"
'
)
;
}
if
(
!
toLanguage
)
{
throw
new
Error
(
'
Worker
initialization
missing
"
toLanguage
"
'
)
;
}
if
(
isLoggingEnabled
)
{
_isLoggingEnabled
=
true
;
}
let
engine
;
if
(
enginePayload
)
{
const
{
bergamotWasmArrayBuffer
languageModelFiles
}
=
enginePayload
;
const
bergamot
=
await
BergamotUtils
.
initializeWasm
(
bergamotWasmArrayBuffer
)
;
engine
=
new
Engine
(
fromLanguage
toLanguage
bergamot
languageModelFiles
)
;
}
else
{
engine
=
new
MockedEngine
(
fromLanguage
toLanguage
)
;
}
handleMessages
(
engine
)
;
postMessage
(
{
type
:
"
initialization
-
success
"
}
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
postMessage
(
{
type
:
"
initialization
-
error
"
error
:
error
?
.
message
}
)
;
}
removeEventListener
(
"
message
"
handleInitializationMessage
)
;
}
function
handleMessages
(
engine
)
{
addEventListener
(
"
message
"
(
{
data
}
)
=
>
{
try
{
if
(
data
.
type
=
=
=
"
initialize
"
)
{
throw
new
Error
(
"
The
Translations
engine
must
not
be
re
-
initialized
.
"
)
;
}
log
(
"
Received
message
"
data
)
;
switch
(
data
.
type
)
{
case
"
translation
-
request
"
:
{
const
{
messageBatch
messageId
}
=
data
;
try
{
const
translations
=
engine
.
translate
(
messageBatch
)
;
postMessage
(
{
type
:
"
translation
-
response
"
translations
messageId
}
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
let
message
=
"
An
error
occurred
in
the
engine
worker
.
"
;
if
(
typeof
error
?
.
message
=
=
=
"
string
"
)
{
message
=
error
.
message
;
}
let
stack
=
"
(
no
stack
)
"
;
if
(
typeof
error
?
.
stack
=
=
=
"
string
"
)
{
stack
=
error
.
stack
;
}
postMessage
(
{
type
:
"
translation
-
error
"
error
:
{
message
stack
}
messageId
}
)
;
}
break
;
}
default
:
console
.
warn
(
"
Unknown
message
type
:
"
data
.
type
)
;
}
}
catch
(
error
)
{
console
.
error
(
error
)
;
}
}
)
;
}
class
Engine
{
constructor
(
fromLanguage
toLanguage
bergamot
languageTranslationModelFiles
)
{
this
.
fromLanguage
=
fromLanguage
;
this
.
toLanguage
=
toLanguage
;
this
.
bergamot
=
bergamot
;
this
.
languageTranslationModels
=
languageTranslationModelFiles
.
map
(
languageTranslationModelFiles
=
>
BergamotUtils
.
constructSingleTranslationModel
(
bergamot
languageTranslationModelFiles
)
)
;
this
.
translationService
=
new
bergamot
.
BlockingService
(
{
cacheSize
:
0
}
)
;
}
translate
(
messageBatch
withQualityEstimation
=
false
)
{
let
response
;
const
{
messages
options
}
=
BergamotUtils
.
getTranslationArgs
(
this
.
bergamot
messageBatch
withQualityEstimation
)
;
try
{
if
(
messages
.
size
(
)
=
=
=
0
)
{
return
[
]
;
}
let
responses
;
if
(
this
.
languageTranslationModels
.
length
=
=
=
1
)
{
responses
=
this
.
translationService
.
translate
(
this
.
languageTranslationModels
[
0
]
messages
options
)
;
}
else
if
(
this
.
languageTranslationModels
.
length
=
=
=
2
)
{
responses
=
this
.
translationService
.
translateViaPivoting
(
this
.
languageTranslationModels
[
0
]
this
.
languageTranslationModels
[
1
]
messages
options
)
;
}
else
{
throw
new
Error
(
"
Too
many
models
were
provided
to
the
translation
worker
.
"
)
;
}
return
BergamotUtils
.
mapVector
(
responses
response
=
>
response
.
getTranslatedText
(
)
)
;
}
finally
{
messages
?
.
delete
(
)
;
options
?
.
delete
(
)
;
response
?
.
delete
(
)
;
}
}
}
class
BergamotUtils
{
static
constructSingleTranslationModel
(
bergamot
languageTranslationModelFiles
)
{
log
(
Constructing
translation
model
.
)
;
const
{
model
lex
vocab
qualityModel
srcvocab
trgvocab
}
=
BergamotUtils
.
allocateModelMemory
(
bergamot
languageTranslationModelFiles
)
;
const
getMemory
=
memory
=
>
{
Math
.
floor
(
memory
.
size
(
)
/
100_000
)
/
10
}
mb
;
let
memoryLog
=
Model
memory
sizes
in
wasm
heap
:
;
memoryLog
+
=
\
n
Model
:
{
getMemory
(
model
)
}
;
memoryLog
+
=
\
n
Shortlist
:
{
getMemory
(
lex
)
}
;
const
vocabList
=
new
bergamot
.
AlignedMemoryList
(
)
;
if
(
vocab
)
{
vocabList
.
push_back
(
vocab
)
;
memoryLog
+
=
\
n
Vocab
:
{
getMemory
(
vocab
)
}
;
}
else
if
(
srcvocab
&
&
trgvocab
)
{
vocabList
.
push_back
(
srcvocab
)
;
vocabList
.
push_back
(
trgvocab
)
;
memoryLog
+
=
\
n
Src
Vocab
:
{
getMemory
(
srcvocab
)
}
;
memoryLog
+
=
\
n
Trg
Vocab
:
{
getMemory
(
trgvocab
)
}
;
}
else
{
throw
new
Error
(
"
Vocabulary
key
is
not
found
.
"
)
;
}
if
(
qualityModel
)
{
memoryLog
+
=
\
n
QualityModel
:
{
getMemory
(
qualityModel
)
}
\
n
;
}
const
config
=
BergamotUtils
.
generateTextConfig
(
{
"
beam
-
size
"
:
"
1
"
normalize
:
"
1
.
0
"
"
word
-
penalty
"
:
"
0
"
"
max
-
length
-
break
"
:
"
128
"
"
mini
-
batch
-
words
"
:
"
1024
"
workspace
:
"
128
"
"
max
-
length
-
factor
"
:
"
2
.
0
"
"
skip
-
cost
"
:
(
!
qualityModel
)
.
toString
(
)
"
cpu
-
threads
"
:
"
0
"
quiet
:
"
true
"
"
quiet
-
translation
"
:
"
true
"
"
gemm
-
precision
"
:
languageTranslationModelFiles
.
model
.
record
.
name
.
endsWith
(
"
intgemm8
.
bin
"
)
?
"
int8shiftAll
"
:
"
int8shiftAlphaAll
"
alignment
:
"
soft
"
}
)
;
log
(
Bergamot
translation
model
config
:
{
config
}
)
;
log
(
memoryLog
)
;
return
new
bergamot
.
TranslationModel
(
config
model
lex
vocabList
qualityModel
?
?
null
)
;
}
static
allocateModelMemory
(
bergamot
languageTranslationModelFiles
)
{
const
results
=
{
}
;
for
(
const
[
fileType
file
]
of
Object
.
entries
(
languageTranslationModelFiles
)
)
{
const
alignment
=
MODEL_FILE_ALIGNMENTS
[
fileType
]
;
if
(
!
alignment
)
{
throw
new
Error
(
Unknown
file
type
:
"
{
fileType
}
"
)
;
}
const
alignedMemory
=
new
bergamot
.
AlignedMemory
(
file
.
buffer
.
byteLength
alignment
)
;
alignedMemory
.
getByteArrayView
(
)
.
set
(
new
Uint8Array
(
file
.
buffer
)
)
;
results
[
fileType
]
=
alignedMemory
;
}
return
results
;
}
static
initializeWasm
(
wasmBinary
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
start
=
performance
.
now
(
)
;
const
bergamot
=
loadBergamot
(
{
preRun
:
[
]
onAbort
(
)
{
reject
(
new
Error
(
"
Error
loading
Bergamot
wasm
module
.
"
)
)
;
}
onRuntimeInitialized
:
async
(
)
=
>
{
const
duration
=
performance
.
now
(
)
-
start
;
log
(
Bergamot
wasm
runtime
initialized
in
{
duration
/
1000
}
seconds
.
)
;
await
Promise
.
resolve
(
)
;
resolve
(
bergamot
)
;
}
wasmBinary
}
)
;
}
)
;
}
static
mapVector
(
vector
fn
)
{
const
result
=
[
]
;
for
(
let
index
=
0
;
index
<
vector
.
size
(
)
;
index
+
+
)
{
result
.
push
(
fn
(
vector
.
get
(
index
)
index
)
)
;
}
return
result
;
}
static
generateTextConfig
(
config
)
{
const
indent
=
"
"
;
let
result
=
"
\
n
"
;
for
(
const
[
key
value
]
of
Object
.
entries
(
config
)
)
{
result
+
=
{
indent
}
{
key
}
:
{
value
}
\
n
;
}
return
result
+
indent
;
}
static
getTranslationArgs
(
bergamot
messageBatch
withQualityEstimation
)
{
const
messages
=
new
bergamot
.
VectorString
(
)
;
const
options
=
new
bergamot
.
VectorResponseOptions
(
)
;
for
(
const
message
of
messageBatch
)
{
if
(
message
.
trim
(
)
=
=
=
"
"
)
{
continue
;
}
messages
.
push_back
(
message
)
;
options
.
push_back
(
{
qualityScores
:
withQualityEstimation
alignment
:
true
html
:
false
}
)
;
}
return
{
messages
options
}
;
}
}
class
MockedEngine
{
constructor
(
fromLanguage
toLanguage
)
{
this
.
fromLanguage
=
fromLanguage
;
this
.
toLanguage
=
toLanguage
;
}
translate
(
messageBatch
)
{
return
messageBatch
.
map
(
message
=
>
{
message
.
toUpperCase
(
)
}
[
{
this
.
fromLanguage
}
to
{
this
.
toLanguage
}
]
)
;
}
}
