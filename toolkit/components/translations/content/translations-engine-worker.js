"
use
strict
"
;
importScripts
(
"
chrome
:
/
/
global
/
content
/
translations
/
bergamot
-
translator
.
js
"
)
;
let
_isLoggingEnabled
=
false
;
function
log
(
.
.
.
args
)
{
if
(
_isLoggingEnabled
)
{
console
.
log
(
"
Translations
:
"
.
.
.
args
)
;
}
}
self
.
addEventListener
(
"
unhandledrejection
"
event
=
>
{
throw
event
.
reason
;
}
)
;
const
MODEL_FILE_ALIGNMENTS
=
{
model
:
256
lex
:
64
vocab
:
64
qualityModel
:
64
srcvocab
:
64
trgvocab
:
64
}
;
addEventListener
(
"
message
"
handleInitializationMessage
)
;
async
function
handleInitializationMessage
(
{
data
}
)
{
const
startTime
=
performance
.
now
(
)
;
if
(
data
.
type
!
=
=
"
initialize
"
)
{
console
.
error
(
"
The
TranslationEngine
worker
received
a
message
before
it
was
initialized
.
"
)
;
return
;
}
try
{
const
{
fromLanguage
toLanguage
enginePayload
isLoggingEnabled
innerWindowId
}
=
data
;
if
(
!
fromLanguage
)
{
throw
new
Error
(
'
Worker
initialization
missing
"
fromLanguage
"
'
)
;
}
if
(
!
toLanguage
)
{
throw
new
Error
(
'
Worker
initialization
missing
"
toLanguage
"
'
)
;
}
if
(
isLoggingEnabled
)
{
_isLoggingEnabled
=
true
;
}
let
engine
;
if
(
enginePayload
)
{
const
{
bergamotWasmArrayBuffer
languageModelFiles
}
=
enginePayload
;
const
bergamot
=
await
BergamotUtils
.
initializeWasm
(
bergamotWasmArrayBuffer
)
;
engine
=
new
Engine
(
fromLanguage
toLanguage
bergamot
languageModelFiles
)
;
}
else
{
engine
=
new
MockedEngine
(
fromLanguage
toLanguage
)
;
}
ChromeUtils
.
addProfilerMarker
(
"
TranslationsWorker
"
{
startTime
innerWindowId
}
"
Translations
engine
loaded
.
"
)
;
handleMessages
(
engine
)
;
postMessage
(
{
type
:
"
initialization
-
success
"
}
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
postMessage
(
{
type
:
"
initialization
-
error
"
error
:
error
?
.
message
}
)
;
}
removeEventListener
(
"
message
"
handleInitializationMessage
)
;
}
function
handleMessages
(
engine
)
{
let
discardPromise
;
addEventListener
(
"
message
"
async
(
{
data
}
)
=
>
{
try
{
if
(
data
.
type
=
=
=
"
initialize
"
)
{
throw
new
Error
(
"
The
Translations
engine
must
not
be
re
-
initialized
.
"
)
;
}
log
(
"
Received
message
"
data
)
;
switch
(
data
.
type
)
{
case
"
translation
-
request
"
:
{
const
{
messageBatch
messageId
isHTML
innerWindowId
}
=
data
;
if
(
discardPromise
)
{
await
discardPromise
;
}
try
{
const
translations
=
await
engine
.
translate
(
messageBatch
isHTML
innerWindowId
)
;
postMessage
(
{
type
:
"
translation
-
response
"
translations
messageId
}
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
let
message
=
"
An
error
occurred
in
the
engine
worker
.
"
;
if
(
typeof
error
?
.
message
=
=
=
"
string
"
)
{
message
=
error
.
message
;
}
let
stack
=
"
(
no
stack
)
"
;
if
(
typeof
error
?
.
stack
=
=
=
"
string
"
)
{
stack
=
error
.
stack
;
}
postMessage
(
{
type
:
"
translation
-
error
"
error
:
{
message
stack
}
messageId
innerWindowId
}
)
;
}
break
;
}
case
"
discard
-
translation
-
queue
"
:
{
ChromeUtils
.
addProfilerMarker
(
"
TranslationsWorker
"
{
innerWindowId
:
data
.
innerWindowId
}
"
Translations
discard
requested
"
)
;
discardPromise
=
engine
.
discardTranslations
(
)
;
await
discardPromise
;
discardPromise
=
null
;
postMessage
(
{
type
:
"
translations
-
discarded
"
}
)
;
break
;
}
default
:
console
.
warn
(
"
Unknown
message
type
:
"
data
.
type
)
;
}
}
catch
(
error
)
{
console
.
error
(
error
)
;
}
}
)
;
}
class
Engine
{
constructor
(
fromLanguage
toLanguage
bergamot
languageTranslationModelFiles
)
{
this
.
fromLanguage
=
fromLanguage
;
this
.
toLanguage
=
toLanguage
;
this
.
bergamot
=
bergamot
;
this
.
languageTranslationModels
=
languageTranslationModelFiles
.
map
(
languageTranslationModelFiles
=
>
BergamotUtils
.
constructSingleTranslationModel
(
bergamot
languageTranslationModelFiles
)
)
;
this
.
translationService
=
new
bergamot
.
BlockingService
(
{
cacheSize
:
0
}
)
;
}
translate
(
messageBatch
isHTML
innerWindowId
withQualityEstimation
=
false
)
{
return
this
.
#
getWorkQueue
(
innerWindowId
)
.
runTask
(
(
)
=
>
this
.
#
syncTranslate
(
messageBatch
isHTML
innerWindowId
withQualityEstimation
)
)
;
}
#
workQueues
=
new
Map
(
)
;
#
getWorkQueue
(
innerWindowId
)
{
let
workQueue
=
this
.
#
workQueues
.
get
(
innerWindowId
)
;
if
(
workQueue
)
{
return
workQueue
;
}
workQueue
=
new
WorkQueue
(
innerWindowId
)
;
this
.
#
workQueues
.
set
(
innerWindowId
workQueue
)
;
return
workQueue
;
}
discardTranslations
(
innerWindowId
)
{
let
workQueue
=
this
.
#
workQueues
.
get
(
innerWindowId
)
;
if
(
workQueue
)
{
workQueue
.
cancelWork
(
)
;
this
.
#
workQueues
.
delete
(
innerWindowId
)
;
}
}
#
syncTranslate
(
messageBatch
isHTML
innerWindowId
withQualityEstimation
=
false
)
{
const
startTime
=
performance
.
now
(
)
;
let
response
;
const
{
messages
options
}
=
BergamotUtils
.
getTranslationArgs
(
this
.
bergamot
messageBatch
isHTML
withQualityEstimation
)
;
try
{
if
(
messages
.
size
(
)
=
=
=
0
)
{
return
[
]
;
}
let
responses
;
if
(
this
.
languageTranslationModels
.
length
=
=
=
1
)
{
responses
=
this
.
translationService
.
translate
(
this
.
languageTranslationModels
[
0
]
messages
options
)
;
}
else
if
(
this
.
languageTranslationModels
.
length
=
=
=
2
)
{
responses
=
this
.
translationService
.
translateViaPivoting
(
this
.
languageTranslationModels
[
0
]
this
.
languageTranslationModels
[
1
]
messages
options
)
;
}
else
{
throw
new
Error
(
"
Too
many
models
were
provided
to
the
translation
worker
.
"
)
;
}
const
translations
=
BergamotUtils
.
mapVector
(
responses
response
=
>
response
.
getTranslatedText
(
)
)
;
let
length
=
0
;
for
(
const
message
of
messageBatch
)
{
length
+
=
message
.
length
;
}
ChromeUtils
.
addProfilerMarker
(
"
TranslationsWorker
"
{
startTime
innerWindowId
}
Translated
{
length
}
code
units
.
)
;
return
translations
;
}
finally
{
messages
?
.
delete
(
)
;
options
?
.
delete
(
)
;
response
?
.
delete
(
)
;
}
}
}
class
BergamotUtils
{
static
constructSingleTranslationModel
(
bergamot
languageTranslationModelFiles
)
{
log
(
Constructing
translation
model
.
)
;
const
{
model
lex
vocab
qualityModel
srcvocab
trgvocab
}
=
BergamotUtils
.
allocateModelMemory
(
bergamot
languageTranslationModelFiles
)
;
const
getMemory
=
memory
=
>
{
Math
.
floor
(
memory
.
size
(
)
/
100_000
)
/
10
}
mb
;
let
memoryLog
=
Model
memory
sizes
in
wasm
heap
:
;
memoryLog
+
=
\
n
Model
:
{
getMemory
(
model
)
}
;
memoryLog
+
=
\
n
Shortlist
:
{
getMemory
(
lex
)
}
;
const
vocabList
=
new
bergamot
.
AlignedMemoryList
(
)
;
if
(
vocab
)
{
vocabList
.
push_back
(
vocab
)
;
memoryLog
+
=
\
n
Vocab
:
{
getMemory
(
vocab
)
}
;
}
else
if
(
srcvocab
&
&
trgvocab
)
{
vocabList
.
push_back
(
srcvocab
)
;
vocabList
.
push_back
(
trgvocab
)
;
memoryLog
+
=
\
n
Src
Vocab
:
{
getMemory
(
srcvocab
)
}
;
memoryLog
+
=
\
n
Trg
Vocab
:
{
getMemory
(
trgvocab
)
}
;
}
else
{
throw
new
Error
(
"
Vocabulary
key
is
not
found
.
"
)
;
}
if
(
qualityModel
)
{
memoryLog
+
=
\
n
QualityModel
:
{
getMemory
(
qualityModel
)
}
\
n
;
}
const
config
=
BergamotUtils
.
generateTextConfig
(
{
"
beam
-
size
"
:
"
1
"
normalize
:
"
1
.
0
"
"
word
-
penalty
"
:
"
0
"
"
max
-
length
-
break
"
:
"
128
"
"
mini
-
batch
-
words
"
:
"
1024
"
workspace
:
"
128
"
"
max
-
length
-
factor
"
:
"
2
.
0
"
"
skip
-
cost
"
:
(
!
qualityModel
)
.
toString
(
)
"
cpu
-
threads
"
:
"
0
"
quiet
:
"
true
"
"
quiet
-
translation
"
:
"
true
"
"
gemm
-
precision
"
:
languageTranslationModelFiles
.
model
.
record
.
name
.
endsWith
(
"
intgemm8
.
bin
"
)
?
"
int8shiftAll
"
:
"
int8shiftAlphaAll
"
alignment
:
"
soft
"
}
)
;
log
(
Bergamot
translation
model
config
:
{
config
}
)
;
log
(
memoryLog
)
;
return
new
bergamot
.
TranslationModel
(
config
model
lex
vocabList
qualityModel
?
?
null
)
;
}
static
allocateModelMemory
(
bergamot
languageTranslationModelFiles
)
{
const
results
=
{
}
;
for
(
const
[
fileType
file
]
of
Object
.
entries
(
languageTranslationModelFiles
)
)
{
const
alignment
=
MODEL_FILE_ALIGNMENTS
[
fileType
]
;
if
(
!
alignment
)
{
throw
new
Error
(
Unknown
file
type
:
"
{
fileType
}
"
)
;
}
const
alignedMemory
=
new
bergamot
.
AlignedMemory
(
file
.
buffer
.
byteLength
alignment
)
;
alignedMemory
.
getByteArrayView
(
)
.
set
(
new
Uint8Array
(
file
.
buffer
)
)
;
results
[
fileType
]
=
alignedMemory
;
}
return
results
;
}
static
initializeWasm
(
wasmBinary
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
start
=
performance
.
now
(
)
;
const
bergamot
=
loadBergamot
(
{
preRun
:
[
]
onAbort
(
)
{
reject
(
new
Error
(
"
Error
loading
Bergamot
wasm
module
.
"
)
)
;
}
onRuntimeInitialized
:
async
(
)
=
>
{
const
duration
=
performance
.
now
(
)
-
start
;
log
(
Bergamot
wasm
runtime
initialized
in
{
duration
/
1000
}
seconds
.
)
;
await
Promise
.
resolve
(
)
;
resolve
(
bergamot
)
;
}
wasmBinary
}
)
;
}
)
;
}
static
mapVector
(
vector
fn
)
{
const
result
=
[
]
;
for
(
let
index
=
0
;
index
<
vector
.
size
(
)
;
index
+
+
)
{
result
.
push
(
fn
(
vector
.
get
(
index
)
index
)
)
;
}
return
result
;
}
static
generateTextConfig
(
config
)
{
const
indent
=
"
"
;
let
result
=
"
\
n
"
;
for
(
const
[
key
value
]
of
Object
.
entries
(
config
)
)
{
result
+
=
{
indent
}
{
key
}
:
{
value
}
\
n
;
}
return
result
+
indent
;
}
static
getTranslationArgs
(
bergamot
messageBatch
isHTML
withQualityEstimation
)
{
const
messages
=
new
bergamot
.
VectorString
(
)
;
const
options
=
new
bergamot
.
VectorResponseOptions
(
)
;
for
(
let
message
of
messageBatch
)
{
message
=
message
.
trim
(
)
;
if
(
message
=
=
=
"
"
)
{
continue
;
}
if
(
withQualityEstimation
&
&
!
isHTML
)
{
throw
new
Error
(
"
Quality
estimates
on
non
-
hTML
is
not
curently
supported
.
"
)
;
}
messages
.
push_back
(
message
)
;
options
.
push_back
(
{
qualityScores
:
withQualityEstimation
alignment
:
true
html
:
isHTML
}
)
;
}
return
{
messages
options
}
;
}
}
class
MockedEngine
{
constructor
(
fromLanguage
toLanguage
)
{
this
.
fromLanguage
=
fromLanguage
;
this
.
toLanguage
=
toLanguage
;
}
translate
(
messageBatch
isHTML
)
{
return
messageBatch
.
map
(
message
=
>
{
let
html
=
isHTML
?
"
html
"
:
"
"
;
message
=
message
.
toUpperCase
(
)
;
return
{
message
}
[
{
this
.
fromLanguage
}
to
{
this
.
toLanguage
}
{
html
}
]
;
}
)
;
}
}
class
WorkQueue
{
#
TIME_BUDGET
=
100
;
/
/
ms
#
RUN_IMMEDIATELY_COUNT
=
20
;
#
tasks
=
[
]
;
#
isRunning
=
false
;
#
isWorkCancelled
=
false
;
#
runImmediately
=
this
.
#
RUN_IMMEDIATELY_COUNT
;
constructor
(
innerWindowId
)
{
this
.
innerWindowId
=
innerWindowId
;
}
runTask
(
task
)
{
if
(
this
.
#
runImmediately
>
0
)
{
this
.
#
runImmediately
-
-
;
return
Promise
.
resolve
(
task
(
)
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
#
tasks
.
push
(
{
task
resolve
reject
}
)
;
this
.
#
run
(
)
.
catch
(
error
=
>
console
.
error
(
error
)
)
;
}
)
;
}
async
#
run
(
)
{
if
(
this
.
#
isRunning
)
{
return
;
}
this
.
#
isRunning
=
true
;
let
lastTimeout
=
null
;
let
tasksInBatch
=
0
;
const
addProfilerMarker
=
(
)
=
>
{
ChromeUtils
.
addProfilerMarker
(
"
TranslationsWorker
WorkQueue
"
{
startTime
:
lastTimeout
innerWindowId
:
this
.
innerWindowId
}
WorkQueue
processed
{
tasksInBatch
}
tasks
)
;
}
;
while
(
this
.
#
tasks
.
length
!
=
=
0
)
{
if
(
this
.
#
isWorkCancelled
)
{
break
;
}
const
now
=
performance
.
now
(
)
;
if
(
lastTimeout
=
=
=
null
)
{
lastTimeout
=
now
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
else
if
(
now
-
lastTimeout
>
this
.
#
TIME_BUDGET
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
addProfilerMarker
(
)
;
lastTimeout
=
performance
.
now
(
)
;
}
if
(
this
.
#
isWorkCancelled
)
{
break
;
}
tasksInBatch
+
+
;
const
{
task
resolve
reject
}
=
this
.
#
tasks
.
shift
(
)
;
try
{
const
result
=
await
task
(
)
;
if
(
this
.
#
isWorkCancelled
)
{
break
;
}
resolve
(
result
)
;
}
catch
(
error
)
{
reject
(
error
)
;
}
}
addProfilerMarker
(
)
;
this
.
isRunning
=
false
;
}
async
cancelWork
(
)
{
this
.
#
isWorkCancelled
=
true
;
this
.
#
tasks
=
[
]
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
this
.
#
isWorkCancelled
=
false
;
}
}
