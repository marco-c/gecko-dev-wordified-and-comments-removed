"
use
strict
"
;
importScripts
(
"
chrome
:
/
/
global
/
content
/
translations
/
bergamot
-
translator
.
js
"
)
;
let
_loggingLevel
=
"
Error
"
;
function
log
(
.
.
.
args
)
{
if
(
_loggingLevel
!
=
=
"
Error
"
&
&
_loggingLevel
!
=
=
"
Warn
"
)
{
console
.
log
(
"
Translations
:
"
.
.
.
args
)
;
}
}
function
trace
(
.
.
.
args
)
{
if
(
_loggingLevel
=
=
=
"
Trace
"
|
|
_loggingLevel
=
=
=
"
All
"
)
{
console
.
log
(
"
Translations
:
"
.
.
.
args
)
;
}
}
self
.
addEventListener
(
"
unhandledrejection
"
event
=
>
{
throw
event
.
reason
;
}
)
;
const
MODEL_FILE_ALIGNMENTS
=
{
model
:
256
lex
:
64
vocab
:
64
qualityModel
:
64
srcvocab
:
64
trgvocab
:
64
}
;
const
WHITESPACE_REGEX
=
/
^
(
\
s
*
)
(
.
*
?
)
(
\
s
*
)
/
s
;
const
FULL_WIDTH_PUNCTUATION_REGEX
=
/
(
[
]
)
/
g
;
const
FULL_WIDTH_PUNCTUATION_LANGUAGE_TAGS
=
[
"
ja
"
"
ko
"
"
zh
"
]
;
function
cleanText
(
sourceLanguage
sourceText
)
{
const
result
=
WHITESPACE_REGEX
.
exec
(
sourceText
)
;
if
(
!
result
)
{
throw
new
Error
(
"
The
whitespace
regex
should
always
return
a
result
.
"
)
;
}
const
whitespaceBefore
=
result
[
1
]
;
const
whitespaceAfter
=
result
[
3
]
;
let
cleanedSourceText
=
result
[
2
]
;
cleanedSourceText
=
cleanedSourceText
.
replaceAll
(
"
\
u00AD
"
"
"
)
;
if
(
FULL_WIDTH_PUNCTUATION_LANGUAGE_TAGS
.
includes
(
sourceLanguage
)
)
{
cleanedSourceText
=
cleanedSourceText
.
replaceAll
(
FULL_WIDTH_PUNCTUATION_REGEX
"
1
"
)
;
}
return
{
whitespaceBefore
whitespaceAfter
cleanedSourceText
}
;
}
addEventListener
(
"
message
"
handleInitializationMessage
)
;
async
function
handleInitializationMessage
(
{
data
}
)
{
const
startTime
=
ChromeUtils
.
now
(
)
;
if
(
data
.
type
!
=
=
"
initialize
"
)
{
console
.
error
(
"
The
TranslationEngine
worker
received
a
message
before
it
was
initialized
.
"
)
;
return
;
}
try
{
const
{
sourceLanguage
targetLanguage
enginePayload
logLevel
innerWindowId
}
=
data
;
if
(
!
sourceLanguage
)
{
throw
new
Error
(
'
Worker
initialization
missing
"
sourceLanguage
"
'
)
;
}
if
(
!
targetLanguage
)
{
throw
new
Error
(
'
Worker
initialization
missing
"
targetLanguage
"
'
)
;
}
if
(
logLevel
)
{
_loggingLevel
=
logLevel
;
}
let
engine
;
if
(
enginePayload
.
isMocked
)
{
engine
=
new
MockedEngine
(
sourceLanguage
targetLanguage
)
;
}
else
{
const
{
bergamotWasmArrayBuffer
translationModelPayloads
}
=
enginePayload
;
const
bergamot
=
await
BergamotUtils
.
initializeWasm
(
bergamotWasmArrayBuffer
)
;
engine
=
new
Engine
(
sourceLanguage
targetLanguage
bergamot
translationModelPayloads
)
;
bergamotWasmArrayBuffer
.
transfer
(
)
;
for
(
const
{
languageModelFiles
}
of
translationModelPayloads
)
{
for
(
const
file
of
Object
.
values
(
languageModelFiles
)
)
{
file
.
buffer
.
transfer
(
)
;
}
}
}
ChromeUtils
.
addProfilerMarker
(
"
TranslationsWorker
"
{
startTime
innerWindowId
}
"
Translations
engine
loaded
.
"
)
;
handleMessages
(
engine
)
;
postMessage
(
{
type
:
"
initialization
-
success
"
}
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
postMessage
(
{
type
:
"
initialization
-
error
"
error
:
error
?
.
message
}
)
;
}
removeEventListener
(
"
message
"
handleInitializationMessage
)
;
}
function
handleMessages
(
engine
)
{
let
discardPromise
;
addEventListener
(
"
message
"
async
(
{
data
}
)
=
>
{
try
{
if
(
data
.
type
=
=
=
"
initialize
"
)
{
throw
new
Error
(
"
The
Translations
engine
must
not
be
re
-
initialized
.
"
)
;
}
if
(
data
.
type
=
=
=
"
translation
-
request
"
)
{
trace
(
"
Received
message
"
data
)
;
}
else
{
log
(
"
Received
message
"
data
)
;
}
switch
(
data
.
type
)
{
case
"
translation
-
request
"
:
{
const
{
sourceText
messageId
translationId
isHTML
innerWindowId
}
=
data
;
if
(
discardPromise
)
{
await
discardPromise
;
}
try
{
const
{
whitespaceBefore
whitespaceAfter
cleanedSourceText
}
=
cleanText
(
engine
.
sourceLanguage
sourceText
)
;
let
{
targetText
inferenceMilliseconds
}
=
await
engine
.
translate
(
cleanedSourceText
isHTML
innerWindowId
translationId
)
;
targetText
=
whitespaceBefore
+
targetText
+
whitespaceAfter
;
trace
(
"
Translation
complete
"
{
sourceText
targetText
isHTML
innerWindowId
}
)
;
postMessage
(
{
type
:
"
translation
-
response
"
targetText
inferenceMilliseconds
translationId
messageId
}
)
;
}
catch
(
error
)
{
console
.
error
(
error
)
;
let
message
=
"
An
error
occurred
in
the
engine
worker
.
"
;
if
(
typeof
error
?
.
message
=
=
=
"
string
"
)
{
message
=
error
.
message
;
}
let
stack
=
"
(
no
stack
)
"
;
if
(
typeof
error
?
.
stack
=
=
=
"
string
"
)
{
stack
=
error
.
stack
;
}
postMessage
(
{
type
:
"
translation
-
error
"
error
:
{
message
stack
}
messageId
innerWindowId
}
)
;
}
break
;
}
case
"
discard
-
translation
-
queue
"
:
{
ChromeUtils
.
addProfilerMarker
(
"
TranslationsWorker
"
{
innerWindowId
:
data
.
innerWindowId
}
"
Translations
discard
requested
"
)
;
discardPromise
=
engine
.
discardTranslations
(
data
.
innerWindowId
)
;
await
discardPromise
;
discardPromise
=
null
;
postMessage
(
{
type
:
"
translations
-
discarded
"
}
)
;
break
;
}
case
"
cancel
-
single
-
translation
"
:
{
engine
.
discardSingleTranslation
(
data
.
innerWindowId
data
.
translationId
)
;
break
;
}
default
:
console
.
warn
(
"
Unknown
message
type
:
"
data
.
type
)
;
}
}
catch
(
error
)
{
console
.
error
(
error
)
;
}
}
)
;
}
class
Engine
{
constructor
(
sourceLanguage
targetLanguage
bergamot
translationModelPayloads
)
{
this
.
sourceLanguage
=
sourceLanguage
;
this
.
targetLanguage
=
targetLanguage
;
this
.
bergamot
=
bergamot
;
this
.
languageTranslationModels
=
translationModelPayloads
.
map
(
translationModelPayload
=
>
BergamotUtils
.
constructSingleTranslationModel
(
bergamot
translationModelPayload
)
)
;
this
.
translationService
=
new
bergamot
.
BlockingService
(
{
cacheSize
:
0
}
)
;
}
translate
(
sourceText
isHTML
innerWindowId
translationId
)
{
return
this
.
#
getWorkQueue
(
innerWindowId
)
.
runTask
(
translationId
(
)
=
>
this
.
#
syncTranslate
(
sourceText
isHTML
innerWindowId
)
)
;
}
#
workQueues
=
new
Map
(
)
;
#
getWorkQueue
(
innerWindowId
)
{
let
workQueue
=
this
.
#
workQueues
.
get
(
innerWindowId
)
;
if
(
workQueue
)
{
return
workQueue
;
}
workQueue
=
new
WorkQueue
(
innerWindowId
)
;
this
.
#
workQueues
.
set
(
innerWindowId
workQueue
)
;
return
workQueue
;
}
discardTranslations
(
innerWindowId
)
{
let
workQueue
=
this
.
#
workQueues
.
get
(
innerWindowId
)
;
if
(
workQueue
)
{
workQueue
.
cancelWork
(
)
;
this
.
#
workQueues
.
delete
(
innerWindowId
)
;
}
}
discardSingleTranslation
(
innerWindowId
translationId
)
{
const
workQueue
=
this
.
#
workQueues
.
get
(
innerWindowId
)
;
if
(
workQueue
)
{
trace
(
"
Discarding
translation
with
translationId
"
translationId
)
;
workQueue
.
cancelTask
(
translationId
)
;
}
}
#
syncTranslate
(
sourceText
isHTML
innerWindowId
)
{
const
startTime
=
ChromeUtils
.
now
(
)
;
let
response
;
const
{
messages
options
}
=
BergamotUtils
.
getTranslationArgs
(
this
.
bergamot
sourceText
isHTML
)
;
try
{
if
(
messages
.
size
(
)
=
=
=
0
)
{
return
[
]
;
}
let
responses
;
if
(
this
.
languageTranslationModels
.
length
=
=
=
1
)
{
responses
=
this
.
translationService
.
translate
(
this
.
languageTranslationModels
[
0
]
messages
options
)
;
}
else
if
(
this
.
languageTranslationModels
.
length
=
=
=
2
)
{
responses
=
this
.
translationService
.
translateViaPivoting
(
this
.
languageTranslationModels
[
0
]
this
.
languageTranslationModels
[
1
]
messages
options
)
;
}
else
{
throw
new
Error
(
"
Too
many
models
were
provided
to
the
translation
worker
.
"
)
;
}
ChromeUtils
.
addProfilerMarker
(
"
TranslationsWorker
"
{
startTime
innerWindowId
}
Translated
{
sourceText
.
length
}
code
units
.
)
;
const
endTime
=
ChromeUtils
.
now
(
)
;
const
targetText
=
responses
.
get
(
0
)
.
getTranslatedText
(
)
;
return
{
targetText
inferenceMilliseconds
:
endTime
-
startTime
}
;
}
finally
{
messages
?
.
delete
(
)
;
options
?
.
delete
(
)
;
response
?
.
delete
(
)
;
}
}
}
class
BergamotUtils
{
static
constructSingleTranslationModel
(
bergamot
translationModelPayload
)
{
log
(
Constructing
translation
model
.
)
;
const
{
sourceLanguage
targetLanguage
languageModelFiles
}
=
translationModelPayload
;
const
{
model
lex
vocab
qualityModel
srcvocab
trgvocab
}
=
BergamotUtils
.
allocateModelMemory
(
bergamot
languageModelFiles
)
;
const
getMemory
=
memory
=
>
{
Math
.
floor
(
memory
.
size
(
)
/
100_000
)
/
10
}
mb
;
let
memoryLog
=
Model
memory
sizes
in
wasm
heap
:
;
memoryLog
+
=
\
n
Model
:
{
getMemory
(
model
)
}
;
if
(
lex
)
{
memoryLog
+
=
\
n
Shortlist
:
{
getMemory
(
lex
)
}
;
}
const
vocabList
=
new
bergamot
.
AlignedMemoryList
(
)
;
if
(
vocab
)
{
vocabList
.
push_back
(
vocab
)
;
memoryLog
+
=
\
n
Vocab
:
{
getMemory
(
vocab
)
}
;
}
else
if
(
srcvocab
&
&
trgvocab
)
{
vocabList
.
push_back
(
srcvocab
)
;
vocabList
.
push_back
(
trgvocab
)
;
memoryLog
+
=
\
n
Src
Vocab
:
{
getMemory
(
srcvocab
)
}
;
memoryLog
+
=
\
n
Trg
Vocab
:
{
getMemory
(
trgvocab
)
}
;
}
else
{
throw
new
Error
(
"
Vocabulary
key
is
not
found
.
"
)
;
}
if
(
qualityModel
)
{
memoryLog
+
=
\
n
QualityModel
:
{
getMemory
(
qualityModel
)
}
\
n
;
}
const
config
=
BergamotUtils
.
generateTextConfig
(
{
"
beam
-
size
"
:
"
1
"
normalize
:
"
1
.
0
"
"
word
-
penalty
"
:
"
0
"
"
max
-
length
-
break
"
:
"
128
"
"
mini
-
batch
-
words
"
:
"
1024
"
workspace
:
"
128
"
"
max
-
length
-
factor
"
:
"
2
.
0
"
"
skip
-
cost
"
:
(
!
qualityModel
)
.
toString
(
)
"
cpu
-
threads
"
:
"
0
"
quiet
:
"
true
"
"
quiet
-
translation
"
:
"
true
"
"
gemm
-
precision
"
:
languageModelFiles
.
model
.
record
.
name
.
endsWith
(
"
intgemm8
.
bin
"
)
?
"
int8shiftAll
"
:
"
int8shiftAlphaAll
"
alignment
:
"
soft
"
}
)
;
log
(
Bergamot
translation
model
config
:
{
config
}
)
;
log
(
memoryLog
)
;
return
new
bergamot
.
TranslationModel
(
sourceLanguage
targetLanguage
config
model
lex
?
?
null
vocabList
qualityModel
?
?
null
)
;
}
static
allocateModelMemory
(
bergamot
languageModelFiles
)
{
const
results
=
{
}
;
for
(
const
[
fileType
file
]
of
Object
.
entries
(
languageModelFiles
)
)
{
const
alignment
=
MODEL_FILE_ALIGNMENTS
[
fileType
]
;
if
(
!
alignment
)
{
throw
new
Error
(
Unknown
file
type
:
"
{
fileType
}
"
)
;
}
const
alignedMemory
=
new
bergamot
.
AlignedMemory
(
file
.
buffer
.
byteLength
alignment
)
;
alignedMemory
.
getByteArrayView
(
)
.
set
(
new
Uint8Array
(
file
.
buffer
)
)
;
results
[
fileType
]
=
alignedMemory
;
}
return
results
;
}
static
initializeWasm
(
wasmBinary
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
start
=
performance
.
now
(
)
;
const
bergamot
=
loadBergamot
(
{
INITIAL_MEMORY
:
234_291_200
print
:
log
onAbort
(
)
{
reject
(
new
Error
(
"
Error
loading
Bergamot
wasm
module
.
"
)
)
;
}
onRuntimeInitialized
:
async
(
)
=
>
{
const
duration
=
performance
.
now
(
)
-
start
;
log
(
Bergamot
wasm
runtime
initialized
in
{
duration
/
1000
}
seconds
.
)
;
await
Promise
.
resolve
(
)
;
resolve
(
bergamot
)
;
}
wasmBinary
}
)
;
}
)
;
}
static
mapVector
(
vector
fn
)
{
const
result
=
[
]
;
for
(
let
index
=
0
;
index
<
vector
.
size
(
)
;
index
+
+
)
{
result
.
push
(
fn
(
vector
.
get
(
index
)
index
)
)
;
}
return
result
;
}
static
generateTextConfig
(
config
)
{
const
indent
=
"
"
;
let
result
=
"
\
n
"
;
for
(
const
[
key
value
]
of
Object
.
entries
(
config
)
)
{
result
+
=
{
indent
}
{
key
}
:
{
value
}
\
n
;
}
return
result
+
indent
;
}
static
getTranslationArgs
(
bergamot
sourceText
isHTML
)
{
const
messages
=
new
bergamot
.
VectorString
(
)
;
const
options
=
new
bergamot
.
VectorResponseOptions
(
)
;
if
(
sourceText
)
{
messages
.
push_back
(
sourceText
)
;
options
.
push_back
(
{
qualityScores
:
false
alignment
:
true
html
:
isHTML
}
)
;
}
return
{
messages
options
}
;
}
}
class
MockedEngine
{
constructor
(
sourceLanguage
targetLanguage
)
{
this
.
sourceLanguage
=
sourceLanguage
;
this
.
targetLanguage
=
targetLanguage
;
}
translate
(
sourceText
isHTML
)
{
const
startTime
=
performance
.
now
(
)
;
let
html
=
isHTML
?
"
html
"
:
"
"
;
const
targetText
=
{
sourceText
.
toUpperCase
(
)
}
[
{
this
.
sourceLanguage
}
to
{
this
.
targetLanguage
}
{
html
}
]
;
const
endTime
=
performance
.
now
(
)
;
return
{
targetText
inferenceMilliseconds
:
endTime
-
startTime
}
;
}
discardTranslations
(
)
{
}
}
class
WorkQueue
{
#
TIME_BUDGET
=
100
;
/
/
ms
#
RUN_IMMEDIATELY_COUNT
=
20
;
#
tasksByTranslationId
=
new
Map
(
)
;
#
isRunning
=
false
;
#
isWorkCancelled
=
false
;
#
runImmediately
=
this
.
#
RUN_IMMEDIATELY_COUNT
;
constructor
(
innerWindowId
)
{
this
.
innerWindowId
=
innerWindowId
;
}
runTask
(
translationId
task
)
{
if
(
this
.
#
runImmediately
>
0
)
{
this
.
#
runImmediately
-
-
;
return
Promise
.
resolve
(
task
(
)
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
#
tasksByTranslationId
.
set
(
translationId
{
task
resolve
reject
}
)
;
this
.
#
run
(
)
.
catch
(
error
=
>
console
.
error
(
error
)
)
;
}
)
;
}
cancelTask
(
translationId
)
{
this
.
#
tasksByTranslationId
.
delete
(
translationId
)
;
}
async
#
run
(
)
{
if
(
this
.
#
isRunning
)
{
return
;
}
this
.
#
isRunning
=
true
;
let
lastTimeout
=
null
;
let
tasksInBatch
=
0
;
const
addProfilerMarker
=
(
)
=
>
{
ChromeUtils
.
addProfilerMarker
(
"
TranslationsWorker
WorkQueue
"
{
startTime
:
lastTimeout
innerWindowId
:
this
.
innerWindowId
}
WorkQueue
processed
{
tasksInBatch
}
tasks
)
;
}
;
while
(
this
.
#
tasksByTranslationId
.
size
)
{
if
(
this
.
#
isWorkCancelled
)
{
break
;
}
const
now
=
ChromeUtils
.
now
(
)
;
if
(
lastTimeout
=
=
=
null
)
{
lastTimeout
=
now
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
else
if
(
now
-
lastTimeout
>
this
.
#
TIME_BUDGET
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
addProfilerMarker
(
)
;
lastTimeout
=
ChromeUtils
.
now
(
)
;
}
if
(
this
.
#
isWorkCancelled
|
|
!
this
.
#
tasksByTranslationId
.
size
)
{
break
;
}
tasksInBatch
+
+
;
const
[
translationId
taskAndResolvers
]
=
this
.
#
tasksByTranslationId
.
entries
(
)
.
next
(
)
.
value
;
const
{
task
resolve
reject
}
=
taskAndResolvers
;
this
.
#
tasksByTranslationId
.
delete
(
translationId
)
;
try
{
const
result
=
await
task
(
)
;
if
(
this
.
#
isWorkCancelled
)
{
break
;
}
resolve
(
result
)
;
}
catch
(
error
)
{
reject
(
error
)
;
}
}
addProfilerMarker
(
)
;
this
.
#
isRunning
=
false
;
}
async
cancelWork
(
)
{
this
.
#
isWorkCancelled
=
true
;
this
.
#
tasksByTranslationId
=
new
Map
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
this
.
#
isWorkCancelled
=
false
;
}
}
