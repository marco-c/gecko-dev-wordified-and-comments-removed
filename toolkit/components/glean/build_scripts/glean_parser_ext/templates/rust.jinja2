{
#
The
rendered
source
is
autogenerated
but
this
Jinja2
template
is
not
.
Please
file
bugs
!
#
}
{
%
macro
generate_extra_keys
(
obj
)
%
}
{
%
for
name
suffix
in
obj
[
"
_generate_enums
"
]
%
}
{
%
if
obj
|
attr
(
name
)
|
length
%
}
#
[
derive
(
Clone
Copy
Hash
Eq
PartialEq
)
]
pub
enum
{
{
obj
.
name
|
Camelize
}
}
{
{
suffix
}
}
{
{
%
for
key
in
obj
|
attr
(
name
)
%
}
{
{
key
|
Camelize
}
}
{
%
endfor
%
}
}
impl
ExtraKeys
for
{
{
obj
.
name
|
Camelize
}
}
{
{
suffix
}
}
{
const
ALLOWED_KEYS
:
&
'
static
[
&
'
static
str
]
=
{
{
obj
.
allowed_extra_keys
|
extra_keys
}
}
;
fn
index
(
self
)
-
>
i32
{
self
as
i32
}
}
impl
std
:
:
convert
:
:
TryFrom
<
i32
>
for
{
{
obj
.
name
|
Camelize
}
}
{
{
suffix
}
}
{
type
Error
=
EventRecordingError
;
fn
try_from
(
value
:
i32
)
-
>
Result
<
Self
Self
:
:
Error
>
{
match
value
{
{
%
for
key
in
obj
|
attr
(
name
)
%
}
{
{
loop
.
index
-
1
}
}
=
>
Ok
(
Self
:
:
{
{
key
|
Camelize
}
}
)
{
%
endfor
%
}
_
=
>
Err
(
EventRecordingError
:
:
InvalidExtraKey
)
}
}
}
impl
std
:
:
convert
:
:
TryFrom
<
&
str
>
for
{
{
obj
.
name
|
Camelize
}
}
{
{
suffix
}
}
{
type
Error
=
EventRecordingError
;
fn
try_from
(
value
:
&
str
)
-
>
Result
<
Self
Self
:
:
Error
>
{
match
value
{
{
%
for
key
in
obj
|
attr
(
name
)
%
}
"
{
{
key
}
}
"
=
>
Ok
(
Self
:
:
{
{
key
|
Camelize
}
}
)
{
%
endfor
%
}
_
=
>
Err
(
EventRecordingError
:
:
InvalidExtraKey
)
}
}
}
{
%
endif
%
}
{
%
endfor
%
}
{
%
endmacro
%
}
{
%
for
category_name
objs
in
all_objs
.
items
(
)
%
}
pub
mod
{
{
category_name
|
snake_case
}
}
{
use
crate
:
:
private
:
:
*
;
use
glean
:
:
CommonMetricData
;
use
once_cell
:
:
sync
:
:
Lazy
;
{
%
for
obj
in
objs
.
values
(
)
%
}
{
%
if
obj
|
attr
(
"
_generate_enums
"
)
%
}
{
{
generate_extra_keys
(
obj
)
}
}
{
%
-
endif
%
}
#
[
allow
(
non_upper_case_globals
)
]
pub
static
{
{
obj
.
name
|
snake_case
}
}
:
Lazy
<
{
{
obj
|
type_name
}
}
>
=
Lazy
:
:
new
(
|
|
{
{
{
obj
|
ctor
}
}
(
{
{
obj
|
metric_id
}
}
.
into
(
)
CommonMetricData
{
{
%
for
arg_name
in
common_metric_data_args
if
obj
[
arg_name
]
is
defined
%
}
{
{
arg_name
}
}
:
{
{
obj
[
arg_name
]
|
rust
}
}
{
%
endfor
%
}
.
.
Default
:
:
default
(
)
}
{
%
-
for
arg_name
in
extra_args
if
obj
[
arg_name
]
is
defined
and
arg_name
not
in
common_metric_data_args
and
arg_name
!
=
'
allowed_extra_keys
'
-
%
}
{
{
obj
[
arg_name
]
|
rust
}
}
{
%
-
endfor
-
%
}
{
{
"
"
if
obj
.
labeled
else
"
)
\
n
"
}
}
{
%
-
if
obj
.
labeled
-
%
}
{
%
-
if
obj
.
labels
-
%
}
Some
(
{
{
obj
.
labels
|
rust
}
}
)
{
%
-
else
-
%
}
None
{
%
-
endif
-
%
}
)
{
%
endif
%
}
}
)
;
{
%
endfor
%
}
}
{
%
endfor
%
}
{
%
if
metric_by_type
|
length
>
0
%
}
#
[
allow
(
dead_code
)
]
pub
(
crate
)
mod
__glean_metric_maps
{
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
convert
:
:
TryInto
;
use
crate
:
:
private
:
:
*
;
use
once_cell
:
:
sync
:
:
Lazy
;
{
%
for
typ
metrics
in
metric_by_type
.
items
(
)
%
}
pub
static
{
{
typ
.
0
}
}
:
Lazy
<
HashMap
<
MetricId
&
Lazy
<
{
{
typ
.
1
}
}
>
>
>
=
Lazy
:
:
new
(
|
|
{
let
mut
map
=
HashMap
:
:
with_capacity
(
{
{
metrics
|
length
}
}
)
;
{
%
for
metric
in
metrics
%
}
map
.
insert
(
{
{
metric
.
0
}
}
.
into
(
)
&
super
:
:
{
{
metric
.
1
}
}
)
;
{
%
endfor
%
}
map
}
)
;
{
%
endfor
%
}
fn
extra_keys_len
<
K
:
ExtraKeys
>
(
_event
:
&
EventMetric
<
K
>
)
-
>
usize
{
K
:
:
ALLOWED_KEYS
.
len
(
)
}
pub
(
crate
)
fn
record_event_by_id
(
metric_id
:
u32
extra
:
HashMap
<
i32
String
>
)
-
>
Result
<
(
)
EventRecordingError
>
{
match
metric_id
{
{
%
for
metric_id
event
in
events_by_id
.
items
(
)
%
}
{
{
metric_id
}
}
=
>
{
assert
!
(
extra_keys_len
(
&
super
:
:
{
{
event
}
}
)
!
=
0
|
|
extra
.
is_empty
(
)
"
No
extra
keys
allowed
but
some
were
passed
"
)
;
#
[
allow
(
unused_variables
)
]
let
extra
:
HashMap
<
_
_
>
=
extra
.
into_iter
(
)
.
map
(
|
(
k
v
)
|
k
.
try_into
(
)
.
map
(
|
k
|
(
k
v
)
)
)
.
collect
:
:
<
Result
<
HashMap
<
_
_
>
_
>
>
(
)
?
;
super
:
:
{
{
event
}
}
.
record
(
Some
(
extra
)
)
;
Ok
(
(
)
)
}
{
%
endfor
%
}
_
=
>
Err
(
EventRecordingError
:
:
InvalidId
)
}
}
pub
(
crate
)
fn
record_event_by_id_with_time
(
metric_id
:
MetricId
timestamp
:
u64
extra
:
HashMap
<
i32
String
>
)
-
>
Result
<
(
)
EventRecordingError
>
{
match
metric_id
{
{
%
for
metric_id
event
in
events_by_id
.
items
(
)
%
}
MetricId
(
{
{
metric_id
}
}
)
=
>
{
if
extra_keys_len
(
&
super
:
:
{
{
event
}
}
)
=
=
0
&
&
!
extra
.
is_empty
(
)
{
return
Err
(
EventRecordingError
:
:
InvalidExtraKey
)
;
}
super
:
:
{
{
event
}
}
.
record_with_time
(
timestamp
extra
)
;
Ok
(
(
)
)
}
{
%
endfor
%
}
_
=
>
Err
(
EventRecordingError
:
:
InvalidId
)
}
}
pub
(
crate
)
fn
record_event_by_id_with_strings
(
metric_id
:
u32
extra
:
HashMap
<
String
String
>
)
-
>
Result
<
(
)
EventRecordingError
>
{
match
metric_id
{
{
%
for
metric_id
event
in
events_by_id
.
items
(
)
%
}
{
{
metric_id
}
}
=
>
{
assert
!
(
extra_keys_len
(
&
super
:
:
{
{
event
}
}
)
!
=
0
|
|
extra
.
is_empty
(
)
"
No
extra
keys
allowed
but
some
were
passed
"
)
;
#
[
allow
(
unused_variables
)
]
let
extra
=
extra
.
into_iter
(
)
.
map
(
|
(
k
v
)
|
(
&
*
k
)
.
try_into
(
)
.
map
(
|
k
|
(
k
v
)
)
)
.
collect
:
:
<
Result
<
HashMap
<
_
_
>
_
>
>
(
)
?
;
super
:
:
{
{
event
}
}
.
record
(
Some
(
extra
)
)
;
Ok
(
(
)
)
}
{
%
endfor
%
}
_
=
>
Err
(
EventRecordingError
:
:
InvalidId
)
}
}
pub
(
crate
)
fn
event_test_get_value_wrapper
(
metric_id
:
u32
ping_name
:
Option
<
String
>
)
-
>
Option
<
Vec
<
RecordedEvent
>
>
{
match
metric_id
{
{
%
for
metric_id
event
in
events_by_id
.
items
(
)
%
}
{
{
metric_id
}
}
=
>
super
:
:
{
{
event
}
}
.
test_get_value
(
ping_name
.
as_deref
(
)
)
{
%
endfor
%
}
_
=
>
panic
!
(
"
No
event
for
metric
id
{
}
"
metric_id
)
}
}
pub
(
crate
)
mod
submetric_maps
{
use
std
:
:
sync
:
:
{
atomic
:
:
AtomicU32
RwLock
}
;
use
super
:
:
*
;
pub
(
crate
)
const
MIN_LABELED_SUBMETRIC_ID
:
u32
=
{
{
min_submetric_id
}
}
;
pub
(
crate
)
static
NEXT_LABELED_SUBMETRIC_ID
:
AtomicU32
=
AtomicU32
:
:
new
(
MIN_LABELED_SUBMETRIC_ID
)
;
pub
(
crate
)
static
LABELED_METRICS_TO_IDS
:
Lazy
<
RwLock
<
HashMap
<
(
u32
String
)
u32
>
>
>
=
Lazy
:
:
new
(
|
|
RwLock
:
:
new
(
HashMap
:
:
new
(
)
)
)
;
{
%
for
typ
metrics
in
metric_by_type
.
items
(
)
%
}
{
%
if
typ
.
0
in
(
'
BOOLEAN_MAP
'
'
COUNTER_MAP
'
'
STRING_MAP
'
)
%
}
pub
static
{
{
typ
.
0
}
}
:
Lazy
<
RwLock
<
HashMap
<
MetricId
Labeled
{
{
typ
.
1
}
}
>
>
>
=
Lazy
:
:
new
(
|
|
RwLock
:
:
new
(
HashMap
:
:
new
(
)
)
)
;
{
%
endif
%
}
{
%
endfor
%
}
}
}
{
%
endif
%
}
