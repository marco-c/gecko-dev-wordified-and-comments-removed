{
#
The
rendered
source
is
autogenerated
but
this
Jinja2
template
is
not
.
Please
file
bugs
!
#
}
#
ifndef
mozilla_GleanJSMetricsLookup_h
#
define
mozilla_GleanJSMetricsLookup_h
#
include
"
mozilla
/
PerfectHash
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
glean
/
MetricTypes
.
h
"
#
define
GLEAN_INDEX_BITS
(
{
{
index_bits
}
}
)
#
define
GLEAN_ID_BITS
(
{
{
id_bits
}
}
)
#
define
GLEAN_TYPE_ID
(
id
)
(
(
id
)
>
>
GLEAN_ID_BITS
)
#
define
GLEAN_METRIC_ID
(
id
)
(
(
id
)
&
(
(
1ULL
<
<
GLEAN_ID_BITS
)
-
1
)
)
#
define
GLEAN_OFFSET
(
entry
)
(
entry
&
(
(
1ULL
<
<
GLEAN_INDEX_BITS
)
-
1
)
)
namespace
mozilla
:
:
glean
{
using
category_entry_t
=
uint32_t
;
using
metric_entry_t
=
uint64_t
;
static_assert
(
GLEAN_INDEX_BITS
+
GLEAN_ID_BITS
<
sizeof
(
metric_entry_t
)
*
8
"
Index
and
ID
bits
need
to
fit
into
an
category_entry_t
"
)
;
static_assert
(
GLEAN_ID_BITS
<
sizeof
(
uint32_t
)
*
8
"
Metric
IDs
need
to
fit
into
less
than
32
bit
"
)
;
static_assert
(
{
{
categories
|
length
}
}
<
UINT32_MAX
"
Too
many
metric
categories
generated
.
"
)
;
static_assert
(
{
{
metric_id_mapping
|
length
}
}
<
{
{
2
*
*
id_bits
}
}
"
Too
many
metrics
generated
.
"
)
;
static_assert
(
{
{
metric_type_ids
|
length
}
}
<
{
{
2
*
*
(
entry_width
-
index_bits
-
id_bits
)
}
}
"
Too
many
different
metric
types
.
"
)
;
static
already_AddRefed
<
nsISupports
>
NewMetricFromId
(
uint32_t
id
)
{
uint32_t
typeId
=
GLEAN_TYPE_ID
(
id
)
;
uint32_t
metricId
=
GLEAN_METRIC_ID
(
id
)
;
switch
(
typeId
)
{
{
%
for
type
type_id
in
metric_type_ids
.
items
(
)
%
}
{
%
if
type
|
is_implemented_type
%
}
case
{
{
type_id
}
}
:
{
return
MakeAndAddRef
<
{
{
type
|
type_name
}
}
>
(
metricId
)
;
}
{
%
endif
%
}
{
%
endfor
%
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
type
ID
reached
when
trying
to
instantiate
a
new
metric
"
)
;
return
nullptr
;
}
}
static
Maybe
<
uint32_t
>
category_result_check
(
const
nsACString
&
aKey
category_entry_t
entry
)
;
static
Maybe
<
uint32_t
>
metric_result_check
(
const
nsACString
&
aKey
metric_entry_t
entry
)
;
{
{
category_string_table
}
}
static_assert
(
sizeof
(
gCategoryStringTable
)
<
UINT32_MAX
"
Category
string
table
is
too
large
.
"
)
;
{
{
category_by_name_lookup
}
}
{
{
metric_string_table
}
}
static_assert
(
sizeof
(
gMetricStringTable
)
<
{
{
2
*
*
index_bits
}
}
"
Metric
string
table
is
too
large
.
"
)
;
{
{
metric_by_name_lookup
}
}
static
const
char
*
GetCategoryName
(
category_entry_t
entry
)
{
MOZ_ASSERT
(
entry
<
sizeof
(
gCategoryStringTable
)
"
Entry
identifier
offset
larger
than
string
table
"
)
;
return
&
gCategoryStringTable
[
entry
]
;
}
static
const
char
*
GetMetricIdentifier
(
metric_entry_t
entry
)
{
uint32_t
offset
=
GLEAN_OFFSET
(
entry
)
;
MOZ_ASSERT
(
offset
<
sizeof
(
gMetricStringTable
)
"
Entry
identifier
offset
larger
than
string
table
"
)
;
return
&
gMetricStringTable
[
offset
]
;
}
static
Maybe
<
uint32_t
>
category_result_check
(
const
nsACString
&
aKey
category_entry_t
entry
)
{
if
(
MOZ_UNLIKELY
(
entry
>
sizeof
(
gCategoryStringTable
)
)
)
{
return
Nothing
(
)
;
}
if
(
aKey
.
EqualsASCII
(
gCategoryStringTable
+
entry
)
)
{
return
Some
(
entry
)
;
}
return
Nothing
(
)
;
}
static
Maybe
<
uint32_t
>
metric_result_check
(
const
nsACString
&
aKey
uint64_t
entry
)
{
uint32_t
metricId
=
entry
>
>
GLEAN_INDEX_BITS
;
uint32_t
offset
=
GLEAN_OFFSET
(
entry
)
;
if
(
offset
>
sizeof
(
gMetricStringTable
)
)
{
return
Nothing
(
)
;
}
if
(
aKey
.
EqualsASCII
(
gMetricStringTable
+
offset
)
)
{
return
Some
(
metricId
)
;
}
return
Nothing
(
)
;
}
#
undef
GLEAN_INDEX_BITS
#
undef
GLEAN_ID_BITS
#
undef
GLEAN_TYPE_ID
#
undef
GLEAN_METRIC_ID
#
undef
GLEAN_OFFSET
}
#
endif
