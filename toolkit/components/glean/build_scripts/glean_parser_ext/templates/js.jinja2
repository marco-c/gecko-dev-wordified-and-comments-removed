{
#
The
rendered
source
is
autogenerated
but
this
Jinja2
template
is
not
.
Please
file
bugs
!
#
}
#
include
"
mozilla
/
glean
/
bindings
/
GleanJSMetricsLookup
.
h
"
#
include
"
mozilla
/
PerfectHash
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
glean
/
bindings
/
MetricTypes
.
h
"
#
include
"
mozilla
/
glean
/
fog_ffi_generated
.
h
"
#
include
"
nsString
.
h
"
#
define
GLEAN_INDEX_BITS
(
{
{
index_bits
}
}
)
#
define
GLEAN_TYPE_BITS
(
{
{
type_bits
}
}
)
#
define
GLEAN_ID_BITS
(
{
{
id_bits
}
}
)
#
define
GLEAN_TYPE_ID
(
id
)
(
(
id
)
>
>
GLEAN_ID_BITS
)
#
define
GLEAN_METRIC_ID
(
id
)
(
(
id
)
&
(
(
1ULL
<
<
GLEAN_ID_BITS
)
-
1
)
)
#
define
GLEAN_OFFSET
(
entry
)
(
entry
&
(
(
1ULL
<
<
GLEAN_INDEX_BITS
)
-
1
)
)
namespace
mozilla
:
:
glean
{
using
category_entry_t
=
uint32_t
;
using
metric_entry_t
=
uint64_t
;
static_assert
(
GLEAN_INDEX_BITS
+
GLEAN_TYPE_BITS
+
GLEAN_ID_BITS
=
=
sizeof
(
metric_entry_t
)
*
8
"
Index
Type
and
ID
bits
need
to
fit
into
a
metric_entry_t
"
)
;
static_assert
(
GLEAN_TYPE_BITS
+
GLEAN_ID_BITS
<
=
sizeof
(
uint32_t
)
*
8
"
Metric
Types
and
IDs
need
to
fit
into
at
most
32
bits
"
)
;
static_assert
(
{
{
categories
|
length
}
}
<
UINT32_MAX
"
Too
many
metric
categories
generated
.
"
)
;
static_assert
(
{
{
metric_id_mapping
|
length
}
}
<
{
{
2
*
*
(
id_bits
-
id_signal_bits
)
}
}
"
Too
many
metrics
generated
.
Need
room
for
{
{
id_signal_bits
}
}
signal
bits
.
"
)
;
static_assert
(
{
{
metric_type_ids
|
length
}
}
<
{
{
2
*
*
type_bits
}
}
"
Too
many
different
metric
types
.
"
)
;
already_AddRefed
<
GleanMetric
>
NewMetricFromId
(
uint32_t
id
nsISupports
*
aParent
)
{
uint32_t
typeId
=
GLEAN_TYPE_ID
(
id
)
;
uint32_t
metricId
=
GLEAN_METRIC_ID
(
id
)
;
switch
(
typeId
)
{
{
%
for
(
type_name
subtype_name
)
(
type_id
original_type
)
in
metric_type_ids
.
items
(
)
%
}
case
{
{
type_id
}
}
:
{
return
MakeAndAddRef
<
{
{
type_name
}
}
>
(
metricId
{
%
if
subtype_name
|
length
>
0
%
}
{
{
type_id
}
}
{
%
endif
%
}
aParent
)
;
}
{
%
endfor
%
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
type
ID
reached
when
trying
to
instantiate
a
new
metric
"
)
;
return
nullptr
;
}
}
already_AddRefed
<
GleanMetric
>
NewSubMetricFromIds
(
uint32_t
aParentTypeId
uint32_t
aParentMetricId
const
nsACString
&
aLabel
uint32_t
*
aSubmetricId
nsISupports
*
aParent
)
{
switch
(
aParentTypeId
)
{
{
%
for
(
type_name
subtype_name
)
(
type_id
original_type
)
in
metric_type_ids
.
items
(
)
%
}
{
%
if
subtype_name
|
length
>
0
%
}
case
{
{
type_id
}
}
:
{
auto
id
=
impl
:
:
fog_
{
{
original_type
}
}
_get
(
aParentMetricId
&
aLabel
)
;
*
aSubmetricId
=
id
;
return
MakeAndAddRef
<
{
{
subtype_name
}
}
>
(
id
aParent
)
;
}
{
%
endif
%
}
{
%
endfor
%
}
default
:
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
type
ID
for
submetric
.
"
)
;
return
nullptr
;
}
}
}
static
Maybe
<
uint32_t
>
category_result_check
(
const
nsACString
&
aKey
category_entry_t
entry
)
;
static
Maybe
<
uint32_t
>
metric_result_check
(
const
nsACString
&
aKey
metric_entry_t
entry
)
;
{
{
category_string_table
}
}
static_assert
(
sizeof
(
gCategoryStringTable
)
<
UINT32_MAX
"
Category
string
table
is
too
large
.
"
)
;
{
{
category_by_name_lookup
}
}
{
{
metric_string_table
}
}
static_assert
(
sizeof
(
gMetricStringTable
)
<
{
{
2
*
*
index_bits
}
}
"
Metric
string
table
is
too
large
.
"
)
;
{
{
metric_by_name_lookup
}
}
const
char
*
GetCategoryName
(
category_entry_t
entry
)
{
MOZ_ASSERT
(
entry
<
sizeof
(
gCategoryStringTable
)
"
Entry
identifier
offset
larger
than
string
table
"
)
;
return
&
gCategoryStringTable
[
entry
]
;
}
const
char
*
GetMetricIdentifier
(
metric_entry_t
entry
)
{
uint32_t
offset
=
GLEAN_OFFSET
(
entry
)
;
MOZ_ASSERT
(
offset
<
sizeof
(
gMetricStringTable
)
"
Entry
identifier
offset
larger
than
string
table
"
)
;
return
&
gMetricStringTable
[
offset
]
;
}
static
Maybe
<
uint32_t
>
category_result_check
(
const
nsACString
&
aKey
category_entry_t
entry
)
{
if
(
MOZ_UNLIKELY
(
entry
>
sizeof
(
gCategoryStringTable
)
)
)
{
return
Nothing
(
)
;
}
if
(
aKey
.
EqualsASCII
(
gCategoryStringTable
+
entry
)
)
{
return
Some
(
entry
)
;
}
return
Nothing
(
)
;
}
static
Maybe
<
uint32_t
>
metric_result_check
(
const
nsACString
&
aKey
uint64_t
entry
)
{
uint32_t
metricId
=
entry
>
>
GLEAN_INDEX_BITS
;
uint32_t
offset
=
GLEAN_OFFSET
(
entry
)
;
if
(
offset
>
sizeof
(
gMetricStringTable
)
)
{
return
Nothing
(
)
;
}
if
(
aKey
.
EqualsASCII
(
gMetricStringTable
+
offset
)
)
{
return
Some
(
metricId
)
;
}
return
Nothing
(
)
;
}
#
undef
GLEAN_INDEX_BITS
#
undef
GLEAN_ID_BITS
#
undef
GLEAN_TYPE_ID
#
undef
GLEAN_METRIC_ID
#
undef
GLEAN_OFFSET
}
