{
#
The
rendered
source
is
autogenerated
but
this
Jinja2
template
is
not
.
Please
file
bugs
!
#
}
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
glean
/
bindings
/
GleanJSMetricsLookup
.
h
"
#
include
"
mozilla
/
glean
/
bindings
/
jog
/
JOG
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
ifndef
mozilla_glean_
{
{
probe_type
}
}
GifftMap_h
#
define
mozilla_glean_
{
{
probe_type
}
}
GifftMap_h
#
define
DYNAMIC_METRIC_BIT
(
{
{
runtime_metric_bit
}
}
)
#
define
GLEAN_METRIC_ID
(
id
)
(
(
id
)
&
(
(
1ULL
<
<
{
{
id_bits
}
}
)
-
1
)
)
namespace
mozilla
:
:
glean
{
using
Telemetry
:
:
{
{
probe_type
}
}
ID
;
{
%
if
probe_type
=
=
"
Scalar
"
%
}
static
inline
bool
IsSubmetricId
(
uint32_t
aId
)
{
return
(
aId
&
(
1
<
<
{
{
id_bits
-
id_signal_bits
}
}
)
)
>
0
;
}
{
%
endif
%
}
static
{
%
if
probe_type
=
=
"
Event
"
or
probe_type
=
=
"
Scalar
"
%
}
inline
{
%
endif
%
}
Maybe
<
{
{
probe_type
}
}
ID
>
{
{
probe_type
}
}
IdForMetric
(
uint32_t
aId
)
{
switch
(
aId
)
{
{
%
for
id
(
mirror
metric_name
)
in
ids_to_probes
.
items
(
)
%
}
case
{
{
id
}
}
:
{
return
Some
(
{
{
probe_type
}
}
ID
:
:
{
{
mirror
}
}
)
;
}
{
%
endfor
%
}
default
:
{
if
(
MOZ_UNLIKELY
(
aId
&
(
1
<
<
DYNAMIC_METRIC_BIT
)
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
metricName
=
JOG
:
:
GetMetricName
(
aId
)
;
if
(
metricName
.
isSome
(
)
)
{
auto
maybeMetric
=
MetricByNameLookup
(
metricName
.
ref
(
)
)
;
if
(
maybeMetric
.
isSome
(
)
)
{
uint32_t
staticId
=
GLEAN_METRIC_ID
(
maybeMetric
.
value
(
)
)
;
MOZ_ASSERT
(
!
(
staticId
&
(
1
<
<
DYNAMIC_METRIC_BIT
)
)
)
;
return
{
{
probe_type
}
}
IdForMetric
(
staticId
)
;
}
}
}
return
Nothing
(
)
;
}
}
}
}
#
undef
GLEAN_METRIC_ID
#
undef
DYNAMIC_METRIC_BIT
#
endif
