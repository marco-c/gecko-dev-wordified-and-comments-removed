use
serde
:
:
{
Deserialize
Serialize
}
;
pub
use
glean
:
:
{
traits
CommonMetricData
DistributionData
ErrorType
LabeledMetricData
Lifetime
MemoryUnit
RecordedEvent
TimeUnit
TimerId
}
;
mod
boolean
;
mod
counter
;
mod
custom_distribution
;
mod
datetime
;
mod
denominator
;
mod
event
;
mod
labeled
;
mod
labeled_boolean
;
mod
labeled_counter
;
mod
labeled_custom_distribution
;
mod
labeled_memory_distribution
;
mod
labeled_timing_distribution
;
mod
memory_distribution
;
mod
numerator
;
mod
object
;
mod
ping
;
mod
quantity
;
mod
rate
;
pub
(
crate
)
mod
string
;
mod
string_list
;
mod
text
;
mod
timespan
;
mod
timing_distribution
;
mod
url
;
mod
uuid
;
pub
use
self
:
:
boolean
:
:
BooleanMetric
;
pub
use
self
:
:
counter
:
:
CounterMetric
;
pub
use
self
:
:
custom_distribution
:
:
{
CustomDistributionMetric
LocalCustomDistribution
}
;
pub
use
self
:
:
datetime
:
:
DatetimeMetric
;
pub
use
self
:
:
denominator
:
:
DenominatorMetric
;
pub
use
self
:
:
event
:
:
{
EventMetric
EventRecordingError
ExtraKeys
NoExtraKeys
}
;
pub
use
self
:
:
labeled
:
:
LabeledMetric
;
pub
use
self
:
:
labeled_boolean
:
:
LabeledBooleanMetric
;
pub
use
self
:
:
labeled_counter
:
:
LabeledCounterMetric
;
pub
use
self
:
:
labeled_custom_distribution
:
:
LabeledCustomDistributionMetric
;
pub
use
self
:
:
labeled_memory_distribution
:
:
LabeledMemoryDistributionMetric
;
pub
use
self
:
:
labeled_timing_distribution
:
:
LabeledTimingDistributionMetric
;
pub
use
self
:
:
memory_distribution
:
:
{
LocalMemoryDistribution
MemoryDistributionMetric
}
;
pub
use
self
:
:
numerator
:
:
NumeratorMetric
;
pub
use
self
:
:
object
:
:
ObjectMetric
;
pub
use
self
:
:
ping
:
:
Ping
;
pub
use
self
:
:
quantity
:
:
QuantityMetric
as
LabeledQuantityMetric
;
pub
use
self
:
:
quantity
:
:
QuantityMetric
;
pub
use
self
:
:
rate
:
:
RateMetric
;
pub
use
self
:
:
string
:
:
StringMetric
;
pub
use
self
:
:
string
:
:
StringMetric
as
LabeledStringMetric
;
pub
use
self
:
:
string_list
:
:
StringListMetric
;
pub
use
self
:
:
text
:
:
TextMetric
;
pub
use
self
:
:
timespan
:
:
TimespanMetric
;
pub
use
self
:
:
timing_distribution
:
:
TimingDistributionMetric
;
pub
use
self
:
:
url
:
:
UrlMetric
;
pub
use
self
:
:
uuid
:
:
UuidMetric
;
#
[
derive
(
Debug
PartialEq
Eq
Hash
Copy
Clone
Deserialize
Serialize
)
]
#
[
repr
(
transparent
)
]
pub
struct
MetricId
(
pub
(
crate
)
u32
)
;
impl
MetricId
{
pub
fn
new
(
id
:
u32
)
-
>
Self
{
Self
(
id
)
}
}
impl
From
<
u32
>
for
MetricId
{
fn
from
(
id
:
u32
)
-
>
Self
{
Self
(
id
)
}
}
#
[
cfg
(
feature
=
"
with_gecko
"
)
]
pub
(
crate
)
mod
profiler_utils
{
use
super
:
:
max_string_byte_length
;
pub
(
crate
)
use
super
:
:
truncate_string_for_marker
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
LookupError
{
NullPointer
Utf8ParseError
(
std
:
:
str
:
:
Utf8Error
)
}
impl
LookupError
{
pub
fn
as_str
(
self
)
-
>
&
'
static
str
{
match
self
{
LookupError
:
:
NullPointer
=
>
"
id
not
found
"
LookupError
:
:
Utf8ParseError
(
_
)
=
>
"
utf8
parse
error
"
}
}
}
impl
std
:
:
fmt
:
:
Display
for
LookupError
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
match
self
{
LookupError
:
:
NullPointer
=
>
write
!
(
f
"
id
not
found
"
)
LookupError
:
:
Utf8ParseError
(
p
)
=
>
write
!
(
f
"
utf8
parse
error
:
{
}
"
p
)
}
}
}
pub
(
crate
)
fn
lookup_canonical_metric_name
(
id
:
&
super
:
:
MetricId
)
-
>
Result
<
&
'
static
str
LookupError
>
{
#
[
allow
(
unused
)
]
use
std
:
:
ffi
:
:
{
c_char
CStr
}
;
extern
"
C
"
{
fn
FOG_GetMetricIdentifier
(
id
:
u32
)
-
>
*
const
c_char
;
}
unsafe
{
let
raw_name_ptr
=
FOG_GetMetricIdentifier
(
id
.
0
)
;
if
raw_name_ptr
.
is_null
(
)
{
Err
(
LookupError
:
:
NullPointer
)
}
else
{
let
name
=
CStr
:
:
from_ptr
(
raw_name_ptr
)
.
to_str
(
)
;
match
name
{
Ok
(
s
)
=
>
Ok
(
s
)
Err
(
ut8err
)
=
>
Err
(
LookupError
:
:
Utf8ParseError
(
ut8err
)
)
}
}
}
}
pub
(
crate
)
fn
local_now_with_offset
(
)
-
>
chrono
:
:
DateTime
<
chrono
:
:
FixedOffset
>
{
use
chrono
:
:
{
DateTime
Local
}
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
{
use
chrono
:
:
{
FixedOffset
Utc
}
;
let
tm
=
time
:
:
now
(
)
;
let
offset
=
tm
.
tm_utcoff
;
if
let
None
=
FixedOffset
:
:
east_opt
(
offset
)
{
log
:
:
warn
!
(
"
Detected
invalid
timezone
offset
:
{
}
.
Using
UTC
fallback
.
"
offset
)
;
let
now
:
DateTime
<
Utc
>
=
Utc
:
:
now
(
)
;
let
utc_offset
=
FixedOffset
:
:
east
(
0
)
;
return
now
.
with_timezone
(
&
utc_offset
)
;
}
}
let
now
:
DateTime
<
Local
>
=
Local
:
:
now
(
)
;
now
.
with_timezone
(
now
.
offset
(
)
)
}
pub
(
crate
)
fn
glean_to_chrono_datetime
(
gdt
:
&
glean
:
:
Datetime
)
-
>
Option
<
chrono
:
:
LocalResult
<
chrono
:
:
DateTime
<
chrono
:
:
FixedOffset
>
>
>
{
use
chrono
:
:
{
FixedOffset
TimeZone
}
;
let
tz
=
FixedOffset
:
:
east_opt
(
gdt
.
offset_seconds
)
;
if
tz
.
is_none
(
)
{
return
None
;
}
Some
(
FixedOffset
:
:
east
(
gdt
.
offset_seconds
)
.
ymd_opt
(
gdt
.
year
gdt
.
month
gdt
.
day
)
.
and_hms_nano_opt
(
gdt
.
hour
gdt
.
minute
gdt
.
second
gdt
.
nanosecond
)
)
}
pub
(
crate
)
fn
truncate_vector_for_marker
<
T
>
(
vec
:
&
Vec
<
T
>
)
-
>
Vec
<
T
>
where
T
:
Clone
{
const
MAX_VECTOR_LENGTH
:
usize
=
1024
;
if
vec
.
len
(
)
>
MAX_VECTOR_LENGTH
{
vec
[
0
.
.
MAX_VECTOR_LENGTH
-
1
]
.
to_vec
(
)
}
else
{
vec
.
clone
(
)
}
}
#
[
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
Debug
)
]
pub
(
crate
)
struct
StringLikeMetricMarker
{
id
:
super
:
:
MetricId
value
:
String
}
impl
StringLikeMetricMarker
{
pub
fn
new
(
id
:
super
:
:
MetricId
value
:
&
String
)
-
>
StringLikeMetricMarker
{
StringLikeMetricMarker
{
id
:
id
value
:
truncate_string_for_marker
(
value
.
clone
(
)
)
}
}
pub
fn
new_owned
(
id
:
super
:
:
MetricId
value
:
String
)
-
>
StringLikeMetricMarker
{
StringLikeMetricMarker
{
id
:
id
value
:
truncate_string_for_marker
(
value
)
}
}
}
impl
gecko_profiler
:
:
ProfilerMarker
for
StringLikeMetricMarker
{
fn
marker_type_name
(
)
-
>
&
'
static
str
{
"
StringLikeMetric
"
}
fn
marker_type_display
(
)
-
>
gecko_profiler
:
:
MarkerSchema
{
use
gecko_profiler
:
:
schema
:
:
*
;
let
mut
schema
=
MarkerSchema
:
:
new
(
&
[
Location
:
:
MarkerChart
Location
:
:
MarkerTable
]
)
;
schema
.
set_tooltip_label
(
"
{
marker
.
data
.
id
}
"
)
;
schema
.
set_table_label
(
"
{
marker
.
name
}
-
{
marker
.
data
.
id
}
:
{
marker
.
data
.
value
}
"
)
;
schema
.
add_key_label_format_searchable
(
"
id
"
"
Metric
"
Format
:
:
UniqueString
Searchable
:
:
Searchable
)
;
schema
.
add_key_label_format
(
"
value
"
"
Value
"
Format
:
:
String
)
;
schema
}
fn
stream_json_marker_data
(
&
self
json_writer
:
&
mut
gecko_profiler
:
:
JSONWriter
)
{
json_writer
.
unique_string_property
(
"
id
"
lookup_canonical_metric_name
(
&
self
.
id
)
.
unwrap_or_else
(
LookupError
:
:
as_str
)
)
;
debug_assert
!
(
self
.
value
.
len
(
)
<
=
max_string_byte_length
(
)
)
;
json_writer
.
string_property
(
"
value
"
self
.
value
.
as_str
(
)
)
;
}
}
#
[
derive
(
serde
:
:
Serialize
serde
:
:
Deserialize
Debug
)
]
pub
(
crate
)
struct
IntLikeMetricMarker
<
T
>
where
T
:
Into
<
i64
>
{
id
:
super
:
:
MetricId
label
:
Option
<
String
>
value
:
T
}
impl
<
T
>
IntLikeMetricMarker
<
T
>
where
T
:
Into
<
i64
>
{
pub
fn
new
(
id
:
super
:
:
MetricId
label
:
Option
<
String
>
value
:
T
)
-
>
IntLikeMetricMarker
<
T
>
{
IntLikeMetricMarker
{
id
label
value
}
}
}
impl
<
T
>
gecko_profiler
:
:
ProfilerMarker
for
IntLikeMetricMarker
<
T
>
where
T
:
serde
:
:
Serialize
+
serde
:
:
de
:
:
DeserializeOwned
+
Into
<
i64
>
+
Copy
{
fn
marker_type_name
(
)
-
>
&
'
static
str
{
"
IntLikeMetric
"
}
fn
marker_type_display
(
)
-
>
gecko_profiler
:
:
MarkerSchema
{
use
gecko_profiler
:
:
schema
:
:
*
;
let
mut
schema
=
MarkerSchema
:
:
new
(
&
[
Location
:
:
MarkerChart
Location
:
:
MarkerTable
]
)
;
schema
.
set_tooltip_label
(
"
{
marker
.
data
.
id
}
{
marker
.
data
.
label
}
{
marker
.
data
.
value
}
"
)
;
schema
.
set_table_label
(
"
{
marker
.
name
}
-
{
marker
.
data
.
id
}
{
marker
.
data
.
label
}
:
{
marker
.
data
.
value
}
"
)
;
schema
.
add_key_label_format_searchable
(
"
id
"
"
Metric
"
Format
:
:
UniqueString
Searchable
:
:
Searchable
)
;
schema
.
add_key_label_format
(
"
value
"
"
Value
"
Format
:
:
Integer
)
;
schema
.
add_key_label_format_searchable
(
"
label
"
"
Label
"
Format
:
:
String
Searchable
:
:
Searchable
)
;
schema
}
fn
stream_json_marker_data
(
&
self
json_writer
:
&
mut
gecko_profiler
:
:
JSONWriter
)
{
json_writer
.
unique_string_property
(
"
id
"
lookup_canonical_metric_name
(
&
self
.
id
)
.
unwrap_or_else
(
LookupError
:
:
as_str
)
)
;
json_writer
.
int_property
(
"
value
"
self
.
value
.
clone
(
)
.
into
(
)
)
;
if
let
Some
(
l
)
=
&
self
.
label
{
json_writer
.
string_property
(
"
label
"
&
l
)
;
}
;
}
}
}
#
[
cfg
(
any
(
feature
=
"
with_gecko
"
test
)
)
]
pub
(
crate
)
fn
truncate_string_for_marker
(
input
:
String
)
-
>
String
{
truncate_string_for_marker_to_length
(
input
max_string_byte_length
(
)
)
}
#
[
cfg
(
any
(
feature
=
"
with_gecko
"
test
)
)
]
const
fn
max_string_byte_length
(
)
-
>
usize
{
1024
}
#
[
cfg
(
any
(
feature
=
"
with_gecko
"
test
)
)
]
#
[
inline
]
fn
truncate_string_for_marker_to_length
(
mut
input
:
String
byte_length
:
usize
)
-
>
String
{
#
[
inline
]
const
fn
is_utf8_char_boundary
(
b
:
u8
)
-
>
bool
{
(
b
as
i8
)
>
=
-
0x40
}
if
byte_length
<
input
.
len
(
)
{
let
lower_bound
=
byte_length
.
saturating_sub
(
3
)
;
let
new_byte_length
=
input
.
as_bytes
(
)
[
lower_bound
.
.
=
byte_length
]
.
iter
(
)
.
rposition
(
|
b
|
is_utf8_char_boundary
(
*
b
)
)
;
let
truncation_point
=
unsafe
{
lower_bound
+
new_byte_length
.
unwrap_unchecked
(
)
}
;
input
.
truncate
(
truncation_point
)
}
input
}
#
[
cfg
(
test
)
]
mod
truncation_tests
{
use
crate
:
:
private
:
:
truncate_string_for_marker
;
use
crate
:
:
private
:
:
truncate_string_for_marker_to_length
;
fn
check_many
(
s
:
&
str
arg
:
impl
IntoIterator
<
Item
=
usize
>
truncated
:
&
str
)
{
for
len
in
arg
{
assert_eq
!
(
truncate_string_for_marker_to_length
(
s
.
to_string
(
)
len
)
truncated
"
truncate_string_for_marker_to_length
(
{
:
?
}
{
:
?
}
)
!
=
{
:
?
}
"
len
s
truncated
)
;
}
}
#
[
test
]
fn
truncate_1byte_chars
(
)
{
check_many
(
"
jp
"
[
0
]
"
"
)
;
check_many
(
"
jp
"
[
1
]
"
j
"
)
;
check_many
(
"
jp
"
2
.
.
4
"
jp
"
)
;
}
#
[
test
]
fn
truncate_2byte_chars
(
)
{
check_many
(
"
"
0
.
.
2
"
"
)
;
check_many
(
"
"
2
.
.
4
"
"
)
;
check_many
(
"
"
4
.
.
6
"
"
)
;
}
#
[
test
]
fn
truncate_3byte_chars
(
)
{
check_many
(
"
"
0
.
.
3
"
"
)
;
check_many
(
"
"
3
.
.
6
"
"
)
;
check_many
(
"
"
6
.
.
8
"
"
)
;
}
#
[
test
]
fn
truncate_4byte_chars
(
)
{
check_many
(
"
"
0
.
.
4
"
"
)
;
check_many
(
"
"
4
.
.
8
"
"
)
;
check_many
(
"
"
8
.
.
10
"
"
)
;
}
fn
check_one
(
s
:
String
truncated
:
String
)
{
assert_eq
!
(
truncate_string_for_marker
(
s
.
clone
(
)
)
truncated
"
truncate_string_for_marker
(
{
:
?
}
)
!
=
{
:
?
}
"
s
truncated
)
;
}
#
[
test
]
fn
full_truncation
(
)
{
let
pad
=
|
reps
:
usize
|
-
>
String
{
"
-
"
.
repeat
(
reps
)
}
;
check_one
(
pad
(
1020
)
+
"
jpjpj
"
pad
(
1020
)
+
"
jpjp
"
)
;
check_one
(
pad
(
1020
)
+
"
"
pad
(
1020
)
+
"
"
)
;
check_one
(
pad
(
1021
)
+
"
"
pad
(
1021
)
+
"
"
)
;
check_one
(
pad
(
1018
)
+
"
"
pad
(
1018
)
+
"
"
)
;
check_one
(
pad
(
1020
)
+
"
"
pad
(
1020
)
+
"
"
)
;
check_one
(
pad
(
1022
)
+
"
"
pad
(
1022
)
)
;
check_one
(
pad
(
1016
)
+
"
"
pad
(
1016
)
+
"
"
)
;
check_one
(
pad
(
1017
)
+
"
"
pad
(
1017
)
+
"
"
)
;
check_one
(
pad
(
1021
)
+
"
"
pad
(
1021
)
+
"
"
)
;
}
}
