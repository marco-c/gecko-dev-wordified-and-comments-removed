use
std
:
:
convert
:
:
TryFrom
;
use
std
:
:
time
:
:
{
SystemTime
UNIX_EPOCH
}
;
use
serde
:
:
{
Deserialize
Serialize
}
;
pub
use
glean_core
:
:
{
metrics
:
:
DistributionData
metrics
:
:
MemoryUnit
metrics
:
:
RecordedEvent
metrics
:
:
TimeUnit
CommonMetricData
ErrorType
Lifetime
}
;
mod
boolean
;
mod
counter
;
mod
datetime
;
mod
event
;
mod
labeled
;
mod
memory_distribution
;
mod
ping
;
pub
(
crate
)
mod
string
;
mod
string_list
;
mod
timespan
;
mod
timing_distribution
;
mod
uuid
;
pub
use
self
:
:
boolean
:
:
BooleanMetric
;
pub
use
self
:
:
counter
:
:
CounterMetric
;
pub
use
self
:
:
datetime
:
:
DatetimeMetric
;
pub
use
self
:
:
event
:
:
{
EventMetric
ExtraKeys
NoExtraKeys
}
;
pub
use
self
:
:
labeled
:
:
LabeledMetric
;
pub
use
self
:
:
memory_distribution
:
:
MemoryDistributionMetric
;
pub
use
self
:
:
ping
:
:
Ping
;
pub
use
self
:
:
string
:
:
StringMetric
;
pub
use
self
:
:
string_list
:
:
StringListMetric
;
pub
use
self
:
:
timespan
:
:
TimespanMetric
;
pub
use
self
:
:
timing_distribution
:
:
{
TimerId
TimingDistributionMetric
}
;
pub
use
self
:
:
uuid
:
:
UuidMetric
;
#
[
derive
(
Clone
Debug
Deserialize
Serialize
)
]
pub
struct
Instant
(
u64
)
;
impl
Instant
{
fn
now
(
)
-
>
Instant
{
let
now
=
SystemTime
:
:
now
(
)
.
duration_since
(
UNIX_EPOCH
)
.
expect
(
"
SystemTime
before
UNIX
epoch
!
"
)
;
let
now
=
now
.
as_nanos
(
)
;
match
u64
:
:
try_from
(
now
)
{
Ok
(
now
)
=
>
Instant
(
now
)
Err
(
_
)
=
>
{
panic
!
(
"
timestamp
exceeds
value
range
"
)
}
}
}
fn
as_nanos
(
&
self
)
-
>
u64
{
self
.
0
}
fn
as_millis
(
&
self
)
-
>
u64
{
const
NANOS_PER_MILLI
:
u64
=
1_000_000
;
self
.
0
/
NANOS_PER_MILLI
}
}
#
[
derive
(
Debug
PartialEq
Eq
Hash
Copy
Clone
Deserialize
Serialize
)
]
#
[
repr
(
transparent
)
]
pub
struct
MetricId
(
u32
)
;
impl
MetricId
{
pub
fn
new
(
id
:
u32
)
-
>
Self
{
Self
(
id
)
}
}
impl
From
<
u32
>
for
MetricId
{
fn
from
(
id
:
u32
)
-
>
Self
{
Self
(
id
)
}
}
