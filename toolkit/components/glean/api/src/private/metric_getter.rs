use
serde
:
:
{
Deserialize
Serialize
}
;
use
std
:
:
error
:
:
Error
;
use
std
:
:
fmt
:
:
Display
;
#
[
derive
(
Debug
)
]
pub
enum
LookupError
{
FOGMetricMapWasUninit
FOGMetricMapLookupFailed
FOGSubmetricMapWasUninit
FOGSubmetricMapLockWasPoisoned
FOGSubmetricLookupFailed
JOGMetricMapWasUninit
JOGMetricMapLockWasPoisoned
JOGMetricMapLookupFailed
ReverseSubmetricLookupFailed
LookupUnlabledBySubId
SubmetricIdIsDynamic
LabeledBaseMetricIsNotDynamic
SubMetricLookupFailed
FOGMetricIdLookupFailed
NoBaseMetricForThisLabeledType
}
impl
Display
for
LookupError
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
match
self
{
LookupError
:
:
FOGMetricMapWasUninit
=
>
write
!
(
f
"
FOGMetricMapWasUninit
"
)
LookupError
:
:
FOGMetricMapLookupFailed
=
>
write
!
(
f
"
FOGMetricMapLookupFailed
"
)
LookupError
:
:
FOGSubmetricMapWasUninit
=
>
write
!
(
f
"
FOGSubmetricMapWasUninit
"
)
LookupError
:
:
FOGSubmetricMapLockWasPoisoned
=
>
{
write
!
(
f
"
FOGSubmetricMapLockWasPoisoned
"
)
}
LookupError
:
:
FOGSubmetricLookupFailed
=
>
write
!
(
f
"
FOGSubmetricLookupFailed
"
)
LookupError
:
:
JOGMetricMapWasUninit
=
>
write
!
(
f
"
JOGMetricMapWasUninit
"
)
LookupError
:
:
JOGMetricMapLockWasPoisoned
=
>
write
!
(
f
"
JOGMetricMapLockWasPoisoned
"
)
LookupError
:
:
JOGMetricMapLookupFailed
=
>
write
!
(
f
"
JOGMetricMapLookupFailed
"
)
LookupError
:
:
ReverseSubmetricLookupFailed
=
>
write
!
(
f
"
ReverseSubmetricLookupFailed
"
)
LookupError
:
:
LookupUnlabledBySubId
=
>
write
!
(
f
"
LookupUnlabledBySubId
"
)
LookupError
:
:
SubmetricIdIsDynamic
=
>
write
!
(
f
"
SubmetricIdIsDynamic
"
)
LookupError
:
:
LabeledBaseMetricIsNotDynamic
=
>
{
write
!
(
f
"
LabeledBaseMetricIsNotDynamic
"
)
}
LookupError
:
:
SubMetricLookupFailed
=
>
write
!
(
f
"
SubMetricLookupFailed
"
)
LookupError
:
:
FOGMetricIdLookupFailed
=
>
write
!
(
f
"
FOGMetricIdLookupFailed
"
)
LookupError
:
:
NoBaseMetricForThisLabeledType
=
>
{
write
!
(
f
"
NoBaseMetricForThisLabeledType
"
)
}
}
}
}
impl
Error
for
LookupError
{
}
pub
type
LookupResult
<
T
>
=
std
:
:
result
:
:
Result
<
T
LookupError
>
;
#
[
derive
(
Debug
)
]
pub
struct
MetricMetadata
{
pub
category
:
String
pub
name
:
String
pub
label
:
Option
<
String
>
}
impl
MetricMetadata
{
pub
fn
from_triple
(
t
:
(
&
str
&
str
Option
<
&
str
>
)
)
-
>
MetricMetadata
{
MetricMetadata
{
category
:
t
.
0
.
to_owned
(
)
name
:
t
.
1
.
to_owned
(
)
label
:
t
.
2
.
map
(
str
:
:
to_string
)
}
}
pub
fn
from_error
(
error
:
LookupError
)
-
>
MetricMetadata
{
MetricMetadata
{
category
:
"
"
.
to_owned
(
)
name
:
error
.
to_string
(
)
label
:
None
}
}
pub
fn
from_error_str
(
error
:
&
str
)
-
>
MetricMetadata
{
MetricMetadata
{
category
:
"
"
.
to_owned
(
)
name
:
error
.
to_owned
(
)
label
:
None
}
}
pub
fn
with_ref_label
(
self
other
:
Option
<
&
str
>
)
-
>
Self
{
MetricMetadata
{
category
:
self
.
category
name
:
self
.
name
label
:
self
.
label
.
or
(
other
.
map
(
str
:
:
to_string
)
)
}
}
pub
fn
with_owned_label
(
self
other
:
Option
<
String
>
)
-
>
Self
{
MetricMetadata
{
category
:
self
.
category
name
:
self
.
name
label
:
self
.
label
.
or
(
other
)
}
}
}
pub
trait
MetricNamer
{
fn
get_metadata
(
&
self
)
-
>
MetricMetadata
;
}
macro_rules
!
define_metric_namer
{
(
metric_type
:
ident
)
=
>
{
impl
crate
:
:
private
:
:
MetricNamer
for
metric_type
{
fn
get_metadata
(
&
self
)
-
>
crate
:
:
private
:
:
MetricMetadata
{
use
glean
:
:
MetricIdentifier
;
match
self
{
metric_type
:
:
Parent
{
inner
.
.
}
=
>
{
crate
:
:
private
:
:
MetricMetadata
:
:
from_triple
(
inner
.
get_identifiers
(
)
)
}
metric_type
:
:
Child
(
meta
)
=
>
{
crate
:
:
private
:
:
MetricMetadata
:
:
from_triple
(
meta
.
get_identifiers
(
)
)
}
}
}
}
}
;
(
metric_type
:
ident
PARENT_ONLY
)
=
>
{
impl
crate
:
:
private
:
:
MetricNamer
for
metric_type
{
fn
get_metadata
(
&
self
)
-
>
crate
:
:
private
:
:
MetricMetadata
{
use
glean
:
:
MetricIdentifier
;
match
self
{
metric_type
:
:
Parent
{
inner
.
.
}
=
>
{
crate
:
:
private
:
:
MetricMetadata
:
:
from_triple
(
inner
.
get_identifiers
(
)
)
}
_
=
>
crate
:
:
private
:
:
MetricMetadata
:
:
from_error_str
(
concat
!
(
"
Cannot
get
child
identifiers
for
parent
only
type
"
stringify
!
(
metric_type
)
)
)
}
}
}
}
;
(
metric_type
:
ident
LABELED
)
=
>
{
impl
crate
:
:
private
:
:
MetricNamer
for
metric_type
{
fn
get_metadata
(
&
self
)
-
>
crate
:
:
private
:
:
MetricMetadata
{
match
self
.
get_base_metric
(
)
{
BaseMetricResult
:
:
BaseMetric
(
metric
)
=
>
metric
.
get_metadata
(
)
BaseMetricResult
:
:
BaseMetricWithLabel
(
metric
inner_label
)
=
>
{
metric
.
get_metadata
(
)
.
with_ref_label
(
Some
(
inner_label
)
)
}
BaseMetricResult
:
:
IndexLabelPair
(
id
child_label
)
=
>
{
match
<
metric_type
as
BaseMetric
>
:
:
BaseMetricT
:
:
get_base_metric_metadata_by_id
(
id
)
{
Ok
(
(
metadata
inner_label
)
)
=
>
metadata
.
with_owned_label
(
inner_label
)
.
with_ref_label
(
Some
(
child_label
)
)
Err
(
e
)
=
>
crate
:
:
private
:
:
MetricMetadata
:
:
from_error
(
e
)
}
}
BaseMetricResult
:
:
None
=
>
crate
:
:
private
:
:
MetricMetadata
:
:
from_error
(
crate
:
:
private
:
:
metric_getter
:
:
LookupError
:
:
NoBaseMetricForThisLabeledType
)
}
}
}
}
;
}
pub
trait
MetricMetadataGetter
{
fn
get_metric_metadata_by_id
<
T
:
Into
<
MetricId
>
>
(
id
:
T
)
-
>
LookupResult
<
(
MetricMetadata
Option
<
String
>
)
>
where
Self
:
MetricNamer
;
}
impl
<
MetricT
>
MetricMetadataGetter
for
MetricT
where
MetricT
:
MetricMetadataGetterImpl
+
MetricNamer
{
fn
get_metric_metadata_by_id
<
T
:
Into
<
MetricId
>
>
(
id
:
T
)
-
>
LookupResult
<
(
MetricMetadata
Option
<
String
>
)
>
{
match
id
.
into
(
)
{
MetricId
:
:
Id
(
baseid
)
=
>
Self
:
:
get_base_metric_metadata_by_id
(
baseid
)
MetricId
:
:
SubId
(
subid
)
=
>
Self
:
:
get_sub_metric_metadata_by_id
(
subid
)
}
}
}
pub
trait
MetricMetadataGetterImpl
{
fn
get_base_metric_metadata_by_id
(
id
:
BaseMetricId
)
-
>
LookupResult
<
(
MetricMetadata
Option
<
String
>
)
>
where
Self
:
MetricNamer
;
fn
get_sub_metric_metadata_by_id
(
id
:
SubMetricId
)
-
>
LookupResult
<
(
MetricMetadata
Option
<
String
>
)
>
where
Self
:
MetricNamer
;
}
pub
enum
BaseMetricResult
<
'
a
BaseMetricT
>
{
BaseMetric
(
&
'
a
BaseMetricT
)
BaseMetricWithLabel
(
&
'
a
BaseMetricT
&
'
a
str
)
IndexLabelPair
(
BaseMetricId
&
'
a
str
)
None
}
pub
trait
BaseMetric
{
type
BaseMetricT
;
fn
get_base_metric
<
'
a
>
(
&
'
a
self
)
-
>
BaseMetricResult
<
'
a
Self
:
:
BaseMetricT
>
;
}
macro_rules
!
metadata_from_static_map
{
(
metric_type
:
ident
metric_map
:
ident
metric_id
:
ident
)
=
>
{
{
let
static_map
=
once_cell
:
:
sync
:
:
Lazy
:
:
get
(
&
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
metric_map
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
FOGMetricMapWasUninit
)
?
;
let
metric
:
&
metric_type
=
static_map
.
get
(
&
metric_id
)
.
and_then
(
|
thunk
:
&
&
once_cell
:
:
sync
:
:
Lazy
<
metric_type
>
|
{
once_cell
:
:
sync
:
:
Lazy
:
:
get
(
*
thunk
)
}
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
FOGMetricMapLookupFailed
)
?
;
Ok
(
(
metric
.
get_metadata
(
)
None
)
)
}
}
;
}
macro_rules
!
metadata_from_dynamic_map
{
(
metric_map
:
ident
metric_id
:
ident
)
=
>
{
{
/
/
Find
the
dynamic
map
(
given
as
part
of
the
macro
)
and
try
to
read
/
/
from
it
.
We
don
'
t
need
to
force
it
as
if
it
hasn
'
t
been
/
/
initialized
we
won
'
t
have
a
metric
in
there
to
read
anyway
!
let
dynamic_map
=
once_cell
:
:
sync
:
:
Lazy
:
:
get
(
&
crate
:
:
factory
:
:
__jog_metric_maps
:
:
metric_map
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
JOGMetricMapWasUninit
)
?
.
read
(
)
.
or
(
Err
(
crate
:
:
private
:
:
LookupError
:
:
JOGMetricMapLockWasPoisoned
)
)
?
;
let
metric
:
&
Self
=
dynamic_map
.
get
(
&
metric_id
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
JOGMetricMapLookupFailed
)
?
;
Ok
(
(
metric
.
get_metadata
(
)
None
)
)
}
}
;
}
macro_rules
!
define_get_base_metric_metadata_by_id
{
(
metric_type
:
ident
metric_map
:
ident
)
=
>
{
fn
get_base_metric_metadata_by_id
(
id
:
crate
:
:
private
:
:
BaseMetricId
)
-
>
crate
:
:
private
:
:
LookupResult
<
(
crate
:
:
private
:
:
MetricMetadata
Option
<
String
>
)
>
{
use
crate
:
:
private
:
:
metric_getter
:
:
MetricNamer
;
if
id
.
is_dynamic
(
)
{
metadata_from_dynamic_map
!
(
metric_map
id
)
}
else
{
metadata_from_static_map
!
(
metric_type
metric_map
id
)
}
}
}
}
macro_rules
!
define_metric_metadata_getter
{
(
metric_type
:
ident
metric_map
:
ident
)
=
>
{
impl
crate
:
:
private
:
:
MetricMetadataGetterImpl
for
metric_type
{
define_get_base_metric_metadata_by_id
!
(
metric_type
metric_map
)
;
fn
get_sub_metric_metadata_by_id
(
_id
:
crate
:
:
private
:
:
SubMetricId
)
-
>
crate
:
:
private
:
:
LookupResult
<
(
crate
:
:
private
:
:
MetricMetadata
Option
<
String
>
)
>
{
/
/
Unlabeled
metrics
cannot
look
up
submetrics
Err
(
crate
:
:
private
:
:
LookupError
:
:
LookupUnlabledBySubId
)
}
}
}
;
(
metric_type
:
ident
metric_map
:
ident
_labeled_map
:
ident
)
=
>
{
impl
crate
:
:
private
:
:
MetricMetadataGetterImpl
for
metric_type
{
define_get_base_metric_metadata_by_id
!
(
metric_type
metric_map
)
;
fn
get_sub_metric_metadata_by_id
(
id
:
crate
:
:
private
:
:
SubMetricId
)
-
>
crate
:
:
private
:
:
LookupResult
<
(
crate
:
:
private
:
:
MetricMetadata
Option
<
String
>
)
>
{
use
crate
:
:
private
:
:
metric_getter
:
:
MetricNamer
;
/
/
We
should
have
a
non
-
dynamic
ID
here
as
dynamic
/
/
metrics
always
have
base
metric
IDs
but
we
should
/
/
check
anyway
if
id
.
is_dynamic
(
)
{
return
Err
(
crate
:
:
private
:
:
LookupError
:
:
SubmetricIdIsDynamic
)
;
}
/
/
Re
-
use
the
metric_map
name
to
find
the
sub
-
metric
map
let
submetric_map
=
once_cell
:
:
sync
:
:
Lazy
:
:
get
(
&
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
metric_map
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricMapWasUninit
)
?
.
read
(
)
.
or
(
Err
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricMapLockWasPoisoned
)
)
?
;
let
metric
=
submetric_map
.
get
(
&
id
)
.
map
(
|
arcm
:
&
std
:
:
sync
:
:
Arc
<
metric_type
>
|
arcm
.
as_ref
(
)
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricLookupFailed
)
?
;
Ok
(
(
metric
.
get_metadata
(
)
None
)
)
}
}
}
;
(
metric_type
:
ident
submetric_type
:
ident
metric_map
:
ident
labeled_map
:
ident
)
=
>
{
/
/
Define
MetricMetadataGetter
for
the
base
type
with
awareness
of
the
/
/
other
type
(
i
.
e
.
Counter
is
aware
of
LabeledCounter
)
.
impl
crate
:
:
private
:
:
MetricMetadataGetterImpl
for
metric_type
{
define_get_base_metric_metadata_by_id
!
(
metric_type
metric_map
)
;
fn
get_sub_metric_metadata_by_id
(
id
:
crate
:
:
private
:
:
SubMetricId
)
-
>
crate
:
:
private
:
:
LookupResult
<
(
crate
:
:
private
:
:
MetricMetadata
Option
<
String
>
)
>
{
use
crate
:
:
private
:
:
metric_getter
:
:
MetricNamer
;
/
/
We
should
have
a
non
-
dynamic
ID
here
as
dynamic
/
/
metrics
always
have
base
metric
IDs
but
we
should
/
/
check
anyway
if
id
.
is_dynamic
(
)
{
return
Err
(
crate
:
:
private
:
:
LookupError
:
:
SubmetricIdIsDynamic
)
;
}
/
/
Re
-
use
the
metric_map
name
to
find
the
sub
-
metric
map
let
submetric_map
=
once_cell
:
:
sync
:
:
Lazy
:
:
get
(
&
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
metric_map
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricMapWasUninit
)
?
.
read
(
)
.
or
(
Err
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricMapLockWasPoisoned
)
)
?
;
let
submetric
:
&
submetric_type
=
submetric_map
.
get
(
&
id
)
.
map
(
|
arcm
:
&
std
:
:
sync
:
:
Arc
<
submetric_type
>
|
arcm
.
as_ref
(
)
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricLookupFailed
)
?
;
match
submetric
.
get_base_metric
(
)
{
BaseMetricResult
:
:
BaseMetric
(
metric
)
=
>
Ok
(
(
metric
.
get_metadata
(
)
None
)
)
BaseMetricResult
:
:
BaseMetricWithLabel
(
metric
label
)
=
>
{
Ok
(
(
metric
.
get_metadata
(
)
Some
(
label
.
to_string
(
)
)
)
)
}
BaseMetricResult
:
:
IndexLabelPair
(
id
label
)
=
>
{
match
metric_type
:
:
get_base_metric_metadata_by_id
(
id
)
{
Ok
(
(
metadata
_
)
)
=
>
Ok
(
(
metadata
Some
(
label
.
to_string
(
)
)
)
)
e
=
>
e
}
}
BaseMetricResult
:
:
None
=
>
{
Err
(
crate
:
:
private
:
:
LookupError
:
:
NoBaseMetricForThisLabeledType
)
}
}
}
}
impl
crate
:
:
private
:
:
MetricMetadataGetterImpl
for
submetric_type
{
fn
get_base_metric_metadata_by_id
(
id
:
crate
:
:
private
:
:
BaseMetricId
)
-
>
crate
:
:
private
:
:
LookupResult
<
(
crate
:
:
private
:
:
MetricMetadata
Option
<
String
>
)
>
{
use
crate
:
:
private
:
:
metric_getter
:
:
MetricNamer
;
/
/
A
base
metric
id
means
that
we
have
a
labeled
JOG
metric
/
/
so
it
must
be
dynamic
.
Report
an
error
if
condition
is
not
/
/
met
.
if
!
id
.
is_dynamic
(
)
{
return
Err
(
crate
:
:
private
:
:
LookupError
:
:
LabeledBaseMetricIsNotDynamic
)
;
}
/
/
A
dynamic
ID
means
that
we
have
a
JOG
metric
/
/
Look
up
the
wrapped
labeled
metric
from
the
dynamic
maps
.
/
/
/
/
Warning
:
We
acquire
the
read
lock
for
the
labeled
map
here
and
the
lock
/
/
remains
held
until
dynamic_map
is
dropped
at
the
end
of
this
function
.
/
/
Nothing
called
from
this
function
is
allowed
grab
a
write
lock
on
the
dynamic
/
/
map
or
there
will
be
a
deadlock
!
let
dynamic_map
=
once_cell
:
:
sync
:
:
Lazy
:
:
get
(
&
crate
:
:
factory
:
:
__jog_metric_maps
:
:
labeled_map
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
JOGMetricMapWasUninit
)
?
.
read
(
)
.
or
(
Err
(
crate
:
:
private
:
:
LookupError
:
:
JOGMetricMapLockWasPoisoned
)
)
?
;
let
labeled
=
dynamic_map
.
get
(
&
id
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
JOGMetricMapLookupFailed
)
?
;
let
label_string
=
{
/
/
We
can
'
t
directly
use
labeled
to
get
a
metric
instance
as
/
/
we
don
'
t
know
the
label
.
Instead
we
use
the
base
metric
/
/
id
to
find
the
label
using
the
static
submetric
map
.
/
/
Warning
:
We
acquire
the
read
lock
for
LABELED_METRICS_TO_IDS
/
/
here
and
the
lock
remains
held
until
map
is
dropped
at
the
end
of
/
/
this
scope
.
let
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
LABELED_METRICS_TO_IDS
.
read
(
)
.
or
(
Err
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricMapLockWasPoisoned
)
)
?
;
/
/
Iterate
over
the
keys
of
the
hash
table
to
find
the
ID
and
extract
the
/
/
corresponding
label
.
map
.
keys
(
)
.
find_map
(
|
(
key_id
key_label
)
|
{
if
*
key_id
=
=
id
{
Some
(
key_label
.
clone
(
)
)
}
else
{
None
}
}
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
ReverseSubmetricLookupFailed
)
?
}
;
let
metadata
=
labeled
.
get
(
&
label_string
)
.
get_metadata
(
)
;
Ok
(
(
metadata
Some
(
label_string
)
)
)
}
fn
get_sub_metric_metadata_by_id
(
id
:
crate
:
:
private
:
:
SubMetricId
)
-
>
crate
:
:
private
:
:
LookupResult
<
(
crate
:
:
private
:
:
MetricMetadata
Option
<
String
>
)
>
{
use
crate
:
:
private
:
:
metric_getter
:
:
MetricNamer
;
/
/
We
should
have
a
non
-
dynamic
ID
here
as
dynamic
/
/
metrics
always
have
base
metric
IDs
but
we
should
/
/
check
anyway
if
id
.
is_dynamic
(
)
{
return
Err
(
crate
:
:
private
:
:
LookupError
:
:
SubmetricIdIsDynamic
)
;
}
/
/
Re
-
use
the
metric_map
name
to
find
the
sub
-
metric
map
let
submetric_map
=
once_cell
:
:
sync
:
:
Lazy
:
:
get
(
&
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
metric_map
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricMapWasUninit
)
?
.
read
(
)
.
or
(
Err
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricMapLockWasPoisoned
)
)
?
;
let
submetric
=
submetric_map
.
get
(
&
id
)
.
map
(
|
arcm
:
&
std
:
:
sync
:
:
Arc
<
submetric_type
>
|
arcm
.
as_ref
(
)
)
.
ok_or
(
crate
:
:
private
:
:
LookupError
:
:
FOGSubmetricLookupFailed
)
?
;
Ok
(
(
submetric
.
get_metadata
(
)
None
)
)
}
}
}
;
}
#
[
derive
(
Debug
PartialEq
Eq
Hash
Copy
Clone
Deserialize
Serialize
)
]
pub
enum
MetricId
{
Id
(
BaseMetricId
)
SubId
(
SubMetricId
)
}
impl
MetricId
{
pub
fn
base_metric_id
(
self
)
-
>
Option
<
BaseMetricId
>
{
match
self
{
MetricId
:
:
Id
(
base_metric_id
)
=
>
Some
(
base_metric_id
)
_
=
>
None
}
}
pub
fn
is_base_metric_id
(
&
self
)
-
>
bool
{
matches
!
(
self
MetricId
:
:
Id
(
_
)
)
}
pub
fn
is_dynamic
(
self
)
-
>
bool
{
*
self
&
(
1
<
<
crate
:
:
factory
:
:
DYNAMIC_METRIC_BIT
)
>
0
}
}
#
[
cfg
(
feature
=
"
with_gecko
"
)
]
impl
MetricId
{
pub
fn
get_identifiers
(
&
self
)
-
>
(
String
Option
<
String
>
)
{
match
self
{
MetricId
:
:
Id
(
id
)
=
>
(
id
.
get_name
(
)
None
)
MetricId
:
:
SubId
(
sid
)
=
>
match
sid
.
lookup_metric_id_and_label
(
)
{
Some
(
(
id
label
)
)
=
>
(
id
.
get_name
(
)
Some
(
label
)
)
None
=
>
(
String
:
:
from
(
"
Could
not
find
submetric
in
maps
"
)
None
)
}
}
}
}
impl
From
<
&
MetricId
>
for
MetricId
{
fn
from
(
base_metric_id
:
&
MetricId
)
-
>
MetricId
{
*
base_metric_id
}
}
impl
From
<
BaseMetricId
>
for
MetricId
{
fn
from
(
base_metric_id
:
BaseMetricId
)
-
>
MetricId
{
MetricId
:
:
Id
(
base_metric_id
)
}
}
impl
From
<
SubMetricId
>
for
MetricId
{
fn
from
(
submetric_id
:
SubMetricId
)
-
>
MetricId
{
MetricId
:
:
SubId
(
submetric_id
)
}
}
impl
std
:
:
ops
:
:
Deref
for
MetricId
{
type
Target
=
u32
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
match
self
{
MetricId
:
:
Id
(
BaseMetricId
(
m
)
)
=
>
m
MetricId
:
:
SubId
(
SubMetricId
(
m
)
)
=
>
m
}
}
}
#
[
derive
(
Debug
PartialEq
Eq
Hash
Copy
Clone
Deserialize
Serialize
)
]
#
[
repr
(
transparent
)
]
pub
struct
BaseMetricId
(
pub
(
crate
)
u32
)
;
impl
BaseMetricId
{
pub
fn
new
(
id
:
u32
)
-
>
Self
{
Self
(
id
)
}
pub
fn
is_dynamic
(
self
)
-
>
bool
{
self
.
0
&
(
1
<
<
crate
:
:
factory
:
:
DYNAMIC_METRIC_BIT
)
>
0
}
}
impl
malloc_size_of
:
:
MallocSizeOf
for
BaseMetricId
{
#
[
inline
(
always
)
]
fn
size_of
(
&
self
_
:
&
mut
malloc_size_of
:
:
MallocSizeOfOps
)
-
>
usize
{
0
}
}
#
[
cfg
(
feature
=
"
with_gecko
"
)
]
impl
BaseMetricId
{
pub
(
crate
)
fn
get_name
(
&
self
)
-
>
String
{
String
:
:
from
(
self
.
lookup_canonical_metric_name
(
)
.
unwrap_or
(
"
id
not
found
"
)
)
}
pub
(
crate
)
fn
lookup_canonical_metric_name
(
&
self
)
-
>
Option
<
&
'
static
str
>
{
#
[
allow
(
unused
)
]
use
std
:
:
ffi
:
:
{
c_char
CStr
}
;
extern
"
C
"
{
fn
FOG_GetMetricIdentifier
(
id
:
u32
)
-
>
*
const
c_char
;
}
unsafe
{
let
raw_name_ptr
=
FOG_GetMetricIdentifier
(
*
*
self
)
;
if
raw_name_ptr
.
is_null
(
)
{
None
}
else
{
match
CStr
:
:
from_ptr
(
raw_name_ptr
)
.
to_str
(
)
{
Ok
(
s
)
=
>
Some
(
s
)
Err
(
_
)
=
>
None
}
}
}
}
}
impl
From
<
u32
>
for
BaseMetricId
{
fn
from
(
id
:
u32
)
-
>
Self
{
Self
(
id
)
}
}
impl
std
:
:
ops
:
:
Deref
for
BaseMetricId
{
type
Target
=
u32
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
#
[
derive
(
Debug
PartialEq
Eq
Hash
Copy
Clone
Deserialize
Serialize
)
]
#
[
repr
(
transparent
)
]
pub
struct
SubMetricId
(
pub
(
crate
)
u32
)
;
impl
malloc_size_of
:
:
MallocSizeOf
for
SubMetricId
{
fn
size_of
(
&
self
_ops
:
&
mut
malloc_size_of
:
:
MallocSizeOfOps
)
-
>
usize
{
0
}
}
impl
SubMetricId
{
pub
fn
new
(
id
:
u32
)
-
>
Self
{
Self
(
id
)
}
pub
fn
is_dynamic
(
self
)
-
>
bool
{
self
.
0
&
(
1
<
<
crate
:
:
factory
:
:
DYNAMIC_METRIC_BIT
)
>
0
}
}
#
[
cfg
(
feature
=
"
with_gecko
"
)
]
impl
SubMetricId
{
pub
(
crate
)
fn
lookup_metric_id_and_label
(
&
self
)
-
>
Option
<
(
BaseMetricId
String
)
>
{
let
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
LABELED_METRICS_TO_IDS
.
read
(
)
.
expect
(
"
read
lock
of
submetric
ids
was
poisoned
"
)
;
map
.
iter
(
)
.
find
(
|
(
_
&
value
)
|
value
=
=
*
self
)
.
map
(
|
(
key
_
)
|
key
.
clone
(
)
)
}
}
impl
From
<
u32
>
for
SubMetricId
{
fn
from
(
id
:
u32
)
-
>
Self
{
Self
(
id
)
}
}
impl
std
:
:
ops
:
:
Deref
for
SubMetricId
{
type
Target
=
u32
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
0
}
}
