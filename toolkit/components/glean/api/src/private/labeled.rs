use
std
:
:
sync
:
:
RwLock
;
use
glean_core
:
:
metrics
:
:
MetricType
;
use
super
:
:
{
BooleanMetric
CommonMetricData
CounterMetric
ErrorType
MetricId
StringMetric
}
;
use
crate
:
:
dispatcher
;
use
crate
:
:
ipc
:
:
need_ipc
;
mod
private
{
use
super
:
:
{
BooleanMetric
CommonMetricData
CounterMetric
MetricId
StringMetric
}
;
use
crate
:
:
ipc
:
:
need_ipc
;
use
std
:
:
sync
:
:
Arc
;
pub
trait
Sealed
{
type
Inner
:
glean_core
:
:
metrics
:
:
MetricType
+
Clone
;
fn
from_inner
(
id
:
MetricId
metric
:
Self
:
:
Inner
)
-
>
Self
;
fn
new_inner
(
meta
:
CommonMetricData
)
-
>
Self
:
:
Inner
;
}
impl
Sealed
for
BooleanMetric
{
type
Inner
=
glean_core
:
:
metrics
:
:
BooleanMetric
;
fn
from_inner
(
_id
:
MetricId
metric
:
Self
:
:
Inner
)
-
>
Self
{
assert
!
(
!
need_ipc
(
)
"
Labeled
Boolean
metrics
are
not
supported
in
non
-
main
processes
"
)
;
BooleanMetric
:
:
Parent
(
Arc
:
:
new
(
crate
:
:
private
:
:
boolean
:
:
BooleanMetricImpl
(
metric
)
)
)
}
fn
new_inner
(
meta
:
CommonMetricData
)
-
>
Self
:
:
Inner
{
glean_core
:
:
metrics
:
:
BooleanMetric
:
:
new
(
meta
)
}
}
impl
Sealed
for
StringMetric
{
type
Inner
=
glean_core
:
:
metrics
:
:
StringMetric
;
fn
from_inner
(
_id
:
MetricId
metric
:
Self
:
:
Inner
)
-
>
Self
{
assert
!
(
!
need_ipc
(
)
"
Labeled
String
metrics
are
not
supported
in
non
-
main
processes
"
)
;
StringMetric
:
:
Parent
(
crate
:
:
private
:
:
string
:
:
StringMetricImpl
(
metric
)
)
}
fn
new_inner
(
meta
:
CommonMetricData
)
-
>
Self
:
:
Inner
{
glean_core
:
:
metrics
:
:
StringMetric
:
:
new
(
meta
)
}
}
impl
Sealed
for
CounterMetric
{
type
Inner
=
glean_core
:
:
metrics
:
:
CounterMetric
;
fn
from_inner
(
id
:
MetricId
metric
:
Self
:
:
Inner
)
-
>
Self
{
assert
!
(
!
need_ipc
(
)
)
;
CounterMetric
:
:
Parent
{
id
inner
:
Arc
:
:
new
(
crate
:
:
private
:
:
counter
:
:
CounterMetricImpl
(
metric
)
)
}
}
fn
new_inner
(
meta
:
CommonMetricData
)
-
>
Self
:
:
Inner
{
glean_core
:
:
metrics
:
:
CounterMetric
:
:
new
(
meta
)
}
}
}
pub
trait
AllowLabeled
:
private
:
:
Sealed
{
}
impl
<
T
>
AllowLabeled
for
T
where
T
:
private
:
:
Sealed
{
}
#
[
derive
(
Debug
)
]
pub
struct
LabeledMetric
<
T
:
AllowLabeled
>
{
id
:
MetricId
core
:
RwLock
<
glean_core
:
:
metrics
:
:
LabeledMetric
<
T
:
:
Inner
>
>
}
impl
<
T
>
LabeledMetric
<
T
>
where
T
:
AllowLabeled
{
pub
fn
new
(
id
:
MetricId
meta
:
CommonMetricData
labels
:
Option
<
Vec
<
String
>
>
)
-
>
LabeledMetric
<
T
>
{
let
submetric
=
T
:
:
new_inner
(
meta
)
;
let
core
=
glean_core
:
:
metrics
:
:
LabeledMetric
:
:
new
(
submetric
labels
)
;
LabeledMetric
{
id
core
:
RwLock
:
:
new
(
core
)
}
}
pub
fn
get
(
&
self
label
:
&
str
)
-
>
T
{
if
need_ipc
(
)
{
panic
!
(
"
Use
of
labeled
metrics
in
IPC
land
not
yet
implemented
!
"
)
;
}
else
{
let
core
=
self
.
core
.
write
(
)
.
expect
(
"
lock
of
wrapped
metric
was
poisoned
"
)
;
let
inner
=
core
.
get
(
label
)
;
T
:
:
from_inner
(
self
.
id
inner
)
}
}
pub
fn
test_get_num_recorded_errors
(
&
self
error_type
:
ErrorType
storage_name
:
Option
<
&
str
>
)
-
>
Result
<
i32
String
>
{
dispatcher
:
:
block_on_queue
(
)
;
crate
:
:
with_glean
(
move
|
glean
|
{
let
core
=
self
.
core
.
read
(
)
.
expect
(
"
lock
of
wrapped
metric
was
poisoned
"
)
;
glean_core
:
:
test_get_num_recorded_errors
(
&
glean
&
core
.
get_submetric
(
)
.
meta
(
)
error_type
storage_name
)
}
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
once_cell
:
:
sync
:
:
Lazy
;
use
super
:
:
*
;
use
crate
:
:
common_test
:
:
*
;
static
GLOBAL_METRIC
:
Lazy
<
LabeledMetric
<
BooleanMetric
>
>
=
Lazy
:
:
new
(
|
|
{
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
global
"
.
into
(
)
category
:
"
metric
"
.
into
(
)
send_in_pings
:
vec
!
[
"
ping
"
.
into
(
)
]
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
}
)
;
#
[
test
]
fn
smoke_test_global_metric
(
)
{
let
_lock
=
lock_test
(
)
;
GLOBAL_METRIC
.
get
(
"
a_value
"
)
.
set
(
true
)
;
assert_eq
!
(
true
GLOBAL_METRIC
.
get
(
"
a_value
"
)
.
test_get_value
(
"
ping
"
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
sets_labeled_bool_metrics
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
BooleanMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
bool
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
;
metric
.
get
(
"
upload
"
)
.
set
(
true
)
;
assert
!
(
metric
.
get
(
"
upload
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
None
metric
.
get
(
"
download
"
)
.
test_get_value
(
"
store1
"
)
)
;
}
#
[
test
]
fn
sets_labeled_string_metrics
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
StringMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
string
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
;
metric
.
get
(
"
upload
"
)
.
set
(
"
Glean
"
)
;
assert_eq
!
(
"
Glean
"
metric
.
get
(
"
upload
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
None
metric
.
get
(
"
download
"
)
.
test_get_value
(
"
store1
"
)
)
;
}
#
[
test
]
fn
sets_labeled_counter_metrics
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
CounterMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
counter
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
;
metric
.
get
(
"
upload
"
)
.
add
(
10
)
;
assert_eq
!
(
10
metric
.
get
(
"
upload
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
None
metric
.
get
(
"
download
"
)
.
test_get_value
(
"
store1
"
)
)
;
}
#
[
test
]
fn
records_errors
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
BooleanMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
bool
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
;
metric
.
get
(
"
this_string_has_more_than_thirty_characters
"
)
.
set
(
true
)
;
assert_eq
!
(
Ok
(
1
)
metric
.
test_get_num_recorded_errors
(
ErrorType
:
:
InvalidLabel
None
)
)
;
}
#
[
test
]
fn
predefined_labels
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
BooleanMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
bool
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
Some
(
vec
!
[
"
label1
"
.
into
(
)
"
label2
"
.
into
(
)
]
)
)
;
metric
.
get
(
"
label1
"
)
.
set
(
true
)
;
metric
.
get
(
"
label2
"
)
.
set
(
false
)
;
metric
.
get
(
"
not_a_label
"
)
.
set
(
true
)
;
assert_eq
!
(
true
metric
.
get
(
"
label1
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
false
metric
.
get
(
"
label2
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
true
metric
.
get
(
"
__other__
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert
!
(
metric
.
test_get_num_recorded_errors
(
ErrorType
:
:
InvalidLabel
None
)
.
is_err
(
)
)
;
}
}
