use
inherent
:
:
inherent
;
use
super
:
:
{
BooleanMetric
CommonMetricData
CounterMetric
ErrorType
MetricId
StringMetric
}
;
use
crate
:
:
ipc
:
:
need_ipc
;
mod
private
{
use
super
:
:
{
BooleanMetric
CounterMetric
StringMetric
}
;
pub
trait
Sealed
{
type
GleanMetric
:
glean
:
:
private
:
:
AllowLabeled
+
Clone
;
}
impl
Sealed
for
BooleanMetric
{
type
GleanMetric
=
glean
:
:
private
:
:
BooleanMetric
;
}
impl
Sealed
for
StringMetric
{
type
GleanMetric
=
glean
:
:
private
:
:
StringMetric
;
}
impl
Sealed
for
CounterMetric
{
type
GleanMetric
=
glean
:
:
private
:
:
CounterMetric
;
}
}
pub
trait
AllowLabeled
:
private
:
:
Sealed
{
}
impl
<
T
>
AllowLabeled
for
T
where
T
:
private
:
:
Sealed
{
}
pub
struct
LabeledMetric
<
T
:
AllowLabeled
>
{
_id
:
MetricId
core
:
glean
:
:
private
:
:
LabeledMetric
<
T
:
:
GleanMetric
>
}
impl
<
T
>
LabeledMetric
<
T
>
where
T
:
AllowLabeled
{
pub
fn
new
(
id
:
MetricId
meta
:
CommonMetricData
labels
:
Option
<
Vec
<
String
>
>
)
-
>
LabeledMetric
<
T
>
{
let
core
=
glean
:
:
private
:
:
LabeledMetric
:
:
new
(
meta
labels
)
;
LabeledMetric
{
_id
:
id
core
}
}
}
#
[
inherent
(
pub
)
]
impl
<
U
>
glean_core
:
:
traits
:
:
Labeled
<
U
:
:
GleanMetric
>
for
LabeledMetric
<
U
>
where
U
:
AllowLabeled
+
Clone
{
fn
get
(
&
self
label
:
&
str
)
-
>
U
:
:
GleanMetric
{
if
need_ipc
(
)
{
panic
!
(
"
Use
of
labeled
metrics
in
IPC
land
not
yet
implemented
!
"
)
;
}
else
{
self
.
core
.
get
(
label
)
}
}
fn
test_get_num_recorded_errors
<
'
a
S
:
Into
<
Option
<
&
'
a
str
>
>
>
(
&
self
error
:
ErrorType
ping_name
:
S
)
-
>
i32
{
if
need_ipc
(
)
{
panic
!
(
"
Use
of
labeled
metrics
in
IPC
land
not
yet
implemented
!
"
)
;
}
else
{
self
.
core
.
test_get_num_recorded_errors
(
error
ping_name
)
}
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
once_cell
:
:
sync
:
:
Lazy
;
use
super
:
:
*
;
use
crate
:
:
common_test
:
:
*
;
static
GLOBAL_METRIC
:
Lazy
<
LabeledMetric
<
BooleanMetric
>
>
=
Lazy
:
:
new
(
|
|
{
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
global
"
.
into
(
)
category
:
"
metric
"
.
into
(
)
send_in_pings
:
vec
!
[
"
ping
"
.
into
(
)
]
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
}
)
;
#
[
test
]
fn
smoke_test_global_metric
(
)
{
let
_lock
=
lock_test
(
)
;
GLOBAL_METRIC
.
get
(
"
a_value
"
)
.
set
(
true
)
;
assert_eq
!
(
true
GLOBAL_METRIC
.
get
(
"
a_value
"
)
.
test_get_value
(
"
ping
"
)
.
unwrap
(
)
)
;
}
#
[
test
]
fn
sets_labeled_bool_metrics
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
BooleanMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
bool
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
;
metric
.
get
(
"
upload
"
)
.
set
(
true
)
;
assert
!
(
metric
.
get
(
"
upload
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
None
metric
.
get
(
"
download
"
)
.
test_get_value
(
"
store1
"
)
)
;
}
#
[
test
]
fn
sets_labeled_string_metrics
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
StringMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
string
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
;
metric
.
get
(
"
upload
"
)
.
set
(
"
Glean
"
)
;
assert_eq
!
(
"
Glean
"
metric
.
get
(
"
upload
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
None
metric
.
get
(
"
download
"
)
.
test_get_value
(
"
store1
"
)
)
;
}
#
[
test
]
fn
sets_labeled_counter_metrics
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
CounterMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
counter
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
;
metric
.
get
(
"
upload
"
)
.
add
(
10
)
;
assert_eq
!
(
10
metric
.
get
(
"
upload
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
None
metric
.
get
(
"
download
"
)
.
test_get_value
(
"
store1
"
)
)
;
}
#
[
test
]
fn
records_errors
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
BooleanMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
bool
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
None
)
;
metric
.
get
(
"
this_string_has_more_than_thirty_characters
"
)
.
set
(
true
)
;
assert_eq
!
(
1
metric
.
test_get_num_recorded_errors
(
ErrorType
:
:
InvalidLabel
None
)
)
;
}
#
[
test
]
fn
predefined_labels
(
)
{
let
_lock
=
lock_test
(
)
;
let
store_names
:
Vec
<
String
>
=
vec
!
[
"
store1
"
.
into
(
)
]
;
let
metric
:
LabeledMetric
<
BooleanMetric
>
=
LabeledMetric
:
:
new
(
0
.
into
(
)
CommonMetricData
{
name
:
"
bool
"
.
into
(
)
category
:
"
labeled
"
.
into
(
)
send_in_pings
:
store_names
disabled
:
false
.
.
Default
:
:
default
(
)
}
Some
(
vec
!
[
"
label1
"
.
into
(
)
"
label2
"
.
into
(
)
]
)
)
;
metric
.
get
(
"
label1
"
)
.
set
(
true
)
;
metric
.
get
(
"
label2
"
)
.
set
(
false
)
;
metric
.
get
(
"
not_a_label
"
)
.
set
(
true
)
;
assert_eq
!
(
true
metric
.
get
(
"
label1
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
false
metric
.
get
(
"
label2
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
true
metric
.
get
(
"
__other__
"
)
.
test_get_value
(
"
store1
"
)
.
unwrap
(
)
)
;
assert_eq
!
(
0
metric
.
test_get_num_recorded_errors
(
ErrorType
:
:
InvalidLabel
None
)
)
;
}
}
