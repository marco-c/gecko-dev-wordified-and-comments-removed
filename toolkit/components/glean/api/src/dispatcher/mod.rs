use
std
:
:
{
mem
sync
:
:
{
atomic
:
:
{
AtomicBool
Ordering
}
Arc
}
thread
}
;
use
crossbeam_channel
:
:
{
bounded
unbounded
SendError
Sender
TrySendError
}
;
use
thiserror
:
:
Error
;
pub
use
global
:
:
*
;
mod
global
;
enum
Command
{
Task
(
Box
<
dyn
FnOnce
(
)
+
Send
>
)
Swap
(
Sender
<
(
)
>
)
Shutdown
}
#
[
derive
(
Error
Debug
PartialEq
)
]
pub
enum
DispatchError
{
#
[
error
(
"
The
worker
panicked
while
running
a
task
"
)
]
WorkerPanic
#
[
error
(
"
Maximum
queue
size
reached
"
)
]
QueueFull
#
[
error
(
"
Pre
-
init
buffer
was
already
flushed
"
)
]
AlreadyFlushed
#
[
error
(
"
Failed
to
send
command
to
worker
thread
"
)
]
SendError
#
[
error
(
"
Failed
to
receive
from
channel
"
)
]
RecvError
(
#
[
from
]
crossbeam_channel
:
:
RecvError
)
}
impl
From
<
TrySendError
<
Command
>
>
for
DispatchError
{
fn
from
(
err
:
TrySendError
<
Command
>
)
-
>
Self
{
match
err
{
TrySendError
:
:
Full
(
_
)
=
>
DispatchError
:
:
QueueFull
_
=
>
DispatchError
:
:
SendError
}
}
}
impl
<
T
>
From
<
SendError
<
T
>
>
for
DispatchError
{
fn
from
(
_
:
SendError
<
T
>
)
-
>
Self
{
DispatchError
:
:
SendError
}
}
#
[
derive
(
Clone
)
]
struct
DispatchGuard
{
queue_preinit
:
Arc
<
AtomicBool
>
preinit
:
Sender
<
Command
>
queue
:
Sender
<
Command
>
}
impl
DispatchGuard
{
pub
fn
launch
(
&
self
task
:
impl
FnOnce
(
)
+
Send
+
'
static
)
-
>
Result
<
(
)
DispatchError
>
{
let
task
=
Command
:
:
Task
(
Box
:
:
new
(
task
)
)
;
self
.
send
(
task
)
}
pub
fn
shutdown
(
&
self
)
-
>
Result
<
(
)
DispatchError
>
{
self
.
send
(
Command
:
:
Shutdown
)
}
fn
send
(
&
self
task
:
Command
)
-
>
Result
<
(
)
DispatchError
>
{
if
self
.
queue_preinit
.
load
(
Ordering
:
:
SeqCst
)
{
match
self
.
preinit
.
try_send
(
task
)
{
Ok
(
(
)
)
=
>
Ok
(
(
)
)
Err
(
TrySendError
:
:
Full
(
_
)
)
=
>
Err
(
DispatchError
:
:
QueueFull
)
Err
(
TrySendError
:
:
Disconnected
(
_
)
)
=
>
Err
(
DispatchError
:
:
SendError
)
}
}
else
{
self
.
queue
.
send
(
task
)
?
;
Ok
(
(
)
)
}
}
}
pub
struct
Dispatcher
{
queue_preinit
:
Arc
<
AtomicBool
>
block_sender
:
Sender
<
(
)
>
preinit_sender
:
Sender
<
Command
>
sender
:
Sender
<
Command
>
}
impl
Dispatcher
{
pub
fn
new
(
max_queue_size
:
usize
)
-
>
Self
{
let
(
block_sender
block_receiver
)
=
bounded
(
0
)
;
let
(
preinit_sender
preinit_receiver
)
=
bounded
(
max_queue_size
)
;
let
(
sender
mut
unbounded_receiver
)
=
unbounded
(
)
;
let
queue_preinit
=
Arc
:
:
new
(
AtomicBool
:
:
new
(
true
)
)
;
thread
:
:
spawn
(
move
|
|
{
if
let
Err
(
_
)
=
block_receiver
.
recv
(
)
{
log
:
:
error
!
(
"
The
task
producer
was
disconnected
.
Worker
thread
will
exit
.
"
)
;
return
;
}
let
mut
receiver
=
preinit_receiver
;
loop
{
use
Command
:
:
*
;
match
receiver
.
recv
(
)
{
Ok
(
Shutdown
)
=
>
{
break
;
}
Ok
(
Task
(
f
)
)
=
>
{
(
f
)
(
)
;
}
Ok
(
Swap
(
swap_done
)
)
=
>
{
mem
:
:
swap
(
&
mut
receiver
&
mut
unbounded_receiver
)
;
swap_done
.
send
(
(
)
)
.
expect
(
"
The
caller
of
flush_init
has
gone
missing
"
)
;
}
Err
(
_
)
=
>
{
log
:
:
error
!
(
"
The
task
producer
was
disconnected
.
Worker
thread
will
exit
.
"
)
;
return
;
}
}
}
}
)
;
Dispatcher
{
queue_preinit
block_sender
preinit_sender
sender
}
}
fn
guard
(
&
self
)
-
>
DispatchGuard
{
DispatchGuard
{
queue_preinit
:
Arc
:
:
clone
(
&
self
.
queue_preinit
)
preinit
:
self
.
preinit_sender
.
clone
(
)
queue
:
self
.
sender
.
clone
(
)
}
}
pub
fn
flush_init
(
&
mut
self
)
-
>
Result
<
(
)
DispatchError
>
{
let
old_val
=
self
.
queue_preinit
.
swap
(
false
Ordering
:
:
SeqCst
)
;
if
!
old_val
{
return
Err
(
DispatchError
:
:
AlreadyFlushed
)
;
}
self
.
block_sender
.
send
(
(
)
)
?
;
let
(
swap_sender
swap_receiver
)
=
bounded
(
0
)
;
self
.
preinit_sender
.
send
(
Command
:
:
Swap
(
swap_sender
)
)
.
map_err
(
|
_
|
DispatchError
:
:
SendError
)
?
;
swap_receiver
.
recv
(
)
?
;
Ok
(
(
)
)
}
}
