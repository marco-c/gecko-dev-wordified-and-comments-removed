use
once_cell
:
:
sync
:
:
{
Lazy
OnceCell
}
;
use
std
:
:
sync
:
:
RwLock
;
use
super
:
:
{
DispatchError
DispatchGuard
Dispatcher
}
;
const
GLOBAL_DISPATCHER_LIMIT
:
usize
=
100
;
static
GLOBAL_DISPATCHER
:
Lazy
<
RwLock
<
Option
<
Dispatcher
>
>
>
=
Lazy
:
:
new
(
|
|
RwLock
:
:
new
(
Some
(
Dispatcher
:
:
new
(
GLOBAL_DISPATCHER_LIMIT
)
)
)
)
;
fn
guard
(
)
-
>
&
'
static
DispatchGuard
{
static
GLOBAL_GUARD
:
OnceCell
<
DispatchGuard
>
=
OnceCell
:
:
new
(
)
;
GLOBAL_GUARD
.
get_or_init
(
|
|
{
let
lock
=
GLOBAL_DISPATCHER
.
read
(
)
.
unwrap
(
)
;
lock
.
as_ref
(
)
.
unwrap
(
)
.
guard
(
)
}
)
}
pub
fn
launch
(
task
:
impl
FnOnce
(
)
+
Send
+
'
static
)
{
match
guard
(
)
.
launch
(
task
)
{
Ok
(
_
)
=
>
{
}
Err
(
DispatchError
:
:
QueueFull
)
=
>
{
log
:
:
info
!
(
"
Exceeded
maximum
queue
size
discarding
task
"
)
;
}
Err
(
_
)
=
>
{
log
:
:
info
!
(
"
Failed
to
launch
a
task
on
the
queue
.
Discarding
task
.
"
)
;
}
}
}
pub
fn
block_on_queue
(
)
{
let
(
tx
rx
)
=
crossbeam_channel
:
:
bounded
(
0
)
;
launch
(
move
|
|
{
tx
.
send
(
(
)
)
.
expect
(
"
(
worker
)
Can
'
t
send
message
on
single
-
use
channel
"
)
}
)
;
rx
.
recv
(
)
.
expect
(
"
Failed
to
receive
message
on
single
-
use
channel
"
)
;
}
pub
fn
flush_init
(
)
-
>
Result
<
(
)
DispatchError
>
{
GLOBAL_DISPATCHER
.
write
(
)
.
unwrap
(
)
.
as_mut
(
)
.
map
(
|
dispatcher
|
dispatcher
.
flush_init
(
)
)
.
unwrap
(
)
}
pub
fn
try_shutdown
(
)
-
>
Result
<
(
)
DispatchError
>
{
guard
(
)
.
shutdown
(
)
}
