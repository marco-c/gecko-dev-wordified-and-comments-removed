use
std
:
:
sync
:
:
RwLock
;
use
super
:
:
{
CommonMetricData
Instant
TimeUnit
}
;
pub
struct
TimerId
(
glean_core
:
:
metrics
:
:
TimerId
)
;
#
[
derive
(
Debug
)
]
pub
struct
TimingDistributionMetric
{
inner
:
RwLock
<
glean_core
:
:
metrics
:
:
TimingDistributionMetric
>
}
impl
TimingDistributionMetric
{
pub
fn
new
(
meta
:
CommonMetricData
time_unit
:
TimeUnit
)
-
>
Self
{
let
inner
=
RwLock
:
:
new
(
glean_core
:
:
metrics
:
:
TimingDistributionMetric
:
:
new
(
meta
time_unit
)
)
;
Self
{
inner
}
}
pub
fn
start
(
&
self
)
-
>
TimerId
{
let
now
=
Instant
:
:
now
(
)
;
let
mut
inner
=
self
.
inner
.
write
(
)
.
expect
(
"
lock
of
wrapped
metric
was
poisoned
"
)
;
TimerId
(
inner
.
set_start
(
now
.
as_nanos
(
)
)
)
}
pub
fn
stop_and_accumulate
(
&
self
id
:
TimerId
)
{
crate
:
:
with_glean
(
|
glean
|
{
let
TimerId
(
id
)
=
id
;
let
now
=
Instant
:
:
now
(
)
;
let
mut
inner
=
self
.
inner
.
write
(
)
.
expect
(
"
lock
of
wrapped
metric
was
poisoned
"
)
;
inner
.
set_stop_and_accumulate
(
glean
id
now
.
as_nanos
(
)
)
}
)
}
pub
fn
cancel
(
&
self
id
:
TimerId
)
{
let
TimerId
(
id
)
=
id
;
let
mut
inner
=
self
.
inner
.
write
(
)
.
expect
(
"
lock
of
wrapped
metric
was
poisoned
"
)
;
inner
.
cancel
(
id
)
}
pub
fn
test_get_value
(
&
self
storage_name
:
&
str
)
-
>
Option
<
String
>
{
crate
:
:
with_glean
(
move
|
glean
|
{
let
inner
=
self
.
inner
.
read
(
)
.
expect
(
"
lock
of
wrapped
metric
was
poisoned
"
)
;
inner
.
test_get_value_as_json_string
(
glean
storage_name
)
}
)
}
}
