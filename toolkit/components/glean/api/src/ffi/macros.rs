macro_rules
!
with_metric
{
(
BOOLEAN_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
BOOLEAN_MAP
id
m
f
)
}
;
(
COUNTER_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
COUNTER_MAP
id
m
f
)
}
;
(
STRING_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
STRING_MAP
id
m
f
)
}
;
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
just_with_metric
!
(
map
id
m
f
)
}
;
}
macro_rules
!
just_with_metric
{
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
match
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
map
.
get
(
&
id
.
into
(
)
)
{
Some
(
m
)
=
>
f
None
=
>
panic
!
(
"
No
metric
for
id
{
}
"
id
)
}
}
;
}
macro_rules
!
maybe_labeled_with_metric
{
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
if
id
>
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
MIN_LABELED_SUBMETRIC_ID
{
let
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
map
.
read
(
)
.
expect
(
"
Read
lock
for
labeled
metric
map
was
poisoned
"
)
;
match
map
.
get
(
&
id
.
into
(
)
)
{
Some
(
m
)
=
>
f
None
=
>
panic
!
(
"
No
submetric
for
id
{
}
"
id
)
}
}
else
{
just_with_metric
!
(
map
id
m
f
)
}
}
;
}
macro_rules
!
test_has
{
(
metric
:
ident
storage
:
ident
)
=
>
{
{
let
storage
=
if
storage
.
is_empty
(
)
{
None
}
else
{
Some
(
storage
.
to_utf8
(
)
)
}
;
metric
.
test_get_value
(
storage
.
as_deref
(
)
)
.
is_some
(
)
}
}
;
}
macro_rules
!
test_get
{
(
metric
:
ident
storage
:
ident
)
=
>
{
{
let
storage
=
if
storage
.
is_empty
(
)
{
None
}
else
{
Some
(
storage
.
to_utf8
(
)
)
}
;
metric
.
test_get_value
(
storage
.
as_deref
(
)
)
.
unwrap
(
)
}
}
;
}
macro_rules
!
labeled_submetric_get
{
(
id
:
ident
label
:
ident
labeled_map
:
ident
submetric_map
:
ident
metric_type
:
ty
)
=
>
{
{
let
tuple
=
(
id
label
.
to_utf8
(
)
.
into
(
)
)
;
{
let
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
LABELED_METRICS_TO_IDS
.
read
(
)
.
expect
(
"
read
lock
of
submetric
ids
was
poisoned
"
)
;
if
let
Some
(
submetric_id
)
=
map
.
get
(
&
tuple
)
{
return
*
submetric_id
;
}
}
/
/
Gotta
actually
create
a
new
submetric
with
a
new
id
.
let
submetric_id
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
NEXT_LABELED_SUBMETRIC_ID
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
{
with_metric
!
(
labeled_map
id
metric
{
let
submetric
=
metric
.
get
(
&
tuple
.
1
)
;
let
mut
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
submetric_map
.
write
(
)
.
expect
(
"
write
lock
of
submetric
map
was
poisoned
"
)
;
map
.
insert
(
submetric_id
.
into
(
)
submetric
)
;
}
)
;
}
let
mut
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
LABELED_METRICS_TO_IDS
.
write
(
)
.
expect
(
"
write
lock
of
submetric
ids
was
poisoned
"
)
;
map
.
insert
(
tuple
submetric_id
)
;
submetric_id
}
}
;
}
