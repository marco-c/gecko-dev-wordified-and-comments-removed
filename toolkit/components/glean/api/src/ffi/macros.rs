macro_rules
!
with_metric
{
(
BOOLEAN_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
BOOLEAN_MAP
id
m
f
)
}
;
(
COUNTER_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
COUNTER_MAP
id
m
f
)
}
;
(
STRING_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
STRING_MAP
id
m
f
)
}
;
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
just_with_metric
!
(
map
id
m
f
)
}
;
}
macro_rules
!
just_with_metric
{
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
match
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
map
.
get
(
&
id
.
into
(
)
)
{
Some
(
m
)
=
>
f
None
=
>
panic
!
(
"
No
metric
for
id
{
}
"
id
)
}
}
;
}
macro_rules
!
maybe_labeled_with_metric
{
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
if
id
&
(
1
<
<
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
SUBMETRIC_BIT
)
>
0
{
let
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
map
.
read
(
)
.
expect
(
"
Read
lock
for
labeled
metric
map
was
poisoned
"
)
;
match
map
.
get
(
&
id
.
into
(
)
)
{
Some
(
m
)
=
>
f
None
=
>
panic
!
(
"
No
submetric
for
id
{
}
"
id
)
}
}
else
{
just_with_metric
!
(
map
id
m
f
)
}
}
;
}
macro_rules
!
test_has
{
(
metric
:
ident
storage
:
ident
)
=
>
{
{
let
storage
=
if
storage
.
is_empty
(
)
{
None
}
else
{
Some
(
storage
.
to_utf8
(
)
)
}
;
metric
.
test_get_value
(
storage
.
as_deref
(
)
)
.
is_some
(
)
}
}
;
}
macro_rules
!
test_get
{
(
metric
:
ident
storage
:
ident
)
=
>
{
{
let
storage
=
if
storage
.
is_empty
(
)
{
None
}
else
{
Some
(
storage
.
to_utf8
(
)
)
}
;
metric
.
test_get_value
(
storage
.
as_deref
(
)
)
.
unwrap
(
)
}
}
;
}
macro_rules
!
test_get_errors
{
(
metric
:
path
storage
:
ident
)
=
>
{
{
let
storage
=
if
storage
.
is_empty
(
)
{
None
}
else
{
Some
(
storage
.
to_utf8
(
)
)
}
;
/
/
Note
:
I
'
d
really
appreciate
a
trick
that
'
d
get
the
compiler
to
/
/
double
-
check
I
haven
'
t
missed
any
error
types
here
.
test_get_errors_string
!
(
metric
storage
)
}
}
;
}
macro_rules
!
test_get_errors_string
{
(
metric
:
path
storage
:
ident
)
=
>
{
{
let
error_types
=
[
glean
:
:
ErrorType
:
:
InvalidValue
glean
:
:
ErrorType
:
:
InvalidLabel
glean
:
:
ErrorType
:
:
InvalidState
glean
:
:
ErrorType
:
:
InvalidOverflow
]
;
let
mut
error_str
=
None
;
for
&
error_type
in
error_types
.
iter
(
)
{
let
num_errors
=
metric
.
test_get_num_recorded_errors
(
error_type
storage
.
as_deref
(
)
)
;
if
num_errors
>
0
{
error_str
=
Some
(
format
!
(
"
Metric
had
{
}
error
(
s
)
of
type
{
}
!
"
num_errors
error_type
.
as_str
(
)
)
)
;
break
;
}
}
error_str
}
}
;
}
macro_rules
!
labeled_submetric_get
{
(
id
:
ident
label
:
ident
labeled_map
:
ident
submetric_map
:
ident
metric_type
:
ty
)
=
>
{
{
let
tuple
=
(
id
label
.
to_utf8
(
)
.
into
(
)
)
;
{
let
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
LABELED_METRICS_TO_IDS
.
read
(
)
.
expect
(
"
read
lock
of
submetric
ids
was
poisoned
"
)
;
if
let
Some
(
submetric_id
)
=
map
.
get
(
&
tuple
)
{
return
*
submetric_id
;
}
}
/
/
Gotta
actually
create
a
new
submetric
with
a
new
id
.
let
submetric_id
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
NEXT_LABELED_SUBMETRIC_ID
.
fetch_add
(
1
Ordering
:
:
SeqCst
)
;
{
with_metric
!
(
labeled_map
id
metric
{
let
submetric
=
metric
.
get
(
&
tuple
.
1
)
;
let
mut
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
submetric_map
.
write
(
)
.
expect
(
"
write
lock
of
submetric
map
was
poisoned
"
)
;
map
.
insert
(
submetric_id
.
into
(
)
submetric
)
;
}
)
;
}
let
mut
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
LABELED_METRICS_TO_IDS
.
write
(
)
.
expect
(
"
write
lock
of
submetric
ids
was
poisoned
"
)
;
map
.
insert
(
tuple
submetric_id
)
;
submetric_id
}
}
;
}
