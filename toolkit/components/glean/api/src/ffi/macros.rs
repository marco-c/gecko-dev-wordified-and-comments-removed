macro_rules
!
with_metric
{
(
BOOLEAN_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
BOOLEAN_MAP
id
m
f
)
}
;
(
COUNTER_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
COUNTER_MAP
id
m
f
)
}
;
(
CUSTOM_DISTRIBUTION_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
CUSTOM_DISTRIBUTION_MAP
id
m
f
)
}
;
(
MEMORY_DISTRIBUTION_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
MEMORY_DISTRIBUTION_MAP
id
m
f
)
}
;
(
QUANTITY_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
QUANTITY_MAP
id
m
f
)
}
;
(
STRING_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
STRING_MAP
id
m
f
)
}
;
(
TIMING_DISTRIBUTION_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
maybe_labeled_with_metric
!
(
TIMING_DISTRIBUTION_MAP
id
m
f
)
}
;
(
DUAL_COUNTER_MAP
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
just_labeled_with_metric
!
(
DUAL_COUNTER_MAP
id
m
f
)
}
;
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
just_with_metric
!
(
map
id
m
f
)
}
;
}
macro_rules
!
just_with_jog_metric
{
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
{
let
map
=
crate
:
:
factory
:
:
__jog_metric_maps
:
:
map
.
read
(
)
.
expect
(
"
Read
lock
for
dynamic
metric
map
was
poisoned
"
)
;
match
map
.
get
(
&
id
.
into
(
)
)
{
Some
(
m
)
=
>
f
None
=
>
panic
!
(
"
No
(
dynamic
)
metric
for
id
{
}
"
id
)
}
}
}
;
}
macro_rules
!
just_with_metric
{
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
if
id
&
(
1
<
<
crate
:
:
factory
:
:
DYNAMIC_METRIC_BIT
)
>
0
{
just_with_jog_metric
!
(
map
id
m
f
)
}
else
{
match
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
map
.
get
(
&
id
.
into
(
)
)
{
Some
(
m
)
=
>
f
None
=
>
panic
!
(
"
No
metric
for
id
{
}
"
id
)
}
}
}
;
}
macro_rules
!
maybe_labeled_with_metric
{
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
if
id
&
(
1
<
<
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
SUBMETRIC_BIT
)
>
0
{
just_labeled_with_metric
!
(
map
id
m
f
)
}
else
{
just_with_metric
!
(
map
id
m
f
)
}
}
;
}
macro_rules
!
just_labeled_with_metric
{
(
map
:
ident
id
:
ident
m
:
ident
f
:
expr
)
=
>
{
{
let
map
=
crate
:
:
metrics
:
:
__glean_metric_maps
:
:
submetric_maps
:
:
map
.
read
(
)
.
expect
(
"
Read
lock
for
labeled
metric
map
was
poisoned
"
)
;
match
map
.
get
(
&
id
.
into
(
)
)
{
Some
(
m
)
=
>
f
None
=
>
panic
!
(
"
No
submetric
for
id
{
}
"
id
)
}
}
}
;
}
macro_rules
!
test_has
{
(
metric
:
ident
storage
:
ident
)
=
>
{
{
let
storage
=
if
storage
.
is_empty
(
)
{
None
}
else
{
Some
(
storage
.
to_utf8
(
)
)
}
;
metric
.
test_get_value
(
storage
.
as_deref
(
)
)
.
is_some
(
)
}
}
;
}
macro_rules
!
test_get
{
(
metric
:
ident
storage
:
ident
)
=
>
{
{
let
storage
=
if
storage
.
is_empty
(
)
{
None
}
else
{
Some
(
storage
.
to_utf8
(
)
)
}
;
metric
.
test_get_value
(
storage
.
as_deref
(
)
)
.
unwrap
(
)
}
}
;
}
macro_rules
!
test_get_errors
{
(
metric
:
path
)
=
>
{
{
let
error_types
=
[
glean
:
:
ErrorType
:
:
InvalidValue
glean
:
:
ErrorType
:
:
InvalidLabel
glean
:
:
ErrorType
:
:
InvalidState
glean
:
:
ErrorType
:
:
InvalidOverflow
]
;
let
mut
error_str
=
None
;
for
&
error_type
in
error_types
.
iter
(
)
{
let
num_errors
=
metric
.
test_get_num_recorded_errors
(
error_type
)
;
if
num_errors
>
0
{
error_str
=
Some
(
format
!
(
"
Metric
had
{
}
error
(
s
)
of
type
{
}
!
"
num_errors
error_type
.
as_str
(
)
)
)
;
break
;
}
}
error_str
}
}
;
}
