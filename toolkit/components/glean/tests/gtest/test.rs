use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
sync
:
:
Arc
;
extern
crate
firefox_on_glean
;
use
firefox_on_glean
:
:
{
metrics
pings
}
;
extern
crate
nsstring
;
use
nsstring
:
:
nsString
;
fn
nonfatal_fail
(
msg
:
String
)
{
extern
"
C
"
{
fn
GTest_FOG_ExpectFailure
(
message
:
*
const
:
:
std
:
:
os
:
:
raw
:
:
c_char
)
;
}
unsafe
{
let
msg
=
:
:
std
:
:
ffi
:
:
CString
:
:
new
(
msg
)
.
unwrap
(
)
;
GTest_FOG_ExpectFailure
(
msg
.
as_ptr
(
)
)
;
}
}
macro_rules
!
expect
{
(
x
:
expr
)
=
>
{
match
(
&
x
)
{
true
=
>
{
}
false
=
>
nonfatal_fail
(
format
!
(
"
check
failed
:
(
{
}
)
at
{
}
:
{
}
"
stringify
!
(
x
)
file
!
(
)
line
!
(
)
)
)
}
}
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
Rust_TestRustInGTest
(
)
{
metrics
:
:
test_only
:
:
bad_code
.
add
(
12
)
;
expect
!
(
metrics
:
:
test_only
:
:
bad_code
.
test_get_value
(
None
)
=
=
Some
(
12
)
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
Rust_TestJogfile
(
)
{
expect
!
(
jog
:
:
jog_load_jogfile
(
&
nsString
:
:
from
(
"
jogfile_output
"
)
)
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
Rust_TestRideAlongPing
(
)
{
let
test_submitted
=
Arc
:
:
new
(
AtomicBool
:
:
new
(
false
)
)
;
let
ride_along_submitted
=
Arc
:
:
new
(
AtomicBool
:
:
new
(
false
)
)
;
{
let
test_submitted
=
Arc
:
:
clone
(
&
test_submitted
)
;
pings
:
:
test_ping
.
test_before_next_submit
(
move
|
_reason
|
{
test_submitted
.
store
(
true
Ordering
:
:
Release
)
;
}
)
;
}
{
let
ride_along_submitted
=
Arc
:
:
clone
(
&
ride_along_submitted
)
;
pings
:
:
ride_along_ping
.
test_before_next_submit
(
move
|
_reason
|
{
ride_along_submitted
.
store
(
true
Ordering
:
:
Release
)
;
}
)
;
}
pings
:
:
test_ping
.
submit
(
None
)
;
expect
!
(
test_submitted
.
load
(
Ordering
:
:
Acquire
)
)
;
expect
!
(
ride_along_submitted
.
load
(
Ordering
:
:
Acquire
)
)
;
}
