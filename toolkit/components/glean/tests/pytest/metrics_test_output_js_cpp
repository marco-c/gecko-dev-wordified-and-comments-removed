#
include
"
mozilla
/
glean
/
bindings
/
GleanJSMetricsLookup
.
h
"
#
include
"
mozilla
/
PerfectHash
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
glean
/
bindings
/
MetricTypes
.
h
"
#
include
"
mozilla
/
glean
/
fog_ffi_generated
.
h
"
#
include
"
nsString
.
h
"
#
define
GLEAN_INDEX_BITS
(
32
)
#
define
GLEAN_TYPE_BITS
(
5
)
#
define
GLEAN_ID_BITS
(
27
)
#
define
GLEAN_TYPE_ID
(
id
)
(
(
id
)
>
>
GLEAN_ID_BITS
)
#
define
GLEAN_METRIC_ID
(
id
)
(
(
id
)
&
(
(
1ULL
<
<
GLEAN_ID_BITS
)
-
1
)
)
#
define
GLEAN_OFFSET
(
entry
)
(
entry
&
(
(
1ULL
<
<
GLEAN_INDEX_BITS
)
-
1
)
)
namespace
mozilla
:
:
glean
{
using
category_entry_t
=
uint32_t
;
using
metric_entry_t
=
uint64_t
;
static_assert
(
GLEAN_INDEX_BITS
+
GLEAN_TYPE_BITS
+
GLEAN_ID_BITS
=
=
sizeof
(
metric_entry_t
)
*
8
"
Index
Type
and
ID
bits
need
to
fit
into
a
metric_entry_t
"
)
;
static_assert
(
GLEAN_TYPE_BITS
+
GLEAN_ID_BITS
<
=
sizeof
(
uint32_t
)
*
8
"
Metric
Types
and
IDs
need
to
fit
into
at
most
32
bits
"
)
;
static_assert
(
2
<
UINT32_MAX
"
Too
many
metric
categories
generated
.
"
)
;
static_assert
(
25
<
33554432
"
Too
many
metrics
generated
.
Need
room
for
2
signal
bits
.
"
)
;
static_assert
(
20
<
32
"
Too
many
different
metric
types
.
"
)
;
already_AddRefed
<
GleanMetric
>
NewMetricFromId
(
uint32_t
id
nsISupports
*
aParent
)
{
uint32_t
typeId
=
GLEAN_TYPE_ID
(
id
)
;
uint32_t
metricId
=
GLEAN_METRIC_ID
(
id
)
;
switch
(
typeId
)
{
case
1
:
{
return
MakeAndAddRef
<
GleanBoolean
>
(
metricId
aParent
)
;
}
case
2
:
{
return
MakeAndAddRef
<
GleanCounter
>
(
metricId
aParent
)
;
}
case
3
:
{
return
MakeAndAddRef
<
GleanCustomDistribution
>
(
metricId
aParent
)
;
}
case
4
:
{
return
MakeAndAddRef
<
GleanLabeled
>
(
metricId
4
aParent
)
;
}
case
5
:
{
return
MakeAndAddRef
<
GleanLabeled
>
(
metricId
5
aParent
)
;
}
case
6
:
{
return
MakeAndAddRef
<
GleanLabeled
>
(
metricId
6
aParent
)
;
}
case
7
:
{
return
MakeAndAddRef
<
GleanMemoryDistribution
>
(
metricId
aParent
)
;
}
case
8
:
{
return
MakeAndAddRef
<
GleanStringList
>
(
metricId
aParent
)
;
}
case
9
:
{
return
MakeAndAddRef
<
GleanString
>
(
metricId
aParent
)
;
}
case
10
:
{
return
MakeAndAddRef
<
GleanText
>
(
metricId
aParent
)
;
}
case
11
:
{
return
MakeAndAddRef
<
GleanTimespan
>
(
metricId
aParent
)
;
}
case
12
:
{
return
MakeAndAddRef
<
GleanTimingDistribution
>
(
metricId
aParent
)
;
}
case
13
:
{
return
MakeAndAddRef
<
GleanObject
>
(
metricId
aParent
)
;
}
case
14
:
{
return
MakeAndAddRef
<
GleanDatetime
>
(
metricId
aParent
)
;
}
case
15
:
{
return
MakeAndAddRef
<
GleanEvent
>
(
metricId
aParent
)
;
}
case
16
:
{
return
MakeAndAddRef
<
GleanDenominator
>
(
metricId
aParent
)
;
}
case
17
:
{
return
MakeAndAddRef
<
GleanQuantity
>
(
metricId
aParent
)
;
}
case
18
:
{
return
MakeAndAddRef
<
GleanRate
>
(
metricId
aParent
)
;
}
case
19
:
{
return
MakeAndAddRef
<
GleanNumerator
>
(
metricId
aParent
)
;
}
case
20
:
{
return
MakeAndAddRef
<
GleanUuid
>
(
metricId
aParent
)
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
type
ID
reached
when
trying
to
instantiate
a
new
metric
"
)
;
return
nullptr
;
}
}
already_AddRefed
<
GleanMetric
>
NewSubMetricFromIds
(
uint32_t
aParentTypeId
uint32_t
aParentMetricId
const
nsACString
&
aLabel
uint32_t
*
aSubmetricId
nsISupports
*
aParent
)
{
switch
(
aParentTypeId
)
{
case
4
:
{
auto
id
=
impl
:
:
fog_labeled_boolean_get
(
aParentMetricId
&
aLabel
)
;
*
aSubmetricId
=
id
;
return
MakeAndAddRef
<
GleanBoolean
>
(
id
aParent
)
;
}
case
5
:
{
auto
id
=
impl
:
:
fog_labeled_counter_get
(
aParentMetricId
&
aLabel
)
;
*
aSubmetricId
=
id
;
return
MakeAndAddRef
<
GleanCounter
>
(
id
aParent
)
;
}
case
6
:
{
auto
id
=
impl
:
:
fog_labeled_string_get
(
aParentMetricId
&
aLabel
)
;
*
aSubmetricId
=
id
;
return
MakeAndAddRef
<
GleanString
>
(
id
aParent
)
;
}
default
:
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
type
ID
for
submetric
.
"
)
;
return
nullptr
;
}
}
}
static
Maybe
<
uint32_t
>
category_result_check
(
const
nsACString
&
aKey
category_entry_t
entry
)
;
static
Maybe
<
uint32_t
>
metric_result_check
(
const
nsACString
&
aKey
metric_entry_t
entry
)
;
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
const
char
gCategoryStringTable
[
]
=
{
#
else
constexpr
char
gCategoryStringTable
[
]
=
{
#
endif
'
t
'
'
e
'
'
s
'
'
t
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
\
0
'
}
;
static_assert
(
sizeof
(
gCategoryStringTable
)
<
UINT32_MAX
"
Category
string
table
is
too
large
.
"
)
;
const
category_entry_t
sCategoryByNameLookupEntries
[
]
=
{
5ul
0ul
}
;
Maybe
<
uint32_t
>
CategoryByNameLookup
(
const
nsACString
&
aKey
)
{
static
const
uint8_t
BASES
[
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
const
char
*
bytes
=
aKey
.
BeginReading
(
)
;
size_t
length
=
aKey
.
Length
(
)
;
auto
&
entry
=
mozilla
:
:
perfecthash
:
:
Lookup
(
bytes
length
BASES
sCategoryByNameLookupEntries
)
;
return
category_result_check
(
aKey
entry
)
;
}
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
const
char
gMetricStringTable
[
]
=
{
#
else
constexpr
char
gMetricStringTable
[
]
=
{
#
endif
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
b
'
'
o
'
'
o
'
'
l
'
'
e
'
'
a
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
c
'
'
o
'
'
u
'
'
n
'
'
t
'
'
e
'
'
r
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
c
'
'
u
'
'
s
'
'
t
'
'
o
'
'
m
'
'
D
'
'
i
'
'
s
'
'
t
'
'
r
'
'
i
'
'
b
'
'
u
'
'
t
'
'
i
'
'
o
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
B
'
'
o
'
'
o
'
'
l
'
'
e
'
'
a
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
B
'
'
o
'
'
o
'
'
l
'
'
e
'
'
a
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
L
'
'
a
'
'
b
'
'
e
'
'
l
'
'
s
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
C
'
'
o
'
'
u
'
'
n
'
'
t
'
'
e
'
'
r
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
C
'
'
o
'
'
u
'
'
n
'
'
t
'
'
e
'
'
r
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
L
'
'
a
'
'
b
'
'
e
'
'
l
'
'
s
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
S
'
'
t
'
'
r
'
'
i
'
'
n
'
'
g
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
S
'
'
t
'
'
r
'
'
i
'
'
n
'
'
g
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
L
'
'
a
'
'
b
'
'
e
'
'
l
'
'
s
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
m
'
'
e
'
'
m
'
'
o
'
'
r
'
'
y
'
'
D
'
'
i
'
'
s
'
'
t
'
'
r
'
'
i
'
'
b
'
'
u
'
'
t
'
'
i
'
'
o
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
s
'
'
t
'
'
r
'
'
i
'
'
n
'
'
g
'
'
L
'
'
i
'
'
s
'
'
t
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
s
'
'
t
'
'
r
'
'
i
'
'
n
'
'
g
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
t
'
'
e
'
'
x
'
'
t
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
t
'
'
i
'
'
m
'
'
e
'
'
s
'
'
p
'
'
a
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
t
'
'
i
'
'
m
'
'
i
'
'
n
'
'
g
'
'
D
'
'
i
'
'
s
'
'
t
'
'
r
'
'
i
'
'
b
'
'
u
'
'
t
'
'
i
'
'
o
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
a
'
'
n
'
'
O
'
'
b
'
'
j
'
'
e
'
'
c
'
'
t
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
d
'
'
a
'
'
t
'
'
e
'
'
t
'
'
i
'
'
m
'
'
e
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
e
'
'
v
'
'
e
'
'
n
'
'
t
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
e
'
'
v
'
'
e
'
'
n
'
'
t
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
W
'
'
i
'
'
t
'
'
h
'
'
E
'
'
x
'
'
t
'
'
r
'
'
a
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
e
'
'
x
'
'
t
'
'
e
'
'
r
'
'
n
'
'
a
'
'
l
'
'
D
'
'
e
'
'
n
'
'
o
'
'
m
'
'
i
'
'
n
'
'
a
'
'
t
'
'
o
'
'
r
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
o
'
'
p
'
'
t
'
'
i
'
'
m
'
'
i
'
'
z
'
'
a
'
'
b
'
'
l
'
'
e
'
'
C
'
'
o
'
'
u
'
'
n
'
'
t
'
'
e
'
'
r
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
q
'
'
u
'
'
a
'
'
n
'
'
t
'
'
i
'
'
t
'
'
y
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
r
'
'
a
'
'
t
'
'
e
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
r
'
'
a
'
'
t
'
'
e
'
'
W
'
'
i
'
'
t
'
'
h
'
'
E
'
'
x
'
'
t
'
'
e
'
'
r
'
'
n
'
'
a
'
'
l
'
'
D
'
'
e
'
'
n
'
'
o
'
'
m
'
'
i
'
'
n
'
'
a
'
'
t
'
'
o
'
'
r
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
u
'
'
u
'
'
i
'
'
d
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
}
;
static_assert
(
sizeof
(
gMetricStringTable
)
<
4294967296
"
Metric
string
table
is
too
large
.
"
)
;
const
metric_entry_t
sMetricByNameLookupEntries
[
]
=
{
5764607578868810038ull
1152921513196781587ull
1729382269795172390ull
3458764552475246801ull
10952754396844261968ull
4611686065672028430ull
2305843026393563204ull
1152921594801160700ull
5188146822270419236ull
3458764548180279480ull
8646911361860764070ull
8646911366155731389ull
8070450605262373260ull
9799832883647480352ull
11529215153442652791ull
2305843030688530526ull
6917529092065591642ull
9223372122754122205ull
10376293640245871162ull
4035225309073637616ull
2882303787286921342ull
576460756598390784ull
7493989848663982456ull
2882303791581888664ull
6341068335467200838ull
}
;
Maybe
<
uint32_t
>
MetricByNameLookup
(
const
nsACString
&
aKey
)
{
static
const
uint8_t
BASES
[
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
4
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
2
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
4
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
3
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
3
0
0
0
0
0
0
1
0
3
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
2
0
2
0
0
0
0
0
0
0
2
0
0
0
6
0
0
51
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
const
char
*
bytes
=
aKey
.
BeginReading
(
)
;
size_t
length
=
aKey
.
Length
(
)
;
auto
&
entry
=
mozilla
:
:
perfecthash
:
:
Lookup
(
bytes
length
BASES
sMetricByNameLookupEntries
)
;
return
metric_result_check
(
aKey
entry
)
;
}
const
char
*
GetCategoryName
(
category_entry_t
entry
)
{
MOZ_ASSERT
(
entry
<
sizeof
(
gCategoryStringTable
)
"
Entry
identifier
offset
larger
than
string
table
"
)
;
return
&
gCategoryStringTable
[
entry
]
;
}
const
char
*
GetMetricIdentifier
(
metric_entry_t
entry
)
{
uint32_t
offset
=
GLEAN_OFFSET
(
entry
)
;
MOZ_ASSERT
(
offset
<
sizeof
(
gMetricStringTable
)
"
Entry
identifier
offset
larger
than
string
table
"
)
;
return
&
gMetricStringTable
[
offset
]
;
}
extern
"
C
"
const
char
*
FOG_GetMetricIdentifier
(
uint32_t
metric_id
)
{
for
(
metric_entry_t
entry
:
sMetricByNameLookupEntries
)
{
if
(
static_cast
<
uint32_t
>
(
GLEAN_METRIC_ID
(
entry
>
>
GLEAN_INDEX_BITS
)
)
=
=
metric_id
)
{
return
GetMetricIdentifier
(
entry
)
;
}
}
return
nullptr
;
}
static
Maybe
<
uint32_t
>
category_result_check
(
const
nsACString
&
aKey
category_entry_t
entry
)
{
if
(
MOZ_UNLIKELY
(
entry
>
sizeof
(
gCategoryStringTable
)
)
)
{
return
Nothing
(
)
;
}
if
(
aKey
.
EqualsASCII
(
gCategoryStringTable
+
entry
)
)
{
return
Some
(
entry
)
;
}
return
Nothing
(
)
;
}
static
Maybe
<
uint32_t
>
metric_result_check
(
const
nsACString
&
aKey
uint64_t
entry
)
{
uint32_t
metricId
=
entry
>
>
GLEAN_INDEX_BITS
;
uint32_t
offset
=
GLEAN_OFFSET
(
entry
)
;
if
(
offset
>
sizeof
(
gMetricStringTable
)
)
{
return
Nothing
(
)
;
}
if
(
aKey
.
EqualsASCII
(
gMetricStringTable
+
offset
)
)
{
return
Some
(
metricId
)
;
}
return
Nothing
(
)
;
}
#
undef
GLEAN_INDEX_BITS
#
undef
GLEAN_ID_BITS
#
undef
GLEAN_TYPE_ID
#
undef
GLEAN_METRIC_ID
#
undef
GLEAN_OFFSET
}
