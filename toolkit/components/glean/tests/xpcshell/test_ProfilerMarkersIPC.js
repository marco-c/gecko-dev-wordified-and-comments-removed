"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
ObjectUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
sys
.
mjs
"
)
;
const
{
ProfilerTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ProfilerTestUtils
.
sys
.
mjs
"
)
;
add_setup
(
{
skip_if
:
(
)
=
>
!
runningInParent
|
|
AppConstants
.
platform
=
=
"
android
"
}
function
test_setup
(
)
{
do_get_profile
(
)
;
Services
.
fog
.
initializeFOG
(
)
;
}
)
;
const
METRICS
=
[
[
"
labeled_counter
"
"
jog_ipc
"
"
jog_labeled_counter
"
[
"
test
-
ping
"
]
"
ping
"
false
]
]
;
async
function
runWithProfilerAndGetMarkers
(
type
func
)
{
await
ProfilerTestUtils
.
startProfiler
(
{
entries
:
10000
interval
:
10
features
:
[
"
nostacksampling
"
]
threads
:
[
"
GeckoMain
"
]
}
)
;
Assert
.
ok
(
Services
.
profiler
.
IsActive
(
)
)
;
await
func
(
)
;
let
profile
=
await
ProfilerTestUtils
.
stopNowAndGetProfile
(
)
;
Assert
.
equal
(
profile
.
threads
.
length
1
"
We
should
only
be
profiling
one
thread
"
)
;
let
markers
=
ProfilerTestUtils
.
getPayloadsOfType
(
profile
.
threads
[
0
]
type
)
;
let
stringTable
=
profile
.
threads
[
0
]
.
stringTable
;
for
(
let
marker
of
markers
)
{
marker
.
id
=
stringTable
[
marker
.
id
]
;
if
(
marker
.
cat
!
=
undefined
)
{
marker
.
cat
=
stringTable
[
marker
.
cat
]
;
}
if
(
marker
.
label
!
=
undefined
)
{
marker
.
label
=
stringTable
[
marker
.
label
]
;
}
}
markers
=
markers
.
filter
(
marker
=
>
{
let
name
=
marker
.
id
.
startsWith
(
"
testOnly
"
)
|
|
marker
.
id
.
startsWith
(
"
test_only
"
)
|
|
marker
.
id
.
startsWith
(
"
jog_
"
)
;
let
cat
=
false
;
if
(
marker
.
cat
!
=
undefined
)
{
cat
=
marker
.
cat
.
startsWith
(
"
test
"
)
|
|
marker
.
cat
.
startsWith
(
"
jog_
"
)
;
}
let
ping
=
[
"
test
-
ping
"
"
one
-
ping
-
only
"
"
ride
-
along
-
ping
"
]
.
includes
(
marker
.
id
)
;
let
error
=
marker
.
id
.
startsWith
(
"
JOG
"
)
;
return
name
|
|
cat
|
|
ping
|
|
error
;
}
)
;
return
markers
;
}
add_task
(
{
skip_if
:
(
)
=
>
runningInParent
}
async
function
run_child_stuff
(
)
{
Glean
.
testOnly
.
badCode
;
for
(
let
metric
of
METRICS
)
{
Services
.
fog
.
testRegisterRuntimeMetric
(
.
.
.
metric
)
;
}
let
markers
=
await
runWithProfilerAndGetMarkers
(
"
IntLikeMetric
"
(
)
=
>
{
Glean
.
jogIpc
.
jogLabeledCounter
.
label1
.
add
(
1
)
;
Glean
.
jogIpc
.
jogLabeledCounter
.
label1
.
add
(
2
)
;
}
)
;
const
lookupFailedMarkers
=
[
{
type
:
"
IntLikeMetric
"
cat
:
"
"
id
:
"
JOGMetricMapLookupFailed
"
label
:
"
label1
"
val
:
1
}
{
type
:
"
IntLikeMetric
"
cat
:
"
"
id
:
"
JOGMetricMapLookupFailed
"
label
:
"
label1
"
val
:
2
}
]
;
const
mapUninitMarkers
=
[
{
type
:
"
IntLikeMetric
"
cat
:
"
"
id
:
"
JOGMetricMapWasUninit
"
label
:
"
label1
"
val
:
1
}
{
type
:
"
IntLikeMetric
"
cat
:
"
"
id
:
"
JOGMetricMapWasUninit
"
label
:
"
label1
"
val
:
2
}
]
;
Assert
.
ok
(
ObjectUtils
.
deepEqual
(
markers
lookupFailedMarkers
)
|
|
ObjectUtils
.
deepEqual
(
markers
mapUninitMarkers
)
"
Error
markers
present
.
"
)
;
}
)
;
add_task
(
{
skip_if
:
(
)
=
>
!
runningInParent
}
async
function
test_child_markers
(
)
{
await
run_test_in_child
(
"
test_ProfilerMarkersIPC
.
js
"
)
;
}
)
;
