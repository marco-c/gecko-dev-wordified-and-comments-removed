#
!
[
allow
(
dead_code
)
]
use
glean
:
:
ping_upload
:
:
{
self
UploadResult
}
;
use
glean_core
:
:
{
global_glean
setup_glean
Configuration
Glean
Result
}
;
use
once_cell
:
:
sync
:
:
OnceCell
;
use
url
:
:
Url
;
use
viaduct
:
:
Request
;
use
crate
:
:
client_info
:
:
ClientInfo
;
use
crate
:
:
core_metrics
:
:
InternalMetrics
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
AppState
{
client_info
:
ClientInfo
}
static
STATE
:
OnceCell
<
AppState
>
=
OnceCell
:
:
new
(
)
;
fn
global_state
(
)
-
>
&
'
static
AppState
{
STATE
.
get
(
)
.
unwrap
(
)
}
fn
with_glean_mut
<
F
R
>
(
f
:
F
)
-
>
R
where
F
:
Fn
(
&
mut
Glean
)
-
>
R
{
let
mut
glean
=
global_glean
(
)
.
expect
(
"
Global
Glean
not
initialized
"
)
.
lock
(
)
.
unwrap
(
)
;
f
(
&
mut
glean
)
}
pub
fn
initialize
(
cfg
:
Configuration
client_info
:
ClientInfo
)
-
>
Result
<
(
)
>
{
STATE
.
get_or_try_init
(
|
|
{
let
glean
=
Glean
:
:
new
(
cfg
)
?
;
initialize_core_metrics
(
&
glean
&
client_info
)
;
setup_glean
(
glean
)
?
;
register_uploader
(
)
;
Ok
(
AppState
{
client_info
}
)
}
)
.
map
(
|
_
|
(
)
)
}
fn
initialize_core_metrics
(
glean
:
&
Glean
client_info
:
&
ClientInfo
)
{
let
core_metrics
=
InternalMetrics
:
:
new
(
)
;
core_metrics
.
app_build
.
set
(
glean
&
client_info
.
app_build
[
.
.
]
)
;
core_metrics
.
app_display_version
.
set
(
glean
&
client_info
.
app_display_version
[
.
.
]
)
;
if
let
Some
(
app_channel
)
=
&
client_info
.
channel
{
core_metrics
.
app_channel
.
set
(
glean
app_channel
)
;
}
core_metrics
.
os
.
set
(
glean
"
unknown
"
.
to_string
(
)
)
;
core_metrics
.
os_version
.
set
(
glean
&
client_info
.
os_version
[
.
.
]
)
;
core_metrics
.
architecture
.
set
(
glean
&
client_info
.
architecture
)
;
core_metrics
.
device_manufacturer
.
set
(
glean
"
unknown
"
.
to_string
(
)
)
;
core_metrics
.
device_model
.
set
(
glean
"
unknown
"
.
to_string
(
)
)
;
}
pub
fn
set_upload_enabled
(
enabled
:
bool
)
-
>
bool
{
with_glean_mut
(
|
glean
|
{
let
state
=
global_state
(
)
;
let
old_enabled
=
glean
.
is_upload_enabled
(
)
;
glean
.
set_upload_enabled
(
enabled
)
;
if
!
old_enabled
&
&
enabled
{
initialize_core_metrics
(
&
glean
&
state
.
client_info
)
;
}
enabled
}
)
}
fn
register_uploader
(
)
{
let
result
=
ping_upload
:
:
register_uploader
(
Box
:
:
new
(
|
ping_request
|
{
log
:
:
trace
!
(
"
FOG
Ping
Uploader
uploading
ping
{
}
"
ping_request
.
document_id
)
;
let
result
:
std
:
:
result
:
:
Result
<
UploadResult
viaduct
:
:
Error
>
=
(
move
|
|
{
const
SERVER
:
&
str
=
"
https
:
/
/
incoming
.
telemetry
.
mozilla
.
org
"
;
let
url
=
Url
:
:
parse
(
SERVER
)
?
.
join
(
&
ping_request
.
path
)
?
;
let
mut
req
=
Request
:
:
post
(
url
)
.
body
(
ping_request
.
body
.
clone
(
)
)
;
for
(
&
header_key
header_value
)
in
ping_request
.
headers
.
iter
(
)
{
req
=
req
.
header
(
header_key
header_value
)
?
;
}
log
:
:
trace
!
(
"
FOG
Ping
Uploader
sending
ping
{
}
"
ping_request
.
document_id
)
;
let
res
=
req
.
send
(
)
?
;
Ok
(
UploadResult
:
:
HttpStatus
(
res
.
status
.
into
(
)
)
)
}
)
(
)
;
log
:
:
trace
!
(
"
FOG
Ping
Uploader
completed
uploading
ping
{
}
(
Result
{
:
?
}
)
"
ping_request
.
document_id
result
)
;
match
result
{
Ok
(
result
)
=
>
result
_
=
>
UploadResult
:
:
UnrecoverableFailure
}
}
)
)
;
if
result
.
is_err
(
)
{
log
:
:
warn
!
(
"
Couldn
'
t
register
uploader
because
one
'
s
already
in
there
.
{
:
?
}
"
result
)
;
}
}
