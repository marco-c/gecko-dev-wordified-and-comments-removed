use
std
:
:
ffi
:
:
{
c_char
CStr
CString
}
;
use
std
:
:
ops
:
:
DerefMut
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
time
:
:
{
Duration
UNIX_EPOCH
}
;
use
std
:
:
{
env
fs
}
;
use
firefox_on_glean
:
:
{
metrics
pings
}
;
use
nserror
:
:
{
nsresult
NS_ERROR_FAILURE
}
;
use
nsstring
:
:
{
nsACString
nsCString
nsString
}
;
use
xpcom
:
:
interfaces
:
:
{
mozILocaleService
nsIFile
nsIPrefService
nsIProperties
nsIXULAppInfo
nsIXULRuntime
}
;
use
xpcom
:
:
{
RefPtr
XpCom
}
;
use
glean
:
:
{
ClientInfoMetrics
Configuration
}
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
mod
upload_pref
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
mod
user_activity
;
mod
viaduct_uploader
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
use
upload_pref
:
:
UploadPrefObserver
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
use
user_activity
:
:
UserActivityObserver
;
use
viaduct_uploader
:
:
ViaductUploader
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
#
[
no_mangle
]
pub
extern
"
C
"
fn
fog_init
(
data_path_override
:
&
nsACString
app_id_override
:
&
nsACString
disable_internal_pings
:
bool
)
-
>
nsresult
{
let
upload_enabled
=
static_prefs
:
:
pref
!
(
"
datareporting
.
healthreport
.
uploadEnabled
"
)
;
let
recording_enabled
=
static_prefs
:
:
pref
!
(
"
telemetry
.
fog
.
test
.
localhost_port
"
)
<
0
;
let
uploader
=
Some
(
Box
:
:
new
(
ViaductUploader
)
as
Box
<
dyn
glean
:
:
net
:
:
PingUploader
>
)
;
fog_init_internal
(
data_path_override
app_id_override
upload_enabled
|
|
recording_enabled
uploader
!
disable_internal_pings
)
.
into
(
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
#
[
no_mangle
]
pub
extern
"
C
"
fn
fog_init
(
data_path_override
:
&
nsACString
app_id_override
:
&
nsACString
disable_internal_pings
:
bool
)
-
>
nsresult
{
let
upload_enabled
=
true
;
let
uploader
=
None
;
fog_init_internal
(
data_path_override
app_id_override
upload_enabled
uploader
!
disable_internal_pings
)
.
into
(
)
}
fn
fog_init_internal
(
data_path_override
:
&
nsACString
app_id_override
:
&
nsACString
upload_enabled
:
bool
uploader
:
Option
<
Box
<
dyn
glean
:
:
net
:
:
PingUploader
>
>
enable_internal_pings
:
bool
)
-
>
Result
<
(
)
nsresult
>
{
let
timer_id
=
metrics
:
:
fog
:
:
initializations
.
start
(
)
;
log
:
:
debug
!
(
"
Initializing
FOG
.
"
)
;
setup_observers
(
)
?
;
let
(
mut
conf
client_info
)
=
build_configuration
(
data_path_override
app_id_override
)
?
;
conf
.
upload_enabled
=
upload_enabled
;
conf
.
uploader
=
uploader
;
conf
.
enable_internal_pings
=
enable_internal_pings
;
if
env
:
:
var
(
"
MOZ_AUTOMATION
"
)
.
is_ok
(
)
&
&
env
:
:
var
(
"
GLEAN_SOURCE_TAGS
"
)
.
is_err
(
)
{
log
:
:
info
!
(
"
In
automation
setting
'
automation
'
source
tag
.
"
)
;
glean
:
:
set_source_tags
(
vec
!
[
"
automation
"
.
to_string
(
)
]
)
;
log
:
:
info
!
(
"
In
automation
disabling
MPS
to
avoid
4am
issues
.
"
)
;
conf
.
use_core_mps
=
false
;
}
log
:
:
debug
!
(
"
Configuration
:
{
:
#
?
}
"
conf
)
;
pings
:
:
register_pings
(
Some
(
&
conf
.
application_id
)
)
;
if
mozbuild
:
:
config
:
:
NIGHTLY_BUILD
{
log
:
:
debug
!
(
"
Collecting
FOG
data
directory
information
.
"
)
;
collect_directory_info
(
&
conf
.
data_path
)
;
}
glean
:
:
initialize
(
conf
client_info
)
;
metrics
:
:
fog
:
:
initializations
.
stop_and_accumulate
(
timer_id
)
;
Ok
(
(
)
)
}
fn
build_configuration
(
data_path_override
:
&
nsACString
app_id_override
:
&
nsACString
)
-
>
Result
<
(
Configuration
ClientInfoMetrics
)
nsresult
>
{
let
data_path_str
=
if
data_path_override
.
is_empty
(
)
{
get_data_path
(
)
?
}
else
{
data_path_override
.
to_utf8
(
)
.
to_string
(
)
}
;
let
data_path
=
PathBuf
:
:
from
(
&
data_path_str
)
;
let
(
app_build
app_display_version
channel
locale
)
=
get_app_info
(
)
?
;
let
client_info
=
ClientInfoMetrics
{
app_build
app_display_version
channel
:
Some
(
channel
)
locale
:
Some
(
locale
)
}
;
log
:
:
debug
!
(
"
Client
Info
:
{
:
#
?
}
"
client_info
)
;
let
localhost_port
=
static_prefs
:
:
pref
!
(
"
telemetry
.
fog
.
test
.
localhost_port
"
)
;
let
server
=
if
localhost_port
>
0
{
format
!
(
"
http
:
/
/
localhost
:
{
}
"
localhost_port
)
}
else
{
if
app_id_override
=
=
"
thunderbird
.
desktop
"
{
String
:
:
from
(
"
https
:
/
/
incoming
.
thunderbird
.
net
"
)
}
else
{
String
:
:
from
(
"
https
:
/
/
incoming
.
telemetry
.
mozilla
.
org
"
)
}
}
;
let
application_id
=
if
app_id_override
.
is_empty
(
)
{
"
firefox
.
desktop
"
.
to_string
(
)
}
else
{
app_id_override
.
to_utf8
(
)
.
to_string
(
)
}
;
extern
"
C
"
{
fn
FOG_MaxPingLimit
(
)
-
>
u32
;
}
let
pings_per_interval
=
unsafe
{
FOG_MaxPingLimit
(
)
}
;
metrics
:
:
fog
:
:
max_pings_per_minute
.
set
(
pings_per_interval
.
into
(
)
)
;
let
rate_limit
=
Some
(
glean
:
:
PingRateLimit
{
seconds_per_interval
:
60
pings_per_interval
}
)
;
let
configuration
=
Configuration
{
upload_enabled
:
false
data_path
application_id
max_events
:
None
delay_ping_lifetime_io
:
true
server_endpoint
:
Some
(
server
)
uploader
:
None
use_core_mps
:
true
trim_data_to_registered_pings
:
true
log_level
:
None
rate_limit
enable_event_timestamps
:
true
experimentation_id
:
None
enable_internal_pings
:
true
ping_schedule
:
pings
:
:
ping_schedule
(
)
ping_lifetime_threshold
:
0
ping_lifetime_max_time
:
Duration
:
:
ZERO
}
;
Ok
(
(
configuration
client_info
)
)
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
setup_observers
(
)
-
>
Result
<
(
)
nsresult
>
{
if
let
Err
(
e
)
=
UploadPrefObserver
:
:
begin_observing
(
)
{
log
:
:
error
!
(
"
Could
not
observe
data
upload
pref
.
Abandoning
FOG
init
due
to
{
:
?
}
"
e
)
;
return
Err
(
e
)
;
}
if
let
Err
(
e
)
=
UserActivityObserver
:
:
begin_observing
(
)
{
log
:
:
error
!
(
"
Could
not
observe
user
activity
.
Abandoning
FOG
init
due
to
{
:
?
}
"
e
)
;
return
Err
(
e
)
;
}
Ok
(
(
)
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
setup_observers
(
)
-
>
Result
<
(
)
nsresult
>
{
Ok
(
(
)
)
}
fn
get_data_path
(
)
-
>
Result
<
String
nsresult
>
{
let
dir_svc
:
RefPtr
<
nsIProperties
>
=
match
xpcom
:
:
components
:
:
Directory
:
:
service
(
)
{
Ok
(
ds
)
=
>
ds
_
=
>
return
Err
(
NS_ERROR_FAILURE
)
}
;
let
mut
profile_dir
=
xpcom
:
:
GetterAddrefs
:
:
<
nsIFile
>
:
:
new
(
)
;
unsafe
{
dir_svc
.
Get
(
cstr
!
(
"
ProfD
"
)
.
as_ptr
(
)
&
nsIFile
:
:
IID
profile_dir
.
void_ptr
(
)
)
.
to_result
(
)
?
;
}
let
profile_dir
=
profile_dir
.
refptr
(
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
let
mut
profile_path
=
nsString
:
:
new
(
)
;
unsafe
{
(
*
profile_dir
)
.
GetPath
(
&
mut
*
profile_path
)
.
to_result
(
)
?
;
}
let
profile_path
=
String
:
:
from_utf16
(
&
profile_path
[
.
.
]
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
let
data_path
=
profile_path
+
"
/
datareporting
/
glean
"
;
Ok
(
data_path
)
}
fn
get_app_info
(
)
-
>
Result
<
(
String
String
String
String
)
nsresult
>
{
let
xul
:
RefPtr
<
nsIXULRuntime
>
=
xpcom
:
:
components
:
:
XULRuntime
:
:
service
(
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
let
pref_service
:
RefPtr
<
nsIPrefService
>
=
xpcom
:
:
components
:
:
Preferences
:
:
service
(
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
let
locale_service
:
RefPtr
<
mozILocaleService
>
=
xpcom
:
:
components
:
:
Locale
:
:
service
(
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
let
branch
=
xpcom
:
:
getter_addrefs
(
|
p
|
{
unsafe
{
pref_service
.
GetDefaultBranch
(
std
:
:
ptr
:
:
null
(
)
p
)
}
}
)
?
;
let
pref_name
=
CString
:
:
new
(
"
app
.
update
.
channel
"
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
let
mut
channel
=
nsCString
:
:
new
(
)
;
unsafe
{
if
(
*
branch
)
.
GetCharPref
(
pref_name
.
as_ptr
(
)
channel
.
deref_mut
(
)
as
*
mut
nsACString
)
.
to_result
(
)
.
is_err
(
)
{
channel
=
"
unknown
"
.
into
(
)
;
}
}
extern
"
C
"
{
fn
FOG_MozAppVersionDisplay
(
)
-
>
*
const
c_char
;
}
let
version
=
unsafe
{
CStr
:
:
from_ptr
(
FOG_MozAppVersionDisplay
(
)
)
}
.
to_str
(
)
.
map_err
(
|
_
|
NS_ERROR_FAILURE
)
?
;
let
app_info
=
match
xul
.
query_interface
:
:
<
nsIXULAppInfo
>
(
)
{
Some
(
ai
)
=
>
ai
_
=
>
{
return
Ok
(
(
"
unknown
"
.
to_owned
(
)
version
.
to_string
(
)
channel
.
to_string
(
)
"
unknown
"
.
to_owned
(
)
)
)
}
}
;
let
mut
build_id
=
nsCString
:
:
new
(
)
;
unsafe
{
app_info
.
GetAppBuildID
(
&
mut
*
build_id
)
.
to_result
(
)
?
;
}
let
mut
locale
=
nsCString
:
:
new
(
)
;
unsafe
{
locale_service
.
GetAppLocaleAsBCP47
(
&
mut
*
locale
)
.
to_result
(
)
?
;
}
Ok
(
(
build_id
.
to_string
(
)
version
.
to_string
(
)
channel
.
to_string
(
)
locale
.
to_string
(
)
)
)
}
fn
collect_directory_info
(
path
:
&
PathBuf
)
{
let
subdirs
=
[
"
db
"
"
events
"
"
pending_pings
"
]
;
let
mut
directories_info
=
metrics
:
:
fog
:
:
DataDirectoryInfoObject
:
:
new
(
)
;
for
subdir
in
subdirs
.
iter
(
)
{
let
dir_path
=
path
.
join
(
subdir
)
;
let
mut
directory_info
=
metrics
:
:
fog
:
:
DataDirectoryInfoObjectItem
{
dir_name
:
Some
(
subdir
.
to_string
(
)
)
dir_exists
:
None
dir_created
:
None
dir_modified
:
None
file_count
:
None
files
:
Vec
:
:
new
(
)
}
;
if
dir_path
.
is_dir
(
)
{
directory_info
.
dir_exists
=
Some
(
true
)
;
if
let
Ok
(
metadata
)
=
fs
:
:
metadata
(
&
dir_path
)
{
if
let
Ok
(
created
)
=
metadata
.
created
(
)
{
directory_info
.
dir_created
=
Some
(
created
.
duration_since
(
UNIX_EPOCH
)
.
unwrap_or
(
Duration
:
:
ZERO
)
.
as_secs
(
)
as
i64
)
;
}
if
let
Ok
(
modified
)
=
metadata
.
modified
(
)
{
directory_info
.
dir_modified
=
Some
(
modified
.
duration_since
(
UNIX_EPOCH
)
.
unwrap_or
(
Duration
:
:
ZERO
)
.
as_secs
(
)
as
i64
)
;
}
}
let
mut
file_count
=
0
;
for
entry
in
fs
:
:
read_dir
(
&
dir_path
)
.
unwrap
(
)
{
let
entry
=
entry
.
unwrap
(
)
;
let
metadata
=
entry
.
metadata
(
)
.
unwrap
(
)
;
if
metadata
.
is_file
(
)
{
file_count
+
=
1
;
let
file_size
=
metadata
.
len
(
)
as
i64
;
let
modified_time
=
metadata
.
modified
(
)
.
unwrap_or
(
UNIX_EPOCH
)
.
duration_since
(
UNIX_EPOCH
)
.
unwrap_or
(
Duration
:
:
ZERO
)
.
as_secs
(
)
as
i64
;
let
creation_time
=
metadata
.
created
(
)
.
unwrap_or
(
UNIX_EPOCH
)
.
duration_since
(
UNIX_EPOCH
)
.
unwrap_or
(
Duration
:
:
ZERO
)
.
as_secs
(
)
as
i64
;
let
file_name
=
entry
.
file_name
(
)
.
to_string_lossy
(
)
.
to_string
(
)
;
let
file_info
=
metrics
:
:
fog
:
:
DataDirectoryInfoObjectItemItemFilesItem
{
file_name
:
Some
(
file_name
)
file_created
:
Some
(
creation_time
)
file_modified
:
Some
(
modified_time
)
file_size
:
Some
(
file_size
)
}
;
directory_info
.
files
.
push
(
file_info
)
;
}
}
directory_info
.
file_count
=
Some
(
file_count
as
i64
)
;
}
else
{
directory_info
.
dir_exists
=
Some
(
false
)
;
}
directories_info
.
push
(
directory_info
)
;
}
metrics
:
:
fog
:
:
data_directory_info
.
set
(
directories_info
)
;
pings
:
:
temp_fog_initial_state
.
submit
(
Some
(
"
startup
"
)
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
fog_test_reset
(
data_path_override
:
&
nsACString
app_id_override
:
&
nsACString
)
-
>
nsresult
{
fog_test_reset_internal
(
data_path_override
app_id_override
)
.
into
(
)
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
fog_test_reset_internal
(
data_path_override
:
&
nsACString
app_id_override
:
&
nsACString
)
-
>
Result
<
(
)
nsresult
>
{
let
(
mut
conf
client_info
)
=
build_configuration
(
data_path_override
app_id_override
)
?
;
let
upload_enabled
=
static_prefs
:
:
pref
!
(
"
datareporting
.
healthreport
.
uploadEnabled
"
)
;
let
recording_enabled
=
static_prefs
:
:
pref
!
(
"
telemetry
.
fog
.
test
.
localhost_port
"
)
<
0
;
conf
.
upload_enabled
=
upload_enabled
|
|
recording_enabled
;
conf
.
use_core_mps
=
false
;
conf
.
uploader
=
Some
(
Box
:
:
new
(
ViaductUploader
)
as
Box
<
dyn
glean
:
:
net
:
:
PingUploader
>
)
;
glean
:
:
test_reset_glean
(
conf
client_info
true
)
;
pings
:
:
register_pings
(
None
)
;
Ok
(
(
)
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
fog_test_reset_internal
(
data_path_override
:
&
nsACString
app_id_override
:
&
nsACString
)
-
>
Result
<
(
)
nsresult
>
{
let
(
mut
conf
client_info
)
=
build_configuration
(
data_path_override
app_id_override
)
?
;
conf
.
upload_enabled
=
true
;
conf
.
use_core_mps
=
false
;
conf
.
uploader
=
Some
(
Box
:
:
new
(
ViaductUploader
)
as
Box
<
dyn
glean
:
:
net
:
:
PingUploader
>
)
;
glean
:
:
test_reset_glean
(
conf
client_info
true
)
;
Ok
(
(
)
)
}
