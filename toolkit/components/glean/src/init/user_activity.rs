use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
use
std
:
:
sync
:
:
{
atomic
:
:
{
AtomicBool
Ordering
}
RwLock
}
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
use
nserror
:
:
{
nsresult
NS_ERROR_FAILURE
NS_OK
}
;
use
xpcom
:
:
interfaces
:
:
nsISupports
;
#
[
xpcom
(
implement
(
nsIObserver
)
atomic
)
]
pub
(
crate
)
struct
UserActivityObserver
{
last_edge
:
RwLock
<
Instant
>
was_active
:
AtomicBool
}
#
[
allow
(
non_snake_case
)
]
impl
UserActivityObserver
{
pub
(
crate
)
fn
begin_observing
(
)
-
>
Result
<
(
)
nsresult
>
{
glean
:
:
handle_client_active
(
)
;
unsafe
{
let
activity_obs
=
Self
:
:
allocate
(
InitUserActivityObserver
{
last_edge
:
RwLock
:
:
new
(
Instant
:
:
now
(
)
)
was_active
:
AtomicBool
:
:
new
(
false
)
}
)
;
let
obs_service
=
xpcom
:
:
services
:
:
get_ObserverService
(
)
.
ok_or
(
NS_ERROR_FAILURE
)
?
;
let
rv
=
obs_service
.
AddObserver
(
activity_obs
.
coerce
(
)
cstr
!
(
"
user
-
interaction
-
active
"
)
.
as_ptr
(
)
false
)
;
if
!
rv
.
succeeded
(
)
{
return
Err
(
rv
)
;
}
let
rv
=
obs_service
.
AddObserver
(
activity_obs
.
coerce
(
)
cstr
!
(
"
user
-
interaction
-
inactive
"
)
.
as_ptr
(
)
false
)
;
if
!
rv
.
succeeded
(
)
{
return
Err
(
rv
)
;
}
}
Ok
(
(
)
)
}
unsafe
fn
Observe
(
&
self
_subject
:
*
const
nsISupports
topic
:
*
const
c_char
_data
:
*
const
u16
)
-
>
nserror
:
:
nsresult
{
match
CStr
:
:
from_ptr
(
topic
)
.
to_str
(
)
{
Ok
(
"
user
-
interaction
-
active
"
)
=
>
self
.
handle_active
(
)
Ok
(
"
user
-
interaction
-
inactive
"
)
=
>
self
.
handle_inactive
(
)
_
=
>
NS_OK
}
}
fn
handle_active
(
&
self
)
-
>
nserror
:
:
nsresult
{
let
was_active
=
self
.
was_active
.
swap
(
true
Ordering
:
:
SeqCst
)
;
if
!
was_active
{
let
inactivity
=
self
.
last_edge
.
read
(
)
.
expect
(
"
Edge
lock
poisoned
.
"
)
.
elapsed
(
)
;
let
limit
=
static_prefs
:
:
pref
!
(
"
telemetry
.
fog
.
test
.
inactivity_limit
"
)
;
if
inactivity
>
=
Duration
:
:
from_secs
(
limit
.
into
(
)
)
{
log
:
:
info
!
(
"
User
triggers
core
activity
after
{
}
s
!
"
inactivity
.
as_secs
(
)
)
;
glean
:
:
handle_client_active
(
)
;
}
let
mut
edge
=
self
.
last_edge
.
write
(
)
.
expect
(
"
Edge
lock
poisoned
.
"
)
;
*
edge
=
Instant
:
:
now
(
)
;
}
NS_OK
}
fn
handle_inactive
(
&
self
)
-
>
nserror
:
:
nsresult
{
let
was_active
=
self
.
was_active
.
swap
(
false
Ordering
:
:
SeqCst
)
;
if
was_active
{
let
activity
=
self
.
last_edge
.
read
(
)
.
expect
(
"
Edge
lock
poisoned
.
"
)
.
elapsed
(
)
;
let
limit
=
static_prefs
:
:
pref
!
(
"
telemetry
.
fog
.
test
.
activity_limit
"
)
;
if
activity
>
=
Duration
:
:
from_secs
(
limit
.
into
(
)
)
{
log
:
:
info
!
(
"
User
triggers
core
inactivity
after
{
}
s
!
"
activity
.
as_secs
(
)
)
;
glean
:
:
handle_client_inactive
(
)
;
}
let
mut
edge
=
self
.
last_edge
.
write
(
)
.
expect
(
"
Edge
lock
poisoned
.
"
)
;
*
edge
=
Instant
:
:
now
(
)
;
}
NS_OK
}
}
