#
include
"
mozilla
/
glean
/
bindings
/
Event
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
dom
/
GleanMetricsBinding
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
glean
/
bindings
/
Common
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
namespace
mozilla
:
:
glean
{
JSObject
*
GleanEvent
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
GleanEvent_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsCString
camelToSnake
(
const
nsACString
&
aCamel
)
{
nsCString
snake
;
const
auto
*
start
=
aCamel
.
BeginReading
(
)
;
const
auto
*
end
=
aCamel
.
EndReading
(
)
;
for
(
;
start
!
=
end
;
+
+
start
)
{
if
(
'
A
'
<
=
*
start
&
&
*
start
<
=
'
Z
'
)
{
snake
.
AppendLiteral
(
"
_
"
)
;
snake
.
Append
(
static_cast
<
char
>
(
std
:
:
tolower
(
*
start
)
)
)
;
}
else
{
snake
.
Append
(
*
start
)
;
}
}
return
snake
;
}
void
GleanEvent
:
:
Record
(
const
dom
:
:
Optional
<
dom
:
:
Record
<
nsCString
nsCString
>
>
&
aExtra
)
{
if
(
!
aExtra
.
WasPassed
(
)
)
{
mEvent
.
Record
(
)
;
return
;
}
nsTArray
<
nsCString
>
extraKeys
;
nsTArray
<
nsCString
>
extraValues
;
CopyableTArray
<
Telemetry
:
:
EventExtraEntry
>
telExtras
;
nsCString
telValue
;
for
(
const
auto
&
entry
:
aExtra
.
Value
(
)
.
Entries
(
)
)
{
if
(
entry
.
mValue
.
IsVoid
(
)
)
{
continue
;
}
auto
snakeKey
=
camelToSnake
(
entry
.
mKey
)
;
extraKeys
.
AppendElement
(
snakeKey
)
;
extraValues
.
AppendElement
(
entry
.
mValue
)
;
if
(
snakeKey
.
EqualsLiteral
(
"
value
"
)
)
{
telValue
=
entry
.
mValue
;
}
else
{
telExtras
.
EmplaceBack
(
Telemetry
:
:
EventExtraEntry
{
entry
.
mKey
entry
.
mValue
}
)
;
}
}
auto
id
=
EventIdForMetric
(
mEvent
.
mId
)
;
if
(
id
)
{
Telemetry
:
:
RecordEvent
(
id
.
extract
(
)
telValue
.
IsEmpty
(
)
?
Nothing
(
)
:
Some
(
telValue
)
telExtras
.
IsEmpty
(
)
?
Nothing
(
)
:
Some
(
telExtras
)
)
;
}
impl
:
:
fog_event_record
(
mEvent
.
mId
&
extraKeys
&
extraValues
)
;
}
void
GleanEvent
:
:
TestGetValue
(
const
nsACString
&
aPingName
dom
:
:
Nullable
<
nsTArray
<
dom
:
:
GleanEventRecord
>
>
&
aResult
ErrorResult
&
aRv
)
{
auto
resEvents
=
mEvent
.
TestGetValue
(
aPingName
)
;
if
(
resEvents
.
isErr
(
)
)
{
aRv
.
ThrowDataError
(
resEvents
.
unwrapErr
(
)
)
;
return
;
}
auto
optEvents
=
resEvents
.
unwrap
(
)
;
if
(
optEvents
.
isNothing
(
)
)
{
return
;
}
nsTArray
<
dom
:
:
GleanEventRecord
>
ret
;
for
(
auto
&
event
:
optEvents
.
extract
(
)
)
{
dom
:
:
GleanEventRecord
record
;
if
(
!
event
.
mExtra
.
IsEmpty
(
)
)
{
record
.
mExtra
.
Construct
(
)
;
for
(
auto
&
extraEntry
:
event
.
mExtra
)
{
dom
:
:
binding_detail
:
:
RecordEntry
<
nsCString
nsCString
>
extra
;
extra
.
mKey
=
std
:
:
get
<
0
>
(
extraEntry
)
;
extra
.
mValue
=
std
:
:
get
<
1
>
(
extraEntry
)
;
record
.
mExtra
.
Value
(
)
.
Entries
(
)
.
EmplaceBack
(
std
:
:
move
(
extra
)
)
;
}
}
record
.
mCategory
=
event
.
mCategory
;
record
.
mName
=
event
.
mName
;
record
.
mTimestamp
=
event
.
mTimestamp
;
ret
.
EmplaceBack
(
std
:
:
move
(
record
)
)
;
}
aResult
.
SetValue
(
std
:
:
move
(
ret
)
)
;
}
}
