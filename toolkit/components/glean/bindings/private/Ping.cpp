#
include
"
mozilla
/
glean
/
bindings
/
Ping
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
:
:
glean
{
namespace
impl
{
using
CallbackMapType
=
nsTHashMap
<
uint32_t
PingTestCallback
>
;
using
MetricIdToCallbackMutex
=
StaticDataMutex
<
UniquePtr
<
CallbackMapType
>
>
;
static
Maybe
<
MetricIdToCallbackMutex
:
:
AutoLock
>
GetCallbackMapLock
(
)
{
static
MetricIdToCallbackMutex
sCallbacks
(
"
sCallbacks
"
)
;
auto
lock
=
sCallbacks
.
Lock
(
)
;
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
XPCOMWillShutdown
)
)
{
return
Nothing
(
)
;
}
if
(
!
*
lock
)
{
*
lock
=
MakeUnique
<
CallbackMapType
>
(
)
;
RunOnShutdown
(
[
&
]
{
auto
lock
=
sCallbacks
.
Lock
(
)
;
*
lock
=
nullptr
;
}
ShutdownPhase
:
:
XPCOMWillShutdown
)
;
}
return
Some
(
std
:
:
move
(
lock
)
)
;
}
void
Ping
:
:
Submit
(
const
nsACString
&
aReason
)
const
{
{
GetCallbackMapLock
(
)
.
apply
(
[
&
]
(
auto
&
lock
)
{
auto
callback
=
lock
.
ref
(
)
-
>
Extract
(
mId
)
;
if
(
callback
)
{
callback
.
extract
(
)
(
aReason
)
;
}
}
)
;
}
fog_submit_ping_by_id
(
mId
&
aReason
)
;
}
void
Ping
:
:
TestBeforeNextSubmit
(
PingTestCallback
&
&
aCallback
)
const
{
{
GetCallbackMapLock
(
)
.
apply
(
[
&
]
(
auto
&
lock
)
{
lock
.
ref
(
)
-
>
InsertOrUpdate
(
mId
aCallback
)
;
}
)
;
}
}
}
NS_IMPL_CLASSINFO
(
GleanPing
nullptr
0
{
0
}
)
NS_IMPL_ISUPPORTS_CI
(
GleanPing
nsIGleanPing
)
NS_IMETHODIMP
GleanPing
:
:
Submit
(
const
nsACString
&
aReason
)
{
mPing
.
Submit
(
aReason
)
;
return
NS_OK
;
}
NS_IMETHODIMP
GleanPing
:
:
TestBeforeNextSubmit
(
nsIGleanPingTestCallback
*
aCallback
)
{
if
(
NS_WARN_IF
(
!
aCallback
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIGleanPingTestCallback
>
callback
=
aCallback
;
mPing
.
TestBeforeNextSubmit
(
[
callback
]
(
const
nsACString
&
aReason
)
{
callback
-
>
Call
(
aReason
)
;
}
)
;
return
NS_OK
;
}
}
