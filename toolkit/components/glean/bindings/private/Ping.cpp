#
include
"
mozilla
/
glean
/
bindings
/
Ping
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsString
.
h
"
#
include
<
memory
>
namespace
mozilla
:
:
glean
{
namespace
impl
{
using
CallbackMapType
=
nsTHashMap
<
NoMemMoveKey
<
nsUint32HashKey
>
FalliblePingTestCallback
>
;
using
MetricIdToCallbackMutex
=
StaticDataMutex
<
UniquePtr
<
CallbackMapType
>
>
;
static
Maybe
<
MetricIdToCallbackMutex
:
:
AutoLock
>
GetCallbackMapLock
(
)
{
static
MetricIdToCallbackMutex
sCallbacks
(
"
sCallbacks
"
)
;
auto
lock
=
sCallbacks
.
Lock
(
)
;
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
XPCOMWillShutdown
)
)
{
return
Nothing
(
)
;
}
if
(
!
*
lock
)
{
*
lock
=
MakeUnique
<
CallbackMapType
>
(
)
;
RunOnShutdown
(
[
&
]
{
auto
lock
=
sCallbacks
.
Lock
(
)
;
*
lock
=
nullptr
;
}
ShutdownPhase
:
:
XPCOMWillShutdown
)
;
}
return
Some
(
std
:
:
move
(
lock
)
)
;
}
void
Ping
:
:
Submit
(
const
nsACString
&
aReason
)
const
{
(
void
)
SubmitInternal
(
aReason
)
;
}
nsresult
Ping
:
:
SubmitInternal
(
const
nsACString
&
aReason
)
const
{
nsresult
rv
=
NS_OK
;
{
auto
callback
=
Maybe
<
FalliblePingTestCallback
>
(
)
;
GetCallbackMapLock
(
)
.
apply
(
[
&
]
(
const
auto
&
lock
)
{
callback
=
lock
.
ref
(
)
-
>
Extract
(
mId
)
;
}
)
;
if
(
callback
)
{
rv
=
callback
.
extract
(
)
(
aReason
)
;
}
}
fog_submit_ping_by_id
(
mId
&
aReason
)
;
return
rv
;
}
void
Ping
:
:
SetEnabled
(
bool
aValue
)
const
{
fog_set_ping_enabled_by_id
(
mId
aValue
)
;
}
void
Ping
:
:
TestBeforeNextSubmit
(
PingTestCallback
&
&
aCallback
)
const
{
TestBeforeNextSubmitFallible
(
[
callback
=
std
:
:
move
(
aCallback
)
]
(
const
nsACString
&
aReason
)
-
>
nsresult
{
callback
(
aReason
)
;
return
NS_OK
;
}
)
;
}
void
Ping
:
:
TestBeforeNextSubmitFallible
(
FalliblePingTestCallback
&
&
aCallback
)
const
{
{
GetCallbackMapLock
(
)
.
apply
(
[
&
]
(
const
auto
&
lock
)
{
lock
.
ref
(
)
-
>
InsertOrUpdate
(
mId
aCallback
)
;
}
)
;
}
}
bool
Ping
:
:
TestSubmission
(
PingTestCallback
&
&
aTestCallback
PingSubmitCallback
&
&
aSubmitCallback
)
const
{
auto
didCall
=
std
:
:
make_shared
<
bool
>
(
false
)
;
TestBeforeNextSubmit
(
[
callback
=
std
:
:
move
(
aTestCallback
)
didCall
]
(
const
nsACString
&
aReason
)
{
*
didCall
=
true
;
callback
(
aReason
)
;
}
)
;
aSubmitCallback
(
)
;
return
*
didCall
;
}
}
NS_IMPL_CLASSINFO
(
GleanPing
nullptr
0
{
0
}
)
NS_IMPL_ISUPPORTS_CI
(
GleanPing
nsIGleanPing
)
NS_IMETHODIMP
GleanPing
:
:
Submit
(
const
nsACString
&
aReason
)
{
return
mPing
.
SubmitInternal
(
aReason
)
;
}
NS_IMETHODIMP
GleanPing
:
:
SetEnabled
(
bool
aValue
)
{
mPing
.
SetEnabled
(
aValue
)
;
return
NS_OK
;
}
NS_IMETHODIMP
GleanPing
:
:
TestBeforeNextSubmit
(
nsIGleanPingTestCallback
*
aCallback
)
{
if
(
NS_WARN_IF
(
!
aCallback
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mPing
.
TestBeforeNextSubmitFallible
(
[
callback
=
nsCOMPtr
(
aCallback
)
]
(
const
nsACString
&
aReason
)
-
>
nsresult
{
return
callback
-
>
Call
(
aReason
)
;
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
GleanPing
:
:
TestSubmission
(
nsIGleanPingTestCallback
*
aTestCallback
nsIGleanPingSubmitCallback
*
aSubmitCallback
uint32_t
aSubmitTimeoutMs
JSContext
*
aCx
dom
:
:
Promise
*
*
aOutPromise
)
{
if
(
NS_WARN_IF
(
!
aTestCallback
|
|
!
aSubmitCallback
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
IgnoredErrorResult
err
;
RefPtr
<
dom
:
:
Promise
>
submittedPromise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
err
)
;
if
(
err
.
Failed
(
)
)
{
return
err
.
StealNSResult
(
)
;
}
mPing
.
TestBeforeNextSubmit
(
[
testCallback
=
nsCOMPtr
{
aTestCallback
}
submittedPromise
]
(
const
nsACString
&
aReason
)
{
nsresult
rv
=
testCallback
-
>
Call
(
aReason
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
submittedPromise
-
>
MaybeResolveWithUndefined
(
)
;
}
else
{
submittedPromise
-
>
MaybeReject
(
rv
)
;
}
}
)
;
RefPtr
<
dom
:
:
Promise
>
submitPromise
;
MOZ_TRY
(
aSubmitCallback
-
>
Call
(
getter_AddRefs
(
submitPromise
)
)
)
;
RefPtr
<
dom
:
:
Promise
>
thenPromise
=
MOZ_TRY
(
submitPromise
-
>
ThenWithCycleCollectedArgs
(
[
aSubmitTimeoutMs
]
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
ErrorResult
&
aRv
RefPtr
<
dom
:
:
Promise
>
aSubmittedPromise
)
-
>
already_AddRefed
<
dom
:
:
Promise
>
{
if
(
aSubmitTimeoutMs
)
{
nsresult
rv
=
NS_DelayedDispatchToCurrentThread
(
NS_NewRunnableFunction
(
__func__
[
submittedPromise
=
RefPtr
(
aSubmittedPromise
)
]
(
)
{
submittedPromise
-
>
MaybeRejectWithTimeoutError
(
"
Ping
was
not
submitted
after
timeout
"
)
;
}
)
aSubmitTimeoutMs
)
;
if
(
NS_FAILED
(
rv
)
)
{
aSubmittedPromise
-
>
MaybeReject
(
rv
)
;
}
}
else
{
aSubmittedPromise
-
>
MaybeRejectWithOperationError
(
"
Ping
did
not
submit
immediately
"
)
;
}
return
aSubmittedPromise
.
forget
(
)
;
}
std
:
:
move
(
submittedPromise
)
)
)
;
thenPromise
.
forget
(
aOutPromise
)
;
return
NS_OK
;
}
}
