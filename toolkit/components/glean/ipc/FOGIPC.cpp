#
include
"
FOGIPC
.
h
"
#
include
<
limits
>
#
include
"
mozilla
/
glean
/
fog_ffi_generated
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
gfx
/
GPUChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessChild
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessParent
.
h
"
#
include
"
mozilla
/
ProcInfo
.
h
"
#
include
"
mozilla
/
RDDChild
.
h
"
#
include
"
mozilla
/
RDDParent
.
h
"
#
include
"
mozilla
/
RDDProcessManager
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityProcessChild
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityProcessManager
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityProcessParent
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityProcessSandboxing
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
GMPPlatform
.
h
"
#
include
"
GMPServiceParent
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
mozilla
:
:
dom
:
:
ContentParent
;
using
mozilla
:
:
gfx
:
:
GPUChild
;
using
mozilla
:
:
gfx
:
:
GPUProcessManager
;
using
mozilla
:
:
ipc
:
:
ByteBuf
;
using
mozilla
:
:
ipc
:
:
UtilityProcessChild
;
using
mozilla
:
:
ipc
:
:
UtilityProcessManager
;
using
mozilla
:
:
ipc
:
:
UtilityProcessParent
;
using
FlushFOGDataPromise
=
mozilla
:
:
dom
:
:
ContentParent
:
:
FlushFOGDataPromise
;
namespace
geckoprofiler
:
:
markers
{
using
namespace
mozilla
;
struct
ProcessingTimeMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
ProcessingTime
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
int64_t
aDiffMs
const
ProfilerString8View
&
aType
)
{
aWriter
.
IntProperty
(
"
time
"
aDiffMs
)
;
aWriter
.
StringProperty
(
"
label
"
aType
)
;
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyLabelFormat
(
"
time
"
"
Recorded
Time
"
MS
:
:
Format
:
:
Milliseconds
)
;
schema
.
SetTooltipLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
label
}
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
label
}
:
{
marker
.
data
.
time
}
"
)
;
return
schema
;
}
}
;
}
namespace
mozilla
:
:
glean
{
void
RecordPowerMetrics
(
)
{
static
uint64_t
previousCpuTime
=
0
previousGpuTime
=
0
;
uint64_t
cpuTime
newCpuTime
=
0
;
if
(
NS_SUCCEEDED
(
GetCpuTimeSinceProcessStartInMs
(
&
cpuTime
)
)
&
&
cpuTime
>
previousCpuTime
)
{
newCpuTime
=
cpuTime
-
previousCpuTime
;
}
uint64_t
gpuTime
newGpuTime
=
0
;
if
(
!
XRE_IsSocketProcess
(
)
&
&
NS_SUCCEEDED
(
GetGpuTimeSinceProcessStartInMs
(
&
gpuTime
)
)
&
&
gpuTime
>
previousGpuTime
)
{
newGpuTime
=
gpuTime
-
previousGpuTime
;
}
if
(
!
newCpuTime
&
&
!
newGpuTime
)
{
return
;
}
nsAutoCString
type
(
XRE_GetProcessTypeString
(
)
)
;
if
(
XRE_IsContentProcess
(
)
)
{
auto
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
if
(
cc
)
{
type
.
Assign
(
dom
:
:
RemoteTypePrefix
(
cc
-
>
GetRemoteType
(
)
)
)
;
if
(
StringBeginsWith
(
type
WEB_REMOTE_TYPE
)
)
{
type
.
AssignLiteral
(
"
web
"
)
;
switch
(
cc
-
>
GetProcessPriority
(
)
)
{
case
hal
:
:
PROCESS_PRIORITY_BACKGROUND
:
type
.
AppendLiteral
(
"
.
background
"
)
;
break
;
case
hal
:
:
PROCESS_PRIORITY_FOREGROUND
:
type
.
AppendLiteral
(
"
.
foreground
"
)
;
break
;
case
hal
:
:
PROCESS_PRIORITY_BACKGROUND_PERCEIVABLE
:
type
.
AppendLiteral
(
"
.
background
-
perceivable
"
)
;
break
;
default
:
break
;
}
}
}
}
else
if
(
XRE_IsParentProcess
(
)
)
{
if
(
nsContentUtils
:
:
GetUserIsInteracting
(
)
)
{
type
.
AssignLiteral
(
"
parent
.
active
"
)
;
}
else
{
type
.
AssignLiteral
(
"
parent
.
inactive
"
)
;
}
hal
:
:
WakeLockInformation
info
;
GetWakeLockInfo
(
u
"
video
-
playing
"
_ns
&
info
)
;
if
(
info
.
numLocks
(
)
!
=
0
&
&
info
.
numHidden
(
)
<
info
.
numLocks
(
)
)
{
type
.
AppendLiteral
(
"
.
playing
-
video
"
)
;
}
else
{
GetWakeLockInfo
(
u
"
audio
-
playing
"
_ns
&
info
)
;
if
(
info
.
numLocks
(
)
)
{
type
.
AppendLiteral
(
"
.
playing
-
audio
"
)
;
}
}
}
if
(
newCpuTime
)
{
int32_t
nNewCpuTime
=
int32_t
(
newCpuTime
)
;
if
(
newCpuTime
<
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
{
power
:
:
total_cpu_time_ms
.
Add
(
nNewCpuTime
)
;
power
:
:
cpu_time_per_process_type_ms
.
Get
(
type
)
.
Add
(
nNewCpuTime
)
;
}
else
{
power
:
:
cpu_time_bogus_values
.
Add
(
1
)
;
}
PROFILER_MARKER
(
"
CPU
Time
"
OTHER
{
}
ProcessingTimeMarker
nNewCpuTime
type
)
;
previousCpuTime
+
=
newCpuTime
;
}
if
(
newGpuTime
)
{
int32_t
nNewGpuTime
=
int32_t
(
newGpuTime
)
;
if
(
newGpuTime
<
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
{
power
:
:
total_gpu_time_ms
.
Add
(
nNewGpuTime
)
;
power
:
:
gpu_time_per_process_type_ms
.
Get
(
type
)
.
Add
(
nNewGpuTime
)
;
}
else
{
power
:
:
gpu_time_bogus_values
.
Add
(
1
)
;
}
PROFILER_MARKER
(
"
GPU
Time
"
OTHER
{
}
ProcessingTimeMarker
nNewGpuTime
type
)
;
previousGpuTime
+
=
newGpuTime
;
}
}
void
FlushFOGData
(
std
:
:
function
<
void
(
ipc
:
:
ByteBuf
&
&
)
>
&
&
aResolver
)
{
RecordPowerMetrics
(
)
;
ByteBuf
buf
;
uint32_t
ipcBufferSize
=
impl
:
:
fog_serialize_ipc_buf
(
)
;
bool
ok
=
buf
.
Allocate
(
ipcBufferSize
)
;
if
(
!
ok
)
{
return
;
}
uint32_t
writtenLen
=
impl
:
:
fog_give_ipc_buf
(
buf
.
mData
buf
.
mLen
)
;
if
(
writtenLen
!
=
ipcBufferSize
)
{
return
;
}
aResolver
(
std
:
:
move
(
buf
)
)
;
}
void
FlushAllChildData
(
std
:
:
function
<
void
(
nsTArray
<
ipc
:
:
ByteBuf
>
&
&
)
>
&
&
aResolver
)
{
auto
timerId
=
fog_ipc
:
:
flush_durations
.
Start
(
)
;
nsTArray
<
ContentParent
*
>
parents
;
ContentParent
:
:
GetAll
(
parents
)
;
nsTArray
<
RefPtr
<
FlushFOGDataPromise
>
>
promises
;
for
(
auto
*
parent
:
parents
)
{
promises
.
EmplaceBack
(
parent
-
>
SendFlushFOGData
(
)
)
;
}
if
(
GPUProcessManager
*
gpuManager
=
GPUProcessManager
:
:
Get
(
)
)
{
if
(
GPUChild
*
gpuChild
=
gpuManager
-
>
GetGPUChild
(
)
)
{
promises
.
EmplaceBack
(
gpuChild
-
>
SendFlushFOGData
(
)
)
;
}
}
if
(
RDDProcessManager
*
rddManager
=
RDDProcessManager
:
:
Get
(
)
)
{
if
(
RDDChild
*
rddChild
=
rddManager
-
>
GetRDDChild
(
)
)
{
promises
.
EmplaceBack
(
rddChild
-
>
SendFlushFOGData
(
)
)
;
}
}
if
(
net
:
:
SocketProcessParent
*
socketParent
=
net
:
:
SocketProcessParent
:
:
GetSingleton
(
)
)
{
promises
.
EmplaceBack
(
socketParent
-
>
SendFlushFOGData
(
)
)
;
}
{
RefPtr
<
mozilla
:
:
gmp
:
:
GeckoMediaPluginServiceParent
>
gmps
(
mozilla
:
:
gmp
:
:
GeckoMediaPluginServiceParent
:
:
GetSingleton
(
)
)
;
gmps
-
>
SendFlushFOGData
(
promises
)
;
}
if
(
RefPtr
<
UtilityProcessManager
>
utilityManager
=
UtilityProcessManager
:
:
GetIfExists
(
)
)
{
for
(
RefPtr
<
UtilityProcessParent
>
&
parent
:
utilityManager
-
>
GetAllProcessesProcessParent
(
)
)
{
promises
.
EmplaceBack
(
parent
-
>
SendFlushFOGData
(
)
)
;
}
}
if
(
promises
.
Length
(
)
=
=
0
)
{
fog_ipc
:
:
flush_durations
.
Cancel
(
std
:
:
move
(
timerId
)
)
;
nsTArray
<
ipc
:
:
ByteBuf
>
results
;
aResolver
(
std
:
:
move
(
results
)
)
;
return
;
}
FlushFOGDataPromise
:
:
All
(
GetCurrentSerialEventTarget
(
)
promises
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
aResolver
=
std
:
:
move
(
aResolver
)
timerId
]
(
FlushFOGDataPromise
:
:
AllPromiseType
:
:
ResolveOrRejectValue
&
&
aValue
)
{
fog_ipc
:
:
flush_durations
.
StopAndAccumulate
(
std
:
:
move
(
timerId
)
)
;
if
(
aValue
.
IsResolve
(
)
)
{
aResolver
(
std
:
:
move
(
aValue
.
ResolveValue
(
)
)
)
;
}
else
{
fog_ipc
:
:
flush_failures
.
Add
(
1
)
;
nsTArray
<
ipc
:
:
ByteBuf
>
results
;
aResolver
(
std
:
:
move
(
results
)
)
;
}
}
)
;
}
void
FOGData
(
ipc
:
:
ByteBuf
&
&
buf
)
{
fog_ipc
:
:
buffer_sizes
.
Accumulate
(
buf
.
mLen
)
;
impl
:
:
fog_use_ipc_buf
(
buf
.
mData
buf
.
mLen
)
;
}
void
SendFOGData
(
ipc
:
:
ByteBuf
&
&
buf
)
{
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Content
:
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendFOGData
(
std
:
:
move
(
buf
)
)
;
break
;
case
GeckoProcessType_GMPlugin
:
{
mozilla
:
:
gmp
:
:
SendFOGData
(
std
:
:
move
(
buf
)
)
;
}
break
;
case
GeckoProcessType_GPU
:
Unused
<
<
mozilla
:
:
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
-
>
SendFOGData
(
std
:
:
move
(
buf
)
)
;
break
;
case
GeckoProcessType_RDD
:
Unused
<
<
mozilla
:
:
RDDParent
:
:
GetSingleton
(
)
-
>
SendFOGData
(
std
:
:
move
(
buf
)
)
;
break
;
case
GeckoProcessType_Socket
:
Unused
<
<
net
:
:
SocketProcessChild
:
:
GetSingleton
(
)
-
>
SendFOGData
(
std
:
:
move
(
buf
)
)
;
break
;
case
GeckoProcessType_Utility
:
Unused
<
<
ipc
:
:
UtilityProcessChild
:
:
GetSingleton
(
)
-
>
SendFOGData
(
std
:
:
move
(
buf
)
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsuppored
process
type
"
)
;
}
}
RefPtr
<
GenericPromise
>
FlushAndUseFOGData
(
)
{
RecordPowerMetrics
(
)
;
RefPtr
<
GenericPromise
:
:
Private
>
ret
=
new
GenericPromise
:
:
Private
(
__func__
)
;
std
:
:
function
<
void
(
nsTArray
<
ByteBuf
>
&
&
)
>
resolver
=
[
ret
]
(
nsTArray
<
ByteBuf
>
&
&
bufs
)
{
for
(
ByteBuf
&
buf
:
bufs
)
{
FOGData
(
std
:
:
move
(
buf
)
)
;
}
ret
-
>
Resolve
(
true
__func__
)
;
}
;
FlushAllChildData
(
std
:
:
move
(
resolver
)
)
;
return
ret
;
}
void
TestTriggerMetrics
(
uint32_t
aProcessType
const
RefPtr
<
dom
:
:
Promise
>
&
promise
)
{
switch
(
aProcessType
)
{
case
nsIXULRuntime
:
:
PROCESS_TYPE_GMPLUGIN
:
{
RefPtr
<
mozilla
:
:
gmp
:
:
GeckoMediaPluginServiceParent
>
gmps
(
mozilla
:
:
gmp
:
:
GeckoMediaPluginServiceParent
:
:
GetSingleton
(
)
)
;
gmps
-
>
TestTriggerMetrics
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
(
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
}
break
;
case
nsIXULRuntime
:
:
PROCESS_TYPE_GPU
:
gfx
:
:
GPUProcessManager
:
:
Get
(
)
-
>
TestTriggerMetrics
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
(
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
break
;
case
nsIXULRuntime
:
:
PROCESS_TYPE_RDD
:
RDDProcessManager
:
:
Get
(
)
-
>
TestTriggerMetrics
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
(
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
break
;
case
nsIXULRuntime
:
:
PROCESS_TYPE_SOCKET
:
Unused
<
<
net
:
:
SocketProcessParent
:
:
GetSingleton
(
)
-
>
SendTestTriggerMetrics
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
(
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
break
;
case
nsIXULRuntime
:
:
PROCESS_TYPE_UTILITY
:
Unused
<
<
ipc
:
:
UtilityProcessManager
:
:
GetSingleton
(
)
-
>
GetProcessParent
(
ipc
:
:
SandboxingKind
:
:
GENERIC_UTILITY
)
-
>
SendTestTriggerMetrics
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
(
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
break
;
default
:
promise
-
>
MaybeRejectWithUndefined
(
)
;
break
;
}
}
}
