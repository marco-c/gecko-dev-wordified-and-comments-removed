#
include
"
FOGIPC
.
h
"
#
include
"
mozilla
/
glean
/
fog_ffi_generated
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
gfx
/
GPUChild
.
h
"
#
include
"
mozilla
/
gfx
/
GPUParent
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessChild
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessParent
.
h
"
#
include
"
mozilla
/
ProcInfo
.
h
"
#
include
"
mozilla
/
RDDChild
.
h
"
#
include
"
mozilla
/
RDDParent
.
h
"
#
include
"
mozilla
/
RDDProcessManager
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
mozilla
:
:
dom
:
:
ContentParent
;
using
mozilla
:
:
gfx
:
:
GPUChild
;
using
mozilla
:
:
gfx
:
:
GPUProcessManager
;
using
mozilla
:
:
ipc
:
:
ByteBuf
;
using
FlushFOGDataPromise
=
mozilla
:
:
dom
:
:
ContentParent
:
:
FlushFOGDataPromise
;
namespace
mozilla
{
namespace
glean
{
static
void
RecordPowerMetrics
(
)
{
static
uint64_t
previousCpuTime
=
0
previousGpuTime
=
0
;
uint64_t
cpuTime
;
if
(
NS_FAILED
(
GetCpuTimeSinceProcessStartInMs
(
&
cpuTime
)
)
)
{
return
;
}
uint64_t
newCpuTime
=
cpuTime
-
previousCpuTime
;
previousCpuTime
+
=
newCpuTime
;
if
(
newCpuTime
)
{
power
:
:
total_cpu_time_ms
.
Add
(
int32_t
(
newCpuTime
)
)
;
}
uint64_t
gpuTime
;
if
(
NS_SUCCEEDED
(
GetGpuTimeSinceProcessStartInMs
(
&
gpuTime
)
)
)
{
uint64_t
newGpuTime
=
gpuTime
-
previousGpuTime
;
previousGpuTime
+
=
newGpuTime
;
if
(
newGpuTime
)
{
power
:
:
total_gpu_time_ms
.
Add
(
int32_t
(
newGpuTime
)
)
;
}
}
}
void
FlushFOGData
(
std
:
:
function
<
void
(
ipc
:
:
ByteBuf
&
&
)
>
&
&
aResolver
)
{
RecordPowerMetrics
(
)
;
ByteBuf
buf
;
uint32_t
ipcBufferSize
=
impl
:
:
fog_serialize_ipc_buf
(
)
;
bool
ok
=
buf
.
Allocate
(
ipcBufferSize
)
;
if
(
!
ok
)
{
return
;
}
uint32_t
writtenLen
=
impl
:
:
fog_give_ipc_buf
(
buf
.
mData
buf
.
mLen
)
;
if
(
writtenLen
!
=
ipcBufferSize
)
{
return
;
}
aResolver
(
std
:
:
move
(
buf
)
)
;
}
void
FlushAllChildData
(
std
:
:
function
<
void
(
nsTArray
<
ipc
:
:
ByteBuf
>
&
&
)
>
&
&
aResolver
)
{
auto
timerId
=
fog_ipc
:
:
flush_durations
.
Start
(
)
;
nsTArray
<
ContentParent
*
>
parents
;
ContentParent
:
:
GetAll
(
parents
)
;
nsTArray
<
RefPtr
<
FlushFOGDataPromise
>
>
promises
;
for
(
auto
*
parent
:
parents
)
{
promises
.
EmplaceBack
(
parent
-
>
SendFlushFOGData
(
)
)
;
}
if
(
GPUProcessManager
*
gpuManager
=
GPUProcessManager
:
:
Get
(
)
)
{
if
(
GPUChild
*
gpuChild
=
gpuManager
-
>
GetGPUChild
(
)
)
{
promises
.
EmplaceBack
(
gpuChild
-
>
SendFlushFOGData
(
)
)
;
}
}
if
(
RDDProcessManager
*
rddManager
=
RDDProcessManager
:
:
Get
(
)
)
{
if
(
RDDChild
*
rddChild
=
rddManager
-
>
GetRDDChild
(
)
)
{
promises
.
EmplaceBack
(
rddChild
-
>
SendFlushFOGData
(
)
)
;
}
}
if
(
net
:
:
SocketProcessParent
*
socketParent
=
net
:
:
SocketProcessParent
:
:
GetSingleton
(
)
)
{
promises
.
EmplaceBack
(
socketParent
-
>
SendFlushFOGData
(
)
)
;
}
if
(
promises
.
Length
(
)
=
=
0
)
{
fog_ipc
:
:
flush_durations
.
Cancel
(
std
:
:
move
(
timerId
)
)
;
nsTArray
<
ipc
:
:
ByteBuf
>
results
;
aResolver
(
std
:
:
move
(
results
)
)
;
return
;
}
FlushFOGDataPromise
:
:
All
(
GetCurrentSerialEventTarget
(
)
promises
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
aResolver
=
std
:
:
move
(
aResolver
)
timerId
]
(
FlushFOGDataPromise
:
:
AllPromiseType
:
:
ResolveOrRejectValue
&
&
aValue
)
{
fog_ipc
:
:
flush_durations
.
StopAndAccumulate
(
std
:
:
move
(
timerId
)
)
;
if
(
aValue
.
IsResolve
(
)
)
{
aResolver
(
std
:
:
move
(
aValue
.
ResolveValue
(
)
)
)
;
}
else
{
fog_ipc
:
:
flush_failures
.
Add
(
1
)
;
nsTArray
<
ipc
:
:
ByteBuf
>
results
;
aResolver
(
std
:
:
move
(
results
)
)
;
}
}
)
;
}
void
FOGData
(
ipc
:
:
ByteBuf
&
&
buf
)
{
fog_ipc
:
:
buffer_sizes
.
Accumulate
(
buf
.
mLen
)
;
impl
:
:
fog_use_ipc_buf
(
buf
.
mData
buf
.
mLen
)
;
}
void
SendFOGData
(
ipc
:
:
ByteBuf
&
&
buf
)
{
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Content
:
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendFOGData
(
std
:
:
move
(
buf
)
)
;
break
;
case
GeckoProcessType_GPU
:
Unused
<
<
mozilla
:
:
gfx
:
:
GPUParent
:
:
GetSingleton
(
)
-
>
SendFOGData
(
std
:
:
move
(
buf
)
)
;
break
;
case
GeckoProcessType_RDD
:
Unused
<
<
mozilla
:
:
RDDParent
:
:
GetSingleton
(
)
-
>
SendFOGData
(
std
:
:
move
(
buf
)
)
;
break
;
case
GeckoProcessType_Socket
:
Unused
<
<
net
:
:
SocketProcessChild
:
:
GetSingleton
(
)
-
>
SendFOGData
(
std
:
:
move
(
buf
)
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsuppored
process
type
"
)
;
}
}
RefPtr
<
GenericPromise
>
FlushAndUseFOGData
(
)
{
RecordPowerMetrics
(
)
;
RefPtr
<
GenericPromise
:
:
Private
>
ret
=
new
GenericPromise
:
:
Private
(
__func__
)
;
std
:
:
function
<
void
(
nsTArray
<
ByteBuf
>
&
&
)
>
resolver
=
[
ret
]
(
nsTArray
<
ByteBuf
>
&
&
bufs
)
{
for
(
ByteBuf
&
buf
:
bufs
)
{
FOGData
(
std
:
:
move
(
buf
)
)
;
}
ret
-
>
Resolve
(
true
__func__
)
;
}
;
FlushAllChildData
(
std
:
:
move
(
resolver
)
)
;
return
ret
;
}
void
TestTriggerMetrics
(
uint32_t
aProcessType
const
RefPtr
<
dom
:
:
Promise
>
&
promise
)
{
switch
(
aProcessType
)
{
case
nsIXULRuntime
:
:
PROCESS_TYPE_GPU
:
gfx
:
:
GPUProcessManager
:
:
Get
(
)
-
>
TestTriggerMetrics
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
(
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
break
;
case
nsIXULRuntime
:
:
PROCESS_TYPE_RDD
:
RDDProcessManager
:
:
Get
(
)
-
>
TestTriggerMetrics
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
(
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
break
;
case
nsIXULRuntime
:
:
PROCESS_TYPE_SOCKET
:
Unused
<
<
net
:
:
SocketProcessParent
:
:
GetSingleton
(
)
-
>
SendTestTriggerMetrics
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
(
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
break
;
default
:
promise
-
>
MaybeRejectWithUndefined
(
)
;
break
;
}
}
}
}
