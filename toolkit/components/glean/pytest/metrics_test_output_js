#
ifndef
mozilla_GleanJSMetricsLookup_h
#
define
mozilla_GleanJSMetricsLookup_h
#
include
"
mozilla
/
PerfectHash
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
glean
/
bindings
/
MetricTypes
.
h
"
#
include
"
mozilla
/
glean
/
fog_ffi_generated
.
h
"
#
define
GLEAN_INDEX_BITS
(
32
)
#
define
GLEAN_ID_BITS
(
27
)
#
define
GLEAN_TYPE_ID
(
id
)
(
(
id
)
>
>
GLEAN_ID_BITS
)
#
define
GLEAN_METRIC_ID
(
id
)
(
(
id
)
&
(
(
1ULL
<
<
GLEAN_ID_BITS
)
-
1
)
)
#
define
GLEAN_OFFSET
(
entry
)
(
entry
&
(
(
1ULL
<
<
GLEAN_INDEX_BITS
)
-
1
)
)
namespace
mozilla
:
:
glean
{
using
category_entry_t
=
uint32_t
;
using
metric_entry_t
=
uint64_t
;
static_assert
(
GLEAN_INDEX_BITS
+
GLEAN_ID_BITS
<
sizeof
(
metric_entry_t
)
*
8
"
Index
and
ID
bits
need
to
fit
into
an
category_entry_t
"
)
;
static_assert
(
GLEAN_ID_BITS
<
sizeof
(
uint32_t
)
*
8
"
Metric
IDs
need
to
fit
into
less
than
32
bit
"
)
;
static_assert
(
2
<
UINT32_MAX
"
Too
many
metric
categories
generated
.
"
)
;
static_assert
(
19
<
134217728
"
Too
many
metrics
generated
.
"
)
;
static_assert
(
15
<
32
"
Too
many
different
metric
types
.
"
)
;
static
already_AddRefed
<
nsISupports
>
NewMetricFromId
(
uint32_t
id
)
{
uint32_t
typeId
=
GLEAN_TYPE_ID
(
id
)
;
uint32_t
metricId
=
GLEAN_METRIC_ID
(
id
)
;
switch
(
typeId
)
{
case
1
:
{
return
MakeAndAddRef
<
GleanBoolean
>
(
metricId
)
;
}
case
2
:
{
return
MakeAndAddRef
<
GleanLabeled
>
(
metricId
2
)
;
}
case
3
:
{
return
MakeAndAddRef
<
GleanCounter
>
(
metricId
)
;
}
case
4
:
{
return
MakeAndAddRef
<
GleanLabeled
>
(
metricId
4
)
;
}
case
5
:
{
return
MakeAndAddRef
<
GleanString
>
(
metricId
)
;
}
case
6
:
{
return
MakeAndAddRef
<
GleanLabeled
>
(
metricId
6
)
;
}
case
7
:
{
return
MakeAndAddRef
<
GleanStringList
>
(
metricId
)
;
}
case
8
:
{
return
MakeAndAddRef
<
GleanTimespan
>
(
metricId
)
;
}
case
9
:
{
return
MakeAndAddRef
<
GleanTimingDistribution
>
(
metricId
)
;
}
case
10
:
{
return
MakeAndAddRef
<
GleanMemoryDistribution
>
(
metricId
)
;
}
case
11
:
{
return
MakeAndAddRef
<
GleanCustomDistribution
>
(
metricId
)
;
}
case
12
:
{
return
MakeAndAddRef
<
GleanUuid
>
(
metricId
)
;
}
case
13
:
{
return
MakeAndAddRef
<
GleanDatetime
>
(
metricId
)
;
}
case
14
:
{
return
MakeAndAddRef
<
GleanEvent
>
(
metricId
)
;
}
case
15
:
{
return
MakeAndAddRef
<
GleanQuantity
>
(
metricId
)
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
type
ID
reached
when
trying
to
instantiate
a
new
metric
"
)
;
return
nullptr
;
}
}
static
already_AddRefed
<
nsISupports
>
NewSubMetricFromIds
(
uint32_t
aParentTypeId
uint32_t
aParentMetricId
const
nsACString
&
aLabel
uint32_t
*
aSubmetricId
)
{
switch
(
aParentTypeId
)
{
case
2
:
{
#
ifdef
MOZ_GLEAN_ANDROID
auto
id
=
*
aSubmetricId
;
#
else
auto
id
=
impl
:
:
fog_labeled_boolean_get
(
aParentMetricId
&
aLabel
)
;
*
aSubmetricId
=
id
;
#
endif
return
MakeAndAddRef
<
GleanBoolean
>
(
id
)
;
}
case
4
:
{
#
ifdef
MOZ_GLEAN_ANDROID
auto
id
=
*
aSubmetricId
;
#
else
auto
id
=
impl
:
:
fog_labeled_counter_get
(
aParentMetricId
&
aLabel
)
;
*
aSubmetricId
=
id
;
#
endif
return
MakeAndAddRef
<
GleanCounter
>
(
id
)
;
}
case
6
:
{
#
ifdef
MOZ_GLEAN_ANDROID
auto
id
=
*
aSubmetricId
;
#
else
auto
id
=
impl
:
:
fog_labeled_string_get
(
aParentMetricId
&
aLabel
)
;
*
aSubmetricId
=
id
;
#
endif
return
MakeAndAddRef
<
GleanString
>
(
id
)
;
}
default
:
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
type
ID
for
submetric
.
"
)
;
return
nullptr
;
}
}
}
static
Maybe
<
uint32_t
>
category_result_check
(
const
nsACString
&
aKey
category_entry_t
entry
)
;
static
Maybe
<
uint32_t
>
metric_result_check
(
const
nsACString
&
aKey
metric_entry_t
entry
)
;
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
const
char
gCategoryStringTable
[
]
=
{
#
else
constexpr
char
gCategoryStringTable
[
]
=
{
#
endif
'
t
'
'
e
'
'
s
'
'
t
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
\
0
'
}
;
static_assert
(
sizeof
(
gCategoryStringTable
)
<
UINT32_MAX
"
Category
string
table
is
too
large
.
"
)
;
const
category_entry_t
sCategoryByNameLookupEntries
[
]
=
{
5
0
}
;
static
Maybe
<
uint32_t
>
CategoryByNameLookup
(
const
nsACString
&
aKey
)
{
static
const
uint8_t
BASES
[
]
=
{
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
const
char
*
bytes
=
aKey
.
BeginReading
(
)
;
size_t
length
=
aKey
.
Length
(
)
;
auto
&
entry
=
mozilla
:
:
perfecthash
:
:
Lookup
(
bytes
length
BASES
sCategoryByNameLookupEntries
)
;
return
category_result_check
(
aKey
entry
)
;
}
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
const
char
gMetricStringTable
[
]
=
{
#
else
constexpr
char
gMetricStringTable
[
]
=
{
#
endif
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
b
'
'
o
'
'
o
'
'
l
'
'
e
'
'
a
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
B
'
'
o
'
'
o
'
'
l
'
'
e
'
'
a
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
B
'
'
o
'
'
o
'
'
l
'
'
e
'
'
a
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
L
'
'
a
'
'
b
'
'
e
'
'
l
'
'
s
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
c
'
'
o
'
'
u
'
'
n
'
'
t
'
'
e
'
'
r
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
C
'
'
o
'
'
u
'
'
n
'
'
t
'
'
e
'
'
r
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
C
'
'
o
'
'
u
'
'
n
'
'
t
'
'
e
'
'
r
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
L
'
'
a
'
'
b
'
'
e
'
'
l
'
'
s
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
s
'
'
t
'
'
r
'
'
i
'
'
n
'
'
g
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
S
'
'
t
'
'
r
'
'
i
'
'
n
'
'
g
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
l
'
'
a
'
'
b
'
'
e
'
'
l
'
'
e
'
'
d
'
'
S
'
'
t
'
'
r
'
'
i
'
'
n
'
'
g
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
L
'
'
a
'
'
b
'
'
e
'
'
l
'
'
s
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
s
'
'
t
'
'
r
'
'
i
'
'
n
'
'
g
'
'
L
'
'
i
'
'
s
'
'
t
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
t
'
'
i
'
'
m
'
'
e
'
'
s
'
'
p
'
'
a
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
t
'
'
i
'
'
m
'
'
i
'
'
n
'
'
g
'
'
D
'
'
i
'
'
s
'
'
t
'
'
r
'
'
i
'
'
b
'
'
u
'
'
t
'
'
i
'
'
o
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
m
'
'
e
'
'
m
'
'
o
'
'
r
'
'
y
'
'
D
'
'
i
'
'
s
'
'
t
'
'
r
'
'
i
'
'
b
'
'
u
'
'
t
'
'
i
'
'
o
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
.
'
'
c
'
'
u
'
'
s
'
'
t
'
'
o
'
'
m
'
'
D
'
'
i
'
'
s
'
'
t
'
'
r
'
'
i
'
'
b
'
'
u
'
'
t
'
'
i
'
'
o
'
'
n
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
u
'
'
u
'
'
i
'
'
d
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
d
'
'
a
'
'
t
'
'
e
'
'
t
'
'
i
'
'
m
'
'
e
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
e
'
'
v
'
'
e
'
'
n
'
'
t
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
e
'
'
v
'
'
e
'
'
n
'
'
t
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
W
'
'
i
'
'
t
'
'
h
'
'
E
'
'
x
'
'
t
'
'
r
'
'
a
'
'
\
0
'
'
t
'
'
e
'
'
s
'
'
t
'
'
N
'
'
e
'
'
s
'
'
t
'
'
e
'
'
d
'
'
.
'
'
q
'
'
u
'
'
a
'
'
n
'
'
t
'
'
i
'
'
t
'
'
y
'
'
M
'
'
e
'
'
t
'
'
r
'
'
i
'
'
c
'
'
\
0
'
}
;
static_assert
(
sizeof
(
gMetricStringTable
)
<
4294967296
"
Metric
string
table
is
too
large
.
"
)
;
const
metric_entry_t
sMetricByNameLookupEntries
[
]
=
{
1152921517491748909
3458764552475246789
8070450609557340591
4035225309073637604
8646911366155731407
1729382274090139725
2882303791581888666
6917529092065591656
5188146822270419214
576460756598390784
3458764548180279468
6341068335467200842
5764607578868810028
7493989848663982462
2305843030688530528
1152921513196781587
8070450605262373272
4611686065672028410
2305843034983497850
}
;
static
Maybe
<
uint32_t
>
MetricByNameLookup
(
const
nsACString
&
aKey
)
{
static
const
uint8_t
BASES
[
]
=
{
0
0
0
1
0
1
0
1
1
0
0
0
0
0
0
0
1
0
0
0
1
0
0
1
0
3
0
0
2
0
1
0
4
0
0
0
0
0
0
0
2
0
0
2
0
9
0
0
0
0
10
0
0
18
0
0
0
0
0
0
0
0
0
17
}
;
const
char
*
bytes
=
aKey
.
BeginReading
(
)
;
size_t
length
=
aKey
.
Length
(
)
;
auto
&
entry
=
mozilla
:
:
perfecthash
:
:
Lookup
(
bytes
length
BASES
sMetricByNameLookupEntries
)
;
return
metric_result_check
(
aKey
entry
)
;
}
static
const
char
*
GetCategoryName
(
category_entry_t
entry
)
{
MOZ_ASSERT
(
entry
<
sizeof
(
gCategoryStringTable
)
"
Entry
identifier
offset
larger
than
string
table
"
)
;
return
&
gCategoryStringTable
[
entry
]
;
}
static
const
char
*
GetMetricIdentifier
(
metric_entry_t
entry
)
{
uint32_t
offset
=
GLEAN_OFFSET
(
entry
)
;
MOZ_ASSERT
(
offset
<
sizeof
(
gMetricStringTable
)
"
Entry
identifier
offset
larger
than
string
table
"
)
;
return
&
gMetricStringTable
[
offset
]
;
}
static
Maybe
<
uint32_t
>
category_result_check
(
const
nsACString
&
aKey
category_entry_t
entry
)
{
if
(
MOZ_UNLIKELY
(
entry
>
sizeof
(
gCategoryStringTable
)
)
)
{
return
Nothing
(
)
;
}
if
(
aKey
.
EqualsASCII
(
gCategoryStringTable
+
entry
)
)
{
return
Some
(
entry
)
;
}
return
Nothing
(
)
;
}
static
Maybe
<
uint32_t
>
metric_result_check
(
const
nsACString
&
aKey
uint64_t
entry
)
{
uint32_t
metricId
=
entry
>
>
GLEAN_INDEX_BITS
;
uint32_t
offset
=
GLEAN_OFFSET
(
entry
)
;
if
(
offset
>
sizeof
(
gMetricStringTable
)
)
{
return
Nothing
(
)
;
}
if
(
aKey
.
EqualsASCII
(
gMetricStringTable
+
offset
)
)
{
return
Some
(
metricId
)
;
}
return
Nothing
(
)
;
}
#
undef
GLEAN_INDEX_BITS
#
undef
GLEAN_ID_BITS
#
undef
GLEAN_TYPE_ID
#
undef
GLEAN_METRIC_ID
#
undef
GLEAN_OFFSET
}
#
endif
