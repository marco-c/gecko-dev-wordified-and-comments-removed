"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
PREF_LOGLEVEL
=
"
browser
.
policies
.
loglevel
"
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
return
new
ConsoleAPI
(
{
prefix
:
"
macOSPoliciesParser
.
jsm
"
maxLogLevel
:
"
error
"
maxLogLevelPref
:
PREF_LOGLEVEL
}
)
;
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
macOSPoliciesParser
"
]
;
var
macOSPoliciesParser
=
{
readPolicies
(
reader
)
{
let
nativePolicies
=
reader
.
readPreferences
(
)
;
if
(
!
nativePolicies
)
{
return
null
;
}
nativePolicies
=
this
.
unflatten
(
nativePolicies
)
;
nativePolicies
=
this
.
removeUnknownPolicies
(
nativePolicies
)
;
if
(
lazy
.
log
.
maxLogLevel
=
=
"
debug
"
)
{
lazy
.
log
.
debug
(
JSON
.
stringify
(
nativePolicies
null
2
)
)
;
}
return
nativePolicies
;
}
removeUnknownPolicies
(
policies
)
{
let
{
schema
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
/
modules
/
policies
/
schema
.
jsm
"
)
;
for
(
let
policyName
of
Object
.
keys
(
policies
)
)
{
if
(
!
schema
.
properties
.
hasOwnProperty
(
policyName
)
)
{
lazy
.
log
.
debug
(
Removing
unknown
policy
:
{
policyName
}
)
;
delete
policies
[
policyName
]
;
}
}
return
policies
;
}
unflatten
(
input
delimiter
=
"
__
"
)
{
let
ret
=
{
}
;
for
(
let
key
of
Object
.
keys
(
input
)
)
{
if
(
!
key
.
includes
(
delimiter
)
)
{
ret
[
key
]
=
input
[
key
]
;
continue
;
}
lazy
.
log
.
debug
(
Unflattening
policy
key
"
{
key
}
"
.
)
;
let
subkeys
=
key
.
split
(
delimiter
)
;
let
obj
=
ret
;
for
(
let
i
=
0
;
i
<
subkeys
.
length
-
1
;
i
+
+
)
{
let
subkey
=
subkeys
[
i
]
;
if
(
!
isValidSubkey
(
subkey
)
)
{
lazy
.
log
.
error
(
Error
in
key
{
key
}
:
can
'
t
use
indexes
bigger
than
50
.
)
;
continue
;
}
if
(
!
obj
[
subkey
]
)
{
if
(
Number
.
isInteger
(
Number
(
subkeys
[
i
+
1
]
)
)
)
{
obj
[
subkey
]
=
[
]
;
}
else
{
obj
[
subkey
]
=
{
}
;
}
}
obj
=
obj
[
subkey
]
;
}
let
lastSubkey
=
subkeys
[
subkeys
.
length
-
1
]
;
if
(
!
isValidSubkey
(
lastSubkey
)
)
{
lazy
.
log
.
error
(
Error
in
key
{
key
}
:
can
'
t
use
indexes
bigger
than
50
.
)
;
continue
;
}
obj
[
lastSubkey
]
=
input
[
key
]
;
}
return
ret
;
}
}
;
function
isValidSubkey
(
subkey
)
{
let
valueAsNumber
=
Number
(
subkey
)
;
return
Number
.
isNaN
(
valueAsNumber
)
|
|
valueAsNumber
<
=
50
;
}
