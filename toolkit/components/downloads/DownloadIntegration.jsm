"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadIntegration
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Downloads
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
const
{
Integration
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Integration
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
AsyncShutdown
"
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
DownloadStore
"
"
resource
:
/
/
gre
/
modules
/
DownloadStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
DownloadUIHelper
"
"
resource
:
/
/
gre
/
modules
/
DownloadUIHelper
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gDownloadPlatform
"
"
mozilla
.
org
/
toolkit
/
download
-
platform
;
1
"
"
mozIDownloadPlatform
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gEnvironment
"
"
mozilla
.
org
/
process
/
environment
;
1
"
"
nsIEnvironment
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gMIMEService
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gExternalProtocolService
"
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
"
nsIExternalProtocolService
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gParentalControlsService
"
function
(
)
{
if
(
"
mozilla
.
org
/
parental
-
controls
-
service
;
1
"
in
Cc
)
{
return
Cc
[
"
mozilla
.
org
/
parental
-
controls
-
service
;
1
"
]
.
createInstance
(
Ci
.
nsIParentalControlsService
)
;
}
return
null
;
}
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
DownloadSpamProtection
"
"
resource
:
/
/
/
modules
/
DownloadSpamProtection
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gApplicationReputationService
"
"
mozilla
.
org
/
reputationservice
/
application
-
reputation
-
service
;
1
"
Ci
.
nsIApplicationReputationService
)
;
Integration
.
downloads
.
defineModuleGetter
(
lazy
"
DownloadIntegration
"
"
resource
:
/
/
gre
/
modules
/
DownloadIntegration
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gCombinedDownloadIntegration
"
(
)
=
>
{
return
lazy
.
DownloadIntegration
;
}
)
;
const
Timer
=
Components
.
Constructor
(
"
mozilla
.
org
/
timer
;
1
"
"
nsITimer
"
"
initWithCallback
"
)
;
const
kSaveDelayMs
=
1500
;
const
kObserverTopics
=
[
"
quit
-
application
-
requested
"
"
offline
-
requested
"
"
last
-
pb
-
context
-
exiting
"
"
last
-
pb
-
context
-
exited
"
"
sleep_notification
"
"
suspend_process_notification
"
"
wake_notification
"
"
resume_process_notification
"
"
network
:
offline
-
about
-
to
-
go
-
offline
"
"
network
:
offline
-
status
-
changed
"
"
xpcom
-
will
-
shutdown
"
"
blocked
-
automatic
-
download
"
]
;
const
kVerdictMap
=
{
[
Ci
.
nsIApplicationReputationService
.
VERDICT_DANGEROUS
]
:
Downloads
.
Error
.
BLOCK_VERDICT_MALWARE
[
Ci
.
nsIApplicationReputationService
.
VERDICT_UNCOMMON
]
:
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
[
Ci
.
nsIApplicationReputationService
.
VERDICT_POTENTIALLY_UNWANTED
]
:
Downloads
.
Error
.
BLOCK_VERDICT_POTENTIALLY_UNWANTED
[
Ci
.
nsIApplicationReputationService
.
VERDICT_DANGEROUS_HOST
]
:
Downloads
.
Error
.
BLOCK_VERDICT_MALWARE
}
;
var
DownloadIntegration
=
{
_store
:
null
shouldKeepBlockedData
(
)
{
const
FIREFOX_ID
=
"
{
ec8030f7
-
c20a
-
464f
-
9b0e
-
13a3a9e97384
}
"
;
return
Services
.
appinfo
.
ID
=
=
FIREFOX_ID
;
}
async
initializePublicDownloadList
(
list
)
{
try
{
await
this
.
loadPublicDownloadListFromStore
(
list
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
if
(
AppConstants
.
MOZ_PLACES
)
{
new
DownloadHistoryObserver
(
list
)
;
}
}
async
loadPublicDownloadListFromStore
(
list
)
{
if
(
this
.
_store
)
{
throw
new
Error
(
"
Initialization
may
be
performed
only
once
.
"
)
;
}
this
.
_store
=
new
lazy
.
DownloadStore
(
list
PathUtils
.
join
(
PathUtils
.
profileDir
"
downloads
.
json
"
)
)
;
this
.
_store
.
onsaveitem
=
this
.
shouldPersistDownload
.
bind
(
this
)
;
try
{
await
this
.
_store
.
load
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
await
new
DownloadAutoSaveView
(
list
this
.
_store
)
.
initialize
(
)
;
}
shouldPersistDownload
(
aDownload
)
{
return
(
!
aDownload
.
stopped
|
|
aDownload
.
hasPartialData
|
|
aDownload
.
hasBlockedData
|
|
AppConstants
.
platform
=
=
"
android
"
)
;
}
async
getSystemDownloadsDirectory
(
)
{
if
(
this
.
_downloadsDirectory
)
{
return
this
.
_downloadsDirectory
;
}
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
this
.
_downloadsDirectory
=
lazy
.
gEnvironment
.
get
(
"
DOWNLOADS_DIRECTORY
"
)
;
if
(
!
this
.
_downloadsDirectory
)
{
throw
new
Components
.
Exception
(
"
DOWNLOADS_DIRECTORY
is
not
set
.
"
Cr
.
NS_ERROR_FILE_UNRECOGNIZED_PATH
)
;
}
}
else
{
try
{
this
.
_downloadsDirectory
=
this
.
_getDirectory
(
"
DfltDwnld
"
)
;
}
catch
(
e
)
{
this
.
_downloadsDirectory
=
await
this
.
_createDownloadsDirectory
(
"
Home
"
)
;
}
}
return
this
.
_downloadsDirectory
;
}
_downloadsDirectory
:
null
async
getPreferredDownloadsDirectory
(
)
{
let
directoryPath
=
null
;
let
prefValue
=
Services
.
prefs
.
getIntPref
(
"
browser
.
download
.
folderList
"
1
)
;
switch
(
prefValue
)
{
case
0
:
directoryPath
=
this
.
_getDirectory
(
"
Desk
"
)
;
break
;
case
1
:
directoryPath
=
await
this
.
getSystemDownloadsDirectory
(
)
;
break
;
case
2
:
try
{
let
directory
=
Services
.
prefs
.
getComplexValue
(
"
browser
.
download
.
dir
"
Ci
.
nsIFile
)
;
directoryPath
=
directory
.
path
;
await
IOUtils
.
makeDirectory
(
directoryPath
{
createAncestors
:
false
}
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
directoryPath
=
await
this
.
getSystemDownloadsDirectory
(
)
;
}
break
;
default
:
directoryPath
=
await
this
.
getSystemDownloadsDirectory
(
)
;
}
return
directoryPath
;
}
async
getTemporaryDownloadsDirectory
(
)
{
let
directoryPath
=
null
;
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
directoryPath
=
await
this
.
getPreferredDownloadsDirectory
(
)
;
}
else
if
(
AppConstants
.
platform
=
=
"
android
"
)
{
directoryPath
=
await
this
.
getSystemDownloadsDirectory
(
)
;
}
else
{
directoryPath
=
this
.
_getDirectory
(
"
TmpD
"
)
;
}
return
directoryPath
;
}
shouldBlockForParentalControls
(
aDownload
)
{
let
isEnabled
=
lazy
.
gParentalControlsService
&
&
lazy
.
gParentalControlsService
.
parentalControlsEnabled
;
let
shouldBlock
=
isEnabled
&
&
lazy
.
gParentalControlsService
.
blockFileDownloadsEnabled
;
if
(
isEnabled
&
&
lazy
.
gParentalControlsService
.
loggingEnabled
)
{
lazy
.
gParentalControlsService
.
log
(
lazy
.
gParentalControlsService
.
ePCLog_FileDownload
shouldBlock
lazy
.
NetUtil
.
newURI
(
aDownload
.
source
.
url
)
null
)
;
}
return
Promise
.
resolve
(
shouldBlock
)
;
}
shouldBlockForReputationCheck
(
aDownload
)
{
let
hash
;
let
sigInfo
;
let
channelRedirects
;
try
{
hash
=
aDownload
.
saver
.
getSha256Hash
(
)
;
sigInfo
=
aDownload
.
saver
.
getSignatureInfo
(
)
;
channelRedirects
=
aDownload
.
saver
.
getRedirects
(
)
;
}
catch
(
ex
)
{
return
Promise
.
resolve
(
{
shouldBlock
:
false
verdict
:
"
"
}
)
;
}
if
(
!
hash
|
|
!
sigInfo
)
{
return
Promise
.
resolve
(
{
shouldBlock
:
false
verdict
:
"
"
}
)
;
}
return
new
Promise
(
resolve
=
>
{
lazy
.
gApplicationReputationService
.
queryReputation
(
{
sourceURI
:
lazy
.
NetUtil
.
newURI
(
aDownload
.
source
.
url
)
referrerInfo
:
aDownload
.
source
.
referrerInfo
fileSize
:
aDownload
.
currentBytes
sha256Hash
:
hash
suggestedFileName
:
PathUtils
.
filename
(
aDownload
.
target
.
path
)
signatureInfo
:
sigInfo
redirects
:
channelRedirects
}
function
onComplete
(
aShouldBlock
aRv
aVerdict
)
{
resolve
(
{
shouldBlock
:
aShouldBlock
verdict
:
(
aShouldBlock
&
&
kVerdictMap
[
aVerdict
]
)
|
|
"
"
}
)
;
}
)
;
}
)
;
}
_shouldSaveZoneInformation
(
)
{
let
key
=
Cc
[
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
]
.
createInstance
(
Ci
.
nsIWindowsRegKey
)
;
try
{
key
.
open
(
Ci
.
nsIWindowsRegKey
.
ROOT_KEY_CURRENT_USER
"
Software
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Policies
\
\
Attachments
"
Ci
.
nsIWindowsRegKey
.
ACCESS_QUERY_VALUE
)
;
try
{
return
key
.
readIntValue
(
"
SaveZoneInformation
"
)
!
=
1
;
}
finally
{
key
.
close
(
)
;
}
}
catch
(
ex
)
{
return
true
;
}
}
_zoneIdKey
(
aKey
aUrl
aFallback
)
{
try
{
let
url
;
const
uri
=
lazy
.
NetUtil
.
newURI
(
aUrl
)
;
if
(
[
"
http
"
"
https
"
"
ftp
"
]
.
includes
(
uri
.
scheme
)
)
{
url
=
uri
.
mutate
(
)
.
setUserPass
(
"
"
)
.
finalize
(
)
.
spec
;
}
else
if
(
aFallback
)
{
url
=
aFallback
;
}
else
{
return
"
"
;
}
return
aKey
+
"
=
"
+
url
+
"
\
r
\
n
"
;
}
catch
(
e
)
{
return
"
"
;
}
}
async
downloadDone
(
aDownload
)
{
if
(
AppConstants
.
platform
=
=
"
win
"
&
&
this
.
_shouldSaveZoneInformation
(
)
)
{
let
zone
;
try
{
zone
=
lazy
.
gDownloadPlatform
.
mapUrlToZone
(
aDownload
.
source
.
url
)
;
}
catch
(
e
)
{
zone
=
Ci
.
mozIDownloadPlatform
.
ZONE_INTERNET
;
}
if
(
zone
>
=
Ci
.
mozIDownloadPlatform
.
ZONE_INTERNET
)
{
let
path
=
aDownload
.
target
.
path
+
"
:
Zone
.
Identifier
"
;
try
{
let
zoneId
=
"
[
ZoneTransfer
]
\
r
\
nZoneId
=
"
+
zone
+
"
\
r
\
n
"
;
let
{
url
isPrivate
referrerInfo
}
=
aDownload
.
source
;
if
(
!
isPrivate
)
{
let
referrer
=
referrerInfo
?
referrerInfo
.
computedReferrerSpec
:
"
"
;
zoneId
+
=
this
.
_zoneIdKey
(
"
ReferrerUrl
"
referrer
)
+
this
.
_zoneIdKey
(
"
HostUrl
"
url
"
about
:
internet
"
)
;
}
await
IOUtils
.
writeUTF8
(
PathUtils
.
toExtendedWindowsPath
(
path
)
zoneId
)
;
}
catch
(
ex
)
{
if
(
!
DOMException
.
isInstance
(
ex
)
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
}
try
{
let
isTemporaryDownload
=
aDownload
.
launchWhenSucceeded
&
&
(
aDownload
.
source
.
isPrivate
|
|
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
helperApps
.
deleteTempFileOnExit
"
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
download
.
improvements_to_download_panel
"
)
)
)
;
let
unixMode
;
if
(
isTemporaryDownload
)
{
unixMode
=
0o400
;
}
else
{
unixMode
=
0o666
;
}
await
IOUtils
.
setPermissions
(
aDownload
.
target
.
path
unixMode
)
;
}
catch
(
ex
)
{
if
(
!
DOMException
.
isInstance
(
ex
)
)
{
Cu
.
reportError
(
ex
)
;
}
}
let
aReferrer
=
null
;
if
(
aDownload
.
source
.
referrerInfo
)
{
aReferrer
=
aDownload
.
source
.
referrerInfo
.
originalReferrer
;
}
await
lazy
.
gDownloadPlatform
.
downloadDone
(
lazy
.
NetUtil
.
newURI
(
aDownload
.
source
.
url
)
aReferrer
new
lazy
.
FileUtils
.
File
(
aDownload
.
target
.
path
)
aDownload
.
contentType
aDownload
.
source
.
isPrivate
)
;
}
shouldViewDownloadInternally
(
aMimeType
aExtension
)
{
return
false
;
}
async
launchDownload
(
aDownload
{
openWhere
useSystemDefault
=
null
}
)
{
let
file
=
new
lazy
.
FileUtils
.
File
(
aDownload
.
target
.
path
)
;
let
fileExtension
=
null
mimeInfo
=
null
;
let
match
=
file
.
leafName
.
match
(
/
\
.
(
[
^
.
]
+
)
/
)
;
if
(
match
)
{
fileExtension
=
match
[
1
]
;
}
let
isWindowsExe
=
AppConstants
.
platform
=
=
"
win
"
&
&
fileExtension
&
&
fileExtension
.
toLowerCase
(
)
=
=
"
exe
"
;
let
isExemptExecutableExtension
=
Services
.
policies
.
isExemptExecutableExtension
(
aDownload
.
source
.
url
fileExtension
)
;
if
(
file
.
isExecutable
(
)
&
&
!
isWindowsExe
&
&
!
isExemptExecutableExtension
&
&
!
(
await
this
.
confirmLaunchExecutable
(
file
.
path
)
)
)
{
return
;
}
try
{
mimeInfo
=
lazy
.
gMIMEService
.
getFromTypeAndExtension
(
aDownload
.
contentType
fileExtension
)
;
}
catch
(
e
)
{
}
if
(
aDownload
.
launcherPath
)
{
if
(
!
mimeInfo
)
{
throw
new
Error
(
"
Unable
to
create
nsIMIMEInfo
to
launch
a
custom
application
"
)
;
}
let
localHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localHandlerApp
.
executable
=
new
lazy
.
FileUtils
.
File
(
aDownload
.
launcherPath
)
;
mimeInfo
.
preferredApplicationHandler
=
localHandlerApp
;
mimeInfo
.
preferredAction
=
Ci
.
nsIMIMEInfo
.
useHelperApp
;
this
.
launchFile
(
file
mimeInfo
)
;
aDownload
.
launchWhenSucceeded
=
false
;
return
;
}
if
(
!
useSystemDefault
&
&
mimeInfo
)
{
useSystemDefault
=
mimeInfo
.
preferredAction
=
=
mimeInfo
.
useSystemDefault
;
}
if
(
!
useSystemDefault
)
{
if
(
aDownload
.
handleInternally
|
|
(
mimeInfo
&
&
this
.
shouldViewDownloadInternally
(
mimeInfo
.
type
fileExtension
)
&
&
!
mimeInfo
.
alwaysAskBeforeHandling
&
&
(
mimeInfo
.
preferredAction
=
=
=
Ci
.
nsIHandlerInfo
.
handleInternally
|
|
(
[
"
image
/
svg
+
xml
"
"
text
/
xml
"
"
application
/
xml
"
]
.
includes
(
mimeInfo
.
type
)
&
&
mimeInfo
.
preferredAction
=
=
=
Ci
.
nsIHandlerInfo
.
saveToDisk
)
)
&
&
!
aDownload
.
launchWhenSucceeded
)
)
{
lazy
.
DownloadUIHelper
.
loadFileIn
(
file
{
browsingContextId
:
aDownload
.
source
.
browsingContextId
isPrivate
:
aDownload
.
source
.
isPrivate
openWhere
userContextId
:
aDownload
.
source
.
userContextId
}
)
;
return
;
}
}
aDownload
.
launchWhenSucceeded
=
false
;
if
(
!
fileExtension
&
&
AppConstants
.
platform
=
=
"
win
"
)
{
this
.
showContainingDirectory
(
aDownload
.
target
.
path
)
;
return
;
}
if
(
mimeInfo
)
{
mimeInfo
.
preferredAction
=
Ci
.
nsIMIMEInfo
.
useSystemDefault
;
try
{
this
.
launchFile
(
file
mimeInfo
)
;
return
;
}
catch
(
ex
)
{
}
}
try
{
this
.
launchFile
(
file
)
;
return
;
}
catch
(
ex
)
{
}
lazy
.
gExternalProtocolService
.
loadURI
(
lazy
.
NetUtil
.
newURI
(
file
)
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
async
confirmLaunchExecutable
(
path
)
{
return
lazy
.
DownloadUIHelper
.
getPrompter
(
)
.
confirmLaunchExecutable
(
path
)
;
}
launchFile
(
file
mimeInfo
)
{
if
(
mimeInfo
)
{
mimeInfo
.
launchWithFile
(
file
)
;
}
else
{
file
.
launch
(
)
;
}
}
async
showContainingDirectory
(
aFilePath
)
{
let
file
=
new
lazy
.
FileUtils
.
File
(
aFilePath
)
;
try
{
file
.
reveal
(
)
;
return
;
}
catch
(
ex
)
{
}
let
parent
=
file
.
parent
;
if
(
!
parent
)
{
throw
new
Error
(
"
Unexpected
reference
to
a
top
-
level
directory
instead
of
a
file
"
)
;
}
try
{
parent
.
launch
(
)
;
return
;
}
catch
(
ex
)
{
}
lazy
.
gExternalProtocolService
.
loadURI
(
lazy
.
NetUtil
.
newURI
(
parent
)
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
}
_createDownloadsDirectory
(
aName
)
{
let
directoryPath
=
PathUtils
.
join
(
this
.
_getDirectory
(
aName
)
lazy
.
DownloadUIHelper
.
strings
.
downloadsFolder
)
;
return
IOUtils
.
makeDirectory
(
directoryPath
{
createAncestors
:
false
}
)
.
then
(
(
)
=
>
directoryPath
)
;
}
_getDirectory
(
name
)
{
return
Services
.
dirsvc
.
get
(
name
Ci
.
nsIFile
)
.
path
;
}
_initializeDownloadSpamProtection
(
)
{
this
.
downloadSpamProtection
=
new
lazy
.
DownloadSpamProtection
(
)
;
}
addListObservers
(
aList
aIsPrivate
)
{
DownloadObserver
.
registerView
(
aList
aIsPrivate
)
;
if
(
!
DownloadObserver
.
observersAdded
)
{
DownloadObserver
.
observersAdded
=
true
;
for
(
let
topic
of
kObserverTopics
)
{
Services
.
obs
.
addObserver
(
DownloadObserver
topic
)
;
}
}
return
Promise
.
resolve
(
)
;
}
forceSave
(
)
{
if
(
this
.
_store
)
{
return
this
.
_store
.
save
(
)
;
}
return
Promise
.
resolve
(
)
;
}
}
;
var
DownloadObserver
=
{
observersAdded
:
false
_wakeTimer
:
null
_publicInProgressDownloads
:
new
Set
(
)
_privateInProgressDownloads
:
new
Set
(
)
_canceledOfflineDownloads
:
new
Set
(
)
registerView
:
function
DO_registerView
(
aList
aIsPrivate
)
{
let
downloadsSet
=
aIsPrivate
?
this
.
_privateInProgressDownloads
:
this
.
_publicInProgressDownloads
;
let
downloadsView
=
{
onDownloadAdded
:
aDownload
=
>
{
if
(
!
aDownload
.
stopped
)
{
downloadsSet
.
add
(
aDownload
)
;
}
}
onDownloadChanged
:
aDownload
=
>
{
if
(
aDownload
.
stopped
)
{
downloadsSet
.
delete
(
aDownload
)
;
}
else
{
downloadsSet
.
add
(
aDownload
)
;
}
}
onDownloadRemoved
:
aDownload
=
>
{
downloadsSet
.
delete
(
aDownload
)
;
this
.
_canceledOfflineDownloads
.
delete
(
aDownload
)
;
}
}
;
aList
.
addView
(
downloadsView
)
.
catch
(
Cu
.
reportError
)
;
}
_confirmCancelDownloads
:
function
DO_confirmCancelDownload
(
aCancel
aDownloadsCount
aPromptType
)
{
if
(
lazy
.
gCombinedDownloadIntegration
.
_testPromptDownloads
)
{
lazy
.
gCombinedDownloadIntegration
.
_testPromptDownloads
=
aDownloadsCount
;
return
;
}
if
(
!
aDownloadsCount
)
{
return
;
}
if
(
aCancel
instanceof
Ci
.
nsISupportsPRBool
&
&
aCancel
.
data
)
{
return
;
}
let
prompter
=
lazy
.
DownloadUIHelper
.
getPrompter
(
)
;
aCancel
.
data
=
prompter
.
confirmCancelDownloads
(
aDownloadsCount
prompter
[
aPromptType
]
)
;
}
_resumeOfflineDownloads
:
function
DO_resumeOfflineDownloads
(
)
{
this
.
_wakeTimer
=
null
;
for
(
let
download
of
this
.
_canceledOfflineDownloads
)
{
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
this
.
_canceledOfflineDownloads
.
clear
(
)
;
}
observe
:
function
DO_observe
(
aSubject
aTopic
aData
)
{
let
downloadsCount
;
switch
(
aTopic
)
{
case
"
quit
-
application
-
requested
"
:
downloadsCount
=
this
.
_publicInProgressDownloads
.
size
+
this
.
_privateInProgressDownloads
.
size
;
this
.
_confirmCancelDownloads
(
aSubject
downloadsCount
"
ON_QUIT
"
)
;
break
;
case
"
offline
-
requested
"
:
downloadsCount
=
this
.
_publicInProgressDownloads
.
size
+
this
.
_privateInProgressDownloads
.
size
;
this
.
_confirmCancelDownloads
(
aSubject
downloadsCount
"
ON_OFFLINE
"
)
;
break
;
case
"
last
-
pb
-
context
-
exiting
"
:
downloadsCount
=
this
.
_privateInProgressDownloads
.
size
;
this
.
_confirmCancelDownloads
(
aSubject
downloadsCount
"
ON_LEAVE_PRIVATE_BROWSING
"
)
;
break
;
case
"
last
-
pb
-
context
-
exited
"
:
let
promise
=
(
async
function
(
)
{
let
list
=
await
Downloads
.
getList
(
Downloads
.
PRIVATE
)
;
let
downloads
=
await
list
.
getAll
(
)
;
for
(
let
download
of
downloads
)
{
list
.
remove
(
download
)
.
catch
(
Cu
.
reportError
)
;
download
.
finalize
(
true
)
.
catch
(
Cu
.
reportError
)
;
}
}
)
(
)
;
if
(
lazy
.
gCombinedDownloadIntegration
.
_testResolveClearPrivateList
)
{
lazy
.
gCombinedDownloadIntegration
.
_testResolveClearPrivateList
(
promise
)
;
}
else
{
promise
.
catch
(
ex
=
>
Cu
.
reportError
(
ex
)
)
;
}
break
;
case
"
sleep_notification
"
:
case
"
suspend_process_notification
"
:
case
"
network
:
offline
-
about
-
to
-
go
-
offline
"
:
for
(
let
download
of
this
.
_publicInProgressDownloads
)
{
download
.
cancel
(
)
;
this
.
_canceledOfflineDownloads
.
add
(
download
)
;
}
for
(
let
download
of
this
.
_privateInProgressDownloads
)
{
download
.
cancel
(
)
;
this
.
_canceledOfflineDownloads
.
add
(
download
)
;
}
break
;
case
"
wake_notification
"
:
case
"
resume_process_notification
"
:
let
wakeDelay
=
Services
.
prefs
.
getIntPref
(
"
browser
.
download
.
manager
.
resumeOnWakeDelay
"
10000
)
;
if
(
wakeDelay
>
=
0
)
{
this
.
_wakeTimer
=
new
Timer
(
this
.
_resumeOfflineDownloads
.
bind
(
this
)
wakeDelay
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
break
;
case
"
network
:
offline
-
status
-
changed
"
:
if
(
aData
=
=
"
online
"
)
{
this
.
_resumeOfflineDownloads
(
)
;
}
break
;
case
"
xpcom
-
will
-
shutdown
"
:
for
(
let
topic
of
kObserverTopics
)
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
}
break
;
case
"
blocked
-
automatic
-
download
"
:
if
(
AppConstants
.
MOZ_BUILD_APP
=
=
"
browser
"
&
&
!
DownloadIntegration
.
downloadSpamProtection
)
{
DownloadIntegration
.
_initializeDownloadSpamProtection
(
)
;
}
DownloadIntegration
.
downloadSpamProtection
.
update
(
aData
)
;
break
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
}
;
var
DownloadHistoryObserver
=
function
(
aList
)
{
this
.
_list
=
aList
;
const
placesObserver
=
new
PlacesWeakCallbackWrapper
(
this
.
handlePlacesEvents
.
bind
(
this
)
)
;
PlacesObservers
.
addListener
(
[
"
history
-
cleared
"
"
page
-
removed
"
]
placesObserver
)
;
}
;
DownloadHistoryObserver
.
prototype
=
{
_list
:
null
handlePlacesEvents
(
events
)
{
for
(
const
event
of
events
)
{
switch
(
event
.
type
)
{
case
"
history
-
cleared
"
:
{
this
.
_list
.
removeFinished
(
)
;
break
;
}
case
"
page
-
removed
"
:
{
if
(
event
.
isRemovedFromStore
)
{
this
.
_list
.
removeFinished
(
download
=
>
event
.
url
=
=
=
download
.
source
.
url
)
;
}
break
;
}
}
}
}
}
;
var
DownloadAutoSaveView
=
function
(
aList
aStore
)
{
this
.
_list
=
aList
;
this
.
_store
=
aStore
;
this
.
_downloadsMap
=
new
Map
(
)
;
this
.
_writer
=
new
lazy
.
DeferredTask
(
(
)
=
>
this
.
_store
.
save
(
)
kSaveDelayMs
)
;
lazy
.
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
DownloadAutoSaveView
:
writing
data
"
(
)
=
>
this
.
_writer
.
finalize
(
)
)
;
}
;
DownloadAutoSaveView
.
prototype
=
{
_list
:
null
_store
:
null
_initialized
:
false
initialize
(
)
{
return
this
.
_list
.
addView
(
this
)
.
then
(
(
)
=
>
(
this
.
_initialized
=
true
)
)
;
}
_downloadsMap
:
null
_writer
:
null
saveSoon
(
)
{
this
.
_writer
.
arm
(
)
;
}
onDownloadAdded
(
aDownload
)
{
if
(
lazy
.
gCombinedDownloadIntegration
.
shouldPersistDownload
(
aDownload
)
)
{
this
.
_downloadsMap
.
set
(
aDownload
aDownload
.
getSerializationHash
(
)
)
;
if
(
this
.
_initialized
)
{
this
.
saveSoon
(
)
;
}
}
}
onDownloadChanged
(
aDownload
)
{
if
(
!
lazy
.
gCombinedDownloadIntegration
.
shouldPersistDownload
(
aDownload
)
)
{
if
(
this
.
_downloadsMap
.
has
(
aDownload
)
)
{
this
.
_downloadsMap
.
delete
(
aDownload
)
;
this
.
saveSoon
(
)
;
}
return
;
}
let
hash
=
aDownload
.
getSerializationHash
(
)
;
if
(
this
.
_downloadsMap
.
get
(
aDownload
)
!
=
hash
)
{
this
.
_downloadsMap
.
set
(
aDownload
hash
)
;
this
.
saveSoon
(
)
;
}
}
onDownloadRemoved
(
aDownload
)
{
if
(
this
.
_downloadsMap
.
has
(
aDownload
)
)
{
this
.
_downloadsMap
.
delete
(
aDownload
)
;
this
.
saveSoon
(
)
;
}
}
}
;
