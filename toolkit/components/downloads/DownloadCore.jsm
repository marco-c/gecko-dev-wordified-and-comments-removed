"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Download
"
"
DownloadSource
"
"
DownloadTarget
"
"
DownloadError
"
"
DownloadSaver
"
"
DownloadCopySaver
"
"
DownloadLegacySaver
"
]
;
const
{
Integration
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Integration
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
DownloadHistory
:
"
resource
:
/
/
gre
/
modules
/
DownloadHistory
.
jsm
"
DownloadPaths
:
"
resource
:
/
/
gre
/
modules
/
DownloadPaths
.
jsm
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gExternalAppLauncher
"
"
mozilla
.
org
/
uriloader
/
external
-
helper
-
app
-
service
;
1
"
Ci
.
nsPIExternalAppLauncher
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gExternalHelperAppService
"
"
mozilla
.
org
/
uriloader
/
external
-
helper
-
app
-
service
;
1
"
Ci
.
nsIExternalHelperAppService
)
;
Integration
.
downloads
.
defineModuleGetter
(
this
"
DownloadIntegration
"
"
resource
:
/
/
gre
/
modules
/
DownloadIntegration
.
jsm
"
)
;
const
BackgroundFileSaverStreamListener
=
Components
.
Constructor
(
"
mozilla
.
org
/
network
/
background
-
file
-
saver
;
1
?
mode
=
streamlistener
"
"
nsIBackgroundFileSaver
"
)
;
function
isString
(
aValue
)
{
return
(
typeof
aValue
=
=
"
string
"
|
|
(
typeof
aValue
=
=
"
object
"
&
&
"
charAt
"
in
aValue
)
)
;
}
function
serializeUnknownProperties
(
aObject
aSerializable
)
{
if
(
aObject
.
_unknownProperties
)
{
for
(
let
property
in
aObject
.
_unknownProperties
)
{
aSerializable
[
property
]
=
aObject
.
_unknownProperties
[
property
]
;
}
}
}
function
deserializeUnknownProperties
(
aObject
aSerializable
aFilterFn
)
{
for
(
let
property
in
aSerializable
)
{
if
(
aFilterFn
(
property
)
)
{
if
(
!
aObject
.
_unknownProperties
)
{
aObject
.
_unknownProperties
=
{
}
;
}
aObject
.
_unknownProperties
[
property
]
=
aSerializable
[
property
]
;
}
}
}
async
function
isPlaceholder
(
path
)
{
try
{
if
(
(
await
IOUtils
.
stat
(
path
)
)
.
size
=
=
0
)
{
return
true
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
return
false
;
}
const
kProgressUpdateIntervalMs
=
400
;
var
Download
=
function
(
)
{
this
.
_deferSucceeded
=
PromiseUtils
.
defer
(
)
;
}
;
Download
.
prototype
=
{
source
:
null
target
:
null
saver
:
null
stopped
:
true
succeeded
:
false
canceled
:
false
error
:
null
startTime
:
null
hasProgress
:
false
progress
:
0
totalBytes
:
0
currentBytes
:
0
speed
:
0
hasPartialData
:
false
hasBlockedData
:
false
onchange
:
null
launchWhenSucceeded
:
false
contentType
:
null
launcherPath
:
null
_notifyChange
:
function
D_notifyChange
(
)
{
try
{
if
(
this
.
onchange
)
{
this
.
onchange
(
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
_currentAttempt
:
null
_launchedFromPanel
:
false
start
:
function
D_start
(
)
{
if
(
this
.
succeeded
)
{
return
Promise
.
resolve
(
)
;
}
if
(
this
.
_currentAttempt
)
{
return
this
.
_currentAttempt
;
}
if
(
this
.
_finalized
)
{
return
Promise
.
reject
(
new
DownloadError
(
{
message
:
"
Cannot
start
after
finalization
.
"
}
)
)
;
}
if
(
this
.
error
&
&
this
.
error
.
becauseBlockedByReputationCheck
)
{
return
Promise
.
reject
(
new
DownloadError
(
{
message
:
"
Cannot
start
after
being
blocked
by
a
reputation
check
.
"
}
)
)
;
}
this
.
stopped
=
false
;
this
.
canceled
=
false
;
this
.
error
=
null
;
this
.
hasProgress
=
false
;
this
.
hasBlockedData
=
false
;
this
.
progress
=
0
;
this
.
totalBytes
=
0
;
this
.
currentBytes
=
0
;
this
.
startTime
=
new
Date
(
)
;
let
deferAttempt
=
PromiseUtils
.
defer
(
)
;
let
currentAttempt
=
deferAttempt
.
promise
;
this
.
_currentAttempt
=
currentAttempt
;
this
.
_lastProgressTimeMs
=
0
;
function
DS_setProgressBytes
(
aCurrentBytes
aTotalBytes
aHasPartialData
)
{
if
(
this
.
_currentAttempt
=
=
currentAttempt
)
{
this
.
_setBytes
(
aCurrentBytes
aTotalBytes
aHasPartialData
)
;
}
}
function
DS_setProperties
(
aOptions
)
{
if
(
this
.
_currentAttempt
!
=
currentAttempt
)
{
return
;
}
let
changeMade
=
false
;
for
(
let
property
of
[
"
contentType
"
"
progress
"
"
hasPartialData
"
"
hasBlockedData
"
]
)
{
if
(
property
in
aOptions
&
&
this
[
property
]
!
=
aOptions
[
property
]
)
{
this
[
property
]
=
aOptions
[
property
]
;
changeMade
=
true
;
}
}
if
(
changeMade
)
{
this
.
_notifyChange
(
)
;
}
}
deferAttempt
.
resolve
(
(
async
(
)
=
>
{
if
(
this
.
_promiseCanceled
)
{
await
this
.
_promiseCanceled
;
}
if
(
this
.
_promiseRemovePartialData
)
{
try
{
await
this
.
_promiseRemovePartialData
;
}
catch
(
ex
)
{
}
}
if
(
this
.
succeeded
)
{
return
;
}
try
{
if
(
this
.
downloadingToSameFile
(
)
)
{
throw
new
DownloadError
(
{
message
:
"
Can
'
t
overwrite
the
source
file
.
"
becauseTargetFailed
:
true
}
)
;
}
if
(
await
DownloadIntegration
.
shouldBlockForParentalControls
(
this
)
)
{
throw
new
DownloadError
(
{
becauseBlockedByParentalControls
:
true
}
)
;
}
if
(
await
DownloadIntegration
.
shouldBlockForRuntimePermissions
(
)
)
{
throw
new
DownloadError
(
{
becauseBlockedByRuntimePermissions
:
true
}
)
;
}
if
(
this
.
_promiseCanceled
)
{
throw
new
Error
(
undefined
)
;
}
this
.
_saverExecuting
=
true
;
try
{
await
this
.
saver
.
execute
(
DS_setProgressBytes
.
bind
(
this
)
DS_setProperties
.
bind
(
this
)
)
;
}
catch
(
ex
)
{
if
(
!
this
.
hasPartialData
&
&
!
this
.
hasBlockedData
)
{
await
this
.
saver
.
removeData
(
true
)
;
}
throw
ex
;
}
await
this
.
target
.
refresh
(
)
;
if
(
this
.
_promiseCanceled
)
{
await
this
.
saver
.
removeData
(
true
)
;
throw
new
DownloadError
(
)
;
}
this
.
progress
=
100
;
this
.
succeeded
=
true
;
this
.
hasPartialData
=
false
;
}
catch
(
originalEx
)
{
let
ex
=
originalEx
;
if
(
this
.
_promiseCanceled
)
{
throw
new
DownloadError
(
{
message
:
"
Download
canceled
.
"
}
)
;
}
if
(
this
.
_blockedByParentalControls
)
{
ex
=
new
DownloadError
(
{
becauseBlockedByParentalControls
:
true
}
)
;
}
if
(
this
.
_currentAttempt
=
=
currentAttempt
|
|
!
this
.
_currentAttempt
)
{
if
(
!
(
ex
instanceof
DownloadError
)
)
{
let
properties
=
{
innerException
:
ex
}
;
if
(
ex
.
message
)
{
properties
.
message
=
ex
.
message
;
}
ex
=
new
DownloadError
(
properties
)
;
}
this
.
error
=
ex
;
}
throw
ex
;
}
finally
{
this
.
_saverExecuting
=
false
;
this
.
_promiseCanceled
=
null
;
if
(
this
.
_currentAttempt
=
=
currentAttempt
|
|
!
this
.
_currentAttempt
)
{
this
.
_currentAttempt
=
null
;
this
.
stopped
=
true
;
this
.
speed
=
0
;
this
.
_notifyChange
(
)
;
if
(
this
.
succeeded
)
{
await
this
.
_succeed
(
)
;
}
}
}
}
)
(
)
)
;
this
.
_notifyChange
(
)
;
return
currentAttempt
;
}
async
_succeed
(
)
{
await
DownloadIntegration
.
downloadDone
(
this
)
;
this
.
_deferSucceeded
.
resolve
(
)
;
if
(
this
.
launchWhenSucceeded
)
{
this
.
launch
(
)
.
catch
(
Cu
.
reportError
)
;
if
(
this
.
source
.
isPrivate
)
{
gExternalAppLauncher
.
deleteTemporaryPrivateFileWhenPossible
(
new
FileUtils
.
File
(
this
.
target
.
path
)
)
;
}
else
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
helperApps
.
deleteTempFileOnExit
"
)
&
&
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
download
.
improvements_to_download_panel
"
)
)
{
gExternalAppLauncher
.
deleteTemporaryFileOnExit
(
new
FileUtils
.
File
(
this
.
target
.
path
)
)
;
}
}
}
_promiseUnblock
:
null
_promiseConfirmBlock
:
null
unblock
(
)
{
if
(
this
.
_promiseUnblock
)
{
return
this
.
_promiseUnblock
;
}
if
(
this
.
_promiseConfirmBlock
)
{
return
Promise
.
reject
(
new
Error
(
"
Download
block
has
been
confirmed
cannot
unblock
.
"
)
)
;
}
if
(
this
.
error
?
.
becauseBlockedByReputationCheck
)
{
Services
.
telemetry
.
getKeyedHistogramById
(
"
DOWNLOADS_USER_ACTION_ON_BLOCKED_DOWNLOAD
"
)
.
add
(
this
.
error
.
reputationCheckVerdict
2
)
;
}
if
(
this
.
error
?
.
reputationCheckVerdict
=
=
DownloadError
.
BLOCK_VERDICT_INSECURE
)
{
this
.
error
=
null
;
this
.
succeeded
=
false
;
this
.
hasBlockedData
=
false
;
delete
this
.
_unknownProperties
?
.
errorObj
;
this
.
start
(
)
.
catch
(
err
=
>
{
if
(
err
.
becauseTargetFailed
)
{
let
uniquePath
=
DownloadPaths
.
createNiceUniqueFile
(
new
FileUtils
.
File
(
this
.
target
.
path
)
)
.
path
;
this
.
target
.
path
=
uniquePath
;
return
this
.
start
(
)
;
}
return
Promise
.
reject
(
err
)
;
}
)
.
catch
(
err
=
>
{
this
.
error
=
err
;
this
.
_notifyChange
(
)
;
}
)
;
this
.
_notifyChange
(
)
;
this
.
_promiseUnblock
=
DownloadIntegration
.
downloadDone
(
this
)
;
return
this
.
_promiseUnblock
;
}
if
(
!
this
.
hasBlockedData
)
{
return
Promise
.
reject
(
new
Error
(
"
unblock
may
only
be
called
on
Downloads
with
blocked
data
.
"
)
)
;
}
this
.
_promiseUnblock
=
(
async
(
)
=
>
{
try
{
await
IOUtils
.
move
(
this
.
target
.
partFilePath
this
.
target
.
path
)
;
await
this
.
target
.
refresh
(
)
;
}
catch
(
ex
)
{
await
this
.
refresh
(
)
;
this
.
_promiseUnblock
=
null
;
throw
ex
;
}
this
.
succeeded
=
true
;
this
.
hasBlockedData
=
false
;
this
.
_notifyChange
(
)
;
await
this
.
_succeed
(
)
;
}
)
(
)
;
return
this
.
_promiseUnblock
;
}
confirmBlock
(
)
{
if
(
this
.
_promiseConfirmBlock
)
{
return
this
.
_promiseConfirmBlock
;
}
if
(
this
.
_promiseUnblock
)
{
return
Promise
.
reject
(
new
Error
(
"
Download
is
being
unblocked
cannot
confirmBlock
.
"
)
)
;
}
if
(
this
.
error
?
.
becauseBlockedByReputationCheck
)
{
Services
.
telemetry
.
getKeyedHistogramById
(
"
DOWNLOADS_USER_ACTION_ON_BLOCKED_DOWNLOAD
"
)
.
add
(
this
.
error
.
reputationCheckVerdict
1
)
;
}
if
(
!
this
.
hasBlockedData
)
{
return
Promise
.
reject
(
new
Error
(
"
confirmBlock
may
only
be
called
on
Downloads
with
blocked
data
.
"
)
)
;
}
this
.
_promiseConfirmBlock
=
(
async
(
)
=
>
{
await
this
.
saver
.
removeData
(
)
;
this
.
hasBlockedData
=
false
;
this
.
_notifyChange
(
)
;
}
)
(
)
;
return
this
.
_promiseConfirmBlock
;
}
launch
(
options
=
{
}
)
{
if
(
!
this
.
succeeded
)
{
return
Promise
.
reject
(
new
Error
(
"
launch
can
only
be
called
if
the
download
succeeded
"
)
)
;
}
if
(
this
.
_launchedFromPanel
)
{
Services
.
telemetry
.
scalarAdd
(
"
downloads
.
file_opened
"
1
)
;
}
return
DownloadIntegration
.
launchDownload
(
this
options
)
;
}
showContainingDirectory
:
function
D_showContainingDirectory
(
)
{
return
DownloadIntegration
.
showContainingDirectory
(
this
.
target
.
path
)
;
}
_promiseCanceled
:
null
_saverExecuting
:
false
cancel
:
function
D_cancel
(
)
{
if
(
this
.
stopped
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_promiseCanceled
)
{
this
.
_promiseCanceled
=
new
Promise
(
resolve
=
>
{
this
.
_currentAttempt
.
then
(
resolve
resolve
)
;
}
)
;
this
.
_currentAttempt
=
null
;
this
.
canceled
=
true
;
this
.
_notifyChange
(
)
;
if
(
this
.
_saverExecuting
)
{
this
.
saver
.
cancel
(
)
;
}
}
return
this
.
_promiseCanceled
;
}
tryToKeepPartialData
:
false
_promiseRemovePartialData
:
null
removePartialData
(
)
{
if
(
!
this
.
canceled
&
&
!
this
.
error
)
{
return
Promise
.
resolve
(
)
;
}
if
(
!
this
.
_promiseRemovePartialData
)
{
this
.
_promiseRemovePartialData
=
(
async
(
)
=
>
{
try
{
if
(
this
.
_promiseCanceled
)
{
await
this
.
_promiseCanceled
;
}
await
this
.
saver
.
removeData
(
)
;
if
(
this
.
currentBytes
!
=
0
|
|
this
.
hasPartialData
)
{
this
.
currentBytes
=
0
;
this
.
hasPartialData
=
false
;
this
.
_notifyChange
(
)
;
}
}
finally
{
this
.
_promiseRemovePartialData
=
null
;
}
}
)
(
)
;
}
return
this
.
_promiseRemovePartialData
;
}
downloadingToSameFile
(
)
{
if
(
!
this
.
source
.
url
|
|
!
this
.
source
.
url
.
startsWith
(
"
file
:
"
)
)
{
return
false
;
}
try
{
let
sourceUri
=
NetUtil
.
newURI
(
this
.
source
.
url
)
;
let
targetUri
=
NetUtil
.
newURI
(
new
FileUtils
.
File
(
this
.
target
.
path
)
)
;
return
sourceUri
.
equals
(
targetUri
)
;
}
catch
(
ex
)
{
return
false
;
}
}
_deferSucceeded
:
null
whenSucceeded
:
function
D_whenSucceeded
(
)
{
return
this
.
_deferSucceeded
.
promise
;
}
refresh
(
)
{
return
(
async
(
)
=
>
{
if
(
!
this
.
stopped
|
|
this
.
_finalized
)
{
return
;
}
if
(
this
.
succeeded
)
{
let
oldExists
=
this
.
target
.
exists
;
let
oldSize
=
this
.
target
.
size
;
await
this
.
target
.
refresh
(
)
;
if
(
oldExists
!
=
this
.
target
.
exists
|
|
oldSize
!
=
this
.
target
.
size
)
{
this
.
_notifyChange
(
)
;
}
return
;
}
if
(
(
this
.
hasPartialData
|
|
this
.
hasBlockedData
)
&
&
this
.
target
.
partFilePath
)
{
try
{
let
stat
=
await
IOUtils
.
stat
(
this
.
target
.
partFilePath
)
;
if
(
!
this
.
stopped
|
|
this
.
_finalized
)
{
return
;
}
this
.
currentBytes
=
stat
.
size
;
if
(
this
.
totalBytes
>
0
)
{
this
.
hasProgress
=
true
;
this
.
progress
=
Math
.
floor
(
(
this
.
currentBytes
/
this
.
totalBytes
)
*
100
)
;
}
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
"
NotFoundError
"
)
{
throw
ex
;
}
if
(
!
this
.
stopped
|
|
this
.
_finalized
)
{
return
;
}
if
(
this
.
error
.
reputationCheckVerdict
=
=
DownloadError
.
BLOCK_VERDICT_INSECURE
)
{
return
;
}
this
.
hasBlockedData
=
false
;
this
.
hasPartialData
=
false
;
}
this
.
_notifyChange
(
)
;
}
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
_finalized
:
false
_finalizeExecuted
:
false
finalize
(
aRemovePartialData
)
{
this
.
_finalized
=
true
;
let
promise
;
if
(
aRemovePartialData
)
{
this
.
cancel
(
)
;
promise
=
this
.
removePartialData
(
)
;
}
else
{
promise
=
this
.
cancel
(
)
;
}
promise
.
then
(
(
)
=
>
{
this
.
_finalizeExecuted
=
true
;
}
)
;
return
promise
;
}
_lastProgressTimeMs
:
0
_setBytes
:
function
D_setBytes
(
aCurrentBytes
aTotalBytes
aHasPartialData
)
{
let
changeMade
=
this
.
hasPartialData
!
=
aHasPartialData
;
this
.
hasPartialData
=
aHasPartialData
;
if
(
aTotalBytes
!
=
-
1
&
&
(
!
this
.
hasProgress
|
|
this
.
totalBytes
!
=
aTotalBytes
)
)
{
this
.
hasProgress
=
true
;
this
.
totalBytes
=
aTotalBytes
;
changeMade
=
true
;
}
let
currentTimeMs
=
Date
.
now
(
)
;
let
intervalMs
=
currentTimeMs
-
this
.
_lastProgressTimeMs
;
if
(
intervalMs
>
=
kProgressUpdateIntervalMs
)
{
if
(
this
.
_lastProgressTimeMs
!
=
0
)
{
let
rawSpeed
=
(
(
aCurrentBytes
-
this
.
currentBytes
)
/
intervalMs
)
*
1000
;
if
(
this
.
speed
=
=
0
)
{
this
.
speed
=
rawSpeed
;
}
else
{
this
.
speed
=
rawSpeed
*
0
.
1
+
this
.
speed
*
0
.
9
;
}
}
if
(
aCurrentBytes
>
0
)
{
this
.
_lastProgressTimeMs
=
currentTimeMs
;
this
.
currentBytes
=
aCurrentBytes
;
if
(
this
.
totalBytes
>
0
)
{
this
.
progress
=
Math
.
floor
(
(
this
.
currentBytes
/
this
.
totalBytes
)
*
100
)
;
}
changeMade
=
true
;
}
if
(
this
.
hasProgress
&
&
this
.
target
&
&
!
this
.
target
.
partFileExists
)
{
this
.
target
.
refreshPartFileState
(
)
;
}
}
if
(
changeMade
)
{
this
.
_notifyChange
(
)
;
}
}
toSerializable
(
)
{
let
serializable
=
{
source
:
this
.
source
.
toSerializable
(
)
target
:
this
.
target
.
toSerializable
(
)
}
;
let
saver
=
this
.
saver
.
toSerializable
(
)
;
if
(
!
serializable
.
source
|
|
!
saver
)
{
return
null
;
}
if
(
saver
!
=
=
"
copy
"
)
{
serializable
.
saver
=
saver
;
}
if
(
this
.
error
)
{
serializable
.
errorObj
=
this
.
error
.
toSerializable
(
)
;
}
if
(
this
.
startTime
)
{
serializable
.
startTime
=
this
.
startTime
.
toJSON
(
)
;
}
for
(
let
property
of
kPlainSerializableDownloadProperties
)
{
if
(
this
[
property
]
)
{
serializable
[
property
]
=
this
[
property
]
;
}
}
serializeUnknownProperties
(
this
serializable
)
;
return
serializable
;
}
getSerializationHash
(
)
{
return
(
this
.
stopped
+
"
"
+
this
.
totalBytes
+
"
"
+
this
.
hasPartialData
+
"
"
+
this
.
contentType
)
;
}
}
;
const
kPlainSerializableDownloadProperties
=
[
"
succeeded
"
"
canceled
"
"
totalBytes
"
"
hasPartialData
"
"
hasBlockedData
"
"
tryToKeepPartialData
"
"
launcherPath
"
"
launchWhenSucceeded
"
"
contentType
"
"
handleInternally
"
]
;
Download
.
fromSerializable
=
function
(
aSerializable
)
{
let
download
=
new
Download
(
)
;
if
(
aSerializable
.
source
instanceof
DownloadSource
)
{
download
.
source
=
aSerializable
.
source
;
}
else
{
download
.
source
=
DownloadSource
.
fromSerializable
(
aSerializable
.
source
)
;
}
if
(
aSerializable
.
target
instanceof
DownloadTarget
)
{
download
.
target
=
aSerializable
.
target
;
}
else
{
download
.
target
=
DownloadTarget
.
fromSerializable
(
aSerializable
.
target
)
;
}
if
(
"
saver
"
in
aSerializable
)
{
download
.
saver
=
DownloadSaver
.
fromSerializable
(
aSerializable
.
saver
)
;
}
else
{
download
.
saver
=
DownloadSaver
.
fromSerializable
(
"
copy
"
)
;
}
download
.
saver
.
download
=
download
;
if
(
"
startTime
"
in
aSerializable
)
{
let
time
=
aSerializable
.
startTime
.
getTime
?
aSerializable
.
startTime
.
getTime
(
)
:
aSerializable
.
startTime
;
download
.
startTime
=
new
Date
(
time
)
;
}
if
(
"
errorObj
"
in
aSerializable
)
{
download
.
error
=
DownloadError
.
fromSerializable
(
aSerializable
.
errorObj
)
;
}
else
if
(
"
error
"
in
aSerializable
)
{
download
.
error
=
aSerializable
.
error
;
}
for
(
let
property
of
kPlainSerializableDownloadProperties
)
{
if
(
property
in
aSerializable
)
{
download
[
property
]
=
aSerializable
[
property
]
;
}
}
deserializeUnknownProperties
(
download
aSerializable
property
=
>
!
kPlainSerializableDownloadProperties
.
includes
(
property
)
&
&
property
!
=
"
startTime
"
&
&
property
!
=
"
source
"
&
&
property
!
=
"
target
"
&
&
property
!
=
"
error
"
&
&
property
!
=
"
saver
"
)
;
return
download
;
}
;
var
DownloadSource
=
function
(
)
{
}
;
DownloadSource
.
prototype
=
{
url
:
null
isPrivate
:
false
referrerInfo
:
null
adjustChannel
:
null
allowHttpStatus
:
null
loadingPrincipal
:
null
cookieJarSettings
:
null
toSerializable
(
)
{
if
(
this
.
adjustChannel
)
{
return
null
;
}
if
(
this
.
allowHttpStatus
)
{
return
null
;
}
let
serializable
=
{
url
:
this
.
url
}
;
if
(
this
.
isPrivate
)
{
serializable
.
isPrivate
=
true
;
}
if
(
this
.
referrerInfo
&
&
isString
(
this
.
referrerInfo
)
)
{
serializable
.
referrerInfo
=
this
.
referrerInfo
;
}
else
if
(
this
.
referrerInfo
)
{
serializable
.
referrerInfo
=
E10SUtils
.
serializeReferrerInfo
(
this
.
referrerInfo
)
;
}
if
(
this
.
loadingPrincipal
)
{
serializable
.
loadingPrincipal
=
isString
(
this
.
loadingPrincipal
)
?
this
.
loadingPrincipal
:
E10SUtils
.
serializePrincipal
(
this
.
loadingPrincipal
)
;
}
if
(
this
.
cookieJarSettings
)
{
serializable
.
cookieJarSettings
=
isString
(
this
.
cookieJarSettings
)
?
this
.
cookieJarSettings
:
E10SUtils
.
serializeCookieJarSettings
(
this
.
cookieJarSettings
)
;
}
serializeUnknownProperties
(
this
serializable
)
;
if
(
Object
.
keys
(
serializable
)
.
length
=
=
=
1
)
{
return
this
.
url
;
}
return
serializable
;
}
}
;
DownloadSource
.
fromSerializable
=
function
(
aSerializable
)
{
let
source
=
new
DownloadSource
(
)
;
if
(
isString
(
aSerializable
)
)
{
source
.
url
=
aSerializable
.
toString
(
)
;
}
else
if
(
aSerializable
instanceof
Ci
.
nsIURI
)
{
source
.
url
=
aSerializable
.
spec
;
}
else
{
source
.
url
=
aSerializable
.
url
.
toString
(
)
;
for
(
let
propName
of
[
"
isPrivate
"
"
userContextId
"
"
browsingContextId
"
]
)
{
if
(
propName
in
aSerializable
)
{
source
[
propName
]
=
aSerializable
[
propName
]
;
}
}
if
(
"
referrerInfo
"
in
aSerializable
)
{
if
(
aSerializable
.
referrerInfo
instanceof
Ci
.
nsIReferrerInfo
)
{
source
.
referrerInfo
=
aSerializable
.
referrerInfo
;
}
else
{
source
.
referrerInfo
=
E10SUtils
.
deserializeReferrerInfo
(
aSerializable
.
referrerInfo
)
;
}
}
if
(
"
loadingPrincipal
"
in
aSerializable
)
{
if
(
aSerializable
.
loadingPrincipal
instanceof
Ci
.
nsIPrincipal
)
{
source
.
loadingPrincipal
=
aSerializable
.
loadingPrincipal
;
}
else
{
source
.
loadingPrincipal
=
E10SUtils
.
deserializePrincipal
(
aSerializable
.
loadingPrincipal
)
;
}
}
if
(
"
adjustChannel
"
in
aSerializable
)
{
source
.
adjustChannel
=
aSerializable
.
adjustChannel
;
}
if
(
"
allowHttpStatus
"
in
aSerializable
)
{
source
.
allowHttpStatus
=
aSerializable
.
allowHttpStatus
;
}
if
(
"
cookieJarSettings
"
in
aSerializable
)
{
if
(
aSerializable
.
cookieJarSettings
instanceof
Ci
.
nsICookieJarSettings
)
{
source
.
cookieJarSettings
=
aSerializable
.
cookieJarSettings
;
}
else
{
source
.
cookieJarSettings
=
E10SUtils
.
deserializeCookieJarSettings
(
aSerializable
.
cookieJarSettings
)
;
}
}
deserializeUnknownProperties
(
source
aSerializable
property
=
>
property
!
=
"
url
"
&
&
property
!
=
"
isPrivate
"
&
&
property
!
=
"
referrerInfo
"
&
&
property
!
=
"
cookieJarSettings
"
)
;
}
return
source
;
}
;
var
DownloadTarget
=
function
(
)
{
}
;
DownloadTarget
.
prototype
=
{
path
:
null
partFilePath
:
null
exists
:
false
partFileExists
:
false
size
:
0
async
refresh
(
)
{
try
{
this
.
size
=
(
await
IOUtils
.
stat
(
this
.
path
)
)
.
size
;
this
.
exists
=
true
;
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
"
NotFoundError
"
)
{
Cu
.
reportError
(
ex
)
;
}
this
.
exists
=
false
;
}
this
.
refreshPartFileState
(
)
;
}
async
refreshPartFileState
(
)
{
if
(
!
this
.
partFilePath
)
{
this
.
partFileExists
=
false
;
return
;
}
try
{
this
.
partFileExists
=
(
await
IOUtils
.
stat
(
this
.
partFilePath
)
)
.
size
>
0
;
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
"
NotFoundError
"
)
{
Cu
.
reportError
(
ex
)
;
}
this
.
partFileExists
=
false
;
}
}
toSerializable
(
)
{
if
(
!
this
.
partFilePath
&
&
!
this
.
_unknownProperties
)
{
return
this
.
path
;
}
let
serializable
=
{
path
:
this
.
path
partFilePath
:
this
.
partFilePath
}
;
serializeUnknownProperties
(
this
serializable
)
;
return
serializable
;
}
}
;
DownloadTarget
.
fromSerializable
=
function
(
aSerializable
)
{
let
target
=
new
DownloadTarget
(
)
;
if
(
isString
(
aSerializable
)
)
{
target
.
path
=
aSerializable
.
toString
(
)
;
}
else
if
(
aSerializable
instanceof
Ci
.
nsIFile
)
{
target
.
path
=
aSerializable
.
path
;
}
else
{
target
.
path
=
aSerializable
.
path
.
toString
(
)
;
if
(
"
partFilePath
"
in
aSerializable
)
{
target
.
partFilePath
=
aSerializable
.
partFilePath
;
}
deserializeUnknownProperties
(
target
aSerializable
property
=
>
property
!
=
"
path
"
&
&
property
!
=
"
partFilePath
"
)
;
}
return
target
;
}
;
var
DownloadError
=
function
(
aProperties
)
{
const
NS_ERROR_MODULE_BASE_OFFSET
=
0x45
;
const
NS_ERROR_MODULE_NETWORK
=
6
;
const
NS_ERROR_MODULE_FILES
=
13
;
this
.
name
=
"
DownloadError
"
;
this
.
result
=
aProperties
.
result
|
|
Cr
.
NS_ERROR_FAILURE
;
if
(
aProperties
.
message
)
{
this
.
message
=
aProperties
.
message
;
}
else
if
(
aProperties
.
becauseBlocked
|
|
aProperties
.
becauseBlockedByParentalControls
|
|
aProperties
.
becauseBlockedByReputationCheck
|
|
aProperties
.
becauseBlockedByRuntimePermissions
)
{
this
.
message
=
"
Download
blocked
.
"
;
}
else
{
let
exception
=
new
Components
.
Exception
(
"
"
this
.
result
)
;
this
.
message
=
exception
.
toString
(
)
;
}
if
(
aProperties
.
inferCause
)
{
let
module
=
(
(
this
.
result
&
0x7fff0000
)
>
>
16
)
-
NS_ERROR_MODULE_BASE_OFFSET
;
this
.
becauseSourceFailed
=
module
=
=
NS_ERROR_MODULE_NETWORK
;
this
.
becauseTargetFailed
=
module
=
=
NS_ERROR_MODULE_FILES
;
}
else
{
if
(
aProperties
.
becauseSourceFailed
)
{
this
.
becauseSourceFailed
=
true
;
}
if
(
aProperties
.
becauseTargetFailed
)
{
this
.
becauseTargetFailed
=
true
;
}
}
if
(
aProperties
.
becauseBlockedByParentalControls
)
{
this
.
becauseBlocked
=
true
;
this
.
becauseBlockedByParentalControls
=
true
;
}
else
if
(
aProperties
.
becauseBlockedByReputationCheck
)
{
this
.
becauseBlocked
=
true
;
this
.
becauseBlockedByReputationCheck
=
true
;
this
.
reputationCheckVerdict
=
aProperties
.
reputationCheckVerdict
|
|
"
"
;
}
else
if
(
aProperties
.
becauseBlockedByRuntimePermissions
)
{
this
.
becauseBlocked
=
true
;
this
.
becauseBlockedByRuntimePermissions
=
true
;
}
else
if
(
aProperties
.
becauseBlocked
)
{
this
.
becauseBlocked
=
true
;
}
if
(
aProperties
.
innerException
)
{
this
.
innerException
=
aProperties
.
innerException
;
}
this
.
stack
=
new
Error
(
)
.
stack
;
}
;
DownloadError
.
BLOCK_VERDICT_MALWARE
=
"
Malware
"
;
DownloadError
.
BLOCK_VERDICT_POTENTIALLY_UNWANTED
=
"
PotentiallyUnwanted
"
;
DownloadError
.
BLOCK_VERDICT_INSECURE
=
"
Insecure
"
;
DownloadError
.
BLOCK_VERDICT_UNCOMMON
=
"
Uncommon
"
;
DownloadError
.
prototype
=
{
__proto__
:
Error
.
prototype
result
:
false
becauseSourceFailed
:
false
becauseTargetFailed
:
false
becauseBlocked
:
false
becauseBlockedByParentalControls
:
false
becauseBlockedByReputationCheck
:
false
becauseBlockedByRuntimePermissions
:
false
reputationCheckVerdict
:
"
"
innerException
:
null
toSerializable
(
)
{
let
serializable
=
{
result
:
this
.
result
message
:
this
.
message
becauseSourceFailed
:
this
.
becauseSourceFailed
becauseTargetFailed
:
this
.
becauseTargetFailed
becauseBlocked
:
this
.
becauseBlocked
becauseBlockedByParentalControls
:
this
.
becauseBlockedByParentalControls
becauseBlockedByReputationCheck
:
this
.
becauseBlockedByReputationCheck
becauseBlockedByRuntimePermissions
:
this
.
becauseBlockedByRuntimePermissions
reputationCheckVerdict
:
this
.
reputationCheckVerdict
}
;
serializeUnknownProperties
(
this
serializable
)
;
return
serializable
;
}
}
;
DownloadError
.
fromSerializable
=
function
(
aSerializable
)
{
let
e
=
new
DownloadError
(
aSerializable
)
;
deserializeUnknownProperties
(
e
aSerializable
property
=
>
property
!
=
"
result
"
&
&
property
!
=
"
message
"
&
&
property
!
=
"
becauseSourceFailed
"
&
&
property
!
=
"
becauseTargetFailed
"
&
&
property
!
=
"
becauseBlocked
"
&
&
property
!
=
"
becauseBlockedByParentalControls
"
&
&
property
!
=
"
becauseBlockedByReputationCheck
"
&
&
property
!
=
"
becauseBlockedByRuntimePermissions
"
&
&
property
!
=
"
reputationCheckVerdict
"
)
;
return
e
;
}
;
var
DownloadSaver
=
function
(
)
{
}
;
DownloadSaver
.
prototype
=
{
download
:
null
async
execute
(
aSetProgressBytesFn
aSetPropertiesFn
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
cancel
:
function
DS_cancel
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
async
removeData
(
canRemoveFinalTarget
)
{
}
addToHistory
(
)
{
if
(
AppConstants
.
MOZ_PLACES
)
{
DownloadHistory
.
addDownloadToHistory
(
this
.
download
)
.
catch
(
Cu
.
reportError
)
;
}
}
toSerializable
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
getSha256Hash
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
getSignatureInfo
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
}
;
DownloadSaver
.
fromSerializable
=
function
(
aSerializable
)
{
let
serializable
=
isString
(
aSerializable
)
?
{
type
:
aSerializable
}
:
aSerializable
;
let
saver
;
switch
(
serializable
.
type
)
{
case
"
copy
"
:
saver
=
DownloadCopySaver
.
fromSerializable
(
serializable
)
;
break
;
case
"
legacy
"
:
saver
=
DownloadLegacySaver
.
fromSerializable
(
serializable
)
;
break
;
default
:
throw
new
Error
(
"
Unrecoginzed
download
saver
type
.
"
)
;
}
return
saver
;
}
;
var
DownloadCopySaver
=
function
(
)
{
}
;
DownloadCopySaver
.
prototype
=
{
__proto__
:
DownloadSaver
.
prototype
_backgroundFileSaver
:
null
_canceled
:
false
_sha256Hash
:
null
_signatureInfo
:
null
_redirects
:
null
alreadyAddedToHistory
:
false
entityID
:
null
async
execute
(
aSetProgressBytesFn
aSetPropertiesFn
)
{
this
.
_canceled
=
false
;
let
download
=
this
.
download
;
let
targetPath
=
download
.
target
.
path
;
let
partFilePath
=
download
.
target
.
partFilePath
;
let
keepPartialData
=
download
.
tryToKeepPartialData
;
if
(
!
this
.
alreadyAddedToHistory
)
{
this
.
addToHistory
(
)
;
this
.
alreadyAddedToHistory
=
true
;
}
try
{
let
file
=
await
OS
.
File
.
open
(
targetPath
{
write
:
true
}
)
;
await
file
.
close
(
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
OS
.
File
.
Error
)
)
{
throw
ex
;
}
let
error
=
new
DownloadError
(
{
message
:
ex
.
toString
(
)
}
)
;
error
.
becauseTargetFailed
=
true
;
throw
error
;
}
let
deferSaveComplete
=
PromiseUtils
.
defer
(
)
;
if
(
this
.
_canceled
)
{
throw
new
DownloadError
(
{
message
:
"
Saver
canceled
.
"
}
)
;
}
let
backgroundFileSaver
=
new
BackgroundFileSaverStreamListener
(
)
;
backgroundFileSaver
.
QueryInterface
(
Ci
.
nsIStreamListener
)
;
try
{
backgroundFileSaver
.
observer
=
{
onTargetChange
(
)
{
}
onSaveComplete
:
(
aSaver
aStatus
)
=
>
{
if
(
Components
.
isSuccessCode
(
aStatus
)
)
{
this
.
_sha256Hash
=
aSaver
.
sha256Hash
;
this
.
_signatureInfo
=
aSaver
.
signatureInfo
;
this
.
_redirects
=
aSaver
.
redirects
;
deferSaveComplete
.
resolve
(
)
;
}
else
{
let
properties
=
{
result
:
aStatus
inferCause
:
true
}
;
deferSaveComplete
.
reject
(
new
DownloadError
(
properties
)
)
;
}
backgroundFileSaver
.
observer
=
null
;
this
.
_backgroundFileSaver
=
null
;
}
}
;
let
resumeAttempted
=
false
;
let
resumeFromBytes
=
0
;
const
notificationCallbacks
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIInterfaceRequestor
"
]
)
getInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIProgressEventSink
"
]
)
onProgress
:
function
DCSE_onProgress
(
aRequest
aProgress
aProgressMax
)
{
let
currentBytes
=
resumeFromBytes
+
aProgress
;
let
totalBytes
=
aProgressMax
=
=
-
1
?
-
1
:
resumeFromBytes
+
aProgressMax
;
aSetProgressBytesFn
(
currentBytes
totalBytes
aProgress
>
0
&
&
partFilePath
&
&
keepPartialData
)
;
}
onStatus
(
)
{
}
}
;
const
streamListener
=
{
onStartRequest
:
function
(
aRequest
)
{
backgroundFileSaver
.
onStartRequest
(
aRequest
)
;
if
(
aRequest
instanceof
Ci
.
nsIHttpChannel
)
{
if
(
aRequest
.
responseStatus
=
=
450
)
{
this
.
download
.
_blockedByParentalControls
=
true
;
aRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
return
;
}
if
(
download
.
source
.
allowHttpStatus
&
&
!
download
.
source
.
allowHttpStatus
(
download
aRequest
.
responseStatus
)
)
{
aRequest
.
cancel
(
Cr
.
NS_BINDING_ABORTED
)
;
return
;
}
}
if
(
aRequest
instanceof
Ci
.
nsIChannel
)
{
aSetPropertiesFn
(
{
contentType
:
aRequest
.
contentType
}
)
;
if
(
aRequest
.
contentLength
>
=
0
)
{
aSetProgressBytesFn
(
0
aRequest
.
contentLength
)
;
}
}
if
(
aRequest
instanceof
Ci
.
nsIEncodedChannel
&
&
aRequest
.
contentEncodings
)
{
let
uri
=
aRequest
.
URI
;
if
(
uri
instanceof
Ci
.
nsIURL
&
&
uri
.
fileExtension
)
{
let
encoding
=
aRequest
.
contentEncodings
.
getNext
(
)
;
if
(
encoding
)
{
aRequest
.
applyConversion
=
gExternalHelperAppService
.
applyDecodingForExtension
(
uri
.
fileExtension
encoding
)
;
}
}
}
if
(
keepPartialData
)
{
if
(
aRequest
instanceof
Ci
.
nsIResumableChannel
)
{
try
{
this
.
entityID
=
aRequest
.
entityID
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Components
.
Exception
)
|
|
ex
.
result
!
=
Cr
.
NS_ERROR_NOT_RESUMABLE
)
{
throw
ex
;
}
keepPartialData
=
false
;
}
}
else
{
keepPartialData
=
false
;
}
}
backgroundFileSaver
.
enableSha256
(
)
;
backgroundFileSaver
.
enableSignatureInfo
(
)
;
if
(
partFilePath
)
{
if
(
resumeAttempted
)
{
backgroundFileSaver
.
enableAppend
(
)
;
}
backgroundFileSaver
.
setTarget
(
new
FileUtils
.
File
(
partFilePath
)
keepPartialData
)
;
}
else
{
backgroundFileSaver
.
setTarget
(
new
FileUtils
.
File
(
targetPath
)
false
)
;
}
}
.
bind
(
this
)
onStopRequest
(
aRequest
aStatusCode
)
{
try
{
backgroundFileSaver
.
onStopRequest
(
aRequest
aStatusCode
)
;
}
finally
{
if
(
Components
.
isSuccessCode
(
aStatusCode
)
)
{
backgroundFileSaver
.
finish
(
Cr
.
NS_OK
)
;
}
}
}
onDataAvailable
(
aRequest
aInputStream
aOffset
aCount
)
{
backgroundFileSaver
.
onDataAvailable
(
aRequest
aInputStream
aOffset
aCount
)
;
}
}
;
const
open
=
async
(
)
=
>
{
let
channel
;
if
(
download
.
source
.
loadingPrincipal
)
{
channel
=
NetUtil
.
newChannel
(
{
uri
:
download
.
source
.
url
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_SAVEAS_DOWNLOAD
loadingPrincipal
:
download
.
source
.
loadingPrincipal
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
}
)
;
}
else
{
channel
=
NetUtil
.
newChannel
(
{
uri
:
download
.
source
.
url
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_SAVEAS_DOWNLOAD
loadUsingSystemPrincipal
:
true
}
)
;
}
if
(
channel
instanceof
Ci
.
nsIPrivateBrowsingChannel
)
{
channel
.
setPrivate
(
download
.
source
.
isPrivate
)
;
}
if
(
channel
instanceof
Ci
.
nsIHttpChannel
&
&
download
.
source
.
referrerInfo
)
{
channel
.
referrerInfo
=
download
.
source
.
referrerInfo
;
download
.
source
.
referrerInfo
=
channel
.
referrerInfo
;
}
if
(
channel
instanceof
Ci
.
nsIHttpChannel
&
&
download
.
source
.
cookieJarSettings
)
{
channel
.
loadInfo
.
cookieJarSettings
=
download
.
source
.
cookieJarSettings
;
}
if
(
download
.
source
.
userContextId
)
{
channel
.
loadInfo
.
originAttributes
=
{
.
.
.
channel
.
loadInfo
.
originAttributes
userContextId
:
download
.
source
.
userContextId
}
;
}
if
(
channel
instanceof
Ci
.
nsIHttpChannelInternal
)
{
channel
.
channelIsForDownload
=
true
;
channel
.
forceAllowThirdPartyCookie
=
true
;
}
if
(
channel
instanceof
Ci
.
nsIResumableChannel
&
&
this
.
entityID
&
&
partFilePath
&
&
keepPartialData
)
{
try
{
let
stat
=
await
IOUtils
.
stat
(
partFilePath
)
;
channel
.
resumeAt
(
stat
.
size
this
.
entityID
)
;
resumeAttempted
=
true
;
resumeFromBytes
=
stat
.
size
;
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
"
NotFoundError
"
)
{
throw
ex
;
}
}
}
channel
.
notificationCallbacks
=
notificationCallbacks
;
if
(
download
.
source
.
adjustChannel
)
{
await
download
.
source
.
adjustChannel
(
channel
)
;
}
channel
.
asyncOpen
(
streamListener
)
;
}
;
await
open
(
)
;
if
(
this
.
_canceled
)
{
throw
new
DownloadError
(
{
message
:
"
Saver
canceled
.
"
}
)
;
}
this
.
_backgroundFileSaver
=
backgroundFileSaver
;
}
catch
(
ex
)
{
backgroundFileSaver
.
finish
(
Cr
.
NS_ERROR_FAILURE
)
;
deferSaveComplete
.
promise
.
catch
(
(
)
=
>
{
}
)
;
throw
ex
;
}
await
deferSaveComplete
.
promise
;
await
this
.
_checkReputationAndMove
(
aSetPropertiesFn
)
;
}
async
_checkReputationAndMove
(
aSetPropertiesFn
)
{
let
download
=
this
.
download
;
let
targetPath
=
this
.
download
.
target
.
path
;
let
partFilePath
=
this
.
download
.
target
.
partFilePath
;
let
{
shouldBlock
verdict
}
=
await
DownloadIntegration
.
shouldBlockForReputationCheck
(
download
)
;
if
(
shouldBlock
)
{
Services
.
telemetry
.
getKeyedHistogramById
(
"
DOWNLOADS_USER_ACTION_ON_BLOCKED_DOWNLOAD
"
)
.
add
(
verdict
0
)
;
let
newProperties
=
{
progress
:
100
hasPartialData
:
false
}
;
if
(
!
DownloadIntegration
.
shouldKeepBlockedData
(
)
|
|
!
partFilePath
)
{
await
this
.
removeData
(
!
partFilePath
)
;
}
else
{
newProperties
.
hasBlockedData
=
true
;
}
aSetPropertiesFn
(
newProperties
)
;
throw
new
DownloadError
(
{
becauseBlockedByReputationCheck
:
true
reputationCheckVerdict
:
verdict
}
)
;
}
if
(
partFilePath
)
{
try
{
await
IOUtils
.
move
(
partFilePath
targetPath
)
;
}
catch
(
e
)
{
if
(
e
.
name
=
=
=
"
NotAllowedError
"
)
{
let
uniquePath
=
DownloadPaths
.
createNiceUniqueFile
(
new
FileUtils
.
File
(
targetPath
)
)
.
path
;
await
IOUtils
.
move
(
partFilePath
uniquePath
)
;
this
.
download
.
target
.
path
=
uniquePath
;
}
else
{
throw
e
;
}
}
}
}
cancel
:
function
DCS_cancel
(
)
{
this
.
_canceled
=
true
;
if
(
this
.
_backgroundFileSaver
)
{
this
.
_backgroundFileSaver
.
finish
(
Cr
.
NS_ERROR_FAILURE
)
;
this
.
_backgroundFileSaver
=
null
;
}
}
async
removeData
(
canRemoveFinalTarget
=
false
)
{
async
function
_tryToRemoveFile
(
path
)
{
try
{
await
IOUtils
.
remove
(
path
)
;
}
catch
(
ex
)
{
if
(
!
[
"
NotFoundError
"
"
NotAllowedError
"
]
.
includes
(
ex
.
name
)
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
if
(
this
.
download
.
target
.
partFilePath
)
{
await
_tryToRemoveFile
(
this
.
download
.
target
.
partFilePath
)
;
}
if
(
this
.
download
.
target
.
path
)
{
if
(
canRemoveFinalTarget
|
|
(
await
isPlaceholder
(
this
.
download
.
target
.
path
)
)
)
{
await
_tryToRemoveFile
(
this
.
download
.
target
.
path
)
;
}
this
.
download
.
target
.
exists
=
false
;
this
.
download
.
target
.
size
=
0
;
}
}
toSerializable
(
)
{
if
(
!
this
.
entityID
&
&
!
this
.
_unknownProperties
)
{
return
"
copy
"
;
}
let
serializable
=
{
type
:
"
copy
"
entityID
:
this
.
entityID
}
;
serializeUnknownProperties
(
this
serializable
)
;
return
serializable
;
}
getSha256Hash
(
)
{
return
this
.
_sha256Hash
;
}
getSignatureInfo
(
)
{
return
this
.
_signatureInfo
;
}
getRedirects
(
)
{
return
this
.
_redirects
;
}
}
;
DownloadCopySaver
.
fromSerializable
=
function
(
aSerializable
)
{
let
saver
=
new
DownloadCopySaver
(
)
;
if
(
"
entityID
"
in
aSerializable
)
{
saver
.
entityID
=
aSerializable
.
entityID
;
}
deserializeUnknownProperties
(
saver
aSerializable
property
=
>
property
!
=
"
entityID
"
&
&
property
!
=
"
type
"
)
;
return
saver
;
}
;
var
DownloadLegacySaver
=
function
(
)
{
this
.
deferExecuted
=
PromiseUtils
.
defer
(
)
;
this
.
deferCanceled
=
PromiseUtils
.
defer
(
)
;
}
;
DownloadLegacySaver
.
prototype
=
{
__proto__
:
DownloadSaver
.
prototype
_sha256Hash
:
null
_signatureInfo
:
null
_redirects
:
null
request
:
null
deferExecuted
:
null
deferCanceled
:
null
setProgressBytesFn
:
null
onProgressBytes
:
function
DLS_onProgressBytes
(
aCurrentBytes
aTotalBytes
)
{
this
.
progressWasNotified
=
true
;
if
(
!
this
.
setProgressBytesFn
)
{
this
.
currentBytes
=
aCurrentBytes
;
this
.
totalBytes
=
aTotalBytes
;
return
;
}
let
hasPartFile
=
!
!
this
.
download
.
target
.
partFilePath
;
this
.
setProgressBytesFn
(
aCurrentBytes
aTotalBytes
aCurrentBytes
>
0
&
&
hasPartFile
)
;
}
progressWasNotified
:
false
onTransferStarted
(
aRequest
)
{
this
.
request
=
aRequest
;
if
(
this
.
download
.
tryToKeepPartialData
&
&
aRequest
instanceof
Ci
.
nsIResumableChannel
)
{
try
{
this
.
entityID
=
aRequest
.
entityID
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Components
.
Exception
)
|
|
ex
.
result
!
=
Cr
.
NS_ERROR_NOT_RESUMABLE
)
{
throw
ex
;
}
}
}
if
(
aRequest
instanceof
Ci
.
nsIHttpChannel
)
{
this
.
download
.
source
.
referrerInfo
=
aRequest
.
referrerInfo
;
}
this
.
addToHistory
(
)
;
}
onTransferFinished
:
function
DLS_onTransferFinished
(
aStatus
)
{
if
(
Components
.
isSuccessCode
(
aStatus
)
)
{
this
.
deferExecuted
.
resolve
(
)
;
}
else
{
let
properties
=
{
result
:
aStatus
inferCause
:
true
}
;
this
.
deferExecuted
.
reject
(
new
DownloadError
(
properties
)
)
;
}
}
firstExecutionFinished
:
false
copySaver
:
null
entityID
:
null
async
execute
(
aSetProgressBytesFn
aSetPropertiesFn
)
{
if
(
this
.
firstExecutionFinished
)
{
if
(
!
this
.
copySaver
)
{
this
.
copySaver
=
new
DownloadCopySaver
(
)
;
this
.
copySaver
.
download
=
this
.
download
;
this
.
copySaver
.
entityID
=
this
.
entityID
;
this
.
copySaver
.
alreadyAddedToHistory
=
true
;
}
await
this
.
copySaver
.
execute
.
apply
(
this
.
copySaver
arguments
)
;
return
;
}
this
.
setProgressBytesFn
=
aSetProgressBytesFn
;
if
(
this
.
progressWasNotified
)
{
this
.
onProgressBytes
(
this
.
currentBytes
this
.
totalBytes
)
;
}
try
{
await
this
.
deferExecuted
.
promise
;
if
(
!
this
.
progressWasNotified
&
&
this
.
request
instanceof
Ci
.
nsIChannel
&
&
this
.
request
.
contentLength
>
=
0
)
{
aSetProgressBytesFn
(
0
this
.
request
.
contentLength
)
;
}
if
(
!
this
.
download
.
target
.
partFilePath
)
{
try
{
let
file
=
await
OS
.
File
.
open
(
this
.
download
.
target
.
path
{
create
:
true
}
)
;
await
file
.
close
(
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
OS
.
File
.
Error
)
|
|
!
ex
.
becauseExists
)
{
throw
ex
;
}
}
}
await
this
.
_checkReputationAndMove
(
aSetPropertiesFn
)
;
}
catch
(
ex
)
{
this
.
deferCanceled
.
resolve
(
)
;
throw
ex
;
}
finally
{
this
.
request
=
null
;
this
.
deferCanceled
=
null
;
this
.
firstExecutionFinished
=
true
;
}
}
_checkReputationAndMove
(
)
{
return
DownloadCopySaver
.
prototype
.
_checkReputationAndMove
.
apply
(
this
arguments
)
;
}
cancel
:
function
DLS_cancel
(
)
{
if
(
this
.
copySaver
)
{
return
this
.
copySaver
.
cancel
.
apply
(
this
.
copySaver
arguments
)
;
}
if
(
this
.
deferCanceled
)
{
this
.
deferCanceled
.
resolve
(
)
;
}
}
removeData
(
canRemoveFinalTarget
)
{
return
DownloadCopySaver
.
prototype
.
removeData
.
call
(
this
canRemoveFinalTarget
)
;
}
toSerializable
(
)
{
return
DownloadCopySaver
.
prototype
.
toSerializable
.
call
(
this
)
;
}
getSha256Hash
(
)
{
if
(
this
.
copySaver
)
{
return
this
.
copySaver
.
getSha256Hash
(
)
;
}
return
this
.
_sha256Hash
;
}
setSha256Hash
(
hash
)
{
this
.
_sha256Hash
=
hash
;
}
getSignatureInfo
(
)
{
if
(
this
.
copySaver
)
{
return
this
.
copySaver
.
getSignatureInfo
(
)
;
}
return
this
.
_signatureInfo
;
}
setSignatureInfo
(
signatureInfo
)
{
this
.
_signatureInfo
=
signatureInfo
;
}
getRedirects
(
)
{
if
(
this
.
copySaver
)
{
return
this
.
copySaver
.
getRedirects
(
)
;
}
return
this
.
_redirects
;
}
setRedirects
(
redirects
)
{
this
.
_redirects
=
redirects
;
}
}
;
DownloadLegacySaver
.
fromSerializable
=
function
(
)
{
return
new
DownloadLegacySaver
(
)
;
}
;
