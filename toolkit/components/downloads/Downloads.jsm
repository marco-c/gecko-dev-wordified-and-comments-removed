"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Downloads
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Integration
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadCore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadCombinedList
"
"
resource
:
/
/
gre
/
modules
/
DownloadList
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadList
"
"
resource
:
/
/
gre
/
modules
/
DownloadList
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadSummary
"
"
resource
:
/
/
gre
/
modules
/
DownloadList
.
jsm
"
)
;
Integration
.
downloads
.
defineModuleGetter
(
this
"
DownloadIntegration
"
"
resource
:
/
/
gre
/
modules
/
DownloadIntegration
.
jsm
"
)
;
var
Downloads
=
{
get
PUBLIC
(
)
{
return
"
{
Downloads
.
PUBLIC
}
"
;
}
get
PRIVATE
(
)
{
return
"
{
Downloads
.
PRIVATE
}
"
;
}
get
ALL
(
)
{
return
"
{
Downloads
.
ALL
}
"
;
}
createDownload
:
function
D_createDownload
(
aProperties
)
{
try
{
return
Promise
.
resolve
(
Download
.
fromSerializable
(
aProperties
)
)
;
}
catch
(
ex
)
{
return
Promise
.
reject
(
ex
)
;
}
}
fetch
(
aSource
aTarget
aOptions
)
{
return
this
.
createDownload
(
{
source
:
aSource
target
:
aTarget
}
)
.
then
(
function
D_SD_onSuccess
(
aDownload
)
{
if
(
aOptions
&
&
(
"
isPrivate
"
in
aOptions
)
)
{
aDownload
.
source
.
isPrivate
=
aOptions
.
isPrivate
;
}
return
aDownload
.
start
(
)
;
}
)
;
}
getList
(
aType
)
{
if
(
!
this
.
_promiseListsInitialized
)
{
this
.
_promiseListsInitialized
=
(
async
(
)
=
>
{
let
publicList
=
new
DownloadList
(
)
;
let
privateList
=
new
DownloadList
(
)
;
let
combinedList
=
new
DownloadCombinedList
(
publicList
privateList
)
;
try
{
await
DownloadIntegration
.
addListObservers
(
publicList
false
)
;
await
DownloadIntegration
.
addListObservers
(
privateList
true
)
;
await
DownloadIntegration
.
initializePublicDownloadList
(
publicList
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
let
publicSummary
=
await
this
.
getSummary
(
Downloads
.
PUBLIC
)
;
let
privateSummary
=
await
this
.
getSummary
(
Downloads
.
PRIVATE
)
;
let
combinedSummary
=
await
this
.
getSummary
(
Downloads
.
ALL
)
;
await
publicSummary
.
bindToList
(
publicList
)
;
await
privateSummary
.
bindToList
(
privateList
)
;
await
combinedSummary
.
bindToList
(
combinedList
)
;
this
.
_lists
[
Downloads
.
PUBLIC
]
=
publicList
;
this
.
_lists
[
Downloads
.
PRIVATE
]
=
privateList
;
this
.
_lists
[
Downloads
.
ALL
]
=
combinedList
;
}
)
(
)
;
}
return
this
.
_promiseListsInitialized
.
then
(
(
)
=
>
this
.
_lists
[
aType
]
)
;
}
_promiseListsInitialized
:
null
_lists
:
{
}
getSummary
(
aType
)
{
if
(
aType
!
=
Downloads
.
PUBLIC
&
&
aType
!
=
Downloads
.
PRIVATE
&
&
aType
!
=
Downloads
.
ALL
)
{
throw
new
Error
(
"
Invalid
aType
argument
.
"
)
;
}
if
(
!
(
aType
in
this
.
_summaries
)
)
{
this
.
_summaries
[
aType
]
=
new
DownloadSummary
(
)
;
}
return
Promise
.
resolve
(
this
.
_summaries
[
aType
]
)
;
}
_summaries
:
{
}
getSystemDownloadsDirectory
:
function
D_getSystemDownloadsDirectory
(
)
{
return
DownloadIntegration
.
getSystemDownloadsDirectory
(
)
;
}
getPreferredDownloadsDirectory
:
function
D_getPreferredDownloadsDirectory
(
)
{
return
DownloadIntegration
.
getPreferredDownloadsDirectory
(
)
;
}
getTemporaryDownloadsDirectory
:
function
D_getTemporaryDownloadsDirectory
(
)
{
return
DownloadIntegration
.
getTemporaryDownloadsDirectory
(
)
;
}
Error
:
DownloadError
}
;
