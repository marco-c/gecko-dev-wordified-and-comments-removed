"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadUIHelper
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
const
kStringBundleUrl
=
"
chrome
:
/
/
mozapps
/
locale
/
downloads
/
downloads
.
properties
"
;
const
kStringsRequiringFormatting
=
{
fileExecutableSecurityWarning
:
true
cancelDownloadsOKTextMultiple
:
true
quitCancelDownloadsAlertMsgMultiple
:
true
quitCancelDownloadsAlertMsgMacMultiple
:
true
offlineCancelDownloadsAlertMsgMultiple
:
true
leavePrivateBrowsingWindowsCancelDownloadsAlertMsgMultiple2
:
true
}
;
var
DownloadUIHelper
=
{
getPrompter
(
aParent
)
{
return
new
DownloadPrompter
(
aParent
|
|
null
)
;
}
loadFileIn
(
file
{
chromeWindow
:
browserWin
openWhere
=
"
tab
"
isPrivate
userContextId
=
0
browsingContextId
=
0
}
=
{
}
)
{
let
fileURI
=
Services
.
io
.
newFileURI
(
file
)
;
let
allowPrivate
=
isPrivate
|
|
lazy
.
PrivateBrowsingUtils
.
permanentPrivateBrowsing
;
if
(
!
browserWin
|
|
browserWin
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
!
=
=
"
navigator
:
browser
"
)
{
browserWin
=
lazy
.
BrowserWindowTracker
.
getTopWindow
(
{
private
:
allowPrivate
}
)
;
}
if
(
!
browserWin
)
{
let
args
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
strURI
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
strURI
.
data
=
fileURI
.
spec
;
args
.
appendElement
(
strURI
)
;
let
features
=
"
chrome
dialog
=
no
all
"
;
if
(
isPrivate
)
{
features
+
=
"
private
"
;
}
browserWin
=
Services
.
ww
.
openWindow
(
null
AppConstants
.
BROWSER_CHROME_URL
null
features
args
)
;
return
;
}
let
browsingContext
=
browserWin
?
.
BrowsingContext
.
get
(
browsingContextId
)
;
browserWin
.
openTrustedLinkIn
(
fileURI
.
spec
openWhere
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
private
:
isPrivate
userContextId
openerBrowser
:
browsingContext
?
.
top
?
.
embedderElement
}
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
DownloadUIHelper
"
strings
"
function
(
)
{
let
strings
=
{
}
;
let
sb
=
Services
.
strings
.
createBundle
(
kStringBundleUrl
)
;
for
(
let
string
of
sb
.
getSimpleEnumeration
(
)
)
{
let
stringName
=
string
.
key
;
if
(
stringName
in
kStringsRequiringFormatting
)
{
strings
[
stringName
]
=
function
(
)
{
return
sb
.
formatStringFromName
(
stringName
Array
.
from
(
arguments
)
)
;
}
;
}
else
{
strings
[
stringName
]
=
string
.
value
;
}
}
return
strings
;
}
)
;
var
DownloadPrompter
=
function
(
aParent
)
{
this
.
_prompter
=
Services
.
ww
.
getNewPrompter
(
aParent
)
;
}
;
DownloadPrompter
.
prototype
=
{
ON_QUIT
:
"
prompt
-
on
-
quit
"
ON_OFFLINE
:
"
prompt
-
on
-
offline
"
ON_LEAVE_PRIVATE_BROWSING
:
"
prompt
-
on
-
leave
-
private
-
browsing
"
_prompter
:
null
async
confirmLaunchExecutable
(
path
)
{
const
kPrefSkipConfirm
=
"
browser
.
download
.
skipConfirmLaunchExecutable
"
;
if
(
!
this
.
_prompter
)
{
return
true
;
}
try
{
if
(
Services
.
prefs
.
getBoolPref
(
kPrefSkipConfirm
)
)
{
return
true
;
}
}
catch
(
ex
)
{
}
let
leafName
=
lazy
.
OS
.
Path
.
basename
(
path
)
;
let
s
=
DownloadUIHelper
.
strings
;
return
this
.
_prompter
.
confirm
(
s
.
fileExecutableSecurityWarningTitle
s
.
fileExecutableSecurityWarning
(
leafName
leafName
)
)
;
}
confirmCancelDownloads
:
function
DP_confirmCancelDownload
(
aDownloadsCount
aPromptType
)
{
if
(
!
this
.
_prompter
|
|
aDownloadsCount
<
=
0
)
{
return
false
;
}
let
s
=
DownloadUIHelper
.
strings
;
let
buttonFlags
=
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
+
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
;
let
okButton
=
aDownloadsCount
>
1
?
s
.
cancelDownloadsOKTextMultiple
(
aDownloadsCount
)
:
s
.
cancelDownloadsOKText
;
let
title
message
cancelButton
;
switch
(
aPromptType
)
{
case
this
.
ON_QUIT
:
title
=
s
.
quitCancelDownloadsAlertTitle
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
message
=
aDownloadsCount
>
1
?
s
.
quitCancelDownloadsAlertMsgMultiple
(
aDownloadsCount
)
:
s
.
quitCancelDownloadsAlertMsg
;
cancelButton
=
s
.
dontQuitButtonWin
;
}
else
{
message
=
aDownloadsCount
>
1
?
s
.
quitCancelDownloadsAlertMsgMacMultiple
(
aDownloadsCount
)
:
s
.
quitCancelDownloadsAlertMsgMac
;
cancelButton
=
s
.
dontQuitButtonMac
;
}
break
;
case
this
.
ON_OFFLINE
:
title
=
s
.
offlineCancelDownloadsAlertTitle
;
message
=
aDownloadsCount
>
1
?
s
.
offlineCancelDownloadsAlertMsgMultiple
(
aDownloadsCount
)
:
s
.
offlineCancelDownloadsAlertMsg
;
cancelButton
=
s
.
dontGoOfflineButton
;
break
;
case
this
.
ON_LEAVE_PRIVATE_BROWSING
:
title
=
s
.
leavePrivateBrowsingCancelDownloadsAlertTitle
;
message
=
aDownloadsCount
>
1
?
s
.
leavePrivateBrowsingWindowsCancelDownloadsAlertMsgMultiple2
(
aDownloadsCount
)
:
s
.
leavePrivateBrowsingWindowsCancelDownloadsAlertMsg2
;
cancelButton
=
s
.
dontLeavePrivateBrowsingButton2
;
break
;
}
let
rv
=
this
.
_prompter
.
confirmEx
(
title
message
buttonFlags
okButton
cancelButton
null
null
{
}
)
;
return
rv
=
=
1
;
}
}
;
