"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadUIHelper
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
kStringBundleUrl
=
"
chrome
:
/
/
mozapps
/
locale
/
downloads
/
downloads
.
properties
"
;
const
kStringsRequiringFormatting
=
{
fileExecutableSecurityWarning
:
true
cancelDownloadsOKTextMultiple
:
true
quitCancelDownloadsAlertMsgMultiple
:
true
quitCancelDownloadsAlertMsgMacMultiple
:
true
offlineCancelDownloadsAlertMsgMultiple
:
true
leavePrivateBrowsingWindowsCancelDownloadsAlertMsgMultiple2
:
true
}
;
var
DownloadUIHelper
=
{
getPrompter
(
aParent
)
{
return
new
DownloadPrompter
(
aParent
|
|
null
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
DownloadUIHelper
"
strings
"
function
(
)
{
let
strings
=
{
}
;
let
sb
=
Services
.
strings
.
createBundle
(
kStringBundleUrl
)
;
for
(
let
string
of
sb
.
getSimpleEnumeration
(
)
)
{
let
stringName
=
string
.
key
;
if
(
stringName
in
kStringsRequiringFormatting
)
{
strings
[
stringName
]
=
function
(
)
{
return
sb
.
formatStringFromName
(
stringName
Array
.
from
(
arguments
)
)
;
}
;
}
else
{
strings
[
stringName
]
=
string
.
value
;
}
}
return
strings
;
}
)
;
var
DownloadPrompter
=
function
(
aParent
)
{
this
.
_prompter
=
Services
.
ww
.
getNewPrompter
(
aParent
)
;
}
;
DownloadPrompter
.
prototype
=
{
ON_QUIT
:
"
prompt
-
on
-
quit
"
ON_OFFLINE
:
"
prompt
-
on
-
offline
"
ON_LEAVE_PRIVATE_BROWSING
:
"
prompt
-
on
-
leave
-
private
-
browsing
"
_prompter
:
null
async
confirmLaunchExecutable
(
path
)
{
const
kPrefSkipConfirm
=
"
browser
.
download
.
skipConfirmLaunchExecutable
"
;
if
(
!
this
.
_prompter
)
{
return
true
;
}
try
{
if
(
Services
.
prefs
.
getBoolPref
(
kPrefSkipConfirm
)
)
{
return
true
;
}
}
catch
(
ex
)
{
}
let
leafName
=
OS
.
Path
.
basename
(
path
)
;
let
s
=
DownloadUIHelper
.
strings
;
return
this
.
_prompter
.
confirm
(
s
.
fileExecutableSecurityWarningTitle
s
.
fileExecutableSecurityWarning
(
leafName
leafName
)
)
;
}
confirmCancelDownloads
:
function
DP_confirmCancelDownload
(
aDownloadsCount
aPromptType
)
{
if
(
!
this
.
_prompter
|
|
aDownloadsCount
<
=
0
)
{
return
false
;
}
let
s
=
DownloadUIHelper
.
strings
;
let
buttonFlags
=
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_0
+
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
*
Ci
.
nsIPrompt
.
BUTTON_POS_1
;
let
okButton
=
aDownloadsCount
>
1
?
s
.
cancelDownloadsOKTextMultiple
(
aDownloadsCount
)
:
s
.
cancelDownloadsOKText
;
let
title
message
cancelButton
;
switch
(
aPromptType
)
{
case
this
.
ON_QUIT
:
title
=
s
.
quitCancelDownloadsAlertTitle
;
if
(
AppConstants
.
platform
!
=
"
macosx
"
)
{
message
=
aDownloadsCount
>
1
?
s
.
quitCancelDownloadsAlertMsgMultiple
(
aDownloadsCount
)
:
s
.
quitCancelDownloadsAlertMsg
;
cancelButton
=
s
.
dontQuitButtonWin
;
}
else
{
message
=
aDownloadsCount
>
1
?
s
.
quitCancelDownloadsAlertMsgMacMultiple
(
aDownloadsCount
)
:
s
.
quitCancelDownloadsAlertMsgMac
;
cancelButton
=
s
.
dontQuitButtonMac
;
}
break
;
case
this
.
ON_OFFLINE
:
title
=
s
.
offlineCancelDownloadsAlertTitle
;
message
=
aDownloadsCount
>
1
?
s
.
offlineCancelDownloadsAlertMsgMultiple
(
aDownloadsCount
)
:
s
.
offlineCancelDownloadsAlertMsg
;
cancelButton
=
s
.
dontGoOfflineButton
;
break
;
case
this
.
ON_LEAVE_PRIVATE_BROWSING
:
title
=
s
.
leavePrivateBrowsingCancelDownloadsAlertTitle
;
message
=
aDownloadsCount
>
1
?
s
.
leavePrivateBrowsingWindowsCancelDownloadsAlertMsgMultiple2
(
aDownloadsCount
)
:
s
.
leavePrivateBrowsingWindowsCancelDownloadsAlertMsg2
;
cancelButton
=
s
.
dontLeavePrivateBrowsingButton2
;
break
;
}
let
rv
=
this
.
_prompter
.
confirmEx
(
title
message
buttonFlags
okButton
cancelButton
null
null
{
}
)
;
return
rv
=
=
1
;
}
}
;
