"
use
strict
"
;
function
notifyPromptObservers
(
aIsPrivate
aExpectedCount
aExpectedPBCount
)
{
let
cancelQuit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
DownloadIntegration
.
_testPromptDownloads
=
-
1
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
quit
-
application
-
requested
"
)
;
Assert
.
equal
(
DownloadIntegration
.
_testPromptDownloads
aExpectedCount
)
;
DownloadIntegration
.
_testPromptDownloads
=
-
1
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
offline
-
requested
"
)
;
Assert
.
equal
(
DownloadIntegration
.
_testPromptDownloads
aExpectedCount
)
;
if
(
aIsPrivate
)
{
DownloadIntegration
.
_testPromptDownloads
=
-
1
;
Services
.
obs
.
notifyObservers
(
cancelQuit
"
last
-
pb
-
context
-
exiting
"
)
;
Assert
.
equal
(
DownloadIntegration
.
_testPromptDownloads
aExpectedPBCount
)
;
}
delete
DownloadIntegration
.
_testPromptDownloads
;
}
function
allowDirectoriesInTest
(
)
{
DownloadIntegration
.
allowDirectories
=
true
;
function
cleanup
(
)
{
DownloadIntegration
.
allowDirectories
=
false
;
}
registerCleanupFunction
(
cleanup
)
;
return
cleanup
;
}
XPCOMUtils
.
defineLazyGetter
(
this
"
gStringBundle
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
mozapps
/
locale
/
downloads
/
downloads
.
properties
"
)
;
}
)
;
add_task
(
async
function
test_getSystemDownloadsDirectory_exists_or_creates
(
)
{
let
tempDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
let
downloadDir
;
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
|
|
Services
.
appinfo
.
OS
=
=
"
Linux
"
|
|
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
&
&
parseFloat
(
Services
.
sysinfo
.
getProperty
(
"
version
"
)
)
>
=
6
)
)
{
downloadDir
=
await
DownloadIntegration
.
getSystemDownloadsDirectory
(
)
;
Assert
.
equal
(
downloadDir
tempDir
.
path
)
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
downloadDir
)
)
;
let
info
=
await
OS
.
File
.
stat
(
downloadDir
)
;
Assert
.
ok
(
info
.
isDir
)
;
}
else
{
let
targetPath
=
OS
.
Path
.
join
(
tempDir
.
path
gStringBundle
.
GetStringFromName
(
"
downloadsFolder
"
)
)
;
try
{
await
OS
.
File
.
removeEmptyDir
(
targetPath
)
;
}
catch
(
e
)
{
}
downloadDir
=
await
DownloadIntegration
.
getSystemDownloadsDirectory
(
)
;
Assert
.
equal
(
downloadDir
targetPath
)
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
downloadDir
)
)
;
let
info
=
await
OS
.
File
.
stat
(
downloadDir
)
;
Assert
.
ok
(
info
.
isDir
)
;
await
OS
.
File
.
removeEmptyDir
(
targetPath
)
;
}
}
)
;
add_task
(
async
function
test_getSystemDownloadsDirectory_real
(
)
{
let
fakeDownloadDir
=
await
DownloadIntegration
.
getSystemDownloadsDirectory
(
)
;
let
cleanup
=
allowDirectoriesInTest
(
)
;
let
realDownloadDir
=
await
DownloadIntegration
.
getSystemDownloadsDirectory
(
)
;
cleanup
(
)
;
Assert
.
notEqual
(
fakeDownloadDir
realDownloadDir
)
;
}
)
;
add_task
(
async
function
test_getPreferredDownloadsDirectory
(
)
{
let
cleanupDirectories
=
allowDirectoriesInTest
(
)
;
let
folderListPrefName
=
"
browser
.
download
.
folderList
"
;
let
dirPrefName
=
"
browser
.
download
.
dir
"
;
function
cleanupPrefs
(
)
{
Services
.
prefs
.
clearUserPref
(
folderListPrefName
)
;
Services
.
prefs
.
clearUserPref
(
dirPrefName
)
;
}
registerCleanupFunction
(
cleanupPrefs
)
;
Services
.
prefs
.
setIntPref
(
folderListPrefName
1
)
;
let
systemDir
=
await
DownloadIntegration
.
getSystemDownloadsDirectory
(
)
;
let
downloadDir
=
await
DownloadIntegration
.
getPreferredDownloadsDirectory
(
)
;
Assert
.
notEqual
(
downloadDir
"
"
)
;
Assert
.
equal
(
downloadDir
systemDir
)
;
Services
.
prefs
.
setIntPref
(
folderListPrefName
0
)
;
downloadDir
=
await
DownloadIntegration
.
getPreferredDownloadsDirectory
(
)
;
Assert
.
notEqual
(
downloadDir
"
"
)
;
Assert
.
equal
(
downloadDir
Services
.
dirsvc
.
get
(
"
Desk
"
Ci
.
nsIFile
)
.
path
)
;
Services
.
prefs
.
setIntPref
(
folderListPrefName
2
)
;
downloadDir
=
await
DownloadIntegration
.
getPreferredDownloadsDirectory
(
)
;
Assert
.
notEqual
(
downloadDir
"
"
)
;
Assert
.
equal
(
downloadDir
systemDir
)
;
let
time
=
new
Date
(
)
.
getTime
(
)
;
let
tempDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
tempDir
.
append
(
time
)
;
Services
.
prefs
.
setComplexValue
(
"
browser
.
download
.
dir
"
Ci
.
nsIFile
tempDir
)
;
downloadDir
=
await
DownloadIntegration
.
getPreferredDownloadsDirectory
(
)
;
Assert
.
notEqual
(
downloadDir
"
"
)
;
Assert
.
equal
(
downloadDir
tempDir
.
path
)
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
downloadDir
)
)
;
await
OS
.
File
.
removeEmptyDir
(
tempDir
.
path
)
;
tempDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
tempDir
.
append
(
"
dir_not_exist
"
)
;
tempDir
.
append
(
time
)
;
Services
.
prefs
.
setComplexValue
(
"
browser
.
download
.
dir
"
Ci
.
nsIFile
tempDir
)
;
downloadDir
=
await
DownloadIntegration
.
getPreferredDownloadsDirectory
(
)
;
Assert
.
equal
(
downloadDir
systemDir
)
;
Services
.
prefs
.
setIntPref
(
folderListPrefName
999
)
;
downloadDir
=
await
DownloadIntegration
.
getPreferredDownloadsDirectory
(
)
;
Assert
.
equal
(
downloadDir
systemDir
)
;
cleanupPrefs
(
)
;
cleanupDirectories
(
)
;
}
)
;
add_task
(
async
function
test_getTemporaryDownloadsDirectory
(
)
{
let
cleanup
=
allowDirectoriesInTest
(
)
;
let
downloadDir
=
await
DownloadIntegration
.
getTemporaryDownloadsDirectory
(
)
;
Assert
.
notEqual
(
downloadDir
"
"
)
;
if
(
"
nsILocalFileMac
"
in
Ci
)
{
let
preferredDownloadDir
=
await
DownloadIntegration
.
getPreferredDownloadsDirectory
(
)
;
Assert
.
equal
(
downloadDir
preferredDownloadDir
)
;
}
else
{
let
tempDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
Assert
.
equal
(
downloadDir
tempDir
.
path
)
;
}
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_observers_setup
(
)
{
DownloadIntegration
.
allowObservers
=
true
;
registerCleanupFunction
(
function
(
)
{
DownloadIntegration
.
allowObservers
=
false
;
}
)
;
}
)
;
add_task
(
async
function
test_notifications
(
)
{
for
(
let
isPrivate
of
[
false
true
]
)
{
mustInterruptResponses
(
)
;
let
list
=
await
promiseNewList
(
isPrivate
)
;
let
download1
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
download2
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
download3
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
promiseAttempt1
=
download1
.
start
(
)
;
let
promiseAttempt2
=
download2
.
start
(
)
;
download3
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
list
.
add
(
download1
)
;
await
list
.
add
(
download2
)
;
await
list
.
add
(
download3
)
;
await
download3
.
cancel
(
)
;
notifyPromptObservers
(
isPrivate
2
2
)
;
continueResponses
(
)
;
await
promiseAttempt1
;
await
promiseAttempt2
;
await
list
.
remove
(
download1
)
;
await
list
.
remove
(
download2
)
;
await
list
.
remove
(
download3
)
;
}
}
)
;
add_task
(
async
function
test_no_notifications
(
)
{
for
(
let
isPrivate
of
[
false
true
]
)
{
let
list
=
await
promiseNewList
(
isPrivate
)
;
let
download1
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
download2
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
download1
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
download2
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
list
.
add
(
download1
)
;
await
list
.
add
(
download2
)
;
await
download1
.
cancel
(
)
;
await
download2
.
cancel
(
)
;
notifyPromptObservers
(
isPrivate
0
0
)
;
await
list
.
remove
(
download1
)
;
await
list
.
remove
(
download2
)
;
}
}
)
;
add_task
(
async
function
test_mix_notifications
(
)
{
mustInterruptResponses
(
)
;
let
publicList
=
await
promiseNewList
(
)
;
let
privateList
=
await
Downloads
.
getList
(
Downloads
.
PRIVATE
)
;
let
download1
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
download2
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
promiseAttempt1
=
download1
.
start
(
)
;
let
promiseAttempt2
=
download2
.
start
(
)
;
await
publicList
.
add
(
download1
)
;
await
privateList
.
add
(
download2
)
;
notifyPromptObservers
(
true
2
1
)
;
continueResponses
(
)
;
await
promiseAttempt1
;
await
promiseAttempt2
;
await
publicList
.
remove
(
download1
)
;
await
privateList
.
remove
(
download2
)
;
}
)
;
add_task
(
async
function
test_suspend_resume
(
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
download
.
manager
.
resumeOnWakeDelay
"
5
)
;
let
addDownload
=
function
(
list
)
{
return
(
async
function
(
)
{
let
download
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
list
.
add
(
download
)
;
return
download
;
}
)
(
)
;
}
;
let
publicList
=
await
promiseNewList
(
)
;
let
privateList
=
await
promiseNewList
(
true
)
;
let
download1
=
await
addDownload
(
publicList
)
;
let
download2
=
await
addDownload
(
publicList
)
;
let
download3
=
await
addDownload
(
privateList
)
;
let
download4
=
await
addDownload
(
privateList
)
;
let
download5
=
await
addDownload
(
publicList
)
;
Services
.
obs
.
notifyObservers
(
null
"
sleep_notification
"
)
;
Assert
.
ok
(
download1
.
canceled
)
;
Assert
.
ok
(
download2
.
canceled
)
;
Assert
.
ok
(
download3
.
canceled
)
;
Assert
.
ok
(
download4
.
canceled
)
;
Assert
.
ok
(
download5
.
canceled
)
;
publicList
.
remove
(
download5
)
;
Assert
.
ok
(
download5
.
canceled
)
;
Services
.
obs
.
notifyObservers
(
null
"
wake_notification
"
)
;
await
download1
.
whenSucceeded
(
)
;
await
download2
.
whenSucceeded
(
)
;
await
download3
.
whenSucceeded
(
)
;
await
download4
.
whenSucceeded
(
)
;
Assert
.
ok
(
!
download1
.
canceled
)
;
Assert
.
ok
(
download5
.
canceled
)
;
download1
=
await
addDownload
(
publicList
)
;
download2
=
await
addDownload
(
publicList
)
;
download3
=
await
addDownload
(
privateList
)
;
download4
=
await
addDownload
(
privateList
)
;
Services
.
obs
.
notifyObservers
(
null
"
network
:
offline
-
about
-
to
-
go
-
offline
"
)
;
Assert
.
ok
(
download1
.
canceled
)
;
Assert
.
ok
(
download2
.
canceled
)
;
Assert
.
ok
(
download3
.
canceled
)
;
Assert
.
ok
(
download4
.
canceled
)
;
Services
.
obs
.
notifyObservers
(
null
"
network
:
offline
-
status
-
changed
"
"
online
"
)
;
await
download1
.
whenSucceeded
(
)
;
await
download2
.
whenSucceeded
(
)
;
await
download3
.
whenSucceeded
(
)
;
await
download4
.
whenSucceeded
(
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
download
.
manager
.
resumeOnWakeDelay
"
)
;
}
)
;
add_task
(
async
function
test_exit_private_browsing
(
)
{
mustInterruptResponses
(
)
;
let
privateList
=
await
promiseNewList
(
true
)
;
let
download1
=
await
promiseNewDownload
(
httpUrl
(
"
source
.
txt
"
)
)
;
let
download2
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
promiseAttempt1
=
download1
.
start
(
)
;
download2
.
start
(
)
;
await
privateList
.
add
(
download1
)
;
await
privateList
.
add
(
download2
)
;
await
promiseAttempt1
;
Assert
.
equal
(
(
await
privateList
.
getAll
(
)
)
.
length
2
)
;
await
new
Promise
(
resolve
=
>
{
DownloadIntegration
.
_testResolveClearPrivateList
=
resolve
;
Services
.
obs
.
notifyObservers
(
null
"
last
-
pb
-
context
-
exited
"
)
;
}
)
;
delete
DownloadIntegration
.
_testResolveClearPrivateList
;
Assert
.
equal
(
(
await
privateList
.
getAll
(
)
)
.
length
0
)
;
continueResponses
(
)
;
}
)
;
