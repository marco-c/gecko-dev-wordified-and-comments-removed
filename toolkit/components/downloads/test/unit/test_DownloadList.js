"
use
strict
"
;
const
{
TelemetryTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
sys
.
mjs
"
)
;
Services
.
prefs
.
setBoolPref
(
"
toolkit
.
telemetry
.
testing
.
overrideProductsCheck
"
true
)
;
function
getExpirableDate
(
)
{
let
dateObj
=
new
Date
(
)
;
dateObj
.
setHours
(
0
)
;
dateObj
.
setMinutes
(
0
)
;
dateObj
.
setSeconds
(
0
)
;
dateObj
.
setMilliseconds
(
0
)
;
return
new
Date
(
dateObj
.
getTime
(
)
-
8
*
86400000
)
;
}
function
promiseExpirableDownloadVisit
(
aSourceUrl
)
{
return
PlacesUtils
.
history
.
insert
(
{
url
:
aSourceUrl
|
|
httpUrl
(
"
source
.
txt
"
)
visits
:
[
{
transition
:
PlacesUtils
.
history
.
TRANSITIONS
.
DOWNLOAD
date
:
getExpirableDate
(
)
}
]
}
)
;
}
add_task
(
async
function
test_construction
(
)
{
let
downloadListOne
=
await
promiseNewList
(
)
;
let
downloadListTwo
=
await
promiseNewList
(
)
;
let
privateDownloadListOne
=
await
promiseNewList
(
true
)
;
let
privateDownloadListTwo
=
await
promiseNewList
(
true
)
;
Assert
.
notEqual
(
downloadListOne
downloadListTwo
)
;
Assert
.
notEqual
(
privateDownloadListOne
privateDownloadListTwo
)
;
Assert
.
notEqual
(
downloadListOne
privateDownloadListOne
)
;
}
)
;
add_task
(
async
function
test_add_getAll
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
downloadOne
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
downloadOne
)
;
let
itemsOne
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
itemsOne
.
length
1
)
;
Assert
.
equal
(
itemsOne
[
0
]
downloadOne
)
;
let
downloadTwo
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
downloadTwo
)
;
let
itemsTwo
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
itemsTwo
.
length
2
)
;
Assert
.
equal
(
itemsTwo
[
0
]
downloadOne
)
;
Assert
.
equal
(
itemsTwo
[
1
]
downloadTwo
)
;
Assert
.
equal
(
itemsOne
.
length
1
)
;
}
)
;
add_task
(
async
function
test_remove
(
)
{
let
list
=
await
promiseNewList
(
)
;
await
list
.
add
(
await
promiseNewDownload
(
)
)
;
await
list
.
add
(
await
promiseNewDownload
(
)
)
;
let
items
=
await
list
.
getAll
(
)
;
await
list
.
remove
(
items
[
0
]
)
;
await
list
.
remove
(
await
promiseNewDownload
(
)
)
;
items
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
1
)
;
}
)
;
add_task
(
async
function
test_DownloadCombinedList_add_remove_getAll
(
)
{
let
publicList
=
await
promiseNewList
(
)
;
let
privateList
=
await
Downloads
.
getList
(
Downloads
.
PRIVATE
)
;
let
combinedList
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
let
publicDownload
=
await
promiseNewDownload
(
)
;
let
privateDownload
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
isPrivate
:
true
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
)
;
await
publicList
.
add
(
publicDownload
)
;
await
privateList
.
add
(
privateDownload
)
;
Assert
.
equal
(
(
await
combinedList
.
getAll
(
)
)
.
length
2
)
;
await
combinedList
.
remove
(
publicDownload
)
;
await
combinedList
.
remove
(
privateDownload
)
;
Assert
.
equal
(
(
await
combinedList
.
getAll
(
)
)
.
length
0
)
;
await
combinedList
.
add
(
publicDownload
)
;
await
combinedList
.
add
(
privateDownload
)
;
Assert
.
equal
(
(
await
publicList
.
getAll
(
)
)
.
length
1
)
;
Assert
.
equal
(
(
await
privateList
.
getAll
(
)
)
.
length
1
)
;
Assert
.
equal
(
(
await
combinedList
.
getAll
(
)
)
.
length
2
)
;
await
publicList
.
remove
(
publicDownload
)
;
await
privateList
.
remove
(
privateDownload
)
;
Assert
.
equal
(
(
await
combinedList
.
getAll
(
)
)
.
length
0
)
;
}
)
;
add_task
(
async
function
test_notifications_add_remove
(
)
{
for
(
let
isCombined
of
[
false
true
]
)
{
let
list
=
await
promiseNewList
(
)
;
if
(
isCombined
)
{
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
}
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
isPrivate
:
true
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
let
addNotifications
=
0
;
let
viewOne
=
{
onDownloadAdded
(
aDownload
)
{
if
(
addNotifications
=
=
0
)
{
Assert
.
equal
(
aDownload
downloadOne
)
;
}
else
if
(
addNotifications
=
=
1
)
{
Assert
.
equal
(
aDownload
downloadTwo
)
;
}
addNotifications
+
+
;
}
}
;
list
.
addView
(
viewOne
)
;
Assert
.
equal
(
addNotifications
2
)
;
await
list
.
add
(
await
promiseNewDownload
(
)
)
;
Assert
.
equal
(
addNotifications
3
)
;
let
removeNotifications
=
0
;
let
viewTwo
=
{
onDownloadRemoved
(
aDownload
)
{
Assert
.
equal
(
aDownload
downloadOne
)
;
removeNotifications
+
+
;
}
}
;
list
.
addView
(
viewTwo
)
;
await
list
.
remove
(
downloadOne
)
;
Assert
.
equal
(
removeNotifications
1
)
;
list
.
removeView
(
viewTwo
)
;
await
list
.
remove
(
downloadTwo
)
;
Assert
.
equal
(
removeNotifications
1
)
;
list
.
removeView
(
viewOne
)
;
await
list
.
add
(
await
promiseNewDownload
(
)
)
;
Assert
.
equal
(
addNotifications
3
)
;
}
}
)
;
add_task
(
async
function
test_notifications_change
(
)
{
for
(
let
isCombined
of
[
false
true
]
)
{
let
list
=
await
promiseNewList
(
)
;
if
(
isCombined
)
{
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
}
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
isPrivate
:
true
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
let
receivedOnDownloadChanged
=
false
;
list
.
addView
(
{
onDownloadChanged
(
aDownload
)
{
Assert
.
equal
(
aDownload
downloadOne
)
;
receivedOnDownloadChanged
=
true
;
}
}
)
;
await
downloadOne
.
start
(
)
;
Assert
.
ok
(
receivedOnDownloadChanged
)
;
receivedOnDownloadChanged
=
false
;
await
list
.
remove
(
downloadTwo
)
;
await
downloadTwo
.
start
(
)
;
Assert
.
ok
(
!
receivedOnDownloadChanged
)
;
}
}
)
;
add_task
(
async
function
test_notifications_this
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
receivedOnDownloadAdded
=
false
;
let
receivedOnDownloadChanged
=
false
;
let
receivedOnDownloadRemoved
=
false
;
let
view
=
{
onDownloadAdded
(
)
{
Assert
.
equal
(
this
view
)
;
receivedOnDownloadAdded
=
true
;
}
onDownloadChanged
(
)
{
if
(
!
receivedOnDownloadChanged
)
{
Assert
.
equal
(
this
view
)
;
receivedOnDownloadChanged
=
true
;
}
}
onDownloadRemoved
(
)
{
Assert
.
equal
(
this
view
)
;
receivedOnDownloadRemoved
=
true
;
}
}
;
list
.
addView
(
view
)
;
let
download
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
download
)
;
await
download
.
start
(
)
;
await
list
.
remove
(
download
)
;
Assert
.
ok
(
receivedOnDownloadAdded
)
;
Assert
.
ok
(
receivedOnDownloadChanged
)
;
Assert
.
ok
(
receivedOnDownloadRemoved
)
;
}
)
;
add_task
(
async
function
test_history_expiration
(
)
{
mustInterruptResponses
(
)
;
function
cleanup
(
)
{
Services
.
prefs
.
clearUserPref
(
"
places
.
history
.
expiration
.
max_pages
"
)
;
}
registerCleanupFunction
(
cleanup
)
;
Services
.
prefs
.
setIntPref
(
"
places
.
history
.
expiration
.
max_pages
"
0
)
;
let
list
=
await
promiseNewList
(
)
;
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
deferred
=
Promise
.
withResolvers
(
)
;
let
removeNotifications
=
0
;
let
downloadView
=
{
onDownloadRemoved
(
)
{
if
(
+
+
removeNotifications
=
=
2
)
{
deferred
.
resolve
(
)
;
}
}
}
;
list
.
addView
(
downloadView
)
;
await
downloadOne
.
start
(
)
;
downloadTwo
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
downloadTwo
.
cancel
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
promiseExpirableDownloadVisit
(
)
;
await
promiseExpirableDownloadVisit
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
Cc
[
"
mozilla
.
org
/
places
/
expiration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
observe
(
null
"
places
-
debug
-
start
-
expiration
"
-
1
)
;
await
deferred
.
promise
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_history_clear
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
let
deferred
=
Promise
.
withResolvers
(
)
;
let
removeNotifications
=
0
;
let
downloadView
=
{
onDownloadRemoved
(
)
{
if
(
+
+
removeNotifications
=
=
2
)
{
deferred
.
resolve
(
)
;
}
}
}
;
list
.
addView
(
downloadView
)
;
await
downloadOne
.
start
(
)
;
await
downloadTwo
.
start
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
deferred
.
promise
;
}
)
;
add_task
(
async
function
test_removeFinished
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
promiseNewDownload
(
)
;
let
downloadThree
=
await
promiseNewDownload
(
)
;
let
downloadFour
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
await
list
.
add
(
downloadThree
)
;
await
list
.
add
(
downloadFour
)
;
let
deferred
=
Promise
.
withResolvers
(
)
;
let
removeNotifications
=
0
;
let
downloadView
=
{
onDownloadRemoved
(
aDownload
)
{
Assert
.
ok
(
aDownload
=
=
downloadOne
|
|
aDownload
=
=
downloadTwo
|
|
aDownload
=
=
downloadThree
)
;
Assert
.
less
(
removeNotifications
3
)
;
if
(
+
+
removeNotifications
=
=
3
)
{
deferred
.
resolve
(
)
;
}
}
}
;
list
.
addView
(
downloadView
)
;
await
downloadOne
.
start
(
)
;
await
downloadThree
.
start
(
)
;
await
downloadFour
.
start
(
)
;
downloadFour
.
hasPartialData
=
true
;
list
.
removeFinished
(
)
;
await
deferred
.
promise
;
let
downloads
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
downloads
.
length
1
)
;
}
)
;
add_task
(
async
function
test_removeFinished_keepsDownloadingFile
(
)
{
let
targetFile
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
;
let
oneDownload
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
empty
.
txt
"
)
target
:
targetFile
.
path
}
)
;
let
otherDownload
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
empty
.
txt
"
)
target
:
targetFile
.
path
}
)
;
let
list
=
await
promiseNewList
(
)
;
await
list
.
add
(
oneDownload
)
;
await
list
.
add
(
otherDownload
)
;
let
deferred
=
Promise
.
withResolvers
(
)
;
let
downloadView
=
{
async
onDownloadRemoved
(
aDownload
)
{
Assert
.
equal
(
aDownload
oneDownload
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
oneDownload
.
_finalizeExecuted
)
;
deferred
.
resolve
(
)
;
}
}
;
list
.
addView
(
downloadView
)
;
await
oneDownload
.
start
(
)
;
await
otherDownload
.
start
(
)
;
oneDownload
.
hasPartialData
=
otherDownload
.
hasPartialData
=
true
;
oneDownload
.
error
=
"
Download
failed
"
;
list
.
removeFinished
(
)
;
await
deferred
.
promise
;
let
downloads
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
downloads
.
length
1
"
Failed
download
should
be
removed
active
download
should
be
kept
"
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
otherDownload
.
target
.
path
)
"
The
file
should
not
have
been
deleted
.
"
)
;
}
)
;
add_task
(
async
function
test_DownloadSummary
(
)
{
mustInterruptResponses
(
)
;
let
publicList
=
await
promiseNewList
(
)
;
let
privateList
=
await
Downloads
.
getList
(
Downloads
.
PRIVATE
)
;
let
publicSummary
=
await
Downloads
.
getSummary
(
Downloads
.
PUBLIC
)
;
let
privateSummary
=
await
Downloads
.
getSummary
(
Downloads
.
PRIVATE
)
;
let
combinedSummary
=
await
Downloads
.
getSummary
(
Downloads
.
ALL
)
;
let
succeededPublicDownload
=
await
promiseNewDownload
(
)
;
await
succeededPublicDownload
.
start
(
)
;
await
publicList
.
add
(
succeededPublicDownload
)
;
let
canceledPublicDownload
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
canceledPublicDownload
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
promiseDownloadMidway
(
canceledPublicDownload
)
;
await
canceledPublicDownload
.
cancel
(
)
;
await
publicList
.
add
(
canceledPublicDownload
)
;
let
inProgressPublicDownload
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
inProgressPublicDownload
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
promiseDownloadMidway
(
inProgressPublicDownload
)
;
await
publicList
.
add
(
inProgressPublicDownload
)
;
let
inProgressSizelessPublicDownload
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible_nosize
.
txt
"
)
)
;
inProgressSizelessPublicDownload
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
promiseDownloadStarted
(
inProgressSizelessPublicDownload
)
;
await
publicList
.
add
(
inProgressSizelessPublicDownload
)
;
let
inProgressPrivateDownload
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
interruptible
.
txt
"
)
isPrivate
:
true
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
)
;
inProgressPrivateDownload
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
promiseDownloadMidway
(
inProgressPrivateDownload
)
;
await
privateList
.
add
(
inProgressPrivateDownload
)
;
Assert
.
ok
(
!
publicSummary
.
allHaveStopped
)
;
Assert
.
ok
(
!
publicSummary
.
allUnknownSize
)
;
Assert
.
equal
(
publicSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
3
)
;
Assert
.
equal
(
publicSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
*
2
)
;
Assert
.
ok
(
!
privateSummary
.
allHaveStopped
)
;
Assert
.
ok
(
!
privateSummary
.
allUnknownSize
)
;
Assert
.
equal
(
privateSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
2
)
;
Assert
.
equal
(
privateSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
)
;
Assert
.
ok
(
!
combinedSummary
.
allHaveStopped
)
;
Assert
.
ok
(
!
combinedSummary
.
allUnknownSize
)
;
Assert
.
equal
(
combinedSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
5
)
;
Assert
.
equal
(
combinedSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
*
3
)
;
await
inProgressPublicDownload
.
cancel
(
)
;
Assert
.
ok
(
!
publicSummary
.
allHaveStopped
)
;
Assert
.
ok
(
publicSummary
.
allUnknownSize
)
;
Assert
.
equal
(
publicSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
)
;
Assert
.
equal
(
publicSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
)
;
Assert
.
ok
(
!
privateSummary
.
allHaveStopped
)
;
Assert
.
ok
(
!
privateSummary
.
allUnknownSize
)
;
Assert
.
equal
(
privateSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
2
)
;
Assert
.
equal
(
privateSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
)
;
Assert
.
ok
(
!
combinedSummary
.
allHaveStopped
)
;
Assert
.
ok
(
!
combinedSummary
.
allUnknownSize
)
;
Assert
.
equal
(
combinedSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
3
)
;
Assert
.
equal
(
combinedSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
*
2
)
;
await
inProgressPrivateDownload
.
cancel
(
)
;
Assert
.
ok
(
!
publicSummary
.
allHaveStopped
)
;
Assert
.
ok
(
publicSummary
.
allUnknownSize
)
;
Assert
.
equal
(
publicSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
)
;
Assert
.
equal
(
publicSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
)
;
Assert
.
ok
(
privateSummary
.
allHaveStopped
)
;
Assert
.
ok
(
privateSummary
.
allUnknownSize
)
;
Assert
.
equal
(
privateSummary
.
progressTotalBytes
0
)
;
Assert
.
equal
(
privateSummary
.
progressCurrentBytes
0
)
;
Assert
.
ok
(
!
combinedSummary
.
allHaveStopped
)
;
Assert
.
ok
(
combinedSummary
.
allUnknownSize
)
;
Assert
.
equal
(
combinedSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
)
;
Assert
.
equal
(
combinedSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
)
;
await
inProgressSizelessPublicDownload
.
cancel
(
)
;
Assert
.
ok
(
publicSummary
.
allHaveStopped
)
;
Assert
.
ok
(
publicSummary
.
allUnknownSize
)
;
Assert
.
equal
(
publicSummary
.
progressTotalBytes
0
)
;
Assert
.
equal
(
publicSummary
.
progressCurrentBytes
0
)
;
Assert
.
ok
(
privateSummary
.
allHaveStopped
)
;
Assert
.
ok
(
privateSummary
.
allUnknownSize
)
;
Assert
.
equal
(
privateSummary
.
progressTotalBytes
0
)
;
Assert
.
equal
(
privateSummary
.
progressCurrentBytes
0
)
;
Assert
.
ok
(
combinedSummary
.
allHaveStopped
)
;
Assert
.
ok
(
combinedSummary
.
allUnknownSize
)
;
Assert
.
equal
(
combinedSummary
.
progressTotalBytes
0
)
;
Assert
.
equal
(
combinedSummary
.
progressCurrentBytes
0
)
;
}
)
;
add_task
(
async
function
test_DownloadSummary_notifications
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
summary
=
await
Downloads
.
getSummary
(
Downloads
.
ALL
)
;
let
download
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
download
)
;
let
receivedOnSummaryChanged
=
false
;
await
summary
.
addView
(
{
onSummaryChanged
(
)
{
receivedOnSummaryChanged
=
true
;
}
}
)
;
await
download
.
start
(
)
;
Assert
.
ok
(
receivedOnSummaryChanged
)
;
}
)
;
add_task
(
async
function
test_downloadAddedTelemetry
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
let
targetFile
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
;
let
download
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
empty
.
txt
"
)
target
:
targetFile
.
path
}
)
;
let
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
await
list
.
add
(
download
)
;
download
.
start
(
)
;
await
promiseDownloadFinished
(
download
)
;
TelemetryTestUtils
.
assertEvents
(
[
{
category
:
"
downloads
"
method
:
"
added
"
object
:
"
fileExtension
"
value
:
"
txt
"
}
]
)
;
}
)
;
