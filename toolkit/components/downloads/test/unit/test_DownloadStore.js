"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadStore
"
"
resource
:
/
/
gre
/
modules
/
DownloadStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
function
promiseNewListAndStore
(
aStorePath
)
{
return
promiseNewList
(
)
.
then
(
function
(
aList
)
{
let
path
=
aStorePath
|
|
getTempFile
(
TEST_STORE_FILE_NAME
)
.
path
;
let
store
=
new
DownloadStore
(
aList
path
)
;
return
[
aList
store
]
;
}
)
;
}
add_task
(
async
function
test_save_reload
(
)
{
let
[
listForSave
storeForSave
]
=
await
promiseNewListAndStore
(
)
;
let
[
listForLoad
storeForLoad
]
=
await
promiseNewListAndStore
(
storeForSave
.
path
)
;
listForSave
.
add
(
await
promiseNewDownload
(
httpUrl
(
"
source
.
txt
"
)
)
)
;
listForSave
.
add
(
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
empty
.
txt
"
)
referrer
:
TEST_REFERRER_URL
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
}
)
)
;
let
pdfDownload
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
empty
.
txt
"
)
referrer
:
TEST_REFERRER_URL
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
saver
:
"
pdf
"
}
)
;
listForSave
.
add
(
pdfDownload
)
;
let
adjustedDownload
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
empty
.
txt
"
)
adjustChannel
:
(
)
=
>
Promise
.
resolve
(
)
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
}
)
;
listForSave
.
add
(
adjustedDownload
)
;
let
legacyDownload
=
await
promiseStartLegacyDownload
(
)
;
await
legacyDownload
.
cancel
(
)
;
listForSave
.
add
(
legacyDownload
)
;
await
storeForSave
.
save
(
)
;
await
storeForLoad
.
load
(
)
;
listForSave
.
remove
(
adjustedDownload
)
;
listForSave
.
remove
(
pdfDownload
)
;
let
itemsForSave
=
await
listForSave
.
getAll
(
)
;
let
itemsForLoad
=
await
listForLoad
.
getAll
(
)
;
Assert
.
equal
(
itemsForSave
.
length
itemsForLoad
.
length
)
;
for
(
let
i
=
0
;
i
<
itemsForSave
.
length
;
i
+
+
)
{
Assert
.
notEqual
(
itemsForSave
[
i
]
itemsForLoad
[
i
]
)
;
Assert
.
equal
(
itemsForSave
[
i
]
.
source
.
url
itemsForLoad
[
i
]
.
source
.
url
)
;
Assert
.
equal
(
itemsForSave
[
i
]
.
source
.
referrer
itemsForLoad
[
i
]
.
source
.
referrer
)
;
Assert
.
equal
(
itemsForSave
[
i
]
.
target
.
path
itemsForLoad
[
i
]
.
target
.
path
)
;
Assert
.
equal
(
itemsForSave
[
i
]
.
saver
.
toSerializable
(
)
itemsForLoad
[
i
]
.
saver
.
toSerializable
(
)
)
;
}
}
)
;
add_task
(
async
function
test_save_empty
(
)
{
let
[
store
]
=
await
promiseNewListAndStore
(
)
;
let
createdFile
=
await
OS
.
File
.
open
(
store
.
path
{
create
:
true
}
)
;
await
createdFile
.
close
(
)
;
await
store
.
save
(
)
;
Assert
.
equal
(
false
await
OS
.
File
.
exists
(
store
.
path
)
)
;
await
store
.
save
(
)
;
}
)
;
add_task
(
async
function
test_load_empty
(
)
{
let
[
list
store
]
=
await
promiseNewListAndStore
(
)
;
Assert
.
equal
(
false
await
OS
.
File
.
exists
(
store
.
path
)
)
;
await
store
.
load
(
)
;
let
items
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
0
)
;
}
)
;
add_task
(
async
function
test_load_string_predefined
(
)
{
let
[
list
store
]
=
await
promiseNewListAndStore
(
)
;
let
targetPath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
let
filePathLiteral
=
JSON
.
stringify
(
targetPath
)
;
let
sourceUriLiteral
=
JSON
.
stringify
(
httpUrl
(
"
source
.
txt
"
)
)
;
let
emptyUriLiteral
=
JSON
.
stringify
(
httpUrl
(
"
empty
.
txt
"
)
)
;
let
referrerUriLiteral
=
JSON
.
stringify
(
TEST_REFERRER_URL
)
;
let
string
=
'
{
"
list
"
:
[
{
"
source
"
:
'
+
sourceUriLiteral
+
"
"
+
'
"
target
"
:
'
+
filePathLiteral
+
"
}
"
+
'
{
"
source
"
:
{
"
url
"
:
'
+
emptyUriLiteral
+
"
"
+
'
"
referrer
"
:
'
+
referrerUriLiteral
+
"
}
"
+
'
"
target
"
:
'
+
filePathLiteral
+
"
}
]
}
"
;
await
OS
.
File
.
writeAtomic
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
await
store
.
load
(
)
;
let
items
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
2
)
;
Assert
.
equal
(
items
[
0
]
.
source
.
url
httpUrl
(
"
source
.
txt
"
)
)
;
Assert
.
equal
(
items
[
0
]
.
target
.
path
targetPath
)
;
Assert
.
equal
(
items
[
1
]
.
source
.
url
httpUrl
(
"
empty
.
txt
"
)
)
;
Assert
.
equal
(
items
[
1
]
.
source
.
referrer
TEST_REFERRER_URL
)
;
Assert
.
equal
(
items
[
1
]
.
target
.
path
targetPath
)
;
}
)
;
add_task
(
async
function
test_load_string_unrecognized
(
)
{
let
[
list
store
]
=
await
promiseNewListAndStore
(
)
;
let
targetPath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
let
filePathLiteral
=
JSON
.
stringify
(
targetPath
)
;
let
sourceUriLiteral
=
JSON
.
stringify
(
httpUrl
(
"
source
.
txt
"
)
)
;
let
string
=
'
{
"
list
"
:
[
{
"
source
"
:
null
'
+
'
"
target
"
:
null
}
'
+
'
{
"
source
"
:
{
"
url
"
:
'
+
sourceUriLiteral
+
"
}
"
+
'
"
target
"
:
{
"
path
"
:
'
+
filePathLiteral
+
"
}
"
+
'
"
saver
"
:
{
"
type
"
:
"
copy
"
}
}
]
}
'
;
await
OS
.
File
.
writeAtomic
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
await
store
.
load
(
)
;
let
items
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
1
)
;
Assert
.
equal
(
items
[
0
]
.
source
.
url
httpUrl
(
"
source
.
txt
"
)
)
;
Assert
.
equal
(
items
[
0
]
.
target
.
path
targetPath
)
;
}
)
;
add_task
(
async
function
test_load_string_malformed
(
)
{
let
[
list
store
]
=
await
promiseNewListAndStore
(
)
;
let
string
=
'
{
"
list
"
:
[
{
"
source
"
:
null
"
target
"
:
null
}
'
+
'
{
"
source
"
:
{
"
url
"
:
"
about
:
blank
"
}
}
}
'
;
await
OS
.
File
.
writeAtomic
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
try
{
await
store
.
load
(
)
;
do_throw
(
"
Exception
expected
when
JSON
data
is
malformed
.
"
)
;
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
"
SyntaxError
"
)
{
throw
ex
;
}
info
(
"
The
expected
SyntaxError
exception
was
thrown
.
"
)
;
}
let
items
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
0
)
;
}
)
;
add_task
(
async
function
test_save_reload_unknownProperties
(
)
{
let
[
listForSave
storeForSave
]
=
await
promiseNewListAndStore
(
)
;
let
[
listForLoad
storeForLoad
]
=
await
promiseNewListAndStore
(
storeForSave
.
path
)
;
let
download1
=
await
promiseNewDownload
(
httpUrl
(
"
source
.
txt
"
)
)
;
download1
.
_unknownProperties
=
{
peanut
:
"
butter
"
orange
:
"
marmalade
"
startTime
:
77
error
:
{
message
:
"
Passed
"
}
}
;
listForSave
.
add
(
download1
)
;
let
download2
=
await
promiseStartLegacyDownload
(
)
;
await
download2
.
cancel
(
)
;
download2
.
_unknownProperties
=
{
number
:
5
object
:
{
test
:
"
string
"
}
}
;
listForSave
.
add
(
download2
)
;
let
download3
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
empty
.
txt
"
)
referrer
:
TEST_REFERRER_URL
source1
:
"
download3source1
"
source2
:
"
download3source2
"
}
target
:
{
path
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
target1
:
"
download3target1
"
target2
:
"
download3target2
"
}
saver
:
{
type
:
"
copy
"
saver1
:
"
download3saver1
"
saver2
:
"
download3saver2
"
}
}
)
;
listForSave
.
add
(
download3
)
;
await
storeForSave
.
save
(
)
;
await
storeForLoad
.
load
(
)
;
let
itemsForSave
=
await
listForSave
.
getAll
(
)
;
let
itemsForLoad
=
await
listForLoad
.
getAll
(
)
;
Assert
.
equal
(
itemsForSave
.
length
itemsForLoad
.
length
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
0
]
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
0
]
.
_unknownProperties
.
peanut
"
butter
"
)
;
Assert
.
equal
(
itemsForLoad
[
0
]
.
_unknownProperties
.
orange
"
marmalade
"
)
;
Assert
.
equal
(
false
"
startTime
"
in
itemsForLoad
[
0
]
.
_unknownProperties
)
;
Assert
.
equal
(
false
"
error
"
in
itemsForLoad
[
0
]
.
_unknownProperties
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
1
]
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
1
]
.
_unknownProperties
.
number
5
)
;
Assert
.
equal
(
itemsForLoad
[
1
]
.
_unknownProperties
.
object
.
test
"
string
"
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
2
]
.
source
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
source
.
_unknownProperties
.
source1
"
download3source1
"
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
source
.
_unknownProperties
.
source2
"
download3source2
"
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
2
]
.
target
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
target
.
_unknownProperties
.
target1
"
download3target1
"
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
target
.
_unknownProperties
.
target2
"
download3target2
"
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
2
]
.
saver
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
saver
.
_unknownProperties
.
saver1
"
download3saver1
"
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
saver
.
_unknownProperties
.
saver2
"
download3saver2
"
)
;
}
)
;
