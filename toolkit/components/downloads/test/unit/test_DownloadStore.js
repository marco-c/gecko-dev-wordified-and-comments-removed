"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadStore
"
"
resource
:
/
/
gre
/
modules
/
DownloadStore
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DownloadError
"
"
resource
:
/
/
gre
/
modules
/
DownloadCore
.
jsm
"
)
;
function
promiseNewListAndStore
(
aStorePath
)
{
return
promiseNewList
(
)
.
then
(
function
(
aList
)
{
let
path
=
aStorePath
|
|
getTempFile
(
TEST_STORE_FILE_NAME
)
.
path
;
let
store
=
new
DownloadStore
(
aList
path
)
;
return
[
aList
store
]
;
}
)
;
}
add_task
(
async
function
test_save_reload
(
)
{
let
[
listForSave
storeForSave
]
=
await
promiseNewListAndStore
(
)
;
let
[
listForLoad
storeForLoad
]
=
await
promiseNewListAndStore
(
storeForSave
.
path
)
;
let
referrerInfo
=
new
ReferrerInfo
(
Ci
.
nsIReferrerInfo
.
EMPTY
true
NetUtil
.
newURI
(
TEST_REFERRER_URL
)
)
;
listForSave
.
add
(
await
promiseNewDownload
(
httpUrl
(
"
source
.
txt
"
)
)
)
;
listForSave
.
add
(
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
empty
.
txt
"
)
referrerInfo
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
}
)
)
;
let
adjustedDownload
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
empty
.
txt
"
)
adjustChannel
:
(
)
=
>
Promise
.
resolve
(
)
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
}
)
;
listForSave
.
add
(
adjustedDownload
)
;
let
legacyDownload
=
await
promiseStartLegacyDownload
(
)
;
await
legacyDownload
.
cancel
(
)
;
listForSave
.
add
(
legacyDownload
)
;
await
storeForSave
.
save
(
)
;
await
storeForLoad
.
load
(
)
;
listForSave
.
remove
(
adjustedDownload
)
;
let
itemsForSave
=
await
listForSave
.
getAll
(
)
;
let
itemsForLoad
=
await
listForLoad
.
getAll
(
)
;
Assert
.
equal
(
itemsForSave
.
length
itemsForLoad
.
length
)
;
for
(
let
i
=
0
;
i
<
itemsForSave
.
length
;
i
+
+
)
{
Assert
.
notEqual
(
itemsForSave
[
i
]
itemsForLoad
[
i
]
)
;
Assert
.
equal
(
itemsForSave
[
i
]
.
source
.
url
itemsForLoad
[
i
]
.
source
.
url
)
;
Assert
.
equal
(
!
!
itemsForSave
[
i
]
.
source
.
referrerInfo
!
!
itemsForLoad
[
i
]
.
source
.
referrerInfo
)
;
if
(
itemsForSave
[
i
]
.
source
.
referrerInfo
&
&
itemsForLoad
[
i
]
.
source
.
referrerInfo
)
{
Assert
.
ok
(
itemsForSave
[
i
]
.
source
.
referrerInfo
.
equals
(
itemsForLoad
[
i
]
.
source
.
referrerInfo
)
)
;
}
Assert
.
equal
(
itemsForSave
[
i
]
.
target
.
path
itemsForLoad
[
i
]
.
target
.
path
)
;
Assert
.
equal
(
itemsForSave
[
i
]
.
saver
.
toSerializable
(
)
itemsForLoad
[
i
]
.
saver
.
toSerializable
(
)
)
;
}
}
)
;
add_task
(
async
function
test_save_empty
(
)
{
let
[
store
]
=
await
promiseNewListAndStore
(
)
;
await
IOUtils
.
write
(
store
.
path
new
Uint8Array
(
)
)
;
await
store
.
save
(
)
;
let
successful
;
try
{
await
IOUtils
.
read
(
store
.
path
)
;
successful
=
true
;
}
catch
(
ex
)
{
successful
=
ex
.
name
!
=
"
NotFoundError
"
;
}
ok
(
!
successful
"
File
should
not
exist
"
)
;
await
store
.
save
(
)
;
}
)
;
add_task
(
async
function
test_load_empty
(
)
{
let
[
list
store
]
=
await
promiseNewListAndStore
(
)
;
let
succeesful
;
try
{
await
IOUtils
.
read
(
store
.
path
)
;
succeesful
=
true
;
}
catch
(
ex
)
{
succeesful
=
ex
.
name
!
=
"
NotFoundError
"
;
}
ok
(
!
succeesful
"
File
should
not
exist
"
)
;
let
items
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
0
)
;
}
)
;
add_task
(
async
function
test_load_string_predefined
(
)
{
let
[
list
store
]
=
await
promiseNewListAndStore
(
)
;
let
targetPath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
let
filePathLiteral
=
JSON
.
stringify
(
targetPath
)
;
let
sourceUriLiteral
=
JSON
.
stringify
(
httpUrl
(
"
source
.
txt
"
)
)
;
let
emptyUriLiteral
=
JSON
.
stringify
(
httpUrl
(
"
empty
.
txt
"
)
)
;
let
referrerInfo
=
new
ReferrerInfo
(
Ci
.
nsIReferrerInfo
.
EMPTY
true
NetUtil
.
newURI
(
TEST_REFERRER_URL
)
)
;
let
referrerInfoLiteral
=
JSON
.
stringify
(
E10SUtils
.
serializeReferrerInfo
(
referrerInfo
)
)
;
let
string
=
'
{
"
list
"
:
[
{
"
source
"
:
'
+
sourceUriLiteral
+
"
"
+
'
"
target
"
:
'
+
filePathLiteral
+
"
}
"
+
'
{
"
source
"
:
{
"
url
"
:
'
+
emptyUriLiteral
+
"
"
+
'
"
referrerInfo
"
:
'
+
referrerInfoLiteral
+
"
}
"
+
'
"
target
"
:
'
+
filePathLiteral
+
"
}
]
}
"
;
await
IOUtils
.
write
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
await
store
.
load
(
)
;
let
items
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
2
)
;
Assert
.
equal
(
items
[
0
]
.
source
.
url
httpUrl
(
"
source
.
txt
"
)
)
;
Assert
.
equal
(
items
[
0
]
.
target
.
path
targetPath
)
;
Assert
.
equal
(
items
[
1
]
.
source
.
url
httpUrl
(
"
empty
.
txt
"
)
)
;
checkEqualReferrerInfos
(
items
[
1
]
.
source
.
referrerInfo
referrerInfo
)
;
Assert
.
equal
(
items
[
1
]
.
target
.
path
targetPath
)
;
}
)
;
add_task
(
async
function
test_load_string_unrecognized
(
)
{
let
[
list
store
]
=
await
promiseNewListAndStore
(
)
;
let
targetPath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
let
filePathLiteral
=
JSON
.
stringify
(
targetPath
)
;
let
sourceUriLiteral
=
JSON
.
stringify
(
httpUrl
(
"
source
.
txt
"
)
)
;
let
string
=
'
{
"
list
"
:
[
{
"
source
"
:
null
'
+
'
"
target
"
:
null
}
'
+
'
{
"
source
"
:
{
"
url
"
:
'
+
sourceUriLiteral
+
"
}
"
+
'
"
target
"
:
{
"
path
"
:
'
+
filePathLiteral
+
"
}
"
+
'
"
saver
"
:
{
"
type
"
:
"
copy
"
}
}
]
}
'
;
await
IOUtils
.
write
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
await
store
.
load
(
)
;
let
items
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
1
)
;
Assert
.
equal
(
items
[
0
]
.
source
.
url
httpUrl
(
"
source
.
txt
"
)
)
;
Assert
.
equal
(
items
[
0
]
.
target
.
path
targetPath
)
;
}
)
;
add_task
(
async
function
test_load_string_malformed
(
)
{
let
[
list
store
]
=
await
promiseNewListAndStore
(
)
;
let
string
=
'
{
"
list
"
:
[
{
"
source
"
:
null
"
target
"
:
null
}
'
+
'
{
"
source
"
:
{
"
url
"
:
"
about
:
blank
"
}
}
}
'
;
await
IOUtils
.
write
(
store
.
path
new
TextEncoder
(
)
.
encode
(
string
)
{
tmpPath
:
store
.
path
+
"
.
tmp
"
}
)
;
try
{
await
store
.
load
(
)
;
do_throw
(
"
Exception
expected
when
JSON
data
is
malformed
.
"
)
;
}
catch
(
ex
)
{
if
(
ex
.
name
!
=
"
SyntaxError
"
)
{
throw
ex
;
}
info
(
"
The
expected
SyntaxError
exception
was
thrown
.
"
)
;
}
let
items
=
await
list
.
getAll
(
)
;
Assert
.
equal
(
items
.
length
0
)
;
}
)
;
add_task
(
async
function
test_save_reload_unknownProperties
(
)
{
let
[
listForSave
storeForSave
]
=
await
promiseNewListAndStore
(
)
;
let
[
listForLoad
storeForLoad
]
=
await
promiseNewListAndStore
(
storeForSave
.
path
)
;
let
download1
=
await
promiseNewDownload
(
httpUrl
(
"
source
.
txt
"
)
)
;
download1
.
_unknownProperties
=
{
peanut
:
"
butter
"
orange
:
"
marmalade
"
startTime
:
77
error
:
{
message
:
"
Passed
"
}
}
;
listForSave
.
add
(
download1
)
;
let
download2
=
await
promiseStartLegacyDownload
(
)
;
await
download2
.
cancel
(
)
;
download2
.
_unknownProperties
=
{
number
:
5
object
:
{
test
:
"
string
"
}
}
;
listForSave
.
add
(
download2
)
;
let
referrerInfo
=
new
ReferrerInfo
(
Ci
.
nsIReferrerInfo
.
EMPTY
true
NetUtil
.
newURI
(
TEST_REFERRER_URL
)
)
;
let
download3
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
empty
.
txt
"
)
referrerInfo
source1
:
"
download3source1
"
source2
:
"
download3source2
"
}
target
:
{
path
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
target1
:
"
download3target1
"
target2
:
"
download3target2
"
}
saver
:
{
type
:
"
copy
"
saver1
:
"
download3saver1
"
saver2
:
"
download3saver2
"
}
}
)
;
listForSave
.
add
(
download3
)
;
await
storeForSave
.
save
(
)
;
await
storeForLoad
.
load
(
)
;
let
itemsForSave
=
await
listForSave
.
getAll
(
)
;
let
itemsForLoad
=
await
listForLoad
.
getAll
(
)
;
Assert
.
equal
(
itemsForSave
.
length
itemsForLoad
.
length
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
0
]
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
0
]
.
_unknownProperties
.
peanut
"
butter
"
)
;
Assert
.
equal
(
itemsForLoad
[
0
]
.
_unknownProperties
.
orange
"
marmalade
"
)
;
Assert
.
equal
(
false
"
startTime
"
in
itemsForLoad
[
0
]
.
_unknownProperties
)
;
Assert
.
equal
(
false
"
error
"
in
itemsForLoad
[
0
]
.
_unknownProperties
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
1
]
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
1
]
.
_unknownProperties
.
number
5
)
;
Assert
.
equal
(
itemsForLoad
[
1
]
.
_unknownProperties
.
object
.
test
"
string
"
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
2
]
.
source
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
source
.
_unknownProperties
.
source1
"
download3source1
"
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
source
.
_unknownProperties
.
source2
"
download3source2
"
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
2
]
.
target
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
target
.
_unknownProperties
.
target1
"
download3target1
"
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
target
.
_unknownProperties
.
target2
"
download3target2
"
)
;
Assert
.
equal
(
Object
.
keys
(
itemsForLoad
[
2
]
.
saver
.
_unknownProperties
)
.
length
2
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
saver
.
_unknownProperties
.
saver1
"
download3saver1
"
)
;
Assert
.
equal
(
itemsForLoad
[
2
]
.
saver
.
_unknownProperties
.
saver2
"
download3saver2
"
)
;
}
)
;
add_task
(
async
function
test_insecure_download_deletion
(
)
{
let
[
listForSave
storeForSave
]
=
await
promiseNewListAndStore
(
)
;
let
[
listForLoad
storeForLoad
]
=
await
promiseNewListAndStore
(
storeForSave
.
path
)
;
let
referrerInfo
=
new
ReferrerInfo
(
Ci
.
nsIReferrerInfo
.
EMPTY
true
NetUtil
.
newURI
(
TEST_REFERRER_URL
)
)
;
const
createTestDownload
=
async
startTime
=
>
{
let
targetFile
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
;
let
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
empty
.
txt
"
)
referrerInfo
}
target
:
targetFile
.
path
startTime
:
new
Date
(
)
.
toISOString
(
)
contentType
:
"
application
/
zip
"
}
)
;
await
download
.
start
(
)
;
download
.
hasBlockedData
=
true
;
download
.
error
=
DownloadError
.
fromSerializable
(
{
becauseBlockedByReputationCheck
:
true
reputationCheckVerdict
:
"
Insecure
"
}
)
;
download
.
startTime
=
startTime
;
let
targetPath
=
download
.
target
.
path
;
listForSave
.
add
(
download
)
;
await
storeForSave
.
save
(
)
;
await
storeForLoad
.
load
(
)
;
let
loadedDownloadList
=
await
listForLoad
.
getAll
(
)
;
return
[
loadedDownloadList
targetPath
]
;
}
;
let
[
loadedDownloadList1
targetPath1
]
=
await
createTestDownload
(
new
Date
(
Date
.
now
(
)
-
360000
)
)
;
Assert
.
equal
(
loadedDownloadList1
.
length
0
"
Download
should
be
removed
"
)
;
Assert
.
ok
(
!
(
await
OS
.
File
.
exists
(
targetPath1
)
)
"
The
file
should
have
been
deleted
.
"
)
;
let
[
loadedDownloadList2
targetPath2
]
=
await
createTestDownload
(
new
Date
(
)
)
;
Assert
.
equal
(
loadedDownloadList2
.
length
1
"
Download
should
be
kept
"
)
;
Assert
.
ok
(
await
OS
.
File
.
exists
(
targetPath2
)
"
The
file
should
have
not
been
deleted
.
"
)
;
}
)
;
