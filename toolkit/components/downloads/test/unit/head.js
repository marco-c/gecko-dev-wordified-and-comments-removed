"
use
strict
"
;
var
{
Integration
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Integration
.
jsm
"
)
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
DownloadPaths
:
"
resource
:
/
/
gre
/
modules
/
DownloadPaths
.
jsm
"
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
E10SUtils
:
"
resource
:
/
/
gre
/
modules
/
E10SUtils
.
jsm
"
FileTestUtils
:
"
resource
:
/
/
testing
-
common
/
FileTestUtils
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
HttpServer
:
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
MockRegistrar
:
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
TelemetryTestUtils
:
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
TestUtils
:
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gExternalHelperAppService
"
"
mozilla
.
org
/
uriloader
/
external
-
helper
-
app
-
service
;
1
"
Ci
.
nsIExternalHelperAppService
)
;
Integration
.
downloads
.
defineModuleGetter
(
this
"
DownloadIntegration
"
"
resource
:
/
/
gre
/
modules
/
DownloadIntegration
.
jsm
"
)
;
const
ServerSocket
=
Components
.
Constructor
(
"
mozilla
.
org
/
network
/
server
-
socket
;
1
"
"
nsIServerSocket
"
"
init
"
)
;
const
BinaryOutputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
binaryoutputstream
;
1
"
"
nsIBinaryOutputStream
"
"
setOutputStream
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gMIMEService
"
"
mozilla
.
org
/
mime
;
1
"
"
nsIMIMEService
"
)
;
const
ReferrerInfo
=
Components
.
Constructor
(
"
mozilla
.
org
/
referrer
-
info
;
1
"
"
nsIReferrerInfo
"
"
init
"
)
;
const
TEST_TARGET_FILE_NAME
=
"
test
-
download
.
txt
"
;
const
TEST_STORE_FILE_NAME
=
"
test
-
downloads
.
json
"
;
const
TEST_REFERRER_URL
=
"
https
:
/
/
www
.
example
.
com
/
referrer
.
html
"
;
const
TEST_DATA_SHORT
=
"
This
test
string
is
downloaded
.
"
;
const
TEST_DATA_SHORT_GZIP_ENCODED_FIRST
=
[
31
139
8
0
0
0
0
0
0
3
11
201
200
44
86
40
73
45
46
81
40
46
41
202
204
]
;
const
TEST_DATA_SHORT_GZIP_ENCODED_SECOND
=
[
75
87
0
114
83
242
203
243
114
242
19
83
82
83
244
0
151
222
109
43
31
0
0
0
]
;
const
TEST_DATA_SHORT_GZIP_ENCODED
=
TEST_DATA_SHORT_GZIP_ENCODED_FIRST
.
concat
(
TEST_DATA_SHORT_GZIP_ENCODED_SECOND
)
;
function
run_test
(
)
{
do_get_profile
(
)
;
run_next_test
(
)
;
}
var
gHttpServer
;
function
httpUrl
(
aFileName
)
{
return
(
"
http
:
/
/
www
.
example
.
com
:
"
+
gHttpServer
.
identity
.
primaryPort
+
"
/
"
+
aFileName
)
;
}
function
getTempFile
(
leafName
)
{
return
FileTestUtils
.
getTempFile
(
leafName
)
;
}
async
function
fileExists
(
path
)
{
try
{
return
(
await
IOUtils
.
stat
(
path
)
)
.
type
=
=
"
regular
"
;
}
catch
(
ex
)
{
return
false
;
}
}
function
promiseExecuteSoon
(
)
{
return
new
Promise
(
resolve
=
>
{
executeSoon
(
resolve
)
;
}
)
;
}
function
promiseTimeout
(
aTime
)
{
return
new
Promise
(
resolve
=
>
{
do_timeout
(
aTime
resolve
)
;
}
)
;
}
function
promiseWaitForVisit
(
aUrl
)
{
return
new
Promise
(
resolve
=
>
{
function
listener
(
aEvents
)
{
Assert
.
equal
(
aEvents
.
length
1
)
;
let
event
=
aEvents
[
0
]
;
Assert
.
equal
(
event
.
type
"
page
-
visited
"
)
;
if
(
event
.
url
=
=
aUrl
)
{
PlacesObservers
.
removeListener
(
[
"
page
-
visited
"
]
listener
)
;
resolve
(
[
event
.
visitTime
event
.
transitionType
event
.
lastKnownTitle
]
)
;
}
}
PlacesObservers
.
addListener
(
[
"
page
-
visited
"
]
listener
)
;
}
)
;
}
function
promiseNewDownload
(
aSourceUrl
)
{
return
Downloads
.
createDownload
(
{
source
:
aSourceUrl
|
|
httpUrl
(
"
source
.
txt
"
)
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
}
)
;
}
function
promiseStartLegacyDownload
(
aSourceUrl
aOptions
)
{
let
sourceURI
=
NetUtil
.
newURI
(
aSourceUrl
|
|
httpUrl
(
"
source
.
txt
"
)
)
;
let
targetFile
=
(
aOptions
&
&
aOptions
.
targetFile
)
|
|
getTempFile
(
TEST_TARGET_FILE_NAME
)
;
let
persist
=
Cc
[
"
mozilla
.
org
/
embedding
/
browser
/
nsWebBrowserPersist
;
1
"
]
.
createInstance
(
Ci
.
nsIWebBrowserPersist
)
;
if
(
aOptions
)
{
aOptions
.
outPersist
=
persist
;
}
let
fileExtension
=
null
mimeInfo
=
null
;
let
match
=
sourceURI
.
pathQueryRef
.
match
(
/
\
.
(
[
^
.
\
/
]
+
)
/
)
;
if
(
match
)
{
fileExtension
=
match
[
1
]
;
}
if
(
fileExtension
)
{
try
{
mimeInfo
=
gMIMEService
.
getFromTypeAndExtension
(
null
fileExtension
)
;
mimeInfo
.
preferredAction
=
Ci
.
nsIMIMEInfo
.
saveToDisk
;
}
catch
(
ex
)
{
}
}
if
(
aOptions
&
&
aOptions
.
launcherPath
)
{
Assert
.
ok
(
mimeInfo
!
=
null
)
;
let
localHandlerApp
=
Cc
[
"
mozilla
.
org
/
uriloader
/
local
-
handler
-
app
;
1
"
]
.
createInstance
(
Ci
.
nsILocalHandlerApp
)
;
localHandlerApp
.
executable
=
new
FileUtils
.
File
(
aOptions
.
launcherPath
)
;
mimeInfo
.
preferredApplicationHandler
=
localHandlerApp
;
mimeInfo
.
preferredAction
=
Ci
.
nsIMIMEInfo
.
useHelperApp
;
}
if
(
aOptions
&
&
aOptions
.
launchWhenSucceeded
)
{
Assert
.
ok
(
mimeInfo
!
=
null
)
;
mimeInfo
.
preferredAction
=
Ci
.
nsIMIMEInfo
.
useHelperApp
;
}
persist
.
persistFlags
&
=
~
Ci
.
nsIWebBrowserPersist
.
PERSIST_FLAGS_NO_CONVERSION
;
persist
.
persistFlags
|
=
Ci
.
nsIWebBrowserPersist
.
PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION
;
let
transfer
=
Cc
[
"
mozilla
.
org
/
transfer
;
1
"
]
.
createInstance
(
Ci
.
nsITransfer
)
;
return
new
Promise
(
resolve
=
>
{
Downloads
.
getList
(
Downloads
.
ALL
)
.
then
(
function
(
aList
)
{
aList
.
addView
(
{
onDownloadAdded
(
aDownload
)
{
aList
.
removeView
(
this
)
.
catch
(
do_report_unexpected_exception
)
;
let
promise
=
aList
.
remove
(
aDownload
)
;
promise
.
then
(
(
)
=
>
resolve
(
aDownload
)
do_report_unexpected_exception
)
;
}
}
)
.
catch
(
do_report_unexpected_exception
)
;
let
isPrivate
=
aOptions
&
&
aOptions
.
isPrivate
;
let
referrerInfo
=
aOptions
?
aOptions
.
referrerInfo
:
null
;
let
cookieJarSettings
=
aOptions
?
aOptions
.
cookieJarSettings
:
null
;
let
classification
=
aOptions
?
.
downloadClassification
?
?
Ci
.
nsITransfer
.
DOWNLOAD_ACCEPTABLE
;
transfer
.
init
(
sourceURI
null
NetUtil
.
newURI
(
targetFile
)
null
mimeInfo
null
null
persist
isPrivate
classification
null
)
;
persist
.
progressListener
=
transfer
;
persist
.
savePrivacyAwareURI
(
sourceURI
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
0
referrerInfo
cookieJarSettings
null
null
targetFile
Ci
.
nsIContentPolicy
.
TYPE_SAVEAS_DOWNLOAD
isPrivate
)
;
}
)
.
catch
(
do_report_unexpected_exception
)
;
}
)
;
}
function
promiseStartExternalHelperAppServiceDownload
(
aSourceUrl
)
{
let
sourceURI
=
NetUtil
.
newURI
(
aSourceUrl
|
|
httpUrl
(
"
interruptible_resumable
.
txt
"
)
)
;
return
new
Promise
(
resolve
=
>
{
Downloads
.
getList
(
Downloads
.
PUBLIC
)
.
then
(
function
(
aList
)
{
aList
.
addView
(
{
onDownloadAdded
(
aDownload
)
{
aList
.
removeView
(
this
)
.
catch
(
do_report_unexpected_exception
)
;
let
promise
=
aList
.
remove
(
aDownload
)
;
promise
.
then
(
(
)
=
>
resolve
(
aDownload
)
do_report_unexpected_exception
)
;
}
}
)
.
catch
(
do_report_unexpected_exception
)
;
let
channel
=
NetUtil
.
newChannel
(
{
uri
:
sourceURI
loadUsingSystemPrincipal
:
true
}
)
;
channel
.
asyncOpen
(
{
contentListener
:
null
onStartRequest
(
aRequest
)
{
let
requestChannel
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
this
.
contentListener
=
gExternalHelperAppService
.
doContent
(
requestChannel
.
contentType
aRequest
null
true
)
;
this
.
contentListener
.
onStartRequest
(
aRequest
)
;
}
onStopRequest
(
aRequest
aStatusCode
)
{
this
.
contentListener
.
onStopRequest
(
aRequest
aStatusCode
)
;
}
onDataAvailable
(
aRequest
aInputStream
aOffset
aCount
)
{
this
.
contentListener
.
onDataAvailable
(
aRequest
aInputStream
aOffset
aCount
)
;
}
}
)
;
}
)
.
catch
(
do_report_unexpected_exception
)
;
}
)
;
}
function
promiseDownloadMidway
(
aDownload
)
{
return
new
Promise
(
resolve
=
>
{
let
onchange
=
function
(
)
{
if
(
!
aDownload
.
stopped
&
&
!
aDownload
.
canceled
&
&
aDownload
.
progress
=
=
50
)
{
aDownload
.
onchange
=
null
;
resolve
(
)
;
}
}
;
aDownload
.
onchange
=
onchange
;
onchange
(
)
;
}
)
;
}
function
promiseDownloadStarted
(
aDownload
)
{
return
new
Promise
(
resolve
=
>
{
let
onchange
=
function
(
)
{
if
(
!
aDownload
.
stopped
&
&
!
aDownload
.
canceled
&
&
aDownload
.
currentBytes
>
0
)
{
aDownload
.
onchange
=
null
;
resolve
(
)
;
}
}
;
aDownload
.
onchange
=
onchange
;
onchange
(
)
;
}
)
;
}
function
promiseDownloadFinished
(
aDownload
)
{
return
new
Promise
(
resolve
=
>
{
let
onchange
=
function
(
)
{
if
(
aDownload
.
succeeded
|
|
aDownload
.
error
)
{
aDownload
.
onchange
=
null
;
resolve
(
)
;
}
}
;
aDownload
.
onchange
=
onchange
;
onchange
(
)
;
}
)
;
}
function
promiseDownloadStopped
(
aDownload
)
{
if
(
!
aDownload
.
stopped
)
{
return
aDownload
.
start
(
)
;
}
if
(
aDownload
.
succeeded
)
{
return
Promise
.
resolve
(
)
;
}
return
Promise
.
reject
(
aDownload
.
error
|
|
new
Error
(
"
Download
canceled
.
"
)
)
;
}
function
promiseNewList
(
aIsPrivate
)
{
Downloads
.
_promiseListsInitialized
=
null
;
Downloads
.
_lists
=
{
}
;
Downloads
.
_summaries
=
{
}
;
return
Downloads
.
getList
(
aIsPrivate
?
Downloads
.
PRIVATE
:
Downloads
.
PUBLIC
)
;
}
async
function
promiseVerifyContents
(
aPath
aExpectedContents
)
{
let
file
=
new
FileUtils
.
File
(
aPath
)
;
if
(
!
(
await
IOUtils
.
exists
(
aPath
)
)
)
{
do_throw
(
"
File
does
not
exist
:
"
+
aPath
)
;
}
if
(
(
await
IOUtils
.
stat
(
aPath
)
)
.
size
=
=
0
)
{
do_throw
(
"
File
is
empty
:
"
+
aPath
)
;
}
await
new
Promise
(
resolve
=
>
{
NetUtil
.
asyncFetch
(
{
uri
:
NetUtil
.
newURI
(
file
)
loadUsingSystemPrincipal
:
true
}
function
(
aInputStream
aStatus
)
{
Assert
.
ok
(
Components
.
isSuccessCode
(
aStatus
)
)
;
let
contents
=
NetUtil
.
readInputStreamToString
(
aInputStream
aInputStream
.
available
(
)
)
;
if
(
contents
.
length
>
TEST_DATA_SHORT
.
length
*
2
|
|
/
[
^
\
x20
-
\
x7E
]
/
.
test
(
contents
)
)
{
Assert
.
equal
(
contents
.
length
aExpectedContents
.
length
)
;
Assert
.
ok
(
contents
=
=
aExpectedContents
)
;
}
else
{
Assert
.
equal
(
contents
aExpectedContents
)
;
}
resolve
(
)
;
}
)
;
}
)
;
}
async
function
promiseStartDownload_tryToKeepPartialData
(
{
useLegacySaver
=
false
}
=
{
}
)
{
mustInterruptResponses
(
)
;
let
download
;
if
(
!
useLegacySaver
)
{
let
targetFilePath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
download
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
interruptible_resumable
.
txt
"
)
target
:
{
path
:
targetFilePath
partFilePath
:
targetFilePath
+
"
.
part
"
}
}
)
;
download
.
tryToKeepPartialData
=
true
;
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
else
{
download
=
await
promiseStartExternalHelperAppServiceDownload
(
)
;
}
await
promiseDownloadMidway
(
download
)
;
await
promisePartFileReady
(
download
)
;
return
download
;
}
async
function
promisePartFileReady
(
aDownload
)
{
try
{
do
{
await
promiseTimeout
(
50
)
;
}
while
(
!
(
await
IOUtils
.
exists
(
aDownload
.
target
.
partFilePath
)
)
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
IOUtils
.
Error
)
)
{
throw
ex
;
}
info
(
"
Expected
exception
while
checking
existence
:
"
+
ex
.
toString
(
)
)
;
await
promiseTimeout
(
100
)
;
}
}
async
function
promiseBlockedDownload
(
{
keepPartialData
keepBlockedData
useLegacySaver
verdict
=
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
}
=
{
}
)
{
let
blockFn
=
base
=
>
(
{
shouldBlockForReputationCheck
:
(
)
=
>
Promise
.
resolve
(
{
shouldBlock
:
true
verdict
}
)
shouldKeepBlockedData
:
(
)
=
>
Promise
.
resolve
(
keepBlockedData
)
}
)
;
Integration
.
downloads
.
register
(
blockFn
)
;
function
cleanup
(
)
{
Integration
.
downloads
.
unregister
(
blockFn
)
;
}
registerCleanupFunction
(
cleanup
)
;
let
download
;
try
{
if
(
keepPartialData
)
{
download
=
await
promiseStartDownload_tryToKeepPartialData
(
{
useLegacySaver
}
)
;
continueResponses
(
)
;
}
else
if
(
useLegacySaver
)
{
download
=
await
promiseStartLegacyDownload
(
)
;
}
else
{
download
=
await
promiseNewDownload
(
)
;
await
download
.
start
(
)
;
do_throw
(
"
The
download
should
have
blocked
.
"
)
;
}
await
promiseDownloadStopped
(
download
)
;
do_throw
(
"
The
download
should
have
blocked
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
!
ex
.
becauseBlocked
)
{
throw
ex
;
}
Assert
.
ok
(
ex
.
becauseBlockedByReputationCheck
)
;
Assert
.
equal
(
ex
.
reputationCheckVerdict
verdict
)
;
Assert
.
ok
(
download
.
error
.
becauseBlockedByReputationCheck
)
;
Assert
.
equal
(
download
.
error
.
reputationCheckVerdict
verdict
)
;
}
Assert
.
ok
(
download
.
stopped
)
;
Assert
.
ok
(
!
download
.
succeeded
)
;
cleanup
(
)
;
return
download
;
}
function
startFakeServer
(
)
{
let
serverSocket
=
new
ServerSocket
(
-
1
true
-
1
)
;
serverSocket
.
asyncListen
(
{
onSocketAccepted
(
aServ
aTransport
)
{
aTransport
.
close
(
Cr
.
NS_BINDING_ABORTED
)
;
}
onStopListening
(
)
{
}
}
)
;
return
serverSocket
;
}
var
_gDeferResponses
=
PromiseUtils
.
defer
(
)
;
function
mustInterruptResponses
(
)
{
_gDeferResponses
.
resolve
(
)
;
info
(
"
Interruptible
responses
will
be
blocked
midway
.
"
)
;
_gDeferResponses
=
PromiseUtils
.
defer
(
)
;
}
function
continueResponses
(
)
{
info
(
"
Interruptible
responses
are
now
allowed
to
continue
.
"
)
;
_gDeferResponses
.
resolve
(
)
;
}
function
registerInterruptibleHandler
(
aPath
aFirstPartFn
aSecondPartFn
)
{
gHttpServer
.
registerPathHandler
(
aPath
function
(
aRequest
aResponse
)
{
info
(
"
Interruptible
request
started
.
"
)
;
aResponse
.
processAsync
(
)
;
aFirstPartFn
(
aRequest
aResponse
)
;
_gDeferResponses
.
promise
.
then
(
function
RIH_onSuccess
(
)
{
aSecondPartFn
(
aRequest
aResponse
)
;
aResponse
.
finish
(
)
;
info
(
"
Interruptible
request
finished
.
"
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
)
;
}
function
isValidDate
(
aDate
)
{
return
aDate
&
&
aDate
.
getTime
&
&
!
isNaN
(
aDate
.
getTime
(
)
)
;
}
function
checkEqualReferrerInfos
(
aActualInfo
aExpectedInfo
)
{
Assert
.
equal
(
!
!
aExpectedInfo
.
originalReferrer
!
!
aActualInfo
.
originalReferrer
)
;
if
(
aExpectedInfo
.
originalReferrer
&
&
aActualInfo
.
originalReferrer
)
{
Assert
.
equal
(
aExpectedInfo
.
originalReferrer
.
spec
aActualInfo
.
originalReferrer
.
spec
)
;
}
Assert
.
equal
(
aExpectedInfo
.
sendReferrer
aActualInfo
.
sendReferrer
)
;
Assert
.
equal
(
aExpectedInfo
.
referrerPolicy
aActualInfo
.
referrerPolicy
)
;
}
function
waitForAnnotation
(
sourceUriSpec
annotationName
)
{
return
TestUtils
.
waitForCondition
(
async
(
)
=
>
{
let
pageInfo
=
await
PlacesUtils
.
history
.
fetch
(
sourceUriSpec
{
includeAnnotations
:
true
}
)
;
return
pageInfo
&
&
pageInfo
.
annotations
.
has
(
annotationName
)
;
}
Should
have
found
annotation
{
annotationName
}
for
{
sourceUriSpec
}
)
;
}
var
gMostRecentFirstBytePos
;
add_setup
(
function
test_common_initialize
(
)
{
gHttpServer
=
new
HttpServer
(
)
;
gHttpServer
.
registerDirectory
(
"
/
"
do_get_file
(
"
.
.
/
data
"
)
)
;
gHttpServer
.
start
(
-
1
)
;
registerCleanupFunction
(
(
)
=
>
{
return
new
Promise
(
resolve
=
>
{
continueResponses
(
)
;
gHttpServer
.
stop
(
resolve
)
;
}
)
;
}
)
;
gHttpServer
.
identity
.
setPrimary
(
"
http
"
"
www
.
example
.
com
"
gHttpServer
.
identity
.
primaryPort
)
;
Services
.
prefs
.
setCharPref
(
"
network
.
dns
.
localDomains
"
"
www
.
example
.
com
"
)
;
registerCleanupFunction
(
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
network
.
dns
.
localDomains
"
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
cache
.
disk
.
enable
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
cache
.
memory
.
enable
"
false
)
;
registerCleanupFunction
(
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
cache
.
disk
.
enable
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
cache
.
memory
.
enable
"
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
http
.
referer
.
disallowCrossSiteRelaxingDefault
"
false
)
;
registerCleanupFunction
(
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
network
.
http
.
referer
.
disallowCrossSiteRelaxingDefault
"
)
;
}
)
;
registerInterruptibleHandler
(
"
/
interruptible
.
txt
"
function
firstPart
(
aRequest
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Length
"
"
"
+
TEST_DATA_SHORT
.
length
*
2
false
)
;
aResponse
.
write
(
TEST_DATA_SHORT
)
;
}
function
secondPart
(
aRequest
aResponse
)
{
aResponse
.
write
(
TEST_DATA_SHORT
)
;
}
)
;
registerInterruptibleHandler
(
"
/
interruptible_nosize
.
txt
"
function
firstPart
(
aRequest
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
aResponse
.
write
(
TEST_DATA_SHORT
)
;
}
function
secondPart
(
aRequest
aResponse
)
{
aResponse
.
write
(
TEST_DATA_SHORT
)
;
}
)
;
registerInterruptibleHandler
(
"
/
interruptible_resumable
.
txt
"
function
firstPart
(
aRequest
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
let
data
=
TEST_DATA_SHORT
+
TEST_DATA_SHORT
;
if
(
aRequest
.
hasHeader
(
"
Range
"
)
)
{
var
matches
=
aRequest
.
getHeader
(
"
Range
"
)
.
match
(
/
^
\
s
*
bytes
=
(
\
d
+
)
?
-
(
\
d
+
)
?
\
s
*
/
)
;
var
firstBytePos
=
matches
[
1
]
=
=
=
undefined
?
0
:
matches
[
1
]
;
var
lastBytePos
=
matches
[
2
]
=
=
=
undefined
?
data
.
length
-
1
:
matches
[
2
]
;
if
(
firstBytePos
>
=
data
.
length
)
{
aResponse
.
setStatusLine
(
aRequest
.
httpVersion
416
"
Requested
Range
Not
Satisfiable
"
)
;
aResponse
.
setHeader
(
"
Content
-
Range
"
"
*
/
"
+
data
.
length
false
)
;
aResponse
.
finish
(
)
;
return
;
}
aResponse
.
setStatusLine
(
aRequest
.
httpVersion
206
"
Partial
Content
"
)
;
aResponse
.
setHeader
(
"
Content
-
Range
"
firstBytePos
+
"
-
"
+
lastBytePos
+
"
/
"
+
data
.
length
false
)
;
data
=
data
.
substring
(
firstBytePos
lastBytePos
+
1
)
;
gMostRecentFirstBytePos
=
firstBytePos
;
}
else
{
gMostRecentFirstBytePos
=
0
;
}
aResponse
.
setHeader
(
"
Content
-
Length
"
"
"
+
data
.
length
false
)
;
aResponse
.
write
(
data
.
substring
(
0
data
.
length
/
2
)
)
;
aResponse
.
secondPartData
=
data
.
substring
(
data
.
length
/
2
)
;
}
function
secondPart
(
aRequest
aResponse
)
{
aResponse
.
write
(
aResponse
.
secondPartData
)
;
}
)
;
registerInterruptibleHandler
(
"
/
interruptible_gzip
.
txt
"
function
firstPart
(
aRequest
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Encoding
"
"
gzip
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Length
"
"
"
+
TEST_DATA_SHORT_GZIP_ENCODED
.
length
)
;
let
bos
=
new
BinaryOutputStream
(
aResponse
.
bodyOutputStream
)
;
bos
.
writeByteArray
(
TEST_DATA_SHORT_GZIP_ENCODED_FIRST
)
;
}
function
secondPart
(
aRequest
aResponse
)
{
let
bos
=
new
BinaryOutputStream
(
aResponse
.
bodyOutputStream
)
;
bos
.
writeByteArray
(
TEST_DATA_SHORT_GZIP_ENCODED_SECOND
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
shorter
-
than
-
content
-
length
-
http
-
1
-
1
.
txt
"
function
(
aRequest
aResponse
)
{
aResponse
.
processAsync
(
)
;
aResponse
.
setStatusLine
(
"
1
.
1
"
200
"
OK
"
)
;
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Length
"
"
"
+
TEST_DATA_SHORT
.
length
*
2
false
)
;
aResponse
.
write
(
TEST_DATA_SHORT
)
;
aResponse
.
finish
(
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
busy
.
txt
"
function
(
aRequest
aResponse
)
{
aResponse
.
setStatusLine
(
"
1
.
1
"
504
"
Gateway
Timeout
"
)
;
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Length
"
"
"
+
TEST_DATA_SHORT
.
length
false
)
;
aResponse
.
write
(
TEST_DATA_SHORT
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
redirect
"
function
(
aRequest
aResponse
)
{
aResponse
.
setStatusLine
(
"
1
.
1
"
301
"
Moved
Permanently
"
)
;
aResponse
.
setHeader
(
"
Location
"
httpUrl
(
"
busy
.
txt
"
)
false
)
;
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
javascript
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Length
"
"
0
"
false
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
parentalblocked
.
zip
"
function
(
aRequest
aResponse
)
{
aResponse
.
setStatusLine
(
aRequest
.
httpVersion
450
"
Blocked
by
Windows
Parental
Controls
"
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
netreset
.
txt
"
function
(
aRequest
aResponse
)
{
info
(
"
Starting
response
that
will
be
aborted
.
"
)
;
aResponse
.
processAsync
(
)
;
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
aResponse
.
write
(
TEST_DATA_SHORT
)
;
promiseExecuteSoon
(
)
.
then
(
(
)
=
>
{
aResponse
.
abort
(
null
true
)
;
aResponse
.
finish
(
)
;
info
(
"
Aborting
response
with
network
reset
.
"
)
;
}
)
.
then
(
null
Cu
.
reportError
)
;
}
)
;
Integration
.
downloads
.
register
(
base
=
>
(
{
__proto__
:
base
loadPublicDownloadListFromStore
:
(
)
=
>
Promise
.
resolve
(
)
shouldKeepBlockedData
:
(
)
=
>
Promise
.
resolve
(
false
)
shouldBlockForParentalControls
:
(
)
=
>
Promise
.
resolve
(
false
)
shouldBlockForRuntimePermissions
:
(
)
=
>
Promise
.
resolve
(
false
)
shouldBlockForReputationCheck
:
(
)
=
>
Promise
.
resolve
(
{
shouldBlock
:
false
verdict
:
"
"
}
)
confirmLaunchExecutable
:
(
)
=
>
Promise
.
resolve
(
)
launchFile
:
(
)
=
>
Promise
.
resolve
(
)
showContainingDirectory
:
(
)
=
>
Promise
.
resolve
(
)
allowObservers
:
false
addListObservers
(
)
{
return
this
.
allowObservers
?
super
.
addListObservers
(
.
.
.
arguments
)
:
Promise
.
resolve
(
)
;
}
_allowDirectories
:
false
set
allowDirectories
(
value
)
{
this
.
_allowDirectories
=
value
;
this
.
_downloadsDirectory
=
null
;
}
_getDirectory
(
name
)
{
return
super
.
_getDirectory
(
this
.
_allowDirectories
?
name
:
"
TmpD
"
)
;
}
}
)
)
;
let
mock
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIHelperAppLauncherDialog
"
]
)
promptForSaveToFileAsync
(
aLauncher
aWindowContext
aDefaultFileName
aSuggestedFileExtension
aForcePrompt
)
{
let
file
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
;
file
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
FileUtils
.
PERMS_FILE
)
;
aLauncher
.
saveDestinationAvailable
(
file
)
;
}
}
;
let
cid
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
helperapplauncherdialog
;
1
"
mock
)
;
registerCleanupFunction
(
(
)
=
>
{
MockRegistrar
.
unregister
(
cid
)
;
}
)
;
}
)
;
