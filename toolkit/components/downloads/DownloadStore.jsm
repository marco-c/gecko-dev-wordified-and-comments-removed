"
use
strict
"
;
const
MAX_INSECURE_DOWNLOAD_AGE_MS
=
5
*
60
*
1000
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadStore
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gTextDecoder
"
function
(
)
{
return
new
TextDecoder
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gTextEncoder
"
function
(
)
{
return
new
TextEncoder
(
)
;
}
)
;
var
DownloadStore
=
function
(
aList
aPath
)
{
this
.
list
=
aList
;
this
.
path
=
aPath
;
}
;
DownloadStore
.
prototype
=
{
list
:
null
path
:
"
"
onsaveitem
:
(
)
=
>
true
load
:
function
DS_load
(
)
{
return
(
async
(
)
=
>
{
let
bytes
;
try
{
bytes
=
await
IOUtils
.
read
(
this
.
path
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
.
name
=
=
"
NotFoundError
"
)
)
{
throw
ex
;
}
return
;
}
let
storeChanges
=
false
;
let
removePromises
=
[
]
;
let
storeData
=
JSON
.
parse
(
lazy
.
gTextDecoder
.
decode
(
bytes
)
)
;
for
(
let
downloadData
of
storeData
.
list
)
{
try
{
let
download
=
await
lazy
.
Downloads
.
createDownload
(
downloadData
)
;
if
(
download
.
error
?
.
becauseBlockedByReputationCheck
&
&
download
.
error
.
reputationCheckVerdict
=
=
"
Insecure
"
&
&
Date
.
now
(
)
-
download
.
startTime
>
MAX_INSECURE_DOWNLOAD_AGE_MS
)
{
removePromises
.
push
(
download
.
removePartialData
(
)
)
;
storeChanges
=
true
;
continue
;
}
try
{
if
(
!
download
.
succeeded
&
&
!
download
.
canceled
&
&
!
download
.
error
)
{
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
else
{
await
download
.
refresh
(
)
;
}
}
finally
{
await
this
.
list
.
add
(
download
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
if
(
storeChanges
)
{
try
{
await
Promise
.
all
(
removePromises
)
;
await
this
.
save
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
)
(
)
;
}
save
:
function
DS_save
(
)
{
return
(
async
(
)
=
>
{
let
downloads
=
await
this
.
list
.
getAll
(
)
;
let
storeData
=
{
list
:
[
]
}
;
let
atLeastOneDownload
=
false
;
for
(
let
download
of
downloads
)
{
try
{
if
(
!
this
.
onsaveitem
(
download
)
)
{
continue
;
}
let
serializable
=
download
.
toSerializable
(
)
;
if
(
!
serializable
)
{
continue
;
}
storeData
.
list
.
push
(
serializable
)
;
atLeastOneDownload
=
true
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
if
(
atLeastOneDownload
)
{
let
bytes
=
lazy
.
gTextEncoder
.
encode
(
JSON
.
stringify
(
storeData
)
)
;
await
IOUtils
.
write
(
this
.
path
bytes
{
tmpPath
:
this
.
path
+
"
.
tmp
"
}
)
;
}
else
{
try
{
await
IOUtils
.
remove
(
this
.
path
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
.
name
=
=
"
NotFoundError
"
|
|
ex
.
name
=
=
"
NotAllowedError
"
)
)
{
throw
ex
;
}
}
}
}
)
(
)
;
}
}
;
