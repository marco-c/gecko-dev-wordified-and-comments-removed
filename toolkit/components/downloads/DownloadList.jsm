"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadList
"
"
DownloadCombinedList
"
"
DownloadSummary
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
kFileExtensions
=
[
"
aac
"
"
adt
"
"
adts
"
"
accdb
"
"
accde
"
"
accdr
"
"
accdt
"
"
aif
"
"
aifc
"
"
aiff
"
"
apng
"
"
aspx
"
"
avi
"
"
avif
"
"
bat
"
"
bin
"
"
bmp
"
"
cab
"
"
cda
"
"
csv
"
"
dif
"
"
dll
"
"
doc
"
"
docm
"
"
docx
"
"
dot
"
"
dotx
"
"
eml
"
"
eps
"
"
exe
"
"
flac
"
"
flv
"
"
gif
"
"
htm
"
"
html
"
"
ico
"
"
ini
"
"
iso
"
"
jar
"
"
jfif
"
"
jpg
"
"
jpeg
"
"
json
"
"
m4a
"
"
mdb
"
"
mid
"
"
midi
"
"
mov
"
"
mp3
"
"
mp4
"
"
mpeg
"
"
mpg
"
"
msi
"
"
mui
"
"
oga
"
"
ogg
"
"
ogv
"
"
opus
"
"
pdf
"
"
pjpeg
"
"
pjp
"
"
png
"
"
pot
"
"
potm
"
"
potx
"
"
ppam
"
"
pps
"
"
ppsm
"
"
ppsx
"
"
ppt
"
"
pptm
"
"
pptx
"
"
psd
"
"
pst
"
"
pub
"
"
rar
"
"
rdf
"
"
rtf
"
"
shtml
"
"
sldm
"
"
sldx
"
"
svg
"
"
swf
"
"
sys
"
"
tif
"
"
tiff
"
"
tmp
"
"
txt
"
"
vob
"
"
vsd
"
"
vsdm
"
"
vsdx
"
"
vss
"
"
vssm
"
"
vst
"
"
vstm
"
"
vstx
"
"
wav
"
"
wbk
"
"
webm
"
"
webp
"
"
wks
"
"
wma
"
"
wmd
"
"
wmv
"
"
wmz
"
"
wms
"
"
wpd
"
"
wp5
"
"
xht
"
"
xhtml
"
"
xla
"
"
xlam
"
"
xll
"
"
xlm
"
"
xls
"
"
xlsm
"
"
xlsx
"
"
xlt
"
"
xltm
"
"
xltx
"
"
xml
"
"
zip
"
]
;
const
TELEMETRY_EVENT_CATEGORY
=
"
downloads
"
;
var
DownloadList
=
function
(
)
{
this
.
_downloads
=
[
]
;
this
.
_views
=
new
Set
(
)
;
}
;
DownloadList
.
prototype
=
{
_downloads
:
null
getAll
:
function
DL_getAll
(
)
{
return
Promise
.
resolve
(
Array
.
from
(
this
.
_downloads
)
)
;
}
add
:
function
DL_add
(
aDownload
)
{
this
.
_downloads
.
push
(
aDownload
)
;
aDownload
.
onchange
=
this
.
_change
.
bind
(
this
aDownload
)
;
this
.
_notifyAllViews
(
"
onDownloadAdded
"
aDownload
)
;
return
Promise
.
resolve
(
)
;
}
remove
:
function
DL_remove
(
aDownload
)
{
let
index
=
this
.
_downloads
.
indexOf
(
aDownload
)
;
if
(
index
!
=
-
1
)
{
this
.
_downloads
.
splice
(
index
1
)
;
aDownload
.
onchange
=
null
;
this
.
_notifyAllViews
(
"
onDownloadRemoved
"
aDownload
)
;
}
return
Promise
.
resolve
(
)
;
}
_change
:
function
DL_change
(
aDownload
)
{
this
.
_notifyAllViews
(
"
onDownloadChanged
"
aDownload
)
;
}
_views
:
null
addView
:
function
DL_addView
(
aView
)
{
this
.
_views
.
add
(
aView
)
;
if
(
"
onDownloadAdded
"
in
aView
)
{
this
.
_notifyAllViews
(
"
onDownloadBatchStarting
"
)
;
for
(
let
download
of
this
.
_downloads
)
{
try
{
aView
.
onDownloadAdded
(
download
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
this
.
_notifyAllViews
(
"
onDownloadBatchEnded
"
)
;
}
return
Promise
.
resolve
(
)
;
}
removeView
:
function
DL_removeView
(
aView
)
{
this
.
_views
.
delete
(
aView
)
;
return
Promise
.
resolve
(
)
;
}
_notifyAllViews
(
methodName
.
.
.
args
)
{
for
(
let
view
of
this
.
_views
)
{
try
{
if
(
methodName
in
view
)
{
view
[
methodName
]
(
.
.
.
args
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
removeFinished
:
function
DL_removeFinished
(
aFilterFn
)
{
(
async
(
)
=
>
{
let
list
=
await
this
.
getAll
(
)
;
for
(
let
download
of
list
)
{
if
(
download
.
stopped
&
&
(
!
download
.
hasPartialData
|
|
download
.
error
)
&
&
(
!
aFilterFn
|
|
aFilterFn
(
download
)
)
)
{
await
this
.
remove
(
download
)
;
let
sameFileIsDownloading
=
false
;
for
(
let
otherDownload
of
await
this
.
getAll
(
)
)
{
if
(
download
!
=
=
otherDownload
&
&
download
.
target
.
path
=
=
otherDownload
.
target
.
path
&
&
!
otherDownload
.
error
)
{
sameFileIsDownloading
=
true
;
}
}
let
removePartialData
=
!
sameFileIsDownloading
;
download
.
finalize
(
removePartialData
)
.
catch
(
Cu
.
reportError
)
;
}
}
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
;
var
DownloadCombinedList
=
function
(
aPublicList
aPrivateList
)
{
DownloadList
.
call
(
this
)
;
this
.
_publicList
=
aPublicList
;
this
.
_privateList
=
aPrivateList
;
aPublicList
.
addView
(
this
)
.
catch
(
Cu
.
reportError
)
;
aPrivateList
.
addView
(
this
)
.
catch
(
Cu
.
reportError
)
;
}
;
DownloadCombinedList
.
prototype
=
{
__proto__
:
DownloadList
.
prototype
_publicList
:
null
_privateList
:
null
add
(
aDownload
)
{
let
extension
=
aDownload
.
target
.
path
.
split
(
"
.
"
)
.
pop
(
)
;
if
(
!
kFileExtensions
.
includes
(
extension
)
)
{
extension
=
"
other
"
;
}
try
{
Services
.
telemetry
.
recordEvent
(
TELEMETRY_EVENT_CATEGORY
"
added
"
"
fileExtension
"
extension
{
}
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
DownloadsCommon
:
error
recording
telemetry
event
.
"
+
ex
.
message
)
;
}
if
(
aDownload
.
source
.
isPrivate
)
{
return
this
.
_privateList
.
add
(
aDownload
)
;
}
return
this
.
_publicList
.
add
(
aDownload
)
;
}
remove
(
aDownload
)
{
if
(
aDownload
.
source
.
isPrivate
)
{
return
this
.
_privateList
.
remove
(
aDownload
)
;
}
return
this
.
_publicList
.
remove
(
aDownload
)
;
}
onDownloadAdded
(
aDownload
)
{
this
.
_downloads
.
push
(
aDownload
)
;
this
.
_notifyAllViews
(
"
onDownloadAdded
"
aDownload
)
;
}
onDownloadChanged
(
aDownload
)
{
this
.
_notifyAllViews
(
"
onDownloadChanged
"
aDownload
)
;
}
onDownloadRemoved
(
aDownload
)
{
let
index
=
this
.
_downloads
.
indexOf
(
aDownload
)
;
if
(
index
!
=
-
1
)
{
this
.
_downloads
.
splice
(
index
1
)
;
}
this
.
_notifyAllViews
(
"
onDownloadRemoved
"
aDownload
)
;
}
}
;
var
DownloadSummary
=
function
(
)
{
this
.
_downloads
=
[
]
;
this
.
_views
=
new
Set
(
)
;
}
;
DownloadSummary
.
prototype
=
{
_downloads
:
null
_list
:
null
bindToList
(
aList
)
{
if
(
this
.
_list
)
{
throw
new
Error
(
"
bindToList
may
be
called
only
once
.
"
)
;
}
return
aList
.
addView
(
this
)
.
then
(
(
)
=
>
{
this
.
_list
=
aList
;
this
.
_onListChanged
(
)
;
}
)
;
}
_views
:
null
addView
(
aView
)
{
this
.
_views
.
add
(
aView
)
;
if
(
"
onSummaryChanged
"
in
aView
)
{
try
{
aView
.
onSummaryChanged
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
return
Promise
.
resolve
(
)
;
}
removeView
(
aView
)
{
this
.
_views
.
delete
(
aView
)
;
return
Promise
.
resolve
(
)
;
}
allHaveStopped
:
true
allUnknownSize
:
true
progressTotalBytes
:
0
progressCurrentBytes
:
0
_onListChanged
(
)
{
let
allHaveStopped
=
true
;
let
allUnknownSize
=
true
;
let
progressTotalBytes
=
0
;
let
progressCurrentBytes
=
0
;
for
(
let
download
of
this
.
_downloads
)
{
if
(
!
download
.
stopped
)
{
allHaveStopped
=
false
;
if
(
download
.
hasProgress
)
{
allUnknownSize
=
false
;
progressTotalBytes
+
=
download
.
totalBytes
;
}
else
{
progressTotalBytes
+
=
download
.
currentBytes
;
}
progressCurrentBytes
+
=
download
.
currentBytes
;
}
}
if
(
this
.
allHaveStopped
=
=
allHaveStopped
&
&
this
.
allUnknownSize
=
=
allUnknownSize
&
&
this
.
progressTotalBytes
=
=
progressTotalBytes
&
&
this
.
progressCurrentBytes
=
=
progressCurrentBytes
)
{
return
;
}
this
.
allHaveStopped
=
allHaveStopped
;
this
.
allUnknownSize
=
allUnknownSize
;
this
.
progressTotalBytes
=
progressTotalBytes
;
this
.
progressCurrentBytes
=
progressCurrentBytes
;
for
(
let
view
of
this
.
_views
)
{
try
{
if
(
"
onSummaryChanged
"
in
view
)
{
view
.
onSummaryChanged
(
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
onDownloadAdded
(
aDownload
)
{
this
.
_downloads
.
push
(
aDownload
)
;
if
(
this
.
_list
)
{
this
.
_onListChanged
(
)
;
}
}
onDownloadChanged
(
aDownload
)
{
this
.
_onListChanged
(
)
;
}
onDownloadRemoved
(
aDownload
)
{
let
index
=
this
.
_downloads
.
indexOf
(
aDownload
)
;
if
(
index
!
=
-
1
)
{
this
.
_downloads
.
splice
(
index
1
)
;
}
this
.
_onListChanged
(
)
;
}
}
;
