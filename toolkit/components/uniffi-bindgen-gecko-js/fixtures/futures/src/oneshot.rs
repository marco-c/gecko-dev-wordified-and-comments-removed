use
std
:
:
{
future
:
:
Future
pin
:
:
Pin
sync
:
:
{
Arc
Mutex
}
task
:
:
{
Context
Poll
Waker
}
}
;
struct
Channel
<
T
>
{
value
:
Option
<
T
>
waker
:
Option
<
Waker
>
}
pub
struct
Sender
<
T
>
(
Arc
<
Mutex
<
Channel
<
T
>
>
>
)
;
pub
struct
Receiver
<
T
>
(
Arc
<
Mutex
<
Channel
<
T
>
>
>
)
;
pub
fn
channel
<
T
>
(
)
-
>
(
Sender
<
T
>
Receiver
<
T
>
)
{
let
channel
=
Arc
:
:
new
(
Mutex
:
:
new
(
Channel
{
value
:
None
waker
:
None
}
)
)
;
(
Sender
(
channel
.
clone
(
)
)
Receiver
(
channel
)
)
}
impl
<
T
>
Sender
<
T
>
{
pub
fn
send
(
self
value
:
T
)
{
let
mut
channel
=
self
.
0
.
lock
(
)
.
unwrap
(
)
;
channel
.
value
=
Some
(
value
)
;
if
let
Some
(
waker
)
=
channel
.
waker
.
take
(
)
{
waker
.
wake
(
)
;
}
}
pub
fn
wake
(
&
self
)
{
let
mut
channel
=
self
.
0
.
lock
(
)
.
unwrap
(
)
;
if
let
Some
(
waker
)
=
channel
.
waker
.
take
(
)
{
waker
.
wake
(
)
;
}
}
}
impl
<
T
>
Future
for
Receiver
<
T
>
{
type
Output
=
T
;
fn
poll
(
self
:
Pin
<
&
mut
Self
>
context
:
&
mut
Context
)
-
>
Poll
<
T
>
{
let
mut
channel
=
self
.
0
.
lock
(
)
.
unwrap
(
)
;
match
channel
.
value
.
take
(
)
{
Some
(
v
)
=
>
Poll
:
:
Ready
(
v
)
None
=
>
{
channel
.
waker
=
Some
(
context
.
waker
(
)
.
clone
(
)
)
;
Poll
:
:
Pending
}
}
}
}
