"
use
strict
"
;
var
UnitTestObjs
=
{
}
;
var
EXPORTED_SYMBOLS
=
[
"
UnitTestObjs
"
]
;
class
ArrayBufferDataStream
{
constructor
(
arrayBuffer
)
{
this
.
dataView
=
new
DataView
(
arrayBuffer
)
;
this
.
pos
=
0
;
}
readUint8
(
)
{
let
rv
=
this
.
dataView
.
getUint8
(
this
.
pos
)
;
this
.
pos
+
=
1
;
return
rv
;
}
writeUint8
(
value
)
{
this
.
dataView
.
setUint8
(
this
.
pos
value
)
;
this
.
pos
+
=
1
;
}
readUint16
(
)
{
let
rv
=
this
.
dataView
.
getUint16
(
this
.
pos
)
;
this
.
pos
+
=
2
;
return
rv
;
}
writeUint16
(
value
)
{
this
.
dataView
.
setUint16
(
this
.
pos
value
)
;
this
.
pos
+
=
2
;
}
readUint32
(
)
{
let
rv
=
this
.
dataView
.
getUint32
(
this
.
pos
)
;
this
.
pos
+
=
4
;
return
rv
;
}
writeUint32
(
value
)
{
this
.
dataView
.
setUint32
(
this
.
pos
value
)
;
this
.
pos
+
=
4
;
}
readUint64
(
)
{
let
rv
=
this
.
dataView
.
getBigUint64
(
this
.
pos
)
;
this
.
pos
+
=
8
;
return
Number
(
rv
)
;
}
writeUint64
(
value
)
{
this
.
dataView
.
setBigUint64
(
this
.
pos
BigInt
(
value
)
)
;
this
.
pos
+
=
8
;
}
readInt8
(
)
{
let
rv
=
this
.
dataView
.
getInt8
(
this
.
pos
)
;
this
.
pos
+
=
1
;
return
rv
;
}
writeInt8
(
value
)
{
this
.
dataView
.
setInt8
(
this
.
pos
value
)
;
this
.
pos
+
=
1
;
}
readInt16
(
)
{
let
rv
=
this
.
dataView
.
getInt16
(
this
.
pos
)
;
this
.
pos
+
=
2
;
return
rv
;
}
writeInt16
(
value
)
{
this
.
dataView
.
setInt16
(
this
.
pos
value
)
;
this
.
pos
+
=
2
;
}
readInt32
(
)
{
let
rv
=
this
.
dataView
.
getInt32
(
this
.
pos
)
;
this
.
pos
+
=
4
;
return
rv
;
}
writeInt32
(
value
)
{
this
.
dataView
.
setInt32
(
this
.
pos
value
)
;
this
.
pos
+
=
4
;
}
readInt64
(
)
{
let
rv
=
this
.
dataView
.
getBigInt64
(
this
.
pos
)
;
this
.
pos
+
=
8
;
return
Number
(
rv
)
;
}
writeInt64
(
value
)
{
this
.
dataView
.
setBigInt64
(
this
.
pos
BigInt
(
value
)
)
;
this
.
pos
+
=
8
;
}
readFloat32
(
)
{
let
rv
=
this
.
dataView
.
getFloat32
(
this
.
pos
)
;
this
.
pos
+
=
4
;
return
rv
;
}
writeFloat32
(
value
)
{
this
.
dataView
.
setFloat32
(
this
.
pos
value
)
;
this
.
pos
+
=
4
;
}
readFloat64
(
)
{
let
rv
=
this
.
dataView
.
getFloat64
(
this
.
pos
)
;
this
.
pos
+
=
8
;
return
rv
;
}
writeFloat64
(
value
)
{
this
.
dataView
.
setFloat64
(
this
.
pos
value
)
;
this
.
pos
+
=
8
;
}
writeString
(
value
)
{
const
encoder
=
new
TextEncoder
(
)
;
const
dest
=
new
Uint8Array
(
this
.
dataView
.
buffer
this
.
pos
+
4
)
;
const
encodeResult
=
encoder
.
encodeInto
(
value
dest
)
;
if
(
encodeResult
.
read
!
=
value
.
length
)
{
throw
new
UniFFIError
(
"
writeString
:
out
of
space
when
writing
to
ArrayBuffer
.
Did
the
computeSize
(
)
method
returned
the
wrong
result
?
"
)
;
}
const
size
=
encodeResult
.
written
;
this
.
dataView
.
setUint32
(
this
.
pos
size
)
;
this
.
pos
+
=
size
+
4
;
}
readString
(
)
{
const
decoder
=
new
TextDecoder
(
)
;
const
size
=
this
.
readUint32
(
)
;
const
source
=
new
Uint8Array
(
this
.
dataView
.
buffer
this
.
pos
size
)
const
value
=
decoder
.
decode
(
source
)
;
this
.
pos
+
=
size
;
return
value
;
}
readPointerTodoList
(
)
{
const
pointerId
=
6
;
const
res
=
UniFFIScaffolding
.
readPointer
(
pointerId
this
.
dataView
.
buffer
this
.
pos
)
;
this
.
pos
+
=
8
;
return
res
;
}
writePointerTodoList
(
value
)
{
const
pointerId
=
6
;
UniFFIScaffolding
.
writePointer
(
pointerId
value
this
.
dataView
.
buffer
this
.
pos
)
;
this
.
pos
+
=
8
;
}
}
function
handleRustResult
(
result
liftCallback
liftErrCallback
)
{
switch
(
result
.
code
)
{
case
"
success
"
:
return
liftCallback
(
result
.
data
)
;
case
"
error
"
:
throw
liftErrCallback
(
result
.
data
)
;
case
"
internal
-
error
"
:
let
message
=
result
.
internalErrorMessage
;
if
(
message
)
{
throw
new
UniFFIInternalError
(
message
)
;
}
else
{
throw
new
UniFFIInternalError
(
"
Unknown
error
"
)
;
}
default
:
throw
new
UniFFIError
(
Unexpected
status
code
:
{
result
.
code
}
)
;
}
}
class
UniFFIError
{
constructor
(
message
)
{
this
.
message
=
message
;
}
toString
(
)
{
return
UniFFIError
:
{
this
.
message
}
}
}
class
UniFFIInternalError
extends
UniFFIError
{
}
class
FfiConverter
{
static
checkType
(
name
value
)
{
if
(
value
=
=
=
undefined
)
{
throw
TypeError
(
{
name
}
is
undefined
)
;
}
if
(
value
=
=
=
null
)
{
throw
TypeError
(
{
name
}
is
null
)
;
}
}
}
class
FfiConverterArrayBuffer
extends
FfiConverter
{
static
lift
(
buf
)
{
return
this
.
read
(
new
ArrayBufferDataStream
(
buf
)
)
;
}
static
lower
(
value
)
{
const
buf
=
new
ArrayBuffer
(
this
.
computeSize
(
value
)
)
;
const
dataStream
=
new
ArrayBufferDataStream
(
buf
)
;
this
.
write
(
dataStream
value
)
;
return
buf
;
}
}
const
uniffiObjectPtr
=
Symbol
(
"
uniffiObjectPtr
"
)
;
const
constructUniffiObject
=
Symbol
(
"
constructUniffiObject
"
)
;
class
FfiConverterString
extends
FfiConverter
{
static
lift
(
buf
)
{
const
decoder
=
new
TextDecoder
(
)
;
const
utf8Arr
=
new
Uint8Array
(
buf
)
;
return
decoder
.
decode
(
utf8Arr
)
;
}
static
lower
(
value
)
{
const
encoder
=
new
TextEncoder
(
)
;
return
encoder
.
encode
(
value
)
.
buffer
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeString
(
value
)
;
}
static
read
(
dataStream
)
{
return
dataStream
.
readString
(
)
;
}
static
computeSize
(
value
)
{
const
encoder
=
new
TextEncoder
(
)
;
return
4
+
encoder
.
encode
(
value
)
.
length
}
}
EXPORTED_SYMBOLS
.
push
(
"
FfiConverterString
"
)
;
class
TodoList
{
constructor
(
opts
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
opts
constructUniffiObject
)
)
{
throw
new
UniFFIError
(
"
Attempting
to
construct
an
object
using
the
JavaScript
constructor
directly
"
+
"
Please
use
a
UDL
defined
constructor
or
the
init
function
for
the
primary
constructor
"
)
}
if
(
!
opts
[
constructUniffiObject
]
instanceof
UniFFIPointer
)
{
throw
new
UniFFIError
(
"
Attempting
to
create
a
UniFFI
object
with
a
pointer
that
is
not
an
instance
of
UniFFIPointer
"
)
}
this
[
uniffiObjectPtr
]
=
opts
[
constructUniffiObject
]
;
}
static
init
(
)
{
const
liftResult
=
(
result
)
=
>
FfiConverterTypeTodoList
.
lift
(
result
)
;
const
liftError
=
null
;
const
functionCall
=
(
)
=
>
{
return
UniFFIScaffolding
.
callAsync
(
92
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
addItem
(
todo
)
{
const
liftResult
=
(
result
)
=
>
undefined
;
const
liftError
=
(
data
)
=
>
FfiConverterTypeTodoError
.
lift
(
data
)
;
const
functionCall
=
(
)
=
>
{
FfiConverterString
.
checkType
(
"
todo
"
todo
)
;
return
UniFFIScaffolding
.
callAsync
(
93
FfiConverterTypeTodoList
.
lower
(
this
)
FfiConverterString
.
lower
(
todo
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
addEntry
(
entry
)
{
const
liftResult
=
(
result
)
=
>
undefined
;
const
liftError
=
(
data
)
=
>
FfiConverterTypeTodoError
.
lift
(
data
)
;
const
functionCall
=
(
)
=
>
{
FfiConverterTypeTodoEntry
.
checkType
(
"
entry
"
entry
)
;
return
UniFFIScaffolding
.
callAsync
(
94
FfiConverterTypeTodoList
.
lower
(
this
)
FfiConverterTypeTodoEntry
.
lower
(
entry
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
getEntries
(
)
{
const
liftResult
=
(
result
)
=
>
FfiConverterSequenceTypeTodoEntry
.
lift
(
result
)
;
const
liftError
=
null
;
const
functionCall
=
(
)
=
>
{
return
UniFFIScaffolding
.
callAsync
(
95
FfiConverterTypeTodoList
.
lower
(
this
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
getItems
(
)
{
const
liftResult
=
(
result
)
=
>
FfiConverterSequencestring
.
lift
(
result
)
;
const
liftError
=
null
;
const
functionCall
=
(
)
=
>
{
return
UniFFIScaffolding
.
callAsync
(
96
FfiConverterTypeTodoList
.
lower
(
this
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
addEntries
(
entries
)
{
const
liftResult
=
(
result
)
=
>
undefined
;
const
liftError
=
null
;
const
functionCall
=
(
)
=
>
{
FfiConverterSequenceTypeTodoEntry
.
checkType
(
"
entries
"
entries
)
;
return
UniFFIScaffolding
.
callAsync
(
97
FfiConverterTypeTodoList
.
lower
(
this
)
FfiConverterSequenceTypeTodoEntry
.
lower
(
entries
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
addItems
(
items
)
{
const
liftResult
=
(
result
)
=
>
undefined
;
const
liftError
=
null
;
const
functionCall
=
(
)
=
>
{
FfiConverterSequencestring
.
checkType
(
"
items
"
items
)
;
return
UniFFIScaffolding
.
callAsync
(
98
FfiConverterTypeTodoList
.
lower
(
this
)
FfiConverterSequencestring
.
lower
(
items
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
getLastEntry
(
)
{
const
liftResult
=
(
result
)
=
>
FfiConverterTypeTodoEntry
.
lift
(
result
)
;
const
liftError
=
(
data
)
=
>
FfiConverterTypeTodoError
.
lift
(
data
)
;
const
functionCall
=
(
)
=
>
{
return
UniFFIScaffolding
.
callAsync
(
99
FfiConverterTypeTodoList
.
lower
(
this
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
getLast
(
)
{
const
liftResult
=
(
result
)
=
>
FfiConverterString
.
lift
(
result
)
;
const
liftError
=
(
data
)
=
>
FfiConverterTypeTodoError
.
lift
(
data
)
;
const
functionCall
=
(
)
=
>
{
return
UniFFIScaffolding
.
callAsync
(
100
FfiConverterTypeTodoList
.
lower
(
this
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
getFirst
(
)
{
const
liftResult
=
(
result
)
=
>
FfiConverterString
.
lift
(
result
)
;
const
liftError
=
(
data
)
=
>
FfiConverterTypeTodoError
.
lift
(
data
)
;
const
functionCall
=
(
)
=
>
{
return
UniFFIScaffolding
.
callAsync
(
101
FfiConverterTypeTodoList
.
lower
(
this
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
clearItem
(
todo
)
{
const
liftResult
=
(
result
)
=
>
undefined
;
const
liftError
=
(
data
)
=
>
FfiConverterTypeTodoError
.
lift
(
data
)
;
const
functionCall
=
(
)
=
>
{
FfiConverterString
.
checkType
(
"
todo
"
todo
)
;
return
UniFFIScaffolding
.
callAsync
(
102
FfiConverterTypeTodoList
.
lower
(
this
)
FfiConverterString
.
lower
(
todo
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
makeDefault
(
)
{
const
liftResult
=
(
result
)
=
>
undefined
;
const
liftError
=
null
;
const
functionCall
=
(
)
=
>
{
return
UniFFIScaffolding
.
callAsync
(
103
FfiConverterTypeTodoList
.
lower
(
this
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
}
class
FfiConverterTypeTodoList
extends
FfiConverter
{
static
lift
(
value
)
{
const
opts
=
{
}
;
opts
[
constructUniffiObject
]
=
value
;
return
new
TodoList
(
opts
)
;
}
static
lower
(
value
)
{
return
value
[
uniffiObjectPtr
]
;
}
static
read
(
dataStream
)
{
return
this
.
lift
(
dataStream
.
readPointerTodoList
(
)
)
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writePointerTodoList
(
value
[
uniffiObjectPtr
]
)
;
}
static
computeSize
(
value
)
{
return
8
;
}
}
EXPORTED_SYMBOLS
.
push
(
"
TodoList
"
)
;
EXPORTED_SYMBOLS
.
push
(
"
FfiConverterTypeTodoList
"
)
;
class
TodoEntry
{
constructor
(
text
)
{
FfiConverterString
.
checkType
(
"
text
"
text
)
;
this
.
text
=
text
;
}
equals
(
other
)
{
return
(
this
.
text
=
=
other
.
text
)
}
}
class
FfiConverterTypeTodoEntry
extends
FfiConverter
{
static
lift
(
buf
)
{
return
this
.
read
(
new
ArrayBufferDataStream
(
buf
)
)
;
}
static
lower
(
value
)
{
const
buf
=
new
ArrayBuffer
(
this
.
computeSize
(
value
)
)
;
const
dataStream
=
new
ArrayBufferDataStream
(
buf
)
;
this
.
write
(
dataStream
value
)
;
return
buf
;
}
static
read
(
dataStream
)
{
return
new
TodoEntry
(
FfiConverterString
.
read
(
dataStream
)
)
;
}
static
write
(
dataStream
value
)
{
FfiConverterString
.
write
(
dataStream
value
.
text
)
;
}
static
computeSize
(
value
)
{
let
totalSize
=
0
;
totalSize
+
=
FfiConverterString
.
computeSize
(
value
.
text
)
;
return
totalSize
}
}
EXPORTED_SYMBOLS
.
push
(
"
TodoEntry
"
)
;
EXPORTED_SYMBOLS
.
push
(
"
FfiConverterTypeTodoEntry
"
)
;
class
TodoError
extends
Error
{
}
EXPORTED_SYMBOLS
.
push
(
"
TodoError
"
)
;
class
TodoDoesNotExist
extends
TodoError
{
constructor
(
message
.
.
.
params
)
{
super
(
.
.
.
params
)
;
this
.
message
=
message
;
}
toString
(
)
{
return
TodoDoesNotExist
:
{
super
.
toString
(
)
}
}
}
EXPORTED_SYMBOLS
.
push
(
"
TodoDoesNotExist
"
)
;
class
EmptyTodoList
extends
TodoError
{
constructor
(
message
.
.
.
params
)
{
super
(
.
.
.
params
)
;
this
.
message
=
message
;
}
toString
(
)
{
return
EmptyTodoList
:
{
super
.
toString
(
)
}
}
}
EXPORTED_SYMBOLS
.
push
(
"
EmptyTodoList
"
)
;
class
DuplicateTodo
extends
TodoError
{
constructor
(
message
.
.
.
params
)
{
super
(
.
.
.
params
)
;
this
.
message
=
message
;
}
toString
(
)
{
return
DuplicateTodo
:
{
super
.
toString
(
)
}
}
}
EXPORTED_SYMBOLS
.
push
(
"
DuplicateTodo
"
)
;
class
EmptyString
extends
TodoError
{
constructor
(
message
.
.
.
params
)
{
super
(
.
.
.
params
)
;
this
.
message
=
message
;
}
toString
(
)
{
return
EmptyString
:
{
super
.
toString
(
)
}
}
}
EXPORTED_SYMBOLS
.
push
(
"
EmptyString
"
)
;
class
DeligatedError
extends
TodoError
{
constructor
(
message
.
.
.
params
)
{
super
(
.
.
.
params
)
;
this
.
message
=
message
;
}
toString
(
)
{
return
DeligatedError
:
{
super
.
toString
(
)
}
}
}
EXPORTED_SYMBOLS
.
push
(
"
DeligatedError
"
)
;
class
FfiConverterTypeTodoError
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
switch
(
dataStream
.
readInt32
(
)
)
{
case
1
:
return
new
TodoDoesNotExist
(
FfiConverterString
.
read
(
dataStream
)
)
;
case
2
:
return
new
EmptyTodoList
(
FfiConverterString
.
read
(
dataStream
)
)
;
case
3
:
return
new
DuplicateTodo
(
FfiConverterString
.
read
(
dataStream
)
)
;
case
4
:
return
new
EmptyString
(
FfiConverterString
.
read
(
dataStream
)
)
;
case
5
:
return
new
DeligatedError
(
FfiConverterString
.
read
(
dataStream
)
)
;
default
:
throw
new
Error
(
"
Unknown
TodoError
variant
"
)
;
}
}
static
computeSize
(
value
)
{
let
totalSize
=
4
;
if
(
value
instanceof
TodoDoesNotExist
)
{
return
totalSize
;
}
if
(
value
instanceof
EmptyTodoList
)
{
return
totalSize
;
}
if
(
value
instanceof
DuplicateTodo
)
{
return
totalSize
;
}
if
(
value
instanceof
EmptyString
)
{
return
totalSize
;
}
if
(
value
instanceof
DeligatedError
)
{
return
totalSize
;
}
throw
new
Error
(
"
Unknown
TodoError
variant
"
)
;
}
static
write
(
dataStream
value
)
{
if
(
value
instanceof
TodoDoesNotExist
)
{
dataStream
.
writeInt32
(
1
)
;
return
;
}
if
(
value
instanceof
EmptyTodoList
)
{
dataStream
.
writeInt32
(
2
)
;
return
;
}
if
(
value
instanceof
DuplicateTodo
)
{
dataStream
.
writeInt32
(
3
)
;
return
;
}
if
(
value
instanceof
EmptyString
)
{
dataStream
.
writeInt32
(
4
)
;
return
;
}
if
(
value
instanceof
DeligatedError
)
{
dataStream
.
writeInt32
(
5
)
;
return
;
}
throw
new
Error
(
"
Unknown
TodoError
variant
"
)
;
}
static
errorClass
=
TodoError
;
}
EXPORTED_SYMBOLS
.
push
(
"
FfiConverterTypeTodoError
"
)
;
class
FfiConverterOptionalTypeTodoList
extends
FfiConverterArrayBuffer
{
static
checkType
(
name
value
)
{
if
(
value
!
=
=
undefined
&
&
value
!
=
=
null
)
{
FfiConverterTypeTodoList
.
checkType
(
name
value
)
}
}
static
read
(
dataStream
)
{
const
code
=
dataStream
.
readUint8
(
0
)
;
switch
(
code
)
{
case
0
:
return
null
case
1
:
return
FfiConverterTypeTodoList
.
read
(
dataStream
)
default
:
throw
UniFFIError
(
Unexpected
code
:
{
code
}
)
;
}
}
static
write
(
dataStream
value
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
dataStream
.
writeUint8
(
0
)
;
return
;
}
dataStream
.
writeUint8
(
1
)
;
FfiConverterTypeTodoList
.
write
(
dataStream
value
)
}
static
computeSize
(
value
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
return
1
;
}
return
1
+
FfiConverterTypeTodoList
.
computeSize
(
value
)
}
}
EXPORTED_SYMBOLS
.
push
(
"
FfiConverterOptionalTypeTodoList
"
)
;
class
FfiConverterSequencestring
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
const
len
=
dataStream
.
readInt32
(
)
;
const
arr
=
[
]
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
arr
.
push
(
FfiConverterString
.
read
(
dataStream
)
)
;
}
return
arr
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeInt32
(
value
.
length
)
;
value
.
forEach
(
(
innerValue
)
=
>
{
FfiConverterString
.
write
(
dataStream
innerValue
)
;
}
)
}
static
computeSize
(
value
)
{
let
size
=
4
;
for
(
const
innerValue
of
value
)
{
size
+
=
FfiConverterString
.
computeSize
(
innerValue
)
;
}
return
size
;
}
}
EXPORTED_SYMBOLS
.
push
(
"
FfiConverterSequencestring
"
)
;
class
FfiConverterSequenceTypeTodoEntry
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
const
len
=
dataStream
.
readInt32
(
)
;
const
arr
=
[
]
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
arr
.
push
(
FfiConverterTypeTodoEntry
.
read
(
dataStream
)
)
;
}
return
arr
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeInt32
(
value
.
length
)
;
value
.
forEach
(
(
innerValue
)
=
>
{
FfiConverterTypeTodoEntry
.
write
(
dataStream
innerValue
)
;
}
)
}
static
computeSize
(
value
)
{
let
size
=
4
;
for
(
const
innerValue
of
value
)
{
size
+
=
FfiConverterTypeTodoEntry
.
computeSize
(
innerValue
)
;
}
return
size
;
}
}
EXPORTED_SYMBOLS
.
push
(
"
FfiConverterSequenceTypeTodoEntry
"
)
;
function
getDefaultList
(
)
{
const
liftResult
=
(
result
)
=
>
FfiConverterOptionalTypeTodoList
.
lift
(
result
)
;
const
liftError
=
null
;
const
functionCall
=
(
)
=
>
{
return
UniFFIScaffolding
.
callAsync
(
104
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
EXPORTED_SYMBOLS
.
push
(
"
getDefaultList
"
)
;
function
setDefaultList
(
list
)
{
const
liftResult
=
(
result
)
=
>
undefined
;
const
liftError
=
null
;
const
functionCall
=
(
)
=
>
{
FfiConverterTypeTodoList
.
checkType
(
"
list
"
list
)
;
return
UniFFIScaffolding
.
callAsync
(
105
FfiConverterTypeTodoList
.
lower
(
list
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
EXPORTED_SYMBOLS
.
push
(
"
setDefaultList
"
)
;
function
createEntryWith
(
todo
)
{
const
liftResult
=
(
result
)
=
>
FfiConverterTypeTodoEntry
.
lift
(
result
)
;
const
liftError
=
(
data
)
=
>
FfiConverterTypeTodoError
.
lift
(
data
)
;
const
functionCall
=
(
)
=
>
{
FfiConverterString
.
checkType
(
"
todo
"
todo
)
;
return
UniFFIScaffolding
.
callAsync
(
106
FfiConverterString
.
lower
(
todo
)
)
}
try
{
return
functionCall
(
)
.
then
(
(
result
)
=
>
handleRustResult
(
result
liftResult
liftError
)
)
;
}
catch
(
error
)
{
return
Promise
.
reject
(
error
)
}
}
EXPORTED_SYMBOLS
.
push
(
"
createEntryWith
"
)
;
