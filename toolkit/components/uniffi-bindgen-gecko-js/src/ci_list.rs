use
std
:
:
collections
:
:
{
BTreeSet
HashMap
HashSet
}
;
use
anyhow
:
:
{
anyhow
bail
Context
Result
}
;
use
camino
:
:
{
Utf8Path
Utf8PathBuf
}
;
use
uniffi_bindgen
:
:
interface
:
:
{
CallbackInterface
ComponentInterface
FfiFunction
Object
}
;
use
crate
:
:
render
:
:
cpp
:
:
exposed_functions
;
use
crate
:
:
Component
;
pub
struct
ComponentUniverse
{
pub
components
:
Vec
<
Component
>
pub
fixture_components
:
Vec
<
Component
>
}
impl
ComponentUniverse
{
pub
fn
new
(
library_path
:
Utf8PathBuf
fixtures_library_path
:
Utf8PathBuf
)
-
>
Result
<
Self
>
{
let
config_supplier
=
GeckoJsCrateConfigSupplier
:
:
new
(
)
?
;
let
universe
=
Self
{
components
:
find_components
(
&
library_path
&
config_supplier
)
?
fixture_components
:
find_components
(
&
fixtures_library_path
&
config_supplier
)
?
}
;
universe
.
check_udl_namespaces_unique
(
)
?
;
universe
.
check_callback_interfaces
(
)
?
;
Ok
(
universe
)
}
fn
check_udl_namespaces_unique
(
&
self
)
-
>
Result
<
(
)
>
{
let
mut
set
=
HashSet
:
:
new
(
)
;
for
ci
in
self
.
iter_cis
(
)
{
if
!
set
.
insert
(
ci
.
namespace
(
)
)
{
bail
!
(
"
UDL
files
have
duplicate
namespace
:
{
}
"
ci
.
namespace
(
)
)
;
}
}
Ok
(
(
)
)
}
fn
check_callback_interfaces
(
&
self
)
-
>
Result
<
(
)
>
{
for
ci
in
self
.
iter_cis
(
)
{
for
cbi
in
ci
.
callback_interface_definitions
(
)
{
for
method
in
cbi
.
methods
(
)
{
if
method
.
return_type
(
)
.
is_some
(
)
{
bail
!
(
"
Callback
interface
method
{
}
.
{
}
throws
an
error
which
is
not
yet
supported
"
cbi
.
name
(
)
method
.
name
(
)
)
}
if
method
.
throws_type
(
)
.
is_some
(
)
{
bail
!
(
"
Callback
interface
method
{
}
.
{
}
returns
a
value
which
is
not
yet
supported
"
cbi
.
name
(
)
method
.
name
(
)
)
}
}
}
}
Ok
(
(
)
)
}
pub
fn
iter_components
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Component
>
{
self
.
components
.
iter
(
)
.
chain
(
self
.
fixture_components
.
iter
(
)
)
}
pub
fn
iter_cis
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
ComponentInterface
>
{
self
.
iter_components
(
)
.
map
(
|
component
|
&
component
.
ci
)
}
}
fn
find_components
(
library_path
:
&
Utf8Path
config_supplier
:
&
GeckoJsCrateConfigSupplier
)
-
>
Result
<
Vec
<
Component
>
>
{
let
mut
components
=
uniffi_bindgen
:
:
find_components
(
library_path
config_supplier
)
?
.
into_iter
(
)
.
filter
(
|
component
|
{
let
namespace
=
component
.
ci
.
namespace
(
)
;
namespace
!
=
"
errorsupport
"
&
&
namespace
!
=
"
fixture_callbacks
"
}
)
.
map
(
|
component
|
{
Ok
(
Component
{
config
:
toml
:
:
Value
:
:
Table
(
component
.
config
)
.
try_into
(
)
?
ci
:
component
.
ci
}
)
}
)
.
collect
:
:
<
Result
<
Vec
<
Component
>
>
>
(
)
?
;
components
.
sort_by
(
|
c1
c2
|
c1
.
ci
.
namespace
(
)
.
cmp
(
c2
.
ci
.
namespace
(
)
)
)
;
Ok
(
components
)
}
struct
GeckoJsCrateConfigSupplier
{
cargo_crate_config_supplier
:
uniffi_bindgen
:
:
cargo_metadata
:
:
CrateConfigSupplier
config_table
:
toml
:
:
map
:
:
Map
<
String
toml
:
:
Value
>
}
impl
GeckoJsCrateConfigSupplier
{
fn
new
(
)
-
>
Result
<
Self
>
{
Ok
(
Self
{
cargo_crate_config_supplier
:
cargo_metadata
:
:
MetadataCommand
:
:
new
(
)
.
exec
(
)
.
context
(
"
error
running
cargo
metadata
"
)
?
.
into
(
)
config_table
:
toml
:
:
from_str
(
include_str
!
(
"
.
.
/
config
.
toml
"
)
)
?
}
)
}
}
impl
uniffi_bindgen
:
:
BindgenCrateConfigSupplier
for
GeckoJsCrateConfigSupplier
{
fn
get_udl
(
&
self
crate_name
:
&
str
udl_name
:
&
str
)
-
>
anyhow
:
:
Result
<
String
>
{
self
.
cargo_crate_config_supplier
.
get_udl
(
crate_name
udl_name
)
}
fn
get_toml
(
&
self
crate_name
:
&
str
)
-
>
anyhow
:
:
Result
<
Option
<
toml
:
:
value
:
:
Table
>
>
{
self
.
config_table
.
get
(
crate_name
)
.
map
(
|
v
|
{
v
.
as_table
(
)
.
ok_or_else
(
|
|
anyhow
!
(
"
Config
value
not
table
"
)
)
.
cloned
(
)
}
)
.
transpose
(
)
}
}
pub
struct
FunctionIds
<
'
a
>
{
map
:
HashMap
<
(
&
'
a
str
&
'
a
str
)
usize
>
}
impl
<
'
a
>
FunctionIds
<
'
a
>
{
pub
fn
new
(
cis
:
&
'
a
ComponentUniverse
)
-
>
Self
{
Self
{
map
:
cis
.
iter_cis
(
)
.
flat_map
(
|
ci
|
exposed_functions
(
ci
)
.
map
(
move
|
f
|
(
ci
.
namespace
(
)
f
.
name
(
)
)
)
)
.
enumerate
(
)
.
map
(
|
(
i
(
namespace
name
)
)
|
(
(
namespace
name
)
i
)
)
.
collect
:
:
<
BTreeSet
<
_
>
>
(
)
.
into_iter
(
)
.
collect
(
)
}
}
pub
fn
get
(
&
self
ci
:
&
ComponentInterface
func
:
&
FfiFunction
)
-
>
usize
{
return
*
self
.
map
.
get
(
&
(
ci
.
namespace
(
)
func
.
name
(
)
)
)
.
unwrap
(
)
;
}
pub
fn
name
(
&
self
ci
:
&
ComponentInterface
func
:
&
FfiFunction
)
-
>
String
{
format
!
(
"
{
}
:
{
}
"
ci
.
namespace
(
)
func
.
name
(
)
)
}
}
pub
struct
ObjectIds
<
'
a
>
{
map
:
HashMap
<
(
&
'
a
str
&
'
a
str
)
usize
>
}
impl
<
'
a
>
ObjectIds
<
'
a
>
{
pub
fn
new
(
cis
:
&
'
a
ComponentUniverse
)
-
>
Self
{
Self
{
map
:
cis
.
iter_cis
(
)
.
flat_map
(
|
ci
|
{
ci
.
object_definitions
(
)
.
iter
(
)
.
map
(
move
|
o
|
(
ci
.
namespace
(
)
o
.
name
(
)
)
)
}
)
.
enumerate
(
)
.
map
(
|
(
i
(
namespace
name
)
)
|
(
(
namespace
name
)
i
)
)
.
collect
:
:
<
BTreeSet
<
_
>
>
(
)
.
into_iter
(
)
.
collect
(
)
}
}
pub
fn
get
(
&
self
ci
:
&
ComponentInterface
obj
:
&
Object
)
-
>
usize
{
return
*
self
.
map
.
get
(
&
(
ci
.
namespace
(
)
obj
.
name
(
)
)
)
.
unwrap
(
)
;
}
pub
fn
name
(
&
self
ci
:
&
ComponentInterface
obj
:
&
Object
)
-
>
String
{
format
!
(
"
{
}
:
{
}
"
ci
.
namespace
(
)
obj
.
name
(
)
)
}
}
pub
struct
CallbackIds
<
'
a
>
{
map
:
HashMap
<
(
&
'
a
str
&
'
a
str
)
usize
>
}
impl
<
'
a
>
CallbackIds
<
'
a
>
{
pub
fn
new
(
cis
:
&
'
a
ComponentUniverse
)
-
>
Self
{
Self
{
map
:
cis
.
iter_cis
(
)
.
flat_map
(
|
ci
|
{
ci
.
callback_interface_definitions
(
)
.
iter
(
)
.
map
(
move
|
cb
|
(
ci
.
namespace
(
)
cb
.
name
(
)
)
)
}
)
.
enumerate
(
)
.
map
(
|
(
i
(
namespace
name
)
)
|
(
(
namespace
name
)
i
)
)
.
collect
:
:
<
BTreeSet
<
_
>
>
(
)
.
into_iter
(
)
.
collect
(
)
}
}
pub
fn
get
(
&
self
ci
:
&
ComponentInterface
cb
:
&
CallbackInterface
)
-
>
usize
{
return
*
self
.
map
.
get
(
&
(
ci
.
namespace
(
)
cb
.
name
(
)
)
)
.
unwrap
(
)
;
}
pub
fn
name
(
&
self
ci
:
&
ComponentInterface
cb
:
&
CallbackInterface
)
-
>
String
{
format
!
(
"
{
}
:
{
}
"
ci
.
namespace
(
)
cb
.
name
(
)
)
}
}
