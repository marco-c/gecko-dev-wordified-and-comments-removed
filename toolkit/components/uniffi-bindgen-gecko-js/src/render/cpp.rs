use
crate
:
:
{
FunctionIds
ObjectIds
}
;
use
askama
:
:
Template
;
use
extend
:
:
ext
;
use
heck
:
:
ToUpperCamelCase
;
use
std
:
:
collections
:
:
HashSet
;
use
std
:
:
iter
;
use
uniffi_bindgen
:
:
interface
:
:
{
ComponentInterface
FFIArgument
FFIFunction
FFIType
Object
}
;
#
[
derive
(
Template
)
]
#
[
template
(
path
=
"
UniFFIScaffolding
.
cpp
"
escape
=
"
none
"
)
]
pub
struct
CPPScaffoldingTemplate
<
'
a
>
{
pub
prefix
:
&
'
a
str
pub
ci_list
:
&
'
a
Vec
<
ComponentInterface
>
pub
function_ids
:
&
'
a
FunctionIds
<
'
a
>
pub
object_ids
:
&
'
a
ObjectIds
<
'
a
>
}
impl
<
'
a
>
CPPScaffoldingTemplate
<
'
a
>
{
fn
has_any_objects
(
&
self
)
-
>
bool
{
self
.
ci_list
.
iter
(
)
.
any
(
|
ci
|
ci
.
object_definitions
(
)
.
len
(
)
>
0
)
}
}
#
[
ext
(
name
=
ComponentInterfaceCppExt
)
]
pub
impl
ComponentInterface
{
fn
pointer_type
(
&
self
object
:
&
Object
)
-
>
String
{
self
.
_pointer_type
(
object
.
name
(
)
)
}
fn
_pointer_type
(
&
self
name
:
&
str
)
-
>
String
{
format
!
(
"
k
{
}
{
}
PointerType
"
self
.
namespace
(
)
.
to_upper_camel_case
(
)
name
.
to_upper_camel_case
(
)
)
}
fn
exposed_functions
(
&
self
)
-
>
Vec
<
&
FFIFunction
>
{
let
excluded
:
HashSet
<
_
>
=
self
.
object_definitions
(
)
.
iter
(
)
.
map
(
|
o
|
o
.
ffi_object_free
(
)
.
name
(
)
)
.
collect
(
)
;
self
.
iter_user_ffi_function_definitions
(
)
.
filter
(
move
|
f
|
!
excluded
.
contains
(
f
.
name
(
)
)
)
.
collect
(
)
}
fn
scaffolding_converter
(
&
self
ffi_type
:
&
FFIType
)
-
>
String
{
match
ffi_type
{
FFIType
:
:
RustArcPtr
(
name
)
=
>
{
format
!
(
"
ScaffoldingObjectConverter
<
&
{
}
>
"
self
.
_pointer_type
(
name
)
)
}
_
=
>
format
!
(
"
ScaffoldingConverter
<
{
}
>
"
ffi_type
.
rust_type
(
)
)
}
}
fn
scaffolding_call_handler
(
&
self
func
:
&
FFIFunction
)
-
>
String
{
let
return_param
=
match
func
.
return_type
(
)
{
Some
(
return_type
)
=
>
self
.
scaffolding_converter
(
return_type
)
None
=
>
"
ScaffoldingConverter
<
void
>
"
.
to_string
(
)
}
;
let
all_params
=
iter
:
:
once
(
return_param
)
.
chain
(
func
.
arguments
(
)
.
into_iter
(
)
.
map
(
|
a
|
self
.
scaffolding_converter
(
&
a
.
type_
(
)
)
)
)
.
collect
:
:
<
Vec
<
_
>
>
(
)
.
join
(
"
"
)
;
return
format
!
(
"
ScaffoldingCallHandler
<
{
}
>
"
all_params
)
;
}
}
#
[
ext
(
name
=
FFIFunctionCppExt
)
]
pub
impl
FFIFunction
{
fn
nm
(
&
self
)
-
>
String
{
self
.
name
(
)
.
to_upper_camel_case
(
)
}
fn
rust_name
(
&
self
)
-
>
String
{
self
.
name
(
)
.
to_string
(
)
}
fn
rust_return_type
(
&
self
)
-
>
String
{
match
self
.
return_type
(
)
{
Some
(
t
)
=
>
t
.
rust_type
(
)
None
=
>
"
void
"
.
to_owned
(
)
}
}
fn
rust_arg_list
(
&
self
)
-
>
String
{
let
mut
parts
:
Vec
<
String
>
=
self
.
arguments
(
)
.
iter
(
)
.
map
(
|
a
|
a
.
rust_type
(
)
)
.
collect
(
)
;
parts
.
push
(
"
RustCallStatus
*
"
.
to_owned
(
)
)
;
parts
.
join
(
"
"
)
}
}
#
[
ext
(
name
=
FFITypeCppExt
)
]
pub
impl
FFIType
{
fn
rust_type
(
&
self
)
-
>
String
{
match
self
{
FFIType
:
:
UInt8
=
>
"
uint8_t
"
FFIType
:
:
Int8
=
>
"
int8_t
"
FFIType
:
:
UInt16
=
>
"
uint16_t
"
FFIType
:
:
Int16
=
>
"
int16_t
"
FFIType
:
:
UInt32
=
>
"
uint32_t
"
FFIType
:
:
Int32
=
>
"
int32_t
"
FFIType
:
:
UInt64
=
>
"
uint64_t
"
FFIType
:
:
Int64
=
>
"
int64_t
"
FFIType
:
:
Float32
=
>
"
float
"
FFIType
:
:
Float64
=
>
"
double
"
FFIType
:
:
RustBuffer
=
>
"
RustBuffer
"
FFIType
:
:
RustArcPtr
(
_
)
=
>
"
void
*
"
FFIType
:
:
ForeignBytes
=
>
unimplemented
!
(
"
ForeignBytes
not
supported
"
)
FFIType
:
:
ForeignCallback
=
>
unimplemented
!
(
"
ForeignCallback
not
supported
"
)
}
.
to_owned
(
)
}
}
#
[
ext
(
name
=
FFIArgumentCppExt
)
]
pub
impl
FFIArgument
{
fn
rust_type
(
&
self
)
-
>
String
{
self
.
type_
(
)
.
rust_type
(
)
}
}
#
[
ext
(
name
=
ObjectCppExt
)
]
pub
impl
Object
{
fn
nm
(
&
self
)
-
>
String
{
self
.
name
(
)
.
to_upper_camel_case
(
)
}
}
