class
UniFFICallbackHandler
{
#
name
;
#
interfaceId
;
#
handleCounter
;
#
handleMap
;
#
methodHandlers
;
#
allowNewCallbacks
constructor
(
name
interfaceId
methodHandlers
)
{
this
.
#
name
=
name
;
this
.
#
interfaceId
=
interfaceId
;
this
.
#
handleCounter
=
0
;
this
.
#
handleMap
=
new
Map
(
)
;
this
.
#
methodHandlers
=
methodHandlers
;
this
.
#
allowNewCallbacks
=
true
;
UniFFIScaffolding
.
registerCallbackHandler
(
this
.
#
interfaceId
this
.
invokeCallback
.
bind
(
this
)
)
;
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
}
storeCallbackObj
(
callbackObj
)
{
if
(
!
this
.
#
allowNewCallbacks
)
{
throw
new
UniFFIError
(
No
new
callbacks
allowed
for
{
this
.
#
name
}
)
;
}
const
handle
=
this
.
#
handleCounter
;
this
.
#
handleCounter
+
=
1
;
this
.
#
handleMap
.
set
(
handle
new
UniFFICallbackHandleMapEntry
(
callbackObj
Components
.
stack
.
caller
.
formattedStack
.
trim
(
)
)
)
;
return
handle
;
}
/
*
*
*
Get
a
previously
stored
callback
object
*
*
param
{
int
}
handle
-
Callback
object
handle
returned
from
storeCallbackObj
(
)
*
returns
{
obj
}
-
Callback
object
*
/
getCallbackObj
(
handle
)
{
return
this
.
#
handleMap
.
get
(
handle
)
.
callbackObj
;
}
/
*
*
*
Set
if
new
callbacks
are
allowed
for
this
handler
*
*
This
is
called
with
false
during
shutdown
to
ensure
the
callback
maps
don
'
t
*
prevent
JS
objects
from
being
GCed
.
*
/
setAllowNewCallbacks
(
allow
)
{
this
.
#
allowNewCallbacks
=
allow
}
/
*
*
*
Check
that
no
callbacks
are
currently
registered
*
*
If
there
are
callbacks
registered
a
UniFFIError
will
be
thrown
.
This
is
*
called
during
shutdown
to
generate
an
alert
if
there
are
leaked
callback
*
interfaces
.
*
/
assertNoRegisteredCallbacks
(
)
{
if
(
this
.
#
handleMap
.
size
>
0
)
{
const
entry
=
this
.
#
handleMap
.
values
(
)
.
next
(
)
.
value
;
throw
new
UniFFIError
(
UniFFI
interface
{
this
.
#
name
}
has
{
this
.
#
handleMap
.
size
}
registered
callbacks
at
xpcom
-
shutdown
.
This
likely
indicates
a
UniFFI
callback
leak
.
\
nStack
trace
for
the
first
leaked
callback
:
\
n
{
entry
.
stackTrace
}
.
)
;
}
}
invokeCallback
(
handle
methodId
argsArrayBuffer
)
{
try
{
this
.
#
invokeCallbackInner
(
handle
methodId
argsArrayBuffer
)
;
}
catch
(
e
)
{
console
.
error
(
internal
error
invoking
callback
:
{
e
}
)
}
}
#
invokeCallbackInner
(
handle
methodId
argsArrayBuffer
)
{
const
callbackObj
=
this
.
getCallbackObj
(
handle
)
;
if
(
callbackObj
=
=
=
undefined
)
{
throw
new
UniFFIError
(
{
this
.
#
name
}
:
invalid
callback
handle
id
:
{
handle
}
)
;
}
/
/
Special
-
cased
drop
method
remove
the
object
from
the
handle
map
and
/
/
return
an
empty
array
buffer
if
(
methodId
=
=
0
)
{
this
.
#
handleMap
.
delete
(
handle
)
;
return
;
}
/
/
Get
the
method
data
converting
from
1
-
based
indexing
const
methodHandler
=
this
.
#
methodHandlers
[
methodId
-
1
]
;
if
(
methodHandler
=
=
=
undefined
)
{
throw
new
UniFFIError
(
{
this
.
#
name
}
:
invalid
method
id
:
{
methodId
}
)
}
methodHandler
.
call
(
callbackObj
argsArrayBuffer
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
xpcom
-
shutdown
"
)
{
try
{
this
.
setAllowNewCallbacks
(
false
)
;
this
.
assertNoRegisteredCallbacks
(
)
;
UniFFIScaffolding
.
deregisterCallbackHandler
(
this
.
#
interfaceId
)
;
}
catch
(
ex
)
{
console
.
error
(
UniFFI
Callback
interface
error
during
xpcom
-
shutdown
:
{
ex
}
)
;
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
.
abort
(
ex
.
filename
ex
.
lineNumber
)
;
}
}
}
}
class
UniFFICallbackMethodHandler
{
#
name
;
#
argsConverters
;
constructor
(
name
argsConverters
)
{
this
.
#
name
=
name
;
this
.
#
argsConverters
=
argsConverters
;
}
call
(
callbackObj
argsArrayBuffer
)
{
const
argsStream
=
new
ArrayBufferDataStream
(
argsArrayBuffer
)
;
const
args
=
this
.
#
argsConverters
.
map
(
converter
=
>
converter
.
read
(
argsStream
)
)
;
callbackObj
[
this
.
#
name
]
(
.
.
.
args
)
;
}
}
class
UniFFICallbackHandleMapEntry
{
constructor
(
callbackObj
stackTrace
)
{
this
.
callbackObj
=
callbackObj
;
this
.
stackTrace
=
stackTrace
}
}
