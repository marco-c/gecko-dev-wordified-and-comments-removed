"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
{
PromptUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
SharedPromptUtils
.
jsm
"
)
;
const
{
MODAL_TYPE_CONTENT
MODAL_TYPE_WINDOW
MODAL_TYPE_INTERNAL_WINDOW
}
=
Ci
.
nsIPrompt
;
const
COMMON_DIALOG
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
;
const
SELECT_DIALOG
=
"
chrome
:
/
/
global
/
content
/
selectDialog
.
xhtml
"
;
function
Prompter
(
)
{
}
Prompter
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
1c978d25
-
b37f
-
43a8
-
a2d6
-
0c7a239ead87
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIPromptFactory
"
"
nsIPromptService
"
]
)
pickPrompter
(
options
)
{
return
new
ModalPrompter
(
options
)
;
}
getPrompt
(
domWin
iid
)
{
if
(
iid
.
equals
(
Ci
.
nsIAuthPrompt2
)
|
|
iid
.
equals
(
Ci
.
nsIAuthPrompt
)
)
{
try
{
let
pwmgr
=
Cc
[
"
mozilla
.
org
/
passwordmanager
/
authpromptfactory
;
1
"
]
.
getService
(
Ci
.
nsIPromptFactory
)
;
return
pwmgr
.
getPrompt
(
domWin
iid
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
nsPrompter
:
Delegation
to
password
manager
failed
:
"
+
e
)
;
}
}
let
p
=
new
ModalPrompter
(
{
domWin
}
)
;
p
.
QueryInterface
(
iid
)
;
return
p
;
}
alert
(
domWin
title
text
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
p
.
alert
(
title
text
)
;
}
alertBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
p
.
alert
(
.
.
.
promptArgs
)
;
}
asyncAlert
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
alert
(
.
.
.
promptArgs
)
;
}
alertCheck
(
domWin
title
text
checkLabel
checkValue
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
p
.
alertCheck
(
title
text
checkLabel
checkValue
)
;
}
alertCheckBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
p
.
alertCheck
(
.
.
.
promptArgs
)
;
}
asyncAlertCheck
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
alertCheck
(
.
.
.
promptArgs
)
;
}
confirm
(
domWin
title
text
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
return
p
.
confirm
(
title
text
)
;
}
confirmBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
return
p
.
confirm
(
.
.
.
promptArgs
)
;
}
asyncConfirm
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
confirm
(
.
.
.
promptArgs
)
;
}
confirmCheck
(
domWin
title
text
checkLabel
checkValue
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
return
p
.
confirmCheck
(
title
text
checkLabel
checkValue
)
;
}
confirmCheckBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
return
p
.
confirmCheck
(
.
.
.
promptArgs
)
;
}
asyncConfirmCheck
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
confirmCheck
(
.
.
.
promptArgs
)
;
}
confirmEx
(
domWin
title
text
flags
button0
button1
button2
checkLabel
checkValue
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
return
p
.
confirmEx
(
title
text
flags
button0
button1
button2
checkLabel
checkValue
)
;
}
confirmExBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
return
p
.
confirmEx
(
.
.
.
promptArgs
)
;
}
asyncConfirmEx
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
confirmEx
(
.
.
.
promptArgs
)
;
}
prompt
(
domWin
title
text
value
checkLabel
checkValue
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
return
p
.
nsIPrompt_prompt
(
title
text
value
checkLabel
checkValue
)
;
}
promptBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
return
p
.
nsIPrompt_prompt
(
.
.
.
promptArgs
)
;
}
asyncPrompt
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
nsIPrompt_prompt
(
.
.
.
promptArgs
)
;
}
promptUsernameAndPassword
(
domWin
title
text
user
pass
checkLabel
checkValue
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
return
p
.
nsIPrompt_promptUsernameAndPassword
(
title
text
user
pass
checkLabel
checkValue
)
;
}
promptUsernameAndPasswordBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
return
p
.
nsIPrompt_promptUsernameAndPassword
(
.
.
.
promptArgs
)
;
}
asyncPromptUsernameAndPassword
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
nsIPrompt_promptUsernameAndPassword
(
.
.
.
promptArgs
)
;
}
promptPassword
(
domWin
title
text
pass
checkLabel
checkValue
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
return
p
.
nsIPrompt_promptPassword
(
title
text
pass
checkLabel
checkValue
)
;
}
promptPasswordBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
return
p
.
nsIPrompt_promptPassword
(
.
.
.
promptArgs
)
;
}
asyncPromptPassword
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
nsIPrompt_promptPassword
(
.
.
.
promptArgs
)
;
}
select
(
domWin
title
text
list
selected
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
return
p
.
select
(
title
text
list
selected
)
;
}
selectBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
return
p
.
select
(
.
.
.
promptArgs
)
;
}
asyncSelect
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
select
(
.
.
.
promptArgs
)
;
}
promptAuth
(
domWin
channel
level
authInfo
checkLabel
checkValue
)
{
let
p
=
this
.
pickPrompter
(
{
domWin
}
)
;
return
p
.
promptAuth
(
channel
level
authInfo
checkLabel
checkValue
)
;
}
promptAuthBC
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
}
)
;
return
p
.
promptAuth
(
.
.
.
promptArgs
)
;
}
asyncPromptAuth
(
browsingContext
modalType
.
.
.
promptArgs
)
{
let
p
=
this
.
pickPrompter
(
{
browsingContext
modalType
async
:
true
}
)
;
return
p
.
promptAuth
(
.
.
.
promptArgs
)
;
}
}
;
var
PromptUtilsTemp
=
{
__proto__
:
PromptUtils
getLocalizedString
(
key
formatArgs
)
{
if
(
formatArgs
)
{
return
this
.
strBundle
.
formatStringFromName
(
key
formatArgs
)
;
}
return
this
.
strBundle
.
GetStringFromName
(
key
)
;
}
confirmExHelper
(
flags
button0
button1
button2
)
{
const
BUTTON_DEFAULT_MASK
=
0x03000000
;
let
defaultButtonNum
=
(
flags
&
BUTTON_DEFAULT_MASK
)
>
>
24
;
let
isDelayEnabled
=
flags
&
Ci
.
nsIPrompt
.
BUTTON_DELAY_ENABLE
;
let
argText
=
[
button0
button1
button2
]
;
let
buttonLabels
=
[
null
null
null
]
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
let
buttonLabel
;
switch
(
flags
&
0xff
)
{
case
Ci
.
nsIPrompt
.
BUTTON_TITLE_OK
:
buttonLabel
=
PromptUtils
.
getLocalizedString
(
"
OK
"
)
;
break
;
case
Ci
.
nsIPrompt
.
BUTTON_TITLE_CANCEL
:
buttonLabel
=
PromptUtils
.
getLocalizedString
(
"
Cancel
"
)
;
break
;
case
Ci
.
nsIPrompt
.
BUTTON_TITLE_YES
:
buttonLabel
=
PromptUtils
.
getLocalizedString
(
"
Yes
"
)
;
break
;
case
Ci
.
nsIPrompt
.
BUTTON_TITLE_NO
:
buttonLabel
=
PromptUtils
.
getLocalizedString
(
"
No
"
)
;
break
;
case
Ci
.
nsIPrompt
.
BUTTON_TITLE_SAVE
:
buttonLabel
=
PromptUtils
.
getLocalizedString
(
"
Save
"
)
;
break
;
case
Ci
.
nsIPrompt
.
BUTTON_TITLE_DONT_SAVE
:
buttonLabel
=
PromptUtils
.
getLocalizedString
(
"
DontSave
"
)
;
break
;
case
Ci
.
nsIPrompt
.
BUTTON_TITLE_REVERT
:
buttonLabel
=
PromptUtils
.
getLocalizedString
(
"
Revert
"
)
;
break
;
case
Ci
.
nsIPrompt
.
BUTTON_TITLE_IS_STRING
:
buttonLabel
=
argText
[
i
]
;
break
;
}
if
(
buttonLabel
)
{
buttonLabels
[
i
]
=
buttonLabel
;
}
flags
>
>
=
8
;
}
return
[
buttonLabels
[
0
]
buttonLabels
[
1
]
buttonLabels
[
2
]
defaultButtonNum
isDelayEnabled
]
;
}
getAuthInfo
(
authInfo
)
{
let
username
password
;
let
flags
=
authInfo
.
flags
;
if
(
flags
&
Ci
.
nsIAuthInformation
.
NEED_DOMAIN
&
&
authInfo
.
domain
)
{
username
=
authInfo
.
domain
+
"
\
\
"
+
authInfo
.
username
;
}
else
{
username
=
authInfo
.
username
;
}
password
=
authInfo
.
password
;
return
[
username
password
]
;
}
setAuthInfo
(
authInfo
username
password
)
{
let
flags
=
authInfo
.
flags
;
if
(
flags
&
Ci
.
nsIAuthInformation
.
NEED_DOMAIN
)
{
let
idx
=
username
.
indexOf
(
"
\
\
"
)
;
if
(
idx
=
=
-
1
)
{
authInfo
.
username
=
username
;
}
else
{
authInfo
.
domain
=
username
.
substring
(
0
idx
)
;
authInfo
.
username
=
username
.
substring
(
idx
+
1
)
;
}
}
else
{
authInfo
.
username
=
username
;
}
authInfo
.
password
=
password
;
}
getFormattedHostname
(
uri
)
{
return
uri
.
scheme
+
"
:
/
/
"
+
uri
.
hostPort
;
}
getAuthTarget
(
aChannel
aAuthInfo
)
{
let
hostname
realm
;
if
(
aAuthInfo
.
flags
&
Ci
.
nsIAuthInformation
.
AUTH_PROXY
)
{
if
(
!
(
aChannel
instanceof
Ci
.
nsIProxiedChannel
)
)
{
throw
new
Error
(
"
proxy
auth
needs
nsIProxiedChannel
"
)
;
}
let
info
=
aChannel
.
proxyInfo
;
if
(
!
info
)
{
throw
new
Error
(
"
proxy
auth
needs
nsIProxyInfo
"
)
;
}
let
idnService
=
Cc
[
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIDNService
)
;
hostname
=
"
moz
-
proxy
:
/
/
"
+
idnService
.
convertUTF8toACE
(
info
.
host
)
+
"
:
"
+
info
.
port
;
realm
=
aAuthInfo
.
realm
;
if
(
!
realm
)
{
realm
=
hostname
;
}
return
[
hostname
realm
]
;
}
hostname
=
this
.
getFormattedHostname
(
aChannel
.
URI
)
;
realm
=
aAuthInfo
.
realm
;
if
(
!
realm
)
{
realm
=
hostname
;
}
return
[
hostname
realm
]
;
}
makeAuthMessage
(
channel
authInfo
)
{
let
isProxy
=
authInfo
.
flags
&
Ci
.
nsIAuthInformation
.
AUTH_PROXY
;
let
isPassOnly
=
authInfo
.
flags
&
Ci
.
nsIAuthInformation
.
ONLY_PASSWORD
;
let
isCrossOrig
=
authInfo
.
flags
&
Ci
.
nsIAuthInformation
.
CROSS_ORIGIN_SUB_RESOURCE
;
let
username
=
authInfo
.
username
;
let
[
displayHost
realm
]
=
this
.
getAuthTarget
(
channel
authInfo
)
;
if
(
!
authInfo
.
realm
&
&
!
isProxy
)
{
realm
=
"
"
;
}
if
(
realm
.
length
>
150
)
{
realm
=
realm
.
substring
(
0
150
)
;
realm
+
=
this
.
ellipsis
;
}
let
text
;
if
(
isProxy
)
{
text
=
PromptUtils
.
getLocalizedString
(
"
EnterLoginForProxy3
"
[
realm
displayHost
]
)
;
}
else
if
(
isPassOnly
)
{
text
=
PromptUtils
.
getLocalizedString
(
"
EnterPasswordFor
"
[
username
displayHost
]
)
;
}
else
if
(
isCrossOrig
)
{
text
=
PromptUtils
.
getLocalizedString
(
"
EnterUserPasswordForCrossOrigin2
"
[
displayHost
]
)
;
}
else
if
(
!
realm
)
{
text
=
PromptUtils
.
getLocalizedString
(
"
EnterUserPasswordFor2
"
[
displayHost
]
)
;
}
else
{
text
=
PromptUtils
.
getLocalizedString
(
"
EnterLoginForRealm3
"
[
realm
displayHost
]
)
;
}
return
text
;
}
getBrandFullName
(
)
{
return
this
.
brandBundle
.
GetStringFromName
(
"
brandFullName
"
)
;
}
}
;
PromptUtils
=
PromptUtilsTemp
;
XPCOMUtils
.
defineLazyGetter
(
PromptUtils
"
strBundle
"
function
(
)
{
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
commonDialogs
.
properties
"
)
;
if
(
!
bundle
)
{
throw
new
Error
(
"
String
bundle
for
Prompter
not
present
!
"
)
;
}
return
bundle
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PromptUtils
"
brandBundle
"
function
(
)
{
let
bundle
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
if
(
!
bundle
)
{
throw
new
Error
(
"
String
bundle
for
branding
not
present
!
"
)
;
}
return
bundle
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
PromptUtils
"
ellipsis
"
function
(
)
{
let
ellipsis
=
"
\
u2026
"
;
try
{
ellipsis
=
Services
.
prefs
.
getComplexValue
(
"
intl
.
ellipsis
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
}
catch
(
e
)
{
}
return
ellipsis
;
}
)
;
class
ModalPrompter
{
constructor
(
{
browsingContext
=
null
domWin
=
null
modalType
=
null
async
=
false
}
)
{
if
(
browsingContext
&
&
domWin
)
{
throw
new
Error
(
"
Pass
either
browsingContext
or
domWin
"
)
;
}
if
(
domWin
)
{
this
.
browsingContext
=
BrowsingContext
.
getFromWindow
(
domWin
)
;
}
else
{
this
.
browsingContext
=
browsingContext
;
}
if
(
domWin
&
&
(
!
modalType
|
|
modalType
=
=
MODAL_TYPE_WINDOW
)
&
&
!
this
.
browsingContext
?
.
isContent
)
{
modalType
=
MODAL_TYPE_INTERNAL_WINDOW
;
}
this
.
modalType
=
modalType
|
|
ModalPrompter
.
defaultModalType
;
this
.
async
=
async
;
this
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
"
nsIPrompt
"
"
nsIAuthPrompt
"
"
nsIAuthPrompt2
"
"
nsIWritablePropertyBag2
"
]
)
;
}
set
modalType
(
modalType
)
{
if
(
modalType
=
=
MODAL_TYPE_WINDOW
)
{
this
.
_modalType
=
modalType
;
return
;
}
if
(
modalType
=
=
MODAL_TYPE_CONTENT
&
&
!
this
.
browsingContext
?
.
isContent
)
{
this
.
_modalType
=
MODAL_TYPE_WINDOW
;
return
;
}
if
(
!
this
.
browsingContext
?
.
isContent
&
&
modalType
!
=
MODAL_TYPE_INTERNAL_WINDOW
)
{
if
(
this
.
browsingContext
?
.
associatedWindow
?
.
gDialogBox
)
{
Cu
.
reportError
(
"
Prompter
:
Browser
not
available
.
Falling
back
to
internal
window
prompt
.
"
)
;
}
modalType
=
MODAL_TYPE_INTERNAL_WINDOW
;
}
if
(
modalType
=
=
MODAL_TYPE_INTERNAL_WINDOW
&
&
(
this
.
browsingContext
?
.
isContent
|
|
!
this
.
browsingContext
?
.
associatedWindow
?
.
gDialogBox
)
)
{
Cu
.
reportError
(
"
Prompter
:
internal
dialogs
not
available
in
this
context
.
Falling
back
to
window
prompt
.
"
)
;
modalType
=
MODAL_TYPE_WINDOW
;
}
this
.
_modalType
=
modalType
;
}
get
modalType
(
)
{
return
this
.
_modalType
;
}
openPromptSync
(
args
)
{
let
closed
=
false
;
this
.
openPrompt
(
args
)
.
then
(
returnedArgs
=
>
{
if
(
returnedArgs
)
{
for
(
let
key
in
returnedArgs
)
{
args
[
key
]
=
returnedArgs
[
key
]
;
}
}
}
)
.
finally
(
(
)
=
>
{
closed
=
true
;
}
)
;
Services
.
tm
.
spinEventLoopUntilOrQuit
(
"
prompts
/
Prompter
.
jsm
:
openPromptSync
"
(
)
=
>
closed
)
;
}
async
openPrompt
(
args
)
{
if
(
!
this
.
browsingContext
)
{
this
.
openWindowPrompt
(
null
args
)
;
return
args
;
}
if
(
this
.
_modalType
=
=
MODAL_TYPE_INTERNAL_WINDOW
)
{
await
this
.
openInternalWindowPrompt
(
this
.
browsingContext
.
associatedWindow
args
)
;
return
args
;
}
if
(
args
.
promptType
=
=
"
select
"
&
&
this
.
modalType
!
=
=
MODAL_TYPE_WINDOW
)
{
Cu
.
reportError
(
"
Prompter
:
'
select
'
prompts
do
not
support
tab
/
content
prompting
.
Falling
back
to
window
prompt
.
"
)
;
args
.
modalType
=
MODAL_TYPE_WINDOW
;
}
else
{
args
.
modalType
=
this
.
modalType
;
}
const
IS_CONTENT
=
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
;
let
actor
;
try
{
if
(
IS_CONTENT
)
{
actor
=
this
.
browsingContext
.
window
.
windowGlobalChild
.
getActor
(
"
Prompt
"
)
;
}
else
{
actor
=
this
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
Prompt
"
)
;
}
}
catch
(
_
)
{
let
parentWin
;
if
(
!
this
.
browsingContext
.
isContent
&
&
this
.
browsingContext
.
window
)
{
parentWin
=
this
.
browsingContext
.
window
;
}
else
{
parentWin
=
this
.
browsingContext
.
top
?
.
embedderElement
?
.
ownerGlobal
;
}
this
.
openWindowPrompt
(
parentWin
args
)
;
return
args
;
}
if
(
IS_CONTENT
)
{
args
.
promptPrincipal
=
this
.
browsingContext
.
window
?
.
document
.
nodePrincipal
;
let
docShell
=
this
.
browsingContext
.
docShell
;
let
inPermitUnload
=
docShell
?
.
contentViewer
?
.
inPermitUnload
;
args
.
inPermitUnload
=
inPermitUnload
;
let
eventDetail
=
Cu
.
cloneInto
(
{
tabPrompt
:
this
.
modalType
!
=
MODAL_TYPE_WINDOW
inPermitUnload
}
this
.
browsingContext
.
window
)
;
PromptUtils
.
fireDialogEvent
(
this
.
browsingContext
.
window
"
DOMWillOpenModalDialog
"
null
eventDetail
)
;
let
windowUtils
=
this
.
browsingContext
.
window
?
.
windowUtils
;
if
(
windowUtils
)
{
windowUtils
.
enterModalState
(
)
;
}
}
let
id
=
"
id
"
+
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
.
generateUUID
(
)
.
toString
(
)
;
args
.
_remoteId
=
id
;
let
returnedArgs
;
try
{
if
(
IS_CONTENT
)
{
returnedArgs
=
await
actor
.
sendQuery
(
"
Prompt
:
Open
"
args
)
;
}
else
{
returnedArgs
=
await
actor
.
receiveMessage
(
{
name
:
"
Prompt
:
Open
"
data
:
args
}
)
;
}
if
(
returnedArgs
?
.
promptAborted
)
{
throw
Components
.
Exception
(
"
prompt
aborted
by
user
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
}
finally
{
if
(
IS_CONTENT
)
{
let
windowUtils
=
this
.
browsingContext
.
window
?
.
windowUtils
;
if
(
windowUtils
)
{
windowUtils
.
leaveModalState
(
)
;
}
PromptUtils
.
fireDialogEvent
(
this
.
browsingContext
.
window
"
DOMModalDialogClosed
"
)
;
}
}
return
returnedArgs
;
}
openWindowPrompt
(
parentWindow
=
null
args
)
{
let
uri
=
args
.
promptType
=
=
"
select
"
?
SELECT_DIALOG
:
COMMON_DIALOG
;
let
propBag
=
PromptUtils
.
objectToPropBag
(
args
)
;
Services
.
ww
.
openWindow
(
parentWindow
|
|
Services
.
ww
.
activeWindow
uri
"
_blank
"
"
centerscreen
chrome
modal
titlebar
"
propBag
)
;
PromptUtils
.
propBagToObject
(
propBag
args
)
;
}
async
openInternalWindowPrompt
(
parentWindow
args
)
{
if
(
!
parentWindow
?
.
gDialogBox
|
|
!
ModalPrompter
.
windowPromptSubDialog
)
{
this
.
openWindowPrompt
(
parentWindow
args
)
;
return
;
}
let
propBag
=
PromptUtils
.
objectToPropBag
(
args
)
;
let
uri
=
args
.
promptType
=
=
"
select
"
?
SELECT_DIALOG
:
COMMON_DIALOG
;
await
parentWindow
.
gDialogBox
.
open
(
uri
propBag
)
;
PromptUtils
.
propBagToObject
(
propBag
args
)
;
}
async
openPromptAsync
(
args
task
)
{
let
result
=
await
this
.
openPrompt
(
args
)
;
if
(
!
task
)
{
return
undefined
;
}
let
taskResult
=
task
(
result
)
;
if
(
!
(
taskResult
instanceof
Object
)
)
{
throw
new
Error
(
"
task
must
return
object
"
)
;
}
return
PromptUtils
.
objectToPropBag
(
taskResult
)
;
}
prompt
(
)
{
if
(
typeof
arguments
[
2
]
=
=
"
object
"
)
{
return
this
.
nsIPrompt_prompt
.
apply
(
this
arguments
)
;
}
return
this
.
nsIAuthPrompt_prompt
.
apply
(
this
arguments
)
;
}
promptUsernameAndPassword
(
)
{
if
(
typeof
arguments
[
2
]
=
=
"
object
"
)
{
return
this
.
nsIPrompt_promptUsernameAndPassword
.
apply
(
this
arguments
)
;
}
return
this
.
nsIAuthPrompt_promptUsernameAndPassword
.
apply
(
this
arguments
)
;
}
promptPassword
(
)
{
if
(
typeof
arguments
[
2
]
=
=
"
object
"
)
{
return
this
.
nsIPrompt_promptPassword
.
apply
(
this
arguments
)
;
}
return
this
.
nsIAuthPrompt_promptPassword
.
apply
(
this
arguments
)
;
}
alert
(
title
text
)
{
if
(
!
title
)
{
title
=
PromptUtils
.
getLocalizedString
(
"
Alert
"
)
;
}
let
args
=
{
promptType
:
"
alert
"
title
text
}
;
if
(
this
.
async
)
{
return
this
.
openPromptAsync
(
args
)
;
}
return
this
.
openPromptSync
(
args
)
;
}
alertCheck
(
title
text
checkLabel
checkValue
)
{
if
(
!
title
)
{
title
=
PromptUtils
.
getLocalizedString
(
"
Alert
"
)
;
}
let
checked
=
this
.
async
?
checkValue
:
checkValue
.
value
;
let
args
=
{
promptType
:
"
alertCheck
"
title
text
checkLabel
checked
}
;
if
(
this
.
async
)
{
return
this
.
openPromptAsync
(
args
result
=
>
(
{
checked
:
result
.
checked
}
)
)
;
}
this
.
openPromptSync
(
args
)
;
checkValue
.
value
=
args
.
checked
;
return
undefined
;
}
confirm
(
title
text
)
{
if
(
!
title
)
{
title
=
PromptUtils
.
getLocalizedString
(
"
Confirm
"
)
;
}
let
args
=
{
promptType
:
"
confirm
"
title
text
ok
:
false
}
;
if
(
this
.
async
)
{
return
this
.
openPromptAsync
(
args
result
=
>
(
{
ok
:
result
.
ok
}
)
)
;
}
this
.
openPromptSync
(
args
)
;
return
args
.
ok
;
}
confirmCheck
(
title
text
checkLabel
checkValue
)
{
if
(
!
title
)
{
title
=
PromptUtils
.
getLocalizedString
(
"
ConfirmCheck
"
)
;
}
let
checked
=
this
.
async
?
checkValue
:
checkValue
.
value
;
let
args
=
{
promptType
:
"
confirmCheck
"
title
text
checkLabel
checked
ok
:
false
}
;
if
(
this
.
async
)
{
return
this
.
openPromptAsync
(
args
result
=
>
(
{
checked
:
result
.
checked
ok
:
result
.
ok
}
)
)
;
}
this
.
openPromptSync
(
args
)
;
checkValue
.
value
=
args
.
checked
;
return
args
.
ok
;
}
confirmEx
(
title
text
flags
button0
button1
button2
checkLabel
checkValue
extraArgs
=
{
}
)
{
if
(
!
title
)
{
title
=
PromptUtils
.
getLocalizedString
(
"
Confirm
"
)
;
}
let
args
=
{
promptType
:
"
confirmEx
"
title
text
checkLabel
checked
:
this
.
async
?
checkValue
:
checkValue
.
value
ok
:
false
buttonNumClicked
:
1
.
.
.
extraArgs
}
;
let
[
label0
label1
label2
defaultButtonNum
isDelayEnabled
]
=
PromptUtils
.
confirmExHelper
(
flags
button0
button1
button2
)
;
args
.
defaultButtonNum
=
defaultButtonNum
;
args
.
enableDelay
=
isDelayEnabled
;
if
(
label0
)
{
args
.
button0Label
=
label0
;
if
(
label1
)
{
args
.
button1Label
=
label1
;
if
(
label2
)
{
args
.
button2Label
=
label2
;
}
}
}
if
(
this
.
async
)
{
return
this
.
openPromptAsync
(
args
result
=
>
(
{
checked
:
!
!
result
.
checked
buttonNumClicked
:
result
.
buttonNumClicked
}
)
)
;
}
this
.
openPromptSync
(
args
)
;
checkValue
.
value
=
args
.
checked
;
return
args
.
buttonNumClicked
;
}
nsIPrompt_prompt
(
title
text
value
checkLabel
checkValue
)
{
if
(
!
title
)
{
title
=
PromptUtils
.
getLocalizedString
(
"
Prompt
"
)
;
}
let
args
=
{
promptType
:
"
prompt
"
title
text
value
:
this
.
async
?
value
:
value
.
value
checkLabel
checked
:
this
.
async
?
checkValue
:
checkValue
.
value
ok
:
false
}
;
if
(
this
.
async
)
{
return
this
.
openPromptAsync
(
args
result
=
>
(
{
checked
:
!
!
result
.
checked
value
:
result
.
value
ok
:
result
.
ok
}
)
)
;
}
this
.
openPromptSync
(
args
)
;
let
ok
=
args
.
ok
;
if
(
ok
)
{
checkValue
.
value
=
args
.
checked
;
value
.
value
=
args
.
value
;
}
return
ok
;
}
nsIPrompt_promptUsernameAndPassword
(
title
text
user
pass
checkLabel
checkValue
)
{
if
(
!
title
)
{
title
=
PromptUtils
.
getLocalizedString
(
"
PromptUsernameAndPassword3
"
[
PromptUtils
.
getBrandFullName
(
)
]
)
;
}
let
args
=
{
promptType
:
"
promptUserAndPass
"
title
text
user
:
this
.
async
?
user
:
user
.
value
pass
:
this
.
async
?
pass
:
pass
.
value
checkLabel
checked
:
this
.
async
?
checkValue
:
checkValue
.
value
ok
:
false
}
;
if
(
this
.
async
)
{
return
this
.
openPromptAsync
(
args
result
=
>
(
{
checked
:
result
.
checked
user
:
result
.
user
pass
:
result
.
pass
ok
:
result
.
ok
}
)
)
;
}
this
.
openPromptSync
(
args
)
;
let
ok
=
args
.
ok
;
if
(
ok
)
{
checkValue
.
value
=
args
.
checked
;
user
.
value
=
args
.
user
;
pass
.
value
=
args
.
pass
;
}
return
ok
;
}
nsIPrompt_promptPassword
(
title
text
pass
checkLabel
checkValue
)
{
if
(
!
title
)
{
title
=
PromptUtils
.
getLocalizedString
(
"
PromptPassword3
"
[
PromptUtils
.
getBrandFullName
(
)
]
)
;
}
let
args
=
{
promptType
:
"
promptPassword
"
title
text
pass
:
this
.
async
?
pass
:
pass
.
value
checkLabel
checked
:
this
.
async
?
checkValue
:
checkValue
.
value
ok
:
false
}
;
if
(
this
.
async
)
{
return
this
.
openPromptAsync
(
args
result
=
>
(
{
checked
:
result
.
checked
pass
:
result
.
pass
ok
:
result
.
ok
}
)
)
;
}
this
.
openPromptSync
(
args
)
;
let
ok
=
args
.
ok
;
if
(
ok
)
{
checkValue
.
value
=
args
.
checked
;
pass
.
value
=
args
.
pass
;
}
return
ok
;
}
select
(
title
text
list
selected
)
{
if
(
!
title
)
{
title
=
PromptUtils
.
getLocalizedString
(
"
Select
"
)
;
}
let
args
=
{
promptType
:
"
select
"
title
text
list
selected
:
-
1
ok
:
false
}
;
if
(
this
.
async
)
{
return
this
.
openPromptAsync
(
args
result
=
>
(
{
selected
:
result
.
selected
ok
:
result
.
ok
}
)
)
;
}
this
.
openPromptSync
(
args
)
;
let
ok
=
args
.
ok
;
if
(
ok
)
{
selected
.
value
=
args
.
selected
;
}
return
ok
;
}
nsIAuthPrompt_prompt
(
title
text
passwordRealm
savePassword
defaultText
result
)
{
if
(
defaultText
)
{
result
.
value
=
defaultText
;
}
return
this
.
nsIPrompt_prompt
(
title
text
result
null
{
}
)
;
}
nsIAuthPrompt_promptUsernameAndPassword
(
title
text
passwordRealm
savePassword
user
pass
)
{
return
this
.
nsIPrompt_promptUsernameAndPassword
(
title
text
user
pass
null
{
}
)
;
}
nsIAuthPrompt_promptPassword
(
title
text
passwordRealm
savePassword
pass
)
{
return
this
.
nsIPrompt_promptPassword
(
title
text
pass
null
{
}
)
;
}
promptAuth
(
channel
level
authInfo
checkLabel
checkValue
)
{
let
message
=
PromptUtils
.
makeAuthMessage
(
channel
authInfo
)
;
let
[
username
password
]
=
PromptUtils
.
getAuthInfo
(
authInfo
)
;
let
userParam
=
this
.
async
?
username
:
{
value
:
username
}
;
let
passParam
=
this
.
async
?
password
:
{
value
:
password
}
;
let
result
;
if
(
authInfo
.
flags
&
Ci
.
nsIAuthInformation
.
ONLY_PASSWORD
)
{
result
=
this
.
nsIPrompt_promptPassword
(
null
message
passParam
checkLabel
checkValue
)
;
}
else
{
result
=
this
.
nsIPrompt_promptUsernameAndPassword
(
null
message
userParam
passParam
checkLabel
checkValue
)
;
}
if
(
this
.
async
)
{
return
result
.
then
(
bag
=
>
{
let
ok
=
bag
.
getProperty
(
"
ok
"
)
;
if
(
ok
)
{
let
username
=
bag
.
getProperty
(
"
user
"
)
;
let
password
=
bag
.
getProperty
(
"
pass
"
)
;
PromptUtils
.
setAuthInfo
(
authInfo
username
password
)
;
}
return
ok
;
}
)
;
}
if
(
result
)
{
PromptUtils
.
setAuthInfo
(
authInfo
userParam
.
value
passParam
.
value
)
;
}
return
result
;
}
asyncPromptAuth
(
channel
callback
context
level
authInfo
checkLabel
checkValue
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
setPropertyAsUint32
(
name
value
)
{
if
(
name
=
=
"
modalType
"
)
{
this
.
modalType
=
value
;
}
else
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_ILLEGAL_VALUE
)
;
}
}
}
XPCOMUtils
.
defineLazyPreferenceGetter
(
ModalPrompter
"
defaultModalType
"
"
prompts
.
defaultModalType
"
MODAL_TYPE_WINDOW
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
ModalPrompter
"
windowPromptSubDialog
"
"
prompts
.
windowPromptSubDialog
"
false
)
;
function
AuthPromptAdapterFactory
(
)
{
}
AuthPromptAdapterFactory
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
6e134924
-
6c3a
-
4d86
-
81ac
-
69432dd971dc
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIAuthPromptAdapterFactory
"
]
)
createAdapter
(
oldPrompter
)
{
return
new
AuthPromptAdapter
(
oldPrompter
)
;
}
}
;
function
AuthPromptAdapter
(
oldPrompter
)
{
this
.
oldPrompter
=
oldPrompter
;
}
AuthPromptAdapter
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIAuthPrompt2
"
]
)
oldPrompter
:
null
promptAuth
(
channel
level
authInfo
checkLabel
checkValue
)
{
let
message
=
PromptUtils
.
makeAuthMessage
(
channel
authInfo
)
;
let
[
username
password
]
=
PromptUtils
.
getAuthInfo
(
authInfo
)
;
let
userParam
=
{
value
:
username
}
;
let
passParam
=
{
value
:
password
}
;
let
[
host
realm
]
=
PromptUtils
.
getAuthTarget
(
channel
authInfo
)
;
let
authTarget
=
host
+
"
(
"
+
realm
+
"
)
"
;
let
ok
;
if
(
authInfo
.
flags
&
Ci
.
nsIAuthInformation
.
ONLY_PASSWORD
)
{
ok
=
this
.
oldPrompter
.
promptPassword
(
null
message
authTarget
Ci
.
nsIAuthPrompt
.
SAVE_PASSWORD_PERMANENTLY
passParam
)
;
}
else
{
ok
=
this
.
oldPrompter
.
promptUsernameAndPassword
(
null
message
authTarget
Ci
.
nsIAuthPrompt
.
SAVE_PASSWORD_PERMANENTLY
userParam
passParam
)
;
}
if
(
ok
)
{
PromptUtils
.
setAuthInfo
(
authInfo
userParam
.
value
passParam
.
value
)
;
}
return
ok
;
}
asyncPromptAuth
(
channel
callback
context
level
authInfo
checkLabel
checkValue
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
}
;
function
EmbedPrompter
(
)
{
}
EmbedPrompter
.
prototype
=
new
Prompter
(
)
;
EmbedPrompter
.
prototype
.
classID
=
Components
.
ID
(
"
{
7ad1b327
-
6dfa
-
46ec
-
9234
-
f2a620ea7e00
}
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
Prompter
"
"
EmbedPrompter
"
"
AuthPromptAdapterFactory
"
]
;
