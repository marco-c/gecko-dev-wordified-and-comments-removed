"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
BrowserTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
)
;
const
{
TestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
const
EXPORTED_SYMBOLS
=
[
"
PromptTestUtils
"
]
;
const
kPrefs
=
{
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
kPrefs
"
tabPromptSubDialogEnabled
"
"
prompts
.
tabChromePromptSubDialog
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
kPrefs
"
contentPromptSubDialogEnabled
"
"
prompts
.
contentPromptSubDialog
"
false
)
;
function
isCommonDialog
(
modalType
)
{
return
(
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_WINDOW
|
|
(
kPrefs
.
tabPromptSubDialogEnabled
&
&
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_TAB
)
|
|
(
kPrefs
.
contentPromptSubDialogEnabled
&
&
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_CONTENT
)
)
;
}
let
PromptTestUtils
=
{
async
handleNextPrompt
(
parent
promptOptions
promptActions
)
{
let
dialog
=
await
this
.
waitForPrompt
(
parent
promptOptions
)
;
return
this
.
handlePrompt
(
dialog
promptActions
)
;
}
handlePrompt
(
dialog
{
checkboxState
=
null
buttonNumClick
=
0
loginInput
=
null
passwordInput
=
null
}
=
{
}
)
{
let
promptClosePromise
;
let
win
;
if
(
isCommonDialog
(
dialog
.
args
.
modalType
)
)
{
win
=
dialog
.
ui
.
prompt
?
.
opener
;
}
else
{
win
=
dialog
.
ui
.
prompt
.
win
;
}
if
(
win
)
{
promptClosePromise
=
BrowserTestUtils
.
waitForEvent
(
win
"
DOMModalDialogClosed
"
)
;
}
else
{
promptClosePromise
=
BrowserTestUtils
.
windowClosed
(
dialog
.
ui
.
prompt
)
;
}
if
(
typeof
checkboxState
=
=
"
boolean
"
)
{
dialog
.
ui
.
checkbox
.
checked
=
checkboxState
;
}
if
(
loginInput
!
=
null
)
{
dialog
.
ui
.
loginTextbox
.
value
=
loginInput
;
}
if
(
passwordInput
!
=
null
)
{
dialog
.
ui
.
password1Textbox
.
value
=
passwordInput
;
}
let
button
=
dialog
.
ui
[
"
button
"
+
buttonNumClick
]
;
if
(
!
button
)
{
throw
new
Error
(
"
Could
not
find
button
with
index
"
+
buttonNumClick
)
;
}
button
.
click
(
)
;
return
promptClosePromise
;
}
async
waitForPrompt
(
parent
{
modalType
promptType
=
null
}
=
{
}
)
{
if
(
!
modalType
)
{
throw
new
Error
(
"
modalType
is
mandatory
"
)
;
}
let
parentWindow
;
let
parentBrowser
;
if
(
parent
)
{
if
(
Element
.
isInstance
(
parent
)
)
{
parentBrowser
=
parent
;
parentWindow
=
parentBrowser
.
ownerGlobal
;
}
else
if
(
parent
instanceof
Ci
.
nsIDOMChromeWindow
)
{
parentWindow
=
parent
;
parentBrowser
=
parentWindow
.
gBrowser
?
.
selectedBrowser
;
}
else
{
throw
new
Error
(
"
Invalid
parent
.
Expected
browser
or
dom
window
"
)
;
}
}
let
topic
=
isCommonDialog
(
modalType
)
?
"
common
-
dialog
-
loaded
"
:
"
tabmodal
-
dialog
-
loaded
"
;
let
dialog
;
await
TestUtils
.
topicObserved
(
topic
subject
=
>
{
let
browser
=
parentBrowser
|
|
subject
.
ownerGlobal
.
gBrowser
?
.
selectedBrowser
;
if
(
isCommonDialog
(
modalType
)
)
{
if
(
parentWindow
&
&
subject
.
opener
!
=
=
parentWindow
)
{
return
false
;
}
if
(
browser
&
&
modalType
=
=
Services
.
prompt
.
MODAL_TYPE_TAB
)
{
let
dialogBox
=
parentWindow
.
gBrowser
.
getTabDialogBox
(
browser
)
;
let
hasMatchingDialog
=
dialogBox
.
getTabDialogManager
(
)
.
_dialogs
.
some
(
d
=
>
d
.
_frame
?
.
browsingContext
=
=
subject
.
browsingContext
)
;
if
(
!
hasMatchingDialog
)
{
return
false
;
}
}
if
(
browser
&
&
modalType
=
=
Services
.
prompt
.
MODAL_TYPE_CONTENT
)
{
let
dialogBox
=
parentWindow
.
gBrowser
.
getTabDialogBox
(
browser
)
;
let
hasMatchingDialog
=
dialogBox
.
getContentDialogManager
(
)
.
_dialogs
.
some
(
d
=
>
d
.
_frame
?
.
browsingContext
=
=
subject
.
browsingContext
)
;
if
(
!
hasMatchingDialog
)
{
return
false
;
}
}
dialog
=
subject
.
Dialog
;
}
else
{
let
prompt
=
browser
.
tabModalPromptBox
.
getPrompt
(
subject
)
;
if
(
!
prompt
)
{
return
false
;
}
dialog
=
prompt
.
Dialog
;
}
if
(
isCommonDialog
(
modalType
)
&
&
dialog
.
args
.
modalType
!
=
=
modalType
)
{
return
false
;
}
if
(
promptType
&
&
dialog
.
args
.
promptType
!
=
=
promptType
)
{
return
false
;
}
return
true
;
}
)
;
return
dialog
;
}
}
;
