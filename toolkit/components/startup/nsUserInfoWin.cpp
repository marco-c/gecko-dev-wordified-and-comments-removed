#
include
"
nsUserInfo
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
nsString
.
h
"
#
include
"
windows
.
h
"
#
include
"
nsCRT
.
h
"
#
define
SECURITY_WIN32
#
include
"
lm
.
h
"
#
include
"
security
.
h
"
nsUserInfo
:
:
nsUserInfo
(
)
{
}
nsUserInfo
:
:
~
nsUserInfo
(
)
{
}
NS_IMPL_ISUPPORTS
(
nsUserInfo
nsIUserInfo
)
NS_IMETHODIMP
nsUserInfo
:
:
GetUsername
(
nsACString
&
aUsername
)
{
wchar_t
username
[
UNLEN
+
1
]
;
DWORD
size
=
mozilla
:
:
ArrayLength
(
username
)
;
if
(
!
GetUserNameW
(
username
&
size
)
)
return
NS_ERROR_FAILURE
;
CopyUTF16toUTF8
(
nsDependentString
(
username
)
aUsername
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsUserInfo
:
:
GetFullname
(
nsAString
&
aFullname
)
{
wchar_t
fullName
[
512
]
;
DWORD
size
=
mozilla
:
:
ArrayLength
(
fullName
)
;
if
(
GetUserNameExW
(
NameDisplay
fullName
&
size
)
)
{
aFullname
.
Assign
(
fullName
)
;
}
else
{
DWORD
getUsernameError
=
GetLastError
(
)
;
wchar_t
username
[
UNLEN
+
1
]
;
size
=
mozilla
:
:
ArrayLength
(
username
)
;
if
(
!
GetUserNameW
(
username
&
size
)
)
{
return
getUsernameError
=
=
ERROR_NONE_MAPPED
?
NS_ERROR_NOT_AVAILABLE
:
NS_ERROR_FAILURE
;
}
const
DWORD
level
=
2
;
LPBYTE
info
;
NET_API_STATUS
status
=
NetUserGetInfo
(
nullptr
username
level
&
info
)
;
if
(
status
!
=
NERR_Success
)
{
return
getUsernameError
=
=
ERROR_NONE_MAPPED
?
NS_ERROR_NOT_AVAILABLE
:
NS_ERROR_FAILURE
;
}
nsDependentString
fullName
=
nsDependentString
(
reinterpret_cast
<
USER_INFO_2
*
>
(
info
)
-
>
usri2_full_name
)
;
if
(
fullName
.
Length
(
)
=
=
0
)
{
NetApiBufferFree
(
info
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
aFullname
.
Assign
(
fullName
)
;
NetApiBufferFree
(
info
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsUserInfo
:
:
GetDomain
(
nsACString
&
aDomain
)
{
const
DWORD
level
=
100
;
LPBYTE
info
;
NET_API_STATUS
status
=
NetWkstaGetInfo
(
nullptr
level
&
info
)
;
if
(
status
!
=
NERR_Success
)
{
return
NS_ERROR_FAILURE
;
}
CopyUTF16toUTF8
(
nsDependentString
(
reinterpret_cast
<
WKSTA_INFO_100
*
>
(
info
)
-
>
wki100_langroup
)
aDomain
)
;
NetApiBufferFree
(
info
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsUserInfo
:
:
GetEmailAddress
(
nsACString
&
aEmailAddress
)
{
wchar_t
emailAddress
[
255
]
;
DWORD
size
=
mozilla
:
:
ArrayLength
(
emailAddress
)
;
if
(
!
GetUserNameExW
(
NameUserPrincipal
emailAddress
&
size
)
)
{
DWORD
getUsernameError
=
GetLastError
(
)
;
return
getUsernameError
=
=
ERROR_NONE_MAPPED
?
NS_ERROR_NOT_AVAILABLE
:
NS_ERROR_FAILURE
;
}
CopyUTF16toUTF8
(
nsDependentString
(
emailAddress
)
aEmailAddress
)
;
return
NS_OK
;
}
