#
ifndef
nsFind_h__
#
define
nsFind_h__
#
include
"
nsIFind
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
mozilla
/
intl
/
Segmenter
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
define
NS_FIND_CONTRACTID
"
mozilla
.
org
/
embedcomp
/
rangefind
;
1
"
#
define
NS_FIND_CID
\
{
0x471f4944
0x1dd2
0x11b2
{
0x87
0xac
0x90
0xbe
0x0a
0x51
0xd6
0x09
}
}
class
nsFind
:
public
nsIFind
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIFIND
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsFind
)
void
SetWordStartBounded
(
bool
aWordStartBounded
)
{
mWordStartBounded
=
aWordStartBounded
;
}
void
SetWordEndBounded
(
bool
aWordEndBounded
)
{
mWordEndBounded
=
aWordEndBounded
;
}
void
SetNodeIndexCache
(
nsContentUtils
:
:
NodeIndexCache
*
aCache
)
{
mNodeIndexCache
=
aCache
;
}
already_AddRefed
<
nsRange
>
FindFromRangeBoundaries
(
const
nsAString
&
aPatText
const
mozilla
:
:
RangeBoundary
&
aStartPoint
const
mozilla
:
:
RangeBoundary
&
aEndPoint
)
;
protected
:
virtual
~
nsFind
(
)
=
default
;
bool
mFindBackward
=
false
;
bool
mCaseSensitive
=
false
;
bool
mMatchDiacritics
=
false
;
bool
mWordStartBounded
=
false
;
bool
mWordEndBounded
=
false
;
mozilla
:
:
intl
:
:
WordBreakIteratorUtf16
mWordBreakIter
{
nullptr
}
;
nsContentUtils
:
:
NodeIndexCache
*
mNodeIndexCache
=
nullptr
;
struct
State
;
class
StateRestorer
;
char32_t
DecodeChar
(
const
char16_t
*
t2b
int32_t
*
index
)
const
;
bool
BreakInBetween
(
char32_t
x
char32_t
y
)
;
char32_t
PeekNextChar
(
State
&
bool
aAlreadyMatching
)
const
;
}
;
#
endif
