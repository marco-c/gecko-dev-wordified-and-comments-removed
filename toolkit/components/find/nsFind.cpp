#
include
"
nsFind
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
TreeIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
define
CHAR_TO_UNICHAR
(
c
)
(
(
char16_t
)
(
unsigned
char
)
c
)
static
NS_DEFINE_CID
(
kCContentIteratorCID
NS_CONTENTITERATOR_CID
)
;
static
NS_DEFINE_CID
(
kCPreContentIteratorCID
NS_PRECONTENTITERATOR_CID
)
;
#
define
CH_QUOTE
(
(
char16_t
)
0x22
)
#
define
CH_APOSTROPHE
(
(
char16_t
)
0x27
)
#
define
CH_LEFT_SINGLE_QUOTE
(
(
char16_t
)
0x2018
)
#
define
CH_RIGHT_SINGLE_QUOTE
(
(
char16_t
)
0x2019
)
#
define
CH_LEFT_DOUBLE_QUOTE
(
(
char16_t
)
0x201C
)
#
define
CH_RIGHT_DOUBLE_QUOTE
(
(
char16_t
)
0x201D
)
#
define
CH_SHY
(
(
char16_t
)
0xAD
)
static_assert
(
CH_SHY
<
=
255
"
CH_SHY
is
not
an
ascii
character
"
)
;
class
nsFindContentIterator
final
:
public
nsIContentIterator
{
public
:
explicit
nsFindContentIterator
(
bool
aFindBackward
)
:
mStartOffset
(
0
)
mEndOffset
(
0
)
mFindBackward
(
aFindBackward
)
{
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsFindContentIterator
)
virtual
nsresult
Init
(
nsINode
*
aRoot
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
internal
error
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
virtual
nsresult
Init
(
nsRange
*
aRange
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
internal
error
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
virtual
nsresult
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
internal
error
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
virtual
nsresult
Init
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
internal
error
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
Init
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
;
virtual
void
First
(
)
override
;
virtual
void
Last
(
)
override
;
virtual
void
Next
(
)
override
;
virtual
void
Prev
(
)
override
;
virtual
nsINode
*
GetCurrentNode
(
)
override
;
virtual
bool
IsDone
(
)
override
;
virtual
nsresult
PositionAt
(
nsINode
*
aCurNode
)
override
;
void
Reset
(
)
;
protected
:
virtual
~
nsFindContentIterator
(
)
{
}
private
:
static
already_AddRefed
<
nsRange
>
CreateRange
(
nsINode
*
aNode
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aNode
)
;
range
-
>
SetMaySpanAnonymousSubtrees
(
true
)
;
return
range
.
forget
(
)
;
}
nsCOMPtr
<
nsIContentIterator
>
mOuterIterator
;
nsCOMPtr
<
nsIContentIterator
>
mInnerIterator
;
nsCOMPtr
<
nsINode
>
mStartNode
;
int32_t
mStartOffset
;
nsCOMPtr
<
nsINode
>
mEndNode
;
int32_t
mEndOffset
;
nsCOMPtr
<
nsIContent
>
mStartOuterContent
;
nsCOMPtr
<
nsIContent
>
mEndOuterContent
;
bool
mFindBackward
;
void
MaybeSetupInnerIterator
(
)
;
void
SetupInnerIterator
(
nsIContent
*
aContent
)
;
}
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsFindContentIterator
)
NS_INTERFACE_MAP_ENTRY
(
nsIContentIterator
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsFindContentIterator
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsFindContentIterator
)
NS_IMPL_CYCLE_COLLECTION
(
nsFindContentIterator
mOuterIterator
mInnerIterator
mStartOuterContent
mEndOuterContent
mEndNode
mStartNode
)
nsresult
nsFindContentIterator
:
:
Init
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
{
NS_ENSURE_ARG_POINTER
(
aStartNode
)
;
NS_ENSURE_ARG_POINTER
(
aEndNode
)
;
if
(
!
mOuterIterator
)
{
if
(
mFindBackward
)
{
mOuterIterator
=
do_CreateInstance
(
kCContentIteratorCID
)
;
}
else
{
mOuterIterator
=
do_CreateInstance
(
kCPreContentIteratorCID
)
;
}
NS_ENSURE_ARG_POINTER
(
mOuterIterator
)
;
}
mStartNode
=
aStartNode
;
mStartOffset
=
aStartOffset
;
mEndNode
=
aEndNode
;
mEndOffset
=
aEndOffset
;
return
NS_OK
;
}
void
nsFindContentIterator
:
:
First
(
)
{
Reset
(
)
;
}
void
nsFindContentIterator
:
:
Last
(
)
{
Reset
(
)
;
}
void
nsFindContentIterator
:
:
Next
(
)
{
if
(
mInnerIterator
)
{
mInnerIterator
-
>
Next
(
)
;
if
(
!
mInnerIterator
-
>
IsDone
(
)
)
{
return
;
}
}
else
{
mOuterIterator
-
>
Next
(
)
;
}
MaybeSetupInnerIterator
(
)
;
}
void
nsFindContentIterator
:
:
Prev
(
)
{
if
(
mInnerIterator
)
{
mInnerIterator
-
>
Prev
(
)
;
if
(
!
mInnerIterator
-
>
IsDone
(
)
)
{
return
;
}
}
else
{
mOuterIterator
-
>
Prev
(
)
;
}
MaybeSetupInnerIterator
(
)
;
}
nsINode
*
nsFindContentIterator
:
:
GetCurrentNode
(
)
{
if
(
mInnerIterator
&
&
!
mInnerIterator
-
>
IsDone
(
)
)
{
return
mInnerIterator
-
>
GetCurrentNode
(
)
;
}
return
mOuterIterator
-
>
GetCurrentNode
(
)
;
}
bool
nsFindContentIterator
:
:
IsDone
(
)
{
if
(
mInnerIterator
&
&
!
mInnerIterator
-
>
IsDone
(
)
)
{
return
false
;
}
return
mOuterIterator
-
>
IsDone
(
)
;
}
static
nsIContent
&
AnonymousSubtreeRootParent
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
aNode
.
IsInNativeAnonymousSubtree
(
)
)
;
nsIContent
*
current
=
aNode
.
GetParent
(
)
;
while
(
current
-
>
IsInNativeAnonymousSubtree
(
)
)
{
current
=
current
-
>
GetParent
(
)
;
MOZ_ASSERT
(
current
"
huh
?
"
)
;
}
return
*
current
;
}
nsresult
nsFindContentIterator
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
nsresult
rv
=
mOuterIterator
-
>
PositionAt
(
aCurNode
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MaybeSetupInnerIterator
(
)
;
return
rv
;
}
nsIContent
&
nonAnonNode
=
AnonymousSubtreeRootParent
(
*
aCurNode
)
;
SetupInnerIterator
(
&
nonAnonNode
)
;
MOZ_ASSERT
(
mInnerIterator
"
How
did
we
have
an
anonymous
node
otherwise
?
"
)
;
rv
=
mInnerIterator
-
>
PositionAt
(
aCurNode
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
mOuterIterator
-
>
IsDone
(
)
)
{
if
(
mFindBackward
)
{
mOuterIterator
-
>
Last
(
)
;
}
else
{
mOuterIterator
-
>
First
(
)
;
}
}
return
rv
;
}
void
nsFindContentIterator
:
:
Reset
(
)
{
mInnerIterator
=
nullptr
;
mStartOuterContent
=
nullptr
;
mEndOuterContent
=
nullptr
;
nsCOMPtr
<
nsIContent
>
startContent
(
do_QueryInterface
(
mStartNode
)
)
;
if
(
startContent
)
{
mStartOuterContent
=
startContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
}
nsCOMPtr
<
nsIContent
>
endContent
(
do_QueryInterface
(
mEndNode
)
)
;
if
(
endContent
)
{
mEndOuterContent
=
endContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
}
nsCOMPtr
<
nsINode
>
node
=
mStartNode
;
NS_ENSURE_TRUE_VOID
(
node
)
;
RefPtr
<
nsRange
>
range
=
CreateRange
(
node
)
;
range
-
>
SetStart
(
*
mStartNode
mStartOffset
IgnoreErrors
(
)
)
;
range
-
>
SetEnd
(
*
mEndNode
mEndOffset
IgnoreErrors
(
)
)
;
mOuterIterator
-
>
Init
(
range
)
;
if
(
!
mFindBackward
)
{
if
(
mStartOuterContent
!
=
startContent
)
{
SetupInnerIterator
(
mStartOuterContent
)
;
if
(
mInnerIterator
)
{
mInnerIterator
-
>
First
(
)
;
}
}
if
(
!
mOuterIterator
-
>
IsDone
(
)
)
{
mOuterIterator
-
>
First
(
)
;
}
}
else
{
if
(
mEndOuterContent
!
=
endContent
)
{
SetupInnerIterator
(
mEndOuterContent
)
;
if
(
mInnerIterator
)
{
mInnerIterator
-
>
Last
(
)
;
}
}
if
(
!
mOuterIterator
-
>
IsDone
(
)
)
{
mOuterIterator
-
>
Last
(
)
;
}
}
if
(
!
mInnerIterator
)
{
MaybeSetupInnerIterator
(
)
;
}
}
void
nsFindContentIterator
:
:
MaybeSetupInnerIterator
(
)
{
mInnerIterator
=
nullptr
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mOuterIterator
-
>
GetCurrentNode
(
)
)
;
if
(
!
content
|
|
!
content
-
>
IsNodeOfType
(
nsINode
:
:
eHTML_FORM_CONTROL
)
)
{
return
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
(
do_QueryInterface
(
content
)
)
;
if
(
!
formControl
-
>
IsTextControl
(
true
)
)
{
return
;
}
SetupInnerIterator
(
content
)
;
if
(
mInnerIterator
)
{
if
(
!
mFindBackward
)
{
mInnerIterator
-
>
First
(
)
;
if
(
!
mOuterIterator
-
>
IsDone
(
)
)
{
mOuterIterator
-
>
First
(
)
;
}
}
else
{
mInnerIterator
-
>
Last
(
)
;
if
(
!
mOuterIterator
-
>
IsDone
(
)
)
{
mOuterIterator
-
>
Last
(
)
;
}
}
}
}
void
nsFindContentIterator
:
:
SetupInnerIterator
(
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
return
;
}
NS_ASSERTION
(
!
aContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
"
invalid
call
"
)
;
nsITextControlFrame
*
tcFrame
=
do_QueryFrame
(
aContent
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
tcFrame
)
{
return
;
}
RefPtr
<
TextEditor
>
textEditor
=
tcFrame
-
>
GetTextEditor
(
)
;
if
(
!
textEditor
|
|
textEditor
-
>
IsDisabled
(
)
)
{
return
;
}
RefPtr
<
dom
:
:
Element
>
rootElement
=
textEditor
-
>
GetRoot
(
)
;
if
(
!
rootElement
)
{
return
;
}
RefPtr
<
nsRange
>
innerRange
=
CreateRange
(
aContent
)
;
RefPtr
<
nsRange
>
outerRange
=
CreateRange
(
aContent
)
;
if
(
!
innerRange
|
|
!
outerRange
)
{
return
;
}
mInnerIterator
=
do_CreateInstance
(
kCPreContentIteratorCID
)
;
if
(
mInnerIterator
)
{
innerRange
-
>
SelectNodeContents
(
*
rootElement
IgnoreErrors
(
)
)
;
if
(
aContent
=
=
mStartOuterContent
)
{
innerRange
-
>
SetStart
(
*
mStartNode
mStartOffset
IgnoreErrors
(
)
)
;
}
if
(
aContent
=
=
mEndOuterContent
)
{
innerRange
-
>
SetEnd
(
*
mEndNode
mEndOffset
IgnoreErrors
(
)
)
;
}
mInnerIterator
-
>
Init
(
innerRange
)
;
IgnoredErrorResult
res1
res2
;
if
(
!
mFindBackward
)
{
outerRange
-
>
SetEnd
(
*
mEndNode
mEndOffset
res1
)
;
outerRange
-
>
SetStartAfter
(
*
aContent
res2
)
;
}
else
{
outerRange
-
>
SetStart
(
*
mStartNode
mStartOffset
res1
)
;
outerRange
-
>
SetEndBefore
(
*
aContent
res2
)
;
}
if
(
res1
.
Failed
(
)
|
|
res2
.
Failed
(
)
)
{
outerRange
-
>
Collapse
(
true
)
;
}
mOuterIterator
-
>
Init
(
outerRange
)
;
}
}
nsresult
NS_NewFindContentIterator
(
bool
aFindBackward
nsIContentIterator
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
if
(
!
aResult
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsFindContentIterator
*
it
=
new
nsFindContentIterator
(
aFindBackward
)
;
if
(
!
it
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
it
-
>
QueryInterface
(
NS_GET_IID
(
nsIContentIterator
)
(
void
*
*
)
aResult
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsFind
)
NS_INTERFACE_MAP_ENTRY
(
nsIFind
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsFind
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsFind
)
NS_IMPL_CYCLE_COLLECTION
(
nsFind
)
nsFind
:
:
nsFind
(
)
:
mFindBackward
(
false
)
mCaseSensitive
(
false
)
mWordBreaker
(
nullptr
)
{
}
nsFind
:
:
~
nsFind
(
)
=
default
;
#
ifdef
DEBUG_FIND
#
define
DEBUG_FIND_PRINTF
(
.
.
.
)
printf
(
__VA_ARGS__
)
#
else
#
define
DEBUG_FIND_PRINTF
(
.
.
.
)
#
endif
static
void
DumpNode
(
const
nsINode
*
aNode
)
{
#
ifdef
DEBUG_FIND
if
(
!
aNode
)
{
printf
(
"
>
>
>
>
Node
:
NULL
\
n
"
)
;
return
;
}
nsString
nodeName
=
aNode
-
>
NodeName
(
)
;
if
(
aNode
-
>
IsText
(
)
)
{
nsAutoString
newText
;
aNode
-
>
AsText
(
)
-
>
AppendTextTo
(
newText
)
;
printf
(
"
>
>
>
>
Text
node
(
node
name
%
s
)
:
'
%
s
'
\
n
"
NS_LossyConvertUTF16toASCII
(
nodeName
)
.
get
(
)
NS_LossyConvertUTF16toASCII
(
newText
)
.
get
(
)
)
;
}
else
{
printf
(
"
>
>
>
>
Node
:
%
s
\
n
"
NS_LossyConvertUTF16toASCII
(
nodeName
)
.
get
(
)
)
;
}
#
endif
}
static
bool
IsBlockNode
(
const
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsElement
(
)
&
&
aContent
-
>
AsElement
(
)
-
>
IsDisplayContents
(
)
)
{
return
false
;
}
if
(
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
img
nsGkAtoms
:
:
hr
nsGkAtoms
:
:
th
nsGkAtoms
:
:
td
)
)
{
return
true
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
return
frame
&
&
frame
-
>
StyleDisplay
(
)
-
>
IsBlockOutsideStyle
(
)
;
}
static
bool
IsDisplayedNode
(
const
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
IsContent
(
)
)
{
return
false
;
}
if
(
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
)
{
return
true
;
}
return
aNode
-
>
IsElement
(
)
&
&
aNode
-
>
AsElement
(
)
-
>
IsDisplayContents
(
)
;
}
static
bool
IsVisibleNode
(
const
nsINode
*
aNode
)
{
if
(
!
IsDisplayedNode
(
aNode
)
)
{
return
false
;
}
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
true
;
}
return
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
static
bool
IsTextFormControl
(
nsIContent
&
aContent
)
{
if
(
!
aContent
.
IsNodeOfType
(
nsINode
:
:
eHTML_FORM_CONTROL
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
&
aContent
)
;
return
formControl
-
>
IsTextControl
(
true
)
;
}
static
bool
SkipNode
(
const
nsIContent
*
aContent
)
{
const
nsIContent
*
content
=
aContent
;
while
(
content
)
{
if
(
!
IsDisplayedNode
(
content
)
|
|
content
-
>
IsComment
(
)
|
|
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
noframes
nsGkAtoms
:
:
select
)
)
{
DEBUG_FIND_PRINTF
(
"
Skipping
node
:
"
)
;
DumpNode
(
content
)
;
return
true
;
}
if
(
content
-
>
IsInNativeAnonymousSubtree
(
)
&
&
!
IsTextFormControl
(
AnonymousSubtreeRootParent
(
*
content
)
)
)
{
return
true
;
}
if
(
IsBlockNode
(
content
)
)
{
return
false
;
}
content
=
content
-
>
GetParent
(
)
;
}
return
false
;
}
static
const
nsIContent
*
GetBlockParent
(
const
Text
*
aNode
)
{
for
(
const
nsIContent
*
current
=
aNode
-
>
GetParent
(
)
;
current
;
current
=
current
-
>
GetParent
(
)
)
{
if
(
IsBlockNode
(
current
)
)
{
return
current
;
}
}
return
nullptr
;
}
struct
nsFind
:
:
State
final
{
State
(
bool
aFindBackward
nsIContent
&
aRoot
const
nsRange
&
aStartPoint
)
:
mFindBackward
(
aFindBackward
)
mInitialized
(
false
)
mIterOffset
(
-
1
)
mLastBlockParent
(
nullptr
)
mIterator
(
aRoot
)
mStartPoint
(
aStartPoint
)
{
}
void
PositionAt
(
Text
&
aNode
)
{
mIterator
.
Seek
(
aNode
)
;
}
Text
*
GetCurrentNode
(
)
const
{
MOZ_ASSERT
(
mInitialized
)
;
nsINode
*
node
=
mIterator
.
GetCurrent
(
)
;
MOZ_ASSERT
(
!
node
|
|
node
-
>
IsText
(
)
)
;
return
node
?
node
-
>
GetAsText
(
)
:
nullptr
;
}
Text
*
GetNextNode
(
)
{
if
(
MOZ_UNLIKELY
(
!
mInitialized
)
)
{
Initialize
(
)
;
}
else
{
Advance
(
)
;
mIterOffset
=
-
1
;
}
return
GetCurrentNode
(
)
;
}
const
nsTextFragment
*
GetNextNonEmptyTextFragmentInSameBlock
(
)
;
private
:
void
Advance
(
)
;
void
Initialize
(
)
;
const
bool
mFindBackward
;
bool
mInitialized
;
public
:
int
mIterOffset
;
const
nsIContent
*
mLastBlockParent
;
TreeIterator
<
StyleChildrenIterator
>
mIterator
;
const
nsRange
&
mStartPoint
;
}
;
void
nsFind
:
:
State
:
:
Advance
(
)
{
MOZ_ASSERT
(
mInitialized
)
;
while
(
true
)
{
nsIContent
*
current
=
mFindBackward
?
mIterator
.
GetPrev
(
)
:
mIterator
.
GetNext
(
)
;
if
(
!
current
)
{
return
;
}
if
(
!
current
-
>
IsContent
(
)
|
|
SkipNode
(
current
-
>
AsContent
(
)
)
)
{
continue
;
}
if
(
current
-
>
IsText
(
)
)
{
return
;
}
}
}
void
nsFind
:
:
State
:
:
Initialize
(
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
mInitialized
=
true
;
mIterOffset
=
mFindBackward
?
-
1
:
0
;
nsINode
*
beginning
=
mFindBackward
?
mStartPoint
.
GetEndContainer
(
)
:
mStartPoint
.
GetStartContainer
(
)
;
if
(
beginning
&
&
beginning
-
>
IsContent
(
)
)
{
mIterator
.
Seek
(
*
beginning
-
>
AsContent
(
)
)
;
}
nsINode
*
current
=
mIterator
.
GetCurrent
(
)
;
if
(
!
current
)
{
return
;
}
if
(
!
current
-
>
IsText
(
)
|
|
SkipNode
(
current
-
>
AsText
(
)
)
)
{
Advance
(
)
;
return
;
}
mLastBlockParent
=
GetBlockParent
(
current
-
>
AsText
(
)
)
;
if
(
current
!
=
beginning
)
{
return
;
}
mIterOffset
=
mFindBackward
?
mStartPoint
.
EndOffset
(
)
:
mStartPoint
.
StartOffset
(
)
;
}
const
nsTextFragment
*
nsFind
:
:
State
:
:
GetNextNonEmptyTextFragmentInSameBlock
(
)
{
while
(
true
)
{
const
Text
*
current
=
GetNextNode
(
)
;
if
(
!
current
)
{
return
nullptr
;
}
const
nsIContent
*
blockParent
=
GetBlockParent
(
current
)
;
if
(
!
blockParent
|
|
blockParent
!
=
mLastBlockParent
)
{
return
nullptr
;
}
const
nsTextFragment
&
frag
=
current
-
>
TextFragment
(
)
;
if
(
frag
.
GetLength
(
)
)
{
return
&
frag
;
}
}
}
class
MOZ_STACK_CLASS
nsFind
:
:
StateRestorer
final
{
public
:
explicit
StateRestorer
(
State
&
aState
)
:
mState
(
aState
)
mIterOffset
(
aState
.
mIterOffset
)
mCurrNode
(
aState
.
GetCurrentNode
(
)
)
mLastBlockParent
(
aState
.
mLastBlockParent
)
{
}
~
StateRestorer
(
)
{
mState
.
mIterOffset
=
mIterOffset
;
if
(
mCurrNode
)
{
mState
.
PositionAt
(
*
mCurrNode
)
;
}
mState
.
mLastBlockParent
=
mLastBlockParent
;
}
private
:
State
&
mState
;
int32_t
mIterOffset
;
Text
*
mCurrNode
;
const
nsIContent
*
mLastBlockParent
;
}
;
NS_IMETHODIMP
nsFind
:
:
GetFindBackwards
(
bool
*
aFindBackward
)
{
if
(
!
aFindBackward
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aFindBackward
=
mFindBackward
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
SetFindBackwards
(
bool
aFindBackward
)
{
mFindBackward
=
aFindBackward
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
GetCaseSensitive
(
bool
*
aCaseSensitive
)
{
if
(
!
aCaseSensitive
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCaseSensitive
=
mCaseSensitive
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
SetCaseSensitive
(
bool
aCaseSensitive
)
{
mCaseSensitive
=
aCaseSensitive
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
GetEntireWord
(
bool
*
aEntireWord
)
{
if
(
!
aEntireWord
)
return
NS_ERROR_NULL_POINTER
;
*
aEntireWord
=
!
!
mWordBreaker
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
SetEntireWord
(
bool
aEntireWord
)
{
mWordBreaker
=
aEntireWord
?
nsContentUtils
:
:
WordBreaker
(
)
:
nullptr
;
return
NS_OK
;
}
char16_t
nsFind
:
:
PeekNextChar
(
State
&
aState
)
const
{
StateRestorer
restorer
(
aState
)
;
const
nsTextFragment
*
frag
=
aState
.
GetNextNonEmptyTextFragmentInSameBlock
(
)
;
if
(
!
frag
)
{
return
L
'
\
0
'
;
}
const
char16_t
*
t2b
=
nullptr
;
const
char
*
t1b
=
nullptr
;
if
(
frag
-
>
Is2b
(
)
)
{
t2b
=
frag
-
>
Get2b
(
)
;
}
else
{
t1b
=
frag
-
>
Get1b
(
)
;
}
uint32_t
len
=
frag
-
>
GetLength
(
)
;
MOZ_ASSERT
(
len
)
;
int32_t
index
=
mFindBackward
?
len
-
1
:
0
;
return
t1b
?
CHAR_TO_UNICHAR
(
t1b
[
index
]
)
:
t2b
[
index
]
;
}
#
define
NBSP_CHARCODE
(
CHAR_TO_UNICHAR
(
160
)
)
#
define
IsSpace
(
c
)
(
nsCRT
:
:
IsAsciiSpace
(
c
)
|
|
(
c
)
=
=
NBSP_CHARCODE
)
#
define
OVERFLOW_PINDEX
(
mFindBackward
?
pindex
<
0
:
pindex
>
patLen
)
#
define
DONE_WITH_PINDEX
(
mFindBackward
?
pindex
<
=
0
:
pindex
>
=
patLen
)
#
define
ALMOST_DONE_WITH_PINDEX
(
mFindBackward
?
pindex
<
=
0
:
pindex
>
=
patLen
-
1
)
NS_IMETHODIMP
nsFind
:
:
Find
(
const
char16_t
*
aPatText
nsRange
*
aSearchRange
nsRange
*
aStartPoint
nsRange
*
aEndPoint
nsRange
*
*
aRangeRet
)
{
DEBUG_FIND_PRINTF
(
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
nsFind
:
:
Find
(
'
%
s
'
%
s
%
p
%
p
%
p
)
\
n
"
NS_LossyConvertUTF16toASCII
(
aPatText
)
.
get
(
)
mFindBackward
?
"
(
backward
)
"
:
"
(
forward
)
"
(
void
*
)
aSearchRange
(
void
*
)
aStartPoint
(
void
*
)
aEndPoint
)
;
NS_ENSURE_ARG
(
aSearchRange
)
;
NS_ENSURE_ARG
(
aStartPoint
)
;
NS_ENSURE_ARG
(
aEndPoint
)
;
NS_ENSURE_ARG_POINTER
(
aRangeRet
)
;
nsIDocument
*
document
=
aStartPoint
-
>
GetRoot
(
)
?
aStartPoint
-
>
GetRoot
(
)
-
>
OwnerDoc
(
)
:
nullptr
;
NS_ENSURE_ARG
(
document
)
;
Element
*
root
=
document
-
>
GetRootElement
(
)
;
NS_ENSURE_ARG
(
root
)
;
*
aRangeRet
=
0
;
if
(
!
aPatText
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsAutoString
patAutoStr
(
aPatText
)
;
if
(
!
mCaseSensitive
)
{
ToLowerCase
(
patAutoStr
)
;
}
static
const
char
kShy
[
]
=
{
char
(
CH_SHY
)
0
}
;
patAutoStr
.
StripChars
(
kShy
)
;
const
char16_t
*
patStr
=
patAutoStr
.
get
(
)
;
int32_t
patLen
=
patAutoStr
.
Length
(
)
-
1
;
int32_t
pindex
=
(
mFindBackward
?
patLen
:
0
)
;
int32_t
findex
=
0
;
int
incr
=
(
mFindBackward
?
-
1
:
1
)
;
const
nsTextFragment
*
frag
=
nullptr
;
int32_t
fragLen
=
0
;
const
char16_t
*
t2b
=
nullptr
;
const
char
*
t1b
=
nullptr
;
bool
inWhitespace
=
false
;
bool
wordBreakPrev
=
false
;
Text
*
matchAnchorNode
=
nullptr
;
int32_t
matchAnchorOffset
=
0
;
nsINode
*
endNode
=
aEndPoint
-
>
GetEndContainer
(
)
;
uint32_t
endOffset
=
aEndPoint
-
>
EndOffset
(
)
;
char16_t
c
=
0
;
char16_t
patc
=
0
;
char16_t
prevChar
=
0
;
char16_t
prevCharInMatch
=
0
;
State
state
(
mFindBackward
*
root
*
aStartPoint
)
;
Text
*
current
=
nullptr
;
while
(
true
)
{
DEBUG_FIND_PRINTF
(
"
Loop
.
.
.
\
n
"
)
;
if
(
!
frag
)
{
current
=
state
.
GetNextNode
(
)
;
if
(
!
current
)
{
return
NS_OK
;
}
const
nsIContent
*
blockParent
=
GetBlockParent
(
current
)
;
DEBUG_FIND_PRINTF
(
"
New
node
:
old
blockparent
=
%
p
new
=
%
p
\
n
"
(
void
*
)
state
.
mLastBlockParent
(
void
*
)
blockParent
)
;
if
(
blockParent
!
=
state
.
mLastBlockParent
)
{
DEBUG_FIND_PRINTF
(
"
Different
block
parent
!
\
n
"
)
;
state
.
mLastBlockParent
=
blockParent
;
matchAnchorNode
=
nullptr
;
matchAnchorOffset
=
0
;
c
=
0
;
prevChar
=
0
;
prevCharInMatch
=
0
;
pindex
=
(
mFindBackward
?
patLen
:
0
)
;
inWhitespace
=
false
;
}
frag
=
&
current
-
>
TextFragment
(
)
;
fragLen
=
frag
-
>
GetLength
(
)
;
if
(
current
=
=
matchAnchorNode
)
{
findex
=
matchAnchorOffset
+
(
mFindBackward
?
1
:
0
)
;
}
else
if
(
state
.
mIterOffset
>
=
0
)
{
findex
=
state
.
mIterOffset
-
(
mFindBackward
?
1
:
0
)
;
}
else
{
findex
=
mFindBackward
?
(
fragLen
-
1
)
:
0
;
}
state
.
mIterOffset
=
-
1
;
DEBUG_FIND_PRINTF
(
"
Starting
from
offset
%
d
of
%
d
\
n
"
findex
fragLen
)
;
if
(
findex
<
0
|
|
findex
>
fragLen
-
1
)
{
DEBUG_FIND_PRINTF
(
"
At
the
end
of
a
text
node
-
-
skipping
to
the
next
\
n
"
)
;
frag
=
nullptr
;
continue
;
}
if
(
frag
-
>
Is2b
(
)
)
{
t2b
=
frag
-
>
Get2b
(
)
;
t1b
=
nullptr
;
#
ifdef
DEBUG_FIND
nsAutoString
str2
(
t2b
fragLen
)
;
DEBUG_FIND_PRINTF
(
"
2
byte
'
%
s
'
\
n
"
NS_LossyConvertUTF16toASCII
(
str2
)
.
get
(
)
)
;
#
endif
}
else
{
t1b
=
frag
-
>
Get1b
(
)
;
t2b
=
nullptr
;
#
ifdef
DEBUG_FIND
nsAutoCString
str1
(
t1b
fragLen
)
;
DEBUG_FIND_PRINTF
(
"
1
byte
'
%
s
'
\
n
"
str1
.
get
(
)
)
;
#
endif
}
}
else
{
findex
+
=
incr
;
DEBUG_FIND_PRINTF
(
"
Same
node
-
-
(
%
d
%
d
)
\
n
"
pindex
findex
)
;
if
(
mFindBackward
?
(
findex
<
0
)
:
(
findex
>
=
fragLen
)
)
{
DEBUG_FIND_PRINTF
(
"
Will
need
to
pull
a
new
node
:
mAO
=
%
d
frag
len
=
%
d
\
n
"
matchAnchorOffset
fragLen
)
;
frag
=
nullptr
;
continue
;
}
}
if
(
state
.
GetCurrentNode
(
)
=
=
endNode
&
&
(
(
mFindBackward
&
&
findex
<
static_cast
<
int32_t
>
(
endOffset
)
)
|
|
(
!
mFindBackward
&
&
findex
>
static_cast
<
int32_t
>
(
endOffset
)
)
)
)
{
return
NS_OK
;
}
prevChar
=
c
;
c
=
(
t2b
?
t2b
[
findex
]
:
CHAR_TO_UNICHAR
(
t1b
[
findex
]
)
)
;
patc
=
patStr
[
pindex
]
;
DEBUG_FIND_PRINTF
(
"
Comparing
'
%
c
'
=
%
x
to
'
%
c
'
(
%
d
of
%
d
)
findex
=
%
d
%
s
\
n
"
(
char
)
c
(
int
)
c
patc
pindex
patLen
findex
inWhitespace
?
"
(
inWhitespace
)
"
:
"
"
)
;
if
(
inWhitespace
&
&
!
IsSpace
(
c
)
)
{
inWhitespace
=
false
;
pindex
+
=
incr
;
#
ifdef
DEBUG
if
(
OVERFLOW_PINDEX
)
{
NS_ASSERTION
(
false
"
Missed
a
whitespace
match
"
)
;
}
#
endif
patc
=
patStr
[
pindex
]
;
}
if
(
!
inWhitespace
&
&
IsSpace
(
patc
)
)
{
inWhitespace
=
true
;
}
else
if
(
!
inWhitespace
&
&
!
mCaseSensitive
&
&
IsUpperCase
(
c
)
)
{
c
=
ToLowerCase
(
c
)
;
}
if
(
c
=
=
CH_SHY
)
{
continue
;
}
if
(
!
mCaseSensitive
)
{
switch
(
c
)
{
case
CH_LEFT_SINGLE_QUOTE
:
case
CH_RIGHT_SINGLE_QUOTE
:
c
=
CH_APOSTROPHE
;
break
;
case
CH_LEFT_DOUBLE_QUOTE
:
case
CH_RIGHT_DOUBLE_QUOTE
:
c
=
CH_QUOTE
;
break
;
}
switch
(
patc
)
{
case
CH_LEFT_SINGLE_QUOTE
:
case
CH_RIGHT_SINGLE_QUOTE
:
patc
=
CH_APOSTROPHE
;
break
;
case
CH_LEFT_DOUBLE_QUOTE
:
case
CH_RIGHT_DOUBLE_QUOTE
:
patc
=
CH_QUOTE
;
break
;
}
}
if
(
pindex
!
=
(
mFindBackward
?
patLen
:
0
)
&
&
c
!
=
patc
&
&
!
inWhitespace
)
{
if
(
c
=
=
'
\
n
'
&
&
t2b
&
&
IS_CJ_CHAR
(
prevCharInMatch
)
)
{
int32_t
nindex
=
findex
+
incr
;
if
(
mFindBackward
?
(
nindex
>
=
0
)
:
(
nindex
<
fragLen
)
)
{
if
(
IS_CJ_CHAR
(
t2b
[
nindex
]
)
)
{
continue
;
}
}
}
}
wordBreakPrev
=
false
;
if
(
mWordBreaker
)
{
if
(
prevChar
=
=
NBSP_CHARCODE
)
prevChar
=
CHAR_TO_UNICHAR
(
'
'
)
;
wordBreakPrev
=
mWordBreaker
-
>
BreakInBetween
(
&
prevChar
1
&
c
1
)
;
}
if
(
(
c
=
=
patc
&
&
(
!
mWordBreaker
|
|
matchAnchorNode
|
|
wordBreakPrev
)
)
|
|
(
inWhitespace
&
&
IsSpace
(
c
)
)
)
{
prevCharInMatch
=
c
;
if
(
inWhitespace
)
{
DEBUG_FIND_PRINTF
(
"
YES
(
whitespace
)
(
%
d
of
%
d
)
\
n
"
pindex
patLen
)
;
}
else
{
DEBUG_FIND_PRINTF
(
"
YES
!
'
%
c
'
=
=
'
%
c
'
(
%
d
of
%
d
)
\
n
"
c
patc
pindex
patLen
)
;
}
if
(
!
matchAnchorNode
)
{
matchAnchorNode
=
state
.
GetCurrentNode
(
)
;
matchAnchorOffset
=
findex
;
}
if
(
DONE_WITH_PINDEX
)
{
DEBUG_FIND_PRINTF
(
"
Found
a
match
!
\
n
"
)
;
if
(
mWordBreaker
)
{
int32_t
nextfindex
=
findex
+
incr
;
char16_t
nextChar
;
if
(
mFindBackward
?
(
nextfindex
>
=
0
)
:
(
nextfindex
<
fragLen
)
)
nextChar
=
(
t2b
?
t2b
[
nextfindex
]
:
CHAR_TO_UNICHAR
(
t1b
[
nextfindex
]
)
)
;
else
nextChar
=
PeekNextChar
(
state
)
;
if
(
nextChar
=
=
NBSP_CHARCODE
)
nextChar
=
CHAR_TO_UNICHAR
(
'
'
)
;
if
(
!
mWordBreaker
-
>
BreakInBetween
(
&
c
1
&
nextChar
1
)
)
{
matchAnchorNode
=
nullptr
;
continue
;
}
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
current
)
;
int32_t
matchStartOffset
;
int32_t
matchEndOffset
;
int32_t
mao
=
matchAnchorOffset
+
(
mFindBackward
?
1
:
0
)
;
Text
*
startParent
;
Text
*
endParent
;
if
(
mFindBackward
)
{
startParent
=
current
;
endParent
=
matchAnchorNode
;
matchStartOffset
=
findex
;
matchEndOffset
=
mao
;
}
else
{
startParent
=
matchAnchorNode
;
endParent
=
current
;
matchStartOffset
=
mao
;
matchEndOffset
=
findex
+
1
;
}
if
(
startParent
&
&
endParent
&
&
IsVisibleNode
(
startParent
)
&
&
IsVisibleNode
(
endParent
)
)
{
range
-
>
SetStart
(
*
startParent
matchStartOffset
IgnoreErrors
(
)
)
;
range
-
>
SetEnd
(
*
endParent
matchEndOffset
IgnoreErrors
(
)
)
;
*
aRangeRet
=
range
.
get
(
)
;
NS_ADDREF
(
*
aRangeRet
)
;
}
else
{
startParent
=
nullptr
;
}
if
(
startParent
)
{
return
NS_OK
;
}
matchAnchorNode
=
nullptr
;
}
if
(
matchAnchorNode
)
{
if
(
!
inWhitespace
|
|
DONE_WITH_PINDEX
|
|
IsSpace
(
patStr
[
pindex
+
incr
]
)
)
{
pindex
+
=
incr
;
inWhitespace
=
false
;
DEBUG_FIND_PRINTF
(
"
Advancing
pindex
to
%
d
\
n
"
pindex
)
;
}
continue
;
}
}
DEBUG_FIND_PRINTF
(
"
NOT
:
%
c
=
=
%
c
\
n
"
c
patc
)
;
if
(
matchAnchorNode
)
{
findex
=
matchAnchorOffset
;
state
.
mIterOffset
=
matchAnchorOffset
;
if
(
matchAnchorNode
!
=
state
.
GetCurrentNode
(
)
)
{
frag
=
nullptr
;
state
.
PositionAt
(
*
matchAnchorNode
)
;
DEBUG_FIND_PRINTF
(
"
Repositioned
anchor
node
\
n
"
)
;
}
DEBUG_FIND_PRINTF
(
"
Ending
a
partial
match
;
findex
-
>
%
d
mIterOffset
-
>
%
d
\
n
"
findex
state
.
mIterOffset
)
;
}
matchAnchorNode
=
nullptr
;
matchAnchorOffset
=
0
;
inWhitespace
=
false
;
pindex
=
mFindBackward
?
patLen
:
0
;
DEBUG_FIND_PRINTF
(
"
Setting
findex
back
to
%
d
pindex
to
%
d
\
n
"
findex
pindex
)
;
}
return
NS_OK
;
}
