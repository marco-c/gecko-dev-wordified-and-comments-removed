#
include
"
nsFind
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
using
namespace
mozilla
;
#
define
CHAR_TO_UNICHAR
(
c
)
(
(
char16_t
)
(
unsigned
char
)
c
)
static
NS_DEFINE_CID
(
kCContentIteratorCID
NS_CONTENTITERATOR_CID
)
;
static
NS_DEFINE_CID
(
kCPreContentIteratorCID
NS_PRECONTENTITERATOR_CID
)
;
#
define
CH_QUOTE
(
(
char16_t
)
0x22
)
#
define
CH_APOSTROPHE
(
(
char16_t
)
0x27
)
#
define
CH_LEFT_SINGLE_QUOTE
(
(
char16_t
)
0x2018
)
#
define
CH_RIGHT_SINGLE_QUOTE
(
(
char16_t
)
0x2019
)
#
define
CH_LEFT_DOUBLE_QUOTE
(
(
char16_t
)
0x201C
)
#
define
CH_RIGHT_DOUBLE_QUOTE
(
(
char16_t
)
0x201D
)
#
define
CH_SHY
(
(
char16_t
)
0xAD
)
static_assert
(
CH_SHY
<
=
255
"
CH_SHY
is
not
an
ascii
character
"
)
;
class
nsFindContentIterator
final
:
public
nsIContentIterator
{
public
:
explicit
nsFindContentIterator
(
bool
aFindBackward
)
:
mStartOffset
(
0
)
mEndOffset
(
0
)
mFindBackward
(
aFindBackward
)
{
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsFindContentIterator
)
virtual
nsresult
Init
(
nsINode
*
aRoot
)
override
{
NS_NOTREACHED
(
"
internal
error
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
virtual
nsresult
Init
(
nsRange
*
aRange
)
override
{
NS_NOTREACHED
(
"
internal
error
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
virtual
nsresult
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
override
{
NS_NOTREACHED
(
"
internal
error
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
virtual
nsresult
Init
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
override
{
NS_NOTREACHED
(
"
internal
error
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
Init
(
nsIDOMNode
*
aStartNode
int32_t
aStartOffset
nsIDOMNode
*
aEndNode
int32_t
aEndOffset
)
;
virtual
void
First
(
)
override
;
virtual
void
Last
(
)
override
;
virtual
void
Next
(
)
override
;
virtual
void
Prev
(
)
override
;
virtual
nsINode
*
GetCurrentNode
(
)
override
;
virtual
bool
IsDone
(
)
override
;
virtual
nsresult
PositionAt
(
nsINode
*
aCurNode
)
override
;
protected
:
virtual
~
nsFindContentIterator
(
)
{
}
private
:
static
already_AddRefed
<
nsRange
>
CreateRange
(
nsINode
*
aNode
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aNode
)
;
range
-
>
SetMaySpanAnonymousSubtrees
(
true
)
;
return
range
.
forget
(
)
;
}
nsCOMPtr
<
nsIContentIterator
>
mOuterIterator
;
nsCOMPtr
<
nsIContentIterator
>
mInnerIterator
;
nsCOMPtr
<
nsINode
>
mStartNode
;
int32_t
mStartOffset
;
nsCOMPtr
<
nsINode
>
mEndNode
;
int32_t
mEndOffset
;
nsCOMPtr
<
nsIContent
>
mStartOuterContent
;
nsCOMPtr
<
nsIContent
>
mEndOuterContent
;
bool
mFindBackward
;
void
Reset
(
)
;
void
MaybeSetupInnerIterator
(
)
;
void
SetupInnerIterator
(
nsIContent
*
aContent
)
;
}
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsFindContentIterator
)
NS_INTERFACE_MAP_ENTRY
(
nsIContentIterator
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsFindContentIterator
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsFindContentIterator
)
NS_IMPL_CYCLE_COLLECTION
(
nsFindContentIterator
mOuterIterator
mInnerIterator
mStartOuterContent
mEndOuterContent
mEndNode
mStartNode
)
nsresult
nsFindContentIterator
:
:
Init
(
nsIDOMNode
*
aStartNode
int32_t
aStartOffset
nsIDOMNode
*
aEndNode
int32_t
aEndOffset
)
{
NS_ENSURE_ARG_POINTER
(
aStartNode
)
;
NS_ENSURE_ARG_POINTER
(
aEndNode
)
;
if
(
!
mOuterIterator
)
{
if
(
mFindBackward
)
{
mOuterIterator
=
do_CreateInstance
(
kCContentIteratorCID
)
;
}
else
{
mOuterIterator
=
do_CreateInstance
(
kCPreContentIteratorCID
)
;
}
NS_ENSURE_ARG_POINTER
(
mOuterIterator
)
;
}
mStartNode
=
do_QueryInterface
(
aStartNode
)
;
mStartOffset
=
aStartOffset
;
mEndNode
=
do_QueryInterface
(
aEndNode
)
;
mEndOffset
=
aEndOffset
;
return
NS_OK
;
}
void
nsFindContentIterator
:
:
First
(
)
{
Reset
(
)
;
}
void
nsFindContentIterator
:
:
Last
(
)
{
Reset
(
)
;
}
void
nsFindContentIterator
:
:
Next
(
)
{
if
(
mInnerIterator
)
{
mInnerIterator
-
>
Next
(
)
;
if
(
!
mInnerIterator
-
>
IsDone
(
)
)
{
return
;
}
}
else
{
mOuterIterator
-
>
Next
(
)
;
}
MaybeSetupInnerIterator
(
)
;
}
void
nsFindContentIterator
:
:
Prev
(
)
{
if
(
mInnerIterator
)
{
mInnerIterator
-
>
Prev
(
)
;
if
(
!
mInnerIterator
-
>
IsDone
(
)
)
{
return
;
}
}
else
{
mOuterIterator
-
>
Prev
(
)
;
}
MaybeSetupInnerIterator
(
)
;
}
nsINode
*
nsFindContentIterator
:
:
GetCurrentNode
(
)
{
if
(
mInnerIterator
&
&
!
mInnerIterator
-
>
IsDone
(
)
)
{
return
mInnerIterator
-
>
GetCurrentNode
(
)
;
}
return
mOuterIterator
-
>
GetCurrentNode
(
)
;
}
bool
nsFindContentIterator
:
:
IsDone
(
)
{
if
(
mInnerIterator
&
&
!
mInnerIterator
-
>
IsDone
(
)
)
{
return
false
;
}
return
mOuterIterator
-
>
IsDone
(
)
;
}
nsresult
nsFindContentIterator
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
nsINode
*
oldNode
=
mOuterIterator
-
>
GetCurrentNode
(
)
;
nsresult
rv
=
mOuterIterator
-
>
PositionAt
(
aCurNode
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MaybeSetupInnerIterator
(
)
;
}
else
{
mOuterIterator
-
>
PositionAt
(
oldNode
)
;
if
(
mInnerIterator
)
{
rv
=
mInnerIterator
-
>
PositionAt
(
aCurNode
)
;
}
}
return
rv
;
}
void
nsFindContentIterator
:
:
Reset
(
)
{
mInnerIterator
=
nullptr
;
mStartOuterContent
=
nullptr
;
mEndOuterContent
=
nullptr
;
nsCOMPtr
<
nsIContent
>
startContent
(
do_QueryInterface
(
mStartNode
)
)
;
if
(
startContent
)
{
mStartOuterContent
=
startContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
}
nsCOMPtr
<
nsIContent
>
endContent
(
do_QueryInterface
(
mEndNode
)
)
;
if
(
endContent
)
{
mEndOuterContent
=
endContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
}
nsCOMPtr
<
nsINode
>
node
=
mStartNode
;
NS_ENSURE_TRUE_VOID
(
node
)
;
RefPtr
<
nsRange
>
range
=
CreateRange
(
node
)
;
range
-
>
SetStart
(
*
mStartNode
mStartOffset
IgnoreErrors
(
)
)
;
range
-
>
SetEnd
(
*
mEndNode
mEndOffset
IgnoreErrors
(
)
)
;
mOuterIterator
-
>
Init
(
range
)
;
if
(
!
mFindBackward
)
{
if
(
mStartOuterContent
!
=
startContent
)
{
SetupInnerIterator
(
mStartOuterContent
)
;
if
(
mInnerIterator
)
{
mInnerIterator
-
>
First
(
)
;
}
}
if
(
!
mOuterIterator
-
>
IsDone
(
)
)
{
mOuterIterator
-
>
First
(
)
;
}
}
else
{
if
(
mEndOuterContent
!
=
endContent
)
{
SetupInnerIterator
(
mEndOuterContent
)
;
if
(
mInnerIterator
)
{
mInnerIterator
-
>
Last
(
)
;
}
}
if
(
!
mOuterIterator
-
>
IsDone
(
)
)
{
mOuterIterator
-
>
Last
(
)
;
}
}
if
(
!
mInnerIterator
)
{
MaybeSetupInnerIterator
(
)
;
}
}
void
nsFindContentIterator
:
:
MaybeSetupInnerIterator
(
)
{
mInnerIterator
=
nullptr
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mOuterIterator
-
>
GetCurrentNode
(
)
)
;
if
(
!
content
|
|
!
content
-
>
IsNodeOfType
(
nsINode
:
:
eHTML_FORM_CONTROL
)
)
{
return
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
(
do_QueryInterface
(
content
)
)
;
if
(
!
formControl
-
>
IsTextControl
(
true
)
)
{
return
;
}
SetupInnerIterator
(
content
)
;
if
(
mInnerIterator
)
{
if
(
!
mFindBackward
)
{
mInnerIterator
-
>
First
(
)
;
if
(
!
mOuterIterator
-
>
IsDone
(
)
)
{
mOuterIterator
-
>
First
(
)
;
}
}
else
{
mInnerIterator
-
>
Last
(
)
;
if
(
!
mOuterIterator
-
>
IsDone
(
)
)
{
mOuterIterator
-
>
Last
(
)
;
}
}
}
}
void
nsFindContentIterator
:
:
SetupInnerIterator
(
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
return
;
}
NS_ASSERTION
(
!
aContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
"
invalid
call
"
)
;
nsITextControlFrame
*
tcFrame
=
do_QueryFrame
(
aContent
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
tcFrame
)
{
return
;
}
RefPtr
<
TextEditor
>
textEditor
=
tcFrame
-
>
GetTextEditor
(
)
;
if
(
!
textEditor
|
|
textEditor
-
>
IsDisabled
(
)
)
{
return
;
}
RefPtr
<
dom
:
:
Element
>
rootElement
=
textEditor
-
>
GetRoot
(
)
;
if
(
!
rootElement
)
{
return
;
}
RefPtr
<
nsRange
>
innerRange
=
CreateRange
(
aContent
)
;
RefPtr
<
nsRange
>
outerRange
=
CreateRange
(
aContent
)
;
if
(
!
innerRange
|
|
!
outerRange
)
{
return
;
}
mInnerIterator
=
do_CreateInstance
(
kCPreContentIteratorCID
)
;
if
(
mInnerIterator
)
{
innerRange
-
>
SelectNodeContents
(
*
rootElement
IgnoreErrors
(
)
)
;
if
(
aContent
=
=
mStartOuterContent
)
{
innerRange
-
>
SetStart
(
*
mStartNode
mStartOffset
IgnoreErrors
(
)
)
;
}
if
(
aContent
=
=
mEndOuterContent
)
{
innerRange
-
>
SetEnd
(
*
mEndNode
mEndOffset
IgnoreErrors
(
)
)
;
}
mInnerIterator
-
>
Init
(
innerRange
)
;
IgnoredErrorResult
res1
res2
;
if
(
!
mFindBackward
)
{
outerRange
-
>
SetEnd
(
*
mEndNode
mEndOffset
res1
)
;
outerRange
-
>
SetStartAfter
(
*
aContent
res2
)
;
}
else
{
outerRange
-
>
SetStart
(
*
mStartNode
mStartOffset
res1
)
;
outerRange
-
>
SetEndBefore
(
*
aContent
res2
)
;
}
if
(
res1
.
Failed
(
)
|
|
res2
.
Failed
(
)
)
{
outerRange
-
>
Collapse
(
true
)
;
}
mOuterIterator
-
>
Init
(
outerRange
)
;
}
}
nsresult
NS_NewFindContentIterator
(
bool
aFindBackward
nsIContentIterator
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
if
(
!
aResult
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsFindContentIterator
*
it
=
new
nsFindContentIterator
(
aFindBackward
)
;
if
(
!
it
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
it
-
>
QueryInterface
(
NS_GET_IID
(
nsIContentIterator
)
(
void
*
*
)
aResult
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsFind
)
NS_INTERFACE_MAP_ENTRY
(
nsIFind
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsFind
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsFind
)
NS_IMPL_CYCLE_COLLECTION
(
nsFind
mLastBlockParent
mIterNode
mIterator
)
nsFind
:
:
nsFind
(
)
:
mFindBackward
(
false
)
mCaseSensitive
(
false
)
mWordBreaker
(
nullptr
)
mIterOffset
(
0
)
{
}
nsFind
:
:
~
nsFind
(
)
{
}
#
ifdef
DEBUG_FIND
static
void
DumpNode
(
nsIDOMNode
*
aNode
)
{
if
(
!
aNode
)
{
printf
(
"
>
>
>
>
Node
:
NULL
\
n
"
)
;
return
;
}
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
nsString
nodeName
=
node
-
>
NodeName
(
)
;
nsCOMPtr
<
nsIContent
>
textContent
(
do_QueryInterface
(
aNode
)
)
;
if
(
textContent
&
&
textContent
-
>
IsText
(
)
)
{
nsAutoString
newText
;
textContent
-
>
AppendTextTo
(
newText
)
;
printf
(
"
>
>
>
>
Text
node
(
node
name
%
s
)
:
'
%
s
'
\
n
"
NS_LossyConvertUTF16toASCII
(
nodeName
)
.
get
(
)
NS_LossyConvertUTF16toASCII
(
newText
)
.
get
(
)
)
;
}
else
{
printf
(
"
>
>
>
>
Node
:
%
s
\
n
"
NS_LossyConvertUTF16toASCII
(
nodeName
)
.
get
(
)
)
;
}
}
#
endif
nsresult
nsFind
:
:
InitIterator
(
nsIDOMNode
*
aStartNode
int32_t
aStartOffset
nsIDOMNode
*
aEndNode
int32_t
aEndOffset
)
{
if
(
!
mIterator
)
{
mIterator
=
new
nsFindContentIterator
(
mFindBackward
)
;
NS_ENSURE_TRUE
(
mIterator
NS_ERROR_OUT_OF_MEMORY
)
;
}
NS_ENSURE_ARG_POINTER
(
aStartNode
)
;
NS_ENSURE_ARG_POINTER
(
aEndNode
)
;
#
ifdef
DEBUG_FIND
printf
(
"
InitIterator
search
range
:
\
n
"
)
;
printf
(
"
-
-
start
%
d
"
aStartOffset
)
;
DumpNode
(
aStartNode
)
;
printf
(
"
-
-
end
%
d
"
aEndOffset
)
;
DumpNode
(
aEndNode
)
;
#
endif
nsresult
rv
=
mIterator
-
>
Init
(
aStartNode
aStartOffset
aEndNode
aEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mFindBackward
)
{
mIterator
-
>
Last
(
)
;
}
else
{
mIterator
-
>
First
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
GetFindBackwards
(
bool
*
aFindBackward
)
{
if
(
!
aFindBackward
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aFindBackward
=
mFindBackward
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
SetFindBackwards
(
bool
aFindBackward
)
{
mFindBackward
=
aFindBackward
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
GetCaseSensitive
(
bool
*
aCaseSensitive
)
{
if
(
!
aCaseSensitive
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCaseSensitive
=
mCaseSensitive
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
SetCaseSensitive
(
bool
aCaseSensitive
)
{
mCaseSensitive
=
aCaseSensitive
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
GetEntireWord
(
bool
*
aEntireWord
)
{
if
(
!
aEntireWord
)
return
NS_ERROR_NULL_POINTER
;
*
aEntireWord
=
!
!
mWordBreaker
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFind
:
:
SetEntireWord
(
bool
aEntireWord
)
{
mWordBreaker
=
aEntireWord
?
nsContentUtils
:
:
WordBreaker
(
)
:
nullptr
;
return
NS_OK
;
}
nsresult
nsFind
:
:
NextNode
(
nsRange
*
aSearchRange
nsRange
*
aStartPoint
nsRange
*
aEndPoint
bool
aContinueOk
)
{
nsresult
rv
;
nsCOMPtr
<
nsIContent
>
content
;
if
(
!
mIterator
|
|
aContinueOk
)
{
nsCOMPtr
<
nsINode
>
startNode
;
nsCOMPtr
<
nsINode
>
endNode
;
uint32_t
startOffset
endOffset
;
if
(
aContinueOk
)
{
#
ifdef
DEBUG_FIND
printf
(
"
Match
in
progress
:
continuing
past
endpoint
\
n
"
)
;
#
endif
if
(
mFindBackward
)
{
startNode
=
aSearchRange
-
>
GetStartContainer
(
)
;
startOffset
=
aSearchRange
-
>
StartOffset
(
)
;
endNode
=
aEndPoint
-
>
GetStartContainer
(
)
;
endOffset
=
aEndPoint
-
>
StartOffset
(
)
;
}
else
{
startNode
=
aEndPoint
-
>
GetEndContainer
(
)
;
startOffset
=
aEndPoint
-
>
EndOffset
(
)
;
endNode
=
aSearchRange
-
>
GetEndContainer
(
)
;
endOffset
=
aSearchRange
-
>
EndOffset
(
)
;
}
}
else
{
if
(
mFindBackward
)
{
startNode
=
aSearchRange
-
>
GetStartContainer
(
)
;
startOffset
=
aSearchRange
-
>
StartOffset
(
)
;
endNode
=
aStartPoint
-
>
GetEndContainer
(
)
;
endOffset
=
aStartPoint
-
>
EndOffset
(
)
;
}
else
{
startNode
=
aStartPoint
-
>
GetStartContainer
(
)
;
startOffset
=
aStartPoint
-
>
StartOffset
(
)
;
endNode
=
aEndPoint
-
>
GetEndContainer
(
)
;
endOffset
=
aEndPoint
-
>
EndOffset
(
)
;
}
}
rv
=
InitIterator
(
startNode
-
>
AsDOMNode
(
)
static_cast
<
int32_t
>
(
startOffset
)
endNode
-
>
AsDOMNode
(
)
static_cast
<
int32_t
>
(
endOffset
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aStartPoint
)
{
aStartPoint
=
aSearchRange
;
}
content
=
do_QueryInterface
(
mIterator
-
>
GetCurrentNode
(
)
)
;
#
ifdef
DEBUG_FIND
nsCOMPtr
<
nsIDOMNode
>
dnode
(
do_QueryInterface
(
content
)
)
;
printf
(
"
:
:
:
:
:
:
Got
the
first
node
"
)
;
DumpNode
(
dnode
)
;
#
endif
if
(
content
&
&
content
-
>
IsText
(
)
&
&
!
SkipNode
(
content
)
)
{
mIterNode
=
content
;
nsCOMPtr
<
nsINode
>
node
;
if
(
mFindBackward
)
{
node
=
aStartPoint
-
>
GetEndContainer
(
)
;
if
(
mIterNode
=
=
node
)
{
uint32_t
endOffset
=
aStartPoint
-
>
EndOffset
(
)
;
mIterOffset
=
static_cast
<
int32_t
>
(
endOffset
)
;
}
else
{
mIterOffset
=
-
1
;
}
}
else
{
node
=
aStartPoint
-
>
GetStartContainer
(
)
;
if
(
mIterNode
=
=
node
)
{
uint32_t
startOffset
=
aStartPoint
-
>
StartOffset
(
)
;
mIterOffset
=
static_cast
<
int32_t
>
(
startOffset
)
;
}
else
{
mIterOffset
=
0
;
}
}
#
ifdef
DEBUG_FIND
printf
(
"
Setting
initial
offset
to
%
d
\
n
"
mIterOffset
)
;
#
endif
return
NS_OK
;
}
}
while
(
true
)
{
if
(
mFindBackward
)
{
mIterator
-
>
Prev
(
)
;
}
else
{
mIterator
-
>
Next
(
)
;
}
content
=
do_QueryInterface
(
mIterator
-
>
GetCurrentNode
(
)
)
;
if
(
!
content
)
{
break
;
}
#
ifdef
DEBUG_FIND
nsCOMPtr
<
nsIDOMNode
>
dnode
(
do_QueryInterface
(
content
)
)
;
printf
(
"
:
:
:
:
:
:
Got
another
node
"
)
;
DumpNode
(
dnode
)
;
#
endif
if
(
SkipNode
(
content
)
)
{
continue
;
}
if
(
content
-
>
IsText
(
)
)
{
break
;
}
#
ifdef
DEBUG_FIND
dnode
=
do_QueryInterface
(
content
)
;
printf
(
"
Not
a
text
node
:
"
)
;
DumpNode
(
dnode
)
;
#
endif
}
mIterNode
=
content
;
mIterOffset
=
-
1
;
#
ifdef
DEBUG_FIND
printf
(
"
Iterator
gave
:
"
)
;
DumpNode
(
mIterNode
)
;
#
endif
return
NS_OK
;
}
class
MOZ_STACK_CLASS
PeekNextCharRestoreState
final
{
public
:
explicit
PeekNextCharRestoreState
(
nsFind
*
aFind
)
:
mIterOffset
(
aFind
-
>
mIterOffset
)
mIterNode
(
aFind
-
>
mIterNode
)
mCurrNode
(
aFind
-
>
mIterator
-
>
GetCurrentNode
(
)
)
mFind
(
aFind
)
{
}
~
PeekNextCharRestoreState
(
)
{
mFind
-
>
mIterOffset
=
mIterOffset
;
mFind
-
>
mIterNode
=
mIterNode
;
mFind
-
>
mIterator
-
>
PositionAt
(
mCurrNode
)
;
}
private
:
int32_t
mIterOffset
;
nsCOMPtr
<
nsINode
>
mIterNode
;
nsCOMPtr
<
nsINode
>
mCurrNode
;
RefPtr
<
nsFind
>
mFind
;
}
;
char16_t
nsFind
:
:
PeekNextChar
(
nsRange
*
aSearchRange
nsRange
*
aStartPoint
nsRange
*
aEndPoint
)
{
PeekNextCharRestoreState
restoreState
(
this
)
;
nsCOMPtr
<
nsIContent
>
tc
;
nsresult
rv
;
const
nsTextFragment
*
frag
;
int32_t
fragLen
;
do
{
tc
=
nullptr
;
NextNode
(
aSearchRange
aStartPoint
aEndPoint
false
)
;
tc
=
do_QueryInterface
(
mIterNode
)
;
nsCOMPtr
<
nsINode
>
blockParent
;
rv
=
GetBlockParent
(
mIterNode
getter_AddRefs
(
blockParent
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
L
'
\
0
'
;
if
(
!
mIterNode
|
|
!
tc
|
|
(
blockParent
!
=
mLastBlockParent
)
)
return
L
'
\
0
'
;
frag
=
tc
-
>
GetText
(
)
;
fragLen
=
frag
-
>
GetLength
(
)
;
}
while
(
fragLen
<
=
0
)
;
const
char16_t
*
t2b
=
nullptr
;
const
char
*
t1b
=
nullptr
;
if
(
frag
-
>
Is2b
(
)
)
{
t2b
=
frag
-
>
Get2b
(
)
;
}
else
{
t1b
=
frag
-
>
Get1b
(
)
;
}
int32_t
index
=
mFindBackward
?
fragLen
-
1
:
0
;
return
t1b
?
CHAR_TO_UNICHAR
(
t1b
[
index
]
)
:
t2b
[
index
]
;
}
bool
nsFind
:
:
IsBlockNode
(
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
img
nsGkAtoms
:
:
hr
nsGkAtoms
:
:
th
nsGkAtoms
:
:
td
)
)
{
return
true
;
}
return
nsContentUtils
:
:
IsHTMLBlock
(
aContent
)
;
}
bool
nsFind
:
:
IsVisibleNode
(
nsINode
*
aDOMNode
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aDOMNode
)
)
;
if
(
!
content
)
{
return
false
;
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
false
;
}
return
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
bool
nsFind
:
:
SkipNode
(
nsIContent
*
aContent
)
{
#
ifdef
HAVE_BIDI_ITERATOR
return
aContent
-
>
IsComment
(
)
|
|
aContent
-
>
IsAnyOfHTMLElements
(
sScriptAtom
sNoframesAtom
sSelectAtom
)
;
#
else
nsIContent
*
content
=
aContent
;
while
(
content
)
{
if
(
aContent
-
>
IsComment
(
)
|
|
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
noframes
nsGkAtoms
:
:
select
)
)
{
#
ifdef
DEBUG_FIND
printf
(
"
Skipping
node
:
"
)
;
nsCOMPtr
<
nsIDOMNode
>
node
(
do_QueryInterface
(
content
)
)
;
DumpNode
(
node
)
;
#
endif
return
true
;
}
if
(
IsBlockNode
(
content
)
)
{
return
false
;
}
content
=
content
-
>
GetParent
(
)
;
}
return
false
;
#
endif
}
nsresult
nsFind
:
:
GetBlockParent
(
nsINode
*
aNode
nsINode
*
*
aParent
)
{
nsINode
*
curNode
=
aNode
;
while
(
curNode
)
{
nsIContent
*
parent
=
curNode
-
>
GetParent
(
)
;
if
(
parent
&
&
IsBlockNode
(
parent
)
)
{
*
aParent
=
do_AddRef
(
parent
)
.
take
(
)
;
return
NS_OK
;
}
curNode
=
parent
;
}
return
NS_ERROR_FAILURE
;
}
void
nsFind
:
:
ResetAll
(
)
{
mIterator
=
nullptr
;
mLastBlockParent
=
nullptr
;
}
#
define
NBSP_CHARCODE
(
CHAR_TO_UNICHAR
(
160
)
)
#
define
IsSpace
(
c
)
(
nsCRT
:
:
IsAsciiSpace
(
c
)
|
|
(
c
)
=
=
NBSP_CHARCODE
)
#
define
OVERFLOW_PINDEX
(
mFindBackward
?
pindex
<
0
:
pindex
>
patLen
)
#
define
DONE_WITH_PINDEX
(
mFindBackward
?
pindex
<
=
0
:
pindex
>
=
patLen
)
#
define
ALMOST_DONE_WITH_PINDEX
(
mFindBackward
?
pindex
<
=
0
:
pindex
>
=
patLen
-
1
)
NS_IMETHODIMP
nsFind
:
:
Find
(
const
char16_t
*
aPatText
nsRange
*
aSearchRange
nsRange
*
aStartPoint
nsRange
*
aEndPoint
nsRange
*
*
aRangeRet
)
{
#
ifdef
DEBUG_FIND
printf
(
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
nsFind
:
:
Find
(
'
%
s
'
%
s
%
p
%
p
%
p
)
\
n
"
NS_LossyConvertUTF16toASCII
(
aPatText
)
.
get
(
)
mFindBackward
?
"
(
backward
)
"
:
"
(
forward
)
"
(
void
*
)
aSearchRange
(
void
*
)
aStartPoint
(
void
*
)
aEndPoint
)
;
#
endif
NS_ENSURE_ARG
(
aSearchRange
)
;
NS_ENSURE_ARG
(
aStartPoint
)
;
NS_ENSURE_ARG
(
aEndPoint
)
;
NS_ENSURE_ARG_POINTER
(
aRangeRet
)
;
*
aRangeRet
=
0
;
if
(
!
aPatText
)
{
return
NS_ERROR_NULL_POINTER
;
}
ResetAll
(
)
;
nsAutoString
patAutoStr
(
aPatText
)
;
if
(
!
mCaseSensitive
)
{
ToLowerCase
(
patAutoStr
)
;
}
static
const
char
kShy
[
]
=
{
char
(
CH_SHY
)
0
}
;
patAutoStr
.
StripChars
(
kShy
)
;
const
char16_t
*
patStr
=
patAutoStr
.
get
(
)
;
int32_t
patLen
=
patAutoStr
.
Length
(
)
-
1
;
int32_t
pindex
=
(
mFindBackward
?
patLen
:
0
)
;
int32_t
findex
=
0
;
int
incr
=
(
mFindBackward
?
-
1
:
1
)
;
nsCOMPtr
<
nsIContent
>
tc
;
const
nsTextFragment
*
frag
=
nullptr
;
int32_t
fragLen
=
0
;
const
char16_t
*
t2b
=
nullptr
;
const
char
*
t1b
=
nullptr
;
bool
inWhitespace
=
false
;
bool
wordBreakPrev
=
false
;
nsCOMPtr
<
nsINode
>
matchAnchorNode
;
int32_t
matchAnchorOffset
=
0
;
nsCOMPtr
<
nsINode
>
endNode
=
aEndPoint
-
>
GetEndContainer
(
)
;
;
uint32_t
endOffset
=
aEndPoint
-
>
EndOffset
(
)
;
char16_t
c
=
0
;
char16_t
patc
=
0
;
char16_t
prevChar
=
0
;
char16_t
prevCharInMatch
=
0
;
while
(
1
)
{
#
ifdef
DEBUG_FIND
printf
(
"
Loop
.
.
.
\
n
"
)
;
#
endif
if
(
!
frag
)
{
tc
=
nullptr
;
NextNode
(
aSearchRange
aStartPoint
aEndPoint
false
)
;
if
(
!
mIterNode
)
{
if
(
matchAnchorNode
)
{
NextNode
(
aSearchRange
aStartPoint
aEndPoint
true
)
;
}
ResetAll
(
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
blockParent
;
GetBlockParent
(
mIterNode
getter_AddRefs
(
blockParent
)
)
;
#
ifdef
DEBUG_FIND
printf
(
"
New
node
:
old
blockparent
=
%
p
new
=
%
p
\
n
"
(
void
*
)
mLastBlockParent
.
get
(
)
(
void
*
)
blockParent
.
get
(
)
)
;
#
endif
if
(
blockParent
!
=
mLastBlockParent
)
{
#
ifdef
DEBUG_FIND
printf
(
"
Different
block
parent
!
\
n
"
)
;
#
endif
mLastBlockParent
=
blockParent
;
matchAnchorNode
=
nullptr
;
matchAnchorOffset
=
0
;
pindex
=
(
mFindBackward
?
patLen
:
0
)
;
inWhitespace
=
false
;
}
tc
=
do_QueryInterface
(
mIterNode
)
;
if
(
!
tc
|
|
!
(
frag
=
tc
-
>
GetText
(
)
)
)
{
mIterator
=
nullptr
;
mLastBlockParent
=
nullptr
;
ResetAll
(
)
;
return
NS_OK
;
}
fragLen
=
frag
-
>
GetLength
(
)
;
if
(
mIterNode
=
=
matchAnchorNode
)
{
findex
=
matchAnchorOffset
+
(
mFindBackward
?
1
:
0
)
;
}
else
if
(
mIterOffset
>
=
0
)
{
findex
=
mIterOffset
-
(
mFindBackward
?
1
:
0
)
;
}
else
if
(
mFindBackward
)
{
findex
=
fragLen
-
1
;
}
else
{
findex
=
0
;
}
mIterOffset
=
-
1
;
if
(
findex
<
0
|
|
findex
>
fragLen
-
1
)
{
#
ifdef
DEBUG_FIND
printf
(
"
At
the
end
of
a
text
node
-
-
skipping
to
the
next
\
n
"
)
;
#
endif
frag
=
0
;
continue
;
}
#
ifdef
DEBUG_FIND
printf
(
"
Starting
from
offset
%
d
\
n
"
findex
)
;
#
endif
if
(
frag
-
>
Is2b
(
)
)
{
t2b
=
frag
-
>
Get2b
(
)
;
t1b
=
nullptr
;
#
ifdef
DEBUG_FIND
nsAutoString
str2
(
t2b
fragLen
)
;
printf
(
"
2
byte
'
%
s
'
\
n
"
NS_LossyConvertUTF16toASCII
(
str2
)
.
get
(
)
)
;
#
endif
}
else
{
t1b
=
frag
-
>
Get1b
(
)
;
t2b
=
nullptr
;
#
ifdef
DEBUG_FIND
nsAutoCString
str1
(
t1b
fragLen
)
;
printf
(
"
1
byte
'
%
s
'
\
n
"
str1
.
get
(
)
)
;
#
endif
}
}
else
{
findex
+
=
incr
;
#
ifdef
DEBUG_FIND
printf
(
"
Same
node
-
-
(
%
d
%
d
)
\
n
"
pindex
findex
)
;
#
endif
if
(
mFindBackward
?
(
findex
<
0
)
:
(
findex
>
=
fragLen
)
)
{
#
ifdef
DEBUG_FIND
printf
(
"
Will
need
to
pull
a
new
node
:
mAO
=
%
d
frag
len
=
%
d
\
n
"
matchAnchorOffset
fragLen
)
;
#
endif
frag
=
nullptr
;
continue
;
}
}
if
(
mIterNode
=
=
endNode
&
&
(
(
mFindBackward
&
&
findex
<
static_cast
<
int32_t
>
(
endOffset
)
)
|
|
(
!
mFindBackward
&
&
findex
>
static_cast
<
int32_t
>
(
endOffset
)
)
)
)
{
ResetAll
(
)
;
return
NS_OK
;
}
prevChar
=
c
;
c
=
(
t2b
?
t2b
[
findex
]
:
CHAR_TO_UNICHAR
(
t1b
[
findex
]
)
)
;
patc
=
patStr
[
pindex
]
;
#
ifdef
DEBUG_FIND
printf
(
"
Comparing
'
%
c
'
=
%
x
to
'
%
c
'
(
%
d
of
%
d
)
findex
=
%
d
%
s
\
n
"
(
char
)
c
(
int
)
c
patc
pindex
patLen
findex
inWhitespace
?
"
(
inWhitespace
)
"
:
"
"
)
;
#
endif
if
(
inWhitespace
&
&
!
IsSpace
(
c
)
)
{
inWhitespace
=
false
;
pindex
+
=
incr
;
#
ifdef
DEBUG
if
(
OVERFLOW_PINDEX
)
{
NS_ASSERTION
(
false
"
Missed
a
whitespace
match
"
)
;
}
#
endif
patc
=
patStr
[
pindex
]
;
}
if
(
!
inWhitespace
&
&
IsSpace
(
patc
)
)
{
inWhitespace
=
true
;
}
else
if
(
!
inWhitespace
&
&
!
mCaseSensitive
&
&
IsUpperCase
(
c
)
)
{
c
=
ToLowerCase
(
c
)
;
}
if
(
c
=
=
CH_SHY
)
{
continue
;
}
if
(
!
mCaseSensitive
)
{
switch
(
c
)
{
case
CH_LEFT_SINGLE_QUOTE
:
case
CH_RIGHT_SINGLE_QUOTE
:
c
=
CH_APOSTROPHE
;
break
;
case
CH_LEFT_DOUBLE_QUOTE
:
case
CH_RIGHT_DOUBLE_QUOTE
:
c
=
CH_QUOTE
;
break
;
}
switch
(
patc
)
{
case
CH_LEFT_SINGLE_QUOTE
:
case
CH_RIGHT_SINGLE_QUOTE
:
patc
=
CH_APOSTROPHE
;
break
;
case
CH_LEFT_DOUBLE_QUOTE
:
case
CH_RIGHT_DOUBLE_QUOTE
:
patc
=
CH_QUOTE
;
break
;
}
}
if
(
pindex
!
=
(
mFindBackward
?
patLen
:
0
)
&
&
c
!
=
patc
&
&
!
inWhitespace
)
{
if
(
c
=
=
'
\
n
'
&
&
t2b
&
&
IS_CJ_CHAR
(
prevCharInMatch
)
)
{
int32_t
nindex
=
findex
+
incr
;
if
(
mFindBackward
?
(
nindex
>
=
0
)
:
(
nindex
<
fragLen
)
)
{
if
(
IS_CJ_CHAR
(
t2b
[
nindex
]
)
)
{
continue
;
}
}
}
}
wordBreakPrev
=
false
;
if
(
mWordBreaker
)
{
if
(
prevChar
=
=
NBSP_CHARCODE
)
prevChar
=
CHAR_TO_UNICHAR
(
'
'
)
;
wordBreakPrev
=
mWordBreaker
-
>
BreakInBetween
(
&
prevChar
1
&
c
1
)
;
}
if
(
(
c
=
=
patc
&
&
(
!
mWordBreaker
|
|
matchAnchorNode
|
|
wordBreakPrev
)
)
|
|
(
inWhitespace
&
&
IsSpace
(
c
)
)
)
{
prevCharInMatch
=
c
;
#
ifdef
DEBUG_FIND
if
(
inWhitespace
)
{
printf
(
"
YES
(
whitespace
)
(
%
d
of
%
d
)
\
n
"
pindex
patLen
)
;
}
else
{
printf
(
"
YES
!
'
%
c
'
=
=
'
%
c
'
(
%
d
of
%
d
)
\
n
"
c
patc
pindex
patLen
)
;
}
#
endif
if
(
!
matchAnchorNode
)
{
matchAnchorNode
=
mIterNode
;
matchAnchorOffset
=
findex
;
}
if
(
DONE_WITH_PINDEX
)
{
#
ifdef
DEBUG_FIND
printf
(
"
Found
a
match
!
\
n
"
)
;
#
endif
nsCOMPtr
<
nsINode
>
startParent
;
nsCOMPtr
<
nsINode
>
endParent
;
if
(
mWordBreaker
)
{
int32_t
nextfindex
=
findex
+
incr
;
char16_t
nextChar
;
if
(
mFindBackward
?
(
nextfindex
>
=
0
)
:
(
nextfindex
<
fragLen
)
)
nextChar
=
(
t2b
?
t2b
[
nextfindex
]
:
CHAR_TO_UNICHAR
(
t1b
[
nextfindex
]
)
)
;
else
nextChar
=
PeekNextChar
(
aSearchRange
aStartPoint
aEndPoint
)
;
if
(
nextChar
=
=
NBSP_CHARCODE
)
nextChar
=
CHAR_TO_UNICHAR
(
'
'
)
;
if
(
!
mWordBreaker
-
>
BreakInBetween
(
&
c
1
&
nextChar
1
)
)
{
matchAnchorNode
=
nullptr
;
continue
;
}
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
tc
)
;
if
(
range
)
{
int32_t
matchStartOffset
matchEndOffset
;
int32_t
mao
=
matchAnchorOffset
+
(
mFindBackward
?
1
:
0
)
;
if
(
mFindBackward
)
{
startParent
=
tc
;
endParent
=
matchAnchorNode
;
matchStartOffset
=
findex
;
matchEndOffset
=
mao
;
}
else
{
startParent
=
matchAnchorNode
;
endParent
=
tc
;
matchStartOffset
=
mao
;
matchEndOffset
=
findex
+
1
;
}
if
(
startParent
&
&
endParent
&
&
IsVisibleNode
(
startParent
)
&
&
IsVisibleNode
(
endParent
)
)
{
range
-
>
SetStart
(
*
startParent
matchStartOffset
IgnoreErrors
(
)
)
;
range
-
>
SetEnd
(
*
endParent
matchEndOffset
IgnoreErrors
(
)
)
;
*
aRangeRet
=
range
.
get
(
)
;
NS_ADDREF
(
*
aRangeRet
)
;
}
else
{
startParent
=
nullptr
;
}
}
if
(
startParent
)
{
mIterOffset
=
findex
+
(
mFindBackward
?
1
:
0
)
;
#
ifdef
DEBUG_FIND
printf
(
"
mIterOffset
=
%
d
mIterNode
=
"
mIterOffset
)
;
DumpNode
(
mIterNode
)
;
#
endif
ResetAll
(
)
;
return
NS_OK
;
}
matchAnchorNode
=
nullptr
;
}
if
(
matchAnchorNode
)
{
if
(
!
inWhitespace
|
|
DONE_WITH_PINDEX
|
|
IsSpace
(
patStr
[
pindex
+
incr
]
)
)
{
pindex
+
=
incr
;
inWhitespace
=
false
;
#
ifdef
DEBUG_FIND
printf
(
"
Advancing
pindex
to
%
d
\
n
"
pindex
)
;
#
endif
}
continue
;
}
}
#
ifdef
DEBUG_FIND
printf
(
"
NOT
:
%
c
=
=
%
c
\
n
"
c
patc
)
;
#
endif
if
(
matchAnchorNode
)
{
findex
=
matchAnchorOffset
;
mIterOffset
=
matchAnchorOffset
;
if
(
matchAnchorNode
!
=
mIterNode
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
matchAnchorNode
)
)
;
DebugOnly
<
nsresult
>
rv
=
NS_ERROR_UNEXPECTED
;
if
(
content
)
{
rv
=
mIterator
-
>
PositionAt
(
content
)
;
}
frag
=
0
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Text
content
wasn
'
t
nsIContent
!
"
)
;
#
ifdef
DEBUG_FIND
printf
(
"
Repositioned
anchor
node
\
n
"
)
;
#
endif
}
#
ifdef
DEBUG_FIND
printf
(
"
Ending
a
partial
match
;
findex
-
>
%
d
mIterOffset
-
>
%
d
\
n
"
findex
mIterOffset
)
;
#
endif
}
matchAnchorNode
=
nullptr
;
matchAnchorOffset
=
0
;
inWhitespace
=
false
;
pindex
=
(
mFindBackward
?
patLen
:
0
)
;
#
ifdef
DEBUG_FIND
printf
(
"
Setting
findex
back
to
%
d
pindex
to
%
d
\
n
"
findex
pindex
)
;
#
endif
}
ResetAll
(
)
;
return
NS_OK
;
}
