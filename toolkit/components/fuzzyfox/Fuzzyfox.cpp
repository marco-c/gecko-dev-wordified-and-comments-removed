#
include
"
Fuzzyfox
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
prrng
.
h
"
#
include
"
prtime
.
h
"
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
using
namespace
mozilla
;
static
LazyLogModule
sFuzzyfoxLog
(
"
Fuzzyfox
"
)
;
#
define
US_TO_NS
(
x
)
(
(
x
)
*
1000
)
#
define
NS_TO_US
(
x
)
(
(
x
)
/
1000
)
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
level
args
)
MOZ_LOG
(
sFuzzyfoxLog
mozilla
:
:
LogLevel
:
:
level
args
)
#
define
FUZZYFOX_ENABLED_PREF
"
privacy
.
fuzzyfox
.
enabled
"
#
define
FUZZYFOX_ENABLED_PREF_DEFAULT
false
#
define
FUZZYFOX_CLOCKGRAIN_PREF
"
privacy
.
fuzzyfox
.
clockgrainus
"
static
bool
sFuzzyfoxInitializing
;
NS_IMPL_ISUPPORTS_INHERITED
(
Fuzzyfox
Runnable
nsIObserver
)
void
Fuzzyfox
:
:
Start
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
Fuzzyfox
>
r
=
new
Fuzzyfox
(
)
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
;
}
Fuzzyfox
:
:
Fuzzyfox
(
)
:
Runnable
(
"
Fuzzyfox
"
)
mSanityCheck
(
false
)
mStartTime
(
0
)
mDuration
(
PickDuration
(
)
)
mTickType
(
eUptick
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
fuzzyfoxEnabled
=
Preferences
:
:
GetBool
(
FUZZYFOX_ENABLED_PREF
FUZZYFOX_ENABLED_PREF_DEFAULT
)
;
LOG
(
Info
(
"
PT
(
%
p
)
Created
Fuzzyfox
FuzzyFox
is
now
%
s
\
n
"
this
(
fuzzyfoxEnabled
?
"
initializing
"
:
"
disabled
"
)
)
)
;
sFuzzyfoxInitializing
=
fuzzyfoxEnabled
;
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
{
return
;
}
prefs
-
>
AddObserver
(
FUZZYFOX_ENABLED_PREF
this
false
)
;
prefs
-
>
AddObserver
(
FUZZYFOX_CLOCKGRAIN_PREF
this
false
)
;
}
Fuzzyfox
:
:
~
Fuzzyfox
(
)
=
default
;
NS_IMETHODIMP
Fuzzyfox
:
:
Observe
(
nsISupports
*
aObject
const
char
*
aTopic
const
char16_t
*
aMessage
)
{
if
(
!
strcmp
(
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
aTopic
)
)
{
NS_ConvertUTF16toUTF8
pref
(
aMessage
)
;
if
(
pref
.
EqualsLiteral
(
FUZZYFOX_ENABLED_PREF
)
)
{
bool
fuzzyfoxEnabled
=
Preferences
:
:
GetBool
(
FUZZYFOX_ENABLED_PREF
FUZZYFOX_ENABLED_PREF_DEFAULT
)
;
LOG
(
Info
(
"
PT
(
%
p
)
Observed
a
pref
change
FuzzyFox
is
now
%
s
\
n
"
this
(
fuzzyfoxEnabled
?
"
initializing
"
:
"
disabled
"
)
)
)
;
sFuzzyfoxInitializing
=
fuzzyfoxEnabled
;
if
(
sFuzzyfoxInitializing
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
this
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
;
}
else
{
mStartTime
=
0
;
mTickType
=
eUptick
;
mSanityCheck
=
false
;
TimeStamp
:
:
SetFuzzyfoxEnabled
(
false
)
;
}
}
}
return
NS_OK
;
}
#
define
DISPATCH_AND_RETURN
(
)
\
nsCOMPtr
<
nsIRunnable
>
r
=
this
;
\
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
;
\
return
NS_OK
NS_IMETHODIMP
Fuzzyfox
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sFuzzyfoxInitializing
&
&
!
TimeStamp
:
:
GetFuzzyfoxEnabled
(
)
)
{
LOG
(
Info
(
"
[
FuzzyfoxEvent
]
PT
(
%
p
)
Fuzzyfox
is
shut
down
doing
nothing
\
n
"
this
)
)
;
return
NS_OK
;
}
if
(
sFuzzyfoxInitializing
)
{
mStartTime
=
CeilToGrain
(
ActualTime
(
)
)
;
MOZ_ASSERT
(
mStartTime
!
=
0
)
;
TimeStamp
newTimeStamp
=
CeilToGrain
(
TimeStamp
:
:
NowUnfuzzed
(
)
)
;
Fuzzyfox
:
:
UpdateClocks
(
mStartTime
newTimeStamp
)
;
mSanityCheck
=
true
;
LOG
(
Info
(
"
[
FuzzyfoxEvent
]
PT
(
%
p
)
Going
to
start
Fuzzyfox
queuing
up
the
"
"
job
\
n
"
this
)
)
;
TimeStamp
:
:
SetFuzzyfoxEnabled
(
true
)
;
sFuzzyfoxInitializing
=
false
;
DISPATCH_AND_RETURN
(
)
;
}
uint64_t
endTime
=
ActualTime
(
)
;
uint64_t
remaining
=
0
;
if
(
endTime
<
mStartTime
)
{
MOZ_ASSERT
(
mSanityCheck
)
;
LOG
(
Warning
(
"
[
FuzzyfoxEvent
]
Unusual
!
!
PT
(
%
p
)
endTime
<
mStartTime
"
"
mStartTime
%
"
PRIu64
"
endTime
%
"
PRIu64
"
\
n
"
this
mStartTime
endTime
)
)
;
mSanityCheck
=
true
;
DISPATCH_AND_RETURN
(
)
;
}
uint64_t
actualRunDuration
=
endTime
-
mStartTime
;
LOG
(
Verbose
(
"
[
FuzzyfoxEvent
]
PT
(
%
p
)
mDuration
:
%
"
PRIu32
"
endTime
:
%
"
PRIu64
"
mStartTime
:
%
"
PRIu64
"
actualRunDuration
:
%
"
PRIu64
"
\
n
"
this
mDuration
endTime
mStartTime
actualRunDuration
)
)
;
if
(
actualRunDuration
>
mDuration
)
{
uint64_t
over
=
actualRunDuration
-
mDuration
;
LOG
(
Debug
(
"
[
FuzzyfoxEvent
]
PT
(
%
p
)
Overran
budget
of
%
"
PRIu32
"
by
%
"
PRIu64
"
\
n
"
this
mDuration
over
)
)
;
uint64_t
nextDuration
=
PickDuration
(
)
;
while
(
over
>
nextDuration
)
{
over
-
=
nextDuration
;
nextDuration
=
PickDuration
(
)
;
mTickType
=
mTickType
=
=
eUptick
?
eDowntick
:
eUptick
;
}
remaining
=
nextDuration
-
over
;
}
else
{
remaining
=
mDuration
-
actualRunDuration
;
LOG
(
Debug
(
"
[
FuzzyfoxEvent
]
PT
(
%
p
)
Finishing
budget
of
%
"
PRIu32
"
with
%
"
PRIu64
"
\
n
"
this
mDuration
remaining
)
)
;
}
mSanityCheck
=
false
;
#
ifdef
XP_WIN
Sleep
(
remaining
)
;
#
else
usleep
(
remaining
)
;
#
endif
uint64_t
newTime
=
FloorToGrain
(
ActualTime
(
)
)
;
TimeStamp
newTimeStamp
=
FloorToGrain
(
TimeStamp
:
:
NowUnfuzzed
(
)
)
;
UpdateClocks
(
newTime
newTimeStamp
)
;
mTickType
=
mTickType
=
=
eUptick
?
eDowntick
:
eUptick
;
mStartTime
=
ActualTime
(
)
;
mDuration
=
PickDuration
(
)
;
LOG
(
Verbose
(
"
[
FuzzyfoxEvent
]
PT
(
%
p
)
For
next
time
mDuration
:
%
"
PRIu32
"
mStartTime
:
%
"
PRIu64
"
\
n
"
this
mDuration
mStartTime
)
)
;
DISPATCH_AND_RETURN
(
)
;
}
uint64_t
Fuzzyfox
:
:
ActualTime
(
)
{
return
PR_Now
(
)
;
}
uint64_t
Fuzzyfox
:
:
PickDuration
(
)
{
long
int
rval
=
rand
(
)
;
uint32_t
duration
=
std
:
:
max
(
(
uint32_t
)
1
StaticPrefs
:
:
privacy_fuzzyfox_clockgrainus
(
)
)
;
duration
=
duration
>
=
(
UINT32_MAX
/
2
)
?
(
UINT32_MAX
/
2
)
:
duration
;
return
1
+
(
rval
%
(
duration
*
2
)
)
;
}
void
Fuzzyfox
:
:
UpdateClocks
(
uint64_t
aNewTime
TimeStamp
aNewTimeStamp
)
{
#
ifndef
XP_WIN
LOG
(
Debug
(
"
[
Time
]
New
time
is
%
"
PRIu64
"
(
compare
to
%
"
PRIu64
"
)
and
timestamp
is
%
"
PRIu64
"
(
compare
to
%
"
PRIu64
"
)
\
n
"
aNewTime
ActualTime
(
)
aNewTimeStamp
.
mValue
.
mTimeStamp
TimeStamp
:
:
NowUnfuzzed
(
)
.
mValue
.
mTimeStamp
)
)
;
#
else
LOG
(
Debug
(
"
[
Time
]
New
time
is
%
"
PRIu64
"
(
compare
to
%
"
PRIu64
"
)
\
n
"
aNewTime
ActualTime
(
)
)
)
;
#
endif
if
(
MOZ_UNLIKELY
(
!
mObs
)
)
{
mObs
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
mObs
)
)
{
return
;
}
}
if
(
mTickType
=
=
eDowntick
)
{
mObs
-
>
NotifyObservers
(
nullptr
FUZZYFOX_FIREOUTBOUND_OBSERVER_TOPIC
nullptr
)
;
}
if
(
!
mTimeUpdateWrapper
)
{
mTimeUpdateWrapper
=
do_CreateInstance
(
NS_SUPPORTS_PRINT64_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
mTimeUpdateWrapper
)
)
{
return
;
}
}
mTimeUpdateWrapper
-
>
SetData
(
aNewTime
)
;
mObs
-
>
NotifyObservers
(
mTimeUpdateWrapper
FUZZYFOX_UPDATECLOCK_OBSERVER_TOPIC
nullptr
)
;
TimeStamp
:
:
UpdateFuzzyTime
(
aNewTime
)
;
TimeStamp
:
:
UpdateFuzzyTimeStamp
(
aNewTimeStamp
)
;
}
uint64_t
Fuzzyfox
:
:
FloorToGrain
(
uint64_t
aValue
)
{
return
aValue
-
(
aValue
%
StaticPrefs
:
:
privacy_fuzzyfox_clockgrainus
(
)
)
;
}
TimeStamp
Fuzzyfox
:
:
FloorToGrain
(
TimeStamp
aValue
)
{
#
ifdef
XP_WIN
uint64_t
grain
=
StaticPrefs
:
:
privacy_fuzzyfox_clockgrainus
(
)
;
uint64_t
GTC
=
mt2ms
(
aValue
.
mValue
.
mGTC
)
*
1000
;
uint64_t
QPC
=
mt2ms
(
aValue
.
mValue
.
mQPC
)
*
1000
;
return
TimeStamp
(
TimeStampValue
(
ms2mt
(
(
GTC
-
(
GTC
%
grain
)
)
/
1000
)
ms2mt
(
(
QPC
-
(
QPC
%
grain
)
)
/
1000
)
aValue
.
mValue
.
mHasQPC
true
)
)
;
#
else
return
TimeStamp
(
TimeStampValue
(
true
US_TO_NS
(
FloorToGrain
(
NS_TO_US
(
aValue
.
mValue
.
mTimeStamp
)
)
)
)
)
;
#
endif
}
uint64_t
Fuzzyfox
:
:
CeilToGrain
(
uint64_t
aValue
)
{
return
(
aValue
/
StaticPrefs
:
:
privacy_fuzzyfox_clockgrainus
(
)
)
*
StaticPrefs
:
:
privacy_fuzzyfox_clockgrainus
(
)
;
}
TimeStamp
Fuzzyfox
:
:
CeilToGrain
(
TimeStamp
aValue
)
{
#
ifdef
XP_WIN
uint64_t
grain
=
StaticPrefs
:
:
privacy_fuzzyfox_clockgrainus
(
)
;
uint64_t
GTC
=
mt2ms
(
aValue
.
mValue
.
mGTC
)
*
1000
;
uint64_t
QPC
=
mt2ms
(
aValue
.
mValue
.
mQPC
)
*
1000
;
return
TimeStamp
(
TimeStampValue
(
ms2mt
(
(
(
GTC
/
grain
)
*
grain
)
/
1000
)
ms2mt
(
(
(
QPC
/
grain
)
*
grain
)
/
1000
)
aValue
.
mValue
.
mHasQPC
true
)
)
;
#
else
return
TimeStamp
(
TimeStampValue
(
true
US_TO_NS
(
CeilToGrain
(
NS_TO_US
(
aValue
.
mValue
.
mTimeStamp
)
)
)
)
)
;
#
endif
}
