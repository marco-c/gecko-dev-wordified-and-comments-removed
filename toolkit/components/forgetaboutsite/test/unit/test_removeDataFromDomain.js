const
{
ForgetAboutSite
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ForgetAboutSite
.
sys
.
mjs
"
)
;
const
{
PlacesUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
)
;
ChromeUtils
.
defineESModuleGetters
(
this
{
PlacesTestUtils
:
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
sys
.
mjs
"
}
)
;
const
COOKIE_EXPIRY
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
+
60
;
const
COOKIE_NAME
=
"
testcookie
"
;
const
COOKIE_PATH
=
"
/
"
;
const
LOGIN_USERNAME
=
"
username
"
;
const
LOGIN_PASSWORD
=
"
password
"
;
const
LOGIN_USERNAME_FIELD
=
"
username_field
"
;
const
LOGIN_PASSWORD_FIELD
=
"
password_field
"
;
const
PERMISSION_TYPE
=
"
test
-
perm
"
;
const
PERMISSION_VALUE
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
const
PREFERENCE_NAME
=
"
test
-
pref
"
;
function
add_cookie
(
aDomain
)
{
check_cookie_exists
(
aDomain
false
)
;
Services
.
cookies
.
add
(
aDomain
COOKIE_PATH
COOKIE_NAME
"
"
false
false
false
COOKIE_EXPIRY
{
}
Ci
.
nsICookie
.
SAMESITE_NONE
Ci
.
nsICookie
.
SCHEME_HTTPS
)
;
check_cookie_exists
(
aDomain
true
)
;
}
function
check_cookie_exists
(
aDomain
aExists
)
{
Assert
.
equal
(
aExists
Services
.
cookies
.
cookieExists
(
aDomain
COOKIE_PATH
COOKIE_NAME
{
}
)
)
;
}
function
add_disabled_host
(
aHost
)
{
check_disabled_host
(
aHost
false
)
;
Services
.
logins
.
setLoginSavingEnabled
(
aHost
false
)
;
check_disabled_host
(
aHost
true
)
;
}
function
check_disabled_host
(
aHost
aIsDisabled
)
{
Assert
.
equal
(
!
aIsDisabled
Services
.
logins
.
getLoginSavingEnabled
(
aHost
)
)
;
}
function
add_login
(
aHost
)
{
check_login_exists
(
aHost
false
)
;
let
login
=
Cc
[
"
mozilla
.
org
/
login
-
manager
/
loginInfo
;
1
"
]
.
createInstance
(
Ci
.
nsILoginInfo
)
;
login
.
init
(
aHost
"
"
null
LOGIN_USERNAME
LOGIN_PASSWORD
LOGIN_USERNAME_FIELD
LOGIN_PASSWORD_FIELD
)
;
Services
.
logins
.
addLogin
(
login
)
;
check_login_exists
(
aHost
true
)
;
}
function
check_login_exists
(
aHost
aExists
)
{
let
logins
=
Services
.
logins
.
findLogins
(
aHost
"
"
null
)
;
Assert
.
equal
(
logins
.
length
aExists
?
1
:
0
)
;
}
function
add_permission
(
aURI
)
{
check_permission_exists
(
aURI
false
)
;
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
aURI
{
}
)
;
Services
.
perms
.
addFromPrincipal
(
principal
PERMISSION_TYPE
PERMISSION_VALUE
)
;
check_permission_exists
(
aURI
true
)
;
}
function
check_permission_exists
(
aURI
aExists
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
aURI
{
}
)
;
let
perm
=
Services
.
perms
.
testExactPermissionFromPrincipal
(
principal
PERMISSION_TYPE
)
;
let
checker
=
aExists
?
"
equal
"
:
"
notEqual
"
;
Assert
[
checker
]
(
perm
PERMISSION_VALUE
)
;
}
function
add_preference
(
aURI
)
{
return
new
Promise
(
resolve
=
>
{
let
cp
=
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
;
cp
.
set
(
aURI
.
spec
PREFERENCE_NAME
"
foo
"
null
{
handleCompletion
:
(
)
=
>
resolve
(
)
}
)
;
}
)
;
}
function
preference_exists
(
aURI
)
{
return
new
Promise
(
resolve
=
>
{
let
cp
=
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
;
let
exists
=
false
;
cp
.
getByDomainAndName
(
aURI
.
spec
PREFERENCE_NAME
null
{
handleResult
:
(
)
=
>
(
exists
=
true
)
handleCompletion
:
(
)
=
>
resolve
(
exists
)
}
)
;
}
)
;
}
async
function
test_history_cleared_with_direct_match
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
/
foo
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
Assert
.
ok
(
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
}
async
function
test_history_cleared_with_subdomain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
/
foo
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
Assert
.
ok
(
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
}
async
function
test_history_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
ilovemozilla
.
org
/
foo
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
Assert
.
ok
(
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
Assert
.
ok
(
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
}
async
function
test_history_cleared_base_domain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
/
foo
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
PlacesTestUtils
.
addVisits
(
TEST_URI
)
;
Assert
.
ok
(
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromBaseDomain
(
"
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
PlacesUtils
.
history
.
hasVisits
(
TEST_URI
)
)
;
}
async
function
test_cookie_cleared_with_direct_match
(
)
{
const
TEST_DOMAIN
=
"
mozilla
.
org
"
;
add_cookie
(
TEST_DOMAIN
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_cookie_exists
(
TEST_DOMAIN
false
)
;
}
async
function
test_cookie_cleared_with_subdomain
(
)
{
const
TEST_DOMAIN
=
"
www
.
mozilla
.
org
"
;
add_cookie
(
TEST_DOMAIN
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_cookie_exists
(
TEST_DOMAIN
false
)
;
}
async
function
test_cookie_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_DOMAIN
=
"
ilovemozilla
.
org
"
;
add_cookie
(
TEST_DOMAIN
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_cookie_exists
(
TEST_DOMAIN
true
)
;
}
async
function
test_cookie_cleared_base_domain
(
)
{
const
TEST_DOMAIN
=
"
mozilla
.
org
"
;
add_cookie
(
TEST_DOMAIN
)
;
await
ForgetAboutSite
.
removeDataFromBaseDomain
(
"
mozilla
.
org
"
)
;
check_cookie_exists
(
TEST_DOMAIN
false
)
;
}
async
function
test_login_manager_disabled_hosts_cleared_with_direct_match
(
)
{
const
TEST_HOST
=
"
http
:
/
/
mozilla
.
org
"
;
add_disabled_host
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_disabled_host
(
TEST_HOST
false
)
;
}
async
function
test_login_manager_disabled_hosts_cleared_with_subdomain
(
)
{
const
TEST_HOST
=
"
http
:
/
/
www
.
mozilla
.
org
"
;
add_disabled_host
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_disabled_host
(
TEST_HOST
false
)
;
}
async
function
test_login_manager_disabled_hosts_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_HOST
=
"
http
:
/
/
ilovemozilla
.
org
"
;
add_disabled_host
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_disabled_host
(
TEST_HOST
true
)
;
Services
.
logins
.
setLoginSavingEnabled
(
TEST_HOST
true
)
;
check_disabled_host
(
TEST_HOST
false
)
;
}
async
function
test_login_manager_logins_cleared_with_direct_match
(
)
{
const
TEST_HOST
=
"
http
:
/
/
mozilla
.
org
"
;
add_login
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_login_exists
(
TEST_HOST
true
)
;
}
async
function
test_login_manager_logins_cleared_with_subdomain
(
)
{
const
TEST_HOST
=
"
http
:
/
/
www
.
mozilla
.
org
"
;
add_login
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_login_exists
(
TEST_HOST
true
)
;
}
async
function
test_login_manager_logins_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_HOST
=
"
http
:
/
/
ilovemozilla
.
org
"
;
add_login
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_login_exists
(
TEST_HOST
true
)
;
Services
.
logins
.
removeAllUserFacingLogins
(
)
;
check_login_exists
(
TEST_HOST
false
)
;
}
async
function
test_login_manager_disabled_hosts_cleared_base_domain
(
)
{
const
TEST_HOST
=
"
http
:
/
/
mozilla
.
org
"
;
add_disabled_host
(
TEST_HOST
)
;
await
ForgetAboutSite
.
removeDataFromBaseDomain
(
"
mozilla
.
org
"
)
;
check_disabled_host
(
TEST_HOST
false
)
;
}
async
function
test_permission_manager_cleared_with_direct_match
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
"
)
;
add_permission
(
TEST_URI
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_permission_exists
(
TEST_URI
false
)
;
}
async
function
test_permission_manager_cleared_with_subdomain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
"
)
;
add_permission
(
TEST_URI
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_permission_exists
(
TEST_URI
false
)
;
}
async
function
test_permission_manager_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
ilovemozilla
.
org
"
)
;
add_permission
(
TEST_URI
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
check_permission_exists
(
TEST_URI
true
)
;
Services
.
perms
.
removeAll
(
)
;
check_permission_exists
(
TEST_URI
false
)
;
}
async
function
test_permission_manager_cleared_base_domain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
"
)
;
add_permission
(
TEST_URI
)
;
await
ForgetAboutSite
.
removeDataFromBaseDomain
(
"
mozilla
.
org
"
)
;
check_permission_exists
(
TEST_URI
false
)
;
}
async
function
test_content_preferences_cleared_with_direct_match
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
await
add_preference
(
TEST_URI
)
;
Assert
.
ok
(
await
preference_exists
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
}
async
function
test_content_preferences_cleared_with_subdomain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
www
.
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
await
add_preference
(
TEST_URI
)
;
Assert
.
ok
(
await
preference_exists
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
}
async
function
test_content_preferences_not_cleared_with_uri_contains_domain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
ilovemozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
await
add_preference
(
TEST_URI
)
;
Assert
.
ok
(
await
preference_exists
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
Assert
.
ok
(
await
preference_exists
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromDomain
(
"
ilovemozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
}
async
function
test_content_preferences_cleared_base_domain
(
)
{
const
TEST_URI
=
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
await
add_preference
(
TEST_URI
)
;
Assert
.
ok
(
await
preference_exists
(
TEST_URI
)
)
;
await
ForgetAboutSite
.
removeDataFromBaseDomain
(
"
mozilla
.
org
"
)
;
Assert
.
equal
(
false
await
preference_exists
(
TEST_URI
)
)
;
}
async
function
test_push_cleared
(
)
{
return
helper_push_cleared
(
false
)
;
}
async
function
test_push_cleared_base_domain
(
)
{
return
helper_push_cleared
(
true
)
;
}
async
function
helper_push_cleared
(
aBaseDomainTest
)
{
let
ps
;
try
{
ps
=
Cc
[
"
mozilla
.
org
/
push
/
Service
;
1
"
]
.
getService
(
Ci
.
nsIPushService
)
;
}
catch
(
e
)
{
return
;
}
Services
.
prefs
.
setBoolPref
(
"
dom
.
push
.
connection
.
enabled
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
dom
.
push
.
enabled
"
true
)
;
let
pushImpl
=
ps
.
wrappedJSObject
;
if
(
typeof
pushImpl
!
=
"
object
"
|
|
!
pushImpl
|
|
!
(
"
service
"
in
pushImpl
)
)
{
info
(
"
Can
'
t
test
with
this
push
service
implementation
"
)
;
return
;
}
await
pushImpl
.
service
.
uninit
?
.
(
)
;
let
wasCleared
=
false
;
pushImpl
.
service
=
{
async
clear
(
{
domain
}
=
{
}
)
{
Assert
.
equal
(
domain
"
mozilla
.
org
"
"
Should
pass
domain
to
clear
to
push
service
"
)
;
wasCleared
=
true
;
}
}
;
Services
.
prefs
.
setBoolPref
(
"
dom
.
push
.
enabled
"
true
)
;
if
(
aBaseDomainTest
)
{
await
ForgetAboutSite
.
removeDataFromBaseDomain
(
"
mozilla
.
org
"
)
;
}
else
{
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
}
Assert
.
ok
(
wasCleared
"
Should
have
cleared
push
data
"
)
;
}
function
test_storage_cleared
(
)
{
return
helper_storage_cleared
(
false
)
;
}
function
test_storage_cleared_base_domain
(
)
{
return
helper_storage_cleared
(
true
)
;
}
async
function
helper_storage_cleared
(
aBaseDomainTest
)
{
function
getStorageForURI
(
aURI
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
aURI
{
}
)
;
return
Services
.
domStorageManager
.
createStorage
(
null
principal
principal
"
"
)
;
}
Services
.
prefs
.
setBoolPref
(
"
dom
.
storage
.
client_validation
"
false
)
;
let
s
=
[
getStorageForURI
(
Services
.
io
.
newURI
(
"
http
:
/
/
mozilla
.
org
"
)
)
getStorageForURI
(
Services
.
io
.
newURI
(
"
http
:
/
/
my
.
mozilla
.
org
"
)
)
getStorageForURI
(
Services
.
io
.
newURI
(
"
http
:
/
/
ilovemozilla
.
org
"
)
)
]
;
for
(
let
i
=
0
;
i
<
s
.
length
;
+
+
i
)
{
let
storage
=
s
[
i
]
;
storage
.
setItem
(
"
test
"
"
value
"
+
i
)
;
Assert
.
equal
(
storage
.
length
1
)
;
Assert
.
equal
(
storage
.
key
(
0
)
"
test
"
)
;
Assert
.
equal
(
storage
.
getItem
(
"
test
"
)
"
value
"
+
i
)
;
}
if
(
aBaseDomainTest
)
{
await
ForgetAboutSite
.
removeDataFromBaseDomain
(
"
mozilla
.
org
"
)
;
}
else
{
await
ForgetAboutSite
.
removeDataFromDomain
(
"
mozilla
.
org
"
)
;
}
Assert
.
equal
(
s
[
0
]
.
getItem
(
"
test
"
)
null
)
;
Assert
.
equal
(
s
[
0
]
.
length
0
)
;
Assert
.
equal
(
s
[
1
]
.
getItem
(
"
test
"
)
null
)
;
Assert
.
equal
(
s
[
1
]
.
length
0
)
;
Assert
.
equal
(
s
[
2
]
.
getItem
(
"
test
"
)
"
value2
"
)
;
Assert
.
equal
(
s
[
2
]
.
length
1
)
;
}
var
tests
=
[
test_history_cleared_with_direct_match
test_history_cleared_with_subdomain
test_history_not_cleared_with_uri_contains_domain
test_history_cleared_base_domain
test_cookie_cleared_with_direct_match
test_cookie_cleared_with_subdomain
test_cookie_not_cleared_with_uri_contains_domain
test_cookie_cleared_base_domain
test_login_manager_disabled_hosts_cleared_with_direct_match
test_login_manager_disabled_hosts_cleared_with_subdomain
test_login_manager_disabled_hosts_not_cleared_with_uri_contains_domain
test_login_manager_logins_cleared_with_direct_match
test_login_manager_logins_cleared_with_subdomain
test_login_manager_logins_not_cleared_with_uri_contains_domain
test_login_manager_disabled_hosts_cleared_base_domain
test_permission_manager_cleared_with_direct_match
test_permission_manager_cleared_with_subdomain
test_permission_manager_not_cleared_with_uri_contains_domain
test_permission_manager_cleared_base_domain
test_content_preferences_cleared_with_direct_match
test_content_preferences_cleared_with_subdomain
test_content_preferences_not_cleared_with_uri_contains_domain
test_content_preferences_cleared_base_domain
test_push_cleared
test_push_cleared_base_domain
test_storage_cleared
test_storage_cleared_base_domain
]
;
function
run_test
(
)
{
for
(
let
i
=
0
;
i
<
tests
.
length
;
i
+
+
)
{
add_task
(
tests
[
i
]
)
;
}
run_next_test
(
)
;
}
