"
use
strict
"
;
add_task
(
async
function
sameCaseAsMatch
(
)
{
await
runTest
(
"
moz
"
)
;
}
)
;
add_task
(
async
function
differentCaseFromMatch
(
)
{
await
runTest
(
"
MOZ
"
)
;
}
)
;
async
function
runTest
(
searchStr
)
{
let
matches
=
[
"
mozilla
.
org
"
"
example
.
com
"
]
;
let
result
=
new
AutoCompleteResultBase
(
matches
)
;
result
.
defaultIndex
=
0
;
let
search
=
new
AutoCompleteSearchBase
(
"
search
"
result
)
;
registerAutoCompleteSearch
(
search
)
;
let
input
=
new
AutoCompleteInputBase
(
[
search
.
name
]
)
;
input
.
completeSelectedIndex
=
true
;
input
.
completeDefaultIndex
=
true
;
input
.
textValue
=
searchStr
;
input
.
selectTextRange
(
searchStr
.
length
searchStr
.
length
)
;
Assert
.
equal
(
input
.
selectionStart
searchStr
.
length
"
Selection
should
start
at
the
end
of
the
input
"
)
;
Assert
.
equal
(
input
.
selectionEnd
searchStr
.
length
"
Selection
should
end
at
the
end
of
the
input
"
)
;
let
controller
=
Cc
[
"
mozilla
.
org
/
autocomplete
/
controller
;
1
"
]
.
createInstance
(
Ci
.
nsIAutoCompleteController
)
;
controller
.
input
=
input
;
input
.
controller
=
controller
;
await
new
Promise
(
resolve
=
>
{
controller
.
startSearch
(
searchStr
)
;
input
.
onSearchComplete
=
(
)
=
>
{
let
expectedValue
=
searchStr
+
matches
[
0
]
.
substr
(
searchStr
.
length
)
;
Assert
.
equal
(
input
.
textValue
expectedValue
"
Should
have
autofilled
"
)
;
Assert
.
equal
(
input
.
selectionStart
searchStr
.
length
"
Selection
should
start
after
search
string
"
)
;
Assert
.
equal
(
input
.
selectionEnd
expectedValue
.
length
"
Selection
should
end
at
the
end
of
the
input
"
)
;
resolve
(
)
;
}
;
}
)
;
controller
.
handleKeyNavigation
(
Ci
.
nsIDOMKeyEvent
.
DOM_VK_DOWN
)
;
let
expectedValue
=
matches
[
1
]
;
Assert
.
equal
(
input
.
textValue
expectedValue
"
Should
have
filled
second
match
"
)
;
Assert
.
equal
(
input
.
selectionStart
expectedValue
.
length
"
Selection
should
start
at
the
end
of
the
input
"
)
;
Assert
.
equal
(
input
.
selectionEnd
expectedValue
.
length
"
Selection
should
end
at
the
end
of
the
input
"
)
;
controller
.
handleKeyNavigation
(
Ci
.
nsIDOMKeyEvent
.
DOM_VK_UP
)
;
expectedValue
=
searchStr
+
matches
[
0
]
.
substr
(
searchStr
.
length
)
;
Assert
.
equal
(
input
.
textValue
expectedValue
"
Should
have
filled
first
match
again
"
)
;
Assert
.
equal
(
input
.
selectionStart
searchStr
.
length
"
Selection
should
start
after
search
string
again
"
)
;
Assert
.
equal
(
input
.
selectionEnd
expectedValue
.
length
"
Selection
should
end
at
the
end
of
the
input
again
"
)
;
}
