ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FileTestUtils
"
"
resource
:
/
/
testing
-
common
/
FileTestUtils
.
jsm
"
)
;
const
BackgroundFileSaverOutputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
network
/
background
-
file
-
saver
;
1
?
mode
=
outputstream
"
"
nsIBackgroundFileSaver
"
)
;
const
StringInputStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
"
nsIStringInputStream
"
"
setData
"
)
;
const
TEST_FILE_NAME_1
=
"
test
-
backgroundfilesaver
-
1
.
txt
"
;
const
gAppRep
=
Cc
[
"
mozilla
.
org
/
reputationservice
/
application
-
reputation
-
service
;
1
"
]
.
getService
(
Ci
.
nsIApplicationReputationService
)
;
var
gStillRunning
=
true
;
var
gTables
=
{
}
;
var
gHttpServer
=
null
;
const
appRepURLPref
=
"
browser
.
safebrowsing
.
downloads
.
remote
.
url
"
;
const
remoteEnabledPref
=
"
browser
.
safebrowsing
.
downloads
.
remote
.
enabled
"
;
function
readFileToString
(
aFilename
)
{
let
f
=
do_get_file
(
aFilename
)
;
let
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
f
-
1
0
0
)
;
let
buf
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
return
buf
;
}
function
promiseSaverComplete
(
aSaver
aOnTargetChangeFn
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
aSaver
.
observer
=
{
onTargetChange
:
function
BFSO_onSaveComplete
(
unused
aTarget
)
{
if
(
aOnTargetChangeFn
)
{
aOnTargetChangeFn
(
aTarget
)
;
}
}
onSaveComplete
:
function
BFSO_onSaveComplete
(
unused
aStatus
)
{
if
(
Components
.
isSuccessCode
(
aStatus
)
)
{
resolve
(
)
;
}
else
{
reject
(
new
Components
.
Exception
(
"
Saver
failed
.
"
aStatus
)
)
;
}
}
}
;
}
)
;
}
function
promiseCopyToSaver
(
aSourceString
aSaverOutputStream
aCloseWhenDone
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
inputStream
=
new
StringInputStream
(
aSourceString
aSourceString
.
length
)
;
let
copier
=
Cc
[
"
mozilla
.
org
/
network
/
async
-
stream
-
copier
;
1
"
]
.
createInstance
(
Ci
.
nsIAsyncStreamCopier
)
;
copier
.
init
(
inputStream
aSaverOutputStream
null
false
true
0x8000
true
aCloseWhenDone
)
;
copier
.
asyncCopy
(
{
onStartRequest
(
)
{
}
onStopRequest
(
aRequest
aContext
aStatusCode
)
{
if
(
Components
.
isSuccessCode
(
aStatusCode
)
)
{
resolve
(
)
;
}
else
{
reject
(
new
Components
.
Exception
(
aStatusCode
)
)
;
}
}
}
null
)
;
}
)
;
}
function
registerTableUpdate
(
aTable
aFilename
)
{
if
(
!
(
aTable
in
gTables
)
)
{
gTables
[
aTable
]
=
[
]
;
}
let
numChunks
=
gTables
[
aTable
]
.
length
+
1
;
let
redirectPath
=
"
/
"
+
aTable
+
"
-
"
+
numChunks
;
let
redirectUrl
=
"
localhost
:
4444
"
+
redirectPath
;
gTables
[
aTable
]
.
push
(
redirectUrl
)
;
gHttpServer
.
registerPathHandler
(
redirectPath
function
(
request
response
)
{
info
(
"
Mock
safebrowsing
server
handling
request
for
"
+
redirectPath
)
;
let
contents
=
readFileToString
(
aFilename
)
;
info
(
"
Length
of
"
+
aFilename
+
"
:
"
+
contents
.
length
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
vnd
.
google
.
safebrowsing
-
update
"
false
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
bodyOutputStream
.
write
(
contents
contents
.
length
)
;
}
)
;
}
add_task
(
async
function
test_setup
(
)
{
do_timeout
(
10
*
60
*
1000
function
(
)
{
if
(
gStillRunning
)
{
do_throw
(
"
Test
timed
out
.
"
)
;
}
}
)
;
Services
.
prefs
.
setCharPref
(
appRepURLPref
"
http
:
/
/
localhost
:
4444
/
download
"
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
safebrowsing
.
malware
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
safebrowsing
.
downloads
.
enabled
"
true
)
;
Services
.
prefs
.
setCharPref
(
"
urlclassifier
.
downloadBlockTable
"
"
goog
-
badbinurl
-
shavar
"
)
;
Services
.
prefs
.
setCharPref
(
"
urlclassifier
.
downloadAllowTable
"
"
goog
-
downloadwhite
-
digest256
"
)
;
let
originalReqLocales
=
Services
.
locale
.
requestedLocales
;
Services
.
locale
.
requestedLocales
=
[
"
en
-
US
"
]
;
registerCleanupFunction
(
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
browser
.
safebrowsing
.
malware
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
browser
.
safebrowsing
.
downloads
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
urlclassifier
.
downloadBlockTable
"
)
;
Services
.
prefs
.
clearUserPref
(
"
urlclassifier
.
downloadAllowTable
"
)
;
Services
.
locale
.
requestedLocales
=
originalReqLocales
;
}
)
;
gHttpServer
=
new
HttpServer
(
)
;
gHttpServer
.
registerDirectory
(
"
/
"
do_get_cwd
(
)
)
;
function
createVerdict
(
aShouldBlock
)
{
let
blob
=
String
.
fromCharCode
(
parseInt
(
0x08
16
)
)
;
if
(
aShouldBlock
)
{
blob
+
=
String
.
fromCharCode
(
parseInt
(
0x01
16
)
)
;
}
else
{
blob
+
=
String
.
fromCharCode
(
parseInt
(
0x00
16
)
)
;
}
return
blob
;
}
gHttpServer
.
registerPathHandler
(
"
/
throw
"
function
(
request
response
)
{
do_throw
(
"
We
shouldn
'
t
be
getting
here
"
)
;
}
)
;
gHttpServer
.
registerPathHandler
(
"
/
download
"
function
(
request
response
)
{
info
(
"
Querying
remote
server
for
verdict
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
octet
-
stream
"
false
)
;
let
buf
=
NetUtil
.
readInputStreamToString
(
request
.
bodyInputStream
request
.
bodyInputStream
.
available
(
)
)
;
info
(
"
Request
length
:
"
+
buf
.
length
)
;
let
blob
=
"
this
is
not
a
serialized
protocol
buffer
(
the
length
doesn
'
t
match
our
hard
-
coded
values
)
"
;
if
(
buf
.
length
=
=
67
)
{
blob
=
createVerdict
(
true
)
;
}
else
if
(
buf
.
length
=
=
73
)
{
blob
=
createVerdict
(
false
)
;
}
response
.
bodyOutputStream
.
write
(
blob
blob
.
length
)
;
}
)
;
gHttpServer
.
start
(
4444
)
;
registerCleanupFunction
(
function
(
)
{
return
(
async
function
(
)
{
await
new
Promise
(
resolve
=
>
{
gHttpServer
.
stop
(
resolve
)
;
}
)
;
}
)
(
)
;
}
)
;
}
)
;
function
processUpdateRequest
(
)
{
let
response
=
"
n
:
1000
\
n
"
;
for
(
let
table
in
gTables
)
{
response
+
=
"
i
:
"
+
table
+
"
\
n
"
;
for
(
let
i
=
0
;
i
<
gTables
[
table
]
.
length
;
+
+
i
)
{
response
+
=
"
u
:
"
+
gTables
[
table
]
[
i
]
+
"
\
n
"
;
}
}
info
(
"
Returning
update
response
:
"
+
response
)
;
return
response
;
}
function
waitForUpdates
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
gHttpServer
.
registerPathHandler
(
"
/
downloads
"
function
(
request
response
)
{
let
blob
=
processUpdateRequest
(
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
vnd
.
google
.
safebrowsing
-
update
"
false
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
bodyOutputStream
.
write
(
blob
blob
.
length
)
;
}
)
;
let
streamUpdater
=
Cc
[
"
mozilla
.
org
/
url
-
classifier
/
streamupdater
;
1
"
]
.
getService
(
Ci
.
nsIUrlClassifierStreamUpdater
)
;
registerTableUpdate
(
"
goog
-
downloadwhite
-
digest256
"
"
data
/
digest
.
chunk
"
)
;
function
updateSuccess
(
aEvent
)
{
Assert
.
equal
(
"
1000
"
aEvent
)
;
info
(
"
All
data
processed
"
)
;
resolve
(
true
)
;
}
function
handleError
(
aEvent
)
{
do_throw
(
"
We
didn
'
t
download
or
update
correctly
:
"
+
aEvent
)
;
reject
(
)
;
}
streamUpdater
.
downloadUpdates
(
"
goog
-
downloadwhite
-
digest256
"
"
goog
-
downloadwhite
-
digest256
;
\
n
"
true
"
http
:
/
/
localhost
:
4444
/
downloads
"
updateSuccess
handleError
handleError
)
;
}
)
;
}
function
promiseQueryReputation
(
query
expected
)
{
return
new
Promise
(
resolve
=
>
{
function
onComplete
(
aShouldBlock
aStatus
)
{
Assert
.
equal
(
Cr
.
NS_OK
aStatus
)
;
check_telemetry
(
expected
)
;
resolve
(
true
)
;
}
gAppRep
.
queryReputation
(
query
onComplete
)
;
}
)
;
}
add_task
(
async
function
(
)
{
await
waitForUpdates
(
)
;
}
)
;
add_task
(
async
function
test_signature_whitelists
(
)
{
Services
.
prefs
.
setBoolPref
(
remoteEnabledPref
true
)
;
Services
.
prefs
.
setCharPref
(
appRepURLPref
"
http
:
/
/
localhost
:
4444
/
throw
"
)
;
let
expected
=
get_telemetry_snapshot
(
)
;
add_telemetry_count
(
expected
.
local
NO_LIST
1
)
;
add_telemetry_count
(
expected
.
reason
NonBinaryFile
1
)
;
let
destFile
=
FileTestUtils
.
getTempFile
(
TEST_FILE_NAME_1
)
;
let
data
=
readFileToString
(
"
data
/
signed_win
.
exe
"
)
;
let
saver
=
new
BackgroundFileSaverOutputStream
(
)
;
let
completionPromise
=
promiseSaverComplete
(
saver
)
;
saver
.
enableSignatureInfo
(
)
;
saver
.
setTarget
(
destFile
false
)
;
await
promiseCopyToSaver
(
data
saver
true
)
;
saver
.
finish
(
Cr
.
NS_OK
)
;
await
completionPromise
;
destFile
.
remove
(
false
)
;
await
promiseQueryReputation
(
{
sourceURI
:
createURI
(
"
http
:
/
/
evil
.
com
"
)
signatureInfo
:
saver
.
signatureInfo
fileSize
:
12
}
expected
)
;
}
)
;
add_task
(
async
function
test_blocked_binary
(
)
{
Services
.
prefs
.
setBoolPref
(
remoteEnabledPref
true
)
;
Services
.
prefs
.
setCharPref
(
appRepURLPref
"
http
:
/
/
localhost
:
4444
/
download
"
)
;
let
expected
=
get_telemetry_snapshot
(
)
;
expected
.
shouldBlock
+
+
;
add_telemetry_count
(
expected
.
local
NO_LIST
1
)
;
add_telemetry_count
(
expected
.
reason
VerdictDangerous
1
)
;
await
promiseQueryReputation
(
{
sourceURI
:
createURI
(
"
http
:
/
/
evil
.
com
"
)
suggestedFileName
:
"
noop
.
bat
"
fileSize
:
12
}
expected
)
;
}
)
;
add_task
(
async
function
test_non_binary
(
)
{
Services
.
prefs
.
setBoolPref
(
remoteEnabledPref
true
)
;
Services
.
prefs
.
setCharPref
(
appRepURLPref
"
http
:
/
/
localhost
:
4444
/
throw
"
)
;
let
expected
=
get_telemetry_snapshot
(
)
;
add_telemetry_count
(
expected
.
local
NO_LIST
1
)
;
add_telemetry_count
(
expected
.
reason
NonBinaryFile
1
)
;
await
promiseQueryReputation
(
{
sourceURI
:
createURI
(
"
http
:
/
/
evil
.
com
"
)
suggestedFileName
:
"
noop
.
txt
"
fileSize
:
12
}
expected
)
;
}
)
;
add_task
(
async
function
test_good_binary
(
)
{
Services
.
prefs
.
setBoolPref
(
remoteEnabledPref
true
)
;
Services
.
prefs
.
setCharPref
(
appRepURLPref
"
http
:
/
/
localhost
:
4444
/
download
"
)
;
let
expected
=
get_telemetry_snapshot
(
)
;
add_telemetry_count
(
expected
.
local
NO_LIST
1
)
;
add_telemetry_count
(
expected
.
reason
VerdictSafe
1
)
;
await
promiseQueryReputation
(
{
sourceURI
:
createURI
(
"
http
:
/
/
mozilla
.
com
"
)
suggestedFileName
:
"
noop
.
bat
"
fileSize
:
12
}
expected
)
;
}
)
;
add_task
(
async
function
test_disabled
(
)
{
Services
.
prefs
.
setBoolPref
(
remoteEnabledPref
false
)
;
Services
.
prefs
.
setCharPref
(
appRepURLPref
"
http
:
/
/
localhost
:
4444
/
throw
"
)
;
let
expected
=
get_telemetry_snapshot
(
)
;
add_telemetry_count
(
expected
.
local
NO_LIST
1
)
;
add_telemetry_count
(
expected
.
reason
RemoteLookupDisabled
1
)
;
let
query
=
{
sourceURI
:
createURI
(
"
http
:
/
/
example
.
com
"
)
suggestedFileName
:
"
noop
.
bat
"
fileSize
:
12
}
;
await
new
Promise
(
resolve
=
>
{
gAppRep
.
queryReputation
(
query
function
onComplete
(
aShouldBlock
aStatus
)
{
Assert
.
equal
(
Cr
.
NS_ERROR_NOT_AVAILABLE
aStatus
)
;
Assert
.
ok
(
!
aShouldBlock
)
;
check_telemetry
(
expected
)
;
resolve
(
true
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_disabled_through_lists
(
)
{
Services
.
prefs
.
setBoolPref
(
remoteEnabledPref
false
)
;
Services
.
prefs
.
setCharPref
(
appRepURLPref
"
http
:
/
/
localhost
:
4444
/
download
"
)
;
Services
.
prefs
.
setCharPref
(
"
urlclassifier
.
downloadBlockTable
"
"
"
)
;
let
expected
=
get_telemetry_snapshot
(
)
;
add_telemetry_count
(
expected
.
local
NO_LIST
1
)
;
add_telemetry_count
(
expected
.
reason
RemoteLookupDisabled
1
)
;
let
query
=
{
sourceURI
:
createURI
(
"
http
:
/
/
example
.
com
"
)
suggestedFileName
:
"
noop
.
bat
"
fileSize
:
12
}
;
await
new
Promise
(
resolve
=
>
{
gAppRep
.
queryReputation
(
query
function
onComplete
(
aShouldBlock
aStatus
)
{
Assert
.
equal
(
Cr
.
NS_ERROR_NOT_AVAILABLE
aStatus
)
;
Assert
.
ok
(
!
aShouldBlock
)
;
check_telemetry
(
expected
)
;
resolve
(
true
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_teardown
(
)
{
gStillRunning
=
false
;
}
)
;
