#
include
"
ApplicationReputation
.
h
"
#
include
"
chrome
/
common
/
safe_browsing
/
csd
.
pb
.
h
"
#
include
"
nsIArray
.
h
"
#
include
"
nsIApplicationReputation
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIStringStream
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIUrlClassifierDBService
.
h
"
#
include
"
nsIX509Cert
.
h
"
#
include
"
nsIX509CertDB
.
h
"
#
include
"
nsIX509CertList
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
LoadContext
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsIRedirectHistoryEntry
.
h
"
using
mozilla
:
:
ArrayLength
;
using
mozilla
:
:
BasePrincipal
;
using
mozilla
:
:
OriginAttributes
;
using
mozilla
:
:
Preferences
;
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
Telemetry
:
:
Accumulate
;
using
mozilla
:
:
intl
:
:
LocaleService
;
using
safe_browsing
:
:
ClientDownloadRequest
;
using
safe_browsing
:
:
ClientDownloadRequest_CertificateChain
;
using
safe_browsing
:
:
ClientDownloadRequest_Resource
;
using
safe_browsing
:
:
ClientDownloadRequest_SignatureInfo
;
#
define
PREF_SB_APP_REP_URL
"
browser
.
safebrowsing
.
downloads
.
remote
.
url
"
#
define
PREF_SB_MALWARE_ENABLED
"
browser
.
safebrowsing
.
malware
.
enabled
"
#
define
PREF_SB_DOWNLOADS_ENABLED
"
browser
.
safebrowsing
.
downloads
.
enabled
"
#
define
PREF_SB_DOWNLOADS_REMOTE_ENABLED
"
browser
.
safebrowsing
.
downloads
.
remote
.
enabled
"
#
define
PREF_SB_DOWNLOADS_REMOTE_TIMEOUT
"
browser
.
safebrowsing
.
downloads
.
remote
.
timeout_ms
"
#
define
PREF_DOWNLOAD_BLOCK_TABLE
"
urlclassifier
.
downloadBlockTable
"
#
define
PREF_DOWNLOAD_ALLOW_TABLE
"
urlclassifier
.
downloadAllowTable
"
#
define
PREF_BLOCK_DANGEROUS
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_dangerous
"
#
define
PREF_BLOCK_DANGEROUS_HOST
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_dangerous_host
"
#
define
PREF_BLOCK_POTENTIALLY_UNWANTED
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_potentially_unwanted
"
#
define
PREF_BLOCK_UNCOMMON
"
browser
.
safebrowsing
.
downloads
.
remote
.
block_uncommon
"
mozilla
:
:
LazyLogModule
ApplicationReputationService
:
:
prlog
(
"
ApplicationReputation
"
)
;
#
define
LOG
(
args
)
MOZ_LOG
(
ApplicationReputationService
:
:
prlog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
ApplicationReputationService
:
:
prlog
mozilla
:
:
LogLevel
:
:
Debug
)
class
PendingDBLookup
;
class
PendingLookup
final
:
public
nsIStreamListener
public
nsITimerCallback
public
nsIObserver
public
nsSupportsWeakReference
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSIOBSERVER
PendingLookup
(
nsIApplicationReputationQuery
*
aQuery
nsIApplicationReputationCallback
*
aCallback
)
;
nsresult
StartLookup
(
)
;
private
:
~
PendingLookup
(
)
;
friend
class
PendingDBLookup
;
enum
SERVER_RESPONSE_TYPES
{
SERVER_RESPONSE_VALID
=
0
SERVER_RESPONSE_FAILED
=
1
SERVER_RESPONSE_INVALID
=
2
}
;
uint32_t
mBlocklistCount
;
uint32_t
mAllowlistCount
;
nsCOMPtr
<
nsIApplicationReputationQuery
>
mQuery
;
nsCOMPtr
<
nsIApplicationReputationCallback
>
mCallback
;
nsTArray
<
nsCString
>
mAllowlistSpecs
;
nsTArray
<
nsCString
>
mAnylistSpecs
;
TimeStamp
mStartTime
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsITimer
>
mTimeoutTimer
;
ClientDownloadRequest
mRequest
;
nsCString
mResponse
;
bool
IsBinaryFile
(
)
;
ClientDownloadRequest
:
:
DownloadType
GetDownloadType
(
const
nsACString
&
aFilename
)
;
nsresult
OnComplete
(
bool
shouldBlock
nsresult
rv
uint32_t
verdict
=
nsIApplicationReputationService
:
:
VERDICT_SAFE
)
;
nsresult
OnStopRequestInternal
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aResult
bool
*
aShouldBlock
uint32_t
*
aVerdict
)
;
nsresult
GetSpecHash
(
nsACString
&
aSpec
nsACString
&
hexEncodedHash
)
;
nsresult
GetStrippedSpec
(
nsIURI
*
aUri
nsACString
&
spec
)
;
nsCString
EscapeCertificateAttribute
(
const
nsACString
&
aAttribute
)
;
nsCString
EscapeFingerprint
(
const
nsACString
&
aAttribute
)
;
nsresult
GenerateWhitelistStringsForPair
(
nsIX509Cert
*
certificate
nsIX509Cert
*
issuer
)
;
nsresult
GenerateWhitelistStringsForChain
(
const
ClientDownloadRequest_CertificateChain
&
aChain
)
;
nsresult
GenerateWhitelistStrings
(
)
;
nsresult
ParseCertificates
(
nsIArray
*
aSigArray
)
;
nsresult
AddRedirects
(
nsIArray
*
aRedirects
)
;
nsresult
DoLookupInternal
(
)
;
nsresult
LookupNext
(
)
;
nsresult
SendRemoteQuery
(
)
;
nsresult
SendRemoteQueryInternal
(
)
;
}
;
class
PendingDBLookup
final
:
public
nsIUrlClassifierCallback
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIURLCLASSIFIERCALLBACK
explicit
PendingDBLookup
(
PendingLookup
*
aPendingLookup
)
;
nsresult
LookupSpec
(
const
nsACString
&
aSpec
bool
aAllowlistOnly
)
;
private
:
~
PendingDBLookup
(
)
;
enum
LIST_TYPES
{
ALLOW_LIST
=
0
BLOCK_LIST
=
1
NO_LIST
=
2
}
;
nsCString
mSpec
;
bool
mAllowlistOnly
;
RefPtr
<
PendingLookup
>
mPendingLookup
;
nsresult
LookupSpecInternal
(
const
nsACString
&
aSpec
)
;
}
;
NS_IMPL_ISUPPORTS
(
PendingDBLookup
nsIUrlClassifierCallback
)
PendingDBLookup
:
:
PendingDBLookup
(
PendingLookup
*
aPendingLookup
)
:
mAllowlistOnly
(
false
)
mPendingLookup
(
aPendingLookup
)
{
LOG
(
(
"
Created
pending
DB
lookup
[
this
=
%
p
]
"
this
)
)
;
}
PendingDBLookup
:
:
~
PendingDBLookup
(
)
{
LOG
(
(
"
Destroying
pending
DB
lookup
[
this
=
%
p
]
"
this
)
)
;
mPendingLookup
=
nullptr
;
}
nsresult
PendingDBLookup
:
:
LookupSpec
(
const
nsACString
&
aSpec
bool
aAllowlistOnly
)
{
LOG
(
(
"
Checking
principal
%
s
[
this
=
%
p
]
"
aSpec
.
Data
(
)
this
)
)
;
mSpec
=
aSpec
;
mAllowlistOnly
=
aAllowlistOnly
;
nsresult
rv
=
LookupSpecInternal
(
aSpec
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsAutoCString
errorName
;
mozilla
:
:
GetErrorName
(
rv
errorName
)
;
LOG
(
(
"
Error
in
LookupSpecInternal
(
)
[
rv
=
%
s
this
=
%
p
]
"
errorName
.
get
(
)
this
)
)
;
return
mPendingLookup
-
>
LookupNext
(
)
;
}
return
rv
;
}
nsresult
PendingDBLookup
:
:
LookupSpecInternal
(
const
nsACString
&
aSpec
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
nsCOMPtr
<
nsIIOService
>
ios
=
do_GetService
(
NS_IOSERVICE_CONTRACTID
&
rv
)
;
rv
=
ios
-
>
NewURI
(
aSpec
nullptr
nullptr
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
uri
attrs
)
;
if
(
!
principal
)
{
return
NS_ERROR_FAILURE
;
}
LOG
(
(
"
Checking
DB
service
for
principal
%
s
[
this
=
%
p
]
"
mSpec
.
get
(
)
this
)
)
;
nsCOMPtr
<
nsIUrlClassifierDBService
>
dbService
=
do_GetService
(
NS_URLCLASSIFIERDBSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
tables
;
nsAutoCString
allowlist
;
Preferences
:
:
GetCString
(
PREF_DOWNLOAD_ALLOW_TABLE
allowlist
)
;
if
(
!
allowlist
.
IsEmpty
(
)
)
{
tables
.
Append
(
allowlist
)
;
}
nsAutoCString
blocklist
;
Preferences
:
:
GetCString
(
PREF_DOWNLOAD_BLOCK_TABLE
blocklist
)
;
if
(
!
mAllowlistOnly
&
&
!
blocklist
.
IsEmpty
(
)
)
{
tables
.
Append
(
'
'
)
;
tables
.
Append
(
blocklist
)
;
}
return
dbService
-
>
Lookup
(
principal
tables
this
)
;
}
NS_IMETHODIMP
PendingDBLookup
:
:
HandleEvent
(
const
nsACString
&
tables
)
{
nsAutoCString
blockList
;
Preferences
:
:
GetCString
(
PREF_DOWNLOAD_BLOCK_TABLE
blockList
)
;
if
(
!
mAllowlistOnly
&
&
FindInReadable
(
blockList
tables
)
)
{
mPendingLookup
-
>
mBlocklistCount
+
+
;
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_LOCAL
BLOCK_LIST
)
;
LOG
(
(
"
Found
principal
%
s
on
blocklist
[
this
=
%
p
]
"
mSpec
.
get
(
)
this
)
)
;
return
mPendingLookup
-
>
OnComplete
(
true
NS_OK
nsIApplicationReputationService
:
:
VERDICT_DANGEROUS
)
;
}
nsAutoCString
allowList
;
Preferences
:
:
GetCString
(
PREF_DOWNLOAD_ALLOW_TABLE
allowList
)
;
if
(
FindInReadable
(
allowList
tables
)
)
{
mPendingLookup
-
>
mAllowlistCount
+
+
;
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_LOCAL
ALLOW_LIST
)
;
LOG
(
(
"
Found
principal
%
s
on
allowlist
[
this
=
%
p
]
"
mSpec
.
get
(
)
this
)
)
;
}
else
{
LOG
(
(
"
Didn
'
t
find
principal
%
s
on
any
list
[
this
=
%
p
]
"
mSpec
.
get
(
)
this
)
)
;
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_LOCAL
NO_LIST
)
;
}
return
mPendingLookup
-
>
LookupNext
(
)
;
}
NS_IMPL_ISUPPORTS
(
PendingLookup
nsIStreamListener
nsIRequestObserver
nsIObserver
nsISupportsWeakReference
)
PendingLookup
:
:
PendingLookup
(
nsIApplicationReputationQuery
*
aQuery
nsIApplicationReputationCallback
*
aCallback
)
:
mBlocklistCount
(
0
)
mAllowlistCount
(
0
)
mQuery
(
aQuery
)
mCallback
(
aCallback
)
{
LOG
(
(
"
Created
pending
lookup
[
this
=
%
p
]
"
this
)
)
;
}
PendingLookup
:
:
~
PendingLookup
(
)
{
LOG
(
(
"
Destroying
pending
lookup
[
this
=
%
p
]
"
this
)
)
;
}
static
const
char
*
const
kBinaryFileExtensions
[
]
=
{
"
.
ade
"
"
.
adp
"
"
.
apk
"
"
.
app
"
"
.
application
"
"
.
appref
-
ms
"
"
.
as
"
"
.
asp
"
"
.
asx
"
"
.
bas
"
"
.
bash
"
"
.
bat
"
"
.
bz
"
"
.
bz2
"
"
.
bzip2
"
"
.
cab
"
"
.
cdr
"
"
.
cfg
"
"
.
chi
"
"
.
chm
"
"
.
class
"
"
.
cmd
"
"
.
com
"
"
.
command
"
"
.
cpgz
"
"
.
cpl
"
"
.
crt
"
"
.
crx
"
"
.
csh
"
"
.
dart
"
"
.
dc42
"
"
.
deb
"
"
.
dex
"
"
.
diskcopy42
"
"
.
dll
"
"
.
dmg
"
"
.
dmgpart
"
"
.
drv
"
"
.
dvdr
"
"
.
efi
"
"
.
eml
"
"
.
exe
"
"
.
fon
"
"
.
fxp
"
"
.
gadget
"
"
.
grp
"
"
.
gz
"
"
.
gzip
"
"
.
hfs
"
"
.
hlp
"
"
.
hqx
"
"
.
hta
"
"
.
htm
"
"
.
html
"
"
.
htt
"
"
.
img
"
"
.
imgpart
"
"
.
inf
"
"
.
ini
"
"
.
ins
"
"
.
iso
"
"
.
isp
"
"
.
jar
"
"
.
jnlp
"
"
.
js
"
"
.
jse
"
"
.
ksh
"
"
.
lnk
"
"
.
local
"
"
.
mad
"
"
.
maf
"
"
.
mag
"
"
.
mam
"
"
.
manifest
"
"
.
maq
"
"
.
mar
"
"
.
mas
"
"
.
mat
"
"
.
mau
"
"
.
mav
"
"
.
maw
"
"
.
mda
"
"
.
mdb
"
"
.
mde
"
"
.
mdt
"
"
.
mdw
"
"
.
mdz
"
"
.
mht
"
"
.
mhtml
"
"
.
mim
"
"
.
mmc
"
"
.
mof
"
"
.
mpkg
"
"
.
msc
"
"
.
msg
"
"
.
msh
"
"
.
msh1
"
"
.
msh1xml
"
"
.
msh2
"
"
.
msh2xml
"
"
.
mshxml
"
"
.
msi
"
"
.
msp
"
"
.
mst
"
"
.
ndif
"
"
.
ocx
"
"
.
ops
"
"
.
partial
"
"
.
pax
"
"
.
pcd
"
"
.
pdf
"
"
.
pet
"
"
.
pif
"
"
.
pkg
"
"
.
pl
"
"
.
plg
"
"
.
prf
"
"
.
prg
"
"
.
ps1
"
"
.
ps1xml
"
"
.
ps2
"
"
.
ps2xml
"
"
.
psc1
"
"
.
psc2
"
"
.
pst
"
"
.
pup
"
"
.
py
"
"
.
pyc
"
"
.
pyw
"
"
.
rb
"
"
.
reg
"
"
.
rels
"
"
.
rpm
"
"
.
scf
"
"
.
scr
"
"
.
sct
"
"
.
search
-
ms
"
"
.
sh
"
"
.
shar
"
"
.
shb
"
"
.
shs
"
"
.
slp
"
"
.
smi
"
"
.
sparsebundle
"
"
.
sparseimage
"
"
.
spl
"
"
.
svg
"
"
.
swf
"
"
.
swm
"
"
.
sys
"
"
.
tar
"
"
.
taz
"
"
.
tbz
"
"
.
tbz2
"
"
.
tcsh
"
"
.
tgz
"
"
.
tpz
"
"
.
txz
"
"
.
tz
"
"
.
udf
"
"
.
udif
"
"
.
url
"
"
.
vb
"
"
.
vbe
"
"
.
vbs
"
"
.
vhd
"
"
.
vhdx
"
"
.
vmdk
"
"
.
vsd
"
"
.
vsmacros
"
"
.
vss
"
"
.
vst
"
"
.
vsw
"
"
.
website
"
"
.
wim
"
"
.
ws
"
"
.
wsc
"
"
.
wsf
"
"
.
wsh
"
"
.
xar
"
"
.
xbap
"
"
.
xhtml
"
"
.
xhtm
"
"
.
xht
"
"
.
xip
"
"
.
xml
"
"
.
xnk
"
"
.
xrm
-
ms
"
"
.
xsl
"
"
.
xz
"
"
.
z
"
#
ifdef
XP_WIN
"
.
zip
"
#
endif
"
.
zipx
"
}
;
bool
PendingLookup
:
:
IsBinaryFile
(
)
{
nsCString
fileName
;
nsresult
rv
=
mQuery
-
>
GetSuggestedFileName
(
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
No
suggested
filename
[
this
=
%
p
]
"
this
)
)
;
return
false
;
}
LOG
(
(
"
Suggested
filename
:
%
s
[
this
=
%
p
]
"
fileName
.
get
(
)
this
)
)
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
kBinaryFileExtensions
)
;
+
+
i
)
{
if
(
StringEndsWith
(
fileName
nsDependentCString
(
kBinaryFileExtensions
[
i
]
)
)
)
{
return
true
;
}
}
return
false
;
}
ClientDownloadRequest
:
:
DownloadType
PendingLookup
:
:
GetDownloadType
(
const
nsACString
&
aFilename
)
{
MOZ_ASSERT
(
IsBinaryFile
(
)
)
;
if
(
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
zip
"
)
)
)
{
return
ClientDownloadRequest
:
:
ZIPPED_EXECUTABLE
;
}
else
if
(
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
apk
"
)
)
)
{
return
ClientDownloadRequest
:
:
ANDROID_APK
;
}
else
if
(
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
app
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
cdr
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
dart
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
dc42
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
diskcopy42
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
dmg
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
dmgpart
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
dvdr
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
img
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
imgpart
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
iso
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
mpkg
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
ndif
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
pkg
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
smi
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
sparsebundle
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
sparseimage
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
toast
"
)
)
|
|
StringEndsWith
(
aFilename
NS_LITERAL_CSTRING
(
"
.
udif
"
)
)
)
{
return
ClientDownloadRequest
:
:
MAC_EXECUTABLE
;
}
return
ClientDownloadRequest
:
:
WIN_EXECUTABLE
;
}
nsresult
PendingLookup
:
:
LookupNext
(
)
{
if
(
mBlocklistCount
>
0
)
{
return
OnComplete
(
true
NS_OK
nsIApplicationReputationService
:
:
VERDICT_DANGEROUS
)
;
}
int
index
=
mAnylistSpecs
.
Length
(
)
-
1
;
nsCString
spec
;
if
(
index
>
=
0
)
{
spec
=
mAnylistSpecs
[
index
]
;
mAnylistSpecs
.
RemoveElementAt
(
index
)
;
RefPtr
<
PendingDBLookup
>
lookup
(
new
PendingDBLookup
(
this
)
)
;
return
lookup
-
>
LookupSpec
(
spec
false
)
;
}
if
(
mBlocklistCount
>
0
)
{
return
OnComplete
(
true
NS_OK
nsIApplicationReputationService
:
:
VERDICT_DANGEROUS
)
;
}
if
(
mAllowlistCount
>
0
)
{
return
OnComplete
(
false
NS_OK
)
;
}
index
=
mAllowlistSpecs
.
Length
(
)
-
1
;
if
(
index
>
=
0
)
{
spec
=
mAllowlistSpecs
[
index
]
;
LOG
(
(
"
PendingLookup
:
:
LookupNext
:
checking
%
s
on
allowlist
"
spec
.
get
(
)
)
)
;
mAllowlistSpecs
.
RemoveElementAt
(
index
)
;
RefPtr
<
PendingDBLookup
>
lookup
(
new
PendingDBLookup
(
this
)
)
;
return
lookup
-
>
LookupSpec
(
spec
true
)
;
}
if
(
!
IsBinaryFile
(
)
)
{
LOG
(
(
"
Not
eligible
for
remote
lookups
[
this
=
%
p
]
"
this
)
)
;
return
OnComplete
(
false
NS_OK
)
;
}
nsresult
rv
=
SendRemoteQuery
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
OnComplete
(
false
rv
)
;
}
return
NS_OK
;
}
nsCString
PendingLookup
:
:
EscapeCertificateAttribute
(
const
nsACString
&
aAttribute
)
{
nsCString
escaped
;
escaped
.
SetCapacity
(
aAttribute
.
Length
(
)
)
;
for
(
unsigned
int
i
=
0
;
i
<
aAttribute
.
Length
(
)
;
+
+
i
)
{
if
(
aAttribute
.
Data
(
)
[
i
]
=
=
'
%
'
)
{
escaped
.
AppendLiteral
(
"
%
25
"
)
;
}
else
if
(
aAttribute
.
Data
(
)
[
i
]
=
=
'
/
'
)
{
escaped
.
AppendLiteral
(
"
%
2F
"
)
;
}
else
if
(
aAttribute
.
Data
(
)
[
i
]
=
=
'
'
)
{
escaped
.
AppendLiteral
(
"
%
20
"
)
;
}
else
{
escaped
.
Append
(
aAttribute
.
Data
(
)
[
i
]
)
;
}
}
return
escaped
;
}
nsCString
PendingLookup
:
:
EscapeFingerprint
(
const
nsACString
&
aFingerprint
)
{
nsCString
escaped
;
escaped
.
SetCapacity
(
aFingerprint
.
Length
(
)
)
;
for
(
unsigned
int
i
=
0
;
i
<
aFingerprint
.
Length
(
)
;
+
+
i
)
{
if
(
aFingerprint
.
Data
(
)
[
i
]
!
=
'
:
'
)
{
escaped
.
Append
(
aFingerprint
.
Data
(
)
[
i
]
)
;
}
}
return
escaped
;
}
nsresult
PendingLookup
:
:
GenerateWhitelistStringsForPair
(
nsIX509Cert
*
certificate
nsIX509Cert
*
issuer
)
{
nsCString
whitelistString
(
"
http
:
/
/
sb
-
ssl
.
google
.
com
/
safebrowsing
/
csd
/
certificate
/
"
)
;
nsString
fingerprint
;
nsresult
rv
=
issuer
-
>
GetSha1Fingerprint
(
fingerprint
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
whitelistString
.
Append
(
EscapeFingerprint
(
NS_ConvertUTF16toUTF8
(
fingerprint
)
)
)
;
nsString
commonName
;
rv
=
certificate
-
>
GetCommonName
(
commonName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
commonName
.
IsEmpty
(
)
)
{
whitelistString
.
AppendLiteral
(
"
/
CN
=
"
)
;
whitelistString
.
Append
(
EscapeCertificateAttribute
(
NS_ConvertUTF16toUTF8
(
commonName
)
)
)
;
}
nsString
organization
;
rv
=
certificate
-
>
GetOrganization
(
organization
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
organization
.
IsEmpty
(
)
)
{
whitelistString
.
AppendLiteral
(
"
/
O
=
"
)
;
whitelistString
.
Append
(
EscapeCertificateAttribute
(
NS_ConvertUTF16toUTF8
(
organization
)
)
)
;
}
nsString
organizationalUnit
;
rv
=
certificate
-
>
GetOrganizationalUnit
(
organizationalUnit
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
organizationalUnit
.
IsEmpty
(
)
)
{
whitelistString
.
AppendLiteral
(
"
/
OU
=
"
)
;
whitelistString
.
Append
(
EscapeCertificateAttribute
(
NS_ConvertUTF16toUTF8
(
organizationalUnit
)
)
)
;
}
LOG
(
(
"
Whitelisting
%
s
"
whitelistString
.
get
(
)
)
)
;
mAllowlistSpecs
.
AppendElement
(
whitelistString
)
;
return
NS_OK
;
}
nsresult
PendingLookup
:
:
GenerateWhitelistStringsForChain
(
const
safe_browsing
:
:
ClientDownloadRequest_CertificateChain
&
aChain
)
{
if
(
aChain
.
element_size
(
)
<
2
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIX509CertDB
>
certDB
=
do_GetService
(
NS_X509CERTDB_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIX509Cert
>
signer
;
nsDependentCSubstring
signerDER
(
const_cast
<
char
*
>
(
aChain
.
element
(
0
)
.
certificate
(
)
.
data
(
)
)
aChain
.
element
(
0
)
.
certificate
(
)
.
size
(
)
)
;
rv
=
certDB
-
>
ConstructX509
(
signerDER
getter_AddRefs
(
signer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
int
i
=
1
;
i
<
aChain
.
element_size
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIX509Cert
>
issuer
;
nsDependentCSubstring
issuerDER
(
const_cast
<
char
*
>
(
aChain
.
element
(
i
)
.
certificate
(
)
.
data
(
)
)
aChain
.
element
(
i
)
.
certificate
(
)
.
size
(
)
)
;
rv
=
certDB
-
>
ConstructX509
(
issuerDER
getter_AddRefs
(
issuer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GenerateWhitelistStringsForPair
(
signer
issuer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
PendingLookup
:
:
GenerateWhitelistStrings
(
)
{
for
(
int
i
=
0
;
i
<
mRequest
.
signature
(
)
.
certificate_chain_size
(
)
;
+
+
i
)
{
nsresult
rv
=
GenerateWhitelistStringsForChain
(
mRequest
.
signature
(
)
.
certificate_chain
(
i
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
PendingLookup
:
:
AddRedirects
(
nsIArray
*
aRedirects
)
{
uint32_t
length
=
0
;
aRedirects
-
>
GetLength
(
&
length
)
;
LOG
(
(
"
ApplicationReputation
:
Got
%
u
redirects
"
length
)
)
;
nsCOMPtr
<
nsISimpleEnumerator
>
iter
;
nsresult
rv
=
aRedirects
-
>
Enumerate
(
getter_AddRefs
(
iter
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasMoreRedirects
=
false
;
rv
=
iter
-
>
HasMoreElements
(
&
hasMoreRedirects
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
hasMoreRedirects
)
{
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
iter
-
>
GetNext
(
getter_AddRefs
(
supports
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIRedirectHistoryEntry
>
redirectEntry
=
do_QueryInterface
(
supports
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
redirectEntry
-
>
GetPrincipal
(
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
principal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
spec
;
rv
=
GetStrippedSpec
(
uri
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mAnylistSpecs
.
AppendElement
(
spec
)
;
LOG
(
(
"
ApplicationReputation
:
Appending
redirect
%
s
\
n
"
spec
.
get
(
)
)
)
;
ClientDownloadRequest_Resource
*
resource
=
mRequest
.
add_resources
(
)
;
resource
-
>
set_url
(
spec
.
get
(
)
)
;
resource
-
>
set_type
(
ClientDownloadRequest
:
:
DOWNLOAD_REDIRECT
)
;
rv
=
iter
-
>
HasMoreElements
(
&
hasMoreRedirects
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
PendingLookup
:
:
StartLookup
(
)
{
mStartTime
=
TimeStamp
:
:
Now
(
)
;
nsresult
rv
=
DoLookupInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
OnComplete
(
false
NS_OK
)
;
}
return
rv
;
}
nsresult
PendingLookup
:
:
GetSpecHash
(
nsACString
&
aSpec
nsACString
&
hexEncodedHash
)
{
nsresult
rv
;
nsCOMPtr
<
nsICryptoHash
>
cryptoHash
=
do_CreateInstance
(
"
mozilla
.
org
/
security
/
hash
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
cryptoHash
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
cryptoHash
-
>
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
aSpec
.
BeginReading
(
)
)
aSpec
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
binaryHash
;
rv
=
cryptoHash
-
>
Finish
(
false
binaryHash
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
static
const
char
*
const
hex
=
"
0123456789ABCDEF
"
;
hexEncodedHash
.
SetCapacity
(
2
*
binaryHash
.
Length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
binaryHash
.
Length
(
)
;
+
+
i
)
{
auto
c
=
static_cast
<
unsigned
char
>
(
binaryHash
[
i
]
)
;
hexEncodedHash
.
Append
(
hex
[
(
c
>
>
4
)
&
0x0F
]
)
;
hexEncodedHash
.
Append
(
hex
[
c
&
0x0F
]
)
;
}
return
NS_OK
;
}
nsresult
PendingLookup
:
:
GetStrippedSpec
(
nsIURI
*
aUri
nsACString
&
escaped
)
{
if
(
NS_WARN_IF
(
!
aUri
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
;
rv
=
aUri
-
>
GetScheme
(
escaped
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
escaped
.
EqualsLiteral
(
"
blob
"
)
)
{
aUri
-
>
GetSpec
(
escaped
)
;
LOG
(
(
"
PendingLookup
:
:
GetStrippedSpec
(
)
:
blob
URL
left
unstripped
as
'
%
s
'
[
this
=
%
p
]
"
PromiseFlatCString
(
escaped
)
.
get
(
)
this
)
)
;
return
NS_OK
;
}
else
if
(
escaped
.
EqualsLiteral
(
"
data
"
)
)
{
aUri
-
>
GetSpec
(
escaped
)
;
int32_t
comma
=
escaped
.
FindChar
(
'
'
)
;
if
(
comma
>
-
1
&
&
static_cast
<
nsCString
:
:
size_type
>
(
comma
)
<
escaped
.
Length
(
)
-
1
)
{
MOZ_ASSERT
(
comma
>
4
"
Data
URIs
start
with
'
data
:
'
"
)
;
nsAutoCString
hexEncodedHash
;
rv
=
GetSpecHash
(
escaped
hexEncodedHash
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
escaped
.
Truncate
(
comma
+
1
)
;
escaped
.
Append
(
hexEncodedHash
)
;
}
}
LOG
(
(
"
PendingLookup
:
:
GetStrippedSpec
(
)
:
data
URL
stripped
to
'
%
s
'
[
this
=
%
p
]
"
PromiseFlatCString
(
escaped
)
.
get
(
)
this
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
aUri
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
PendingLookup
:
:
GetStrippedSpec
(
)
:
scheme
'
%
s
'
is
not
supported
[
this
=
%
p
]
"
PromiseFlatCString
(
escaped
)
.
get
(
)
this
)
)
;
return
rv
;
}
nsCString
temp
;
rv
=
url
-
>
GetHostPort
(
temp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
escaped
.
AppendLiteral
(
"
:
/
/
"
)
;
escaped
.
Append
(
temp
)
;
rv
=
url
-
>
GetFilePath
(
temp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
escaped
.
Append
(
temp
)
;
LOG
(
(
"
PendingLookup
:
:
GetStrippedSpec
(
)
:
URL
stripped
to
'
%
s
'
[
this
=
%
p
]
"
PromiseFlatCString
(
escaped
)
.
get
(
)
this
)
)
;
return
NS_OK
;
}
nsresult
PendingLookup
:
:
DoLookupInternal
(
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
mQuery
-
>
GetSourceURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
sourceSpec
;
rv
=
GetStrippedSpec
(
uri
sourceSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mAnylistSpecs
.
AppendElement
(
sourceSpec
)
;
ClientDownloadRequest_Resource
*
resource
=
mRequest
.
add_resources
(
)
;
resource
-
>
set_url
(
sourceSpec
.
get
(
)
)
;
resource
-
>
set_type
(
ClientDownloadRequest
:
:
DOWNLOAD_URL
)
;
nsCOMPtr
<
nsIURI
>
referrer
=
nullptr
;
rv
=
mQuery
-
>
GetReferrerURI
(
getter_AddRefs
(
referrer
)
)
;
if
(
referrer
)
{
nsCString
referrerSpec
;
rv
=
GetStrippedSpec
(
referrer
referrerSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mAnylistSpecs
.
AppendElement
(
referrerSpec
)
;
resource
-
>
set_referrer
(
referrerSpec
.
get
(
)
)
;
}
nsCOMPtr
<
nsIArray
>
redirects
;
rv
=
mQuery
-
>
GetRedirects
(
getter_AddRefs
(
redirects
)
)
;
if
(
redirects
)
{
AddRedirects
(
redirects
)
;
}
else
{
LOG
(
(
"
ApplicationReputation
:
Got
no
redirects
[
this
=
%
p
]
"
this
)
)
;
}
nsCOMPtr
<
nsIArray
>
sigArray
;
rv
=
mQuery
-
>
GetSignatureInfo
(
getter_AddRefs
(
sigArray
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
sigArray
)
{
rv
=
ParseCertificates
(
sigArray
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
GenerateWhitelistStrings
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
LookupNext
(
)
;
}
nsresult
PendingLookup
:
:
OnComplete
(
bool
shouldBlock
nsresult
rv
uint32_t
verdict
)
{
MOZ_ASSERT
(
!
shouldBlock
|
|
verdict
!
=
nsIApplicationReputationService
:
:
VERDICT_SAFE
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsAutoCString
errorName
;
mozilla
:
:
GetErrorName
(
rv
errorName
)
;
LOG
(
(
"
Failed
sending
remote
query
for
application
reputation
"
"
[
rv
=
%
s
this
=
%
p
]
"
errorName
.
get
(
)
this
)
)
;
}
if
(
mTimeoutTimer
)
{
mTimeoutTimer
-
>
Cancel
(
)
;
mTimeoutTimer
=
nullptr
;
}
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_SHOULD_BLOCK
shouldBlock
)
;
double
t
=
(
TimeStamp
:
:
Now
(
)
-
mStartTime
)
.
ToMilliseconds
(
)
;
LOG
(
(
"
Application
Reputation
verdict
is
%
u
obtained
in
%
f
ms
[
this
=
%
p
]
"
verdict
t
this
)
)
;
if
(
shouldBlock
)
{
LOG
(
(
"
Application
Reputation
check
failed
blocking
bad
binary
[
this
=
%
p
]
"
this
)
)
;
}
else
{
LOG
(
(
"
Application
Reputation
check
passed
[
this
=
%
p
]
"
this
)
)
;
}
nsresult
res
=
mCallback
-
>
OnComplete
(
shouldBlock
rv
verdict
)
;
return
res
;
}
nsresult
PendingLookup
:
:
ParseCertificates
(
nsIArray
*
aSigArray
)
{
NS_ENSURE_ARG_POINTER
(
aSigArray
)
;
nsCOMPtr
<
nsISimpleEnumerator
>
chains
;
nsresult
rv
=
aSigArray
-
>
Enumerate
(
getter_AddRefs
(
chains
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasMoreChains
=
false
;
rv
=
chains
-
>
HasMoreElements
(
&
hasMoreChains
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
hasMoreChains
)
{
nsCOMPtr
<
nsISupports
>
chainSupports
;
rv
=
chains
-
>
GetNext
(
getter_AddRefs
(
chainSupports
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIX509CertList
>
certList
=
do_QueryInterface
(
chainSupports
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
safe_browsing
:
:
ClientDownloadRequest_CertificateChain
*
certChain
=
mRequest
.
mutable_signature
(
)
-
>
add_certificate_chain
(
)
;
nsCOMPtr
<
nsISimpleEnumerator
>
chainElt
;
rv
=
certList
-
>
GetEnumerator
(
getter_AddRefs
(
chainElt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasMoreCerts
=
false
;
rv
=
chainElt
-
>
HasMoreElements
(
&
hasMoreCerts
)
;
while
(
hasMoreCerts
)
{
nsCOMPtr
<
nsISupports
>
certSupports
;
rv
=
chainElt
-
>
GetNext
(
getter_AddRefs
(
certSupports
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIX509Cert
>
cert
=
do_QueryInterface
(
certSupports
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint8_t
*
data
=
nullptr
;
uint32_t
len
=
0
;
rv
=
cert
-
>
GetRawDER
(
&
len
&
data
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
certChain
-
>
add_element
(
)
-
>
set_certificate
(
data
len
)
;
free
(
data
)
;
rv
=
chainElt
-
>
HasMoreElements
(
&
hasMoreCerts
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
chains
-
>
HasMoreElements
(
&
hasMoreChains
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
mRequest
.
signature
(
)
.
certificate_chain_size
(
)
>
0
)
{
mRequest
.
mutable_signature
(
)
-
>
set_trusted
(
true
)
;
}
return
NS_OK
;
}
nsresult
PendingLookup
:
:
SendRemoteQuery
(
)
{
nsresult
rv
=
SendRemoteQueryInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
OnComplete
(
false
rv
)
;
}
return
rv
;
}
nsresult
PendingLookup
:
:
SendRemoteQueryInternal
(
)
{
if
(
!
Preferences
:
:
GetBool
(
PREF_SB_DOWNLOADS_REMOTE_ENABLED
false
)
)
{
LOG
(
(
"
Remote
lookups
are
disabled
[
this
=
%
p
]
"
this
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
serviceUrl
;
NS_ENSURE_SUCCESS
(
Preferences
:
:
GetCString
(
PREF_SB_APP_REP_URL
serviceUrl
)
NS_ERROR_NOT_AVAILABLE
)
;
if
(
serviceUrl
.
IsEmpty
(
)
)
{
LOG
(
(
"
Remote
lookup
URL
is
empty
[
this
=
%
p
]
"
this
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
{
nsAutoCString
table
;
NS_ENSURE_SUCCESS
(
Preferences
:
:
GetCString
(
PREF_DOWNLOAD_BLOCK_TABLE
table
)
NS_ERROR_NOT_AVAILABLE
)
;
if
(
table
.
IsEmpty
(
)
)
{
LOG
(
(
"
Blocklist
is
empty
[
this
=
%
p
]
"
this
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
}
{
nsAutoCString
table
;
NS_ENSURE_SUCCESS
(
Preferences
:
:
GetCString
(
PREF_DOWNLOAD_ALLOW_TABLE
table
)
NS_ERROR_NOT_AVAILABLE
)
;
if
(
table
.
IsEmpty
(
)
)
{
LOG
(
(
"
Allowlist
is
empty
[
this
=
%
p
]
"
this
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
}
LOG
(
(
"
Sending
remote
query
for
application
reputation
[
this
=
%
p
]
"
this
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
;
rv
=
mQuery
-
>
GetSourceURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
spec
;
rv
=
GetStrippedSpec
(
uri
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRequest
.
set_url
(
spec
.
get
(
)
)
;
uint32_t
fileSize
;
rv
=
mQuery
-
>
GetFileSize
(
&
fileSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRequest
.
set_length
(
fileSize
)
;
mRequest
.
set_user_initiated
(
true
)
;
nsCString
locale
;
rv
=
LocaleService
:
:
GetInstance
(
)
-
>
GetAppLocaleAsLangTag
(
locale
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRequest
.
set_locale
(
locale
.
get
(
)
)
;
nsCString
sha256Hash
;
rv
=
mQuery
-
>
GetSha256Hash
(
sha256Hash
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRequest
.
mutable_digests
(
)
-
>
set_sha256
(
sha256Hash
.
Data
(
)
)
;
nsCString
fileName
;
rv
=
mQuery
-
>
GetSuggestedFileName
(
fileName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRequest
.
set_file_basename
(
fileName
.
get
(
)
)
;
mRequest
.
set_download_type
(
GetDownloadType
(
fileName
)
)
;
if
(
mRequest
.
signature
(
)
.
trusted
(
)
)
{
LOG
(
(
"
Got
signed
binary
for
remote
application
reputation
check
"
"
[
this
=
%
p
]
"
this
)
)
;
}
else
{
LOG
(
(
"
Got
unsigned
binary
for
remote
application
reputation
check
"
"
[
this
=
%
p
]
"
this
)
)
;
}
std
:
:
string
serialized
;
if
(
!
mRequest
.
SerializeToString
(
&
serialized
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
LOG
(
(
"
Serialized
protocol
buffer
[
this
=
%
p
]
:
(
length
=
%
zu
)
%
s
"
this
serialized
.
length
(
)
serialized
.
c_str
(
)
)
)
;
nsCOMPtr
<
nsIStringInputStream
>
sstream
=
do_CreateInstance
(
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
sstream
-
>
SetData
(
serialized
.
c_str
(
)
serialized
.
length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIIOService
>
ios
=
do_GetService
(
NS_IOSERVICE_CONTRACTID
&
rv
)
;
rv
=
ios
-
>
NewChannel2
(
serviceUrl
nullptr
nullptr
nullptr
nsContentUtils
:
:
GetSystemPrincipal
(
)
nullptr
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
getter_AddRefs
(
mChannel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
GetLoadInfo
(
)
;
if
(
loadInfo
)
{
mozilla
:
:
OriginAttributes
attrs
;
attrs
.
mFirstPartyDomain
.
AssignLiteral
(
NECKO_SAFEBROWSING_FIRST_PARTY_DOMAIN
)
;
loadInfo
-
>
SetOriginAttributes
(
attrs
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
mChannel
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mozilla
:
:
Unused
<
<
httpChannel
;
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel
=
do_QueryInterface
(
mChannel
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
uploadChannel
-
>
ExplicitSetUploadStream
(
sstream
NS_LITERAL_CSTRING
(
"
application
/
octet
-
stream
"
)
serialized
.
size
(
)
NS_LITERAL_CSTRING
(
"
POST
"
)
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
timeoutMs
=
Preferences
:
:
GetUint
(
PREF_SB_DOWNLOADS_REMOTE_TIMEOUT
10000
)
;
NS_NewTimerWithCallback
(
getter_AddRefs
(
mTimeoutTimer
)
this
timeoutMs
nsITimer
:
:
TYPE_ONE_SHOT
)
;
rv
=
mChannel
-
>
AsyncOpen2
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PendingLookup
:
:
Notify
(
nsITimer
*
aTimer
)
{
LOG
(
(
"
Remote
lookup
timed
out
[
this
=
%
p
]
"
this
)
)
;
MOZ_ASSERT
(
aTimer
=
=
mTimeoutTimer
)
;
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_REMOTE_LOOKUP_TIMEOUT
true
)
;
mChannel
-
>
Cancel
(
NS_ERROR_NET_TIMEOUT
)
;
mTimeoutTimer
-
>
Cancel
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PendingLookup
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
quit
-
application
"
)
)
{
if
(
mTimeoutTimer
)
{
mTimeoutTimer
-
>
Cancel
(
)
;
mTimeoutTimer
=
nullptr
;
}
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
NS_ERROR_ABORT
)
;
}
}
return
NS_OK
;
}
static
nsresult
AppendSegmentToString
(
nsIInputStream
*
inputStream
void
*
closure
const
char
*
rawSegment
uint32_t
toOffset
uint32_t
count
uint32_t
*
writeCount
)
{
nsAutoCString
*
decodedData
=
static_cast
<
nsAutoCString
*
>
(
closure
)
;
decodedData
-
>
Append
(
rawSegment
count
)
;
*
writeCount
=
count
;
return
NS_OK
;
}
NS_IMETHODIMP
PendingLookup
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aStream
uint64_t
offset
uint32_t
count
)
{
uint32_t
read
;
return
aStream
-
>
ReadSegments
(
AppendSegmentToString
&
mResponse
count
&
read
)
;
}
NS_IMETHODIMP
PendingLookup
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
return
NS_OK
;
}
NS_IMETHODIMP
PendingLookup
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aResult
)
{
NS_ENSURE_STATE
(
mCallback
)
;
bool
shouldBlock
=
false
;
uint32_t
verdict
=
nsIApplicationReputationService
:
:
VERDICT_SAFE
;
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_REMOTE_LOOKUP_TIMEOUT
false
)
;
nsresult
rv
=
OnStopRequestInternal
(
aRequest
aContext
aResult
&
shouldBlock
&
verdict
)
;
OnComplete
(
shouldBlock
rv
verdict
)
;
return
rv
;
}
nsresult
PendingLookup
:
:
OnStopRequestInternal
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aResult
bool
*
aShouldBlock
uint32_t
*
aVerdict
)
{
if
(
NS_FAILED
(
aResult
)
)
{
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_SERVER
SERVER_RESPONSE_FAILED
)
;
return
aResult
;
}
*
aShouldBlock
=
false
;
*
aVerdict
=
nsIApplicationReputationService
:
:
VERDICT_SAFE
;
nsresult
rv
;
nsCOMPtr
<
nsIHttpChannel
>
channel
=
do_QueryInterface
(
aRequest
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_SERVER
SERVER_RESPONSE_FAILED
)
;
return
rv
;
}
uint32_t
status
=
0
;
rv
=
channel
-
>
GetResponseStatus
(
&
status
)
;
if
(
NS_FAILED
(
rv
)
)
{
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_SERVER
SERVER_RESPONSE_FAILED
)
;
return
rv
;
}
if
(
status
!
=
200
)
{
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_SERVER
SERVER_RESPONSE_FAILED
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
std
:
:
string
buf
(
mResponse
.
Data
(
)
mResponse
.
Length
(
)
)
;
safe_browsing
:
:
ClientDownloadResponse
response
;
if
(
!
response
.
ParseFromString
(
buf
)
)
{
LOG
(
(
"
Invalid
protocol
buffer
response
[
this
=
%
p
]
:
%
s
"
this
buf
.
c_str
(
)
)
)
;
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_SERVER
SERVER_RESPONSE_INVALID
)
;
return
NS_ERROR_CANNOT_CONVERT_DATA
;
}
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_SERVER
SERVER_RESPONSE_VALID
)
;
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_SERVER_VERDICT
std
:
:
min
<
uint32_t
>
(
response
.
verdict
(
)
7
)
)
;
switch
(
response
.
verdict
(
)
)
{
case
safe_browsing
:
:
ClientDownloadResponse
:
:
DANGEROUS
:
*
aShouldBlock
=
Preferences
:
:
GetBool
(
PREF_BLOCK_DANGEROUS
true
)
;
*
aVerdict
=
nsIApplicationReputationService
:
:
VERDICT_DANGEROUS
;
break
;
case
safe_browsing
:
:
ClientDownloadResponse
:
:
DANGEROUS_HOST
:
*
aShouldBlock
=
Preferences
:
:
GetBool
(
PREF_BLOCK_DANGEROUS_HOST
true
)
;
*
aVerdict
=
nsIApplicationReputationService
:
:
VERDICT_DANGEROUS_HOST
;
break
;
case
safe_browsing
:
:
ClientDownloadResponse
:
:
POTENTIALLY_UNWANTED
:
*
aShouldBlock
=
Preferences
:
:
GetBool
(
PREF_BLOCK_POTENTIALLY_UNWANTED
false
)
;
*
aVerdict
=
nsIApplicationReputationService
:
:
VERDICT_POTENTIALLY_UNWANTED
;
break
;
case
safe_browsing
:
:
ClientDownloadResponse
:
:
UNCOMMON
:
*
aShouldBlock
=
Preferences
:
:
GetBool
(
PREF_BLOCK_UNCOMMON
false
)
;
*
aVerdict
=
nsIApplicationReputationService
:
:
VERDICT_UNCOMMON
;
break
;
default
:
break
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
ApplicationReputationService
nsIApplicationReputationService
)
ApplicationReputationService
*
ApplicationReputationService
:
:
gApplicationReputationService
=
nullptr
;
already_AddRefed
<
ApplicationReputationService
>
ApplicationReputationService
:
:
GetSingleton
(
)
{
if
(
!
gApplicationReputationService
)
{
gApplicationReputationService
=
new
ApplicationReputationService
(
)
;
}
return
do_AddRef
(
gApplicationReputationService
)
;
}
ApplicationReputationService
:
:
ApplicationReputationService
(
)
{
LOG
(
(
"
Application
reputation
service
started
up
"
)
)
;
}
ApplicationReputationService
:
:
~
ApplicationReputationService
(
)
{
LOG
(
(
"
Application
reputation
service
shutting
down
"
)
)
;
MOZ_ASSERT
(
gApplicationReputationService
=
=
this
)
;
gApplicationReputationService
=
nullptr
;
}
NS_IMETHODIMP
ApplicationReputationService
:
:
QueryReputation
(
nsIApplicationReputationQuery
*
aQuery
nsIApplicationReputationCallback
*
aCallback
)
{
LOG
(
(
"
Starting
application
reputation
check
[
query
=
%
p
]
"
aQuery
)
)
;
NS_ENSURE_ARG_POINTER
(
aQuery
)
;
NS_ENSURE_ARG_POINTER
(
aCallback
)
;
nsresult
rv
=
QueryReputationInternal
(
aQuery
aCallback
)
;
if
(
NS_FAILED
(
rv
)
)
{
Accumulate
(
mozilla
:
:
Telemetry
:
:
APPLICATION_REPUTATION_SHOULD_BLOCK
false
)
;
aCallback
-
>
OnComplete
(
false
rv
nsIApplicationReputationService
:
:
VERDICT_SAFE
)
;
}
return
NS_OK
;
}
nsresult
ApplicationReputationService
:
:
QueryReputationInternal
(
nsIApplicationReputationQuery
*
aQuery
nsIApplicationReputationCallback
*
aCallback
)
{
nsresult
rv
;
if
(
!
Preferences
:
:
GetBool
(
PREF_SB_MALWARE_ENABLED
false
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
Preferences
:
:
GetBool
(
PREF_SB_DOWNLOADS_ENABLED
false
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
aQuery
-
>
GetSourceURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
uri
)
;
RefPtr
<
PendingLookup
>
lookup
(
new
PendingLookup
(
aQuery
aCallback
)
)
;
NS_ENSURE_STATE
(
lookup
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
return
NS_ERROR_FAILURE
;
}
observerService
-
>
AddObserver
(
lookup
"
quit
-
application
"
true
)
;
return
lookup
-
>
StartLookup
(
)
;
}
