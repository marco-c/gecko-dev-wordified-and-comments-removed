const
{
Uptake
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
Uptake
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
LogManager
"
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
JsonSchemaValidator
"
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
JsonSchemaValidator
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
BaseAction
"
]
;
class
BaseAction
{
constructor
(
)
{
this
.
state
=
BaseAction
.
STATE_PREPARING
;
this
.
log
=
lazy
.
LogManager
.
getLogger
(
action
.
{
this
.
name
}
)
;
this
.
lastError
=
null
;
}
_ensurePreExecution
(
)
{
if
(
this
.
state
!
=
=
BaseAction
.
STATE_PREPARING
)
{
return
;
}
try
{
this
.
_preExecution
(
)
;
if
(
this
.
state
=
=
=
BaseAction
.
STATE_PREPARING
)
{
this
.
state
=
BaseAction
.
STATE_READY
;
}
}
catch
(
err
)
{
try
{
err
.
message
=
Could
not
initialize
action
{
this
.
name
}
:
{
err
.
message
}
;
}
catch
(
_e
)
{
this
.
log
.
error
(
Could
not
initialize
action
{
this
.
name
}
error
follows
.
)
;
}
this
.
fail
(
err
)
;
}
}
get
schema
(
)
{
return
{
type
:
"
object
"
properties
:
{
}
}
;
}
disable
(
)
{
this
.
state
=
BaseAction
.
STATE_DISABLED
;
}
fail
(
err
)
{
switch
(
this
.
state
)
{
case
BaseAction
.
STATE_PREPARING
:
{
Uptake
.
reportAction
(
this
.
name
Uptake
.
ACTION_PRE_EXECUTION_ERROR
)
;
break
;
}
default
:
{
Cu
.
reportError
(
new
Error
(
"
BaseAction
.
fail
(
)
called
at
unexpected
time
"
)
)
;
}
}
this
.
state
=
BaseAction
.
STATE_FAILED
;
this
.
lastError
=
err
;
Cu
.
reportError
(
err
)
;
}
get
name
(
)
{
return
this
.
constructor
.
name
;
}
_preExecution
(
)
{
}
validateArguments
(
args
schema
=
this
.
schema
)
{
let
{
valid
parsedValue
:
validated
}
=
lazy
.
JsonSchemaValidator
.
validate
(
args
schema
{
allowExtraProperties
:
true
}
)
;
if
(
!
valid
)
{
throw
new
Error
(
Arguments
do
not
match
schema
.
arguments
:
\
n
{
JSON
.
stringify
(
args
)
}
\
n
+
schema
:
\
n
{
JSON
.
stringify
(
schema
)
}
)
;
}
return
validated
;
}
async
processRecipe
(
recipe
suitability
)
{
if
(
!
BaseAction
.
suitabilitySet
.
has
(
suitability
)
)
{
throw
new
Error
(
Unknown
recipe
status
{
suitability
}
)
;
}
this
.
_ensurePreExecution
(
)
;
if
(
this
.
state
=
=
=
BaseAction
.
STATE_FINALIZED
)
{
throw
new
Error
(
"
Action
has
already
been
finalized
"
)
;
}
if
(
this
.
state
!
=
=
BaseAction
.
STATE_READY
)
{
Uptake
.
reportRecipe
(
recipe
Uptake
.
RECIPE_ACTION_DISABLED
)
;
this
.
log
.
warn
(
Skipping
recipe
{
recipe
.
name
}
because
{
this
.
name
}
was
disabled
during
preExecution
.
)
;
return
;
}
let
uptakeResult
=
BaseAction
.
suitabilityToUptakeStatus
[
suitability
]
;
if
(
!
uptakeResult
)
{
throw
new
Error
(
Coding
error
no
uptake
status
for
suitability
{
suitability
}
)
;
}
if
(
suitability
!
=
=
BaseAction
.
suitability
.
CAPABILITIES_MISMATCH
)
{
try
{
recipe
.
arguments
=
this
.
validateArguments
(
recipe
.
arguments
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
uptakeResult
=
Uptake
.
RECIPE_EXECUTION_ERROR
;
suitability
=
BaseAction
.
suitability
.
ARGUMENTS_INVALID
;
}
}
try
{
await
this
.
_processRecipe
(
recipe
suitability
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
uptakeResult
=
Uptake
.
RECIPE_EXECUTION_ERROR
;
}
Uptake
.
reportRecipe
(
recipe
uptakeResult
)
;
}
async
_run
(
recipe
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
async
_processRecipe
(
recipe
suitability
)
{
if
(
!
suitability
)
{
throw
new
Error
(
"
Suitability
is
undefined
:
"
suitability
)
;
}
if
(
suitability
=
=
BaseAction
.
suitability
.
FILTER_MATCH
)
{
await
this
.
_run
(
recipe
)
;
}
}
async
finalize
(
options
)
{
this
.
_ensurePreExecution
(
)
;
let
status
;
switch
(
this
.
state
)
{
case
BaseAction
.
STATE_FINALIZED
:
{
throw
new
Error
(
"
Action
has
already
been
finalized
"
)
;
}
case
BaseAction
.
STATE_READY
:
{
try
{
await
this
.
_finalize
(
options
)
;
status
=
Uptake
.
ACTION_SUCCESS
;
}
catch
(
err
)
{
status
=
Uptake
.
ACTION_POST_EXECUTION_ERROR
;
try
{
err
.
message
=
Could
not
run
postExecution
hook
for
{
this
.
name
}
:
{
err
.
message
}
;
}
catch
(
err
)
{
this
.
log
.
debug
(
Could
not
run
postExecution
hook
for
{
this
.
name
}
)
;
}
this
.
lastError
=
err
;
Cu
.
reportError
(
err
)
;
}
break
;
}
case
BaseAction
.
STATE_DISABLED
:
{
this
.
log
.
debug
(
Skipping
post
-
execution
hook
for
{
this
.
name
}
because
it
is
disabled
.
)
;
status
=
Uptake
.
ACTION_SUCCESS
;
break
;
}
case
BaseAction
.
STATE_FAILED
:
{
this
.
log
.
debug
(
Skipping
post
-
execution
hook
for
{
this
.
name
}
because
it
failed
during
pre
-
execution
.
)
;
break
;
}
default
:
{
throw
new
Error
(
Unexpected
state
during
finalize
:
{
this
.
state
}
)
;
}
}
this
.
state
=
BaseAction
.
STATE_FINALIZED
;
if
(
status
)
{
Uptake
.
reportAction
(
this
.
name
status
)
;
}
}
async
_finalize
(
_options
=
{
}
)
{
}
}
BaseAction
.
STATE_PREPARING
=
"
ACTION_PREPARING
"
;
BaseAction
.
STATE_READY
=
"
ACTION_READY
"
;
BaseAction
.
STATE_DISABLED
=
"
ACTION_DISABLED
"
;
BaseAction
.
STATE_FAILED
=
"
ACTION_FAILED
"
;
BaseAction
.
STATE_FINALIZED
=
"
ACTION_FINALIZED
"
;
BaseAction
.
suitability
=
{
SIGNATURE_ERROR
:
"
RECIPE_SUITABILITY_SIGNATURE_ERROR
"
CAPABILITIES_MISMATCH
:
"
RECIPE_SUITABILITY_CAPABILITIES_MISMATCH
"
FILTER_MATCH
:
"
RECIPE_SUITABILITY_FILTER_MATCH
"
FILTER_MISMATCH
:
"
RECIPE_SUITABILITY_FILTER_MISMATCH
"
FILTER_ERROR
:
"
RECIPE_SUITABILITY_FILTER_ERROR
"
ARGUMENTS_INVALID
:
"
RECIPE_SUITABILITY_ARGUMENTS_INVALID
"
}
;
BaseAction
.
suitabilitySet
=
new
Set
(
Object
.
values
(
BaseAction
.
suitability
)
)
;
BaseAction
.
suitabilityToUptakeStatus
=
{
[
BaseAction
.
suitability
.
SIGNATURE_ERROR
]
:
Uptake
.
RECIPE_INVALID_SIGNATURE
[
BaseAction
.
suitability
.
CAPABILITIES_MISMATCH
]
:
Uptake
.
RECIPE_INCOMPATIBLE_CAPABILITIES
[
BaseAction
.
suitability
.
FILTER_MATCH
]
:
Uptake
.
RECIPE_SUCCESS
[
BaseAction
.
suitability
.
FILTER_MISMATCH
]
:
Uptake
.
RECIPE_DIDNT_MATCH_FILTER
[
BaseAction
.
suitability
.
FILTER_ERROR
]
:
Uptake
.
RECIPE_FILTER_BROKEN
[
BaseAction
.
suitability
.
ARGUMENTS_INVALID
]
:
Uptake
.
RECIPE_ARGUMENTS_INVALID
}
;
