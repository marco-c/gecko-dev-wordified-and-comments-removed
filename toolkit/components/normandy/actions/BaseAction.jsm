ChromeUtils
.
defineModuleGetter
(
this
"
LogManager
"
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Uptake
"
"
resource
:
/
/
normandy
/
lib
/
Uptake
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
JsonSchemaValidator
"
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
JsonSchemaValidator
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
BaseAction
"
]
;
class
BaseAction
{
constructor
(
)
{
this
.
finalized
=
false
;
this
.
failed
=
false
;
this
.
log
=
LogManager
.
getLogger
(
action
.
{
this
.
name
}
)
;
try
{
this
.
_preExecution
(
)
;
}
catch
(
err
)
{
this
.
failed
=
true
;
err
.
message
=
Could
not
initialize
action
{
this
.
name
}
:
{
err
.
message
}
;
Cu
.
reportError
(
err
)
;
Uptake
.
reportAction
(
this
.
name
Uptake
.
ACTION_PRE_EXECUTION_ERROR
)
;
}
}
get
schema
(
)
{
return
{
type
:
"
object
"
properties
:
{
}
}
;
}
get
name
(
)
{
return
this
.
constructor
.
name
;
}
_preExecution
(
)
{
}
async
runRecipe
(
recipe
)
{
if
(
this
.
finalized
)
{
throw
new
Error
(
"
Action
has
already
been
finalized
"
)
;
}
if
(
this
.
failed
)
{
Uptake
.
reportRecipe
(
recipe
.
id
Uptake
.
RECIPE_ACTION_DISABLED
)
;
this
.
log
.
warn
(
Skipping
recipe
{
recipe
.
name
}
because
{
this
.
name
}
failed
during
preExecution
.
)
;
return
;
}
let
[
valid
validatedArguments
]
=
JsonSchemaValidator
.
validateAndParseParameters
(
recipe
.
arguments
this
.
schema
)
;
if
(
!
valid
)
{
Cu
.
reportError
(
new
Error
(
Arguments
do
not
match
schema
.
arguments
:
{
JSON
.
stringify
(
recipe
.
arguments
)
}
.
schema
:
{
JSON
.
stringify
(
this
.
schema
)
}
)
)
;
Uptake
.
reportRecipe
(
recipe
.
id
Uptake
.
RECIPE_EXECUTION_ERROR
)
;
return
;
}
recipe
.
arguments
=
validatedArguments
;
let
status
=
Uptake
.
RECIPE_SUCCESS
;
try
{
await
this
.
_run
(
recipe
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
status
=
Uptake
.
RECIPE_EXECUTION_ERROR
;
}
Uptake
.
reportRecipe
(
recipe
.
id
status
)
;
}
async
_run
(
recipe
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
async
finalize
(
)
{
if
(
this
.
finalized
)
{
throw
new
Error
(
"
Action
has
already
been
finalized
"
)
;
}
if
(
this
.
failed
)
{
this
.
log
.
info
(
Skipping
post
-
execution
hook
for
{
this
.
name
}
due
to
earlier
failure
.
)
;
return
;
}
let
status
=
Uptake
.
ACTION_SUCCESS
;
try
{
await
this
.
_finalize
(
)
;
}
catch
(
err
)
{
status
=
Uptake
.
ACTION_POST_EXECUTION_ERROR
;
err
.
message
=
Could
not
run
postExecution
hook
for
{
this
.
name
}
:
{
err
.
message
}
;
Cu
.
reportError
(
err
)
;
}
finally
{
this
.
finalized
=
true
;
Uptake
.
reportAction
(
this
.
name
status
)
;
}
}
async
_finalize
(
)
{
}
}
