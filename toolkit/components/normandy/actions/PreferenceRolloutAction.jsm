"
use
strict
"
;
const
{
BaseAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
BaseAction
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
TelemetryEnvironment
"
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PreferenceRollouts
"
"
resource
:
/
/
normandy
/
lib
/
PreferenceRollouts
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
PrefUtils
"
"
resource
:
/
/
normandy
/
lib
/
PrefUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
ActionSchemas
"
"
resource
:
/
/
normandy
/
actions
/
schemas
/
index
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
TelemetryEvents
"
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
NormandyUtils
"
"
resource
:
/
/
normandy
/
lib
/
NormandyUtils
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
PreferenceRolloutAction
"
]
;
const
PREFERENCE_TYPE_MAP
=
{
boolean
:
Services
.
prefs
.
PREF_BOOL
string
:
Services
.
prefs
.
PREF_STRING
number
:
Services
.
prefs
.
PREF_INT
}
;
class
PreferenceRolloutAction
extends
BaseAction
{
get
schema
(
)
{
return
lazy
.
ActionSchemas
[
"
preference
-
rollout
"
]
;
}
async
_run
(
recipe
)
{
const
args
=
recipe
.
arguments
;
if
(
lazy
.
PreferenceRollouts
.
GRADUATION_SET
.
has
(
args
.
slug
)
)
{
this
.
log
.
debug
(
Skipping
rollout
"
{
args
.
slug
}
"
because
it
is
in
the
graduation
set
.
)
;
return
;
}
await
this
.
_verifyRolloutPrefs
(
args
)
;
const
newRollout
=
{
slug
:
args
.
slug
state
:
"
active
"
preferences
:
args
.
preferences
.
map
(
(
{
preferenceName
value
}
)
=
>
(
{
preferenceName
value
previousValue
:
lazy
.
PrefUtils
.
getPref
(
preferenceName
{
branch
:
"
default
"
}
)
}
)
)
}
;
const
existingRollout
=
await
lazy
.
PreferenceRollouts
.
get
(
args
.
slug
)
;
if
(
existingRollout
)
{
const
anyChanged
=
await
this
.
_updatePrefsForExistingRollout
(
existingRollout
newRollout
)
;
if
(
anyChanged
)
{
await
lazy
.
PreferenceRollouts
.
update
(
newRollout
)
;
lazy
.
TelemetryEvents
.
sendEvent
(
"
update
"
"
preference_rollout
"
args
.
slug
{
previousState
:
existingRollout
.
state
enrollmentId
:
existingRollout
.
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
switch
(
existingRollout
.
state
)
{
case
lazy
.
PreferenceRollouts
.
STATE_ACTIVE
:
{
this
.
log
.
debug
(
Updated
preference
rollout
{
args
.
slug
}
)
;
break
;
}
case
lazy
.
PreferenceRollouts
.
STATE_GRADUATED
:
{
this
.
log
.
debug
(
Ungraduated
preference
rollout
{
args
.
slug
}
)
;
lazy
.
TelemetryEnvironment
.
setExperimentActive
(
args
.
slug
newRollout
.
state
{
type
:
"
normandy
-
prefrollout
"
}
)
;
break
;
}
default
:
{
Cu
.
reportError
(
new
Error
(
Updated
pref
rollout
in
unexpected
state
:
{
existingRollout
.
state
}
)
)
;
}
}
}
else
{
this
.
log
.
debug
(
No
updates
to
preference
rollout
{
args
.
slug
}
)
;
}
}
else
{
if
(
newRollout
.
preferences
.
every
(
(
{
value
previousValue
}
)
=
>
value
=
=
=
previousValue
)
)
{
lazy
.
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
preference_rollout
"
args
.
slug
{
reason
:
"
would
-
be
-
no
-
op
"
}
)
;
throw
new
Error
(
New
rollout
{
args
.
slug
}
does
not
change
any
preferences
.
)
;
}
let
enrollmentId
=
lazy
.
NormandyUtils
.
generateUuid
(
)
;
newRollout
.
enrollmentId
=
enrollmentId
;
await
lazy
.
PreferenceRollouts
.
add
(
newRollout
)
;
for
(
const
{
preferenceName
value
}
of
args
.
preferences
)
{
lazy
.
PrefUtils
.
setPref
(
preferenceName
value
{
branch
:
"
default
"
}
)
;
}
this
.
log
.
debug
(
Enrolled
in
preference
rollout
{
args
.
slug
}
)
;
lazy
.
TelemetryEnvironment
.
setExperimentActive
(
args
.
slug
newRollout
.
state
{
type
:
"
normandy
-
prefrollout
"
enrollmentId
:
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
lazy
.
TelemetryEvents
.
sendEvent
(
"
enroll
"
"
preference_rollout
"
args
.
slug
{
enrollmentId
:
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
}
async
_verifyRolloutPrefs
(
{
slug
preferences
}
)
{
const
existingManagedPrefs
=
new
Set
(
)
;
for
(
const
rollout
of
await
lazy
.
PreferenceRollouts
.
getAllActive
(
)
)
{
if
(
rollout
.
slug
=
=
=
slug
)
{
continue
;
}
for
(
const
prefSpec
of
rollout
.
preferences
)
{
existingManagedPrefs
.
add
(
prefSpec
.
preferenceName
)
;
}
}
for
(
const
prefSpec
of
preferences
)
{
if
(
existingManagedPrefs
.
has
(
prefSpec
.
preferenceName
)
)
{
lazy
.
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
preference_rollout
"
slug
{
reason
:
"
conflict
"
preference
:
prefSpec
.
preferenceName
}
)
;
throw
new
Error
(
Cannot
start
rollout
{
slug
}
.
Preference
{
prefSpec
.
preferenceName
}
is
already
managed
.
)
;
}
const
existingPrefType
=
Services
.
prefs
.
getPrefType
(
prefSpec
.
preferenceName
)
;
const
rolloutPrefType
=
PREFERENCE_TYPE_MAP
[
typeof
prefSpec
.
value
]
;
if
(
existingPrefType
!
=
=
Services
.
prefs
.
PREF_INVALID
&
&
existingPrefType
!
=
=
rolloutPrefType
)
{
lazy
.
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
preference_rollout
"
slug
{
reason
:
"
invalid
type
"
preference
:
prefSpec
.
preferenceName
}
)
;
throw
new
Error
(
Cannot
start
rollout
"
{
slug
}
"
on
"
{
prefSpec
.
preferenceName
}
"
.
+
Existing
preference
is
of
type
{
existingPrefType
}
but
rollout
+
specifies
type
{
rolloutPrefType
}
)
;
}
}
}
async
_updatePrefsForExistingRollout
(
existingRollout
newRollout
)
{
let
anyChanged
=
false
;
const
oldPrefSpecs
=
new
Map
(
existingRollout
.
preferences
.
map
(
p
=
>
[
p
.
preferenceName
p
]
)
)
;
const
newPrefSpecs
=
new
Map
(
newRollout
.
preferences
.
map
(
p
=
>
[
p
.
preferenceName
p
]
)
)
;
for
(
const
{
preferenceName
previousValue
}
of
oldPrefSpecs
.
values
(
)
)
{
if
(
!
newPrefSpecs
.
has
(
preferenceName
)
)
{
this
.
log
.
debug
(
updating
{
existingRollout
.
slug
}
:
{
preferenceName
}
no
longer
exists
)
;
anyChanged
=
true
;
lazy
.
PrefUtils
.
setPref
(
preferenceName
previousValue
{
branch
:
"
default
"
}
)
;
}
}
for
(
const
prefSpec
of
Object
.
values
(
newRollout
.
preferences
)
)
{
let
oldValue
=
null
;
if
(
oldPrefSpecs
.
has
(
prefSpec
.
preferenceName
)
)
{
let
oldPrefSpec
=
oldPrefSpecs
.
get
(
prefSpec
.
preferenceName
)
;
oldValue
=
oldPrefSpec
.
value
;
prefSpec
.
previousValue
=
oldPrefSpec
.
previousValue
;
}
if
(
oldValue
!
=
=
newPrefSpecs
.
get
(
prefSpec
.
preferenceName
)
.
value
)
{
anyChanged
=
true
;
this
.
log
.
debug
(
updating
{
existingRollout
.
slug
}
:
{
prefSpec
.
preferenceName
}
value
changed
from
{
oldValue
}
to
{
prefSpec
.
value
}
)
;
lazy
.
PrefUtils
.
setPref
(
prefSpec
.
preferenceName
prefSpec
.
value
{
branch
:
"
default
"
}
)
;
}
}
return
anyChanged
;
}
async
_finalize
(
)
{
await
lazy
.
PreferenceRollouts
.
saveStartupPrefs
(
)
;
}
}
