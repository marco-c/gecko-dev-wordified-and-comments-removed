"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
BaseAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
BaseAction
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
ActionSchemas
:
"
resource
:
/
/
normandy
/
actions
/
schemas
/
index
.
js
"
AddonStudies
:
"
resource
:
/
/
normandy
/
lib
/
AddonStudies
.
jsm
"
NormandyApi
:
"
resource
:
/
/
normandy
/
lib
/
NormandyApi
.
jsm
"
TelemetryEvents
:
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
AddonStudyAction
"
]
;
const
OPT_OUT_STUDIES_ENABLED_PREF
=
"
app
.
shield
.
optoutstudies
.
enabled
"
;
class
AddonStudyEnrollError
extends
Error
{
constructor
(
studyName
extra
)
{
let
message
;
let
{
reason
}
=
extra
;
switch
(
reason
)
{
case
"
conflicting
-
addon
-
id
"
:
{
message
=
"
an
add
-
on
with
this
ID
is
already
installed
"
;
break
;
}
case
"
download
-
failure
"
:
{
message
=
"
the
add
-
on
failed
to
download
"
;
break
;
}
case
"
metadata
-
mismatch
"
:
{
message
=
"
the
server
metadata
does
not
match
the
downloaded
add
-
on
"
;
break
;
}
case
"
install
-
failure
"
:
{
message
=
"
the
add
-
on
failed
to
install
"
;
break
;
}
default
:
{
throw
new
Error
(
Unexpected
AddonStudyEnrollError
reason
:
{
reason
}
)
;
}
}
super
(
Cannot
install
study
add
-
on
for
{
studyName
}
:
{
message
}
.
)
;
this
.
studyName
=
studyName
;
this
.
extra
=
extra
;
}
}
class
AddonStudyUpdateError
extends
Error
{
constructor
(
studyName
extra
)
{
let
message
;
let
{
reason
}
=
extra
;
switch
(
reason
)
{
case
"
addon
-
id
-
mismatch
"
:
{
message
=
"
new
add
-
on
ID
does
not
match
old
add
-
on
ID
"
;
break
;
}
case
"
addon
-
does
-
not
-
exist
"
:
{
message
=
"
an
add
-
on
with
this
ID
does
not
exist
"
;
break
;
}
case
"
no
-
downgrade
"
:
{
message
=
"
the
add
-
on
was
an
older
version
than
is
installed
"
;
break
;
}
case
"
metadata
-
mismatch
"
:
{
message
=
"
the
server
metadata
does
not
match
the
downloaded
add
-
on
"
;
break
;
}
case
"
download
-
failure
"
:
{
message
=
"
the
add
-
on
failed
to
download
"
;
break
;
}
case
"
install
-
failure
"
:
{
message
=
"
the
add
-
on
failed
to
install
"
;
break
;
}
default
:
{
throw
new
Error
(
Unexpected
AddonStudyUpdateError
reason
:
{
reason
}
)
;
}
}
super
(
Cannot
update
study
add
-
on
for
{
studyName
}
:
{
message
}
.
)
;
this
.
studyName
=
studyName
;
this
.
extra
=
extra
;
}
}
class
AddonStudyAction
extends
BaseAction
{
get
schema
(
)
{
return
ActionSchemas
[
"
addon
-
study
"
]
;
}
constructor
(
)
{
super
(
)
;
this
.
seenRecipeIds
=
new
Set
(
)
;
}
_preExecution
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
OPT_OUT_STUDIES_ENABLED_PREF
true
)
)
{
this
.
log
.
info
(
"
User
has
opted
-
out
of
opt
-
out
experiments
disabling
action
.
"
)
;
this
.
disable
(
)
;
}
}
async
_run
(
recipe
)
{
this
.
seenRecipeIds
.
add
(
recipe
.
id
)
;
const
hasStudy
=
await
AddonStudies
.
has
(
recipe
.
id
)
;
const
{
extensionApiId
}
=
recipe
.
arguments
;
const
extensionDetails
=
await
NormandyApi
.
fetchExtensionDetails
(
extensionApiId
)
;
if
(
hasStudy
)
{
await
this
.
update
(
recipe
extensionDetails
)
;
}
else
{
await
this
.
enroll
(
recipe
extensionDetails
)
;
}
}
async
_finalize
(
)
{
const
activeStudies
=
(
await
AddonStudies
.
getAll
(
)
)
.
filter
(
study
=
>
study
.
active
)
;
for
(
const
study
of
activeStudies
)
{
if
(
!
this
.
seenRecipeIds
.
has
(
study
.
recipeId
)
)
{
this
.
log
.
debug
(
Stopping
study
for
recipe
{
study
.
recipeId
}
)
;
try
{
await
this
.
unenroll
(
study
.
recipeId
"
recipe
-
not
-
seen
"
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
}
async
downloadAndInstall
(
recipe
extensionDetails
onInstallStarted
onComplete
onFailedInstall
errorClass
reportError
)
{
const
{
name
}
=
recipe
.
arguments
;
const
{
hash
hash_algorithm
}
=
extensionDetails
;
const
downloadDeferred
=
PromiseUtils
.
defer
(
)
;
const
installDeferred
=
PromiseUtils
.
defer
(
)
;
const
install
=
await
AddonManager
.
getInstallForURL
(
extensionDetails
.
xpi
{
hash
:
{
hash_algorithm
}
:
{
hash
}
telemetryInfo
:
{
source
:
"
internal
"
}
}
)
;
const
listener
=
{
onDownloadFailed
(
)
{
downloadDeferred
.
reject
(
new
errorClass
(
name
{
reason
:
"
download
-
failure
"
detail
:
AddonManager
.
errorToString
(
install
.
error
)
}
)
)
;
}
onDownloadEnded
(
)
{
downloadDeferred
.
resolve
(
)
;
return
false
;
}
onInstallFailed
(
)
{
installDeferred
.
reject
(
new
errorClass
(
name
{
reason
:
"
install
-
failure
"
detail
:
AddonManager
.
errorToString
(
install
.
error
)
}
)
)
;
}
onInstallEnded
(
)
{
installDeferred
.
resolve
(
)
;
}
}
;
listener
.
onInstallStarted
=
onInstallStarted
(
installDeferred
)
;
install
.
addListener
(
listener
)
;
try
{
install
.
install
(
)
;
await
downloadDeferred
.
promise
;
}
catch
(
err
)
{
reportError
(
err
)
;
install
.
removeListener
(
listener
)
;
throw
err
;
}
await
onComplete
(
install
listener
)
;
try
{
install
.
install
(
)
;
await
installDeferred
.
promise
;
}
catch
(
err
)
{
reportError
(
err
)
;
install
.
removeListener
(
listener
)
;
await
onFailedInstall
(
)
;
throw
err
;
}
install
.
removeListener
(
listener
)
;
return
[
install
.
addon
.
id
install
.
addon
.
version
]
;
}
async
enroll
(
recipe
extensionDetails
)
{
if
(
recipe
.
arguments
.
isEnrollmentPaused
)
{
return
;
}
const
{
extensionApiId
name
description
}
=
recipe
.
arguments
;
const
onInstallStarted
=
installDeferred
=
>
{
return
cbInstall
=
>
{
const
versionMatches
=
cbInstall
.
addon
.
version
=
=
=
extensionDetails
.
version
;
const
idMatches
=
cbInstall
.
addon
.
id
=
=
=
extensionDetails
.
extension_id
;
if
(
cbInstall
.
existingAddon
)
{
installDeferred
.
reject
(
new
AddonStudyEnrollError
(
name
{
reason
:
"
conflicting
-
addon
-
id
"
}
)
)
;
return
false
;
}
else
if
(
!
versionMatches
|
|
!
idMatches
)
{
installDeferred
.
reject
(
new
AddonStudyEnrollError
(
name
{
reason
:
"
metadata
-
mismatch
"
}
)
)
;
return
false
;
}
return
true
;
}
;
}
;
const
onComplete
=
async
(
install
listener
)
=
>
{
const
study
=
{
recipeId
:
recipe
.
id
name
description
addonId
:
install
.
addon
.
id
addonVersion
:
install
.
addon
.
version
addonUrl
:
extensionDetails
.
xpi
extensionApiId
extensionHash
:
extensionDetails
.
hash
extensionHashAlgorithm
:
extensionDetails
.
hash_algorithm
active
:
true
studyStartDate
:
new
Date
(
)
}
;
try
{
await
AddonStudies
.
add
(
study
)
;
}
catch
(
err
)
{
this
.
reportEnrollError
(
err
)
;
install
.
removeListener
(
listener
)
;
install
.
cancel
(
)
;
throw
err
;
}
}
;
const
onFailedInstall
=
async
(
)
=
>
{
await
AddonStudies
.
delete
(
recipe
.
id
)
;
}
;
const
[
installedId
installedVersion
]
=
await
this
.
downloadAndInstall
(
recipe
extensionDetails
onInstallStarted
onComplete
onFailedInstall
AddonStudyEnrollError
this
.
reportEnrollError
)
;
TelemetryEvents
.
sendEvent
(
"
enroll
"
"
addon_study
"
name
{
addonId
:
installedId
addonVersion
:
installedVersion
}
)
;
}
async
update
(
recipe
extensionDetails
)
{
const
study
=
await
AddonStudies
.
get
(
recipe
.
id
)
;
const
{
extensionApiId
name
}
=
recipe
.
arguments
;
let
error
;
if
(
study
.
addonId
!
=
=
extensionDetails
.
extension_id
)
{
error
=
new
AddonStudyUpdateError
(
name
{
reason
:
"
addon
-
id
-
mismatch
"
}
)
;
}
const
versionCompare
=
Services
.
vc
.
compare
(
study
.
addonVersion
extensionDetails
.
version
)
;
if
(
versionCompare
>
0
)
{
error
=
new
AddonStudyUpdateError
(
name
{
reason
:
"
no
-
downgrade
"
}
)
;
}
else
if
(
versionCompare
=
=
=
0
)
{
return
;
}
if
(
error
)
{
this
.
reportUpdateError
(
error
)
;
throw
error
;
}
const
onInstallStarted
=
installDeferred
=
>
{
return
cbInstall
=
>
{
const
versionMatches
=
cbInstall
.
addon
.
version
=
=
=
extensionDetails
.
version
;
const
idMatches
=
cbInstall
.
addon
.
id
=
=
=
extensionDetails
.
extension_id
;
if
(
!
cbInstall
.
existingAddon
)
{
installDeferred
.
reject
(
new
AddonStudyUpdateError
(
name
{
reason
:
"
addon
-
does
-
not
-
exist
"
}
)
)
;
return
false
;
}
else
if
(
!
versionMatches
|
|
!
idMatches
)
{
installDeferred
.
reject
(
new
AddonStudyUpdateError
(
name
{
reason
:
"
metadata
-
mismatch
"
}
)
)
;
return
false
;
}
return
true
;
}
;
}
;
const
onComplete
=
async
(
install
listener
)
=
>
{
try
{
await
AddonStudies
.
update
(
{
.
.
.
study
addonVersion
:
install
.
addon
.
version
addonUrl
:
extensionDetails
.
xpi
extensionHash
:
extensionDetails
.
hash
extensionHashAlgorithm
:
extensionDetails
.
hash_algorithm
extensionApiId
}
)
;
}
catch
(
err
)
{
this
.
reportUpdateError
(
err
)
;
install
.
removeListener
(
listener
)
;
install
.
cancel
(
)
;
throw
err
;
}
}
;
const
onFailedInstall
=
(
)
=
>
{
AddonStudies
.
update
(
study
)
;
}
;
const
[
installedId
installedVersion
]
=
await
this
.
downloadAndInstall
(
recipe
extensionDetails
onInstallStarted
onComplete
onFailedInstall
AddonStudyUpdateError
this
.
reportUpdateError
)
;
TelemetryEvents
.
sendEvent
(
"
update
"
"
addon_study
"
name
{
addonId
:
installedId
addonVersion
:
installedVersion
}
)
;
}
reportEnrollError
(
error
)
{
if
(
error
instanceof
AddonStudyEnrollError
)
{
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
addon_study
"
error
.
studyName
error
.
extra
)
;
}
else
{
const
safeErrorMessage
=
{
error
.
fileName
}
:
{
error
.
lineNumber
}
:
{
error
.
columnNumber
}
{
error
.
name
}
;
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
addon_study
"
error
.
studyName
{
reason
:
safeErrorMessage
.
slice
(
0
80
)
}
)
;
}
}
reportUpdateError
(
error
)
{
if
(
error
instanceof
AddonStudyUpdateError
)
{
TelemetryEvents
.
sendEvent
(
"
updateFailed
"
"
addon_study
"
error
.
studyName
error
.
extra
)
;
}
else
{
const
safeErrorMessage
=
{
error
.
fileName
}
:
{
error
.
lineNumber
}
:
{
error
.
columnNumber
}
{
error
.
name
}
;
TelemetryEvents
.
sendEvent
(
"
updateFailed
"
"
addon_study
"
error
.
studyName
{
reason
:
safeErrorMessage
.
slice
(
0
80
)
}
)
;
}
}
async
unenroll
(
recipeId
reason
=
"
unknown
"
)
{
const
study
=
await
AddonStudies
.
get
(
recipeId
)
;
if
(
!
study
)
{
throw
new
Error
(
No
study
found
for
recipe
{
recipeId
}
.
)
;
}
if
(
!
study
.
active
)
{
throw
new
Error
(
Cannot
stop
study
for
recipe
{
recipeId
}
;
it
is
already
inactive
.
)
;
}
await
AddonStudies
.
markAsEnded
(
study
reason
)
;
const
addon
=
await
AddonManager
.
getAddonByID
(
study
.
addonId
)
;
if
(
addon
)
{
await
addon
.
uninstall
(
)
;
}
else
{
this
.
log
.
warn
(
Could
not
uninstall
addon
{
study
.
addonId
}
for
recipe
{
study
.
recipeId
}
:
it
is
not
installed
.
)
;
}
}
}
