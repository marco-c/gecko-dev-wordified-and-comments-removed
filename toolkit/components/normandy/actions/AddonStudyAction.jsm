"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
BaseAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
BaseAction
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
ActionSchemas
:
"
resource
:
/
/
normandy
/
actions
/
schemas
/
index
.
js
"
AddonStudies
:
"
resource
:
/
/
normandy
/
lib
/
AddonStudies
.
jsm
"
TelemetryEvents
:
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
AddonStudyAction
"
]
;
const
OPT_OUT_STUDIES_ENABLED_PREF
=
"
app
.
shield
.
optoutstudies
.
enabled
"
;
class
AddonStudyEnrollError
extends
Error
{
constructor
(
studyName
extra
)
{
let
message
;
let
{
reason
}
=
extra
;
switch
(
reason
)
{
case
"
conflicting
-
addon
-
id
"
:
{
message
=
"
an
add
-
on
with
this
ID
is
already
installed
"
;
break
;
}
case
"
download
-
failure
"
:
{
message
=
"
the
add
-
on
failed
to
download
"
;
break
;
}
default
:
{
throw
new
Error
(
Unexpected
AddonStudyEnrollError
reason
:
{
reason
}
)
;
}
}
super
(
new
Error
(
Cannot
install
study
add
-
on
for
{
studyName
}
:
{
message
}
.
)
)
;
this
.
studyName
=
studyName
;
this
.
extra
=
extra
;
}
}
class
AddonStudyAction
extends
BaseAction
{
get
schema
(
)
{
return
ActionSchemas
[
"
addon
-
study
"
]
;
}
constructor
(
)
{
super
(
)
;
this
.
seenRecipeIds
=
new
Set
(
)
;
}
_preExecution
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
OPT_OUT_STUDIES_ENABLED_PREF
true
)
)
{
this
.
log
.
info
(
"
User
has
opted
-
out
of
opt
-
out
experiments
disabling
action
.
"
)
;
this
.
disable
(
)
;
}
}
async
_run
(
recipe
)
{
this
.
seenRecipeIds
.
add
(
recipe
.
id
)
;
const
hasStudy
=
await
AddonStudies
.
has
(
recipe
.
id
)
;
if
(
recipe
.
arguments
.
isEnrollmentPaused
|
|
hasStudy
)
{
return
;
}
await
this
.
enroll
(
recipe
)
;
}
async
_finalize
(
)
{
const
activeStudies
=
(
await
AddonStudies
.
getAll
(
)
)
.
filter
(
study
=
>
study
.
active
)
;
for
(
const
study
of
activeStudies
)
{
if
(
!
this
.
seenRecipeIds
.
has
(
study
.
recipeId
)
)
{
this
.
log
.
debug
(
Stopping
study
for
recipe
{
study
.
recipeId
}
)
;
try
{
await
this
.
unenroll
(
study
.
recipeId
"
recipe
-
not
-
seen
"
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
}
async
enroll
(
recipe
)
{
const
{
addonUrl
name
description
}
=
recipe
.
arguments
;
const
downloadDeferred
=
PromiseUtils
.
defer
(
)
;
const
installDeferred
=
PromiseUtils
.
defer
(
)
;
const
install
=
await
AddonManager
.
getInstallForURL
(
addonUrl
"
application
/
x
-
xpinstall
"
null
null
null
null
null
{
source
:
"
internal
"
}
)
;
const
listener
=
{
onDownloadFailed
(
)
{
downloadDeferred
.
reject
(
new
AddonStudyEnrollError
(
name
{
reason
:
"
download
-
failure
"
detail
:
AddonManager
.
errorToString
(
install
.
error
)
}
)
)
;
}
onDownloadEnded
(
)
{
downloadDeferred
.
resolve
(
)
;
return
false
;
}
onInstallStarted
(
cbInstall
)
{
if
(
cbInstall
.
existingAddon
)
{
installDeferred
.
reject
(
new
AddonStudyEnrollError
(
name
{
reason
:
"
conflicting
-
addon
-
id
"
}
)
)
;
return
false
;
}
return
true
;
}
onInstallFailed
(
)
{
installDeferred
.
reject
(
new
AddonStudyEnrollError
(
name
{
reason
:
"
failed
-
to
-
install
"
detail
:
AddonManager
.
errorToString
(
install
.
error
)
}
)
)
;
}
onInstallEnded
(
)
{
installDeferred
.
resolve
(
)
;
}
}
;
install
.
addListener
(
listener
)
;
try
{
install
.
install
(
)
;
await
downloadDeferred
.
promise
;
}
catch
(
err
)
{
this
.
reportEnrollError
(
err
)
;
install
.
removeListener
(
listener
)
;
return
;
}
const
addonId
=
install
.
addon
.
id
;
const
study
=
{
recipeId
:
recipe
.
id
name
description
addonId
addonVersion
:
install
.
addon
.
version
addonUrl
active
:
true
studyStartDate
:
new
Date
(
)
}
;
try
{
await
AddonStudies
.
add
(
study
)
;
}
catch
(
err
)
{
this
.
reportEnrollError
(
err
)
;
install
.
removeListener
(
listener
)
;
install
.
cancel
(
)
;
throw
err
;
}
try
{
install
.
install
(
)
;
await
installDeferred
.
promise
;
}
catch
(
err
)
{
this
.
reportEnrollError
(
err
)
;
install
.
removeListener
(
listener
)
;
await
AddonStudies
.
delete
(
recipe
.
id
)
;
throw
err
;
}
TelemetryEvents
.
sendEvent
(
"
enroll
"
"
addon_study
"
name
{
addonId
:
install
.
addon
.
id
addonVersion
:
install
.
addon
.
version
}
)
;
install
.
removeListener
(
listener
)
;
}
reportEnrollError
(
error
)
{
if
(
error
instanceof
AddonStudyEnrollError
)
{
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
addon_study
"
error
.
studyName
error
.
extra
)
;
}
else
{
const
safeErrorMessage
=
{
error
.
fileName
}
:
{
error
.
lineNumber
}
:
{
error
.
columnNumber
}
{
error
.
name
}
;
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
addon_study
"
error
.
studyName
{
reason
:
safeErrorMessage
.
slice
(
0
80
)
}
)
;
}
}
async
unenroll
(
recipeId
reason
=
"
unknown
"
)
{
const
study
=
await
AddonStudies
.
get
(
recipeId
)
;
if
(
!
study
)
{
throw
new
Error
(
No
study
found
for
recipe
{
recipeId
}
.
)
;
}
if
(
!
study
.
active
)
{
throw
new
Error
(
Cannot
stop
study
for
recipe
{
recipeId
}
;
it
is
already
inactive
.
)
;
}
await
AddonStudies
.
markAsEnded
(
study
reason
)
;
const
addon
=
await
AddonManager
.
getAddonByID
(
study
.
addonId
)
;
if
(
addon
)
{
await
addon
.
uninstall
(
)
;
}
else
{
this
.
log
.
warn
(
Could
not
uninstall
addon
{
study
.
addonId
}
for
recipe
{
study
.
recipeId
}
:
it
is
not
installed
.
)
;
}
}
}
