"
use
strict
"
;
const
{
PreferenceExperimentAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
PreferenceExperimentAction
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ActionSchemas
"
"
resource
:
/
/
normandy
/
actions
/
schemas
/
index
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
JsonSchemaValidator
"
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
JsonSchemaValidator
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
SinglePreferenceExperimentAction
"
]
;
class
SinglePreferenceExperimentAction
extends
PreferenceExperimentAction
{
get
schema
(
)
{
return
ActionSchemas
[
"
single
-
preference
-
experiment
"
]
;
}
async
_run
(
recipe
)
{
const
{
preferenceBranchType
preferenceName
preferenceType
branches
.
.
.
remainingArguments
}
=
recipe
.
arguments
;
const
newArguments
=
{
userFacingName
:
"
temp
-
name
"
userFacingDescription
:
"
temp
-
description
"
.
.
.
remainingArguments
branches
:
branches
.
map
(
branch
=
>
{
const
{
value
.
.
.
branchProps
}
=
branch
;
return
{
.
.
.
branchProps
preferences
:
{
[
preferenceName
]
:
{
preferenceBranchType
preferenceType
preferenceValue
:
value
}
}
}
;
}
)
}
;
const
multiprefSchema
=
ActionSchemas
[
"
multiple
-
preference
-
experiment
"
]
;
let
[
valid
validatedArguments
]
=
JsonSchemaValidator
.
validateAndParseParameters
(
newArguments
multiprefSchema
)
;
if
(
!
valid
)
{
throw
new
Error
(
Transformed
arguments
do
not
match
schema
.
Original
arguments
:
{
JSON
.
stringify
(
recipe
.
arguments
)
}
new
arguments
:
{
JSON
.
stringify
(
newArguments
)
}
schema
:
{
JSON
.
stringify
(
multiprefSchema
)
}
)
;
}
validatedArguments
.
userFacingName
=
null
;
validatedArguments
.
userFacingDescription
=
null
;
recipe
.
arguments
=
validatedArguments
;
const
newRecipe
=
{
.
.
.
recipe
arguments
:
validatedArguments
}
;
return
super
.
_run
(
newRecipe
)
;
}
}
