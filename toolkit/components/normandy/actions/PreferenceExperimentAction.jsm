"
use
strict
"
;
const
{
BaseStudyAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
BaseStudyAction
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Sampling
"
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
Sampling
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ActionSchemas
"
"
resource
:
/
/
normandy
/
actions
/
schemas
/
index
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BaseAction
"
"
resource
:
/
/
normandy
/
actions
/
BaseAction
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ClientEnvironment
"
"
resource
:
/
/
normandy
/
lib
/
ClientEnvironment
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PreferenceExperiments
"
"
resource
:
/
/
normandy
/
lib
/
PreferenceExperiments
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
PreferenceExperimentAction
"
]
;
class
PreferenceExperimentAction
extends
BaseStudyAction
{
get
schema
(
)
{
return
ActionSchemas
[
"
multi
-
preference
-
experiment
"
]
;
}
constructor
(
)
{
super
(
)
;
this
.
seenExperimentSlugs
=
new
Set
(
)
;
}
async
_processRecipe
(
recipe
suitability
)
{
const
{
branches
isHighPopulation
isEnrollmentPaused
slug
userFacingName
userFacingDescription
}
=
recipe
.
arguments
|
|
{
}
;
let
experiment
;
if
(
slug
)
{
this
.
seenExperimentSlugs
.
add
(
slug
)
;
try
{
experiment
=
await
PreferenceExperiments
.
get
(
slug
)
;
}
catch
(
err
)
{
if
(
!
(
err
instanceof
PreferenceExperiments
.
NotFoundError
)
)
{
throw
err
;
}
}
}
switch
(
suitability
)
{
case
BaseAction
.
suitability
.
SIGNATURE_ERROR
:
{
this
.
_considerTemporaryError
(
{
experiment
reason
:
"
signature
-
error
"
}
)
;
break
;
}
case
BaseAction
.
suitability
.
CAPABILITIES_MISMATCH
:
{
if
(
experiment
&
&
!
experiment
.
expired
)
{
await
PreferenceExperiments
.
stop
(
slug
{
resetValue
:
true
reason
:
"
capability
-
mismatch
"
caller
:
"
PreferenceExperimentAction
.
_processRecipe
:
:
capabilities_mismatch
"
}
)
;
}
break
;
}
case
BaseAction
.
suitability
.
FILTER_MATCH
:
{
if
(
!
experiment
)
{
const
activeExperiments
=
await
PreferenceExperiments
.
getAllActive
(
)
;
for
(
const
branch
of
branches
)
{
const
conflictingPrefs
=
Object
.
keys
(
branch
.
preferences
)
.
filter
(
preferenceName
=
>
{
return
activeExperiments
.
some
(
exp
=
>
exp
.
preferences
.
hasOwnProperty
(
preferenceName
)
)
;
}
)
;
if
(
conflictingPrefs
.
length
)
{
throw
new
Error
(
Experiment
{
slug
}
ignored
;
another
active
experiment
is
already
using
the
{
conflictingPrefs
[
0
]
}
preference
.
)
;
}
}
if
(
isEnrollmentPaused
)
{
this
.
log
.
debug
(
Enrollment
is
paused
for
experiment
"
{
slug
}
"
)
;
return
;
}
const
branch
=
await
this
.
chooseBranch
(
slug
branches
)
;
const
experimentType
=
isHighPopulation
?
"
exp
-
highpop
"
:
"
exp
"
;
await
PreferenceExperiments
.
start
(
{
slug
actionName
:
this
.
name
branch
:
branch
.
slug
preferences
:
branch
.
preferences
experimentType
userFacingName
userFacingDescription
}
)
;
}
else
if
(
experiment
.
expired
)
{
this
.
log
.
debug
(
Experiment
{
slug
}
has
expired
aborting
.
)
;
}
else
{
experiment
.
temporaryErrorDeadline
=
null
;
await
PreferenceExperiments
.
update
(
experiment
)
;
await
PreferenceExperiments
.
markLastSeen
(
slug
)
;
}
break
;
}
case
BaseAction
.
suitability
.
FILTER_MISMATCH
:
{
if
(
experiment
&
&
!
experiment
.
expired
)
{
await
PreferenceExperiments
.
stop
(
slug
{
resetValue
:
true
reason
:
"
filter
-
mismatch
"
caller
:
"
PreferenceExperimentAction
.
_processRecipe
:
:
filter_mismatch
"
}
)
;
}
break
;
}
case
BaseAction
.
suitability
.
FILTER_ERROR
:
{
this
.
_considerTemporaryError
(
{
experiment
reason
:
"
filter
-
error
"
}
)
;
break
;
}
case
BaseAction
.
suitability
.
ARGUMENTS_INVALID
:
{
if
(
experiment
&
&
!
experiment
.
expired
)
{
await
PreferenceExperiments
.
stop
(
slug
{
resetValue
:
true
reason
:
"
arguments
-
invalid
"
caller
:
"
PreferenceExperimentAction
.
_processRecipe
:
:
arguments_invalid
"
}
)
;
}
break
;
}
default
:
{
throw
new
Error
(
Unknown
recipe
suitability
"
{
suitability
}
"
.
)
;
}
}
}
async
_run
(
recipe
)
{
throw
new
Error
(
"
_run
shouldn
'
t
be
called
anymore
"
)
;
}
async
chooseBranch
(
slug
branches
)
{
const
ratios
=
branches
.
map
(
branch
=
>
branch
.
ratio
)
;
const
userId
=
ClientEnvironment
.
userId
;
const
input
=
{
userId
}
-
{
slug
}
-
branch
;
const
index
=
await
Sampling
.
ratioSample
(
input
ratios
)
;
return
branches
[
index
]
;
}
async
_finalize
(
{
noRecipes
}
=
{
}
)
{
const
activeExperiments
=
await
PreferenceExperiments
.
getAllActive
(
)
;
if
(
noRecipes
&
&
this
.
seenExperimentSlugs
.
size
)
{
throw
new
PreferenceExperimentAction
.
BadNoRecipesArg
(
)
;
}
return
Promise
.
all
(
activeExperiments
.
map
(
experiment
=
>
{
if
(
this
.
name
!
=
experiment
.
actionName
)
{
return
null
;
}
if
(
noRecipes
)
{
return
this
.
_considerTemporaryError
(
{
experiment
reason
:
"
no
-
recipes
"
}
)
;
}
if
(
this
.
seenExperimentSlugs
.
has
(
experiment
.
slug
)
)
{
return
null
;
}
return
PreferenceExperiments
.
stop
(
experiment
.
slug
{
resetValue
:
true
reason
:
"
recipe
-
not
-
seen
"
caller
:
"
PreferenceExperimentAction
.
_finalize
"
}
)
.
catch
(
e
=
>
{
this
.
log
.
warn
(
Stopping
experiment
{
experiment
.
slug
}
failed
:
{
e
}
)
;
}
)
;
}
)
)
;
}
async
_considerTemporaryError
(
{
experiment
reason
}
)
{
if
(
!
experiment
|
|
experiment
.
expired
)
{
return
;
}
let
now
=
Date
.
now
(
)
;
let
day
=
24
*
60
*
60
*
1000
;
let
newDeadline
=
new
Date
(
now
+
7
*
day
)
.
toJSON
(
)
;
if
(
experiment
.
temporaryErrorDeadline
)
{
let
deadline
=
new
Date
(
experiment
.
temporaryErrorDeadline
)
;
if
(
isNaN
(
deadline
)
)
{
experiment
.
temporaryErrorDeadline
=
newDeadline
;
await
PreferenceExperiments
.
update
(
experiment
)
;
return
;
}
if
(
now
>
deadline
)
{
await
PreferenceExperiments
.
stop
(
experiment
.
slug
{
resetValue
:
true
reason
caller
:
"
PreferenceExperimentAction
.
_considerTemporaryFailure
"
}
)
;
}
}
else
{
experiment
.
temporaryErrorDeadline
=
newDeadline
;
await
PreferenceExperiments
.
update
(
experiment
)
;
}
}
}
PreferenceExperimentAction
.
BadNoRecipesArg
=
class
extends
Error
{
message
=
"
noRecipes
is
true
but
some
recipes
observed
"
;
}
;
