"
use
strict
"
;
const
{
BaseStudyAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
BaseStudyAction
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Sampling
"
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
Sampling
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ActionSchemas
"
"
resource
:
/
/
normandy
/
actions
/
schemas
/
index
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ClientEnvironment
"
"
resource
:
/
/
normandy
/
lib
/
ClientEnvironment
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PreferenceExperiments
"
"
resource
:
/
/
normandy
/
lib
/
PreferenceExperiments
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
PreferenceExperimentAction
"
]
;
class
PreferenceExperimentAction
extends
BaseStudyAction
{
get
schema
(
)
{
return
ActionSchemas
[
"
multi
-
preference
-
experiment
"
]
;
}
constructor
(
)
{
super
(
)
;
this
.
seenExperimentSlugs
=
[
]
;
}
async
_run
(
recipe
)
{
const
{
branches
isHighPopulation
isEnrollmentPaused
slug
userFacingName
userFacingDescription
}
=
recipe
.
arguments
;
this
.
seenExperimentSlugs
.
push
(
slug
)
;
const
hasSlug
=
await
PreferenceExperiments
.
has
(
slug
)
;
if
(
!
hasSlug
)
{
const
activeExperiments
=
await
PreferenceExperiments
.
getAllActive
(
)
;
for
(
const
branch
of
branches
)
{
const
conflictingPrefs
=
Object
.
keys
(
branch
.
preferences
)
.
filter
(
preferenceName
=
>
{
return
activeExperiments
.
some
(
exp
=
>
exp
.
preferences
.
hasOwnProperty
(
preferenceName
)
)
;
}
)
;
if
(
conflictingPrefs
.
length
>
0
)
{
throw
new
Error
(
Experiment
{
slug
}
ignored
;
another
active
experiment
is
already
using
the
{
conflictingPrefs
[
0
]
}
preference
.
)
;
}
}
if
(
isEnrollmentPaused
)
{
this
.
log
.
debug
(
Enrollment
is
paused
for
experiment
"
{
slug
}
"
)
;
return
;
}
const
branch
=
await
this
.
chooseBranch
(
slug
branches
)
;
const
experimentType
=
isHighPopulation
?
"
exp
-
highpop
"
:
"
exp
"
;
await
PreferenceExperiments
.
start
(
{
slug
actionName
:
this
.
name
branch
:
branch
.
slug
preferences
:
branch
.
preferences
experimentType
userFacingName
userFacingDescription
}
)
;
}
else
{
const
experiment
=
await
PreferenceExperiments
.
get
(
slug
)
;
if
(
experiment
.
expired
)
{
this
.
log
.
debug
(
Experiment
{
slug
}
has
expired
aborting
.
)
;
}
else
{
await
PreferenceExperiments
.
markLastSeen
(
slug
)
;
}
}
}
async
chooseBranch
(
slug
branches
)
{
const
ratios
=
branches
.
map
(
branch
=
>
branch
.
ratio
)
;
const
userId
=
ClientEnvironment
.
userId
;
const
input
=
{
userId
}
-
{
slug
}
-
branch
;
const
index
=
await
Sampling
.
ratioSample
(
input
ratios
)
;
return
branches
[
index
]
;
}
async
_finalize
(
)
{
const
activeExperiments
=
await
PreferenceExperiments
.
getAllActive
(
)
;
return
Promise
.
all
(
activeExperiments
.
map
(
experiment
=
>
{
if
(
this
.
name
!
=
experiment
.
actionName
)
{
return
null
;
}
if
(
this
.
seenExperimentSlugs
.
includes
(
experiment
.
slug
)
)
{
return
null
;
}
return
PreferenceExperiments
.
stop
(
experiment
.
slug
{
resetValue
:
true
reason
:
"
recipe
-
not
-
seen
"
}
)
.
catch
(
e
=
>
{
this
.
log
.
warn
(
Stopping
experiment
{
experiment
.
slug
}
failed
:
{
e
}
)
;
}
)
;
}
)
)
;
}
}
