"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
BaseAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
BaseAction
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ActionSchemas
"
"
resource
:
/
/
normandy
/
actions
/
schemas
/
index
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserWindowTracker
"
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ClientEnvironment
"
"
resource
:
/
/
normandy
/
lib
/
ClientEnvironment
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Heartbeat
"
"
resource
:
/
/
normandy
/
lib
/
Heartbeat
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ShellService
"
"
resource
:
/
/
/
modules
/
ShellService
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Storage
"
"
resource
:
/
/
normandy
/
lib
/
Storage
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UpdateUtils
"
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
uuidGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
ShowHeartbeatAction
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gAllRecipeStorage
"
function
(
)
{
return
new
Storage
(
"
normandy
-
heartbeat
"
)
;
}
)
;
const
DAY_IN_MS
=
24
*
60
*
60
*
1000
;
const
HEARTBEAT_THROTTLE
=
1
*
DAY_IN_MS
;
class
ShowHeartbeatAction
extends
BaseAction
{
get
schema
(
)
{
return
ActionSchemas
[
"
show
-
heartbeat
"
]
;
}
async
_run
(
recipe
)
{
const
{
message
engagementButtonLabel
thanksMessage
learnMoreMessage
learnMoreUrl
}
=
recipe
.
arguments
;
const
recipeStorage
=
new
Storage
(
recipe
.
id
)
;
if
(
!
await
this
.
shouldShow
(
recipeStorage
recipe
)
)
{
return
;
}
this
.
log
.
debug
(
Heartbeat
for
recipe
{
recipe
.
id
}
showing
prompt
"
{
message
}
"
)
;
const
targetWindow
=
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
!
targetWindow
)
{
throw
new
Error
(
"
No
window
to
show
heartbeat
in
"
)
;
}
const
heartbeat
=
new
Heartbeat
(
targetWindow
{
surveyId
:
this
.
generateSurveyId
(
recipe
)
message
engagementButtonLabel
thanksMessage
learnMoreMessage
learnMoreUrl
postAnswerUrl
:
await
this
.
generatePostAnswerURL
(
recipe
)
flowId
:
this
.
uuid
(
)
surveyVersion
:
recipe
.
revision_id
}
)
;
heartbeat
.
eventEmitter
.
once
(
"
Voted
"
this
.
updateLastInteraction
.
bind
(
this
recipeStorage
)
)
;
heartbeat
.
eventEmitter
.
once
(
"
Engaged
"
this
.
updateLastInteraction
.
bind
(
this
recipeStorage
)
)
;
let
now
=
Date
.
now
(
)
;
await
Promise
.
all
(
[
gAllRecipeStorage
.
setItem
(
"
lastShown
"
now
)
recipeStorage
.
setItem
(
"
lastShown
"
now
)
]
)
;
}
async
shouldShow
(
recipeStorage
recipe
)
{
const
{
repeatOption
repeatEvery
}
=
recipe
.
arguments
;
let
lastShown
=
await
gAllRecipeStorage
.
getItem
(
"
lastShown
"
)
;
if
(
lastShown
)
{
const
duration
=
new
Date
(
)
-
lastShown
;
if
(
duration
<
HEARTBEAT_THROTTLE
)
{
const
hoursAgo
=
Math
.
floor
(
duration
/
1000
/
60
/
6
)
/
10
;
this
.
log
.
debug
(
A
heartbeat
was
shown
too
recently
(
{
hoursAgo
}
hours
)
skipping
recipe
{
recipe
.
id
}
.
)
;
return
false
;
}
}
switch
(
repeatOption
)
{
case
"
once
"
:
{
if
(
await
recipeStorage
.
getItem
(
"
lastShown
"
)
)
{
this
.
log
.
debug
(
Heartbeat
for
"
once
"
recipe
{
recipe
.
id
}
has
been
shown
before
skipping
.
)
;
return
false
;
}
}
case
"
nag
"
:
{
if
(
await
recipeStorage
.
getItem
(
"
lastInteraction
"
)
)
{
this
.
log
.
debug
(
Heartbeat
for
"
nag
"
recipe
{
recipe
.
id
}
has
already
been
interacted
with
skipping
.
)
;
return
false
;
}
}
case
"
xdays
"
:
{
let
lastShown
=
await
gAllRecipeStorage
.
getItem
(
"
lastShown
"
)
;
if
(
lastShown
)
{
lastShown
=
new
Date
(
lastShown
)
;
const
duration
=
new
Date
(
)
-
lastShown
;
if
(
duration
<
repeatEvery
*
DAY_IN_MS
)
{
const
hoursAgo
=
Math
.
floor
(
duration
/
1000
/
60
/
6
)
/
10
;
this
.
log
.
debug
(
Heartbeat
for
"
xdays
"
recipe
{
recipe
.
id
}
ran
in
the
last
{
repeatEvery
}
days
skipping
.
(
{
hoursAgo
}
hours
ago
)
)
;
return
false
;
}
}
}
}
return
true
;
}
generateSurveyId
(
recipe
)
{
const
{
includeTelemetryUUID
surveyId
}
=
recipe
.
arguments
;
if
(
includeTelemetryUUID
)
{
return
{
surveyId
}
:
:
{
ClientEnvironment
.
userId
}
;
}
return
surveyId
;
}
uuid
(
)
{
let
rv
=
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
;
return
rv
.
slice
(
1
rv
.
length
-
1
)
;
}
async
generatePostAnswerURL
(
recipe
)
{
const
{
postAnswerUrl
message
includeTelemetryUUID
}
=
recipe
.
arguments
;
if
(
!
postAnswerUrl
)
{
return
postAnswerUrl
;
}
const
userId
=
ClientEnvironment
.
userId
;
const
searchEngine
=
await
new
Promise
(
resolve
=
>
{
Services
.
search
.
init
(
rv
=
>
{
if
(
Components
.
isSuccessCode
(
rv
)
)
{
resolve
(
Services
.
search
.
defaultEngine
.
identifier
)
;
}
}
)
;
}
)
;
const
args
=
{
fxVersion
:
Services
.
appinfo
.
version
isDefaultBrowser
:
ShellService
.
isDefaultBrowser
(
)
?
1
:
0
searchEngine
source
:
"
heartbeat
"
surveyversion
:
Services
.
appinfo
.
version
syncSetup
:
Services
.
prefs
.
prefHasUserValue
(
"
services
.
sync
.
username
"
)
?
1
:
0
updateChannel
:
UpdateUtils
.
getUpdateChannel
(
false
)
utm_campaign
:
encodeURIComponent
(
message
.
replace
(
/
\
s
+
/
g
"
"
)
)
utm_medium
:
recipe
.
action
utm_source
:
"
firefox
"
}
;
if
(
includeTelemetryUUID
)
{
args
.
userId
=
userId
;
}
let
url
=
new
URL
(
postAnswerUrl
)
;
for
(
const
[
key
val
]
of
Object
.
entries
(
args
)
)
{
if
(
!
url
.
searchParams
.
has
(
key
)
)
{
url
.
searchParams
.
set
(
key
val
)
;
}
}
return
url
.
toString
(
)
;
}
updateLastInteraction
(
recipeStorage
)
{
recipeStorage
.
setItem
(
"
lastInteraction
"
Date
.
now
(
)
)
;
}
}
