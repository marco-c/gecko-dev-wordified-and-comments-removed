"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
BaseAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
BaseAction
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ActionSchemas
:
"
resource
:
/
/
normandy
/
actions
/
schemas
/
index
.
js
"
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
ClientEnvironment
:
"
resource
:
/
/
normandy
/
lib
/
ClientEnvironment
.
jsm
"
Heartbeat
:
"
resource
:
/
/
normandy
/
lib
/
Heartbeat
.
jsm
"
Storage
:
"
resource
:
/
/
normandy
/
lib
/
Storage
.
jsm
"
NormandyUtils
:
"
resource
:
/
/
normandy
/
lib
/
NormandyUtils
.
jsm
"
}
)
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
ShellService
:
"
resource
:
/
/
/
modules
/
ShellService
.
sys
.
mjs
"
UpdateUtils
:
"
resource
:
/
/
gre
/
modules
/
UpdateUtils
.
sys
.
mjs
"
}
)
;
const
EXPORTED_SYMBOLS
=
[
"
ShowHeartbeatAction
"
]
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gAllRecipeStorage
"
function
(
)
{
return
new
lazy
.
Storage
(
"
normandy
-
heartbeat
"
)
;
}
)
;
const
DAY_IN_MS
=
24
*
60
*
60
*
1000
;
const
HEARTBEAT_THROTTLE
=
1
*
DAY_IN_MS
;
class
ShowHeartbeatAction
extends
BaseAction
{
static
Heartbeat
=
lazy
.
Heartbeat
;
static
overrideHeartbeatForTests
(
newHeartbeat
)
{
if
(
newHeartbeat
)
{
this
.
Heartbeat
=
newHeartbeat
;
}
else
{
this
.
Heartbeat
=
lazy
.
Heartbeat
;
}
}
get
schema
(
)
{
return
lazy
.
ActionSchemas
[
"
show
-
heartbeat
"
]
;
}
async
_run
(
recipe
)
{
const
{
message
engagementButtonLabel
thanksMessage
learnMoreMessage
learnMoreUrl
}
=
recipe
.
arguments
;
const
recipeStorage
=
new
lazy
.
Storage
(
recipe
.
id
)
;
if
(
!
(
await
this
.
shouldShow
(
recipeStorage
recipe
)
)
)
{
return
;
}
this
.
log
.
debug
(
Heartbeat
for
recipe
{
recipe
.
id
}
showing
prompt
"
{
message
}
"
)
;
const
targetWindow
=
lazy
.
BrowserWindowTracker
.
getTopWindow
(
)
;
if
(
!
targetWindow
)
{
throw
new
Error
(
"
No
window
to
show
heartbeat
in
"
)
;
}
const
heartbeat
=
new
ShowHeartbeatAction
.
Heartbeat
(
targetWindow
{
surveyId
:
this
.
generateSurveyId
(
recipe
)
message
engagementButtonLabel
thanksMessage
learnMoreMessage
learnMoreUrl
postAnswerUrl
:
await
this
.
generatePostAnswerURL
(
recipe
)
flowId
:
lazy
.
NormandyUtils
.
generateUuid
(
)
.
.
.
(
Object
.
hasOwn
(
recipe
"
revision_id
"
)
?
{
surveyVersion
:
recipe
.
revision_id
}
:
{
}
)
}
)
;
heartbeat
.
eventEmitter
.
once
(
"
Voted
"
this
.
updateLastInteraction
.
bind
(
this
recipeStorage
)
)
;
heartbeat
.
eventEmitter
.
once
(
"
Engaged
"
this
.
updateLastInteraction
.
bind
(
this
recipeStorage
)
)
;
let
now
=
Date
.
now
(
)
;
await
Promise
.
all
(
[
lazy
.
gAllRecipeStorage
.
setItem
(
"
lastShown
"
now
)
recipeStorage
.
setItem
(
"
lastShown
"
now
)
]
)
;
}
async
shouldShow
(
recipeStorage
recipe
)
{
const
{
repeatOption
repeatEvery
}
=
recipe
.
arguments
;
let
lastShown
=
await
lazy
.
gAllRecipeStorage
.
getItem
(
"
lastShown
"
)
;
if
(
lastShown
)
{
const
duration
=
new
Date
(
)
-
lastShown
;
if
(
duration
<
HEARTBEAT_THROTTLE
)
{
const
hoursAgo
=
Math
.
floor
(
duration
/
1000
/
60
/
6
)
/
10
;
this
.
log
.
debug
(
A
heartbeat
was
shown
too
recently
(
{
hoursAgo
}
hours
)
skipping
recipe
{
recipe
.
id
}
.
)
;
return
false
;
}
}
switch
(
repeatOption
)
{
case
"
once
"
:
{
if
(
await
recipeStorage
.
getItem
(
"
lastShown
"
)
)
{
this
.
log
.
debug
(
Heartbeat
for
"
once
"
recipe
{
recipe
.
id
}
has
been
shown
before
skipping
.
)
;
return
false
;
}
break
;
}
case
"
nag
"
:
{
if
(
await
recipeStorage
.
getItem
(
"
lastInteraction
"
)
)
{
this
.
log
.
debug
(
Heartbeat
for
"
nag
"
recipe
{
recipe
.
id
}
has
already
been
interacted
with
skipping
.
)
;
return
false
;
}
break
;
}
case
"
xdays
"
:
{
let
lastShown
=
await
lazy
.
gAllRecipeStorage
.
getItem
(
"
lastShown
"
)
;
if
(
lastShown
)
{
lastShown
=
new
Date
(
lastShown
)
;
const
duration
=
new
Date
(
)
-
lastShown
;
if
(
duration
<
repeatEvery
*
DAY_IN_MS
)
{
const
hoursAgo
=
Math
.
floor
(
duration
/
1000
/
60
/
6
)
/
10
;
this
.
log
.
debug
(
Heartbeat
for
"
xdays
"
recipe
{
recipe
.
id
}
ran
in
the
last
{
repeatEvery
}
days
skipping
.
(
{
hoursAgo
}
hours
ago
)
)
;
return
false
;
}
}
}
}
return
true
;
}
generateSurveyId
(
recipe
)
{
const
{
includeTelemetryUUID
surveyId
}
=
recipe
.
arguments
;
if
(
includeTelemetryUUID
)
{
return
{
surveyId
}
:
:
{
lazy
.
ClientEnvironment
.
userId
}
;
}
return
surveyId
;
}
async
generatePostAnswerURL
(
recipe
)
{
const
{
postAnswerUrl
message
includeTelemetryUUID
}
=
recipe
.
arguments
;
if
(
!
postAnswerUrl
)
{
return
postAnswerUrl
;
}
const
userId
=
lazy
.
ClientEnvironment
.
userId
;
const
searchEngine
=
(
await
Services
.
search
.
getDefault
(
)
)
.
identifier
;
const
args
=
{
fxVersion
:
Services
.
appinfo
.
version
isDefaultBrowser
:
lazy
.
ShellService
.
isDefaultBrowser
(
)
?
1
:
0
searchEngine
source
:
"
heartbeat
"
surveyversion
:
Services
.
appinfo
.
version
syncSetup
:
Services
.
prefs
.
prefHasUserValue
(
"
services
.
sync
.
username
"
)
?
1
:
0
updateChannel
:
lazy
.
UpdateUtils
.
getUpdateChannel
(
false
)
utm_campaign
:
encodeURIComponent
(
message
.
replace
(
/
\
s
+
/
g
"
"
)
)
utm_medium
:
recipe
.
action
utm_source
:
"
firefox
"
}
;
if
(
includeTelemetryUUID
)
{
args
.
userId
=
userId
;
}
let
url
=
new
URL
(
postAnswerUrl
)
;
for
(
const
[
key
val
]
of
Object
.
entries
(
args
)
)
{
if
(
!
url
.
searchParams
.
has
(
key
)
)
{
url
.
searchParams
.
set
(
key
val
)
;
}
}
return
url
.
toString
(
)
;
}
updateLastInteraction
(
recipeStorage
)
{
recipeStorage
.
setItem
(
"
lastInteraction
"
Date
.
now
(
)
)
;
}
}
