"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
BaseStudyAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
BaseStudyAction
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ActionSchemas
:
"
resource
:
/
/
normandy
/
actions
/
schemas
/
index
.
js
"
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
AddonStudies
:
"
resource
:
/
/
normandy
/
lib
/
AddonStudies
.
jsm
"
ClientEnvironment
:
"
resource
:
/
/
normandy
/
lib
/
ClientEnvironment
.
jsm
"
NormandyApi
:
"
resource
:
/
/
normandy
/
lib
/
NormandyApi
.
jsm
"
NormandyUtils
:
"
resource
:
/
/
normandy
/
lib
/
NormandyUtils
.
jsm
"
PromiseUtils
:
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
Sampling
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
Sampling
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
TelemetryEvents
:
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
BranchedAddonStudyAction
"
]
;
class
AddonStudyEnrollError
extends
Error
{
constructor
(
studyName
extra
)
{
let
message
;
let
{
reason
}
=
extra
;
switch
(
reason
)
{
case
"
conflicting
-
addon
-
id
"
:
{
message
=
"
an
add
-
on
with
this
ID
is
already
installed
"
;
break
;
}
case
"
download
-
failure
"
:
{
message
=
"
the
add
-
on
failed
to
download
"
;
break
;
}
case
"
metadata
-
mismatch
"
:
{
message
=
"
the
server
metadata
does
not
match
the
downloaded
add
-
on
"
;
break
;
}
case
"
install
-
failure
"
:
{
message
=
"
the
add
-
on
failed
to
install
"
;
break
;
}
default
:
{
throw
new
Error
(
Unexpected
AddonStudyEnrollError
reason
:
{
reason
}
)
;
}
}
super
(
Cannot
install
study
add
-
on
for
{
studyName
}
:
{
message
}
.
)
;
this
.
studyName
=
studyName
;
this
.
extra
=
extra
;
}
}
class
AddonStudyUpdateError
extends
Error
{
constructor
(
studyName
extra
)
{
let
message
;
let
{
reason
}
=
extra
;
switch
(
reason
)
{
case
"
addon
-
id
-
mismatch
"
:
{
message
=
"
new
add
-
on
ID
does
not
match
old
add
-
on
ID
"
;
break
;
}
case
"
addon
-
does
-
not
-
exist
"
:
{
message
=
"
an
add
-
on
with
this
ID
does
not
exist
"
;
break
;
}
case
"
no
-
downgrade
"
:
{
message
=
"
the
add
-
on
was
an
older
version
than
is
installed
"
;
break
;
}
case
"
metadata
-
mismatch
"
:
{
message
=
"
the
server
metadata
does
not
match
the
downloaded
add
-
on
"
;
break
;
}
case
"
download
-
failure
"
:
{
message
=
"
the
add
-
on
failed
to
download
"
;
break
;
}
case
"
install
-
failure
"
:
{
message
=
"
the
add
-
on
failed
to
install
"
;
break
;
}
default
:
{
throw
new
Error
(
Unexpected
AddonStudyUpdateError
reason
:
{
reason
}
)
;
}
}
super
(
Cannot
update
study
add
-
on
for
{
studyName
}
:
{
message
}
.
)
;
this
.
studyName
=
studyName
;
this
.
extra
=
extra
;
}
}
class
BranchedAddonStudyAction
extends
BaseStudyAction
{
get
schema
(
)
{
return
ActionSchemas
[
"
branched
-
addon
-
study
"
]
;
}
constructor
(
)
{
super
(
)
;
this
.
seenRecipeIds
=
new
Set
(
)
;
}
async
_run
(
recipe
)
{
this
.
seenRecipeIds
.
add
(
recipe
.
id
)
;
const
study
=
await
AddonStudies
.
get
(
recipe
.
id
)
;
if
(
study
)
{
await
this
.
update
(
recipe
study
)
;
}
else
{
await
this
.
enroll
(
recipe
)
;
}
}
async
_finalize
(
)
{
const
activeStudies
=
await
AddonStudies
.
getAllActive
(
{
branched
:
AddonStudies
.
FILTER_BRANCHED_ONLY
}
)
;
for
(
const
study
of
activeStudies
)
{
if
(
!
this
.
seenRecipeIds
.
has
(
study
.
recipeId
)
)
{
this
.
log
.
debug
(
Stopping
branched
add
-
on
study
for
recipe
{
study
.
recipeId
}
)
;
try
{
await
this
.
unenroll
(
study
.
recipeId
"
recipe
-
not
-
seen
"
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
}
}
async
downloadAndInstall
(
{
recipe
extensionDetails
branchSlug
onInstallStarted
onComplete
onFailedInstall
errorClass
reportError
errorExtra
=
{
}
}
)
{
const
{
slug
}
=
recipe
.
arguments
;
const
{
hash
hash_algorithm
}
=
extensionDetails
;
const
downloadDeferred
=
PromiseUtils
.
defer
(
)
;
const
installDeferred
=
PromiseUtils
.
defer
(
)
;
const
install
=
await
AddonManager
.
getInstallForURL
(
extensionDetails
.
xpi
{
hash
:
{
hash_algorithm
}
:
{
hash
}
telemetryInfo
:
{
source
:
"
internal
"
}
}
)
;
const
listener
=
{
onDownloadFailed
(
)
{
downloadDeferred
.
reject
(
new
errorClass
(
slug
{
reason
:
"
download
-
failure
"
branch
:
branchSlug
detail
:
AddonManager
.
errorToString
(
install
.
error
)
.
.
.
errorExtra
}
)
)
;
}
onDownloadEnded
(
)
{
downloadDeferred
.
resolve
(
)
;
return
false
;
}
onInstallFailed
(
)
{
installDeferred
.
reject
(
new
errorClass
(
slug
{
reason
:
"
install
-
failure
"
branch
:
branchSlug
detail
:
AddonManager
.
errorToString
(
install
.
error
)
}
)
)
;
}
onInstallEnded
(
)
{
installDeferred
.
resolve
(
)
;
}
}
;
listener
.
onInstallStarted
=
onInstallStarted
(
installDeferred
)
;
install
.
addListener
(
listener
)
;
try
{
install
.
install
(
)
;
await
downloadDeferred
.
promise
;
}
catch
(
err
)
{
reportError
(
err
)
;
install
.
removeListener
(
listener
)
;
throw
err
;
}
await
onComplete
(
install
listener
)
;
try
{
install
.
install
(
)
;
await
installDeferred
.
promise
;
}
catch
(
err
)
{
reportError
(
err
)
;
install
.
removeListener
(
listener
)
;
await
onFailedInstall
(
)
;
throw
err
;
}
install
.
removeListener
(
listener
)
;
return
[
install
.
addon
.
id
install
.
addon
.
version
]
;
}
async
chooseBranch
(
{
slug
branches
}
)
{
const
ratios
=
branches
.
map
(
branch
=
>
branch
.
ratio
)
;
const
userId
=
ClientEnvironment
.
userId
;
const
input
=
{
userId
}
-
{
slug
}
-
addon
-
branch
;
const
index
=
await
Sampling
.
ratioSample
(
input
ratios
)
;
return
branches
[
index
]
;
}
async
enroll
(
recipe
)
{
if
(
recipe
.
arguments
.
isEnrollmentPaused
)
{
return
;
}
const
{
slug
userFacingName
userFacingDescription
}
=
recipe
.
arguments
;
const
branch
=
await
this
.
chooseBranch
(
{
slug
:
recipe
.
arguments
.
slug
branches
:
recipe
.
arguments
.
branches
}
)
;
this
.
log
.
debug
(
Enrolling
in
branch
{
branch
.
slug
}
)
;
const
enrollmentId
=
NormandyUtils
.
generateUuid
(
)
;
if
(
branch
.
extensionApiId
=
=
=
null
)
{
const
study
=
{
recipeId
:
recipe
.
id
slug
userFacingName
userFacingDescription
branch
:
branch
.
slug
addonId
:
null
addonVersion
:
null
addonUrl
:
null
extensionApiId
:
null
extensionHash
:
null
extensionHashAlgorithm
:
null
active
:
true
studyStartDate
:
new
Date
(
)
studyEndDate
:
null
enrollmentId
}
;
try
{
await
AddonStudies
.
add
(
study
)
;
}
catch
(
err
)
{
this
.
reportEnrollError
(
err
)
;
throw
err
;
}
TelemetryEvents
.
sendEvent
(
"
enroll
"
"
addon_study
"
slug
{
addonId
:
AddonStudies
.
NO_ADDON_MARKER
addonVersion
:
AddonStudies
.
NO_ADDON_MARKER
branch
:
branch
.
slug
enrollmentId
:
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
else
{
const
extensionDetails
=
await
NormandyApi
.
fetchExtensionDetails
(
branch
.
extensionApiId
)
;
const
onInstallStarted
=
installDeferred
=
>
cbInstall
=
>
{
const
versionMatches
=
cbInstall
.
addon
.
version
=
=
=
extensionDetails
.
version
;
const
idMatches
=
cbInstall
.
addon
.
id
=
=
=
extensionDetails
.
extension_id
;
if
(
cbInstall
.
existingAddon
)
{
installDeferred
.
reject
(
new
AddonStudyEnrollError
(
slug
{
reason
:
"
conflicting
-
addon
-
id
"
branch
:
branch
.
slug
}
)
)
;
return
false
;
}
else
if
(
!
versionMatches
|
|
!
idMatches
)
{
installDeferred
.
reject
(
new
AddonStudyEnrollError
(
slug
{
branch
:
branch
.
slug
reason
:
"
metadata
-
mismatch
"
}
)
)
;
return
false
;
}
return
true
;
}
;
let
study
;
const
onComplete
=
async
(
install
listener
)
=
>
{
study
=
{
recipeId
:
recipe
.
id
slug
userFacingName
userFacingDescription
branch
:
branch
.
slug
addonId
:
install
.
addon
.
id
addonVersion
:
install
.
addon
.
version
addonUrl
:
extensionDetails
.
xpi
extensionApiId
:
branch
.
extensionApiId
extensionHash
:
extensionDetails
.
hash
extensionHashAlgorithm
:
extensionDetails
.
hash_algorithm
active
:
true
studyStartDate
:
new
Date
(
)
studyEndDate
:
null
enrollmentId
}
;
try
{
await
AddonStudies
.
add
(
study
)
;
}
catch
(
err
)
{
this
.
reportEnrollError
(
err
)
;
install
.
removeListener
(
listener
)
;
install
.
cancel
(
)
;
throw
err
;
}
}
;
const
onFailedInstall
=
async
(
)
=
>
{
await
AddonStudies
.
delete
(
recipe
.
id
)
;
}
;
const
[
installedId
installedVersion
]
=
await
this
.
downloadAndInstall
(
{
recipe
branchSlug
:
branch
.
slug
extensionDetails
onInstallStarted
onComplete
onFailedInstall
errorClass
:
AddonStudyEnrollError
reportError
:
this
.
reportEnrollError
}
)
;
TelemetryEvents
.
sendEvent
(
"
enroll
"
"
addon_study
"
slug
{
addonId
:
installedId
addonVersion
:
installedVersion
branch
:
branch
.
slug
enrollmentId
:
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
TelemetryEnvironment
.
setExperimentActive
(
slug
branch
.
slug
{
type
:
"
normandy
-
addonstudy
"
enrollmentId
:
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
async
update
(
recipe
study
)
{
const
{
slug
}
=
recipe
.
arguments
;
const
branch
=
recipe
.
arguments
.
branches
.
find
(
branch
=
>
branch
.
slug
=
=
=
study
.
branch
)
;
if
(
!
branch
)
{
await
this
.
unenroll
(
recipe
.
id
"
branch
-
removed
"
)
;
return
;
}
const
extensionDetails
=
await
NormandyApi
.
fetchExtensionDetails
(
branch
.
extensionApiId
)
;
let
error
;
if
(
study
.
addonId
&
&
study
.
addonId
!
=
=
extensionDetails
.
extension_id
)
{
error
=
new
AddonStudyUpdateError
(
slug
{
branch
:
branch
.
slug
reason
:
"
addon
-
id
-
mismatch
"
enrollmentId
:
study
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
const
versionCompare
=
Services
.
vc
.
compare
(
study
.
addonVersion
extensionDetails
.
version
)
;
if
(
versionCompare
>
0
)
{
error
=
new
AddonStudyUpdateError
(
slug
{
branch
:
branch
.
slug
reason
:
"
no
-
downgrade
"
enrollmentId
:
study
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
else
if
(
versionCompare
=
=
=
0
)
{
return
;
}
if
(
error
)
{
this
.
reportUpdateError
(
error
)
;
throw
error
;
}
const
onInstallStarted
=
installDeferred
=
>
cbInstall
=
>
{
const
versionMatches
=
cbInstall
.
addon
.
version
=
=
=
extensionDetails
.
version
;
const
idMatches
=
cbInstall
.
addon
.
id
=
=
=
extensionDetails
.
extension_id
;
if
(
!
cbInstall
.
existingAddon
)
{
installDeferred
.
reject
(
new
AddonStudyUpdateError
(
slug
{
branch
:
branch
.
slug
reason
:
"
addon
-
does
-
not
-
exist
"
enrollmentId
:
study
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
)
;
return
false
;
}
else
if
(
!
versionMatches
|
|
!
idMatches
)
{
installDeferred
.
reject
(
new
AddonStudyUpdateError
(
slug
{
branch
:
branch
.
slug
reason
:
"
metadata
-
mismatch
"
enrollmentId
:
study
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
)
;
return
false
;
}
return
true
;
}
;
const
onComplete
=
async
(
install
listener
)
=
>
{
try
{
await
AddonStudies
.
update
(
{
.
.
.
study
addonVersion
:
install
.
addon
.
version
addonUrl
:
extensionDetails
.
xpi
extensionHash
:
extensionDetails
.
hash
extensionHashAlgorithm
:
extensionDetails
.
hash_algorithm
extensionApiId
:
branch
.
extensionApiId
}
)
;
}
catch
(
err
)
{
this
.
reportUpdateError
(
err
)
;
install
.
removeListener
(
listener
)
;
install
.
cancel
(
)
;
throw
err
;
}
}
;
const
onFailedInstall
=
(
)
=
>
{
AddonStudies
.
update
(
study
)
;
}
;
const
[
installedId
installedVersion
]
=
await
this
.
downloadAndInstall
(
{
recipe
extensionDetails
branchSlug
:
branch
.
slug
onInstallStarted
onComplete
onFailedInstall
errorClass
:
AddonStudyUpdateError
reportError
:
this
.
reportUpdateError
errorExtra
:
{
enrollmentId
:
study
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
}
)
;
TelemetryEvents
.
sendEvent
(
"
update
"
"
addon_study
"
slug
{
addonId
:
installedId
addonVersion
:
installedVersion
branch
:
branch
.
slug
enrollmentId
:
study
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
reportEnrollError
(
error
)
{
if
(
error
instanceof
AddonStudyEnrollError
)
{
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
addon_study
"
error
.
studyName
error
.
extra
)
;
}
else
{
const
safeErrorMessage
=
{
error
.
fileName
}
:
{
error
.
lineNumber
}
:
{
error
.
columnNumber
}
{
error
.
name
}
;
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
addon_study
"
error
.
studyName
{
reason
:
safeErrorMessage
.
slice
(
0
80
)
}
)
;
}
}
reportUpdateError
(
error
)
{
if
(
error
instanceof
AddonStudyUpdateError
)
{
TelemetryEvents
.
sendEvent
(
"
updateFailed
"
"
addon_study
"
error
.
studyName
error
.
extra
)
;
}
else
{
const
safeErrorMessage
=
{
error
.
fileName
}
:
{
error
.
lineNumber
}
:
{
error
.
columnNumber
}
{
error
.
name
}
;
TelemetryEvents
.
sendEvent
(
"
updateFailed
"
"
addon_study
"
error
.
studyName
{
reason
:
safeErrorMessage
.
slice
(
0
80
)
}
)
;
}
}
async
unenroll
(
recipeId
reason
=
"
unknown
"
)
{
const
study
=
await
AddonStudies
.
get
(
recipeId
)
;
if
(
!
study
)
{
throw
new
Error
(
No
study
found
for
recipe
{
recipeId
}
.
)
;
}
if
(
!
study
.
active
)
{
throw
new
Error
(
Cannot
stop
study
for
recipe
{
recipeId
}
;
it
is
already
inactive
.
)
;
}
await
AddonStudies
.
markAsEnded
(
study
reason
)
;
if
(
study
.
addonId
)
{
const
addon
=
await
AddonManager
.
getAddonByID
(
study
.
addonId
)
;
if
(
addon
)
{
await
addon
.
uninstall
(
)
;
}
else
{
this
.
log
.
warn
(
Could
not
uninstall
addon
{
study
.
addonId
}
for
recipe
{
study
.
recipeId
}
:
it
is
not
installed
.
)
;
}
}
}
}
