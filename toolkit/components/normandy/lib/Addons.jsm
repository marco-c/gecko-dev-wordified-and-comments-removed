"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
Addons
"
]
;
var
Addons
=
{
async
get
(
addonId
)
{
const
addon
=
await
AddonManager
.
getAddonByID
(
addonId
)
;
if
(
!
addon
)
{
return
null
;
}
return
this
.
serializeForSandbox
(
addon
)
;
}
async
install
(
addonUrl
options
)
{
const
installObj
=
await
AddonManager
.
getInstallForURL
(
addonUrl
"
application
/
x
-
xpinstall
"
)
;
return
this
.
applyInstall
(
installObj
options
)
;
}
async
applyInstall
(
addonInstall
{
update
=
false
}
=
{
}
)
{
const
result
=
new
Promise
(
(
resolve
reject
)
=
>
addonInstall
.
addListener
(
{
onInstallStarted
(
cbInstall
)
{
if
(
cbInstall
.
existingAddon
&
&
!
update
)
{
reject
(
new
Error
(
Cannot
install
add
-
on
{
cbInstall
.
addon
.
id
}
;
an
existing
add
-
on
with
the
same
ID
exists
and
updating
is
disabled
.
)
)
;
return
false
;
}
return
true
;
}
onInstallEnded
(
cbInstall
addon
)
{
resolve
(
addon
.
id
)
;
}
onInstallFailed
(
cbInstall
)
{
reject
(
new
Error
(
AddonInstall
error
code
:
[
{
cbInstall
.
error
}
]
)
)
;
}
onDownloadFailed
(
cbInstall
)
{
reject
(
new
Error
(
Download
failed
:
[
{
cbInstall
.
sourceURI
.
spec
}
]
)
)
;
}
}
)
)
;
addonInstall
.
install
(
)
;
return
result
;
}
async
uninstall
(
addonId
)
{
const
addon
=
await
AddonManager
.
getAddonByID
(
addonId
)
;
if
(
addon
=
=
=
null
)
{
throw
new
Error
(
No
addon
with
ID
[
{
addonId
}
]
found
.
)
;
}
addon
.
uninstall
(
)
;
return
null
;
}
serializeForSandbox
(
addon
)
{
return
{
id
:
addon
.
id
installDate
:
new
Date
(
addon
.
installDate
)
isActive
:
addon
.
isActive
name
:
addon
.
name
type
:
addon
.
type
version
:
addon
.
version
}
;
}
}
;
