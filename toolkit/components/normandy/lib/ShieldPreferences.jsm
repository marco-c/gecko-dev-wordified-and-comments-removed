"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BranchedAddonStudyAction
:
"
resource
:
/
/
normandy
/
actions
/
BranchedAddonStudyAction
.
jsm
"
AddonStudies
:
"
resource
:
/
/
normandy
/
lib
/
AddonStudies
.
jsm
"
CleanupManager
:
"
resource
:
/
/
normandy
/
lib
/
CleanupManager
.
jsm
"
PreferenceExperiments
:
"
resource
:
/
/
normandy
/
lib
/
PreferenceExperiments
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
ShieldPreferences
"
]
;
const
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
=
"
nsPref
:
changed
"
;
const
PREF_OPT_OUT_STUDIES_ENABLED
=
"
app
.
shield
.
optoutstudies
.
enabled
"
;
var
ShieldPreferences
=
{
init
(
)
{
Services
.
prefs
.
addObserver
(
PREF_OPT_OUT_STUDIES_ENABLED
this
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
{
Services
.
prefs
.
removeObserver
(
PREF_OPT_OUT_STUDIES_ENABLED
this
)
;
}
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
:
this
.
observePrefChange
(
data
)
;
break
;
}
}
async
observePrefChange
(
prefName
)
{
let
prefValue
;
switch
(
prefName
)
{
case
PREF_OPT_OUT_STUDIES_ENABLED
:
{
prefValue
=
Services
.
prefs
.
getBoolPref
(
PREF_OPT_OUT_STUDIES_ENABLED
)
;
if
(
!
prefValue
)
{
const
action
=
new
BranchedAddonStudyAction
(
)
;
const
studyPromises
=
(
await
AddonStudies
.
getAll
(
)
)
.
map
(
study
=
>
{
if
(
!
study
.
active
)
{
return
null
;
}
return
action
.
unenroll
(
study
.
recipeId
"
general
-
opt
-
out
"
)
;
}
)
;
const
experimentPromises
=
(
await
PreferenceExperiments
.
getAll
(
)
)
.
map
(
experiment
=
>
{
if
(
experiment
.
expired
)
{
return
null
;
}
return
PreferenceExperiments
.
stop
(
experiment
.
slug
{
reason
:
"
general
-
opt
-
out
"
caller
:
"
observePrefChange
:
:
general
-
opt
-
out
"
}
)
;
}
)
;
const
allPromises
=
studyPromises
.
concat
(
experimentPromises
)
.
map
(
p
=
>
p
&
&
p
.
catch
(
err
=
>
Cu
.
reportError
(
err
)
)
)
;
await
Promise
.
all
(
allPromises
)
;
}
break
;
}
}
}
}
;
