"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
CleanupManager
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
EventEmitter
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URL
"
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
Heartbeat
"
]
;
const
PREF_SURVEY_DURATION
=
"
browser
.
uitour
.
surveyDuration
"
;
const
NOTIFICATION_TIME
=
3000
;
const
HEARTBEAT_CSS_URI
=
Services
.
io
.
newURI
(
"
resource
:
/
/
normandy
/
skin
/
shared
/
Heartbeat
.
css
"
)
;
const
HEARTBEAT_CSS_URI_OSX
=
Services
.
io
.
newURI
(
"
resource
:
/
/
normandy
/
skin
/
osx
/
Heartbeat
.
css
"
)
;
const
log
=
LogManager
.
getLogger
(
"
heartbeat
"
)
;
const
windowsWithInjectedCss
=
new
WeakSet
(
)
;
let
anyWindowsWithInjectedCss
=
false
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
{
if
(
anyWindowsWithInjectedCss
)
{
const
windowEnumerator
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
windowEnumerator
.
hasMoreElements
(
)
)
{
const
window
=
windowEnumerator
.
getNext
(
)
;
if
(
windowsWithInjectedCss
.
has
(
window
)
)
{
const
utils
=
window
.
windowUtils
;
utils
.
removeSheet
(
HEARTBEAT_CSS_URI
window
.
AGENT_SHEET
)
;
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
utils
.
removeSheet
(
HEARTBEAT_CSS_URI_OSX
window
.
AGENT_SHEET
)
;
}
windowsWithInjectedCss
.
delete
(
window
)
;
}
}
}
}
)
;
var
Heartbeat
=
class
{
constructor
(
chromeWindow
sandboxManager
options
)
{
if
(
typeof
options
.
flowId
!
=
=
"
string
"
)
{
throw
new
Error
(
"
flowId
must
be
a
string
"
)
;
}
if
(
!
options
.
flowId
)
{
throw
new
Error
(
"
flowId
must
not
be
an
empty
string
"
)
;
}
if
(
typeof
options
.
message
!
=
=
"
string
"
)
{
throw
new
Error
(
"
message
must
be
a
string
"
)
;
}
if
(
!
options
.
message
)
{
throw
new
Error
(
"
message
must
not
be
an
empty
string
"
)
;
}
if
(
!
sandboxManager
)
{
throw
new
Error
(
"
sandboxManager
must
be
provided
"
)
;
}
if
(
options
.
postAnswerUrl
)
{
options
.
postAnswerUrl
=
new
URL
(
options
.
postAnswerUrl
)
;
}
else
{
options
.
postAnswerUrl
=
null
;
}
if
(
options
.
learnMoreUrl
)
{
try
{
options
.
learnMoreUrl
=
new
URL
(
options
.
learnMoreUrl
)
;
}
catch
(
e
)
{
options
.
learnMoreUrl
=
null
;
}
}
this
.
chromeWindow
=
chromeWindow
;
this
.
eventEmitter
=
new
EventEmitter
(
sandboxManager
)
;
this
.
sandboxManager
=
sandboxManager
;
this
.
options
=
options
;
this
.
surveyResults
=
{
}
;
this
.
buttons
=
null
;
if
(
!
windowsWithInjectedCss
.
has
(
chromeWindow
)
)
{
windowsWithInjectedCss
.
add
(
chromeWindow
)
;
const
utils
=
chromeWindow
.
windowUtils
;
utils
.
loadSheet
(
HEARTBEAT_CSS_URI
chromeWindow
.
AGENT_SHEET
)
;
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
utils
.
loadSheet
(
HEARTBEAT_CSS_URI_OSX
chromeWindow
.
AGENT_SHEET
)
;
}
anyWindowsWithInjectedCss
=
true
;
}
this
.
handleWindowClosed
=
this
.
handleWindowClosed
.
bind
(
this
)
;
this
.
close
=
this
.
close
.
bind
(
this
)
;
if
(
this
.
options
.
engagementButtonLabel
)
{
this
.
buttons
=
[
{
label
:
this
.
options
.
engagementButtonLabel
callback
:
(
)
=
>
{
this
.
maybeNotifyHeartbeat
(
"
Engaged
"
)
;
this
.
userEngaged
(
{
type
:
"
button
"
flowId
:
this
.
options
.
flowId
}
)
;
return
true
;
}
}
]
;
}
this
.
notificationBox
=
this
.
chromeWindow
.
document
.
querySelector
(
"
#
high
-
priority
-
global
-
notificationbox
"
)
;
this
.
notice
=
this
.
notificationBox
.
appendNotification
(
this
.
options
.
message
"
heartbeat
-
"
+
this
.
options
.
flowId
"
resource
:
/
/
normandy
/
skin
/
shared
/
heartbeat
-
icon
.
svg
"
this
.
notificationBox
.
PRIORITY_INFO_HIGH
this
.
buttons
eventType
=
>
{
if
(
eventType
!
=
=
"
removed
"
)
{
return
;
}
this
.
maybeNotifyHeartbeat
(
"
NotificationClosed
"
)
;
}
)
;
const
frag
=
this
.
chromeWindow
.
document
.
createDocumentFragment
(
)
;
if
(
!
this
.
options
.
engagementButtonLabel
)
{
const
numStars
=
this
.
options
.
engagementButtonLabel
?
0
:
5
;
const
ratingContainer
=
this
.
chromeWindow
.
document
.
createElement
(
"
hbox
"
)
;
ratingContainer
.
id
=
"
star
-
rating
-
container
"
;
for
(
let
i
=
0
;
i
<
numStars
;
i
+
+
)
{
const
ratingElement
=
this
.
chromeWindow
.
document
.
createElement
(
"
toolbarbutton
"
)
;
const
starIndex
=
numStars
-
i
;
ratingElement
.
className
=
"
plain
star
-
x
"
;
ratingElement
.
id
=
"
star
"
+
starIndex
;
ratingElement
.
setAttribute
(
"
data
-
score
"
starIndex
)
;
ratingElement
.
addEventListener
(
"
click
"
ev
=
>
{
const
rating
=
parseInt
(
ev
.
target
.
getAttribute
(
"
data
-
score
"
)
)
;
this
.
maybeNotifyHeartbeat
(
"
Voted
"
{
score
:
rating
}
)
;
this
.
userEngaged
(
{
type
:
"
stars
"
score
:
rating
flowId
:
this
.
options
.
flowId
}
)
;
}
)
;
ratingContainer
.
appendChild
(
ratingElement
)
;
}
frag
.
appendChild
(
ratingContainer
)
;
}
const
details
=
this
.
chromeWindow
.
document
.
getAnonymousElementByAttribute
(
this
.
notice
"
anonid
"
"
details
"
)
;
details
.
style
.
overflow
=
"
hidden
"
;
this
.
messageImage
=
this
.
chromeWindow
.
document
.
getAnonymousElementByAttribute
(
this
.
notice
"
anonid
"
"
messageImage
"
)
;
this
.
messageImage
.
classList
.
add
(
"
heartbeat
"
"
pulse
-
onshow
"
)
;
this
.
messageText
=
this
.
chromeWindow
.
document
.
getAnonymousElementByAttribute
(
this
.
notice
"
anonid
"
"
messageText
"
)
;
this
.
messageText
.
classList
.
add
(
"
heartbeat
"
)
;
const
rightSpacer
=
this
.
chromeWindow
.
document
.
createElement
(
"
spacer
"
)
;
rightSpacer
.
flex
=
20
;
frag
.
appendChild
(
rightSpacer
)
;
this
.
messageText
.
flex
=
0
;
const
leftSpacer
=
this
.
messageText
.
nextSibling
;
leftSpacer
.
flex
=
0
;
if
(
this
.
options
.
learnMoreMessage
&
&
this
.
options
.
learnMoreUrl
)
{
const
learnMore
=
this
.
chromeWindow
.
document
.
createElement
(
"
label
"
)
;
learnMore
.
className
=
"
text
-
link
"
;
learnMore
.
href
=
this
.
options
.
learnMoreUrl
.
toString
(
)
;
learnMore
.
setAttribute
(
"
value
"
this
.
options
.
learnMoreMessage
)
;
learnMore
.
addEventListener
(
"
click
"
(
)
=
>
this
.
maybeNotifyHeartbeat
(
"
LearnMore
"
)
)
;
frag
.
appendChild
(
learnMore
)
;
}
this
.
notice
.
appendChild
(
frag
)
;
this
.
notice
.
classList
.
add
(
"
heartbeat
"
)
;
this
.
maybeNotifyHeartbeat
(
"
NotificationOffered
"
)
;
this
.
chromeWindow
.
addEventListener
(
"
SSWindowClosing
"
this
.
handleWindowClosed
)
;
const
surveyDuration
=
Preferences
.
get
(
PREF_SURVEY_DURATION
300
)
*
1000
;
this
.
surveyEndTimer
=
setTimeout
(
(
)
=
>
{
this
.
maybeNotifyHeartbeat
(
"
SurveyExpired
"
)
;
this
.
close
(
)
;
}
surveyDuration
)
;
this
.
sandboxManager
.
addHold
(
"
heartbeat
"
)
;
CleanupManager
.
addCleanupHandler
(
this
.
close
)
;
}
maybeNotifyHeartbeat
(
name
data
=
{
}
)
{
if
(
this
.
pingSent
)
{
log
.
warn
(
"
Heartbeat
event
recieved
after
Telemetry
ping
sent
.
name
:
"
name
"
data
:
"
data
)
;
return
;
}
const
timestamp
=
Date
.
now
(
)
;
let
sendPing
=
false
;
let
cleanup
=
false
;
const
phases
=
{
NotificationOffered
:
(
)
=
>
{
this
.
surveyResults
.
flowId
=
this
.
options
.
flowId
;
this
.
surveyResults
.
offeredTS
=
timestamp
;
}
LearnMore
:
(
)
=
>
{
if
(
!
this
.
surveyResults
.
learnMoreTS
)
{
this
.
surveyResults
.
learnMoreTS
=
timestamp
;
}
}
Engaged
:
(
)
=
>
{
this
.
surveyResults
.
engagedTS
=
timestamp
;
}
Voted
:
(
)
=
>
{
this
.
surveyResults
.
votedTS
=
timestamp
;
this
.
surveyResults
.
score
=
data
.
score
;
}
SurveyExpired
:
(
)
=
>
{
this
.
surveyResults
.
expiredTS
=
timestamp
;
}
NotificationClosed
:
(
)
=
>
{
this
.
surveyResults
.
closedTS
=
timestamp
;
cleanup
=
true
;
sendPing
=
true
;
}
WindowClosed
:
(
)
=
>
{
this
.
surveyResults
.
windowClosedTS
=
timestamp
;
cleanup
=
true
;
sendPing
=
true
;
}
default
:
(
)
=
>
{
log
.
error
(
"
Unrecognized
Heartbeat
event
:
"
name
)
;
}
}
;
(
phases
[
name
]
|
|
phases
.
default
)
(
)
;
data
.
timestamp
=
timestamp
;
data
.
flowId
=
this
.
options
.
flowId
;
this
.
eventEmitter
.
emit
(
name
data
)
;
if
(
sendPing
)
{
const
payload
=
Object
.
assign
(
{
version
:
1
}
this
.
surveyResults
)
;
for
(
const
meta
of
[
"
surveyId
"
"
surveyVersion
"
"
testing
"
]
)
{
if
(
this
.
options
.
hasOwnProperty
(
meta
)
)
{
payload
[
meta
]
=
this
.
options
[
meta
]
;
}
}
log
.
debug
(
"
Sending
telemetry
"
)
;
TelemetryController
.
submitExternalPing
(
"
heartbeat
"
payload
{
addClientId
:
true
addEnvironment
:
true
}
)
;
this
.
eventEmitter
.
emit
(
"
TelemetrySent
"
payload
)
;
this
.
endTimerIfPresent
(
"
surveyEndTimer
"
)
;
this
.
pingSent
=
true
;
this
.
surveyResults
=
null
;
}
if
(
cleanup
)
{
this
.
cleanup
(
)
;
}
}
userEngaged
(
engagementParams
)
{
this
.
notice
.
label
=
this
.
options
.
thanksMessage
;
this
.
messageImage
.
classList
.
remove
(
"
pulse
-
onshow
"
)
;
this
.
messageImage
.
classList
.
add
(
"
pulse
-
twice
"
)
;
while
(
this
.
notice
.
firstChild
)
{
this
.
notice
.
firstChild
.
remove
(
)
;
}
if
(
this
.
options
.
postAnswerUrl
)
{
for
(
const
key
in
engagementParams
)
{
this
.
options
.
postAnswerUrl
.
searchParams
.
append
(
key
engagementParams
[
key
]
)
;
}
this
.
chromeWindow
.
gBrowser
.
selectedTab
=
this
.
chromeWindow
.
gBrowser
.
addTab
(
this
.
options
.
postAnswerUrl
.
toString
(
)
)
;
}
this
.
endTimerIfPresent
(
"
surveyEndTimer
"
)
;
this
.
engagementCloseTimer
=
setTimeout
(
(
)
=
>
this
.
close
(
)
NOTIFICATION_TIME
)
;
}
endTimerIfPresent
(
timerName
)
{
if
(
this
[
timerName
]
)
{
clearTimeout
(
this
[
timerName
]
)
;
this
[
timerName
]
=
null
;
}
}
handleWindowClosed
(
)
{
this
.
maybeNotifyHeartbeat
(
"
WindowClosed
"
)
;
}
close
(
)
{
this
.
notificationBox
.
removeNotification
(
this
.
notice
)
;
}
cleanup
(
)
{
this
.
endTimerIfPresent
(
"
surveyEndTimer
"
)
;
this
.
endTimerIfPresent
(
"
engagementCloseTimer
"
)
;
this
.
sandboxManager
.
removeHold
(
"
heartbeat
"
)
;
this
.
chromeWindow
.
removeEventListener
(
"
SSWindowClosing
"
this
.
handleWindowClosed
)
;
this
.
chromeWindow
=
null
;
this
.
notificationBox
=
null
;
this
.
notification
=
null
;
this
.
notice
=
null
;
this
.
eventEmitter
=
null
;
this
.
sandboxManager
=
null
;
CleanupManager
.
removeCleanupHandler
(
this
.
close
)
;
}
}
;
