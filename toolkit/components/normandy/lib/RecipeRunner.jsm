"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
LogManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
timerManager
"
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
"
nsIUpdateTimerManager
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
RemoteSettings
:
"
resource
:
/
/
services
-
settings
/
remote
-
settings
.
js
"
Storage
:
"
resource
:
/
/
normandy
/
lib
/
Storage
.
jsm
"
FilterExpressions
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
FilterExpressions
.
jsm
"
TargetingContext
:
"
resource
:
/
/
messaging
-
system
/
targeting
/
Targeting
.
jsm
"
NormandyApi
:
"
resource
:
/
/
normandy
/
lib
/
NormandyApi
.
jsm
"
ClientEnvironment
:
"
resource
:
/
/
normandy
/
lib
/
ClientEnvironment
.
jsm
"
CleanupManager
:
"
resource
:
/
/
normandy
/
lib
/
CleanupManager
.
jsm
"
Uptake
:
"
resource
:
/
/
normandy
/
lib
/
Uptake
.
jsm
"
ActionsManager
:
"
resource
:
/
/
normandy
/
lib
/
ActionsManager
.
jsm
"
BaseAction
:
"
resource
:
/
/
normandy
/
actions
/
BaseAction
.
jsm
"
RemoteSettingsClient
:
"
resource
:
/
/
services
-
settings
/
RemoteSettingsClient
.
jsm
"
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
RecipeRunner
"
]
;
const
log
=
LogManager
.
getLogger
(
"
recipe
-
runner
"
)
;
const
TIMER_NAME
=
"
recipe
-
client
-
addon
-
run
"
;
const
REMOTE_SETTINGS_COLLECTION
=
"
normandy
-
recipes
-
capabilities
"
;
const
PREF_CHANGED_TOPIC
=
"
nsPref
:
changed
"
;
const
RUN_INTERVAL_PREF
=
"
app
.
normandy
.
run_interval_seconds
"
;
const
FIRST_RUN_PREF
=
"
app
.
normandy
.
first_run
"
;
const
SHIELD_ENABLED_PREF
=
"
app
.
normandy
.
enabled
"
;
const
DEV_MODE_PREF
=
"
app
.
normandy
.
dev_mode
"
;
const
API_URL_PREF
=
"
app
.
normandy
.
api_url
"
;
const
LAZY_CLASSIFY_PREF
=
"
app
.
normandy
.
experiments
.
lazy_classify
"
;
const
ONSYNC_SKEW_SEC_PREF
=
"
app
.
normandy
.
onsync_skew_sec
"
;
const
TIMER_LAST_UPDATE_PREF
=
app
.
update
.
lastUpdateTime
.
{
TIMER_NAME
}
;
const
PREFS_TO_WATCH
=
[
RUN_INTERVAL_PREF
SHIELD_ENABLED_PREF
API_URL_PREF
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gRemoteSettingsClient
"
(
)
=
>
{
return
RemoteSettings
(
REMOTE_SETTINGS_COLLECTION
)
;
}
)
;
function
cacheProxy
(
target
)
{
const
cache
=
new
Map
(
)
;
return
new
Proxy
(
target
{
get
(
target
prop
receiver
)
{
if
(
!
cache
.
has
(
prop
)
)
{
cache
.
set
(
prop
target
[
prop
]
)
;
}
return
cache
.
get
(
prop
)
;
}
set
(
target
prop
value
receiver
)
{
cache
.
set
(
prop
value
)
;
return
true
;
}
has
(
target
prop
)
{
return
cache
.
has
(
prop
)
|
|
prop
in
target
;
}
}
)
;
}
var
RecipeRunner
=
{
async
init
(
)
{
this
.
running
=
false
;
this
.
enabled
=
null
;
this
.
loadFromRemoteSettings
=
false
;
this
.
_syncSkewTimeout
=
null
;
this
.
checkPrefs
(
)
;
this
.
watchPrefs
(
)
;
this
.
setUpRemoteSettings
(
)
;
const
firstRun
=
Services
.
prefs
.
getBoolPref
(
FIRST_RUN_PREF
true
)
;
let
hasNewBuildID
=
Services
.
appinfo
.
lastAppBuildID
!
=
null
&
&
Services
.
appinfo
.
lastAppBuildID
!
=
Services
.
appinfo
.
appBuildID
;
const
devMode
=
Services
.
prefs
.
getBoolPref
(
DEV_MODE_PREF
false
)
;
if
(
this
.
enabled
&
&
(
devMode
|
|
firstRun
|
|
hasNewBuildID
)
)
{
if
(
devMode
)
{
await
gRemoteSettingsClient
.
sync
(
)
;
}
let
trigger
;
if
(
devMode
)
{
trigger
=
"
devMode
"
;
}
else
if
(
firstRun
)
{
trigger
=
"
firstRun
"
;
}
else
if
(
hasNewBuildID
)
{
trigger
=
"
newBuildID
"
;
}
await
this
.
run
(
{
trigger
}
)
;
}
if
(
firstRun
)
{
Services
.
prefs
.
setBoolPref
(
FIRST_RUN_PREF
false
)
;
}
}
enable
(
)
{
if
(
this
.
enabled
)
{
return
;
}
this
.
registerTimer
(
)
;
this
.
enabled
=
true
;
}
disable
(
)
{
if
(
this
.
enabled
)
{
this
.
unregisterTimer
(
)
;
}
this
.
enabled
=
false
;
}
watchPrefs
(
)
{
for
(
const
pref
of
PREFS_TO_WATCH
)
{
Services
.
prefs
.
addObserver
(
pref
this
)
;
}
CleanupManager
.
addCleanupHandler
(
this
.
unwatchPrefs
.
bind
(
this
)
)
;
}
unwatchPrefs
(
)
{
for
(
const
pref
of
PREFS_TO_WATCH
)
{
Services
.
prefs
.
removeObserver
(
pref
this
)
;
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
PREF_CHANGED_TOPIC
:
{
const
prefName
=
data
;
switch
(
prefName
)
{
case
RUN_INTERVAL_PREF
:
this
.
updateRunInterval
(
)
;
break
;
case
SHIELD_ENABLED_PREF
:
case
API_URL_PREF
:
this
.
checkPrefs
(
)
;
break
;
default
:
log
.
debug
(
Observer
fired
with
unexpected
pref
change
:
{
prefName
}
)
;
}
break
;
}
}
}
checkPrefs
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
SHIELD_ENABLED_PREF
)
)
{
log
.
debug
(
Disabling
Shield
because
{
SHIELD_ENABLED_PREF
}
is
set
to
false
)
;
this
.
disable
(
)
;
return
;
}
const
apiUrl
=
Services
.
prefs
.
getCharPref
(
API_URL_PREF
)
;
if
(
!
apiUrl
)
{
log
.
warn
(
Disabling
Shield
because
{
API_URL_PREF
}
is
not
set
.
)
;
this
.
disable
(
)
;
return
;
}
if
(
!
apiUrl
.
startsWith
(
"
https
:
/
/
"
)
)
{
log
.
warn
(
Disabling
Shield
because
{
API_URL_PREF
}
is
not
an
HTTPS
url
:
{
apiUrl
}
.
)
;
this
.
disable
(
)
;
return
;
}
log
.
debug
(
Enabling
Shield
)
;
this
.
enable
(
)
;
}
registerTimer
(
)
{
this
.
updateRunInterval
(
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
timerManager
.
unregisterTimer
(
TIMER_NAME
)
)
;
}
unregisterTimer
(
)
{
timerManager
.
unregisterTimer
(
TIMER_NAME
)
;
}
setUpRemoteSettings
(
)
{
if
(
this
.
_alreadySetUpRemoteSettings
)
{
return
;
}
this
.
_alreadySetUpRemoteSettings
=
true
;
if
(
!
this
.
_onSync
)
{
this
.
_onSync
=
this
.
onSync
.
bind
(
this
)
;
}
gRemoteSettingsClient
.
on
(
"
sync
"
this
.
_onSync
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
{
gRemoteSettingsClient
.
off
(
"
sync
"
this
.
_onSync
)
;
this
.
_alreadySetUpRemoteSettings
=
false
;
}
)
;
}
async
onSync
(
)
{
if
(
!
this
.
enabled
)
{
return
;
}
if
(
this
.
_syncSkewTimeout
)
{
clearTimeout
(
this
.
_syncSkewTimeout
)
;
}
let
minSkewSec
=
1
;
let
maxSkewSec
=
Services
.
prefs
.
getIntPref
(
ONSYNC_SKEW_SEC_PREF
0
)
;
if
(
maxSkewSec
>
=
minSkewSec
)
{
let
skewMillis
=
(
minSkewSec
+
Math
.
random
(
)
*
(
maxSkewSec
-
minSkewSec
)
)
*
1000
;
log
.
debug
(
Delaying
on
-
sync
Normandy
run
for
{
Math
.
floor
(
skewMillis
/
1000
)
}
seconds
)
;
this
.
_syncSkewTimeout
=
setTimeout
(
(
)
=
>
this
.
run
(
{
trigger
:
"
sync
"
}
)
skewMillis
)
;
}
else
{
log
.
debug
(
Not
skewing
on
-
sync
Normandy
run
)
;
await
this
.
run
(
{
trigger
:
"
sync
"
}
)
;
}
}
updateRunInterval
(
)
{
const
runInterval
=
Services
.
prefs
.
getIntPref
(
RUN_INTERVAL_PREF
)
;
timerManager
.
registerTimer
(
TIMER_NAME
(
)
=
>
this
.
run
(
)
runInterval
)
;
}
async
run
(
{
trigger
=
"
timer
"
}
=
{
}
)
{
if
(
this
.
running
)
{
return
;
}
try
{
this
.
running
=
true
;
Services
.
obs
.
notifyObservers
(
null
"
recipe
-
runner
:
start
"
)
;
if
(
this
.
_syncSkewTimeout
)
{
clearTimeout
(
this
.
_syncSkewTimeout
)
;
this
.
_syncSkewTimeout
=
null
;
}
this
.
clearCaches
(
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
LAZY_CLASSIFY_PREF
false
)
)
{
try
{
await
ClientEnvironment
.
getClientClassification
(
)
;
}
catch
(
err
)
{
}
}
let
recipesAndSignatures
;
try
{
recipesAndSignatures
=
await
gRemoteSettingsClient
.
get
(
)
;
}
catch
(
e
)
{
await
Uptake
.
reportRunner
(
Uptake
.
RUNNER_SERVER_ERROR
)
;
return
;
}
const
actionsManager
=
new
ActionsManager
(
)
;
if
(
recipesAndSignatures
.
length
=
=
=
0
)
{
log
.
debug
(
"
No
recipes
to
execute
"
)
;
}
else
{
for
(
const
{
recipe
signature
}
of
recipesAndSignatures
)
{
let
suitability
=
await
this
.
getRecipeSuitability
(
recipe
signature
)
;
await
actionsManager
.
processRecipe
(
recipe
suitability
)
;
}
}
await
actionsManager
.
finalize
(
)
;
await
Uptake
.
reportRunner
(
Uptake
.
RUNNER_SUCCESS
)
;
Services
.
obs
.
notifyObservers
(
null
"
recipe
-
runner
:
end
"
)
;
}
finally
{
this
.
running
=
false
;
if
(
trigger
!
=
"
timer
"
)
{
const
lastUpdateTime
=
Math
.
round
(
Date
.
now
(
)
/
1000
)
;
Services
.
prefs
.
setIntPref
(
TIMER_LAST_UPDATE_PREF
lastUpdateTime
)
;
}
}
}
getFilterContext
(
recipe
)
{
const
environment
=
cacheProxy
(
ClientEnvironment
)
;
environment
.
recipe
=
{
id
:
recipe
.
id
arguments
:
recipe
.
arguments
}
;
return
{
env
:
environment
normandy
:
environment
}
;
}
getCapabilities
(
)
{
let
capabilities
=
new
Set
(
[
"
capabilities
-
v1
"
]
)
;
for
(
const
actionCapability
of
ActionsManager
.
getCapabilities
(
)
)
{
capabilities
.
add
(
actionCapability
)
;
}
for
(
const
transform
of
FilterExpressions
.
getAvailableTransforms
(
)
)
{
capabilities
.
add
(
jexl
.
transform
.
{
transform
}
)
;
}
capabilities
.
add
(
"
jexl
.
context
.
env
"
)
;
capabilities
.
add
(
"
jexl
.
context
.
normandy
"
)
;
let
env
=
ClientEnvironment
;
while
(
env
&
&
env
.
name
)
{
for
(
const
[
name
descriptor
]
of
Object
.
entries
(
Object
.
getOwnPropertyDescriptors
(
env
)
)
)
{
if
(
descriptor
.
configurable
&
&
descriptor
.
get
)
{
capabilities
.
add
(
jexl
.
context
.
env
.
{
name
}
)
;
capabilities
.
add
(
jexl
.
context
.
normandy
.
{
name
}
)
;
}
}
env
=
Object
.
getPrototypeOf
(
env
)
;
}
return
capabilities
;
}
async
getRecipeSuitability
(
recipe
signature
)
{
let
generator
=
this
.
getAllSuitabilities
(
recipe
signature
)
;
let
{
value
:
suitability
}
=
await
generator
.
next
(
)
;
switch
(
suitability
)
{
case
BaseAction
.
suitability
.
SIGNATURE_ERROR
:
{
await
Uptake
.
reportRecipe
(
recipe
Uptake
.
RECIPE_INVALID_SIGNATURE
)
;
break
;
}
case
BaseAction
.
suitability
.
CAPABILITES_MISMATCH
:
{
await
Uptake
.
reportRecipe
(
recipe
Uptake
.
RECIPE_INCOMPATIBLE_CAPABILITIES
)
;
break
;
}
case
BaseAction
.
suitability
.
FILTER_MATCH
:
{
break
;
}
case
BaseAction
.
suitability
.
FILTER_MISMATCH
:
{
await
Uptake
.
reportRecipe
(
recipe
Uptake
.
RECIPE_DIDNT_MATCH_FILTER
)
;
break
;
}
case
BaseAction
.
suitability
.
FILTER_ERROR
:
{
await
Uptake
.
reportRecipe
(
recipe
Uptake
.
RECIPE_FILTER_BROKEN
)
;
break
;
}
case
BaseAction
.
suitability
.
ARGUMENTS_INVALID
:
{
throw
new
Error
(
Shouldn
'
t
get
{
suitability
}
in
RecipeRunner
)
;
}
default
:
{
throw
new
Error
(
Unexpected
recipe
suitability
{
suitability
}
)
;
}
}
return
suitability
;
}
async
*
getAllSuitabilities
(
recipe
signature
)
{
try
{
await
NormandyApi
.
verifyObjectSignature
(
recipe
signature
"
recipe
"
)
;
}
catch
(
e
)
{
yield
BaseAction
.
suitability
.
SIGNATURE_ERROR
;
}
const
runnerCapabilities
=
this
.
getCapabilities
(
)
;
if
(
Array
.
isArray
(
recipe
.
capabilities
)
)
{
for
(
const
recipeCapability
of
recipe
.
capabilities
)
{
if
(
!
runnerCapabilities
.
has
(
recipeCapability
)
)
{
log
.
debug
(
Recipe
"
{
recipe
.
name
}
"
requires
unknown
capabilities
.
+
Recipe
capabilities
:
{
JSON
.
stringify
(
recipe
.
capabilities
)
}
.
+
Local
runner
capabilities
:
{
JSON
.
stringify
(
Array
.
from
(
runnerCapabilities
)
)
}
)
;
yield
BaseAction
.
suitability
.
CAPABILITES_MISMATCH
;
}
}
}
const
context
=
this
.
getFilterContext
(
recipe
)
;
const
targetingContext
=
new
TargetingContext
(
)
;
try
{
if
(
await
targetingContext
.
eval
(
recipe
.
filter_expression
context
)
)
{
yield
BaseAction
.
suitability
.
FILTER_MATCH
;
}
else
{
yield
BaseAction
.
suitability
.
FILTER_MISMATCH
;
}
}
catch
(
err
)
{
log
.
error
(
Error
checking
filter
for
"
{
recipe
.
name
}
"
.
Filter
:
[
{
recipe
.
filter_expression
}
]
.
Error
:
"
{
err
}
"
)
;
yield
BaseAction
.
suitability
.
FILTER_ERROR
;
}
}
clearCaches
(
)
{
ClientEnvironment
.
clearClassifyCache
(
)
;
NormandyApi
.
clearIndexCache
(
)
;
}
async
testRun
(
baseApiUrl
)
{
const
oldApiUrl
=
Services
.
prefs
.
getCharPref
(
API_URL_PREF
)
;
Services
.
prefs
.
setCharPref
(
API_URL_PREF
baseApiUrl
)
;
try
{
Storage
.
clearAllStorage
(
)
;
this
.
clearCaches
(
)
;
await
this
.
run
(
)
;
}
finally
{
Services
.
prefs
.
setCharPref
(
API_URL_PREF
oldApiUrl
)
;
this
.
clearCaches
(
)
;
}
}
get
_remoteSettingsClientForTesting
(
)
{
return
gRemoteSettingsClient
;
}
migrations
:
{
async
migration01RemoveOldRecipesCollection
(
)
{
const
lastCheckPref
=
"
services
.
settings
.
main
.
normandy
-
recipes
.
last_check
"
;
if
(
Services
.
prefs
.
prefHasUserValue
(
lastCheckPref
)
)
{
const
client
=
new
RemoteSettingsClient
(
"
normandy
-
recipes
"
{
bucketNamePref
:
"
services
.
settings
.
default_bucket
"
}
)
;
await
client
.
db
.
clear
(
)
;
Services
.
prefs
.
clearUserPref
(
lastCheckPref
)
;
}
}
}
}
;
