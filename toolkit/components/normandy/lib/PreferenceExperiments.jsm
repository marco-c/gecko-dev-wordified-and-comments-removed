"
use
strict
"
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CleanupManager
"
"
resource
:
/
/
normandy
/
lib
/
CleanupManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
JSONFile
"
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LogManager
"
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryEnvironment
"
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryEvents
"
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NormandyUtils
"
"
resource
:
/
/
normandy
/
lib
/
NormandyUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrefUtils
"
"
resource
:
/
/
normandy
/
lib
/
PrefUtils
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
PreferenceExperiments
"
]
;
const
EXPERIMENT_FILE
=
"
shield
-
preference
-
experiments
.
json
"
;
const
STARTUP_EXPERIMENT_PREFS_BRANCH
=
"
app
.
normandy
.
startupExperimentPrefs
.
"
;
const
MAX_EXPERIMENT_TYPE_LENGTH
=
20
;
const
EXPERIMENT_TYPE_PREFIX
=
"
normandy
-
"
;
const
MAX_EXPERIMENT_SUBTYPE_LENGTH
=
MAX_EXPERIMENT_TYPE_LENGTH
-
EXPERIMENT_TYPE_PREFIX
.
length
;
const
PREFERENCE_TYPE_MAP
=
{
boolean
:
Services
.
prefs
.
PREF_BOOL
string
:
Services
.
prefs
.
PREF_STRING
integer
:
Services
.
prefs
.
PREF_INT
}
;
const
UserPreferences
=
Services
.
prefs
;
const
DefaultPreferences
=
Services
.
prefs
.
getDefaultBranch
(
"
"
)
;
const
PreferenceBranchType
=
{
user
:
UserPreferences
default
:
DefaultPreferences
}
;
let
gStorePromise
;
function
ensureStorage
(
)
{
if
(
gStorePromise
=
=
=
undefined
)
{
const
path
=
PathUtils
.
join
(
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
path
EXPERIMENT_FILE
)
;
const
storage
=
new
JSONFile
(
{
path
}
)
;
gStorePromise
=
storage
.
load
(
)
.
then
(
(
)
=
>
{
if
(
!
storage
.
data
.
experiments
)
{
storage
.
data
=
{
.
.
.
storage
.
data
experiments
:
{
}
}
;
}
return
storage
;
}
)
;
}
return
gStorePromise
;
}
const
log
=
LogManager
.
getLogger
(
"
preference
-
experiments
"
)
;
let
experimentObservers
=
new
Map
(
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
PreferenceExperiments
.
stopAllObservers
(
)
)
;
var
PreferenceExperiments
=
{
async
recordOriginalValues
(
studyPrefsChanged
)
{
const
store
=
await
ensureStorage
(
)
;
for
(
const
experiment
of
Object
.
values
(
store
.
data
.
experiments
)
)
{
for
(
const
[
prefName
prefInfo
]
of
Object
.
entries
(
experiment
.
preferences
)
)
{
if
(
studyPrefsChanged
.
hasOwnProperty
(
prefName
)
)
{
if
(
experiment
.
expired
)
{
log
.
warn
(
"
Expired
preference
experiment
changed
value
during
startup
"
)
;
}
if
(
prefInfo
.
preferenceBranch
!
=
=
"
default
"
)
{
log
.
warn
(
"
Non
-
default
branch
preference
experiment
changed
value
during
startup
"
)
;
}
prefInfo
.
previousPreferenceValue
=
studyPrefsChanged
[
prefName
]
;
}
}
}
}
async
init
(
)
{
CleanupManager
.
addCleanupHandler
(
(
)
=
>
this
.
saveStartupPrefs
(
)
)
;
for
(
const
experiment
of
await
this
.
getAllActive
(
)
)
{
for
(
const
[
preferenceName
spec
]
of
Object
.
entries
(
experiment
.
preferences
)
)
{
if
(
!
spec
.
overridden
&
&
PrefUtils
.
getPref
(
preferenceName
)
!
=
=
spec
.
preferenceValue
)
{
await
this
.
recordPrefChange
(
{
experiment
preferenceName
reason
:
"
sideload
"
}
)
;
}
}
TelemetryEnvironment
.
setExperimentActive
(
experiment
.
slug
experiment
.
branch
{
type
:
EXPERIMENT_TYPE_PREFIX
+
experiment
.
experimentType
enrollmentId
:
experiment
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
this
.
startObserver
(
experiment
.
slug
experiment
.
preferences
)
;
}
}
async
saveStartupPrefs
(
)
{
const
prefBranch
=
Services
.
prefs
.
getBranch
(
STARTUP_EXPERIMENT_PREFS_BRANCH
)
;
for
(
const
pref
of
prefBranch
.
getChildList
(
"
"
)
)
{
prefBranch
.
clearUserPref
(
pref
)
;
}
const
allExperiments
=
await
this
.
getAllActive
(
)
;
const
defaultBranchPrefs
=
allExperiments
.
flatMap
(
exp
=
>
Object
.
entries
(
exp
.
preferences
)
)
.
filter
(
(
[
preferenceName
preferenceInfo
]
)
=
>
preferenceInfo
.
preferenceBranchType
=
=
=
"
default
"
)
;
for
(
const
[
preferenceName
{
preferenceValue
}
]
of
defaultBranchPrefs
)
{
switch
(
typeof
preferenceValue
)
{
case
"
string
"
:
prefBranch
.
setCharPref
(
preferenceName
preferenceValue
)
;
break
;
case
"
number
"
:
prefBranch
.
setIntPref
(
preferenceName
preferenceValue
)
;
break
;
case
"
boolean
"
:
prefBranch
.
setBoolPref
(
preferenceName
preferenceValue
)
;
break
;
default
:
throw
new
Error
(
Invalid
preference
type
{
typeof
preferenceValue
}
)
;
}
}
}
withMockExperiments
(
prefExperiments
=
[
]
)
{
return
function
wrapper
(
testFunction
)
{
return
async
function
wrappedTestFunction
(
args
)
{
const
experiments
=
{
}
;
for
(
const
exp
of
prefExperiments
)
{
if
(
exp
.
name
)
{
throw
new
Error
(
"
Preference
experiments
'
name
'
field
has
been
replaced
by
'
slug
'
and
'
userFacingName
'
please
update
.
"
)
;
}
experiments
[
exp
.
slug
]
=
exp
;
}
const
data
=
{
experiments
}
;
const
oldPromise
=
gStorePromise
;
gStorePromise
=
Promise
.
resolve
(
{
data
saveSoon
(
)
{
}
}
)
;
const
oldObservers
=
experimentObservers
;
experimentObservers
=
new
Map
(
)
;
try
{
await
testFunction
(
{
.
.
.
args
prefExperiments
}
)
;
}
finally
{
gStorePromise
=
oldPromise
;
PreferenceExperiments
.
stopAllObservers
(
)
;
experimentObservers
=
oldObservers
;
}
}
;
}
;
}
async
onTelemetryDisabled
(
)
{
const
store
=
await
ensureStorage
(
)
;
for
(
const
experiment
of
Object
.
values
(
store
.
data
.
experiments
)
)
{
experiment
.
enrollmentId
=
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
;
}
store
.
saveSoon
(
)
;
}
async
clearAllExperimentStorage
(
)
{
const
store
=
await
ensureStorage
(
)
;
store
.
data
=
{
experiments
:
{
}
}
;
store
.
saveSoon
(
)
;
}
async
start
(
{
name
=
null
slug
actionName
branch
preferences
experimentType
=
"
exp
"
userFacingName
=
null
userFacingDescription
=
null
}
)
{
if
(
name
)
{
throw
new
Error
(
"
Preference
experiments
'
name
'
field
has
been
replaced
by
'
slug
'
and
'
userFacingName
'
please
update
.
"
)
;
}
log
.
debug
(
PreferenceExperiments
.
start
(
{
slug
}
{
branch
}
)
)
;
const
store
=
await
ensureStorage
(
)
;
if
(
slug
in
store
.
data
.
experiments
)
{
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
preference_study
"
slug
{
reason
:
"
name
-
conflict
"
}
)
;
throw
new
Error
(
A
preference
experiment
with
the
slug
"
{
slug
}
"
already
exists
.
)
;
}
const
activeExperiments
=
Object
.
values
(
store
.
data
.
experiments
)
.
filter
(
e
=
>
!
e
.
expired
)
;
const
preferencesWithConflicts
=
Object
.
keys
(
preferences
)
.
filter
(
preferenceName
=
>
{
return
activeExperiments
.
some
(
e
=
>
e
.
preferences
.
hasOwnProperty
(
preferenceName
)
)
;
}
)
;
if
(
preferencesWithConflicts
.
length
)
{
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
preference_study
"
slug
{
reason
:
"
pref
-
conflict
"
}
)
;
throw
new
Error
(
Another
preference
experiment
for
the
pref
"
{
preferencesWithConflicts
[
0
]
}
"
is
currently
active
.
)
;
}
if
(
experimentType
.
length
>
MAX_EXPERIMENT_SUBTYPE_LENGTH
)
{
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
preference_study
"
slug
{
reason
:
"
experiment
-
type
-
too
-
long
"
}
)
;
throw
new
Error
(
experimentType
must
be
less
than
{
MAX_EXPERIMENT_SUBTYPE_LENGTH
}
characters
.
+
"
{
experimentType
}
"
is
{
experimentType
.
length
}
long
.
)
;
}
for
(
const
[
preferenceName
preferenceInfo
]
of
Object
.
entries
(
preferences
)
)
{
preferenceInfo
.
preferenceBranchType
=
preferenceInfo
.
preferenceBranchType
|
|
"
default
"
;
const
{
preferenceBranchType
preferenceType
}
=
preferenceInfo
;
if
(
!
(
preferenceBranchType
=
=
=
"
user
"
|
|
preferenceBranchType
=
=
=
"
default
"
)
)
{
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
preference_study
"
slug
{
reason
:
"
invalid
-
branch
"
prefBranch
:
preferenceBranchType
.
slice
(
0
80
)
}
)
;
throw
new
Error
(
Invalid
value
for
preferenceBranchType
:
{
preferenceBranchType
}
)
;
}
const
prevPrefType
=
Services
.
prefs
.
getPrefType
(
preferenceName
)
;
const
givenPrefType
=
PREFERENCE_TYPE_MAP
[
preferenceType
]
;
if
(
!
preferenceType
|
|
!
givenPrefType
)
{
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
preference_study
"
slug
{
reason
:
"
invalid
-
type
"
}
)
;
throw
new
Error
(
Invalid
preferenceType
provided
(
given
"
{
preferenceType
}
"
)
)
;
}
if
(
prevPrefType
!
=
=
Services
.
prefs
.
PREF_INVALID
&
&
prevPrefType
!
=
=
givenPrefType
)
{
TelemetryEvents
.
sendEvent
(
"
enrollFailed
"
"
preference_study
"
slug
{
reason
:
"
invalid
-
type
"
}
)
;
throw
new
Error
(
Previous
preference
value
is
of
type
"
{
prevPrefType
}
"
but
was
given
+
"
{
givenPrefType
}
"
(
{
preferenceType
}
)
)
;
}
preferenceInfo
.
previousPreferenceValue
=
PrefUtils
.
getPref
(
preferenceName
{
branch
:
preferenceBranchType
}
)
;
}
const
alreadyOverriddenPrefs
=
new
Set
(
)
;
for
(
const
[
preferenceName
preferenceInfo
]
of
Object
.
entries
(
preferences
)
)
{
const
{
preferenceValue
preferenceBranchType
}
=
preferenceInfo
;
if
(
preferenceBranchType
=
=
=
"
default
"
)
{
if
(
Services
.
prefs
.
prefHasUserValue
(
preferenceName
)
)
{
alreadyOverriddenPrefs
.
add
(
preferenceName
)
;
}
else
{
PrefUtils
.
setPref
(
preferenceName
preferenceValue
{
branch
:
preferenceBranchType
}
)
;
}
}
else
if
(
preferenceBranchType
=
=
=
"
user
"
)
{
PrefUtils
.
setPref
(
preferenceName
preferenceValue
{
branch
:
preferenceBranchType
}
)
;
}
else
{
log
.
error
(
Unexpected
preference
branch
type
{
preferenceBranchType
}
)
;
}
}
PreferenceExperiments
.
startObserver
(
slug
preferences
)
;
const
enrollmentId
=
NormandyUtils
.
generateUuid
(
)
;
const
experiment
=
{
slug
actionName
branch
expired
:
false
lastSeen
:
new
Date
(
)
.
toJSON
(
)
preferences
experimentType
userFacingName
userFacingDescription
enrollmentId
}
;
store
.
data
.
experiments
[
slug
]
=
experiment
;
store
.
saveSoon
(
)
;
TelemetryEnvironment
.
setExperimentActive
(
slug
branch
{
type
:
EXPERIMENT_TYPE_PREFIX
+
experimentType
enrollmentId
:
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
TelemetryEvents
.
sendEvent
(
"
enroll
"
"
preference_study
"
slug
{
experimentType
branch
enrollmentId
:
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
for
(
const
preferenceName
of
alreadyOverriddenPrefs
)
{
await
this
.
recordPrefChange
(
{
experiment
preferenceName
reason
:
"
onEnroll
"
}
)
;
}
await
this
.
saveStartupPrefs
(
)
;
return
experiment
;
}
startObserver
(
experimentSlug
preferences
)
{
log
.
debug
(
PreferenceExperiments
.
startObserver
(
{
experimentSlug
}
)
)
;
if
(
experimentObservers
.
has
(
experimentSlug
)
)
{
throw
new
Error
(
An
observer
for
the
preference
experiment
{
experimentSlug
}
is
already
active
.
)
;
}
const
observerInfo
=
{
preferences
observe
(
aSubject
aTopic
preferenceName
)
{
const
prefInfo
=
preferences
[
preferenceName
]
;
if
(
!
prefInfo
)
{
return
;
}
const
originalValue
=
prefInfo
.
preferenceValue
;
const
newValue
=
PrefUtils
.
getPref
(
preferenceName
)
;
if
(
newValue
!
=
=
originalValue
)
{
PreferenceExperiments
.
recordPrefChange
(
{
experimentSlug
preferenceName
reason
:
"
observer
"
}
)
;
Services
.
prefs
.
removeObserver
(
preferenceName
observerInfo
)
;
}
}
}
;
experimentObservers
.
set
(
experimentSlug
observerInfo
)
;
for
(
const
[
preferenceName
spec
]
of
Object
.
entries
(
preferences
)
)
{
if
(
!
spec
.
overridden
)
{
Services
.
prefs
.
addObserver
(
preferenceName
observerInfo
)
;
}
}
}
hasObserver
(
experimentSlug
)
{
log
.
debug
(
PreferenceExperiments
.
hasObserver
(
{
experimentSlug
}
)
)
;
return
experimentObservers
.
has
(
experimentSlug
)
;
}
stopObserver
(
experimentSlug
)
{
log
.
debug
(
PreferenceExperiments
.
stopObserver
(
{
experimentSlug
}
)
)
;
if
(
!
experimentObservers
.
has
(
experimentSlug
)
)
{
throw
new
Error
(
No
observer
for
the
preference
experiment
{
experimentSlug
}
found
.
)
;
}
const
observer
=
experimentObservers
.
get
(
experimentSlug
)
;
for
(
const
preferenceName
of
Object
.
keys
(
observer
.
preferences
)
)
{
Services
.
prefs
.
removeObserver
(
preferenceName
observer
)
;
}
experimentObservers
.
delete
(
experimentSlug
)
;
}
stopAllObservers
(
)
{
log
.
debug
(
"
PreferenceExperiments
.
stopAllObservers
(
)
"
)
;
for
(
const
observer
of
experimentObservers
.
values
(
)
)
{
for
(
const
preferenceName
of
Object
.
keys
(
observer
.
preferences
)
)
{
Services
.
prefs
.
removeObserver
(
preferenceName
observer
)
;
}
}
experimentObservers
.
clear
(
)
;
}
async
markLastSeen
(
experimentSlug
)
{
log
.
debug
(
PreferenceExperiments
.
markLastSeen
(
{
experimentSlug
}
)
)
;
const
store
=
await
ensureStorage
(
)
;
if
(
!
(
experimentSlug
in
store
.
data
.
experiments
)
)
{
throw
new
Error
(
Could
not
find
a
preference
experiment
with
the
slug
"
{
experimentSlug
}
"
)
;
}
store
.
data
.
experiments
[
experimentSlug
]
.
lastSeen
=
new
Date
(
)
.
toJSON
(
)
;
store
.
saveSoon
(
)
;
}
async
recordPrefChange
(
{
experiment
=
null
experimentSlug
=
null
preferenceName
reason
}
)
{
if
(
!
experiment
)
{
experiment
=
await
PreferenceExperiments
.
get
(
experimentSlug
)
;
}
let
preferenceSpecification
=
experiment
.
preferences
[
preferenceName
]
;
if
(
!
preferenceSpecification
)
{
throw
new
PreferenceExperiments
.
InvalidPreferenceName
(
Preference
"
{
preferenceName
}
"
is
not
a
part
of
experiment
"
{
experimentSlug
}
"
)
;
}
preferenceSpecification
.
overridden
=
true
;
await
this
.
update
(
experiment
)
;
TelemetryEvents
.
sendEvent
(
"
expPrefChanged
"
"
preference_study
"
experiment
.
slug
{
preferenceName
reason
enrollmentId
:
experiment
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
async
stop
(
experimentSlug
{
resetValue
=
true
reason
=
"
unknown
"
changedPref
caller
}
=
{
}
)
{
log
.
debug
(
PreferenceExperiments
.
stop
(
{
experimentSlug
}
{
resetValue
:
{
resetValue
}
reason
:
{
reason
}
changedPref
:
{
changedPref
}
caller
:
{
caller
}
}
)
)
;
if
(
reason
=
=
=
"
unknown
"
)
{
log
.
warn
(
experiment
{
experimentSlug
}
ending
for
unknown
reason
)
;
}
const
store
=
await
ensureStorage
(
)
;
if
(
!
(
experimentSlug
in
store
.
data
.
experiments
)
)
{
TelemetryEvents
.
sendEvent
(
"
unenrollFailed
"
"
preference_study
"
experimentSlug
{
reason
:
"
does
-
not
-
exist
"
originalReason
:
reason
.
.
.
(
changedPref
?
{
changedPref
}
:
{
}
)
}
)
;
throw
new
Error
(
Could
not
find
a
preference
experiment
with
the
slug
"
{
experimentSlug
}
"
)
;
}
const
experiment
=
store
.
data
.
experiments
[
experimentSlug
]
;
if
(
experiment
.
expired
)
{
const
extra
=
{
reason
:
"
already
-
unenrolled
"
originalReason
:
reason
enrollmentId
:
experiment
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
;
if
(
changedPref
)
{
extra
.
changedPref
=
changedPref
;
}
if
(
caller
&
&
AppConstants
.
NIGHTLY_BUILD
)
{
extra
.
caller
=
caller
;
}
TelemetryEvents
.
sendEvent
(
"
unenrollFailed
"
"
preference_study
"
experimentSlug
extra
)
;
throw
new
Error
(
Cannot
stop
preference
experiment
"
{
experimentSlug
}
"
because
it
is
already
expired
)
;
}
if
(
PreferenceExperiments
.
hasObserver
(
experimentSlug
)
)
{
PreferenceExperiments
.
stopObserver
(
experimentSlug
)
;
}
if
(
resetValue
)
{
for
(
const
[
preferenceName
{
previousPreferenceValue
preferenceBranchType
overridden
}
]
of
Object
.
entries
(
experiment
.
preferences
)
)
{
if
(
overridden
&
&
preferenceBranchType
=
=
=
"
user
"
)
{
continue
;
}
const
preferences
=
PreferenceBranchType
[
preferenceBranchType
]
;
if
(
previousPreferenceValue
!
=
=
null
)
{
PrefUtils
.
setPref
(
preferenceName
previousPreferenceValue
{
branch
:
preferenceBranchType
}
)
;
}
else
if
(
preferenceBranchType
=
=
=
"
user
"
)
{
preferences
.
clearUserPref
(
preferenceName
)
;
}
else
{
log
.
warn
(
Can
'
t
revert
pref
{
preferenceName
}
for
experiment
{
experimentSlug
}
+
because
it
had
no
default
value
.
+
Preference
will
be
reset
at
the
next
restart
.
)
;
}
}
}
experiment
.
expired
=
true
;
if
(
experiment
.
temporaryErrorDeadline
)
{
experiment
.
temporaryErrorDeadline
=
null
;
}
await
store
.
saveSoon
(
)
;
TelemetryEnvironment
.
setExperimentInactive
(
experimentSlug
)
;
TelemetryEvents
.
sendEvent
(
"
unenroll
"
"
preference_study
"
experimentSlug
{
didResetValue
:
resetValue
?
"
true
"
:
"
false
"
branch
:
experiment
.
branch
reason
enrollmentId
:
experiment
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
.
.
.
(
changedPref
?
{
changedPref
}
:
{
}
)
}
)
;
await
this
.
saveStartupPrefs
(
)
;
Services
.
obs
.
notifyObservers
(
null
"
normandy
:
preference
-
experiment
:
stopped
"
experimentSlug
)
;
}
_cloneExperiment
(
experiment
)
{
return
{
.
.
.
experiment
preferences
:
{
.
.
.
experiment
.
preferences
}
}
;
}
async
get
(
experimentSlug
)
{
log
.
debug
(
PreferenceExperiments
.
get
(
{
experimentSlug
}
)
)
;
const
store
=
await
ensureStorage
(
)
;
if
(
!
(
experimentSlug
in
store
.
data
.
experiments
)
)
{
throw
new
PreferenceExperiments
.
NotFoundError
(
Could
not
find
a
preference
experiment
with
the
slug
"
{
experimentSlug
}
"
)
;
}
return
this
.
_cloneExperiment
(
store
.
data
.
experiments
[
experimentSlug
]
)
;
}
async
getAll
(
)
{
const
store
=
await
ensureStorage
(
)
;
return
Object
.
values
(
store
.
data
.
experiments
)
.
map
(
experiment
=
>
this
.
_cloneExperiment
(
experiment
)
)
;
}
async
getAllActive
(
)
{
const
store
=
await
ensureStorage
(
)
;
return
Object
.
values
(
store
.
data
.
experiments
)
.
filter
(
e
=
>
!
e
.
expired
)
.
map
(
e
=
>
this
.
_cloneExperiment
(
e
)
)
;
}
async
has
(
experimentSlug
)
{
log
.
debug
(
PreferenceExperiments
.
has
(
{
experimentSlug
}
)
)
;
const
store
=
await
ensureStorage
(
)
;
return
experimentSlug
in
store
.
data
.
experiments
;
}
async
update
(
experiment
)
{
const
store
=
await
ensureStorage
(
)
;
if
(
!
(
experiment
.
slug
in
store
.
data
.
experiments
)
)
{
throw
new
Error
(
Could
not
update
a
preference
experiment
with
the
slug
"
{
experiment
.
slug
}
"
)
;
}
store
.
data
.
experiments
[
experiment
.
slug
]
=
experiment
;
store
.
saveSoon
(
)
;
}
NotFoundError
:
class
extends
Error
{
}
InvalidPreferenceName
:
class
extends
Error
{
}
migrations
:
{
async
migration01MoveExperiments
(
storage
=
null
)
{
if
(
storage
=
=
=
null
)
{
storage
=
await
ensureStorage
(
)
;
}
if
(
Object
.
hasOwnProperty
.
call
(
storage
.
data
"
experiments
"
)
)
{
return
;
}
storage
.
data
=
{
experiments
:
storage
.
data
}
;
delete
storage
.
data
.
experiments
.
__version
;
storage
.
saveSoon
(
)
;
}
async
migration02MultiPreference
(
storage
=
null
)
{
if
(
storage
=
=
=
null
)
{
storage
=
await
ensureStorage
(
)
;
}
const
oldExperiments
=
storage
.
data
.
experiments
;
const
v2Experiments
=
{
}
;
for
(
let
[
expName
oldExperiment
]
of
Object
.
entries
(
oldExperiments
)
)
{
if
(
expName
=
=
"
__version
"
)
{
continue
;
}
if
(
oldExperiment
.
preferences
)
{
v2Experiments
[
expName
]
=
oldExperiment
;
continue
;
}
v2Experiments
[
expName
]
=
{
name
:
oldExperiment
.
name
branch
:
oldExperiment
.
branch
expired
:
oldExperiment
.
expired
lastSeen
:
oldExperiment
.
lastSeen
preferences
:
{
[
oldExperiment
.
preferenceName
]
:
{
preferenceBranchType
:
oldExperiment
.
preferenceBranchType
preferenceType
:
oldExperiment
.
preferenceType
preferenceValue
:
oldExperiment
.
preferenceValue
previousPreferenceValue
:
oldExperiment
.
previousPreferenceValue
}
}
experimentType
:
oldExperiment
.
experimentType
}
;
}
storage
.
data
.
experiments
=
v2Experiments
;
storage
.
saveSoon
(
)
;
}
async
migration03AddActionName
(
storage
=
null
)
{
if
(
storage
=
=
=
null
)
{
storage
=
await
ensureStorage
(
)
;
}
for
(
const
experiment
of
Object
.
values
(
storage
.
data
.
experiments
)
)
{
if
(
!
experiment
.
actionName
)
{
experiment
.
actionName
=
"
SinglePreferenceExperimentAction
"
;
}
}
storage
.
saveSoon
(
)
;
}
async
migration04RenameNameToSlug
(
storage
=
null
)
{
if
(
!
storage
)
{
storage
=
await
ensureStorage
(
)
;
}
for
(
const
experiment
of
Object
.
values
(
storage
.
data
.
experiments
)
)
{
if
(
experiment
.
name
&
&
!
experiment
.
slug
)
{
experiment
.
slug
=
experiment
.
name
;
delete
experiment
.
name
;
}
}
storage
.
saveSoon
(
)
;
}
async
migration05RemoveOldAction
(
)
{
const
experiments
=
await
PreferenceExperiments
.
getAllActive
(
)
;
for
(
const
experiment
of
experiments
)
{
if
(
experiment
.
actionName
=
=
"
SinglePreferenceExperimentAction
"
)
{
try
{
await
PreferenceExperiments
.
stop
(
experiment
.
slug
{
resetValue
:
true
reason
:
"
migration
-
removing
-
single
-
pref
-
action
"
caller
:
"
migration05RemoveOldAction
"
}
)
;
}
catch
(
e
)
{
log
.
error
(
Stopping
preference
experiment
{
experiment
.
slug
}
during
migration
failed
:
{
e
}
)
;
}
}
}
}
async
migration06TrackOverriddenPrefs
(
storage
=
null
)
{
if
(
!
storage
)
{
storage
=
await
ensureStorage
(
)
;
}
for
(
const
experiment
of
Object
.
values
(
storage
.
data
.
experiments
)
)
{
for
(
const
[
preferenceName
specification
]
of
Object
.
entries
(
experiment
.
preferences
)
)
{
if
(
specification
.
overridden
!
=
=
undefined
)
{
continue
;
}
specification
.
overridden
=
PrefUtils
.
getPref
(
preferenceName
)
!
=
=
specification
.
preferenceValue
;
}
}
storage
.
saveSoon
(
)
;
}
}
}
;
