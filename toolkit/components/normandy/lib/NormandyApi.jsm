"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
LogManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CanonicalJSON
"
"
resource
:
/
/
gre
/
modules
/
CanonicalJSON
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
"
URL
"
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
NormandyApi
"
]
;
const
log
=
LogManager
.
getLogger
(
"
normandy
-
api
"
)
;
const
prefs
=
Services
.
prefs
.
getBranch
(
"
app
.
normandy
.
"
)
;
let
indexPromise
=
null
;
var
NormandyApi
=
{
InvalidSignatureError
:
class
InvalidSignatureError
extends
Error
{
}
clearIndexCache
(
)
{
indexPromise
=
null
;
}
apiCall
(
method
endpoint
data
=
{
}
)
{
const
url
=
new
URL
(
endpoint
)
;
method
=
method
.
toLowerCase
(
)
;
let
body
=
undefined
;
if
(
data
)
{
if
(
method
=
=
=
"
get
"
)
{
for
(
const
key
of
Object
.
keys
(
data
)
)
{
url
.
searchParams
.
set
(
key
data
[
key
]
)
;
}
}
else
if
(
method
=
=
=
"
post
"
)
{
body
=
JSON
.
stringify
(
data
)
;
}
}
const
headers
=
{
"
Accept
"
:
"
application
/
json
"
}
;
return
fetch
(
url
.
href
{
method
body
headers
credentials
:
"
omit
"
}
)
;
}
get
(
endpoint
data
)
{
return
this
.
apiCall
(
"
get
"
endpoint
data
)
;
}
post
(
endpoint
data
)
{
return
this
.
apiCall
(
"
post
"
endpoint
data
)
;
}
absolutify
(
url
)
{
if
(
url
.
startsWith
(
"
http
"
)
)
{
return
url
;
}
const
apiBase
=
prefs
.
getCharPref
(
"
api_url
"
)
;
const
server
=
new
URL
(
apiBase
)
.
origin
;
if
(
url
.
startsWith
(
"
/
"
)
)
{
return
server
+
url
;
}
throw
new
Error
(
"
Can
'
t
use
relative
urls
"
)
;
}
async
getApiUrl
(
name
)
{
if
(
!
indexPromise
)
{
const
apiBase
=
new
URL
(
prefs
.
getCharPref
(
"
api_url
"
)
)
;
if
(
!
apiBase
.
pathname
.
endsWith
(
"
/
"
)
)
{
apiBase
.
pathname
+
=
"
/
"
;
}
indexPromise
=
this
.
get
(
apiBase
.
toString
(
)
)
.
then
(
res
=
>
res
.
json
(
)
)
;
}
const
index
=
await
indexPromise
;
if
(
!
(
name
in
index
)
)
{
throw
new
Error
(
API
endpoint
with
name
"
{
name
}
"
not
found
.
)
;
}
const
url
=
index
[
name
]
;
return
this
.
absolutify
(
url
)
;
}
async
fetchSignedObjects
(
type
filters
)
{
const
signedObjectsUrl
=
await
this
.
getApiUrl
(
{
type
}
-
signed
)
;
const
objectsResponse
=
await
this
.
get
(
signedObjectsUrl
filters
)
;
const
rawText
=
await
objectsResponse
.
text
(
)
;
const
objectsWithSigs
=
JSON
.
parse
(
rawText
)
;
return
Promise
.
all
(
objectsWithSigs
.
map
(
async
(
item
)
=
>
{
const
object
=
item
[
type
]
;
const
serialized
=
CanonicalJSON
.
stringify
(
object
)
;
if
(
!
rawText
.
includes
(
serialized
)
)
{
log
.
debug
(
rawText
serialized
)
;
throw
new
NormandyApi
.
InvalidSignatureError
(
Canonical
{
type
}
serialization
does
not
match
!
)
;
}
await
this
.
verifyObjectSignature
(
serialized
item
.
signature
type
)
;
return
object
;
}
)
)
;
}
async
verifyObjectSignature
(
data
signaturePayload
type
)
{
const
{
signature
x5u
}
=
signaturePayload
;
const
certChainResponse
=
await
this
.
get
(
this
.
absolutify
(
x5u
)
)
;
const
certChain
=
await
certChainResponse
.
text
(
)
;
const
builtSignature
=
p384ecdsa
=
{
signature
}
;
const
serialized
=
typeof
data
=
=
"
string
"
?
data
:
CanonicalJSON
.
stringify
(
data
)
;
const
verifier
=
Cc
[
"
mozilla
.
org
/
security
/
contentsignatureverifier
;
1
"
]
.
createInstance
(
Ci
.
nsIContentSignatureVerifier
)
;
let
valid
;
try
{
valid
=
await
verifier
.
asyncVerifyContentSignature
(
serialized
builtSignature
certChain
"
normandy
.
content
-
signature
.
mozilla
.
org
"
)
;
}
catch
(
err
)
{
throw
new
NormandyApi
.
InvalidSignatureError
(
{
type
}
signature
validation
failed
:
{
err
}
)
;
}
if
(
!
valid
)
{
throw
new
NormandyApi
.
InvalidSignatureError
(
{
type
}
signature
is
not
valid
)
;
}
}
async
classifyClient
(
)
{
const
classifyClientUrl
=
await
this
.
getApiUrl
(
"
classify
-
client
"
)
;
const
response
=
await
this
.
get
(
classifyClientUrl
)
;
const
clientData
=
await
response
.
json
(
)
;
clientData
.
request_time
=
new
Date
(
clientData
.
request_time
)
;
return
clientData
;
}
async
fetchRecipes
(
filters
=
{
enabled
:
true
}
)
{
return
this
.
fetchSignedObjects
(
"
recipe
"
filters
)
;
}
async
fetchExtensionDetails
(
extensionId
)
{
const
baseUrl
=
await
this
.
getApiUrl
(
"
extension
-
list
"
)
;
const
extensionDetailsUrl
=
{
baseUrl
}
{
extensionId
}
/
;
const
response
=
await
this
.
get
(
extensionDetailsUrl
)
;
return
response
.
json
(
)
;
}
}
;
