const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
LogManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonStudyAction
:
"
resource
:
/
/
normandy
/
actions
/
AddonStudyAction
.
jsm
"
BranchedAddonStudyAction
:
"
resource
:
/
/
normandy
/
actions
/
BranchedAddonStudyAction
.
jsm
"
ConsoleLogAction
:
"
resource
:
/
/
normandy
/
actions
/
ConsoleLogAction
.
jsm
"
PreferenceExperimentAction
:
"
resource
:
/
/
normandy
/
actions
/
PreferenceExperimentAction
.
jsm
"
PreferenceRollbackAction
:
"
resource
:
/
/
normandy
/
actions
/
PreferenceRollbackAction
.
jsm
"
PreferenceRolloutAction
:
"
resource
:
/
/
normandy
/
actions
/
PreferenceRolloutAction
.
jsm
"
ShowHeartbeatAction
:
"
resource
:
/
/
normandy
/
actions
/
ShowHeartbeatAction
.
jsm
"
SinglePreferenceExperimentAction
:
"
resource
:
/
/
normandy
/
actions
/
SinglePreferenceExperimentAction
.
jsm
"
Uptake
:
"
resource
:
/
/
normandy
/
lib
/
Uptake
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
ActionsManager
"
]
;
const
log
=
LogManager
.
getLogger
(
"
recipe
-
runner
"
)
;
const
actionConstructors
=
{
"
addon
-
study
"
:
AddonStudyAction
"
branched
-
addon
-
study
"
:
BranchedAddonStudyAction
"
console
-
log
"
:
ConsoleLogAction
"
multi
-
preference
-
experiment
"
:
PreferenceExperimentAction
"
preference
-
rollback
"
:
PreferenceRollbackAction
"
preference
-
rollout
"
:
PreferenceRolloutAction
"
show
-
heartbeat
"
:
ShowHeartbeatAction
"
single
-
preference
-
experiment
"
:
SinglePreferenceExperimentAction
}
;
const
actionAliases
=
{
"
opt
-
out
-
study
"
:
"
addon
-
study
"
"
preference
-
experiment
"
:
"
single
-
preference
-
experiment
"
}
;
class
ActionsManager
{
constructor
(
)
{
this
.
finalized
=
false
;
this
.
localActions
=
{
}
;
for
(
const
[
name
Constructor
]
of
Object
.
entries
(
actionConstructors
)
)
{
this
.
localActions
[
name
]
=
new
Constructor
(
)
;
}
for
(
const
[
alias
target
]
of
Object
.
entries
(
actionAliases
)
)
{
this
.
localActions
[
alias
]
=
this
.
localActions
[
target
]
;
}
}
static
getCapabilities
(
)
{
let
capabilities
=
new
Set
(
)
;
for
(
const
actionName
of
Object
.
keys
(
actionConstructors
)
)
{
capabilities
.
add
(
action
.
{
actionName
}
)
;
}
for
(
const
actionAlias
of
Object
.
keys
(
actionAliases
)
)
{
capabilities
.
add
(
action
.
{
actionAlias
}
)
;
}
return
capabilities
;
}
async
runRecipe
(
recipe
)
{
let
actionName
=
recipe
.
action
;
if
(
actionName
in
this
.
localActions
)
{
log
.
info
(
Executing
recipe
"
{
recipe
.
name
}
"
(
action
=
{
recipe
.
action
}
)
)
;
const
action
=
this
.
localActions
[
actionName
]
;
await
action
.
runRecipe
(
recipe
)
;
}
else
{
log
.
error
(
Could
not
execute
recipe
{
recipe
.
name
}
:
Action
{
recipe
.
action
}
is
either
missing
or
invalid
.
)
;
await
Uptake
.
reportRecipe
(
recipe
Uptake
.
RECIPE_INVALID_ACTION
)
;
}
}
async
finalize
(
)
{
if
(
this
.
finalized
)
{
throw
new
Error
(
"
ActionsManager
has
already
been
finalized
"
)
;
}
this
.
finalized
=
true
;
for
(
const
action
of
new
Set
(
Object
.
values
(
this
.
localActions
)
)
)
{
action
.
finalize
(
)
;
}
}
}
