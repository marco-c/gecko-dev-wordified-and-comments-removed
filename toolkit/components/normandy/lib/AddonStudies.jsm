"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
IndexedDB
"
"
resource
:
/
/
gre
/
modules
/
IndexedDB
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CleanupManager
"
"
resource
:
/
/
normandy
/
lib
/
CleanupManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
LogManager
"
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryEvents
"
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
AddonStudies
"
]
;
const
DB_NAME
=
"
shield
"
;
const
STORE_NAME
=
"
addon
-
studies
"
;
const
DB_OPTIONS
=
{
version
:
1
}
;
const
STUDY_ENDED_TOPIC
=
"
shield
-
study
-
ended
"
;
const
log
=
LogManager
.
getLogger
(
"
addon
-
studies
"
)
;
function
openDatabase
(
)
{
return
IndexedDB
.
open
(
DB_NAME
DB_OPTIONS
db
=
>
{
db
.
createObjectStore
(
STORE_NAME
{
keyPath
:
"
recipeId
"
}
)
;
}
)
;
}
let
databasePromise
;
async
function
getDatabase
(
)
{
if
(
!
databasePromise
)
{
databasePromise
=
openDatabase
(
)
;
}
return
databasePromise
;
}
function
getStore
(
db
mode
)
{
if
(
!
mode
)
{
throw
new
Error
(
"
mode
is
required
"
)
;
}
return
db
.
objectStore
(
STORE_NAME
mode
)
;
}
var
AddonStudies
=
{
withStudies
(
studies
=
[
]
)
{
return
function
wrapper
(
testFunction
)
{
return
async
function
wrappedTestFunction
(
.
.
.
args
)
{
const
oldStudies
=
await
AddonStudies
.
getAll
(
)
;
let
db
=
await
getDatabase
(
)
;
await
AddonStudies
.
clear
(
)
;
const
store
=
getStore
(
db
"
readwrite
"
)
;
await
Promise
.
all
(
studies
.
map
(
study
=
>
store
.
add
(
study
)
)
)
;
try
{
await
testFunction
(
.
.
.
args
studies
)
;
}
finally
{
db
=
await
getDatabase
(
)
;
await
AddonStudies
.
clear
(
)
;
const
store
=
getStore
(
db
"
readwrite
"
)
;
await
Promise
.
all
(
oldStudies
.
map
(
study
=
>
store
.
add
(
study
)
)
)
;
}
}
;
}
;
}
async
init
(
)
{
const
activeStudies
=
(
await
this
.
getAll
(
)
)
.
filter
(
study
=
>
study
.
active
)
;
for
(
const
study
of
activeStudies
)
{
const
addon
=
await
AddonManager
.
getAddonByID
(
study
.
addonId
)
;
if
(
!
addon
)
{
await
this
.
markAsEnded
(
study
"
uninstalled
-
sideload
"
)
;
}
}
AddonManager
.
addAddonListener
(
this
)
;
CleanupManager
.
addCleanupHandler
(
(
)
=
>
{
AddonManager
.
removeAddonListener
(
this
)
;
}
)
;
}
async
onUninstalled
(
addon
)
{
const
activeStudies
=
(
await
this
.
getAll
(
)
)
.
filter
(
study
=
>
study
.
active
)
;
const
matchingStudy
=
activeStudies
.
find
(
study
=
>
study
.
addonId
=
=
=
addon
.
id
)
;
if
(
matchingStudy
)
{
await
this
.
markAsEnded
(
matchingStudy
"
uninstalled
"
)
;
}
}
async
clear
(
)
{
const
db
=
await
getDatabase
(
)
;
await
getStore
(
db
"
readwrite
"
)
.
clear
(
)
;
}
async
has
(
recipeId
)
{
const
db
=
await
getDatabase
(
)
;
const
study
=
await
getStore
(
db
"
readonly
"
)
.
get
(
recipeId
)
;
return
!
!
study
;
}
async
get
(
recipeId
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readonly
"
)
.
get
(
recipeId
)
;
}
async
getAll
(
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readonly
"
)
.
getAll
(
)
;
}
async
add
(
study
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readwrite
"
)
.
add
(
study
)
;
}
async
delete
(
recipeId
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readwrite
"
)
.
delete
(
recipeId
)
;
}
async
markAsEnded
(
study
reason
)
{
if
(
reason
=
=
=
"
unknown
"
)
{
log
.
warn
(
Study
{
study
.
name
}
ending
for
unknown
reason
.
)
;
}
study
.
active
=
false
;
study
.
studyEndDate
=
new
Date
(
)
;
const
db
=
await
getDatabase
(
)
;
await
getStore
(
db
"
readwrite
"
)
.
put
(
study
)
;
Services
.
obs
.
notifyObservers
(
study
STUDY_ENDED_TOPIC
{
study
.
recipeId
}
)
;
TelemetryEvents
.
sendEvent
(
"
unenroll
"
"
addon_study
"
study
.
name
{
addonId
:
study
.
addonId
addonVersion
:
study
.
addonVersion
reason
}
)
;
await
this
.
onUnenroll
(
study
.
addonId
reason
)
;
}
_unenrollListeners
:
new
Map
(
)
addUnenrollListener
(
id
listener
)
{
let
listeners
=
this
.
_unenrollListeners
.
get
(
id
)
;
if
(
!
listeners
)
{
listeners
=
new
Set
(
)
;
this
.
_unenrollListeners
.
set
(
id
listeners
)
;
}
listeners
.
add
(
listener
)
;
}
onUnenroll
(
id
reason
)
{
let
callbacks
=
this
.
_unenrollListeners
.
get
(
id
)
;
let
promises
=
[
]
;
if
(
callbacks
)
{
for
(
let
callback
of
callbacks
)
{
promises
.
push
(
callback
(
reason
)
)
;
}
}
return
Promise
.
all
(
promises
)
;
}
}
;
