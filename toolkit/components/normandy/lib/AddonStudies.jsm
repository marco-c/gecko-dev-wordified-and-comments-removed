"
use
strict
"
;
const
{
LogManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
IndexedDB
"
"
resource
:
/
/
gre
/
modules
/
IndexedDB
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
BranchedAddonStudyAction
"
"
resource
:
/
/
normandy
/
actions
/
BranchedAddonStudyAction
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
CleanupManager
"
"
resource
:
/
/
normandy
/
lib
/
CleanupManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
TelemetryEnvironment
"
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
TelemetryEvents
"
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
AddonStudies
"
]
;
const
DB_NAME
=
"
shield
"
;
const
STORE_NAME
=
"
addon
-
studies
"
;
const
VERSION_STORE_NAME
=
"
addon
-
studies
-
version
"
;
const
DB_VERSION
=
2
;
const
STUDY_ENDED_TOPIC
=
"
shield
-
study
-
ended
"
;
const
log
=
LogManager
.
getLogger
(
"
addon
-
studies
"
)
;
function
openDatabase
(
)
{
return
lazy
.
IndexedDB
.
open
(
DB_NAME
DB_VERSION
async
(
db
event
)
=
>
{
if
(
event
.
oldVersion
<
1
)
{
db
.
createObjectStore
(
STORE_NAME
{
keyPath
:
"
recipeId
"
}
)
;
}
if
(
event
.
oldVersion
<
2
)
{
db
.
createObjectStore
(
VERSION_STORE_NAME
)
;
}
}
)
;
}
let
databasePromise
;
async
function
getDatabase
(
)
{
if
(
!
databasePromise
)
{
databasePromise
=
openDatabase
(
)
;
}
return
databasePromise
;
}
function
getStore
(
db
mode
)
{
if
(
!
mode
)
{
throw
new
Error
(
"
mode
is
required
"
)
;
}
return
db
.
objectStore
(
STORE_NAME
mode
)
;
}
var
AddonStudies
=
{
withStudies
(
addonStudies
=
[
]
)
{
return
function
wrapper
(
testFunction
)
{
return
async
function
wrappedTestFunction
(
args
)
{
const
oldStudies
=
await
AddonStudies
.
getAll
(
)
;
let
db
=
await
getDatabase
(
)
;
await
AddonStudies
.
clear
(
)
;
const
store
=
getStore
(
db
"
readwrite
"
)
;
await
Promise
.
all
(
addonStudies
.
map
(
study
=
>
store
.
add
(
study
)
)
)
;
try
{
await
testFunction
(
{
.
.
.
args
addonStudies
}
)
;
}
finally
{
db
=
await
getDatabase
(
)
;
await
AddonStudies
.
clear
(
)
;
const
store
=
getStore
(
db
"
readwrite
"
)
;
await
Promise
.
all
(
oldStudies
.
map
(
study
=
>
store
.
add
(
study
)
)
)
;
}
}
;
}
;
}
async
init
(
)
{
for
(
const
study
of
await
this
.
getAllActive
(
)
)
{
const
addon
=
await
lazy
.
AddonManager
.
getAddonByID
(
study
.
addonId
)
;
if
(
!
addon
)
{
await
this
.
markAsEnded
(
study
"
uninstalled
-
sideload
"
)
;
continue
;
}
lazy
.
TelemetryEnvironment
.
setExperimentActive
(
study
.
slug
study
.
branch
{
type
:
"
normandy
-
addonstudy
"
enrollmentId
:
study
.
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
lazy
.
AddonManager
.
addAddonListener
(
this
)
;
lazy
.
CleanupManager
.
addCleanupHandler
(
(
)
=
>
{
lazy
.
AddonManager
.
removeAddonListener
(
this
)
;
}
)
;
}
async
onTelemetryDisabled
(
)
{
const
studies
=
await
this
.
getAll
(
)
;
for
(
const
study
of
studies
)
{
study
.
enrollmentId
=
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
;
}
await
this
.
updateMany
(
studies
)
;
}
migrations
:
{
async
migration01AddonStudyFieldsToSlugAndUserFacingFields
(
)
{
const
db
=
await
getDatabase
(
)
;
const
studies
=
await
db
.
objectStore
(
STORE_NAME
"
readonly
"
)
.
getAll
(
)
;
if
(
studies
.
length
=
=
=
0
)
{
return
;
}
const
writePromises
=
[
]
;
const
objectStore
=
db
.
objectStore
(
STORE_NAME
"
readwrite
"
)
;
for
(
const
study
of
studies
)
{
if
(
!
study
.
slug
)
{
study
.
slug
=
study
.
name
;
}
if
(
study
.
name
&
&
!
study
.
userFacingName
)
{
study
.
userFacingName
=
study
.
name
;
}
delete
study
.
name
;
if
(
study
.
description
&
&
!
study
.
userFacingDescription
)
{
study
.
userFacingDescription
=
study
.
description
;
}
delete
study
.
description
;
if
(
!
study
.
branch
)
{
study
.
branch
=
AddonStudies
.
NO_BRANCHES_MARKER
;
}
writePromises
.
push
(
objectStore
.
put
(
study
)
)
;
}
await
Promise
.
all
(
writePromises
)
;
}
async
migration02RemoveOldAddonStudyAction
(
)
{
const
studies
=
await
AddonStudies
.
getAllActive
(
{
branched
:
AddonStudies
.
FILTER_NOT_BRANCHED
}
)
;
if
(
!
studies
.
length
)
{
return
;
}
const
action
=
new
lazy
.
BranchedAddonStudyAction
(
)
;
for
(
const
study
of
studies
)
{
try
{
await
action
.
unenroll
(
study
.
recipeId
"
migration
-
removing
-
unbranched
-
action
"
)
;
}
catch
(
e
)
{
log
.
error
(
Stopping
add
-
on
study
{
study
.
slug
}
during
migration
failed
:
{
e
}
)
;
}
}
}
}
async
onUninstalled
(
addon
)
{
const
activeStudies
=
(
await
this
.
getAll
(
)
)
.
filter
(
study
=
>
study
.
active
)
;
const
matchingStudy
=
activeStudies
.
find
(
study
=
>
study
.
addonId
=
=
=
addon
.
id
)
;
if
(
matchingStudy
)
{
await
this
.
markAsEnded
(
matchingStudy
"
uninstalled
"
)
;
}
}
async
clear
(
)
{
const
db
=
await
getDatabase
(
)
;
await
getStore
(
db
"
readwrite
"
)
.
clear
(
)
;
}
async
has
(
recipeId
)
{
const
db
=
await
getDatabase
(
)
;
const
study
=
await
getStore
(
db
"
readonly
"
)
.
get
(
recipeId
)
;
return
!
!
study
;
}
async
get
(
recipeId
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readonly
"
)
.
get
(
recipeId
)
;
}
FILTER_BRANCHED_ONLY
:
Symbol
(
"
FILTER_BRANCHED_ONLY
"
)
FILTER_NOT_BRANCHED
:
Symbol
(
"
FILTER_NOT_BRANCHED
"
)
FILTER_ALL
:
Symbol
(
"
FILTER_ALL
"
)
async
getAll
(
{
branched
=
AddonStudies
.
FILTER_ALL
}
=
{
}
)
{
const
db
=
await
getDatabase
(
)
;
let
results
=
await
getStore
(
db
"
readonly
"
)
.
getAll
(
)
;
if
(
branched
=
=
AddonStudies
.
FILTER_BRANCHED_ONLY
)
{
results
=
results
.
filter
(
study
=
>
study
.
branch
!
=
AddonStudies
.
NO_BRANCHES_MARKER
)
;
}
else
if
(
branched
=
=
AddonStudies
.
FILTER_NOT_BRANCHED
)
{
results
=
results
.
filter
(
study
=
>
study
.
branch
=
=
AddonStudies
.
NO_BRANCHES_MARKER
)
;
}
return
results
;
}
async
getAllActive
(
options
)
{
return
(
await
this
.
getAll
(
options
)
)
.
filter
(
study
=
>
study
.
active
)
;
}
async
add
(
study
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readwrite
"
)
.
add
(
study
)
;
}
async
update
(
study
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readwrite
"
)
.
put
(
study
)
;
}
async
updateMany
(
studies
)
{
if
(
!
studies
.
length
)
{
return
;
}
const
db
=
await
getDatabase
(
)
;
let
store
=
await
getStore
(
db
"
readonly
"
)
;
await
Promise
.
all
(
studies
.
map
(
async
(
{
recipeId
}
)
=
>
{
let
existingStudy
=
await
store
.
get
(
recipeId
)
;
if
(
!
existingStudy
)
{
throw
new
Error
(
Tried
to
update
addon
study
{
recipeId
}
but
it
doesn
'
t
exist
.
)
;
}
}
)
)
;
store
=
await
getStore
(
db
"
readwrite
"
)
;
await
Promise
.
all
(
studies
.
map
(
study
=
>
store
.
put
(
study
)
)
)
;
}
async
delete
(
recipeId
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readwrite
"
)
.
delete
(
recipeId
)
;
}
async
markAsEnded
(
study
reason
=
"
unknown
"
)
{
if
(
reason
=
=
=
"
unknown
"
)
{
log
.
warn
(
Study
{
study
.
slug
}
ending
for
unknown
reason
.
)
;
}
study
.
active
=
false
;
study
.
temporaryErrorDeadline
=
null
;
study
.
studyEndDate
=
new
Date
(
)
;
const
db
=
await
getDatabase
(
)
;
await
getStore
(
db
"
readwrite
"
)
.
put
(
study
)
;
Services
.
obs
.
notifyObservers
(
study
STUDY_ENDED_TOPIC
{
study
.
recipeId
}
)
;
lazy
.
TelemetryEvents
.
sendEvent
(
"
unenroll
"
"
addon_study
"
study
.
slug
{
addonId
:
study
.
addonId
|
|
AddonStudies
.
NO_ADDON_MARKER
addonVersion
:
study
.
addonVersion
|
|
AddonStudies
.
NO_ADDON_MARKER
reason
branch
:
study
.
branch
enrollmentId
:
study
.
enrollmentId
|
|
lazy
.
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
lazy
.
TelemetryEnvironment
.
setExperimentInactive
(
study
.
slug
)
;
await
this
.
callUnenrollListeners
(
study
.
addonId
reason
)
;
}
_unenrollListeners
:
new
Map
(
)
addUnenrollListener
(
id
listener
)
{
let
listeners
=
this
.
_unenrollListeners
.
get
(
id
)
;
if
(
!
listeners
)
{
listeners
=
new
Set
(
)
;
this
.
_unenrollListeners
.
set
(
id
listeners
)
;
}
listeners
.
add
(
listener
)
;
}
removeUnenrollListener
(
id
listener
)
{
let
listeners
=
this
.
_unenrollListeners
.
get
(
id
)
;
if
(
listeners
)
{
listeners
.
delete
(
listener
)
;
}
}
async
callUnenrollListeners
(
id
reason
)
{
let
callbacks
=
this
.
_unenrollListeners
.
get
(
id
)
|
|
[
]
;
async
function
callCallback
(
cb
reason
)
{
try
{
await
cb
(
reason
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
let
promises
=
[
]
;
for
(
let
callback
of
callbacks
)
{
promises
.
push
(
callCallback
(
callback
reason
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
}
;
AddonStudies
.
NO_BRANCHES_MARKER
=
"
__NO_BRANCHES__
"
;
AddonStudies
.
NO_ADDON_MARKER
=
"
__NO_ADDON__
"
;
