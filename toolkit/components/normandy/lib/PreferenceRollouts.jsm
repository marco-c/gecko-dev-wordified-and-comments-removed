"
use
strict
"
;
const
{
LogManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
LogManager
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
IndexedDB
"
"
resource
:
/
/
gre
/
modules
/
IndexedDB
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryEnvironment
"
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CleanupManager
"
"
resource
:
/
/
normandy
/
lib
/
CleanupManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrefUtils
"
"
resource
:
/
/
normandy
/
lib
/
PrefUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TelemetryEvents
"
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
)
;
const
log
=
LogManager
.
getLogger
(
"
recipe
-
runner
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
PreferenceRollouts
"
]
;
const
STARTUP_PREFS_BRANCH
=
"
app
.
normandy
.
startupRolloutPrefs
.
"
;
const
DB_NAME
=
"
normandy
-
preference
-
rollout
"
;
const
STORE_NAME
=
"
preference
-
rollouts
"
;
const
DB_VERSION
=
1
;
function
openDatabase
(
)
{
return
IndexedDB
.
open
(
DB_NAME
DB_VERSION
db
=
>
{
db
.
createObjectStore
(
STORE_NAME
{
keyPath
:
"
slug
"
}
)
;
}
)
;
}
let
databasePromise
;
function
getDatabase
(
)
{
if
(
!
databasePromise
)
{
databasePromise
=
openDatabase
(
)
;
}
return
databasePromise
;
}
function
getStore
(
db
mode
)
{
if
(
!
mode
)
{
throw
new
Error
(
"
mode
is
required
"
)
;
}
return
db
.
objectStore
(
STORE_NAME
mode
)
;
}
var
PreferenceRollouts
=
{
STATE_ACTIVE
:
"
active
"
STATE_ROLLED_BACK
:
"
rolled
-
back
"
STATE_GRADUATED
:
"
graduated
"
GRADUATION_SET
:
new
Set
(
[
"
pref
-
webrender
-
intel
-
rollout
-
70
-
release
"
"
bug
-
1703186
-
rollout
-
http3
-
support
-
release
-
88
-
89
"
"
rollout
-
doh
-
nightly
-
rollout
-
to
-
all
-
us
-
desktop
-
users
-
nightly
-
74
-
80
-
bug
-
1613481
"
"
rollout
-
doh
-
beta
-
rollout
-
to
-
all
-
us
-
desktop
-
users
-
v2
-
beta
-
74
-
80
-
bug
-
1613489
"
"
rollout
-
doh
-
us
-
staged
-
rollout
-
to
-
all
-
us
-
desktop
-
users
-
release
-
73
-
77
-
bug
-
1586331
"
"
bug
-
1648229
-
rollout
-
comcast
-
steering
-
rollout
-
release
-
78
-
80
"
"
bug
-
1732206
-
rollout
-
fission
-
release
-
rollout
-
release
-
94
-
95
"
"
bug
-
1745237
-
rollout
-
fission
-
beta
-
96
-
97
-
rollout
-
beta
-
96
-
97
"
"
bug
-
1750601
-
rollout
-
doh
-
steering
-
in
-
canada
-
staggered
-
starting
-
for
-
release
-
97
-
98
"
"
bug
-
1758988
-
rollout
-
doh
-
enablment
-
to
-
new
-
countries
-
staggered
-
st
-
release
-
98
-
100
"
"
bug
-
1758818
-
rollout
-
enabling
-
doh
-
in
-
new
-
countries
-
staggered
-
sta
-
release
-
98
-
100
"
]
)
async
recordOriginalValues
(
originalPreferences
)
{
for
(
const
rollout
of
await
this
.
getAllActive
(
)
)
{
let
shouldSaveRollout
=
false
;
let
prefMatchingDefaultCount
=
0
;
for
(
const
prefSpec
of
rollout
.
preferences
)
{
const
builtInDefault
=
originalPreferences
[
prefSpec
.
preferenceName
]
;
if
(
prefSpec
.
value
=
=
=
builtInDefault
)
{
prefMatchingDefaultCount
+
+
;
}
if
(
prefSpec
.
previousValue
!
=
=
builtInDefault
)
{
prefSpec
.
previousValue
=
builtInDefault
;
shouldSaveRollout
=
true
;
}
}
if
(
prefMatchingDefaultCount
=
=
=
rollout
.
preferences
.
length
)
{
await
this
.
graduate
(
rollout
"
all
-
prefs
-
match
"
)
;
shouldSaveRollout
=
false
;
}
if
(
shouldSaveRollout
)
{
const
db
=
await
getDatabase
(
)
;
await
getStore
(
db
"
readwrite
"
)
.
put
(
rollout
)
;
}
}
}
async
init
(
)
{
CleanupManager
.
addCleanupHandler
(
(
)
=
>
this
.
saveStartupPrefs
(
)
)
;
for
(
const
rollout
of
await
this
.
getAllActive
(
)
)
{
if
(
this
.
GRADUATION_SET
.
has
(
rollout
.
slug
)
)
{
await
this
.
graduate
(
rollout
"
in
-
graduation
-
set
"
)
;
continue
;
}
TelemetryEnvironment
.
setExperimentActive
(
rollout
.
slug
rollout
.
state
{
type
:
"
normandy
-
prefrollout
"
enrollmentId
:
rollout
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
}
async
onTelemetryDisabled
(
)
{
const
rollouts
=
await
this
.
getAll
(
)
;
for
(
const
rollout
of
rollouts
)
{
rollout
.
enrollmentId
=
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
;
}
await
this
.
updateMany
(
rollouts
)
;
}
withTestMock
(
{
graduationSet
=
new
Set
(
)
rollouts
:
prefRollouts
=
[
]
}
=
{
}
)
{
return
testFunction
=
>
{
return
async
args
=
>
{
let
db
=
await
getDatabase
(
)
;
const
oldData
=
await
getStore
(
db
"
readonly
"
)
.
getAll
(
)
;
await
getStore
(
db
"
readwrite
"
)
.
clear
(
)
;
await
Promise
.
all
(
prefRollouts
.
map
(
r
=
>
this
.
add
(
r
)
)
)
;
const
oldGraduationSet
=
this
.
GRADUATION_SET
;
this
.
GRADUATION_SET
=
graduationSet
;
try
{
await
testFunction
(
{
.
.
.
args
prefRollouts
}
)
;
}
finally
{
this
.
GRADUATION_SET
=
oldGraduationSet
;
db
=
await
getDatabase
(
)
;
await
getStore
(
db
"
readwrite
"
)
.
clear
(
)
;
const
store
=
getStore
(
db
"
readwrite
"
)
;
await
Promise
.
all
(
oldData
.
map
(
d
=
>
store
.
add
(
d
)
)
)
;
}
}
;
}
;
}
async
add
(
rollout
)
{
if
(
!
rollout
.
enrollmentId
)
{
throw
new
Error
(
"
Rollout
must
have
an
enrollment
ID
"
)
;
}
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readwrite
"
)
.
add
(
rollout
)
;
}
async
update
(
rollout
)
{
if
(
!
(
await
this
.
has
(
rollout
.
slug
)
)
)
{
throw
new
Error
(
Tried
to
update
{
rollout
.
slug
}
but
it
doesn
'
t
already
exist
.
)
;
}
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readwrite
"
)
.
put
(
rollout
)
;
}
async
updateMany
(
rollouts
)
{
if
(
!
rollouts
.
length
)
{
return
;
}
const
db
=
await
getDatabase
(
)
;
let
store
=
await
getStore
(
db
"
readonly
"
)
;
await
Promise
.
all
(
rollouts
.
map
(
async
(
{
slug
}
)
=
>
{
let
existingRollout
=
await
store
.
get
(
slug
)
;
if
(
!
existingRollout
)
{
throw
new
Error
(
Tried
to
update
{
slug
}
but
it
doesn
'
t
exist
.
)
;
}
}
)
)
;
store
=
await
getStore
(
db
"
readwrite
"
)
;
await
Promise
.
all
(
rollouts
.
map
(
rollout
=
>
store
.
put
(
rollout
)
)
)
;
}
async
has
(
slug
)
{
const
db
=
await
getDatabase
(
)
;
const
rollout
=
await
getStore
(
db
"
readonly
"
)
.
get
(
slug
)
;
return
!
!
rollout
;
}
async
get
(
slug
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readonly
"
)
.
get
(
slug
)
;
}
async
getAll
(
)
{
const
db
=
await
getDatabase
(
)
;
return
getStore
(
db
"
readonly
"
)
.
getAll
(
)
;
}
async
getAllActive
(
)
{
const
rollouts
=
await
this
.
getAll
(
)
;
return
rollouts
.
filter
(
rollout
=
>
rollout
.
state
=
=
=
this
.
STATE_ACTIVE
)
;
}
async
saveStartupPrefs
(
)
{
const
prefBranch
=
Services
.
prefs
.
getBranch
(
STARTUP_PREFS_BRANCH
)
;
for
(
const
pref
of
prefBranch
.
getChildList
(
"
"
)
)
{
prefBranch
.
clearUserPref
(
pref
)
;
}
for
(
const
rollout
of
await
this
.
getAllActive
(
)
)
{
for
(
const
prefSpec
of
rollout
.
preferences
)
{
PrefUtils
.
setPref
(
STARTUP_PREFS_BRANCH
+
prefSpec
.
preferenceName
prefSpec
.
value
)
;
}
}
}
async
graduate
(
rollout
reason
)
{
log
.
debug
(
Graduating
rollout
:
{
rollout
.
slug
}
)
;
rollout
.
state
=
this
.
STATE_GRADUATED
;
const
db
=
await
getDatabase
(
)
;
await
getStore
(
db
"
readwrite
"
)
.
put
(
rollout
)
;
TelemetryEvents
.
sendEvent
(
"
graduate
"
"
preference_rollout
"
rollout
.
slug
{
reason
enrollmentId
:
rollout
.
enrollmentId
|
|
TelemetryEvents
.
NO_ENROLLMENT_ID_MARKER
}
)
;
}
}
;
