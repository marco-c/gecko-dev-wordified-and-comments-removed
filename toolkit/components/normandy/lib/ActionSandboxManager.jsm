"
use
strict
"
;
const
{
NormandyDriver
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
NormandyDriver
.
jsm
"
)
;
const
{
SandboxManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
SandboxManager
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
ActionSandboxManager
"
]
;
var
ActionSandboxManager
=
class
extends
SandboxManager
{
constructor
(
actionScript
)
{
super
(
)
;
const
driver
=
new
NormandyDriver
(
this
)
;
this
.
cloneIntoGlobal
(
"
sandboxedDriver
"
driver
{
cloneFunctions
:
true
}
)
;
this
.
evalInSandbox
(
/
/
Shim
old
API
for
registering
actions
function
registerAction
(
name
Action
)
{
registerAsyncCallback
(
"
action
"
(
driver
recipe
)
=
>
{
return
new
Action
(
driver
recipe
)
.
execute
(
)
;
}
)
;
}
;
this
.
asyncCallbacks
=
new
Map
(
)
;
function
registerAsyncCallback
(
name
callback
)
{
asyncCallbacks
.
set
(
name
callback
)
;
}
this
.
window
=
this
;
this
.
setTimeout
=
sandboxedDriver
.
setTimeout
;
this
.
clearTimeout
=
sandboxedDriver
.
clearTimeout
;
)
;
this
.
evalInSandbox
(
actionScript
)
;
}
async
runAsyncCallback
(
callbackName
.
.
.
args
)
{
const
callbackWasRegistered
=
this
.
evalInSandbox
(
asyncCallbacks
.
has
(
"
{
callbackName
}
"
)
)
;
if
(
!
callbackWasRegistered
)
{
return
undefined
;
}
this
.
cloneIntoGlobal
(
"
callbackArgs
"
args
)
;
const
result
=
await
this
.
evalInSandbox
(
asyncCallbacks
.
get
(
"
{
callbackName
}
"
)
(
sandboxedDriver
.
.
.
callbackArgs
)
;
)
;
return
Cu
.
cloneInto
(
result
{
}
)
;
}
}
;
