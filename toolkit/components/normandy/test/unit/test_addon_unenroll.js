const
{
AddonTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
)
;
const
{
ExtensionTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
ExtensionXPCShellUtils
.
jsm
"
)
;
const
{
BranchedAddonStudyAction
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
normandy
/
actions
/
BranchedAddonStudyAction
.
sys
.
mjs
"
)
;
const
{
BaseAction
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
normandy
/
actions
/
BaseAction
.
sys
.
mjs
"
)
;
const
{
TelemetryEvents
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
sys
.
mjs
"
)
;
const
{
AddonManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
{
AddonStudies
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
normandy
/
lib
/
AddonStudies
.
sys
.
mjs
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
sys
.
mjs
"
)
;
load
(
"
utils
.
js
"
)
;
NormandyTestUtils
.
init
(
{
add_task
}
)
;
const
{
decorate_task
}
=
NormandyTestUtils
;
const
global
=
this
;
add_task
(
async
(
)
=
>
{
ExtensionTestUtils
.
init
(
global
)
;
AddonTestUtils
.
init
(
global
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
1
"
"
1
.
9
.
2
"
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
await
AddonTestUtils
.
promiseStartupManager
(
)
;
TelemetryEvents
.
init
(
)
;
}
)
;
decorate_task
(
withMockApiServer
(
)
AddonStudies
.
withStudies
(
[
]
)
async
function
test_addon_unenroll
(
{
server
:
apiServer
}
)
{
const
ID
=
"
study
tests
.
mozilla
.
org
"
;
let
xpi
=
AddonTestUtils
.
createTempWebExtensionFile
(
{
manifest
:
{
version
:
"
1
.
0
"
browser_specific_settings
:
{
gecko
:
{
id
:
ID
}
}
experiment_apis
:
{
study
:
{
schema
:
"
schema
.
json
"
parent
:
{
scopes
:
[
"
addon_parent
"
]
script
:
"
api
.
js
"
paths
:
[
[
"
study
"
]
]
}
}
}
}
files
:
{
"
schema
.
json
"
:
JSON
.
stringify
(
[
{
namespace
:
"
study
"
events
:
[
{
name
:
"
onStudyEnded
"
type
:
"
function
"
}
]
}
]
)
"
api
.
js
"
:
(
)
=
>
{
const
{
AddonStudies
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
normandy
/
lib
/
AddonStudies
.
sys
.
mjs
"
)
;
const
{
ExtensionCommon
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionCommon
.
jsm
"
)
;
this
.
study
=
class
extends
ExtensionAPI
{
getAPI
(
context
)
{
return
{
study
:
{
onStudyEnded
:
new
ExtensionCommon
.
EventManager
(
{
context
name
:
"
study
.
onStudyEnded
"
register
:
fire
=
>
{
AddonStudies
.
addUnenrollListener
(
this
.
extension
.
id
reason
=
>
fire
.
sync
(
reason
)
)
;
return
(
)
=
>
{
}
;
}
}
)
.
api
(
)
}
}
;
}
}
;
}
}
background
(
)
{
browser
.
study
.
onStudyEnded
.
addListener
(
reason
=
>
{
browser
.
test
.
sendMessage
(
"
got
-
event
"
reason
)
;
return
new
Promise
(
resolve
=
>
{
browser
.
test
.
onMessage
.
addListener
(
resolve
)
;
}
)
;
}
)
;
}
}
)
;
const
server
=
AddonTestUtils
.
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
server
.
registerFile
(
"
/
study
.
xpi
"
xpi
)
;
const
API_ID
=
999
;
apiServer
.
registerPathHandler
(
/
api
/
v1
/
extension
/
{
API_ID
}
/
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
write
(
JSON
.
stringify
(
{
id
:
API_ID
name
:
"
Addon
Unenroll
Fixture
"
xpi
:
"
http
:
/
/
example
.
com
/
study
.
xpi
"
extension_id
:
ID
version
:
"
1
.
0
"
hash
:
CryptoUtils
.
getFileHash
(
xpi
"
sha256
"
)
hash_algorithm
:
"
sha256
"
}
)
)
;
}
)
;
let
extension
=
ExtensionTestUtils
.
expectExtension
(
ID
)
;
const
RECIPE_ID
=
1
;
const
UNENROLL_REASON
=
"
test
-
ending
"
;
let
action
=
new
BranchedAddonStudyAction
(
)
;
await
action
.
processRecipe
(
{
id
:
RECIPE_ID
type
:
"
addon
-
study
"
arguments
:
{
slug
:
"
addon
-
unenroll
-
test
"
userFacingDescription
:
"
A
recipe
to
test
add
-
on
unenrollment
"
userFacingName
:
"
Add
-
on
Unenroll
Test
"
isEnrollmentPaused
:
false
branches
:
[
{
ratio
:
1
slug
:
"
only
"
extensionApiId
:
API_ID
}
]
}
}
BaseAction
.
suitability
.
FILTER_MATCH
)
;
await
extension
.
awaitStartup
(
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
ok
(
addon
"
Extension
is
installed
"
)
;
let
unenrollPromise
=
action
.
unenroll
(
RECIPE_ID
UNENROLL_REASON
)
;
let
receivedReason
=
await
extension
.
awaitMessage
(
"
got
-
event
"
)
;
info
(
"
Got
onStudyEnded
event
in
extension
"
)
;
equal
(
receivedReason
UNENROLL_REASON
"
Unenroll
reason
should
be
passed
"
)
;
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
ok
(
addon
"
Extension
has
not
yet
been
uninstalled
"
)
;
extension
.
sendMessage
(
"
resolve
"
)
;
await
unenrollPromise
;
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
equal
(
addon
null
"
After
resolving
studyEnded
promise
extension
is
uninstalled
"
)
;
}
)
;
decorate_task
(
withMockApiServer
(
)
AddonStudies
.
withStudies
(
[
]
)
async
function
test_addon_unenroll
(
{
server
:
apiServer
}
)
{
const
ID
=
"
study
tests
.
mozilla
.
org
"
;
let
xpi
=
AddonTestUtils
.
createTempWebExtensionFile
(
{
manifest
:
{
version
:
"
1
.
0
"
browser_specific_settings
:
{
gecko
:
{
id
:
ID
}
}
}
}
)
;
const
server
=
AddonTestUtils
.
createHttpServer
(
{
hosts
:
[
"
example
.
com
"
]
}
)
;
server
.
registerFile
(
"
/
study
.
xpi
"
xpi
)
;
const
API_ID
=
999
;
apiServer
.
registerPathHandler
(
/
api
/
v1
/
extension
/
{
API_ID
}
/
(
request
response
)
=
>
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
write
(
JSON
.
stringify
(
{
id
:
API_ID
name
:
"
Addon
Fixture
"
xpi
:
"
http
:
/
/
example
.
com
/
study
.
xpi
"
extension_id
:
ID
version
:
"
1
.
0
"
hash
:
CryptoUtils
.
getFileHash
(
xpi
"
sha256
"
)
hash_algorithm
:
"
sha256
"
}
)
)
;
}
)
;
let
extension
=
ExtensionTestUtils
.
expectExtension
(
ID
)
;
const
RECIPE_ID
=
1
;
const
UNENROLL_REASON
=
"
test
-
ending
"
;
let
action
=
new
BranchedAddonStudyAction
(
)
;
await
action
.
processRecipe
(
{
id
:
RECIPE_ID
type
:
"
addon
-
study
"
arguments
:
{
slug
:
"
addon
-
unenroll
-
test
"
userFacingDescription
:
"
A
recipe
to
test
add
-
on
unenrollment
"
userFacingName
:
"
Add
-
on
Unenroll
Test
"
isEnrollmentPaused
:
false
branches
:
[
{
ratio
:
1
slug
:
"
only
"
extensionApiId
:
API_ID
}
]
}
}
BaseAction
.
suitability
.
FILTER_MATCH
)
;
await
extension
.
startupPromise
;
let
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
ok
(
addon
"
Extension
is
installed
"
)
;
let
listenerDeferred
=
PromiseUtils
.
defer
(
)
;
AddonStudies
.
addUnenrollListener
(
ID
(
)
=
>
{
listenerDeferred
.
resolve
(
)
;
throw
new
Error
(
"
This
listener
is
busted
"
)
;
}
)
;
await
action
.
unenroll
(
RECIPE_ID
UNENROLL_REASON
)
;
await
listenerDeferred
;
addon
=
await
AddonManager
.
getAddonByID
(
ID
)
;
equal
(
addon
null
"
Extension
is
uninstalled
even
though
it
threw
an
exception
in
the
callback
"
)
;
}
)
;
