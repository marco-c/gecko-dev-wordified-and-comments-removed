"
use
strict
"
;
const
{
BaseAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
BaseAction
.
jsm
"
)
;
const
{
ConsoleLogAction
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
actions
/
ConsoleLogAction
.
jsm
"
)
;
const
{
Uptake
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
Uptake
.
jsm
"
)
;
add_task
(
async
function
logging_works
(
)
{
const
action
=
new
ConsoleLogAction
(
)
;
const
infoStub
=
sinon
.
stub
(
action
.
log
"
info
"
)
;
try
{
const
recipe
=
{
id
:
1
arguments
:
{
message
:
"
Hello
world
!
"
}
}
;
await
action
.
processRecipe
(
recipe
BaseAction
.
suitability
.
FILTER_MATCH
)
;
is
(
action
.
lastError
null
"
lastError
should
be
null
"
)
;
Assert
.
deepEqual
(
infoStub
.
args
[
"
Hello
world
!
"
]
"
the
message
should
be
logged
"
)
;
}
finally
{
infoStub
.
restore
(
)
;
}
}
)
;
decorate_task
(
withStub
(
Uptake
"
reportRecipe
"
)
async
function
arguments_are_validated
(
{
reportRecipeStub
}
)
{
const
action
=
new
ConsoleLogAction
(
)
;
const
infoStub
=
sinon
.
stub
(
action
.
log
"
info
"
)
;
try
{
let
recipe
=
{
id
:
1
arguments
:
{
}
}
;
await
action
.
processRecipe
(
recipe
BaseAction
.
suitability
.
FILTER_MATCH
)
;
is
(
action
.
lastError
null
"
lastError
should
be
null
"
)
;
Assert
.
deepEqual
(
infoStub
.
args
[
]
"
no
message
should
be
logged
"
)
;
Assert
.
deepEqual
(
reportRecipeStub
.
args
[
[
recipe
Uptake
.
RECIPE_EXECUTION_ERROR
]
]
)
;
reportRecipeStub
.
reset
(
)
;
recipe
=
{
id
:
1
arguments
:
{
message
:
1
}
}
;
await
action
.
processRecipe
(
recipe
BaseAction
.
suitability
.
FILTER_MATCH
)
;
is
(
action
.
lastError
null
"
lastError
should
be
null
"
)
;
Assert
.
deepEqual
(
infoStub
.
args
[
]
"
no
message
should
be
logged
"
)
;
Assert
.
deepEqual
(
reportRecipeStub
.
args
[
[
recipe
Uptake
.
RECIPE_EXECUTION_ERROR
]
]
)
;
}
finally
{
infoStub
.
restore
(
)
;
}
}
)
;
