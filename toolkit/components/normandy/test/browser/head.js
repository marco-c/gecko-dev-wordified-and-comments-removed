ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
-
content
/
AboutPages
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
SandboxManager
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
NormandyDriver
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
NormandyApi
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
normandy
/
lib
/
TelemetryEvents
.
jsm
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
resource
:
/
/
testing
-
common
/
sinon
-
2
.
3
.
2
.
js
"
)
;
sinon
.
assert
.
fail
=
function
(
message
)
{
ok
(
false
message
)
;
}
;
registerCleanupFunction
(
async
function
(
)
{
delete
window
.
sinon
;
}
)
;
TelemetryEvents
.
init
(
)
;
this
.
UUID_REGEX
=
/
[
a
-
f0
-
9
]
{
8
}
-
[
a
-
f0
-
9
]
{
4
}
-
[
a
-
f0
-
9
]
{
4
}
-
[
a
-
f0
-
9
]
{
4
}
-
[
a
-
f0
-
9
]
{
12
}
/
;
this
.
TEST_XPI_URL
=
(
function
(
)
{
const
dir
=
getChromeDir
(
getResolvedURI
(
gTestPath
)
)
;
dir
.
append
(
"
fixtures
"
)
;
dir
.
append
(
"
normandy
.
xpi
"
)
;
return
Services
.
io
.
newFileURI
(
dir
)
.
spec
;
}
)
(
)
;
this
.
withWebExtension
=
function
(
manifestOverrides
=
{
}
)
{
return
function
wrapper
(
testFunction
)
{
return
async
function
wrappedTestFunction
(
.
.
.
args
)
{
const
random
=
Math
.
random
(
)
.
toString
(
36
)
.
replace
(
/
0
.
/
"
"
)
.
substr
(
-
3
)
;
let
id
=
normandydriver_
{
random
}
example
.
com
;
if
(
"
id
"
in
manifestOverrides
)
{
id
=
manifestOverrides
.
id
;
delete
manifestOverrides
.
id
;
}
const
manifest
=
Object
.
assign
(
{
manifest_version
:
2
name
:
"
normandy_fixture
"
version
:
"
1
.
0
"
description
:
"
Dummy
test
fixture
that
'
s
a
webextension
"
applications
:
{
gecko
:
{
id
}
}
}
manifestOverrides
)
;
const
addonFile
=
AddonTestUtils
.
createTempWebExtensionFile
(
{
manifest
}
)
;
Services
.
obs
.
notifyObservers
(
addonFile
"
flush
-
cache
-
entry
"
)
;
try
{
await
testFunction
(
.
.
.
args
[
id
addonFile
]
)
;
}
finally
{
AddonTestUtils
.
cleanupTempXPIs
(
)
;
}
}
;
}
;
}
;
this
.
withCorruptedWebExtension
=
function
(
)
{
return
this
.
withWebExtension
(
{
manifest_version
:
-
1
}
)
;
}
;
this
.
withInstalledWebExtension
=
function
(
manifestOverrides
=
{
}
expectUninstall
=
false
)
{
return
function
wrapper
(
testFunction
)
{
return
decorate
(
withWebExtension
(
manifestOverrides
)
async
function
wrappedTestFunction
(
.
.
.
args
)
{
const
[
id
file
]
=
args
[
args
.
length
-
1
]
;
const
startupPromise
=
AddonTestUtils
.
promiseWebExtensionStartup
(
id
)
;
const
addonInstall
=
await
AddonManager
.
getInstallForFile
(
file
"
application
/
x
-
xpinstall
"
)
;
await
addonInstall
.
install
(
)
;
await
startupPromise
;
try
{
await
testFunction
(
.
.
.
args
)
;
}
finally
{
const
addonToUninstall
=
await
AddonManager
.
getAddonByID
(
id
)
;
if
(
addonToUninstall
)
{
await
addonToUninstall
.
uninstall
(
)
;
}
else
{
ok
(
expectUninstall
"
Add
-
on
should
not
be
unexpectedly
uninstalled
during
test
"
)
;
}
}
}
)
;
}
;
}
;
this
.
withSandboxManager
=
function
(
Assert
)
{
return
function
wrapper
(
testFunction
)
{
return
async
function
wrappedTestFunction
(
.
.
.
args
)
{
const
sandboxManager
=
new
SandboxManager
(
)
;
sandboxManager
.
addHold
(
"
test
running
"
)
;
await
testFunction
(
.
.
.
args
sandboxManager
)
;
sandboxManager
.
removeHold
(
"
test
running
"
)
;
await
sandboxManager
.
isNuked
(
)
.
then
(
(
)
=
>
Assert
.
ok
(
true
"
sandbox
is
nuked
"
)
)
.
catch
(
e
=
>
Assert
.
ok
(
false
"
sandbox
is
nuked
"
e
)
)
;
}
;
}
;
}
;
this
.
withDriver
=
function
(
Assert
testFunction
)
{
return
withSandboxManager
(
Assert
)
(
async
function
inner
(
.
.
.
args
)
{
const
sandboxManager
=
args
[
args
.
length
-
1
]
;
const
driver
=
new
NormandyDriver
(
sandboxManager
)
;
await
testFunction
(
driver
.
.
.
args
)
;
}
)
;
}
;
this
.
withMockNormandyApi
=
function
(
testFunction
)
{
return
async
function
inner
(
.
.
.
args
)
{
const
mockApi
=
{
actions
:
[
]
recipes
:
[
]
implementations
:
{
}
}
;
mockApi
.
fetchActions
=
sinon
.
stub
(
NormandyApi
"
fetchActions
"
)
.
callsFake
(
async
(
)
=
>
mockApi
.
actions
)
;
mockApi
.
fetchRecipes
=
sinon
.
stub
(
NormandyApi
"
fetchRecipes
"
)
.
callsFake
(
async
(
)
=
>
mockApi
.
recipes
)
;
mockApi
.
fetchImplementation
=
sinon
.
stub
(
NormandyApi
"
fetchImplementation
"
)
.
callsFake
(
async
action
=
>
{
const
impl
=
mockApi
.
implementations
[
action
.
name
]
;
if
(
!
impl
)
{
throw
new
Error
(
Missing
implementation
for
{
action
.
name
}
)
;
}
return
impl
;
}
)
;
try
{
await
testFunction
(
mockApi
.
.
.
args
)
;
}
finally
{
mockApi
.
fetchActions
.
restore
(
)
;
mockApi
.
fetchRecipes
.
restore
(
)
;
mockApi
.
fetchImplementation
.
restore
(
)
;
}
}
;
}
;
const
preferenceBranches
=
{
user
:
Preferences
default
:
new
Preferences
(
{
defaultBranch
:
true
}
)
}
;
this
.
withMockPreferences
=
function
(
testFunction
)
{
return
async
function
inner
(
.
.
.
args
)
{
const
prefManager
=
new
MockPreferences
(
)
;
try
{
await
testFunction
(
.
.
.
args
prefManager
)
;
}
finally
{
prefManager
.
cleanup
(
)
;
}
}
;
}
;
class
MockPreferences
{
constructor
(
)
{
this
.
oldValues
=
{
user
:
{
}
default
:
{
}
}
;
}
set
(
name
value
branch
=
"
user
"
)
{
this
.
preserve
(
name
branch
)
;
preferenceBranches
[
branch
]
.
set
(
name
value
)
;
}
preserve
(
name
branch
)
{
if
(
!
(
name
in
this
.
oldValues
[
branch
]
)
)
{
const
preferenceBranch
=
preferenceBranches
[
branch
]
;
let
oldValue
;
let
existed
;
try
{
oldValue
=
preferenceBranch
.
get
(
name
)
;
existed
=
preferenceBranch
.
has
(
name
)
;
}
catch
(
e
)
{
oldValue
=
null
;
existed
=
false
;
}
this
.
oldValues
[
branch
]
[
name
]
=
{
oldValue
existed
}
;
}
}
cleanup
(
)
{
for
(
const
[
branchName
values
]
of
Object
.
entries
(
this
.
oldValues
)
)
{
const
preferenceBranch
=
preferenceBranches
[
branchName
]
;
for
(
const
[
name
{
oldValue
existed
}
]
of
Object
.
entries
(
values
)
)
{
const
before
=
preferenceBranch
.
get
(
name
)
;
if
(
before
=
=
=
oldValue
)
{
continue
;
}
if
(
existed
)
{
preferenceBranch
.
set
(
name
oldValue
)
;
}
else
if
(
branchName
=
=
=
"
default
"
)
{
Services
.
prefs
.
getDefaultBranch
(
name
)
.
deleteBranch
(
"
"
)
;
}
else
{
preferenceBranch
.
reset
(
name
)
;
}
const
after
=
preferenceBranch
.
get
(
name
)
;
if
(
before
=
=
=
after
&
&
before
!
=
=
undefined
)
{
throw
new
Error
(
Couldn
'
t
reset
pref
"
{
name
}
"
to
"
{
oldValue
}
"
on
"
{
branchName
}
"
branch
+
(
value
stayed
"
{
before
}
"
did
{
existed
?
"
"
:
"
not
"
}
exist
)
)
;
}
}
}
}
}
this
.
withPrefEnv
=
function
(
inPrefs
)
{
return
function
wrapper
(
testFunc
)
{
return
async
function
inner
(
.
.
.
args
)
{
await
SpecialPowers
.
pushPrefEnv
(
inPrefs
)
;
try
{
await
testFunc
(
.
.
.
args
)
;
}
finally
{
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
;
}
;
}
;
this
.
decorate
=
function
(
.
.
.
args
)
{
const
funcs
=
Array
.
from
(
args
)
;
let
decorated
=
funcs
.
pop
(
)
;
const
origName
=
decorated
.
name
;
funcs
.
reverse
(
)
;
for
(
const
func
of
funcs
)
{
decorated
=
func
(
decorated
)
;
}
Object
.
defineProperty
(
decorated
"
name
"
{
value
:
origName
}
)
;
return
decorated
;
}
;
this
.
decorate_task
=
function
(
.
.
.
args
)
{
return
add_task
(
decorate
(
.
.
.
args
)
)
;
}
;
let
_addonStudyFactoryId
=
0
;
this
.
addonStudyFactory
=
function
(
attrs
)
{
return
Object
.
assign
(
{
recipeId
:
_addonStudyFactoryId
+
+
name
:
"
Test
study
"
description
:
"
fake
"
active
:
true
addonId
:
"
fake
example
.
com
"
addonUrl
:
"
http
:
/
/
test
/
addon
.
xpi
"
addonVersion
:
"
1
.
0
.
0
"
studyStartDate
:
new
Date
(
)
}
attrs
)
;
}
;
let
_preferenceStudyFactoryId
=
0
;
this
.
preferenceStudyFactory
=
function
(
attrs
)
{
return
Object
.
assign
(
{
name
:
Test
study
{
_preferenceStudyFactoryId
+
+
}
branch
:
"
control
"
expired
:
false
lastSeen
:
new
Date
(
)
.
toJSON
(
)
preferenceName
:
"
test
.
study
"
preferenceValue
:
false
preferenceType
:
"
boolean
"
previousPreferenceValue
:
undefined
preferenceBranchType
:
"
default
"
experimentType
:
"
exp
"
}
attrs
)
;
}
;
this
.
withStub
=
function
(
.
.
.
stubArgs
)
{
return
function
wrapper
(
testFunction
)
{
return
async
function
wrappedTestFunction
(
.
.
.
args
)
{
const
stub
=
sinon
.
stub
(
.
.
.
stubArgs
)
;
try
{
await
testFunction
(
.
.
.
args
stub
)
;
}
finally
{
stub
.
restore
(
)
;
}
}
;
}
;
}
;
this
.
withSpy
=
function
(
.
.
.
spyArgs
)
{
return
function
wrapper
(
testFunction
)
{
return
async
function
wrappedTestFunction
(
.
.
.
args
)
{
const
spy
=
sinon
.
spy
(
.
.
.
spyArgs
)
;
try
{
await
testFunction
(
.
.
.
args
spy
)
;
}
finally
{
spy
.
restore
(
)
;
}
}
;
}
;
}
;
this
.
studyEndObserved
=
function
(
recipeId
)
{
return
TestUtils
.
topicObserved
(
"
shield
-
study
-
ended
"
(
subject
endedRecipeId
)
=
>
Number
.
parseInt
(
endedRecipeId
)
=
=
=
recipeId
)
;
}
;
this
.
withSendEventStub
=
function
(
testFunction
)
{
return
async
function
wrappedTestFunction
(
.
.
.
args
)
{
const
stub
=
sinon
.
spy
(
TelemetryEvents
"
sendEvent
"
)
;
try
{
await
testFunction
(
.
.
.
args
stub
)
;
}
finally
{
stub
.
restore
(
)
;
Assert
.
ok
(
!
stub
.
threw
(
)
"
some
telemetry
call
failed
"
)
;
}
}
;
}
;
let
_recipeId
=
1
;
this
.
recipeFactory
=
function
(
overrides
=
{
}
)
{
return
Object
.
assign
(
{
id
:
_recipeId
+
+
arguments
:
overrides
.
arguments
|
|
{
}
}
overrides
)
;
}
;
function
mockLogger
(
)
{
const
logStub
=
sinon
.
stub
(
)
;
logStub
.
fatal
=
sinon
.
stub
(
)
;
logStub
.
error
=
sinon
.
stub
(
)
;
logStub
.
warn
=
sinon
.
stub
(
)
;
logStub
.
info
=
sinon
.
stub
(
)
;
logStub
.
config
=
sinon
.
stub
(
)
;
logStub
.
debug
=
sinon
.
stub
(
)
;
logStub
.
trace
=
sinon
.
stub
(
)
;
return
logStub
;
}
