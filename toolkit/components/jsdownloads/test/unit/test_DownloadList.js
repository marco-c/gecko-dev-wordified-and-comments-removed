"
use
strict
"
;
function
getExpirablePRTime
(
)
{
let
dateObj
=
new
Date
(
)
;
dateObj
.
setHours
(
0
)
;
dateObj
.
setMinutes
(
0
)
;
dateObj
.
setSeconds
(
0
)
;
dateObj
.
setMilliseconds
(
0
)
;
dateObj
=
new
Date
(
dateObj
.
getTime
(
)
-
8
*
86400000
)
;
return
dateObj
.
getTime
(
)
*
1000
;
}
function
promiseExpirableDownloadVisit
(
aSourceUrl
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
PlacesUtils
.
asyncHistory
.
updatePlaces
(
{
uri
:
NetUtil
.
newURI
(
aSourceUrl
|
|
httpUrl
(
"
source
.
txt
"
)
)
visits
:
[
{
transitionType
:
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
visitDate
:
getExpirablePRTime
(
)
}
]
}
{
handleError
:
function
handleError
(
aResultCode
aPlaceInfo
)
{
let
ex
=
new
Components
.
Exception
(
"
Unexpected
error
in
adding
visits
.
"
aResultCode
)
;
reject
(
ex
)
;
}
handleResult
(
)
{
}
handleCompletion
:
function
handleCompletion
(
)
{
resolve
(
)
;
}
}
)
;
}
)
;
}
add_task
(
async
function
test_construction
(
)
{
let
downloadListOne
=
await
promiseNewList
(
)
;
let
downloadListTwo
=
await
promiseNewList
(
)
;
let
privateDownloadListOne
=
await
promiseNewList
(
true
)
;
let
privateDownloadListTwo
=
await
promiseNewList
(
true
)
;
do_check_neq
(
downloadListOne
downloadListTwo
)
;
do_check_neq
(
privateDownloadListOne
privateDownloadListTwo
)
;
do_check_neq
(
downloadListOne
privateDownloadListOne
)
;
}
)
;
add_task
(
async
function
test_add_getAll
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
downloadOne
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
downloadOne
)
;
let
itemsOne
=
await
list
.
getAll
(
)
;
do_check_eq
(
itemsOne
.
length
1
)
;
do_check_eq
(
itemsOne
[
0
]
downloadOne
)
;
let
downloadTwo
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
downloadTwo
)
;
let
itemsTwo
=
await
list
.
getAll
(
)
;
do_check_eq
(
itemsTwo
.
length
2
)
;
do_check_eq
(
itemsTwo
[
0
]
downloadOne
)
;
do_check_eq
(
itemsTwo
[
1
]
downloadTwo
)
;
do_check_eq
(
itemsOne
.
length
1
)
;
}
)
;
add_task
(
async
function
test_remove
(
)
{
let
list
=
await
promiseNewList
(
)
;
await
list
.
add
(
await
promiseNewDownload
(
)
)
;
await
list
.
add
(
await
promiseNewDownload
(
)
)
;
let
items
=
await
list
.
getAll
(
)
;
await
list
.
remove
(
items
[
0
]
)
;
await
list
.
remove
(
await
promiseNewDownload
(
)
)
;
items
=
await
list
.
getAll
(
)
;
do_check_eq
(
items
.
length
1
)
;
}
)
;
add_task
(
async
function
test_DownloadCombinedList_add_remove_getAll
(
)
{
let
publicList
=
await
promiseNewList
(
)
;
let
privateList
=
await
Downloads
.
getList
(
Downloads
.
PRIVATE
)
;
let
combinedList
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
let
publicDownload
=
await
promiseNewDownload
(
)
;
let
privateDownload
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
isPrivate
:
true
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
)
;
await
publicList
.
add
(
publicDownload
)
;
await
privateList
.
add
(
privateDownload
)
;
do_check_eq
(
(
await
combinedList
.
getAll
(
)
)
.
length
2
)
;
await
combinedList
.
remove
(
publicDownload
)
;
await
combinedList
.
remove
(
privateDownload
)
;
do_check_eq
(
(
await
combinedList
.
getAll
(
)
)
.
length
0
)
;
await
combinedList
.
add
(
publicDownload
)
;
await
combinedList
.
add
(
privateDownload
)
;
do_check_eq
(
(
await
publicList
.
getAll
(
)
)
.
length
1
)
;
do_check_eq
(
(
await
privateList
.
getAll
(
)
)
.
length
1
)
;
do_check_eq
(
(
await
combinedList
.
getAll
(
)
)
.
length
2
)
;
await
publicList
.
remove
(
publicDownload
)
;
await
privateList
.
remove
(
privateDownload
)
;
do_check_eq
(
(
await
combinedList
.
getAll
(
)
)
.
length
0
)
;
}
)
;
add_task
(
async
function
test_notifications_add_remove
(
)
{
for
(
let
isCombined
of
[
false
true
]
)
{
let
list
=
await
promiseNewList
(
)
;
if
(
isCombined
)
{
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
}
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
isPrivate
:
true
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
let
addNotifications
=
0
;
let
viewOne
=
{
onDownloadAdded
(
aDownload
)
{
if
(
addNotifications
=
=
0
)
{
do_check_eq
(
aDownload
downloadOne
)
;
}
else
if
(
addNotifications
=
=
1
)
{
do_check_eq
(
aDownload
downloadTwo
)
;
}
addNotifications
+
+
;
}
}
;
await
list
.
addView
(
viewOne
)
;
do_check_eq
(
addNotifications
2
)
;
await
list
.
add
(
await
promiseNewDownload
(
)
)
;
do_check_eq
(
addNotifications
3
)
;
let
removeNotifications
=
0
;
let
viewTwo
=
{
onDownloadRemoved
(
aDownload
)
{
do_check_eq
(
aDownload
downloadOne
)
;
removeNotifications
+
+
;
}
}
;
await
list
.
addView
(
viewTwo
)
;
await
list
.
remove
(
downloadOne
)
;
do_check_eq
(
removeNotifications
1
)
;
await
list
.
removeView
(
viewTwo
)
;
await
list
.
remove
(
downloadTwo
)
;
do_check_eq
(
removeNotifications
1
)
;
await
list
.
removeView
(
viewOne
)
;
await
list
.
add
(
await
promiseNewDownload
(
)
)
;
do_check_eq
(
addNotifications
3
)
;
}
}
)
;
add_task
(
async
function
test_notifications_change
(
)
{
for
(
let
isCombined
of
[
false
true
]
)
{
let
list
=
await
promiseNewList
(
)
;
if
(
isCombined
)
{
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
}
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
isPrivate
:
true
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
let
receivedOnDownloadChanged
=
false
;
await
list
.
addView
(
{
onDownloadChanged
(
aDownload
)
{
do_check_eq
(
aDownload
downloadOne
)
;
receivedOnDownloadChanged
=
true
;
}
}
)
;
await
downloadOne
.
start
(
)
;
do_check_true
(
receivedOnDownloadChanged
)
;
receivedOnDownloadChanged
=
false
;
await
list
.
remove
(
downloadTwo
)
;
await
downloadTwo
.
start
(
)
;
do_check_false
(
receivedOnDownloadChanged
)
;
}
}
)
;
add_task
(
async
function
test_notifications_this
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
receivedOnDownloadAdded
=
false
;
let
receivedOnDownloadChanged
=
false
;
let
receivedOnDownloadRemoved
=
false
;
let
view
=
{
onDownloadAdded
(
)
{
do_check_eq
(
this
view
)
;
receivedOnDownloadAdded
=
true
;
}
onDownloadChanged
(
)
{
if
(
!
receivedOnDownloadChanged
)
{
do_check_eq
(
this
view
)
;
receivedOnDownloadChanged
=
true
;
}
}
onDownloadRemoved
(
)
{
do_check_eq
(
this
view
)
;
receivedOnDownloadRemoved
=
true
;
}
}
;
await
list
.
addView
(
view
)
;
let
download
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
download
)
;
await
download
.
start
(
)
;
await
list
.
remove
(
download
)
;
do_check_true
(
receivedOnDownloadAdded
)
;
do_check_true
(
receivedOnDownloadChanged
)
;
do_check_true
(
receivedOnDownloadRemoved
)
;
}
)
;
add_task
(
async
function
test_history_expiration
(
)
{
mustInterruptResponses
(
)
;
function
cleanup
(
)
{
Services
.
prefs
.
clearUserPref
(
"
places
.
history
.
expiration
.
max_pages
"
)
;
}
do_register_cleanup
(
cleanup
)
;
Services
.
prefs
.
setIntPref
(
"
places
.
history
.
expiration
.
max_pages
"
0
)
;
let
list
=
await
promiseNewList
(
)
;
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
deferred
=
Promise
.
defer
(
)
;
let
removeNotifications
=
0
;
let
downloadView
=
{
onDownloadRemoved
(
aDownload
)
{
if
(
+
+
removeNotifications
=
=
2
)
{
deferred
.
resolve
(
)
;
}
}
}
;
await
list
.
addView
(
downloadView
)
;
await
downloadOne
.
start
(
)
;
downloadTwo
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
downloadTwo
.
cancel
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
promiseExpirableDownloadVisit
(
)
;
await
promiseExpirableDownloadVisit
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
Cc
[
"
mozilla
.
org
/
places
/
expiration
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
.
observe
(
null
"
places
-
debug
-
start
-
expiration
"
-
1
)
;
await
deferred
.
promise
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_history_clear
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
let
deferred
=
Promise
.
defer
(
)
;
let
removeNotifications
=
0
;
let
downloadView
=
{
onDownloadRemoved
(
aDownload
)
{
if
(
+
+
removeNotifications
=
=
2
)
{
deferred
.
resolve
(
)
;
}
}
}
;
await
list
.
addView
(
downloadView
)
;
await
downloadOne
.
start
(
)
;
await
downloadTwo
.
start
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
deferred
.
promise
;
}
)
;
add_task
(
async
function
test_removeFinished
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
downloadOne
=
await
promiseNewDownload
(
)
;
let
downloadTwo
=
await
promiseNewDownload
(
)
;
let
downloadThree
=
await
promiseNewDownload
(
)
;
let
downloadFour
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
downloadOne
)
;
await
list
.
add
(
downloadTwo
)
;
await
list
.
add
(
downloadThree
)
;
await
list
.
add
(
downloadFour
)
;
let
deferred
=
Promise
.
defer
(
)
;
let
removeNotifications
=
0
;
let
downloadView
=
{
onDownloadRemoved
(
aDownload
)
{
do_check_true
(
aDownload
=
=
downloadOne
|
|
aDownload
=
=
downloadTwo
|
|
aDownload
=
=
downloadThree
)
;
do_check_true
(
removeNotifications
<
3
)
;
if
(
+
+
removeNotifications
=
=
3
)
{
deferred
.
resolve
(
)
;
}
}
}
;
await
list
.
addView
(
downloadView
)
;
await
downloadOne
.
start
(
)
;
await
downloadThree
.
start
(
)
;
await
downloadFour
.
start
(
)
;
downloadFour
.
hasPartialData
=
true
;
list
.
removeFinished
(
)
;
await
deferred
.
promise
;
let
downloads
=
await
list
.
getAll
(
)
;
do_check_eq
(
downloads
.
length
1
)
;
}
)
;
add_task
(
async
function
test_DownloadSummary
(
)
{
mustInterruptResponses
(
)
;
let
publicList
=
await
promiseNewList
(
)
;
let
privateList
=
await
Downloads
.
getList
(
Downloads
.
PRIVATE
)
;
let
publicSummary
=
await
Downloads
.
getSummary
(
Downloads
.
PUBLIC
)
;
let
privateSummary
=
await
Downloads
.
getSummary
(
Downloads
.
PRIVATE
)
;
let
combinedSummary
=
await
Downloads
.
getSummary
(
Downloads
.
ALL
)
;
let
succeededPublicDownload
=
await
promiseNewDownload
(
)
;
await
succeededPublicDownload
.
start
(
)
;
await
publicList
.
add
(
succeededPublicDownload
)
;
let
canceledPublicDownload
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
canceledPublicDownload
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
promiseDownloadMidway
(
canceledPublicDownload
)
;
await
canceledPublicDownload
.
cancel
(
)
;
await
publicList
.
add
(
canceledPublicDownload
)
;
let
inProgressPublicDownload
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
inProgressPublicDownload
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
promiseDownloadMidway
(
inProgressPublicDownload
)
;
await
publicList
.
add
(
inProgressPublicDownload
)
;
let
inProgressPrivateDownload
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
interruptible
.
txt
"
)
isPrivate
:
true
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
)
;
inProgressPrivateDownload
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
promiseDownloadMidway
(
inProgressPrivateDownload
)
;
await
privateList
.
add
(
inProgressPrivateDownload
)
;
do_check_false
(
publicSummary
.
allHaveStopped
)
;
do_check_eq
(
publicSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
2
)
;
do_check_eq
(
publicSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
)
;
do_check_false
(
privateSummary
.
allHaveStopped
)
;
do_check_eq
(
privateSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
2
)
;
do_check_eq
(
privateSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
)
;
do_check_false
(
combinedSummary
.
allHaveStopped
)
;
do_check_eq
(
combinedSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
4
)
;
do_check_eq
(
combinedSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
*
2
)
;
await
inProgressPublicDownload
.
cancel
(
)
;
do_check_true
(
publicSummary
.
allHaveStopped
)
;
do_check_eq
(
publicSummary
.
progressTotalBytes
0
)
;
do_check_eq
(
publicSummary
.
progressCurrentBytes
0
)
;
do_check_false
(
privateSummary
.
allHaveStopped
)
;
do_check_eq
(
privateSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
2
)
;
do_check_eq
(
privateSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
)
;
do_check_false
(
combinedSummary
.
allHaveStopped
)
;
do_check_eq
(
combinedSummary
.
progressTotalBytes
TEST_DATA_SHORT
.
length
*
2
)
;
do_check_eq
(
combinedSummary
.
progressCurrentBytes
TEST_DATA_SHORT
.
length
)
;
await
inProgressPrivateDownload
.
cancel
(
)
;
do_check_true
(
publicSummary
.
allHaveStopped
)
;
do_check_eq
(
publicSummary
.
progressTotalBytes
0
)
;
do_check_eq
(
publicSummary
.
progressCurrentBytes
0
)
;
do_check_true
(
privateSummary
.
allHaveStopped
)
;
do_check_eq
(
privateSummary
.
progressTotalBytes
0
)
;
do_check_eq
(
privateSummary
.
progressCurrentBytes
0
)
;
do_check_true
(
combinedSummary
.
allHaveStopped
)
;
do_check_eq
(
combinedSummary
.
progressTotalBytes
0
)
;
do_check_eq
(
combinedSummary
.
progressCurrentBytes
0
)
;
}
)
;
add_task
(
async
function
test_DownloadSummary_notifications
(
)
{
let
list
=
await
promiseNewList
(
)
;
let
summary
=
await
Downloads
.
getSummary
(
Downloads
.
ALL
)
;
let
download
=
await
promiseNewDownload
(
)
;
await
list
.
add
(
download
)
;
let
receivedOnSummaryChanged
=
false
;
await
summary
.
addView
(
{
onSummaryChanged
(
)
{
receivedOnSummaryChanged
=
true
;
}
}
)
;
await
download
.
start
(
)
;
do_check_true
(
receivedOnSummaryChanged
)
;
}
)
;
