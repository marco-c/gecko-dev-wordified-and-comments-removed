"
use
strict
"
;
const
kDeleteTempFileOnExit
=
"
browser
.
helperApps
.
deleteTempFileOnExit
"
;
function
promiseStartDownload
(
aSourceUrl
)
{
if
(
gUseLegacySaver
)
{
return
promiseStartLegacyDownload
(
aSourceUrl
)
;
}
return
promiseNewDownload
(
aSourceUrl
)
.
then
(
download
=
>
{
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
return
download
;
}
)
;
}
function
promiseStartDownload_tryToKeepPartialData
(
)
{
return
(
async
function
(
)
{
mustInterruptResponses
(
)
;
let
download
;
if
(
!
gUseLegacySaver
)
{
let
targetFilePath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
download
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
interruptible_resumable
.
txt
"
)
target
:
{
path
:
targetFilePath
partFilePath
:
targetFilePath
+
"
.
part
"
}
}
)
;
download
.
tryToKeepPartialData
=
true
;
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
else
{
download
=
await
promiseStartExternalHelperAppServiceDownload
(
)
;
}
await
promiseDownloadMidway
(
download
)
;
await
promisePartFileReady
(
download
)
;
return
download
;
}
)
(
)
;
}
function
promisePartFileReady
(
aDownload
)
{
return
(
async
function
(
)
{
try
{
do
{
await
promiseTimeout
(
50
)
;
}
while
(
!
(
await
OS
.
File
.
exists
(
aDownload
.
target
.
partFilePath
)
)
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
OS
.
File
.
Error
)
)
{
throw
ex
;
}
do_print
(
"
Expected
exception
while
checking
existence
:
"
+
ex
.
toString
(
)
)
;
await
promiseTimeout
(
100
)
;
}
}
)
(
)
;
}
var
promiseVerifyTarget
=
async
function
(
downloadTarget
expectedContents
)
{
await
promiseVerifyContents
(
downloadTarget
.
path
expectedContents
)
;
do_check_true
(
downloadTarget
.
exists
)
;
do_check_eq
(
downloadTarget
.
size
expectedContents
.
length
)
;
}
;
function
waitForFileLaunched
(
)
{
return
new
Promise
(
resolve
=
>
{
let
waitFn
=
base
=
>
(
{
launchFile
(
file
mimeInfo
)
{
Integration
.
downloads
.
unregister
(
waitFn
)
;
if
(
!
mimeInfo
|
|
mimeInfo
.
preferredAction
=
=
Ci
.
nsIMIMEInfo
.
useSystemDefault
)
{
resolve
(
null
)
;
}
else
{
resolve
(
mimeInfo
)
;
}
return
Promise
.
resolve
(
)
;
}
}
)
;
Integration
.
downloads
.
register
(
waitFn
)
;
}
)
;
}
function
waitForDirectoryShown
(
)
{
return
new
Promise
(
resolve
=
>
{
let
waitFn
=
base
=
>
(
{
showContainingDirectory
(
path
)
{
Integration
.
downloads
.
unregister
(
waitFn
)
;
resolve
(
path
)
;
return
Promise
.
resolve
(
)
;
}
}
)
;
Integration
.
downloads
.
register
(
waitFn
)
;
}
)
;
}
add_task
(
async
function
test_basic
(
)
{
let
targetFile
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
;
let
download
;
if
(
!
gUseLegacySaver
)
{
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
}
target
:
{
path
:
targetFile
.
path
}
saver
:
{
type
:
"
copy
"
}
}
)
;
do_check_eq
(
download
.
source
.
url
httpUrl
(
"
source
.
txt
"
)
)
;
do_check_eq
(
download
.
target
.
path
targetFile
.
path
)
;
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
null
{
targetFile
}
)
;
do_check_eq
(
download
.
source
.
url
httpUrl
(
"
source
.
txt
"
)
)
;
do_check_eq
(
download
.
target
.
path
targetFile
.
path
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_check_true
(
download
.
source
.
referrer
=
=
=
null
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_basic_tryToKeepPartialData
(
)
{
let
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
continueResponses
(
)
;
await
promiseDownloadStopped
(
download
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
do_check_eq
(
32
download
.
saver
.
getSha256Hash
(
)
.
length
)
;
}
)
;
add_task
(
async
function
test_channelIsForDownload_classFlags
(
)
{
let
downloadChannel
=
null
;
if
(
!
gUseLegacySaver
)
{
let
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
interruptible_resumable
.
txt
"
)
async
adjustChannel
(
channel
)
{
downloadChannel
=
channel
;
}
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
)
;
await
download
.
start
(
)
;
}
else
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartExternalHelperAppServiceDownload
(
)
;
downloadChannel
=
download
.
saver
.
request
;
continueResponses
(
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_check_true
(
downloadChannel
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
.
channelIsForDownload
)
;
do_check_eq
(
downloadChannel
.
QueryInterface
(
Ci
.
nsIClassOfService
)
.
classFlags
Ci
.
nsIClassOfService
.
Throttleable
)
;
}
)
;
add_task
(
async
function
test_unix_permissions
(
)
{
if
(
Services
.
appinfo
.
OS
!
=
"
Darwin
"
&
&
Services
.
appinfo
.
OS
!
=
"
Linux
"
&
&
Services
.
appinfo
.
OS
!
=
"
WINNT
"
)
{
do_print
(
"
Skipping
test
.
"
)
;
return
;
}
let
launcherPath
=
getTempFile
(
"
app
-
launcher
"
)
.
path
;
for
(
let
autoDelete
of
[
false
true
]
)
{
for
(
let
isPrivate
of
[
false
true
]
)
{
for
(
let
launchWhenSucceeded
of
[
false
true
]
)
{
do_print
(
"
Checking
"
+
JSON
.
stringify
(
{
autoDelete
isPrivate
launchWhenSucceeded
}
)
)
;
Services
.
prefs
.
setBoolPref
(
kDeleteTempFileOnExit
autoDelete
)
;
let
download
;
if
(
!
gUseLegacySaver
)
{
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
isPrivate
}
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
launchWhenSucceeded
launcherPath
}
)
;
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
httpUrl
(
"
source
.
txt
"
)
{
isPrivate
launchWhenSucceeded
launcherPath
:
launchWhenSucceeded
&
&
launcherPath
}
)
;
await
promiseDownloadStopped
(
download
)
;
}
let
isTemporary
=
launchWhenSucceeded
&
&
(
autoDelete
|
|
isPrivate
)
;
let
stat
=
await
OS
.
File
.
stat
(
download
.
target
.
path
)
;
if
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
{
do_check_eq
(
stat
.
winAttributes
.
readOnly
!
!
isTemporary
)
;
}
else
{
do_check_eq
(
stat
.
unixMode
isTemporary
?
0o400
:
(
0o666
&
~
OS
.
Constants
.
Sys
.
umask
)
)
;
}
}
}
}
Services
.
prefs
.
clearUserPref
(
kDeleteTempFileOnExit
)
;
}
)
;
add_task
(
async
function
test_windows_zoneInformation
(
)
{
if
(
Services
.
appinfo
.
OS
!
=
"
WINNT
"
)
{
do_print
(
"
Skipping
test
.
"
)
;
return
;
}
let
normalTargetFile
=
FileUtils
.
getFile
(
"
LocalAppData
"
[
"
xpcshell
-
download
-
test
.
txt
"
]
)
;
let
longTargetFile
=
FileUtils
.
getFile
(
"
LocalAppData
"
[
"
T
"
.
repeat
(
256
)
+
"
.
txt
"
]
)
;
longTargetFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o600
)
;
for
(
let
targetFile
of
[
normalTargetFile
longTargetFile
]
)
{
try
{
if
(
!
gUseLegacySaver
)
{
let
download
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
source
.
txt
"
)
target
:
targetFile
.
path
}
)
;
await
download
.
start
(
)
;
}
else
{
let
download
=
await
promiseStartLegacyDownload
(
null
{
targetFile
}
)
;
await
promiseDownloadStopped
(
download
)
;
}
await
promiseVerifyContents
(
targetFile
.
path
TEST_DATA_SHORT
)
;
let
file
=
await
OS
.
File
.
open
(
targetFile
.
path
+
"
:
Zone
.
Identifier
"
{
}
{
winAllowLengthBeyondMaxPathWithCaveats
:
true
}
)
;
try
{
do_check_eq
(
new
TextDecoder
(
)
.
decode
(
await
file
.
read
(
)
)
"
[
ZoneTransfer
]
\
r
\
nZoneId
=
3
\
r
\
n
"
)
;
}
finally
{
file
.
close
(
)
;
}
}
finally
{
await
OS
.
File
.
remove
(
targetFile
.
path
)
;
}
}
}
)
;
add_task
(
async
function
test_referrer
(
)
{
let
sourcePath
=
"
/
test_referrer
.
txt
"
;
let
sourceUrl
=
httpUrl
(
"
test_referrer
.
txt
"
)
;
let
targetPath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
function
cleanup
(
)
{
gHttpServer
.
registerPathHandler
(
sourcePath
null
)
;
}
do_register_cleanup
(
cleanup
)
;
gHttpServer
.
registerPathHandler
(
sourcePath
function
(
aRequest
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
do_check_true
(
aRequest
.
hasHeader
(
"
Referer
"
)
)
;
do_check_eq
(
aRequest
.
getHeader
(
"
Referer
"
)
TEST_REFERRER_URL
)
;
}
)
;
let
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
sourceUrl
referrer
:
TEST_REFERRER_URL
}
target
:
targetPath
}
)
;
do_check_eq
(
download
.
source
.
referrer
TEST_REFERRER_URL
)
;
await
download
.
start
(
)
;
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
sourceUrl
referrer
:
TEST_REFERRER_URL
isPrivate
:
true
}
target
:
targetPath
}
)
;
do_check_eq
(
download
.
source
.
referrer
TEST_REFERRER_URL
)
;
await
download
.
start
(
)
;
sourceUrl
=
"
data
:
text
/
html
<
html
>
<
body
>
<
/
body
>
<
/
html
>
"
;
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
sourceUrl
referrer
:
TEST_REFERRER_URL
}
target
:
targetPath
}
)
;
do_check_eq
(
download
.
source
.
referrer
TEST_REFERRER_URL
)
;
await
download
.
start
(
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_adjustChannel
(
)
{
const
sourcePath
=
"
/
test_post
.
txt
"
;
const
sourceUrl
=
httpUrl
(
"
test_post
.
txt
"
)
;
const
targetPath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
const
customHeader
=
{
name
:
"
X
-
Answer
"
value
:
"
42
"
}
;
const
postData
=
"
Don
'
t
Panic
"
;
function
cleanup
(
)
{
gHttpServer
.
registerPathHandler
(
sourcePath
null
)
;
}
do_register_cleanup
(
cleanup
)
;
gHttpServer
.
registerPathHandler
(
sourcePath
aRequest
=
>
{
do_check_eq
(
aRequest
.
method
"
POST
"
)
;
do_check_true
(
aRequest
.
hasHeader
(
customHeader
.
name
)
)
;
do_check_eq
(
aRequest
.
getHeader
(
customHeader
.
name
)
customHeader
.
value
)
;
const
stream
=
aRequest
.
bodyInputStream
;
const
body
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
do_check_eq
(
body
postData
)
;
}
)
;
function
adjustChannel
(
channel
)
{
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
channel
.
setRequestHeader
(
customHeader
.
name
customHeader
.
value
false
)
;
const
stream
=
Cc
[
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIStringInputStream
)
;
stream
.
setData
(
postData
postData
.
length
)
;
channel
.
QueryInterface
(
Ci
.
nsIUploadChannel2
)
;
channel
.
explicitSetUploadStream
(
stream
null
-
1
"
POST
"
false
)
;
return
Promise
.
resolve
(
)
;
}
const
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
sourceUrl
adjustChannel
}
target
:
targetPath
}
)
;
do_check_eq
(
download
.
source
.
adjustChannel
adjustChannel
)
;
do_check_eq
(
download
.
toSerializable
(
)
null
)
;
await
download
.
start
(
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_initial_final_state
(
)
{
let
download
;
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
)
;
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
succeeded
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_eq
(
download
.
progress
0
)
;
do_check_true
(
download
.
startTime
=
=
=
null
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_eq
(
download
.
progress
100
)
;
do_check_true
(
isValidDate
(
download
.
startTime
)
)
;
do_check_true
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
TEST_DATA_SHORT
.
length
)
;
}
)
;
add_task
(
async
function
test_final_state_notified
(
)
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
onchangeNotified
=
false
;
let
lastNotifiedStopped
;
let
lastNotifiedProgress
;
download
.
onchange
=
function
(
)
{
onchangeNotified
=
true
;
lastNotifiedStopped
=
download
.
stopped
;
lastNotifiedProgress
=
download
.
progress
;
}
;
let
promiseAttempt
=
download
.
start
(
)
;
continueResponses
(
)
;
await
promiseAttempt
;
do_check_true
(
onchangeNotified
)
;
do_check_true
(
lastNotifiedStopped
)
;
do_check_eq
(
lastNotifiedProgress
100
)
;
}
)
;
add_task
(
async
function
test_intermediate_progress
(
)
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
await
promiseDownloadMidway
(
download
)
;
do_check_true
(
download
.
hasProgress
)
;
do_check_eq
(
download
.
currentBytes
TEST_DATA_SHORT
.
length
)
;
do_check_eq
(
download
.
totalBytes
TEST_DATA_SHORT
.
length
*
2
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
continueResponses
(
)
;
await
promiseDownloadStopped
(
download
)
;
do_check_true
(
download
.
stopped
)
;
do_check_eq
(
download
.
progress
100
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_empty_progress
(
)
{
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
empty
.
txt
"
)
)
;
await
promiseDownloadStopped
(
download
)
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
hasProgress
)
;
do_check_eq
(
download
.
progress
100
)
;
do_check_eq
(
download
.
currentBytes
0
)
;
do_check_eq
(
download
.
totalBytes
0
)
;
do_check_eq
(
download
.
contentType
"
text
/
plain
"
)
;
do_check_eq
(
(
await
OS
.
File
.
stat
(
download
.
target
.
path
)
)
.
size
0
)
;
do_check_true
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
}
)
;
add_task
(
async
function
test_empty_progress_tryToKeepPartialData
(
)
{
let
download
;
if
(
!
gUseLegacySaver
)
{
let
targetFilePath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
download
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
empty
.
txt
"
)
target
:
{
path
:
targetFilePath
partFilePath
:
targetFilePath
+
"
.
part
"
}
}
)
;
download
.
tryToKeepPartialData
=
true
;
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
else
{
download
=
await
promiseStartExternalHelperAppServiceDownload
(
httpUrl
(
"
empty
.
txt
"
)
)
;
}
await
promiseDownloadStopped
(
download
)
;
do_check_eq
(
(
await
OS
.
File
.
stat
(
download
.
target
.
path
)
)
.
size
0
)
;
do_check_true
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
do_check_eq
(
32
download
.
saver
.
getSha256Hash
(
)
.
length
)
;
}
)
;
add_task
(
async
function
test_empty_noprogress
(
)
{
let
sourcePath
=
"
/
test_empty_noprogress
.
txt
"
;
let
sourceUrl
=
httpUrl
(
"
test_empty_noprogress
.
txt
"
)
;
let
deferRequestReceived
=
Promise
.
defer
(
)
;
function
cleanup
(
)
{
gHttpServer
.
registerPathHandler
(
sourcePath
null
)
;
}
do_register_cleanup
(
cleanup
)
;
registerInterruptibleHandler
(
sourcePath
function
firstPart
(
aRequest
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
deferRequestReceived
.
resolve
(
)
;
}
function
secondPart
(
aRequest
aResponse
)
{
}
)
;
mustInterruptResponses
(
)
;
let
download
;
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
sourceUrl
)
;
download
.
onchange
=
function
(
)
{
if
(
!
download
.
stopped
)
{
do_check_false
(
download
.
hasProgress
)
;
do_check_eq
(
download
.
currentBytes
0
)
;
do_check_eq
(
download
.
totalBytes
0
)
;
}
}
;
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
sourceUrl
)
;
}
await
deferRequestReceived
.
promise
;
await
promiseExecuteSoon
(
)
;
do_check_false
(
download
.
stopped
)
;
do_check_false
(
download
.
hasProgress
)
;
do_check_eq
(
download
.
currentBytes
0
)
;
do_check_eq
(
download
.
totalBytes
0
)
;
continueResponses
(
)
;
await
promiseDownloadStopped
(
download
)
;
do_check_eq
(
download
.
contentType
"
text
/
plain
"
)
;
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
hasProgress
)
;
do_check_eq
(
download
.
progress
100
)
;
do_check_eq
(
download
.
currentBytes
0
)
;
do_check_eq
(
download
.
totalBytes
0
)
;
do_check_true
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
do_check_eq
(
(
await
OS
.
File
.
stat
(
download
.
target
.
path
)
)
.
size
0
)
;
}
)
;
add_task
(
async
function
test_start_twice
(
)
{
mustInterruptResponses
(
)
;
let
download
;
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
}
let
promiseAttempt1
=
download
.
start
(
)
;
let
promiseAttempt2
=
download
.
start
(
)
;
continueResponses
(
)
;
await
promiseAttempt1
;
await
promiseAttempt2
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_cancel_midway
(
)
{
mustInterruptResponses
(
)
;
let
download
;
let
options
=
{
}
;
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
options
)
;
}
let
deferCancel
=
Promise
.
defer
(
)
;
let
onchange
=
function
(
)
{
if
(
!
download
.
stopped
&
&
!
download
.
canceled
&
&
download
.
progress
=
=
50
)
{
deferCancel
.
resolve
(
download
.
cancel
(
)
)
;
do_check_true
(
download
.
canceled
)
;
}
}
;
download
.
onchange
=
onchange
;
onchange
(
)
;
let
promiseAttempt
;
if
(
!
gUseLegacySaver
)
{
promiseAttempt
=
download
.
start
(
)
;
}
await
deferCancel
.
promise
;
if
(
gUseLegacySaver
)
{
do_check_eq
(
options
.
outPersist
.
result
Cr
.
NS_ERROR_ABORT
)
;
}
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_eq
(
download
.
progress
50
)
;
do_check_eq
(
download
.
totalBytes
TEST_DATA_SHORT
.
length
*
2
)
;
do_check_eq
(
download
.
currentBytes
TEST_DATA_SHORT
.
length
)
;
if
(
!
gUseLegacySaver
)
{
try
{
await
promiseAttempt
;
do_throw
(
"
The
download
should
have
been
canceled
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
)
{
throw
ex
;
}
do_check_false
(
ex
.
becauseSourceFailed
)
;
do_check_false
(
ex
.
becauseTargetFailed
)
;
}
}
}
)
;
add_task
(
async
function
test_cancel_midway_tryToKeepPartialData
(
)
{
let
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
await
download
.
cancel
(
)
;
await
download
.
removePartialData
(
)
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
}
)
;
add_task
(
async
function
test_cancel_immediately
(
)
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
promiseAttempt
=
download
.
start
(
)
;
do_check_false
(
download
.
stopped
)
;
let
promiseCancel
=
download
.
cancel
(
)
;
do_check_true
(
download
.
canceled
)
;
try
{
await
promiseAttempt
;
do_throw
(
"
The
download
should
have
been
canceled
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
)
{
throw
ex
;
}
do_check_false
(
ex
.
becauseSourceFailed
)
;
do_check_false
(
ex
.
becauseTargetFailed
)
;
}
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
await
promiseCancel
;
}
)
;
add_task
(
async
function
test_cancel_midway_restart
(
)
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
await
promiseDownloadMidway
(
download
)
;
await
download
.
cancel
(
)
;
do_check_true
(
download
.
stopped
)
;
continueResponses
(
)
;
download
.
onchange
=
null
;
let
promiseAttempt
=
download
.
start
(
)
;
do_check_false
(
download
.
stopped
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_eq
(
download
.
progress
0
)
;
do_check_eq
(
download
.
totalBytes
0
)
;
do_check_eq
(
download
.
currentBytes
0
)
;
await
promiseAttempt
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_cancel_midway_restart_tryToKeepPartialData
(
)
{
let
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
await
download
.
cancel
(
)
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
hasPartialData
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
await
promiseVerifyContents
(
download
.
target
.
partFilePath
TEST_DATA_SHORT
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
do_check_eq
(
gMostRecentFirstBytePos
0
)
;
let
deferMidway
=
Promise
.
defer
(
)
;
download
.
onchange
=
function
(
)
{
if
(
!
download
.
stopped
&
&
!
download
.
canceled
&
&
download
.
currentBytes
=
=
Math
.
floor
(
TEST_DATA_SHORT
.
length
*
3
/
2
)
)
{
download
.
onchange
=
null
;
deferMidway
.
resolve
(
)
;
}
}
;
mustInterruptResponses
(
)
;
let
promiseAttempt
=
download
.
start
(
)
;
await
deferMidway
.
promise
;
do_check_true
(
download
.
progress
>
72
&
&
download
.
progress
<
78
)
;
continueResponses
(
)
;
await
promiseAttempt
;
do_check_eq
(
gMostRecentFirstBytePos
TEST_DATA_SHORT
.
length
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
}
)
;
add_task
(
async
function
test_cancel_midway_restart_removePartialData
(
)
{
let
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
await
download
.
cancel
(
)
;
await
download
.
removePartialData
(
)
;
do_check_false
(
download
.
hasPartialData
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
continueResponses
(
)
;
await
download
.
start
(
)
;
do_check_eq
(
gMostRecentFirstBytePos
0
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
}
)
;
add_task
(
async
function
test_cancel_midway_restart_tryToKeepPartialData_false
(
)
{
let
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
await
download
.
cancel
(
)
;
download
.
tryToKeepPartialData
=
false
;
do_check_true
(
download
.
hasPartialData
)
;
await
promiseVerifyContents
(
download
.
target
.
partFilePath
TEST_DATA_SHORT
)
;
await
download
.
removePartialData
(
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
mustInterruptResponses
(
)
;
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
promiseDownloadMidway
(
download
)
;
await
promisePartFileReady
(
download
)
;
do_check_false
(
download
.
hasPartialData
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
|
|
Services
.
appinfo
.
OS
=
=
"
Linux
"
)
{
do_check_eq
(
(
await
OS
.
File
.
stat
(
download
.
target
.
partFilePath
)
)
.
unixMode
0o600
)
;
}
await
download
.
cancel
(
)
;
do_check_false
(
download
.
hasPartialData
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
continueResponses
(
)
;
await
download
.
start
(
)
;
do_check_eq
(
gMostRecentFirstBytePos
0
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
}
)
;
add_task
(
async
function
test_cancel_immediately_restart_immediately
(
)
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
promiseAttempt
=
download
.
start
(
)
;
do_check_false
(
download
.
stopped
)
;
download
.
cancel
(
)
;
do_check_true
(
download
.
canceled
)
;
let
promiseRestarted
=
download
.
start
(
)
;
do_check_false
(
download
.
stopped
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_eq
(
download
.
hasProgress
false
)
;
do_check_eq
(
download
.
progress
0
)
;
do_check_eq
(
download
.
totalBytes
0
)
;
do_check_eq
(
download
.
currentBytes
0
)
;
continueResponses
(
)
;
try
{
await
promiseAttempt
;
do_print
(
"
The
download
should
have
been
canceled
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
)
{
throw
ex
;
}
do_check_false
(
ex
.
becauseSourceFailed
)
;
do_check_false
(
ex
.
becauseTargetFailed
)
;
}
await
promiseRestarted
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_cancel_midway_restart_immediately
(
)
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
promiseAttempt
=
download
.
start
(
)
;
await
promiseDownloadMidway
(
download
)
;
download
.
cancel
(
)
;
do_check_true
(
download
.
canceled
)
;
let
promiseRestarted
=
download
.
start
(
)
;
do_check_false
(
download
.
stopped
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_eq
(
download
.
hasProgress
false
)
;
do_check_eq
(
download
.
progress
0
)
;
do_check_eq
(
download
.
totalBytes
0
)
;
do_check_eq
(
download
.
currentBytes
0
)
;
continueResponses
(
)
;
try
{
await
promiseAttempt
;
do_throw
(
"
The
download
should
have
been
canceled
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
)
{
throw
ex
;
}
do_check_false
(
ex
.
becauseSourceFailed
)
;
do_check_false
(
ex
.
becauseTargetFailed
)
;
}
await
promiseRestarted
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_cancel_successful
(
)
{
let
download
=
await
promiseStartDownload
(
)
;
await
promiseDownloadStopped
(
download
)
;
await
download
.
cancel
(
)
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_cancel_twice
(
)
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
promiseAttempt
=
download
.
start
(
)
;
do_check_false
(
download
.
stopped
)
;
let
promiseCancel1
=
download
.
cancel
(
)
;
do_check_true
(
download
.
canceled
)
;
let
promiseCancel2
=
download
.
cancel
(
)
;
try
{
await
promiseAttempt
;
do_throw
(
"
The
download
should
have
been
canceled
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
)
{
throw
ex
;
}
do_check_false
(
ex
.
becauseSourceFailed
)
;
do_check_false
(
ex
.
becauseTargetFailed
)
;
}
await
promiseCancel1
;
await
promiseCancel2
;
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
succeeded
)
;
do_check_true
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
}
)
;
add_task
(
async
function
test_refresh_succeeded
(
)
{
let
download
=
await
promiseStartDownload
(
)
;
await
promiseDownloadStopped
(
download
)
;
await
download
.
refresh
(
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
)
;
await
OS
.
File
.
move
(
download
.
target
.
path
download
.
target
.
path
+
"
.
old
"
)
;
await
download
.
refresh
(
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
TEST_DATA_SHORT
.
length
)
;
await
OS
.
File
.
move
(
download
.
target
.
path
+
"
.
old
"
download
.
target
.
path
)
;
await
download
.
refresh
(
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_finalize
(
)
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
promiseFinalized
=
download
.
finalize
(
)
;
try
{
await
download
.
start
(
)
;
do_throw
(
"
It
should
not
be
possible
to
restart
after
finalization
.
"
)
;
}
catch
(
ex
)
{
}
await
promiseFinalized
;
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
succeeded
)
;
do_check_true
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
}
)
;
add_task
(
async
function
test_finalize_tryToKeepPartialData
(
)
{
let
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
await
download
.
finalize
(
)
;
do_check_true
(
download
.
hasPartialData
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
await
download
.
removePartialData
(
)
;
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
await
download
.
finalize
(
true
)
;
do_check_false
(
download
.
hasPartialData
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
}
)
;
add_task
(
async
function
test_whenSucceeded_after_restart
(
)
{
mustInterruptResponses
(
)
;
let
promiseSucceeded
;
let
download
;
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
promiseSucceeded
=
download
.
whenSucceeded
(
)
;
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
promiseSucceeded
=
download
.
whenSucceeded
(
)
;
}
await
download
.
cancel
(
)
;
continueResponses
(
)
;
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
await
promiseSucceeded
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_error_source
(
)
{
let
serverSocket
=
startFakeServer
(
)
;
try
{
let
sourceUrl
=
"
http
:
/
/
localhost
:
"
+
serverSocket
.
port
+
"
/
source
.
txt
"
;
let
download
;
try
{
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
sourceUrl
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
sourceUrl
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_throw
(
"
The
download
should
have
failed
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
!
ex
.
becauseSourceFailed
)
{
throw
ex
;
}
}
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
!
=
=
null
)
;
do_check_true
(
download
.
error
.
becauseSourceFailed
)
;
do_check_false
(
download
.
error
.
becauseTargetFailed
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
}
finally
{
serverSocket
.
close
(
)
;
}
}
)
;
add_task
(
async
function
test_error_source_partial
(
)
{
let
sourceUrl
=
httpUrl
(
"
shorter
-
than
-
content
-
length
-
http
-
1
-
1
.
txt
"
)
;
let
enforcePref
=
Services
.
prefs
.
getBoolPref
(
"
network
.
http
.
enforce
-
framing
.
http1
"
)
;
Services
.
prefs
.
setBoolPref
(
"
network
.
http
.
enforce
-
framing
.
http1
"
true
)
;
function
cleanup
(
)
{
Services
.
prefs
.
setBoolPref
(
"
network
.
http
.
enforce
-
framing
.
http1
"
enforcePref
)
;
}
do_register_cleanup
(
cleanup
)
;
let
download
;
try
{
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
sourceUrl
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
sourceUrl
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_throw
(
"
The
download
should
have
failed
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
!
ex
.
becauseSourceFailed
)
{
throw
ex
;
}
}
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
!
=
=
null
)
;
do_check_true
(
download
.
error
.
becauseSourceFailed
)
;
do_check_false
(
download
.
error
.
becauseTargetFailed
)
;
do_check_eq
(
download
.
error
.
result
Cr
.
NS_ERROR_NET_PARTIAL_TRANSFER
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
}
)
;
add_task
(
async
function
test_error_target
(
)
{
let
targetFile
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
;
targetFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0
)
;
try
{
let
download
;
try
{
if
(
!
gUseLegacySaver
)
{
download
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
source
.
txt
"
)
target
:
targetFile
}
)
;
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
null
{
targetFile
}
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_throw
(
"
The
download
should
have
failed
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
!
ex
.
becauseTargetFailed
)
{
throw
ex
;
}
}
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
!
=
=
null
)
;
do_check_true
(
download
.
error
.
becauseTargetFailed
)
;
do_check_false
(
download
.
error
.
becauseSourceFailed
)
;
}
finally
{
if
(
targetFile
.
exists
(
)
)
{
targetFile
.
permissions
=
FileUtils
.
PERMS_FILE
;
targetFile
.
remove
(
false
)
;
}
}
}
)
;
add_task
(
async
function
test_error_restart
(
)
{
let
download
;
let
targetFile
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
;
targetFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0
)
;
try
{
if
(
!
gUseLegacySaver
)
{
download
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
source
.
txt
"
)
target
:
targetFile
}
)
;
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
null
{
targetFile
}
)
;
}
await
promiseDownloadStopped
(
download
)
;
do_throw
(
"
The
download
should
have
failed
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
!
ex
.
becauseTargetFailed
)
{
throw
ex
;
}
}
finally
{
if
(
targetFile
.
exists
(
)
)
{
targetFile
.
permissions
=
FileUtils
.
PERMS_FILE
;
targetFile
.
moveTo
(
null
targetFile
.
leafName
+
"
.
delete
.
tmp
"
)
;
targetFile
.
remove
(
false
)
;
}
}
await
download
.
start
(
)
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
canceled
)
;
do_check_true
(
download
.
error
=
=
=
null
)
;
do_check_eq
(
download
.
progress
100
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_public_and_private
(
)
{
let
sourcePath
=
"
/
test_public_and_private
.
txt
"
;
let
sourceUrl
=
httpUrl
(
"
test_public_and_private
.
txt
"
)
;
let
testCount
=
0
;
Services
.
prefs
.
setIntPref
(
"
network
.
cookie
.
cookieBehavior
"
0
)
;
function
cleanup
(
)
{
Services
.
prefs
.
clearUserPref
(
"
network
.
cookie
.
cookieBehavior
"
)
;
Services
.
cookies
.
removeAll
(
)
;
gHttpServer
.
registerPathHandler
(
sourcePath
null
)
;
}
do_register_cleanup
(
cleanup
)
;
gHttpServer
.
registerPathHandler
(
sourcePath
function
(
aRequest
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
if
(
testCount
=
=
0
)
{
do_check_false
(
aRequest
.
hasHeader
(
"
Cookie
"
)
)
;
aResponse
.
setHeader
(
"
Set
-
Cookie
"
"
foobar
=
1
"
false
)
;
testCount
+
+
;
}
else
if
(
testCount
=
=
1
)
{
do_check_true
(
aRequest
.
hasHeader
(
"
Cookie
"
)
)
;
do_check_eq
(
aRequest
.
getHeader
(
"
Cookie
"
)
"
foobar
=
1
"
)
;
testCount
+
+
;
}
else
if
(
testCount
=
=
2
)
{
do_check_false
(
aRequest
.
hasHeader
(
"
Cookie
"
)
)
;
}
}
)
;
let
targetFile
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
;
await
Downloads
.
fetch
(
sourceUrl
targetFile
)
;
await
Downloads
.
fetch
(
sourceUrl
targetFile
)
;
if
(
!
gUseLegacySaver
)
{
let
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
sourceUrl
isPrivate
:
true
}
target
:
targetFile
}
)
;
await
download
.
start
(
)
;
}
else
{
let
download
=
await
promiseStartLegacyDownload
(
sourceUrl
{
isPrivate
:
true
}
)
;
await
promiseDownloadStopped
(
download
)
;
}
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_cancel_immediately_restart_and_check_startTime
(
)
{
let
download
=
await
promiseStartDownload
(
)
;
let
startTime
=
download
.
startTime
;
do_check_true
(
isValidDate
(
download
.
startTime
)
)
;
await
download
.
cancel
(
)
;
do_check_eq
(
download
.
startTime
.
getTime
(
)
startTime
.
getTime
(
)
)
;
await
promiseTimeout
(
10
)
;
await
download
.
start
(
)
;
do_check_true
(
download
.
startTime
.
getTime
(
)
>
startTime
.
getTime
(
)
)
;
}
)
;
add_task
(
async
function
test_with_content_encoding
(
)
{
let
sourcePath
=
"
/
test_with_content_encoding
.
txt
"
;
let
sourceUrl
=
httpUrl
(
"
test_with_content_encoding
.
txt
"
)
;
function
cleanup
(
)
{
gHttpServer
.
registerPathHandler
(
sourcePath
null
)
;
}
do_register_cleanup
(
cleanup
)
;
gHttpServer
.
registerPathHandler
(
sourcePath
function
(
aRequest
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Encoding
"
"
gzip
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Length
"
"
"
+
TEST_DATA_SHORT_GZIP_ENCODED
.
length
false
)
;
let
bos
=
new
BinaryOutputStream
(
aResponse
.
bodyOutputStream
)
;
bos
.
writeByteArray
(
TEST_DATA_SHORT_GZIP_ENCODED
TEST_DATA_SHORT_GZIP_ENCODED
.
length
)
;
}
)
;
let
download
=
await
promiseStartDownload
(
sourceUrl
)
;
await
promiseDownloadStopped
(
download
)
;
do_check_eq
(
download
.
progress
100
)
;
do_check_eq
(
download
.
totalBytes
TEST_DATA_SHORT_GZIP_ENCODED
.
length
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_with_content_encoding_ignore_extension
(
)
{
let
sourcePath
=
"
/
test_with_content_encoding_ignore_extension
.
gz
"
;
let
sourceUrl
=
httpUrl
(
"
test_with_content_encoding_ignore_extension
.
gz
"
)
;
function
cleanup
(
)
{
gHttpServer
.
registerPathHandler
(
sourcePath
null
)
;
}
do_register_cleanup
(
cleanup
)
;
gHttpServer
.
registerPathHandler
(
sourcePath
function
(
aRequest
aResponse
)
{
aResponse
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Encoding
"
"
gzip
"
false
)
;
aResponse
.
setHeader
(
"
Content
-
Length
"
"
"
+
TEST_DATA_SHORT_GZIP_ENCODED
.
length
false
)
;
let
bos
=
new
BinaryOutputStream
(
aResponse
.
bodyOutputStream
)
;
bos
.
writeByteArray
(
TEST_DATA_SHORT_GZIP_ENCODED
TEST_DATA_SHORT_GZIP_ENCODED
.
length
)
;
}
)
;
let
download
=
await
promiseStartDownload
(
sourceUrl
)
;
await
promiseDownloadStopped
(
download
)
;
do_check_eq
(
download
.
progress
100
)
;
do_check_eq
(
download
.
totalBytes
TEST_DATA_SHORT_GZIP_ENCODED
.
length
)
;
do_check_eq
(
download
.
target
.
size
TEST_DATA_SHORT_GZIP_ENCODED
.
length
)
;
await
promiseVerifyTarget
(
download
.
target
String
.
fromCharCode
.
apply
(
String
TEST_DATA_SHORT_GZIP_ENCODED
)
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_cancel_midway_restart_with_content_encoding
(
)
{
mustInterruptResponses
(
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible_gzip
.
txt
"
)
)
;
await
new
Promise
(
resolve
=
>
{
let
onchange
=
function
(
)
{
if
(
!
download
.
stopped
&
&
!
download
.
canceled
&
&
download
.
currentBytes
=
=
TEST_DATA_SHORT_GZIP_ENCODED_FIRST
.
length
)
{
resolve
(
download
.
cancel
(
)
)
;
}
}
;
download
.
onchange
=
onchange
;
onchange
(
)
;
}
)
;
do_check_true
(
download
.
stopped
)
;
continueResponses
(
)
;
download
.
onchange
=
null
;
await
download
.
start
(
)
;
do_check_eq
(
download
.
progress
100
)
;
do_check_eq
(
download
.
totalBytes
TEST_DATA_SHORT_GZIP_ENCODED
.
length
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
)
;
}
)
;
add_task
(
async
function
test_blocked_parental_controls
(
)
{
let
blockFn
=
base
=
>
(
{
shouldBlockForParentalControls
:
(
)
=
>
Promise
.
resolve
(
true
)
}
)
;
Integration
.
downloads
.
register
(
blockFn
)
;
function
cleanup
(
)
{
Integration
.
downloads
.
unregister
(
blockFn
)
;
}
do_register_cleanup
(
cleanup
)
;
let
download
;
try
{
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
)
;
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_throw
(
"
The
download
should
have
blocked
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
!
ex
.
becauseBlocked
)
{
throw
ex
;
}
do_check_true
(
ex
.
becauseBlockedByParentalControls
)
;
do_check_true
(
download
.
error
.
becauseBlockedByParentalControls
)
;
}
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_blocked_parental_controls_httpstatus450
(
)
{
let
download
;
try
{
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
httpUrl
(
"
parentalblocked
.
zip
"
)
)
;
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
httpUrl
(
"
parentalblocked
.
zip
"
)
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_throw
(
"
The
download
should
have
blocked
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
!
ex
.
becauseBlocked
)
{
throw
ex
;
}
do_check_true
(
ex
.
becauseBlockedByParentalControls
)
;
do_check_true
(
download
.
error
.
becauseBlockedByParentalControls
)
;
do_check_true
(
download
.
stopped
)
;
}
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
}
)
;
add_task
(
async
function
test_blocked_runtime_permissions
(
)
{
let
blockFn
=
base
=
>
(
{
shouldBlockForRuntimePermissions
:
(
)
=
>
Promise
.
resolve
(
true
)
}
)
;
Integration
.
downloads
.
register
(
blockFn
)
;
function
cleanup
(
)
{
Integration
.
downloads
.
unregister
(
blockFn
)
;
}
do_register_cleanup
(
cleanup
)
;
let
download
;
try
{
if
(
!
gUseLegacySaver
)
{
download
=
await
promiseNewDownload
(
)
;
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_throw
(
"
The
download
should
have
blocked
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
!
ex
.
becauseBlocked
)
{
throw
ex
;
}
do_check_true
(
ex
.
becauseBlockedByRuntimePermissions
)
;
do_check_true
(
download
.
error
.
becauseBlockedByRuntimePermissions
)
;
}
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_getSha256Hash
(
)
{
if
(
!
gUseLegacySaver
)
{
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
source
.
txt
"
)
)
;
await
promiseDownloadStopped
(
download
)
;
do_check_true
(
download
.
stopped
)
;
do_check_eq
(
32
download
.
saver
.
getSha256Hash
(
)
.
length
)
;
}
}
)
;
var
promiseBlockedDownload
=
async
function
(
options
)
{
let
blockFn
=
base
=
>
(
{
shouldBlockForReputationCheck
:
(
)
=
>
Promise
.
resolve
(
{
shouldBlock
:
true
verdict
:
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
}
)
shouldKeepBlockedData
:
(
)
=
>
Promise
.
resolve
(
options
.
keepBlockedData
)
}
)
;
Integration
.
downloads
.
register
(
blockFn
)
;
function
cleanup
(
)
{
Integration
.
downloads
.
unregister
(
blockFn
)
;
}
do_register_cleanup
(
cleanup
)
;
let
download
;
try
{
if
(
options
.
keepPartialData
)
{
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
continueResponses
(
)
;
}
else
if
(
gUseLegacySaver
)
{
download
=
await
promiseStartLegacyDownload
(
)
;
}
else
{
download
=
await
promiseNewDownload
(
)
;
await
download
.
start
(
)
;
do_throw
(
"
The
download
should
have
blocked
.
"
)
;
}
await
promiseDownloadStopped
(
download
)
;
do_throw
(
"
The
download
should
have
blocked
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
!
ex
.
becauseBlocked
)
{
throw
ex
;
}
do_check_true
(
ex
.
becauseBlockedByReputationCheck
)
;
do_check_eq
(
ex
.
reputationCheckVerdict
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
)
;
do_check_true
(
download
.
error
.
becauseBlockedByReputationCheck
)
;
do_check_eq
(
download
.
error
.
reputationCheckVerdict
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
)
;
}
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
succeeded
)
;
cleanup
(
)
;
return
download
;
}
;
add_task
(
async
function
test_blocked_applicationReputation
(
)
{
let
download
=
await
promiseBlockedDownload
(
{
keepPartialData
:
false
keepBlockedData
:
false
}
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
do_check_false
(
download
.
hasBlockedData
)
;
}
)
;
add_task
(
async
function
test_blocked_applicationReputation_race
(
)
{
let
isFirstShouldBlockCall
=
true
;
let
blockFn
=
base
=
>
(
{
shouldBlockForReputationCheck
(
download
)
{
if
(
isFirstShouldBlockCall
)
{
isFirstShouldBlockCall
=
false
;
download
.
cancel
(
)
;
download
.
removePartialData
(
)
;
download
.
start
(
)
;
return
Promise
.
resolve
(
{
shouldBlock
:
true
verdict
:
Downloads
.
Error
.
BLOCK_VERDICT_UNCOMMON
}
)
;
}
return
Promise
.
resolve
(
{
shouldBlock
:
false
verdict
:
"
"
}
)
;
}
shouldKeepBlockedData
:
(
)
=
>
Promise
.
resolve
(
true
)
}
)
;
Integration
.
downloads
.
register
(
blockFn
)
;
function
cleanup
(
)
{
Integration
.
downloads
.
unregister
(
blockFn
)
;
}
do_register_cleanup
(
cleanup
)
;
let
download
;
try
{
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
let
firstAttempt
=
promiseDownloadStopped
(
download
)
;
continueResponses
(
)
;
await
firstAttempt
;
do_throw
(
"
The
first
attempt
should
have
been
canceled
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Downloads
.
Error
)
|
|
ex
.
becauseBlocked
)
{
throw
ex
;
}
}
await
promiseDownloadStopped
(
download
)
;
do_check_false
(
download
.
hasBlockedData
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_blocked_applicationReputation_confirmBlock
(
)
{
let
download
=
await
promiseBlockedDownload
(
{
keepPartialData
:
true
keepBlockedData
:
true
}
)
;
do_check_true
(
download
.
hasBlockedData
)
;
do_check_eq
(
(
await
OS
.
File
.
stat
(
download
.
target
.
path
)
)
.
size
0
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
await
download
.
confirmBlock
(
)
;
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
succeeded
)
;
do_check_false
(
download
.
hasBlockedData
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
}
)
;
add_task
(
async
function
test_blocked_applicationReputation_unblock
(
)
{
let
download
=
await
promiseBlockedDownload
(
{
keepPartialData
:
true
keepBlockedData
:
true
}
)
;
do_check_true
(
download
.
hasBlockedData
)
;
do_check_eq
(
(
await
OS
.
File
.
stat
(
download
.
target
.
path
)
)
.
size
0
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
await
download
.
unblock
(
)
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
hasBlockedData
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
await
promiseVerifyTarget
(
download
.
target
TEST_DATA_SHORT
+
TEST_DATA_SHORT
)
;
do_check_true
(
download
.
error
instanceof
Downloads
.
Error
)
;
do_check_true
(
download
.
error
.
becauseBlocked
)
;
do_check_true
(
download
.
error
.
becauseBlockedByReputationCheck
)
;
}
)
;
add_task
(
async
function
test_blocked_applicationReputation_cancel
(
)
{
let
download
=
await
promiseBlockedDownload
(
{
keepPartialData
:
true
keepBlockedData
:
true
}
)
;
await
download
.
cancel
(
)
;
do_check_true
(
download
.
error
.
becauseBlockedByReputationCheck
)
;
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
succeeded
)
;
do_check_true
(
download
.
hasBlockedData
)
;
}
)
;
add_task
(
async
function
test_blocked_applicationReputation_decisionRace
(
)
{
let
download
=
await
promiseBlockedDownload
(
{
keepPartialData
:
true
keepBlockedData
:
true
}
)
;
let
unblockPromise
=
download
.
unblock
(
)
;
let
confirmBlockPromise
=
download
.
confirmBlock
(
)
;
await
confirmBlockPromise
.
then
(
(
)
=
>
{
do_throw
(
"
confirmBlock
should
have
failed
.
"
)
;
}
(
)
=
>
{
}
)
;
await
unblockPromise
;
do_check_true
(
download
.
stopped
)
;
do_check_true
(
download
.
succeeded
)
;
do_check_false
(
download
.
hasBlockedData
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
download
=
await
promiseBlockedDownload
(
{
keepPartialData
:
true
keepBlockedData
:
true
}
)
;
confirmBlockPromise
=
download
.
confirmBlock
(
)
;
unblockPromise
=
download
.
unblock
(
)
;
await
unblockPromise
.
then
(
(
)
=
>
{
do_throw
(
"
unblock
should
have
failed
.
"
)
;
}
(
)
=
>
{
}
)
;
await
confirmBlockPromise
;
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
succeeded
)
;
do_check_false
(
download
.
hasBlockedData
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
do_check_false
(
await
OS
.
File
.
exists
(
download
.
target
.
path
)
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
}
)
;
add_task
(
async
function
test_blocked_applicationReputation_unblock
(
)
{
let
download
=
await
promiseBlockedDownload
(
{
keepPartialData
:
true
keepBlockedData
:
true
}
)
;
do_check_true
(
download
.
hasBlockedData
)
;
do_check_true
(
await
OS
.
File
.
exists
(
download
.
target
.
partFilePath
)
)
;
await
OS
.
File
.
remove
(
download
.
target
.
partFilePath
)
;
let
unblockPromise
=
download
.
unblock
(
)
;
await
unblockPromise
.
then
(
(
)
=
>
{
do_throw
(
"
unblock
should
have
failed
.
"
)
;
}
(
)
=
>
{
}
)
;
do_check_false
(
download
.
hasBlockedData
)
;
do_check_true
(
download
.
stopped
)
;
do_check_false
(
download
.
succeeded
)
;
do_check_false
(
download
.
target
.
exists
)
;
do_check_eq
(
download
.
target
.
size
0
)
;
}
)
;
add_task
(
async
function
test_showContainingDirectory
(
)
{
let
targetPath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
let
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
}
target
:
"
"
}
)
;
let
promiseDirectoryShown
=
waitForDirectoryShown
(
)
;
await
download
.
showContainingDirectory
(
)
;
let
path
=
await
promiseDirectoryShown
;
try
{
new
FileUtils
.
File
(
path
)
;
do_throw
(
"
Should
have
failed
because
of
an
invalid
path
.
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Components
.
Exception
)
)
{
throw
ex
;
}
let
validResult
=
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_UNRECOGNIZED_PATH
|
|
ex
.
result
=
=
Cr
.
NS_ERROR_FAILURE
;
do_check_true
(
validResult
)
;
}
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
}
target
:
targetPath
}
)
;
promiseDirectoryShown
=
waitForDirectoryShown
(
)
;
download
.
showContainingDirectory
(
)
;
await
promiseDirectoryShown
;
}
)
;
add_task
(
async
function
test_launch
(
)
{
let
customLauncher
=
getTempFile
(
"
app
-
launcher
"
)
;
for
(
let
launcherPath
of
[
null
customLauncher
.
path
]
)
{
let
download
;
if
(
!
gUseLegacySaver
)
{
download
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
source
.
txt
"
)
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
launcherPath
launchWhenSucceeded
:
true
}
)
;
try
{
await
download
.
launch
(
)
;
do_throw
(
"
Can
'
t
launch
download
file
as
it
has
not
completed
yet
"
)
;
}
catch
(
ex
)
{
do_check_eq
(
ex
.
message
"
launch
can
only
be
called
if
the
download
succeeded
"
)
;
}
await
download
.
start
(
)
;
}
else
{
download
=
await
promiseStartLegacyDownload
(
httpUrl
(
"
source
.
txt
"
)
{
launcherPath
launchWhenSucceeded
:
true
}
)
;
await
promiseDownloadStopped
(
download
)
;
}
do_check_true
(
download
.
launchWhenSucceeded
)
;
let
promiseFileLaunched
=
waitForFileLaunched
(
)
;
download
.
launch
(
)
;
let
result
=
await
promiseFileLaunched
;
if
(
!
launcherPath
)
{
do_check_true
(
result
=
=
=
null
)
;
}
else
{
do_check_eq
(
result
.
preferredAction
Ci
.
nsIMIMEInfo
.
useHelperApp
)
;
do_check_true
(
result
.
preferredApplicationHandler
.
QueryInterface
(
Ci
.
nsILocalHandlerApp
)
.
executable
.
equals
(
customLauncher
)
)
;
}
}
}
)
;
add_task
(
async
function
test_launcherPath_invalid
(
)
{
let
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
}
target
:
{
path
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
}
launcherPath
:
"
"
}
)
;
let
promiseDownloadLaunched
=
new
Promise
(
resolve
=
>
{
let
waitFn
=
base
=
>
(
{
__proto__
:
base
launchDownload
(
)
{
Integration
.
downloads
.
unregister
(
waitFn
)
;
let
superPromise
=
super
.
launchDownload
(
.
.
.
arguments
)
;
resolve
(
superPromise
)
;
return
superPromise
;
}
}
)
;
Integration
.
downloads
.
register
(
waitFn
)
;
}
)
;
await
download
.
start
(
)
;
try
{
download
.
launch
(
)
;
await
promiseDownloadLaunched
;
do_throw
(
"
Can
'
t
launch
file
with
invalid
custom
launcher
"
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
Components
.
Exception
)
)
{
throw
ex
;
}
let
validResult
=
ex
.
result
=
=
Cr
.
NS_ERROR_FILE_UNRECOGNIZED_PATH
|
|
ex
.
result
=
=
Cr
.
NS_ERROR_FAILURE
;
do_check_true
(
validResult
)
;
}
}
)
;
add_task
(
async
function
test_launchWhenSucceeded
(
)
{
let
customLauncher
=
getTempFile
(
"
app
-
launcher
"
)
;
for
(
let
launcherPath
of
[
null
customLauncher
.
path
]
)
{
let
promiseFileLaunched
=
waitForFileLaunched
(
)
;
if
(
!
gUseLegacySaver
)
{
let
download
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
source
.
txt
"
)
target
:
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
launchWhenSucceeded
:
true
launcherPath
}
)
;
await
download
.
start
(
)
;
}
else
{
let
download
=
await
promiseStartLegacyDownload
(
httpUrl
(
"
source
.
txt
"
)
{
launcherPath
launchWhenSucceeded
:
true
}
)
;
await
promiseDownloadStopped
(
download
)
;
}
let
result
=
await
promiseFileLaunched
;
if
(
!
launcherPath
)
{
do_check_true
(
result
=
=
=
null
)
;
}
else
{
do_check_eq
(
result
.
preferredAction
Ci
.
nsIMIMEInfo
.
useHelperApp
)
;
do_check_true
(
result
.
preferredApplicationHandler
.
QueryInterface
(
Ci
.
nsILocalHandlerApp
)
.
executable
.
equals
(
customLauncher
)
)
;
}
}
}
)
;
add_task
(
async
function
test_contentType
(
)
{
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
source
.
txt
"
)
)
;
await
promiseDownloadStopped
(
download
)
;
do_check_eq
(
"
text
/
plain
"
download
.
contentType
)
;
}
)
;
add_task
(
async
function
test_toSerializable_startTime
(
)
{
let
download1
=
await
promiseStartDownload
(
httpUrl
(
"
source
.
txt
"
)
)
;
await
promiseDownloadStopped
(
download1
)
;
let
serializable
=
download1
.
toSerializable
(
)
;
let
reserialized
=
JSON
.
parse
(
JSON
.
stringify
(
serializable
)
)
;
let
download2
=
await
Downloads
.
createDownload
(
reserialized
)
;
do_check_eq
(
download1
.
startTime
.
constructor
.
name
"
Date
"
)
;
do_check_eq
(
download2
.
startTime
.
constructor
.
name
"
Date
"
)
;
do_check_eq
(
download1
.
startTime
.
toJSON
(
)
download2
.
startTime
.
toJSON
(
)
)
;
}
)
;
add_task
(
async
function
test_history
(
)
{
mustInterruptResponses
(
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
let
promiseVisit
=
promiseWaitForVisit
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
download
=
await
promiseStartDownload
(
httpUrl
(
"
interruptible
.
txt
"
)
)
;
let
[
time
transitionType
]
=
await
promiseVisit
;
do_check_eq
(
time
download
.
startTime
.
getTime
(
)
*
1000
)
;
do_check_eq
(
transitionType
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
download
.
cancel
(
)
;
continueResponses
(
)
;
await
download
.
start
(
)
;
do_check_false
(
await
promiseIsURIVisited
(
httpUrl
(
"
interruptible
.
txt
"
)
)
)
;
}
)
;
add_task
(
async
function
test_history_tryToKeepPartialData
(
)
{
await
PlacesUtils
.
history
.
clear
(
)
;
let
promiseVisit
=
promiseWaitForVisit
(
httpUrl
(
"
interruptible_resumable
.
txt
"
)
)
;
let
beforeStartTimeMs
=
Date
.
now
(
)
;
let
download
=
await
promiseStartDownload_tryToKeepPartialData
(
)
;
let
[
time
transitionType
]
=
await
promiseVisit
;
do_check_eq
(
transitionType
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
)
;
do_check_true
(
time
>
=
beforeStartTimeMs
*
1000
-
1000000
)
;
continueResponses
(
)
;
await
promiseDownloadStopped
(
download
)
;
}
)
;
add_task
(
async
function
test_launchWhenSucceeded_deleteTempFileOnExit
(
)
{
let
customLauncherPath
=
getTempFile
(
"
app
-
launcher
"
)
.
path
;
let
autoDeleteTargetPathOne
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
let
autoDeleteTargetPathTwo
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
let
noAutoDeleteTargetPath
=
getTempFile
(
TEST_TARGET_FILE_NAME
)
.
path
;
let
autoDeleteDownloadOne
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
httpUrl
(
"
source
.
txt
"
)
isPrivate
:
true
}
target
:
autoDeleteTargetPathOne
launchWhenSucceeded
:
true
launcherPath
:
customLauncherPath
}
)
;
await
autoDeleteDownloadOne
.
start
(
)
;
Services
.
prefs
.
setBoolPref
(
kDeleteTempFileOnExit
true
)
;
let
autoDeleteDownloadTwo
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
source
.
txt
"
)
target
:
autoDeleteTargetPathTwo
launchWhenSucceeded
:
true
launcherPath
:
customLauncherPath
}
)
;
await
autoDeleteDownloadTwo
.
start
(
)
;
Services
.
prefs
.
setBoolPref
(
kDeleteTempFileOnExit
false
)
;
let
noAutoDeleteDownload
=
await
Downloads
.
createDownload
(
{
source
:
httpUrl
(
"
source
.
txt
"
)
target
:
noAutoDeleteTargetPath
launchWhenSucceeded
:
true
launcherPath
:
customLauncherPath
}
)
;
await
noAutoDeleteDownload
.
start
(
)
;
Services
.
prefs
.
clearUserPref
(
kDeleteTempFileOnExit
)
;
do_check_true
(
await
OS
.
File
.
exists
(
autoDeleteTargetPathOne
)
)
;
do_check_true
(
await
OS
.
File
.
exists
(
autoDeleteTargetPathTwo
)
)
;
do_check_true
(
await
OS
.
File
.
exists
(
noAutoDeleteTargetPath
)
)
;
Services
.
obs
.
notifyObservers
(
null
"
last
-
pb
-
context
-
exited
"
)
;
do_check_false
(
await
OS
.
File
.
exists
(
autoDeleteTargetPathOne
)
)
;
let
expire
=
Cc
[
"
mozilla
.
org
/
uriloader
/
external
-
helper
-
app
-
service
;
1
"
]
.
getService
(
Ci
.
nsIObserver
)
;
expire
.
observe
(
null
"
profile
-
before
-
change
"
null
)
;
do_check_false
(
await
OS
.
File
.
exists
(
autoDeleteTargetPathTwo
)
)
;
do_check_true
(
await
OS
.
File
.
exists
(
noAutoDeleteTargetPath
)
)
;
}
)
;
