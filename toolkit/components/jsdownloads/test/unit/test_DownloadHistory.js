"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadHistory
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gDownloadHistory
"
"
mozilla
.
org
/
browser
/
download
-
history
;
1
"
Ci
.
nsIDownloadHistory
)
;
let
baseDate
=
new
Date
(
"
2000
-
01
-
01
"
)
;
function
waitForAnnotations
(
sourceUriSpec
)
{
let
sourceUri
=
Services
.
io
.
newURI
(
sourceUriSpec
)
;
let
destinationFileUriSet
=
false
;
let
metaDataSet
=
false
;
return
new
Promise
(
resolve
=
>
{
PlacesUtils
.
annotations
.
addObserver
(
{
onPageAnnotationSet
(
page
name
)
{
if
(
!
page
.
equals
(
sourceUri
)
)
{
return
;
}
switch
(
name
)
{
case
"
downloads
/
destinationFileURI
"
:
destinationFileUriSet
=
true
;
break
;
case
"
downloads
/
metaData
"
:
metaDataSet
=
true
;
break
;
}
if
(
destinationFileUriSet
&
&
metaDataSet
)
{
PlacesUtils
.
annotations
.
removeObserver
(
this
)
;
resolve
(
)
;
}
}
onItemAnnotationSet
(
)
{
}
onPageAnnotationRemoved
(
)
{
}
onItemAnnotationRemoved
(
)
{
}
}
)
;
}
)
;
}
function
areEqual
(
a
b
)
{
if
(
a
=
=
=
b
)
{
Assert
.
equal
(
a
b
)
;
return
true
;
}
info
(
a
+
"
!
=
=
"
+
b
)
;
return
false
;
}
class
TestView
{
constructor
(
expected
)
{
this
.
expected
=
[
.
.
.
expected
]
;
this
.
downloads
=
[
]
;
this
.
resolveWhenExpected
=
(
)
=
>
{
}
;
}
onDownloadAdded
(
download
options
=
{
}
)
{
if
(
options
.
insertBefore
)
{
let
index
=
this
.
downloads
.
indexOf
(
options
.
insertBefore
)
;
this
.
downloads
.
splice
(
index
0
download
)
;
}
else
{
this
.
downloads
.
push
(
download
)
;
}
this
.
checkForExpectedDownloads
(
)
;
}
onDownloadChanged
(
download
)
{
this
.
checkForExpectedDownloads
(
)
;
}
onDownloadRemoved
(
download
)
{
let
index
=
this
.
downloads
.
indexOf
(
download
)
;
this
.
downloads
.
splice
(
index
1
)
;
this
.
checkForExpectedDownloads
(
)
;
}
checkForExpectedDownloads
(
)
{
if
(
this
.
downloads
.
length
!
=
this
.
expected
.
length
)
{
return
;
}
for
(
let
i
=
0
;
i
<
this
.
downloads
.
length
;
i
+
+
)
{
if
(
this
.
downloads
[
i
]
.
source
.
url
!
=
this
.
expected
[
i
]
.
source
.
url
|
|
this
.
downloads
[
i
]
.
target
.
path
!
=
this
.
expected
[
i
]
.
target
.
path
)
{
return
;
}
}
for
(
let
i
=
0
;
i
<
this
.
downloads
.
length
;
i
+
+
)
{
let
download
=
this
.
downloads
[
i
]
;
let
testDownload
=
this
.
expected
[
i
]
;
info
(
"
Checking
download
source
"
+
download
.
source
.
url
+
"
with
target
"
+
download
.
target
.
path
)
;
if
(
!
areEqual
(
download
.
succeeded
!
!
testDownload
.
succeeded
)
|
|
!
areEqual
(
download
.
canceled
!
!
testDownload
.
canceled
)
|
|
!
areEqual
(
download
.
hasPartialData
!
!
testDownload
.
hasPartialData
)
|
|
!
areEqual
(
!
!
download
.
error
!
!
testDownload
.
error
)
)
{
return
;
}
if
(
download
.
error
)
{
if
(
testDownload
.
error
.
becauseSourceFailed
)
{
Assert
.
equal
(
download
.
error
.
message
"
History
download
failed
.
"
)
;
}
Assert
.
equal
(
download
.
error
.
becauseBlockedByParentalControls
testDownload
.
error
.
becauseBlockedByParentalControls
)
;
Assert
.
equal
(
download
.
error
.
becauseBlockedByReputationCheck
testDownload
.
error
.
becauseBlockedByReputationCheck
)
;
}
}
this
.
resolveWhenExpected
(
)
;
}
async
waitForExpected
(
)
{
let
promise
=
new
Promise
(
resolve
=
>
this
.
resolveWhenExpected
=
resolve
)
;
this
.
checkForExpectedDownloads
(
)
;
await
promise
;
}
}
add_task
(
async
function
test_DownloadHistory
(
)
{
async
function
cleanup
(
)
{
await
PlacesUtils
.
history
.
clear
(
)
;
}
registerCleanupFunction
(
cleanup
)
;
await
cleanup
(
)
;
let
testDownloads
=
[
{
offset
:
10
canceled
:
true
}
{
offset
:
20
succeeded
:
true
}
{
offset
:
30
error
:
{
becauseSourceFailed
:
true
}
}
{
offset
:
40
error
:
{
becauseBlockedByParentalControls
:
true
}
}
{
offset
:
50
error
:
{
becauseBlockedByReputationCheck
:
true
}
}
{
offset
:
45
canceled
:
true
inSession
:
true
}
{
offset
:
35
canceled
:
true
hasPartialData
:
true
inSession
:
true
}
{
offset
:
55
succeeded
:
true
inSession
:
true
}
]
;
const
NEXT_OFFSET
=
60
;
let
publicList
=
await
promiseNewList
(
)
;
let
allList
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
async
function
addTestDownload
(
properties
)
{
properties
.
source
=
{
url
:
httpUrl
(
"
source
"
+
properties
.
offset
)
isPrivate
:
properties
.
isPrivate
}
;
let
targetFile
=
getTempFile
(
TEST_TARGET_FILE_NAME
+
properties
.
offset
)
;
properties
.
target
=
{
path
:
targetFile
.
path
}
;
properties
.
startTime
=
new
Date
(
baseDate
.
getTime
(
)
+
properties
.
offset
)
;
let
download
=
await
Downloads
.
createDownload
(
properties
)
;
if
(
properties
.
inSession
)
{
await
allList
.
add
(
download
)
;
}
if
(
properties
.
isPrivate
)
{
return
;
}
let
promiseAnnotations
=
waitForAnnotations
(
properties
.
source
.
url
)
;
let
promiseVisit
=
promiseWaitForVisit
(
properties
.
source
.
url
)
;
gDownloadHistory
.
addDownload
(
Services
.
io
.
newURI
(
properties
.
source
.
url
)
null
properties
.
startTime
.
getTime
(
)
*
1000
NetUtil
.
newURI
(
targetFile
)
)
;
await
promiseVisit
;
DownloadHistory
.
updateMetaData
(
download
)
;
await
promiseAnnotations
;
}
for
(
let
properties
of
testDownloads
)
{
await
addTestDownload
(
properties
)
;
}
let
historyList
=
await
DownloadHistory
.
getList
(
)
;
let
view
=
new
TestView
(
testDownloads
)
;
await
historyList
.
addView
(
view
)
;
await
view
.
waitForExpected
(
)
;
let
downloadToRemove
=
view
.
expected
[
1
]
;
view
.
expected
.
splice
(
1
1
)
;
await
PlacesUtils
.
history
.
remove
(
downloadToRemove
.
source
.
url
)
;
await
view
.
waitForExpected
(
)
;
let
downloadToAdd
=
{
offset
:
NEXT_OFFSET
canceled
:
true
}
;
view
.
expected
.
splice
(
view
.
expected
.
findIndex
(
d
=
>
d
.
inSession
)
0
downloadToAdd
)
;
await
addTestDownload
(
downloadToAdd
)
;
await
view
.
waitForExpected
(
)
;
let
sessionDownloadToAdd
=
{
offset
:
0
inSession
:
true
succeeded
:
true
}
;
view
.
expected
.
push
(
sessionDownloadToAdd
)
;
await
addTestDownload
(
sessionDownloadToAdd
)
;
await
view
.
waitForExpected
(
)
;
view
.
expected
.
push
(
sessionDownloadToAdd
)
;
await
publicList
.
add
(
await
Downloads
.
createDownload
(
sessionDownloadToAdd
)
)
;
await
view
.
waitForExpected
(
)
;
let
allHistoryList
=
await
DownloadHistory
.
getList
(
{
type
:
Downloads
.
ALL
}
)
;
let
allView
=
new
TestView
(
view
.
expected
)
;
await
allHistoryList
.
addView
(
allView
)
;
await
allView
.
waitForExpected
(
)
;
let
privateDownloadToAdd
=
{
offset
:
NEXT_OFFSET
+
10
inSession
:
true
succeeded
:
true
isPrivate
:
true
}
;
allView
.
expected
.
push
(
privateDownloadToAdd
)
;
await
addTestDownload
(
privateDownloadToAdd
)
;
await
view
.
waitForExpected
(
)
;
await
allView
.
waitForExpected
(
)
;
let
allHistoryList2
=
await
DownloadHistory
.
getList
(
{
type
:
Downloads
.
ALL
maxHistoryResults
:
3
}
)
;
let
allView2
=
new
TestView
(
allView
.
expected
.
slice
(
3
)
)
;
await
allHistoryList2
.
addView
(
allView2
)
;
await
allView2
.
waitForExpected
(
)
;
view
.
expected
=
view
.
expected
.
filter
(
d
=
>
d
.
hasPartialData
)
;
allView
.
expected
=
allView
.
expected
.
filter
(
d
=
>
d
.
hasPartialData
|
|
d
.
isPrivate
)
;
await
PlacesUtils
.
history
.
clear
(
)
;
await
view
.
waitForExpected
(
)
;
await
allView
.
waitForExpected
(
)
;
}
)
;
