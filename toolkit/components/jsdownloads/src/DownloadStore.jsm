"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
DownloadStore
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gTextDecoder
"
function
(
)
{
return
new
TextDecoder
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gTextEncoder
"
function
(
)
{
return
new
TextEncoder
(
)
;
}
)
;
this
.
DownloadStore
=
function
(
aList
aPath
)
{
this
.
list
=
aList
;
this
.
path
=
aPath
;
}
;
this
.
DownloadStore
.
prototype
=
{
list
:
null
path
:
"
"
onsaveitem
:
(
)
=
>
true
load
:
function
DS_load
(
)
{
return
(
async
(
)
=
>
{
let
bytes
;
try
{
bytes
=
await
OS
.
File
.
read
(
this
.
path
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
OS
.
File
.
Error
)
|
|
!
ex
.
becauseNoSuchFile
)
{
throw
ex
;
}
return
;
}
let
storeData
=
JSON
.
parse
(
gTextDecoder
.
decode
(
bytes
)
)
;
for
(
let
downloadData
of
storeData
.
list
)
{
try
{
let
download
=
await
Downloads
.
createDownload
(
downloadData
)
;
try
{
if
(
!
download
.
succeeded
&
&
!
download
.
canceled
&
&
!
download
.
error
)
{
download
.
start
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
else
{
await
download
.
refresh
(
)
;
}
}
finally
{
await
this
.
list
.
add
(
download
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
)
(
)
;
}
save
:
function
DS_save
(
)
{
return
(
async
(
)
=
>
{
let
downloads
=
await
this
.
list
.
getAll
(
)
;
let
storeData
=
{
list
:
[
]
}
;
let
atLeastOneDownload
=
false
;
for
(
let
download
of
downloads
)
{
try
{
if
(
!
this
.
onsaveitem
(
download
)
)
{
continue
;
}
let
serializable
=
download
.
toSerializable
(
)
;
if
(
!
serializable
)
{
continue
;
}
storeData
.
list
.
push
(
serializable
)
;
atLeastOneDownload
=
true
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
if
(
atLeastOneDownload
)
{
let
bytes
=
gTextEncoder
.
encode
(
JSON
.
stringify
(
storeData
)
)
;
await
OS
.
File
.
writeAtomic
(
this
.
path
bytes
{
tmpPath
:
this
.
path
+
"
.
tmp
"
}
)
;
}
else
{
try
{
await
OS
.
File
.
remove
(
this
.
path
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
OS
.
File
.
Error
)
|
|
!
(
ex
.
becauseNoSuchFile
|
|
ex
.
becauseAccessDenied
)
)
{
throw
ex
;
}
}
}
}
)
(
)
;
}
}
;
