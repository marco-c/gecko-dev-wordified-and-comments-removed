"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
DownloadHistory
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
DownloadList
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
HISTORY_PLACES_QUERY
=
"
place
:
transition
=
"
+
Ci
.
nsINavHistoryService
.
TRANSITION_DOWNLOAD
+
"
&
sort
=
"
+
Ci
.
nsINavHistoryQueryOptions
.
SORT_BY_DATE_DESCENDING
;
const
DESTINATIONFILEURI_ANNO
=
"
downloads
/
destinationFileURI
"
;
const
METADATA_ANNO
=
"
downloads
/
metaData
"
;
const
METADATA_STATE_FINISHED
=
1
;
const
METADATA_STATE_FAILED
=
2
;
const
METADATA_STATE_CANCELED
=
3
;
const
METADATA_STATE_PAUSED
=
4
;
const
METADATA_STATE_BLOCKED_PARENTAL
=
6
;
const
METADATA_STATE_DIRTY
=
8
;
this
.
DownloadHistory
=
{
getList
(
{
type
=
Downloads
.
PUBLIC
maxHistoryResults
}
=
{
}
)
{
let
key
=
{
type
}
|
{
maxHistoryResults
?
maxHistoryResults
:
-
1
}
;
if
(
!
this
.
_listPromises
[
key
]
)
{
this
.
_listPromises
[
key
]
=
Downloads
.
getList
(
type
)
.
then
(
list
=
>
{
let
query
=
HISTORY_PLACES_QUERY
+
(
maxHistoryResults
?
"
&
maxResults
=
"
+
maxHistoryResults
:
"
"
)
;
return
new
DownloadHistoryList
(
list
query
)
;
}
)
;
}
return
this
.
_listPromises
[
key
]
;
}
_listPromises
:
{
}
updateMetaData
(
download
)
{
if
(
download
.
source
.
isPrivate
|
|
!
download
.
stopped
)
{
return
;
}
let
state
=
METADATA_STATE_CANCELED
;
if
(
download
.
succeeded
)
{
state
=
METADATA_STATE_FINISHED
;
}
else
if
(
download
.
error
)
{
if
(
download
.
error
.
becauseBlockedByParentalControls
)
{
state
=
METADATA_STATE_BLOCKED_PARENTAL
;
}
else
if
(
download
.
error
.
becauseBlockedByReputationCheck
)
{
state
=
METADATA_STATE_DIRTY
;
}
else
{
state
=
METADATA_STATE_FAILED
;
}
}
let
metaData
=
{
state
endTime
:
download
.
endTime
}
;
if
(
download
.
succeeded
)
{
metaData
.
fileSize
=
download
.
target
.
size
;
}
if
(
download
.
error
&
&
download
.
error
.
reputationCheckVerdict
)
{
metaData
.
reputationCheckVerdict
=
download
.
error
.
reputationCheckVerdict
;
}
try
{
PlacesUtils
.
annotations
.
setPageAnnotation
(
Services
.
io
.
newURI
(
download
.
source
.
url
)
METADATA_ANNO
JSON
.
stringify
(
metaData
)
0
PlacesUtils
.
annotations
.
EXPIRE_WITH_HISTORY
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
getPlacesMetaDataFor
(
spec
)
{
let
metaData
=
{
}
;
try
{
let
uri
=
Services
.
io
.
newURI
(
spec
)
;
try
{
metaData
=
JSON
.
parse
(
PlacesUtils
.
annotations
.
getPageAnnotation
(
uri
METADATA_ANNO
)
)
;
}
catch
(
ex
)
{
}
metaData
.
targetFileSpec
=
PlacesUtils
.
annotations
.
getPageAnnotation
(
uri
DESTINATIONFILEURI_ANNO
)
;
}
catch
(
ex
)
{
}
return
metaData
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gCachedPlacesMetaData
"
function
(
)
{
let
placesMetaData
=
new
Map
(
)
;
for
(
let
result
of
PlacesUtils
.
annotations
.
getAnnotationsWithName
(
METADATA_ANNO
)
)
{
try
{
placesMetaData
.
set
(
result
.
uri
.
spec
JSON
.
parse
(
result
.
annotationValue
)
)
;
}
catch
(
ex
)
{
}
}
for
(
let
result
of
PlacesUtils
.
annotations
.
getAnnotationsWithName
(
DESTINATIONFILEURI_ANNO
)
)
{
let
metaData
=
placesMetaData
.
get
(
result
.
uri
.
spec
)
;
if
(
!
metaData
)
{
metaData
=
{
}
;
placesMetaData
.
set
(
result
.
uri
.
spec
metaData
)
;
}
metaData
.
targetFileSpec
=
result
.
annotationValue
;
}
return
placesMetaData
;
}
)
;
function
HistoryDownload
(
placesNode
)
{
this
.
placesNode
=
placesNode
;
this
.
source
=
{
url
:
placesNode
.
uri
isPrivate
:
false
}
;
this
.
target
=
{
path
:
undefined
exists
:
false
size
:
undefined
}
;
this
.
endTime
=
placesNode
.
time
/
1000
;
}
HistoryDownload
.
prototype
=
{
slot
:
null
updateFromMetaData
(
metaData
)
{
try
{
this
.
target
.
path
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
file
"
]
.
getService
(
Ci
.
nsIFileProtocolHandler
)
.
getFileFromURLSpec
(
metaData
.
targetFileSpec
)
.
path
;
}
catch
(
ex
)
{
this
.
target
.
path
=
undefined
;
}
if
(
"
state
"
in
metaData
)
{
this
.
succeeded
=
metaData
.
state
=
=
METADATA_STATE_FINISHED
;
this
.
canceled
=
metaData
.
state
=
=
METADATA_STATE_CANCELED
|
|
metaData
.
state
=
=
METADATA_STATE_PAUSED
;
this
.
endTime
=
metaData
.
endTime
;
if
(
metaData
.
state
=
=
METADATA_STATE_FAILED
)
{
this
.
error
=
{
message
:
"
History
download
failed
.
"
}
;
}
else
if
(
metaData
.
state
=
=
METADATA_STATE_BLOCKED_PARENTAL
)
{
this
.
error
=
{
becauseBlockedByParentalControls
:
true
}
;
}
else
if
(
metaData
.
state
=
=
METADATA_STATE_DIRTY
)
{
this
.
error
=
{
becauseBlockedByReputationCheck
:
true
reputationCheckVerdict
:
metaData
.
reputationCheckVerdict
|
|
"
"
}
;
}
else
{
this
.
error
=
null
;
}
this
.
target
.
exists
=
true
;
this
.
target
.
size
=
metaData
.
fileSize
;
}
else
{
this
.
succeeded
=
!
this
.
target
.
path
;
this
.
error
=
this
.
target
.
path
?
{
message
:
"
Unstarted
download
.
"
}
:
null
;
this
.
canceled
=
false
;
this
.
target
.
exists
=
false
;
this
.
target
.
size
=
undefined
;
}
}
stopped
:
true
hasProgress
:
false
hasPartialData
:
false
async
finalize
(
)
{
}
async
refresh
(
)
{
try
{
this
.
target
.
size
=
(
await
OS
.
File
.
stat
(
this
.
target
.
path
)
)
.
size
;
this
.
target
.
exists
=
true
;
}
catch
(
ex
)
{
this
.
target
.
exists
=
false
;
}
this
.
slot
.
list
.
_notifyAllViews
(
"
onDownloadChanged
"
this
)
;
}
}
;
function
DownloadSlot
(
list
)
{
this
.
list
=
list
;
}
DownloadSlot
.
prototype
=
{
list
:
null
sessionDownload
:
null
get
historyDownload
(
)
{
return
this
.
_historyDownload
;
}
set
historyDownload
(
historyDownload
)
{
this
.
_historyDownload
=
historyDownload
;
if
(
historyDownload
)
{
historyDownload
.
slot
=
this
;
}
}
_historyDownload
:
null
get
download
(
)
{
return
this
.
sessionDownload
|
|
this
.
historyDownload
;
}
}
;
this
.
DownloadHistoryList
=
function
(
publicList
place
)
{
DownloadList
.
call
(
this
)
;
this
.
_slots
=
[
]
;
this
.
_slotsForUrl
=
new
Map
(
)
;
this
.
_slotForDownload
=
new
WeakMap
(
)
;
publicList
.
addView
(
this
)
.
catch
(
Cu
.
reportError
)
;
let
queries
=
{
}
options
=
{
}
;
PlacesUtils
.
history
.
queryStringToQueries
(
place
queries
{
}
options
)
;
if
(
!
queries
.
value
.
length
)
{
queries
.
value
=
[
PlacesUtils
.
history
.
getNewQuery
(
)
]
;
}
let
result
=
PlacesUtils
.
history
.
executeQueries
(
queries
.
value
queries
.
value
.
length
options
.
value
)
;
result
.
addObserver
(
this
)
;
}
;
this
.
DownloadHistoryList
.
prototype
=
{
__proto__
:
DownloadList
.
prototype
get
result
(
)
{
return
this
.
_result
;
}
set
result
(
result
)
{
if
(
this
.
_result
=
=
result
)
{
return
;
}
if
(
this
.
_result
)
{
PlacesUtils
.
annotations
.
removeObserver
(
this
)
;
this
.
_result
.
removeObserver
(
this
)
;
this
.
_result
.
root
.
containerOpen
=
false
;
}
this
.
_result
=
result
;
if
(
this
.
_result
)
{
this
.
_result
.
root
.
containerOpen
=
true
;
PlacesUtils
.
annotations
.
addObserver
(
this
)
;
}
}
_result
:
null
_firstSessionSlotIndex
:
0
_insertSlot
(
{
slot
index
slotsForUrl
}
)
{
this
.
_slots
.
splice
(
index
0
slot
)
;
this
.
_downloads
.
splice
(
index
0
slot
.
download
)
;
if
(
!
slot
.
sessionDownload
)
{
this
.
_firstSessionSlotIndex
+
+
;
}
slotsForUrl
.
add
(
slot
)
;
this
.
_slotsForUrl
.
set
(
slot
.
download
.
source
.
url
slotsForUrl
)
;
this
.
_notifyAllViews
(
"
onDownloadAdded
"
slot
.
download
{
insertBefore
:
this
.
_downloads
[
index
+
1
]
}
)
;
}
_removeSlot
(
{
slot
slotsForUrl
}
)
{
let
index
=
this
.
_slots
.
indexOf
(
slot
)
;
this
.
_slots
.
splice
(
index
1
)
;
this
.
_downloads
.
splice
(
index
1
)
;
if
(
this
.
_firstSessionSlotIndex
>
index
)
{
this
.
_firstSessionSlotIndex
-
-
;
}
slotsForUrl
.
delete
(
slot
)
;
if
(
slotsForUrl
.
size
=
=
0
)
{
this
.
_slotsForUrl
.
delete
(
slot
.
download
.
source
.
url
)
;
}
this
.
_notifyAllViews
(
"
onDownloadRemoved
"
slot
.
download
)
;
}
_insertPlacesNode
(
placesNode
)
{
let
slotsForUrl
=
this
.
_slotsForUrl
.
get
(
placesNode
.
uri
)
|
|
new
Set
(
)
;
if
(
slotsForUrl
.
size
>
0
)
{
for
(
let
slot
of
slotsForUrl
)
{
if
(
!
slot
.
historyDownload
)
{
slot
.
historyDownload
=
new
HistoryDownload
(
placesNode
)
;
}
else
{
slot
.
historyDownload
.
placesNode
=
placesNode
;
}
}
return
;
}
let
historyDownload
=
new
HistoryDownload
(
placesNode
)
;
historyDownload
.
updateFromMetaData
(
gCachedPlacesMetaData
.
get
(
placesNode
.
uri
)
|
|
DownloadHistory
.
getPlacesMetaDataFor
(
placesNode
.
uri
)
)
;
let
slot
=
new
DownloadSlot
(
this
)
;
slot
.
historyDownload
=
historyDownload
;
this
.
_insertSlot
(
{
slot
slotsForUrl
index
:
this
.
_firstSessionSlotIndex
}
)
;
}
containerStateChanged
(
node
oldState
newState
)
{
this
.
invalidateContainer
(
node
)
;
}
invalidateContainer
(
container
)
{
this
.
_notifyAllViews
(
"
onDownloadBatchStarting
"
)
;
for
(
let
index
=
this
.
_slots
.
length
-
1
;
index
>
=
0
;
index
-
-
)
{
let
slot
=
this
.
_slots
[
index
]
;
if
(
slot
.
sessionDownload
)
{
slot
.
historyDownload
=
null
;
}
else
{
let
slotsForUrl
=
this
.
_slotsForUrl
.
get
(
slot
.
download
.
source
.
url
)
;
this
.
_removeSlot
(
{
slot
slotsForUrl
}
)
;
}
}
for
(
let
index
=
container
.
childCount
-
1
;
index
>
=
0
;
-
-
index
)
{
try
{
this
.
_insertPlacesNode
(
container
.
getChild
(
index
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
this
.
_notifyAllViews
(
"
onDownloadBatchEnded
"
)
;
}
nodeInserted
(
parent
placesNode
)
{
this
.
_insertPlacesNode
(
placesNode
)
;
}
nodeRemoved
(
parent
placesNode
aOldIndex
)
{
let
slotsForUrl
=
this
.
_slotsForUrl
.
get
(
placesNode
.
uri
)
;
for
(
let
slot
of
slotsForUrl
)
{
if
(
slot
.
sessionDownload
)
{
slot
.
historyDownload
=
null
;
}
else
{
this
.
_removeSlot
(
{
slot
slotsForUrl
}
)
;
}
}
}
nodeAnnotationChanged
(
)
{
}
nodeIconChanged
(
)
{
}
nodeTitleChanged
(
)
{
}
nodeKeywordChanged
(
)
{
}
nodeDateAddedChanged
(
)
{
}
nodeLastModifiedChanged
(
)
{
}
nodeHistoryDetailsChanged
(
)
{
}
nodeTagsChanged
(
)
{
}
sortingChanged
(
)
{
}
nodeMoved
(
)
{
}
nodeURIChanged
(
)
{
}
batching
(
)
{
}
onPageAnnotationSet
(
page
name
)
{
if
(
name
!
=
DESTINATIONFILEURI_ANNO
&
&
name
!
=
METADATA_ANNO
)
{
return
;
}
let
slotsForUrl
=
this
.
_slotsForUrl
.
get
(
page
.
spec
)
;
if
(
!
slotsForUrl
)
{
return
;
}
for
(
let
slot
of
slotsForUrl
)
{
if
(
slot
.
sessionDownload
)
{
return
;
}
slot
.
historyDownload
.
updateFromMetaData
(
DownloadHistory
.
getPlacesMetaDataFor
(
page
.
spec
)
)
;
this
.
_notifyAllViews
(
"
onDownloadChanged
"
slot
.
download
)
;
}
}
onItemAnnotationSet
(
)
{
}
onPageAnnotationRemoved
(
)
{
}
onItemAnnotationRemoved
(
)
{
}
onDownloadAdded
(
download
)
{
let
url
=
download
.
source
.
url
;
let
slotsForUrl
=
this
.
_slotsForUrl
.
get
(
url
)
|
|
new
Set
(
)
;
gCachedPlacesMetaData
.
delete
(
url
)
;
let
slot
=
[
.
.
.
slotsForUrl
]
[
0
]
;
if
(
slot
&
&
!
slot
.
sessionDownload
)
{
this
.
_removeSlot
(
{
slot
slotsForUrl
}
)
;
}
else
{
slot
=
new
DownloadSlot
(
this
)
;
}
slot
.
sessionDownload
=
download
;
this
.
_insertSlot
(
{
slot
slotsForUrl
index
:
this
.
_slots
.
length
}
)
;
this
.
_slotForDownload
.
set
(
download
slot
)
;
}
onDownloadChanged
(
download
)
{
let
slot
=
this
.
_slotForDownload
.
get
(
download
)
;
this
.
_notifyAllViews
(
"
onDownloadChanged
"
slot
.
download
)
;
}
onDownloadRemoved
(
download
)
{
let
url
=
download
.
source
.
url
;
let
slotsForUrl
=
this
.
_slotsForUrl
.
get
(
url
)
;
let
slot
=
this
.
_slotForDownload
.
get
(
download
)
;
this
.
_removeSlot
(
{
slot
slotsForUrl
}
)
;
if
(
slotsForUrl
.
size
=
=
0
&
&
slot
.
historyDownload
)
{
slot
.
historyDownload
.
updateFromMetaData
(
DownloadHistory
.
getPlacesMetaDataFor
(
url
)
)
;
slot
.
sessionDownload
=
null
;
this
.
_insertSlot
(
{
slot
slotsForUrl
index
:
this
.
_firstSessionSlotIndex
}
)
;
}
this
.
_slotForDownload
.
delete
(
download
)
;
}
add
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
remove
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
removeFinished
(
)
{
throw
new
Error
(
"
Not
implemented
.
"
)
;
}
}
;
