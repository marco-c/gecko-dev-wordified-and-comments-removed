"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DownloadList
"
"
DownloadCombinedList
"
"
DownloadSummary
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
DownloadList
=
function
(
)
{
this
.
_downloads
=
[
]
;
this
.
_views
=
new
Set
(
)
;
}
;
this
.
DownloadList
.
prototype
=
{
_downloads
:
null
getAll
:
function
DL_getAll
(
)
{
return
Promise
.
resolve
(
Array
.
slice
(
this
.
_downloads
0
)
)
;
}
add
:
function
DL_add
(
aDownload
)
{
this
.
_downloads
.
push
(
aDownload
)
;
aDownload
.
onchange
=
this
.
_change
.
bind
(
this
aDownload
)
;
this
.
_notifyAllViews
(
"
onDownloadAdded
"
aDownload
)
;
return
Promise
.
resolve
(
)
;
}
remove
:
function
DL_remove
(
aDownload
)
{
let
index
=
this
.
_downloads
.
indexOf
(
aDownload
)
;
if
(
index
!
=
-
1
)
{
this
.
_downloads
.
splice
(
index
1
)
;
aDownload
.
onchange
=
null
;
this
.
_notifyAllViews
(
"
onDownloadRemoved
"
aDownload
)
;
}
return
Promise
.
resolve
(
)
;
}
_change
:
function
DL_change
(
aDownload
)
{
this
.
_notifyAllViews
(
"
onDownloadChanged
"
aDownload
)
;
}
_views
:
null
addView
:
function
DL_addView
(
aView
)
{
this
.
_views
.
add
(
aView
)
;
if
(
"
onDownloadAdded
"
in
aView
)
{
this
.
_notifyAllViews
(
"
onDownloadBatchStarting
"
)
;
for
(
let
download
of
this
.
_downloads
)
{
try
{
aView
.
onDownloadAdded
(
download
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
this
.
_notifyAllViews
(
"
onDownloadBatchEnded
"
)
;
}
return
Promise
.
resolve
(
)
;
}
removeView
:
function
DL_removeView
(
aView
)
{
this
.
_views
.
delete
(
aView
)
;
return
Promise
.
resolve
(
)
;
}
_notifyAllViews
(
methodName
.
.
.
args
)
{
for
(
let
view
of
this
.
_views
)
{
try
{
if
(
methodName
in
view
)
{
view
[
methodName
]
(
.
.
.
args
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
removeFinished
:
function
DL_removeFinished
(
aFilterFn
)
{
(
async
(
)
=
>
{
let
list
=
await
this
.
getAll
(
)
;
for
(
let
download
of
list
)
{
if
(
download
.
stopped
&
&
(
!
download
.
hasPartialData
|
|
download
.
error
)
&
&
(
!
aFilterFn
|
|
aFilterFn
(
download
)
)
)
{
await
this
.
remove
(
download
)
;
download
.
finalize
(
true
)
.
catch
(
Cu
.
reportError
)
;
}
}
}
)
(
)
.
catch
(
Cu
.
reportError
)
;
}
}
;
var
DownloadCombinedList
=
function
(
aPublicList
aPrivateList
)
{
DownloadList
.
call
(
this
)
;
this
.
_publicList
=
aPublicList
;
this
.
_privateList
=
aPrivateList
;
aPublicList
.
addView
(
this
)
.
catch
(
Cu
.
reportError
)
;
aPrivateList
.
addView
(
this
)
.
catch
(
Cu
.
reportError
)
;
}
;
this
.
DownloadCombinedList
.
prototype
=
{
__proto__
:
DownloadList
.
prototype
_publicList
:
null
_privateList
:
null
add
(
aDownload
)
{
if
(
aDownload
.
source
.
isPrivate
)
{
return
this
.
_privateList
.
add
(
aDownload
)
;
}
return
this
.
_publicList
.
add
(
aDownload
)
;
}
remove
(
aDownload
)
{
if
(
aDownload
.
source
.
isPrivate
)
{
return
this
.
_privateList
.
remove
(
aDownload
)
;
}
return
this
.
_publicList
.
remove
(
aDownload
)
;
}
onDownloadAdded
(
aDownload
)
{
this
.
_downloads
.
push
(
aDownload
)
;
this
.
_notifyAllViews
(
"
onDownloadAdded
"
aDownload
)
;
}
onDownloadChanged
(
aDownload
)
{
this
.
_notifyAllViews
(
"
onDownloadChanged
"
aDownload
)
;
}
onDownloadRemoved
(
aDownload
)
{
let
index
=
this
.
_downloads
.
indexOf
(
aDownload
)
;
if
(
index
!
=
-
1
)
{
this
.
_downloads
.
splice
(
index
1
)
;
}
this
.
_notifyAllViews
(
"
onDownloadRemoved
"
aDownload
)
;
}
}
;
var
DownloadSummary
=
function
(
)
{
this
.
_downloads
=
[
]
;
this
.
_views
=
new
Set
(
)
;
}
;
this
.
DownloadSummary
.
prototype
=
{
_downloads
:
null
_list
:
null
bindToList
(
aList
)
{
if
(
this
.
_list
)
{
throw
new
Error
(
"
bindToList
may
be
called
only
once
.
"
)
;
}
return
aList
.
addView
(
this
)
.
then
(
(
)
=
>
{
this
.
_list
=
aList
;
this
.
_onListChanged
(
)
;
}
)
;
}
_views
:
null
addView
(
aView
)
{
this
.
_views
.
add
(
aView
)
;
if
(
"
onSummaryChanged
"
in
aView
)
{
try
{
aView
.
onSummaryChanged
(
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
return
Promise
.
resolve
(
)
;
}
removeView
(
aView
)
{
this
.
_views
.
delete
(
aView
)
;
return
Promise
.
resolve
(
)
;
}
allHaveStopped
:
true
progressTotalBytes
:
0
progressCurrentBytes
:
0
_onListChanged
(
)
{
let
allHaveStopped
=
true
;
let
progressTotalBytes
=
0
;
let
progressCurrentBytes
=
0
;
for
(
let
download
of
this
.
_downloads
)
{
if
(
!
download
.
stopped
)
{
allHaveStopped
=
false
;
progressTotalBytes
+
=
download
.
hasProgress
?
download
.
totalBytes
:
download
.
currentBytes
;
progressCurrentBytes
+
=
download
.
currentBytes
;
}
}
if
(
this
.
allHaveStopped
=
=
allHaveStopped
&
&
this
.
progressTotalBytes
=
=
progressTotalBytes
&
&
this
.
progressCurrentBytes
=
=
progressCurrentBytes
)
{
return
;
}
this
.
allHaveStopped
=
allHaveStopped
;
this
.
progressTotalBytes
=
progressTotalBytes
;
this
.
progressCurrentBytes
=
progressCurrentBytes
;
for
(
let
view
of
this
.
_views
)
{
try
{
if
(
"
onSummaryChanged
"
in
view
)
{
view
.
onSummaryChanged
(
)
;
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
onDownloadAdded
(
aDownload
)
{
this
.
_downloads
.
push
(
aDownload
)
;
if
(
this
.
_list
)
{
this
.
_onListChanged
(
)
;
}
}
onDownloadChanged
(
aDownload
)
{
this
.
_onListChanged
(
)
;
}
onDownloadRemoved
(
aDownload
)
{
let
index
=
this
.
_downloads
.
indexOf
(
aDownload
)
;
if
(
index
!
=
-
1
)
{
this
.
_downloads
.
splice
(
index
1
)
;
}
this
.
_onListChanged
(
)
;
}
}
;
