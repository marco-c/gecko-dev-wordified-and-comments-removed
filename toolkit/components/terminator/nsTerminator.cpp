#
include
"
mozilla
/
ShutdownPhase
.
h
"
#
include
"
nsTerminator
.
h
"
#
include
"
prthread
.
h
"
#
include
"
prmon
.
h
"
#
include
"
prio
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntentionalCrash
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
IOUtils
.
h
"
#
include
"
mozilla
/
dom
/
workerinternals
/
RuntimeService
.
h
"
#
define
FALLBACK_ASYNCSHUTDOWN_CRASH_AFTER_MS
60000
#
define
ADDITIONAL_WAIT_BEFORE_CRASH_MS
3000
#
define
HEARTBEAT_INTERVAL_MS
100
namespace
mozilla
{
namespace
{
struct
ShutdownStep
{
mozilla
:
:
ShutdownPhase
mPhase
;
Atomic
<
int
>
mTicks
;
constexpr
explicit
ShutdownStep
(
mozilla
:
:
ShutdownPhase
aPhase
)
:
mPhase
(
aPhase
)
mTicks
(
-
1
)
{
}
}
;
static
ShutdownStep
sShutdownSteps
[
]
=
{
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownConfirmed
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownNetTeardown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownTeardown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownQM
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMWillShutdown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdownThreads
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdownFinal
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
CCPostLastCycleCollection
)
}
;
int
GetStepForPhase
(
mozilla
:
:
ShutdownPhase
aPhase
)
{
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
sShutdownSteps
)
;
i
+
+
)
{
if
(
sShutdownSteps
[
i
]
.
mPhase
>
=
aPhase
)
{
return
(
int
)
i
;
}
}
return
-
1
;
}
PRThread
*
CreateSystemThread
(
void
(
*
start
)
(
void
*
arg
)
void
*
arg
)
{
PRThread
*
thread
=
PR_CreateThread
(
PR_SYSTEM_THREAD
start
arg
PR_PRIORITY_LOW
PR_GLOBAL_THREAD
PR_UNJOINABLE_THREAD
0
)
;
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
thread
)
;
return
thread
;
}
Atomic
<
uint32_t
>
gHeartbeat
(
0
)
;
struct
Options
{
uint32_t
crashAfterTicks
;
}
;
void
RunWatchdog
(
void
*
arg
)
{
NS_SetCurrentThreadName
(
"
Shutdown
Hang
Terminator
"
)
;
UniquePtr
<
Options
>
options
(
(
Options
*
)
arg
)
;
uint32_t
crashAfterTicks
=
options
-
>
crashAfterTicks
;
options
=
nullptr
;
const
uint32_t
timeToLive
=
crashAfterTicks
;
while
(
true
)
{
#
if
defined
(
XP_WIN
)
Sleep
(
HEARTBEAT_INTERVAL_MS
)
;
#
else
usleep
(
HEARTBEAT_INTERVAL_MS
*
1000
)
;
#
endif
if
(
gHeartbeat
+
+
<
timeToLive
)
{
continue
;
}
NoteIntentionalCrash
(
XRE_GetProcessTypeString
(
)
)
;
nsCString
stack
;
AutoNestedEventLoopAnnotation
:
:
CopyCurrentStack
(
stack
)
;
printf_stderr
(
"
RunWatchdog
:
Mainthread
nested
event
loops
during
hang
:
\
n
-
-
-
%
s
\
n
"
stack
.
get
(
)
)
;
mozilla
:
:
ShutdownPhase
lastPhase
=
mozilla
:
:
ShutdownPhase
:
:
NotInShutdown
;
for
(
int
i
=
ArrayLength
(
sShutdownSteps
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
sShutdownSteps
[
i
]
.
mTicks
>
-
1
)
{
lastPhase
=
sShutdownSteps
[
i
]
.
mPhase
;
break
;
}
}
if
(
lastPhase
=
=
mozilla
:
:
ShutdownPhase
:
:
NotInShutdown
)
{
CrashReporter
:
:
SetMinidumpAnalysisAllThreads
(
)
;
MOZ_CRASH
(
"
Shutdown
hanging
before
starting
any
known
phase
.
"
)
;
}
mozilla
:
:
dom
:
:
workerinternals
:
:
RuntimeService
*
runtimeService
=
mozilla
:
:
dom
:
:
workerinternals
:
:
RuntimeService
:
:
GetService
(
)
;
if
(
runtimeService
)
{
runtimeService
-
>
CrashIfHanging
(
)
;
}
nsCString
msg
;
msg
.
AppendPrintf
(
"
Shutdown
hanging
at
step
%
s
.
"
"
Something
is
blocking
the
main
-
thread
.
"
mozilla
:
:
AppShutdown
:
:
GetShutdownPhaseName
(
lastPhase
)
)
;
CrashReporter
:
:
SetMinidumpAnalysisAllThreads
(
)
;
MOZ_CRASH_UNSAFE
(
strdup
(
msg
.
BeginReading
(
)
)
)
;
}
}
Atomic
<
nsCString
*
>
gWriteData
(
nullptr
)
;
PRMonitor
*
gWriteReady
=
nullptr
;
void
RunWriter
(
void
*
arg
)
{
AUTO_PROFILER_REGISTER_THREAD
(
"
Shutdown
Statistics
Writer
"
)
;
NS_SetCurrentThreadName
(
"
Shutdown
Statistics
Writer
"
)
;
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
arg
)
;
nsCString
destinationPath
;
destinationPath
.
Adopt
(
static_cast
<
char
*
>
(
arg
)
)
;
nsAutoCString
tmpFilePath
;
tmpFilePath
.
Append
(
destinationPath
)
;
tmpFilePath
.
AppendLiteral
(
"
.
tmp
"
)
;
Unused
<
<
PR_Delete
(
tmpFilePath
.
get
(
)
)
;
Unused
<
<
PR_Delete
(
destinationPath
.
get
(
)
)
;
while
(
true
)
{
UniquePtr
<
nsCString
>
data
(
gWriteData
.
exchange
(
nullptr
)
)
;
if
(
!
data
)
{
PR_EnterMonitor
(
gWriteReady
)
;
PR_Wait
(
gWriteReady
PR_INTERVAL_NO_TIMEOUT
)
;
PR_ExitMonitor
(
gWriteReady
)
;
continue
;
}
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
data
.
get
(
)
)
;
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
tmpFileDesc
(
PR_Open
(
tmpFilePath
.
get
(
)
PR_WRONLY
|
PR_TRUNCATE
|
PR_CREATE_FILE
00600
)
)
;
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
tmpFileDesc
.
get
(
)
)
;
if
(
tmpFileDesc
=
=
nullptr
)
{
break
;
}
if
(
PR_Write
(
tmpFileDesc
.
get
(
)
data
-
>
get
(
)
data
-
>
Length
(
)
)
=
=
-
1
)
{
break
;
}
tmpFileDesc
.
reset
(
)
;
Unused
<
<
PR_Delete
(
destinationPath
.
get
(
)
)
;
if
(
PR_Rename
(
tmpFilePath
.
get
(
)
destinationPath
.
get
(
)
)
!
=
PR_SUCCESS
)
{
break
;
}
}
}
}
NS_IMPL_ISUPPORTS
(
nsTerminator
nsIObserver
)
nsTerminator
:
:
nsTerminator
(
)
:
mInitialized
(
false
)
mCurrentStep
(
-
1
)
{
}
void
nsTerminator
:
:
Start
(
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
StartWatchdog
(
)
;
#
if
!
defined
(
NS_FREE_PERMANENT_DATA
)
StartWriter
(
)
;
#
endif
mInitialized
=
true
;
}
NS_IMETHODIMP
nsTerminator
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
if
(
strcmp
(
aTopic
"
terminator
-
test
-
quit
-
application
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownConfirmed
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
change
-
net
-
teardown
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownNetTeardown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
change
-
teardown
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownTeardown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
before
-
change
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
before
-
change
-
qm
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownQM
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
before
-
change
-
telemetry
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownTelemetry
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
xpcom
-
will
-
shutdown
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMWillShutdown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
xpcom
-
shutdown
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
xpcom
-
shutdown
-
threads
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdownThreads
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
XPCOMShutdownFinal
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdownFinal
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
CCPostLastCycleCollection
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
CCPostLastCycleCollection
)
;
}
return
NS_OK
;
}
void
nsTerminator
:
:
StartWatchdog
(
)
{
int32_t
crashAfterMS
=
Preferences
:
:
GetInt
(
"
toolkit
.
asyncshutdown
.
crash_timeout
"
FALLBACK_ASYNCSHUTDOWN_CRASH_AFTER_MS
)
;
if
(
crashAfterMS
<
=
0
)
{
crashAfterMS
=
FALLBACK_ASYNCSHUTDOWN_CRASH_AFTER_MS
;
}
if
(
crashAfterMS
>
INT32_MAX
-
ADDITIONAL_WAIT_BEFORE_CRASH_MS
)
{
crashAfterMS
=
INT32_MAX
;
}
else
{
crashAfterMS
+
=
ADDITIONAL_WAIT_BEFORE_CRASH_MS
;
}
#
ifdef
MOZ_VALGRIND
if
(
RUNNING_ON_VALGRIND
)
{
const
int32_t
scaleUp
=
3
;
if
(
crashAfterMS
>
=
(
INT32_MAX
/
scaleUp
)
-
1
)
{
crashAfterMS
=
INT32_MAX
;
}
else
{
crashAfterMS
*
=
scaleUp
;
}
}
#
endif
UniquePtr
<
Options
>
options
(
new
Options
(
)
)
;
options
-
>
crashAfterTicks
=
crashAfterMS
/
HEARTBEAT_INTERVAL_MS
;
DebugOnly
<
PRThread
*
>
watchdogThread
=
CreateSystemThread
(
RunWatchdog
options
.
release
(
)
)
;
MOZ_ASSERT
(
watchdogThread
)
;
}
void
nsTerminator
:
:
StartWriter
(
)
{
if
(
!
Telemetry
:
:
CanRecordExtended
(
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
profLD
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_LOCAL_50_DIR
getter_AddRefs
(
profLD
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
profLD
-
>
Append
(
u
"
ShutdownDuration
.
json
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsAutoString
path
;
rv
=
profLD
-
>
GetPath
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
gWriteReady
=
PR_NewMonitor
(
)
;
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
gWriteReady
)
;
PRThread
*
writerThread
=
CreateSystemThread
(
RunWriter
ToNewUTF8String
(
path
)
)
;
if
(
!
writerThread
)
{
return
;
}
}
const
char
*
GetReadableNameForPhase
(
mozilla
:
:
ShutdownPhase
aPhase
)
{
const
char
*
readableName
=
mozilla
:
:
AppShutdown
:
:
GetObserverKey
(
aPhase
)
;
if
(
!
readableName
)
{
readableName
=
mozilla
:
:
AppShutdown
:
:
GetShutdownPhaseName
(
aPhase
)
;
}
return
readableName
;
}
void
nsTerminator
:
:
AdvancePhase
(
mozilla
:
:
ShutdownPhase
aPhase
)
{
auto
step
=
GetStepForPhase
(
aPhase
)
;
if
(
step
<
0
)
{
return
;
}
if
(
!
mInitialized
)
{
Start
(
)
;
}
UpdateHeartbeat
(
step
)
;
#
if
!
defined
(
NS_FREE_PERMANENT_DATA
)
UpdateTelemetry
(
)
;
#
endif
UpdateCrashReport
(
GetReadableNameForPhase
(
aPhase
)
)
;
}
void
nsTerminator
:
:
UpdateHeartbeat
(
int32_t
aStep
)
{
MOZ_ASSERT
(
aStep
>
=
mCurrentStep
)
;
if
(
aStep
>
mCurrentStep
)
{
uint32_t
ticks
=
gHeartbeat
.
exchange
(
0
)
;
if
(
mCurrentStep
>
=
0
)
{
sShutdownSteps
[
mCurrentStep
]
.
mTicks
=
ticks
;
}
sShutdownSteps
[
aStep
]
.
mTicks
=
0
;
mCurrentStep
=
aStep
;
}
}
void
nsTerminator
:
:
UpdateTelemetry
(
)
{
if
(
!
Telemetry
:
:
CanRecordExtended
(
)
|
|
!
gWriteReady
)
{
return
;
}
UniquePtr
<
nsCString
>
telemetryData
(
new
nsCString
(
)
)
;
telemetryData
-
>
AppendLiteral
(
"
{
"
)
;
size_t
fields
=
0
;
for
(
auto
&
shutdownStep
:
sShutdownSteps
)
{
if
(
shutdownStep
.
mTicks
<
0
)
{
continue
;
}
if
(
fields
+
+
>
0
)
{
telemetryData
-
>
AppendLiteral
(
"
"
)
;
}
telemetryData
-
>
AppendLiteral
(
R
"
(
"
)
"
)
;
telemetryData
-
>
Append
(
GetReadableNameForPhase
(
shutdownStep
.
mPhase
)
)
;
telemetryData
-
>
AppendLiteral
(
R
"
(
"
:
)
"
)
;
telemetryData
-
>
AppendInt
(
shutdownStep
.
mTicks
)
;
}
telemetryData
-
>
AppendLiteral
(
"
}
"
)
;
if
(
fields
=
=
0
)
{
return
;
}
delete
gWriteData
.
exchange
(
telemetryData
.
release
(
)
)
;
PR_EnterMonitor
(
gWriteReady
)
;
PR_Notify
(
gWriteReady
)
;
PR_ExitMonitor
(
gWriteReady
)
;
}
void
nsTerminator
:
:
UpdateCrashReport
(
const
char
*
aTopic
)
{
CrashReporter
:
:
RecordAnnotationCString
(
CrashReporter
:
:
Annotation
:
:
ShutdownProgress
aTopic
)
;
}
}
