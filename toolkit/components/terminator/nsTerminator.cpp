#
include
"
mozilla
/
ShutdownPhase
.
h
"
#
include
"
nsTerminator
.
h
"
#
include
"
prthread
.
h
"
#
include
"
prmon
.
h
"
#
include
"
prio
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntentionalCrash
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
IOUtils
.
h
"
#
include
"
mozilla
/
dom
/
workerinternals
/
RuntimeService
.
h
"
#
define
FALLBACK_ASYNCSHUTDOWN_CRASH_AFTER_MS
60000
#
define
ADDITIONAL_WAIT_BEFORE_CRASH_MS
3000
#
define
HEARTBEAT_INTERVAL_MS
100
namespace
mozilla
{
namespace
{
struct
ShutdownStep
{
mozilla
:
:
ShutdownPhase
mPhase
;
Atomic
<
int
>
mTicks
;
constexpr
explicit
ShutdownStep
(
mozilla
:
:
ShutdownPhase
aPhase
)
:
mPhase
(
aPhase
)
mTicks
(
-
1
)
{
}
}
;
static
ShutdownStep
sShutdownSteps
[
]
=
{
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownConfirmed
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownNetTeardown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownTeardown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownQM
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMWillShutdown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdown
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdownThreads
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdownFinal
)
ShutdownStep
(
mozilla
:
:
ShutdownPhase
:
:
CCPostLastCycleCollection
)
}
;
int
GetStepForPhase
(
mozilla
:
:
ShutdownPhase
aPhase
)
{
for
(
size_t
i
=
0
;
i
<
std
:
:
size
(
sShutdownSteps
)
;
i
+
+
)
{
if
(
sShutdownSteps
[
i
]
.
mPhase
>
=
aPhase
)
{
return
(
int
)
i
;
}
}
return
-
1
;
}
PRThread
*
CreateSystemThread
(
void
(
*
start
)
(
void
*
arg
)
void
*
arg
)
{
PRThread
*
thread
=
PR_CreateThread
(
PR_SYSTEM_THREAD
start
arg
PR_PRIORITY_LOW
PR_GLOBAL_THREAD
PR_UNJOINABLE_THREAD
0
)
;
MOZ_LSAN_INTENTIONALLY_LEAK_OBJECT
(
thread
)
;
return
thread
;
}
Atomic
<
uint32_t
>
gHeartbeat
(
0
)
;
struct
Options
{
uint32_t
crashAfterTicks
;
}
;
void
RunWatchdog
(
void
*
arg
)
{
NS_SetCurrentThreadName
(
"
Shutdown
Hang
Terminator
"
)
;
UniquePtr
<
Options
>
options
(
(
Options
*
)
arg
)
;
uint32_t
crashAfterTicks
=
options
-
>
crashAfterTicks
;
options
=
nullptr
;
const
uint32_t
timeToLive
=
crashAfterTicks
;
while
(
true
)
{
#
if
defined
(
XP_WIN
)
Sleep
(
HEARTBEAT_INTERVAL_MS
)
;
#
else
usleep
(
HEARTBEAT_INTERVAL_MS
*
1000
)
;
#
endif
if
(
gHeartbeat
+
+
<
timeToLive
)
{
continue
;
}
NoteIntentionalCrash
(
XRE_GetProcessTypeString
(
)
)
;
nsCString
stack
;
AutoNestedEventLoopAnnotation
:
:
CopyCurrentStack
(
stack
)
;
printf_stderr
(
"
RunWatchdog
:
Mainthread
nested
event
loops
during
hang
:
\
n
-
-
-
%
s
\
n
"
stack
.
get
(
)
)
;
mozilla
:
:
ShutdownPhase
lastPhase
=
mozilla
:
:
ShutdownPhase
:
:
NotInShutdown
;
for
(
int
i
=
ArrayLength
(
sShutdownSteps
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
sShutdownSteps
[
i
]
.
mTicks
>
-
1
)
{
lastPhase
=
sShutdownSteps
[
i
]
.
mPhase
;
break
;
}
}
if
(
lastPhase
=
=
mozilla
:
:
ShutdownPhase
:
:
NotInShutdown
)
{
CrashReporter
:
:
SetMinidumpAnalysisAllThreads
(
)
;
MOZ_CRASH
(
"
Shutdown
hanging
before
starting
any
known
phase
.
"
)
;
}
mozilla
:
:
dom
:
:
workerinternals
:
:
RuntimeService
*
runtimeService
=
mozilla
:
:
dom
:
:
workerinternals
:
:
RuntimeService
:
:
GetService
(
)
;
if
(
runtimeService
)
{
runtimeService
-
>
CrashIfHanging
(
)
;
}
nsCString
msg
;
msg
.
AppendPrintf
(
"
Shutdown
hanging
at
step
%
s
.
"
"
Something
is
blocking
the
main
-
thread
.
"
mozilla
:
:
AppShutdown
:
:
GetShutdownPhaseName
(
lastPhase
)
)
;
CrashReporter
:
:
SetMinidumpAnalysisAllThreads
(
)
;
MOZ_CRASH_UNSAFE
(
strdup
(
msg
.
BeginReading
(
)
)
)
;
}
}
}
NS_IMPL_ISUPPORTS
(
nsTerminator
nsIObserver
nsITerminatorTest
)
nsTerminator
:
:
nsTerminator
(
)
:
mInitialized
(
false
)
mCurrentStep
(
-
1
)
{
}
void
nsTerminator
:
:
Start
(
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
StartWatchdog
(
)
;
mInitialized
=
true
;
}
NS_IMETHODIMP
nsTerminator
:
:
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
{
if
(
strcmp
(
aTopic
"
terminator
-
test
-
quit
-
application
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownConfirmed
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
change
-
net
-
teardown
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownNetTeardown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
change
-
teardown
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownTeardown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
before
-
change
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
before
-
change
-
qm
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownQM
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
profile
-
before
-
change
-
telemetry
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
AppShutdownTelemetry
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
xpcom
-
will
-
shutdown
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMWillShutdown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
xpcom
-
shutdown
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdown
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
xpcom
-
shutdown
-
threads
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdownThreads
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
XPCOMShutdownFinal
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
XPCOMShutdownFinal
)
;
}
else
if
(
strcmp
(
aTopic
"
terminator
-
test
-
CCPostLastCycleCollection
"
)
=
=
0
)
{
AdvancePhase
(
mozilla
:
:
ShutdownPhase
:
:
CCPostLastCycleCollection
)
;
}
return
NS_OK
;
}
void
nsTerminator
:
:
StartWatchdog
(
)
{
int32_t
crashAfterMS
=
Preferences
:
:
GetInt
(
"
toolkit
.
asyncshutdown
.
crash_timeout
"
FALLBACK_ASYNCSHUTDOWN_CRASH_AFTER_MS
)
;
if
(
crashAfterMS
<
=
0
)
{
crashAfterMS
=
FALLBACK_ASYNCSHUTDOWN_CRASH_AFTER_MS
;
}
if
(
crashAfterMS
>
INT32_MAX
-
ADDITIONAL_WAIT_BEFORE_CRASH_MS
)
{
crashAfterMS
=
INT32_MAX
;
}
else
{
crashAfterMS
+
=
ADDITIONAL_WAIT_BEFORE_CRASH_MS
;
}
#
ifdef
MOZ_VALGRIND
if
(
RUNNING_ON_VALGRIND
)
{
const
int32_t
scaleUp
=
3
;
if
(
crashAfterMS
>
=
(
INT32_MAX
/
scaleUp
)
-
1
)
{
crashAfterMS
=
INT32_MAX
;
}
else
{
crashAfterMS
*
=
scaleUp
;
}
}
#
endif
UniquePtr
<
Options
>
options
(
new
Options
(
)
)
;
options
-
>
crashAfterTicks
=
crashAfterMS
/
HEARTBEAT_INTERVAL_MS
;
DebugOnly
<
PRThread
*
>
watchdogThread
=
CreateSystemThread
(
RunWatchdog
options
.
release
(
)
)
;
MOZ_ASSERT
(
watchdogThread
)
;
}
const
char
*
GetReadableNameForPhase
(
mozilla
:
:
ShutdownPhase
aPhase
)
{
const
char
*
readableName
=
mozilla
:
:
AppShutdown
:
:
GetObserverKey
(
aPhase
)
;
if
(
!
readableName
)
{
readableName
=
mozilla
:
:
AppShutdown
:
:
GetShutdownPhaseName
(
aPhase
)
;
}
return
readableName
;
}
void
nsTerminator
:
:
AdvancePhase
(
mozilla
:
:
ShutdownPhase
aPhase
)
{
auto
step
=
GetStepForPhase
(
aPhase
)
;
if
(
step
<
0
)
{
return
;
}
if
(
!
mInitialized
)
{
Start
(
)
;
}
UpdateHeartbeat
(
step
)
;
UpdateCrashReport
(
GetReadableNameForPhase
(
aPhase
)
)
;
}
void
nsTerminator
:
:
UpdateHeartbeat
(
int32_t
aStep
)
{
MOZ_ASSERT
(
aStep
>
=
mCurrentStep
)
;
if
(
aStep
>
mCurrentStep
)
{
uint32_t
ticks
=
gHeartbeat
.
exchange
(
0
)
;
if
(
mCurrentStep
>
=
0
)
{
sShutdownSteps
[
mCurrentStep
]
.
mTicks
=
ticks
;
}
sShutdownSteps
[
aStep
]
.
mTicks
=
0
;
mCurrentStep
=
aStep
;
}
}
void
nsTerminator
:
:
UpdateCrashReport
(
const
char
*
aTopic
)
{
CrashReporter
:
:
RecordAnnotationCString
(
CrashReporter
:
:
Annotation
:
:
ShutdownProgress
aTopic
)
;
}
NS_IMETHODIMP
nsTerminator
:
:
GetTicksForShutdownPhases
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
)
{
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
aRetval
.
setObject
(
*
obj
)
;
for
(
auto
&
shutdownStep
:
sShutdownSteps
)
{
if
(
shutdownStep
.
mTicks
>
=
0
)
{
JS_DefineProperty
(
aCx
obj
GetReadableNameForPhase
(
shutdownStep
.
mPhase
)
shutdownStep
.
mTicks
JSPROP_ENUMERATE
)
;
}
}
return
NS_OK
;
}
}
