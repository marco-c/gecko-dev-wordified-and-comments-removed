"
use
strict
"
;
const
{
setTimeout
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
sys
.
mjs
"
)
;
var
PATH
;
var
PATH_TMP
;
var
terminator
;
var
HEARTBEAT_MS
=
100
;
let
KEYS
=
[
"
quit
-
application
"
"
profile
-
change
-
net
-
teardown
"
"
profile
-
change
-
teardown
"
"
profile
-
before
-
change
"
"
profile
-
before
-
change
-
qm
"
"
xpcom
-
will
-
shutdown
"
"
xpcom
-
shutdown
"
"
xpcom
-
shutdown
-
threads
"
"
XPCOMShutdownFinal
"
"
CCPostLastCycleCollection
"
]
;
let
DATA
=
[
]
;
let
MeasuredDurations
=
[
]
;
add_task
(
async
function
init
(
)
{
do_get_profile
(
)
;
PATH
=
PathUtils
.
join
(
PathUtils
.
localProfileDir
"
ShutdownDuration
.
json
"
)
;
PATH_TMP
=
PATH
+
"
.
tmp
"
;
info
(
"
Initializing
the
Terminator
"
)
;
terminator
=
Cc
[
"
mozilla
.
org
/
toolkit
/
shutdown
-
terminator
;
1
"
]
.
createInstance
(
Ci
.
nsIObserver
)
;
}
)
;
var
promiseShutdownDurationData
=
async
function
(
)
{
while
(
true
)
{
if
(
await
IOUtils
.
exists
(
PATH
)
)
{
break
;
}
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
50
)
)
;
}
return
IOUtils
.
readJSON
(
PATH
)
;
}
;
var
currentPhase
=
0
;
var
advancePhase
=
async
function
(
)
{
let
key
=
"
terminator
-
test
-
"
+
KEYS
[
currentPhase
]
;
let
msDuration
=
200
+
HEARTBEAT_MS
*
currentPhase
;
info
(
"
Advancing
shutdown
phase
to
"
+
KEYS
[
currentPhase
]
)
;
terminator
.
observe
(
null
key
null
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
msDuration
)
)
;
let
data
=
await
promiseShutdownDurationData
(
)
;
Assert
.
ok
(
KEYS
[
currentPhase
]
in
data
"
The
file
contains
the
expected
key
"
)
;
Assert
.
equal
(
Object
.
keys
(
data
)
.
length
currentPhase
+
1
"
File
does
not
contain
more
durations
than
expected
"
)
;
DATA
[
currentPhase
]
=
data
;
currentPhase
+
+
;
if
(
currentPhase
<
KEYS
.
length
)
{
return
true
;
}
return
false
;
}
;
add_task
(
async
function
test_record
(
)
{
info
(
"
Collecting
duration
data
for
all
known
phases
"
)
;
let
morePhases
=
true
;
while
(
morePhases
)
{
let
beforeWait
=
Date
.
now
(
)
;
morePhases
=
await
advancePhase
(
)
;
await
IOUtils
.
remove
(
PATH
)
;
await
IOUtils
.
remove
(
PATH_TMP
)
;
MeasuredDurations
[
currentPhase
-
1
]
=
Math
.
floor
(
(
Date
.
now
(
)
-
beforeWait
)
/
HEARTBEAT_MS
)
;
}
Assert
.
equal
(
DATA
.
length
KEYS
.
length
"
We
have
data
for
each
phase
"
)
;
for
(
let
i
=
0
;
i
<
KEYS
.
length
;
i
+
+
)
{
let
lastDuration
=
DATA
[
KEYS
.
length
-
1
]
[
KEYS
[
i
]
]
;
Assert
.
equal
(
typeof
lastDuration
"
number
"
"
Duration
of
phase
"
+
i
+
"
:
"
+
KEYS
[
i
]
+
"
is
a
number
"
)
;
if
(
i
<
KEYS
.
length
-
1
)
{
let
ticksDuration
=
DATA
[
i
+
1
]
[
KEYS
[
i
]
]
;
let
measuredDuration
=
MeasuredDurations
[
i
]
;
info
(
"
measuredDuration
:
"
+
measuredDuration
+
"
-
"
+
typeof
measuredDuration
)
;
Assert
.
lessOrEqual
(
ticksDuration
measuredDuration
+
2
"
Duration
of
phase
"
+
i
+
"
:
"
+
KEYS
[
i
]
+
"
is
not
too
long
"
)
;
Assert
.
greaterOrEqual
(
ticksDuration
0
"
Duration
of
phase
"
+
i
+
"
:
"
+
KEYS
[
i
]
+
"
is
not
too
short
"
)
;
}
if
(
i
<
KEYS
.
length
-
2
)
{
let
ticksDuration
=
DATA
[
i
+
1
]
[
KEYS
[
i
]
]
;
Assert
.
equal
(
ticksDuration
DATA
[
KEYS
.
length
-
1
]
[
KEYS
[
i
]
]
"
Duration
of
phase
"
+
i
+
"
:
"
+
KEYS
[
i
]
+
"
hasn
'
t
changed
"
)
;
}
}
Assert
.
equal
(
Object
.
keys
(
DATA
[
KEYS
.
length
-
1
]
)
.
sort
(
)
.
join
(
"
"
)
KEYS
.
sort
(
)
.
join
(
"
"
)
"
The
last
file
contains
all
expected
keys
"
)
;
}
)
;
