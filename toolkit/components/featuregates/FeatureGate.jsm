"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FeatureGateImplementation
"
"
resource
:
/
/
featuregates
/
FeatureGateImplementation
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
FeatureGate
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gFeatureDefinitionsPromise
"
async
(
)
=
>
{
const
url
=
"
resource
:
/
/
featuregates
/
feature_definitions
.
json
"
;
return
fetchFeatureDefinitions
(
url
)
;
}
)
;
const
kTargetFacts
=
new
Map
(
[
[
"
release
"
AppConstants
.
MOZ_UPDATE_CHANNEL
=
=
=
"
release
"
]
[
"
beta
"
AppConstants
.
MOZ_UPDATE_CHANNEL
=
=
=
"
beta
"
]
[
"
dev
-
edition
"
AppConstants
.
MOZ_UPDATE_CHANNEL
=
=
=
"
aurora
"
]
[
"
nightly
"
AppConstants
.
MOZ_UPDATE_CHANNEL
=
=
=
"
nightly
"
]
[
"
win
"
AppConstants
.
platform
=
=
=
"
win
"
]
[
"
mac
"
AppConstants
.
platform
=
=
=
"
macosx
"
]
[
"
linux
"
AppConstants
.
platform
=
=
=
"
linux
"
]
[
"
android
"
AppConstants
.
platform
=
=
=
"
android
"
]
]
)
;
async
function
fetchFeatureDefinitions
(
url
)
{
const
res
=
await
fetch
(
url
)
;
let
definitionsJson
=
await
res
.
json
(
)
;
return
new
Map
(
Object
.
entries
(
definitionsJson
)
)
;
}
function
evaluateTargetedValue
(
targetedValue
targetingFacts
)
{
if
(
!
Object
.
hasOwnProperty
.
call
(
targetedValue
"
default
"
)
)
{
throw
new
Error
(
Targeted
value
{
JSON
.
stringify
(
targetedValue
)
}
has
no
default
key
)
;
}
for
(
const
[
key
value
]
of
Object
.
entries
(
targetedValue
)
)
{
if
(
key
=
=
=
"
default
"
)
{
continue
;
}
if
(
key
.
split
(
"
"
)
.
every
(
part
=
>
targetingFacts
.
get
(
part
)
)
)
{
return
value
;
}
}
return
targetedValue
.
default
;
}
const
kFeatureGateCache
=
new
Map
(
)
;
class
FeatureGate
{
constructor
(
)
{
}
static
async
fromId
(
id
testDefinitionsUrl
=
undefined
)
{
let
featureDefinitions
;
if
(
testDefinitionsUrl
)
{
featureDefinitions
=
await
fetchFeatureDefinitions
(
testDefinitionsUrl
)
;
}
else
{
featureDefinitions
=
await
gFeatureDefinitionsPromise
;
}
if
(
!
featureDefinitions
.
has
(
id
)
)
{
throw
new
Error
(
Unknown
feature
id
{
id
}
.
Features
must
be
defined
in
toolkit
/
components
/
featuregates
/
Features
.
toml
)
;
}
const
definition
=
{
.
.
.
featureDefinitions
.
get
(
id
)
}
;
const
targetValueKeys
=
[
"
defaultValue
"
"
isPublic
"
]
;
for
(
const
key
of
targetValueKeys
)
{
definition
[
key
]
=
evaluateTargetedValue
(
definition
[
key
]
kTargetFacts
)
;
}
return
new
FeatureGateImplementation
(
definition
)
;
}
static
async
addObserver
(
id
observer
testDefinitionsUrl
=
undefined
)
{
if
(
!
kFeatureGateCache
.
has
(
id
)
)
{
kFeatureGateCache
.
set
(
id
await
FeatureGate
.
fromId
(
id
testDefinitionsUrl
)
)
;
}
const
feature
=
kFeatureGateCache
.
get
(
id
)
;
return
feature
.
addObserver
(
observer
)
;
}
static
async
removeObserver
(
id
observer
)
{
let
feature
=
kFeatureGateCache
.
get
(
id
)
;
if
(
!
feature
)
{
return
;
}
feature
.
removeObserver
(
observer
)
;
if
(
feature
.
_observers
.
size
=
=
=
0
)
{
kFeatureGateCache
.
delete
(
id
)
;
}
}
static
async
getValue
(
id
testDefinitionsUrl
=
undefined
)
{
let
feature
=
kFeatureGateCache
.
get
(
id
)
;
if
(
!
feature
)
{
feature
=
await
FeatureGate
.
fromId
(
id
testDefinitionsUrl
)
;
}
return
feature
.
getValue
(
)
;
}
static
async
isEnabled
(
id
testDefinitionsUrl
=
undefined
)
{
let
feature
=
kFeatureGateCache
.
get
(
id
)
;
if
(
!
feature
)
{
feature
=
await
FeatureGate
.
fromId
(
id
testDefinitionsUrl
)
;
}
return
feature
.
isEnabled
(
)
;
}
}
