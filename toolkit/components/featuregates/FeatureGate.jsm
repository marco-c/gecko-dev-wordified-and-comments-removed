"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
FeatureGateImplementation
"
"
resource
:
/
/
featuregates
/
FeatureGateImplementation
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
FeatureGate
"
]
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
gFeatureDefinitionsPromise
"
async
(
)
=
>
{
const
url
=
"
resource
:
/
/
featuregates
/
feature_definitions
.
json
"
;
return
fetchFeatureDefinitions
(
url
)
;
}
)
;
async
function
fetchFeatureDefinitions
(
url
)
{
const
res
=
await
fetch
(
url
)
;
let
definitionsJson
=
await
res
.
json
(
)
;
return
new
Map
(
Object
.
entries
(
definitionsJson
)
)
;
}
function
buildFeatureGateImplementation
(
definition
)
{
const
targetValueKeys
=
[
"
defaultValue
"
"
isPublic
"
]
;
for
(
const
key
of
targetValueKeys
)
{
definition
[
{
key
}
OriginalValue
]
=
definition
[
key
]
;
definition
[
key
]
=
FeatureGate
.
evaluateTargetedValue
(
definition
[
key
]
)
;
}
return
new
lazy
.
FeatureGateImplementation
(
definition
)
;
}
let
featureGatePrefObserver
=
{
onChange
(
)
{
FeatureGate
.
annotateCrashReporter
(
)
;
}
onEnable
(
)
{
}
onDisable
(
)
{
}
}
;
const
kFeatureGateCache
=
new
Map
(
)
;
class
FeatureGate
{
constructor
(
)
{
}
static
async
fromId
(
id
testDefinitionsUrl
=
undefined
)
{
let
featureDefinitions
;
if
(
testDefinitionsUrl
)
{
featureDefinitions
=
await
fetchFeatureDefinitions
(
testDefinitionsUrl
)
;
}
else
{
featureDefinitions
=
await
lazy
.
gFeatureDefinitionsPromise
;
}
if
(
!
featureDefinitions
.
has
(
id
)
)
{
throw
new
Error
(
Unknown
feature
id
{
id
}
.
Features
must
be
defined
in
toolkit
/
components
/
featuregates
/
Features
.
toml
)
;
}
return
buildFeatureGateImplementation
(
{
.
.
.
featureDefinitions
.
get
(
id
)
}
)
;
}
static
async
all
(
testDefinitionsUrl
=
undefined
)
{
let
featureDefinitions
;
if
(
testDefinitionsUrl
)
{
featureDefinitions
=
await
fetchFeatureDefinitions
(
testDefinitionsUrl
)
;
}
else
{
featureDefinitions
=
await
lazy
.
gFeatureDefinitionsPromise
;
}
let
definitions
=
[
]
;
for
(
let
definition
of
featureDefinitions
.
values
(
)
)
{
definitions
[
definitions
.
length
]
=
buildFeatureGateImplementation
(
Object
.
assign
(
{
}
definition
)
)
;
}
return
definitions
;
}
static
async
observePrefChangesForCrashReportAnnotation
(
testDefinitionsUrl
=
undefined
)
{
let
featureDefinitions
=
await
FeatureGate
.
all
(
testDefinitionsUrl
)
;
for
(
let
definition
of
featureDefinitions
.
values
(
)
)
{
FeatureGate
.
addObserver
(
definition
.
id
featureGatePrefObserver
testDefinitionsUrl
)
;
}
}
static
async
annotateCrashReporter
(
)
{
let
crashReporter
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
.
getService
(
Ci
.
nsICrashReporter
)
;
if
(
!
crashReporter
?
.
enabled
)
{
return
;
}
let
features
=
await
FeatureGate
.
all
(
)
;
let
enabledFeatures
=
[
]
;
for
(
let
feature
of
features
)
{
if
(
await
feature
.
getValue
(
)
)
{
enabledFeatures
.
push
(
feature
.
preference
)
;
}
}
crashReporter
.
annotateCrashReport
(
"
ExperimentalFeatures
"
enabledFeatures
.
join
(
"
"
)
)
;
}
static
async
addObserver
(
id
observer
testDefinitionsUrl
=
undefined
)
{
if
(
!
kFeatureGateCache
.
has
(
id
)
)
{
kFeatureGateCache
.
set
(
id
await
FeatureGate
.
fromId
(
id
testDefinitionsUrl
)
)
;
}
const
feature
=
kFeatureGateCache
.
get
(
id
)
;
return
feature
.
addObserver
(
observer
)
;
}
static
async
removeObserver
(
id
observer
)
{
let
feature
=
kFeatureGateCache
.
get
(
id
)
;
if
(
!
feature
)
{
return
;
}
feature
.
removeObserver
(
observer
)
;
if
(
feature
.
_observers
.
size
=
=
=
0
)
{
kFeatureGateCache
.
delete
(
id
)
;
}
}
static
async
getValue
(
id
testDefinitionsUrl
=
undefined
)
{
let
feature
=
kFeatureGateCache
.
get
(
id
)
;
if
(
!
feature
)
{
feature
=
await
FeatureGate
.
fromId
(
id
testDefinitionsUrl
)
;
}
return
feature
.
getValue
(
)
;
}
static
async
isEnabled
(
id
testDefinitionsUrl
=
undefined
)
{
let
feature
=
kFeatureGateCache
.
get
(
id
)
;
if
(
!
feature
)
{
feature
=
await
FeatureGate
.
fromId
(
id
testDefinitionsUrl
)
;
}
return
feature
.
isEnabled
(
)
;
}
static
targetingFacts
=
new
Map
(
[
[
"
release
"
AppConstants
.
MOZ_UPDATE_CHANNEL
=
=
=
"
release
"
|
|
AppConstants
.
IS_ESR
]
[
"
beta
"
AppConstants
.
MOZ_UPDATE_CHANNEL
=
=
=
"
beta
"
]
[
"
early_beta_or_earlier
"
AppConstants
.
EARLY_BETA_OR_EARLIER
]
[
"
dev
-
edition
"
AppConstants
.
MOZ_DEV_EDITION
]
[
"
nightly
"
AppConstants
.
NIGHTLY_BUILD
]
[
"
win
"
AppConstants
.
platform
=
=
=
"
win
"
]
[
"
mac
"
AppConstants
.
platform
=
=
=
"
macosx
"
]
[
"
linux
"
AppConstants
.
platform
=
=
=
"
linux
"
]
[
"
android
"
AppConstants
.
platform
=
=
=
"
android
"
]
[
"
thunderbird
"
AppConstants
.
MOZ_APP_NAME
=
=
=
"
thunderbird
"
]
]
)
;
static
evaluateTargetedValue
(
targetedValue
targetingFacts
=
FeatureGate
.
targetingFacts
{
mergeFactsWithDefault
=
false
}
=
{
}
)
{
if
(
!
Object
.
hasOwnProperty
.
call
(
targetedValue
"
default
"
)
)
{
throw
new
Error
(
Targeted
value
{
JSON
.
stringify
(
targetedValue
)
}
has
no
default
key
)
;
}
if
(
mergeFactsWithDefault
)
{
const
combinedFacts
=
new
Map
(
FeatureGate
.
targetingFacts
)
;
for
(
const
[
key
value
]
of
targetingFacts
.
entries
(
)
)
{
combinedFacts
.
set
(
key
value
)
;
}
targetingFacts
=
combinedFacts
;
}
for
(
const
[
key
value
]
of
Object
.
entries
(
targetedValue
)
)
{
if
(
key
=
=
=
"
default
"
)
{
continue
;
}
if
(
key
.
split
(
"
"
)
.
every
(
part
=
>
targetingFacts
.
get
(
part
)
)
)
{
return
value
;
}
}
return
targetedValue
.
default
;
}
}
