"
use
strict
"
;
const
HARDCODED_ASSUMPTIONS_PROCESS
=
{
minimalNumberOfThreads
:
6
maximalNumberOfThreads
:
1000
minimalCPUPercentage
:
0
maximalCPUPercentage
:
1000
minimalCPUTotalDurationMS
:
10
maximalCPUTotalDurationMS
:
10000000
minimalRAMBytesUsage
:
1024
*
1024
maximalRAMBytesUsage
:
1024
*
1024
*
1024
*
1024
*
1
}
;
const
HARDCODED_ASSUMPTIONS_THREAD
=
{
minimalCPUPercentage
:
0
maximalCPUPercentage
:
100
minimalCPUTotalDurationMS
:
0
maximalCPUTotalDurationMS
:
10000000
}
;
const
APPROX_FACTOR
=
1
.
51
;
const
MS_PER_NS
=
1000000
;
async
function
promiseAboutProcessesUpdated
(
{
doc
force
tabAboutProcesses
}
)
{
let
startTime
=
performance
.
now
(
)
;
let
updatePromise
=
new
Promise
(
resolve
=
>
{
doc
.
addEventListener
(
"
AboutProcessesUpdated
"
resolve
{
once
:
true
}
)
;
}
)
;
if
(
force
)
{
await
SpecialPowers
.
spawn
(
tabAboutProcesses
.
linkedBrowser
[
]
async
(
)
=
>
{
info
(
"
Forcing
about
:
processes
refresh
"
)
;
await
content
.
Control
.
update
(
true
)
;
}
)
;
}
await
updatePromise
;
await
new
Promise
(
doc
.
defaultView
.
requestAnimationFrame
)
;
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
ChromeUtils
.
addProfilerMarker
(
"
promiseAboutProcessesUpdated
"
{
startTime
category
:
"
Test
"
}
force
?
"
force
"
:
undefined
)
;
}
function
promiseProcessDied
(
{
childID
}
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
properties
=
>
{
properties
.
QueryInterface
(
Ci
.
nsIPropertyBag2
)
;
let
subjectChildID
=
properties
.
get
(
"
childID
"
)
;
if
(
subjectChildID
=
=
childID
)
{
Services
.
obs
.
removeObserver
(
observer
"
ipc
:
content
-
shutdown
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observer
"
ipc
:
content
-
shutdown
"
)
;
}
)
;
}
function
isCloseEnough
(
value
expected
)
{
if
(
value
<
0
|
|
expected
<
0
)
{
throw
new
Error
(
Invalid
isCloseEnough
(
{
value
}
{
expected
}
)
)
;
}
if
(
Math
.
round
(
value
)
=
=
Math
.
round
(
expected
)
)
{
return
true
;
}
if
(
expected
=
=
0
)
{
return
false
;
}
let
ratio
=
value
/
expected
;
if
(
ratio
<
=
APPROX_FACTOR
&
&
ratio
>
=
1
/
APPROX_FACTOR
)
{
return
true
;
}
return
false
;
}
function
getMemoryMultiplier
(
unit
sign
=
"
+
"
)
{
let
multiplier
;
switch
(
sign
)
{
case
"
+
"
:
multiplier
=
1
;
break
;
case
"
-
"
:
multiplier
=
-
1
;
break
;
default
:
throw
new
Error
(
"
Invalid
sign
:
"
+
sign
)
;
}
switch
(
unit
)
{
case
"
B
"
:
break
;
case
"
KB
"
:
multiplier
*
=
1024
;
break
;
case
"
MB
"
:
multiplier
*
=
1024
*
1024
;
break
;
case
"
GB
"
:
multiplier
*
=
1024
*
1024
*
1024
;
break
;
case
"
TB
"
:
multiplier
*
=
1024
*
1024
*
1024
*
1024
;
break
;
default
:
throw
new
Error
(
"
Invalid
memory
unit
:
"
+
unit
)
;
}
return
multiplier
;
}
function
getTimeMultiplier
(
unit
)
{
switch
(
unit
)
{
case
"
ns
"
:
return
1
/
(
1000
*
1000
)
;
case
"
s
"
:
return
1
/
1000
;
case
"
ms
"
:
return
1
;
case
"
s
"
:
return
1000
;
case
"
m
"
:
return
60000
;
}
throw
new
Error
(
"
Invalid
time
unit
:
"
+
unit
)
;
}
async
function
testCpu
(
element
total
slope
assumptions
)
{
info
(
Testing
CPU
display
{
element
.
textContent
}
-
{
element
.
title
}
vs
total
{
total
}
slope
{
slope
}
)
;
let
barWidth
=
getComputedStyle
(
element
)
.
getPropertyValue
(
"
-
-
bar
-
width
"
)
;
if
(
slope
)
{
Assert
.
greater
(
Number
.
parseFloat
(
barWidth
)
0
"
The
bar
width
should
be
>
0
when
there
is
some
CPU
use
"
)
;
}
else
{
Assert
.
equal
(
barWidth
"
-
0
.
5
"
"
There
should
be
no
CPU
bar
displayed
"
)
;
}
if
(
element
.
textContent
=
=
"
(
measuring
)
"
)
{
info
(
"
Still
measuring
"
)
;
return
;
}
const
CPU_TEXT_CONTENT_REGEXP
=
/
\
~
0
%
|
idle
|
[
0
-
9
.
]
+
%
|
[
?
]
/
;
let
extractedPercentage
=
CPU_TEXT_CONTENT_REGEXP
.
exec
(
element
.
textContent
)
[
0
]
;
switch
(
extractedPercentage
)
{
case
"
idle
"
:
Assert
.
equal
(
slope
0
"
Idle
means
exactly
0
%
"
)
;
return
;
case
"
~
0
%
"
:
Assert
.
ok
(
slope
>
0
&
&
slope
<
0
.
0001
)
;
break
;
case
"
?
"
:
Assert
.
ok
(
slope
=
=
null
)
;
return
;
default
:
{
let
computedPercentage
=
Number
.
parseFloat
(
extractedPercentage
)
;
Assert
.
ok
(
isCloseEnough
(
computedPercentage
slope
*
100
)
The
displayed
approximation
of
the
slope
is
reasonable
:
{
computedPercentage
}
vs
{
slope
*
100
}
)
;
Assert
.
ok
(
computedPercentage
/
100
>
=
assumptions
.
minimalCPUPercentage
Not
too
little
:
{
computedPercentage
/
100
}
>
=
?
{
assumptions
.
minimalCPUPercentage
}
)
;
Assert
.
ok
(
computedPercentage
/
100
<
=
assumptions
.
maximalCPUPercentage
Not
too
much
:
{
computedPercentage
/
100
}
<
=
?
{
assumptions
.
maximalCPUPercentage
}
)
;
break
;
}
}
const
CPU_TOOLTIP_REGEXP
=
/
(
?
:
.
*
:
(
[
0
-
9
.
]
+
)
?
(
ns
|
s
|
ms
|
s
|
m
|
h
|
d
)
)
/
;
let
[
extractedTotal
extractedUnit
]
=
CPU_TOOLTIP_REGEXP
.
exec
(
element
.
title
)
;
let
totalMS
=
total
/
MS_PER_NS
;
let
computedTotal
=
Number
.
parseFloat
(
extractedTotal
.
replace
(
/
/
g
"
"
)
)
*
getTimeMultiplier
(
extractedUnit
)
;
Assert
.
ok
(
isCloseEnough
(
computedTotal
totalMS
)
The
displayed
approximation
of
the
total
duration
is
reasonable
:
{
computedTotal
}
vs
{
totalMS
}
)
;
Assert
.
ok
(
totalMS
<
=
assumptions
.
maximalCPUTotalDurationMS
&
&
totalMS
>
=
assumptions
.
minimalCPUTotalDurationMS
The
total
number
of
MS
is
reasonable
{
totalMS
}
:
[
{
assumptions
.
minimalCPUTotalDurationMS
}
{
assumptions
.
maximalCPUTotalDurationMS
}
]
)
;
}
async
function
testMemory
(
element
total
delta
assumptions
)
{
info
(
Testing
memory
display
{
element
.
textContent
}
-
{
element
.
title
}
vs
total
{
total
}
delta
{
delta
}
)
;
const
MEMORY_TEXT_CONTENT_REGEXP
=
/
(
[
0
-
9
.
]
+
)
(
TB
|
GB
|
MB
|
KB
|
B
)
/
;
let
extracted
=
MEMORY_TEXT_CONTENT_REGEXP
.
exec
(
element
.
textContent
)
;
Assert
.
notEqual
(
extracted
null
Can
we
parse
{
element
.
textContent
}
with
{
MEMORY_TEXT_CONTENT_REGEXP
}
?
)
;
let
[
extractedTotal
extractedUnit
]
=
extracted
;
let
extractedTotalNumber
=
Number
.
parseFloat
(
extractedTotal
)
;
Assert
.
ok
(
extractedTotalNumber
>
0
Unitless
total
memory
use
is
greater
than
0
:
{
extractedTotal
}
)
;
if
(
extractedUnit
!
=
"
GB
"
)
{
Assert
.
ok
(
extractedTotalNumber
<
=
1024
Unitless
total
memory
use
is
less
than
1024
:
{
extractedTotal
}
)
;
}
let
computedTotal
=
getMemoryMultiplier
(
extractedUnit
)
*
extractedTotalNumber
;
Assert
.
ok
(
isCloseEnough
(
computedTotal
total
)
The
displayed
approximation
of
the
total
amount
of
memory
is
reasonable
:
{
computedTotal
}
vs
{
total
}
)
;
if
(
!
AppConstants
.
ASAN
)
{
Assert
.
ok
(
assumptions
.
minimalRAMBytesUsage
<
=
computedTotal
&
&
computedTotal
<
=
assumptions
.
maximalRAMBytesUsage
The
total
amount
amount
of
memory
is
reasonable
:
{
computedTotal
}
in
[
{
assumptions
.
minimalRAMBytesUsage
}
{
assumptions
.
maximalRAMBytesUsage
}
]
)
;
}
const
MEMORY_TOOLTIP_REGEXP
=
/
(
?
:
.
*
:
(
[
-
+
]
?
)
(
[
0
-
9
.
]
+
)
(
GB
|
MB
|
KB
|
B
)
)
?
/
;
extracted
=
MEMORY_TOOLTIP_REGEXP
.
exec
(
element
.
title
)
;
Assert
.
notEqual
(
extracted
null
Can
we
parse
{
element
.
title
}
with
{
MEMORY_TOOLTIP_REGEXP
}
?
)
;
let
[
extractedDeltaSign
extractedDeltaTotal
extractedDeltaUnit
]
=
extracted
;
if
(
extractedDeltaSign
=
=
null
)
{
Assert
.
equal
(
delta
|
|
0
0
)
;
return
;
}
let
deltaTotalNumber
=
Number
.
parseFloat
(
extractedDeltaTotal
.
replace
(
/
/
g
"
"
)
)
;
Assert
.
ok
(
deltaTotalNumber
>
0
&
&
deltaTotalNumber
<
=
1024
Unitless
delta
memory
use
is
in
(
0
1024
)
:
{
extractedDeltaTotal
}
)
;
Assert
.
ok
(
[
"
B
"
"
KB
"
"
MB
"
]
.
includes
(
extractedDeltaUnit
)
Delta
unit
is
reasonable
:
{
extractedDeltaUnit
}
)
;
let
computedDelta
=
getMemoryMultiplier
(
extractedDeltaUnit
extractedDeltaSign
)
*
deltaTotalNumber
;
Assert
.
equal
(
computedDelta
>
=
0
delta
>
=
0
Delta
has
the
right
sign
:
{
computedDelta
}
vs
{
delta
}
)
;
}
function
extractProcessDetails
(
row
)
{
let
children
=
row
.
children
;
let
name
=
children
[
0
]
;
let
memory
=
children
[
1
]
;
let
cpu
=
children
[
2
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
aboutProcesses
.
showProfilerIcons
"
)
)
{
name
=
name
.
firstChild
;
Assert
.
ok
(
name
.
nextSibling
.
classList
.
contains
(
"
profiler
-
icon
"
)
"
The
profiler
icon
should
be
shown
"
)
;
}
let
fluentArgs
=
row
.
ownerDocument
.
l10n
.
getAttributes
(
name
)
.
args
;
let
threadDetailsRow
=
row
.
nextSibling
;
while
(
threadDetailsRow
)
{
if
(
threadDetailsRow
.
classList
.
contains
(
"
process
"
)
)
{
threadDetailsRow
=
null
;
break
;
}
if
(
threadDetailsRow
.
classList
.
contains
(
"
thread
-
summary
"
)
)
{
break
;
}
threadDetailsRow
=
threadDetailsRow
.
nextSibling
;
}
return
{
memory
cpu
pidContent
:
fluentArgs
.
pid
threads
:
threadDetailsRow
}
;
}
function
findTabRowByName
(
doc
name
)
{
for
(
let
row
of
doc
.
getElementsByClassName
(
"
name
"
)
)
{
if
(
!
row
.
parentNode
.
classList
.
contains
(
"
window
"
)
)
{
continue
;
}
let
foundName
=
document
.
l10n
.
getAttributes
(
row
)
.
args
.
name
;
if
(
foundName
!
=
name
)
{
continue
;
}
return
row
.
parentNode
;
}
return
null
;
}
function
findProcessRowByOrigin
(
doc
origin
)
{
for
(
let
row
of
doc
.
getElementsByClassName
(
"
process
"
)
)
{
if
(
row
.
process
.
origin
=
=
origin
)
{
return
row
;
}
}
return
null
;
}
async
function
setupTabWithOriginAndTitle
(
origin
title
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
origin
{
skipAnimation
:
true
}
)
;
tab
.
testTitle
=
title
;
tab
.
testOrigin
=
origin
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
title
]
async
title
=
>
{
content
.
document
.
title
=
title
;
}
)
;
return
tab
;
}
async
function
setupAudioTab
(
)
{
let
origin
=
"
about
:
blank
"
;
let
title
=
"
utility
audio
"
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
origin
{
skipAnimation
:
true
}
)
;
tab
.
testTitle
=
title
;
tab
.
testOrigin
=
origin
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
title
]
async
title
=
>
{
content
.
document
.
title
=
title
;
const
ROOT
=
"
https
:
/
/
example
.
com
/
browser
/
toolkit
/
components
/
aboutprocesses
/
tests
/
browser
"
;
let
audio
=
content
.
document
.
createElement
(
"
audio
"
)
;
audio
.
setAttribute
(
"
controls
"
"
true
"
)
;
audio
.
setAttribute
(
"
loop
"
true
)
;
audio
.
src
=
{
ROOT
}
/
small
-
shot
.
mp3
;
content
.
document
.
body
.
appendChild
(
audio
)
;
await
audio
.
play
(
)
;
}
)
;
return
tab
;
}
async
function
testAboutProcessesWithConfig
(
{
showAllFrames
showThreads
}
)
{
const
isFission
=
gFissionBrowser
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
toolkit
.
aboutProcesses
.
showAllSubframes
"
showAllFrames
]
[
"
toolkit
.
aboutProcesses
.
showThreads
"
showThreads
]
[
"
dom
.
ipc
.
processCount
.
webIsolated
"
1
]
[
"
media
.
utility
-
process
.
enabled
"
true
]
]
}
)
;
const
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
browser_specific_settings
:
{
gecko
:
{
id
:
"
test
-
aboutprocesses
mochi
.
test
"
}
}
}
background
(
)
{
document
.
body
.
appendChild
(
document
.
createElement
(
"
iframe
"
)
)
;
this
.
browser
.
test
.
sendMessage
(
"
bg
-
page
-
loaded
"
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
bg
-
page
-
loaded
"
)
;
info
(
"
Setting
up
about
:
processes
"
)
;
let
promiseTabAboutProcesses
=
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
"
about
:
processes
"
waitForLoad
:
true
}
)
;
info
(
"
Setting
up
example
.
com
"
)
;
let
promiseTabHung
=
(
async
function
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
http
:
/
/
example
.
com
"
{
skipAnimation
:
true
}
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
let
p
=
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
true
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
let
frame
=
content
.
document
.
createElement
(
"
iframe
"
)
;
content
.
document
.
body
.
appendChild
(
frame
)
;
}
)
;
await
p
;
return
tab
;
}
)
(
)
;
let
promiseAudioPlayback
=
setupAudioTab
(
)
;
let
promiseUserContextTab
=
(
async
function
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
http
:
/
/
example
.
com
"
{
userContextId
:
1
skipAnimation
:
true
}
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
(
)
=
>
{
content
.
document
.
title
=
"
Tab
with
User
Context
"
;
}
)
;
return
tab
;
}
)
(
)
;
info
(
"
Setting
up
tabs
we
intend
to
close
"
)
;
let
promiseTabCloseSeparately1
=
setupTabWithOriginAndTitle
(
"
http
:
/
/
example
.
org
"
"
Close
me
1
(
separately
)
"
)
;
let
promiseTabCloseSeparately2
=
setupTabWithOriginAndTitle
(
"
http
:
/
/
example
.
org
"
"
Close
me
2
(
separately
)
"
)
;
let
promiseTabCloseProcess1
=
setupTabWithOriginAndTitle
(
"
http
:
/
/
example
.
net
"
"
Close
me
1
(
process
)
"
)
;
let
promiseTabCloseProcess2
=
setupTabWithOriginAndTitle
(
"
http
:
/
/
example
.
net
"
"
Close
me
2
(
process
)
"
)
;
let
promiseTabCloseTogether1
=
setupTabWithOriginAndTitle
(
"
https
:
/
/
example
.
org
"
"
Close
me
1
(
together
)
"
)
;
let
promiseTabCloseTogether2
=
setupTabWithOriginAndTitle
(
"
https
:
/
/
example
.
org
"
"
Close
me
2
(
together
)
"
)
;
let
tabAboutProcesses
=
await
promiseTabAboutProcesses
;
let
tabHung
=
await
promiseTabHung
;
let
audioPlayback
=
await
promiseAudioPlayback
;
let
tabUserContext
=
await
promiseUserContextTab
;
let
tabCloseSeparately1
=
await
promiseTabCloseSeparately1
;
let
tabCloseSeparately2
=
await
promiseTabCloseSeparately2
;
let
tabCloseProcess1
=
await
promiseTabCloseProcess1
;
let
tabCloseProcess2
=
await
promiseTabCloseProcess2
;
let
tabCloseTogether1
=
await
promiseTabCloseTogether1
;
let
tabCloseTogether2
=
await
promiseTabCloseTogether2
;
let
doc
=
tabAboutProcesses
.
linkedBrowser
.
contentDocument
;
let
tbody
=
doc
.
getElementById
(
"
process
-
tbody
"
)
;
Assert
.
ok
(
!
!
tbody
"
Found
the
#
process
-
tbody
element
"
)
;
if
(
isFission
)
{
await
SpecialPowers
.
spawn
(
tabCloseProcess1
.
linkedBrowser
[
]
(
)
=
>
{
ChromeUtils
.
privateNoteIntentionalCrash
(
)
;
}
)
;
}
info
(
"
Setting
up
fake
process
hang
detector
"
)
;
let
hungChildID
=
tabHung
.
linkedBrowser
.
frameLoader
.
childID
;
let
fakeProcessHangMonitor
=
async
function
(
)
{
for
(
let
i
=
0
;
i
<
100
;
+
+
i
)
{
if
(
!
tabHung
.
linkedBrowser
)
{
return
;
}
Services
.
obs
.
notifyObservers
(
{
childID
:
hungChildID
scriptBrowser
:
tabHung
.
linkedBrowser
scriptFileName
:
"
chrome
:
/
/
browser
/
content
/
browser
.
js
"
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIHangReport
"
]
)
}
"
process
-
hang
-
report
"
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
300
)
)
;
}
}
;
fakeProcessHangMonitor
(
)
;
await
promiseAboutProcessesUpdated
(
{
doc
tabAboutProcesses
}
)
;
Assert
.
ok
(
tbody
.
childElementCount
"
The
table
should
be
populated
"
)
;
Assert
.
ok
(
!
!
tbody
.
getElementsByClassName
(
"
hung
"
)
.
length
"
The
hung
process
should
appear
"
)
;
info
(
"
Looking
at
the
contents
of
about
:
processes
"
)
;
let
processesToBeFound
=
[
{
name
:
"
browser
"
predicate
:
row
=
>
row
.
process
.
type
=
=
"
browser
"
}
{
name
:
"
hung
"
predicate
:
row
=
>
row
.
classList
.
contains
(
"
hung
"
)
&
&
row
.
classList
.
contains
(
"
process
"
)
&
&
[
"
web
"
"
webIsolated
"
]
.
includes
(
row
.
process
.
type
)
}
{
name
:
"
non
-
hung
"
predicate
:
row
=
>
!
row
.
classList
.
contains
(
"
hung
"
)
&
&
row
.
classList
.
contains
(
"
process
"
)
&
&
[
"
web
"
"
webIsolated
"
]
.
includes
(
row
.
process
.
type
)
}
{
name
:
"
utility
"
predicate
:
row
=
>
row
.
process
&
&
row
.
process
.
type
=
=
"
utility
"
&
&
row
.
classList
.
contains
(
"
process
"
)
&
&
row
.
nextSibling
&
&
row
.
nextSibling
.
classList
.
contains
(
"
actor
"
)
}
]
;
for
(
let
finder
of
processesToBeFound
)
{
info
(
Running
sanity
tests
on
{
finder
.
name
}
)
;
let
row
=
tbody
.
firstChild
;
while
(
row
)
{
if
(
finder
.
predicate
(
row
)
)
{
break
;
}
row
=
row
.
nextSibling
;
}
Assert
.
ok
(
!
!
row
found
a
table
row
for
{
finder
.
name
}
)
;
let
{
memory
cpu
pidContent
threads
}
=
extractProcessDetails
(
row
)
;
info
(
"
Sanity
checks
:
pid
"
)
;
let
pid
=
Number
.
parseInt
(
pidContent
)
;
Assert
.
ok
(
pid
>
0
Checking
pid
{
pidContent
}
)
;
Assert
.
equal
(
pid
row
.
process
.
pid
)
;
info
(
"
Sanity
checks
:
memory
resident
"
)
;
await
testMemory
(
memory
row
.
process
.
totalRamSize
row
.
process
.
deltaRamSize
HARDCODED_ASSUMPTIONS_PROCESS
)
;
info
(
"
Sanity
checks
:
CPU
(
Total
)
"
)
;
await
testCpu
(
cpu
row
.
process
.
totalCpu
row
.
process
.
slopeCpu
HARDCODED_ASSUMPTIONS_PROCESS
)
;
if
(
!
showThreads
)
{
info
(
"
In
this
mode
we
shouldn
'
t
display
any
threads
"
)
;
Assert
.
equal
(
threads
null
"
In
hidden
threads
mode
we
shouldn
'
t
have
any
thread
summary
"
)
;
}
else
{
Assert
.
ok
(
threads
"
We
have
a
thread
summary
row
"
)
;
let
{
number
active
=
0
list
}
=
doc
.
l10n
.
getAttributes
(
threads
.
children
[
0
]
.
children
[
1
]
)
.
args
;
info
(
"
Sanity
checks
:
number
of
threads
"
)
;
Assert
.
greaterOrEqual
(
number
HARDCODED_ASSUMPTIONS_PROCESS
.
minimalNumberOfThreads
)
;
Assert
.
lessOrEqual
(
number
HARDCODED_ASSUMPTIONS_PROCESS
.
maximalNumberOfThreads
)
;
Assert
.
equal
(
number
row
.
process
.
threads
.
length
"
The
number
we
display
should
be
the
number
of
threads
"
)
;
info
(
"
Sanity
checks
:
number
of
active
threads
"
)
;
Assert
.
greaterOrEqual
(
active
0
"
The
number
of
active
threads
should
never
be
negative
"
)
;
Assert
.
lessOrEqual
(
active
number
"
The
number
of
active
threads
should
not
exceed
the
total
number
of
threads
"
)
;
let
activeThreads
=
row
.
process
.
threads
.
filter
(
t
=
>
t
.
active
)
;
Assert
.
equal
(
active
activeThreads
.
length
"
The
displayed
number
of
active
threads
should
be
correct
"
)
;
let
activeSet
=
new
Set
(
)
;
for
(
let
t
of
activeThreads
)
{
activeSet
.
add
(
t
.
name
.
replace
(
/
?
#
[
0
-
9
]
+
/
"
"
)
)
;
}
info
(
"
Sanity
checks
:
thread
list
"
)
;
Assert
.
equal
(
list
?
list
.
split
(
"
"
)
.
length
:
0
activeSet
.
size
"
The
thread
summary
list
of
active
threads
should
have
the
expected
length
"
)
;
info
(
"
Testing
that
we
can
open
the
list
of
threads
"
)
;
let
twisty
=
threads
.
getElementsByClassName
(
"
twisty
"
)
[
0
]
;
twisty
.
click
(
)
;
await
new
Promise
(
doc
.
defaultView
.
requestAnimationFrame
)
;
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
let
numberOfThreadsFound
=
0
;
for
(
let
threadRow
=
threads
.
nextSibling
;
threadRow
&
&
threadRow
.
classList
.
contains
(
"
thread
"
)
;
threadRow
=
threadRow
.
nextSibling
)
{
numberOfThreadsFound
+
+
;
}
Assert
.
equal
(
numberOfThreadsFound
number
We
should
see
{
number
}
threads
found
{
numberOfThreadsFound
}
)
;
let
threadIds
=
[
]
;
for
(
let
threadRow
=
threads
.
nextSibling
;
threadRow
&
&
threadRow
.
classList
.
contains
(
"
thread
"
)
;
threadRow
=
threadRow
.
nextSibling
)
{
Assert
.
ok
(
threadRow
.
children
.
length
>
=
3
&
&
threadRow
.
children
[
1
]
.
textContent
"
The
thread
row
should
be
populated
"
)
;
let
children
=
threadRow
.
children
;
let
cpu
=
children
[
1
]
;
let
l10nArgs
=
doc
.
l10n
.
getAttributes
(
children
[
0
]
)
.
args
;
Assert
.
ok
(
threadRow
.
thread
.
name
"
Thread
name
is
not
empty
"
)
;
Assert
.
equal
(
l10nArgs
.
name
threadRow
.
thread
.
name
"
Displayed
thread
name
is
correct
"
)
;
let
tidContent
=
l10nArgs
.
tid
;
let
tid
=
Number
.
parseInt
(
tidContent
)
;
threadIds
.
push
(
tid
)
;
Assert
.
notEqual
(
tid
0
"
The
tid
should
be
set
"
)
;
Assert
.
equal
(
tid
threadRow
.
thread
.
tid
"
Displayed
tid
is
correct
"
)
;
await
testCpu
(
cpu
threadRow
.
thread
.
totalCpu
threadRow
.
thread
.
slopeCpu
HARDCODED_ASSUMPTIONS_THREAD
)
;
}
let
threadList
=
threadIds
.
join
(
"
"
)
;
Assert
.
equal
(
threadList
threadIds
.
sort
(
(
a
b
)
=
>
a
-
b
)
.
join
(
"
"
)
"
The
thread
rows
are
in
the
default
sort
order
.
"
)
;
}
}
await
promiseAboutProcessesUpdated
(
{
doc
force
:
true
tabAboutProcesses
}
)
;
info
(
"
Testing
subframes
"
)
;
let
foundAtLeastOneInProcessSubframe
=
false
;
for
(
let
row
of
doc
.
getElementsByClassName
(
"
window
"
)
)
{
let
subframe
=
row
.
win
;
if
(
subframe
.
tab
)
{
continue
;
}
let
url
=
doc
.
l10n
.
getAttributes
(
row
.
children
[
0
]
)
.
args
.
url
;
Assert
.
equal
(
url
subframe
.
documentURI
.
spec
)
;
if
(
!
subframe
.
isProcessRoot
)
{
foundAtLeastOneInProcessSubframe
=
true
;
}
}
if
(
showAllFrames
)
{
Assert
.
ok
(
foundAtLeastOneInProcessSubframe
"
Found
at
least
one
about
:
blank
in
-
process
subframe
"
)
;
}
else
{
Assert
.
ok
(
!
foundAtLeastOneInProcessSubframe
"
We
shouldn
'
t
have
any
about
:
blank
in
-
process
subframe
"
)
;
}
info
(
"
Double
-
clicking
on
a
tab
"
)
;
let
whenTabSwitchedToWeb
=
BrowserTestUtils
.
switchTab
(
gBrowser
(
)
=
>
{
}
)
;
await
SpecialPowers
.
spawn
(
tabAboutProcesses
.
linkedBrowser
[
]
async
(
)
=
>
{
let
tbody
=
content
.
document
.
getElementById
(
"
process
-
tbody
"
)
;
for
(
let
row
of
tbody
.
getElementsByClassName
(
"
tab
"
)
)
{
if
(
row
.
parentNode
.
win
.
documentURI
.
spec
!
=
"
http
:
/
/
example
.
com
/
"
)
{
continue
;
}
let
evt
=
new
content
.
window
.
MouseEvent
(
"
dblclick
"
{
bubbles
:
true
cancelable
:
true
view
:
content
.
window
}
)
;
row
.
dispatchEvent
(
evt
)
;
return
;
}
Assert
.
ok
(
false
"
We
should
have
found
the
hung
tab
"
)
;
}
)
;
info
(
"
Waiting
for
tab
switch
"
)
;
await
whenTabSwitchedToWeb
;
Assert
.
equal
(
gBrowser
.
selectedTab
.
linkedBrowser
.
currentURI
.
spec
tabHung
.
linkedBrowser
.
currentURI
.
spec
"
We
should
have
focused
the
hung
tab
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tabAboutProcesses
)
;
info
(
"
Double
-
clicking
on
the
extensions
process
"
)
;
let
tabPromise
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
"
about
:
addons
"
)
;
await
SpecialPowers
.
spawn
(
tabAboutProcesses
.
linkedBrowser
[
]
async
(
)
=
>
{
let
extensionsRow
=
content
.
document
.
getElementsByClassName
(
"
extensions
"
)
[
0
]
;
Assert
.
ok
(
!
!
extensionsRow
"
We
should
have
found
the
extensions
process
"
)
;
let
evt
=
new
content
.
window
.
MouseEvent
(
"
dblclick
"
{
bubbles
:
true
cancelable
:
true
view
:
content
.
window
}
)
;
extensionsRow
.
dispatchEvent
(
evt
)
;
}
)
;
info
(
"
Waiting
for
about
:
addons
to
open
"
)
;
await
tabPromise
;
Assert
.
equal
(
gBrowser
.
selectedTab
.
linkedBrowser
.
currentURI
.
spec
"
about
:
addons
"
"
We
should
now
see
the
addon
tab
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
info
(
"
Testing
tab
closing
"
)
;
let
waitForProcessesToDisappear
=
[
]
;
await
promiseAboutProcessesUpdated
(
{
doc
force
:
true
tabAboutProcesses
}
)
;
if
(
isFission
)
{
for
(
let
origin
of
[
"
http
:
/
/
example
.
com
"
"
http
:
/
/
example
.
net
"
"
http
:
/
/
example
.
org
"
"
https
:
/
/
example
.
org
"
]
)
{
Assert
.
ok
(
findProcessRowByOrigin
(
doc
origin
)
There
is
a
process
for
origin
{
origin
}
)
;
}
let
userContextProcessRow
=
findProcessRowByOrigin
(
doc
"
http
:
/
/
example
.
com
^
userContextId
=
1
"
)
;
Assert
.
ok
(
userContextProcessRow
"
There
is
a
separate
process
for
the
tab
with
a
different
user
context
"
)
;
let
name
=
userContextProcessRow
.
firstChild
;
if
(
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
aboutProcesses
.
showProfilerIcons
"
)
)
{
name
=
name
.
firstChild
;
Assert
.
ok
(
name
.
nextSibling
.
classList
.
contains
(
"
profiler
-
icon
"
)
"
The
profiler
icon
should
be
shown
"
)
;
}
Assert
.
equal
(
doc
.
l10n
.
getAttributes
(
name
)
.
args
.
origin
"
http
:
/
/
example
.
com
"
+
ContextualIdentityService
.
getUserContextLabel
(
1
)
"
The
user
context
ID
should
be
replaced
with
the
localized
container
name
"
)
;
for
(
let
origin
of
[
"
http
:
/
/
example
.
net
"
"
https
:
/
/
example
.
org
"
]
)
{
let
row
=
findProcessRowByOrigin
(
doc
origin
)
;
let
childID
=
row
.
process
.
childID
;
waitForProcessesToDisappear
.
push
(
promiseProcessDied
(
{
childID
}
)
)
;
}
}
for
(
let
tab
of
[
tabCloseSeparately1
tabCloseTogether1
tabCloseTogether2
]
)
{
info
(
"
Closing
a
tab
through
about
:
processes
"
)
;
let
found
=
findTabRowByName
(
doc
tab
.
linkedBrowser
.
contentTitle
)
;
Assert
.
ok
(
found
We
should
have
found
tab
{
tab
.
linkedBrowser
.
contentTitle
}
to
close
it
)
;
let
closeIcons
=
found
.
getElementsByClassName
(
"
close
-
icon
"
)
;
Assert
.
equal
(
closeIcons
.
length
1
"
This
tab
should
have
exactly
one
close
icon
"
)
;
closeIcons
[
0
]
.
click
(
)
;
Assert
.
ok
(
found
.
classList
.
contains
(
"
killing
"
)
"
We
should
have
marked
the
row
as
dying
"
)
;
}
if
(
isFission
)
{
info
(
"
Closing
an
entire
process
through
about
:
processes
"
)
;
let
found
=
findProcessRowByOrigin
(
doc
"
http
:
/
/
example
.
net
"
)
;
let
closeIcons
=
found
.
getElementsByClassName
(
"
close
-
icon
"
)
;
Assert
.
equal
(
closeIcons
.
length
1
"
This
process
should
have
exactly
one
close
icon
"
)
;
closeIcons
[
0
]
.
click
(
)
;
Assert
.
ok
(
found
.
classList
.
contains
(
"
killing
"
)
"
We
should
have
marked
the
row
as
dying
"
)
;
info
(
"
Closing
the
audio
utility
process
through
about
:
processes
"
)
;
let
utilityRow
;
for
(
let
row
of
doc
.
getElementsByClassName
(
"
process
"
)
)
{
if
(
row
.
process
.
type
=
=
"
utility
"
)
{
utilityRow
=
row
;
break
;
}
}
Assert
.
ok
(
utilityRow
"
Should
have
found
audio
utility
row
.
"
)
;
closeIcons
=
utilityRow
.
getElementsByClassName
(
"
close
-
icon
"
)
;
Assert
.
equal
(
closeIcons
.
length
1
"
The
utility
process
should
have
exactly
one
close
icon
"
)
;
closeIcons
[
0
]
.
click
(
)
;
Assert
.
ok
(
utilityRow
.
classList
.
contains
(
"
killing
"
)
"
We
should
have
marked
the
utility
process
as
dying
"
)
;
}
await
promiseAboutProcessesUpdated
(
{
doc
force
:
true
tabAboutProcesses
}
)
;
for
(
let
{
origin
tab
}
of
[
{
origin
:
"
http
:
/
/
example
.
org
"
tab
:
tabCloseSeparately1
}
{
origin
:
"
https
:
/
/
example
.
org
"
tab
:
tabCloseTogether1
}
{
origin
:
"
https
:
/
/
example
.
org
"
tab
:
tabCloseTogether2
}
.
.
.
(
isFission
?
[
{
origin
:
"
http
:
/
/
example
.
net
"
tab
:
tabCloseProcess1
}
{
origin
:
"
http
:
/
/
example
.
net
"
tab
:
tabCloseProcess2
}
]
:
[
]
)
]
)
{
Assert
.
ok
(
!
findTabRowByName
(
doc
origin
)
Tab
for
{
origin
}
shouldn
'
t
show
up
anymore
in
about
:
processes
)
;
Assert
.
ok
(
!
tab
.
getAttribute
(
"
linkedPanel
"
)
The
tab
should
now
be
unloaded
(
{
tab
.
testOrigin
}
-
{
tab
.
testTitle
}
)
)
;
}
Assert
.
ok
(
tabCloseSeparately2
.
linkedBrowser
"
Killing
one
tab
in
the
domain
should
not
have
closed
the
other
tab
"
)
;
let
foundtabCloseSeparately2
=
findTabRowByName
(
doc
tabCloseSeparately2
.
linkedBrowser
.
contentTitle
)
;
Assert
.
ok
(
foundtabCloseSeparately2
"
The
second
tab
is
still
visible
in
about
:
processes
"
)
;
if
(
isFission
)
{
for
(
let
origin
of
[
"
http
:
/
/
example
.
com
"
"
http
:
/
/
example
.
org
"
]
)
{
Assert
.
ok
(
findProcessRowByOrigin
(
doc
origin
)
There
should
still
be
a
process
row
for
origin
{
origin
}
)
;
}
info
(
"
Waiting
for
processes
to
die
"
)
;
await
Promise
.
all
(
waitForProcessesToDisappear
)
;
info
(
"
Waiting
for
about
:
processes
to
be
updated
"
)
;
await
promiseAboutProcessesUpdated
(
{
doc
force
:
true
tabAboutProcesses
}
)
;
for
(
let
origin
of
[
"
http
:
/
/
example
.
net
"
"
https
:
/
/
example
.
org
"
]
)
{
Assert
.
ok
(
!
findProcessRowByOrigin
(
doc
origin
)
Process
{
origin
}
should
disappear
from
about
:
processes
)
;
}
}
info
(
"
Additional
sanity
check
for
all
processes
"
)
;
for
(
let
row
of
doc
.
getElementsByClassName
(
"
process
"
)
)
{
let
{
pidContent
}
=
extractProcessDetails
(
row
)
;
Assert
.
equal
(
Number
.
parseInt
(
pidContent
)
row
.
process
.
pid
)
;
}
BrowserTestUtils
.
removeTab
(
tabAboutProcesses
)
;
BrowserTestUtils
.
removeTab
(
tabHung
)
;
BrowserTestUtils
.
removeTab
(
tabUserContext
)
;
BrowserTestUtils
.
removeTab
(
tabCloseSeparately2
)
;
BrowserTestUtils
.
removeTab
(
tabCloseProcess1
)
;
BrowserTestUtils
.
removeTab
(
tabCloseProcess2
)
;
BrowserTestUtils
.
removeTab
(
audioPlayback
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
await
extension
.
unload
(
)
;
}
