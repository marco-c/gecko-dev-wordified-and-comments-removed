"
use
strict
"
;
const
TIME_BEFORE_SORTING_AGAIN
=
5000
;
const
BUFFER_SAMPLING_RATE_MS
=
1000
;
const
BUFFER_DURATION_MS
=
10000
;
const
UPDATE_INTERVAL_MS
=
2000
;
const
MS_PER_NS
=
1000000
;
const
NS_PER_S
=
1000000000
;
const
ONE_GIGA
=
1024
*
1024
*
1024
;
const
ONE_MEGA
=
1024
*
1024
;
const
ONE_KILO
=
1024
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
function
wait
(
ms
=
0
)
{
try
{
let
resolve
;
let
p
=
new
Promise
(
resolve_
=
>
{
resolve
=
resolve_
;
}
)
;
setTimeout
(
resolve
ms
)
;
return
p
;
}
catch
(
e
)
{
dump
(
"
WARNING
:
wait
aborted
because
of
an
invalid
Window
state
in
aboutPerformance
.
js
.
\
n
"
)
;
return
undefined
;
}
}
var
State
=
{
_buffer
:
[
]
_latest
:
null
async
_promiseSnapshot
(
)
{
let
date
=
Cu
.
now
(
)
;
let
main
=
await
ChromeUtils
.
requestProcInfo
(
)
;
main
.
date
=
date
;
let
processes
=
new
Map
(
)
;
processes
.
set
(
main
.
pid
main
)
;
for
(
let
child
of
main
.
children
)
{
child
.
date
=
date
;
processes
.
set
(
child
.
pid
child
)
;
}
return
{
processes
date
}
;
}
async
update
(
)
{
if
(
!
this
.
_buffer
.
length
)
{
this
.
_latest
=
await
this
.
_promiseSnapshot
(
)
;
this
.
_buffer
.
push
(
this
.
_latest
)
;
await
wait
(
BUFFER_SAMPLING_RATE_MS
*
1
.
1
)
;
}
let
now
=
Cu
.
now
(
)
;
let
latestInBuffer
=
this
.
_buffer
[
this
.
_buffer
.
length
-
1
]
;
let
deltaT
=
now
-
latestInBuffer
.
date
;
if
(
deltaT
>
BUFFER_SAMPLING_RATE_MS
)
{
this
.
_latest
=
await
this
.
_promiseSnapshot
(
)
;
this
.
_buffer
.
push
(
this
.
_latest
)
;
}
let
oldestInBuffer
=
this
.
_buffer
[
0
]
;
if
(
oldestInBuffer
.
date
+
BUFFER_DURATION_MS
<
this
.
_latest
.
date
)
{
this
.
_buffer
.
shift
(
)
;
}
}
_getThreadDelta
(
cur
prev
deltaT
)
{
let
name
=
cur
.
name
|
|
"
?
?
?
"
;
let
result
=
{
tid
:
cur
.
tid
name
totalCpuUser
:
cur
.
cpuUser
slopeCpuUser
:
null
totalCpuKernel
:
cur
.
cpuKernel
slopeCpuKernel
:
null
totalCpu
:
cur
.
cpuUser
+
cur
.
cpuKernel
slopeCpu
:
null
}
;
if
(
!
prev
)
{
return
result
;
}
if
(
prev
.
tid
!
=
cur
.
tid
)
{
throw
new
Error
(
"
Assertion
failed
:
A
thread
cannot
change
tid
.
"
)
;
}
result
.
slopeCpuUser
=
(
cur
.
cpuUser
-
prev
.
cpuUser
)
/
deltaT
;
result
.
slopeCpuKernel
=
(
cur
.
cpuKernel
-
prev
.
cpuKernel
)
/
deltaT
;
result
.
slopeCpu
=
result
.
slopeCpuKernel
+
result
.
slopeCpuUser
;
return
result
;
}
_getProcessDelta
(
cur
prev
)
{
let
result
=
{
pid
:
cur
.
pid
childID
:
cur
.
childID
filename
:
cur
.
filename
totalResidentUniqueSize
:
cur
.
residentUniqueSize
deltaResidentUniqueSize
:
null
totalCpuUser
:
cur
.
cpuUser
slopeCpuUser
:
null
totalCpuKernel
:
cur
.
cpuKernel
slopeCpuKernel
:
null
totalCpu
:
cur
.
cpuUser
+
cur
.
cpuKernel
slopeCpu
:
null
type
:
cur
.
type
origin
:
cur
.
origin
|
|
"
"
threads
:
null
displayRank
:
Control
.
_getDisplayGroupRank
(
cur
.
type
)
}
;
if
(
!
prev
)
{
result
.
threads
=
cur
.
threads
.
map
(
data
=
>
this
.
_getThreadDelta
(
data
null
null
)
)
;
return
result
;
}
if
(
prev
.
pid
!
=
cur
.
pid
)
{
throw
new
Error
(
"
Assertion
failed
:
A
process
cannot
change
pid
.
"
)
;
}
let
prevThreads
=
new
Map
(
)
;
for
(
let
thread
of
prev
.
threads
)
{
prevThreads
.
set
(
thread
.
tid
thread
)
;
}
let
deltaT
=
(
cur
.
date
-
prev
.
date
)
*
MS_PER_NS
;
let
threads
=
cur
.
threads
.
map
(
curThread
=
>
{
let
prevThread
=
prevThreads
.
get
(
curThread
.
tid
)
;
if
(
!
prevThread
)
{
return
this
.
_getThreadDelta
(
curThread
)
;
}
return
this
.
_getThreadDelta
(
curThread
prevThread
deltaT
)
;
}
)
;
result
.
deltaResidentUniqueSize
=
cur
.
residentUniqueSize
-
prev
.
residentUniqueSize
;
result
.
slopeCpuUser
=
(
cur
.
cpuUser
-
prev
.
cpuUser
)
/
deltaT
;
result
.
slopeCpuKernel
=
(
cur
.
cpuKernel
-
prev
.
cpuKernel
)
/
deltaT
;
result
.
slopeCpu
=
result
.
slopeCpuUser
+
result
.
slopeCpuKernel
;
result
.
threads
=
threads
;
return
result
;
}
getCounters
(
)
{
let
current
=
this
.
_latest
;
let
counters
=
[
]
;
for
(
let
cur
of
current
.
processes
.
values
(
)
)
{
let
oldest
=
null
;
let
delta
;
for
(
let
index
=
0
;
index
<
=
this
.
_buffer
.
length
-
2
;
+
+
index
)
{
oldest
=
this
.
_buffer
[
index
]
.
processes
.
get
(
cur
.
pid
)
;
if
(
oldest
)
{
break
;
}
}
if
(
oldest
)
{
delta
=
this
.
_getProcessDelta
(
cur
oldest
)
;
}
else
{
delta
=
this
.
_getProcessDelta
(
cur
null
)
;
}
counters
.
push
(
delta
)
;
}
return
counters
;
}
}
;
var
View
=
{
_fragment
:
document
.
createDocumentFragment
(
)
async
commit
(
)
{
let
tbody
=
document
.
getElementById
(
"
process
-
tbody
"
)
;
await
document
.
l10n
.
translateFragment
(
this
.
_fragment
)
;
while
(
tbody
.
firstChild
)
{
tbody
.
firstChild
.
remove
(
)
;
}
tbody
.
appendChild
(
this
.
_fragment
)
;
this
.
_fragment
=
document
.
createDocumentFragment
(
)
;
}
insertAfterRow
(
row
)
{
row
.
parentNode
.
insertBefore
(
this
.
_fragment
row
.
nextSibling
)
;
this
.
_fragment
=
document
.
createDocumentFragment
(
)
;
}
appendProcessRow
(
data
)
{
let
row
=
document
.
createElement
(
"
tr
"
)
;
row
.
classList
.
add
(
"
process
"
)
;
if
(
data
.
isHung
)
{
row
.
classList
.
add
(
"
hung
"
)
;
}
{
let
content
=
data
.
origin
?
{
data
.
origin
}
(
{
data
.
type
}
)
:
data
.
type
;
let
elt
=
this
.
_addCell
(
row
{
content
classes
:
[
"
type
"
]
}
)
;
if
(
data
.
threads
.
length
)
{
let
img
=
document
.
createElement
(
"
span
"
)
;
img
.
classList
.
add
(
"
twisty
"
"
process
"
)
;
if
(
data
.
isOpen
)
{
img
.
classList
.
add
(
"
open
"
)
;
}
elt
.
insertBefore
(
img
elt
.
firstChild
)
;
}
}
{
let
{
formatedDelta
formatedValue
}
=
this
.
_formatMemoryAndDelta
(
data
.
totalResidentUniqueSize
data
.
deltaResidentUniqueSize
)
;
let
content
=
formatedDelta
?
{
formatedValue
}
{
formatedDelta
}
:
formatedValue
;
this
.
_addCell
(
row
{
content
classes
:
[
"
totalMemorySize
"
]
}
)
;
}
{
let
slope
=
this
.
_formatPercentage
(
data
.
slopeCpu
)
;
let
content
=
{
slope
}
(
{
(
data
.
totalCpu
/
MS_PER_NS
)
.
toLocaleString
(
undefined
{
maximumFractionDigits
:
0
}
)
}
ms
)
;
this
.
_addCell
(
row
{
content
classes
:
[
"
cpu
"
]
}
)
;
}
this
.
_addCell
(
row
{
content
:
data
.
pid
classes
:
[
"
pid
"
"
root
"
]
}
)
;
this
.
_addCell
(
row
{
content
:
data
.
threads
.
length
classes
:
[
"
numberOfThreads
"
]
}
)
;
this
.
_fragment
.
appendChild
(
row
)
;
return
row
;
}
appendThreadRow
(
data
)
{
let
row
=
document
.
createElement
(
"
tr
"
)
;
row
.
classList
.
add
(
"
thread
"
)
;
this
.
_addCell
(
row
{
content
:
data
.
name
classes
:
[
"
name
"
"
indent
"
]
}
)
;
this
.
_addCell
(
row
{
content
:
"
"
classes
:
[
"
totalResidentSize
"
]
}
)
;
{
let
slope
=
this
.
_formatPercentage
(
data
.
slopeCpu
)
;
let
text
=
{
slope
}
(
{
(
data
.
totalCpu
/
MS_PER_NS
)
.
toLocaleString
(
undefined
{
maximumFractionDigits
:
0
}
)
}
ms
)
;
this
.
_addCell
(
row
{
content
:
text
classes
:
[
"
cpu
"
]
}
)
;
}
this
.
_addCell
(
row
{
content
:
data
.
tid
classes
:
[
"
tid
"
]
}
)
;
this
.
_addCell
(
row
{
content
:
"
"
classes
:
[
"
numberOfThreads
"
]
}
)
;
this
.
_fragment
.
appendChild
(
row
)
;
return
row
;
}
_addCell
(
row
{
content
classes
}
)
{
let
elt
=
document
.
createElement
(
"
td
"
)
;
this
.
_setTextAndTooltip
(
elt
content
)
;
elt
.
classList
.
add
(
.
.
.
classes
)
;
row
.
appendChild
(
elt
)
;
return
elt
;
}
_formatPercentage
(
value
)
{
if
(
value
=
=
null
)
{
return
"
?
"
;
}
if
(
value
<
0
|
|
typeof
value
!
=
"
number
"
)
{
throw
new
Error
(
Invalid
percentage
value
{
value
}
)
;
}
if
(
value
=
=
0
)
{
return
"
idle
"
;
}
let
percentage
=
value
*
100
;
if
(
percentage
<
0
.
01
)
{
return
"
~
0
%
"
;
}
if
(
percentage
<
1
)
{
return
{
percentage
.
toLocaleString
(
undefined
{
maximumFractionDigits
:
2
}
)
}
%
;
}
return
{
Math
.
round
(
percentage
)
}
%
;
}
_formatMemory
(
value
)
{
if
(
value
=
=
null
)
{
return
{
unit
:
"
?
"
amount
:
0
}
;
}
if
(
value
<
0
|
|
typeof
value
!
=
"
number
"
)
{
throw
new
Error
(
Invalid
memory
value
{
value
}
)
;
}
if
(
value
>
=
ONE_GIGA
)
{
return
{
unit
:
"
GB
"
amount
:
Math
.
ceil
(
(
value
/
ONE_GIGA
)
*
100
)
/
100
}
;
}
if
(
value
>
=
ONE_MEGA
)
{
return
{
unit
:
"
MB
"
amount
:
Math
.
ceil
(
(
value
/
ONE_MEGA
)
*
100
)
/
100
}
;
}
if
(
value
>
=
ONE_KILO
)
{
return
{
unit
:
"
KB
"
amount
:
Math
.
ceil
(
(
value
/
ONE_KILO
)
*
100
)
/
100
}
;
}
return
{
unit
:
"
B
"
amount
:
Math
.
round
(
value
)
}
;
}
_formatMemoryAndDelta
(
value
delta
)
{
let
formatedDelta
;
let
unitDelta
;
if
(
delta
=
=
null
)
{
formatedDelta
=
=
"
"
;
unitDelta
=
null
;
}
else
if
(
delta
=
=
0
)
{
formatedDelta
=
null
;
unitDelta
=
null
;
}
else
if
(
delta
>
=
0
)
{
let
{
unit
amount
}
=
this
.
_formatMemory
(
delta
)
;
formatedDelta
=
(
+
{
amount
}
{
unit
}
)
;
unitDelta
=
unit
;
}
else
{
let
{
unit
amount
}
=
this
.
_formatMemory
(
-
delta
)
;
formatedDelta
=
(
-
{
amount
}
{
unit
}
)
;
unitDelta
=
unit
;
}
let
{
unit
:
unitValue
amount
}
=
this
.
_formatMemory
(
value
)
;
return
{
unitValue
unitDelta
formatedDelta
formatedValue
:
{
amount
}
{
unitValue
}
}
;
}
_setTextAndTooltip
(
elt
text
tooltip
=
text
)
{
elt
.
textContent
=
text
;
elt
.
setAttribute
(
"
title
"
tooltip
)
;
}
}
;
var
Control
=
{
_openItems
:
new
Set
(
)
_hungItems
:
new
Set
(
)
_sortColumn
:
null
_sortAscendent
:
true
_removeSubtree
(
row
)
{
while
(
row
.
nextSibling
&
&
row
.
nextSibling
.
classList
.
contains
(
"
thread
"
)
)
{
row
.
nextSibling
.
remove
(
)
;
}
}
init
(
)
{
this
.
_initHangReports
(
)
;
let
tbody
=
document
.
getElementById
(
"
process
-
tbody
"
)
;
tbody
.
addEventListener
(
"
click
"
event
=
>
{
this
.
_updateLastMouseEvent
(
)
;
let
target
=
event
.
target
;
if
(
target
.
classList
.
contains
(
"
twisty
"
)
)
{
let
row
=
target
.
parentNode
.
parentNode
;
let
id
=
row
.
process
.
pid
;
if
(
target
.
classList
.
toggle
(
"
open
"
)
)
{
this
.
_openItems
.
add
(
id
)
;
this
.
_showChildren
(
row
)
;
View
.
insertAfterRow
(
row
)
;
}
else
{
this
.
_openItems
.
delete
(
id
)
;
this
.
_removeSubtree
(
row
)
;
}
return
;
}
let
row
=
target
.
parentNode
;
if
(
this
.
selectedRow
)
{
this
.
selectedRow
.
removeAttribute
(
"
selected
"
)
;
}
if
(
row
.
windowId
)
{
row
.
setAttribute
(
"
selected
"
"
true
"
)
;
this
.
selectedRow
=
row
;
}
else
if
(
this
.
selectedRow
)
{
this
.
selectedRow
=
null
;
}
}
)
;
tbody
.
addEventListener
(
"
mousemove
"
(
)
=
>
{
this
.
_updateLastMouseEvent
(
)
;
}
)
;
window
.
addEventListener
(
"
visibilitychange
"
event
=
>
{
if
(
!
document
.
hidden
)
{
this
.
_updateDisplay
(
true
)
;
}
}
)
;
document
.
getElementById
(
"
process
-
thead
"
)
.
addEventListener
(
"
click
"
async
event
=
>
{
if
(
!
event
.
target
.
classList
.
contains
(
"
clickable
"
)
)
{
return
;
}
if
(
this
.
_sortColumn
)
{
const
td
=
document
.
getElementById
(
this
.
_sortColumn
)
;
td
.
classList
.
remove
(
"
asc
"
)
;
td
.
classList
.
remove
(
"
desc
"
)
;
}
const
columnId
=
event
.
target
.
id
;
if
(
columnId
=
=
this
.
_sortColumn
)
{
this
.
_sortAscendent
=
!
this
.
_sortAscendent
;
}
else
{
this
.
_sortColumn
=
columnId
;
this
.
_sortAscendent
=
true
;
}
if
(
this
.
_sortAscendent
)
{
event
.
target
.
classList
.
remove
(
"
desc
"
)
;
event
.
target
.
classList
.
add
(
"
asc
"
)
;
}
else
{
event
.
target
.
classList
.
remove
(
"
asc
"
)
;
event
.
target
.
classList
.
add
(
"
desc
"
)
;
}
await
this
.
_updateDisplay
(
true
)
;
}
)
;
}
_lastMouseEvent
:
0
_updateLastMouseEvent
(
)
{
this
.
_lastMouseEvent
=
Date
.
now
(
)
;
}
_initHangReports
(
)
{
const
PROCESS_HANG_REPORT_NOTIFICATION
=
"
process
-
hang
-
report
"
;
let
hangReporter
=
report
=
>
{
report
.
QueryInterface
(
Ci
.
nsIHangReport
)
;
this
.
_hungItems
.
add
(
report
.
childID
)
;
}
;
Services
.
obs
.
addObserver
(
hangReporter
PROCESS_HANG_REPORT_NOTIFICATION
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Services
.
obs
.
removeObserver
(
hangReporter
PROCESS_HANG_REPORT_NOTIFICATION
)
;
}
{
once
:
true
}
)
;
}
async
update
(
)
{
await
State
.
update
(
)
;
if
(
document
.
hidden
)
{
return
;
}
await
wait
(
0
)
;
await
this
.
_updateDisplay
(
)
;
}
async
_updateDisplay
(
force
=
false
)
{
if
(
!
force
&
&
Date
.
now
(
)
-
this
.
_lastMouseEvent
<
TIME_BEFORE_SORTING_AGAIN
)
{
return
;
}
let
counters
=
State
.
getCounters
(
)
;
let
openItems
=
this
.
_openItems
;
this
.
_openItems
=
new
Set
(
)
;
let
hungItems
=
this
.
_hungItems
;
this
.
_hungItems
=
new
Set
(
)
;
counters
=
this
.
_sortProcesses
(
counters
)
;
let
previousRow
=
null
;
let
previousProcess
=
null
;
for
(
let
process
of
counters
)
{
let
isOpen
=
openItems
.
has
(
process
.
pid
)
;
process
.
isOpen
=
isOpen
;
let
isHung
=
process
.
childID
&
&
hungItems
.
has
(
process
.
childID
)
;
process
.
isHung
=
isHung
;
let
processRow
=
View
.
appendProcessRow
(
process
isOpen
)
;
processRow
.
process
=
process
;
let
latestRow
=
processRow
;
if
(
isOpen
)
{
this
.
_openItems
.
add
(
process
.
pid
)
;
latestRow
=
this
.
_showChildren
(
processRow
)
;
}
if
(
this
.
_sortColumn
=
=
null
&
&
previousProcess
&
&
previousProcess
.
displayRank
!
=
process
.
displayRank
)
{
previousRow
.
classList
.
add
(
"
separate
-
from
-
next
-
process
-
group
"
)
;
}
previousProcess
=
process
;
previousRow
=
latestRow
;
}
await
View
.
commit
(
)
;
}
_showChildren
(
row
)
{
let
process
=
row
.
process
;
this
.
_sortThreads
(
process
.
threads
)
;
let
elt
=
row
;
for
(
let
thread
of
process
.
threads
)
{
elt
=
View
.
appendThreadRow
(
thread
)
;
elt
.
thread
=
thread
;
}
return
elt
;
}
_sortThreads
(
threads
)
{
return
threads
.
sort
(
(
a
b
)
=
>
{
let
order
;
switch
(
this
.
_sortColumn
)
{
case
"
column
-
name
"
:
order
=
a
.
name
.
localeCompare
(
b
.
name
)
;
break
;
case
"
column
-
cpu
-
total
"
:
order
=
b
.
totalCpu
-
a
.
totalCpu
;
if
(
order
=
=
0
)
{
order
=
b
.
totalCpu
-
a
.
totalCpu
;
}
break
;
case
"
column
-
cpu
-
threads
"
:
case
"
column
-
memory
-
resident
"
:
case
"
column
-
type
"
:
case
"
column
-
pid
"
:
case
null
:
order
=
b
.
tid
-
a
.
tid
;
break
;
default
:
throw
new
Error
(
"
Unsupported
order
:
"
+
this
.
_sortColumn
)
;
}
if
(
!
this
.
_sortAscendent
)
{
order
=
-
order
;
}
return
order
;
}
)
;
}
_sortProcesses
(
counters
)
{
return
counters
.
sort
(
(
a
b
)
=
>
{
let
order
;
switch
(
this
.
_sortColumn
)
{
case
"
column
-
pid
"
:
order
=
b
.
pid
-
a
.
pid
;
break
;
case
"
column
-
type
"
:
order
=
String
(
a
.
origin
)
.
localeCompare
(
b
.
origin
)
;
if
(
order
=
=
0
)
{
order
=
String
(
a
.
type
)
.
localeCompare
(
b
.
type
)
;
}
break
;
case
"
column
-
name
"
:
order
=
String
(
a
.
name
)
.
localeCompare
(
b
.
name
)
;
break
;
case
"
column
-
cpu
-
total
"
:
order
=
b
.
totalCpu
-
a
.
totalCpu
;
if
(
order
=
=
0
)
{
order
=
b
.
totalCpu
-
a
.
totalCpu
;
}
break
;
case
"
column
-
cpu
-
threads
"
:
order
=
b
.
threads
.
length
-
a
.
threads
.
length
;
break
;
case
"
column
-
memory
-
resident
"
:
order
=
b
.
totalResidentUniqueSize
-
a
.
totalResidentUniqueSize
;
break
;
case
null
:
order
=
a
.
displayRank
-
b
.
displayRank
;
if
(
order
=
=
0
)
{
order
=
String
(
a
.
name
)
.
localeCompare
(
b
.
name
)
;
if
(
order
=
=
0
)
{
order
=
b
.
slopeCpuUser
-
a
.
slopeCpuUser
;
}
}
break
;
default
:
throw
new
Error
(
"
Unsupported
order
:
"
+
this
.
_sortColumn
)
;
}
if
(
!
this
.
_sortAscendent
)
{
order
=
-
order
;
}
return
order
;
}
)
;
}
_getDisplayGroupRank
(
type
)
{
switch
(
type
)
{
case
"
browser
"
:
return
0
;
case
"
web
"
:
case
"
webIsolated
"
:
case
"
webLargeAllocation
"
:
case
"
withCoopCoep
"
:
return
1
;
case
"
preallocated
"
:
return
3
;
default
:
return
2
;
}
}
}
;
window
.
onload
=
async
function
(
)
{
Control
.
init
(
)
;
await
Control
.
update
(
)
;
window
.
setInterval
(
(
)
=
>
Control
.
update
(
)
UPDATE_INTERVAL_MS
)
;
}
;
