"
use
strict
"
;
const
TIME_BEFORE_SORTING_AGAIN
=
5000
;
const
MINIMUM_INTERVAL_BETWEEN_SAMPLES_MS
=
1000
;
const
UPDATE_INTERVAL_MS
=
2000
;
const
NS_PER_US
=
1000
;
const
NS_PER_MS
=
1000
*
1000
;
const
NS_PER_S
=
1000
*
1000
*
1000
;
const
NS_PER_MIN
=
NS_PER_S
*
60
;
const
NS_PER_HOUR
=
NS_PER_MIN
*
60
;
const
NS_PER_DAY
=
NS_PER_HOUR
*
24
;
const
ONE_GIGA
=
1024
*
1024
*
1024
;
const
ONE_MEGA
=
1024
*
1024
;
const
ONE_KILO
=
1024
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ContextualIdentityService
:
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ProfilerPopupBackground
"
function
(
)
{
return
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
popup
/
background
.
jsm
.
js
"
)
;
}
)
;
const
{
WebExtensionPolicy
}
=
Cu
.
getGlobalForObject
(
Services
)
;
const
SHOW_THREADS
=
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
aboutProcesses
.
showThreads
"
)
;
const
SHOW_ALL_SUBFRAMES
=
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
aboutProcesses
.
showAllSubframes
"
)
;
const
SHOW_PROFILER_ICONS
=
Services
.
prefs
.
getBoolPref
(
"
toolkit
.
aboutProcesses
.
showProfilerIcons
"
)
;
const
PROFILE_DURATION
=
Math
.
max
(
1
Services
.
prefs
.
getIntPref
(
"
toolkit
.
aboutProcesses
.
profileDuration
"
)
)
;
let
gLocalizedUnits
;
let
tabFinder
=
{
update
(
)
{
this
.
_map
=
new
Map
(
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
let
tabbrowser
=
win
.
gBrowser
;
for
(
let
browser
of
tabbrowser
.
browsers
)
{
let
id
=
browser
.
outerWindowID
;
if
(
id
!
=
null
)
{
this
.
_map
.
set
(
id
browser
)
;
}
}
if
(
tabbrowser
.
preloadedBrowser
)
{
let
browser
=
tabbrowser
.
preloadedBrowser
;
if
(
browser
.
outerWindowID
)
{
this
.
_map
.
set
(
browser
.
outerWindowID
browser
)
;
}
}
}
}
get
(
id
)
{
let
browser
=
this
.
_map
.
get
(
id
)
;
if
(
!
browser
)
{
return
null
;
}
let
tabbrowser
=
browser
.
getTabBrowser
(
)
;
if
(
!
tabbrowser
)
{
return
{
tabbrowser
:
null
tab
:
{
getAttribute
(
)
{
return
"
"
;
}
linkedBrowser
:
browser
}
}
;
}
return
{
tabbrowser
tab
:
tabbrowser
.
getTabForBrowser
(
browser
)
}
;
}
}
;
var
State
=
{
_previous
:
null
_latest
:
null
async
_promiseSnapshot
(
)
{
let
date
=
Cu
.
now
(
)
;
let
main
=
await
ChromeUtils
.
requestProcInfo
(
)
;
main
.
date
=
date
;
let
processes
=
new
Map
(
)
;
processes
.
set
(
main
.
pid
main
)
;
for
(
let
child
of
main
.
children
)
{
child
.
date
=
date
;
processes
.
set
(
child
.
pid
child
)
;
}
return
{
processes
date
}
;
}
async
update
(
force
=
false
)
{
if
(
force
|
|
!
this
.
_latest
|
|
Cu
.
now
(
)
-
this
.
_latest
.
date
>
MINIMUM_INTERVAL_BETWEEN_SAMPLES_MS
)
{
let
newSnapshot
=
await
this
.
_promiseSnapshot
(
)
;
this
.
_previous
=
this
.
_latest
;
this
.
_latest
=
newSnapshot
;
}
}
_getThreadDelta
(
cur
prev
deltaT
)
{
let
result
=
{
tid
:
cur
.
tid
name
:
cur
.
name
|
|
(
{
cur
.
tid
}
)
totalCpu
:
cur
.
cpuTime
slopeCpu
:
null
active
:
null
}
;
if
(
!
deltaT
)
{
return
result
;
}
result
.
slopeCpu
=
(
result
.
totalCpu
-
(
prev
?
prev
.
cpuTime
:
0
)
)
/
deltaT
;
result
.
active
=
!
!
result
.
slopeCpu
|
|
cur
.
cpuCycleCount
>
(
prev
?
prev
.
cpuCycleCount
:
0
)
;
return
result
;
}
_getDOMWindows
(
process
)
{
if
(
!
process
.
windows
)
{
return
[
]
;
}
if
(
!
process
.
type
=
=
"
extensions
"
)
{
return
[
]
;
}
let
windows
=
process
.
windows
.
map
(
win
=
>
{
let
tab
=
tabFinder
.
get
(
win
.
outerWindowId
)
;
let
addon
=
process
.
type
=
=
"
extension
"
?
WebExtensionPolicy
.
getByURI
(
win
.
documentURI
)
:
null
;
let
displayRank
;
if
(
tab
)
{
displayRank
=
1
;
}
else
if
(
win
.
isProcessRoot
)
{
displayRank
=
2
;
}
else
if
(
win
.
documentTitle
)
{
displayRank
=
3
;
}
else
{
displayRank
=
4
;
}
return
{
outerWindowId
:
win
.
outerWindowId
documentURI
:
win
.
documentURI
documentTitle
:
win
.
documentTitle
isProcessRoot
:
win
.
isProcessRoot
isInProcess
:
win
.
isInProcess
tab
addon
count
:
1
displayRank
}
;
}
)
;
let
collapsible
=
new
Map
(
)
;
let
result
=
[
]
;
for
(
let
win
of
windows
)
{
if
(
win
.
tab
|
|
win
.
addon
)
{
result
.
push
(
win
)
;
continue
;
}
let
prev
=
collapsible
.
get
(
win
.
documentURI
.
prePath
)
;
if
(
prev
)
{
prev
.
count
+
=
1
;
}
else
{
collapsible
.
set
(
win
.
documentURI
.
prePath
win
)
;
result
.
push
(
win
)
;
}
}
return
result
;
}
_getProcessDelta
(
cur
prev
)
{
let
windows
=
this
.
_getDOMWindows
(
cur
)
;
let
result
=
{
pid
:
cur
.
pid
childID
:
cur
.
childID
totalRamSize
:
cur
.
memory
deltaRamSize
:
null
totalCpu
:
cur
.
cpuTime
slopeCpu
:
null
active
:
null
type
:
cur
.
type
origin
:
cur
.
origin
|
|
"
"
threads
:
null
displayRank
:
Control
.
_getDisplayGroupRank
(
cur
windows
)
windows
title
:
null
}
;
let
titles
=
[
.
.
.
new
Set
(
result
.
windows
.
filter
(
win
=
>
win
.
documentTitle
)
.
map
(
win
=
>
win
.
documentTitle
)
)
]
;
if
(
titles
.
length
=
=
1
)
{
result
.
title
=
titles
[
0
]
;
}
if
(
!
prev
)
{
if
(
SHOW_THREADS
)
{
result
.
threads
=
cur
.
threads
.
map
(
data
=
>
this
.
_getThreadDelta
(
data
)
)
;
}
return
result
;
}
if
(
prev
.
pid
!
=
cur
.
pid
)
{
throw
new
Error
(
"
Assertion
failed
:
A
process
cannot
change
pid
.
"
)
;
}
let
deltaT
=
(
cur
.
date
-
prev
.
date
)
*
NS_PER_MS
;
let
threads
=
null
;
if
(
SHOW_THREADS
)
{
let
prevThreads
=
new
Map
(
)
;
for
(
let
thread
of
prev
.
threads
)
{
prevThreads
.
set
(
thread
.
tid
thread
)
;
}
threads
=
cur
.
threads
.
map
(
curThread
=
>
this
.
_getThreadDelta
(
curThread
prevThreads
.
get
(
curThread
.
tid
)
deltaT
)
)
;
}
result
.
deltaRamSize
=
cur
.
memory
-
prev
.
memory
;
result
.
slopeCpu
=
(
cur
.
cpuTime
-
prev
.
cpuTime
)
/
deltaT
;
result
.
active
=
!
!
result
.
slopeCpu
|
|
cur
.
cpuCycleCount
>
prev
.
cpuCycleCount
;
result
.
threads
=
threads
;
return
result
;
}
getCounters
(
)
{
tabFinder
.
update
(
)
;
let
counters
=
[
]
;
for
(
let
cur
of
this
.
_latest
.
processes
.
values
(
)
)
{
let
prev
=
this
.
_previous
?
.
processes
.
get
(
cur
.
pid
)
;
counters
.
push
(
this
.
_getProcessDelta
(
cur
prev
)
)
;
}
return
counters
;
}
}
;
var
View
=
{
_killedRecently
:
[
]
commit
(
)
{
this
.
_killedRecently
.
length
=
0
;
let
tbody
=
document
.
getElementById
(
"
process
-
tbody
"
)
;
let
insertPoint
=
tbody
.
firstChild
;
let
nextRow
;
while
(
(
nextRow
=
this
.
_orderedRows
.
shift
(
)
)
)
{
if
(
insertPoint
&
&
insertPoint
=
=
=
nextRow
)
{
insertPoint
=
insertPoint
.
nextSibling
;
}
else
{
tbody
.
insertBefore
(
nextRow
insertPoint
)
;
}
}
if
(
insertPoint
)
{
while
(
(
nextRow
=
insertPoint
.
nextSibling
)
)
{
this
.
_removeRow
(
nextRow
)
;
}
this
.
_removeRow
(
insertPoint
)
;
}
}
discardUpdate
(
)
{
for
(
let
row
of
this
.
_orderedRows
)
{
if
(
!
row
.
parentNode
)
{
this
.
_rowsById
.
delete
(
row
.
rowId
)
;
}
}
this
.
_orderedRows
=
[
]
;
}
insertAfterRow
(
row
)
{
let
tbody
=
row
.
parentNode
;
let
nextRow
;
while
(
(
nextRow
=
this
.
_orderedRows
.
pop
(
)
)
)
{
tbody
.
insertBefore
(
nextRow
row
.
nextSibling
)
;
}
}
_rowsById
:
new
Map
(
)
_removeRow
(
row
)
{
this
.
_rowsById
.
delete
(
row
.
rowId
)
;
row
.
remove
(
)
;
}
_getOrCreateRow
(
rowId
cellCount
)
{
let
row
=
this
.
_rowsById
.
get
(
rowId
)
;
if
(
!
row
)
{
row
=
document
.
createElement
(
"
tr
"
)
;
while
(
cellCount
-
-
)
{
row
.
appendChild
(
document
.
createElement
(
"
td
"
)
)
;
}
row
.
rowId
=
rowId
;
this
.
_rowsById
.
set
(
rowId
row
)
;
}
this
.
_orderedRows
.
push
(
row
)
;
return
row
;
}
displayCpu
(
data
cpuCell
)
{
if
(
data
.
slopeCpu
=
=
null
)
{
this
.
_fillCell
(
cpuCell
{
fluentName
:
"
about
-
processes
-
cpu
-
user
-
and
-
kernel
-
not
-
ready
"
classes
:
[
"
cpu
"
]
}
)
;
}
else
{
let
{
duration
unit
}
=
this
.
_getDuration
(
data
.
totalCpu
)
;
if
(
data
.
totalCpu
=
=
0
)
{
unit
=
"
ms
"
;
}
let
localizedUnit
=
gLocalizedUnits
.
duration
[
unit
]
;
if
(
data
.
slopeCpu
=
=
0
)
{
let
fluentName
=
data
.
active
?
"
about
-
processes
-
cpu
-
almost
-
idle
"
:
"
about
-
processes
-
cpu
-
fully
-
idle
"
;
this
.
_fillCell
(
cpuCell
{
fluentName
fluentArgs
:
{
total
:
duration
unit
:
localizedUnit
}
classes
:
[
"
cpu
"
]
}
)
;
}
else
{
this
.
_fillCell
(
cpuCell
{
fluentName
:
"
about
-
processes
-
cpu
"
fluentArgs
:
{
percent
:
data
.
slopeCpu
total
:
duration
unit
:
localizedUnit
}
classes
:
[
"
cpu
"
]
}
)
;
}
}
}
displayProcessRow
(
data
)
{
const
cellCount
=
4
;
let
rowId
=
"
p
:
"
+
data
.
pid
;
let
row
=
this
.
_getOrCreateRow
(
rowId
cellCount
)
;
row
.
process
=
data
;
{
let
classNames
=
"
process
"
;
if
(
data
.
isHung
)
{
classNames
+
=
"
hung
"
;
}
row
.
className
=
classNames
;
}
let
nameCell
=
row
.
firstChild
;
{
let
classNames
=
[
]
;
let
fluentName
;
let
fluentArgs
=
{
pid
:
"
"
+
data
.
pid
}
;
switch
(
data
.
type
)
{
case
"
web
"
:
fluentName
=
"
about
-
processes
-
web
-
process
"
;
break
;
case
"
webIsolated
"
:
fluentName
=
"
about
-
processes
-
web
-
isolated
-
process
"
;
fluentArgs
.
origin
=
data
.
origin
;
break
;
case
"
webServiceWorker
"
:
fluentName
=
"
about
-
processes
-
web
-
serviceworker
"
;
fluentArgs
.
origin
=
data
.
origin
;
break
;
case
"
webLargeAllocation
"
:
fluentName
=
"
about
-
processes
-
web
-
large
-
allocation
-
process
"
;
fluentArgs
.
origin
=
data
.
origin
;
break
;
case
"
file
"
:
fluentName
=
"
about
-
processes
-
file
-
process
"
;
break
;
case
"
extension
"
:
fluentName
=
"
about
-
processes
-
extension
-
process
"
;
classNames
=
[
"
extensions
"
]
;
break
;
case
"
privilegedabout
"
:
fluentName
=
"
about
-
processes
-
privilegedabout
-
process
"
;
break
;
case
"
privilegedmozilla
"
:
fluentName
=
"
about
-
processes
-
privilegedmozilla
-
process
"
;
break
;
case
"
withCoopCoep
"
:
fluentName
=
"
about
-
processes
-
with
-
coop
-
coep
-
process
"
;
fluentArgs
.
origin
=
data
.
origin
;
break
;
case
"
browser
"
:
fluentName
=
"
about
-
processes
-
browser
-
process
"
;
break
;
case
"
plugin
"
:
fluentName
=
"
about
-
processes
-
plugin
-
process
"
;
break
;
case
"
gmpPlugin
"
:
fluentName
=
"
about
-
processes
-
gmp
-
plugin
-
process
"
;
break
;
case
"
gpu
"
:
fluentName
=
"
about
-
processes
-
gpu
-
process
"
;
break
;
case
"
vr
"
:
fluentName
=
"
about
-
processes
-
vr
-
process
"
;
break
;
case
"
rdd
"
:
fluentName
=
"
about
-
processes
-
rdd
-
process
"
;
break
;
case
"
socket
"
:
fluentName
=
"
about
-
processes
-
socket
-
process
"
;
break
;
case
"
remoteSandboxBroker
"
:
fluentName
=
"
about
-
processes
-
remote
-
sandbox
-
broker
-
process
"
;
break
;
case
"
forkServer
"
:
fluentName
=
"
about
-
processes
-
fork
-
server
-
process
"
;
break
;
case
"
preallocated
"
:
fluentName
=
"
about
-
processes
-
preallocated
-
process
"
;
break
;
default
:
fluentName
=
"
about
-
processes
-
unknown
-
process
"
;
fluentArgs
.
type
=
data
.
type
;
break
;
}
if
(
fluentArgs
.
origin
?
.
includes
(
"
^
"
)
)
{
let
origin
=
fluentArgs
.
origin
;
let
privateBrowsingId
userContextId
;
try
{
(
{
privateBrowsingId
userContextId
}
=
ChromeUtils
.
createOriginAttributesFromOrigin
(
origin
)
)
;
fluentArgs
.
origin
=
origin
.
slice
(
0
origin
.
indexOf
(
"
^
"
)
)
;
}
catch
(
e
)
{
}
if
(
userContextId
)
{
let
identityLabel
=
ContextualIdentityService
.
getUserContextLabel
(
userContextId
)
;
if
(
identityLabel
)
{
fluentArgs
.
origin
+
=
{
identityLabel
}
;
}
}
if
(
privateBrowsingId
)
{
fluentName
+
=
"
-
private
"
;
}
}
let
processNameElement
=
nameCell
;
if
(
SHOW_PROFILER_ICONS
)
{
if
(
!
nameCell
.
firstChild
)
{
processNameElement
=
document
.
createElement
(
"
span
"
)
;
nameCell
.
appendChild
(
processNameElement
)
;
let
profilerIcon
=
document
.
createElement
(
"
span
"
)
;
profilerIcon
.
className
=
"
profiler
-
icon
"
;
document
.
l10n
.
setAttributes
(
profilerIcon
"
about
-
processes
-
profile
-
process
"
{
duration
:
PROFILE_DURATION
}
)
;
nameCell
.
appendChild
(
profilerIcon
)
;
}
else
{
processNameElement
=
nameCell
.
firstChild
;
}
}
document
.
l10n
.
setAttributes
(
processNameElement
fluentName
fluentArgs
)
;
nameCell
.
className
=
[
"
type
"
"
favicon
"
.
.
.
classNames
]
.
join
(
"
"
)
;
let
image
;
switch
(
data
.
type
)
{
case
"
browser
"
:
case
"
privilegedabout
"
:
image
=
"
chrome
:
/
/
branding
/
content
/
icon32
.
png
"
;
break
;
case
"
extension
"
:
image
=
"
chrome
:
/
/
mozapps
/
skin
/
extensions
/
extension
.
svg
"
;
break
;
default
:
for
(
let
win
of
data
.
windows
|
|
[
]
)
{
if
(
!
win
.
tab
)
{
continue
;
}
let
favicon
=
win
.
tab
.
tab
.
getAttribute
(
"
image
"
)
;
if
(
!
favicon
)
{
}
else
if
(
!
image
)
{
image
=
favicon
;
}
else
if
(
image
=
=
favicon
)
{
}
else
{
image
=
null
;
break
;
}
}
if
(
!
image
)
{
image
=
"
chrome
:
/
/
global
/
skin
/
icons
/
link
.
svg
"
;
}
}
nameCell
.
style
.
backgroundImage
=
url
(
'
{
image
}
'
)
;
}
let
memoryCell
=
nameCell
.
nextSibling
;
{
let
formattedTotal
=
this
.
_formatMemory
(
data
.
totalRamSize
)
;
if
(
data
.
deltaRamSize
)
{
let
formattedDelta
=
this
.
_formatMemory
(
data
.
deltaRamSize
)
;
this
.
_fillCell
(
memoryCell
{
fluentName
:
"
about
-
processes
-
total
-
memory
-
size
-
changed
"
fluentArgs
:
{
total
:
formattedTotal
.
amount
totalUnit
:
gLocalizedUnits
.
memory
[
formattedTotal
.
unit
]
delta
:
Math
.
abs
(
formattedDelta
.
amount
)
deltaUnit
:
gLocalizedUnits
.
memory
[
formattedDelta
.
unit
]
deltaSign
:
data
.
deltaRamSize
>
0
?
"
+
"
:
"
-
"
}
classes
:
[
"
memory
"
]
}
)
;
}
else
{
this
.
_fillCell
(
memoryCell
{
fluentName
:
"
about
-
processes
-
total
-
memory
-
size
-
no
-
change
"
fluentArgs
:
{
total
:
formattedTotal
.
amount
totalUnit
:
gLocalizedUnits
.
memory
[
formattedTotal
.
unit
]
}
classes
:
[
"
memory
"
]
}
)
;
}
}
let
cpuCell
=
memoryCell
.
nextSibling
;
this
.
displayCpu
(
data
cpuCell
)
;
let
killButton
=
cpuCell
.
nextSibling
;
killButton
.
className
=
"
action
-
icon
"
;
if
(
data
.
type
.
startsWith
(
"
web
"
)
)
{
if
(
this
.
_killedRecently
.
some
(
kill
=
>
kill
.
pid
&
&
kill
.
pid
=
=
data
.
pid
)
)
{
row
.
classList
.
add
(
"
killed
"
)
;
}
else
{
killButton
.
classList
.
add
(
"
close
-
icon
"
)
;
document
.
l10n
.
setAttributes
(
killButton
"
about
-
processes
-
shutdown
-
process
"
)
;
}
}
return
row
;
}
displayThreadSummaryRow
(
data
)
{
const
cellCount
=
2
;
let
rowId
=
"
ts
:
"
+
data
.
pid
;
let
row
=
this
.
_getOrCreateRow
(
rowId
cellCount
)
;
row
.
process
=
data
;
row
.
className
=
"
thread
-
summary
"
;
let
isOpen
=
false
;
let
nameCell
=
row
.
firstChild
;
let
threads
=
data
.
threads
;
let
activeThreads
=
new
Map
(
)
;
let
activeThreadCount
=
0
;
for
(
let
t
of
data
.
threads
)
{
if
(
!
t
.
active
)
{
continue
;
}
+
+
activeThreadCount
;
let
name
=
t
.
name
.
replace
(
/
?
#
[
0
-
9
]
+
/
"
"
)
;
if
(
!
activeThreads
.
has
(
name
)
)
{
activeThreads
.
set
(
name
{
name
slopeCpu
:
t
.
slopeCpu
count
:
1
}
)
;
}
else
{
let
thread
=
activeThreads
.
get
(
name
)
;
thread
.
count
+
+
;
thread
.
slopeCpu
+
=
t
.
slopeCpu
;
}
}
let
fluentName
fluentArgs
;
if
(
activeThreadCount
)
{
let
percentFormatter
=
new
Intl
.
NumberFormat
(
undefined
{
style
:
"
percent
"
minimumSignificantDigits
:
1
}
)
;
let
threadList
=
Array
.
from
(
activeThreads
.
values
(
)
)
;
threadList
.
sort
(
(
t1
t2
)
=
>
t2
.
slopeCpu
-
t1
.
slopeCpu
)
;
fluentName
=
"
about
-
processes
-
active
-
threads
"
;
fluentArgs
=
{
number
:
threads
.
length
active
:
activeThreadCount
list
:
new
Intl
.
ListFormat
(
undefined
{
style
:
"
narrow
"
}
)
.
format
(
threadList
.
map
(
t
=
>
{
let
name
=
t
.
count
>
1
?
{
t
.
count
}
{
t
.
name
}
:
t
.
name
;
let
percent
=
Math
.
round
(
t
.
slopeCpu
*
1000
)
/
1000
;
if
(
percent
)
{
return
{
name
}
{
percentFormatter
.
format
(
percent
)
}
;
}
return
name
;
}
)
)
}
;
}
else
{
fluentName
=
"
about
-
processes
-
inactive
-
threads
"
;
fluentArgs
=
{
number
:
threads
.
length
}
;
}
let
span
;
if
(
!
nameCell
.
firstChild
)
{
nameCell
.
className
=
"
name
indent
"
;
let
img
=
document
.
createElement
(
"
span
"
)
;
img
.
className
=
"
twisty
"
;
nameCell
.
appendChild
(
img
)
;
span
=
document
.
createElement
(
"
span
"
)
;
nameCell
.
appendChild
(
span
)
;
}
else
{
let
img
=
nameCell
.
firstChild
;
isOpen
=
img
.
classList
.
contains
(
"
open
"
)
;
span
=
img
.
nextSibling
;
}
document
.
l10n
.
setAttributes
(
span
fluentName
fluentArgs
)
;
let
actionCell
=
nameCell
.
nextSibling
;
actionCell
.
className
=
"
action
-
icon
"
;
return
isOpen
;
}
displayDOMWindowRow
(
data
parent
)
{
const
cellCount
=
2
;
let
rowId
=
"
w
:
"
+
data
.
outerWindowId
;
let
row
=
this
.
_getOrCreateRow
(
rowId
cellCount
)
;
row
.
win
=
data
;
row
.
className
=
"
window
"
;
let
nameCell
=
row
.
firstChild
;
let
tab
=
tabFinder
.
get
(
data
.
outerWindowId
)
;
let
fluentName
;
let
fluentArgs
=
{
}
;
let
className
;
if
(
tab
&
&
tab
.
tabbrowser
)
{
fluentName
=
"
about
-
processes
-
tab
-
name
"
;
fluentArgs
.
name
=
tab
.
tab
.
label
;
className
=
"
tab
"
;
}
else
if
(
tab
)
{
fluentName
=
"
about
-
processes
-
preloaded
-
tab
"
;
className
=
"
preloaded
-
tab
"
;
}
else
if
(
data
.
count
=
=
1
)
{
fluentName
=
"
about
-
processes
-
frame
-
name
-
one
"
;
fluentArgs
.
url
=
data
.
documentURI
.
spec
;
className
=
"
frame
-
one
"
;
}
else
{
fluentName
=
"
about
-
processes
-
frame
-
name
-
many
"
;
fluentArgs
.
number
=
data
.
count
;
fluentArgs
.
shortUrl
=
data
.
documentURI
.
scheme
=
=
"
about
"
?
data
.
documentURI
.
spec
:
data
.
documentURI
.
prePath
;
className
=
"
frame
-
many
"
;
}
this
.
_fillCell
(
nameCell
{
fluentName
fluentArgs
classes
:
[
"
name
"
"
indent
"
"
favicon
"
className
]
}
)
;
let
image
=
tab
?
.
tab
.
getAttribute
(
"
image
"
)
;
if
(
image
)
{
nameCell
.
style
.
backgroundImage
=
url
(
'
{
image
}
'
)
;
}
let
killButton
=
nameCell
.
nextSibling
;
killButton
.
className
=
"
action
-
icon
"
;
if
(
data
.
tab
&
&
data
.
tab
.
tabbrowser
)
{
if
(
this
.
_killedRecently
.
some
(
kill
=
>
kill
.
windowId
&
&
kill
.
windowId
=
=
data
.
outerWindowId
)
)
{
row
.
classList
.
add
(
"
killed
"
)
;
}
else
{
killButton
.
classList
.
add
(
"
close
-
icon
"
)
;
document
.
l10n
.
setAttributes
(
killButton
"
about
-
processes
-
shutdown
-
tab
"
)
;
}
}
}
displayThreadRow
(
data
)
{
const
cellCount
=
3
;
let
rowId
=
"
t
:
"
+
data
.
tid
;
let
row
=
this
.
_getOrCreateRow
(
rowId
cellCount
)
;
row
.
thread
=
data
;
row
.
className
=
"
thread
"
;
let
nameCell
=
row
.
firstChild
;
this
.
_fillCell
(
nameCell
{
fluentName
:
"
about
-
processes
-
thread
-
name
-
and
-
id
"
fluentArgs
:
{
name
:
data
.
name
tid
:
"
"
+
data
.
tid
}
classes
:
[
"
name
"
"
double_indent
"
]
}
)
;
this
.
displayCpu
(
data
nameCell
.
nextSibling
)
;
}
_orderedRows
:
[
]
_fillCell
(
elt
{
classes
fluentName
fluentArgs
}
)
{
document
.
l10n
.
setAttributes
(
elt
fluentName
fluentArgs
)
;
elt
.
className
=
classes
.
join
(
"
"
)
;
}
_getDuration
(
rawDurationNS
)
{
if
(
rawDurationNS
<
=
NS_PER_US
)
{
return
{
duration
:
rawDurationNS
unit
:
"
ns
"
}
;
}
if
(
rawDurationNS
<
=
NS_PER_MS
)
{
return
{
duration
:
rawDurationNS
/
NS_PER_US
unit
:
"
us
"
}
;
}
if
(
rawDurationNS
<
=
NS_PER_S
)
{
return
{
duration
:
rawDurationNS
/
NS_PER_MS
unit
:
"
ms
"
}
;
}
if
(
rawDurationNS
<
=
NS_PER_MIN
)
{
return
{
duration
:
rawDurationNS
/
NS_PER_S
unit
:
"
s
"
}
;
}
if
(
rawDurationNS
<
=
NS_PER_HOUR
)
{
return
{
duration
:
rawDurationNS
/
NS_PER_MIN
unit
:
"
m
"
}
;
}
if
(
rawDurationNS
<
=
NS_PER_DAY
)
{
return
{
duration
:
rawDurationNS
/
NS_PER_HOUR
unit
:
"
h
"
}
;
}
return
{
duration
:
rawDurationNS
/
NS_PER_DAY
unit
:
"
d
"
}
;
}
_formatMemory
(
value
)
{
if
(
value
=
=
null
)
{
return
{
unit
:
"
?
"
amount
:
0
}
;
}
if
(
typeof
value
!
=
"
number
"
)
{
throw
new
Error
(
Invalid
memory
value
{
value
}
)
;
}
let
abs
=
Math
.
abs
(
value
)
;
if
(
abs
>
=
ONE_GIGA
)
{
return
{
unit
:
"
GB
"
amount
:
value
/
ONE_GIGA
}
;
}
if
(
abs
>
=
ONE_MEGA
)
{
return
{
unit
:
"
MB
"
amount
:
value
/
ONE_MEGA
}
;
}
if
(
abs
>
=
ONE_KILO
)
{
return
{
unit
:
"
KB
"
amount
:
value
/
ONE_KILO
}
;
}
return
{
unit
:
"
B
"
amount
:
value
}
;
}
}
;
var
Control
=
{
_hungItems
:
new
Set
(
)
_sortColumn
:
null
_sortAscendent
:
true
_removeSubtree
(
row
)
{
let
sibling
=
row
.
nextSibling
;
while
(
sibling
&
&
!
sibling
.
classList
.
contains
(
"
process
"
)
)
{
let
next
=
sibling
.
nextSibling
;
if
(
sibling
.
classList
.
contains
(
"
thread
"
)
)
{
View
.
_removeRow
(
sibling
)
;
}
sibling
=
next
;
}
}
init
(
)
{
this
.
_initHangReports
(
)
;
this
.
_promisePrefetchedUnits
=
(
async
function
(
)
{
let
[
ns
us
ms
s
m
h
d
B
KB
MB
GB
TB
PB
EB
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
duration
-
unit
-
ns
"
}
{
id
:
"
duration
-
unit
-
us
"
}
{
id
:
"
duration
-
unit
-
ms
"
}
{
id
:
"
duration
-
unit
-
s
"
}
{
id
:
"
duration
-
unit
-
m
"
}
{
id
:
"
duration
-
unit
-
h
"
}
{
id
:
"
duration
-
unit
-
d
"
}
{
id
:
"
memory
-
unit
-
B
"
}
{
id
:
"
memory
-
unit
-
KB
"
}
{
id
:
"
memory
-
unit
-
MB
"
}
{
id
:
"
memory
-
unit
-
GB
"
}
{
id
:
"
memory
-
unit
-
TB
"
}
{
id
:
"
memory
-
unit
-
PB
"
}
{
id
:
"
memory
-
unit
-
EB
"
}
]
)
;
return
{
duration
:
{
ns
us
ms
s
m
h
d
}
memory
:
{
B
KB
MB
GB
TB
PB
EB
}
}
;
}
)
(
)
;
let
tbody
=
document
.
getElementById
(
"
process
-
tbody
"
)
;
tbody
.
addEventListener
(
"
click
"
event
=
>
{
this
.
_updateLastMouseEvent
(
)
;
let
target
=
event
.
target
;
if
(
target
.
classList
.
contains
(
"
twisty
"
)
)
{
this
.
_handleTwisty
(
target
)
;
return
;
}
if
(
target
.
classList
.
contains
(
"
close
-
icon
"
)
)
{
this
.
_handleKill
(
target
)
;
return
;
}
if
(
target
.
classList
.
contains
(
"
profiler
-
icon
"
)
)
{
if
(
Services
.
profiler
.
IsActive
(
)
)
{
return
;
}
Services
.
profiler
.
StartProfiler
(
10000000
1
[
"
default
"
"
ipcmessages
"
]
[
"
pid
:
"
+
target
.
parentNode
.
parentNode
.
process
.
pid
]
)
;
target
.
classList
.
add
(
"
profiler
-
active
"
)
;
setTimeout
(
(
)
=
>
{
ProfilerPopupBackground
.
captureProfile
(
"
aboutprofiling
"
)
;
target
.
classList
.
remove
(
"
profiler
-
active
"
)
;
}
PROFILE_DURATION
*
1000
)
;
return
;
}
let
row
=
target
.
closest
(
"
tr
"
)
;
if
(
!
row
)
{
return
;
}
if
(
this
.
selectedRow
)
{
this
.
selectedRow
.
removeAttribute
(
"
selected
"
)
;
if
(
this
.
selectedRow
.
rowId
=
=
row
.
rowId
)
{
this
.
selectedRow
=
null
;
return
;
}
}
row
.
setAttribute
(
"
selected
"
"
true
"
)
;
this
.
selectedRow
=
row
;
}
)
;
tbody
.
addEventListener
(
"
dblclick
"
event
=
>
{
this
.
_updateLastMouseEvent
(
)
;
event
.
stopPropagation
(
)
;
for
(
let
target
=
event
.
target
;
target
&
&
target
.
getAttribute
(
"
id
"
)
!
=
"
process
-
tbody
"
;
target
=
target
.
parentNode
)
{
if
(
target
.
classList
.
contains
(
"
tab
"
)
)
{
let
{
tab
tabbrowser
}
=
target
.
parentNode
.
win
.
tab
;
tabbrowser
.
selectedTab
=
tab
;
tabbrowser
.
ownerGlobal
.
focus
(
)
;
return
;
}
if
(
target
.
classList
.
contains
(
"
extensions
"
)
)
{
let
parentWin
=
window
.
docShell
.
browsingContext
.
embedderElement
.
ownerGlobal
;
parentWin
.
BrowserOpenAddonsMgr
(
)
;
return
;
}
}
}
)
;
tbody
.
addEventListener
(
"
mousemove
"
(
)
=
>
{
this
.
_updateLastMouseEvent
(
)
;
}
)
;
window
.
addEventListener
(
"
visibilitychange
"
event
=
>
{
if
(
!
document
.
hidden
)
{
this
.
_updateDisplay
(
true
)
;
}
}
)
;
document
.
getElementById
(
"
process
-
thead
"
)
.
addEventListener
(
"
click
"
async
event
=
>
{
if
(
!
event
.
target
.
classList
.
contains
(
"
clickable
"
)
)
{
return
;
}
if
(
this
.
_sortColumn
)
{
const
td
=
document
.
getElementById
(
this
.
_sortColumn
)
;
td
.
classList
.
remove
(
"
asc
"
)
;
td
.
classList
.
remove
(
"
desc
"
)
;
}
const
columnId
=
event
.
target
.
id
;
if
(
columnId
=
=
this
.
_sortColumn
)
{
this
.
_sortAscendent
=
!
this
.
_sortAscendent
;
}
else
{
this
.
_sortColumn
=
columnId
;
this
.
_sortAscendent
=
true
;
}
if
(
this
.
_sortAscendent
)
{
event
.
target
.
classList
.
remove
(
"
desc
"
)
;
event
.
target
.
classList
.
add
(
"
asc
"
)
;
}
else
{
event
.
target
.
classList
.
remove
(
"
asc
"
)
;
event
.
target
.
classList
.
add
(
"
desc
"
)
;
}
await
this
.
_updateDisplay
(
true
)
;
}
)
;
}
_lastMouseEvent
:
0
_updateLastMouseEvent
(
)
{
this
.
_lastMouseEvent
=
Date
.
now
(
)
;
}
_initHangReports
(
)
{
const
PROCESS_HANG_REPORT_NOTIFICATION
=
"
process
-
hang
-
report
"
;
let
hangReporter
=
report
=
>
{
report
.
QueryInterface
(
Ci
.
nsIHangReport
)
;
this
.
_hungItems
.
add
(
report
.
childID
)
;
}
;
Services
.
obs
.
addObserver
(
hangReporter
PROCESS_HANG_REPORT_NOTIFICATION
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
Services
.
obs
.
removeObserver
(
hangReporter
PROCESS_HANG_REPORT_NOTIFICATION
)
;
}
{
once
:
true
}
)
;
}
async
update
(
force
=
false
)
{
await
State
.
update
(
force
)
;
if
(
document
.
hidden
)
{
return
;
}
await
this
.
_updateDisplay
(
force
)
;
}
async
_updateDisplay
(
force
=
false
)
{
let
counters
=
State
.
getCounters
(
)
;
if
(
this
.
_promisePrefetchedUnits
)
{
gLocalizedUnits
=
await
this
.
_promisePrefetchedUnits
;
this
.
_promisePrefetchedUnits
=
null
;
}
let
hungItems
=
this
.
_hungItems
;
this
.
_hungItems
=
new
Set
(
)
;
counters
=
this
.
_sortProcesses
(
counters
)
;
let
previousProcess
=
null
;
for
(
let
process
of
counters
)
{
this
.
_sortDOMWindows
(
process
.
windows
)
;
process
.
isHung
=
process
.
childID
&
&
hungItems
.
has
(
process
.
childID
)
;
let
processRow
=
View
.
displayProcessRow
(
process
)
;
if
(
process
.
type
!
=
"
extension
"
)
{
for
(
let
win
of
process
.
windows
)
{
if
(
SHOW_ALL_SUBFRAMES
|
|
win
.
tab
|
|
win
.
isProcessRoot
)
{
View
.
displayDOMWindowRow
(
win
process
)
;
}
}
}
if
(
SHOW_THREADS
)
{
if
(
View
.
displayThreadSummaryRow
(
process
)
)
{
this
.
_showThreads
(
processRow
)
;
}
}
if
(
this
.
_sortColumn
=
=
null
&
&
previousProcess
&
&
previousProcess
.
displayRank
!
=
process
.
displayRank
)
{
processRow
.
classList
.
add
(
"
separate
-
from
-
previous
-
process
-
group
"
)
;
}
previousProcess
=
process
;
}
if
(
!
force
&
&
Date
.
now
(
)
-
this
.
_lastMouseEvent
<
TIME_BEFORE_SORTING_AGAIN
)
{
View
.
discardUpdate
(
)
;
return
;
}
View
.
commit
(
)
;
if
(
this
.
selectedRow
&
&
!
this
.
selectedRow
.
parentNode
)
{
this
.
selectedRow
=
null
;
}
document
.
dispatchEvent
(
new
CustomEvent
(
"
AboutProcessesUpdated
"
)
)
;
}
_compareCpu
(
a
b
)
{
return
(
b
.
slopeCpu
-
a
.
slopeCpu
|
|
b
.
active
-
a
.
active
|
|
b
.
totalCpu
-
a
.
totalCpu
)
;
}
_showThreads
(
row
)
{
let
process
=
row
.
process
;
this
.
_sortThreads
(
process
.
threads
)
;
for
(
let
thread
of
process
.
threads
)
{
View
.
displayThreadRow
(
thread
)
;
}
}
_sortThreads
(
threads
)
{
return
threads
.
sort
(
(
a
b
)
=
>
{
let
order
;
switch
(
this
.
_sortColumn
)
{
case
"
column
-
name
"
:
order
=
a
.
name
.
localeCompare
(
b
.
name
)
|
|
a
.
tid
-
b
.
tid
;
break
;
case
"
column
-
cpu
-
total
"
:
order
=
this
.
_compareCpu
(
a
b
)
;
break
;
case
"
column
-
memory
-
resident
"
:
case
null
:
order
=
a
.
tid
-
b
.
tid
;
break
;
default
:
throw
new
Error
(
"
Unsupported
order
:
"
+
this
.
_sortColumn
)
;
}
if
(
!
this
.
_sortAscendent
)
{
order
=
-
order
;
}
return
order
;
}
)
;
}
_sortProcesses
(
counters
)
{
return
counters
.
sort
(
(
a
b
)
=
>
{
let
order
;
switch
(
this
.
_sortColumn
)
{
case
"
column
-
name
"
:
order
=
String
(
a
.
origin
)
.
localeCompare
(
b
.
origin
)
|
|
String
(
a
.
type
)
.
localeCompare
(
b
.
type
)
|
|
a
.
pid
-
b
.
pid
;
break
;
case
"
column
-
cpu
-
total
"
:
order
=
this
.
_compareCpu
(
a
b
)
;
break
;
case
"
column
-
memory
-
resident
"
:
order
=
b
.
totalRamSize
-
a
.
totalRamSize
;
break
;
case
null
:
order
=
a
.
displayRank
-
b
.
displayRank
|
|
String
(
a
.
origin
)
.
localeCompare
(
b
.
origin
)
;
break
;
default
:
throw
new
Error
(
"
Unsupported
order
:
"
+
this
.
_sortColumn
)
;
}
if
(
!
this
.
_sortAscendent
)
{
order
=
-
order
;
}
return
order
;
}
)
;
}
_sortDOMWindows
(
windows
)
{
return
windows
.
sort
(
(
a
b
)
=
>
{
let
order
=
a
.
displayRank
-
b
.
displayRank
|
|
a
.
documentTitle
.
localeCompare
(
b
.
documentTitle
)
|
|
a
.
documentURI
.
spec
.
localeCompare
(
b
.
documentURI
.
spec
)
;
if
(
!
this
.
_sortAscendent
)
{
order
=
-
order
;
}
return
order
;
}
)
;
}
_getDisplayGroupRank
(
data
windows
)
{
const
RANK_BROWSER
=
0
;
const
RANK_WEB_TABS
=
1
;
const
RANK_WEB_FRAMES
=
2
;
const
RANK_UTILITY
=
3
;
const
RANK_PREALLOCATED
=
4
;
let
type
=
data
.
type
;
switch
(
type
)
{
case
"
browser
"
:
return
RANK_BROWSER
;
case
"
webIsolated
"
:
case
"
webServiceWorker
"
:
case
"
webLargeAllocation
"
:
case
"
withCoopCoep
"
:
{
if
(
windows
.
some
(
w
=
>
w
.
tab
)
)
{
return
RANK_WEB_TABS
;
}
return
RANK_WEB_FRAMES
;
}
case
"
preallocated
"
:
return
RANK_PREALLOCATED
;
case
"
web
"
:
if
(
windows
.
some
(
w
=
>
w
.
tab
)
)
{
return
RANK_WEB_TABS
;
}
if
(
windows
.
length
>
=
1
)
{
return
RANK_WEB_FRAMES
;
}
return
RANK_PREALLOCATED
;
default
:
return
RANK_UTILITY
;
}
}
_handleTwisty
(
target
)
{
let
row
=
target
.
parentNode
.
parentNode
;
if
(
target
.
classList
.
toggle
(
"
open
"
)
)
{
this
.
_showThreads
(
row
)
;
View
.
insertAfterRow
(
row
)
;
}
else
{
this
.
_removeSubtree
(
row
)
;
}
}
_handleKill
(
target
)
{
let
row
=
target
.
parentNode
;
if
(
row
.
process
)
{
let
pid
=
row
.
process
.
pid
;
View
.
_killedRecently
.
push
(
{
pid
}
)
;
row
.
classList
.
add
(
"
killing
"
)
;
for
(
let
childRow
=
row
.
nextSibling
;
childRow
&
&
!
childRow
.
classList
.
contains
(
"
process
"
)
;
childRow
=
childRow
.
nextSibling
)
{
childRow
.
classList
.
add
(
"
killing
"
)
;
let
win
=
childRow
.
win
;
if
(
win
)
{
View
.
_killedRecently
.
push
(
{
pid
:
win
.
outerWindowId
}
)
;
if
(
win
.
tab
&
&
win
.
tab
.
tabbrowser
)
{
win
.
tab
.
tabbrowser
.
discardBrowser
(
win
.
tab
.
tab
true
)
;
}
}
}
const
ProcessTools
=
Cc
[
"
mozilla
.
org
/
processtools
-
service
;
1
"
]
.
getService
(
Ci
.
nsIProcessToolsService
)
;
ProcessTools
.
kill
(
pid
)
;
}
else
if
(
row
.
win
&
&
row
.
win
.
tab
&
&
row
.
win
.
tab
.
tabbrowser
)
{
row
.
win
.
tab
.
tabbrowser
.
removeTab
(
row
.
win
.
tab
.
tab
{
skipPermitUnload
:
true
animate
:
true
}
)
;
View
.
_killedRecently
.
push
(
{
outerWindowId
:
row
.
win
.
outerWindowId
}
)
;
row
.
classList
.
add
(
"
killing
"
)
;
if
(
row
.
previousSibling
.
classList
.
contains
(
"
process
"
)
)
{
let
parentRow
=
row
.
previousSibling
;
let
roots
=
0
;
for
(
let
win
of
parentRow
.
process
.
windows
)
{
if
(
win
.
isProcessRoot
)
{
roots
+
=
1
;
}
}
if
(
roots
<
=
1
)
{
View
.
_killedRecently
.
push
(
{
pid
:
parentRow
.
process
.
pid
}
)
;
parentRow
.
classList
.
add
(
"
killing
"
)
;
}
}
}
}
}
;
window
.
onload
=
async
function
(
)
{
Control
.
init
(
)
;
await
Control
.
update
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
MINIMUM_INTERVAL_BETWEEN_SAMPLES_MS
)
)
;
await
Control
.
update
(
true
)
;
window
.
setInterval
(
(
)
=
>
Control
.
update
(
)
UPDATE_INTERVAL_MS
)
;
}
;
