ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PageThumbUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
Blob
"
"
FileReader
"
]
)
;
const
SETTLE_WAIT_TIME
=
2500
;
const
STATE_LOADING
=
1
;
const
STATE_CAPTURING
=
2
;
const
STATE_CANCELED
=
3
;
const
SANDBOXED_AUXILIARY_NAVIGATION
=
0x2
;
const
backgroundPageThumbsContent
=
{
init
(
)
{
Services
.
obs
.
addObserver
(
this
"
document
-
element
-
inserted
"
true
)
;
this
.
_webNav
.
QueryInterface
(
Ci
.
nsIDocumentLoader
)
.
loadGroup
.
QueryInterface
(
Ci
.
nsISupportsPriority
)
.
priority
=
Ci
.
nsISupportsPriority
.
PRIORITY_LOWEST
;
docShell
.
allowMedia
=
false
;
docShell
.
allowPlugins
=
false
;
docShell
.
allowContentRetargeting
=
false
;
let
defaultFlags
=
Ci
.
nsIRequest
.
LOAD_ANONYMOUS
|
Ci
.
nsIRequest
.
LOAD_BYPASS_CACHE
|
Ci
.
nsIRequest
.
INHIBIT_CACHING
|
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_BYPASS_HISTORY
;
docShell
.
defaultLoadFlags
=
defaultFlags
;
docShell
.
sandboxFlags
|
=
SANDBOXED_AUXILIARY_NAVIGATION
;
docShell
.
useTrackingProtection
=
true
;
addMessageListener
(
"
BackgroundPageThumbs
:
capture
"
this
.
_onCapture
.
bind
(
this
)
)
;
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
)
;
}
observe
(
subj
topic
data
)
{
if
(
content
&
&
subj
=
=
content
.
document
)
{
content
.
windowUtils
.
disableDialogs
(
)
;
}
}
get
_webNav
(
)
{
return
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
}
_onCapture
(
msg
)
{
this
.
_nextCapture
=
{
id
:
msg
.
data
.
id
url
:
msg
.
data
.
url
isImage
:
msg
.
data
.
isImage
targetWidth
:
msg
.
data
.
targetWidth
backgroundColor
:
msg
.
data
.
backgroundColor
}
;
if
(
this
.
_currentCapture
)
{
if
(
this
.
_state
=
=
STATE_LOADING
)
{
this
.
_state
=
STATE_CANCELED
;
this
.
_loadAboutBlank
(
)
;
}
return
;
}
this
.
_startNextCapture
(
)
;
}
_startNextCapture
(
)
{
if
(
!
this
.
_nextCapture
)
return
;
this
.
_currentCapture
=
this
.
_nextCapture
;
delete
this
.
_nextCapture
;
this
.
_state
=
STATE_LOADING
;
this
.
_currentCapture
.
pageLoadStartDate
=
new
Date
(
)
;
try
{
this
.
_webNav
.
loadURI
(
this
.
_currentCapture
.
url
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_STOP_CONTENT
null
null
null
)
;
}
catch
(
e
)
{
this
.
_failCurrentCapture
(
"
BAD_URI
"
)
;
}
}
onStateChange
(
webProgress
req
flags
status
)
{
if
(
webProgress
.
isTopLevel
&
&
(
flags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
&
&
this
.
_currentCapture
)
{
if
(
req
.
name
=
=
"
about
:
blank
"
)
{
if
(
this
.
_state
=
=
STATE_CAPTURING
)
{
this
.
_finishCurrentCapture
(
)
;
delete
this
.
_currentCapture
;
this
.
_startNextCapture
(
)
;
}
else
if
(
this
.
_state
=
=
STATE_CANCELED
)
{
delete
this
.
_currentCapture
;
this
.
_startNextCapture
(
)
;
}
}
else
if
(
this
.
_state
=
=
STATE_LOADING
&
&
(
Components
.
isSuccessCode
(
status
)
|
|
status
=
=
=
Cr
.
NS_BINDING_ABORTED
)
)
{
if
(
this
.
_captureTimer
)
{
this
.
_captureTimer
.
delay
=
SETTLE_WAIT_TIME
;
}
else
{
this
.
_captureTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_captureTimer
.
init
(
(
)
=
>
{
this
.
_state
=
STATE_CAPTURING
;
this
.
_captureCurrentPage
(
)
;
delete
this
.
_captureTimer
;
}
SETTLE_WAIT_TIME
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
else
if
(
this
.
_state
!
=
STATE_CANCELED
)
{
this
.
_state
=
STATE_CANCELED
;
if
(
!
this
.
_cancelTimer
)
{
this
.
_cancelTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_cancelTimer
.
init
(
(
)
=
>
{
this
.
_loadAboutBlank
(
)
;
delete
this
.
_cancelTimer
;
}
0
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
}
}
}
_captureCurrentPage
(
)
{
const
doCapture
=
async
(
)
=
>
{
let
capture
=
this
.
_currentCapture
;
capture
.
finalURL
=
this
.
_webNav
.
currentURI
.
spec
;
capture
.
pageLoadTime
=
new
Date
(
)
-
capture
.
pageLoadStartDate
;
let
canvasDrawDate
=
new
Date
(
)
;
docShell
.
isActive
=
true
;
let
finalCanvas
;
if
(
capture
.
isImage
|
|
content
.
document
instanceof
content
.
ImageDocument
)
{
finalCanvas
=
await
PageThumbUtils
.
createImageThumbnailCanvas
(
content
capture
.
url
capture
.
targetWidth
capture
.
backgroundColor
)
;
}
else
{
finalCanvas
=
PageThumbUtils
.
createSnapshotThumbnail
(
content
null
)
;
}
docShell
.
isActive
=
false
;
capture
.
canvasDrawTime
=
new
Date
(
)
-
canvasDrawDate
;
finalCanvas
.
toBlob
(
blob
=
>
{
capture
.
imageBlob
=
new
Blob
(
[
blob
]
)
;
this
.
_loadAboutBlank
(
)
;
}
)
;
}
;
let
win
=
docShell
.
domWindow
;
win
.
requestIdleCallback
(
(
)
=
>
doCapture
(
)
.
catch
(
ex
=
>
this
.
_failCurrentCapture
(
ex
.
message
)
)
)
;
}
_finishCurrentCapture
(
)
{
let
capture
=
this
.
_currentCapture
;
let
fileReader
=
new
FileReader
(
)
;
fileReader
.
onloadend
=
(
)
=
>
{
sendAsyncMessage
(
"
BackgroundPageThumbs
:
didCapture
"
{
id
:
capture
.
id
imageData
:
fileReader
.
result
finalURL
:
capture
.
finalURL
telemetry
:
{
CAPTURE_PAGE_LOAD_TIME_MS
:
capture
.
pageLoadTime
CAPTURE_CANVAS_DRAW_TIME_MS
:
capture
.
canvasDrawTime
}
}
)
;
}
;
fileReader
.
readAsArrayBuffer
(
capture
.
imageBlob
)
;
}
_failCurrentCapture
(
reason
)
{
let
capture
=
this
.
_currentCapture
;
sendAsyncMessage
(
"
BackgroundPageThumbs
:
didCapture
"
{
id
:
capture
.
id
failReason
:
reason
}
)
;
delete
this
.
_currentCapture
;
this
.
_startNextCapture
(
)
;
}
_loadAboutBlank
:
function
_loadAboutBlank
(
)
{
if
(
!
docShell
)
{
return
;
}
this
.
_webNav
.
loadURI
(
"
about
:
blank
"
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_STOP_CONTENT
null
null
null
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
Ci
.
nsIObserver
]
)
}
;
backgroundPageThumbsContent
.
init
(
)
;
