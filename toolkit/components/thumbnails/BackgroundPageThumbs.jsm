const
EXPORTED_SYMBOLS
=
[
"
BackgroundPageThumbs
"
]
;
const
DEFAULT_CAPTURE_TIMEOUT
=
30000
;
const
DESTROY_BROWSER_TIMEOUT
=
60000
;
const
FRAME_SCRIPT_URL
=
"
chrome
:
/
/
global
/
content
/
backgroundPageThumbsContent
.
js
"
;
const
TELEMETRY_HISTOGRAM_ID_PREFIX
=
"
FX_THUMBNAILS_BG_
"
;
const
ABOUT_NEWTAB_SEGREGATION_PREF
=
"
privacy
.
usercontext
.
about_newtab_segregation
.
enabled
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
const
{
PageThumbs
PageThumbsStorage
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PageThumbs
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
TEL_CAPTURE_DONE_OK
=
0
;
const
TEL_CAPTURE_DONE_TIMEOUT
=
1
;
const
TEL_CAPTURE_DONE_CRASHED
=
4
;
const
TEL_CAPTURE_DONE_BAD_URI
=
5
;
const
TEL_CAPTURE_DONE_LOAD_FAILED
=
6
;
const
TEL_CAPTURE_DONE_IMAGE_ZERO_DIMENSION
=
7
;
XPCOMUtils
.
defineConstant
(
this
"
TEL_CAPTURE_DONE_OK
"
TEL_CAPTURE_DONE_OK
)
;
XPCOMUtils
.
defineConstant
(
this
"
TEL_CAPTURE_DONE_TIMEOUT
"
TEL_CAPTURE_DONE_TIMEOUT
)
;
XPCOMUtils
.
defineConstant
(
this
"
TEL_CAPTURE_DONE_CRASHED
"
TEL_CAPTURE_DONE_CRASHED
)
;
XPCOMUtils
.
defineConstant
(
this
"
TEL_CAPTURE_DONE_BAD_URI
"
TEL_CAPTURE_DONE_BAD_URI
)
;
XPCOMUtils
.
defineConstant
(
this
"
TEL_CAPTURE_DONE_LOAD_FAILED
"
TEL_CAPTURE_DONE_LOAD_FAILED
)
;
XPCOMUtils
.
defineConstant
(
this
"
TEL_CAPTURE_DONE_IMAGE_ZERO_DIMENSION
"
TEL_CAPTURE_DONE_IMAGE_ZERO_DIMENSION
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContextualIdentityService
"
"
resource
:
/
/
gre
/
modules
/
ContextualIdentityService
.
jsm
"
)
;
const
global
=
this
;
const
BackgroundPageThumbs
=
{
capture
(
url
options
=
{
}
)
{
if
(
!
PageThumbs
.
_prefEnabled
(
)
)
{
if
(
options
.
onDone
)
schedule
(
(
)
=
>
options
.
onDone
(
url
)
)
;
return
;
}
this
.
_captureQueue
=
this
.
_captureQueue
|
|
[
]
;
this
.
_capturesByURL
=
this
.
_capturesByURL
|
|
new
Map
(
)
;
tel
(
"
QUEUE_SIZE_ON_CAPTURE
"
this
.
_captureQueue
.
length
)
;
let
existing
=
this
.
_capturesByURL
.
get
(
url
)
;
if
(
existing
)
{
if
(
options
.
onDone
)
existing
.
doneCallbacks
.
push
(
options
.
onDone
)
;
return
;
}
let
cap
=
new
Capture
(
url
this
.
_onCaptureOrTimeout
.
bind
(
this
)
options
)
;
this
.
_captureQueue
.
push
(
cap
)
;
this
.
_capturesByURL
.
set
(
url
cap
)
;
this
.
_processCaptureQueue
(
)
;
}
async
captureIfMissing
(
url
options
=
{
}
)
{
if
(
!
PageThumbs
.
_prefEnabled
(
)
)
{
if
(
options
.
onDone
)
options
.
onDone
(
url
)
;
return
url
;
}
let
exists
=
await
PageThumbsStorage
.
fileExistsForURL
(
url
)
;
if
(
exists
)
{
if
(
options
.
onDone
)
{
options
.
onDone
(
url
)
;
}
return
url
;
}
let
thumbPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
observe
=
(
subject
topic
data
)
=
>
{
if
(
data
=
=
=
url
)
{
switch
(
topic
)
{
case
"
page
-
thumbnail
:
create
"
:
resolve
(
)
;
break
;
case
"
page
-
thumbnail
:
error
"
:
reject
(
new
Error
(
"
page
-
thumbnail
:
error
"
)
)
;
break
;
}
cleanup
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observe
"
page
-
thumbnail
:
create
"
)
;
Services
.
obs
.
addObserver
(
observe
"
page
-
thumbnail
:
error
"
)
;
function
cleanup
(
)
{
if
(
observe
)
{
Services
.
obs
.
removeObserver
(
observe
"
page
-
thumbnail
:
create
"
)
;
Services
.
obs
.
removeObserver
(
observe
"
page
-
thumbnail
:
error
"
)
;
observe
=
null
;
}
}
if
(
options
.
unloadingPromise
)
{
options
.
unloadingPromise
.
then
(
cleanup
)
;
}
}
)
;
try
{
this
.
capture
(
url
options
)
;
await
thumbPromise
;
}
catch
(
err
)
{
if
(
options
.
onDone
)
{
options
.
onDone
(
url
)
;
}
throw
err
;
}
return
url
;
}
renewThumbnailBrowser
(
)
{
this
.
_renewThumbBrowser
=
true
;
}
_ensureParentWindowReady
(
)
{
if
(
this
.
_parentWin
)
return
true
;
if
(
this
.
_startedParentWinInit
)
return
false
;
this
.
_startedParentWinInit
=
true
;
let
wlBrowser
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
wlBrowser
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
;
let
webProgress
=
wlBrowser
.
getInterface
(
Ci
.
nsIWebProgress
)
;
this
.
_listener
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsIWebProgressListener2
Ci
.
nsISupportsWeakReference
]
)
}
;
this
.
_listener
.
onStateChange
=
(
wbp
request
stateFlags
status
)
=
>
{
if
(
!
request
)
{
return
;
}
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
)
{
webProgress
.
removeProgressListener
(
this
.
_listener
)
;
delete
this
.
_listener
;
this
.
_parentWin
=
wlBrowser
.
document
.
defaultView
;
this
.
_processCaptureQueue
(
)
;
}
}
;
webProgress
.
addProgressListener
(
this
.
_listener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
)
;
let
loadURIOptions
=
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
;
wlBrowser
.
loadURI
(
"
chrome
:
/
/
global
/
content
/
backgroundPageThumbs
.
xhtml
"
loadURIOptions
)
;
this
.
_windowlessContainer
=
wlBrowser
;
return
false
;
}
_init
(
)
{
Services
.
prefs
.
addObserver
(
ABOUT_NEWTAB_SEGREGATION_PREF
this
)
;
Services
.
obs
.
addObserver
(
this
"
profile
-
before
-
change
"
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
profile
-
before
-
change
"
)
{
this
.
_destroy
(
)
;
}
else
if
(
topic
=
=
"
nsPref
:
changed
"
&
&
data
=
=
ABOUT_NEWTAB_SEGREGATION_PREF
)
{
BackgroundPageThumbs
.
renewThumbnailBrowser
(
)
;
}
}
_destroy
(
)
{
if
(
this
.
_captureQueue
)
this
.
_captureQueue
.
forEach
(
cap
=
>
cap
.
destroy
(
)
)
;
this
.
_destroyBrowser
(
)
;
if
(
this
.
_windowlessContainer
)
this
.
_windowlessContainer
.
close
(
)
;
delete
this
.
_captureQueue
;
delete
this
.
_windowlessContainer
;
delete
this
.
_startedParentWinInit
;
delete
this
.
_parentWin
;
delete
this
.
_listener
;
}
_ensureBrowser
(
)
{
if
(
this
.
_thumbBrowser
&
&
!
this
.
_renewThumbBrowser
)
return
;
this
.
_destroyBrowser
(
)
;
this
.
_renewThumbBrowser
=
false
;
let
browser
=
this
.
_parentWin
.
document
.
createXULElement
(
"
browser
"
)
;
browser
.
setAttribute
(
"
type
"
"
content
"
)
;
browser
.
setAttribute
(
"
remote
"
"
true
"
)
;
browser
.
setAttribute
(
"
disableglobalhistory
"
"
true
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
ABOUT_NEWTAB_SEGREGATION_PREF
)
)
{
let
privateIdentity
=
ContextualIdentityService
.
getPrivateIdentity
(
"
userContextIdInternal
.
thumbnail
"
)
;
browser
.
setAttribute
(
"
usercontextid
"
privateIdentity
.
userContextId
)
;
}
let
[
swidth
sheight
]
=
[
{
}
{
}
]
;
Cc
[
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
]
.
getService
(
Ci
.
nsIScreenManager
)
.
primaryScreen
.
GetRectDisplayPix
(
{
}
{
}
swidth
sheight
)
;
let
bwidth
=
Math
.
min
(
1024
swidth
.
value
)
;
browser
.
style
.
width
=
bwidth
+
"
px
"
;
browser
.
style
.
height
=
(
bwidth
*
sheight
.
value
/
swidth
.
value
)
+
"
px
"
;
this
.
_parentWin
.
document
.
documentElement
.
appendChild
(
browser
)
;
browser
.
addEventListener
(
"
oop
-
browser
-
crashed
"
(
)
=
>
{
Cu
.
reportError
(
"
BackgroundThumbnails
remote
process
crashed
-
recovering
"
)
;
this
.
_destroyBrowser
(
)
;
let
curCapture
=
this
.
_captureQueue
.
length
?
this
.
_captureQueue
[
0
]
:
null
;
if
(
curCapture
&
&
curCapture
.
pending
)
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
curCapture
.
_done
(
null
TEL_CAPTURE_DONE_CRASHED
)
;
}
)
;
}
}
)
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_URL
false
)
;
browser
.
docShellIsActive
=
false
;
this
.
_thumbBrowser
=
browser
;
}
_destroyBrowser
(
)
{
if
(
!
this
.
_thumbBrowser
)
return
;
this
.
_thumbBrowser
.
remove
(
)
;
delete
this
.
_thumbBrowser
;
}
_processCaptureQueue
(
)
{
if
(
!
this
.
_captureQueue
.
length
|
|
this
.
_captureQueue
[
0
]
.
pending
|
|
!
this
.
_ensureParentWindowReady
(
)
)
return
;
this
.
_ensureBrowser
(
)
;
this
.
_captureQueue
[
0
]
.
start
(
this
.
_thumbBrowser
.
messageManager
)
;
if
(
this
.
_destroyBrowserTimer
)
{
this
.
_destroyBrowserTimer
.
cancel
(
)
;
delete
this
.
_destroyBrowserTimer
;
}
}
_onCaptureOrTimeout
(
capture
)
{
if
(
capture
!
=
=
this
.
_captureQueue
[
0
]
)
throw
new
Error
(
"
The
capture
should
be
at
the
head
of
the
queue
.
"
)
;
this
.
_captureQueue
.
shift
(
)
;
this
.
_capturesByURL
.
delete
(
capture
.
url
)
;
if
(
capture
.
doneReason
!
=
TEL_CAPTURE_DONE_OK
)
{
Services
.
obs
.
notifyObservers
(
null
"
page
-
thumbnail
:
error
"
capture
.
url
)
;
}
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
initWithCallback
(
this
.
_destroyBrowser
.
bind
(
this
)
this
.
_destroyBrowserTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
this
.
_destroyBrowserTimer
=
timer
;
this
.
_processCaptureQueue
(
)
;
}
_destroyBrowserTimeout
:
DESTROY_BROWSER_TIMEOUT
}
;
BackgroundPageThumbs
.
_init
(
)
;
Object
.
defineProperty
(
this
"
BackgroundPageThumbs
"
{
value
:
BackgroundPageThumbs
enumerable
:
true
writable
:
false
}
)
;
function
Capture
(
url
captureCallback
options
)
{
this
.
url
=
url
;
this
.
captureCallback
=
captureCallback
;
this
.
options
=
options
;
this
.
id
=
Capture
.
nextID
+
+
;
this
.
creationDate
=
new
Date
(
)
;
this
.
doneCallbacks
=
[
]
;
this
.
doneReason
=
-
1
;
if
(
options
.
onDone
)
this
.
doneCallbacks
.
push
(
options
.
onDone
)
;
}
Capture
.
prototype
=
{
get
pending
(
)
{
return
!
!
this
.
_msgMan
;
}
start
(
messageManager
)
{
this
.
startDate
=
new
Date
(
)
;
tel
(
"
CAPTURE_QUEUE_TIME_MS
"
this
.
startDate
-
this
.
creationDate
)
;
let
timeout
=
typeof
(
this
.
options
.
timeout
)
=
=
"
number
"
?
this
.
options
.
timeout
:
DEFAULT_CAPTURE_TIMEOUT
;
this
.
_timeoutTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_timeoutTimer
.
initWithCallback
(
this
timeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
this
.
_msgMan
=
messageManager
;
this
.
_msgMan
.
sendAsyncMessage
(
"
BackgroundPageThumbs
:
capture
"
{
id
:
this
.
id
url
:
this
.
url
isImage
:
this
.
options
.
isImage
targetWidth
:
this
.
options
.
targetWidth
backgroundColor
:
this
.
options
.
backgroundColor
}
)
;
this
.
_msgMan
.
addMessageListener
(
"
BackgroundPageThumbs
:
didCapture
"
this
)
;
}
destroy
(
)
{
if
(
this
.
_timeoutTimer
)
{
this
.
_timeoutTimer
.
cancel
(
)
;
delete
this
.
_timeoutTimer
;
}
if
(
this
.
_msgMan
)
{
this
.
_msgMan
.
removeMessageListener
(
"
BackgroundPageThumbs
:
didCapture
"
this
)
;
delete
this
.
_msgMan
;
}
delete
this
.
captureCallback
;
delete
this
.
doneCallbacks
;
delete
this
.
options
;
}
receiveMessage
(
msg
)
{
if
(
msg
.
data
.
imageData
)
tel
(
"
CAPTURE_SERVICE_TIME_MS
"
new
Date
(
)
-
this
.
startDate
)
;
if
(
msg
.
data
.
id
!
=
this
.
id
)
return
;
if
(
msg
.
data
.
failReason
)
{
let
reason
=
global
[
"
TEL_CAPTURE_DONE_
"
+
msg
.
data
.
failReason
]
;
this
.
_done
(
null
reason
)
;
return
;
}
this
.
_done
(
msg
.
data
TEL_CAPTURE_DONE_OK
)
;
}
notify
(
)
{
this
.
_done
(
null
TEL_CAPTURE_DONE_TIMEOUT
)
;
}
_done
(
data
reason
)
{
let
{
captureCallback
doneCallbacks
options
}
=
this
;
this
.
destroy
(
)
;
this
.
doneReason
=
reason
;
if
(
typeof
(
reason
)
!
=
"
number
"
)
{
throw
new
Error
(
"
A
done
reason
must
be
given
.
"
)
;
}
tel
(
"
CAPTURE_DONE_REASON_2
"
reason
)
;
if
(
data
&
&
data
.
telemetry
)
{
for
(
let
id
in
data
.
telemetry
)
{
tel
(
id
data
.
telemetry
[
id
]
)
;
}
}
let
done
=
(
)
=
>
{
captureCallback
(
this
)
;
for
(
let
callback
of
doneCallbacks
)
{
try
{
callback
.
call
(
options
this
.
url
this
.
doneReason
)
;
}
catch
(
err
)
{
Cu
.
reportError
(
err
)
;
}
}
if
(
Services
.
prefs
.
getBoolPref
(
ABOUT_NEWTAB_SEGREGATION_PREF
)
)
{
let
privateIdentity
=
ContextualIdentityService
.
getPrivateIdentity
(
"
userContextIdInternal
.
thumbnail
"
)
;
if
(
privateIdentity
)
{
Services
.
clearData
.
deleteDataFromOriginAttributesPattern
(
{
userContextId
:
privateIdentity
.
userContextId
}
)
;
}
}
}
;
if
(
!
data
)
{
done
(
)
;
return
;
}
PageThumbs
.
_store
(
this
.
url
data
.
finalURL
data
.
imageData
true
)
.
then
(
done
done
)
;
}
}
;
Capture
.
nextID
=
0
;
function
tel
(
histogramID
value
)
{
let
id
=
TELEMETRY_HISTOGRAM_ID_PREFIX
+
histogramID
;
Services
.
telemetry
.
getHistogramById
(
id
)
.
add
(
value
)
;
}
function
schedule
(
callback
)
{
Services
.
tm
.
dispatchToMainThread
(
callback
)
;
}
