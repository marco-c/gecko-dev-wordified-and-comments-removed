"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PageThumbs
"
"
PageThumbsStorage
"
]
;
const
PREF_STORAGE_VERSION
=
"
browser
.
pagethumbnails
.
storage_version
"
;
const
LATEST_STORAGE_VERSION
=
3
;
const
EXPIRATION_MIN_CHUNK_SIZE
=
50
;
const
EXPIRATION_INTERVAL_SECS
=
3600
;
const
MAX_THUMBNAIL_AGE_SECS
=
172800
;
const
THUMBNAIL_DIRECTORY
=
"
thumbnails
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
BasePromiseWorker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseWorker
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
FileReader
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
PageThumbUtils
:
"
resource
:
/
/
gre
/
modules
/
PageThumbUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gUpdateTimerManager
"
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
"
nsIUpdateTimerManager
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
PageThumbsStorageService
"
"
mozilla
.
org
/
thumbnails
/
pagethumbs
-
service
;
1
"
"
nsIPageThumbsStorageService
"
)
;
const
TaskUtils
=
{
readBlob
:
function
readBlob
(
blob
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
reader
=
new
FileReader
(
)
;
reader
.
onloadend
=
function
onloadend
(
)
{
if
(
reader
.
readyState
!
=
FileReader
.
DONE
)
{
reject
(
reader
.
error
)
;
}
else
{
resolve
(
reader
.
result
)
;
}
}
;
reader
.
readAsArrayBuffer
(
blob
)
;
}
)
;
}
}
;
var
PageThumbs
=
{
_initialized
:
false
_thumbnailWidth
:
0
_thumbnailHeight
:
0
get
scheme
(
)
{
return
"
moz
-
page
-
thumb
"
;
}
get
staticHost
(
)
{
return
"
thumbnails
"
;
}
get
contentType
(
)
{
return
"
image
/
png
"
;
}
init
:
function
PageThumbs_init
(
)
{
if
(
!
this
.
_initialized
)
{
this
.
_initialized
=
true
;
this
.
_placesObserver
=
new
PlacesWeakCallbackWrapper
(
this
.
handlePlacesEvents
.
bind
(
this
)
)
;
PlacesObservers
.
addListener
(
[
"
history
-
cleared
"
"
page
-
removed
"
]
this
.
_placesObserver
)
;
PageThumbsStorageMigrator
.
migrate
(
)
;
PageThumbsExpiration
.
init
(
)
;
}
}
handlePlacesEvents
(
events
)
{
for
(
const
event
of
events
)
{
switch
(
event
.
type
)
{
case
"
history
-
cleared
"
:
{
PageThumbsStorage
.
wipe
(
)
;
break
;
}
case
"
page
-
removed
"
:
{
if
(
event
.
isRemovedFromStore
)
{
PageThumbsStorage
.
remove
(
event
.
url
)
;
}
break
;
}
}
}
}
uninit
:
function
PageThumbs_uninit
(
)
{
if
(
this
.
_initialized
)
{
this
.
_initialized
=
false
;
}
}
getThumbnailURL
:
function
PageThumbs_getThumbnailURL
(
aUrl
)
{
return
(
this
.
scheme
+
"
:
/
/
"
+
this
.
staticHost
+
"
/
?
url
=
"
+
encodeURIComponent
(
aUrl
)
+
"
&
revision
=
"
+
PageThumbsStorage
.
getRevision
(
aUrl
)
)
;
}
getThumbnailPath
:
function
PageThumbs_getThumbnailPath
(
aUrl
)
{
return
PageThumbsStorageService
.
getFilePathForURL
(
aUrl
)
;
}
captureToBlob
:
function
PageThumbs_captureToBlob
(
aBrowser
aArgs
)
{
if
(
!
this
.
_prefEnabled
(
)
)
{
return
null
;
}
return
new
Promise
(
resolve
=
>
{
let
canvas
=
this
.
createCanvas
(
aBrowser
.
ownerGlobal
)
;
this
.
captureToCanvas
(
aBrowser
canvas
aArgs
)
.
then
(
(
)
=
>
{
canvas
.
toBlob
(
blob
=
>
{
resolve
(
blob
this
.
contentType
)
;
}
)
;
}
)
.
catch
(
e
=
>
Cu
.
reportError
(
e
)
)
;
}
)
;
}
async
captureToCanvas
(
aBrowser
aCanvas
aArgs
aSkipTelemetry
=
false
)
{
let
telemetryCaptureTime
=
new
Date
(
)
;
let
args
=
{
fullScale
:
aArgs
?
aArgs
.
fullScale
:
false
isImage
:
aArgs
?
aArgs
.
isImage
:
false
backgroundColor
:
aArgs
?
.
backgroundColor
?
?
PageThumbUtils
.
THUMBNAIL_BG_COLOR
targetWidth
:
aArgs
?
.
targetWidth
?
?
PageThumbUtils
.
THUMBNAIL_DEFAULT_SIZE
isBackgroundThumb
:
aArgs
?
aArgs
.
isBackgroundThumb
:
false
fullViewport
:
aArgs
?
.
fullViewport
?
?
false
}
;
return
this
.
_captureToCanvas
(
aBrowser
aCanvas
args
)
.
then
(
(
)
=
>
{
if
(
!
aSkipTelemetry
)
{
Services
.
telemetry
.
getHistogramById
(
"
FX_THUMBNAILS_CAPTURE_TIME_MS
"
)
.
add
(
new
Date
(
)
-
telemetryCaptureTime
)
;
}
return
aCanvas
;
}
)
;
}
async
shouldStoreThumbnail
(
aBrowser
)
{
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
aBrowser
)
)
{
return
false
;
}
if
(
aBrowser
.
isRemoteBrowser
)
{
if
(
aBrowser
.
browsingContext
.
currentWindowGlobal
)
{
let
thumbnailsActor
=
aBrowser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
Thumbnails
"
)
;
return
thumbnailsActor
.
sendQuery
(
"
Browser
:
Thumbnail
:
CheckState
"
)
.
catch
(
err
=
>
{
return
false
;
}
)
;
}
return
false
;
}
return
PageThumbUtils
.
shouldStoreContentThumbnail
(
aBrowser
.
contentDocument
aBrowser
.
docShell
)
;
}
async
_captureToCanvas
(
aBrowser
aCanvas
aArgs
)
{
if
(
aBrowser
.
isRemoteBrowser
)
{
let
thumbnail
=
await
this
.
_captureRemoteThumbnail
(
aBrowser
aCanvas
.
width
aCanvas
.
height
aArgs
)
;
if
(
thumbnail
)
{
let
ctx
=
thumbnail
.
getContext
(
"
2d
"
)
;
let
imgData
=
ctx
.
getImageData
(
0
0
thumbnail
.
width
thumbnail
.
height
)
;
aCanvas
.
width
=
thumbnail
.
width
;
aCanvas
.
height
=
thumbnail
.
height
;
aCanvas
.
getContext
(
"
2d
"
)
.
putImageData
(
imgData
0
0
)
;
}
return
aCanvas
;
}
await
PageThumbUtils
.
createSnapshotThumbnail
(
aBrowser
aCanvas
aArgs
)
;
return
aCanvas
;
}
async
_captureRemoteThumbnail
(
aBrowser
aWidth
aHeight
aArgs
)
{
if
(
!
aBrowser
.
browsingContext
|
|
!
aBrowser
.
parentElement
)
{
return
null
;
}
let
thumbnailsActor
=
aBrowser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
aArgs
.
isBackgroundThumb
?
"
BackgroundThumbnails
"
:
"
Thumbnails
"
)
;
let
contentInfo
=
await
thumbnailsActor
.
sendQuery
(
"
Browser
:
Thumbnail
:
ContentInfo
"
{
isImage
:
aArgs
.
isImage
targetWidth
:
aArgs
.
targetWidth
backgroundColor
:
aArgs
.
backgroundColor
}
)
;
let
contentWidth
=
contentInfo
.
width
;
let
contentHeight
=
contentInfo
.
height
;
if
(
contentWidth
=
=
0
|
|
contentHeight
=
=
0
)
{
throw
new
Error
(
"
IMAGE_ZERO_DIMENSION
"
)
;
}
let
doc
=
aBrowser
.
parentElement
.
ownerDocument
;
let
thumbnail
=
doc
.
createElementNS
(
PageThumbUtils
.
HTML_NAMESPACE
"
canvas
"
)
;
let
image
;
if
(
contentInfo
.
imageData
)
{
thumbnail
.
width
=
contentWidth
;
thumbnail
.
height
=
contentHeight
;
image
=
new
aBrowser
.
ownerGlobal
.
Image
(
)
;
await
new
Promise
(
resolve
=
>
{
image
.
onload
=
resolve
;
image
.
src
=
contentInfo
.
imageData
;
}
)
;
}
else
{
let
fullScale
=
aArgs
?
aArgs
.
fullScale
:
false
;
let
scale
=
fullScale
?
1
:
Math
.
min
(
Math
.
max
(
aWidth
/
contentWidth
aHeight
/
contentHeight
)
1
)
;
image
=
await
aBrowser
.
drawSnapshot
(
0
0
contentWidth
contentHeight
scale
aArgs
.
backgroundColor
aArgs
.
fullViewport
)
;
thumbnail
.
width
=
fullScale
?
contentWidth
:
aWidth
;
thumbnail
.
height
=
fullScale
?
contentHeight
:
aHeight
;
}
thumbnail
.
getContext
(
"
2d
"
)
.
drawImage
(
image
0
0
)
;
return
thumbnail
;
}
captureAndStore
:
async
function
PageThumbs_captureAndStore
(
aBrowser
)
{
if
(
!
this
.
_prefEnabled
(
)
)
{
return
;
}
let
url
=
aBrowser
.
currentURI
.
spec
;
let
originalURL
;
let
channelError
=
false
;
if
(
!
aBrowser
.
isRemoteBrowser
)
{
let
channel
=
aBrowser
.
docShell
.
currentDocumentChannel
;
originalURL
=
channel
.
originalURI
.
spec
;
channelError
=
PageThumbUtils
.
isChannelErrorResponse
(
channel
)
;
}
else
{
let
thumbnailsActor
=
aBrowser
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
Thumbnails
"
)
;
let
resp
=
await
thumbnailsActor
.
sendQuery
(
"
Browser
:
Thumbnail
:
GetOriginalURL
"
)
;
originalURL
=
resp
.
originalURL
|
|
url
;
channelError
=
resp
.
channelError
;
}
try
{
let
blob
=
await
this
.
captureToBlob
(
aBrowser
)
;
let
buffer
=
await
TaskUtils
.
readBlob
(
blob
)
;
await
this
.
_store
(
originalURL
url
buffer
channelError
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Exception
thrown
during
thumbnail
capture
:
'
"
+
ex
+
"
'
"
)
;
}
}
captureAndStoreIfStale
:
async
function
PageThumbs_captureAndStoreIfStale
(
aBrowser
)
{
if
(
!
aBrowser
.
currentURI
)
{
return
false
;
}
let
url
=
aBrowser
.
currentURI
.
spec
;
let
recent
;
try
{
recent
=
await
PageThumbsStorage
.
isFileRecentForURL
(
url
)
;
}
catch
{
return
false
;
}
if
(
!
recent
&
&
aBrowser
.
currentURI
&
&
aBrowser
.
currentURI
.
spec
=
=
url
)
{
await
this
.
captureAndStore
(
aBrowser
)
;
}
return
true
;
}
_store
:
async
function
PageThumbs__store
(
aOriginalURL
aFinalURL
aData
aNoOverwrite
)
{
let
telemetryStoreTime
=
new
Date
(
)
;
await
PageThumbsStorage
.
writeData
(
aFinalURL
aData
aNoOverwrite
)
;
Services
.
telemetry
.
getHistogramById
(
"
FX_THUMBNAILS_STORE_TIME_MS
"
)
.
add
(
new
Date
(
)
-
telemetryStoreTime
)
;
Services
.
obs
.
notifyObservers
(
null
"
page
-
thumbnail
:
create
"
aFinalURL
)
;
if
(
aFinalURL
!
=
aOriginalURL
)
{
await
PageThumbsStorage
.
copy
(
aFinalURL
aOriginalURL
aNoOverwrite
)
;
Services
.
obs
.
notifyObservers
(
null
"
page
-
thumbnail
:
create
"
aOriginalURL
)
;
}
}
addExpirationFilter
:
function
PageThumbs_addExpirationFilter
(
aFilter
)
{
PageThumbsExpiration
.
addFilter
(
aFilter
)
;
}
removeExpirationFilter
:
function
PageThumbs_removeExpirationFilter
(
aFilter
)
{
PageThumbsExpiration
.
removeFilter
(
aFilter
)
;
}
createCanvas
:
function
PageThumbs_createCanvas
(
aWindow
)
{
return
PageThumbUtils
.
createCanvas
(
aWindow
)
;
}
_prefEnabled
:
function
PageThumbs_prefEnabled
(
)
{
try
{
return
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
pagethumbnails
.
capturing_disabled
"
)
;
}
catch
(
e
)
{
return
true
;
}
}
}
;
var
PageThumbsStorage
=
{
ensurePath
:
function
Storage_ensurePath
(
)
{
return
PageThumbsWorker
.
post
(
"
makeDir
"
[
PageThumbsStorageService
.
path
{
ignoreExisting
:
true
}
]
)
.
catch
(
function
onError
(
aReason
)
{
Cu
.
reportError
(
"
Could
not
create
thumbnails
directory
"
+
aReason
)
;
}
)
;
}
_revisionTable
:
{
}
updateRevision
(
aURL
)
{
let
rev
=
this
.
_revisionTable
[
aURL
]
;
if
(
rev
=
=
null
)
{
rev
=
Math
.
floor
(
Math
.
random
(
)
*
this
.
_revisionRange
)
;
}
this
.
_revisionTable
[
aURL
]
=
(
rev
+
1
)
%
this
.
_revisionRange
;
}
_revisionRange
:
8192
getRevision
(
aURL
)
{
let
rev
=
this
.
_revisionTable
[
aURL
]
;
if
(
rev
=
=
null
)
{
this
.
updateRevision
(
aURL
)
;
rev
=
this
.
_revisionTable
[
aURL
]
;
}
return
rev
;
}
writeData
:
function
Storage_writeData
(
aURL
aData
aNoOverwrite
)
{
let
path
=
PageThumbsStorageService
.
getFilePathForURL
(
aURL
)
;
this
.
ensurePath
(
)
;
aData
=
new
Uint8Array
(
aData
)
;
let
msg
=
[
path
aData
{
tmpPath
:
path
+
"
.
tmp
"
mode
:
aNoOverwrite
?
"
create
"
:
"
overwrite
"
}
]
;
return
PageThumbsWorker
.
post
(
"
writeAtomic
"
msg
msg
)
.
then
(
(
)
=
>
this
.
updateRevision
(
aURL
)
this
.
_eatNoOverwriteError
(
aNoOverwrite
)
)
;
}
copy
:
function
Storage_copy
(
aSourceURL
aTargetURL
aNoOverwrite
)
{
this
.
ensurePath
(
)
;
let
sourceFile
=
PageThumbsStorageService
.
getFilePathForURL
(
aSourceURL
)
;
let
targetFile
=
PageThumbsStorageService
.
getFilePathForURL
(
aTargetURL
)
;
let
options
=
{
noOverwrite
:
aNoOverwrite
}
;
return
PageThumbsWorker
.
post
(
"
copy
"
[
sourceFile
targetFile
options
]
)
.
then
(
(
)
=
>
this
.
updateRevision
(
aTargetURL
)
this
.
_eatNoOverwriteError
(
aNoOverwrite
)
)
;
}
remove
:
function
Storage_remove
(
aURL
)
{
return
PageThumbsWorker
.
post
(
"
remove
"
[
PageThumbsStorageService
.
getFilePathForURL
(
aURL
)
]
)
;
}
wipe
:
async
function
Storage_wipe
(
)
{
let
blocker
=
(
)
=
>
undefined
;
IOUtils
.
profileBeforeChange
.
addBlocker
(
"
PageThumbs
:
removing
all
thumbnails
"
blocker
)
;
let
promise
=
PageThumbsWorker
.
post
(
"
wipe
"
[
PageThumbsStorageService
.
path
]
)
;
try
{
await
promise
;
}
finally
{
IOUtils
.
profileBeforeChange
.
removeBlocker
(
blocker
)
;
}
}
fileExistsForURL
:
function
Storage_fileExistsForURL
(
aURL
)
{
return
PageThumbsWorker
.
post
(
"
exists
"
[
PageThumbsStorageService
.
getFilePathForURL
(
aURL
)
]
)
;
}
isFileRecentForURL
:
function
Storage_isFileRecentForURL
(
aURL
)
{
return
PageThumbsWorker
.
post
(
"
isFileRecent
"
[
PageThumbsStorageService
.
getFilePathForURL
(
aURL
)
MAX_THUMBNAIL_AGE_SECS
]
)
;
}
_eatNoOverwriteError
:
function
Storage__eatNoOverwriteError
(
aNoOverwrite
)
{
return
function
onError
(
err
)
{
if
(
!
aNoOverwrite
|
|
!
(
err
instanceof
DOMException
)
|
|
err
.
name
!
=
=
"
TypeMismatchError
"
)
{
throw
err
;
}
}
;
}
}
;
var
PageThumbsStorageMigrator
=
{
get
currentVersion
(
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
PREF_STORAGE_VERSION
)
;
}
catch
(
e
)
{
return
0
;
}
}
set
currentVersion
(
aVersion
)
{
Services
.
prefs
.
setIntPref
(
PREF_STORAGE_VERSION
aVersion
)
;
}
migrate
:
function
Migrator_migrate
(
)
{
let
version
=
this
.
currentVersion
;
if
(
version
<
3
)
{
this
.
migrateToVersion3
(
)
;
}
this
.
currentVersion
=
LATEST_STORAGE_VERSION
;
}
migrateToVersion3
:
function
Migrator_migrateToVersion3
(
local
=
Services
.
dirsvc
.
get
(
"
ProfLD
"
Ci
.
nsIFile
)
.
path
roaming
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
path
)
{
PageThumbsWorker
.
post
(
"
moveOrDeleteAllThumbnails
"
[
PathUtils
.
join
(
roaming
THUMBNAIL_DIRECTORY
)
PathUtils
.
join
(
local
THUMBNAIL_DIRECTORY
)
]
)
;
}
}
;
var
PageThumbsExpiration
=
{
_filters
:
[
]
init
:
function
Expiration_init
(
)
{
gUpdateTimerManager
.
registerTimer
(
"
browser
-
cleanup
-
thumbnails
"
this
EXPIRATION_INTERVAL_SECS
)
;
}
addFilter
:
function
Expiration_addFilter
(
aFilter
)
{
this
.
_filters
.
push
(
aFilter
)
;
}
removeFilter
:
function
Expiration_removeFilter
(
aFilter
)
{
let
index
=
this
.
_filters
.
indexOf
(
aFilter
)
;
if
(
index
>
-
1
)
{
this
.
_filters
.
splice
(
index
1
)
;
}
}
notify
:
function
Expiration_notify
(
aTimer
)
{
let
urls
=
[
]
;
let
filtersToWaitFor
=
this
.
_filters
.
length
;
let
expire
=
(
)
=
>
{
this
.
expireThumbnails
(
urls
)
;
}
;
if
(
!
filtersToWaitFor
)
{
expire
(
)
;
return
;
}
function
filterCallback
(
aURLs
)
{
urls
=
urls
.
concat
(
aURLs
)
;
if
(
-
-
filtersToWaitFor
=
=
0
)
{
expire
(
)
;
}
}
for
(
let
filter
of
this
.
_filters
)
{
if
(
typeof
filter
=
=
"
function
"
)
{
filter
(
filterCallback
)
;
}
else
{
filter
.
filterForThumbnailExpiration
(
filterCallback
)
;
}
}
}
expireThumbnails
:
function
Expiration_expireThumbnails
(
aURLsToKeep
)
{
let
keep
=
aURLsToKeep
.
map
(
url
=
>
PageThumbsStorageService
.
getLeafNameForURL
(
url
)
)
;
let
msg
=
[
PageThumbsStorageService
.
path
keep
EXPIRATION_MIN_CHUNK_SIZE
]
;
return
PageThumbsWorker
.
post
(
"
expireFilesInDirectory
"
msg
)
;
}
}
;
var
PageThumbsWorker
=
new
BasePromiseWorker
(
"
resource
:
/
/
gre
/
modules
/
PageThumbsWorker
.
js
"
)
;
