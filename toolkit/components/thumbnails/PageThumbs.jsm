"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PageThumbs
"
"
PageThumbsStorage
"
]
;
const
PREF_STORAGE_VERSION
=
"
browser
.
pagethumbnails
.
storage_version
"
;
const
LATEST_STORAGE_VERSION
=
3
;
const
EXPIRATION_MIN_CHUNK_SIZE
=
50
;
const
EXPIRATION_INTERVAL_SECS
=
3600
;
var
gRemoteThumbId
=
0
;
const
MAX_THUMBNAIL_AGE_SECS
=
172800
;
const
THUMBNAIL_DIRECTORY
=
"
thumbnails
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseWorker
.
jsm
"
this
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
this
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
FileReader
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Deprecated
:
"
resource
:
/
/
gre
/
modules
/
Deprecated
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
PageThumbUtils
:
"
resource
:
/
/
gre
/
modules
/
PageThumbUtils
.
jsm
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gUpdateTimerManager
"
"
mozilla
.
org
/
updates
/
timer
-
manager
;
1
"
"
nsIUpdateTimerManager
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
PageThumbsStorageService
"
"
mozilla
.
org
/
thumbnails
/
pagethumbs
-
service
;
1
"
"
nsIPageThumbsStorageService
"
)
;
const
TaskUtils
=
{
readBlob
:
function
readBlob
(
blob
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
reader
=
new
FileReader
(
)
;
reader
.
onloadend
=
function
onloadend
(
)
{
if
(
reader
.
readyState
!
=
FileReader
.
DONE
)
{
reject
(
reader
.
error
)
;
}
else
{
resolve
(
reader
.
result
)
;
}
}
;
reader
.
readAsArrayBuffer
(
blob
)
;
}
)
;
}
}
;
var
PageThumbs
=
{
_initialized
:
false
_thumbnailWidth
:
0
_thumbnailHeight
:
0
get
scheme
(
)
{
return
"
moz
-
page
-
thumb
"
;
}
get
staticHost
(
)
{
return
"
thumbnail
"
;
}
get
contentType
(
)
{
return
"
image
/
png
"
;
}
init
:
function
PageThumbs_init
(
)
{
if
(
!
this
.
_initialized
)
{
this
.
_initialized
=
true
;
PlacesUtils
.
history
.
addObserver
(
PageThumbsHistoryObserver
true
)
;
PageThumbsStorageMigrator
.
migrate
(
)
;
PageThumbsExpiration
.
init
(
)
;
}
}
uninit
:
function
PageThumbs_uninit
(
)
{
if
(
this
.
_initialized
)
{
this
.
_initialized
=
false
;
}
}
getThumbnailURL
:
function
PageThumbs_getThumbnailURL
(
aUrl
)
{
return
(
this
.
scheme
+
"
:
/
/
"
+
this
.
staticHost
+
"
/
?
url
=
"
+
encodeURIComponent
(
aUrl
)
+
"
&
revision
=
"
+
PageThumbsStorage
.
getRevision
(
aUrl
)
)
;
}
getThumbnailPath
:
function
PageThumbs_getThumbnailPath
(
aUrl
)
{
return
PageThumbsStorageService
.
getFilePathForURL
(
aUrl
)
;
}
captureToBlob
:
function
PageThumbs_captureToBlob
(
aBrowser
)
{
if
(
!
this
.
_prefEnabled
(
)
)
{
return
null
;
}
return
new
Promise
(
resolve
=
>
{
let
canvas
=
this
.
createCanvas
(
aBrowser
.
ownerGlobal
)
;
this
.
captureToCanvas
(
aBrowser
canvas
(
)
=
>
{
canvas
.
toBlob
(
blob
=
>
{
resolve
(
blob
this
.
contentType
)
;
}
)
;
}
)
;
}
)
;
}
captureToCanvas
(
aBrowser
aCanvas
aCallback
aArgs
)
{
let
telemetryCaptureTime
=
new
Date
(
)
;
let
args
=
{
fullScale
:
aArgs
?
aArgs
.
fullScale
:
false
}
;
this
.
_captureToCanvas
(
aBrowser
aCanvas
args
aCanvas
=
>
{
Services
.
telemetry
.
getHistogramById
(
"
FX_THUMBNAILS_CAPTURE_TIME_MS
"
)
.
add
(
new
Date
(
)
-
telemetryCaptureTime
)
;
if
(
aCallback
)
{
aCallback
(
aCanvas
)
;
}
}
)
;
}
shouldStoreThumbnail
(
aBrowser
aCallback
)
{
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
aBrowser
)
)
{
aCallback
(
false
)
;
return
;
}
if
(
aBrowser
.
isRemoteBrowser
)
{
let
mm
=
aBrowser
.
messageManager
;
let
resultFunc
=
function
(
aMsg
)
{
mm
.
removeMessageListener
(
"
Browser
:
Thumbnail
:
CheckState
:
Response
"
resultFunc
)
;
aCallback
(
aMsg
.
data
.
result
)
;
}
;
mm
.
addMessageListener
(
"
Browser
:
Thumbnail
:
CheckState
:
Response
"
resultFunc
)
;
try
{
mm
.
sendAsyncMessage
(
"
Browser
:
Thumbnail
:
CheckState
"
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
resultFunc
(
{
data
:
{
result
:
false
}
}
)
;
}
}
else
{
aCallback
(
PageThumbUtils
.
shouldStoreContentThumbnail
(
aBrowser
.
contentDocument
aBrowser
.
docShell
)
)
;
}
}
_captureToCanvas
(
aBrowser
aCanvas
aArgs
aCallback
)
{
if
(
aBrowser
.
isRemoteBrowser
)
{
(
async
(
)
=
>
{
let
data
=
await
this
.
_captureRemoteThumbnail
(
aBrowser
aCanvas
.
width
aCanvas
.
height
aArgs
)
;
let
canvas
=
data
.
thumbnail
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
let
imgData
=
ctx
.
getImageData
(
0
0
canvas
.
width
canvas
.
height
)
;
aCanvas
.
width
=
canvas
.
width
;
aCanvas
.
height
=
canvas
.
height
;
aCanvas
.
getContext
(
"
2d
"
)
.
putImageData
(
imgData
0
0
)
;
if
(
aCallback
)
{
aCallback
(
aCanvas
)
;
}
}
)
(
)
;
return
;
}
PageThumbUtils
.
createSnapshotThumbnail
(
aBrowser
.
contentWindow
aCanvas
aArgs
)
;
if
(
aCallback
)
{
aCallback
(
aCanvas
)
;
}
}
_captureRemoteThumbnail
(
aBrowser
aWidth
aHeight
aArgs
)
{
return
new
Promise
(
resolve
=
>
{
let
index
=
gRemoteThumbId
+
+
;
let
mm
=
aBrowser
.
messageManager
;
let
thumbFunc
=
function
(
aMsg
)
{
if
(
aMsg
.
data
.
id
!
=
index
)
{
return
;
}
mm
.
removeMessageListener
(
"
Browser
:
Thumbnail
:
Response
"
thumbFunc
)
;
let
imageBlob
=
aMsg
.
data
.
thumbnail
;
let
doc
=
aBrowser
.
parentElement
.
ownerDocument
;
let
reader
=
new
FileReader
(
)
;
reader
.
addEventListener
(
"
loadend
"
function
(
)
{
let
image
=
doc
.
createElementNS
(
PageThumbUtils
.
HTML_NAMESPACE
"
img
"
)
;
image
.
onload
=
function
(
)
{
let
thumbnail
=
doc
.
createElementNS
(
PageThumbUtils
.
HTML_NAMESPACE
"
canvas
"
)
;
thumbnail
.
width
=
image
.
naturalWidth
;
thumbnail
.
height
=
image
.
naturalHeight
;
let
ctx
=
thumbnail
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
image
0
0
)
;
resolve
(
{
thumbnail
}
)
;
}
;
image
.
src
=
reader
.
result
;
}
)
;
reader
.
readAsDataURL
(
imageBlob
)
;
}
;
mm
.
addMessageListener
(
"
Browser
:
Thumbnail
:
Response
"
thumbFunc
)
;
mm
.
sendAsyncMessage
(
"
Browser
:
Thumbnail
:
Request
"
{
canvasWidth
:
aWidth
canvasHeight
:
aHeight
background
:
PageThumbUtils
.
THUMBNAIL_BG_COLOR
id
:
index
additionalArgs
:
aArgs
}
)
;
}
)
;
}
captureAndStore
:
function
PageThumbs_captureAndStore
(
aBrowser
aCallback
)
{
if
(
!
this
.
_prefEnabled
(
)
)
{
return
;
}
let
url
=
aBrowser
.
currentURI
.
spec
;
let
originalURL
;
let
channelError
=
false
;
(
async
(
)
=
>
{
if
(
!
aBrowser
.
isRemoteBrowser
)
{
let
channel
=
aBrowser
.
docShell
.
currentDocumentChannel
;
originalURL
=
channel
.
originalURI
.
spec
;
channelError
=
PageThumbUtils
.
isChannelErrorResponse
(
channel
)
;
}
else
{
let
resp
=
await
new
Promise
(
resolve
=
>
{
let
mm
=
aBrowser
.
messageManager
;
let
respName
=
"
Browser
:
Thumbnail
:
GetOriginalURL
:
Response
"
;
mm
.
addMessageListener
(
respName
function
onResp
(
msg
)
{
mm
.
removeMessageListener
(
respName
onResp
)
;
resolve
(
msg
.
data
)
;
}
)
;
mm
.
sendAsyncMessage
(
"
Browser
:
Thumbnail
:
GetOriginalURL
"
)
;
}
)
;
originalURL
=
resp
.
originalURL
|
|
url
;
channelError
=
resp
.
channelError
;
}
let
isSuccess
=
true
;
try
{
let
blob
=
await
this
.
captureToBlob
(
aBrowser
)
;
let
buffer
=
await
TaskUtils
.
readBlob
(
blob
)
;
await
this
.
_store
(
originalURL
url
buffer
channelError
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
"
Exception
thrown
during
thumbnail
capture
:
'
"
+
ex
+
"
'
"
)
;
isSuccess
=
false
;
}
if
(
aCallback
)
{
aCallback
(
isSuccess
)
;
}
}
)
(
)
;
}
captureAndStoreIfStale
:
function
PageThumbs_captureAndStoreIfStale
(
aBrowser
aCallback
)
{
let
url
=
aBrowser
.
currentURI
.
spec
;
PageThumbsStorage
.
isFileRecentForURL
(
url
)
.
then
(
recent
=
>
{
if
(
!
recent
&
&
aBrowser
.
currentURI
&
&
aBrowser
.
currentURI
.
spec
=
=
url
)
{
this
.
captureAndStore
(
aBrowser
aCallback
)
;
}
else
if
(
aCallback
)
{
aCallback
(
true
)
;
}
}
err
=
>
{
if
(
aCallback
)
{
aCallback
(
false
)
;
}
}
)
;
}
_store
:
function
PageThumbs__store
(
aOriginalURL
aFinalURL
aData
aNoOverwrite
)
{
return
(
async
function
(
)
{
let
telemetryStoreTime
=
new
Date
(
)
;
await
PageThumbsStorage
.
writeData
(
aFinalURL
aData
aNoOverwrite
)
;
Services
.
telemetry
.
getHistogramById
(
"
FX_THUMBNAILS_STORE_TIME_MS
"
)
.
add
(
new
Date
(
)
-
telemetryStoreTime
)
;
Services
.
obs
.
notifyObservers
(
null
"
page
-
thumbnail
:
create
"
aFinalURL
)
;
if
(
aFinalURL
!
=
aOriginalURL
)
{
await
PageThumbsStorage
.
copy
(
aFinalURL
aOriginalURL
aNoOverwrite
)
;
Services
.
obs
.
notifyObservers
(
null
"
page
-
thumbnail
:
create
"
aOriginalURL
)
;
}
}
)
(
)
;
}
addExpirationFilter
:
function
PageThumbs_addExpirationFilter
(
aFilter
)
{
PageThumbsExpiration
.
addFilter
(
aFilter
)
;
}
removeExpirationFilter
:
function
PageThumbs_removeExpirationFilter
(
aFilter
)
{
PageThumbsExpiration
.
removeFilter
(
aFilter
)
;
}
createCanvas
:
function
PageThumbs_createCanvas
(
aWindow
)
{
return
PageThumbUtils
.
createCanvas
(
aWindow
)
;
}
_prefEnabled
:
function
PageThumbs_prefEnabled
(
)
{
try
{
return
!
Services
.
prefs
.
getBoolPref
(
"
browser
.
pagethumbnails
.
capturing_disabled
"
)
;
}
catch
(
e
)
{
return
true
;
}
}
}
;
var
PageThumbsStorage
=
{
ensurePath
:
function
Storage_ensurePath
(
)
{
return
PageThumbsWorker
.
post
(
"
makeDir
"
[
PageThumbsStorageService
.
path
{
ignoreExisting
:
true
}
]
)
.
catch
(
function
onError
(
aReason
)
{
Cu
.
reportError
(
"
Could
not
create
thumbnails
directory
"
+
aReason
)
;
}
)
;
}
_revisionTable
:
{
}
_updateRevision
(
aURL
)
{
let
rev
=
this
.
_revisionTable
[
aURL
]
;
if
(
rev
=
=
null
)
{
rev
=
Math
.
floor
(
Math
.
random
(
)
*
this
.
_revisionRange
)
;
}
this
.
_revisionTable
[
aURL
]
=
(
rev
+
1
)
%
this
.
_revisionRange
;
}
_revisionRange
:
8192
getRevision
(
aURL
)
{
let
rev
=
this
.
_revisionTable
[
aURL
]
;
if
(
rev
=
=
null
)
{
this
.
_updateRevision
(
aURL
)
;
rev
=
this
.
_revisionTable
[
aURL
]
;
}
return
rev
;
}
writeData
:
function
Storage_writeData
(
aURL
aData
aNoOverwrite
)
{
let
path
=
PageThumbsStorageService
.
getFilePathForURL
(
aURL
)
;
this
.
ensurePath
(
)
;
aData
=
new
Uint8Array
(
aData
)
;
let
msg
=
[
path
aData
{
tmpPath
:
path
+
"
.
tmp
"
bytes
:
aData
.
byteLength
noOverwrite
:
aNoOverwrite
flush
:
false
}
]
;
return
PageThumbsWorker
.
post
(
"
writeAtomic
"
msg
msg
)
.
then
(
(
)
=
>
this
.
_updateRevision
(
aURL
)
this
.
_eatNoOverwriteError
(
aNoOverwrite
)
)
;
}
copy
:
function
Storage_copy
(
aSourceURL
aTargetURL
aNoOverwrite
)
{
this
.
ensurePath
(
)
;
let
sourceFile
=
PageThumbsStorageService
.
getFilePathForURL
(
aSourceURL
)
;
let
targetFile
=
PageThumbsStorageService
.
getFilePathForURL
(
aTargetURL
)
;
let
options
=
{
noOverwrite
:
aNoOverwrite
}
;
return
PageThumbsWorker
.
post
(
"
copy
"
[
sourceFile
targetFile
options
]
)
.
then
(
(
)
=
>
this
.
_updateRevision
(
aTargetURL
)
this
.
_eatNoOverwriteError
(
aNoOverwrite
)
)
;
}
remove
:
function
Storage_remove
(
aURL
)
{
return
PageThumbsWorker
.
post
(
"
remove
"
[
PageThumbsStorageService
.
getFilePathForURL
(
aURL
)
]
)
;
}
wipe
:
async
function
Storage_wipe
(
)
{
let
blocker
=
(
)
=
>
promise
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
PageThumbs
:
removing
all
thumbnails
"
blocker
)
;
let
promise
=
PageThumbsWorker
.
post
(
"
wipe
"
[
PageThumbsStorageService
.
path
]
)
;
try
{
await
promise
;
}
finally
{
if
(
"
removeBlocker
"
in
AsyncShutdown
.
profileBeforeChange
)
{
AsyncShutdown
.
profileBeforeChange
.
removeBlocker
(
blocker
)
;
}
}
}
fileExistsForURL
:
function
Storage_fileExistsForURL
(
aURL
)
{
return
PageThumbsWorker
.
post
(
"
exists
"
[
PageThumbsStorageService
.
getFilePathForURL
(
aURL
)
]
)
;
}
isFileRecentForURL
:
function
Storage_isFileRecentForURL
(
aURL
)
{
return
PageThumbsWorker
.
post
(
"
isFileRecent
"
[
PageThumbsStorageService
.
getFilePathForURL
(
aURL
)
MAX_THUMBNAIL_AGE_SECS
]
)
;
}
_eatNoOverwriteError
:
function
Storage__eatNoOverwriteError
(
aNoOverwrite
)
{
return
function
onError
(
err
)
{
if
(
!
aNoOverwrite
|
|
!
(
err
instanceof
OS
.
File
.
Error
)
|
|
!
err
.
becauseExists
)
{
throw
err
;
}
}
;
}
getFileForURL
:
function
Storage_getFileForURL_DEPRECATED
(
aURL
)
{
Deprecated
.
warning
(
"
PageThumbs
.
getFileForURL
is
deprecated
.
Please
use
PageThumbs
.
getFilePathForURL
and
OS
.
File
"
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
JavaScript_OS
.
File
"
)
;
return
new
FileUtils
.
File
(
PageThumbsStorageService
.
getFilePathForURL
(
aURL
)
)
;
}
}
;
var
PageThumbsStorageMigrator
=
{
get
currentVersion
(
)
{
try
{
return
Services
.
prefs
.
getIntPref
(
PREF_STORAGE_VERSION
)
;
}
catch
(
e
)
{
return
0
;
}
}
set
currentVersion
(
aVersion
)
{
Services
.
prefs
.
setIntPref
(
PREF_STORAGE_VERSION
aVersion
)
;
}
migrate
:
function
Migrator_migrate
(
)
{
let
version
=
this
.
currentVersion
;
if
(
version
<
3
)
{
this
.
migrateToVersion3
(
)
;
}
this
.
currentVersion
=
LATEST_STORAGE_VERSION
;
}
migrateToVersion3
:
function
Migrator_migrateToVersion3
(
local
=
OS
.
Constants
.
Path
.
localProfileDir
roaming
=
OS
.
Constants
.
Path
.
profileDir
)
{
PageThumbsWorker
.
post
(
"
moveOrDeleteAllThumbnails
"
[
OS
.
Path
.
join
(
roaming
THUMBNAIL_DIRECTORY
)
OS
.
Path
.
join
(
local
THUMBNAIL_DIRECTORY
)
]
)
;
}
}
;
var
PageThumbsExpiration
=
{
_filters
:
[
]
init
:
function
Expiration_init
(
)
{
gUpdateTimerManager
.
registerTimer
(
"
browser
-
cleanup
-
thumbnails
"
this
EXPIRATION_INTERVAL_SECS
)
;
}
addFilter
:
function
Expiration_addFilter
(
aFilter
)
{
this
.
_filters
.
push
(
aFilter
)
;
}
removeFilter
:
function
Expiration_removeFilter
(
aFilter
)
{
let
index
=
this
.
_filters
.
indexOf
(
aFilter
)
;
if
(
index
>
-
1
)
{
this
.
_filters
.
splice
(
index
1
)
;
}
}
notify
:
function
Expiration_notify
(
aTimer
)
{
let
urls
=
[
]
;
let
filtersToWaitFor
=
this
.
_filters
.
length
;
let
expire
=
(
)
=
>
{
this
.
expireThumbnails
(
urls
)
;
}
;
if
(
!
filtersToWaitFor
)
{
expire
(
)
;
return
;
}
function
filterCallback
(
aURLs
)
{
urls
=
urls
.
concat
(
aURLs
)
;
if
(
-
-
filtersToWaitFor
=
=
0
)
{
expire
(
)
;
}
}
for
(
let
filter
of
this
.
_filters
)
{
if
(
typeof
filter
=
=
"
function
"
)
{
filter
(
filterCallback
)
;
}
else
{
filter
.
filterForThumbnailExpiration
(
filterCallback
)
;
}
}
}
expireThumbnails
:
function
Expiration_expireThumbnails
(
aURLsToKeep
)
{
let
keep
=
aURLsToKeep
.
map
(
url
=
>
PageThumbsStorageService
.
getLeafNameForURL
(
url
)
)
;
let
msg
=
[
PageThumbsStorageService
.
path
keep
EXPIRATION_MIN_CHUNK_SIZE
]
;
return
PageThumbsWorker
.
post
(
"
expireFilesInDirectory
"
msg
)
;
}
}
;
var
PageThumbsWorker
=
new
BasePromiseWorker
(
"
resource
:
/
/
gre
/
modules
/
PageThumbsWorker
.
js
"
)
;
PageThumbsWorker
.
ExceptionHandlers
[
"
OS
.
File
.
Error
"
]
=
OS
.
File
.
Error
.
fromMsg
;
var
PageThumbsHistoryObserver
=
{
onDeleteURI
(
aURI
aGUID
)
{
PageThumbsStorage
.
remove
(
aURI
.
spec
)
;
}
onClearHistory
(
)
{
PageThumbsStorage
.
wipe
(
)
;
}
onTitleChanged
(
)
{
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onPageChanged
(
)
{
}
onDeleteVisits
(
)
{
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsINavHistoryObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
