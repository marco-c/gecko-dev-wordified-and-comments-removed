"
use
strict
"
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
workers
/
require
.
js
"
)
;
var
PromiseWorker
=
require
(
"
resource
:
/
/
gre
/
modules
/
workers
/
PromiseWorker
.
js
"
)
;
var
worker
=
new
PromiseWorker
.
AbstractWorker
(
)
;
worker
.
dispatch
=
function
(
method
args
=
[
]
)
{
return
Agent
[
method
]
(
.
.
.
args
)
;
}
;
worker
.
postMessage
=
function
(
message
.
.
.
transfers
)
{
self
.
postMessage
(
message
.
.
.
transfers
)
;
}
;
worker
.
close
=
function
(
)
{
self
.
close
(
)
;
}
;
self
.
addEventListener
(
"
message
"
msg
=
>
worker
.
handleMessage
(
msg
)
)
;
self
.
addEventListener
(
"
unhandledrejection
"
function
(
error
)
{
throw
error
.
reason
;
}
)
;
var
Agent
=
{
async
isFileRecent
(
path
maxAge
)
{
try
{
let
stat
=
await
IOUtils
.
stat
(
path
)
;
let
maxDate
=
new
Date
(
)
;
maxDate
.
setSeconds
(
maxDate
.
getSeconds
(
)
-
maxAge
)
;
return
stat
.
lastModified
>
maxDate
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
DOMException
)
)
{
throw
ex
;
}
return
false
;
}
}
async
remove
(
path
)
{
try
{
await
IOUtils
.
remove
(
path
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
async
expireFilesInDirectory
(
path
filesToKeep
minChunkSize
)
{
let
entries
=
await
this
.
getFileEntriesInDirectory
(
path
filesToKeep
)
;
let
limit
=
Math
.
max
(
minChunkSize
Math
.
round
(
entries
.
length
/
2
)
)
;
for
(
let
entry
of
entries
)
{
await
this
.
remove
(
entry
)
;
if
(
-
-
limit
<
=
0
)
{
break
;
}
}
return
true
;
}
async
getFileEntriesInDirectory
(
path
skipFiles
)
{
let
children
=
await
IOUtils
.
getChildren
(
path
)
;
let
skip
=
new
Set
(
skipFiles
)
;
let
entries
=
[
]
;
for
(
let
entry
of
children
)
{
let
stat
=
await
IOUtils
.
stat
(
entry
)
;
if
(
stat
.
type
=
=
=
"
regular
"
&
&
!
skip
.
has
(
PathUtils
.
filename
(
entry
)
)
)
{
entries
.
push
(
entry
)
;
}
}
return
entries
;
}
async
moveOrDeleteAllThumbnails
(
pathFrom
pathTo
)
{
await
IOUtils
.
makeDirectory
(
pathTo
)
;
if
(
pathFrom
=
=
pathTo
)
{
return
true
;
}
let
children
=
await
IOUtils
.
getChildren
(
pathFrom
)
;
for
(
let
entry
of
children
)
{
let
stat
=
await
IOUtils
.
stat
(
entry
)
;
if
(
stat
.
type
!
=
=
"
regular
"
)
{
continue
;
}
let
fileName
=
PathUtils
.
filename
(
entry
)
;
let
from
=
PathUtils
.
join
(
pathFrom
fileName
)
;
let
to
=
PathUtils
.
join
(
pathTo
fileName
)
;
try
{
await
IOUtils
.
move
(
from
to
{
noOverwrite
:
true
}
)
;
}
catch
(
e
)
{
await
IOUtils
.
remove
(
from
)
;
}
}
try
{
await
IOUtils
.
remove
(
pathFrom
{
recursive
:
true
}
)
;
}
catch
(
e
)
{
}
return
true
;
}
writeAtomic
(
path
buffer
options
)
{
return
IOUtils
.
write
(
path
buffer
options
)
;
}
makeDir
(
path
options
)
{
return
IOUtils
.
makeDirectory
(
path
options
)
;
}
copy
(
source
dest
options
)
{
return
IOUtils
.
copy
(
source
dest
options
)
;
}
async
wipe
(
path
)
{
let
children
=
await
IOUtils
.
getChildren
(
path
)
;
try
{
await
Promise
.
all
(
children
.
map
(
entry
=
>
IOUtils
.
remove
(
entry
)
)
)
;
}
catch
(
ex
)
{
}
}
exists
(
path
)
{
return
IOUtils
.
exists
(
path
)
;
}
}
;
