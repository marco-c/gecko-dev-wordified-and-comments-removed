const
StyleDictionary
=
require
(
"
style
-
dictionary
"
)
;
const
COLLECTIONS
=
{
colors
:
"
Colors
"
primitives
:
"
Primitives
"
theme
:
"
Theme
"
hcmTheme
:
"
HCM
Theme
"
}
;
const
HCM_VALUES
=
[
"
ActiveText
"
"
ButtonBorder
"
"
ButtonFace
"
"
ButtonText
"
"
Canvas
"
"
CanvasText
"
"
Field
"
"
FieldText
"
"
GrayText
"
"
Highlight
"
"
HighlightText
"
"
LinkText
"
"
Mark
"
"
MarkText
"
"
SelectedItem
"
"
SelectedItemText
"
"
AccentColor
"
"
AccentColorText
"
"
VisitedText
"
]
;
StyleDictionary
.
registerTransform
(
{
type
:
"
name
"
name
:
"
name
/
figma
"
transformer
:
token
=
>
token
.
path
.
join
(
"
/
"
)
.
replace
(
"
/
base
"
"
"
)
}
)
;
function
isNestedDefaultObject
(
value
)
{
let
current
=
value
;
while
(
typeof
current
=
=
=
"
object
"
)
{
const
keys
=
Object
.
keys
(
current
)
;
if
(
keys
.
length
!
=
=
1
)
{
return
false
;
}
const
key
=
keys
[
0
]
;
if
(
key
=
=
=
"
default
"
)
{
if
(
typeof
current
[
key
]
=
=
=
"
object
"
)
{
return
false
;
}
if
(
current
[
key
]
=
=
=
"
currentColor
"
)
{
return
false
;
}
return
true
;
}
current
=
current
[
key
]
;
}
return
false
;
}
StyleDictionary
.
registerTransform
(
{
type
:
"
attribute
"
name
:
"
attribute
/
figma
"
transformer
:
token
=
>
{
let
collection
=
COLLECTIONS
.
theme
;
if
(
(
typeof
token
.
value
!
=
=
"
object
"
|
|
isNestedDefaultObject
(
token
.
value
)
)
&
&
token
.
value
!
=
=
"
currentColor
"
)
{
if
(
token
.
path
[
0
]
=
=
=
"
color
"
)
{
collection
=
COLLECTIONS
.
colors
;
}
else
{
collection
=
COLLECTIONS
.
primitives
;
}
}
let
willBeDestructured
=
false
;
const
originalVal
=
token
.
original
.
value
;
if
(
attemptShadowDestructuring
(
token
originalVal
)
|
|
attemptPaddingMarginDestructuring
(
token
originalVal
)
)
{
willBeDestructured
=
true
;
}
return
{
collection
willBeDestructured
}
;
}
}
)
;
const
formatTokens
=
collection
=
>
args
=
>
{
let
dictionary
=
Object
.
assign
(
{
}
args
.
dictionary
)
;
let
tokens
=
[
]
;
const
filter
=
mergeFilters
(
defaultFilter
token
=
>
token
.
attributes
?
.
collection
=
=
=
collection
)
;
dictionary
.
allTokens
.
forEach
(
token
=
>
{
let
originalVal
=
token
.
original
.
value
;
if
(
originalVal
=
=
=
undefined
)
{
throw
new
Error
(
[
formatTokens
]
Token
{
token
.
name
}
has
an
undefined
original
value
.
Please
check
your
tokens
.
)
;
}
if
(
dictionary
.
usesReference
(
originalVal
)
)
{
const
references
=
dictionary
.
getReferences
(
originalVal
)
;
if
(
references
.
some
(
ref
=
>
ref
.
attributes
.
willBeDestructured
)
)
{
console
.
warn
(
[
formatTokens
]
Skipping
token
{
token
.
name
}
because
it
references
a
token
that
will
be
destructured
)
;
return
;
}
}
const
potentialShadowTokens
=
attemptShadowDestructuring
(
token
originalVal
)
;
if
(
potentialShadowTokens
)
{
potentialShadowTokens
.
forEach
(
(
{
token
:
sToken
originalVal
:
sOriginalVal
}
)
=
>
{
if
(
!
filter
(
sToken
)
)
{
return
;
}
let
formattedToken
=
transformTokenValue
(
sToken
sOriginalVal
dictionary
)
;
tokens
.
push
(
formattedToken
)
;
}
)
;
return
;
}
const
potentialPaddingMarginTokens
=
attemptPaddingMarginDestructuring
(
token
originalVal
)
;
if
(
potentialPaddingMarginTokens
)
{
potentialPaddingMarginTokens
.
forEach
(
(
{
token
:
sToken
originalVal
:
sOriginalVal
}
)
=
>
{
if
(
!
filter
(
sToken
)
)
{
return
;
}
let
formattedToken
=
transformTokenValue
(
sToken
sOriginalVal
dictionary
)
;
tokens
.
push
(
formattedToken
)
;
}
)
;
return
;
}
if
(
!
filter
(
token
)
)
{
return
;
}
let
formattedToken
=
transformTokenValue
(
token
originalVal
dictionary
)
;
tokens
.
push
(
formattedToken
)
;
}
)
;
if
(
!
tokens
.
length
)
{
return
"
"
;
}
dictionary
.
allTokens
=
dictionary
.
allProperties
=
tokens
;
return
(
"
{
\
n
"
+
dictionary
.
allTokens
.
map
(
function
(
token
)
{
return
"
{
token
.
name
}
"
:
{
JSON
.
stringify
(
args
.
options
.
usesDtcg
?
token
.
value
:
token
.
value
null
2
)
.
replace
(
/
\
n
/
g
"
\
n
"
)
}
;
}
)
.
join
(
"
\
n
"
)
+
"
\
n
}
"
+
"
\
n
"
)
;
}
;
function
transformTokenValue
(
token
originalVal
dictionary
)
{
let
newValue
=
originalVal
;
if
(
typeof
token
.
value
=
=
=
"
object
"
)
{
const
brandValue
=
getNestedBrandColor
(
originalVal
)
;
const
forcedColorsValue
=
getNestedSystemColor
(
originalVal
)
;
if
(
token
.
attributes
?
.
collection
=
=
=
COLLECTIONS
.
primitives
)
{
newValue
=
brandValue
?
.
light
;
}
else
{
newValue
=
{
light
:
brandValue
?
.
light
?
replaceReferences
(
dictionary
brandValue
?
.
light
)
:
"
transparent
"
dark
:
brandValue
?
.
dark
?
replaceReferences
(
dictionary
brandValue
?
.
dark
)
:
"
transparent
"
forcedColors
:
replaceReferences
(
dictionary
forcedColorsValue
)
}
;
if
(
newValue
.
forcedColors
=
=
=
undefined
&
&
newValue
.
light
=
=
=
newValue
.
dark
)
{
newValue
.
forcedColors
=
newValue
.
light
;
}
else
if
(
newValue
.
forcedColors
=
=
=
undefined
)
{
newValue
.
forcedColors
=
"
transparent
"
;
}
}
}
else
if
(
dictionary
.
usesReference
(
newValue
)
)
{
newValue
=
replaceReferences
(
dictionary
newValue
)
;
}
if
(
typeof
newValue
=
=
=
"
object
"
)
{
Object
.
keys
(
newValue
)
.
forEach
(
key
=
>
{
newValue
[
key
]
=
potentiallyTransformValue
(
token
newValue
[
key
]
)
;
}
)
;
}
else
{
newValue
=
potentiallyTransformValue
(
token
newValue
)
;
}
return
{
.
.
.
token
value
:
newValue
}
;
}
function
potentiallyTransformValue
(
token
value
)
{
const
numberOrPxRegex
=
/
^
-
?
\
d
*
\
.
?
\
d
+
(
px
)
?
/
;
if
(
typeof
value
=
=
=
"
string
"
&
&
numberOrPxRegex
.
test
(
value
)
)
{
const
numberValue
=
parseFloat
(
value
)
;
if
(
isNaN
(
numberValue
)
)
{
throw
new
Error
(
Failed
to
parse
value
:
{
value
}
)
;
}
return
numberValue
;
}
if
(
typeof
value
=
=
=
"
number
"
&
&
value
>
=
0
&
&
value
<
=
1
&
&
token
.
path
.
includes
(
"
opacity
"
)
)
{
return
Math
.
round
(
value
*
100
)
;
}
return
value
;
}
function
replaceReferences
(
dictionary
value
)
{
if
(
value
=
=
=
undefined
)
{
return
value
;
}
if
(
typeof
value
=
=
=
"
string
"
)
{
value
=
value
.
replace
(
/
calc
\
(
(
[
^
(
)
]
+
)
\
)
/
g
(
_
calcContent
)
=
>
{
dictionary
.
getReferences
(
calcContent
)
.
forEach
(
ref
=
>
{
calcContent
=
calcContent
.
replace
(
{
{
ref
.
path
.
join
(
"
.
"
)
}
}
ref
.
value
)
;
}
)
;
const
calcValue
=
resolveCssCalc
(
calcContent
)
;
return
calcValue
;
}
)
;
}
if
(
dictionary
.
usesReference
(
value
)
)
{
dictionary
.
getReferences
(
value
)
.
forEach
(
ref
=
>
{
value
=
value
.
replace
(
{
{
ref
.
path
.
join
(
"
.
"
)
}
}
{
{
ref
.
attributes
.
collection
}
{
ref
.
name
}
}
)
;
}
)
;
}
if
(
HCM_VALUES
.
includes
(
value
)
)
{
value
=
{
{
COLLECTIONS
.
hcmTheme
}
{
value
}
}
;
}
return
value
;
}
function
getNestedSystemColor
(
token
)
{
let
current
=
token
;
while
(
typeof
current
=
=
=
"
object
"
)
{
current
=
current
.
forcedColors
?
?
current
.
prefersContrast
?
?
current
.
default
;
}
return
current
;
}
function
getNestedBrandColor
(
token
)
{
const
stack
=
[
token
]
;
while
(
stack
.
length
)
{
const
node
=
stack
.
pop
(
)
;
if
(
typeof
node
!
=
=
"
object
"
)
{
return
{
light
:
node
dark
:
node
}
;
}
if
(
typeof
node
=
=
=
"
object
"
)
{
if
(
node
.
light
&
&
node
.
dark
)
{
return
node
;
}
if
(
node
.
brand
)
{
stack
.
push
(
node
.
brand
)
;
}
if
(
node
.
default
)
{
stack
.
push
(
node
.
default
)
;
}
}
}
return
undefined
;
}
function
attemptShadowDestructuring
(
token
originalVal
)
{
if
(
!
token
.
path
.
includes
(
"
shadow
"
)
|
|
typeof
originalVal
!
=
=
"
string
"
)
{
return
undefined
;
}
if
(
!
originalVal
.
includes
(
"
"
)
)
{
return
undefined
;
}
let
shadows
;
try
{
shadows
=
parseBoxShadow
(
originalVal
)
;
}
catch
(
e
)
{
console
.
warn
(
"
[
attemptShadowDestructuring
]
Error
parsing
shadow
:
"
e
)
;
return
undefined
;
}
if
(
shadows
.
length
=
=
=
0
)
{
return
undefined
;
}
const
subtokens
=
shadows
.
flatMap
(
(
shadow
index
)
=
>
{
const
path
=
shadows
.
length
>
1
?
[
.
.
.
token
.
path
shadow
-
{
index
+
1
}
]
:
token
.
path
;
return
Object
.
entries
(
shadow
)
.
map
(
(
[
key
value
]
)
=
>
{
let
collection
=
token
.
attributes
?
.
collection
;
if
(
key
!
=
=
"
color
"
)
{
collection
=
COLLECTIONS
.
primitives
;
}
const
copy
=
{
.
.
.
token
path
:
[
.
.
.
path
key
]
.
filter
(
filterBase
)
name
:
[
.
.
.
path
key
]
.
filter
(
filterBase
)
.
join
(
"
/
"
)
value
original
:
{
.
.
.
token
.
original
value
}
attributes
:
{
.
.
.
token
.
attributes
collection
}
}
;
return
{
token
:
copy
originalVal
:
value
}
;
}
)
;
}
)
;
return
subtokens
;
}
function
attemptPaddingMarginDestructuring
(
token
originalVal
)
{
if
(
typeof
originalVal
!
=
=
"
string
"
|
|
(
!
token
.
path
.
includes
(
"
padding
"
)
&
&
!
token
.
path
.
includes
(
"
margin
"
)
)
)
{
return
undefined
;
}
const
parts
=
originalVal
.
split
(
/
(
?
<
!
\
(
[
^
\
s
]
*
)
\
s
+
/
)
;
if
(
parts
.
length
=
=
=
1
)
{
return
undefined
;
}
if
(
parts
.
length
>
4
)
{
throw
new
Error
(
[
attemptPaddingMarginDestructuring
]
Too
many
parts
in
{
originalVal
}
)
;
}
const
result
=
{
}
;
if
(
parts
.
length
=
=
=
2
)
{
result
.
block
=
parts
[
0
]
;
result
.
inline
=
parts
[
1
]
;
}
else
if
(
parts
.
length
=
=
=
3
)
{
result
.
blockStart
=
parts
[
0
]
;
result
.
inline
=
parts
[
1
]
;
result
.
blockEnd
=
parts
[
2
]
;
}
else
if
(
parts
.
length
=
=
=
4
)
{
result
.
blockStart
=
parts
[
0
]
;
result
.
inlineStart
=
parts
[
1
]
;
result
.
blockEnd
=
parts
[
2
]
;
result
.
inlineEnd
=
parts
[
3
]
;
}
return
Object
.
entries
(
result
)
.
map
(
(
[
key
value
]
)
=
>
{
const
copy
=
{
.
.
.
token
path
:
[
.
.
.
token
.
path
key
]
.
filter
(
filterBase
)
name
:
[
.
.
.
token
.
path
key
]
.
filter
(
filterBase
)
.
join
(
"
/
"
)
value
original
:
{
.
.
.
token
.
original
value
}
}
;
return
{
token
:
copy
originalVal
:
value
}
;
}
)
;
}
function
resolveCssCalc
(
expression
)
{
const
unitRegex
=
/
[
a
-
zA
-
Z
%
]
+
/
g
;
const
precedence
=
{
"
+
"
:
1
"
-
"
:
1
"
*
"
:
2
"
/
"
:
2
}
;
const
tokens
=
expression
.
match
(
/
\
d
*
\
.
?
\
d
+
[
a
-
zA
-
Z
%
]
*
|
[
-
+
*
/
(
)
]
/
g
)
;
if
(
!
tokens
)
{
throw
new
Error
(
"
[
resolveCssCalc
]
Invalid
expression
"
)
;
}
const
units
=
new
Set
(
)
;
const
parsedTokens
=
tokens
.
map
(
token
=
>
{
const
unit
=
token
.
match
(
unitRegex
)
?
.
[
0
]
|
|
"
"
;
if
(
unit
)
{
units
.
add
(
unit
)
;
}
return
parseFloat
(
token
)
|
|
token
;
}
)
;
if
(
units
.
size
>
1
)
{
throw
new
Error
(
"
[
resolveCssCalc
]
Mixing
units
is
not
allowed
"
)
;
}
const
resultUnit
=
units
.
size
?
[
.
.
.
units
]
[
0
]
:
"
"
;
const
output
=
[
]
;
const
operators
=
[
]
;
const
compute
=
(
)
=
>
{
const
b
=
output
.
pop
(
)
;
const
a
=
output
.
pop
(
)
;
switch
(
operators
.
pop
(
)
)
{
case
"
+
"
:
output
.
push
(
a
+
b
)
;
break
;
case
"
-
"
:
output
.
push
(
a
-
b
)
;
break
;
case
"
*
"
:
output
.
push
(
a
*
b
)
;
break
;
case
"
/
"
:
output
.
push
(
a
/
b
)
;
break
;
}
}
;
for
(
let
i
=
0
;
i
<
parsedTokens
.
length
;
i
+
+
)
{
let
token
=
parsedTokens
[
i
]
;
if
(
typeof
token
=
=
=
"
number
"
)
{
output
.
push
(
token
)
;
}
else
if
(
token
=
=
=
"
(
"
)
{
operators
.
push
(
token
)
;
}
else
if
(
token
=
=
=
"
)
"
)
{
while
(
operators
.
at
(
-
1
)
!
=
=
"
(
"
)
{
compute
(
)
;
}
operators
.
pop
(
)
;
}
else
{
if
(
(
token
=
=
=
"
-
"
|
|
token
=
=
=
"
+
"
)
&
&
(
i
=
=
=
0
|
|
parsedTokens
[
i
-
1
]
=
=
=
"
(
"
)
)
{
output
.
push
(
0
)
;
}
while
(
operators
.
length
&
&
precedence
[
token
]
<
=
precedence
[
operators
.
at
(
-
1
)
]
)
{
compute
(
)
;
}
operators
.
push
(
token
)
;
}
}
while
(
operators
.
length
)
{
compute
(
)
;
}
if
(
isNaN
(
output
[
0
]
)
)
{
throw
new
Error
(
"
[
resolveCssCalc
]
Resolving
math
expression
resulted
in
NaN
"
)
;
}
return
output
[
0
]
+
resultUnit
;
}
const
DEFAULT_SHADOW
=
{
x
:
"
0
"
y
:
"
0
"
blur
:
"
0
"
spread
:
"
0
"
color
:
"
transparent
"
}
;
function
parseBoxShadow
(
input
)
{
if
(
typeof
input
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Input
must
be
a
string
"
)
;
}
const
shadowSplitRegex
=
/
(
?
!
[
^
(
]
*
\
)
)
/
;
const
shadowPartsRegex
=
/
(
?
:
[
^
\
s
(
)
]
+
|
\
(
[
^
)
]
*
\
)
)
+
/
g
;
const
lengthValueRegex
=
/
^
-
?
\
d
*
\
.
?
\
d
+
(
px
|
em
|
rem
|
%
)
?
/
;
return
input
.
split
(
shadowSplitRegex
)
.
map
(
shadow
=
>
{
shadow
=
shadow
.
trim
(
)
;
const
parts
=
shadow
.
match
(
shadowPartsRegex
)
;
let
x
y
blur
spread
color
;
let
lengthValues
=
[
]
;
for
(
let
i
=
0
;
i
<
parts
.
length
;
i
+
+
)
{
const
part
=
parts
[
i
]
;
if
(
lengthValueRegex
.
test
(
part
)
)
{
lengthValues
.
push
(
part
)
;
}
else
{
color
=
parts
.
slice
(
i
)
.
join
(
"
"
)
;
break
;
}
}
if
(
lengthValues
.
length
<
2
|
|
lengthValues
.
length
>
4
)
{
throw
new
Error
(
"
Invalid
box
-
shadow
syntax
"
)
;
}
[
x
y
blur
spread
]
=
lengthValues
;
if
(
color
)
{
const
colorParts
=
color
.
split
(
"
"
)
;
if
(
colorParts
.
includes
(
"
inset
"
)
)
{
colorParts
.
splice
(
colorParts
.
indexOf
(
"
inset
"
)
1
)
;
}
if
(
colorParts
.
includes
(
"
outset
"
)
)
{
colorParts
.
splice
(
colorParts
.
indexOf
(
"
outset
"
)
1
)
;
}
color
=
colorParts
.
length
?
colorParts
.
join
(
"
"
)
:
undefined
;
}
return
{
x
:
x
|
|
DEFAULT_SHADOW
.
x
y
:
y
|
|
DEFAULT_SHADOW
.
y
blur
:
blur
|
|
DEFAULT_SHADOW
.
blur
spread
:
spread
|
|
DEFAULT_SHADOW
.
spread
color
:
color
|
|
DEFAULT_SHADOW
.
color
}
;
}
)
;
}
function
mergeFilters
(
.
.
.
filters
)
{
return
token
=
>
{
for
(
const
filter
of
filters
)
{
if
(
!
filter
(
token
)
)
{
return
false
;
}
}
return
true
;
}
;
}
function
defaultFilter
(
token
)
{
if
(
token
.
path
.
includes
(
"
font
"
)
)
{
return
false
;
}
return
true
;
}
function
filterBase
(
pathItem
)
{
return
pathItem
!
=
=
"
base
"
;
}
const
platform
=
{
options
:
{
outputReferences
:
true
showFileHeader
:
false
}
transforms
:
[
"
name
/
figma
"
"
attribute
/
figma
"
]
files
:
[
{
destination
:
"
tokens
-
figma
-
colors
.
json
"
format
:
"
json
/
figma
/
colors
"
}
{
destination
:
"
tokens
-
figma
-
primitives
.
json
"
format
:
"
json
/
figma
/
primitives
"
}
{
destination
:
"
tokens
-
figma
-
theme
.
json
"
format
:
"
json
/
figma
/
theme
"
}
]
}
;
module
.
exports
=
{
platform
formats
:
{
"
json
/
figma
/
colors
"
:
formatTokens
(
COLLECTIONS
.
colors
)
"
json
/
figma
/
primitives
"
:
formatTokens
(
COLLECTIONS
.
primitives
)
"
json
/
figma
/
theme
"
:
formatTokens
(
COLLECTIONS
.
theme
)
}
}
;
