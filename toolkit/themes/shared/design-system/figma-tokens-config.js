const
StyleDictionary
=
require
(
"
style
-
dictionary
"
)
;
const
Color
=
require
(
"
tinycolor2
"
)
;
function
isValidColor
(
color
)
{
if
(
typeof
color
=
=
=
"
string
"
&
&
color
.
startsWith
(
"
oklch
"
)
)
{
return
true
;
}
return
Color
(
color
)
.
isValid
(
)
;
}
function
transformIfValid
(
color
)
{
const
c
=
Color
(
color
)
;
return
c
.
isValid
(
)
?
c
.
toHex8String
(
)
:
color
;
}
function
hex8Transform
(
token
)
{
if
(
typeof
token
.
value
=
=
=
"
string
"
)
{
if
(
token
.
value
.
startsWith
(
"
oklch
"
)
)
{
return
token
.
value
;
}
return
Color
(
token
.
value
)
.
toHex8String
(
)
;
}
return
{
.
.
.
token
.
value
light
:
transformIfValid
(
token
.
value
.
light
)
dark
:
transformIfValid
(
token
.
value
.
dark
)
forcedColors
:
transformIfValid
(
token
.
value
.
forcedColors
)
}
;
}
StyleDictionary
.
registerTransform
(
{
type
:
"
value
"
transitive
:
true
name
:
"
color
/
hex8figma
"
matcher
:
token
=
>
isValidColor
(
token
.
value
)
|
|
(
typeof
token
.
value
=
=
=
"
object
"
&
&
(
token
.
value
.
light
|
|
token
.
value
.
dark
|
|
token
.
value
.
forcedColors
)
)
transformer
:
hex8Transform
}
)
;
StyleDictionary
.
registerTransform
(
{
type
:
"
name
"
name
:
"
name
/
figma
"
transformer
:
token
=
>
token
.
path
.
join
(
"
/
"
)
.
replace
(
"
/
base
"
"
"
)
}
)
;
function
getNestedSystemColor
(
token
)
{
let
current
=
token
;
while
(
typeof
current
=
=
=
"
object
"
)
{
current
=
current
.
forcedColors
?
?
current
.
prefersContrast
?
?
current
.
default
;
}
return
current
;
}
function
getNestedBrandColor
(
token
)
{
const
stack
=
[
token
]
;
while
(
stack
.
length
)
{
const
node
=
stack
.
pop
(
)
;
if
(
typeof
node
=
=
=
"
string
"
)
{
return
{
light
:
node
dark
:
node
}
;
}
if
(
typeof
node
=
=
=
"
object
"
)
{
if
(
node
.
light
&
&
node
.
dark
)
{
return
node
;
}
if
(
node
.
brand
)
{
stack
.
push
(
node
.
brand
)
;
}
if
(
node
.
default
)
{
stack
.
push
(
node
.
default
)
;
}
}
}
return
undefined
;
}
function
figmaFormatTransform
(
token
)
{
if
(
typeof
token
.
value
!
=
=
"
object
"
)
{
return
token
.
value
;
}
const
brandValue
=
getNestedBrandColor
(
token
.
value
)
;
const
forcedColorsValue
=
getNestedSystemColor
(
token
.
value
)
;
const
obj
=
{
light
:
brandValue
?
.
light
|
|
"
transparent
"
dark
:
brandValue
?
.
dark
|
|
"
transparent
"
forcedColors
:
forcedColorsValue
}
;
return
obj
;
}
StyleDictionary
.
registerTransform
(
{
type
:
"
value
"
name
:
"
value
/
figma
"
transformer
:
figmaFormatTransform
transitive
:
true
}
)
;
const
HCM_VALUES
=
[
"
ActiveText
"
"
ButtonBorder
"
"
ButtonFace
"
"
ButtonText
"
"
Canvas
"
"
CanvasText
"
"
Field
"
"
FieldText
"
"
GrayText
"
"
Highlight
"
"
HighlightText
"
"
LinkText
"
"
Mark
"
"
MarkText
"
"
SelectedItem
"
"
SelectedItemText
"
"
AccentColor
"
"
AccentColorText
"
"
VisitedText
"
]
;
function
filterFigmaTokens
(
token
)
{
if
(
typeof
token
.
value
=
=
=
"
number
"
|
|
(
typeof
token
.
value
=
=
=
"
string
"
&
&
!
isValidColor
(
token
.
value
)
)
)
{
return
false
;
}
if
(
typeof
token
.
value
=
=
=
"
object
"
)
{
for
(
const
value
of
Object
.
values
(
token
.
value
)
)
{
if
(
typeof
value
!
=
=
"
string
"
|
|
(
value
!
=
=
"
inherit
"
&
&
!
isValidColor
(
value
)
&
&
!
value
.
startsWith
(
"
color
-
mix
"
)
&
&
!
HCM_VALUES
.
includes
(
value
)
)
)
{
return
false
;
}
}
}
if
(
typeof
token
?
.
original
?
.
value
=
=
=
"
string
"
&
&
!
/
^
(
\
{
[
^
{
}
]
*
\
}
|
[
^
{
}
]
*
)
/
.
test
(
token
.
original
.
value
)
)
{
return
false
;
}
return
true
;
}
module
.
exports
=
{
options
:
{
outputReferences
:
true
showFileHeader
:
false
}
transforms
:
[
"
value
/
figma
"
"
name
/
figma
"
"
color
/
hex8figma
"
]
files
:
[
{
destination
:
"
tokens
-
figma
.
json
"
format
:
"
json
/
flat
"
filter
:
filterFigmaTokens
}
]
}
;
