#
include
<
windows
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsDependentString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
using
namespace
mozilla
;
constexpr
const
WCHAR
pattern
[
]
=
L
"
\
\
api
-
*
.
dll
"
;
static
LPWSTR
GetModuleFileDir
(
HMODULE
module
LPWSTR
path
DWORD
size
)
{
DWORD
chars
=
GetModuleFileNameW
(
module
path
size
)
;
if
(
chars
<
=
0
|
|
chars
>
=
MAX_PATH
)
{
return
nullptr
;
}
LPWSTR
basename
=
wcsrchr
(
path
L
'
\
\
'
)
;
if
(
!
basename
)
{
return
nullptr
;
}
*
basename
+
+
=
L
'
\
0
'
;
return
basename
;
}
TEST
(
TestUCRTDepends
AppDir
)
{
WCHAR
appdir
[
MAX_PATH
]
;
ASSERT_TRUE
(
GetModuleFileDir
(
nullptr
appdir
MAX_PATH
)
)
;
WCHAR
path
[
MAX_PATH
+
ArrayLength
(
pattern
)
]
;
swprintf
(
path
L
"
%
s
%
s
"
appdir
pattern
)
;
WIN32_FIND_DATAW
wfd
;
HANDLE
hFind
=
FindFirstFileW
(
path
&
wfd
)
;
#
if
defined
(
_M_ARM64
)
if
(
hFind
=
=
INVALID_HANDLE_VALUE
)
{
EXPECT_EQ
(
GetLastError
(
)
ERROR_FILE_NOT_FOUND
)
;
return
;
}
#
else
ASSERT_NE
(
hFind
INVALID_HANDLE_VALUE
)
;
#
endif
do
{
nsModuleHandle
module
(
LoadLibraryW
(
wfd
.
cFileName
)
)
;
EXPECT_TRUE
(
module
)
;
if
(
!
module
)
{
continue
;
}
LPWSTR
basename
=
GetModuleFileDir
(
module
path
MAX_PATH
)
;
ASSERT_TRUE
(
basename
)
;
bool
inApiSets
=
wcsicmp
(
wfd
.
cFileName
basename
)
;
if
(
IsWin10OrLater
(
)
)
{
EXPECT_TRUE
(
inApiSets
)
;
continue
;
}
if
(
IsWin8OrLater
(
)
)
{
if
(
inApiSets
)
{
continue
;
}
EXPECT_TRUE
(
StringBeginsWith
(
nsDependentString
(
wfd
.
cFileName
)
NS_LITERAL_STRING
(
"
api
-
ms
-
win
-
crt
-
"
)
nsCaseInsensitiveStringComparator
)
)
;
}
else
{
EXPECT_FALSE
(
inApiSets
)
;
}
EXPECT_TRUE
(
!
wcsicmp
(
path
appdir
)
)
;
}
while
(
FindNextFileW
(
hFind
&
wfd
)
)
;
EXPECT_EQ
(
GetLastError
(
)
ERROR_NO_MORE_FILES
)
;
BOOL
ret
=
FindClose
(
hFind
)
;
EXPECT_TRUE
(
ret
)
;
}
TEST
(
TestUCRTDepends
SystemDir
)
{
WCHAR
appdir
[
MAX_PATH
]
;
ASSERT_TRUE
(
GetModuleFileDir
(
nullptr
appdir
MAX_PATH
)
)
;
WCHAR
path
[
MAX_PATH
+
ArrayLength
(
pattern
)
]
;
UINT
chars
=
GetSystemDirectoryW
(
path
MAX_PATH
)
;
ASSERT_TRUE
(
chars
>
0
&
&
chars
<
MAX_PATH
)
;
wcscat
(
path
pattern
)
;
WIN32_FIND_DATAW
wfd
;
HANDLE
hFind
=
FindFirstFileW
(
path
&
wfd
)
;
if
(
hFind
=
=
INVALID_HANDLE_VALUE
)
{
EXPECT_EQ
(
GetLastError
(
)
ERROR_FILE_NOT_FOUND
)
;
EXPECT_TRUE
(
IsWin8OrLater
(
)
)
;
return
;
}
EXPECT_FALSE
(
IsWin10OrLater
(
)
)
;
do
{
HMODULE
module
=
GetModuleHandleW
(
wfd
.
cFileName
)
;
if
(
!
module
)
{
continue
;
}
LPWSTR
basename
=
GetModuleFileDir
(
module
path
MAX_PATH
)
;
ASSERT_TRUE
(
basename
)
;
if
(
wcsicmp
(
wfd
.
cFileName
basename
)
)
{
swprintf
(
path
L
"
%
s
\
\
%
s
"
appdir
wfd
.
cFileName
)
;
EXPECT_EQ
(
GetFileAttributesW
(
path
)
INVALID_FILE_ATTRIBUTES
)
;
}
else
{
EXPECT_TRUE
(
!
wcsicmp
(
path
appdir
)
)
;
}
}
while
(
FindNextFileW
(
hFind
&
wfd
)
)
;
EXPECT_EQ
(
GetLastError
(
)
ERROR_NO_MORE_FILES
)
;
BOOL
ret
=
FindClose
(
hFind
)
;
EXPECT_TRUE
(
ret
)
;
}
