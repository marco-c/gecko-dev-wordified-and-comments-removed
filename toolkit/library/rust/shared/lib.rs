#
[
cfg
(
feature
=
"
servo
"
)
]
extern
crate
geckoservo
;
extern
crate
mp4parse_capi
;
extern
crate
nsstring
;
extern
crate
nserror
;
extern
crate
rust_url_capi
;
extern
crate
netwerk_helper
;
#
[
cfg
(
feature
=
"
quantum_render
"
)
]
extern
crate
webrender_bindings
;
#
[
cfg
(
feature
=
"
cubeb_pulse_rust
"
)
]
extern
crate
cubeb_pulse
;
extern
crate
encoding_c
;
extern
crate
encoding_glue
;
#
[
cfg
(
feature
=
"
cubeb
-
remoting
"
)
]
extern
crate
audioipc_client
;
#
[
cfg
(
feature
=
"
cubeb
-
remoting
"
)
]
extern
crate
audioipc_server
;
extern
crate
u2fhid
;
extern
crate
log
;
extern
crate
syn
;
extern
crate
cosec
;
use
std
:
:
boxed
:
:
Box
;
use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
use
std
:
:
panic
;
#
[
no_mangle
]
pub
extern
"
C
"
fn
intentional_panic
(
message
:
*
const
c_char
)
{
panic
!
(
"
{
}
"
unsafe
{
CStr
:
:
from_ptr
(
message
)
}
.
to_string_lossy
(
)
)
;
}
static
mut
PANIC_REASON
:
Option
<
*
const
str
>
=
None
;
#
[
no_mangle
]
pub
extern
"
C
"
fn
install_rust_panic_hook
(
)
{
let
default_hook
=
panic
:
:
take_hook
(
)
;
panic
:
:
set_hook
(
Box
:
:
new
(
move
|
info
|
{
let
payload
=
info
.
payload
(
)
;
if
let
Some
(
s
)
=
payload
.
downcast_ref
:
:
<
&
str
>
(
)
{
unsafe
{
PANIC_REASON
=
Some
(
*
s
as
*
const
str
)
;
}
}
else
if
let
Some
(
s
)
=
payload
.
downcast_ref
:
:
<
String
>
(
)
{
unsafe
{
PANIC_REASON
=
Some
(
s
.
as_str
(
)
as
*
const
str
)
;
}
}
else
{
println
!
(
"
Unhandled
panic
payload
!
"
)
;
}
default_hook
(
info
)
;
}
)
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
get_rust_panic_reason
(
reason
:
*
mut
*
const
c_char
length
:
*
mut
usize
)
-
>
bool
{
unsafe
{
if
let
Some
(
s
)
=
PANIC_REASON
{
*
reason
=
s
as
*
const
c_char
;
*
length
=
(
*
s
)
.
len
(
)
;
true
}
else
{
false
}
}
}
