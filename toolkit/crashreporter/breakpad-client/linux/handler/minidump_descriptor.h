#
ifndef
CLIENT_LINUX_HANDLER_MINIDUMP_DESCRIPTOR_H_
#
define
CLIENT_LINUX_HANDLER_MINIDUMP_DESCRIPTOR_H_
#
include
<
assert
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
string
>
#
include
"
linux
/
handler
/
microdump_extra_info
.
h
"
#
include
"
common
/
using_std_string
.
h
"
namespace
google_breakpad
{
class
MinidumpDescriptor
{
public
:
struct
MicrodumpOnConsole
{
}
;
static
const
MicrodumpOnConsole
kMicrodumpOnConsole
;
MinidumpDescriptor
(
)
:
mode_
(
kUninitialized
)
fd_
(
-
1
)
size_limit_
(
-
1
)
address_within_principal_mapping_
(
0
)
skip_dump_if_principal_mapping_not_referenced_
(
false
)
{
}
explicit
MinidumpDescriptor
(
const
string
&
directory
)
:
mode_
(
kWriteMinidumpToFile
)
fd_
(
-
1
)
directory_
(
directory
)
c_path_
(
NULL
)
size_limit_
(
-
1
)
address_within_principal_mapping_
(
0
)
skip_dump_if_principal_mapping_not_referenced_
(
false
)
sanitize_stacks_
(
false
)
{
assert
(
!
directory
.
empty
(
)
)
;
}
explicit
MinidumpDescriptor
(
int
fd
)
:
mode_
(
kWriteMinidumpToFd
)
fd_
(
fd
)
c_path_
(
NULL
)
size_limit_
(
-
1
)
address_within_principal_mapping_
(
0
)
skip_dump_if_principal_mapping_not_referenced_
(
false
)
sanitize_stacks_
(
false
)
{
assert
(
fd
!
=
-
1
)
;
}
explicit
MinidumpDescriptor
(
const
MicrodumpOnConsole
&
)
:
mode_
(
kWriteMicrodumpToConsole
)
fd_
(
-
1
)
size_limit_
(
-
1
)
address_within_principal_mapping_
(
0
)
skip_dump_if_principal_mapping_not_referenced_
(
false
)
sanitize_stacks_
(
false
)
{
}
explicit
MinidumpDescriptor
(
const
MinidumpDescriptor
&
descriptor
)
;
MinidumpDescriptor
&
operator
=
(
const
MinidumpDescriptor
&
descriptor
)
;
static
MinidumpDescriptor
getMicrodumpDescriptor
(
)
;
bool
IsFD
(
)
const
{
return
mode_
=
=
kWriteMinidumpToFd
;
}
int
fd
(
)
const
{
return
fd_
;
}
string
directory
(
)
const
{
return
directory_
;
}
const
char
*
path
(
)
const
{
return
c_path_
;
}
bool
IsMicrodumpOnConsole
(
)
const
{
return
mode_
=
=
kWriteMicrodumpToConsole
;
}
void
UpdatePath
(
)
;
off_t
size_limit
(
)
const
{
return
size_limit_
;
}
void
set_size_limit
(
off_t
limit
)
{
size_limit_
=
limit
;
}
uintptr_t
address_within_principal_mapping
(
)
const
{
return
address_within_principal_mapping_
;
}
void
set_address_within_principal_mapping
(
uintptr_t
address_within_principal_mapping
)
{
address_within_principal_mapping_
=
address_within_principal_mapping
;
}
bool
skip_dump_if_principal_mapping_not_referenced
(
)
{
return
skip_dump_if_principal_mapping_not_referenced_
;
}
void
set_skip_dump_if_principal_mapping_not_referenced
(
bool
skip_dump_if_principal_mapping_not_referenced
)
{
skip_dump_if_principal_mapping_not_referenced_
=
skip_dump_if_principal_mapping_not_referenced
;
}
bool
sanitize_stacks
(
)
const
{
return
sanitize_stacks_
;
}
void
set_sanitize_stacks
(
bool
sanitize_stacks
)
{
sanitize_stacks_
=
sanitize_stacks
;
}
MicrodumpExtraInfo
*
microdump_extra_info
(
)
{
assert
(
IsMicrodumpOnConsole
(
)
)
;
return
&
microdump_extra_info_
;
}
;
private
:
enum
DumpMode
{
kUninitialized
=
0
kWriteMinidumpToFile
kWriteMinidumpToFd
kWriteMicrodumpToConsole
}
;
DumpMode
mode_
;
int
fd_
;
string
directory_
;
string
path_
;
const
char
*
c_path_
;
off_t
size_limit_
;
uintptr_t
address_within_principal_mapping_
;
bool
skip_dump_if_principal_mapping_not_referenced_
;
bool
sanitize_stacks_
;
MicrodumpExtraInfo
microdump_extra_info_
;
}
;
}
#
endif
