#
include
<
windows
.
h
>
#
include
<
psapi
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdint
.
h
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
.
.
/
crash_generation
/
temporary_stack
.
cc
"
static
bool
failed
=
false
;
namespace
metrics
{
struct
MemoryStat
{
const
char
*
name
;
SIZE_T
PROCESS_MEMORY_COUNTERS
:
:
*
ptr
;
}
;
#
define
DECL_MEMORY_STAT
(
name
)
\
{
#
name
&
PROCESS_MEMORY_COUNTERS
:
:
name
}
constexpr
MemoryStat
relevant_stats
[
]
=
{
DECL_MEMORY_STAT
(
PeakWorkingSetSize
)
DECL_MEMORY_STAT
(
WorkingSetSize
)
DECL_MEMORY_STAT
(
QuotaPeakPagedPoolUsage
)
DECL_MEMORY_STAT
(
QuotaPagedPoolUsage
)
DECL_MEMORY_STAT
(
QuotaPeakNonPagedPoolUsage
)
DECL_MEMORY_STAT
(
QuotaNonPagedPoolUsage
)
DECL_MEMORY_STAT
(
PagefileUsage
)
DECL_MEMORY_STAT
(
PeakPagefileUsage
)
}
;
#
undef
DECL_MEMORY_STAT
struct
MemoryRecord
{
const
char
*
name
;
PROCESS_MEMORY_COUNTERS
stats
;
}
;
MemoryRecord
get_mem_stats
(
const
char
*
name
)
{
MemoryRecord
record
{
.
name
=
name
.
stats
=
{
sizeof
(
PROCESS_MEMORY_COUNTERS
)
}
}
;
:
:
GetProcessMemoryInfo
(
:
:
GetCurrentProcess
(
)
&
record
.
stats
sizeof
(
record
.
stats
)
)
;
return
record
;
}
void
assert_mem_use_is_reasonable
(
MemoryRecord
const
&
mem
)
{
for
(
auto
const
&
stat
:
relevant_stats
)
{
SIZE_T
const
val
=
mem
.
stats
.
*
stat
.
ptr
;
if
(
val
>
10
*
1024
*
1024
)
{
failed
=
true
;
:
:
fprintf
(
stderr
"
unexpectedly
large
%
30s
at
%
s
(
%
zu
)
\
n
"
stat
.
name
mem
.
name
val
)
;
}
}
}
void
assert_compare_mem_stats
(
MemoryRecord
const
&
mem_a
MemoryRecord
const
&
mem_b
)
{
for
(
auto
const
&
stat
:
relevant_stats
)
{
SIZE_T
const
a
=
mem_a
.
stats
.
*
stat
.
ptr
;
SIZE_T
const
b
=
mem_b
.
stats
.
*
stat
.
ptr
;
bool
const
ok
=
(
a
<
=
b
&
&
b
<
=
2
*
a
)
;
if
(
!
ok
)
{
failed
=
true
;
:
:
fprintf
(
stderr
"
unusual
growth
in
%
30s
between
'
%
10s
'
(
%
10zu
)
and
'
%
10s
'
(
%
10zu
)
\
n
"
stat
.
name
mem_a
.
name
a
mem_b
.
name
b
)
;
}
}
}
}
size_t
fibonacci
(
size_t
val
)
{
if
(
val
=
=
0
|
|
val
=
=
1
)
return
val
;
return
fibonacci
(
val
-
1
)
+
fibonacci
(
val
-
2
)
;
}
size_t
fiberborne_fibonacci
(
size_t
val
size_t
stack_size
)
{
auto
const
adaptor
=
[
]
(
void
*
arg
)
{
size_t
*
valptr
=
(
size_t
*
)
arg
;
*
valptr
=
fibonacci
(
*
valptr
)
;
}
;
:
:
RunOnTemporaryStack
(
adaptor
&
val
stack_size
)
;
return
val
;
}
void
test_small
(
)
{
auto
const
initial
=
metrics
:
:
get_mem_stats
(
"
initial
"
)
;
constexpr
size_t
expected_values
[
10
]
=
{
0
1
1
2
3
5
8
13
21
34
}
;
for
(
size_t
i
=
0
;
i
<
ARRAYSIZE
(
expected_values
)
;
+
+
i
)
{
auto
const
actual
=
:
:
fiberborne_fibonacci
(
i
1024
)
;
auto
const
expected
=
:
:
fibonacci
(
i
)
;
if
(
actual
!
=
expected
)
{
failed
=
true
;
:
:
fprintf
(
stderr
"
Fib
(
%
zu
)
not
computed
correctly
?
!
got
%
zu
expected
%
zu
\
n
"
i
actual
expected
)
;
}
}
auto
const
after_small
=
metrics
:
:
get_mem_stats
(
"
after_small
"
)
;
assert_compare_mem_stats
(
initial
after_small
)
;
}
void
test_large
(
)
{
#
ifdef
_WIN64
constexpr
size_t
very_large_stack_size
=
size_t
(
1024
)
*
1024
*
1024
*
1024
;
#
else
constexpr
size_t
very_large_stack_size
=
size_t
(
256
)
*
1024
*
1024
;
#
endif
:
:
fiberborne_fibonacci
(
0
very_large_stack_size
)
;
auto
const
after_once
=
metrics
:
:
get_mem_stats
(
"
after
once
"
)
;
assert_mem_use_is_reasonable
(
after_once
)
;
for
(
size_t
i
=
0
;
i
<
10
;
+
+
i
)
{
:
:
fiberborne_fibonacci
(
i
very_large_stack_size
)
;
assert_mem_use_is_reasonable
(
metrics
:
:
get_mem_stats
(
"
somewhere
in
the
loop
"
)
)
;
}
auto
const
after_many
=
metrics
:
:
get_mem_stats
(
"
after
many
"
)
;
assert_compare_mem_stats
(
after_once
after_many
)
;
}
struct
confirm_normal_exit
{
private
:
struct
handles
{
HANDLE
const
hMainThread
;
HANDLE
const
hExitEvent
;
HANDLE
const
hInitializationEvent
;
handles
(
)
:
hMainThread
(
confirm_normal_exit
:
:
get_current_thread_handle
(
)
)
hExitEvent
(
:
:
CreateEventW
(
NULL
TRUE
FALSE
NULL
)
)
hInitializationEvent
(
:
:
CreateEventW
(
NULL
TRUE
FALSE
NULL
)
)
{
}
~
handles
(
)
{
:
:
CloseHandle
(
hInitializationEvent
)
;
:
:
CloseHandle
(
hExitEvent
)
;
:
:
CloseHandle
(
hMainThread
)
;
}
}
;
std
:
:
shared_ptr
<
handles
>
handles_ptr
;
static
DWORD
ThreadFunc
(
std
:
:
shared_ptr
<
handles
>
handles_ptr
)
{
HANDLE
handles
[
2
]
=
{
handles_ptr
-
>
hExitEvent
handles_ptr
-
>
hMainThread
}
;
DWORD
const
ret
=
:
:
WaitForMultipleObjects
(
2
handles
FALSE
INFINITE
)
;
if
(
ret
!
=
WAIT_OBJECT_0
+
0
)
{
failed
=
true
;
fprintf
(
stderr
"
%
s
\
n
"
"
Unexpected
exit
of
main
thread
:
"
"
fiber
did
not
relinquish
control
?
"
)
;
:
:
ExitProcess
(
1
)
;
}
return
0
;
}
static
HANDLE
get_current_thread_handle
(
)
{
HANDLE
handle
;
const
auto
ret
=
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
:
:
GetCurrentThread
(
)
:
:
GetCurrentProcess
(
)
&
handle
SYNCHRONIZE
FALSE
0
)
;
if
(
!
ret
)
{
const
unsigned
long
err
=
:
:
GetLastError
(
)
;
:
:
fprintf
(
stderr
"
DuplicateHandle
failed
with
error
code
%
lu
\
n
"
err
)
;
:
:
ExitProcess
(
1
)
;
}
return
handle
;
}
public
:
confirm_normal_exit
(
)
:
handles_ptr
(
std
:
:
make_shared
<
handles
>
(
)
)
{
auto
const
thread_func
=
[
]
(
void
*
p
)
-
>
DWORD
{
confirm_normal_exit
*
this_
=
(
(
confirm_normal_exit
*
)
p
)
;
std
:
:
shared_ptr
<
handles
>
local_handles_ptr
(
this_
-
>
handles_ptr
)
;
:
:
SetEvent
(
local_handles_ptr
-
>
hInitializationEvent
)
;
return
confirm_normal_exit
:
:
ThreadFunc
(
std
:
:
move
(
local_handles_ptr
)
)
;
}
;
:
:
CreateThread
(
NULL
0
thread_func
this
0
NULL
)
;
:
:
WaitForSingleObject
(
handles_ptr
-
>
hInitializationEvent
INFINITE
)
;
}
~
confirm_normal_exit
(
)
{
:
:
SetEvent
(
handles_ptr
-
>
hExitEvent
)
;
}
}
;
int
main
(
int
char
*
*
)
{
confirm_normal_exit
_cne
;
test_small
(
)
;
test_large
(
)
;
if
(
failed
)
{
:
:
printf
(
"
%
s
\
n
"
"
failed
(
see
above
)
"
)
;
return
1
;
}
:
:
printf
(
"
%
s
\
n
"
"
all
ok
"
)
;
return
0
;
}
