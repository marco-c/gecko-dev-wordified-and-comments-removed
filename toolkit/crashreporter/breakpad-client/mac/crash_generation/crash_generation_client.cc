#
include
"
mac
/
crash_generation
/
crash_generation_client
.
h
"
#
include
"
mac
/
crash_generation
/
crash_generation_server
.
h
"
#
include
"
common
/
mac
/
MachIPC
.
h
"
#
include
<
pthread
.
h
>
#
include
<
servers
/
bootstrap
.
h
>
namespace
google_breakpad
{
bool
CrashGenerationClient
:
:
RequestDumpForException
(
int
exception_type
int
exception_code
int64_t
exception_subcode
mach_port_t
crashing_thread
mach_port_t
crashing_task
)
{
if
(
!
WaitForInitialization
(
)
)
{
return
false
;
}
ReceivePort
acknowledge_port
;
MachSendMessage
message
(
kDumpRequestMessage
)
;
message
.
AddDescriptor
(
crashing_task
)
;
message
.
AddDescriptor
(
crashing_thread
)
;
message
.
AddDescriptor
(
MACH_PORT_NULL
)
;
message
.
AddDescriptor
(
acknowledge_port
.
GetPort
(
)
)
;
ExceptionInfo
info
;
info
.
exception_type
=
exception_type
;
info
.
exception_code
=
exception_code
;
info
.
exception_subcode
=
exception_subcode
;
info
.
child_pid
=
getpid
(
)
;
message
.
SetData
(
&
info
sizeof
(
info
)
)
;
kern_return_t
result
=
sender_
-
>
SendMessage
(
message
MACH_MSG_TIMEOUT_NONE
)
;
if
(
result
!
=
KERN_SUCCESS
)
return
false
;
MachReceiveMessage
acknowledge_message
;
result
=
acknowledge_port
.
WaitForMessage
(
&
acknowledge_message
MACH_MSG_TIMEOUT_NONE
)
;
return
result
=
=
KERN_SUCCESS
;
}
void
*
CrashGenerationClient
:
:
AsynchronousInitializationThread
(
void
*
arg
)
{
CrashGenerationClient
*
client
=
reinterpret_cast
<
CrashGenerationClient
*
>
(
arg
)
;
client
-
>
Initialization
(
)
;
return
nullptr
;
}
void
CrashGenerationClient
:
:
Initialization
(
)
{
assert
(
state_
=
=
State
:
:
Uninitialized
)
;
mach_port_t
task_bootstrap_port
=
0
;
kern_return_t
rv
=
task_get_bootstrap_port
(
mach_task_self
(
)
&
task_bootstrap_port
)
;
if
(
rv
!
=
KERN_SUCCESS
)
{
os_unfair_lock_lock
(
&
sync_
)
;
state_
=
State
:
:
Failed
;
os_unfair_lock_unlock
(
&
sync_
)
;
return
;
}
while
(
true
)
{
mach_port_t
send_port
;
rv
=
bootstrap_look_up
(
task_bootstrap_port
mach_port_name_
.
c_str
(
)
&
send_port
)
;
if
(
rv
=
=
KERN_SUCCESS
)
{
os_unfair_lock_lock
(
&
sync_
)
;
state_
=
State
:
:
Initialized
;
sender_
=
std
:
:
make_unique
<
MachPortSender
>
(
send_port
)
;
os_unfair_lock_unlock
(
&
sync_
)
;
return
;
}
else
if
(
rv
=
=
BOOTSTRAP_UNKNOWN_SERVICE
)
{
struct
timespec
delay
=
{
.
tv_sec
=
0
.
tv_nsec
=
10
*
1000
*
1000
}
;
nanosleep
(
&
delay
nullptr
)
;
}
else
{
os_unfair_lock_lock
(
&
sync_
)
;
state_
=
State
:
:
Failed
;
os_unfair_lock_unlock
(
&
sync_
)
;
return
;
}
}
}
void
CrashGenerationClient
:
:
AsynchronousInitialization
(
)
{
pthread_t
thread
;
int
rv
=
pthread_create
(
&
thread
nullptr
AsynchronousInitializationThread
this
)
;
if
(
rv
<
0
)
{
state_
=
State
:
:
Failed
;
}
pthread_detach
(
thread
)
;
}
bool
CrashGenerationClient
:
:
WaitForInitialization
(
)
{
while
(
true
)
{
while
(
!
os_unfair_lock_trylock
(
&
sync_
)
)
{
}
State
state
=
state_
;
os_unfair_lock_unlock
(
&
sync_
)
;
switch
(
state
)
{
case
Initializing
:
continue
;
case
Initialized
:
return
true
;
default
:
return
false
;
}
}
}
}
