var
{
OS
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
makeFakeAppDir
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
AppData
.
jsm
"
)
;
var
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
function
getEventDir
(
)
{
return
OS
.
Path
.
join
(
do_get_tempdir
(
)
.
path
"
crash
-
events
"
)
;
}
function
sendCommandAsync
(
command
)
{
return
new
Promise
(
resolve
=
>
{
sendCommand
(
command
resolve
)
;
}
)
;
}
async
function
do_crash
(
setup
callback
canReturnZero
)
{
let
bin
=
Services
.
dirsvc
.
get
(
"
XREExeF
"
Ci
.
nsIFile
)
;
if
(
!
bin
.
exists
(
)
)
{
do_throw
(
"
Can
'
t
find
xpcshell
binary
!
"
)
;
}
let
greD
=
Services
.
dirsvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
;
let
headfile
=
do_get_file
(
"
crasher_subprocess_head
.
js
"
)
;
let
tailfile
=
do_get_file
(
"
crasher_subprocess_tail
.
js
"
)
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
bin
)
;
let
args
=
[
"
-
g
"
greD
.
path
"
-
f
"
headfile
.
path
]
;
if
(
setup
)
{
if
(
typeof
setup
=
=
"
function
"
)
{
setup
=
"
(
"
+
setup
.
toSource
(
)
+
"
)
(
)
;
"
;
}
args
.
push
(
"
-
e
"
setup
)
;
}
args
.
push
(
"
-
f
"
tailfile
.
path
)
;
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
crashD
=
do_get_tempdir
(
)
;
crashD
.
append
(
"
crash
-
events
"
)
;
if
(
!
crashD
.
exists
(
)
)
{
crashD
.
create
(
crashD
.
DIRECTORY_TYPE
0o700
)
;
}
env
.
set
(
"
CRASHES_EVENTS_DIR
"
crashD
.
path
)
;
try
{
process
.
run
(
true
args
args
.
length
)
;
}
catch
(
ex
)
{
}
finally
{
env
.
set
(
"
CRASHES_EVENTS_DIR
"
"
"
)
;
}
if
(
!
canReturnZero
)
{
Assert
.
notEqual
(
process
.
exitValue
0
)
;
}
await
handleMinidump
(
callback
)
;
}
function
getMinidump
(
)
{
let
en
=
do_get_tempdir
(
)
.
directoryEntries
;
while
(
en
.
hasMoreElements
(
)
)
{
let
f
=
en
.
nextFile
;
if
(
f
.
leafName
.
substr
(
-
4
)
=
=
"
.
dmp
"
)
{
return
f
;
}
}
return
null
;
}
function
getMinidumpAnalyzerPath
(
)
{
const
binSuffix
=
AppConstants
.
platform
=
=
=
"
win
"
?
"
.
exe
"
:
"
"
;
const
exeName
=
"
minidump
-
analyzer
"
+
binSuffix
;
let
exe
=
Services
.
dirsvc
.
get
(
"
GreBinD
"
Ci
.
nsIFile
)
;
exe
.
append
(
exeName
)
;
return
exe
;
}
function
runMinidumpAnalyzer
(
dumpFile
additionalArgs
)
{
let
bin
=
getMinidumpAnalyzerPath
(
)
;
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
bin
)
;
let
args
=
[
]
;
if
(
additionalArgs
)
{
args
=
args
.
concat
(
additionalArgs
)
;
}
args
.
push
(
dumpFile
.
path
)
;
process
.
run
(
true
args
args
.
length
)
;
}
async
function
handleMinidump
(
callback
)
{
let
minidump
=
getMinidump
(
)
;
if
(
minidump
=
=
null
)
{
do_throw
(
"
No
minidump
found
!
"
)
;
}
let
extrafile
=
minidump
.
clone
(
)
;
extrafile
.
leafName
=
extrafile
.
leafName
.
slice
(
0
-
4
)
+
"
.
extra
"
;
let
memoryfile
=
minidump
.
clone
(
)
;
memoryfile
.
leafName
=
memoryfile
.
leafName
.
slice
(
0
-
4
)
+
"
.
memory
.
json
.
gz
"
;
let
cleanup
=
function
(
)
{
[
minidump
extrafile
memoryfile
]
.
forEach
(
file
=
>
{
if
(
file
.
exists
(
)
)
{
file
.
remove
(
false
)
;
}
}
)
;
}
;
registerCleanupFunction
(
cleanup
)
;
Assert
.
ok
(
extrafile
.
exists
(
)
)
;
let
data
=
await
OS
.
File
.
read
(
extrafile
.
path
)
;
let
decoder
=
new
TextDecoder
(
)
;
let
extra
=
JSON
.
parse
(
decoder
.
decode
(
data
)
)
;
if
(
callback
)
{
await
callback
(
minidump
extra
extrafile
memoryfile
)
;
}
cleanup
(
)
;
}
function
spinEventLoop
(
)
{
return
new
Promise
(
resolve
=
>
{
executeSoon
(
resolve
)
;
}
)
;
}
async
function
do_content_crash
(
setup
callback
)
{
do_load_child_test_harness
(
)
;
let
crashReporter
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
.
getService
(
Ci
.
nsICrashReporter
)
;
crashReporter
.
minidumpPath
=
do_get_tempdir
(
)
;
let
headfile
=
do_get_file
(
"
.
.
/
unit
/
crasher_subprocess_head
.
js
"
)
;
let
tailfile
=
do_get_file
(
"
.
.
/
unit
/
crasher_subprocess_tail
.
js
"
)
;
if
(
setup
)
{
if
(
typeof
setup
=
=
"
function
"
)
{
setup
=
"
(
"
+
setup
.
toSource
(
)
+
"
)
(
)
;
"
;
}
}
do_get_profile
(
)
;
await
makeFakeAppDir
(
)
;
await
sendCommandAsync
(
'
load
(
"
'
+
headfile
.
path
.
replace
(
/
\
\
/
g
"
/
"
)
+
'
"
)
;
'
)
;
if
(
setup
)
{
await
sendCommandAsync
(
setup
)
;
}
await
sendCommandAsync
(
'
load
(
"
'
+
tailfile
.
path
.
replace
(
/
\
\
/
g
"
/
"
)
+
'
"
)
;
'
)
;
await
spinEventLoop
(
)
;
let
minidump
=
getMinidump
(
)
;
let
id
=
minidump
.
leafName
.
slice
(
0
-
4
)
;
await
Services
.
crashmanager
.
ensureCrashIsPresent
(
id
)
;
try
{
await
handleMinidump
(
callback
)
;
}
catch
(
x
)
{
do_report_unexpected_exception
(
x
)
;
}
}
async
function
do_triggered_content_crash
(
trigger
callback
)
{
do_load_child_test_harness
(
)
;
let
crashReporter
=
Cc
[
"
mozilla
.
org
/
toolkit
/
crash
-
reporter
;
1
"
]
.
getService
(
Ci
.
nsICrashReporter
)
;
crashReporter
.
minidumpPath
=
do_get_tempdir
(
)
;
let
headfile
=
do_get_file
(
"
.
.
/
unit
/
crasher_subprocess_head
.
js
"
)
;
if
(
trigger
)
{
if
(
typeof
trigger
=
=
"
function
"
)
{
trigger
=
"
(
"
+
trigger
.
toSource
(
)
+
"
)
(
)
;
"
;
}
}
do_get_profile
(
)
;
await
makeFakeAppDir
(
)
;
await
sendCommandAsync
(
'
load
(
"
'
+
headfile
.
path
.
replace
(
/
\
\
/
g
"
/
"
)
+
'
"
)
;
'
)
;
await
sendCommandAsync
(
trigger
)
;
await
spinEventLoop
(
)
;
let
id
=
getMinidump
(
)
.
leafName
.
slice
(
0
-
4
)
;
await
Services
.
crashmanager
.
ensureCrashIsPresent
(
id
)
;
try
{
await
handleMinidump
(
callback
)
;
}
catch
(
x
)
{
do_report_unexpected_exception
(
x
)
;
}
}
async
function
do_backgroundtask_crash
(
crashType
crashExtras
callback
canReturnZero
)
{
Assert
.
ok
(
AppConstants
.
MOZ_BACKGROUNDTASKS
)
;
let
bin
=
Services
.
dirsvc
.
get
(
"
GreBinD
"
Ci
.
nsIFile
)
;
if
(
AppConstants
.
platform
=
=
=
"
win
"
)
{
bin
.
append
(
AppConstants
.
MOZ_APP_NAME
+
"
.
exe
"
)
;
}
else
{
bin
.
append
(
AppConstants
.
MOZ_APP_NAME
)
;
}
let
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
process
.
init
(
bin
)
;
let
args
=
[
"
-
-
backgroundtask
"
"
crash
"
]
;
args
.
push
(
crashType
.
toString
(
)
)
;
let
sorted
=
Object
.
entries
(
crashExtras
)
.
sort
(
(
a
b
)
=
>
a
[
0
]
<
b
[
0
]
)
;
for
(
let
[
key
value
]
of
sorted
)
{
args
.
push
(
key
)
;
args
.
push
(
value
)
;
}
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
crashD
=
do_get_tempdir
(
)
;
crashD
.
append
(
"
crash
-
events
"
)
;
if
(
!
crashD
.
exists
(
)
)
{
crashD
.
create
(
crashD
.
DIRECTORY_TYPE
0o700
)
;
}
env
.
set
(
"
CRASHES_EVENTS_DIR
"
crashD
.
path
)
;
let
protocolHandler
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
let
uri
=
protocolHandler
.
getSubstitution
(
"
testing
-
common
"
)
;
Assert
.
ok
(
uri
"
resource
:
/
/
testing
-
common
is
not
substituted
"
)
;
env
.
set
(
"
XPCSHELL_TESTING_MODULES_URI
"
uri
.
spec
)
;
try
{
process
.
run
(
true
args
args
.
length
)
;
}
catch
(
ex
)
{
}
finally
{
env
.
set
(
"
CRASHES_EVENTS_DIR
"
"
"
)
;
env
.
set
(
"
XPCSHELL_TESTING_MODULES_URI
"
"
"
)
;
}
if
(
!
canReturnZero
)
{
Assert
.
notEqual
(
process
.
exitValue
0
)
;
}
await
handleMinidump
(
callback
)
;
}
var
{
CrashTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
test
/
CrashTestUtils
.
jsm
"
)
;
