var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
function
create_subdir
(
dir
subdirname
)
{
let
subdir
=
dir
.
clone
(
)
;
subdir
.
append
(
subdirname
)
;
if
(
subdir
.
exists
(
)
)
{
subdir
.
remove
(
true
)
;
}
subdir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
return
subdir
;
}
function
generate_uuid
(
)
{
let
uuidGenerator
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
let
uuid
=
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
;
return
uuid
.
substring
(
1
uuid
.
length
-
1
)
;
}
var
_provider
=
null
;
function
make_fake_appdir
(
)
{
let
profD
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
let
appD
=
create_subdir
(
profD
"
UAppData
"
)
;
let
crashesDir
=
create_subdir
(
appD
"
Crash
Reports
"
)
;
create_subdir
(
crashesDir
"
pending
"
)
;
create_subdir
(
crashesDir
"
submitted
"
)
;
_provider
=
{
getFile
(
prop
persistent
)
{
persistent
.
value
=
true
;
if
(
prop
=
=
"
UAppData
"
)
{
return
appD
.
clone
(
)
;
}
dump
(
"
WARNING
:
make_fake_appdir
-
fake
nsIDirectoryServiceProvider
-
Unexpected
getFile
for
:
'
"
+
prop
+
"
'
\
n
"
)
;
return
null
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIDirectoryServiceProvider
"
]
)
}
;
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIDirectoryService
)
.
registerProvider
(
_provider
)
;
try
{
Services
.
dirsvc
.
undefine
(
"
UAppData
"
)
;
}
catch
(
ex
)
{
}
return
appD
.
clone
(
)
;
}
function
cleanup_fake_appdir
(
)
{
Services
.
dirsvc
.
QueryInterface
(
Ci
.
nsIDirectoryService
)
.
unregisterProvider
(
_provider
)
;
try
{
Services
.
dirsvc
.
undefine
(
"
UAppData
"
)
;
}
catch
(
ex
)
{
dump
(
"
cleanup_fake_appdir
:
dirSvc
.
undefine
failed
:
"
+
ex
.
message
+
"
\
n
"
)
;
}
}
function
add_fake_crashes
(
crD
count
)
{
let
results
=
[
]
;
let
submitdir
=
crD
.
clone
(
)
;
submitdir
.
append
(
"
submitted
"
)
;
let
date
=
Date
.
now
(
)
-
count
*
60000
;
for
(
let
i
=
0
;
i
<
count
;
i
+
+
)
{
let
uuid
=
"
bp
-
"
+
generate_uuid
(
)
;
let
fn
=
uuid
+
"
.
txt
"
;
let
file
=
submitdir
.
clone
(
)
;
file
.
append
(
fn
)
;
file
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o666
)
;
file
.
lastModifiedTime
=
date
;
results
.
push
(
{
id
:
uuid
date
pending
:
false
}
)
;
date
+
=
60000
;
}
results
.
sort
(
(
a
b
)
=
>
b
.
date
-
a
.
date
)
;
return
results
;
}
function
clear_fake_crashes
(
crD
crashes
)
{
let
submitdir
=
crD
.
clone
(
)
;
submitdir
.
append
(
"
submitted
"
)
;
for
(
let
i
of
crashes
)
{
let
fn
=
i
.
id
+
"
.
txt
"
;
let
file
=
submitdir
.
clone
(
)
;
file
.
append
(
fn
)
;
file
.
remove
(
false
)
;
}
}
function
writeDataToFile
(
file
data
)
{
var
fstream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
fstream
.
init
(
file
-
1
-
1
0
)
;
var
os
=
Cc
[
"
mozilla
.
org
/
intl
/
converter
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIConverterOutputStream
)
;
os
.
init
(
fstream
"
UTF
-
8
"
)
;
os
.
writeString
(
data
)
;
os
.
close
(
)
;
fstream
.
close
(
)
;
}
function
writeCrashReportFile
(
dir
uuid
suffix
date
data
)
{
let
file
=
dir
.
clone
(
)
;
file
.
append
(
uuid
+
suffix
)
;
writeDataToFile
(
file
data
)
;
file
.
lastModifiedTime
=
date
;
}
function
writeMinidumpFile
(
dir
uuid
date
)
{
writeCrashReportFile
(
dir
uuid
"
.
dmp
"
date
"
MDMP
"
)
;
}
function
writeExtraFile
(
dir
uuid
date
data
)
{
let
extradata
=
"
"
;
for
(
let
x
in
data
)
{
extradata
+
=
x
+
"
=
"
+
data
[
x
]
+
"
\
n
"
;
}
writeCrashReportFile
(
dir
uuid
"
.
extra
"
date
extradata
)
;
}
function
writeMemoryReport
(
dir
uuid
date
)
{
let
data
=
"
Let
'
s
pretend
this
is
a
memory
report
"
;
writeCrashReportFile
(
dir
uuid
"
.
memory
.
json
.
gz
"
date
data
)
;
}
function
addPendingCrashreport
(
crD
date
extra
)
{
let
pendingdir
=
crD
.
clone
(
)
;
pendingdir
.
append
(
"
pending
"
)
;
let
uuid
=
generate_uuid
(
)
;
writeMinidumpFile
(
pendingdir
uuid
date
)
;
writeExtraFile
(
pendingdir
uuid
date
extra
)
;
writeMemoryReport
(
pendingdir
uuid
date
)
;
return
{
id
:
uuid
date
pending
:
true
extra
}
;
}
function
addIncompletePendingCrashreport
(
crD
date
)
{
let
pendingdir
=
crD
.
clone
(
)
;
pendingdir
.
append
(
"
pending
"
)
;
let
uuid
=
generate_uuid
(
)
;
writeMinidumpFile
(
pendingdir
uuid
date
)
;
return
{
id
:
uuid
date
pending
:
true
}
;
}
