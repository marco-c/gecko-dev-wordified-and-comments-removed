let
reportURL
;
const
{
CrashReports
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
CrashReports
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CrashSubmit
"
"
resource
:
/
/
gre
/
modules
/
CrashSubmit
.
jsm
"
)
;
document
.
addEventListener
(
"
DOMContentLoaded
"
(
)
=
>
{
populateReportLists
(
)
;
document
.
getElementById
(
"
clearUnsubmittedReports
"
)
.
addEventListener
(
"
click
"
(
)
=
>
{
clearUnsubmittedReports
(
)
.
catch
(
Cu
.
reportError
)
;
}
)
;
document
.
getElementById
(
"
submitAllUnsubmittedReports
"
)
.
addEventListener
(
"
click
"
(
)
=
>
{
submitAllUnsubmittedReports
(
)
.
catch
(
Cu
.
reportError
)
;
}
)
;
document
.
getElementById
(
"
clearSubmittedReports
"
)
.
addEventListener
(
"
click
"
(
)
=
>
{
clearSubmittedReports
(
)
.
catch
(
Cu
.
reportError
)
;
}
)
;
}
)
;
const
buildID
=
Services
.
appinfo
.
appBuildID
;
function
populateReportLists
(
)
{
try
{
reportURL
=
Services
.
prefs
.
getCharPref
(
"
breakpad
.
reportURL
"
)
;
if
(
!
/
^
https
?
:
/
i
.
test
(
reportURL
)
)
{
reportURL
=
null
;
}
}
catch
(
e
)
{
reportURL
=
null
;
}
if
(
!
reportURL
)
{
document
.
getElementById
(
"
noConfig
"
)
.
classList
.
remove
(
"
hidden
"
)
;
return
;
}
const
reports
=
CrashReports
.
getReports
(
)
;
const
dateFormatter
=
new
Services
.
intl
.
DateTimeFormat
(
undefined
{
timeStyle
:
"
short
"
dateStyle
:
"
short
"
}
)
;
reports
.
forEach
(
report
=
>
addReportRow
(
report
.
pending
report
.
id
report
.
date
dateFormatter
)
)
;
showAppropriateSections
(
)
;
}
function
addReportRow
(
isPending
id
date
dateFormatter
)
{
const
rowTemplate
=
document
.
getElementById
(
"
crashReportRow
"
)
;
const
row
=
document
.
importNode
(
rowTemplate
.
content
true
)
.
querySelector
(
"
tr
"
)
;
row
.
id
=
id
;
const
cells
=
row
.
querySelectorAll
(
"
td
"
)
;
cells
[
0
]
.
appendChild
(
document
.
createTextNode
(
id
)
)
;
cells
[
1
]
.
appendChild
(
document
.
createTextNode
(
dateFormatter
.
format
(
date
)
)
)
;
if
(
isPending
)
{
const
buttonTemplate
=
document
.
getElementById
(
"
crashSubmitButton
"
)
;
const
button
=
document
.
importNode
(
buttonTemplate
.
content
true
)
.
querySelector
(
"
button
"
)
;
const
buttonText
=
button
.
querySelector
(
"
span
"
)
;
button
.
addEventListener
(
"
click
"
(
)
=
>
submitPendingReport
(
id
row
button
buttonText
dateFormatter
)
)
;
cells
[
2
]
.
appendChild
(
button
)
;
document
.
getElementById
(
"
unsubmitted
"
)
.
appendChild
(
row
)
;
}
else
{
const
linkTemplate
=
document
.
getElementById
(
"
viewCrashLink
"
)
;
const
link
=
document
.
importNode
(
linkTemplate
.
content
true
)
.
querySelector
(
"
a
"
)
;
link
.
href
=
{
reportURL
}
{
id
}
;
cells
[
2
]
.
appendChild
(
link
)
;
document
.
getElementById
(
"
submitted
"
)
.
appendChild
(
row
)
;
}
}
function
showAppropriateSections
(
)
{
let
hasUnsubmitted
=
document
.
getElementById
(
"
unsubmitted
"
)
.
childElementCount
>
0
;
document
.
getElementById
(
"
reportListUnsubmitted
"
)
.
classList
.
toggle
(
"
hidden
"
!
hasUnsubmitted
)
;
let
hasSubmitted
=
document
.
getElementById
(
"
submitted
"
)
.
childElementCount
>
0
;
document
.
getElementById
(
"
reportListSubmitted
"
)
.
classList
.
toggle
(
"
hidden
"
!
hasSubmitted
)
;
document
.
getElementById
(
"
noSubmittedReports
"
)
.
classList
.
toggle
(
"
hidden
"
hasSubmitted
)
;
}
function
submitPendingReport
(
reportId
row
button
buttonText
dateFormatter
)
{
button
.
classList
.
add
(
"
submitting
"
)
;
document
.
getElementById
(
"
submitAllUnsubmittedReports
"
)
.
disabled
=
true
;
CrashSubmit
.
submit
(
reportId
{
noThrottle
:
true
}
)
.
then
(
remoteCrashID
=
>
{
document
.
getElementById
(
"
unsubmitted
"
)
.
removeChild
(
row
)
;
const
report
=
CrashReports
.
getReports
(
)
.
filter
(
report
=
>
report
.
id
=
=
=
remoteCrashID
)
;
addReportRow
(
false
remoteCrashID
report
.
date
dateFormatter
)
;
showAppropriateSections
(
)
;
dispatchEvent
(
"
CrashSubmitSucceeded
"
)
;
}
(
)
=
>
{
button
.
classList
.
remove
(
"
submitting
"
)
;
button
.
classList
.
add
(
"
failed
-
to
-
submit
"
)
;
document
.
l10n
.
setAttributes
(
buttonText
"
submit
-
crash
-
button
-
failure
-
label
"
)
;
dispatchEvent
(
"
CrashSubmitFailed
"
)
;
}
)
.
finally
(
(
)
=
>
{
document
.
getElementById
(
"
submitAllUnsubmittedReports
"
)
.
disabled
=
false
;
}
)
;
}
async
function
clearUnsubmittedReports
(
)
{
const
[
title
description
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
delete
-
confirm
-
title
"
}
{
id
:
"
delete
-
unsubmitted
-
description
"
}
]
)
;
if
(
!
Services
.
prompt
.
confirm
(
window
title
description
)
)
{
return
;
}
await
cleanupFolder
(
CrashReports
.
pendingDir
.
path
)
;
await
clearOldReports
(
)
;
document
.
getElementById
(
"
reportListUnsubmitted
"
)
.
classList
.
add
(
"
hidden
"
)
;
}
async
function
submitAllUnsubmittedReports
(
)
{
for
(
var
i
=
0
;
i
<
document
.
getElementById
(
"
unsubmitted
"
)
.
childNodes
.
length
;
i
+
+
)
{
document
.
getElementById
(
"
unsubmitted
"
)
.
childNodes
[
i
]
.
cells
[
2
]
.
childNodes
[
0
]
.
click
(
)
;
}
}
async
function
clearSubmittedReports
(
)
{
const
[
title
description
]
=
await
document
.
l10n
.
formatValues
(
[
{
id
:
"
delete
-
confirm
-
title
"
}
{
id
:
"
delete
-
submitted
-
description
"
}
]
)
;
if
(
!
Services
.
prompt
.
confirm
(
window
title
description
)
)
{
return
;
}
await
cleanupFolder
(
CrashReports
.
submittedDir
.
path
async
entry
=
>
entry
.
name
.
startsWith
(
"
bp
-
"
)
&
&
entry
.
name
.
endsWith
(
"
.
txt
"
)
)
;
await
clearOldReports
(
)
;
document
.
getElementById
(
"
reportListSubmitted
"
)
.
classList
.
add
(
"
hidden
"
)
;
document
.
getElementById
(
"
noSubmittedReports
"
)
.
classList
.
remove
(
"
hidden
"
)
;
}
async
function
clearOldReports
(
)
{
const
oneYearAgo
=
Date
.
now
(
)
-
31586000000
;
await
cleanupFolder
(
CrashReports
.
reportsDir
.
path
async
entry
=
>
{
if
(
!
entry
.
name
.
startsWith
(
"
InstallTime
"
)
|
|
entry
.
name
=
=
"
InstallTime
"
+
buildID
)
{
return
false
;
}
let
date
=
entry
.
winLastWriteDate
;
if
(
!
date
)
{
const
stat
=
await
OS
.
File
.
stat
(
entry
.
path
)
;
date
=
stat
.
lastModificationDate
;
}
return
date
<
oneYearAgo
;
}
)
;
}
async
function
cleanupFolder
(
path
filter
)
{
const
iterator
=
new
OS
.
File
.
DirectoryIterator
(
path
)
;
try
{
await
iterator
.
forEach
(
async
entry
=
>
{
if
(
!
filter
|
|
(
await
filter
(
entry
)
)
)
{
await
OS
.
File
.
remove
(
entry
.
path
)
;
}
}
)
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
OS
.
File
.
Error
)
|
|
!
e
.
becauseNoSuchFile
)
{
throw
e
;
}
}
finally
{
iterator
.
close
(
)
;
}
}
function
dispatchEvent
(
name
)
{
const
event
=
document
.
createEvent
(
"
Events
"
)
;
event
.
initEvent
(
name
true
false
)
;
document
.
dispatchEvent
(
event
)
;
}
