#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
android
"
)
)
]
extern
crate
rust_minidump_writer_linux
;
mod
breakpad_crash_generator
;
mod
crash_generation
;
mod
ipc_server
;
mod
logging
;
mod
phc
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
use
crash_helper_common
:
:
Pid
;
#
[
cfg
(
target_os
=
"
android
"
)
]
use
crash_helper_common
:
:
RawAncillaryData
;
use
crash_helper_common
:
:
{
BreakpadData
BreakpadRawData
IPCConnector
IPCListener
}
;
use
std
:
:
{
ffi
:
:
{
c_char
CStr
OsString
}
fmt
:
:
Display
}
;
use
crash_generation
:
:
CrashGenerator
;
use
ipc_server
:
:
{
IPCServer
IPCServerState
}
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_generator_logic_desktop
(
client_pid
:
Pid
breakpad_data
:
BreakpadRawData
minidump_path
:
*
const
c_char
listener
:
*
const
c_char
pipe
:
*
const
c_char
)
-
>
i32
{
daemonize
(
)
;
logging
:
:
init
(
)
;
let
breakpad_data
=
BreakpadData
:
:
new
(
breakpad_data
)
;
let
minidump_path
=
unsafe
{
CStr
:
:
from_ptr
(
minidump_path
)
}
.
to_owned
(
)
.
into_string
(
)
.
unwrap
(
)
;
let
minidump_path
=
OsString
:
:
from
(
minidump_path
)
;
let
listener
=
unsafe
{
CStr
:
:
from_ptr
(
listener
)
}
;
let
listener
=
unwrap_with_message
(
IPCListener
:
:
deserialize
(
listener
client_pid
)
"
Could
not
parse
the
crash
generator
'
s
listener
"
)
;
let
pipe
=
unsafe
{
CStr
:
:
from_ptr
(
pipe
)
}
;
let
connector
=
unwrap_with_message
(
IPCConnector
:
:
deserialize
(
pipe
)
"
Could
not
parse
the
crash
generator
'
s
connector
"
)
;
let
crash_generator
=
unwrap_with_message
(
CrashGenerator
:
:
new
(
breakpad_data
minidump_path
)
"
Could
not
create
the
crash
generator
"
)
;
let
ipc_server
=
unwrap_with_message
(
IPCServer
:
:
new
(
listener
connector
)
"
Could
not
create
the
IPC
server
"
)
;
main_loop
(
ipc_server
crash_generator
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_generator_logic_android
(
breakpad_data
:
BreakpadRawData
minidump_path
:
*
const
c_char
pipe
:
RawAncillaryData
)
{
logging
:
:
init
(
)
;
let
breakpad_data
=
BreakpadData
:
:
new
(
breakpad_data
)
;
let
minidump_path
=
unsafe
{
CStr
:
:
from_ptr
(
minidump_path
)
}
.
to_owned
(
)
.
into_string
(
)
.
unwrap
(
)
;
let
minidump_path
=
OsString
:
:
from
(
minidump_path
)
;
let
_
=
std
:
:
thread
:
:
spawn
(
move
|
|
{
let
crash_generator
=
unwrap_with_message
(
CrashGenerator
:
:
new
(
breakpad_data
minidump_path
)
"
Could
not
create
the
crash
generator
"
)
;
let
listener
=
IPCListener
:
:
new
(
0
)
.
unwrap
(
)
;
let
connector
=
unwrap_with_message
(
unsafe
{
IPCConnector
:
:
from_raw_ancillary
(
pipe
)
}
"
Could
not
use
the
pipe
"
)
;
let
ipc_server
=
unwrap_with_message
(
IPCServer
:
:
new
(
listener
connector
)
"
Could
not
create
the
IPC
server
"
)
;
main_loop
(
ipc_server
crash_generator
)
}
)
;
}
fn
main_loop
(
mut
ipc_server
:
IPCServer
mut
crash_generator
:
CrashGenerator
)
-
>
i32
{
loop
{
match
ipc_server
.
run
(
&
mut
crash_generator
)
{
Ok
(
_result
IPCServerState
:
:
ClientDisconnected
)
=
>
{
return
0
;
}
Err
(
error
)
=
>
{
log
:
:
error
!
(
"
The
crashhelper
encountered
an
error
exiting
(
error
:
{
error
}
)
"
)
;
return
-
1
;
}
_
=
>
{
}
}
}
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
daemonize
(
)
{
#
[
cfg
(
not
(
target_os
=
"
windows
"
)
)
]
{
use
nix
:
:
unistd
:
:
{
fork
setsid
ForkResult
}
;
let
_
=
setsid
(
)
;
let
res
=
unsafe
{
fork
(
)
}
;
let
Ok
(
res
)
=
res
else
{
return
;
}
;
match
res
{
ForkResult
:
:
Child
=
>
{
}
ForkResult
:
:
Parent
{
child
:
_
}
=
>
unsafe
{
nix
:
:
libc
:
:
_exit
(
0
)
;
}
}
}
}
fn
unwrap_with_message
<
T
E
:
Display
>
(
res
:
Result
<
T
E
>
error_string
:
&
str
)
-
>
T
{
match
res
{
Ok
(
value
)
=
>
value
Err
(
error
)
=
>
{
log
:
:
error
!
(
"
{
error_string
}
(
error
:
{
error
}
)
"
)
;
panic
!
(
"
{
}
(
error
:
{
}
)
"
error_string
error
)
;
}
}
}
