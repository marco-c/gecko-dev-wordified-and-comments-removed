#
include
"
ThreadAnnotation
.
h
"
#
include
<
stddef
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
prthread
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
using
mozilla
:
:
StaticMutex
;
using
mozilla
:
:
StaticMutexAutoLock
;
using
mozilla
:
:
UniquePtr
;
namespace
CrashReporter
{
namespace
{
#
ifdef
XP_MACOSX
class
MacCrashReporterLock
{
public
:
void
Lock
(
)
{
sInnerMutex
.
Lock
(
)
;
sIsLocked
=
true
;
}
void
Unlock
(
)
{
sIsLocked
=
false
;
sInnerMutex
.
Unlock
(
)
;
}
bool
IsLocked
(
)
{
return
sIsLocked
;
}
void
AssertCurrentThreadOwns
(
)
{
sInnerMutex
.
AssertCurrentThreadOwns
(
)
;
}
private
:
static
StaticMutex
sInnerMutex
;
static
bool
sIsLocked
;
}
;
StaticMutex
MacCrashReporterLock
:
:
sInnerMutex
;
bool
MacCrashReporterLock
:
:
sIsLocked
;
typedef
mozilla
:
:
detail
:
:
BaseAutoLock
<
MacCrashReporterLock
&
>
CrashReporterAutoLock
;
typedef
MacCrashReporterLock
CrashReporterLockType
;
#
else
typedef
StaticMutexAutoLock
CrashReporterAutoLock
;
typedef
StaticMutex
CrashReporterLockType
;
#
endif
static
CrashReporterLockType
sMutex
;
class
ThreadAnnotationSpan
{
public
:
ThreadAnnotationSpan
(
uint32_t
aBegin
uint32_t
aEnd
)
:
mBegin
(
aBegin
)
mEnd
(
aEnd
)
{
MOZ_ASSERT
(
mBegin
<
mEnd
)
;
}
~
ThreadAnnotationSpan
(
)
;
class
Comparator
{
public
:
bool
Equals
(
const
ThreadAnnotationSpan
*
const
&
a
const
ThreadAnnotationSpan
*
const
&
b
)
const
{
return
a
-
>
mBegin
=
=
b
-
>
mBegin
;
}
bool
LessThan
(
const
ThreadAnnotationSpan
*
const
&
a
const
ThreadAnnotationSpan
*
const
&
b
)
const
{
return
a
-
>
mBegin
<
b
-
>
mBegin
;
}
}
;
private
:
ThreadAnnotationSpan
(
const
ThreadAnnotationSpan
&
aOther
)
=
delete
;
ThreadAnnotationSpan
&
operator
=
(
const
ThreadAnnotationSpan
&
aOther
)
=
delete
;
friend
class
ThreadAnnotationData
;
friend
class
Comparator
;
uint32_t
mBegin
;
uint32_t
mEnd
;
}
;
class
ThreadAnnotationData
{
public
:
ThreadAnnotationData
(
)
=
default
;
~
ThreadAnnotationData
(
)
=
default
;
ThreadAnnotationSpan
*
AddThreadAnnotation
(
ThreadId
aTid
const
char
*
aThreadName
)
{
if
(
!
aTid
|
|
!
aThreadName
)
{
return
nullptr
;
}
uint32_t
oldLength
=
mData
.
Length
(
)
;
mData
.
AppendPrintf
(
"
%
u
:
\
"
%
s
\
"
"
aTid
aThreadName
)
;
uint32_t
newLength
=
mData
.
Length
(
)
;
ThreadAnnotationSpan
*
rv
=
new
ThreadAnnotationSpan
(
oldLength
newLength
)
;
mDataSpans
.
AppendElement
(
rv
)
;
return
rv
;
}
void
EraseThreadAnnotation
(
const
ThreadAnnotationSpan
&
aThreadInfo
)
{
uint32_t
begin
=
aThreadInfo
.
mBegin
;
uint32_t
end
=
aThreadInfo
.
mEnd
;
if
(
!
(
begin
<
end
&
&
end
<
=
mData
.
Length
(
)
)
)
{
return
;
}
uint32_t
cutLength
=
end
-
begin
;
mData
.
Cut
(
begin
cutLength
)
;
size_t
index
=
mDataSpans
.
BinaryIndexOf
(
&
aThreadInfo
ThreadAnnotationSpan
:
:
Comparator
(
)
)
;
for
(
size_t
i
=
index
+
1
;
i
<
mDataSpans
.
Length
(
)
;
i
+
+
)
{
ThreadAnnotationSpan
*
elem
=
mDataSpans
[
i
]
;
MOZ_ASSERT
(
elem
-
>
mBegin
>
=
cutLength
)
;
MOZ_ASSERT
(
elem
-
>
mEnd
>
cutLength
)
;
elem
-
>
mBegin
-
=
cutLength
;
elem
-
>
mEnd
-
=
cutLength
;
}
mDataSpans
.
RemoveElementAt
(
index
)
;
}
void
GetData
(
const
std
:
:
function
<
void
(
const
char
*
)
>
&
aCallback
)
{
aCallback
(
mData
.
BeginReading
(
)
)
;
}
private
:
nsCString
mData
;
nsTArray
<
ThreadAnnotationSpan
*
>
mDataSpans
;
}
;
static
bool
sInitialized
=
false
;
static
UniquePtr
<
ThreadAnnotationData
>
sThreadAnnotations
;
static
unsigned
sTLSThreadInfoKey
=
(
unsigned
)
-
1
;
void
ThreadLocalDestructor
(
void
*
aUserData
)
{
MOZ_ASSERT
(
aUserData
)
;
CrashReporterAutoLock
lock
(
sMutex
)
;
ThreadAnnotationSpan
*
aThreadInfo
=
static_cast
<
ThreadAnnotationSpan
*
>
(
aUserData
)
;
delete
aThreadInfo
;
}
ThreadAnnotationSpan
:
:
~
ThreadAnnotationSpan
(
)
{
sMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
sThreadAnnotations
)
{
sThreadAnnotations
-
>
EraseThreadAnnotation
(
*
this
)
;
}
}
}
void
InitThreadAnnotation
(
)
{
CrashReporterAutoLock
lock
(
sMutex
)
;
if
(
sInitialized
)
{
return
;
}
PRStatus
status
=
PR_NewThreadPrivateIndex
(
&
sTLSThreadInfoKey
&
ThreadLocalDestructor
)
;
if
(
status
=
=
PR_FAILURE
)
{
return
;
}
sInitialized
=
true
;
sThreadAnnotations
=
mozilla
:
:
MakeUnique
<
ThreadAnnotationData
>
(
)
;
}
void
SetCurrentThreadName
(
const
char
*
aName
)
{
if
(
PR_GetThreadPrivate
(
sTLSThreadInfoKey
)
)
{
PR_SetThreadPrivate
(
sTLSThreadInfoKey
nullptr
)
;
}
CrashReporterAutoLock
lock
(
sMutex
)
;
if
(
!
sInitialized
)
{
return
;
}
ThreadAnnotationSpan
*
threadInfo
=
sThreadAnnotations
-
>
AddThreadAnnotation
(
CurrentThreadId
(
)
aName
)
;
PR_SetThreadPrivate
(
sTLSThreadInfoKey
threadInfo
)
;
}
void
GetFlatThreadAnnotation
(
const
std
:
:
function
<
void
(
const
char
*
)
>
&
aCallback
bool
aIsHandlingException
)
{
bool
lockNeeded
=
true
;
#
ifdef
XP_MACOSX
if
(
aIsHandlingException
)
{
if
(
sMutex
.
IsLocked
(
)
)
{
aCallback
(
"
"
)
;
return
;
}
lockNeeded
=
false
;
}
#
endif
if
(
lockNeeded
)
{
sMutex
.
Lock
(
)
;
}
if
(
sThreadAnnotations
)
{
sThreadAnnotations
-
>
GetData
(
aCallback
)
;
}
else
{
aCallback
(
"
"
)
;
}
if
(
lockNeeded
)
{
sMutex
.
Unlock
(
)
;
}
}
void
ShutdownThreadAnnotation
(
)
{
CrashReporterAutoLock
lock
(
sMutex
)
;
sInitialized
=
false
;
sThreadAnnotations
.
reset
(
)
;
}
}
