use
{
anyhow
:
:
Context
libc
:
:
pid_t
minidump_writer
:
:
{
crash_context
:
:
CrashContext
minidump_writer
:
:
{
DirectAuxvDumpInfo
as
InternalDumpInfo
MinidumpWriter
}
}
std
:
:
{
convert
:
:
TryInto
ffi
:
:
{
c_char
CStr
CString
}
fs
:
:
File
}
}
;
#
[
allow
(
non_camel_case_types
)
]
#
[
cfg
(
not
(
target_arch
=
"
arm
"
)
)
]
type
fpregset_t
=
crash_context
:
:
fpregset_t
;
#
[
allow
(
non_camel_case_types
)
]
#
[
cfg
(
target_arch
=
"
arm
"
)
]
type
fpregset_t
=
u8
;
pub
struct
MinidumpWriterContext
{
dump_file
:
File
writer
:
MinidumpWriter
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
)
]
pub
struct
DirectAuxvDumpInfo
{
pub
program_header_count
:
usize
pub
program_header_address
:
usize
pub
linux_gate_address
:
usize
pub
entry_address
:
usize
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
minidump_writer_create
(
dump_path
:
*
const
c_char
child
:
pid_t
child_blamed_thread
:
pid_t
error_msg
:
*
mut
*
mut
c_char
)
-
>
Option
<
Box
<
MinidumpWriterContext
>
>
{
err_to_error_msg
(
error_msg
|
|
{
let
dump_path
=
CStr
:
:
from_ptr
(
dump_path
)
.
to_str
(
)
.
context
(
"
path
not
valid
UTF
-
8
"
)
?
;
let
dump_file
=
std
:
:
fs
:
:
OpenOptions
:
:
new
(
)
.
create
(
true
)
.
truncate
(
true
)
.
write
(
true
)
.
open
(
dump_path
)
.
context
(
"
failed
to
open
minidump
file
"
)
?
;
let
writer
=
MinidumpWriter
:
:
new
(
child
child_blamed_thread
)
;
Ok
(
Box
:
:
new
(
MinidumpWriterContext
{
dump_file
writer
}
)
)
}
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
minidump_writer_set_crash_context
(
context
:
&
mut
MinidumpWriterContext
ucontext
:
&
crash_context
:
:
ucontext_t
float_state
:
Option
<
&
fpregset_t
>
siginfo
:
Option
<
&
libc
:
:
signalfd_siginfo
>
)
{
#
[
cfg
(
not
(
target_arch
=
"
arm
"
)
)
]
let
float_state
=
float_state
.
unwrap
(
)
.
clone
(
)
;
#
[
cfg
(
target_arch
=
"
arm
"
)
]
assert
!
(
float_state
.
is_none
(
)
)
;
context
.
writer
.
set_crash_context
(
CrashContext
{
inner
:
crash_context
:
:
CrashContext
{
context
:
ucontext
.
clone
(
)
#
[
cfg
(
not
(
target_arch
=
"
arm
"
)
)
]
float_state
siginfo
:
siginfo
.
cloned
(
)
.
unwrap_or_else
(
|
|
unsafe
{
std
:
:
mem
:
:
zeroed
(
)
}
)
pid
:
context
.
writer
.
process_id
tid
:
context
.
writer
.
blamed_thread
}
}
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
minidump_writer_set_direct_auxv_dump_info
(
context
:
&
mut
MinidumpWriterContext
direct_auxv_dump_info
:
&
DirectAuxvDumpInfo
)
{
context
.
writer
.
set_direct_auxv_dump_info
(
InternalDumpInfo
{
program_header_count
:
direct_auxv_dump_info
.
program_header_count
.
try_into
(
)
.
unwrap
(
)
program_header_address
:
direct_auxv_dump_info
.
program_header_address
.
try_into
(
)
.
unwrap
(
)
linux_gate_address
:
direct_auxv_dump_info
.
linux_gate_address
.
try_into
(
)
.
unwrap
(
)
entry_address
:
direct_auxv_dump_info
.
entry_address
.
try_into
(
)
.
unwrap
(
)
}
)
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
minidump_writer_dump
(
mut
context
:
Box
<
MinidumpWriterContext
>
error_msg
:
*
mut
*
mut
c_char
)
-
>
bool
{
err_to_error_msg
(
error_msg
|
|
{
context
.
writer
.
dump
(
&
mut
context
.
dump_file
)
.
context
(
"
failed
to
write
dump
file
"
)
}
)
.
is_some
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
free_minidump_error_msg
(
error_msg
:
*
mut
c_char
)
{
let
_error_msg
=
CString
:
:
from_raw
(
error_msg
)
;
}
unsafe
fn
err_to_error_msg
<
F
T
>
(
error_msg
:
*
mut
*
mut
c_char
f
:
F
)
-
>
Option
<
T
>
where
F
:
FnOnce
(
)
-
>
anyhow
:
:
Result
<
T
>
{
match
f
(
)
{
Ok
(
t
)
=
>
Some
(
t
)
Err
(
e
)
=
>
{
if
!
error_msg
.
is_null
(
)
{
*
error_msg
=
CString
:
:
new
(
format
!
(
"
{
e
:
#
?
}
"
)
)
.
unwrap
(
)
.
into_raw
(
)
;
}
None
}
}
}
