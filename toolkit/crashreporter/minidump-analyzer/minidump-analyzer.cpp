#
include
<
cstdio
>
#
include
<
cstring
>
#
include
<
fstream
>
#
include
<
string
>
#
include
<
sstream
>
#
include
"
json
/
json
.
h
"
#
include
"
google_breakpad
/
processor
/
basic_source_line_resolver
.
h
"
#
include
"
google_breakpad
/
processor
/
call_stack
.
h
"
#
include
"
google_breakpad
/
processor
/
code_module
.
h
"
#
include
"
google_breakpad
/
processor
/
code_modules
.
h
"
#
include
"
google_breakpad
/
processor
/
minidump
.
h
"
#
include
"
google_breakpad
/
processor
/
minidump_processor
.
h
"
#
include
"
google_breakpad
/
processor
/
process_state
.
h
"
#
include
"
google_breakpad
/
processor
/
stack_frame
.
h
"
#
include
"
processor
/
pathname_stripper
.
h
"
#
if
defined
(
XP_WIN32
)
#
include
<
windows
.
h
>
#
elif
defined
(
XP_UNIX
)
|
|
defined
(
XP_MACOSX
)
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
endif
static
string
gMinidumpPath
;
static
bool
gFullMinidump
=
false
;
namespace
CrashReporter
{
using
std
:
:
ios
;
using
std
:
:
ios_base
;
using
std
:
:
hex
;
using
std
:
:
ofstream
;
using
std
:
:
map
;
using
std
:
:
showbase
;
using
std
:
:
string
;
using
std
:
:
stringstream
;
using
std
:
:
wstring
;
using
google_breakpad
:
:
BasicSourceLineResolver
;
using
google_breakpad
:
:
CallStack
;
using
google_breakpad
:
:
CodeModule
;
using
google_breakpad
:
:
CodeModules
;
using
google_breakpad
:
:
Minidump
;
using
google_breakpad
:
:
MinidumpProcessor
;
using
google_breakpad
:
:
PathnameStripper
;
using
google_breakpad
:
:
ProcessResult
;
using
google_breakpad
:
:
ProcessState
;
using
google_breakpad
:
:
StackFrame
;
#
ifdef
XP_WIN
static
wstring
UTF8ToWide
(
const
string
&
aUtf8Str
bool
*
aSuccess
=
nullptr
)
{
wchar_t
*
buffer
=
nullptr
;
int
buffer_size
=
MultiByteToWideChar
(
CP_UTF8
0
aUtf8Str
.
c_str
(
)
-
1
nullptr
0
)
;
if
(
buffer_size
=
=
0
)
{
if
(
aSuccess
)
{
*
aSuccess
=
false
;
}
return
L
"
"
;
}
buffer
=
new
wchar_t
[
buffer_size
]
;
if
(
buffer
=
=
nullptr
)
{
if
(
aSuccess
)
{
*
aSuccess
=
false
;
}
return
L
"
"
;
}
MultiByteToWideChar
(
CP_UTF8
0
aUtf8Str
.
c_str
(
)
-
1
buffer
buffer_size
)
;
wstring
str
=
buffer
;
delete
[
]
buffer
;
if
(
aSuccess
)
{
*
aSuccess
=
true
;
}
return
str
;
}
#
endif
struct
ModuleCompare
{
bool
operator
(
)
(
const
CodeModule
*
aLhs
const
CodeModule
*
aRhs
)
const
{
return
aLhs
-
>
base_address
(
)
<
aRhs
-
>
base_address
(
)
;
}
}
;
typedef
map
<
const
CodeModule
*
unsigned
int
ModuleCompare
>
OrderedModulesMap
;
static
const
char
kExtraDataExtension
[
]
=
"
.
extra
"
;
static
string
ToHex
(
uint64_t
aValue
)
{
stringstream
output
;
output
<
<
hex
<
<
showbase
<
<
aValue
;
return
output
.
str
(
)
;
}
static
string
FrameTrust
(
const
StackFrame
:
:
FrameTrust
aTrust
)
{
switch
(
aTrust
)
{
case
StackFrame
:
:
FRAME_TRUST_NONE
:
return
"
none
"
;
case
StackFrame
:
:
FRAME_TRUST_SCAN
:
return
"
scan
"
;
case
StackFrame
:
:
FRAME_TRUST_CFI_SCAN
:
return
"
cfi_scan
"
;
case
StackFrame
:
:
FRAME_TRUST_FP
:
return
"
frame_pointer
"
;
case
StackFrame
:
:
FRAME_TRUST_CFI
:
return
"
cfi
"
;
case
StackFrame
:
:
FRAME_TRUST_PREWALKED
:
return
"
prewalked
"
;
case
StackFrame
:
:
FRAME_TRUST_CONTEXT
:
return
"
context
"
;
}
return
"
none
"
;
}
static
string
ResultString
(
ProcessResult
aResult
)
{
switch
(
aResult
)
{
case
google_breakpad
:
:
PROCESS_OK
:
return
"
OK
"
;
case
google_breakpad
:
:
PROCESS_ERROR_MINIDUMP_NOT_FOUND
:
return
"
ERROR_MINIDUMP_NOT_FOUND
"
;
case
google_breakpad
:
:
PROCESS_ERROR_NO_MINIDUMP_HEADER
:
return
"
ERROR_NO_MINIDUMP_HEADER
"
;
case
google_breakpad
:
:
PROCESS_ERROR_NO_THREAD_LIST
:
return
"
ERROR_NO_THREAD_LIST
"
;
case
google_breakpad
:
:
PROCESS_ERROR_GETTING_THREAD
:
return
"
ERROR_GETTING_THREAD
"
;
case
google_breakpad
:
:
PROCESS_ERROR_GETTING_THREAD_ID
:
return
"
ERROR_GETTING_THREAD_ID
"
;
case
google_breakpad
:
:
PROCESS_ERROR_DUPLICATE_REQUESTING_THREADS
:
return
"
ERROR_DUPLICATE_REQUESTING_THREADS
"
;
case
google_breakpad
:
:
PROCESS_SYMBOL_SUPPLIER_INTERRUPTED
:
return
"
SYMBOL_SUPPLIER_INTERRUPTED
"
;
default
:
return
"
"
;
}
}
static
void
ConvertStackToJSON
(
const
ProcessState
&
aProcessState
const
OrderedModulesMap
&
aOrderedModules
const
CallStack
*
aStack
Json
:
:
Value
&
aNode
)
{
int
frameCount
=
aStack
-
>
frames
(
)
-
>
size
(
)
;
unsigned
int
moduleIndex
=
0
;
for
(
int
frameIndex
=
0
;
frameIndex
<
frameCount
;
+
+
frameIndex
)
{
const
StackFrame
*
frame
=
aStack
-
>
frames
(
)
-
>
at
(
frameIndex
)
;
Json
:
:
Value
frameNode
;
if
(
frame
-
>
module
)
{
auto
itr
=
aOrderedModules
.
find
(
frame
-
>
module
)
;
if
(
itr
!
=
aOrderedModules
.
end
(
)
)
{
moduleIndex
=
(
*
itr
)
.
second
;
frameNode
[
"
module_index
"
]
=
moduleIndex
;
}
}
frameNode
[
"
trust
"
]
=
FrameTrust
(
frame
-
>
trust
)
;
frameNode
[
"
ip
"
]
=
ToHex
(
frame
-
>
instruction
)
;
aNode
.
append
(
frameNode
)
;
}
}
static
int
ConvertModulesToJSON
(
const
ProcessState
&
aProcessState
OrderedModulesMap
&
aOrderedModules
Json
:
:
Value
&
aNode
)
{
const
CodeModules
*
modules
=
aProcessState
.
modules
(
)
;
if
(
!
modules
)
{
return
-
1
;
}
for
(
unsigned
int
i
=
0
;
i
<
modules
-
>
module_count
(
)
;
+
+
i
)
{
aOrderedModules
.
insert
(
std
:
:
pair
<
const
CodeModule
*
unsigned
int
>
(
modules
-
>
GetModuleAtSequence
(
i
)
i
)
)
;
}
uint64_t
mainAddress
=
0
;
const
CodeModule
*
mainModule
=
modules
-
>
GetMainModule
(
)
;
if
(
mainModule
)
{
mainAddress
=
mainModule
-
>
base_address
(
)
;
}
unsigned
int
moduleCount
=
modules
-
>
module_count
(
)
;
int
mainModuleIndex
=
-
1
;
for
(
unsigned
int
moduleSequence
=
0
;
moduleSequence
<
moduleCount
;
+
+
moduleSequence
)
{
const
CodeModule
*
module
=
modules
-
>
GetModuleAtSequence
(
moduleSequence
)
;
if
(
module
-
>
base_address
(
)
=
=
mainAddress
)
{
mainModuleIndex
=
moduleSequence
;
}
Json
:
:
Value
moduleNode
;
moduleNode
[
"
filename
"
]
=
PathnameStripper
:
:
File
(
module
-
>
code_file
(
)
)
;
moduleNode
[
"
code_id
"
]
=
PathnameStripper
:
:
File
(
module
-
>
code_identifier
(
)
)
;
moduleNode
[
"
version
"
]
=
module
-
>
version
(
)
;
moduleNode
[
"
debug_file
"
]
=
PathnameStripper
:
:
File
(
module
-
>
debug_file
(
)
)
;
moduleNode
[
"
debug_id
"
]
=
module
-
>
debug_identifier
(
)
;
moduleNode
[
"
base_addr
"
]
=
ToHex
(
module
-
>
base_address
(
)
)
;
moduleNode
[
"
end_addr
"
]
=
ToHex
(
module
-
>
base_address
(
)
+
module
-
>
size
(
)
)
;
aNode
.
append
(
moduleNode
)
;
}
return
mainModuleIndex
;
}
static
void
ConvertProcessStateToJSON
(
const
ProcessState
&
aProcessState
Json
:
:
Value
&
aRoot
)
{
OrderedModulesMap
orderedModules
;
Json
:
:
Value
crashInfo
;
int
requestingThread
=
aProcessState
.
requesting_thread
(
)
;
if
(
aProcessState
.
crashed
(
)
)
{
crashInfo
[
"
type
"
]
=
aProcessState
.
crash_reason
(
)
;
crashInfo
[
"
address
"
]
=
ToHex
(
aProcessState
.
crash_address
(
)
)
;
if
(
requestingThread
!
=
-
1
)
{
crashInfo
[
"
crashing_thread
"
]
=
gFullMinidump
?
requestingThread
:
0
;
}
}
else
{
crashInfo
[
"
type
"
]
=
Json
:
:
Value
(
Json
:
:
nullValue
)
;
string
assertion
=
aProcessState
.
assertion
(
)
;
if
(
!
assertion
.
empty
(
)
)
{
crashInfo
[
"
assertion
"
]
=
assertion
;
}
}
aRoot
[
"
crash_info
"
]
=
crashInfo
;
Json
:
:
Value
modules
(
Json
:
:
arrayValue
)
;
int
mainModule
=
ConvertModulesToJSON
(
aProcessState
orderedModules
modules
)
;
if
(
mainModule
!
=
-
1
)
{
aRoot
[
"
main_module
"
]
=
mainModule
;
}
aRoot
[
"
modules
"
]
=
modules
;
Json
:
:
Value
threads
(
Json
:
:
arrayValue
)
;
int
threadCount
=
aProcessState
.
threads
(
)
-
>
size
(
)
;
if
(
!
gFullMinidump
&
&
(
requestingThread
!
=
-
1
)
)
{
Json
:
:
Value
thread
;
Json
:
:
Value
stack
(
Json
:
:
arrayValue
)
;
const
CallStack
*
rawStack
=
aProcessState
.
threads
(
)
-
>
at
(
requestingThread
)
;
ConvertStackToJSON
(
aProcessState
orderedModules
rawStack
stack
)
;
thread
[
"
frames
"
]
=
stack
;
threads
.
append
(
thread
)
;
}
else
{
for
(
int
threadIndex
=
0
;
threadIndex
<
threadCount
;
+
+
threadIndex
)
{
Json
:
:
Value
thread
;
Json
:
:
Value
stack
(
Json
:
:
arrayValue
)
;
const
CallStack
*
rawStack
=
aProcessState
.
threads
(
)
-
>
at
(
threadIndex
)
;
ConvertStackToJSON
(
aProcessState
orderedModules
rawStack
stack
)
;
thread
[
"
frames
"
]
=
stack
;
threads
.
append
(
thread
)
;
}
}
aRoot
[
"
threads
"
]
=
threads
;
}
static
bool
ProcessMinidump
(
Json
:
:
Value
&
aRoot
const
string
&
aDumpFile
)
{
BasicSourceLineResolver
resolver
;
MinidumpProcessor
minidumpProcessor
(
nullptr
&
resolver
)
;
Minidump
dump
(
aDumpFile
)
;
if
(
!
dump
.
Read
(
)
)
{
return
false
;
}
ProcessResult
rv
;
ProcessState
processState
;
rv
=
minidumpProcessor
.
Process
(
&
dump
&
processState
)
;
aRoot
[
"
status
"
]
=
ResultString
(
rv
)
;
ConvertProcessStateToJSON
(
processState
aRoot
)
;
return
true
;
}
static
ofstream
*
OpenAppend
(
const
string
&
aFilename
)
{
ios_base
:
:
openmode
mode
=
ios
:
:
out
|
ios
:
:
app
;
#
if
defined
(
XP_WIN
)
#
if
defined
(
_MSC_VER
)
ofstream
*
file
=
new
ofstream
(
)
;
file
-
>
open
(
UTF8ToWide
(
aFilename
)
.
c_str
(
)
mode
)
;
#
else
ofstream
*
file
=
new
ofstream
(
WideToMBCP
(
UTF8ToWide
(
aFilename
)
CP_ACP
)
.
c_str
(
)
mode
)
;
#
endif
#
else
ofstream
*
file
=
new
ofstream
(
aFilename
.
c_str
(
)
mode
)
;
#
endif
return
file
;
}
static
bool
FileExists
(
const
string
&
aPath
)
{
#
if
defined
(
XP_WIN
)
DWORD
attrs
=
GetFileAttributes
(
UTF8ToWide
(
aPath
)
.
c_str
(
)
)
;
return
(
attrs
!
=
INVALID_FILE_ATTRIBUTES
)
;
#
else
struct
stat
sb
;
int
ret
=
stat
(
aPath
.
c_str
(
)
&
sb
)
;
if
(
ret
=
=
-
1
|
|
!
(
sb
.
st_mode
&
S_IFREG
)
)
{
return
false
;
}
return
true
;
#
endif
}
static
void
UpdateExtraDataFile
(
const
string
&
aDumpPath
const
Json
:
:
Value
&
aRoot
)
{
string
extraDataPath
(
aDumpPath
)
;
int
dot
=
extraDataPath
.
rfind
(
'
.
'
)
;
if
(
dot
<
0
)
{
return
;
}
extraDataPath
.
replace
(
dot
extraDataPath
.
length
(
)
-
dot
kExtraDataExtension
)
;
ofstream
*
f
=
OpenAppend
(
extraDataPath
.
c_str
(
)
)
;
if
(
f
-
>
is_open
(
)
)
{
Json
:
:
FastWriter
writer
;
*
f
<
<
"
StackTraces
=
"
<
<
writer
.
write
(
aRoot
)
;
f
-
>
close
(
)
;
}
delete
f
;
}
}
using
namespace
CrashReporter
;
static
void
ParseArguments
(
int
argc
char
*
*
argv
)
{
if
(
argc
<
=
1
)
{
exit
(
EXIT_FAILURE
)
;
}
for
(
int
i
=
1
;
i
<
argc
-
1
;
i
+
+
)
{
if
(
strcmp
(
argv
[
i
]
"
-
-
full
"
)
=
=
0
)
{
gFullMinidump
=
true
;
}
else
{
exit
(
EXIT_FAILURE
)
;
}
}
gMinidumpPath
=
argv
[
argc
-
1
]
;
}
int
main
(
int
argc
char
*
*
argv
)
{
ParseArguments
(
argc
argv
)
;
if
(
!
FileExists
(
gMinidumpPath
)
)
{
exit
(
EXIT_FAILURE
)
;
}
Json
:
:
Value
root
;
if
(
ProcessMinidump
(
root
gMinidumpPath
)
)
{
UpdateExtraDataFile
(
gMinidumpPath
root
)
;
}
exit
(
EXIT_SUCCESS
)
;
}
