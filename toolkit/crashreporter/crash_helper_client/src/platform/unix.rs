use
anyhow
:
:
Result
;
use
std
:
:
{
ffi
:
:
c_char
process
}
;
use
crate
:
:
CrashHelperClient
;
use
crash_helper_common
:
:
{
IPCConnector
Pid
}
;
impl
CrashHelperClient
{
pub
(
crate
)
fn
new
(
program
:
*
const
c_char
user_app_data_dir
:
*
const
c_char
)
-
>
Result
<
CrashHelperClient
>
{
let
pid
=
CrashHelperClient
:
:
spawn_crash_helper
(
program
user_app_data_dir
)
?
;
let
connector
=
IPCConnector
:
:
connect
(
process
:
:
id
(
)
as
Pid
)
?
;
Ok
(
CrashHelperClient
{
connector
pid
}
)
}
#
[
allow
(
unused_variables
)
]
fn
spawn_crash_helper
(
program
:
*
const
c_char
user_app_data_dir
:
*
const
c_char
)
-
>
Result
<
nix
:
:
libc
:
:
pid_t
>
{
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
macos
"
)
)
]
{
use
nix
:
:
unistd
:
:
{
execv
fork
getpid
ForkResult
}
;
use
std
:
:
ffi
:
:
{
CStr
CString
}
;
let
parent_pid
=
getpid
(
)
.
to_string
(
)
;
let
parent_pid_arg
=
unsafe
{
CString
:
:
from_vec_unchecked
(
parent_pid
.
into_bytes
(
)
)
}
;
let
pid
=
unsafe
{
fork
(
)
}
?
;
match
pid
{
ForkResult
:
:
Child
=
>
{
let
program
=
unsafe
{
CStr
:
:
from_ptr
(
program
)
}
;
let
user_app_data_dir
=
unsafe
{
CStr
:
:
from_ptr
(
user_app_data_dir
)
}
;
let
_
=
execv
(
program
&
[
program
&
parent_pid_arg
user_app_data_dir
]
)
;
unsafe
{
nix
:
:
libc
:
:
_exit
(
1
)
}
;
}
ForkResult
:
:
Parent
{
child
}
=
>
Ok
(
child
.
as_raw
(
)
)
}
}
#
[
cfg
(
target_os
=
"
android
"
)
]
Ok
(
0
)
}
}
