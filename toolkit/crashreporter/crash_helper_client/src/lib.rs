use
anyhow
:
:
{
bail
Result
}
;
use
crash_helper_common
:
:
{
messages
:
:
{
self
}
AncillaryData
BreakpadString
IPCClientChannel
IPCConnector
ProcessHandle
INVALID_ANCILLARY_DATA
}
;
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
use
minidump_writer
:
:
minidump_writer
:
:
{
AuxvType
DirectAuxvDumpInfo
}
;
#
[
cfg
(
target_os
=
"
android
"
)
]
use
std
:
:
os
:
:
fd
:
:
RawFd
;
use
std
:
:
{
ffi
:
:
{
c_char
CString
OsString
}
hint
:
:
spin_loop
ptr
:
:
null_mut
sync
:
:
{
atomic
:
:
{
AtomicBool
Ordering
}
OnceLock
}
thread
:
:
{
self
JoinHandle
}
}
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
use
windows_sys
:
:
Win32
:
:
System
:
:
Diagnostics
:
:
Debug
:
:
{
CONTEXT
EXCEPTION_RECORD
}
;
extern
crate
num_traits
;
pub
use
crash_helper_common
:
:
{
BreakpadChar
BreakpadRawData
Pid
}
;
mod
platform
;
pub
struct
CrashHelperClient
{
connector
:
IPCConnector
spawner_thread
:
Option
<
JoinHandle
<
Result
<
ProcessHandle
>
>
>
helper_process
:
Option
<
ProcessHandle
>
}
impl
CrashHelperClient
{
fn
set_crash_report_path
(
&
mut
self
path
:
OsString
)
-
>
Result
<
(
)
>
{
let
message
=
messages
:
:
SetCrashReportPath
:
:
new
(
path
)
;
self
.
connector
.
send_message
(
&
message
)
?
;
Ok
(
(
)
)
}
fn
register_child_process
(
&
mut
self
)
-
>
Result
<
AncillaryData
>
{
let
ipc_channel
=
IPCClientChannel
:
:
new
(
)
?
;
let
(
server_endpoint
client_endpoint
)
=
ipc_channel
.
deconstruct
(
)
;
if
let
Some
(
join_handle
)
=
self
.
spawner_thread
.
take
(
)
{
let
Ok
(
process_handle
)
=
join_handle
.
join
(
)
else
{
bail
!
(
"
The
spawner
thread
failed
to
execute
"
)
;
}
;
let
Ok
(
process_handle
)
=
process_handle
else
{
bail
!
(
"
The
crash
helper
process
failed
to
launch
"
)
;
}
;
self
.
helper_process
=
Some
(
process_handle
)
;
}
if
self
.
helper_process
.
is_none
(
)
{
bail
!
(
"
The
crash
helper
process
is
not
available
"
)
;
}
;
let
Ok
(
ancillary_data
)
=
server_endpoint
.
into_ancillary
(
&
self
.
helper_process
)
else
{
bail
!
(
"
Could
not
convert
the
server
IPC
endpoint
"
)
;
}
;
let
message
=
messages
:
:
RegisterChildProcess
:
:
new
(
ancillary_data
)
;
self
.
connector
.
send_message
(
&
message
)
?
;
let
Ok
(
ancillary_data
)
=
client_endpoint
.
into_ancillary
(
&
None
)
else
{
bail
!
(
"
Could
not
convert
the
local
IPC
endpoint
"
)
;
}
;
Ok
(
ancillary_data
)
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
register_auxv_info
(
&
mut
self
pid
:
Pid
auxv_info
:
DirectAuxvDumpInfo
)
-
>
Result
<
(
)
>
{
let
message
=
messages
:
:
RegisterAuxvInfo
:
:
new
(
pid
auxv_info
)
;
self
.
connector
.
send_message
(
&
message
)
?
;
Ok
(
(
)
)
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
fn
unregister_auxv_info
(
&
mut
self
pid
:
Pid
)
-
>
Result
<
(
)
>
{
let
message
=
messages
:
:
UnregisterAuxvInfo
:
:
new
(
pid
)
;
self
.
connector
.
send_message
(
&
message
)
?
;
Ok
(
(
)
)
}
fn
transfer_crash_report
(
&
mut
self
pid
:
Pid
)
-
>
Result
<
CrashReport
>
{
let
message
=
messages
:
:
TransferMinidump
:
:
new
(
pid
)
;
self
.
connector
.
send_message
(
&
message
)
?
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
self
.
connector
.
poll
(
nix
:
:
poll
:
:
PollFlags
:
:
POLLIN
)
?
;
let
reply
=
self
.
connector
.
recv_reply
:
:
<
messages
:
:
TransferMinidumpReply
>
(
)
?
;
if
reply
.
path
.
is_empty
(
)
{
bail
!
(
"
Minidump
for
pid
{
pid
:
}
was
not
found
"
)
;
}
Ok
(
CrashReport
{
path
:
reply
.
path
.
into_raw
(
)
error
:
reply
.
error
.
map_or
(
null_mut
(
)
|
error
|
error
.
into_raw
(
)
)
}
)
}
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_helper_launch
(
helper_name
:
*
const
BreakpadChar
breakpad_raw_data
:
BreakpadRawData
minidump_path
:
*
const
BreakpadChar
)
-
>
*
mut
CrashHelperClient
{
use
crash_helper_common
:
:
BreakpadData
;
let
breakpad_data
=
BreakpadData
:
:
new
(
breakpad_raw_data
)
;
if
let
Ok
(
crash_helper
)
=
CrashHelperClient
:
:
new
(
helper_name
breakpad_data
minidump_path
)
{
let
crash_helper_box
=
Box
:
:
new
(
crash_helper
)
;
Box
:
:
into_raw
(
crash_helper_box
)
}
else
{
null_mut
(
)
}
}
#
[
cfg
(
target_os
=
"
android
"
)
]
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_helper_connect
(
client_socket
:
RawFd
)
-
>
*
mut
CrashHelperClient
{
if
let
Ok
(
crash_helper
)
=
CrashHelperClient
:
:
new
(
client_socket
)
{
let
crash_helper_box
=
Box
:
:
new
(
crash_helper
)
;
Box
:
:
into_raw
(
crash_helper_box
)
}
else
{
null_mut
(
)
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_helper_shutdown
(
client
:
*
mut
CrashHelperClient
)
{
let
_crash_helper_box
=
Box
:
:
from_raw
(
client
)
;
}
#
[
repr
(
C
)
]
pub
struct
CrashReport
{
path
:
*
mut
BreakpadChar
error
:
*
mut
c_char
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
set_crash_report_path
(
client
:
*
mut
CrashHelperClient
path
:
*
const
BreakpadChar
)
-
>
bool
{
let
client
=
client
.
as_mut
(
)
.
unwrap
(
)
;
let
path
=
<
OsString
as
BreakpadString
>
:
:
from_ptr
(
path
)
;
client
.
set_crash_report_path
(
path
)
.
is_ok
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
register_child_ipc_channel
(
client
:
*
mut
CrashHelperClient
)
-
>
AncillaryData
{
let
client
=
client
.
as_mut
(
)
.
unwrap
(
)
;
if
let
Ok
(
client_endpoint
)
=
client
.
register_child_process
(
)
{
client_endpoint
}
else
{
INVALID_ANCILLARY_DATA
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
transfer_crash_report
(
client
:
*
mut
CrashHelperClient
pid
:
Pid
)
-
>
*
mut
CrashReport
{
let
client
=
client
.
as_mut
(
)
.
unwrap
(
)
;
if
let
Ok
(
crash_report
)
=
client
.
transfer_crash_report
(
pid
)
{
Box
:
:
into_raw
(
Box
:
:
new
(
crash_report
)
)
}
else
{
null_mut
(
)
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
release_crash_report
(
crash_report
:
*
mut
CrashReport
)
{
let
crash_report
=
Box
:
:
from_raw
(
crash_report
)
;
let
_path
=
<
OsString
as
BreakpadString
>
:
:
from_raw
(
crash_report
.
path
)
;
if
!
crash_report
.
error
.
is_null
(
)
{
let
_error
=
CString
:
:
from_raw
(
crash_report
.
error
)
;
}
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
pub
unsafe
fn
report_external_exception
(
main_process_pid
:
Pid
pid
:
Pid
thread
:
Pid
exception_record_ptr
:
*
mut
EXCEPTION_RECORD
context_ptr
:
*
mut
CONTEXT
)
{
let
exception_records
=
collect_exception_records
(
exception_record_ptr
)
;
let
context
=
unsafe
{
context_ptr
.
read
(
)
}
;
let
message
=
messages
:
:
WindowsErrorReportingMinidump
:
:
new
(
pid
thread
exception_records
context
)
;
let
server_addr
=
crash_helper_common
:
:
server_addr
(
main_process_pid
)
;
if
let
Ok
(
connector
)
=
IPCConnector
:
:
connect
(
&
server_addr
)
{
let
_
=
connector
.
send_message
(
&
message
)
.
and_then
(
|
_
|
connector
.
recv_reply
:
:
<
messages
:
:
WindowsErrorReportingMinidumpReply
>
(
)
)
;
}
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
fn
collect_exception_records
(
mut
exception_record_ptr
:
*
mut
EXCEPTION_RECORD
)
-
>
Vec
<
EXCEPTION_RECORD
>
{
let
mut
exception_records
=
Vec
:
:
<
EXCEPTION_RECORD
>
:
:
with_capacity
(
1
)
;
loop
{
if
exception_record_ptr
.
is_null
(
)
{
return
exception_records
;
}
let
mut
exception_record
=
unsafe
{
exception_record_ptr
.
read
(
)
}
;
exception_record_ptr
=
exception_record
.
ExceptionRecord
;
exception_record
.
ExceptionRecord
=
null_mut
(
)
;
exception_records
.
push
(
exception_record
)
;
}
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
register_child_auxv_info
(
client
:
*
mut
CrashHelperClient
pid
:
Pid
auxv_info_ptr
:
*
const
rust_minidump_writer_linux
:
:
DirectAuxvDumpInfo
)
-
>
bool
{
let
client
=
client
.
as_mut
(
)
.
unwrap
(
)
;
let
auxv_info
=
DirectAuxvDumpInfo
{
program_header_count
:
(
*
auxv_info_ptr
)
.
program_header_count
as
AuxvType
program_header_address
:
(
*
auxv_info_ptr
)
.
program_header_address
as
AuxvType
linux_gate_address
:
(
*
auxv_info_ptr
)
.
linux_gate_address
as
AuxvType
entry_address
:
(
*
auxv_info_ptr
)
.
entry_address
as
AuxvType
}
;
client
.
register_auxv_info
(
pid
auxv_info
)
.
is_ok
(
)
}
#
[
cfg
(
any
(
target_os
=
"
android
"
target_os
=
"
linux
"
)
)
]
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
unregister_child_auxv_info
(
client
:
*
mut
CrashHelperClient
pid
:
Pid
)
-
>
bool
{
let
client
=
client
.
as_mut
(
)
.
unwrap
(
)
;
client
.
unregister_auxv_info
(
pid
)
.
is_ok
(
)
}
static
CHILD_IPC_ENDPOINT
:
OnceLock
<
Box
<
AncillaryData
>
>
=
OnceLock
:
:
new
(
)
;
static
RENDEZVOUS_FAILED
:
AtomicBool
=
AtomicBool
:
:
new
(
false
)
;
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_helper_rendezvous
(
client_endpoint
:
AncillaryData
)
{
let
Ok
(
connector
)
=
IPCConnector
:
:
from_ancillary
(
client_endpoint
)
else
{
RENDEZVOUS_FAILED
.
store
(
true
Ordering
:
:
Relaxed
)
;
return
;
}
;
let
join_handle
=
thread
:
:
spawn
(
move
|
|
{
if
let
Ok
(
message
)
=
connector
.
recv_reply
:
:
<
messages
:
:
ChildProcessRegistered
>
(
)
{
CrashHelperClient
:
:
prepare_for_minidump
(
message
.
crash_helper_pid
)
;
assert
!
(
CHILD_IPC_ENDPOINT
.
set
(
Box
:
:
new
(
connector
.
into_ancillary
(
&
None
)
.
unwrap
(
)
)
)
.
is_ok
(
)
"
The
crash_helper_rendezvous
(
)
function
must
only
be
called
once
"
)
;
}
RENDEZVOUS_FAILED
.
store
(
true
Ordering
:
:
Relaxed
)
;
}
)
;
if
join_handle
.
is_finished
(
)
&
&
join_handle
.
join
(
)
.
is_err
(
)
{
RENDEZVOUS_FAILED
.
store
(
true
Ordering
:
:
Relaxed
)
;
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_helper_wait_for_rendezvous
(
)
{
while
CHILD_IPC_ENDPOINT
.
get
(
)
.
is_none
(
)
{
if
RENDEZVOUS_FAILED
.
load
(
Ordering
:
:
Relaxed
)
{
break
;
}
spin_loop
(
)
;
}
}
