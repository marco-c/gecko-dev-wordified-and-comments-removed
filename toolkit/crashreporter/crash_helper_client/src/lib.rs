use
anyhow
:
:
{
bail
Result
}
;
use
crash_helper_common
:
:
{
messages
:
:
{
self
}
BreakpadData
BreakpadString
IPCConnector
}
;
use
std
:
:
{
ffi
:
:
{
c_char
CStr
CString
OsString
}
ptr
:
:
null_mut
}
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
use
windows_sys
:
:
Win32
:
:
System
:
:
Diagnostics
:
:
Debug
:
:
{
CONTEXT
EXCEPTION_RECORD
}
;
extern
crate
num_traits
;
pub
use
crash_helper_common
:
:
{
BreakpadChar
BreakpadRawData
Pid
}
;
mod
platform
;
pub
struct
CrashHelperClient
{
connector
:
IPCConnector
pid
:
Pid
}
impl
CrashHelperClient
{
fn
send_initialize
(
&
self
minidump_path
:
OsString
breakpad_data
:
BreakpadData
release_channel
:
&
str
)
-
>
Result
<
(
)
>
{
let
message
=
messages
:
:
Initialize
:
:
new
(
minidump_path
breakpad_data
release_channel
)
;
self
.
connector
.
send_message
(
&
message
)
?
;
self
.
connector
.
recv_reply
:
:
<
messages
:
:
InitializeReply
>
(
)
?
;
Ok
(
(
)
)
}
fn
set_crash_report_path
(
&
self
path
:
OsString
)
-
>
Result
<
(
)
>
{
let
message
=
messages
:
:
SetCrashReportPath
:
:
new
(
path
)
;
self
.
connector
.
send_message
(
&
message
)
?
;
self
.
connector
.
recv_reply
:
:
<
messages
:
:
SetCrashReportPathReply
>
(
)
?
;
Ok
(
(
)
)
}
fn
transfer_crash_report
(
&
self
pid
:
Pid
)
-
>
Result
<
CrashReport
>
{
let
message
=
messages
:
:
TransferMinidump
:
:
new
(
pid
)
;
self
.
connector
.
send_message
(
&
message
)
?
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
self
.
connector
.
poll
(
nix
:
:
poll
:
:
PollFlags
:
:
POLLIN
)
?
;
let
reply
=
self
.
connector
.
recv_reply
:
:
<
messages
:
:
TransferMinidumpReply
>
(
)
?
;
if
reply
.
path
.
is_empty
(
)
{
bail
!
(
"
Minidump
for
pid
{
pid
:
}
was
not
found
"
)
;
}
Ok
(
CrashReport
{
path
:
reply
.
path
.
into_raw
(
)
error
:
reply
.
error
.
map_or
(
null_mut
(
)
|
error
|
error
.
into_raw
(
)
)
}
)
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_helper_launch
(
helper_name
:
*
const
BreakpadChar
minidump_path
:
*
const
BreakpadChar
breakpad_raw_data
:
BreakpadRawData
release_channel
:
*
const
c_char
)
-
>
*
mut
CrashHelperClient
{
if
let
Ok
(
crash_helper
)
=
CrashHelperClient
:
:
new
(
helper_name
)
{
let
minidump_path
=
<
OsString
as
BreakpadString
>
:
:
from_ptr
(
minidump_path
)
;
let
breakpad_data
=
BreakpadData
:
:
new
(
breakpad_raw_data
)
;
let
release_channel
=
CStr
:
:
from_ptr
(
release_channel
)
;
let
res
=
crash_helper
.
send_initialize
(
minidump_path
breakpad_data
&
release_channel
.
to_string_lossy
(
)
)
;
if
res
.
is_err
(
)
{
return
null_mut
(
)
;
}
let
crash_helper_box
=
Box
:
:
new
(
crash_helper
)
;
Box
:
:
into_raw
(
crash_helper_box
)
}
else
{
null_mut
(
)
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_helper_shutdown
(
client
:
*
mut
CrashHelperClient
)
{
let
_crash_helper_box
=
Box
:
:
from_raw
(
client
)
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
crash_helper_pid
(
client
:
*
const
CrashHelperClient
)
-
>
Pid
{
(
*
client
)
.
pid
}
#
[
repr
(
C
)
]
pub
struct
CrashReport
{
path
:
*
mut
BreakpadChar
error
:
*
mut
c_char
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
set_crash_report_path
(
client
:
*
mut
CrashHelperClient
path
:
*
const
BreakpadChar
)
-
>
bool
{
let
client
=
client
.
as_ref
(
)
.
unwrap
(
)
;
let
path
=
<
OsString
as
BreakpadString
>
:
:
from_ptr
(
path
)
;
client
.
set_crash_report_path
(
path
)
.
is_ok
(
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
transfer_crash_report
(
client
:
*
mut
CrashHelperClient
pid
:
Pid
)
-
>
*
mut
CrashReport
{
let
client
=
client
.
as_ref
(
)
.
unwrap
(
)
;
if
let
Ok
(
crash_report
)
=
client
.
transfer_crash_report
(
pid
)
{
Box
:
:
into_raw
(
Box
:
:
new
(
crash_report
)
)
}
else
{
null_mut
(
)
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
release_crash_report
(
crash_report
:
*
mut
CrashReport
)
{
let
crash_report
=
Box
:
:
from_raw
(
crash_report
)
;
let
_path
=
<
OsString
as
BreakpadString
>
:
:
from_raw
(
crash_report
.
path
)
;
if
!
crash_report
.
error
.
is_null
(
)
{
let
_error
=
CString
:
:
from_raw
(
crash_report
.
error
)
;
}
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
pub
unsafe
fn
report_external_exception
(
main_process_pid
:
Pid
pid
:
Pid
thread
:
Pid
exception_record_ptr
:
*
mut
EXCEPTION_RECORD
context_ptr
:
*
mut
CONTEXT
)
{
let
exception_records
=
collect_exception_records
(
exception_record_ptr
)
;
let
context
=
unsafe
{
context_ptr
.
read
(
)
}
;
let
message
=
messages
:
:
WindowsErrorReportingMinidump
:
:
new
(
pid
thread
exception_records
context
)
;
if
let
Ok
(
connector
)
=
IPCConnector
:
:
connect
(
main_process_pid
)
{
let
_
=
connector
.
send_message
(
&
message
)
.
and_then
(
|
_
|
connector
.
recv_reply
:
:
<
messages
:
:
WindowsErrorReportingMinidumpReply
>
(
)
)
;
}
}
#
[
cfg
(
target_os
=
"
windows
"
)
]
fn
collect_exception_records
(
mut
exception_record_ptr
:
*
mut
EXCEPTION_RECORD
)
-
>
Vec
<
EXCEPTION_RECORD
>
{
let
mut
exception_records
=
Vec
:
:
<
EXCEPTION_RECORD
>
:
:
with_capacity
(
1
)
;
loop
{
if
exception_record_ptr
.
is_null
(
)
{
return
exception_records
;
}
let
mut
exception_record
=
unsafe
{
exception_record_ptr
.
read
(
)
}
;
exception_record_ptr
=
exception_record
.
ExceptionRecord
;
exception_record
.
ExceptionRecord
=
null_mut
(
)
;
exception_records
.
push
(
exception_record
)
;
}
}
