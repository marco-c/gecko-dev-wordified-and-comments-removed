use
crate
:
:
{
errors
:
:
IPCError
messages
:
:
{
self
Message
}
platform
:
:
windows
:
:
{
create_manual_reset_event
server_name
OverlappedOperation
}
Pid
IO_TIMEOUT
}
;
use
std
:
:
{
ffi
:
:
{
c_void
CStr
OsString
}
os
:
:
windows
:
:
io
:
:
{
AsRawHandle
FromRawHandle
OwnedHandle
RawHandle
}
ptr
:
:
null_mut
str
:
:
FromStr
time
:
:
{
Duration
Instant
}
}
;
use
windows_sys
:
:
Win32
:
:
{
Foundation
:
:
{
GetLastError
ERROR_FILE_NOT_FOUND
ERROR_INVALID_MESSAGE
ERROR_PIPE_BUSY
FALSE
HANDLE
INVALID_HANDLE_VALUE
WAIT_TIMEOUT
}
Security
:
:
SECURITY_ATTRIBUTES
Storage
:
:
FileSystem
:
:
{
CreateFileA
FILE_FLAG_OVERLAPPED
FILE_READ_DATA
FILE_SHARE_READ
FILE_SHARE_WRITE
FILE_WRITE_ATTRIBUTES
FILE_WRITE_DATA
OPEN_EXISTING
}
System
:
:
Pipes
:
:
{
SetNamedPipeHandleState
WaitNamedPipeA
PIPE_READMODE_MESSAGE
}
}
;
pub
type
AncillaryData
=
(
)
;
pub
const
INVALID_ANCILLARY_DATA
:
AncillaryData
=
(
)
;
pub
struct
IPCConnector
{
handle
:
OwnedHandle
event
:
OwnedHandle
overlapped
:
Option
<
OverlappedOperation
>
}
impl
IPCConnector
{
pub
fn
new
(
handle
:
OwnedHandle
)
-
>
Result
<
IPCConnector
IPCError
>
{
let
event
=
create_manual_reset_event
(
)
?
;
Ok
(
IPCConnector
{
handle
event
overlapped
:
None
}
)
}
pub
fn
as_raw
(
&
self
)
-
>
HANDLE
{
self
.
handle
.
as_raw_handle
(
)
as
HANDLE
}
pub
fn
event_raw_handle
(
&
self
)
-
>
HANDLE
{
self
.
event
.
as_raw_handle
(
)
as
HANDLE
}
pub
fn
connect
(
pid
:
Pid
)
-
>
Result
<
IPCConnector
IPCError
>
{
let
server_name
=
server_name
(
pid
)
;
let
now
=
Instant
:
:
now
(
)
;
let
timeout
=
Duration
:
:
from_millis
(
IO_TIMEOUT
.
into
(
)
)
;
let
mut
pipe
;
loop
{
let
security_attributes
=
SECURITY_ATTRIBUTES
{
nLength
:
size_of
:
:
<
SECURITY_ATTRIBUTES
>
(
)
as
u32
lpSecurityDescriptor
:
null_mut
(
)
bInheritHandle
:
FALSE
}
;
pipe
=
unsafe
{
CreateFileA
(
server_name
.
as_ptr
(
)
FILE_READ_DATA
|
FILE_WRITE_DATA
|
FILE_WRITE_ATTRIBUTES
FILE_SHARE_READ
|
FILE_SHARE_WRITE
&
security_attributes
OPEN_EXISTING
FILE_FLAG_OVERLAPPED
0
as
HANDLE
)
}
;
if
pipe
!
=
INVALID_HANDLE_VALUE
{
break
;
}
let
elapsed
=
now
.
elapsed
(
)
;
if
elapsed
>
=
timeout
{
return
Err
(
IPCError
:
:
System
(
WAIT_TIMEOUT
)
)
;
}
let
error
=
unsafe
{
GetLastError
(
)
}
;
if
(
error
=
=
ERROR_FILE_NOT_FOUND
)
|
|
(
error
=
=
ERROR_PIPE_BUSY
)
{
let
res
=
unsafe
{
WaitNamedPipeA
(
server_name
.
as_ptr
(
)
(
timeout
-
elapsed
)
.
as_millis
(
)
as
u32
)
}
;
let
error
=
unsafe
{
GetLastError
(
)
}
;
if
(
res
=
=
FALSE
)
&
&
(
error
!
=
ERROR_FILE_NOT_FOUND
)
{
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
}
else
{
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
}
let
pipe_mode
:
u32
=
PIPE_READMODE_MESSAGE
;
let
res
=
unsafe
{
SetNamedPipeHandleState
(
pipe
&
pipe_mode
null_mut
(
)
null_mut
(
)
)
}
;
if
res
=
=
FALSE
{
return
Err
(
IPCError
:
:
System
(
unsafe
{
GetLastError
(
)
}
)
)
;
}
let
handle
=
unsafe
{
OwnedHandle
:
:
from_raw_handle
(
pipe
as
RawHandle
)
}
;
IPCConnector
:
:
new
(
handle
)
}
pub
fn
serialize
(
&
self
)
-
>
OsString
{
let
raw_handle
=
self
.
handle
.
as_raw_handle
(
)
as
usize
;
OsString
:
:
from_str
(
raw_handle
.
to_string
(
)
.
as_ref
(
)
)
.
unwrap
(
)
}
pub
fn
deserialize
(
string
:
&
CStr
)
-
>
Result
<
IPCConnector
IPCError
>
{
let
string
=
string
.
to_str
(
)
.
map_err
(
|
_e
|
IPCError
:
:
ParseError
)
?
;
let
handle
=
usize
:
:
from_str
(
string
)
.
map_err
(
|
_e
|
IPCError
:
:
ParseError
)
?
;
let
handle
=
handle
as
*
mut
c_void
;
let
handle
=
unsafe
{
OwnedHandle
:
:
from_raw_handle
(
handle
)
}
;
IPCConnector
:
:
new
(
handle
)
}
pub
fn
send_message
(
&
self
message
:
&
dyn
Message
)
-
>
Result
<
(
)
IPCError
>
{
self
.
send
(
&
message
.
header
(
)
)
?
;
debug_assert
!
(
message
.
ancillary_payload
(
)
.
is_none
(
)
"
Windows
doesn
'
t
transfer
ancillary
data
"
)
;
self
.
send
(
&
message
.
payload
(
)
)
?
;
Ok
(
(
)
)
}
pub
fn
recv_reply
<
T
>
(
&
self
)
-
>
Result
<
T
IPCError
>
where
T
:
Message
{
let
header
=
self
.
recv_header
(
)
?
;
if
header
.
kind
!
=
T
:
:
kind
(
)
{
return
Err
(
IPCError
:
:
ReceptionFailure
(
ERROR_INVALID_MESSAGE
)
)
;
}
let
(
data
_
)
=
self
.
recv
(
header
.
size
)
?
;
T
:
:
decode
(
&
data
None
)
.
map_err
(
IPCError
:
:
from
)
}
fn
recv_header
(
&
self
)
-
>
Result
<
messages
:
:
Header
IPCError
>
{
let
(
header
_
)
=
self
.
recv
(
messages
:
:
HEADER_SIZE
)
?
;
messages
:
:
Header
:
:
decode
(
&
header
)
.
map_err
(
IPCError
:
:
BadMessage
)
}
pub
fn
sched_recv_header
(
&
mut
self
)
-
>
Result
<
(
)
IPCError
>
{
if
self
.
overlapped
.
is_some
(
)
{
return
Ok
(
(
)
)
;
}
self
.
overlapped
=
Some
(
OverlappedOperation
:
:
sched_recv
(
self
.
handle
.
try_clone
(
)
.
map_err
(
IPCError
:
:
CloneHandleFailed
)
?
self
.
event_raw_handle
(
)
messages
:
:
HEADER_SIZE
)
?
)
;
Ok
(
(
)
)
}
pub
fn
collect_header
(
&
mut
self
)
-
>
Result
<
messages
:
:
Header
IPCError
>
{
let
overlapped
=
self
.
overlapped
.
take
(
)
.
unwrap
(
)
;
let
buffer
=
overlapped
.
collect_recv
(
false
)
?
;
messages
:
:
Header
:
:
decode
(
buffer
.
as_ref
(
)
)
.
map_err
(
IPCError
:
:
BadMessage
)
}
pub
fn
send
(
&
self
buff
:
&
[
u8
]
)
-
>
Result
<
(
)
IPCError
>
{
let
overlapped
=
OverlappedOperation
:
:
sched_send
(
self
.
handle
.
try_clone
(
)
.
map_err
(
IPCError
:
:
CloneHandleFailed
)
?
self
.
event_raw_handle
(
)
buff
.
to_vec
(
)
)
?
;
overlapped
.
complete_send
(
false
)
}
pub
fn
recv
(
&
self
expected_size
:
usize
)
-
>
Result
<
(
Vec
<
u8
>
Option
<
AncillaryData
>
)
IPCError
>
{
let
overlapped
=
OverlappedOperation
:
:
sched_recv
(
self
.
handle
.
try_clone
(
)
.
map_err
(
IPCError
:
:
CloneHandleFailed
)
?
self
.
event_raw_handle
(
)
expected_size
)
?
;
let
buffer
=
overlapped
.
collect_recv
(
true
)
?
;
Ok
(
(
buffer
None
)
)
}
}
unsafe
impl
Send
for
IPCConnector
{
}
