use
crate
:
:
{
Pid
IO_TIMEOUT
}
;
use
std
:
:
{
ffi
:
:
CString
mem
:
:
{
zeroed
MaybeUninit
}
os
:
:
windows
:
:
io
:
:
{
AsHandle
AsRawHandle
BorrowedHandle
FromRawHandle
OwnedHandle
RawHandle
}
ptr
:
:
{
null
null_mut
}
rc
:
:
Rc
}
;
use
thiserror
:
:
Error
;
use
windows_sys
:
:
Win32
:
:
{
Foundation
:
:
{
GetLastError
ERROR_BROKEN_PIPE
ERROR_IO_PENDING
ERROR_NOT_FOUND
ERROR_PIPE_CONNECTED
FALSE
HANDLE
WAIT_TIMEOUT
WIN32_ERROR
}
Storage
:
:
FileSystem
:
:
{
ReadFile
WriteFile
}
System
:
:
{
Pipes
:
:
ConnectNamedPipe
Threading
:
:
{
CreateEventA
ResetEvent
SetEvent
INFINITE
}
IO
:
:
{
CancelIoEx
GetOverlappedResultEx
OVERLAPPED
}
}
}
;
pub
type
ProcessHandle
=
OwnedHandle
;
#
[
derive
(
Error
Debug
)
]
pub
enum
PlatformError
{
#
[
error
(
"
Could
not
accept
incoming
connection
:
{
0
}
"
)
]
AcceptFailed
(
WIN32_ERROR
)
#
[
error
(
"
Broken
pipe
"
)
]
BrokenPipe
#
[
error
(
"
Failed
to
duplicate
clone
handle
"
)
]
CloneHandleFailed
(
#
[
source
]
std
:
:
io
:
:
Error
)
#
[
error
(
"
Could
not
create
event
:
{
0
}
"
)
]
CreateEventFailed
(
WIN32_ERROR
)
#
[
error
(
"
Could
not
create
a
pipe
:
{
0
}
"
)
]
CreatePipeFailure
(
WIN32_ERROR
)
#
[
error
(
"
I
/
O
error
:
{
0
}
"
)
]
IOError
(
WIN32_ERROR
)
#
[
error
(
"
No
process
handle
specified
"
)
]
MissingProcessHandle
#
[
error
(
"
Could
not
listen
for
incoming
connections
:
{
0
}
"
)
]
ListenFailed
(
WIN32_ERROR
)
#
[
error
(
"
Receiving
{
expected
}
bytes
failed
only
{
received
}
bytes
received
"
)
]
ReceiveTooShort
{
expected
:
usize
received
:
usize
}
#
[
error
(
"
Could
not
reset
event
:
{
0
}
"
)
]
ResetEventFailed
(
WIN32_ERROR
)
#
[
error
(
"
Sending
{
expected
}
bytes
failed
only
{
sent
}
bytes
sent
"
)
]
SendTooShort
{
expected
:
usize
sent
:
usize
}
#
[
error
(
"
Could
not
set
event
:
{
0
}
"
)
]
SetEventFailed
(
WIN32_ERROR
)
#
[
error
(
"
Value
too
large
"
)
]
ValueTooLarge
}
pub
(
crate
)
fn
get_last_error
(
)
-
>
WIN32_ERROR
{
unsafe
{
GetLastError
(
)
}
}
pub
fn
server_addr
(
pid
:
Pid
)
-
>
CString
{
CString
:
:
new
(
format
!
(
"
\
\
\
\
.
\
\
pipe
\
\
gecko
-
crash
-
helper
-
pipe
.
{
pid
:
}
"
)
)
.
unwrap
(
)
}
pub
(
crate
)
fn
create_manual_reset_event
(
)
-
>
Result
<
OwnedHandle
PlatformError
>
{
let
raw_handle
=
unsafe
{
CreateEventA
(
null
(
)
FALSE
FALSE
null
(
)
)
}
as
RawHandle
;
if
raw_handle
.
is_null
(
)
{
return
Err
(
PlatformError
:
:
CreateEventFailed
(
get_last_error
(
)
)
)
;
}
Ok
(
unsafe
{
OwnedHandle
:
:
from_raw_handle
(
raw_handle
)
}
)
}
fn
set_event
(
handle
:
BorrowedHandle
)
-
>
Result
<
(
)
PlatformError
>
{
if
unsafe
{
SetEvent
(
handle
.
as_raw_handle
(
)
as
HANDLE
)
}
=
=
FALSE
{
Err
(
PlatformError
:
:
SetEventFailed
(
get_last_error
(
)
)
)
}
else
{
Ok
(
(
)
)
}
}
fn
reset_event
(
handle
:
BorrowedHandle
)
-
>
Result
<
(
)
PlatformError
>
{
if
unsafe
{
ResetEvent
(
handle
.
as_raw_handle
(
)
as
HANDLE
)
}
=
=
FALSE
{
Err
(
PlatformError
:
:
ResetEventFailed
(
get_last_error
(
)
)
)
}
else
{
Ok
(
(
)
)
}
}
fn
cancel_overlapped_io
(
handle
:
BorrowedHandle
overlapped
:
&
OVERLAPPED
)
-
>
bool
{
let
res
=
unsafe
{
CancelIoEx
(
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
)
}
;
if
res
=
=
FALSE
{
if
get_last_error
(
)
=
=
ERROR_NOT_FOUND
{
return
true
;
}
return
false
;
}
if
overlapped
.
hEvent
=
=
0
{
return
true
;
}
let
mut
number_of_bytes_transferred
=
MaybeUninit
:
:
<
u32
>
:
:
uninit
(
)
;
let
res
=
unsafe
{
GetOverlappedResultEx
(
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
number_of_bytes_transferred
.
as_mut_ptr
(
)
INFINITE
FALSE
)
}
;
res
!
=
FALSE
}
pub
(
crate
)
struct
OverlappedOperation
{
handle
:
Rc
<
OwnedHandle
>
overlapped
:
Option
<
Box
<
OVERLAPPED
>
>
buffer
:
Option
<
Vec
<
u8
>
>
}
enum
OverlappedOperationType
{
Read
Write
}
impl
OverlappedOperation
{
pub
(
crate
)
fn
listen
(
handle
:
&
Rc
<
OwnedHandle
>
)
-
>
Result
<
OverlappedOperation
PlatformError
>
{
let
mut
overlapped
=
Self
:
:
overlapped
(
)
;
let
res
=
unsafe
{
ConnectNamedPipe
(
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
.
as_mut
(
)
)
}
;
let
error
=
get_last_error
(
)
;
if
res
!
=
FALSE
{
return
Err
(
PlatformError
:
:
ListenFailed
(
error
)
)
;
}
match
error
{
ERROR_PIPE_CONNECTED
|
ERROR_IO_PENDING
=
>
{
}
error
=
>
return
Err
(
PlatformError
:
:
ListenFailed
(
error
)
)
}
;
Ok
(
OverlappedOperation
{
handle
:
handle
.
clone
(
)
overlapped
:
Some
(
overlapped
)
buffer
:
None
}
)
}
pub
(
crate
)
fn
accept
(
mut
self
)
-
>
Result
<
(
)
PlatformError
>
{
let
overlapped
=
self
.
overlapped
.
take
(
)
.
unwrap
(
)
;
let
mut
number_of_bytes_transferred
=
MaybeUninit
:
:
<
u32
>
:
:
uninit
(
)
;
let
res
=
unsafe
{
GetOverlappedResultEx
(
self
.
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
.
as_ref
(
)
number_of_bytes_transferred
.
as_mut_ptr
(
)
0
FALSE
)
}
;
if
res
=
=
FALSE
{
return
Err
(
PlatformError
:
:
AcceptFailed
(
get_last_error
(
)
)
)
;
}
Ok
(
(
)
)
}
fn
await_io
(
mut
self
optype
:
OverlappedOperationType
)
-
>
Result
<
Option
<
Vec
<
u8
>
>
PlatformError
>
{
let
overlapped
=
self
.
overlapped
.
take
(
)
.
unwrap
(
)
;
let
buffer
=
self
.
buffer
.
take
(
)
.
unwrap
(
)
;
let
mut
number_of_bytes_transferred
=
MaybeUninit
:
:
<
u32
>
:
:
uninit
(
)
;
let
res
=
unsafe
{
GetOverlappedResultEx
(
self
.
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
.
as_ref
(
)
number_of_bytes_transferred
.
as_mut_ptr
(
)
IO_TIMEOUT
as
u32
FALSE
)
}
;
if
res
=
=
FALSE
{
let
error
=
get_last_error
(
)
;
if
error
=
=
WAIT_TIMEOUT
{
self
.
cancel_or_leak
(
overlapped
Some
(
buffer
)
)
;
}
else
if
error
=
=
ERROR_BROKEN_PIPE
{
return
Err
(
PlatformError
:
:
BrokenPipe
)
;
}
return
Err
(
PlatformError
:
:
IOError
(
error
)
)
;
}
let
number_of_bytes_transferred
=
unsafe
{
number_of_bytes_transferred
.
assume_init
(
)
}
;
if
number_of_bytes_transferred
as
usize
!
=
buffer
.
len
(
)
{
return
Err
(
match
optype
{
OverlappedOperationType
:
:
Read
=
>
PlatformError
:
:
ReceiveTooShort
{
expected
:
buffer
.
len
(
)
received
:
number_of_bytes_transferred
as
usize
}
OverlappedOperationType
:
:
Write
=
>
PlatformError
:
:
SendTooShort
{
expected
:
buffer
.
len
(
)
sent
:
number_of_bytes_transferred
as
usize
}
}
)
;
}
Ok
(
match
optype
{
OverlappedOperationType
:
:
Read
=
>
Some
(
buffer
)
OverlappedOperationType
:
:
Write
=
>
None
}
)
}
fn
sched_recv_internal
(
handle
:
&
Rc
<
OwnedHandle
>
event
:
Option
<
BorrowedHandle
>
expected_size
:
usize
)
-
>
Result
<
OverlappedOperation
PlatformError
>
{
let
mut
overlapped
=
if
let
Some
(
event
)
=
event
{
OverlappedOperation
:
:
overlapped_with_event
(
event
)
?
}
else
{
OverlappedOperation
:
:
overlapped
(
)
}
;
let
mut
buffer
=
vec
!
[
0u8
;
expected_size
]
;
let
number_of_bytes_to_read
:
u32
=
expected_size
.
try_into
(
)
.
map_err
(
|
_e
|
PlatformError
:
:
ValueTooLarge
)
?
;
let
res
=
unsafe
{
ReadFile
(
handle
.
as_raw_handle
(
)
as
HANDLE
buffer
.
as_mut_ptr
(
)
number_of_bytes_to_read
null_mut
(
)
overlapped
.
as_mut
(
)
)
}
;
let
error
=
get_last_error
(
)
;
if
res
!
=
FALSE
{
if
let
Some
(
event
)
=
event
{
set_event
(
event
)
?
;
}
}
else
if
error
=
=
ERROR_BROKEN_PIPE
{
return
Err
(
PlatformError
:
:
BrokenPipe
)
;
}
else
if
error
!
=
ERROR_IO_PENDING
{
return
Err
(
PlatformError
:
:
IOError
(
error
)
)
;
}
Ok
(
OverlappedOperation
{
handle
:
handle
.
clone
(
)
overlapped
:
Some
(
overlapped
)
buffer
:
Some
(
buffer
)
}
)
}
pub
(
crate
)
fn
recv
(
handle
:
&
Rc
<
OwnedHandle
>
event
:
BorrowedHandle
<
'
_
>
expected_size
:
usize
)
-
>
Result
<
Vec
<
u8
>
PlatformError
>
{
let
overlapped
=
Self
:
:
sched_recv_internal
(
handle
Some
(
event
)
expected_size
)
?
;
overlapped
.
await_io
(
OverlappedOperationType
:
:
Read
)
.
map
(
|
buffer
|
buffer
.
unwrap
(
)
)
}
pub
(
crate
)
fn
sched_recv
(
handle
:
&
Rc
<
OwnedHandle
>
expected_size
:
usize
)
-
>
Result
<
OverlappedOperation
PlatformError
>
{
Self
:
:
sched_recv_internal
(
handle
None
expected_size
)
}
pub
(
crate
)
fn
collect_recv
(
mut
self
)
-
>
Vec
<
u8
>
{
self
.
buffer
.
take
(
)
.
expect
(
"
Missing
receive
buffer
"
)
}
pub
(
crate
)
fn
send
(
handle
:
&
Rc
<
OwnedHandle
>
event
:
BorrowedHandle
<
'
_
>
mut
buffer
:
Vec
<
u8
>
)
-
>
Result
<
(
)
PlatformError
>
{
let
mut
overlapped
=
Self
:
:
overlapped_with_event
(
event
)
?
;
let
number_of_bytes_to_write
:
u32
=
buffer
.
len
(
)
.
try_into
(
)
.
map_err
(
|
_e
|
PlatformError
:
:
ValueTooLarge
)
?
;
let
res
=
unsafe
{
WriteFile
(
handle
.
as_raw_handle
(
)
as
HANDLE
buffer
.
as_mut_ptr
(
)
number_of_bytes_to_write
null_mut
(
)
overlapped
.
as_mut
(
)
)
}
;
let
error
=
get_last_error
(
)
;
if
res
!
=
FALSE
{
set_event
(
event
)
?
;
}
else
if
error
=
=
ERROR_BROKEN_PIPE
{
return
Err
(
PlatformError
:
:
BrokenPipe
)
;
}
else
if
error
!
=
ERROR_IO_PENDING
{
return
Err
(
PlatformError
:
:
IOError
(
error
)
)
;
}
let
overlapped
=
OverlappedOperation
{
handle
:
handle
.
clone
(
)
overlapped
:
Some
(
overlapped
)
buffer
:
Some
(
buffer
)
}
;
overlapped
.
await_io
(
OverlappedOperationType
:
:
Write
)
.
map
(
|
buffer
|
{
debug_assert
!
(
buffer
.
is_none
(
)
)
;
}
)
}
fn
overlapped_with_event
(
event
:
BorrowedHandle
<
'
_
>
)
-
>
Result
<
Box
<
OVERLAPPED
>
PlatformError
>
{
reset_event
(
event
)
?
;
Ok
(
Box
:
:
new
(
OVERLAPPED
{
hEvent
:
event
.
as_raw_handle
(
)
as
HANDLE
|
1
.
.
unsafe
{
zeroed
(
)
}
}
)
)
}
fn
overlapped
(
)
-
>
Box
<
OVERLAPPED
>
{
Box
:
:
new
(
unsafe
{
zeroed
(
)
}
)
}
pub
(
crate
)
fn
cancel
(
&
self
)
-
>
bool
{
if
let
Some
(
overlapped
)
=
self
.
overlapped
.
as_deref
(
)
{
return
cancel_overlapped_io
(
self
.
handle
.
as_handle
(
)
overlapped
)
;
}
true
}
pub
(
crate
)
fn
leak
(
&
mut
self
)
{
if
let
Some
(
overlapped
)
=
self
.
overlapped
.
take
(
)
{
Box
:
:
leak
(
overlapped
)
;
if
let
Some
(
buffer
)
=
self
.
buffer
.
take
(
)
{
buffer
.
leak
(
)
;
}
}
}
fn
cancel_or_leak
(
&
self
mut
overlapped
:
Box
<
OVERLAPPED
>
buffer
:
Option
<
Vec
<
u8
>
>
)
{
if
!
cancel_overlapped_io
(
self
.
handle
.
as_handle
(
)
overlapped
.
as_mut
(
)
)
{
Box
:
:
leak
(
overlapped
)
;
if
let
Some
(
buffer
)
=
buffer
{
buffer
.
leak
(
)
;
}
}
}
}
impl
Drop
for
OverlappedOperation
{
fn
drop
(
&
mut
self
)
{
let
overlapped
=
self
.
overlapped
.
take
(
)
;
let
buffer
=
self
.
buffer
.
take
(
)
;
if
let
Some
(
overlapped
)
=
overlapped
{
if
overlapped
.
hEvent
=
=
0
{
return
;
}
self
.
cancel_or_leak
(
overlapped
buffer
)
;
}
}
}
