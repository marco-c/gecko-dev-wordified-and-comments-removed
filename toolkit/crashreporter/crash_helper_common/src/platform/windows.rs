use
crate
:
:
{
errors
:
:
{
IPCError
MessageError
}
Pid
IO_TIMEOUT
}
;
use
std
:
:
{
ffi
:
:
CString
mem
:
:
zeroed
os
:
:
windows
:
:
io
:
:
{
AsRawHandle
FromRawHandle
OwnedHandle
RawHandle
}
ptr
:
:
{
null
null_mut
}
}
;
use
windows_sys
:
:
Win32
:
:
{
Foundation
:
:
{
GetLastError
ERROR_IO_INCOMPLETE
ERROR_IO_PENDING
ERROR_NOT_FOUND
ERROR_PIPE_CONNECTED
FALSE
HANDLE
WAIT_TIMEOUT
WIN32_ERROR
}
Storage
:
:
FileSystem
:
:
{
ReadFile
WriteFile
}
System
:
:
{
Pipes
:
:
ConnectNamedPipe
Threading
:
:
{
CreateEventA
ResetEvent
SetEvent
INFINITE
}
IO
:
:
{
CancelIoEx
GetOverlappedResultEx
OVERLAPPED
}
}
}
;
pub
type
ProcessHandle
=
OwnedHandle
;
pub
(
crate
)
fn
get_last_error
(
)
-
>
WIN32_ERROR
{
unsafe
{
GetLastError
(
)
}
}
pub
fn
server_addr
(
pid
:
Pid
)
-
>
CString
{
CString
:
:
new
(
format
!
(
"
\
\
\
\
.
\
\
pipe
\
\
gecko
-
crash
-
helper
-
pipe
.
{
pid
:
}
"
)
)
.
unwrap
(
)
}
pub
(
crate
)
fn
create_manual_reset_event
(
)
-
>
Result
<
OwnedHandle
IPCError
>
{
let
raw_handle
=
unsafe
{
CreateEventA
(
null
(
)
FALSE
FALSE
null
(
)
)
}
as
RawHandle
;
if
raw_handle
.
is_null
(
)
{
return
Err
(
IPCError
:
:
System
(
get_last_error
(
)
)
)
;
}
Ok
(
unsafe
{
OwnedHandle
:
:
from_raw_handle
(
raw_handle
)
}
)
}
fn
set_event
(
handle
:
HANDLE
)
-
>
Result
<
(
)
IPCError
>
{
if
unsafe
{
SetEvent
(
handle
)
}
=
=
FALSE
{
Err
(
IPCError
:
:
System
(
get_last_error
(
)
)
)
}
else
{
Ok
(
(
)
)
}
}
fn
cancel_overlapped_io
(
handle
:
HANDLE
overlapped
:
&
mut
OVERLAPPED
)
-
>
bool
{
let
res
=
unsafe
{
CancelIoEx
(
handle
overlapped
)
}
;
if
res
=
=
FALSE
{
if
get_last_error
(
)
=
=
ERROR_NOT_FOUND
{
return
true
;
}
return
false
;
}
let
mut
number_of_bytes_transferred
:
u32
=
0
;
let
res
=
unsafe
{
GetOverlappedResultEx
(
handle
overlapped
&
mut
number_of_bytes_transferred
INFINITE
FALSE
)
}
;
res
!
=
FALSE
}
pub
(
crate
)
struct
OverlappedOperation
{
handle
:
OwnedHandle
overlapped
:
Option
<
Box
<
OVERLAPPED
>
>
buffer
:
Option
<
Vec
<
u8
>
>
}
enum
OverlappedOperationType
{
Read
Write
}
impl
OverlappedOperation
{
pub
(
crate
)
fn
listen
(
handle
:
OwnedHandle
event
:
HANDLE
)
-
>
Result
<
OverlappedOperation
IPCError
>
{
let
mut
overlapped
=
Self
:
:
overlapped_with_event
(
event
)
?
;
let
res
=
unsafe
{
ConnectNamedPipe
(
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
.
as_mut
(
)
)
}
;
let
error
=
get_last_error
(
)
;
if
res
!
=
FALSE
{
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
if
error
=
=
ERROR_PIPE_CONNECTED
{
set_event
(
event
)
?
;
}
else
if
error
!
=
ERROR_IO_PENDING
{
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
Ok
(
OverlappedOperation
{
handle
overlapped
:
Some
(
overlapped
)
buffer
:
None
}
)
}
pub
(
crate
)
fn
accept
(
mut
self
handle
:
HANDLE
)
-
>
Result
<
(
)
IPCError
>
{
let
overlapped
=
self
.
overlapped
.
take
(
)
.
unwrap
(
)
;
let
mut
_number_of_bytes_transferred
:
u32
=
0
;
let
res
=
unsafe
{
GetOverlappedResultEx
(
handle
overlapped
.
as_ref
(
)
&
mut
_number_of_bytes_transferred
0
FALSE
)
}
;
if
res
=
=
FALSE
{
let
error
=
get_last_error
(
)
;
if
error
=
=
ERROR_IO_INCOMPLETE
{
self
.
cancel_or_leak
(
overlapped
None
)
;
}
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
Ok
(
(
)
)
}
fn
await_io
(
mut
self
optype
:
OverlappedOperationType
wait
:
bool
)
-
>
Result
<
Option
<
Vec
<
u8
>
>
IPCError
>
{
let
overlapped
=
self
.
overlapped
.
take
(
)
.
unwrap
(
)
;
let
buffer
=
self
.
buffer
.
take
(
)
.
unwrap
(
)
;
let
mut
number_of_bytes_transferred
:
u32
=
0
;
let
res
=
unsafe
{
GetOverlappedResultEx
(
self
.
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
.
as_ref
(
)
&
mut
number_of_bytes_transferred
if
wait
{
IO_TIMEOUT
as
u32
}
else
{
0
}
FALSE
)
}
;
if
res
=
=
FALSE
{
let
error
=
get_last_error
(
)
;
if
(
wait
&
&
(
error
=
=
WAIT_TIMEOUT
)
)
|
|
(
!
wait
&
&
(
error
=
=
ERROR_IO_INCOMPLETE
)
)
{
self
.
cancel_or_leak
(
overlapped
Some
(
buffer
)
)
;
}
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
if
(
number_of_bytes_transferred
as
usize
)
!
=
buffer
.
len
(
)
{
return
Err
(
IPCError
:
:
BadMessage
(
MessageError
:
:
InvalidData
)
)
;
}
Ok
(
match
optype
{
OverlappedOperationType
:
:
Read
=
>
Some
(
buffer
)
OverlappedOperationType
:
:
Write
=
>
None
}
)
}
pub
(
crate
)
fn
sched_recv
(
handle
:
OwnedHandle
event
:
HANDLE
expected_size
:
usize
)
-
>
Result
<
OverlappedOperation
IPCError
>
{
let
mut
overlapped
=
Self
:
:
overlapped_with_event
(
event
)
?
;
let
mut
buffer
=
vec
!
[
0u8
;
expected_size
]
;
let
number_of_bytes_to_read
:
u32
=
expected_size
.
try_into
(
)
?
;
let
res
=
unsafe
{
ReadFile
(
handle
.
as_raw_handle
(
)
as
HANDLE
buffer
.
as_mut_ptr
(
)
number_of_bytes_to_read
null_mut
(
)
overlapped
.
as_mut
(
)
)
}
;
let
error
=
get_last_error
(
)
;
if
res
!
=
FALSE
{
set_event
(
event
)
?
;
}
else
if
error
!
=
ERROR_IO_PENDING
{
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
Ok
(
OverlappedOperation
{
handle
overlapped
:
Some
(
overlapped
)
buffer
:
Some
(
buffer
)
}
)
}
pub
(
crate
)
fn
collect_recv
(
self
wait
:
bool
)
-
>
Result
<
Vec
<
u8
>
IPCError
>
{
Ok
(
self
.
await_io
(
OverlappedOperationType
:
:
Read
wait
)
?
.
unwrap
(
)
)
}
pub
(
crate
)
fn
sched_send
(
handle
:
OwnedHandle
event
:
HANDLE
mut
buffer
:
Vec
<
u8
>
)
-
>
Result
<
OverlappedOperation
IPCError
>
{
let
mut
overlapped
=
Self
:
:
overlapped_with_event
(
event
)
?
;
let
number_of_bytes_to_write
:
u32
=
buffer
.
len
(
)
.
try_into
(
)
?
;
let
res
=
unsafe
{
WriteFile
(
handle
.
as_raw_handle
(
)
as
HANDLE
buffer
.
as_mut_ptr
(
)
number_of_bytes_to_write
null_mut
(
)
overlapped
.
as_mut
(
)
)
}
;
let
error
=
get_last_error
(
)
;
if
res
!
=
FALSE
{
set_event
(
event
)
?
;
}
else
if
error
!
=
ERROR_IO_PENDING
{
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
Ok
(
OverlappedOperation
{
handle
overlapped
:
Some
(
overlapped
)
buffer
:
Some
(
buffer
)
}
)
}
pub
(
crate
)
fn
complete_send
(
self
wait
:
bool
)
-
>
Result
<
(
)
IPCError
>
{
self
.
await_io
(
OverlappedOperationType
:
:
Write
wait
)
?
;
Ok
(
(
)
)
}
fn
overlapped_with_event
(
event
:
HANDLE
)
-
>
Result
<
Box
<
OVERLAPPED
>
IPCError
>
{
if
unsafe
{
ResetEvent
(
event
)
}
=
=
FALSE
{
return
Err
(
IPCError
:
:
System
(
get_last_error
(
)
)
)
;
}
Ok
(
Box
:
:
new
(
OVERLAPPED
{
hEvent
:
event
.
.
unsafe
{
zeroed
(
)
}
}
)
)
}
fn
cancel_or_leak
(
&
self
mut
overlapped
:
Box
<
OVERLAPPED
>
buffer
:
Option
<
Vec
<
u8
>
>
)
{
if
!
cancel_overlapped_io
(
self
.
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
.
as_mut
(
)
)
{
Box
:
:
leak
(
overlapped
)
;
if
let
Some
(
buffer
)
=
buffer
{
buffer
.
leak
(
)
;
}
}
}
}
impl
Drop
for
OverlappedOperation
{
fn
drop
(
&
mut
self
)
{
let
overlapped
=
self
.
overlapped
.
take
(
)
;
let
buffer
=
self
.
buffer
.
take
(
)
;
if
let
Some
(
overlapped
)
=
overlapped
{
self
.
cancel_or_leak
(
overlapped
buffer
)
;
}
}
}
