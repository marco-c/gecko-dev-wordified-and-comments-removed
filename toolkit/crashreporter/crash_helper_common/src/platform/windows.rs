use
crate
:
:
{
errors
:
:
IPCError
Pid
}
;
use
std
:
:
{
os
:
:
windows
:
:
io
:
:
{
AsRawHandle
BorrowedHandle
FromRawHandle
OwnedHandle
RawHandle
}
ptr
:
:
null
}
;
use
windows_sys
:
:
Win32
:
:
{
Foundation
:
:
{
GetLastError
ERROR_NOT_FOUND
FALSE
HANDLE
TRUE
}
System
:
:
{
Threading
:
:
{
CreateEventA
ResetEvent
SetEvent
}
IO
:
:
{
CancelIoEx
GetOverlappedResult
OVERLAPPED
}
}
}
;
pub
(
crate
)
fn
server_name
(
pid
:
Pid
)
-
>
String
{
format
!
(
"
\
\
\
\
.
\
\
pipe
\
\
gecko
-
crash
-
helper
-
pipe
.
{
pid
:
}
\
0
"
)
}
pub
(
crate
)
fn
create_manual_reset_event
(
)
-
>
Result
<
OwnedHandle
IPCError
>
{
let
raw_handle
=
unsafe
{
CreateEventA
(
null
(
)
FALSE
FALSE
null
(
)
)
}
as
RawHandle
;
if
raw_handle
.
is_null
(
)
{
return
Err
(
IPCError
:
:
System
(
unsafe
{
GetLastError
(
)
}
)
)
;
}
Ok
(
unsafe
{
OwnedHandle
:
:
from_raw_handle
(
raw_handle
)
}
)
}
pub
(
crate
)
fn
reset_event
(
handle
:
BorrowedHandle
)
-
>
Result
<
(
)
IPCError
>
{
let
res
=
unsafe
{
ResetEvent
(
handle
.
as_raw_handle
(
)
as
HANDLE
)
}
;
match
res
{
FALSE
=
>
Err
(
IPCError
:
:
System
(
unsafe
{
GetLastError
(
)
}
)
)
_
=
>
Ok
(
(
)
)
}
}
pub
(
crate
)
fn
set_event
(
handle
:
BorrowedHandle
)
-
>
Result
<
(
)
IPCError
>
{
let
res
=
unsafe
{
SetEvent
(
handle
.
as_raw_handle
(
)
as
HANDLE
)
}
;
match
res
{
FALSE
=
>
Err
(
IPCError
:
:
System
(
unsafe
{
GetLastError
(
)
}
)
)
_
=
>
Ok
(
(
)
)
}
}
pub
(
crate
)
fn
cancel_overlapped_io
(
handle
:
BorrowedHandle
mut
overlapped
:
Box
<
OVERLAPPED
>
)
{
let
res
=
unsafe
{
CancelIoEx
(
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
.
as_mut
(
)
)
}
;
if
res
=
=
0
{
if
unsafe
{
GetLastError
(
)
}
!
=
ERROR_NOT_FOUND
{
let
_
=
Box
:
:
leak
(
overlapped
)
;
}
return
;
}
let
mut
number_of_bytes_transferred
:
u32
=
0
;
let
res
=
unsafe
{
GetOverlappedResult
(
handle
.
as_raw_handle
(
)
as
HANDLE
overlapped
.
as_mut
(
)
&
mut
number_of_bytes_transferred
TRUE
)
}
;
if
res
=
=
FALSE
{
let
_
=
Box
:
:
leak
(
overlapped
)
;
}
}
