use
crate
:
:
Pid
;
use
nix
:
:
{
errno
:
:
Errno
fcntl
:
:
{
fcntl
FcntlArg
:
:
{
F_GETFL
F_SETFD
F_SETFL
}
FdFlag
OFlag
}
libc
:
:
{
setsockopt
SOL_SOCKET
SO_NOSIGPIPE
}
sys
:
:
socket
:
:
{
socket
socketpair
AddressFamily
SockFlag
SockType
UnixAddr
}
Result
}
;
use
std
:
:
{
mem
:
:
size_of
os
:
:
fd
:
:
{
AsRawFd
BorrowedFd
OwnedFd
}
path
:
:
PathBuf
str
:
:
FromStr
}
;
pub
type
ProcessHandle
=
(
)
;
pub
(
crate
)
fn
unix_socket
(
)
-
>
Result
<
OwnedFd
>
{
socket
(
AddressFamily
:
:
Unix
SockType
:
:
Stream
SockFlag
:
:
empty
(
)
None
)
}
pub
(
crate
)
fn
unix_socketpair
(
)
-
>
Result
<
(
OwnedFd
OwnedFd
)
>
{
socketpair
(
AddressFamily
:
:
Unix
SockType
:
:
Stream
None
SockFlag
:
:
empty
(
)
)
}
pub
(
crate
)
fn
set_socket_default_flags
(
socket
:
BorrowedFd
)
-
>
Result
<
(
)
>
{
let
flags
=
OFlag
:
:
from_bits_retain
(
fcntl
(
socket
F_GETFL
)
?
)
;
fcntl
(
socket
F_SETFL
(
flags
.
union
(
OFlag
:
:
O_NONBLOCK
)
)
)
?
;
let
res
=
unsafe
{
setsockopt
(
socket
.
as_raw_fd
(
)
SOL_SOCKET
SO_NOSIGPIPE
(
&
1
as
*
const
i32
)
.
cast
(
)
size_of
:
:
<
i32
>
(
)
as
_
)
}
;
if
res
<
0
{
return
Err
(
Errno
:
:
last
(
)
)
;
}
Ok
(
(
)
)
}
pub
(
crate
)
fn
set_socket_cloexec
(
socket
:
BorrowedFd
)
-
>
Result
<
(
)
>
{
fcntl
(
socket
F_SETFD
(
FdFlag
:
:
FD_CLOEXEC
)
)
.
map
(
|
_res
|
(
)
)
}
pub
fn
server_addr
(
pid
:
Pid
)
-
>
Result
<
UnixAddr
>
{
let
server_name
=
format
!
(
"
/
tmp
/
gecko
-
crash
-
helper
-
pipe
.
{
pid
:
}
"
)
;
let
server_path
=
PathBuf
:
:
from_str
(
&
server_name
)
.
unwrap
(
)
;
UnixAddr
:
:
new
(
&
server_path
)
}
