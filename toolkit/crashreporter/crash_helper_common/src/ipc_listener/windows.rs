use
crate
:
:
{
errors
:
:
IPCError
platform
:
:
windows
:
:
{
create_manual_reset_event
server_addr
OverlappedOperation
}
IPCConnector
Pid
}
;
use
std
:
:
{
ffi
:
:
{
CStr
CString
OsString
}
os
:
:
windows
:
:
io
:
:
{
AsRawHandle
FromRawHandle
OwnedHandle
RawHandle
}
ptr
:
:
null_mut
rc
:
:
Rc
str
:
:
FromStr
}
;
use
windows_sys
:
:
Win32
:
:
{
Foundation
:
:
{
GetLastError
HANDLE
INVALID_HANDLE_VALUE
TRUE
}
Security
:
:
SECURITY_ATTRIBUTES
Storage
:
:
FileSystem
:
:
{
FILE_FLAG_FIRST_PIPE_INSTANCE
FILE_FLAG_OVERLAPPED
PIPE_ACCESS_DUPLEX
}
System
:
:
Pipes
:
:
{
CreateNamedPipeA
PIPE_READMODE_MESSAGE
PIPE_TYPE_MESSAGE
PIPE_UNLIMITED_INSTANCES
PIPE_WAIT
}
}
;
pub
struct
IPCListener
{
server_addr
:
CString
handle
:
Rc
<
OwnedHandle
>
overlapped
:
Option
<
OverlappedOperation
>
event
:
OwnedHandle
}
impl
IPCListener
{
pub
(
crate
)
fn
new
(
server_addr
:
CString
)
-
>
Result
<
IPCListener
IPCError
>
{
let
pipe
=
create_named_pipe
(
&
server_addr
true
)
?
;
let
event
=
create_manual_reset_event
(
)
?
;
Ok
(
IPCListener
{
server_addr
handle
:
Rc
:
:
new
(
pipe
)
overlapped
:
None
event
}
)
}
pub
fn
event_raw_handle
(
&
self
)
-
>
HANDLE
{
self
.
event
.
as_raw_handle
(
)
as
HANDLE
}
pub
(
crate
)
fn
address
(
&
self
)
-
>
&
CStr
{
&
self
.
server_addr
}
pub
(
crate
)
fn
listen
(
&
mut
self
)
-
>
Result
<
(
)
IPCError
>
{
self
.
overlapped
=
Some
(
OverlappedOperation
:
:
listen
(
&
self
.
handle
self
.
event_raw_handle
(
)
)
?
)
;
Ok
(
(
)
)
}
pub
fn
accept
(
&
mut
self
)
-
>
Result
<
IPCConnector
IPCError
>
{
let
connected_pipe
=
{
let
overlapped
=
self
.
overlapped
.
take
(
)
.
expect
(
"
Accepting
a
connection
without
listening
first
"
)
;
overlapped
.
accept
(
self
.
handle
.
as_raw_handle
(
)
as
HANDLE
)
?
;
let
new_pipe
=
create_named_pipe
(
&
self
.
server_addr
false
)
?
;
std
:
:
mem
:
:
replace
(
&
mut
self
.
handle
Rc
:
:
new
(
new_pipe
)
)
}
;
self
.
listen
(
)
?
;
IPCConnector
:
:
from_ancillary
(
Rc
:
:
<
OwnedHandle
>
:
:
try_unwrap
(
connected_pipe
)
.
unwrap
(
)
)
}
pub
fn
serialize
(
&
self
)
-
>
OsString
{
let
raw_handle
=
self
.
handle
.
as_raw_handle
(
)
as
usize
;
OsString
:
:
from_str
(
raw_handle
.
to_string
(
)
.
as_ref
(
)
)
.
unwrap
(
)
}
pub
fn
deserialize
(
string
:
&
CStr
pid
:
Pid
)
-
>
Result
<
IPCListener
IPCError
>
{
let
server_addr
=
server_addr
(
pid
)
;
let
string
=
string
.
to_str
(
)
.
map_err
(
|
_e
|
IPCError
:
:
ParseError
)
?
;
let
handle
=
usize
:
:
from_str
(
string
)
.
map_err
(
|
_e
|
IPCError
:
:
ParseError
)
?
;
let
handle
=
unsafe
{
OwnedHandle
:
:
from_raw_handle
(
handle
as
RawHandle
)
}
;
let
event
=
create_manual_reset_event
(
)
?
;
let
mut
listener
=
IPCListener
{
server_addr
handle
:
Rc
:
:
new
(
handle
)
overlapped
:
None
event
}
;
listener
.
listen
(
)
?
;
Ok
(
listener
)
}
}
unsafe
impl
Send
for
IPCListener
{
}
fn
create_named_pipe
(
server_addr
:
&
CStr
first_instance
:
bool
)
-
>
Result
<
OwnedHandle
IPCError
>
{
const
PIPE_BUFFER_SIZE
:
u32
=
4096
;
let
open_mode
=
PIPE_ACCESS_DUPLEX
|
FILE_FLAG_OVERLAPPED
|
if
first_instance
{
FILE_FLAG_FIRST_PIPE_INSTANCE
}
else
{
0
}
;
let
security_attributes
=
SECURITY_ATTRIBUTES
{
nLength
:
size_of
:
:
<
SECURITY_ATTRIBUTES
>
(
)
as
u32
lpSecurityDescriptor
:
null_mut
(
)
bInheritHandle
:
TRUE
}
;
let
pipe
=
unsafe
{
CreateNamedPipeA
(
server_addr
.
as_ptr
(
)
as
*
const
_
open_mode
PIPE_TYPE_MESSAGE
|
PIPE_READMODE_MESSAGE
|
PIPE_WAIT
PIPE_UNLIMITED_INSTANCES
PIPE_BUFFER_SIZE
PIPE_BUFFER_SIZE
0
&
security_attributes
)
}
;
if
pipe
=
=
INVALID_HANDLE_VALUE
{
return
Err
(
IPCError
:
:
System
(
unsafe
{
GetLastError
(
)
}
)
)
;
}
Ok
(
unsafe
{
OwnedHandle
:
:
from_raw_handle
(
pipe
as
RawHandle
)
}
)
}
