use
crate
:
:
{
errors
:
:
IPCError
platform
:
:
windows
:
:
{
create_manual_reset_event
reset_event
server_name
set_event
}
IPCConnector
Pid
}
;
use
std
:
:
{
ffi
:
:
{
c_void
CStr
OsString
}
mem
:
:
zeroed
os
:
:
windows
:
:
io
:
:
{
AsHandle
AsRawHandle
FromRawHandle
OwnedHandle
RawHandle
}
ptr
:
:
null_mut
str
:
:
FromStr
}
;
use
windows_sys
:
:
Win32
:
:
{
Foundation
:
:
{
GetLastError
ERROR_IO_PENDING
ERROR_PIPE_CONNECTED
FALSE
HANDLE
INVALID_HANDLE_VALUE
TRUE
}
Security
:
:
SECURITY_ATTRIBUTES
Storage
:
:
FileSystem
:
:
{
FILE_FLAG_FIRST_PIPE_INSTANCE
FILE_FLAG_OVERLAPPED
PIPE_ACCESS_DUPLEX
}
System
:
:
{
Pipes
:
:
{
ConnectNamedPipe
CreateNamedPipeA
PIPE_READMODE_MESSAGE
PIPE_TYPE_MESSAGE
PIPE_UNLIMITED_INSTANCES
PIPE_WAIT
}
IO
:
:
{
GetOverlappedResult
OVERLAPPED
}
}
}
;
pub
struct
IPCListener
{
server_name
:
String
handle
:
OwnedHandle
overlapped
:
Box
<
OVERLAPPED
>
event
:
OwnedHandle
connected
:
bool
}
impl
IPCListener
{
pub
fn
new
(
pid
:
Pid
)
-
>
Result
<
IPCListener
IPCError
>
{
let
server_name
=
server_name
(
pid
)
;
let
pipe
=
create_named_pipe
(
&
server_name
true
)
?
;
let
event
=
create_manual_reset_event
(
)
?
;
Ok
(
IPCListener
{
server_name
handle
:
pipe
overlapped
:
Box
:
:
new
(
unsafe
{
zeroed
(
)
}
)
event
connected
:
false
}
)
}
pub
fn
event_raw_handle
(
&
self
)
-
>
HANDLE
{
self
.
event
.
as_raw_handle
(
)
as
HANDLE
}
pub
fn
listen
(
&
mut
self
)
-
>
Result
<
(
)
IPCError
>
{
reset_event
(
self
.
event
.
as_handle
(
)
)
?
;
*
self
.
overlapped
.
as_mut
(
)
=
OVERLAPPED
{
hEvent
:
self
.
event
.
as_raw_handle
(
)
as
HANDLE
.
.
unsafe
{
zeroed
(
)
}
}
;
let
res
=
unsafe
{
ConnectNamedPipe
(
self
.
handle
.
as_raw_handle
(
)
as
HANDLE
self
.
overlapped
.
as_mut
(
)
)
}
;
let
error
=
unsafe
{
GetLastError
(
)
}
;
if
res
!
=
FALSE
{
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
match
error
{
ERROR_IO_PENDING
=
>
Ok
(
(
)
)
ERROR_PIPE_CONNECTED
=
>
{
set_event
(
self
.
event
.
as_handle
(
)
)
?
;
self
.
connected
=
true
;
Ok
(
(
)
)
}
_
=
>
Err
(
IPCError
:
:
System
(
error
)
)
}
}
pub
fn
accept
(
&
mut
self
)
-
>
Result
<
IPCConnector
IPCError
>
{
if
!
self
.
connected
{
let
mut
_number_of_bytes_transferred
:
u32
=
0
;
let
res
=
unsafe
{
GetOverlappedResult
(
self
.
handle
.
as_raw_handle
(
)
as
HANDLE
self
.
overlapped
.
as_ref
(
)
&
mut
_number_of_bytes_transferred
FALSE
)
}
;
let
error
=
unsafe
{
GetLastError
(
)
}
;
if
res
=
=
FALSE
{
return
Err
(
IPCError
:
:
System
(
error
)
)
;
}
}
self
.
connected
=
false
;
let
new_pipe
=
create_named_pipe
(
&
self
.
server_name
false
)
?
;
let
connected_pipe
=
std
:
:
mem
:
:
replace
(
&
mut
self
.
handle
new_pipe
)
;
self
.
listen
(
)
?
;
IPCConnector
:
:
new
(
connected_pipe
)
}
pub
fn
serialize
(
&
self
)
-
>
OsString
{
let
raw_handle
=
self
.
handle
.
as_raw_handle
(
)
as
usize
;
OsString
:
:
from_str
(
raw_handle
.
to_string
(
)
.
as_ref
(
)
)
.
unwrap
(
)
}
pub
fn
deserialize
(
string
:
&
CStr
pid
:
Pid
)
-
>
Result
<
IPCListener
IPCError
>
{
let
server_name
=
server_name
(
pid
)
;
let
string
=
string
.
to_str
(
)
.
map_err
(
|
_e
|
IPCError
:
:
ParseError
)
?
;
let
handle
=
usize
:
:
from_str
(
string
)
.
map_err
(
|
_e
|
IPCError
:
:
ParseError
)
?
;
let
handle
=
handle
as
*
mut
c_void
;
let
handle
=
unsafe
{
OwnedHandle
:
:
from_raw_handle
(
handle
)
}
;
let
event
=
create_manual_reset_event
(
)
?
;
let
mut
listener
=
IPCListener
{
server_name
handle
overlapped
:
Box
:
:
new
(
unsafe
{
zeroed
(
)
}
)
event
connected
:
false
}
;
listener
.
listen
(
)
?
;
return
Ok
(
listener
)
;
}
}
unsafe
impl
Send
for
IPCListener
{
}
fn
create_named_pipe
(
server_name
:
&
str
first_instance
:
bool
)
-
>
Result
<
OwnedHandle
IPCError
>
{
const
PIPE_BUFFER_SIZE
:
u32
=
4096
;
let
open_mode
=
PIPE_ACCESS_DUPLEX
|
FILE_FLAG_OVERLAPPED
|
if
first_instance
{
FILE_FLAG_FIRST_PIPE_INSTANCE
}
else
{
0
}
;
let
security_attributes
=
SECURITY_ATTRIBUTES
{
nLength
:
size_of
:
:
<
SECURITY_ATTRIBUTES
>
(
)
as
u32
lpSecurityDescriptor
:
null_mut
(
)
bInheritHandle
:
TRUE
}
;
let
pipe
=
unsafe
{
CreateNamedPipeA
(
server_name
.
as_ptr
(
)
open_mode
PIPE_TYPE_MESSAGE
|
PIPE_READMODE_MESSAGE
|
PIPE_WAIT
PIPE_UNLIMITED_INSTANCES
PIPE_BUFFER_SIZE
PIPE_BUFFER_SIZE
0
&
security_attributes
)
}
;
if
pipe
=
=
INVALID_HANDLE_VALUE
{
return
Err
(
IPCError
:
:
System
(
unsafe
{
GetLastError
(
)
}
)
)
;
}
Ok
(
unsafe
{
OwnedHandle
:
:
from_raw_handle
(
pipe
as
RawHandle
)
}
)
}
