#
ifndef
nsExceptionHandler_h__
#
define
nsExceptionHandler_h__
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
if
!
defined
(
XP_WIN
)
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
endif
#
include
"
CrashAnnotations
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
if
defined
(
XP_WIN
)
#
include
<
handleapi
.
h
>
#
elif
defined
(
XP_MACOSX
)
#
include
<
mach
/
mach
.
h
>
#
elif
defined
(
XP_LINUX
)
#
include
<
signal
.
h
>
#
endif
class
nsIFile
;
namespace
CrashReporter
{
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
#
if
defined
(
XP_WIN
)
typedef
HANDLE
ProcessHandle
;
typedef
DWORD
ProcessId
;
typedef
DWORD
ThreadId
;
typedef
HANDLE
FileHandle
;
const
FileHandle
kInvalidFileHandle
=
INVALID_HANDLE_VALUE
;
#
elif
defined
(
XP_MACOSX
)
typedef
task_t
ProcessHandle
;
typedef
pid_t
ProcessId
;
typedef
mach_port_t
ThreadId
;
typedef
int
FileHandle
;
const
FileHandle
kInvalidFileHandle
=
-
1
;
#
else
typedef
int
ProcessHandle
;
typedef
pid_t
ProcessId
;
typedef
int
ThreadId
;
typedef
int
FileHandle
;
const
FileHandle
kInvalidFileHandle
=
-
1
;
#
endif
static
inline
bool
IsDummy
(
)
{
#
ifdef
MOZ_CRASHREPORTER
return
false
;
#
else
return
true
;
#
endif
}
nsresult
SetExceptionHandler
(
nsIFile
*
aXREDirectory
bool
force
=
false
)
;
nsresult
UnsetExceptionHandler
(
)
;
void
SetUserAppDataDirectory
(
nsIFile
*
aDir
)
;
void
SetProfileDirectory
(
nsIFile
*
aDir
)
;
void
UpdateCrashEventsDir
(
)
;
void
SetMemoryReportFile
(
nsIFile
*
aFile
)
;
nsresult
GetDefaultMemoryReportFile
(
nsIFile
*
*
aFile
)
;
bool
GetCrashEventsDir
(
nsAString
&
aPath
)
;
bool
GetEnabled
(
)
;
bool
GetServerURL
(
nsACString
&
aServerURL
)
;
nsresult
SetServerURL
(
const
nsACString
&
aServerURL
)
;
bool
GetMinidumpPath
(
nsAString
&
aPath
)
;
nsresult
SetMinidumpPath
(
const
nsAString
&
aPath
)
;
const
bool
*
RegisterAnnotationBool
(
Annotation
aKey
const
bool
*
aData
)
;
const
uint32_t
*
RegisterAnnotationU32
(
Annotation
aKey
const
uint32_t
*
aData
)
;
const
uint64_t
*
RegisterAnnotationU64
(
Annotation
aKey
const
uint64_t
*
aData
)
;
const
size_t
*
RegisterAnnotationUSize
(
Annotation
aKey
const
size_t
*
aData
)
;
const
char
*
RegisterAnnotationCString
(
Annotation
aKey
const
char
*
aData
)
;
const
nsCString
*
RegisterAnnotationNSCString
(
Annotation
aKey
const
nsCString
*
aData
)
;
nsresult
RecordAnnotationBool
(
Annotation
aKey
bool
aData
)
;
nsresult
RecordAnnotationU32
(
Annotation
aKey
uint32_t
aData
)
;
nsresult
RecordAnnotationU64
(
Annotation
aKey
uint64_t
aData
)
;
nsresult
RecordAnnotationUSize
(
Annotation
aKey
size_t
aData
)
;
nsresult
RecordAnnotationCString
(
Annotation
aKey
const
char
*
aData
)
;
nsresult
RecordAnnotationNSCString
(
Annotation
aKey
const
nsACString
&
aData
)
;
nsresult
RecordAnnotationNSString
(
Annotation
aKey
const
nsAString
&
aData
)
;
nsresult
UnrecordAnnotation
(
Annotation
aKey
)
;
nsresult
AppendAppNotesToCrashReport
(
const
nsACString
&
data
)
;
class
MOZ_RAII
AutoRecordAnnotation
final
{
public
:
AutoRecordAnnotation
(
Annotation
key
bool
data
)
;
AutoRecordAnnotation
(
Annotation
key
int
data
)
;
AutoRecordAnnotation
(
Annotation
key
unsigned
int
data
)
;
AutoRecordAnnotation
(
Annotation
key
const
nsACString
&
data
)
;
~
AutoRecordAnnotation
(
)
;
#
ifdef
MOZ_CRASHREPORTER
private
:
Annotation
mKey
;
const
nsCString
mCurrent
;
const
nsCString
*
mPrevious
;
#
endif
}
;
void
AnnotateOOMAllocationSize
(
size_t
size
)
;
void
AnnotateTexturesSize
(
size_t
size
)
;
nsresult
SetGarbageCollecting
(
bool
collecting
)
;
void
SetEventloopNestingLevel
(
uint32_t
level
)
;
void
SetMinidumpAnalysisAllThreads
(
)
;
void
ClearInactiveStateStart
(
)
;
void
SetInactiveStateStart
(
)
;
nsresult
SetRestartArgs
(
int
argc
char
*
*
argv
)
;
nsresult
SetupExtraData
(
nsIFile
*
aAppDataDirectory
const
nsACString
&
aBuildID
)
;
nsresult
RegisterAppMemory
(
void
*
ptr
size_t
length
)
;
nsresult
UnregisterAppMemory
(
void
*
ptr
)
;
void
SetIncludeContextHeap
(
bool
aValue
)
;
void
GetAnnotation
(
ProcessId
childPid
Annotation
annotation
nsACString
&
outStr
)
;
typedef
mozilla
:
:
EnumeratedArray
<
Annotation
nsCString
size_t
(
Annotation
:
:
Count
)
>
AnnotationTable
;
void
DeleteMinidumpFilesForID
(
const
nsAString
&
aId
const
Maybe
<
nsString
>
&
aAdditionalMinidump
=
Nothing
(
)
)
;
bool
GetMinidumpForID
(
const
nsAString
&
id
nsIFile
*
*
minidump
const
Maybe
<
nsString
>
&
aAdditionalMinidump
=
Nothing
(
)
)
;
bool
GetIDFromMinidump
(
nsIFile
*
minidump
nsAString
&
id
)
;
bool
GetExtraFileForID
(
const
nsAString
&
id
nsIFile
*
*
extraFile
)
;
bool
GetExtraFileForMinidump
(
nsIFile
*
minidump
nsIFile
*
*
extraFile
)
;
bool
WriteExtraFile
(
const
nsAString
&
id
const
AnnotationTable
&
annotations
)
;
void
MergeCrashAnnotations
(
AnnotationTable
&
aDst
const
AnnotationTable
&
aSrc
)
;
#
ifdef
XP_WIN
nsresult
WriteMinidumpForException
(
EXCEPTION_POINTERS
*
aExceptionInfo
)
;
#
endif
#
ifdef
XP_LINUX
bool
WriteMinidumpForSigInfo
(
int
signo
siginfo_t
*
info
void
*
uc
)
;
#
endif
#
ifdef
XP_MACOSX
nsresult
AppendObjCExceptionInfoToAppNotes
(
void
*
inException
)
;
#
endif
nsresult
GetSubmitReports
(
bool
*
aSubmitReport
)
;
nsresult
SetSubmitReports
(
bool
aSubmitReport
)
;
#
ifdef
XP_WIN
struct
WindowsErrorReportingData
{
DWORD
mChildPid
;
char
mMinidumpFile
[
40
]
;
}
;
#
endif
void
OOPInit
(
)
;
bool
TakeMinidumpForChild
(
ProcessId
childPid
nsIFile
*
*
dump
AnnotationTable
&
aAnnotations
)
;
[
[
nodiscard
]
]
bool
FinalizeOrphanedMinidump
(
ProcessId
aChildPid
GeckoProcessType
aType
nsString
*
aDumpId
=
nullptr
)
;
ThreadId
CurrentThreadId
(
)
;
bool
CreateMinidumpsAndPair
(
ProcessHandle
aTargetPid
ThreadId
aTargetBlamedThread
const
nsACString
&
aIncomingPairName
AnnotationTable
&
aTargetAnnotations
nsIFile
*
*
aTargetDumpOut
)
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
using
CrashPipeType
=
const
char
*
;
#
else
using
CrashPipeType
=
mozilla
:
:
UniqueFileHandle
;
#
endif
CrashPipeType
GetChildNotificationPipe
(
)
;
bool
SetRemoteExceptionHandler
(
CrashPipeType
aCrashPipe
)
;
bool
UnsetRemoteExceptionHandler
(
bool
wasSet
=
true
)
;
}
#
endif
