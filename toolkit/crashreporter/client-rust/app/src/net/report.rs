use
crate
:
:
std
:
:
{
ffi
:
:
OsStr
path
:
:
Path
process
:
:
Child
}
;
use
anyhow
:
:
Context
;
pub
const
USER_AGENT
:
&
str
=
concat
!
(
env
!
(
"
CARGO_PKG_NAME
"
)
"
/
"
env
!
(
"
CARGO_PKG_VERSION
"
)
)
;
pub
struct
CrashReport
<
'
a
>
{
pub
extra
:
&
'
a
serde_json
:
:
Value
pub
dump_file
:
&
'
a
Path
pub
memory_file
:
Option
<
&
'
a
Path
>
pub
url
:
&
'
a
OsStr
}
impl
CrashReport
<
'
_
>
{
pub
fn
send
(
&
self
)
-
>
std
:
:
io
:
:
Result
<
CrashReportSender
>
{
let
extra_json_data
=
serde_json
:
:
to_string
(
self
.
extra
)
?
;
self
.
send_with_curl_binary
(
extra_json_data
.
clone
(
)
)
.
or_else
(
|
e
|
{
log
:
:
info
!
(
"
failed
to
invoke
curl
(
{
e
}
)
trying
libcurl
"
)
;
self
.
send_with_libcurl
(
extra_json_data
.
clone
(
)
)
}
)
}
fn
send_with_curl_binary
(
&
self
extra_json_data
:
String
)
-
>
std
:
:
io
:
:
Result
<
CrashReportSender
>
{
let
mut
cmd
=
crate
:
:
process
:
:
background_command
(
"
curl
"
)
;
cmd
.
args
(
[
"
-
-
user
-
agent
"
USER_AGENT
]
)
;
cmd
.
arg
(
"
-
-
form
"
)
;
cmd
.
arg
(
"
extra
=
-
;
filename
=
extra
.
json
;
type
=
application
/
json
"
)
;
cmd
.
arg
(
"
-
-
form
"
)
;
cmd
.
arg
(
format
!
(
"
upload_file_minidump
=
{
}
"
CurlQuote
(
&
self
.
dump_file
.
display
(
)
.
to_string
(
)
)
)
)
;
if
let
Some
(
path
)
=
self
.
memory_file
{
cmd
.
arg
(
"
-
-
form
"
)
;
cmd
.
arg
(
format
!
(
"
memory_report
=
{
}
"
CurlQuote
(
&
path
.
display
(
)
.
to_string
(
)
)
)
)
;
}
cmd
.
arg
(
self
.
url
)
;
cmd
.
stdin
(
std
:
:
process
:
:
Stdio
:
:
piped
(
)
)
;
cmd
.
stdout
(
std
:
:
process
:
:
Stdio
:
:
piped
(
)
)
;
cmd
.
stderr
(
std
:
:
process
:
:
Stdio
:
:
piped
(
)
)
;
cmd
.
spawn
(
)
.
map
(
move
|
child
|
CrashReportSender
:
:
CurlChild
{
child
extra_json_data
}
)
}
fn
send_with_libcurl
(
&
self
extra_json_data
:
String
)
-
>
std
:
:
io
:
:
Result
<
CrashReportSender
>
{
let
curl
=
super
:
:
libcurl
:
:
load
(
)
?
;
let
mut
easy
=
curl
.
easy
(
)
?
;
easy
.
set_url
(
&
self
.
url
.
to_string_lossy
(
)
)
?
;
easy
.
set_user_agent
(
USER_AGENT
)
?
;
easy
.
set_max_redirs
(
30
)
?
;
let
mut
mime
=
easy
.
mime
(
)
?
;
{
let
mut
part
=
mime
.
add_part
(
)
?
;
part
.
set_name
(
"
extra
"
)
?
;
part
.
set_filename
(
"
extra
.
json
"
)
?
;
part
.
set_type
(
"
application
/
json
"
)
?
;
part
.
set_data
(
extra_json_data
.
as_bytes
(
)
)
?
;
}
{
let
mut
part
=
mime
.
add_part
(
)
?
;
part
.
set_name
(
"
upload_file_minidump
"
)
?
;
part
.
set_filename
(
&
self
.
dump_file
.
display
(
)
.
to_string
(
)
)
?
;
part
.
set_filedata
(
self
.
dump_file
)
?
;
}
if
let
Some
(
path
)
=
self
.
memory_file
{
let
mut
part
=
mime
.
add_part
(
)
?
;
part
.
set_name
(
"
memory_report
"
)
?
;
part
.
set_filename
(
&
path
.
display
(
)
.
to_string
(
)
)
?
;
part
.
set_filedata
(
path
)
?
;
}
easy
.
set_mime_post
(
mime
)
?
;
Ok
(
CrashReportSender
:
:
LibCurl
{
easy
}
)
}
}
pub
enum
CrashReportSender
{
CurlChild
{
child
:
Child
extra_json_data
:
String
}
LibCurl
{
easy
:
super
:
:
libcurl
:
:
Easy
<
'
static
>
}
}
impl
CrashReportSender
{
pub
fn
finish
(
self
)
-
>
anyhow
:
:
Result
<
Response
>
{
let
response
=
match
self
{
Self
:
:
CurlChild
{
mut
child
extra_json_data
}
=
>
{
{
let
mut
stdin
=
child
.
stdin
.
take
(
)
.
context
(
"
failed
to
get
curl
process
stdin
"
)
?
;
std
:
:
io
:
:
copy
(
&
mut
std
:
:
io
:
:
Cursor
:
:
new
(
extra_json_data
)
&
mut
stdin
)
.
context
(
"
failed
to
write
extra
file
data
to
stdin
of
curl
process
"
)
?
;
}
let
output
=
child
.
wait_with_output
(
)
.
context
(
"
failed
to
wait
on
curl
process
"
)
?
;
anyhow
:
:
ensure
!
(
output
.
status
.
success
(
)
"
process
failed
(
exit
status
{
}
)
with
stderr
:
{
}
"
output
.
status
String
:
:
from_utf8_lossy
(
&
output
.
stderr
)
)
;
String
:
:
from_utf8_lossy
(
&
output
.
stdout
)
.
into_owned
(
)
}
Self
:
:
LibCurl
{
easy
}
=
>
{
let
response
=
easy
.
perform
(
)
?
;
let
response_code
=
easy
.
get_response_code
(
)
?
;
let
response
=
String
:
:
from_utf8_lossy
(
&
response
)
.
into_owned
(
)
;
dbg
!
(
&
response
&
response_code
)
;
anyhow
:
:
ensure
!
(
response_code
=
=
200
"
unexpected
response
code
(
{
response_code
}
)
:
{
response
}
"
)
;
response
}
}
;
log
:
:
debug
!
(
"
received
response
from
sending
report
:
{
:
?
}
"
&
*
response
)
;
Ok
(
Response
:
:
parse
(
response
)
)
}
}
#
[
derive
(
Default
Debug
)
]
pub
struct
Response
{
pub
crash_id
:
Option
<
String
>
pub
stop_sending_reports_for
:
Option
<
String
>
pub
view_url
:
Option
<
String
>
pub
discarded
:
bool
}
impl
Response
{
fn
parse
<
S
:
AsRef
<
str
>
>
(
response
:
S
)
-
>
Self
{
let
mut
ret
=
Self
:
:
default
(
)
;
for
line
in
response
.
as_ref
(
)
.
lines
(
)
{
if
let
Some
(
(
key
value
)
)
=
line
.
split_once
(
'
=
'
)
{
match
key
{
"
StopSendingReportsFor
"
=
>
{
ret
.
stop_sending_reports_for
=
Some
(
value
.
to_owned
(
)
)
}
"
Discarded
"
=
>
ret
.
discarded
=
true
"
CrashID
"
=
>
ret
.
crash_id
=
Some
(
value
.
to_owned
(
)
)
"
ViewURL
"
=
>
ret
.
view_url
=
Some
(
value
.
to_owned
(
)
)
_
=
>
(
)
}
}
}
ret
}
}
struct
CurlQuote
<
'
a
>
(
&
'
a
str
)
;
impl
std
:
:
fmt
:
:
Display
for
CurlQuote
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
use
std
:
:
fmt
:
:
Write
;
f
.
write_char
(
'
"
'
)
?
;
const
ESCAPE_CHARS
:
[
char
;
2
]
=
[
'
"
'
'
\
\
'
]
;
for
substr
in
self
.
0
.
split_inclusive
(
ESCAPE_CHARS
)
{
if
substr
.
ends_with
(
ESCAPE_CHARS
)
{
let
(
s
escape
)
=
substr
.
split_at
(
substr
.
len
(
)
-
1
)
;
f
.
write_str
(
s
)
?
;
f
.
write_char
(
'
\
\
'
)
?
;
f
.
write_str
(
escape
)
?
;
}
else
{
f
.
write_str
(
substr
)
?
;
}
}
f
.
write_char
(
'
"
'
)
}
}
