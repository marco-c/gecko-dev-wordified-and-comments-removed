use
std
:
:
{
env
path
:
:
Path
}
;
fn
main
(
)
{
windows_manifest
(
)
;
crash_annotations
(
)
;
set_mock_cfg
(
)
;
set_glean_metrics_file
(
)
;
generate_buildid_section
(
)
;
}
fn
windows_manifest
(
)
{
use
embed_manifest
:
:
{
embed_manifest
manifest
new_manifest
}
;
if
std
:
:
env
:
:
var_os
(
"
CARGO_CFG_WINDOWS
"
)
.
is_none
(
)
{
return
;
}
let
manifest
=
new_manifest
(
"
CrashReporter
"
)
.
active_code_page
(
manifest
:
:
ActiveCodePage
:
:
Legacy
)
.
dpi_awareness
(
manifest
:
:
DpiAwareness
:
:
PerMonitorV2
)
;
embed_manifest
(
manifest
)
.
expect
(
"
unable
to
embed
windows
manifest
file
"
)
;
println
!
(
"
cargo
:
rerun
-
if
-
changed
=
build
.
rs
"
)
;
}
fn
crash_annotations
(
)
{
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
BufWriter
Write
}
;
use
yaml_rust
:
:
{
Yaml
YamlLoader
}
;
let
crash_annotations
=
Path
:
:
new
(
"
.
.
/
.
.
/
CrashAnnotations
.
yaml
"
)
.
canonicalize
(
)
.
unwrap
(
)
;
println
!
(
"
cargo
:
rerun
-
if
-
changed
=
{
}
"
crash_annotations
.
display
(
)
)
;
let
crash_ping_file
=
Path
:
:
new
(
&
env
:
:
var
(
"
OUT_DIR
"
)
.
unwrap
(
)
)
.
join
(
"
crash_annotations
.
rs
"
)
;
let
yaml
=
std
:
:
fs
:
:
read_to_string
(
crash_annotations
)
.
unwrap
(
)
;
let
Yaml
:
:
Hash
(
entries
)
=
YamlLoader
:
:
load_from_str
(
&
yaml
)
.
unwrap
(
)
.
into_iter
(
)
.
next
(
)
.
unwrap
(
)
else
{
panic
!
(
"
unexpected
crash
annotations
root
type
"
)
;
}
;
let
mut
ping_annotations
=
phf_codegen
:
:
Set
:
:
new
(
)
;
let
mut
report_annotations
=
phf_codegen
:
:
Set
:
:
new
(
)
;
for
(
k
v
)
in
entries
{
let
scope
=
v
[
"
scope
"
]
.
as_str
(
)
.
unwrap_or
(
"
client
"
)
;
match
scope
{
"
ping
"
=
>
{
ping_annotations
.
entry
(
k
.
into_string
(
)
.
unwrap
(
)
)
;
}
"
report
"
=
>
{
report_annotations
.
entry
(
k
.
into_string
(
)
.
unwrap
(
)
)
;
}
_
=
>
(
)
}
}
let
mut
file
=
BufWriter
:
:
new
(
File
:
:
create
(
&
crash_ping_file
)
.
unwrap
(
)
)
;
writeln
!
(
&
mut
file
"
static
PING_ANNOTATIONS
:
phf
:
:
Set
<
&
'
static
str
>
=
{
}
;
"
ping_annotations
.
build
(
)
)
.
unwrap
(
)
;
writeln
!
(
&
mut
file
"
static
REPORT_ANNOTATIONS
:
phf
:
:
Set
<
&
'
static
str
>
=
{
}
;
"
report_annotations
.
build
(
)
)
.
unwrap
(
)
;
}
fn
set_mock_cfg
(
)
{
println
!
(
"
cargo
:
rustc
-
check
-
cfg
=
cfg
(
mock
)
"
)
;
if
env
:
:
var_os
(
"
CARGO_FEATURE_MOCK
"
)
.
is_some
(
)
|
|
mozbuild
:
:
config
:
:
MOZ_CRASHREPORTER_MOCK
{
println
!
(
"
cargo
:
rustc
-
cfg
=
mock
"
)
;
}
}
fn
set_glean_metrics_file
(
)
{
let
full_path
=
Path
:
:
new
(
env
!
(
"
CARGO_MANIFEST_DIR
"
)
)
;
let
relative_path
=
full_path
.
strip_prefix
(
mozbuild
:
:
TOPSRCDIR
)
.
expect
(
"
CARGO_MANIFEST_DIR
not
a
child
of
TOPSRCDIR
"
)
;
let
glean_metrics_path
=
{
let
mut
p
=
mozbuild
:
:
TOPOBJDIR
.
join
(
relative_path
)
;
p
.
push
(
"
glean_metrics
.
rs
"
)
;
p
}
;
println
!
(
"
cargo
:
rustc
-
env
=
GLEAN_METRICS_FILE
=
{
}
"
glean_metrics_path
.
display
(
)
)
;
}
fn
generate_buildid_section
(
)
{
use
mozbuild
:
:
config
:
:
BINDGEN_SYSTEM_FLAGS
as
CFLAGS
;
let
defines
=
if
cfg
!
(
target_os
=
"
macos
"
)
{
"
#
define
XP_DARWIN
"
}
else
if
cfg
!
(
target_os
=
"
windows
"
)
{
"
#
define
XP_WIN
"
}
else
{
"
"
}
;
let
bindings
=
bindgen
:
:
Builder
:
:
default
(
)
.
header_contents
(
"
defines
.
h
"
defines
)
.
header
(
format
!
(
"
{
}
/
toolkit
/
library
/
buildid_section
.
h
"
mozbuild
:
:
TOPSRCDIR
.
display
(
)
)
)
.
clang_args
(
CFLAGS
)
.
generate_cstr
(
true
)
.
generate
(
)
.
expect
(
"
unable
to
generate
buildid_section
.
h
"
)
;
let
out_path
=
std
:
:
path
:
:
PathBuf
:
:
from
(
std
:
:
env
:
:
var
(
"
OUT_DIR
"
)
.
unwrap
(
)
)
;
bindings
.
write_to_file
(
out_path
.
join
(
"
buildid_section
.
rs
"
)
)
.
expect
(
"
failed
to
write
buildid
section
"
)
;
}
