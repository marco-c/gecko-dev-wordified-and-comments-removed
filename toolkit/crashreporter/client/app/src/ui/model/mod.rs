use
crate
:
:
data
:
:
Property
;
pub
use
button
:
:
Button
;
pub
use
checkbox
:
:
Checkbox
;
pub
use
hbox
:
:
HBox
;
pub
use
label
:
:
Label
;
pub
use
progress
:
:
Progress
;
pub
use
scroll
:
:
Scroll
;
pub
use
textbox
:
:
TextBox
;
pub
use
vbox
:
:
VBox
;
pub
use
window
:
:
Window
;
mod
button
;
mod
checkbox
;
mod
hbox
;
mod
label
;
mod
progress
;
mod
scroll
;
mod
textbox
;
mod
vbox
;
mod
window
;
#
[
derive
(
Debug
)
]
pub
struct
Element
{
pub
style
:
ElementStyle
pub
element_type
:
ElementType
}
macro_rules
!
element_types
{
(
(
name
:
ident
)
*
)
=
>
{
/
/
/
A
type
of
GUI
element
.
#
[
derive
(
Debug
)
]
pub
enum
ElementType
{
(
name
(
name
)
)
*
}
(
impl
From
<
name
>
for
ElementType
{
fn
from
(
e
:
name
)
-
>
ElementType
{
ElementType
:
:
name
(
e
)
}
}
impl
TryFrom
<
ElementType
>
for
name
{
type
Error
=
&
'
static
str
;
fn
try_from
(
et
:
ElementType
)
-
>
Result
<
Self
Self
:
:
Error
>
{
if
let
ElementType
:
:
name
(
v
)
=
et
{
Ok
(
v
)
}
else
{
Err
(
concat
!
(
"
ElementType
was
not
"
stringify
!
(
name
)
)
)
}
}
}
impl
<
'
a
>
TryFrom
<
&
'
a
ElementType
>
for
&
'
a
name
{
type
Error
=
&
'
static
str
;
fn
try_from
(
et
:
&
'
a
ElementType
)
-
>
Result
<
Self
Self
:
:
Error
>
{
if
let
ElementType
:
:
name
(
v
)
=
et
{
Ok
(
v
)
}
else
{
Err
(
concat
!
(
"
ElementType
was
not
"
stringify
!
(
name
)
)
)
}
}
}
impl
From
<
ElementBuilder
<
name
>
>
for
Element
{
fn
from
(
b
:
ElementBuilder
<
name
>
)
-
>
Self
{
Element
{
style
:
b
.
style
element_type
:
b
.
element_type
.
into
(
)
}
}
}
)
*
}
}
element_types
!
{
Button
Checkbox
HBox
Label
Progress
Scroll
TextBox
VBox
}
#
[
derive
(
Debug
)
]
pub
struct
ElementStyle
{
pub
horizontal_alignment
:
Alignment
pub
vertical_alignment
:
Alignment
pub
horizontal_size_request
:
Option
<
u32
>
pub
vertical_size_request
:
Option
<
u32
>
pub
margin
:
Margin
pub
visible
:
Property
<
bool
>
pub
enabled
:
Property
<
bool
>
#
[
cfg
(
test
)
]
pub
id
:
Option
<
String
>
}
impl
Default
for
ElementStyle
{
fn
default
(
)
-
>
Self
{
ElementStyle
{
horizontal_alignment
:
Default
:
:
default
(
)
vertical_alignment
:
Default
:
:
default
(
)
horizontal_size_request
:
Default
:
:
default
(
)
vertical_size_request
:
Default
:
:
default
(
)
margin
:
Default
:
:
default
(
)
visible
:
true
.
into
(
)
enabled
:
true
.
into
(
)
#
[
cfg
(
test
)
]
id
:
Default
:
:
default
(
)
}
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
ElementBuilder
<
T
>
{
pub
style
:
ElementStyle
pub
element_type
:
T
}
impl
<
T
>
ElementBuilder
<
T
>
{
pub
fn
halign
(
&
mut
self
alignment
:
Alignment
)
{
self
.
style
.
horizontal_alignment
=
alignment
;
}
pub
fn
valign
(
&
mut
self
alignment
:
Alignment
)
{
self
.
style
.
vertical_alignment
=
alignment
;
}
pub
fn
hsize
(
&
mut
self
value
:
u32
)
{
assert
!
(
value
<
=
i32
:
:
MAX
as
u32
)
;
self
.
style
.
horizontal_size_request
=
Some
(
value
)
;
}
pub
fn
vsize
(
&
mut
self
value
:
u32
)
{
assert
!
(
value
<
=
i32
:
:
MAX
as
u32
)
;
self
.
style
.
vertical_size_request
=
Some
(
value
)
;
}
pub
fn
margin_start
(
&
mut
self
amount
:
u32
)
{
self
.
style
.
margin
.
start
=
amount
;
}
pub
fn
margin_end
(
&
mut
self
amount
:
u32
)
{
self
.
style
.
margin
.
end
=
amount
;
}
pub
fn
margin_horizontal
(
&
mut
self
amount
:
u32
)
{
self
.
margin_start
(
amount
)
;
self
.
margin_end
(
amount
)
}
pub
fn
margin_top
(
&
mut
self
amount
:
u32
)
{
self
.
style
.
margin
.
top
=
amount
;
}
pub
fn
margin_bottom
(
&
mut
self
amount
:
u32
)
{
self
.
style
.
margin
.
bottom
=
amount
;
}
pub
fn
margin_vertical
(
&
mut
self
amount
:
u32
)
{
self
.
margin_top
(
amount
)
;
self
.
margin_bottom
(
amount
)
}
pub
fn
margin
(
&
mut
self
amount
:
u32
)
{
self
.
margin_horizontal
(
amount
)
;
self
.
margin_vertical
(
amount
)
}
pub
fn
visible
(
&
mut
self
value
:
impl
Into
<
Property
<
bool
>
>
)
{
self
.
style
.
visible
=
value
.
into
(
)
;
}
pub
fn
enabled
(
&
mut
self
value
:
impl
Into
<
Property
<
bool
>
>
)
{
self
.
style
.
enabled
=
value
.
into
(
)
;
}
#
[
cfg
(
test
)
]
pub
fn
id
(
&
mut
self
value
:
impl
Into
<
String
>
)
{
self
.
style
.
id
=
Some
(
value
.
into
(
)
)
;
}
#
[
cfg
(
not
(
test
)
)
]
pub
fn
id
(
&
mut
self
_value
:
impl
Into
<
String
>
)
{
}
fn
single_child
(
slot
:
&
mut
Option
<
Box
<
Element
>
>
child
:
Element
)
{
if
slot
.
replace
(
Box
:
:
new
(
child
)
)
.
is_some
(
)
{
panic
!
(
"
{
}
can
only
have
one
child
"
std
:
:
any
:
:
type_name
:
:
<
T
>
(
)
)
;
}
}
}
#
[
derive
(
Debug
Default
)
]
pub
struct
TypedElement
<
T
>
{
pub
style
:
ElementStyle
pub
element_type
:
T
}
impl
<
T
>
From
<
ElementBuilder
<
T
>
>
for
TypedElement
<
T
>
{
fn
from
(
b
:
ElementBuilder
<
T
>
)
-
>
Self
{
TypedElement
{
style
:
b
.
style
element_type
:
b
.
element_type
}
}
}
#
[
derive
(
Default
Debug
Clone
Copy
PartialEq
Eq
)
]
#
[
allow
(
dead_code
)
]
pub
enum
Alignment
{
#
[
default
]
Start
Center
End
Fill
}
#
[
derive
(
Default
Debug
)
]
pub
struct
Margin
{
pub
start
:
u32
pub
end
:
u32
pub
top
:
u32
pub
bottom
:
u32
}
macro_rules
!
ui
{
(
el
:
ident
(
[
id
:
literal
]
)
?
(
method
:
ident
methodargs
:
tt
)
*
(
{
(
contents
:
tt
)
*
}
)
?
)
=
>
{
{
#
[
allow
(
unused_imports
)
]
use
crate
:
:
ui
:
:
model
:
:
*
;
let
mut
el
:
ElementBuilder
<
el
>
=
Default
:
:
default
(
)
;
(
el
.
id
(
id
)
;
)
?
(
el
.
method
methodargs
;
)
*
(
ui
!
{
children
(
el
)
(
contents
)
*
}
)
?
el
.
into
(
)
}
}
;
(
children
(
parent
:
expr
)
)
=
>
{
}
;
(
children
(
parent
:
expr
)
el
:
ident
(
[
id
:
literal
]
)
?
(
method
:
ident
methodargs
:
tt
)
*
(
{
(
contents
:
tt
)
*
}
)
?
(
(
rest
:
tt
)
*
)
?
)
=
>
{
parent
.
add_child
(
ui
!
(
el
(
[
id
]
)
?
(
method
methodargs
)
*
(
{
(
contents
)
*
}
)
?
)
)
;
(
ui
!
(
children
(
parent
)
(
rest
)
*
)
)
?
}
;
}
pub
(
crate
)
use
ui
;
pub
struct
Application
{
pub
windows
:
Vec
<
TypedElement
<
Window
>
>
#
[
cfg_attr
(
test
allow
(
dead_code
)
)
]
pub
rtl
:
bool
}
pub
type
InvokeFn
=
Box
<
dyn
FnOnce
(
)
+
Send
+
'
static
>
;
