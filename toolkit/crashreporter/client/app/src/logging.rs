use
crate
:
:
std
:
:
{
self
path
:
:
Path
sync
:
:
{
Arc
Mutex
}
}
;
pub
fn
init
(
)
-
>
LogTarget
{
let
log_target_inner
=
LogTargetInner
:
:
default
(
)
;
env_logger
:
:
builder
(
)
.
parse_env
(
env_logger
:
:
Env
:
:
new
(
)
.
filter
(
ekey
!
(
"
LOG
"
)
)
.
write_style
(
ekey
!
(
"
LOG_STYLE
"
)
)
)
.
target
(
env_logger
:
:
fmt
:
:
Target
:
:
Pipe
(
Box
:
:
new
(
log_target_inner
.
clone
(
)
)
)
)
.
init
(
)
;
LogTarget
{
inner
:
log_target_inner
}
}
#
[
derive
(
Clone
)
]
pub
struct
LogTarget
{
inner
:
LogTargetInner
}
impl
LogTarget
{
pub
fn
set_file
(
&
self
path
:
&
Path
)
{
match
std
:
:
fs
:
:
File
:
:
create
(
path
)
{
Ok
(
file
)
=
>
{
if
let
Ok
(
mut
guard
)
=
self
.
inner
.
target
.
lock
(
)
{
*
guard
=
Box
:
:
new
(
file
)
;
}
}
Err
(
e
)
=
>
log
:
:
error
!
(
"
failed
to
retarget
log
to
{
}
:
{
e
}
"
path
.
display
(
)
)
}
}
}
#
[
derive
(
Clone
)
]
struct
LogTargetInner
{
target
:
Arc
<
Mutex
<
Box
<
dyn
std
:
:
io
:
:
Write
+
Send
+
'
static
>
>
>
}
impl
Default
for
LogTargetInner
{
fn
default
(
)
-
>
Self
{
LogTargetInner
{
target
:
Arc
:
:
new
(
Mutex
:
:
new
(
Box
:
:
new
(
std
:
:
io
:
:
stderr
(
)
)
)
)
}
}
}
impl
std
:
:
io
:
:
Write
for
LogTargetInner
{
fn
write
(
&
mut
self
buf
:
&
[
u8
]
)
-
>
std
:
:
io
:
:
Result
<
usize
>
{
let
Ok
(
mut
guard
)
=
self
.
target
.
lock
(
)
else
{
return
Ok
(
buf
.
len
(
)
)
;
}
;
guard
.
write
(
buf
)
}
fn
flush
(
&
mut
self
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
let
Ok
(
mut
guard
)
=
self
.
target
.
lock
(
)
else
{
return
Ok
(
(
)
)
;
}
;
guard
.
flush
(
)
}
}
