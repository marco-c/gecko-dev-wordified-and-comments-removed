use
crate
:
:
config
:
:
installation_program_path
;
use
crate
:
:
std
:
:
{
self
env
fs
:
:
{
File
OpenOptions
}
io
:
:
{
Read
Seek
}
mem
:
:
ManuallyDrop
path
:
:
{
Path
PathBuf
}
process
:
:
Child
}
;
use
anyhow
:
:
Context
;
use
once_cell
:
:
sync
:
:
Lazy
;
use
serde
:
:
Serialize
;
#
[
cfg
(
mock
)
]
use
crate
:
:
std
:
:
mock
:
:
{
mock_key
MockKey
}
;
#
[
cfg
(
mock
)
]
mock_key
!
{
/
/
/
The
outer
Result
is
for
RequestBuilder
:
:
build
(
)
the
inner
is
for
Request
:
:
send
(
)
.
pub
struct
MockHttp
=
>
Box
<
dyn
Fn
(
&
RequestBuilder
&
str
)
-
>
std
:
:
io
:
:
Result
<
std
:
:
io
:
:
Result
<
Vec
<
u8
>
>
>
+
Send
+
Sync
>
}
#
[
cfg
(
mock
)
]
impl
MockHttp
{
#
[
allow
(
unused
)
]
pub
fn
try_others
(
)
-
>
std
:
:
io
:
:
Result
<
std
:
:
io
:
:
Result
<
Vec
<
u8
>
>
>
{
Err
(
std
:
:
io
:
:
ErrorKind
:
:
Interrupted
.
into
(
)
)
}
}
pub
fn
user_agent
(
)
-
>
&
'
static
str
{
static
USER_AGENT
:
Lazy
<
String
>
=
Lazy
:
:
new
(
|
|
{
format
!
(
"
{
}
/
{
}
(
{
}
{
}
)
"
env
!
(
"
CARGO_PKG_NAME
"
)
mozbuild
:
:
config
:
:
MOZ_APP_VERSION
std
:
:
env
:
:
consts
:
:
OS
std
:
:
env
:
:
consts
:
:
ARCH
)
}
)
;
&
*
USER_AGENT
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Serialize
)
]
#
[
serde
(
tag
=
"
type
"
)
]
pub
enum
RequestBuilder
<
'
a
>
{
MimePost
{
parts
:
Vec
<
MimePart
<
'
a
>
>
}
Post
{
body
:
&
'
a
[
u8
]
headers
:
&
'
a
[
(
String
String
)
]
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Serialize
)
]
pub
struct
MimePart
<
'
a
>
{
pub
name
:
&
'
a
str
pub
content
:
MimePartContent
<
'
a
>
#
[
serde
(
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
filename
:
Option
<
&
'
a
str
>
#
[
serde
(
skip_serializing_if
=
"
Option
:
:
is_none
"
)
]
pub
mime_type
:
Option
<
&
'
a
str
>
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Serialize
)
]
#
[
serde
(
tag
=
"
type
"
content
=
"
value
"
)
]
pub
enum
MimePartContent
<
'
a
>
{
File
(
&
'
a
Path
)
String
(
&
'
a
str
)
}
pub
enum
Request
<
'
a
>
{
BackgroundTaskChild
{
child
:
Child
file
:
TempRequestFile
builder
:
RequestBuilder
<
'
a
>
url
:
&
'
a
str
}
CurlChild
{
child
:
Child
stdin
:
Option
<
Box
<
dyn
Read
+
Send
+
'
static
>
>
}
LibCurl
{
easy
:
super
:
:
libcurl
:
:
Easy
<
'
static
>
}
#
[
cfg
(
mock
)
]
Mock
{
response
:
std
:
:
io
:
:
Result
<
Vec
<
u8
>
>
}
}
impl
<
'
a
>
RequestBuilder
<
'
a
>
{
pub
fn
build
(
&
self
url
:
&
'
a
str
)
-
>
std
:
:
io
:
:
Result
<
Request
<
'
a
>
>
{
log
:
:
debug
!
(
"
starting
request
to
{
url
}
:
{
self
:
?
}
"
)
;
#
[
cfg
(
mock
)
]
if
let
Some
(
r
)
=
self
.
try_send_with_mock
(
url
)
{
return
r
;
}
let
background_task_err
=
match
self
.
send_with_background_task
(
url
)
{
Ok
(
r
)
=
>
return
Ok
(
r
)
Err
(
e
)
=
>
e
}
;
log
:
:
info
!
(
"
failed
to
invoke
background
task
(
{
background_task_err
}
)
falling
back
to
curl
backend
"
)
;
self
.
send_with_curl
(
url
)
}
fn
send_with_background_task
(
&
self
url
:
&
'
a
str
)
-
>
std
:
:
io
:
:
Result
<
Request
<
'
a
>
>
{
let
path
=
installation_program_path
(
mozbuild
:
:
config
:
:
MOZ_APP_NAME
)
;
let
mut
cmd
=
crate
:
:
process
:
:
background_command
(
path
)
;
cmd
.
args
(
[
"
-
-
backgroundtask
"
"
crashreporterNetworkBackend
"
]
)
;
cmd
.
arg
(
url
)
;
cmd
.
arg
(
user_agent
(
)
)
;
cmd
.
env
(
"
MOZ_CRASHREPORTER_DISABLE
"
"
1
"
)
.
env_remove
(
"
MOZ_CRASHREPORTER
"
)
;
let
mut
file
=
TempRequestFile
:
:
new
(
)
?
;
serde_json
:
:
to_writer
(
&
mut
*
file
self
)
?
;
cmd
.
arg
(
&
file
.
path
)
;
cmd
.
stdin
(
std
:
:
process
:
:
Stdio
:
:
null
(
)
)
;
cmd
.
stdout
(
std
:
:
process
:
:
Stdio
:
:
piped
(
)
)
;
cmd
.
stderr
(
std
:
:
process
:
:
Stdio
:
:
piped
(
)
)
;
cmd
.
spawn
(
)
.
map
(
move
|
child
|
Request
:
:
BackgroundTaskChild
{
child
file
builder
:
self
.
clone
(
)
url
}
)
}
pub
fn
send_with_curl
(
&
self
url
:
&
str
)
-
>
std
:
:
io
:
:
Result
<
Request
<
'
static
>
>
{
let
curl_err
=
match
self
.
send_with_curl_executable
(
url
)
{
Ok
(
r
)
=
>
return
Ok
(
r
)
Err
(
e
)
=
>
e
}
;
#
[
cfg
(
mock
)
]
if
!
crate
:
:
std
:
:
mock
:
:
try_hook
(
false
"
use_system_libcurl
"
)
{
log
:
:
error
!
(
"
use_system_libcurl
not
enabled
and
curl
failed
:
{
curl_err
}
"
)
;
panic
!
(
"
no
mock
handler
available
to
build
http
request
"
)
;
}
log
:
:
info
!
(
"
failed
to
invoke
curl
(
{
curl_err
}
)
trying
libcurl
"
)
;
self
.
send_with_libcurl
(
url
)
}
fn
send_with_curl_executable
(
&
self
url
:
&
str
)
-
>
std
:
:
io
:
:
Result
<
Request
<
'
static
>
>
{
let
mut
cmd
=
crate
:
:
process
:
:
background_command
(
"
curl
"
)
;
let
mut
stdin
:
Option
<
Box
<
dyn
Read
+
Send
+
'
static
>
>
=
None
;
cmd
.
args
(
[
"
-
-
user
-
agent
"
user_agent
(
)
]
)
;
match
self
{
Self
:
:
MimePost
{
parts
}
=
>
{
for
part
in
parts
{
part
.
curl_command_args
(
&
mut
cmd
&
mut
stdin
)
?
;
}
}
Self
:
:
Post
{
body
headers
}
=
>
{
for
(
k
v
)
in
headers
.
iter
(
)
{
cmd
.
args
(
[
"
-
-
header
"
&
format
!
(
"
{
k
}
:
{
v
}
"
)
]
)
;
}
cmd
.
args
(
[
"
-
-
data
-
binary
"
"
-
"
]
)
;
stdin
=
Some
(
Box
:
:
new
(
std
:
:
io
:
:
Cursor
:
:
new
(
body
.
to_vec
(
)
)
)
)
;
}
}
cmd
.
arg
(
url
)
;
cmd
.
stdin
(
std
:
:
process
:
:
Stdio
:
:
piped
(
)
)
;
cmd
.
stdout
(
std
:
:
process
:
:
Stdio
:
:
piped
(
)
)
;
cmd
.
stderr
(
std
:
:
process
:
:
Stdio
:
:
piped
(
)
)
;
cmd
.
spawn
(
)
.
map
(
move
|
child
|
Request
:
:
CurlChild
{
child
stdin
}
)
}
fn
send_with_libcurl
(
&
self
url
:
&
str
)
-
>
std
:
:
io
:
:
Result
<
Request
<
'
static
>
>
{
let
curl
=
super
:
:
libcurl
:
:
load
(
)
?
;
let
mut
easy
=
curl
.
easy
(
)
?
;
easy
.
set_url
(
url
)
?
;
easy
.
set_user_agent
(
user_agent
(
)
)
?
;
easy
.
set_max_redirs
(
30
)
?
;
match
self
{
Self
:
:
MimePost
{
parts
}
=
>
{
let
mut
mime
=
easy
.
mime
(
)
?
;
for
part
in
parts
{
part
.
curl_mime
(
&
mut
mime
)
?
;
}
easy
.
set_mime_post
(
mime
)
?
;
}
Self
:
:
Post
{
body
headers
}
=
>
{
let
mut
header_list
=
easy
.
slist
(
)
;
for
(
k
v
)
in
headers
.
iter
(
)
{
header_list
.
append
(
&
format
!
(
"
{
k
}
:
{
v
}
"
)
)
?
;
}
easy
.
set_headers
(
header_list
)
?
;
easy
.
set_postfields
(
*
body
)
?
;
}
}
Ok
(
Request
:
:
LibCurl
{
easy
}
)
}
#
[
cfg
(
mock
)
]
fn
try_send_with_mock
(
&
self
url
:
&
str
)
-
>
Option
<
std
:
:
io
:
:
Result
<
Request
<
'
static
>
>
>
{
let
result
=
MockHttp
.
try_get
(
|
f
|
f
(
self
url
)
)
?
;
if
result
.
as_ref
(
)
.
err
(
)
.
map
(
|
e
|
e
.
kind
(
)
=
=
std
:
:
io
:
:
ErrorKind
:
:
Interrupted
)
.
unwrap_or
(
false
)
{
None
}
else
{
Some
(
result
.
map
(
|
response
|
Request
:
:
Mock
{
response
}
)
)
}
}
}
pub
struct
TempRequestFile
{
path
:
PathBuf
file
:
ManuallyDrop
<
File
>
}
static
REQUEST_NUM
:
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
=
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
:
:
new
(
0
)
;
impl
TempRequestFile
{
fn
new
(
)
-
>
std
:
:
io
:
:
Result
<
Self
>
{
let
path
=
std
:
:
env
:
:
temp_dir
(
)
.
join
(
format
!
(
"
{
}
{
}
-
request
{
}
.
json
"
env
!
(
"
CARGO_PKG_NAME
"
)
std
:
:
process
:
:
id
(
)
REQUEST_NUM
.
fetch_add
(
1
std
:
:
sync
:
:
atomic
:
:
Ordering
:
:
Relaxed
)
)
)
;
if
let
Some
(
p
)
=
path
.
parent
(
)
{
std
:
:
fs
:
:
create_dir_all
(
p
)
?
;
}
let
file
=
OpenOptions
:
:
new
(
)
.
read
(
true
)
.
write
(
true
)
.
create
(
true
)
.
truncate
(
true
)
.
open
(
&
path
)
?
;
Ok
(
TempRequestFile
{
path
file
:
ManuallyDrop
:
:
new
(
file
)
}
)
}
}
impl
std
:
:
ops
:
:
Deref
for
TempRequestFile
{
type
Target
=
File
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
file
}
}
impl
std
:
:
ops
:
:
DerefMut
for
TempRequestFile
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
file
}
}
impl
Drop
for
TempRequestFile
{
fn
drop
(
&
mut
self
)
{
unsafe
{
ManuallyDrop
:
:
drop
(
&
mut
self
.
file
)
}
;
let
_
=
std
:
:
fs
:
:
remove_file
(
&
self
.
path
)
;
}
}
impl
MimePart
<
'
_
>
{
fn
curl_command_args
(
&
self
cmd
:
&
mut
crate
:
:
std
:
:
process
:
:
Command
stdin
:
&
mut
Option
<
Box
<
dyn
Read
+
Send
+
'
static
>
>
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
use
std
:
:
fmt
:
:
Write
;
let
mut
formarg
=
format
!
(
"
{
}
=
"
self
.
name
)
;
match
self
.
content
{
MimePartContent
:
:
File
(
f
)
=
>
{
write
!
(
formarg
"
{
}
"
CurlQuote
(
&
f
.
display
(
)
.
to_string
(
)
)
)
.
unwrap
(
)
}
MimePartContent
:
:
String
(
s
)
=
>
{
write
!
(
formarg
"
-
"
)
.
unwrap
(
)
;
if
stdin
.
replace
(
Box
:
:
new
(
std
:
:
io
:
:
Cursor
:
:
new
(
s
.
to_owned
(
)
)
)
)
.
is_some
(
)
{
return
Err
(
std
:
:
io
:
:
Error
:
:
other
(
"
only
one
MimePartContent
:
:
String
supported
"
)
)
;
}
}
}
if
let
Some
(
filename
)
=
self
.
filename
{
write
!
(
formarg
"
;
filename
=
{
}
"
filename
)
.
unwrap
(
)
;
}
if
let
Some
(
mime_type
)
=
self
.
mime_type
{
write
!
(
formarg
"
;
type
=
{
}
"
mime_type
)
.
unwrap
(
)
;
}
cmd
.
arg
(
"
-
-
form
"
)
;
cmd
.
arg
(
formarg
)
;
Ok
(
(
)
)
}
fn
curl_mime
(
&
self
mime
:
&
mut
super
:
:
libcurl
:
:
Mime
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
let
mut
p
=
mime
.
add_part
(
)
?
;
p
.
set_name
(
&
self
.
name
)
?
;
match
self
.
content
{
MimePartContent
:
:
File
(
f
)
=
>
{
p
.
set_filename
(
&
f
.
display
(
)
.
to_string
(
)
)
?
;
p
.
set_filedata
(
f
)
?
;
}
MimePartContent
:
:
String
(
s
)
=
>
{
p
.
set_data
(
s
.
as_bytes
(
)
)
?
;
}
}
if
let
Some
(
filename
)
=
self
.
filename
{
p
.
set_filename
(
filename
)
?
;
}
if
let
Some
(
mime_type
)
=
self
.
mime_type
{
p
.
set_type
(
mime_type
)
?
;
}
Ok
(
(
)
)
}
}
impl
Request
<
'
_
>
{
pub
fn
send
(
self
)
-
>
anyhow
:
:
Result
<
Vec
<
u8
>
>
{
Ok
(
match
self
{
Self
:
:
BackgroundTaskChild
{
child
mut
file
builder
url
}
=
>
{
(
move
|
|
{
let
output
=
child
.
wait_with_output
(
)
.
context
(
"
failed
to
wait
on
background
task
process
"
)
?
;
anyhow
:
:
ensure
!
(
output
.
status
.
success
(
)
"
process
failed
(
exit
status
{
}
)
with
stderr
:
{
}
"
output
.
status
String
:
:
from_utf8_lossy
(
&
output
.
stderr
)
)
;
file
.
rewind
(
)
.
context
(
"
failed
to
rewind
response
file
"
)
?
;
let
mut
ret
=
Vec
:
:
new
(
)
;
file
.
read_to_end
(
&
mut
ret
)
.
context
(
"
failed
to
read
response
file
"
)
?
;
Ok
(
ret
)
}
)
(
)
.
or_else
(
|
e
|
{
log
:
:
error
!
(
"
background
task
error
:
{
e
:
#
}
"
)
;
log
:
:
info
!
(
"
falling
back
to
curl
backend
"
)
;
builder
.
send_with_curl
(
url
)
.
context
(
"
curl
error
"
)
?
.
send
(
)
}
)
?
}
Self
:
:
CurlChild
{
mut
child
stdin
}
=
>
{
if
let
Some
(
mut
stdin
)
=
stdin
{
let
mut
child_stdin
=
child
.
stdin
.
take
(
)
.
context
(
"
failed
to
get
curl
process
stdin
"
)
?
;
std
:
:
io
:
:
copy
(
&
mut
stdin
&
mut
child_stdin
)
.
context
(
"
failed
to
write
to
stdin
of
curl
process
"
)
?
;
}
let
output
=
child
.
wait_with_output
(
)
.
context
(
"
failed
to
wait
on
curl
process
"
)
?
;
anyhow
:
:
ensure
!
(
output
.
status
.
success
(
)
"
process
failed
(
exit
status
{
}
)
with
stderr
:
{
}
"
output
.
status
String
:
:
from_utf8_lossy
(
&
output
.
stderr
)
)
;
output
.
stdout
}
Self
:
:
LibCurl
{
easy
}
=
>
{
let
response
=
easy
.
perform
(
)
?
;
let
response_code
=
easy
.
get_response_code
(
)
?
;
anyhow
:
:
ensure
!
(
response_code
=
=
200
"
unexpected
response
code
(
{
response_code
}
)
:
{
}
"
String
:
:
from_utf8_lossy
(
&
response
)
.
as_ref
(
)
)
;
response
}
#
[
cfg
(
mock
)
]
Self
:
:
Mock
{
response
}
=
>
response
?
}
)
}
}
struct
CurlQuote
<
'
a
>
(
&
'
a
str
)
;
impl
CurlQuote
<
'
_
>
{
fn
quoted
(
&
self
)
-
>
String
{
let
quote
=
std
:
:
iter
:
:
once
(
&
b
'
"
'
)
;
let
escaped
=
self
.
0
.
as_bytes
(
)
.
iter
(
)
.
flat_map
(
|
b
|
match
b
{
b
'
"
'
=
>
br
#
"
\
"
"
#
.
as_slice
(
)
b
'
\
\
'
=
>
br
#
"
\
\
"
#
.
as_slice
(
)
other
=
>
std
:
:
slice
:
:
from_ref
(
other
)
}
)
;
let
bytes
=
quote
.
clone
(
)
.
chain
(
escaped
)
.
chain
(
quote
)
.
copied
(
)
.
collect
(
)
;
unsafe
{
String
:
:
from_utf8_unchecked
(
bytes
)
}
}
}
impl
std
:
:
fmt
:
:
Display
for
CurlQuote
<
'
_
>
{
fn
fmt
(
&
self
f
:
&
mut
std
:
:
fmt
:
:
Formatter
<
'
_
>
)
-
>
std
:
:
fmt
:
:
Result
{
write
!
(
f
"
{
}
"
self
.
quoted
(
)
)
}
}
#
[
cfg
(
test
)
]
mod
test
{
use
super
:
:
*
;
#
[
test
]
fn
curl_quote
(
)
{
assert_eq
!
(
CurlQuote
(
r
#
"
hello
"
world
"
"
#
)
.
to_string
(
)
r
#
"
"
hello
\
"
world
\
"
"
"
#
)
;
assert_eq
!
(
CurlQuote
(
r
#
"
C
:
\
dir
\
\
"
\
"
"
dir
"
"
#
)
.
to_string
(
)
r
#
"
"
C
:
\
\
dir
\
\
\
\
\
"
\
\
\
"
\
"
dir
\
"
"
"
#
)
;
}
}
