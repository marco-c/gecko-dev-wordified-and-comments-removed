use
crate
:
:
std
:
:
borrow
:
:
Cow
;
use
crate
:
:
std
:
:
ffi
:
:
{
OsStr
OsString
}
;
use
crate
:
:
std
:
:
path
:
:
{
Path
PathBuf
}
;
use
crate
:
:
{
lang
logging
:
:
LogTarget
std
}
;
use
anyhow
:
:
Context
;
use
once_cell
:
:
sync
:
:
Lazy
;
const
MINIDUMP_PRUNE_SAVE_COUNT
:
usize
=
10
;
#
[
cfg
(
test
)
]
pub
mod
test
{
pub
const
MINIDUMP_PRUNE_SAVE_COUNT
:
usize
=
super
:
:
MINIDUMP_PRUNE_SAVE_COUNT
;
}
const
VENDOR_KEY
:
&
str
=
"
Vendor
"
;
const
PRODUCT_KEY
:
&
str
=
"
ProductName
"
;
const
DEFAULT_VENDOR
:
&
str
=
"
Mozilla
"
;
const
DEFAULT_PRODUCT
:
&
str
=
"
Firefox
"
;
#
[
derive
(
Default
)
]
pub
struct
Config
{
pub
auto_submit
:
bool
pub
dump_all_threads
:
bool
pub
delete_dump
:
bool
pub
data_dir
:
Option
<
PathBuf
>
pub
events_dir
:
Option
<
PathBuf
>
pub
ping_dir
:
Option
<
PathBuf
>
pub
dump_file
:
Option
<
PathBuf
>
pub
app_file
:
Option
<
OsString
>
pub
restart_command
:
Option
<
OsString
>
pub
restart_args
:
Vec
<
OsString
>
pub
report_url
:
Option
<
OsString
>
pub
strings
:
Option
<
lang
:
:
LangStrings
>
pub
log_target
:
Option
<
LogTarget
>
}
pub
struct
ConfigStringBuilder
<
'
a
>
(
lang
:
:
LangStringBuilder
<
'
a
>
)
;
impl
<
'
a
>
ConfigStringBuilder
<
'
a
>
{
pub
fn
arg
<
V
:
Into
<
Cow
<
'
a
str
>
>
>
(
self
key
:
&
'
a
str
value
:
V
)
-
>
Self
{
ConfigStringBuilder
(
self
.
0
.
arg
(
key
value
)
)
}
pub
fn
get
(
self
)
-
>
String
{
self
.
0
.
get
(
)
.
context
(
"
failed
to
get
localized
string
"
)
.
unwrap
(
)
}
}
impl
Config
{
pub
fn
new
(
)
-
>
Self
{
Self
:
:
default
(
)
}
#
[
cfg_attr
(
mock
allow
(
unused
)
)
]
pub
fn
read_from_environment
(
&
mut
self
)
-
>
anyhow
:
:
Result
<
(
)
>
{
self
.
auto_submit
=
env_bool
(
ekey
!
(
"
AUTO_SUBMIT
"
)
)
;
self
.
dump_all_threads
=
env_bool
(
ekey
!
(
"
DUMP_ALL_THREADS
"
)
)
;
self
.
delete_dump
=
!
env_bool
(
ekey
!
(
"
NO_DELETE_DUMP
"
)
)
;
self
.
data_dir
=
env_path
(
ekey
!
(
"
DATA_DIRECTORY
"
)
)
;
self
.
events_dir
=
env_path
(
ekey
!
(
"
EVENTS_DIRECTORY
"
)
)
;
self
.
ping_dir
=
env_path
(
ekey
!
(
"
PING_DIRECTORY
"
)
)
;
self
.
app_file
=
std
:
:
env
:
:
var_os
(
ekey
!
(
"
RESTART_XUL_APP_FILE
"
)
)
;
if
cfg
!
(
not
(
target_os
=
"
windows
"
)
)
{
self
.
restart_command
=
std
:
:
env
:
:
var_os
(
"
MOZ_APP_LAUNCHER
"
)
;
}
if
self
.
restart_command
.
is_none
(
)
{
self
.
restart_command
=
Some
(
self
.
sibling_program_path
(
mozbuild
:
:
config
:
:
MOZ_APP_NAME
)
.
into
(
)
)
}
self
.
restart_args
=
(
1
.
.
)
.
into_iter
(
)
.
map_while
(
|
arg_num
|
std
:
:
env
:
:
var_os
(
format
!
(
"
{
}
_
{
}
"
ekey
!
(
"
RESTART_ARG
"
)
arg_num
)
)
)
.
filter
(
|
s
|
!
s
.
is_empty
(
)
)
.
collect
(
)
;
self
.
report_url
=
std
:
:
env
:
:
var_os
(
ekey
!
(
"
URL
"
)
)
;
let
mut
args
=
std
:
:
env
:
:
args_os
(
)
.
skip
(
1
)
;
self
.
dump_file
=
args
.
next
(
)
.
map
(
|
p
|
p
.
into
(
)
)
;
while
let
Some
(
arg
)
=
args
.
next
(
)
{
log
:
:
warn
!
(
"
ignoring
extraneous
argument
:
{
}
"
arg
.
to_string_lossy
(
)
)
;
}
self
.
strings
=
Some
(
lang
:
:
load
(
)
.
context
(
"
failed
to
load
localized
strings
"
)
?
)
;
Ok
(
(
)
)
}
pub
fn
string
(
&
self
index
:
&
str
)
-
>
String
{
self
.
build_string
(
index
)
.
get
(
)
}
pub
fn
build_string
<
'
a
>
(
&
'
a
self
index
:
&
'
a
str
)
-
>
ConfigStringBuilder
<
'
a
>
{
ConfigStringBuilder
(
self
.
strings
.
as_ref
(
)
.
expect
(
"
strings
not
set
"
)
.
builder
(
index
)
)
}
pub
fn
is_rtl
(
&
self
)
-
>
bool
{
self
.
strings
.
as_ref
(
)
.
map
(
|
s
|
s
.
is_rtl
(
)
)
.
unwrap_or_default
(
)
}
pub
fn
load_extra_file
(
&
mut
self
)
-
>
anyhow
:
:
Result
<
serde_json
:
:
Value
>
{
let
extra_file
=
self
.
extra_file
(
)
.
unwrap
(
)
;
let
extra
:
serde_json
:
:
Value
=
serde_json
:
:
from_reader
(
std
:
:
fs
:
:
File
:
:
open
(
&
extra_file
)
.
with_context
(
|
|
{
self
.
build_string
(
"
crashreporter
-
error
-
opening
-
file
"
)
.
arg
(
"
path
"
extra_file
.
display
(
)
.
to_string
(
)
)
.
get
(
)
}
)
?
)
.
with_context
(
|
|
{
self
.
build_string
(
"
crashreporter
-
error
-
loading
-
file
"
)
.
arg
(
"
path
"
extra_file
.
display
(
)
.
to_string
(
)
)
.
get
(
)
}
)
?
;
if
self
.
report_url
.
is_none
(
)
{
if
let
Some
(
url
)
=
extra
[
"
ServerURL
"
]
.
as_str
(
)
{
self
.
report_url
=
Some
(
url
.
into
(
)
)
;
}
}
if
self
.
data_dir
.
is_none
(
)
{
let
vendor
=
extra
[
VENDOR_KEY
]
.
as_str
(
)
.
unwrap_or
(
DEFAULT_VENDOR
)
;
let
product
=
extra
[
PRODUCT_KEY
]
.
as_str
(
)
.
unwrap_or
(
DEFAULT_PRODUCT
)
;
self
.
data_dir
=
Some
(
self
.
get_data_dir
(
vendor
product
)
?
)
;
}
if
extra
.
get
(
"
WindowsErrorReporting
"
)
.
is_some
(
)
{
self
.
restart_command
=
None
;
}
Ok
(
extra
)
}
pub
fn
extra_file
(
&
self
)
-
>
Option
<
PathBuf
>
{
self
.
dump_file
.
clone
(
)
.
map
(
extra_file_for_dump_file
)
}
pub
fn
memory_file
(
&
self
)
-
>
Option
<
PathBuf
>
{
self
.
dump_file
.
clone
(
)
.
and_then
(
|
p
|
{
let
p
=
memory_file_for_dump_file
(
p
)
;
p
.
exists
(
)
.
then_some
(
p
)
}
)
}
pub
fn
data_dir
(
&
self
)
-
>
&
Path
{
self
.
data_dir
.
as_deref
(
)
.
unwrap
(
)
}
pub
fn
dump_file
(
&
self
)
-
>
&
Path
{
self
.
dump_file
.
as_deref
(
)
.
unwrap
(
)
}
pub
fn
local_dump_id
(
&
self
)
-
>
Cow
<
str
>
{
self
.
dump_file
(
)
.
file_stem
(
)
.
unwrap
(
)
.
to_string_lossy
(
)
}
pub
fn
move_crash_data_to_pending
(
&
mut
self
)
-
>
anyhow
:
:
Result
<
(
)
>
{
let
pending_crashes_dir
=
self
.
data_dir
(
)
.
join
(
"
pending
"
)
;
std
:
:
fs
:
:
create_dir_all
(
&
pending_crashes_dir
)
.
with_context
(
|
|
{
self
.
build_string
(
"
crashreporter
-
error
-
creating
-
dir
"
)
.
arg
(
"
path
"
pending_crashes_dir
.
display
(
)
.
to_string
(
)
)
.
get
(
)
}
)
?
;
let
move_file
=
|
from
:
&
Path
|
-
>
anyhow
:
:
Result
<
PathBuf
>
{
let
to
=
pending_crashes_dir
.
join
(
from
.
file_name
(
)
.
unwrap
(
)
)
;
if
let
Err
(
e
)
=
std
:
:
fs
:
:
rename
(
from
&
to
)
{
log
:
:
warn
!
(
"
failed
to
move
{
}
to
{
}
:
{
e
}
"
from
.
display
(
)
to
.
display
(
)
)
;
log
:
:
info
!
(
"
trying
to
copy
and
remove
instead
"
)
;
std
:
:
fs
:
:
copy
(
from
&
to
)
.
with_context
(
|
|
{
self
.
build_string
(
"
crashreporter
-
error
-
moving
-
path
"
)
.
arg
(
"
from
"
from
.
display
(
)
.
to_string
(
)
)
.
arg
(
"
to
"
to
.
display
(
)
.
to_string
(
)
)
.
get
(
)
}
)
?
;
if
let
Err
(
e
)
=
std
:
:
fs
:
:
remove_file
(
from
)
{
log
:
:
warn
!
(
"
failed
to
remove
{
}
:
{
e
}
"
from
.
display
(
)
)
;
}
}
Ok
(
to
)
}
;
let
new_dump_file
=
move_file
(
self
.
dump_file
(
)
)
?
;
move_file
(
self
.
extra_file
(
)
.
unwrap
(
)
.
as_ref
(
)
)
?
;
if
let
Some
(
memory_file
)
=
self
.
memory_file
(
)
{
if
let
Err
(
e
)
=
move_file
(
memory_file
.
as_ref
(
)
)
{
log
:
:
warn
!
(
"
failed
to
move
memory
file
:
{
e
}
"
)
;
if
let
Err
(
e
)
=
std
:
:
fs
:
:
remove_file
(
&
memory_file
)
{
log
:
:
warn
!
(
"
failed
to
remove
{
}
:
{
e
}
"
memory_file
.
display
(
)
)
;
}
}
}
self
.
dump_file
=
Some
(
new_dump_file
)
;
Ok
(
(
)
)
}
pub
fn
version_eol_file
(
&
self
version
:
&
str
)
-
>
PathBuf
{
self
.
data_dir
(
)
.
join
(
format
!
(
"
EndOfLife
{
version
}
"
)
)
}
pub
fn
submitted_crash_dir
(
&
self
)
-
>
PathBuf
{
self
.
data_dir
(
)
.
join
(
"
submitted
"
)
}
pub
fn
delete_files
(
&
self
)
{
if
!
self
.
delete_dump
{
return
;
}
for
file
in
[
&
self
.
dump_file
&
self
.
extra_file
(
)
&
self
.
memory_file
(
)
]
.
into_iter
(
)
.
flatten
(
)
{
if
let
Err
(
e
)
=
std
:
:
fs
:
:
remove_file
(
file
)
{
log
:
:
warn
!
(
"
failed
to
remove
{
}
:
{
e
}
"
file
.
display
(
)
)
;
}
}
}
pub
fn
prune_files
(
&
self
)
-
>
anyhow
:
:
Result
<
(
)
>
{
log
:
:
info
!
(
"
pruning
minidump
files
to
the
{
MINIDUMP_PRUNE_SAVE_COUNT
}
most
recent
"
)
;
let
Some
(
file
)
=
&
self
.
dump_file
else
{
anyhow
:
:
bail
!
(
"
no
dump
file
"
)
}
;
let
Some
(
dir
)
=
file
.
parent
(
)
else
{
anyhow
:
:
bail
!
(
"
no
parent
directory
for
dump
file
"
)
}
;
log
:
:
debug
!
(
"
pruning
{
}
directory
"
dir
.
display
(
)
)
;
let
read_dir
=
dir
.
read_dir
(
)
.
with_context
(
|
|
{
format
!
(
"
failed
to
read
dump
file
parent
directory
{
}
"
dir
.
display
(
)
)
}
)
?
;
let
mut
minidump_files
=
Vec
:
:
new
(
)
;
for
entry
in
read_dir
{
match
entry
{
Err
(
e
)
=
>
log
:
:
error
!
(
"
error
while
iterating
over
{
}
directory
entry
:
{
e
}
"
dir
.
display
(
)
)
Ok
(
e
)
if
e
.
path
(
)
.
extension
(
)
=
=
Some
(
"
dmp
"
.
as_ref
(
)
)
=
>
{
let
meta
=
e
.
metadata
(
)
.
with_context
(
|
|
{
format
!
(
"
failed
to
read
metadata
for
{
}
"
e
.
path
(
)
.
display
(
)
)
}
)
?
;
if
meta
.
is_file
(
)
{
let
modified_time
=
meta
.
modified
(
)
.
expect
(
"
file
modification
time
should
be
available
on
all
crashreporter
platforms
"
)
;
minidump_files
.
push
(
(
modified_time
e
.
path
(
)
)
)
;
}
}
_
=
>
(
)
}
}
minidump_files
.
sort_unstable_by
(
|
a
b
|
a
.
cmp
(
b
)
.
reverse
(
)
)
;
for
dump_file
in
minidump_files
.
into_iter
(
)
.
skip
(
MINIDUMP_PRUNE_SAVE_COUNT
)
.
map
(
|
v
|
v
.
1
)
{
log
:
:
debug
!
(
"
pruning
{
}
and
related
files
"
dump_file
.
display
(
)
)
;
if
let
Err
(
e
)
=
std
:
:
fs
:
:
remove_file
(
&
dump_file
)
{
log
:
:
warn
!
(
"
failed
to
delete
{
}
:
{
e
}
"
dump_file
.
display
(
)
)
;
}
let
_
=
std
:
:
fs
:
:
remove_file
(
extra_file_for_dump_file
(
dump_file
.
clone
(
)
)
)
;
let
_
=
std
:
:
fs
:
:
remove_file
(
memory_file_for_dump_file
(
dump_file
)
)
;
}
Ok
(
(
)
)
}
pub
fn
sibling_program_path
<
N
:
AsRef
<
OsStr
>
>
(
&
self
program
:
N
)
-
>
PathBuf
{
let
self_path
=
self_path
(
)
;
let
exe_extension
=
self_path
.
extension
(
)
.
unwrap_or_default
(
)
;
if
!
exe_extension
.
is_empty
(
)
{
let
mut
p
=
program
.
as_ref
(
)
.
to_os_string
(
)
;
p
.
push
(
"
.
"
)
;
p
.
push
(
exe_extension
)
;
sibling_path
(
p
)
}
else
{
sibling_path
(
program
)
}
}
cfg_if
:
:
cfg_if
!
{
if
#
[
cfg
(
mock
)
]
{
fn
get_data_dir
(
&
self
vendor
:
&
str
product
:
&
str
)
-
>
anyhow
:
:
Result
<
PathBuf
>
{
let
mut
path
=
PathBuf
:
:
from
(
"
data_dir
"
)
;
path
.
push
(
vendor
)
;
path
.
push
(
product
)
;
path
.
push
(
"
Crash
Reports
"
)
;
Ok
(
path
)
}
}
else
if
#
[
cfg
(
target_os
=
"
linux
"
)
]
{
fn
get_data_dir
(
&
self
vendor
:
&
str
product
:
&
str
)
-
>
anyhow
:
:
Result
<
PathBuf
>
{
/
/
home_dir
is
deprecated
due
to
incorrect
behavior
on
windows
but
we
only
use
it
on
linux
#
[
allow
(
deprecated
)
]
let
mut
data_path
=
std
:
:
env
:
:
home_dir
(
)
.
with_context
(
|
|
self
.
string
(
"
crashreporter
-
error
-
no
-
home
-
dir
"
)
)
?
;
data_path
.
push
(
format
!
(
"
.
{
}
"
vendor
.
to_lowercase
(
)
)
)
;
data_path
.
push
(
product
.
to_lowercase
(
)
)
;
data_path
.
push
(
"
Crash
Reports
"
)
;
Ok
(
data_path
)
}
}
else
if
#
[
cfg
(
target_os
=
"
macos
"
)
]
{
fn
get_data_dir
(
&
self
_vendor
:
&
str
product
:
&
str
)
-
>
anyhow
:
:
Result
<
PathBuf
>
{
use
objc
:
:
{
rc
:
:
autoreleasepool
runtime
:
:
{
Object
BOOL
YES
}
*
}
;
#
[
link
(
name
=
"
Foundation
"
kind
=
"
framework
"
)
]
extern
"
system
"
{
fn
NSSearchPathForDirectoriesInDomains
(
directory
:
usize
domain_mask
:
usize
expand_tilde
:
BOOL
)
-
>
*
mut
Object
/
*
NSArray
<
NSString
*
>
*
*
/
;
}
#
[
allow
(
non_upper_case_globals
)
]
const
NSApplicationSupportDirectory
:
usize
=
14
;
#
[
allow
(
non_upper_case_globals
)
]
const
NSUserDomainMask
:
usize
=
1
;
let
mut
data_path
=
autoreleasepool
(
|
|
{
let
paths
/
*
NSArray
<
NSString
*
>
*
*
/
=
unsafe
{
NSSearchPathForDirectoriesInDomains
(
NSApplicationSupportDirectory
NSUserDomainMask
YES
)
}
;
if
paths
.
is_null
(
)
{
anyhow
:
:
bail
!
(
"
NSSearchPathForDirectoriesInDomains
returned
nil
"
)
;
}
let
path
:
*
mut
Object
/
*
NSString
*
*
/
=
unsafe
{
msg_send
!
[
paths
firstObject
]
}
;
if
path
.
is_null
(
)
{
anyhow
:
:
bail
!
(
"
NSSearchPathForDirectoriesInDomains
returned
no
paths
"
)
;
}
let
str_pointer
:
*
const
i8
=
unsafe
{
msg_send
!
[
path
UTF8String
]
}
;
/
/
#
Safety
/
/
The
pointer
is
a
readable
C
string
with
a
null
terminator
.
let
Ok
(
s
)
=
unsafe
{
std
:
:
ffi
:
:
CStr
:
:
from_ptr
(
str_pointer
)
}
.
to_str
(
)
else
{
anyhow
:
:
bail
!
(
"
NSString
wasn
'
t
valid
UTF8
"
)
;
}
;
Ok
(
PathBuf
:
:
from
(
s
)
)
}
)
?
;
data_path
.
push
(
product
)
;
std
:
:
fs
:
:
create_dir_all
(
&
data_path
)
.
with_context
(
|
|
{
self
.
build_string
(
"
crashreporter
-
error
-
creating
-
dir
"
)
.
arg
(
"
path
"
data_path
.
display
(
)
.
to_string
(
)
)
.
get
(
)
}
)
?
;
data_path
.
push
(
"
Crash
Reports
"
)
;
Ok
(
data_path
)
}
}
else
if
#
[
cfg
(
target_os
=
"
windows
"
)
]
{
fn
get_data_dir
(
&
self
vendor
:
&
str
product
:
&
str
)
-
>
anyhow
:
:
Result
<
PathBuf
>
{
use
crate
:
:
std
:
:
os
:
:
windows
:
:
ffi
:
:
OsStringExt
;
use
windows_sys
:
:
{
core
:
:
PWSTR
Win32
:
:
{
Globalization
:
:
lstrlenW
System
:
:
Com
:
:
CoTaskMemFree
UI
:
:
Shell
:
:
{
FOLDERID_RoamingAppData
SHGetKnownFolderPath
}
}
}
;
let
mut
path
:
PWSTR
=
std
:
:
ptr
:
:
null_mut
(
)
;
let
result
=
unsafe
{
SHGetKnownFolderPath
(
&
FOLDERID_RoamingAppData
0
0
&
mut
path
)
}
;
if
result
!
=
0
{
unsafe
{
CoTaskMemFree
(
path
as
_
)
}
;
anyhow
:
:
bail
!
(
"
failed
to
get
known
path
for
roaming
appdata
"
)
;
}
let
length
=
unsafe
{
lstrlenW
(
path
)
}
;
let
slice
=
unsafe
{
std
:
:
slice
:
:
from_raw_parts
(
path
length
as
usize
)
}
;
let
osstr
=
OsString
:
:
from_wide
(
slice
)
;
unsafe
{
CoTaskMemFree
(
path
as
_
)
}
;
let
mut
path
=
PathBuf
:
:
from
(
osstr
)
;
path
.
push
(
vendor
)
;
path
.
push
(
product
)
;
path
.
push
(
"
Crash
Reports
"
)
;
Ok
(
path
)
}
}
}
}
pub
fn
sibling_path
<
N
:
AsRef
<
OsStr
>
>
(
file
:
N
)
-
>
PathBuf
{
let
dir_path
=
self_path
(
)
.
parent
(
)
.
expect
(
"
program
invoked
based
on
PATH
"
)
;
let
mut
path
=
dir_path
.
join
(
file
.
as_ref
(
)
)
;
if
!
path
.
exists
(
)
&
&
cfg
!
(
all
(
not
(
mock
)
target_os
=
"
macos
"
)
)
{
if
let
Some
(
ancestor
)
=
dir_path
.
ancestors
(
)
.
nth
(
3
)
{
path
=
ancestor
.
join
(
file
.
as_ref
(
)
)
;
}
}
path
}
fn
self_path
(
)
-
>
&
'
static
Path
{
static
PATH
:
Lazy
<
PathBuf
>
=
Lazy
:
:
new
(
|
|
{
PathBuf
:
:
from
(
std
:
:
env
:
:
args_os
(
)
.
next
(
)
.
expect
(
"
failed
to
get
argv
[
0
]
"
)
)
}
)
;
&
*
PATH
}
fn
env_bool
<
K
:
AsRef
<
OsStr
>
>
(
name
:
K
)
-
>
bool
{
std
:
:
env
:
:
var
(
name
)
.
map
(
|
s
|
!
s
.
is_empty
(
)
)
.
unwrap_or
(
false
)
}
fn
env_path
<
K
:
AsRef
<
OsStr
>
>
(
name
:
K
)
-
>
Option
<
PathBuf
>
{
std
:
:
env
:
:
var_os
(
name
)
.
map
(
PathBuf
:
:
from
)
}
fn
extra_file_for_dump_file
(
mut
dump_file
:
PathBuf
)
-
>
PathBuf
{
dump_file
.
set_extension
(
"
extra
"
)
;
dump_file
}
fn
memory_file_for_dump_file
(
mut
dump_file
:
PathBuf
)
-
>
PathBuf
{
dump_file
.
set_extension
(
"
memory
.
json
.
gz
"
)
;
dump_file
}
