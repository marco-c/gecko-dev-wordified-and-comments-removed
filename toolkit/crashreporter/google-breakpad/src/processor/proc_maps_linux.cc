#
ifndef
__STDC_FORMAT_MACROS
#
define
__STDC_FORMAT_MACROS
#
endif
#
include
"
google_breakpad
/
processor
/
proc_maps_linux
.
h
"
#
include
<
fcntl
.
h
>
#
include
<
inttypes
.
h
>
#
include
<
stdio
.
h
>
#
include
"
processor
/
logging
.
h
"
#
if
defined
(
OS_ANDROID
)
&
&
!
defined
(
__LP64__
)
#
undef
SCNxPTR
#
define
SCNxPTR
"
x
"
#
endif
namespace
google_breakpad
{
bool
ParseProcMaps
(
const
std
:
:
string
&
input
std
:
:
vector
<
MappedMemoryRegion
>
*
regions_out
)
{
std
:
:
vector
<
MappedMemoryRegion
>
regions
;
std
:
:
vector
<
std
:
:
string
>
lines
;
std
:
:
string
l
=
"
"
;
for
(
size_t
i
=
0
;
i
<
input
.
size
(
)
;
i
+
+
)
{
if
(
input
[
i
]
!
=
'
\
n
'
&
&
input
[
i
]
!
=
'
\
r
'
)
{
l
.
push_back
(
input
[
i
]
)
;
}
else
if
(
l
.
size
(
)
>
0
)
{
lines
.
push_back
(
l
)
;
l
.
clear
(
)
;
}
}
if
(
l
.
size
(
)
>
0
)
{
BPLOG
(
ERROR
)
<
<
"
Input
doesn
'
t
end
in
newline
"
;
return
false
;
}
for
(
size_t
i
=
0
;
i
<
lines
.
size
(
)
;
+
+
i
)
{
MappedMemoryRegion
region
;
const
char
*
line
=
lines
[
i
]
.
c_str
(
)
;
char
permissions
[
5
]
=
{
'
\
0
'
}
;
int
path_index
=
0
;
if
(
sscanf
(
line
"
%
"
SCNx64
"
-
%
"
SCNx64
"
%
4c
%
"
SCNx64
"
%
hhx
:
%
hhx
%
"
SCNd64
"
%
n
"
&
region
.
start
&
region
.
end
permissions
&
region
.
offset
&
region
.
major_device
&
region
.
minor_device
&
region
.
inode
&
path_index
)
<
7
)
{
BPLOG
(
ERROR
)
<
<
"
sscanf
failed
for
line
:
"
<
<
line
;
return
false
;
}
region
.
permissions
=
0
;
if
(
permissions
[
0
]
=
=
'
r
'
)
region
.
permissions
|
=
MappedMemoryRegion
:
:
READ
;
else
if
(
permissions
[
0
]
!
=
'
-
'
)
return
false
;
if
(
permissions
[
1
]
=
=
'
w
'
)
region
.
permissions
|
=
MappedMemoryRegion
:
:
WRITE
;
else
if
(
permissions
[
1
]
!
=
'
-
'
)
return
false
;
if
(
permissions
[
2
]
=
=
'
x
'
)
region
.
permissions
|
=
MappedMemoryRegion
:
:
EXECUTE
;
else
if
(
permissions
[
2
]
!
=
'
-
'
)
return
false
;
if
(
permissions
[
3
]
=
=
'
p
'
)
region
.
permissions
|
=
MappedMemoryRegion
:
:
PRIVATE
;
else
if
(
permissions
[
3
]
!
=
'
s
'
&
&
permissions
[
3
]
!
=
'
S
'
)
return
false
;
regions
.
push_back
(
region
)
;
regions
.
back
(
)
.
path
.
assign
(
line
+
path_index
)
;
regions
.
back
(
)
.
line
.
assign
(
line
)
;
}
regions_out
-
>
swap
(
regions
)
;
return
true
;
}
}
