#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
common
/
scoped_ptr
.
h
"
#
include
"
common
/
using_std_string
.
h
"
#
include
"
google_breakpad
/
processor
/
basic_source_line_resolver
.
h
"
#
include
"
google_breakpad
/
processor
/
minidump
.
h
"
#
include
"
google_breakpad
/
processor
/
minidump_processor
.
h
"
#
include
"
google_breakpad
/
processor
/
process_state
.
h
"
#
include
"
processor
/
logging
.
h
"
#
include
"
processor
/
simple_symbol_supplier
.
h
"
#
include
"
processor
/
stackwalk_common
.
h
"
namespace
{
using
google_breakpad
:
:
BasicSourceLineResolver
;
using
google_breakpad
:
:
Minidump
;
using
google_breakpad
:
:
MinidumpProcessor
;
using
google_breakpad
:
:
ProcessState
;
using
google_breakpad
:
:
SimpleSymbolSupplier
;
using
google_breakpad
:
:
scoped_ptr
;
bool
PrintMinidumpProcess
(
const
string
&
minidump_file
const
std
:
:
vector
<
string
>
&
symbol_paths
bool
machine_readable
bool
output_stack_contents
)
{
scoped_ptr
<
SimpleSymbolSupplier
>
symbol_supplier
;
if
(
!
symbol_paths
.
empty
(
)
)
{
symbol_supplier
.
reset
(
new
SimpleSymbolSupplier
(
symbol_paths
)
)
;
}
BasicSourceLineResolver
resolver
;
MinidumpProcessor
minidump_processor
(
symbol_supplier
.
get
(
)
&
resolver
)
;
Minidump
dump
(
minidump_file
)
;
if
(
!
dump
.
Read
(
)
)
{
BPLOG
(
ERROR
)
<
<
"
Minidump
"
<
<
dump
.
path
(
)
<
<
"
could
not
be
read
"
;
return
false
;
}
ProcessState
process_state
;
if
(
minidump_processor
.
Process
(
&
dump
&
process_state
)
!
=
google_breakpad
:
:
PROCESS_OK
)
{
BPLOG
(
ERROR
)
<
<
"
MinidumpProcessor
:
:
Process
failed
"
;
return
false
;
}
if
(
machine_readable
)
{
PrintProcessStateMachineReadable
(
process_state
)
;
}
else
{
PrintProcessState
(
process_state
output_stack_contents
&
resolver
)
;
}
return
true
;
}
void
usage
(
const
char
*
program_name
)
{
fprintf
(
stderr
"
usage
:
%
s
[
-
m
|
-
s
]
<
minidump
-
file
>
[
symbol
-
path
.
.
.
]
\
n
"
"
-
m
:
Output
in
machine
-
readable
format
\
n
"
"
-
s
:
Output
stack
contents
\
n
"
program_name
)
;
}
}
int
main
(
int
argc
char
*
*
argv
)
{
BPLOG_INIT
(
&
argc
&
argv
)
;
if
(
argc
<
2
)
{
usage
(
argv
[
0
]
)
;
return
1
;
}
const
char
*
minidump_file
;
bool
machine_readable
=
false
;
bool
output_stack_contents
=
false
;
int
symbol_path_arg
;
if
(
strcmp
(
argv
[
1
]
"
-
m
"
)
=
=
0
)
{
if
(
argc
<
3
)
{
usage
(
argv
[
0
]
)
;
return
1
;
}
machine_readable
=
true
;
minidump_file
=
argv
[
2
]
;
symbol_path_arg
=
3
;
}
else
if
(
strcmp
(
argv
[
1
]
"
-
s
"
)
=
=
0
)
{
if
(
argc
<
3
)
{
usage
(
argv
[
0
]
)
;
return
1
;
}
output_stack_contents
=
true
;
minidump_file
=
argv
[
2
]
;
symbol_path_arg
=
3
;
}
else
{
minidump_file
=
argv
[
1
]
;
symbol_path_arg
=
2
;
}
std
:
:
vector
<
string
>
symbol_paths
;
if
(
argc
>
symbol_path_arg
)
{
for
(
int
argi
=
symbol_path_arg
;
argi
<
argc
;
+
+
argi
)
symbol_paths
.
push_back
(
argv
[
argi
]
)
;
}
return
PrintMinidumpProcess
(
minidump_file
symbol_paths
machine_readable
output_stack_contents
)
?
0
:
1
;
}
