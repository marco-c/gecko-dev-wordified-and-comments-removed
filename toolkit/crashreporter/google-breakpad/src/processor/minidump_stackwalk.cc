#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
unistd
.
h
>
#
include
<
limits
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
common
/
path_helper
.
h
"
#
include
"
common
/
scoped_ptr
.
h
"
#
include
"
common
/
using_std_string
.
h
"
#
include
"
google_breakpad
/
processor
/
basic_source_line_resolver
.
h
"
#
include
"
google_breakpad
/
processor
/
minidump
.
h
"
#
include
"
google_breakpad
/
processor
/
minidump_processor
.
h
"
#
include
"
google_breakpad
/
processor
/
process_state
.
h
"
#
include
"
processor
/
logging
.
h
"
#
include
"
processor
/
simple_symbol_supplier
.
h
"
#
include
"
processor
/
stackwalk_common
.
h
"
namespace
{
struct
Options
{
bool
machine_readable
;
bool
output_stack_contents
;
string
minidump_file
;
std
:
:
vector
<
string
>
symbol_paths
;
}
;
using
google_breakpad
:
:
BasicSourceLineResolver
;
using
google_breakpad
:
:
Minidump
;
using
google_breakpad
:
:
MinidumpMemoryList
;
using
google_breakpad
:
:
MinidumpThreadList
;
using
google_breakpad
:
:
MinidumpProcessor
;
using
google_breakpad
:
:
ProcessState
;
using
google_breakpad
:
:
SimpleSymbolSupplier
;
using
google_breakpad
:
:
scoped_ptr
;
bool
PrintMinidumpProcess
(
const
Options
&
options
)
{
scoped_ptr
<
SimpleSymbolSupplier
>
symbol_supplier
;
if
(
!
options
.
symbol_paths
.
empty
(
)
)
{
symbol_supplier
.
reset
(
new
SimpleSymbolSupplier
(
options
.
symbol_paths
)
)
;
}
BasicSourceLineResolver
resolver
;
MinidumpProcessor
minidump_processor
(
symbol_supplier
.
get
(
)
&
resolver
)
;
MinidumpThreadList
:
:
set_max_threads
(
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
;
MinidumpMemoryList
:
:
set_max_regions
(
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
;
Minidump
dump
(
options
.
minidump_file
)
;
if
(
!
dump
.
Read
(
)
)
{
BPLOG
(
ERROR
)
<
<
"
Minidump
"
<
<
dump
.
path
(
)
<
<
"
could
not
be
read
"
;
return
false
;
}
ProcessState
process_state
;
if
(
minidump_processor
.
Process
(
&
dump
&
process_state
)
!
=
google_breakpad
:
:
PROCESS_OK
)
{
BPLOG
(
ERROR
)
<
<
"
MinidumpProcessor
:
:
Process
failed
"
;
return
false
;
}
if
(
options
.
machine_readable
)
{
PrintProcessStateMachineReadable
(
process_state
)
;
}
else
{
PrintProcessState
(
process_state
options
.
output_stack_contents
&
resolver
)
;
}
return
true
;
}
}
static
void
Usage
(
int
argc
const
char
*
argv
[
]
bool
error
)
{
fprintf
(
error
?
stderr
:
stdout
"
Usage
:
%
s
[
options
]
<
minidump
-
file
>
[
symbol
-
path
.
.
.
]
\
n
"
"
\
n
"
"
Output
a
stack
trace
for
the
provided
minidump
\
n
"
"
\
n
"
"
Options
:
\
n
"
"
\
n
"
"
-
m
Output
in
machine
-
readable
format
\
n
"
"
-
s
Output
stack
contents
\
n
"
google_breakpad
:
:
BaseName
(
argv
[
0
]
)
.
c_str
(
)
)
;
}
static
void
SetupOptions
(
int
argc
const
char
*
argv
[
]
Options
*
options
)
{
int
ch
;
options
-
>
machine_readable
=
false
;
options
-
>
output_stack_contents
=
false
;
while
(
(
ch
=
getopt
(
argc
(
char
*
const
*
)
argv
"
hms
"
)
)
!
=
-
1
)
{
switch
(
ch
)
{
case
'
h
'
:
Usage
(
argc
argv
false
)
;
exit
(
0
)
;
break
;
case
'
m
'
:
options
-
>
machine_readable
=
true
;
break
;
case
'
s
'
:
options
-
>
output_stack_contents
=
true
;
break
;
case
'
?
'
:
Usage
(
argc
argv
true
)
;
exit
(
1
)
;
break
;
}
}
if
(
(
argc
-
optind
)
=
=
0
)
{
fprintf
(
stderr
"
%
s
:
Missing
minidump
file
\
n
"
argv
[
0
]
)
;
Usage
(
argc
argv
true
)
;
exit
(
1
)
;
}
options
-
>
minidump_file
=
argv
[
optind
]
;
for
(
int
argi
=
optind
+
1
;
argi
<
argc
;
+
+
argi
)
options
-
>
symbol_paths
.
push_back
(
argv
[
argi
]
)
;
}
int
main
(
int
argc
const
char
*
argv
[
]
)
{
Options
options
;
SetupOptions
(
argc
argv
&
options
)
;
return
PrintMinidumpProcess
(
options
)
?
0
:
1
;
}
