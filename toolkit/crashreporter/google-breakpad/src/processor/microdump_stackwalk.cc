#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
unistd
.
h
>
#
include
<
fstream
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
common
/
path_helper
.
h
"
#
include
"
common
/
scoped_ptr
.
h
"
#
include
"
common
/
using_std_string
.
h
"
#
include
"
google_breakpad
/
processor
/
basic_source_line_resolver
.
h
"
#
include
"
google_breakpad
/
processor
/
microdump
.
h
"
#
include
"
google_breakpad
/
processor
/
microdump_processor
.
h
"
#
include
"
google_breakpad
/
processor
/
process_state
.
h
"
#
include
"
google_breakpad
/
processor
/
stack_frame_symbolizer
.
h
"
#
include
"
processor
/
logging
.
h
"
#
include
"
processor
/
simple_symbol_supplier
.
h
"
#
include
"
processor
/
stackwalk_common
.
h
"
namespace
{
struct
Options
{
bool
machine_readable
;
bool
output_stack_contents
;
string
microdump_file
;
std
:
:
vector
<
string
>
symbol_paths
;
}
;
using
google_breakpad
:
:
BasicSourceLineResolver
;
using
google_breakpad
:
:
Microdump
;
using
google_breakpad
:
:
MicrodumpProcessor
;
using
google_breakpad
:
:
ProcessResult
;
using
google_breakpad
:
:
ProcessState
;
using
google_breakpad
:
:
scoped_ptr
;
using
google_breakpad
:
:
SimpleSymbolSupplier
;
using
google_breakpad
:
:
StackFrameSymbolizer
;
int
PrintMicrodumpProcess
(
const
Options
&
options
)
{
std
:
:
ifstream
file_stream
(
options
.
microdump_file
)
;
std
:
:
vector
<
char
>
bytes
;
file_stream
.
seekg
(
0
std
:
:
ios_base
:
:
end
)
;
bytes
.
resize
(
file_stream
.
tellg
(
)
)
;
if
(
bytes
.
empty
(
)
)
{
BPLOG
(
ERROR
)
<
<
"
Microdump
is
empty
.
"
;
return
1
;
}
file_stream
.
seekg
(
0
std
:
:
ios_base
:
:
beg
)
;
file_stream
.
read
(
&
bytes
[
0
]
bytes
.
size
(
)
)
;
string
microdump_content
(
&
bytes
[
0
]
bytes
.
size
(
)
)
;
scoped_ptr
<
SimpleSymbolSupplier
>
symbol_supplier
;
if
(
!
options
.
symbol_paths
.
empty
(
)
)
{
symbol_supplier
.
reset
(
new
SimpleSymbolSupplier
(
options
.
symbol_paths
)
)
;
}
BasicSourceLineResolver
resolver
;
StackFrameSymbolizer
frame_symbolizer
(
symbol_supplier
.
get
(
)
&
resolver
)
;
ProcessState
process_state
;
MicrodumpProcessor
microdump_processor
(
&
frame_symbolizer
)
;
Microdump
microdump
(
microdump_content
)
;
ProcessResult
res
=
microdump_processor
.
Process
(
&
microdump
&
process_state
)
;
if
(
res
=
=
google_breakpad
:
:
PROCESS_OK
)
{
if
(
options
.
machine_readable
)
{
PrintProcessStateMachineReadable
(
process_state
)
;
}
else
{
PrintProcessState
(
process_state
options
.
output_stack_contents
&
resolver
)
;
}
return
0
;
}
BPLOG
(
ERROR
)
<
<
"
MicrodumpProcessor
:
:
Process
failed
(
code
=
"
<
<
res
<
<
"
)
"
;
return
1
;
}
}
static
void
Usage
(
int
argc
const
char
*
argv
[
]
bool
error
)
{
fprintf
(
error
?
stderr
:
stdout
"
Usage
:
%
s
[
options
]
<
microdump
-
file
>
[
symbol
-
path
.
.
.
]
\
n
"
"
\
n
"
"
Output
a
stack
trace
for
the
provided
microdump
\
n
"
"
\
n
"
"
Options
:
\
n
"
"
\
n
"
"
-
m
Output
in
machine
-
readable
format
\
n
"
"
-
s
Output
stack
contents
\
n
"
google_breakpad
:
:
BaseName
(
argv
[
0
]
)
.
c_str
(
)
)
;
}
static
void
SetupOptions
(
int
argc
const
char
*
argv
[
]
Options
*
options
)
{
int
ch
;
options
-
>
machine_readable
=
false
;
options
-
>
output_stack_contents
=
false
;
while
(
(
ch
=
getopt
(
argc
(
char
*
const
*
)
argv
"
hms
"
)
)
!
=
-
1
)
{
switch
(
ch
)
{
case
'
h
'
:
Usage
(
argc
argv
false
)
;
exit
(
0
)
;
break
;
case
'
m
'
:
options
-
>
machine_readable
=
true
;
break
;
case
'
s
'
:
options
-
>
output_stack_contents
=
true
;
break
;
case
'
?
'
:
Usage
(
argc
argv
true
)
;
exit
(
1
)
;
break
;
}
}
if
(
(
argc
-
optind
)
=
=
0
)
{
fprintf
(
stderr
"
%
s
:
Missing
microdump
file
\
n
"
argv
[
0
]
)
;
Usage
(
argc
argv
true
)
;
exit
(
1
)
;
}
options
-
>
microdump_file
=
argv
[
optind
]
;
for
(
int
argi
=
optind
+
1
;
argi
<
argc
;
+
+
argi
)
options
-
>
symbol_paths
.
push_back
(
argv
[
argi
]
)
;
}
int
main
(
int
argc
const
char
*
argv
[
]
)
{
Options
options
;
SetupOptions
(
argc
argv
&
options
)
;
return
PrintMicrodumpProcess
(
options
)
;
}
