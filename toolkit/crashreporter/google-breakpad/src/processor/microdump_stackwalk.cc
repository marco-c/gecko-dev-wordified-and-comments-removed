#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
fstream
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
common
/
scoped_ptr
.
h
"
#
include
"
common
/
using_std_string
.
h
"
#
include
"
google_breakpad
/
processor
/
basic_source_line_resolver
.
h
"
#
include
"
google_breakpad
/
processor
/
microdump_processor
.
h
"
#
include
"
google_breakpad
/
processor
/
process_state
.
h
"
#
include
"
google_breakpad
/
processor
/
stack_frame_symbolizer
.
h
"
#
include
"
processor
/
logging
.
h
"
#
include
"
processor
/
simple_symbol_supplier
.
h
"
#
include
"
processor
/
stackwalk_common
.
h
"
namespace
{
using
google_breakpad
:
:
BasicSourceLineResolver
;
using
google_breakpad
:
:
MicrodumpProcessor
;
using
google_breakpad
:
:
ProcessResult
;
using
google_breakpad
:
:
ProcessState
;
using
google_breakpad
:
:
scoped_ptr
;
using
google_breakpad
:
:
SimpleSymbolSupplier
;
using
google_breakpad
:
:
StackFrameSymbolizer
;
int
PrintMicrodumpProcess
(
const
char
*
microdump_file
const
std
:
:
vector
<
string
>
&
symbol_paths
bool
machine_readable
)
{
std
:
:
ifstream
file_stream
(
microdump_file
)
;
std
:
:
vector
<
char
>
bytes
;
file_stream
.
seekg
(
0
std
:
:
ios_base
:
:
end
)
;
bytes
.
resize
(
file_stream
.
tellg
(
)
)
;
file_stream
.
seekg
(
0
std
:
:
ios_base
:
:
beg
)
;
file_stream
.
read
(
&
bytes
[
0
]
bytes
.
size
(
)
)
;
string
microdump_content
(
&
bytes
[
0
]
bytes
.
size
(
)
)
;
scoped_ptr
<
SimpleSymbolSupplier
>
symbol_supplier
;
if
(
!
symbol_paths
.
empty
(
)
)
{
symbol_supplier
.
reset
(
new
SimpleSymbolSupplier
(
symbol_paths
)
)
;
}
BasicSourceLineResolver
resolver
;
StackFrameSymbolizer
frame_symbolizer
(
symbol_supplier
.
get
(
)
&
resolver
)
;
ProcessState
process_state
;
MicrodumpProcessor
microdump_processor
(
&
frame_symbolizer
)
;
ProcessResult
res
=
microdump_processor
.
Process
(
microdump_content
&
process_state
)
;
if
(
res
=
=
google_breakpad
:
:
PROCESS_OK
)
{
if
(
machine_readable
)
{
PrintProcessStateMachineReadable
(
process_state
)
;
}
else
{
PrintProcessState
(
process_state
false
&
resolver
)
;
}
return
0
;
}
BPLOG
(
ERROR
)
<
<
"
MicrodumpProcessor
:
:
Process
failed
(
code
=
"
<
<
res
<
<
"
)
"
;
return
1
;
}
void
usage
(
const
char
*
program_name
)
{
fprintf
(
stderr
"
usage
:
%
s
[
-
m
]
<
microdump
-
file
>
[
symbol
-
path
.
.
.
]
\
n
"
"
-
m
:
Output
in
machine
-
readable
format
\
n
"
program_name
)
;
}
}
int
main
(
int
argc
char
*
*
argv
)
{
BPLOG_INIT
(
&
argc
&
argv
)
;
if
(
argc
<
2
)
{
usage
(
argv
[
0
]
)
;
return
1
;
}
const
char
*
microdump_file
;
bool
machine_readable
;
int
symbol_path_arg
;
if
(
strcmp
(
argv
[
1
]
"
-
m
"
)
=
=
0
)
{
if
(
argc
<
3
)
{
usage
(
argv
[
0
]
)
;
return
1
;
}
machine_readable
=
true
;
microdump_file
=
argv
[
2
]
;
symbol_path_arg
=
3
;
}
else
{
machine_readable
=
false
;
microdump_file
=
argv
[
1
]
;
symbol_path_arg
=
2
;
}
std
:
:
vector
<
string
>
symbol_paths
;
if
(
argc
>
symbol_path_arg
)
{
for
(
int
argi
=
symbol_path_arg
;
argi
<
argc
;
+
+
argi
)
symbol_paths
.
push_back
(
argv
[
argi
]
)
;
}
return
PrintMicrodumpProcess
(
microdump_file
symbol_paths
machine_readable
)
;
}
