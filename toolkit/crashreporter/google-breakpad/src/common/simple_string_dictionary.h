#
ifndef
COMMON_SIMPLE_STRING_DICTIONARY_H_
#
define
COMMON_SIMPLE_STRING_DICTIONARY_H_
#
include
<
assert
.
h
>
#
include
<
string
.
h
>
#
include
"
common
/
basictypes
.
h
"
namespace
google_breakpad
{
struct
SerializedNonAllocatingMap
;
template
<
size_t
KeySize
size_t
ValueSize
size_t
NumEntries
>
class
NonAllocatingMap
{
public
:
static
const
size_t
key_size
=
KeySize
;
static
const
size_t
value_size
=
ValueSize
;
static
const
size_t
num_entries
=
NumEntries
;
struct
Entry
{
char
key
[
KeySize
]
;
char
value
[
ValueSize
]
;
bool
is_active
(
)
const
{
return
key
[
0
]
!
=
'
\
0
'
;
}
}
;
class
Iterator
{
public
:
explicit
Iterator
(
const
NonAllocatingMap
&
map
)
:
map_
(
map
)
current_
(
0
)
{
}
const
Entry
*
Next
(
)
{
while
(
current_
<
map_
.
num_entries
)
{
const
Entry
*
entry
=
&
map_
.
entries_
[
current_
+
+
]
;
if
(
entry
-
>
is_active
(
)
)
{
return
entry
;
}
}
return
NULL
;
}
private
:
const
NonAllocatingMap
&
map_
;
size_t
current_
;
DISALLOW_COPY_AND_ASSIGN
(
Iterator
)
;
}
;
NonAllocatingMap
(
)
:
entries_
(
)
{
}
NonAllocatingMap
(
const
NonAllocatingMap
&
other
)
{
*
this
=
other
;
}
NonAllocatingMap
&
operator
=
(
const
NonAllocatingMap
&
other
)
{
assert
(
other
.
key_size
=
=
key_size
)
;
assert
(
other
.
value_size
=
=
value_size
)
;
assert
(
other
.
num_entries
=
=
num_entries
)
;
if
(
other
.
key_size
=
=
key_size
&
&
other
.
value_size
=
=
value_size
&
&
other
.
num_entries
=
=
num_entries
)
{
memcpy
(
entries_
other
.
entries_
sizeof
(
entries_
)
)
;
}
return
*
this
;
}
NonAllocatingMap
(
const
SerializedNonAllocatingMap
*
map
size_t
size
)
{
assert
(
size
=
=
sizeof
(
entries_
)
)
;
if
(
size
=
=
sizeof
(
entries_
)
)
{
memcpy
(
entries_
map
size
)
;
}
}
size_t
GetCount
(
)
const
{
size_t
count
=
0
;
for
(
size_t
i
=
0
;
i
<
num_entries
;
+
+
i
)
{
if
(
entries_
[
i
]
.
is_active
(
)
)
{
+
+
count
;
}
}
return
count
;
}
const
char
*
GetValueForKey
(
const
char
*
key
)
const
{
assert
(
key
)
;
if
(
!
key
)
return
NULL
;
const
Entry
*
entry
=
GetConstEntryForKey
(
key
)
;
if
(
!
entry
)
return
NULL
;
return
entry
-
>
value
;
}
void
SetKeyValue
(
const
char
*
key
const
char
*
value
)
{
if
(
!
value
)
{
RemoveKey
(
key
)
;
return
;
}
assert
(
key
)
;
if
(
!
key
)
return
;
assert
(
key
[
0
]
!
=
'
\
0
'
)
;
if
(
key
[
0
]
=
=
'
\
0
'
)
return
;
Entry
*
entry
=
GetEntryForKey
(
key
)
;
if
(
!
entry
)
{
for
(
size_t
i
=
0
;
i
<
num_entries
;
+
+
i
)
{
if
(
!
entries_
[
i
]
.
is_active
(
)
)
{
entry
=
&
entries_
[
i
]
;
strncpy
(
entry
-
>
key
key
key_size
)
;
entry
-
>
key
[
key_size
-
1
]
=
'
\
0
'
;
break
;
}
}
}
if
(
!
entry
)
return
;
#
ifndef
NDEBUG
int
count
=
0
;
for
(
size_t
i
=
0
;
i
<
num_entries
;
+
+
i
)
{
if
(
strncmp
(
entries_
[
i
]
.
key
key
key_size
)
=
=
0
)
+
+
count
;
}
assert
(
count
=
=
1
)
;
#
endif
strncpy
(
entry
-
>
value
value
value_size
)
;
entry
-
>
value
[
value_size
-
1
]
=
'
\
0
'
;
}
void
RemoveKey
(
const
char
*
key
)
{
assert
(
key
)
;
if
(
!
key
)
return
;
Entry
*
entry
=
GetEntryForKey
(
key
)
;
if
(
entry
)
{
entry
-
>
key
[
0
]
=
'
\
0
'
;
entry
-
>
value
[
0
]
=
'
\
0
'
;
}
#
ifndef
NDEBUG
assert
(
GetEntryForKey
(
key
)
=
=
NULL
)
;
#
endif
}
size_t
Serialize
(
const
SerializedNonAllocatingMap
*
*
map
)
const
{
*
map
=
reinterpret_cast
<
const
SerializedNonAllocatingMap
*
>
(
entries_
)
;
return
sizeof
(
entries_
)
;
}
private
:
const
Entry
*
GetConstEntryForKey
(
const
char
*
key
)
const
{
for
(
size_t
i
=
0
;
i
<
num_entries
;
+
+
i
)
{
if
(
strncmp
(
key
entries_
[
i
]
.
key
key_size
)
=
=
0
)
{
return
&
entries_
[
i
]
;
}
}
return
NULL
;
}
Entry
*
GetEntryForKey
(
const
char
*
key
)
{
return
const_cast
<
Entry
*
>
(
GetConstEntryForKey
(
key
)
)
;
}
Entry
entries_
[
NumEntries
]
;
}
;
typedef
NonAllocatingMap
<
256
256
64
>
SimpleStringDictionary
;
}
#
endif
