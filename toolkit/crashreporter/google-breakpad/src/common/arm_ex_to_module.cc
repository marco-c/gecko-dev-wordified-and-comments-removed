#
include
"
common
/
arm_ex_to_module
.
h
"
#
include
<
stdio
.
h
>
#
include
<
assert
.
h
>
#
define
ARM_EXBUF_START
(
x
)
(
(
(
x
)
>
>
4
)
&
0x0f
)
#
define
ARM_EXBUF_COUNT
(
x
)
(
(
x
)
&
0x0f
)
#
define
ARM_EXBUF_END
(
x
)
(
ARM_EXBUF_START
(
x
)
+
ARM_EXBUF_COUNT
(
x
)
)
using
google_breakpad
:
:
Module
;
namespace
arm_ex_to_module
{
static
const
char
*
const
regnames
[
]
=
{
"
r0
"
"
r1
"
"
r2
"
"
r3
"
"
r4
"
"
r5
"
"
r6
"
"
r7
"
"
r8
"
"
r9
"
"
r10
"
"
r11
"
"
r12
"
"
sp
"
"
lr
"
"
pc
"
"
f0
"
"
f1
"
"
f2
"
"
f3
"
"
f4
"
"
f5
"
"
f6
"
"
f7
"
"
fps
"
"
cpsr
"
}
;
int
ARMExToModule
:
:
TranslateCmd
(
const
struct
extab_data
*
edata
Module
:
:
StackFrameEntry
*
entry
string
&
vsp
)
{
int
ret
=
0
;
switch
(
edata
-
>
cmd
)
{
case
ARM_EXIDX_CMD_FINISH
:
if
(
entry
-
>
initial_rules
.
find
(
"
pc
"
)
=
=
entry
-
>
initial_rules
.
end
(
)
)
{
if
(
entry
-
>
initial_rules
.
find
(
"
lr
"
)
=
=
entry
-
>
initial_rules
.
end
(
)
)
{
entry
-
>
initial_rules
[
"
pc
"
]
=
"
lr
"
;
}
else
{
entry
-
>
initial_rules
[
"
pc
"
]
=
entry
-
>
initial_rules
[
"
lr
"
]
;
}
}
break
;
case
ARM_EXIDX_CMD_SUB_FROM_VSP
:
{
char
c
[
16
]
;
sprintf
(
c
"
%
d
-
"
edata
-
>
data
)
;
vsp
+
=
c
;
}
break
;
case
ARM_EXIDX_CMD_ADD_TO_VSP
:
{
char
c
[
16
]
;
sprintf
(
c
"
%
d
+
"
edata
-
>
data
)
;
vsp
+
=
c
;
}
break
;
case
ARM_EXIDX_CMD_REG_POP
:
for
(
unsigned
int
i
=
0
;
i
<
16
;
i
+
+
)
{
if
(
edata
-
>
data
&
(
1
<
<
i
)
)
{
entry
-
>
initial_rules
[
regnames
[
i
]
]
=
vsp
+
"
^
"
;
vsp
+
=
"
4
+
"
;
}
}
if
(
edata
-
>
data
&
(
1
<
<
13
)
)
{
vsp
=
entry
-
>
initial_rules
[
"
sp
"
]
;
}
break
;
case
ARM_EXIDX_CMD_REG_TO_SP
:
{
assert
(
edata
-
>
data
<
16
)
;
const
char
*
const
regname
=
regnames
[
edata
-
>
data
]
;
if
(
entry
-
>
initial_rules
.
find
(
regname
)
=
=
entry
-
>
initial_rules
.
end
(
)
)
{
entry
-
>
initial_rules
[
"
sp
"
]
=
regname
;
}
else
{
entry
-
>
initial_rules
[
"
sp
"
]
=
entry
-
>
initial_rules
[
regname
]
;
}
vsp
=
entry
-
>
initial_rules
[
"
sp
"
]
;
break
;
}
case
ARM_EXIDX_CMD_VFP_POP
:
for
(
unsigned
int
i
=
ARM_EXBUF_START
(
edata
-
>
data
)
;
i
<
=
ARM_EXBUF_END
(
edata
-
>
data
)
;
i
+
+
)
{
vsp
+
=
"
8
+
"
;
}
if
(
!
(
edata
-
>
data
&
ARM_EXIDX_VFP_FSTMD
)
)
{
vsp
+
=
"
4
+
"
;
}
break
;
case
ARM_EXIDX_CMD_WREG_POP
:
for
(
unsigned
int
i
=
ARM_EXBUF_START
(
edata
-
>
data
)
;
i
<
=
ARM_EXBUF_END
(
edata
-
>
data
)
;
i
+
+
)
{
vsp
+
=
"
8
+
"
;
}
break
;
case
ARM_EXIDX_CMD_WCGR_POP
:
for
(
unsigned
int
i
=
0
;
i
<
4
;
i
+
+
)
{
if
(
edata
-
>
data
&
(
1
<
<
i
)
)
{
vsp
+
=
"
4
+
"
;
}
}
break
;
case
ARM_EXIDX_CMD_REFUSED
:
case
ARM_EXIDX_CMD_RESERVED
:
ret
=
-
1
;
break
;
}
return
ret
;
}
bool
ARMExToModule
:
:
HasStackFrame
(
uintptr_t
addr
size_t
size
)
{
uintptr_t
covered
=
addr
;
while
(
covered
<
addr
+
size
)
{
const
Module
:
:
StackFrameEntry
*
old_entry
=
module_
-
>
FindStackFrameEntryByAddress
(
covered
)
;
if
(
!
old_entry
)
{
return
false
;
}
covered
=
old_entry
-
>
address
+
old_entry
-
>
size
;
}
return
true
;
}
void
ARMExToModule
:
:
AddStackFrame
(
uintptr_t
addr
size_t
size
)
{
stack_frame_entry_
=
new
Module
:
:
StackFrameEntry
;
stack_frame_entry_
-
>
address
=
addr
;
stack_frame_entry_
-
>
size
=
size
;
stack_frame_entry_
-
>
initial_rules
[
"
.
cfa
"
]
=
"
sp
"
;
vsp_
=
"
sp
"
;
}
int
ARMExToModule
:
:
ImproveStackFrame
(
const
struct
extab_data
*
edata
)
{
return
TranslateCmd
(
edata
stack_frame_entry_
vsp_
)
;
}
void
ARMExToModule
:
:
DeleteStackFrame
(
)
{
delete
stack_frame_entry_
;
}
void
ARMExToModule
:
:
SubmitStackFrame
(
)
{
stack_frame_entry_
-
>
initial_rules
[
"
.
ra
"
]
=
stack_frame_entry_
-
>
initial_rules
[
"
pc
"
]
;
stack_frame_entry_
-
>
initial_rules
[
"
sp
"
]
=
vsp_
;
module_
-
>
AddStackFrameEntry
(
stack_frame_entry_
)
;
}
}
