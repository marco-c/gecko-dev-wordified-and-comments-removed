#
ifndef
_GNU_SOURCE
#
define
_GNU_SOURCE
#
endif
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
unistd
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
map
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
third_party
/
musl
/
include
/
elf
.
h
"
#
include
"
elf_reader
.
h
"
#
include
"
common
/
using_std_string
.
h
"
#
if
!
defined
(
EM_AARCH64
)
#
define
EM_AARCH64
183
/
*
ARM
AARCH64
*
/
#
endif
#
if
__APPLE__
#
ifndef
__LITTLE_ENDIAN
#
define
__LITTLE_ENDIAN
__ORDER_LITTLE_ENDIAN__
#
endif
#
ifndef
__BIG_ENDIAN
#
define
__BIG_ENDIAN
__ORDER_BIG_ENDIAN__
#
endif
#
ifndef
__BYTE_ORDER
#
define
__BYTE_ORDER
__BYTE_ORDER__
#
endif
#
endif
using
std
:
:
vector
;
namespace
{
const
int
kARMThumbBitOffset
=
0
;
template
<
typename
T
>
T
AdjustARMThumbSymbolValue
(
const
T
&
symbol_table_value
)
{
return
symbol_table_value
&
~
(
1
<
<
kARMThumbBitOffset
)
;
}
const
char
kElfPLTRelSectionName
[
]
=
"
.
rel
.
plt
"
;
const
char
kElfPLTRelaSectionName
[
]
=
"
.
rela
.
plt
"
;
const
char
kElfPLTSectionName
[
]
=
"
.
plt
"
;
const
char
kElfDynSymSectionName
[
]
=
"
.
dynsym
"
;
const
int
kX86PLTCodeSize
=
0x10
;
const
int
kARMPLTCodeSize
=
0xc
;
const
int
kAARCH64PLTCodeSize
=
0x10
;
const
int
kX86PLT0Size
=
0x10
;
const
int
kARMPLT0Size
=
0x14
;
const
int
kAARCH64PLT0Size
=
0x20
;
const
char
kPLTFunctionSuffix
[
]
=
"
plt
"
;
}
namespace
dwarf2reader
{
template
<
class
ElfArch
>
class
ElfReaderImpl
;
class
Elf32
{
public
:
typedef
Elf32_Ehdr
Ehdr
;
typedef
Elf32_Shdr
Shdr
;
typedef
Elf32_Phdr
Phdr
;
typedef
Elf32_Word
Word
;
typedef
Elf32_Sym
Sym
;
typedef
Elf32_Rel
Rel
;
typedef
Elf32_Rela
Rela
;
static
const
int
kElfClass
=
ELFCLASS32
;
static
char
Bind
(
const
Elf32_Sym
*
sym
)
{
return
ELF32_ST_BIND
(
sym
-
>
st_info
)
;
}
static
char
Type
(
const
Elf32_Sym
*
sym
)
{
return
ELF32_ST_TYPE
(
sym
-
>
st_info
)
;
}
static
int
r_sym
(
const
Elf32_Word
r_info
)
{
return
ELF32_R_SYM
(
r_info
)
;
}
}
;
class
Elf64
{
public
:
typedef
Elf64_Ehdr
Ehdr
;
typedef
Elf64_Shdr
Shdr
;
typedef
Elf64_Phdr
Phdr
;
typedef
Elf64_Word
Word
;
typedef
Elf64_Sym
Sym
;
typedef
Elf64_Rel
Rel
;
typedef
Elf64_Rela
Rela
;
static
const
int
kElfClass
=
ELFCLASS64
;
static
char
Bind
(
const
Elf64_Sym
*
sym
)
{
return
ELF64_ST_BIND
(
sym
-
>
st_info
)
;
}
static
char
Type
(
const
Elf64_Sym
*
sym
)
{
return
ELF64_ST_TYPE
(
sym
-
>
st_info
)
;
}
static
int
r_sym
(
const
Elf64_Xword
r_info
)
{
return
ELF64_R_SYM
(
r_info
)
;
}
}
;
template
<
class
ElfArch
>
class
ElfSectionReader
{
public
:
ElfSectionReader
(
const
char
*
name
const
string
&
path
int
fd
const
typename
ElfArch
:
:
Shdr
&
section_header
)
:
contents_aligned_
(
NULL
)
contents_
(
NULL
)
header_
(
section_header
)
{
const
size_t
additional
=
header_
.
sh_offset
%
getpagesize
(
)
;
const
size_t
offset_aligned
=
header_
.
sh_offset
-
additional
;
section_size_
=
header_
.
sh_size
;
size_aligned_
=
section_size_
+
additional
;
if
(
header_
.
sh_type
=
=
SHT_NOBITS
|
|
header_
.
sh_size
=
=
0
)
return
;
contents_aligned_
=
mmap
(
NULL
size_aligned_
PROT_READ
MAP_SHARED
fd
offset_aligned
)
;
contents_
=
reinterpret_cast
<
char
*
>
(
contents_aligned_
)
+
(
header_
.
sh_offset
-
offset_aligned
)
;
}
~
ElfSectionReader
(
)
{
if
(
contents_aligned_
!
=
NULL
)
munmap
(
contents_aligned_
size_aligned_
)
;
else
delete
[
]
contents_
;
}
typename
ElfArch
:
:
Shdr
const
&
header
(
)
const
{
return
header_
;
}
const
char
*
GetOffset
(
typename
ElfArch
:
:
Word
bytes
)
const
{
return
contents_
+
bytes
;
}
const
char
*
contents
(
)
const
{
return
contents_
;
}
size_t
section_size
(
)
const
{
return
section_size_
;
}
private
:
void
*
contents_aligned_
;
char
*
contents_
;
size_t
size_aligned_
;
size_t
section_size_
;
const
typename
ElfArch
:
:
Shdr
header_
;
}
;
template
<
class
ElfArch
>
class
SymbolIterator
{
public
:
SymbolIterator
(
ElfReaderImpl
<
ElfArch
>
*
reader
typename
ElfArch
:
:
Word
section_type
)
:
symbol_section_
(
reader
-
>
GetSectionByType
(
section_type
)
)
string_section_
(
NULL
)
num_symbols_in_section_
(
0
)
symbol_within_section_
(
0
)
{
if
(
symbol_section_
!
=
NULL
)
{
num_symbols_in_section_
=
symbol_section_
-
>
header
(
)
.
sh_size
/
symbol_section_
-
>
header
(
)
.
sh_entsize
;
string_section_
=
reader
-
>
GetSection
(
symbol_section_
-
>
header
(
)
.
sh_link
)
;
}
}
bool
done
(
)
const
{
return
symbol_within_section_
>
=
num_symbols_in_section_
;
}
void
Next
(
)
{
+
+
symbol_within_section_
;
}
const
typename
ElfArch
:
:
Sym
*
GetSymbol
(
)
const
{
return
reinterpret_cast
<
const
typename
ElfArch
:
:
Sym
*
>
(
symbol_section_
-
>
GetOffset
(
symbol_within_section_
*
symbol_section_
-
>
header
(
)
.
sh_entsize
)
)
;
}
const
char
*
GetSymbolName
(
)
const
{
int
name_offset
=
GetSymbol
(
)
-
>
st_name
;
if
(
name_offset
=
=
0
)
return
NULL
;
return
string_section_
-
>
GetOffset
(
name_offset
)
;
}
int
GetCurrentSymbolIndex
(
)
const
{
return
symbol_within_section_
;
}
private
:
const
ElfSectionReader
<
ElfArch
>
*
const
symbol_section_
;
const
ElfSectionReader
<
ElfArch
>
*
string_section_
;
int
num_symbols_in_section_
;
int
symbol_within_section_
;
}
;
static
inline
bool
MyHasSuffixString
(
const
string
&
str
const
string
&
suffix
)
{
int
len
=
str
.
length
(
)
;
int
suflen
=
suffix
.
length
(
)
;
return
(
suflen
<
=
len
)
&
&
(
str
.
compare
(
len
-
suflen
suflen
suffix
)
=
=
0
)
;
}
template
<
class
ElfArch
>
class
ElfReaderImpl
{
public
:
explicit
ElfReaderImpl
(
const
string
&
path
int
fd
)
:
path_
(
path
)
fd_
(
fd
)
section_headers_
(
NULL
)
program_headers_
(
NULL
)
opd_section_
(
NULL
)
base_for_text_
(
0
)
plts_supported_
(
false
)
plt_code_size_
(
0
)
plt0_size_
(
0
)
visited_relocation_entries_
(
false
)
{
string
error
;
is_dwp_
=
MyHasSuffixString
(
path
"
.
dwp
"
)
;
ParseHeaders
(
fd
path
)
;
if
(
header_
.
e_machine
=
=
EM_PPC64
)
{
opd_section_
=
GetSectionInfoByName
(
"
.
opd
"
&
opd_info_
)
;
for
(
unsigned
int
k
=
0u
;
k
<
GetNumSections
(
)
;
+
+
k
)
{
const
char
*
name
=
GetSectionName
(
section_headers_
[
k
]
.
sh_name
)
;
if
(
strncmp
(
name
"
.
text
"
strlen
(
"
.
text
"
)
)
=
=
0
)
{
base_for_text_
=
section_headers_
[
k
]
.
sh_addr
-
section_headers_
[
k
]
.
sh_offset
;
break
;
}
}
}
if
(
header_
.
e_machine
=
=
EM_386
|
|
header_
.
e_machine
=
=
EM_X86_64
)
{
plt_code_size_
=
kX86PLTCodeSize
;
plt0_size_
=
kX86PLT0Size
;
plts_supported_
=
true
;
}
else
if
(
header_
.
e_machine
=
=
EM_ARM
)
{
plt_code_size_
=
kARMPLTCodeSize
;
plt0_size_
=
kARMPLT0Size
;
plts_supported_
=
true
;
}
else
if
(
header_
.
e_machine
=
=
EM_AARCH64
)
{
plt_code_size_
=
kAARCH64PLTCodeSize
;
plt0_size_
=
kAARCH64PLT0Size
;
plts_supported_
=
true
;
}
}
~
ElfReaderImpl
(
)
{
for
(
unsigned
int
i
=
0u
;
i
<
sections_
.
size
(
)
;
+
+
i
)
delete
sections_
[
i
]
;
delete
[
]
section_headers_
;
delete
[
]
program_headers_
;
}
static
bool
IsArchElfFile
(
int
fd
string
*
error
)
{
unsigned
char
header
[
EI_NIDENT
]
;
if
(
pread
(
fd
header
sizeof
(
header
)
0
)
!
=
sizeof
(
header
)
)
{
if
(
error
!
=
NULL
)
*
error
=
"
Could
not
read
header
"
;
return
false
;
}
if
(
memcmp
(
header
ELFMAG
SELFMAG
)
!
=
0
)
{
if
(
error
!
=
NULL
)
*
error
=
"
Missing
ELF
magic
"
;
return
false
;
}
if
(
header
[
EI_CLASS
]
!
=
ElfArch
:
:
kElfClass
)
{
if
(
error
!
=
NULL
)
*
error
=
"
Different
word
size
"
;
return
false
;
}
int
endian
=
0
;
if
(
header
[
EI_DATA
]
=
=
ELFDATA2LSB
)
endian
=
__LITTLE_ENDIAN
;
else
if
(
header
[
EI_DATA
]
=
=
ELFDATA2MSB
)
endian
=
__BIG_ENDIAN
;
if
(
endian
!
=
__BYTE_ORDER
)
{
if
(
error
!
=
NULL
)
*
error
=
"
Different
byte
order
"
;
return
false
;
}
return
true
;
}
bool
CanUseSymbol
(
const
char
*
name
const
typename
ElfArch
:
:
Sym
*
sym
)
{
if
(
ElfArch
:
:
Type
(
sym
)
!
=
STT_FUNC
&
&
ElfArch
:
:
Type
(
sym
)
!
=
STT_NOTYPE
)
{
return
false
;
}
switch
(
header_
.
e_machine
)
{
case
EM_AARCH64
:
case
EM_ARM
:
return
name
[
0
]
!
=
'
'
|
|
ElfArch
:
:
Bind
(
sym
)
!
=
STB_LOCAL
;
case
EM_X86_64
:
return
name
[
0
]
!
=
'
.
'
|
|
ElfArch
:
:
Bind
(
sym
)
!
=
STB_LOCAL
;
default
:
return
true
;
}
}
void
VisitSymbols
(
typename
ElfArch
:
:
Word
section_type
ElfReader
:
:
SymbolSink
*
sink
)
{
VisitSymbols
(
section_type
sink
-
1
-
1
false
)
;
}
void
VisitSymbols
(
typename
ElfArch
:
:
Word
section_type
ElfReader
:
:
SymbolSink
*
sink
int
symbol_binding
int
symbol_type
bool
get_raw_symbol_values
)
{
for
(
SymbolIterator
<
ElfArch
>
it
(
this
section_type
)
;
!
it
.
done
(
)
;
it
.
Next
(
)
)
{
const
char
*
name
=
it
.
GetSymbolName
(
)
;
if
(
!
name
)
continue
;
const
typename
ElfArch
:
:
Sym
*
sym
=
it
.
GetSymbol
(
)
;
if
(
(
symbol_binding
<
0
|
|
ElfArch
:
:
Bind
(
sym
)
=
=
symbol_binding
)
&
&
(
symbol_type
<
0
|
|
ElfArch
:
:
Type
(
sym
)
=
=
symbol_type
)
)
{
typename
ElfArch
:
:
Sym
symbol
=
*
sym
;
int
symbol_index
=
it
.
GetCurrentSymbolIndex
(
)
;
if
(
section_type
=
=
SHT_DYNSYM
&
&
static_cast
<
unsigned
int
>
(
symbol_index
)
<
symbols_plt_offsets_
.
size
(
)
&
&
symbols_plt_offsets_
[
symbol_index
]
!
=
0
)
{
string
plt_name
=
string
(
name
)
+
kPLTFunctionSuffix
;
if
(
plt_function_names_
[
symbol_index
]
.
empty
(
)
)
{
plt_function_names_
[
symbol_index
]
=
plt_name
;
}
else
if
(
plt_function_names_
[
symbol_index
]
!
=
plt_name
)
{
;
}
sink
-
>
AddSymbol
(
plt_function_names_
[
symbol_index
]
.
c_str
(
)
symbols_plt_offsets_
[
it
.
GetCurrentSymbolIndex
(
)
]
plt_code_size_
)
;
}
if
(
!
get_raw_symbol_values
)
AdjustSymbolValue
(
&
symbol
)
;
sink
-
>
AddSymbol
(
name
symbol
.
st_value
symbol
.
st_size
)
;
}
}
}
void
VisitRelocationEntries
(
)
{
if
(
visited_relocation_entries_
)
{
return
;
}
visited_relocation_entries_
=
true
;
if
(
!
plts_supported_
)
{
return
;
}
ElfReader
:
:
SectionInfo
plt_section_info
;
const
char
*
plt_section
=
GetSectionInfoByName
(
kElfPLTSectionName
&
plt_section_info
)
;
if
(
!
plt_section
)
{
return
;
}
if
(
plt_section_info
.
size
=
=
0
)
{
return
;
}
ElfReader
:
:
SectionInfo
rel_section_info
;
ElfReader
:
:
SectionInfo
rela_section_info
;
const
char
*
rel_section
=
GetSectionInfoByName
(
kElfPLTRelSectionName
&
rel_section_info
)
;
const
char
*
rela_section
=
GetSectionInfoByName
(
kElfPLTRelaSectionName
&
rela_section_info
)
;
const
typename
ElfArch
:
:
Rel
*
rel
=
reinterpret_cast
<
const
typename
ElfArch
:
:
Rel
*
>
(
rel_section
)
;
const
typename
ElfArch
:
:
Rela
*
rela
=
reinterpret_cast
<
const
typename
ElfArch
:
:
Rela
*
>
(
rela_section
)
;
if
(
!
rel_section
&
&
!
rela_section
)
{
return
;
}
size_t
section_size
=
rel_section
?
rel_section_info
.
size
:
rela_section_info
.
size
;
size_t
entry_size
=
rel_section
?
sizeof
(
typename
ElfArch
:
:
Rel
)
:
sizeof
(
typename
ElfArch
:
:
Rela
)
;
ElfReader
:
:
SectionInfo
dynsym_section_info
;
const
char
*
dynsym_section
=
GetSectionInfoByName
(
kElfDynSymSectionName
&
dynsym_section_info
)
;
if
(
!
dynsym_section
|
|
dynsym_section_info
.
size
=
=
0
)
{
return
;
}
size_t
num_dynamic_symbols
=
dynsym_section_info
.
size
/
dynsym_section_info
.
entsize
;
symbols_plt_offsets_
.
resize
(
num_dynamic_symbols
0
)
;
plt_function_names_
.
resize
(
num_dynamic_symbols
)
;
for
(
size_t
i
=
0
;
i
<
section_size
/
entry_size
;
+
+
i
)
{
int
sym_index
=
ElfArch
:
:
r_sym
(
rel_section
?
rel
[
i
]
.
r_info
:
rela
[
i
]
.
r_info
)
;
if
(
static_cast
<
unsigned
int
>
(
sym_index
)
>
=
symbols_plt_offsets_
.
size
(
)
)
{
continue
;
}
symbols_plt_offsets_
[
sym_index
]
=
plt_section_info
.
addr
+
plt0_size_
+
i
*
plt_code_size_
;
}
}
const
ElfSectionReader
<
ElfArch
>
*
GetSectionByType
(
typename
ElfArch
:
:
Word
section_type
)
{
for
(
unsigned
int
k
=
0u
;
k
<
GetNumSections
(
)
;
+
+
k
)
{
if
(
section_headers_
[
k
]
.
sh_type
=
=
section_type
)
{
return
GetSection
(
k
)
;
}
}
return
NULL
;
}
const
char
*
GetSectionNameByIndex
(
int
shndx
)
{
return
GetSectionName
(
section_headers_
[
shndx
]
.
sh_name
)
;
}
const
char
*
GetSectionContentsByIndex
(
int
shndx
size_t
*
size
)
{
const
ElfSectionReader
<
ElfArch
>
*
section
=
GetSection
(
shndx
)
;
if
(
section
!
=
NULL
)
{
*
size
=
section
-
>
section_size
(
)
;
return
section
-
>
contents
(
)
;
}
return
NULL
;
}
const
char
*
GetSectionContentsByName
(
const
string
&
section_name
size_t
*
size
)
{
for
(
unsigned
int
k
=
0u
;
k
<
GetNumSections
(
)
;
+
+
k
)
{
int
shndx
=
is_dwp_
?
GetNumSections
(
)
-
k
-
1
:
k
;
const
char
*
name
=
GetSectionName
(
section_headers_
[
shndx
]
.
sh_name
)
;
if
(
name
!
=
NULL
&
&
ElfReader
:
:
SectionNamesMatch
(
section_name
name
)
)
{
const
ElfSectionReader
<
ElfArch
>
*
section
=
GetSection
(
shndx
)
;
if
(
section
=
=
NULL
)
{
return
NULL
;
}
else
{
*
size
=
section
-
>
section_size
(
)
;
return
section
-
>
contents
(
)
;
}
}
}
return
NULL
;
}
const
char
*
GetSectionInfoByName
(
const
string
&
section_name
ElfReader
:
:
SectionInfo
*
info
)
{
for
(
unsigned
int
k
=
0u
;
k
<
GetNumSections
(
)
;
+
+
k
)
{
int
shndx
=
is_dwp_
?
GetNumSections
(
)
-
k
-
1
:
k
;
const
char
*
name
=
GetSectionName
(
section_headers_
[
shndx
]
.
sh_name
)
;
if
(
name
!
=
NULL
&
&
ElfReader
:
:
SectionNamesMatch
(
section_name
name
)
)
{
const
ElfSectionReader
<
ElfArch
>
*
section
=
GetSection
(
shndx
)
;
if
(
section
=
=
NULL
)
{
return
NULL
;
}
else
{
info
-
>
type
=
section
-
>
header
(
)
.
sh_type
;
info
-
>
flags
=
section
-
>
header
(
)
.
sh_flags
;
info
-
>
addr
=
section
-
>
header
(
)
.
sh_addr
;
info
-
>
offset
=
section
-
>
header
(
)
.
sh_offset
;
info
-
>
size
=
section
-
>
header
(
)
.
sh_size
;
info
-
>
link
=
section
-
>
header
(
)
.
sh_link
;
info
-
>
info
=
section
-
>
header
(
)
.
sh_info
;
info
-
>
addralign
=
section
-
>
header
(
)
.
sh_addralign
;
info
-
>
entsize
=
section
-
>
header
(
)
.
sh_entsize
;
return
section
-
>
contents
(
)
;
}
}
}
return
NULL
;
}
uint64
VaddrOfFirstLoadSegment
(
)
const
{
if
(
header_
.
e_type
=
=
ET_REL
)
{
return
0
;
}
for
(
int
i
=
0
;
i
<
GetNumProgramHeaders
(
)
;
+
+
i
)
{
if
(
program_headers_
[
i
]
.
p_type
=
=
PT_LOAD
)
{
return
program_headers_
[
i
]
.
p_vaddr
;
}
}
return
0
;
}
bool
HasDebugSections
(
)
{
for
(
int
k
=
GetNumSections
(
)
-
1
;
k
>
=
0
;
-
-
k
)
{
const
char
*
name
=
GetSectionName
(
section_headers_
[
k
]
.
sh_name
)
;
if
(
strncmp
(
name
"
.
debug
"
strlen
(
"
.
debug
"
)
)
=
=
0
)
return
true
;
if
(
strncmp
(
name
"
.
zdebug
"
strlen
(
"
.
zdebug
"
)
)
=
=
0
)
return
true
;
}
return
false
;
}
bool
IsDynamicSharedObject
(
)
const
{
return
header_
.
e_type
=
=
ET_DYN
;
}
uint64_t
GetNumSections
(
)
const
{
if
(
HasManySections
(
)
)
return
first_section_header_
.
sh_size
;
return
header_
.
e_shnum
;
}
private
:
typedef
vector
<
pair
<
uint64
const
typename
ElfArch
:
:
Sym
*
>
>
AddrToSymMap
;
static
bool
AddrToSymSorter
(
const
typename
AddrToSymMap
:
:
value_type
&
lhs
const
typename
AddrToSymMap
:
:
value_type
&
rhs
)
{
return
lhs
.
first
<
rhs
.
first
;
}
static
bool
AddrToSymEquals
(
const
typename
AddrToSymMap
:
:
value_type
&
lhs
const
typename
AddrToSymMap
:
:
value_type
&
rhs
)
{
return
lhs
.
first
=
=
rhs
.
first
;
}
bool
HasManySections
(
)
const
{
return
header_
.
e_shnum
=
=
SHN_UNDEF
;
}
int
GetNumProgramHeaders
(
)
const
{
if
(
HasManySections
(
)
&
&
header_
.
e_phnum
=
=
0xffff
&
&
first_section_header_
.
sh_info
!
=
0
)
return
first_section_header_
.
sh_info
;
return
header_
.
e_phnum
;
}
int
GetStringTableIndex
(
)
const
{
if
(
HasManySections
(
)
)
{
if
(
header_
.
e_shstrndx
=
=
0xffff
)
return
first_section_header_
.
sh_link
;
else
if
(
header_
.
e_shstrndx
>
=
GetNumSections
(
)
)
return
0
;
}
return
header_
.
e_shstrndx
;
}
const
char
*
GetSectionName
(
typename
ElfArch
:
:
Word
sh_name
)
{
const
ElfSectionReader
<
ElfArch
>
*
shstrtab
=
GetSection
(
GetStringTableIndex
(
)
)
;
if
(
shstrtab
!
=
NULL
)
{
return
shstrtab
-
>
GetOffset
(
sh_name
)
;
}
return
NULL
;
}
const
ElfSectionReader
<
ElfArch
>
*
GetSection
(
int
num
)
{
const
char
*
name
;
if
(
num
=
=
GetStringTableIndex
(
)
)
name
=
"
.
shstrtab
"
;
else
name
=
GetSectionNameByIndex
(
num
)
;
ElfSectionReader
<
ElfArch
>
*
&
reader
=
sections_
[
num
]
;
if
(
reader
=
=
NULL
)
reader
=
new
ElfSectionReader
<
ElfArch
>
(
name
path_
fd_
section_headers_
[
num
]
)
;
return
reader
;
}
bool
ParseHeaders
(
int
fd
const
string
&
path
)
{
if
(
pread
(
fd
&
header_
sizeof
(
header_
)
0
)
!
=
sizeof
(
header_
)
)
{
return
false
;
}
if
(
header_
.
e_type
!
=
ET_EXEC
&
&
header_
.
e_type
!
=
ET_DYN
&
&
header_
.
e_type
!
=
ET_REL
)
{
return
false
;
}
if
(
header_
.
e_shoff
=
=
0
)
{
return
false
;
}
if
(
header_
.
e_shnum
=
=
SHN_UNDEF
)
{
if
(
pread
(
fd
&
first_section_header_
sizeof
(
first_section_header_
)
header_
.
e_shoff
)
!
=
sizeof
(
first_section_header_
)
)
{
return
false
;
}
}
const
int
section_headers_size
=
GetNumSections
(
)
*
sizeof
(
*
section_headers_
)
;
section_headers_
=
new
typename
ElfArch
:
:
Shdr
[
section_headers_size
]
;
if
(
pread
(
fd
section_headers_
section_headers_size
header_
.
e_shoff
)
!
=
section_headers_size
)
{
return
false
;
}
program_headers_
=
new
typename
ElfArch
:
:
Phdr
[
GetNumProgramHeaders
(
)
]
;
sections_
.
resize
(
GetNumSections
(
)
NULL
)
;
return
true
;
}
uint64
AdjustPPC64FunctionDescriptorSymbolValue
(
uint64
value
)
{
if
(
opd_section_
!
=
NULL
&
&
opd_info_
.
addr
<
=
value
&
&
value
<
opd_info_
.
addr
+
opd_info_
.
size
)
{
uint64
offset
=
value
-
opd_info_
.
addr
;
return
(
*
reinterpret_cast
<
const
uint64
*
>
(
opd_section_
+
offset
)
)
;
}
return
value
;
}
void
AdjustSymbolValue
(
typename
ElfArch
:
:
Sym
*
sym
)
{
switch
(
header_
.
e_machine
)
{
case
EM_ARM
:
if
(
ElfArch
:
:
Type
(
sym
)
=
=
STT_FUNC
)
sym
-
>
st_value
=
AdjustARMThumbSymbolValue
(
sym
-
>
st_value
)
;
break
;
case
EM_386
:
break
;
case
EM_PPC64
:
if
(
ElfArch
:
:
Type
(
sym
)
=
=
STT_FUNC
)
sym
-
>
st_value
=
AdjustPPC64FunctionDescriptorSymbolValue
(
sym
-
>
st_value
)
;
break
;
default
:
break
;
}
}
friend
class
SymbolIterator
<
ElfArch
>
;
const
string
path_
;
const
int
fd_
;
typename
ElfArch
:
:
Ehdr
header_
;
typename
ElfArch
:
:
Shdr
first_section_header_
;
typename
ElfArch
:
:
Shdr
*
section_headers_
;
typename
ElfArch
:
:
Phdr
*
program_headers_
;
vector
<
ElfSectionReader
<
ElfArch
>
*
>
sections_
;
ElfReader
:
:
SectionInfo
opd_info_
;
const
char
*
opd_section_
;
int64
base_for_text_
;
bool
plts_supported_
;
size_t
plt_code_size_
;
size_t
plt0_size_
;
std
:
:
vector
<
uint64
>
symbols_plt_offsets_
;
std
:
:
vector
<
string
>
plt_function_names_
;
bool
visited_relocation_entries_
;
bool
is_dwp_
;
}
;
ElfReader
:
:
ElfReader
(
const
string
&
path
)
:
path_
(
path
)
fd_
(
-
1
)
impl32_
(
NULL
)
impl64_
(
NULL
)
{
if
(
MyHasSuffixString
(
path
"
(
deleted
)
"
)
)
return
;
if
(
path
=
=
"
[
vdso
]
"
)
return
;
if
(
path
=
=
"
[
vsyscall
]
"
)
return
;
fd_
=
open
(
path
.
c_str
(
)
O_RDONLY
)
;
}
ElfReader
:
:
~
ElfReader
(
)
{
if
(
fd_
!
=
-
1
)
close
(
fd_
)
;
if
(
impl32_
!
=
NULL
)
delete
impl32_
;
if
(
impl64_
!
=
NULL
)
delete
impl64_
;
}
#
if
__WORDSIZE
=
=
32
#
define
NATIVE_ELF_ARCH
Elf32
#
elif
__WORDSIZE
=
=
64
#
define
NATIVE_ELF_ARCH
Elf64
#
else
#
error
"
Invalid
word
size
"
#
endif
template
<
typename
ElfArch
>
static
bool
IsElfFile
(
const
int
fd
const
string
&
path
)
{
if
(
fd
<
0
)
return
false
;
if
(
!
ElfReaderImpl
<
ElfArch
>
:
:
IsArchElfFile
(
fd
NULL
)
)
{
return
false
;
}
return
true
;
}
bool
ElfReader
:
:
IsNativeElfFile
(
)
const
{
return
IsElfFile
<
NATIVE_ELF_ARCH
>
(
fd_
path_
)
;
}
bool
ElfReader
:
:
IsElf32File
(
)
const
{
return
IsElfFile
<
Elf32
>
(
fd_
path_
)
;
}
bool
ElfReader
:
:
IsElf64File
(
)
const
{
return
IsElfFile
<
Elf64
>
(
fd_
path_
)
;
}
void
ElfReader
:
:
VisitSymbols
(
ElfReader
:
:
SymbolSink
*
sink
)
{
VisitSymbols
(
sink
-
1
-
1
)
;
}
void
ElfReader
:
:
VisitSymbols
(
ElfReader
:
:
SymbolSink
*
sink
int
symbol_binding
int
symbol_type
)
{
VisitSymbols
(
sink
symbol_binding
symbol_type
false
)
;
}
void
ElfReader
:
:
VisitSymbols
(
ElfReader
:
:
SymbolSink
*
sink
int
symbol_binding
int
symbol_type
bool
get_raw_symbol_values
)
{
if
(
IsElf32File
(
)
)
{
GetImpl32
(
)
-
>
VisitRelocationEntries
(
)
;
GetImpl32
(
)
-
>
VisitSymbols
(
SHT_SYMTAB
sink
symbol_binding
symbol_type
get_raw_symbol_values
)
;
GetImpl32
(
)
-
>
VisitSymbols
(
SHT_DYNSYM
sink
symbol_binding
symbol_type
get_raw_symbol_values
)
;
}
else
if
(
IsElf64File
(
)
)
{
GetImpl64
(
)
-
>
VisitRelocationEntries
(
)
;
GetImpl64
(
)
-
>
VisitSymbols
(
SHT_SYMTAB
sink
symbol_binding
symbol_type
get_raw_symbol_values
)
;
GetImpl64
(
)
-
>
VisitSymbols
(
SHT_DYNSYM
sink
symbol_binding
symbol_type
get_raw_symbol_values
)
;
}
}
uint64
ElfReader
:
:
VaddrOfFirstLoadSegment
(
)
{
if
(
IsElf32File
(
)
)
{
return
GetImpl32
(
)
-
>
VaddrOfFirstLoadSegment
(
)
;
}
else
if
(
IsElf64File
(
)
)
{
return
GetImpl64
(
)
-
>
VaddrOfFirstLoadSegment
(
)
;
}
else
{
return
0
;
}
}
const
char
*
ElfReader
:
:
GetSectionName
(
int
shndx
)
{
if
(
shndx
<
0
|
|
static_cast
<
unsigned
int
>
(
shndx
)
>
=
GetNumSections
(
)
)
return
NULL
;
if
(
IsElf32File
(
)
)
{
return
GetImpl32
(
)
-
>
GetSectionNameByIndex
(
shndx
)
;
}
else
if
(
IsElf64File
(
)
)
{
return
GetImpl64
(
)
-
>
GetSectionNameByIndex
(
shndx
)
;
}
else
{
return
NULL
;
}
}
uint64
ElfReader
:
:
GetNumSections
(
)
{
if
(
IsElf32File
(
)
)
{
return
GetImpl32
(
)
-
>
GetNumSections
(
)
;
}
else
if
(
IsElf64File
(
)
)
{
return
GetImpl64
(
)
-
>
GetNumSections
(
)
;
}
else
{
return
0
;
}
}
const
char
*
ElfReader
:
:
GetSectionByIndex
(
int
shndx
size_t
*
size
)
{
if
(
IsElf32File
(
)
)
{
return
GetImpl32
(
)
-
>
GetSectionContentsByIndex
(
shndx
size
)
;
}
else
if
(
IsElf64File
(
)
)
{
return
GetImpl64
(
)
-
>
GetSectionContentsByIndex
(
shndx
size
)
;
}
else
{
return
NULL
;
}
}
const
char
*
ElfReader
:
:
GetSectionByName
(
const
string
&
section_name
size_t
*
size
)
{
if
(
IsElf32File
(
)
)
{
return
GetImpl32
(
)
-
>
GetSectionContentsByName
(
section_name
size
)
;
}
else
if
(
IsElf64File
(
)
)
{
return
GetImpl64
(
)
-
>
GetSectionContentsByName
(
section_name
size
)
;
}
else
{
return
NULL
;
}
}
const
char
*
ElfReader
:
:
GetSectionInfoByName
(
const
string
&
section_name
SectionInfo
*
info
)
{
if
(
IsElf32File
(
)
)
{
return
GetImpl32
(
)
-
>
GetSectionInfoByName
(
section_name
info
)
;
}
else
if
(
IsElf64File
(
)
)
{
return
GetImpl64
(
)
-
>
GetSectionInfoByName
(
section_name
info
)
;
}
else
{
return
NULL
;
}
}
bool
ElfReader
:
:
SectionNamesMatch
(
const
string
&
name
const
string
&
sh_name
)
{
if
(
(
name
.
find
(
"
.
debug_
"
0
)
=
=
0
)
&
&
(
sh_name
.
find
(
"
.
zdebug_
"
0
)
=
=
0
)
)
{
const
string
name_suffix
(
name
strlen
(
"
.
debug_
"
)
)
;
const
string
sh_name_suffix
(
sh_name
strlen
(
"
.
zdebug_
"
)
)
;
return
name_suffix
=
=
sh_name_suffix
;
}
return
name
=
=
sh_name
;
}
bool
ElfReader
:
:
IsDynamicSharedObject
(
)
{
if
(
IsElf32File
(
)
)
{
return
GetImpl32
(
)
-
>
IsDynamicSharedObject
(
)
;
}
else
if
(
IsElf64File
(
)
)
{
return
GetImpl64
(
)
-
>
IsDynamicSharedObject
(
)
;
}
else
{
return
false
;
}
}
ElfReaderImpl
<
Elf32
>
*
ElfReader
:
:
GetImpl32
(
)
{
if
(
impl32_
=
=
NULL
)
{
impl32_
=
new
ElfReaderImpl
<
Elf32
>
(
path_
fd_
)
;
}
return
impl32_
;
}
ElfReaderImpl
<
Elf64
>
*
ElfReader
:
:
GetImpl64
(
)
{
if
(
impl64_
=
=
NULL
)
{
impl64_
=
new
ElfReaderImpl
<
Elf64
>
(
path_
fd_
)
;
}
return
impl64_
;
}
template
<
typename
ElfArch
>
static
bool
IsNonStrippedELFBinaryImpl
(
const
string
&
path
const
int
fd
bool
debug_only
)
{
if
(
!
ElfReaderImpl
<
ElfArch
>
:
:
IsArchElfFile
(
fd
NULL
)
)
return
false
;
ElfReaderImpl
<
ElfArch
>
elf_reader
(
path
fd
)
;
return
debug_only
?
elf_reader
.
HasDebugSections
(
)
:
(
elf_reader
.
GetSectionByType
(
SHT_SYMTAB
)
!
=
NULL
)
;
}
static
bool
IsNonStrippedELFBinaryHelper
(
const
string
&
path
bool
debug_only
)
{
const
int
fd
=
open
(
path
.
c_str
(
)
O_RDONLY
)
;
if
(
fd
=
=
-
1
)
{
return
false
;
}
if
(
IsNonStrippedELFBinaryImpl
<
Elf32
>
(
path
fd
debug_only
)
|
|
IsNonStrippedELFBinaryImpl
<
Elf64
>
(
path
fd
debug_only
)
)
{
close
(
fd
)
;
return
true
;
}
close
(
fd
)
;
return
false
;
}
bool
ElfReader
:
:
IsNonStrippedELFBinary
(
const
string
&
path
)
{
return
IsNonStrippedELFBinaryHelper
(
path
false
)
;
}
bool
ElfReader
:
:
IsNonDebugStrippedELFBinary
(
const
string
&
path
)
{
return
IsNonStrippedELFBinaryHelper
(
path
true
)
;
}
}
