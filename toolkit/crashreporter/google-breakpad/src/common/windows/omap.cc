#
include
"
common
/
windows
/
omap
.
h
"
#
include
<
atlbase
.
h
>
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
set
>
#
include
"
common
/
windows
/
dia_util
.
h
"
namespace
google_breakpad
{
namespace
{
static
const
wchar_t
kOmapToDebugStreamName
[
]
=
L
"
OMAPTO
"
;
static
const
wchar_t
kOmapFromDebugStreamName
[
]
=
L
"
OMAPFROM
"
;
template
<
typename
T
>
const
T
&
Min
(
const
T
&
t1
const
T
&
t2
)
{
return
t1
<
t2
?
t1
:
t2
;
}
template
<
typename
T
>
const
T
&
Max
(
const
T
&
t1
const
T
&
t2
)
{
return
t1
>
t2
?
t1
:
t2
;
}
struct
OmapOrigToTran
{
DWORD
rva_original
;
DWORD
rva_transformed
;
}
;
struct
OmapTranToOrig
{
DWORD
rva_transformed
;
DWORD
rva_original
;
}
;
static_assert
(
sizeof
(
OmapOrigToTran
)
=
=
sizeof
(
OMAP
)
"
OmapOrigToTran
must
have
same
size
as
OMAP
.
"
)
;
static_assert
(
sizeof
(
OmapTranToOrig
)
=
=
sizeof
(
OMAP
)
"
OmapTranToOrig
must
have
same
size
as
OMAP
.
"
)
;
typedef
std
:
:
vector
<
OmapOrigToTran
>
OmapFromTable
;
typedef
std
:
:
vector
<
OmapTranToOrig
>
OmapToTable
;
bool
MappedRangeOriginalLess
(
const
MappedRange
&
lhs
const
MappedRange
&
rhs
)
{
if
(
lhs
.
rva_original
<
rhs
.
rva_original
)
return
true
;
if
(
lhs
.
rva_original
>
rhs
.
rva_original
)
return
false
;
return
lhs
.
length
<
rhs
.
length
;
}
bool
MappedRangeMappedLess
(
const
MappedRange
&
lhs
const
MappedRange
&
rhs
)
{
if
(
lhs
.
rva_transformed
<
rhs
.
rva_transformed
)
return
true
;
if
(
lhs
.
rva_transformed
>
rhs
.
rva_transformed
)
return
false
;
return
lhs
.
length
<
rhs
.
length
;
}
bool
EndpointIndexLess
(
const
EndpointIndex
&
ei1
const
EndpointIndex
&
ei2
)
{
return
ei1
.
endpoint
<
ei2
.
endpoint
;
}
bool
FindAndLoadOmapTable
(
const
wchar_t
*
name
IDiaSession
*
session
OmapTable
*
table
)
{
assert
(
name
!
=
NULL
)
;
assert
(
session
!
=
NULL
)
;
assert
(
table
!
=
NULL
)
;
CComPtr
<
IDiaEnumDebugStreamData
>
stream
;
if
(
!
FindDebugStream
(
name
session
&
stream
)
)
return
false
;
assert
(
stream
.
p
!
=
NULL
)
;
LONG
count
=
0
;
if
(
FAILED
(
stream
-
>
get_Count
(
&
count
)
)
)
{
fprintf
(
stderr
"
IDiaEnumDebugStreamData
:
:
get_Count
failed
for
stream
"
"
\
"
%
ws
\
"
\
n
"
name
)
;
return
false
;
}
DWORD
bytes_read
=
0
;
ULONG
count_read
=
0
;
if
(
FAILED
(
stream
-
>
Next
(
count
0
&
bytes_read
NULL
&
count_read
)
)
)
{
fprintf
(
stderr
"
IDiaEnumDebugStreamData
:
:
Next
failed
while
reading
"
"
length
of
stream
\
"
%
ws
\
"
\
n
"
name
)
;
return
false
;
}
DWORD
bytes_expected
=
count
*
sizeof
(
OmapTable
:
:
value_type
)
;
if
(
count
*
sizeof
(
OmapTable
:
:
value_type
)
!
=
bytes_read
)
{
fprintf
(
stderr
"
DIA
debug
stream
\
"
%
ws
\
"
has
an
unexpected
length
"
name
)
;
return
false
;
}
table
-
>
resize
(
count
)
;
bytes_read
=
0
;
count_read
=
0
;
if
(
FAILED
(
stream
-
>
Next
(
count
bytes_expected
&
bytes_read
reinterpret_cast
<
BYTE
*
>
(
&
table
-
>
at
(
0
)
)
&
count_read
)
)
)
{
fprintf
(
stderr
"
IDiaEnumDebugStreamData
:
:
Next
failed
while
reading
"
"
data
from
stream
\
"
%
ws
\
"
\
n
"
)
;
return
false
;
}
return
true
;
}
bool
GetOriginalImageLength
(
IDiaSession
*
session
DWORD
*
image_length
)
{
assert
(
session
!
=
NULL
)
;
assert
(
image_length
!
=
NULL
)
;
CComPtr
<
IDiaEnumSegments
>
enum_segments
;
if
(
!
FindTable
(
session
&
enum_segments
)
)
return
false
;
assert
(
enum_segments
.
p
!
=
NULL
)
;
DWORD
temp_image_length
=
0
;
CComPtr
<
IDiaSegment
>
segment
;
ULONG
fetched
=
0
;
while
(
SUCCEEDED
(
enum_segments
-
>
Next
(
1
&
segment
&
fetched
)
)
&
&
fetched
=
=
1
)
{
assert
(
segment
.
p
!
=
NULL
)
;
DWORD
rva
=
0
;
DWORD
length
=
0
;
DWORD
frame
=
0
;
if
(
FAILED
(
segment
-
>
get_relativeVirtualAddress
(
&
rva
)
)
|
|
FAILED
(
segment
-
>
get_length
(
&
length
)
)
|
|
FAILED
(
segment
-
>
get_frame
(
&
frame
)
)
)
{
fprintf
(
stderr
"
Failed
to
get
basic
properties
for
IDiaSegment
\
n
"
)
;
return
false
;
}
if
(
frame
>
0
)
{
DWORD
segment_end
=
rva
+
length
;
if
(
segment_end
>
temp_image_length
)
temp_image_length
=
segment_end
;
}
segment
.
Release
(
)
;
}
*
image_length
=
temp_image_length
;
return
true
;
}
void
FillInRemovedLengths
(
Mapping
*
mapping
)
{
assert
(
mapping
!
=
NULL
)
;
size_t
fill
=
0
;
DWORD
rva_front
=
0
;
for
(
size_t
find
=
0
;
find
<
mapping
-
>
size
(
)
;
+
+
find
)
{
#
ifndef
NDEBUG
if
(
find
>
0
)
{
assert
(
mapping
-
>
at
(
find
-
1
)
.
rva_original
<
=
mapping
-
>
at
(
find
)
.
rva_original
)
;
}
#
endif
if
(
rva_front
<
mapping
-
>
at
(
find
)
.
rva_original
)
{
DWORD
removed
=
mapping
-
>
at
(
find
)
.
rva_original
-
rva_front
;
for
(
;
fill
<
find
;
+
+
fill
)
{
if
(
mapping
-
>
at
(
fill
)
.
rva_original
+
mapping
-
>
at
(
fill
)
.
length
!
=
rva_front
)
{
continue
;
}
mapping
-
>
at
(
fill
)
.
removed
=
removed
;
}
}
rva_front
=
mapping
-
>
at
(
find
)
.
rva_original
+
mapping
-
>
at
(
find
)
.
length
;
}
}
void
BuildMapping
(
const
OmapData
&
omap_data
Mapping
*
mapping
)
{
assert
(
mapping
!
=
NULL
)
;
mapping
-
>
clear
(
)
;
if
(
omap_data
.
omap_from
.
empty
(
)
|
|
omap_data
.
omap_to
.
empty
(
)
)
return
;
const
OmapToTable
&
tran2orig
=
reinterpret_cast
<
const
OmapToTable
&
>
(
omap_data
.
omap_to
)
;
const
OmapFromTable
&
orig2tran
=
reinterpret_cast
<
const
OmapFromTable
&
>
(
omap_data
.
omap_from
)
;
if
(
tran2orig
[
0
]
.
rva_transformed
>
0
&
&
orig2tran
[
0
]
.
rva_original
>
0
)
{
DWORD
header_transformed
=
tran2orig
[
0
]
.
rva_transformed
;
DWORD
header_original
=
orig2tran
[
0
]
.
rva_original
;
DWORD
header
=
Min
(
header_transformed
header_original
)
;
MappedRange
mr
=
{
}
;
mr
.
length
=
header
;
mr
.
injected
=
header_transformed
-
header
;
mr
.
removed
=
header_original
-
header
;
mapping
-
>
push_back
(
mr
)
;
}
for
(
size_t
i
=
0
;
i
<
tran2orig
.
size
(
)
;
+
+
i
)
{
const
OmapTranToOrig
&
o1
=
tran2orig
[
i
]
;
if
(
o1
.
rva_original
>
=
omap_data
.
length_original
)
continue
;
DWORD
length
=
0
;
if
(
i
+
1
<
tran2orig
.
size
(
)
)
{
const
OmapTranToOrig
&
o2
=
tran2orig
[
i
+
1
]
;
assert
(
o1
.
rva_transformed
<
=
o2
.
rva_transformed
)
;
length
=
o2
.
rva_transformed
-
o1
.
rva_transformed
;
if
(
o1
.
rva_original
+
length
>
omap_data
.
length_original
)
{
length
=
omap_data
.
length_original
-
o1
.
rva_original
;
}
}
else
{
length
=
omap_data
.
length_original
-
o1
.
rva_original
;
}
if
(
length
=
=
0
)
continue
;
if
(
!
mapping
-
>
empty
(
)
)
{
MappedRange
&
prev_mr
=
mapping
-
>
back
(
)
;
prev_mr
.
injected
+
=
o1
.
rva_transformed
-
(
prev_mr
.
rva_transformed
+
prev_mr
.
length
)
;
}
MappedRange
mr
=
{
}
;
mr
.
rva_original
=
o1
.
rva_original
;
mr
.
rva_transformed
=
o1
.
rva_transformed
;
mr
.
length
=
length
;
mapping
-
>
push_back
(
mr
)
;
}
std
:
:
sort
(
mapping
-
>
begin
(
)
mapping
-
>
end
(
)
MappedRangeOriginalLess
)
;
FillInRemovedLengths
(
mapping
)
;
return
;
}
void
BuildEndpointIndexMap
(
ImageMap
*
image_map
)
{
assert
(
image_map
!
=
NULL
)
;
if
(
image_map
-
>
mapping
.
size
(
)
=
=
0
)
return
;
const
Mapping
&
mapping
=
image_map
-
>
mapping
;
EndpointIndexMap
&
eim
=
image_map
-
>
endpoint_index_map
;
std
:
:
set
<
DWORD
>
endpoints
;
for
(
size_t
i
=
0
;
i
<
mapping
.
size
(
)
;
+
+
i
)
{
endpoints
.
insert
(
mapping
[
i
]
.
rva_original
)
;
endpoints
.
insert
(
mapping
[
i
]
.
rva_original
+
mapping
[
i
]
.
length
+
mapping
[
i
]
.
removed
)
;
}
eim
.
resize
(
endpoints
.
size
(
)
)
;
std
:
:
set
<
DWORD
>
:
:
const_iterator
it
=
endpoints
.
begin
(
)
;
for
(
size_t
i
=
0
;
it
!
=
endpoints
.
end
(
)
;
+
+
it
+
+
i
)
{
eim
[
i
]
.
endpoint
=
*
it
;
eim
[
i
]
.
index
=
mapping
.
size
(
)
;
}
for
(
size_t
i
=
0
;
i
<
mapping
.
size
(
)
;
+
+
i
)
{
EndpointIndex
ei1
=
{
mapping
[
i
]
.
rva_original
0
}
;
EndpointIndexMap
:
:
iterator
it1
=
std
:
:
lower_bound
(
eim
.
begin
(
)
eim
.
end
(
)
ei1
EndpointIndexLess
)
;
EndpointIndex
ei2
=
{
mapping
[
i
]
.
rva_original
+
mapping
[
i
]
.
length
+
mapping
[
i
]
.
removed
0
}
;
EndpointIndexMap
:
:
iterator
it2
=
std
:
:
lower_bound
(
eim
.
begin
(
)
eim
.
end
(
)
ei2
EndpointIndexLess
)
;
for
(
;
it1
!
=
it2
;
+
+
it1
)
it1
-
>
index
=
Min
(
i
it1
-
>
index
)
;
}
}
void
ClipMappedRangeOriginal
(
const
AddressRange
&
clip_range
MappedRange
*
mapped_range
)
{
assert
(
mapped_range
!
=
NULL
)
;
if
(
clip_range
.
end
(
)
<
=
mapped_range
-
>
rva_original
|
|
mapped_range
-
>
rva_original
+
mapped_range
-
>
length
+
mapped_range
-
>
removed
<
=
clip_range
.
rva
)
{
mapped_range
-
>
length
=
0
;
mapped_range
-
>
injected
=
0
;
mapped_range
-
>
removed
=
0
;
return
;
}
if
(
mapped_range
-
>
rva_original
<
clip_range
.
rva
)
{
DWORD
clip_left
=
clip_range
.
rva
-
mapped_range
-
>
rva_original
;
mapped_range
-
>
rva_original
+
=
clip_left
;
mapped_range
-
>
rva_transformed
+
=
clip_left
;
if
(
clip_left
>
mapped_range
-
>
length
)
{
DWORD
trim
=
clip_left
-
mapped_range
-
>
length
;
mapped_range
-
>
length
=
0
;
mapped_range
-
>
injected
-
=
Min
(
trim
mapped_range
-
>
injected
)
;
mapped_range
-
>
removed
-
=
trim
;
}
else
{
mapped_range
-
>
length
-
=
clip_left
;
}
}
DWORD
end_original
=
mapped_range
-
>
rva_original
+
mapped_range
-
>
length
;
if
(
clip_range
.
end
(
)
<
end_original
)
{
DWORD
clip_right
=
end_original
-
clip_range
.
end
(
)
;
mapped_range
-
>
length
-
=
clip_right
;
mapped_range
-
>
injected
=
0
;
mapped_range
-
>
removed
=
0
;
return
;
}
else
{
DWORD
end_removed
=
end_original
+
mapped_range
-
>
removed
;
if
(
clip_range
.
end
(
)
<
end_removed
)
mapped_range
-
>
removed
=
clip_range
.
end
(
)
-
end_original
;
DWORD
end_injected
=
end_original
+
mapped_range
-
>
injected
;
if
(
clip_range
.
end
(
)
<
end_injected
)
mapped_range
-
>
injected
=
clip_range
.
end
(
)
-
end_original
;
}
return
;
}
}
int
AddressRange
:
:
Compare
(
const
AddressRange
&
rhs
)
const
{
if
(
end
(
)
<
=
rhs
.
rva
)
return
-
1
;
if
(
rhs
.
end
(
)
<
=
rva
)
return
1
;
return
0
;
}
bool
GetOmapDataAndDisableTranslation
(
IDiaSession
*
session
OmapData
*
omap_data
)
{
assert
(
session
!
=
NULL
)
;
assert
(
omap_data
!
=
NULL
)
;
CComPtr
<
IDiaAddressMap
>
address_map
;
if
(
FAILED
(
session
-
>
QueryInterface
(
&
address_map
)
)
)
{
fprintf
(
stderr
"
IDiaSession
:
:
QueryInterface
(
IDiaAddressMap
)
failed
\
n
"
)
;
return
false
;
}
assert
(
address_map
.
p
!
=
NULL
)
;
BOOL
omap_enabled
=
FALSE
;
if
(
FAILED
(
address_map
-
>
get_addressMapEnabled
(
&
omap_enabled
)
)
)
{
fprintf
(
stderr
"
IDiaAddressMap
:
:
get_addressMapEnabled
failed
\
n
"
)
;
return
false
;
}
if
(
!
omap_enabled
)
{
omap_data
-
>
omap_from
.
clear
(
)
;
omap_data
-
>
omap_to
.
clear
(
)
;
omap_data
-
>
length_original
=
0
;
return
true
;
}
if
(
FAILED
(
address_map
-
>
put_addressMapEnabled
(
FALSE
)
)
)
{
fprintf
(
stderr
"
IDiaAddressMap
:
:
put_addressMapEnabled
failed
\
n
"
)
;
return
false
;
}
if
(
!
FindAndLoadOmapTable
(
kOmapFromDebugStreamName
session
&
omap_data
-
>
omap_from
)
)
{
return
false
;
}
if
(
!
FindAndLoadOmapTable
(
kOmapToDebugStreamName
session
&
omap_data
-
>
omap_to
)
)
{
return
false
;
}
if
(
!
GetOriginalImageLength
(
session
&
omap_data
-
>
length_original
)
)
return
false
;
return
true
;
}
void
BuildImageMap
(
const
OmapData
&
omap_data
ImageMap
*
image_map
)
{
assert
(
image_map
!
=
NULL
)
;
BuildMapping
(
omap_data
&
image_map
-
>
mapping
)
;
BuildEndpointIndexMap
(
image_map
)
;
}
void
MapAddressRange
(
const
ImageMap
&
image_map
const
AddressRange
&
original_range
AddressRangeVector
*
mapped_ranges
)
{
assert
(
mapped_ranges
!
=
NULL
)
;
const
Mapping
&
map
=
image_map
.
mapping
;
if
(
map
.
empty
(
)
)
{
mapped_ranges
-
>
push_back
(
original_range
)
;
return
;
}
AddressRange
query_range
(
original_range
)
;
if
(
query_range
.
length
=
=
0
)
query_range
.
length
=
1
;
size_t
imin
=
0
;
size_t
imax
=
0
;
{
const
EndpointIndexMap
&
eim
=
image_map
.
endpoint_index_map
;
EndpointIndex
q1
=
{
query_range
.
rva
0
}
;
EndpointIndexMap
:
:
const_iterator
it1
=
std
:
:
lower_bound
(
eim
.
begin
(
)
eim
.
end
(
)
q1
EndpointIndexLess
)
;
if
(
it1
=
=
eim
.
end
(
)
)
{
imin
=
map
.
size
(
)
;
}
else
{
if
(
it1
!
=
eim
.
begin
(
)
&
&
query_range
.
rva
<
it1
-
>
endpoint
)
-
-
it1
;
imin
=
it1
-
>
index
;
}
MappedRange
q2
=
{
query_range
.
end
(
)
0
}
;
Mapping
:
:
const_iterator
it2
=
std
:
:
lower_bound
(
map
.
begin
(
)
map
.
end
(
)
q2
MappedRangeOriginalLess
)
;
imax
=
it2
-
map
.
begin
(
)
;
}
Mapping
temp_map
;
for
(
size_t
i
=
imin
;
i
<
imax
;
+
+
i
)
{
MappedRange
mr
=
map
[
i
]
;
ClipMappedRangeOriginal
(
query_range
&
mr
)
;
if
(
mr
.
length
+
mr
.
injected
>
0
)
temp_map
.
push_back
(
mr
)
;
}
if
(
temp_map
.
empty
(
)
)
return
;
std
:
:
sort
(
temp_map
.
begin
(
)
temp_map
.
end
(
)
MappedRangeMappedLess
)
;
if
(
original_range
.
length
=
=
0
)
{
mapped_ranges
-
>
push_back
(
AddressRange
(
temp_map
[
0
]
.
rva_transformed
0
)
)
;
for
(
size_t
i
=
1
;
i
<
temp_map
.
size
(
)
;
+
+
i
)
{
if
(
temp_map
[
i
]
.
rva_transformed
>
mapped_ranges
-
>
back
(
)
.
rva
)
mapped_ranges
-
>
push_back
(
AddressRange
(
temp_map
[
i
]
.
rva_transformed
0
)
)
;
}
return
;
}
DWORD
rva_begin
=
temp_map
[
0
]
.
rva_transformed
;
DWORD
rva_cur_content
=
rva_begin
+
temp_map
[
0
]
.
length
;
DWORD
rva_cur_injected
=
rva_cur_content
+
temp_map
[
0
]
.
injected
;
for
(
size_t
i
=
1
;
i
<
temp_map
.
size
(
)
;
+
+
i
)
{
if
(
rva_cur_injected
<
temp_map
[
i
]
.
rva_transformed
)
{
if
(
rva_begin
<
rva_cur_content
)
{
mapped_ranges
-
>
push_back
(
AddressRange
(
rva_begin
rva_cur_content
-
rva_begin
)
)
;
}
rva_begin
=
temp_map
[
i
]
.
rva_transformed
;
}
rva_cur_content
=
temp_map
[
i
]
.
rva_transformed
+
temp_map
[
i
]
.
length
;
rva_cur_injected
=
rva_cur_content
+
temp_map
[
i
]
.
injected
;
}
if
(
rva_begin
<
rva_cur_content
)
{
mapped_ranges
-
>
push_back
(
AddressRange
(
rva_begin
rva_cur_content
-
rva_begin
)
)
;
}
return
;
}
}
