#
include
"
common
/
windows
/
pdb_source_line_writer
.
h
"
#
include
<
windows
.
h
>
#
include
<
winnt
.
h
>
#
include
<
atlbase
.
h
>
#
include
<
dia2
.
h
>
#
include
<
diacreate
.
h
>
#
include
<
ImageHlp
.
h
>
#
include
<
stdio
.
h
>
#
include
<
algorithm
>
#
include
<
limits
>
#
include
<
map
>
#
include
<
set
>
#
include
<
utility
>
#
include
"
common
/
windows
/
dia_util
.
h
"
#
include
"
common
/
windows
/
guid_string
.
h
"
#
include
"
common
/
windows
/
pe_util
.
h
"
#
include
"
common
/
windows
/
string_utils
-
inl
.
h
"
#
ifndef
UNDNAME_NO_ECSU
#
define
UNDNAME_NO_ECSU
0x8000
/
/
Suppresses
enum
/
class
/
struct
/
union
.
#
endif
namespace
google_breakpad
{
namespace
{
using
std
:
:
vector
;
struct
SelectedSymbol
{
SelectedSymbol
(
const
CComPtr
<
IDiaSymbol
>
&
symbol
bool
is_public
)
:
symbol
(
symbol
)
is_public
(
is_public
)
is_multiple
(
false
)
{
}
CComPtr
<
IDiaSymbol
>
symbol
;
bool
is_public
;
bool
is_multiple
;
}
;
typedef
std
:
:
map
<
DWORD
SelectedSymbol
>
SymbolMap
;
void
MaybeRecordSymbol
(
DWORD
rva
const
CComPtr
<
IDiaSymbol
>
symbol
bool
is_public
SymbolMap
*
map
)
{
SymbolMap
:
:
iterator
loc
=
map
-
>
find
(
rva
)
;
if
(
loc
=
=
map
-
>
end
(
)
)
{
map
-
>
insert
(
std
:
:
make_pair
(
rva
SelectedSymbol
(
symbol
is_public
)
)
)
;
return
;
}
if
(
is_public
&
&
!
loc
-
>
second
.
is_public
)
{
return
;
}
loc
-
>
second
.
is_multiple
=
true
;
BSTR
current_name
new_name
;
loc
-
>
second
.
symbol
-
>
get_name
(
&
current_name
)
;
symbol
-
>
get_name
(
&
new_name
)
;
if
(
wcscmp
(
new_name
current_name
)
<
0
)
{
loc
-
>
second
.
symbol
=
symbol
;
loc
-
>
second
.
is_public
=
is_public
;
}
}
bool
SymbolsMatch
(
IDiaSymbol
*
a
IDiaSymbol
*
b
)
{
DWORD
a_section
a_offset
b_section
b_offset
;
if
(
FAILED
(
a
-
>
get_addressSection
(
&
a_section
)
)
|
|
FAILED
(
a
-
>
get_addressOffset
(
&
a_offset
)
)
|
|
FAILED
(
b
-
>
get_addressSection
(
&
b_section
)
)
|
|
FAILED
(
b
-
>
get_addressOffset
(
&
b_offset
)
)
)
return
false
;
return
a_section
=
=
b_section
&
&
a_offset
=
=
b_offset
;
}
bool
CreateDiaDataSourceInstance
(
CComPtr
<
IDiaDataSource
>
&
data_source
)
{
if
(
SUCCEEDED
(
data_source
.
CoCreateInstance
(
CLSID_DiaSource
)
)
)
{
return
true
;
}
class
DECLSPEC_UUID
(
"
B86AE24D
-
BF2F
-
4ac9
-
B5A2
-
34B14E4CE11D
"
)
DiaSource100
;
class
DECLSPEC_UUID
(
"
761D3BCD
-
1304
-
41D5
-
94E8
-
EAC54E4AC172
"
)
DiaSource110
;
class
DECLSPEC_UUID
(
"
3BFCEA48
-
620F
-
4B6B
-
81F7
-
B9AF75454C7D
"
)
DiaSource120
;
class
DECLSPEC_UUID
(
"
E6756135
-
1E65
-
4D17
-
8576
-
610761398C3C
"
)
DiaSource140
;
const
wchar_t
*
msdia_dll
=
nullptr
;
if
(
CLSID_DiaSource
=
=
_uuidof
(
DiaSource100
)
)
{
msdia_dll
=
L
"
msdia100
.
dll
"
;
}
else
if
(
CLSID_DiaSource
=
=
_uuidof
(
DiaSource110
)
)
{
msdia_dll
=
L
"
msdia110
.
dll
"
;
}
else
if
(
CLSID_DiaSource
=
=
_uuidof
(
DiaSource120
)
)
{
msdia_dll
=
L
"
msdia120
.
dll
"
;
}
else
if
(
CLSID_DiaSource
=
=
_uuidof
(
DiaSource140
)
)
{
msdia_dll
=
L
"
msdia140
.
dll
"
;
}
if
(
msdia_dll
&
&
SUCCEEDED
(
NoRegCoCreate
(
msdia_dll
CLSID_DiaSource
IID_IDiaDataSource
reinterpret_cast
<
void
*
*
>
(
&
data_source
)
)
)
)
{
return
true
;
}
return
false
;
}
}
PDBSourceLineWriter
:
:
PDBSourceLineWriter
(
)
:
output_
(
NULL
)
{
}
PDBSourceLineWriter
:
:
~
PDBSourceLineWriter
(
)
{
Close
(
)
;
}
bool
PDBSourceLineWriter
:
:
SetCodeFile
(
const
wstring
&
exe_file
)
{
if
(
code_file_
.
empty
(
)
)
{
code_file_
=
exe_file
;
return
true
;
}
return
exe_file
=
=
code_file_
;
}
bool
PDBSourceLineWriter
:
:
Open
(
const
wstring
&
file
FileFormat
format
)
{
Close
(
)
;
code_file_
.
clear
(
)
;
if
(
FAILED
(
CoInitialize
(
NULL
)
)
)
{
fprintf
(
stderr
"
CoInitialize
failed
\
n
"
)
;
return
false
;
}
CComPtr
<
IDiaDataSource
>
data_source
;
if
(
!
CreateDiaDataSourceInstance
(
data_source
)
)
{
const
int
kGuidSize
=
64
;
wchar_t
classid
[
kGuidSize
]
=
{
0
}
;
StringFromGUID2
(
CLSID_DiaSource
classid
kGuidSize
)
;
fprintf
(
stderr
"
CoCreateInstance
CLSID_DiaSource
%
S
failed
"
"
(
msdia
*
.
dll
unregistered
?
)
\
n
"
classid
)
;
return
false
;
}
switch
(
format
)
{
case
PDB_FILE
:
if
(
FAILED
(
data_source
-
>
loadDataFromPdb
(
file
.
c_str
(
)
)
)
)
{
fprintf
(
stderr
"
loadDataFromPdb
failed
for
%
ws
\
n
"
file
.
c_str
(
)
)
;
return
false
;
}
break
;
case
EXE_FILE
:
if
(
FAILED
(
data_source
-
>
loadDataForExe
(
file
.
c_str
(
)
NULL
NULL
)
)
)
{
fprintf
(
stderr
"
loadDataForExe
failed
for
%
ws
\
n
"
file
.
c_str
(
)
)
;
return
false
;
}
code_file_
=
file
;
break
;
case
ANY_FILE
:
if
(
FAILED
(
data_source
-
>
loadDataFromPdb
(
file
.
c_str
(
)
)
)
)
{
if
(
FAILED
(
data_source
-
>
loadDataForExe
(
file
.
c_str
(
)
NULL
NULL
)
)
)
{
fprintf
(
stderr
"
loadDataForPdb
and
loadDataFromExe
failed
for
%
ws
\
n
"
file
.
c_str
(
)
)
;
return
false
;
}
code_file_
=
file
;
}
break
;
default
:
fprintf
(
stderr
"
Unknown
file
format
\
n
"
)
;
return
false
;
}
if
(
FAILED
(
data_source
-
>
openSession
(
&
session_
)
)
)
{
fprintf
(
stderr
"
openSession
failed
\
n
"
)
;
}
return
true
;
}
bool
PDBSourceLineWriter
:
:
PrintLines
(
IDiaEnumLineNumbers
*
lines
)
{
CComPtr
<
IDiaLineNumber
>
line
;
ULONG
count
;
while
(
SUCCEEDED
(
lines
-
>
Next
(
1
&
line
&
count
)
)
&
&
count
=
=
1
)
{
DWORD
rva
;
if
(
FAILED
(
line
-
>
get_relativeVirtualAddress
(
&
rva
)
)
)
{
fprintf
(
stderr
"
failed
to
get
line
rva
\
n
"
)
;
return
false
;
}
DWORD
length
;
if
(
FAILED
(
line
-
>
get_length
(
&
length
)
)
)
{
fprintf
(
stderr
"
failed
to
get
line
code
length
\
n
"
)
;
return
false
;
}
DWORD
dia_source_id
;
if
(
FAILED
(
line
-
>
get_sourceFileId
(
&
dia_source_id
)
)
)
{
fprintf
(
stderr
"
failed
to
get
line
source
file
id
\
n
"
)
;
return
false
;
}
DWORD
source_id
=
GetRealFileID
(
dia_source_id
)
;
DWORD
line_num
;
if
(
FAILED
(
line
-
>
get_lineNumber
(
&
line_num
)
)
)
{
fprintf
(
stderr
"
failed
to
get
line
number
\
n
"
)
;
return
false
;
}
AddressRangeVector
ranges
;
MapAddressRange
(
image_map_
AddressRange
(
rva
length
)
&
ranges
)
;
for
(
size_t
i
=
0
;
i
<
ranges
.
size
(
)
;
+
+
i
)
{
fprintf
(
output_
"
%
lx
%
lx
%
lu
%
lu
\
n
"
ranges
[
i
]
.
rva
ranges
[
i
]
.
length
line_num
source_id
)
;
}
line
.
Release
(
)
;
}
return
true
;
}
bool
PDBSourceLineWriter
:
:
PrintFunction
(
IDiaSymbol
*
function
IDiaSymbol
*
block
bool
has_multiple_symbols
)
{
DWORD
rva
;
if
(
FAILED
(
block
-
>
get_relativeVirtualAddress
(
&
rva
)
)
)
{
fprintf
(
stderr
"
couldn
'
t
get
rva
\
n
"
)
;
return
false
;
}
ULONGLONG
length
;
if
(
FAILED
(
block
-
>
get_length
(
&
length
)
)
)
{
fprintf
(
stderr
"
failed
to
get
function
length
\
n
"
)
;
return
false
;
}
if
(
length
=
=
0
)
{
return
true
;
}
CComBSTR
name
;
int
stack_param_size
;
if
(
!
GetSymbolFunctionName
(
function
&
name
&
stack_param_size
)
)
{
return
false
;
}
if
(
stack_param_size
<
0
)
{
stack_param_size
=
GetFunctionStackParamSize
(
function
)
;
}
AddressRangeVector
ranges
;
MapAddressRange
(
image_map_
AddressRange
(
rva
static_cast
<
DWORD
>
(
length
)
)
&
ranges
)
;
for
(
size_t
i
=
0
;
i
<
ranges
.
size
(
)
;
+
+
i
)
{
const
char
*
optional_multiple_field
=
has_multiple_symbols
?
"
m
"
:
"
"
;
fprintf
(
output_
"
FUNC
%
s
%
lx
%
lx
%
x
%
ws
\
n
"
optional_multiple_field
ranges
[
i
]
.
rva
ranges
[
i
]
.
length
stack_param_size
name
.
m_str
)
;
}
CComPtr
<
IDiaEnumLineNumbers
>
lines
;
if
(
FAILED
(
session_
-
>
findLinesByRVA
(
rva
DWORD
(
length
)
&
lines
)
)
)
{
return
false
;
}
if
(
!
PrintLines
(
lines
)
)
{
return
false
;
}
return
true
;
}
bool
PDBSourceLineWriter
:
:
PrintSourceFiles
(
)
{
CComPtr
<
IDiaSymbol
>
global
;
if
(
FAILED
(
session_
-
>
get_globalScope
(
&
global
)
)
)
{
fprintf
(
stderr
"
get_globalScope
failed
\
n
"
)
;
return
false
;
}
CComPtr
<
IDiaEnumSymbols
>
compilands
;
if
(
FAILED
(
global
-
>
findChildren
(
SymTagCompiland
NULL
nsNone
&
compilands
)
)
)
{
fprintf
(
stderr
"
findChildren
failed
\
n
"
)
;
return
false
;
}
CComPtr
<
IDiaSymbol
>
compiland
;
ULONG
count
;
while
(
SUCCEEDED
(
compilands
-
>
Next
(
1
&
compiland
&
count
)
)
&
&
count
=
=
1
)
{
CComPtr
<
IDiaEnumSourceFiles
>
source_files
;
if
(
FAILED
(
session_
-
>
findFile
(
compiland
NULL
nsNone
&
source_files
)
)
)
{
return
false
;
}
CComPtr
<
IDiaSourceFile
>
file
;
while
(
SUCCEEDED
(
source_files
-
>
Next
(
1
&
file
&
count
)
)
&
&
count
=
=
1
)
{
DWORD
file_id
;
if
(
FAILED
(
file
-
>
get_uniqueId
(
&
file_id
)
)
)
{
return
false
;
}
CComBSTR
file_name
;
if
(
FAILED
(
file
-
>
get_fileName
(
&
file_name
)
)
)
{
return
false
;
}
wstring
file_name_string
(
file_name
)
;
if
(
!
FileIDIsCached
(
file_name_string
)
)
{
CacheFileID
(
file_name_string
file_id
)
;
fwprintf
(
output_
L
"
FILE
%
d
%
ws
\
n
"
file_id
file_name_string
.
c_str
(
)
)
;
}
else
{
StoreDuplicateFileID
(
file_name_string
file_id
)
;
}
file
.
Release
(
)
;
}
compiland
.
Release
(
)
;
}
return
true
;
}
bool
PDBSourceLineWriter
:
:
PrintFunctions
(
)
{
ULONG
count
=
0
;
DWORD
rva
=
0
;
CComPtr
<
IDiaSymbol
>
global
;
HRESULT
hr
;
if
(
FAILED
(
session_
-
>
get_globalScope
(
&
global
)
)
)
{
fprintf
(
stderr
"
get_globalScope
failed
\
n
"
)
;
return
false
;
}
CComPtr
<
IDiaEnumSymbols
>
symbols
=
NULL
;
SymbolMap
rva_symbol
;
hr
=
global
-
>
findChildren
(
SymTagFunction
NULL
nsNone
&
symbols
)
;
if
(
SUCCEEDED
(
hr
)
)
{
CComPtr
<
IDiaSymbol
>
symbol
=
NULL
;
while
(
SUCCEEDED
(
symbols
-
>
Next
(
1
&
symbol
&
count
)
)
&
&
count
=
=
1
)
{
if
(
SUCCEEDED
(
symbol
-
>
get_relativeVirtualAddress
(
&
rva
)
)
)
{
MaybeRecordSymbol
(
rva
symbol
false
&
rva_symbol
)
;
}
else
{
fprintf
(
stderr
"
get_relativeVirtualAddress
failed
on
the
symbol
\
n
"
)
;
return
false
;
}
symbol
.
Release
(
)
;
}
symbols
.
Release
(
)
;
}
hr
=
global
-
>
findChildren
(
SymTagPublicSymbol
NULL
nsNone
&
symbols
)
;
if
(
SUCCEEDED
(
hr
)
)
{
CComPtr
<
IDiaSymbol
>
symbol
=
NULL
;
while
(
SUCCEEDED
(
symbols
-
>
Next
(
1
&
symbol
&
count
)
)
&
&
count
=
=
1
)
{
if
(
SUCCEEDED
(
symbol
-
>
get_relativeVirtualAddress
(
&
rva
)
)
)
{
MaybeRecordSymbol
(
rva
symbol
true
&
rva_symbol
)
;
}
else
{
fprintf
(
stderr
"
get_relativeVirtualAddress
failed
on
the
symbol
\
n
"
)
;
return
false
;
}
symbol
.
Release
(
)
;
}
symbols
.
Release
(
)
;
}
SymbolMap
:
:
iterator
it
;
for
(
it
=
rva_symbol
.
begin
(
)
;
it
!
=
rva_symbol
.
end
(
)
;
+
+
it
)
{
CComPtr
<
IDiaSymbol
>
symbol
=
it
-
>
second
.
symbol
;
if
(
!
it
-
>
second
.
is_public
)
{
if
(
!
PrintFunction
(
symbol
symbol
it
-
>
second
.
is_multiple
)
)
return
false
;
}
else
{
if
(
!
PrintCodePublicSymbol
(
symbol
it
-
>
second
.
is_multiple
)
)
return
false
;
}
}
CComPtr
<
IDiaEnumSymbols
>
compilands
;
if
(
FAILED
(
global
-
>
findChildren
(
SymTagCompiland
NULL
nsNone
&
compilands
)
)
)
{
fprintf
(
stderr
"
findChildren
failed
on
the
global
\
n
"
)
;
return
false
;
}
CComPtr
<
IDiaSymbol
>
compiland
;
while
(
SUCCEEDED
(
compilands
-
>
Next
(
1
&
compiland
&
count
)
)
&
&
count
=
=
1
)
{
CComPtr
<
IDiaEnumSymbols
>
blocks
;
if
(
FAILED
(
compiland
-
>
findChildren
(
SymTagBlock
NULL
nsNone
&
blocks
)
)
)
{
fprintf
(
stderr
"
findChildren
failed
on
a
compiland
\
n
"
)
;
return
false
;
}
CComPtr
<
IDiaSymbol
>
block
;
while
(
SUCCEEDED
(
blocks
-
>
Next
(
1
&
block
&
count
)
)
&
&
count
=
=
1
)
{
CComPtr
<
IDiaSymbol
>
parent
;
DWORD
tag
;
if
(
SUCCEEDED
(
block
-
>
get_lexicalParent
(
&
parent
)
)
&
&
SUCCEEDED
(
parent
-
>
get_symTag
(
&
tag
)
)
&
&
tag
=
=
SymTagFunction
)
{
DWORD
func_rva
block_rva
;
ULONGLONG
func_length
;
if
(
SUCCEEDED
(
block
-
>
get_relativeVirtualAddress
(
&
block_rva
)
)
&
&
SUCCEEDED
(
parent
-
>
get_relativeVirtualAddress
(
&
func_rva
)
)
&
&
SUCCEEDED
(
parent
-
>
get_length
(
&
func_length
)
)
)
{
if
(
block_rva
<
func_rva
|
|
block_rva
>
(
func_rva
+
func_length
)
)
{
if
(
!
PrintFunction
(
parent
block
false
)
)
{
return
false
;
}
}
}
}
parent
.
Release
(
)
;
block
.
Release
(
)
;
}
blocks
.
Release
(
)
;
compiland
.
Release
(
)
;
}
global
.
Release
(
)
;
return
true
;
}
#
undef
max
bool
PDBSourceLineWriter
:
:
PrintFrameDataUsingPDB
(
)
{
CComPtr
<
IDiaEnumFrameData
>
frame_data_enum
;
if
(
!
FindTable
(
session_
&
frame_data_enum
)
)
return
false
;
DWORD
last_type
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
;
DWORD
last_rva
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
;
DWORD
last_code_size
=
0
;
DWORD
last_prolog_size
=
std
:
:
numeric_limits
<
DWORD
>
:
:
max
(
)
;
CComPtr
<
IDiaFrameData
>
frame_data
;
ULONG
count
=
0
;
while
(
SUCCEEDED
(
frame_data_enum
-
>
Next
(
1
&
frame_data
&
count
)
)
&
&
count
=
=
1
)
{
DWORD
type
;
if
(
FAILED
(
frame_data
-
>
get_type
(
&
type
)
)
)
return
false
;
DWORD
rva
;
if
(
FAILED
(
frame_data
-
>
get_relativeVirtualAddress
(
&
rva
)
)
)
return
false
;
DWORD
code_size
;
if
(
FAILED
(
frame_data
-
>
get_lengthBlock
(
&
code_size
)
)
)
return
false
;
DWORD
prolog_size
;
if
(
FAILED
(
frame_data
-
>
get_lengthProlog
(
&
prolog_size
)
)
)
return
false
;
DWORD
parameter_size
;
if
(
FAILED
(
frame_data
-
>
get_lengthParams
(
&
parameter_size
)
)
)
return
false
;
DWORD
saved_register_size
;
if
(
FAILED
(
frame_data
-
>
get_lengthSavedRegisters
(
&
saved_register_size
)
)
)
return
false
;
DWORD
local_size
;
if
(
FAILED
(
frame_data
-
>
get_lengthLocals
(
&
local_size
)
)
)
return
false
;
DWORD
max_stack_size
=
0
;
if
(
FAILED
(
frame_data
-
>
get_maxStack
(
&
max_stack_size
)
)
)
return
false
;
HRESULT
program_string_result
;
CComBSTR
program_string
;
if
(
FAILED
(
program_string_result
=
frame_data
-
>
get_program
(
&
program_string
)
)
)
{
return
false
;
}
BOOL
allocates_base_pointer
=
FALSE
;
if
(
program_string_result
!
=
S_OK
)
{
if
(
FAILED
(
frame_data
-
>
get_allocatesBasePointer
(
&
allocates_base_pointer
)
)
)
{
return
false
;
}
}
if
(
type
!
=
last_type
|
|
rva
!
=
last_rva
|
|
code_size
!
=
last_code_size
|
|
prolog_size
!
=
last_prolog_size
)
{
AddressRangeVector
prolog_ranges
;
if
(
prolog_size
>
0
)
{
MapAddressRange
(
image_map_
AddressRange
(
rva
prolog_size
)
&
prolog_ranges
)
;
}
AddressRangeVector
code_ranges
;
MapAddressRange
(
image_map_
AddressRange
(
rva
+
prolog_size
code_size
-
prolog_size
)
&
code_ranges
)
;
struct
FrameInfo
{
DWORD
rva
;
DWORD
code_size
;
DWORD
prolog_size
;
}
;
std
:
:
vector
<
FrameInfo
>
frame_infos
;
if
(
prolog_ranges
.
size
(
)
=
=
1
&
&
code_ranges
.
size
(
)
=
=
1
&
&
prolog_ranges
[
0
]
.
end
(
)
=
=
code_ranges
[
0
]
.
rva
)
{
FrameInfo
fi
=
{
prolog_ranges
[
0
]
.
rva
prolog_ranges
[
0
]
.
length
+
code_ranges
[
0
]
.
length
prolog_ranges
[
0
]
.
length
}
;
frame_infos
.
push_back
(
fi
)
;
}
else
{
for
(
size_t
i
=
0
;
i
<
prolog_ranges
.
size
(
)
;
+
+
i
)
{
FrameInfo
fi
=
{
prolog_ranges
[
i
]
.
rva
prolog_ranges
[
i
]
.
length
prolog_ranges
[
i
]
.
length
}
;
frame_infos
.
push_back
(
fi
)
;
}
for
(
size_t
i
=
0
;
i
<
code_ranges
.
size
(
)
;
+
+
i
)
{
FrameInfo
fi
=
{
code_ranges
[
i
]
.
rva
code_ranges
[
i
]
.
length
0
}
;
frame_infos
.
push_back
(
fi
)
;
}
}
for
(
size_t
i
=
0
;
i
<
frame_infos
.
size
(
)
;
+
+
i
)
{
const
FrameInfo
&
fi
(
frame_infos
[
i
]
)
;
fprintf
(
output_
"
STACK
WIN
%
lx
%
lx
%
lx
%
lx
%
x
%
lx
%
lx
%
lx
%
lx
%
d
"
type
fi
.
rva
fi
.
code_size
fi
.
prolog_size
0
parameter_size
saved_register_size
local_size
max_stack_size
program_string_result
=
=
S_OK
)
;
if
(
program_string_result
=
=
S_OK
)
{
fprintf
(
output_
"
%
ws
\
n
"
program_string
.
m_str
)
;
}
else
{
fprintf
(
output_
"
%
d
\
n
"
allocates_base_pointer
)
;
}
}
last_type
=
type
;
last_rva
=
rva
;
last_code_size
=
code_size
;
last_prolog_size
=
prolog_size
;
}
frame_data
.
Release
(
)
;
}
return
true
;
}
bool
PDBSourceLineWriter
:
:
PrintFrameDataUsingEXE
(
)
{
if
(
code_file_
.
empty
(
)
&
&
!
FindPEFile
(
)
)
{
fprintf
(
stderr
"
Couldn
'
t
locate
EXE
or
DLL
file
.
\
n
"
)
;
return
false
;
}
return
PrintPEFrameData
(
code_file_
output_
)
;
}
bool
PDBSourceLineWriter
:
:
PrintFrameData
(
)
{
PDBModuleInfo
info
;
if
(
GetModuleInfo
(
&
info
)
&
&
info
.
cpu
=
=
L
"
x86_64
"
)
{
return
PrintFrameDataUsingEXE
(
)
;
}
else
{
return
PrintFrameDataUsingPDB
(
)
;
}
return
false
;
}
bool
PDBSourceLineWriter
:
:
PrintCodePublicSymbol
(
IDiaSymbol
*
symbol
bool
has_multiple_symbols
)
{
BOOL
is_code
;
if
(
FAILED
(
symbol
-
>
get_code
(
&
is_code
)
)
)
{
return
false
;
}
if
(
!
is_code
)
{
return
true
;
}
DWORD
rva
;
if
(
FAILED
(
symbol
-
>
get_relativeVirtualAddress
(
&
rva
)
)
)
{
return
false
;
}
CComBSTR
name
;
int
stack_param_size
;
if
(
!
GetSymbolFunctionName
(
symbol
&
name
&
stack_param_size
)
)
{
return
false
;
}
AddressRangeVector
ranges
;
MapAddressRange
(
image_map_
AddressRange
(
rva
1
)
&
ranges
)
;
for
(
size_t
i
=
0
;
i
<
ranges
.
size
(
)
;
+
+
i
)
{
const
char
*
optional_multiple_field
=
has_multiple_symbols
?
"
m
"
:
"
"
;
fprintf
(
output_
"
PUBLIC
%
s
%
lx
%
x
%
ws
\
n
"
optional_multiple_field
ranges
[
i
]
.
rva
stack_param_size
>
0
?
stack_param_size
:
0
name
.
m_str
)
;
}
for
(
;
;
)
{
rva
=
image_map_
.
subsequent_rva_block
[
rva
]
;
if
(
rva
=
=
0
)
break
;
CComPtr
<
IDiaSymbol
>
next_sym
=
NULL
;
LONG
displacement
;
if
(
FAILED
(
session_
-
>
findSymbolByRVAEx
(
rva
SymTagPublicSymbol
&
next_sym
&
displacement
)
)
)
{
break
;
}
if
(
!
SymbolsMatch
(
symbol
next_sym
)
)
break
;
AddressRangeVector
next_ranges
;
MapAddressRange
(
image_map_
AddressRange
(
rva
1
)
&
next_ranges
)
;
for
(
size_t
i
=
0
;
i
<
next_ranges
.
size
(
)
;
+
+
i
)
{
fprintf
(
output_
"
PUBLIC
%
lx
%
x
%
ws
\
n
"
next_ranges
[
i
]
.
rva
stack_param_size
>
0
?
stack_param_size
:
0
name
.
m_str
)
;
}
}
return
true
;
}
bool
PDBSourceLineWriter
:
:
PrintPDBInfo
(
)
{
PDBModuleInfo
info
;
if
(
!
GetModuleInfo
(
&
info
)
)
{
return
false
;
}
fprintf
(
output_
"
MODULE
windows
%
ws
%
ws
%
ws
\
n
"
info
.
cpu
.
c_str
(
)
info
.
debug_identifier
.
c_str
(
)
info
.
debug_file
.
c_str
(
)
)
;
return
true
;
}
bool
PDBSourceLineWriter
:
:
PrintPEInfo
(
)
{
PEModuleInfo
info
;
if
(
!
GetPEInfo
(
&
info
)
)
{
return
false
;
}
fprintf
(
output_
"
INFO
CODE_ID
%
ws
%
ws
\
n
"
info
.
code_identifier
.
c_str
(
)
info
.
code_file
.
c_str
(
)
)
;
return
true
;
}
static
bool
wcstol_positive_strict
(
wchar_t
*
string
int
*
result
)
{
int
value
=
0
;
for
(
wchar_t
*
c
=
string
;
*
c
!
=
'
\
0
'
;
+
+
c
)
{
int
last_value
=
value
;
value
*
=
10
;
if
(
value
/
10
!
=
last_value
|
|
value
<
0
)
{
return
false
;
}
if
(
*
c
<
'
0
'
|
|
*
c
>
'
9
'
)
{
return
false
;
}
unsigned
int
c_value
=
*
c
-
'
0
'
;
last_value
=
value
;
value
+
=
c_value
;
if
(
value
<
last_value
)
{
return
false
;
}
if
(
value
=
=
0
&
&
*
(
c
+
1
)
!
=
'
\
0
'
)
{
return
false
;
}
}
*
result
=
value
;
return
true
;
}
bool
PDBSourceLineWriter
:
:
FindPEFile
(
)
{
CComPtr
<
IDiaSymbol
>
global
;
if
(
FAILED
(
session_
-
>
get_globalScope
(
&
global
)
)
)
{
fprintf
(
stderr
"
get_globalScope
failed
\
n
"
)
;
return
false
;
}
CComBSTR
symbols_file
;
if
(
SUCCEEDED
(
global
-
>
get_symbolsFileName
(
&
symbols_file
)
)
)
{
wstring
file
(
symbols_file
)
;
const
wchar_t
*
extensions
[
]
=
{
L
"
exe
"
L
"
dll
"
}
;
for
(
size_t
i
=
0
;
i
<
sizeof
(
extensions
)
/
sizeof
(
extensions
[
0
]
)
;
i
+
+
)
{
size_t
dot_pos
=
file
.
find_last_of
(
L
"
.
"
)
;
if
(
dot_pos
!
=
wstring
:
:
npos
)
{
file
.
replace
(
dot_pos
+
1
wstring
:
:
npos
extensions
[
i
]
)
;
if
(
GetFileAttributesW
(
file
.
c_str
(
)
)
!
=
INVALID_FILE_ATTRIBUTES
)
{
code_file_
=
file
;
return
true
;
}
}
}
}
return
false
;
}
bool
PDBSourceLineWriter
:
:
GetSymbolFunctionName
(
IDiaSymbol
*
function
BSTR
*
name
int
*
stack_param_size
)
{
*
stack_param_size
=
-
1
;
const
DWORD
undecorate_options
=
UNDNAME_NO_MS_KEYWORDS
|
UNDNAME_NO_FUNCTION_RETURNS
|
UNDNAME_NO_ALLOCATION_MODEL
|
UNDNAME_NO_ALLOCATION_LANGUAGE
|
UNDNAME_NO_THISTYPE
|
UNDNAME_NO_ACCESS_SPECIFIERS
|
UNDNAME_NO_THROW_SIGNATURES
|
UNDNAME_NO_MEMBER_TYPE
|
UNDNAME_NO_RETURN_UDT_MODEL
|
UNDNAME_NO_ECSU
;
if
(
function
-
>
get_undecoratedNameEx
(
undecorate_options
name
)
!
=
S_OK
)
{
if
(
function
-
>
get_name
(
name
)
!
=
S_OK
)
{
fprintf
(
stderr
"
failed
to
get
function
name
\
n
"
)
;
return
false
;
}
if
(
wcscmp
(
*
name
L
"
"
)
=
=
0
)
{
SysFreeString
(
*
name
)
;
*
name
=
SysAllocString
(
L
"
<
name
omitted
>
"
)
;
return
true
;
}
}
else
{
const
wchar_t
*
replace_string
=
L
"
(
void
)
"
;
const
size_t
replace_length
=
wcslen
(
replace_string
)
;
const
wchar_t
*
replacement_string
=
L
"
(
)
"
;
size_t
length
=
wcslen
(
*
name
)
;
if
(
length
>
=
replace_length
)
{
wchar_t
*
name_end
=
*
name
+
length
-
replace_length
;
if
(
wcscmp
(
name_end
replace_string
)
=
=
0
)
{
WindowsStringUtils
:
:
safe_wcscpy
(
name_end
replace_length
replacement_string
)
;
length
=
wcslen
(
*
name
)
;
}
}
if
(
!
wcschr
(
*
name
'
:
'
)
&
&
!
wcschr
(
*
name
'
(
'
)
&
&
(
*
name
[
0
]
=
=
'
_
'
|
|
*
name
[
0
]
=
=
'
'
)
)
{
wchar_t
*
last_at
=
wcsrchr
(
*
name
+
1
'
'
)
;
if
(
last_at
&
&
wcstol_positive_strict
(
last_at
+
1
stack_param_size
)
)
{
if
(
*
name
[
0
]
=
=
'
'
)
{
if
(
*
stack_param_size
>
8
)
{
*
stack_param_size
-
=
8
;
}
else
{
*
stack_param_size
=
0
;
}
}
WindowsStringUtils
:
:
safe_wcsncpy
(
*
name
length
*
name
+
1
last_at
-
*
name
-
1
)
;
}
else
if
(
*
name
[
0
]
=
=
'
_
'
)
{
WindowsStringUtils
:
:
safe_wcsncpy
(
*
name
length
*
name
+
1
length
)
;
}
}
}
return
true
;
}
int
PDBSourceLineWriter
:
:
GetFunctionStackParamSize
(
IDiaSymbol
*
function
)
{
CComPtr
<
IDiaEnumSymbols
>
data_children
;
if
(
FAILED
(
function
-
>
findChildren
(
SymTagData
NULL
nsNone
&
data_children
)
)
)
{
return
0
;
}
int
lowest_base
=
INT_MAX
;
int
highest_end
=
INT_MIN
;
CComPtr
<
IDiaSymbol
>
child
;
DWORD
count
;
while
(
SUCCEEDED
(
data_children
-
>
Next
(
1
&
child
&
count
)
)
&
&
count
=
=
1
)
{
CComPtr
<
IDiaSymbol
>
child_type
;
DWORD
child_kind
;
if
(
FAILED
(
child
-
>
get_dataKind
(
&
child_kind
)
)
|
|
(
child_kind
!
=
DataIsParam
&
&
child_kind
!
=
DataIsObjectPtr
)
)
{
goto
next_child
;
}
DWORD
child_location_type
;
if
(
FAILED
(
child
-
>
get_locationType
(
&
child_location_type
)
)
|
|
child_location_type
!
=
LocIsRegRel
)
{
goto
next_child
;
}
DWORD
child_register
;
if
(
FAILED
(
child
-
>
get_registerId
(
&
child_register
)
)
|
|
child_register
!
=
CV_REG_EBP
)
{
goto
next_child
;
}
LONG
child_register_offset
;
if
(
FAILED
(
child
-
>
get_offset
(
&
child_register_offset
)
)
)
{
goto
next_child
;
}
if
(
FAILED
(
child
-
>
get_type
(
&
child_type
)
)
|
|
!
child_type
)
{
goto
next_child
;
}
ULONGLONG
child_length
;
if
(
FAILED
(
child_type
-
>
get_length
(
&
child_length
)
)
)
{
goto
next_child
;
}
{
int
child_end
=
child_register_offset
+
static_cast
<
ULONG
>
(
child_length
)
;
if
(
child_register_offset
<
lowest_base
)
{
lowest_base
=
child_register_offset
;
}
if
(
child_end
>
highest_end
)
{
highest_end
=
child_end
;
}
}
next_child
:
child
.
Release
(
)
;
}
int
param_size
=
0
;
if
(
lowest_base
<
4
)
{
lowest_base
=
4
;
}
if
(
highest_end
>
lowest_base
)
{
int
remainder
=
highest_end
%
4
;
if
(
remainder
)
{
highest_end
+
=
4
-
remainder
;
}
param_size
=
highest_end
-
lowest_base
;
}
return
param_size
;
}
bool
PDBSourceLineWriter
:
:
WriteSymbols
(
FILE
*
symbol_file
)
{
output_
=
symbol_file
;
OmapData
omap_data
;
if
(
!
GetOmapDataAndDisableTranslation
(
session_
&
omap_data
)
)
return
false
;
BuildImageMap
(
omap_data
&
image_map_
)
;
bool
ret
=
PrintPDBInfo
(
)
;
PrintPEInfo
(
)
;
ret
=
ret
&
&
PrintSourceFiles
(
)
&
&
PrintFunctions
(
)
&
&
PrintFrameData
(
)
;
output_
=
NULL
;
return
ret
;
}
void
PDBSourceLineWriter
:
:
Close
(
)
{
if
(
session_
!
=
nullptr
)
{
session_
.
Release
(
)
;
}
}
bool
PDBSourceLineWriter
:
:
GetModuleInfo
(
PDBModuleInfo
*
info
)
{
if
(
!
info
)
{
return
false
;
}
info
-
>
debug_file
.
clear
(
)
;
info
-
>
debug_identifier
.
clear
(
)
;
info
-
>
cpu
.
clear
(
)
;
CComPtr
<
IDiaSymbol
>
global
;
if
(
FAILED
(
session_
-
>
get_globalScope
(
&
global
)
)
)
{
return
false
;
}
DWORD
machine_type
;
if
(
global
-
>
get_machineType
(
&
machine_type
)
=
=
S_OK
)
{
info
-
>
cpu
=
FileHeaderMachineToCpuString
(
static_cast
<
WORD
>
(
machine_type
)
)
;
}
else
{
info
-
>
cpu
=
L
"
unknown
"
;
}
DWORD
age
;
if
(
FAILED
(
global
-
>
get_age
(
&
age
)
)
)
{
return
false
;
}
bool
uses_guid
;
if
(
!
UsesGUID
(
&
uses_guid
)
)
{
return
false
;
}
if
(
uses_guid
)
{
GUID
guid
;
if
(
FAILED
(
global
-
>
get_guid
(
&
guid
)
)
)
{
return
false
;
}
info
-
>
debug_identifier
=
GenerateDebugIdentifier
(
age
guid
)
;
}
else
{
DWORD
signature
;
if
(
FAILED
(
global
-
>
get_signature
(
&
signature
)
)
)
{
return
false
;
}
info
-
>
debug_identifier
=
GenerateDebugIdentifier
(
age
signature
)
;
}
CComBSTR
debug_file_string
;
if
(
FAILED
(
global
-
>
get_symbolsFileName
(
&
debug_file_string
)
)
)
{
return
false
;
}
info
-
>
debug_file
=
WindowsStringUtils
:
:
GetBaseName
(
wstring
(
debug_file_string
)
)
;
return
true
;
}
bool
PDBSourceLineWriter
:
:
GetPEInfo
(
PEModuleInfo
*
info
)
{
if
(
!
info
)
{
return
false
;
}
if
(
code_file_
.
empty
(
)
&
&
!
FindPEFile
(
)
)
{
fprintf
(
stderr
"
Couldn
'
t
locate
EXE
or
DLL
file
.
\
n
"
)
;
return
false
;
}
return
ReadPEInfo
(
code_file_
info
)
;
}
bool
PDBSourceLineWriter
:
:
UsesGUID
(
bool
*
uses_guid
)
{
if
(
!
uses_guid
)
return
false
;
CComPtr
<
IDiaSymbol
>
global
;
if
(
FAILED
(
session_
-
>
get_globalScope
(
&
global
)
)
)
return
false
;
GUID
guid
;
if
(
FAILED
(
global
-
>
get_guid
(
&
guid
)
)
)
return
false
;
DWORD
signature
;
if
(
FAILED
(
global
-
>
get_signature
(
&
signature
)
)
)
return
false
;
GUID
signature_guid
=
{
signature
}
;
*
uses_guid
=
!
IsEqualGUID
(
guid
signature_guid
)
;
return
true
;
}
}
