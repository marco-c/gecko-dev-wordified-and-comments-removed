#
import
"
HTTPMultipartUpload
.
h
"
#
import
"
GTMDefines
.
h
"
static
NSString
*
PercentEncodeNSString
(
NSString
*
key
)
{
#
if
(
defined
(
__IPHONE_OS_VERSION_MIN_REQUIRED
)
&
&
defined
(
__IPHONE_9_0
)
&
&
\
__IPHONE_OS_VERSION_MIN_REQUIRED
>
=
__IPHONE_9_0
)
|
|
\
(
defined
(
MAC_OS_X_VERSION_MIN_REQUIRED
)
&
&
\
defined
(
MAC_OS_X_VERSION_10_11
)
&
&
\
MAC_OS_X_VERSION_MIN_REQUIRED
>
=
MAC_OS_X_VERSION_10_11
)
return
[
key
stringByAddingPercentEncodingWithAllowedCharacters
:
[
NSCharacterSet
URLQueryAllowedCharacterSet
]
]
;
#
else
return
[
key
stringByAddingPercentEscapesUsingEncoding
:
NSUTF8StringEncoding
]
;
#
endif
}
static
NSData
*
SendSynchronousNSURLRequest
(
NSURLRequest
*
req
NSURLResponse
*
*
out_response
NSError
*
*
out_error
)
{
#
if
(
defined
(
__IPHONE_OS_VERSION_MIN_REQUIRED
)
&
&
defined
(
__IPHONE_7_0
)
&
&
\
__IPHONE_OS_VERSION_MIN_REQUIRED
>
=
__IPHONE_7_0
)
|
|
\
(
defined
(
MAC_OS_X_VERSION_MIN_REQUIRED
)
&
&
\
defined
(
MAC_OS_X_VERSION_10_11
)
&
&
\
MAC_OS_X_VERSION_MIN_REQUIRED
>
=
MAC_OS_X_VERSION_10_11
)
__block
NSData
*
result
=
nil
;
__block
NSError
*
error
=
nil
;
__block
NSURLResponse
*
response
=
nil
;
dispatch_semaphore_t
wait_semaphone
=
dispatch_semaphore_create
(
0
)
;
[
[
[
NSURLSession
sharedSession
]
dataTaskWithRequest
:
req
completionHandler
:
^
(
NSData
*
data
NSURLResponse
*
resp
NSError
*
err
)
{
if
(
out_error
)
error
=
[
err
retain
]
;
if
(
out_response
)
response
=
[
resp
retain
]
;
if
(
err
=
=
nil
)
result
=
[
data
retain
]
;
dispatch_semaphore_signal
(
wait_semaphone
)
;
}
]
resume
]
;
dispatch_semaphore_wait
(
wait_semaphone
DISPATCH_TIME_FOREVER
)
;
dispatch_release
(
wait_semaphone
)
;
if
(
out_error
)
*
out_error
=
[
error
autorelease
]
;
if
(
out_response
)
*
out_response
=
[
response
autorelease
]
;
return
[
result
autorelease
]
;
#
else
return
[
NSURLConnection
sendSynchronousRequest
:
req
returningResponse
:
out_response
error
:
out_error
]
;
#
endif
}
interface
HTTPMultipartUpload
(
PrivateMethods
)
-
(
NSString
*
)
multipartBoundary
;
-
(
NSData
*
)
formDataForJSON
:
(
NSString
*
)
json
;
-
(
NSData
*
)
formDataForFileContents
:
(
NSData
*
)
contents
name
:
(
NSString
*
)
name
;
-
(
NSData
*
)
formDataForFile
:
(
NSString
*
)
file
name
:
(
NSString
*
)
name
;
end
implementation
HTTPMultipartUpload
#
pragma
mark
-
#
pragma
mark
|
|
Private
|
|
-
(
NSString
*
)
multipartBoundary
{
return
[
NSString
stringWithFormat
:
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
%
08X
%
08X
"
rand
(
)
rand
(
)
]
;
}
-
(
NSData
*
)
formDataForJSON
:
(
NSString
*
)
json
{
NSMutableData
*
data
=
[
NSMutableData
data
]
;
NSString
*
fmt
=
"
-
-
%
\
r
\
nContent
-
Disposition
:
form
-
data
;
name
=
\
"
extra
\
"
;
"
"
filename
=
\
"
extra
.
json
\
"
\
r
\
nContent
-
Type
:
application
/
json
\
r
\
n
\
r
\
n
"
;
NSString
*
form
=
[
NSString
stringWithFormat
:
fmt
boundary_
]
;
[
data
appendData
:
[
form
dataUsingEncoding
:
NSUTF8StringEncoding
]
]
;
[
data
appendData
:
[
json
dataUsingEncoding
:
NSUTF8StringEncoding
]
]
;
return
data
;
}
-
(
NSData
*
)
formDataForFileContents
:
(
NSData
*
)
contents
name
:
(
NSString
*
)
name
{
NSMutableData
*
data
=
[
NSMutableData
data
]
;
NSString
*
escaped
=
PercentEncodeNSString
(
name
)
;
NSString
*
fmt
=
"
-
-
%
\
r
\
nContent
-
Disposition
:
form
-
data
;
name
=
\
"
%
\
"
;
"
"
filename
=
\
"
minidump
.
dmp
\
"
\
r
\
nContent
-
Type
:
application
/
octet
-
stream
\
r
\
n
\
r
\
n
"
;
NSString
*
pre
=
[
NSString
stringWithFormat
:
fmt
boundary_
escaped
]
;
[
data
appendData
:
[
pre
dataUsingEncoding
:
NSUTF8StringEncoding
]
]
;
[
data
appendData
:
contents
]
;
return
data
;
}
-
(
NSData
*
)
formDataForFile
:
(
NSString
*
)
file
name
:
(
NSString
*
)
name
{
NSData
*
contents
=
[
NSData
dataWithContentsOfFile
:
file
]
;
return
[
self
formDataForFileContents
:
contents
name
:
name
]
;
}
#
pragma
mark
-
#
pragma
mark
|
|
Public
|
|
-
(
id
)
initWithURL
:
(
NSURL
*
)
url
{
if
(
(
self
=
[
super
init
]
)
)
{
url_
=
[
url
copy
]
;
boundary_
=
[
[
self
multipartBoundary
]
retain
]
;
files_
=
[
[
NSMutableDictionary
alloc
]
init
]
;
}
return
self
;
}
-
(
void
)
dealloc
{
[
url_
release
]
;
[
parameters_
release
]
;
[
files_
release
]
;
[
boundary_
release
]
;
[
response_
release
]
;
[
super
dealloc
]
;
}
-
(
NSURL
*
)
URL
{
return
url_
;
}
-
(
void
)
setParameters
:
(
NSMutableString
*
)
parameters
{
if
(
parameters
!
=
parameters_
)
{
[
parameters_
release
]
;
parameters_
=
[
parameters
mutableCopy
]
;
}
}
-
(
NSMutableString
*
)
parameters
{
return
parameters_
;
}
-
(
void
)
addFileAtPath
:
(
NSString
*
)
path
name
:
(
NSString
*
)
name
{
[
files_
setObject
:
path
forKey
:
name
]
;
}
-
(
void
)
addFileContents
:
(
NSData
*
)
data
name
:
(
NSString
*
)
name
{
[
files_
setObject
:
data
forKey
:
name
]
;
}
-
(
NSDictionary
*
)
files
{
return
files_
;
}
-
(
NSData
*
)
send
:
(
NSError
*
*
)
error
{
NSMutableURLRequest
*
req
=
[
[
NSMutableURLRequest
alloc
]
initWithURL
:
url_
cachePolicy
:
NSURLRequestUseProtocolCachePolicy
timeoutInterval
:
60
.
0
]
;
NSMutableData
*
postBody
=
[
NSMutableData
data
]
;
[
req
setValue
:
[
NSString
stringWithFormat
:
"
multipart
/
form
-
data
;
boundary
=
%
"
boundary_
]
forHTTPHeaderField
:
"
Content
-
type
"
]
;
[
postBody
appendData
:
[
self
formDataForJSON
:
parameters_
]
]
;
NSArray
*
fileNames
=
[
files_
allKeys
]
;
for
(
NSString
*
name
in
fileNames
)
{
id
fileOrData
=
[
files_
objectForKey
:
name
]
;
NSData
*
fileData
;
if
(
[
fileOrData
isKindOfClass
:
[
NSData
class
]
]
)
fileData
=
[
self
formDataForFileContents
:
fileOrData
name
:
name
]
;
else
fileData
=
[
self
formDataForFile
:
fileOrData
name
:
name
]
;
[
postBody
appendData
:
fileData
]
;
}
NSString
*
epilogue
=
[
NSString
stringWithFormat
:
"
\
r
\
n
-
-
%
-
-
\
r
\
n
"
boundary_
]
;
[
postBody
appendData
:
[
epilogue
dataUsingEncoding
:
NSUTF8StringEncoding
]
]
;
[
req
setHTTPBody
:
postBody
]
;
[
req
setHTTPMethod
:
"
POST
"
]
;
[
response_
release
]
;
response_
=
nil
;
NSData
*
data
=
nil
;
if
(
[
[
req
URL
]
isFileURL
]
)
{
[
[
req
HTTPBody
]
writeToURL
:
[
req
URL
]
options
:
0
error
:
error
]
;
}
else
{
NSURLResponse
*
response
=
nil
;
data
=
SendSynchronousNSURLRequest
(
req
&
response
error
)
;
response_
=
(
NSHTTPURLResponse
*
)
[
response
retain
]
;
}
[
req
release
]
;
return
data
;
}
-
(
NSHTTPURLResponse
*
)
response
{
return
response_
;
}
end
