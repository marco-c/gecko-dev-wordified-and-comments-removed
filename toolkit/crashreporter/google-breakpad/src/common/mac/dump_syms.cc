#
include
"
common
/
mac
/
dump_syms
.
h
"
#
include
<
assert
.
h
>
#
include
<
dirent
.
h
>
#
include
<
errno
.
h
>
#
include
<
libgen
.
h
>
#
include
<
mach
-
o
/
arch
.
h
>
#
include
<
mach
-
o
/
fat
.
h
>
#
include
<
stdio
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
unistd
.
h
>
#
include
<
ostream
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
common
/
dwarf
/
bytereader
-
inl
.
h
"
#
include
"
common
/
dwarf
/
dwarf2reader
.
h
"
#
include
"
common
/
dwarf_cfi_to_module
.
h
"
#
include
"
common
/
dwarf_cu_to_module
.
h
"
#
include
"
common
/
dwarf_line_to_module
.
h
"
#
include
"
common
/
mac
/
file_id
.
h
"
#
include
"
common
/
mac
/
arch_utilities
.
h
"
#
include
"
common
/
mac
/
macho_reader
.
h
"
#
include
"
common
/
module
.
h
"
#
include
"
common
/
scoped_ptr
.
h
"
#
include
"
common
/
stabs_reader
.
h
"
#
include
"
common
/
stabs_to_module
.
h
"
#
include
"
common
/
symbol_data
.
h
"
#
ifndef
CPU_TYPE_ARM
#
define
CPU_TYPE_ARM
(
static_cast
<
cpu_type_t
>
(
12
)
)
#
endif
#
ifndef
CPU_TYPE_ARM64
#
define
CPU_TYPE_ARM64
(
static_cast
<
cpu_type_t
>
(
16777228
)
)
#
endif
using
dwarf2reader
:
:
ByteReader
;
using
google_breakpad
:
:
DwarfCUToModule
;
using
google_breakpad
:
:
DwarfLineToModule
;
using
google_breakpad
:
:
FileID
;
using
google_breakpad
:
:
mach_o
:
:
FatReader
;
using
google_breakpad
:
:
mach_o
:
:
Section
;
using
google_breakpad
:
:
mach_o
:
:
Segment
;
using
google_breakpad
:
:
Module
;
using
google_breakpad
:
:
StabsReader
;
using
google_breakpad
:
:
StabsToModule
;
using
google_breakpad
:
:
scoped_ptr
;
using
std
:
:
make_pair
;
using
std
:
:
pair
;
using
std
:
:
string
;
using
std
:
:
vector
;
namespace
{
vector
<
string
>
list_directory
(
const
string
&
directory
)
{
vector
<
string
>
entries
;
DIR
*
dir
=
opendir
(
directory
.
c_str
(
)
)
;
if
(
!
dir
)
{
return
entries
;
}
string
path
=
directory
;
if
(
path
[
path
.
length
(
)
-
1
]
!
=
'
/
'
)
{
path
+
=
'
/
'
;
}
struct
dirent
*
entry
=
NULL
;
while
(
(
entry
=
readdir
(
dir
)
)
)
{
if
(
strcmp
(
entry
-
>
d_name
"
.
"
)
!
=
0
&
&
strcmp
(
entry
-
>
d_name
"
.
.
"
)
!
=
0
)
{
entries
.
push_back
(
path
+
entry
-
>
d_name
)
;
}
}
closedir
(
dir
)
;
return
entries
;
}
}
namespace
google_breakpad
{
bool
DumpSymbols
:
:
Read
(
const
string
&
filename
)
{
struct
stat
st
;
if
(
stat
(
filename
.
c_str
(
)
&
st
)
=
=
-
1
)
{
fprintf
(
stderr
"
Could
not
access
object
file
%
s
:
%
s
\
n
"
filename
.
c_str
(
)
strerror
(
errno
)
)
;
return
false
;
}
input_pathname_
=
filename
;
string
contents_path
=
input_pathname_
+
"
/
Contents
/
Resources
/
DWARF
"
;
if
(
S_ISDIR
(
st
.
st_mode
)
&
&
access
(
contents_path
.
c_str
(
)
F_OK
)
=
=
0
)
{
const
vector
<
string
>
entries
=
list_directory
(
contents_path
)
;
if
(
entries
.
size
(
)
=
=
0
)
{
fprintf
(
stderr
"
Unable
to
find
DWARF
-
bearing
file
in
bundle
:
%
s
\
n
"
input_pathname_
.
c_str
(
)
)
;
return
false
;
}
if
(
entries
.
size
(
)
>
1
)
{
fprintf
(
stderr
"
Too
many
DWARF
files
in
bundle
:
%
s
\
n
"
input_pathname_
.
c_str
(
)
)
;
return
false
;
}
object_filename_
=
entries
[
0
]
;
}
else
{
object_filename_
=
input_pathname_
;
}
bool
read_ok
=
true
;
string
error
;
if
(
stat
(
object_filename_
.
c_str
(
)
&
st
)
!
=
-
1
)
{
FILE
*
f
=
fopen
(
object_filename_
.
c_str
(
)
"
rb
"
)
;
if
(
f
)
{
contents_
.
reset
(
new
uint8_t
[
st
.
st_size
]
)
;
off_t
total
=
0
;
while
(
total
<
st
.
st_size
&
&
!
feof
(
f
)
)
{
size_t
read
=
fread
(
&
contents_
[
0
]
+
total
1
st
.
st_size
-
total
f
)
;
if
(
read
=
=
0
)
{
if
(
ferror
(
f
)
)
{
read_ok
=
false
;
error
=
strerror
(
errno
)
;
}
break
;
}
total
+
=
read
;
}
fclose
(
f
)
;
}
else
{
error
=
strerror
(
errno
)
;
}
}
if
(
!
read_ok
)
{
fprintf
(
stderr
"
Error
reading
object
file
:
%
s
:
%
s
\
n
"
object_filename_
.
c_str
(
)
error
.
c_str
(
)
)
;
return
false
;
}
FatReader
:
:
Reporter
fat_reporter
(
object_filename_
)
;
FatReader
fat_reader
(
&
fat_reporter
)
;
if
(
!
fat_reader
.
Read
(
&
contents_
[
0
]
st
.
st_size
)
)
{
return
false
;
}
size_t
object_files_count
;
const
SuperFatArch
*
object_files
=
fat_reader
.
object_files
(
&
object_files_count
)
;
if
(
object_files_count
=
=
0
)
{
fprintf
(
stderr
"
Fat
binary
file
contains
*
no
*
architectures
:
%
s
\
n
"
object_filename_
.
c_str
(
)
)
;
return
false
;
}
object_files_
.
resize
(
object_files_count
)
;
memcpy
(
&
object_files_
[
0
]
object_files
sizeof
(
SuperFatArch
)
*
object_files_count
)
;
return
true
;
}
bool
DumpSymbols
:
:
SetArchitecture
(
cpu_type_t
cpu_type
cpu_subtype_t
cpu_subtype
)
{
const
SuperFatArch
*
best_match
=
FindBestMatchForArchitecture
(
cpu_type
cpu_subtype
)
;
if
(
!
best_match
)
return
false
;
selected_object_file_
=
best_match
;
return
true
;
}
bool
DumpSymbols
:
:
SetArchitecture
(
const
std
:
:
string
&
arch_name
)
{
bool
arch_set
=
false
;
const
NXArchInfo
*
arch_info
=
google_breakpad
:
:
BreakpadGetArchInfoFromName
(
arch_name
.
c_str
(
)
)
;
if
(
arch_info
)
{
arch_set
=
SetArchitecture
(
arch_info
-
>
cputype
arch_info
-
>
cpusubtype
)
;
}
return
arch_set
;
}
SuperFatArch
*
DumpSymbols
:
:
FindBestMatchForArchitecture
(
cpu_type_t
cpu_type
cpu_subtype_t
cpu_subtype
)
{
bool
can_convert_to_fat_arch
=
true
;
vector
<
struct
fat_arch
>
fat_arch_vector
;
for
(
vector
<
SuperFatArch
>
:
:
const_iterator
it
=
object_files_
.
begin
(
)
;
it
!
=
object_files_
.
end
(
)
;
+
+
it
)
{
struct
fat_arch
arch
;
bool
success
=
it
-
>
ConvertToFatArch
(
&
arch
)
;
if
(
!
success
)
{
can_convert_to_fat_arch
=
false
;
break
;
}
fat_arch_vector
.
push_back
(
arch
)
;
}
if
(
can_convert_to_fat_arch
)
{
const
struct
fat_arch
*
best_match
=
NXFindBestFatArch
(
cpu_type
cpu_subtype
&
fat_arch_vector
[
0
]
static_cast
<
uint32_t
>
(
fat_arch_vector
.
size
(
)
)
)
;
for
(
size_t
i
=
0
;
i
<
fat_arch_vector
.
size
(
)
;
+
+
i
)
{
if
(
best_match
=
=
&
fat_arch_vector
[
i
]
)
return
&
object_files_
[
i
]
;
}
assert
(
best_match
=
=
NULL
)
;
return
NULL
;
}
for
(
vector
<
SuperFatArch
>
:
:
iterator
it
=
object_files_
.
begin
(
)
;
it
!
=
object_files_
.
end
(
)
;
+
+
it
)
{
if
(
static_cast
<
cpu_type_t
>
(
it
-
>
cputype
)
=
=
cpu_type
&
&
static_cast
<
cpu_subtype_t
>
(
it
-
>
cpusubtype
)
=
=
cpu_subtype
)
return
&
*
it
;
}
fprintf
(
stderr
"
Failed
to
find
an
exact
match
for
an
object
file
with
cpu
"
"
type
:
%
d
and
cpu
subtype
:
%
d
.
Furthermore
at
least
one
object
file
is
"
"
larger
than
2
*
*
32
.
\
n
"
cpu_type
cpu_subtype
)
;
return
NULL
;
}
string
DumpSymbols
:
:
Identifier
(
)
{
FileID
file_id
(
object_filename_
.
c_str
(
)
)
;
unsigned
char
identifier_bytes
[
16
]
;
cpu_type_t
cpu_type
=
selected_object_file_
-
>
cputype
;
cpu_subtype_t
cpu_subtype
=
selected_object_file_
-
>
cpusubtype
;
if
(
!
file_id
.
MachoIdentifier
(
cpu_type
cpu_subtype
identifier_bytes
)
)
{
fprintf
(
stderr
"
Unable
to
calculate
UUID
of
mach
-
o
binary
%
s
!
\
n
"
object_filename_
.
c_str
(
)
)
;
return
"
"
;
}
char
identifier_string
[
40
]
;
FileID
:
:
ConvertIdentifierToString
(
identifier_bytes
identifier_string
sizeof
(
identifier_string
)
)
;
string
compacted
(
identifier_string
)
;
for
(
size_t
i
=
compacted
.
find
(
'
-
'
)
;
i
!
=
string
:
:
npos
;
i
=
compacted
.
find
(
'
-
'
i
)
)
compacted
.
erase
(
i
1
)
;
return
compacted
;
}
class
DumpSymbols
:
:
DumperLineToModule
:
public
DwarfCUToModule
:
:
LineToModuleHandler
{
public
:
DumperLineToModule
(
dwarf2reader
:
:
ByteReader
*
byte_reader
)
:
byte_reader_
(
byte_reader
)
{
}
void
StartCompilationUnit
(
const
string
&
compilation_dir
)
{
compilation_dir_
=
compilation_dir
;
}
void
ReadProgram
(
const
char
*
program
uint64
length
Module
*
module
vector
<
Module
:
:
Line
>
*
lines
)
{
DwarfLineToModule
handler
(
module
compilation_dir_
lines
)
;
dwarf2reader
:
:
LineInfo
parser
(
program
length
byte_reader_
&
handler
)
;
parser
.
Start
(
)
;
}
private
:
string
compilation_dir_
;
dwarf2reader
:
:
ByteReader
*
byte_reader_
;
}
;
bool
DumpSymbols
:
:
ReadDwarf
(
google_breakpad
:
:
Module
*
module
const
mach_o
:
:
Reader
&
macho_reader
const
mach_o
:
:
SectionMap
&
dwarf_sections
bool
handle_inter_cu_refs
)
const
{
ByteReader
byte_reader
(
macho_reader
.
big_endian
(
)
?
dwarf2reader
:
:
ENDIANNESS_BIG
:
dwarf2reader
:
:
ENDIANNESS_LITTLE
)
;
DwarfCUToModule
:
:
FileContext
file_context
(
selected_object_name_
module
handle_inter_cu_refs
)
;
for
(
mach_o
:
:
SectionMap
:
:
const_iterator
it
=
dwarf_sections
.
begin
(
)
;
it
!
=
dwarf_sections
.
end
(
)
;
+
+
it
)
{
file_context
.
AddSectionToSectionMap
(
it
-
>
first
reinterpret_cast
<
const
char
*
>
(
it
-
>
second
.
contents
.
start
)
it
-
>
second
.
contents
.
Size
(
)
)
;
}
dwarf2reader
:
:
SectionMap
:
:
const_iterator
debug_info_entry
=
file_context
.
section_map
(
)
.
find
(
"
__debug_info
"
)
;
assert
(
debug_info_entry
!
=
file_context
.
section_map
(
)
.
end
(
)
)
;
const
std
:
:
pair
<
const
char
*
uint64
>
&
debug_info_section
=
debug_info_entry
-
>
second
;
if
(
!
debug_info_section
.
first
)
{
fprintf
(
stderr
"
%
s
:
__DWARF
segment
of
file
has
no
__debug_info
section
\
n
"
selected_object_name_
.
c_str
(
)
)
;
return
false
;
}
DumperLineToModule
line_to_module
(
&
byte_reader
)
;
uint64
debug_info_length
=
debug_info_section
.
second
;
for
(
uint64
offset
=
0
;
offset
<
debug_info_length
;
)
{
DwarfCUToModule
:
:
WarningReporter
reporter
(
selected_object_name_
offset
)
;
DwarfCUToModule
root_handler
(
&
file_context
&
line_to_module
&
reporter
)
;
dwarf2reader
:
:
DIEDispatcher
die_dispatcher
(
&
root_handler
)
;
dwarf2reader
:
:
CompilationUnit
dwarf_reader
(
file_context
.
section_map
(
)
offset
&
byte_reader
&
die_dispatcher
)
;
offset
+
=
dwarf_reader
.
Start
(
)
;
}
return
true
;
}
bool
DumpSymbols
:
:
ReadCFI
(
google_breakpad
:
:
Module
*
module
const
mach_o
:
:
Reader
&
macho_reader
const
mach_o
:
:
Section
&
section
bool
eh_frame
)
const
{
vector
<
string
>
register_names
;
switch
(
macho_reader
.
cpu_type
(
)
)
{
case
CPU_TYPE_X86
:
register_names
=
DwarfCFIToModule
:
:
RegisterNames
:
:
I386
(
)
;
break
;
case
CPU_TYPE_X86_64
:
register_names
=
DwarfCFIToModule
:
:
RegisterNames
:
:
X86_64
(
)
;
break
;
case
CPU_TYPE_ARM
:
register_names
=
DwarfCFIToModule
:
:
RegisterNames
:
:
ARM
(
)
;
break
;
case
CPU_TYPE_ARM64
:
register_names
=
DwarfCFIToModule
:
:
RegisterNames
:
:
ARM64
(
)
;
break
;
default
:
{
const
NXArchInfo
*
arch
=
google_breakpad
:
:
BreakpadGetArchInfoFromCpuType
(
macho_reader
.
cpu_type
(
)
macho_reader
.
cpu_subtype
(
)
)
;
fprintf
(
stderr
"
%
s
:
cannot
convert
DWARF
call
frame
information
for
"
selected_object_name_
.
c_str
(
)
)
;
if
(
arch
)
fprintf
(
stderr
"
architecture
'
%
s
'
"
arch
-
>
name
)
;
else
fprintf
(
stderr
"
architecture
%
d
%
d
"
macho_reader
.
cpu_type
(
)
macho_reader
.
cpu_subtype
(
)
)
;
fprintf
(
stderr
"
to
Breakpad
symbol
file
:
no
register
name
table
\
n
"
)
;
return
false
;
}
}
const
char
*
cfi
=
reinterpret_cast
<
const
char
*
>
(
section
.
contents
.
start
)
;
size_t
cfi_size
=
section
.
contents
.
Size
(
)
;
DwarfCFIToModule
:
:
Reporter
module_reporter
(
selected_object_name_
section
.
section_name
)
;
DwarfCFIToModule
handler
(
module
register_names
&
module_reporter
)
;
dwarf2reader
:
:
ByteReader
byte_reader
(
macho_reader
.
big_endian
(
)
?
dwarf2reader
:
:
ENDIANNESS_BIG
:
dwarf2reader
:
:
ENDIANNESS_LITTLE
)
;
byte_reader
.
SetAddressSize
(
macho_reader
.
bits_64
(
)
?
8
:
4
)
;
byte_reader
.
SetCFIDataBase
(
section
.
address
cfi
)
;
dwarf2reader
:
:
CallFrameInfo
:
:
Reporter
dwarf_reporter
(
selected_object_name_
section
.
section_name
)
;
dwarf2reader
:
:
CallFrameInfo
parser
(
cfi
cfi_size
&
byte_reader
&
handler
&
dwarf_reporter
eh_frame
)
;
parser
.
Start
(
)
;
return
true
;
}
class
DumpSymbols
:
:
LoadCommandDumper
:
public
mach_o
:
:
Reader
:
:
LoadCommandHandler
{
public
:
LoadCommandDumper
(
const
DumpSymbols
&
dumper
google_breakpad
:
:
Module
*
module
const
mach_o
:
:
Reader
&
reader
SymbolData
symbol_data
bool
handle_inter_cu_refs
)
:
dumper_
(
dumper
)
module_
(
module
)
reader_
(
reader
)
symbol_data_
(
symbol_data
)
handle_inter_cu_refs_
(
handle_inter_cu_refs
)
{
}
bool
SegmentCommand
(
const
mach_o
:
:
Segment
&
segment
)
;
bool
SymtabCommand
(
const
ByteBuffer
&
entries
const
ByteBuffer
&
strings
)
;
private
:
const
DumpSymbols
&
dumper_
;
google_breakpad
:
:
Module
*
module_
;
const
mach_o
:
:
Reader
&
reader_
;
const
SymbolData
symbol_data_
;
const
bool
handle_inter_cu_refs_
;
}
;
bool
DumpSymbols
:
:
LoadCommandDumper
:
:
SegmentCommand
(
const
Segment
&
segment
)
{
mach_o
:
:
SectionMap
section_map
;
if
(
!
reader_
.
MapSegmentSections
(
segment
&
section_map
)
)
return
false
;
if
(
segment
.
name
=
=
"
__TEXT
"
)
{
module_
-
>
SetLoadAddress
(
segment
.
vmaddr
)
;
if
(
symbol_data_
!
=
NO_CFI
)
{
mach_o
:
:
SectionMap
:
:
const_iterator
eh_frame
=
section_map
.
find
(
"
__eh_frame
"
)
;
if
(
eh_frame
!
=
section_map
.
end
(
)
)
{
dumper_
.
ReadCFI
(
module_
reader_
eh_frame
-
>
second
true
)
;
}
}
return
true
;
}
if
(
segment
.
name
=
=
"
__DWARF
"
)
{
if
(
symbol_data_
!
=
ONLY_CFI
)
{
if
(
!
dumper_
.
ReadDwarf
(
module_
reader_
section_map
handle_inter_cu_refs_
)
)
{
return
false
;
}
}
if
(
symbol_data_
!
=
NO_CFI
)
{
mach_o
:
:
SectionMap
:
:
const_iterator
debug_frame
=
section_map
.
find
(
"
__debug_frame
"
)
;
if
(
debug_frame
!
=
section_map
.
end
(
)
)
{
dumper_
.
ReadCFI
(
module_
reader_
debug_frame
-
>
second
false
)
;
}
}
}
return
true
;
}
bool
DumpSymbols
:
:
LoadCommandDumper
:
:
SymtabCommand
(
const
ByteBuffer
&
entries
const
ByteBuffer
&
strings
)
{
StabsToModule
stabs_to_module
(
module_
)
;
StabsReader
stabs_reader
(
entries
.
start
entries
.
Size
(
)
strings
.
start
strings
.
Size
(
)
reader_
.
big_endian
(
)
reader_
.
bits_64
(
)
?
8
:
4
true
&
stabs_to_module
)
;
if
(
!
stabs_reader
.
Process
(
)
)
return
false
;
stabs_to_module
.
Finalize
(
)
;
return
true
;
}
bool
DumpSymbols
:
:
ReadSymbolData
(
Module
*
*
out_module
)
{
if
(
!
selected_object_file_
)
{
if
(
object_files_
.
size
(
)
=
=
1
)
selected_object_file_
=
&
object_files_
[
0
]
;
else
{
const
NXArchInfo
*
local_arch
=
NXGetLocalArchInfo
(
)
;
if
(
!
SetArchitecture
(
local_arch
-
>
cputype
local_arch
-
>
cpusubtype
)
)
{
fprintf
(
stderr
"
%
s
:
object
file
contains
more
than
one
"
"
architecture
none
of
which
match
the
current
"
"
architecture
;
specify
an
architecture
explicitly
"
"
with
'
-
a
ARCH
'
to
resolve
the
ambiguity
\
n
"
object_filename_
.
c_str
(
)
)
;
return
false
;
}
}
}
assert
(
selected_object_file_
)
;
const
NXArchInfo
*
selected_arch_info
=
google_breakpad
:
:
BreakpadGetArchInfoFromCpuType
(
selected_object_file_
-
>
cputype
selected_object_file_
-
>
cpusubtype
)
;
const
char
*
selected_arch_name
=
selected_arch_info
-
>
name
;
if
(
strcmp
(
selected_arch_name
"
i386
"
)
=
=
0
)
selected_arch_name
=
"
x86
"
;
selected_object_name_
=
object_filename_
;
if
(
object_files_
.
size
(
)
>
1
)
{
selected_object_name_
+
=
"
architecture
"
;
selected_object_name_
+
selected_arch_name
;
}
string
module_name
=
object_filename_
;
module_name
=
basename
(
&
module_name
[
0
]
)
;
string
identifier
=
Identifier
(
)
;
if
(
identifier
.
empty
(
)
)
return
false
;
identifier
+
=
"
0
"
;
scoped_ptr
<
Module
>
module
(
new
Module
(
module_name
"
mac
"
selected_arch_name
identifier
)
)
;
mach_o
:
:
Reader
:
:
Reporter
reporter
(
selected_object_name_
)
;
mach_o
:
:
Reader
reader
(
&
reporter
)
;
if
(
!
reader
.
Read
(
&
contents_
[
0
]
+
selected_object_file_
-
>
offset
selected_object_file_
-
>
size
selected_object_file_
-
>
cputype
selected_object_file_
-
>
cpusubtype
)
)
return
false
;
LoadCommandDumper
load_command_dumper
(
*
this
module
.
get
(
)
reader
symbol_data_
handle_inter_cu_refs_
)
;
if
(
!
reader
.
WalkLoadCommands
(
&
load_command_dumper
)
)
return
false
;
*
out_module
=
module
.
release
(
)
;
return
true
;
}
bool
DumpSymbols
:
:
WriteSymbolFile
(
std
:
:
ostream
&
stream
)
{
Module
*
module
=
NULL
;
if
(
ReadSymbolData
(
&
module
)
&
&
module
)
{
bool
res
=
module
-
>
Write
(
stream
symbol_data_
)
;
delete
module
;
return
res
;
}
return
false
;
}
}
