#
include
"
common
/
linux
/
memory_mapped_file
.
h
"
#
include
<
fcntl
.
h
>
#
include
<
sys
/
mman
.
h
>
#
if
defined
(
__ANDROID__
)
#
include
<
sys
/
stat
.
h
>
#
endif
#
include
<
unistd
.
h
>
#
include
"
common
/
memory_range
.
h
"
#
include
"
third_party
/
lss
/
linux_syscall_support
.
h
"
namespace
google_breakpad
{
MemoryMappedFile
:
:
MemoryMappedFile
(
)
{
}
MemoryMappedFile
:
:
MemoryMappedFile
(
const
char
*
path
size_t
offset
)
{
Map
(
path
offset
)
;
}
MemoryMappedFile
:
:
~
MemoryMappedFile
(
)
{
Unmap
(
)
;
}
#
include
<
unistd
.
h
>
bool
MemoryMappedFile
:
:
Map
(
const
char
*
path
size_t
offset
)
{
Unmap
(
)
;
int
fd
=
sys_open
(
path
O_RDONLY
0
)
;
if
(
fd
=
=
-
1
)
{
return
false
;
}
#
if
defined
(
__x86_64__
)
|
|
defined
(
__aarch64__
)
|
|
\
(
defined
(
__mips__
)
&
&
_MIPS_SIM
=
=
_ABI64
)
struct
kernel_stat
st
;
if
(
sys_fstat
(
fd
&
st
)
=
=
-
1
|
|
st
.
st_size
<
0
)
{
#
else
struct
kernel_stat64
st
;
if
(
sys_fstat64
(
fd
&
st
)
=
=
-
1
|
|
st
.
st_size
<
0
)
{
#
endif
sys_close
(
fd
)
;
return
false
;
}
size_t
file_len
=
static_cast
<
size_t
>
(
st
.
st_size
)
;
if
(
offset
>
=
file_len
)
{
sys_close
(
fd
)
;
return
true
;
}
#
if
defined
(
__x86_64__
)
|
|
defined
(
__aarch64__
)
|
|
\
(
defined
(
__mips__
)
&
&
_MIPS_SIM
=
=
_ABI64
)
void
*
data
=
sys_mmap
(
NULL
file_len
PROT_READ
MAP_PRIVATE
fd
offset
)
;
#
else
if
(
(
offset
&
4095
)
!
=
0
)
{
sys_close
(
fd
)
;
return
false
;
}
void
*
data
=
sys_mmap2
(
NULL
file_len
PROT_READ
MAP_PRIVATE
fd
offset
>
>
12
)
;
#
endif
sys_close
(
fd
)
;
if
(
data
=
=
MAP_FAILED
)
{
return
false
;
}
content_
.
Set
(
data
file_len
-
offset
)
;
return
true
;
}
void
MemoryMappedFile
:
:
Unmap
(
)
{
if
(
content_
.
data
(
)
)
{
sys_munmap
(
const_cast
<
uint8_t
*
>
(
content_
.
data
(
)
)
content_
.
length
(
)
)
;
content_
.
Set
(
NULL
0
)
;
}
}
}
