#
include
"
common
/
linux
/
file_id
.
h
"
#
include
<
arpa
/
inet
.
h
>
#
include
<
assert
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
string
>
#
include
"
common
/
linux
/
elf_gnu_compat
.
h
"
#
include
"
common
/
linux
/
elfutils
.
h
"
#
include
"
common
/
linux
/
linux_libc_support
.
h
"
#
include
"
common
/
linux
/
memory_mapped_file
.
h
"
#
include
"
common
/
using_std_string
.
h
"
#
include
"
third_party
/
lss
/
linux_syscall_support
.
h
"
namespace
google_breakpad
{
const
size_t
kMDGUIDSize
=
sizeof
(
MDGUID
)
;
FileID
:
:
FileID
(
const
char
*
path
)
:
path_
(
path
)
{
}
#
define
NOTE_PADDING
(
a
)
(
(
a
+
3
)
&
~
3
)
template
<
typename
ElfClass
>
static
bool
ElfClassBuildIDNoteIdentifier
(
const
void
*
section
size_t
length
wasteful_vector
<
uint8_t
>
&
identifier
)
{
typedef
typename
ElfClass
:
:
Nhdr
Nhdr
;
const
void
*
section_end
=
reinterpret_cast
<
const
char
*
>
(
section
)
+
length
;
const
Nhdr
*
note_header
=
reinterpret_cast
<
const
Nhdr
*
>
(
section
)
;
while
(
reinterpret_cast
<
const
void
*
>
(
note_header
)
<
section_end
)
{
if
(
note_header
-
>
n_type
=
=
NT_GNU_BUILD_ID
)
break
;
note_header
=
reinterpret_cast
<
const
Nhdr
*
>
(
reinterpret_cast
<
const
char
*
>
(
note_header
)
+
sizeof
(
Nhdr
)
+
NOTE_PADDING
(
note_header
-
>
n_namesz
)
+
NOTE_PADDING
(
note_header
-
>
n_descsz
)
)
;
}
if
(
reinterpret_cast
<
const
void
*
>
(
note_header
)
>
=
section_end
|
|
note_header
-
>
n_descsz
=
=
0
)
{
return
false
;
}
const
uint8_t
*
build_id
=
reinterpret_cast
<
const
uint8_t
*
>
(
note_header
)
+
sizeof
(
Nhdr
)
+
NOTE_PADDING
(
note_header
-
>
n_namesz
)
;
identifier
.
insert
(
identifier
.
end
(
)
build_id
build_id
+
note_header
-
>
n_descsz
)
;
return
true
;
}
static
bool
FindElfBuildIDNote
(
const
void
*
elf_mapped_base
wasteful_vector
<
uint8_t
>
&
identifier
)
{
void
*
note_section
;
size_t
note_size
;
int
elfclass
;
if
(
(
!
FindElfSegment
(
elf_mapped_base
PT_NOTE
(
const
void
*
*
)
&
note_section
&
note_size
&
elfclass
)
|
|
note_size
=
=
0
)
&
&
(
!
FindElfSection
(
elf_mapped_base
"
.
note
.
gnu
.
build
-
id
"
SHT_NOTE
(
const
void
*
*
)
&
note_section
&
note_size
&
elfclass
)
|
|
note_size
=
=
0
)
)
{
return
false
;
}
if
(
elfclass
=
=
ELFCLASS32
)
{
return
ElfClassBuildIDNoteIdentifier
<
ElfClass32
>
(
note_section
note_size
identifier
)
;
}
else
if
(
elfclass
=
=
ELFCLASS64
)
{
return
ElfClassBuildIDNoteIdentifier
<
ElfClass64
>
(
note_section
note_size
identifier
)
;
}
return
false
;
}
static
bool
HashElfTextSection
(
const
void
*
elf_mapped_base
wasteful_vector
<
uint8_t
>
&
identifier
)
{
identifier
.
resize
(
kMDGUIDSize
)
;
void
*
text_section
;
size_t
text_size
;
if
(
!
FindElfSection
(
elf_mapped_base
"
.
text
"
SHT_PROGBITS
(
const
void
*
*
)
&
text_section
&
text_size
NULL
)
|
|
text_size
=
=
0
)
{
return
false
;
}
my_memset
(
&
identifier
[
0
]
0
kMDGUIDSize
)
;
const
uint8_t
*
ptr
=
reinterpret_cast
<
const
uint8_t
*
>
(
text_section
)
;
const
uint8_t
*
ptr_end
=
ptr
+
std
:
:
min
(
text_size
static_cast
<
size_t
>
(
4096
)
)
;
while
(
ptr
<
ptr_end
)
{
for
(
unsigned
i
=
0
;
i
<
kMDGUIDSize
;
i
+
+
)
identifier
[
i
]
^
=
ptr
[
i
]
;
ptr
+
=
kMDGUIDSize
;
}
return
true
;
}
bool
FileID
:
:
ElfFileIdentifierFromMappedFile
(
const
void
*
base
wasteful_vector
<
uint8_t
>
&
identifier
)
{
if
(
FindElfBuildIDNote
(
base
identifier
)
)
return
true
;
return
HashElfTextSection
(
base
identifier
)
;
}
bool
FileID
:
:
ElfFileIdentifier
(
wasteful_vector
<
uint8_t
>
&
identifier
)
{
MemoryMappedFile
mapped_file
(
path_
.
c_str
(
)
0
)
;
if
(
!
mapped_file
.
data
(
)
)
return
false
;
return
ElfFileIdentifierFromMappedFile
(
mapped_file
.
data
(
)
identifier
)
;
}
static
string
bytes_to_hex_string
(
const
uint8_t
*
bytes
size_t
count
)
{
string
result
;
for
(
unsigned
int
idx
=
0
;
idx
<
count
;
+
+
idx
)
{
char
buf
[
3
]
;
snprintf
(
buf
sizeof
(
buf
)
"
%
02X
"
bytes
[
idx
]
)
;
result
.
append
(
buf
)
;
}
return
result
;
}
string
FileID
:
:
ConvertIdentifierToUUIDString
(
const
wasteful_vector
<
uint8_t
>
&
identifier
)
{
uint8_t
identifier_swapped
[
kMDGUIDSize
]
=
{
0
}
;
memcpy
(
identifier_swapped
&
identifier
[
0
]
std
:
:
min
(
kMDGUIDSize
identifier
.
size
(
)
)
)
;
uint32_t
*
data1
=
reinterpret_cast
<
uint32_t
*
>
(
identifier_swapped
)
;
*
data1
=
htonl
(
*
data1
)
;
uint16_t
*
data2
=
reinterpret_cast
<
uint16_t
*
>
(
identifier_swapped
+
4
)
;
*
data2
=
htons
(
*
data2
)
;
uint16_t
*
data3
=
reinterpret_cast
<
uint16_t
*
>
(
identifier_swapped
+
6
)
;
*
data3
=
htons
(
*
data3
)
;
return
bytes_to_hex_string
(
identifier_swapped
kMDGUIDSize
)
;
}
string
FileID
:
:
ConvertIdentifierToString
(
const
wasteful_vector
<
uint8_t
>
&
identifier
)
{
return
bytes_to_hex_string
(
&
identifier
[
0
]
identifier
.
size
(
)
)
;
}
}
