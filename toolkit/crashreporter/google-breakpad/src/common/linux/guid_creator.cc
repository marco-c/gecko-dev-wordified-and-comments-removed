#
ifdef
HAVE_CONFIG_H
#
include
<
config
.
h
>
#
endif
#
include
"
common
/
linux
/
eintr_wrapper
.
h
"
#
include
"
common
/
linux
/
guid_creator
.
h
"
#
include
<
assert
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
pthread
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
#
if
defined
(
HAVE_SYS_RANDOM_H
)
#
include
<
sys
/
random
.
h
>
#
endif
class
GUIDGenerator
{
public
:
static
uint32_t
BytesToUInt32
(
const
uint8_t
bytes
[
]
)
{
return
(
(
uint32_t
)
bytes
[
0
]
|
(
(
uint32_t
)
bytes
[
1
]
<
<
8
)
|
(
(
uint32_t
)
bytes
[
2
]
<
<
16
)
|
(
(
uint32_t
)
bytes
[
3
]
<
<
24
)
)
;
}
static
void
UInt32ToBytes
(
uint8_t
bytes
[
]
uint32_t
n
)
{
bytes
[
0
]
=
n
&
0xff
;
bytes
[
1
]
=
(
n
>
>
8
)
&
0xff
;
bytes
[
2
]
=
(
n
>
>
16
)
&
0xff
;
bytes
[
3
]
=
(
n
>
>
24
)
&
0xff
;
}
static
bool
CreateGUID
(
GUID
*
guid
)
{
#
if
defined
(
HAVE_ARC4RANDOM
)
CreateGuidFromArc4Random
(
guid
)
;
#
else
bool
success
=
false
;
#
if
defined
(
HAVE_SYS_RANDOM_H
)
&
&
defined
(
HAVE_GETRANDOM
)
success
=
CreateGUIDFromGetrandom
(
guid
)
;
#
endif
if
(
!
success
)
{
success
=
CreateGUIDFromDevUrandom
(
guid
)
;
}
if
(
!
success
)
{
CreateGUIDFromRand
(
guid
)
;
success
=
true
;
}
#
endif
guid
-
>
data3
&
=
0x0fff
;
guid
-
>
data3
|
=
0x4000
;
guid
-
>
data4
[
0
]
&
=
0x3f
;
guid
-
>
data4
[
0
]
|
=
0x80
;
return
true
;
}
private
:
#
ifdef
HAVE_ARC4RANDOM
static
void
CreateGuidFromArc4Random
(
GUID
*
guid
)
{
char
*
buf
=
reinterpret_cast
<
char
*
>
(
guid
)
;
for
(
size_t
i
=
0
;
i
<
sizeof
(
GUID
)
;
i
+
=
sizeof
(
uint32_t
)
)
{
uint32_t
random_data
=
arc4random
(
)
;
memcpy
(
buf
+
i
&
random_data
sizeof
(
uint32_t
)
)
;
}
}
#
else
static
void
InitOnce
(
)
{
pthread_once
(
&
once_control
&
InitOnceImpl
)
;
}
static
void
InitOnceImpl
(
)
{
srand
(
time
(
NULL
)
|
(
(
uintptr_t
)
&
once_control
>
>
4
)
)
;
}
static
pthread_once_t
once_control
;
#
if
defined
(
HAVE_SYS_RANDOM_H
)
&
&
defined
(
HAVE_GETRANDOM
)
static
bool
CreateGUIDFromGetrandom
(
GUID
*
guid
)
{
char
*
buf
=
reinterpret_cast
<
char
*
>
(
guid
)
;
int
read_bytes
=
getrandom
(
buf
sizeof
(
GUID
)
GRND_NONBLOCK
)
;
return
(
read_bytes
=
=
static_cast
<
int
>
(
sizeof
(
GUID
)
)
)
;
}
#
endif
static
bool
CreateGUIDFromDevUrandom
(
GUID
*
guid
)
{
char
*
buf
=
reinterpret_cast
<
char
*
>
(
guid
)
;
int
fd
=
open
(
"
/
dev
/
urandom
"
O_RDONLY
|
O_CLOEXEC
)
;
if
(
fd
=
=
-
1
)
{
return
false
;
}
ssize_t
read_bytes
=
HANDLE_EINTR
(
read
(
fd
buf
sizeof
(
GUID
)
)
)
;
close
(
fd
)
;
return
(
read_bytes
=
=
static_cast
<
ssize_t
>
(
sizeof
(
GUID
)
)
)
;
}
static
void
CreateGUIDFromRand
(
GUID
*
guid
)
{
char
*
buf
=
reinterpret_cast
<
char
*
>
(
guid
)
;
InitOnce
(
)
;
for
(
size_t
i
=
0
;
i
<
sizeof
(
GUID
)
;
i
+
+
)
{
buf
[
i
]
=
rand
(
)
;
}
}
#
endif
}
;
#
ifndef
HAVE_ARC4RANDOM
pthread_once_t
GUIDGenerator
:
:
once_control
=
PTHREAD_ONCE_INIT
;
#
endif
bool
CreateGUID
(
GUID
*
guid
)
{
return
GUIDGenerator
:
:
CreateGUID
(
guid
)
;
}
bool
GUIDToString
(
const
GUID
*
guid
char
*
buf
int
buf_len
)
{
assert
(
buf_len
>
kGUIDStringLength
)
;
int
num
=
snprintf
(
buf
buf_len
kGUIDFormatString
guid
-
>
data1
guid
-
>
data2
guid
-
>
data3
GUIDGenerator
:
:
BytesToUInt32
(
&
(
guid
-
>
data4
[
0
]
)
)
GUIDGenerator
:
:
BytesToUInt32
(
&
(
guid
-
>
data4
[
4
]
)
)
)
;
if
(
num
!
=
kGUIDStringLength
)
return
false
;
buf
[
num
]
=
'
\
0
'
;
return
true
;
}
