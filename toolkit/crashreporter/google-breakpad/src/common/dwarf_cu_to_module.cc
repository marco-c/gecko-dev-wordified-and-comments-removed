#
ifndef
__STDC_FORMAT_MACROS
#
define
__STDC_FORMAT_MACROS
#
endif
#
include
"
common
/
dwarf_cu_to_module
.
h
"
#
include
<
assert
.
h
>
#
include
<
inttypes
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
algorithm
>
#
include
<
numeric
>
#
include
<
utility
>
#
include
"
common
/
dwarf_line_to_module
.
h
"
#
include
"
common
/
unordered
.
h
"
namespace
google_breakpad
{
using
std
:
:
accumulate
;
using
std
:
:
map
;
using
std
:
:
pair
;
using
std
:
:
sort
;
using
std
:
:
vector
;
struct
DwarfCUToModule
:
:
Specification
{
string
qualified_name
;
string
enclosing_name
;
string
unqualified_name
;
}
;
struct
AbstractOrigin
{
AbstractOrigin
(
)
:
name
(
)
{
}
explicit
AbstractOrigin
(
const
string
&
name
)
:
name
(
name
)
{
}
string
name
;
}
;
typedef
map
<
uint64
AbstractOrigin
>
AbstractOriginByOffset
;
struct
DwarfCUToModule
:
:
FilePrivate
{
unordered_set
<
string
>
common_strings
;
SpecificationByOffset
specifications
;
AbstractOriginByOffset
origins
;
struct
InlinedSubroutineRange
{
InlinedSubroutineRange
(
Module
:
:
Range
range
uint64
call_file
uint64
call_line
)
:
range_
(
range
)
call_file_
(
call_file
)
call_line_
(
call_line
)
{
}
Module
:
:
Range
range_
;
uint64
call_file_
call_line_
;
}
;
vector
<
InlinedSubroutineRange
>
inlined_ranges
;
}
;
DwarfCUToModule
:
:
FileContext
:
:
FileContext
(
const
string
&
filename
Module
*
module
bool
handle_inter_cu_refs
)
:
filename_
(
filename
)
module_
(
module
)
handle_inter_cu_refs_
(
handle_inter_cu_refs
)
file_private_
(
new
FilePrivate
(
)
)
{
}
DwarfCUToModule
:
:
FileContext
:
:
~
FileContext
(
)
{
}
void
DwarfCUToModule
:
:
FileContext
:
:
AddSectionToSectionMap
(
const
string
&
name
const
uint8_t
*
contents
uint64
length
)
{
section_map_
[
name
]
=
std
:
:
make_pair
(
contents
length
)
;
}
void
DwarfCUToModule
:
:
FileContext
:
:
ClearSectionMapForTest
(
)
{
section_map_
.
clear
(
)
;
}
const
dwarf2reader
:
:
SectionMap
&
DwarfCUToModule
:
:
FileContext
:
:
section_map
(
)
const
{
return
section_map_
;
}
void
DwarfCUToModule
:
:
FileContext
:
:
ClearSpecifications
(
)
{
if
(
!
handle_inter_cu_refs_
)
file_private_
-
>
specifications
.
clear
(
)
;
}
bool
DwarfCUToModule
:
:
FileContext
:
:
IsUnhandledInterCUReference
(
uint64
offset
uint64
compilation_unit_start
)
const
{
if
(
handle_inter_cu_refs_
)
return
false
;
return
offset
<
compilation_unit_start
;
}
struct
DwarfCUToModule
:
:
CUContext
{
CUContext
(
FileContext
*
file_context_arg
WarningReporter
*
reporter_arg
RangesHandler
*
ranges_handler_arg
)
:
file_context
(
file_context_arg
)
reporter
(
reporter_arg
)
ranges_handler
(
ranges_handler_arg
)
language
(
Language
:
:
CPlusPlus
)
low_pc
(
0
)
high_pc
(
0
)
ranges
(
0
)
{
}
~
CUContext
(
)
{
for
(
vector
<
Module
:
:
Function
*
>
:
:
iterator
it
=
functions
.
begin
(
)
;
it
!
=
functions
.
end
(
)
;
+
+
it
)
{
delete
*
it
;
}
}
;
FileContext
*
file_context
;
WarningReporter
*
reporter
;
RangesHandler
*
ranges_handler
;
const
Language
*
language
;
uint64
low_pc
;
uint64
high_pc
;
uint64
ranges
;
vector
<
Module
:
:
Function
*
>
functions
;
std
:
:
map
<
uint64_t
Module
:
:
Function
*
>
forward_ref_die_to_func
;
}
;
struct
DwarfCUToModule
:
:
DIEContext
{
string
name
;
}
;
class
DwarfCUToModule
:
:
GenericDIEHandler
:
public
dwarf2reader
:
:
DIEHandler
{
public
:
GenericDIEHandler
(
CUContext
*
cu_context
DIEContext
*
parent_context
uint64
offset
)
:
cu_context_
(
cu_context
)
parent_context_
(
parent_context
)
offset_
(
offset
)
declaration_
(
false
)
specification_
(
NULL
)
forward_ref_die_offset_
(
0
)
{
}
void
ProcessAttributeUnsigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
;
void
ProcessAttributeReference
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
;
void
ProcessAttributeString
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
const
string
&
data
)
;
protected
:
string
ComputeQualifiedName
(
)
;
CUContext
*
cu_context_
;
DIEContext
*
parent_context_
;
uint64
offset_
;
string
AddStringToPool
(
const
string
&
str
)
;
bool
declaration_
;
Specification
*
specification_
;
uint64_t
forward_ref_die_offset_
;
string
name_attribute_
;
string
demangled_name_
;
string
raw_name_
;
}
;
void
DwarfCUToModule
:
:
GenericDIEHandler
:
:
ProcessAttributeUnsigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_declaration
:
declaration_
=
(
data
!
=
0
)
;
break
;
default
:
break
;
}
}
void
DwarfCUToModule
:
:
GenericDIEHandler
:
:
ProcessAttributeReference
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_specification
:
{
FileContext
*
file_context
=
cu_context_
-
>
file_context
;
if
(
file_context
-
>
IsUnhandledInterCUReference
(
data
cu_context_
-
>
reporter
-
>
cu_offset
(
)
)
)
{
cu_context_
-
>
reporter
-
>
UnhandledInterCUReference
(
offset_
data
)
;
break
;
}
SpecificationByOffset
*
specifications
=
&
file_context
-
>
file_private_
-
>
specifications
;
SpecificationByOffset
:
:
iterator
spec
=
specifications
-
>
find
(
data
)
;
if
(
spec
!
=
specifications
-
>
end
(
)
)
{
specification_
=
&
spec
-
>
second
;
}
else
if
(
data
>
offset_
)
{
forward_ref_die_offset_
=
data
;
}
else
{
cu_context_
-
>
reporter
-
>
UnknownSpecification
(
offset_
data
)
;
}
break
;
}
default
:
break
;
}
}
string
DwarfCUToModule
:
:
GenericDIEHandler
:
:
AddStringToPool
(
const
string
&
str
)
{
pair
<
unordered_set
<
string
>
:
:
iterator
bool
>
result
=
cu_context_
-
>
file_context
-
>
file_private_
-
>
common_strings
.
insert
(
str
)
;
return
*
result
.
first
;
}
void
DwarfCUToModule
:
:
GenericDIEHandler
:
:
ProcessAttributeString
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
const
string
&
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_name
:
name_attribute_
=
AddStringToPool
(
data
)
;
break
;
case
dwarf2reader
:
:
DW_AT_MIPS_linkage_name
:
case
dwarf2reader
:
:
DW_AT_linkage_name
:
{
string
demangled
;
Language
:
:
DemangleResult
result
=
cu_context_
-
>
language
-
>
DemangleName
(
data
&
demangled
)
;
switch
(
result
)
{
case
Language
:
:
kDemangleSuccess
:
demangled_name_
=
AddStringToPool
(
demangled
)
;
break
;
case
Language
:
:
kDemangleFailure
:
cu_context_
-
>
reporter
-
>
DemangleError
(
data
)
;
case
Language
:
:
kDontDemangle
:
demangled_name_
.
clear
(
)
;
raw_name_
=
AddStringToPool
(
data
)
;
break
;
}
break
;
}
default
:
break
;
}
}
string
DwarfCUToModule
:
:
GenericDIEHandler
:
:
ComputeQualifiedName
(
)
{
const
string
*
qualified_name
=
NULL
;
if
(
!
demangled_name_
.
empty
(
)
)
{
qualified_name
=
&
demangled_name_
;
}
else
if
(
specification_
&
&
!
specification_
-
>
qualified_name
.
empty
(
)
)
{
qualified_name
=
&
specification_
-
>
qualified_name
;
}
const
string
*
unqualified_name
=
NULL
;
const
string
*
enclosing_name
;
if
(
!
qualified_name
)
{
if
(
!
name_attribute_
.
empty
(
)
)
unqualified_name
=
&
name_attribute_
;
else
if
(
specification_
)
unqualified_name
=
&
specification_
-
>
unqualified_name
;
else
if
(
!
raw_name_
.
empty
(
)
)
unqualified_name
=
&
raw_name_
;
if
(
specification_
)
enclosing_name
=
&
specification_
-
>
enclosing_name
;
else
enclosing_name
=
&
parent_context_
-
>
name
;
}
string
return_value
;
if
(
qualified_name
)
{
return_value
=
*
qualified_name
;
}
else
if
(
unqualified_name
&
&
enclosing_name
)
{
return_value
=
cu_context_
-
>
language
-
>
MakeQualifiedName
(
*
enclosing_name
*
unqualified_name
)
;
}
if
(
(
declaration_
&
&
qualified_name
)
|
|
(
unqualified_name
&
&
enclosing_name
)
)
{
Specification
spec
;
if
(
qualified_name
)
{
spec
.
qualified_name
=
*
qualified_name
;
}
else
{
spec
.
enclosing_name
=
*
enclosing_name
;
spec
.
unqualified_name
=
*
unqualified_name
;
}
cu_context_
-
>
file_context
-
>
file_private_
-
>
specifications
[
offset_
]
=
spec
;
}
return
return_value
;
}
class
DwarfCUToModule
:
:
InlinedSubroutineHandler
:
public
GenericDIEHandler
{
public
:
InlinedSubroutineHandler
(
CUContext
*
cu_context
DIEContext
*
parent_context
uint64
offset
)
:
GenericDIEHandler
(
cu_context
parent_context
offset
)
low_pc_
(
0
)
high_pc_
(
0
)
high_pc_form_
(
dwarf2reader
:
:
DW_FORM_addr
)
ranges_
(
0
)
call_file_
(
0
)
call_file_set_
(
false
)
call_line_
(
0
)
call_line_set_
(
false
)
{
}
void
ProcessAttributeUnsigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
;
bool
EndAttributes
(
)
;
private
:
uint64
low_pc_
high_pc_
;
DwarfForm
high_pc_form_
;
uint64
ranges_
;
uint64
call_file_
;
bool
call_file_set_
;
uint64
call_line_
;
bool
call_line_set_
;
}
;
void
DwarfCUToModule
:
:
InlinedSubroutineHandler
:
:
ProcessAttributeUnsigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_low_pc
:
low_pc_
=
data
;
break
;
case
dwarf2reader
:
:
DW_AT_high_pc
:
high_pc_form_
=
form
;
high_pc_
=
data
;
break
;
case
dwarf2reader
:
:
DW_AT_ranges
:
ranges_
=
data
;
break
;
case
dwarf2reader
:
:
DW_AT_call_file
:
call_file_
=
data
;
call_file_set_
=
true
;
break
;
case
dwarf2reader
:
:
DW_AT_call_line
:
call_line_
=
data
;
call_line_set_
=
true
;
break
;
default
:
GenericDIEHandler
:
:
ProcessAttributeUnsigned
(
attr
form
data
)
;
break
;
}
}
bool
DwarfCUToModule
:
:
InlinedSubroutineHandler
:
:
EndAttributes
(
)
{
const
bool
ignore_children
=
false
;
if
(
!
call_file_set_
|
|
!
call_line_set_
)
{
return
ignore_children
;
}
vector
<
Module
:
:
Range
>
ranges
;
if
(
!
ranges_
)
{
if
(
high_pc_form_
!
=
dwarf2reader
:
:
DW_FORM_addr
&
&
high_pc_form_
!
=
dwarf2reader
:
:
DW_FORM_GNU_addr_index
)
{
high_pc_
+
=
low_pc_
;
}
Module
:
:
Range
range
(
low_pc_
high_pc_
-
low_pc_
)
;
ranges
.
push_back
(
range
)
;
}
else
{
RangesHandler
*
ranges_handler
=
cu_context_
-
>
ranges_handler
;
if
(
ranges_handler
)
{
if
(
!
ranges_handler
-
>
ReadRanges
(
ranges_
cu_context_
-
>
low_pc
&
ranges
)
)
{
ranges
.
clear
(
)
;
cu_context_
-
>
reporter
-
>
MalformedRangeList
(
ranges_
)
;
}
}
else
{
cu_context_
-
>
reporter
-
>
MissingRanges
(
)
;
}
}
for
(
const
auto
&
range
:
ranges
)
{
if
(
range
.
size
>
0
)
{
FilePrivate
:
:
InlinedSubroutineRange
inline_range
(
range
call_file_
call_line_
)
;
cu_context_
-
>
file_context
-
>
file_private_
-
>
inlined_ranges
.
push_back
(
inline_range
)
;
}
}
return
ignore_children
;
}
class
DwarfCUToModule
:
:
LexicalBlockHandler
:
public
GenericDIEHandler
{
public
:
LexicalBlockHandler
(
CUContext
*
cu_context
DIEContext
*
parent_context
uint64
offset
)
:
GenericDIEHandler
(
cu_context
parent_context
offset
)
{
}
bool
EndAttributes
(
)
;
DIEHandler
*
FindChildHandler
(
uint64
offset
enum
DwarfTag
tag
)
;
}
;
bool
DwarfCUToModule
:
:
LexicalBlockHandler
:
:
EndAttributes
(
)
{
return
true
;
}
dwarf2reader
:
:
DIEHandler
*
DwarfCUToModule
:
:
LexicalBlockHandler
:
:
FindChildHandler
(
uint64
offset
enum
DwarfTag
tag
)
{
switch
(
tag
)
{
case
dwarf2reader
:
:
DW_TAG_inlined_subroutine
:
return
new
InlinedSubroutineHandler
(
cu_context_
parent_context_
offset
)
;
default
:
return
NULL
;
}
}
class
DwarfCUToModule
:
:
FuncHandler
:
public
GenericDIEHandler
{
public
:
FuncHandler
(
CUContext
*
cu_context
DIEContext
*
parent_context
uint64
offset
)
:
GenericDIEHandler
(
cu_context
parent_context
offset
)
low_pc_
(
0
)
high_pc_
(
0
)
high_pc_form_
(
dwarf2reader
:
:
DW_FORM_addr
)
ranges_
(
0
)
abstract_origin_
(
NULL
)
inline_
(
false
)
{
}
void
ProcessAttributeUnsigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
;
void
ProcessAttributeSigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
int64
data
)
;
void
ProcessAttributeReference
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
;
bool
EndAttributes
(
)
;
void
Finish
(
)
;
DIEHandler
*
FindChildHandler
(
uint64
offset
enum
DwarfTag
tag
)
;
private
:
string
name_
;
uint64
low_pc_
high_pc_
;
DwarfForm
high_pc_form_
;
uint64
ranges_
;
const
AbstractOrigin
*
abstract_origin_
;
bool
inline_
;
}
;
void
DwarfCUToModule
:
:
FuncHandler
:
:
ProcessAttributeUnsigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_inline
:
inline_
=
true
;
break
;
case
dwarf2reader
:
:
DW_AT_low_pc
:
low_pc_
=
data
;
break
;
case
dwarf2reader
:
:
DW_AT_high_pc
:
high_pc_form_
=
form
;
high_pc_
=
data
;
break
;
case
dwarf2reader
:
:
DW_AT_ranges
:
ranges_
=
data
;
break
;
default
:
GenericDIEHandler
:
:
ProcessAttributeUnsigned
(
attr
form
data
)
;
break
;
}
}
void
DwarfCUToModule
:
:
FuncHandler
:
:
ProcessAttributeSigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
int64
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_inline
:
inline_
=
true
;
break
;
default
:
break
;
}
}
void
DwarfCUToModule
:
:
FuncHandler
:
:
ProcessAttributeReference
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_abstract_origin
:
{
const
AbstractOriginByOffset
&
origins
=
cu_context_
-
>
file_context
-
>
file_private_
-
>
origins
;
AbstractOriginByOffset
:
:
const_iterator
origin
=
origins
.
find
(
data
)
;
if
(
origin
!
=
origins
.
end
(
)
)
{
abstract_origin_
=
&
(
origin
-
>
second
)
;
}
else
if
(
data
>
offset_
)
{
forward_ref_die_offset_
=
data
;
}
else
{
cu_context_
-
>
reporter
-
>
UnknownAbstractOrigin
(
offset_
data
)
;
}
break
;
}
default
:
GenericDIEHandler
:
:
ProcessAttributeReference
(
attr
form
data
)
;
break
;
}
}
bool
DwarfCUToModule
:
:
FuncHandler
:
:
EndAttributes
(
)
{
name_
=
ComputeQualifiedName
(
)
;
if
(
name_
.
empty
(
)
&
&
abstract_origin_
)
{
name_
=
abstract_origin_
-
>
name
;
}
return
true
;
}
static
bool
IsEmptyRange
(
const
vector
<
Module
:
:
Range
>
&
ranges
)
{
uint64
size
=
accumulate
(
ranges
.
cbegin
(
)
ranges
.
cend
(
)
0
[
]
(
uint64
total
Module
:
:
Range
entry
)
{
return
total
+
entry
.
size
;
}
)
;
return
size
=
=
0
;
}
void
DwarfCUToModule
:
:
FuncHandler
:
:
Finish
(
)
{
vector
<
Module
:
:
Range
>
ranges
;
if
(
!
name_
.
empty
(
)
)
{
auto
iter
=
cu_context_
-
>
forward_ref_die_to_func
.
find
(
offset_
)
;
if
(
iter
!
=
cu_context_
-
>
forward_ref_die_to_func
.
end
(
)
)
iter
-
>
second
-
>
name
=
name_
;
}
if
(
!
ranges_
)
{
if
(
high_pc_form_
!
=
dwarf2reader
:
:
DW_FORM_addr
&
&
high_pc_form_
!
=
dwarf2reader
:
:
DW_FORM_GNU_addr_index
)
{
high_pc_
+
=
low_pc_
;
}
Module
:
:
Range
range
(
low_pc_
high_pc_
-
low_pc_
)
;
ranges
.
push_back
(
range
)
;
}
else
{
RangesHandler
*
ranges_handler
=
cu_context_
-
>
ranges_handler
;
if
(
ranges_handler
)
{
if
(
!
ranges_handler
-
>
ReadRanges
(
ranges_
cu_context_
-
>
low_pc
&
ranges
)
)
{
ranges
.
clear
(
)
;
cu_context_
-
>
reporter
-
>
MalformedRangeList
(
ranges_
)
;
}
}
else
{
cu_context_
-
>
reporter
-
>
MissingRanges
(
)
;
}
}
if
(
!
IsEmptyRange
(
ranges
)
)
{
low_pc_
=
ranges
.
front
(
)
.
address
;
string
name
;
if
(
!
name_
.
empty
(
)
)
{
name
=
name_
;
}
else
{
if
(
forward_ref_die_offset_
=
=
0
)
cu_context_
-
>
reporter
-
>
UnnamedFunction
(
offset_
)
;
name
=
"
<
name
omitted
>
"
;
}
scoped_ptr
<
Module
:
:
Function
>
func
(
new
Module
:
:
Function
(
name
low_pc_
)
)
;
func
-
>
ranges
=
ranges
;
func
-
>
parameter_size
=
0
;
if
(
func
-
>
address
)
{
cu_context_
-
>
functions
.
push_back
(
func
.
release
(
)
)
;
if
(
forward_ref_die_offset_
!
=
0
)
{
auto
iter
=
cu_context_
-
>
forward_ref_die_to_func
.
find
(
forward_ref_die_offset_
)
;
if
(
iter
=
=
cu_context_
-
>
forward_ref_die_to_func
.
end
(
)
)
{
cu_context_
-
>
reporter
-
>
UnknownSpecification
(
offset_
forward_ref_die_offset_
)
;
}
else
{
iter
-
>
second
=
cu_context_
-
>
functions
.
back
(
)
;
}
}
}
}
else
if
(
inline_
)
{
AbstractOrigin
origin
(
name_
)
;
cu_context_
-
>
file_context
-
>
file_private_
-
>
origins
[
offset_
]
=
origin
;
}
}
dwarf2reader
:
:
DIEHandler
*
DwarfCUToModule
:
:
FuncHandler
:
:
FindChildHandler
(
uint64
offset
enum
DwarfTag
tag
)
{
switch
(
tag
)
{
case
dwarf2reader
:
:
DW_TAG_inlined_subroutine
:
return
new
InlinedSubroutineHandler
(
cu_context_
parent_context_
offset
)
;
case
dwarf2reader
:
:
DW_TAG_lexical_block
:
return
new
LexicalBlockHandler
(
cu_context_
parent_context_
offset
)
;
default
:
return
NULL
;
}
}
class
DwarfCUToModule
:
:
NamedScopeHandler
:
public
GenericDIEHandler
{
public
:
NamedScopeHandler
(
CUContext
*
cu_context
DIEContext
*
parent_context
uint64
offset
)
:
GenericDIEHandler
(
cu_context
parent_context
offset
)
{
}
bool
EndAttributes
(
)
;
DIEHandler
*
FindChildHandler
(
uint64
offset
enum
DwarfTag
tag
)
;
private
:
DIEContext
child_context_
;
}
;
bool
DwarfCUToModule
:
:
NamedScopeHandler
:
:
EndAttributes
(
)
{
child_context_
.
name
=
ComputeQualifiedName
(
)
;
return
true
;
}
dwarf2reader
:
:
DIEHandler
*
DwarfCUToModule
:
:
NamedScopeHandler
:
:
FindChildHandler
(
uint64
offset
enum
DwarfTag
tag
)
{
switch
(
tag
)
{
case
dwarf2reader
:
:
DW_TAG_subprogram
:
return
new
FuncHandler
(
cu_context_
&
child_context_
offset
)
;
case
dwarf2reader
:
:
DW_TAG_namespace
:
case
dwarf2reader
:
:
DW_TAG_class_type
:
case
dwarf2reader
:
:
DW_TAG_structure_type
:
case
dwarf2reader
:
:
DW_TAG_union_type
:
return
new
NamedScopeHandler
(
cu_context_
&
child_context_
offset
)
;
default
:
return
NULL
;
}
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
CUHeading
(
)
{
if
(
printed_cu_header_
)
return
;
fprintf
(
stderr
"
%
s
:
in
compilation
unit
'
%
s
'
(
offset
0x
%
llx
)
:
\
n
"
filename_
.
c_str
(
)
cu_name_
.
c_str
(
)
cu_offset_
)
;
printed_cu_header_
=
true
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
UnknownSpecification
(
uint64
offset
uint64
target
)
{
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
the
DIE
at
offset
0x
%
llx
has
a
DW_AT_specification
"
"
attribute
referring
to
the
DIE
at
offset
0x
%
llx
which
was
not
"
"
marked
as
a
declaration
\
n
"
filename_
.
c_str
(
)
offset
target
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
UnknownAbstractOrigin
(
uint64
offset
uint64
target
)
{
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
the
DIE
at
offset
0x
%
llx
has
a
DW_AT_abstract_origin
"
"
attribute
referring
to
the
DIE
at
offset
0x
%
llx
which
was
not
"
"
marked
as
an
inline
\
n
"
filename_
.
c_str
(
)
offset
target
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
MissingSection
(
const
string
&
name
)
{
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
warning
:
couldn
'
t
find
DWARF
'
%
s
'
section
\
n
"
filename_
.
c_str
(
)
name
.
c_str
(
)
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
BadLineInfoOffset
(
uint64
offset
)
{
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
warning
:
line
number
data
offset
beyond
end
"
"
of
'
.
debug_line
'
section
\
n
"
filename_
.
c_str
(
)
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
UncoveredHeading
(
)
{
if
(
printed_unpaired_header_
)
return
;
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
warning
:
skipping
unpaired
lines
/
functions
:
\
n
"
filename_
.
c_str
(
)
)
;
printed_unpaired_header_
=
true
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
UncoveredFunction
(
const
Module
:
:
Function
&
function
)
{
if
(
!
uncovered_warnings_enabled_
)
return
;
UncoveredHeading
(
)
;
fprintf
(
stderr
"
function
%
s
:
%
s
\
n
"
IsEmptyRange
(
function
.
ranges
)
?
"
(
zero
-
length
)
"
:
"
"
function
.
name
.
c_str
(
)
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
UncoveredLine
(
const
Module
:
:
Line
&
line
)
{
if
(
!
uncovered_warnings_enabled_
)
return
;
UncoveredHeading
(
)
;
fprintf
(
stderr
"
line
%
s
:
%
s
:
%
d
at
0x
%
"
PRIx64
"
\
n
"
(
line
.
size
=
=
0
?
"
(
zero
-
length
)
"
:
"
"
)
line
.
file
-
>
name
.
c_str
(
)
line
.
number
line
.
address
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
UnnamedFunction
(
uint64
offset
)
{
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
warning
:
function
at
offset
0x
%
llx
has
no
name
\
n
"
filename_
.
c_str
(
)
offset
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
DemangleError
(
const
string
&
input
)
{
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
warning
:
failed
to
demangle
%
s
\
n
"
filename_
.
c_str
(
)
input
.
c_str
(
)
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
UnhandledInterCUReference
(
uint64
offset
uint64
target
)
{
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
warning
:
the
DIE
at
offset
0x
%
llx
has
a
"
"
DW_FORM_ref_addr
attribute
with
an
inter
-
CU
reference
to
"
"
0x
%
llx
but
inter
-
CU
reference
handling
is
turned
off
.
\
n
"
filename_
.
c_str
(
)
offset
target
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
MalformedRangeList
(
uint64
offset
)
{
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
warning
:
the
range
list
at
offset
0x
%
llx
falls
out
of
"
"
the
.
debug_ranges
section
.
\
n
"
filename_
.
c_str
(
)
offset
)
;
}
void
DwarfCUToModule
:
:
WarningReporter
:
:
MissingRanges
(
)
{
CUHeading
(
)
;
fprintf
(
stderr
"
%
s
:
warning
:
A
DW_AT_ranges
attribute
was
encountered
but
"
"
the
.
debug_ranges
section
is
missing
.
\
n
"
filename_
.
c_str
(
)
)
;
}
DwarfCUToModule
:
:
DwarfCUToModule
(
FileContext
*
file_context
LineToModuleHandler
*
line_reader
RangesHandler
*
ranges_handler
WarningReporter
*
reporter
)
:
line_reader_
(
line_reader
)
cu_context_
(
new
CUContext
(
file_context
reporter
ranges_handler
)
)
child_context_
(
new
DIEContext
(
)
)
has_source_line_info_
(
false
)
{
}
DwarfCUToModule
:
:
~
DwarfCUToModule
(
)
{
}
void
DwarfCUToModule
:
:
ProcessAttributeSigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
int64
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_language
:
SetLanguage
(
static_cast
<
DwarfLanguage
>
(
data
)
)
;
break
;
default
:
break
;
}
}
void
DwarfCUToModule
:
:
ProcessAttributeUnsigned
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
uint64
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_stmt_list
:
has_source_line_info_
=
true
;
source_line_offset_
=
data
;
break
;
case
dwarf2reader
:
:
DW_AT_language
:
SetLanguage
(
static_cast
<
DwarfLanguage
>
(
data
)
)
;
break
;
case
dwarf2reader
:
:
DW_AT_low_pc
:
cu_context_
-
>
low_pc
=
data
;
break
;
case
dwarf2reader
:
:
DW_AT_high_pc
:
cu_context_
-
>
high_pc
=
data
;
break
;
case
dwarf2reader
:
:
DW_AT_ranges
:
cu_context_
-
>
ranges
=
data
;
break
;
default
:
break
;
}
}
void
DwarfCUToModule
:
:
ProcessAttributeString
(
enum
DwarfAttribute
attr
enum
DwarfForm
form
const
string
&
data
)
{
switch
(
attr
)
{
case
dwarf2reader
:
:
DW_AT_name
:
cu_context_
-
>
reporter
-
>
SetCUName
(
data
)
;
break
;
case
dwarf2reader
:
:
DW_AT_comp_dir
:
line_reader_
-
>
StartCompilationUnit
(
data
)
;
break
;
default
:
break
;
}
}
bool
DwarfCUToModule
:
:
EndAttributes
(
)
{
return
true
;
}
dwarf2reader
:
:
DIEHandler
*
DwarfCUToModule
:
:
FindChildHandler
(
uint64
offset
enum
DwarfTag
tag
)
{
switch
(
tag
)
{
case
dwarf2reader
:
:
DW_TAG_subprogram
:
return
new
FuncHandler
(
cu_context_
.
get
(
)
child_context_
.
get
(
)
offset
)
;
case
dwarf2reader
:
:
DW_TAG_namespace
:
case
dwarf2reader
:
:
DW_TAG_class_type
:
case
dwarf2reader
:
:
DW_TAG_structure_type
:
case
dwarf2reader
:
:
DW_TAG_union_type
:
case
dwarf2reader
:
:
DW_TAG_module
:
return
new
NamedScopeHandler
(
cu_context_
.
get
(
)
child_context_
.
get
(
)
offset
)
;
default
:
return
NULL
;
}
}
void
DwarfCUToModule
:
:
SetLanguage
(
DwarfLanguage
language
)
{
switch
(
language
)
{
case
dwarf2reader
:
:
DW_LANG_Java
:
cu_context_
-
>
language
=
Language
:
:
Java
;
break
;
case
dwarf2reader
:
:
DW_LANG_Swift
:
cu_context_
-
>
language
=
Language
:
:
Swift
;
break
;
case
dwarf2reader
:
:
DW_LANG_Rust
:
cu_context_
-
>
language
=
Language
:
:
Rust
;
break
;
case
dwarf2reader
:
:
DW_LANG_Mips_Assembler
:
cu_context_
-
>
language
=
Language
:
:
Assembler
;
break
;
default
:
case
dwarf2reader
:
:
DW_LANG_ObjC
:
case
dwarf2reader
:
:
DW_LANG_ObjC_plus_plus
:
case
dwarf2reader
:
:
DW_LANG_C
:
case
dwarf2reader
:
:
DW_LANG_C89
:
case
dwarf2reader
:
:
DW_LANG_C99
:
case
dwarf2reader
:
:
DW_LANG_C_plus_plus
:
cu_context_
-
>
language
=
Language
:
:
CPlusPlus
;
break
;
}
}
void
DwarfCUToModule
:
:
ReadSourceLines
(
uint64
offset
LineToModuleHandler
:
:
FileMap
*
files
)
{
const
dwarf2reader
:
:
SectionMap
&
section_map
=
cu_context_
-
>
file_context
-
>
section_map
(
)
;
dwarf2reader
:
:
SectionMap
:
:
const_iterator
map_entry
=
section_map
.
find
(
"
.
debug_line
"
)
;
if
(
map_entry
=
=
section_map
.
end
(
)
)
map_entry
=
section_map
.
find
(
"
__debug_line
"
)
;
if
(
map_entry
=
=
section_map
.
end
(
)
)
{
cu_context_
-
>
reporter
-
>
MissingSection
(
"
.
debug_line
"
)
;
return
;
}
const
uint8_t
*
section_start
=
map_entry
-
>
second
.
first
;
uint64
section_length
=
map_entry
-
>
second
.
second
;
if
(
offset
>
=
section_length
)
{
cu_context_
-
>
reporter
-
>
BadLineInfoOffset
(
offset
)
;
return
;
}
line_reader_
-
>
ReadProgram
(
section_start
+
offset
section_length
-
offset
cu_context_
-
>
file_context
-
>
module_
&
lines_
files
)
;
}
namespace
{
class
FunctionRange
{
public
:
FunctionRange
(
const
Module
:
:
Range
&
range
Module
:
:
Function
*
function
)
:
address
(
range
.
address
)
size
(
range
.
size
)
function
(
function
)
{
}
void
AddLine
(
Module
:
:
Line
&
line
)
{
function
-
>
lines
.
push_back
(
line
)
;
}
Module
:
:
Address
address
;
Module
:
:
Address
size
;
Module
:
:
Function
*
function
;
}
;
static
void
FillSortedFunctionRanges
(
vector
<
FunctionRange
>
&
dest_ranges
vector
<
Module
:
:
Function
*
>
*
functions
)
{
for
(
vector
<
Module
:
:
Function
*
>
:
:
const_iterator
func_it
=
functions
-
>
cbegin
(
)
;
func_it
!
=
functions
-
>
cend
(
)
;
func_it
+
+
)
{
Module
:
:
Function
*
func
=
*
func_it
;
vector
<
Module
:
:
Range
>
&
ranges
=
func
-
>
ranges
;
for
(
vector
<
Module
:
:
Range
>
:
:
const_iterator
ranges_it
=
ranges
.
cbegin
(
)
;
ranges_it
!
=
ranges
.
cend
(
)
;
+
+
ranges_it
)
{
FunctionRange
range
(
*
ranges_it
func
)
;
if
(
range
.
size
!
=
0
)
{
dest_ranges
.
push_back
(
range
)
;
}
}
}
sort
(
dest_ranges
.
begin
(
)
dest_ranges
.
end
(
)
[
]
(
const
FunctionRange
&
fr1
const
FunctionRange
&
fr2
)
{
return
fr1
.
address
<
fr2
.
address
;
}
)
;
}
template
<
class
T
>
inline
bool
within
(
const
T
&
item
Module
:
:
Address
address
)
{
return
address
-
item
.
address
<
item
.
size
;
}
vector
<
Module
:
:
Line
>
MergeLines
(
const
vector
<
Module
:
:
Line
>
&
inlines
const
vector
<
Module
:
:
Line
>
&
lines
)
{
vector
<
Module
:
:
Line
>
merged_lines
;
vector
<
Module
:
:
Line
>
:
:
const_iterator
orig_lines
=
lines
.
begin
(
)
;
vector
<
Module
:
:
Line
>
:
:
const_iterator
inline_lines
=
inlines
.
begin
(
)
;
vector
<
Module
:
:
Line
>
:
:
const_iterator
orig_end
=
lines
.
end
(
)
;
vector
<
Module
:
:
Line
>
:
:
const_iterator
inline_end
=
inlines
.
end
(
)
;
while
(
true
)
{
if
(
orig_lines
=
=
orig_end
)
{
break
;
}
if
(
inline_lines
=
=
inline_end
)
{
merged_lines
.
push_back
(
*
orig_lines
)
;
+
+
orig_lines
;
continue
;
}
if
(
orig_lines
-
>
address
<
inline_lines
-
>
address
)
{
merged_lines
.
push_back
(
*
orig_lines
)
;
+
+
orig_lines
;
continue
;
}
if
(
orig_lines
-
>
address
=
=
inline_lines
-
>
address
)
{
auto
start
=
orig_lines
+
1
;
while
(
(
start
-
>
address
-
inline_lines
-
>
address
)
<
inline_lines
-
>
size
&
&
start
!
=
orig_end
)
{
+
+
start
;
}
merged_lines
.
push_back
(
*
inline_lines
)
;
auto
overlapped
=
start
-
1
;
if
(
within
(
*
overlapped
inline_lines
-
>
address
+
inline_lines
-
>
size
)
)
{
Module
:
:
Line
rest
;
rest
.
address
=
inline_lines
-
>
address
+
inline_lines
-
>
size
;
rest
.
size
=
overlapped
-
>
address
+
overlapped
-
>
size
-
rest
.
address
;
rest
.
file
=
overlapped
-
>
file
;
rest
.
number
=
overlapped
-
>
number
;
merged_lines
.
push_back
(
rest
)
;
}
+
+
inline_lines
;
orig_lines
=
start
;
continue
;
}
if
(
orig_lines
-
>
address
>
inline_lines
-
>
address
)
{
+
+
inline_lines
;
continue
;
}
}
return
merged_lines
;
}
void
CollapseAdjacentLines
(
vector
<
Module
:
:
Line
>
&
lines
)
{
if
(
lines
.
empty
(
)
)
{
return
;
}
auto
merging_into
=
lines
.
begin
(
)
;
auto
next
=
merging_into
+
1
;
const
auto
end
=
lines
.
end
(
)
;
while
(
next
!
=
end
)
{
if
(
(
merging_into
-
>
address
+
merging_into
-
>
size
)
=
=
next
-
>
address
&
&
merging_into
-
>
file
=
=
next
-
>
file
&
&
merging_into
-
>
number
=
=
next
-
>
number
)
{
merging_into
-
>
size
=
next
-
>
address
+
next
-
>
size
-
merging_into
-
>
address
;
+
+
next
;
continue
;
}
+
+
merging_into
;
if
(
next
!
=
end
)
{
if
(
next
!
=
merging_into
)
{
*
merging_into
=
std
:
:
move
(
*
next
)
;
}
+
+
next
;
}
}
lines
.
erase
(
merging_into
+
1
end
)
;
}
}
void
DwarfCUToModule
:
:
AssignLinesToFunctions
(
const
LineToModuleHandler
:
:
FileMap
&
files
)
{
vector
<
Module
:
:
Function
*
>
*
functions
=
&
cu_context_
-
>
functions
;
WarningReporter
*
reporter
=
cu_context_
-
>
reporter
;
std
:
:
sort
(
functions
-
>
begin
(
)
functions
-
>
end
(
)
Module
:
:
Function
:
:
CompareByAddress
)
;
std
:
:
sort
(
lines_
.
begin
(
)
lines_
.
end
(
)
Module
:
:
Line
:
:
CompareByAddress
)
;
vector
<
Module
:
:
Line
>
inlines
;
for
(
const
auto
&
range
:
cu_context_
-
>
file_context
-
>
file_private_
-
>
inlined_ranges
)
{
auto
f
=
files
.
find
(
range
.
call_file_
)
;
if
(
f
=
=
files
.
end
(
)
)
{
continue
;
}
Module
:
:
Line
line
;
line
.
address
=
range
.
range_
.
address
;
line
.
size
=
range
.
range_
.
size
;
line
.
number
=
range
.
call_line_
;
line
.
file
=
f
-
>
second
;
inlines
.
push_back
(
line
)
;
}
std
:
:
sort
(
inlines
.
begin
(
)
inlines
.
end
(
)
Module
:
:
Line
:
:
CompareByAddress
)
;
if
(
!
inlines
.
empty
(
)
)
{
vector
<
Module
:
:
Line
>
merged_lines
=
MergeLines
(
inlines
lines_
)
;
CollapseAdjacentLines
(
merged_lines
)
;
lines_
=
std
:
:
move
(
merged_lines
)
;
}
const
Module
:
:
Line
*
last_line_used
=
NULL
;
const
Module
:
:
Function
*
last_function_cited
=
NULL
;
const
Module
:
:
Line
*
last_line_cited
=
NULL
;
vector
<
FunctionRange
>
sorted_ranges
;
FillSortedFunctionRanges
(
sorted_ranges
functions
)
;
vector
<
FunctionRange
>
:
:
iterator
range_it
=
sorted_ranges
.
begin
(
)
;
vector
<
Module
:
:
Line
>
:
:
const_iterator
line_it
=
lines_
.
begin
(
)
;
Module
:
:
Address
current
;
FunctionRange
*
range
;
const
Module
:
:
Line
*
line
;
if
(
range_it
!
=
sorted_ranges
.
end
(
)
&
&
line_it
!
=
lines_
.
end
(
)
)
{
range
=
&
*
range_it
;
line
=
&
*
line_it
;
current
=
std
:
:
min
(
range
-
>
address
line
-
>
address
)
;
}
else
if
(
line_it
!
=
lines_
.
end
(
)
)
{
range
=
NULL
;
line
=
&
*
line_it
;
current
=
line
-
>
address
;
}
else
if
(
range_it
!
=
sorted_ranges
.
end
(
)
)
{
range
=
&
*
range_it
;
line
=
NULL
;
current
=
range
-
>
address
;
}
else
{
return
;
}
while
(
range
|
|
line
)
{
assert
(
!
range
|
|
current
<
range
-
>
address
|
|
within
(
*
range
current
)
)
;
assert
(
!
line
|
|
current
<
line
-
>
address
|
|
within
(
*
line
current
)
)
;
Module
:
:
Address
next_transition
;
if
(
range
&
&
current
>
=
range
-
>
address
)
{
if
(
line
&
&
current
>
=
line
-
>
address
)
{
Module
:
:
Address
range_left
=
range
-
>
size
-
(
current
-
range
-
>
address
)
;
Module
:
:
Address
line_left
=
line
-
>
size
-
(
current
-
line
-
>
address
)
;
next_transition
=
current
+
std
:
:
min
(
range_left
line_left
)
;
Module
:
:
Line
l
=
*
line
;
l
.
address
=
current
;
l
.
size
=
next_transition
-
current
;
range
-
>
AddLine
(
l
)
;
last_line_used
=
line
;
}
else
{
if
(
range
-
>
function
!
=
last_function_cited
)
{
reporter
-
>
UncoveredFunction
(
*
(
range
-
>
function
)
)
;
last_function_cited
=
range
-
>
function
;
}
if
(
line
&
&
within
(
*
range
line
-
>
address
)
)
next_transition
=
line
-
>
address
;
else
next_transition
=
range
-
>
address
+
range
-
>
size
;
}
}
else
{
if
(
line
&
&
current
>
=
line
-
>
address
)
{
if
(
line
!
=
last_line_cited
&
&
!
(
range
&
&
line
=
=
last_line_used
&
&
range
-
>
address
-
line
-
>
address
=
=
line
-
>
size
)
)
{
reporter
-
>
UncoveredLine
(
*
line
)
;
last_line_cited
=
line
;
}
if
(
range
&
&
within
(
*
line
range
-
>
address
)
)
next_transition
=
range
-
>
address
;
else
next_transition
=
line
-
>
address
+
line
-
>
size
;
}
else
{
assert
(
range
|
|
line
)
;
if
(
range
&
&
line
)
next_transition
=
std
:
:
min
(
range
-
>
address
line
-
>
address
)
;
else
if
(
range
)
next_transition
=
range
-
>
address
;
else
next_transition
=
line
-
>
address
;
}
}
if
(
!
next_transition
)
break
;
while
(
range_it
!
=
sorted_ranges
.
end
(
)
&
&
next_transition
>
=
range_it
-
>
address
&
&
!
within
(
*
range_it
next_transition
)
)
range_it
+
+
;
range
=
(
range_it
!
=
sorted_ranges
.
end
(
)
)
?
&
(
*
range_it
)
:
NULL
;
while
(
line_it
!
=
lines_
.
end
(
)
&
&
next_transition
>
=
line_it
-
>
address
&
&
!
within
(
*
line_it
next_transition
)
)
line_it
+
+
;
line
=
(
line_it
!
=
lines_
.
end
(
)
)
?
&
*
line_it
:
NULL
;
assert
(
next_transition
>
current
)
;
current
=
next_transition
;
}
}
void
DwarfCUToModule
:
:
Finish
(
)
{
if
(
!
cu_context_
-
>
language
-
>
HasFunctions
(
)
)
return
;
LineToModuleHandler
:
:
FileMap
files
;
if
(
has_source_line_info_
)
ReadSourceLines
(
source_line_offset_
&
files
)
;
vector
<
Module
:
:
Function
*
>
*
functions
=
&
cu_context_
-
>
functions
;
AssignLinesToFunctions
(
files
)
;
cu_context_
-
>
file_context
-
>
module_
-
>
AddFunctions
(
functions
-
>
begin
(
)
functions
-
>
end
(
)
)
;
functions
-
>
clear
(
)
;
cu_context_
-
>
file_context
-
>
ClearSpecifications
(
)
;
}
bool
DwarfCUToModule
:
:
StartCompilationUnit
(
uint64
offset
uint8
address_size
uint8
offset_size
uint64
cu_length
uint8
dwarf_version
)
{
return
dwarf_version
>
=
2
;
}
bool
DwarfCUToModule
:
:
StartRootDIE
(
uint64
offset
enum
DwarfTag
tag
)
{
return
tag
=
=
dwarf2reader
:
:
DW_TAG_compile_unit
;
}
}
