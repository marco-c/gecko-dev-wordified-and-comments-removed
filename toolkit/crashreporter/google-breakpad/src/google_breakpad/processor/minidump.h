#
ifndef
GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_H__
#
define
GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_H__
#
include
<
stdint
.
h
>
#
ifndef
_WIN32
#
include
<
unistd
.
h
>
#
endif
#
include
<
iostream
>
#
include
<
map
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
common
/
basictypes
.
h
"
#
include
"
common
/
using_std_string
.
h
"
#
include
"
google_breakpad
/
processor
/
code_module
.
h
"
#
include
"
google_breakpad
/
processor
/
code_modules
.
h
"
#
include
"
google_breakpad
/
processor
/
dump_context
.
h
"
#
include
"
google_breakpad
/
processor
/
dump_object
.
h
"
#
include
"
google_breakpad
/
processor
/
memory_region
.
h
"
#
include
"
google_breakpad
/
processor
/
proc_maps_linux
.
h
"
namespace
google_breakpad
{
using
std
:
:
map
;
using
std
:
:
vector
;
class
Minidump
;
template
<
typename
AddressType
typename
EntryType
>
class
RangeMap
;
class
MinidumpObject
:
public
DumpObject
{
public
:
virtual
~
MinidumpObject
(
)
{
}
protected
:
explicit
MinidumpObject
(
Minidump
*
minidump
)
;
Minidump
*
minidump_
;
}
;
class
MinidumpStream
:
public
MinidumpObject
{
public
:
virtual
~
MinidumpStream
(
)
{
}
protected
:
explicit
MinidumpStream
(
Minidump
*
minidump
)
;
private
:
virtual
bool
Read
(
uint32_t
expected_size
)
=
0
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpStream
)
;
}
;
class
MinidumpContext
:
public
DumpContext
{
public
:
virtual
~
MinidumpContext
(
)
;
protected
:
explicit
MinidumpContext
(
Minidump
*
minidump
)
;
private
:
friend
class
MinidumpThread
;
friend
class
MinidumpException
;
bool
Read
(
uint32_t
expected_size
)
;
bool
CheckAgainstSystemInfo
(
uint32_t
context_cpu_type
)
;
Minidump
*
minidump_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpContext
)
;
}
;
class
MinidumpMemoryRegion
:
public
MinidumpObject
public
MemoryRegion
{
public
:
virtual
~
MinidumpMemoryRegion
(
)
;
static
void
set_max_bytes
(
uint32_t
max_bytes
)
{
max_bytes_
=
max_bytes
;
}
static
uint32_t
max_bytes
(
)
{
return
max_bytes_
;
}
const
uint8_t
*
GetMemory
(
)
const
;
uint64_t
GetBase
(
)
const
;
uint32_t
GetSize
(
)
const
;
void
FreeMemory
(
)
;
bool
GetMemoryAtAddress
(
uint64_t
address
uint8_t
*
value
)
const
;
bool
GetMemoryAtAddress
(
uint64_t
address
uint16_t
*
value
)
const
;
bool
GetMemoryAtAddress
(
uint64_t
address
uint32_t
*
value
)
const
;
bool
GetMemoryAtAddress
(
uint64_t
address
uint64_t
*
value
)
const
;
void
Print
(
)
const
;
void
SetPrintMode
(
bool
hexdump
unsigned
int
width
)
;
protected
:
explicit
MinidumpMemoryRegion
(
Minidump
*
minidump
)
;
private
:
friend
class
MinidumpThread
;
friend
class
MinidumpMemoryList
;
void
SetDescriptor
(
MDMemoryDescriptor
*
descriptor
)
;
template
<
typename
T
>
bool
GetMemoryAtAddressInternal
(
uint64_t
address
T
*
value
)
const
;
bool
hexdump_
;
unsigned
int
hexdump_width_
;
static
uint32_t
max_bytes_
;
MDMemoryDescriptor
*
descriptor_
;
mutable
vector
<
uint8_t
>
*
memory_
;
}
;
class
MinidumpThread
:
public
MinidumpObject
{
public
:
virtual
~
MinidumpThread
(
)
;
const
MDRawThread
*
thread
(
)
const
{
return
valid_
?
&
thread_
:
NULL
;
}
virtual
MinidumpMemoryRegion
*
GetMemory
(
)
;
virtual
uint32_t
GetLastError
(
)
;
virtual
MinidumpContext
*
GetContext
(
)
;
virtual
bool
GetThreadID
(
uint32_t
*
thread_id
)
const
;
void
Print
(
)
;
virtual
uint64_t
GetStartOfStackMemoryRange
(
)
const
;
protected
:
explicit
MinidumpThread
(
Minidump
*
minidump
)
;
private
:
friend
class
MinidumpThreadList
;
bool
Read
(
)
;
MDRawThread
thread_
;
MinidumpMemoryRegion
*
memory_
;
MinidumpContext
*
context_
;
}
;
class
MinidumpThreadList
:
public
MinidumpStream
{
public
:
virtual
~
MinidumpThreadList
(
)
;
static
void
set_max_threads
(
uint32_t
max_threads
)
{
max_threads_
=
max_threads
;
}
static
uint32_t
max_threads
(
)
{
return
max_threads_
;
}
virtual
unsigned
int
thread_count
(
)
const
{
return
valid_
?
thread_count_
:
0
;
}
virtual
MinidumpThread
*
GetThreadAtIndex
(
unsigned
int
index
)
const
;
MinidumpThread
*
GetThreadByID
(
uint32_t
thread_id
)
;
void
Print
(
)
;
protected
:
explicit
MinidumpThreadList
(
Minidump
*
aMinidump
)
;
private
:
friend
class
Minidump
;
typedef
map
<
uint32_t
MinidumpThread
*
>
IDToThreadMap
;
typedef
vector
<
MinidumpThread
>
MinidumpThreads
;
static
const
uint32_t
kStreamType
=
MD_THREAD_LIST_STREAM
;
bool
Read
(
uint32_t
aExpectedSize
)
override
;
static
uint32_t
max_threads_
;
IDToThreadMap
id_to_thread_map_
;
MinidumpThreads
*
threads_
;
uint32_t
thread_count_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpThreadList
)
;
}
;
class
MinidumpModule
:
public
MinidumpObject
public
CodeModule
{
public
:
virtual
~
MinidumpModule
(
)
;
static
void
set_max_cv_bytes
(
uint32_t
max_cv_bytes
)
{
max_cv_bytes_
=
max_cv_bytes
;
}
static
uint32_t
max_cv_bytes
(
)
{
return
max_cv_bytes_
;
}
static
void
set_max_misc_bytes
(
uint32_t
max_misc_bytes
)
{
max_misc_bytes_
=
max_misc_bytes
;
}
static
uint32_t
max_misc_bytes
(
)
{
return
max_misc_bytes_
;
}
const
MDRawModule
*
module
(
)
const
{
return
valid_
?
&
module_
:
NULL
;
}
virtual
uint64_t
base_address
(
)
const
{
return
valid_
?
module_
.
base_of_image
:
static_cast
<
uint64_t
>
(
-
1
)
;
}
virtual
uint64_t
size
(
)
const
{
return
valid_
?
module_
.
size_of_image
:
0
;
}
virtual
string
code_file
(
)
const
;
virtual
string
code_identifier
(
)
const
;
virtual
string
debug_file
(
)
const
;
virtual
string
debug_identifier
(
)
const
;
virtual
string
version
(
)
const
;
virtual
CodeModule
*
Copy
(
)
const
;
virtual
bool
is_unloaded
(
)
const
{
return
false
;
}
virtual
uint64_t
shrink_down_delta
(
)
const
;
virtual
void
SetShrinkDownDelta
(
uint64_t
shrink_down_delta
)
;
const
uint8_t
*
GetCVRecord
(
uint32_t
*
size
)
;
const
MDImageDebugMisc
*
GetMiscRecord
(
uint32_t
*
size
)
;
void
Print
(
)
;
private
:
friend
class
MinidumpModuleList
;
explicit
MinidumpModule
(
Minidump
*
minidump
)
;
bool
Read
(
)
;
bool
ReadAuxiliaryData
(
)
;
static
uint32_t
max_cv_bytes_
;
static
uint32_t
max_misc_bytes_
;
bool
module_valid_
;
bool
has_debug_info_
;
MDRawModule
module_
;
const
string
*
name_
;
vector
<
uint8_t
>
*
cv_record_
;
uint32_t
cv_record_signature_
;
vector
<
uint8_t
>
*
misc_record_
;
}
;
class
MinidumpModuleList
:
public
MinidumpStream
public
CodeModules
{
public
:
virtual
~
MinidumpModuleList
(
)
;
static
void
set_max_modules
(
uint32_t
max_modules
)
{
max_modules_
=
max_modules
;
}
static
uint32_t
max_modules
(
)
{
return
max_modules_
;
}
virtual
unsigned
int
module_count
(
)
const
{
return
valid_
?
module_count_
:
0
;
}
virtual
const
MinidumpModule
*
GetModuleForAddress
(
uint64_t
address
)
const
;
virtual
const
MinidumpModule
*
GetMainModule
(
)
const
;
virtual
const
MinidumpModule
*
GetModuleAtSequence
(
unsigned
int
sequence
)
const
;
virtual
const
MinidumpModule
*
GetModuleAtIndex
(
unsigned
int
index
)
const
;
virtual
const
CodeModules
*
Copy
(
)
const
;
virtual
vector
<
linked_ptr
<
const
CodeModule
>
>
GetShrunkRangeModules
(
)
const
;
void
Print
(
)
;
protected
:
explicit
MinidumpModuleList
(
Minidump
*
minidump
)
;
private
:
friend
class
Minidump
;
typedef
vector
<
MinidumpModule
>
MinidumpModules
;
static
const
uint32_t
kStreamType
=
MD_MODULE_LIST_STREAM
;
bool
Read
(
uint32_t
expected_size
)
;
bool
StoreRange
(
const
MinidumpModule
&
module
uint64_t
base_address
uint32_t
module_index
uint32_t
module_count
bool
is_android
)
;
static
uint32_t
max_modules_
;
RangeMap
<
uint64_t
unsigned
int
>
*
range_map_
;
MinidumpModules
*
modules_
;
uint32_t
module_count_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpModuleList
)
;
}
;
class
MinidumpMemoryList
:
public
MinidumpStream
{
public
:
virtual
~
MinidumpMemoryList
(
)
;
static
void
set_max_regions
(
uint32_t
max_regions
)
{
max_regions_
=
max_regions
;
}
static
uint32_t
max_regions
(
)
{
return
max_regions_
;
}
unsigned
int
region_count
(
)
const
{
return
valid_
?
region_count_
:
0
;
}
MinidumpMemoryRegion
*
GetMemoryRegionAtIndex
(
unsigned
int
index
)
;
virtual
MinidumpMemoryRegion
*
GetMemoryRegionForAddress
(
uint64_t
address
)
;
void
Print
(
)
;
private
:
friend
class
Minidump
;
friend
class
MockMinidumpMemoryList
;
typedef
vector
<
MDMemoryDescriptor
>
MemoryDescriptors
;
typedef
vector
<
MinidumpMemoryRegion
>
MemoryRegions
;
static
const
uint32_t
kStreamType
=
MD_MEMORY_LIST_STREAM
;
explicit
MinidumpMemoryList
(
Minidump
*
minidump
)
;
bool
Read
(
uint32_t
expected_size
)
override
;
static
uint32_t
max_regions_
;
RangeMap
<
uint64_t
unsigned
int
>
*
range_map_
;
MemoryDescriptors
*
descriptors_
;
MemoryRegions
*
regions_
;
uint32_t
region_count_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpMemoryList
)
;
}
;
class
MinidumpException
:
public
MinidumpStream
{
public
:
virtual
~
MinidumpException
(
)
;
const
MDRawExceptionStream
*
exception
(
)
const
{
return
valid_
?
&
exception_
:
NULL
;
}
bool
GetThreadID
(
uint32_t
*
thread_id
)
const
;
MinidumpContext
*
GetContext
(
)
;
void
Print
(
)
;
private
:
friend
class
Minidump
;
static
const
uint32_t
kStreamType
=
MD_EXCEPTION_STREAM
;
explicit
MinidumpException
(
Minidump
*
minidump
)
;
bool
Read
(
uint32_t
expected_size
)
override
;
MDRawExceptionStream
exception_
;
MinidumpContext
*
context_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpException
)
;
}
;
class
MinidumpAssertion
:
public
MinidumpStream
{
public
:
virtual
~
MinidumpAssertion
(
)
;
const
MDRawAssertionInfo
*
assertion
(
)
const
{
return
valid_
?
&
assertion_
:
NULL
;
}
string
expression
(
)
const
{
return
valid_
?
expression_
:
"
"
;
}
string
function
(
)
const
{
return
valid_
?
function_
:
"
"
;
}
string
file
(
)
const
{
return
valid_
?
file_
:
"
"
;
}
void
Print
(
)
;
private
:
friend
class
Minidump
;
static
const
uint32_t
kStreamType
=
MD_ASSERTION_INFO_STREAM
;
explicit
MinidumpAssertion
(
Minidump
*
minidump
)
;
bool
Read
(
uint32_t
expected_size
)
override
;
MDRawAssertionInfo
assertion_
;
string
expression_
;
string
function_
;
string
file_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpAssertion
)
;
}
;
class
MinidumpSystemInfo
:
public
MinidumpStream
{
public
:
virtual
~
MinidumpSystemInfo
(
)
;
const
MDRawSystemInfo
*
system_info
(
)
const
{
return
valid_
?
&
system_info_
:
NULL
;
}
string
GetOS
(
)
;
string
GetCPU
(
)
;
const
string
*
GetCSDVersion
(
)
;
const
string
*
GetCPUVendor
(
)
;
void
Print
(
)
;
protected
:
explicit
MinidumpSystemInfo
(
Minidump
*
minidump
)
;
MDRawSystemInfo
system_info_
;
const
string
*
csd_version_
;
private
:
friend
class
Minidump
;
static
const
uint32_t
kStreamType
=
MD_SYSTEM_INFO_STREAM
;
bool
Read
(
uint32_t
expected_size
)
override
;
const
string
*
cpu_vendor_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpSystemInfo
)
;
}
;
class
MinidumpUnloadedModule
:
public
MinidumpObject
public
CodeModule
{
public
:
~
MinidumpUnloadedModule
(
)
override
;
const
MDRawUnloadedModule
*
module
(
)
const
{
return
valid_
?
&
unloaded_module_
:
NULL
;
}
uint64_t
base_address
(
)
const
override
{
return
valid_
?
unloaded_module_
.
base_of_image
:
0
;
}
uint64_t
size
(
)
const
override
{
return
valid_
?
unloaded_module_
.
size_of_image
:
0
;
}
string
code_file
(
)
const
override
;
string
code_identifier
(
)
const
override
;
string
debug_file
(
)
const
override
;
string
debug_identifier
(
)
const
override
;
string
version
(
)
const
override
;
CodeModule
*
Copy
(
)
const
override
;
bool
is_unloaded
(
)
const
override
{
return
true
;
}
uint64_t
shrink_down_delta
(
)
const
override
;
void
SetShrinkDownDelta
(
uint64_t
shrink_down_delta
)
override
;
void
Print
(
)
;
protected
:
explicit
MinidumpUnloadedModule
(
Minidump
*
minidump
)
;
private
:
friend
class
MinidumpUnloadedModuleList
;
bool
Read
(
uint32_t
expected_size
)
;
bool
ReadAuxiliaryData
(
)
;
bool
module_valid_
;
MDRawUnloadedModule
unloaded_module_
;
const
string
*
name_
;
}
;
class
MinidumpUnloadedModuleList
:
public
MinidumpStream
public
CodeModules
{
public
:
~
MinidumpUnloadedModuleList
(
)
override
;
static
void
set_max_modules
(
uint32_t
max_modules
)
{
max_modules_
=
max_modules
;
}
static
uint32_t
max_modules
(
)
{
return
max_modules_
;
}
unsigned
int
module_count
(
)
const
override
{
return
valid_
?
module_count_
:
0
;
}
const
MinidumpUnloadedModule
*
GetModuleForAddress
(
uint64_t
address
)
const
override
;
const
MinidumpUnloadedModule
*
GetMainModule
(
)
const
override
;
const
MinidumpUnloadedModule
*
GetModuleAtSequence
(
unsigned
int
sequence
)
const
override
;
const
MinidumpUnloadedModule
*
GetModuleAtIndex
(
unsigned
int
index
)
const
override
;
const
CodeModules
*
Copy
(
)
const
override
;
vector
<
linked_ptr
<
const
CodeModule
>
>
GetShrunkRangeModules
(
)
const
override
;
void
Print
(
)
;
protected
:
explicit
MinidumpUnloadedModuleList
(
Minidump
*
minidump_
)
;
private
:
friend
class
Minidump
;
typedef
vector
<
MinidumpUnloadedModule
>
MinidumpUnloadedModules
;
static
const
uint32_t
kStreamType
=
MD_UNLOADED_MODULE_LIST_STREAM
;
bool
Read
(
uint32_t
expected_size_
)
override
;
static
uint32_t
max_modules_
;
RangeMap
<
uint64_t
unsigned
int
>
*
range_map_
;
MinidumpUnloadedModules
*
unloaded_modules_
;
uint32_t
module_count_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpUnloadedModuleList
)
;
}
;
class
MinidumpMiscInfo
:
public
MinidumpStream
{
public
:
const
MDRawMiscInfo
*
misc_info
(
)
const
{
return
valid_
?
&
misc_info_
:
NULL
;
}
void
Print
(
)
;
private
:
friend
class
Minidump
;
friend
class
TestMinidumpMiscInfo
;
static
const
uint32_t
kStreamType
=
MD_MISC_INFO_STREAM
;
explicit
MinidumpMiscInfo
(
Minidump
*
minidump_
)
;
bool
Read
(
uint32_t
expected_size_
)
override
;
MDRawMiscInfo
misc_info_
;
string
standard_name_
;
string
daylight_name_
;
string
build_string_
;
string
dbg_bld_str_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpMiscInfo
)
;
}
;
class
MinidumpBreakpadInfo
:
public
MinidumpStream
{
public
:
const
MDRawBreakpadInfo
*
breakpad_info
(
)
const
{
return
valid_
?
&
breakpad_info_
:
NULL
;
}
bool
GetDumpThreadID
(
uint32_t
*
thread_id
)
const
;
bool
GetRequestingThreadID
(
uint32_t
*
thread_id
)
const
;
void
Print
(
)
;
private
:
friend
class
Minidump
;
static
const
uint32_t
kStreamType
=
MD_BREAKPAD_INFO_STREAM
;
explicit
MinidumpBreakpadInfo
(
Minidump
*
minidump_
)
;
bool
Read
(
uint32_t
expected_size_
)
override
;
MDRawBreakpadInfo
breakpad_info_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpBreakpadInfo
)
;
}
;
class
MinidumpMemoryInfo
:
public
MinidumpObject
{
public
:
const
MDRawMemoryInfo
*
info
(
)
const
{
return
valid_
?
&
memory_info_
:
NULL
;
}
uint64_t
GetBase
(
)
const
{
return
valid_
?
memory_info_
.
base_address
:
0
;
}
uint64_t
GetSize
(
)
const
{
return
valid_
?
memory_info_
.
region_size
:
0
;
}
bool
IsExecutable
(
)
const
;
bool
IsWritable
(
)
const
;
void
Print
(
)
;
private
:
friend
class
MinidumpMemoryInfoList
;
explicit
MinidumpMemoryInfo
(
Minidump
*
minidump_
)
;
bool
Read
(
)
;
MDRawMemoryInfo
memory_info_
;
}
;
class
MinidumpMemoryInfoList
:
public
MinidumpStream
{
public
:
virtual
~
MinidumpMemoryInfoList
(
)
;
unsigned
int
info_count
(
)
const
{
return
valid_
?
info_count_
:
0
;
}
const
MinidumpMemoryInfo
*
GetMemoryInfoForAddress
(
uint64_t
address
)
const
;
const
MinidumpMemoryInfo
*
GetMemoryInfoAtIndex
(
unsigned
int
index
)
const
;
void
Print
(
)
;
private
:
friend
class
Minidump
;
typedef
vector
<
MinidumpMemoryInfo
>
MinidumpMemoryInfos
;
static
const
uint32_t
kStreamType
=
MD_MEMORY_INFO_LIST_STREAM
;
explicit
MinidumpMemoryInfoList
(
Minidump
*
minidump_
)
;
bool
Read
(
uint32_t
expected_size
)
override
;
RangeMap
<
uint64_t
unsigned
int
>
*
range_map_
;
MinidumpMemoryInfos
*
infos_
;
uint32_t
info_count_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpMemoryInfoList
)
;
}
;
class
MinidumpLinuxMaps
:
public
MinidumpObject
{
public
:
uint64_t
GetBase
(
)
const
{
return
valid_
?
region_
.
start
:
0
;
}
uint64_t
GetSize
(
)
const
{
return
valid_
?
region_
.
end
-
region_
.
start
:
0
;
}
bool
IsReadable
(
)
const
{
return
valid_
?
region_
.
permissions
&
MappedMemoryRegion
:
:
READ
:
false
;
}
bool
IsWriteable
(
)
const
{
return
valid_
?
region_
.
permissions
&
MappedMemoryRegion
:
:
WRITE
:
false
;
}
bool
IsExecutable
(
)
const
{
return
valid_
?
region_
.
permissions
&
MappedMemoryRegion
:
:
EXECUTE
:
false
;
}
bool
IsPrivate
(
)
const
{
return
valid_
?
region_
.
permissions
&
MappedMemoryRegion
:
:
PRIVATE
:
false
;
}
uint64_t
GetOffset
(
)
const
{
return
valid_
?
region_
.
offset
:
0
;
}
uint8_t
GetMajorDevice
(
)
const
{
return
valid_
?
region_
.
major_device
:
0
;
}
uint8_t
GetMinorDevice
(
)
const
{
return
valid_
?
region_
.
minor_device
:
0
;
}
uint64_t
GetInode
(
)
const
{
return
valid_
?
region_
.
inode
:
0
;
}
const
string
GetPathname
(
)
const
{
return
valid_
?
region_
.
path
:
"
"
;
}
void
Print
(
)
const
;
private
:
friend
class
MinidumpLinuxMapsList
;
explicit
MinidumpLinuxMaps
(
Minidump
*
minidump
)
;
MappedMemoryRegion
region_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpLinuxMaps
)
;
}
;
class
MinidumpLinuxMapsList
:
public
MinidumpStream
{
public
:
virtual
~
MinidumpLinuxMapsList
(
)
;
unsigned
int
get_maps_count
(
)
const
{
return
valid_
?
maps_count_
:
0
;
}
const
MinidumpLinuxMaps
*
GetLinuxMapsForAddress
(
uint64_t
address
)
const
;
const
MinidumpLinuxMaps
*
GetLinuxMapsAtIndex
(
unsigned
int
index
)
const
;
void
Print
(
)
const
;
private
:
friend
class
Minidump
;
typedef
vector
<
MinidumpLinuxMaps
*
>
MinidumpLinuxMappings
;
static
const
uint32_t
kStreamType
=
MD_LINUX_MAPS
;
explicit
MinidumpLinuxMapsList
(
Minidump
*
minidump
)
;
bool
Read
(
uint32_t
expected_size
)
override
;
MinidumpLinuxMappings
*
maps_
;
uint32_t
maps_count_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpLinuxMapsList
)
;
}
;
class
MinidumpCrashpadInfo
:
public
MinidumpStream
{
public
:
const
MDRawCrashpadInfo
*
crashpad_info
(
)
const
{
return
valid_
?
&
crashpad_info_
:
NULL
;
}
void
Print
(
)
;
private
:
friend
class
Minidump
;
static
const
uint32_t
kStreamType
=
MD_CRASHPAD_INFO_STREAM
;
explicit
MinidumpCrashpadInfo
(
Minidump
*
minidump_
)
;
bool
Read
(
uint32_t
expected_size
)
;
MDRawCrashpadInfo
crashpad_info_
;
std
:
:
vector
<
uint32_t
>
module_crashpad_info_links_
;
std
:
:
vector
<
MDRawModuleCrashpadInfo
>
module_crashpad_info_
;
std
:
:
vector
<
std
:
:
vector
<
std
:
:
string
>
>
module_crashpad_info_list_annotations_
;
std
:
:
vector
<
std
:
:
map
<
std
:
:
string
std
:
:
string
>
>
module_crashpad_info_simple_annotations_
;
std
:
:
map
<
std
:
:
string
std
:
:
string
>
simple_annotations_
;
}
;
typedef
struct
crash_info_record
{
string
module_path
;
unsigned
long
version
;
string
message
;
string
signature_string
;
string
backtrace
;
string
message2
;
unsigned
long
long
thread
;
unsigned
int
dialog_mode
;
long
long
abort_cause
;
crash_info_record
(
)
:
version
(
0
)
thread
(
0
)
dialog_mode
(
0
)
abort_cause
(
0
)
{
}
}
crash_info_record_t
;
class
MinidumpMacCrashInfo
:
public
MinidumpStream
{
public
:
string
description
(
)
const
{
return
description_
;
}
vector
<
crash_info_record_t
>
const
records
(
)
{
return
records_
;
}
void
Print
(
)
;
private
:
friend
class
Minidump
;
static
const
uint32_t
kStreamType
=
MOZ_MACOS_CRASH_INFO_STREAM
;
explicit
MinidumpMacCrashInfo
(
Minidump
*
minidump_
)
;
bool
ReadCrashInfoRecord
(
MDLocationDescriptor
location
uint32_t
record_start_size
)
;
bool
Read
(
uint32_t
expected_size
)
;
string
description_
;
vector
<
crash_info_record_t
>
records_
;
}
;
class
MinidumpThreadName
:
public
MinidumpObject
{
public
:
~
MinidumpThreadName
(
)
override
;
const
MDRawThreadName
*
thread_name
(
)
const
{
if
(
valid_
)
{
return
&
thread_name_
;
}
return
NULL
;
}
uint32_t
thread_id
(
)
const
{
if
(
valid_
)
{
return
thread_name_
.
thread_id
;
}
return
0
;
}
string
name
(
)
const
;
void
Print
(
)
;
protected
:
explicit
MinidumpThreadName
(
Minidump
*
minidump
)
;
private
:
friend
class
MinidumpThreadNamesList
;
bool
Read
(
uint32_t
expected_size
)
;
bool
ReadAuxiliaryData
(
)
;
bool
valid_
;
MDRawThreadName
thread_name_
;
const
string
*
name_
;
}
;
class
MinidumpThreadNamesList
:
public
MinidumpStream
{
public
:
~
MinidumpThreadNamesList
(
)
override
;
unsigned
int
name_count
(
)
const
{
return
valid_
?
name_count_
:
0
;
}
const
string
GetNameForThreadId
(
uint32_t
thread_id
)
const
;
void
Print
(
)
;
protected
:
explicit
MinidumpThreadNamesList
(
Minidump
*
minidump_
)
;
private
:
friend
class
Minidump
;
typedef
vector
<
MinidumpThreadName
>
MinidumpThreadNames
;
static
const
uint32_t
kStreamType
=
MD_THREAD_NAMES_STREAM
;
bool
Read
(
uint32_t
expected_size_
)
override
;
MinidumpThreadNames
*
thread_names_
;
uint32_t
name_count_
;
bool
valid_
;
DISALLOW_COPY_AND_ASSIGN
(
MinidumpThreadNamesList
)
;
}
;
class
Minidump
{
public
:
explicit
Minidump
(
const
string
&
path
bool
hexdump
=
false
unsigned
int
hexdump_width
=
16
)
;
explicit
Minidump
(
std
:
:
istream
&
input
)
;
virtual
~
Minidump
(
)
;
virtual
string
path
(
)
const
{
return
path_
;
}
static
void
set_max_streams
(
uint32_t
max_streams
)
{
max_streams_
=
max_streams
;
}
static
uint32_t
max_streams
(
)
{
return
max_streams_
;
}
static
void
set_max_string_length
(
uint32_t
max_string_length
)
{
max_string_length_
=
max_string_length
;
}
static
uint32_t
max_string_length
(
)
{
return
max_string_length_
;
}
virtual
const
MDRawHeader
*
header
(
)
const
{
return
valid_
?
&
header_
:
NULL
;
}
bool
GetContextCPUFlagsFromSystemInfo
(
uint32_t
*
context_cpu_flags
)
;
virtual
bool
Read
(
)
;
virtual
MinidumpThreadList
*
GetThreadList
(
)
;
virtual
MinidumpModuleList
*
GetModuleList
(
)
;
virtual
MinidumpMemoryList
*
GetMemoryList
(
)
;
virtual
MinidumpException
*
GetException
(
)
;
virtual
MinidumpAssertion
*
GetAssertion
(
)
;
virtual
MinidumpSystemInfo
*
GetSystemInfo
(
)
;
virtual
MinidumpUnloadedModuleList
*
GetUnloadedModuleList
(
)
;
virtual
MinidumpMiscInfo
*
GetMiscInfo
(
)
;
virtual
MinidumpBreakpadInfo
*
GetBreakpadInfo
(
)
;
virtual
MinidumpMemoryInfoList
*
GetMemoryInfoList
(
)
;
MinidumpCrashpadInfo
*
GetCrashpadInfo
(
)
;
MinidumpMacCrashInfo
*
GetMacCrashInfo
(
)
;
MinidumpThreadNamesList
*
GetThreadNamesList
(
)
;
virtual
MinidumpLinuxMapsList
*
GetLinuxMapsList
(
)
;
unsigned
int
GetDirectoryEntryCount
(
)
const
{
return
valid_
?
header_
.
stream_count
:
0
;
}
const
MDRawDirectory
*
GetDirectoryEntryAtIndex
(
unsigned
int
index
)
const
;
bool
ReadBytes
(
void
*
bytes
size_t
count
)
;
bool
SeekSet
(
off_t
offset
)
;
off_t
Tell
(
)
;
string
*
ReadString
(
off_t
offset
)
;
bool
ReadUTF8String
(
off_t
offset
string
*
string_utf8
)
;
bool
ReadStringList
(
off_t
offset
std
:
:
vector
<
std
:
:
string
>
*
string_list
)
;
bool
ReadSimpleStringDictionary
(
off_t
offset
std
:
:
map
<
std
:
:
string
std
:
:
string
>
*
simple_string_dictionary
)
;
bool
SeekToStreamType
(
uint32_t
stream_type
uint32_t
*
stream_length
)
;
bool
swap
(
)
const
{
return
valid_
?
swap_
:
false
;
}
bool
is_big_endian
(
)
const
{
return
valid_
?
is_big_endian_
:
false
;
}
void
Print
(
)
;
bool
IsAndroid
(
)
;
bool
GetPlatform
(
MDOSPlatform
*
platform
)
;
unsigned
int
HexdumpMode
(
)
const
{
return
hexdump_
?
hexdump_width_
:
0
;
}
private
:
struct
MinidumpStreamInfo
{
MinidumpStreamInfo
(
)
:
stream_index
(
0
)
stream
(
NULL
)
{
}
~
MinidumpStreamInfo
(
)
{
delete
stream
;
}
unsigned
int
stream_index
;
MinidumpStream
*
stream
;
}
;
typedef
vector
<
MDRawDirectory
>
MinidumpDirectoryEntries
;
typedef
map
<
uint32_t
MinidumpStreamInfo
>
MinidumpStreamMap
;
template
<
typename
T
>
T
*
GetStream
(
T
*
*
stream
)
;
bool
Open
(
)
;
static
uint32_t
max_streams_
;
static
unsigned
int
max_string_length_
;
MDRawHeader
header_
;
MinidumpDirectoryEntries
*
directory_
;
MinidumpStreamMap
*
stream_map_
;
const
string
path_
;
std
:
:
istream
*
stream_
;
bool
swap_
;
bool
is_big_endian_
;
bool
valid_
;
bool
hexdump_
;
unsigned
int
hexdump_width_
;
DISALLOW_COPY_AND_ASSIGN
(
Minidump
)
;
}
;
}
#
endif
