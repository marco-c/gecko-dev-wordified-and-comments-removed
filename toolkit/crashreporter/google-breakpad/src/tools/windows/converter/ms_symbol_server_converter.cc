#
include
<
windows
.
h
>
#
include
<
dbghelp
.
h
>
#
include
<
cassert
>
#
include
<
cstdio
>
#
include
"
tools
/
windows
/
converter
/
ms_symbol_server_converter
.
h
"
#
include
"
common
/
windows
/
pdb_source_line_writer
.
h
"
#
include
"
common
/
windows
/
string_utils
-
inl
.
h
"
#
ifndef
SYMOPT_NO_PROMPTS
#
define
SYMOPT_NO_PROMPTS
0x00080000
#
endif
namespace
google_breakpad
{
#
if
_MSC_VER
>
=
1400
#
define
SSCANF
sscanf_s
#
else
#
define
SSCANF
sscanf
#
endif
bool
GUIDOrSignatureIdentifier
:
:
InitializeFromString
(
const
string
&
identifier
)
{
type_
=
TYPE_NONE
;
size_t
length
=
identifier
.
length
(
)
;
if
(
length
>
32
&
&
length
<
=
40
)
{
if
(
SSCANF
(
identifier
.
c_str
(
)
"
%
08X
%
04X
%
04X
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
%
X
"
&
guid_
.
Data1
&
guid_
.
Data2
&
guid_
.
Data3
&
guid_
.
Data4
[
0
]
&
guid_
.
Data4
[
1
]
&
guid_
.
Data4
[
2
]
&
guid_
.
Data4
[
3
]
&
guid_
.
Data4
[
4
]
&
guid_
.
Data4
[
5
]
&
guid_
.
Data4
[
6
]
&
guid_
.
Data4
[
7
]
&
age_
)
!
=
12
)
{
return
false
;
}
type_
=
TYPE_GUID
;
}
else
if
(
length
>
8
&
&
length
<
=
15
)
{
if
(
SSCANF
(
identifier
.
c_str
(
)
"
%
08X
%
x
"
&
signature_
&
age_
)
!
=
2
)
{
return
false
;
}
type_
=
TYPE_SIGNATURE
;
}
else
{
return
false
;
}
return
true
;
}
#
undef
SSCANF
MSSymbolServerConverter
:
:
MSSymbolServerConverter
(
const
string
&
local_cache
const
vector
<
string
>
&
symbol_servers
)
:
symbol_path_
(
)
fail_dns_
(
false
)
fail_timeout_
(
false
)
fail_not_found_
(
false
)
{
assert
(
symbol_servers
.
size
(
)
>
0
)
;
#
if
!
defined
(
NDEBUG
)
const
char
kInvalidCharacters
[
]
=
"
*
;
"
;
assert
(
local_cache
.
find_first_of
(
kInvalidCharacters
)
=
=
string
:
:
npos
)
;
#
endif
for
(
vector
<
string
>
:
:
const_iterator
symbol_server
=
symbol_servers
.
begin
(
)
;
symbol_server
!
=
symbol_servers
.
end
(
)
;
+
+
symbol_server
)
{
assert
(
(
*
symbol_server
)
.
find_first_of
(
kInvalidCharacters
)
=
=
string
:
:
npos
)
;
symbol_path_
+
=
"
srv
*
"
+
local_cache
+
"
*
"
+
*
symbol_server
+
"
;
"
;
}
symbol_path_
.
erase
(
symbol_path_
.
length
(
)
-
1
)
;
}
class
AutoSymSrv
{
public
:
AutoSymSrv
(
)
:
initialized_
(
false
)
{
}
~
AutoSymSrv
(
)
{
if
(
!
Cleanup
(
)
)
{
fprintf
(
stderr
"
~
AutoSymSrv
:
SymCleanup
:
error
%
d
\
n
"
GetLastError
(
)
)
;
}
}
bool
Initialize
(
HANDLE
process
char
*
path
bool
invade_process
)
{
process_
=
process
;
initialized_
=
SymInitialize
(
process
path
invade_process
)
=
=
TRUE
;
return
initialized_
;
}
bool
Cleanup
(
)
{
if
(
initialized_
)
{
if
(
SymCleanup
(
process_
)
)
{
initialized_
=
false
;
return
true
;
}
return
false
;
}
return
true
;
}
private
:
HANDLE
process_
;
bool
initialized_
;
}
;
class
AutoDeleter
{
public
:
explicit
AutoDeleter
(
const
string
&
path
)
:
path_
(
path
)
{
}
~
AutoDeleter
(
)
{
int
error
;
if
(
(
error
=
Delete
(
)
)
!
=
0
)
{
fprintf
(
stderr
"
~
AutoDeleter
:
Delete
:
error
%
d
for
%
s
\
n
"
error
path_
.
c_str
(
)
)
;
}
}
int
Delete
(
)
{
if
(
path_
.
empty
(
)
)
return
0
;
int
error
=
remove
(
path_
.
c_str
(
)
)
;
Release
(
)
;
return
error
;
}
void
Release
(
)
{
path_
.
clear
(
)
;
}
private
:
string
path_
;
}
;
MSSymbolServerConverter
:
:
LocateResult
MSSymbolServerConverter
:
:
LocateFile
(
const
string
&
debug_or_code_file
const
string
&
debug_or_code_id
const
string
&
version
string
*
file_name
)
{
assert
(
file_name
)
;
file_name
-
>
clear
(
)
;
GUIDOrSignatureIdentifier
identifier
;
if
(
!
identifier
.
InitializeFromString
(
debug_or_code_id
)
)
{
fprintf
(
stderr
"
LocateFile
:
Unparseable
identifier
for
%
s
%
s
%
s
\
n
"
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
HANDLE
process
=
GetCurrentProcess
(
)
;
AutoSymSrv
symsrv
;
if
(
!
symsrv
.
Initialize
(
process
const_cast
<
char
*
>
(
symbol_path_
.
c_str
(
)
)
false
)
)
{
fprintf
(
stderr
"
LocateFile
:
SymInitialize
:
error
%
d
for
%
s
%
s
%
s
\
n
"
GetLastError
(
)
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
!
SymRegisterCallback64
(
process
SymCallback
reinterpret_cast
<
ULONG64
>
(
this
)
)
)
{
fprintf
(
stderr
"
LocateFile
:
SymRegisterCallback64
:
error
%
d
for
%
s
%
s
%
s
\
n
"
GetLastError
(
)
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
DWORD
options
=
SymGetOptions
(
)
|
SYMOPT_DEBUG
|
SYMOPT_NO_PROMPTS
|
SYMOPT_FAIL_CRITICAL_ERRORS
|
SYMOPT_SECURE
;
SymSetOptions
(
options
)
;
fail_dns_
=
false
;
fail_timeout_
=
false
;
fail_not_found_
=
false
;
char
path
[
MAX_PATH
]
;
if
(
!
SymFindFileInPath
(
process
NULL
const_cast
<
char
*
>
(
debug_or_code_file
.
c_str
(
)
)
const_cast
<
void
*
>
(
identifier
.
guid_or_signature_pointer
(
)
)
identifier
.
age
(
)
0
identifier
.
type
(
)
=
=
GUIDOrSignatureIdentifier
:
:
TYPE_GUID
?
SSRVOPT_GUIDPTR
:
SSRVOPT_DWORDPTR
path
SymFindFileInPathCallback
this
)
)
{
DWORD
error
=
GetLastError
(
)
;
if
(
error
=
=
ERROR_FILE_NOT_FOUND
)
{
if
(
fail_dns_
|
|
fail_timeout_
)
{
return
LOCATE_RETRY
;
}
if
(
fail_not_found_
)
{
fprintf
(
stderr
"
LocateFile
:
SymFindFileInPath
:
LOCATE_NOT_FOUND
error
"
"
for
%
s
%
s
%
s
\
n
"
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_NOT_FOUND
;
}
}
fprintf
(
stderr
"
LocateFile
:
SymFindFileInPath
:
error
%
d
for
%
s
%
s
%
s
\
n
"
error
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
path
[
MAX_PATH
-
1
]
=
'
\
0
'
;
AutoDeleter
deleter
(
path
)
;
if
(
!
symsrv
.
Cleanup
(
)
)
{
fprintf
(
stderr
"
LocateFile
:
SymCleanup
:
error
%
d
for
%
s
%
s
%
s
\
n
"
GetLastError
(
)
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
deleter
.
Release
(
)
;
printf
(
"
Downloaded
:
%
s
\
n
"
path
)
;
*
file_name
=
path
;
return
LOCATE_SUCCESS
;
}
MSSymbolServerConverter
:
:
LocateResult
MSSymbolServerConverter
:
:
LocatePEFile
(
const
MissingSymbolInfo
&
missing
string
*
pe_file
)
{
return
LocateFile
(
missing
.
code_file
missing
.
code_identifier
missing
.
version
pe_file
)
;
}
MSSymbolServerConverter
:
:
LocateResult
MSSymbolServerConverter
:
:
LocateSymbolFile
(
const
MissingSymbolInfo
&
missing
string
*
symbol_file
)
{
return
LocateFile
(
missing
.
debug_file
missing
.
debug_identifier
missing
.
version
symbol_file
)
;
}
BOOL
CALLBACK
MSSymbolServerConverter
:
:
SymCallback
(
HANDLE
process
ULONG
action
ULONG64
data
ULONG64
context
)
{
MSSymbolServerConverter
*
self
=
reinterpret_cast
<
MSSymbolServerConverter
*
>
(
context
)
;
switch
(
action
)
{
case
CBA_EVENT
:
{
IMAGEHLP_CBA_EVENT
*
cba_event
=
reinterpret_cast
<
IMAGEHLP_CBA_EVENT
*
>
(
data
)
;
string
desc
(
cba_event
-
>
desc
)
;
struct
desc_action
{
const
char
*
desc
;
bool
*
action
;
}
;
static
const
desc_action
desc_actions
[
]
=
{
{
"
SYMSRV
:
The
server
name
or
address
could
not
be
resolved
\
n
"
&
self
-
>
fail_dns_
}
{
"
SYMSRV
:
A
connection
with
the
server
could
not
be
established
\
n
"
&
self
-
>
fail_timeout_
}
{
"
SYMSRV
:
The
operation
timed
out
\
n
"
&
self
-
>
fail_timeout_
}
{
"
not
found
\
n
"
&
self
-
>
fail_not_found_
}
}
;
for
(
int
desc_action_index
=
0
;
desc_action_index
<
sizeof
(
desc_actions
)
/
sizeof
(
desc_action
)
;
+
+
desc_action_index
)
{
if
(
desc
.
find
(
desc_actions
[
desc_action_index
]
.
desc
)
!
=
string
:
:
npos
)
{
*
(
desc_actions
[
desc_action_index
]
.
action
)
=
true
;
break
;
}
}
break
;
}
}
return
FALSE
;
}
BOOL
CALLBACK
MSSymbolServerConverter
:
:
SymFindFileInPathCallback
(
const
char
*
filename
void
*
context
)
{
return
FALSE
;
}
MSSymbolServerConverter
:
:
LocateResult
MSSymbolServerConverter
:
:
LocateAndConvertSymbolFile
(
const
MissingSymbolInfo
&
missing
bool
keep_symbol_file
bool
keep_pe_file
string
*
converted_symbol_file
string
*
symbol_file
string
*
out_pe_file
)
{
assert
(
converted_symbol_file
)
;
converted_symbol_file
-
>
clear
(
)
;
if
(
symbol_file
)
{
symbol_file
-
>
clear
(
)
;
}
string
pdb_file
;
LocateResult
result
=
LocateSymbolFile
(
missing
&
pdb_file
)
;
if
(
result
!
=
LOCATE_SUCCESS
)
{
return
result
;
}
if
(
symbol_file
&
&
keep_symbol_file
)
{
*
symbol_file
=
pdb_file
;
}
string
pe_file
;
result
=
LocatePEFile
(
missing
&
pe_file
)
;
if
(
result
!
=
LOCATE_SUCCESS
)
{
fprintf
(
stderr
"
WARNING
:
Could
not
download
:
%
s
\
n
"
pe_file
.
c_str
(
)
)
;
}
if
(
out_pe_file
&
&
keep_pe_file
)
{
*
out_pe_file
=
pe_file
;
}
AutoDeleter
pdb_deleter
(
pdb_file
)
;
AutoDeleter
pe_deleter
(
pe_file
)
;
string
pdb_extension
=
pdb_file
.
substr
(
pdb_file
.
length
(
)
-
4
)
;
if
(
_stricmp
(
pdb_extension
.
c_str
(
)
"
.
pdb
"
)
!
=
0
)
{
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
no
.
pdb
extension
for
%
s
%
s
%
s
%
s
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pdb_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
PDBSourceLineWriter
writer
;
wstring
pe_file_w
;
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
pe_file
&
pe_file_w
)
)
{
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
WindowsStringUtils
:
:
safe_mbstowcs
failed
for
%
s
\
n
"
pe_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
wstring
pdb_file_w
;
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
pdb_file
&
pdb_file_w
)
)
{
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
WindowsStringUtils
:
:
safe_mbstowcs
failed
for
%
s
\
n
"
pdb_file_w
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
!
writer
.
Open
(
pdb_file_w
PDBSourceLineWriter
:
:
PDB_FILE
)
)
{
fprintf
(
stderr
"
ERROR
:
PDBSourceLineWriter
:
:
Open
failed
for
%
s
%
s
%
s
%
ws
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pdb_file_w
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
!
writer
.
SetCodeFile
(
pe_file_w
)
)
{
fprintf
(
stderr
"
ERROR
:
PDBSourceLineWriter
:
:
SetCodeFile
failed
for
%
s
%
s
%
s
%
ws
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pe_file_w
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
*
converted_symbol_file
=
pdb_file
.
substr
(
0
pdb_file
.
length
(
)
-
4
)
+
"
.
sym
"
;
FILE
*
converted_output
=
NULL
;
#
if
_MSC_VER
>
=
1400
errno_t
err
;
if
(
(
err
=
fopen_s
(
&
converted_output
converted_symbol_file
-
>
c_str
(
)
"
w
"
)
)
!
=
0
)
{
#
else
int
err
;
if
(
!
(
converted_output
=
fopen
(
converted_symbol_file
-
>
c_str
(
)
"
w
"
)
)
)
{
err
=
-
1
;
#
endif
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
fopen_s
:
error
%
d
for
%
s
%
s
%
s
%
s
\
n
"
err
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
converted_symbol_file
-
>
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
AutoDeleter
sym_deleter
(
*
converted_symbol_file
)
;
bool
success
=
writer
.
WriteMap
(
converted_output
)
;
fclose
(
converted_output
)
;
if
(
!
success
)
{
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
PDBSourceLineWriter
:
:
WriteMap
failed
for
%
s
%
s
%
s
%
s
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pdb_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
keep_symbol_file
)
{
pdb_deleter
.
Release
(
)
;
}
if
(
keep_pe_file
)
{
pe_deleter
.
Release
(
)
;
}
sym_deleter
.
Release
(
)
;
return
LOCATE_SUCCESS
;
}
}
