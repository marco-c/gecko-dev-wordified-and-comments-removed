#
include
<
windows
.
h
>
#
include
<
dbghelp
.
h
>
#
include
<
pathcch
.
h
>
#
include
<
cassert
>
#
include
<
cstdio
>
#
include
"
tools
/
windows
/
converter
/
ms_symbol_server_converter
.
h
"
#
include
"
common
/
windows
/
pdb_source_line_writer
.
h
"
#
include
"
common
/
windows
/
pe_source_line_writer
.
h
"
#
include
"
common
/
windows
/
string_utils
-
inl
.
h
"
#
ifndef
SYMOPT_NO_PROMPTS
#
define
SYMOPT_NO_PROMPTS
0x00080000
#
endif
namespace
{
std
:
:
wstring
GetExeDirectory
(
)
{
wchar_t
directory
[
MAX_PATH
]
;
DWORD
result
=
GetModuleFileName
(
nullptr
directory
MAX_PATH
)
;
if
(
result
<
=
0
|
|
result
=
=
MAX_PATH
)
{
fprintf
(
stderr
"
GetExeDirectory
:
failed
to
get
path
to
process
exe
.
\
n
"
)
;
return
L
"
"
;
}
HRESULT
hr
=
PathCchRemoveFileSpec
(
directory
result
+
1
)
;
if
(
hr
!
=
S_OK
)
{
fprintf
(
stderr
"
GetExeDirectory
:
failed
to
remove
basename
from
path
'
%
ls
'
.
\
n
"
directory
)
;
return
L
"
"
;
}
return
std
:
:
wstring
(
directory
)
;
}
}
namespace
google_breakpad
{
#
if
_MSC_VER
>
=
1400
#
define
SSCANF
sscanf_s
#
else
#
define
SSCANF
sscanf
#
endif
bool
GUIDOrSignatureIdentifier
:
:
InitializeFromString
(
const
string
&
identifier
)
{
type_
=
TYPE_NONE
;
size_t
length
=
identifier
.
length
(
)
;
if
(
length
>
32
&
&
length
<
=
40
)
{
if
(
SSCANF
(
identifier
.
c_str
(
)
"
%
08X
%
04hX
%
04hX
%
02hhX
%
02hhX
%
02hhX
%
02hhX
%
02hhX
%
02hhX
%
02hhX
%
02hhX
%
X
"
&
guid_
.
Data1
&
guid_
.
Data2
&
guid_
.
Data3
&
guid_
.
Data4
[
0
]
&
guid_
.
Data4
[
1
]
&
guid_
.
Data4
[
2
]
&
guid_
.
Data4
[
3
]
&
guid_
.
Data4
[
4
]
&
guid_
.
Data4
[
5
]
&
guid_
.
Data4
[
6
]
&
guid_
.
Data4
[
7
]
&
age_
)
!
=
12
)
{
return
false
;
}
type_
=
TYPE_GUID
;
}
else
if
(
length
>
8
&
&
length
<
=
15
)
{
if
(
SSCANF
(
identifier
.
c_str
(
)
"
%
08X
%
x
"
&
signature_
&
age_
)
!
=
2
)
{
return
false
;
}
type_
=
TYPE_SIGNATURE
;
}
else
{
return
false
;
}
return
true
;
}
#
undef
SSCANF
MSSymbolServerConverter
:
:
MSSymbolServerConverter
(
const
string
&
local_cache
const
vector
<
string
>
&
symbol_servers
)
:
symbol_path_
(
)
fail_dns_
(
false
)
fail_timeout_
(
false
)
fail_not_found_
(
false
)
{
assert
(
symbol_servers
.
size
(
)
>
0
)
;
#
if
!
defined
(
NDEBUG
)
const
char
kInvalidCharacters
[
]
=
"
*
;
"
;
assert
(
local_cache
.
find_first_of
(
kInvalidCharacters
)
=
=
string
:
:
npos
)
;
#
endif
for
(
vector
<
string
>
:
:
const_iterator
symbol_server
=
symbol_servers
.
begin
(
)
;
symbol_server
!
=
symbol_servers
.
end
(
)
;
+
+
symbol_server
)
{
assert
(
(
*
symbol_server
)
.
find_first_of
(
kInvalidCharacters
)
=
=
string
:
:
npos
)
;
symbol_path_
+
=
"
srv
*
"
+
local_cache
+
"
*
"
+
*
symbol_server
+
"
;
"
;
}
symbol_path_
.
erase
(
symbol_path_
.
length
(
)
-
1
)
;
}
class
AutoSymSrv
{
public
:
AutoSymSrv
(
)
:
initialized_
(
false
)
{
}
~
AutoSymSrv
(
)
{
if
(
!
Cleanup
(
)
)
{
fprintf
(
stderr
"
~
AutoSymSrv
:
SymCleanup
:
error
%
lu
\
n
"
GetLastError
(
)
)
;
}
}
bool
Initialize
(
HANDLE
process
char
*
path
bool
invade_process
)
{
process_
=
process
;
static
HMODULE
dbghelp_module
=
[
]
(
)
-
>
HMODULE
{
std
:
:
wstring
exe_directory
=
GetExeDirectory
(
)
;
if
(
exe_directory
.
empty
(
)
)
{
return
nullptr
;
}
std
:
:
wstring
dbghelp_path
=
exe_directory
+
L
"
\
\
dbghelp
.
dll
"
;
return
LoadLibrary
(
dbghelp_path
.
c_str
(
)
)
;
}
(
)
;
if
(
dbghelp_module
=
=
nullptr
)
{
fprintf
(
stderr
"
AutoSymSrv
:
:
Initialize
:
failed
to
load
dbghelp
.
dll
beside
exe
.
"
)
;
return
false
;
}
initialized_
=
SymInitialize
(
process
path
invade_process
)
=
=
TRUE
;
return
initialized_
;
}
bool
Cleanup
(
)
{
if
(
initialized_
)
{
if
(
SymCleanup
(
process_
)
)
{
initialized_
=
false
;
return
true
;
}
return
false
;
}
return
true
;
}
private
:
HANDLE
process_
;
bool
initialized_
;
}
;
class
AutoDeleter
{
public
:
explicit
AutoDeleter
(
const
string
&
path
)
:
path_
(
path
)
{
}
~
AutoDeleter
(
)
{
int
error
;
if
(
(
error
=
Delete
(
)
)
!
=
0
)
{
fprintf
(
stderr
"
~
AutoDeleter
:
Delete
:
error
%
d
for
%
s
\
n
"
error
path_
.
c_str
(
)
)
;
}
}
int
Delete
(
)
{
if
(
path_
.
empty
(
)
)
return
0
;
int
error
=
remove
(
path_
.
c_str
(
)
)
;
Release
(
)
;
return
error
;
}
void
Release
(
)
{
path_
.
clear
(
)
;
}
private
:
string
path_
;
}
;
MSSymbolServerConverter
:
:
LocateResult
MSSymbolServerConverter
:
:
LocateFile
(
const
string
&
debug_or_code_file
const
string
&
debug_or_code_id
const
string
&
version
string
*
file_name
)
{
assert
(
file_name
)
;
file_name
-
>
clear
(
)
;
GUIDOrSignatureIdentifier
identifier
;
if
(
!
identifier
.
InitializeFromString
(
debug_or_code_id
)
)
{
fprintf
(
stderr
"
LocateFile
:
Unparseable
identifier
for
%
s
%
s
%
s
\
n
"
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
HANDLE
process
=
GetCurrentProcess
(
)
;
AutoSymSrv
symsrv
;
if
(
!
symsrv
.
Initialize
(
process
const_cast
<
char
*
>
(
symbol_path_
.
c_str
(
)
)
false
)
)
{
fprintf
(
stderr
"
LocateFile
:
SymInitialize
:
error
%
lu
for
%
s
%
s
%
s
\
n
"
GetLastError
(
)
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
!
SymRegisterCallback64
(
process
SymCallback
reinterpret_cast
<
ULONG64
>
(
this
)
)
)
{
fprintf
(
stderr
"
LocateFile
:
SymRegisterCallback64
:
error
%
lu
for
%
s
%
s
%
s
\
n
"
GetLastError
(
)
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
DWORD
options
=
SymGetOptions
(
)
|
SYMOPT_DEBUG
|
SYMOPT_NO_PROMPTS
|
SYMOPT_FAIL_CRITICAL_ERRORS
|
SYMOPT_SECURE
;
SymSetOptions
(
options
)
;
fail_dns_
=
false
;
fail_timeout_
=
false
;
fail_not_found_
=
false
;
char
path
[
MAX_PATH
]
;
if
(
!
SymFindFileInPath
(
process
NULL
const_cast
<
char
*
>
(
debug_or_code_file
.
c_str
(
)
)
const_cast
<
void
*
>
(
identifier
.
guid_or_signature_pointer
(
)
)
identifier
.
age
(
)
0
identifier
.
type
(
)
=
=
GUIDOrSignatureIdentifier
:
:
TYPE_GUID
?
SSRVOPT_GUIDPTR
:
SSRVOPT_DWORDPTR
path
SymFindFileInPathCallback
this
)
)
{
DWORD
error
=
GetLastError
(
)
;
if
(
error
=
=
ERROR_FILE_NOT_FOUND
)
{
if
(
fail_dns_
|
|
fail_timeout_
)
{
return
LOCATE_RETRY
;
}
if
(
fail_not_found_
)
{
fprintf
(
stderr
"
LocateFile
:
SymFindFileInPath
:
LOCATE_NOT_FOUND
error
"
"
for
%
s
%
s
%
s
\
n
"
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_NOT_FOUND
;
}
}
fprintf
(
stderr
"
LocateFile
:
SymFindFileInPath
:
error
%
lu
for
%
s
%
s
%
s
\
n
"
error
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
path
[
MAX_PATH
-
1
]
=
'
\
0
'
;
AutoDeleter
deleter
(
path
)
;
if
(
!
symsrv
.
Cleanup
(
)
)
{
fprintf
(
stderr
"
LocateFile
:
SymCleanup
:
error
%
lu
for
%
s
%
s
%
s
\
n
"
GetLastError
(
)
debug_or_code_file
.
c_str
(
)
debug_or_code_id
.
c_str
(
)
version
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
deleter
.
Release
(
)
;
printf
(
"
Downloaded
:
%
s
\
n
"
path
)
;
*
file_name
=
path
;
return
LOCATE_SUCCESS
;
}
MSSymbolServerConverter
:
:
LocateResult
MSSymbolServerConverter
:
:
LocatePEFile
(
const
MissingSymbolInfo
&
missing
string
*
pe_file
)
{
return
LocateFile
(
missing
.
code_file
missing
.
code_identifier
missing
.
version
pe_file
)
;
}
MSSymbolServerConverter
:
:
LocateResult
MSSymbolServerConverter
:
:
LocateSymbolFile
(
const
MissingSymbolInfo
&
missing
string
*
symbol_file
)
{
return
LocateFile
(
missing
.
debug_file
missing
.
debug_identifier
missing
.
version
symbol_file
)
;
}
BOOL
CALLBACK
MSSymbolServerConverter
:
:
SymCallback
(
HANDLE
process
ULONG
action
ULONG64
data
ULONG64
context
)
{
MSSymbolServerConverter
*
self
=
reinterpret_cast
<
MSSymbolServerConverter
*
>
(
context
)
;
switch
(
action
)
{
case
CBA_EVENT
:
{
IMAGEHLP_CBA_EVENT
*
cba_event
=
reinterpret_cast
<
IMAGEHLP_CBA_EVENT
*
>
(
data
)
;
string
desc
(
cba_event
-
>
desc
)
;
struct
desc_action
{
const
char
*
desc
;
bool
*
action
;
}
;
static
const
desc_action
desc_actions
[
]
=
{
{
"
SYMSRV
:
The
server
name
or
address
could
not
be
resolved
\
n
"
&
self
-
>
fail_dns_
}
{
"
SYMSRV
:
A
connection
with
the
server
could
not
be
established
\
n
"
&
self
-
>
fail_timeout_
}
{
"
SYMSRV
:
The
operation
timed
out
\
n
"
&
self
-
>
fail_timeout_
}
{
"
not
found
\
n
"
&
self
-
>
fail_not_found_
}
}
;
for
(
int
desc_action_index
=
0
;
desc_action_index
<
static_cast
<
int
>
(
sizeof
(
desc_actions
)
/
sizeof
(
desc_action
)
)
;
+
+
desc_action_index
)
{
if
(
desc
.
find
(
desc_actions
[
desc_action_index
]
.
desc
)
!
=
string
:
:
npos
)
{
*
(
desc_actions
[
desc_action_index
]
.
action
)
=
true
;
break
;
}
}
break
;
}
}
return
FALSE
;
}
BOOL
CALLBACK
MSSymbolServerConverter
:
:
SymFindFileInPathCallback
(
const
char
*
filename
void
*
context
)
{
return
FALSE
;
}
MSSymbolServerConverter
:
:
LocateResult
MSSymbolServerConverter
:
:
LocateAndConvertSymbolFile
(
const
MissingSymbolInfo
&
missing
bool
keep_symbol_file
bool
keep_pe_file
string
*
converted_symbol_file
string
*
symbol_file
string
*
out_pe_file
)
{
assert
(
converted_symbol_file
)
;
converted_symbol_file
-
>
clear
(
)
;
if
(
symbol_file
)
{
symbol_file
-
>
clear
(
)
;
}
string
pdb_file
;
LocateResult
result
=
LocateSymbolFile
(
missing
&
pdb_file
)
;
if
(
result
!
=
LOCATE_SUCCESS
)
{
fprintf
(
stderr
"
Fallback
to
PE
-
only
symbol
generation
for
:
%
s
\
n
"
missing
.
debug_file
.
c_str
(
)
)
;
return
LocateAndConvertPEFile
(
missing
keep_pe_file
converted_symbol_file
out_pe_file
)
;
}
if
(
symbol_file
&
&
keep_symbol_file
)
{
*
symbol_file
=
pdb_file
;
}
string
pe_file
;
result
=
LocatePEFile
(
missing
&
pe_file
)
;
if
(
result
!
=
LOCATE_SUCCESS
)
{
fprintf
(
stderr
"
WARNING
:
Could
not
download
:
%
s
\
n
"
pe_file
.
c_str
(
)
)
;
}
if
(
out_pe_file
&
&
keep_pe_file
)
{
*
out_pe_file
=
pe_file
;
}
AutoDeleter
pdb_deleter
(
pdb_file
)
;
AutoDeleter
pe_deleter
(
pe_file
)
;
string
pdb_extension
=
pdb_file
.
substr
(
pdb_file
.
length
(
)
-
4
)
;
if
(
_stricmp
(
pdb_extension
.
c_str
(
)
"
.
pdb
"
)
!
=
0
)
{
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
no
.
pdb
extension
for
%
s
%
s
%
s
%
s
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pdb_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
PDBSourceLineWriter
writer
;
wstring
pe_file_w
;
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
pe_file
&
pe_file_w
)
)
{
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
WindowsStringUtils
:
:
safe_mbstowcs
failed
for
%
s
\
n
"
pe_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
wstring
pdb_file_w
;
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
pdb_file
&
pdb_file_w
)
)
{
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
WindowsStringUtils
:
:
safe_mbstowcs
failed
for
%
ws
\
n
"
pdb_file_w
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
!
writer
.
Open
(
pdb_file_w
PDBSourceLineWriter
:
:
PDB_FILE
)
)
{
fprintf
(
stderr
"
ERROR
:
PDBSourceLineWriter
:
:
Open
failed
for
%
s
%
s
%
s
%
ws
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pdb_file_w
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
!
writer
.
SetCodeFile
(
pe_file_w
)
)
{
fprintf
(
stderr
"
ERROR
:
PDBSourceLineWriter
:
:
SetCodeFile
failed
for
%
s
%
s
%
s
%
ws
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pe_file_w
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
*
converted_symbol_file
=
pdb_file
.
substr
(
0
pdb_file
.
length
(
)
-
4
)
+
"
.
sym
"
;
FILE
*
converted_output
=
NULL
;
#
if
_MSC_VER
>
=
1400
errno_t
err
;
if
(
(
err
=
fopen_s
(
&
converted_output
converted_symbol_file
-
>
c_str
(
)
"
w
"
)
)
!
=
0
)
{
#
else
int
err
;
if
(
!
(
converted_output
=
fopen
(
converted_symbol_file
-
>
c_str
(
)
"
w
"
)
)
)
{
err
=
-
1
;
#
endif
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
fopen_s
:
error
%
d
for
%
s
%
s
%
s
%
s
\
n
"
err
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
converted_symbol_file
-
>
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
AutoDeleter
sym_deleter
(
*
converted_symbol_file
)
;
bool
success
=
writer
.
WriteSymbols
(
converted_output
)
;
fclose
(
converted_output
)
;
if
(
!
success
)
{
fprintf
(
stderr
"
LocateAndConvertSymbolFile
:
"
"
PDBSourceLineWriter
:
:
WriteMap
failed
for
%
s
%
s
%
s
%
s
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pdb_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
keep_symbol_file
)
{
pdb_deleter
.
Release
(
)
;
}
if
(
keep_pe_file
)
{
pe_deleter
.
Release
(
)
;
}
sym_deleter
.
Release
(
)
;
return
LOCATE_SUCCESS
;
}
MSSymbolServerConverter
:
:
LocateResult
MSSymbolServerConverter
:
:
LocateAndConvertPEFile
(
const
MissingSymbolInfo
&
missing
bool
keep_pe_file
string
*
converted_symbol_file
string
*
out_pe_file
)
{
assert
(
converted_symbol_file
)
;
converted_symbol_file
-
>
clear
(
)
;
string
pe_file
;
MSSymbolServerConverter
:
:
LocateResult
result
=
LocatePEFile
(
missing
&
pe_file
)
;
if
(
result
!
=
LOCATE_SUCCESS
)
{
fprintf
(
stderr
"
WARNING
:
Could
not
download
:
%
s
\
n
"
pe_file
.
c_str
(
)
)
;
return
result
;
}
if
(
out_pe_file
&
&
keep_pe_file
)
{
*
out_pe_file
=
pe_file
;
}
AutoDeleter
pe_deleter
(
pe_file
)
;
string
pe_extension
=
pe_file
.
substr
(
pe_file
.
length
(
)
-
4
)
;
if
(
_stricmp
(
pe_extension
.
c_str
(
)
"
.
exe
"
)
!
=
0
&
&
_stricmp
(
pe_extension
.
c_str
(
)
"
.
dll
"
)
!
=
0
)
{
fprintf
(
stderr
"
LocateAndConvertPEFile
:
"
"
no
.
dll
/
.
exe
extension
for
%
s
%
s
%
s
%
s
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pe_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
*
converted_symbol_file
=
pe_file
.
substr
(
0
pe_file
.
length
(
)
-
4
)
+
"
.
sym
"
;
FILE
*
converted_output
=
NULL
;
#
if
_MSC_VER
>
=
1400
errno_t
err
;
if
(
(
err
=
fopen_s
(
&
converted_output
converted_symbol_file
-
>
c_str
(
)
"
w
"
)
)
!
=
0
)
{
#
else
int
err
;
if
(
!
(
converted_output
=
fopen
(
converted_symbol_file
-
>
c_str
(
)
"
w
"
)
)
)
{
err
=
-
1
;
#
endif
fprintf
(
stderr
"
LocateAndConvertPEFile
:
"
"
fopen_s
:
error
%
d
for
%
s
%
s
%
s
%
s
\
n
"
err
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
converted_symbol_file
-
>
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
AutoDeleter
sym_deleter
(
*
converted_symbol_file
)
;
wstring
pe_file_w
;
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
pe_file
&
pe_file_w
)
)
{
fprintf
(
stderr
"
LocateAndConvertPEFile
:
"
"
WindowsStringUtils
:
:
safe_mbstowcs
failed
for
%
s
\
n
"
pe_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
PESourceLineWriter
writer
(
pe_file_w
)
;
PDBModuleInfo
module_info
;
if
(
!
writer
.
GetModuleInfo
(
&
module_info
)
)
{
fprintf
(
stderr
"
LocateAndConvertPEFile
:
"
"
PESourceLineWriter
:
:
GetModuleInfo
failed
for
%
s
%
s
%
s
%
s
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pe_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
module_info
.
cpu
.
compare
(
L
"
x86_64
"
)
!
=
0
)
{
pe_deleter
.
Release
(
)
;
return
LOCATE_FAILURE
;
}
bool
success
=
writer
.
WriteSymbols
(
converted_output
)
;
fclose
(
converted_output
)
;
if
(
!
success
)
{
fprintf
(
stderr
"
LocateAndConvertPEFile
:
"
"
PESourceLineWriter
:
:
WriteMap
failed
for
%
s
%
s
%
s
%
s
\
n
"
missing
.
debug_file
.
c_str
(
)
missing
.
debug_identifier
.
c_str
(
)
missing
.
version
.
c_str
(
)
pe_file
.
c_str
(
)
)
;
return
LOCATE_FAILURE
;
}
if
(
keep_pe_file
)
{
pe_deleter
.
Release
(
)
;
}
sym_deleter
.
Release
(
)
;
return
LOCATE_SUCCESS
;
}
}
