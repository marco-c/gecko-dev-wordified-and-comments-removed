#
include
"
tools
/
windows
/
converter_exe
/
escaping
.
h
"
#
include
<
assert
.
h
>
#
define
kApb
kAsciiPropertyBits
const
unsigned
char
kAsciiPropertyBits
[
256
]
=
{
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x68
0x48
0x48
0x48
0x48
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x40
0x28
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x84
0x84
0x10
0x10
0x10
0x10
0x10
0x10
0x10
0x85
0x85
0x85
0x85
0x85
0x85
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x10
0x10
0x10
0x10
0x10
0x10
0x85
0x85
0x85
0x85
0x85
0x85
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x10
0x10
0x10
0x10
0x40
}
;
static
inline
bool
ascii_isspace
(
unsigned
char
c
)
{
return
!
!
(
kApb
[
c
]
&
0x08
)
;
}
template
<
class
C
>
class
scoped_array
{
public
:
typedef
C
element_type
;
explicit
scoped_array
(
C
*
p
=
NULL
)
:
array_
(
p
)
{
}
~
scoped_array
(
)
{
enum
{
type_must_be_complete
=
sizeof
(
C
)
}
;
delete
[
]
array_
;
}
void
reset
(
C
*
p
=
NULL
)
{
if
(
p
!
=
array_
)
{
enum
{
type_must_be_complete
=
sizeof
(
C
)
}
;
delete
[
]
array_
;
array_
=
p
;
}
}
C
&
operator
[
]
(
std
:
:
ptrdiff_t
i
)
const
{
assert
(
i
>
=
0
)
;
assert
(
array_
!
=
NULL
)
;
return
array_
[
i
]
;
}
C
*
get
(
)
const
{
return
array_
;
}
bool
operator
=
=
(
const
C
*
p
)
const
{
return
array_
=
=
p
;
}
bool
operator
!
=
(
const
C
*
p
)
const
{
return
array_
!
=
p
;
}
void
swap
(
scoped_array
&
p2
)
{
C
*
tmp
=
array_
;
array_
=
p2
.
array_
;
p2
.
array_
=
tmp
;
}
C
*
release
(
)
{
C
*
retVal
=
array_
;
array_
=
NULL
;
return
retVal
;
}
private
:
C
*
array_
;
template
<
class
C2
>
bool
operator
=
=
(
scoped_array
<
C2
>
const
&
p2
)
const
;
template
<
class
C2
>
bool
operator
!
=
(
scoped_array
<
C2
>
const
&
p2
)
const
;
scoped_array
(
const
scoped_array
&
)
;
void
operator
=
(
const
scoped_array
&
)
;
}
;
namespace
strings
{
inline
char
*
string_as_array
(
string
*
str
)
{
return
str
-
>
empty
(
)
?
NULL
:
&
*
str
-
>
begin
(
)
;
}
int
CalculateBase64EscapedLen
(
int
input_len
bool
do_padding
)
{
int
intermediate_result
=
8
*
input_len
+
5
;
assert
(
intermediate_result
>
0
)
;
int
len
=
intermediate_result
/
6
;
if
(
do_padding
)
len
=
(
(
len
+
3
)
/
4
)
*
4
;
return
len
;
}
int
CalculateBase64EscapedLen
(
int
input_len
)
{
return
CalculateBase64EscapedLen
(
input_len
true
)
;
}
int
Base64UnescapeInternal
(
const
char
*
src
int
szsrc
char
*
dest
int
szdest
const
signed
char
*
unbase64
)
{
static
const
char
kPad64
=
'
=
'
;
int
decode
=
0
;
int
destidx
=
0
;
int
state
=
0
;
unsigned
int
ch
=
0
;
unsigned
int
temp
=
0
;
#
define
GET_INPUT
(
label
remain
)
\
label
:
\
-
-
szsrc
;
\
ch
=
*
src
+
+
;
\
decode
=
unbase64
[
ch
]
;
\
if
(
decode
<
0
)
{
\
if
(
ascii_isspace
(
(
char
)
ch
)
&
&
szsrc
>
=
remain
)
\
goto
label
;
\
state
=
4
-
remain
;
\
break
;
\
}
if
(
dest
)
{
while
(
szsrc
>
=
4
)
{
if
(
!
src
[
0
]
|
|
!
src
[
1
]
|
|
!
src
[
2
]
|
|
(
temp
=
(
(
unbase64
[
static_cast
<
int
>
(
src
[
0
]
)
]
<
<
18
)
|
(
unbase64
[
static_cast
<
int
>
(
src
[
1
]
)
]
<
<
12
)
|
(
unbase64
[
static_cast
<
int
>
(
src
[
2
]
)
]
<
<
6
)
|
(
unbase64
[
static_cast
<
int
>
(
src
[
3
]
)
]
)
)
)
&
0x80000000
)
{
GET_INPUT
(
first
4
)
;
temp
=
decode
;
GET_INPUT
(
second
3
)
;
temp
=
(
temp
<
<
6
)
|
decode
;
GET_INPUT
(
third
2
)
;
temp
=
(
temp
<
<
6
)
|
decode
;
GET_INPUT
(
fourth
1
)
;
temp
=
(
temp
<
<
6
)
|
decode
;
}
else
{
szsrc
-
=
4
;
src
+
=
4
;
decode
=
-
1
;
ch
=
'
\
0
'
;
}
if
(
destidx
+
3
>
szdest
)
return
-
1
;
dest
[
destidx
+
2
]
=
(
char
)
temp
;
temp
>
>
=
8
;
dest
[
destidx
+
1
]
=
(
char
)
temp
;
temp
>
>
=
8
;
dest
[
destidx
]
=
(
char
)
temp
;
destidx
+
=
3
;
}
}
else
{
while
(
szsrc
>
=
4
)
{
if
(
!
src
[
0
]
|
|
!
src
[
1
]
|
|
!
src
[
2
]
|
|
(
temp
=
(
(
unbase64
[
static_cast
<
int
>
(
src
[
0
]
)
]
<
<
18
)
|
(
unbase64
[
static_cast
<
int
>
(
src
[
1
]
)
]
<
<
12
)
|
(
unbase64
[
static_cast
<
int
>
(
src
[
2
]
)
]
<
<
6
)
|
(
unbase64
[
static_cast
<
int
>
(
src
[
3
]
)
]
)
)
)
&
0x80000000
)
{
GET_INPUT
(
first_no_dest
4
)
;
GET_INPUT
(
second_no_dest
3
)
;
GET_INPUT
(
third_no_dest
2
)
;
GET_INPUT
(
fourth_no_dest
1
)
;
}
else
{
szsrc
-
=
4
;
src
+
=
4
;
decode
=
-
1
;
ch
=
'
\
0
'
;
}
destidx
+
=
3
;
}
}
#
undef
GET_INPUT
if
(
decode
<
0
&
&
ch
!
=
'
\
0
'
&
&
ch
!
=
kPad64
&
&
!
ascii_isspace
(
(
char
)
ch
)
)
return
-
1
;
if
(
ch
=
=
kPad64
)
{
+
+
szsrc
;
-
-
src
;
}
else
{
while
(
szsrc
>
0
)
{
-
-
szsrc
;
ch
=
*
src
+
+
;
decode
=
unbase64
[
ch
]
;
if
(
decode
<
0
)
{
if
(
ascii_isspace
(
(
char
)
ch
)
)
{
continue
;
}
else
if
(
ch
=
=
'
\
0
'
)
{
break
;
}
else
if
(
ch
=
=
kPad64
)
{
+
+
szsrc
;
-
-
src
;
break
;
}
else
{
return
-
1
;
}
}
temp
=
(
temp
<
<
6
)
|
decode
;
+
+
state
;
if
(
state
=
=
4
)
{
if
(
dest
)
{
if
(
destidx
+
3
>
szdest
)
return
-
1
;
dest
[
destidx
+
2
]
=
(
char
)
temp
;
temp
>
>
=
8
;
dest
[
destidx
+
1
]
=
(
char
)
temp
;
temp
>
>
=
8
;
dest
[
destidx
]
=
(
char
)
temp
;
}
destidx
+
=
3
;
state
=
0
;
temp
=
0
;
}
}
}
int
expected_equals
=
0
;
switch
(
state
)
{
case
0
:
break
;
case
1
:
return
-
1
;
case
2
:
if
(
dest
)
{
if
(
destidx
+
1
>
szdest
)
return
-
1
;
temp
>
>
=
4
;
dest
[
destidx
]
=
(
char
)
temp
;
}
+
+
destidx
;
expected_equals
=
2
;
break
;
case
3
:
if
(
dest
)
{
if
(
destidx
+
2
>
szdest
)
return
-
1
;
temp
>
>
=
2
;
dest
[
destidx
+
1
]
=
(
char
)
temp
;
temp
>
>
=
8
;
dest
[
destidx
]
=
(
char
)
temp
;
}
destidx
+
=
2
;
expected_equals
=
1
;
break
;
default
:
fprintf
(
stdout
"
This
can
'
t
happen
;
base64
decoder
state
=
%
d
"
state
)
;
}
int
equals
=
0
;
while
(
szsrc
>
0
&
&
*
src
)
{
if
(
*
src
=
=
kPad64
)
+
+
equals
;
else
if
(
!
ascii_isspace
(
*
src
)
)
return
-
1
;
-
-
szsrc
;
+
+
src
;
}
return
(
equals
=
=
0
|
|
equals
=
=
expected_equals
)
?
destidx
:
-
1
;
}
int
Base64Unescape
(
const
char
*
src
int
szsrc
char
*
dest
int
szdest
)
{
static
const
signed
char
UnBase64
[
]
=
{
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
62
-
1
-
1
-
1
63
52
53
54
55
56
57
58
59
60
61
-
1
-
1
-
1
-
1
-
1
-
1
-
1
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
-
1
-
1
-
1
-
1
-
1
-
1
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
}
;
return
Base64UnescapeInternal
(
src
szsrc
dest
szdest
UnBase64
)
;
}
bool
Base64Unescape
(
const
char
*
src
int
slen
string
*
dest
)
{
const
int
dest_len
=
3
*
(
slen
/
4
)
+
(
slen
%
4
)
;
dest
-
>
resize
(
dest_len
)
;
const
int
len
=
Base64Unescape
(
src
slen
string_as_array
(
dest
)
dest
-
>
size
(
)
)
;
if
(
len
<
0
)
{
return
false
;
}
assert
(
len
<
=
dest_len
)
;
dest
-
>
resize
(
len
)
;
return
true
;
}
int
Base64EscapeInternal
(
const
unsigned
char
*
src
int
szsrc
char
*
dest
int
szdest
const
char
*
base64
bool
do_padding
)
{
static
const
char
kPad64
=
'
=
'
;
if
(
szsrc
<
=
0
)
return
0
;
char
*
cur_dest
=
dest
;
const
unsigned
char
*
cur_src
=
src
;
while
(
szsrc
>
2
)
{
if
(
(
szdest
-
=
4
)
<
0
)
return
0
;
cur_dest
[
0
]
=
base64
[
cur_src
[
0
]
>
>
2
]
;
cur_dest
[
1
]
=
base64
[
(
(
cur_src
[
0
]
&
0x03
)
<
<
4
)
+
(
cur_src
[
1
]
>
>
4
)
]
;
cur_dest
[
2
]
=
base64
[
(
(
cur_src
[
1
]
&
0x0f
)
<
<
2
)
+
(
cur_src
[
2
]
>
>
6
)
]
;
cur_dest
[
3
]
=
base64
[
cur_src
[
2
]
&
0x3f
]
;
cur_dest
+
=
4
;
cur_src
+
=
3
;
szsrc
-
=
3
;
}
switch
(
szsrc
)
{
case
0
:
break
;
case
1
:
if
(
(
szdest
-
=
2
)
<
0
)
return
0
;
cur_dest
[
0
]
=
base64
[
cur_src
[
0
]
>
>
2
]
;
cur_dest
[
1
]
=
base64
[
(
cur_src
[
0
]
&
0x03
)
<
<
4
]
;
cur_dest
+
=
2
;
if
(
do_padding
)
{
if
(
(
szdest
-
=
2
)
<
0
)
return
0
;
cur_dest
[
0
]
=
kPad64
;
cur_dest
[
1
]
=
kPad64
;
cur_dest
+
=
2
;
}
break
;
case
2
:
if
(
(
szdest
-
=
3
)
<
0
)
return
0
;
cur_dest
[
0
]
=
base64
[
cur_src
[
0
]
>
>
2
]
;
cur_dest
[
1
]
=
base64
[
(
(
cur_src
[
0
]
&
0x03
)
<
<
4
)
+
(
cur_src
[
1
]
>
>
4
)
]
;
cur_dest
[
2
]
=
base64
[
(
cur_src
[
1
]
&
0x0f
)
<
<
2
]
;
cur_dest
+
=
3
;
if
(
do_padding
)
{
if
(
(
szdest
-
=
1
)
<
0
)
return
0
;
cur_dest
[
0
]
=
kPad64
;
cur_dest
+
=
1
;
}
break
;
default
:
fprintf
(
stderr
"
Logic
problem
?
szsrc
=
%
d
"
szsrc
)
;
assert
(
false
)
;
break
;
}
return
(
cur_dest
-
dest
)
;
}
static
const
char
kBase64Chars
[
]
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
"
;
static
const
char
kWebSafeBase64Chars
[
]
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
-
_
"
;
int
Base64Escape
(
const
unsigned
char
*
src
int
szsrc
char
*
dest
int
szdest
)
{
return
Base64EscapeInternal
(
src
szsrc
dest
szdest
kBase64Chars
true
)
;
}
void
Base64Escape
(
const
unsigned
char
*
src
int
szsrc
string
*
dest
bool
do_padding
)
{
const
int
max_escaped_size
=
CalculateBase64EscapedLen
(
szsrc
do_padding
)
;
dest
-
>
clear
(
)
;
dest
-
>
resize
(
max_escaped_size
+
1
'
\
0
'
)
;
const
int
escaped_len
=
Base64EscapeInternal
(
src
szsrc
&
*
dest
-
>
begin
(
)
dest
-
>
size
(
)
kBase64Chars
do_padding
)
;
assert
(
max_escaped_size
<
=
escaped_len
)
;
dest
-
>
resize
(
escaped_len
)
;
}
void
Base64Escape
(
const
string
&
src
string
*
dest
)
{
Base64Escape
(
reinterpret_cast
<
const
unsigned
char
*
>
(
src
.
c_str
(
)
)
src
.
size
(
)
dest
true
)
;
}
int
WebSafeBase64Unescape
(
const
char
*
src
int
szsrc
char
*
dest
int
szdest
)
{
static
const
signed
char
UnBase64
[
]
=
{
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
62
-
1
-
1
52
53
54
55
56
57
58
59
60
61
-
1
-
1
-
1
-
1
-
1
-
1
-
1
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
-
1
-
1
-
1
-
1
63
-
1
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
}
;
return
Base64UnescapeInternal
(
src
szsrc
dest
szdest
UnBase64
)
;
}
bool
WebSafeBase64Unescape
(
const
char
*
src
int
slen
string
*
dest
)
{
int
dest_len
=
3
*
(
slen
/
4
)
+
(
slen
%
4
)
;
dest
-
>
clear
(
)
;
dest
-
>
resize
(
dest_len
)
;
int
len
=
WebSafeBase64Unescape
(
src
slen
&
*
dest
-
>
begin
(
)
dest
-
>
size
(
)
)
;
if
(
len
<
0
)
{
dest
-
>
clear
(
)
;
return
false
;
}
assert
(
len
<
=
dest_len
)
;
dest
-
>
resize
(
len
)
;
return
true
;
}
bool
WebSafeBase64Unescape
(
const
string
&
src
string
*
dest
)
{
return
WebSafeBase64Unescape
(
src
.
data
(
)
src
.
size
(
)
dest
)
;
}
int
WebSafeBase64Escape
(
const
unsigned
char
*
src
int
szsrc
char
*
dest
int
szdest
bool
do_padding
)
{
return
Base64EscapeInternal
(
src
szsrc
dest
szdest
kWebSafeBase64Chars
do_padding
)
;
}
void
WebSafeBase64Escape
(
const
unsigned
char
*
src
int
szsrc
string
*
dest
bool
do_padding
)
{
const
int
max_escaped_size
=
CalculateBase64EscapedLen
(
szsrc
do_padding
)
;
dest
-
>
clear
(
)
;
dest
-
>
resize
(
max_escaped_size
+
1
'
\
0
'
)
;
const
int
escaped_len
=
Base64EscapeInternal
(
src
szsrc
&
*
dest
-
>
begin
(
)
dest
-
>
size
(
)
kWebSafeBase64Chars
do_padding
)
;
assert
(
max_escaped_size
<
=
escaped_len
)
;
dest
-
>
resize
(
escaped_len
)
;
}
void
WebSafeBase64EscapeInternal
(
const
string
&
src
string
*
dest
bool
do_padding
)
{
int
encoded_len
=
CalculateBase64EscapedLen
(
src
.
size
(
)
)
;
scoped_array
<
char
>
buf
(
new
char
[
encoded_len
]
)
;
int
len
=
WebSafeBase64Escape
(
reinterpret_cast
<
const
unsigned
char
*
>
(
src
.
c_str
(
)
)
src
.
size
(
)
buf
.
get
(
)
encoded_len
do_padding
)
;
dest
-
>
assign
(
buf
.
get
(
)
len
)
;
}
void
WebSafeBase64Escape
(
const
string
&
src
string
*
dest
)
{
WebSafeBase64EscapeInternal
(
src
dest
false
)
;
}
void
WebSafeBase64EscapeWithPadding
(
const
string
&
src
string
*
dest
)
{
WebSafeBase64EscapeInternal
(
src
dest
true
)
;
}
}
