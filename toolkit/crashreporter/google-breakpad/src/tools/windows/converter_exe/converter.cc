#
pragma
comment
(
lib
"
winhttp
.
lib
"
)
#
pragma
comment
(
lib
"
wininet
.
lib
"
)
#
pragma
comment
(
lib
"
diaguids
.
lib
"
)
#
pragma
comment
(
lib
"
imagehlp
.
lib
"
)
#
include
<
cassert
>
#
include
<
cstdio
>
#
include
<
ctime
>
#
include
<
map
>
#
include
<
regex
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
tools
/
windows
/
converter_exe
/
escaping
.
h
"
#
include
"
tools
/
windows
/
converter_exe
/
http_download
.
h
"
#
include
"
tools
/
windows
/
converter_exe
/
tokenizer
.
h
"
#
include
"
common
/
windows
/
http_upload
.
h
"
#
include
"
common
/
windows
/
string_utils
-
inl
.
h
"
#
include
"
tools
/
windows
/
converter
/
ms_symbol_server_converter
.
h
"
using
strings
:
:
WebSafeBase64Unescape
;
using
strings
:
:
WebSafeBase64Escape
;
namespace
{
using
std
:
:
map
;
using
std
:
:
string
;
using
std
:
:
vector
;
using
std
:
:
wstring
;
using
crash
:
:
HTTPDownload
;
using
crash
:
:
Tokenizer
;
using
google_breakpad
:
:
HTTPUpload
;
using
google_breakpad
:
:
MissingSymbolInfo
;
using
google_breakpad
:
:
MSSymbolServerConverter
;
using
google_breakpad
:
:
WindowsStringUtils
;
const
char
*
kMissingStringDelimiters
=
"
|
"
;
const
char
*
kLocalCachePath
=
"
c
:
\
\
symbols
"
;
const
char
*
kNoExeMSSSServer
=
"
http
:
/
/
msdl
.
microsoft
.
com
/
download
/
symbols
/
"
;
static
int
FprintfFlush
(
FILE
*
file
const
char
*
format
.
.
.
)
{
va_list
arguments
;
va_start
(
arguments
format
)
;
int
retval
=
vfprintf
(
file
format
arguments
)
;
va_end
(
arguments
)
;
fflush
(
file
)
;
return
retval
;
}
static
string
CurrentDateAndTime
(
)
{
const
string
kUnknownDateAndTime
=
R
"
(
?
?
?
?
-
?
?
-
?
?
?
?
:
?
?
:
?
?
)
"
;
time_t
current_time
;
time
(
&
current_time
)
;
struct
tm
*
time_pointer
;
#
if
_MSC_VER
>
=
1400
struct
tm
time_struct
;
time_pointer
=
&
time_struct
;
if
(
localtime_s
(
time_pointer
&
current_time
)
!
=
0
)
{
return
kUnknownDateAndTime
;
}
#
else
time_pointer
=
localtime
(
&
current_time
)
;
if
(
!
time_pointer
)
{
return
kUnknownDateAndTime
;
}
#
endif
char
buffer
[
256
]
;
if
(
!
strftime
(
buffer
sizeof
(
buffer
)
"
%
Y
-
%
m
-
%
d
%
H
:
%
M
:
%
S
"
time_pointer
)
)
{
return
kUnknownDateAndTime
;
}
return
string
(
buffer
)
;
}
static
bool
ParseMissingString
(
const
string
&
missing_string
MissingSymbolInfo
*
missing_info
)
{
assert
(
missing_info
)
;
vector
<
string
>
tokens
;
Tokenizer
:
:
Tokenize
(
kMissingStringDelimiters
missing_string
&
tokens
)
;
if
(
tokens
.
size
(
)
!
=
5
)
{
return
false
;
}
missing_info
-
>
debug_file
=
tokens
[
0
]
;
missing_info
-
>
debug_identifier
=
tokens
[
1
]
;
missing_info
-
>
version
=
tokens
[
2
]
;
missing_info
-
>
code_file
=
tokens
[
3
]
;
missing_info
-
>
code_identifier
=
tokens
[
4
]
;
return
true
;
}
static
bool
StringMapToWStringMap
(
const
map
<
string
string
>
&
smap
map
<
wstring
wstring
>
*
wsmap
)
{
assert
(
wsmap
)
;
wsmap
-
>
clear
(
)
;
for
(
map
<
string
string
>
:
:
const_iterator
iterator
=
smap
.
begin
(
)
;
iterator
!
=
smap
.
end
(
)
;
+
+
iterator
)
{
wstring
key
;
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
iterator
-
>
first
&
key
)
)
{
FprintfFlush
(
stderr
"
StringMapToWStringMap
:
safe_mbstowcs
failed
for
key
%
s
\
n
"
iterator
-
>
first
.
c_str
(
)
)
;
return
false
;
}
wstring
value
;
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
iterator
-
>
second
&
value
)
)
{
FprintfFlush
(
stderr
"
StringMapToWStringMap
:
safe_mbstowcs
failed
"
"
for
value
%
s
\
n
"
iterator
-
>
second
.
c_str
(
)
)
;
return
false
;
}
wsmap
-
>
insert
(
make_pair
(
key
value
)
)
;
}
return
true
;
}
static
bool
MissingSymbolInfoToParameters
(
const
MissingSymbolInfo
&
missing_info
map
<
wstring
wstring
>
*
wparameters
)
{
assert
(
wparameters
)
;
map
<
string
string
>
parameters
;
string
encoded_param
;
parameters
[
"
encoded
"
]
=
"
true
"
;
WebSafeBase64Escape
(
missing_info
.
code_file
&
encoded_param
)
;
parameters
[
"
code_file
"
]
=
encoded_param
;
WebSafeBase64Escape
(
missing_info
.
code_identifier
&
encoded_param
)
;
parameters
[
"
code_identifier
"
]
=
encoded_param
;
WebSafeBase64Escape
(
missing_info
.
debug_file
&
encoded_param
)
;
parameters
[
"
debug_file
"
]
=
encoded_param
;
WebSafeBase64Escape
(
missing_info
.
debug_identifier
&
encoded_param
)
;
parameters
[
"
debug_identifier
"
]
=
encoded_param
;
if
(
!
missing_info
.
version
.
empty
(
)
)
{
WebSafeBase64Escape
(
missing_info
.
version
&
encoded_param
)
;
parameters
[
"
version
"
]
=
encoded_param
;
}
WebSafeBase64Escape
(
"
WinSymConv
"
&
encoded_param
)
;
parameters
[
"
product
"
]
=
encoded_param
;
if
(
!
StringMapToWStringMap
(
parameters
wparameters
)
)
{
return
false
;
}
return
true
;
}
static
bool
UploadSymbolFile
(
const
wstring
&
upload_symbol_url
const
MissingSymbolInfo
&
missing_info
const
string
&
converted_file
)
{
map
<
wstring
wstring
>
parameters
;
if
(
!
MissingSymbolInfoToParameters
(
missing_info
&
parameters
)
)
{
return
false
;
}
wstring
converted_file_w
;
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
converted_file
&
converted_file_w
)
)
{
FprintfFlush
(
stderr
"
UploadSymbolFile
:
safe_mbstowcs
failed
for
%
s
\
n
"
converted_file
.
c_str
(
)
)
;
return
false
;
}
map
<
wstring
wstring
>
files
;
files
[
L
"
symbol_file
"
]
=
converted_file_w
;
FprintfFlush
(
stderr
"
Uploading
%
s
\
n
"
converted_file
.
c_str
(
)
)
;
if
(
!
HTTPUpload
:
:
SendMultipartPostRequest
(
upload_symbol_url
parameters
files
NULL
NULL
NULL
)
)
{
FprintfFlush
(
stderr
"
UploadSymbolFile
:
HTTPUpload
:
:
SendRequest
failed
"
"
for
%
s
%
s
%
s
\
n
"
missing_info
.
debug_file
.
c_str
(
)
missing_info
.
debug_identifier
.
c_str
(
)
missing_info
.
version
.
c_str
(
)
)
;
return
false
;
}
return
true
;
}
static
bool
SendFetchFailedPing
(
const
wstring
&
fetch_symbol_failure_url
const
MissingSymbolInfo
&
missing_info
)
{
map
<
wstring
wstring
>
parameters
;
if
(
!
MissingSymbolInfoToParameters
(
missing_info
&
parameters
)
)
{
return
false
;
}
string
content
;
if
(
!
HTTPDownload
:
:
Download
(
fetch_symbol_failure_url
&
parameters
&
content
NULL
)
)
{
FprintfFlush
(
stderr
"
SendFetchFailedPing
:
HTTPDownload
:
:
Download
failed
"
"
for
%
s
%
s
%
s
\
n
"
missing_info
.
debug_file
.
c_str
(
)
missing_info
.
debug_identifier
.
c_str
(
)
missing_info
.
version
.
c_str
(
)
)
;
return
false
;
}
return
true
;
}
static
bool
SafeToMakeExternalRequest
(
const
MissingSymbolInfo
&
missing_info
std
:
:
regex
blacklist_regex
)
{
string
file_name
=
missing_info
.
debug_file
;
if
(
std
:
:
regex_search
(
file_name
blacklist_regex
)
)
{
FprintfFlush
(
stderr
"
Not
safe
to
make
external
request
for
file
%
s
\
n
"
file_name
.
c_str
(
)
)
;
return
false
;
}
return
true
;
}
struct
ConverterOptions
{
ConverterOptions
(
)
:
report_fetch_failures
(
true
)
{
}
~
ConverterOptions
(
)
{
}
vector
<
string
>
full_internal_msss_servers
;
vector
<
string
>
full_external_msss_servers
;
vector
<
string
>
no_exe_internal_msss_servers
;
vector
<
string
>
no_exe_external_msss_servers
;
string
local_cache_path
;
wstring
upload_symbols_url
;
wstring
missing_symbols_url
;
wstring
fetch_symbol_failure_url
;
bool
report_fetch_failures
;
string
missing_symbols_file
;
std
:
:
regex
blacklist_regex
;
private
:
ConverterOptions
(
const
ConverterOptions
&
)
;
ConverterOptions
&
operator
=
(
const
ConverterOptions
&
)
;
}
;
static
void
ConvertMissingSymbolFile
(
const
MissingSymbolInfo
&
missing_info
const
ConverterOptions
&
options
)
{
string
time_string
=
CurrentDateAndTime
(
)
;
FprintfFlush
(
stdout
"
converter
:
%
s
:
attempting
%
s
%
s
%
s
\
n
"
time_string
.
c_str
(
)
missing_info
.
debug_file
.
c_str
(
)
missing_info
.
debug_identifier
.
c_str
(
)
missing_info
.
version
.
c_str
(
)
)
;
vector
<
string
>
msss_servers
=
options
.
full_internal_msss_servers
;
bool
is_exe
=
false
;
if
(
missing_info
.
code_file
.
length
(
)
>
=
4
)
{
string
code_extension
=
missing_info
.
code_file
.
substr
(
missing_info
.
code_file
.
size
(
)
-
4
)
;
if
(
_stricmp
(
code_extension
.
c_str
(
)
"
.
exe
"
)
=
=
0
&
&
_stricmp
(
missing_info
.
code_file
.
c_str
(
)
"
firefox
.
exe
"
)
!
=
0
)
{
is_exe
=
true
;
}
}
if
(
!
is_exe
)
{
msss_servers
.
insert
(
msss_servers
.
end
(
)
options
.
no_exe_internal_msss_servers
.
begin
(
)
options
.
no_exe_internal_msss_servers
.
end
(
)
)
;
}
MSSymbolServerConverter
:
:
LocateResult
located
=
MSSymbolServerConverter
:
:
LOCATE_FAILURE
;
string
converted_file
;
if
(
msss_servers
.
size
(
)
>
0
)
{
FprintfFlush
(
stderr
"
Making
internal
request
for
%
s
(
%
s
)
\
n
"
missing_info
.
debug_file
.
c_str
(
)
missing_info
.
debug_identifier
.
c_str
(
)
)
;
MSSymbolServerConverter
converter
(
options
.
local_cache_path
msss_servers
)
;
located
=
converter
.
LocateAndConvertSymbolFile
(
missing_info
false
false
&
converted_file
NULL
NULL
)
;
switch
(
located
)
{
case
MSSymbolServerConverter
:
:
LOCATE_SUCCESS
:
FprintfFlush
(
stderr
"
LocateResult
=
LOCATE_SUCCESS
\
n
"
)
;
UploadSymbolFile
(
options
.
upload_symbols_url
missing_info
converted_file
)
;
remove
(
converted_file
.
c_str
(
)
)
;
break
;
case
MSSymbolServerConverter
:
:
LOCATE_NOT_FOUND
:
FprintfFlush
(
stderr
"
LocateResult
=
LOCATE_NOT_FOUND
\
n
"
)
;
break
;
case
MSSymbolServerConverter
:
:
LOCATE_RETRY
:
FprintfFlush
(
stderr
"
LocateResult
=
LOCATE_RETRY
\
n
"
)
;
break
;
case
MSSymbolServerConverter
:
:
LOCATE_FAILURE
:
FprintfFlush
(
stderr
"
LocateResult
=
LOCATE_FAILURE
\
n
"
)
;
break
;
default
:
FprintfFlush
(
stderr
"
FATAL
:
Unexpected
return
value
'
%
d
'
from
"
"
LocateAndConvertSymbolFile
(
)
\
n
"
located
)
;
assert
(
0
)
;
break
;
}
}
else
{
}
if
(
located
!
=
MSSymbolServerConverter
:
:
LOCATE_SUCCESS
&
&
SafeToMakeExternalRequest
(
missing_info
options
.
blacklist_regex
)
)
{
msss_servers
=
options
.
full_external_msss_servers
;
if
(
!
is_exe
)
{
msss_servers
.
insert
(
msss_servers
.
end
(
)
options
.
no_exe_external_msss_servers
.
begin
(
)
options
.
no_exe_external_msss_servers
.
end
(
)
)
;
}
if
(
msss_servers
.
size
(
)
>
0
)
{
FprintfFlush
(
stderr
"
Making
external
request
for
%
s
(
%
s
)
\
n
"
missing_info
.
debug_file
.
c_str
(
)
missing_info
.
debug_identifier
.
c_str
(
)
)
;
MSSymbolServerConverter
external_converter
(
options
.
local_cache_path
msss_servers
)
;
located
=
external_converter
.
LocateAndConvertSymbolFile
(
missing_info
false
false
&
converted_file
NULL
NULL
)
;
}
else
{
FprintfFlush
(
stderr
"
ERROR
:
No
suitable
external
symbol
servers
.
\
n
"
)
;
}
}
switch
(
located
)
{
case
MSSymbolServerConverter
:
:
LOCATE_SUCCESS
:
FprintfFlush
(
stderr
"
LocateResult
=
LOCATE_SUCCESS
\
n
"
)
;
UploadSymbolFile
(
options
.
upload_symbols_url
missing_info
converted_file
)
;
remove
(
converted_file
.
c_str
(
)
)
;
break
;
case
MSSymbolServerConverter
:
:
LOCATE_NOT_FOUND
:
if
(
!
options
.
report_fetch_failures
)
{
FprintfFlush
(
stderr
"
SendFetchFailedPing
skipped
\
n
"
)
;
}
else
if
(
SendFetchFailedPing
(
options
.
fetch_symbol_failure_url
missing_info
)
)
{
FprintfFlush
(
stderr
"
SendFetchFailedPing
succeeded
\
n
"
)
;
}
else
{
FprintfFlush
(
stderr
"
SendFetchFailedPing
failed
\
n
"
)
;
}
break
;
case
MSSymbolServerConverter
:
:
LOCATE_RETRY
:
FprintfFlush
(
stderr
"
LocateResult
=
LOCATE_RETRY
\
n
"
)
;
FprintfFlush
(
stderr
"
ConvertMissingSymbolFile
:
deferring
retry
"
"
for
%
s
%
s
%
s
\
n
"
missing_info
.
debug_file
.
c_str
(
)
missing_info
.
debug_identifier
.
c_str
(
)
missing_info
.
version
.
c_str
(
)
)
;
break
;
case
MSSymbolServerConverter
:
:
LOCATE_FAILURE
:
FprintfFlush
(
stderr
"
LocateResult
=
LOCATE_FAILURE
\
n
"
)
;
if
(
!
options
.
report_fetch_failures
)
{
FprintfFlush
(
stderr
"
SendFetchFailedPing
skipped
\
n
"
)
;
}
else
if
(
SendFetchFailedPing
(
options
.
fetch_symbol_failure_url
missing_info
)
)
{
FprintfFlush
(
stderr
"
SendFetchFailedPing
succeeded
\
n
"
)
;
}
else
{
FprintfFlush
(
stderr
"
SendFetchFailedPing
failed
\
n
"
)
;
}
break
;
default
:
FprintfFlush
(
stderr
"
FATAL
:
Unexpected
return
value
'
%
d
'
from
"
"
LocateAndConvertSymbolFile
(
)
\
n
"
located
)
;
assert
(
0
)
;
break
;
}
}
static
bool
ReadFile
(
string
file_name
string
*
contents
)
{
char
buffer
[
1024
*
8
]
;
FILE
*
fp
=
fopen
(
file_name
.
c_str
(
)
"
rt
"
)
;
if
(
!
fp
)
{
return
false
;
}
contents
-
>
clear
(
)
;
while
(
fgets
(
buffer
sizeof
(
buffer
)
fp
)
!
=
NULL
)
{
contents
-
>
append
(
buffer
)
;
}
fclose
(
fp
)
;
return
true
;
}
static
bool
ConvertMissingSymbolsList
(
const
ConverterOptions
&
options
)
{
map
<
wstring
wstring
>
parameters
;
parameters
[
L
"
product
"
]
=
L
"
WinSymConv
"
;
parameters
[
L
"
encoded
"
]
=
L
"
true
"
;
string
missing_symbol_list
;
if
(
!
options
.
missing_symbols_file
.
empty
(
)
)
{
if
(
!
ReadFile
(
options
.
missing_symbols_file
&
missing_symbol_list
)
)
{
return
false
;
}
}
else
if
(
!
HTTPDownload
:
:
Download
(
options
.
missing_symbols_url
&
parameters
&
missing_symbol_list
NULL
)
)
{
return
false
;
}
vector
<
string
>
missing_symbol_lines
;
Tokenizer
:
:
Tokenize
(
"
\
n
"
missing_symbol_list
&
missing_symbol_lines
)
;
FprintfFlush
(
stderr
"
Found
%
d
missing
symbol
files
in
list
.
\
n
"
missing_symbol_lines
.
size
(
)
-
1
)
;
int
convert_attempts
=
0
;
for
(
vector
<
string
>
:
:
const_iterator
iterator
=
missing_symbol_lines
.
begin
(
)
;
iterator
!
=
missing_symbol_lines
.
end
(
)
;
+
+
iterator
)
{
const
string
&
encoded_line
=
*
iterator
;
if
(
encoded_line
.
empty
(
)
)
{
continue
;
}
string
line
;
if
(
!
WebSafeBase64Unescape
(
encoded_line
&
line
)
)
{
line
=
encoded_line
;
}
FprintfFlush
(
stderr
"
\
nLine
:
%
s
\
n
"
line
.
c_str
(
)
)
;
MissingSymbolInfo
missing_info
;
if
(
!
ParseMissingString
(
line
&
missing_info
)
)
{
FprintfFlush
(
stderr
"
ConvertMissingSymbols
:
ParseMissingString
failed
"
"
for
%
s
from
%
ws
\
n
"
line
.
c_str
(
)
options
.
missing_symbols_url
.
c_str
(
)
)
;
continue
;
}
+
+
convert_attempts
;
ConvertMissingSymbolFile
(
missing_info
options
)
;
}
if
(
convert_attempts
=
=
0
)
{
string
current_time
=
CurrentDateAndTime
(
)
;
FprintfFlush
(
stdout
"
converter
:
%
s
:
nothing
to
convert
\
n
"
current_time
.
c_str
(
)
)
;
}
return
true
;
}
static
int
usage
(
const
char
*
program_name
)
{
FprintfFlush
(
stderr
"
usage
:
%
s
[
options
]
\
n
"
"
-
f
<
full_msss_server
>
MS
servers
to
ask
for
all
symbols
\
n
"
"
-
n
<
no_exe_msss_server
>
same
but
prevent
asking
for
EXEs
\
n
"
"
-
l
<
local_cache_path
>
Temporary
local
storage
for
symbols
\
n
"
"
-
s
<
upload_url
>
URL
for
uploading
symbols
\
n
"
"
-
m
<
missing_symbols_url
>
URL
to
fetch
list
of
missing
symbols
\
n
"
"
-
mf
<
missing_symbols_file
>
File
containing
the
list
of
missing
\
n
"
"
symbols
.
Fetch
failures
are
not
\
n
"
"
reported
if
such
file
is
provided
.
\
n
"
"
-
t
<
fetch_failure_url
>
URL
to
report
symbol
fetch
failure
\
n
"
"
-
b
<
regex
>
Regex
used
to
blacklist
files
to
\
n
"
"
prevent
external
symbol
requests
\
n
"
"
Note
that
any
server
specified
by
-
f
or
-
n
that
starts
with
\
\
filer
\
n
"
"
will
be
treated
as
internal
and
all
others
as
external
.
\
n
"
program_name
)
;
return
1
;
}
static
bool
IsInternalServer
(
const
string
&
server_name
)
{
if
(
server_name
.
find
(
"
\
\
\
\
filer
\
\
"
)
=
=
0
)
{
return
true
;
}
return
false
;
}
static
void
AddServer
(
const
string
&
server_name
vector
<
string
>
*
internal_servers
vector
<
string
>
*
external_servers
)
{
if
(
IsInternalServer
(
server_name
)
)
{
internal_servers
-
>
push_back
(
server_name
)
;
}
else
{
external_servers
-
>
push_back
(
server_name
)
;
}
}
}
int
main
(
int
argc
char
*
*
argv
)
{
string
time_string
=
CurrentDateAndTime
(
)
;
FprintfFlush
(
stdout
"
converter
:
%
s
:
starting
\
n
"
time_string
.
c_str
(
)
)
;
ConverterOptions
options
;
options
.
report_fetch_failures
=
true
;
if
(
argc
%
2
!
=
1
)
{
return
usage
(
argv
[
0
]
)
;
}
string
blacklist_regex_str
;
bool
have_any_msss_servers
=
false
;
for
(
int
argi
=
1
;
argi
<
argc
;
argi
+
=
2
)
{
string
option
=
argv
[
argi
]
;
string
value
=
argv
[
argi
+
1
]
;
if
(
option
=
=
"
-
f
"
)
{
AddServer
(
value
&
options
.
full_internal_msss_servers
&
options
.
full_external_msss_servers
)
;
have_any_msss_servers
=
true
;
}
else
if
(
option
=
=
"
-
n
"
)
{
AddServer
(
value
&
options
.
no_exe_internal_msss_servers
&
options
.
no_exe_external_msss_servers
)
;
have_any_msss_servers
=
true
;
}
else
if
(
option
=
=
"
-
l
"
)
{
if
(
!
options
.
local_cache_path
.
empty
(
)
)
{
return
usage
(
argv
[
0
]
)
;
}
options
.
local_cache_path
=
value
;
}
else
if
(
option
=
=
"
-
s
"
)
{
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
value
&
options
.
upload_symbols_url
)
)
{
FprintfFlush
(
stderr
"
main
:
safe_mbstowcs
failed
for
%
s
\
n
"
value
.
c_str
(
)
)
;
return
1
;
}
}
else
if
(
option
=
=
"
-
m
"
)
{
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
value
&
options
.
missing_symbols_url
)
)
{
FprintfFlush
(
stderr
"
main
:
safe_mbstowcs
failed
for
%
s
\
n
"
value
.
c_str
(
)
)
;
return
1
;
}
}
else
if
(
option
=
=
"
-
mf
"
)
{
options
.
missing_symbols_file
=
value
;
printf
(
"
Getting
the
list
of
missing
symbols
from
a
file
.
Fetch
failures
"
"
will
not
be
reported
.
\
n
"
)
;
options
.
report_fetch_failures
=
false
;
}
else
if
(
option
=
=
"
-
t
"
)
{
if
(
!
WindowsStringUtils
:
:
safe_mbstowcs
(
value
&
options
.
fetch_symbol_failure_url
)
)
{
FprintfFlush
(
stderr
"
main
:
safe_mbstowcs
failed
for
%
s
\
n
"
value
.
c_str
(
)
)
;
return
1
;
}
}
else
if
(
option
=
=
"
-
b
"
)
{
blacklist_regex_str
=
value
;
}
else
{
return
usage
(
argv
[
0
]
)
;
}
}
if
(
blacklist_regex_str
.
empty
(
)
)
{
FprintfFlush
(
stderr
"
No
blacklist
specified
.
\
n
"
)
;
return
usage
(
argv
[
0
]
)
;
}
options
.
blacklist_regex
=
std
:
:
regex
(
blacklist_regex_str
.
c_str
(
)
std
:
:
regex_constants
:
:
icase
)
;
if
(
!
have_any_msss_servers
)
{
AddServer
(
kNoExeMSSSServer
&
options
.
no_exe_internal_msss_servers
&
options
.
no_exe_external_msss_servers
)
;
}
if
(
options
.
local_cache_path
.
empty
(
)
)
{
options
.
local_cache_path
=
kLocalCachePath
;
}
if
(
options
.
upload_symbols_url
.
empty
(
)
)
{
FprintfFlush
(
stderr
"
No
upload
symbols
URL
specified
.
\
n
"
)
;
return
usage
(
argv
[
0
]
)
;
}
if
(
options
.
missing_symbols_url
.
empty
(
)
&
&
options
.
missing_symbols_file
.
empty
(
)
)
{
FprintfFlush
(
stderr
"
No
missing
symbols
URL
or
file
specified
.
\
n
"
)
;
return
usage
(
argv
[
0
]
)
;
}
if
(
options
.
fetch_symbol_failure_url
.
empty
(
)
)
{
FprintfFlush
(
stderr
"
No
fetch
symbol
failure
URL
specified
.
\
n
"
)
;
return
usage
(
argv
[
0
]
)
;
}
FprintfFlush
(
stdout
"
#
of
Symbol
Servers
(
int
/
ext
)
:
%
d
/
%
d
full
%
d
/
%
d
no_exe
\
n
"
options
.
full_internal_msss_servers
.
size
(
)
options
.
full_external_msss_servers
.
size
(
)
options
.
no_exe_internal_msss_servers
.
size
(
)
options
.
no_exe_external_msss_servers
.
size
(
)
)
;
if
(
!
ConvertMissingSymbolsList
(
options
)
)
{
return
1
;
}
time_string
=
CurrentDateAndTime
(
)
;
FprintfFlush
(
stdout
"
converter
:
%
s
:
finished
\
n
"
time_string
.
c_str
(
)
)
;
return
0
;
}
