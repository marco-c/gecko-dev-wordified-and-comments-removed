package
main
import
(
"
debug
/
macho
"
"
flag
"
"
fmt
"
"
io
"
"
io
/
ioutil
"
"
log
"
"
os
"
"
os
/
exec
"
"
path
"
"
regexp
"
"
strings
"
"
sync
"
"
time
"
)
var
(
breakpadTools
=
flag
.
String
(
"
breakpad
-
tools
"
"
out
/
Release
/
"
"
Path
to
the
Breakpad
tools
directory
containing
dump_syms
and
symupload
.
"
)
uploadOnlyPath
=
flag
.
String
(
"
upload
-
from
"
"
"
"
Upload
a
directory
of
symbol
files
that
has
been
dumped
independently
.
"
)
dumpOnlyPath
=
flag
.
String
(
"
dump
-
to
"
"
"
"
Dump
the
symbols
to
the
specified
directory
but
do
not
upload
them
.
"
)
systemRoot
=
flag
.
String
(
"
system
-
root
"
"
"
"
Path
to
the
root
of
the
Mac
OS
X
system
whose
symbols
will
be
dumped
.
"
)
dumpArchitecture
=
flag
.
String
(
"
arch
"
"
"
"
The
CPU
architecture
for
which
symbols
should
be
dumped
.
If
not
specified
dumps
all
architectures
.
"
)
)
var
(
pathsToScan
=
[
]
string
{
"
/
Library
/
QuickTime
"
"
/
System
/
Library
/
Components
"
"
/
System
/
Library
/
Frameworks
"
"
/
System
/
Library
/
PrivateFrameworks
"
"
/
usr
/
lib
"
}
uploadServers
=
[
]
string
{
"
https
:
/
/
clients2
.
google
.
com
/
cr
/
symbol
"
"
https
:
/
/
clients2
.
google
.
com
/
cr
/
staging_symbol
"
}
blacklistRegexps
=
[
]
*
regexp
.
Regexp
{
regexp
.
MustCompile
(
/
System
/
Library
/
Frameworks
/
Python
\
.
framework
/
)
regexp
.
MustCompile
(
/
System
/
Library
/
Frameworks
/
Ruby
\
.
framework
/
)
regexp
.
MustCompile
(
_profile
\
.
dylib
)
regexp
.
MustCompile
(
_debug
\
.
dylib
)
regexp
.
MustCompile
(
\
.
a
)
regexp
.
MustCompile
(
\
.
dat
)
}
)
func
main
(
)
{
flag
.
Parse
(
)
log
.
SetFlags
(
0
)
var
uq
*
UploadQueue
if
*
uploadOnlyPath
!
=
"
"
{
uq
=
StartUploadQueue
(
)
uploadFromDirectory
(
*
uploadOnlyPath
uq
)
uq
.
Wait
(
)
return
}
if
*
systemRoot
=
=
"
"
{
log
.
Fatal
(
"
Need
a
-
system
-
root
to
dump
symbols
for
"
)
}
if
*
dumpOnlyPath
!
=
"
"
{
if
fi
err
:
=
os
.
Stat
(
*
dumpOnlyPath
)
;
err
!
=
nil
{
log
.
Fatal
(
"
-
dump
-
to
location
:
%
v
"
err
)
}
else
if
!
fi
.
IsDir
(
)
{
log
.
Fatal
(
"
-
dump
-
to
location
is
not
a
directory
"
)
}
}
dumpPath
:
=
*
dumpOnlyPath
if
*
dumpOnlyPath
=
=
"
"
{
uq
=
StartUploadQueue
(
)
if
p
err
:
=
ioutil
.
TempDir
(
"
"
"
upload_system_symbols
"
)
;
err
!
=
nil
{
log
.
Fatal
(
"
Failed
to
create
temporary
directory
:
%
v
"
err
)
}
else
{
dumpPath
=
p
defer
os
.
RemoveAll
(
p
)
}
}
dq
:
=
StartDumpQueue
(
*
systemRoot
dumpPath
uq
)
dq
.
Wait
(
)
if
uq
!
=
nil
{
uq
.
Wait
(
)
}
}
type
WorkerPool
struct
{
wg
sync
.
WaitGroup
}
func
StartWorkerPool
(
numWorkers
int
workerFunc
func
(
)
)
*
WorkerPool
{
p
:
=
new
(
WorkerPool
)
for
i
:
=
0
;
i
<
numWorkers
;
i
+
+
{
p
.
wg
.
Add
(
1
)
go
func
(
)
{
workerFunc
(
)
p
.
wg
.
Done
(
)
}
(
)
}
return
p
}
func
(
p
*
WorkerPool
)
Wait
(
)
{
p
.
wg
.
Wait
(
)
}
type
UploadQueue
struct
{
*
WorkerPool
queue
chan
string
}
func
StartUploadQueue
(
)
*
UploadQueue
{
uq
:
=
&
UploadQueue
{
queue
:
make
(
chan
string
10
)
}
uq
.
WorkerPool
=
StartWorkerPool
(
5
uq
.
worker
)
return
uq
}
func
(
uq
*
UploadQueue
)
Upload
(
filepath
string
)
{
uq
.
queue
<
-
filepath
}
func
(
uq
*
UploadQueue
)
Done
(
)
{
close
(
uq
.
queue
)
}
func
(
uq
*
UploadQueue
)
worker
(
)
{
symUpload
:
=
path
.
Join
(
*
breakpadTools
"
symupload
"
)
for
symfile
:
=
range
uq
.
queue
{
for
_
server
:
=
range
uploadServers
{
for
i
:
=
0
;
i
<
3
;
i
+
+
{
cmd
:
=
exec
.
Command
(
symUpload
symfile
server
)
if
output
err
:
=
cmd
.
Output
(
)
;
err
=
=
nil
{
fmt
.
Printf
(
"
Uploaded
%
s
to
%
s
\
n
"
symfile
server
)
break
}
else
{
log
.
Printf
(
"
Error
running
symupload
(
%
s
%
s
)
attempt
%
d
:
%
v
:
%
s
\
n
"
symfile
server
i
err
output
)
time
.
Sleep
(
1
*
time
.
Second
)
}
}
}
}
}
type
DumpQueue
struct
{
*
WorkerPool
dumpPath
string
queue
chan
dumpRequest
uq
*
UploadQueue
}
type
dumpRequest
struct
{
path
string
arch
string
}
func
StartDumpQueue
(
root
dumpPath
string
uq
*
UploadQueue
)
*
DumpQueue
{
dq
:
=
&
DumpQueue
{
dumpPath
:
dumpPath
queue
:
make
(
chan
dumpRequest
)
uq
:
uq
}
dq
.
WorkerPool
=
StartWorkerPool
(
12
dq
.
worker
)
findLibsInRoot
(
root
dq
)
return
dq
}
func
(
dq
*
DumpQueue
)
DumpSymbols
(
filepath
string
arch
string
)
{
dq
.
queue
<
-
dumpRequest
{
path
:
filepath
arch
:
arch
}
}
func
(
dq
*
DumpQueue
)
Wait
(
)
{
dq
.
WorkerPool
.
Wait
(
)
if
dq
.
uq
!
=
nil
{
dq
.
uq
.
Done
(
)
}
}
func
(
dq
*
DumpQueue
)
done
(
)
{
close
(
dq
.
queue
)
}
func
(
dq
*
DumpQueue
)
worker
(
)
{
dumpSyms
:
=
path
.
Join
(
*
breakpadTools
"
dump_syms
"
)
for
req
:
=
range
dq
.
queue
{
filebase
:
=
path
.
Join
(
dq
.
dumpPath
strings
.
Replace
(
req
.
path
"
/
"
"
_
"
-
1
)
)
symfile
:
=
fmt
.
Sprintf
(
"
%
s_
%
s
.
sym
"
filebase
req
.
arch
)
f
err
:
=
os
.
Create
(
symfile
)
if
err
!
=
nil
{
log
.
Fatal
(
"
Error
creating
symbol
file
:
"
err
)
}
cmd
:
=
exec
.
Command
(
dumpSyms
"
-
a
"
req
.
arch
req
.
path
)
cmd
.
Stdout
=
f
err
=
cmd
.
Run
(
)
f
.
Close
(
)
if
err
!
=
nil
{
os
.
Remove
(
symfile
)
log
.
Printf
(
"
Error
running
dump_syms
(
%
s
%
s
)
:
%
v
\
n
"
req
.
arch
req
.
path
err
)
}
else
if
dq
.
uq
!
=
nil
{
dq
.
uq
.
Upload
(
symfile
)
}
}
}
func
uploadFromDirectory
(
directory
string
uq
*
UploadQueue
)
{
d
err
:
=
os
.
Open
(
directory
)
if
err
!
=
nil
{
log
.
Fatal
(
"
Could
not
open
directory
to
upload
:
%
v
"
err
)
}
defer
d
.
Close
(
)
entries
err
:
=
d
.
Readdirnames
(
0
)
if
err
!
=
nil
{
log
.
Fatal
(
"
Could
not
read
directory
:
%
v
"
err
)
}
for
_
entry
:
=
range
entries
{
uq
.
Upload
(
path
.
Join
(
directory
entry
)
)
}
uq
.
Done
(
)
}
type
findQueue
struct
{
*
WorkerPool
queue
chan
string
dq
*
DumpQueue
}
func
findLibsInRoot
(
root
string
dq
*
DumpQueue
)
{
fq
:
=
&
findQueue
{
queue
:
make
(
chan
string
10
)
dq
:
dq
}
fq
.
WorkerPool
=
StartWorkerPool
(
12
fq
.
worker
)
for
_
p
:
=
range
pathsToScan
{
fq
.
findLibsInPath
(
path
.
Join
(
root
p
)
)
}
close
(
fq
.
queue
)
fq
.
Wait
(
)
dq
.
done
(
)
}
func
(
fq
*
findQueue
)
findLibsInPath
(
loc
string
)
{
d
err
:
=
os
.
Open
(
loc
)
if
err
!
=
nil
{
log
.
Fatal
(
"
Could
not
open
%
s
:
%
v
"
loc
err
)
}
defer
d
.
Close
(
)
for
{
fis
err
:
=
d
.
Readdir
(
100
)
if
err
!
=
nil
&
&
err
!
=
io
.
EOF
{
log
.
Fatal
(
"
Error
reading
directory
%
s
:
%
v
"
loc
err
)
}
for
_
fi
:
=
range
fis
{
fp
:
=
path
.
Join
(
loc
fi
.
Name
(
)
)
if
fi
.
IsDir
(
)
{
fq
.
findLibsInPath
(
fp
)
continue
}
else
if
fi
.
Mode
(
)
&
os
.
ModeSymlink
!
=
0
{
continue
}
fq
.
queue
<
-
fp
}
if
err
=
=
io
.
EOF
{
break
}
}
}
func
(
fq
*
findQueue
)
worker
(
)
{
for
fp
:
=
range
fq
.
queue
{
blacklisted
:
=
false
for
_
re
:
=
range
blacklistRegexps
{
blacklisted
=
blacklisted
|
|
re
.
MatchString
(
fp
)
}
if
blacklisted
{
continue
}
f
err
:
=
os
.
Open
(
fp
)
if
err
!
=
nil
{
log
.
Printf
(
"
%
s
:
%
v
"
fp
err
)
continue
}
fatFile
err
:
=
macho
.
NewFatFile
(
f
)
if
err
=
=
nil
{
for
_
fatArch
:
=
range
fatFile
.
Arches
{
fq
.
dumpMachOFile
(
fp
fatArch
.
File
)
}
fatFile
.
Close
(
)
}
else
if
err
=
=
macho
.
ErrNotFat
{
thinFile
err
:
=
macho
.
NewFile
(
f
)
if
err
!
=
nil
{
log
.
Printf
(
"
%
s
:
%
v
"
fp
err
)
continue
}
fq
.
dumpMachOFile
(
fp
thinFile
)
thinFile
.
Close
(
)
}
else
{
f
.
Close
(
)
}
}
}
func
(
fq
*
findQueue
)
dumpMachOFile
(
fp
string
image
*
macho
.
File
)
{
if
image
.
Type
!
=
MachODylib
&
&
image
.
Type
!
=
MachOBundle
{
return
}
arch
:
=
getArchStringFromHeader
(
image
.
FileHeader
)
if
arch
=
=
"
"
{
return
}
if
(
*
dumpArchitecture
!
=
"
"
&
&
*
dumpArchitecture
=
=
arch
)
|
|
*
dumpArchitecture
=
=
"
"
{
fq
.
dq
.
DumpSymbols
(
fp
arch
)
}
}
