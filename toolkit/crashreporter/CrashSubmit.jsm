const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
KeyValueParser
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
File
"
]
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
CrashSubmit
"
]
;
const
STATE_START
=
Ci
.
nsIWebProgressListener
.
STATE_START
;
const
STATE_STOP
=
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
const
SUCCESS
=
"
success
"
;
const
FAILED
=
"
failed
"
;
const
SUBMITTING
=
"
submitting
"
;
const
UUID_REGEX
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
i
;
function
parseINIStrings
(
path
)
{
let
file
=
new
FileUtils
.
File
(
path
)
;
let
factory
=
Cc
[
"
mozilla
.
org
/
xpcom
/
ini
-
parser
-
factory
;
1
"
]
.
getService
(
Ci
.
nsIINIParserFactory
)
;
let
parser
=
factory
.
createINIParser
(
file
)
;
let
obj
=
{
}
;
let
en
=
parser
.
getKeys
(
"
Strings
"
)
;
while
(
en
.
hasMore
(
)
)
{
let
key
=
en
.
getNext
(
)
;
obj
[
key
]
=
parser
.
getString
(
"
Strings
"
key
)
;
}
return
obj
;
}
async
function
getL10nStrings
(
)
{
let
dirSvc
=
Cc
[
"
mozilla
.
org
/
file
/
directory_service
;
1
"
]
.
getService
(
Ci
.
nsIProperties
)
;
let
path
=
OS
.
Path
.
join
(
dirSvc
.
get
(
"
GreD
"
Ci
.
nsIFile
)
.
path
"
crashreporter
.
ini
"
)
;
let
pathExists
=
await
OS
.
File
.
exists
(
path
)
;
if
(
!
pathExists
)
{
let
parentDir
=
OS
.
Path
.
dirname
(
path
)
;
path
=
OS
.
Path
.
join
(
parentDir
"
MacOS
"
"
crashreporter
.
app
"
"
Contents
"
"
Resources
"
"
crashreporter
.
ini
"
)
;
let
pathExists
=
await
OS
.
File
.
exists
(
path
)
;
if
(
!
pathExists
)
{
return
{
"
crashid
"
:
"
Crash
ID
:
%
s
"
"
reporturl
"
:
"
You
can
view
details
of
this
crash
at
%
s
"
}
;
}
}
let
crstrings
=
parseINIStrings
(
path
)
;
let
strings
=
{
"
crashid
"
:
crstrings
.
CrashID
"
reporturl
"
:
crstrings
.
CrashDetailsURL
}
;
path
=
OS
.
Path
.
join
(
dirSvc
.
get
(
"
XCurProcD
"
Ci
.
nsIFile
)
.
path
"
crashreporter
-
override
.
ini
"
)
;
pathExists
=
await
OS
.
File
.
exists
(
path
)
;
if
(
pathExists
)
{
crstrings
=
parseINIStrings
(
path
)
;
if
(
"
CrashID
"
in
crstrings
)
{
strings
[
"
crashid
"
]
=
crstrings
.
CrashID
;
}
if
(
"
CrashDetailsURL
"
in
crstrings
)
{
strings
[
"
reporturl
"
]
=
crstrings
.
CrashDetailsURL
;
}
}
return
strings
;
}
function
getDir
(
name
)
{
let
dirSvc
=
Cc
[
"
mozilla
.
org
/
file
/
directory_service
;
1
"
]
.
getService
(
Ci
.
nsIProperties
)
;
let
uAppDataPath
=
dirSvc
.
get
(
"
UAppData
"
Ci
.
nsIFile
)
.
path
;
return
OS
.
Path
.
join
(
uAppDataPath
"
Crash
Reports
"
name
)
;
}
async
function
isDirAsync
(
path
)
{
try
{
let
dirInfo
=
await
OS
.
File
.
stat
(
path
)
;
if
(
!
dirInfo
.
isDir
)
{
return
false
;
}
}
catch
(
ex
)
{
return
false
;
}
return
true
;
}
async
function
writeFileAsync
(
dirName
fileName
data
)
{
let
dirPath
=
getDir
(
dirName
)
;
let
filePath
=
OS
.
Path
.
join
(
dirPath
fileName
)
;
await
OS
.
File
.
makeDir
(
dirPath
{
unixFlags
:
OS
.
Constants
.
libc
.
S_IRWXU
}
)
;
await
OS
.
File
.
writeAtomic
(
filePath
data
{
encoding
:
"
utf
-
8
"
}
)
;
}
function
getPendingMinidump
(
id
)
{
let
pendingDir
=
getDir
(
"
pending
"
)
;
return
[
"
.
dmp
"
"
.
extra
"
"
.
memory
.
json
.
gz
"
]
.
map
(
suffix
=
>
{
return
OS
.
Path
.
join
(
pendingDir
{
id
}
{
suffix
}
)
;
}
)
;
}
function
addFormEntry
(
doc
form
name
value
)
{
let
input
=
doc
.
createElement
(
"
input
"
)
;
input
.
type
=
"
hidden
"
;
input
.
name
=
name
;
input
.
value
=
value
;
form
.
appendChild
(
input
)
;
}
async
function
writeSubmittedReportAsync
(
crashID
viewURL
)
{
let
strings
=
await
getL10nStrings
(
)
;
let
data
=
strings
.
crashid
.
replace
(
"
%
s
"
crashID
)
;
if
(
viewURL
)
{
data
+
=
"
\
n
"
+
strings
.
reporturl
.
replace
(
"
%
s
"
viewURL
)
;
}
await
writeFileAsync
(
"
submitted
"
{
crashID
}
.
txt
data
)
;
}
function
Submitter
(
id
recordSubmission
noThrottle
extraExtraKeyVals
)
{
this
.
id
=
id
;
this
.
recordSubmission
=
recordSubmission
;
this
.
noThrottle
=
noThrottle
;
this
.
additionalDumps
=
[
]
;
this
.
extraKeyVals
=
extraExtraKeyVals
|
|
{
}
;
this
.
submitStatusPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
resolveSubmitStatusPromise
=
resolve
;
this
.
rejectSubmitStatusPromise
=
reject
;
}
)
;
}
Submitter
.
prototype
=
{
submitSuccess
:
async
function
Submitter_submitSuccess
(
ret
)
{
await
writeSubmittedReportAsync
(
ret
.
CrashID
ret
.
ViewURL
)
;
try
{
let
toDelete
=
[
this
.
dump
this
.
extra
]
;
if
(
this
.
memory
)
{
toDelete
.
push
(
this
.
memory
)
;
}
for
(
let
dump
of
this
.
additionalDumps
)
{
toDelete
.
push
(
dump
)
;
}
await
Promise
.
all
(
toDelete
.
map
(
path
=
>
{
return
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
}
)
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
this
.
notifyStatus
(
SUCCESS
ret
)
;
this
.
cleanup
(
)
;
}
cleanup
:
function
Submitter_cleanup
(
)
{
this
.
iframe
=
null
;
this
.
dump
=
null
;
this
.
extra
=
null
;
this
.
memory
=
null
;
this
.
additionalDumps
=
null
;
let
idx
=
CrashSubmit
.
_activeSubmissions
.
indexOf
(
this
)
;
if
(
idx
!
=
-
1
)
{
CrashSubmit
.
_activeSubmissions
.
splice
(
idx
1
)
;
}
}
submitForm
:
function
Submitter_submitForm
(
)
{
if
(
!
(
"
ServerURL
"
in
this
.
extraKeyVals
)
)
{
return
false
;
}
let
serverURL
=
this
.
extraKeyVals
.
ServerURL
;
let
envOverride
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
.
get
(
"
MOZ_CRASHREPORTER_URL
"
)
;
if
(
envOverride
!
=
"
"
)
{
serverURL
=
envOverride
;
}
let
xhr
=
Cc
[
"
mozilla
.
org
/
xmlextras
/
xmlhttprequest
;
1
"
]
.
createInstance
(
Ci
.
nsIXMLHttpRequest
)
;
xhr
.
open
(
"
POST
"
serverURL
true
)
;
let
formData
=
Cc
[
"
mozilla
.
org
/
files
/
formdata
;
1
"
]
.
createInstance
(
Ci
.
nsIDOMFormData
)
;
for
(
let
[
name
value
]
of
Object
.
entries
(
this
.
extraKeyVals
)
)
{
if
(
name
!
=
"
ServerURL
"
)
{
formData
.
append
(
name
value
)
;
}
}
if
(
this
.
noThrottle
)
{
formData
.
append
(
"
Throttleable
"
"
0
"
)
;
}
let
promises
=
[
File
.
createFromFileName
(
this
.
dump
)
.
then
(
file
=
>
{
formData
.
append
(
"
upload_file_minidump
"
file
)
;
}
)
]
;
if
(
this
.
memory
)
{
promises
.
push
(
File
.
createFromFileName
(
this
.
memory
)
.
then
(
file
=
>
{
formData
.
append
(
"
memory_report
"
file
)
;
}
)
)
;
}
if
(
this
.
additionalDumps
.
length
>
0
)
{
let
names
=
[
]
;
for
(
let
i
of
this
.
additionalDumps
)
{
names
.
push
(
i
.
name
)
;
promises
.
push
(
File
.
createFromFileName
(
i
.
dump
)
.
then
(
file
=
>
{
formData
.
append
(
"
upload_file_minidump_
"
+
i
.
name
file
)
;
}
)
)
;
}
}
let
manager
=
Services
.
crashmanager
;
let
submissionID
=
manager
.
generateSubmissionID
(
)
;
xhr
.
addEventListener
(
"
readystatechange
"
(
evt
)
=
>
{
if
(
xhr
.
readyState
=
=
4
)
{
let
ret
=
xhr
.
status
=
=
=
200
?
parseKeyValuePairs
(
xhr
.
responseText
)
:
{
}
;
let
submitted
=
!
!
ret
.
CrashID
;
let
p
=
Promise
.
resolve
(
)
;
if
(
this
.
recordSubmission
)
{
let
result
=
submitted
?
manager
.
SUBMISSION_RESULT_OK
:
manager
.
SUBMISSION_RESULT_FAILED
;
p
=
manager
.
addSubmissionResult
(
this
.
id
submissionID
new
Date
(
)
result
)
;
if
(
submitted
)
{
manager
.
setRemoteCrashID
(
this
.
id
ret
.
CrashID
)
;
}
}
p
.
then
(
(
)
=
>
{
if
(
submitted
)
{
this
.
submitSuccess
(
ret
)
;
}
else
{
this
.
notifyStatus
(
FAILED
)
;
this
.
cleanup
(
)
;
}
}
)
;
}
}
)
;
let
p
=
Promise
.
all
(
promises
)
;
let
id
=
this
.
id
;
if
(
this
.
recordSubmission
)
{
p
=
p
.
then
(
(
)
=
>
{
return
manager
.
ensureCrashIsPresent
(
id
)
;
}
)
.
then
(
(
)
=
>
{
return
manager
.
addSubmissionAttempt
(
id
submissionID
new
Date
(
)
)
;
}
)
;
}
p
.
then
(
(
)
=
>
{
xhr
.
send
(
formData
)
;
}
)
;
return
true
;
}
notifyStatus
:
function
Submitter_notify
(
status
ret
)
{
let
propBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag2
)
;
propBag
.
setPropertyAsAString
(
"
minidumpID
"
this
.
id
)
;
if
(
status
=
=
SUCCESS
)
{
propBag
.
setPropertyAsAString
(
"
serverCrashID
"
ret
.
CrashID
)
;
}
let
extraKeyValsBag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag2
)
;
for
(
let
key
in
this
.
extraKeyVals
)
{
extraKeyValsBag
.
setPropertyAsAString
(
key
this
.
extraKeyVals
[
key
]
)
;
}
propBag
.
setPropertyAsInterface
(
"
extra
"
extraKeyValsBag
)
;
Services
.
obs
.
notifyObservers
(
propBag
"
crash
-
report
-
status
"
status
)
;
switch
(
status
)
{
case
SUCCESS
:
this
.
resolveSubmitStatusPromise
(
ret
.
CrashID
)
;
break
;
case
FAILED
:
this
.
rejectSubmitStatusPromise
(
FAILED
)
;
break
;
default
:
}
}
submit
:
async
function
Submitter_submit
(
)
{
let
[
dump
extra
memory
]
=
getPendingMinidump
(
this
.
id
)
;
let
[
dumpExists
extraExists
memoryExists
]
=
await
Promise
.
all
(
[
OS
.
File
.
exists
(
dump
)
OS
.
File
.
exists
(
extra
)
OS
.
File
.
exists
(
memory
)
]
)
;
if
(
!
dumpExists
|
|
!
extraExists
)
{
this
.
notifyStatus
(
FAILED
)
;
this
.
cleanup
(
)
;
return
this
.
submitStatusPromise
;
}
this
.
dump
=
dump
;
this
.
extra
=
extra
;
this
.
memory
=
memoryExists
?
memory
:
null
;
let
extraKeyVals
=
await
parseKeyValuePairsFromFileAsync
(
extra
)
;
for
(
let
key
in
extraKeyVals
)
{
if
(
!
(
key
in
this
.
extraKeyVals
)
)
{
this
.
extraKeyVals
[
key
]
=
extraKeyVals
[
key
]
;
}
}
let
additionalDumps
=
[
]
;
if
(
"
additional_minidumps
"
in
this
.
extraKeyVals
)
{
let
dumpsExistsPromises
=
[
]
;
let
names
=
this
.
extraKeyVals
.
additional_minidumps
.
split
(
"
"
)
;
for
(
let
name
of
names
)
{
let
[
dump
]
=
getPendingMinidump
(
this
.
id
+
"
-
"
+
name
)
;
dumpsExistsPromises
.
push
(
OS
.
File
.
exists
(
dump
)
)
;
additionalDumps
.
push
(
{
name
dump
}
)
;
}
let
dumpsExist
=
await
Promise
.
all
(
dumpsExistsPromises
)
;
let
allDumpsExist
=
dumpsExist
.
every
(
exists
=
>
exists
)
;
if
(
!
allDumpsExist
)
{
this
.
notifyStatus
(
FAILED
)
;
this
.
cleanup
(
)
;
return
this
.
submitStatusPromise
;
}
}
this
.
notifyStatus
(
SUBMITTING
)
;
this
.
additionalDumps
=
additionalDumps
;
if
(
!
(
await
this
.
submitForm
(
)
)
)
{
this
.
notifyStatus
(
FAILED
)
;
this
.
cleanup
(
)
;
}
return
this
.
submitStatusPromise
;
}
}
;
this
.
CrashSubmit
=
{
submit
:
function
CrashSubmit_submit
(
id
params
)
{
params
=
params
|
|
{
}
;
let
recordSubmission
=
false
;
let
noThrottle
=
false
;
let
extraExtraKeyVals
=
null
;
if
(
"
recordSubmission
"
in
params
)
{
recordSubmission
=
params
.
recordSubmission
;
}
if
(
"
noThrottle
"
in
params
)
{
noThrottle
=
params
.
noThrottle
;
}
if
(
"
extraExtraKeyVals
"
in
params
)
{
extraExtraKeyVals
=
params
.
extraExtraKeyVals
;
}
let
submitter
=
new
Submitter
(
id
recordSubmission
noThrottle
extraExtraKeyVals
)
;
CrashSubmit
.
_activeSubmissions
.
push
(
submitter
)
;
return
submitter
.
submit
(
)
;
}
delete
:
async
function
CrashSubmit_delete
(
id
)
{
await
Promise
.
all
(
getPendingMinidump
(
id
)
.
map
(
path
=
>
{
return
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
}
)
)
;
}
ignore
:
async
function
CrashSubmit_ignore
(
id
)
{
let
[
dump
]
=
getPendingMinidump
(
id
)
;
let
file
=
await
OS
.
File
.
open
(
{
dump
}
.
ignore
{
create
:
true
}
{
unixFlags
:
OS
.
Constants
.
libc
.
O_CREAT
}
)
;
await
file
.
close
(
)
;
}
pendingIDs
:
async
function
CrashSubmit_pendingIDs
(
minFileDate
)
{
let
ids
=
[
]
;
let
dirIter
=
null
;
let
pendingDir
=
getDir
(
"
pending
"
)
;
try
{
dirIter
=
new
OS
.
File
.
DirectoryIterator
(
pendingDir
)
;
}
catch
(
ex
)
{
if
(
ex
.
becauseNoSuchFile
)
{
return
ids
;
}
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
try
{
let
entries
=
Object
.
create
(
null
)
;
let
ignored
=
Object
.
create
(
null
)
;
await
dirIter
.
forEach
(
entry
=
>
{
if
(
!
entry
.
isDir
)
{
let
matches
=
entry
.
name
.
match
(
/
(
.
+
)
\
.
dmp
/
)
;
if
(
matches
)
{
let
id
=
matches
[
1
]
;
if
(
UUID_REGEX
.
test
(
id
)
)
{
entries
[
id
]
=
OS
.
File
.
stat
(
entry
.
path
)
;
}
}
else
{
let
matchesIgnore
=
entry
.
name
.
match
(
/
(
.
+
)
\
.
dmp
.
ignore
/
)
;
if
(
matchesIgnore
)
{
let
id
=
matches
[
1
]
;
if
(
UUID_REGEX
.
test
(
id
)
)
{
ignored
[
id
]
=
true
;
}
}
}
}
}
)
;
for
(
let
entry
in
entries
)
{
let
entryInfo
=
await
entries
[
entry
]
;
if
(
!
(
{
entry
}
.
dmp
.
ignore
in
ignored
)
&
&
entryInfo
.
lastAccessDate
>
minFileDate
)
{
ids
.
push
(
entry
)
;
}
}
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
finally
{
dirIter
.
close
(
)
;
}
return
ids
;
}
pruneSavedDumps
:
async
function
CrashSubmit_pruneSavedDumps
(
)
{
const
KEEP
=
10
;
let
dirIter
=
null
;
let
dirEntries
=
[
]
;
let
pendingDir
=
getDir
(
"
pending
"
)
;
try
{
dirIter
=
new
OS
.
File
.
DirectoryIterator
(
pendingDir
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
OS
.
File
.
Error
&
&
ex
.
becauseNoSuchFile
)
{
return
[
]
;
}
throw
ex
;
}
try
{
await
dirIter
.
forEach
(
entry
=
>
{
if
(
!
entry
.
isDir
)
{
let
matches
=
entry
.
name
.
match
(
/
(
.
+
)
\
.
extra
/
)
;
if
(
matches
)
{
dirEntries
.
push
(
{
name
:
entry
.
name
path
:
entry
.
path
infoPromise
:
OS
.
File
.
stat
(
entry
.
path
)
}
)
;
}
}
}
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
throw
ex
;
}
finally
{
dirIter
.
close
(
)
;
}
dirEntries
.
sort
(
async
(
a
b
)
=
>
{
let
dateA
=
(
await
a
.
infoPromise
)
.
lastModificationDate
;
let
dateB
=
(
await
b
.
infoPromise
)
.
lastModificationDate
;
if
(
dateA
<
dateB
)
{
return
-
1
;
}
if
(
dateB
<
dateA
)
{
return
1
;
}
return
0
;
}
)
;
if
(
dirEntries
.
length
>
KEEP
)
{
let
toDelete
=
[
]
;
for
(
let
i
=
0
;
i
<
dirEntries
.
length
-
KEEP
;
+
+
i
)
{
let
extra
=
dirEntries
[
i
]
;
let
matches
=
extra
.
leafName
.
match
(
/
(
.
+
)
\
.
extra
/
)
;
if
(
matches
)
{
let
pathComponents
=
OS
.
Path
.
split
(
extra
.
path
)
;
pathComponents
[
pathComponents
.
length
-
1
]
=
matches
[
1
]
;
let
path
=
OS
.
Path
.
join
(
.
.
.
pathComponents
)
;
toDelete
.
push
(
extra
.
path
{
path
}
.
dmp
{
path
}
.
memory
.
json
.
gz
)
;
}
}
await
Promise
.
all
(
toDelete
.
map
(
path
=
>
{
return
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
}
)
)
;
}
}
_activeSubmissions
:
[
]
}
;
