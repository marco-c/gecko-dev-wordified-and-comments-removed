var
EXPORTED_SYMBOLS
=
[
"
NetErrorChild
"
]
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
AppInfo
:
"
chrome
:
/
/
remote
/
content
/
shared
/
AppInfo
.
sys
.
mjs
"
}
)
;
const
{
RemotePageChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
actors
/
RemotePageChild
.
jsm
"
)
;
class
NetErrorChild
extends
RemotePageChild
{
actorCreated
(
)
{
super
.
actorCreated
(
)
;
const
exportableFunctions
=
[
"
RPMGetAppBuildID
"
"
RPMGetInnerMostURI
"
"
RPMAddToHistogram
"
"
RPMRecordTelemetryEvent
"
"
RPMCheckAlternateHostAvailable
"
"
RPMGetHttpResponseHeader
"
"
RPMIsTRROnlyFailure
"
"
RPMIsFirefox
"
"
RPMIsNativeFallbackFailure
"
"
RPMOpenPreferences
"
"
RPMGetTRRSkipReason
"
"
RPMGetTRRDomain
"
]
;
this
.
exportFunctions
(
exportableFunctions
)
;
}
getFailedCertChain
(
docShell
)
{
let
securityInfo
=
docShell
.
failedChannel
&
&
docShell
.
failedChannel
.
securityInfo
;
if
(
!
securityInfo
)
{
return
[
]
;
}
return
securityInfo
.
failedCertChain
.
map
(
cert
=
>
cert
.
getBase64DERString
(
)
)
;
}
handleEvent
(
aEvent
)
{
let
doc
=
aEvent
.
originalTarget
.
ownerDocument
|
|
aEvent
.
originalTarget
;
switch
(
aEvent
.
type
)
{
case
"
click
"
:
let
elem
=
aEvent
.
originalTarget
;
if
(
elem
.
id
=
=
"
viewCertificate
"
)
{
this
.
sendAsyncMessage
(
"
Browser
:
CertExceptionError
"
{
location
:
doc
.
location
.
href
elementId
:
elem
.
id
failedCertChain
:
this
.
getFailedCertChain
(
doc
.
defaultView
.
docShell
)
}
)
;
}
break
;
}
}
RPMGetInnerMostURI
(
uriString
)
{
let
uri
=
Services
.
io
.
newURI
(
uriString
)
;
if
(
uri
instanceof
Ci
.
nsINestedURI
)
{
uri
=
uri
.
QueryInterface
(
Ci
.
nsINestedURI
)
.
innermostURI
;
}
return
uri
.
spec
;
}
RPMGetAppBuildID
(
)
{
return
Services
.
appinfo
.
appBuildID
;
}
RPMAddToHistogram
(
histID
bin
)
{
Services
.
telemetry
.
getHistogramById
(
histID
)
.
add
(
bin
)
;
}
RPMRecordTelemetryEvent
(
category
event
object
value
extra
)
{
Services
.
telemetry
.
recordEvent
(
category
event
object
value
extra
)
;
}
RPMCheckAlternateHostAvailable
(
)
{
const
host
=
this
.
contentWindow
.
location
.
host
.
trim
(
)
;
const
REGEXP_SINGLE_WORD
=
/
^
[
^
\
s
:
/
?
#
]
+
(
:
\
d
+
)
?
/
;
if
(
!
REGEXP_SINGLE_WORD
.
test
(
host
)
)
{
return
;
}
let
info
=
Services
.
uriFixup
.
forceHttpFixup
(
this
.
contentWindow
.
location
.
href
)
;
if
(
!
info
.
fixupCreatedAlternateURI
&
&
!
info
.
fixupChangedProtocol
)
{
return
;
}
let
{
displayHost
displaySpec
pathQueryRef
}
=
info
.
fixedURI
;
if
(
pathQueryRef
.
endsWith
(
"
/
"
)
)
{
pathQueryRef
=
pathQueryRef
.
slice
(
0
pathQueryRef
.
length
-
1
)
;
}
let
weakDoc
=
Cu
.
getWeakReference
(
this
.
contentWindow
.
document
)
;
let
onLookupCompleteListener
=
{
onLookupComplete
(
request
record
status
)
{
let
doc
=
weakDoc
.
get
(
)
;
if
(
!
doc
|
|
!
Components
.
isSuccessCode
(
status
)
)
{
return
;
}
let
link
=
doc
.
createElement
(
"
a
"
)
;
link
.
href
=
displaySpec
;
link
.
setAttribute
(
"
data
-
l10n
-
name
"
"
website
"
)
;
let
span
=
doc
.
createElement
(
"
span
"
)
;
span
.
appendChild
(
link
)
;
doc
.
l10n
.
setAttributes
(
span
"
neterror
-
dns
-
not
-
found
-
with
-
suggestion
"
{
hostAndPath
:
displayHost
+
pathQueryRef
}
)
;
const
shortDesc
=
doc
.
getElementById
(
"
errorShortDesc
"
)
;
shortDesc
.
textContent
+
=
"
"
;
shortDesc
.
appendChild
(
span
)
;
}
}
;
Services
.
uriFixup
.
checkHost
(
info
.
fixedURI
onLookupCompleteListener
this
.
document
.
nodePrincipal
.
originAttributes
)
;
}
RPMGetHttpResponseHeader
(
responseHeader
)
{
let
channel
=
this
.
contentWindow
.
docShell
.
failedChannel
;
if
(
!
channel
)
{
return
"
"
;
}
let
httpChannel
=
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
if
(
!
httpChannel
)
{
return
"
"
;
}
try
{
return
httpChannel
.
getResponseHeader
(
responseHeader
)
;
}
catch
(
e
)
{
}
return
"
"
;
}
RPMIsTRROnlyFailure
(
)
{
let
channel
=
this
.
contentWindow
?
.
docShell
?
.
failedChannel
?
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
if
(
!
channel
)
{
return
false
;
}
return
channel
.
effectiveTRRMode
=
=
Ci
.
nsIRequest
.
TRR_ONLY_MODE
;
}
RPMIsFirefox
(
)
{
return
lazy
.
AppInfo
.
isFirefox
;
}
RPMIsNativeFallbackFailure
(
)
{
let
channel
=
this
.
contentWindow
?
.
docShell
?
.
failedChannel
?
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
let
value
=
channel
?
.
trrSkipReason
?
?
Ci
.
nsITRRSkipReason
.
TRR_UNSET
;
const
warningReasons
=
new
Set
(
[
Ci
.
nsITRRSkipReason
.
TRR_NOT_CONFIRMED
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_GOOGLE_SAFESEARCH
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_YOUTUBE_SAFESEARCH
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_ZSCALER_CANARY
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_CANARY
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_MODIFIED_ROOTS
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_PARENTAL_CONTROLS
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_THIRD_PARTY_ROOTS
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_ENTERPRISE_POLICY
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_VPN
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_PROXY
Ci
.
nsITRRSkipReason
.
TRR_HEURISTIC_TRIPPED_NRPT
]
)
;
return
(
Services
.
dns
.
currentTrrMode
=
=
Ci
.
nsIRequest
.
TRR_FIRST_MODE
&
&
warningReasons
.
has
(
value
)
)
;
}
RPMGetTRRSkipReason
(
)
{
let
channel
=
this
.
contentWindow
?
.
docShell
?
.
failedChannel
?
.
QueryInterface
(
Ci
.
nsIHttpChannelInternal
)
;
let
value
=
channel
?
.
trrSkipReason
?
?
Ci
.
nsITRRSkipReason
.
TRR_UNSET
;
return
Services
.
dns
.
getTRRSkipReasonName
(
value
)
;
}
RPMGetTRRDomain
(
)
{
return
Services
.
dns
.
trrDomain
;
}
}
