"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserElementParent
"
"
PermitUnloader
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
let
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
unloadTimeoutMs
"
"
dom
.
beforeunload_timeout_ms
"
)
;
const
STATE_WAITING
=
0
;
const
STATE_RUNNING
=
1
;
const
STATE_DONE
=
2
;
class
BrowserElementParent
extends
JSWindowActorParent
{
sendPermitUnload
(
flags
)
{
this
.
sendAsyncMessage
(
"
PermitUnload
"
{
flags
}
)
;
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
Running
"
:
{
PermitUnloader
.
_transitionFrameState
(
this
.
manager
STATE_RUNNING
)
;
break
;
}
case
"
Done
"
:
{
let
permitUnload
=
message
.
data
.
permitUnload
;
if
(
!
permitUnload
)
{
PermitUnloader
.
_doNotPermitUnload
(
this
.
manager
)
;
}
else
{
PermitUnloader
.
_transitionFrameState
(
this
.
manager
STATE_DONE
)
;
}
break
;
}
case
"
DOMWindowClose
"
:
{
if
(
!
this
.
manager
.
browsingContext
.
parent
)
{
let
browser
=
this
.
manager
.
browsingContext
.
embedderElement
;
let
win
=
browser
.
ownerGlobal
;
if
(
browser
.
isRemoteBrowser
)
{
browser
.
dispatchEvent
(
new
win
.
CustomEvent
(
"
DOMWindowClose
"
{
bubbles
:
true
}
)
)
;
}
}
break
;
}
}
}
}
var
PermitUnloader
=
{
inProgressPermitUnload
:
new
WeakMap
(
)
inPermitUnload
(
frameLoader
)
{
return
this
.
inProgressPermitUnload
.
has
(
frameLoader
)
;
}
permitUnload
(
frameLoader
flags
)
{
if
(
this
.
inPermitUnload
(
frameLoader
)
)
{
throw
new
Error
(
"
permitUnload
is
already
running
for
this
tab
.
"
)
;
}
let
frameStates
=
new
Map
(
)
;
let
mm
=
frameLoader
.
messageManager
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
let
roots
=
this
.
getProcessContiguousRoots
(
frameLoader
.
browsingContext
)
;
let
state
=
{
frameStates
timedOut
:
false
permitUnload
:
true
timer
waitingCount
:
roots
.
length
}
;
let
observer
=
subject
=
>
{
if
(
subject
=
=
mm
)
{
this
.
_finish
(
state
)
;
}
}
;
try
{
this
.
inProgressPermitUnload
.
set
(
frameLoader
state
)
;
Services
.
obs
.
addObserver
(
observer
"
message
-
manager
-
close
"
)
;
for
(
let
windowGlobalParent
of
roots
)
{
let
actor
=
windowGlobalParent
.
getActor
(
"
BrowserElement
"
)
;
frameStates
.
set
(
actor
.
manager
STATE_WAITING
)
;
actor
.
sendPermitUnload
(
flags
)
;
}
timer
.
initWithCallback
(
(
)
=
>
{
this
.
_onTimeout
(
frameLoader
)
;
}
unloadTimeoutMs
timer
.
TYPE_ONE_SHOT
)
;
Services
.
tm
.
spinEventLoopUntilOrShutdown
(
(
)
=
>
{
return
this
.
_finishedPermitUnload
(
frameStates
)
;
}
)
;
}
finally
{
this
.
_finish
(
state
)
;
this
.
inProgressPermitUnload
.
delete
(
frameLoader
)
;
Services
.
obs
.
removeObserver
(
observer
"
message
-
manager
-
close
"
)
;
}
return
{
permitUnload
:
state
.
permitUnload
timedOut
:
state
.
timedOut
}
;
}
getProcessContiguousRoots
(
browsingContext
)
{
let
contextsToWalk
=
[
browsingContext
]
;
let
roots
=
[
]
;
while
(
contextsToWalk
.
length
)
{
let
currentContext
=
contextsToWalk
.
pop
(
)
;
let
windowGlobal
=
currentContext
.
currentWindowGlobal
;
if
(
!
windowGlobal
)
{
continue
;
}
if
(
windowGlobal
.
isProcessRoot
)
{
roots
.
push
(
windowGlobal
)
;
}
contextsToWalk
.
push
(
.
.
.
currentContext
.
getChildren
(
)
)
;
}
return
roots
;
}
hasBeforeUnload
(
frameLoader
)
{
if
(
frameLoader
.
remoteTab
)
{
return
frameLoader
.
remoteTab
.
hasBeforeUnload
;
}
return
false
;
}
_transitionFrameState
(
windowGlobal
newFrameState
)
{
let
frameLoader
=
windowGlobal
.
rootFrameLoader
;
let
state
=
this
.
inProgressPermitUnload
.
get
(
frameLoader
)
;
let
oldFrameState
=
state
.
frameStates
.
get
(
windowGlobal
)
;
if
(
oldFrameState
=
=
STATE_WAITING
)
{
state
.
waitingCount
-
-
;
if
(
!
state
.
waitingCount
)
{
state
.
timer
.
cancel
(
)
;
}
}
state
.
frameStates
.
set
(
windowGlobal
newFrameState
)
;
}
_finishedPermitUnload
(
frameStates
)
{
for
(
let
[
state
]
of
frameStates
)
{
if
(
state
!
=
STATE_DONE
)
{
return
false
;
}
}
return
true
;
}
_finish
(
state
)
{
state
.
frameStates
.
clear
(
)
;
state
.
timer
.
cancel
(
)
;
}
_onTimeout
(
frameLoader
)
{
let
state
=
this
.
inProgressPermitUnload
.
get
(
frameLoader
)
;
state
.
timedOut
=
true
;
this
.
_finish
(
state
)
;
Services
.
tm
.
dispatchToMainThread
(
function
(
)
{
}
)
;
}
_doNotPermitUnload
(
windowGlobal
)
{
let
frameLoader
=
windowGlobal
.
rootFrameLoader
;
let
state
=
this
.
inProgressPermitUnload
.
get
(
frameLoader
)
;
if
(
state
)
{
this
.
_finish
(
state
)
;
state
.
permitUnload
=
false
;
}
}
}
;
