"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PrintingChild
"
]
;
const
{
ActorChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ReaderMode
"
"
resource
:
/
/
gre
/
modules
/
ReaderMode
.
jsm
"
)
;
class
PrintingChild
extends
ActorChild
{
get
shouldSavePrintSettings
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
print
.
use_global_printsettings
"
)
&
&
Services
.
prefs
.
getBoolPref
(
"
print
.
save_print_settings
"
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
PrintingError
"
:
{
let
win
=
event
.
target
.
defaultView
;
let
wbp
=
win
.
getInterface
(
Ci
.
nsIWebBrowserPrint
)
;
let
nsresult
=
event
.
detail
;
this
.
mm
.
sendAsyncMessage
(
"
Printing
:
Error
"
{
isPrinting
:
wbp
.
doingPrint
nsresult
}
)
;
break
;
}
case
"
printPreviewUpdate
"
:
{
let
info
=
this
.
printPreviewInitializingInfo
;
if
(
!
info
)
{
return
;
}
if
(
!
info
.
entered
)
{
info
.
entered
=
true
;
this
.
mm
.
sendAsyncMessage
(
"
Printing
:
Preview
:
Entered
"
{
failed
:
false
changingBrowsers
:
info
.
changingBrowsers
}
)
;
if
(
info
.
nextRequest
)
{
Services
.
tm
.
dispatchToMainThread
(
info
.
nextRequest
)
;
}
}
this
.
updatePageCount
(
this
.
mm
)
;
break
;
}
}
}
receiveMessage
(
message
)
{
let
data
=
message
.
data
;
switch
(
message
.
name
)
{
case
"
Printing
:
Preview
:
Enter
"
:
{
this
.
enterPrintPreview
(
Services
.
wm
.
getOuterWindowWithId
(
data
.
windowID
)
data
.
simplifiedMode
data
.
changingBrowsers
data
.
defaultPrinterName
)
;
break
;
}
case
"
Printing
:
Preview
:
Exit
"
:
{
this
.
exitPrintPreview
(
)
;
break
;
}
case
"
Printing
:
Preview
:
Navigate
"
:
{
this
.
navigate
(
data
.
navType
data
.
pageNum
)
;
break
;
}
case
"
Printing
:
Preview
:
ParseDocument
"
:
{
this
.
parseDocument
(
data
.
URL
Services
.
wm
.
getOuterWindowWithId
(
data
.
windowID
)
)
;
break
;
}
case
"
Printing
:
Print
"
:
{
this
.
print
(
Services
.
wm
.
getOuterWindowWithId
(
data
.
windowID
)
data
.
simplifiedMode
data
.
defaultPrinterName
)
;
break
;
}
}
}
getPrintSettings
(
defaultPrinterName
)
{
try
{
let
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
let
printSettings
=
PSSVC
.
globalPrintSettings
;
if
(
!
printSettings
.
printerName
)
{
printSettings
.
printerName
=
defaultPrinterName
;
}
PSSVC
.
initPrintSettingsFromPrinter
(
printSettings
.
printerName
printSettings
)
;
PSSVC
.
initPrintSettingsFromPrefs
(
printSettings
true
printSettings
.
kInitSaveAll
)
;
return
printSettings
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
null
;
}
parseDocument
(
URL
contentWindow
)
{
let
articlePromise
=
ReaderMode
.
parseDocument
(
contentWindow
.
document
)
.
catch
(
Cu
.
reportError
)
;
articlePromise
.
then
(
(
article
)
=
>
{
let
{
mm
}
=
this
;
let
webProgressListener
=
{
onStateChange
(
webProgress
req
flags
status
)
{
if
(
flags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
webProgress
.
removeProgressListener
(
webProgressListener
)
;
let
domUtils
=
contentWindow
.
windowUtils
;
if
(
domUtils
.
isMozAfterPaintPending
)
{
let
onPaint
=
function
(
)
{
mm
.
removeEventListener
(
"
MozAfterPaint
"
onPaint
)
;
mm
.
sendAsyncMessage
(
"
Printing
:
Preview
:
ReaderModeReady
"
)
;
}
;
contentWindow
.
addEventListener
(
"
MozAfterPaint
"
onPaint
)
;
mm
.
setTimeout
(
(
)
=
>
{
mm
.
removeEventListener
(
"
MozAfterPaint
"
onPaint
)
;
mm
.
sendAsyncMessage
(
"
Printing
:
Preview
:
ReaderModeReady
"
)
;
}
100
)
;
}
else
{
mm
.
sendAsyncMessage
(
"
Printing
:
Preview
:
ReaderModeReady
"
)
;
}
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
Ci
.
nsIObserver
]
)
}
;
const
{
content
docShell
}
=
this
.
mm
;
let
webProgress
=
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
webProgress
.
addProgressListener
(
webProgressListener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_REQUEST
)
;
content
.
document
.
head
.
innerHTML
=
"
"
;
let
headBaseElement
=
content
.
document
.
createElement
(
"
base
"
)
;
headBaseElement
.
setAttribute
(
"
href
"
URL
)
;
content
.
document
.
head
.
appendChild
(
headBaseElement
)
;
let
headStyleElement
=
content
.
document
.
createElement
(
"
link
"
)
;
headStyleElement
.
setAttribute
(
"
rel
"
"
stylesheet
"
)
;
headStyleElement
.
setAttribute
(
"
href
"
"
chrome
:
/
/
global
/
skin
/
aboutReader
.
css
"
)
;
headStyleElement
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
content
.
document
.
head
.
appendChild
(
headStyleElement
)
;
headStyleElement
=
content
.
document
.
createElement
(
"
link
"
)
;
headStyleElement
.
setAttribute
(
"
rel
"
"
stylesheet
"
)
;
headStyleElement
.
setAttribute
(
"
href
"
"
chrome
:
/
/
global
/
content
/
simplifyMode
.
css
"
)
;
headStyleElement
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
content
.
document
.
head
.
appendChild
(
headStyleElement
)
;
content
.
document
.
body
.
innerHTML
=
"
"
;
let
containerElement
=
content
.
document
.
createElement
(
"
div
"
)
;
containerElement
.
setAttribute
(
"
id
"
"
container
"
)
;
content
.
document
.
body
.
appendChild
(
containerElement
)
;
if
(
article
)
{
content
.
document
.
title
=
article
.
title
;
let
headerElement
=
content
.
document
.
createElement
(
"
div
"
)
;
headerElement
.
setAttribute
(
"
id
"
"
reader
-
header
"
)
;
headerElement
.
setAttribute
(
"
class
"
"
header
"
)
;
containerElement
.
appendChild
(
headerElement
)
;
let
titleElement
=
content
.
document
.
createElement
(
"
h1
"
)
;
titleElement
.
setAttribute
(
"
id
"
"
reader
-
title
"
)
;
titleElement
.
textContent
=
article
.
title
;
headerElement
.
appendChild
(
titleElement
)
;
let
bylineElement
=
content
.
document
.
createElement
(
"
div
"
)
;
bylineElement
.
setAttribute
(
"
id
"
"
reader
-
credits
"
)
;
bylineElement
.
setAttribute
(
"
class
"
"
credits
"
)
;
bylineElement
.
textContent
=
article
.
byline
;
headerElement
.
appendChild
(
bylineElement
)
;
headerElement
.
style
.
display
=
"
block
"
;
let
contentElement
=
content
.
document
.
createElement
(
"
div
"
)
;
contentElement
.
setAttribute
(
"
class
"
"
content
"
)
;
containerElement
.
appendChild
(
contentElement
)
;
let
readerContent
=
content
.
document
.
createElement
(
"
div
"
)
;
readerContent
.
setAttribute
(
"
id
"
"
moz
-
reader
-
content
"
)
;
contentElement
.
appendChild
(
readerContent
)
;
let
articleUri
=
Services
.
io
.
newURI
(
article
.
url
)
;
let
parserUtils
=
Cc
[
"
mozilla
.
org
/
parserutils
;
1
"
]
.
getService
(
Ci
.
nsIParserUtils
)
;
let
contentFragment
=
parserUtils
.
parseFragment
(
article
.
content
Ci
.
nsIParserUtils
.
SanitizerDropForms
|
Ci
.
nsIParserUtils
.
SanitizerAllowStyle
false
articleUri
readerContent
)
;
readerContent
.
appendChild
(
contentFragment
)
;
readerContent
.
style
.
display
=
"
block
"
;
}
else
{
let
aboutReaderStrings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
global
/
locale
/
aboutReader
.
properties
"
)
;
let
errorMessage
=
aboutReaderStrings
.
GetStringFromName
(
"
aboutReader
.
loadError
"
)
;
content
.
document
.
title
=
errorMessage
;
let
readerMessageElement
=
content
.
document
.
createElement
(
"
div
"
)
;
readerMessageElement
.
setAttribute
(
"
class
"
"
reader
-
message
"
)
;
readerMessageElement
.
textContent
=
errorMessage
;
containerElement
.
appendChild
(
readerMessageElement
)
;
readerMessageElement
.
style
.
display
=
"
block
"
;
}
}
)
;
}
enterPrintPreview
(
contentWindow
simplifiedMode
changingBrowsers
defaultPrinterName
)
{
const
{
docShell
}
=
this
;
try
{
let
printSettings
=
this
.
getPrintSettings
(
defaultPrinterName
)
;
if
(
printSettings
&
&
simplifiedMode
)
printSettings
.
docURL
=
contentWindow
.
document
.
baseURI
;
let
printPreviewInitialize
=
(
)
=
>
{
try
{
let
listener
=
new
PrintingListener
(
this
.
mm
)
;
this
.
printPreviewInitializingInfo
=
{
changingBrowsers
}
;
docShell
.
printPreview
.
printPreview
(
printSettings
contentWindow
listener
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
this
.
printPreviewInitializingInfo
=
null
;
this
.
mm
.
sendAsyncMessage
(
"
Printing
:
Preview
:
Entered
"
{
failed
:
true
}
)
;
}
}
;
if
(
this
.
printPreviewInitializingInfo
&
&
!
this
.
printPreviewInitializingInfo
.
entered
)
{
this
.
printPreviewInitializingInfo
.
nextRequest
=
printPreviewInitialize
;
}
else
{
Services
.
tm
.
dispatchToMainThread
(
printPreviewInitialize
)
;
}
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
this
.
mm
.
sendAsyncMessage
(
"
Printing
:
Preview
:
Entered
"
{
failed
:
true
}
)
;
}
}
exitPrintPreview
(
glo
)
{
this
.
printPreviewInitializingInfo
=
null
;
this
.
docShell
.
printPreview
.
exitPrintPreview
(
)
;
}
print
(
contentWindow
simplifiedMode
defaultPrinterName
)
{
let
printSettings
=
this
.
getPrintSettings
(
defaultPrinterName
)
;
if
(
printSettings
&
&
simplifiedMode
)
{
printSettings
.
docURL
=
contentWindow
.
document
.
baseURI
;
}
try
{
let
print
=
contentWindow
.
getInterface
(
Ci
.
nsIWebBrowserPrint
)
;
if
(
print
.
doingPrintPreview
)
{
this
.
logKeyedTelemetry
(
"
PRINT_DIALOG_OPENED_COUNT
"
"
FROM_PREVIEW
"
)
;
}
else
{
this
.
logKeyedTelemetry
(
"
PRINT_DIALOG_OPENED_COUNT
"
"
FROM_PAGE
"
)
;
}
print
.
print
(
printSettings
null
)
;
if
(
print
.
doingPrintPreview
)
{
if
(
simplifiedMode
)
{
this
.
logKeyedTelemetry
(
"
PRINT_COUNT
"
"
SIMPLIFIED
"
)
;
}
else
{
this
.
logKeyedTelemetry
(
"
PRINT_COUNT
"
"
WITH_PREVIEW
"
)
;
}
}
else
{
this
.
logKeyedTelemetry
(
"
PRINT_COUNT
"
"
WITHOUT_PREVIEW
"
)
;
}
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_ABORT
)
{
Cu
.
reportError
(
In
Printing
:
Print
:
Done
handler
got
unexpected
rv
{
e
.
result
}
.
)
;
this
.
mm
.
sendAsyncMessage
(
"
Printing
:
Error
"
{
isPrinting
:
true
nsresult
:
e
.
result
}
)
;
}
}
if
(
this
.
shouldSavePrintSettings
)
{
let
PSSVC
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
PSSVC
.
savePrintSettingsToPrefs
(
printSettings
true
printSettings
.
kInitSaveAll
)
;
PSSVC
.
savePrintSettingsToPrefs
(
printSettings
false
printSettings
.
kInitSavePrinterName
)
;
}
}
logKeyedTelemetry
(
id
key
)
{
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
id
)
;
histogram
.
add
(
key
)
;
}
updatePageCount
(
)
{
let
numPages
=
this
.
docShell
.
printPreview
.
printPreviewNumPages
;
this
.
mm
.
sendAsyncMessage
(
"
Printing
:
Preview
:
UpdatePageCount
"
{
numPages
}
)
;
}
navigate
(
navType
pageNum
)
{
this
.
docShell
.
printPreview
.
printPreviewNavigate
(
navType
pageNum
)
;
}
}
PrintingChild
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsIPrintingPromptService
]
)
;
function
PrintingListener
(
global
)
{
this
.
global
=
global
;
}
PrintingListener
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
]
)
onStateChange
(
aWebProgress
aRequest
aStateFlags
aStatus
)
{
this
.
global
.
sendAsyncMessage
(
"
Printing
:
Preview
:
StateChange
"
{
stateFlags
:
aStateFlags
status
:
aStatus
}
)
;
}
onProgressChange
(
aWebProgress
aRequest
aCurSelfProgress
aMaxSelfProgress
aCurTotalProgress
aMaxTotalProgress
)
{
this
.
global
.
sendAsyncMessage
(
"
Printing
:
Preview
:
ProgressChange
"
{
curSelfProgress
:
aCurSelfProgress
maxSelfProgress
:
aMaxSelfProgress
curTotalProgress
:
aCurTotalProgress
maxTotalProgress
:
aMaxTotalProgress
}
)
;
}
onLocationChange
(
aWebProgress
aRequest
aLocation
aFlags
)
{
}
onStatusChange
(
aWebProgress
aRequest
aStatus
aMessage
)
{
}
onSecurityChange
(
aWebProgress
aRequest
aState
)
{
}
onContentBlockingEvent
(
aWebProgress
aRequest
aEvent
)
{
}
}
;
