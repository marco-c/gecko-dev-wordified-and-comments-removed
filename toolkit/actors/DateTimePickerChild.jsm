ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
DateTimePickerChild
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
class
DateTimePickerChild
extends
ActorChild
{
constructor
(
dispatcher
)
{
super
(
dispatcher
)
;
this
.
_inputElement
=
null
;
}
close
(
)
{
this
.
removeListeners
(
)
;
let
dateTimeBoxElement
=
this
.
_inputElement
.
dateTimeBoxElement
;
if
(
!
dateTimeBoxElement
)
{
this
.
_inputElement
=
null
;
return
;
}
if
(
dateTimeBoxElement
instanceof
Ci
.
nsIDateTimeInputArea
)
{
dateTimeBoxElement
.
wrappedJSObject
.
setPickerState
(
false
)
;
}
else
if
(
this
.
_inputElement
.
openOrClosedShadowRoot
)
{
let
win
=
this
.
_inputElement
.
ownerGlobal
;
dateTimeBoxElement
.
dispatchEvent
(
new
win
.
CustomEvent
(
"
MozSetDateTimePickerState
"
{
detail
:
false
}
)
)
;
}
this
.
_inputElement
=
null
;
}
addListeners
(
)
{
this
.
mm
.
addEventListener
(
"
MozUpdateDateTimePicker
"
this
)
;
this
.
mm
.
addEventListener
(
"
MozCloseDateTimePicker
"
this
)
;
this
.
mm
.
addEventListener
(
"
pagehide
"
this
)
;
this
.
mm
.
addMessageListener
(
"
FormDateTime
:
PickerValueChanged
"
this
)
;
this
.
mm
.
addMessageListener
(
"
FormDateTime
:
PickerClosed
"
this
)
;
}
removeListeners
(
)
{
this
.
mm
.
removeEventListener
(
"
MozUpdateDateTimePicker
"
this
)
;
this
.
mm
.
removeEventListener
(
"
MozCloseDateTimePicker
"
this
)
;
this
.
mm
.
removeEventListener
(
"
pagehide
"
this
)
;
this
.
mm
.
removeMessageListener
(
"
FormDateTime
:
PickerValueChanged
"
this
)
;
this
.
mm
.
removeMessageListener
(
"
FormDateTime
:
PickerClosed
"
this
)
;
}
getComputedDirection
(
aElement
)
{
return
aElement
.
ownerGlobal
.
getComputedStyle
(
aElement
)
.
getPropertyValue
(
"
direction
"
)
;
}
getBoundingContentRect
(
aElement
)
{
return
BrowserUtils
.
getElementBoundingRect
(
aElement
)
;
}
getTimePickerPref
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
dom
.
forms
.
datetime
.
timepicker
"
)
;
}
receiveMessage
(
aMessage
)
{
switch
(
aMessage
.
name
)
{
case
"
FormDateTime
:
PickerClosed
"
:
{
this
.
close
(
)
;
break
;
}
case
"
FormDateTime
:
PickerValueChanged
"
:
{
let
dateTimeBoxElement
=
this
.
_inputElement
.
dateTimeBoxElement
;
if
(
!
dateTimeBoxElement
)
{
return
;
}
let
win
=
this
.
_inputElement
.
ownerGlobal
;
if
(
dateTimeBoxElement
instanceof
Ci
.
nsIDateTimeInputArea
)
{
dateTimeBoxElement
.
wrappedJSObject
.
setValueFromPicker
(
Cu
.
cloneInto
(
aMessage
.
data
win
)
)
;
}
else
if
(
this
.
_inputElement
.
openOrClosedShadowRoot
)
{
dateTimeBoxElement
.
dispatchEvent
(
new
win
.
CustomEvent
(
"
MozPickerValueChanged
"
{
detail
:
Cu
.
cloneInto
(
aMessage
.
data
win
)
}
)
)
;
}
break
;
}
default
:
break
;
}
}
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
MozOpenDateTimePicker
"
:
{
if
(
!
(
aEvent
.
originalTarget
instanceof
aEvent
.
originalTarget
.
ownerGlobal
.
HTMLInputElement
)
|
|
(
aEvent
.
originalTarget
.
type
=
=
"
time
"
&
&
!
this
.
getTimePickerPref
(
)
)
)
{
return
;
}
if
(
this
.
_inputElement
)
{
return
;
}
this
.
_inputElement
=
aEvent
.
originalTarget
;
let
dateTimeBoxElement
=
this
.
_inputElement
.
dateTimeBoxElement
;
if
(
!
dateTimeBoxElement
)
{
throw
new
Error
(
"
How
do
we
get
this
event
without
a
UA
Widget
or
XBL
binding
?
"
)
;
}
if
(
dateTimeBoxElement
instanceof
Ci
.
nsIDateTimeInputArea
)
{
dateTimeBoxElement
.
wrappedJSObject
.
setPickerState
(
true
)
;
}
else
if
(
this
.
_inputElement
.
openOrClosedShadowRoot
)
{
let
win
=
this
.
_inputElement
.
ownerGlobal
;
dateTimeBoxElement
.
dispatchEvent
(
new
win
.
CustomEvent
(
"
MozSetDateTimePickerState
"
{
detail
:
true
}
)
)
;
}
this
.
addListeners
(
)
;
let
value
=
this
.
_inputElement
.
getDateTimeInputBoxValue
(
)
;
this
.
mm
.
sendAsyncMessage
(
"
FormDateTime
:
OpenPicker
"
{
rect
:
this
.
getBoundingContentRect
(
this
.
_inputElement
)
dir
:
this
.
getComputedDirection
(
this
.
_inputElement
)
type
:
this
.
_inputElement
.
type
detail
:
{
value
:
Object
.
keys
(
value
)
.
length
>
0
?
value
:
this
.
_inputElement
.
value
min
:
this
.
_inputElement
.
getMinimum
(
)
max
:
this
.
_inputElement
.
getMaximum
(
)
step
:
this
.
_inputElement
.
getStep
(
)
stepBase
:
this
.
_inputElement
.
getStepBase
(
)
}
}
)
;
break
;
}
case
"
MozUpdateDateTimePicker
"
:
{
let
value
=
this
.
_inputElement
.
getDateTimeInputBoxValue
(
)
;
value
.
type
=
this
.
_inputElement
.
type
;
this
.
mm
.
sendAsyncMessage
(
"
FormDateTime
:
UpdatePicker
"
{
value
}
)
;
break
;
}
case
"
MozCloseDateTimePicker
"
:
{
this
.
mm
.
sendAsyncMessage
(
"
FormDateTime
:
ClosePicker
"
)
;
this
.
close
(
)
;
break
;
}
case
"
pagehide
"
:
{
if
(
this
.
_inputElement
&
&
this
.
_inputElement
.
ownerDocument
=
=
aEvent
.
target
)
{
this
.
mm
.
sendAsyncMessage
(
"
FormDateTime
:
ClosePicker
"
)
;
this
.
close
(
)
;
}
break
;
}
default
:
break
;
}
}
}
