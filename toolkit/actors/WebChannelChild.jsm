var
EXPORTED_SYMBOLS
=
[
"
WebChannelChild
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
function
getMessageManager
(
event
)
{
let
window
=
Cu
.
getGlobalForObject
(
event
.
target
)
;
return
window
.
docShell
.
messageManager
;
}
const
URL_WHITELIST_PREF
=
"
webchannel
.
allowObject
.
urlWhitelist
"
;
let
_cachedWhitelist
=
[
]
;
let
_lastWhitelistValue
=
"
"
;
class
WebChannelChild
extends
ActorChild
{
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
WebChannelMessageToChrome
"
)
{
return
this
.
_onMessageToChrome
(
event
)
;
}
return
undefined
;
}
receiveMessage
(
msg
)
{
if
(
msg
.
name
=
=
=
"
WebChannelMessageToContent
"
)
{
return
this
.
_onMessageToContent
(
msg
)
;
}
return
undefined
;
}
_getWhitelistedPrincipals
(
)
{
let
whitelist
=
Services
.
prefs
.
getCharPref
(
URL_WHITELIST_PREF
)
;
if
(
whitelist
!
=
_lastWhitelistValue
)
{
let
urls
=
whitelist
.
split
(
/
\
s
+
/
)
;
_cachedWhitelist
=
urls
.
map
(
origin
=
>
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
origin
)
)
;
}
return
_cachedWhitelist
;
}
_onMessageToChrome
(
e
)
{
let
principal
=
e
.
target
.
nodePrincipal
?
e
.
target
.
nodePrincipal
:
e
.
target
.
document
.
nodePrincipal
;
if
(
e
.
detail
)
{
if
(
typeof
e
.
detail
!
=
"
string
"
)
{
let
objectsAllowed
=
this
.
_getWhitelistedPrincipals
(
)
.
some
(
whitelisted
=
>
principal
.
originNoSuffix
=
=
whitelisted
.
originNoSuffix
)
;
if
(
!
objectsAllowed
)
{
Cu
.
reportError
(
"
WebChannelMessageToChrome
sent
with
an
object
from
a
non
-
whitelisted
principal
"
)
;
return
;
}
}
let
mm
=
getMessageManager
(
e
)
;
mm
.
sendAsyncMessage
(
"
WebChannelMessageToChrome
"
e
.
detail
{
eventTarget
:
e
.
target
}
principal
)
;
}
else
{
Cu
.
reportError
(
"
WebChannel
message
failed
.
No
message
detail
.
"
)
;
}
}
_onMessageToContent
(
msg
)
{
if
(
msg
.
data
)
{
let
eventTarget
=
msg
.
objects
.
eventTarget
|
|
msg
.
target
.
content
;
let
targetPrincipal
=
eventTarget
instanceof
Ci
.
nsIDOMWindow
?
eventTarget
.
document
.
nodePrincipal
:
eventTarget
.
nodePrincipal
;
if
(
msg
.
principal
.
subsumes
(
targetPrincipal
)
)
{
let
targetWindow
=
eventTarget
instanceof
Ci
.
nsIDOMWindow
?
eventTarget
:
eventTarget
.
ownerGlobal
;
eventTarget
.
dispatchEvent
(
new
targetWindow
.
CustomEvent
(
"
WebChannelMessageToContent
"
{
detail
:
Cu
.
cloneInto
(
{
id
:
msg
.
data
.
id
message
:
msg
.
data
.
message
}
targetWindow
)
}
)
)
;
}
else
{
Cu
.
reportError
(
"
WebChannel
message
failed
.
Principal
mismatch
.
"
)
;
}
}
else
{
Cu
.
reportError
(
"
WebChannel
message
failed
.
No
message
data
.
"
)
;
}
}
}
