"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AutoCompleteParent
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
GeckoViewAutocomplete
:
"
resource
:
/
/
gre
/
modules
/
GeckoViewAutocomplete
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
DELEGATE_AUTOCOMPLETE
"
"
toolkit
.
autocomplete
.
delegate
"
false
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
setTimeout
"
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
PREF_SECURITY_DELAY
=
"
security
.
notification_enable_delay
"
;
let
currentActor
=
null
;
let
autoCompleteListeners
=
new
Set
(
)
;
function
compareContext
(
message
)
{
if
(
!
currentActor
|
|
(
currentActor
.
browsingContext
!
=
message
.
data
.
browsingContext
&
&
currentActor
.
browsingContext
.
top
!
=
message
.
data
.
browsingContext
)
)
{
return
false
;
}
return
true
;
}
Services
.
ppmm
.
addMessageListener
(
"
FormAutoComplete
:
GetSelectedIndex
"
message
=
>
{
if
(
compareContext
(
message
)
)
{
let
actor
=
currentActor
;
if
(
actor
&
&
actor
.
openedPopup
)
{
return
actor
.
openedPopup
.
selectedIndex
;
}
}
return
-
1
;
}
)
;
Services
.
ppmm
.
addMessageListener
(
"
FormAutoComplete
:
SelectBy
"
message
=
>
{
if
(
compareContext
(
message
)
)
{
let
actor
=
currentActor
;
if
(
actor
&
&
actor
.
openedPopup
)
{
actor
.
openedPopup
.
selectBy
(
message
.
data
.
reverse
message
.
data
.
page
)
;
}
}
}
)
;
var
AutoCompleteResultView
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIAutoCompleteController
"
"
nsIAutoCompleteInput
"
]
)
results
:
[
]
currentActor
:
null
get
matchCount
(
)
{
return
this
.
results
.
length
;
}
getValueAt
(
index
)
{
return
this
.
results
[
index
]
.
value
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
results
[
index
]
.
value
;
}
getLabelAt
(
index
)
{
return
this
.
results
[
index
]
.
comment
;
}
getCommentAt
(
index
)
{
return
this
.
results
[
index
]
.
label
;
}
getStyleAt
(
index
)
{
return
this
.
results
[
index
]
.
style
;
}
getImageAt
(
index
)
{
return
this
.
results
[
index
]
.
image
;
}
handleEnter
(
aIsPopupSelection
)
{
if
(
this
.
currentActor
)
{
this
.
currentActor
.
handleEnter
(
aIsPopupSelection
)
;
}
}
stopSearch
(
)
{
}
searchString
:
"
"
get
controller
(
)
{
return
this
;
}
get
popup
(
)
{
return
null
;
}
_focus
(
)
{
if
(
this
.
currentActor
)
{
this
.
currentActor
.
requestFocus
(
)
;
}
}
clearResults
(
)
{
this
.
currentActor
=
null
;
this
.
results
=
[
]
;
}
setResults
(
actor
results
)
{
this
.
currentActor
=
actor
;
this
.
results
=
results
;
}
}
;
class
AutoCompleteParent
extends
JSWindowActorParent
{
didDestroy
(
)
{
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
closePopup
(
)
;
}
}
static
getCurrentActor
(
)
{
return
currentActor
;
}
static
addPopupStateListener
(
listener
)
{
autoCompleteListeners
.
add
(
listener
)
;
}
static
removePopupStateListener
(
listener
)
{
autoCompleteListeners
.
delete
(
listener
)
;
}
handleEvent
(
evt
)
{
switch
(
evt
.
type
)
{
case
"
popupshowing
"
:
{
this
.
sendAsyncMessage
(
"
FormAutoComplete
:
PopupOpened
"
{
}
)
;
break
;
}
case
"
popuphidden
"
:
{
let
selectedIndex
=
this
.
openedPopup
.
selectedIndex
;
let
selectedRowComment
=
selectedIndex
!
=
-
1
?
AutoCompleteResultView
.
getCommentAt
(
selectedIndex
)
:
"
"
;
let
selectedRowStyle
=
selectedIndex
!
=
-
1
?
AutoCompleteResultView
.
getStyleAt
(
selectedIndex
)
:
"
"
;
this
.
sendAsyncMessage
(
"
FormAutoComplete
:
PopupClosed
"
{
selectedRowComment
selectedRowStyle
}
)
;
AutoCompleteResultView
.
clearResults
(
)
;
this
.
openedPopup
.
adjustHeight
(
)
;
this
.
openedPopup
=
null
;
currentActor
=
null
;
evt
.
target
.
removeEventListener
(
"
popuphidden
"
this
)
;
evt
.
target
.
removeEventListener
(
"
popupshowing
"
this
)
;
break
;
}
}
}
showPopupWithResults
(
{
rect
dir
results
}
)
{
if
(
!
results
.
length
|
|
this
.
openedPopup
)
{
return
;
}
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
let
window
=
browser
.
ownerGlobal
;
if
(
Services
.
focus
.
activeWindow
!
=
=
window
.
top
&
&
Services
.
focus
.
focusedWindow
.
top
!
=
=
window
.
top
)
{
return
;
}
let
resultStyles
=
new
Set
(
results
.
map
(
r
=
>
r
.
style
)
.
filter
(
r
=
>
!
!
r
)
)
;
currentActor
=
this
;
this
.
openedPopup
=
browser
.
autoCompletePopup
;
this
.
openedPopup
.
setAttribute
(
"
resultstyles
"
[
.
.
.
resultStyles
]
.
join
(
"
"
)
)
;
this
.
openedPopup
.
hidden
=
false
;
this
.
openedPopup
.
style
.
setProperty
(
"
-
-
panel
-
width
"
Math
.
max
(
100
rect
.
width
)
+
"
px
"
)
;
this
.
openedPopup
.
style
.
direction
=
dir
;
AutoCompleteResultView
.
setResults
(
this
results
)
;
this
.
openedPopup
.
view
=
AutoCompleteResultView
;
this
.
openedPopup
.
selectedIndex
=
-
1
;
this
.
openedPopup
.
mInput
=
AutoCompleteResultView
;
if
(
resultStyles
.
size
&
&
(
resultStyles
.
has
(
"
autofill
-
profile
"
)
|
|
resultStyles
.
has
(
"
loginsFooter
"
)
)
)
{
this
.
openedPopup
.
_normalMaxRows
=
this
.
openedPopup
.
maxRows
;
this
.
openedPopup
.
mInput
.
maxRows
=
10
;
}
this
.
openedPopup
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
openedPopup
.
addEventListener
(
"
popupshowing
"
this
)
;
this
.
openedPopup
.
openPopupAtScreenRect
(
"
after_start
"
rect
.
left
rect
.
top
rect
.
width
rect
.
height
false
false
)
;
this
.
openedPopup
.
invalidate
(
)
;
this
.
_maybeRecordTelemetryEvents
(
results
)
;
let
isCreditCard
=
results
.
some
(
result
=
>
result
?
.
comment
?
.
includes
(
"
cc
-
number
"
)
)
;
if
(
isCreditCard
)
{
this
.
delayPopupInput
(
)
;
}
}
_maybeRecordTelemetryEvents
(
results
)
{
let
actor
=
this
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
LoginManager
"
)
;
actor
.
maybeRecordPasswordGenerationShownTelemetryEvent
(
results
)
;
let
lastResult
=
results
[
results
.
length
-
1
]
;
if
(
lastResult
.
style
!
=
"
loginsFooter
"
)
{
return
;
}
let
rawExtraData
=
JSON
.
parse
(
lastResult
.
comment
)
.
telemetryEventData
;
if
(
!
rawExtraData
.
searchStartTimeMS
)
{
throw
new
Error
(
"
Invalid
autocomplete
search
start
time
"
)
;
}
if
(
rawExtraData
.
stringLength
>
1
)
{
return
;
}
let
duration
=
Services
.
telemetry
.
msSystemNow
(
)
-
rawExtraData
.
searchStartTimeMS
;
delete
rawExtraData
.
searchStartTimeMS
;
results
.
reduce
(
(
accumulated
r
)
=
>
{
if
(
r
.
style
=
=
=
"
importableLearnMore
"
)
{
return
accumulated
;
}
let
truncatedStyle
=
r
.
style
.
substring
(
0
r
.
style
=
=
=
"
loginWithOrigin
"
?
5
:
15
)
;
accumulated
[
truncatedStyle
]
=
(
accumulated
[
truncatedStyle
]
|
|
0
)
+
1
;
return
accumulated
;
}
rawExtraData
)
;
let
extraStrings
=
Object
.
fromEntries
(
Object
.
entries
(
rawExtraData
)
.
map
(
(
[
key
val
]
)
=
>
{
let
stringVal
=
"
"
;
if
(
typeof
val
=
=
"
boolean
"
)
{
stringVal
+
=
val
?
"
1
"
:
"
0
"
;
}
else
{
stringVal
+
=
val
;
}
return
[
key
stringVal
]
;
}
)
)
;
Services
.
telemetry
.
recordEvent
(
"
form_autocomplete
"
"
show
"
"
logins
"
duration
+
"
"
extraStrings
)
;
}
invalidate
(
results
)
{
if
(
!
this
.
openedPopup
)
{
return
;
}
if
(
!
results
.
length
)
{
this
.
closePopup
(
)
;
}
else
{
AutoCompleteResultView
.
setResults
(
this
results
)
;
this
.
openedPopup
.
invalidate
(
)
;
this
.
_maybeRecordTelemetryEvents
(
results
)
;
}
}
closePopup
(
)
{
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
hidePopup
(
)
;
}
}
receiveMessage
(
message
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
if
(
!
browser
|
|
(
!
lazy
.
DELEGATE_AUTOCOMPLETE
&
&
!
browser
.
autoCompletePopup
)
)
{
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
closePopup
(
)
;
}
return
false
;
}
switch
(
message
.
name
)
{
case
"
FormAutoComplete
:
SetSelectedIndex
"
:
{
let
{
index
}
=
message
.
data
;
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
selectedIndex
=
index
;
}
break
;
}
case
"
FormAutoComplete
:
MaybeOpenPopup
"
:
{
let
{
results
rect
dir
inputElementIdentifier
formOrigin
}
=
message
.
data
;
if
(
lazy
.
DELEGATE_AUTOCOMPLETE
)
{
lazy
.
GeckoViewAutocomplete
.
delegateSelection
(
{
browsingContext
:
this
.
browsingContext
options
:
results
inputElementIdentifier
formOrigin
}
)
;
}
else
{
this
.
showPopupWithResults
(
{
results
rect
dir
}
)
;
this
.
notifyListeners
(
)
;
}
break
;
}
case
"
FormAutoComplete
:
Invalidate
"
:
{
let
{
results
}
=
message
.
data
;
this
.
invalidate
(
results
)
;
break
;
}
case
"
FormAutoComplete
:
ClosePopup
"
:
{
this
.
closePopup
(
)
;
break
;
}
}
return
false
;
}
delayPopupInput
(
)
{
if
(
!
this
.
openedPopup
)
{
return
;
}
const
popupDelay
=
Services
.
prefs
.
getIntPref
(
PREF_SECURITY_DELAY
)
;
if
(
!
popupDelay
)
{
return
;
}
const
items
=
Array
.
from
(
this
.
openedPopup
.
getElementsByTagName
(
"
richlistitem
"
)
)
;
items
.
forEach
(
item
=
>
(
item
.
disabled
=
true
)
)
;
lazy
.
setTimeout
(
(
)
=
>
items
.
forEach
(
item
=
>
(
item
.
disabled
=
false
)
)
popupDelay
)
;
}
notifyListeners
(
)
{
let
window
=
this
.
browsingContext
.
top
.
embedderElement
.
ownerGlobal
;
for
(
let
listener
of
autoCompleteListeners
)
{
try
{
listener
(
window
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
handleEnter
(
aIsPopupSelection
)
{
if
(
this
.
openedPopup
)
{
this
.
sendAsyncMessage
(
"
FormAutoComplete
:
HandleEnter
"
{
selectedIndex
:
this
.
openedPopup
.
selectedIndex
isPopupSelection
:
aIsPopupSelection
}
)
;
}
}
stopSearch
(
)
{
}
requestFocus
(
)
{
}
}
