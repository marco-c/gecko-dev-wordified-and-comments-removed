"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AutoCompleteParent
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
let
currentBrowserWeakRef
=
null
;
let
currentActor
=
null
;
let
autoCompleteListeners
=
new
Set
(
)
;
function
compareContext
(
message
)
{
if
(
!
currentActor
|
|
(
currentActor
.
browsingContext
!
=
message
.
data
.
browsingContext
&
&
currentActor
.
browsingContext
.
top
!
=
message
.
data
.
browsingContext
)
)
{
return
false
;
}
return
true
;
}
Services
.
ppmm
.
addMessageListener
(
"
FormAutoComplete
:
GetSelectedIndex
"
message
=
>
{
if
(
compareContext
(
message
)
)
{
let
actor
=
currentActor
;
if
(
actor
&
&
actor
.
openedPopup
)
{
return
actor
.
openedPopup
.
selectedIndex
;
}
}
return
-
1
;
}
)
;
Services
.
ppmm
.
addMessageListener
(
"
FormAutoComplete
:
SelectBy
"
message
=
>
{
if
(
compareContext
(
message
)
)
{
let
actor
=
currentActor
;
if
(
actor
&
&
actor
.
openedPopup
)
{
actor
.
openedPopup
.
selectBy
(
message
.
data
.
reverse
message
.
data
.
page
)
;
}
}
}
)
;
var
AutoCompleteResultView
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIAutoCompleteController
Ci
.
nsIAutoCompleteInput
]
)
results
:
[
]
currentActor
:
null
get
matchCount
(
)
{
return
this
.
results
.
length
;
}
getValueAt
(
index
)
{
return
this
.
results
[
index
]
.
value
;
}
getFinalCompleteValueAt
(
index
)
{
return
this
.
results
[
index
]
.
value
;
}
getLabelAt
(
index
)
{
return
this
.
results
[
index
]
.
comment
;
}
getCommentAt
(
index
)
{
return
this
.
results
[
index
]
.
label
;
}
getStyleAt
(
index
)
{
return
this
.
results
[
index
]
.
style
;
}
getImageAt
(
index
)
{
return
this
.
results
[
index
]
.
image
;
}
handleEnter
(
aIsPopupSelection
)
{
if
(
this
.
currentActor
)
{
this
.
currentActor
.
handleEnter
(
aIsPopupSelection
)
;
}
}
stopSearch
(
)
{
}
searchString
:
"
"
get
controller
(
)
{
return
this
;
}
get
popup
(
)
{
return
null
;
}
_focus
(
)
{
if
(
this
.
currentActor
)
{
this
.
currentActor
.
requestFocus
(
)
;
}
}
clearResults
(
)
{
this
.
currentActor
=
null
;
this
.
results
=
[
]
;
}
setResults
(
actor
results
)
{
this
.
currentActor
=
actor
;
this
.
results
=
results
;
}
}
;
class
AutoCompleteParent
extends
JSWindowActorParent
{
willDestroy
(
)
{
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
closePopup
(
)
;
}
}
static
getCurrentBrowser
(
)
{
return
currentBrowserWeakRef
?
currentBrowserWeakRef
.
get
(
)
:
null
;
}
static
addPopupStateListener
(
listener
)
{
autoCompleteListeners
.
add
(
listener
)
;
}
static
removePopupStateListener
(
listener
)
{
autoCompleteListeners
.
delete
(
listener
)
;
}
handleEvent
(
evt
)
{
switch
(
evt
.
type
)
{
case
"
popupshowing
"
:
{
this
.
sendAsyncMessage
(
"
FormAutoComplete
:
PopupOpened
"
{
}
)
;
break
;
}
case
"
popuphidden
"
:
{
let
selectedIndex
=
this
.
openedPopup
.
selectedIndex
;
let
selectedRowStyle
=
selectedIndex
!
=
-
1
?
AutoCompleteResultView
.
getStyleAt
(
selectedIndex
)
:
"
"
;
this
.
sendAsyncMessage
(
"
FormAutoComplete
:
PopupClosed
"
{
selectedRowStyle
}
)
;
AutoCompleteResultView
.
clearResults
(
)
;
this
.
openedPopup
.
adjustHeight
(
)
;
this
.
openedPopup
=
null
;
currentBrowserWeakRef
=
null
;
currentActor
=
null
;
evt
.
target
.
removeEventListener
(
"
popuphidden
"
this
)
;
evt
.
target
.
removeEventListener
(
"
popupshowing
"
this
)
;
break
;
}
}
}
showPopupWithResults
(
{
rect
dir
results
}
)
{
if
(
!
results
.
length
|
|
this
.
openedPopup
)
{
return
;
}
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
let
window
=
browser
.
ownerGlobal
;
if
(
Services
.
focus
.
activeWindow
!
=
=
window
.
top
&
&
Services
.
focus
.
focusedWindow
.
top
!
=
=
window
.
top
)
{
return
;
}
let
resultStyles
=
new
Set
(
results
.
map
(
r
=
>
r
.
style
)
.
filter
(
r
=
>
!
!
r
)
)
;
currentBrowserWeakRef
=
Cu
.
getWeakReference
(
browser
)
;
currentActor
=
this
;
this
.
openedPopup
=
browser
.
autoCompletePopup
;
this
.
openedPopup
.
setAttribute
(
"
resultstyles
"
[
.
.
.
resultStyles
]
.
join
(
"
"
)
)
;
this
.
openedPopup
.
hidden
=
false
;
this
.
openedPopup
.
setAttribute
(
"
width
"
Math
.
max
(
100
rect
.
width
)
)
;
this
.
openedPopup
.
style
.
direction
=
dir
;
AutoCompleteResultView
.
setResults
(
this
results
)
;
this
.
openedPopup
.
view
=
AutoCompleteResultView
;
this
.
openedPopup
.
selectedIndex
=
-
1
;
if
(
results
.
length
)
{
this
.
openedPopup
.
mInput
=
AutoCompleteResultView
;
if
(
resultStyles
.
size
&
&
(
resultStyles
.
has
(
"
autofill
-
profile
"
)
|
|
resultStyles
.
has
(
"
loginsFooter
"
)
)
)
{
this
.
openedPopup
.
_normalMaxRows
=
this
.
openedPopup
.
maxRows
;
this
.
openedPopup
.
mInput
.
maxRows
=
100
;
}
this
.
openedPopup
.
addEventListener
(
"
popuphidden
"
this
)
;
this
.
openedPopup
.
addEventListener
(
"
popupshowing
"
this
)
;
this
.
openedPopup
.
openPopupAtScreenRect
(
"
after_start
"
rect
.
left
rect
.
top
rect
.
width
rect
.
height
false
false
)
;
this
.
openedPopup
.
invalidate
(
)
;
}
else
{
this
.
closePopup
(
)
;
}
}
invalidate
(
results
)
{
if
(
!
this
.
openedPopup
)
{
return
;
}
if
(
!
results
.
length
)
{
this
.
closePopup
(
)
;
}
else
{
AutoCompleteResultView
.
setResults
(
this
results
)
;
this
.
openedPopup
.
invalidate
(
)
;
}
}
closePopup
(
)
{
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
hidePopup
(
)
;
}
}
receiveMessage
(
message
)
{
let
browser
=
this
.
browsingContext
.
top
.
embedderElement
;
if
(
!
browser
|
|
!
browser
.
autoCompletePopup
)
{
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
closePopup
(
)
;
}
return
false
;
}
switch
(
message
.
name
)
{
case
"
FormAutoComplete
:
SetSelectedIndex
"
:
{
let
{
index
}
=
message
.
data
;
if
(
this
.
openedPopup
)
{
this
.
openedPopup
.
selectedIndex
=
index
;
}
break
;
}
case
"
FormAutoComplete
:
MaybeOpenPopup
"
:
{
let
{
results
rect
dir
}
=
message
.
data
;
this
.
showPopupWithResults
(
{
rect
dir
results
}
)
;
this
.
notifyListeners
(
)
;
break
;
}
case
"
FormAutoComplete
:
Invalidate
"
:
{
let
{
results
}
=
message
.
data
;
this
.
invalidate
(
results
)
;
break
;
}
case
"
FormAutoComplete
:
ClosePopup
"
:
{
this
.
closePopup
(
)
;
break
;
}
case
"
FormAutoComplete
:
Disconnect
"
:
{
AutoCompleteResultView
.
clearResults
(
)
;
break
;
}
}
return
false
;
}
notifyListeners
(
)
{
let
window
=
this
.
browsingContext
.
top
.
embedderElement
.
ownerGlobal
;
for
(
let
listener
of
autoCompleteListeners
)
{
try
{
listener
(
window
)
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
handleEnter
(
aIsPopupSelection
)
{
if
(
this
.
openedPopup
)
{
this
.
sendAsyncMessage
(
"
FormAutoComplete
:
HandleEnter
"
{
selectedIndex
:
this
.
openedPopup
.
selectedIndex
isPopupSelection
:
aIsPopupSelection
}
)
;
}
}
stopSearch
(
)
{
}
requestFocus
(
)
{
}
}
