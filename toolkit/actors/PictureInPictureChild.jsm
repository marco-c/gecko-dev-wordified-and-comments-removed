"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PictureInPictureChild
"
]
;
const
{
ActorChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
var
gWeakVideo
=
null
;
var
gWeakPlayerContent
=
null
;
class
PictureInPictureChild
extends
ActorChild
{
static
videoIsPlaying
(
video
)
{
return
!
!
(
video
.
currentTime
>
0
&
&
!
video
.
paused
&
&
!
video
.
ended
&
&
video
.
readyState
>
2
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
MozTogglePictureInPicture
"
:
{
if
(
event
.
isTrusted
)
{
this
.
togglePictureInPicture
(
event
.
target
)
;
}
break
;
}
case
"
pagehide
"
:
{
this
.
closePictureInPicture
(
)
;
break
;
}
case
"
play
"
:
{
this
.
mm
.
sendAsyncMessage
(
"
PictureInPicture
:
Playing
"
)
;
break
;
}
case
"
pause
"
:
{
this
.
mm
.
sendAsyncMessage
(
"
PictureInPicture
:
Paused
"
)
;
break
;
}
}
}
get
weakVideo
(
)
{
if
(
gWeakVideo
)
{
return
gWeakVideo
.
get
(
)
;
}
return
null
;
}
get
weakPlayerContent
(
)
{
if
(
gWeakPlayerContent
)
{
return
gWeakPlayerContent
.
get
(
)
;
}
return
null
;
}
async
togglePictureInPicture
(
video
)
{
if
(
this
.
inPictureInPicture
(
video
)
)
{
await
this
.
closePictureInPicture
(
)
;
}
else
{
if
(
this
.
weakVideo
)
{
await
this
.
closePictureInPicture
(
)
;
}
gWeakVideo
=
Cu
.
getWeakReference
(
video
)
;
this
.
mm
.
sendAsyncMessage
(
"
PictureInPicture
:
Request
"
{
playing
:
PictureInPictureChild
.
videoIsPlaying
(
video
)
videoHeight
:
video
.
videoHeight
videoWidth
:
video
.
videoWidth
}
)
;
}
}
inPictureInPicture
(
video
)
{
return
this
.
weakVideo
=
=
=
video
;
}
async
closePictureInPicture
(
)
{
if
(
this
.
weakVideo
)
{
this
.
untrackOriginatingVideo
(
this
.
weakVideo
)
;
}
this
.
mm
.
sendAsyncMessage
(
"
PictureInPicture
:
Close
"
{
browingContextId
:
this
.
docShell
.
browsingContext
.
id
}
)
;
if
(
this
.
weakPlayerContent
)
{
await
new
Promise
(
resolve
=
>
{
this
.
weakPlayerContent
.
addEventListener
(
"
unload
"
resolve
{
once
:
true
}
)
;
}
)
;
gWeakPlayerContent
=
null
;
}
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
PictureInPicture
:
SetupPlayer
"
:
{
this
.
setupPlayer
(
)
;
break
;
}
case
"
PictureInPicture
:
Play
"
:
{
this
.
play
(
)
;
break
;
}
case
"
PictureInPicture
:
Pause
"
:
{
this
.
pause
(
)
;
break
;
}
}
}
trackOriginatingVideo
(
originatingVideo
)
{
let
originatingWindow
=
originatingVideo
.
ownerGlobal
;
if
(
originatingWindow
)
{
originatingWindow
.
addEventListener
(
"
pagehide
"
this
)
;
originatingVideo
.
addEventListener
(
"
play
"
this
)
;
originatingVideo
.
addEventListener
(
"
pause
"
this
)
;
}
}
untrackOriginatingVideo
(
originatingVideo
)
{
let
originatingWindow
=
originatingVideo
.
ownerGlobal
;
if
(
originatingWindow
)
{
originatingWindow
.
removeEventListener
(
"
pagehide
"
this
)
;
originatingVideo
.
removeEventListener
(
"
play
"
this
)
;
originatingVideo
.
removeEventListener
(
"
pause
"
this
)
;
}
}
async
setupPlayer
(
)
{
let
originatingVideo
=
this
.
weakVideo
;
if
(
!
originatingVideo
)
{
await
this
.
closePictureInPicture
(
)
;
return
;
}
let
webProgress
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
if
(
webProgress
.
isLoadingDocument
)
{
await
new
Promise
(
resolve
=
>
{
this
.
mm
.
addEventListener
(
"
load
"
resolve
{
once
:
true
mozSystemGroup
:
true
capture
:
true
}
)
;
}
)
;
}
let
doc
=
this
.
content
.
document
;
let
playerVideo
=
originatingVideo
.
cloneNode
(
)
;
playerVideo
.
removeAttribute
(
"
controls
"
)
;
playerVideo
.
muted
=
true
;
playerVideo
.
style
.
height
=
"
100vh
"
;
playerVideo
.
style
.
width
=
"
100vw
"
;
playerVideo
.
style
.
margin
=
"
0
"
;
doc
.
body
.
style
.
overflow
=
"
hidden
"
;
doc
.
body
.
style
.
margin
=
"
0
"
;
doc
.
body
.
appendChild
(
playerVideo
)
;
originatingVideo
.
cloneElementVisually
(
playerVideo
)
;
this
.
trackOriginatingVideo
(
originatingVideo
)
;
this
.
content
.
addEventListener
(
"
unload
"
(
)
=
>
{
if
(
this
.
weakVideo
)
{
this
.
weakVideo
.
stopCloningElementVisually
(
)
;
}
gWeakVideo
=
null
;
}
{
once
:
true
}
)
;
gWeakPlayerContent
=
Cu
.
getWeakReference
(
this
.
content
)
;
}
play
(
)
{
let
video
=
this
.
weakVideo
;
if
(
video
)
{
video
.
play
(
)
;
}
}
pause
(
)
{
let
video
=
this
.
weakVideo
;
if
(
video
)
{
video
.
pause
(
)
;
}
}
}
