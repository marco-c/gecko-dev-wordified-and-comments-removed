"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PictureInPictureChild
"
"
PictureInPictureToggleChild
"
"
PictureInPictureLauncherChild
"
]
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
KEYBOARD_CONTROLS
"
"
resource
:
/
/
gre
/
modules
/
PictureInPictureControls
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TOGGLE_POLICIES
"
"
resource
:
/
/
gre
/
modules
/
PictureInPictureControls
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
TOGGLE_POLICY_STRINGS
"
"
resource
:
/
/
gre
/
modules
/
PictureInPictureControls
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Rect
"
"
resource
:
/
/
gre
/
modules
/
Geometry
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContentDOMReference
"
"
resource
:
/
/
gre
/
modules
/
ContentDOMReference
.
jsm
"
)
;
const
{
WebVTT
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
vtt
.
jsm
"
)
;
const
{
setTimeout
clearTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
DISPLAY_TEXT_TRACKS_PREF
"
"
media
.
videocontrols
.
picture
-
in
-
picture
.
display
-
text
-
tracks
.
enabled
"
false
)
;
const
TOGGLE_ENABLED_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
enabled
"
;
const
PIP_ENABLED_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
enabled
"
;
const
TOGGLE_TESTING_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
testing
"
;
const
TOGGLE_VISIBILITY_THRESHOLD_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
visibility
-
threshold
"
;
const
TEXT_TRACK_FONT_SIZE
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
display
-
text
-
tracks
.
size
"
;
const
MOUSEMOVE_PROCESSING_DELAY_MS
=
50
;
const
TOGGLE_HIDING_TIMEOUT_MS
=
2000
;
const
SEEK_TIME_SECS
=
5
;
const
EMPTIED_TIMEOUT_MS
=
1000
;
var
gPlayerContents
=
new
WeakSet
(
)
;
var
gWeakIntersectingVideosForTesting
=
new
WeakSet
(
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gSiteOverrides
"
(
)
=
>
{
return
PictureInPictureToggleChild
.
getSiteOverrides
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logConsole
"
(
)
=
>
{
return
console
.
createInstance
(
{
prefix
:
"
PictureInPictureChild
"
maxLogLevel
:
Services
.
prefs
.
getBoolPref
(
"
media
.
videocontrols
.
picture
-
in
-
picture
.
log
"
false
)
?
"
Debug
"
:
"
Error
"
}
)
;
}
)
;
function
applyWrapper
(
pipChild
originatingVideo
)
{
let
originatingDoc
=
originatingVideo
.
ownerDocument
;
let
originatingDocumentURI
=
originatingDoc
.
documentURI
;
let
overrides
=
gSiteOverrides
.
find
(
(
[
matcher
]
)
=
>
{
return
matcher
.
matches
(
originatingDocumentURI
)
;
}
)
;
let
wrapperPath
=
overrides
?
overrides
[
1
]
.
videoWrapperScriptPath
:
null
;
return
new
PictureInPictureChildVideoWrapper
(
wrapperPath
originatingVideo
pipChild
)
;
}
class
PictureInPictureLauncherChild
extends
JSWindowActorChild
{
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
MozTogglePictureInPicture
"
:
{
if
(
event
.
isTrusted
)
{
this
.
togglePictureInPicture
(
event
.
target
)
;
}
break
;
}
}
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
PictureInPicture
:
KeyToggle
"
:
{
this
.
keyToggle
(
)
;
break
;
}
}
}
async
togglePictureInPicture
(
video
)
{
if
(
video
.
isCloningElementVisually
)
{
const
stopPipEvent
=
new
this
.
contentWindow
.
CustomEvent
(
"
MozStopPictureInPicture
"
{
bubbles
:
true
detail
:
{
reason
:
"
context
-
menu
"
}
}
)
;
video
.
dispatchEvent
(
stopPipEvent
)
;
return
;
}
const
videoRef
=
ContentDOMReference
.
get
(
video
)
;
this
.
sendAsyncMessage
(
"
PictureInPicture
:
Request
"
{
isMuted
:
PictureInPictureChild
.
videoIsMuted
(
video
)
playing
:
PictureInPictureChild
.
videoIsPlaying
(
video
)
videoHeight
:
video
.
videoHeight
videoWidth
:
video
.
videoWidth
videoRef
ccEnabled
:
DISPLAY_TEXT_TRACKS_PREF
webVTTSubtitles
:
!
!
video
.
textTracks
?
.
length
}
)
;
}
keyToggle
(
)
{
let
doc
=
this
.
document
;
if
(
doc
)
{
let
video
=
doc
.
activeElement
;
if
(
!
HTMLVideoElement
.
isInstance
(
video
)
)
{
let
listOfVideos
=
[
.
.
.
doc
.
querySelectorAll
(
"
video
"
)
]
.
filter
(
video
=
>
!
isNaN
(
video
.
duration
)
)
;
video
=
listOfVideos
.
filter
(
v
=
>
!
v
.
paused
)
[
0
]
|
|
listOfVideos
.
sort
(
(
a
b
)
=
>
b
.
duration
-
a
.
duration
)
[
0
]
;
}
if
(
video
)
{
this
.
togglePictureInPicture
(
video
)
;
}
}
}
}
class
PictureInPictureToggleChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
weakDocStates
=
new
WeakMap
(
)
;
this
.
toggleEnabled
=
Services
.
prefs
.
getBoolPref
(
TOGGLE_ENABLED_PREF
)
&
&
Services
.
prefs
.
getBoolPref
(
PIP_ENABLED_PREF
)
;
this
.
toggleTesting
=
Services
.
prefs
.
getBoolPref
(
TOGGLE_TESTING_PREF
false
)
;
this
.
observerFunction
=
(
subject
topic
data
)
=
>
{
this
.
observe
(
subject
topic
data
)
;
}
;
Services
.
prefs
.
addObserver
(
TOGGLE_ENABLED_PREF
this
.
observerFunction
)
;
Services
.
prefs
.
addObserver
(
PIP_ENABLED_PREF
this
.
observerFunction
)
;
Services
.
cpmm
.
sharedData
.
addEventListener
(
"
change
"
this
)
;
}
didDestroy
(
)
{
this
.
stopTrackingMouseOverVideos
(
)
;
Services
.
prefs
.
removeObserver
(
TOGGLE_ENABLED_PREF
this
.
observerFunction
)
;
Services
.
prefs
.
removeObserver
(
PIP_ENABLED_PREF
this
.
observerFunction
)
;
Services
.
cpmm
.
sharedData
.
removeEventListener
(
"
change
"
this
)
;
let
state
=
this
.
docState
;
if
(
state
?
.
intersectionObserver
)
{
state
.
intersectionObserver
.
disconnect
(
)
;
}
this
.
videoWrapper
?
.
destroy
(
)
;
this
.
videoWrapper
=
null
;
this
.
isDestroyed
=
true
;
}
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
nsPref
:
changed
"
)
{
return
;
}
this
.
toggleEnabled
=
Services
.
prefs
.
getBoolPref
(
TOGGLE_ENABLED_PREF
)
&
&
Services
.
prefs
.
getBoolPref
(
PIP_ENABLED_PREF
)
;
if
(
this
.
toggleEnabled
)
{
this
.
contentWindow
.
requestIdleCallback
(
(
)
=
>
{
let
videos
=
this
.
document
.
querySelectorAll
(
"
video
"
)
;
for
(
let
video
of
videos
)
{
this
.
registerVideo
(
video
)
;
}
}
)
;
}
}
get
docState
(
)
{
if
(
this
.
isDestroyed
|
|
!
this
.
document
)
{
return
false
;
}
let
state
=
this
.
weakDocStates
.
get
(
this
.
document
)
;
let
visibilityThresholdPref
=
Services
.
prefs
.
getFloatPref
(
TOGGLE_VISIBILITY_THRESHOLD_PREF
"
1
.
0
"
)
;
if
(
!
state
)
{
state
=
{
intersectionObserver
:
null
weakVisibleVideos
:
new
WeakSet
(
)
visibleVideosCount
:
0
mousemoveDeferredTask
:
null
weakOverVideo
:
null
isClickingToggle
:
false
clickedElement
:
null
hideToggleDeferredTask
:
null
isTrackingVideos
:
false
togglePolicy
:
TOGGLE_POLICIES
.
DEFAULT
toggleVisibilityThreshold
:
visibilityThresholdPref
checkedPolicyDocumentURI
:
null
}
;
this
.
weakDocStates
.
set
(
this
.
document
state
)
;
}
return
state
;
}
getWeakOverVideo
(
)
{
let
{
weakOverVideo
}
=
this
.
docState
;
if
(
weakOverVideo
)
{
try
{
return
weakOverVideo
.
get
(
)
;
}
catch
(
e
)
{
return
null
;
}
}
return
null
;
}
handleEvent
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
if
(
gPlayerContents
.
has
(
this
.
contentWindow
)
)
{
return
;
}
switch
(
event
.
type
)
{
case
"
change
"
:
{
const
{
changedKeys
}
=
event
;
if
(
changedKeys
.
includes
(
"
PictureInPicture
:
SiteOverrides
"
)
)
{
try
{
gSiteOverrides
=
PictureInPictureToggleChild
.
getSiteOverrides
(
)
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
TypeError
)
)
{
throw
e
;
}
}
}
break
;
}
case
"
UAWidgetSetupOrChange
"
:
{
if
(
this
.
toggleEnabled
&
&
this
.
contentWindow
.
HTMLVideoElement
.
isInstance
(
event
.
target
)
&
&
event
.
target
.
ownerDocument
=
=
this
.
document
)
{
this
.
registerVideo
(
event
.
target
)
;
}
break
;
}
case
"
contextmenu
"
:
{
if
(
this
.
toggleEnabled
)
{
this
.
checkContextMenu
(
event
)
;
}
break
;
}
case
"
mouseout
"
:
{
this
.
onMouseOut
(
event
)
;
break
;
}
case
"
click
"
:
if
(
event
.
detail
=
=
0
)
{
let
shadowRoot
=
event
.
originalTarget
.
containingShadowRoot
;
let
toggle
=
this
.
getToggleElement
(
shadowRoot
)
;
if
(
event
.
originalTarget
=
=
toggle
)
{
this
.
startPictureInPicture
(
event
shadowRoot
.
host
toggle
)
;
return
;
}
}
case
"
mousedown
"
:
case
"
pointerup
"
:
case
"
mouseup
"
:
{
this
.
onMouseButtonEvent
(
event
)
;
break
;
}
case
"
pointerdown
"
:
{
this
.
onPointerDown
(
event
)
;
break
;
}
case
"
mousemove
"
:
{
this
.
onMouseMove
(
event
)
;
break
;
}
case
"
pageshow
"
:
{
this
.
onPageShow
(
event
)
;
break
;
}
case
"
pagehide
"
:
{
this
.
onPageHide
(
event
)
;
break
;
}
}
}
registerVideo
(
video
)
{
let
state
=
this
.
docState
;
if
(
!
state
.
intersectionObserver
)
{
let
fn
=
this
.
onIntersection
.
bind
(
this
)
;
state
.
intersectionObserver
=
new
this
.
contentWindow
.
IntersectionObserver
(
fn
{
threshold
:
[
0
.
0
0
.
5
]
}
)
;
}
state
.
intersectionObserver
.
observe
(
video
)
;
}
worthTracking
(
intersectionEntry
)
{
return
intersectionEntry
.
isIntersecting
;
}
onIntersection
(
entries
)
{
let
state
=
this
.
docState
;
if
(
!
state
)
{
return
;
}
let
oldVisibleVideosCount
=
state
.
visibleVideosCount
;
for
(
let
entry
of
entries
)
{
let
video
=
entry
.
target
;
if
(
this
.
worthTracking
(
entry
)
)
{
if
(
!
state
.
weakVisibleVideos
.
has
(
video
)
)
{
state
.
weakVisibleVideos
.
add
(
video
)
;
state
.
visibleVideosCount
+
+
;
if
(
this
.
toggleTesting
)
{
gWeakIntersectingVideosForTesting
.
add
(
video
)
;
}
}
}
else
if
(
state
.
weakVisibleVideos
.
has
(
video
)
)
{
state
.
weakVisibleVideos
.
delete
(
video
)
;
state
.
visibleVideosCount
-
-
;
if
(
this
.
toggleTesting
)
{
gWeakIntersectingVideosForTesting
.
delete
(
video
)
;
}
}
}
if
(
!
oldVisibleVideosCount
&
&
state
.
visibleVideosCount
)
{
if
(
this
.
toggleTesting
|
|
!
this
.
contentWindow
)
{
this
.
beginTrackingMouseOverVideos
(
)
;
}
else
{
this
.
contentWindow
.
requestIdleCallback
(
(
)
=
>
{
this
.
beginTrackingMouseOverVideos
(
)
;
}
)
;
}
}
else
if
(
oldVisibleVideosCount
&
&
!
state
.
visibleVideosCount
)
{
if
(
this
.
toggleTesting
|
|
!
this
.
contentWindow
)
{
this
.
stopTrackingMouseOverVideos
(
)
;
}
else
{
this
.
contentWindow
.
requestIdleCallback
(
(
)
=
>
{
this
.
stopTrackingMouseOverVideos
(
)
;
}
)
;
}
}
}
addMouseButtonListeners
(
)
{
this
.
contentWindow
.
windowRoot
.
addEventListener
(
"
pointerdown
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
addEventListener
(
"
mousedown
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
addEventListener
(
"
mouseup
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
addEventListener
(
"
pointerup
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
addEventListener
(
"
click
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
addEventListener
(
"
mouseout
"
this
{
capture
:
true
}
)
;
}
removeMouseButtonListeners
(
)
{
if
(
!
this
.
contentWindow
|
|
!
this
.
contentWindow
.
windowRoot
)
{
return
;
}
this
.
contentWindow
.
windowRoot
.
removeEventListener
(
"
pointerdown
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
removeEventListener
(
"
mousedown
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
removeEventListener
(
"
mouseup
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
removeEventListener
(
"
pointerup
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
removeEventListener
(
"
click
"
this
{
capture
:
true
}
)
;
this
.
contentWindow
.
windowRoot
.
removeEventListener
(
"
mouseout
"
this
{
capture
:
true
}
)
;
}
beginTrackingMouseOverVideos
(
)
{
let
state
=
this
.
docState
;
if
(
!
state
.
mousemoveDeferredTask
)
{
state
.
mousemoveDeferredTask
=
new
DeferredTask
(
(
)
=
>
{
this
.
checkLastMouseMove
(
)
;
}
MOUSEMOVE_PROCESSING_DELAY_MS
)
;
}
this
.
document
.
addEventListener
(
"
mousemove
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
this
.
contentWindow
.
addEventListener
(
"
pageshow
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
contentWindow
.
addEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
addMouseButtonListeners
(
)
;
state
.
isTrackingVideos
=
true
;
}
stopTrackingMouseOverVideos
(
)
{
let
state
=
this
.
docState
;
if
(
!
state
.
mousemoveDeferredTask
)
{
return
;
}
state
.
mousemoveDeferredTask
.
disarm
(
)
;
this
.
document
.
removeEventListener
(
"
mousemove
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
if
(
this
.
contentWindow
)
{
this
.
contentWindow
.
removeEventListener
(
"
pageshow
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
contentWindow
.
removeEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
}
this
.
removeMouseButtonListeners
(
)
;
let
oldOverVideo
=
this
.
getWeakOverVideo
(
)
;
if
(
oldOverVideo
)
{
this
.
onMouseLeaveVideo
(
oldOverVideo
)
;
}
state
.
isTrackingVideos
=
false
;
}
onPageShow
(
event
)
{
let
state
=
this
.
docState
;
if
(
state
.
isTrackingVideos
)
{
this
.
addMouseButtonListeners
(
)
;
}
}
onPageHide
(
event
)
{
let
state
=
this
.
docState
;
if
(
state
.
isTrackingVideos
)
{
this
.
removeMouseButtonListeners
(
)
;
}
}
onPointerDown
(
event
)
{
if
(
event
.
button
!
=
0
)
{
return
;
}
let
video
=
this
.
getWeakOverVideo
(
)
;
if
(
!
video
)
{
return
;
}
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
if
(
!
shadowRoot
)
{
return
;
}
let
state
=
this
.
docState
;
let
{
clientX
clientY
}
=
event
;
let
winUtils
=
this
.
contentWindow
.
windowUtils
;
let
elements
=
winUtils
.
nodesFromRect
(
clientX
clientY
1
1
1
1
true
false
true
state
.
toggleVisibilityThreshold
)
;
if
(
!
Array
.
from
(
elements
)
.
includes
(
video
)
)
{
return
;
}
let
toggle
=
this
.
getToggleElement
(
shadowRoot
)
;
if
(
this
.
isMouseOverToggle
(
toggle
event
)
)
{
state
.
isClickingToggle
=
true
;
state
.
clickedElement
=
Cu
.
getWeakReference
(
event
.
originalTarget
)
;
event
.
stopImmediatePropagation
(
)
;
this
.
startPictureInPicture
(
event
video
toggle
)
;
}
}
startPictureInPicture
(
event
video
toggle
)
{
Services
.
telemetry
.
keyedScalarAdd
(
"
pictureinpicture
.
opened_method
"
"
toggle
"
1
)
;
let
args
=
{
method
:
"
toggle
"
firstTimeToggle
:
(
!
Services
.
prefs
.
getBoolPref
(
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
has
-
used
"
)
)
.
toString
(
)
}
;
Services
.
telemetry
.
recordEvent
(
"
pictureinpicture
"
"
opened_method
"
"
method
"
null
args
)
;
let
pipEvent
=
new
this
.
contentWindow
.
CustomEvent
(
"
MozTogglePictureInPicture
"
{
bubbles
:
true
}
)
;
video
.
dispatchEvent
(
pipEvent
)
;
this
.
onMouseLeaveVideo
(
video
)
;
}
onMouseButtonEvent
(
event
)
{
if
(
event
.
button
!
=
0
)
{
return
;
}
let
state
=
this
.
docState
;
if
(
state
.
isClickingToggle
)
{
event
.
stopImmediatePropagation
(
)
;
let
isMouseUpOnOtherElement
=
event
.
type
=
=
"
mouseup
"
&
&
(
!
state
.
clickedElement
|
|
state
.
clickedElement
.
get
(
)
!
=
event
.
originalTarget
)
;
if
(
isMouseUpOnOtherElement
|
|
event
.
type
=
=
"
click
"
)
{
state
.
isClickingToggle
=
false
;
state
.
clickedElement
=
null
;
}
}
}
onMouseOut
(
event
)
{
if
(
!
event
.
relatedTarget
)
{
let
video
=
this
.
getWeakOverVideo
(
)
;
if
(
!
video
)
{
return
;
}
this
.
onMouseLeaveVideo
(
video
)
;
}
}
onMouseMove
(
event
)
{
let
state
=
this
.
docState
;
if
(
state
.
hideToggleDeferredTask
)
{
state
.
hideToggleDeferredTask
.
disarm
(
)
;
state
.
hideToggleDeferredTask
.
arm
(
)
;
}
state
.
lastMouseMoveEvent
=
event
;
state
.
mousemoveDeferredTask
.
arm
(
)
;
}
checkLastMouseMove
(
)
{
let
state
=
this
.
docState
;
let
event
=
state
.
lastMouseMoveEvent
;
let
{
clientX
clientY
}
=
event
;
logConsole
.
debug
(
"
Visible
videos
count
:
"
state
.
visibleVideosCount
)
;
logConsole
.
debug
(
"
Tracking
videos
:
"
state
.
isTrackingVideos
)
;
let
winUtils
=
this
.
contentWindow
.
windowUtils
;
let
elements
=
winUtils
.
nodesFromRect
(
clientX
clientY
1
1
1
1
true
false
true
)
;
for
(
let
element
of
elements
)
{
logConsole
.
debug
(
"
Element
id
under
cursor
:
"
element
.
id
)
;
logConsole
.
debug
(
"
Node
name
of
an
element
under
cursor
:
"
element
.
nodeName
)
;
logConsole
.
debug
(
"
Supported
<
video
>
element
:
"
state
.
weakVisibleVideos
.
has
(
element
)
)
;
logConsole
.
debug
(
"
PiP
window
is
open
:
"
element
.
isCloningElementVisually
)
;
if
(
state
.
weakVisibleVideos
.
has
(
element
)
&
&
!
element
.
isCloningElementVisually
)
{
logConsole
.
debug
(
"
Found
supported
element
"
)
;
this
.
onMouseOverVideo
(
element
event
)
;
return
;
}
}
let
oldOverVideo
=
this
.
getWeakOverVideo
(
)
;
if
(
oldOverVideo
)
{
this
.
onMouseLeaveVideo
(
oldOverVideo
)
;
}
}
onMouseOverVideo
(
video
event
)
{
let
oldOverVideo
=
this
.
getWeakOverVideo
(
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
if
(
shadowRoot
.
firstChild
&
&
video
!
=
oldOverVideo
)
{
if
(
video
.
getTransformToViewport
(
)
.
a
=
=
-
1
)
{
shadowRoot
.
firstChild
.
setAttribute
(
"
flipped
"
true
)
;
}
else
{
shadowRoot
.
firstChild
.
removeAttribute
(
"
flipped
"
)
;
}
}
if
(
!
shadowRoot
)
{
if
(
oldOverVideo
)
{
this
.
onMouseLeaveVideo
(
oldOverVideo
)
;
}
return
;
}
let
state
=
this
.
docState
;
let
toggle
=
this
.
getToggleElement
(
shadowRoot
)
;
let
controlsOverlay
=
shadowRoot
.
querySelector
(
"
.
controlsOverlay
"
)
;
if
(
state
.
checkedPolicyDocumentURI
!
=
this
.
document
.
documentURI
)
{
state
.
togglePolicy
=
TOGGLE_POLICIES
.
DEFAULT
;
let
siteOverrides
=
this
.
toggleTesting
?
PictureInPictureToggleChild
.
getSiteOverrides
(
)
:
gSiteOverrides
;
let
visibilityThresholdPref
=
Services
.
prefs
.
getFloatPref
(
TOGGLE_VISIBILITY_THRESHOLD_PREF
"
1
.
0
"
)
;
if
(
!
this
.
videoWrapper
)
{
this
.
videoWrapper
=
applyWrapper
(
this
video
)
;
}
for
(
let
[
override
{
policy
visibilityThreshold
}
]
of
siteOverrides
)
{
if
(
(
policy
|
|
visibilityThreshold
)
&
&
override
.
matches
(
this
.
document
.
documentURI
)
)
{
state
.
togglePolicy
=
this
.
videoWrapper
?
.
shouldHideToggle
(
video
)
?
TOGGLE_POLICIES
.
HIDDEN
:
policy
|
|
TOGGLE_POLICIES
.
DEFAULT
;
state
.
toggleVisibilityThreshold
=
visibilityThreshold
|
|
visibilityThresholdPref
;
break
;
}
}
state
.
checkedPolicyDocumentURI
=
this
.
document
.
documentURI
;
}
if
(
state
.
togglePolicy
!
=
TOGGLE_POLICIES
.
DEFAULT
&
&
!
(
state
.
togglePolicy
=
=
TOGGLE_POLICIES
.
BOTTOM
&
&
video
.
controls
)
)
{
toggle
.
setAttribute
(
"
policy
"
TOGGLE_POLICY_STRINGS
[
state
.
togglePolicy
]
)
;
}
else
{
toggle
.
removeAttribute
(
"
policy
"
)
;
}
const
nimbusExperimentVariables
=
NimbusFeatures
.
pictureinpicture
.
getAllVariables
(
{
defaultValues
:
{
title
:
null
message
:
false
showIconOnly
:
false
}
}
)
;
if
(
nimbusExperimentVariables
.
title
&
&
nimbusExperimentVariables
.
message
)
{
let
pipExplainer
=
shadowRoot
.
querySelector
(
"
.
pip
-
explainer
"
)
;
let
pipLabel
=
shadowRoot
.
querySelector
(
"
.
pip
-
label
"
)
;
pipExplainer
.
innerText
=
nimbusExperimentVariables
.
message
;
pipLabel
.
innerText
=
nimbusExperimentVariables
.
title
;
}
else
if
(
nimbusExperimentVariables
.
showIconOnly
)
{
let
pipExpanded
=
shadowRoot
.
querySelector
(
"
.
pip
-
expanded
"
)
;
pipExpanded
.
style
.
display
=
"
none
"
;
let
pipSmall
=
shadowRoot
.
querySelector
(
"
.
pip
-
small
"
)
;
pipSmall
.
style
.
opacity
=
"
1
"
;
let
pipIcon
=
shadowRoot
.
querySelectorAll
(
"
.
pip
-
icon
"
)
[
1
]
;
pipIcon
.
style
.
display
=
"
block
"
;
}
controlsOverlay
.
removeAttribute
(
"
hidetoggle
"
)
;
if
(
!
state
.
hideToggleDeferredTask
&
&
!
this
.
toggleTesting
)
{
state
.
hideToggleDeferredTask
=
new
DeferredTask
(
(
)
=
>
{
controlsOverlay
.
setAttribute
(
"
hidetoggle
"
true
)
;
}
TOGGLE_HIDING_TIMEOUT_MS
)
;
}
if
(
oldOverVideo
)
{
if
(
oldOverVideo
=
=
video
)
{
this
.
checkHoverToggle
(
toggle
event
)
;
return
;
}
this
.
onMouseLeaveVideo
(
oldOverVideo
)
;
}
state
.
weakOverVideo
=
Cu
.
getWeakReference
(
video
)
;
controlsOverlay
.
classList
.
add
(
"
hovering
"
)
;
if
(
state
.
togglePolicy
!
=
TOGGLE_POLICIES
.
HIDDEN
&
&
!
toggle
.
hasAttribute
(
"
hidden
"
)
)
{
Services
.
telemetry
.
scalarAdd
(
"
pictureinpicture
.
saw_toggle
"
1
)
;
const
hasUsedPiP
=
Services
.
prefs
.
getBoolPref
(
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
has
-
used
"
)
;
let
args
=
{
firstTime
:
(
!
hasUsedPiP
)
.
toString
(
)
}
;
Services
.
telemetry
.
recordEvent
(
"
pictureinpicture
"
"
saw_toggle
"
"
toggle
"
null
args
)
;
if
(
!
hasUsedPiP
)
{
NimbusFeatures
.
pictureinpicture
.
recordExposureEvent
(
)
;
}
}
this
.
checkHoverToggle
(
toggle
event
)
;
}
checkHoverToggle
(
toggle
event
)
{
toggle
.
classList
.
toggle
(
"
hovering
"
this
.
isMouseOverToggle
(
toggle
event
)
)
;
}
onMouseLeaveVideo
(
video
)
{
let
state
=
this
.
docState
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
if
(
shadowRoot
)
{
let
controlsOverlay
=
shadowRoot
.
querySelector
(
"
.
controlsOverlay
"
)
;
let
toggle
=
this
.
getToggleElement
(
shadowRoot
)
;
controlsOverlay
.
classList
.
remove
(
"
hovering
"
)
;
toggle
.
classList
.
remove
(
"
hovering
"
)
;
}
state
.
weakOverVideo
=
null
;
if
(
!
this
.
toggleTesting
)
{
state
.
hideToggleDeferredTask
.
disarm
(
)
;
state
.
mousemoveDeferredTask
.
disarm
(
)
;
}
state
.
hideToggleDeferredTask
=
null
;
}
isMouseOverToggle
(
toggle
event
)
{
let
toggleRect
=
toggle
.
ownerGlobal
.
windowUtils
.
getBoundsWithoutFlushing
(
toggle
)
;
toggleRect
=
Rect
.
fromRect
(
toggleRect
)
;
let
clickableChildren
=
toggle
.
querySelectorAll
(
"
.
clickable
"
)
;
for
(
let
child
of
clickableChildren
)
{
let
childRect
=
Rect
.
fromRect
(
child
.
ownerGlobal
.
windowUtils
.
getBoundsWithoutFlushing
(
child
)
)
;
toggleRect
.
expandToContain
(
childRect
)
;
}
if
(
!
toggleRect
.
width
|
|
!
toggleRect
.
height
)
{
return
false
;
}
let
{
clientX
clientY
}
=
event
;
return
(
clientX
>
=
toggleRect
.
left
&
&
clientX
<
=
toggleRect
.
right
&
&
clientY
>
=
toggleRect
.
top
&
&
clientY
<
=
toggleRect
.
bottom
)
;
}
checkContextMenu
(
event
)
{
let
video
=
this
.
getWeakOverVideo
(
)
;
if
(
!
video
)
{
return
;
}
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
if
(
!
shadowRoot
)
{
return
;
}
let
toggle
=
this
.
getToggleElement
(
shadowRoot
)
;
if
(
this
.
isMouseOverToggle
(
toggle
event
)
)
{
let
devicePixelRatio
=
toggle
.
ownerGlobal
.
devicePixelRatio
;
this
.
sendAsyncMessage
(
"
PictureInPicture
:
OpenToggleContextMenu
"
{
screenXDevPx
:
event
.
screenX
*
devicePixelRatio
screenYDevPx
:
event
.
screenY
*
devicePixelRatio
mozInputSource
:
event
.
mozInputSource
}
)
;
event
.
stopImmediatePropagation
(
)
;
event
.
preventDefault
(
)
;
}
}
getToggleElement
(
shadowRoot
)
{
return
shadowRoot
.
getElementById
(
"
pictureInPictureToggle
"
)
;
}
static
isTracking
(
video
)
{
return
gWeakIntersectingVideosForTesting
.
has
(
video
)
;
}
static
getSiteOverrides
(
)
{
let
result
=
[
]
;
let
patterns
=
Services
.
cpmm
.
sharedData
.
get
(
"
PictureInPicture
:
SiteOverrides
"
)
;
for
(
let
pattern
in
patterns
)
{
let
matcher
=
new
MatchPattern
(
pattern
)
;
result
.
push
(
[
matcher
patterns
[
pattern
]
]
)
;
}
return
result
;
}
}
class
PictureInPictureChild
extends
JSWindowActorChild
{
weakVideo
=
null
;
weakPlayerContent
=
null
;
_currentWebVTTTrack
=
null
;
observerFunction
=
null
;
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
nsPref
:
changed
"
)
{
return
;
}
switch
(
data
)
{
case
"
media
.
videocontrols
.
picture
-
in
-
picture
.
display
-
text
-
tracks
.
enabled
"
:
{
const
originatingVideo
=
this
.
getWeakVideo
(
)
;
let
isTextTrackPrefEnabled
=
Services
.
prefs
.
getBoolPref
(
"
media
.
videocontrols
.
picture
-
in
-
picture
.
display
-
text
-
tracks
.
enabled
"
)
;
if
(
isTextTrackPrefEnabled
)
{
this
.
setupTextTracks
(
originatingVideo
)
;
}
else
{
this
.
removeTextTracks
(
originatingVideo
)
;
}
break
;
}
case
TEXT_TRACK_FONT_SIZE
:
this
.
setTextTrackFontSize
(
)
;
break
;
}
}
createTextTracksStyleSheet
(
)
{
let
headStyleElement
=
this
.
document
.
createElement
(
"
link
"
)
;
headStyleElement
.
setAttribute
(
"
rel
"
"
stylesheet
"
)
;
headStyleElement
.
setAttribute
(
"
href
"
"
chrome
:
/
/
global
/
skin
/
pictureinpicture
/
texttracks
.
css
"
)
;
headStyleElement
.
setAttribute
(
"
type
"
"
text
/
css
"
)
;
return
headStyleElement
;
}
setupTextTracks
(
originatingVideo
)
{
const
isWebVTTSupported
=
!
!
originatingVideo
.
textTracks
?
.
length
;
if
(
!
isWebVTTSupported
)
{
this
.
setUpCaptionChangeListener
(
originatingVideo
)
;
return
;
}
this
.
setActiveTextTrack
(
originatingVideo
.
textTracks
)
;
if
(
!
this
.
_currentWebVTTTrack
)
{
return
;
}
originatingVideo
.
textTracks
.
addEventListener
(
"
change
"
this
)
;
this
.
_currentWebVTTTrack
.
addEventListener
(
"
cuechange
"
this
.
onCueChange
)
;
const
cues
=
this
.
_currentWebVTTTrack
.
activeCues
;
this
.
updateWebVTTTextTracksDisplay
(
cues
)
;
}
removeTextTracks
(
originatingVideo
)
{
const
isWebVTTSupported
=
!
!
originatingVideo
.
textTracks
;
if
(
!
isWebVTTSupported
)
{
return
;
}
originatingVideo
.
textTracks
.
removeEventListener
(
"
change
"
this
)
;
this
.
_currentWebVTTTrack
?
.
removeEventListener
(
"
cuechange
"
this
.
onCueChange
)
;
this
.
_currentWebVTTTrack
=
null
;
this
.
updateWebVTTTextTracksDisplay
(
null
)
;
}
moveTextTracks
(
data
)
{
const
{
isFullscreen
isVideoControlsShowing
playerBottomControlsDOMRect
}
=
data
;
let
textTracks
=
this
.
document
.
getElementById
(
"
texttracks
"
)
;
const
originatingWindow
=
this
.
getWeakVideo
(
)
.
ownerGlobal
;
const
isReducedMotionEnabled
=
originatingWindow
.
matchMedia
(
"
(
prefers
-
reduced
-
motion
:
reduce
)
"
)
.
matches
;
const
textTracksFontScale
=
this
.
document
.
querySelector
(
"
:
root
"
)
.
style
.
getPropertyValue
(
"
-
-
font
-
scale
"
)
;
if
(
isFullscreen
|
|
isReducedMotionEnabled
)
{
textTracks
.
removeAttribute
(
"
overlap
-
video
-
controls
"
)
;
return
;
}
if
(
isVideoControlsShowing
)
{
let
playerVideoRect
=
textTracks
.
parentElement
.
getBoundingClientRect
(
)
;
let
isOverlap
=
playerVideoRect
.
bottom
-
textTracksFontScale
*
playerVideoRect
.
height
>
playerBottomControlsDOMRect
.
top
;
if
(
isOverlap
)
{
textTracks
.
setAttribute
(
"
overlap
-
video
-
controls
"
true
)
;
}
else
{
textTracks
.
removeAttribute
(
"
overlap
-
video
-
controls
"
)
;
}
}
else
{
textTracks
.
removeAttribute
(
"
overlap
-
video
-
controls
"
)
;
}
}
updateWebVTTTextTracksDisplay
(
textTrackCues
)
{
let
pipWindowTracksContainer
=
this
.
document
.
getElementById
(
"
texttracks
"
)
;
let
playerVideo
=
this
.
document
.
getElementById
(
"
playervideo
"
)
;
let
playerVideoWindow
=
playerVideo
.
ownerGlobal
;
pipWindowTracksContainer
.
replaceChildren
(
)
;
if
(
!
textTrackCues
)
{
return
;
}
let
allCuesArray
=
[
.
.
.
textTrackCues
]
;
this
.
getOrderedWebVTTCues
(
allCuesArray
)
;
allCuesArray
.
forEach
(
cue
=
>
{
let
text
=
cue
.
text
;
let
cueTextNode
=
WebVTT
.
convertCueToDOMTree
(
playerVideoWindow
text
)
;
let
cueDiv
=
this
.
document
.
createElement
(
"
div
"
)
;
cueDiv
.
appendChild
(
cueTextNode
)
;
pipWindowTracksContainer
.
appendChild
(
cueDiv
)
;
}
)
;
}
getOrderedWebVTTCues
(
allCuesArray
)
{
if
(
!
allCuesArray
|
|
allCuesArray
.
length
<
=
1
)
{
return
;
}
let
allCuesHaveNumericLines
=
allCuesArray
.
find
(
cue
=
>
cue
.
line
!
=
=
"
auto
"
)
;
if
(
allCuesHaveNumericLines
)
{
allCuesArray
.
sort
(
(
cue1
cue2
)
=
>
cue1
.
line
-
cue2
.
line
)
;
}
else
if
(
allCuesArray
.
length
>
=
2
)
{
allCuesArray
.
reverse
(
)
;
}
}
getWeakVideo
(
)
{
if
(
this
.
weakVideo
)
{
try
{
return
this
.
weakVideo
.
get
(
)
;
}
catch
(
e
)
{
return
null
;
}
}
return
null
;
}
getWeakPlayerContent
(
)
{
if
(
this
.
weakPlayerContent
)
{
try
{
return
this
.
weakPlayerContent
.
get
(
)
;
}
catch
(
e
)
{
return
null
;
}
}
return
null
;
}
inPictureInPicture
(
video
)
{
return
this
.
getWeakVideo
(
)
=
=
=
video
;
}
static
videoIsPlaying
(
video
)
{
return
!
!
(
!
video
.
paused
&
&
!
video
.
ended
&
&
video
.
readyState
>
2
)
;
}
static
videoIsMuted
(
video
)
{
return
video
.
muted
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
MozStopPictureInPicture
"
:
{
if
(
event
.
isTrusted
&
&
event
.
target
=
=
=
this
.
getWeakVideo
(
)
)
{
const
reason
=
event
.
detail
?
.
reason
|
|
"
video
-
el
-
remove
"
;
this
.
closePictureInPicture
(
{
reason
}
)
;
}
break
;
}
case
"
pagehide
"
:
{
this
.
closePictureInPicture
(
{
reason
:
"
pagehide
"
}
)
;
break
;
}
case
"
MozDOMFullscreen
:
Request
"
:
{
this
.
closePictureInPicture
(
{
reason
:
"
fullscreen
"
}
)
;
break
;
}
case
"
play
"
:
{
this
.
sendAsyncMessage
(
"
PictureInPicture
:
Playing
"
)
;
break
;
}
case
"
pause
"
:
{
this
.
sendAsyncMessage
(
"
PictureInPicture
:
Paused
"
)
;
break
;
}
case
"
volumechange
"
:
{
let
video
=
this
.
getWeakVideo
(
)
;
if
(
video
!
=
=
event
.
target
)
{
Cu
.
reportError
(
"
PictureInPictureChild
received
volumechange
for
"
+
"
the
wrong
video
!
"
)
;
return
;
}
if
(
video
.
muted
)
{
this
.
sendAsyncMessage
(
"
PictureInPicture
:
Muting
"
)
;
}
else
{
this
.
sendAsyncMessage
(
"
PictureInPicture
:
Unmuting
"
)
;
}
break
;
}
case
"
resize
"
:
{
let
video
=
event
.
target
;
if
(
this
.
inPictureInPicture
(
video
)
)
{
this
.
sendAsyncMessage
(
"
PictureInPicture
:
Resize
"
{
videoHeight
:
video
.
videoHeight
videoWidth
:
video
.
videoWidth
}
)
;
}
this
.
setupTextTracks
(
video
)
;
break
;
}
case
"
emptied
"
:
{
if
(
this
.
emptiedTimeout
)
{
clearTimeout
(
this
.
emptiedTimeout
)
;
this
.
emptiedTimeout
=
null
;
}
let
video
=
this
.
getWeakVideo
(
)
;
this
.
emptiedTimeout
=
setTimeout
(
(
)
=
>
{
if
(
!
video
|
|
!
video
.
src
)
{
this
.
closePictureInPicture
(
{
reason
:
"
video
-
el
-
emptied
"
}
)
;
}
}
EMPTIED_TIMEOUT_MS
)
;
break
;
}
case
"
change
"
:
{
if
(
this
.
_currentWebVTTTrack
)
{
this
.
_currentWebVTTTrack
.
removeEventListener
(
"
cuechange
"
this
.
onCueChange
)
;
this
.
_currentWebVTTTrack
=
null
;
}
const
tracks
=
event
.
target
;
this
.
setActiveTextTrack
(
tracks
)
;
const
isCurrentTrackAvailable
=
this
.
_currentWebVTTTrack
;
if
(
!
isCurrentTrackAvailable
|
|
!
tracks
.
length
)
{
this
.
updateWebVTTTextTracksDisplay
(
null
)
;
return
;
}
this
.
_currentWebVTTTrack
.
addEventListener
(
"
cuechange
"
this
.
onCueChange
)
;
const
cues
=
this
.
_currentWebVTTTrack
.
activeCues
;
this
.
updateWebVTTTextTracksDisplay
(
cues
)
;
break
;
}
}
}
async
closePictureInPicture
(
{
reason
}
)
{
let
video
=
this
.
getWeakVideo
(
)
;
if
(
video
)
{
this
.
untrackOriginatingVideo
(
video
)
;
}
this
.
sendAsyncMessage
(
"
PictureInPicture
:
Close
"
{
reason
}
)
;
let
playerContent
=
this
.
getWeakPlayerContent
(
)
;
if
(
playerContent
)
{
if
(
!
playerContent
.
closed
)
{
await
new
Promise
(
resolve
=
>
{
playerContent
.
addEventListener
(
"
unload
"
resolve
{
once
:
true
}
)
;
}
)
;
}
this
.
weakPlayerContent
=
null
;
}
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
PictureInPicture
:
SetupPlayer
"
:
{
const
{
videoRef
}
=
message
.
data
;
this
.
setupPlayer
(
videoRef
)
;
break
;
}
case
"
PictureInPicture
:
Play
"
:
{
this
.
play
(
)
;
break
;
}
case
"
PictureInPicture
:
Pause
"
:
{
if
(
message
.
data
&
&
message
.
data
.
reason
=
=
"
pip
-
closed
"
)
{
let
video
=
this
.
getWeakVideo
(
)
;
if
(
video
&
&
MediaStream
.
isInstance
(
video
.
srcObject
)
)
{
break
;
}
}
this
.
pause
(
)
;
break
;
}
case
"
PictureInPicture
:
Mute
"
:
{
this
.
mute
(
)
;
break
;
}
case
"
PictureInPicture
:
Unmute
"
:
{
this
.
unmute
(
)
;
break
;
}
case
"
PictureInPicture
:
KeyDown
"
:
{
this
.
keyDown
(
message
.
data
)
;
break
;
}
case
"
PictureInPicture
:
EnterFullscreen
"
:
case
"
PictureInPicture
:
ExitFullscreen
"
:
{
let
textTracks
=
this
.
document
.
getElementById
(
"
texttracks
"
)
;
if
(
textTracks
)
{
this
.
moveTextTracks
(
message
.
data
)
;
}
break
;
}
case
"
PictureInPicture
:
ShowVideoControls
"
:
case
"
PictureInPicture
:
HideVideoControls
"
:
{
let
textTracks
=
this
.
document
.
getElementById
(
"
texttracks
"
)
;
if
(
textTracks
)
{
this
.
moveTextTracks
(
message
.
data
)
;
}
break
;
}
}
}
setActiveTextTrack
(
textTrackList
)
{
this
.
_currentWebVTTTrack
=
null
;
for
(
let
i
=
0
;
i
<
textTrackList
.
length
;
i
+
+
)
{
let
track
=
textTrackList
[
i
]
;
let
isCCText
=
track
.
kind
=
=
=
"
subtitles
"
|
|
track
.
kind
=
=
=
"
captions
"
;
if
(
isCCText
&
&
track
.
mode
=
=
=
"
showing
"
)
{
this
.
_currentWebVTTTrack
=
track
;
break
;
}
}
}
setTextTrackFontSize
(
)
{
const
fontSize
=
Services
.
prefs
.
getStringPref
(
TEXT_TRACK_FONT_SIZE
"
medium
"
)
;
const
root
=
this
.
document
.
querySelector
(
"
:
root
"
)
;
if
(
fontSize
=
=
=
"
small
"
)
{
root
.
style
.
setProperty
(
"
-
-
font
-
scale
"
"
0
.
03
"
)
;
}
else
if
(
fontSize
=
=
=
"
large
"
)
{
root
.
style
.
setProperty
(
"
-
-
font
-
scale
"
"
0
.
09
"
)
;
}
else
{
root
.
style
.
setProperty
(
"
-
-
font
-
scale
"
"
0
.
06
"
)
;
}
}
trackOriginatingVideo
(
originatingVideo
)
{
this
.
observerFunction
=
(
subject
topic
data
)
=
>
{
this
.
observe
(
subject
topic
data
)
;
}
;
Services
.
prefs
.
addObserver
(
"
media
.
videocontrols
.
picture
-
in
-
picture
.
display
-
text
-
tracks
.
enabled
"
this
.
observerFunction
)
;
Services
.
prefs
.
addObserver
(
TEXT_TRACK_FONT_SIZE
this
.
observerFunction
)
;
let
originatingWindow
=
originatingVideo
.
ownerGlobal
;
if
(
originatingWindow
)
{
originatingWindow
.
addEventListener
(
"
pagehide
"
this
)
;
originatingVideo
.
addEventListener
(
"
play
"
this
)
;
originatingVideo
.
addEventListener
(
"
pause
"
this
)
;
originatingVideo
.
addEventListener
(
"
volumechange
"
this
)
;
originatingVideo
.
addEventListener
(
"
resize
"
this
)
;
originatingVideo
.
addEventListener
(
"
emptied
"
this
)
;
if
(
DISPLAY_TEXT_TRACKS_PREF
)
{
this
.
setupTextTracks
(
originatingVideo
)
;
}
let
chromeEventHandler
=
originatingWindow
.
docShell
.
chromeEventHandler
;
chromeEventHandler
.
addEventListener
(
"
MozDOMFullscreen
:
Request
"
this
true
)
;
chromeEventHandler
.
addEventListener
(
"
MozStopPictureInPicture
"
this
true
)
;
}
}
setUpCaptionChangeListener
(
originatingVideo
)
{
if
(
this
.
videoWrapper
)
{
this
.
videoWrapper
.
setCaptionContainerObserver
(
originatingVideo
this
)
;
}
}
untrackOriginatingVideo
(
originatingVideo
)
{
Services
.
prefs
.
removeObserver
(
"
media
.
videocontrols
.
picture
-
in
-
picture
.
display
-
text
-
tracks
.
enabled
"
this
.
observerFunction
)
;
let
originatingWindow
=
originatingVideo
.
ownerGlobal
;
if
(
originatingWindow
)
{
originatingWindow
.
removeEventListener
(
"
pagehide
"
this
)
;
originatingVideo
.
removeEventListener
(
"
play
"
this
)
;
originatingVideo
.
removeEventListener
(
"
pause
"
this
)
;
originatingVideo
.
removeEventListener
(
"
volumechange
"
this
)
;
originatingVideo
.
removeEventListener
(
"
resize
"
this
)
;
originatingVideo
.
removeEventListener
(
"
emptied
"
this
)
;
if
(
DISPLAY_TEXT_TRACKS_PREF
)
{
this
.
removeTextTracks
(
originatingVideo
)
;
}
let
chromeEventHandler
=
originatingWindow
.
docShell
.
chromeEventHandler
;
chromeEventHandler
.
removeEventListener
(
"
MozDOMFullscreen
:
Request
"
this
true
)
;
chromeEventHandler
.
removeEventListener
(
"
MozStopPictureInPicture
"
this
true
)
;
}
}
async
setupPlayer
(
videoRef
)
{
const
video
=
await
ContentDOMReference
.
resolve
(
videoRef
)
;
this
.
weakVideo
=
Cu
.
getWeakReference
(
video
)
;
let
originatingVideo
=
this
.
getWeakVideo
(
)
;
if
(
!
originatingVideo
)
{
await
this
.
closePictureInPicture
(
{
reason
:
"
setup
-
failure
"
}
)
;
return
;
}
this
.
videoWrapper
=
applyWrapper
(
this
originatingVideo
)
;
let
loadPromise
=
new
Promise
(
resolve
=
>
{
this
.
contentWindow
.
addEventListener
(
"
load
"
resolve
{
once
:
true
mozSystemGroup
:
true
capture
:
true
}
)
;
}
)
;
this
.
contentWindow
.
location
.
reload
(
)
;
await
loadPromise
;
this
.
weakPlayerContent
=
Cu
.
getWeakReference
(
this
.
contentWindow
)
;
gPlayerContents
.
add
(
this
.
contentWindow
)
;
let
doc
=
this
.
document
;
let
playerVideo
=
doc
.
createElement
(
"
video
"
)
;
playerVideo
.
id
=
"
playervideo
"
;
let
textTracks
=
doc
.
createElement
(
"
div
"
)
;
doc
.
body
.
style
.
overflow
=
"
hidden
"
;
doc
.
body
.
style
.
margin
=
"
0
"
;
playerVideo
.
style
.
height
=
"
100vh
"
;
playerVideo
.
style
.
width
=
"
100vw
"
;
playerVideo
.
style
.
backgroundColor
=
"
#
000
"
;
textTracks
.
id
=
"
texttracks
"
;
textTracks
.
setAttribute
(
"
overlap
-
video
-
controls
"
true
)
;
doc
.
body
.
appendChild
(
playerVideo
)
;
doc
.
body
.
appendChild
(
textTracks
)
;
let
textTracksStyleSheet
=
this
.
createTextTracksStyleSheet
(
)
;
doc
.
head
.
appendChild
(
textTracksStyleSheet
)
;
this
.
setTextTrackFontSize
(
)
;
originatingVideo
.
cloneElementVisually
(
playerVideo
)
;
let
shadowRoot
=
originatingVideo
.
openOrClosedShadowRoot
;
if
(
originatingVideo
.
getTransformToViewport
(
)
.
a
=
=
-
1
)
{
shadowRoot
.
firstChild
.
setAttribute
(
"
flipped
"
true
)
;
playerVideo
.
style
.
transform
=
"
scaleX
(
-
1
)
"
;
}
this
.
onCueChange
=
this
.
onCueChange
.
bind
(
this
)
;
this
.
trackOriginatingVideo
(
originatingVideo
)
;
this
.
contentWindow
.
addEventListener
(
"
unload
"
(
)
=
>
{
let
video
=
this
.
getWeakVideo
(
)
;
if
(
video
)
{
this
.
untrackOriginatingVideo
(
video
)
;
video
.
stopCloningElementVisually
(
)
;
}
this
.
weakVideo
=
null
;
}
{
once
:
true
}
)
;
}
play
(
)
{
let
video
=
this
.
getWeakVideo
(
)
;
if
(
video
&
&
this
.
videoWrapper
)
{
this
.
videoWrapper
.
play
(
video
)
;
}
}
pause
(
)
{
let
video
=
this
.
getWeakVideo
(
)
;
if
(
video
&
&
this
.
videoWrapper
)
{
this
.
videoWrapper
.
pause
(
video
)
;
}
}
mute
(
)
{
let
video
=
this
.
getWeakVideo
(
)
;
if
(
video
&
&
this
.
videoWrapper
)
{
this
.
videoWrapper
.
setMuted
(
video
true
)
;
}
}
unmute
(
)
{
let
video
=
this
.
getWeakVideo
(
)
;
if
(
video
&
&
this
.
videoWrapper
)
{
this
.
videoWrapper
.
setMuted
(
video
false
)
;
}
}
onCueChange
(
e
)
{
if
(
!
DISPLAY_TEXT_TRACKS_PREF
)
{
this
.
updateWebVTTTextTracksDisplay
(
null
)
;
}
else
{
const
cues
=
this
.
_currentWebVTTTrack
.
activeCues
;
this
.
updateWebVTTTextTracksDisplay
(
cues
)
;
}
}
isKeyEnabled
(
key
)
{
const
video
=
this
.
getWeakVideo
(
)
;
if
(
!
video
)
{
return
false
;
}
const
{
documentURI
}
=
video
.
ownerDocument
;
if
(
!
documentURI
)
{
return
true
;
}
for
(
let
[
override
{
keyboardControls
}
]
of
gSiteOverrides
)
{
if
(
keyboardControls
!
=
=
undefined
&
&
override
.
matches
(
documentURI
)
)
{
if
(
keyboardControls
=
=
=
KEYBOARD_CONTROLS
.
NONE
)
{
return
false
;
}
return
keyboardControls
&
key
;
}
}
return
true
;
}
keyDown
(
{
altKey
shiftKey
metaKey
ctrlKey
keyCode
}
)
{
let
video
=
this
.
getWeakVideo
(
)
;
if
(
!
video
)
{
return
;
}
var
keystroke
=
"
"
;
if
(
altKey
)
{
keystroke
+
=
"
alt
-
"
;
}
if
(
shiftKey
)
{
keystroke
+
=
"
shift
-
"
;
}
if
(
this
.
contentWindow
.
navigator
.
platform
.
startsWith
(
"
Mac
"
)
)
{
if
(
metaKey
)
{
keystroke
+
=
"
accel
-
"
;
}
if
(
ctrlKey
)
{
keystroke
+
=
"
control
-
"
;
}
}
else
{
if
(
metaKey
)
{
keystroke
+
=
"
meta
-
"
;
}
if
(
ctrlKey
)
{
keystroke
+
=
"
accel
-
"
;
}
}
switch
(
keyCode
)
{
case
this
.
contentWindow
.
KeyEvent
.
DOM_VK_UP
:
keystroke
+
=
"
upArrow
"
;
break
;
case
this
.
contentWindow
.
KeyEvent
.
DOM_VK_DOWN
:
keystroke
+
=
"
downArrow
"
;
break
;
case
this
.
contentWindow
.
KeyEvent
.
DOM_VK_LEFT
:
keystroke
+
=
"
leftArrow
"
;
break
;
case
this
.
contentWindow
.
KeyEvent
.
DOM_VK_RIGHT
:
keystroke
+
=
"
rightArrow
"
;
break
;
case
this
.
contentWindow
.
KeyEvent
.
DOM_VK_HOME
:
keystroke
+
=
"
home
"
;
break
;
case
this
.
contentWindow
.
KeyEvent
.
DOM_VK_END
:
keystroke
+
=
"
end
"
;
break
;
case
this
.
contentWindow
.
KeyEvent
.
DOM_VK_SPACE
:
keystroke
+
=
"
space
"
;
break
;
case
this
.
contentWindow
.
KeyEvent
.
DOM_VK_W
:
keystroke
+
=
"
w
"
;
break
;
}
const
isVideoStreaming
=
this
.
videoWrapper
.
getDuration
(
video
)
=
=
+
Infinity
;
var
oldval
newval
;
try
{
switch
(
keystroke
)
{
case
"
space
"
:
if
(
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
PLAY_PAUSE
)
)
{
return
;
}
if
(
this
.
videoWrapper
.
getPaused
(
video
)
|
|
this
.
videoWrapper
.
getEnded
(
video
)
)
{
this
.
videoWrapper
.
play
(
video
)
;
}
else
{
this
.
videoWrapper
.
pause
(
video
)
;
}
break
;
case
"
accel
-
w
"
:
if
(
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
CLOSE
)
)
{
return
;
}
this
.
pause
(
)
;
this
.
closePictureInPicture
(
{
reason
:
"
close
-
player
-
shortcut
"
}
)
;
break
;
case
"
downArrow
"
:
if
(
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
VOLUME
)
)
{
return
;
}
oldval
=
this
.
videoWrapper
.
getVolume
(
video
)
;
this
.
videoWrapper
.
setVolume
(
video
oldval
<
0
.
1
?
0
:
oldval
-
0
.
1
)
;
this
.
videoWrapper
.
setMuted
(
video
false
)
;
break
;
case
"
upArrow
"
:
if
(
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
VOLUME
)
)
{
return
;
}
oldval
=
this
.
videoWrapper
.
getVolume
(
video
)
;
this
.
videoWrapper
.
setVolume
(
video
oldval
>
0
.
9
?
1
:
oldval
+
0
.
1
)
;
this
.
videoWrapper
.
setMuted
(
video
false
)
;
break
;
case
"
accel
-
downArrow
"
:
if
(
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
MUTE_UNMUTE
)
)
{
return
;
}
this
.
videoWrapper
.
setMuted
(
video
true
)
;
break
;
case
"
accel
-
upArrow
"
:
if
(
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
MUTE_UNMUTE
)
)
{
return
;
}
this
.
videoWrapper
.
setMuted
(
video
false
)
;
break
;
case
"
leftArrow
"
:
case
"
accel
-
leftArrow
"
:
if
(
isVideoStreaming
|
|
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
SEEK
)
)
{
return
;
}
oldval
=
this
.
videoWrapper
.
getCurrentTime
(
video
)
;
if
(
keystroke
=
=
"
leftArrow
"
)
{
newval
=
oldval
-
SEEK_TIME_SECS
;
}
else
{
newval
=
oldval
-
this
.
videoWrapper
.
getDuration
(
video
)
/
10
;
}
this
.
videoWrapper
.
setCurrentTime
(
video
newval
>
=
0
?
newval
:
0
)
;
break
;
case
"
rightArrow
"
:
case
"
accel
-
rightArrow
"
:
if
(
isVideoStreaming
|
|
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
SEEK
)
)
{
return
;
}
oldval
=
this
.
videoWrapper
.
getCurrentTime
(
video
)
;
var
maxtime
=
this
.
videoWrapper
.
getDuration
(
video
)
;
if
(
keystroke
=
=
"
rightArrow
"
)
{
newval
=
oldval
+
SEEK_TIME_SECS
;
}
else
{
newval
=
oldval
+
maxtime
/
10
;
}
let
selectedTime
=
newval
<
=
maxtime
?
newval
:
maxtime
;
this
.
videoWrapper
.
setCurrentTime
(
video
selectedTime
)
;
break
;
case
"
home
"
:
if
(
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
SEEK
)
)
{
return
;
}
if
(
!
isVideoStreaming
)
{
this
.
videoWrapper
.
setCurrentTime
(
video
0
)
;
}
break
;
case
"
end
"
:
if
(
!
this
.
isKeyEnabled
(
KEYBOARD_CONTROLS
.
SEEK
)
)
{
return
;
}
let
duration
=
this
.
videoWrapper
.
getDuration
(
video
)
;
if
(
!
isVideoStreaming
&
&
this
.
videoWrapper
.
getCurrentTime
(
video
)
!
=
duration
)
{
this
.
videoWrapper
.
setCurrentTime
(
video
duration
)
;
}
break
;
default
:
}
}
catch
(
e
)
{
}
}
}
class
PictureInPictureChildVideoWrapper
{
#
sandbox
;
#
siteWrapper
;
#
PictureInPictureChild
;
constructor
(
videoWrapperScriptPath
video
piPChild
)
{
this
.
#
sandbox
=
videoWrapperScriptPath
?
this
.
#
createSandbox
(
videoWrapperScriptPath
video
)
:
null
;
this
.
#
PictureInPictureChild
=
piPChild
;
}
#
callWrapperMethod
(
{
name
args
=
[
]
fallback
=
(
)
=
>
{
}
validateRetVal
}
)
{
try
{
const
wrappedMethod
=
this
.
#
siteWrapper
?
.
[
name
]
;
if
(
typeof
wrappedMethod
=
=
=
"
function
"
)
{
let
retVal
=
wrappedMethod
.
call
(
this
.
#
siteWrapper
.
.
.
args
)
;
if
(
!
validateRetVal
)
{
Cu
.
reportError
(
No
return
value
validator
was
provided
for
method
{
name
}
(
)
.
Returning
null
.
)
;
return
null
;
}
if
(
!
validateRetVal
(
retVal
)
)
{
Cu
.
reportError
(
Calling
method
{
name
}
(
)
returned
an
unexpected
value
:
{
retVal
}
.
Returning
null
.
)
;
return
null
;
}
return
retVal
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
There
was
an
error
while
calling
{
name
}
(
)
:
e
.
message
)
;
}
return
fallback
(
)
;
}
#
createSandbox
(
videoWrapperScriptPath
video
)
{
const
addonPolicy
=
WebExtensionPolicy
.
getByID
(
"
pictureinpicture
mozilla
.
org
"
)
;
let
wrapperScriptUrl
=
addonPolicy
.
getURL
(
videoWrapperScriptPath
)
;
let
originatingWin
=
video
.
ownerGlobal
;
let
originatingDoc
=
video
.
ownerDocument
;
let
sandbox
=
Cu
.
Sandbox
(
[
originatingDoc
.
nodePrincipal
]
{
sandboxName
:
"
Picture
-
in
-
Picture
video
wrapper
sandbox
"
sandboxPrototype
:
originatingWin
sameZoneAs
:
originatingWin
wantXrays
:
false
}
)
;
try
{
Services
.
scriptloader
.
loadSubScript
(
wrapperScriptUrl
sandbox
)
;
}
catch
(
e
)
{
Cu
.
nukeSandbox
(
sandbox
)
;
Cu
.
reportError
(
"
Error
loading
wrapper
script
for
Picture
-
in
-
Picture
"
+
e
)
;
return
null
;
}
this
.
#
siteWrapper
=
new
sandbox
.
PictureInPictureVideoWrapper
(
)
.
wrappedJSObject
;
return
sandbox
;
}
#
isBoolean
(
val
)
{
return
typeof
val
=
=
=
"
boolean
"
;
}
#
isNumber
(
val
)
{
return
typeof
val
=
=
=
"
number
"
;
}
destroy
(
)
{
if
(
this
.
#
sandbox
)
{
Cu
.
nukeSandbox
(
this
.
#
sandbox
)
;
}
}
updatePiPTextTracks
(
text
)
{
let
pipWindowTracksContainer
=
this
.
#
PictureInPictureChild
.
document
.
getElementById
(
"
texttracks
"
)
;
pipWindowTracksContainer
.
textContent
=
text
;
}
/
*
Video
methods
to
be
used
for
video
controls
from
the
PiP
window
.
*
/
play
(
video
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
play
"
args
:
[
video
]
fallback
:
(
)
=
>
video
.
play
(
)
validateRetVal
:
retVal
=
>
retVal
=
=
null
}
)
;
}
pause
(
video
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
pause
"
args
:
[
video
]
fallback
:
(
)
=
>
video
.
pause
(
)
validateRetVal
:
retVal
=
>
retVal
=
=
null
}
)
;
}
getPaused
(
video
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
getPaused
"
args
:
[
video
]
fallback
:
(
)
=
>
video
.
paused
validateRetVal
:
retVal
=
>
this
.
#
isBoolean
(
retVal
)
}
)
;
}
getEnded
(
video
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
getEnded
"
args
:
[
video
]
fallback
:
(
)
=
>
video
.
ended
validateRetVal
:
retVal
=
>
this
.
#
isBoolean
(
retVal
)
}
)
;
}
getDuration
(
video
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
getDuration
"
args
:
[
video
]
fallback
:
(
)
=
>
video
.
duration
validateRetVal
:
retVal
=
>
this
.
#
isNumber
(
retVal
)
}
)
;
}
getCurrentTime
(
video
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
getCurrentTime
"
args
:
[
video
]
fallback
:
(
)
=
>
video
.
currentTime
validateRetVal
:
retVal
=
>
this
.
#
isNumber
(
retVal
)
}
)
;
}
setCurrentTime
(
video
position
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
setCurrentTime
"
args
:
[
video
position
]
fallback
:
(
)
=
>
{
video
.
currentTime
=
position
;
}
validateRetVal
:
retVal
=
>
retVal
=
=
null
}
)
;
}
getVolume
(
video
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
getVolume
"
args
:
[
video
]
fallback
:
(
)
=
>
video
.
volume
validateRetVal
:
retVal
=
>
this
.
#
isNumber
(
retVal
)
}
)
;
}
setVolume
(
video
volume
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
setVolume
"
args
:
[
video
volume
]
fallback
:
(
)
=
>
{
video
.
volume
=
volume
;
}
validateRetVal
:
retVal
=
>
retVal
=
=
null
}
)
;
}
setMuted
(
video
shouldMute
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
setMuted
"
args
:
[
video
shouldMute
]
fallback
:
(
)
=
>
{
video
.
muted
=
shouldMute
;
}
validateRetVal
:
retVal
=
>
retVal
=
=
null
}
)
;
}
setCaptionContainerObserver
(
video
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
setCaptionContainerObserver
"
args
:
[
video
text
=
>
{
this
.
updatePiPTextTracks
(
text
)
;
}
]
fallback
:
(
)
=
>
{
}
validateRetVal
:
retVal
=
>
retVal
=
=
null
}
)
;
}
shouldHideToggle
(
video
)
{
return
this
.
#
callWrapperMethod
(
{
name
:
"
shouldHideToggle
"
args
:
[
video
]
fallback
:
(
)
=
>
false
validateRetVal
:
retVal
=
>
this
.
#
isBoolean
(
retVal
)
}
)
;
}
}
