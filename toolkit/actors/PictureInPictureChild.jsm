"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
PictureInPictureChild
"
"
PictureInPictureToggleChild
"
]
;
const
{
ActorChild
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ActorChild
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
DeferredTask
"
"
resource
:
/
/
gre
/
modules
/
DeferredTask
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
InspectorUtils
"
]
)
;
const
TOGGLE_ENABLED_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
enabled
"
;
const
TOGGLE_TESTING_PREF
=
"
media
.
videocontrols
.
picture
-
in
-
picture
.
video
-
toggle
.
testing
"
;
const
MOUSEMOVE_PROCESSING_DELAY_MS
=
50
;
const
TOGGLE_HIDING_TIMEOUT_MS
=
2000
;
var
gWeakVideo
=
null
;
var
gWeakPlayerContent
=
null
;
var
gWeakIntersectingVideosForTesting
=
new
WeakSet
(
)
;
class
PictureInPictureToggleChild
extends
ActorChild
{
constructor
(
dispatcher
)
{
super
(
dispatcher
)
;
this
.
weakDocStates
=
new
WeakMap
(
)
;
this
.
toggleEnabled
=
Services
.
prefs
.
getBoolPref
(
TOGGLE_ENABLED_PREF
)
;
Services
.
prefs
.
addObserver
(
TOGGLE_ENABLED_PREF
this
)
;
this
.
toggleTesting
=
Services
.
prefs
.
getBoolPref
(
TOGGLE_TESTING_PREF
false
)
;
}
cleanup
(
)
{
this
.
removeMouseButtonListeners
(
)
;
Services
.
prefs
.
removeObserver
(
TOGGLE_ENABLED_PREF
this
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
"
nsPref
:
changed
"
&
&
data
=
=
TOGGLE_ENABLED_PREF
)
{
this
.
toggleEnabled
=
Services
.
prefs
.
getBoolPref
(
TOGGLE_ENABLED_PREF
)
;
if
(
this
.
toggleEnabled
)
{
this
.
content
.
requestIdleCallback
(
(
)
=
>
{
let
videos
=
this
.
content
.
document
.
querySelectorAll
(
"
video
"
)
;
for
(
let
video
of
videos
)
{
this
.
registerVideo
(
video
)
;
}
}
)
;
}
}
}
get
docState
(
)
{
let
state
=
this
.
weakDocStates
.
get
(
this
.
content
.
document
)
;
if
(
!
state
)
{
state
=
{
intersectionObserver
:
null
weakVisibleVideos
:
new
WeakSet
(
)
visibleVideosCount
:
0
mousemoveDeferredTask
:
null
weakOverVideo
:
null
isClickingToggle
:
false
clickedElement
:
null
hideToggleDeferredTask
:
null
}
;
this
.
weakDocStates
.
set
(
this
.
content
.
document
state
)
;
}
return
state
;
}
handleEvent
(
event
)
{
if
(
!
event
.
isTrusted
)
{
return
;
}
switch
(
event
.
type
)
{
case
"
canplay
"
:
{
if
(
this
.
toggleEnabled
&
&
event
.
target
instanceof
this
.
content
.
HTMLVideoElement
&
&
!
event
.
target
.
controls
&
&
event
.
target
.
ownerDocument
=
=
this
.
content
.
document
)
{
this
.
registerVideo
(
event
.
target
)
;
}
break
;
}
case
"
mousedown
"
:
case
"
pointerup
"
:
case
"
mouseup
"
:
case
"
click
"
:
{
this
.
onMouseButtonEvent
(
event
)
;
break
;
}
case
"
pointerdown
"
:
{
this
.
onPointerDown
(
event
)
;
break
;
}
case
"
mousemove
"
:
{
this
.
onMouseMove
(
event
)
;
break
;
}
}
}
registerVideo
(
video
)
{
let
state
=
this
.
docState
;
if
(
!
state
.
intersectionObserver
)
{
let
fn
=
this
.
onIntersection
.
bind
(
this
)
;
state
.
intersectionObserver
=
new
this
.
content
.
IntersectionObserver
(
fn
{
threshold
:
[
0
.
0
0
.
5
]
}
)
;
}
state
.
intersectionObserver
.
observe
(
video
)
;
}
worthTracking
(
intersectionEntry
)
{
return
intersectionEntry
.
isIntersecting
;
}
onIntersection
(
entries
)
{
let
state
=
this
.
docState
;
let
oldVisibleVideosCount
=
state
.
visibleVideosCount
;
for
(
let
entry
of
entries
)
{
let
video
=
entry
.
target
;
if
(
this
.
worthTracking
(
entry
)
)
{
if
(
!
state
.
weakVisibleVideos
.
has
(
video
)
)
{
state
.
weakVisibleVideos
.
add
(
video
)
;
state
.
visibleVideosCount
+
+
;
if
(
this
.
toggleTesting
)
{
gWeakIntersectingVideosForTesting
.
add
(
video
)
;
}
}
}
else
if
(
state
.
weakVisibleVideos
.
has
(
video
)
)
{
state
.
weakVisibleVideos
.
delete
(
video
)
;
state
.
visibleVideosCount
-
-
;
if
(
this
.
toggleTesting
)
{
gWeakIntersectingVideosForTesting
.
delete
(
video
)
;
}
}
}
if
(
!
oldVisibleVideosCount
&
&
state
.
visibleVideosCount
)
{
if
(
this
.
toggleTesting
)
{
this
.
beginTrackingMouseOverVideos
(
)
;
}
else
{
this
.
content
.
requestIdleCallback
(
(
)
=
>
{
this
.
beginTrackingMouseOverVideos
(
)
;
}
)
;
}
}
else
if
(
oldVisibleVideosCount
&
&
!
state
.
visibleVideosCount
)
{
if
(
this
.
toggleTesting
)
{
this
.
stopTrackingMouseOverVideos
(
)
;
}
else
{
this
.
content
.
requestIdleCallback
(
(
)
=
>
{
this
.
stopTrackingMouseOverVideos
(
)
;
}
)
;
}
}
}
addMouseButtonListeners
(
)
{
this
.
content
.
windowRoot
.
addEventListener
(
"
pointerdown
"
this
{
capture
:
true
}
)
;
this
.
content
.
windowRoot
.
addEventListener
(
"
mousedown
"
this
{
capture
:
true
}
)
;
this
.
content
.
windowRoot
.
addEventListener
(
"
mouseup
"
this
{
capture
:
true
}
)
;
this
.
content
.
windowRoot
.
addEventListener
(
"
pointerup
"
this
{
capture
:
true
}
)
;
this
.
content
.
windowRoot
.
addEventListener
(
"
click
"
this
{
capture
:
true
}
)
;
}
removeMouseButtonListeners
(
)
{
this
.
content
.
windowRoot
.
removeEventListener
(
"
pointerdown
"
this
{
capture
:
true
}
)
;
this
.
content
.
windowRoot
.
removeEventListener
(
"
mousedown
"
this
{
capture
:
true
}
)
;
this
.
content
.
windowRoot
.
removeEventListener
(
"
mouseup
"
this
{
capture
:
true
}
)
;
this
.
content
.
windowRoot
.
removeEventListener
(
"
pointerup
"
this
{
capture
:
true
}
)
;
this
.
content
.
windowRoot
.
removeEventListener
(
"
click
"
this
{
capture
:
true
}
)
;
}
beginTrackingMouseOverVideos
(
)
{
let
state
=
this
.
docState
;
if
(
!
state
.
mousemoveDeferredTask
)
{
state
.
mousemoveDeferredTask
=
new
DeferredTask
(
(
)
=
>
{
this
.
checkLastMouseMove
(
)
;
}
MOUSEMOVE_PROCESSING_DELAY_MS
)
;
}
this
.
content
.
document
.
addEventListener
(
"
mousemove
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
this
.
addMouseButtonListeners
(
)
;
}
stopTrackingMouseOverVideos
(
)
{
let
state
=
this
.
docState
;
state
.
mousemoveDeferredTask
.
disarm
(
)
;
this
.
content
.
document
.
removeEventListener
(
"
mousemove
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
this
.
removeMouseButtonListeners
(
)
;
let
oldOverVideo
=
state
.
weakOverVideo
&
&
state
.
weakOverVideo
.
get
(
)
;
if
(
oldOverVideo
)
{
this
.
onMouseLeaveVideo
(
oldOverVideo
)
;
}
}
onPointerDown
(
event
)
{
if
(
event
.
button
!
=
0
)
{
return
;
}
let
state
=
this
.
docState
;
let
video
=
state
.
weakOverVideo
&
&
state
.
weakOverVideo
.
get
(
)
;
if
(
!
video
)
{
return
;
}
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
if
(
!
shadowRoot
)
{
return
;
}
let
{
clientX
clientY
}
=
event
;
let
winUtils
=
this
.
content
.
windowUtils
;
let
elements
=
winUtils
.
nodesFromRect
(
clientX
clientY
1
1
1
1
true
false
true
)
;
if
(
!
Array
.
from
(
elements
)
.
includes
(
video
)
)
{
return
;
}
let
toggle
=
shadowRoot
.
getElementById
(
"
pictureInPictureToggleButton
"
)
;
if
(
this
.
isMouseOverToggle
(
toggle
event
)
)
{
state
.
isClickingToggle
=
true
;
state
.
clickedElement
=
Cu
.
getWeakReference
(
event
.
originalTarget
)
;
event
.
stopImmediatePropagation
(
)
;
Services
.
telemetry
.
keyedScalarAdd
(
"
pictureinpicture
.
opened_method
"
"
toggle
"
1
)
;
let
pipEvent
=
new
this
.
content
.
CustomEvent
(
"
MozTogglePictureInPicture
"
{
bubbles
:
true
}
)
;
video
.
dispatchEvent
(
pipEvent
)
;
this
.
onMouseLeaveVideo
(
video
)
;
}
}
onMouseButtonEvent
(
event
)
{
if
(
event
.
button
!
=
0
)
{
return
;
}
let
state
=
this
.
docState
;
if
(
state
.
isClickingToggle
)
{
event
.
stopImmediatePropagation
(
)
;
let
isMouseUpOnOtherElement
=
event
.
type
=
=
"
mouseup
"
&
&
(
!
state
.
clickedElement
|
|
state
.
clickedElement
.
get
(
)
!
=
event
.
originalTarget
)
;
if
(
isMouseUpOnOtherElement
|
|
event
.
type
=
=
"
click
"
)
{
state
.
isClickingToggle
=
false
;
state
.
clickedElement
=
null
;
}
}
}
onMouseMove
(
event
)
{
let
state
=
this
.
docState
;
if
(
state
.
hideToggleDeferredTask
)
{
state
.
hideToggleDeferredTask
.
disarm
(
)
;
state
.
hideToggleDeferredTask
.
arm
(
)
;
}
state
.
lastMouseMoveEvent
=
event
;
state
.
mousemoveDeferredTask
.
arm
(
)
;
}
checkLastMouseMove
(
)
{
let
state
=
this
.
docState
;
let
event
=
state
.
lastMouseMoveEvent
;
let
{
clientX
clientY
}
=
event
;
let
winUtils
=
this
.
content
.
windowUtils
;
let
elements
=
winUtils
.
nodesFromRect
(
clientX
clientY
1
1
1
1
true
false
false
)
;
for
(
let
element
of
elements
)
{
if
(
state
.
weakVisibleVideos
.
has
(
element
)
&
&
!
element
.
isCloningElementVisually
)
{
this
.
onMouseOverVideo
(
element
event
)
;
return
;
}
}
let
oldOverVideo
=
state
.
weakOverVideo
&
&
state
.
weakOverVideo
.
get
(
)
;
if
(
oldOverVideo
)
{
this
.
onMouseLeaveVideo
(
oldOverVideo
)
;
}
}
onMouseOverVideo
(
video
event
)
{
let
state
=
this
.
docState
;
let
oldOverVideo
=
state
.
weakOverVideo
&
&
state
.
weakOverVideo
.
get
(
)
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
if
(
!
shadowRoot
)
{
if
(
oldOverVideo
)
{
this
.
onMouseLeaveVideo
(
oldOverVideo
)
;
}
return
;
}
let
toggle
=
shadowRoot
.
getElementById
(
"
pictureInPictureToggleButton
"
)
;
let
controlsOverlay
=
shadowRoot
.
querySelector
(
"
.
controlsOverlay
"
)
;
controlsOverlay
.
removeAttribute
(
"
hidetoggle
"
)
;
if
(
!
state
.
hideToggleDeferredTask
&
&
!
this
.
toggleTesting
)
{
state
.
hideToggleDeferredTask
=
new
DeferredTask
(
(
)
=
>
{
controlsOverlay
.
setAttribute
(
"
hidetoggle
"
true
)
;
}
TOGGLE_HIDING_TIMEOUT_MS
)
;
}
if
(
oldOverVideo
)
{
if
(
oldOverVideo
=
=
video
)
{
this
.
checkHoverToggle
(
toggle
event
)
;
return
;
}
this
.
onMouseLeaveVideo
(
oldOverVideo
)
;
}
state
.
weakOverVideo
=
Cu
.
getWeakReference
(
video
)
;
InspectorUtils
.
addPseudoClassLock
(
controlsOverlay
"
:
hover
"
)
;
this
.
checkHoverToggle
(
toggle
event
)
;
}
checkHoverToggle
(
toggle
event
)
{
if
(
this
.
isMouseOverToggle
(
toggle
event
)
)
{
InspectorUtils
.
addPseudoClassLock
(
toggle
"
:
hover
"
)
;
}
else
{
InspectorUtils
.
removePseudoClassLock
(
toggle
"
:
hover
"
)
;
}
}
onMouseLeaveVideo
(
video
)
{
let
state
=
this
.
docState
;
let
shadowRoot
=
video
.
openOrClosedShadowRoot
;
if
(
shadowRoot
)
{
let
controlsOverlay
=
shadowRoot
.
querySelector
(
"
.
controlsOverlay
"
)
;
let
toggle
=
shadowRoot
.
getElementById
(
"
pictureInPictureToggleButton
"
)
;
InspectorUtils
.
removePseudoClassLock
(
controlsOverlay
"
:
hover
"
)
;
InspectorUtils
.
removePseudoClassLock
(
toggle
"
:
hover
"
)
;
}
state
.
weakOverVideo
=
null
;
state
.
hideToggleDeferredTask
.
disarm
(
)
;
state
.
hideToggleDeferredTask
=
null
;
}
isMouseOverToggle
(
toggle
event
)
{
let
toggleRect
=
toggle
.
ownerGlobal
.
windowUtils
.
getBoundsWithoutFlushing
(
toggle
)
;
let
{
clientX
clientY
}
=
event
;
return
(
clientX
>
=
toggleRect
.
left
&
&
clientX
<
=
toggleRect
.
right
&
&
clientY
>
=
toggleRect
.
top
&
&
clientY
<
=
toggleRect
.
bottom
)
;
}
static
isTracking
(
video
)
{
return
gWeakIntersectingVideosForTesting
.
has
(
video
)
;
}
}
class
PictureInPictureChild
extends
ActorChild
{
static
videoIsPlaying
(
video
)
{
return
!
!
(
video
.
currentTime
>
0
&
&
!
video
.
paused
&
&
!
video
.
ended
&
&
video
.
readyState
>
2
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
MozTogglePictureInPicture
"
:
{
if
(
event
.
isTrusted
)
{
this
.
togglePictureInPicture
(
event
.
target
)
;
}
break
;
}
case
"
pagehide
"
:
{
this
.
closePictureInPicture
(
{
reason
:
"
pagehide
"
}
)
;
break
;
}
case
"
play
"
:
{
this
.
mm
.
sendAsyncMessage
(
"
PictureInPicture
:
Playing
"
)
;
break
;
}
case
"
pause
"
:
{
this
.
mm
.
sendAsyncMessage
(
"
PictureInPicture
:
Paused
"
)
;
break
;
}
}
}
get
weakVideo
(
)
{
if
(
gWeakVideo
)
{
return
gWeakVideo
.
get
(
)
;
}
return
null
;
}
get
weakPlayerContent
(
)
{
if
(
gWeakPlayerContent
)
{
return
gWeakPlayerContent
.
get
(
)
;
}
return
null
;
}
async
togglePictureInPicture
(
video
)
{
if
(
this
.
inPictureInPicture
(
video
)
)
{
await
this
.
closePictureInPicture
(
{
reason
:
"
contextmenu
"
}
)
;
}
else
{
if
(
this
.
weakVideo
)
{
await
this
.
closePictureInPicture
(
{
reason
:
"
new
-
pip
"
}
)
;
}
gWeakVideo
=
Cu
.
getWeakReference
(
video
)
;
this
.
mm
.
sendAsyncMessage
(
"
PictureInPicture
:
Request
"
{
playing
:
PictureInPictureChild
.
videoIsPlaying
(
video
)
videoHeight
:
video
.
videoHeight
videoWidth
:
video
.
videoWidth
}
)
;
}
}
inPictureInPicture
(
video
)
{
return
this
.
weakVideo
=
=
=
video
;
}
async
closePictureInPicture
(
{
reason
}
)
{
if
(
this
.
weakVideo
)
{
this
.
untrackOriginatingVideo
(
this
.
weakVideo
)
;
}
this
.
mm
.
sendAsyncMessage
(
"
PictureInPicture
:
Close
"
{
browingContextId
:
this
.
docShell
.
browsingContext
.
id
reason
}
)
;
if
(
this
.
weakPlayerContent
)
{
if
(
!
this
.
weakPlayerContent
.
closed
)
{
await
new
Promise
(
resolve
=
>
{
this
.
weakPlayerContent
.
addEventListener
(
"
unload
"
resolve
{
once
:
true
}
)
;
}
)
;
}
gWeakPlayerContent
=
null
;
}
}
receiveMessage
(
message
)
{
switch
(
message
.
name
)
{
case
"
PictureInPicture
:
SetupPlayer
"
:
{
this
.
setupPlayer
(
)
;
break
;
}
case
"
PictureInPicture
:
Play
"
:
{
this
.
play
(
)
;
break
;
}
case
"
PictureInPicture
:
Pause
"
:
{
this
.
pause
(
)
;
break
;
}
}
}
trackOriginatingVideo
(
originatingVideo
)
{
let
originatingWindow
=
originatingVideo
.
ownerGlobal
;
if
(
originatingWindow
)
{
originatingWindow
.
addEventListener
(
"
pagehide
"
this
)
;
originatingVideo
.
addEventListener
(
"
play
"
this
)
;
originatingVideo
.
addEventListener
(
"
pause
"
this
)
;
}
}
untrackOriginatingVideo
(
originatingVideo
)
{
let
originatingWindow
=
originatingVideo
.
ownerGlobal
;
if
(
originatingWindow
)
{
originatingWindow
.
removeEventListener
(
"
pagehide
"
this
)
;
originatingVideo
.
removeEventListener
(
"
play
"
this
)
;
originatingVideo
.
removeEventListener
(
"
pause
"
this
)
;
}
}
async
setupPlayer
(
)
{
let
originatingVideo
=
this
.
weakVideo
;
if
(
!
originatingVideo
)
{
await
this
.
closePictureInPicture
(
{
reason
:
"
setup
-
failure
"
}
)
;
return
;
}
let
webProgress
=
this
.
mm
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
if
(
webProgress
.
isLoadingDocument
)
{
await
new
Promise
(
resolve
=
>
{
this
.
mm
.
addEventListener
(
"
load
"
resolve
{
once
:
true
mozSystemGroup
:
true
capture
:
true
}
)
;
}
)
;
}
let
doc
=
this
.
content
.
document
;
let
playerVideo
=
originatingVideo
.
cloneNode
(
)
;
playerVideo
.
pause
(
)
;
playerVideo
.
removeAttribute
(
"
controls
"
)
;
playerVideo
.
muted
=
true
;
playerVideo
.
style
.
height
=
"
100vh
"
;
playerVideo
.
style
.
width
=
"
100vw
"
;
playerVideo
.
style
.
margin
=
"
0
"
;
doc
.
body
.
style
.
overflow
=
"
hidden
"
;
doc
.
body
.
style
.
margin
=
"
0
"
;
doc
.
body
.
appendChild
(
playerVideo
)
;
originatingVideo
.
cloneElementVisually
(
playerVideo
)
;
this
.
trackOriginatingVideo
(
originatingVideo
)
;
this
.
content
.
addEventListener
(
"
unload
"
(
)
=
>
{
if
(
this
.
weakVideo
)
{
this
.
weakVideo
.
stopCloningElementVisually
(
)
;
}
gWeakVideo
=
null
;
}
{
once
:
true
}
)
;
gWeakPlayerContent
=
Cu
.
getWeakReference
(
this
.
content
)
;
}
play
(
)
{
let
video
=
this
.
weakVideo
;
if
(
video
)
{
video
.
play
(
)
;
}
}
pause
(
)
{
let
video
=
this
.
weakVideo
;
if
(
video
)
{
video
.
pause
(
)
;
}
}
}
