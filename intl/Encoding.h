#
ifndef
mozilla_Encoding_h
#
define
mozilla_Encoding_h
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
class
Encoding
;
class
Decoder
;
class
Encoder
;
}
;
#
define
ENCODING_RS_ENCODING
mozilla
:
:
Encoding
#
define
ENCODING_RS_NOT_NULL_CONST_ENCODING_PTR
\
mozilla
:
:
NotNull
<
const
mozilla
:
:
Encoding
*
>
#
define
ENCODING_RS_ENCODER
mozilla
:
:
Encoder
#
define
ENCODING_RS_DECODER
mozilla
:
:
Decoder
#
include
"
encoding_rs
.
h
"
extern
"
C
"
{
nsresult
mozilla_encoding_decode_to_nsstring
(
mozilla
:
:
Encoding
const
*
*
encoding
uint8_t
const
*
src
size_t
src_len
nsAString
*
dst
)
;
nsresult
mozilla_encoding_decode_to_nsstring_with_bom_removal
(
mozilla
:
:
Encoding
const
*
encoding
uint8_t
const
*
src
size_t
src_len
nsAString
*
dst
)
;
nsresult
mozilla_encoding_decode_to_nsstring_without_bom_handling
(
mozilla
:
:
Encoding
const
*
encoding
uint8_t
const
*
src
size_t
src_len
nsAString
*
dst
)
;
nsresult
mozilla_encoding_decode_to_nsstring_without_bom_handling_and_without_replacement
(
mozilla
:
:
Encoding
const
*
encoding
uint8_t
const
*
src
size_t
src_len
nsAString
*
dst
)
;
nsresult
mozilla_encoding_encode_from_utf16
(
mozilla
:
:
Encoding
const
*
*
encoding
char16_t
const
*
src
size_t
src_len
nsACString
*
dst
)
;
nsresult
mozilla_encoding_decode_to_nscstring
(
mozilla
:
:
Encoding
const
*
*
encoding
nsACString
const
*
src
nsACString
*
dst
)
;
nsresult
mozilla_encoding_decode_to_nscstring_with_bom_removal
(
mozilla
:
:
Encoding
const
*
encoding
nsACString
const
*
src
nsACString
*
dst
)
;
nsresult
mozilla_encoding_decode_to_nscstring_without_bom_handling
(
mozilla
:
:
Encoding
const
*
encoding
nsACString
const
*
src
nsACString
*
dst
)
;
nsresult
mozilla_encoding_decode_from_slice_to_nscstring_without_bom_handling
(
mozilla
:
:
Encoding
const
*
encoding
uint8_t
const
*
src
size_t
src_len
nsACString
*
dst
size_t
already_validated
)
;
nsresult
mozilla_encoding_decode_to_nscstring_without_bom_handling_and_without_replacement
(
mozilla
:
:
Encoding
const
*
encoding
nsACString
const
*
src
nsACString
*
dst
)
;
nsresult
mozilla_encoding_encode_from_nscstring
(
mozilla
:
:
Encoding
const
*
*
encoding
nsACString
const
*
src
nsACString
*
dst
)
;
}
namespace
mozilla
{
const
uint32_t
kInputEmpty
=
INPUT_EMPTY
;
const
uint32_t
kOutputFull
=
OUTPUT_FULL
;
class
Encoding
final
{
public
:
static
inline
const
Encoding
*
ForLabel
(
Span
<
const
char
>
aLabel
)
{
return
encoding_for_label
(
reinterpret_cast
<
const
uint8_t
*
>
(
aLabel
.
Elements
(
)
)
aLabel
.
Length
(
)
)
;
}
static
inline
const
Encoding
*
ForLabel
(
const
nsAString
&
aLabel
)
{
return
Encoding
:
:
ForLabel
(
NS_ConvertUTF16toUTF8
(
aLabel
)
)
;
}
static
inline
const
Encoding
*
ForLabelNoReplacement
(
Span
<
const
char
>
aLabel
)
{
return
encoding_for_label_no_replacement
(
reinterpret_cast
<
const
uint8_t
*
>
(
aLabel
.
Elements
(
)
)
aLabel
.
Length
(
)
)
;
}
static
inline
const
Encoding
*
ForLabelNoReplacement
(
const
nsAString
&
aLabel
)
{
return
Encoding
:
:
ForLabelNoReplacement
(
NS_ConvertUTF16toUTF8
(
aLabel
)
)
;
}
static
inline
Tuple
<
const
Encoding
*
size_t
>
ForBOM
(
Span
<
const
uint8_t
>
aBuffer
)
{
size_t
len
=
aBuffer
.
Length
(
)
;
const
Encoding
*
encoding
=
encoding_for_bom
(
aBuffer
.
Elements
(
)
&
len
)
;
return
MakeTuple
(
encoding
len
)
;
}
inline
void
Name
(
nsACString
&
aName
)
const
{
aName
.
SetLength
(
ENCODING_NAME_MAX_LENGTH
)
;
size_t
length
=
encoding_name
(
this
reinterpret_cast
<
uint8_t
*
>
(
aName
.
BeginWriting
(
)
)
)
;
aName
.
SetLength
(
length
)
;
}
inline
bool
CanEncodeEverything
(
)
const
{
return
encoding_can_encode_everything
(
this
)
;
}
inline
bool
IsAsciiCompatible
(
)
const
{
return
encoding_is_ascii_compatible
(
this
)
;
}
inline
bool
IsJapaneseLegacy
(
)
const
{
return
this
=
=
SHIFT_JIS_ENCODING
|
|
this
=
=
EUC_JP_ENCODING
|
|
this
=
=
ISO_2022_JP_ENCODING
;
}
inline
NotNull
<
const
mozilla
:
:
Encoding
*
>
OutputEncoding
(
)
const
{
return
WrapNotNull
(
encoding_output_encoding
(
this
)
)
;
}
inline
Tuple
<
nsresult
NotNull
<
const
mozilla
:
:
Encoding
*
>
>
Decode
(
const
nsACString
&
aBytes
nsACString
&
aOut
)
const
{
const
Encoding
*
encoding
=
this
;
const
nsACString
*
bytes
=
&
aBytes
;
nsACString
*
out
=
&
aOut
;
nsresult
rv
;
if
(
bytes
=
=
out
)
{
nsAutoCString
temp
(
aBytes
)
;
rv
=
mozilla_encoding_decode_to_nscstring
(
&
encoding
&
temp
out
)
;
}
else
{
rv
=
mozilla_encoding_decode_to_nscstring
(
&
encoding
bytes
out
)
;
}
return
MakeTuple
(
rv
WrapNotNull
(
encoding
)
)
;
}
inline
Tuple
<
nsresult
NotNull
<
const
mozilla
:
:
Encoding
*
>
>
Decode
(
Span
<
const
uint8_t
>
aBytes
nsAString
&
aOut
)
const
{
const
Encoding
*
encoding
=
this
;
nsresult
rv
=
mozilla_encoding_decode_to_nsstring
(
&
encoding
aBytes
.
Elements
(
)
aBytes
.
Length
(
)
&
aOut
)
;
return
MakeTuple
(
rv
WrapNotNull
(
encoding
)
)
;
}
inline
nsresult
DecodeWithBOMRemoval
(
const
nsACString
&
aBytes
nsACString
&
aOut
)
const
{
const
nsACString
*
bytes
=
&
aBytes
;
nsACString
*
out
=
&
aOut
;
if
(
bytes
=
=
out
)
{
nsAutoCString
temp
(
aBytes
)
;
return
mozilla_encoding_decode_to_nscstring_with_bom_removal
(
this
&
temp
out
)
;
}
return
mozilla_encoding_decode_to_nscstring_with_bom_removal
(
this
bytes
out
)
;
}
inline
nsresult
DecodeWithBOMRemoval
(
Span
<
const
uint8_t
>
aBytes
nsAString
&
aOut
)
const
{
return
mozilla_encoding_decode_to_nsstring_with_bom_removal
(
this
aBytes
.
Elements
(
)
aBytes
.
Length
(
)
&
aOut
)
;
}
inline
nsresult
DecodeWithoutBOMHandling
(
const
nsACString
&
aBytes
nsACString
&
aOut
)
const
{
const
nsACString
*
bytes
=
&
aBytes
;
nsACString
*
out
=
&
aOut
;
if
(
bytes
=
=
out
)
{
nsAutoCString
temp
(
aBytes
)
;
return
mozilla_encoding_decode_to_nscstring_without_bom_handling
(
this
&
temp
out
)
;
}
return
mozilla_encoding_decode_to_nscstring_without_bom_handling
(
this
bytes
out
)
;
}
inline
nsresult
DecodeWithoutBOMHandling
(
Span
<
const
uint8_t
>
aBytes
nsAString
&
aOut
)
const
{
return
mozilla_encoding_decode_to_nsstring_without_bom_handling
(
this
aBytes
.
Elements
(
)
aBytes
.
Length
(
)
&
aOut
)
;
}
inline
nsresult
DecodeWithoutBOMHandlingAndWithoutReplacement
(
const
nsACString
&
aBytes
nsACString
&
aOut
)
const
{
const
nsACString
*
bytes
=
&
aBytes
;
nsACString
*
out
=
&
aOut
;
if
(
bytes
=
=
out
)
{
nsAutoCString
temp
(
aBytes
)
;
return
mozilla_encoding_decode_to_nscstring_without_bom_handling_and_without_replacement
(
this
&
temp
out
)
;
}
return
mozilla_encoding_decode_to_nscstring_without_bom_handling_and_without_replacement
(
this
bytes
out
)
;
}
inline
nsresult
DecodeWithoutBOMHandling
(
Span
<
const
uint8_t
>
aBytes
nsACString
&
aOut
size_t
aAlreadyValidated
)
const
{
return
mozilla_encoding_decode_from_slice_to_nscstring_without_bom_handling
(
this
aBytes
.
Elements
(
)
aBytes
.
Length
(
)
&
aOut
aAlreadyValidated
)
;
}
inline
nsresult
DecodeWithoutBOMHandlingAndWithoutReplacement
(
Span
<
const
uint8_t
>
aBytes
nsAString
&
aOut
)
const
{
return
mozilla_encoding_decode_to_nsstring_without_bom_handling_and_without_replacement
(
this
aBytes
.
Elements
(
)
aBytes
.
Length
(
)
&
aOut
)
;
}
inline
Tuple
<
nsresult
NotNull
<
const
mozilla
:
:
Encoding
*
>
>
Encode
(
const
nsACString
&
aString
nsACString
&
aOut
)
const
{
const
Encoding
*
encoding
=
this
;
const
nsACString
*
string
=
&
aString
;
nsACString
*
out
=
&
aOut
;
nsresult
rv
;
if
(
string
=
=
out
)
{
nsAutoCString
temp
(
aString
)
;
rv
=
mozilla_encoding_encode_from_nscstring
(
&
encoding
&
temp
out
)
;
}
else
{
rv
=
mozilla_encoding_encode_from_nscstring
(
&
encoding
string
out
)
;
}
return
MakeTuple
(
rv
WrapNotNull
(
encoding
)
)
;
}
inline
Tuple
<
nsresult
NotNull
<
const
mozilla
:
:
Encoding
*
>
>
Encode
(
Span
<
const
char16_t
>
aString
nsACString
&
aOut
)
const
{
const
Encoding
*
encoding
=
this
;
nsresult
rv
=
mozilla_encoding_encode_from_utf16
(
&
encoding
aString
.
Elements
(
)
aString
.
Length
(
)
&
aOut
)
;
return
MakeTuple
(
rv
WrapNotNull
(
encoding
)
)
;
}
inline
UniquePtr
<
Decoder
>
NewDecoder
(
)
const
{
UniquePtr
<
Decoder
>
decoder
(
encoding_new_decoder
(
this
)
)
;
return
decoder
;
}
inline
void
NewDecoderInto
(
Decoder
&
aDecoder
)
const
{
encoding_new_decoder_into
(
this
&
aDecoder
)
;
}
inline
UniquePtr
<
Decoder
>
NewDecoderWithBOMRemoval
(
)
const
{
UniquePtr
<
Decoder
>
decoder
(
encoding_new_decoder_with_bom_removal
(
this
)
)
;
return
decoder
;
}
inline
void
NewDecoderWithBOMRemovalInto
(
Decoder
&
aDecoder
)
const
{
encoding_new_decoder_with_bom_removal_into
(
this
&
aDecoder
)
;
}
inline
UniquePtr
<
Decoder
>
NewDecoderWithoutBOMHandling
(
)
const
{
UniquePtr
<
Decoder
>
decoder
(
encoding_new_decoder_without_bom_handling
(
this
)
)
;
return
decoder
;
}
inline
void
NewDecoderWithoutBOMHandlingInto
(
Decoder
&
aDecoder
)
const
{
encoding_new_decoder_without_bom_handling_into
(
this
&
aDecoder
)
;
}
inline
UniquePtr
<
Encoder
>
NewEncoder
(
)
const
{
UniquePtr
<
Encoder
>
encoder
(
encoding_new_encoder
(
this
)
)
;
return
encoder
;
}
inline
void
NewEncoderInto
(
Encoder
&
aEncoder
)
const
{
encoding_new_encoder_into
(
this
&
aEncoder
)
;
}
static
inline
size_t
UTF8ValidUpTo
(
Span
<
const
uint8_t
>
aBuffer
)
{
return
encoding_utf8_valid_up_to
(
aBuffer
.
Elements
(
)
aBuffer
.
Length
(
)
)
;
}
static
inline
size_t
ASCIIValidUpTo
(
Span
<
const
uint8_t
>
aBuffer
)
{
return
encoding_ascii_valid_up_to
(
aBuffer
.
Elements
(
)
aBuffer
.
Length
(
)
)
;
}
static
inline
size_t
ISO2022JPASCIIValidUpTo
(
Span
<
const
uint8_t
>
aBuffer
)
{
return
encoding_iso_2022_jp_ascii_valid_up_to
(
aBuffer
.
Elements
(
)
aBuffer
.
Length
(
)
)
;
}
private
:
Encoding
(
)
=
delete
;
Encoding
(
const
Encoding
&
)
=
delete
;
Encoding
&
operator
=
(
const
Encoding
&
)
=
delete
;
~
Encoding
(
)
=
delete
;
}
;
class
Decoder
final
{
public
:
~
Decoder
(
)
{
}
static
void
operator
delete
(
void
*
aDecoder
)
{
decoder_free
(
reinterpret_cast
<
Decoder
*
>
(
aDecoder
)
)
;
}
inline
NotNull
<
const
mozilla
:
:
Encoding
*
>
Encoding
(
)
const
{
return
WrapNotNull
(
decoder_encoding
(
this
)
)
;
}
inline
CheckedInt
<
size_t
>
MaxUTF8BufferLength
(
size_t
aByteLength
)
const
{
CheckedInt
<
size_t
>
max
(
decoder_max_utf8_buffer_length
(
this
aByteLength
)
)
;
if
(
max
.
value
(
)
=
=
MaxValue
<
size_t
>
:
:
value
)
{
max
+
+
;
MOZ_ASSERT
(
!
max
.
isValid
(
)
)
;
}
return
max
;
}
inline
CheckedInt
<
size_t
>
MaxUTF8BufferLengthWithoutReplacement
(
size_t
aByteLength
)
const
{
CheckedInt
<
size_t
>
max
(
decoder_max_utf8_buffer_length_without_replacement
(
this
aByteLength
)
)
;
if
(
max
.
value
(
)
=
=
MaxValue
<
size_t
>
:
:
value
)
{
max
+
+
;
MOZ_ASSERT
(
!
max
.
isValid
(
)
)
;
}
return
max
;
}
inline
Tuple
<
uint32_t
size_t
size_t
bool
>
DecodeToUTF8
(
Span
<
const
uint8_t
>
aSrc
Span
<
uint8_t
>
aDst
bool
aLast
)
{
size_t
srcRead
=
aSrc
.
Length
(
)
;
size_t
dstWritten
=
aDst
.
Length
(
)
;
bool
hadReplacements
;
uint32_t
result
=
decoder_decode_to_utf8
(
this
aSrc
.
Elements
(
)
&
srcRead
aDst
.
Elements
(
)
&
dstWritten
aLast
&
hadReplacements
)
;
return
MakeTuple
(
result
srcRead
dstWritten
hadReplacements
)
;
}
inline
Tuple
<
uint32_t
size_t
size_t
>
DecodeToUTF8WithoutReplacement
(
Span
<
const
uint8_t
>
aSrc
Span
<
uint8_t
>
aDst
bool
aLast
)
{
size_t
srcRead
=
aSrc
.
Length
(
)
;
size_t
dstWritten
=
aDst
.
Length
(
)
;
uint32_t
result
=
decoder_decode_to_utf8_without_replacement
(
this
aSrc
.
Elements
(
)
&
srcRead
aDst
.
Elements
(
)
&
dstWritten
aLast
)
;
return
MakeTuple
(
result
srcRead
dstWritten
)
;
}
inline
CheckedInt
<
size_t
>
MaxUTF16BufferLength
(
size_t
aU16Length
)
const
{
CheckedInt
<
size_t
>
max
(
decoder_max_utf16_buffer_length
(
this
aU16Length
)
)
;
if
(
max
.
value
(
)
=
=
MaxValue
<
size_t
>
:
:
value
)
{
max
+
+
;
MOZ_ASSERT
(
!
max
.
isValid
(
)
)
;
}
return
max
;
}
inline
Tuple
<
uint32_t
size_t
size_t
bool
>
DecodeToUTF16
(
Span
<
const
uint8_t
>
aSrc
Span
<
char16_t
>
aDst
bool
aLast
)
{
size_t
srcRead
=
aSrc
.
Length
(
)
;
size_t
dstWritten
=
aDst
.
Length
(
)
;
bool
hadReplacements
;
uint32_t
result
=
decoder_decode_to_utf16
(
this
aSrc
.
Elements
(
)
&
srcRead
aDst
.
Elements
(
)
&
dstWritten
aLast
&
hadReplacements
)
;
return
MakeTuple
(
result
srcRead
dstWritten
hadReplacements
)
;
}
inline
Tuple
<
uint32_t
size_t
size_t
>
DecodeToUTF16WithoutReplacement
(
Span
<
const
uint8_t
>
aSrc
Span
<
char16_t
>
aDst
bool
aLast
)
{
size_t
srcRead
=
aSrc
.
Length
(
)
;
size_t
dstWritten
=
aDst
.
Length
(
)
;
uint32_t
result
=
decoder_decode_to_utf16_without_replacement
(
this
aSrc
.
Elements
(
)
&
srcRead
aDst
.
Elements
(
)
&
dstWritten
aLast
)
;
return
MakeTuple
(
result
srcRead
dstWritten
)
;
}
private
:
Decoder
(
)
=
delete
;
Decoder
(
const
Decoder
&
)
=
delete
;
Decoder
&
operator
=
(
const
Decoder
&
)
=
delete
;
}
;
class
Encoder
final
{
public
:
~
Encoder
(
)
{
}
static
void
operator
delete
(
void
*
aEncoder
)
{
encoder_free
(
reinterpret_cast
<
Encoder
*
>
(
aEncoder
)
)
;
}
inline
NotNull
<
const
mozilla
:
:
Encoding
*
>
Encoding
(
)
const
{
return
WrapNotNull
(
encoder_encoding
(
this
)
)
;
}
inline
bool
HasPendingState
(
)
const
{
return
encoder_has_pending_state
(
this
)
;
}
inline
CheckedInt
<
size_t
>
MaxBufferLengthFromUTF8IfNoUnmappables
(
size_t
aByteLength
)
const
{
CheckedInt
<
size_t
>
max
(
encoder_max_buffer_length_from_utf8_if_no_unmappables
(
this
aByteLength
)
)
;
if
(
max
.
value
(
)
=
=
MaxValue
<
size_t
>
:
:
value
)
{
max
+
+
;
MOZ_ASSERT
(
!
max
.
isValid
(
)
)
;
}
return
max
;
}
inline
CheckedInt
<
size_t
>
MaxBufferLengthFromUTF8WithoutReplacement
(
size_t
aByteLength
)
const
{
CheckedInt
<
size_t
>
max
(
encoder_max_buffer_length_from_utf8_without_replacement
(
this
aByteLength
)
)
;
if
(
max
.
value
(
)
=
=
MaxValue
<
size_t
>
:
:
value
)
{
max
+
+
;
MOZ_ASSERT
(
!
max
.
isValid
(
)
)
;
}
return
max
;
}
inline
Tuple
<
uint32_t
size_t
size_t
bool
>
EncodeFromUTF8
(
Span
<
const
uint8_t
>
aSrc
Span
<
uint8_t
>
aDst
bool
aLast
)
{
size_t
srcRead
=
aSrc
.
Length
(
)
;
size_t
dstWritten
=
aDst
.
Length
(
)
;
bool
hadReplacements
;
uint32_t
result
=
encoder_encode_from_utf8
(
this
aSrc
.
Elements
(
)
&
srcRead
aDst
.
Elements
(
)
&
dstWritten
aLast
&
hadReplacements
)
;
return
MakeTuple
(
result
srcRead
dstWritten
hadReplacements
)
;
}
inline
Tuple
<
uint32_t
size_t
size_t
>
EncodeFromUTF8WithoutReplacement
(
Span
<
const
uint8_t
>
aSrc
Span
<
uint8_t
>
aDst
bool
aLast
)
{
size_t
srcRead
=
aSrc
.
Length
(
)
;
size_t
dstWritten
=
aDst
.
Length
(
)
;
uint32_t
result
=
encoder_encode_from_utf8_without_replacement
(
this
aSrc
.
Elements
(
)
&
srcRead
aDst
.
Elements
(
)
&
dstWritten
aLast
)
;
return
MakeTuple
(
result
srcRead
dstWritten
)
;
}
inline
CheckedInt
<
size_t
>
MaxBufferLengthFromUTF16IfNoUnmappables
(
size_t
aU16Length
)
const
{
CheckedInt
<
size_t
>
max
(
encoder_max_buffer_length_from_utf16_if_no_unmappables
(
this
aU16Length
)
)
;
if
(
max
.
value
(
)
=
=
MaxValue
<
size_t
>
:
:
value
)
{
max
+
+
;
MOZ_ASSERT
(
!
max
.
isValid
(
)
)
;
}
return
max
;
}
inline
CheckedInt
<
size_t
>
MaxBufferLengthFromUTF16WithoutReplacement
(
size_t
aU16Length
)
const
{
CheckedInt
<
size_t
>
max
(
encoder_max_buffer_length_from_utf16_without_replacement
(
this
aU16Length
)
)
;
if
(
max
.
value
(
)
=
=
MaxValue
<
size_t
>
:
:
value
)
{
max
+
+
;
MOZ_ASSERT
(
!
max
.
isValid
(
)
)
;
}
return
max
;
}
inline
Tuple
<
uint32_t
size_t
size_t
bool
>
EncodeFromUTF16
(
Span
<
const
char16_t
>
aSrc
Span
<
uint8_t
>
aDst
bool
aLast
)
{
size_t
srcRead
=
aSrc
.
Length
(
)
;
size_t
dstWritten
=
aDst
.
Length
(
)
;
bool
hadReplacements
;
uint32_t
result
=
encoder_encode_from_utf16
(
this
aSrc
.
Elements
(
)
&
srcRead
aDst
.
Elements
(
)
&
dstWritten
aLast
&
hadReplacements
)
;
return
MakeTuple
(
result
srcRead
dstWritten
hadReplacements
)
;
}
inline
Tuple
<
uint32_t
size_t
size_t
>
EncodeFromUTF16WithoutReplacement
(
Span
<
const
char16_t
>
aSrc
Span
<
uint8_t
>
aDst
bool
aLast
)
{
size_t
srcRead
=
aSrc
.
Length
(
)
;
size_t
dstWritten
=
aDst
.
Length
(
)
;
uint32_t
result
=
encoder_encode_from_utf16_without_replacement
(
this
aSrc
.
Elements
(
)
&
srcRead
aDst
.
Elements
(
)
&
dstWritten
aLast
)
;
return
MakeTuple
(
result
srcRead
dstWritten
)
;
}
private
:
Encoder
(
)
=
delete
;
Encoder
(
const
Encoder
&
)
=
delete
;
Encoder
&
operator
=
(
const
Encoder
&
)
=
delete
;
}
;
}
;
#
endif
