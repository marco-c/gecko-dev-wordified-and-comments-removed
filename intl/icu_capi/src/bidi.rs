#
[
diplomat
:
:
bridge
]
pub
mod
ffi
{
use
alloc
:
:
boxed
:
:
Box
;
use
alloc
:
:
vec
:
:
Vec
;
use
diplomat_runtime
:
:
DiplomatWriteable
;
use
core
:
:
fmt
:
:
Write
;
use
icu_properties
:
:
bidi
:
:
BidiClassAdapter
;
use
icu_properties
:
:
maps
;
use
icu_properties
:
:
BidiClass
;
use
unicode_bidi
:
:
BidiInfo
;
use
unicode_bidi
:
:
Level
;
use
unicode_bidi
:
:
Paragraph
;
use
crate
:
:
errors
:
:
ffi
:
:
ICU4XError
;
use
crate
:
:
provider
:
:
ffi
:
:
ICU4XDataProvider
;
pub
enum
ICU4XBidiDirection
{
Ltr
Rtl
Mixed
}
#
[
diplomat
:
:
opaque
]
#
[
diplomat
:
:
rust_link
(
icu
:
:
properties
:
:
bidi
:
:
BidiClassAdapter
Struct
)
]
pub
struct
ICU4XBidi
(
pub
maps
:
:
CodePointMapData
<
BidiClass
>
)
;
impl
ICU4XBidi
{
#
[
diplomat
:
:
rust_link
(
icu
:
:
properties
:
:
bidi
:
:
BidiClassAdapter
:
:
new
FnInStruct
)
]
pub
fn
create
(
provider
:
&
ICU4XDataProvider
)
-
>
Result
<
Box
<
ICU4XBidi
>
ICU4XError
>
{
Ok
(
Box
:
:
new
(
ICU4XBidi
(
call_constructor_unstable
!
(
maps
:
:
bidi_class
[
m
=
>
Ok
(
m
.
static_to_owned
(
)
)
]
maps
:
:
load_bidi_class
provider
)
?
)
)
)
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
BidiInfo
:
:
new_with_data_source
FnInStruct
)
]
#
[
diplomat
:
:
rust_link
(
icu
:
:
properties
:
:
bidi
:
:
BidiClassAdapter
:
:
bidi_class
FnInStruct
hidden
)
]
pub
fn
for_text
<
'
text
>
(
&
self
text
:
&
'
text
str
default_level
:
u8
)
-
>
Box
<
ICU4XBidiInfo
<
'
text
>
>
{
let
data
=
self
.
0
.
as_borrowed
(
)
;
let
adapter
=
BidiClassAdapter
:
:
new
(
data
)
;
Box
:
:
new
(
ICU4XBidiInfo
(
BidiInfo
:
:
new_with_data_source
(
&
adapter
text
Level
:
:
new
(
default_level
)
.
ok
(
)
)
)
)
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
BidiInfo
:
:
reorder_visual
FnInStruct
)
]
pub
fn
reorder_visual
(
&
self
levels
:
&
[
u8
]
)
-
>
Box
<
ICU4XReorderedIndexMap
>
{
let
levels
=
Level
:
:
from_slice_unchecked
(
levels
)
;
Box
:
:
new
(
ICU4XReorderedIndexMap
(
BidiInfo
:
:
reorder_visual
(
levels
)
)
)
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
Level
:
:
is_rtl
FnInStruct
)
]
pub
fn
level_is_rtl
(
level
:
u8
)
-
>
bool
{
Level
:
:
new
(
level
)
.
unwrap_or_else
(
|
_
|
Level
:
:
ltr
(
)
)
.
is_rtl
(
)
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
Level
:
:
is_ltr
FnInStruct
)
]
pub
fn
level_is_ltr
(
level
:
u8
)
-
>
bool
{
Level
:
:
new
(
level
)
.
unwrap_or_else
(
|
_
|
Level
:
:
ltr
(
)
)
.
is_ltr
(
)
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
Level
:
:
rtl
FnInStruct
)
]
pub
fn
level_rtl
(
)
-
>
u8
{
Level
:
:
rtl
(
)
.
number
(
)
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
Level
:
:
ltr
FnInStruct
)
]
pub
fn
level_ltr
(
)
-
>
u8
{
Level
:
:
ltr
(
)
.
number
(
)
}
}
#
[
diplomat
:
:
opaque
]
pub
struct
ICU4XReorderedIndexMap
(
pub
Vec
<
usize
>
)
;
impl
ICU4XReorderedIndexMap
{
pub
fn
as_slice
<
'
a
>
(
&
'
a
self
)
-
>
&
'
a
[
usize
]
{
&
self
.
0
}
#
[
allow
(
clippy
:
:
len_without_is_empty
)
]
#
[
diplomat
:
:
attr
(
dart
rename
=
"
length
"
)
]
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
0
.
len
(
)
}
pub
fn
get
(
&
self
index
:
usize
)
-
>
usize
{
self
.
0
.
get
(
index
)
.
copied
(
)
.
unwrap_or
(
0
)
}
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
BidiInfo
Struct
)
]
#
[
diplomat
:
:
opaque
]
pub
struct
ICU4XBidiInfo
<
'
text
>
(
pub
BidiInfo
<
'
text
>
)
;
impl
<
'
text
>
ICU4XBidiInfo
<
'
text
>
{
pub
fn
paragraph_count
(
&
self
)
-
>
usize
{
self
.
0
.
paragraphs
.
len
(
)
}
pub
fn
paragraph_at
(
&
'
text
self
n
:
usize
)
-
>
Option
<
Box
<
ICU4XBidiParagraph
<
'
text
>
>
>
{
self
.
0
.
paragraphs
.
get
(
n
)
.
map
(
|
p
|
Box
:
:
new
(
ICU4XBidiParagraph
(
Paragraph
:
:
new
(
&
self
.
0
p
)
)
)
)
}
pub
fn
size
(
&
self
)
-
>
usize
{
self
.
0
.
levels
.
len
(
)
}
pub
fn
level_at
(
&
self
pos
:
usize
)
-
>
u8
{
if
let
Some
(
l
)
=
self
.
0
.
levels
.
get
(
pos
)
{
l
.
number
(
)
}
else
{
0
}
}
}
#
[
diplomat
:
:
opaque
]
pub
struct
ICU4XBidiParagraph
<
'
info
>
(
pub
Paragraph
<
'
info
'
info
>
)
;
impl
<
'
info
>
ICU4XBidiParagraph
<
'
info
>
{
pub
fn
set_paragraph_in_text
(
&
mut
self
n
:
usize
)
-
>
Result
<
(
)
ICU4XError
>
{
let
para
=
self
.
0
.
info
.
paragraphs
.
get
(
n
)
.
ok_or
(
ICU4XError
:
:
OutOfBoundsError
)
?
;
self
.
0
=
Paragraph
:
:
new
(
self
.
0
.
info
para
)
;
Ok
(
(
)
)
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
Paragraph
:
:
level_at
FnInStruct
)
]
pub
fn
direction
(
&
self
)
-
>
ICU4XBidiDirection
{
self
.
0
.
direction
(
)
.
into
(
)
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
ParagraphInfo
:
:
len
FnInStruct
)
]
pub
fn
size
(
&
self
)
-
>
usize
{
self
.
0
.
para
.
len
(
)
}
pub
fn
range_start
(
&
self
)
-
>
usize
{
self
.
0
.
para
.
range
.
start
}
pub
fn
range_end
(
&
self
)
-
>
usize
{
self
.
0
.
para
.
range
.
end
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
Paragraph
:
:
level_at
FnInStruct
)
]
pub
fn
reorder_line
(
&
self
range_start
:
usize
range_end
:
usize
out
:
&
mut
DiplomatWriteable
)
-
>
Result
<
(
)
ICU4XError
>
{
if
range_start
<
self
.
range_start
(
)
|
|
range_end
>
self
.
range_end
(
)
{
return
Err
(
ICU4XError
:
:
OutOfBoundsError
)
;
}
let
info
=
self
.
0
.
info
;
let
para
=
self
.
0
.
para
;
let
reordered
=
info
.
reorder_line
(
para
range_start
.
.
range_end
)
;
Ok
(
out
.
write_str
(
&
reordered
)
?
)
}
#
[
diplomat
:
:
rust_link
(
unicode_bidi
:
:
Paragraph
:
:
level_at
FnInStruct
)
]
pub
fn
level_at
(
&
self
pos
:
usize
)
-
>
u8
{
if
pos
>
=
self
.
size
(
)
{
return
0
;
}
self
.
0
.
level_at
(
pos
)
.
number
(
)
}
}
}
use
unicode_bidi
:
:
Direction
;
impl
From
<
Direction
>
for
ffi
:
:
ICU4XBidiDirection
{
fn
from
(
other
:
Direction
)
-
>
Self
{
match
other
{
Direction
:
:
Ltr
=
>
Self
:
:
Ltr
Direction
:
:
Rtl
=
>
Self
:
:
Rtl
Direction
:
:
Mixed
=
>
Self
:
:
Mixed
}
}
}
