use
unicode_bidi
:
:
level
:
:
Level
;
use
unicode_bidi
:
:
utf16
;
use
unicode_bidi
:
:
Direction
;
use
core
:
:
ops
:
:
Range
;
use
core
:
:
slice
;
#
[
repr
(
C
)
]
pub
struct
LevelRun
{
start
:
u32
length
:
u32
level
:
u8
}
pub
struct
UnicodeBidi
<
'
a
>
{
paragraph_info
:
utf16
:
:
ParagraphBidiInfo
<
'
a
>
resolved
:
Option
<
(
Vec
<
Level
>
Vec
<
Range
<
usize
>
>
)
>
}
impl
UnicodeBidi
<
'
_
>
{
fn
new
<
'
a
>
(
text
:
*
const
u16
length
:
usize
level
:
u8
)
-
>
Box
<
Self
>
{
let
text
=
unsafe
{
slice
:
:
from_raw_parts
(
text
length
)
}
;
let
level
=
if
let
Ok
(
level
)
=
Level
:
:
new
(
level
)
{
Some
(
level
)
}
else
{
None
}
;
Box
:
:
new
(
UnicodeBidi
{
paragraph_info
:
utf16
:
:
ParagraphBidiInfo
:
:
<
'
a
>
:
:
new
(
text
level
)
resolved
:
None
}
)
}
#
[
inline
]
fn
resolved
(
&
mut
self
)
-
>
&
(
Vec
<
Level
>
Vec
<
Range
<
usize
>
>
)
{
if
self
.
resolved
.
is_none
(
)
{
let
len
=
self
.
paragraph_info
.
text
.
len
(
)
;
self
.
resolved
=
Some
(
self
.
paragraph_info
.
visual_runs
(
0
.
.
len
)
)
;
}
&
self
.
resolved
.
as_ref
(
)
.
unwrap
(
)
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_new
<
'
a
>
(
text
:
*
const
u16
length
:
usize
level
:
u8
)
-
>
*
mut
UnicodeBidi
<
'
a
>
{
Box
:
:
into_raw
(
UnicodeBidi
:
:
<
'
a
>
:
:
new
(
text
length
level
)
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_destroy
(
bidi
:
*
mut
UnicodeBidi
)
{
if
bidi
.
is_null
(
)
{
return
;
}
let
_
=
unsafe
{
Box
:
:
from_raw
(
bidi
)
}
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_get_length
(
bidi
:
*
const
UnicodeBidi
)
-
>
i32
{
let
bidi
=
unsafe
{
&
(
*
bidi
)
}
;
bidi
.
paragraph_info
.
text
.
len
(
)
.
try_into
(
)
.
unwrap
(
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_get_direction
(
bidi
:
*
const
UnicodeBidi
)
-
>
i8
{
let
bidi
=
unsafe
{
&
(
*
bidi
)
}
;
match
bidi
.
paragraph_info
.
direction
(
)
{
Direction
:
:
Mixed
=
>
0
Direction
:
:
Ltr
=
>
1
Direction
:
:
Rtl
=
>
-
1
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_get_paragraph_level
(
bidi
:
*
const
UnicodeBidi
)
-
>
u8
{
let
bidi
=
unsafe
{
&
(
*
bidi
)
}
;
bidi
.
paragraph_info
.
paragraph_level
.
into
(
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_count_runs
(
bidi
:
*
mut
UnicodeBidi
)
-
>
i32
{
let
bidi
=
unsafe
{
&
mut
(
*
bidi
)
}
;
if
bidi
.
paragraph_info
.
text
.
is_empty
(
)
{
return
0
;
}
bidi
.
resolved
(
)
.
1
.
len
(
)
.
try_into
(
)
.
unwrap
(
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_get_levels
(
bidi
:
*
mut
UnicodeBidi
)
-
>
*
const
Level
{
let
bidi
=
unsafe
{
&
mut
(
*
bidi
)
}
;
bidi
.
resolved
(
)
.
0
.
as_ptr
(
)
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_get_visual_run
(
bidi
:
*
mut
UnicodeBidi
run_index
:
u32
)
-
>
LevelRun
{
let
bidi
=
unsafe
{
&
mut
(
*
bidi
)
}
;
let
level_runs
=
&
bidi
.
resolved
(
)
.
1
;
let
start
=
level_runs
[
run_index
as
usize
]
.
start
;
let
length
=
level_runs
[
run_index
as
usize
]
.
end
-
start
;
LevelRun
{
start
:
start
.
try_into
(
)
.
unwrap
(
)
length
:
length
.
try_into
(
)
.
unwrap
(
)
level
:
bidi
.
resolved
(
)
.
0
[
start
]
.
into
(
)
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_reorder_visual
(
levels
:
*
const
u8
length
:
usize
index_map
:
*
mut
i32
)
{
let
levels
=
unsafe
{
slice
:
:
from_raw_parts
(
levels
as
*
const
Level
length
)
}
;
let
result
=
unsafe
{
slice
:
:
from_raw_parts_mut
(
index_map
length
)
}
;
let
reordered
=
utf16
:
:
BidiInfo
:
:
reorder_visual
(
levels
)
;
for
i
in
0
.
.
length
{
result
[
i
]
=
reordered
[
i
]
.
try_into
(
)
.
unwrap
(
)
;
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
bidi_get_base_direction
(
text
:
*
const
u16
length
:
usize
first_paragraph
:
bool
)
-
>
i8
{
let
text
=
unsafe
{
slice
:
:
from_raw_parts
(
text
length
)
}
;
if
first_paragraph
{
match
unicode_bidi
:
:
get_base_direction
(
text
)
{
Direction
:
:
Mixed
=
>
0
Direction
:
:
Ltr
=
>
1
Direction
:
:
Rtl
=
>
-
1
}
}
else
{
match
unicode_bidi
:
:
get_base_direction_full
(
text
)
{
Direction
:
:
Mixed
=
>
0
Direction
:
:
Ltr
=
>
1
Direction
:
:
Rtl
=
>
-
1
}
}
}
