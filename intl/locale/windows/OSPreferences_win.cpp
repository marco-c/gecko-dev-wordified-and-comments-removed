#
include
"
OSPreferences
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
<
windows
.
h
>
#
ifndef
__MINGW32__
#
include
<
roapi
.
h
>
#
include
<
wrl
.
h
>
#
include
<
Windows
.
System
.
UserProfile
.
h
>
using
namespace
Microsoft
:
:
WRL
;
using
namespace
Microsoft
:
:
WRL
:
:
Wrappers
;
using
namespace
ABI
:
:
Windows
:
:
Foundation
:
:
Collections
;
using
namespace
ABI
:
:
Windows
:
:
System
:
:
UserProfile
;
#
endif
using
namespace
mozilla
:
:
intl
;
OSPreferences
:
:
OSPreferences
(
)
{
}
OSPreferences
:
:
~
OSPreferences
(
)
{
}
bool
OSPreferences
:
:
ReadSystemLocales
(
nsTArray
<
nsCString
>
&
aLocaleList
)
{
MOZ_ASSERT
(
aLocaleList
.
IsEmpty
(
)
)
;
#
ifndef
__MINGW32__
if
(
IsWin8OrLater
(
)
)
{
HRESULT
inited
=
RoInitialize
(
RO_INIT_MULTITHREADED
)
;
if
(
SUCCEEDED
(
inited
)
|
|
inited
=
=
RPC_E_CHANGED_MODE
)
{
ComPtr
<
IGlobalizationPreferencesStatics
>
globalizationPrefs
;
ComPtr
<
IVectorView
<
HSTRING
>
>
languages
;
uint32_t
count
;
if
(
SUCCEEDED
(
RoGetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_System_UserProfile_GlobalizationPreferences
)
.
Get
(
)
IID_PPV_ARGS
(
&
globalizationPrefs
)
)
)
&
&
SUCCEEDED
(
globalizationPrefs
-
>
get_Languages
(
&
languages
)
)
&
&
SUCCEEDED
(
languages
-
>
get_Size
(
&
count
)
)
)
{
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
HString
lang
;
if
(
SUCCEEDED
(
languages
-
>
GetAt
(
i
lang
.
GetAddressOf
(
)
)
)
)
{
unsigned
int
length
;
const
wchar_t
*
text
=
lang
.
GetRawBuffer
(
&
length
)
;
NS_LossyConvertUTF16toASCII
loc
(
text
length
)
;
if
(
CanonicalizeLanguageTag
(
loc
)
)
{
aLocaleList
.
AppendElement
(
loc
)
;
}
}
}
}
}
if
(
SUCCEEDED
(
inited
)
)
{
RoUninitialize
(
)
;
}
}
#
endif
if
(
aLocaleList
.
IsEmpty
(
)
)
{
ULONG
numLanguages
=
0
;
DWORD
cchLanguagesBuffer
=
0
;
if
(
!
GetUserPreferredUILanguages
(
MUI_LANGUAGE_NAME
&
numLanguages
nullptr
&
cchLanguagesBuffer
)
)
{
return
false
;
}
AutoTArray
<
WCHAR
64
>
locBuffer
;
locBuffer
.
SetCapacity
(
cchLanguagesBuffer
)
;
if
(
!
GetUserPreferredUILanguages
(
MUI_LANGUAGE_NAME
&
numLanguages
locBuffer
.
Elements
(
)
&
cchLanguagesBuffer
)
)
{
return
false
;
}
const
WCHAR
*
start
=
locBuffer
.
Elements
(
)
;
const
WCHAR
*
bufEnd
=
start
+
cchLanguagesBuffer
;
while
(
bufEnd
-
start
>
1
&
&
*
start
)
{
const
WCHAR
*
end
=
start
+
1
;
while
(
bufEnd
-
end
>
1
&
&
*
end
)
{
end
+
+
;
}
NS_LossyConvertUTF16toASCII
loc
(
start
end
-
start
)
;
if
(
CanonicalizeLanguageTag
(
loc
)
)
{
aLocaleList
.
AppendElement
(
loc
)
;
}
start
=
end
+
1
;
}
}
return
!
aLocaleList
.
IsEmpty
(
)
;
}
bool
OSPreferences
:
:
ReadRegionalPrefsLocales
(
nsTArray
<
nsCString
>
&
aLocaleList
)
{
MOZ_ASSERT
(
aLocaleList
.
IsEmpty
(
)
)
;
WCHAR
locale
[
LOCALE_NAME_MAX_LENGTH
]
;
if
(
NS_WARN_IF
(
!
LCIDToLocaleName
(
LOCALE_USER_DEFAULT
locale
LOCALE_NAME_MAX_LENGTH
0
)
)
)
{
return
false
;
}
NS_LossyConvertUTF16toASCII
loc
(
locale
)
;
if
(
CanonicalizeLanguageTag
(
loc
)
)
{
aLocaleList
.
AppendElement
(
loc
)
;
return
true
;
}
return
false
;
}
static
LCTYPE
ToDateLCType
(
OSPreferences
:
:
DateTimeFormatStyle
aFormatStyle
)
{
switch
(
aFormatStyle
)
{
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
None
:
return
LOCALE_SLONGDATE
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Short
:
return
LOCALE_SSHORTDATE
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Medium
:
return
LOCALE_SSHORTDATE
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Long
:
return
LOCALE_SLONGDATE
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Full
:
return
LOCALE_SLONGDATE
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Invalid
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
date
format
"
)
;
return
LOCALE_SLONGDATE
;
}
}
static
LCTYPE
ToTimeLCType
(
OSPreferences
:
:
DateTimeFormatStyle
aFormatStyle
)
{
switch
(
aFormatStyle
)
{
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
None
:
return
LOCALE_STIMEFORMAT
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Short
:
return
LOCALE_SSHORTTIME
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Medium
:
return
LOCALE_SSHORTTIME
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Long
:
return
LOCALE_STIMEFORMAT
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Full
:
return
LOCALE_STIMEFORMAT
;
case
OSPreferences
:
:
DateTimeFormatStyle
:
:
Invalid
:
default
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
time
format
"
)
;
return
LOCALE_STIMEFORMAT
;
}
}
bool
OSPreferences
:
:
ReadDateTimePattern
(
DateTimeFormatStyle
aDateStyle
DateTimeFormatStyle
aTimeStyle
const
nsACString
&
aLocale
nsAString
&
aRetVal
)
{
nsAutoString
localeName
;
CopyASCIItoUTF16
(
aLocale
localeName
)
;
bool
isDate
=
aDateStyle
!
=
DateTimeFormatStyle
:
:
None
&
&
aDateStyle
!
=
DateTimeFormatStyle
:
:
Invalid
;
bool
isTime
=
aTimeStyle
!
=
DateTimeFormatStyle
:
:
None
&
&
aTimeStyle
!
=
DateTimeFormatStyle
:
:
Invalid
;
nsAutoString
tmpStr
;
nsAString
*
str
;
if
(
isDate
&
&
isTime
)
{
if
(
!
GetDateTimeConnectorPattern
(
aLocale
aRetVal
)
)
{
NS_WARNING
(
"
failed
to
get
date
/
time
connector
"
)
;
aRetVal
.
AssignLiteral
(
u
"
{
1
}
{
0
}
"
)
;
}
str
=
&
tmpStr
;
}
else
if
(
isDate
|
|
isTime
)
{
str
=
&
aRetVal
;
}
else
{
aRetVal
.
Truncate
(
0
)
;
return
true
;
}
if
(
isDate
)
{
LCTYPE
lcType
=
ToDateLCType
(
aDateStyle
)
;
size_t
len
=
GetLocaleInfoEx
(
reinterpret_cast
<
const
wchar_t
*
>
(
localeName
.
BeginReading
(
)
)
lcType
nullptr
0
)
;
if
(
len
=
=
0
)
{
return
false
;
}
str
-
>
SetLength
(
len
)
;
GetLocaleInfoEx
(
reinterpret_cast
<
const
wchar_t
*
>
(
localeName
.
BeginReading
(
)
)
lcType
(
WCHAR
*
)
str
-
>
BeginWriting
(
)
len
)
;
str
-
>
SetLength
(
len
-
1
)
;
nsAString
:
:
const_iterator
start
pos
end
;
start
=
str
-
>
BeginReading
(
pos
)
;
str
-
>
EndReading
(
end
)
;
if
(
FindInReadable
(
NS_LITERAL_STRING
(
"
dddd
"
)
pos
end
)
)
{
str
-
>
ReplaceLiteral
(
pos
-
start
4
u
"
EEEE
"
)
;
}
else
{
pos
=
start
;
if
(
FindInReadable
(
NS_LITERAL_STRING
(
"
ddd
"
)
pos
end
)
)
{
str
-
>
ReplaceLiteral
(
pos
-
start
3
u
"
EEE
"
)
;
}
}
int32_t
index
=
str
-
>
FindChar
(
'
g
'
)
;
if
(
index
>
=
0
)
{
str
-
>
Replace
(
index
1
'
G
'
)
;
index
+
+
;
if
(
str
-
>
CharAt
(
index
)
=
=
'
g
'
)
{
str
-
>
Cut
(
index
1
)
;
}
}
if
(
isTime
)
{
nsAString
:
:
const_iterator
start
pos
end
;
start
=
aRetVal
.
BeginReading
(
pos
)
;
aRetVal
.
EndReading
(
end
)
;
if
(
FindInReadable
(
NS_LITERAL_STRING
(
"
{
1
}
"
)
pos
end
)
)
{
aRetVal
.
Replace
(
pos
-
start
3
tmpStr
)
;
}
}
}
if
(
isTime
)
{
LCTYPE
lcType
=
ToTimeLCType
(
aTimeStyle
)
;
size_t
len
=
GetLocaleInfoEx
(
reinterpret_cast
<
const
wchar_t
*
>
(
localeName
.
BeginReading
(
)
)
lcType
nullptr
0
)
;
if
(
len
=
=
0
)
{
return
false
;
}
str
-
>
SetLength
(
len
)
;
GetLocaleInfoEx
(
reinterpret_cast
<
const
wchar_t
*
>
(
localeName
.
BeginReading
(
)
)
lcType
(
WCHAR
*
)
str
-
>
BeginWriting
(
)
len
)
;
str
-
>
SetLength
(
len
-
1
)
;
int32_t
index
=
str
-
>
FindChar
(
'
t
'
)
;
if
(
index
>
=
0
)
{
str
-
>
Replace
(
index
1
'
a
'
)
;
index
+
+
;
if
(
str
-
>
CharAt
(
index
)
=
=
'
t
'
)
{
str
-
>
Cut
(
index
1
)
;
}
}
if
(
isDate
)
{
nsAString
:
:
const_iterator
start
pos
end
;
start
=
aRetVal
.
BeginReading
(
pos
)
;
aRetVal
.
EndReading
(
end
)
;
if
(
FindInReadable
(
NS_LITERAL_STRING
(
"
{
0
}
"
)
pos
end
)
)
{
aRetVal
.
Replace
(
pos
-
start
3
tmpStr
)
;
}
}
}
return
true
;
}
