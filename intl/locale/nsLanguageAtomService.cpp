#
include
"
nsLanguageAtomService
.
h
"
#
include
"
nsUConvPropertySearch
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
intl
/
OSPreferences
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
intl
:
:
OSPreferences
;
static
constexpr
nsUConvProp
encodingsGroups
[
]
=
{
#
include
"
encodingsgroups
.
properties
.
h
"
}
;
static
constexpr
const
char
*
kLangGroups
[
]
=
{
"
x
-
armn
"
"
x
-
cyrillic
"
"
x
-
devanagari
"
"
x
-
geor
"
"
x
-
math
"
"
x
-
tamil
"
"
x
-
unicode
"
"
x
-
western
"
}
;
static
constexpr
struct
{
const
char
*
mTag
;
nsAtom
*
mAtom
;
}
kScriptLangGroup
[
]
=
{
{
"
Arab
"
nsGkAtoms
:
:
ar
}
{
"
Armn
"
nsGkAtoms
:
:
x_armn
}
{
"
Beng
"
nsGkAtoms
:
:
x_beng
}
{
"
Cans
"
nsGkAtoms
:
:
x_cans
}
{
"
Cyrl
"
nsGkAtoms
:
:
x_cyrillic
}
{
"
Deva
"
nsGkAtoms
:
:
x_devanagari
}
{
"
Ethi
"
nsGkAtoms
:
:
x_ethi
}
{
"
Geok
"
nsGkAtoms
:
:
x_geor
}
{
"
Geor
"
nsGkAtoms
:
:
x_geor
}
{
"
Grek
"
nsGkAtoms
:
:
el
}
{
"
Gujr
"
nsGkAtoms
:
:
x_gujr
}
{
"
Guru
"
nsGkAtoms
:
:
x_guru
}
{
"
Hang
"
nsGkAtoms
:
:
ko
}
{
"
Hani
"
nsGkAtoms
:
:
Japanese
}
{
"
Hans
"
nsGkAtoms
:
:
Chinese
}
{
"
Hebr
"
nsGkAtoms
:
:
he
}
{
"
Hira
"
nsGkAtoms
:
:
Japanese
}
{
"
Jpan
"
nsGkAtoms
:
:
Japanese
}
{
"
Kana
"
nsGkAtoms
:
:
Japanese
}
{
"
Khmr
"
nsGkAtoms
:
:
x_khmr
}
{
"
Knda
"
nsGkAtoms
:
:
x_knda
}
{
"
Kore
"
nsGkAtoms
:
:
ko
}
{
"
Latn
"
nsGkAtoms
:
:
x_western
}
{
"
Mlym
"
nsGkAtoms
:
:
x_mlym
}
{
"
Orya
"
nsGkAtoms
:
:
x_orya
}
{
"
Sinh
"
nsGkAtoms
:
:
x_sinh
}
{
"
Taml
"
nsGkAtoms
:
:
x_tamil
}
{
"
Telu
"
nsGkAtoms
:
:
x_telu
}
{
"
Thai
"
nsGkAtoms
:
:
th
}
{
"
Tibt
"
nsGkAtoms
:
:
x_tibt
}
}
;
nsLanguageAtomService
*
nsLanguageAtomService
:
:
GetService
(
)
{
static
UniquePtr
<
nsLanguageAtomService
>
gLangAtomService
;
if
(
!
gLangAtomService
)
{
gLangAtomService
=
MakeUnique
<
nsLanguageAtomService
>
(
)
;
ClearOnShutdown
(
&
gLangAtomService
)
;
}
return
gLangAtomService
.
get
(
)
;
}
nsAtom
*
nsLanguageAtomService
:
:
LookupLanguage
(
const
nsACString
&
aLanguage
)
{
nsAutoCString
lowered
(
aLanguage
)
;
ToLowerCase
(
lowered
)
;
RefPtr
<
nsAtom
>
lang
=
NS_Atomize
(
lowered
)
;
return
GetLanguageGroup
(
lang
)
;
}
already_AddRefed
<
nsAtom
>
nsLanguageAtomService
:
:
LookupCharSet
(
NotNull
<
const
Encoding
*
>
aEncoding
)
{
nsAutoCString
charset
;
aEncoding
-
>
Name
(
charset
)
;
nsAutoCString
group
;
if
(
NS_FAILED
(
nsUConvPropertySearch
:
:
SearchPropertyValue
(
encodingsGroups
ArrayLength
(
encodingsGroups
)
charset
group
)
)
)
{
return
RefPtr
<
nsAtom
>
(
nsGkAtoms
:
:
Unicode
)
.
forget
(
)
;
}
return
NS_Atomize
(
group
)
;
}
nsAtom
*
nsLanguageAtomService
:
:
GetLocaleLanguage
(
)
{
do
{
if
(
!
mLocaleLanguage
)
{
AutoTArray
<
nsCString
10
>
regionalPrefsLocales
;
if
(
NS_SUCCEEDED
(
OSPreferences
:
:
GetInstance
(
)
-
>
GetRegionalPrefsLocales
(
regionalPrefsLocales
)
)
)
{
ToLowerCase
(
regionalPrefsLocales
[
0
]
)
;
mLocaleLanguage
=
NS_Atomize
(
regionalPrefsLocales
[
0
]
)
;
}
else
{
nsAutoCString
locale
;
OSPreferences
:
:
GetInstance
(
)
-
>
GetSystemLocale
(
locale
)
;
ToLowerCase
(
locale
)
;
mLocaleLanguage
=
NS_Atomize
(
locale
)
;
}
}
}
while
(
0
)
;
return
mLocaleLanguage
;
}
nsAtom
*
nsLanguageAtomService
:
:
GetLanguageGroup
(
nsAtom
*
aLanguage
bool
*
aNeedsToCache
)
{
nsAtom
*
retVal
=
mLangToGroup
.
GetWeak
(
aLanguage
)
;
if
(
!
retVal
)
{
if
(
aNeedsToCache
)
{
*
aNeedsToCache
=
true
;
return
nullptr
;
}
RefPtr
<
nsAtom
>
uncached
=
GetUncachedLanguageGroup
(
aLanguage
)
;
retVal
=
uncached
.
get
(
)
;
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
mLangToGroup
.
Put
(
aLanguage
uncached
)
;
}
return
retVal
;
}
already_AddRefed
<
nsAtom
>
nsLanguageAtomService
:
:
GetUncachedLanguageGroup
(
nsAtom
*
aLanguage
)
const
{
nsAutoCString
langStr
;
aLanguage
-
>
ToUTF8String
(
langStr
)
;
ToLowerCase
(
langStr
)
;
RefPtr
<
nsAtom
>
langGroup
;
if
(
langStr
[
0
]
=
=
'
x
'
&
&
langStr
[
1
]
=
=
'
-
'
)
{
size_t
unused
;
if
(
BinarySearchIf
(
kLangGroups
0
ArrayLength
(
kLangGroups
)
[
&
langStr
]
(
const
char
*
tag
)
-
>
int
{
return
langStr
.
Compare
(
tag
)
;
}
&
unused
)
)
{
langGroup
=
NS_Atomize
(
langStr
)
;
return
langGroup
.
forget
(
)
;
}
}
else
{
Locale
loc
(
langStr
)
;
if
(
loc
.
IsWellFormed
(
)
)
{
if
(
loc
.
GetScript
(
)
.
IsEmpty
(
)
)
{
loc
.
AddLikelySubtags
(
)
;
}
if
(
loc
.
GetScript
(
)
.
EqualsLiteral
(
"
Hant
"
)
)
{
if
(
loc
.
GetRegion
(
)
.
EqualsLiteral
(
"
HK
"
)
)
{
langGroup
=
nsGkAtoms
:
:
HongKongChinese
;
}
else
{
langGroup
=
nsGkAtoms
:
:
Taiwanese
;
}
return
langGroup
.
forget
(
)
;
}
else
{
size_t
foundIndex
;
const
nsCString
&
script
=
loc
.
GetScript
(
)
;
if
(
BinarySearchIf
(
kScriptLangGroup
0
ArrayLength
(
kScriptLangGroup
)
[
script
]
(
const
auto
&
entry
)
-
>
int
{
return
script
.
Compare
(
entry
.
mTag
)
;
}
&
foundIndex
)
)
{
langGroup
=
kScriptLangGroup
[
foundIndex
]
.
mAtom
;
return
langGroup
.
forget
(
)
;
}
}
}
}
langGroup
=
nsGkAtoms
:
:
Unicode
;
return
langGroup
.
forget
(
)
;
}
