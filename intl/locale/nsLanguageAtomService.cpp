#
include
"
nsLanguageAtomService
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
intl
/
Locale
.
h
"
#
include
"
mozilla
/
intl
/
OSPreferences
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsUConvPropertySearch
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
<
mutex
>
using
namespace
mozilla
;
using
mozilla
:
:
intl
:
:
OSPreferences
;
static
constexpr
nsStaticAtom
*
kLangGroups
[
]
=
{
nsGkAtoms
:
:
x_armn
nsGkAtoms
:
:
x_cyrillic
nsGkAtoms
:
:
x_devanagari
nsGkAtoms
:
:
x_geor
nsGkAtoms
:
:
x_math
nsGkAtoms
:
:
x_tamil
nsGkAtoms
:
:
Unicode
nsGkAtoms
:
:
x_western
}
;
static
constexpr
struct
{
const
char
*
mTag
;
nsStaticAtom
*
mAtom
;
}
kScriptLangGroup
[
]
=
{
{
"
Arab
"
nsGkAtoms
:
:
ar
}
{
"
Armn
"
nsGkAtoms
:
:
x_armn
}
{
"
Beng
"
nsGkAtoms
:
:
x_beng
}
{
"
Cans
"
nsGkAtoms
:
:
x_cans
}
{
"
Cyrl
"
nsGkAtoms
:
:
x_cyrillic
}
{
"
Deva
"
nsGkAtoms
:
:
x_devanagari
}
{
"
Ethi
"
nsGkAtoms
:
:
x_ethi
}
{
"
Geok
"
nsGkAtoms
:
:
x_geor
}
{
"
Geor
"
nsGkAtoms
:
:
x_geor
}
{
"
Grek
"
nsGkAtoms
:
:
el
}
{
"
Gujr
"
nsGkAtoms
:
:
x_gujr
}
{
"
Guru
"
nsGkAtoms
:
:
x_guru
}
{
"
Hang
"
nsGkAtoms
:
:
ko
}
{
"
Hans
"
nsGkAtoms
:
:
Chinese
}
{
"
Hebr
"
nsGkAtoms
:
:
he
}
{
"
Hira
"
nsGkAtoms
:
:
Japanese
}
{
"
Jpan
"
nsGkAtoms
:
:
Japanese
}
{
"
Kana
"
nsGkAtoms
:
:
Japanese
}
{
"
Khmr
"
nsGkAtoms
:
:
x_khmr
}
{
"
Knda
"
nsGkAtoms
:
:
x_knda
}
{
"
Kore
"
nsGkAtoms
:
:
ko
}
{
"
Latn
"
nsGkAtoms
:
:
x_western
}
{
"
Mlym
"
nsGkAtoms
:
:
x_mlym
}
{
"
Orya
"
nsGkAtoms
:
:
x_orya
}
{
"
Sinh
"
nsGkAtoms
:
:
x_sinh
}
{
"
Taml
"
nsGkAtoms
:
:
x_tamil
}
{
"
Telu
"
nsGkAtoms
:
:
x_telu
}
{
"
Thai
"
nsGkAtoms
:
:
th
}
{
"
Tibt
"
nsGkAtoms
:
:
x_tibt
}
}
;
StaticAutoPtr
<
nsLanguageAtomService
>
nsLanguageAtomService
:
:
sLangAtomService
;
nsLanguageAtomService
*
nsLanguageAtomService
:
:
GetService
(
)
{
static
std
:
:
once_flag
sOnce
;
std
:
:
call_once
(
sOnce
[
]
(
)
{
sLangAtomService
=
new
nsLanguageAtomService
(
)
;
}
)
;
return
sLangAtomService
.
get
(
)
;
}
void
nsLanguageAtomService
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sLangAtomService
=
nullptr
;
}
nsStaticAtom
*
nsLanguageAtomService
:
:
LookupLanguage
(
const
nsACString
&
aLanguage
)
{
nsAutoCString
lowered
(
aLanguage
)
;
ToLowerCase
(
lowered
)
;
RefPtr
<
nsAtom
>
lang
=
NS_Atomize
(
lowered
)
;
return
GetLanguageGroup
(
lang
)
;
}
nsAtom
*
nsLanguageAtomService
:
:
GetLocaleLanguage
(
)
{
{
AutoReadLock
lock
(
mLock
)
;
if
(
mLocaleLanguage
)
{
return
mLocaleLanguage
;
}
}
AutoWriteLock
lock
(
mLock
)
;
if
(
!
mLocaleLanguage
)
{
AutoTArray
<
nsCString
10
>
regionalPrefsLocales
;
if
(
NS_SUCCEEDED
(
OSPreferences
:
:
GetInstance
(
)
-
>
GetRegionalPrefsLocales
(
regionalPrefsLocales
)
)
)
{
ToLowerCase
(
regionalPrefsLocales
[
0
]
)
;
mLocaleLanguage
=
NS_Atomize
(
regionalPrefsLocales
[
0
]
)
;
}
else
{
nsAutoCString
locale
;
OSPreferences
:
:
GetInstance
(
)
-
>
GetSystemLocale
(
locale
)
;
ToLowerCase
(
locale
)
;
mLocaleLanguage
=
NS_Atomize
(
locale
)
;
}
}
return
mLocaleLanguage
;
}
nsStaticAtom
*
nsLanguageAtomService
:
:
GetLanguageGroup
(
nsAtom
*
aLanguage
)
{
{
AutoReadLock
lock
(
mLock
)
;
if
(
nsStaticAtom
*
atom
=
mLangToGroup
.
Get
(
aLanguage
)
)
{
return
atom
;
}
}
AutoWriteLock
lock
(
mLock
)
;
return
mLangToGroup
.
LookupOrInsertWith
(
aLanguage
[
&
]
{
return
GetUncachedLanguageGroup
(
aLanguage
)
;
}
)
;
}
nsStaticAtom
*
nsLanguageAtomService
:
:
GetUncachedLanguageGroup
(
nsAtom
*
aLanguage
)
const
{
nsAutoCString
langStr
;
aLanguage
-
>
ToUTF8String
(
langStr
)
;
ToLowerCase
(
langStr
)
;
if
(
langStr
[
0
]
=
=
'
x
'
&
&
langStr
[
1
]
=
=
'
-
'
)
{
for
(
nsStaticAtom
*
langGroup
:
kLangGroups
)
{
if
(
langGroup
=
=
aLanguage
)
{
return
langGroup
;
}
if
(
aLanguage
-
>
IsAsciiLowercase
(
)
)
{
continue
;
}
nsDependentAtomString
string
(
langGroup
)
;
if
(
string
.
EqualsASCII
(
langStr
.
get
(
)
langStr
.
Length
(
)
)
)
{
return
langGroup
;
}
}
}
else
{
nsACString
:
:
const_iterator
start
end
;
langStr
.
BeginReading
(
start
)
;
langStr
.
EndReading
(
end
)
;
if
(
FindInReadable
(
"
-
x
-
"
_ns
start
end
)
)
{
langStr
.
Truncate
(
start
.
get
(
)
-
langStr
.
BeginReading
(
)
)
;
}
intl
:
:
Locale
loc
;
auto
result
=
intl
:
:
LocaleParser
:
:
TryParse
(
langStr
loc
)
;
if
(
!
result
.
isOk
(
)
)
{
if
(
langStr
.
Contains
(
'
_
'
)
)
{
langStr
.
ReplaceChar
(
'
_
'
'
-
'
)
;
loc
=
{
}
;
result
=
intl
:
:
LocaleParser
:
:
TryParse
(
langStr
loc
)
;
}
}
if
(
result
.
isOk
(
)
&
&
loc
.
Canonicalize
(
)
.
isOk
(
)
)
{
if
(
loc
.
Script
(
)
.
Missing
(
)
)
{
if
(
loc
.
Language
(
)
.
EqualTo
(
"
en
"
)
)
{
return
nsGkAtoms
:
:
x_western
;
}
if
(
loc
.
AddLikelySubtags
(
)
.
isErr
(
)
)
{
return
nsGkAtoms
:
:
Unicode
;
}
}
if
(
loc
.
Script
(
)
.
EqualTo
(
"
Hant
"
)
)
{
if
(
loc
.
Region
(
)
.
EqualTo
(
"
HK
"
)
)
{
return
nsGkAtoms
:
:
HongKongChinese
;
}
return
nsGkAtoms
:
:
Taiwanese
;
}
size_t
foundIndex
;
Span
<
const
char
>
scriptAsSpan
=
loc
.
Script
(
)
.
Span
(
)
;
nsDependentCSubstring
script
(
scriptAsSpan
.
data
(
)
scriptAsSpan
.
size
(
)
)
;
if
(
BinarySearchIf
(
kScriptLangGroup
0
std
:
:
size
(
kScriptLangGroup
)
[
script
]
(
const
auto
&
entry
)
-
>
int
{
return
Compare
(
script
nsDependentCString
(
entry
.
mTag
)
)
;
}
&
foundIndex
)
)
{
return
kScriptLangGroup
[
foundIndex
]
.
mAtom
;
}
if
(
loc
.
Language
(
)
.
EqualTo
(
"
zh
"
)
)
{
if
(
loc
.
Region
(
)
.
EqualTo
(
"
HK
"
)
)
{
return
nsGkAtoms
:
:
HongKongChinese
;
}
if
(
loc
.
Region
(
)
.
EqualTo
(
"
TW
"
)
)
{
return
nsGkAtoms
:
:
Taiwanese
;
}
return
nsGkAtoms
:
:
Chinese
;
}
if
(
loc
.
Language
(
)
.
EqualTo
(
"
ja
"
)
)
{
return
nsGkAtoms
:
:
Japanese
;
}
if
(
loc
.
Language
(
)
.
EqualTo
(
"
ko
"
)
)
{
return
nsGkAtoms
:
:
ko
;
}
}
}
return
nsGkAtoms
:
:
Unicode
;
}
