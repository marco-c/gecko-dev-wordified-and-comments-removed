"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonRepository
:
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
AddonManager
:
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
if
(
Services
.
appinfo
.
processType
!
=
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
This
code
is
assumed
to
run
in
the
parent
process
.
"
)
;
}
async
function
negotiateLangPackForLanguageMismatch
(
)
{
const
localeInfo
=
getAppAndSystemLocaleInfo
(
)
;
const
nullResult
=
{
langPack
:
null
langPackDisplayName
:
null
}
;
if
(
!
localeInfo
.
systemLocale
)
{
return
nullResult
;
}
const
availableLangpacks
=
await
mockable
.
getAvailableLangpacks
(
)
;
if
(
!
availableLangpacks
)
{
return
nullResult
;
}
const
langPack
=
availableLangpacks
.
find
(
(
{
target_locale
}
)
=
>
target_locale
=
=
=
localeInfo
.
systemLocale
.
baseName
)
|
|
availableLangpacks
.
find
(
(
{
target_locale
}
)
=
>
target_locale
=
=
=
localeInfo
.
systemLocale
.
language
)
|
|
availableLangpacks
.
find
(
(
{
target_locale
}
)
=
>
target_locale
.
startsWith
(
{
localeInfo
.
systemLocale
.
language
}
-
)
)
|
|
null
;
if
(
!
langPack
)
{
return
nullResult
;
}
return
{
langPack
langPackDisplayName
:
Services
.
intl
.
getLocaleDisplayNames
(
undefined
[
langPack
.
target_locale
]
{
preferNative
:
true
}
)
[
0
]
}
;
}
let
installingLangpack
=
new
Map
(
)
;
function
ensureLangPackInstalled
(
langPack
)
{
if
(
!
langPack
)
{
throw
new
Error
(
"
Expected
a
LangPack
to
install
.
"
)
;
}
const
inProgress
=
installingLangpack
.
get
(
langPack
.
hash
)
;
if
(
inProgress
)
{
return
inProgress
;
}
const
promise
=
_ensureLangPackInstalledImpl
(
langPack
)
;
installingLangpack
.
set
(
langPack
.
hash
promise
)
;
promise
.
finally
(
(
)
=
>
{
installingLangpack
.
delete
(
langPack
.
hash
)
;
}
)
;
return
promise
;
}
async
function
_ensureLangPackInstalledImpl
(
langPack
)
{
if
(
mockable
.
getAvailableLocales
(
)
.
includes
(
langPack
.
target_locale
)
)
{
return
true
;
}
return
mockable
.
installLangPack
(
langPack
)
;
}
const
mockable
=
{
async
getAvailableLangpacks
(
)
{
try
{
return
AddonRepository
.
getAvailableLangpacks
(
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
Failed
to
get
the
list
of
available
language
packs
:
{
error
?
.
message
}
)
;
return
null
;
}
}
async
installLangPack
(
langPack
)
{
let
install
;
try
{
install
=
await
AddonManager
.
getInstallForURL
(
langPack
.
url
{
hash
:
langPack
.
hash
telemetryInfo
:
{
source
:
"
about
:
welcome
"
}
}
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
return
false
;
}
try
{
await
install
.
install
(
)
;
}
catch
(
error
)
{
Cu
.
reportError
(
error
)
;
return
false
;
}
return
true
;
}
getAvailableLocales
(
)
{
return
Services
.
locale
.
availableLocales
;
}
getAppLocaleAsBCP47
(
)
{
return
Services
.
locale
.
appLocaleAsBCP47
;
}
getSystemLocale
(
)
{
const
systemLocaleOverride
=
Services
.
prefs
.
getCharPref
(
"
intl
.
multilingual
.
aboutWelcome
.
systemLocaleOverride
"
null
)
;
if
(
systemLocaleOverride
)
{
try
{
new
Services
.
intl
.
Locale
(
systemLocaleOverride
)
;
return
systemLocaleOverride
;
}
catch
(
_error
)
{
}
}
const
osPrefs
=
Cc
[
"
mozilla
.
org
/
intl
/
ospreferences
;
1
"
]
.
getService
(
Ci
.
mozIOSPreferences
)
;
return
osPrefs
.
systemLocale
;
}
setRequestedAppLocales
(
locales
)
{
Services
.
locale
.
requestedLocales
=
locales
;
}
}
;
function
setRequestedAppLocales
(
locales
)
{
mockable
.
setRequestedAppLocales
(
locales
)
;
}
function
getStructuredLocaleOrNull
(
localeString
)
{
try
{
const
locale
=
new
Services
.
intl
.
Locale
(
localeString
)
;
return
{
baseName
:
locale
.
baseName
language
:
locale
.
language
region
:
locale
.
region
}
;
}
catch
(
_err
)
{
return
null
;
}
}
function
getAppAndSystemLocaleInfo
(
)
{
const
systemLocaleRaw
=
mockable
.
getSystemLocale
(
)
;
const
appLocaleRaw
=
mockable
.
getAppLocaleAsBCP47
(
)
;
const
systemLocale
=
getStructuredLocaleOrNull
(
systemLocaleRaw
)
;
const
appLocale
=
getStructuredLocaleOrNull
(
appLocaleRaw
)
;
let
matchType
=
"
unknown
"
;
if
(
systemLocale
&
&
appLocale
)
{
if
(
systemLocale
.
language
!
=
=
appLocale
.
language
)
{
matchType
=
"
language
-
mismatch
"
;
}
else
if
(
systemLocale
.
region
!
=
=
appLocale
.
region
)
{
matchType
=
"
region
-
mismatch
"
;
}
else
{
matchType
=
"
match
"
;
}
}
let
canLiveReload
=
null
;
if
(
systemLocale
&
&
appLocale
)
{
const
systemDirection
=
Services
.
intl
.
getScriptDirection
(
systemLocale
.
language
)
;
const
appDirection
=
Services
.
intl
.
getScriptDirection
(
appLocale
.
language
)
;
const
supportsBidiSwitching
=
Services
.
prefs
.
getBoolPref
(
"
intl
.
multilingual
.
liveReloadBidirectional
"
false
)
;
canLiveReload
=
systemDirection
=
=
=
appDirection
|
|
supportsBidiSwitching
;
}
return
{
systemLocaleRaw
systemLocale
appLocaleRaw
appLocale
matchType
canLiveReload
displayNames
:
{
systemLanguage
:
systemLocale
?
Services
.
intl
.
getLocaleDisplayNames
(
undefined
[
systemLocale
.
baseName
]
{
preferNative
:
true
}
)
[
0
]
:
null
appLanguage
:
appLocale
?
Services
.
intl
.
getLocaleDisplayNames
(
undefined
[
appLocale
.
baseName
]
{
preferNative
:
true
}
)
[
0
]
:
null
}
}
;
}
var
LangPackMatcher
=
{
negotiateLangPackForLanguageMismatch
ensureLangPackInstalled
getAppAndSystemLocaleInfo
setRequestedAppLocales
mockable
}
;
var
EXPORTED_SYMBOLS
=
[
"
LangPackMatcher
"
]
;
