#
include
"
OSPreferences
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
unicode
/
udat
.
h
"
#
include
"
unicode
/
udatpg
.
h
"
using
namespace
mozilla
:
:
intl
;
NS_IMPL_ISUPPORTS
(
OSPreferences
mozIOSPreferences
)
mozilla
:
:
StaticRefPtr
<
OSPreferences
>
OSPreferences
:
:
sInstance
;
OSPreferences
*
OSPreferences
:
:
GetInstance
(
)
{
if
(
!
sInstance
)
{
sInstance
=
new
OSPreferences
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
}
return
sInstance
;
}
bool
OSPreferences
:
:
GetSystemLocales
(
nsTArray
<
nsCString
>
&
aRetVal
)
{
if
(
!
mSystemLocales
.
IsEmpty
(
)
)
{
aRetVal
=
mSystemLocales
;
return
true
;
}
if
(
ReadSystemLocales
(
aRetVal
)
)
{
mSystemLocales
=
aRetVal
;
return
true
;
}
aRetVal
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
en
-
US
"
)
)
;
return
false
;
}
bool
OSPreferences
:
:
GetRegionalPrefsLocales
(
nsTArray
<
nsCString
>
&
aRetVal
)
{
if
(
!
mRegionalPrefsLocales
.
IsEmpty
(
)
)
{
aRetVal
=
mRegionalPrefsLocales
;
return
true
;
}
if
(
ReadRegionalPrefsLocales
(
aRetVal
)
)
{
mRegionalPrefsLocales
=
aRetVal
;
return
true
;
}
return
false
;
}
void
OSPreferences
:
:
Refresh
(
)
{
nsTArray
<
nsCString
>
newLocales
;
ReadSystemLocales
(
newLocales
)
;
if
(
mSystemLocales
!
=
newLocales
)
{
mSystemLocales
=
std
:
:
move
(
newLocales
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
intl
:
system
-
locales
-
changed
"
nullptr
)
;
}
}
}
bool
OSPreferences
:
:
CanonicalizeLanguageTag
(
nsCString
&
aLoc
)
{
char
langTag
[
512
]
;
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
langTagLen
=
uloc_toLanguageTag
(
aLoc
.
get
(
)
langTag
sizeof
(
langTag
)
-
1
false
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
aLoc
.
Assign
(
langTag
langTagLen
)
;
return
true
;
}
bool
OSPreferences
:
:
GetDateTimePatternForStyle
(
DateTimeFormatStyle
aDateStyle
DateTimeFormatStyle
aTimeStyle
const
nsACString
&
aLocale
nsAString
&
aRetVal
)
{
UDateFormatStyle
timeStyle
=
UDAT_NONE
;
UDateFormatStyle
dateStyle
=
UDAT_NONE
;
switch
(
aTimeStyle
)
{
case
DateTimeFormatStyle
:
:
None
:
timeStyle
=
UDAT_NONE
;
break
;
case
DateTimeFormatStyle
:
:
Short
:
timeStyle
=
UDAT_SHORT
;
break
;
case
DateTimeFormatStyle
:
:
Medium
:
timeStyle
=
UDAT_MEDIUM
;
break
;
case
DateTimeFormatStyle
:
:
Long
:
timeStyle
=
UDAT_LONG
;
break
;
case
DateTimeFormatStyle
:
:
Full
:
timeStyle
=
UDAT_FULL
;
break
;
case
DateTimeFormatStyle
:
:
Invalid
:
timeStyle
=
UDAT_NONE
;
break
;
}
switch
(
aDateStyle
)
{
case
DateTimeFormatStyle
:
:
None
:
dateStyle
=
UDAT_NONE
;
break
;
case
DateTimeFormatStyle
:
:
Short
:
dateStyle
=
UDAT_SHORT
;
break
;
case
DateTimeFormatStyle
:
:
Medium
:
dateStyle
=
UDAT_MEDIUM
;
break
;
case
DateTimeFormatStyle
:
:
Long
:
dateStyle
=
UDAT_LONG
;
break
;
case
DateTimeFormatStyle
:
:
Full
:
dateStyle
=
UDAT_FULL
;
break
;
case
DateTimeFormatStyle
:
:
Invalid
:
dateStyle
=
UDAT_NONE
;
break
;
}
const
int32_t
kPatternMax
=
160
;
UChar
pattern
[
kPatternMax
]
;
nsAutoCString
locale
;
if
(
aLocale
.
IsEmpty
(
)
)
{
AutoTArray
<
nsCString
10
>
regionalPrefsLocales
;
LocaleService
:
:
GetInstance
(
)
-
>
GetRegionalPrefsLocales
(
regionalPrefsLocales
)
;
locale
.
Assign
(
regionalPrefsLocales
[
0
]
)
;
}
else
{
locale
.
Assign
(
aLocale
)
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
UDateFormat
*
df
=
udat_open
(
timeStyle
dateStyle
locale
.
get
(
)
nullptr
-
1
nullptr
-
1
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
int32_t
patsize
=
udat_toPattern
(
df
false
pattern
kPatternMax
&
status
)
;
udat_close
(
df
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
aRetVal
.
Assign
(
(
const
char16_t
*
)
pattern
patsize
)
;
return
true
;
}
bool
OSPreferences
:
:
GetDateTimeSkeletonForStyle
(
DateTimeFormatStyle
aDateStyle
DateTimeFormatStyle
aTimeStyle
const
nsACString
&
aLocale
nsAString
&
aRetVal
)
{
nsAutoString
pattern
;
if
(
!
GetDateTimePatternForStyle
(
aDateStyle
aTimeStyle
aLocale
pattern
)
)
{
return
false
;
}
const
int32_t
kSkeletonMax
=
160
;
UChar
skeleton
[
kSkeletonMax
]
;
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
skelsize
=
udatpg_getSkeleton
(
nullptr
(
const
UChar
*
)
pattern
.
BeginReading
(
)
pattern
.
Length
(
)
skeleton
kSkeletonMax
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
aRetVal
.
Assign
(
(
const
char16_t
*
)
skeleton
skelsize
)
;
return
true
;
}
bool
OSPreferences
:
:
GetPatternForSkeleton
(
const
nsAString
&
aSkeleton
const
nsACString
&
aLocale
nsAString
&
aRetVal
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UDateTimePatternGenerator
*
pg
=
udatpg_open
(
PromiseFlatCString
(
aLocale
)
.
get
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
int32_t
len
=
udatpg_getBestPattern
(
pg
(
const
UChar
*
)
aSkeleton
.
BeginReading
(
)
aSkeleton
.
Length
(
)
nullptr
0
&
status
)
;
if
(
status
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
aRetVal
.
SetLength
(
len
)
;
status
=
U_ZERO_ERROR
;
udatpg_getBestPattern
(
pg
(
const
UChar
*
)
aSkeleton
.
BeginReading
(
)
aSkeleton
.
Length
(
)
(
UChar
*
)
aRetVal
.
BeginWriting
(
)
len
&
status
)
;
}
udatpg_close
(
pg
)
;
return
U_SUCCESS
(
status
)
;
}
bool
OSPreferences
:
:
GetDateTimeConnectorPattern
(
const
nsACString
&
aLocale
nsAString
&
aRetVal
)
{
bool
result
=
false
;
UErrorCode
status
=
U_ZERO_ERROR
;
UDateTimePatternGenerator
*
pg
=
udatpg_open
(
PromiseFlatCString
(
aLocale
)
.
get
(
)
&
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
int32_t
resultSize
;
const
UChar
*
value
=
udatpg_getDateTimeFormat
(
pg
&
resultSize
)
;
MOZ_ASSERT
(
resultSize
>
=
0
)
;
aRetVal
.
Assign
(
(
char16_t
*
)
value
resultSize
)
;
result
=
true
;
}
udatpg_close
(
pg
)
;
return
result
;
}
NS_IMETHODIMP
OSPreferences
:
:
GetSystemLocales
(
uint32_t
*
aCount
char
*
*
*
aOutArray
)
{
AutoTArray
<
nsCString
10
>
tempLocales
;
nsTArray
<
nsCString
>
*
systemLocalesPtr
;
if
(
!
mSystemLocales
.
IsEmpty
(
)
)
{
systemLocalesPtr
=
&
mSystemLocales
;
}
else
{
GetSystemLocales
(
tempLocales
)
;
systemLocalesPtr
=
&
tempLocales
;
}
*
aCount
=
systemLocalesPtr
-
>
Length
(
)
;
*
aOutArray
=
static_cast
<
char
*
*
>
(
moz_xmalloc
(
*
aCount
*
sizeof
(
char
*
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
*
aCount
;
i
+
+
)
{
(
*
aOutArray
)
[
i
]
=
moz_xstrdup
(
(
*
systemLocalesPtr
)
[
i
]
.
get
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
OSPreferences
:
:
GetSystemLocale
(
nsACString
&
aRetVal
)
{
if
(
!
mSystemLocales
.
IsEmpty
(
)
)
{
aRetVal
=
mSystemLocales
[
0
]
;
}
else
{
AutoTArray
<
nsCString
10
>
locales
;
GetSystemLocales
(
locales
)
;
if
(
!
locales
.
IsEmpty
(
)
)
{
aRetVal
=
locales
[
0
]
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
OSPreferences
:
:
GetRegionalPrefsLocales
(
uint32_t
*
aCount
char
*
*
*
aOutArray
)
{
AutoTArray
<
nsCString
10
>
tempLocales
;
nsTArray
<
nsCString
>
*
regionalPrefsLocalesPtr
;
if
(
!
mRegionalPrefsLocales
.
IsEmpty
(
)
)
{
regionalPrefsLocalesPtr
=
&
mRegionalPrefsLocales
;
}
else
{
GetRegionalPrefsLocales
(
tempLocales
)
;
regionalPrefsLocalesPtr
=
&
tempLocales
;
}
*
aCount
=
regionalPrefsLocalesPtr
-
>
Length
(
)
;
*
aOutArray
=
static_cast
<
char
*
*
>
(
moz_xmalloc
(
*
aCount
*
sizeof
(
char
*
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
*
aCount
;
i
+
+
)
{
(
*
aOutArray
)
[
i
]
=
moz_xstrdup
(
(
*
regionalPrefsLocalesPtr
)
[
i
]
.
get
(
)
)
;
}
return
NS_OK
;
}
static
OSPreferences
:
:
DateTimeFormatStyle
ToDateTimeFormatStyle
(
int32_t
aTimeFormat
)
{
switch
(
aTimeFormat
)
{
case
0
:
return
OSPreferences
:
:
DateTimeFormatStyle
:
:
None
;
case
1
:
return
OSPreferences
:
:
DateTimeFormatStyle
:
:
Short
;
case
2
:
return
OSPreferences
:
:
DateTimeFormatStyle
:
:
Medium
;
case
3
:
return
OSPreferences
:
:
DateTimeFormatStyle
:
:
Long
;
case
4
:
return
OSPreferences
:
:
DateTimeFormatStyle
:
:
Full
;
}
return
OSPreferences
:
:
DateTimeFormatStyle
:
:
Invalid
;
}
NS_IMETHODIMP
OSPreferences
:
:
GetDateTimePattern
(
int32_t
aDateFormatStyle
int32_t
aTimeFormatStyle
const
nsACString
&
aLocale
nsAString
&
aRetVal
)
{
DateTimeFormatStyle
dateStyle
=
ToDateTimeFormatStyle
(
aDateFormatStyle
)
;
if
(
dateStyle
=
=
DateTimeFormatStyle
:
:
Invalid
)
{
return
NS_ERROR_INVALID_ARG
;
}
DateTimeFormatStyle
timeStyle
=
ToDateTimeFormatStyle
(
aTimeFormatStyle
)
;
if
(
timeStyle
=
=
DateTimeFormatStyle
:
:
Invalid
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
timeStyle
=
=
DateTimeFormatStyle
:
:
None
&
&
dateStyle
=
=
DateTimeFormatStyle
:
:
None
)
{
return
NS_OK
;
}
if
(
!
ReadDateTimePattern
(
dateStyle
timeStyle
aLocale
aRetVal
)
)
{
if
(
!
GetDateTimePatternForStyle
(
dateStyle
timeStyle
aLocale
aRetVal
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
