#
include
"
LocaleService
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
intl
/
OSPreferences
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsStringEnumerator
.
h
"
#
include
"
nsIToolkitChromeRegistry
.
h
"
#
ifdef
ENABLE_INTL_API
#
include
"
unicode
/
uloc
.
h
"
#
endif
#
define
MATCH_OS_LOCALE_PREF
"
intl
.
locale
.
matchOS
"
#
define
SELECTED_LOCALE_PREF
"
general
.
useragent
.
locale
"
static
const
char
*
kObservedPrefs
[
]
=
{
MATCH_OS_LOCALE_PREF
SELECTED_LOCALE_PREF
nullptr
}
;
using
namespace
mozilla
:
:
intl
;
NS_IMPL_ISUPPORTS
(
LocaleService
mozILocaleService
nsIObserver
)
mozilla
:
:
StaticRefPtr
<
LocaleService
>
LocaleService
:
:
sInstance
;
static
void
SanitizeForBCP47
(
nsACString
&
aLocale
)
{
#
ifdef
ENABLE_INTL_API
const
int32_t
LANG_TAG_CAPACITY
=
128
;
char
langTag
[
LANG_TAG_CAPACITY
]
;
nsAutoCString
locale
(
aLocale
)
;
UErrorCode
err
=
U_ZERO_ERROR
;
int32_t
len
=
uloc_toLanguageTag
(
locale
.
get
(
)
langTag
LANG_TAG_CAPACITY
false
&
err
)
;
if
(
U_SUCCESS
(
err
)
&
&
len
>
0
)
{
aLocale
.
Assign
(
langTag
len
)
;
}
#
else
if
(
aLocale
.
EqualsLiteral
(
"
ja
-
JP
-
mac
"
)
)
{
aLocale
.
AssignLiteral
(
"
ja
-
JP
"
)
;
}
#
endif
}
static
void
ReadAppLocales
(
nsTArray
<
nsCString
>
&
aRetVal
)
{
nsAutoCString
uaLangTag
;
nsCOMPtr
<
nsIToolkitChromeRegistry
>
cr
=
mozilla
:
:
services
:
:
GetToolkitChromeRegistryService
(
)
;
if
(
cr
)
{
cr
-
>
GetSelectedLocale
(
NS_LITERAL_CSTRING
(
"
global
"
)
false
uaLangTag
)
;
}
if
(
!
uaLangTag
.
IsEmpty
(
)
)
{
aRetVal
.
AppendElement
(
uaLangTag
)
;
}
if
(
!
uaLangTag
.
EqualsLiteral
(
"
en
-
US
"
)
)
{
aRetVal
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
en
-
US
"
)
)
;
}
}
LocaleService
*
LocaleService
:
:
GetInstance
(
)
{
if
(
!
sInstance
)
{
sInstance
=
new
LocaleService
(
)
;
DebugOnly
<
nsresult
>
rv
=
Preferences
:
:
AddStrongObservers
(
sInstance
kObservedPrefs
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Adding
observers
failed
.
"
)
;
ClearOnShutdown
(
&
sInstance
)
;
}
return
sInstance
;
}
LocaleService
:
:
~
LocaleService
(
)
{
Preferences
:
:
RemoveObservers
(
sInstance
kObservedPrefs
)
;
}
void
LocaleService
:
:
GetAppLocalesAsLangTags
(
nsTArray
<
nsCString
>
&
aRetVal
)
{
if
(
mAppLocales
.
IsEmpty
(
)
)
{
ReadAppLocales
(
mAppLocales
)
;
}
aRetVal
=
mAppLocales
;
}
void
LocaleService
:
:
GetAppLocalesAsBCP47
(
nsTArray
<
nsCString
>
&
aRetVal
)
{
if
(
mAppLocales
.
IsEmpty
(
)
)
{
ReadAppLocales
(
mAppLocales
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mAppLocales
.
Length
(
)
;
i
+
+
)
{
nsAutoCString
locale
(
mAppLocales
[
i
]
)
;
SanitizeForBCP47
(
locale
)
;
aRetVal
.
AppendElement
(
locale
)
;
}
}
bool
LocaleService
:
:
GetRequestedLocales
(
nsTArray
<
nsCString
>
&
aRetVal
)
{
nsAutoCString
locale
;
bool
matchOSLocale
=
Preferences
:
:
GetBool
(
MATCH_OS_LOCALE_PREF
)
;
if
(
matchOSLocale
)
{
if
(
OSPreferences
:
:
GetInstance
(
)
-
>
GetSystemLocales
(
aRetVal
)
)
{
return
true
;
}
}
if
(
!
NS_SUCCEEDED
(
Preferences
:
:
GetLocalizedCString
(
SELECTED_LOCALE_PREF
&
locale
)
)
)
{
if
(
!
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
SELECTED_LOCALE_PREF
&
locale
)
)
)
{
return
false
;
}
}
aRetVal
.
AppendElement
(
locale
)
;
return
true
;
}
bool
LocaleService
:
:
GetAvailableLocales
(
nsTArray
<
nsCString
>
&
aRetVal
)
{
nsCOMPtr
<
nsIToolkitChromeRegistry
>
cr
=
mozilla
:
:
services
:
:
GetToolkitChromeRegistryService
(
)
;
nsCOMPtr
<
nsIUTF8StringEnumerator
>
localesEnum
;
nsresult
rv
=
cr
-
>
GetLocalesForPackage
(
NS_LITERAL_CSTRING
(
"
global
"
)
getter_AddRefs
(
localesEnum
)
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
return
false
;
}
bool
more
;
while
(
NS_SUCCEEDED
(
rv
=
localesEnum
-
>
HasMore
(
&
more
)
)
&
&
more
)
{
nsAutoCString
localeStr
;
rv
=
localesEnum
-
>
GetNext
(
localeStr
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
return
false
;
}
aRetVal
.
AppendElement
(
localeStr
)
;
}
return
!
aRetVal
.
IsEmpty
(
)
;
}
void
LocaleService
:
:
Refresh
(
)
{
nsTArray
<
nsCString
>
newLocales
;
ReadAppLocales
(
newLocales
)
;
if
(
mAppLocales
!
=
newLocales
)
{
mAppLocales
=
Move
(
newLocales
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
intl
:
app
-
locales
-
changed
"
nullptr
)
;
}
}
}
#
define
HANDLE_STRATEGY
\
switch
(
aStrategy
)
{
\
case
LangNegStrategy
:
:
Lookup
:
\
return
;
\
case
LangNegStrategy
:
:
Matching
:
\
continue
;
\
case
LangNegStrategy
:
:
Filtering
:
\
break
;
\
}
void
LocaleService
:
:
FilterMatches
(
const
nsTArray
<
nsCString
>
&
aRequested
const
nsTArray
<
nsCString
>
&
aAvailable
LangNegStrategy
aStrategy
nsTArray
<
nsCString
>
&
aRetVal
)
{
AutoTArray
<
Locale
100
>
availLocales
;
for
(
auto
&
avail
:
aAvailable
)
{
availLocales
.
AppendElement
(
Locale
(
avail
true
)
)
;
}
auto
eraseFromAvail
=
[
&
]
(
nsTArray
<
Locale
>
:
:
iterator
aIter
)
{
nsTArray
<
Locale
>
:
:
size_type
index
=
aIter
-
availLocales
.
begin
(
)
;
availLocales
.
RemoveElementAt
(
index
)
;
return
availLocales
.
begin
(
)
+
index
;
}
;
for
(
auto
&
requested
:
aRequested
)
{
auto
matchesExactly
=
[
&
]
(
const
Locale
&
aLoc
)
{
return
requested
.
Equals
(
aLoc
.
AsString
(
)
nsCaseInsensitiveCStringComparator
(
)
)
;
}
;
auto
match
=
std
:
:
find_if
(
availLocales
.
begin
(
)
availLocales
.
end
(
)
matchesExactly
)
;
if
(
match
!
=
availLocales
.
end
(
)
)
{
aRetVal
.
AppendElement
(
match
-
>
AsString
(
)
)
;
eraseFromAvail
(
match
)
;
}
if
(
!
aRetVal
.
IsEmpty
(
)
)
{
HANDLE_STRATEGY
;
}
auto
findRangeMatches
=
[
&
]
(
const
Locale
&
aReq
)
{
auto
matchesRange
=
[
&
]
(
const
Locale
&
aLoc
)
{
return
aReq
.
Matches
(
aLoc
)
;
}
;
bool
foundMatch
=
false
;
auto
match
=
availLocales
.
begin
(
)
;
while
(
(
match
=
std
:
:
find_if
(
match
availLocales
.
end
(
)
matchesRange
)
)
!
=
availLocales
.
end
(
)
)
{
aRetVal
.
AppendElement
(
match
-
>
AsString
(
)
)
;
match
=
eraseFromAvail
(
match
)
;
foundMatch
=
true
;
if
(
aStrategy
!
=
LangNegStrategy
:
:
Filtering
)
{
return
true
;
}
}
return
foundMatch
;
}
;
Locale
requestedLocale
=
Locale
(
requested
false
)
;
if
(
findRangeMatches
(
requestedLocale
)
)
{
HANDLE_STRATEGY
;
}
if
(
requestedLocale
.
AddLikelySubtags
(
)
)
{
if
(
findRangeMatches
(
requestedLocale
)
)
{
HANDLE_STRATEGY
;
}
}
requestedLocale
.
SetVariantRange
(
)
;
if
(
findRangeMatches
(
requestedLocale
)
)
{
HANDLE_STRATEGY
;
}
requestedLocale
.
SetRegionRange
(
)
;
if
(
findRangeMatches
(
requestedLocale
)
)
{
HANDLE_STRATEGY
;
}
}
}
bool
LocaleService
:
:
NegotiateLanguages
(
const
nsTArray
<
nsCString
>
&
aRequested
const
nsTArray
<
nsCString
>
&
aAvailable
const
nsACString
&
aDefaultLocale
LangNegStrategy
aStrategy
nsTArray
<
nsCString
>
&
aRetVal
)
{
if
(
aStrategy
=
=
LangNegStrategy
:
:
Lookup
&
&
aDefaultLocale
.
IsEmpty
(
)
)
{
return
false
;
}
FilterMatches
(
aRequested
aAvailable
aStrategy
aRetVal
)
;
if
(
aStrategy
=
=
LangNegStrategy
:
:
Lookup
)
{
if
(
aRetVal
.
Length
(
)
=
=
0
)
{
aRetVal
.
AppendElement
(
aDefaultLocale
)
;
}
}
else
if
(
!
aDefaultLocale
.
IsEmpty
(
)
&
&
!
aRetVal
.
Contains
(
aDefaultLocale
)
)
{
aRetVal
.
AppendElement
(
aDefaultLocale
)
;
}
return
true
;
}
NS_IMETHODIMP
LocaleService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
NS_ConvertUTF16toUTF8
pref
(
aData
)
;
if
(
pref
.
EqualsLiteral
(
MATCH_OS_LOCALE_PREF
)
|
|
pref
.
EqualsLiteral
(
SELECTED_LOCALE_PREF
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
intl
:
requested
-
locales
-
changed
"
nullptr
)
;
}
}
return
NS_OK
;
}
static
char
*
*
CreateOutArray
(
const
nsTArray
<
nsCString
>
&
aArray
)
{
uint32_t
n
=
aArray
.
Length
(
)
;
char
*
*
result
=
static_cast
<
char
*
*
>
(
moz_xmalloc
(
n
*
sizeof
(
char
*
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
n
;
i
+
+
)
{
result
[
i
]
=
moz_xstrdup
(
aArray
[
i
]
.
get
(
)
)
;
}
return
result
;
}
NS_IMETHODIMP
LocaleService
:
:
GetDefaultLocale
(
nsACString
&
aRetVal
)
{
aRetVal
.
AssignLiteral
(
"
en
-
US
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
LocaleService
:
:
GetAppLocalesAsLangTags
(
uint32_t
*
aCount
char
*
*
*
aOutArray
)
{
if
(
mAppLocales
.
IsEmpty
(
)
)
{
ReadAppLocales
(
mAppLocales
)
;
}
*
aCount
=
mAppLocales
.
Length
(
)
;
*
aOutArray
=
CreateOutArray
(
mAppLocales
)
;
return
NS_OK
;
}
NS_IMETHODIMP
LocaleService
:
:
GetAppLocalesAsBCP47
(
uint32_t
*
aCount
char
*
*
*
aOutArray
)
{
AutoTArray
<
nsCString
32
>
locales
;
GetAppLocalesAsBCP47
(
locales
)
;
*
aCount
=
locales
.
Length
(
)
;
*
aOutArray
=
CreateOutArray
(
locales
)
;
return
NS_OK
;
}
NS_IMETHODIMP
LocaleService
:
:
GetAppLocaleAsLangTag
(
nsACString
&
aRetVal
)
{
if
(
mAppLocales
.
IsEmpty
(
)
)
{
ReadAppLocales
(
mAppLocales
)
;
}
aRetVal
=
mAppLocales
[
0
]
;
return
NS_OK
;
}
NS_IMETHODIMP
LocaleService
:
:
GetAppLocaleAsBCP47
(
nsACString
&
aRetVal
)
{
if
(
mAppLocales
.
IsEmpty
(
)
)
{
ReadAppLocales
(
mAppLocales
)
;
}
aRetVal
=
mAppLocales
[
0
]
;
SanitizeForBCP47
(
aRetVal
)
;
return
NS_OK
;
}
static
LocaleService
:
:
LangNegStrategy
ToLangNegStrategy
(
int32_t
aStrategy
)
{
switch
(
aStrategy
)
{
case
1
:
return
LocaleService
:
:
LangNegStrategy
:
:
Matching
;
case
2
:
return
LocaleService
:
:
LangNegStrategy
:
:
Lookup
;
default
:
return
LocaleService
:
:
LangNegStrategy
:
:
Filtering
;
}
}
NS_IMETHODIMP
LocaleService
:
:
NegotiateLanguages
(
const
char
*
*
aRequested
const
char
*
*
aAvailable
const
char
*
aDefaultLocale
int32_t
aStrategy
uint32_t
aRequestedCount
uint32_t
aAvailableCount
uint32_t
*
aCount
char
*
*
*
aRetVal
)
{
if
(
aStrategy
<
0
|
|
aStrategy
>
2
)
{
return
NS_ERROR_INVALID_ARG
;
}
auto
validTagChars
=
[
]
(
const
char
*
s
)
{
if
(
!
s
|
|
!
*
s
)
{
return
false
;
}
while
(
*
s
)
{
if
(
isalnum
(
(
unsigned
char
)
*
s
)
|
|
*
s
=
=
'
-
'
|
|
*
s
=
=
'
_
'
|
|
*
s
=
=
'
*
'
)
{
s
+
+
;
}
else
{
return
false
;
}
}
return
true
;
}
;
AutoTArray
<
nsCString
100
>
requestedLocales
;
for
(
uint32_t
i
=
0
;
i
<
aRequestedCount
;
i
+
+
)
{
if
(
!
validTagChars
(
aRequested
[
i
]
)
)
{
continue
;
}
requestedLocales
.
AppendElement
(
aRequested
[
i
]
)
;
}
AutoTArray
<
nsCString
100
>
availableLocales
;
for
(
uint32_t
i
=
0
;
i
<
aAvailableCount
;
i
+
+
)
{
if
(
!
validTagChars
(
aAvailable
[
i
]
)
)
{
continue
;
}
availableLocales
.
AppendElement
(
aAvailable
[
i
]
)
;
}
nsAutoCString
defaultLocale
(
aDefaultLocale
)
;
LangNegStrategy
strategy
=
ToLangNegStrategy
(
aStrategy
)
;
AutoTArray
<
nsCString
100
>
supportedLocales
;
bool
result
=
NegotiateLanguages
(
requestedLocales
availableLocales
defaultLocale
strategy
supportedLocales
)
;
if
(
!
result
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aRetVal
=
static_cast
<
char
*
*
>
(
moz_xmalloc
(
sizeof
(
char
*
)
*
supportedLocales
.
Length
(
)
)
)
;
*
aCount
=
0
;
for
(
const
auto
&
supported
:
supportedLocales
)
{
(
*
aRetVal
)
[
(
*
aCount
)
+
+
]
=
moz_xstrdup
(
supported
.
get
(
)
)
;
}
return
NS_OK
;
}
LocaleService
:
:
Locale
:
:
Locale
(
const
nsCString
&
aLocale
bool
aRange
)
:
mLocaleStr
(
aLocale
)
{
int32_t
partNum
=
0
;
nsAutoCString
normLocale
(
aLocale
)
;
normLocale
.
ReplaceChar
(
'
_
'
'
-
'
)
;
for
(
const
nsCSubstring
&
part
:
normLocale
.
Split
(
'
-
'
)
)
{
switch
(
partNum
)
{
case
0
:
if
(
part
.
EqualsLiteral
(
"
*
"
)
|
|
part
.
Length
(
)
=
=
2
|
|
part
.
Length
(
)
=
=
3
)
{
mLanguage
.
Assign
(
part
)
;
}
break
;
case
1
:
if
(
part
.
EqualsLiteral
(
"
*
"
)
|
|
part
.
Length
(
)
=
=
4
)
{
mScript
.
Assign
(
part
)
;
break
;
}
partNum
+
+
;
MOZ_FALLTHROUGH
;
case
2
:
if
(
part
.
EqualsLiteral
(
"
*
"
)
|
|
part
.
Length
(
)
=
=
2
)
{
mRegion
.
Assign
(
part
)
;
}
break
;
case
3
:
if
(
part
.
EqualsLiteral
(
"
*
"
)
|
|
part
.
Length
(
)
=
=
3
)
{
mVariant
.
Assign
(
part
)
;
}
break
;
}
partNum
+
+
;
}
if
(
aRange
)
{
if
(
mLanguage
.
IsEmpty
(
)
)
{
mLanguage
.
Assign
(
NS_LITERAL_CSTRING
(
"
*
"
)
)
;
}
if
(
mScript
.
IsEmpty
(
)
)
{
mScript
.
Assign
(
NS_LITERAL_CSTRING
(
"
*
"
)
)
;
}
if
(
mRegion
.
IsEmpty
(
)
)
{
mRegion
.
Assign
(
NS_LITERAL_CSTRING
(
"
*
"
)
)
;
}
if
(
mVariant
.
IsEmpty
(
)
)
{
mVariant
.
Assign
(
NS_LITERAL_CSTRING
(
"
*
"
)
)
;
}
}
}
bool
LocaleService
:
:
Locale
:
:
Matches
(
const
LocaleService
:
:
Locale
&
aLocale
)
const
{
auto
subtagMatches
=
[
]
(
const
nsCString
&
aSubtag1
const
nsCString
&
aSubtag2
)
{
return
aSubtag1
.
EqualsLiteral
(
"
*
"
)
|
|
aSubtag2
.
EqualsLiteral
(
"
*
"
)
|
|
aSubtag1
.
Equals
(
aSubtag2
nsCaseInsensitiveCStringComparator
(
)
)
;
}
;
return
subtagMatches
(
mLanguage
aLocale
.
mLanguage
)
&
&
subtagMatches
(
mScript
aLocale
.
mScript
)
&
&
subtagMatches
(
mRegion
aLocale
.
mRegion
)
&
&
subtagMatches
(
mVariant
aLocale
.
mVariant
)
;
}
void
LocaleService
:
:
Locale
:
:
SetVariantRange
(
)
{
mVariant
.
AssignLiteral
(
"
*
"
)
;
}
void
LocaleService
:
:
Locale
:
:
SetRegionRange
(
)
{
mRegion
.
AssignLiteral
(
"
*
"
)
;
}
bool
LocaleService
:
:
Locale
:
:
AddLikelySubtags
(
)
{
#
ifdef
ENABLE_INTL_API
const
int32_t
kLocaleMax
=
160
;
char
maxLocale
[
kLocaleMax
]
;
UErrorCode
status
=
U_ZERO_ERROR
;
uloc_addLikelySubtags
(
mLocaleStr
.
get
(
)
maxLocale
kLocaleMax
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
nsDependentCString
maxLocStr
(
maxLocale
)
;
Locale
loc
=
Locale
(
maxLocStr
false
)
;
if
(
loc
=
=
*
this
)
{
return
false
;
}
mLanguage
=
loc
.
mLanguage
;
mScript
=
loc
.
mScript
;
mRegion
=
loc
.
mRegion
;
mVariant
=
loc
.
mVariant
;
return
true
;
#
else
return
false
;
#
endif
}
NS_IMETHODIMP
LocaleService
:
:
GetRequestedLocales
(
uint32_t
*
aCount
char
*
*
*
aOutArray
)
{
AutoTArray
<
nsCString
16
>
requestedLocales
;
bool
res
=
GetRequestedLocales
(
requestedLocales
)
;
if
(
!
res
)
{
NS_ERROR
(
"
Couldn
'
t
retrieve
selected
locales
from
prefs
!
"
)
;
return
NS_ERROR_FAILURE
;
}
*
aCount
=
requestedLocales
.
Length
(
)
;
*
aOutArray
=
CreateOutArray
(
requestedLocales
)
;
return
NS_OK
;
}
NS_IMETHODIMP
LocaleService
:
:
SetRequestedLocales
(
const
char
*
*
aRequested
uint32_t
aRequestedCount
)
{
MOZ_ASSERT
(
aRequestedCount
<
2
"
We
can
only
handle
one
requested
locale
"
)
;
if
(
aRequestedCount
=
=
0
)
{
Preferences
:
:
ClearUser
(
SELECTED_LOCALE_PREF
)
;
}
else
{
Preferences
:
:
SetCString
(
SELECTED_LOCALE_PREF
aRequested
[
0
]
)
;
}
Preferences
:
:
SetBool
(
MATCH_OS_LOCALE_PREF
aRequestedCount
=
=
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
LocaleService
:
:
GetAvailableLocales
(
uint32_t
*
aCount
char
*
*
*
aOutArray
)
{
AutoTArray
<
nsCString
100
>
availableLocales
;
bool
res
=
GetAvailableLocales
(
availableLocales
)
;
if
(
!
res
)
{
NS_ERROR
(
"
Couldn
'
t
retrieve
available
locales
!
"
)
;
return
NS_ERROR_FAILURE
;
}
*
aCount
=
availableLocales
.
Length
(
)
;
*
aOutArray
=
CreateOutArray
(
availableLocales
)
;
return
NS_OK
;
}
