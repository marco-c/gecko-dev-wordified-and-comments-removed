#
include
"
nsHyphenator
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsIJARURI
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
mapped_hyph
.
h
"
static
const
void
*
GetItemPtrFromJarURI
(
nsIJARURI
*
aJAR
uint32_t
*
aLength
)
{
nsCOMPtr
<
nsIURI
>
jarFile
;
if
(
NS_FAILED
(
aJAR
-
>
GetJARFile
(
getter_AddRefs
(
jarFile
)
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIFileURL
>
fileUrl
=
do_QueryInterface
(
jarFile
)
;
if
(
!
fileUrl
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIFile
>
file
;
fileUrl
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
!
file
)
{
return
nullptr
;
}
RefPtr
<
nsZipArchive
>
archive
=
mozilla
:
:
Omnijar
:
:
GetReader
(
file
)
;
if
(
archive
)
{
nsCString
path
;
aJAR
-
>
GetJAREntry
(
path
)
;
nsZipItem
*
item
=
archive
-
>
GetItem
(
path
.
get
(
)
)
;
if
(
item
&
&
item
-
>
Compression
(
)
=
=
0
&
&
item
-
>
Size
(
)
>
0
)
{
const
uint8_t
*
data
=
archive
-
>
GetData
(
item
)
;
if
(
data
)
{
*
aLength
=
item
-
>
Size
(
)
;
return
data
;
}
}
}
return
nullptr
;
}
nsHyphenator
:
:
nsHyphenator
(
nsIURI
*
aURI
bool
aHyphenateCapitalized
)
:
mDict
(
nullptr
)
mDictSize
(
0
)
mHyphenateCapitalized
(
aHyphenateCapitalized
)
{
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
HYPHENATION_LOAD_TIME
>
telemetry
;
nsCOMPtr
<
nsIJARURI
>
jar
=
do_QueryInterface
(
aURI
)
;
if
(
jar
)
{
mDict
=
GetItemPtrFromJarURI
(
jar
&
mDictSize
)
;
if
(
!
mDict
|
|
!
mDictSize
|
|
!
mapped_hyph_is_valid_hyphenator
(
static_cast
<
const
uint8_t
*
>
(
mDict
)
mDictSize
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
invalid
packaged
hyphenation
resource
?
"
)
;
mDict
=
nullptr
;
mDictSize
=
0
;
}
return
;
}
if
(
mozilla
:
:
net
:
:
SchemeIsFile
(
aURI
)
)
{
nsAutoCString
path
;
aURI
-
>
GetFilePath
(
path
)
;
mDict
=
mapped_hyph_load_dictionary
(
path
.
get
(
)
)
;
MOZ_ASSERT
(
mDict
"
failed
to
load
hyphenation
resource
from
file
"
)
;
return
;
}
if
(
!
mDict
)
{
MOZ_ASSERT_UNREACHABLE
(
"
invalid
hyphenation
resource
?
"
)
;
}
}
nsHyphenator
:
:
~
nsHyphenator
(
)
{
if
(
mDict
&
&
mDictSize
=
=
0
)
{
mapped_hyph_free_dictionary
(
(
HyphDic
*
)
mDict
)
;
}
}
bool
nsHyphenator
:
:
IsValid
(
)
{
return
(
mDict
!
=
nullptr
)
;
}
nsresult
nsHyphenator
:
:
Hyphenate
(
const
nsAString
&
aString
nsTArray
<
bool
>
&
aHyphens
)
{
if
(
!
aHyphens
.
SetLength
(
aString
.
Length
(
)
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
memset
(
aHyphens
.
Elements
(
)
false
aHyphens
.
Length
(
)
*
sizeof
(
bool
)
)
;
bool
inWord
=
false
;
uint32_t
wordStart
=
0
wordLimit
=
0
;
uint32_t
chLen
;
for
(
uint32_t
i
=
0
;
i
<
aString
.
Length
(
)
;
i
+
=
chLen
)
{
uint32_t
ch
=
aString
[
i
]
;
chLen
=
1
;
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
)
{
if
(
i
+
1
<
aString
.
Length
(
)
&
&
NS_IS_LOW_SURROGATE
(
aString
[
i
+
1
]
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
aString
[
i
+
1
]
)
;
chLen
=
2
;
}
else
{
NS_WARNING
(
"
unpaired
surrogate
found
during
hyphenation
"
)
;
}
}
nsUGenCategory
cat
=
mozilla
:
:
unicode
:
:
GetGenCategory
(
ch
)
;
if
(
cat
=
=
nsUGenCategory
:
:
kLetter
|
|
cat
=
=
nsUGenCategory
:
:
kMark
)
{
if
(
!
inWord
)
{
inWord
=
true
;
wordStart
=
i
;
}
wordLimit
=
i
+
chLen
;
if
(
i
+
chLen
<
aString
.
Length
(
)
)
{
continue
;
}
}
if
(
inWord
)
{
HyphenateWord
(
aString
wordStart
wordLimit
aHyphens
)
;
inWord
=
false
;
}
}
return
NS_OK
;
}
void
nsHyphenator
:
:
HyphenateWord
(
const
nsAString
&
aString
uint32_t
aStart
uint32_t
aLimit
nsTArray
<
bool
>
&
aHyphens
)
{
nsAutoCString
utf8
;
const
char16_t
*
cur
=
aString
.
BeginReading
(
)
+
aStart
;
const
char16_t
*
end
=
aString
.
BeginReading
(
)
+
aLimit
;
bool
firstLetter
=
true
;
while
(
cur
<
end
)
{
uint32_t
ch
=
*
cur
+
+
;
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
)
{
if
(
cur
<
end
&
&
NS_IS_LOW_SURROGATE
(
*
cur
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
cur
+
+
)
;
}
else
{
return
;
}
}
else
if
(
NS_IS_LOW_SURROGATE
(
ch
)
)
{
return
;
}
uint32_t
origCh
=
ch
;
ch
=
ToLowerCase
(
ch
)
;
if
(
ch
!
=
origCh
)
{
if
(
!
mHyphenateCapitalized
|
|
!
firstLetter
)
{
return
;
}
}
firstLetter
=
false
;
if
(
ch
<
0x80
)
{
utf8
.
Append
(
ch
)
;
}
else
if
(
ch
<
0x0800
)
{
utf8
.
Append
(
0xC0
|
(
ch
>
>
6
)
)
;
utf8
.
Append
(
0x80
|
(
0x003F
&
ch
)
)
;
}
else
if
(
ch
<
0x10000
)
{
utf8
.
Append
(
0xE0
|
(
ch
>
>
12
)
)
;
utf8
.
Append
(
0x80
|
(
0x003F
&
(
ch
>
>
6
)
)
)
;
utf8
.
Append
(
0x80
|
(
0x003F
&
ch
)
)
;
}
else
{
utf8
.
Append
(
0xF0
|
(
ch
>
>
18
)
)
;
utf8
.
Append
(
0x80
|
(
0x003F
&
(
ch
>
>
12
)
)
)
;
utf8
.
Append
(
0x80
|
(
0x003F
&
(
ch
>
>
6
)
)
)
;
utf8
.
Append
(
0x80
|
(
0x003F
&
ch
)
)
;
}
}
AutoTArray
<
uint8_t
200
>
hyphenValues
;
hyphenValues
.
SetLength
(
utf8
.
Length
(
)
)
;
int32_t
result
;
if
(
mDictSize
>
0
)
{
result
=
mapped_hyph_find_hyphen_values_raw
(
static_cast
<
const
uint8_t
*
>
(
mDict
)
mDictSize
utf8
.
BeginReading
(
)
utf8
.
Length
(
)
hyphenValues
.
Elements
(
)
hyphenValues
.
Length
(
)
)
;
}
else
{
result
=
mapped_hyph_find_hyphen_values_dic
(
static_cast
<
const
HyphDic
*
>
(
mDict
)
utf8
.
BeginReading
(
)
utf8
.
Length
(
)
hyphenValues
.
Elements
(
)
hyphenValues
.
Length
(
)
)
;
}
if
(
result
>
0
)
{
uint32_t
utf16index
=
0
;
for
(
uint32_t
utf8index
=
0
;
utf8index
<
utf8
.
Length
(
)
;
)
{
const
uint8_t
leadByte
=
utf8
[
utf8index
]
;
if
(
leadByte
<
0x80
)
{
utf8index
+
=
1
;
}
else
if
(
leadByte
<
0xE0
)
{
utf8index
+
=
2
;
}
else
if
(
leadByte
<
0xF0
)
{
utf8index
+
=
3
;
}
else
{
utf8index
+
=
4
;
}
utf16index
+
=
leadByte
>
=
0xF0
?
2
:
1
;
if
(
utf16index
>
0
&
&
(
hyphenValues
[
utf8index
-
1
]
&
0x01
)
)
{
aHyphens
[
aStart
+
utf16index
-
1
]
=
true
;
}
}
}
}
