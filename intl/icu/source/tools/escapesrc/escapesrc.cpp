#
include
<
stdio
.
h
>
#
include
<
string
>
#
include
<
stdlib
.
h
>
#
include
<
errno
.
h
>
#
include
<
string
.
h
>
#
include
<
iostream
>
#
include
<
fstream
>
#
include
"
unicode
/
utf8
.
h
"
#
include
"
cptbl
.
h
"
static
const
char
kSPACE
=
0x20
kTAB
=
0x09
kLF
=
0x0A
kCR
=
0x0D
;
#
define
cp1047_to_8859
(
c
)
cp1047_8859_1
[
c
]
std
:
:
string
prog
;
void
usage
(
)
{
fprintf
(
stderr
"
%
s
:
usage
:
%
s
infile
.
cpp
outfile
.
cpp
\
n
"
prog
.
c_str
(
)
prog
.
c_str
(
)
)
;
}
int
cleanup
(
const
std
:
:
string
&
outfile
)
{
const
char
*
outstr
=
outfile
.
c_str
(
)
;
if
(
outstr
&
&
*
outstr
)
{
int
rc
=
std
:
:
remove
(
outstr
)
;
if
(
rc
=
=
0
)
{
fprintf
(
stderr
"
%
s
:
deleted
%
s
\
n
"
prog
.
c_str
(
)
outstr
)
;
return
0
;
}
else
{
if
(
errno
=
=
ENOENT
)
{
return
0
;
}
else
{
perror
(
"
std
:
:
remove
"
)
;
return
1
;
}
}
}
return
0
;
}
inline
const
char
*
skipws
(
const
char
*
p
const
char
*
e
)
{
for
(
;
p
<
e
;
p
+
+
)
{
switch
(
*
p
)
{
case
kSPACE
:
case
kTAB
:
case
kLF
:
case
kCR
:
break
;
default
:
return
p
;
}
}
return
p
;
}
void
appendByte
(
std
:
:
string
&
outstr
uint8_t
byte
)
{
char
tmp2
[
5
]
;
snprintf
(
tmp2
sizeof
(
tmp2
)
"
\
\
x
%
02X
"
0xFF
&
(
int
)
(
byte
)
)
;
outstr
+
=
tmp2
;
}
bool
appendUtf8
(
std
:
:
string
&
outstr
const
std
:
:
string
&
linestr
size_t
&
pos
size_t
chars
)
{
char
tmp
[
9
]
;
for
(
size_t
i
=
0
;
i
<
chars
;
i
+
+
)
{
tmp
[
i
]
=
linestr
[
+
+
pos
]
;
}
tmp
[
chars
]
=
0
;
unsigned
int
c
;
sscanf
(
tmp
"
%
X
"
&
c
)
;
UChar32
ch
=
c
&
0x1FFFFF
;
uint8_t
bytesNeeded
=
U8_LENGTH
(
ch
)
;
if
(
bytesNeeded
=
=
0
)
{
fprintf
(
stderr
"
Illegal
code
point
U
+
%
X
\
n
"
ch
)
;
return
true
;
}
uint8_t
bytes
[
4
]
;
uint8_t
*
s
=
bytes
;
size_t
i
=
0
;
U8_APPEND_UNSAFE
(
s
i
ch
)
;
for
(
size_t
t
=
0
;
t
<
i
;
t
+
+
)
{
appendByte
(
outstr
s
[
t
]
)
;
}
return
false
;
}
bool
fixu8
(
std
:
:
string
&
linestr
size_t
origpos
size_t
&
endpos
)
{
size_t
pos
=
origpos
+
3
;
std
:
:
string
outstr
;
outstr
+
=
'
\
"
'
;
for
(
;
pos
<
endpos
;
pos
+
+
)
{
char
c
=
linestr
[
pos
]
;
if
(
c
=
=
'
\
\
'
)
{
char
c2
=
linestr
[
+
+
pos
]
;
switch
(
c2
)
{
case
'
\
'
'
:
case
'
"
'
:
#
if
(
U_CHARSET_FAMILY
=
=
U_EBCDIC_FAMILY
)
c2
=
cp1047_to_8859
(
c2
)
;
#
endif
appendByte
(
outstr
c2
)
;
break
;
case
'
u
'
:
appendUtf8
(
outstr
linestr
pos
4
)
;
break
;
case
'
U
'
:
appendUtf8
(
outstr
linestr
pos
8
)
;
break
;
}
}
else
{
#
if
(
U_CHARSET_FAMILY
=
=
U_EBCDIC_FAMILY
)
c
=
cp1047_to_8859
(
c
)
;
#
endif
appendByte
(
outstr
c
)
;
}
}
outstr
+
=
(
'
\
"
'
)
;
linestr
.
replace
(
origpos
(
endpos
-
origpos
+
1
)
outstr
)
;
return
false
;
}
bool
fixAt
(
std
:
:
string
&
linestr
size_t
pos
)
{
size_t
origpos
=
pos
;
if
(
linestr
[
pos
]
!
=
'
u
'
)
{
fprintf
(
stderr
"
Not
a
'
u
'
?
"
)
;
return
true
;
}
pos
+
+
;
bool
utf8
=
false
;
if
(
linestr
[
pos
]
=
=
'
8
'
)
{
utf8
=
true
;
pos
+
+
;
}
char
quote
=
linestr
[
pos
]
;
if
(
quote
!
=
'
\
'
'
&
&
quote
!
=
'
\
"
'
)
{
fprintf
(
stderr
"
Quote
is
'
%
c
'
-
not
sure
what
to
do
.
\
n
"
quote
)
;
return
true
;
}
if
(
quote
=
=
'
\
'
'
&
&
utf8
)
{
fprintf
(
stderr
"
Cannot
do
u8
'
.
.
.
'
\
n
"
)
;
return
true
;
}
pos
+
+
;
for
(
;
pos
<
linestr
.
size
(
)
;
pos
+
+
)
{
if
(
linestr
[
pos
]
=
=
quote
)
{
if
(
utf8
)
{
return
fixu8
(
linestr
origpos
pos
)
;
}
else
{
return
false
;
}
}
if
(
linestr
[
pos
]
=
=
'
\
\
'
)
{
pos
+
+
;
if
(
linestr
[
pos
]
=
=
quote
)
continue
;
if
(
linestr
[
pos
]
=
=
'
u
'
)
continue
;
if
(
linestr
[
pos
]
=
=
'
\
\
'
)
continue
;
}
else
{
size_t
old_pos
=
pos
;
int32_t
i
=
pos
;
#
if
(
U_CHARSET_FAMILY
=
=
U_EBCDIC_FAMILY
)
char
old_byte
=
linestr
[
pos
]
;
linestr
[
pos
]
=
cp1047_to_8859
(
linestr
[
pos
]
)
;
int32_t
trail
=
U8_COUNT_TRAIL_BYTES
(
linestr
[
pos
]
)
;
for
(
size_t
pos2
=
pos
+
1
;
trail
>
0
;
pos2
+
+
trail
-
-
)
{
linestr
[
pos2
]
=
cp1047_to_8859
(
linestr
[
pos2
]
)
;
if
(
linestr
[
pos2
]
=
=
0x0A
)
{
linestr
[
pos2
]
=
0x85
;
}
}
#
endif
const
uint8_t
*
s
=
(
const
uint8_t
*
)
(
linestr
.
c_str
(
)
)
;
int32_t
length
=
linestr
.
size
(
)
;
UChar32
c
;
if
(
U8_IS_SINGLE
(
(
uint8_t
)
s
[
i
]
)
&
&
oldIllegal
[
s
[
i
]
]
)
{
#
if
(
U_CHARSET_FAMILY
=
=
U_EBCDIC_FAMILY
)
linestr
[
pos
]
=
old_byte
;
#
endif
continue
;
}
{
U8_NEXT
(
s
i
length
c
)
;
}
if
(
c
<
0
)
{
fprintf
(
stderr
"
Illegal
utf
-
8
sequence
at
Column
:
%
d
\
n
"
(
int
)
old_pos
)
;
fprintf
(
stderr
"
Line
:
>
>
%
s
<
<
\
n
"
linestr
.
c_str
(
)
)
;
return
true
;
}
size_t
seqLen
=
(
i
-
pos
)
;
char
newSeq
[
20
]
;
if
(
c
<
=
0xFFFF
)
{
snprintf
(
newSeq
sizeof
(
newSeq
)
"
\
\
u
%
04X
"
c
)
;
}
else
{
snprintf
(
newSeq
sizeof
(
newSeq
)
"
\
\
U
%
08X
"
c
)
;
}
linestr
.
replace
(
pos
seqLen
newSeq
)
;
pos
+
=
strlen
(
newSeq
)
-
1
;
}
}
return
false
;
}
bool
fixLine
(
int
std
:
:
string
&
linestr
)
{
const
char
*
line
=
linestr
.
c_str
(
)
;
size_t
len
=
linestr
.
size
(
)
;
if
(
!
strstr
(
line
"
u
'
"
)
&
&
!
strstr
(
line
"
u
\
"
"
)
&
&
!
strstr
(
line
"
u8
\
"
"
)
)
{
return
false
;
}
size_t
pos
=
len
=
linestr
.
size
(
)
;
if
(
len
>
INT32_MAX
/
2
)
{
return
true
;
}
while
(
(
pos
>
0
)
&
&
(
pos
=
linestr
.
rfind
(
"
u
\
"
"
pos
)
)
!
=
std
:
:
string
:
:
npos
)
{
if
(
fixAt
(
linestr
pos
)
)
return
true
;
if
(
pos
=
=
0
)
break
;
pos
-
-
;
}
pos
=
len
=
linestr
.
size
(
)
;
while
(
(
pos
>
0
)
&
&
(
pos
=
linestr
.
rfind
(
"
u
'
"
pos
)
)
!
=
std
:
:
string
:
:
npos
)
{
if
(
fixAt
(
linestr
pos
)
)
return
true
;
if
(
pos
=
=
0
)
break
;
pos
-
-
;
}
pos
=
len
=
linestr
.
size
(
)
;
while
(
(
pos
>
0
)
&
&
(
pos
=
linestr
.
rfind
(
"
u8
\
"
"
pos
)
)
!
=
std
:
:
string
:
:
npos
)
{
if
(
fixAt
(
linestr
pos
)
)
return
true
;
if
(
pos
=
=
0
)
break
;
pos
-
-
;
}
return
false
;
}
int
convert
(
const
std
:
:
string
&
infile
const
std
:
:
string
&
outfile
)
{
fprintf
(
stderr
"
escapesrc
:
%
s
-
>
%
s
\
n
"
infile
.
c_str
(
)
outfile
.
c_str
(
)
)
;
std
:
:
ifstream
inf
;
inf
.
open
(
infile
.
c_str
(
)
std
:
:
ios
:
:
in
)
;
if
(
!
inf
.
is_open
(
)
)
{
fprintf
(
stderr
"
%
s
:
could
not
open
input
file
%
s
\
n
"
prog
.
c_str
(
)
infile
.
c_str
(
)
)
;
cleanup
(
outfile
)
;
return
1
;
}
std
:
:
ofstream
outf
;
outf
.
open
(
outfile
.
c_str
(
)
std
:
:
ios
:
:
out
)
;
if
(
!
outf
.
is_open
(
)
)
{
fprintf
(
stderr
"
%
s
:
could
not
open
output
file
%
s
\
n
"
prog
.
c_str
(
)
outfile
.
c_str
(
)
)
;
return
1
;
}
outf
<
<
"
#
line
1
\
"
"
<
<
infile
<
<
"
\
"
"
<
<
'
\
n
'
;
int
no
=
0
;
std
:
:
string
linestr
;
while
(
getline
(
inf
linestr
)
)
{
no
+
+
;
if
(
fixLine
(
no
linestr
)
)
{
goto
fail
;
}
outf
<
<
linestr
<
<
'
\
n
'
;
}
if
(
inf
.
eof
(
)
)
{
return
0
;
}
fail
:
outf
.
close
(
)
;
fprintf
(
stderr
"
%
s
:
%
d
:
Fixup
failed
by
%
s
\
n
"
infile
.
c_str
(
)
no
prog
.
c_str
(
)
)
;
cleanup
(
outfile
)
;
return
1
;
}
int
main
(
int
argc
const
char
*
argv
[
]
)
{
prog
=
argv
[
0
]
;
if
(
argc
!
=
3
)
{
usage
(
)
;
return
1
;
}
std
:
:
string
infile
=
argv
[
1
]
;
std
:
:
string
outfile
=
argv
[
2
]
;
return
convert
(
infile
outfile
)
;
}
