#
ifndef
__FILTERRB_H__
#
define
__FILTERRB_H__
#
include
<
list
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
ostream
>
#
include
<
string
>
#
include
"
unicode
/
utypes
.
h
"
class
ResKeyPath
{
public
:
ResKeyPath
(
)
;
ResKeyPath
(
const
std
:
:
string
&
path
UErrorCode
&
status
)
;
void
push
(
const
std
:
:
string
&
key
)
;
void
pop
(
)
;
const
std
:
:
list
<
std
:
:
string
>
&
pieces
(
)
const
;
private
:
std
:
:
list
<
std
:
:
string
>
fPath
;
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
ResKeyPath
&
value
)
;
class
PathFilter
{
public
:
enum
EInclusion
{
INCLUDE
PARTIAL
EXCLUDE
}
;
static
const
char
*
kEInclusionNames
[
]
;
virtual
~
PathFilter
(
)
;
virtual
EInclusion
match
(
const
ResKeyPath
&
path
)
const
=
0
;
}
;
class
SimpleRuleBasedPathFilter
:
public
PathFilter
{
public
:
void
addRule
(
const
std
:
:
string
&
ruleLine
UErrorCode
&
status
)
;
void
addRule
(
const
ResKeyPath
&
path
bool
inclusionRule
UErrorCode
&
status
)
;
EInclusion
match
(
const
ResKeyPath
&
path
)
const
override
;
void
print
(
std
:
:
ostream
&
out
)
const
;
private
:
struct
Tree
{
Tree
(
)
=
default
;
Tree
(
const
Tree
&
other
)
;
EInclusion
fIncluded
=
PARTIAL
;
std
:
:
map
<
std
:
:
string
Tree
>
fChildren
;
std
:
:
unique_ptr
<
Tree
>
fWildcard
;
void
applyRule
(
const
ResKeyPath
&
path
std
:
:
list
<
std
:
:
string
>
:
:
const_iterator
it
bool
inclusionRule
UErrorCode
&
status
)
;
bool
isLeaf
(
)
const
;
void
print
(
std
:
:
ostream
&
out
int32_t
indent
)
const
;
}
;
Tree
fRoot
;
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
out
const
SimpleRuleBasedPathFilter
&
value
)
;
#
endif
