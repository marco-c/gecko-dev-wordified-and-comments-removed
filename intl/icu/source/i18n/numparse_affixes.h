#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
ifndef
__NUMPARSE_AFFIXES_H__
#
define
__NUMPARSE_AFFIXES_H__
#
include
"
numparse_types
.
h
"
#
include
"
numparse_symbols
.
h
"
#
include
"
numparse_currency
.
h
"
#
include
"
number_affixutils
.
h
"
#
include
"
number_currencysymbols
.
h
"
#
include
<
array
>
U_NAMESPACE_BEGIN
namespace
numparse
{
namespace
impl
{
class
AffixPatternMatcherBuilder
;
class
AffixPatternMatcher
;
using
:
:
icu
:
:
number
:
:
impl
:
:
AffixPatternProvider
;
using
:
:
icu
:
:
number
:
:
impl
:
:
TokenConsumer
;
using
:
:
icu
:
:
number
:
:
impl
:
:
CurrencySymbols
;
class
CodePointMatcher
:
public
NumberParseMatcher
public
UMemory
{
public
:
CodePointMatcher
(
)
=
default
;
CodePointMatcher
(
UChar32
cp
)
;
bool
match
(
StringSegment
&
segment
ParsedNumber
&
result
UErrorCode
&
status
)
const
override
;
bool
smokeTest
(
const
StringSegment
&
segment
)
const
override
;
UnicodeString
toString
(
)
const
override
;
private
:
UChar32
fCp
;
}
;
}
}
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
MaybeStackArray
<
UChar
4
>
;
template
class
U_I18N_API
MaybeStackArray
<
numparse
:
:
impl
:
:
CodePointMatcher
*
3
>
;
template
class
U_I18N_API
numparse
:
:
impl
:
:
CompactUnicodeString
<
4
>
;
#
endif
namespace
numparse
{
namespace
impl
{
class
U_I18N_API
CodePointMatcherWarehouse
:
public
UMemory
{
private
:
static
constexpr
int32_t
CODE_POINT_STACK_CAPACITY
=
5
;
static
constexpr
int32_t
CODE_POINT_BATCH_SIZE
=
10
;
public
:
CodePointMatcherWarehouse
(
)
;
~
CodePointMatcherWarehouse
(
)
;
CodePointMatcherWarehouse
(
CodePointMatcherWarehouse
&
&
src
)
U_NOEXCEPT
;
CodePointMatcherWarehouse
&
operator
=
(
CodePointMatcherWarehouse
&
&
src
)
U_NOEXCEPT
;
NumberParseMatcher
&
nextCodePointMatcher
(
UChar32
cp
)
;
private
:
std
:
:
array
<
CodePointMatcher
CODE_POINT_STACK_CAPACITY
>
codePoints
;
MaybeStackArray
<
CodePointMatcher
*
3
>
codePointsOverflow
;
int32_t
codePointCount
;
int32_t
codePointNumBatches
;
}
;
struct
AffixTokenMatcherSetupData
{
const
CurrencySymbols
&
currencySymbols
;
const
DecimalFormatSymbols
&
dfs
;
IgnorablesMatcher
&
ignorables
;
const
Locale
&
locale
;
parse_flags_t
parseFlags
;
}
;
class
U_I18N_API
AffixTokenMatcherWarehouse
:
public
UMemory
{
public
:
AffixTokenMatcherWarehouse
(
)
=
default
;
AffixTokenMatcherWarehouse
(
const
AffixTokenMatcherSetupData
*
setupData
)
;
NumberParseMatcher
&
minusSign
(
)
;
NumberParseMatcher
&
plusSign
(
)
;
NumberParseMatcher
&
percent
(
)
;
NumberParseMatcher
&
permille
(
)
;
NumberParseMatcher
&
currency
(
UErrorCode
&
status
)
;
IgnorablesMatcher
&
ignorables
(
)
;
NumberParseMatcher
&
nextCodePointMatcher
(
UChar32
cp
)
;
private
:
const
AffixTokenMatcherSetupData
*
fSetupData
;
MinusSignMatcher
fMinusSign
;
PlusSignMatcher
fPlusSign
;
PercentMatcher
fPercent
;
PermilleMatcher
fPermille
;
CombinedCurrencyMatcher
fCurrency
;
CodePointMatcherWarehouse
fCodePoints
;
friend
class
AffixPatternMatcherBuilder
;
friend
class
AffixPatternMatcher
;
}
;
class
AffixPatternMatcherBuilder
:
public
TokenConsumer
public
MutableMatcherCollection
{
public
:
AffixPatternMatcherBuilder
(
const
UnicodeString
&
pattern
AffixTokenMatcherWarehouse
&
warehouse
IgnorablesMatcher
*
ignorables
)
;
void
consumeToken
(
:
:
icu
:
:
number
:
:
impl
:
:
AffixPatternType
type
UChar32
cp
UErrorCode
&
status
)
override
;
AffixPatternMatcher
build
(
)
;
private
:
ArraySeriesMatcher
:
:
MatcherArray
fMatchers
;
int32_t
fMatchersLen
;
int32_t
fLastTypeOrCp
;
const
UnicodeString
&
fPattern
;
AffixTokenMatcherWarehouse
&
fWarehouse
;
IgnorablesMatcher
*
fIgnorables
;
void
addMatcher
(
NumberParseMatcher
&
matcher
)
override
;
}
;
class
U_I18N_API
AffixPatternMatcher
:
public
ArraySeriesMatcher
{
public
:
AffixPatternMatcher
(
)
=
default
;
static
AffixPatternMatcher
fromAffixPattern
(
const
UnicodeString
&
affixPattern
AffixTokenMatcherWarehouse
&
warehouse
parse_flags_t
parseFlags
bool
*
success
UErrorCode
&
status
)
;
UnicodeString
getPattern
(
)
const
;
bool
operator
=
=
(
const
AffixPatternMatcher
&
other
)
const
;
private
:
CompactUnicodeString
<
4
>
fPattern
;
AffixPatternMatcher
(
MatcherArray
&
matchers
int32_t
matchersLen
const
UnicodeString
&
pattern
)
;
friend
class
AffixPatternMatcherBuilder
;
}
;
class
AffixMatcher
:
public
NumberParseMatcher
public
UMemory
{
public
:
AffixMatcher
(
)
=
default
;
AffixMatcher
(
AffixPatternMatcher
*
prefix
AffixPatternMatcher
*
suffix
result_flags_t
flags
)
;
bool
match
(
StringSegment
&
segment
ParsedNumber
&
result
UErrorCode
&
status
)
const
override
;
void
postProcess
(
ParsedNumber
&
result
)
const
override
;
bool
smokeTest
(
const
StringSegment
&
segment
)
const
override
;
int8_t
compareTo
(
const
AffixMatcher
&
rhs
)
const
;
UnicodeString
toString
(
)
const
override
;
private
:
AffixPatternMatcher
*
fPrefix
;
AffixPatternMatcher
*
fSuffix
;
result_flags_t
fFlags
;
}
;
class
AffixMatcherWarehouse
{
public
:
AffixMatcherWarehouse
(
)
=
default
;
AffixMatcherWarehouse
(
AffixTokenMatcherWarehouse
*
tokenWarehouse
)
;
void
createAffixMatchers
(
const
AffixPatternProvider
&
patternInfo
MutableMatcherCollection
&
output
const
IgnorablesMatcher
&
ignorables
parse_flags_t
parseFlags
UErrorCode
&
status
)
;
private
:
AffixMatcher
fAffixMatchers
[
9
]
;
AffixPatternMatcher
fAffixPatternMatchers
[
6
]
;
AffixTokenMatcherWarehouse
*
fTokenWarehouse
;
friend
class
AffixMatcher
;
static
bool
isInteresting
(
const
AffixPatternProvider
&
patternInfo
const
IgnorablesMatcher
&
ignorables
parse_flags_t
parseFlags
UErrorCode
&
status
)
;
}
;
}
}
U_NAMESPACE_END
#
endif
#
endif
