#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
define
UNISTR_FROM_STRING_EXPLICIT
#
include
<
stdlib
.
h
>
#
include
<
cmath
>
#
include
"
number_decnum
.
h
"
#
include
"
number_types
.
h
"
#
include
"
number_utils
.
h
"
#
include
"
charstr
.
h
"
#
include
"
decContext
.
h
"
#
include
"
decNumber
.
h
"
#
include
"
double
-
conversion
.
h
"
#
include
"
fphdlimp
.
h
"
#
include
"
uresimp
.
h
"
#
include
"
ureslocs
.
h
"
using
namespace
icu
;
using
namespace
icu
:
:
number
;
using
namespace
icu
:
:
number
:
:
impl
;
using
icu
:
:
double_conversion
:
:
DoubleToStringConverter
;
namespace
{
const
char16_t
*
doGetPattern
(
UResourceBundle
*
res
const
char
*
nsName
const
char
*
patternKey
UErrorCode
&
publicStatus
UErrorCode
&
localStatus
)
{
CharString
key
;
key
.
append
(
"
NumberElements
/
"
publicStatus
)
;
key
.
append
(
nsName
publicStatus
)
;
key
.
append
(
"
/
patterns
/
"
publicStatus
)
;
key
.
append
(
patternKey
publicStatus
)
;
if
(
U_FAILURE
(
publicStatus
)
)
{
return
u
"
"
;
}
return
ures_getStringByKeyWithFallback
(
res
key
.
data
(
)
nullptr
&
localStatus
)
;
}
}
const
char16_t
*
utils
:
:
getPatternForStyle
(
const
Locale
&
locale
const
char
*
nsName
CldrPatternStyle
style
UErrorCode
&
status
)
{
const
char
*
patternKey
;
switch
(
style
)
{
case
CLDR_PATTERN_STYLE_DECIMAL
:
patternKey
=
"
decimalFormat
"
;
break
;
case
CLDR_PATTERN_STYLE_CURRENCY
:
patternKey
=
"
currencyFormat
"
;
break
;
case
CLDR_PATTERN_STYLE_ACCOUNTING
:
patternKey
=
"
accountingFormat
"
;
break
;
case
CLDR_PATTERN_STYLE_PERCENT
:
patternKey
=
"
percentFormat
"
;
break
;
case
CLDR_PATTERN_STYLE_SCIENTIFIC
:
patternKey
=
"
scientificFormat
"
;
break
;
default
:
patternKey
=
"
decimalFormat
"
;
U_ASSERT
(
false
)
;
}
LocalUResourceBundlePointer
res
(
ures_open
(
nullptr
locale
.
getName
(
)
&
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
return
u
"
"
;
}
UErrorCode
localStatus
=
U_ZERO_ERROR
;
const
char16_t
*
pattern
;
pattern
=
doGetPattern
(
res
.
getAlias
(
)
nsName
patternKey
status
localStatus
)
;
if
(
U_FAILURE
(
status
)
)
{
return
u
"
"
;
}
if
(
U_FAILURE
(
localStatus
)
&
&
uprv_strcmp
(
"
latn
"
nsName
)
!
=
0
)
{
localStatus
=
U_ZERO_ERROR
;
pattern
=
doGetPattern
(
res
.
getAlias
(
)
"
latn
"
patternKey
status
localStatus
)
;
if
(
U_FAILURE
(
status
)
)
{
return
u
"
"
;
}
}
return
pattern
;
}
DecNum
:
:
DecNum
(
)
{
uprv_decContextDefault
(
&
fContext
DEC_INIT_BASE
)
;
uprv_decContextSetRounding
(
&
fContext
DEC_ROUND_HALF_EVEN
)
;
fContext
.
traps
=
0
;
}
DecNum
:
:
DecNum
(
const
DecNum
&
other
UErrorCode
&
status
)
:
fContext
(
other
.
fContext
)
{
U_ASSERT
(
fContext
.
digits
=
=
other
.
fData
.
getCapacity
(
)
)
;
if
(
fContext
.
digits
>
kDefaultDigits
)
{
void
*
p
=
fData
.
resize
(
fContext
.
digits
0
)
;
if
(
p
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
}
uprv_memcpy
(
fData
.
getAlias
(
)
other
.
fData
.
getAlias
(
)
sizeof
(
decNumber
)
)
;
uprv_memcpy
(
fData
.
getArrayStart
(
)
other
.
fData
.
getArrayStart
(
)
other
.
fData
.
getArrayLimit
(
)
-
other
.
fData
.
getArrayStart
(
)
)
;
}
void
DecNum
:
:
setTo
(
StringPiece
str
UErrorCode
&
status
)
{
CharString
cstr
(
str
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
_setTo
(
cstr
.
data
(
)
str
.
length
(
)
status
)
;
}
void
DecNum
:
:
setTo
(
const
char
*
str
UErrorCode
&
status
)
{
_setTo
(
str
static_cast
<
int32_t
>
(
uprv_strlen
(
str
)
)
status
)
;
}
void
DecNum
:
:
setTo
(
double
d
UErrorCode
&
status
)
{
if
(
std
:
:
isnan
(
d
)
!
=
0
|
|
std
:
:
isfinite
(
d
)
=
=
0
)
{
status
=
U_UNSUPPORTED_ERROR
;
return
;
}
char
buffer
[
DoubleToStringConverter
:
:
kBase10MaximalLength
+
6
]
;
bool
sign
;
int32_t
length
;
int32_t
point
;
DoubleToStringConverter
:
:
DoubleToAscii
(
d
DoubleToStringConverter
:
:
DtoaMode
:
:
SHORTEST
0
buffer
sizeof
(
buffer
)
&
sign
&
length
&
point
)
;
_setTo
(
buffer
length
status
)
;
fData
.
getAlias
(
)
-
>
exponent
+
=
point
-
length
;
fData
.
getAlias
(
)
-
>
bits
|
=
static_cast
<
uint8_t
>
(
std
:
:
signbit
(
d
)
?
DECNEG
:
0
)
;
}
void
DecNum
:
:
_setTo
(
const
char
*
str
int32_t
maxDigits
UErrorCode
&
status
)
{
if
(
maxDigits
>
kDefaultDigits
)
{
fData
.
resize
(
maxDigits
0
)
;
fContext
.
digits
=
maxDigits
;
}
else
{
fContext
.
digits
=
kDefaultDigits
;
}
static_assert
(
DECDPUN
=
=
1
"
Assumes
that
DECDPUN
is
set
to
1
"
)
;
uprv_decNumberFromString
(
fData
.
getAlias
(
)
str
&
fContext
)
;
if
(
(
fContext
.
status
&
DEC_Conversion_syntax
)
!
=
0
)
{
status
=
U_DECIMAL_NUMBER_SYNTAX_ERROR
;
return
;
}
else
if
(
fContext
.
status
!
=
0
)
{
status
=
U_UNSUPPORTED_ERROR
;
return
;
}
if
(
decNumberIsSpecial
(
fData
.
getAlias
(
)
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
return
;
}
}
void
DecNum
:
:
setTo
(
const
uint8_t
*
bcd
int32_t
length
int32_t
scale
bool
isNegative
UErrorCode
&
status
)
{
if
(
length
>
kDefaultDigits
)
{
fData
.
resize
(
length
0
)
;
fContext
.
digits
=
length
;
}
else
{
fContext
.
digits
=
kDefaultDigits
;
}
if
(
length
<
1
|
|
length
>
999999999
)
{
status
=
U_UNSUPPORTED_ERROR
;
return
;
}
if
(
scale
>
999999999
-
length
+
1
|
|
scale
<
-
999999999
-
length
+
1
)
{
status
=
U_UNSUPPORTED_ERROR
;
return
;
}
fData
.
getAlias
(
)
-
>
digits
=
length
;
fData
.
getAlias
(
)
-
>
exponent
=
scale
;
fData
.
getAlias
(
)
-
>
bits
=
static_cast
<
uint8_t
>
(
isNegative
?
DECNEG
:
0
)
;
uprv_decNumberSetBCD
(
fData
bcd
static_cast
<
uint32_t
>
(
length
)
)
;
if
(
fContext
.
status
!
=
0
)
{
status
=
U_INTERNAL_PROGRAM_ERROR
;
}
}
void
DecNum
:
:
normalize
(
)
{
uprv_decNumberReduce
(
fData
fData
&
fContext
)
;
}
void
DecNum
:
:
multiplyBy
(
const
DecNum
&
rhs
UErrorCode
&
status
)
{
uprv_decNumberMultiply
(
fData
fData
rhs
.
fData
&
fContext
)
;
if
(
fContext
.
status
!
=
0
)
{
status
=
U_INTERNAL_PROGRAM_ERROR
;
}
}
void
DecNum
:
:
divideBy
(
const
DecNum
&
rhs
UErrorCode
&
status
)
{
uprv_decNumberDivide
(
fData
fData
rhs
.
fData
&
fContext
)
;
if
(
fContext
.
status
!
=
0
)
{
status
=
U_INTERNAL_PROGRAM_ERROR
;
}
}
bool
DecNum
:
:
isNegative
(
)
const
{
return
decNumberIsNegative
(
fData
.
getAlias
(
)
)
;
}
bool
DecNum
:
:
isZero
(
)
const
{
return
decNumberIsZero
(
fData
.
getAlias
(
)
)
;
}
#
endif
