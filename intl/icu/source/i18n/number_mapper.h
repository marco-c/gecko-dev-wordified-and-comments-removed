#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
ifndef
__NUMBER_MAPPER_H__
#
define
__NUMBER_MAPPER_H__
#
include
<
atomic
>
#
include
"
number_types
.
h
"
#
include
"
unicode
/
currpinf
.
h
"
#
include
"
standardplural
.
h
"
#
include
"
number_patternstring
.
h
"
#
include
"
number_currencysymbols
.
h
"
#
include
"
numparse_impl
.
h
"
U_NAMESPACE_BEGIN
namespace
number
{
namespace
impl
{
class
PropertiesAffixPatternProvider
:
public
AffixPatternProvider
public
UMemory
{
public
:
bool
isBogus
(
)
const
{
return
fBogus
;
}
void
setToBogus
(
)
{
fBogus
=
true
;
}
void
setTo
(
const
DecimalFormatProperties
&
properties
UErrorCode
&
status
)
;
PropertiesAffixPatternProvider
(
)
=
default
;
PropertiesAffixPatternProvider
(
const
DecimalFormatProperties
&
properties
UErrorCode
&
status
)
{
setTo
(
properties
status
)
;
}
char16_t
charAt
(
int32_t
flags
int32_t
i
)
const
U_OVERRIDE
;
int32_t
length
(
int32_t
flags
)
const
U_OVERRIDE
;
UnicodeString
getString
(
int32_t
flags
)
const
U_OVERRIDE
;
bool
hasCurrencySign
(
)
const
U_OVERRIDE
;
bool
positiveHasPlusSign
(
)
const
U_OVERRIDE
;
bool
hasNegativeSubpattern
(
)
const
U_OVERRIDE
;
bool
negativeHasMinusSign
(
)
const
U_OVERRIDE
;
bool
containsSymbolType
(
AffixPatternType
UErrorCode
&
)
const
U_OVERRIDE
;
bool
hasBody
(
)
const
U_OVERRIDE
;
private
:
UnicodeString
posPrefix
;
UnicodeString
posSuffix
;
UnicodeString
negPrefix
;
UnicodeString
negSuffix
;
const
UnicodeString
&
getStringInternal
(
int32_t
flags
)
const
;
bool
fBogus
{
true
}
;
}
;
class
CurrencyPluralInfoAffixProvider
:
public
AffixPatternProvider
public
UMemory
{
public
:
bool
isBogus
(
)
const
{
return
fBogus
;
}
void
setToBogus
(
)
{
fBogus
=
true
;
}
void
setTo
(
const
CurrencyPluralInfo
&
cpi
const
DecimalFormatProperties
&
properties
UErrorCode
&
status
)
;
char16_t
charAt
(
int32_t
flags
int32_t
i
)
const
U_OVERRIDE
;
int32_t
length
(
int32_t
flags
)
const
U_OVERRIDE
;
UnicodeString
getString
(
int32_t
flags
)
const
U_OVERRIDE
;
bool
hasCurrencySign
(
)
const
U_OVERRIDE
;
bool
positiveHasPlusSign
(
)
const
U_OVERRIDE
;
bool
hasNegativeSubpattern
(
)
const
U_OVERRIDE
;
bool
negativeHasMinusSign
(
)
const
U_OVERRIDE
;
bool
containsSymbolType
(
AffixPatternType
UErrorCode
&
)
const
U_OVERRIDE
;
bool
hasBody
(
)
const
U_OVERRIDE
;
private
:
PropertiesAffixPatternProvider
affixesByPlural
[
StandardPlural
:
:
COUNT
]
;
bool
fBogus
{
true
}
;
}
;
struct
DecimalFormatWarehouse
{
PropertiesAffixPatternProvider
propertiesAPP
;
CurrencyPluralInfoAffixProvider
currencyPluralInfoAPP
;
CurrencySymbols
currencySymbols
;
}
;
struct
DecimalFormatFields
:
public
UMemory
{
LocalPointer
<
DecimalFormatProperties
>
properties
;
LocalPointer
<
const
DecimalFormatSymbols
>
symbols
;
LocalPointer
<
const
LocalizedNumberFormatter
>
formatter
;
std
:
:
atomic
<
:
:
icu
:
:
numparse
:
:
impl
:
:
NumberParserImpl
*
>
atomicParser
=
{
}
;
std
:
:
atomic
<
:
:
icu
:
:
numparse
:
:
impl
:
:
NumberParserImpl
*
>
atomicCurrencyParser
=
{
}
;
DecimalFormatWarehouse
warehouse
;
LocalPointer
<
DecimalFormatProperties
>
exportedProperties
;
bool
canUseFastFormat
=
false
;
struct
FastFormatData
{
char16_t
cpZero
;
char16_t
cpGroupingSeparator
;
char16_t
cpMinusSign
;
int8_t
minInt
;
int8_t
maxInt
;
}
fastData
;
}
;
class
NumberPropertyMapper
{
public
:
static
UnlocalizedNumberFormatter
create
(
const
DecimalFormatProperties
&
properties
const
DecimalFormatSymbols
&
symbols
DecimalFormatWarehouse
&
warehouse
UErrorCode
&
status
)
;
static
UnlocalizedNumberFormatter
create
(
const
DecimalFormatProperties
&
properties
const
DecimalFormatSymbols
&
symbols
DecimalFormatWarehouse
&
warehouse
DecimalFormatProperties
&
exportedProperties
UErrorCode
&
status
)
;
static
MacroProps
oldToNew
(
const
DecimalFormatProperties
&
properties
const
DecimalFormatSymbols
&
symbols
DecimalFormatWarehouse
&
warehouse
DecimalFormatProperties
*
exportedProperties
UErrorCode
&
status
)
;
}
;
}
}
U_NAMESPACE_END
#
endif
#
endif
