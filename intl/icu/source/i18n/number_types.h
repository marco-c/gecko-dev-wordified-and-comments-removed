#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
&
&
!
UPRV_INCOMPLETE_CPP11_SUPPORT
#
ifndef
__NUMBER_TYPES_H__
#
define
__NUMBER_TYPES_H__
#
include
<
cstdint
>
#
include
"
unicode
/
decimfmt
.
h
"
#
include
"
unicode
/
unum
.
h
"
#
include
"
unicode
/
numsys
.
h
"
#
include
"
unicode
/
numberformatter
.
h
"
#
include
"
unicode
/
utf16
.
h
"
#
include
"
uassert
.
h
"
#
include
"
unicode
/
platform
.
h
"
U_NAMESPACE_BEGIN
namespace
number
{
namespace
impl
{
typedef
UNumberFormatFields
Field
;
typedef
UNumberFormatRoundingMode
RoundingMode
;
typedef
UNumberFormatPadPosition
PadPosition
;
typedef
UNumberCompactStyle
CompactStyle
;
static
constexpr
int32_t
kMaxIntFracSig
=
100
;
static
constexpr
RoundingMode
kDefaultMode
=
RoundingMode
:
:
UNUM_FOUND_HALFEVEN
;
static
constexpr
char16_t
kFallbackPaddingString
[
]
=
u
"
"
;
static
constexpr
char16_t
kDefaultCurrency
[
]
=
u
"
XXX
"
;
static
constexpr
UErrorCode
U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR
=
U_ILLEGAL_ARGUMENT_ERROR
;
static
constexpr
UErrorCode
U_NUMBER_PADDING_WIDTH_OUTOFBOUNDS_ERROR
=
U_ILLEGAL_ARGUMENT_ERROR
;
class
Modifier
;
class
MutablePatternModifier
;
class
DecimalQuantity
;
class
NumberStringBuilder
;
struct
MicroProps
;
enum
AffixPatternType
{
TYPE_CODEPOINT
=
0
TYPE_MINUS_SIGN
=
-
1
TYPE_PLUS_SIGN
=
-
2
TYPE_PERCENT
=
-
3
TYPE_PERMILLE
=
-
4
TYPE_CURRENCY_SINGLE
=
-
5
TYPE_CURRENCY_DOUBLE
=
-
6
TYPE_CURRENCY_TRIPLE
=
-
7
TYPE_CURRENCY_QUAD
=
-
8
TYPE_CURRENCY_QUINT
=
-
9
TYPE_CURRENCY_OVERFLOW
=
-
15
}
;
enum
CompactType
{
TYPE_DECIMAL
TYPE_CURRENCY
}
;
class
U_I18N_API
CharSequence
{
public
:
virtual
~
CharSequence
(
)
=
default
;
virtual
int32_t
length
(
)
const
=
0
;
virtual
char16_t
charAt
(
int32_t
index
)
const
=
0
;
virtual
UChar32
codePointAt
(
int32_t
index
)
const
{
char16_t
leading
=
charAt
(
index
)
;
if
(
U16_IS_LEAD
(
leading
)
&
&
length
(
)
>
index
+
1
)
{
char16_t
trailing
=
charAt
(
index
+
1
)
;
return
U16_GET_SUPPLEMENTARY
(
leading
trailing
)
;
}
else
{
return
leading
;
}
}
virtual
UnicodeString
toUnicodeString
(
)
const
=
0
;
}
;
class
U_I18N_API
AffixPatternProvider
{
public
:
static
const
int32_t
AFFIX_PLURAL_MASK
=
0xff
;
static
const
int32_t
AFFIX_PREFIX
=
0x100
;
static
const
int32_t
AFFIX_NEGATIVE_SUBPATTERN
=
0x200
;
static
const
int32_t
AFFIX_PADDING
=
0x400
;
virtual
~
AffixPatternProvider
(
)
=
default
;
virtual
char16_t
charAt
(
int
flags
int
i
)
const
=
0
;
virtual
int
length
(
int
flags
)
const
=
0
;
virtual
bool
hasCurrencySign
(
)
const
=
0
;
virtual
bool
positiveHasPlusSign
(
)
const
=
0
;
virtual
bool
hasNegativeSubpattern
(
)
const
=
0
;
virtual
bool
negativeHasMinusSign
(
)
const
=
0
;
virtual
bool
containsSymbolType
(
AffixPatternType
UErrorCode
&
)
const
=
0
;
}
;
class
U_I18N_API
Modifier
{
public
:
virtual
~
Modifier
(
)
=
default
;
virtual
int32_t
apply
(
NumberStringBuilder
&
output
int
leftIndex
int
rightIndex
UErrorCode
&
status
)
const
=
0
;
virtual
int32_t
getPrefixLength
(
UErrorCode
&
status
)
const
=
0
;
virtual
int32_t
getCodePointCount
(
UErrorCode
&
status
)
const
=
0
;
virtual
bool
isStrong
(
)
const
=
0
;
}
;
class
U_I18N_API
MicroPropsGenerator
{
public
:
virtual
~
MicroPropsGenerator
(
)
=
default
;
virtual
void
processQuantity
(
DecimalQuantity
&
quantity
MicroProps
&
micros
UErrorCode
&
status
)
const
=
0
;
}
;
class
MultiplierProducer
{
public
:
virtual
~
MultiplierProducer
(
)
=
default
;
virtual
int32_t
getMultiplier
(
int32_t
magnitude
)
const
=
0
;
}
;
template
<
typename
T
>
class
U_I18N_API
NullableValue
{
public
:
NullableValue
(
)
:
fNull
(
true
)
{
}
NullableValue
(
const
NullableValue
<
T
>
&
other
)
=
default
;
explicit
NullableValue
(
const
T
&
other
)
{
fValue
=
other
;
fNull
=
false
;
}
NullableValue
<
T
>
&
operator
=
(
const
NullableValue
<
T
>
&
other
)
=
default
;
NullableValue
<
T
>
&
operator
=
(
const
T
&
other
)
{
fValue
=
other
;
fNull
=
false
;
return
*
this
;
}
bool
operator
=
=
(
const
NullableValue
&
other
)
const
{
return
fNull
?
other
.
fNull
:
(
other
.
fNull
?
false
:
static_cast
<
bool
>
(
fValue
=
=
other
.
fValue
)
)
;
}
void
nullify
(
)
{
fNull
=
true
;
}
bool
isNull
(
)
const
{
return
fNull
;
}
T
get
(
UErrorCode
&
status
)
const
{
if
(
fNull
)
{
status
=
U_UNDEFINED_VARIABLE
;
}
return
fValue
;
}
private
:
bool
fNull
;
T
fValue
;
}
;
}
}
U_NAMESPACE_END
#
endif
#
endif
