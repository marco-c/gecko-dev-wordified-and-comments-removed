#
ifndef
ERARULES_H_
#
define
ERARULES_H_
#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
localpointer
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
cmemory
.
h
"
U_NAMESPACE_BEGIN
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4661
)
#
endif
template
class
U_I18N_API
LocalPointerBase
<
int32_t
>
;
template
class
U_I18N_API
LocalMemory
<
int32_t
>
;
#
if
defined
(
_MSC_VER
)
#
pragma
warning
(
pop
)
#
endif
#
endif
class
U_I18N_API
EraRules
:
public
UMemory
{
public
:
~
EraRules
(
)
;
static
EraRules
*
createInstance
(
const
char
*
calType
UBool
includeTentativeEra
UErrorCode
&
status
)
;
inline
int32_t
getNumberOfEras
(
)
const
{
return
numEras
;
}
void
getStartDate
(
int32_t
eraIdx
int32_t
(
&
fields
)
[
3
]
UErrorCode
&
status
)
const
;
int32_t
getStartYear
(
int32_t
eraIdx
UErrorCode
&
status
)
const
;
int32_t
getEraIndex
(
int32_t
year
int32_t
month
int32_t
day
UErrorCode
&
status
)
const
;
inline
int32_t
getCurrentEraIndex
(
)
const
{
return
currentEra
;
}
private
:
EraRules
(
LocalMemory
<
int32_t
>
&
eraStartDates
int32_t
numEra
)
;
void
initCurrentEra
(
)
;
LocalMemory
<
int32_t
>
startDates
;
int32_t
numEras
;
int32_t
currentEra
;
}
;
U_NAMESPACE_END
#
endif
#
endif
