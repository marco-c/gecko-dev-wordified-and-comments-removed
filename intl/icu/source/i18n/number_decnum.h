#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
ifndef
__NUMBER_DECNUM_H__
#
define
__NUMBER_DECNUM_H__
#
include
"
decNumber
.
h
"
#
include
"
charstr
.
h
"
U_NAMESPACE_BEGIN
#
define
DECNUM_INITIAL_CAPACITY
34
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
MaybeStackHeaderAndArray
<
decNumber
char
DECNUM_INITIAL_CAPACITY
>
;
#
endif
namespace
number
{
namespace
impl
{
class
U_I18N_API
DecNum
:
public
UMemory
{
public
:
DecNum
(
)
;
DecNum
(
const
DecNum
&
other
UErrorCode
&
status
)
;
void
setTo
(
StringPiece
str
UErrorCode
&
status
)
;
void
setTo
(
const
char
*
str
UErrorCode
&
status
)
;
void
setTo
(
double
d
UErrorCode
&
status
)
;
void
setTo
(
const
uint8_t
*
bcd
int32_t
length
int32_t
scale
bool
isNegative
UErrorCode
&
status
)
;
void
normalize
(
)
;
void
multiplyBy
(
const
DecNum
&
rhs
UErrorCode
&
status
)
;
void
divideBy
(
const
DecNum
&
rhs
UErrorCode
&
status
)
;
bool
isNegative
(
)
const
;
bool
isZero
(
)
const
;
inline
const
decNumber
*
getRawDecNumber
(
)
const
{
return
fData
.
getAlias
(
)
;
}
private
:
static
constexpr
int32_t
kDefaultDigits
=
DECNUM_INITIAL_CAPACITY
;
MaybeStackHeaderAndArray
<
decNumber
char
kDefaultDigits
>
fData
;
decContext
fContext
;
void
_setTo
(
const
char
*
str
int32_t
maxDigits
UErrorCode
&
status
)
;
}
;
}
}
U_NAMESPACE_END
#
endif
#
endif
