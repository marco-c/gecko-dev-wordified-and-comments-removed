#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
ifndef
__NUMPARSE_TYPES_H__
#
define
__NUMPARSE_TYPES_H__
#
include
"
unicode
/
uobject
.
h
"
#
include
"
number_decimalquantity
.
h
"
#
include
"
string_segment
.
h
"
U_NAMESPACE_BEGIN
namespace
numparse
{
namespace
impl
{
class
ParsedNumber
;
typedef
int32_t
result_flags_t
;
typedef
int32_t
parse_flags_t
;
enum
ResultFlags
{
FLAG_NEGATIVE
=
0x0001
FLAG_PERCENT
=
0x0002
FLAG_PERMILLE
=
0x0004
FLAG_HAS_EXPONENT
=
0x0008
FLAG_HAS_DECIMAL_SEPARATOR
=
0x0020
FLAG_NAN
=
0x0040
FLAG_INFINITY
=
0x0080
FLAG_FAIL
=
0x0100
}
;
enum
ParseFlags
{
PARSE_FLAG_IGNORE_CASE
=
0x0001
PARSE_FLAG_MONETARY_SEPARATORS
=
0x0002
PARSE_FLAG_STRICT_SEPARATORS
=
0x0004
PARSE_FLAG_STRICT_GROUPING_SIZE
=
0x0008
PARSE_FLAG_INTEGER_ONLY
=
0x0010
PARSE_FLAG_GROUPING_DISABLED
=
0x0020
PARSE_FLAG_INCLUDE_UNPAIRED_AFFIXES
=
0x0080
PARSE_FLAG_USE_FULL_AFFIXES
=
0x0100
PARSE_FLAG_EXACT_AFFIX
=
0x0200
PARSE_FLAG_PLUS_SIGN_ALLOWED
=
0x0400
PARSE_FLAG_NO_FOREIGN_CURRENCY
=
0x2000
PARSE_FLAG_ALLOW_INFINITE_RECURSION
=
0x4000
PARSE_FLAG_STRICT_IGNORABLES
=
0x8000
}
;
template
<
int32_t
stackCapacity
>
class
CompactUnicodeString
{
public
:
CompactUnicodeString
(
)
{
static_assert
(
stackCapacity
>
0
"
cannot
have
zero
space
on
stack
"
)
;
fBuffer
[
0
]
=
0
;
}
CompactUnicodeString
(
const
UnicodeString
&
text
)
:
fBuffer
(
text
.
length
(
)
+
1
)
{
uprv_memcpy
(
fBuffer
.
getAlias
(
)
text
.
getBuffer
(
)
sizeof
(
UChar
)
*
text
.
length
(
)
)
;
fBuffer
[
text
.
length
(
)
]
=
0
;
}
inline
UnicodeString
toAliasedUnicodeString
(
)
const
{
return
UnicodeString
(
TRUE
fBuffer
.
getAlias
(
)
-
1
)
;
}
bool
operator
=
=
(
const
CompactUnicodeString
&
other
)
const
{
return
toAliasedUnicodeString
(
)
=
=
other
.
toAliasedUnicodeString
(
)
;
}
private
:
MaybeStackArray
<
UChar
stackCapacity
>
fBuffer
;
}
;
class
U_I18N_API
ParsedNumber
{
public
:
:
:
icu
:
:
number
:
:
impl
:
:
DecimalQuantity
quantity
;
int32_t
charEnd
;
result_flags_t
flags
;
UnicodeString
prefix
;
UnicodeString
suffix
;
UChar
currencyCode
[
4
]
;
ParsedNumber
(
)
;
ParsedNumber
(
const
ParsedNumber
&
other
)
=
default
;
ParsedNumber
&
operator
=
(
const
ParsedNumber
&
other
)
=
default
;
void
clear
(
)
;
void
setCharsConsumed
(
const
StringSegment
&
segment
)
;
void
postProcess
(
)
;
bool
success
(
)
const
;
bool
seenNumber
(
)
const
;
double
getDouble
(
UErrorCode
&
status
)
const
;
void
populateFormattable
(
Formattable
&
output
parse_flags_t
parseFlags
)
const
;
bool
isBetterThan
(
const
ParsedNumber
&
other
)
;
}
;
class
U_I18N_API
NumberParseMatcher
{
public
:
virtual
~
NumberParseMatcher
(
)
;
virtual
bool
isFlexible
(
)
const
{
return
false
;
}
virtual
bool
match
(
StringSegment
&
segment
ParsedNumber
&
result
UErrorCode
&
status
)
const
=
0
;
virtual
bool
smokeTest
(
const
StringSegment
&
segment
)
const
=
0
;
virtual
void
postProcess
(
ParsedNumber
&
)
const
{
}
virtual
UnicodeString
toString
(
)
const
=
0
;
protected
:
NumberParseMatcher
(
)
=
default
;
}
;
class
U_I18N_API
MutableMatcherCollection
{
public
:
virtual
~
MutableMatcherCollection
(
)
=
default
;
virtual
void
addMatcher
(
NumberParseMatcher
&
matcher
)
=
0
;
}
;
}
}
U_NAMESPACE_END
#
endif
#
endif
