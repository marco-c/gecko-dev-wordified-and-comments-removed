#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
ifndef
__NUMPARSE_IMPL_H__
#
define
__NUMPARSE_IMPL_H__
#
include
"
numparse_types
.
h
"
#
include
"
numparse_decimal
.
h
"
#
include
"
numparse_symbols
.
h
"
#
include
"
numparse_scientific
.
h
"
#
include
"
unicode
/
uniset
.
h
"
#
include
"
numparse_currency
.
h
"
#
include
"
numparse_affixes
.
h
"
#
include
"
number_decimfmtprops
.
h
"
#
include
"
unicode
/
localpointer
.
h
"
#
include
"
numparse_validators
.
h
"
#
include
"
number_multiplier
.
h
"
#
include
"
string_segment
.
h
"
U_NAMESPACE_BEGIN
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
MaybeStackArray
<
const
numparse
:
:
impl
:
:
NumberParseMatcher
*
10
>
;
#
endif
namespace
numparse
{
namespace
impl
{
class
U_I18N_API
NumberParserImpl
:
public
MutableMatcherCollection
public
UMemory
{
public
:
virtual
~
NumberParserImpl
(
)
;
static
NumberParserImpl
*
createSimpleParser
(
const
Locale
&
locale
const
UnicodeString
&
patternString
parse_flags_t
parseFlags
UErrorCode
&
status
)
;
static
NumberParserImpl
*
createParserFromProperties
(
const
number
:
:
impl
:
:
DecimalFormatProperties
&
properties
const
DecimalFormatSymbols
&
symbols
bool
parseCurrency
UErrorCode
&
status
)
;
void
addMatcher
(
NumberParseMatcher
&
matcher
)
override
;
void
freeze
(
)
;
parse_flags_t
getParseFlags
(
)
const
;
void
parse
(
const
UnicodeString
&
input
bool
greedy
ParsedNumber
&
result
UErrorCode
&
status
)
const
;
void
parse
(
const
UnicodeString
&
input
int32_t
start
bool
greedy
ParsedNumber
&
result
UErrorCode
&
status
)
const
;
UnicodeString
toString
(
)
const
;
private
:
parse_flags_t
fParseFlags
;
int32_t
fNumMatchers
=
0
;
MaybeStackArray
<
const
NumberParseMatcher
*
10
>
fMatchers
;
bool
fFrozen
=
false
;
struct
{
IgnorablesMatcher
ignorables
;
InfinityMatcher
infinity
;
MinusSignMatcher
minusSign
;
NanMatcher
nan
;
PaddingMatcher
padding
;
PercentMatcher
percent
;
PermilleMatcher
permille
;
PlusSignMatcher
plusSign
;
DecimalMatcher
decimal
;
ScientificMatcher
scientific
;
CombinedCurrencyMatcher
currency
;
AffixMatcherWarehouse
affixMatcherWarehouse
;
AffixTokenMatcherWarehouse
affixTokenMatcherWarehouse
;
}
fLocalMatchers
;
struct
{
RequireAffixValidator
affix
;
RequireCurrencyValidator
currency
;
RequireDecimalSeparatorValidator
decimalSeparator
;
RequireNumberValidator
number
;
MultiplierParseHandler
multiplier
;
}
fLocalValidators
;
explicit
NumberParserImpl
(
parse_flags_t
parseFlags
)
;
void
parseGreedy
(
StringSegment
&
segment
ParsedNumber
&
result
UErrorCode
&
status
)
const
;
void
parseLongestRecursive
(
StringSegment
&
segment
ParsedNumber
&
result
int32_t
recursionLevels
UErrorCode
&
status
)
const
;
}
;
}
}
U_NAMESPACE_END
#
endif
#
endif
