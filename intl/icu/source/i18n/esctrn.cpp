#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_TRANSLITERATION
#
include
"
unicode
/
utf16
.
h
"
#
include
"
esctrn
.
h
"
#
include
"
util
.
h
"
U_NAMESPACE_BEGIN
static
const
char16_t
UNIPRE
[
]
=
{
85
43
0
}
;
static
const
char16_t
BS_u
[
]
=
{
92
117
0
}
;
static
const
char16_t
BS_U
[
]
=
{
92
85
0
}
;
static
const
char16_t
XMLPRE
[
]
=
{
38
35
120
0
}
;
static
const
char16_t
XML10PRE
[
]
=
{
38
35
0
}
;
static
const
char16_t
PERLPRE
[
]
=
{
92
120
123
0
}
;
static
const
char16_t
SEMI
[
]
=
{
59
0
}
;
static
const
char16_t
RBRACE
[
]
=
{
125
0
}
;
UOBJECT_DEFINE_RTTI_IMPLEMENTATION
(
EscapeTransliterator
)
static
Transliterator
*
_createEscUnicode
(
const
UnicodeString
&
ID
Transliterator
:
:
Token
)
{
return
new
EscapeTransliterator
(
ID
UnicodeString
(
true
UNIPRE
2
)
UnicodeString
(
)
16
4
true
nullptr
)
;
}
static
Transliterator
*
_createEscJava
(
const
UnicodeString
&
ID
Transliterator
:
:
Token
)
{
return
new
EscapeTransliterator
(
ID
UnicodeString
(
true
BS_u
2
)
UnicodeString
(
)
16
4
false
nullptr
)
;
}
static
Transliterator
*
_createEscC
(
const
UnicodeString
&
ID
Transliterator
:
:
Token
)
{
return
new
EscapeTransliterator
(
ID
UnicodeString
(
true
BS_u
2
)
UnicodeString
(
)
16
4
true
new
EscapeTransliterator
(
UnicodeString
(
)
UnicodeString
(
true
BS_U
2
)
UnicodeString
(
)
16
8
true
nullptr
)
)
;
}
static
Transliterator
*
_createEscXML
(
const
UnicodeString
&
ID
Transliterator
:
:
Token
)
{
return
new
EscapeTransliterator
(
ID
UnicodeString
(
true
XMLPRE
3
)
UnicodeString
(
SEMI
[
0
]
)
16
1
true
nullptr
)
;
}
static
Transliterator
*
_createEscXML10
(
const
UnicodeString
&
ID
Transliterator
:
:
Token
)
{
return
new
EscapeTransliterator
(
ID
UnicodeString
(
true
XML10PRE
2
)
UnicodeString
(
SEMI
[
0
]
)
10
1
true
nullptr
)
;
}
static
Transliterator
*
_createEscPerl
(
const
UnicodeString
&
ID
Transliterator
:
:
Token
)
{
return
new
EscapeTransliterator
(
ID
UnicodeString
(
true
PERLPRE
3
)
UnicodeString
(
RBRACE
[
0
]
)
16
1
true
nullptr
)
;
}
void
EscapeTransliterator
:
:
registerIDs
(
)
{
Token
t
=
integerToken
(
0
)
;
Transliterator
:
:
_registerFactory
(
UNICODE_STRING_SIMPLE
(
"
Any
-
Hex
/
Unicode
"
)
_createEscUnicode
t
)
;
Transliterator
:
:
_registerFactory
(
UNICODE_STRING_SIMPLE
(
"
Any
-
Hex
/
Java
"
)
_createEscJava
t
)
;
Transliterator
:
:
_registerFactory
(
UNICODE_STRING_SIMPLE
(
"
Any
-
Hex
/
C
"
)
_createEscC
t
)
;
Transliterator
:
:
_registerFactory
(
UNICODE_STRING_SIMPLE
(
"
Any
-
Hex
/
XML
"
)
_createEscXML
t
)
;
Transliterator
:
:
_registerFactory
(
UNICODE_STRING_SIMPLE
(
"
Any
-
Hex
/
XML10
"
)
_createEscXML10
t
)
;
Transliterator
:
:
_registerFactory
(
UNICODE_STRING_SIMPLE
(
"
Any
-
Hex
/
Perl
"
)
_createEscPerl
t
)
;
Transliterator
:
:
_registerFactory
(
UNICODE_STRING_SIMPLE
(
"
Any
-
Hex
"
)
_createEscJava
t
)
;
}
EscapeTransliterator
:
:
EscapeTransliterator
(
const
UnicodeString
&
newID
const
UnicodeString
&
_prefix
const
UnicodeString
&
_suffix
int32_t
_radix
int32_t
_minDigits
UBool
_grokSupplementals
EscapeTransliterator
*
adoptedSupplementalHandler
)
:
Transliterator
(
newID
nullptr
)
{
this
-
>
prefix
=
_prefix
;
this
-
>
suffix
=
_suffix
;
this
-
>
radix
=
_radix
;
this
-
>
minDigits
=
_minDigits
;
this
-
>
grokSupplementals
=
_grokSupplementals
;
this
-
>
supplementalHandler
=
adoptedSupplementalHandler
;
}
EscapeTransliterator
:
:
EscapeTransliterator
(
const
EscapeTransliterator
&
o
)
:
Transliterator
(
o
)
prefix
(
o
.
prefix
)
suffix
(
o
.
suffix
)
radix
(
o
.
radix
)
minDigits
(
o
.
minDigits
)
grokSupplementals
(
o
.
grokSupplementals
)
{
supplementalHandler
=
(
o
.
supplementalHandler
!
=
0
)
?
new
EscapeTransliterator
(
*
o
.
supplementalHandler
)
:
nullptr
;
}
EscapeTransliterator
:
:
~
EscapeTransliterator
(
)
{
delete
supplementalHandler
;
}
EscapeTransliterator
*
EscapeTransliterator
:
:
clone
(
)
const
{
return
new
EscapeTransliterator
(
*
this
)
;
}
void
EscapeTransliterator
:
:
handleTransliterate
(
Replaceable
&
text
UTransPosition
&
pos
UBool
)
const
{
int32_t
start
=
pos
.
start
;
int32_t
limit
=
pos
.
limit
;
UnicodeString
buf
(
prefix
)
;
int32_t
prefixLen
=
prefix
.
length
(
)
;
UBool
redoPrefix
=
false
;
while
(
start
<
limit
)
{
int32_t
c
=
grokSupplementals
?
text
.
char32At
(
start
)
:
text
.
charAt
(
start
)
;
int32_t
charLen
=
grokSupplementals
?
U16_LENGTH
(
c
)
:
1
;
if
(
(
c
&
0xFFFF0000
)
!
=
0
&
&
supplementalHandler
!
=
nullptr
)
{
buf
.
truncate
(
0
)
;
buf
.
append
(
supplementalHandler
-
>
prefix
)
;
ICU_Utility
:
:
appendNumber
(
buf
c
supplementalHandler
-
>
radix
supplementalHandler
-
>
minDigits
)
;
buf
.
append
(
supplementalHandler
-
>
suffix
)
;
redoPrefix
=
true
;
}
else
{
if
(
redoPrefix
)
{
buf
.
truncate
(
0
)
;
buf
.
append
(
prefix
)
;
redoPrefix
=
false
;
}
else
{
buf
.
truncate
(
prefixLen
)
;
}
ICU_Utility
:
:
appendNumber
(
buf
c
radix
minDigits
)
;
buf
.
append
(
suffix
)
;
}
text
.
handleReplaceBetween
(
start
start
+
charLen
buf
)
;
start
+
=
buf
.
length
(
)
;
limit
+
=
buf
.
length
(
)
-
charLen
;
}
pos
.
contextLimit
+
=
limit
-
pos
.
limit
;
pos
.
limit
=
limit
;
pos
.
start
=
start
;
}
U_NAMESPACE_END
#
endif
