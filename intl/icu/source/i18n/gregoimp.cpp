#
include
"
gregoimp
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
ucal
.
h
"
#
include
"
uresimp
.
h
"
#
include
"
cstring
.
h
"
#
include
"
uassert
.
h
"
U_NAMESPACE_BEGIN
int32_t
ClockMath
:
:
floorDivide
(
int32_t
numerator
int32_t
denominator
)
{
return
(
numerator
>
=
0
)
?
numerator
/
denominator
:
(
(
numerator
+
1
)
/
denominator
)
-
1
;
}
int64_t
ClockMath
:
:
floorDivide
(
int64_t
numerator
int64_t
denominator
)
{
return
(
numerator
>
=
0
)
?
numerator
/
denominator
:
(
(
numerator
+
1
)
/
denominator
)
-
1
;
}
int32_t
ClockMath
:
:
floorDivide
(
double
numerator
int32_t
denominator
int32_t
*
remainder
)
{
double
quotient
=
uprv_floor
(
numerator
/
denominator
)
;
if
(
remainder
!
=
nullptr
)
{
*
remainder
=
(
int32_t
)
(
uprv_floor
(
numerator
)
-
(
quotient
*
denominator
)
)
;
}
return
(
int32_t
)
quotient
;
}
double
ClockMath
:
:
floorDivide
(
double
dividend
double
divisor
double
*
remainder
)
{
U_ASSERT
(
divisor
>
0
)
;
double
quotient
=
floorDivide
(
dividend
divisor
)
;
double
r
=
dividend
-
(
quotient
*
divisor
)
;
if
(
r
<
0
|
|
r
>
=
divisor
)
{
double
q
=
quotient
;
quotient
+
=
(
r
<
0
)
?
-
1
:
+
1
;
if
(
q
=
=
quotient
)
{
r
=
0
;
}
else
{
r
=
dividend
-
(
quotient
*
divisor
)
;
}
}
U_ASSERT
(
0
<
=
r
&
&
r
<
divisor
)
;
if
(
remainder
!
=
nullptr
)
{
*
remainder
=
r
;
}
return
quotient
;
}
const
int32_t
JULIAN_1_CE
=
1721426
;
const
int32_t
JULIAN_1970_CE
=
2440588
;
const
int16_t
Grego
:
:
DAYS_BEFORE
[
24
]
=
{
0
31
59
90
120
151
181
212
243
273
304
334
0
31
60
91
121
152
182
213
244
274
305
335
}
;
const
int8_t
Grego
:
:
MONTH_LENGTH
[
24
]
=
{
31
28
31
30
31
30
31
31
30
31
30
31
31
29
31
30
31
30
31
31
30
31
30
31
}
;
double
Grego
:
:
fieldsToDay
(
int32_t
year
int32_t
month
int32_t
dom
)
{
int32_t
y
=
year
-
1
;
double
julian
=
365
*
y
+
ClockMath
:
:
floorDivide
(
y
4
)
+
(
JULIAN_1_CE
-
3
)
+
ClockMath
:
:
floorDivide
(
y
400
)
-
ClockMath
:
:
floorDivide
(
y
100
)
+
2
+
DAYS_BEFORE
[
month
+
(
isLeapYear
(
year
)
?
12
:
0
)
]
+
dom
;
return
julian
-
JULIAN_1970_CE
;
}
void
Grego
:
:
dayToFields
(
double
day
int32_t
&
year
int32_t
&
month
int32_t
&
dom
int32_t
&
dow
int32_t
&
doy
)
{
day
+
=
JULIAN_1970_CE
-
JULIAN_1_CE
;
int32_t
n400
=
ClockMath
:
:
floorDivide
(
day
146097
&
doy
)
;
int32_t
n100
=
ClockMath
:
:
floorDivide
(
doy
36524
&
doy
)
;
int32_t
n4
=
ClockMath
:
:
floorDivide
(
doy
1461
&
doy
)
;
int32_t
n1
=
ClockMath
:
:
floorDivide
(
doy
365
&
doy
)
;
year
=
400
*
n400
+
100
*
n100
+
4
*
n4
+
n1
;
if
(
n100
=
=
4
|
|
n1
=
=
4
)
{
doy
=
365
;
}
else
{
+
+
year
;
}
UBool
isLeap
=
isLeapYear
(
year
)
;
dow
=
(
int32_t
)
uprv_fmod
(
day
+
1
7
)
;
dow
+
=
(
dow
<
0
)
?
(
UCAL_SUNDAY
+
7
)
:
UCAL_SUNDAY
;
int32_t
correction
=
0
;
int32_t
march1
=
isLeap
?
60
:
59
;
if
(
doy
>
=
march1
)
{
correction
=
isLeap
?
1
:
2
;
}
month
=
(
12
*
(
doy
+
correction
)
+
6
)
/
367
;
dom
=
doy
-
DAYS_BEFORE
[
month
+
(
isLeap
?
12
:
0
)
]
+
1
;
doy
+
+
;
}
void
Grego
:
:
timeToFields
(
UDate
time
int32_t
&
year
int32_t
&
month
int32_t
&
dom
int32_t
&
dow
int32_t
&
doy
int32_t
&
mid
)
{
double
millisInDay
;
double
day
=
ClockMath
:
:
floorDivide
(
(
double
)
time
(
double
)
U_MILLIS_PER_DAY
&
millisInDay
)
;
mid
=
(
int32_t
)
millisInDay
;
dayToFields
(
day
year
month
dom
dow
doy
)
;
}
int32_t
Grego
:
:
dayOfWeek
(
double
day
)
{
int32_t
dow
;
ClockMath
:
:
floorDivide
(
day
+
int
{
UCAL_THURSDAY
}
7
&
dow
)
;
return
(
dow
=
=
0
)
?
UCAL_SATURDAY
:
dow
;
}
int32_t
Grego
:
:
dayOfWeekInMonth
(
int32_t
year
int32_t
month
int32_t
dom
)
{
int32_t
weekInMonth
=
(
dom
+
6
)
/
7
;
if
(
weekInMonth
=
=
4
)
{
if
(
dom
+
7
>
monthLength
(
year
month
)
)
{
weekInMonth
=
-
1
;
}
}
else
if
(
weekInMonth
=
=
5
)
{
weekInMonth
=
-
1
;
}
return
weekInMonth
;
}
U_NAMESPACE_END
#
endif
