#
ifndef
__AFFIX_PATTERN_PARSER_H__
#
define
__AFFIX_PATTERN_PARSER_H__
#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
unistr
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
pluralaffix
.
h
"
U_NAMESPACE_BEGIN
class
PluralRules
;
class
FixedPrecision
;
class
DecimalFormatSymbols
;
class
U_I18N_API
CurrencyAffixInfo
:
public
UMemory
{
public
:
CurrencyAffixInfo
(
)
;
const
UnicodeString
&
getSymbol
(
)
const
{
return
fSymbol
;
}
const
UnicodeString
&
getISO
(
)
const
{
return
fISO
;
}
const
PluralAffix
&
getLong
(
)
const
{
return
fLong
;
}
void
setSymbol
(
const
UnicodeString
&
symbol
)
{
fSymbol
=
symbol
;
fIsDefault
=
FALSE
;
}
void
setISO
(
const
UnicodeString
&
iso
)
{
fISO
=
iso
;
fIsDefault
=
FALSE
;
}
UBool
equals
(
const
CurrencyAffixInfo
&
other
)
const
{
return
(
fSymbol
=
=
other
.
fSymbol
)
&
&
(
fISO
=
=
other
.
fISO
)
&
&
(
fLong
.
equals
(
other
.
fLong
)
)
&
&
(
fIsDefault
=
=
other
.
fIsDefault
)
;
}
void
set
(
const
char
*
locale
const
PluralRules
*
rules
const
UChar
*
currency
UErrorCode
&
status
)
;
UBool
isDefault
(
)
const
{
return
fIsDefault
;
}
static
void
adjustPrecision
(
const
UChar
*
currency
const
UCurrencyUsage
usage
FixedPrecision
&
precision
UErrorCode
&
status
)
;
private
:
UnicodeString
fSymbol
;
UnicodeString
fISO
;
PluralAffix
fLong
;
UBool
fIsDefault
;
}
;
class
AffixPatternIterator
;
class
U_I18N_API
AffixPattern
:
public
UMemory
{
public
:
enum
ETokenType
{
kLiteral
kPercent
kPerMill
kCurrency
kNegative
kPositive
}
;
AffixPattern
(
)
:
tokens
(
)
literals
(
)
hasCurrencyToken
(
FALSE
)
hasPercentToken
(
FALSE
)
hasPermillToken
(
FALSE
)
char32Count
(
0
)
{
}
void
addLiteral
(
const
UChar
*
int32_t
start
int32_t
len
)
;
void
add
(
ETokenType
t
)
;
void
addCurrency
(
uint8_t
count
)
;
void
remove
(
)
;
AffixPatternIterator
&
iterator
(
AffixPatternIterator
&
result
)
const
;
UBool
usesCurrency
(
)
const
{
return
hasCurrencyToken
;
}
UBool
usesPercent
(
)
const
{
return
hasPercentToken
;
}
UBool
usesPermill
(
)
const
{
return
hasPermillToken
;
}
int32_t
countChar32
(
)
const
{
return
char32Count
;
}
AffixPattern
&
append
(
const
AffixPattern
&
other
)
;
UnicodeString
&
toUserString
(
UnicodeString
&
appendTo
)
const
;
UnicodeString
&
toString
(
UnicodeString
&
appendTo
)
const
;
static
AffixPattern
&
parseAffixString
(
const
UnicodeString
&
affixStr
AffixPattern
&
appendTo
UErrorCode
&
status
)
;
static
AffixPattern
&
parseUserAffixString
(
const
UnicodeString
&
affixStr
AffixPattern
&
appendTo
UErrorCode
&
status
)
;
UBool
equals
(
const
AffixPattern
&
other
)
const
{
return
(
tokens
=
=
other
.
tokens
)
&
&
(
literals
=
=
other
.
literals
)
&
&
(
hasCurrencyToken
=
=
other
.
hasCurrencyToken
)
&
&
(
hasPercentToken
=
=
other
.
hasPercentToken
)
&
&
(
hasPermillToken
=
=
other
.
hasPermillToken
)
&
&
(
char32Count
=
=
other
.
char32Count
)
;
}
private
:
UnicodeString
tokens
;
UnicodeString
literals
;
UBool
hasCurrencyToken
;
UBool
hasPercentToken
;
UBool
hasPermillToken
;
int32_t
char32Count
;
void
add
(
ETokenType
t
uint8_t
count
)
;
}
;
class
U_I18N_API
AffixPatternIterator
:
public
UMemory
{
public
:
AffixPatternIterator
(
)
:
nextLiteralIndex
(
0
)
lastLiteralLength
(
0
)
nextTokenIndex
(
0
)
tokens
(
NULL
)
literals
(
NULL
)
{
}
UBool
nextToken
(
)
;
AffixPattern
:
:
ETokenType
getTokenType
(
)
const
;
UnicodeString
&
getLiteral
(
UnicodeString
&
result
)
const
;
int32_t
getTokenLength
(
)
const
;
private
:
int32_t
nextLiteralIndex
;
int32_t
lastLiteralLength
;
int32_t
nextTokenIndex
;
const
UnicodeString
*
tokens
;
const
UnicodeString
*
literals
;
friend
class
AffixPattern
;
AffixPatternIterator
(
const
AffixPatternIterator
&
)
;
AffixPatternIterator
&
operator
=
(
const
AffixPatternIterator
&
)
;
}
;
class
U_I18N_API
AffixPatternParser
:
public
UMemory
{
public
:
AffixPatternParser
(
)
;
AffixPatternParser
(
const
DecimalFormatSymbols
&
symbols
)
;
void
setDecimalFormatSymbols
(
const
DecimalFormatSymbols
&
symbols
)
;
PluralAffix
&
parse
(
const
AffixPattern
&
affixPattern
const
CurrencyAffixInfo
&
currencyAffixInfo
PluralAffix
&
appendTo
UErrorCode
&
status
)
const
;
UBool
equals
(
const
AffixPatternParser
&
other
)
const
{
return
(
fPercent
=
=
other
.
fPercent
)
&
&
(
fPermill
=
=
other
.
fPermill
)
&
&
(
fNegative
=
=
other
.
fNegative
)
&
&
(
fPositive
=
=
other
.
fPositive
)
;
}
private
:
UnicodeString
fPercent
;
UnicodeString
fPermill
;
UnicodeString
fNegative
;
UnicodeString
fPositive
;
}
;
U_NAMESPACE_END
#
endif
#
endif
