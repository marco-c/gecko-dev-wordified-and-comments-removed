#
ifndef
GREGOIMP_H
#
define
GREGOIMP_H
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
calendar
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
ures
.
h
"
#
include
"
unicode
/
locid
.
h
"
#
include
"
putilimp
.
h
"
U_NAMESPACE_BEGIN
class
ClockMath
{
public
:
static
int32_t
floorDivide
(
int32_t
numerator
int32_t
denominator
)
;
static
int64_t
floorDivideInt64
(
int64_t
numerator
int64_t
denominator
)
;
static
inline
double
floorDivide
(
double
numerator
double
denominator
)
;
static
int32_t
floorDivide
(
int32_t
numerator
int32_t
denominator
int32_t
*
remainder
)
;
static
double
floorDivide
(
double
numerator
int32_t
denominator
int32_t
*
remainder
)
;
static
double
floorDivide
(
double
dividend
double
divisor
double
*
remainder
)
;
}
;
#
define
kOneDay
(
1
.
0
*
U_MILLIS_PER_DAY
)
/
/
86
400
000
#
define
kOneHour
(
60
*
60
*
1000
)
#
define
kOneMinute
60000
#
define
kOneSecond
1000
#
define
kOneMillisecond
1
#
define
kOneWeek
(
7
.
0
*
kOneDay
)
/
/
604
800
000
#
define
kJan1_1JulianDay
1721426
/
/
January
1
year
1
(
Gregorian
)
#
define
kEpochStartAsJulianDay
2440588
/
/
January
1
1970
(
Gregorian
)
#
define
kEpochYear
1970
#
define
kEarliestViableMillis
-
185331720384000000
.
0
/
/
minimum
representable
by
julian
day
-
1e17
#
define
kLatestViableMillis
185753453990400000
.
0
/
/
max
representable
by
julian
day
+
1e17
#
define
MIN_JULIAN
(
-
0x7F000000
)
#
define
MIN_MILLIS
(
(
MIN_JULIAN
-
kEpochStartAsJulianDay
)
*
kOneDay
)
#
define
MAX_JULIAN
(
+
0x7F000000
)
#
define
MAX_MILLIS
(
(
MAX_JULIAN
-
kEpochStartAsJulianDay
)
*
kOneDay
)
class
Grego
{
public
:
static
inline
UBool
isLeapYear
(
int32_t
year
)
;
static
inline
int8_t
monthLength
(
int32_t
year
int32_t
month
)
;
static
inline
int8_t
previousMonthLength
(
int
y
int
m
)
;
static
int64_t
fieldsToDay
(
int32_t
year
int32_t
month
int32_t
dom
)
;
static
void
dayToFields
(
int32_t
day
int32_t
&
year
int8_t
&
month
int8_t
&
dom
int8_t
&
dow
int16_t
&
doy
UErrorCode
&
status
)
;
static
int32_t
dayToYear
(
int32_t
day
UErrorCode
&
status
)
;
static
int32_t
dayToYear
(
int32_t
day
int16_t
&
doy
UErrorCode
&
status
)
;
static
void
timeToFields
(
UDate
time
int32_t
&
year
int8_t
&
month
int8_t
&
dom
int8_t
&
dow
int16_t
&
doy
int32_t
&
mid
UErrorCode
&
status
)
;
static
void
timeToFields
(
UDate
time
int32_t
&
year
int8_t
&
month
int8_t
&
dom
int8_t
&
dow
int32_t
&
mid
UErrorCode
&
status
)
;
static
void
timeToFields
(
UDate
time
int32_t
&
year
int8_t
&
month
int8_t
&
dom
int32_t
&
mid
UErrorCode
&
status
)
;
static
int32_t
timeToYear
(
UDate
time
UErrorCode
&
status
)
;
static
int32_t
dayOfWeek
(
int32_t
day
)
;
static
int32_t
dayOfWeekInMonth
(
int32_t
year
int32_t
month
int32_t
dom
)
;
static
inline
double
julianDayToMillis
(
int32_t
julian
)
;
static
inline
int32_t
millisToJulianDay
(
double
millis
)
;
static
inline
int32_t
gregorianShift
(
int32_t
eyear
)
;
private
:
static
const
int16_t
DAYS_BEFORE
[
24
]
;
static
const
int8_t
MONTH_LENGTH
[
24
]
;
}
;
inline
double
ClockMath
:
:
floorDivide
(
double
numerator
double
denominator
)
{
return
uprv_floor
(
numerator
/
denominator
)
;
}
inline
UBool
Grego
:
:
isLeapYear
(
int32_t
year
)
{
return
(
(
year
&
0x3
)
=
=
0
)
&
&
(
(
year
%
100
!
=
0
)
|
|
(
year
%
400
=
=
0
)
)
;
}
inline
int8_t
Grego
:
:
monthLength
(
int32_t
year
int32_t
month
)
{
return
MONTH_LENGTH
[
month
+
(
isLeapYear
(
year
)
?
12
:
0
)
]
;
}
inline
int8_t
Grego
:
:
previousMonthLength
(
int
y
int
m
)
{
return
(
m
>
0
)
?
monthLength
(
y
m
-
1
)
:
31
;
}
inline
double
Grego
:
:
julianDayToMillis
(
int32_t
julian
)
{
return
(
static_cast
<
double
>
(
julian
)
-
kEpochStartAsJulianDay
)
*
kOneDay
;
}
inline
int32_t
Grego
:
:
millisToJulianDay
(
double
millis
)
{
return
static_cast
<
int32_t
>
(
kEpochStartAsJulianDay
+
ClockMath
:
:
floorDivide
(
millis
kOneDay
)
)
;
}
inline
int32_t
Grego
:
:
gregorianShift
(
int32_t
eyear
)
{
int64_t
y
=
static_cast
<
int64_t
>
(
eyear
)
-
1
;
int64_t
gregShift
=
ClockMath
:
:
floorDivideInt64
(
y
400LL
)
-
ClockMath
:
:
floorDivideInt64
(
y
100LL
)
+
2
;
return
static_cast
<
int32_t
>
(
gregShift
)
;
}
#
define
IMPL_SYSTEM_DEFAULT_CENTURY
(
T
U
)
\
namespace
{
\
static
UDate
gSystemDefaultCenturyStart
=
DBL_MIN
;
\
static
int32_t
gSystemDefaultCenturyStartYear
=
-
1
;
\
static
icu
:
:
UInitOnce
gSystemDefaultCenturyInit
{
}
;
\
static
void
U_CALLCONV
\
initializeSystemDefaultCentury
(
)
{
\
UErrorCode
status
=
U_ZERO_ERROR
;
\
T
calendar
(
U
status
)
;
\
/
*
initialize
systemDefaultCentury
and
systemDefaultCenturyYear
based
*
/
\
/
*
on
the
current
time
.
They
'
ll
be
set
to
80
years
before
*
/
\
/
*
the
current
time
.
*
/
\
if
(
U_FAILURE
(
status
)
)
{
\
return
;
\
}
\
calendar
.
setTime
(
Calendar
:
:
getNow
(
)
status
)
;
\
calendar
.
add
(
UCAL_YEAR
-
80
status
)
;
\
gSystemDefaultCenturyStart
=
calendar
.
getTime
(
status
)
;
\
gSystemDefaultCenturyStartYear
=
calendar
.
get
(
UCAL_YEAR
status
)
;
\
/
*
We
have
no
recourse
upon
failure
unless
we
want
to
propagate
the
*
/
\
/
*
failure
out
.
*
/
\
}
\
}
/
*
namespace
*
/
\
UDate
T
:
:
defaultCenturyStart
(
)
const
{
\
/
*
lazy
-
evaluate
systemDefaultCenturyStart
*
/
\
umtx_initOnce
(
gSystemDefaultCenturyInit
&
initializeSystemDefaultCentury
)
;
\
return
gSystemDefaultCenturyStart
;
\
}
\
int32_t
T
:
:
defaultCenturyStartYear
(
)
const
{
\
/
*
lazy
-
evaluate
systemDefaultCenturyStart
*
/
\
umtx_initOnce
(
gSystemDefaultCenturyInit
&
initializeSystemDefaultCentury
)
;
\
return
gSystemDefaultCenturyStartYear
;
\
}
\
UBool
T
:
:
haveDefaultCentury
(
)
const
{
return
true
;
}
U_NAMESPACE_END
#
endif
#
endif
