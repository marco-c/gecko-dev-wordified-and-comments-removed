#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
if
!
UCONFIG_NO_MF2
#
include
"
messageformat2_allocation
.
h
"
#
include
"
messageformat2_checker
.
h
"
#
include
"
messageformat2_macros
.
h
"
#
include
"
uvector
.
h
"
U_NAMESPACE_BEGIN
namespace
message2
{
TypeEnvironment
:
:
TypeEnvironment
(
UErrorCode
&
status
)
{
CHECK_ERROR
(
status
)
;
UVector
*
temp
;
temp
=
createStringVectorNoAdopt
(
status
)
;
CHECK_ERROR
(
status
)
;
annotated
.
adoptInstead
(
temp
)
;
temp
=
createStringVectorNoAdopt
(
status
)
;
CHECK_ERROR
(
status
)
;
unannotated
.
adoptInstead
(
temp
)
;
temp
=
createStringVectorNoAdopt
(
status
)
;
CHECK_ERROR
(
status
)
;
freeVars
.
adoptInstead
(
temp
)
;
}
static
bool
has
(
const
UVector
&
v
const
VariableName
&
var
)
{
return
v
.
contains
(
const_cast
<
void
*
>
(
static_cast
<
const
void
*
>
(
&
var
)
)
)
;
}
bool
TypeEnvironment
:
:
known
(
const
VariableName
&
var
)
const
{
return
has
(
*
annotated
var
)
|
|
has
(
*
unannotated
var
)
|
|
has
(
*
freeVars
var
)
;
}
TypeEnvironment
:
:
Type
TypeEnvironment
:
:
get
(
const
VariableName
&
var
)
const
{
U_ASSERT
(
annotated
.
isValid
(
)
)
;
if
(
has
(
*
annotated
var
)
)
{
return
Annotated
;
}
U_ASSERT
(
unannotated
.
isValid
(
)
)
;
if
(
has
(
*
unannotated
var
)
)
{
return
Unannotated
;
}
U_ASSERT
(
freeVars
.
isValid
(
)
)
;
if
(
has
(
*
freeVars
var
)
)
{
return
FreeVariable
;
}
return
Unannotated
;
}
void
TypeEnvironment
:
:
extend
(
const
VariableName
&
var
TypeEnvironment
:
:
Type
t
UErrorCode
&
status
)
{
if
(
t
=
=
Unannotated
)
{
U_ASSERT
(
unannotated
.
isValid
(
)
)
;
unannotated
-
>
addElement
(
const_cast
<
void
*
>
(
static_cast
<
const
void
*
>
(
&
var
)
)
status
)
;
return
;
}
if
(
t
=
=
FreeVariable
)
{
U_ASSERT
(
freeVars
.
isValid
(
)
)
;
freeVars
-
>
addElement
(
const_cast
<
void
*
>
(
static_cast
<
const
void
*
>
(
&
var
)
)
status
)
;
return
;
}
U_ASSERT
(
annotated
.
isValid
(
)
)
;
annotated
-
>
addElement
(
const_cast
<
void
*
>
(
static_cast
<
const
void
*
>
(
&
var
)
)
status
)
;
}
TypeEnvironment
:
:
~
TypeEnvironment
(
)
{
}
static
bool
areDefaultKeys
(
const
Key
*
keys
int32_t
len
)
{
U_ASSERT
(
len
>
0
)
;
for
(
int32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
keys
[
i
]
.
isWildcard
(
)
)
{
return
false
;
}
}
return
true
;
}
void
Checker
:
:
addFreeVars
(
TypeEnvironment
&
t
const
Operand
&
rand
UErrorCode
&
status
)
{
CHECK_ERROR
(
status
)
;
if
(
rand
.
isVariable
(
)
)
{
const
VariableName
&
v
=
rand
.
asVariable
(
)
;
if
(
!
t
.
known
(
v
)
)
{
t
.
extend
(
v
TypeEnvironment
:
:
Type
:
:
FreeVariable
status
)
;
}
}
}
void
Checker
:
:
addFreeVars
(
TypeEnvironment
&
t
const
OptionMap
&
opts
UErrorCode
&
status
)
{
for
(
int32_t
i
=
0
;
i
<
opts
.
size
(
)
;
i
+
+
)
{
const
Option
&
o
=
opts
.
getOption
(
i
status
)
;
CHECK_ERROR
(
status
)
;
addFreeVars
(
t
o
.
getValue
(
)
status
)
;
}
}
void
Checker
:
:
addFreeVars
(
TypeEnvironment
&
t
const
Operator
&
rator
UErrorCode
&
status
)
{
CHECK_ERROR
(
status
)
;
addFreeVars
(
t
rator
.
getOptionsInternal
(
)
status
)
;
}
void
Checker
:
:
addFreeVars
(
TypeEnvironment
&
t
const
Expression
&
rhs
UErrorCode
&
status
)
{
CHECK_ERROR
(
status
)
;
if
(
rhs
.
isFunctionCall
(
)
)
{
const
Operator
*
rator
=
rhs
.
getOperator
(
status
)
;
U_ASSERT
(
U_SUCCESS
(
status
)
)
;
addFreeVars
(
t
*
rator
status
)
;
}
addFreeVars
(
t
rhs
.
getOperand
(
)
status
)
;
}
void
Checker
:
:
checkVariants
(
UErrorCode
&
status
)
{
CHECK_ERROR
(
status
)
;
U_ASSERT
(
!
dataModel
.
hasPattern
(
)
)
;
const
Variant
*
variants
=
dataModel
.
getVariantsInternal
(
)
;
bool
defaultExists
=
false
;
bool
duplicatesExist
=
false
;
for
(
int32_t
i
=
0
;
i
<
dataModel
.
numVariants
(
)
;
i
+
+
)
{
const
SelectorKeys
&
k
=
variants
[
i
]
.
getKeys
(
)
;
const
Key
*
keys
=
k
.
getKeysInternal
(
)
;
int32_t
len
=
k
.
len
;
if
(
len
!
=
dataModel
.
numSelectors
(
)
)
{
errors
.
addError
(
StaticErrorType
:
:
VariantKeyMismatchError
status
)
;
return
;
}
defaultExists
|
=
areDefaultKeys
(
keys
len
)
;
if
(
!
duplicatesExist
)
{
for
(
int32_t
j
=
0
;
j
<
i
;
j
+
+
)
{
const
SelectorKeys
&
k1
=
variants
[
j
]
.
getKeys
(
)
;
const
Key
*
keys1
=
k1
.
getKeysInternal
(
)
;
bool
allEqual
=
true
;
for
(
int32_t
kk
=
0
;
kk
<
len
;
kk
+
+
)
{
if
(
!
(
keys
[
kk
]
=
=
keys1
[
kk
]
)
)
{
allEqual
=
false
;
break
;
}
}
if
(
allEqual
)
{
duplicatesExist
=
true
;
}
}
}
}
if
(
duplicatesExist
)
{
errors
.
addError
(
StaticErrorType
:
:
DuplicateVariant
status
)
;
}
if
(
!
defaultExists
)
{
errors
.
addError
(
StaticErrorType
:
:
NonexhaustivePattern
status
)
;
}
}
void
Checker
:
:
requireAnnotated
(
const
TypeEnvironment
&
t
const
Expression
&
selectorExpr
UErrorCode
&
status
)
{
CHECK_ERROR
(
status
)
;
if
(
selectorExpr
.
isFunctionCall
(
)
)
{
return
;
}
const
Operand
&
rand
=
selectorExpr
.
getOperand
(
)
;
if
(
rand
.
isVariable
(
)
)
{
if
(
t
.
get
(
rand
.
asVariable
(
)
)
=
=
TypeEnvironment
:
:
Type
:
:
Annotated
)
{
return
;
}
}
errors
.
addError
(
StaticErrorType
:
:
MissingSelectorAnnotation
status
)
;
}
void
Checker
:
:
checkSelectors
(
const
TypeEnvironment
&
t
UErrorCode
&
status
)
{
U_ASSERT
(
!
dataModel
.
hasPattern
(
)
)
;
const
Expression
*
selectors
=
dataModel
.
getSelectorsInternal
(
)
;
for
(
int32_t
i
=
0
;
i
<
dataModel
.
numSelectors
(
)
;
i
+
+
)
{
requireAnnotated
(
t
selectors
[
i
]
status
)
;
}
}
TypeEnvironment
:
:
Type
typeOf
(
TypeEnvironment
&
t
const
Expression
&
expr
)
{
if
(
expr
.
isFunctionCall
(
)
)
{
return
TypeEnvironment
:
:
Type
:
:
Annotated
;
}
const
Operand
&
rand
=
expr
.
getOperand
(
)
;
U_ASSERT
(
!
rand
.
isNull
(
)
)
;
if
(
rand
.
isLiteral
(
)
)
{
return
TypeEnvironment
:
:
Type
:
:
Unannotated
;
}
U_ASSERT
(
rand
.
isVariable
(
)
)
;
return
t
.
get
(
rand
.
asVariable
(
)
)
;
}
void
Checker
:
:
checkDeclarations
(
TypeEnvironment
&
t
UErrorCode
&
status
)
{
CHECK_ERROR
(
status
)
;
const
Binding
*
env
=
dataModel
.
getLocalVariablesInternal
(
)
;
for
(
int32_t
i
=
0
;
i
<
dataModel
.
bindingsLen
;
i
+
+
)
{
const
Binding
&
b
=
env
[
i
]
;
const
VariableName
&
lhs
=
b
.
getVariable
(
)
;
const
Expression
&
rhs
=
b
.
getValue
(
)
;
if
(
b
.
isLocal
(
)
)
{
addFreeVars
(
t
rhs
status
)
;
if
(
t
.
known
(
lhs
)
&
&
t
.
get
(
lhs
)
=
=
TypeEnvironment
:
:
Type
:
:
FreeVariable
)
{
errors
.
addError
(
StaticErrorType
:
:
DuplicateDeclarationError
status
)
;
}
}
else
{
if
(
!
b
.
isLocal
(
)
&
&
b
.
hasAnnotation
(
)
)
{
const
OptionMap
&
opts
=
b
.
getOptionsInternal
(
)
;
addFreeVars
(
t
opts
status
)
;
}
if
(
t
.
known
(
lhs
)
&
&
t
.
get
(
lhs
)
=
=
TypeEnvironment
:
:
Type
:
:
FreeVariable
)
{
errors
.
addError
(
StaticErrorType
:
:
DuplicateDeclarationError
status
)
;
}
}
t
.
extend
(
lhs
typeOf
(
t
rhs
)
status
)
;
}
}
void
Checker
:
:
check
(
UErrorCode
&
status
)
{
CHECK_ERROR
(
status
)
;
TypeEnvironment
typeEnv
(
status
)
;
checkDeclarations
(
typeEnv
status
)
;
if
(
dataModel
.
hasPattern
(
)
)
{
return
;
}
else
{
checkSelectors
(
typeEnv
status
)
;
checkVariants
(
status
)
;
}
}
}
U_NAMESPACE_END
#
endif
#
endif
