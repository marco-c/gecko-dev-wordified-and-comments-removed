#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
if
!
UCONFIG_NO_MF2
#
include
"
unicode
/
messageformat2_arguments
.
h
"
#
include
"
unicode
/
messageformat2_data_model
.
h
"
#
include
"
unicode
/
messageformat2_formattable
.
h
"
#
include
"
unicode
/
messageformat2
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
include
"
messageformat2_allocation
.
h
"
#
include
"
messageformat2_evaluation
.
h
"
#
include
"
messageformat2_macros
.
h
"
U_NAMESPACE_BEGIN
namespace
message2
{
using
namespace
data_model
;
static
Formattable
evalLiteral
(
const
Literal
&
lit
)
{
return
Formattable
(
lit
.
unquoted
(
)
)
;
}
[
[
nodiscard
]
]
FormattedPlaceholder
MessageFormatter
:
:
evalArgument
(
const
VariableName
&
var
MessageContext
&
context
UErrorCode
&
errorCode
)
const
{
if
(
U_SUCCESS
(
errorCode
)
)
{
UnicodeString
str
(
DOLLAR
)
;
str
+
=
var
;
const
Formattable
*
val
=
context
.
getGlobal
(
var
errorCode
)
;
if
(
U_SUCCESS
(
errorCode
)
)
{
return
(
FormattedPlaceholder
(
*
val
str
)
)
;
}
}
return
{
}
;
}
[
[
nodiscard
]
]
FormattedPlaceholder
MessageFormatter
:
:
formatLiteral
(
const
Literal
&
lit
)
const
{
return
FormattedPlaceholder
(
evalLiteral
(
lit
)
lit
.
quoted
(
)
)
;
}
[
[
nodiscard
]
]
FormattedPlaceholder
MessageFormatter
:
:
formatOperand
(
const
Environment
&
env
const
Operand
&
rand
MessageContext
&
context
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
if
(
rand
.
isNull
(
)
)
{
return
FormattedPlaceholder
(
)
;
}
if
(
rand
.
isVariable
(
)
)
{
const
VariableName
&
var
=
rand
.
asVariable
(
)
;
if
(
env
.
has
(
var
)
)
{
const
Closure
&
rhs
=
env
.
lookup
(
var
)
;
return
formatExpression
(
rhs
.
getEnv
(
)
rhs
.
getExpr
(
)
context
status
)
;
}
FormattedPlaceholder
result
=
evalArgument
(
var
context
status
)
;
if
(
status
=
=
U_ILLEGAL_ARGUMENT_ERROR
)
{
status
=
U_ZERO_ERROR
;
context
.
getErrors
(
)
.
setUnresolvedVariable
(
var
status
)
;
UnicodeString
str
(
DOLLAR
)
;
str
+
=
var
;
return
FormattedPlaceholder
(
str
)
;
}
return
result
;
}
else
{
U_ASSERT
(
rand
.
isLiteral
(
)
)
;
return
formatLiteral
(
rand
.
asLiteral
(
)
)
;
}
}
FunctionOptions
MessageFormatter
:
:
resolveOptions
(
const
Environment
&
env
const
OptionMap
&
options
MessageContext
&
context
UErrorCode
&
status
)
const
{
LocalPointer
<
UVector
>
optionsVector
(
createUVector
(
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
LocalPointer
<
ResolvedFunctionOption
>
resolvedOpt
;
for
(
int
i
=
0
;
i
<
options
.
size
(
)
;
i
+
+
)
{
const
Option
&
opt
=
options
.
getOption
(
i
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
const
UnicodeString
&
k
=
opt
.
getName
(
)
;
const
Operand
&
v
=
opt
.
getValue
(
)
;
FormattedPlaceholder
rhsVal
=
formatOperand
(
env
v
context
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
if
(
!
rhsVal
.
isFallback
(
)
)
{
resolvedOpt
.
adoptInstead
(
create
<
ResolvedFunctionOption
>
(
ResolvedFunctionOption
(
k
rhsVal
.
asFormattable
(
)
)
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
optionsVector
-
>
adoptElement
(
resolvedOpt
.
orphan
(
)
status
)
;
}
}
return
FunctionOptions
(
std
:
:
move
(
*
optionsVector
)
status
)
;
}
[
[
nodiscard
]
]
FormattedPlaceholder
MessageFormatter
:
:
evalFormatterCall
(
FormattedPlaceholder
&
&
argument
MessageContext
&
context
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
U_ASSERT
(
!
argument
.
isFallback
(
)
&
&
!
argument
.
isNullOperand
(
)
)
;
const
Formattable
&
toFormat
=
argument
.
asFormattable
(
)
;
switch
(
toFormat
.
getType
(
)
)
{
case
UFMT_OBJECT
:
{
const
FormattableObject
*
obj
=
toFormat
.
getObject
(
status
)
;
U_ASSERT
(
U_SUCCESS
(
status
)
)
;
U_ASSERT
(
obj
!
=
nullptr
)
;
const
UnicodeString
&
type
=
obj
-
>
tag
(
)
;
FunctionName
functionName
;
if
(
!
getDefaultFormatterNameByType
(
type
functionName
)
)
{
break
;
}
return
evalFormatterCall
(
functionName
std
:
:
move
(
argument
)
FunctionOptions
(
)
context
status
)
;
}
default
:
{
break
;
}
}
return
std
:
:
move
(
argument
)
;
}
[
[
nodiscard
]
]
FormattedPlaceholder
MessageFormatter
:
:
evalFormatterCall
(
const
FunctionName
&
functionName
FormattedPlaceholder
&
&
argument
FunctionOptions
&
&
options
MessageContext
&
context
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
DynamicErrors
&
errs
=
context
.
getErrors
(
)
;
UnicodeString
fallback
(
COLON
)
;
fallback
+
=
functionName
;
if
(
!
argument
.
isNullOperand
(
)
)
{
fallback
=
argument
.
fallback
;
}
if
(
isFormatter
(
functionName
)
)
{
LocalPointer
<
Formatter
>
formatterImpl
(
getFormatter
(
functionName
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
if
(
status
=
=
U_MF_FORMATTING_ERROR
)
{
errs
.
setFormattingError
(
functionName
status
)
;
status
=
U_ZERO_ERROR
;
return
{
}
;
}
if
(
status
=
=
U_MF_UNKNOWN_FUNCTION_ERROR
)
{
errs
.
setUnknownFunction
(
functionName
status
)
;
status
=
U_ZERO_ERROR
;
return
{
}
;
}
return
{
}
;
}
U_ASSERT
(
formatterImpl
!
=
nullptr
)
;
UErrorCode
savedStatus
=
status
;
FormattedPlaceholder
result
=
formatterImpl
-
>
format
(
std
:
:
move
(
argument
)
std
:
:
move
(
options
)
status
)
;
if
(
savedStatus
!
=
status
)
{
if
(
U_FAILURE
(
status
)
)
{
if
(
status
=
=
U_MF_OPERAND_MISMATCH_ERROR
)
{
status
=
U_ZERO_ERROR
;
errs
.
setOperandMismatchError
(
functionName
status
)
;
}
else
{
status
=
U_ZERO_ERROR
;
errs
.
setFormattingError
(
functionName
status
)
;
}
return
FormattedPlaceholder
(
fallback
)
;
}
else
{
status
=
savedStatus
;
}
}
if
(
errs
.
hasFormattingError
(
)
)
{
return
FormattedPlaceholder
(
fallback
)
;
}
return
result
;
}
if
(
isSelector
(
functionName
)
)
{
errs
.
setFormattingError
(
functionName
status
)
;
}
else
{
errs
.
setUnknownFunction
(
functionName
status
)
;
}
return
FormattedPlaceholder
(
fallback
)
;
}
[
[
nodiscard
]
]
FormattedPlaceholder
MessageFormatter
:
:
formatExpression
(
const
Environment
&
globalEnv
const
Expression
&
expr
MessageContext
&
context
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
const
Operand
&
rand
=
expr
.
getOperand
(
)
;
FormattedPlaceholder
randVal
=
formatOperand
(
globalEnv
rand
context
status
)
;
if
(
randVal
.
isFallback
(
)
)
{
return
randVal
;
}
if
(
!
expr
.
isFunctionCall
(
)
)
{
return
evalFormatterCall
(
std
:
:
move
(
randVal
)
context
status
)
;
}
else
{
const
Operator
*
rator
=
expr
.
getOperator
(
status
)
;
U_ASSERT
(
U_SUCCESS
(
status
)
)
;
const
FunctionName
&
functionName
=
rator
-
>
getFunctionName
(
)
;
const
OptionMap
&
options
=
rator
-
>
getOptionsInternal
(
)
;
FunctionOptions
resolvedOptions
=
resolveOptions
(
globalEnv
options
context
status
)
;
UnicodeString
fallback
;
if
(
rand
.
isNull
(
)
)
{
fallback
=
UnicodeString
(
COLON
)
;
fallback
+
=
functionName
;
}
else
{
fallback
=
randVal
.
fallback
;
}
return
evalFormatterCall
(
functionName
std
:
:
move
(
randVal
)
std
:
:
move
(
resolvedOptions
)
context
status
)
;
}
}
void
MessageFormatter
:
:
formatPattern
(
MessageContext
&
context
const
Environment
&
globalEnv
const
Pattern
&
pat
UErrorCode
&
status
UnicodeString
&
result
)
const
{
CHECK_ERROR
(
status
)
;
for
(
int32_t
i
=
0
;
i
<
pat
.
numParts
(
)
;
i
+
+
)
{
const
PatternPart
&
part
=
pat
.
getPart
(
i
)
;
if
(
part
.
isText
(
)
)
{
result
+
=
part
.
asText
(
)
;
}
else
if
(
part
.
isMarkup
(
)
)
{
}
else
{
FormattedPlaceholder
partVal
=
formatExpression
(
globalEnv
part
.
contents
(
)
context
status
)
;
UnicodeString
partResult
=
partVal
.
formatToString
(
locale
status
)
;
result
+
=
partResult
;
if
(
status
=
=
U_MF_FORMATTING_ERROR
)
{
status
=
U_ZERO_ERROR
;
context
.
getErrors
(
)
.
setFormattingError
(
status
)
;
}
}
}
}
void
MessageFormatter
:
:
resolveSelectors
(
MessageContext
&
context
const
Environment
&
env
UErrorCode
&
status
UVector
&
res
)
const
{
CHECK_ERROR
(
status
)
;
U_ASSERT
(
!
dataModel
.
hasPattern
(
)
)
;
const
Expression
*
selectors
=
dataModel
.
getSelectorsInternal
(
)
;
for
(
int32_t
i
=
0
;
i
<
dataModel
.
numSelectors
(
)
;
i
+
+
)
{
ResolvedSelector
rv
=
formatSelectorExpression
(
env
selectors
[
i
]
context
status
)
;
if
(
rv
.
hasSelector
(
)
)
{
}
else
{
#
if
U_DEBUG
const
DynamicErrors
&
err
=
context
.
getErrors
(
)
;
U_ASSERT
(
err
.
hasError
(
)
)
;
U_ASSERT
(
rv
.
argument
(
)
.
isFallback
(
)
)
;
#
endif
}
LocalPointer
<
ResolvedSelector
>
v
(
create
<
ResolvedSelector
>
(
std
:
:
move
(
rv
)
status
)
)
;
CHECK_ERROR
(
status
)
;
res
.
adoptElement
(
v
.
orphan
(
)
status
)
;
}
}
void
MessageFormatter
:
:
matchSelectorKeys
(
const
UVector
&
keys
MessageContext
&
context
ResolvedSelector
&
&
rv
UVector
&
keysOut
UErrorCode
&
status
)
const
{
CHECK_ERROR
(
status
)
;
if
(
!
rv
.
hasSelector
(
)
)
{
return
;
}
auto
selectorImpl
=
rv
.
getSelector
(
)
;
U_ASSERT
(
selectorImpl
!
=
nullptr
)
;
UErrorCode
savedStatus
=
status
;
int32_t
keysLen
=
keys
.
size
(
)
;
UnicodeString
*
keysArr
=
new
UnicodeString
[
keysLen
]
;
if
(
keysArr
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
for
(
int32_t
i
=
0
;
i
<
keysLen
;
i
+
+
)
{
const
UnicodeString
*
k
=
static_cast
<
UnicodeString
*
>
(
keys
[
i
]
)
;
U_ASSERT
(
k
!
=
nullptr
)
;
keysArr
[
i
]
=
*
k
;
}
LocalArray
<
UnicodeString
>
adoptedKeys
(
keysArr
)
;
UnicodeString
*
prefsArr
=
new
UnicodeString
[
keysLen
]
;
if
(
prefsArr
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
LocalArray
<
UnicodeString
>
adoptedPrefs
(
prefsArr
)
;
int32_t
prefsLen
=
0
;
selectorImpl
-
>
selectKey
(
rv
.
takeArgument
(
)
rv
.
takeOptions
(
)
adoptedKeys
.
getAlias
(
)
keysLen
adoptedPrefs
.
getAlias
(
)
prefsLen
status
)
;
if
(
savedStatus
!
=
status
)
{
if
(
U_FAILURE
(
status
)
)
{
status
=
U_ZERO_ERROR
;
context
.
getErrors
(
)
.
setSelectorError
(
rv
.
getSelectorName
(
)
status
)
;
}
else
{
status
=
savedStatus
;
}
}
CHECK_ERROR
(
status
)
;
keysOut
.
removeAllElements
(
)
;
for
(
int32_t
i
=
0
;
i
<
prefsLen
;
i
+
+
)
{
UnicodeString
*
k
=
message2
:
:
create
<
UnicodeString
>
(
std
:
:
move
(
prefsArr
[
i
]
)
status
)
;
if
(
k
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
keysOut
.
adoptElement
(
k
status
)
;
CHECK_ERROR
(
status
)
;
}
}
void
MessageFormatter
:
:
resolvePreferences
(
MessageContext
&
context
UVector
&
res
UVector
&
pref
UErrorCode
&
status
)
const
{
CHECK_ERROR
(
status
)
;
UnicodeString
ks
;
LocalPointer
<
UnicodeString
>
ksP
;
int32_t
numVariants
=
dataModel
.
numVariants
(
)
;
const
Variant
*
variants
=
dataModel
.
getVariantsInternal
(
)
;
for
(
int32_t
i
=
0
;
i
<
res
.
size
(
)
;
i
+
+
)
{
LocalPointer
<
UVector
>
keys
(
createUVector
(
status
)
)
;
CHECK_ERROR
(
status
)
;
for
(
int32_t
variantNum
=
0
;
variantNum
<
numVariants
;
variantNum
+
+
)
{
const
SelectorKeys
&
selectorKeys
=
variants
[
variantNum
]
.
getKeys
(
)
;
const
Key
*
var
=
selectorKeys
.
getKeysInternal
(
)
;
U_ASSERT
(
i
<
selectorKeys
.
len
)
;
const
Key
&
key
=
var
[
i
]
;
if
(
!
key
.
isWildcard
(
)
)
{
ks
=
key
.
asLiteral
(
)
.
unquoted
(
)
;
ksP
.
adoptInstead
(
create
<
UnicodeString
>
(
std
:
:
move
(
ks
)
status
)
)
;
CHECK_ERROR
(
status
)
;
keys
-
>
adoptElement
(
ksP
.
orphan
(
)
status
)
;
}
}
U_ASSERT
(
i
<
res
.
size
(
)
)
;
ResolvedSelector
rv
=
std
:
:
move
(
*
(
static_cast
<
ResolvedSelector
*
>
(
res
[
i
]
)
)
)
;
LocalPointer
<
UVector
>
matches
(
createUVector
(
status
)
)
;
matchSelectorKeys
(
*
keys
context
std
:
:
move
(
rv
)
*
matches
status
)
;
pref
.
adoptElement
(
matches
.
orphan
(
)
status
)
;
}
}
static
int32_t
vectorFind
(
const
UVector
&
v
const
UnicodeString
&
k
)
{
for
(
int32_t
i
=
0
;
i
<
v
.
size
(
)
;
i
+
+
)
{
if
(
*
static_cast
<
UnicodeString
*
>
(
v
[
i
]
)
=
=
k
)
{
return
i
;
}
}
return
-
1
;
}
static
UBool
vectorContains
(
const
UVector
&
v
const
UnicodeString
&
k
)
{
return
(
vectorFind
(
v
k
)
!
=
-
1
)
;
}
void
MessageFormatter
:
:
filterVariants
(
const
UVector
&
pref
UVector
&
vars
UErrorCode
&
status
)
const
{
const
Variant
*
variants
=
dataModel
.
getVariantsInternal
(
)
;
for
(
int32_t
j
=
0
;
j
<
dataModel
.
numVariants
(
)
;
j
+
+
)
{
const
SelectorKeys
&
selectorKeys
=
variants
[
j
]
.
getKeys
(
)
;
const
Pattern
&
p
=
variants
[
j
]
.
getPattern
(
)
;
const
Key
*
var
=
selectorKeys
.
getKeysInternal
(
)
;
bool
noMatch
=
false
;
for
(
int32_t
i
=
0
;
i
<
pref
.
size
(
)
;
i
+
+
)
{
U_ASSERT
(
i
<
selectorKeys
.
len
)
;
const
Key
&
key
=
var
[
i
]
;
if
(
key
.
isWildcard
(
)
)
{
continue
;
}
UnicodeString
ks
=
key
.
asLiteral
(
)
.
unquoted
(
)
;
const
UVector
&
matches
=
*
(
static_cast
<
UVector
*
>
(
pref
[
i
]
)
)
;
if
(
vectorContains
(
matches
ks
)
)
{
continue
;
}
noMatch
=
true
;
break
;
}
if
(
!
noMatch
)
{
PrioritizedVariant
*
tuple
=
create
<
PrioritizedVariant
>
(
PrioritizedVariant
(
-
1
selectorKeys
p
)
status
)
;
CHECK_ERROR
(
status
)
;
vars
.
adoptElement
(
tuple
status
)
;
}
}
}
void
MessageFormatter
:
:
sortVariants
(
const
UVector
&
pref
UVector
&
vars
UErrorCode
&
status
)
const
{
CHECK_ERROR
(
status
)
;
int32_t
len
=
pref
.
size
(
)
;
int32_t
i
=
len
-
1
;
while
(
i
>
=
0
)
{
U_ASSERT
(
pref
[
i
]
!
=
nullptr
)
;
const
UVector
&
matches
=
*
(
static_cast
<
UVector
*
>
(
pref
[
i
]
)
)
;
int32_t
minpref
=
matches
.
size
(
)
;
for
(
int32_t
j
=
0
;
j
<
vars
.
size
(
)
;
j
+
+
)
{
U_ASSERT
(
vars
[
j
]
!
=
nullptr
)
;
PrioritizedVariant
&
tuple
=
*
(
static_cast
<
PrioritizedVariant
*
>
(
vars
[
j
]
)
)
;
int32_t
matchpref
=
minpref
;
const
Key
*
tupleVariantKeys
=
tuple
.
keys
.
getKeysInternal
(
)
;
U_ASSERT
(
i
<
tuple
.
keys
.
len
)
;
const
Key
&
key
=
tupleVariantKeys
[
i
]
;
if
(
!
key
.
isWildcard
(
)
)
{
UnicodeString
ks
=
key
.
asLiteral
(
)
.
unquoted
(
)
;
matchpref
=
vectorFind
(
matches
ks
)
;
U_ASSERT
(
matchpref
>
=
0
)
;
}
tuple
.
priority
=
matchpref
;
}
vars
.
sort
(
comparePrioritizedVariants
status
)
;
CHECK_ERROR
(
status
)
;
i
-
-
;
}
}
ResolvedSelector
MessageFormatter
:
:
resolveVariables
(
const
Environment
&
env
const
Operand
&
rand
MessageContext
&
context
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
if
(
rand
.
isNull
(
)
)
{
return
ResolvedSelector
(
FormattedPlaceholder
(
)
)
;
}
if
(
rand
.
isLiteral
(
)
)
{
return
ResolvedSelector
(
formatLiteral
(
rand
.
asLiteral
(
)
)
)
;
}
const
VariableName
&
var
=
rand
.
asVariable
(
)
;
if
(
env
.
has
(
var
)
)
{
const
Closure
&
referent
=
env
.
lookup
(
var
)
;
return
resolveVariables
(
referent
.
getEnv
(
)
referent
.
getExpr
(
)
context
status
)
;
}
FormattedPlaceholder
val
=
evalArgument
(
var
context
status
)
;
if
(
status
=
=
U_ILLEGAL_ARGUMENT_ERROR
)
{
status
=
U_ZERO_ERROR
;
U_ASSERT
(
context
.
getErrors
(
)
.
hasUnresolvedVariableError
(
)
)
;
return
ResolvedSelector
(
FormattedPlaceholder
(
var
)
)
;
}
return
ResolvedSelector
(
std
:
:
move
(
val
)
)
;
}
ResolvedSelector
MessageFormatter
:
:
resolveVariables
(
const
Environment
&
env
const
Expression
&
expr
MessageContext
&
context
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
if
(
expr
.
isFunctionCall
(
)
)
{
const
Operator
*
rator
=
expr
.
getOperator
(
status
)
;
U_ASSERT
(
U_SUCCESS
(
status
)
)
;
const
FunctionName
&
selectorName
=
rator
-
>
getFunctionName
(
)
;
if
(
isSelector
(
selectorName
)
)
{
auto
selector
=
getSelector
(
context
selectorName
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
FunctionOptions
resolvedOptions
=
resolveOptions
(
env
rator
-
>
getOptionsInternal
(
)
context
status
)
;
FormattedPlaceholder
argument
=
formatOperand
(
env
expr
.
getOperand
(
)
context
status
)
;
return
ResolvedSelector
(
selectorName
selector
std
:
:
move
(
resolvedOptions
)
std
:
:
move
(
argument
)
)
;
}
}
else
if
(
isFormatter
(
selectorName
)
)
{
context
.
getErrors
(
)
.
setSelectorError
(
selectorName
status
)
;
}
else
{
context
.
getErrors
(
)
.
setUnknownFunction
(
selectorName
status
)
;
}
UnicodeString
fallback
(
COLON
)
;
fallback
+
=
selectorName
;
if
(
!
expr
.
getOperand
(
)
.
isNull
(
)
)
{
fallback
=
formatOperand
(
env
expr
.
getOperand
(
)
context
status
)
.
fallback
;
}
return
ResolvedSelector
(
FormattedPlaceholder
(
fallback
)
)
;
}
else
{
return
resolveVariables
(
env
expr
.
getOperand
(
)
context
status
)
;
}
}
ResolvedSelector
MessageFormatter
:
:
formatSelectorExpression
(
const
Environment
&
globalEnv
const
Expression
&
expr
MessageContext
&
context
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
ResolvedSelector
exprResult
=
resolveVariables
(
globalEnv
expr
context
status
)
;
DynamicErrors
&
err
=
context
.
getErrors
(
)
;
if
(
exprResult
.
hasSelector
(
)
)
{
if
(
exprResult
.
argument
(
)
.
isFallback
(
)
)
{
if
(
err
.
hasSyntaxError
(
)
|
|
err
.
hasDataModelError
(
)
)
{
return
ResolvedSelector
(
FormattedPlaceholder
(
)
)
;
}
else
{
return
ResolvedSelector
(
exprResult
.
takeArgument
(
)
)
;
}
}
return
exprResult
;
}
U_ASSERT
(
err
.
hasMissingSelectorAnnotationError
(
)
|
|
err
.
hasUnknownFunctionError
(
)
|
|
err
.
hasSelectorError
(
)
)
;
return
ResolvedSelector
(
FormattedPlaceholder
(
exprResult
.
argument
(
)
.
fallback
)
)
;
}
void
MessageFormatter
:
:
formatSelectors
(
MessageContext
&
context
const
Environment
&
env
UErrorCode
&
status
UnicodeString
&
result
)
const
{
CHECK_ERROR
(
status
)
;
LocalPointer
<
UVector
>
res
(
createUVector
(
status
)
)
;
CHECK_ERROR
(
status
)
;
resolveSelectors
(
context
env
status
*
res
)
;
LocalPointer
<
UVector
>
pref
(
createUVector
(
status
)
)
;
CHECK_ERROR
(
status
)
;
resolvePreferences
(
context
*
res
*
pref
status
)
;
LocalPointer
<
UVector
>
vars
(
createUVector
(
status
)
)
;
CHECK_ERROR
(
status
)
;
filterVariants
(
*
pref
*
vars
status
)
;
sortVariants
(
*
pref
*
vars
status
)
;
CHECK_ERROR
(
status
)
;
U_ASSERT
(
vars
-
>
size
(
)
>
0
)
;
const
PrioritizedVariant
&
var
=
*
(
static_cast
<
PrioritizedVariant
*
>
(
vars
-
>
elementAt
(
0
)
)
)
;
const
Pattern
&
pat
=
var
.
pat
;
formatPattern
(
context
env
pat
status
result
)
;
}
UnicodeString
MessageFormatter
:
:
formatToString
(
const
MessageArguments
&
arguments
UErrorCode
&
status
)
{
EMPTY_ON_ERROR
(
status
)
;
Environment
*
env
=
Environment
:
:
create
(
status
)
;
MessageContext
context
(
arguments
*
errors
status
)
;
checkDeclarations
(
context
env
status
)
;
LocalPointer
<
Environment
>
globalEnv
(
env
)
;
UnicodeString
result
;
if
(
dataModel
.
hasPattern
(
)
)
{
formatPattern
(
context
*
globalEnv
dataModel
.
getPattern
(
)
status
result
)
;
}
else
{
const
DynamicErrors
&
err
=
context
.
getErrors
(
)
;
if
(
err
.
hasSyntaxError
(
)
|
|
err
.
hasDataModelError
(
)
)
{
result
+
=
REPLACEMENT
;
}
else
{
formatSelectors
(
context
*
globalEnv
status
result
)
;
}
}
if
(
signalErrors
)
{
context
.
checkErrors
(
status
)
;
}
if
(
U_FAILURE
(
status
)
)
{
result
.
remove
(
)
;
}
return
result
;
}
void
MessageFormatter
:
:
check
(
MessageContext
&
context
const
Environment
&
localEnv
const
OptionMap
&
options
UErrorCode
&
status
)
const
{
for
(
int32_t
i
=
0
;
i
<
options
.
size
(
)
;
i
+
+
)
{
const
Option
&
opt
=
options
.
getOption
(
i
status
)
;
CHECK_ERROR
(
status
)
;
check
(
context
localEnv
opt
.
getValue
(
)
status
)
;
}
}
void
MessageFormatter
:
:
check
(
MessageContext
&
context
const
Environment
&
localEnv
const
Operand
&
rand
UErrorCode
&
status
)
const
{
if
(
rand
.
isLiteral
(
)
|
|
rand
.
isNull
(
)
)
{
return
;
}
const
VariableName
&
var
=
rand
.
asVariable
(
)
;
if
(
localEnv
.
has
(
var
)
)
{
return
;
}
context
.
getGlobal
(
var
status
)
;
if
(
status
=
=
U_ILLEGAL_ARGUMENT_ERROR
)
{
status
=
U_ZERO_ERROR
;
context
.
getErrors
(
)
.
setUnresolvedVariable
(
var
status
)
;
}
return
;
}
void
MessageFormatter
:
:
check
(
MessageContext
&
context
const
Environment
&
localEnv
const
Expression
&
expr
UErrorCode
&
status
)
const
{
if
(
expr
.
isFunctionCall
(
)
)
{
const
Operator
*
rator
=
expr
.
getOperator
(
status
)
;
U_ASSERT
(
U_SUCCESS
(
status
)
)
;
const
Operand
&
rand
=
expr
.
getOperand
(
)
;
check
(
context
localEnv
rand
status
)
;
check
(
context
localEnv
rator
-
>
getOptionsInternal
(
)
status
)
;
}
}
void
MessageFormatter
:
:
checkDeclarations
(
MessageContext
&
context
Environment
*
&
env
UErrorCode
&
status
)
const
{
CHECK_ERROR
(
status
)
;
const
Binding
*
decls
=
getDataModel
(
)
.
getLocalVariablesInternal
(
)
;
U_ASSERT
(
env
!
=
nullptr
&
&
(
decls
!
=
nullptr
|
|
getDataModel
(
)
.
bindingsLen
=
=
0
)
)
;
for
(
int32_t
i
=
0
;
i
<
getDataModel
(
)
.
bindingsLen
;
i
+
+
)
{
const
Binding
&
decl
=
decls
[
i
]
;
const
Expression
&
rhs
=
decl
.
getValue
(
)
;
check
(
context
*
env
rhs
status
)
;
env
=
Environment
:
:
create
(
decl
.
getVariable
(
)
Closure
(
rhs
*
env
)
env
status
)
;
CHECK_ERROR
(
status
)
;
}
}
}
U_NAMESPACE_END
#
endif
#
endif
