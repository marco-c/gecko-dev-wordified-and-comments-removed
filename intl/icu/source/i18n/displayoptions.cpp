#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
displayoptions
.
h
"
#
include
"
unicode
/
udisplayoptions
.
h
"
#
include
"
cstring
.
h
"
U_NAMESPACE_BEGIN
DisplayOptions
:
:
Builder
DisplayOptions
:
:
builder
(
)
{
return
DisplayOptions
:
:
Builder
(
)
;
}
DisplayOptions
:
:
Builder
DisplayOptions
:
:
copyToBuilder
(
)
const
{
return
Builder
(
*
this
)
;
}
DisplayOptions
:
:
DisplayOptions
(
const
Builder
&
builder
)
{
grammaticalCase
=
builder
.
grammaticalCase
;
nounClass
=
builder
.
nounClass
;
pluralCategory
=
builder
.
pluralCategory
;
capitalization
=
builder
.
capitalization
;
nameStyle
=
builder
.
nameStyle
;
displayLength
=
builder
.
displayLength
;
substituteHandling
=
builder
.
substituteHandling
;
}
DisplayOptions
:
:
Builder
:
:
Builder
(
)
{
grammaticalCase
=
UDISPOPT_GRAMMATICAL_CASE_UNDEFINED
;
nounClass
=
UDISPOPT_NOUN_CLASS_UNDEFINED
;
pluralCategory
=
UDISPOPT_PLURAL_CATEGORY_UNDEFINED
;
capitalization
=
UDISPOPT_CAPITALIZATION_UNDEFINED
;
nameStyle
=
UDISPOPT_NAME_STYLE_UNDEFINED
;
displayLength
=
UDISPOPT_DISPLAY_LENGTH_UNDEFINED
;
substituteHandling
=
UDISPOPT_SUBSTITUTE_HANDLING_UNDEFINED
;
}
DisplayOptions
:
:
Builder
:
:
Builder
(
const
DisplayOptions
&
displayOptions
)
{
grammaticalCase
=
displayOptions
.
grammaticalCase
;
nounClass
=
displayOptions
.
nounClass
;
pluralCategory
=
displayOptions
.
pluralCategory
;
capitalization
=
displayOptions
.
capitalization
;
nameStyle
=
displayOptions
.
nameStyle
;
displayLength
=
displayOptions
.
displayLength
;
substituteHandling
=
displayOptions
.
substituteHandling
;
}
U_NAMESPACE_END
U_NAMESPACE_USE
namespace
{
const
char
*
grammaticalCaseIds
[
]
=
{
"
undefined
"
"
ablative
"
"
accusative
"
"
comitative
"
"
dative
"
"
ergative
"
"
genitive
"
"
instrumental
"
"
locative
"
"
locative_copulative
"
"
nominative
"
"
oblique
"
"
prepositional
"
"
sociative
"
"
vocative
"
}
;
}
U_CAPI
const
char
*
U_EXPORT2
udispopt_getGrammaticalCaseIdentifier
(
UDisplayOptionsGrammaticalCase
grammaticalCase
)
{
if
(
grammaticalCase
>
=
0
&
&
grammaticalCase
<
UPRV_LENGTHOF
(
grammaticalCaseIds
)
)
{
return
grammaticalCaseIds
[
grammaticalCase
]
;
}
return
grammaticalCaseIds
[
0
]
;
}
U_CAPI
UDisplayOptionsGrammaticalCase
U_EXPORT2
udispopt_fromGrammaticalCaseIdentifier
(
const
char
*
identifier
)
{
for
(
int32_t
i
=
0
;
i
<
UPRV_LENGTHOF
(
grammaticalCaseIds
)
;
i
+
+
)
{
if
(
uprv_strcmp
(
identifier
grammaticalCaseIds
[
i
]
)
=
=
0
)
{
return
static_cast
<
UDisplayOptionsGrammaticalCase
>
(
i
)
;
}
}
return
UDISPOPT_GRAMMATICAL_CASE_UNDEFINED
;
}
namespace
{
const
char
*
pluralCategoryIds
[
]
=
{
"
undefined
"
"
zero
"
"
one
"
"
two
"
"
few
"
"
many
"
"
other
"
}
;
}
U_CAPI
const
char
*
U_EXPORT2
udispopt_getPluralCategoryIdentifier
(
UDisplayOptionsPluralCategory
pluralCategory
)
{
if
(
pluralCategory
>
=
0
&
&
pluralCategory
<
UPRV_LENGTHOF
(
pluralCategoryIds
)
)
{
return
pluralCategoryIds
[
pluralCategory
]
;
}
return
pluralCategoryIds
[
0
]
;
}
U_CAPI
UDisplayOptionsPluralCategory
U_EXPORT2
udispopt_fromPluralCategoryIdentifier
(
const
char
*
identifier
)
{
for
(
int32_t
i
=
0
;
i
<
UPRV_LENGTHOF
(
pluralCategoryIds
)
;
i
+
+
)
{
if
(
uprv_strcmp
(
identifier
pluralCategoryIds
[
i
]
)
=
=
0
)
{
return
static_cast
<
UDisplayOptionsPluralCategory
>
(
i
)
;
}
}
return
UDISPOPT_PLURAL_CATEGORY_UNDEFINED
;
}
namespace
{
const
char
*
nounClassIds
[
]
=
{
"
undefined
"
"
other
"
"
neuter
"
"
feminine
"
"
masculine
"
"
animate
"
"
inanimate
"
"
personal
"
"
common
"
}
;
}
U_CAPI
const
char
*
U_EXPORT2
udispopt_getNounClassIdentifier
(
UDisplayOptionsNounClass
nounClass
)
{
if
(
nounClass
>
=
0
&
&
nounClass
<
UPRV_LENGTHOF
(
nounClassIds
)
)
{
return
nounClassIds
[
nounClass
]
;
}
return
nounClassIds
[
0
]
;
}
U_CAPI
UDisplayOptionsNounClass
U_EXPORT2
udispopt_fromNounClassIdentifier
(
const
char
*
identifier
)
{
for
(
int32_t
i
=
0
;
i
<
UPRV_LENGTHOF
(
nounClassIds
)
;
i
+
+
)
{
if
(
uprv_strcmp
(
identifier
nounClassIds
[
i
]
)
=
=
0
)
{
return
static_cast
<
UDisplayOptionsNounClass
>
(
i
)
;
}
}
return
UDISPOPT_NOUN_CLASS_UNDEFINED
;
}
#
endif
