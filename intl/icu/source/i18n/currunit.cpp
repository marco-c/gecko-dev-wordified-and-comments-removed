#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
currunit
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
unicode
/
uchar
.
h
"
#
include
"
cstring
.
h
"
#
include
"
uinvchar
.
h
"
#
include
"
charstr
.
h
"
#
include
"
ustr_imp
.
h
"
#
include
"
measunit_impl
.
h
"
U_NAMESPACE_BEGIN
CurrencyUnit
:
:
CurrencyUnit
(
ConstChar16Ptr
_isoCode
UErrorCode
&
ec
)
{
bool
useDefault
=
false
;
if
(
U_FAILURE
(
ec
)
|
|
_isoCode
=
=
nullptr
|
|
_isoCode
[
0
]
=
=
0
)
{
useDefault
=
true
;
}
else
if
(
_isoCode
[
1
]
=
=
0
|
|
_isoCode
[
2
]
=
=
0
)
{
useDefault
=
true
;
ec
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
else
if
(
!
uprv_isInvariantUString
(
_isoCode
3
)
)
{
useDefault
=
true
;
ec
=
U_INVARIANT_CONVERSION_ERROR
;
}
else
{
for
(
int32_t
i
=
0
;
i
<
3
;
i
+
+
)
{
isoCode
[
i
]
=
u_asciiToUpper
(
_isoCode
[
i
]
)
;
}
isoCode
[
3
]
=
0
;
}
if
(
useDefault
)
{
uprv_memcpy
(
isoCode
kDefaultCurrency
sizeof
(
char16_t
)
*
4
)
;
}
char
simpleIsoCode
[
4
]
;
u_UCharsToChars
(
isoCode
simpleIsoCode
4
)
;
initCurrency
(
simpleIsoCode
)
;
}
CurrencyUnit
:
:
CurrencyUnit
(
StringPiece
_isoCode
UErrorCode
&
ec
)
{
char
isoCodeBuffer
[
4
]
;
const
char
*
isoCodeToUse
;
if
(
_isoCode
.
length
(
)
!
=
3
|
|
uprv_memchr
(
_isoCode
.
data
(
)
0
3
)
!
=
nullptr
)
{
isoCodeToUse
=
kDefaultCurrency8
;
ec
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
else
if
(
!
uprv_isInvariantString
(
_isoCode
.
data
(
)
3
)
)
{
isoCodeToUse
=
kDefaultCurrency8
;
ec
=
U_INVARIANT_CONVERSION_ERROR
;
}
else
{
for
(
int32_t
i
=
0
;
i
<
3
;
i
+
+
)
{
isoCodeBuffer
[
i
]
=
uprv_toupper
(
_isoCode
.
data
(
)
[
i
]
)
;
}
isoCodeBuffer
[
3
]
=
0
;
isoCodeToUse
=
isoCodeBuffer
;
}
u_charsToUChars
(
isoCodeToUse
isoCode
4
)
;
initCurrency
(
isoCodeToUse
)
;
}
CurrencyUnit
:
:
CurrencyUnit
(
const
CurrencyUnit
&
other
)
:
MeasureUnit
(
other
)
{
u_strcpy
(
isoCode
other
.
isoCode
)
;
}
CurrencyUnit
:
:
CurrencyUnit
(
const
MeasureUnit
&
other
UErrorCode
&
ec
)
:
MeasureUnit
(
other
)
{
if
(
uprv_strcmp
(
"
currency
"
getType
(
)
)
!
=
0
)
{
ec
=
U_ILLEGAL_ARGUMENT_ERROR
;
isoCode
[
0
]
=
0
;
}
else
{
u_charsToUChars
(
getSubtype
(
)
isoCode
4
)
;
isoCode
[
3
]
=
0
;
}
}
CurrencyUnit
:
:
CurrencyUnit
(
)
:
MeasureUnit
(
)
{
u_strcpy
(
isoCode
kDefaultCurrency
)
;
char
simpleIsoCode
[
4
]
;
u_UCharsToChars
(
isoCode
simpleIsoCode
4
)
;
initCurrency
(
simpleIsoCode
)
;
}
CurrencyUnit
&
CurrencyUnit
:
:
operator
=
(
const
CurrencyUnit
&
other
)
{
if
(
this
=
=
&
other
)
{
return
*
this
;
}
MeasureUnit
:
:
operator
=
(
other
)
;
u_strcpy
(
isoCode
other
.
isoCode
)
;
return
*
this
;
}
CurrencyUnit
*
CurrencyUnit
:
:
clone
(
)
const
{
return
new
CurrencyUnit
(
*
this
)
;
}
CurrencyUnit
:
:
~
CurrencyUnit
(
)
{
}
UOBJECT_DEFINE_RTTI_IMPLEMENTATION
(
CurrencyUnit
)
U_NAMESPACE_END
#
endif
