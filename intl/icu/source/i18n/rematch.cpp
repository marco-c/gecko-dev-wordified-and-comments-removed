#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_REGULAR_EXPRESSIONS
#
include
"
unicode
/
regex
.
h
"
#
include
"
unicode
/
uniset
.
h
"
#
include
"
unicode
/
uchar
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
unicode
/
rbbi
.
h
"
#
include
"
unicode
/
utf
.
h
"
#
include
"
unicode
/
utf16
.
h
"
#
include
"
uassert
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
cstr
.
h
"
#
include
"
uvector
.
h
"
#
include
"
uvectr32
.
h
"
#
include
"
uvectr64
.
h
"
#
include
"
regeximp
.
h
"
#
include
"
regexst
.
h
"
#
include
"
regextxt
.
h
"
#
include
"
ucase
.
h
"
U_NAMESPACE_BEGIN
static
const
int32_t
DEFAULT_BACKTRACK_STACK_CAPACITY
=
8000000
;
static
const
int32_t
TIMER_INITIAL_VALUE
=
10000
;
static
inline
UBool
isLineTerminator
(
UChar32
c
)
{
if
(
c
&
~
(
0x0a
|
0x0b
|
0x0c
|
0x0d
|
0x85
|
0x2028
|
0x2029
)
)
{
return
false
;
}
return
(
c
<
=
0x0d
&
&
c
>
=
0x0a
)
|
|
c
=
=
0x85
|
|
c
=
=
0x2028
|
|
c
=
=
0x2029
;
}
RegexMatcher
:
:
RegexMatcher
(
const
RegexPattern
*
pat
)
{
fDeferredStatus
=
U_ZERO_ERROR
;
init
(
fDeferredStatus
)
;
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
return
;
}
if
(
pat
=
=
nullptr
)
{
fDeferredStatus
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
fPattern
=
pat
;
init2
(
RegexStaticSets
:
:
gStaticSets
-
>
fEmptyText
fDeferredStatus
)
;
}
RegexMatcher
:
:
RegexMatcher
(
const
UnicodeString
&
regexp
const
UnicodeString
&
input
uint32_t
flags
UErrorCode
&
status
)
{
init
(
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
UParseError
pe
;
fPatternOwned
=
RegexPattern
:
:
compile
(
regexp
flags
pe
status
)
;
fPattern
=
fPatternOwned
;
UText
inputText
=
UTEXT_INITIALIZER
;
utext_openConstUnicodeString
(
&
inputText
&
input
&
status
)
;
init2
(
&
inputText
status
)
;
utext_close
(
&
inputText
)
;
fInputUniStrMaybeMutable
=
true
;
}
RegexMatcher
:
:
RegexMatcher
(
UText
*
regexp
UText
*
input
uint32_t
flags
UErrorCode
&
status
)
{
init
(
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
UParseError
pe
;
fPatternOwned
=
RegexPattern
:
:
compile
(
regexp
flags
pe
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
fPattern
=
fPatternOwned
;
init2
(
input
status
)
;
}
RegexMatcher
:
:
RegexMatcher
(
const
UnicodeString
&
regexp
uint32_t
flags
UErrorCode
&
status
)
{
init
(
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
UParseError
pe
;
fPatternOwned
=
RegexPattern
:
:
compile
(
regexp
flags
pe
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
fPattern
=
fPatternOwned
;
init2
(
RegexStaticSets
:
:
gStaticSets
-
>
fEmptyText
status
)
;
}
RegexMatcher
:
:
RegexMatcher
(
UText
*
regexp
uint32_t
flags
UErrorCode
&
status
)
{
init
(
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
UParseError
pe
;
fPatternOwned
=
RegexPattern
:
:
compile
(
regexp
flags
pe
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
fPattern
=
fPatternOwned
;
init2
(
RegexStaticSets
:
:
gStaticSets
-
>
fEmptyText
status
)
;
}
RegexMatcher
:
:
~
RegexMatcher
(
)
{
delete
fStack
;
if
(
fData
!
=
fSmallData
)
{
uprv_free
(
fData
)
;
fData
=
nullptr
;
}
if
(
fPatternOwned
)
{
delete
fPatternOwned
;
fPatternOwned
=
nullptr
;
fPattern
=
nullptr
;
}
if
(
fInput
)
{
delete
fInput
;
}
if
(
fInputText
)
{
utext_close
(
fInputText
)
;
}
if
(
fAltInputText
)
{
utext_close
(
fAltInputText
)
;
}
#
if
UCONFIG_NO_BREAK_ITERATION
=
=
0
delete
fWordBreakItr
;
delete
fGCBreakItr
;
#
endif
}
void
RegexMatcher
:
:
init
(
UErrorCode
&
status
)
{
fPattern
=
nullptr
;
fPatternOwned
=
nullptr
;
fFrameSize
=
0
;
fRegionStart
=
0
;
fRegionLimit
=
0
;
fAnchorStart
=
0
;
fAnchorLimit
=
0
;
fLookStart
=
0
;
fLookLimit
=
0
;
fActiveStart
=
0
;
fActiveLimit
=
0
;
fTransparentBounds
=
false
;
fAnchoringBounds
=
true
;
fMatch
=
false
;
fMatchStart
=
0
;
fMatchEnd
=
0
;
fLastMatchEnd
=
-
1
;
fAppendPosition
=
0
;
fHitEnd
=
false
;
fRequireEnd
=
false
;
fStack
=
nullptr
;
fFrame
=
nullptr
;
fTimeLimit
=
0
;
fTime
=
0
;
fTickCounter
=
0
;
fStackLimit
=
DEFAULT_BACKTRACK_STACK_CAPACITY
;
fCallbackFn
=
nullptr
;
fCallbackContext
=
nullptr
;
fFindProgressCallbackFn
=
nullptr
;
fFindProgressCallbackContext
=
nullptr
;
fTraceDebug
=
false
;
fDeferredStatus
=
status
;
fData
=
fSmallData
;
fWordBreakItr
=
nullptr
;
fGCBreakItr
=
nullptr
;
fStack
=
nullptr
;
fInputText
=
nullptr
;
fAltInputText
=
nullptr
;
fInput
=
nullptr
;
fInputLength
=
0
;
fInputUniStrMaybeMutable
=
false
;
}
void
RegexMatcher
:
:
init2
(
UText
*
input
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
fDeferredStatus
=
status
;
return
;
}
if
(
fPattern
-
>
fDataSize
>
UPRV_LENGTHOF
(
fSmallData
)
)
{
fData
=
(
int64_t
*
)
uprv_malloc
(
fPattern
-
>
fDataSize
*
sizeof
(
int64_t
)
)
;
if
(
fData
=
=
nullptr
)
{
status
=
fDeferredStatus
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
}
fStack
=
new
UVector64
(
status
)
;
if
(
fStack
=
=
nullptr
)
{
status
=
fDeferredStatus
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
reset
(
input
)
;
setStackLimit
(
DEFAULT_BACKTRACK_STACK_CAPACITY
status
)
;
if
(
U_FAILURE
(
status
)
)
{
fDeferredStatus
=
status
;
return
;
}
}
static
const
char16_t
BACKSLASH
=
0x5c
;
static
const
char16_t
DOLLARSIGN
=
0x24
;
static
const
char16_t
LEFTBRACKET
=
0x7b
;
static
const
char16_t
RIGHTBRACKET
=
0x7d
;
RegexMatcher
&
RegexMatcher
:
:
appendReplacement
(
UnicodeString
&
dest
const
UnicodeString
&
replacement
UErrorCode
&
status
)
{
UText
replacementText
=
UTEXT_INITIALIZER
;
utext_openConstUnicodeString
(
&
replacementText
&
replacement
&
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
UText
resultText
=
UTEXT_INITIALIZER
;
utext_openUnicodeString
(
&
resultText
&
dest
&
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
appendReplacement
(
&
resultText
&
replacementText
status
)
;
utext_close
(
&
resultText
)
;
}
utext_close
(
&
replacementText
)
;
}
return
*
this
;
}
RegexMatcher
&
RegexMatcher
:
:
appendReplacement
(
UText
*
dest
UText
*
replacement
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
*
this
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
*
this
;
}
if
(
fMatch
=
=
false
)
{
status
=
U_REGEX_INVALID_STATE
;
return
*
this
;
}
int64_t
destLen
=
utext_nativeLength
(
dest
)
;
if
(
fMatchStart
>
fAppendPosition
)
{
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
fInputText
fInputLength
)
)
{
destLen
+
=
utext_replace
(
dest
destLen
destLen
fInputText
-
>
chunkContents
+
fAppendPosition
(
int32_t
)
(
fMatchStart
-
fAppendPosition
)
&
status
)
;
}
else
{
int32_t
len16
;
if
(
UTEXT_USES_U16
(
fInputText
)
)
{
len16
=
(
int32_t
)
(
fMatchStart
-
fAppendPosition
)
;
}
else
{
UErrorCode
lengthStatus
=
U_ZERO_ERROR
;
len16
=
utext_extract
(
fInputText
fAppendPosition
fMatchStart
nullptr
0
&
lengthStatus
)
;
}
char16_t
*
inputChars
=
(
char16_t
*
)
uprv_malloc
(
sizeof
(
char16_t
)
*
(
len16
+
1
)
)
;
if
(
inputChars
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
*
this
;
}
utext_extract
(
fInputText
fAppendPosition
fMatchStart
inputChars
len16
+
1
&
status
)
;
destLen
+
=
utext_replace
(
dest
destLen
destLen
inputChars
len16
&
status
)
;
uprv_free
(
inputChars
)
;
}
}
fAppendPosition
=
fMatchEnd
;
UTEXT_SETNATIVEINDEX
(
replacement
0
)
;
for
(
UChar32
c
=
UTEXT_NEXT32
(
replacement
)
;
U_SUCCESS
(
status
)
&
&
c
!
=
U_SENTINEL
;
c
=
UTEXT_NEXT32
(
replacement
)
)
{
if
(
c
=
=
BACKSLASH
)
{
c
=
UTEXT_CURRENT32
(
replacement
)
;
if
(
c
=
=
U_SENTINEL
)
{
break
;
}
if
(
c
=
=
0x55
|
|
c
=
=
0x75
)
{
int32_t
offset
=
0
;
struct
URegexUTextUnescapeCharContext
context
=
U_REGEX_UTEXT_UNESCAPE_CONTEXT
(
replacement
)
;
UChar32
escapedChar
=
u_unescapeAt
(
uregex_utext_unescape_charAt
&
offset
INT32_MAX
&
context
)
;
if
(
escapedChar
!
=
(
UChar32
)
0xFFFFFFFF
)
{
if
(
U_IS_BMP
(
escapedChar
)
)
{
char16_t
c16
=
(
char16_t
)
escapedChar
;
destLen
+
=
utext_replace
(
dest
destLen
destLen
&
c16
1
&
status
)
;
}
else
{
char16_t
surrogate
[
2
]
;
surrogate
[
0
]
=
U16_LEAD
(
escapedChar
)
;
surrogate
[
1
]
=
U16_TRAIL
(
escapedChar
)
;
if
(
U_SUCCESS
(
status
)
)
{
destLen
+
=
utext_replace
(
dest
destLen
destLen
surrogate
2
&
status
)
;
}
}
if
(
context
.
lastOffset
=
=
offset
)
{
(
void
)
UTEXT_PREVIOUS32
(
replacement
)
;
}
else
if
(
context
.
lastOffset
!
=
offset
-
1
)
{
utext_moveIndex32
(
replacement
offset
-
context
.
lastOffset
-
1
)
;
}
}
}
else
{
(
void
)
UTEXT_NEXT32
(
replacement
)
;
if
(
U_IS_BMP
(
c
)
)
{
char16_t
c16
=
(
char16_t
)
c
;
destLen
+
=
utext_replace
(
dest
destLen
destLen
&
c16
1
&
status
)
;
}
else
{
char16_t
surrogate
[
2
]
;
surrogate
[
0
]
=
U16_LEAD
(
c
)
;
surrogate
[
1
]
=
U16_TRAIL
(
c
)
;
if
(
U_SUCCESS
(
status
)
)
{
destLen
+
=
utext_replace
(
dest
destLen
destLen
surrogate
2
&
status
)
;
}
}
}
}
else
if
(
c
!
=
DOLLARSIGN
)
{
if
(
U_IS_BMP
(
c
)
)
{
char16_t
c16
=
(
char16_t
)
c
;
destLen
+
=
utext_replace
(
dest
destLen
destLen
&
c16
1
&
status
)
;
}
else
{
char16_t
surrogate
[
2
]
;
surrogate
[
0
]
=
U16_LEAD
(
c
)
;
surrogate
[
1
]
=
U16_TRAIL
(
c
)
;
if
(
U_SUCCESS
(
status
)
)
{
destLen
+
=
utext_replace
(
dest
destLen
destLen
surrogate
2
&
status
)
;
}
}
}
else
{
int32_t
groupNum
=
0
;
int32_t
numDigits
=
0
;
UChar32
nextChar
=
utext_current32
(
replacement
)
;
if
(
nextChar
=
=
LEFTBRACKET
)
{
UnicodeString
groupName
;
utext_next32
(
replacement
)
;
while
(
U_SUCCESS
(
status
)
&
&
nextChar
!
=
RIGHTBRACKET
)
{
nextChar
=
utext_next32
(
replacement
)
;
if
(
nextChar
=
=
U_SENTINEL
)
{
status
=
U_REGEX_INVALID_CAPTURE_GROUP_NAME
;
}
else
if
(
(
nextChar
>
=
0x41
&
&
nextChar
<
=
0x5a
)
|
|
(
nextChar
>
=
0x61
&
&
nextChar
<
=
0x7a
)
|
|
(
nextChar
>
=
0x31
&
&
nextChar
<
=
0x39
)
)
{
groupName
.
append
(
nextChar
)
;
}
else
if
(
nextChar
=
=
RIGHTBRACKET
)
{
groupNum
=
fPattern
-
>
fNamedCaptureMap
?
uhash_geti
(
fPattern
-
>
fNamedCaptureMap
&
groupName
)
:
0
;
if
(
groupNum
=
=
0
)
{
status
=
U_REGEX_INVALID_CAPTURE_GROUP_NAME
;
}
}
else
{
status
=
U_REGEX_INVALID_CAPTURE_GROUP_NAME
;
}
}
}
else
if
(
u_isdigit
(
nextChar
)
)
{
int32_t
numCaptureGroups
=
fPattern
-
>
fGroupMap
-
>
size
(
)
;
for
(
;
;
)
{
nextChar
=
UTEXT_CURRENT32
(
replacement
)
;
if
(
nextChar
=
=
U_SENTINEL
)
{
break
;
}
if
(
u_isdigit
(
nextChar
)
=
=
false
)
{
break
;
}
int32_t
nextDigitVal
=
u_charDigitValue
(
nextChar
)
;
if
(
groupNum
*
10
+
nextDigitVal
>
numCaptureGroups
)
{
if
(
numDigits
=
=
0
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
}
break
;
}
(
void
)
UTEXT_NEXT32
(
replacement
)
;
groupNum
=
groupNum
*
10
+
nextDigitVal
;
+
+
numDigits
;
}
}
else
{
status
=
U_REGEX_INVALID_CAPTURE_GROUP_NAME
;
}
if
(
U_SUCCESS
(
status
)
)
{
destLen
+
=
appendGroup
(
groupNum
dest
status
)
;
}
}
}
return
*
this
;
}
UnicodeString
&
RegexMatcher
:
:
appendTail
(
UnicodeString
&
dest
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UText
resultText
=
UTEXT_INITIALIZER
;
utext_openUnicodeString
(
&
resultText
&
dest
&
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
appendTail
(
&
resultText
status
)
;
utext_close
(
&
resultText
)
;
}
return
dest
;
}
UText
*
RegexMatcher
:
:
appendTail
(
UText
*
dest
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
dest
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
dest
;
}
if
(
fInputLength
>
fAppendPosition
)
{
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
fInputText
fInputLength
)
)
{
int64_t
destLen
=
utext_nativeLength
(
dest
)
;
utext_replace
(
dest
destLen
destLen
fInputText
-
>
chunkContents
+
fAppendPosition
(
int32_t
)
(
fInputLength
-
fAppendPosition
)
&
status
)
;
}
else
{
int32_t
len16
;
if
(
UTEXT_USES_U16
(
fInputText
)
)
{
len16
=
(
int32_t
)
(
fInputLength
-
fAppendPosition
)
;
}
else
{
len16
=
utext_extract
(
fInputText
fAppendPosition
fInputLength
nullptr
0
&
status
)
;
status
=
U_ZERO_ERROR
;
}
char16_t
*
inputChars
=
(
char16_t
*
)
uprv_malloc
(
sizeof
(
char16_t
)
*
(
len16
)
)
;
if
(
inputChars
=
=
nullptr
)
{
fDeferredStatus
=
U_MEMORY_ALLOCATION_ERROR
;
}
else
{
utext_extract
(
fInputText
fAppendPosition
fInputLength
inputChars
len16
&
status
)
;
int64_t
destLen
=
utext_nativeLength
(
dest
)
;
utext_replace
(
dest
destLen
destLen
inputChars
len16
&
status
)
;
uprv_free
(
inputChars
)
;
}
}
}
return
dest
;
}
int32_t
RegexMatcher
:
:
end
(
UErrorCode
&
err
)
const
{
return
end
(
0
err
)
;
}
int64_t
RegexMatcher
:
:
end64
(
UErrorCode
&
err
)
const
{
return
end64
(
0
err
)
;
}
int64_t
RegexMatcher
:
:
end64
(
int32_t
group
UErrorCode
&
err
)
const
{
if
(
U_FAILURE
(
err
)
)
{
return
-
1
;
}
if
(
fMatch
=
=
false
)
{
err
=
U_REGEX_INVALID_STATE
;
return
-
1
;
}
if
(
group
<
0
|
|
group
>
fPattern
-
>
fGroupMap
-
>
size
(
)
)
{
err
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
-
1
;
}
int64_t
e
=
-
1
;
if
(
group
=
=
0
)
{
e
=
fMatchEnd
;
}
else
{
int32_t
groupOffset
=
fPattern
-
>
fGroupMap
-
>
elementAti
(
group
-
1
)
;
U_ASSERT
(
groupOffset
<
fPattern
-
>
fFrameSize
)
;
U_ASSERT
(
groupOffset
>
=
0
)
;
e
=
fFrame
-
>
fExtra
[
groupOffset
+
1
]
;
}
return
e
;
}
int32_t
RegexMatcher
:
:
end
(
int32_t
group
UErrorCode
&
err
)
const
{
return
(
int32_t
)
end64
(
group
err
)
;
}
UBool
RegexMatcher
:
:
findProgressInterrupt
(
int64_t
pos
UErrorCode
&
status
)
{
if
(
fFindProgressCallbackFn
&
&
!
(
*
fFindProgressCallbackFn
)
(
fFindProgressCallbackContext
pos
)
)
{
status
=
U_REGEX_STOPPED_BY_CALLER
;
return
true
;
}
return
false
;
}
UBool
RegexMatcher
:
:
find
(
)
{
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
return
false
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
UBool
result
=
find
(
status
)
;
return
result
;
}
UBool
RegexMatcher
:
:
find
(
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
false
;
}
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
fInputText
fInputLength
)
)
{
return
findUsingChunk
(
status
)
;
}
int64_t
startPos
=
fMatchEnd
;
if
(
startPos
=
=
0
)
{
startPos
=
fActiveStart
;
}
if
(
fMatch
)
{
fLastMatchEnd
=
fMatchEnd
;
if
(
fMatchStart
=
=
fMatchEnd
)
{
if
(
startPos
>
=
fActiveLimit
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
(
void
)
UTEXT_NEXT32
(
fInputText
)
;
startPos
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
}
else
{
if
(
fLastMatchEnd
>
=
0
)
{
fHitEnd
=
true
;
return
false
;
}
}
int64_t
testStartLimit
;
if
(
UTEXT_USES_U16
(
fInputText
)
)
{
testStartLimit
=
fActiveLimit
-
fPattern
-
>
fMinMatchLen
;
if
(
startPos
>
testStartLimit
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
}
else
{
testStartLimit
=
fActiveLimit
-
(
fPattern
-
>
fMinMatchLen
>
0
?
1
:
0
)
;
}
UChar32
c
;
U_ASSERT
(
startPos
>
=
0
)
;
switch
(
fPattern
-
>
fStartType
)
{
case
START_NO_INFO
:
for
(
;
;
)
{
MatchAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
if
(
startPos
>
=
testStartLimit
)
{
fHitEnd
=
true
;
return
false
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
(
void
)
UTEXT_NEXT32
(
fInputText
)
;
startPos
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
UPRV_UNREACHABLE_EXIT
;
case
START_START
:
if
(
startPos
>
fActiveStart
)
{
fMatch
=
false
;
return
false
;
}
MatchAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
return
fMatch
;
case
START_SET
:
{
U_ASSERT
(
fPattern
-
>
fMinMatchLen
>
0
)
;
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
for
(
;
;
)
{
int64_t
pos
=
startPos
;
c
=
UTEXT_NEXT32
(
fInputText
)
;
startPos
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
if
(
c
>
=
0
&
&
(
(
c
<
256
&
&
fPattern
-
>
fInitialChars8
-
>
contains
(
c
)
)
|
|
(
c
>
=
256
&
&
fPattern
-
>
fInitialChars
-
>
contains
(
c
)
)
)
)
{
MatchAt
(
pos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
pos
)
;
}
if
(
startPos
>
testStartLimit
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
}
UPRV_UNREACHABLE_EXIT
;
case
START_STRING
:
case
START_CHAR
:
{
U_ASSERT
(
fPattern
-
>
fMinMatchLen
>
0
)
;
UChar32
theChar
=
fPattern
-
>
fInitialChar
;
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
for
(
;
;
)
{
int64_t
pos
=
startPos
;
c
=
UTEXT_NEXT32
(
fInputText
)
;
startPos
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
if
(
c
=
=
theChar
)
{
MatchAt
(
pos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
}
if
(
startPos
>
testStartLimit
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
}
UPRV_UNREACHABLE_EXIT
;
case
START_LINE
:
{
UChar32
ch
;
if
(
startPos
=
=
fAnchorStart
)
{
MatchAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
ch
=
UTEXT_NEXT32
(
fInputText
)
;
startPos
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
ch
=
UTEXT_PREVIOUS32
(
fInputText
)
;
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
}
if
(
fPattern
-
>
fFlags
&
UREGEX_UNIX_LINES
)
{
for
(
;
;
)
{
if
(
ch
=
=
0x0a
)
{
MatchAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
}
if
(
startPos
>
=
testStartLimit
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
ch
=
UTEXT_NEXT32
(
fInputText
)
;
startPos
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
}
else
{
for
(
;
;
)
{
if
(
isLineTerminator
(
ch
)
)
{
if
(
ch
=
=
0x0d
&
&
startPos
<
fActiveLimit
&
&
UTEXT_CURRENT32
(
fInputText
)
=
=
0x0a
)
{
(
void
)
UTEXT_NEXT32
(
fInputText
)
;
startPos
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
MatchAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
startPos
)
;
}
if
(
startPos
>
=
testStartLimit
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
ch
=
UTEXT_NEXT32
(
fInputText
)
;
startPos
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
}
}
default
:
UPRV_UNREACHABLE_ASSERT
;
status
=
U_INTERNAL_PROGRAM_ERROR
;
return
false
;
}
UPRV_UNREACHABLE_EXIT
;
}
UBool
RegexMatcher
:
:
find
(
int64_t
start
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
false
;
}
this
-
>
reset
(
)
;
if
(
start
<
0
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
false
;
}
int64_t
nativeStart
=
start
;
if
(
nativeStart
<
fActiveStart
|
|
nativeStart
>
fActiveLimit
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
false
;
}
fMatchEnd
=
nativeStart
;
return
find
(
status
)
;
}
UBool
RegexMatcher
:
:
findUsingChunk
(
UErrorCode
&
status
)
{
int32_t
startPos
=
(
int32_t
)
fMatchEnd
;
if
(
startPos
=
=
0
)
{
startPos
=
(
int32_t
)
fActiveStart
;
}
const
char16_t
*
inputBuf
=
fInputText
-
>
chunkContents
;
if
(
fMatch
)
{
fLastMatchEnd
=
fMatchEnd
;
if
(
fMatchStart
=
=
fMatchEnd
)
{
if
(
startPos
>
=
fActiveLimit
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
U16_FWD_1
(
inputBuf
startPos
fInputLength
)
;
}
}
else
{
if
(
fLastMatchEnd
>
=
0
)
{
fHitEnd
=
true
;
return
false
;
}
}
int32_t
testLen
=
(
int32_t
)
(
fActiveLimit
-
fPattern
-
>
fMinMatchLen
)
;
if
(
startPos
>
testLen
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
UChar32
c
;
U_ASSERT
(
startPos
>
=
0
)
;
switch
(
fPattern
-
>
fStartType
)
{
case
START_NO_INFO
:
for
(
;
;
)
{
MatchChunkAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
if
(
startPos
>
=
testLen
)
{
fHitEnd
=
true
;
return
false
;
}
U16_FWD_1
(
inputBuf
startPos
fActiveLimit
)
;
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
UPRV_UNREACHABLE_EXIT
;
case
START_START
:
if
(
startPos
>
fActiveStart
)
{
fMatch
=
false
;
return
false
;
}
MatchChunkAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
return
fMatch
;
case
START_SET
:
{
U_ASSERT
(
fPattern
-
>
fMinMatchLen
>
0
)
;
for
(
;
;
)
{
int32_t
pos
=
startPos
;
U16_NEXT
(
inputBuf
startPos
fActiveLimit
c
)
;
if
(
(
c
<
256
&
&
fPattern
-
>
fInitialChars8
-
>
contains
(
c
)
)
|
|
(
c
>
=
256
&
&
fPattern
-
>
fInitialChars
-
>
contains
(
c
)
)
)
{
MatchChunkAt
(
pos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
}
if
(
startPos
>
testLen
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
}
UPRV_UNREACHABLE_EXIT
;
case
START_STRING
:
case
START_CHAR
:
{
U_ASSERT
(
fPattern
-
>
fMinMatchLen
>
0
)
;
UChar32
theChar
=
fPattern
-
>
fInitialChar
;
for
(
;
;
)
{
int32_t
pos
=
startPos
;
U16_NEXT
(
inputBuf
startPos
fActiveLimit
c
)
;
if
(
c
=
=
theChar
)
{
MatchChunkAt
(
pos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
}
if
(
startPos
>
testLen
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
}
UPRV_UNREACHABLE_EXIT
;
case
START_LINE
:
{
UChar32
ch
;
if
(
startPos
=
=
fAnchorStart
)
{
MatchChunkAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
U16_FWD_1
(
inputBuf
startPos
fActiveLimit
)
;
}
if
(
fPattern
-
>
fFlags
&
UREGEX_UNIX_LINES
)
{
for
(
;
;
)
{
ch
=
inputBuf
[
startPos
-
1
]
;
if
(
ch
=
=
0x0a
)
{
MatchChunkAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
}
if
(
startPos
>
=
testLen
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
U16_FWD_1
(
inputBuf
startPos
fActiveLimit
)
;
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
}
else
{
for
(
;
;
)
{
ch
=
inputBuf
[
startPos
-
1
]
;
if
(
isLineTerminator
(
ch
)
)
{
if
(
ch
=
=
0x0d
&
&
startPos
<
fActiveLimit
&
&
inputBuf
[
startPos
]
=
=
0x0a
)
{
startPos
+
+
;
}
MatchChunkAt
(
startPos
false
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
fMatch
)
{
return
true
;
}
}
if
(
startPos
>
=
testLen
)
{
fMatch
=
false
;
fHitEnd
=
true
;
return
false
;
}
U16_FWD_1
(
inputBuf
startPos
fActiveLimit
)
;
if
(
findProgressInterrupt
(
startPos
status
)
)
return
false
;
}
}
}
default
:
UPRV_UNREACHABLE_ASSERT
;
status
=
U_INTERNAL_PROGRAM_ERROR
;
return
false
;
}
UPRV_UNREACHABLE_EXIT
;
}
UnicodeString
RegexMatcher
:
:
group
(
UErrorCode
&
status
)
const
{
return
group
(
0
status
)
;
}
UText
*
RegexMatcher
:
:
group
(
UText
*
dest
int64_t
&
group_len
UErrorCode
&
status
)
const
{
return
group
(
0
dest
group_len
status
)
;
}
UText
*
RegexMatcher
:
:
group
(
int32_t
groupNum
UText
*
dest
int64_t
&
group_len
UErrorCode
&
status
)
const
{
group_len
=
0
;
if
(
U_FAILURE
(
status
)
)
{
return
dest
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
}
else
if
(
fMatch
=
=
false
)
{
status
=
U_REGEX_INVALID_STATE
;
}
else
if
(
groupNum
<
0
|
|
groupNum
>
fPattern
-
>
fGroupMap
-
>
size
(
)
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
}
if
(
U_FAILURE
(
status
)
)
{
return
dest
;
}
int64_t
s
e
;
if
(
groupNum
=
=
0
)
{
s
=
fMatchStart
;
e
=
fMatchEnd
;
}
else
{
int32_t
groupOffset
=
fPattern
-
>
fGroupMap
-
>
elementAti
(
groupNum
-
1
)
;
U_ASSERT
(
groupOffset
<
fPattern
-
>
fFrameSize
)
;
U_ASSERT
(
groupOffset
>
=
0
)
;
s
=
fFrame
-
>
fExtra
[
groupOffset
]
;
e
=
fFrame
-
>
fExtra
[
groupOffset
+
1
]
;
}
if
(
s
<
0
)
{
return
utext_clone
(
dest
fInputText
false
true
&
status
)
;
}
U_ASSERT
(
s
<
=
e
)
;
group_len
=
e
-
s
;
dest
=
utext_clone
(
dest
fInputText
false
true
&
status
)
;
if
(
dest
)
UTEXT_SETNATIVEINDEX
(
dest
s
)
;
return
dest
;
}
UnicodeString
RegexMatcher
:
:
group
(
int32_t
groupNum
UErrorCode
&
status
)
const
{
UnicodeString
result
;
int64_t
groupStart
=
start64
(
groupNum
status
)
;
int64_t
groupEnd
=
end64
(
groupNum
status
)
;
if
(
U_FAILURE
(
status
)
|
|
groupStart
=
=
-
1
|
|
groupStart
=
=
groupEnd
)
{
return
result
;
}
int32_t
length
=
utext_extract
(
fInputText
groupStart
groupEnd
nullptr
0
&
status
)
;
if
(
status
!
=
U_BUFFER_OVERFLOW_ERROR
)
{
return
result
;
}
status
=
U_ZERO_ERROR
;
char16_t
*
buf
=
result
.
getBuffer
(
length
)
;
if
(
buf
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
else
{
int32_t
extractLength
=
utext_extract
(
fInputText
groupStart
groupEnd
buf
length
&
status
)
;
result
.
releaseBuffer
(
extractLength
)
;
U_ASSERT
(
length
=
=
extractLength
)
;
}
return
result
;
}
int64_t
RegexMatcher
:
:
appendGroup
(
int32_t
groupNum
UText
*
dest
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
0
;
}
int64_t
destLen
=
utext_nativeLength
(
dest
)
;
if
(
fMatch
=
=
false
)
{
status
=
U_REGEX_INVALID_STATE
;
return
utext_replace
(
dest
destLen
destLen
nullptr
0
&
status
)
;
}
if
(
groupNum
<
0
|
|
groupNum
>
fPattern
-
>
fGroupMap
-
>
size
(
)
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
utext_replace
(
dest
destLen
destLen
nullptr
0
&
status
)
;
}
int64_t
s
e
;
if
(
groupNum
=
=
0
)
{
s
=
fMatchStart
;
e
=
fMatchEnd
;
}
else
{
int32_t
groupOffset
=
fPattern
-
>
fGroupMap
-
>
elementAti
(
groupNum
-
1
)
;
U_ASSERT
(
groupOffset
<
fPattern
-
>
fFrameSize
)
;
U_ASSERT
(
groupOffset
>
=
0
)
;
s
=
fFrame
-
>
fExtra
[
groupOffset
]
;
e
=
fFrame
-
>
fExtra
[
groupOffset
+
1
]
;
}
if
(
s
<
0
)
{
return
utext_replace
(
dest
destLen
destLen
nullptr
0
&
status
)
;
}
U_ASSERT
(
s
<
=
e
)
;
int64_t
deltaLen
;
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
fInputText
fInputLength
)
)
{
U_ASSERT
(
e
<
=
fInputLength
)
;
deltaLen
=
utext_replace
(
dest
destLen
destLen
fInputText
-
>
chunkContents
+
s
(
int32_t
)
(
e
-
s
)
&
status
)
;
}
else
{
int32_t
len16
;
if
(
UTEXT_USES_U16
(
fInputText
)
)
{
len16
=
(
int32_t
)
(
e
-
s
)
;
}
else
{
UErrorCode
lengthStatus
=
U_ZERO_ERROR
;
len16
=
utext_extract
(
fInputText
s
e
nullptr
0
&
lengthStatus
)
;
}
char16_t
*
groupChars
=
(
char16_t
*
)
uprv_malloc
(
sizeof
(
char16_t
)
*
(
len16
+
1
)
)
;
if
(
groupChars
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
0
;
}
utext_extract
(
fInputText
s
e
groupChars
len16
+
1
&
status
)
;
deltaLen
=
utext_replace
(
dest
destLen
destLen
groupChars
len16
&
status
)
;
uprv_free
(
groupChars
)
;
}
return
deltaLen
;
}
int32_t
RegexMatcher
:
:
groupCount
(
)
const
{
return
fPattern
-
>
fGroupMap
-
>
size
(
)
;
}
UBool
RegexMatcher
:
:
hasAnchoringBounds
(
)
const
{
return
fAnchoringBounds
;
}
UBool
RegexMatcher
:
:
hasTransparentBounds
(
)
const
{
return
fTransparentBounds
;
}
UBool
RegexMatcher
:
:
hitEnd
(
)
const
{
return
fHitEnd
;
}
const
UnicodeString
&
RegexMatcher
:
:
input
(
)
const
{
if
(
!
fInput
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
len16
;
if
(
UTEXT_USES_U16
(
fInputText
)
)
{
len16
=
(
int32_t
)
fInputLength
;
}
else
{
len16
=
utext_extract
(
fInputText
0
fInputLength
nullptr
0
&
status
)
;
status
=
U_ZERO_ERROR
;
}
UnicodeString
*
result
=
new
UnicodeString
(
len16
0
0
)
;
char16_t
*
inputChars
=
result
-
>
getBuffer
(
len16
)
;
utext_extract
(
fInputText
0
fInputLength
inputChars
len16
&
status
)
;
result
-
>
releaseBuffer
(
len16
)
;
(
*
(
const
UnicodeString
*
*
)
&
fInput
)
=
result
;
}
return
*
fInput
;
}
UText
*
RegexMatcher
:
:
inputText
(
)
const
{
return
fInputText
;
}
UText
*
RegexMatcher
:
:
getInput
(
UText
*
dest
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
dest
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
dest
;
}
if
(
dest
)
{
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
fInputText
fInputLength
)
)
{
utext_replace
(
dest
0
utext_nativeLength
(
dest
)
fInputText
-
>
chunkContents
(
int32_t
)
fInputLength
&
status
)
;
}
else
{
int32_t
input16Len
;
if
(
UTEXT_USES_U16
(
fInputText
)
)
{
input16Len
=
(
int32_t
)
fInputLength
;
}
else
{
UErrorCode
lengthStatus
=
U_ZERO_ERROR
;
input16Len
=
utext_extract
(
fInputText
0
fInputLength
nullptr
0
&
lengthStatus
)
;
}
char16_t
*
inputChars
=
(
char16_t
*
)
uprv_malloc
(
sizeof
(
char16_t
)
*
(
input16Len
)
)
;
if
(
inputChars
=
=
nullptr
)
{
return
dest
;
}
status
=
U_ZERO_ERROR
;
utext_extract
(
fInputText
0
fInputLength
inputChars
input16Len
&
status
)
;
status
=
U_ZERO_ERROR
;
utext_replace
(
dest
0
utext_nativeLength
(
dest
)
inputChars
input16Len
&
status
)
;
uprv_free
(
inputChars
)
;
}
return
dest
;
}
else
{
return
utext_clone
(
nullptr
fInputText
false
true
&
status
)
;
}
}
static
UBool
compat_SyncMutableUTextContents
(
UText
*
ut
)
;
static
UBool
compat_SyncMutableUTextContents
(
UText
*
ut
)
{
UBool
retVal
=
false
;
if
(
utext_nativeLength
(
ut
)
!
=
ut
-
>
nativeIndexingLimit
)
{
UnicodeString
*
us
=
(
UnicodeString
*
)
ut
-
>
context
;
int32_t
newLength
=
us
-
>
length
(
)
;
ut
-
>
chunkContents
=
us
-
>
getBuffer
(
)
;
ut
-
>
chunkLength
=
newLength
;
ut
-
>
chunkNativeLimit
=
newLength
;
ut
-
>
nativeIndexingLimit
=
newLength
;
retVal
=
true
;
}
return
retVal
;
}
UBool
RegexMatcher
:
:
lookingAt
(
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
false
;
}
if
(
fInputUniStrMaybeMutable
)
{
if
(
compat_SyncMutableUTextContents
(
fInputText
)
)
{
fInputLength
=
utext_nativeLength
(
fInputText
)
;
reset
(
)
;
}
}
else
{
resetPreserveRegion
(
)
;
}
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
fInputText
fInputLength
)
)
{
MatchChunkAt
(
(
int32_t
)
fActiveStart
false
status
)
;
}
else
{
MatchAt
(
fActiveStart
false
status
)
;
}
return
fMatch
;
}
UBool
RegexMatcher
:
:
lookingAt
(
int64_t
start
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
false
;
}
reset
(
)
;
if
(
start
<
0
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
false
;
}
if
(
fInputUniStrMaybeMutable
)
{
if
(
compat_SyncMutableUTextContents
(
fInputText
)
)
{
fInputLength
=
utext_nativeLength
(
fInputText
)
;
reset
(
)
;
}
}
int64_t
nativeStart
;
nativeStart
=
start
;
if
(
nativeStart
<
fActiveStart
|
|
nativeStart
>
fActiveLimit
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
false
;
}
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
fInputText
fInputLength
)
)
{
MatchChunkAt
(
(
int32_t
)
nativeStart
false
status
)
;
}
else
{
MatchAt
(
nativeStart
false
status
)
;
}
return
fMatch
;
}
UBool
RegexMatcher
:
:
matches
(
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
false
;
}
if
(
fInputUniStrMaybeMutable
)
{
if
(
compat_SyncMutableUTextContents
(
fInputText
)
)
{
fInputLength
=
utext_nativeLength
(
fInputText
)
;
reset
(
)
;
}
}
else
{
resetPreserveRegion
(
)
;
}
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
fInputText
fInputLength
)
)
{
MatchChunkAt
(
(
int32_t
)
fActiveStart
true
status
)
;
}
else
{
MatchAt
(
fActiveStart
true
status
)
;
}
return
fMatch
;
}
UBool
RegexMatcher
:
:
matches
(
int64_t
start
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
false
;
}
reset
(
)
;
if
(
start
<
0
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
false
;
}
if
(
fInputUniStrMaybeMutable
)
{
if
(
compat_SyncMutableUTextContents
(
fInputText
)
)
{
fInputLength
=
utext_nativeLength
(
fInputText
)
;
reset
(
)
;
}
}
int64_t
nativeStart
;
nativeStart
=
start
;
if
(
nativeStart
<
fActiveStart
|
|
nativeStart
>
fActiveLimit
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
false
;
}
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
fInputText
fInputLength
)
)
{
MatchChunkAt
(
(
int32_t
)
nativeStart
true
status
)
;
}
else
{
MatchAt
(
nativeStart
true
status
)
;
}
return
fMatch
;
}
const
RegexPattern
&
RegexMatcher
:
:
pattern
(
)
const
{
return
*
fPattern
;
}
RegexMatcher
&
RegexMatcher
:
:
region
(
int64_t
regionStart
int64_t
regionLimit
int64_t
startIndex
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
*
this
;
}
if
(
regionStart
>
regionLimit
|
|
regionStart
<
0
|
|
regionLimit
<
0
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
int64_t
nativeStart
=
regionStart
;
int64_t
nativeLimit
=
regionLimit
;
if
(
nativeStart
>
fInputLength
|
|
nativeLimit
>
fInputLength
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
if
(
startIndex
=
=
-
1
)
this
-
>
reset
(
)
;
else
resetPreserveRegion
(
)
;
fRegionStart
=
nativeStart
;
fRegionLimit
=
nativeLimit
;
fActiveStart
=
nativeStart
;
fActiveLimit
=
nativeLimit
;
if
(
startIndex
!
=
-
1
)
{
if
(
startIndex
<
fActiveStart
|
|
startIndex
>
fActiveLimit
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
}
fMatchEnd
=
startIndex
;
}
if
(
!
fTransparentBounds
)
{
fLookStart
=
nativeStart
;
fLookLimit
=
nativeLimit
;
}
if
(
fAnchoringBounds
)
{
fAnchorStart
=
nativeStart
;
fAnchorLimit
=
nativeLimit
;
}
return
*
this
;
}
RegexMatcher
&
RegexMatcher
:
:
region
(
int64_t
start
int64_t
limit
UErrorCode
&
status
)
{
return
region
(
start
limit
-
1
status
)
;
}
int32_t
RegexMatcher
:
:
regionEnd
(
)
const
{
return
(
int32_t
)
fRegionLimit
;
}
int64_t
RegexMatcher
:
:
regionEnd64
(
)
const
{
return
fRegionLimit
;
}
int32_t
RegexMatcher
:
:
regionStart
(
)
const
{
return
(
int32_t
)
fRegionStart
;
}
int64_t
RegexMatcher
:
:
regionStart64
(
)
const
{
return
fRegionStart
;
}
UnicodeString
RegexMatcher
:
:
replaceAll
(
const
UnicodeString
&
replacement
UErrorCode
&
status
)
{
UText
replacementText
=
UTEXT_INITIALIZER
;
UText
resultText
=
UTEXT_INITIALIZER
;
UnicodeString
resultString
;
if
(
U_FAILURE
(
status
)
)
{
return
resultString
;
}
utext_openConstUnicodeString
(
&
replacementText
&
replacement
&
status
)
;
utext_openUnicodeString
(
&
resultText
&
resultString
&
status
)
;
replaceAll
(
&
replacementText
&
resultText
status
)
;
utext_close
(
&
resultText
)
;
utext_close
(
&
replacementText
)
;
return
resultString
;
}
UText
*
RegexMatcher
:
:
replaceAll
(
UText
*
replacement
UText
*
dest
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
dest
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
dest
;
}
if
(
dest
=
=
nullptr
)
{
UnicodeString
emptyString
;
UText
empty
=
UTEXT_INITIALIZER
;
utext_openUnicodeString
(
&
empty
&
emptyString
&
status
)
;
dest
=
utext_clone
(
nullptr
&
empty
true
false
&
status
)
;
utext_close
(
&
empty
)
;
}
if
(
U_SUCCESS
(
status
)
)
{
reset
(
)
;
while
(
find
(
)
)
{
appendReplacement
(
dest
replacement
status
)
;
if
(
U_FAILURE
(
status
)
)
{
break
;
}
}
appendTail
(
dest
status
)
;
}
return
dest
;
}
UnicodeString
RegexMatcher
:
:
replaceFirst
(
const
UnicodeString
&
replacement
UErrorCode
&
status
)
{
UText
replacementText
=
UTEXT_INITIALIZER
;
UText
resultText
=
UTEXT_INITIALIZER
;
UnicodeString
resultString
;
utext_openConstUnicodeString
(
&
replacementText
&
replacement
&
status
)
;
utext_openUnicodeString
(
&
resultText
&
resultString
&
status
)
;
replaceFirst
(
&
replacementText
&
resultText
status
)
;
utext_close
(
&
resultText
)
;
utext_close
(
&
replacementText
)
;
return
resultString
;
}
UText
*
RegexMatcher
:
:
replaceFirst
(
UText
*
replacement
UText
*
dest
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
dest
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
dest
;
}
reset
(
)
;
if
(
!
find
(
)
)
{
return
getInput
(
dest
status
)
;
}
if
(
dest
=
=
nullptr
)
{
UnicodeString
emptyString
;
UText
empty
=
UTEXT_INITIALIZER
;
utext_openUnicodeString
(
&
empty
&
emptyString
&
status
)
;
dest
=
utext_clone
(
nullptr
&
empty
true
false
&
status
)
;
utext_close
(
&
empty
)
;
}
appendReplacement
(
dest
replacement
status
)
;
appendTail
(
dest
status
)
;
return
dest
;
}
UBool
RegexMatcher
:
:
requireEnd
(
)
const
{
return
fRequireEnd
;
}
RegexMatcher
&
RegexMatcher
:
:
reset
(
)
{
fRegionStart
=
0
;
fRegionLimit
=
fInputLength
;
fActiveStart
=
0
;
fActiveLimit
=
fInputLength
;
fAnchorStart
=
0
;
fAnchorLimit
=
fInputLength
;
fLookStart
=
0
;
fLookLimit
=
fInputLength
;
resetPreserveRegion
(
)
;
return
*
this
;
}
void
RegexMatcher
:
:
resetPreserveRegion
(
)
{
fMatchStart
=
0
;
fMatchEnd
=
0
;
fLastMatchEnd
=
-
1
;
fAppendPosition
=
0
;
fMatch
=
false
;
fHitEnd
=
false
;
fRequireEnd
=
false
;
fTime
=
0
;
fTickCounter
=
TIMER_INITIAL_VALUE
;
}
RegexMatcher
&
RegexMatcher
:
:
reset
(
const
UnicodeString
&
input
)
{
fInputText
=
utext_openConstUnicodeString
(
fInputText
&
input
&
fDeferredStatus
)
;
if
(
fPattern
-
>
fNeedsAltInput
)
{
fAltInputText
=
utext_clone
(
fAltInputText
fInputText
false
true
&
fDeferredStatus
)
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
return
*
this
;
}
fInputLength
=
utext_nativeLength
(
fInputText
)
;
reset
(
)
;
delete
fInput
;
fInput
=
nullptr
;
fInputUniStrMaybeMutable
=
true
;
#
if
UCONFIG_NO_BREAK_ITERATION
=
=
0
if
(
fWordBreakItr
)
{
fWordBreakItr
-
>
setText
(
fInputText
fDeferredStatus
)
;
}
if
(
fGCBreakItr
)
{
fGCBreakItr
-
>
setText
(
fInputText
fDeferredStatus
)
;
}
#
endif
return
*
this
;
}
RegexMatcher
&
RegexMatcher
:
:
reset
(
UText
*
input
)
{
if
(
fInputText
!
=
input
)
{
fInputText
=
utext_clone
(
fInputText
input
false
true
&
fDeferredStatus
)
;
if
(
fPattern
-
>
fNeedsAltInput
)
fAltInputText
=
utext_clone
(
fAltInputText
fInputText
false
true
&
fDeferredStatus
)
;
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
return
*
this
;
}
fInputLength
=
utext_nativeLength
(
fInputText
)
;
delete
fInput
;
fInput
=
nullptr
;
#
if
UCONFIG_NO_BREAK_ITERATION
=
=
0
if
(
fWordBreakItr
)
{
fWordBreakItr
-
>
setText
(
input
fDeferredStatus
)
;
}
if
(
fGCBreakItr
)
{
fGCBreakItr
-
>
setText
(
fInputText
fDeferredStatus
)
;
}
#
endif
}
reset
(
)
;
fInputUniStrMaybeMutable
=
false
;
return
*
this
;
}
RegexMatcher
&
RegexMatcher
:
:
reset
(
int64_t
position
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
*
this
;
}
reset
(
)
;
if
(
position
<
0
|
|
position
>
fActiveLimit
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
*
this
;
}
fMatchEnd
=
position
;
return
*
this
;
}
RegexMatcher
&
RegexMatcher
:
:
refreshInputText
(
UText
*
input
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
*
this
;
}
if
(
input
=
=
nullptr
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
*
this
;
}
if
(
utext_nativeLength
(
fInputText
)
!
=
utext_nativeLength
(
input
)
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
*
this
;
}
int64_t
pos
=
utext_getNativeIndex
(
fInputText
)
;
fInputText
=
utext_clone
(
fInputText
input
false
true
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
*
this
;
}
utext_setNativeIndex
(
fInputText
pos
)
;
if
(
fAltInputText
!
=
nullptr
)
{
pos
=
utext_getNativeIndex
(
fAltInputText
)
;
fAltInputText
=
utext_clone
(
fAltInputText
input
false
true
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
*
this
;
}
utext_setNativeIndex
(
fAltInputText
pos
)
;
}
return
*
this
;
}
void
RegexMatcher
:
:
setTrace
(
UBool
state
)
{
fTraceDebug
=
state
;
}
static
UText
*
utext_extract_replace
(
UText
*
src
UText
*
dest
int64_t
start
int64_t
limit
UErrorCode
*
status
)
{
if
(
U_FAILURE
(
*
status
)
)
{
return
dest
;
}
if
(
start
=
=
limit
)
{
if
(
dest
)
{
utext_replace
(
dest
0
utext_nativeLength
(
dest
)
nullptr
0
status
)
;
return
dest
;
}
else
{
return
utext_openUChars
(
nullptr
nullptr
0
status
)
;
}
}
int32_t
length
=
utext_extract
(
src
start
limit
nullptr
0
status
)
;
if
(
*
status
!
=
U_BUFFER_OVERFLOW_ERROR
&
&
U_FAILURE
(
*
status
)
)
{
return
dest
;
}
*
status
=
U_ZERO_ERROR
;
MaybeStackArray
<
char16_t
40
>
buffer
;
if
(
length
>
=
buffer
.
getCapacity
(
)
)
{
char16_t
*
newBuf
=
buffer
.
resize
(
length
+
1
)
;
if
(
newBuf
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
}
utext_extract
(
src
start
limit
buffer
.
getAlias
(
)
length
+
1
status
)
;
if
(
dest
)
{
utext_replace
(
dest
0
utext_nativeLength
(
dest
)
buffer
.
getAlias
(
)
length
status
)
;
return
dest
;
}
if
(
U_FAILURE
(
*
status
)
)
{
return
nullptr
;
}
int32_t
ownedLength
=
0
;
char16_t
*
ownedBuf
=
buffer
.
orphanOrClone
(
length
+
1
ownedLength
)
;
if
(
ownedBuf
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
UText
*
result
=
utext_openUChars
(
nullptr
ownedBuf
length
status
)
;
if
(
U_FAILURE
(
*
status
)
)
{
uprv_free
(
ownedBuf
)
;
return
nullptr
;
}
result
-
>
providerProperties
|
=
(
1
<
<
UTEXT_PROVIDER_OWNS_TEXT
)
;
return
result
;
}
int32_t
RegexMatcher
:
:
split
(
const
UnicodeString
&
input
UnicodeString
dest
[
]
int32_t
destCapacity
UErrorCode
&
status
)
{
UText
inputText
=
UTEXT_INITIALIZER
;
utext_openConstUnicodeString
(
&
inputText
&
input
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
UText
*
*
destText
=
(
UText
*
*
)
uprv_malloc
(
sizeof
(
UText
*
)
*
destCapacity
)
;
if
(
destText
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
0
;
}
int32_t
i
;
for
(
i
=
0
;
i
<
destCapacity
;
i
+
+
)
{
destText
[
i
]
=
utext_openUnicodeString
(
nullptr
&
dest
[
i
]
&
status
)
;
}
int32_t
fieldCount
=
split
(
&
inputText
destText
destCapacity
status
)
;
for
(
i
=
0
;
i
<
destCapacity
;
i
+
+
)
{
utext_close
(
destText
[
i
]
)
;
}
uprv_free
(
destText
)
;
utext_close
(
&
inputText
)
;
return
fieldCount
;
}
int32_t
RegexMatcher
:
:
split
(
UText
*
input
UText
*
dest
[
]
int32_t
destCapacity
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
if
(
destCapacity
<
1
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
reset
(
input
)
;
int64_t
nextOutputStringStart
=
0
;
if
(
fActiveLimit
=
=
0
)
{
return
0
;
}
int32_t
i
;
int32_t
numCaptureGroups
=
fPattern
-
>
fGroupMap
-
>
size
(
)
;
for
(
i
=
0
;
;
i
+
+
)
{
if
(
i
>
=
destCapacity
-
1
)
{
i
=
destCapacity
-
1
;
if
(
fActiveLimit
>
nextOutputStringStart
)
{
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
input
fInputLength
)
)
{
if
(
dest
[
i
]
)
{
utext_replace
(
dest
[
i
]
0
utext_nativeLength
(
dest
[
i
]
)
input
-
>
chunkContents
+
nextOutputStringStart
(
int32_t
)
(
fActiveLimit
-
nextOutputStringStart
)
&
status
)
;
}
else
{
UText
remainingText
=
UTEXT_INITIALIZER
;
utext_openUChars
(
&
remainingText
input
-
>
chunkContents
+
nextOutputStringStart
fActiveLimit
-
nextOutputStringStart
&
status
)
;
dest
[
i
]
=
utext_clone
(
nullptr
&
remainingText
true
false
&
status
)
;
utext_close
(
&
remainingText
)
;
}
}
else
{
UErrorCode
lengthStatus
=
U_ZERO_ERROR
;
int32_t
remaining16Length
=
utext_extract
(
input
nextOutputStringStart
fActiveLimit
nullptr
0
&
lengthStatus
)
;
char16_t
*
remainingChars
=
(
char16_t
*
)
uprv_malloc
(
sizeof
(
char16_t
)
*
(
remaining16Length
+
1
)
)
;
if
(
remainingChars
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
utext_extract
(
input
nextOutputStringStart
fActiveLimit
remainingChars
remaining16Length
+
1
&
status
)
;
if
(
dest
[
i
]
)
{
utext_replace
(
dest
[
i
]
0
utext_nativeLength
(
dest
[
i
]
)
remainingChars
remaining16Length
&
status
)
;
}
else
{
UText
remainingText
=
UTEXT_INITIALIZER
;
utext_openUChars
(
&
remainingText
remainingChars
remaining16Length
&
status
)
;
dest
[
i
]
=
utext_clone
(
nullptr
&
remainingText
true
false
&
status
)
;
utext_close
(
&
remainingText
)
;
}
uprv_free
(
remainingChars
)
;
}
}
break
;
}
if
(
find
(
)
)
{
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
input
fInputLength
)
)
{
if
(
dest
[
i
]
)
{
utext_replace
(
dest
[
i
]
0
utext_nativeLength
(
dest
[
i
]
)
input
-
>
chunkContents
+
nextOutputStringStart
(
int32_t
)
(
fMatchStart
-
nextOutputStringStart
)
&
status
)
;
}
else
{
UText
remainingText
=
UTEXT_INITIALIZER
;
utext_openUChars
(
&
remainingText
input
-
>
chunkContents
+
nextOutputStringStart
fMatchStart
-
nextOutputStringStart
&
status
)
;
dest
[
i
]
=
utext_clone
(
nullptr
&
remainingText
true
false
&
status
)
;
utext_close
(
&
remainingText
)
;
}
}
else
{
UErrorCode
lengthStatus
=
U_ZERO_ERROR
;
int32_t
remaining16Length
=
utext_extract
(
input
nextOutputStringStart
fMatchStart
nullptr
0
&
lengthStatus
)
;
char16_t
*
remainingChars
=
(
char16_t
*
)
uprv_malloc
(
sizeof
(
char16_t
)
*
(
remaining16Length
+
1
)
)
;
if
(
remainingChars
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
utext_extract
(
input
nextOutputStringStart
fMatchStart
remainingChars
remaining16Length
+
1
&
status
)
;
if
(
dest
[
i
]
)
{
utext_replace
(
dest
[
i
]
0
utext_nativeLength
(
dest
[
i
]
)
remainingChars
remaining16Length
&
status
)
;
}
else
{
UText
remainingText
=
UTEXT_INITIALIZER
;
utext_openUChars
(
&
remainingText
remainingChars
remaining16Length
&
status
)
;
dest
[
i
]
=
utext_clone
(
nullptr
&
remainingText
true
false
&
status
)
;
utext_close
(
&
remainingText
)
;
}
uprv_free
(
remainingChars
)
;
}
nextOutputStringStart
=
fMatchEnd
;
int32_t
groupNum
;
for
(
groupNum
=
1
;
groupNum
<
=
numCaptureGroups
;
groupNum
+
+
)
{
if
(
i
>
=
destCapacity
-
2
)
{
break
;
}
i
+
+
;
dest
[
i
]
=
utext_extract_replace
(
fInputText
dest
[
i
]
start64
(
groupNum
status
)
end64
(
groupNum
status
)
&
status
)
;
}
if
(
nextOutputStringStart
=
=
fActiveLimit
)
{
if
(
i
+
1
<
destCapacity
)
{
+
+
i
;
if
(
dest
[
i
]
=
=
nullptr
)
{
dest
[
i
]
=
utext_openUChars
(
nullptr
nullptr
0
&
status
)
;
}
else
{
static
const
char16_t
emptyString
[
]
=
{
(
char16_t
)
0
}
;
utext_replace
(
dest
[
i
]
0
utext_nativeLength
(
dest
[
i
]
)
emptyString
0
&
status
)
;
}
}
break
;
}
}
else
{
if
(
UTEXT_FULL_TEXT_IN_CHUNK
(
input
fInputLength
)
)
{
if
(
dest
[
i
]
)
{
utext_replace
(
dest
[
i
]
0
utext_nativeLength
(
dest
[
i
]
)
input
-
>
chunkContents
+
nextOutputStringStart
(
int32_t
)
(
fActiveLimit
-
nextOutputStringStart
)
&
status
)
;
}
else
{
UText
remainingText
=
UTEXT_INITIALIZER
;
utext_openUChars
(
&
remainingText
input
-
>
chunkContents
+
nextOutputStringStart
fActiveLimit
-
nextOutputStringStart
&
status
)
;
dest
[
i
]
=
utext_clone
(
nullptr
&
remainingText
true
false
&
status
)
;
utext_close
(
&
remainingText
)
;
}
}
else
{
UErrorCode
lengthStatus
=
U_ZERO_ERROR
;
int32_t
remaining16Length
=
utext_extract
(
input
nextOutputStringStart
fActiveLimit
nullptr
0
&
lengthStatus
)
;
char16_t
*
remainingChars
=
(
char16_t
*
)
uprv_malloc
(
sizeof
(
char16_t
)
*
(
remaining16Length
+
1
)
)
;
if
(
remainingChars
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
utext_extract
(
input
nextOutputStringStart
fActiveLimit
remainingChars
remaining16Length
+
1
&
status
)
;
if
(
dest
[
i
]
)
{
utext_replace
(
dest
[
i
]
0
utext_nativeLength
(
dest
[
i
]
)
remainingChars
remaining16Length
&
status
)
;
}
else
{
UText
remainingText
=
UTEXT_INITIALIZER
;
utext_openUChars
(
&
remainingText
remainingChars
remaining16Length
&
status
)
;
dest
[
i
]
=
utext_clone
(
nullptr
&
remainingText
true
false
&
status
)
;
utext_close
(
&
remainingText
)
;
}
uprv_free
(
remainingChars
)
;
}
break
;
}
if
(
U_FAILURE
(
status
)
)
{
break
;
}
}
return
i
+
1
;
}
int32_t
RegexMatcher
:
:
start
(
UErrorCode
&
status
)
const
{
return
start
(
0
status
)
;
}
int64_t
RegexMatcher
:
:
start64
(
UErrorCode
&
status
)
const
{
return
start64
(
0
status
)
;
}
int64_t
RegexMatcher
:
:
start64
(
int32_t
group
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
-
1
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
-
1
;
}
if
(
fMatch
=
=
false
)
{
status
=
U_REGEX_INVALID_STATE
;
return
-
1
;
}
if
(
group
<
0
|
|
group
>
fPattern
-
>
fGroupMap
-
>
size
(
)
)
{
status
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
-
1
;
}
int64_t
s
;
if
(
group
=
=
0
)
{
s
=
fMatchStart
;
}
else
{
int32_t
groupOffset
=
fPattern
-
>
fGroupMap
-
>
elementAti
(
group
-
1
)
;
U_ASSERT
(
groupOffset
<
fPattern
-
>
fFrameSize
)
;
U_ASSERT
(
groupOffset
>
=
0
)
;
s
=
fFrame
-
>
fExtra
[
groupOffset
]
;
}
return
s
;
}
int32_t
RegexMatcher
:
:
start
(
int32_t
group
UErrorCode
&
status
)
const
{
return
(
int32_t
)
start64
(
group
status
)
;
}
RegexMatcher
&
RegexMatcher
:
:
useAnchoringBounds
(
UBool
b
)
{
fAnchoringBounds
=
b
;
fAnchorStart
=
(
fAnchoringBounds
?
fRegionStart
:
0
)
;
fAnchorLimit
=
(
fAnchoringBounds
?
fRegionLimit
:
fInputLength
)
;
return
*
this
;
}
RegexMatcher
&
RegexMatcher
:
:
useTransparentBounds
(
UBool
b
)
{
fTransparentBounds
=
b
;
fLookStart
=
(
fTransparentBounds
?
0
:
fRegionStart
)
;
fLookLimit
=
(
fTransparentBounds
?
fInputLength
:
fRegionLimit
)
;
return
*
this
;
}
void
RegexMatcher
:
:
setTimeLimit
(
int32_t
limit
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
;
}
if
(
limit
<
0
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
fTimeLimit
=
limit
;
}
int32_t
RegexMatcher
:
:
getTimeLimit
(
)
const
{
return
fTimeLimit
;
}
void
RegexMatcher
:
:
setStackLimit
(
int32_t
limit
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
;
}
if
(
limit
<
0
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
reset
(
)
;
if
(
limit
=
=
0
)
{
fStack
-
>
setMaxCapacity
(
0
)
;
}
else
{
int32_t
adjustedLimit
=
limit
/
sizeof
(
int32_t
)
;
if
(
adjustedLimit
<
fPattern
-
>
fFrameSize
)
{
adjustedLimit
=
fPattern
-
>
fFrameSize
;
}
fStack
-
>
setMaxCapacity
(
adjustedLimit
)
;
}
fStackLimit
=
limit
;
}
int32_t
RegexMatcher
:
:
getStackLimit
(
)
const
{
return
fStackLimit
;
}
void
RegexMatcher
:
:
setMatchCallback
(
URegexMatchCallback
*
callback
const
void
*
context
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
fCallbackFn
=
callback
;
fCallbackContext
=
context
;
}
void
RegexMatcher
:
:
getMatchCallback
(
URegexMatchCallback
*
&
callback
const
void
*
&
context
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
callback
=
fCallbackFn
;
context
=
fCallbackContext
;
}
void
RegexMatcher
:
:
setFindProgressCallback
(
URegexFindProgressCallback
*
callback
const
void
*
context
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
fFindProgressCallbackFn
=
callback
;
fFindProgressCallbackContext
=
context
;
}
void
RegexMatcher
:
:
getFindProgressCallback
(
URegexFindProgressCallback
*
&
callback
const
void
*
&
context
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
callback
=
fFindProgressCallbackFn
;
context
=
fFindProgressCallbackContext
;
}
REStackFrame
*
RegexMatcher
:
:
resetStack
(
)
{
fStack
-
>
removeAllElements
(
)
;
REStackFrame
*
iFrame
=
(
REStackFrame
*
)
fStack
-
>
reserveBlock
(
fPattern
-
>
fFrameSize
fDeferredStatus
)
;
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
return
nullptr
;
}
int32_t
i
;
for
(
i
=
0
;
i
<
fPattern
-
>
fFrameSize
-
RESTACKFRAME_HDRCOUNT
;
i
+
+
)
{
iFrame
-
>
fExtra
[
i
]
=
-
1
;
}
return
iFrame
;
}
UBool
RegexMatcher
:
:
isWordBoundary
(
int64_t
pos
)
{
UBool
isBoundary
=
false
;
UBool
cIsWord
=
false
;
if
(
pos
>
=
fLookLimit
)
{
fHitEnd
=
true
;
}
else
{
UTEXT_SETNATIVEINDEX
(
fInputText
pos
)
;
UChar32
c
=
UTEXT_CURRENT32
(
fInputText
)
;
if
(
u_hasBinaryProperty
(
c
UCHAR_GRAPHEME_EXTEND
)
|
|
u_charType
(
c
)
=
=
U_FORMAT_CHAR
)
{
return
false
;
}
cIsWord
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets
[
URX_ISWORD_SET
]
.
contains
(
c
)
;
}
UBool
prevCIsWord
=
false
;
for
(
;
;
)
{
if
(
UTEXT_GETNATIVEINDEX
(
fInputText
)
<
=
fLookStart
)
{
break
;
}
UChar32
prevChar
=
UTEXT_PREVIOUS32
(
fInputText
)
;
if
(
!
(
u_hasBinaryProperty
(
prevChar
UCHAR_GRAPHEME_EXTEND
)
|
|
u_charType
(
prevChar
)
=
=
U_FORMAT_CHAR
)
)
{
prevCIsWord
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets
[
URX_ISWORD_SET
]
.
contains
(
prevChar
)
;
break
;
}
}
isBoundary
=
cIsWord
^
prevCIsWord
;
return
isBoundary
;
}
UBool
RegexMatcher
:
:
isChunkWordBoundary
(
int32_t
pos
)
{
UBool
isBoundary
=
false
;
UBool
cIsWord
=
false
;
const
char16_t
*
inputBuf
=
fInputText
-
>
chunkContents
;
if
(
pos
>
=
fLookLimit
)
{
fHitEnd
=
true
;
}
else
{
UChar32
c
;
U16_GET
(
inputBuf
fLookStart
pos
fLookLimit
c
)
;
if
(
u_hasBinaryProperty
(
c
UCHAR_GRAPHEME_EXTEND
)
|
|
u_charType
(
c
)
=
=
U_FORMAT_CHAR
)
{
return
false
;
}
cIsWord
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets
[
URX_ISWORD_SET
]
.
contains
(
c
)
;
}
UBool
prevCIsWord
=
false
;
for
(
;
;
)
{
if
(
pos
<
=
fLookStart
)
{
break
;
}
UChar32
prevChar
;
U16_PREV
(
inputBuf
fLookStart
pos
prevChar
)
;
if
(
!
(
u_hasBinaryProperty
(
prevChar
UCHAR_GRAPHEME_EXTEND
)
|
|
u_charType
(
prevChar
)
=
=
U_FORMAT_CHAR
)
)
{
prevCIsWord
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets
[
URX_ISWORD_SET
]
.
contains
(
prevChar
)
;
break
;
}
}
isBoundary
=
cIsWord
^
prevCIsWord
;
return
isBoundary
;
}
UBool
RegexMatcher
:
:
isUWordBoundary
(
int64_t
pos
UErrorCode
&
status
)
{
UBool
returnVal
=
false
;
#
if
UCONFIG_NO_BREAK_ITERATION
=
=
0
if
(
fWordBreakItr
=
=
nullptr
)
{
fWordBreakItr
=
BreakIterator
:
:
createWordInstance
(
Locale
:
:
getEnglish
(
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
false
;
}
fWordBreakItr
-
>
setText
(
fInputText
status
)
;
}
if
(
pos
>
=
fLookLimit
)
{
fHitEnd
=
true
;
returnVal
=
true
;
}
else
{
returnVal
=
fWordBreakItr
-
>
isBoundary
(
(
int32_t
)
pos
)
;
}
#
endif
return
returnVal
;
}
int64_t
RegexMatcher
:
:
followingGCBoundary
(
int64_t
pos
UErrorCode
&
status
)
{
int64_t
result
=
pos
;
#
if
UCONFIG_NO_BREAK_ITERATION
=
=
0
if
(
fGCBreakItr
=
=
nullptr
)
{
fGCBreakItr
=
BreakIterator
:
:
createCharacterInstance
(
Locale
:
:
getEnglish
(
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
pos
;
}
fGCBreakItr
-
>
setText
(
fInputText
status
)
;
}
result
=
fGCBreakItr
-
>
following
(
pos
)
;
if
(
result
=
=
BreakIterator
:
:
DONE
)
{
result
=
pos
;
}
#
endif
return
result
;
}
void
RegexMatcher
:
:
IncrementTime
(
UErrorCode
&
status
)
{
fTickCounter
=
TIMER_INITIAL_VALUE
;
fTime
+
+
;
if
(
fCallbackFn
!
=
nullptr
)
{
if
(
(
*
fCallbackFn
)
(
fCallbackContext
fTime
)
=
=
false
)
{
status
=
U_REGEX_STOPPED_BY_CALLER
;
return
;
}
}
if
(
fTimeLimit
>
0
&
&
fTime
>
=
fTimeLimit
)
{
status
=
U_REGEX_TIME_OUT
;
}
}
inline
REStackFrame
*
RegexMatcher
:
:
StateSave
(
REStackFrame
*
fp
int64_t
savePatIdx
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
fp
;
}
int64_t
*
newFP
=
fStack
-
>
reserveBlock
(
fFrameSize
status
)
;
if
(
U_FAILURE
(
status
)
)
{
status
=
U_REGEX_STACK_OVERFLOW
;
return
fp
;
}
fp
=
(
REStackFrame
*
)
(
newFP
-
fFrameSize
)
;
int64_t
*
source
=
(
int64_t
*
)
fp
;
int64_t
*
dest
=
newFP
;
for
(
;
;
)
{
*
dest
+
+
=
*
source
+
+
;
if
(
source
=
=
newFP
)
{
break
;
}
}
fTickCounter
-
-
;
if
(
fTickCounter
<
=
0
)
{
IncrementTime
(
status
)
;
}
fp
-
>
fPatIdx
=
savePatIdx
;
return
(
REStackFrame
*
)
newFP
;
}
#
if
defined
(
REGEX_DEBUG
)
namespace
{
UnicodeString
StringFromUText
(
UText
*
ut
)
{
UnicodeString
result
;
for
(
UChar32
c
=
utext_next32From
(
ut
0
)
;
c
!
=
U_SENTINEL
;
c
=
UTEXT_NEXT32
(
ut
)
)
{
result
.
append
(
c
)
;
}
return
result
;
}
}
#
endif
void
RegexMatcher
:
:
MatchAt
(
int64_t
startIdx
UBool
toEnd
UErrorCode
&
status
)
{
UBool
isMatch
=
false
;
int64_t
backSearchIndex
=
U_INT64_MAX
;
int32_t
op
;
int32_t
opType
;
int32_t
opValue
;
#
ifdef
REGEX_RUN_DEBUG
if
(
fTraceDebug
)
{
printf
(
"
MatchAt
(
startIdx
=
%
ld
)
\
n
"
startIdx
)
;
printf
(
"
Original
Pattern
:
\
"
%
s
\
"
\
n
"
CStr
(
StringFromUText
(
fPattern
-
>
fPattern
)
)
(
)
)
;
printf
(
"
Input
String
:
\
"
%
s
\
"
\
n
\
n
"
CStr
(
StringFromUText
(
fInputText
)
)
(
)
)
;
}
#
endif
if
(
U_FAILURE
(
status
)
)
{
return
;
}
int64_t
*
pat
=
fPattern
-
>
fCompiledPat
-
>
getBuffer
(
)
;
const
char16_t
*
litText
=
fPattern
-
>
fLiteralText
.
getBuffer
(
)
;
UVector
*
fSets
=
fPattern
-
>
fSets
;
fFrameSize
=
fPattern
-
>
fFrameSize
;
REStackFrame
*
fp
=
resetStack
(
)
;
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
;
}
fp
-
>
fPatIdx
=
0
;
fp
-
>
fInputIdx
=
startIdx
;
int32_t
i
;
for
(
i
=
0
;
i
<
fPattern
-
>
fDataSize
;
i
+
+
)
{
fData
[
i
]
=
0
;
}
for
(
;
;
)
{
op
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
opType
=
URX_TYPE
(
op
)
;
opValue
=
URX_VAL
(
op
)
;
#
ifdef
REGEX_RUN_DEBUG
if
(
fTraceDebug
)
{
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
printf
(
"
inputIdx
=
%
ld
inputChar
=
%
x
sp
=
%
3ld
activeLimit
=
%
ld
"
fp
-
>
fInputIdx
UTEXT_CURRENT32
(
fInputText
)
(
int64_t
*
)
fp
-
fStack
-
>
getBuffer
(
)
fActiveLimit
)
;
fPattern
-
>
dumpOp
(
fp
-
>
fPatIdx
)
;
}
#
endif
fp
-
>
fPatIdx
+
+
;
switch
(
opType
)
{
case
URX_NOP
:
break
;
case
URX_BACKTRACK
:
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
case
URX_ONECHAR
:
if
(
fp
-
>
fInputIdx
<
fActiveLimit
)
{
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
c
=
=
opValue
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
break
;
}
}
else
{
fHitEnd
=
true
;
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
case
URX_STRING
:
{
int32_t
stringStartIdx
=
opValue
;
op
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
fp
-
>
fPatIdx
+
+
;
opType
=
URX_TYPE
(
op
)
;
int32_t
stringLen
=
URX_VAL
(
op
)
;
U_ASSERT
(
opType
=
=
URX_STRING_LEN
)
;
U_ASSERT
(
stringLen
>
=
2
)
;
const
char16_t
*
patternString
=
litText
+
stringStartIdx
;
int32_t
patternStringIndex
=
0
;
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
inputChar
;
UChar32
patternChar
;
UBool
success
=
true
;
while
(
patternStringIndex
<
stringLen
)
{
if
(
UTEXT_GETNATIVEINDEX
(
fInputText
)
>
=
fActiveLimit
)
{
success
=
false
;
fHitEnd
=
true
;
break
;
}
inputChar
=
UTEXT_NEXT32
(
fInputText
)
;
U16_NEXT
(
patternString
patternStringIndex
stringLen
patternChar
)
;
if
(
patternChar
!
=
inputChar
)
{
success
=
false
;
break
;
}
}
if
(
success
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_STATE_SAVE
:
fp
=
StateSave
(
fp
opValue
status
)
;
break
;
case
URX_END
:
if
(
toEnd
&
&
fp
-
>
fInputIdx
!
=
fActiveLimit
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
isMatch
=
true
;
goto
breakFromLoop
;
case
URX_START_CAPTURE
:
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
-
3
)
;
fp
-
>
fExtra
[
opValue
+
2
]
=
fp
-
>
fInputIdx
;
break
;
case
URX_END_CAPTURE
:
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
-
3
)
;
U_ASSERT
(
fp
-
>
fExtra
[
opValue
+
2
]
>
=
0
)
;
fp
-
>
fExtra
[
opValue
]
=
fp
-
>
fExtra
[
opValue
+
2
]
;
fp
-
>
fExtra
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
U_ASSERT
(
fp
-
>
fExtra
[
opValue
]
<
=
fp
-
>
fExtra
[
opValue
+
1
]
)
;
break
;
case
URX_DOLLAR
:
{
if
(
fp
-
>
fInputIdx
>
=
fAnchorLimit
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
UTEXT_GETNATIVEINDEX
(
fInputText
)
>
=
fAnchorLimit
)
{
if
(
isLineTerminator
(
c
)
)
{
if
(
!
(
c
=
=
0x0a
&
&
fp
-
>
fInputIdx
>
fAnchorStart
&
&
(
(
void
)
UTEXT_PREVIOUS32
(
fInputText
)
UTEXT_PREVIOUS32
(
fInputText
)
)
=
=
0x0d
)
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
}
}
else
{
UChar32
nextC
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
c
=
=
0x0d
&
&
nextC
=
=
0x0a
&
&
UTEXT_GETNATIVEINDEX
(
fInputText
)
>
=
fAnchorLimit
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_DOLLAR_D
:
if
(
fp
-
>
fInputIdx
>
=
fAnchorLimit
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
else
{
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
c
=
=
0x0a
&
&
UTEXT_GETNATIVEINDEX
(
fInputText
)
=
=
fAnchorLimit
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
case
URX_DOLLAR_M
:
{
if
(
fp
-
>
fInputIdx
>
=
fAnchorLimit
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_CURRENT32
(
fInputText
)
;
if
(
isLineTerminator
(
c
)
)
{
if
(
!
(
c
=
=
0x0a
&
&
fp
-
>
fInputIdx
>
fAnchorStart
&
&
UTEXT_PREVIOUS32
(
fInputText
)
=
=
0x0d
)
)
{
break
;
}
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_DOLLAR_MD
:
{
if
(
fp
-
>
fInputIdx
>
=
fAnchorLimit
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
if
(
UTEXT_CURRENT32
(
fInputText
)
!
=
0x0a
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_CARET
:
if
(
fp
-
>
fInputIdx
!
=
fAnchorStart
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_CARET_M
:
{
if
(
fp
-
>
fInputIdx
=
=
fAnchorStart
)
{
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_PREVIOUS32
(
fInputText
)
;
if
(
(
fp
-
>
fInputIdx
<
fAnchorLimit
)
&
&
isLineTerminator
(
c
)
)
{
break
;
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_CARET_M_UNIX
:
{
U_ASSERT
(
fp
-
>
fInputIdx
>
=
fAnchorStart
)
;
if
(
fp
-
>
fInputIdx
<
=
fAnchorStart
)
{
break
;
}
U_ASSERT
(
fp
-
>
fInputIdx
<
=
fAnchorLimit
)
;
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_PREVIOUS32
(
fInputText
)
;
if
(
c
!
=
0x0a
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_B
:
{
UBool
success
=
isWordBoundary
(
fp
-
>
fInputIdx
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
!
success
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_BU
:
{
UBool
success
=
isUWordBoundary
(
fp
-
>
fInputIdx
status
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
!
success
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_D
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
int8_t
ctype
=
u_charType
(
c
)
;
UBool
success
=
(
ctype
=
=
U_DECIMAL_DIGIT_NUMBER
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
success
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_G
:
if
(
!
(
(
fMatch
&
&
fp
-
>
fInputIdx
=
=
fMatchEnd
)
|
|
(
fMatch
=
=
false
&
&
fp
-
>
fInputIdx
=
=
fActiveStart
)
)
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_BACKSLASH_H
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
int8_t
ctype
=
u_charType
(
c
)
;
UBool
success
=
(
ctype
=
=
U_SPACE_SEPARATOR
|
|
c
=
=
9
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
success
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_R
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
isLineTerminator
(
c
)
)
{
if
(
c
=
=
0x0d
&
&
utext_current32
(
fInputText
)
=
=
0x0a
)
{
utext_next32
(
fInputText
)
;
}
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_V
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
UBool
success
=
isLineTerminator
(
c
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
success
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_X
:
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
fp
-
>
fInputIdx
=
followingGCBoundary
(
fp
-
>
fInputIdx
status
)
;
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
-
>
fInputIdx
=
fActiveLimit
;
}
break
;
case
URX_BACKSLASH_Z
:
if
(
fp
-
>
fInputIdx
<
fAnchorLimit
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
else
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
}
break
;
case
URX_STATIC_SETREF
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UBool
success
=
(
(
opValue
&
URX_NEG_SET
)
=
=
URX_NEG_SET
)
;
opValue
&
=
~
URX_NEG_SET
;
U_ASSERT
(
opValue
>
0
&
&
opValue
<
URX_LAST_SET
)
;
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
c
<
256
)
{
Regex8BitSet
&
s8
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets8
[
opValue
]
;
if
(
s8
.
contains
(
c
)
)
{
success
=
!
success
;
}
}
else
{
const
UnicodeSet
&
s
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets
[
opValue
]
;
if
(
s
.
contains
(
c
)
)
{
success
=
!
success
;
}
}
if
(
success
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_STAT_SETREF_N
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
U_ASSERT
(
opValue
>
0
&
&
opValue
<
URX_LAST_SET
)
;
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
c
<
256
)
{
Regex8BitSet
&
s8
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets8
[
opValue
]
;
if
(
s8
.
contains
(
c
)
=
=
false
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
break
;
}
}
else
{
const
UnicodeSet
&
s
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets
[
opValue
]
;
if
(
s
.
contains
(
c
)
=
=
false
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
break
;
}
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_SETREF
:
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
else
{
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fSets
-
>
size
(
)
)
;
if
(
c
<
256
)
{
Regex8BitSet
*
s8
=
&
fPattern
-
>
fSets8
[
opValue
]
;
if
(
s8
-
>
contains
(
c
)
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
break
;
}
}
else
{
UnicodeSet
*
s
=
(
UnicodeSet
*
)
fSets
-
>
elementAt
(
opValue
)
;
if
(
s
-
>
contains
(
c
)
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
break
;
}
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_DOTANY
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
isLineTerminator
(
c
)
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
break
;
case
URX_DOTANY_ALL
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
;
c
=
UTEXT_NEXT32
(
fInputText
)
;
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
if
(
c
=
=
0x0d
&
&
fp
-
>
fInputIdx
<
fActiveLimit
)
{
UChar32
nextc
=
UTEXT_CURRENT32
(
fInputText
)
;
if
(
nextc
=
=
0x0a
)
{
(
void
)
UTEXT_NEXT32
(
fInputText
)
;
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
}
}
break
;
case
URX_DOTANY_UNIX
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
c
=
=
0x0a
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
else
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
}
break
;
case
URX_JMP
:
fp
-
>
fPatIdx
=
opValue
;
break
;
case
URX_FAIL
:
isMatch
=
false
;
goto
breakFromLoop
;
case
URX_JMP_SAV
:
U_ASSERT
(
opValue
<
fPattern
-
>
fCompiledPat
-
>
size
(
)
)
;
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
fp
-
>
fPatIdx
=
opValue
;
break
;
case
URX_JMP_SAV_X
:
{
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fPattern
-
>
fCompiledPat
-
>
size
(
)
)
;
int32_t
stoOp
=
(
int32_t
)
pat
[
opValue
-
1
]
;
U_ASSERT
(
URX_TYPE
(
stoOp
)
=
=
URX_STO_INP_LOC
)
;
int32_t
frameLoc
=
URX_VAL
(
stoOp
)
;
U_ASSERT
(
frameLoc
>
=
0
&
&
frameLoc
<
fFrameSize
)
;
int64_t
prevInputIdx
=
fp
-
>
fExtra
[
frameLoc
]
;
U_ASSERT
(
prevInputIdx
<
=
fp
-
>
fInputIdx
)
;
if
(
prevInputIdx
<
fp
-
>
fInputIdx
)
{
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
fp
-
>
fPatIdx
=
opValue
;
fp
-
>
fExtra
[
frameLoc
]
=
fp
-
>
fInputIdx
;
}
}
break
;
case
URX_CTR_INIT
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
-
2
)
;
fp
-
>
fExtra
[
opValue
]
=
0
;
int32_t
instrOperandLoc
=
(
int32_t
)
fp
-
>
fPatIdx
;
fp
-
>
fPatIdx
+
=
3
;
int32_t
loopLoc
=
URX_VAL
(
pat
[
instrOperandLoc
]
)
;
int32_t
minCount
=
(
int32_t
)
pat
[
instrOperandLoc
+
1
]
;
int32_t
maxCount
=
(
int32_t
)
pat
[
instrOperandLoc
+
2
]
;
U_ASSERT
(
minCount
>
=
0
)
;
U_ASSERT
(
maxCount
>
=
minCount
|
|
maxCount
=
=
-
1
)
;
U_ASSERT
(
loopLoc
>
=
fp
-
>
fPatIdx
)
;
if
(
minCount
=
=
0
)
{
fp
=
StateSave
(
fp
loopLoc
+
1
status
)
;
}
if
(
maxCount
=
=
-
1
)
{
fp
-
>
fExtra
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
}
else
if
(
maxCount
=
=
0
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_CTR_LOOP
:
{
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fp
-
>
fPatIdx
-
2
)
;
int32_t
initOp
=
(
int32_t
)
pat
[
opValue
]
;
U_ASSERT
(
URX_TYPE
(
initOp
)
=
=
URX_CTR_INIT
)
;
int64_t
*
pCounter
=
&
fp
-
>
fExtra
[
URX_VAL
(
initOp
)
]
;
int32_t
minCount
=
(
int32_t
)
pat
[
opValue
+
2
]
;
int32_t
maxCount
=
(
int32_t
)
pat
[
opValue
+
3
]
;
(
*
pCounter
)
+
+
;
if
(
(
uint64_t
)
*
pCounter
>
=
(
uint32_t
)
maxCount
&
&
maxCount
!
=
-
1
)
{
U_ASSERT
(
*
pCounter
=
=
maxCount
)
;
break
;
}
if
(
*
pCounter
>
=
minCount
)
{
if
(
maxCount
=
=
-
1
)
{
int64_t
*
pLastInputIdx
=
&
fp
-
>
fExtra
[
URX_VAL
(
initOp
)
+
1
]
;
if
(
fp
-
>
fInputIdx
=
=
*
pLastInputIdx
)
{
break
;
}
else
{
*
pLastInputIdx
=
fp
-
>
fInputIdx
;
}
}
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
}
else
{
fTickCounter
-
-
;
if
(
fTickCounter
<
=
0
)
{
IncrementTime
(
status
)
;
}
}
fp
-
>
fPatIdx
=
opValue
+
4
;
}
break
;
case
URX_CTR_INIT_NG
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
-
2
)
;
fp
-
>
fExtra
[
opValue
]
=
0
;
int32_t
instrOperandLoc
=
(
int32_t
)
fp
-
>
fPatIdx
;
fp
-
>
fPatIdx
+
=
3
;
int32_t
loopLoc
=
URX_VAL
(
pat
[
instrOperandLoc
]
)
;
int32_t
minCount
=
(
int32_t
)
pat
[
instrOperandLoc
+
1
]
;
int32_t
maxCount
=
(
int32_t
)
pat
[
instrOperandLoc
+
2
]
;
U_ASSERT
(
minCount
>
=
0
)
;
U_ASSERT
(
maxCount
>
=
minCount
|
|
maxCount
=
=
-
1
)
;
U_ASSERT
(
loopLoc
>
fp
-
>
fPatIdx
)
;
if
(
maxCount
=
=
-
1
)
{
fp
-
>
fExtra
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
}
if
(
minCount
=
=
0
)
{
if
(
maxCount
!
=
0
)
{
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
}
fp
-
>
fPatIdx
=
loopLoc
+
1
;
}
}
break
;
case
URX_CTR_LOOP_NG
:
{
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fp
-
>
fPatIdx
-
2
)
;
int32_t
initOp
=
(
int32_t
)
pat
[
opValue
]
;
U_ASSERT
(
URX_TYPE
(
initOp
)
=
=
URX_CTR_INIT_NG
)
;
int64_t
*
pCounter
=
&
fp
-
>
fExtra
[
URX_VAL
(
initOp
)
]
;
int32_t
minCount
=
(
int32_t
)
pat
[
opValue
+
2
]
;
int32_t
maxCount
=
(
int32_t
)
pat
[
opValue
+
3
]
;
(
*
pCounter
)
+
+
;
if
(
(
uint64_t
)
*
pCounter
>
=
(
uint32_t
)
maxCount
&
&
maxCount
!
=
-
1
)
{
U_ASSERT
(
*
pCounter
=
=
maxCount
)
;
break
;
}
if
(
*
pCounter
<
minCount
)
{
fp
-
>
fPatIdx
=
opValue
+
4
;
fTickCounter
-
-
;
if
(
fTickCounter
<
=
0
)
{
IncrementTime
(
status
)
;
}
}
else
{
if
(
maxCount
=
=
-
1
)
{
int64_t
*
pLastInputIdx
=
&
fp
-
>
fExtra
[
URX_VAL
(
initOp
)
+
1
]
;
if
(
fp
-
>
fInputIdx
=
=
*
pLastInputIdx
)
{
break
;
}
*
pLastInputIdx
=
fp
-
>
fInputIdx
;
}
fp
=
StateSave
(
fp
opValue
+
4
status
)
;
}
}
break
;
case
URX_STO_SP
:
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fPattern
-
>
fDataSize
)
;
fData
[
opValue
]
=
fStack
-
>
size
(
)
;
break
;
case
URX_LD_SP
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fPattern
-
>
fDataSize
)
;
int32_t
newStackSize
=
(
int32_t
)
fData
[
opValue
]
;
U_ASSERT
(
newStackSize
<
=
fStack
-
>
size
(
)
)
;
int64_t
*
newFP
=
fStack
-
>
getBuffer
(
)
+
newStackSize
-
fFrameSize
;
if
(
newFP
=
=
(
int64_t
*
)
fp
)
{
break
;
}
int32_t
j
;
for
(
j
=
0
;
j
<
fFrameSize
;
j
+
+
)
{
newFP
[
j
]
=
(
(
int64_t
*
)
fp
)
[
j
]
;
}
fp
=
(
REStackFrame
*
)
newFP
;
fStack
-
>
setSize
(
newStackSize
)
;
}
break
;
case
URX_BACKREF
:
{
U_ASSERT
(
opValue
<
fFrameSize
)
;
int64_t
groupStartIdx
=
fp
-
>
fExtra
[
opValue
]
;
int64_t
groupEndIdx
=
fp
-
>
fExtra
[
opValue
+
1
]
;
U_ASSERT
(
groupStartIdx
<
=
groupEndIdx
)
;
if
(
groupStartIdx
<
0
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UTEXT_SETNATIVEINDEX
(
fAltInputText
groupStartIdx
)
;
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UBool
success
=
true
;
for
(
;
;
)
{
if
(
utext_getNativeIndex
(
fAltInputText
)
>
=
groupEndIdx
)
{
success
=
true
;
break
;
}
if
(
utext_getNativeIndex
(
fInputText
)
>
=
fActiveLimit
)
{
success
=
false
;
fHitEnd
=
true
;
break
;
}
UChar32
captureGroupChar
=
utext_next32
(
fAltInputText
)
;
UChar32
inputChar
=
utext_next32
(
fInputText
)
;
if
(
inputChar
!
=
captureGroupChar
)
{
success
=
false
;
break
;
}
}
if
(
success
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKREF_I
:
{
U_ASSERT
(
opValue
<
fFrameSize
)
;
int64_t
groupStartIdx
=
fp
-
>
fExtra
[
opValue
]
;
int64_t
groupEndIdx
=
fp
-
>
fExtra
[
opValue
+
1
]
;
U_ASSERT
(
groupStartIdx
<
=
groupEndIdx
)
;
if
(
groupStartIdx
<
0
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
utext_setNativeIndex
(
fAltInputText
groupStartIdx
)
;
utext_setNativeIndex
(
fInputText
fp
-
>
fInputIdx
)
;
CaseFoldingUTextIterator
captureGroupItr
(
*
fAltInputText
)
;
CaseFoldingUTextIterator
inputItr
(
*
fInputText
)
;
UBool
success
=
true
;
for
(
;
;
)
{
if
(
!
captureGroupItr
.
inExpansion
(
)
&
&
utext_getNativeIndex
(
fAltInputText
)
>
=
groupEndIdx
)
{
success
=
true
;
break
;
}
if
(
!
inputItr
.
inExpansion
(
)
&
&
utext_getNativeIndex
(
fInputText
)
>
=
fActiveLimit
)
{
success
=
false
;
fHitEnd
=
true
;
break
;
}
UChar32
captureGroupChar
=
captureGroupItr
.
next
(
)
;
UChar32
inputChar
=
inputItr
.
next
(
)
;
if
(
inputChar
!
=
captureGroupChar
)
{
success
=
false
;
break
;
}
}
if
(
success
&
&
inputItr
.
inExpansion
(
)
)
{
success
=
false
;
}
if
(
success
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_STO_INP_LOC
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
)
;
fp
-
>
fExtra
[
opValue
]
=
fp
-
>
fInputIdx
;
}
break
;
case
URX_JMPX
:
{
int32_t
instrOperandLoc
=
(
int32_t
)
fp
-
>
fPatIdx
;
fp
-
>
fPatIdx
+
=
1
;
int32_t
dataLoc
=
URX_VAL
(
pat
[
instrOperandLoc
]
)
;
U_ASSERT
(
dataLoc
>
=
0
&
&
dataLoc
<
fFrameSize
)
;
int64_t
savedInputIdx
=
fp
-
>
fExtra
[
dataLoc
]
;
U_ASSERT
(
savedInputIdx
<
=
fp
-
>
fInputIdx
)
;
if
(
savedInputIdx
<
fp
-
>
fInputIdx
)
{
fp
-
>
fPatIdx
=
opValue
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_LA_START
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
3
<
fPattern
-
>
fDataSize
)
;
fData
[
opValue
]
=
fStack
-
>
size
(
)
;
fData
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
fData
[
opValue
+
2
]
=
fActiveStart
;
fData
[
opValue
+
3
]
=
fActiveLimit
;
fActiveStart
=
fLookStart
;
fActiveLimit
=
fLookLimit
;
}
break
;
case
URX_LA_END
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
3
<
fPattern
-
>
fDataSize
)
;
int32_t
stackSize
=
fStack
-
>
size
(
)
;
int32_t
newStackSize
=
(
int32_t
)
fData
[
opValue
]
;
U_ASSERT
(
stackSize
>
=
newStackSize
)
;
if
(
stackSize
>
newStackSize
)
{
int64_t
*
newFP
=
fStack
-
>
getBuffer
(
)
+
newStackSize
-
fFrameSize
;
int32_t
j
;
for
(
j
=
0
;
j
<
fFrameSize
;
j
+
+
)
{
newFP
[
j
]
=
(
(
int64_t
*
)
fp
)
[
j
]
;
}
fp
=
(
REStackFrame
*
)
newFP
;
fStack
-
>
setSize
(
newStackSize
)
;
}
fp
-
>
fInputIdx
=
fData
[
opValue
+
1
]
;
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
}
break
;
case
URX_ONECHAR_I
:
if
(
fp
-
>
fInputIdx
<
fActiveLimit
)
{
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
u_foldCase
(
c
U_FOLD_CASE_DEFAULT
)
=
=
opValue
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
break
;
}
}
else
{
fHitEnd
=
true
;
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
case
URX_STRING_I
:
{
{
const
char16_t
*
patternString
=
litText
+
opValue
;
int32_t
patternStringIdx
=
0
;
op
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
fp
-
>
fPatIdx
+
+
;
opType
=
URX_TYPE
(
op
)
;
opValue
=
URX_VAL
(
op
)
;
U_ASSERT
(
opType
=
=
URX_STRING_LEN
)
;
int32_t
patternStringLen
=
opValue
;
UChar32
cPattern
;
UChar32
cText
;
UBool
success
=
true
;
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
CaseFoldingUTextIterator
inputIterator
(
*
fInputText
)
;
while
(
patternStringIdx
<
patternStringLen
)
{
if
(
!
inputIterator
.
inExpansion
(
)
&
&
UTEXT_GETNATIVEINDEX
(
fInputText
)
>
=
fActiveLimit
)
{
success
=
false
;
fHitEnd
=
true
;
break
;
}
U16_NEXT
(
patternString
patternStringIdx
patternStringLen
cPattern
)
;
cText
=
inputIterator
.
next
(
)
;
if
(
cText
!
=
cPattern
)
{
success
=
false
;
break
;
}
}
if
(
inputIterator
.
inExpansion
(
)
)
{
success
=
false
;
}
if
(
success
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
}
break
;
case
URX_LB_START
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
fData
[
opValue
]
=
fStack
-
>
size
(
)
;
fData
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
fData
[
opValue
+
2
]
=
fActiveStart
;
fData
[
opValue
+
3
]
=
fActiveLimit
;
fActiveStart
=
fRegionStart
;
fActiveLimit
=
fp
-
>
fInputIdx
;
fData
[
opValue
+
4
]
=
-
1
;
}
break
;
case
URX_LB_CONT
:
{
int32_t
minML
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
int32_t
maxML
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
if
(
!
UTEXT_USES_U16
(
fInputText
)
)
{
maxML
*
=
3
;
}
U_ASSERT
(
minML
<
=
maxML
)
;
U_ASSERT
(
minML
>
=
0
)
;
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
int64_t
&
lbStartIdx
=
fData
[
opValue
+
4
]
;
if
(
lbStartIdx
<
0
)
{
lbStartIdx
=
fp
-
>
fInputIdx
-
minML
;
if
(
lbStartIdx
>
0
)
{
UTEXT_SETNATIVEINDEX
(
fInputText
lbStartIdx
)
;
lbStartIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
}
else
{
if
(
lbStartIdx
=
=
0
)
{
(
lbStartIdx
)
-
-
;
}
else
{
UTEXT_SETNATIVEINDEX
(
fInputText
lbStartIdx
)
;
(
void
)
UTEXT_PREVIOUS32
(
fInputText
)
;
lbStartIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
}
if
(
lbStartIdx
<
0
|
|
lbStartIdx
<
fp
-
>
fInputIdx
-
maxML
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
break
;
}
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
-
3
status
)
;
fp
-
>
fInputIdx
=
lbStartIdx
;
}
break
;
case
URX_LB_END
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
if
(
fp
-
>
fInputIdx
!
=
fActiveLimit
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
}
break
;
case
URX_LBN_CONT
:
{
int32_t
minML
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
int32_t
maxML
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
if
(
!
UTEXT_USES_U16
(
fInputText
)
)
{
maxML
*
=
3
;
}
int32_t
continueLoc
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
continueLoc
=
URX_VAL
(
continueLoc
)
;
U_ASSERT
(
minML
<
=
maxML
)
;
U_ASSERT
(
minML
>
=
0
)
;
U_ASSERT
(
continueLoc
>
fp
-
>
fPatIdx
)
;
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
int64_t
&
lbStartIdx
=
fData
[
opValue
+
4
]
;
if
(
lbStartIdx
<
0
)
{
lbStartIdx
=
fp
-
>
fInputIdx
-
minML
;
if
(
lbStartIdx
>
0
)
{
UTEXT_SETNATIVEINDEX
(
fInputText
lbStartIdx
)
;
lbStartIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
}
else
{
if
(
lbStartIdx
=
=
0
)
{
(
lbStartIdx
)
-
-
;
}
else
{
UTEXT_SETNATIVEINDEX
(
fInputText
lbStartIdx
)
;
(
void
)
UTEXT_PREVIOUS32
(
fInputText
)
;
lbStartIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
}
if
(
lbStartIdx
<
0
|
|
lbStartIdx
<
fp
-
>
fInputIdx
-
maxML
)
{
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
fp
-
>
fPatIdx
=
continueLoc
;
break
;
}
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
-
4
status
)
;
fp
-
>
fInputIdx
=
lbStartIdx
;
}
break
;
case
URX_LBN_END
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
if
(
fp
-
>
fInputIdx
!
=
fActiveLimit
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
1
<
fPattern
-
>
fDataSize
)
;
int32_t
newStackSize
=
(
int32_t
)
fData
[
opValue
]
;
U_ASSERT
(
fStack
-
>
size
(
)
>
newStackSize
)
;
fStack
-
>
setSize
(
newStackSize
)
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_LOOP_SR_I
:
{
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fSets
-
>
size
(
)
)
;
Regex8BitSet
*
s8
=
&
fPattern
-
>
fSets8
[
opValue
]
;
UnicodeSet
*
s
=
(
UnicodeSet
*
)
fSets
-
>
elementAt
(
opValue
)
;
int64_t
ix
=
fp
-
>
fInputIdx
;
UTEXT_SETNATIVEINDEX
(
fInputText
ix
)
;
for
(
;
;
)
{
if
(
ix
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
break
;
}
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
c
<
256
)
{
if
(
s8
-
>
contains
(
c
)
=
=
false
)
{
break
;
}
}
else
{
if
(
s
-
>
contains
(
c
)
=
=
false
)
{
break
;
}
}
ix
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
if
(
ix
=
=
fp
-
>
fInputIdx
)
{
fp
-
>
fPatIdx
+
+
;
break
;
}
int32_t
loopcOp
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
U_ASSERT
(
URX_TYPE
(
loopcOp
)
=
=
URX_LOOP_C
)
;
int32_t
stackLoc
=
URX_VAL
(
loopcOp
)
;
U_ASSERT
(
stackLoc
>
=
0
&
&
stackLoc
<
fFrameSize
)
;
fp
-
>
fExtra
[
stackLoc
]
=
fp
-
>
fInputIdx
;
fp
-
>
fInputIdx
=
ix
;
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
fp
-
>
fPatIdx
+
+
;
}
break
;
case
URX_LOOP_DOT_I
:
{
int64_t
ix
;
if
(
(
opValue
&
1
)
=
=
1
)
{
ix
=
fActiveLimit
;
fHitEnd
=
true
;
}
else
{
ix
=
fp
-
>
fInputIdx
;
UTEXT_SETNATIVEINDEX
(
fInputText
ix
)
;
for
(
;
;
)
{
if
(
ix
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
break
;
}
UChar32
c
=
UTEXT_NEXT32
(
fInputText
)
;
if
(
(
c
&
0x7f
)
<
=
0x29
)
{
if
(
(
c
=
=
0x0a
)
|
|
(
(
(
opValue
&
2
)
=
=
0
)
&
&
isLineTerminator
(
c
)
)
)
{
break
;
}
}
ix
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
}
if
(
ix
=
=
fp
-
>
fInputIdx
)
{
fp
-
>
fPatIdx
+
+
;
break
;
}
int32_t
loopcOp
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
U_ASSERT
(
URX_TYPE
(
loopcOp
)
=
=
URX_LOOP_C
)
;
int32_t
stackLoc
=
URX_VAL
(
loopcOp
)
;
U_ASSERT
(
stackLoc
>
=
0
&
&
stackLoc
<
fFrameSize
)
;
fp
-
>
fExtra
[
stackLoc
]
=
fp
-
>
fInputIdx
;
fp
-
>
fInputIdx
=
ix
;
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
fp
-
>
fPatIdx
+
+
;
}
break
;
case
URX_LOOP_C
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
)
;
backSearchIndex
=
fp
-
>
fExtra
[
opValue
]
;
U_ASSERT
(
backSearchIndex
<
=
fp
-
>
fInputIdx
)
;
if
(
backSearchIndex
=
=
fp
-
>
fInputIdx
)
{
break
;
}
U_ASSERT
(
fp
-
>
fInputIdx
>
0
)
;
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
UChar32
prevC
=
UTEXT_PREVIOUS32
(
fInputText
)
;
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
UChar32
twoPrevC
=
UTEXT_PREVIOUS32
(
fInputText
)
;
if
(
prevC
=
=
0x0a
&
&
fp
-
>
fInputIdx
>
backSearchIndex
&
&
twoPrevC
=
=
0x0d
)
{
int32_t
prevOp
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
-
2
]
;
if
(
URX_TYPE
(
prevOp
)
=
=
URX_LOOP_DOT_I
)
{
fp
-
>
fInputIdx
=
UTEXT_GETNATIVEINDEX
(
fInputText
)
;
}
}
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
-
1
status
)
;
}
break
;
default
:
UPRV_UNREACHABLE_ASSERT
;
status
=
U_INTERNAL_PROGRAM_ERROR
;
}
if
(
U_FAILURE
(
status
)
)
{
isMatch
=
false
;
break
;
}
}
breakFromLoop
:
fMatch
=
isMatch
;
if
(
isMatch
)
{
fLastMatchEnd
=
fMatchEnd
;
fMatchStart
=
startIdx
;
fMatchEnd
=
fp
-
>
fInputIdx
;
}
#
ifdef
REGEX_RUN_DEBUG
if
(
fTraceDebug
)
{
if
(
isMatch
)
{
printf
(
"
Match
.
start
=
%
ld
end
=
%
ld
\
n
\
n
"
fMatchStart
fMatchEnd
)
;
}
else
{
printf
(
"
No
match
\
n
\
n
"
)
;
}
}
#
endif
fFrame
=
fp
;
return
;
}
void
RegexMatcher
:
:
MatchChunkAt
(
int32_t
startIdx
UBool
toEnd
UErrorCode
&
status
)
{
UBool
isMatch
=
false
;
int32_t
backSearchIndex
=
INT32_MAX
;
int32_t
op
;
int32_t
opType
;
int32_t
opValue
;
#
ifdef
REGEX_RUN_DEBUG
if
(
fTraceDebug
)
{
printf
(
"
MatchAt
(
startIdx
=
%
d
)
\
n
"
startIdx
)
;
printf
(
"
Original
Pattern
:
\
"
%
s
\
"
\
n
"
CStr
(
StringFromUText
(
fPattern
-
>
fPattern
)
)
(
)
)
;
printf
(
"
Input
String
:
\
"
%
s
\
"
\
n
\
n
"
CStr
(
StringFromUText
(
fInputText
)
)
(
)
)
;
}
#
endif
if
(
U_FAILURE
(
status
)
)
{
return
;
}
int64_t
*
pat
=
fPattern
-
>
fCompiledPat
-
>
getBuffer
(
)
;
const
char16_t
*
litText
=
fPattern
-
>
fLiteralText
.
getBuffer
(
)
;
UVector
*
fSets
=
fPattern
-
>
fSets
;
const
char16_t
*
inputBuf
=
fInputText
-
>
chunkContents
;
fFrameSize
=
fPattern
-
>
fFrameSize
;
REStackFrame
*
fp
=
resetStack
(
)
;
if
(
U_FAILURE
(
fDeferredStatus
)
)
{
status
=
fDeferredStatus
;
return
;
}
fp
-
>
fPatIdx
=
0
;
fp
-
>
fInputIdx
=
startIdx
;
int32_t
i
;
for
(
i
=
0
;
i
<
fPattern
-
>
fDataSize
;
i
+
+
)
{
fData
[
i
]
=
0
;
}
for
(
;
;
)
{
op
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
opType
=
URX_TYPE
(
op
)
;
opValue
=
URX_VAL
(
op
)
;
#
ifdef
REGEX_RUN_DEBUG
if
(
fTraceDebug
)
{
UTEXT_SETNATIVEINDEX
(
fInputText
fp
-
>
fInputIdx
)
;
printf
(
"
inputIdx
=
%
ld
inputChar
=
%
x
sp
=
%
3ld
activeLimit
=
%
ld
"
fp
-
>
fInputIdx
UTEXT_CURRENT32
(
fInputText
)
(
int64_t
*
)
fp
-
fStack
-
>
getBuffer
(
)
fActiveLimit
)
;
fPattern
-
>
dumpOp
(
fp
-
>
fPatIdx
)
;
}
#
endif
fp
-
>
fPatIdx
+
+
;
switch
(
opType
)
{
case
URX_NOP
:
break
;
case
URX_BACKTRACK
:
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
case
URX_ONECHAR
:
if
(
fp
-
>
fInputIdx
<
fActiveLimit
)
{
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
if
(
c
=
=
opValue
)
{
break
;
}
}
else
{
fHitEnd
=
true
;
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
case
URX_STRING
:
{
int32_t
stringStartIdx
=
opValue
;
int32_t
stringLen
;
op
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
fp
-
>
fPatIdx
+
+
;
opType
=
URX_TYPE
(
op
)
;
stringLen
=
URX_VAL
(
op
)
;
U_ASSERT
(
opType
=
=
URX_STRING_LEN
)
;
U_ASSERT
(
stringLen
>
=
2
)
;
const
char16_t
*
pInp
=
inputBuf
+
fp
-
>
fInputIdx
;
const
char16_t
*
pInpLimit
=
inputBuf
+
fActiveLimit
;
const
char16_t
*
pPat
=
litText
+
stringStartIdx
;
const
char16_t
*
pEnd
=
pInp
+
stringLen
;
UBool
success
=
true
;
while
(
pInp
<
pEnd
)
{
if
(
pInp
>
=
pInpLimit
)
{
fHitEnd
=
true
;
success
=
false
;
break
;
}
if
(
*
pInp
+
+
!
=
*
pPat
+
+
)
{
success
=
false
;
break
;
}
}
if
(
success
)
{
fp
-
>
fInputIdx
+
=
stringLen
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_STATE_SAVE
:
fp
=
StateSave
(
fp
opValue
status
)
;
break
;
case
URX_END
:
if
(
toEnd
&
&
fp
-
>
fInputIdx
!
=
fActiveLimit
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
isMatch
=
true
;
goto
breakFromLoop
;
case
URX_START_CAPTURE
:
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
-
3
)
;
fp
-
>
fExtra
[
opValue
+
2
]
=
fp
-
>
fInputIdx
;
break
;
case
URX_END_CAPTURE
:
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
-
3
)
;
U_ASSERT
(
fp
-
>
fExtra
[
opValue
+
2
]
>
=
0
)
;
fp
-
>
fExtra
[
opValue
]
=
fp
-
>
fExtra
[
opValue
+
2
]
;
fp
-
>
fExtra
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
U_ASSERT
(
fp
-
>
fExtra
[
opValue
]
<
=
fp
-
>
fExtra
[
opValue
+
1
]
)
;
break
;
case
URX_DOLLAR
:
if
(
fp
-
>
fInputIdx
<
fAnchorLimit
-
2
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
if
(
fp
-
>
fInputIdx
>
=
fAnchorLimit
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
if
(
fp
-
>
fInputIdx
=
=
fAnchorLimit
-
1
)
{
UChar32
c
;
U16_GET
(
inputBuf
fAnchorStart
fp
-
>
fInputIdx
fAnchorLimit
c
)
;
if
(
isLineTerminator
(
c
)
)
{
if
(
!
(
c
=
=
0x0a
&
&
fp
-
>
fInputIdx
>
fAnchorStart
&
&
inputBuf
[
fp
-
>
fInputIdx
-
1
]
=
=
0x0d
)
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
}
}
else
if
(
fp
-
>
fInputIdx
=
=
fAnchorLimit
-
2
&
&
inputBuf
[
fp
-
>
fInputIdx
]
=
=
0x0d
&
&
inputBuf
[
fp
-
>
fInputIdx
+
1
]
=
=
0x0a
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
case
URX_DOLLAR_D
:
if
(
fp
-
>
fInputIdx
>
=
fAnchorLimit
-
1
)
{
if
(
fp
-
>
fInputIdx
=
=
fAnchorLimit
-
1
)
{
if
(
inputBuf
[
fp
-
>
fInputIdx
]
=
=
0x0a
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
}
else
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
case
URX_DOLLAR_M
:
{
if
(
fp
-
>
fInputIdx
>
=
fAnchorLimit
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
UChar32
c
=
inputBuf
[
fp
-
>
fInputIdx
]
;
if
(
isLineTerminator
(
c
)
)
{
if
(
!
(
c
=
=
0x0a
&
&
fp
-
>
fInputIdx
>
fAnchorStart
&
&
inputBuf
[
fp
-
>
fInputIdx
-
1
]
=
=
0x0d
)
)
{
break
;
}
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_DOLLAR_MD
:
{
if
(
fp
-
>
fInputIdx
>
=
fAnchorLimit
)
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
break
;
}
if
(
inputBuf
[
fp
-
>
fInputIdx
]
!
=
0x0a
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_CARET
:
if
(
fp
-
>
fInputIdx
!
=
fAnchorStart
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_CARET_M
:
{
if
(
fp
-
>
fInputIdx
=
=
fAnchorStart
)
{
break
;
}
char16_t
c
=
inputBuf
[
fp
-
>
fInputIdx
-
1
]
;
if
(
(
fp
-
>
fInputIdx
<
fAnchorLimit
)
&
&
isLineTerminator
(
c
)
)
{
break
;
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_CARET_M_UNIX
:
{
U_ASSERT
(
fp
-
>
fInputIdx
>
=
fAnchorStart
)
;
if
(
fp
-
>
fInputIdx
<
=
fAnchorStart
)
{
break
;
}
U_ASSERT
(
fp
-
>
fInputIdx
<
=
fAnchorLimit
)
;
char16_t
c
=
inputBuf
[
fp
-
>
fInputIdx
-
1
]
;
if
(
c
!
=
0x0a
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_B
:
{
UBool
success
=
isChunkWordBoundary
(
(
int32_t
)
fp
-
>
fInputIdx
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
!
success
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_BU
:
{
UBool
success
=
isUWordBoundary
(
fp
-
>
fInputIdx
status
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
!
success
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_D
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
int8_t
ctype
=
u_charType
(
c
)
;
UBool
success
=
(
ctype
=
=
U_DECIMAL_DIGIT_NUMBER
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
!
success
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_G
:
if
(
!
(
(
fMatch
&
&
fp
-
>
fInputIdx
=
=
fMatchEnd
)
|
|
(
fMatch
=
=
false
&
&
fp
-
>
fInputIdx
=
=
fActiveStart
)
)
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_BACKSLASH_H
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
int8_t
ctype
=
u_charType
(
c
)
;
UBool
success
=
(
ctype
=
=
U_SPACE_SEPARATOR
|
|
c
=
=
9
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
!
success
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_R
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
if
(
isLineTerminator
(
c
)
)
{
if
(
c
=
=
0x0d
&
&
fp
-
>
fInputIdx
<
fActiveLimit
)
{
char16_t
c2
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c2
)
;
if
(
c2
!
=
0x0a
)
{
U16_PREV
(
inputBuf
0
fp
-
>
fInputIdx
c2
)
;
}
}
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_V
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
UBool
success
=
isLineTerminator
(
c
)
;
success
^
=
(
UBool
)
(
opValue
!
=
0
)
;
if
(
!
success
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKSLASH_X
:
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
fp
-
>
fInputIdx
=
followingGCBoundary
(
fp
-
>
fInputIdx
status
)
;
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
-
>
fInputIdx
=
fActiveLimit
;
}
break
;
case
URX_BACKSLASH_Z
:
if
(
fp
-
>
fInputIdx
<
fAnchorLimit
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
else
{
fHitEnd
=
true
;
fRequireEnd
=
true
;
}
break
;
case
URX_STATIC_SETREF
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UBool
success
=
(
(
opValue
&
URX_NEG_SET
)
=
=
URX_NEG_SET
)
;
opValue
&
=
~
URX_NEG_SET
;
U_ASSERT
(
opValue
>
0
&
&
opValue
<
URX_LAST_SET
)
;
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
if
(
c
<
256
)
{
Regex8BitSet
&
s8
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets8
[
opValue
]
;
if
(
s8
.
contains
(
c
)
)
{
success
=
!
success
;
}
}
else
{
const
UnicodeSet
&
s
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets
[
opValue
]
;
if
(
s
.
contains
(
c
)
)
{
success
=
!
success
;
}
}
if
(
!
success
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_STAT_SETREF_N
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
U_ASSERT
(
opValue
>
0
&
&
opValue
<
URX_LAST_SET
)
;
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
if
(
c
<
256
)
{
Regex8BitSet
&
s8
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets8
[
opValue
]
;
if
(
s8
.
contains
(
c
)
=
=
false
)
{
break
;
}
}
else
{
const
UnicodeSet
&
s
=
RegexStaticSets
:
:
gStaticSets
-
>
fPropSets
[
opValue
]
;
if
(
s
.
contains
(
c
)
=
=
false
)
{
break
;
}
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_SETREF
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fSets
-
>
size
(
)
)
;
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
if
(
c
<
256
)
{
Regex8BitSet
*
s8
=
&
fPattern
-
>
fSets8
[
opValue
]
;
if
(
s8
-
>
contains
(
c
)
)
{
break
;
}
}
else
{
UnicodeSet
*
s
=
(
UnicodeSet
*
)
fSets
-
>
elementAt
(
opValue
)
;
if
(
s
-
>
contains
(
c
)
)
{
break
;
}
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_DOTANY
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
if
(
isLineTerminator
(
c
)
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
}
break
;
case
URX_DOTANY_ALL
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
if
(
c
=
=
0x0d
&
&
fp
-
>
fInputIdx
<
fActiveLimit
)
{
if
(
inputBuf
[
fp
-
>
fInputIdx
]
=
=
0x0a
)
{
U16_FWD_1
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
)
;
}
}
}
break
;
case
URX_DOTANY_UNIX
:
{
if
(
fp
-
>
fInputIdx
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
if
(
c
=
=
0x0a
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_JMP
:
fp
-
>
fPatIdx
=
opValue
;
break
;
case
URX_FAIL
:
isMatch
=
false
;
goto
breakFromLoop
;
case
URX_JMP_SAV
:
U_ASSERT
(
opValue
<
fPattern
-
>
fCompiledPat
-
>
size
(
)
)
;
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
fp
-
>
fPatIdx
=
opValue
;
break
;
case
URX_JMP_SAV_X
:
{
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fPattern
-
>
fCompiledPat
-
>
size
(
)
)
;
int32_t
stoOp
=
(
int32_t
)
pat
[
opValue
-
1
]
;
U_ASSERT
(
URX_TYPE
(
stoOp
)
=
=
URX_STO_INP_LOC
)
;
int32_t
frameLoc
=
URX_VAL
(
stoOp
)
;
U_ASSERT
(
frameLoc
>
=
0
&
&
frameLoc
<
fFrameSize
)
;
int32_t
prevInputIdx
=
(
int32_t
)
fp
-
>
fExtra
[
frameLoc
]
;
U_ASSERT
(
prevInputIdx
<
=
fp
-
>
fInputIdx
)
;
if
(
prevInputIdx
<
fp
-
>
fInputIdx
)
{
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
fp
-
>
fPatIdx
=
opValue
;
fp
-
>
fExtra
[
frameLoc
]
=
fp
-
>
fInputIdx
;
}
}
break
;
case
URX_CTR_INIT
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
-
2
)
;
fp
-
>
fExtra
[
opValue
]
=
0
;
int32_t
instrOperandLoc
=
(
int32_t
)
fp
-
>
fPatIdx
;
fp
-
>
fPatIdx
+
=
3
;
int32_t
loopLoc
=
URX_VAL
(
pat
[
instrOperandLoc
]
)
;
int32_t
minCount
=
(
int32_t
)
pat
[
instrOperandLoc
+
1
]
;
int32_t
maxCount
=
(
int32_t
)
pat
[
instrOperandLoc
+
2
]
;
U_ASSERT
(
minCount
>
=
0
)
;
U_ASSERT
(
maxCount
>
=
minCount
|
|
maxCount
=
=
-
1
)
;
U_ASSERT
(
loopLoc
>
=
fp
-
>
fPatIdx
)
;
if
(
minCount
=
=
0
)
{
fp
=
StateSave
(
fp
loopLoc
+
1
status
)
;
}
if
(
maxCount
=
=
-
1
)
{
fp
-
>
fExtra
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
}
else
if
(
maxCount
=
=
0
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_CTR_LOOP
:
{
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fp
-
>
fPatIdx
-
2
)
;
int32_t
initOp
=
(
int32_t
)
pat
[
opValue
]
;
U_ASSERT
(
URX_TYPE
(
initOp
)
=
=
URX_CTR_INIT
)
;
int64_t
*
pCounter
=
&
fp
-
>
fExtra
[
URX_VAL
(
initOp
)
]
;
int32_t
minCount
=
(
int32_t
)
pat
[
opValue
+
2
]
;
int32_t
maxCount
=
(
int32_t
)
pat
[
opValue
+
3
]
;
(
*
pCounter
)
+
+
;
if
(
(
uint64_t
)
*
pCounter
>
=
(
uint32_t
)
maxCount
&
&
maxCount
!
=
-
1
)
{
U_ASSERT
(
*
pCounter
=
=
maxCount
)
;
break
;
}
if
(
*
pCounter
>
=
minCount
)
{
if
(
maxCount
=
=
-
1
)
{
int64_t
*
pLastInputIdx
=
&
fp
-
>
fExtra
[
URX_VAL
(
initOp
)
+
1
]
;
if
(
fp
-
>
fInputIdx
=
=
*
pLastInputIdx
)
{
break
;
}
else
{
*
pLastInputIdx
=
fp
-
>
fInputIdx
;
}
}
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
}
else
{
fTickCounter
-
-
;
if
(
fTickCounter
<
=
0
)
{
IncrementTime
(
status
)
;
}
}
fp
-
>
fPatIdx
=
opValue
+
4
;
}
break
;
case
URX_CTR_INIT_NG
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
-
2
)
;
fp
-
>
fExtra
[
opValue
]
=
0
;
int32_t
instrOperandLoc
=
(
int32_t
)
fp
-
>
fPatIdx
;
fp
-
>
fPatIdx
+
=
3
;
int32_t
loopLoc
=
URX_VAL
(
pat
[
instrOperandLoc
]
)
;
int32_t
minCount
=
(
int32_t
)
pat
[
instrOperandLoc
+
1
]
;
int32_t
maxCount
=
(
int32_t
)
pat
[
instrOperandLoc
+
2
]
;
U_ASSERT
(
minCount
>
=
0
)
;
U_ASSERT
(
maxCount
>
=
minCount
|
|
maxCount
=
=
-
1
)
;
U_ASSERT
(
loopLoc
>
fp
-
>
fPatIdx
)
;
if
(
maxCount
=
=
-
1
)
{
fp
-
>
fExtra
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
}
if
(
minCount
=
=
0
)
{
if
(
maxCount
!
=
0
)
{
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
}
fp
-
>
fPatIdx
=
loopLoc
+
1
;
}
}
break
;
case
URX_CTR_LOOP_NG
:
{
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fp
-
>
fPatIdx
-
2
)
;
int32_t
initOp
=
(
int32_t
)
pat
[
opValue
]
;
U_ASSERT
(
URX_TYPE
(
initOp
)
=
=
URX_CTR_INIT_NG
)
;
int64_t
*
pCounter
=
&
fp
-
>
fExtra
[
URX_VAL
(
initOp
)
]
;
int32_t
minCount
=
(
int32_t
)
pat
[
opValue
+
2
]
;
int32_t
maxCount
=
(
int32_t
)
pat
[
opValue
+
3
]
;
(
*
pCounter
)
+
+
;
if
(
(
uint64_t
)
*
pCounter
>
=
(
uint32_t
)
maxCount
&
&
maxCount
!
=
-
1
)
{
U_ASSERT
(
*
pCounter
=
=
maxCount
)
;
break
;
}
if
(
*
pCounter
<
minCount
)
{
fp
-
>
fPatIdx
=
opValue
+
4
;
fTickCounter
-
-
;
if
(
fTickCounter
<
=
0
)
{
IncrementTime
(
status
)
;
}
}
else
{
if
(
maxCount
=
=
-
1
)
{
int64_t
*
pLastInputIdx
=
&
fp
-
>
fExtra
[
URX_VAL
(
initOp
)
+
1
]
;
if
(
fp
-
>
fInputIdx
=
=
*
pLastInputIdx
)
{
break
;
}
*
pLastInputIdx
=
fp
-
>
fInputIdx
;
}
fp
=
StateSave
(
fp
opValue
+
4
status
)
;
}
}
break
;
case
URX_STO_SP
:
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fPattern
-
>
fDataSize
)
;
fData
[
opValue
]
=
fStack
-
>
size
(
)
;
break
;
case
URX_LD_SP
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fPattern
-
>
fDataSize
)
;
int32_t
newStackSize
=
(
int32_t
)
fData
[
opValue
]
;
U_ASSERT
(
newStackSize
<
=
fStack
-
>
size
(
)
)
;
int64_t
*
newFP
=
fStack
-
>
getBuffer
(
)
+
newStackSize
-
fFrameSize
;
if
(
newFP
=
=
(
int64_t
*
)
fp
)
{
break
;
}
int32_t
j
;
for
(
j
=
0
;
j
<
fFrameSize
;
j
+
+
)
{
newFP
[
j
]
=
(
(
int64_t
*
)
fp
)
[
j
]
;
}
fp
=
(
REStackFrame
*
)
newFP
;
fStack
-
>
setSize
(
newStackSize
)
;
}
break
;
case
URX_BACKREF
:
{
U_ASSERT
(
opValue
<
fFrameSize
)
;
int64_t
groupStartIdx
=
fp
-
>
fExtra
[
opValue
]
;
int64_t
groupEndIdx
=
fp
-
>
fExtra
[
opValue
+
1
]
;
U_ASSERT
(
groupStartIdx
<
=
groupEndIdx
)
;
int64_t
inputIndex
=
fp
-
>
fInputIdx
;
if
(
groupStartIdx
<
0
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
UBool
success
=
true
;
for
(
int64_t
groupIndex
=
groupStartIdx
;
groupIndex
<
groupEndIdx
;
+
+
groupIndex
+
+
inputIndex
)
{
if
(
inputIndex
>
=
fActiveLimit
)
{
success
=
false
;
fHitEnd
=
true
;
break
;
}
if
(
inputBuf
[
groupIndex
]
!
=
inputBuf
[
inputIndex
]
)
{
success
=
false
;
break
;
}
}
if
(
success
&
&
groupStartIdx
<
groupEndIdx
&
&
U16_IS_LEAD
(
inputBuf
[
groupEndIdx
-
1
]
)
&
&
inputIndex
<
fActiveLimit
&
&
U16_IS_TRAIL
(
inputBuf
[
inputIndex
]
)
)
{
success
=
false
;
}
if
(
success
)
{
fp
-
>
fInputIdx
=
inputIndex
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_BACKREF_I
:
{
U_ASSERT
(
opValue
<
fFrameSize
)
;
int64_t
groupStartIdx
=
fp
-
>
fExtra
[
opValue
]
;
int64_t
groupEndIdx
=
fp
-
>
fExtra
[
opValue
+
1
]
;
U_ASSERT
(
groupStartIdx
<
=
groupEndIdx
)
;
if
(
groupStartIdx
<
0
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
CaseFoldingUCharIterator
captureGroupItr
(
inputBuf
groupStartIdx
groupEndIdx
)
;
CaseFoldingUCharIterator
inputItr
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
)
;
UBool
success
=
true
;
for
(
;
;
)
{
UChar32
captureGroupChar
=
captureGroupItr
.
next
(
)
;
if
(
captureGroupChar
=
=
U_SENTINEL
)
{
success
=
true
;
break
;
}
UChar32
inputChar
=
inputItr
.
next
(
)
;
if
(
inputChar
=
=
U_SENTINEL
)
{
success
=
false
;
fHitEnd
=
true
;
break
;
}
if
(
inputChar
!
=
captureGroupChar
)
{
success
=
false
;
break
;
}
}
if
(
success
&
&
inputItr
.
inExpansion
(
)
)
{
success
=
false
;
}
if
(
success
)
{
fp
-
>
fInputIdx
=
inputItr
.
getIndex
(
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_STO_INP_LOC
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
)
;
fp
-
>
fExtra
[
opValue
]
=
fp
-
>
fInputIdx
;
}
break
;
case
URX_JMPX
:
{
int32_t
instrOperandLoc
=
(
int32_t
)
fp
-
>
fPatIdx
;
fp
-
>
fPatIdx
+
=
1
;
int32_t
dataLoc
=
URX_VAL
(
pat
[
instrOperandLoc
]
)
;
U_ASSERT
(
dataLoc
>
=
0
&
&
dataLoc
<
fFrameSize
)
;
int32_t
savedInputIdx
=
(
int32_t
)
fp
-
>
fExtra
[
dataLoc
]
;
U_ASSERT
(
savedInputIdx
<
=
fp
-
>
fInputIdx
)
;
if
(
savedInputIdx
<
fp
-
>
fInputIdx
)
{
fp
-
>
fPatIdx
=
opValue
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_LA_START
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
3
<
fPattern
-
>
fDataSize
)
;
fData
[
opValue
]
=
fStack
-
>
size
(
)
;
fData
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
fData
[
opValue
+
2
]
=
fActiveStart
;
fData
[
opValue
+
3
]
=
fActiveLimit
;
fActiveStart
=
fLookStart
;
fActiveLimit
=
fLookLimit
;
}
break
;
case
URX_LA_END
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
3
<
fPattern
-
>
fDataSize
)
;
int32_t
stackSize
=
fStack
-
>
size
(
)
;
int32_t
newStackSize
=
(
int32_t
)
fData
[
opValue
]
;
U_ASSERT
(
stackSize
>
=
newStackSize
)
;
if
(
stackSize
>
newStackSize
)
{
int64_t
*
newFP
=
fStack
-
>
getBuffer
(
)
+
newStackSize
-
fFrameSize
;
int32_t
j
;
for
(
j
=
0
;
j
<
fFrameSize
;
j
+
+
)
{
newFP
[
j
]
=
(
(
int64_t
*
)
fp
)
[
j
]
;
}
fp
=
(
REStackFrame
*
)
newFP
;
fStack
-
>
setSize
(
newStackSize
)
;
}
fp
-
>
fInputIdx
=
fData
[
opValue
+
1
]
;
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
}
break
;
case
URX_ONECHAR_I
:
if
(
fp
-
>
fInputIdx
<
fActiveLimit
)
{
UChar32
c
;
U16_NEXT
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
c
)
;
if
(
u_foldCase
(
c
U_FOLD_CASE_DEFAULT
)
=
=
opValue
)
{
break
;
}
}
else
{
fHitEnd
=
true
;
}
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
case
URX_STRING_I
:
{
const
char16_t
*
patternString
=
litText
+
opValue
;
op
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
fp
-
>
fPatIdx
+
+
;
opType
=
URX_TYPE
(
op
)
;
opValue
=
URX_VAL
(
op
)
;
U_ASSERT
(
opType
=
=
URX_STRING_LEN
)
;
int32_t
patternStringLen
=
opValue
;
UChar32
cText
;
UChar32
cPattern
;
UBool
success
=
true
;
int32_t
patternStringIdx
=
0
;
CaseFoldingUCharIterator
inputIterator
(
inputBuf
fp
-
>
fInputIdx
fActiveLimit
)
;
while
(
patternStringIdx
<
patternStringLen
)
{
U16_NEXT
(
patternString
patternStringIdx
patternStringLen
cPattern
)
;
cText
=
inputIterator
.
next
(
)
;
if
(
cText
!
=
cPattern
)
{
success
=
false
;
if
(
cText
=
=
U_SENTINEL
)
{
fHitEnd
=
true
;
}
break
;
}
}
if
(
inputIterator
.
inExpansion
(
)
)
{
success
=
false
;
}
if
(
success
)
{
fp
-
>
fInputIdx
=
inputIterator
.
getIndex
(
)
;
}
else
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
}
break
;
case
URX_LB_START
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
fData
[
opValue
]
=
fStack
-
>
size
(
)
;
fData
[
opValue
+
1
]
=
fp
-
>
fInputIdx
;
fData
[
opValue
+
2
]
=
fActiveStart
;
fData
[
opValue
+
3
]
=
fActiveLimit
;
fActiveStart
=
fRegionStart
;
fActiveLimit
=
fp
-
>
fInputIdx
;
fData
[
opValue
+
4
]
=
-
1
;
}
break
;
case
URX_LB_CONT
:
{
int32_t
minML
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
int32_t
maxML
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
U_ASSERT
(
minML
<
=
maxML
)
;
U_ASSERT
(
minML
>
=
0
)
;
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
int64_t
&
lbStartIdx
=
fData
[
opValue
+
4
]
;
if
(
lbStartIdx
<
0
)
{
lbStartIdx
=
fp
-
>
fInputIdx
-
minML
;
if
(
lbStartIdx
>
0
&
&
lbStartIdx
<
fInputLength
)
{
U16_SET_CP_START
(
inputBuf
0
lbStartIdx
)
;
}
}
else
{
if
(
lbStartIdx
=
=
0
)
{
lbStartIdx
-
-
;
}
else
{
U16_BACK_1
(
inputBuf
0
lbStartIdx
)
;
}
}
if
(
lbStartIdx
<
0
|
|
lbStartIdx
<
fp
-
>
fInputIdx
-
maxML
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
break
;
}
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
-
3
status
)
;
fp
-
>
fInputIdx
=
lbStartIdx
;
}
break
;
case
URX_LB_END
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
if
(
fp
-
>
fInputIdx
!
=
fActiveLimit
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
}
break
;
case
URX_LBN_CONT
:
{
int32_t
minML
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
int32_t
maxML
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
int32_t
continueLoc
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
+
+
]
;
continueLoc
=
URX_VAL
(
continueLoc
)
;
U_ASSERT
(
minML
<
=
maxML
)
;
U_ASSERT
(
minML
>
=
0
)
;
U_ASSERT
(
continueLoc
>
fp
-
>
fPatIdx
)
;
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
int64_t
&
lbStartIdx
=
fData
[
opValue
+
4
]
;
if
(
lbStartIdx
<
0
)
{
lbStartIdx
=
fp
-
>
fInputIdx
-
minML
;
if
(
lbStartIdx
>
0
&
&
lbStartIdx
<
fInputLength
)
{
U16_SET_CP_START
(
inputBuf
0
lbStartIdx
)
;
}
}
else
{
if
(
lbStartIdx
=
=
0
)
{
lbStartIdx
-
-
;
}
else
{
U16_BACK_1
(
inputBuf
0
lbStartIdx
)
;
}
}
if
(
lbStartIdx
<
0
|
|
lbStartIdx
<
fp
-
>
fInputIdx
-
maxML
)
{
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
fp
-
>
fPatIdx
=
continueLoc
;
break
;
}
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
-
4
status
)
;
fp
-
>
fInputIdx
=
lbStartIdx
;
}
break
;
case
URX_LBN_END
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
4
<
fPattern
-
>
fDataSize
)
;
if
(
fp
-
>
fInputIdx
!
=
fActiveLimit
)
{
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
break
;
}
fActiveStart
=
fData
[
opValue
+
2
]
;
fActiveLimit
=
fData
[
opValue
+
3
]
;
U_ASSERT
(
fActiveStart
>
=
0
)
;
U_ASSERT
(
fActiveLimit
<
=
fInputLength
)
;
U_ASSERT
(
opValue
>
=
0
&
&
opValue
+
1
<
fPattern
-
>
fDataSize
)
;
int32_t
newStackSize
=
(
int32_t
)
fData
[
opValue
]
;
U_ASSERT
(
fStack
-
>
size
(
)
>
newStackSize
)
;
fStack
-
>
setSize
(
newStackSize
)
;
fp
=
(
REStackFrame
*
)
fStack
-
>
popFrame
(
fFrameSize
)
;
}
break
;
case
URX_LOOP_SR_I
:
{
U_ASSERT
(
opValue
>
0
&
&
opValue
<
fSets
-
>
size
(
)
)
;
Regex8BitSet
*
s8
=
&
fPattern
-
>
fSets8
[
opValue
]
;
UnicodeSet
*
s
=
(
UnicodeSet
*
)
fSets
-
>
elementAt
(
opValue
)
;
int32_t
ix
=
(
int32_t
)
fp
-
>
fInputIdx
;
for
(
;
;
)
{
if
(
ix
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
break
;
}
UChar32
c
;
U16_NEXT
(
inputBuf
ix
fActiveLimit
c
)
;
if
(
c
<
256
)
{
if
(
s8
-
>
contains
(
c
)
=
=
false
)
{
U16_BACK_1
(
inputBuf
0
ix
)
;
break
;
}
}
else
{
if
(
s
-
>
contains
(
c
)
=
=
false
)
{
U16_BACK_1
(
inputBuf
0
ix
)
;
break
;
}
}
}
if
(
ix
=
=
fp
-
>
fInputIdx
)
{
fp
-
>
fPatIdx
+
+
;
break
;
}
int32_t
loopcOp
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
U_ASSERT
(
URX_TYPE
(
loopcOp
)
=
=
URX_LOOP_C
)
;
int32_t
stackLoc
=
URX_VAL
(
loopcOp
)
;
U_ASSERT
(
stackLoc
>
=
0
&
&
stackLoc
<
fFrameSize
)
;
fp
-
>
fExtra
[
stackLoc
]
=
fp
-
>
fInputIdx
;
fp
-
>
fInputIdx
=
ix
;
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
fp
-
>
fPatIdx
+
+
;
}
break
;
case
URX_LOOP_DOT_I
:
{
int32_t
ix
;
if
(
(
opValue
&
1
)
=
=
1
)
{
ix
=
(
int32_t
)
fActiveLimit
;
fHitEnd
=
true
;
}
else
{
ix
=
(
int32_t
)
fp
-
>
fInputIdx
;
for
(
;
;
)
{
if
(
ix
>
=
fActiveLimit
)
{
fHitEnd
=
true
;
break
;
}
UChar32
c
;
U16_NEXT
(
inputBuf
ix
fActiveLimit
c
)
;
if
(
(
c
&
0x7f
)
<
=
0x29
)
{
if
(
(
c
=
=
0x0a
)
|
|
(
(
(
opValue
&
2
)
=
=
0
)
&
&
isLineTerminator
(
c
)
)
)
{
U16_BACK_1
(
inputBuf
0
ix
)
;
break
;
}
}
}
}
if
(
ix
=
=
fp
-
>
fInputIdx
)
{
fp
-
>
fPatIdx
+
+
;
break
;
}
int32_t
loopcOp
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
]
;
U_ASSERT
(
URX_TYPE
(
loopcOp
)
=
=
URX_LOOP_C
)
;
int32_t
stackLoc
=
URX_VAL
(
loopcOp
)
;
U_ASSERT
(
stackLoc
>
=
0
&
&
stackLoc
<
fFrameSize
)
;
fp
-
>
fExtra
[
stackLoc
]
=
fp
-
>
fInputIdx
;
fp
-
>
fInputIdx
=
ix
;
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
status
)
;
fp
-
>
fPatIdx
+
+
;
}
break
;
case
URX_LOOP_C
:
{
U_ASSERT
(
opValue
>
=
0
&
&
opValue
<
fFrameSize
)
;
backSearchIndex
=
(
int32_t
)
fp
-
>
fExtra
[
opValue
]
;
U_ASSERT
(
backSearchIndex
<
=
fp
-
>
fInputIdx
)
;
if
(
backSearchIndex
=
=
fp
-
>
fInputIdx
)
{
break
;
}
U_ASSERT
(
fp
-
>
fInputIdx
>
0
)
;
UChar32
prevC
;
U16_PREV
(
inputBuf
0
fp
-
>
fInputIdx
prevC
)
;
if
(
prevC
=
=
0x0a
&
&
fp
-
>
fInputIdx
>
backSearchIndex
&
&
inputBuf
[
fp
-
>
fInputIdx
-
1
]
=
=
0x0d
)
{
int32_t
prevOp
=
(
int32_t
)
pat
[
fp
-
>
fPatIdx
-
2
]
;
if
(
URX_TYPE
(
prevOp
)
=
=
URX_LOOP_DOT_I
)
{
U16_BACK_1
(
inputBuf
0
fp
-
>
fInputIdx
)
;
}
}
fp
=
StateSave
(
fp
fp
-
>
fPatIdx
-
1
status
)
;
}
break
;
default
:
UPRV_UNREACHABLE_ASSERT
;
status
=
U_INTERNAL_PROGRAM_ERROR
;
}
if
(
U_FAILURE
(
status
)
)
{
isMatch
=
false
;
break
;
}
}
breakFromLoop
:
fMatch
=
isMatch
;
if
(
isMatch
)
{
fLastMatchEnd
=
fMatchEnd
;
fMatchStart
=
startIdx
;
fMatchEnd
=
fp
-
>
fInputIdx
;
}
#
ifdef
REGEX_RUN_DEBUG
if
(
fTraceDebug
)
{
if
(
isMatch
)
{
printf
(
"
Match
.
start
=
%
ld
end
=
%
ld
\
n
\
n
"
fMatchStart
fMatchEnd
)
;
}
else
{
printf
(
"
No
match
\
n
\
n
"
)
;
}
}
#
endif
fFrame
=
fp
;
return
;
}
UOBJECT_DEFINE_RTTI_IMPLEMENTATION
(
RegexMatcher
)
U_NAMESPACE_END
#
endif
