#
include
"
utypeinfo
.
h
"
#
include
"
unicode
/
dtitvfmt
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
calendar
.
h
"
#
include
"
unicode
/
dtptngen
.
h
"
#
include
"
unicode
/
dtitvinf
.
h
"
#
include
"
unicode
/
simpleformatter
.
h
"
#
include
"
unicode
/
udisplaycontext
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
cstring
.
h
"
#
include
"
dtitv_impl
.
h
"
#
include
"
mutex
.
h
"
#
include
"
uresimp
.
h
"
#
include
"
formattedval_impl
.
h
"
#
ifdef
DTITVFMT_DEBUG
#
include
<
iostream
>
#
endif
U_NAMESPACE_BEGIN
#
ifdef
DTITVFMT_DEBUG
#
define
PRINTMESG
(
msg
)
{
std
:
:
cout
<
<
"
(
"
<
<
__FILE__
<
<
"
:
"
<
<
__LINE__
<
<
"
)
"
<
<
msg
<
<
"
\
n
"
;
}
#
endif
static
const
char16_t
gDateFormatSkeleton
[
]
[
11
]
=
{
{
LOW_Y
CAP_M
CAP_M
CAP_M
CAP_M
CAP_E
CAP_E
CAP_E
CAP_E
LOW_D
0
}
{
LOW_Y
CAP_M
CAP_M
CAP_M
CAP_M
LOW_D
0
}
{
LOW_Y
CAP_M
CAP_M
CAP_M
LOW_D
0
}
{
LOW_Y
CAP_M
LOW_D
0
}
}
;
static
const
char
gCalendarTag
[
]
=
"
calendar
"
;
static
const
char
gGregorianTag
[
]
=
"
gregorian
"
;
static
const
char
gDateTimePatternsTag
[
]
=
"
DateTimePatterns
"
;
static
const
char16_t
gLaterFirstPrefix
[
]
=
{
LOW_L
LOW_A
LOW_T
LOW_E
LOW_S
LOW_T
CAP_F
LOW_I
LOW_R
LOW_S
LOW_T
COLON
}
;
static
const
char16_t
gEarlierFirstPrefix
[
]
=
{
LOW_E
LOW_A
LOW_R
LOW_L
LOW_I
LOW_E
LOW_S
LOW_T
CAP_F
LOW_I
LOW_R
LOW_S
LOW_T
COLON
}
;
class
FormattedDateIntervalData
:
public
FormattedValueFieldPositionIteratorImpl
{
public
:
FormattedDateIntervalData
(
UErrorCode
&
status
)
:
FormattedValueFieldPositionIteratorImpl
(
5
status
)
{
}
virtual
~
FormattedDateIntervalData
(
)
;
}
;
FormattedDateIntervalData
:
:
~
FormattedDateIntervalData
(
)
=
default
;
UPRV_FORMATTED_VALUE_SUBCLASS_AUTO_IMPL
(
FormattedDateInterval
)
UOBJECT_DEFINE_RTTI_IMPLEMENTATION
(
DateIntervalFormat
)
static
UMutex
gFormatterMutex
;
DateIntervalFormat
*
U_EXPORT2
DateIntervalFormat
:
:
createInstance
(
const
UnicodeString
&
skeleton
UErrorCode
&
status
)
{
return
createInstance
(
skeleton
Locale
:
:
getDefault
(
)
status
)
;
}
DateIntervalFormat
*
U_EXPORT2
DateIntervalFormat
:
:
createInstance
(
const
UnicodeString
&
skeleton
const
Locale
&
locale
UErrorCode
&
status
)
{
#
ifdef
DTITVFMT_DEBUG
char
result
[
1000
]
;
char
result_1
[
1000
]
;
char
mesg
[
2000
]
;
skeleton
.
extract
(
0
skeleton
.
length
(
)
result
"
UTF
-
8
"
)
;
UnicodeString
pat
;
(
(
SimpleDateFormat
*
)
dtfmt
)
-
>
toPattern
(
pat
)
;
pat
.
extract
(
0
pat
.
length
(
)
result_1
"
UTF
-
8
"
)
;
snprintf
(
mesg
sizeof
(
mesg
)
"
skeleton
:
%
s
;
pattern
:
%
s
\
n
"
result
result_1
)
;
PRINTMESG
(
mesg
)
#
endif
DateIntervalInfo
*
dtitvinf
=
new
DateIntervalInfo
(
locale
status
)
;
if
(
dtitvinf
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
return
create
(
locale
dtitvinf
&
skeleton
status
)
;
}
DateIntervalFormat
*
U_EXPORT2
DateIntervalFormat
:
:
createInstance
(
const
UnicodeString
&
skeleton
const
DateIntervalInfo
&
dtitvinf
UErrorCode
&
status
)
{
return
createInstance
(
skeleton
Locale
:
:
getDefault
(
)
dtitvinf
status
)
;
}
DateIntervalFormat
*
U_EXPORT2
DateIntervalFormat
:
:
createInstance
(
const
UnicodeString
&
skeleton
const
Locale
&
locale
const
DateIntervalInfo
&
dtitvinf
UErrorCode
&
status
)
{
DateIntervalInfo
*
ptn
=
dtitvinf
.
clone
(
)
;
return
create
(
locale
ptn
&
skeleton
status
)
;
}
DateIntervalFormat
:
:
DateIntervalFormat
(
)
:
fInfo
(
nullptr
)
fDateFormat
(
nullptr
)
fFromCalendar
(
nullptr
)
fToCalendar
(
nullptr
)
fLocale
(
Locale
:
:
getRoot
(
)
)
fDatePattern
(
nullptr
)
fTimePattern
(
nullptr
)
fDateTimeFormat
(
nullptr
)
fCapitalizationContext
(
UDISPCTX_CAPITALIZATION_NONE
)
{
}
DateIntervalFormat
:
:
DateIntervalFormat
(
const
DateIntervalFormat
&
itvfmt
)
:
Format
(
itvfmt
)
fInfo
(
nullptr
)
fDateFormat
(
nullptr
)
fFromCalendar
(
nullptr
)
fToCalendar
(
nullptr
)
fLocale
(
itvfmt
.
fLocale
)
fDatePattern
(
nullptr
)
fTimePattern
(
nullptr
)
fDateTimeFormat
(
nullptr
)
fCapitalizationContext
(
UDISPCTX_CAPITALIZATION_NONE
)
{
*
this
=
itvfmt
;
}
DateIntervalFormat
&
DateIntervalFormat
:
:
operator
=
(
const
DateIntervalFormat
&
itvfmt
)
{
if
(
this
!
=
&
itvfmt
)
{
delete
fDateFormat
;
delete
fInfo
;
delete
fFromCalendar
;
delete
fToCalendar
;
delete
fDatePattern
;
delete
fTimePattern
;
delete
fDateTimeFormat
;
{
Mutex
lock
(
&
gFormatterMutex
)
;
if
(
itvfmt
.
fDateFormat
)
{
fDateFormat
=
itvfmt
.
fDateFormat
-
>
clone
(
)
;
}
else
{
fDateFormat
=
nullptr
;
}
if
(
itvfmt
.
fFromCalendar
)
{
fFromCalendar
=
itvfmt
.
fFromCalendar
-
>
clone
(
)
;
}
else
{
fFromCalendar
=
nullptr
;
}
if
(
itvfmt
.
fToCalendar
)
{
fToCalendar
=
itvfmt
.
fToCalendar
-
>
clone
(
)
;
}
else
{
fToCalendar
=
nullptr
;
}
}
if
(
itvfmt
.
fInfo
)
{
fInfo
=
itvfmt
.
fInfo
-
>
clone
(
)
;
}
else
{
fInfo
=
nullptr
;
}
fSkeleton
=
itvfmt
.
fSkeleton
;
int8_t
i
;
for
(
i
=
0
;
i
<
DateIntervalInfo
:
:
kIPI_MAX_INDEX
;
+
+
i
)
{
fIntervalPatterns
[
i
]
=
itvfmt
.
fIntervalPatterns
[
i
]
;
}
fLocale
=
itvfmt
.
fLocale
;
fDatePattern
=
(
itvfmt
.
fDatePattern
)
?
itvfmt
.
fDatePattern
-
>
clone
(
)
:
nullptr
;
fTimePattern
=
(
itvfmt
.
fTimePattern
)
?
itvfmt
.
fTimePattern
-
>
clone
(
)
:
nullptr
;
fDateTimeFormat
=
(
itvfmt
.
fDateTimeFormat
)
?
itvfmt
.
fDateTimeFormat
-
>
clone
(
)
:
nullptr
;
fCapitalizationContext
=
itvfmt
.
fCapitalizationContext
;
}
return
*
this
;
}
DateIntervalFormat
:
:
~
DateIntervalFormat
(
)
{
delete
fInfo
;
delete
fDateFormat
;
delete
fFromCalendar
;
delete
fToCalendar
;
delete
fDatePattern
;
delete
fTimePattern
;
delete
fDateTimeFormat
;
}
DateIntervalFormat
*
DateIntervalFormat
:
:
clone
(
)
const
{
return
new
DateIntervalFormat
(
*
this
)
;
}
bool
DateIntervalFormat
:
:
operator
=
=
(
const
Format
&
other
)
const
{
if
(
typeid
(
*
this
)
!
=
typeid
(
other
)
)
{
return
false
;
}
const
DateIntervalFormat
*
fmt
=
(
DateIntervalFormat
*
)
&
other
;
if
(
this
=
=
fmt
)
{
return
true
;
}
if
(
!
Format
:
:
operator
=
=
(
other
)
)
{
return
false
;
}
if
(
(
fInfo
!
=
fmt
-
>
fInfo
)
&
&
(
fInfo
=
=
nullptr
|
|
fmt
-
>
fInfo
=
=
nullptr
)
)
{
return
false
;
}
if
(
fInfo
&
&
fmt
-
>
fInfo
&
&
(
*
fInfo
!
=
*
fmt
-
>
fInfo
)
)
{
return
false
;
}
{
Mutex
lock
(
&
gFormatterMutex
)
;
if
(
fDateFormat
!
=
fmt
-
>
fDateFormat
&
&
(
fDateFormat
=
=
nullptr
|
|
fmt
-
>
fDateFormat
=
=
nullptr
)
)
{
return
false
;
}
if
(
fDateFormat
&
&
fmt
-
>
fDateFormat
&
&
(
*
fDateFormat
!
=
*
fmt
-
>
fDateFormat
)
)
{
return
false
;
}
}
if
(
fSkeleton
!
=
fmt
-
>
fSkeleton
)
{
return
false
;
}
if
(
fDatePattern
!
=
fmt
-
>
fDatePattern
&
&
(
fDatePattern
=
=
nullptr
|
|
fmt
-
>
fDatePattern
=
=
nullptr
)
)
{
return
false
;
}
if
(
fDatePattern
&
&
fmt
-
>
fDatePattern
&
&
(
*
fDatePattern
!
=
*
fmt
-
>
fDatePattern
)
)
{
return
false
;
}
if
(
fTimePattern
!
=
fmt
-
>
fTimePattern
&
&
(
fTimePattern
=
=
nullptr
|
|
fmt
-
>
fTimePattern
=
=
nullptr
)
)
{
return
false
;
}
if
(
fTimePattern
&
&
fmt
-
>
fTimePattern
&
&
(
*
fTimePattern
!
=
*
fmt
-
>
fTimePattern
)
)
{
return
false
;
}
if
(
fDateTimeFormat
!
=
fmt
-
>
fDateTimeFormat
&
&
(
fDateTimeFormat
=
=
nullptr
|
|
fmt
-
>
fDateTimeFormat
=
=
nullptr
)
)
{
return
false
;
}
if
(
fDateTimeFormat
&
&
fmt
-
>
fDateTimeFormat
&
&
(
*
fDateTimeFormat
!
=
*
fmt
-
>
fDateTimeFormat
)
)
{
return
false
;
}
if
(
fLocale
!
=
fmt
-
>
fLocale
)
{
return
false
;
}
for
(
int32_t
i
=
0
;
i
<
DateIntervalInfo
:
:
kIPI_MAX_INDEX
;
+
+
i
)
{
if
(
fIntervalPatterns
[
i
]
.
firstPart
!
=
fmt
-
>
fIntervalPatterns
[
i
]
.
firstPart
)
{
return
false
;
}
if
(
fIntervalPatterns
[
i
]
.
secondPart
!
=
fmt
-
>
fIntervalPatterns
[
i
]
.
secondPart
)
{
return
false
;
}
if
(
fIntervalPatterns
[
i
]
.
laterDateFirst
!
=
fmt
-
>
fIntervalPatterns
[
i
]
.
laterDateFirst
)
{
return
false
;
}
}
if
(
fCapitalizationContext
!
=
fmt
-
>
fCapitalizationContext
)
{
return
false
;
}
return
true
;
}
UnicodeString
&
DateIntervalFormat
:
:
format
(
const
Formattable
&
obj
UnicodeString
&
appendTo
FieldPosition
&
fieldPosition
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
if
(
obj
.
getType
(
)
=
=
Formattable
:
:
kObject
)
{
const
UObject
*
formatObj
=
obj
.
getObject
(
)
;
const
DateInterval
*
interval
=
dynamic_cast
<
const
DateInterval
*
>
(
formatObj
)
;
if
(
interval
!
=
nullptr
)
{
return
format
(
interval
appendTo
fieldPosition
status
)
;
}
}
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
appendTo
;
}
UnicodeString
&
DateIntervalFormat
:
:
format
(
const
DateInterval
*
dtInterval
UnicodeString
&
appendTo
FieldPosition
&
fieldPosition
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
if
(
fDateFormat
=
=
nullptr
|
|
fInfo
=
=
nullptr
)
{
status
=
U_INVALID_STATE_ERROR
;
return
appendTo
;
}
FieldPositionOnlyHandler
handler
(
fieldPosition
)
;
handler
.
setAcceptFirstOnly
(
true
)
;
int8_t
ignore
;
Mutex
lock
(
&
gFormatterMutex
)
;
return
formatIntervalImpl
(
*
dtInterval
appendTo
ignore
handler
status
)
;
}
FormattedDateInterval
DateIntervalFormat
:
:
formatToValue
(
const
DateInterval
&
dtInterval
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
FormattedDateInterval
(
status
)
;
}
LocalPointer
<
FormattedDateIntervalData
>
result
(
new
FormattedDateIntervalData
(
status
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
FormattedDateInterval
(
status
)
;
}
UnicodeString
string
;
int8_t
firstIndex
;
auto
handler
=
result
-
>
getHandler
(
status
)
;
handler
.
setCategory
(
UFIELD_CATEGORY_DATE
)
;
{
Mutex
lock
(
&
gFormatterMutex
)
;
formatIntervalImpl
(
dtInterval
string
firstIndex
handler
status
)
;
}
handler
.
getError
(
status
)
;
result
-
>
appendString
(
string
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
FormattedDateInterval
(
status
)
;
}
if
(
firstIndex
!
=
-
1
)
{
result
-
>
addOverlapSpans
(
UFIELD_CATEGORY_DATE_INTERVAL_SPAN
firstIndex
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
FormattedDateInterval
(
status
)
;
}
result
-
>
sort
(
)
;
}
return
FormattedDateInterval
(
result
.
orphan
(
)
)
;
}
UnicodeString
&
DateIntervalFormat
:
:
format
(
Calendar
&
fromCalendar
Calendar
&
toCalendar
UnicodeString
&
appendTo
FieldPosition
&
pos
UErrorCode
&
status
)
const
{
FieldPositionOnlyHandler
handler
(
pos
)
;
handler
.
setAcceptFirstOnly
(
true
)
;
int8_t
ignore
;
Mutex
lock
(
&
gFormatterMutex
)
;
return
formatImpl
(
fromCalendar
toCalendar
appendTo
ignore
handler
status
)
;
}
FormattedDateInterval
DateIntervalFormat
:
:
formatToValue
(
Calendar
&
fromCalendar
Calendar
&
toCalendar
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
FormattedDateInterval
(
status
)
;
}
LocalPointer
<
FormattedDateIntervalData
>
result
(
new
FormattedDateIntervalData
(
status
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
FormattedDateInterval
(
status
)
;
}
UnicodeString
string
;
int8_t
firstIndex
;
auto
handler
=
result
-
>
getHandler
(
status
)
;
handler
.
setCategory
(
UFIELD_CATEGORY_DATE
)
;
{
Mutex
lock
(
&
gFormatterMutex
)
;
formatImpl
(
fromCalendar
toCalendar
string
firstIndex
handler
status
)
;
}
handler
.
getError
(
status
)
;
result
-
>
appendString
(
string
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
FormattedDateInterval
(
status
)
;
}
if
(
firstIndex
!
=
-
1
)
{
result
-
>
addOverlapSpans
(
UFIELD_CATEGORY_DATE_INTERVAL_SPAN
firstIndex
status
)
;
result
-
>
sort
(
)
;
}
return
FormattedDateInterval
(
result
.
orphan
(
)
)
;
}
UnicodeString
&
DateIntervalFormat
:
:
formatIntervalImpl
(
const
DateInterval
&
dtInterval
UnicodeString
&
appendTo
int8_t
&
firstIndex
FieldPositionHandler
&
fphandler
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
if
(
fFromCalendar
=
=
nullptr
|
|
fToCalendar
=
=
nullptr
)
{
status
=
U_INVALID_STATE_ERROR
;
return
appendTo
;
}
fFromCalendar
-
>
setTime
(
dtInterval
.
getFromDate
(
)
status
)
;
fToCalendar
-
>
setTime
(
dtInterval
.
getToDate
(
)
status
)
;
return
formatImpl
(
*
fFromCalendar
*
fToCalendar
appendTo
firstIndex
fphandler
status
)
;
}
UnicodeString
&
DateIntervalFormat
:
:
formatImpl
(
Calendar
&
fromCalendar
Calendar
&
toCalendar
UnicodeString
&
appendTo
int8_t
&
firstIndex
FieldPositionHandler
&
fphandler
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
firstIndex
=
-
1
;
if
(
!
fromCalendar
.
isEquivalentTo
(
toCalendar
)
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
appendTo
;
}
UCalendarDateFields
field
=
UCAL_FIELD_COUNT
;
if
(
fromCalendar
.
get
(
UCAL_ERA
status
)
!
=
toCalendar
.
get
(
UCAL_ERA
status
)
)
{
field
=
UCAL_ERA
;
}
else
if
(
fromCalendar
.
get
(
UCAL_YEAR
status
)
!
=
toCalendar
.
get
(
UCAL_YEAR
status
)
)
{
field
=
UCAL_YEAR
;
}
else
if
(
fromCalendar
.
get
(
UCAL_MONTH
status
)
!
=
toCalendar
.
get
(
UCAL_MONTH
status
)
)
{
field
=
UCAL_MONTH
;
}
else
if
(
fromCalendar
.
get
(
UCAL_DATE
status
)
!
=
toCalendar
.
get
(
UCAL_DATE
status
)
)
{
field
=
UCAL_DATE
;
}
else
if
(
fromCalendar
.
get
(
UCAL_AM_PM
status
)
!
=
toCalendar
.
get
(
UCAL_AM_PM
status
)
)
{
field
=
UCAL_AM_PM
;
}
else
if
(
fromCalendar
.
get
(
UCAL_HOUR
status
)
!
=
toCalendar
.
get
(
UCAL_HOUR
status
)
)
{
field
=
UCAL_HOUR
;
}
else
if
(
fromCalendar
.
get
(
UCAL_MINUTE
status
)
!
=
toCalendar
.
get
(
UCAL_MINUTE
status
)
)
{
field
=
UCAL_MINUTE
;
}
else
if
(
fromCalendar
.
get
(
UCAL_SECOND
status
)
!
=
toCalendar
.
get
(
UCAL_SECOND
status
)
)
{
field
=
UCAL_SECOND
;
}
else
if
(
fromCalendar
.
get
(
UCAL_MILLISECOND
status
)
!
=
toCalendar
.
get
(
UCAL_MILLISECOND
status
)
)
{
field
=
UCAL_MILLISECOND
;
}
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
UErrorCode
tempStatus
=
U_ZERO_ERROR
;
fDateFormat
-
>
setContext
(
fCapitalizationContext
tempStatus
)
;
if
(
field
=
=
UCAL_FIELD_COUNT
)
{
return
fDateFormat
-
>
_format
(
fromCalendar
appendTo
fphandler
status
)
;
}
UBool
fromToOnSameDay
=
(
field
=
=
UCAL_AM_PM
|
|
field
=
=
UCAL_HOUR
|
|
field
=
=
UCAL_MINUTE
|
|
field
=
=
UCAL_SECOND
|
|
field
=
=
UCAL_MILLISECOND
)
;
int32_t
itvPtnIndex
=
DateIntervalInfo
:
:
calendarFieldToIntervalIndex
(
field
status
)
;
const
PatternInfo
&
intervalPattern
=
fIntervalPatterns
[
itvPtnIndex
]
;
if
(
intervalPattern
.
firstPart
.
isEmpty
(
)
&
&
intervalPattern
.
secondPart
.
isEmpty
(
)
)
{
if
(
fDateFormat
-
>
isFieldUnitIgnored
(
field
)
)
{
return
fDateFormat
-
>
_format
(
fromCalendar
appendTo
fphandler
status
)
;
}
return
fallbackFormat
(
fromCalendar
toCalendar
fromToOnSameDay
appendTo
firstIndex
fphandler
status
)
;
}
if
(
intervalPattern
.
firstPart
.
isEmpty
(
)
)
{
UnicodeString
originalPattern
;
fDateFormat
-
>
toPattern
(
originalPattern
)
;
fDateFormat
-
>
applyPattern
(
intervalPattern
.
secondPart
)
;
appendTo
=
fallbackFormat
(
fromCalendar
toCalendar
fromToOnSameDay
appendTo
firstIndex
fphandler
status
)
;
fDateFormat
-
>
applyPattern
(
originalPattern
)
;
return
appendTo
;
}
Calendar
*
firstCal
;
Calendar
*
secondCal
;
if
(
intervalPattern
.
laterDateFirst
)
{
firstCal
=
&
toCalendar
;
secondCal
=
&
fromCalendar
;
firstIndex
=
1
;
}
else
{
firstCal
=
&
fromCalendar
;
secondCal
=
&
toCalendar
;
firstIndex
=
0
;
}
UnicodeString
originalPattern
;
fDateFormat
-
>
toPattern
(
originalPattern
)
;
fDateFormat
-
>
applyPattern
(
intervalPattern
.
firstPart
)
;
fDateFormat
-
>
_format
(
*
firstCal
appendTo
fphandler
status
)
;
if
(
!
intervalPattern
.
secondPart
.
isEmpty
(
)
)
{
fDateFormat
-
>
applyPattern
(
intervalPattern
.
secondPart
)
;
tempStatus
=
U_ZERO_ERROR
;
fDateFormat
-
>
setContext
(
UDISPCTX_CAPITALIZATION_NONE
tempStatus
)
;
fDateFormat
-
>
_format
(
*
secondCal
appendTo
fphandler
status
)
;
}
fDateFormat
-
>
applyPattern
(
originalPattern
)
;
return
appendTo
;
}
void
DateIntervalFormat
:
:
parseObject
(
const
UnicodeString
&
Formattable
&
ParsePosition
&
)
const
{
}
const
DateIntervalInfo
*
DateIntervalFormat
:
:
getDateIntervalInfo
(
)
const
{
return
fInfo
;
}
void
DateIntervalFormat
:
:
setDateIntervalInfo
(
const
DateIntervalInfo
&
newItvPattern
UErrorCode
&
status
)
{
delete
fInfo
;
fInfo
=
new
DateIntervalInfo
(
newItvPattern
)
;
if
(
fInfo
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
delete
fDatePattern
;
fDatePattern
=
nullptr
;
delete
fTimePattern
;
fTimePattern
=
nullptr
;
delete
fDateTimeFormat
;
fDateTimeFormat
=
nullptr
;
if
(
fDateFormat
)
{
initializePattern
(
status
)
;
}
}
const
DateFormat
*
DateIntervalFormat
:
:
getDateFormat
(
)
const
{
return
fDateFormat
;
}
void
DateIntervalFormat
:
:
adoptTimeZone
(
TimeZone
*
zone
)
{
if
(
fDateFormat
!
=
nullptr
)
{
fDateFormat
-
>
adoptTimeZone
(
zone
)
;
}
if
(
fFromCalendar
)
{
fFromCalendar
-
>
setTimeZone
(
*
zone
)
;
}
if
(
fToCalendar
)
{
fToCalendar
-
>
setTimeZone
(
*
zone
)
;
}
}
void
DateIntervalFormat
:
:
setTimeZone
(
const
TimeZone
&
zone
)
{
if
(
fDateFormat
!
=
nullptr
)
{
fDateFormat
-
>
setTimeZone
(
zone
)
;
}
if
(
fFromCalendar
)
{
fFromCalendar
-
>
setTimeZone
(
zone
)
;
}
if
(
fToCalendar
)
{
fToCalendar
-
>
setTimeZone
(
zone
)
;
}
}
const
TimeZone
&
DateIntervalFormat
:
:
getTimeZone
(
)
const
{
if
(
fDateFormat
!
=
nullptr
)
{
Mutex
lock
(
&
gFormatterMutex
)
;
return
fDateFormat
-
>
getTimeZone
(
)
;
}
return
*
(
TimeZone
:
:
createDefault
(
)
)
;
}
void
DateIntervalFormat
:
:
setContext
(
UDisplayContext
value
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
return
;
if
(
(
UDisplayContextType
)
(
(
uint32_t
)
value
>
>
8
)
=
=
UDISPCTX_TYPE_CAPITALIZATION
)
{
fCapitalizationContext
=
value
;
}
else
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
}
UDisplayContext
DateIntervalFormat
:
:
getContext
(
UDisplayContextType
type
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
return
(
UDisplayContext
)
0
;
if
(
type
!
=
UDISPCTX_TYPE_CAPITALIZATION
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
(
UDisplayContext
)
0
;
}
return
fCapitalizationContext
;
}
DateIntervalFormat
:
:
DateIntervalFormat
(
const
Locale
&
locale
DateIntervalInfo
*
dtItvInfo
const
UnicodeString
*
skeleton
UErrorCode
&
status
)
:
fInfo
(
nullptr
)
fDateFormat
(
nullptr
)
fFromCalendar
(
nullptr
)
fToCalendar
(
nullptr
)
fLocale
(
locale
)
fDatePattern
(
nullptr
)
fTimePattern
(
nullptr
)
fDateTimeFormat
(
nullptr
)
fCapitalizationContext
(
UDISPCTX_CAPITALIZATION_NONE
)
{
LocalPointer
<
DateIntervalInfo
>
info
(
dtItvInfo
status
)
;
LocalPointer
<
SimpleDateFormat
>
dtfmt
(
static_cast
<
SimpleDateFormat
*
>
(
DateFormat
:
:
createInstanceForSkeleton
(
*
skeleton
locale
status
)
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
if
(
skeleton
)
{
fSkeleton
=
*
skeleton
;
}
fInfo
=
info
.
orphan
(
)
;
fDateFormat
=
dtfmt
.
orphan
(
)
;
if
(
fDateFormat
-
>
getCalendar
(
)
)
{
fFromCalendar
=
fDateFormat
-
>
getCalendar
(
)
-
>
clone
(
)
;
fToCalendar
=
fDateFormat
-
>
getCalendar
(
)
-
>
clone
(
)
;
}
initializePattern
(
status
)
;
}
DateIntervalFormat
*
U_EXPORT2
DateIntervalFormat
:
:
create
(
const
Locale
&
locale
DateIntervalInfo
*
dtitvinf
const
UnicodeString
*
skeleton
UErrorCode
&
status
)
{
DateIntervalFormat
*
f
=
new
DateIntervalFormat
(
locale
dtitvinf
skeleton
status
)
;
if
(
f
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
delete
dtitvinf
;
}
else
if
(
U_FAILURE
(
status
)
)
{
delete
f
;
f
=
0
;
}
return
f
;
}
void
DateIntervalFormat
:
:
initializePattern
(
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
const
Locale
&
locale
=
fDateFormat
-
>
getSmpFmtLocale
(
)
;
if
(
fSkeleton
.
isEmpty
(
)
)
{
UnicodeString
fullPattern
;
fDateFormat
-
>
toPattern
(
fullPattern
)
;
#
ifdef
DTITVFMT_DEBUG
char
result
[
1000
]
;
char
result_1
[
1000
]
;
char
mesg
[
2000
]
;
fSkeleton
.
extract
(
0
fSkeleton
.
length
(
)
result
"
UTF
-
8
"
)
;
snprintf
(
mesg
sizeof
(
mesg
)
"
in
getBestSkeleton
:
fSkeleton
:
%
s
;
\
n
"
result
)
;
PRINTMESG
(
mesg
)
#
endif
fSkeleton
=
DateTimePatternGenerator
:
:
staticGetSkeleton
(
fullPattern
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
}
int8_t
i
;
for
(
i
=
0
;
i
<
DateIntervalInfo
:
:
kIPI_MAX_INDEX
;
+
+
i
)
{
fIntervalPatterns
[
i
]
.
laterDateFirst
=
fInfo
-
>
getDefaultOrder
(
)
;
}
UnicodeString
dateSkeleton
;
UnicodeString
timeSkeleton
;
UnicodeString
normalizedTimeSkeleton
;
UnicodeString
normalizedDateSkeleton
;
UnicodeString
convertedSkeleton
=
normalizeHourMetacharacters
(
fSkeleton
)
;
getDateTimeSkeleton
(
convertedSkeleton
dateSkeleton
normalizedDateSkeleton
timeSkeleton
normalizedTimeSkeleton
)
;
#
ifdef
DTITVFMT_DEBUG
char
result
[
1000
]
;
char
result_1
[
1000
]
;
char
mesg
[
2000
]
;
fSkeleton
.
extract
(
0
fSkeleton
.
length
(
)
result
"
UTF
-
8
"
)
;
snprintf
(
mesg
sizeof
(
mesg
)
"
in
getBestSkeleton
:
fSkeleton
:
%
s
;
\
n
"
result
)
;
PRINTMESG
(
mesg
)
#
endif
if
(
timeSkeleton
.
length
(
)
>
0
&
&
dateSkeleton
.
length
(
)
>
0
)
{
LocalUResourceBundlePointer
dateTimePatternsRes
(
ures_open
(
nullptr
locale
.
getBaseName
(
)
&
status
)
)
;
ures_getByKey
(
dateTimePatternsRes
.
getAlias
(
)
gCalendarTag
dateTimePatternsRes
.
getAlias
(
)
&
status
)
;
ures_getByKeyWithFallback
(
dateTimePatternsRes
.
getAlias
(
)
gGregorianTag
dateTimePatternsRes
.
getAlias
(
)
&
status
)
;
ures_getByKeyWithFallback
(
dateTimePatternsRes
.
getAlias
(
)
gDateTimePatternsTag
dateTimePatternsRes
.
getAlias
(
)
&
status
)
;
int32_t
dateTimeFormatLength
;
const
char16_t
*
dateTimeFormat
=
ures_getStringByIndex
(
dateTimePatternsRes
.
getAlias
(
)
(
int32_t
)
DateFormat
:
:
kDateTime
&
dateTimeFormatLength
&
status
)
;
if
(
U_SUCCESS
(
status
)
&
&
dateTimeFormatLength
>
=
3
)
{
fDateTimeFormat
=
new
UnicodeString
(
dateTimeFormat
dateTimeFormatLength
)
;
if
(
fDateTimeFormat
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
}
}
UBool
found
=
setSeparateDateTimePtn
(
normalizedDateSkeleton
normalizedTimeSkeleton
)
;
if
(
found
=
=
false
)
{
if
(
timeSkeleton
.
length
(
)
!
=
0
)
{
if
(
dateSkeleton
.
length
(
)
=
=
0
)
{
timeSkeleton
.
insert
(
0
gDateFormatSkeleton
[
DateFormat
:
:
kShort
]
-
1
)
;
UnicodeString
pattern
=
DateFormat
:
:
getBestPattern
(
locale
timeSkeleton
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
setPatternInfo
(
UCAL_DATE
nullptr
&
pattern
fInfo
-
>
getDefaultOrder
(
)
)
;
setPatternInfo
(
UCAL_MONTH
nullptr
&
pattern
fInfo
-
>
getDefaultOrder
(
)
)
;
setPatternInfo
(
UCAL_YEAR
nullptr
&
pattern
fInfo
-
>
getDefaultOrder
(
)
)
;
timeSkeleton
.
insert
(
0
CAP_G
)
;
pattern
=
DateFormat
:
:
getBestPattern
(
locale
timeSkeleton
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
setPatternInfo
(
UCAL_ERA
nullptr
&
pattern
fInfo
-
>
getDefaultOrder
(
)
)
;
}
else
{
}
}
else
{
}
return
;
}
if
(
timeSkeleton
.
length
(
)
=
=
0
)
{
}
else
if
(
dateSkeleton
.
length
(
)
=
=
0
)
{
timeSkeleton
.
insert
(
0
gDateFormatSkeleton
[
DateFormat
:
:
kShort
]
-
1
)
;
UnicodeString
pattern
=
DateFormat
:
:
getBestPattern
(
locale
timeSkeleton
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
setPatternInfo
(
UCAL_DATE
nullptr
&
pattern
fInfo
-
>
getDefaultOrder
(
)
)
;
setPatternInfo
(
UCAL_MONTH
nullptr
&
pattern
fInfo
-
>
getDefaultOrder
(
)
)
;
setPatternInfo
(
UCAL_YEAR
nullptr
&
pattern
fInfo
-
>
getDefaultOrder
(
)
)
;
timeSkeleton
.
insert
(
0
CAP_G
)
;
pattern
=
DateFormat
:
:
getBestPattern
(
locale
timeSkeleton
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
setPatternInfo
(
UCAL_ERA
nullptr
&
pattern
fInfo
-
>
getDefaultOrder
(
)
)
;
}
else
{
UnicodeString
skeleton
=
fSkeleton
;
if
(
!
fieldExistsInSkeleton
(
UCAL_DATE
dateSkeleton
)
)
{
skeleton
.
insert
(
0
LOW_D
)
;
setFallbackPattern
(
UCAL_DATE
skeleton
status
)
;
}
if
(
!
fieldExistsInSkeleton
(
UCAL_MONTH
dateSkeleton
)
)
{
skeleton
.
insert
(
0
CAP_M
)
;
setFallbackPattern
(
UCAL_MONTH
skeleton
status
)
;
}
if
(
!
fieldExistsInSkeleton
(
UCAL_YEAR
dateSkeleton
)
)
{
skeleton
.
insert
(
0
LOW_Y
)
;
setFallbackPattern
(
UCAL_YEAR
skeleton
status
)
;
}
if
(
!
fieldExistsInSkeleton
(
UCAL_ERA
dateSkeleton
)
)
{
skeleton
.
insert
(
0
CAP_G
)
;
setFallbackPattern
(
UCAL_ERA
skeleton
status
)
;
}
if
(
fDateTimeFormat
=
=
nullptr
)
{
return
;
}
UnicodeString
datePattern
=
DateFormat
:
:
getBestPattern
(
locale
dateSkeleton
status
)
;
concatSingleDate2TimeInterval
(
*
fDateTimeFormat
datePattern
UCAL_AM_PM
status
)
;
concatSingleDate2TimeInterval
(
*
fDateTimeFormat
datePattern
UCAL_HOUR
status
)
;
concatSingleDate2TimeInterval
(
*
fDateTimeFormat
datePattern
UCAL_MINUTE
status
)
;
}
}
UnicodeString
DateIntervalFormat
:
:
normalizeHourMetacharacters
(
const
UnicodeString
&
skeleton
)
const
{
UnicodeString
result
=
skeleton
;
char16_t
hourMetachar
=
u
'
\
0
'
;
char16_t
dayPeriodChar
=
u
'
\
0
'
;
int32_t
hourFieldStart
=
0
;
int32_t
hourFieldLength
=
0
;
int32_t
dayPeriodStart
=
0
;
int32_t
dayPeriodLength
=
0
;
for
(
int32_t
i
=
0
;
i
<
result
.
length
(
)
;
i
+
+
)
{
char16_t
c
=
result
[
i
]
;
if
(
c
=
=
LOW_J
|
|
c
=
=
CAP_J
|
|
c
=
=
CAP_C
|
|
c
=
=
LOW_H
|
|
c
=
=
CAP_H
|
|
c
=
=
LOW_K
|
|
c
=
=
CAP_K
)
{
if
(
hourMetachar
=
=
u
'
\
0
'
)
{
hourMetachar
=
c
;
hourFieldStart
=
i
;
}
+
+
hourFieldLength
;
}
else
if
(
c
=
=
LOW_A
|
|
c
=
=
LOW_B
|
|
c
=
=
CAP_B
)
{
if
(
dayPeriodChar
=
=
u
'
\
0
'
)
{
dayPeriodChar
=
c
;
dayPeriodStart
=
i
;
}
+
+
dayPeriodLength
;
}
else
{
if
(
hourMetachar
!
=
u
'
\
0
'
&
&
dayPeriodChar
!
=
u
'
\
0
'
)
{
break
;
}
}
}
if
(
hourMetachar
!
=
u
'
\
0
'
)
{
UErrorCode
err
=
U_ZERO_ERROR
;
char16_t
hourChar
=
CAP_H
;
UnicodeString
convertedPattern
=
DateFormat
:
:
getBestPattern
(
fLocale
UnicodeString
(
hourMetachar
)
err
)
;
if
(
U_SUCCESS
(
err
)
)
{
int32_t
firstQuotePos
;
while
(
(
firstQuotePos
=
convertedPattern
.
indexOf
(
u
'
\
'
'
)
)
!
=
-
1
)
{
int32_t
secondQuotePos
=
convertedPattern
.
indexOf
(
u
'
\
'
'
firstQuotePos
+
1
)
;
if
(
secondQuotePos
=
=
-
1
)
{
secondQuotePos
=
firstQuotePos
;
}
convertedPattern
.
replace
(
firstQuotePos
(
secondQuotePos
-
firstQuotePos
)
+
1
UnicodeString
(
)
)
;
}
if
(
convertedPattern
.
indexOf
(
LOW_H
)
!
=
-
1
)
{
hourChar
=
LOW_H
;
}
else
if
(
convertedPattern
.
indexOf
(
CAP_K
)
!
=
-
1
)
{
hourChar
=
CAP_K
;
}
else
if
(
convertedPattern
.
indexOf
(
LOW_K
)
!
=
-
1
)
{
hourChar
=
LOW_K
;
}
if
(
convertedPattern
.
indexOf
(
LOW_B
)
!
=
-
1
)
{
dayPeriodChar
=
LOW_B
;
}
else
if
(
convertedPattern
.
indexOf
(
CAP_B
)
!
=
-
1
)
{
dayPeriodChar
=
CAP_B
;
}
else
if
(
dayPeriodChar
=
=
u
'
\
0
'
)
{
dayPeriodChar
=
LOW_A
;
}
}
UnicodeString
hourAndDayPeriod
(
hourChar
)
;
if
(
hourChar
!
=
CAP_H
&
&
hourChar
!
=
LOW_K
)
{
int32_t
newDayPeriodLength
=
0
;
if
(
dayPeriodLength
>
=
5
|
|
hourFieldLength
>
=
5
)
{
newDayPeriodLength
=
5
;
}
else
if
(
dayPeriodLength
>
=
3
|
|
hourFieldLength
>
=
3
)
{
newDayPeriodLength
=
3
;
}
else
{
newDayPeriodLength
=
1
;
}
for
(
int32_t
i
=
0
;
i
<
newDayPeriodLength
;
i
+
+
)
{
hourAndDayPeriod
.
append
(
dayPeriodChar
)
;
}
}
result
.
replace
(
hourFieldStart
hourFieldLength
hourAndDayPeriod
)
;
if
(
dayPeriodStart
>
hourFieldStart
)
{
dayPeriodStart
+
=
hourAndDayPeriod
.
length
(
)
-
hourFieldLength
;
}
result
.
remove
(
dayPeriodStart
dayPeriodLength
)
;
}
return
result
;
}
void
U_EXPORT2
DateIntervalFormat
:
:
getDateTimeSkeleton
(
const
UnicodeString
&
skeleton
UnicodeString
&
dateSkeleton
UnicodeString
&
normalizedDateSkeleton
UnicodeString
&
timeSkeleton
UnicodeString
&
normalizedTimeSkeleton
)
{
int32_t
ECount
=
0
;
int32_t
dCount
=
0
;
int32_t
MCount
=
0
;
int32_t
yCount
=
0
;
int32_t
mCount
=
0
;
int32_t
vCount
=
0
;
int32_t
zCount
=
0
;
char16_t
hourChar
=
u
'
\
0
'
;
int32_t
i
;
for
(
i
=
0
;
i
<
skeleton
.
length
(
)
;
+
+
i
)
{
char16_t
ch
=
skeleton
[
i
]
;
switch
(
ch
)
{
case
CAP_E
:
dateSkeleton
.
append
(
ch
)
;
+
+
ECount
;
break
;
case
LOW_D
:
dateSkeleton
.
append
(
ch
)
;
+
+
dCount
;
break
;
case
CAP_M
:
dateSkeleton
.
append
(
ch
)
;
+
+
MCount
;
break
;
case
LOW_Y
:
dateSkeleton
.
append
(
ch
)
;
+
+
yCount
;
break
;
case
CAP_G
:
case
CAP_Y
:
case
LOW_U
:
case
CAP_Q
:
case
LOW_Q
:
case
CAP_L
:
case
LOW_L
:
case
CAP_W
:
case
LOW_W
:
case
CAP_D
:
case
CAP_F
:
case
LOW_G
:
case
LOW_E
:
case
LOW_C
:
case
CAP_U
:
case
LOW_R
:
normalizedDateSkeleton
.
append
(
ch
)
;
dateSkeleton
.
append
(
ch
)
;
break
;
case
LOW_H
:
case
CAP_H
:
case
LOW_K
:
case
CAP_K
:
timeSkeleton
.
append
(
ch
)
;
if
(
hourChar
=
=
u
'
\
0
'
)
{
hourChar
=
ch
;
}
break
;
case
LOW_M
:
timeSkeleton
.
append
(
ch
)
;
+
+
mCount
;
break
;
case
LOW_Z
:
+
+
zCount
;
timeSkeleton
.
append
(
ch
)
;
break
;
case
LOW_V
:
+
+
vCount
;
timeSkeleton
.
append
(
ch
)
;
break
;
case
LOW_A
:
case
CAP_V
:
case
CAP_Z
:
case
LOW_J
:
case
LOW_S
:
case
CAP_S
:
case
CAP_A
:
case
LOW_B
:
case
CAP_B
:
timeSkeleton
.
append
(
ch
)
;
normalizedTimeSkeleton
.
append
(
ch
)
;
break
;
}
}
if
(
yCount
!
=
0
)
{
for
(
i
=
0
;
i
<
yCount
;
+
+
i
)
{
normalizedDateSkeleton
.
append
(
LOW_Y
)
;
}
}
if
(
MCount
!
=
0
)
{
if
(
MCount
<
3
)
{
normalizedDateSkeleton
.
append
(
CAP_M
)
;
}
else
{
for
(
int32_t
j
=
0
;
j
<
MCount
&
&
j
<
MAX_M_COUNT
;
+
+
j
)
{
normalizedDateSkeleton
.
append
(
CAP_M
)
;
}
}
}
if
(
ECount
!
=
0
)
{
if
(
ECount
<
=
3
)
{
normalizedDateSkeleton
.
append
(
CAP_E
)
;
}
else
{
for
(
int32_t
j
=
0
;
j
<
ECount
&
&
j
<
MAX_E_COUNT
;
+
+
j
)
{
normalizedDateSkeleton
.
append
(
CAP_E
)
;
}
}
}
if
(
dCount
!
=
0
)
{
normalizedDateSkeleton
.
append
(
LOW_D
)
;
}
if
(
hourChar
!
=
u
'
\
0
'
)
{
normalizedTimeSkeleton
.
append
(
hourChar
)
;
}
if
(
mCount
!
=
0
)
{
normalizedTimeSkeleton
.
append
(
LOW_M
)
;
}
if
(
zCount
!
=
0
)
{
normalizedTimeSkeleton
.
append
(
LOW_Z
)
;
}
if
(
vCount
!
=
0
)
{
normalizedTimeSkeleton
.
append
(
LOW_V
)
;
}
}
UBool
DateIntervalFormat
:
:
setSeparateDateTimePtn
(
const
UnicodeString
&
dateSkeleton
const
UnicodeString
&
timeSkeleton
)
{
const
UnicodeString
*
skeleton
;
if
(
timeSkeleton
.
length
(
)
!
=
0
)
{
skeleton
=
&
timeSkeleton
;
}
else
{
skeleton
=
&
dateSkeleton
;
}
int8_t
differenceInfo
=
0
;
const
UnicodeString
*
bestSkeleton
=
fInfo
-
>
getBestSkeleton
(
*
skeleton
differenceInfo
)
;
if
(
bestSkeleton
=
=
nullptr
)
{
return
false
;
}
UErrorCode
status
;
if
(
dateSkeleton
.
length
(
)
!
=
0
)
{
status
=
U_ZERO_ERROR
;
fDatePattern
=
new
UnicodeString
(
DateFormat
:
:
getBestPattern
(
fLocale
dateSkeleton
status
)
)
;
}
if
(
timeSkeleton
.
length
(
)
!
=
0
)
{
status
=
U_ZERO_ERROR
;
fTimePattern
=
new
UnicodeString
(
DateFormat
:
:
getBestPattern
(
fLocale
timeSkeleton
status
)
)
;
}
if
(
differenceInfo
=
=
-
1
)
{
return
false
;
}
if
(
timeSkeleton
.
length
(
)
=
=
0
)
{
UnicodeString
extendedSkeleton
;
UnicodeString
extendedBestSkeleton
;
setIntervalPattern
(
UCAL_DATE
skeleton
bestSkeleton
differenceInfo
&
extendedSkeleton
&
extendedBestSkeleton
)
;
UBool
extended
=
setIntervalPattern
(
UCAL_MONTH
skeleton
bestSkeleton
differenceInfo
&
extendedSkeleton
&
extendedBestSkeleton
)
;
if
(
extended
)
{
bestSkeleton
=
&
extendedBestSkeleton
;
skeleton
=
&
extendedSkeleton
;
}
setIntervalPattern
(
UCAL_YEAR
skeleton
bestSkeleton
differenceInfo
&
extendedSkeleton
&
extendedBestSkeleton
)
;
setIntervalPattern
(
UCAL_ERA
skeleton
bestSkeleton
differenceInfo
&
extendedSkeleton
&
extendedBestSkeleton
)
;
}
else
{
setIntervalPattern
(
UCAL_MINUTE
skeleton
bestSkeleton
differenceInfo
)
;
setIntervalPattern
(
UCAL_HOUR
skeleton
bestSkeleton
differenceInfo
)
;
setIntervalPattern
(
UCAL_AM_PM
skeleton
bestSkeleton
differenceInfo
)
;
}
return
true
;
}
void
DateIntervalFormat
:
:
setFallbackPattern
(
UCalendarDateFields
field
const
UnicodeString
&
skeleton
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
UnicodeString
pattern
=
DateFormat
:
:
getBestPattern
(
fLocale
skeleton
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
setPatternInfo
(
field
nullptr
&
pattern
fInfo
-
>
getDefaultOrder
(
)
)
;
}
void
DateIntervalFormat
:
:
setPatternInfo
(
UCalendarDateFields
field
const
UnicodeString
*
firstPart
const
UnicodeString
*
secondPart
UBool
laterDateFirst
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
itvPtnIndex
=
DateIntervalInfo
:
:
calendarFieldToIntervalIndex
(
field
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
PatternInfo
&
ptn
=
fIntervalPatterns
[
itvPtnIndex
]
;
if
(
firstPart
)
{
ptn
.
firstPart
=
*
firstPart
;
}
if
(
secondPart
)
{
ptn
.
secondPart
=
*
secondPart
;
}
ptn
.
laterDateFirst
=
laterDateFirst
;
}
void
DateIntervalFormat
:
:
setIntervalPattern
(
UCalendarDateFields
field
const
UnicodeString
&
intervalPattern
)
{
UBool
order
=
fInfo
-
>
getDefaultOrder
(
)
;
setIntervalPattern
(
field
intervalPattern
order
)
;
}
void
DateIntervalFormat
:
:
setIntervalPattern
(
UCalendarDateFields
field
const
UnicodeString
&
intervalPattern
UBool
laterDateFirst
)
{
const
UnicodeString
*
pattern
=
&
intervalPattern
;
UBool
order
=
laterDateFirst
;
int8_t
prefixLength
=
UPRV_LENGTHOF
(
gLaterFirstPrefix
)
;
int8_t
earliestFirstLength
=
UPRV_LENGTHOF
(
gEarlierFirstPrefix
)
;
UnicodeString
realPattern
;
if
(
intervalPattern
.
startsWith
(
gLaterFirstPrefix
prefixLength
)
)
{
order
=
true
;
intervalPattern
.
extract
(
prefixLength
intervalPattern
.
length
(
)
-
prefixLength
realPattern
)
;
pattern
=
&
realPattern
;
}
else
if
(
intervalPattern
.
startsWith
(
gEarlierFirstPrefix
earliestFirstLength
)
)
{
order
=
false
;
intervalPattern
.
extract
(
earliestFirstLength
intervalPattern
.
length
(
)
-
earliestFirstLength
realPattern
)
;
pattern
=
&
realPattern
;
}
int32_t
splitPoint
=
splitPatternInto2Part
(
*
pattern
)
;
UnicodeString
firstPart
;
UnicodeString
secondPart
;
pattern
-
>
extract
(
0
splitPoint
firstPart
)
;
if
(
splitPoint
<
pattern
-
>
length
(
)
)
{
pattern
-
>
extract
(
splitPoint
pattern
-
>
length
(
)
-
splitPoint
secondPart
)
;
}
setPatternInfo
(
field
&
firstPart
&
secondPart
order
)
;
}
UBool
DateIntervalFormat
:
:
setIntervalPattern
(
UCalendarDateFields
field
const
UnicodeString
*
skeleton
const
UnicodeString
*
bestSkeleton
int8_t
differenceInfo
UnicodeString
*
extendedSkeleton
UnicodeString
*
extendedBestSkeleton
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UnicodeString
pattern
;
fInfo
-
>
getIntervalPattern
(
*
bestSkeleton
field
pattern
status
)
;
if
(
pattern
.
isEmpty
(
)
)
{
if
(
SimpleDateFormat
:
:
isFieldUnitIgnored
(
*
bestSkeleton
field
)
)
{
return
false
;
}
if
(
field
=
=
UCAL_AM_PM
)
{
fInfo
-
>
getIntervalPattern
(
*
bestSkeleton
UCAL_HOUR
pattern
status
)
;
if
(
!
pattern
.
isEmpty
(
)
)
{
UBool
suppressDayPeriodField
=
fSkeleton
.
indexOf
(
CAP_J
)
!
=
-
1
;
UnicodeString
adjustIntervalPattern
;
adjustFieldWidth
(
*
skeleton
*
bestSkeleton
pattern
differenceInfo
suppressDayPeriodField
adjustIntervalPattern
)
;
setIntervalPattern
(
field
adjustIntervalPattern
)
;
}
return
false
;
}
char16_t
fieldLetter
=
fgCalendarFieldToPatternLetter
[
field
]
;
if
(
extendedSkeleton
)
{
*
extendedSkeleton
=
*
skeleton
;
*
extendedBestSkeleton
=
*
bestSkeleton
;
extendedSkeleton
-
>
insert
(
0
fieldLetter
)
;
extendedBestSkeleton
-
>
insert
(
0
fieldLetter
)
;
fInfo
-
>
getIntervalPattern
(
*
extendedBestSkeleton
field
pattern
status
)
;
if
(
pattern
.
isEmpty
(
)
&
&
differenceInfo
=
=
0
)
{
const
UnicodeString
*
tmpBest
=
fInfo
-
>
getBestSkeleton
(
*
extendedBestSkeleton
differenceInfo
)
;
if
(
tmpBest
!
=
0
&
&
differenceInfo
!
=
-
1
)
{
fInfo
-
>
getIntervalPattern
(
*
tmpBest
field
pattern
status
)
;
bestSkeleton
=
tmpBest
;
}
}
}
}
if
(
!
pattern
.
isEmpty
(
)
)
{
UBool
suppressDayPeriodField
=
fSkeleton
.
indexOf
(
CAP_J
)
!
=
-
1
;
if
(
differenceInfo
!
=
0
|
|
suppressDayPeriodField
)
{
UnicodeString
adjustIntervalPattern
;
adjustFieldWidth
(
*
skeleton
*
bestSkeleton
pattern
differenceInfo
suppressDayPeriodField
adjustIntervalPattern
)
;
setIntervalPattern
(
field
adjustIntervalPattern
)
;
}
else
{
setIntervalPattern
(
field
pattern
)
;
}
if
(
extendedSkeleton
&
&
!
extendedSkeleton
-
>
isEmpty
(
)
)
{
return
true
;
}
}
return
false
;
}
int32_t
U_EXPORT2
DateIntervalFormat
:
:
splitPatternInto2Part
(
const
UnicodeString
&
intervalPattern
)
{
UBool
inQuote
=
false
;
char16_t
prevCh
=
0
;
int32_t
count
=
0
;
UBool
patternRepeated
[
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
int8_t
PATTERN_CHAR_BASE
=
0x41
;
int32_t
i
;
UBool
foundRepetition
=
false
;
for
(
i
=
0
;
i
<
intervalPattern
.
length
(
)
;
+
+
i
)
{
char16_t
ch
=
intervalPattern
.
charAt
(
i
)
;
if
(
ch
!
=
prevCh
&
&
count
>
0
)
{
UBool
repeated
=
patternRepeated
[
(
int
)
(
prevCh
-
PATTERN_CHAR_BASE
)
]
;
if
(
repeated
=
=
false
)
{
patternRepeated
[
prevCh
-
PATTERN_CHAR_BASE
]
=
true
;
}
else
{
foundRepetition
=
true
;
break
;
}
count
=
0
;
}
if
(
ch
=
=
0x0027
)
{
if
(
(
i
+
1
)
<
intervalPattern
.
length
(
)
&
&
intervalPattern
.
charAt
(
i
+
1
)
=
=
0x0027
)
{
+
+
i
;
}
else
{
inQuote
=
!
inQuote
;
}
}
else
if
(
!
inQuote
&
&
(
(
ch
>
=
0x0061
&
&
ch
<
=
0x007A
)
|
|
(
ch
>
=
0x0041
&
&
ch
<
=
0x005A
)
)
)
{
prevCh
=
ch
;
+
+
count
;
}
}
if
(
count
>
0
&
&
foundRepetition
=
=
false
)
{
if
(
patternRepeated
[
(
int
)
(
prevCh
-
PATTERN_CHAR_BASE
)
]
=
=
false
)
{
count
=
0
;
}
}
return
(
i
-
count
)
;
}
void
DateIntervalFormat
:
:
fallbackFormatRange
(
Calendar
&
fromCalendar
Calendar
&
toCalendar
UnicodeString
&
appendTo
int8_t
&
firstIndex
FieldPositionHandler
&
fphandler
UErrorCode
&
status
)
const
{
UnicodeString
fallbackPattern
;
fInfo
-
>
getFallbackIntervalPattern
(
fallbackPattern
)
;
SimpleFormatter
sf
(
fallbackPattern
2
2
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
int32_t
offsets
[
2
]
;
UnicodeString
patternBody
=
sf
.
getTextWithNoArguments
(
offsets
2
)
;
UErrorCode
tempStatus
=
U_ZERO_ERROR
;
if
(
offsets
[
0
]
<
offsets
[
1
]
)
{
firstIndex
=
0
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
0
offsets
[
0
]
)
)
;
fDateFormat
-
>
_format
(
fromCalendar
appendTo
fphandler
status
)
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
offsets
[
0
]
offsets
[
1
]
)
)
;
fDateFormat
-
>
setContext
(
UDISPCTX_CAPITALIZATION_NONE
tempStatus
)
;
fDateFormat
-
>
_format
(
toCalendar
appendTo
fphandler
status
)
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
offsets
[
1
]
)
)
;
}
else
{
firstIndex
=
1
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
0
offsets
[
1
]
)
)
;
fDateFormat
-
>
_format
(
toCalendar
appendTo
fphandler
status
)
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
offsets
[
1
]
offsets
[
0
]
)
)
;
fDateFormat
-
>
setContext
(
UDISPCTX_CAPITALIZATION_NONE
tempStatus
)
;
fDateFormat
-
>
_format
(
fromCalendar
appendTo
fphandler
status
)
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
offsets
[
0
]
)
)
;
}
}
UnicodeString
&
DateIntervalFormat
:
:
fallbackFormat
(
Calendar
&
fromCalendar
Calendar
&
toCalendar
UBool
fromToOnSameDay
UnicodeString
&
appendTo
int8_t
&
firstIndex
FieldPositionHandler
&
fphandler
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
UBool
formatDatePlusTimeRange
=
(
fromToOnSameDay
&
&
fDatePattern
&
&
fTimePattern
)
;
if
(
formatDatePlusTimeRange
)
{
SimpleFormatter
sf
(
*
fDateTimeFormat
2
2
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
int32_t
offsets
[
2
]
;
UnicodeString
patternBody
=
sf
.
getTextWithNoArguments
(
offsets
2
)
;
UnicodeString
fullPattern
;
fDateFormat
-
>
toPattern
(
fullPattern
)
;
UErrorCode
tempStatus
=
U_ZERO_ERROR
;
if
(
offsets
[
0
]
<
offsets
[
1
]
)
{
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
0
offsets
[
0
]
)
)
;
fDateFormat
-
>
applyPattern
(
*
fTimePattern
)
;
fallbackFormatRange
(
fromCalendar
toCalendar
appendTo
firstIndex
fphandler
status
)
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
offsets
[
0
]
offsets
[
1
]
)
)
;
fDateFormat
-
>
applyPattern
(
*
fDatePattern
)
;
fDateFormat
-
>
setContext
(
UDISPCTX_CAPITALIZATION_NONE
tempStatus
)
;
fDateFormat
-
>
_format
(
fromCalendar
appendTo
fphandler
status
)
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
offsets
[
1
]
)
)
;
}
else
{
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
0
offsets
[
1
]
)
)
;
fDateFormat
-
>
applyPattern
(
*
fDatePattern
)
;
fDateFormat
-
>
_format
(
fromCalendar
appendTo
fphandler
status
)
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
offsets
[
1
]
offsets
[
0
]
)
)
;
fDateFormat
-
>
applyPattern
(
*
fTimePattern
)
;
fDateFormat
-
>
setContext
(
UDISPCTX_CAPITALIZATION_NONE
tempStatus
)
;
fallbackFormatRange
(
fromCalendar
toCalendar
appendTo
firstIndex
fphandler
status
)
;
appendTo
.
append
(
patternBody
.
tempSubStringBetween
(
offsets
[
0
]
)
)
;
}
fDateFormat
-
>
applyPattern
(
fullPattern
)
;
}
else
{
fallbackFormatRange
(
fromCalendar
toCalendar
appendTo
firstIndex
fphandler
status
)
;
}
return
appendTo
;
}
UBool
U_EXPORT2
DateIntervalFormat
:
:
fieldExistsInSkeleton
(
UCalendarDateFields
field
const
UnicodeString
&
skeleton
)
{
const
char16_t
fieldChar
=
fgCalendarFieldToPatternLetter
[
field
]
;
return
(
(
skeleton
.
indexOf
(
fieldChar
)
=
=
-
1
)
?
false
:
true
)
;
}
void
U_EXPORT2
DateIntervalFormat
:
:
adjustFieldWidth
(
const
UnicodeString
&
inputSkeleton
const
UnicodeString
&
bestMatchSkeleton
const
UnicodeString
&
bestIntervalPattern
int8_t
differenceInfo
UBool
suppressDayPeriodField
UnicodeString
&
adjustedPtn
)
{
adjustedPtn
=
bestIntervalPattern
;
int32_t
inputSkeletonFieldWidth
[
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
int32_t
bestMatchSkeletonFieldWidth
[
]
=
{
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
}
;
const
int8_t
PATTERN_CHAR_BASE
=
0x41
;
DateIntervalInfo
:
:
parseSkeleton
(
inputSkeleton
inputSkeletonFieldWidth
)
;
DateIntervalInfo
:
:
parseSkeleton
(
bestMatchSkeleton
bestMatchSkeletonFieldWidth
)
;
if
(
suppressDayPeriodField
)
{
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
u
"
\
u00A0a
"
-
1
)
UnicodeString
(
)
)
;
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
u
"
\
u202Fa
"
-
1
)
UnicodeString
(
)
)
;
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
u
"
a
\
u00A0
"
-
1
)
UnicodeString
(
)
)
;
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
u
"
a
\
u202F
"
-
1
)
UnicodeString
(
)
)
;
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
LOW_A
)
UnicodeString
(
)
)
;
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
"
"
)
UnicodeString
(
"
"
)
)
;
adjustedPtn
.
trim
(
)
;
}
if
(
differenceInfo
=
=
2
)
{
if
(
inputSkeleton
.
indexOf
(
LOW_Z
)
!
=
-
1
)
{
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
LOW_V
)
UnicodeString
(
LOW_Z
)
)
;
}
if
(
inputSkeleton
.
indexOf
(
CAP_K
)
!
=
-
1
)
{
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
LOW_H
)
UnicodeString
(
CAP_K
)
)
;
}
if
(
inputSkeleton
.
indexOf
(
LOW_K
)
!
=
-
1
)
{
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
CAP_H
)
UnicodeString
(
LOW_K
)
)
;
}
if
(
inputSkeleton
.
indexOf
(
LOW_B
)
!
=
-
1
)
{
findReplaceInPattern
(
adjustedPtn
UnicodeString
(
LOW_A
)
UnicodeString
(
LOW_B
)
)
;
}
}
if
(
adjustedPtn
.
indexOf
(
LOW_A
)
!
=
-
1
&
&
bestMatchSkeletonFieldWidth
[
LOW_A
-
PATTERN_CHAR_BASE
]
=
=
0
)
{
bestMatchSkeletonFieldWidth
[
LOW_A
-
PATTERN_CHAR_BASE
]
=
1
;
}
if
(
adjustedPtn
.
indexOf
(
LOW_B
)
!
=
-
1
&
&
bestMatchSkeletonFieldWidth
[
LOW_B
-
PATTERN_CHAR_BASE
]
=
=
0
)
{
bestMatchSkeletonFieldWidth
[
LOW_B
-
PATTERN_CHAR_BASE
]
=
1
;
}
UBool
inQuote
=
false
;
char16_t
prevCh
=
0
;
int32_t
count
=
0
;
int32_t
adjustedPtnLength
=
adjustedPtn
.
length
(
)
;
int32_t
i
;
for
(
i
=
0
;
i
<
adjustedPtnLength
;
+
+
i
)
{
char16_t
ch
=
adjustedPtn
.
charAt
(
i
)
;
if
(
ch
!
=
prevCh
&
&
count
>
0
)
{
char16_t
skeletonChar
=
prevCh
;
if
(
skeletonChar
=
=
CAP_L
)
{
skeletonChar
=
CAP_M
;
}
int32_t
fieldCount
=
bestMatchSkeletonFieldWidth
[
(
int
)
(
skeletonChar
-
PATTERN_CHAR_BASE
)
]
;
int32_t
inputFieldCount
=
inputSkeletonFieldWidth
[
(
int
)
(
skeletonChar
-
PATTERN_CHAR_BASE
)
]
;
if
(
fieldCount
=
=
count
&
&
inputFieldCount
>
fieldCount
)
{
count
=
inputFieldCount
-
fieldCount
;
int32_t
j
;
for
(
j
=
0
;
j
<
count
;
+
+
j
)
{
adjustedPtn
.
insert
(
i
prevCh
)
;
}
i
+
=
count
;
adjustedPtnLength
+
=
count
;
}
count
=
0
;
}
if
(
ch
=
=
0x0027
)
{
if
(
(
i
+
1
)
<
adjustedPtn
.
length
(
)
&
&
adjustedPtn
.
charAt
(
i
+
1
)
=
=
0x0027
)
{
+
+
i
;
}
else
{
inQuote
=
!
inQuote
;
}
}
else
if
(
!
inQuote
&
&
(
(
ch
>
=
0x0061
&
&
ch
<
=
0x007A
)
|
|
(
ch
>
=
0x0041
&
&
ch
<
=
0x005A
)
)
)
{
prevCh
=
ch
;
+
+
count
;
}
}
if
(
count
>
0
)
{
char16_t
skeletonChar
=
prevCh
;
if
(
skeletonChar
=
=
CAP_L
)
{
skeletonChar
=
CAP_M
;
}
int32_t
fieldCount
=
bestMatchSkeletonFieldWidth
[
(
int
)
(
skeletonChar
-
PATTERN_CHAR_BASE
)
]
;
int32_t
inputFieldCount
=
inputSkeletonFieldWidth
[
(
int
)
(
skeletonChar
-
PATTERN_CHAR_BASE
)
]
;
if
(
fieldCount
=
=
count
&
&
inputFieldCount
>
fieldCount
)
{
count
=
inputFieldCount
-
fieldCount
;
int32_t
j
;
for
(
j
=
0
;
j
<
count
;
+
+
j
)
{
adjustedPtn
.
append
(
prevCh
)
;
}
}
}
}
void
DateIntervalFormat
:
:
findReplaceInPattern
(
UnicodeString
&
targetString
const
UnicodeString
&
strToReplace
const
UnicodeString
&
strToReplaceWith
)
{
int32_t
firstQuoteIndex
=
targetString
.
indexOf
(
u
'
\
'
'
)
;
if
(
firstQuoteIndex
=
=
-
1
)
{
targetString
.
findAndReplace
(
strToReplace
strToReplaceWith
)
;
}
else
{
UnicodeString
result
;
UnicodeString
source
=
targetString
;
while
(
firstQuoteIndex
>
=
0
)
{
int32_t
secondQuoteIndex
=
source
.
indexOf
(
u
'
\
'
'
firstQuoteIndex
+
1
)
;
if
(
secondQuoteIndex
=
=
-
1
)
{
secondQuoteIndex
=
source
.
length
(
)
-
1
;
}
UnicodeString
unquotedText
(
source
0
firstQuoteIndex
)
;
UnicodeString
quotedText
(
source
firstQuoteIndex
secondQuoteIndex
-
firstQuoteIndex
+
1
)
;
unquotedText
.
findAndReplace
(
strToReplace
strToReplaceWith
)
;
result
+
=
unquotedText
;
result
+
=
quotedText
;
source
.
remove
(
0
secondQuoteIndex
+
1
)
;
firstQuoteIndex
=
source
.
indexOf
(
u
'
\
'
'
)
;
}
source
.
findAndReplace
(
strToReplace
strToReplaceWith
)
;
result
+
=
source
;
targetString
=
result
;
}
}
void
DateIntervalFormat
:
:
concatSingleDate2TimeInterval
(
UnicodeString
&
format
const
UnicodeString
&
datePattern
UCalendarDateFields
field
UErrorCode
&
status
)
{
int32_t
itvPtnIndex
=
DateIntervalInfo
:
:
calendarFieldToIntervalIndex
(
field
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
PatternInfo
&
timeItvPtnInfo
=
fIntervalPatterns
[
itvPtnIndex
]
;
if
(
!
timeItvPtnInfo
.
firstPart
.
isEmpty
(
)
)
{
UnicodeString
timeIntervalPattern
(
timeItvPtnInfo
.
firstPart
)
;
timeIntervalPattern
.
append
(
timeItvPtnInfo
.
secondPart
)
;
UnicodeString
combinedPattern
;
SimpleFormatter
(
format
2
2
status
)
.
format
(
timeIntervalPattern
datePattern
combinedPattern
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
setIntervalPattern
(
field
combinedPattern
timeItvPtnInfo
.
laterDateFirst
)
;
}
}
const
char16_t
DateIntervalFormat
:
:
fgCalendarFieldToPatternLetter
[
]
=
{
CAP_G
LOW_Y
CAP_M
LOW_W
CAP_W
LOW_D
CAP_D
CAP_E
CAP_F
LOW_A
LOW_H
CAP_H
LOW_M
LOW_S
CAP_S
LOW_Z
SPACE
CAP_Y
LOW_E
LOW_U
LOW_G
CAP_A
SPACE
SPACE
}
;
U_NAMESPACE_END
#
endif
