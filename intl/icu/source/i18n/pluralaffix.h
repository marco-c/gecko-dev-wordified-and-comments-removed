#
ifndef
__PLURALAFFIX_H__
#
define
__PLURALAFFIX_H__
#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
unum
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
digitaffix
.
h
"
#
include
"
pluralmap
.
h
"
U_NAMESPACE_BEGIN
class
FieldPositionHandler
;
#
if
!
U_PLATFORM_IS_DARWIN_BASED
template
class
U_I18N_API
PluralMap
<
DigitAffix
>
;
#
endif
class
U_I18N_API
PluralAffix
:
public
UMemory
{
public
:
PluralAffix
(
)
:
affixes
(
)
{
}
PluralAffix
(
const
DigitAffix
&
otherVariant
)
:
affixes
(
otherVariant
)
{
}
UBool
setVariant
(
const
char
*
category
const
UnicodeString
&
variant
UErrorCode
&
status
)
;
void
remove
(
)
;
void
appendUChar
(
UChar
value
int32_t
fieldId
=
UNUM_FIELD_COUNT
)
;
void
append
(
const
UnicodeString
&
value
int32_t
fieldId
=
UNUM_FIELD_COUNT
)
;
void
append
(
const
UChar
*
value
int32_t
charCount
int32_t
fieldId
=
UNUM_FIELD_COUNT
)
;
UBool
append
(
const
PluralAffix
&
rhs
int32_t
fieldId
UErrorCode
&
status
)
;
const
DigitAffix
&
getByCategory
(
const
char
*
category
)
const
;
const
DigitAffix
&
getByCategory
(
const
UnicodeString
&
category
)
const
;
const
DigitAffix
&
getOtherVariant
(
)
const
{
return
affixes
.
getOther
(
)
;
}
UBool
hasMultipleVariants
(
)
const
;
UBool
equals
(
const
PluralAffix
&
rhs
)
const
{
return
affixes
.
equals
(
rhs
.
affixes
&
eq
)
;
}
private
:
PluralMap
<
DigitAffix
>
affixes
;
static
UBool
eq
(
const
DigitAffix
&
x
const
DigitAffix
&
y
)
{
return
x
.
equals
(
y
)
;
}
}
;
U_NAMESPACE_END
#
endif
#
endif
