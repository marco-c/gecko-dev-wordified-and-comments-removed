#
include
"
unicode
/
utypes
.
h
"
#
ifndef
U_HIDE_DEPRECATED_API
#
ifndef
MESSAGEFORMAT2_EVALUATION_H
#
define
MESSAGEFORMAT2_EVALUATION_H
#
if
U_SHOW_CPLUSPLUS_API
#
if
!
UCONFIG_NO_NORMALIZATION
#
if
!
UCONFIG_NO_FORMATTING
#
if
!
UCONFIG_NO_MF2
#
include
"
unicode
/
messageformat2_arguments
.
h
"
#
include
"
unicode
/
messageformat2_data_model
.
h
"
#
include
"
unicode
/
messageformat2_function_registry
.
h
"
#
include
"
messageformat2_errors
.
h
"
U_NAMESPACE_BEGIN
namespace
message2
{
namespace
functions
{
static
constexpr
std
:
:
u16string_view
DATETIME
=
u
"
datetime
"
;
static
constexpr
std
:
:
u16string_view
DATE
=
u
"
date
"
;
static
constexpr
std
:
:
u16string_view
TIME
=
u
"
time
"
;
static
constexpr
std
:
:
u16string_view
NUMBER
=
u
"
number
"
;
static
constexpr
std
:
:
u16string_view
INTEGER
=
u
"
integer
"
;
static
constexpr
std
:
:
u16string_view
TEST_FUNCTION
=
u
"
test
:
function
"
;
static
constexpr
std
:
:
u16string_view
TEST_FORMAT
=
u
"
test
:
format
"
;
static
constexpr
std
:
:
u16string_view
TEST_SELECT
=
u
"
test
:
select
"
;
static
constexpr
std
:
:
u16string_view
STRING
=
u
"
string
"
;
}
using
namespace
data_model
;
class
PrioritizedVariant
:
public
UObject
{
public
:
PrioritizedVariant
(
)
=
default
;
PrioritizedVariant
(
PrioritizedVariant
&
&
)
=
default
;
PrioritizedVariant
&
operator
=
(
PrioritizedVariant
&
&
)
noexcept
=
default
;
UBool
operator
<
(
const
PrioritizedVariant
&
)
const
;
int32_t
priority
;
SelectorKeys
keys
;
Pattern
pat
;
PrioritizedVariant
(
uint32_t
p
const
SelectorKeys
&
k
const
Pattern
&
pattern
)
noexcept
:
priority
(
p
)
keys
(
k
)
pat
(
pattern
)
{
}
virtual
~
PrioritizedVariant
(
)
;
}
;
static
inline
int32_t
comparePrioritizedVariants
(
UElement
left
UElement
right
)
{
const
PrioritizedVariant
&
tuple1
=
*
(
static_cast
<
const
PrioritizedVariant
*
>
(
left
.
pointer
)
)
;
const
PrioritizedVariant
&
tuple2
=
*
(
static_cast
<
const
PrioritizedVariant
*
>
(
right
.
pointer
)
)
;
if
(
tuple1
<
tuple2
)
{
return
-
1
;
}
if
(
tuple1
.
priority
=
=
tuple2
.
priority
)
{
return
0
;
}
return
1
;
}
class
Environment
;
class
Closure
:
public
UMemory
{
public
:
const
Expression
&
getExpr
(
)
const
{
return
expr
;
}
const
Environment
&
getEnv
(
)
const
{
return
env
;
}
Closure
(
const
Expression
&
expression
const
Environment
&
environment
)
:
expr
(
expression
)
env
(
environment
)
{
}
Closure
(
Closure
&
&
)
=
default
;
virtual
~
Closure
(
)
;
private
:
const
Expression
&
expr
;
const
Environment
&
env
;
}
;
class
Environment
:
public
UMemory
{
public
:
virtual
bool
has
(
const
VariableName
&
)
const
=
0
;
virtual
const
Closure
&
lookup
(
const
VariableName
&
)
const
=
0
;
static
Environment
*
create
(
UErrorCode
&
)
;
static
Environment
*
create
(
const
VariableName
&
Closure
&
&
Environment
*
UErrorCode
&
)
;
virtual
~
Environment
(
)
;
}
;
class
NonEmptyEnvironment
;
class
EmptyEnvironment
:
public
Environment
{
public
:
EmptyEnvironment
(
)
=
default
;
virtual
~
EmptyEnvironment
(
)
;
private
:
friend
class
Environment
;
bool
has
(
const
VariableName
&
)
const
override
;
const
Closure
&
lookup
(
const
VariableName
&
)
const
override
;
static
EmptyEnvironment
*
create
(
UErrorCode
&
)
;
static
NonEmptyEnvironment
*
create
(
const
VariableName
&
Closure
&
&
Environment
*
UErrorCode
&
)
;
}
;
class
NonEmptyEnvironment
:
public
Environment
{
private
:
friend
class
Environment
;
bool
has
(
const
VariableName
&
)
const
override
;
const
Closure
&
lookup
(
const
VariableName
&
)
const
override
;
static
NonEmptyEnvironment
*
create
(
const
VariableName
&
Closure
&
&
const
Environment
*
UErrorCode
&
)
;
virtual
~
NonEmptyEnvironment
(
)
;
private
:
friend
class
Environment
;
NonEmptyEnvironment
(
const
VariableName
&
v
Closure
&
&
c
Environment
*
e
)
:
var
(
v
)
rhs
(
std
:
:
move
(
c
)
)
parent
(
e
)
{
}
VariableName
var
;
Closure
rhs
;
const
LocalPointer
<
Environment
>
parent
;
}
;
class
MessageFormatter
;
class
MessageContext
:
public
UMemory
{
public
:
MessageContext
(
const
MessageArguments
&
const
StaticErrors
&
UErrorCode
&
)
;
const
Formattable
*
getGlobal
(
const
VariableName
&
UErrorCode
&
)
const
;
void
checkErrors
(
UErrorCode
&
status
)
const
;
DynamicErrors
&
getErrors
(
)
{
return
errors
;
}
virtual
~
MessageContext
(
)
;
private
:
const
MessageArguments
&
arguments
;
DynamicErrors
errors
;
}
;
class
InternalValue
:
public
UObject
{
public
:
const
FunctionName
&
getFunctionName
(
)
const
{
return
name
;
}
bool
canSelect
(
)
const
{
return
selector
!
=
nullptr
;
}
const
Selector
*
getSelector
(
UErrorCode
&
)
const
;
FormattedPlaceholder
forceFormatting
(
DynamicErrors
&
errs
UErrorCode
&
errorCode
)
;
void
forceSelection
(
DynamicErrors
&
errs
const
UnicodeString
*
keys
int32_t
keysLen
UnicodeString
*
prefs
int32_t
&
prefsLen
UErrorCode
&
errorCode
)
;
virtual
~
InternalValue
(
)
;
InternalValue
(
FormattedPlaceholder
&
&
)
;
InternalValue
(
InternalValue
*
FunctionOptions
&
&
const
FunctionName
&
const
Formatter
*
const
Selector
*
)
;
const
UnicodeString
&
getFallback
(
)
const
;
bool
isFallback
(
)
const
;
bool
hasNullOperand
(
)
const
;
FormattedPlaceholder
takeArgument
(
UErrorCode
&
errorCode
)
;
InternalValue
(
InternalValue
&
&
other
)
{
*
this
=
std
:
:
move
(
other
)
;
}
InternalValue
&
operator
=
(
InternalValue
&
&
other
)
noexcept
;
private
:
std
:
:
variant
<
InternalValue
*
FormattedPlaceholder
>
argument
;
FunctionOptions
options
;
FunctionName
name
;
const
Selector
*
selector
;
const
Formatter
*
formatter
;
bool
checkSelectOption
(
)
const
;
}
;
}
U_NAMESPACE_END
#
endif
#
endif
#
endif
#
endif
#
endif
#
endif
