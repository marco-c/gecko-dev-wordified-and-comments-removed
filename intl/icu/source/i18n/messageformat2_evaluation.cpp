#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_NORMALIZATION
#
if
!
UCONFIG_NO_FORMATTING
#
if
!
UCONFIG_NO_MF2
#
include
"
messageformat2_allocation
.
h
"
#
include
"
messageformat2_evaluation
.
h
"
#
include
"
messageformat2_function_registry_internal
.
h
"
#
include
"
messageformat2_macros
.
h
"
#
include
"
uvector
.
h
"
U_NAMESPACE_BEGIN
namespace
message2
{
using
namespace
data_model
;
ResolvedFunctionOption
:
:
ResolvedFunctionOption
(
ResolvedFunctionOption
&
&
other
)
{
name
=
std
:
:
move
(
other
.
name
)
;
value
=
std
:
:
move
(
other
.
value
)
;
sourceIsLiteral
=
other
.
sourceIsLiteral
;
}
ResolvedFunctionOption
:
:
~
ResolvedFunctionOption
(
)
{
}
const
ResolvedFunctionOption
*
FunctionOptions
:
:
getResolvedFunctionOptions
(
int32_t
&
len
)
const
{
len
=
functionOptionsLen
;
U_ASSERT
(
len
=
=
0
|
|
options
!
=
nullptr
)
;
return
options
;
}
FunctionOptions
:
:
FunctionOptions
(
UVector
&
&
optionsVector
UErrorCode
&
status
)
{
CHECK_ERROR
(
status
)
;
functionOptionsLen
=
optionsVector
.
size
(
)
;
options
=
moveVectorToArray
<
ResolvedFunctionOption
>
(
optionsVector
status
)
;
}
UBool
FunctionOptions
:
:
wasSetFromLiteral
(
const
UnicodeString
&
key
)
const
{
if
(
options
=
=
nullptr
)
{
U_ASSERT
(
functionOptionsLen
=
=
0
)
;
}
for
(
int32_t
i
=
0
;
i
<
functionOptionsLen
;
i
+
+
)
{
const
ResolvedFunctionOption
&
opt
=
options
[
i
]
;
if
(
opt
.
getName
(
)
=
=
key
)
{
return
opt
.
isLiteral
(
)
;
}
}
return
false
;
}
UBool
FunctionOptions
:
:
getFunctionOption
(
std
:
:
u16string_view
key
Formattable
&
option
)
const
{
if
(
options
=
=
nullptr
)
{
U_ASSERT
(
functionOptionsLen
=
=
0
)
;
}
for
(
int32_t
i
=
0
;
i
<
functionOptionsLen
;
i
+
+
)
{
const
ResolvedFunctionOption
&
opt
=
options
[
i
]
;
if
(
opt
.
getName
(
)
=
=
key
)
{
option
=
opt
.
getValue
(
)
;
return
true
;
}
}
return
false
;
}
UnicodeString
FunctionOptions
:
:
getStringFunctionOption
(
std
:
:
u16string_view
key
)
const
{
Formattable
option
;
if
(
getFunctionOption
(
key
option
)
)
{
if
(
option
.
getType
(
)
=
=
UFMT_STRING
)
{
UErrorCode
localErrorCode
=
U_ZERO_ERROR
;
UnicodeString
val
=
option
.
getString
(
localErrorCode
)
;
U_ASSERT
(
U_SUCCESS
(
localErrorCode
)
)
;
return
val
;
}
}
return
{
}
;
}
FunctionOptions
&
FunctionOptions
:
:
operator
=
(
FunctionOptions
&
&
other
)
noexcept
{
functionOptionsLen
=
other
.
functionOptionsLen
;
options
=
other
.
options
;
other
.
functionOptionsLen
=
0
;
other
.
options
=
nullptr
;
return
*
this
;
}
FunctionOptions
:
:
FunctionOptions
(
FunctionOptions
&
&
other
)
{
*
this
=
std
:
:
move
(
other
)
;
}
FunctionOptions
:
:
~
FunctionOptions
(
)
{
if
(
options
!
=
nullptr
)
{
delete
[
]
options
;
options
=
nullptr
;
}
}
static
bool
containsOption
(
const
UVector
&
opts
const
ResolvedFunctionOption
&
opt
)
{
for
(
int32_t
i
=
0
;
i
<
opts
.
size
(
)
;
i
+
+
)
{
if
(
static_cast
<
ResolvedFunctionOption
*
>
(
opts
[
i
]
)
-
>
getName
(
)
=
=
opt
.
getName
(
)
)
{
return
true
;
}
}
return
false
;
}
FunctionOptions
FunctionOptions
:
:
mergeOptions
(
FunctionOptions
&
&
other
UErrorCode
&
status
)
{
UVector
mergedOptions
(
status
)
;
mergedOptions
.
setDeleter
(
uprv_deleteUObject
)
;
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
for
(
int32_t
i
=
0
;
i
<
functionOptionsLen
;
i
+
+
)
{
mergedOptions
.
adoptElement
(
create
<
ResolvedFunctionOption
>
(
std
:
:
move
(
options
[
i
]
)
status
)
status
)
;
}
for
(
int
i
=
0
;
i
<
other
.
functionOptionsLen
;
i
+
+
)
{
if
(
!
containsOption
(
mergedOptions
other
.
options
[
i
]
)
)
{
mergedOptions
.
adoptElement
(
create
<
ResolvedFunctionOption
>
(
std
:
:
move
(
other
.
options
[
i
]
)
status
)
status
)
;
}
}
delete
[
]
options
;
options
=
nullptr
;
functionOptionsLen
=
0
;
return
FunctionOptions
(
std
:
:
move
(
mergedOptions
)
status
)
;
}
UBool
PrioritizedVariant
:
:
operator
<
(
const
PrioritizedVariant
&
other
)
const
{
if
(
priority
<
other
.
priority
)
{
return
true
;
}
return
false
;
}
PrioritizedVariant
:
:
~
PrioritizedVariant
(
)
{
}
Environment
*
Environment
:
:
create
(
const
VariableName
&
var
Closure
&
&
c
Environment
*
parent
UErrorCode
&
errorCode
)
{
NULL_ON_ERROR
(
errorCode
)
;
Environment
*
result
=
new
NonEmptyEnvironment
(
var
std
:
:
move
(
c
)
parent
)
;
if
(
result
=
=
nullptr
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
return
result
;
}
Environment
*
Environment
:
:
create
(
UErrorCode
&
errorCode
)
{
NULL_ON_ERROR
(
errorCode
)
;
Environment
*
result
=
new
EmptyEnvironment
(
)
;
if
(
result
=
=
nullptr
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
return
result
;
}
const
Closure
&
EmptyEnvironment
:
:
lookup
(
const
VariableName
&
v
)
const
{
(
void
)
v
;
U_ASSERT
(
false
)
;
UPRV_UNREACHABLE_EXIT
;
}
const
Closure
&
NonEmptyEnvironment
:
:
lookup
(
const
VariableName
&
v
)
const
{
if
(
v
=
=
var
)
{
return
rhs
;
}
return
parent
-
>
lookup
(
v
)
;
}
bool
EmptyEnvironment
:
:
has
(
const
VariableName
&
v
)
const
{
(
void
)
v
;
return
false
;
}
bool
NonEmptyEnvironment
:
:
has
(
const
VariableName
&
v
)
const
{
if
(
v
=
=
var
)
{
return
true
;
}
return
parent
-
>
has
(
v
)
;
}
Environment
:
:
~
Environment
(
)
{
}
NonEmptyEnvironment
:
:
~
NonEmptyEnvironment
(
)
{
}
EmptyEnvironment
:
:
~
EmptyEnvironment
(
)
{
}
Closure
:
:
~
Closure
(
)
{
}
void
MessageContext
:
:
checkErrors
(
UErrorCode
&
status
)
const
{
CHECK_ERROR
(
status
)
;
errors
.
checkErrors
(
status
)
;
}
const
Formattable
*
MessageContext
:
:
getGlobal
(
const
VariableName
&
v
UErrorCode
&
errorCode
)
const
{
return
arguments
.
getArgument
(
v
errorCode
)
;
}
MessageContext
:
:
MessageContext
(
const
MessageArguments
&
args
const
StaticErrors
&
e
UErrorCode
&
status
)
:
arguments
(
args
)
errors
(
e
status
)
{
}
MessageContext
:
:
~
MessageContext
(
)
{
}
bool
InternalValue
:
:
isFallback
(
)
const
{
return
std
:
:
holds_alternative
<
FormattedPlaceholder
>
(
argument
)
&
&
std
:
:
get_if
<
FormattedPlaceholder
>
(
&
argument
)
-
>
isFallback
(
)
;
}
bool
InternalValue
:
:
hasNullOperand
(
)
const
{
return
std
:
:
holds_alternative
<
FormattedPlaceholder
>
(
argument
)
&
&
std
:
:
get_if
<
FormattedPlaceholder
>
(
&
argument
)
-
>
isNullOperand
(
)
;
}
FormattedPlaceholder
InternalValue
:
:
takeArgument
(
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
{
}
;
}
if
(
std
:
:
holds_alternative
<
FormattedPlaceholder
>
(
argument
)
)
{
return
std
:
:
move
(
*
std
:
:
get_if
<
FormattedPlaceholder
>
(
&
argument
)
)
;
}
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
{
}
;
}
const
UnicodeString
&
InternalValue
:
:
getFallback
(
)
const
{
if
(
std
:
:
holds_alternative
<
FormattedPlaceholder
>
(
argument
)
)
{
return
std
:
:
get_if
<
FormattedPlaceholder
>
(
&
argument
)
-
>
getFallback
(
)
;
}
return
(
*
std
:
:
get_if
<
InternalValue
*
>
(
&
argument
)
)
-
>
getFallback
(
)
;
}
const
Selector
*
InternalValue
:
:
getSelector
(
UErrorCode
&
errorCode
)
const
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
nullptr
;
}
if
(
selector
=
=
nullptr
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
selector
;
}
InternalValue
:
:
InternalValue
(
FormattedPlaceholder
&
&
arg
)
{
argument
=
std
:
:
move
(
arg
)
;
selector
=
nullptr
;
formatter
=
nullptr
;
}
InternalValue
:
:
InternalValue
(
InternalValue
*
operand
FunctionOptions
&
&
opts
const
FunctionName
&
functionName
const
Formatter
*
f
const
Selector
*
s
)
{
argument
=
operand
;
options
=
std
:
:
move
(
opts
)
;
name
=
functionName
;
selector
=
s
;
formatter
=
f
;
U_ASSERT
(
selector
!
=
nullptr
|
|
formatter
!
=
nullptr
)
;
}
void
InternalValue
:
:
forceSelection
(
DynamicErrors
&
errs
const
UnicodeString
*
keys
int32_t
keysLen
UnicodeString
*
prefs
int32_t
&
prefsLen
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
if
(
!
canSelect
(
)
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
FunctionOptions
opts
;
InternalValue
*
p
=
this
;
FunctionName
selectorName
=
name
;
bool
operandSelect
=
false
;
while
(
std
:
:
holds_alternative
<
InternalValue
*
>
(
p
-
>
argument
)
)
{
if
(
p
-
>
name
!
=
selectorName
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
if
(
p
!
=
this
&
&
!
p
-
>
options
.
getStringFunctionOption
(
options
:
:
SELECT
)
.
isEmpty
(
)
&
&
(
selectorName
=
=
functions
:
:
NUMBER
|
|
selectorName
=
=
functions
:
:
INTEGER
)
)
{
operandSelect
=
true
;
}
opts
=
opts
.
mergeOptions
(
std
:
:
move
(
p
-
>
options
)
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
InternalValue
*
next
=
*
std
:
:
get_if
<
InternalValue
*
>
(
&
p
-
>
argument
)
;
p
=
next
;
}
FormattedPlaceholder
arg
=
std
:
:
move
(
*
std
:
:
get_if
<
FormattedPlaceholder
>
(
&
p
-
>
argument
)
)
;
bool
badSelectOption
=
!
checkSelectOption
(
)
;
selector
-
>
selectKey
(
std
:
:
move
(
arg
)
std
:
:
move
(
opts
)
keys
keysLen
prefs
prefsLen
errorCode
)
;
if
(
errorCode
=
=
U_MF_SELECTOR_ERROR
)
{
errorCode
=
U_ZERO_ERROR
;
errs
.
setSelectorError
(
selectorName
errorCode
)
;
}
else
if
(
errorCode
=
=
U_MF_BAD_OPTION
)
{
errorCode
=
U_ZERO_ERROR
;
errs
.
setBadOption
(
selectorName
errorCode
)
;
}
else
if
(
operandSelect
|
|
badSelectOption
)
{
errs
.
setRecoverableBadOption
(
selectorName
errorCode
)
;
prefsLen
=
0
;
}
}
bool
InternalValue
:
:
checkSelectOption
(
)
const
{
if
(
name
!
=
UnicodeString
(
"
number
"
)
&
&
name
!
=
UnicodeString
(
"
integer
"
)
)
{
return
true
;
}
Formattable
opt
;
if
(
!
options
.
getFunctionOption
(
UnicodeString
(
"
select
"
)
opt
)
)
{
return
true
;
}
return
options
.
wasSetFromLiteral
(
UnicodeString
(
"
select
"
)
)
;
}
FormattedPlaceholder
InternalValue
:
:
forceFormatting
(
DynamicErrors
&
errs
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
{
}
;
}
if
(
formatter
=
=
nullptr
&
&
selector
=
=
nullptr
)
{
U_ASSERT
(
std
:
:
holds_alternative
<
FormattedPlaceholder
>
(
argument
)
)
;
return
std
:
:
move
(
*
std
:
:
get_if
<
FormattedPlaceholder
>
(
&
argument
)
)
;
}
if
(
formatter
=
=
nullptr
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
{
}
;
}
FormattedPlaceholder
arg
;
if
(
std
:
:
holds_alternative
<
FormattedPlaceholder
>
(
argument
)
)
{
arg
=
std
:
:
move
(
*
std
:
:
get_if
<
FormattedPlaceholder
>
(
&
argument
)
)
;
}
else
{
arg
=
(
*
std
:
:
get_if
<
InternalValue
*
>
(
&
argument
)
)
-
>
forceFormatting
(
errs
errorCode
)
;
}
if
(
U_FAILURE
(
errorCode
)
)
{
return
{
}
;
}
if
(
arg
.
isFallback
(
)
)
{
return
arg
;
}
UnicodeString
fallback
;
if
(
arg
.
isNullOperand
(
)
)
{
fallback
=
u
"
:
"
;
fallback
+
=
name
;
}
else
{
fallback
=
arg
.
getFallback
(
)
;
}
bool
badSelect
=
!
checkSelectOption
(
)
;
FormattedPlaceholder
result
=
formatter
-
>
format
(
std
:
:
move
(
arg
)
std
:
:
move
(
options
)
errorCode
)
;
if
(
U_SUCCESS
(
errorCode
)
&
&
errorCode
=
=
U_USING_DEFAULT_WARNING
)
{
errorCode
=
U_ZERO_ERROR
;
}
if
(
U_FAILURE
(
errorCode
)
)
{
if
(
errorCode
=
=
U_MF_OPERAND_MISMATCH_ERROR
)
{
errorCode
=
U_ZERO_ERROR
;
errs
.
setOperandMismatchError
(
name
errorCode
)
;
}
else
if
(
errorCode
=
=
U_MF_BAD_OPTION
)
{
errorCode
=
U_ZERO_ERROR
;
errs
.
setBadOption
(
name
errorCode
)
;
}
else
{
errorCode
=
U_ZERO_ERROR
;
errs
.
setFormattingError
(
name
errorCode
)
;
}
}
if
(
errs
.
hasFormattingError
(
)
|
|
errs
.
hasBadOptionError
(
)
)
{
return
FormattedPlaceholder
(
fallback
)
;
}
if
(
badSelect
)
{
errs
.
setRecoverableBadOption
(
name
errorCode
)
;
}
return
result
;
}
InternalValue
&
InternalValue
:
:
operator
=
(
InternalValue
&
&
other
)
noexcept
{
argument
=
std
:
:
move
(
other
.
argument
)
;
other
.
argument
=
nullptr
;
options
=
std
:
:
move
(
other
.
options
)
;
name
=
other
.
name
;
selector
=
other
.
selector
;
formatter
=
other
.
formatter
;
other
.
selector
=
nullptr
;
other
.
formatter
=
nullptr
;
return
*
this
;
}
InternalValue
:
:
~
InternalValue
(
)
{
delete
selector
;
selector
=
nullptr
;
delete
formatter
;
formatter
=
nullptr
;
if
(
std
:
:
holds_alternative
<
InternalValue
*
>
(
argument
)
)
{
delete
*
std
:
:
get_if
<
InternalValue
*
>
(
&
argument
)
;
argument
=
nullptr
;
}
}
}
U_NAMESPACE_END
#
endif
#
endif
#
endif
