#
ifndef
NFRS_H
#
define
NFRS_H
#
include
"
unicode
/
uobject
.
h
"
#
include
"
unicode
/
rbnf
.
h
"
#
if
U_HAVE_RBNF
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
umisc
.
h
"
#
include
"
nfrlist
.
h
"
U_NAMESPACE_BEGIN
class
NFRuleSet
:
public
UMemory
{
public
:
NFRuleSet
(
RuleBasedNumberFormat
*
owner
UnicodeString
*
descriptions
int32_t
index
UErrorCode
&
status
)
;
void
parseRules
(
UnicodeString
&
rules
UErrorCode
&
status
)
;
void
setNonNumericalRule
(
NFRule
*
rule
)
;
void
setBestFractionRule
(
int32_t
originalIndex
NFRule
*
newRule
UBool
rememberRule
)
;
void
makeIntoFractionRuleSet
(
)
{
fIsFractionRuleSet
=
true
;
}
~
NFRuleSet
(
)
;
bool
operator
=
=
(
const
NFRuleSet
&
rhs
)
const
;
bool
operator
!
=
(
const
NFRuleSet
&
rhs
)
const
{
return
!
operator
=
=
(
rhs
)
;
}
UBool
isPublic
(
)
const
{
return
fIsPublic
;
}
UBool
isParseable
(
)
const
{
return
fIsParseable
;
}
UBool
isFractionRuleSet
(
)
const
{
return
fIsFractionRuleSet
;
}
void
getName
(
UnicodeString
&
result
)
const
{
result
.
setTo
(
name
)
;
}
UBool
isNamed
(
const
UnicodeString
&
_name
)
const
{
return
this
-
>
name
=
=
_name
;
}
void
format
(
int64_t
number
UnicodeString
&
toAppendTo
int32_t
pos
int32_t
recursionCount
UErrorCode
&
status
)
const
;
void
format
(
double
number
UnicodeString
&
toAppendTo
int32_t
pos
int32_t
recursionCount
UErrorCode
&
status
)
const
;
UBool
parse
(
const
UnicodeString
&
text
ParsePosition
&
pos
double
upperBound
uint32_t
nonNumericalExecutedRuleMask
int32_t
recursionCount
Formattable
&
result
)
const
;
void
appendRules
(
UnicodeString
&
result
)
const
;
void
setDecimalFormatSymbols
(
const
DecimalFormatSymbols
&
newSymbols
UErrorCode
&
status
)
;
const
RuleBasedNumberFormat
*
getOwner
(
)
const
{
return
owner
;
}
private
:
const
NFRule
*
findNormalRule
(
int64_t
number
)
const
;
const
NFRule
*
findDoubleRule
(
double
number
)
const
;
const
NFRule
*
findFractionRuleSetRule
(
double
number
)
const
;
friend
class
NFSubstitution
;
private
:
UnicodeString
name
;
NFRuleList
rules
;
NFRule
*
nonNumericalRules
[
6
]
;
RuleBasedNumberFormat
*
owner
;
NFRuleList
fractionRules
;
UBool
fIsFractionRuleSet
;
UBool
fIsPublic
;
UBool
fIsParseable
;
NFRuleSet
(
const
NFRuleSet
&
other
)
;
NFRuleSet
&
operator
=
(
const
NFRuleSet
&
other
)
;
}
;
int64_t
util64_fromDouble
(
double
d
)
;
uint64_t
util64_pow
(
uint32_t
radix
uint16_t
exponent
)
;
uint32_t
util64_tou
(
int64_t
n
char16_t
*
buffer
uint32_t
buflen
uint32_t
radix
=
10
UBool
raw
=
false
)
;
#
ifdef
RBNF_DEBUG
int64_t
util64_utoi
(
const
char16_t
*
str
uint32_t
radix
=
10
)
;
uint32_t
util64_toa
(
int64_t
n
char
*
buffer
uint32_t
buflen
uint32_t
radix
=
10
UBool
raw
=
false
)
;
int64_t
util64_atoi
(
const
char
*
str
uint32_t
radix
)
;
#
endif
U_NAMESPACE_END
#
endif
#
endif
