#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
charstr
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
cstring
.
h
"
#
include
"
measunit_impl
.
h
"
#
include
"
number_decimalquantity
.
h
"
#
include
"
number_roundingutils
.
h
"
#
include
"
resource
.
h
"
#
include
"
unicode
/
measure
.
h
"
#
include
"
units_data
.
h
"
#
include
"
units_router
.
h
"
#
include
<
cmath
>
U_NAMESPACE_BEGIN
namespace
units
{
using
number
:
:
Precision
;
using
number
:
:
impl
:
:
parseIncrementOption
;
Precision
UnitsRouter
:
:
parseSkeletonToPrecision
(
icu
:
:
UnicodeString
precisionSkeleton
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
constexpr
int32_t
kSkelPrefixLen
=
20
;
if
(
!
precisionSkeleton
.
startsWith
(
UNICODE_STRING_SIMPLE
(
"
precision
-
increment
/
"
)
)
)
{
status
=
U_INVALID_FORMAT_ERROR
;
return
{
}
;
}
U_ASSERT
(
precisionSkeleton
[
kSkelPrefixLen
-
1
]
=
=
u
'
/
'
)
;
StringSegment
segment
(
precisionSkeleton
false
)
;
segment
.
adjustOffset
(
kSkelPrefixLen
)
;
Precision
result
;
parseIncrementOption
(
segment
result
status
)
;
return
result
;
}
UnitsRouter
:
:
UnitsRouter
(
StringPiece
inputUnitIdentifier
StringPiece
region
StringPiece
usage
UErrorCode
&
status
)
{
this
-
>
init
(
MeasureUnit
:
:
forIdentifier
(
inputUnitIdentifier
status
)
region
usage
status
)
;
}
UnitsRouter
:
:
UnitsRouter
(
const
MeasureUnit
&
inputUnit
StringPiece
region
StringPiece
usage
UErrorCode
&
status
)
{
this
-
>
init
(
std
:
:
move
(
inputUnit
)
region
usage
status
)
;
}
void
UnitsRouter
:
:
init
(
const
MeasureUnit
&
inputUnit
StringPiece
region
StringPiece
usage
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
ConversionRates
conversionRates
(
status
)
;
UnitPreferences
prefs
(
status
)
;
MeasureUnitImpl
inputUnitImpl
=
MeasureUnitImpl
:
:
forMeasureUnitMaybeCopy
(
inputUnit
status
)
;
MeasureUnit
baseUnit
=
(
extractCompoundBaseUnit
(
inputUnitImpl
conversionRates
status
)
)
.
build
(
status
)
;
CharString
category
=
getUnitQuantity
(
baseUnit
.
getIdentifier
(
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
const
UnitPreference
*
const
*
unitPreferences
;
int32_t
preferencesCount
=
0
;
prefs
.
getPreferencesFor
(
category
.
toStringPiece
(
)
usage
region
unitPreferences
preferencesCount
status
)
;
for
(
int
i
=
0
;
i
<
preferencesCount
;
+
+
i
)
{
U_ASSERT
(
unitPreferences
[
i
]
!
=
nullptr
)
;
const
auto
&
preference
=
*
unitPreferences
[
i
]
;
MeasureUnitImpl
complexTargetUnitImpl
=
MeasureUnitImpl
:
:
forIdentifier
(
preference
.
unit
.
data
(
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
UnicodeString
precision
=
preference
.
skeleton
;
if
(
!
precision
.
isEmpty
(
)
&
&
!
precision
.
startsWith
(
u
"
precision
-
increment
"
19
)
)
{
status
=
U_INTERNAL_PROGRAM_ERROR
;
return
;
}
outputUnits_
.
emplaceBackAndCheckErrorCode
(
status
complexTargetUnitImpl
.
copy
(
status
)
.
build
(
status
)
)
;
converterPreferences_
.
emplaceBackAndCheckErrorCode
(
status
inputUnitImpl
complexTargetUnitImpl
preference
.
geq
std
:
:
move
(
precision
)
conversionRates
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
}
}
RouteResult
UnitsRouter
:
:
route
(
double
quantity
icu
:
:
number
:
:
impl
:
:
RoundingImpl
*
rounder
UErrorCode
&
status
)
const
{
const
ConverterPreference
*
converterPreference
=
nullptr
;
for
(
int32_t
i
=
0
n
=
converterPreferences_
.
length
(
)
;
i
<
n
;
i
+
+
)
{
converterPreference
=
converterPreferences_
[
i
]
;
if
(
converterPreference
-
>
converter
.
greaterThanOrEqual
(
std
:
:
abs
(
quantity
)
*
(
1
+
DBL_EPSILON
)
converterPreference
-
>
limit
)
)
{
break
;
}
}
U_ASSERT
(
converterPreference
!
=
nullptr
)
;
if
(
rounder
!
=
nullptr
&
&
rounder
-
>
fPrecision
.
isBogus
(
)
)
{
if
(
converterPreference
-
>
precision
.
length
(
)
>
0
)
{
rounder
-
>
fPrecision
=
parseSkeletonToPrecision
(
converterPreference
-
>
precision
status
)
;
}
else
{
rounder
-
>
fPrecision
=
Precision
:
:
integer
(
)
.
withMinDigits
(
2
)
;
}
}
return
RouteResult
(
converterPreference
-
>
converter
.
convert
(
quantity
rounder
status
)
converterPreference
-
>
targetUnit
.
copy
(
status
)
)
;
}
const
MaybeStackVector
<
MeasureUnit
>
*
UnitsRouter
:
:
getOutputUnits
(
)
const
{
return
&
outputUnits_
;
}
}
U_NAMESPACE_END
#
endif
