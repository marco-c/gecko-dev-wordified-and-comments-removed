#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
define
UNISTR_FROM_STRING_EXPLICIT
#
include
"
numparse_types
.
h
"
#
include
"
numparse_currency
.
h
"
#
include
"
ucurrimp
.
h
"
#
include
"
unicode
/
errorcode
.
h
"
#
include
"
numparse_utils
.
h
"
#
include
"
string_segment
.
h
"
using
namespace
icu
;
using
namespace
icu
:
:
numparse
;
using
namespace
icu
:
:
numparse
:
:
impl
;
CombinedCurrencyMatcher
:
:
CombinedCurrencyMatcher
(
const
CurrencySymbols
&
currencySymbols
const
DecimalFormatSymbols
&
dfs
parse_flags_t
parseFlags
UErrorCode
&
status
)
:
fCurrency1
(
currencySymbols
.
getCurrencySymbol
(
status
)
)
fCurrency2
(
currencySymbols
.
getIntlCurrencySymbol
(
status
)
)
fUseFullCurrencyData
(
0
=
=
(
parseFlags
&
PARSE_FLAG_NO_FOREIGN_CURRENCY
)
)
afterPrefixInsert
(
dfs
.
getPatternForCurrencySpacing
(
UNUM_CURRENCY_INSERT
false
status
)
)
beforeSuffixInsert
(
dfs
.
getPatternForCurrencySpacing
(
UNUM_CURRENCY_INSERT
true
status
)
)
fLocaleName
(
dfs
.
getLocale
(
)
.
getName
(
)
-
1
status
)
{
utils
:
:
copyCurrencyCode
(
fCurrencyCode
currencySymbols
.
getIsoCode
(
)
)
;
if
(
!
fUseFullCurrencyData
)
{
for
(
int32_t
i
=
0
;
i
<
StandardPlural
:
:
COUNT
;
i
+
+
)
{
auto
plural
=
static_cast
<
StandardPlural
:
:
Form
>
(
i
)
;
fLocalLongNames
[
i
]
=
currencySymbols
.
getPluralName
(
plural
status
)
;
}
}
}
bool
CombinedCurrencyMatcher
:
:
match
(
StringSegment
&
segment
ParsedNumber
&
result
UErrorCode
&
status
)
const
{
if
(
result
.
currencyCode
[
0
]
!
=
0
)
{
return
false
;
}
int32_t
initialOffset
=
segment
.
getOffset
(
)
;
bool
maybeMore
=
false
;
if
(
result
.
seenNumber
(
)
&
&
!
beforeSuffixInsert
.
isEmpty
(
)
)
{
int32_t
overlap
=
segment
.
getCommonPrefixLength
(
beforeSuffixInsert
)
;
if
(
overlap
=
=
beforeSuffixInsert
.
length
(
)
)
{
segment
.
adjustOffset
(
overlap
)
;
}
maybeMore
=
maybeMore
|
|
overlap
=
=
segment
.
length
(
)
;
}
maybeMore
=
maybeMore
|
|
matchCurrency
(
segment
result
status
)
;
if
(
result
.
currencyCode
[
0
]
=
=
0
)
{
segment
.
setOffset
(
initialOffset
)
;
return
maybeMore
;
}
if
(
!
result
.
seenNumber
(
)
&
&
!
afterPrefixInsert
.
isEmpty
(
)
)
{
int32_t
overlap
=
segment
.
getCommonPrefixLength
(
afterPrefixInsert
)
;
if
(
overlap
=
=
afterPrefixInsert
.
length
(
)
)
{
segment
.
adjustOffset
(
overlap
)
;
}
maybeMore
=
maybeMore
|
|
overlap
=
=
segment
.
length
(
)
;
}
return
maybeMore
;
}
bool
CombinedCurrencyMatcher
:
:
matchCurrency
(
StringSegment
&
segment
ParsedNumber
&
result
UErrorCode
&
status
)
const
{
bool
maybeMore
=
false
;
int32_t
overlap1
;
if
(
!
fCurrency1
.
isEmpty
(
)
)
{
overlap1
=
segment
.
getCaseSensitivePrefixLength
(
fCurrency1
)
;
}
else
{
overlap1
=
-
1
;
}
maybeMore
=
maybeMore
|
|
overlap1
=
=
segment
.
length
(
)
;
if
(
overlap1
=
=
fCurrency1
.
length
(
)
)
{
utils
:
:
copyCurrencyCode
(
result
.
currencyCode
fCurrencyCode
)
;
segment
.
adjustOffset
(
overlap1
)
;
result
.
setCharsConsumed
(
segment
)
;
return
maybeMore
;
}
int32_t
overlap2
;
if
(
!
fCurrency2
.
isEmpty
(
)
)
{
overlap2
=
segment
.
getCommonPrefixLength
(
fCurrency2
)
;
}
else
{
overlap2
=
-
1
;
}
maybeMore
=
maybeMore
|
|
overlap2
=
=
segment
.
length
(
)
;
if
(
overlap2
=
=
fCurrency2
.
length
(
)
)
{
utils
:
:
copyCurrencyCode
(
result
.
currencyCode
fCurrencyCode
)
;
segment
.
adjustOffset
(
overlap2
)
;
result
.
setCharsConsumed
(
segment
)
;
return
maybeMore
;
}
if
(
fUseFullCurrencyData
)
{
const
UnicodeString
segmentString
=
segment
.
toTempUnicodeString
(
)
;
ParsePosition
ppos
(
0
)
;
int32_t
partialMatchLen
=
0
;
uprv_parseCurrency
(
fLocaleName
.
data
(
)
segmentString
ppos
UCURR_SYMBOL_NAME
&
partialMatchLen
result
.
currencyCode
status
)
;
maybeMore
=
maybeMore
|
|
partialMatchLen
=
=
segment
.
length
(
)
;
if
(
U_SUCCESS
(
status
)
&
&
ppos
.
getIndex
(
)
!
=
0
)
{
segment
.
adjustOffset
(
ppos
.
getIndex
(
)
)
;
result
.
setCharsConsumed
(
segment
)
;
return
maybeMore
;
}
}
else
{
int32_t
longestFullMatch
=
0
;
for
(
int32_t
i
=
0
;
i
<
StandardPlural
:
:
COUNT
;
i
+
+
)
{
const
UnicodeString
&
name
=
fLocalLongNames
[
i
]
;
int32_t
overlap
=
segment
.
getCommonPrefixLength
(
name
)
;
if
(
overlap
=
=
name
.
length
(
)
&
&
name
.
length
(
)
>
longestFullMatch
)
{
longestFullMatch
=
name
.
length
(
)
;
}
maybeMore
=
maybeMore
|
|
overlap
>
0
;
}
if
(
longestFullMatch
>
0
)
{
utils
:
:
copyCurrencyCode
(
result
.
currencyCode
fCurrencyCode
)
;
segment
.
adjustOffset
(
longestFullMatch
)
;
result
.
setCharsConsumed
(
segment
)
;
return
maybeMore
;
}
}
return
maybeMore
;
}
bool
CombinedCurrencyMatcher
:
:
smokeTest
(
const
StringSegment
&
)
const
{
return
true
;
}
UnicodeString
CombinedCurrencyMatcher
:
:
toString
(
)
const
{
return
u
"
<
CombinedCurrencyMatcher
>
"
;
}
#
endif
