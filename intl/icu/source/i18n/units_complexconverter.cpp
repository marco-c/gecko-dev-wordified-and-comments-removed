#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
<
cmath
>
#
include
"
cmemory
.
h
"
#
include
"
number_decimalquantity
.
h
"
#
include
"
number_roundingutils
.
h
"
#
include
"
uarrsort
.
h
"
#
include
"
uassert
.
h
"
#
include
"
unicode
/
fmtable
.
h
"
#
include
"
unicode
/
localpointer
.
h
"
#
include
"
unicode
/
measunit
.
h
"
#
include
"
unicode
/
measure
.
h
"
#
include
"
units_complexconverter
.
h
"
#
include
"
units_converter
.
h
"
U_NAMESPACE_BEGIN
namespace
units
{
ComplexUnitsConverter
:
:
ComplexUnitsConverter
(
const
MeasureUnitImpl
&
inputUnit
const
MeasureUnitImpl
&
outputUnits
const
ConversionRates
&
ratesInfo
UErrorCode
&
status
)
:
units_
(
outputUnits
.
extractIndividualUnits
(
status
)
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
U_ASSERT
(
units_
.
length
(
)
!
=
0
)
;
for
(
int32_t
i
=
0
;
i
<
units_
.
length
(
)
;
i
+
+
)
{
outputUnits_
.
emplaceBackAndCheckErrorCode
(
status
units_
[
i
]
-
>
copy
(
status
)
.
build
(
status
)
)
;
}
auto
descendingCompareUnits
=
[
]
(
const
void
*
context
const
void
*
left
const
void
*
right
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
const
auto
*
leftPointer
=
static_cast
<
const
MeasureUnitImpl
*
const
*
>
(
left
)
;
const
auto
*
rightPointer
=
static_cast
<
const
MeasureUnitImpl
*
const
*
>
(
right
)
;
UnitConverter
fromLeftToRight
(
*
*
leftPointer
*
*
rightPointer
*
static_cast
<
const
ConversionRates
*
>
(
context
)
status
)
;
double
rightFromOneLeft
=
fromLeftToRight
.
convert
(
1
.
0
)
;
if
(
std
:
:
abs
(
rightFromOneLeft
-
1
.
0
)
<
0
.
0000000001
)
{
return
0
;
}
else
if
(
rightFromOneLeft
>
1
.
0
)
{
return
-
1
;
}
return
1
;
}
;
uprv_sortArray
(
units_
.
getAlias
(
)
units_
.
length
(
)
sizeof
units_
[
0
]
descendingCompareUnits
&
ratesInfo
false
&
status
)
;
for
(
int
i
=
0
n
=
units_
.
length
(
)
;
i
<
n
;
i
+
+
)
{
if
(
i
=
=
0
)
{
unitConverters_
.
emplaceBackAndCheckErrorCode
(
status
inputUnit
*
units_
[
i
]
ratesInfo
status
)
;
}
else
{
unitConverters_
.
emplaceBackAndCheckErrorCode
(
status
*
units_
[
i
-
1
]
*
units_
[
i
]
ratesInfo
status
)
;
}
if
(
U_FAILURE
(
status
)
)
{
return
;
}
}
}
UBool
ComplexUnitsConverter
:
:
greaterThanOrEqual
(
double
quantity
double
limit
)
const
{
U_ASSERT
(
unitConverters_
.
length
(
)
>
0
)
;
double
newQuantity
=
unitConverters_
[
0
]
-
>
convert
(
quantity
)
;
return
newQuantity
>
=
limit
;
}
MaybeStackVector
<
Measure
>
ComplexUnitsConverter
:
:
convert
(
double
quantity
icu
:
:
number
:
:
impl
:
:
RoundingImpl
*
rounder
UErrorCode
&
status
)
const
{
MaybeStackVector
<
Measure
>
result
;
int
sign
=
1
;
if
(
quantity
<
0
)
{
quantity
*
=
-
1
;
sign
=
-
1
;
}
MaybeStackArray
<
int64_t
5
>
intValues
(
unitConverters_
.
length
(
)
-
1
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
result
;
}
uprv_memset
(
intValues
.
getAlias
(
)
0
(
unitConverters_
.
length
(
)
-
1
)
*
sizeof
(
int64_t
)
)
;
for
(
int
i
=
0
n
=
unitConverters_
.
length
(
)
;
i
<
n
;
+
+
i
)
{
quantity
=
(
*
unitConverters_
[
i
]
)
.
convert
(
quantity
)
;
if
(
i
<
n
-
1
)
{
int64_t
roundedQuantity
=
floor
(
quantity
*
(
1
+
DBL_EPSILON
)
)
;
intValues
[
i
]
=
roundedQuantity
;
if
(
(
quantity
-
roundedQuantity
)
/
quantity
<
DBL_EPSILON
)
{
quantity
=
0
;
}
else
{
quantity
-
=
roundedQuantity
;
}
}
else
{
if
(
rounder
=
=
nullptr
)
{
break
;
}
number
:
:
impl
:
:
DecimalQuantity
quant
;
quant
.
setToDouble
(
quantity
)
;
rounder
-
>
apply
(
quant
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
result
;
}
quantity
=
quant
.
toDouble
(
)
;
if
(
i
=
=
0
)
{
break
;
}
int64_t
carry
=
floor
(
unitConverters_
[
i
]
-
>
convertInverse
(
quantity
)
*
(
1
+
DBL_EPSILON
)
)
;
if
(
carry
<
=
0
)
{
break
;
}
quantity
-
=
unitConverters_
[
i
]
-
>
convert
(
carry
)
;
intValues
[
i
-
1
]
+
=
carry
;
for
(
int32_t
j
=
i
-
1
;
j
>
0
;
j
-
-
)
{
carry
=
floor
(
unitConverters_
[
j
]
-
>
convertInverse
(
intValues
[
j
]
)
*
(
1
+
DBL_EPSILON
)
)
;
if
(
carry
<
=
0
)
{
break
;
}
intValues
[
j
]
-
=
round
(
unitConverters_
[
j
]
-
>
convert
(
carry
)
)
;
intValues
[
j
-
1
]
+
=
carry
;
}
}
}
for
(
int
i
=
0
n
=
unitConverters_
.
length
(
)
;
i
<
n
;
+
+
i
)
{
if
(
i
<
n
-
1
)
{
Formattable
formattableQuantity
(
intValues
[
i
]
*
sign
)
;
MeasureUnit
*
type
=
new
MeasureUnit
(
units_
[
i
]
-
>
copy
(
status
)
.
build
(
status
)
)
;
if
(
result
.
emplaceBackAndCheckErrorCode
(
status
formattableQuantity
type
status
)
=
=
nullptr
)
{
U_ASSERT
(
U_FAILURE
(
status
)
)
;
delete
type
;
}
if
(
U_FAILURE
(
status
)
)
{
return
result
;
}
}
else
{
Formattable
formattableQuantity
(
quantity
*
sign
)
;
MeasureUnit
*
type
=
new
MeasureUnit
(
units_
[
i
]
-
>
copy
(
status
)
.
build
(
status
)
)
;
if
(
result
.
emplaceBackAndCheckErrorCode
(
status
formattableQuantity
type
status
)
=
=
nullptr
)
{
U_ASSERT
(
U_FAILURE
(
status
)
)
;
delete
type
;
}
if
(
U_FAILURE
(
status
)
)
{
return
result
;
}
U_ASSERT
(
result
.
length
(
)
=
=
i
+
1
)
;
U_ASSERT
(
result
[
i
]
!
=
nullptr
)
;
}
}
MaybeStackVector
<
Measure
>
orderedResult
;
int32_t
unitsCount
=
outputUnits_
.
length
(
)
;
U_ASSERT
(
unitsCount
=
=
units_
.
length
(
)
)
;
Measure
*
*
arr
=
result
.
getAlias
(
)
;
for
(
int32_t
i
=
0
;
i
<
unitsCount
;
i
+
+
)
{
for
(
int32_t
j
=
i
;
j
<
unitsCount
;
j
+
+
)
{
U_ASSERT
(
result
[
j
]
!
=
nullptr
)
;
if
(
result
[
j
]
-
>
getUnit
(
)
=
=
*
outputUnits_
[
i
]
)
{
if
(
j
!
=
i
)
{
Measure
*
tmp
=
arr
[
j
]
;
arr
[
j
]
=
arr
[
i
]
;
arr
[
i
]
=
tmp
;
}
}
}
}
return
result
;
}
}
U_NAMESPACE_END
#
endif
