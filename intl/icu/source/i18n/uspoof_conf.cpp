#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
uspoof
.
h
"
#
if
!
UCONFIG_NO_REGULAR_EXPRESSIONS
#
if
!
UCONFIG_NO_NORMALIZATION
#
include
"
unicode
/
unorm
.
h
"
#
include
"
unicode
/
uregex
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
uspoof_impl
.
h
"
#
include
"
uhash
.
h
"
#
include
"
uvector
.
h
"
#
include
"
uassert
.
h
"
#
include
"
uarrsort
.
h
"
#
include
"
uspoof_conf
.
h
"
U_NAMESPACE_USE
SPUString
:
:
SPUString
(
LocalPointer
<
UnicodeString
>
s
)
{
fStr
=
std
:
:
move
(
s
)
;
fCharOrStrTableIndex
=
0
;
}
SPUString
:
:
~
SPUString
(
)
{
}
SPUStringPool
:
:
SPUStringPool
(
UErrorCode
&
status
)
:
fVec
(
nullptr
)
fHash
(
nullptr
)
{
LocalPointer
<
UVector
>
vec
(
new
UVector
(
status
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
vec
-
>
setDeleter
(
[
]
(
void
*
obj
)
{
delete
(
SPUString
*
)
obj
;
}
)
;
fVec
=
vec
.
orphan
(
)
;
fHash
=
uhash_open
(
uhash_hashUnicodeString
uhash_compareUnicodeString
nullptr
&
status
)
;
}
SPUStringPool
:
:
~
SPUStringPool
(
)
{
delete
fVec
;
uhash_close
(
fHash
)
;
}
int32_t
SPUStringPool
:
:
size
(
)
{
return
fVec
-
>
size
(
)
;
}
SPUString
*
SPUStringPool
:
:
getByIndex
(
int32_t
index
)
{
SPUString
*
retString
=
(
SPUString
*
)
fVec
-
>
elementAt
(
index
)
;
return
retString
;
}
static
int32_t
U_CALLCONV
SPUStringCompare
(
UHashTok
left
UHashTok
right
)
{
const
SPUString
*
sL
=
const_cast
<
const
SPUString
*
>
(
static_cast
<
SPUString
*
>
(
left
.
pointer
)
)
;
const
SPUString
*
sR
=
const_cast
<
const
SPUString
*
>
(
static_cast
<
SPUString
*
>
(
right
.
pointer
)
)
;
int32_t
lenL
=
sL
-
>
fStr
-
>
length
(
)
;
int32_t
lenR
=
sR
-
>
fStr
-
>
length
(
)
;
if
(
lenL
<
lenR
)
{
return
-
1
;
}
else
if
(
lenL
>
lenR
)
{
return
1
;
}
else
{
return
sL
-
>
fStr
-
>
compare
(
*
(
sR
-
>
fStr
)
)
;
}
}
void
SPUStringPool
:
:
sort
(
UErrorCode
&
status
)
{
fVec
-
>
sort
(
SPUStringCompare
status
)
;
}
SPUString
*
SPUStringPool
:
:
addString
(
UnicodeString
*
src
UErrorCode
&
status
)
{
LocalPointer
<
UnicodeString
>
lpSrc
(
src
)
;
if
(
U_FAILURE
(
status
)
)
{
return
nullptr
;
}
SPUString
*
hashedString
=
static_cast
<
SPUString
*
>
(
uhash_get
(
fHash
src
)
)
;
if
(
hashedString
!
=
nullptr
)
{
return
hashedString
;
}
LocalPointer
<
SPUString
>
spuStr
(
new
SPUString
(
std
:
:
move
(
lpSrc
)
)
status
)
;
hashedString
=
spuStr
.
getAlias
(
)
;
fVec
-
>
adoptElement
(
spuStr
.
orphan
(
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
nullptr
;
}
uhash_put
(
fHash
src
hashedString
&
status
)
;
return
hashedString
;
}
ConfusabledataBuilder
:
:
ConfusabledataBuilder
(
SpoofImpl
*
spImpl
UErrorCode
&
status
)
:
fSpoofImpl
(
spImpl
)
fInput
(
nullptr
)
fTable
(
nullptr
)
fKeySet
(
nullptr
)
fKeyVec
(
nullptr
)
fValueVec
(
nullptr
)
fStringTable
(
nullptr
)
stringPool
(
nullptr
)
fParseLine
(
nullptr
)
fParseHexNum
(
nullptr
)
fLineNum
(
0
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
fTable
=
uhash_open
(
uhash_hashLong
uhash_compareLong
nullptr
&
status
)
;
fKeySet
=
new
UnicodeSet
(
)
;
if
(
fKeySet
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
fKeyVec
=
new
UVector
(
status
)
;
if
(
fKeyVec
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
fValueVec
=
new
UVector
(
status
)
;
if
(
fValueVec
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
stringPool
=
new
SPUStringPool
(
status
)
;
if
(
stringPool
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
}
ConfusabledataBuilder
:
:
~
ConfusabledataBuilder
(
)
{
uprv_free
(
fInput
)
;
uregex_close
(
fParseLine
)
;
uregex_close
(
fParseHexNum
)
;
uhash_close
(
fTable
)
;
delete
fKeySet
;
delete
fKeyVec
;
delete
fStringTable
;
delete
fValueVec
;
delete
stringPool
;
}
void
ConfusabledataBuilder
:
:
buildConfusableData
(
SpoofImpl
*
spImpl
const
char
*
confusables
int32_t
confusablesLen
int32_t
*
errorType
UParseError
*
pe
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
ConfusabledataBuilder
builder
(
spImpl
status
)
;
builder
.
build
(
confusables
confusablesLen
status
)
;
if
(
U_FAILURE
(
status
)
&
&
errorType
!
=
nullptr
)
{
*
errorType
=
USPOOF_SINGLE_SCRIPT_CONFUSABLE
;
pe
-
>
line
=
builder
.
fLineNum
;
}
}
void
ConfusabledataBuilder
:
:
build
(
const
char
*
confusables
int32_t
confusablesLen
UErrorCode
&
status
)
{
int32_t
inputLen
=
0
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
u_strFromUTF8
(
nullptr
0
&
inputLen
confusables
confusablesLen
&
status
)
;
if
(
status
!
=
U_BUFFER_OVERFLOW_ERROR
)
{
return
;
}
status
=
U_ZERO_ERROR
;
fInput
=
static_cast
<
char16_t
*
>
(
uprv_malloc
(
(
inputLen
+
1
)
*
sizeof
(
char16_t
)
)
)
;
if
(
fInput
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
u_strFromUTF8
(
fInput
inputLen
+
1
nullptr
confusables
confusablesLen
&
status
)
;
UnicodeString
pattern
(
"
(
?
m
)
^
[
\
\
t
]
*
(
[
0
-
9A
-
Fa
-
f
]
+
)
[
\
\
t
]
+
;
"
"
[
\
\
t
]
*
(
[
0
-
9A
-
Fa
-
f
]
+
"
"
(
?
:
[
\
\
t
]
+
[
0
-
9A
-
Fa
-
f
]
+
)
*
)
[
\
\
t
]
*
;
"
"
\
\
s
*
(
?
:
(
SL
)
|
(
SA
)
|
(
ML
)
|
(
MA
)
)
"
"
[
\
\
t
]
*
(
?
:
#
.
*
?
)
?
"
"
|
^
(
[
\
\
t
]
*
(
?
:
#
.
*
?
)
?
)
"
"
|
^
(
.
*
?
)
"
-
1
US_INV
)
;
fParseLine
=
uregex_open
(
pattern
.
getBuffer
(
)
pattern
.
length
(
)
0
nullptr
&
status
)
;
pattern
=
UNICODE_STRING_SIMPLE
(
"
\
\
s
*
(
[
0
-
9A
-
F
]
+
)
"
)
;
fParseHexNum
=
uregex_open
(
pattern
.
getBuffer
(
)
pattern
.
length
(
)
0
nullptr
&
status
)
;
if
(
*
fInput
=
=
0xfeff
)
{
*
fInput
=
0x20
;
}
uregex_setText
(
fParseLine
fInput
inputLen
&
status
)
;
while
(
uregex_findNext
(
fParseLine
&
status
)
)
{
fLineNum
+
+
;
if
(
uregex_start
(
fParseLine
7
&
status
)
>
=
0
)
{
continue
;
}
if
(
uregex_start
(
fParseLine
8
&
status
)
>
=
0
)
{
status
=
U_PARSE_ERROR
;
return
;
}
UChar32
keyChar
=
SpoofImpl
:
:
ScanHex
(
fInput
uregex_start
(
fParseLine
1
&
status
)
uregex_end
(
fParseLine
1
&
status
)
status
)
;
int32_t
mapStringStart
=
uregex_start
(
fParseLine
2
&
status
)
;
int32_t
mapStringLength
=
uregex_end
(
fParseLine
2
&
status
)
-
mapStringStart
;
uregex_setText
(
fParseHexNum
&
fInput
[
mapStringStart
]
mapStringLength
&
status
)
;
UnicodeString
*
mapString
=
new
UnicodeString
(
)
;
if
(
mapString
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
while
(
uregex_findNext
(
fParseHexNum
&
status
)
)
{
UChar32
c
=
SpoofImpl
:
:
ScanHex
(
&
fInput
[
mapStringStart
]
uregex_start
(
fParseHexNum
1
&
status
)
uregex_end
(
fParseHexNum
1
&
status
)
status
)
;
mapString
-
>
append
(
c
)
;
}
U_ASSERT
(
mapString
-
>
length
(
)
>
=
1
)
;
SPUString
*
smapString
=
stringPool
-
>
addString
(
mapString
status
)
;
uhash_iput
(
fTable
keyChar
smapString
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
fKeySet
-
>
add
(
keyChar
)
;
}
stringPool
-
>
sort
(
status
)
;
fStringTable
=
new
UnicodeString
(
)
;
int32_t
poolSize
=
stringPool
-
>
size
(
)
;
int32_t
i
;
for
(
i
=
0
;
i
<
poolSize
;
i
+
+
)
{
SPUString
*
s
=
stringPool
-
>
getByIndex
(
i
)
;
int32_t
strLen
=
s
-
>
fStr
-
>
length
(
)
;
int32_t
strIndex
=
fStringTable
-
>
length
(
)
;
if
(
strLen
=
=
1
)
{
s
-
>
fCharOrStrTableIndex
=
s
-
>
fStr
-
>
charAt
(
0
)
;
}
else
{
s
-
>
fCharOrStrTableIndex
=
strIndex
;
fStringTable
-
>
append
(
*
(
s
-
>
fStr
)
)
;
}
}
for
(
int32_t
range
=
0
;
range
<
fKeySet
-
>
getRangeCount
(
)
;
range
+
+
)
{
for
(
UChar32
keyChar
=
fKeySet
-
>
getRangeStart
(
range
)
;
keyChar
<
=
fKeySet
-
>
getRangeEnd
(
range
)
;
keyChar
+
+
)
{
SPUString
*
targetMapping
=
static_cast
<
SPUString
*
>
(
uhash_iget
(
fTable
keyChar
)
)
;
U_ASSERT
(
targetMapping
!
=
nullptr
)
;
if
(
targetMapping
-
>
fStr
-
>
length
(
)
>
256
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
int32_t
key
=
ConfusableDataUtils
:
:
codePointAndLengthToKey
(
keyChar
targetMapping
-
>
fStr
-
>
length
(
)
)
;
int32_t
value
=
targetMapping
-
>
fCharOrStrTableIndex
;
fKeyVec
-
>
addElement
(
key
status
)
;
fValueVec
-
>
addElement
(
value
status
)
;
}
}
outputData
(
status
)
;
return
;
}
void
ConfusabledataBuilder
:
:
outputData
(
UErrorCode
&
status
)
{
U_ASSERT
(
fSpoofImpl
-
>
fSpoofData
-
>
fDataOwned
)
;
int32_t
numKeys
=
fKeyVec
-
>
size
(
)
;
int32_t
*
keys
=
static_cast
<
int32_t
*
>
(
fSpoofImpl
-
>
fSpoofData
-
>
reserveSpace
(
numKeys
*
sizeof
(
int32_t
)
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
int
i
;
UChar32
previousCodePoint
=
0
;
for
(
i
=
0
;
i
<
numKeys
;
i
+
+
)
{
int32_t
key
=
fKeyVec
-
>
elementAti
(
i
)
;
UChar32
codePoint
=
ConfusableDataUtils
:
:
keyToCodePoint
(
key
)
;
(
void
)
previousCodePoint
;
U_ASSERT
(
codePoint
>
previousCodePoint
)
;
keys
[
i
]
=
key
;
previousCodePoint
=
codePoint
;
}
SpoofDataHeader
*
rawData
=
fSpoofImpl
-
>
fSpoofData
-
>
fRawData
;
rawData
-
>
fCFUKeys
=
(
int32_t
)
(
(
char
*
)
keys
-
(
char
*
)
rawData
)
;
rawData
-
>
fCFUKeysSize
=
numKeys
;
fSpoofImpl
-
>
fSpoofData
-
>
fCFUKeys
=
keys
;
int32_t
numValues
=
fValueVec
-
>
size
(
)
;
U_ASSERT
(
numKeys
=
=
numValues
)
;
uint16_t
*
values
=
static_cast
<
uint16_t
*
>
(
fSpoofImpl
-
>
fSpoofData
-
>
reserveSpace
(
numKeys
*
sizeof
(
uint16_t
)
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
for
(
i
=
0
;
i
<
numValues
;
i
+
+
)
{
uint32_t
value
=
static_cast
<
uint32_t
>
(
fValueVec
-
>
elementAti
(
i
)
)
;
U_ASSERT
(
value
<
0xffff
)
;
values
[
i
]
=
static_cast
<
uint16_t
>
(
value
)
;
}
rawData
=
fSpoofImpl
-
>
fSpoofData
-
>
fRawData
;
rawData
-
>
fCFUStringIndex
=
(
int32_t
)
(
(
char
*
)
values
-
(
char
*
)
rawData
)
;
rawData
-
>
fCFUStringIndexSize
=
numValues
;
fSpoofImpl
-
>
fSpoofData
-
>
fCFUValues
=
values
;
uint32_t
stringsLength
=
fStringTable
-
>
length
(
)
;
char16_t
*
strings
=
static_cast
<
char16_t
*
>
(
fSpoofImpl
-
>
fSpoofData
-
>
reserveSpace
(
stringsLength
*
sizeof
(
char16_t
)
+
2
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
fStringTable
-
>
extract
(
strings
stringsLength
+
1
status
)
;
rawData
=
fSpoofImpl
-
>
fSpoofData
-
>
fRawData
;
U_ASSERT
(
rawData
-
>
fCFUStringTable
=
=
0
)
;
rawData
-
>
fCFUStringTable
=
(
int32_t
)
(
(
char
*
)
strings
-
(
char
*
)
rawData
)
;
rawData
-
>
fCFUStringTableLen
=
stringsLength
;
fSpoofImpl
-
>
fSpoofData
-
>
fCFUStrings
=
strings
;
}
#
endif
#
endif
