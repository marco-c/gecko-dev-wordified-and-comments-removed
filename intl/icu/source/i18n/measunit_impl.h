#
ifndef
__MEASUNIT_IMPL_H__
#
define
__MEASUNIT_IMPL_H__
#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
measunit
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
charstr
.
h
"
U_NAMESPACE_BEGIN
static
const
char16_t
kDefaultCurrency
[
]
=
u
"
XXX
"
;
static
const
char
kDefaultCurrency8
[
]
=
"
XXX
"
;
struct
U_I18N_API
SingleUnitImpl
:
public
UMemory
{
static
SingleUnitImpl
forMeasureUnit
(
const
MeasureUnit
&
measureUnit
UErrorCode
&
status
)
;
MeasureUnit
build
(
UErrorCode
&
status
)
const
;
const
char
*
getSimpleUnitID
(
)
const
;
int32_t
compareTo
(
const
SingleUnitImpl
&
other
)
const
{
if
(
dimensionality
<
0
&
&
other
.
dimensionality
>
0
)
{
return
1
;
}
if
(
dimensionality
>
0
&
&
other
.
dimensionality
<
0
)
{
return
-
1
;
}
if
(
index
<
other
.
index
)
{
return
-
1
;
}
if
(
index
>
other
.
index
)
{
return
1
;
}
if
(
siPrefix
<
other
.
siPrefix
)
{
return
-
1
;
}
if
(
siPrefix
>
other
.
siPrefix
)
{
return
1
;
}
return
0
;
}
bool
isCompatibleWith
(
const
SingleUnitImpl
&
other
)
const
{
return
(
compareTo
(
other
)
=
=
0
)
;
}
bool
isDimensionless
(
)
const
{
return
index
=
=
-
1
;
}
int32_t
index
=
-
1
;
UMeasureSIPrefix
siPrefix
=
UMEASURE_SI_PREFIX_ONE
;
int32_t
dimensionality
=
1
;
}
;
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
MaybeStackArray
<
SingleUnitImpl
*
8
>
;
template
class
U_I18N_API
MemoryPool
<
SingleUnitImpl
8
>
;
template
class
U_I18N_API
MaybeStackVector
<
SingleUnitImpl
8
>
;
#
endif
struct
U_I18N_API
MeasureUnitImpl
:
public
UMemory
{
MeasureUnitImpl
(
)
=
default
;
MeasureUnitImpl
(
MeasureUnitImpl
&
&
other
)
=
default
;
MeasureUnitImpl
(
const
MeasureUnitImpl
&
other
UErrorCode
&
status
)
;
MeasureUnitImpl
(
const
SingleUnitImpl
&
singleUnit
UErrorCode
&
status
)
;
MeasureUnitImpl
&
operator
=
(
MeasureUnitImpl
&
&
other
)
noexcept
=
default
;
static
inline
const
MeasureUnitImpl
*
get
(
const
MeasureUnit
&
measureUnit
)
{
return
measureUnit
.
fImpl
;
}
static
MeasureUnitImpl
forIdentifier
(
StringPiece
identifier
UErrorCode
&
status
)
;
static
const
MeasureUnitImpl
&
forMeasureUnit
(
const
MeasureUnit
&
measureUnit
MeasureUnitImpl
&
memory
UErrorCode
&
status
)
;
static
MeasureUnitImpl
forMeasureUnitMaybeCopy
(
const
MeasureUnit
&
measureUnit
UErrorCode
&
status
)
;
static
inline
MeasureUnitImpl
forCurrencyCode
(
StringPiece
currencyCode
)
{
MeasureUnitImpl
result
;
UErrorCode
localStatus
=
U_ZERO_ERROR
;
result
.
identifier
.
append
(
currencyCode
localStatus
)
;
return
result
;
}
MeasureUnit
build
(
UErrorCode
&
status
)
&
&
;
MeasureUnitImpl
copy
(
UErrorCode
&
status
)
const
;
MaybeStackVector
<
MeasureUnitImpl
>
extractIndividualUnits
(
UErrorCode
&
status
)
const
;
void
takeReciprocal
(
UErrorCode
&
status
)
;
bool
append
(
const
SingleUnitImpl
&
singleUnit
UErrorCode
&
status
)
;
UMeasureUnitComplexity
complexity
=
UMEASURE_UNIT_SINGLE
;
MaybeStackVector
<
SingleUnitImpl
>
units
;
CharString
identifier
;
}
;
U_NAMESPACE_END
#
endif
#
endif
