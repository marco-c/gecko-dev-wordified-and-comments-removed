#
ifndef
__MEASUNIT_IMPL_H__
#
define
__MEASUNIT_IMPL_H__
#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
measunit
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
charstr
.
h
"
U_NAMESPACE_BEGIN
static
const
char16_t
kDefaultCurrency
[
]
=
u
"
XXX
"
;
static
const
char
kDefaultCurrency8
[
]
=
"
XXX
"
;
struct
SingleUnitImpl
:
public
UMemory
{
static
SingleUnitImpl
forMeasureUnit
(
const
MeasureUnit
&
measureUnit
UErrorCode
&
status
)
;
MeasureUnit
build
(
UErrorCode
&
status
)
const
;
int32_t
compareTo
(
const
SingleUnitImpl
&
other
)
const
{
if
(
dimensionality
<
0
&
&
other
.
dimensionality
>
0
)
{
return
1
;
}
if
(
dimensionality
>
0
&
&
other
.
dimensionality
<
0
)
{
return
-
1
;
}
if
(
index
<
other
.
index
)
{
return
-
1
;
}
if
(
index
>
other
.
index
)
{
return
1
;
}
if
(
siPrefix
<
other
.
siPrefix
)
{
return
-
1
;
}
if
(
siPrefix
>
other
.
siPrefix
)
{
return
1
;
}
return
0
;
}
bool
isCompatibleWith
(
const
SingleUnitImpl
&
other
)
const
{
return
(
compareTo
(
other
)
=
=
0
)
;
}
bool
isDimensionless
(
)
const
{
return
index
=
=
-
1
;
}
int32_t
index
=
-
1
;
UMeasureSIPrefix
siPrefix
=
UMEASURE_SI_PREFIX_ONE
;
int32_t
dimensionality
=
1
;
}
;
struct
MeasureUnitImpl
:
public
UMemory
{
static
inline
const
MeasureUnitImpl
*
get
(
const
MeasureUnit
&
measureUnit
)
{
return
measureUnit
.
fImpl
;
}
static
MeasureUnitImpl
forIdentifier
(
StringPiece
identifier
UErrorCode
&
status
)
;
static
const
MeasureUnitImpl
&
forMeasureUnit
(
const
MeasureUnit
&
measureUnit
MeasureUnitImpl
&
memory
UErrorCode
&
status
)
;
static
MeasureUnitImpl
forMeasureUnitMaybeCopy
(
const
MeasureUnit
&
measureUnit
UErrorCode
&
status
)
;
static
inline
MeasureUnitImpl
forCurrencyCode
(
StringPiece
currencyCode
)
{
MeasureUnitImpl
result
;
UErrorCode
localStatus
=
U_ZERO_ERROR
;
result
.
identifier
.
append
(
currencyCode
localStatus
)
;
return
result
;
}
MeasureUnit
build
(
UErrorCode
&
status
)
&
&
;
inline
MeasureUnitImpl
copy
(
UErrorCode
&
status
)
const
{
MeasureUnitImpl
result
;
result
.
complexity
=
complexity
;
result
.
units
.
appendAll
(
units
status
)
;
result
.
identifier
.
append
(
identifier
status
)
;
return
result
;
}
void
takeReciprocal
(
UErrorCode
&
status
)
;
bool
append
(
const
SingleUnitImpl
&
singleUnit
UErrorCode
&
status
)
;
UMeasureUnitComplexity
complexity
=
UMEASURE_UNIT_SINGLE
;
MaybeStackVector
<
SingleUnitImpl
>
units
;
CharString
identifier
;
}
;
U_NAMESPACE_END
#
endif
#
endif
