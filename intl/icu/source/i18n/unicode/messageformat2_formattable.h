#
include
"
unicode
/
utypes
.
h
"
#
ifndef
MESSAGEFORMAT2_FORMATTABLE_H
#
define
MESSAGEFORMAT2_FORMATTABLE_H
#
if
U_SHOW_CPLUSPLUS_API
#
if
!
UCONFIG_NO_FORMATTING
#
if
!
UCONFIG_NO_MF2
#
include
"
unicode
/
chariter
.
h
"
#
include
"
unicode
/
numberformatter
.
h
"
#
include
"
unicode
/
messageformat2_data_model_names
.
h
"
#
ifndef
U_HIDE_DEPRECATED_API
#
include
<
map
>
#
include
<
variant
>
U_NAMESPACE_BEGIN
class
Hashtable
;
class
UVector
;
namespace
message2
{
class
Formatter
;
class
MessageContext
;
class
Selector
;
class
U_I18N_API
FormattableObject
:
public
UObject
{
public
:
virtual
const
UnicodeString
&
tag
(
)
const
=
0
;
virtual
~
FormattableObject
(
)
;
}
;
class
Formattable
;
}
U_NAMESPACE_END
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
#
if
defined
(
U_REAL_MSVC
)
&
&
defined
(
_MSVC_STL_VERSION
)
template
class
U_I18N_API
std
:
:
_Variant_storage_
<
false
double
int64_t
icu
:
:
UnicodeString
icu
:
:
Formattable
const
icu
:
:
message2
:
:
FormattableObject
*
std
:
:
pair
<
const
icu
:
:
message2
:
:
Formattable
*
int32_t
>
>
;
#
endif
typedef
std
:
:
pair
<
const
icu
:
:
message2
:
:
Formattable
*
int32_t
>
P
;
template
class
U_I18N_API
std
:
:
variant
<
double
int64_t
icu
:
:
UnicodeString
icu
:
:
Formattable
const
icu
:
:
message2
:
:
FormattableObject
*
P
>
;
#
endif
U_NAMESPACE_BEGIN
namespace
message2
{
class
U_I18N_API
Formattable
:
public
UObject
{
public
:
UFormattableType
getType
(
)
const
;
double
getDouble
(
UErrorCode
&
status
)
const
{
if
(
U_SUCCESS
(
status
)
)
{
if
(
isDecimal
(
)
&
&
getType
(
)
=
=
UFMT_DOUBLE
)
{
return
(
std
:
:
get_if
<
icu
:
:
Formattable
>
(
&
contents
)
)
-
>
getDouble
(
)
;
}
if
(
std
:
:
holds_alternative
<
double
>
(
contents
)
)
{
return
*
(
std
:
:
get_if
<
double
>
(
&
contents
)
)
;
}
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
0
;
}
int32_t
getLong
(
UErrorCode
&
status
)
const
{
if
(
U_SUCCESS
(
status
)
)
{
if
(
isDecimal
(
)
&
&
getType
(
)
=
=
UFMT_LONG
)
{
return
std
:
:
get_if
<
icu
:
:
Formattable
>
(
&
contents
)
-
>
getLong
(
)
;
}
if
(
std
:
:
holds_alternative
<
int64_t
>
(
contents
)
)
{
return
static_cast
<
int32_t
>
(
*
(
std
:
:
get_if
<
int64_t
>
(
&
contents
)
)
)
;
}
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
0
;
}
int64_t
getInt64Value
(
UErrorCode
&
status
)
const
{
if
(
U_SUCCESS
(
status
)
)
{
if
(
isDecimal
(
)
&
&
getType
(
)
=
=
UFMT_INT64
)
{
return
std
:
:
get_if
<
icu
:
:
Formattable
>
(
&
contents
)
-
>
getInt64
(
)
;
}
if
(
std
:
:
holds_alternative
<
int64_t
>
(
contents
)
)
{
return
*
(
std
:
:
get_if
<
int64_t
>
(
&
contents
)
)
;
}
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
0
;
}
int64_t
getInt64
(
UErrorCode
&
status
)
const
;
const
UnicodeString
&
getString
(
UErrorCode
&
status
)
const
{
if
(
U_SUCCESS
(
status
)
)
{
if
(
std
:
:
holds_alternative
<
UnicodeString
>
(
contents
)
)
{
return
*
std
:
:
get_if
<
UnicodeString
>
(
&
contents
)
;
}
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
bogusString
;
}
UDate
getDate
(
UErrorCode
&
status
)
const
{
if
(
U_SUCCESS
(
status
)
)
{
if
(
isDate
(
)
)
{
return
*
std
:
:
get_if
<
double
>
(
&
contents
)
;
}
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
0
;
}
UBool
isNumeric
(
)
const
{
return
(
getType
(
)
=
=
UFMT_DOUBLE
|
|
getType
(
)
=
=
UFMT_LONG
|
|
getType
(
)
=
=
UFMT_INT64
)
;
}
const
Formattable
*
getArray
(
int32_t
&
count
UErrorCode
&
status
)
const
;
const
FormattableObject
*
getObject
(
UErrorCode
&
status
)
const
{
if
(
U_SUCCESS
(
status
)
)
{
if
(
getType
(
)
=
=
UFMT_OBJECT
)
{
return
*
std
:
:
get_if
<
const
FormattableObject
*
>
(
&
contents
)
;
}
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
nullptr
;
}
friend
inline
void
swap
(
Formattable
&
f1
Formattable
&
f2
)
noexcept
{
using
std
:
:
swap
;
swap
(
f1
.
contents
f2
.
contents
)
;
swap
(
f1
.
holdsDate
f2
.
holdsDate
)
;
}
Formattable
(
const
Formattable
&
)
;
Formattable
&
operator
=
(
Formattable
)
noexcept
;
Formattable
(
)
:
contents
(
0
.
0
)
{
}
Formattable
(
const
UnicodeString
&
s
)
:
contents
(
s
)
{
}
Formattable
(
double
d
)
:
contents
(
d
)
{
}
Formattable
(
int64_t
i
)
:
contents
(
i
)
{
}
static
Formattable
forDate
(
UDate
d
)
{
Formattable
f
;
f
.
contents
=
d
;
f
.
holdsDate
=
true
;
return
f
;
}
static
Formattable
forDecimal
(
std
:
:
string_view
number
UErrorCode
&
status
)
;
Formattable
(
const
Formattable
*
arr
int32_t
len
)
:
contents
(
std
:
:
pair
(
arr
len
)
)
{
}
Formattable
(
const
FormattableObject
*
obj
)
:
contents
(
obj
)
{
}
virtual
~
Formattable
(
)
;
icu
:
:
Formattable
asICUFormattable
(
UErrorCode
&
status
)
const
;
private
:
std
:
:
variant
<
double
int64_t
UnicodeString
icu
:
:
Formattable
const
FormattableObject
*
std
:
:
pair
<
const
Formattable
*
int32_t
>
>
contents
;
bool
holdsDate
=
false
;
UnicodeString
bogusString
;
UBool
isDecimal
(
)
const
{
return
std
:
:
holds_alternative
<
icu
:
:
Formattable
>
(
contents
)
;
}
UBool
isDate
(
)
const
{
return
std
:
:
holds_alternative
<
double
>
(
contents
)
&
&
holdsDate
;
}
}
;
#
ifndef
U_IN_DOXYGEN
class
U_I18N_API
ResolvedFunctionOption
:
public
UObject
{
private
:
UnicodeString
name
;
Formattable
value
;
public
:
const
UnicodeString
&
getName
(
)
const
{
return
name
;
}
const
Formattable
&
getValue
(
)
const
{
return
value
;
}
ResolvedFunctionOption
(
const
UnicodeString
&
n
const
Formattable
&
f
)
:
name
(
n
)
value
(
f
)
{
}
ResolvedFunctionOption
(
)
{
}
ResolvedFunctionOption
(
ResolvedFunctionOption
&
&
)
;
ResolvedFunctionOption
&
operator
=
(
ResolvedFunctionOption
&
&
other
)
noexcept
{
name
=
std
:
:
move
(
other
.
name
)
;
value
=
std
:
:
move
(
other
.
value
)
;
return
*
this
;
}
virtual
~
ResolvedFunctionOption
(
)
;
}
;
#
endif
using
FunctionOptionsMap
=
std
:
:
map
<
UnicodeString
message2
:
:
Formattable
>
;
class
U_I18N_API
FunctionOptions
:
public
UObject
{
public
:
FunctionOptionsMap
getOptions
(
)
const
{
int32_t
len
;
const
ResolvedFunctionOption
*
resolvedOptions
=
getResolvedFunctionOptions
(
len
)
;
FunctionOptionsMap
result
;
for
(
int32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
const
ResolvedFunctionOption
&
opt
=
resolvedOptions
[
i
]
;
result
[
opt
.
getName
(
)
]
=
opt
.
getValue
(
)
;
}
return
result
;
}
FunctionOptions
(
)
{
options
=
nullptr
;
}
virtual
~
FunctionOptions
(
)
;
FunctionOptions
&
operator
=
(
FunctionOptions
&
&
)
noexcept
;
FunctionOptions
(
FunctionOptions
&
&
)
;
FunctionOptions
&
operator
=
(
const
FunctionOptions
&
)
=
delete
;
private
:
friend
class
MessageFormatter
;
friend
class
StandardFunctions
;
explicit
FunctionOptions
(
UVector
&
&
UErrorCode
&
)
;
const
ResolvedFunctionOption
*
getResolvedFunctionOptions
(
int32_t
&
len
)
const
;
UBool
getFunctionOption
(
const
UnicodeString
&
Formattable
&
)
const
;
UnicodeString
getStringFunctionOption
(
const
UnicodeString
&
)
const
;
int32_t
optionsCount
(
)
const
{
return
functionOptionsLen
;
}
ResolvedFunctionOption
*
options
;
int32_t
functionOptionsLen
=
0
;
}
;
class
U_I18N_API
FormattedValue
:
public
UObject
{
public
:
explicit
FormattedValue
(
const
UnicodeString
&
)
;
explicit
FormattedValue
(
number
:
:
FormattedNumber
&
&
)
;
FormattedValue
(
)
:
type
(
kString
)
{
}
bool
isString
(
)
const
{
return
type
=
=
kString
;
}
bool
isNumber
(
)
const
{
return
type
=
=
kNumber
;
}
const
UnicodeString
&
getString
(
)
const
{
return
stringOutput
;
}
const
number
:
:
FormattedNumber
&
getNumber
(
)
const
{
return
numberOutput
;
}
FormattedValue
&
operator
=
(
FormattedValue
&
&
)
noexcept
;
FormattedValue
(
FormattedValue
&
&
other
)
{
*
this
=
std
:
:
move
(
other
)
;
}
virtual
~
FormattedValue
(
)
;
private
:
enum
Type
{
kString
kNumber
}
;
Type
type
;
UnicodeString
stringOutput
;
number
:
:
FormattedNumber
numberOutput
;
}
;
class
U_I18N_API
FormattedPlaceholder
:
public
UObject
{
public
:
explicit
FormattedPlaceholder
(
const
UnicodeString
&
s
)
:
fallback
(
s
)
type
(
kFallback
)
{
}
FormattedPlaceholder
(
const
FormattedPlaceholder
&
input
FormattedValue
&
&
output
)
:
fallback
(
input
.
fallback
)
source
(
input
.
source
)
formatted
(
std
:
:
move
(
output
)
)
previousOptions
(
FunctionOptions
(
)
)
type
(
kEvaluated
)
{
}
FormattedPlaceholder
(
const
FormattedPlaceholder
&
input
FunctionOptions
&
&
opts
FormattedValue
&
&
output
)
:
fallback
(
input
.
fallback
)
source
(
input
.
source
)
formatted
(
std
:
:
move
(
output
)
)
previousOptions
(
std
:
:
move
(
opts
)
)
type
(
kEvaluated
)
{
}
FormattedPlaceholder
(
const
Formattable
&
input
const
UnicodeString
&
fb
)
:
fallback
(
fb
)
source
(
input
)
type
(
kUnevaluated
)
{
}
FormattedPlaceholder
(
)
:
type
(
kNull
)
{
}
const
message2
:
:
Formattable
&
asFormattable
(
)
const
;
bool
isFallback
(
)
const
{
return
type
=
=
kFallback
;
}
bool
isNullOperand
(
)
const
{
return
type
=
=
kNull
;
}
bool
isEvaluated
(
)
const
{
return
(
type
=
=
kEvaluated
)
;
}
bool
canFormat
(
)
const
{
return
!
(
isFallback
(
)
|
|
isNullOperand
(
)
)
;
}
const
UnicodeString
&
getFallback
(
)
const
{
return
fallback
;
}
const
FunctionOptions
&
options
(
)
const
{
return
previousOptions
;
}
const
FormattedValue
&
output
(
)
const
{
return
formatted
;
}
FormattedPlaceholder
&
operator
=
(
FormattedPlaceholder
&
&
)
noexcept
;
FormattedPlaceholder
(
FormattedPlaceholder
&
&
other
)
{
*
this
=
std
:
:
move
(
other
)
;
}
UnicodeString
formatToString
(
const
Locale
&
locale
UErrorCode
&
status
)
const
;
private
:
friend
class
MessageFormatter
;
enum
Type
{
kFallback
kNull
kUnevaluated
kEvaluated
}
;
UnicodeString
fallback
;
Formattable
source
;
FormattedValue
formatted
;
FunctionOptions
previousOptions
;
Type
type
;
}
;
class
U_I18N_API
FormattedMessage
:
public
icu
:
:
FormattedValue
{
public
:
FormattedMessage
(
UErrorCode
&
status
)
{
if
(
U_SUCCESS
(
status
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
}
}
int32_t
length
(
UErrorCode
&
status
)
const
{
if
(
U_SUCCESS
(
status
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
}
return
-
1
;
}
char16_t
charAt
(
int32_t
index
UErrorCode
&
status
)
const
{
(
void
)
index
;
if
(
U_SUCCESS
(
status
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
}
return
0
;
}
StringPiece
subSequence
(
int32_t
start
int32_t
end
UErrorCode
&
status
)
const
{
(
void
)
start
;
(
void
)
end
;
if
(
U_SUCCESS
(
status
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
}
return
"
"
;
}
UnicodeString
toString
(
UErrorCode
&
status
)
const
override
{
if
(
U_SUCCESS
(
status
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
}
return
{
}
;
}
UnicodeString
toTempString
(
UErrorCode
&
status
)
const
override
{
if
(
U_SUCCESS
(
status
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
}
return
{
}
;
}
Appendable
&
appendTo
(
Appendable
&
appendable
UErrorCode
&
status
)
const
override
{
if
(
U_SUCCESS
(
status
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
}
return
appendable
;
}
UBool
nextPosition
(
ConstrainedFieldPosition
&
cfpos
UErrorCode
&
status
)
const
override
{
(
void
)
cfpos
;
if
(
U_SUCCESS
(
status
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
}
return
false
;
}
CharacterIterator
*
toCharacterIterator
(
UErrorCode
&
status
)
{
if
(
U_SUCCESS
(
status
)
)
{
status
=
U_UNSUPPORTED_ERROR
;
}
return
nullptr
;
}
virtual
~
FormattedMessage
(
)
;
}
;
}
U_NAMESPACE_END
#
endif
#
endif
#
endif
#
endif
#
endif
