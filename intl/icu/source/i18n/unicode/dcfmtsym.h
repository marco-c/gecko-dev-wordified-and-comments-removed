#
ifndef
DCFMTSYM_H
#
define
DCFMTSYM_H
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
uchar
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
uobject
.
h
"
#
include
"
unicode
/
locid
.
h
"
#
include
"
unicode
/
numsys
.
h
"
#
include
"
unicode
/
unum
.
h
"
#
include
"
unicode
/
unistr
.
h
"
U_NAMESPACE_BEGIN
class
U_I18N_API
DecimalFormatSymbols
:
public
UObject
{
public
:
enum
ENumberFormatSymbol
{
kDecimalSeparatorSymbol
kGroupingSeparatorSymbol
kPatternSeparatorSymbol
kPercentSymbol
kZeroDigitSymbol
kDigitSymbol
kMinusSignSymbol
kPlusSignSymbol
kCurrencySymbol
kIntlCurrencySymbol
kMonetarySeparatorSymbol
kExponentialSymbol
kPerMillSymbol
kPadEscapeSymbol
kInfinitySymbol
kNaNSymbol
kSignificantDigitSymbol
kMonetaryGroupingSeparatorSymbol
kOneDigitSymbol
kTwoDigitSymbol
kThreeDigitSymbol
kFourDigitSymbol
kFiveDigitSymbol
kSixDigitSymbol
kSevenDigitSymbol
kEightDigitSymbol
kNineDigitSymbol
kExponentMultiplicationSymbol
kFormatSymbolCount
=
kNineDigitSymbol
+
2
}
;
DecimalFormatSymbols
(
const
Locale
&
locale
UErrorCode
&
status
)
;
#
ifndef
U_HIDE_DRAFT_API
DecimalFormatSymbols
(
const
Locale
&
locale
const
NumberingSystem
&
ns
UErrorCode
&
status
)
;
#
endif
DecimalFormatSymbols
(
UErrorCode
&
status
)
;
static
DecimalFormatSymbols
*
createWithLastResortData
(
UErrorCode
&
status
)
;
DecimalFormatSymbols
(
const
DecimalFormatSymbols
&
)
;
DecimalFormatSymbols
&
operator
=
(
const
DecimalFormatSymbols
&
)
;
virtual
~
DecimalFormatSymbols
(
)
;
UBool
operator
=
=
(
const
DecimalFormatSymbols
&
other
)
const
;
UBool
operator
!
=
(
const
DecimalFormatSymbols
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
inline
UnicodeString
getSymbol
(
ENumberFormatSymbol
symbol
)
const
;
void
setSymbol
(
ENumberFormatSymbol
symbol
const
UnicodeString
&
value
const
UBool
propogateDigits
)
;
inline
Locale
getLocale
(
)
const
;
Locale
getLocale
(
ULocDataLocaleType
type
UErrorCode
&
status
)
const
;
const
UnicodeString
&
getPatternForCurrencySpacing
(
UCurrencySpacing
type
UBool
beforeCurrency
UErrorCode
&
status
)
const
;
void
setPatternForCurrencySpacing
(
UCurrencySpacing
type
UBool
beforeCurrency
const
UnicodeString
&
pattern
)
;
virtual
UClassID
getDynamicClassID
(
)
const
;
static
UClassID
U_EXPORT2
getStaticClassID
(
)
;
private
:
DecimalFormatSymbols
(
)
;
void
initialize
(
const
Locale
&
locale
UErrorCode
&
success
UBool
useLastResortData
=
FALSE
const
NumberingSystem
*
ns
=
nullptr
)
;
void
initialize
(
)
;
void
setCurrencyForSymbols
(
)
;
public
:
#
ifndef
U_HIDE_INTERNAL_API
inline
UBool
isCustomCurrencySymbol
(
)
const
{
return
fIsCustomCurrencySymbol
;
}
inline
UBool
isCustomIntlCurrencySymbol
(
)
const
{
return
fIsCustomIntlCurrencySymbol
;
}
inline
UChar32
getCodePointZero
(
)
const
{
return
fCodePointZero
;
}
#
endif
inline
const
UnicodeString
&
getConstSymbol
(
ENumberFormatSymbol
symbol
)
const
;
#
ifndef
U_HIDE_INTERNAL_API
inline
const
UnicodeString
&
getConstDigitSymbol
(
int32_t
digit
)
const
;
inline
const
char16_t
*
getCurrencyPattern
(
void
)
const
;
#
endif
private
:
UnicodeString
fSymbols
[
kFormatSymbolCount
]
;
UnicodeString
fNoSymbol
;
UChar32
fCodePointZero
;
Locale
locale
;
char
actualLocale
[
ULOC_FULLNAME_CAPACITY
]
;
char
validLocale
[
ULOC_FULLNAME_CAPACITY
]
;
const
char16_t
*
currPattern
;
UnicodeString
currencySpcBeforeSym
[
UNUM_CURRENCY_SPACING_COUNT
]
;
UnicodeString
currencySpcAfterSym
[
UNUM_CURRENCY_SPACING_COUNT
]
;
UBool
fIsCustomCurrencySymbol
;
UBool
fIsCustomIntlCurrencySymbol
;
}
;
inline
UnicodeString
DecimalFormatSymbols
:
:
getSymbol
(
ENumberFormatSymbol
symbol
)
const
{
const
UnicodeString
*
strPtr
;
if
(
symbol
<
kFormatSymbolCount
)
{
strPtr
=
&
fSymbols
[
symbol
]
;
}
else
{
strPtr
=
&
fNoSymbol
;
}
return
*
strPtr
;
}
inline
const
UnicodeString
&
DecimalFormatSymbols
:
:
getConstSymbol
(
ENumberFormatSymbol
symbol
)
const
{
const
UnicodeString
*
strPtr
;
if
(
symbol
<
kFormatSymbolCount
)
{
strPtr
=
&
fSymbols
[
symbol
]
;
}
else
{
strPtr
=
&
fNoSymbol
;
}
return
*
strPtr
;
}
#
ifndef
U_HIDE_INTERNAL_API
inline
const
UnicodeString
&
DecimalFormatSymbols
:
:
getConstDigitSymbol
(
int32_t
digit
)
const
{
if
(
digit
<
0
|
|
digit
>
9
)
{
digit
=
0
;
}
if
(
digit
=
=
0
)
{
return
fSymbols
[
kZeroDigitSymbol
]
;
}
ENumberFormatSymbol
key
=
static_cast
<
ENumberFormatSymbol
>
(
kOneDigitSymbol
+
digit
-
1
)
;
return
fSymbols
[
key
]
;
}
#
endif
inline
void
DecimalFormatSymbols
:
:
setSymbol
(
ENumberFormatSymbol
symbol
const
UnicodeString
&
value
const
UBool
propogateDigits
=
TRUE
)
{
if
(
symbol
=
=
kCurrencySymbol
)
{
fIsCustomCurrencySymbol
=
TRUE
;
}
else
if
(
symbol
=
=
kIntlCurrencySymbol
)
{
fIsCustomIntlCurrencySymbol
=
TRUE
;
}
if
(
symbol
<
kFormatSymbolCount
)
{
fSymbols
[
symbol
]
=
value
;
}
if
(
symbol
=
=
kZeroDigitSymbol
)
{
UChar32
sym
=
value
.
char32At
(
0
)
;
if
(
propogateDigits
&
&
u_charDigitValue
(
sym
)
=
=
0
&
&
value
.
countChar32
(
)
=
=
1
)
{
fCodePointZero
=
sym
;
for
(
int8_t
i
=
1
;
i
<
=
9
;
i
+
+
)
{
sym
+
+
;
fSymbols
[
(
int
)
kOneDigitSymbol
+
i
-
1
]
=
UnicodeString
(
sym
)
;
}
}
else
{
fCodePointZero
=
-
1
;
}
}
else
if
(
symbol
>
=
kOneDigitSymbol
&
&
symbol
<
=
kNineDigitSymbol
)
{
fCodePointZero
=
-
1
;
}
}
inline
Locale
DecimalFormatSymbols
:
:
getLocale
(
)
const
{
return
locale
;
}
#
ifndef
U_HIDE_INTERNAL_API
inline
const
char16_t
*
DecimalFormatSymbols
:
:
getCurrencyPattern
(
)
const
{
return
currPattern
;
}
#
endif
U_NAMESPACE_END
#
endif
#
endif
