#
include
"
unicode
/
utypes
.
h
"
#
ifndef
MESSAGEFORMAT_DATA_MODEL_H
#
define
MESSAGEFORMAT_DATA_MODEL_H
#
if
U_SHOW_CPLUSPLUS_API
#
if
!
UCONFIG_NO_NORMALIZATION
#
if
!
UCONFIG_NO_FORMATTING
#
if
!
UCONFIG_NO_MF2
#
include
"
unicode
/
localpointer
.
h
"
#
include
"
unicode
/
messageformat2_data_model_names
.
h
"
#
ifndef
U_HIDE_DEPRECATED_API
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
iterator
>
#
include
<
optional
>
#
include
<
variant
>
#
include
<
vector
>
U_NAMESPACE_BEGIN
class
UVector
;
template
<
typename
T
>
static
inline
std
:
:
vector
<
T
>
toStdVector
(
const
T
*
arr
int32_t
len
)
{
std
:
:
vector
<
T
>
result
;
for
(
int32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
result
.
push_back
(
arr
[
i
]
)
;
}
return
result
;
}
#
if
defined
(
U_REAL_MSVC
)
#
pragma
warning
(
push
)
#
pragma
warning
(
disable
:
4251
)
#
endif
namespace
message2
{
class
Checker
;
class
MFDataModel
;
class
MessageFormatter
;
class
Parser
;
class
Serializer
;
namespace
data_model
{
class
Binding
;
class
Literal
;
class
Operator
;
class
U_I18N_API
Literal
:
public
UObject
{
public
:
UnicodeString
quoted
(
)
const
;
const
UnicodeString
&
unquoted
(
)
const
;
UBool
isQuoted
(
)
const
{
return
thisIsQuoted
;
}
Literal
(
UBool
q
const
UnicodeString
&
s
)
:
thisIsQuoted
(
q
)
contents
(
s
)
{
}
Literal
(
const
Literal
&
other
)
:
thisIsQuoted
(
other
.
thisIsQuoted
)
contents
(
other
.
contents
)
{
}
friend
inline
void
swap
(
Literal
&
l1
Literal
&
l2
)
noexcept
{
using
std
:
:
swap
;
swap
(
l1
.
thisIsQuoted
l2
.
thisIsQuoted
)
;
swap
(
l1
.
contents
l2
.
contents
)
;
}
Literal
&
operator
=
(
Literal
)
noexcept
;
Literal
(
)
=
default
;
bool
operator
<
(
const
Literal
&
other
)
const
;
bool
operator
=
=
(
const
Literal
&
other
)
const
;
virtual
~
Literal
(
)
;
private
:
bool
thisIsQuoted
=
false
;
UnicodeString
contents
;
}
;
}
}
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
LocalPointerBase
<
message2
:
:
data_model
:
:
Literal
>
;
template
class
U_I18N_API
LocalArray
<
message2
:
:
data_model
:
:
Literal
>
;
#
endif
#
if
defined
(
U_REAL_MSVC
)
#
pragma
warning
(
pop
)
#
endif
U_NAMESPACE_END
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
#
if
defined
(
U_REAL_MSVC
)
&
&
defined
(
_MSVC_STL_VERSION
)
struct
U_I18N_API
std
:
:
_Nontrivial_dummy_type
;
template
class
U_I18N_API
std
:
:
_Variant_storage_
<
false
icu
:
:
UnicodeString
icu
:
:
message2
:
:
data_model
:
:
Literal
>
;
#
endif
template
class
U_I18N_API
std
:
:
variant
<
icu
:
:
UnicodeString
icu
:
:
message2
:
:
data_model
:
:
Literal
>
;
template
class
U_I18N_API
std
:
:
optional
<
std
:
:
variant
<
icu
:
:
UnicodeString
icu
:
:
message2
:
:
data_model
:
:
Literal
>
>
;
template
class
U_I18N_API
std
:
:
optional
<
icu
:
:
message2
:
:
data_model
:
:
Literal
>
;
#
endif
U_NAMESPACE_BEGIN
namespace
message2
{
namespace
data_model
{
class
U_I18N_API
Operand
:
public
UObject
{
public
:
UBool
isVariable
(
)
const
;
UBool
isLiteral
(
)
const
;
virtual
UBool
isNull
(
)
const
;
const
UnicodeString
&
asVariable
(
)
const
;
const
Literal
&
asLiteral
(
)
const
;
Operand
(
)
:
contents
(
std
:
:
nullopt
)
{
}
explicit
Operand
(
const
UnicodeString
&
v
)
:
contents
(
VariableName
(
v
)
)
{
}
explicit
Operand
(
const
Literal
&
l
)
:
contents
(
l
)
{
}
friend
inline
void
swap
(
Operand
&
o1
Operand
&
o2
)
noexcept
{
using
std
:
:
swap
;
(
void
)
o1
;
(
void
)
o2
;
swap
(
o1
.
contents
o2
.
contents
)
;
}
virtual
Operand
&
operator
=
(
Operand
)
noexcept
;
Operand
(
const
Operand
&
)
;
virtual
~
Operand
(
)
;
private
:
std
:
:
optional
<
std
:
:
variant
<
VariableName
Literal
>
>
contents
;
}
;
class
U_I18N_API
Key
:
public
UObject
{
public
:
UBool
isWildcard
(
)
const
{
return
!
contents
.
has_value
(
)
;
}
const
Literal
&
asLiteral
(
)
const
;
Key
(
const
Key
&
other
)
:
contents
(
other
.
contents
)
{
}
Key
(
)
:
contents
(
std
:
:
nullopt
)
{
}
explicit
Key
(
const
Literal
&
lit
)
:
contents
(
lit
)
{
}
friend
inline
void
swap
(
Key
&
k1
Key
&
k2
)
noexcept
{
using
std
:
:
swap
;
swap
(
k1
.
contents
k2
.
contents
)
;
}
Key
&
operator
=
(
Key
)
noexcept
;
bool
operator
<
(
const
Key
&
other
)
const
;
bool
operator
=
=
(
const
Key
&
other
)
const
;
virtual
~
Key
(
)
;
private
:
std
:
:
optional
<
Literal
>
contents
;
}
;
}
}
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
LocalPointerBase
<
message2
:
:
data_model
:
:
Key
>
;
template
class
U_I18N_API
LocalArray
<
message2
:
:
data_model
:
:
Key
>
;
#
endif
namespace
message2
{
namespace
data_model
{
class
U_I18N_API
SelectorKeys
:
public
UObject
{
public
:
std
:
:
vector
<
Key
>
getKeys
(
)
const
{
return
toStdVector
<
Key
>
(
keys
.
getAlias
(
)
len
)
;
}
class
U_I18N_API
Builder
:
public
UMemory
{
private
:
friend
class
SelectorKeys
;
UVector
*
keys
;
public
:
Builder
&
add
(
Key
&
&
key
UErrorCode
&
status
)
noexcept
;
SelectorKeys
build
(
UErrorCode
&
status
)
const
;
Builder
(
UErrorCode
&
status
)
;
virtual
~
Builder
(
)
;
Builder
(
const
Builder
&
)
=
delete
;
Builder
&
operator
=
(
const
Builder
&
)
=
delete
;
Builder
(
Builder
&
&
)
=
delete
;
Builder
&
operator
=
(
Builder
&
&
)
=
delete
;
}
;
bool
operator
<
(
const
SelectorKeys
&
other
)
const
;
SelectorKeys
(
)
:
len
(
0
)
{
}
friend
inline
void
swap
(
SelectorKeys
&
s1
SelectorKeys
&
s2
)
noexcept
{
using
std
:
:
swap
;
swap
(
s1
.
len
s2
.
len
)
;
swap
(
s1
.
keys
s2
.
keys
)
;
}
SelectorKeys
(
const
SelectorKeys
&
other
)
;
SelectorKeys
&
operator
=
(
SelectorKeys
other
)
noexcept
;
virtual
~
SelectorKeys
(
)
;
private
:
friend
class
Builder
;
friend
class
message2
:
:
Checker
;
friend
class
message2
:
:
MessageFormatter
;
friend
class
message2
:
:
Serializer
;
LocalArray
<
Key
>
keys
;
int32_t
len
;
const
Key
*
getKeysInternal
(
)
const
;
SelectorKeys
(
const
UVector
&
ks
UErrorCode
&
status
)
;
}
;
}
namespace
data_model
{
class
Operator
;
class
U_I18N_API
Option
:
public
UObject
{
public
:
const
Operand
&
getValue
(
)
const
{
return
rand
;
}
const
UnicodeString
&
getName
(
)
const
{
return
name
;
}
Option
(
const
UnicodeString
&
n
Operand
&
&
r
)
:
name
(
n
)
rand
(
std
:
:
move
(
r
)
)
{
}
Option
(
)
{
}
friend
inline
void
swap
(
Option
&
o1
Option
&
o2
)
noexcept
{
using
std
:
:
swap
;
swap
(
o1
.
name
o2
.
name
)
;
swap
(
o1
.
rand
o2
.
rand
)
;
}
Option
(
const
Option
&
other
)
;
Option
&
operator
=
(
Option
other
)
noexcept
;
virtual
~
Option
(
)
;
private
:
UnicodeString
name
;
Operand
rand
;
}
;
}
}
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
LocalPointerBase
<
message2
:
:
data_model
:
:
Option
>
;
template
class
U_I18N_API
LocalArray
<
message2
:
:
data_model
:
:
Option
>
;
#
endif
namespace
message2
{
namespace
data_model
{
#
ifndef
U_IN_DOXYGEN
class
U_I18N_API
OptionMap
:
public
UObject
{
public
:
int32_t
size
(
)
const
;
const
Option
&
getOption
(
int32_t
UErrorCode
&
)
const
;
friend
inline
void
swap
(
OptionMap
&
m1
OptionMap
&
m2
)
noexcept
{
using
std
:
:
swap
;
swap
(
m1
.
bogus
m2
.
bogus
)
;
swap
(
m1
.
options
m2
.
options
)
;
swap
(
m1
.
len
m2
.
len
)
;
}
OptionMap
(
)
:
len
(
0
)
{
}
OptionMap
(
const
OptionMap
&
)
;
OptionMap
&
operator
=
(
OptionMap
)
;
std
:
:
vector
<
Option
>
getOptions
(
)
const
{
return
toStdVector
<
Option
>
(
options
.
getAlias
(
)
len
)
;
}
OptionMap
(
const
UVector
&
UErrorCode
&
)
;
OptionMap
(
Option
*
int32_t
)
;
virtual
~
OptionMap
(
)
;
class
U_I18N_API
Builder
:
public
UObject
{
private
:
UVector
*
options
;
bool
checkDuplicates
=
true
;
public
:
Builder
&
add
(
Option
&
&
opt
UErrorCode
&
)
;
Builder
(
UErrorCode
&
)
;
static
Builder
attributes
(
UErrorCode
&
)
;
OptionMap
build
(
UErrorCode
&
)
;
friend
inline
void
swap
(
Builder
&
m1
Builder
&
m2
)
noexcept
{
using
std
:
:
swap
;
swap
(
m1
.
options
m2
.
options
)
;
swap
(
m1
.
checkDuplicates
m2
.
checkDuplicates
)
;
}
Builder
(
Builder
&
&
)
;
Builder
(
const
Builder
&
)
=
delete
;
Builder
&
operator
=
(
Builder
)
noexcept
;
virtual
~
Builder
(
)
;
}
;
private
:
friend
class
message2
:
:
Serializer
;
bool
bogus
=
false
;
LocalArray
<
Option
>
options
;
int32_t
len
;
}
;
#
endif
}
}
U_NAMESPACE_END
U_NAMESPACE_BEGIN
namespace
message2
{
namespace
data_model
{
class
U_I18N_API
Operator
:
public
UObject
{
public
:
const
FunctionName
&
getFunctionName
(
)
const
;
std
:
:
vector
<
Option
>
getOptions
(
)
const
{
return
options
.
getOptions
(
)
;
}
class
U_I18N_API
Builder
:
public
UMemory
{
private
:
friend
class
Operator
;
FunctionName
functionName
;
OptionMap
:
:
Builder
options
;
public
:
Builder
&
setFunctionName
(
FunctionName
&
&
func
)
;
Builder
&
addOption
(
const
UnicodeString
&
key
Operand
&
&
value
UErrorCode
&
status
)
noexcept
;
Operator
build
(
UErrorCode
&
status
)
;
Builder
(
UErrorCode
&
status
)
;
virtual
~
Builder
(
)
;
Builder
(
const
Builder
&
)
=
delete
;
Builder
&
operator
=
(
const
Builder
&
)
=
delete
;
Builder
(
Builder
&
&
)
=
delete
;
Builder
&
operator
=
(
Builder
&
&
)
=
delete
;
}
;
Operator
(
const
Operator
&
other
)
noexcept
;
friend
inline
void
swap
(
Operator
&
o1
Operator
&
o2
)
noexcept
{
using
std
:
:
swap
;
swap
(
o1
.
name
o2
.
name
)
;
swap
(
o1
.
options
o2
.
options
)
;
}
Operator
&
operator
=
(
Operator
)
noexcept
;
Operator
(
)
{
}
virtual
~
Operator
(
)
;
private
:
friend
class
Binding
;
friend
class
Builder
;
friend
class
message2
:
:
Checker
;
friend
class
message2
:
:
MessageFormatter
;
friend
class
message2
:
:
Serializer
;
Operator
(
const
FunctionName
&
f
const
UVector
&
options
UErrorCode
&
)
;
const
OptionMap
&
getOptionsInternal
(
)
const
;
Operator
(
const
FunctionName
&
const
OptionMap
&
)
;
FunctionName
name
;
OptionMap
options
;
}
;
}
}
U_NAMESPACE_END
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
std
:
:
optional
<
icu
:
:
message2
:
:
data_model
:
:
Operator
>
;
#
endif
U_NAMESPACE_BEGIN
namespace
message2
{
namespace
data_model
{
typedef
enum
UMarkupType
{
UMARKUP_OPEN
=
0
UMARKUP_CLOSE
UMARKUP_STANDALONE
UMARKUP_COUNT
}
UMarkupType
;
class
U_I18N_API
Markup
:
public
UObject
{
public
:
UBool
isOpen
(
)
const
{
return
(
type
=
=
UMARKUP_OPEN
)
;
}
UBool
isClose
(
)
const
{
return
(
type
=
=
UMARKUP_CLOSE
)
;
}
UBool
isStandalone
(
)
const
{
return
(
type
=
=
UMARKUP_STANDALONE
)
;
}
const
UnicodeString
&
getName
(
)
const
{
return
name
;
}
std
:
:
vector
<
Option
>
getOptions
(
)
const
{
return
options
.
getOptions
(
)
;
}
std
:
:
vector
<
Option
>
getAttributes
(
)
const
{
return
attributes
.
getOptions
(
)
;
}
Markup
(
)
{
}
virtual
~
Markup
(
)
;
class
U_I18N_API
Builder
:
public
UMemory
{
private
:
friend
class
Markup
;
UnicodeString
name
;
OptionMap
:
:
Builder
options
;
OptionMap
:
:
Builder
attributes
;
UMarkupType
type
=
UMARKUP_COUNT
;
public
:
Builder
&
setName
(
const
UnicodeString
&
n
)
{
name
=
n
;
return
*
this
;
}
Builder
&
setOpen
(
)
{
type
=
UMARKUP_OPEN
;
return
*
this
;
}
Builder
&
setClose
(
)
{
type
=
UMARKUP_CLOSE
;
return
*
this
;
}
Builder
&
setStandalone
(
)
{
type
=
UMARKUP_STANDALONE
;
return
*
this
;
}
Builder
&
addOption
(
const
UnicodeString
&
key
Operand
&
&
value
UErrorCode
&
status
)
;
Builder
&
addAttribute
(
const
UnicodeString
&
key
Operand
&
&
value
UErrorCode
&
status
)
;
Markup
build
(
UErrorCode
&
status
)
;
Builder
(
UErrorCode
&
status
)
;
virtual
~
Builder
(
)
;
Builder
(
const
Builder
&
)
=
delete
;
Builder
&
operator
=
(
const
Builder
&
)
=
delete
;
Builder
(
Builder
&
&
)
=
delete
;
Builder
&
operator
=
(
Builder
&
&
)
=
delete
;
}
;
private
:
friend
class
Builder
;
friend
class
message2
:
:
Serializer
;
UMarkupType
type
;
UnicodeString
name
;
OptionMap
options
;
OptionMap
attributes
;
const
OptionMap
&
getOptionsInternal
(
)
const
{
return
options
;
}
const
OptionMap
&
getAttributesInternal
(
)
const
{
return
attributes
;
}
Markup
(
UMarkupType
UnicodeString
OptionMap
&
&
OptionMap
&
&
)
;
}
;
class
U_I18N_API
Expression
:
public
UObject
{
public
:
UBool
isStandaloneAnnotation
(
)
const
;
UBool
isFunctionCall
(
)
const
;
const
Operator
*
getOperator
(
UErrorCode
&
status
)
const
;
const
Operand
&
getOperand
(
)
const
;
std
:
:
vector
<
Option
>
getAttributes
(
)
const
{
return
attributes
.
getOptions
(
)
;
}
class
U_I18N_API
Builder
:
public
UMemory
{
private
:
friend
class
Expression
;
bool
hasOperand
=
false
;
bool
hasOperator
=
false
;
Operand
rand
;
Operator
rator
;
OptionMap
:
:
Builder
attributes
;
public
:
Builder
&
setOperand
(
Operand
&
&
rAnd
)
;
Builder
&
setOperator
(
Operator
&
&
rAtor
)
;
Builder
&
addAttribute
(
const
UnicodeString
&
key
Operand
&
&
value
UErrorCode
&
status
)
;
Expression
build
(
UErrorCode
&
status
)
;
Builder
(
UErrorCode
&
status
)
;
virtual
~
Builder
(
)
;
Builder
(
const
Builder
&
)
=
delete
;
Builder
&
operator
=
(
const
Builder
&
)
=
delete
;
Builder
(
Builder
&
&
)
=
delete
;
Builder
&
operator
=
(
Builder
&
&
)
=
delete
;
}
;
friend
inline
void
swap
(
Expression
&
e1
Expression
&
e2
)
noexcept
{
using
std
:
:
swap
;
swap
(
e1
.
rator
e2
.
rator
)
;
swap
(
e1
.
rand
e2
.
rand
)
;
swap
(
e1
.
attributes
e2
.
attributes
)
;
}
Expression
(
const
Expression
&
other
)
;
Expression
&
operator
=
(
Expression
)
noexcept
;
Expression
(
)
;
virtual
~
Expression
(
)
;
private
:
friend
class
message2
:
:
Serializer
;
Expression
(
const
Operator
&
rAtor
const
Operand
&
rAnd
const
OptionMap
&
attrs
)
:
rator
(
rAtor
)
rand
(
rAnd
)
attributes
(
attrs
)
{
}
Expression
(
const
Operand
&
rAnd
const
OptionMap
&
attrs
)
:
rator
(
std
:
:
nullopt
)
rand
(
Operand
(
rAnd
)
)
attributes
(
attrs
)
{
}
Expression
(
const
Operator
&
rAtor
const
OptionMap
&
attrs
)
:
rator
(
rAtor
)
rand
(
)
attributes
(
attrs
)
{
}
std
:
:
optional
<
Operator
>
rator
;
Operand
rand
;
OptionMap
attributes
;
const
OptionMap
&
getAttributesInternal
(
)
const
{
return
attributes
;
}
}
;
}
}
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
LocalPointerBase
<
message2
:
:
data_model
:
:
Expression
>
;
template
class
U_I18N_API
LocalArray
<
message2
:
:
data_model
:
:
Expression
>
;
#
endif
namespace
message2
{
namespace
data_model
{
class
Pattern
;
class
PatternPart
:
public
UObject
{
public
:
UBool
isText
(
)
const
{
return
std
:
:
holds_alternative
<
UnicodeString
>
(
piece
)
;
}
UBool
isMarkup
(
)
const
{
return
std
:
:
holds_alternative
<
Markup
>
(
piece
)
;
}
UBool
isExpression
(
)
const
{
return
std
:
:
holds_alternative
<
Expression
>
(
piece
)
;
}
const
Expression
&
contents
(
)
const
;
const
Markup
&
asMarkup
(
)
const
;
const
UnicodeString
&
asText
(
)
const
;
friend
inline
void
swap
(
PatternPart
&
p1
PatternPart
&
p2
)
noexcept
{
using
std
:
:
swap
;
swap
(
p1
.
piece
p2
.
piece
)
;
}
PatternPart
(
const
PatternPart
&
other
)
;
PatternPart
&
operator
=
(
PatternPart
)
noexcept
;
virtual
~
PatternPart
(
)
;
explicit
PatternPart
(
const
UnicodeString
&
t
)
:
piece
(
t
)
{
}
explicit
PatternPart
(
Expression
&
&
e
)
:
piece
(
e
)
{
}
explicit
PatternPart
(
Markup
&
&
m
)
:
piece
(
m
)
{
}
PatternPart
(
)
=
default
;
private
:
friend
class
Pattern
;
std
:
:
variant
<
UnicodeString
Expression
Markup
>
piece
;
}
;
}
}
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
LocalPointerBase
<
message2
:
:
data_model
:
:
PatternPart
>
;
template
class
U_I18N_API
LocalArray
<
message2
:
:
data_model
:
:
PatternPart
>
;
#
endif
namespace
message2
{
namespace
data_model
{
class
U_I18N_API
Pattern
:
public
UObject
{
private
:
friend
class
PatternPart
;
public
:
struct
Iterator
;
Iterator
begin
(
)
const
{
return
Iterator
(
this
0
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
this
len
)
;
}
class
U_I18N_API
Builder
:
public
UMemory
{
private
:
friend
class
Pattern
;
UVector
*
parts
;
public
:
Builder
&
add
(
Expression
&
&
part
UErrorCode
&
status
)
noexcept
;
Builder
&
add
(
Markup
&
&
part
UErrorCode
&
status
)
noexcept
;
Builder
&
add
(
UnicodeString
&
&
part
UErrorCode
&
status
)
noexcept
;
Pattern
build
(
UErrorCode
&
status
)
const
noexcept
;
Builder
(
UErrorCode
&
status
)
;
virtual
~
Builder
(
)
;
Builder
(
const
Builder
&
)
=
delete
;
Builder
&
operator
=
(
const
Builder
&
)
=
delete
;
Builder
(
Builder
&
&
)
=
delete
;
Builder
&
operator
=
(
Builder
&
&
)
=
delete
;
}
;
Pattern
(
)
:
parts
(
LocalArray
<
PatternPart
>
(
)
)
{
}
friend
inline
void
swap
(
Pattern
&
p1
Pattern
&
p2
)
noexcept
{
using
std
:
:
swap
;
swap
(
p1
.
bogus
p2
.
bogus
)
;
swap
(
p1
.
len
p2
.
len
)
;
swap
(
p1
.
parts
p2
.
parts
)
;
}
Pattern
(
const
Pattern
&
other
)
;
Pattern
&
operator
=
(
Pattern
)
noexcept
;
virtual
~
Pattern
(
)
;
struct
U_I18N_API
Iterator
{
private
:
using
iterator_category
=
std
:
:
forward_iterator_tag
;
using
difference_type
=
std
:
:
ptrdiff_t
;
using
value_type
=
std
:
:
variant
<
UnicodeString
Expression
Markup
>
;
using
pointer
=
value_type
*
;
using
reference
=
const
value_type
&
;
friend
class
Pattern
;
Iterator
(
const
Pattern
*
p
int32_t
i
)
:
pos
(
i
)
pat
(
p
)
{
}
friend
bool
operator
=
=
(
const
Iterator
&
a
const
Iterator
&
b
)
{
return
(
a
.
pat
=
=
b
.
pat
&
&
a
.
pos
=
=
b
.
pos
)
;
}
int32_t
pos
;
const
Pattern
*
pat
;
public
:
reference
operator
*
(
)
const
{
const
PatternPart
&
part
=
pat
-
>
parts
[
pos
]
;
return
patternContents
(
part
)
;
}
Iterator
operator
+
+
(
)
{
pos
+
+
;
return
*
this
;
}
friend
bool
operator
!
=
(
const
Iterator
&
a
const
Iterator
&
b
)
{
return
!
(
a
=
=
b
)
;
}
}
;
private
:
friend
class
Builder
;
friend
class
message2
:
:
MessageFormatter
;
friend
class
message2
:
:
Serializer
;
bool
bogus
=
false
;
int32_t
len
=
0
;
LocalArray
<
PatternPart
>
parts
;
Pattern
(
const
UVector
&
parts
UErrorCode
&
status
)
;
static
void
initParts
(
Pattern
&
const
Pattern
&
)
;
int32_t
numParts
(
)
const
;
const
PatternPart
&
getPart
(
int32_t
i
)
const
;
static
const
std
:
:
variant
<
UnicodeString
Expression
Markup
>
&
patternContents
(
const
PatternPart
&
p
)
{
return
p
.
piece
;
}
}
;
class
U_I18N_API
Variant
:
public
UObject
{
public
:
const
Pattern
&
getPattern
(
)
const
{
return
p
;
}
const
SelectorKeys
&
getKeys
(
)
const
{
return
k
;
}
Variant
(
const
SelectorKeys
&
keys
Pattern
&
&
pattern
)
:
k
(
keys
)
p
(
std
:
:
move
(
pattern
)
)
{
}
friend
inline
void
swap
(
Variant
&
v1
Variant
&
v2
)
noexcept
{
using
std
:
:
swap
;
swap
(
v1
.
k
v2
.
k
)
;
swap
(
v1
.
p
v2
.
p
)
;
}
Variant
&
operator
=
(
Variant
other
)
noexcept
;
Variant
(
)
=
default
;
Variant
(
const
Variant
&
)
;
virtual
~
Variant
(
)
;
private
:
SelectorKeys
k
;
Pattern
p
;
}
;
}
namespace
data_model
{
class
U_I18N_API
Binding
:
public
UObject
{
public
:
const
Expression
&
getValue
(
)
const
;
const
VariableName
&
getVariable
(
)
const
{
return
var
;
}
static
Binding
input
(
UnicodeString
&
&
variableName
Expression
&
&
rhs
UErrorCode
&
errorCode
)
;
UBool
isLocal
(
)
const
{
return
local
;
}
Binding
(
const
VariableName
&
v
Expression
&
&
e
)
:
var
(
v
)
expr
(
std
:
:
move
(
e
)
)
local
(
true
)
annotation
(
nullptr
)
{
}
friend
inline
void
swap
(
Binding
&
b1
Binding
&
b2
)
noexcept
{
using
std
:
:
swap
;
swap
(
b1
.
var
b2
.
var
)
;
swap
(
b1
.
expr
b2
.
expr
)
;
swap
(
b1
.
local
b2
.
local
)
;
b1
.
updateAnnotation
(
)
;
b2
.
updateAnnotation
(
)
;
}
Binding
(
const
Binding
&
other
)
;
Binding
&
operator
=
(
Binding
)
noexcept
;
Binding
(
)
:
local
(
true
)
{
}
virtual
~
Binding
(
)
;
private
:
friend
class
message2
:
:
Checker
;
friend
class
message2
:
:
MessageFormatter
;
friend
class
message2
:
:
Parser
;
friend
class
message2
:
:
Serializer
;
VariableName
var
;
Expression
expr
;
bool
local
;
const
Operator
*
annotation
=
nullptr
;
const
OptionMap
&
getOptionsInternal
(
)
const
;
bool
hasAnnotation
(
)
const
{
return
!
local
&
&
(
annotation
!
=
nullptr
)
;
}
void
updateAnnotation
(
)
;
}
;
}
}
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
LocalPointerBase
<
message2
:
:
data_model
:
:
Variant
>
;
template
class
U_I18N_API
LocalPointerBase
<
message2
:
:
data_model
:
:
Binding
>
;
template
class
U_I18N_API
LocalArray
<
message2
:
:
data_model
:
:
Variant
>
;
template
class
U_I18N_API
LocalArray
<
message2
:
:
data_model
:
:
Binding
>
;
#
endif
namespace
message2
{
using
namespace
data_model
;
class
MFDataModel
;
#
ifndef
U_IN_DOXYGEN
class
Matcher
:
public
UObject
{
public
:
Matcher
&
operator
=
(
Matcher
)
;
Matcher
(
const
Matcher
&
)
;
friend
inline
void
swap
(
Matcher
&
m1
Matcher
&
m2
)
noexcept
{
using
std
:
:
swap
;
if
(
m1
.
bogus
)
{
m2
.
bogus
=
true
;
return
;
}
if
(
m2
.
bogus
)
{
m1
.
bogus
=
true
;
return
;
}
swap
(
m1
.
selectors
m2
.
selectors
)
;
swap
(
m1
.
numSelectors
m2
.
numSelectors
)
;
swap
(
m1
.
variants
m2
.
variants
)
;
swap
(
m1
.
numVariants
m2
.
numVariants
)
;
}
virtual
~
Matcher
(
)
;
private
:
friend
class
MFDataModel
;
Matcher
(
VariableName
*
ss
int32_t
ns
Variant
*
vs
int32_t
nv
)
;
Matcher
(
)
{
}
bool
bogus
=
false
;
LocalArray
<
VariableName
>
selectors
;
int32_t
numSelectors
=
0
;
LocalArray
<
Variant
>
variants
;
int32_t
numVariants
=
0
;
}
;
#
endif
}
U_NAMESPACE_END
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
#
if
defined
(
U_REAL_MSVC
)
&
&
defined
(
_MSVC_STL_VERSION
)
template
class
U_I18N_API
std
:
:
_Variant_storage_
<
false
icu
:
:
message2
:
:
Matcher
icu
:
:
message2
:
:
data_model
:
:
Pattern
>
;
#
endif
template
class
U_I18N_API
std
:
:
variant
<
icu
:
:
message2
:
:
Matcher
icu
:
:
message2
:
:
data_model
:
:
Pattern
>
;
#
endif
U_NAMESPACE_BEGIN
namespace
message2
{
class
U_I18N_API
MFDataModel
:
public
UMemory
{
public
:
std
:
:
vector
<
Binding
>
getLocalVariables
(
)
const
{
std
:
:
vector
<
Binding
>
result
;
if
(
!
bogus
)
{
return
toStdVector
<
Binding
>
(
bindings
.
getAlias
(
)
bindingsLen
)
;
}
return
{
}
;
}
std
:
:
vector
<
VariableName
>
getSelectors
(
)
const
{
if
(
std
:
:
holds_alternative
<
Pattern
>
(
body
)
)
{
return
{
}
;
}
const
Matcher
*
match
=
std
:
:
get_if
<
Matcher
>
(
&
body
)
;
return
toStdVector
<
VariableName
>
(
match
-
>
selectors
.
getAlias
(
)
match
-
>
numSelectors
)
;
}
std
:
:
vector
<
Variant
>
getVariants
(
)
const
{
if
(
std
:
:
holds_alternative
<
Pattern
>
(
body
)
)
{
return
{
}
;
}
const
Matcher
*
match
=
std
:
:
get_if
<
Matcher
>
(
&
body
)
;
return
toStdVector
<
Variant
>
(
match
-
>
variants
.
getAlias
(
)
match
-
>
numVariants
)
;
return
{
}
;
}
const
Pattern
&
getPattern
(
)
const
;
class
U_I18N_API
Builder
;
MFDataModel
(
)
;
friend
inline
void
swap
(
MFDataModel
&
m1
MFDataModel
&
m2
)
noexcept
{
using
std
:
:
swap
;
if
(
m1
.
bogus
)
{
m2
.
bogus
=
true
;
return
;
}
if
(
m2
.
bogus
)
{
m1
.
bogus
=
true
;
return
;
}
swap
(
m1
.
body
m2
.
body
)
;
swap
(
m1
.
bindings
m2
.
bindings
)
;
swap
(
m1
.
bindingsLen
m2
.
bindingsLen
)
;
}
MFDataModel
&
operator
=
(
MFDataModel
)
noexcept
;
MFDataModel
(
const
MFDataModel
&
other
)
;
virtual
~
MFDataModel
(
)
;
class
U_I18N_API
Builder
:
public
UMemory
{
private
:
friend
class
MFDataModel
;
void
checkDuplicate
(
const
VariableName
&
UErrorCode
&
)
const
;
void
buildSelectorsMessage
(
UErrorCode
&
)
;
bool
hasPattern
=
true
;
bool
hasSelectors
=
false
;
Pattern
pattern
;
UVector
*
selectors
=
nullptr
;
UVector
*
variants
=
nullptr
;
UVector
*
bindings
=
nullptr
;
public
:
Builder
&
addBinding
(
Binding
&
&
b
UErrorCode
&
status
)
;
Builder
&
addSelector
(
VariableName
&
&
selector
UErrorCode
&
errorCode
)
;
Builder
&
addVariant
(
SelectorKeys
&
&
keys
Pattern
&
&
pattern
UErrorCode
&
errorCode
)
noexcept
;
Builder
&
setPattern
(
Pattern
&
&
pattern
)
;
MFDataModel
build
(
UErrorCode
&
status
)
const
noexcept
;
Builder
(
UErrorCode
&
status
)
;
virtual
~
Builder
(
)
;
Builder
(
const
Builder
&
)
=
delete
;
Builder
&
operator
=
(
const
Builder
&
)
=
delete
;
Builder
(
Builder
&
&
)
=
delete
;
Builder
&
operator
=
(
Builder
&
&
)
=
delete
;
}
;
private
:
friend
class
Checker
;
friend
class
MessageFormatter
;
friend
class
Serializer
;
Pattern
empty
;
bool
hasPattern
(
)
const
{
return
std
:
:
holds_alternative
<
Pattern
>
(
body
)
;
}
bool
bogus
=
false
;
std
:
:
variant
<
Matcher
Pattern
>
body
;
LocalArray
<
Binding
>
bindings
;
int32_t
bindingsLen
=
0
;
const
Binding
*
getLocalVariablesInternal
(
)
const
;
const
VariableName
*
getSelectorsInternal
(
)
const
;
const
Variant
*
getVariantsInternal
(
)
const
;
int32_t
numSelectors
(
)
const
{
const
Matcher
*
matcher
=
std
:
:
get_if
<
Matcher
>
(
&
body
)
;
return
(
matcher
=
=
nullptr
?
0
:
matcher
-
>
numSelectors
)
;
}
int32_t
numVariants
(
)
const
{
const
Matcher
*
matcher
=
std
:
:
get_if
<
Matcher
>
(
&
body
)
;
return
(
matcher
=
=
nullptr
?
0
:
matcher
-
>
numVariants
)
;
}
void
initBindings
(
const
Binding
*
)
;
MFDataModel
(
const
Builder
&
builder
UErrorCode
&
)
noexcept
;
}
;
}
U_NAMESPACE_END
#
endif
#
endif
#
endif
#
endif
#
endif
#
endif
