#
include
"
unicode
/
utypes
.
h
"
#
ifndef
MESSAGEFORMAT2_ARGUMENTS_H
#
define
MESSAGEFORMAT2_ARGUMENTS_H
#
if
U_SHOW_CPLUSPLUS_API
#
if
!
UCONFIG_NO_NORMALIZATION
#
if
!
UCONFIG_NO_FORMATTING
#
if
!
UCONFIG_NO_MF2
#
include
"
unicode
/
messageformat2_data_model_names
.
h
"
#
include
"
unicode
/
messageformat2_formattable
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
ifndef
U_HIDE_DEPRECATED_API
#
include
<
map
>
U_NAMESPACE_BEGIN
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
template
class
U_I18N_API
LocalPointerBase
<
UnicodeString
>
;
template
class
U_I18N_API
LocalPointerBase
<
message2
:
:
Formattable
>
;
template
class
U_I18N_API
LocalArray
<
UnicodeString
>
;
template
class
U_I18N_API
LocalArray
<
message2
:
:
Formattable
>
;
#
endif
namespace
message2
{
class
MessageFormatter
;
class
U_I18N_API
MessageArguments
:
public
UObject
{
public
:
MessageArguments
(
const
std
:
:
map
<
UnicodeString
Formattable
>
&
args
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
argumentNames
=
LocalArray
<
UnicodeString
>
(
new
UnicodeString
[
argsLen
=
static_cast
<
int32_t
>
(
args
.
size
(
)
)
]
)
;
arguments
=
LocalArray
<
Formattable
>
(
new
Formattable
[
argsLen
]
)
;
if
(
!
argumentNames
.
isValid
(
)
|
|
!
arguments
.
isValid
(
)
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
int32_t
i
=
0
;
for
(
auto
iter
=
args
.
begin
(
)
;
iter
!
=
args
.
end
(
)
;
+
+
iter
)
{
argumentNames
[
i
]
=
iter
-
>
first
;
arguments
[
i
]
=
iter
-
>
second
;
i
+
+
;
}
}
MessageArguments
&
operator
=
(
MessageArguments
&
&
)
noexcept
;
MessageArguments
(
)
=
default
;
virtual
~
MessageArguments
(
)
;
private
:
friend
class
MessageContext
;
const
Formattable
*
getArgument
(
const
MessageFormatter
&
const
data_model
:
:
VariableName
&
UErrorCode
&
)
const
;
LocalArray
<
UnicodeString
>
argumentNames
;
LocalArray
<
Formattable
>
arguments
;
int32_t
argsLen
=
0
;
}
;
}
U_NAMESPACE_END
#
endif
#
endif
#
endif
#
endif
#
endif
#
endif
