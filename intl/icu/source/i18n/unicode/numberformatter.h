#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
ifndef
__NUMBERFORMATTER_H__
#
define
__NUMBERFORMATTER_H__
#
include
"
unicode
/
appendable
.
h
"
#
include
"
unicode
/
dcfmtsym
.
h
"
#
include
"
unicode
/
currunit
.
h
"
#
include
"
unicode
/
fieldpos
.
h
"
#
include
"
unicode
/
fpositer
.
h
"
#
include
"
unicode
/
measunit
.
h
"
#
include
"
unicode
/
nounit
.
h
"
#
include
"
unicode
/
plurrule
.
h
"
#
include
"
unicode
/
ucurr
.
h
"
#
include
"
unicode
/
unum
.
h
"
#
ifndef
U_HIDE_DRAFT_API
typedef
enum
UNumberUnitWidth
{
UNUM_UNIT_WIDTH_NARROW
UNUM_UNIT_WIDTH_SHORT
UNUM_UNIT_WIDTH_FULL_NAME
UNUM_UNIT_WIDTH_ISO_CODE
UNUM_UNIT_WIDTH_HIDDEN
#
ifndef
U_HIDE_INTERNAL_API
UNUM_UNIT_WIDTH_COUNT
#
endif
}
UNumberUnitWidth
;
typedef
enum
UGroupingStrategy
{
UNUM_GROUPING_OFF
UNUM_GROUPING_MIN2
UNUM_GROUPING_AUTO
UNUM_GROUPING_ON_ALIGNED
UNUM_GROUPING_THOUSANDS
}
UGroupingStrategy
;
typedef
enum
UNumberSignDisplay
{
UNUM_SIGN_AUTO
UNUM_SIGN_ALWAYS
UNUM_SIGN_NEVER
UNUM_SIGN_ACCOUNTING
UNUM_SIGN_ACCOUNTING_ALWAYS
UNUM_SIGN_EXCEPT_ZERO
UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO
#
ifndef
U_HIDE_INTERNAL_API
UNUM_SIGN_COUNT
#
endif
}
UNumberSignDisplay
;
typedef
enum
UNumberDecimalSeparatorDisplay
{
UNUM_DECIMAL_SEPARATOR_AUTO
UNUM_DECIMAL_SEPARATOR_ALWAYS
#
ifndef
U_HIDE_INTERNAL_API
UNUM_DECIMAL_SEPARATOR_COUNT
#
endif
}
UNumberDecimalMarkDisplay
;
U_NAMESPACE_BEGIN
namespace
number
{
class
UnlocalizedNumberFormatter
;
class
LocalizedNumberFormatter
;
class
FormattedNumber
;
class
Notation
;
class
ScientificNotation
;
class
Rounder
;
class
FractionRounder
;
class
CurrencyRounder
;
class
IncrementRounder
;
class
IntegerWidth
;
namespace
impl
{
#
ifndef
U_HIDE_INTERNAL_API
typedef
int16_t
digits_t
;
static
constexpr
int32_t
DEFAULT_THRESHOLD
=
3
;
#
endif
class
Padder
;
struct
MacroProps
;
struct
MicroProps
;
class
DecimalQuantity
;
struct
NumberFormatterResults
;
class
NumberFormatterImpl
;
struct
ParsedPatternInfo
;
class
ScientificModifier
;
class
MultiplierProducer
;
class
MutablePatternModifier
;
class
LongNameHandler
;
class
ScientificHandler
;
class
CompactHandler
;
class
Modifier
;
class
NumberStringBuilder
;
}
typedef
Notation
CompactNotation
;
typedef
Notation
SimpleNotation
;
class
U_I18N_API
Notation
:
public
UMemory
{
public
:
static
ScientificNotation
scientific
(
)
;
static
ScientificNotation
engineering
(
)
;
static
CompactNotation
compactShort
(
)
;
static
CompactNotation
compactLong
(
)
;
static
SimpleNotation
simple
(
)
;
private
:
enum
NotationType
{
NTN_SCIENTIFIC
NTN_COMPACT
NTN_SIMPLE
NTN_ERROR
}
fType
;
union
NotationUnion
{
struct
ScientificSettings
{
int8_t
fEngineeringInterval
;
bool
fRequireMinInt
;
impl
:
:
digits_t
fMinExponentDigits
;
UNumberSignDisplay
fExponentSignDisplay
;
}
scientific
;
UNumberCompactStyle
compactStyle
;
UErrorCode
errorCode
;
}
fUnion
;
typedef
NotationUnion
:
:
ScientificSettings
ScientificSettings
;
Notation
(
const
NotationType
&
type
const
NotationUnion
&
union_
)
:
fType
(
type
)
fUnion
(
union_
)
{
}
Notation
(
UErrorCode
errorCode
)
:
fType
(
NTN_ERROR
)
{
fUnion
.
errorCode
=
errorCode
;
}
Notation
(
)
:
fType
(
NTN_SIMPLE
)
fUnion
(
)
{
}
UBool
copyErrorTo
(
UErrorCode
&
status
)
const
{
if
(
fType
=
=
NTN_ERROR
)
{
status
=
fUnion
.
errorCode
;
return
TRUE
;
}
return
FALSE
;
}
friend
struct
impl
:
:
MacroProps
;
friend
class
ScientificNotation
;
friend
class
impl
:
:
NumberFormatterImpl
;
friend
class
impl
:
:
ScientificModifier
;
friend
class
impl
:
:
ScientificHandler
;
}
;
class
U_I18N_API
ScientificNotation
:
public
Notation
{
public
:
ScientificNotation
withMinExponentDigits
(
int32_t
minExponentDigits
)
const
;
ScientificNotation
withExponentSignDisplay
(
UNumberSignDisplay
exponentSignDisplay
)
const
;
private
:
using
Notation
:
:
Notation
;
friend
class
Notation
;
}
;
typedef
Rounder
DigitRounder
;
class
U_I18N_API
Rounder
:
public
UMemory
{
public
:
static
Rounder
unlimited
(
)
;
static
FractionRounder
integer
(
)
;
static
FractionRounder
fixedFraction
(
int32_t
minMaxFractionPlaces
)
;
static
FractionRounder
minFraction
(
int32_t
minFractionPlaces
)
;
static
FractionRounder
maxFraction
(
int32_t
maxFractionPlaces
)
;
static
FractionRounder
minMaxFraction
(
int32_t
minFractionPlaces
int32_t
maxFractionPlaces
)
;
static
DigitRounder
fixedDigits
(
int32_t
minMaxSignificantDigits
)
;
static
DigitRounder
minDigits
(
int32_t
minSignificantDigits
)
;
static
DigitRounder
maxDigits
(
int32_t
maxSignificantDigits
)
;
static
DigitRounder
minMaxDigits
(
int32_t
minSignificantDigits
int32_t
maxSignificantDigits
)
;
static
IncrementRounder
increment
(
double
roundingIncrement
)
;
static
CurrencyRounder
currency
(
UCurrencyUsage
currencyUsage
)
;
Rounder
withMode
(
UNumberFormatRoundingMode
roundingMode
)
const
;
private
:
enum
RounderType
{
RND_BOGUS
RND_NONE
RND_FRACTION
RND_SIGNIFICANT
RND_FRACTION_SIGNIFICANT
RND_INCREMENT
RND_CURRENCY
RND_PASS_THROUGH
RND_ERROR
}
fType
;
union
RounderUnion
{
struct
FractionSignificantSettings
{
impl
:
:
digits_t
fMinFrac
;
impl
:
:
digits_t
fMaxFrac
;
impl
:
:
digits_t
fMinSig
;
impl
:
:
digits_t
fMaxSig
;
}
fracSig
;
struct
IncrementSettings
{
double
fIncrement
;
impl
:
:
digits_t
fMinFrac
;
}
increment
;
UCurrencyUsage
currencyUsage
;
UErrorCode
errorCode
;
}
fUnion
;
typedef
RounderUnion
:
:
FractionSignificantSettings
FractionSignificantSettings
;
typedef
RounderUnion
:
:
IncrementSettings
IncrementSettings
;
UNumberFormatRoundingMode
fRoundingMode
;
Rounder
(
const
RounderType
&
type
const
RounderUnion
&
union_
UNumberFormatRoundingMode
roundingMode
)
:
fType
(
type
)
fUnion
(
union_
)
fRoundingMode
(
roundingMode
)
{
}
Rounder
(
UErrorCode
errorCode
)
:
fType
(
RND_ERROR
)
{
fUnion
.
errorCode
=
errorCode
;
}
Rounder
(
)
:
fType
(
RND_BOGUS
)
{
}
bool
isBogus
(
)
const
{
return
fType
=
=
RND_BOGUS
;
}
UBool
copyErrorTo
(
UErrorCode
&
status
)
const
{
if
(
fType
=
=
RND_ERROR
)
{
status
=
fUnion
.
errorCode
;
return
TRUE
;
}
return
FALSE
;
}
Rounder
withCurrency
(
const
CurrencyUnit
&
currency
UErrorCode
&
status
)
const
;
void
setLocaleData
(
const
CurrencyUnit
&
currency
UErrorCode
&
status
)
;
void
apply
(
impl
:
:
DecimalQuantity
&
value
UErrorCode
&
status
)
const
;
void
apply
(
impl
:
:
DecimalQuantity
&
value
int32_t
minInt
UErrorCode
status
)
;
int32_t
chooseMultiplierAndApply
(
impl
:
:
DecimalQuantity
&
input
const
impl
:
:
MultiplierProducer
&
producer
UErrorCode
&
status
)
;
static
FractionRounder
constructFraction
(
int32_t
minFrac
int32_t
maxFrac
)
;
static
Rounder
constructSignificant
(
int32_t
minSig
int32_t
maxSig
)
;
static
Rounder
constructFractionSignificant
(
const
FractionRounder
&
base
int32_t
minSig
int32_t
maxSig
)
;
static
IncrementRounder
constructIncrement
(
double
increment
int32_t
minFrac
)
;
static
CurrencyRounder
constructCurrency
(
UCurrencyUsage
usage
)
;
static
Rounder
constructPassThrough
(
)
;
friend
struct
impl
:
:
MacroProps
;
friend
struct
impl
:
:
MicroProps
;
friend
class
impl
:
:
NumberFormatterImpl
;
friend
class
impl
:
:
MutablePatternModifier
;
friend
class
impl
:
:
LongNameHandler
;
friend
class
impl
:
:
ScientificHandler
;
friend
class
impl
:
:
CompactHandler
;
friend
class
FractionRounder
;
friend
class
CurrencyRounder
;
friend
class
IncrementRounder
;
}
;
class
U_I18N_API
FractionRounder
:
public
Rounder
{
public
:
Rounder
withMinDigits
(
int32_t
minSignificantDigits
)
const
;
Rounder
withMaxDigits
(
int32_t
maxSignificantDigits
)
const
;
private
:
using
Rounder
:
:
Rounder
;
friend
class
Rounder
;
}
;
class
U_I18N_API
CurrencyRounder
:
public
Rounder
{
public
:
Rounder
withCurrency
(
const
CurrencyUnit
&
currency
)
const
;
private
:
using
Rounder
:
:
Rounder
;
friend
class
Rounder
;
}
;
class
U_I18N_API
IncrementRounder
:
public
Rounder
{
public
:
Rounder
withMinFraction
(
int32_t
minFrac
)
const
;
private
:
using
Rounder
:
:
Rounder
;
friend
class
Rounder
;
}
;
class
U_I18N_API
IntegerWidth
:
public
UMemory
{
public
:
static
IntegerWidth
zeroFillTo
(
int32_t
minInt
)
;
IntegerWidth
truncateAt
(
int32_t
maxInt
)
;
private
:
union
{
struct
{
impl
:
:
digits_t
fMinInt
;
impl
:
:
digits_t
fMaxInt
;
}
minMaxInt
;
UErrorCode
errorCode
;
}
fUnion
;
bool
fHasError
=
false
;
IntegerWidth
(
impl
:
:
digits_t
minInt
impl
:
:
digits_t
maxInt
)
;
IntegerWidth
(
UErrorCode
errorCode
)
{
fUnion
.
errorCode
=
errorCode
;
fHasError
=
true
;
}
IntegerWidth
(
)
{
fUnion
.
minMaxInt
.
fMinInt
=
-
1
;
}
bool
isBogus
(
)
const
{
return
!
fHasError
&
&
fUnion
.
minMaxInt
.
fMinInt
=
=
-
1
;
}
UBool
copyErrorTo
(
UErrorCode
&
status
)
const
{
if
(
fHasError
)
{
status
=
fUnion
.
errorCode
;
return
TRUE
;
}
return
FALSE
;
}
void
apply
(
impl
:
:
DecimalQuantity
&
quantity
UErrorCode
&
status
)
const
;
friend
struct
impl
:
:
MacroProps
;
friend
struct
impl
:
:
MicroProps
;
friend
class
impl
:
:
NumberFormatterImpl
;
}
;
namespace
impl
{
class
U_I18N_API
SymbolsWrapper
:
public
UMemory
{
public
:
SymbolsWrapper
(
)
:
fType
(
SYMPTR_NONE
)
fPtr
{
nullptr
}
{
}
SymbolsWrapper
(
const
SymbolsWrapper
&
other
)
;
~
SymbolsWrapper
(
)
;
SymbolsWrapper
&
operator
=
(
const
SymbolsWrapper
&
other
)
;
#
ifndef
U_HIDE_INTERNAL_API
void
setTo
(
const
DecimalFormatSymbols
&
dfs
)
;
void
setTo
(
const
NumberingSystem
*
ns
)
;
bool
isDecimalFormatSymbols
(
)
const
;
bool
isNumberingSystem
(
)
const
;
const
DecimalFormatSymbols
*
getDecimalFormatSymbols
(
)
const
;
const
NumberingSystem
*
getNumberingSystem
(
)
const
;
UBool
copyErrorTo
(
UErrorCode
&
status
)
const
{
if
(
fType
=
=
SYMPTR_DFS
&
&
fPtr
.
dfs
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
TRUE
;
}
else
if
(
fType
=
=
SYMPTR_NS
&
&
fPtr
.
ns
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
TRUE
;
}
return
FALSE
;
}
#
endif
private
:
enum
SymbolsPointerType
{
SYMPTR_NONE
SYMPTR_DFS
SYMPTR_NS
}
fType
;
union
{
const
DecimalFormatSymbols
*
dfs
;
const
NumberingSystem
*
ns
;
}
fPtr
;
void
doCopyFrom
(
const
SymbolsWrapper
&
other
)
;
void
doCleanup
(
)
;
}
;
class
U_I18N_API
Grouper
:
public
UMemory
{
public
:
#
ifndef
U_HIDE_INTERNAL_API
static
Grouper
forStrategy
(
UGroupingStrategy
grouping
)
;
Grouper
(
int16_t
grouping1
int16_t
grouping2
int16_t
minGrouping
)
:
fGrouping1
(
grouping1
)
fGrouping2
(
grouping2
)
fMinGrouping
(
minGrouping
)
{
}
#
endif
private
:
int16_t
fGrouping1
;
int16_t
fGrouping2
;
int16_t
fMinGrouping
;
Grouper
(
)
:
fGrouping1
(
-
3
)
{
}
;
bool
isBogus
(
)
const
{
return
fGrouping1
=
=
-
3
;
}
void
setLocaleData
(
const
impl
:
:
ParsedPatternInfo
&
patternInfo
const
Locale
&
locale
)
;
bool
groupAtPosition
(
int32_t
position
const
impl
:
:
DecimalQuantity
&
value
)
const
;
friend
struct
MacroProps
;
friend
struct
MicroProps
;
friend
class
NumberFormatterImpl
;
}
;
class
U_I18N_API
Padder
:
public
UMemory
{
public
:
#
ifndef
U_HIDE_INTERNAL_API
static
Padder
none
(
)
;
static
Padder
codePoints
(
UChar32
cp
int32_t
targetWidth
UNumberFormatPadPosition
position
)
;
#
endif
private
:
UChar32
fWidth
;
union
{
struct
{
int32_t
fCp
;
UNumberFormatPadPosition
fPosition
;
}
padding
;
UErrorCode
errorCode
;
}
fUnion
;
Padder
(
UChar32
cp
int32_t
width
UNumberFormatPadPosition
position
)
;
Padder
(
int32_t
width
)
;
Padder
(
UErrorCode
errorCode
)
:
fWidth
(
-
3
)
{
fUnion
.
errorCode
=
errorCode
;
}
Padder
(
)
:
fWidth
(
-
2
)
{
}
bool
isBogus
(
)
const
{
return
fWidth
=
=
-
2
;
}
UBool
copyErrorTo
(
UErrorCode
&
status
)
const
{
if
(
fWidth
=
=
-
3
)
{
status
=
fUnion
.
errorCode
;
return
TRUE
;
}
return
FALSE
;
}
bool
isValid
(
)
const
{
return
fWidth
>
0
;
}
int32_t
padAndApply
(
const
impl
:
:
Modifier
&
mod1
const
impl
:
:
Modifier
&
mod2
impl
:
:
NumberStringBuilder
&
string
int32_t
leftIndex
int32_t
rightIndex
UErrorCode
&
status
)
const
;
friend
struct
MacroProps
;
friend
struct
MicroProps
;
friend
class
impl
:
:
NumberFormatterImpl
;
}
;
struct
U_I18N_API
MacroProps
:
public
UMemory
{
Notation
notation
;
MeasureUnit
unit
;
MeasureUnit
perUnit
;
Rounder
rounder
;
Grouper
grouper
;
Padder
padder
;
IntegerWidth
integerWidth
;
SymbolsWrapper
symbols
;
UNumberUnitWidth
unitWidth
=
UNUM_UNIT_WIDTH_COUNT
;
UNumberSignDisplay
sign
=
UNUM_SIGN_COUNT
;
UNumberDecimalSeparatorDisplay
decimal
=
UNUM_DECIMAL_SEPARATOR_COUNT
;
PluralRules
*
rules
=
nullptr
;
int32_t
threshold
=
DEFAULT_THRESHOLD
;
Locale
locale
;
bool
copyErrorTo
(
UErrorCode
&
status
)
const
{
return
notation
.
copyErrorTo
(
status
)
|
|
rounder
.
copyErrorTo
(
status
)
|
|
padder
.
copyErrorTo
(
status
)
|
|
integerWidth
.
copyErrorTo
(
status
)
|
|
symbols
.
copyErrorTo
(
status
)
;
}
}
;
}
template
<
typename
Derived
>
class
U_I18N_API
NumberFormatterSettings
{
public
:
Derived
notation
(
const
Notation
&
notation
)
const
;
Derived
unit
(
const
icu
:
:
MeasureUnit
&
unit
)
const
;
Derived
adoptUnit
(
icu
:
:
MeasureUnit
*
unit
)
const
;
Derived
perUnit
(
const
icu
:
:
MeasureUnit
&
perUnit
)
const
;
Derived
adoptPerUnit
(
icu
:
:
MeasureUnit
*
perUnit
)
const
;
Derived
rounding
(
const
Rounder
&
rounder
)
const
;
Derived
grouping
(
const
UGroupingStrategy
&
strategy
)
const
;
Derived
integerWidth
(
const
IntegerWidth
&
style
)
const
;
Derived
symbols
(
const
DecimalFormatSymbols
&
symbols
)
const
;
Derived
adoptSymbols
(
NumberingSystem
*
symbols
)
const
;
Derived
unitWidth
(
const
UNumberUnitWidth
&
width
)
const
;
Derived
sign
(
const
UNumberSignDisplay
&
width
)
const
;
Derived
decimal
(
const
UNumberDecimalSeparatorDisplay
&
width
)
const
;
#
ifndef
U_HIDE_INTERNAL_API
Derived
padding
(
const
impl
:
:
Padder
&
padder
)
const
;
Derived
threshold
(
int32_t
threshold
)
const
;
#
endif
UBool
copyErrorTo
(
UErrorCode
&
outErrorCode
)
const
{
if
(
U_FAILURE
(
outErrorCode
)
)
{
return
TRUE
;
}
fMacros
.
copyErrorTo
(
outErrorCode
)
;
return
U_FAILURE
(
outErrorCode
)
;
}
protected
:
impl
:
:
MacroProps
fMacros
;
private
:
NumberFormatterSettings
(
)
=
default
;
friend
class
LocalizedNumberFormatter
;
friend
class
UnlocalizedNumberFormatter
;
}
;
class
U_I18N_API
UnlocalizedNumberFormatter
:
public
NumberFormatterSettings
<
UnlocalizedNumberFormatter
>
public
UMemory
{
public
:
LocalizedNumberFormatter
locale
(
const
icu
:
:
Locale
&
locale
)
const
;
UnlocalizedNumberFormatter
(
const
UnlocalizedNumberFormatter
&
other
)
:
UnlocalizedNumberFormatter
(
static_cast
<
const
NumberFormatterSettings
<
UnlocalizedNumberFormatter
>
&
>
(
other
)
)
{
}
private
:
UnlocalizedNumberFormatter
(
)
=
default
;
explicit
UnlocalizedNumberFormatter
(
const
NumberFormatterSettings
<
UnlocalizedNumberFormatter
>
&
other
)
;
friend
class
NumberFormatterSettings
<
UnlocalizedNumberFormatter
>
;
friend
class
NumberFormatter
;
}
;
class
U_I18N_API
LocalizedNumberFormatter
:
public
NumberFormatterSettings
<
LocalizedNumberFormatter
>
public
UMemory
{
public
:
FormattedNumber
formatInt
(
int64_t
value
UErrorCode
&
status
)
const
;
FormattedNumber
formatDouble
(
double
value
UErrorCode
&
status
)
const
;
FormattedNumber
formatDecimal
(
StringPiece
value
UErrorCode
&
status
)
const
;
LocalizedNumberFormatter
(
const
LocalizedNumberFormatter
&
other
)
:
LocalizedNumberFormatter
(
static_cast
<
const
NumberFormatterSettings
<
LocalizedNumberFormatter
>
&
>
(
other
)
)
{
}
~
LocalizedNumberFormatter
(
)
;
private
:
const
impl
:
:
NumberFormatterImpl
*
fCompiled
{
nullptr
}
;
char
fUnsafeCallCount
[
8
]
{
}
;
LocalizedNumberFormatter
(
)
=
default
;
explicit
LocalizedNumberFormatter
(
const
NumberFormatterSettings
<
LocalizedNumberFormatter
>
&
other
)
;
LocalizedNumberFormatter
(
const
impl
:
:
MacroProps
&
macros
const
Locale
&
locale
)
;
FormattedNumber
formatImpl
(
impl
:
:
NumberFormatterResults
*
results
UErrorCode
&
status
)
const
;
friend
class
NumberFormatterSettings
<
UnlocalizedNumberFormatter
>
;
friend
class
NumberFormatterSettings
<
LocalizedNumberFormatter
>
;
friend
class
UnlocalizedNumberFormatter
;
}
;
class
U_I18N_API
FormattedNumber
:
public
UMemory
{
public
:
UnicodeString
toString
(
)
const
;
Appendable
&
appendTo
(
Appendable
&
appendable
)
;
void
populateFieldPosition
(
FieldPosition
&
fieldPosition
UErrorCode
&
status
)
;
void
populateFieldPositionIterator
(
FieldPositionIterator
&
iterator
UErrorCode
&
status
)
;
~
FormattedNumber
(
)
;
private
:
const
impl
:
:
NumberFormatterResults
*
fResults
;
UErrorCode
fErrorCode
;
explicit
FormattedNumber
(
impl
:
:
NumberFormatterResults
*
results
)
:
fResults
(
results
)
fErrorCode
(
U_ZERO_ERROR
)
{
}
;
explicit
FormattedNumber
(
UErrorCode
errorCode
)
:
fResults
(
nullptr
)
fErrorCode
(
errorCode
)
{
}
;
friend
class
LocalizedNumberFormatter
;
}
;
class
U_I18N_API
NumberFormatter
final
{
public
:
static
UnlocalizedNumberFormatter
with
(
)
;
static
LocalizedNumberFormatter
withLocale
(
const
Locale
&
locale
)
;
NumberFormatter
(
)
=
delete
;
}
;
}
U_NAMESPACE_END
#
endif
#
endif
#
endif
