#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
taiwncal
.
h
"
#
include
"
gregoimp
.
h
"
#
include
"
unicode
/
gregocal
.
h
"
#
include
"
umutex
.
h
"
#
include
<
float
.
h
>
U_NAMESPACE_BEGIN
UOBJECT_DEFINE_RTTI_IMPLEMENTATION
(
TaiwanCalendar
)
static
const
int32_t
kTaiwanEraStart
=
1911
;
static
const
int32_t
kGregorianEpoch
=
1970
;
TaiwanCalendar
:
:
TaiwanCalendar
(
const
Locale
&
aLocale
UErrorCode
&
success
)
:
GregorianCalendar
(
aLocale
success
)
{
}
TaiwanCalendar
:
:
~
TaiwanCalendar
(
)
{
}
TaiwanCalendar
:
:
TaiwanCalendar
(
const
TaiwanCalendar
&
source
)
:
GregorianCalendar
(
source
)
{
}
TaiwanCalendar
*
TaiwanCalendar
:
:
clone
(
)
const
{
return
new
TaiwanCalendar
(
*
this
)
;
}
const
char
*
TaiwanCalendar
:
:
getType
(
)
const
{
return
"
roc
"
;
}
int32_t
TaiwanCalendar
:
:
handleGetExtendedYear
(
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
if
(
newerField
(
UCAL_EXTENDED_YEAR
UCAL_YEAR
)
=
=
UCAL_EXTENDED_YEAR
&
&
newerField
(
UCAL_EXTENDED_YEAR
UCAL_ERA
)
=
=
UCAL_EXTENDED_YEAR
)
{
return
internalGet
(
UCAL_EXTENDED_YEAR
kGregorianEpoch
)
;
}
int32_t
era
=
internalGet
(
UCAL_ERA
MINGUO
)
;
int32_t
year
=
internalGet
(
UCAL_YEAR
1
)
;
switch
(
era
)
{
case
MINGUO
:
if
(
uprv_add32_overflow
(
year
kTaiwanEraStart
&
year
)
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
return
year
;
case
BEFORE_MINGUO
:
if
(
uprv_add32_overflow
(
1
+
kTaiwanEraStart
-
year
&
year
)
)
{
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
return
year
;
default
:
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
}
void
TaiwanCalendar
:
:
handleComputeFields
(
int32_t
julianDay
UErrorCode
&
status
)
{
GregorianCalendar
:
:
handleComputeFields
(
julianDay
status
)
;
int32_t
y
=
internalGet
(
UCAL_EXTENDED_YEAR
)
-
kTaiwanEraStart
;
if
(
y
>
0
)
{
internalSet
(
UCAL_ERA
MINGUO
)
;
internalSet
(
UCAL_YEAR
y
)
;
}
else
{
internalSet
(
UCAL_ERA
BEFORE_MINGUO
)
;
internalSet
(
UCAL_YEAR
1
-
y
)
;
}
}
int32_t
TaiwanCalendar
:
:
handleGetLimit
(
UCalendarDateFields
field
ELimitType
limitType
)
const
{
if
(
field
!
=
UCAL_ERA
)
{
return
GregorianCalendar
:
:
handleGetLimit
(
field
limitType
)
;
}
if
(
limitType
=
=
UCAL_LIMIT_MINIMUM
|
|
limitType
=
=
UCAL_LIMIT_GREATEST_MINIMUM
)
{
return
BEFORE_MINGUO
;
}
return
MINGUO
;
}
IMPL_SYSTEM_DEFAULT_CENTURY
(
TaiwanCalendar
"
calendar
=
roc
"
)
U_NAMESPACE_END
#
endif
