#
include
"
utypeinfo
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_FORMATTING
#
include
"
unicode
/
measfmt
.
h
"
#
include
"
unicode
/
numfmt
.
h
"
#
include
"
currfmt
.
h
"
#
include
"
unicode
/
localpointer
.
h
"
#
include
"
resource
.
h
"
#
include
"
unicode
/
simpleformatter
.
h
"
#
include
"
quantityformatter
.
h
"
#
include
"
unicode
/
plurrule
.
h
"
#
include
"
unicode
/
decimfmt
.
h
"
#
include
"
uresimp
.
h
"
#
include
"
unicode
/
ures
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
ureslocs
.
h
"
#
include
"
cstring
.
h
"
#
include
"
mutex
.
h
"
#
include
"
ucln_in
.
h
"
#
include
"
unicode
/
listformatter
.
h
"
#
include
"
charstr
.
h
"
#
include
"
unicode
/
putil
.
h
"
#
include
"
unicode
/
smpdtfmt
.
h
"
#
include
"
uassert
.
h
"
#
include
"
sharednumberformat
.
h
"
#
include
"
sharedpluralrules
.
h
"
#
include
"
standardplural
.
h
"
#
include
"
unifiedcache
.
h
"
U_NAMESPACE_BEGIN
static
constexpr
int32_t
PER_UNIT_INDEX
=
StandardPlural
:
:
COUNT
;
static
constexpr
int32_t
PATTERN_COUNT
=
PER_UNIT_INDEX
+
1
;
static
constexpr
int32_t
MEAS_UNIT_COUNT
=
138
;
static
constexpr
int32_t
WIDTH_INDEX_COUNT
=
UMEASFMT_WIDTH_NARROW
+
1
;
UOBJECT_DEFINE_RTTI_IMPLEMENTATION
(
MeasureFormat
)
class
NumericDateFormatters
:
public
UMemory
{
public
:
SimpleDateFormat
hourMinute
;
SimpleDateFormat
minuteSecond
;
SimpleDateFormat
hourMinuteSecond
;
NumericDateFormatters
(
const
UnicodeString
&
hm
const
UnicodeString
&
ms
const
UnicodeString
&
hms
UErrorCode
&
status
)
:
hourMinute
(
hm
status
)
minuteSecond
(
ms
status
)
hourMinuteSecond
(
hms
status
)
{
const
TimeZone
*
gmt
=
TimeZone
:
:
getGMT
(
)
;
hourMinute
.
setTimeZone
(
*
gmt
)
;
minuteSecond
.
setTimeZone
(
*
gmt
)
;
hourMinuteSecond
.
setTimeZone
(
*
gmt
)
;
}
private
:
NumericDateFormatters
(
const
NumericDateFormatters
&
other
)
;
NumericDateFormatters
&
operator
=
(
const
NumericDateFormatters
&
other
)
;
}
;
static
UMeasureFormatWidth
getRegularWidth
(
UMeasureFormatWidth
width
)
{
if
(
width
>
=
WIDTH_INDEX_COUNT
)
{
return
UMEASFMT_WIDTH_NARROW
;
}
return
width
;
}
class
MeasureFormatCacheData
:
public
SharedObject
{
public
:
UMeasureFormatWidth
widthFallback
[
WIDTH_INDEX_COUNT
]
;
SimpleFormatter
*
patterns
[
MEAS_UNIT_COUNT
]
[
WIDTH_INDEX_COUNT
]
[
PATTERN_COUNT
]
;
const
UChar
*
dnams
[
MEAS_UNIT_COUNT
]
[
WIDTH_INDEX_COUNT
]
;
SimpleFormatter
perFormatters
[
WIDTH_INDEX_COUNT
]
;
MeasureFormatCacheData
(
)
;
virtual
~
MeasureFormatCacheData
(
)
;
UBool
hasPerFormatter
(
int32_t
width
)
const
{
return
perFormatters
[
width
]
.
getArgumentLimit
(
)
=
=
2
;
}
void
adoptCurrencyFormat
(
int32_t
widthIndex
NumberFormat
*
nfToAdopt
)
{
delete
currencyFormats
[
widthIndex
]
;
currencyFormats
[
widthIndex
]
=
nfToAdopt
;
}
const
NumberFormat
*
getCurrencyFormat
(
UMeasureFormatWidth
width
)
const
{
return
currencyFormats
[
getRegularWidth
(
width
)
]
;
}
void
adoptIntegerFormat
(
NumberFormat
*
nfToAdopt
)
{
delete
integerFormat
;
integerFormat
=
nfToAdopt
;
}
const
NumberFormat
*
getIntegerFormat
(
)
const
{
return
integerFormat
;
}
void
adoptNumericDateFormatters
(
NumericDateFormatters
*
formattersToAdopt
)
{
delete
numericDateFormatters
;
numericDateFormatters
=
formattersToAdopt
;
}
const
NumericDateFormatters
*
getNumericDateFormatters
(
)
const
{
return
numericDateFormatters
;
}
private
:
NumberFormat
*
currencyFormats
[
WIDTH_INDEX_COUNT
]
;
NumberFormat
*
integerFormat
;
NumericDateFormatters
*
numericDateFormatters
;
MeasureFormatCacheData
(
const
MeasureFormatCacheData
&
other
)
;
MeasureFormatCacheData
&
operator
=
(
const
MeasureFormatCacheData
&
other
)
;
}
;
MeasureFormatCacheData
:
:
MeasureFormatCacheData
(
)
:
integerFormat
(
nullptr
)
numericDateFormatters
(
nullptr
)
{
U_ASSERT
(
MEAS_UNIT_COUNT
=
=
MeasureUnit
:
:
getIndexCount
(
)
)
;
for
(
int32_t
i
=
0
;
i
<
WIDTH_INDEX_COUNT
;
+
+
i
)
{
widthFallback
[
i
]
=
UMEASFMT_WIDTH_COUNT
;
}
memset
(
&
patterns
[
0
]
[
0
]
[
0
]
0
sizeof
(
patterns
)
)
;
memset
(
&
dnams
[
0
]
[
0
]
0
sizeof
(
dnams
)
)
;
memset
(
currencyFormats
0
sizeof
(
currencyFormats
)
)
;
}
MeasureFormatCacheData
:
:
~
MeasureFormatCacheData
(
)
{
for
(
int32_t
i
=
0
;
i
<
UPRV_LENGTHOF
(
currencyFormats
)
;
+
+
i
)
{
delete
currencyFormats
[
i
]
;
}
for
(
int32_t
i
=
0
;
i
<
MEAS_UNIT_COUNT
;
+
+
i
)
{
for
(
int32_t
j
=
0
;
j
<
WIDTH_INDEX_COUNT
;
+
+
j
)
{
for
(
int32_t
k
=
0
;
k
<
PATTERN_COUNT
;
+
+
k
)
{
delete
patterns
[
i
]
[
j
]
[
k
]
;
}
}
}
delete
integerFormat
;
delete
numericDateFormatters
;
}
static
UBool
isCurrency
(
const
MeasureUnit
&
unit
)
{
return
(
uprv_strcmp
(
unit
.
getType
(
)
"
currency
"
)
=
=
0
)
;
}
static
UBool
getString
(
const
UResourceBundle
*
resource
UnicodeString
&
result
UErrorCode
&
status
)
{
int32_t
len
=
0
;
const
UChar
*
resStr
=
ures_getString
(
resource
&
len
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
FALSE
;
}
result
.
setTo
(
TRUE
resStr
len
)
;
return
TRUE
;
}
namespace
{
static
const
UChar
g_LOCALE_units
[
]
=
{
0x2F
0x4C
0x4F
0x43
0x41
0x4C
0x45
0x2F
0x75
0x6E
0x69
0x74
0x73
}
;
static
const
UChar
gShort
[
]
=
{
0x53
0x68
0x6F
0x72
0x74
}
;
static
const
UChar
gNarrow
[
]
=
{
0x4E
0x61
0x72
0x72
0x6F
0x77
}
;
struct
UnitDataSink
:
public
ResourceSink
{
MeasureFormatCacheData
&
cacheData
;
UMeasureFormatWidth
width
;
const
char
*
type
;
int32_t
unitIndex
;
UnitDataSink
(
MeasureFormatCacheData
&
outputData
)
:
cacheData
(
outputData
)
width
(
UMEASFMT_WIDTH_COUNT
)
type
(
NULL
)
unitIndex
(
0
)
{
}
~
UnitDataSink
(
)
;
void
setFormatterIfAbsent
(
int32_t
index
const
ResourceValue
&
value
int32_t
minPlaceholders
UErrorCode
&
errorCode
)
{
U_ASSERT
(
unitIndex
<
MEAS_UNIT_COUNT
)
;
U_ASSERT
(
width
<
WIDTH_INDEX_COUNT
)
;
U_ASSERT
(
index
<
PATTERN_COUNT
)
;
SimpleFormatter
*
*
patterns
=
&
cacheData
.
patterns
[
unitIndex
]
[
width
]
[
0
]
;
if
(
U_SUCCESS
(
errorCode
)
&
&
patterns
[
index
]
=
=
NULL
)
{
if
(
minPlaceholders
>
=
0
)
{
patterns
[
index
]
=
new
SimpleFormatter
(
value
.
getUnicodeString
(
errorCode
)
minPlaceholders
1
errorCode
)
;
}
if
(
U_SUCCESS
(
errorCode
)
&
&
patterns
[
index
]
=
=
NULL
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
}
}
}
void
setDnamIfAbsent
(
const
ResourceValue
&
value
UErrorCode
&
errorCode
)
{
U_ASSERT
(
unitIndex
<
MEAS_UNIT_COUNT
)
;
U_ASSERT
(
width
<
WIDTH_INDEX_COUNT
)
;
if
(
cacheData
.
dnams
[
unitIndex
]
[
width
]
=
=
NULL
)
{
int32_t
length
;
cacheData
.
dnams
[
unitIndex
]
[
width
]
=
value
.
getString
(
length
errorCode
)
;
}
}
void
consumePattern
(
const
char
*
key
const
ResourceValue
&
value
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
if
(
uprv_strcmp
(
key
"
dnam
"
)
=
=
0
)
{
setDnamIfAbsent
(
value
errorCode
)
;
}
else
if
(
uprv_strcmp
(
key
"
per
"
)
=
=
0
)
{
setFormatterIfAbsent
(
PER_UNIT_INDEX
value
1
errorCode
)
;
}
else
{
setFormatterIfAbsent
(
StandardPlural
:
:
indexFromString
(
key
errorCode
)
value
0
errorCode
)
;
}
}
void
consumeSubtypeTable
(
const
char
*
key
ResourceValue
&
value
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
unitIndex
=
MeasureUnit
:
:
internalGetIndexForTypeAndSubtype
(
type
key
)
;
if
(
unitIndex
<
0
)
{
return
;
}
if
(
value
.
getType
(
)
=
=
URES_TABLE
)
{
ResourceTable
patternTableTable
=
value
.
getTable
(
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
for
(
int
i
=
0
;
patternTableTable
.
getKeyAndValue
(
i
key
value
)
;
+
+
i
)
{
consumePattern
(
key
value
errorCode
)
;
}
}
else
{
return
;
}
}
void
consumeCompoundPattern
(
const
char
*
key
const
ResourceValue
&
value
UErrorCode
&
errorCode
)
{
if
(
U_SUCCESS
(
errorCode
)
&
&
uprv_strcmp
(
key
"
per
"
)
=
=
0
)
{
cacheData
.
perFormatters
[
width
]
.
applyPatternMinMaxArguments
(
value
.
getUnicodeString
(
errorCode
)
2
2
errorCode
)
;
}
}
void
consumeUnitTypesTable
(
const
char
*
key
ResourceValue
&
value
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
if
(
uprv_strcmp
(
key
"
currency
"
)
=
=
0
)
{
}
else
if
(
uprv_strcmp
(
key
"
compound
"
)
=
=
0
)
{
if
(
!
cacheData
.
hasPerFormatter
(
width
)
)
{
ResourceTable
compoundTable
=
value
.
getTable
(
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
for
(
int
i
=
0
;
compoundTable
.
getKeyAndValue
(
i
key
value
)
;
+
+
i
)
{
consumeCompoundPattern
(
key
value
errorCode
)
;
}
}
}
else
if
(
uprv_strcmp
(
key
"
coordinate
"
)
=
=
0
)
{
}
else
{
type
=
key
;
ResourceTable
subtypeTable
=
value
.
getTable
(
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
for
(
int
i
=
0
;
subtypeTable
.
getKeyAndValue
(
i
key
value
)
;
+
+
i
)
{
consumeSubtypeTable
(
key
value
errorCode
)
;
}
}
}
void
consumeAlias
(
const
char
*
key
const
ResourceValue
&
value
UErrorCode
&
errorCode
)
{
UMeasureFormatWidth
sourceWidth
=
widthFromKey
(
key
)
;
if
(
sourceWidth
=
=
UMEASFMT_WIDTH_COUNT
)
{
return
;
}
UMeasureFormatWidth
targetWidth
=
widthFromAlias
(
value
errorCode
)
;
if
(
targetWidth
=
=
UMEASFMT_WIDTH_COUNT
)
{
errorCode
=
U_INVALID_FORMAT_ERROR
;
return
;
}
if
(
cacheData
.
widthFallback
[
targetWidth
]
!
=
UMEASFMT_WIDTH_COUNT
)
{
errorCode
=
U_INVALID_FORMAT_ERROR
;
return
;
}
cacheData
.
widthFallback
[
sourceWidth
]
=
targetWidth
;
}
void
consumeTable
(
const
char
*
key
ResourceValue
&
value
UErrorCode
&
errorCode
)
{
if
(
U_SUCCESS
(
errorCode
)
&
&
(
width
=
widthFromKey
(
key
)
)
!
=
UMEASFMT_WIDTH_COUNT
)
{
ResourceTable
unitTypesTable
=
value
.
getTable
(
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
for
(
int
i
=
0
;
unitTypesTable
.
getKeyAndValue
(
i
key
value
)
;
+
+
i
)
{
consumeUnitTypesTable
(
key
value
errorCode
)
;
}
}
}
static
UMeasureFormatWidth
widthFromKey
(
const
char
*
key
)
{
if
(
uprv_strncmp
(
key
"
units
"
5
)
=
=
0
)
{
key
+
=
5
;
if
(
*
key
=
=
0
)
{
return
UMEASFMT_WIDTH_WIDE
;
}
else
if
(
uprv_strcmp
(
key
"
Short
"
)
=
=
0
)
{
return
UMEASFMT_WIDTH_SHORT
;
}
else
if
(
uprv_strcmp
(
key
"
Narrow
"
)
=
=
0
)
{
return
UMEASFMT_WIDTH_NARROW
;
}
}
return
UMEASFMT_WIDTH_COUNT
;
}
static
UMeasureFormatWidth
widthFromAlias
(
const
ResourceValue
&
value
UErrorCode
&
errorCode
)
{
int32_t
length
;
const
UChar
*
s
=
value
.
getAliasString
(
length
errorCode
)
;
if
(
U_SUCCESS
(
errorCode
)
&
&
length
>
=
13
&
&
u_memcmp
(
s
g_LOCALE_units
13
)
=
=
0
)
{
s
+
=
13
;
length
-
=
13
;
if
(
*
s
=
=
0
)
{
return
UMEASFMT_WIDTH_WIDE
;
}
else
if
(
u_strCompare
(
s
length
gShort
5
FALSE
)
=
=
0
)
{
return
UMEASFMT_WIDTH_SHORT
;
}
else
if
(
u_strCompare
(
s
length
gNarrow
6
FALSE
)
=
=
0
)
{
return
UMEASFMT_WIDTH_NARROW
;
}
}
return
UMEASFMT_WIDTH_COUNT
;
}
virtual
void
put
(
const
char
*
key
ResourceValue
&
value
UBool
UErrorCode
&
errorCode
)
{
ResourceTable
widthsTable
=
value
.
getTable
(
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
for
(
int
i
=
0
;
widthsTable
.
getKeyAndValue
(
i
key
value
)
;
+
+
i
)
{
if
(
value
.
getType
(
)
=
=
URES_ALIAS
)
{
consumeAlias
(
key
value
errorCode
)
;
}
else
{
consumeTable
(
key
value
errorCode
)
;
}
}
}
}
;
UnitDataSink
:
:
~
UnitDataSink
(
)
{
}
}
static
UBool
loadMeasureUnitData
(
const
UResourceBundle
*
resource
MeasureFormatCacheData
&
cacheData
UErrorCode
&
status
)
{
UnitDataSink
sink
(
cacheData
)
;
ures_getAllItemsWithFallback
(
resource
"
"
sink
status
)
;
return
U_SUCCESS
(
status
)
;
}
static
UnicodeString
loadNumericDateFormatterPattern
(
const
UResourceBundle
*
resource
const
char
*
pattern
UErrorCode
&
status
)
{
UnicodeString
result
;
if
(
U_FAILURE
(
status
)
)
{
return
result
;
}
CharString
chs
;
chs
.
append
(
"
durationUnits
"
status
)
.
append
(
"
/
"
status
)
.
append
(
pattern
status
)
;
LocalUResourceBundlePointer
patternBundle
(
ures_getByKeyWithFallback
(
resource
chs
.
data
(
)
NULL
&
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
return
result
;
}
getString
(
patternBundle
.
getAlias
(
)
result
status
)
;
int32_t
len
=
result
.
length
(
)
;
UChar
*
buffer
=
result
.
getBuffer
(
len
)
;
for
(
int32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
buffer
[
i
]
=
=
0x68
)
{
buffer
[
i
]
=
0x48
;
}
}
result
.
releaseBuffer
(
len
)
;
return
result
;
}
static
NumericDateFormatters
*
loadNumericDateFormatters
(
const
UResourceBundle
*
resource
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
NULL
;
}
NumericDateFormatters
*
result
=
new
NumericDateFormatters
(
loadNumericDateFormatterPattern
(
resource
"
hm
"
status
)
loadNumericDateFormatterPattern
(
resource
"
ms
"
status
)
loadNumericDateFormatterPattern
(
resource
"
hms
"
status
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
delete
result
;
return
NULL
;
}
return
result
;
}
template
<
>
U_I18N_API
const
MeasureFormatCacheData
*
LocaleCacheKey
<
MeasureFormatCacheData
>
:
:
createObject
(
const
void
*
UErrorCode
&
status
)
const
{
const
char
*
localeId
=
fLoc
.
getName
(
)
;
LocalUResourceBundlePointer
unitsBundle
(
ures_open
(
U_ICUDATA_UNIT
localeId
&
status
)
)
;
static
UNumberFormatStyle
currencyStyles
[
]
=
{
UNUM_CURRENCY_PLURAL
UNUM_CURRENCY_ISO
UNUM_CURRENCY
}
;
LocalPointer
<
MeasureFormatCacheData
>
result
(
new
MeasureFormatCacheData
(
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
NULL
;
}
if
(
!
loadMeasureUnitData
(
unitsBundle
.
getAlias
(
)
*
result
status
)
)
{
return
NULL
;
}
result
-
>
adoptNumericDateFormatters
(
loadNumericDateFormatters
(
unitsBundle
.
getAlias
(
)
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
return
NULL
;
}
for
(
int32_t
i
=
0
;
i
<
WIDTH_INDEX_COUNT
;
+
+
i
)
{
UErrorCode
localStatus
=
U_ZERO_ERROR
;
result
-
>
adoptCurrencyFormat
(
i
NumberFormat
:
:
createInstance
(
localeId
currencyStyles
[
i
]
localStatus
)
)
;
if
(
localStatus
!
=
U_ZERO_ERROR
)
{
status
=
localStatus
;
}
if
(
U_FAILURE
(
status
)
)
{
return
NULL
;
}
}
NumberFormat
*
inf
=
NumberFormat
:
:
createInstance
(
localeId
UNUM_DECIMAL
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
NULL
;
}
inf
-
>
setMaximumFractionDigits
(
0
)
;
DecimalFormat
*
decfmt
=
dynamic_cast
<
DecimalFormat
*
>
(
inf
)
;
if
(
decfmt
!
=
NULL
)
{
decfmt
-
>
setRoundingMode
(
DecimalFormat
:
:
kRoundDown
)
;
}
result
-
>
adoptIntegerFormat
(
inf
)
;
result
-
>
addRef
(
)
;
return
result
.
orphan
(
)
;
}
static
UBool
isTimeUnit
(
const
MeasureUnit
&
mu
const
char
*
tu
)
{
return
uprv_strcmp
(
mu
.
getType
(
)
"
duration
"
)
=
=
0
&
&
uprv_strcmp
(
mu
.
getSubtype
(
)
tu
)
=
=
0
;
}
static
int32_t
toHMS
(
const
Measure
*
measures
int32_t
measureCount
Formattable
*
hms
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
int32_t
result
=
0
;
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
for
(
int32_t
i
=
0
;
i
<
measureCount
;
+
+
i
)
{
if
(
isTimeUnit
(
measures
[
i
]
.
getUnit
(
)
"
hour
"
)
)
{
if
(
result
>
=
1
)
{
return
0
;
}
hms
[
0
]
=
measures
[
i
]
.
getNumber
(
)
;
if
(
hms
[
0
]
.
getDouble
(
)
<
0
.
0
)
{
return
0
;
}
result
|
=
1
;
}
else
if
(
isTimeUnit
(
measures
[
i
]
.
getUnit
(
)
"
minute
"
)
)
{
if
(
result
>
=
2
)
{
return
0
;
}
hms
[
1
]
=
measures
[
i
]
.
getNumber
(
)
;
if
(
hms
[
1
]
.
getDouble
(
)
<
0
.
0
)
{
return
0
;
}
result
|
=
2
;
}
else
if
(
isTimeUnit
(
measures
[
i
]
.
getUnit
(
)
"
second
"
)
)
{
if
(
result
>
=
4
)
{
return
0
;
}
hms
[
2
]
=
measures
[
i
]
.
getNumber
(
)
;
if
(
hms
[
2
]
.
getDouble
(
)
<
0
.
0
)
{
return
0
;
}
result
|
=
4
;
}
else
{
return
0
;
}
}
return
result
;
}
MeasureFormat
:
:
MeasureFormat
(
const
Locale
&
locale
UMeasureFormatWidth
w
UErrorCode
&
status
)
:
cache
(
NULL
)
numberFormat
(
NULL
)
pluralRules
(
NULL
)
width
(
w
)
listFormatter
(
NULL
)
{
initMeasureFormat
(
locale
w
NULL
status
)
;
}
MeasureFormat
:
:
MeasureFormat
(
const
Locale
&
locale
UMeasureFormatWidth
w
NumberFormat
*
nfToAdopt
UErrorCode
&
status
)
:
cache
(
NULL
)
numberFormat
(
NULL
)
pluralRules
(
NULL
)
width
(
w
)
listFormatter
(
NULL
)
{
initMeasureFormat
(
locale
w
nfToAdopt
status
)
;
}
MeasureFormat
:
:
MeasureFormat
(
const
MeasureFormat
&
other
)
:
Format
(
other
)
cache
(
other
.
cache
)
numberFormat
(
other
.
numberFormat
)
pluralRules
(
other
.
pluralRules
)
width
(
other
.
width
)
listFormatter
(
NULL
)
{
cache
-
>
addRef
(
)
;
numberFormat
-
>
addRef
(
)
;
pluralRules
-
>
addRef
(
)
;
if
(
other
.
listFormatter
!
=
NULL
)
{
listFormatter
=
new
ListFormatter
(
*
other
.
listFormatter
)
;
}
}
MeasureFormat
&
MeasureFormat
:
:
operator
=
(
const
MeasureFormat
&
other
)
{
if
(
this
=
=
&
other
)
{
return
*
this
;
}
Format
:
:
operator
=
(
other
)
;
SharedObject
:
:
copyPtr
(
other
.
cache
cache
)
;
SharedObject
:
:
copyPtr
(
other
.
numberFormat
numberFormat
)
;
SharedObject
:
:
copyPtr
(
other
.
pluralRules
pluralRules
)
;
width
=
other
.
width
;
delete
listFormatter
;
if
(
other
.
listFormatter
!
=
NULL
)
{
listFormatter
=
new
ListFormatter
(
*
other
.
listFormatter
)
;
}
else
{
listFormatter
=
NULL
;
}
return
*
this
;
}
MeasureFormat
:
:
MeasureFormat
(
)
:
cache
(
NULL
)
numberFormat
(
NULL
)
pluralRules
(
NULL
)
width
(
UMEASFMT_WIDTH_SHORT
)
listFormatter
(
NULL
)
{
}
MeasureFormat
:
:
~
MeasureFormat
(
)
{
if
(
cache
!
=
NULL
)
{
cache
-
>
removeRef
(
)
;
}
if
(
numberFormat
!
=
NULL
)
{
numberFormat
-
>
removeRef
(
)
;
}
if
(
pluralRules
!
=
NULL
)
{
pluralRules
-
>
removeRef
(
)
;
}
delete
listFormatter
;
}
UBool
MeasureFormat
:
:
operator
=
=
(
const
Format
&
other
)
const
{
if
(
this
=
=
&
other
)
{
return
TRUE
;
}
if
(
!
Format
:
:
operator
=
=
(
other
)
)
{
return
FALSE
;
}
const
MeasureFormat
&
rhs
=
static_cast
<
const
MeasureFormat
&
>
(
other
)
;
if
(
width
!
=
rhs
.
width
)
{
return
FALSE
;
}
if
(
cache
!
=
rhs
.
cache
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
const
char
*
localeId
=
getLocaleID
(
status
)
;
const
char
*
rhsLocaleId
=
rhs
.
getLocaleID
(
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
FALSE
;
}
if
(
uprv_strcmp
(
localeId
rhsLocaleId
)
!
=
0
)
{
return
FALSE
;
}
}
return
(
numberFormat
=
=
rhs
.
numberFormat
|
|
*
*
numberFormat
=
=
*
*
rhs
.
numberFormat
)
;
}
Format
*
MeasureFormat
:
:
clone
(
)
const
{
return
new
MeasureFormat
(
*
this
)
;
}
UnicodeString
&
MeasureFormat
:
:
format
(
const
Formattable
&
obj
UnicodeString
&
appendTo
FieldPosition
&
pos
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
return
appendTo
;
if
(
obj
.
getType
(
)
=
=
Formattable
:
:
kObject
)
{
const
UObject
*
formatObj
=
obj
.
getObject
(
)
;
const
Measure
*
amount
=
dynamic_cast
<
const
Measure
*
>
(
formatObj
)
;
if
(
amount
!
=
NULL
)
{
return
formatMeasure
(
*
amount
*
*
numberFormat
appendTo
pos
status
)
;
}
}
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
appendTo
;
}
void
MeasureFormat
:
:
parseObject
(
const
UnicodeString
&
Formattable
&
ParsePosition
&
)
const
{
return
;
}
UnicodeString
&
MeasureFormat
:
:
formatMeasurePerUnit
(
const
Measure
&
measure
const
MeasureUnit
&
perUnit
UnicodeString
&
appendTo
FieldPosition
&
pos
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
MeasureUnit
*
resolvedUnit
=
MeasureUnit
:
:
resolveUnitPerUnit
(
measure
.
getUnit
(
)
perUnit
)
;
if
(
resolvedUnit
!
=
NULL
)
{
Measure
newMeasure
(
measure
.
getNumber
(
)
resolvedUnit
status
)
;
return
formatMeasure
(
newMeasure
*
*
numberFormat
appendTo
pos
status
)
;
}
FieldPosition
fpos
(
pos
.
getField
(
)
)
;
UnicodeString
result
;
int32_t
offset
=
withPerUnitAndAppend
(
formatMeasure
(
measure
*
*
numberFormat
result
fpos
status
)
perUnit
appendTo
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
if
(
fpos
.
getBeginIndex
(
)
!
=
0
|
|
fpos
.
getEndIndex
(
)
!
=
0
)
{
pos
.
setBeginIndex
(
fpos
.
getBeginIndex
(
)
+
offset
)
;
pos
.
setEndIndex
(
fpos
.
getEndIndex
(
)
+
offset
)
;
}
return
appendTo
;
}
UnicodeString
&
MeasureFormat
:
:
formatMeasures
(
const
Measure
*
measures
int32_t
measureCount
UnicodeString
&
appendTo
FieldPosition
&
pos
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
if
(
measureCount
=
=
0
)
{
return
appendTo
;
}
if
(
measureCount
=
=
1
)
{
return
formatMeasure
(
measures
[
0
]
*
*
numberFormat
appendTo
pos
status
)
;
}
if
(
width
=
=
UMEASFMT_WIDTH_NUMERIC
)
{
Formattable
hms
[
3
]
;
int32_t
bitMap
=
toHMS
(
measures
measureCount
hms
status
)
;
if
(
bitMap
>
0
)
{
return
formatNumeric
(
hms
bitMap
appendTo
status
)
;
}
}
if
(
pos
.
getField
(
)
!
=
FieldPosition
:
:
DONT_CARE
)
{
return
formatMeasuresSlowTrack
(
measures
measureCount
appendTo
pos
status
)
;
}
UnicodeString
*
results
=
new
UnicodeString
[
measureCount
]
;
if
(
results
=
=
NULL
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
appendTo
;
}
for
(
int32_t
i
=
0
;
i
<
measureCount
;
+
+
i
)
{
const
NumberFormat
*
nf
=
cache
-
>
getIntegerFormat
(
)
;
if
(
i
=
=
measureCount
-
1
)
{
nf
=
numberFormat
-
>
get
(
)
;
}
formatMeasure
(
measures
[
i
]
*
nf
results
[
i
]
pos
status
)
;
}
listFormatter
-
>
format
(
results
measureCount
appendTo
status
)
;
delete
[
]
results
;
return
appendTo
;
}
UnicodeString
MeasureFormat
:
:
getUnitDisplayName
(
const
MeasureUnit
&
unit
UErrorCode
&
)
const
{
UMeasureFormatWidth
width
=
getRegularWidth
(
this
-
>
width
)
;
const
UChar
*
const
*
styleToDnam
=
cache
-
>
dnams
[
unit
.
getIndex
(
)
]
;
const
UChar
*
dnam
=
styleToDnam
[
width
]
;
if
(
dnam
=
=
NULL
)
{
int32_t
fallbackWidth
=
cache
-
>
widthFallback
[
width
]
;
dnam
=
styleToDnam
[
fallbackWidth
]
;
}
UnicodeString
result
;
if
(
dnam
=
=
NULL
)
{
result
.
setToBogus
(
)
;
}
else
{
result
.
setTo
(
dnam
-
1
)
;
}
return
result
;
}
void
MeasureFormat
:
:
initMeasureFormat
(
const
Locale
&
locale
UMeasureFormatWidth
w
NumberFormat
*
nfToAdopt
UErrorCode
&
status
)
{
static
const
char
*
listStyles
[
]
=
{
"
unit
"
"
unit
-
short
"
"
unit
-
narrow
"
}
;
LocalPointer
<
NumberFormat
>
nf
(
nfToAdopt
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
const
char
*
name
=
locale
.
getName
(
)
;
setLocaleIDs
(
name
name
)
;
UnifiedCache
:
:
getByLocale
(
locale
cache
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
const
SharedPluralRules
*
pr
=
PluralRules
:
:
createSharedInstance
(
locale
UPLURAL_TYPE_CARDINAL
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
SharedObject
:
:
copyPtr
(
pr
pluralRules
)
;
pr
-
>
removeRef
(
)
;
if
(
nf
.
isNull
(
)
)
{
const
SharedNumberFormat
*
shared
=
NumberFormat
:
:
createSharedInstance
(
locale
UNUM_DECIMAL
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
SharedObject
:
:
copyPtr
(
shared
numberFormat
)
;
shared
-
>
removeRef
(
)
;
}
else
{
adoptNumberFormat
(
nf
.
orphan
(
)
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
}
width
=
w
;
delete
listFormatter
;
listFormatter
=
ListFormatter
:
:
createInstance
(
locale
listStyles
[
getRegularWidth
(
width
)
]
status
)
;
}
void
MeasureFormat
:
:
adoptNumberFormat
(
NumberFormat
*
nfToAdopt
UErrorCode
&
status
)
{
LocalPointer
<
NumberFormat
>
nf
(
nfToAdopt
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
SharedNumberFormat
*
shared
=
new
SharedNumberFormat
(
nf
.
getAlias
(
)
)
;
if
(
shared
=
=
NULL
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
nf
.
orphan
(
)
;
SharedObject
:
:
copyPtr
(
shared
numberFormat
)
;
}
UBool
MeasureFormat
:
:
setMeasureFormatLocale
(
const
Locale
&
locale
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
|
|
locale
=
=
getLocale
(
status
)
)
{
return
FALSE
;
}
initMeasureFormat
(
locale
width
NULL
status
)
;
return
U_SUCCESS
(
status
)
;
}
const
NumberFormat
&
MeasureFormat
:
:
getNumberFormat
(
)
const
{
return
*
*
numberFormat
;
}
const
PluralRules
&
MeasureFormat
:
:
getPluralRules
(
)
const
{
return
*
*
pluralRules
;
}
Locale
MeasureFormat
:
:
getLocale
(
UErrorCode
&
status
)
const
{
return
Format
:
:
getLocale
(
ULOC_VALID_LOCALE
status
)
;
}
const
char
*
MeasureFormat
:
:
getLocaleID
(
UErrorCode
&
status
)
const
{
return
Format
:
:
getLocaleID
(
ULOC_VALID_LOCALE
status
)
;
}
UnicodeString
&
MeasureFormat
:
:
formatMeasure
(
const
Measure
&
measure
const
NumberFormat
&
nf
UnicodeString
&
appendTo
FieldPosition
&
pos
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
const
Formattable
&
amtNumber
=
measure
.
getNumber
(
)
;
const
MeasureUnit
&
amtUnit
=
measure
.
getUnit
(
)
;
if
(
isCurrency
(
amtUnit
)
)
{
UChar
isoCode
[
4
]
;
u_charsToUChars
(
amtUnit
.
getSubtype
(
)
isoCode
4
)
;
return
cache
-
>
getCurrencyFormat
(
width
)
-
>
format
(
new
CurrencyAmount
(
amtNumber
isoCode
status
)
appendTo
pos
status
)
;
}
UnicodeString
formattedNumber
;
StandardPlural
:
:
Form
pluralForm
=
QuantityFormatter
:
:
selectPlural
(
amtNumber
nf
*
*
pluralRules
formattedNumber
pos
status
)
;
const
SimpleFormatter
*
formatter
=
getPluralFormatter
(
amtUnit
width
pluralForm
status
)
;
return
QuantityFormatter
:
:
format
(
*
formatter
formattedNumber
appendTo
pos
status
)
;
}
UnicodeString
&
MeasureFormat
:
:
formatNumeric
(
const
Formattable
*
hms
int32_t
bitMap
UnicodeString
&
appendTo
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
UDate
millis
=
(
UDate
)
(
(
(
uprv_trunc
(
hms
[
0
]
.
getDouble
(
status
)
)
*
60
.
0
+
uprv_trunc
(
hms
[
1
]
.
getDouble
(
status
)
)
)
*
60
.
0
+
uprv_trunc
(
hms
[
2
]
.
getDouble
(
status
)
)
)
*
1000
.
0
)
;
switch
(
bitMap
)
{
case
5
:
case
7
:
return
formatNumeric
(
millis
cache
-
>
getNumericDateFormatters
(
)
-
>
hourMinuteSecond
UDAT_SECOND_FIELD
hms
[
2
]
appendTo
status
)
;
break
;
case
6
:
return
formatNumeric
(
millis
cache
-
>
getNumericDateFormatters
(
)
-
>
minuteSecond
UDAT_SECOND_FIELD
hms
[
2
]
appendTo
status
)
;
break
;
case
3
:
return
formatNumeric
(
millis
cache
-
>
getNumericDateFormatters
(
)
-
>
hourMinute
UDAT_MINUTE_FIELD
hms
[
1
]
appendTo
status
)
;
break
;
default
:
status
=
U_INTERNAL_PROGRAM_ERROR
;
return
appendTo
;
break
;
}
return
appendTo
;
}
static
void
appendRange
(
const
UnicodeString
&
src
int32_t
start
int32_t
end
UnicodeString
&
dest
)
{
dest
.
append
(
src
start
end
-
start
)
;
}
static
void
appendRange
(
const
UnicodeString
&
src
int32_t
end
UnicodeString
&
dest
)
{
dest
.
append
(
src
end
src
.
length
(
)
-
end
)
;
}
UnicodeString
&
MeasureFormat
:
:
formatNumeric
(
UDate
date
const
DateFormat
&
dateFmt
UDateFormatField
smallestField
const
Formattable
&
smallestAmount
UnicodeString
&
appendTo
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
UnicodeString
smallestAmountFormatted
;
FieldPosition
intFieldPosition
(
UNUM_INTEGER_FIELD
)
;
(
*
numberFormat
)
-
>
format
(
smallestAmount
smallestAmountFormatted
intFieldPosition
status
)
;
if
(
intFieldPosition
.
getBeginIndex
(
)
=
=
0
&
&
intFieldPosition
.
getEndIndex
(
)
=
=
0
)
{
status
=
U_INTERNAL_PROGRAM_ERROR
;
return
appendTo
;
}
FieldPosition
smallestFieldPosition
(
smallestField
)
;
UnicodeString
draft
;
dateFmt
.
format
(
date
draft
smallestFieldPosition
status
)
;
if
(
smallestFieldPosition
.
getBeginIndex
(
)
!
=
0
|
|
smallestFieldPosition
.
getEndIndex
(
)
!
=
0
)
{
appendRange
(
draft
0
smallestFieldPosition
.
getBeginIndex
(
)
appendTo
)
;
appendRange
(
smallestAmountFormatted
0
intFieldPosition
.
getBeginIndex
(
)
appendTo
)
;
appendRange
(
draft
smallestFieldPosition
.
getBeginIndex
(
)
smallestFieldPosition
.
getEndIndex
(
)
appendTo
)
;
appendRange
(
smallestAmountFormatted
intFieldPosition
.
getEndIndex
(
)
appendTo
)
;
appendRange
(
draft
smallestFieldPosition
.
getEndIndex
(
)
appendTo
)
;
}
else
{
appendTo
.
append
(
draft
)
;
}
return
appendTo
;
}
const
SimpleFormatter
*
MeasureFormat
:
:
getFormatterOrNull
(
const
MeasureUnit
&
unit
UMeasureFormatWidth
width
int32_t
index
)
const
{
width
=
getRegularWidth
(
width
)
;
SimpleFormatter
*
const
(
*
unitPatterns
)
[
PATTERN_COUNT
]
=
&
cache
-
>
patterns
[
unit
.
getIndex
(
)
]
[
0
]
;
if
(
unitPatterns
[
width
]
[
index
]
!
=
NULL
)
{
return
unitPatterns
[
width
]
[
index
]
;
}
int32_t
fallbackWidth
=
cache
-
>
widthFallback
[
width
]
;
if
(
fallbackWidth
!
=
UMEASFMT_WIDTH_COUNT
&
&
unitPatterns
[
fallbackWidth
]
[
index
]
!
=
NULL
)
{
return
unitPatterns
[
fallbackWidth
]
[
index
]
;
}
return
NULL
;
}
const
SimpleFormatter
*
MeasureFormat
:
:
getFormatter
(
const
MeasureUnit
&
unit
UMeasureFormatWidth
width
int32_t
index
UErrorCode
&
errorCode
)
const
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
NULL
;
}
const
SimpleFormatter
*
pattern
=
getFormatterOrNull
(
unit
width
index
)
;
if
(
pattern
=
=
NULL
)
{
errorCode
=
U_MISSING_RESOURCE_ERROR
;
}
return
pattern
;
}
const
SimpleFormatter
*
MeasureFormat
:
:
getPluralFormatter
(
const
MeasureUnit
&
unit
UMeasureFormatWidth
width
int32_t
index
UErrorCode
&
errorCode
)
const
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
NULL
;
}
if
(
index
!
=
StandardPlural
:
:
OTHER
)
{
const
SimpleFormatter
*
pattern
=
getFormatterOrNull
(
unit
width
index
)
;
if
(
pattern
!
=
NULL
)
{
return
pattern
;
}
}
return
getFormatter
(
unit
width
StandardPlural
:
:
OTHER
errorCode
)
;
}
const
SimpleFormatter
*
MeasureFormat
:
:
getPerFormatter
(
UMeasureFormatWidth
width
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
NULL
;
}
width
=
getRegularWidth
(
width
)
;
const
SimpleFormatter
*
perFormatters
=
cache
-
>
perFormatters
;
if
(
perFormatters
[
width
]
.
getArgumentLimit
(
)
=
=
2
)
{
return
&
perFormatters
[
width
]
;
}
int32_t
fallbackWidth
=
cache
-
>
widthFallback
[
width
]
;
if
(
fallbackWidth
!
=
UMEASFMT_WIDTH_COUNT
&
&
perFormatters
[
fallbackWidth
]
.
getArgumentLimit
(
)
=
=
2
)
{
return
&
perFormatters
[
fallbackWidth
]
;
}
status
=
U_MISSING_RESOURCE_ERROR
;
return
NULL
;
}
int32_t
MeasureFormat
:
:
withPerUnitAndAppend
(
const
UnicodeString
&
formatted
const
MeasureUnit
&
perUnit
UnicodeString
&
appendTo
UErrorCode
&
status
)
const
{
int32_t
offset
=
-
1
;
if
(
U_FAILURE
(
status
)
)
{
return
offset
;
}
const
SimpleFormatter
*
perUnitFormatter
=
getFormatterOrNull
(
perUnit
width
PER_UNIT_INDEX
)
;
if
(
perUnitFormatter
!
=
NULL
)
{
const
UnicodeString
*
params
[
]
=
{
&
formatted
}
;
perUnitFormatter
-
>
formatAndAppend
(
params
UPRV_LENGTHOF
(
params
)
appendTo
&
offset
1
status
)
;
return
offset
;
}
const
SimpleFormatter
*
perFormatter
=
getPerFormatter
(
width
status
)
;
const
SimpleFormatter
*
pattern
=
getPluralFormatter
(
perUnit
width
StandardPlural
:
:
ONE
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
offset
;
}
UnicodeString
perUnitString
=
pattern
-
>
getTextWithNoArguments
(
)
;
perUnitString
.
trim
(
)
;
const
UnicodeString
*
params
[
]
=
{
&
formatted
&
perUnitString
}
;
perFormatter
-
>
formatAndAppend
(
params
UPRV_LENGTHOF
(
params
)
appendTo
&
offset
1
status
)
;
return
offset
;
}
UnicodeString
&
MeasureFormat
:
:
formatMeasuresSlowTrack
(
const
Measure
*
measures
int32_t
measureCount
UnicodeString
&
appendTo
FieldPosition
&
pos
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
appendTo
;
}
FieldPosition
dontCare
(
FieldPosition
:
:
DONT_CARE
)
;
FieldPosition
fpos
(
pos
.
getField
(
)
)
;
UnicodeString
*
results
=
new
UnicodeString
[
measureCount
]
;
int32_t
fieldPositionFoundIndex
=
-
1
;
for
(
int32_t
i
=
0
;
i
<
measureCount
;
+
+
i
)
{
const
NumberFormat
*
nf
=
cache
-
>
getIntegerFormat
(
)
;
if
(
i
=
=
measureCount
-
1
)
{
nf
=
numberFormat
-
>
get
(
)
;
}
if
(
fieldPositionFoundIndex
=
=
-
1
)
{
formatMeasure
(
measures
[
i
]
*
nf
results
[
i
]
fpos
status
)
;
if
(
U_FAILURE
(
status
)
)
{
delete
[
]
results
;
return
appendTo
;
}
if
(
fpos
.
getBeginIndex
(
)
!
=
0
|
|
fpos
.
getEndIndex
(
)
!
=
0
)
{
fieldPositionFoundIndex
=
i
;
}
}
else
{
formatMeasure
(
measures
[
i
]
*
nf
results
[
i
]
dontCare
status
)
;
}
}
int32_t
offset
;
listFormatter
-
>
format
(
results
measureCount
appendTo
fieldPositionFoundIndex
offset
status
)
;
if
(
U_FAILURE
(
status
)
)
{
delete
[
]
results
;
return
appendTo
;
}
if
(
offset
!
=
-
1
)
{
pos
.
setBeginIndex
(
fpos
.
getBeginIndex
(
)
+
offset
)
;
pos
.
setEndIndex
(
fpos
.
getEndIndex
(
)
+
offset
)
;
}
delete
[
]
results
;
return
appendTo
;
}
MeasureFormat
*
U_EXPORT2
MeasureFormat
:
:
createCurrencyFormat
(
const
Locale
&
locale
UErrorCode
&
ec
)
{
CurrencyFormat
*
fmt
=
NULL
;
if
(
U_SUCCESS
(
ec
)
)
{
fmt
=
new
CurrencyFormat
(
locale
ec
)
;
if
(
U_FAILURE
(
ec
)
)
{
delete
fmt
;
fmt
=
NULL
;
}
}
return
fmt
;
}
MeasureFormat
*
U_EXPORT2
MeasureFormat
:
:
createCurrencyFormat
(
UErrorCode
&
ec
)
{
if
(
U_FAILURE
(
ec
)
)
{
return
NULL
;
}
return
MeasureFormat
:
:
createCurrencyFormat
(
Locale
:
:
getDefault
(
)
ec
)
;
}
U_NAMESPACE_END
#
endif
