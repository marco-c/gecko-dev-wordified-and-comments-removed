#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
rep
.
h
"
#
if
!
UCONFIG_NO_TRANSLITERATION
#
include
"
unicode
/
translit
.
h
"
#
include
"
unicode
/
resbund
.
h
"
#
include
"
unicode
/
uniset
.
h
"
#
include
"
unicode
/
uscript
.
h
"
#
include
"
rbt
.
h
"
#
include
"
cpdtrans
.
h
"
#
include
"
nultrans
.
h
"
#
include
"
transreg
.
h
"
#
include
"
rbt_data
.
h
"
#
include
"
rbt_pars
.
h
"
#
include
"
tridpars
.
h
"
#
include
"
charstr
.
h
"
#
include
"
uassert
.
h
"
#
include
"
locutil
.
h
"
#
ifdef
DEBUG_MEM
#
include
<
stdio
.
h
>
#
endif
static
const
char16_t
LOCALE_SEP
=
95
;
static
const
char16_t
ANY
[
]
=
{
0x41
0x6E
0x79
0
}
;
static
const
char16_t
LAT
[
]
=
{
0x4C
0x61
0x74
0
}
;
#
define
NO_VARIANT
UnicodeString
(
)
#
define
SPECDAG_INIT_SIZE
149
#
define
VARIANT_LIST_INIT_SIZE
11
#
define
VARIANT_LIST_MAX_SIZE
31
#
define
AVAILABLE_IDS_INIT_SIZE
641
#
define
ANY_TARGETS_INIT_SIZE
125
#
define
LAT_TARGETS_INIT_SIZE
23
U_NAMESPACE_BEGIN
TransliteratorAlias
:
:
TransliteratorAlias
(
const
UnicodeString
&
theAliasID
const
UnicodeSet
*
cpdFilter
)
:
ID
(
)
aliasesOrRules
(
theAliasID
)
transes
(
nullptr
)
compoundFilter
(
cpdFilter
)
direction
(
UTRANS_FORWARD
)
type
(
TransliteratorAlias
:
:
SIMPLE
)
{
}
TransliteratorAlias
:
:
TransliteratorAlias
(
const
UnicodeString
&
theID
const
UnicodeString
&
idBlocks
UVector
*
adoptedTransliterators
const
UnicodeSet
*
cpdFilter
)
:
ID
(
theID
)
aliasesOrRules
(
idBlocks
)
transes
(
adoptedTransliterators
)
compoundFilter
(
cpdFilter
)
direction
(
UTRANS_FORWARD
)
type
(
TransliteratorAlias
:
:
COMPOUND
)
{
}
TransliteratorAlias
:
:
TransliteratorAlias
(
const
UnicodeString
&
theID
const
UnicodeString
&
rules
UTransDirection
dir
)
:
ID
(
theID
)
aliasesOrRules
(
rules
)
transes
(
nullptr
)
compoundFilter
(
nullptr
)
direction
(
dir
)
type
(
TransliteratorAlias
:
:
RULES
)
{
}
TransliteratorAlias
:
:
~
TransliteratorAlias
(
)
{
delete
transes
;
}
Transliterator
*
TransliteratorAlias
:
:
create
(
UParseError
&
pe
UErrorCode
&
ec
)
{
if
(
U_FAILURE
(
ec
)
)
{
return
nullptr
;
}
Transliterator
*
t
=
nullptr
;
switch
(
type
)
{
case
SIMPLE
:
t
=
Transliterator
:
:
createInstance
(
aliasesOrRules
UTRANS_FORWARD
pe
ec
)
;
if
(
U_FAILURE
(
ec
)
)
{
return
nullptr
;
}
if
(
compoundFilter
!
=
nullptr
)
t
-
>
adoptFilter
(
compoundFilter
-
>
clone
(
)
)
;
break
;
case
COMPOUND
:
{
int32_t
anonymousRBTs
=
transes
-
>
size
(
)
;
UnicodeString
noIDBlock
(
static_cast
<
char16_t
>
(
0xffff
)
)
;
noIDBlock
+
=
static_cast
<
char16_t
>
(
0xffff
)
;
int32_t
pos
=
aliasesOrRules
.
indexOf
(
noIDBlock
)
;
while
(
pos
>
=
0
)
{
pos
=
aliasesOrRules
.
indexOf
(
noIDBlock
pos
+
1
)
;
}
UVector
transliterators
(
uprv_deleteUObject
nullptr
ec
)
;
UnicodeString
idBlock
;
int32_t
blockSeparatorPos
=
aliasesOrRules
.
indexOf
(
static_cast
<
char16_t
>
(
0xffff
)
)
;
while
(
blockSeparatorPos
>
=
0
)
{
aliasesOrRules
.
extract
(
0
blockSeparatorPos
idBlock
)
;
aliasesOrRules
.
remove
(
0
blockSeparatorPos
+
1
)
;
if
(
!
idBlock
.
isEmpty
(
)
)
transliterators
.
adoptElement
(
Transliterator
:
:
createInstance
(
idBlock
UTRANS_FORWARD
pe
ec
)
ec
)
;
if
(
!
transes
-
>
isEmpty
(
)
)
transliterators
.
adoptElement
(
transes
-
>
orphanElementAt
(
0
)
ec
)
;
blockSeparatorPos
=
aliasesOrRules
.
indexOf
(
static_cast
<
char16_t
>
(
0xffff
)
)
;
}
if
(
!
aliasesOrRules
.
isEmpty
(
)
)
transliterators
.
adoptElement
(
Transliterator
:
:
createInstance
(
aliasesOrRules
UTRANS_FORWARD
pe
ec
)
ec
)
;
while
(
!
transes
-
>
isEmpty
(
)
)
transliterators
.
adoptElement
(
transes
-
>
orphanElementAt
(
0
)
ec
)
;
transliterators
.
setDeleter
(
nullptr
)
;
if
(
U_SUCCESS
(
ec
)
)
{
t
=
new
CompoundTransliterator
(
ID
transliterators
(
compoundFilter
?
compoundFilter
-
>
clone
(
)
:
nullptr
)
anonymousRBTs
pe
ec
)
;
if
(
t
=
=
nullptr
)
{
ec
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
}
else
{
for
(
int32_t
i
=
0
;
i
<
transliterators
.
size
(
)
;
i
+
+
)
delete
static_cast
<
Transliterator
*
>
(
transliterators
.
elementAt
(
i
)
)
;
}
}
break
;
case
RULES
:
UPRV_UNREACHABLE_EXIT
;
}
return
t
;
}
UBool
TransliteratorAlias
:
:
isRuleBased
(
)
const
{
return
type
=
=
RULES
;
}
void
TransliteratorAlias
:
:
parse
(
TransliteratorParser
&
parser
UParseError
&
pe
UErrorCode
&
ec
)
const
{
U_ASSERT
(
type
=
=
RULES
)
;
if
(
U_FAILURE
(
ec
)
)
{
return
;
}
parser
.
parse
(
aliasesOrRules
direction
pe
ec
)
;
}
class
TransliteratorSpec
:
public
UMemory
{
public
:
TransliteratorSpec
(
const
UnicodeString
&
spec
)
;
~
TransliteratorSpec
(
)
;
const
UnicodeString
&
get
(
)
const
;
UBool
hasFallback
(
)
const
;
const
UnicodeString
&
next
(
)
;
void
reset
(
)
;
UBool
isLocale
(
)
const
;
ResourceBundle
&
getBundle
(
)
const
;
operator
const
UnicodeString
&
(
)
const
{
return
get
(
)
;
}
const
UnicodeString
&
getTop
(
)
const
{
return
top
;
}
private
:
void
setupNext
(
)
;
UnicodeString
top
;
UnicodeString
spec
;
UnicodeString
nextSpec
;
UnicodeString
scriptName
;
UBool
isSpecLocale
;
UBool
isNextLocale
;
ResourceBundle
*
res
;
TransliteratorSpec
(
const
TransliteratorSpec
&
other
)
;
TransliteratorSpec
&
operator
=
(
const
TransliteratorSpec
&
other
)
;
}
;
TransliteratorSpec
:
:
TransliteratorSpec
(
const
UnicodeString
&
theSpec
)
:
top
(
theSpec
)
res
(
nullptr
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
Locale
topLoc
(
"
"
)
;
LocaleUtility
:
:
initLocaleFromName
(
theSpec
topLoc
)
;
if
(
!
topLoc
.
isBogus
(
)
)
{
res
=
new
ResourceBundle
(
U_ICUDATA_TRANSLIT
topLoc
status
)
;
if
(
res
=
=
nullptr
)
{
return
;
}
if
(
U_FAILURE
(
status
)
|
|
status
=
=
U_USING_DEFAULT_WARNING
)
{
delete
res
;
res
=
nullptr
;
}
}
status
=
U_ZERO_ERROR
;
static
const
int32_t
capacity
=
10
;
UScriptCode
script
[
capacity
]
=
{
USCRIPT_INVALID_CODE
}
;
int32_t
num
=
uscript_getCode
(
CharString
(
)
.
appendInvariantChars
(
theSpec
status
)
.
data
(
)
script
capacity
&
status
)
;
if
(
num
>
0
&
&
script
[
0
]
!
=
USCRIPT_INVALID_CODE
)
{
scriptName
=
UnicodeString
(
uscript_getName
(
script
[
0
]
)
-
1
US_INV
)
;
}
if
(
res
!
=
nullptr
)
{
UnicodeString
locStr
;
LocaleUtility
:
:
initNameFromLocale
(
topLoc
locStr
)
;
if
(
!
locStr
.
isBogus
(
)
)
{
top
=
locStr
;
}
}
else
if
(
scriptName
.
length
(
)
!
=
0
)
{
top
=
scriptName
;
}
reset
(
)
;
}
TransliteratorSpec
:
:
~
TransliteratorSpec
(
)
{
delete
res
;
}
UBool
TransliteratorSpec
:
:
hasFallback
(
)
const
{
return
nextSpec
.
length
(
)
!
=
0
;
}
void
TransliteratorSpec
:
:
reset
(
)
{
if
(
spec
!
=
top
)
{
spec
=
top
;
isSpecLocale
=
(
res
!
=
nullptr
)
;
setupNext
(
)
;
}
}
void
TransliteratorSpec
:
:
setupNext
(
)
{
isNextLocale
=
false
;
if
(
isSpecLocale
)
{
nextSpec
=
spec
;
int32_t
i
=
nextSpec
.
lastIndexOf
(
LOCALE_SEP
)
;
if
(
i
>
0
)
{
nextSpec
.
truncate
(
i
)
;
isNextLocale
=
true
;
}
else
{
nextSpec
=
scriptName
;
}
}
else
{
nextSpec
.
truncate
(
0
)
;
}
}
const
UnicodeString
&
TransliteratorSpec
:
:
next
(
)
{
spec
=
nextSpec
;
isSpecLocale
=
isNextLocale
;
setupNext
(
)
;
return
spec
;
}
const
UnicodeString
&
TransliteratorSpec
:
:
get
(
)
const
{
return
spec
;
}
UBool
TransliteratorSpec
:
:
isLocale
(
)
const
{
return
isSpecLocale
;
}
ResourceBundle
&
TransliteratorSpec
:
:
getBundle
(
)
const
{
return
*
res
;
}
#
ifdef
DEBUG_MEM
static
UVector
*
DEBUG_entries
=
nullptr
;
static
void
DEBUG_setup
(
)
{
if
(
DEBUG_entries
=
=
nullptr
)
{
UErrorCode
ec
=
U_ZERO_ERROR
;
DEBUG_entries
=
new
UVector
(
ec
)
;
}
}
static
int
DEBUG_findEntry
(
TransliteratorEntry
*
e
)
{
for
(
int
i
=
0
;
i
<
DEBUG_entries
-
>
size
(
)
;
+
+
i
)
{
if
(
e
=
=
(
TransliteratorEntry
*
)
DEBUG_entries
-
>
elementAt
(
i
)
)
{
return
i
;
}
}
return
-
1
;
}
static
void
DEBUG_newEntry
(
TransliteratorEntry
*
e
)
{
DEBUG_setup
(
)
;
if
(
DEBUG_findEntry
(
e
)
>
=
0
)
{
printf
(
"
ERROR
DEBUG_newEntry
duplicate
new
pointer
%
08X
\
n
"
e
)
;
return
;
}
UErrorCode
ec
=
U_ZERO_ERROR
;
DEBUG_entries
-
>
addElement
(
e
ec
)
;
}
static
void
DEBUG_delEntry
(
TransliteratorEntry
*
e
)
{
DEBUG_setup
(
)
;
int
i
=
DEBUG_findEntry
(
e
)
;
if
(
i
<
0
)
{
printf
(
"
ERROR
DEBUG_delEntry
possible
double
deletion
%
08X
\
n
"
e
)
;
return
;
}
DEBUG_entries
-
>
removeElementAt
(
i
)
;
}
static
void
DEBUG_useEntry
(
TransliteratorEntry
*
e
)
{
if
(
e
=
=
nullptr
)
return
;
DEBUG_setup
(
)
;
int
i
=
DEBUG_findEntry
(
e
)
;
if
(
i
<
0
)
{
printf
(
"
ERROR
DEBUG_useEntry
possible
dangling
pointer
%
08X
\
n
"
e
)
;
}
}
#
else
#
define
DEBUG_newEntry
(
x
)
#
define
DEBUG_delEntry
(
x
)
#
define
DEBUG_useEntry
(
x
)
#
endif
class
TransliteratorEntry
:
public
UMemory
{
public
:
enum
Type
{
RULES_FORWARD
RULES_REVERSE
LOCALE_RULES
PROTOTYPE
RBT_DATA
COMPOUND_RBT
ALIAS
FACTORY
NONE
}
entryType
;
UnicodeString
stringArg
;
int32_t
intArg
;
UnicodeSet
*
compoundFilter
;
union
{
Transliterator
*
prototype
;
TransliterationRuleData
*
data
;
UVector
*
dataVector
;
struct
{
Transliterator
:
:
Factory
function
;
Transliterator
:
:
Token
context
;
}
factory
;
}
u
;
TransliteratorEntry
(
)
;
~
TransliteratorEntry
(
)
;
void
adoptPrototype
(
Transliterator
*
adopted
)
;
void
setFactory
(
Transliterator
:
:
Factory
factory
Transliterator
:
:
Token
context
)
;
private
:
TransliteratorEntry
(
const
TransliteratorEntry
&
other
)
;
TransliteratorEntry
&
operator
=
(
const
TransliteratorEntry
&
other
)
;
}
;
TransliteratorEntry
:
:
TransliteratorEntry
(
)
{
u
.
prototype
=
nullptr
;
compoundFilter
=
nullptr
;
entryType
=
NONE
;
DEBUG_newEntry
(
this
)
;
}
TransliteratorEntry
:
:
~
TransliteratorEntry
(
)
{
DEBUG_delEntry
(
this
)
;
if
(
entryType
=
=
PROTOTYPE
)
{
delete
u
.
prototype
;
}
else
if
(
entryType
=
=
RBT_DATA
)
{
delete
u
.
data
;
}
else
if
(
entryType
=
=
COMPOUND_RBT
)
{
while
(
u
.
dataVector
!
=
nullptr
&
&
!
u
.
dataVector
-
>
isEmpty
(
)
)
delete
static_cast
<
TransliterationRuleData
*
>
(
u
.
dataVector
-
>
orphanElementAt
(
0
)
)
;
delete
u
.
dataVector
;
}
delete
compoundFilter
;
}
void
TransliteratorEntry
:
:
adoptPrototype
(
Transliterator
*
adopted
)
{
if
(
entryType
=
=
PROTOTYPE
)
{
delete
u
.
prototype
;
}
entryType
=
PROTOTYPE
;
u
.
prototype
=
adopted
;
}
void
TransliteratorEntry
:
:
setFactory
(
Transliterator
:
:
Factory
factory
Transliterator
:
:
Token
context
)
{
if
(
entryType
=
=
PROTOTYPE
)
{
delete
u
.
prototype
;
}
entryType
=
FACTORY
;
u
.
factory
.
function
=
factory
;
u
.
factory
.
context
=
context
;
}
U_CDECL_BEGIN
static
void
U_CALLCONV
deleteEntry
(
void
*
obj
)
{
delete
(
TransliteratorEntry
*
)
obj
;
}
U_CDECL_END
TransliteratorRegistry
:
:
TransliteratorRegistry
(
UErrorCode
&
status
)
:
registry
(
true
status
)
specDAG
(
true
SPECDAG_INIT_SIZE
status
)
variantList
(
VARIANT_LIST_INIT_SIZE
status
)
availableIDs
(
true
AVAILABLE_IDS_INIT_SIZE
status
)
{
registry
.
setValueDeleter
(
deleteEntry
)
;
variantList
.
setDeleter
(
uprv_deleteUObject
)
;
variantList
.
setComparer
(
uhash_compareCaselessUnicodeString
)
;
UnicodeString
*
emptyString
=
new
UnicodeString
(
)
;
if
(
emptyString
!
=
nullptr
)
{
variantList
.
adoptElement
(
emptyString
status
)
;
}
specDAG
.
setValueDeleter
(
uhash_deleteHashtable
)
;
}
TransliteratorRegistry
:
:
~
TransliteratorRegistry
(
)
{
}
Transliterator
*
TransliteratorRegistry
:
:
get
(
const
UnicodeString
&
ID
TransliteratorAlias
*
&
aliasReturn
UErrorCode
&
status
)
{
U_ASSERT
(
aliasReturn
=
=
nullptr
)
;
TransliteratorEntry
*
entry
=
find
(
ID
)
;
return
entry
=
=
nullptr
?
nullptr
:
instantiateEntry
(
ID
entry
aliasReturn
status
)
;
}
Transliterator
*
TransliteratorRegistry
:
:
reget
(
const
UnicodeString
&
ID
TransliteratorParser
&
parser
TransliteratorAlias
*
&
aliasReturn
UErrorCode
&
status
)
{
U_ASSERT
(
aliasReturn
=
=
nullptr
)
;
TransliteratorEntry
*
entry
=
find
(
ID
)
;
if
(
entry
=
=
nullptr
)
{
return
nullptr
;
}
if
(
entry
-
>
entryType
=
=
TransliteratorEntry
:
:
RULES_FORWARD
|
|
entry
-
>
entryType
=
=
TransliteratorEntry
:
:
RULES_REVERSE
|
|
entry
-
>
entryType
=
=
TransliteratorEntry
:
:
LOCALE_RULES
)
{
if
(
parser
.
idBlockVector
.
isEmpty
(
)
&
&
parser
.
dataVector
.
isEmpty
(
)
)
{
entry
-
>
u
.
data
=
nullptr
;
entry
-
>
entryType
=
TransliteratorEntry
:
:
ALIAS
;
entry
-
>
stringArg
=
UNICODE_STRING_SIMPLE
(
"
Any
-
nullptr
"
)
;
}
else
if
(
parser
.
idBlockVector
.
isEmpty
(
)
&
&
parser
.
dataVector
.
size
(
)
=
=
1
)
{
entry
-
>
u
.
data
=
static_cast
<
TransliterationRuleData
*
>
(
parser
.
dataVector
.
orphanElementAt
(
0
)
)
;
entry
-
>
entryType
=
TransliteratorEntry
:
:
RBT_DATA
;
}
else
if
(
parser
.
idBlockVector
.
size
(
)
=
=
1
&
&
parser
.
dataVector
.
isEmpty
(
)
)
{
entry
-
>
stringArg
=
*
static_cast
<
UnicodeString
*
>
(
parser
.
idBlockVector
.
elementAt
(
0
)
)
;
entry
-
>
compoundFilter
=
parser
.
orphanCompoundFilter
(
)
;
entry
-
>
entryType
=
TransliteratorEntry
:
:
ALIAS
;
}
else
{
entry
-
>
entryType
=
TransliteratorEntry
:
:
COMPOUND_RBT
;
entry
-
>
compoundFilter
=
parser
.
orphanCompoundFilter
(
)
;
entry
-
>
u
.
dataVector
=
new
UVector
(
status
)
;
entry
-
>
stringArg
.
remove
(
)
;
int32_t
limit
=
parser
.
idBlockVector
.
size
(
)
;
if
(
parser
.
dataVector
.
size
(
)
>
limit
)
limit
=
parser
.
dataVector
.
size
(
)
;
for
(
int32_t
i
=
0
;
i
<
limit
;
i
+
+
)
{
if
(
i
<
parser
.
idBlockVector
.
size
(
)
)
{
UnicodeString
*
idBlock
=
static_cast
<
UnicodeString
*
>
(
parser
.
idBlockVector
.
elementAt
(
i
)
)
;
if
(
!
idBlock
-
>
isEmpty
(
)
)
entry
-
>
stringArg
+
=
*
idBlock
;
}
if
(
!
parser
.
dataVector
.
isEmpty
(
)
)
{
TransliterationRuleData
*
data
=
static_cast
<
TransliterationRuleData
*
>
(
parser
.
dataVector
.
orphanElementAt
(
0
)
)
;
entry
-
>
u
.
dataVector
-
>
addElement
(
data
status
)
;
if
(
U_FAILURE
(
status
)
)
{
delete
data
;
}
entry
-
>
stringArg
+
=
static_cast
<
char16_t
>
(
0xffff
)
;
}
}
}
}
Transliterator
*
t
=
instantiateEntry
(
ID
entry
aliasReturn
status
)
;
return
t
;
}
void
TransliteratorRegistry
:
:
put
(
Transliterator
*
adoptedProto
UBool
visible
UErrorCode
&
ec
)
{
TransliteratorEntry
*
entry
=
new
TransliteratorEntry
(
)
;
if
(
entry
=
=
nullptr
)
{
ec
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
entry
-
>
adoptPrototype
(
adoptedProto
)
;
registerEntry
(
adoptedProto
-
>
getID
(
)
entry
visible
)
;
}
void
TransliteratorRegistry
:
:
put
(
const
UnicodeString
&
ID
Transliterator
:
:
Factory
factory
Transliterator
:
:
Token
context
UBool
visible
UErrorCode
&
ec
)
{
TransliteratorEntry
*
entry
=
new
TransliteratorEntry
(
)
;
if
(
entry
=
=
nullptr
)
{
ec
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
entry
-
>
setFactory
(
factory
context
)
;
registerEntry
(
ID
entry
visible
)
;
}
void
TransliteratorRegistry
:
:
put
(
const
UnicodeString
&
ID
const
UnicodeString
&
resourceName
UTransDirection
dir
UBool
readonlyResourceAlias
UBool
visible
UErrorCode
&
ec
)
{
TransliteratorEntry
*
entry
=
new
TransliteratorEntry
(
)
;
if
(
entry
=
=
nullptr
)
{
ec
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
entry
-
>
entryType
=
(
dir
=
=
UTRANS_FORWARD
)
?
TransliteratorEntry
:
:
RULES_FORWARD
:
TransliteratorEntry
:
:
RULES_REVERSE
;
if
(
readonlyResourceAlias
)
{
entry
-
>
stringArg
.
setTo
(
true
resourceName
.
getBuffer
(
)
-
1
)
;
}
else
{
entry
-
>
stringArg
=
resourceName
;
}
registerEntry
(
ID
entry
visible
)
;
}
void
TransliteratorRegistry
:
:
put
(
const
UnicodeString
&
ID
const
UnicodeString
&
alias
UBool
readonlyAliasAlias
UBool
visible
UErrorCode
&
)
{
TransliteratorEntry
*
entry
=
new
TransliteratorEntry
(
)
;
if
(
entry
!
=
nullptr
)
{
entry
-
>
entryType
=
TransliteratorEntry
:
:
ALIAS
;
if
(
readonlyAliasAlias
)
{
entry
-
>
stringArg
.
setTo
(
true
alias
.
getBuffer
(
)
-
1
)
;
}
else
{
entry
-
>
stringArg
=
alias
;
}
registerEntry
(
ID
entry
visible
)
;
}
}
void
TransliteratorRegistry
:
:
remove
(
const
UnicodeString
&
ID
)
{
UnicodeString
source
target
variant
;
UBool
sawSource
;
TransliteratorIDParser
:
:
IDtoSTV
(
ID
source
target
variant
sawSource
)
;
UnicodeString
id
;
TransliteratorIDParser
:
:
STVtoID
(
source
target
variant
id
)
;
registry
.
remove
(
id
)
;
removeSTV
(
source
target
variant
)
;
availableIDs
.
remove
(
id
)
;
}
int32_t
TransliteratorRegistry
:
:
countAvailableIDs
(
)
const
{
return
availableIDs
.
count
(
)
;
}
const
UnicodeString
&
TransliteratorRegistry
:
:
getAvailableID
(
int32_t
index
)
const
{
if
(
index
<
0
|
|
index
>
=
availableIDs
.
count
(
)
)
{
index
=
0
;
}
int32_t
pos
=
UHASH_FIRST
;
const
UHashElement
*
e
=
nullptr
;
while
(
index
-
-
>
=
0
)
{
e
=
availableIDs
.
nextElement
(
pos
)
;
if
(
e
=
=
nullptr
)
{
break
;
}
}
if
(
e
!
=
nullptr
)
{
return
*
static_cast
<
UnicodeString
*
>
(
e
-
>
key
.
pointer
)
;
}
static
UnicodeString
empty
;
return
empty
;
}
StringEnumeration
*
TransliteratorRegistry
:
:
getAvailableIDs
(
)
const
{
return
new
Enumeration
(
*
this
)
;
}
int32_t
TransliteratorRegistry
:
:
countAvailableSources
(
)
const
{
return
specDAG
.
count
(
)
;
}
UnicodeString
&
TransliteratorRegistry
:
:
getAvailableSource
(
int32_t
index
UnicodeString
&
result
)
const
{
int32_t
pos
=
UHASH_FIRST
;
const
UHashElement
*
e
=
nullptr
;
while
(
index
-
-
>
=
0
)
{
e
=
specDAG
.
nextElement
(
pos
)
;
if
(
e
=
=
nullptr
)
{
break
;
}
}
if
(
e
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
}
else
{
result
=
*
static_cast
<
UnicodeString
*
>
(
e
-
>
key
.
pointer
)
;
}
return
result
;
}
int32_t
TransliteratorRegistry
:
:
countAvailableTargets
(
const
UnicodeString
&
source
)
const
{
Hashtable
*
targets
=
static_cast
<
Hashtable
*
>
(
specDAG
.
get
(
source
)
)
;
return
(
targets
=
=
nullptr
)
?
0
:
targets
-
>
count
(
)
;
}
UnicodeString
&
TransliteratorRegistry
:
:
getAvailableTarget
(
int32_t
index
const
UnicodeString
&
source
UnicodeString
&
result
)
const
{
Hashtable
*
targets
=
static_cast
<
Hashtable
*
>
(
specDAG
.
get
(
source
)
)
;
if
(
targets
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
int32_t
pos
=
UHASH_FIRST
;
const
UHashElement
*
e
=
nullptr
;
while
(
index
-
-
>
=
0
)
{
e
=
targets
-
>
nextElement
(
pos
)
;
if
(
e
=
=
nullptr
)
{
break
;
}
}
if
(
e
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
}
else
{
result
=
*
static_cast
<
UnicodeString
*
>
(
e
-
>
key
.
pointer
)
;
}
return
result
;
}
int32_t
TransliteratorRegistry
:
:
countAvailableVariants
(
const
UnicodeString
&
source
const
UnicodeString
&
target
)
const
{
Hashtable
*
targets
=
static_cast
<
Hashtable
*
>
(
specDAG
.
get
(
source
)
)
;
if
(
targets
=
=
nullptr
)
{
return
0
;
}
uint32_t
varMask
=
targets
-
>
geti
(
target
)
;
int32_t
varCount
=
0
;
while
(
varMask
>
0
)
{
if
(
varMask
&
1
)
{
varCount
+
+
;
}
varMask
>
>
=
1
;
}
return
varCount
;
}
UnicodeString
&
TransliteratorRegistry
:
:
getAvailableVariant
(
int32_t
index
const
UnicodeString
&
source
const
UnicodeString
&
target
UnicodeString
&
result
)
const
{
Hashtable
*
targets
=
static_cast
<
Hashtable
*
>
(
specDAG
.
get
(
source
)
)
;
if
(
targets
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
uint32_t
varMask
=
targets
-
>
geti
(
target
)
;
int32_t
varCount
=
0
;
int32_t
varListIndex
=
0
;
while
(
varMask
>
0
)
{
if
(
varMask
&
1
)
{
if
(
varCount
=
=
index
)
{
UnicodeString
*
v
=
static_cast
<
UnicodeString
*
>
(
variantList
.
elementAt
(
varListIndex
)
)
;
if
(
v
!
=
nullptr
)
{
result
=
*
v
;
return
result
;
}
break
;
}
varCount
+
+
;
}
varMask
>
>
=
1
;
varListIndex
+
+
;
}
result
.
truncate
(
0
)
;
return
result
;
}
TransliteratorRegistry
:
:
Enumeration
:
:
Enumeration
(
const
TransliteratorRegistry
&
_reg
)
:
pos
(
UHASH_FIRST
)
size
(
_reg
.
availableIDs
.
count
(
)
)
reg
(
_reg
)
{
}
TransliteratorRegistry
:
:
Enumeration
:
:
~
Enumeration
(
)
{
}
int32_t
TransliteratorRegistry
:
:
Enumeration
:
:
count
(
UErrorCode
&
)
const
{
return
size
;
}
const
UnicodeString
*
TransliteratorRegistry
:
:
Enumeration
:
:
snext
(
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
nullptr
;
}
int32_t
n
=
reg
.
availableIDs
.
count
(
)
;
if
(
n
!
=
size
)
{
status
=
U_ENUM_OUT_OF_SYNC_ERROR
;
return
nullptr
;
}
const
UHashElement
*
element
=
reg
.
availableIDs
.
nextElement
(
pos
)
;
if
(
element
=
=
nullptr
)
{
return
nullptr
;
}
unistr
=
*
static_cast
<
const
UnicodeString
*
>
(
element
-
>
key
.
pointer
)
;
return
&
unistr
;
}
void
TransliteratorRegistry
:
:
Enumeration
:
:
reset
(
UErrorCode
&
)
{
pos
=
UHASH_FIRST
;
size
=
reg
.
availableIDs
.
count
(
)
;
}
UOBJECT_DEFINE_RTTI_IMPLEMENTATION
(
TransliteratorRegistry
:
:
Enumeration
)
void
TransliteratorRegistry
:
:
registerEntry
(
const
UnicodeString
&
source
const
UnicodeString
&
target
const
UnicodeString
&
variant
TransliteratorEntry
*
adopted
UBool
visible
)
{
UnicodeString
ID
;
UnicodeString
s
(
source
)
;
if
(
s
.
length
(
)
=
=
0
)
{
s
.
setTo
(
true
ANY
3
)
;
}
TransliteratorIDParser
:
:
STVtoID
(
source
target
variant
ID
)
;
registerEntry
(
ID
s
target
variant
adopted
visible
)
;
}
void
TransliteratorRegistry
:
:
registerEntry
(
const
UnicodeString
&
ID
TransliteratorEntry
*
adopted
UBool
visible
)
{
UnicodeString
source
target
variant
;
UBool
sawSource
;
TransliteratorIDParser
:
:
IDtoSTV
(
ID
source
target
variant
sawSource
)
;
UnicodeString
id
;
TransliteratorIDParser
:
:
STVtoID
(
source
target
variant
id
)
;
registerEntry
(
id
source
target
variant
adopted
visible
)
;
}
void
TransliteratorRegistry
:
:
registerEntry
(
const
UnicodeString
&
ID
const
UnicodeString
&
source
const
UnicodeString
&
target
const
UnicodeString
&
variant
TransliteratorEntry
*
adopted
UBool
visible
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
registry
.
put
(
ID
adopted
status
)
;
if
(
visible
)
{
registerSTV
(
source
target
variant
)
;
if
(
!
availableIDs
.
containsKey
(
ID
)
)
{
availableIDs
.
puti
(
ID
1
status
)
;
}
}
else
{
removeSTV
(
source
target
variant
)
;
availableIDs
.
remove
(
ID
)
;
}
}
void
TransliteratorRegistry
:
:
registerSTV
(
const
UnicodeString
&
source
const
UnicodeString
&
target
const
UnicodeString
&
variant
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
Hashtable
*
targets
=
static_cast
<
Hashtable
*
>
(
specDAG
.
get
(
source
)
)
;
if
(
targets
=
=
nullptr
)
{
int32_t
size
=
3
;
if
(
source
.
compare
(
ANY
3
)
=
=
0
)
{
size
=
ANY_TARGETS_INIT_SIZE
;
}
else
if
(
source
.
compare
(
LAT
3
)
=
=
0
)
{
size
=
LAT_TARGETS_INIT_SIZE
;
}
targets
=
new
Hashtable
(
true
size
status
)
;
if
(
U_FAILURE
(
status
)
|
|
targets
=
=
nullptr
)
{
return
;
}
specDAG
.
put
(
source
targets
status
)
;
}
int32_t
variantListIndex
=
variantList
.
indexOf
(
(
void
*
)
&
variant
0
)
;
if
(
variantListIndex
<
0
)
{
if
(
variantList
.
size
(
)
>
=
VARIANT_LIST_MAX_SIZE
)
{
return
;
}
UnicodeString
*
variantEntry
=
new
UnicodeString
(
variant
)
;
if
(
variantEntry
!
=
nullptr
)
{
variantList
.
adoptElement
(
variantEntry
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
variantListIndex
=
variantList
.
size
(
)
-
1
;
}
}
if
(
variantListIndex
<
0
)
{
return
;
}
}
uint32_t
addMask
=
1
<
<
variantListIndex
;
uint32_t
varMask
=
targets
-
>
geti
(
target
)
;
targets
-
>
puti
(
target
varMask
|
addMask
status
)
;
}
void
TransliteratorRegistry
:
:
removeSTV
(
const
UnicodeString
&
source
const
UnicodeString
&
target
const
UnicodeString
&
variant
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
Hashtable
*
targets
=
static_cast
<
Hashtable
*
>
(
specDAG
.
get
(
source
)
)
;
if
(
targets
=
=
nullptr
)
{
return
;
}
uint32_t
varMask
=
targets
-
>
geti
(
target
)
;
if
(
varMask
=
=
0
)
{
return
;
}
int32_t
variantListIndex
=
variantList
.
indexOf
(
(
void
*
)
&
variant
0
)
;
if
(
variantListIndex
<
0
)
{
return
;
}
int32_t
remMask
=
1
<
<
variantListIndex
;
varMask
&
=
(
~
remMask
)
;
if
(
varMask
!
=
0
)
{
targets
-
>
puti
(
target
varMask
status
)
;
}
else
{
targets
-
>
remove
(
target
)
;
if
(
targets
-
>
count
(
)
=
=
0
)
{
specDAG
.
remove
(
source
)
;
}
}
}
TransliteratorEntry
*
TransliteratorRegistry
:
:
findInDynamicStore
(
const
TransliteratorSpec
&
src
const
TransliteratorSpec
&
trg
const
UnicodeString
&
variant
)
const
{
UnicodeString
ID
;
TransliteratorIDParser
:
:
STVtoID
(
src
trg
variant
ID
)
;
TransliteratorEntry
*
e
=
static_cast
<
TransliteratorEntry
*
>
(
registry
.
get
(
ID
)
)
;
DEBUG_useEntry
(
e
)
;
return
e
;
}
TransliteratorEntry
*
TransliteratorRegistry
:
:
findInStaticStore
(
const
TransliteratorSpec
&
src
const
TransliteratorSpec
&
trg
const
UnicodeString
&
variant
)
{
TransliteratorEntry
*
entry
=
nullptr
;
if
(
src
.
isLocale
(
)
)
{
entry
=
findInBundle
(
src
trg
variant
UTRANS_FORWARD
)
;
}
else
if
(
trg
.
isLocale
(
)
)
{
entry
=
findInBundle
(
trg
src
variant
UTRANS_REVERSE
)
;
}
if
(
entry
!
=
nullptr
)
{
registerEntry
(
src
.
getTop
(
)
trg
.
getTop
(
)
variant
entry
false
)
;
}
return
entry
;
}
static
const
char16_t
TRANSLITERATE_TO
[
]
=
{
84
114
97
110
115
108
105
116
101
114
97
116
101
84
111
0
}
;
static
const
char16_t
TRANSLITERATE_FROM
[
]
=
{
84
114
97
110
115
108
105
116
101
114
97
116
101
70
114
111
109
0
}
;
static
const
char16_t
TRANSLITERATE
[
]
=
{
84
114
97
110
115
108
105
116
101
114
97
116
101
0
}
;
TransliteratorEntry
*
TransliteratorRegistry
:
:
findInBundle
(
const
TransliteratorSpec
&
specToOpen
const
TransliteratorSpec
&
specToFind
const
UnicodeString
&
variant
UTransDirection
direction
)
{
UnicodeString
utag
;
UnicodeString
resStr
;
int32_t
pass
;
for
(
pass
=
0
;
pass
<
2
;
+
+
pass
)
{
utag
.
truncate
(
0
)
;
if
(
pass
=
=
0
)
{
utag
.
append
(
direction
=
=
UTRANS_FORWARD
?
TRANSLITERATE_TO
:
TRANSLITERATE_FROM
-
1
)
;
}
else
{
utag
.
append
(
TRANSLITERATE
-
1
)
;
}
UnicodeString
s
(
specToFind
.
get
(
)
)
;
utag
.
append
(
s
.
toUpper
(
"
"
)
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
ResourceBundle
subres
(
specToOpen
.
getBundle
(
)
.
get
(
CharString
(
)
.
appendInvariantChars
(
utag
status
)
.
data
(
)
status
)
)
;
if
(
U_FAILURE
(
status
)
|
|
status
=
=
U_USING_DEFAULT_WARNING
)
{
continue
;
}
s
.
truncate
(
0
)
;
if
(
specToOpen
.
get
(
)
!
=
LocaleUtility
:
:
initNameFromLocale
(
subres
.
getLocale
(
)
s
)
)
{
continue
;
}
if
(
variant
.
length
(
)
!
=
0
)
{
status
=
U_ZERO_ERROR
;
resStr
=
subres
.
getStringEx
(
CharString
(
)
.
appendInvariantChars
(
variant
status
)
.
data
(
)
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
break
;
}
}
else
{
status
=
U_ZERO_ERROR
;
resStr
=
subres
.
getStringEx
(
1
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
break
;
}
}
}
if
(
pass
=
=
2
)
{
return
nullptr
;
}
TransliteratorEntry
*
entry
=
new
TransliteratorEntry
(
)
;
if
(
entry
!
=
nullptr
)
{
int32_t
dir
=
(
pass
=
=
0
)
?
UTRANS_FORWARD
:
direction
;
entry
-
>
entryType
=
TransliteratorEntry
:
:
LOCALE_RULES
;
entry
-
>
stringArg
=
resStr
;
entry
-
>
intArg
=
dir
;
}
return
entry
;
}
TransliteratorEntry
*
TransliteratorRegistry
:
:
find
(
const
UnicodeString
&
ID
)
{
UnicodeString
source
target
variant
;
UBool
sawSource
;
TransliteratorIDParser
:
:
IDtoSTV
(
ID
source
target
variant
sawSource
)
;
return
find
(
source
target
variant
)
;
}
TransliteratorEntry
*
TransliteratorRegistry
:
:
find
(
UnicodeString
&
source
UnicodeString
&
target
UnicodeString
&
variant
)
{
TransliteratorSpec
src
(
source
)
;
TransliteratorSpec
trg
(
target
)
;
TransliteratorEntry
*
entry
;
UnicodeString
ID
;
TransliteratorIDParser
:
:
STVtoID
(
source
target
variant
ID
)
;
entry
=
static_cast
<
TransliteratorEntry
*
>
(
registry
.
get
(
ID
)
)
;
if
(
entry
!
=
nullptr
)
{
return
entry
;
}
if
(
variant
.
length
(
)
!
=
0
)
{
entry
=
findInDynamicStore
(
src
trg
variant
)
;
if
(
entry
!
=
nullptr
)
{
return
entry
;
}
entry
=
findInStaticStore
(
src
trg
variant
)
;
if
(
entry
!
=
nullptr
)
{
return
entry
;
}
}
for
(
;
;
)
{
src
.
reset
(
)
;
for
(
;
;
)
{
entry
=
findInDynamicStore
(
src
trg
NO_VARIANT
)
;
if
(
entry
!
=
nullptr
)
{
return
entry
;
}
entry
=
findInStaticStore
(
src
trg
NO_VARIANT
)
;
if
(
entry
!
=
nullptr
)
{
return
entry
;
}
if
(
!
src
.
hasFallback
(
)
)
{
break
;
}
src
.
next
(
)
;
}
if
(
!
trg
.
hasFallback
(
)
)
{
break
;
}
trg
.
next
(
)
;
}
return
nullptr
;
}
Transliterator
*
TransliteratorRegistry
:
:
instantiateEntry
(
const
UnicodeString
&
ID
TransliteratorEntry
*
entry
TransliteratorAlias
*
&
aliasReturn
UErrorCode
&
status
)
{
Transliterator
*
t
=
nullptr
;
U_ASSERT
(
aliasReturn
=
=
0
)
;
switch
(
entry
-
>
entryType
)
{
case
TransliteratorEntry
:
:
RBT_DATA
:
t
=
new
RuleBasedTransliterator
(
ID
entry
-
>
u
.
data
)
;
if
(
t
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
return
t
;
case
TransliteratorEntry
:
:
PROTOTYPE
:
t
=
entry
-
>
u
.
prototype
-
>
clone
(
)
;
if
(
t
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
return
t
;
case
TransliteratorEntry
:
:
ALIAS
:
aliasReturn
=
new
TransliteratorAlias
(
entry
-
>
stringArg
entry
-
>
compoundFilter
)
;
if
(
aliasReturn
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
return
nullptr
;
case
TransliteratorEntry
:
:
FACTORY
:
t
=
entry
-
>
u
.
factory
.
function
(
ID
entry
-
>
u
.
factory
.
context
)
;
if
(
t
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
return
t
;
case
TransliteratorEntry
:
:
COMPOUND_RBT
:
{
UVector
*
rbts
=
new
UVector
(
uprv_deleteUObject
nullptr
entry
-
>
u
.
dataVector
-
>
size
(
)
status
)
;
if
(
rbts
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
int32_t
passNumber
=
1
;
for
(
int32_t
i
=
0
;
U_SUCCESS
(
status
)
&
&
i
<
entry
-
>
u
.
dataVector
-
>
size
(
)
;
i
+
+
)
{
Transliterator
*
tl
=
new
RuleBasedTransliterator
(
UnicodeString
(
CompoundTransliterator
:
:
PASS_STRING
)
+
UnicodeString
(
passNumber
+
+
)
static_cast
<
TransliterationRuleData
*
>
(
entry
-
>
u
.
dataVector
-
>
elementAt
(
i
)
)
false
)
;
if
(
tl
=
=
nullptr
)
status
=
U_MEMORY_ALLOCATION_ERROR
;
else
rbts
-
>
adoptElement
(
tl
status
)
;
}
if
(
U_FAILURE
(
status
)
)
{
delete
rbts
;
return
nullptr
;
}
rbts
-
>
setDeleter
(
nullptr
)
;
aliasReturn
=
new
TransliteratorAlias
(
ID
entry
-
>
stringArg
rbts
entry
-
>
compoundFilter
)
;
}
if
(
aliasReturn
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
return
nullptr
;
case
TransliteratorEntry
:
:
LOCALE_RULES
:
aliasReturn
=
new
TransliteratorAlias
(
ID
entry
-
>
stringArg
static_cast
<
UTransDirection
>
(
entry
-
>
intArg
)
)
;
if
(
aliasReturn
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
return
nullptr
;
case
TransliteratorEntry
:
:
RULES_FORWARD
:
case
TransliteratorEntry
:
:
RULES_REVERSE
:
{
TransliteratorParser
parser
(
status
)
;
UnicodeString
rules
=
entry
-
>
stringArg
;
aliasReturn
=
new
TransliteratorAlias
(
ID
rules
(
(
entry
-
>
entryType
=
=
TransliteratorEntry
:
:
RULES_REVERSE
)
?
UTRANS_REVERSE
:
UTRANS_FORWARD
)
)
;
if
(
aliasReturn
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
}
return
nullptr
;
default
:
UPRV_UNREACHABLE_EXIT
;
}
}
U_NAMESPACE_END
#
endif
