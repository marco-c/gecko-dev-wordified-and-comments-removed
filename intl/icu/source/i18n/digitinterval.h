#
ifndef
__DIGITINTERVAL_H__
#
define
__DIGITINTERVAL_H__
#
include
"
unicode
/
uobject
.
h
"
#
include
"
unicode
/
utypes
.
h
"
U_NAMESPACE_BEGIN
class
U_I18N_API
DigitInterval
:
public
UMemory
{
public
:
DigitInterval
(
)
:
fLargestExclusive
(
INT32_MAX
)
fSmallestInclusive
(
INT32_MIN
)
{
}
void
clear
(
)
{
fLargestExclusive
=
INT32_MAX
;
fSmallestInclusive
=
INT32_MIN
;
}
UBool
contains
(
int32_t
digitPosition
)
const
;
UBool
equals
(
const
DigitInterval
&
rhs
)
const
{
return
(
(
fLargestExclusive
=
=
rhs
.
fLargestExclusive
)
&
&
(
fSmallestInclusive
=
=
rhs
.
fSmallestInclusive
)
)
;
}
void
expandToContain
(
const
DigitInterval
&
rhs
)
;
void
shrinkToFitWithin
(
const
DigitInterval
&
rhs
)
;
void
expandToContainDigit
(
int32_t
digitExponent
)
;
void
setIntDigitCount
(
int32_t
count
)
;
void
setFracDigitCount
(
int32_t
count
)
;
void
setLeastSignificantInclusive
(
int32_t
smallest
)
{
fSmallestInclusive
=
smallest
<
0
?
smallest
:
0
;
}
void
setMostSignificantExclusive
(
int32_t
largest
)
{
fLargestExclusive
=
largest
>
0
?
largest
:
0
;
}
int32_t
getMostSignificantExclusive
(
)
const
{
return
fLargestExclusive
;
}
int32_t
getIntDigitCount
(
)
const
{
return
fLargestExclusive
;
}
int32_t
getFracDigitCount
(
)
const
{
return
fSmallestInclusive
=
=
INT32_MIN
?
INT32_MAX
:
-
fSmallestInclusive
;
}
int32_t
length
(
)
const
{
return
fLargestExclusive
-
fSmallestInclusive
;
}
int32_t
getLeastSignificantInclusive
(
)
const
{
return
fSmallestInclusive
;
}
private
:
int32_t
fLargestExclusive
;
int32_t
fSmallestInclusive
;
}
;
U_NAMESPACE_END
#
endif
