#
include
"
unicode
/
utypes
.
h
"
#
ifndef
U_HIDE_DEPRECATED_API
#
ifndef
MESSAGEFORMAT_PARSER_H
#
define
MESSAGEFORMAT_PARSER_H
#
include
"
unicode
/
messageformat2_data_model
.
h
"
#
include
"
unicode
/
parseerr
.
h
"
#
include
"
messageformat2_allocation
.
h
"
#
include
"
messageformat2_errors
.
h
"
#
if
U_SHOW_CPLUSPLUS_API
#
if
!
UCONFIG_NO_FORMATTING
#
if
!
UCONFIG_NO_MF2
U_NAMESPACE_BEGIN
namespace
message2
{
using
namespace
data_model
;
template
<
class
T
>
class
OptionAdder
{
private
:
T
&
builder
;
public
:
OptionAdder
(
T
&
b
)
:
builder
(
b
)
{
}
void
addOption
(
const
UnicodeString
&
k
Operand
&
&
r
UErrorCode
&
s
)
{
builder
.
addOption
(
k
std
:
:
move
(
r
)
s
)
;
}
}
;
template
<
class
T
>
class
AttributeAdder
{
private
:
T
&
builder
;
public
:
AttributeAdder
(
T
&
b
)
:
builder
(
b
)
{
}
void
addAttribute
(
const
UnicodeString
&
k
Operand
&
&
r
UErrorCode
&
s
)
{
builder
.
addAttribute
(
k
std
:
:
move
(
r
)
s
)
;
}
}
;
class
Parser
:
public
UMemory
{
public
:
virtual
~
Parser
(
)
;
private
:
friend
class
MessageFormatter
;
void
parse
(
UParseError
&
UErrorCode
&
)
;
typedef
struct
MessageParseError
{
uint32_t
line
;
uint32_t
offset
;
uint32_t
lengthBeforeCurrentLine
;
UChar
preContext
[
U_PARSE_CONTEXT_LEN
]
;
UChar
postContext
[
U_PARSE_CONTEXT_LEN
]
;
}
MessageParseError
;
Parser
(
const
UnicodeString
&
input
MFDataModel
:
:
Builder
&
dataModelBuilder
StaticErrors
&
e
UnicodeString
&
normalizedInputRef
)
:
source
(
input
)
index
(
0
)
errors
(
e
)
normalizedInput
(
normalizedInputRef
)
dataModel
(
dataModelBuilder
)
{
parseError
.
line
=
0
;
parseError
.
offset
=
0
;
parseError
.
lengthBeforeCurrentLine
=
0
;
parseError
.
preContext
[
0
]
=
'
\
0
'
;
parseError
.
postContext
[
0
]
=
'
\
0
'
;
}
static
void
translateParseError
(
const
MessageParseError
&
UParseError
&
)
;
static
void
setParseError
(
MessageParseError
&
uint32_t
)
;
void
maybeAdvanceLine
(
)
;
Pattern
parseSimpleMessage
(
UErrorCode
&
)
;
void
parseBody
(
UErrorCode
&
)
;
void
parseDeclarations
(
UErrorCode
&
)
;
void
parseUnsupportedStatement
(
UErrorCode
&
)
;
void
parseLocalDeclaration
(
UErrorCode
&
)
;
void
parseInputDeclaration
(
UErrorCode
&
)
;
void
parseSelectors
(
UErrorCode
&
)
;
void
parseWhitespaceMaybeRequired
(
bool
UErrorCode
&
)
;
void
parseRequiredWhitespace
(
UErrorCode
&
)
;
void
parseOptionalWhitespace
(
UErrorCode
&
)
;
void
parseToken
(
UChar32
UErrorCode
&
)
;
void
parseTokenWithWhitespace
(
UChar32
UErrorCode
&
)
;
void
parseToken
(
const
std
:
:
u16string_view
&
UErrorCode
&
)
;
void
parseTokenWithWhitespace
(
const
std
:
:
u16string_view
&
UErrorCode
&
)
;
bool
nextIs
(
const
std
:
:
u16string_view
&
)
const
;
UnicodeString
parseName
(
UErrorCode
&
)
;
UnicodeString
parseIdentifier
(
UErrorCode
&
)
;
UnicodeString
parseDigits
(
UErrorCode
&
)
;
VariableName
parseVariableName
(
UErrorCode
&
)
;
FunctionName
parseFunction
(
UErrorCode
&
)
;
UnicodeString
parseEscapeSequence
(
UErrorCode
&
)
;
Literal
parseUnquotedLiteral
(
UErrorCode
&
)
;
Literal
parseQuotedLiteral
(
UErrorCode
&
)
;
Literal
parseLiteral
(
UErrorCode
&
)
;
template
<
class
T
>
void
parseAttribute
(
AttributeAdder
<
T
>
&
UErrorCode
&
)
;
template
<
class
T
>
void
parseAttributes
(
AttributeAdder
<
T
>
&
UErrorCode
&
)
;
template
<
class
T
>
void
parseOption
(
OptionAdder
<
T
>
&
UErrorCode
&
)
;
template
<
class
T
>
void
parseOptions
(
OptionAdder
<
T
>
&
UErrorCode
&
)
;
Operator
parseAnnotation
(
UErrorCode
&
)
;
void
parseLiteralOrVariableWithAnnotation
(
bool
Expression
:
:
Builder
&
UErrorCode
&
)
;
Markup
parseMarkup
(
UErrorCode
&
)
;
Expression
parseExpression
(
UErrorCode
&
)
;
std
:
:
variant
<
Expression
Markup
>
parsePlaceholder
(
UErrorCode
&
)
;
UnicodeString
parseTextChar
(
UErrorCode
&
)
;
Key
parseKey
(
UErrorCode
&
)
;
SelectorKeys
parseNonEmptyKeys
(
UErrorCode
&
)
;
void
errorPattern
(
UErrorCode
&
status
)
;
Pattern
parseQuotedPattern
(
UErrorCode
&
)
;
bool
isDeclarationStart
(
)
;
UChar32
peek
(
)
const
{
return
source
.
char32At
(
index
)
;
}
UChar32
peek
(
uint32_t
i
)
const
{
return
source
.
char32At
(
source
.
moveIndex32
(
index
i
)
)
;
}
void
next
(
)
{
index
=
source
.
moveIndex32
(
index
1
)
;
}
bool
inBounds
(
)
const
{
return
(
int32_t
)
index
<
source
.
length
(
)
;
}
bool
inBounds
(
uint32_t
i
)
const
{
return
source
.
moveIndex32
(
index
i
)
<
source
.
length
(
)
;
}
bool
allConsumed
(
)
const
{
return
(
int32_t
)
index
=
=
source
.
length
(
)
;
}
const
UnicodeString
&
source
;
uint32_t
index
;
MessageParseError
parseError
;
StaticErrors
&
errors
;
UnicodeString
&
normalizedInput
;
MFDataModel
:
:
Builder
&
dataModel
;
}
;
}
U_NAMESPACE_END
#
endif
#
endif
#
endif
#
endif
#
endif
