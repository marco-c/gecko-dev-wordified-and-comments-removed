#
ifndef
UMUTEX_H
#
define
UMUTEX_H
#
ifndef
__wasi__
#
include
<
atomic
>
#
include
<
condition_variable
>
#
include
<
mutex
>
#
endif
#
include
<
type_traits
>
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
uclean
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
putilimp
.
h
"
#
if
defined
(
U_USER_ATOMICS_H
)
|
|
defined
(
U_USER_MUTEX_H
)
#
error
U_USER_ATOMICS
and
U_USER_MUTEX_H
are
not
supported
#
endif
#
ifndef
__wasi__
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
&
&
!
defined
(
U_IN_DOXYGEN
)
#
if
defined
(
__clang__
)
|
|
defined
(
_MSC_VER
)
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Winstantiation
-
after
-
specialization
"
#
endif
template
struct
U_COMMON_API
std
:
:
atomic
<
int32_t
>
;
template
struct
U_COMMON_API
std
:
:
atomic
<
std
:
:
mutex
*
>
;
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
pop
#
endif
#
elif
defined
(
__GNUC__
)
template
struct
std
:
:
atomic
<
int32_t
>
;
template
struct
std
:
:
atomic
<
std
:
:
mutex
*
>
;
#
endif
#
endif
#
endif
U_NAMESPACE_BEGIN
#
ifndef
__wasi__
typedef
std
:
:
atomic
<
int32_t
>
u_atomic_int32_t
;
inline
int32_t
umtx_loadAcquire
(
u_atomic_int32_t
&
var
)
{
return
var
.
load
(
std
:
:
memory_order_acquire
)
;
}
inline
void
umtx_storeRelease
(
u_atomic_int32_t
&
var
int32_t
val
)
{
var
.
store
(
val
std
:
:
memory_order_release
)
;
}
inline
int32_t
umtx_atomic_inc
(
u_atomic_int32_t
*
var
)
{
return
var
-
>
fetch_add
(
1
)
+
1
;
}
inline
int32_t
umtx_atomic_dec
(
u_atomic_int32_t
*
var
)
{
return
var
-
>
fetch_sub
(
1
)
-
1
;
}
#
else
typedef
int32_t
u_atomic_int32_t
;
inline
int32_t
umtx_loadAcquire
(
u_atomic_int32_t
&
var
)
{
return
var
;
}
inline
void
umtx_storeRelease
(
u_atomic_int32_t
&
var
int32_t
val
)
{
var
=
val
;
}
inline
int32_t
umtx_atomic_inc
(
u_atomic_int32_t
*
var
)
{
return
+
+
(
*
var
)
;
}
inline
int32_t
umtx_atomic_dec
(
u_atomic_int32_t
*
var
)
{
return
-
-
(
*
var
)
;
}
#
endif
struct
U_COMMON_API
UInitOnce
{
u_atomic_int32_t
fState
{
0
}
;
UErrorCode
fErrCode
{
U_ZERO_ERROR
}
;
void
reset
(
)
{
fState
=
0
;
}
UBool
isReset
(
)
{
return
umtx_loadAcquire
(
fState
)
=
=
0
;
}
}
;
U_COMMON_API
UBool
U_EXPORT2
umtx_initImplPreInit
(
UInitOnce
&
)
;
U_COMMON_API
void
U_EXPORT2
umtx_initImplPostInit
(
UInitOnce
&
)
;
template
<
class
T
>
void
umtx_initOnce
(
UInitOnce
&
uio
T
*
obj
void
(
U_CALLCONV
T
:
:
*
fp
)
(
)
)
{
if
(
umtx_loadAcquire
(
uio
.
fState
)
=
=
2
)
{
return
;
}
if
(
umtx_initImplPreInit
(
uio
)
)
{
(
obj
-
>
*
fp
)
(
)
;
umtx_initImplPostInit
(
uio
)
;
}
}
inline
void
umtx_initOnce
(
UInitOnce
&
uio
void
(
U_CALLCONV
*
fp
)
(
)
)
{
if
(
umtx_loadAcquire
(
uio
.
fState
)
=
=
2
)
{
return
;
}
if
(
umtx_initImplPreInit
(
uio
)
)
{
(
*
fp
)
(
)
;
umtx_initImplPostInit
(
uio
)
;
}
}
inline
void
umtx_initOnce
(
UInitOnce
&
uio
void
(
U_CALLCONV
*
fp
)
(
UErrorCode
&
)
UErrorCode
&
errCode
)
{
if
(
U_FAILURE
(
errCode
)
)
{
return
;
}
if
(
umtx_loadAcquire
(
uio
.
fState
)
!
=
2
&
&
umtx_initImplPreInit
(
uio
)
)
{
(
*
fp
)
(
errCode
)
;
uio
.
fErrCode
=
errCode
;
umtx_initImplPostInit
(
uio
)
;
}
else
{
if
(
U_FAILURE
(
uio
.
fErrCode
)
)
{
errCode
=
uio
.
fErrCode
;
}
}
}
template
<
class
T
>
void
umtx_initOnce
(
UInitOnce
&
uio
void
(
U_CALLCONV
*
fp
)
(
T
)
T
context
)
{
if
(
umtx_loadAcquire
(
uio
.
fState
)
=
=
2
)
{
return
;
}
if
(
umtx_initImplPreInit
(
uio
)
)
{
(
*
fp
)
(
context
)
;
umtx_initImplPostInit
(
uio
)
;
}
}
template
<
class
T
>
void
umtx_initOnce
(
UInitOnce
&
uio
void
(
U_CALLCONV
*
fp
)
(
T
UErrorCode
&
)
T
context
UErrorCode
&
errCode
)
{
if
(
U_FAILURE
(
errCode
)
)
{
return
;
}
if
(
umtx_loadAcquire
(
uio
.
fState
)
!
=
2
&
&
umtx_initImplPreInit
(
uio
)
)
{
(
*
fp
)
(
context
errCode
)
;
uio
.
fErrCode
=
errCode
;
umtx_initImplPostInit
(
uio
)
;
}
else
{
if
(
U_FAILURE
(
uio
.
fErrCode
)
)
{
errCode
=
uio
.
fErrCode
;
}
}
}
#
if
(
defined
(
_CPPLIB_VER
)
&
&
!
defined
(
_MSVC_STL_VERSION
)
)
|
|
\
(
defined
(
_MSVC_STL_VERSION
)
&
&
_MSVC_STL_VERSION
<
142
)
#
define
UMUTEX_CONSTEXPR
#
else
#
define
UMUTEX_CONSTEXPR
constexpr
#
endif
class
U_COMMON_API
UMutex
{
public
:
UMUTEX_CONSTEXPR
UMutex
(
)
{
}
~
UMutex
(
)
=
default
;
UMutex
(
const
UMutex
&
other
)
=
delete
;
UMutex
&
operator
=
(
const
UMutex
&
other
)
=
delete
;
void
*
operator
new
(
size_t
)
=
delete
;
void
lock
(
)
{
#
ifndef
__wasi__
std
:
:
mutex
*
m
=
fMutex
.
load
(
std
:
:
memory_order_acquire
)
;
if
(
m
=
=
nullptr
)
{
m
=
getMutex
(
)
;
}
m
-
>
lock
(
)
;
#
endif
}
void
unlock
(
)
{
#
ifndef
__wasi__
fMutex
.
load
(
std
:
:
memory_order_relaxed
)
-
>
unlock
(
)
;
#
endif
}
static
void
cleanup
(
)
;
private
:
#
ifndef
__wasi__
alignas
(
std
:
:
mutex
)
char
fStorage
[
sizeof
(
std
:
:
mutex
)
]
{
}
;
std
:
:
atomic
<
std
:
:
mutex
*
>
fMutex
{
nullptr
}
;
#
endif
UMutex
*
fListLink
{
nullptr
}
;
static
UMutex
*
gListHead
;
#
ifndef
__wasi__
std
:
:
mutex
*
getMutex
(
)
;
#
endif
}
;
U_CAPI
void
U_EXPORT2
umtx_lock
(
UMutex
*
mutex
)
;
U_CAPI
void
U_EXPORT2
umtx_unlock
(
UMutex
*
mutex
)
;
U_NAMESPACE_END
#
endif
