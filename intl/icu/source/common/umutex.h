#
ifndef
UMUTEX_H
#
define
UMUTEX_H
#
include
<
atomic
>
#
include
<
condition_variable
>
#
include
<
mutex
>
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
uclean
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
putilimp
.
h
"
#
if
defined
(
U_USER_ATOMICS_H
)
|
|
defined
(
U_USER_MUTEX_H
)
#
error
U_USER_ATOMICS
and
U_USER_MUTEX_H
are
not
supported
#
endif
#
if
U_PF_WINDOWS
<
=
U_PLATFORM
&
&
U_PLATFORM
<
=
U_PF_CYGWIN
&
&
!
defined
(
U_IN_DOXYGEN
)
#
if
defined
(
__clang__
)
|
|
defined
(
_MSC_VER
)
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
push
#
pragma
clang
diagnostic
ignored
"
-
Winstantiation
-
after
-
specialization
"
#
endif
template
struct
U_COMMON_API
std
:
:
atomic
<
int32_t
>
;
#
if
defined
(
__clang__
)
#
pragma
clang
diagnostic
pop
#
endif
#
elif
defined
(
__GNUC__
)
template
struct
std
:
:
atomic
<
int32_t
>
;
#
endif
#
endif
U_NAMESPACE_BEGIN
typedef
std
:
:
atomic
<
int32_t
>
u_atomic_int32_t
;
#
define
ATOMIC_INT32_T_INITIALIZER
(
val
)
ATOMIC_VAR_INIT
(
val
)
inline
int32_t
umtx_loadAcquire
(
u_atomic_int32_t
&
var
)
{
return
var
.
load
(
std
:
:
memory_order_acquire
)
;
}
inline
void
umtx_storeRelease
(
u_atomic_int32_t
&
var
int32_t
val
)
{
var
.
store
(
val
std
:
:
memory_order_release
)
;
}
inline
int32_t
umtx_atomic_inc
(
u_atomic_int32_t
*
var
)
{
return
var
-
>
fetch_add
(
1
)
+
1
;
}
inline
int32_t
umtx_atomic_dec
(
u_atomic_int32_t
*
var
)
{
return
var
-
>
fetch_sub
(
1
)
-
1
;
}
struct
UInitOnce
{
u_atomic_int32_t
fState
;
UErrorCode
fErrCode
;
void
reset
(
)
{
fState
=
0
;
}
UBool
isReset
(
)
{
return
umtx_loadAcquire
(
fState
)
=
=
0
;
}
}
;
#
define
U_INITONCE_INITIALIZER
{
ATOMIC_INT32_T_INITIALIZER
(
0
)
U_ZERO_ERROR
}
U_COMMON_API
UBool
U_EXPORT2
umtx_initImplPreInit
(
UInitOnce
&
)
;
U_COMMON_API
void
U_EXPORT2
umtx_initImplPostInit
(
UInitOnce
&
)
;
template
<
class
T
>
void
umtx_initOnce
(
UInitOnce
&
uio
T
*
obj
void
(
U_CALLCONV
T
:
:
*
fp
)
(
)
)
{
if
(
umtx_loadAcquire
(
uio
.
fState
)
=
=
2
)
{
return
;
}
if
(
umtx_initImplPreInit
(
uio
)
)
{
(
obj
-
>
*
fp
)
(
)
;
umtx_initImplPostInit
(
uio
)
;
}
}
inline
void
umtx_initOnce
(
UInitOnce
&
uio
void
(
U_CALLCONV
*
fp
)
(
)
)
{
if
(
umtx_loadAcquire
(
uio
.
fState
)
=
=
2
)
{
return
;
}
if
(
umtx_initImplPreInit
(
uio
)
)
{
(
*
fp
)
(
)
;
umtx_initImplPostInit
(
uio
)
;
}
}
inline
void
umtx_initOnce
(
UInitOnce
&
uio
void
(
U_CALLCONV
*
fp
)
(
UErrorCode
&
)
UErrorCode
&
errCode
)
{
if
(
U_FAILURE
(
errCode
)
)
{
return
;
}
if
(
umtx_loadAcquire
(
uio
.
fState
)
!
=
2
&
&
umtx_initImplPreInit
(
uio
)
)
{
(
*
fp
)
(
errCode
)
;
uio
.
fErrCode
=
errCode
;
umtx_initImplPostInit
(
uio
)
;
}
else
{
if
(
U_FAILURE
(
uio
.
fErrCode
)
)
{
errCode
=
uio
.
fErrCode
;
}
}
}
template
<
class
T
>
void
umtx_initOnce
(
UInitOnce
&
uio
void
(
U_CALLCONV
*
fp
)
(
T
)
T
context
)
{
if
(
umtx_loadAcquire
(
uio
.
fState
)
=
=
2
)
{
return
;
}
if
(
umtx_initImplPreInit
(
uio
)
)
{
(
*
fp
)
(
context
)
;
umtx_initImplPostInit
(
uio
)
;
}
}
template
<
class
T
>
void
umtx_initOnce
(
UInitOnce
&
uio
void
(
U_CALLCONV
*
fp
)
(
T
UErrorCode
&
)
T
context
UErrorCode
&
errCode
)
{
if
(
U_FAILURE
(
errCode
)
)
{
return
;
}
if
(
umtx_loadAcquire
(
uio
.
fState
)
!
=
2
&
&
umtx_initImplPreInit
(
uio
)
)
{
(
*
fp
)
(
context
errCode
)
;
uio
.
fErrCode
=
errCode
;
umtx_initImplPostInit
(
uio
)
;
}
else
{
if
(
U_FAILURE
(
uio
.
fErrCode
)
)
{
errCode
=
uio
.
fErrCode
;
}
}
}
struct
UMutex
:
public
icu
:
:
UMemory
{
UMutex
(
)
=
default
;
~
UMutex
(
)
=
default
;
UMutex
(
const
UMutex
&
other
)
=
delete
;
UMutex
&
operator
=
(
const
UMutex
&
other
)
=
delete
;
std
:
:
mutex
fMutex
=
{
}
;
}
;
struct
UConditionVar
:
public
icu
:
:
UMemory
{
U_COMMON_API
UConditionVar
(
)
;
U_COMMON_API
~
UConditionVar
(
)
;
UConditionVar
(
const
UConditionVar
&
other
)
=
delete
;
UConditionVar
&
operator
=
(
const
UConditionVar
&
other
)
=
delete
;
std
:
:
condition_variable_any
fCV
;
}
;
#
define
U_MUTEX_INITIALIZER
{
}
#
define
U_CONDITION_INITIALIZER
{
}
U_INTERNAL
void
U_EXPORT2
umtx_lock
(
UMutex
*
mutex
)
;
U_INTERNAL
void
U_EXPORT2
umtx_unlock
(
UMutex
*
mutex
)
;
U_INTERNAL
void
U_EXPORT2
umtx_condWait
(
UConditionVar
*
cond
UMutex
*
mutex
)
;
U_INTERNAL
void
U_EXPORT2
umtx_condBroadcast
(
UConditionVar
*
cond
)
;
U_INTERNAL
void
U_EXPORT2
umtx_condSignal
(
UConditionVar
*
cond
)
;
U_NAMESPACE_END
#
endif
