#
ifndef
BYTESINKUTIL_H
#
define
BYTESINKUTIL_H
#
include
<
type_traits
>
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
bytestream
.
h
"
#
include
"
unicode
/
edits
.
h
"
#
include
"
charstr
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
uassert
.
h
"
#
include
"
ustr_imp
.
h
"
U_NAMESPACE_BEGIN
class
ByteSink
;
class
Edits
;
class
U_COMMON_API
CharStringByteSink
:
public
ByteSink
{
public
:
CharStringByteSink
(
CharString
*
dest
)
;
~
CharStringByteSink
(
)
override
;
CharStringByteSink
(
)
=
delete
;
CharStringByteSink
(
const
CharStringByteSink
&
)
=
delete
;
CharStringByteSink
&
operator
=
(
const
CharStringByteSink
&
)
=
delete
;
void
Append
(
const
char
*
bytes
int32_t
n
)
override
;
char
*
GetAppendBuffer
(
int32_t
min_capacity
int32_t
desired_capacity_hint
char
*
scratch
int32_t
scratch_capacity
int32_t
*
result_capacity
)
override
;
private
:
CharString
&
dest_
;
}
;
template
<
>
class
StringByteSink
<
CharString
>
:
public
CharStringByteSink
{
public
:
StringByteSink
(
CharString
*
dest
)
:
CharStringByteSink
(
dest
)
{
}
StringByteSink
(
CharString
*
dest
int32_t
)
:
CharStringByteSink
(
dest
)
{
}
}
;
class
U_COMMON_API
ByteSinkUtil
{
public
:
ByteSinkUtil
(
)
=
delete
;
static
UBool
appendChange
(
int32_t
length
const
char16_t
*
s16
int32_t
s16Length
ByteSink
&
sink
Edits
*
edits
UErrorCode
&
errorCode
)
;
static
UBool
appendChange
(
const
uint8_t
*
s
const
uint8_t
*
limit
const
char16_t
*
s16
int32_t
s16Length
ByteSink
&
sink
Edits
*
edits
UErrorCode
&
errorCode
)
;
static
void
appendCodePoint
(
int32_t
length
UChar32
c
ByteSink
&
sink
Edits
*
edits
=
nullptr
)
;
static
inline
void
appendCodePoint
(
const
uint8_t
*
src
const
uint8_t
*
nextSrc
UChar32
c
ByteSink
&
sink
Edits
*
edits
=
nullptr
)
{
appendCodePoint
(
static_cast
<
int32_t
>
(
nextSrc
-
src
)
c
sink
edits
)
;
}
static
void
appendTwoBytes
(
UChar32
c
ByteSink
&
sink
)
;
static
UBool
appendUnchanged
(
const
uint8_t
*
s
int32_t
length
ByteSink
&
sink
uint32_t
options
Edits
*
edits
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
false
;
}
if
(
length
>
0
)
{
appendNonEmptyUnchanged
(
s
length
sink
options
edits
)
;
}
return
true
;
}
static
UBool
appendUnchanged
(
const
uint8_t
*
s
const
uint8_t
*
limit
ByteSink
&
sink
uint32_t
options
Edits
*
edits
UErrorCode
&
errorCode
)
;
template
<
typename
F
typename
=
std
:
:
enable_if_t
<
std
:
:
is_invocable_r_v
<
void
F
ByteSink
&
UErrorCode
&
>
>
>
static
int32_t
viaByteSinkToTerminatedChars
(
char
*
buffer
int32_t
capacity
F
&
&
lambda
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
CheckedArrayByteSink
sink
(
buffer
capacity
)
;
lambda
(
sink
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
int32_t
reslen
=
sink
.
NumberOfBytesAppended
(
)
;
if
(
sink
.
Overflowed
(
)
)
{
status
=
U_BUFFER_OVERFLOW_ERROR
;
return
reslen
;
}
return
u_terminateChars
(
buffer
capacity
reslen
&
status
)
;
}
template
<
typename
F
typename
=
std
:
:
enable_if_t
<
std
:
:
is_invocable_r_v
<
void
F
ByteSink
&
UErrorCode
&
>
>
>
static
CharString
viaByteSinkToCharString
(
F
&
&
lambda
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
CharString
result
;
CharStringByteSink
sink
(
&
result
)
;
lambda
(
sink
status
)
;
return
result
;
}
private
:
static
void
appendNonEmptyUnchanged
(
const
uint8_t
*
s
int32_t
length
ByteSink
&
sink
uint32_t
options
Edits
*
edits
)
;
}
;
U_NAMESPACE_END
#
endif
