#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
brkiter
.
h
"
#
include
"
unicode
/
casemap
.
h
"
#
include
"
unicode
/
edits
.
h
"
#
include
"
unicode
/
stringoptions
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
unicode
/
ucasemap
.
h
"
#
include
"
unicode
/
ubrk
.
h
"
#
include
"
unicode
/
utf
.
h
"
#
include
"
unicode
/
utf16
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
ucase
.
h
"
#
include
"
ucasemap_imp
.
h
"
#
include
"
ustr_imp
.
h
"
#
include
"
uassert
.
h
"
#
define
ACUTE
u
'
\
u0301
'
U_NAMESPACE_BEGIN
namespace
{
int32_t
checkOverflowAndEditsError
(
int32_t
destIndex
int32_t
destCapacity
Edits
*
edits
UErrorCode
&
errorCode
)
{
if
(
U_SUCCESS
(
errorCode
)
)
{
if
(
destIndex
>
destCapacity
)
{
errorCode
=
U_BUFFER_OVERFLOW_ERROR
;
}
else
if
(
edits
!
=
nullptr
)
{
edits
-
>
copyErrorTo
(
errorCode
)
;
}
}
return
destIndex
;
}
inline
int32_t
appendResult
(
char16_t
*
dest
int32_t
destIndex
int32_t
destCapacity
int32_t
result
const
char16_t
*
s
int32_t
cpLength
uint32_t
options
icu
:
:
Edits
*
edits
)
{
UChar32
c
;
int32_t
length
;
if
(
result
<
0
)
{
if
(
edits
!
=
nullptr
)
{
edits
-
>
addUnchanged
(
cpLength
)
;
}
if
(
options
&
U_OMIT_UNCHANGED_TEXT
)
{
return
destIndex
;
}
c
=
~
result
;
if
(
destIndex
<
destCapacity
&
&
c
<
=
0xffff
)
{
dest
[
destIndex
+
+
]
=
(
char16_t
)
c
;
return
destIndex
;
}
length
=
cpLength
;
}
else
{
if
(
result
<
=
UCASE_MAX_STRING_LENGTH
)
{
c
=
U_SENTINEL
;
length
=
result
;
}
else
if
(
destIndex
<
destCapacity
&
&
result
<
=
0xffff
)
{
dest
[
destIndex
+
+
]
=
(
char16_t
)
result
;
if
(
edits
!
=
nullptr
)
{
edits
-
>
addReplace
(
cpLength
1
)
;
}
return
destIndex
;
}
else
{
c
=
result
;
length
=
U16_LENGTH
(
c
)
;
}
if
(
edits
!
=
nullptr
)
{
edits
-
>
addReplace
(
cpLength
length
)
;
}
}
if
(
length
>
(
INT32_MAX
-
destIndex
)
)
{
return
-
1
;
}
if
(
destIndex
<
destCapacity
)
{
if
(
c
>
=
0
)
{
UBool
isError
=
false
;
U16_APPEND
(
dest
destIndex
destCapacity
c
isError
)
;
if
(
isError
)
{
destIndex
+
=
length
;
}
}
else
{
if
(
(
destIndex
+
length
)
<
=
destCapacity
)
{
while
(
length
>
0
)
{
dest
[
destIndex
+
+
]
=
*
s
+
+
;
-
-
length
;
}
}
else
{
destIndex
+
=
length
;
}
}
}
else
{
destIndex
+
=
length
;
}
return
destIndex
;
}
inline
int32_t
appendUChar
(
char16_t
*
dest
int32_t
destIndex
int32_t
destCapacity
char16_t
c
)
{
if
(
destIndex
<
destCapacity
)
{
dest
[
destIndex
]
=
c
;
}
else
if
(
destIndex
=
=
INT32_MAX
)
{
return
-
1
;
}
return
destIndex
+
1
;
}
int32_t
appendNonEmptyUnchanged
(
char16_t
*
dest
int32_t
destIndex
int32_t
destCapacity
const
char16_t
*
s
int32_t
length
uint32_t
options
icu
:
:
Edits
*
edits
)
{
if
(
edits
!
=
nullptr
)
{
edits
-
>
addUnchanged
(
length
)
;
}
if
(
options
&
U_OMIT_UNCHANGED_TEXT
)
{
return
destIndex
;
}
if
(
length
>
(
INT32_MAX
-
destIndex
)
)
{
return
-
1
;
}
if
(
(
destIndex
+
length
)
<
=
destCapacity
)
{
u_memcpy
(
dest
+
destIndex
s
length
)
;
}
return
destIndex
+
length
;
}
inline
int32_t
appendUnchanged
(
char16_t
*
dest
int32_t
destIndex
int32_t
destCapacity
const
char16_t
*
s
int32_t
length
uint32_t
options
icu
:
:
Edits
*
edits
)
{
if
(
length
<
=
0
)
{
return
destIndex
;
}
return
appendNonEmptyUnchanged
(
dest
destIndex
destCapacity
s
length
options
edits
)
;
}
UChar32
U_CALLCONV
utf16_caseContextIterator
(
void
*
context
int8_t
dir
)
{
UCaseContext
*
csc
=
(
UCaseContext
*
)
context
;
UChar32
c
;
if
(
dir
<
0
)
{
csc
-
>
index
=
csc
-
>
cpStart
;
csc
-
>
dir
=
dir
;
}
else
if
(
dir
>
0
)
{
csc
-
>
index
=
csc
-
>
cpLimit
;
csc
-
>
dir
=
dir
;
}
else
{
dir
=
csc
-
>
dir
;
}
if
(
dir
<
0
)
{
if
(
csc
-
>
start
<
csc
-
>
index
)
{
U16_PREV
(
(
const
char16_t
*
)
csc
-
>
p
csc
-
>
start
csc
-
>
index
c
)
;
return
c
;
}
}
else
{
if
(
csc
-
>
index
<
csc
-
>
limit
)
{
U16_NEXT
(
(
const
char16_t
*
)
csc
-
>
p
csc
-
>
index
csc
-
>
limit
c
)
;
return
c
;
}
}
return
U_SENTINEL
;
}
int32_t
toLower
(
int32_t
caseLocale
uint32_t
options
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
UCaseContext
*
csc
int32_t
srcStart
int32_t
srcLimit
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
{
const
int8_t
*
latinToLower
;
if
(
caseLocale
=
=
UCASE_LOC_ROOT
|
|
(
caseLocale
>
=
0
?
!
(
caseLocale
=
=
UCASE_LOC_TURKISH
|
|
caseLocale
=
=
UCASE_LOC_LITHUANIAN
)
:
(
options
&
_FOLD_CASE_OPTIONS_MASK
)
=
=
U_FOLD_CASE_DEFAULT
)
)
{
latinToLower
=
LatinCase
:
:
TO_LOWER_NORMAL
;
}
else
{
latinToLower
=
LatinCase
:
:
TO_LOWER_TR_LT
;
}
const
UTrie2
*
trie
=
ucase_getTrie
(
)
;
int32_t
destIndex
=
0
;
int32_t
prev
=
srcStart
;
int32_t
srcIndex
=
srcStart
;
for
(
;
;
)
{
char16_t
lead
=
0
;
while
(
srcIndex
<
srcLimit
)
{
lead
=
src
[
srcIndex
]
;
int32_t
delta
;
if
(
lead
<
LatinCase
:
:
LONG_S
)
{
int8_t
d
=
latinToLower
[
lead
]
;
if
(
d
=
=
LatinCase
:
:
EXC
)
{
break
;
}
+
+
srcIndex
;
if
(
d
=
=
0
)
{
continue
;
}
delta
=
d
;
}
else
if
(
lead
>
=
0xd800
)
{
break
;
}
else
{
uint16_t
props
=
UTRIE2_GET16_FROM_U16_SINGLE_LEAD
(
trie
lead
)
;
if
(
UCASE_HAS_EXCEPTION
(
props
)
)
{
break
;
}
+
+
srcIndex
;
if
(
!
UCASE_IS_UPPER_OR_TITLE
(
props
)
|
|
(
delta
=
UCASE_GET_DELTA
(
props
)
)
=
=
0
)
{
continue
;
}
}
lead
+
=
static_cast
<
char16_t
>
(
delta
)
;
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
prev
srcIndex
-
1
-
prev
options
edits
)
;
if
(
destIndex
>
=
0
)
{
destIndex
=
appendUChar
(
dest
destIndex
destCapacity
lead
)
;
if
(
edits
!
=
nullptr
)
{
edits
-
>
addReplace
(
1
1
)
;
}
}
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
prev
=
srcIndex
;
}
if
(
srcIndex
>
=
srcLimit
)
{
break
;
}
int32_t
cpStart
=
srcIndex
+
+
;
char16_t
trail
;
UChar32
c
;
if
(
U16_IS_LEAD
(
lead
)
&
&
srcIndex
<
srcLimit
&
&
U16_IS_TRAIL
(
trail
=
src
[
srcIndex
]
)
)
{
c
=
U16_GET_SUPPLEMENTARY
(
lead
trail
)
;
+
+
srcIndex
;
}
else
{
c
=
lead
;
}
const
char16_t
*
s
;
if
(
caseLocale
>
=
0
)
{
csc
-
>
cpStart
=
cpStart
;
csc
-
>
cpLimit
=
srcIndex
;
c
=
ucase_toFullLower
(
c
utf16_caseContextIterator
csc
&
s
caseLocale
)
;
}
else
{
c
=
ucase_toFullFolding
(
c
&
s
options
)
;
}
if
(
c
>
=
0
)
{
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
prev
cpStart
-
prev
options
edits
)
;
if
(
destIndex
>
=
0
)
{
destIndex
=
appendResult
(
dest
destIndex
destCapacity
c
s
srcIndex
-
cpStart
options
edits
)
;
}
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
prev
=
srcIndex
;
}
}
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
prev
srcIndex
-
prev
options
edits
)
;
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
return
destIndex
;
}
int32_t
toUpper
(
int32_t
caseLocale
uint32_t
options
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
UCaseContext
*
csc
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
{
const
int8_t
*
latinToUpper
;
if
(
caseLocale
=
=
UCASE_LOC_TURKISH
)
{
latinToUpper
=
LatinCase
:
:
TO_UPPER_TR
;
}
else
{
latinToUpper
=
LatinCase
:
:
TO_UPPER_NORMAL
;
}
const
UTrie2
*
trie
=
ucase_getTrie
(
)
;
int32_t
destIndex
=
0
;
int32_t
prev
=
0
;
int32_t
srcIndex
=
0
;
for
(
;
;
)
{
char16_t
lead
=
0
;
while
(
srcIndex
<
srcLength
)
{
lead
=
src
[
srcIndex
]
;
int32_t
delta
;
if
(
lead
<
LatinCase
:
:
LONG_S
)
{
int8_t
d
=
latinToUpper
[
lead
]
;
if
(
d
=
=
LatinCase
:
:
EXC
)
{
break
;
}
+
+
srcIndex
;
if
(
d
=
=
0
)
{
continue
;
}
delta
=
d
;
}
else
if
(
lead
>
=
0xd800
)
{
break
;
}
else
{
uint16_t
props
=
UTRIE2_GET16_FROM_U16_SINGLE_LEAD
(
trie
lead
)
;
if
(
UCASE_HAS_EXCEPTION
(
props
)
)
{
break
;
}
+
+
srcIndex
;
if
(
UCASE_GET_TYPE
(
props
)
!
=
UCASE_LOWER
|
|
(
delta
=
UCASE_GET_DELTA
(
props
)
)
=
=
0
)
{
continue
;
}
}
lead
+
=
static_cast
<
char16_t
>
(
delta
)
;
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
prev
srcIndex
-
1
-
prev
options
edits
)
;
if
(
destIndex
>
=
0
)
{
destIndex
=
appendUChar
(
dest
destIndex
destCapacity
lead
)
;
if
(
edits
!
=
nullptr
)
{
edits
-
>
addReplace
(
1
1
)
;
}
}
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
prev
=
srcIndex
;
}
if
(
srcIndex
>
=
srcLength
)
{
break
;
}
int32_t
cpStart
;
csc
-
>
cpStart
=
cpStart
=
srcIndex
+
+
;
char16_t
trail
;
UChar32
c
;
if
(
U16_IS_LEAD
(
lead
)
&
&
srcIndex
<
srcLength
&
&
U16_IS_TRAIL
(
trail
=
src
[
srcIndex
]
)
)
{
c
=
U16_GET_SUPPLEMENTARY
(
lead
trail
)
;
+
+
srcIndex
;
}
else
{
c
=
lead
;
}
csc
-
>
cpLimit
=
srcIndex
;
const
char16_t
*
s
;
c
=
ucase_toFullUpper
(
c
utf16_caseContextIterator
csc
&
s
caseLocale
)
;
if
(
c
>
=
0
)
{
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
prev
cpStart
-
prev
options
edits
)
;
if
(
destIndex
>
=
0
)
{
destIndex
=
appendResult
(
dest
destIndex
destCapacity
c
s
srcIndex
-
cpStart
options
edits
)
;
}
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
prev
=
srcIndex
;
}
}
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
prev
srcIndex
-
prev
options
edits
)
;
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
return
destIndex
;
}
}
U_NAMESPACE_END
U_NAMESPACE_USE
#
if
!
UCONFIG_NO_BREAK_ITERATION
namespace
{
int32_t
maybeTitleDutchIJ
(
const
char16_t
*
src
UChar32
c
int32_t
start
int32_t
segmentLimit
char16_t
*
dest
int32_t
&
destIndex
int32_t
destCapacity
uint32_t
options
icu
:
:
Edits
*
edits
)
{
U_ASSERT
(
start
<
segmentLimit
)
;
int32_t
index
=
start
;
bool
withAcute
=
false
;
int32_t
unchanged1
=
0
;
bool
doTitleJ
=
false
;
int32_t
unchanged2
=
0
;
char16_t
c2
=
src
[
index
+
+
]
;
if
(
c
=
=
u
'
I
'
)
{
if
(
c2
=
=
ACUTE
)
{
withAcute
=
true
;
unchanged1
=
1
;
if
(
index
=
=
segmentLimit
)
{
return
start
;
}
c2
=
src
[
index
+
+
]
;
}
}
else
{
withAcute
=
true
;
}
if
(
c2
=
=
u
'
j
'
)
{
doTitleJ
=
true
;
}
else
if
(
c2
=
=
u
'
J
'
)
{
+
+
unchanged1
;
}
else
{
return
start
;
}
if
(
withAcute
)
{
if
(
index
=
=
segmentLimit
|
|
src
[
index
+
+
]
!
=
ACUTE
)
{
return
start
;
}
if
(
doTitleJ
)
{
unchanged2
=
1
;
}
else
{
+
+
unchanged1
;
}
}
if
(
index
<
segmentLimit
)
{
int32_t
cp
;
int32_t
i
=
index
;
U16_NEXT
(
src
i
segmentLimit
cp
)
;
uint32_t
typeMask
=
U_GET_GC_MASK
(
cp
)
;
if
(
(
typeMask
&
U_GC_M_MASK
)
!
=
0
)
{
return
start
;
}
}
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
start
unchanged1
options
edits
)
;
start
+
=
unchanged1
;
if
(
doTitleJ
)
{
destIndex
=
appendUChar
(
dest
destIndex
destCapacity
u
'
J
'
)
;
if
(
edits
!
=
nullptr
)
{
edits
-
>
addReplace
(
1
1
)
;
}
+
+
start
;
}
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
start
unchanged2
options
edits
)
;
U_ASSERT
(
start
+
unchanged2
=
=
index
)
;
return
index
;
}
}
U_CFUNC
int32_t
U_CALLCONV
ustrcase_internalToTitle
(
int32_t
caseLocale
uint32_t
options
BreakIterator
*
iter
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
{
if
(
!
ustrcase_checkTitleAdjustmentOptions
(
options
errorCode
)
)
{
return
0
;
}
UCaseContext
csc
=
UCASECONTEXT_INITIALIZER
;
csc
.
p
=
(
void
*
)
src
;
csc
.
limit
=
srcLength
;
int32_t
destIndex
=
0
;
int32_t
prev
=
0
;
bool
isFirstIndex
=
true
;
while
(
prev
<
srcLength
)
{
int32_t
index
;
if
(
isFirstIndex
)
{
isFirstIndex
=
false
;
index
=
iter
-
>
first
(
)
;
}
else
{
index
=
iter
-
>
next
(
)
;
}
if
(
index
=
=
UBRK_DONE
|
|
index
>
srcLength
)
{
index
=
srcLength
;
}
if
(
prev
<
index
)
{
int32_t
titleStart
=
prev
;
int32_t
titleLimit
=
prev
;
UChar32
c
;
U16_NEXT
(
src
titleLimit
index
c
)
;
if
(
(
options
&
U_TITLECASE_NO_BREAK_ADJUSTMENT
)
=
=
0
)
{
bool
toCased
=
(
options
&
U_TITLECASE_ADJUST_TO_CASED
)
!
=
0
;
while
(
toCased
?
UCASE_NONE
=
=
ucase_getType
(
c
)
:
!
ustrcase_isLNS
(
c
)
)
{
titleStart
=
titleLimit
;
if
(
titleLimit
=
=
index
)
{
break
;
}
U16_NEXT
(
src
titleLimit
index
c
)
;
}
if
(
prev
<
titleStart
)
{
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
prev
titleStart
-
prev
options
edits
)
;
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
}
}
if
(
titleStart
<
titleLimit
)
{
csc
.
cpStart
=
titleStart
;
csc
.
cpLimit
=
titleLimit
;
const
char16_t
*
s
;
c
=
ucase_toFullTitle
(
c
utf16_caseContextIterator
&
csc
&
s
caseLocale
)
;
destIndex
=
appendResult
(
dest
destIndex
destCapacity
c
s
titleLimit
-
titleStart
options
edits
)
;
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
if
(
titleStart
+
1
<
index
&
&
caseLocale
=
=
UCASE_LOC_DUTCH
)
{
if
(
c
<
0
)
{
c
=
~
c
;
}
if
(
c
=
=
u
'
I
'
|
|
c
=
=
u
'
'
)
{
titleLimit
=
maybeTitleDutchIJ
(
src
c
titleStart
+
1
index
dest
destIndex
destCapacity
options
edits
)
;
}
}
if
(
titleLimit
<
index
)
{
if
(
(
options
&
U_TITLECASE_NO_LOWERCASE
)
=
=
0
)
{
destIndex
+
=
toLower
(
caseLocale
options
(
dest
=
=
nullptr
)
?
nullptr
:
dest
+
destIndex
destCapacity
-
destIndex
src
&
csc
titleLimit
index
edits
errorCode
)
;
if
(
errorCode
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
errorCode
=
U_ZERO_ERROR
;
}
if
(
U_FAILURE
(
errorCode
)
)
{
return
destIndex
;
}
}
else
{
destIndex
=
appendUnchanged
(
dest
destIndex
destCapacity
src
+
titleLimit
index
-
titleLimit
options
edits
)
;
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
}
}
}
}
prev
=
index
;
}
return
checkOverflowAndEditsError
(
destIndex
destCapacity
edits
errorCode
)
;
}
#
endif
U_NAMESPACE_BEGIN
namespace
GreekUpper
{
static
const
uint16_t
data0370
[
]
=
{
0x0370
0x0370
0x0372
0x0372
0
0
0x0376
0x0376
0
0
0x037A
0x03FD
0x03FE
0x03FF
0
0x037F
0
0
0
0
0
0
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
|
HAS_DIALYTIKA
0x0391
|
HAS_VOWEL
0x0392
0x0393
0x0394
0x0395
|
HAS_VOWEL
0x0396
0x0397
|
HAS_VOWEL
0x0398
0x0399
|
HAS_VOWEL
0x039A
0x039B
0x039C
0x039D
0x039E
0x039F
|
HAS_VOWEL
0x03A0
0x03A1
0
0x03A3
0x03A4
0x03A5
|
HAS_VOWEL
0x03A6
0x03A7
0x03A8
0x03A9
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
|
HAS_DIALYTIKA
0x03A5
|
HAS_VOWEL
|
HAS_DIALYTIKA
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
|
HAS_DIALYTIKA
0x0391
|
HAS_VOWEL
0x0392
0x0393
0x0394
0x0395
|
HAS_VOWEL
0x0396
0x0397
|
HAS_VOWEL
0x0398
0x0399
|
HAS_VOWEL
0x039A
0x039B
0x039C
0x039D
0x039E
0x039F
|
HAS_VOWEL
0x03A0
0x03A1
0x03A3
0x03A3
0x03A4
0x03A5
|
HAS_VOWEL
0x03A6
0x03A7
0x03A8
0x03A9
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
|
HAS_DIALYTIKA
0x03A5
|
HAS_VOWEL
|
HAS_DIALYTIKA
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03CF
0x0392
0x0398
0x03D2
0x03D2
|
HAS_ACCENT
0x03D2
|
HAS_DIALYTIKA
0x03A6
0x03A0
0x03CF
0x03D8
0x03D8
0x03DA
0x03DA
0x03DC
0x03DC
0x03DE
0x03DE
0x03E0
0x03E0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0x039A
0x03A1
0x03F9
0x037F
0x03F4
0x0395
|
HAS_VOWEL
0
0x03F7
0x03F7
0x03F9
0x03FA
0x03FA
0x03FC
0x03FD
0x03FE
0x03FF
}
;
static
const
uint16_t
data1F00
[
]
=
{
0x0391
|
HAS_VOWEL
0x0391
|
HAS_VOWEL
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
0x0391
|
HAS_VOWEL
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
0x0395
|
HAS_VOWEL
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0
0
0x0395
|
HAS_VOWEL
0x0395
|
HAS_VOWEL
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0
0
0x0397
|
HAS_VOWEL
0x0397
|
HAS_VOWEL
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
0x0397
|
HAS_VOWEL
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
0x039F
|
HAS_VOWEL
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0
0
0x039F
|
HAS_VOWEL
0x039F
|
HAS_VOWEL
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0
0
0x03A5
|
HAS_VOWEL
0x03A5
|
HAS_VOWEL
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0
0x03A5
|
HAS_VOWEL
0
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
0x03A9
|
HAS_VOWEL
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
0x03A9
|
HAS_VOWEL
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0
0
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
0x0391
|
HAS_VOWEL
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
0x0391
|
HAS_VOWEL
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_ACCENT
0x0391
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0
0x0399
|
HAS_VOWEL
0
0
0
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0395
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_ACCENT
0x0397
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0
0
0
0x0399
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
|
HAS_DIALYTIKA
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
|
HAS_DIALYTIKA
0
0
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
|
HAS_DIALYTIKA
0x0399
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0x0399
|
HAS_VOWEL
|
HAS_ACCENT
0
0
0
0
0x03A5
|
HAS_VOWEL
0x03A5
|
HAS_VOWEL
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
|
HAS_DIALYTIKA
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
|
HAS_DIALYTIKA
0x03A1
0x03A1
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
|
HAS_DIALYTIKA
0x03A5
|
HAS_VOWEL
0x03A5
|
HAS_VOWEL
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A5
|
HAS_VOWEL
|
HAS_ACCENT
0x03A1
0
0
0
0
0
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x039F
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_ACCENT
0x03A9
|
HAS_VOWEL
|
HAS_YPOGEGRAMMENI
0
0
0
}
;
static
const
uint16_t
data2126
=
0x03A9
|
HAS_VOWEL
;
uint32_t
getLetterData
(
UChar32
c
)
{
if
(
c
<
0x370
|
|
0x2126
<
c
|
|
(
0x3ff
<
c
&
&
c
<
0x1f00
)
)
{
return
0
;
}
else
if
(
c
<
=
0x3ff
)
{
return
data0370
[
c
-
0x370
]
;
}
else
if
(
c
<
=
0x1fff
)
{
return
data1F00
[
c
-
0x1f00
]
;
}
else
if
(
c
=
=
0x2126
)
{
return
data2126
;
}
else
{
return
0
;
}
}
uint32_t
getDiacriticData
(
UChar32
c
)
{
switch
(
c
)
{
case
0x0300
:
case
0x0301
:
case
0x0342
:
case
0x0302
:
case
0x0303
:
case
0x0311
:
return
HAS_ACCENT
;
case
0x0308
:
return
HAS_COMBINING_DIALYTIKA
;
case
0x0344
:
return
HAS_COMBINING_DIALYTIKA
|
HAS_ACCENT
;
case
0x0345
:
return
HAS_YPOGEGRAMMENI
;
case
0x0304
:
case
0x0306
:
case
0x0313
:
case
0x0314
:
case
0x0343
:
return
HAS_OTHER_GREEK_DIACRITIC
;
default
:
return
0
;
}
}
UBool
isFollowedByCasedLetter
(
const
char16_t
*
s
int32_t
i
int32_t
length
)
{
while
(
i
<
length
)
{
UChar32
c
;
U16_NEXT
(
s
i
length
c
)
;
int32_t
type
=
ucase_getTypeOrIgnorable
(
c
)
;
if
(
(
type
&
UCASE_IGNORABLE
)
!
=
0
)
{
}
else
if
(
type
!
=
UCASE_NONE
)
{
return
true
;
}
else
{
return
false
;
}
}
return
false
;
}
int32_t
toUpper
(
uint32_t
options
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
int32_t
srcLength
Edits
*
edits
UErrorCode
&
errorCode
)
{
int32_t
destIndex
=
0
;
uint32_t
state
=
0
;
for
(
int32_t
i
=
0
;
i
<
srcLength
;
)
{
int32_t
nextIndex
=
i
;
UChar32
c
;
U16_NEXT
(
src
nextIndex
srcLength
c
)
;
uint32_t
nextState
=
0
;
int32_t
type
=
ucase_getTypeOrIgnorable
(
c
)
;
if
(
(
type
&
UCASE_IGNORABLE
)
!
=
0
)
{
nextState
|
=
(
state
&
AFTER_CASED
)
;
}
else
if
(
type
!
=
UCASE_NONE
)
{
nextState
|
=
AFTER_CASED
;
}
uint32_t
data
=
getLetterData
(
c
)
;
if
(
data
>
0
)
{
uint32_t
upper
=
data
&
UPPER_MASK
;
if
(
(
data
&
HAS_VOWEL
)
!
=
0
&
&
(
state
&
AFTER_VOWEL_WITH_ACCENT
)
!
=
0
&
&
(
upper
=
=
0x399
|
|
upper
=
=
0x3A5
)
)
{
data
|
=
HAS_DIALYTIKA
;
}
int32_t
numYpogegrammeni
=
0
;
if
(
(
data
&
HAS_YPOGEGRAMMENI
)
!
=
0
)
{
numYpogegrammeni
=
1
;
}
while
(
nextIndex
<
srcLength
)
{
uint32_t
diacriticData
=
getDiacriticData
(
src
[
nextIndex
]
)
;
if
(
diacriticData
!
=
0
)
{
data
|
=
diacriticData
;
if
(
(
diacriticData
&
HAS_YPOGEGRAMMENI
)
!
=
0
)
{
+
+
numYpogegrammeni
;
}
+
+
nextIndex
;
}
else
{
break
;
}
}
if
(
(
data
&
HAS_VOWEL_AND_ACCENT_AND_DIALYTIKA
)
=
=
HAS_VOWEL_AND_ACCENT
)
{
nextState
|
=
AFTER_VOWEL_WITH_ACCENT
;
}
UBool
addTonos
=
false
;
if
(
upper
=
=
0x397
&
&
(
data
&
HAS_ACCENT
)
!
=
0
&
&
numYpogegrammeni
=
=
0
&
&
(
state
&
AFTER_CASED
)
=
=
0
&
&
!
isFollowedByCasedLetter
(
src
nextIndex
srcLength
)
)
{
if
(
i
=
=
nextIndex
)
{
upper
=
0x389
;
}
else
{
addTonos
=
true
;
}
}
else
if
(
(
data
&
HAS_DIALYTIKA
)
!
=
0
)
{
if
(
upper
=
=
0x399
)
{
upper
=
0x3AA
;
data
&
=
~
HAS_EITHER_DIALYTIKA
;
}
else
if
(
upper
=
=
0x3A5
)
{
upper
=
0x3AB
;
data
&
=
~
HAS_EITHER_DIALYTIKA
;
}
}
UBool
change
;
if
(
edits
=
=
nullptr
&
&
(
options
&
U_OMIT_UNCHANGED_TEXT
)
=
=
0
)
{
change
=
true
;
}
else
{
change
=
src
[
i
]
!
=
upper
|
|
numYpogegrammeni
>
0
;
int32_t
i2
=
i
+
1
;
if
(
(
data
&
HAS_EITHER_DIALYTIKA
)
!
=
0
)
{
change
|
=
i2
>
=
nextIndex
|
|
src
[
i2
]
!
=
0x308
;
+
+
i2
;
}
if
(
addTonos
)
{
change
|
=
i2
>
=
nextIndex
|
|
src
[
i2
]
!
=
0x301
;
+
+
i2
;
}
int32_t
oldLength
=
nextIndex
-
i
;
int32_t
newLength
=
(
i2
-
i
)
+
numYpogegrammeni
;
change
|
=
oldLength
!
=
newLength
;
if
(
change
)
{
if
(
edits
!
=
nullptr
)
{
edits
-
>
addReplace
(
oldLength
newLength
)
;
}
}
else
{
if
(
edits
!
=
nullptr
)
{
edits
-
>
addUnchanged
(
oldLength
)
;
}
change
=
(
options
&
U_OMIT_UNCHANGED_TEXT
)
=
=
0
;
}
}
if
(
change
)
{
destIndex
=
appendUChar
(
dest
destIndex
destCapacity
(
char16_t
)
upper
)
;
if
(
destIndex
>
=
0
&
&
(
data
&
HAS_EITHER_DIALYTIKA
)
!
=
0
)
{
destIndex
=
appendUChar
(
dest
destIndex
destCapacity
0x308
)
;
}
if
(
destIndex
>
=
0
&
&
addTonos
)
{
destIndex
=
appendUChar
(
dest
destIndex
destCapacity
0x301
)
;
}
while
(
destIndex
>
=
0
&
&
numYpogegrammeni
>
0
)
{
destIndex
=
appendUChar
(
dest
destIndex
destCapacity
0x399
)
;
-
-
numYpogegrammeni
;
}
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
}
}
else
{
const
char16_t
*
s
;
c
=
ucase_toFullUpper
(
c
nullptr
nullptr
&
s
UCASE_LOC_GREEK
)
;
destIndex
=
appendResult
(
dest
destIndex
destCapacity
c
s
nextIndex
-
i
options
edits
)
;
if
(
destIndex
<
0
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
}
i
=
nextIndex
;
state
=
nextState
;
}
return
destIndex
;
}
}
U_NAMESPACE_END
U_CFUNC
int32_t
U_CALLCONV
ustrcase_internalToLower
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_UNUSED
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
{
UCaseContext
csc
=
UCASECONTEXT_INITIALIZER
;
csc
.
p
=
(
void
*
)
src
;
csc
.
limit
=
srcLength
;
int32_t
destIndex
=
toLower
(
caseLocale
options
dest
destCapacity
src
&
csc
0
srcLength
edits
errorCode
)
;
return
checkOverflowAndEditsError
(
destIndex
destCapacity
edits
errorCode
)
;
}
U_CFUNC
int32_t
U_CALLCONV
ustrcase_internalToUpper
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_UNUSED
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
{
int32_t
destIndex
;
if
(
caseLocale
=
=
UCASE_LOC_GREEK
)
{
destIndex
=
GreekUpper
:
:
toUpper
(
options
dest
destCapacity
src
srcLength
edits
errorCode
)
;
}
else
{
UCaseContext
csc
=
UCASECONTEXT_INITIALIZER
;
csc
.
p
=
(
void
*
)
src
;
csc
.
limit
=
srcLength
;
destIndex
=
toUpper
(
caseLocale
options
dest
destCapacity
src
&
csc
srcLength
edits
errorCode
)
;
}
return
checkOverflowAndEditsError
(
destIndex
destCapacity
edits
errorCode
)
;
}
U_CFUNC
int32_t
U_CALLCONV
ustrcase_internalFold
(
int32_t
uint32_t
options
UCASEMAP_BREAK_ITERATOR_UNUSED
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
{
int32_t
destIndex
=
toLower
(
-
1
options
dest
destCapacity
src
nullptr
0
srcLength
edits
errorCode
)
;
return
checkOverflowAndEditsError
(
destIndex
destCapacity
edits
errorCode
)
;
}
U_CFUNC
int32_t
ustrcase_map
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_PARAM
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
int32_t
srcLength
UStringCaseMapper
*
stringCaseMapper
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
{
int32_t
destLength
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
0
;
}
if
(
destCapacity
<
0
|
|
(
dest
=
=
nullptr
&
&
destCapacity
>
0
)
|
|
src
=
=
nullptr
|
|
srcLength
<
-
1
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
if
(
srcLength
=
=
-
1
)
{
srcLength
=
u_strlen
(
src
)
;
}
if
(
dest
!
=
nullptr
&
&
(
(
src
>
=
dest
&
&
src
<
(
dest
+
destCapacity
)
)
|
|
(
dest
>
=
src
&
&
dest
<
(
src
+
srcLength
)
)
)
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
if
(
edits
!
=
nullptr
&
&
(
options
&
U_EDITS_NO_RESET
)
=
=
0
)
{
edits
-
>
reset
(
)
;
}
destLength
=
stringCaseMapper
(
caseLocale
options
UCASEMAP_BREAK_ITERATOR
dest
destCapacity
src
srcLength
edits
errorCode
)
;
return
u_terminateUChars
(
dest
destCapacity
destLength
&
errorCode
)
;
}
U_CFUNC
int32_t
ustrcase_mapWithOverlap
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_PARAM
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
int32_t
srcLength
UStringCaseMapper
*
stringCaseMapper
UErrorCode
&
errorCode
)
{
char16_t
buffer
[
300
]
;
char16_t
*
temp
;
int32_t
destLength
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
0
;
}
if
(
destCapacity
<
0
|
|
(
dest
=
=
nullptr
&
&
destCapacity
>
0
)
|
|
src
=
=
nullptr
|
|
srcLength
<
-
1
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
if
(
srcLength
=
=
-
1
)
{
srcLength
=
u_strlen
(
src
)
;
}
if
(
dest
!
=
nullptr
&
&
(
(
src
>
=
dest
&
&
src
<
(
dest
+
destCapacity
)
)
|
|
(
dest
>
=
src
&
&
dest
<
(
src
+
srcLength
)
)
)
)
{
if
(
destCapacity
<
=
UPRV_LENGTHOF
(
buffer
)
)
{
temp
=
buffer
;
}
else
{
temp
=
(
char16_t
*
)
uprv_malloc
(
destCapacity
*
U_SIZEOF_UCHAR
)
;
if
(
temp
=
=
nullptr
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
return
0
;
}
}
}
else
{
temp
=
dest
;
}
destLength
=
stringCaseMapper
(
caseLocale
options
UCASEMAP_BREAK_ITERATOR
temp
destCapacity
src
srcLength
nullptr
errorCode
)
;
if
(
temp
!
=
dest
)
{
if
(
U_SUCCESS
(
errorCode
)
&
&
0
<
destLength
&
&
destLength
<
=
destCapacity
)
{
u_memmove
(
dest
temp
destLength
)
;
}
if
(
temp
!
=
buffer
)
{
uprv_free
(
temp
)
;
}
}
return
u_terminateUChars
(
dest
destCapacity
destLength
&
errorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
u_strFoldCase
(
char16_t
*
dest
int32_t
destCapacity
const
char16_t
*
src
int32_t
srcLength
uint32_t
options
UErrorCode
*
pErrorCode
)
{
return
ustrcase_mapWithOverlap
(
UCASE_LOC_ROOT
options
UCASEMAP_BREAK_ITERATOR_NULL
dest
destCapacity
src
srcLength
ustrcase_internalFold
*
pErrorCode
)
;
}
U_NAMESPACE_BEGIN
int32_t
CaseMap
:
:
fold
(
uint32_t
options
const
char16_t
*
src
int32_t
srcLength
char16_t
*
dest
int32_t
destCapacity
Edits
*
edits
UErrorCode
&
errorCode
)
{
return
ustrcase_map
(
UCASE_LOC_ROOT
options
UCASEMAP_BREAK_ITERATOR_NULL
dest
destCapacity
src
srcLength
ustrcase_internalFold
edits
errorCode
)
;
}
U_NAMESPACE_END
struct
CmpEquivLevel
{
const
char16_t
*
start
*
s
*
limit
;
}
;
typedef
struct
CmpEquivLevel
CmpEquivLevel
;
static
int32_t
_cmpFold
(
const
char16_t
*
s1
int32_t
length1
const
char16_t
*
s2
int32_t
length2
uint32_t
options
int32_t
*
matchLen1
int32_t
*
matchLen2
UErrorCode
*
pErrorCode
)
{
int32_t
cmpRes
=
0
;
const
char16_t
*
start1
*
start2
*
limit1
*
limit2
;
const
char16_t
*
org1
*
org2
;
const
char16_t
*
m1
*
m2
;
const
char16_t
*
p
;
int32_t
length
;
CmpEquivLevel
stack1
[
2
]
stack2
[
2
]
;
char16_t
fold1
[
UCASE_MAX_STRING_LENGTH
+
1
]
fold2
[
UCASE_MAX_STRING_LENGTH
+
1
]
;
int32_t
level1
level2
;
UChar32
c1
c2
cp1
cp2
;
if
(
U_FAILURE
(
*
pErrorCode
)
)
{
return
0
;
}
if
(
matchLen1
)
{
U_ASSERT
(
matchLen2
!
=
nullptr
)
;
*
matchLen1
=
0
;
*
matchLen2
=
0
;
}
start1
=
m1
=
org1
=
s1
;
if
(
length1
=
=
-
1
)
{
limit1
=
nullptr
;
}
else
{
limit1
=
s1
+
length1
;
}
start2
=
m2
=
org2
=
s2
;
if
(
length2
=
=
-
1
)
{
limit2
=
nullptr
;
}
else
{
limit2
=
s2
+
length2
;
}
level1
=
level2
=
0
;
c1
=
c2
=
-
1
;
for
(
;
;
)
{
if
(
c1
<
0
)
{
for
(
;
;
)
{
if
(
s1
=
=
limit1
|
|
(
(
c1
=
*
s1
)
=
=
0
&
&
(
limit1
=
=
nullptr
|
|
(
options
&
_STRNCMP_STYLE
)
)
)
)
{
if
(
level1
=
=
0
)
{
c1
=
-
1
;
break
;
}
}
else
{
+
+
s1
;
break
;
}
do
{
-
-
level1
;
start1
=
stack1
[
level1
]
.
start
;
}
while
(
start1
=
=
nullptr
)
;
s1
=
stack1
[
level1
]
.
s
;
limit1
=
stack1
[
level1
]
.
limit
;
}
}
if
(
c2
<
0
)
{
for
(
;
;
)
{
if
(
s2
=
=
limit2
|
|
(
(
c2
=
*
s2
)
=
=
0
&
&
(
limit2
=
=
nullptr
|
|
(
options
&
_STRNCMP_STYLE
)
)
)
)
{
if
(
level2
=
=
0
)
{
c2
=
-
1
;
break
;
}
}
else
{
+
+
s2
;
break
;
}
do
{
-
-
level2
;
start2
=
stack2
[
level2
]
.
start
;
}
while
(
start2
=
=
nullptr
)
;
s2
=
stack2
[
level2
]
.
s
;
limit2
=
stack2
[
level2
]
.
limit
;
}
}
if
(
c1
=
=
c2
)
{
const
char16_t
*
next1
*
next2
;
if
(
c1
<
0
)
{
cmpRes
=
0
;
break
;
}
next1
=
next2
=
nullptr
;
if
(
level1
=
=
0
)
{
next1
=
s1
;
}
else
if
(
s1
=
=
limit1
)
{
U_ASSERT
(
level1
=
=
1
)
;
next1
=
stack1
[
0
]
.
s
;
}
if
(
next1
!
=
nullptr
)
{
if
(
level2
=
=
0
)
{
next2
=
s2
;
}
else
if
(
s2
=
=
limit2
)
{
U_ASSERT
(
level2
=
=
1
)
;
next2
=
stack2
[
0
]
.
s
;
}
if
(
next2
!
=
nullptr
)
{
m1
=
next1
;
m2
=
next2
;
}
}
c1
=
c2
=
-
1
;
continue
;
}
else
if
(
c1
<
0
)
{
cmpRes
=
-
1
;
break
;
}
else
if
(
c2
<
0
)
{
cmpRes
=
1
;
break
;
}
cp1
=
c1
;
if
(
U_IS_SURROGATE
(
c1
)
)
{
char16_t
c
;
if
(
U_IS_SURROGATE_LEAD
(
c1
)
)
{
if
(
s1
!
=
limit1
&
&
U16_IS_TRAIL
(
c
=
*
s1
)
)
{
cp1
=
U16_GET_SUPPLEMENTARY
(
c1
c
)
;
}
}
else
{
if
(
start1
<
=
(
s1
-
2
)
&
&
U16_IS_LEAD
(
c
=
*
(
s1
-
2
)
)
)
{
cp1
=
U16_GET_SUPPLEMENTARY
(
c
c1
)
;
}
}
}
cp2
=
c2
;
if
(
U_IS_SURROGATE
(
c2
)
)
{
char16_t
c
;
if
(
U_IS_SURROGATE_LEAD
(
c2
)
)
{
if
(
s2
!
=
limit2
&
&
U16_IS_TRAIL
(
c
=
*
s2
)
)
{
cp2
=
U16_GET_SUPPLEMENTARY
(
c2
c
)
;
}
}
else
{
if
(
start2
<
=
(
s2
-
2
)
&
&
U16_IS_LEAD
(
c
=
*
(
s2
-
2
)
)
)
{
cp2
=
U16_GET_SUPPLEMENTARY
(
c
c2
)
;
}
}
}
if
(
level1
=
=
0
&
&
(
length
=
ucase_toFullFolding
(
(
UChar32
)
cp1
&
p
options
)
)
>
=
0
)
{
if
(
U_IS_SURROGATE
(
c1
)
)
{
if
(
U_IS_SURROGATE_LEAD
(
c1
)
)
{
+
+
s1
;
}
else
{
-
-
s2
;
-
-
m2
;
c2
=
*
(
s2
-
1
)
;
}
}
stack1
[
0
]
.
start
=
start1
;
stack1
[
0
]
.
s
=
s1
;
stack1
[
0
]
.
limit
=
limit1
;
+
+
level1
;
if
(
length
<
=
UCASE_MAX_STRING_LENGTH
)
{
u_memcpy
(
fold1
p
length
)
;
}
else
{
int32_t
i
=
0
;
U16_APPEND_UNSAFE
(
fold1
i
length
)
;
length
=
i
;
}
start1
=
s1
=
fold1
;
limit1
=
fold1
+
length
;
c1
=
-
1
;
continue
;
}
if
(
level2
=
=
0
&
&
(
length
=
ucase_toFullFolding
(
(
UChar32
)
cp2
&
p
options
)
)
>
=
0
)
{
if
(
U_IS_SURROGATE
(
c2
)
)
{
if
(
U_IS_SURROGATE_LEAD
(
c2
)
)
{
+
+
s2
;
}
else
{
-
-
s1
;
-
-
m2
;
c1
=
*
(
s1
-
1
)
;
}
}
stack2
[
0
]
.
start
=
start2
;
stack2
[
0
]
.
s
=
s2
;
stack2
[
0
]
.
limit
=
limit2
;
+
+
level2
;
if
(
length
<
=
UCASE_MAX_STRING_LENGTH
)
{
u_memcpy
(
fold2
p
length
)
;
}
else
{
int32_t
i
=
0
;
U16_APPEND_UNSAFE
(
fold2
i
length
)
;
length
=
i
;
}
start2
=
s2
=
fold2
;
limit2
=
fold2
+
length
;
c2
=
-
1
;
continue
;
}
if
(
c1
>
=
0xd800
&
&
c2
>
=
0xd800
&
&
(
options
&
U_COMPARE_CODE_POINT_ORDER
)
)
{
if
(
(
c1
<
=
0xdbff
&
&
s1
!
=
limit1
&
&
U16_IS_TRAIL
(
*
s1
)
)
|
|
(
U16_IS_TRAIL
(
c1
)
&
&
start1
!
=
(
s1
-
1
)
&
&
U16_IS_LEAD
(
*
(
s1
-
2
)
)
)
)
{
}
else
{
c1
-
=
0x2800
;
}
if
(
(
c2
<
=
0xdbff
&
&
s2
!
=
limit2
&
&
U16_IS_TRAIL
(
*
s2
)
)
|
|
(
U16_IS_TRAIL
(
c2
)
&
&
start2
!
=
(
s2
-
1
)
&
&
U16_IS_LEAD
(
*
(
s2
-
2
)
)
)
)
{
}
else
{
c2
-
=
0x2800
;
}
}
cmpRes
=
c1
-
c2
;
break
;
}
if
(
matchLen1
)
{
*
matchLen1
=
static_cast
<
int32_t
>
(
m1
-
org1
)
;
*
matchLen2
=
static_cast
<
int32_t
>
(
m2
-
org2
)
;
}
return
cmpRes
;
}
U_CFUNC
int32_t
u_strcmpFold
(
const
char16_t
*
s1
int32_t
length1
const
char16_t
*
s2
int32_t
length2
uint32_t
options
UErrorCode
*
pErrorCode
)
{
return
_cmpFold
(
s1
length1
s2
length2
options
nullptr
nullptr
pErrorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
u_strCaseCompare
(
const
char16_t
*
s1
int32_t
length1
const
char16_t
*
s2
int32_t
length2
uint32_t
options
UErrorCode
*
pErrorCode
)
{
if
(
pErrorCode
=
=
0
|
|
U_FAILURE
(
*
pErrorCode
)
)
{
return
0
;
}
if
(
s1
=
=
nullptr
|
|
length1
<
-
1
|
|
s2
=
=
nullptr
|
|
length2
<
-
1
)
{
*
pErrorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
return
u_strcmpFold
(
s1
length1
s2
length2
options
|
U_COMPARE_IGNORE_CASE
pErrorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
u_strcasecmp
(
const
char16_t
*
s1
const
char16_t
*
s2
uint32_t
options
)
{
UErrorCode
errorCode
=
U_ZERO_ERROR
;
return
u_strcmpFold
(
s1
-
1
s2
-
1
options
|
U_COMPARE_IGNORE_CASE
&
errorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
u_memcasecmp
(
const
char16_t
*
s1
const
char16_t
*
s2
int32_t
length
uint32_t
options
)
{
UErrorCode
errorCode
=
U_ZERO_ERROR
;
return
u_strcmpFold
(
s1
length
s2
length
options
|
U_COMPARE_IGNORE_CASE
&
errorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
u_strncasecmp
(
const
char16_t
*
s1
const
char16_t
*
s2
int32_t
n
uint32_t
options
)
{
UErrorCode
errorCode
=
U_ZERO_ERROR
;
return
u_strcmpFold
(
s1
n
s2
n
options
|
(
U_COMPARE_IGNORE_CASE
|
_STRNCMP_STYLE
)
&
errorCode
)
;
}
U_CAPI
void
u_caseInsensitivePrefixMatch
(
const
char16_t
*
s1
int32_t
length1
const
char16_t
*
s2
int32_t
length2
uint32_t
options
int32_t
*
matchLen1
int32_t
*
matchLen2
UErrorCode
*
pErrorCode
)
{
_cmpFold
(
s1
length1
s2
length2
options
matchLen1
matchLen2
pErrorCode
)
;
}
