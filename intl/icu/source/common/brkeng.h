#
ifndef
BRKENG_H
#
define
BRKENG_H
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
unicode
/
utext
.
h
"
#
include
"
unicode
/
uscript
.
h
"
U_NAMESPACE_BEGIN
class
UnicodeSet
;
class
UStack
;
class
UVector32
;
class
DictionaryMatcher
;
class
LanguageBreakEngine
:
public
UMemory
{
public
:
LanguageBreakEngine
(
)
;
virtual
~
LanguageBreakEngine
(
)
;
virtual
UBool
handles
(
UChar32
c
)
const
=
0
;
virtual
int32_t
findBreaks
(
UText
*
text
int32_t
startPos
int32_t
endPos
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
=
0
;
}
;
class
LanguageBreakFactory
:
public
UMemory
{
public
:
LanguageBreakFactory
(
)
;
virtual
~
LanguageBreakFactory
(
)
;
virtual
const
LanguageBreakEngine
*
getEngineFor
(
UChar32
c
)
=
0
;
}
;
class
UnhandledEngine
:
public
LanguageBreakEngine
{
private
:
UnicodeSet
*
fHandled
;
public
:
UnhandledEngine
(
UErrorCode
&
status
)
;
virtual
~
UnhandledEngine
(
)
;
virtual
UBool
handles
(
UChar32
c
)
const
override
;
virtual
int32_t
findBreaks
(
UText
*
text
int32_t
startPos
int32_t
endPos
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
override
;
virtual
void
handleCharacter
(
UChar32
c
)
;
}
;
class
ICULanguageBreakFactory
:
public
LanguageBreakFactory
{
private
:
UStack
*
fEngines
;
public
:
ICULanguageBreakFactory
(
UErrorCode
&
status
)
;
virtual
~
ICULanguageBreakFactory
(
)
;
virtual
const
LanguageBreakEngine
*
getEngineFor
(
UChar32
c
)
override
;
protected
:
virtual
const
LanguageBreakEngine
*
loadEngineFor
(
UChar32
c
)
;
virtual
DictionaryMatcher
*
loadDictionaryMatcherFor
(
UScriptCode
script
)
;
}
;
U_NAMESPACE_END
#
endif
