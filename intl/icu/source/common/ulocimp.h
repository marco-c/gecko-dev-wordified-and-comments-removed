#
ifndef
ULOCIMP_H
#
define
ULOCIMP_H
#
include
"
unicode
/
bytestream
.
h
"
#
include
"
unicode
/
uloc
.
h
"
#
include
"
charstr
.
h
"
U_CAPI
UEnumeration
*
U_EXPORT2
uloc_openKeywordList
(
const
char
*
keywordList
int32_t
keywordListSize
UErrorCode
*
status
)
;
U_CAPI
const
UChar
*
U_EXPORT2
uloc_getTableStringWithFallback
(
const
char
*
path
const
char
*
locale
const
char
*
tableKey
const
char
*
subTableKey
const
char
*
itemKey
int32_t
*
pLength
UErrorCode
*
pErrorCode
)
;
#
define
_isIDSeparator
(
a
)
(
a
=
=
'
_
'
|
|
a
=
=
'
-
'
)
U_CFUNC
const
char
*
uloc_getCurrentCountryID
(
const
char
*
oldID
)
;
U_CFUNC
const
char
*
uloc_getCurrentLanguageID
(
const
char
*
oldID
)
;
U_CFUNC
void
ulocimp_getKeywords
(
const
char
*
localeID
char
prev
icu
:
:
ByteSink
&
sink
UBool
valuesToo
UErrorCode
*
status
)
;
icu
:
:
CharString
U_EXPORT2
ulocimp_getLanguage
(
const
char
*
localeID
const
char
*
*
pEnd
UErrorCode
&
status
)
;
icu
:
:
CharString
U_EXPORT2
ulocimp_getScript
(
const
char
*
localeID
const
char
*
*
pEnd
UErrorCode
&
status
)
;
icu
:
:
CharString
U_EXPORT2
ulocimp_getCountry
(
const
char
*
localeID
const
char
*
*
pEnd
UErrorCode
&
status
)
;
U_CAPI
void
U_EXPORT2
ulocimp_getName
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UErrorCode
*
err
)
;
U_CAPI
void
U_EXPORT2
ulocimp_getBaseName
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UErrorCode
*
err
)
;
U_CAPI
void
U_EXPORT2
ulocimp_canonicalize
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UErrorCode
*
err
)
;
U_CAPI
void
U_EXPORT2
ulocimp_getKeywordValue
(
const
char
*
localeID
const
char
*
keywordName
icu
:
:
ByteSink
&
sink
UErrorCode
*
status
)
;
U_CAPI
void
U_EXPORT2
ulocimp_toLanguageTag
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UBool
strict
UErrorCode
*
err
)
;
U_CAPI
void
U_EXPORT2
ulocimp_forLanguageTag
(
const
char
*
langtag
int32_t
tagLen
icu
:
:
ByteSink
&
sink
int32_t
*
parsedLength
UErrorCode
*
err
)
;
U_CAPI
int32_t
U_EXPORT2
ulocimp_getRegionForSupplementalData
(
const
char
*
localeID
UBool
inferRegion
char
*
region
int32_t
regionCapacity
UErrorCode
*
status
)
;
U_CAPI
void
U_EXPORT2
ulocimp_addLikelySubtags
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UErrorCode
*
err
)
;
U_CAPI
void
U_EXPORT2
ulocimp_minimizeSubtags
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UErrorCode
*
err
)
;
U_CAPI
const
char
*
U_EXPORT2
locale_getKeywordsStart
(
const
char
*
localeID
)
;
U_CFUNC
UBool
ultag_isExtensionSubtags
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isLanguageSubtag
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isPrivateuseValueSubtags
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isRegionSubtag
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isScriptSubtag
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isTransformedExtensionSubtags
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isUnicodeExtensionSubtags
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isUnicodeLocaleAttribute
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isUnicodeLocaleAttributes
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isUnicodeLocaleKey
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isUnicodeLocaleType
(
const
char
*
s
int32_t
len
)
;
U_CFUNC
UBool
ultag_isVariantSubtags
(
const
char
*
s
int32_t
len
)
;
U_CAPI
const
char
*
U_EXPORT2
ultag_getTKeyStart
(
const
char
*
localeID
)
;
U_CFUNC
const
char
*
ulocimp_toBcpKey
(
const
char
*
key
)
;
U_CFUNC
const
char
*
ulocimp_toLegacyKey
(
const
char
*
key
)
;
U_CFUNC
const
char
*
ulocimp_toBcpType
(
const
char
*
key
const
char
*
type
UBool
*
isKnownKey
UBool
*
isSpecialType
)
;
U_CFUNC
const
char
*
ulocimp_toLegacyType
(
const
char
*
key
const
char
*
type
UBool
*
isKnownKey
UBool
*
isSpecialType
)
;
U_CAPI
const
char
*
const
*
ulocimp_getKnownCanonicalizedLocaleForTest
(
int32_t
*
length
)
;
U_CAPI
bool
ulocimp_isCanonicalizedLocaleForTest
(
const
char
*
localeName
)
;
class
PreflightingLocaleIDBuffer
{
private
:
char
stackBuffer
[
ULOC_FULLNAME_CAPACITY
]
;
char
*
heapBuffer
=
nullptr
;
int32_t
capacity
=
ULOC_FULLNAME_CAPACITY
;
public
:
int32_t
requestedCapacity
=
ULOC_FULLNAME_CAPACITY
;
static
void
*
U_EXPORT2
operator
new
(
size_t
)
noexcept
=
delete
;
static
void
*
U_EXPORT2
operator
new
[
]
(
size_t
)
noexcept
=
delete
;
#
if
U_HAVE_PLACEMENT_NEW
static
void
*
U_EXPORT2
operator
new
(
size_t
void
*
)
noexcept
=
delete
;
#
endif
PreflightingLocaleIDBuffer
(
)
{
}
~
PreflightingLocaleIDBuffer
(
)
{
uprv_free
(
heapBuffer
)
;
}
char
*
getBuffer
(
)
{
if
(
heapBuffer
=
=
nullptr
)
{
return
stackBuffer
;
}
else
{
return
heapBuffer
;
}
}
int32_t
getCapacity
(
)
{
return
capacity
;
}
bool
needToTryAgain
(
UErrorCode
*
err
)
{
if
(
heapBuffer
!
=
nullptr
)
{
return
false
;
}
if
(
*
err
=
=
U_BUFFER_OVERFLOW_ERROR
|
|
*
err
=
=
U_STRING_NOT_TERMINATED_WARNING
)
{
int32_t
newCapacity
=
requestedCapacity
+
2
;
heapBuffer
=
static_cast
<
char
*
>
(
uprv_malloc
(
newCapacity
)
)
;
if
(
heapBuffer
=
=
nullptr
)
{
*
err
=
U_MEMORY_ALLOCATION_ERROR
;
}
else
{
*
err
=
U_ZERO_ERROR
;
capacity
=
newCapacity
;
}
return
U_SUCCESS
(
*
err
)
;
}
return
false
;
}
}
;
#
endif
