#
include
"
unicode
/
utypes
.
h
"
#
if
U_PLATFORM_USES_ONLY_WIN32_API
#
include
"
wintz
.
h
"
#
include
"
charstr
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
cstring
.
h
"
#
include
"
unicode
/
ures
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
include
"
uresimp
.
h
"
#
ifndef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
#
endif
#
define
VC_EXTRALEAN
#
define
NOUSER
#
define
NOSERVICE
#
define
NOIME
#
define
NOMCX
#
include
<
windows
.
h
>
U_NAMESPACE_BEGIN
#
define
WINDOWS_TIMEZONES_REG_KEY_PATH
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
\
\
Time
Zones
"
#
define
WINDOWS_MAX_REG_KEY_LENGTH
256
#
if
U_PLATFORM_HAS_WINUWP_API
=
=
0
typedef
struct
_REG_TZI_FORMAT
{
LONG
Bias
;
LONG
StandardBias
;
LONG
DaylightBias
;
SYSTEMTIME
StandardDate
;
SYSTEMTIME
DaylightDate
;
}
REG_TZI_FORMAT
;
#
endif
U_CAPI
const
char
*
U_EXPORT2
uprv_detectWindowsTimeZone
(
)
{
DYNAMIC_TIME_ZONE_INFORMATION
dynamicTZI
;
uprv_memset
(
&
dynamicTZI
0
sizeof
(
dynamicTZI
)
)
;
SYSTEMTIME
systemTimeAllZero
;
uprv_memset
(
&
systemTimeAllZero
0
sizeof
(
systemTimeAllZero
)
)
;
if
(
GetDynamicTimeZoneInformation
(
&
dynamicTZI
)
=
=
TIME_ZONE_ID_INVALID
)
{
return
nullptr
;
}
if
(
dynamicTZI
.
DynamicDaylightTimeDisabled
!
=
0
&
&
uprv_memcmp
(
&
dynamicTZI
.
StandardDate
&
dynamicTZI
.
DaylightDate
sizeof
(
dynamicTZI
.
StandardDate
)
)
=
=
0
&
&
(
(
dynamicTZI
.
TimeZoneKeyName
[
0
]
!
=
L
'
\
0
'
&
&
uprv_memcmp
(
&
dynamicTZI
.
StandardDate
&
systemTimeAllZero
sizeof
(
systemTimeAllZero
)
)
=
=
0
)
|
|
(
dynamicTZI
.
TimeZoneKeyName
[
0
]
=
=
L
'
\
0
'
&
&
uprv_memcmp
(
&
dynamicTZI
.
StandardDate
&
systemTimeAllZero
sizeof
(
systemTimeAllZero
)
)
!
=
0
)
)
)
{
LONG
utcOffsetMins
=
dynamicTZI
.
Bias
;
if
(
utcOffsetMins
=
=
0
)
{
return
uprv_strdup
(
"
Etc
/
UTC
"
)
;
}
if
(
utcOffsetMins
%
60
=
=
0
)
{
char
gmtOffsetTz
[
11
]
=
{
}
;
int
ret
=
snprintf
(
gmtOffsetTz
sizeof
(
gmtOffsetTz
)
"
Etc
/
GMT
%
+
ld
"
utcOffsetMins
/
60
)
;
if
(
ret
>
0
&
&
ret
<
UPRV_LENGTHOF
(
gmtOffsetTz
)
)
{
return
uprv_strdup
(
gmtOffsetTz
)
;
}
}
}
WCHAR
timezoneSubKeyName
[
WINDOWS_MAX_REG_KEY_LENGTH
]
;
WCHAR
*
windowsTimeZoneName
=
dynamicTZI
.
TimeZoneKeyName
;
if
(
dynamicTZI
.
TimeZoneKeyName
[
0
]
=
=
0
)
{
#
if
U_PLATFORM_HAS_WINUWP_API
=
=
1
(
void
)
timezoneSubKeyName
;
return
nullptr
;
#
else
LONG
ret
;
HKEY
hKeyAllTimeZones
=
nullptr
;
ret
=
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
WINDOWS_TIMEZONES_REG_KEY_PATH
0
KEY_READ
reinterpret_cast
<
PHKEY
>
(
&
hKeyAllTimeZones
)
)
;
if
(
ret
!
=
ERROR_SUCCESS
)
{
return
nullptr
;
}
DWORD
numTimeZoneSubKeys
;
ret
=
RegQueryInfoKeyW
(
hKeyAllTimeZones
nullptr
nullptr
nullptr
&
numTimeZoneSubKeys
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
)
;
if
(
ret
!
=
ERROR_SUCCESS
)
{
RegCloseKey
(
hKeyAllTimeZones
)
;
return
nullptr
;
}
HKEY
hKeyTimeZoneSubKey
=
nullptr
;
ULONG
registryValueType
;
WCHAR
registryStandardName
[
WINDOWS_MAX_REG_KEY_LENGTH
]
;
for
(
DWORD
i
=
0
;
i
<
numTimeZoneSubKeys
;
i
+
+
)
{
DWORD
size
=
UPRV_LENGTHOF
(
timezoneSubKeyName
)
;
ret
=
RegEnumKeyExW
(
hKeyAllTimeZones
i
timezoneSubKeyName
&
size
nullptr
nullptr
nullptr
nullptr
)
;
if
(
ret
!
=
ERROR_SUCCESS
)
{
RegCloseKey
(
hKeyAllTimeZones
)
;
return
nullptr
;
}
ret
=
RegOpenKeyExW
(
hKeyAllTimeZones
timezoneSubKeyName
0
KEY_READ
reinterpret_cast
<
PHKEY
>
(
&
hKeyTimeZoneSubKey
)
)
;
if
(
ret
!
=
ERROR_SUCCESS
)
{
RegCloseKey
(
hKeyAllTimeZones
)
;
return
nullptr
;
}
size
=
sizeof
(
registryStandardName
)
;
ret
=
RegQueryValueExW
(
hKeyTimeZoneSubKey
L
"
Std
"
nullptr
&
registryValueType
reinterpret_cast
<
LPBYTE
>
(
registryStandardName
)
&
size
)
;
if
(
ret
!
=
ERROR_SUCCESS
|
|
registryValueType
!
=
REG_SZ
)
{
RegCloseKey
(
hKeyTimeZoneSubKey
)
;
RegCloseKey
(
hKeyAllTimeZones
)
;
return
nullptr
;
}
if
(
wcscmp
(
reinterpret_cast
<
WCHAR
*
>
(
registryStandardName
)
dynamicTZI
.
StandardName
)
=
=
0
)
{
REG_TZI_FORMAT
registryTziValue
;
uprv_memset
(
&
registryTziValue
0
sizeof
(
registryTziValue
)
)
;
DWORD
timezoneTziValueSize
=
sizeof
(
registryTziValue
)
;
ret
=
RegQueryValueExW
(
hKeyTimeZoneSubKey
L
"
TZI
"
nullptr
&
registryValueType
reinterpret_cast
<
LPBYTE
>
(
&
registryTziValue
)
&
timezoneTziValueSize
)
;
if
(
ret
=
=
ERROR_SUCCESS
)
{
if
(
(
dynamicTZI
.
Bias
=
=
registryTziValue
.
Bias
)
&
&
(
memcmp
(
(
const
void
*
)
&
dynamicTZI
.
StandardDate
(
const
void
*
)
&
registryTziValue
.
StandardDate
sizeof
(
SYSTEMTIME
)
)
=
=
0
)
&
&
(
memcmp
(
(
const
void
*
)
&
dynamicTZI
.
DaylightDate
(
const
void
*
)
&
registryTziValue
.
DaylightDate
sizeof
(
SYSTEMTIME
)
)
=
=
0
)
)
{
windowsTimeZoneName
=
timezoneSubKeyName
;
break
;
}
}
}
RegCloseKey
(
hKeyTimeZoneSubKey
)
;
hKeyTimeZoneSubKey
=
nullptr
;
}
if
(
hKeyTimeZoneSubKey
!
=
nullptr
)
{
RegCloseKey
(
hKeyTimeZoneSubKey
)
;
}
if
(
hKeyAllTimeZones
!
=
nullptr
)
{
RegCloseKey
(
hKeyAllTimeZones
)
;
}
#
endif
}
CharString
winTZ
;
UErrorCode
status
=
U_ZERO_ERROR
;
winTZ
.
appendInvariantChars
(
UnicodeString
(
true
windowsTimeZoneName
-
1
)
status
)
;
StackUResourceBundle
winTZBundle
;
ures_openDirectFillIn
(
winTZBundle
.
getAlias
(
)
nullptr
"
windowsZones
"
&
status
)
;
ures_getByKey
(
winTZBundle
.
getAlias
(
)
"
mapTimezones
"
winTZBundle
.
getAlias
(
)
&
status
)
;
ures_getByKey
(
winTZBundle
.
getAlias
(
)
winTZ
.
data
(
)
winTZBundle
.
getAlias
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
nullptr
;
}
wchar_t
regionCodeW
[
3
]
=
{
}
;
char
regionCode
[
3
]
=
{
}
;
int
geoId
=
GetUserGeoID
(
GEOCLASS_NATION
)
;
int
regionCodeLen
=
GetGeoInfoW
(
geoId
GEO_ISO2
regionCodeW
UPRV_LENGTHOF
(
regionCodeW
)
0
)
;
const
char16_t
*
icuTZ16
=
nullptr
;
int32_t
tzListLen
=
0
;
if
(
regionCodeLen
!
=
0
)
{
for
(
int
i
=
0
;
i
<
UPRV_LENGTHOF
(
regionCodeW
)
;
i
+
+
)
{
regionCode
[
i
]
=
static_cast
<
char
>
(
regionCodeW
[
i
]
)
;
}
icuTZ16
=
ures_getStringByKey
(
winTZBundle
.
getAlias
(
)
regionCode
&
tzListLen
&
status
)
;
}
if
(
regionCodeLen
=
=
0
|
|
U_FAILURE
(
status
)
)
{
status
=
U_ZERO_ERROR
;
icuTZ16
=
ures_getStringByKey
(
winTZBundle
.
getAlias
(
)
"
001
"
&
tzListLen
&
status
)
;
}
int32_t
tzLen
=
0
;
if
(
tzListLen
>
0
)
{
while
(
!
(
icuTZ16
[
tzLen
]
=
=
u
'
\
0
'
|
|
icuTZ16
[
tzLen
]
=
=
u
'
'
)
)
{
tzLen
+
+
;
}
}
CharString
icuTZStr
;
return
icuTZStr
.
appendInvariantChars
(
icuTZ16
tzLen
status
)
.
cloneData
(
status
)
;
}
U_NAMESPACE_END
#
endif
