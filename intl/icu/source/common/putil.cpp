#
include
"
uposixdefs
.
h
"
#
include
"
unicode
/
platform
.
h
"
#
if
U_PLATFORM
=
=
U_PF_MINGW
&
&
defined
__STRICT_ANSI__
#
undef
__STRICT_ANSI__
#
endif
#
include
<
time
.
h
>
#
if
!
U_PLATFORM_USES_ONLY_WIN32_API
#
include
<
sys
/
time
.
h
>
#
endif
#
include
"
unicode
/
putil
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
putilimp
.
h
"
#
include
"
uassert
.
h
"
#
include
"
umutex
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
cstring
.
h
"
#
include
"
locmap
.
h
"
#
include
"
ucln_cmn
.
h
"
#
include
"
charstr
.
h
"
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
math
.
h
>
#
include
<
locale
.
h
>
#
include
<
float
.
h
>
#
ifndef
U_COMMON_IMPLEMENTATION
#
error
U_COMMON_IMPLEMENTATION
not
set
-
must
be
set
for
all
ICU
source
files
in
common
/
-
see
https
:
/
/
unicode
-
org
.
github
.
io
/
icu
/
userguide
/
howtouseicu
#
endif
#
if
U_PLATFORM_USES_ONLY_WIN32_API
#
ifndef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
#
endif
#
define
VC_EXTRALEAN
#
define
NOUSER
#
define
NOSERVICE
#
define
NOIME
#
define
NOMCX
#
include
<
windows
.
h
>
#
include
"
unicode
/
uloc
.
h
"
#
include
"
wintz
.
h
"
#
elif
U_PLATFORM
=
=
U_PF_OS400
#
include
<
float
.
h
>
#
include
<
qusec
.
h
>
#
include
<
qusrjobi
.
h
>
#
include
<
qliept
.
h
>
#
include
<
mih
/
testptr
.
h
>
#
elif
U_PLATFORM
=
=
U_PF_OS390
#
include
"
unicode
/
ucnv
.
h
"
#
elif
U_PLATFORM_IS_DARWIN_BASED
|
|
U_PLATFORM_IS_LINUX_BASED
|
|
U_PLATFORM
=
=
U_PF_BSD
|
|
U_PLATFORM
=
=
U_PF_SOLARIS
#
include
<
limits
.
h
>
#
include
<
unistd
.
h
>
#
if
U_PLATFORM
=
=
U_PF_SOLARIS
#
ifndef
_XPG4_2
#
define
_XPG4_2
#
endif
#
elif
U_PLATFORM
=
=
U_PF_ANDROID
#
include
<
sys
/
system_properties
.
h
>
#
include
<
dlfcn
.
h
>
#
endif
#
elif
U_PLATFORM
=
=
U_PF_QNX
#
include
<
sys
/
neutrino
.
h
>
#
endif
#
if
U_HAVE_NL_LANGINFO_CODESET
#
include
<
langinfo
.
h
>
#
endif
#
if
U_PLATFORM_IMPLEMENTS_POSIX
#
if
U_PLATFORM
=
=
U_PF_OS400
#
define
HAVE_DLFCN_H
0
#
define
HAVE_DLOPEN
0
#
else
#
ifndef
HAVE_DLFCN_H
#
define
HAVE_DLFCN_H
1
#
endif
#
ifndef
HAVE_DLOPEN
#
define
HAVE_DLOPEN
1
#
endif
#
endif
#
ifndef
HAVE_GETTIMEOFDAY
#
define
HAVE_GETTIMEOFDAY
1
#
endif
#
else
#
define
HAVE_DLFCN_H
0
#
define
HAVE_DLOPEN
0
#
define
HAVE_GETTIMEOFDAY
0
#
endif
U_NAMESPACE_USE
#
define
DATA_TYPE
"
dat
"
static
const
char
copyright
[
]
=
U_COPYRIGHT_STRING
;
#
define
SIGN
0x80000000U
typedef
union
{
int64_t
i64
;
double
d64
;
}
BitPatternConversion
;
static
const
BitPatternConversion
gNan
=
{
(
int64_t
)
INT64_C
(
0x7FF8000000000000
)
}
;
static
const
BitPatternConversion
gInf
=
{
(
int64_t
)
INT64_C
(
0x7FF0000000000000
)
}
;
#
if
U_PLATFORM_USES_ONLY_WIN32_API
|
|
U_PLATFORM
=
=
U_PF_OS400
#
undef
U_POSIX_LOCALE
#
else
#
define
U_POSIX_LOCALE
1
#
endif
#
if
!
IEEE_754
static
char
*
u_topNBytesOfDouble
(
double
*
d
int
n
)
{
#
if
U_IS_BIG_ENDIAN
return
(
char
*
)
d
;
#
else
return
(
char
*
)
(
d
+
1
)
-
n
;
#
endif
}
static
char
*
u_bottomNBytesOfDouble
(
double
*
d
int
n
)
{
#
if
U_IS_BIG_ENDIAN
return
(
char
*
)
(
d
+
1
)
-
n
;
#
else
return
(
char
*
)
d
;
#
endif
}
#
endif
#
if
IEEE_754
static
UBool
u_signBit
(
double
d
)
{
uint8_t
hiByte
;
#
if
U_IS_BIG_ENDIAN
hiByte
=
*
(
uint8_t
*
)
&
d
;
#
else
hiByte
=
*
(
(
(
uint8_t
*
)
&
d
)
+
sizeof
(
double
)
-
1
)
;
#
endif
return
(
hiByte
&
0x80
)
!
=
0
;
}
#
endif
#
if
defined
(
U_DEBUG_FAKETIME
)
UDate
fakeClock_t0
=
0
;
UDate
fakeClock_dt
=
0
;
UBool
fakeClock_set
=
false
;
static
UDate
getUTCtime_real
(
)
{
struct
timeval
posixTime
;
gettimeofday
(
&
posixTime
nullptr
)
;
return
(
UDate
)
(
(
(
int64_t
)
posixTime
.
tv_sec
*
U_MILLIS_PER_SECOND
)
+
(
posixTime
.
tv_usec
/
1000
)
)
;
}
static
UDate
getUTCtime_fake
(
)
{
static
UMutex
fakeClockMutex
;
umtx_lock
(
&
fakeClockMutex
)
;
if
(
!
fakeClock_set
)
{
UDate
real
=
getUTCtime_real
(
)
;
const
char
*
fake_start
=
getenv
(
"
U_FAKETIME_START
"
)
;
if
(
(
fake_start
!
=
nullptr
)
&
&
(
fake_start
[
0
]
!
=
0
)
)
{
sscanf
(
fake_start
"
%
lf
"
&
fakeClock_t0
)
;
fakeClock_dt
=
fakeClock_t0
-
real
;
fprintf
(
stderr
"
U_DEBUG_FAKETIME
was
set
at
compile
time
so
the
ICU
clock
will
start
at
a
preset
value
\
n
"
"
env
variable
U_FAKETIME_START
=
%
.
0f
(
%
s
)
for
an
offset
of
%
.
0f
ms
from
the
current
time
%
.
0f
\
n
"
fakeClock_t0
fake_start
fakeClock_dt
real
)
;
}
else
{
fakeClock_dt
=
0
;
fprintf
(
stderr
"
U_DEBUG_FAKETIME
was
set
at
compile
time
but
U_FAKETIME_START
was
not
set
.
\
n
"
"
Set
U_FAKETIME_START
to
the
number
of
milliseconds
since
1
/
1
/
1970
to
set
the
ICU
clock
.
\
n
"
)
;
}
fakeClock_set
=
true
;
}
umtx_unlock
(
&
fakeClockMutex
)
;
return
getUTCtime_real
(
)
+
fakeClock_dt
;
}
#
endif
#
if
U_PLATFORM_USES_ONLY_WIN32_API
typedef
union
{
int64_t
int64
;
FILETIME
fileTime
;
}
FileTimeConversion
;
#
define
EPOCH_BIAS
INT64_C
(
116444736000000000
)
#
define
HECTONANOSECOND_PER_MILLISECOND
10000
#
endif
U_CAPI
UDate
U_EXPORT2
uprv_getUTCtime
(
)
{
#
if
defined
(
U_DEBUG_FAKETIME
)
return
getUTCtime_fake
(
)
;
#
else
return
uprv_getRawUTCtime
(
)
;
#
endif
}
U_CAPI
UDate
U_EXPORT2
uprv_getRawUTCtime
(
)
{
#
if
U_PLATFORM_USES_ONLY_WIN32_API
FileTimeConversion
winTime
;
GetSystemTimeAsFileTime
(
&
winTime
.
fileTime
)
;
return
(
UDate
)
(
(
winTime
.
int64
-
EPOCH_BIAS
)
/
HECTONANOSECOND_PER_MILLISECOND
)
;
#
else
#
if
HAVE_GETTIMEOFDAY
struct
timeval
posixTime
;
gettimeofday
(
&
posixTime
nullptr
)
;
return
(
UDate
)
(
(
(
int64_t
)
posixTime
.
tv_sec
*
U_MILLIS_PER_SECOND
)
+
(
posixTime
.
tv_usec
/
1000
)
)
;
#
else
time_t
epochtime
;
time
(
&
epochtime
)
;
return
(
UDate
)
epochtime
*
U_MILLIS_PER_SECOND
;
#
endif
#
endif
}
U_CAPI
UBool
U_EXPORT2
uprv_isNaN
(
double
number
)
{
#
if
IEEE_754
BitPatternConversion
convertedNumber
;
convertedNumber
.
d64
=
number
;
return
(
UBool
)
(
(
convertedNumber
.
i64
&
U_INT64_MAX
)
>
gInf
.
i64
)
;
#
elif
U_PLATFORM
=
=
U_PF_OS390
uint32_t
highBits
=
*
(
uint32_t
*
)
u_topNBytesOfDouble
(
&
number
sizeof
(
uint32_t
)
)
;
uint32_t
lowBits
=
*
(
uint32_t
*
)
u_bottomNBytesOfDouble
(
&
number
sizeof
(
uint32_t
)
)
;
return
(
(
highBits
&
0x7F080000L
)
=
=
0x7F080000L
)
&
&
(
lowBits
=
=
0x00000000L
)
;
#
else
return
number
!
=
number
;
#
endif
}
U_CAPI
UBool
U_EXPORT2
uprv_isInfinite
(
double
number
)
{
#
if
IEEE_754
BitPatternConversion
convertedNumber
;
convertedNumber
.
d64
=
number
;
return
(
UBool
)
(
(
convertedNumber
.
i64
&
U_INT64_MAX
)
=
=
gInf
.
i64
)
;
#
elif
U_PLATFORM
=
=
U_PF_OS390
uint32_t
highBits
=
*
(
uint32_t
*
)
u_topNBytesOfDouble
(
&
number
sizeof
(
uint32_t
)
)
;
uint32_t
lowBits
=
*
(
uint32_t
*
)
u_bottomNBytesOfDouble
(
&
number
sizeof
(
uint32_t
)
)
;
return
(
(
highBits
&
~
SIGN
)
=
=
0x70FF0000L
)
&
&
(
lowBits
=
=
0x00000000L
)
;
#
else
return
number
=
=
(
2
.
0
*
number
)
;
#
endif
}
U_CAPI
UBool
U_EXPORT2
uprv_isPositiveInfinity
(
double
number
)
{
#
if
IEEE_754
|
|
U_PLATFORM
=
=
U_PF_OS390
return
(
UBool
)
(
number
>
0
&
&
uprv_isInfinite
(
number
)
)
;
#
else
return
uprv_isInfinite
(
number
)
;
#
endif
}
U_CAPI
UBool
U_EXPORT2
uprv_isNegativeInfinity
(
double
number
)
{
#
if
IEEE_754
|
|
U_PLATFORM
=
=
U_PF_OS390
return
(
UBool
)
(
number
<
0
&
&
uprv_isInfinite
(
number
)
)
;
#
else
uint32_t
highBits
=
*
(
uint32_t
*
)
u_topNBytesOfDouble
(
&
number
sizeof
(
uint32_t
)
)
;
return
(
(
highBits
&
SIGN
)
&
&
uprv_isInfinite
(
number
)
)
;
#
endif
}
U_CAPI
double
U_EXPORT2
uprv_getNaN
(
)
{
#
if
IEEE_754
|
|
U_PLATFORM
=
=
U_PF_OS390
return
gNan
.
d64
;
#
else
return
0
.
0
;
#
endif
}
U_CAPI
double
U_EXPORT2
uprv_getInfinity
(
)
{
#
if
IEEE_754
|
|
U_PLATFORM
=
=
U_PF_OS390
return
gInf
.
d64
;
#
else
return
0
.
0
;
#
endif
}
U_CAPI
double
U_EXPORT2
uprv_floor
(
double
x
)
{
return
floor
(
x
)
;
}
U_CAPI
double
U_EXPORT2
uprv_ceil
(
double
x
)
{
return
ceil
(
x
)
;
}
U_CAPI
double
U_EXPORT2
uprv_round
(
double
x
)
{
return
uprv_floor
(
x
+
0
.
5
)
;
}
U_CAPI
double
U_EXPORT2
uprv_fabs
(
double
x
)
{
return
fabs
(
x
)
;
}
U_CAPI
double
U_EXPORT2
uprv_modf
(
double
x
double
*
y
)
{
return
modf
(
x
y
)
;
}
U_CAPI
double
U_EXPORT2
uprv_fmod
(
double
x
double
y
)
{
return
fmod
(
x
y
)
;
}
U_CAPI
double
U_EXPORT2
uprv_pow
(
double
x
double
y
)
{
return
pow
(
x
y
)
;
}
U_CAPI
double
U_EXPORT2
uprv_pow10
(
int32_t
x
)
{
return
pow
(
10
.
0
(
double
)
x
)
;
}
U_CAPI
double
U_EXPORT2
uprv_fmax
(
double
x
double
y
)
{
#
if
IEEE_754
if
(
uprv_isNaN
(
x
)
|
|
uprv_isNaN
(
y
)
)
return
uprv_getNaN
(
)
;
if
(
x
=
=
0
.
0
&
&
y
=
=
0
.
0
&
&
u_signBit
(
x
)
)
return
y
;
#
endif
return
(
x
>
y
?
x
:
y
)
;
}
U_CAPI
double
U_EXPORT2
uprv_fmin
(
double
x
double
y
)
{
#
if
IEEE_754
if
(
uprv_isNaN
(
x
)
|
|
uprv_isNaN
(
y
)
)
return
uprv_getNaN
(
)
;
if
(
x
=
=
0
.
0
&
&
y
=
=
0
.
0
&
&
u_signBit
(
y
)
)
return
y
;
#
endif
return
(
x
>
y
?
y
:
x
)
;
}
U_CAPI
UBool
U_EXPORT2
uprv_add32_overflow
(
int32_t
a
int32_t
b
int32_t
*
res
)
{
auto
a64
=
static_cast
<
int64_t
>
(
a
)
;
auto
b64
=
static_cast
<
int64_t
>
(
b
)
;
int64_t
res64
=
a64
+
b64
;
*
res
=
static_cast
<
int32_t
>
(
res64
)
;
return
res64
!
=
*
res
;
}
U_CAPI
UBool
U_EXPORT2
uprv_mul32_overflow
(
int32_t
a
int32_t
b
int32_t
*
res
)
{
auto
a64
=
static_cast
<
int64_t
>
(
a
)
;
auto
b64
=
static_cast
<
int64_t
>
(
b
)
;
int64_t
res64
=
a64
*
b64
;
*
res
=
static_cast
<
int32_t
>
(
res64
)
;
return
res64
!
=
*
res
;
}
U_CAPI
double
U_EXPORT2
uprv_trunc
(
double
d
)
{
#
if
IEEE_754
if
(
uprv_isNaN
(
d
)
)
return
uprv_getNaN
(
)
;
if
(
uprv_isInfinite
(
d
)
)
return
uprv_getInfinity
(
)
;
if
(
u_signBit
(
d
)
)
return
ceil
(
d
)
;
else
return
floor
(
d
)
;
#
else
return
d
>
=
0
?
floor
(
d
)
:
ceil
(
d
)
;
#
endif
}
U_CAPI
double
U_EXPORT2
uprv_maxMantissa
(
)
{
return
pow
(
2
.
0
DBL_MANT_DIG
+
1
.
0
)
-
1
.
0
;
}
U_CAPI
double
U_EXPORT2
uprv_log
(
double
d
)
{
return
log
(
d
)
;
}
U_CAPI
void
*
U_EXPORT2
uprv_maximumPtr
(
void
*
base
)
{
#
if
U_PLATFORM
=
=
U_PF_OS400
if
(
(
base
!
=
nullptr
)
&
&
(
_TESTPTR
(
base
_C_TERASPACE_CHECK
)
)
)
{
return
(
(
void
*
)
(
(
(
char
*
)
base
)
-
(
(
uint32_t
)
(
base
)
)
+
(
(
uint32_t
)
0x7fffefff
)
)
)
;
}
return
(
(
void
*
)
(
(
(
char
*
)
base
)
-
(
(
uint32_t
)
(
base
)
)
+
(
(
uint32_t
)
0xffefff
)
)
)
;
#
else
return
U_MAX_PTR
(
base
)
;
#
endif
}
U_CAPI
void
U_EXPORT2
uprv_tzset
(
)
{
#
if
defined
(
U_TZSET
)
U_TZSET
(
)
;
#
else
#
endif
}
U_CAPI
int32_t
U_EXPORT2
uprv_timezone
(
)
{
#
ifdef
U_TIMEZONE
return
U_TIMEZONE
;
#
else
time_t
t
t1
t2
;
struct
tm
tmrec
;
int32_t
tdiff
=
0
;
time
(
&
t
)
;
uprv_memcpy
(
&
tmrec
localtime
(
&
t
)
sizeof
(
tmrec
)
)
;
#
if
U_PLATFORM
!
=
U_PF_IPHONE
UBool
dst_checked
=
(
tmrec
.
tm_isdst
!
=
0
)
;
#
endif
t1
=
mktime
(
&
tmrec
)
;
uprv_memcpy
(
&
tmrec
gmtime
(
&
t
)
sizeof
(
tmrec
)
)
;
t2
=
mktime
(
&
tmrec
)
;
tdiff
=
t2
-
t1
;
#
if
U_PLATFORM
!
=
U_PF_IPHONE
if
(
dst_checked
)
tdiff
+
=
3600
;
#
endif
return
tdiff
;
#
endif
}
#
if
defined
(
U_TZNAME
)
&
&
(
U_PLATFORM
=
=
U_PF_IRIX
|
|
U_PLATFORM_IS_DARWIN_BASED
)
extern
U_IMPORT
char
*
U_TZNAME
[
]
;
#
endif
#
if
!
UCONFIG_NO_FILE_IO
&
&
(
(
U_PLATFORM_IS_DARWIN_BASED
&
&
(
U_PLATFORM
!
=
U_PF_IPHONE
|
|
defined
(
U_TIMEZONE
)
)
)
|
|
U_PLATFORM_IS_LINUX_BASED
|
|
U_PLATFORM
=
=
U_PF_BSD
|
|
U_PLATFORM
=
=
U_PF_SOLARIS
)
#
define
CHECK_LOCALTIME_LINK
1
#
if
U_PLATFORM_IS_DARWIN_BASED
#
include
<
tzfile
.
h
>
#
define
TZZONEINFO
(
TZDIR
"
/
"
)
#
elif
U_PLATFORM
=
=
U_PF_SOLARIS
#
define
TZDEFAULT
"
/
etc
/
localtime
"
#
define
TZZONEINFO
"
/
usr
/
share
/
lib
/
zoneinfo
/
"
#
define
TZ_ENV_CHECK
"
localtime
"
#
else
#
define
TZDEFAULT
"
/
etc
/
localtime
"
#
define
TZZONEINFO
"
/
usr
/
share
/
zoneinfo
/
"
#
endif
#
define
TZZONEINFOTAIL
"
/
zoneinfo
/
"
#
if
U_HAVE_DIRENT_H
#
define
TZFILE_SKIP
"
posixrules
"
/
*
tz
file
to
skip
when
searching
.
*
/
#
define
TZFILE_SKIP2
"
localtime
"
#
define
SEARCH_TZFILE
#
include
<
dirent
.
h
>
#
endif
static
char
gTimeZoneBuffer
[
PATH_MAX
]
;
static
const
char
*
gTimeZoneBufferPtr
=
nullptr
;
#
endif
#
if
!
U_PLATFORM_USES_ONLY_WIN32_API
#
define
isNonDigit
(
ch
)
(
ch
<
'
0
'
|
|
'
9
'
<
ch
)
#
define
isDigit
(
ch
)
(
'
0
'
<
=
ch
&
&
ch
<
=
'
9
'
)
static
UBool
isValidOlsonID
(
const
char
*
id
)
{
int32_t
idx
=
0
;
int32_t
idxMax
=
0
;
while
(
id
[
idx
]
&
&
isNonDigit
(
id
[
idx
]
)
&
&
id
[
idx
]
!
=
'
'
)
{
idx
+
+
;
}
idxMax
=
idx
+
2
;
while
(
id
[
idx
]
&
&
isDigit
(
id
[
idx
]
)
&
&
idx
<
idxMax
)
{
idx
+
+
;
}
return
(
UBool
)
(
id
[
idx
]
=
=
0
|
|
uprv_strcmp
(
id
"
PST8PDT
"
)
=
=
0
|
|
uprv_strcmp
(
id
"
MST7MDT
"
)
=
=
0
|
|
uprv_strcmp
(
id
"
CST6CDT
"
)
=
=
0
|
|
uprv_strcmp
(
id
"
EST5EDT
"
)
=
=
0
)
;
}
static
void
skipZoneIDPrefix
(
const
char
*
*
id
)
{
if
(
uprv_strncmp
(
*
id
"
posix
/
"
6
)
=
=
0
|
|
uprv_strncmp
(
*
id
"
right
/
"
6
)
=
=
0
)
{
*
id
+
=
6
;
}
}
#
endif
#
if
defined
(
U_TZNAME
)
&
&
!
U_PLATFORM_USES_ONLY_WIN32_API
#
define
CONVERT_HOURS_TO_SECONDS
(
offset
)
(
int32_t
)
(
offset
*
3600
)
typedef
struct
OffsetZoneMapping
{
int32_t
offsetSeconds
;
int32_t
daylightType
;
const
char
*
stdID
;
const
char
*
dstID
;
const
char
*
olsonID
;
}
OffsetZoneMapping
;
enum
{
U_DAYLIGHT_NONE
=
0
U_DAYLIGHT_JUNE
=
1
U_DAYLIGHT_DECEMBER
=
2
}
;
static
const
struct
OffsetZoneMapping
OFFSET_ZONE_MAPPINGS
[
]
=
{
{
-
45900
2
"
CHAST
"
"
CHADT
"
"
Pacific
/
Chatham
"
}
{
-
43200
1
"
PETT
"
"
PETST
"
"
Asia
/
Kamchatka
"
}
{
-
43200
2
"
NZST
"
"
NZDT
"
"
Pacific
/
Auckland
"
}
{
-
43200
1
"
ANAT
"
"
ANAST
"
"
Asia
/
Anadyr
"
}
{
-
39600
1
"
MAGT
"
"
MAGST
"
"
Asia
/
Magadan
"
}
{
-
37800
2
"
LHST
"
"
LHST
"
"
Australia
/
Lord_Howe
"
}
{
-
36000
2
"
EST
"
"
EST
"
"
Australia
/
Sydney
"
}
{
-
36000
1
"
SAKT
"
"
SAKST
"
"
Asia
/
Sakhalin
"
}
{
-
36000
1
"
VLAT
"
"
VLAST
"
"
Asia
/
Vladivostok
"
}
{
-
34200
2
"
CST
"
"
CST
"
"
Australia
/
South
"
}
{
-
32400
1
"
YAKT
"
"
YAKST
"
"
Asia
/
Yakutsk
"
}
{
-
32400
1
"
CHOT
"
"
CHOST
"
"
Asia
/
Choibalsan
"
}
{
-
31500
2
"
CWST
"
"
CWST
"
"
Australia
/
Eucla
"
}
{
-
28800
1
"
IRKT
"
"
IRKST
"
"
Asia
/
Irkutsk
"
}
{
-
28800
1
"
ULAT
"
"
ULAST
"
"
Asia
/
Ulaanbaatar
"
}
{
-
28800
2
"
WST
"
"
WST
"
"
Australia
/
West
"
}
{
-
25200
1
"
HOVT
"
"
HOVST
"
"
Asia
/
Hovd
"
}
{
-
25200
1
"
KRAT
"
"
KRAST
"
"
Asia
/
Krasnoyarsk
"
}
{
-
21600
1
"
NOVT
"
"
NOVST
"
"
Asia
/
Novosibirsk
"
}
{
-
21600
1
"
OMST
"
"
OMSST
"
"
Asia
/
Omsk
"
}
{
-
18000
1
"
YEKT
"
"
YEKST
"
"
Asia
/
Yekaterinburg
"
}
{
-
14400
1
"
SAMT
"
"
SAMST
"
"
Europe
/
Samara
"
}
{
-
14400
1
"
AMT
"
"
AMST
"
"
Asia
/
Yerevan
"
}
{
-
14400
1
"
AZT
"
"
AZST
"
"
Asia
/
Baku
"
}
{
-
10800
1
"
AST
"
"
ADT
"
"
Asia
/
Baghdad
"
}
{
-
10800
1
"
MSK
"
"
MSD
"
"
Europe
/
Moscow
"
}
{
-
10800
1
"
VOLT
"
"
VOLST
"
"
Europe
/
Volgograd
"
}
{
-
7200
0
"
EET
"
"
CEST
"
"
Africa
/
Tripoli
"
}
{
-
7200
1
"
EET
"
"
EEST
"
"
Europe
/
Athens
"
}
{
-
7200
1
"
IST
"
"
IDT
"
"
Asia
/
Jerusalem
"
}
{
-
3600
0
"
CET
"
"
WEST
"
"
Africa
/
Algiers
"
}
{
-
3600
2
"
WAT
"
"
WAST
"
"
Africa
/
Windhoek
"
}
{
0
1
"
GMT
"
"
IST
"
"
Europe
/
Dublin
"
}
{
0
1
"
GMT
"
"
BST
"
"
Europe
/
London
"
}
{
0
0
"
WET
"
"
WEST
"
"
Africa
/
Casablanca
"
}
{
0
0
"
WET
"
"
WET
"
"
Africa
/
El_Aaiun
"
}
{
3600
1
"
AZOT
"
"
AZOST
"
"
Atlantic
/
Azores
"
}
{
3600
1
"
EGT
"
"
EGST
"
"
America
/
Scoresbysund
"
}
{
10800
1
"
PMST
"
"
PMDT
"
"
America
/
Miquelon
"
}
{
10800
2
"
UYT
"
"
UYST
"
"
America
/
Montevideo
"
}
{
10800
1
"
WGT
"
"
WGST
"
"
America
/
Godthab
"
}
{
10800
2
"
BRT
"
"
BRST
"
"
Brazil
/
East
"
}
{
12600
1
"
NST
"
"
NDT
"
"
America
/
St_Johns
"
}
{
14400
1
"
AST
"
"
ADT
"
"
Canada
/
Atlantic
"
}
{
14400
2
"
AMT
"
"
AMST
"
"
America
/
Cuiaba
"
}
{
14400
2
"
CLT
"
"
CLST
"
"
Chile
/
Continental
"
}
{
14400
2
"
FKT
"
"
FKST
"
"
Atlantic
/
Stanley
"
}
{
14400
2
"
PYT
"
"
PYST
"
"
America
/
Asuncion
"
}
{
18000
1
"
CST
"
"
CDT
"
"
America
/
Havana
"
}
{
18000
1
"
EST
"
"
EDT
"
"
US
/
Eastern
"
}
{
21600
2
"
EAST
"
"
EASST
"
"
Chile
/
EasterIsland
"
}
{
21600
0
"
CST
"
"
MDT
"
"
Canada
/
Saskatchewan
"
}
{
21600
0
"
CST
"
"
CDT
"
"
America
/
Guatemala
"
}
{
21600
1
"
CST
"
"
CDT
"
"
US
/
Central
"
}
{
25200
1
"
MST
"
"
MDT
"
"
US
/
Mountain
"
}
{
28800
0
"
PST
"
"
PST
"
"
Pacific
/
Pitcairn
"
}
{
28800
1
"
PST
"
"
PDT
"
"
US
/
Pacific
"
}
{
32400
1
"
AKST
"
"
AKDT
"
"
US
/
Alaska
"
}
{
36000
1
"
HAST
"
"
HADT
"
"
US
/
Aleutian
"
}
}
;
static
const
char
*
remapShortTimeZone
(
const
char
*
stdID
const
char
*
dstID
int32_t
daylightType
int32_t
offset
)
{
int32_t
idx
;
#
ifdef
DEBUG_TZNAME
fprintf
(
stderr
"
TZ
=
%
s
std
=
%
s
dst
=
%
s
daylight
=
%
d
offset
=
%
d
\
n
"
getenv
(
"
TZ
"
)
stdID
dstID
daylightType
offset
)
;
#
endif
for
(
idx
=
0
;
idx
<
UPRV_LENGTHOF
(
OFFSET_ZONE_MAPPINGS
)
;
idx
+
+
)
{
if
(
offset
=
=
OFFSET_ZONE_MAPPINGS
[
idx
]
.
offsetSeconds
&
&
daylightType
=
=
OFFSET_ZONE_MAPPINGS
[
idx
]
.
daylightType
&
&
strcmp
(
OFFSET_ZONE_MAPPINGS
[
idx
]
.
stdID
stdID
)
=
=
0
&
&
strcmp
(
OFFSET_ZONE_MAPPINGS
[
idx
]
.
dstID
dstID
)
=
=
0
)
{
return
OFFSET_ZONE_MAPPINGS
[
idx
]
.
olsonID
;
}
}
return
nullptr
;
}
#
endif
#
ifdef
SEARCH_TZFILE
#
define
MAX_READ_SIZE
512
typedef
struct
DefaultTZInfo
{
char
*
defaultTZBuffer
;
int64_t
defaultTZFileSize
;
FILE
*
defaultTZFilePtr
;
UBool
defaultTZstatus
;
int32_t
defaultTZPosition
;
}
DefaultTZInfo
;
static
UBool
compareBinaryFiles
(
const
char
*
defaultTZFileName
const
char
*
TZFileName
DefaultTZInfo
*
tzInfo
)
{
FILE
*
file
;
int64_t
sizeFile
;
int64_t
sizeFileLeft
;
int32_t
sizeFileRead
;
int32_t
sizeFileToRead
;
char
bufferFile
[
MAX_READ_SIZE
]
;
UBool
result
=
true
;
if
(
tzInfo
-
>
defaultTZFilePtr
=
=
nullptr
)
{
tzInfo
-
>
defaultTZFilePtr
=
fopen
(
defaultTZFileName
"
r
"
)
;
}
file
=
fopen
(
TZFileName
"
r
"
)
;
tzInfo
-
>
defaultTZPosition
=
0
;
if
(
file
!
=
nullptr
&
&
tzInfo
-
>
defaultTZFilePtr
!
=
nullptr
)
{
if
(
tzInfo
-
>
defaultTZFileSize
=
=
0
)
{
fseek
(
tzInfo
-
>
defaultTZFilePtr
0
SEEK_END
)
;
tzInfo
-
>
defaultTZFileSize
=
ftell
(
tzInfo
-
>
defaultTZFilePtr
)
;
}
fseek
(
file
0
SEEK_END
)
;
sizeFile
=
ftell
(
file
)
;
sizeFileLeft
=
sizeFile
;
if
(
sizeFile
!
=
tzInfo
-
>
defaultTZFileSize
)
{
result
=
false
;
}
else
{
if
(
tzInfo
-
>
defaultTZBuffer
=
=
nullptr
)
{
rewind
(
tzInfo
-
>
defaultTZFilePtr
)
;
tzInfo
-
>
defaultTZBuffer
=
(
char
*
)
uprv_malloc
(
sizeof
(
char
)
*
tzInfo
-
>
defaultTZFileSize
)
;
sizeFileRead
=
fread
(
tzInfo
-
>
defaultTZBuffer
1
tzInfo
-
>
defaultTZFileSize
tzInfo
-
>
defaultTZFilePtr
)
;
}
rewind
(
file
)
;
while
(
sizeFileLeft
>
0
)
{
uprv_memset
(
bufferFile
0
MAX_READ_SIZE
)
;
sizeFileToRead
=
sizeFileLeft
<
MAX_READ_SIZE
?
sizeFileLeft
:
MAX_READ_SIZE
;
sizeFileRead
=
fread
(
bufferFile
1
sizeFileToRead
file
)
;
if
(
memcmp
(
tzInfo
-
>
defaultTZBuffer
+
tzInfo
-
>
defaultTZPosition
bufferFile
sizeFileRead
)
!
=
0
)
{
result
=
false
;
break
;
}
sizeFileLeft
-
=
sizeFileRead
;
tzInfo
-
>
defaultTZPosition
+
=
sizeFileRead
;
}
}
}
else
{
result
=
false
;
}
if
(
file
!
=
nullptr
)
{
fclose
(
file
)
;
}
return
result
;
}
#
define
SKIP1
"
.
"
#
define
SKIP2
"
.
.
"
static
UBool
U_CALLCONV
putil_cleanup
(
)
;
static
CharString
*
gSearchTZFileResult
=
nullptr
;
static
char
*
searchForTZFile
(
const
char
*
path
DefaultTZInfo
*
tzInfo
)
{
DIR
*
dirp
=
nullptr
;
struct
dirent
*
dirEntry
=
nullptr
;
char
*
result
=
nullptr
;
UErrorCode
status
=
U_ZERO_ERROR
;
CharString
curpath
(
path
-
1
status
)
;
if
(
U_FAILURE
(
status
)
)
{
goto
cleanupAndReturn
;
}
dirp
=
opendir
(
path
)
;
if
(
dirp
=
=
nullptr
)
{
goto
cleanupAndReturn
;
}
if
(
gSearchTZFileResult
=
=
nullptr
)
{
gSearchTZFileResult
=
new
CharString
;
if
(
gSearchTZFileResult
=
=
nullptr
)
{
goto
cleanupAndReturn
;
}
ucln_common_registerCleanup
(
UCLN_COMMON_PUTIL
putil_cleanup
)
;
}
while
(
(
dirEntry
=
readdir
(
dirp
)
)
!
=
nullptr
)
{
const
char
*
dirName
=
dirEntry
-
>
d_name
;
if
(
uprv_strcmp
(
dirName
SKIP1
)
!
=
0
&
&
uprv_strcmp
(
dirName
SKIP2
)
!
=
0
&
&
uprv_strcmp
(
TZFILE_SKIP
dirName
)
!
=
0
&
&
uprv_strcmp
(
TZFILE_SKIP2
dirName
)
!
=
0
)
{
CharString
newpath
(
curpath
status
)
;
newpath
.
append
(
dirName
-
1
status
)
;
if
(
U_FAILURE
(
status
)
)
{
break
;
}
DIR
*
subDirp
=
nullptr
;
if
(
(
subDirp
=
opendir
(
newpath
.
data
(
)
)
)
!
=
nullptr
)
{
closedir
(
subDirp
)
;
newpath
.
append
(
'
/
'
status
)
;
if
(
U_FAILURE
(
status
)
)
{
break
;
}
result
=
searchForTZFile
(
newpath
.
data
(
)
tzInfo
)
;
if
(
result
!
=
nullptr
)
break
;
}
else
{
if
(
compareBinaryFiles
(
TZDEFAULT
newpath
.
data
(
)
tzInfo
)
)
{
int32_t
amountToSkip
=
sizeof
(
TZZONEINFO
)
-
1
;
if
(
amountToSkip
>
newpath
.
length
(
)
)
{
amountToSkip
=
newpath
.
length
(
)
;
}
const
char
*
zoneid
=
newpath
.
data
(
)
+
amountToSkip
;
skipZoneIDPrefix
(
&
zoneid
)
;
gSearchTZFileResult
-
>
clear
(
)
;
gSearchTZFileResult
-
>
append
(
zoneid
-
1
status
)
;
if
(
U_FAILURE
(
status
)
)
{
break
;
}
result
=
gSearchTZFileResult
-
>
data
(
)
;
break
;
}
}
}
}
cleanupAndReturn
:
if
(
dirp
)
{
closedir
(
dirp
)
;
}
return
result
;
}
#
endif
#
if
U_PLATFORM
=
=
U_PF_ANDROID
typedef
int
(
system_property_read_callback
)
(
const
prop_info
*
info
void
(
*
callback
)
(
void
*
cookie
const
char
*
name
const
char
*
value
uint32_t
serial
)
void
*
cookie
)
;
typedef
int
(
system_property_get
)
(
const
char
*
char
*
)
;
static
char
gAndroidTimeZone
[
PROP_VALUE_MAX
]
=
{
'
\
0
'
}
;
static
void
u_property_read
(
void
*
cookie
const
char
*
name
const
char
*
value
uint32_t
serial
)
{
uprv_strcpy
(
(
char
*
)
cookie
value
)
;
}
#
endif
U_CAPI
void
U_EXPORT2
uprv_tzname_clear_cache
(
)
{
#
if
U_PLATFORM
=
=
U_PF_ANDROID
gAndroidTimeZone
[
0
]
=
'
\
0
'
;
void
*
libc
=
dlopen
(
"
libc
.
so
"
RTLD_NOLOAD
)
;
if
(
libc
)
{
system_property_read_callback
*
property_read_callback
=
(
system_property_read_callback
*
)
dlsym
(
libc
"
__system_property_read_callback
"
)
;
if
(
property_read_callback
)
{
const
prop_info
*
info
=
__system_property_find
(
"
persist
.
sys
.
timezone
"
)
;
if
(
info
)
{
property_read_callback
(
info
&
u_property_read
gAndroidTimeZone
)
;
}
}
else
{
system_property_get
*
property_get
=
(
system_property_get
*
)
dlsym
(
libc
"
__system_property_get
"
)
;
if
(
property_get
)
{
property_get
(
"
persist
.
sys
.
timezone
"
gAndroidTimeZone
)
;
}
}
dlclose
(
libc
)
;
}
#
endif
#
if
defined
(
CHECK_LOCALTIME_LINK
)
&
&
!
defined
(
DEBUG_SKIP_LOCALTIME_LINK
)
gTimeZoneBufferPtr
=
nullptr
;
#
endif
}
U_CAPI
const
char
*
U_EXPORT2
uprv_tzname
(
int
n
)
{
(
void
)
n
;
const
char
*
tzid
=
nullptr
;
#
if
U_PLATFORM_USES_ONLY_WIN32_API
tzid
=
uprv_detectWindowsTimeZone
(
)
;
if
(
tzid
!
=
nullptr
)
{
return
tzid
;
}
#
ifndef
U_TZNAME
return
uprv_strdup
(
"
"
)
;
#
endif
#
else
#
ifndef
DEBUG_TZNAME
#
if
U_PLATFORM
=
=
U_PF_ANDROID
tzid
=
gAndroidTimeZone
;
#
else
tzid
=
getenv
(
"
TZ
"
)
;
#
endif
if
(
tzid
!
=
nullptr
&
&
isValidOlsonID
(
tzid
)
#
if
U_PLATFORM
=
=
U_PF_SOLARIS
&
&
uprv_strcmp
(
tzid
TZ_ENV_CHECK
)
!
=
0
#
endif
)
{
if
(
tzid
[
0
]
=
=
'
:
'
)
{
tzid
+
+
;
}
skipZoneIDPrefix
(
&
tzid
)
;
return
tzid
;
}
#
endif
#
if
defined
(
CHECK_LOCALTIME_LINK
)
&
&
!
defined
(
DEBUG_SKIP_LOCALTIME_LINK
)
if
(
gTimeZoneBufferPtr
=
=
nullptr
)
{
char
*
ret
=
realpath
(
TZDEFAULT
gTimeZoneBuffer
)
;
if
(
ret
!
=
nullptr
&
&
uprv_strcmp
(
TZDEFAULT
gTimeZoneBuffer
)
!
=
0
)
{
int32_t
tzZoneInfoTailLen
=
uprv_strlen
(
TZZONEINFOTAIL
)
;
const
char
*
tzZoneInfoTailPtr
=
uprv_strstr
(
gTimeZoneBuffer
TZZONEINFOTAIL
)
;
if
(
tzZoneInfoTailPtr
!
=
nullptr
)
{
tzZoneInfoTailPtr
+
=
tzZoneInfoTailLen
;
skipZoneIDPrefix
(
&
tzZoneInfoTailPtr
)
;
if
(
isValidOlsonID
(
tzZoneInfoTailPtr
)
)
{
return
(
gTimeZoneBufferPtr
=
tzZoneInfoTailPtr
)
;
}
}
}
else
{
#
if
defined
(
SEARCH_TZFILE
)
DefaultTZInfo
*
tzInfo
=
(
DefaultTZInfo
*
)
uprv_malloc
(
sizeof
(
DefaultTZInfo
)
)
;
if
(
tzInfo
!
=
nullptr
)
{
tzInfo
-
>
defaultTZBuffer
=
nullptr
;
tzInfo
-
>
defaultTZFileSize
=
0
;
tzInfo
-
>
defaultTZFilePtr
=
nullptr
;
tzInfo
-
>
defaultTZstatus
=
false
;
tzInfo
-
>
defaultTZPosition
=
0
;
gTimeZoneBufferPtr
=
searchForTZFile
(
TZZONEINFO
tzInfo
)
;
if
(
tzInfo
-
>
defaultTZBuffer
!
=
nullptr
)
{
uprv_free
(
tzInfo
-
>
defaultTZBuffer
)
;
}
if
(
tzInfo
-
>
defaultTZFilePtr
!
=
nullptr
)
{
fclose
(
tzInfo
-
>
defaultTZFilePtr
)
;
}
uprv_free
(
tzInfo
)
;
}
if
(
gTimeZoneBufferPtr
!
=
nullptr
&
&
isValidOlsonID
(
gTimeZoneBufferPtr
)
)
{
return
gTimeZoneBufferPtr
;
}
#
endif
}
}
else
{
return
gTimeZoneBufferPtr
;
}
#
endif
#
endif
#
ifdef
U_TZNAME
#
if
U_PLATFORM_USES_ONLY_WIN32_API
return
uprv_strdup
(
U_TZNAME
[
n
]
)
;
#
else
{
struct
tm
juneSol
decemberSol
;
int
daylightType
;
static
const
time_t
juneSolstice
=
1182478260
;
static
const
time_t
decemberSolstice
=
1198332540
;
localtime_r
(
&
juneSolstice
&
juneSol
)
;
localtime_r
(
&
decemberSolstice
&
decemberSol
)
;
if
(
decemberSol
.
tm_isdst
>
0
)
{
daylightType
=
U_DAYLIGHT_DECEMBER
;
}
else
if
(
juneSol
.
tm_isdst
>
0
)
{
daylightType
=
U_DAYLIGHT_JUNE
;
}
else
{
daylightType
=
U_DAYLIGHT_NONE
;
}
tzid
=
remapShortTimeZone
(
U_TZNAME
[
0
]
U_TZNAME
[
1
]
daylightType
uprv_timezone
(
)
)
;
if
(
tzid
!
=
nullptr
)
{
return
tzid
;
}
}
return
U_TZNAME
[
n
]
;
#
endif
#
else
return
"
"
;
#
endif
}
static
icu
:
:
UInitOnce
gDataDirInitOnce
{
}
;
static
char
*
gDataDirectory
=
nullptr
;
UInitOnce
gTimeZoneFilesInitOnce
{
}
;
static
CharString
*
gTimeZoneFilesDirectory
=
nullptr
;
#
if
U_POSIX_LOCALE
|
|
U_PLATFORM_USES_ONLY_WIN32_API
static
const
char
*
gCorrectedPOSIXLocale
=
nullptr
;
static
bool
gCorrectedPOSIXLocaleHeapAllocated
=
false
;
#
endif
static
UBool
U_CALLCONV
putil_cleanup
(
)
{
if
(
gDataDirectory
&
&
*
gDataDirectory
)
{
uprv_free
(
gDataDirectory
)
;
}
gDataDirectory
=
nullptr
;
gDataDirInitOnce
.
reset
(
)
;
delete
gTimeZoneFilesDirectory
;
gTimeZoneFilesDirectory
=
nullptr
;
gTimeZoneFilesInitOnce
.
reset
(
)
;
#
ifdef
SEARCH_TZFILE
delete
gSearchTZFileResult
;
gSearchTZFileResult
=
nullptr
;
#
endif
#
if
U_POSIX_LOCALE
|
|
U_PLATFORM_USES_ONLY_WIN32_API
if
(
gCorrectedPOSIXLocale
&
&
gCorrectedPOSIXLocaleHeapAllocated
)
{
uprv_free
(
const_cast
<
char
*
>
(
gCorrectedPOSIXLocale
)
)
;
gCorrectedPOSIXLocale
=
nullptr
;
gCorrectedPOSIXLocaleHeapAllocated
=
false
;
}
#
endif
return
true
;
}
U_CAPI
void
U_EXPORT2
u_setDataDirectory
(
const
char
*
directory
)
{
char
*
newDataDir
;
int32_t
length
;
if
(
directory
=
=
nullptr
|
|
*
directory
=
=
0
)
{
newDataDir
=
(
char
*
)
"
"
;
}
else
{
length
=
(
int32_t
)
uprv_strlen
(
directory
)
;
newDataDir
=
(
char
*
)
uprv_malloc
(
length
+
2
)
;
if
(
newDataDir
=
=
nullptr
)
{
return
;
}
uprv_strcpy
(
newDataDir
directory
)
;
#
if
(
U_FILE_SEP_CHAR
!
=
U_FILE_ALT_SEP_CHAR
)
{
char
*
p
;
while
(
(
p
=
uprv_strchr
(
newDataDir
U_FILE_ALT_SEP_CHAR
)
)
!
=
nullptr
)
{
*
p
=
U_FILE_SEP_CHAR
;
}
}
#
endif
}
if
(
gDataDirectory
&
&
*
gDataDirectory
)
{
uprv_free
(
gDataDirectory
)
;
}
gDataDirectory
=
newDataDir
;
ucln_common_registerCleanup
(
UCLN_COMMON_PUTIL
putil_cleanup
)
;
}
U_CAPI
UBool
U_EXPORT2
uprv_pathIsAbsolute
(
const
char
*
path
)
{
if
(
!
path
|
|
!
*
path
)
{
return
false
;
}
if
(
*
path
=
=
U_FILE_SEP_CHAR
)
{
return
true
;
}
#
if
(
U_FILE_SEP_CHAR
!
=
U_FILE_ALT_SEP_CHAR
)
if
(
*
path
=
=
U_FILE_ALT_SEP_CHAR
)
{
return
true
;
}
#
endif
#
if
U_PLATFORM_USES_ONLY_WIN32_API
if
(
(
(
(
path
[
0
]
>
=
'
A
'
)
&
&
(
path
[
0
]
<
=
'
Z
'
)
)
|
|
(
(
path
[
0
]
>
=
'
a
'
)
&
&
(
path
[
0
]
<
=
'
z
'
)
)
)
&
&
path
[
1
]
=
=
'
:
'
)
{
return
true
;
}
#
endif
return
false
;
}
#
if
U_PLATFORM_IS_DARWIN_BASED
&
&
defined
(
TARGET_OS_SIMULATOR
)
&
&
TARGET_OS_SIMULATOR
#
if
!
defined
(
ICU_DATA_DIR_PREFIX_ENV_VAR
)
#
define
ICU_DATA_DIR_PREFIX_ENV_VAR
"
IPHONE_SIMULATOR_ROOT
"
#
endif
#
endif
#
if
defined
(
ICU_DATA_DIR_WINDOWS
)
static
BOOL
U_CALLCONV
getIcuDataDirectoryUnderWindowsDirectory
(
char
*
directoryBuffer
UINT
bufferLength
)
{
wchar_t
windowsPath
[
MAX_PATH
]
;
char
windowsPathUtf8
[
MAX_PATH
]
;
UINT
length
=
GetSystemWindowsDirectoryW
(
windowsPath
UPRV_LENGTHOF
(
windowsPath
)
)
;
if
(
(
length
>
0
)
&
&
(
length
<
(
UPRV_LENGTHOF
(
windowsPath
)
-
1
)
)
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
windowsPathUtf8Len
=
0
;
u_strToUTF8
(
windowsPathUtf8
static_cast
<
int32_t
>
(
UPRV_LENGTHOF
(
windowsPathUtf8
)
)
&
windowsPathUtf8Len
reinterpret_cast
<
const
char16_t
*
>
(
windowsPath
)
-
1
&
status
)
;
if
(
U_SUCCESS
(
status
)
&
&
(
status
!
=
U_STRING_NOT_TERMINATED_WARNING
)
&
&
(
windowsPathUtf8Len
<
(
UPRV_LENGTHOF
(
windowsPathUtf8
)
-
1
)
)
)
{
if
(
windowsPathUtf8
[
windowsPathUtf8Len
-
1
]
!
=
U_FILE_SEP_CHAR
)
{
windowsPathUtf8
[
windowsPathUtf8Len
+
+
]
=
U_FILE_SEP_CHAR
;
windowsPathUtf8
[
windowsPathUtf8Len
]
=
'
\
0
'
;
}
if
(
(
windowsPathUtf8Len
+
UPRV_LENGTHOF
(
ICU_DATA_DIR_WINDOWS
)
)
<
bufferLength
)
{
uprv_strcpy
(
directoryBuffer
windowsPathUtf8
)
;
uprv_strcat
(
directoryBuffer
ICU_DATA_DIR_WINDOWS
)
;
return
true
;
}
}
}
return
false
;
}
#
endif
static
void
U_CALLCONV
dataDirectoryInitFn
(
)
{
if
(
gDataDirectory
)
{
return
;
}
const
char
*
path
=
nullptr
;
#
if
defined
(
ICU_DATA_DIR_PREFIX_ENV_VAR
)
char
datadir_path_buffer
[
PATH_MAX
]
;
#
endif
#
if
!
defined
(
ICU_NO_USER_DATA_OVERRIDE
)
&
&
!
UCONFIG_NO_FILE_IO
#
if
U_PLATFORM_HAS_WINUWP_API
=
=
0
path
=
getenv
(
"
ICU_DATA
"
)
;
#
endif
#
endif
#
if
defined
(
ICU_DATA_DIR
)
|
|
defined
(
U_ICU_DATA_DEFAULT_DIR
)
if
(
path
=
=
nullptr
|
|
*
path
=
=
0
)
{
#
if
defined
(
ICU_DATA_DIR_PREFIX_ENV_VAR
)
const
char
*
prefix
=
getenv
(
ICU_DATA_DIR_PREFIX_ENV_VAR
)
;
#
endif
#
ifdef
ICU_DATA_DIR
path
=
ICU_DATA_DIR
;
#
else
path
=
U_ICU_DATA_DEFAULT_DIR
;
#
endif
#
if
defined
(
ICU_DATA_DIR_PREFIX_ENV_VAR
)
if
(
prefix
!
=
nullptr
)
{
snprintf
(
datadir_path_buffer
sizeof
(
datadir_path_buffer
)
"
%
s
%
s
"
prefix
path
)
;
path
=
datadir_path_buffer
;
}
#
endif
}
#
endif
#
if
defined
(
ICU_DATA_DIR_WINDOWS
)
char
datadir_path_buffer
[
MAX_PATH
]
;
if
(
getIcuDataDirectoryUnderWindowsDirectory
(
datadir_path_buffer
UPRV_LENGTHOF
(
datadir_path_buffer
)
)
)
{
path
=
datadir_path_buffer
;
}
#
endif
if
(
path
=
=
nullptr
)
{
path
=
"
"
;
}
u_setDataDirectory
(
path
)
;
return
;
}
U_CAPI
const
char
*
U_EXPORT2
u_getDataDirectory
(
)
{
umtx_initOnce
(
gDataDirInitOnce
&
dataDirectoryInitFn
)
;
return
gDataDirectory
;
}
static
void
setTimeZoneFilesDir
(
const
char
*
path
UErrorCode
&
status
)
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
gTimeZoneFilesDirectory
-
>
clear
(
)
;
gTimeZoneFilesDirectory
-
>
append
(
path
status
)
;
#
if
(
U_FILE_SEP_CHAR
!
=
U_FILE_ALT_SEP_CHAR
)
char
*
p
=
gTimeZoneFilesDirectory
-
>
data
(
)
;
while
(
(
p
=
uprv_strchr
(
p
U_FILE_ALT_SEP_CHAR
)
)
!
=
nullptr
)
{
*
p
=
U_FILE_SEP_CHAR
;
}
#
endif
}
#
define
TO_STRING
(
x
)
TO_STRING_2
(
x
)
#
define
TO_STRING_2
(
x
)
#
x
static
void
U_CALLCONV
TimeZoneDataDirInitFn
(
UErrorCode
&
status
)
{
U_ASSERT
(
gTimeZoneFilesDirectory
=
=
nullptr
)
;
ucln_common_registerCleanup
(
UCLN_COMMON_PUTIL
putil_cleanup
)
;
gTimeZoneFilesDirectory
=
new
CharString
(
)
;
if
(
gTimeZoneFilesDirectory
=
=
nullptr
)
{
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
const
char
*
dir
=
"
"
;
#
if
defined
(
ICU_TIMEZONE_FILES_DIR_PREFIX_ENV_VAR
)
char
timezonefilesdir_path_buffer
[
PATH_MAX
]
;
const
char
*
prefix
=
getenv
(
ICU_TIMEZONE_FILES_DIR_PREFIX_ENV_VAR
)
;
#
endif
#
if
U_PLATFORM_HAS_WINUWP_API
=
=
1
#
if
defined
(
ICU_DATA_DIR_WINDOWS
)
char
datadir_path_buffer
[
MAX_PATH
]
;
if
(
getIcuDataDirectoryUnderWindowsDirectory
(
datadir_path_buffer
UPRV_LENGTHOF
(
datadir_path_buffer
)
)
)
{
dir
=
datadir_path_buffer
;
}
#
endif
#
else
dir
=
getenv
(
"
ICU_TIMEZONE_FILES_DIR
"
)
;
#
endif
#
if
defined
(
U_TIMEZONE_FILES_DIR
)
if
(
dir
=
=
nullptr
)
{
dir
=
TO_STRING
(
U_TIMEZONE_FILES_DIR
)
;
}
#
endif
if
(
dir
=
=
nullptr
)
{
dir
=
"
"
;
}
#
if
defined
(
ICU_TIMEZONE_FILES_DIR_PREFIX_ENV_VAR
)
if
(
prefix
!
=
nullptr
)
{
snprintf
(
timezonefilesdir_path_buffer
sizeof
(
timezonefilesdir_path_buffer
)
"
%
s
%
s
"
prefix
dir
)
;
dir
=
timezonefilesdir_path_buffer
;
}
#
endif
setTimeZoneFilesDir
(
dir
status
)
;
}
U_CAPI
const
char
*
U_EXPORT2
u_getTimeZoneFilesDirectory
(
UErrorCode
*
status
)
{
umtx_initOnce
(
gTimeZoneFilesInitOnce
&
TimeZoneDataDirInitFn
*
status
)
;
return
U_SUCCESS
(
*
status
)
?
gTimeZoneFilesDirectory
-
>
data
(
)
:
"
"
;
}
U_CAPI
void
U_EXPORT2
u_setTimeZoneFilesDirectory
(
const
char
*
path
UErrorCode
*
status
)
{
umtx_initOnce
(
gTimeZoneFilesInitOnce
&
TimeZoneDataDirInitFn
*
status
)
;
setTimeZoneFilesDir
(
path
*
status
)
;
}
#
if
U_POSIX_LOCALE
static
const
char
*
uprv_getPOSIXIDForCategory
(
int
category
)
{
const
char
*
posixID
=
nullptr
;
if
(
category
=
=
LC_MESSAGES
|
|
category
=
=
LC_CTYPE
)
{
posixID
=
setlocale
(
category
nullptr
)
;
if
(
(
posixID
=
=
0
)
|
|
(
uprv_strcmp
(
"
C
"
posixID
)
=
=
0
)
|
|
(
uprv_strcmp
(
"
POSIX
"
posixID
)
=
=
0
)
)
{
posixID
=
getenv
(
"
LC_ALL
"
)
;
#
if
U_PLATFORM
=
=
U_PF_SOLARIS
if
(
(
posixID
=
=
0
)
|
|
(
posixID
[
0
]
=
=
'
\
0
'
)
)
{
posixID
=
getenv
(
category
=
=
LC_MESSAGES
?
"
LC_MESSAGES
"
:
"
LC_CTYPE
"
)
;
if
(
(
posixID
=
=
0
)
|
|
(
posixID
[
0
]
=
=
'
\
0
'
)
)
{
#
else
if
(
posixID
=
=
0
)
{
posixID
=
getenv
(
category
=
=
LC_MESSAGES
?
"
LC_MESSAGES
"
:
"
LC_CTYPE
"
)
;
if
(
posixID
=
=
0
)
{
#
endif
posixID
=
getenv
(
"
LANG
"
)
;
}
}
}
}
if
(
(
posixID
=
=
0
)
|
|
(
uprv_strcmp
(
"
C
"
posixID
)
=
=
0
)
|
|
(
uprv_strcmp
(
"
POSIX
"
posixID
)
=
=
0
)
)
{
posixID
=
"
en_US_POSIX
"
;
}
return
posixID
;
}
static
const
char
*
uprv_getPOSIXIDForDefaultLocale
(
)
{
static
const
char
*
posixID
=
nullptr
;
if
(
posixID
=
=
0
)
{
posixID
=
uprv_getPOSIXIDForCategory
(
LC_MESSAGES
)
;
}
return
posixID
;
}
#
if
!
U_CHARSET_IS_UTF8
static
const
char
*
uprv_getPOSIXIDForDefaultCodepage
(
)
{
static
const
char
*
posixID
=
nullptr
;
if
(
posixID
=
=
0
)
{
posixID
=
uprv_getPOSIXIDForCategory
(
LC_CTYPE
)
;
}
return
posixID
;
}
#
endif
#
endif
U_CAPI
const
char
*
U_EXPORT2
uprv_getDefaultLocaleID
(
)
{
#
if
U_POSIX_LOCALE
const
char
*
posixID
=
uprv_getPOSIXIDForDefaultLocale
(
)
;
if
(
gCorrectedPOSIXLocale
!
=
nullptr
)
{
return
gCorrectedPOSIXLocale
;
}
char
*
correctedPOSIXLocale
=
static_cast
<
char
*
>
(
uprv_malloc
(
uprv_strlen
(
posixID
)
+
10
+
1
)
)
;
if
(
correctedPOSIXLocale
=
=
nullptr
)
{
return
nullptr
;
}
uprv_strcpy
(
correctedPOSIXLocale
posixID
)
;
char
*
limit
;
if
(
(
limit
=
uprv_strchr
(
correctedPOSIXLocale
'
.
'
)
)
!
=
nullptr
)
{
*
limit
=
0
;
}
if
(
(
limit
=
uprv_strchr
(
correctedPOSIXLocale
'
'
)
)
!
=
nullptr
)
{
*
limit
=
0
;
}
if
(
(
uprv_strcmp
(
"
C
"
correctedPOSIXLocale
)
=
=
0
)
|
|
(
uprv_strcmp
(
"
POSIX
"
correctedPOSIXLocale
)
=
=
0
)
)
{
uprv_strcpy
(
correctedPOSIXLocale
"
en_US_POSIX
"
)
;
}
const
char
*
p
;
if
(
(
p
=
uprv_strrchr
(
posixID
'
'
)
)
!
=
nullptr
)
{
p
+
+
;
if
(
!
uprv_strcmp
(
p
"
nynorsk
"
)
)
{
p
=
"
NY
"
;
}
if
(
uprv_strchr
(
correctedPOSIXLocale
'
_
'
)
=
=
nullptr
)
{
uprv_strcat
(
correctedPOSIXLocale
"
__
"
)
;
}
else
{
uprv_strcat
(
correctedPOSIXLocale
"
_
"
)
;
}
const
char
*
q
;
if
(
(
q
=
uprv_strchr
(
p
'
.
'
)
)
!
=
nullptr
)
{
int32_t
len
=
(
int32_t
)
(
uprv_strlen
(
correctedPOSIXLocale
)
+
(
q
-
p
)
)
;
uprv_strncat
(
correctedPOSIXLocale
p
q
-
p
)
;
correctedPOSIXLocale
[
len
]
=
0
;
}
else
{
uprv_strcat
(
correctedPOSIXLocale
p
)
;
}
}
if
(
gCorrectedPOSIXLocale
=
=
nullptr
)
{
gCorrectedPOSIXLocale
=
correctedPOSIXLocale
;
gCorrectedPOSIXLocaleHeapAllocated
=
true
;
ucln_common_registerCleanup
(
UCLN_COMMON_PUTIL
putil_cleanup
)
;
correctedPOSIXLocale
=
nullptr
;
}
posixID
=
gCorrectedPOSIXLocale
;
if
(
correctedPOSIXLocale
!
=
nullptr
)
{
uprv_free
(
correctedPOSIXLocale
)
;
}
return
posixID
;
#
elif
U_PLATFORM_USES_ONLY_WIN32_API
#
define
POSIX_LOCALE_CAPACITY
64
UErrorCode
status
=
U_ZERO_ERROR
;
char
*
correctedPOSIXLocale
=
nullptr
;
if
(
gCorrectedPOSIXLocale
!
=
nullptr
)
{
return
gCorrectedPOSIXLocale
;
}
static
WCHAR
windowsLocale
[
LOCALE_NAME_MAX_LENGTH
]
=
{
}
;
int
length
=
GetLocaleInfoEx
(
LOCALE_NAME_USER_DEFAULT
LOCALE_SNAME
windowsLocale
LOCALE_NAME_MAX_LENGTH
)
;
if
(
length
>
0
)
{
char
modifiedWindowsLocale
[
LOCALE_NAME_MAX_LENGTH
]
=
{
}
;
int32_t
i
;
for
(
i
=
0
;
i
<
UPRV_LENGTHOF
(
modifiedWindowsLocale
)
;
i
+
+
)
{
if
(
windowsLocale
[
i
]
=
=
'
_
'
)
{
modifiedWindowsLocale
[
i
]
=
'
-
'
;
}
else
{
modifiedWindowsLocale
[
i
]
=
static_cast
<
char
>
(
windowsLocale
[
i
]
)
;
}
if
(
modifiedWindowsLocale
[
i
]
=
=
'
\
0
'
)
{
break
;
}
}
if
(
i
>
=
UPRV_LENGTHOF
(
modifiedWindowsLocale
)
)
{
modifiedWindowsLocale
[
UPRV_LENGTHOF
(
modifiedWindowsLocale
)
-
1
]
=
'
\
0
'
;
}
correctedPOSIXLocale
=
static_cast
<
char
*
>
(
uprv_malloc
(
POSIX_LOCALE_CAPACITY
+
1
)
)
;
if
(
correctedPOSIXLocale
)
{
int32_t
posixLen
=
uloc_canonicalize
(
modifiedWindowsLocale
correctedPOSIXLocale
POSIX_LOCALE_CAPACITY
&
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
*
(
correctedPOSIXLocale
+
posixLen
)
=
0
;
gCorrectedPOSIXLocale
=
correctedPOSIXLocale
;
gCorrectedPOSIXLocaleHeapAllocated
=
true
;
ucln_common_registerCleanup
(
UCLN_COMMON_PUTIL
putil_cleanup
)
;
}
else
{
uprv_free
(
correctedPOSIXLocale
)
;
}
}
}
if
(
gCorrectedPOSIXLocale
=
=
nullptr
)
{
gCorrectedPOSIXLocale
=
"
en_US
"
;
}
return
gCorrectedPOSIXLocale
;
#
elif
U_PLATFORM
=
=
U_PF_OS400
static
char
correctedLocale
[
64
]
;
const
char
*
localeID
=
getenv
(
"
LC_ALL
"
)
;
char
*
p
;
if
(
localeID
=
=
nullptr
)
localeID
=
getenv
(
"
LANG
"
)
;
if
(
localeID
=
=
nullptr
)
localeID
=
setlocale
(
LC_ALL
nullptr
)
;
if
(
localeID
=
=
nullptr
)
return
"
en_US_POSIX
"
;
if
(
(
p
=
uprv_strrchr
(
localeID
'
/
'
)
)
!
=
nullptr
)
{
p
+
+
;
localeID
=
p
;
}
uprv_strcpy
(
correctedLocale
localeID
)
;
if
(
(
p
=
uprv_strchr
(
correctedLocale
'
.
'
)
)
!
=
nullptr
)
{
*
p
=
0
;
}
T_CString_toUpperCase
(
correctedLocale
)
;
if
(
(
uprv_strcmp
(
"
C
"
correctedLocale
)
=
=
0
)
|
|
(
uprv_strcmp
(
"
POSIX
"
correctedLocale
)
=
=
0
)
|
|
(
uprv_strncmp
(
"
QLGPGCMA
"
correctedLocale
8
)
=
=
0
)
)
{
uprv_strcpy
(
correctedLocale
"
en_US_POSIX
"
)
;
}
else
{
int16_t
LocaleLen
;
for
(
p
=
correctedLocale
;
*
p
!
=
0
&
&
*
p
!
=
'
_
'
;
p
+
+
)
{
*
p
=
uprv_tolower
(
*
p
)
;
}
LocaleLen
=
uprv_strlen
(
correctedLocale
)
;
if
(
correctedLocale
[
LocaleLen
-
2
]
=
=
'
_
'
&
&
correctedLocale
[
LocaleLen
-
1
]
=
=
'
E
'
)
{
uprv_strcat
(
correctedLocale
"
URO
"
)
;
}
else
if
(
correctedLocale
[
LocaleLen
-
2
]
=
=
'
_
'
&
&
correctedLocale
[
LocaleLen
-
1
]
=
=
'
L
'
)
{
correctedLocale
[
LocaleLen
-
2
]
=
0
;
}
else
if
(
uprv_strncmp
(
correctedLocale
"
zh_HK
"
5
)
=
=
0
)
{
uprv_strcpy
(
correctedLocale
"
zh_HK
"
)
;
}
else
if
(
uprv_strcmp
(
correctedLocale
"
zh_CN_GBK
"
)
=
=
0
)
{
uprv_strcpy
(
correctedLocale
"
zh_CN
"
)
;
}
}
return
correctedLocale
;
#
endif
}
#
if
!
U_CHARSET_IS_UTF8
#
if
U_POSIX_LOCALE
static
const
char
*
remapPlatformDependentCodepage
(
const
char
*
locale
const
char
*
name
)
{
if
(
locale
!
=
nullptr
&
&
*
locale
=
=
0
)
{
locale
=
nullptr
;
}
if
(
name
=
=
nullptr
)
{
return
nullptr
;
}
#
if
U_PLATFORM
=
=
U_PF_AIX
if
(
uprv_strcmp
(
name
"
IBM
-
943
"
)
=
=
0
)
{
name
=
"
Shift
-
JIS
"
;
}
else
if
(
uprv_strcmp
(
name
"
IBM
-
1252
"
)
=
=
0
)
{
name
=
"
IBM
-
5348
"
;
}
#
elif
U_PLATFORM
=
=
U_PF_SOLARIS
if
(
locale
!
=
nullptr
&
&
uprv_strcmp
(
name
"
EUC
"
)
=
=
0
)
{
if
(
uprv_strcmp
(
locale
"
zh_CN
"
)
=
=
0
)
{
name
=
"
EUC
-
CN
"
;
}
else
if
(
uprv_strcmp
(
locale
"
zh_TW
"
)
=
=
0
)
{
name
=
"
EUC
-
TW
"
;
}
else
if
(
uprv_strcmp
(
locale
"
ko_KR
"
)
=
=
0
)
{
name
=
"
EUC
-
KR
"
;
}
}
else
if
(
uprv_strcmp
(
name
"
eucJP
"
)
=
=
0
)
{
name
=
"
eucjis
"
;
}
else
if
(
uprv_strcmp
(
name
"
646
"
)
=
=
0
)
{
name
=
"
ISO
-
8859
-
1
"
;
}
#
elif
U_PLATFORM_IS_DARWIN_BASED
if
(
locale
=
=
nullptr
&
&
*
name
=
=
0
)
{
name
=
"
UTF
-
8
"
;
}
else
if
(
uprv_strcmp
(
name
"
CP949
"
)
=
=
0
)
{
name
=
"
EUC
-
KR
"
;
}
else
if
(
locale
!
=
nullptr
&
&
uprv_strcmp
(
locale
"
en_US_POSIX
"
)
!
=
0
&
&
uprv_strcmp
(
name
"
US
-
ASCII
"
)
=
=
0
)
{
name
=
"
UTF
-
8
"
;
}
#
elif
U_PLATFORM
=
=
U_PF_BSD
if
(
uprv_strcmp
(
name
"
CP949
"
)
=
=
0
)
{
name
=
"
EUC
-
KR
"
;
}
#
elif
U_PLATFORM
=
=
U_PF_HPUX
if
(
locale
!
=
nullptr
&
&
uprv_strcmp
(
locale
"
zh_HK
"
)
=
=
0
&
&
uprv_strcmp
(
name
"
big5
"
)
=
=
0
)
{
name
=
"
hkbig5
"
;
}
else
if
(
uprv_strcmp
(
name
"
eucJP
"
)
=
=
0
)
{
name
=
"
eucjis
"
;
}
#
elif
U_PLATFORM
=
=
U_PF_LINUX
if
(
locale
!
=
nullptr
&
&
uprv_strcmp
(
name
"
euc
"
)
=
=
0
)
{
if
(
uprv_strcmp
(
locale
"
korean
"
)
=
=
0
)
{
name
=
"
EUC
-
KR
"
;
}
else
if
(
uprv_strcmp
(
locale
"
japanese
"
)
=
=
0
)
{
name
=
"
eucjis
"
;
}
}
else
if
(
uprv_strcmp
(
name
"
eucjp
"
)
=
=
0
)
{
name
=
"
eucjis
"
;
}
else
if
(
locale
!
=
nullptr
&
&
uprv_strcmp
(
locale
"
en_US_POSIX
"
)
!
=
0
&
&
(
uprv_strcmp
(
name
"
ANSI_X3
.
4
-
1968
"
)
=
=
0
|
|
uprv_strcmp
(
name
"
US
-
ASCII
"
)
=
=
0
)
)
{
name
=
"
UTF
-
8
"
;
}
#
endif
if
(
*
name
=
=
0
)
{
name
=
nullptr
;
}
return
name
;
}
static
const
char
*
getCodepageFromPOSIXID
(
const
char
*
localeName
char
*
buffer
int32_t
buffCapacity
)
{
char
localeBuf
[
100
]
;
const
char
*
name
=
nullptr
;
char
*
variant
=
nullptr
;
if
(
localeName
!
=
nullptr
&
&
(
name
=
(
uprv_strchr
(
localeName
'
.
'
)
)
)
!
=
nullptr
)
{
size_t
localeCapacity
=
uprv_min
(
sizeof
(
localeBuf
)
(
name
-
localeName
)
+
1
)
;
uprv_strncpy
(
localeBuf
localeName
localeCapacity
)
;
localeBuf
[
localeCapacity
-
1
]
=
0
;
name
=
uprv_strncpy
(
buffer
name
+
1
buffCapacity
)
;
buffer
[
buffCapacity
-
1
]
=
0
;
if
(
(
variant
=
const_cast
<
char
*
>
(
uprv_strchr
(
name
'
'
)
)
)
!
=
nullptr
)
{
*
variant
=
0
;
}
name
=
remapPlatformDependentCodepage
(
localeBuf
name
)
;
}
return
name
;
}
#
endif
static
const
char
*
int_getDefaultCodepage
(
)
{
#
if
U_PLATFORM
=
=
U_PF_OS400
uint32_t
ccsid
=
37
;
static
char
codepage
[
64
]
;
Qwc_JOBI0400_t
jobinfo
;
Qus_EC_t
error
=
{
sizeof
(
Qus_EC_t
)
}
;
EPT_CALL
(
QUSRJOBI
)
(
&
jobinfo
sizeof
(
jobinfo
)
"
JOBI0400
"
"
*
"
"
"
&
error
)
;
if
(
error
.
Bytes_Available
=
=
0
)
{
if
(
jobinfo
.
Coded_Char_Set_ID
!
=
0xFFFF
)
{
ccsid
=
(
uint32_t
)
jobinfo
.
Coded_Char_Set_ID
;
}
else
if
(
jobinfo
.
Default_Coded_Char_Set_Id
!
=
0xFFFF
)
{
ccsid
=
(
uint32_t
)
jobinfo
.
Default_Coded_Char_Set_Id
;
}
}
snprintf
(
codepage
sizeof
(
codepage
)
"
ibm
-
%
d
"
ccsid
)
;
return
codepage
;
#
elif
U_PLATFORM
=
=
U_PF_OS390
static
char
codepage
[
64
]
;
strncpy
(
codepage
nl_langinfo
(
CODESET
)
63
-
strlen
(
UCNV_SWAP_LFNL_OPTION_STRING
)
)
;
strcat
(
codepage
UCNV_SWAP_LFNL_OPTION_STRING
)
;
codepage
[
63
]
=
0
;
return
codepage
;
#
elif
U_PLATFORM_USES_ONLY_WIN32_API
static
char
codepage
[
64
]
;
DWORD
codepageNumber
=
0
;
#
if
U_PLATFORM_HAS_WINUWP_API
=
=
1
GetLocaleInfoEx
(
LOCALE_NAME_SYSTEM_DEFAULT
LOCALE_IDEFAULTANSICODEPAGE
|
LOCALE_RETURN_NUMBER
(
LPWSTR
)
&
codepageNumber
sizeof
(
codepageNumber
)
/
sizeof
(
WCHAR
)
)
;
#
else
codepageNumber
=
GetACP
(
)
;
#
endif
if
(
codepageNumber
=
=
65001
)
{
return
"
UTF
-
8
"
;
}
if
(
codepageNumber
>
0
&
&
codepageNumber
<
20000
)
{
snprintf
(
codepage
sizeof
(
codepage
)
"
windows
-
%
ld
"
codepageNumber
)
;
return
codepage
;
}
return
"
UTF
-
8
"
;
#
elif
U_POSIX_LOCALE
static
char
codesetName
[
100
]
;
const
char
*
localeName
=
nullptr
;
const
char
*
name
=
nullptr
;
localeName
=
uprv_getPOSIXIDForDefaultCodepage
(
)
;
uprv_memset
(
codesetName
0
sizeof
(
codesetName
)
)
;
#
if
(
U_HAVE_NL_LANGINFO_CODESET
&
&
U_PLATFORM
!
=
U_PF_SOLARIS
)
{
const
char
*
codeset
=
nl_langinfo
(
U_NL_LANGINFO_CODESET
)
;
#
if
U_PLATFORM_IS_DARWIN_BASED
|
|
U_PLATFORM_IS_LINUX_BASED
if
(
uprv_strcmp
(
localeName
"
en_US_POSIX
"
)
!
=
0
)
{
codeset
=
remapPlatformDependentCodepage
(
localeName
codeset
)
;
}
else
#
endif
{
codeset
=
remapPlatformDependentCodepage
(
nullptr
codeset
)
;
}
if
(
codeset
!
=
nullptr
)
{
uprv_strncpy
(
codesetName
codeset
sizeof
(
codesetName
)
)
;
codesetName
[
sizeof
(
codesetName
)
-
1
]
=
0
;
return
codesetName
;
}
}
#
endif
uprv_memset
(
codesetName
0
sizeof
(
codesetName
)
)
;
name
=
getCodepageFromPOSIXID
(
localeName
codesetName
sizeof
(
codesetName
)
)
;
if
(
name
)
{
return
name
;
}
if
(
*
codesetName
=
=
0
)
{
(
void
)
uprv_strcpy
(
codesetName
"
US
-
ASCII
"
)
;
}
return
codesetName
;
#
else
return
"
US
-
ASCII
"
;
#
endif
}
U_CAPI
const
char
*
U_EXPORT2
uprv_getDefaultCodepage
(
)
{
static
char
const
*
name
=
nullptr
;
umtx_lock
(
nullptr
)
;
if
(
name
=
=
nullptr
)
{
name
=
int_getDefaultCodepage
(
)
;
}
umtx_unlock
(
nullptr
)
;
return
name
;
}
#
endif
U_CAPI
void
U_EXPORT2
u_versionFromString
(
UVersionInfo
versionArray
const
char
*
versionString
)
{
char
*
end
;
uint16_t
part
=
0
;
if
(
versionArray
=
=
nullptr
)
{
return
;
}
if
(
versionString
!
=
nullptr
)
{
for
(
;
;
)
{
versionArray
[
part
]
=
(
uint8_t
)
uprv_strtoul
(
versionString
&
end
10
)
;
if
(
end
=
=
versionString
|
|
+
+
part
=
=
U_MAX_VERSION_LENGTH
|
|
*
end
!
=
U_VERSION_DELIMITER
)
{
break
;
}
versionString
=
end
+
1
;
}
}
while
(
part
<
U_MAX_VERSION_LENGTH
)
{
versionArray
[
part
+
+
]
=
0
;
}
}
U_CAPI
void
U_EXPORT2
u_versionFromUString
(
UVersionInfo
versionArray
const
char16_t
*
versionString
)
{
if
(
versionArray
!
=
nullptr
&
&
versionString
!
=
nullptr
)
{
char
versionChars
[
U_MAX_VERSION_STRING_LENGTH
+
1
]
;
int32_t
len
=
u_strlen
(
versionString
)
;
if
(
len
>
U_MAX_VERSION_STRING_LENGTH
)
{
len
=
U_MAX_VERSION_STRING_LENGTH
;
}
u_UCharsToChars
(
versionString
versionChars
len
)
;
versionChars
[
len
]
=
0
;
u_versionFromString
(
versionArray
versionChars
)
;
}
}
U_CAPI
void
U_EXPORT2
u_versionToString
(
const
UVersionInfo
versionArray
char
*
versionString
)
{
uint16_t
count
part
;
uint8_t
field
;
if
(
versionString
=
=
nullptr
)
{
return
;
}
if
(
versionArray
=
=
nullptr
)
{
versionString
[
0
]
=
0
;
return
;
}
for
(
count
=
4
;
count
>
0
&
&
versionArray
[
count
-
1
]
=
=
0
;
-
-
count
)
{
}
if
(
count
<
=
1
)
{
count
=
2
;
}
field
=
versionArray
[
0
]
;
if
(
field
>
=
100
)
{
*
versionString
+
+
=
(
char
)
(
'
0
'
+
field
/
100
)
;
field
%
=
100
;
}
if
(
field
>
=
10
)
{
*
versionString
+
+
=
(
char
)
(
'
0
'
+
field
/
10
)
;
field
%
=
10
;
}
*
versionString
+
+
=
(
char
)
(
'
0
'
+
field
)
;
for
(
part
=
1
;
part
<
count
;
+
+
part
)
{
*
versionString
+
+
=
U_VERSION_DELIMITER
;
field
=
versionArray
[
part
]
;
if
(
field
>
=
100
)
{
*
versionString
+
+
=
(
char
)
(
'
0
'
+
field
/
100
)
;
field
%
=
100
;
}
if
(
field
>
=
10
)
{
*
versionString
+
+
=
(
char
)
(
'
0
'
+
field
/
10
)
;
field
%
=
10
;
}
*
versionString
+
+
=
(
char
)
(
'
0
'
+
field
)
;
}
*
versionString
=
0
;
}
U_CAPI
void
U_EXPORT2
u_getVersion
(
UVersionInfo
versionArray
)
{
(
void
)
copyright
;
u_versionFromString
(
versionArray
U_ICU_VERSION
)
;
}
#
if
U_ENABLE_DYLOAD
&
&
HAVE_DLOPEN
&
&
!
U_PLATFORM_USES_ONLY_WIN32_API
#
if
HAVE_DLFCN_H
#
ifdef
__MVS__
#
ifndef
__SUSV3
#
define
__SUSV3
1
#
endif
#
endif
#
include
<
dlfcn
.
h
>
#
endif
U_CAPI
void
*
U_EXPORT2
uprv_dl_open
(
const
char
*
libName
UErrorCode
*
status
)
{
void
*
ret
=
nullptr
;
if
(
U_FAILURE
(
*
status
)
)
return
ret
;
ret
=
dlopen
(
libName
RTLD_NOW
|
RTLD_GLOBAL
)
;
if
(
ret
=
=
nullptr
)
{
#
ifdef
U_TRACE_DYLOAD
printf
(
"
dlerror
on
dlopen
(
%
s
)
:
%
s
\
n
"
libName
dlerror
(
)
)
;
#
endif
*
status
=
U_MISSING_RESOURCE_ERROR
;
}
return
ret
;
}
U_CAPI
void
U_EXPORT2
uprv_dl_close
(
void
*
lib
UErrorCode
*
status
)
{
if
(
U_FAILURE
(
*
status
)
)
return
;
dlclose
(
lib
)
;
}
U_CAPI
UVoidFunction
*
U_EXPORT2
uprv_dlsym_func
(
void
*
lib
const
char
*
sym
UErrorCode
*
status
)
{
union
{
UVoidFunction
*
fp
;
void
*
vp
;
}
uret
;
uret
.
fp
=
nullptr
;
if
(
U_FAILURE
(
*
status
)
)
return
uret
.
fp
;
uret
.
vp
=
dlsym
(
lib
sym
)
;
if
(
uret
.
vp
=
=
nullptr
)
{
#
ifdef
U_TRACE_DYLOAD
printf
(
"
dlerror
on
dlsym
(
%
p
%
s
)
:
%
s
\
n
"
lib
sym
dlerror
(
)
)
;
#
endif
*
status
=
U_MISSING_RESOURCE_ERROR
;
}
return
uret
.
fp
;
}
#
elif
U_ENABLE_DYLOAD
&
&
U_PLATFORM_USES_ONLY_WIN32_API
&
&
!
U_PLATFORM_HAS_WINUWP_API
U_CAPI
void
*
U_EXPORT2
uprv_dl_open
(
const
char
*
libName
UErrorCode
*
status
)
{
HMODULE
lib
=
nullptr
;
if
(
U_FAILURE
(
*
status
)
)
return
nullptr
;
lib
=
LoadLibraryA
(
libName
)
;
if
(
lib
=
=
nullptr
)
{
*
status
=
U_MISSING_RESOURCE_ERROR
;
}
return
(
void
*
)
lib
;
}
U_CAPI
void
U_EXPORT2
uprv_dl_close
(
void
*
lib
UErrorCode
*
status
)
{
HMODULE
handle
=
(
HMODULE
)
lib
;
if
(
U_FAILURE
(
*
status
)
)
return
;
FreeLibrary
(
handle
)
;
return
;
}
U_CAPI
UVoidFunction
*
U_EXPORT2
uprv_dlsym_func
(
void
*
lib
const
char
*
sym
UErrorCode
*
status
)
{
HMODULE
handle
=
(
HMODULE
)
lib
;
UVoidFunction
*
addr
=
nullptr
;
if
(
U_FAILURE
(
*
status
)
|
|
lib
=
=
nullptr
)
return
nullptr
;
addr
=
(
UVoidFunction
*
)
GetProcAddress
(
handle
sym
)
;
if
(
addr
=
=
nullptr
)
{
DWORD
lastError
=
GetLastError
(
)
;
if
(
lastError
=
=
ERROR_PROC_NOT_FOUND
)
{
*
status
=
U_MISSING_RESOURCE_ERROR
;
}
else
{
*
status
=
U_UNSUPPORTED_ERROR
;
}
}
return
addr
;
}
#
else
U_CAPI
void
*
U_EXPORT2
uprv_dl_open
(
const
char
*
libName
UErrorCode
*
status
)
{
(
void
)
libName
;
if
(
U_FAILURE
(
*
status
)
)
return
nullptr
;
*
status
=
U_UNSUPPORTED_ERROR
;
return
nullptr
;
}
U_CAPI
void
U_EXPORT2
uprv_dl_close
(
void
*
lib
UErrorCode
*
status
)
{
(
void
)
lib
;
if
(
U_FAILURE
(
*
status
)
)
return
;
*
status
=
U_UNSUPPORTED_ERROR
;
return
;
}
U_CAPI
UVoidFunction
*
U_EXPORT2
uprv_dlsym_func
(
void
*
lib
const
char
*
sym
UErrorCode
*
status
)
{
(
void
)
lib
;
(
void
)
sym
;
if
(
U_SUCCESS
(
*
status
)
)
{
*
status
=
U_UNSUPPORTED_ERROR
;
}
return
(
UVoidFunction
*
)
nullptr
;
}
#
endif
