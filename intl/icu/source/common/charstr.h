#
ifndef
CHARSTRING_H
#
define
CHARSTRING_H
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
cmemory
.
h
"
U_NAMESPACE_BEGIN
#
if
!
U_PLATFORM_IS_DARWIN_BASED
template
class
U_COMMON_API
MaybeStackArray
<
char
40
>
;
#
endif
class
U_COMMON_API
CharString
:
public
UMemory
{
public
:
CharString
(
)
:
len
(
0
)
{
buffer
[
0
]
=
0
;
}
CharString
(
StringPiece
s
UErrorCode
&
errorCode
)
:
len
(
0
)
{
buffer
[
0
]
=
0
;
append
(
s
errorCode
)
;
}
CharString
(
const
CharString
&
s
UErrorCode
&
errorCode
)
:
len
(
0
)
{
buffer
[
0
]
=
0
;
append
(
s
errorCode
)
;
}
CharString
(
const
char
*
s
int32_t
sLength
UErrorCode
&
errorCode
)
:
len
(
0
)
{
buffer
[
0
]
=
0
;
append
(
s
sLength
errorCode
)
;
}
~
CharString
(
)
{
}
CharString
(
CharString
&
&
src
)
noexcept
;
CharString
&
operator
=
(
CharString
&
&
src
)
noexcept
;
CharString
&
copyFrom
(
const
CharString
&
other
UErrorCode
&
errorCode
)
;
UBool
isEmpty
(
)
const
{
return
len
=
=
0
;
}
int32_t
length
(
)
const
{
return
len
;
}
char
operator
[
]
(
int32_t
index
)
const
{
return
buffer
[
index
]
;
}
StringPiece
toStringPiece
(
)
const
{
return
StringPiece
(
buffer
.
getAlias
(
)
len
)
;
}
const
char
*
data
(
)
const
{
return
buffer
.
getAlias
(
)
;
}
char
*
data
(
)
{
return
buffer
.
getAlias
(
)
;
}
char
*
cloneData
(
UErrorCode
&
errorCode
)
const
;
int32_t
extract
(
char
*
dest
int32_t
capacity
UErrorCode
&
errorCode
)
const
;
bool
operator
=
=
(
const
CharString
&
other
)
const
{
return
len
=
=
other
.
length
(
)
&
&
(
len
=
=
0
|
|
uprv_memcmp
(
data
(
)
other
.
data
(
)
len
)
=
=
0
)
;
}
bool
operator
!
=
(
const
CharString
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
bool
operator
=
=
(
StringPiece
other
)
const
{
return
len
=
=
other
.
length
(
)
&
&
(
len
=
=
0
|
|
uprv_memcmp
(
data
(
)
other
.
data
(
)
len
)
=
=
0
)
;
}
bool
operator
!
=
(
StringPiece
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
int32_t
lastIndexOf
(
char
c
)
const
;
bool
contains
(
StringPiece
s
)
const
;
CharString
&
clear
(
)
{
len
=
0
;
buffer
[
0
]
=
0
;
return
*
this
;
}
CharString
&
truncate
(
int32_t
newLength
)
;
CharString
&
append
(
char
c
UErrorCode
&
errorCode
)
;
CharString
&
append
(
StringPiece
s
UErrorCode
&
errorCode
)
{
return
append
(
s
.
data
(
)
s
.
length
(
)
errorCode
)
;
}
CharString
&
append
(
const
CharString
&
s
UErrorCode
&
errorCode
)
{
return
append
(
s
.
data
(
)
s
.
length
(
)
errorCode
)
;
}
CharString
&
append
(
const
char
*
s
int32_t
sLength
UErrorCode
&
status
)
;
CharString
&
appendNumber
(
int32_t
number
UErrorCode
&
status
)
;
char
*
getAppendBuffer
(
int32_t
minCapacity
int32_t
desiredCapacityHint
int32_t
&
resultCapacity
UErrorCode
&
errorCode
)
;
CharString
&
appendInvariantChars
(
const
UnicodeString
&
s
UErrorCode
&
errorCode
)
;
CharString
&
appendInvariantChars
(
const
char16_t
*
uchars
int32_t
ucharsLen
UErrorCode
&
errorCode
)
;
CharString
&
appendPathPart
(
StringPiece
s
UErrorCode
&
errorCode
)
;
CharString
&
ensureEndsWithFileSeparator
(
UErrorCode
&
errorCode
)
;
private
:
MaybeStackArray
<
char
40
>
buffer
;
int32_t
len
;
UBool
ensureCapacity
(
int32_t
capacity
int32_t
desiredCapacityHint
UErrorCode
&
errorCode
)
;
CharString
(
const
CharString
&
other
)
=
delete
;
CharString
&
operator
=
(
const
CharString
&
other
)
=
delete
;
char
getDirSepChar
(
)
const
;
}
;
U_NAMESPACE_END
#
endif
