#
include
"
uposixdefs
.
h
"
#
include
"
unicode
/
putil
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
udatamem
.
h
"
#
include
"
umapfile
.
h
"
#
if
MAP_IMPLEMENTATION
=
=
MAP_WIN32
#
ifndef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
#
endif
#
define
VC_EXTRALEAN
#
define
NOUSER
#
define
NOSERVICE
#
define
NOIME
#
define
NOMCX
#
if
U_PLATFORM_HAS_WINUWP_API
=
=
1
#
include
<
winapifamily
.
h
>
#
if
!
(
WINAPI_FAMILY_PARTITION
(
WINAPI_PARTITION_DESKTOP
|
WINAPI_PARTITION_SYSTEM
)
)
#
pragma
push_macro
(
"
WINAPI_PARTITION_DESKTOP
"
)
#
undef
WINAPI_PARTITION_DESKTOP
#
define
WINAPI_PARTITION_DESKTOP
1
#
define
CHANGED_WINAPI_PARTITION_DESKTOP_VALUE
#
endif
#
endif
#
include
<
windows
.
h
>
#
if
U_PLATFORM_HAS_WINUWP_API
=
=
1
&
&
defined
(
CHANGED_WINAPI_PARTITION_DESKTOP_VALUE
)
#
pragma
pop_macro
(
"
WINAPI_PARTITION_DESKTOP
"
)
#
endif
#
include
"
cmemory
.
h
"
typedef
HANDLE
MemoryMap
;
#
define
IS_MAP
(
map
)
(
(
map
)
!
=
nullptr
)
#
elif
MAP_IMPLEMENTATION
=
=
MAP_POSIX
|
|
MAP_IMPLEMENTATION
=
=
MAP_390DLL
typedef
size_t
MemoryMap
;
#
define
IS_MAP
(
map
)
(
(
map
)
!
=
0
)
#
include
<
unistd
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
fcntl
.
h
>
#
ifndef
MAP_FAILED
#
define
MAP_FAILED
(
(
void
*
)
-
1
)
#
endif
#
if
MAP_IMPLEMENTATION
=
=
MAP_390DLL
#
include
<
dll
.
h
>
#
include
"
cstring
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
unicode
/
udata
.
h
"
#
define
LIB_PREFIX
"
lib
"
#
define
LIB_SUFFIX
"
.
dll
"
#
define
U_ICUDATA_ENTRY_NAME
"
icudt
"
U_ICU_VERSION_SHORT
U_LIB_SUFFIX_C_NAME_STRING
"
_dat
"
#
endif
#
elif
MAP_IMPLEMENTATION
=
=
MAP_STDIO
#
include
<
stdio
.
h
>
#
include
"
cmemory
.
h
"
typedef
void
*
MemoryMap
;
#
define
IS_MAP
(
map
)
(
(
map
)
!
=
nullptr
)
#
endif
#
if
MAP_IMPLEMENTATION
=
=
MAP_NONE
U_CFUNC
UBool
uprv_mapFile
(
UDataMemory
*
pData
const
char
*
path
UErrorCode
*
status
)
{
if
(
U_FAILURE
(
*
status
)
)
{
return
false
;
}
UDataMemory_init
(
pData
)
;
return
false
;
}
U_CFUNC
void
uprv_unmapFile
(
UDataMemory
*
pData
)
{
}
#
elif
MAP_IMPLEMENTATION
=
=
MAP_WIN32
U_CFUNC
UBool
uprv_mapFile
(
UDataMemory
*
pData
const
char
*
path
UErrorCode
*
status
)
{
if
(
U_FAILURE
(
*
status
)
)
{
return
false
;
}
HANDLE
map
=
nullptr
;
HANDLE
file
=
INVALID_HANDLE_VALUE
;
UDataMemory_init
(
pData
)
;
#
if
U_PLATFORM_HAS_WINUWP_API
=
=
0
file
=
CreateFileA
(
path
GENERIC_READ
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
|
FILE_FLAG_RANDOM_ACCESS
nullptr
)
;
#
else
wchar_t
utf16Path
[
MAX_PATH
]
;
int32_t
pathUtf16Len
=
0
;
u_strFromUTF8
(
reinterpret_cast
<
char16_t
*
>
(
utf16Path
)
static_cast
<
int32_t
>
(
UPRV_LENGTHOF
(
utf16Path
)
)
&
pathUtf16Len
path
-
1
status
)
;
if
(
U_FAILURE
(
*
status
)
)
{
return
false
;
}
if
(
*
status
=
=
U_STRING_NOT_TERMINATED_WARNING
)
{
*
status
=
U_BUFFER_OVERFLOW_ERROR
;
return
false
;
}
file
=
CreateFileW
(
utf16Path
GENERIC_READ
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
|
FILE_FLAG_RANDOM_ACCESS
nullptr
)
;
#
endif
if
(
file
=
=
INVALID_HANDLE_VALUE
)
{
if
(
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
=
=
E_OUTOFMEMORY
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
return
false
;
}
map
=
CreateFileMappingW
(
file
nullptr
PAGE_READONLY
0
0
nullptr
)
;
CloseHandle
(
file
)
;
if
(
map
=
=
nullptr
)
{
if
(
HRESULT_FROM_WIN32
(
GetLastError
(
)
)
=
=
E_OUTOFMEMORY
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
return
false
;
}
pData
-
>
pHeader
=
reinterpret_cast
<
const
DataHeader
*
>
(
MapViewOfFile
(
map
FILE_MAP_READ
0
0
0
)
)
;
if
(
pData
-
>
pHeader
=
=
nullptr
)
{
CloseHandle
(
map
)
;
return
false
;
}
pData
-
>
map
=
map
;
return
true
;
}
U_CFUNC
void
uprv_unmapFile
(
UDataMemory
*
pData
)
{
if
(
pData
!
=
nullptr
&
&
pData
-
>
map
!
=
nullptr
)
{
UnmapViewOfFile
(
pData
-
>
pHeader
)
;
CloseHandle
(
pData
-
>
map
)
;
pData
-
>
pHeader
=
nullptr
;
pData
-
>
map
=
nullptr
;
}
}
#
elif
MAP_IMPLEMENTATION
=
=
MAP_POSIX
U_CFUNC
UBool
uprv_mapFile
(
UDataMemory
*
pData
const
char
*
path
UErrorCode
*
status
)
{
int
fd
;
int
length
;
struct
stat
mystat
;
void
*
data
;
if
(
U_FAILURE
(
*
status
)
)
{
return
false
;
}
UDataMemory_init
(
pData
)
;
if
(
stat
(
path
&
mystat
)
!
=
0
|
|
mystat
.
st_size
<
=
0
)
{
return
false
;
}
length
=
mystat
.
st_size
;
fd
=
open
(
path
O_RDONLY
)
;
if
(
fd
=
=
-
1
)
{
return
false
;
}
#
if
U_PLATFORM
!
=
U_PF_HPUX
data
=
mmap
(
0
length
PROT_READ
MAP_SHARED
fd
0
)
;
#
else
data
=
mmap
(
0
length
PROT_READ
MAP_PRIVATE
fd
0
)
;
#
endif
close
(
fd
)
;
if
(
data
=
=
MAP_FAILED
)
{
return
false
;
}
pData
-
>
map
=
(
char
*
)
data
+
length
;
pData
-
>
pHeader
=
(
const
DataHeader
*
)
data
;
pData
-
>
mapAddr
=
data
;
#
if
U_PLATFORM
=
=
U_PF_IPHONE
posix_madvise
(
data
length
POSIX_MADV_RANDOM
)
;
#
endif
return
true
;
}
U_CFUNC
void
uprv_unmapFile
(
UDataMemory
*
pData
)
{
if
(
pData
!
=
nullptr
&
&
pData
-
>
map
!
=
nullptr
)
{
size_t
dataLen
=
(
char
*
)
pData
-
>
map
-
(
char
*
)
pData
-
>
mapAddr
;
if
(
munmap
(
pData
-
>
mapAddr
dataLen
)
=
=
-
1
)
{
}
pData
-
>
pHeader
=
nullptr
;
pData
-
>
map
=
0
;
pData
-
>
mapAddr
=
nullptr
;
}
}
#
elif
MAP_IMPLEMENTATION
=
=
MAP_STDIO
static
int32_t
umap_fsize
(
FILE
*
f
)
{
int32_t
savedPos
=
ftell
(
f
)
;
int32_t
size
=
0
;
fseek
(
f
0
SEEK_END
)
;
size
=
(
int32_t
)
ftell
(
f
)
;
fseek
(
f
savedPos
SEEK_SET
)
;
return
size
;
}
U_CFUNC
UBool
uprv_mapFile
(
UDataMemory
*
pData
const
char
*
path
UErrorCode
*
status
)
{
FILE
*
file
;
int32_t
fileLength
;
void
*
p
;
if
(
U_FAILURE
(
*
status
)
)
{
return
false
;
}
UDataMemory_init
(
pData
)
;
file
=
fopen
(
path
"
rb
"
)
;
if
(
file
=
=
nullptr
)
{
return
false
;
}
fileLength
=
umap_fsize
(
file
)
;
if
(
ferror
(
file
)
|
|
fileLength
<
=
20
)
{
fclose
(
file
)
;
return
false
;
}
p
=
uprv_malloc
(
fileLength
)
;
if
(
p
=
=
nullptr
)
{
fclose
(
file
)
;
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
false
;
}
if
(
fileLength
!
=
fread
(
p
1
fileLength
file
)
)
{
uprv_free
(
p
)
;
fclose
(
file
)
;
return
false
;
}
fclose
(
file
)
;
pData
-
>
map
=
p
;
pData
-
>
pHeader
=
(
const
DataHeader
*
)
p
;
pData
-
>
mapAddr
=
p
;
return
true
;
}
U_CFUNC
void
uprv_unmapFile
(
UDataMemory
*
pData
)
{
if
(
pData
!
=
nullptr
&
&
pData
-
>
map
!
=
nullptr
)
{
uprv_free
(
pData
-
>
map
)
;
pData
-
>
map
=
nullptr
;
pData
-
>
mapAddr
=
nullptr
;
pData
-
>
pHeader
=
nullptr
;
}
}
#
elif
MAP_IMPLEMENTATION
=
=
MAP_390DLL
static
char
*
strcpy_returnEnd
(
char
*
dest
const
char
*
src
)
{
while
(
(
*
dest
=
*
src
)
!
=
0
)
{
+
+
dest
;
+
+
src
;
}
return
dest
;
}
static
char
*
uprv_computeDirPath
(
const
char
*
path
char
*
pathBuffer
)
{
char
*
finalSlash
;
int32_t
pathLen
;
finalSlash
=
0
;
if
(
path
!
=
0
)
{
finalSlash
=
uprv_strrchr
(
path
U_FILE_SEP_CHAR
)
;
}
*
pathBuffer
=
0
;
if
(
finalSlash
=
=
0
)
{
const
char
*
icuDataDir
;
icuDataDir
=
u_getDataDirectory
(
)
;
if
(
icuDataDir
!
=
nullptr
&
&
*
icuDataDir
!
=
0
)
{
return
strcpy_returnEnd
(
pathBuffer
icuDataDir
)
;
}
else
{
return
pathBuffer
;
}
}
pathLen
=
(
int32_t
)
(
finalSlash
-
path
+
1
)
;
uprv_memcpy
(
pathBuffer
path
pathLen
)
;
*
(
pathBuffer
+
pathLen
)
=
0
;
return
pathBuffer
+
pathLen
;
}
#
define
DATA_TYPE
"
dat
"
U_CFUNC
UBool
uprv_mapFile
(
UDataMemory
*
pData
const
char
*
path
UErrorCode
*
status
)
{
const
char
*
inBasename
;
char
*
basename
;
char
pathBuffer
[
1024
]
;
const
DataHeader
*
pHeader
;
dllhandle
*
handle
;
void
*
val
=
0
;
if
(
U_FAILURE
(
*
status
)
)
{
return
false
;
}
inBasename
=
uprv_strrchr
(
path
U_FILE_SEP_CHAR
)
;
if
(
inBasename
=
=
nullptr
)
{
inBasename
=
path
;
}
else
{
inBasename
+
+
;
}
basename
=
uprv_computeDirPath
(
path
pathBuffer
)
;
if
(
uprv_strcmp
(
inBasename
U_ICUDATA_NAME
"
.
dat
"
)
!
=
0
)
{
int
fd
;
int
length
;
struct
stat
mystat
;
void
*
data
;
UDataMemory_init
(
pData
)
;
if
(
stat
(
path
&
mystat
)
!
=
0
|
|
mystat
.
st_size
<
=
0
)
{
return
false
;
}
length
=
mystat
.
st_size
;
fd
=
open
(
path
O_RDONLY
)
;
if
(
fd
=
=
-
1
)
{
return
false
;
}
data
=
mmap
(
0
length
PROT_READ
MAP_PRIVATE
fd
0
)
;
close
(
fd
)
;
if
(
data
=
=
MAP_FAILED
)
{
return
false
;
}
pData
-
>
map
=
(
char
*
)
data
+
length
;
pData
-
>
pHeader
=
(
const
DataHeader
*
)
data
;
pData
-
>
mapAddr
=
data
;
return
true
;
}
#
ifdef
OS390BATCH
uprv_strcpy
(
pathBuffer
"
IXMI
"
U_ICU_VERSION_SHORT
"
DA
"
)
;
#
else
uprv_strcpy
(
basename
LIB_PREFIX
U_LIBICUDATA_NAME
U_ICU_VERSION_SHORT
LIB_SUFFIX
)
;
#
endif
#
ifdef
UDATA_DEBUG
fprintf
(
stderr
"
dllload
:
%
s
"
pathBuffer
)
;
#
endif
handle
=
dllload
(
pathBuffer
)
;
#
ifdef
UDATA_DEBUG
fprintf
(
stderr
"
-
>
%
08X
\
n
"
handle
)
;
#
endif
if
(
handle
!
=
nullptr
)
{
UDataMemory_init
(
pData
)
;
val
=
dllqueryvar
(
(
dllhandle
*
)
handle
U_ICUDATA_ENTRY_NAME
)
;
if
(
val
=
=
0
)
{
return
false
;
}
#
ifdef
UDATA_DEBUG
fprintf
(
stderr
"
dllqueryvar
(
%
08X
%
s
)
-
>
%
08X
\
n
"
handle
U_ICUDATA_ENTRY_NAME
val
)
;
#
endif
pData
-
>
pHeader
=
(
const
DataHeader
*
)
val
;
return
true
;
}
else
{
return
false
;
}
}
U_CFUNC
void
uprv_unmapFile
(
UDataMemory
*
pData
)
{
if
(
pData
!
=
nullptr
&
&
pData
-
>
map
!
=
nullptr
)
{
uprv_free
(
pData
-
>
map
)
;
pData
-
>
map
=
nullptr
;
pData
-
>
mapAddr
=
nullptr
;
pData
-
>
pHeader
=
nullptr
;
}
}
#
else
#
error
MAP_IMPLEMENTATION
is
set
incorrectly
#
endif
