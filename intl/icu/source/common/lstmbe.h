#
ifndef
LSTMBE_H
#
define
LSTMBE_H
#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_BREAK_ITERATION
#
include
"
unicode
/
uniset
.
h
"
#
include
"
unicode
/
ures
.
h
"
#
include
"
unicode
/
utext
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
include
"
brkeng
.
h
"
#
include
"
dictbe
.
h
"
#
include
"
uvectr32
.
h
"
U_NAMESPACE_BEGIN
class
Vectorizer
;
struct
LSTMData
;
class
LSTMBreakEngine
:
public
DictionaryBreakEngine
{
public
:
LSTMBreakEngine
(
const
LSTMData
*
data
const
UnicodeSet
&
set
UErrorCode
&
status
)
;
virtual
~
LSTMBreakEngine
(
)
;
virtual
const
char16_t
*
name
(
)
const
;
protected
:
virtual
int32_t
divideUpDictionaryRange
(
UText
*
text
int32_t
rangeStart
int32_t
rangeEnd
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
override
;
private
:
const
LSTMData
*
fData
;
const
Vectorizer
*
fVectorizer
;
}
;
U_CAPI
const
LanguageBreakEngine
*
U_EXPORT2
CreateLSTMBreakEngine
(
UScriptCode
script
const
LSTMData
*
data
UErrorCode
&
status
)
;
U_CAPI
const
LSTMData
*
U_EXPORT2
CreateLSTMData
(
UResourceBundle
*
rb
UErrorCode
&
status
)
;
U_CAPI
const
LSTMData
*
U_EXPORT2
CreateLSTMDataForScript
(
UScriptCode
script
UErrorCode
&
status
)
;
U_CAPI
void
U_EXPORT2
DeleteLSTMData
(
const
LSTMData
*
data
)
;
U_CAPI
const
char16_t
*
U_EXPORT2
LSTMDataName
(
const
LSTMData
*
data
)
;
U_NAMESPACE_END
#
endif
#
endif
