#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_NORMALIZATION
#
include
"
unicode
/
bytestream
.
h
"
#
include
"
unicode
/
edits
.
h
"
#
include
"
unicode
/
normalizer2
.
h
"
#
include
"
unicode
/
stringoptions
.
h
"
#
include
"
unicode
/
ucptrie
.
h
"
#
include
"
unicode
/
udata
.
h
"
#
include
"
unicode
/
umutablecptrie
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
unicode
/
utf16
.
h
"
#
include
"
unicode
/
utf8
.
h
"
#
include
"
bytesinkutil
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
mutex
.
h
"
#
include
"
normalizer2impl
.
h
"
#
include
"
putilimp
.
h
"
#
include
"
uassert
.
h
"
#
include
"
ucptrie_impl
.
h
"
#
include
"
uset_imp
.
h
"
#
include
"
uvector
.
h
"
U_NAMESPACE_BEGIN
namespace
{
inline
uint8_t
leadByteForCP
(
UChar32
c
)
{
if
(
c
<
=
0x7f
)
{
return
(
uint8_t
)
c
;
}
else
if
(
c
<
=
0x7ff
)
{
return
(
uint8_t
)
(
0xc0
+
(
c
>
>
6
)
)
;
}
else
{
return
0xe0
;
}
}
UChar32
codePointFromValidUTF8
(
const
uint8_t
*
cpStart
const
uint8_t
*
cpLimit
)
{
U_ASSERT
(
cpStart
<
cpLimit
)
;
uint8_t
c
=
*
cpStart
;
switch
(
cpLimit
-
cpStart
)
{
case
1
:
return
c
;
case
2
:
return
(
(
c
&
0x1f
)
<
<
6
)
|
(
cpStart
[
1
]
&
0x3f
)
;
case
3
:
return
(
char16_t
)
(
(
c
<
<
12
)
|
(
(
cpStart
[
1
]
&
0x3f
)
<
<
6
)
|
(
cpStart
[
2
]
&
0x3f
)
)
;
case
4
:
return
(
(
c
&
7
)
<
<
18
)
|
(
(
cpStart
[
1
]
&
0x3f
)
<
<
12
)
|
(
(
cpStart
[
2
]
&
0x3f
)
<
<
6
)
|
(
cpStart
[
3
]
&
0x3f
)
;
default
:
UPRV_UNREACHABLE_EXIT
;
}
}
UChar32
previousHangulOrJamo
(
const
uint8_t
*
start
const
uint8_t
*
p
)
{
if
(
(
p
-
start
)
>
=
3
)
{
p
-
=
3
;
uint8_t
l
=
*
p
;
uint8_t
t1
t2
;
if
(
0xe1
<
=
l
&
&
l
<
=
0xed
&
&
(
t1
=
(
uint8_t
)
(
p
[
1
]
-
0x80
)
)
<
=
0x3f
&
&
(
t2
=
(
uint8_t
)
(
p
[
2
]
-
0x80
)
)
<
=
0x3f
&
&
(
l
<
0xed
|
|
t1
<
=
0x1f
)
)
{
return
(
(
l
&
0xf
)
<
<
12
)
|
(
t1
<
<
6
)
|
t2
;
}
}
return
U_SENTINEL
;
}
int32_t
getJamoTMinusBase
(
const
uint8_t
*
src
const
uint8_t
*
limit
)
{
if
(
(
limit
-
src
)
>
=
3
&
&
*
src
=
=
0xe1
)
{
if
(
src
[
1
]
=
=
0x86
)
{
uint8_t
t
=
src
[
2
]
;
if
(
0xa8
<
=
t
&
&
t
<
=
0xbf
)
{
return
t
-
0xa7
;
}
}
else
if
(
src
[
1
]
=
=
0x87
)
{
uint8_t
t
=
src
[
2
]
;
if
(
(
int8_t
)
t
<
=
(
int8_t
)
0x82u
)
{
return
t
-
(
0xa7
-
0x40
)
;
}
}
}
return
-
1
;
}
void
appendCodePointDelta
(
const
uint8_t
*
cpStart
const
uint8_t
*
cpLimit
int32_t
delta
ByteSink
&
sink
Edits
*
edits
)
{
char
buffer
[
U8_MAX_LENGTH
]
;
int32_t
length
;
int32_t
cpLength
=
(
int32_t
)
(
cpLimit
-
cpStart
)
;
if
(
cpLength
=
=
1
)
{
buffer
[
0
]
=
(
uint8_t
)
(
*
cpStart
+
delta
)
;
length
=
1
;
}
else
{
int32_t
trail
=
*
(
cpLimit
-
1
)
+
delta
;
if
(
0x80
<
=
trail
&
&
trail
<
=
0xbf
)
{
-
-
cpLimit
;
length
=
0
;
do
{
buffer
[
length
+
+
]
=
*
cpStart
+
+
;
}
while
(
cpStart
<
cpLimit
)
;
buffer
[
length
+
+
]
=
(
uint8_t
)
trail
;
}
else
{
UChar32
c
=
codePointFromValidUTF8
(
cpStart
cpLimit
)
+
delta
;
length
=
0
;
U8_APPEND_UNSAFE
(
buffer
length
c
)
;
}
}
if
(
edits
!
=
nullptr
)
{
edits
-
>
addReplace
(
cpLength
length
)
;
}
sink
.
Append
(
buffer
length
)
;
}
}
ReorderingBuffer
:
:
ReorderingBuffer
(
const
Normalizer2Impl
&
ni
UnicodeString
&
dest
UErrorCode
&
errorCode
)
:
impl
(
ni
)
str
(
dest
)
start
(
str
.
getBuffer
(
8
)
)
reorderStart
(
start
)
limit
(
start
)
remainingCapacity
(
str
.
getCapacity
(
)
)
lastCC
(
0
)
{
if
(
start
=
=
nullptr
&
&
U_SUCCESS
(
errorCode
)
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
}
}
UBool
ReorderingBuffer
:
:
init
(
int32_t
destCapacity
UErrorCode
&
errorCode
)
{
int32_t
length
=
str
.
length
(
)
;
start
=
str
.
getBuffer
(
destCapacity
)
;
if
(
start
=
=
nullptr
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
return
false
;
}
limit
=
start
+
length
;
remainingCapacity
=
str
.
getCapacity
(
)
-
length
;
reorderStart
=
start
;
if
(
start
=
=
limit
)
{
lastCC
=
0
;
}
else
{
setIterator
(
)
;
lastCC
=
previousCC
(
)
;
if
(
lastCC
>
1
)
{
while
(
previousCC
(
)
>
1
)
{
}
}
reorderStart
=
codePointLimit
;
}
return
true
;
}
UBool
ReorderingBuffer
:
:
equals
(
const
char16_t
*
otherStart
const
char16_t
*
otherLimit
)
const
{
int32_t
length
=
(
int32_t
)
(
limit
-
start
)
;
return
length
=
=
(
int32_t
)
(
otherLimit
-
otherStart
)
&
&
0
=
=
u_memcmp
(
start
otherStart
length
)
;
}
UBool
ReorderingBuffer
:
:
equals
(
const
uint8_t
*
otherStart
const
uint8_t
*
otherLimit
)
const
{
U_ASSERT
(
(
otherLimit
-
otherStart
)
<
=
INT32_MAX
)
;
int32_t
length
=
(
int32_t
)
(
limit
-
start
)
;
int32_t
otherLength
=
(
int32_t
)
(
otherLimit
-
otherStart
)
;
if
(
otherLength
<
length
|
|
(
otherLength
/
3
)
>
length
)
{
return
false
;
}
for
(
int32_t
i
=
0
j
=
0
;
;
)
{
if
(
i
>
=
length
)
{
return
j
>
=
otherLength
;
}
else
if
(
j
>
=
otherLength
)
{
return
false
;
}
UChar32
c
other
;
U16_NEXT_UNSAFE
(
start
i
c
)
;
U8_NEXT_UNSAFE
(
otherStart
j
other
)
;
if
(
c
!
=
other
)
{
return
false
;
}
}
}
UBool
ReorderingBuffer
:
:
appendSupplementary
(
UChar32
c
uint8_t
cc
UErrorCode
&
errorCode
)
{
if
(
remainingCapacity
<
2
&
&
!
resize
(
2
errorCode
)
)
{
return
false
;
}
if
(
lastCC
<
=
cc
|
|
cc
=
=
0
)
{
limit
[
0
]
=
U16_LEAD
(
c
)
;
limit
[
1
]
=
U16_TRAIL
(
c
)
;
limit
+
=
2
;
lastCC
=
cc
;
if
(
cc
<
=
1
)
{
reorderStart
=
limit
;
}
}
else
{
insert
(
c
cc
)
;
}
remainingCapacity
-
=
2
;
return
true
;
}
UBool
ReorderingBuffer
:
:
append
(
const
char16_t
*
s
int32_t
length
UBool
isNFD
uint8_t
leadCC
uint8_t
trailCC
UErrorCode
&
errorCode
)
{
if
(
length
=
=
0
)
{
return
true
;
}
if
(
remainingCapacity
<
length
&
&
!
resize
(
length
errorCode
)
)
{
return
false
;
}
remainingCapacity
-
=
length
;
if
(
lastCC
<
=
leadCC
|
|
leadCC
=
=
0
)
{
if
(
trailCC
<
=
1
)
{
reorderStart
=
limit
+
length
;
}
else
if
(
leadCC
<
=
1
)
{
reorderStart
=
limit
+
1
;
}
const
char16_t
*
sLimit
=
s
+
length
;
do
{
*
limit
+
+
=
*
s
+
+
;
}
while
(
s
!
=
sLimit
)
;
lastCC
=
trailCC
;
}
else
{
int32_t
i
=
0
;
UChar32
c
;
U16_NEXT
(
s
i
length
c
)
;
insert
(
c
leadCC
)
;
while
(
i
<
length
)
{
U16_NEXT
(
s
i
length
c
)
;
if
(
i
<
length
)
{
if
(
isNFD
)
{
leadCC
=
Normalizer2Impl
:
:
getCCFromYesOrMaybe
(
impl
.
getRawNorm16
(
c
)
)
;
}
else
{
leadCC
=
impl
.
getCC
(
impl
.
getNorm16
(
c
)
)
;
}
}
else
{
leadCC
=
trailCC
;
}
append
(
c
leadCC
errorCode
)
;
}
}
return
true
;
}
UBool
ReorderingBuffer
:
:
appendZeroCC
(
UChar32
c
UErrorCode
&
errorCode
)
{
int32_t
cpLength
=
U16_LENGTH
(
c
)
;
if
(
remainingCapacity
<
cpLength
&
&
!
resize
(
cpLength
errorCode
)
)
{
return
false
;
}
remainingCapacity
-
=
cpLength
;
if
(
cpLength
=
=
1
)
{
*
limit
+
+
=
(
char16_t
)
c
;
}
else
{
limit
[
0
]
=
U16_LEAD
(
c
)
;
limit
[
1
]
=
U16_TRAIL
(
c
)
;
limit
+
=
2
;
}
lastCC
=
0
;
reorderStart
=
limit
;
return
true
;
}
UBool
ReorderingBuffer
:
:
appendZeroCC
(
const
char16_t
*
s
const
char16_t
*
sLimit
UErrorCode
&
errorCode
)
{
if
(
s
=
=
sLimit
)
{
return
true
;
}
int32_t
length
=
(
int32_t
)
(
sLimit
-
s
)
;
if
(
remainingCapacity
<
length
&
&
!
resize
(
length
errorCode
)
)
{
return
false
;
}
u_memcpy
(
limit
s
length
)
;
limit
+
=
length
;
remainingCapacity
-
=
length
;
lastCC
=
0
;
reorderStart
=
limit
;
return
true
;
}
void
ReorderingBuffer
:
:
remove
(
)
{
reorderStart
=
limit
=
start
;
remainingCapacity
=
str
.
getCapacity
(
)
;
lastCC
=
0
;
}
void
ReorderingBuffer
:
:
removeSuffix
(
int32_t
suffixLength
)
{
if
(
suffixLength
<
(
limit
-
start
)
)
{
limit
-
=
suffixLength
;
remainingCapacity
+
=
suffixLength
;
}
else
{
limit
=
start
;
remainingCapacity
=
str
.
getCapacity
(
)
;
}
lastCC
=
0
;
reorderStart
=
limit
;
}
UBool
ReorderingBuffer
:
:
resize
(
int32_t
appendLength
UErrorCode
&
errorCode
)
{
int32_t
reorderStartIndex
=
(
int32_t
)
(
reorderStart
-
start
)
;
int32_t
length
=
(
int32_t
)
(
limit
-
start
)
;
str
.
releaseBuffer
(
length
)
;
int32_t
newCapacity
=
length
+
appendLength
;
int32_t
doubleCapacity
=
2
*
str
.
getCapacity
(
)
;
if
(
newCapacity
<
doubleCapacity
)
{
newCapacity
=
doubleCapacity
;
}
if
(
newCapacity
<
256
)
{
newCapacity
=
256
;
}
start
=
str
.
getBuffer
(
newCapacity
)
;
if
(
start
=
=
nullptr
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
return
false
;
}
reorderStart
=
start
+
reorderStartIndex
;
limit
=
start
+
length
;
remainingCapacity
=
str
.
getCapacity
(
)
-
length
;
return
true
;
}
void
ReorderingBuffer
:
:
skipPrevious
(
)
{
codePointLimit
=
codePointStart
;
char16_t
c
=
*
-
-
codePointStart
;
if
(
U16_IS_TRAIL
(
c
)
&
&
start
<
codePointStart
&
&
U16_IS_LEAD
(
*
(
codePointStart
-
1
)
)
)
{
-
-
codePointStart
;
}
}
uint8_t
ReorderingBuffer
:
:
previousCC
(
)
{
codePointLimit
=
codePointStart
;
if
(
reorderStart
>
=
codePointStart
)
{
return
0
;
}
UChar32
c
=
*
-
-
codePointStart
;
char16_t
c2
;
if
(
U16_IS_TRAIL
(
c
)
&
&
start
<
codePointStart
&
&
U16_IS_LEAD
(
c2
=
*
(
codePointStart
-
1
)
)
)
{
-
-
codePointStart
;
c
=
U16_GET_SUPPLEMENTARY
(
c2
c
)
;
}
return
impl
.
getCCFromYesOrMaybeCP
(
c
)
;
}
void
ReorderingBuffer
:
:
insert
(
UChar32
c
uint8_t
cc
)
{
for
(
setIterator
(
)
skipPrevious
(
)
;
previousCC
(
)
>
cc
;
)
{
}
char16_t
*
q
=
limit
;
char16_t
*
r
=
limit
+
=
U16_LENGTH
(
c
)
;
do
{
*
-
-
r
=
*
-
-
q
;
}
while
(
codePointLimit
!
=
q
)
;
writeCodePoint
(
q
c
)
;
if
(
cc
<
=
1
)
{
reorderStart
=
r
;
}
}
struct
CanonIterData
:
public
UMemory
{
CanonIterData
(
UErrorCode
&
errorCode
)
;
~
CanonIterData
(
)
;
void
addToStartSet
(
UChar32
origin
UChar32
decompLead
UErrorCode
&
errorCode
)
;
UMutableCPTrie
*
mutableTrie
;
UCPTrie
*
trie
;
UVector
canonStartSets
;
}
;
Normalizer2Impl
:
:
~
Normalizer2Impl
(
)
{
delete
fCanonIterData
;
}
void
Normalizer2Impl
:
:
init
(
const
int32_t
*
inIndexes
const
UCPTrie
*
inTrie
const
uint16_t
*
inExtraData
const
uint8_t
*
inSmallFCD
)
{
minDecompNoCP
=
static_cast
<
char16_t
>
(
inIndexes
[
IX_MIN_DECOMP_NO_CP
]
)
;
minCompNoMaybeCP
=
static_cast
<
char16_t
>
(
inIndexes
[
IX_MIN_COMP_NO_MAYBE_CP
]
)
;
minLcccCP
=
static_cast
<
char16_t
>
(
inIndexes
[
IX_MIN_LCCC_CP
]
)
;
minYesNo
=
static_cast
<
uint16_t
>
(
inIndexes
[
IX_MIN_YES_NO
]
)
;
minYesNoMappingsOnly
=
static_cast
<
uint16_t
>
(
inIndexes
[
IX_MIN_YES_NO_MAPPINGS_ONLY
]
)
;
minNoNo
=
static_cast
<
uint16_t
>
(
inIndexes
[
IX_MIN_NO_NO
]
)
;
minNoNoCompBoundaryBefore
=
static_cast
<
uint16_t
>
(
inIndexes
[
IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE
]
)
;
minNoNoCompNoMaybeCC
=
static_cast
<
uint16_t
>
(
inIndexes
[
IX_MIN_NO_NO_COMP_NO_MAYBE_CC
]
)
;
minNoNoEmpty
=
static_cast
<
uint16_t
>
(
inIndexes
[
IX_MIN_NO_NO_EMPTY
]
)
;
limitNoNo
=
static_cast
<
uint16_t
>
(
inIndexes
[
IX_LIMIT_NO_NO
]
)
;
minMaybeYes
=
static_cast
<
uint16_t
>
(
inIndexes
[
IX_MIN_MAYBE_YES
]
)
;
U_ASSERT
(
(
minMaybeYes
&
7
)
=
=
0
)
;
centerNoNoDelta
=
(
minMaybeYes
>
>
DELTA_SHIFT
)
-
MAX_DELTA
-
1
;
normTrie
=
inTrie
;
maybeYesCompositions
=
inExtraData
;
extraData
=
maybeYesCompositions
+
(
(
MIN_NORMAL_MAYBE_YES
-
minMaybeYes
)
>
>
OFFSET_SHIFT
)
;
smallFCD
=
inSmallFCD
;
}
U_CDECL_BEGIN
static
uint32_t
U_CALLCONV
segmentStarterMapper
(
const
void
*
uint32_t
value
)
{
return
value
&
CANON_NOT_SEGMENT_STARTER
;
}
U_CDECL_END
void
Normalizer2Impl
:
:
addLcccChars
(
UnicodeSet
&
set
)
const
{
UChar32
start
=
0
end
;
uint32_t
norm16
;
while
(
(
end
=
ucptrie_getRange
(
normTrie
start
UCPMAP_RANGE_FIXED_LEAD_SURROGATES
INERT
nullptr
nullptr
&
norm16
)
)
>
=
0
)
{
if
(
norm16
>
Normalizer2Impl
:
:
MIN_NORMAL_MAYBE_YES
&
&
norm16
!
=
Normalizer2Impl
:
:
JAMO_VT
)
{
set
.
add
(
start
end
)
;
}
else
if
(
minNoNoCompNoMaybeCC
<
=
norm16
&
&
norm16
<
limitNoNo
)
{
uint16_t
fcd16
=
getFCD16
(
start
)
;
if
(
fcd16
>
0xff
)
{
set
.
add
(
start
end
)
;
}
}
start
=
end
+
1
;
}
}
void
Normalizer2Impl
:
:
addPropertyStarts
(
const
USetAdder
*
sa
UErrorCode
&
)
const
{
UChar32
start
=
0
end
;
uint32_t
value
;
while
(
(
end
=
ucptrie_getRange
(
normTrie
start
UCPMAP_RANGE_FIXED_LEAD_SURROGATES
INERT
nullptr
nullptr
&
value
)
)
>
=
0
)
{
sa
-
>
add
(
sa
-
>
set
start
)
;
if
(
start
!
=
end
&
&
isAlgorithmicNoNo
(
(
uint16_t
)
value
)
&
&
(
value
&
Normalizer2Impl
:
:
DELTA_TCCC_MASK
)
>
Normalizer2Impl
:
:
DELTA_TCCC_1
)
{
uint16_t
prevFCD16
=
getFCD16
(
start
)
;
while
(
+
+
start
<
=
end
)
{
uint16_t
fcd16
=
getFCD16
(
start
)
;
if
(
fcd16
!
=
prevFCD16
)
{
sa
-
>
add
(
sa
-
>
set
start
)
;
prevFCD16
=
fcd16
;
}
}
}
start
=
end
+
1
;
}
for
(
char16_t
c
=
Hangul
:
:
HANGUL_BASE
;
c
<
Hangul
:
:
HANGUL_LIMIT
;
c
+
=
Hangul
:
:
JAMO_T_COUNT
)
{
sa
-
>
add
(
sa
-
>
set
c
)
;
sa
-
>
add
(
sa
-
>
set
c
+
1
)
;
}
sa
-
>
add
(
sa
-
>
set
Hangul
:
:
HANGUL_LIMIT
)
;
}
void
Normalizer2Impl
:
:
addCanonIterPropertyStarts
(
const
USetAdder
*
sa
UErrorCode
&
errorCode
)
const
{
if
(
!
ensureCanonIterData
(
errorCode
)
)
{
return
;
}
UChar32
start
=
0
end
;
uint32_t
value
;
while
(
(
end
=
ucptrie_getRange
(
fCanonIterData
-
>
trie
start
UCPMAP_RANGE_NORMAL
0
segmentStarterMapper
nullptr
&
value
)
)
>
=
0
)
{
sa
-
>
add
(
sa
-
>
set
start
)
;
start
=
end
+
1
;
}
}
const
char16_t
*
Normalizer2Impl
:
:
copyLowPrefixFromNulTerminated
(
const
char16_t
*
src
UChar32
minNeedDataCP
ReorderingBuffer
*
buffer
UErrorCode
&
errorCode
)
const
{
const
char16_t
*
prevSrc
=
src
;
char16_t
c
;
while
(
(
c
=
*
src
+
+
)
<
minNeedDataCP
&
&
c
!
=
0
)
{
}
if
(
-
-
src
!
=
prevSrc
)
{
if
(
buffer
!
=
nullptr
)
{
buffer
-
>
appendZeroCC
(
prevSrc
src
errorCode
)
;
}
}
return
src
;
}
UnicodeString
&
Normalizer2Impl
:
:
decompose
(
const
UnicodeString
&
src
UnicodeString
&
dest
UErrorCode
&
errorCode
)
const
{
if
(
U_FAILURE
(
errorCode
)
)
{
dest
.
setToBogus
(
)
;
return
dest
;
}
const
char16_t
*
sArray
=
src
.
getBuffer
(
)
;
if
(
&
dest
=
=
&
src
|
|
sArray
=
=
nullptr
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
dest
.
setToBogus
(
)
;
return
dest
;
}
decompose
(
sArray
sArray
+
src
.
length
(
)
dest
src
.
length
(
)
errorCode
)
;
return
dest
;
}
void
Normalizer2Impl
:
:
decompose
(
const
char16_t
*
src
const
char16_t
*
limit
UnicodeString
&
dest
int32_t
destLengthEstimate
UErrorCode
&
errorCode
)
const
{
if
(
destLengthEstimate
<
0
&
&
limit
!
=
nullptr
)
{
destLengthEstimate
=
(
int32_t
)
(
limit
-
src
)
;
}
dest
.
remove
(
)
;
ReorderingBuffer
buffer
(
*
this
dest
)
;
if
(
buffer
.
init
(
destLengthEstimate
errorCode
)
)
{
decompose
(
src
limit
&
buffer
errorCode
)
;
}
}
const
char16_t
*
Normalizer2Impl
:
:
decompose
(
const
char16_t
*
src
const
char16_t
*
limit
ReorderingBuffer
*
buffer
UErrorCode
&
errorCode
)
const
{
UChar32
minNoCP
=
minDecompNoCP
;
if
(
limit
=
=
nullptr
)
{
src
=
copyLowPrefixFromNulTerminated
(
src
minNoCP
buffer
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
src
;
}
limit
=
u_strchr
(
src
0
)
;
}
const
char16_t
*
prevSrc
;
UChar32
c
=
0
;
uint16_t
norm16
=
0
;
const
char16_t
*
prevBoundary
=
src
;
uint8_t
prevCC
=
0
;
for
(
;
;
)
{
for
(
prevSrc
=
src
;
src
!
=
limit
;
)
{
if
(
(
c
=
*
src
)
<
minNoCP
|
|
isMostDecompYesAndZeroCC
(
norm16
=
UCPTRIE_FAST_BMP_GET
(
normTrie
UCPTRIE_16
c
)
)
)
{
+
+
src
;
}
else
if
(
!
U16_IS_LEAD
(
c
)
)
{
break
;
}
else
{
char16_t
c2
;
if
(
(
src
+
1
)
!
=
limit
&
&
U16_IS_TRAIL
(
c2
=
src
[
1
]
)
)
{
c
=
U16_GET_SUPPLEMENTARY
(
c
c2
)
;
norm16
=
UCPTRIE_FAST_SUPP_GET
(
normTrie
UCPTRIE_16
c
)
;
if
(
isMostDecompYesAndZeroCC
(
norm16
)
)
{
src
+
=
2
;
}
else
{
break
;
}
}
else
{
+
+
src
;
}
}
}
if
(
src
!
=
prevSrc
)
{
if
(
buffer
!
=
nullptr
)
{
if
(
!
buffer
-
>
appendZeroCC
(
prevSrc
src
errorCode
)
)
{
break
;
}
}
else
{
prevCC
=
0
;
prevBoundary
=
src
;
}
}
if
(
src
=
=
limit
)
{
break
;
}
src
+
=
U16_LENGTH
(
c
)
;
if
(
buffer
!
=
nullptr
)
{
if
(
!
decompose
(
c
norm16
*
buffer
errorCode
)
)
{
break
;
}
}
else
{
if
(
isDecompYes
(
norm16
)
)
{
uint8_t
cc
=
getCCFromYesOrMaybe
(
norm16
)
;
if
(
prevCC
<
=
cc
|
|
cc
=
=
0
)
{
prevCC
=
cc
;
if
(
cc
<
=
1
)
{
prevBoundary
=
src
;
}
continue
;
}
}
return
prevBoundary
;
}
}
return
src
;
}
const
char16_t
*
Normalizer2Impl
:
:
decomposeShort
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
stopAtCompBoundary
UBool
onlyContiguous
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
nullptr
;
}
while
(
src
<
limit
)
{
if
(
stopAtCompBoundary
&
&
*
src
<
minCompNoMaybeCP
)
{
return
src
;
}
const
char16_t
*
prevSrc
=
src
;
UChar32
c
;
uint16_t
norm16
;
UCPTRIE_FAST_U16_NEXT
(
normTrie
UCPTRIE_16
src
limit
c
norm16
)
;
if
(
stopAtCompBoundary
&
&
norm16HasCompBoundaryBefore
(
norm16
)
)
{
return
prevSrc
;
}
if
(
!
decompose
(
c
norm16
buffer
errorCode
)
)
{
return
nullptr
;
}
if
(
stopAtCompBoundary
&
&
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
)
{
return
src
;
}
}
return
src
;
}
UBool
Normalizer2Impl
:
:
decompose
(
UChar32
c
uint16_t
norm16
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
{
if
(
norm16
>
=
limitNoNo
)
{
if
(
isMaybeOrNonZeroCC
(
norm16
)
)
{
return
buffer
.
append
(
c
getCCFromYesOrMaybe
(
norm16
)
errorCode
)
;
}
c
=
mapAlgorithmic
(
c
norm16
)
;
norm16
=
getRawNorm16
(
c
)
;
}
if
(
norm16
<
minYesNo
)
{
return
buffer
.
append
(
c
0
errorCode
)
;
}
else
if
(
isHangulLV
(
norm16
)
|
|
isHangulLVT
(
norm16
)
)
{
char16_t
jamos
[
3
]
;
return
buffer
.
appendZeroCC
(
jamos
jamos
+
Hangul
:
:
decompose
(
c
jamos
)
errorCode
)
;
}
const
uint16_t
*
mapping
=
getMapping
(
norm16
)
;
uint16_t
firstUnit
=
*
mapping
;
int32_t
length
=
firstUnit
&
MAPPING_LENGTH_MASK
;
uint8_t
leadCC
trailCC
;
trailCC
=
(
uint8_t
)
(
firstUnit
>
>
8
)
;
if
(
firstUnit
&
MAPPING_HAS_CCC_LCCC_WORD
)
{
leadCC
=
(
uint8_t
)
(
*
(
mapping
-
1
)
>
>
8
)
;
}
else
{
leadCC
=
0
;
}
return
buffer
.
append
(
(
const
char16_t
*
)
mapping
+
1
length
true
leadCC
trailCC
errorCode
)
;
}
const
uint8_t
*
Normalizer2Impl
:
:
decomposeUTF8
(
uint32_t
options
const
uint8_t
*
src
const
uint8_t
*
limit
ByteSink
*
sink
Edits
*
edits
UErrorCode
&
errorCode
)
const
{
U_ASSERT
(
limit
!
=
nullptr
)
;
UnicodeString
s16
;
uint8_t
minNoLead
=
leadByteForCP
(
minDecompNoCP
)
;
const
uint8_t
*
prevBoundary
=
src
;
uint8_t
prevCC
=
0
;
for
(
;
;
)
{
const
uint8_t
*
fastStart
=
src
;
const
uint8_t
*
prevSrc
;
uint16_t
norm16
=
0
;
for
(
;
;
)
{
if
(
src
=
=
limit
)
{
if
(
prevBoundary
!
=
limit
&
&
sink
!
=
nullptr
)
{
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
limit
*
sink
options
edits
errorCode
)
;
}
return
src
;
}
if
(
*
src
<
minNoLead
)
{
+
+
src
;
}
else
{
prevSrc
=
src
;
UCPTRIE_FAST_U8_NEXT
(
normTrie
UCPTRIE_16
src
limit
norm16
)
;
if
(
!
isMostDecompYesAndZeroCC
(
norm16
)
)
{
break
;
}
}
}
if
(
prevSrc
!
=
fastStart
)
{
if
(
sink
!
=
nullptr
&
&
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
prevSrc
*
sink
options
edits
errorCode
)
)
{
break
;
}
prevBoundary
=
prevSrc
;
prevCC
=
0
;
}
if
(
isMaybeOrNonZeroCC
(
norm16
)
)
{
uint8_t
cc
=
getCCFromYesOrMaybe
(
norm16
)
;
if
(
prevCC
<
=
cc
|
|
cc
=
=
0
)
{
prevCC
=
cc
;
if
(
cc
<
=
1
)
{
if
(
sink
!
=
nullptr
&
&
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
src
*
sink
options
edits
errorCode
)
)
{
break
;
}
prevBoundary
=
src
;
}
continue
;
}
}
if
(
sink
=
=
nullptr
)
{
return
prevBoundary
;
}
if
(
prevBoundary
!
=
prevSrc
&
&
norm16HasDecompBoundaryBefore
(
norm16
)
)
{
if
(
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
prevSrc
*
sink
options
edits
errorCode
)
)
{
break
;
}
prevBoundary
=
prevSrc
;
}
ReorderingBuffer
buffer
(
*
this
s16
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
break
;
}
decomposeShort
(
prevBoundary
src
STOP_AT_LIMIT
false
buffer
errorCode
)
;
if
(
buffer
.
getLastCC
(
)
>
1
)
{
src
=
decomposeShort
(
src
limit
STOP_AT_DECOMP_BOUNDARY
false
buffer
errorCode
)
;
}
if
(
U_FAILURE
(
errorCode
)
)
{
break
;
}
if
(
(
src
-
prevSrc
)
>
INT32_MAX
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
break
;
}
if
(
isMaybeOrNonZeroCC
(
norm16
)
&
&
buffer
.
equals
(
prevBoundary
src
)
)
{
if
(
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
src
*
sink
options
edits
errorCode
)
)
{
break
;
}
}
else
{
if
(
!
ByteSinkUtil
:
:
appendChange
(
prevBoundary
src
buffer
.
getStart
(
)
buffer
.
length
(
)
*
sink
edits
errorCode
)
)
{
break
;
}
}
prevBoundary
=
src
;
prevCC
=
0
;
}
return
src
;
}
const
uint8_t
*
Normalizer2Impl
:
:
decomposeShort
(
const
uint8_t
*
src
const
uint8_t
*
limit
StopAt
stopAt
UBool
onlyContiguous
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
nullptr
;
}
while
(
src
<
limit
)
{
const
uint8_t
*
prevSrc
=
src
;
uint16_t
norm16
;
UCPTRIE_FAST_U8_NEXT
(
normTrie
UCPTRIE_16
src
limit
norm16
)
;
UChar32
c
=
U_SENTINEL
;
if
(
norm16
>
=
limitNoNo
)
{
if
(
isMaybeOrNonZeroCC
(
norm16
)
)
{
uint8_t
cc
=
getCCFromYesOrMaybe
(
norm16
)
;
if
(
cc
=
=
0
&
&
stopAt
=
=
STOP_AT_DECOMP_BOUNDARY
)
{
return
prevSrc
;
}
c
=
codePointFromValidUTF8
(
prevSrc
src
)
;
if
(
!
buffer
.
append
(
c
cc
errorCode
)
)
{
return
nullptr
;
}
if
(
stopAt
=
=
STOP_AT_DECOMP_BOUNDARY
&
&
buffer
.
getLastCC
(
)
<
=
1
)
{
return
src
;
}
continue
;
}
if
(
stopAt
!
=
STOP_AT_LIMIT
)
{
return
prevSrc
;
}
c
=
codePointFromValidUTF8
(
prevSrc
src
)
;
c
=
mapAlgorithmic
(
c
norm16
)
;
norm16
=
getRawNorm16
(
c
)
;
}
else
if
(
stopAt
!
=
STOP_AT_LIMIT
&
&
norm16
<
minNoNoCompNoMaybeCC
)
{
return
prevSrc
;
}
U_ASSERT
(
c
>
=
0
|
|
norm16
!
=
INERT
)
;
if
(
norm16
<
minYesNo
)
{
if
(
c
<
0
)
{
c
=
codePointFromValidUTF8
(
prevSrc
src
)
;
}
if
(
!
buffer
.
append
(
c
0
errorCode
)
)
{
return
nullptr
;
}
}
else
if
(
isHangulLV
(
norm16
)
|
|
isHangulLVT
(
norm16
)
)
{
if
(
c
<
0
)
{
c
=
codePointFromValidUTF8
(
prevSrc
src
)
;
}
char16_t
jamos
[
3
]
;
if
(
!
buffer
.
appendZeroCC
(
jamos
jamos
+
Hangul
:
:
decompose
(
c
jamos
)
errorCode
)
)
{
return
nullptr
;
}
}
else
{
const
uint16_t
*
mapping
=
getMapping
(
norm16
)
;
uint16_t
firstUnit
=
*
mapping
;
int32_t
length
=
firstUnit
&
MAPPING_LENGTH_MASK
;
uint8_t
trailCC
=
(
uint8_t
)
(
firstUnit
>
>
8
)
;
uint8_t
leadCC
;
if
(
firstUnit
&
MAPPING_HAS_CCC_LCCC_WORD
)
{
leadCC
=
(
uint8_t
)
(
*
(
mapping
-
1
)
>
>
8
)
;
}
else
{
leadCC
=
0
;
}
if
(
leadCC
=
=
0
&
&
stopAt
=
=
STOP_AT_DECOMP_BOUNDARY
)
{
return
prevSrc
;
}
if
(
!
buffer
.
append
(
(
const
char16_t
*
)
mapping
+
1
length
true
leadCC
trailCC
errorCode
)
)
{
return
nullptr
;
}
}
if
(
(
stopAt
=
=
STOP_AT_COMP_BOUNDARY
&
&
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
)
|
|
(
stopAt
=
=
STOP_AT_DECOMP_BOUNDARY
&
&
buffer
.
getLastCC
(
)
<
=
1
)
)
{
return
src
;
}
}
return
src
;
}
const
char16_t
*
Normalizer2Impl
:
:
getDecomposition
(
UChar32
c
char16_t
buffer
[
4
]
int32_t
&
length
)
const
{
uint16_t
norm16
;
if
(
c
<
minDecompNoCP
|
|
isMaybeOrNonZeroCC
(
norm16
=
getNorm16
(
c
)
)
)
{
return
nullptr
;
}
const
char16_t
*
decomp
=
nullptr
;
if
(
isDecompNoAlgorithmic
(
norm16
)
)
{
c
=
mapAlgorithmic
(
c
norm16
)
;
decomp
=
buffer
;
length
=
0
;
U16_APPEND_UNSAFE
(
buffer
length
c
)
;
norm16
=
getRawNorm16
(
c
)
;
}
if
(
norm16
<
minYesNo
)
{
return
decomp
;
}
else
if
(
isHangulLV
(
norm16
)
|
|
isHangulLVT
(
norm16
)
)
{
length
=
Hangul
:
:
decompose
(
c
buffer
)
;
return
buffer
;
}
const
uint16_t
*
mapping
=
getMapping
(
norm16
)
;
length
=
*
mapping
&
MAPPING_LENGTH_MASK
;
return
(
const
char16_t
*
)
mapping
+
1
;
}
const
char16_t
*
Normalizer2Impl
:
:
getRawDecomposition
(
UChar32
c
char16_t
buffer
[
30
]
int32_t
&
length
)
const
{
uint16_t
norm16
;
if
(
c
<
minDecompNoCP
|
|
isDecompYes
(
norm16
=
getNorm16
(
c
)
)
)
{
return
nullptr
;
}
else
if
(
isHangulLV
(
norm16
)
|
|
isHangulLVT
(
norm16
)
)
{
Hangul
:
:
getRawDecomposition
(
c
buffer
)
;
length
=
2
;
return
buffer
;
}
else
if
(
isDecompNoAlgorithmic
(
norm16
)
)
{
c
=
mapAlgorithmic
(
c
norm16
)
;
length
=
0
;
U16_APPEND_UNSAFE
(
buffer
length
c
)
;
return
buffer
;
}
const
uint16_t
*
mapping
=
getMapping
(
norm16
)
;
uint16_t
firstUnit
=
*
mapping
;
int32_t
mLength
=
firstUnit
&
MAPPING_LENGTH_MASK
;
if
(
firstUnit
&
MAPPING_HAS_RAW_MAPPING
)
{
const
uint16_t
*
rawMapping
=
mapping
-
(
(
firstUnit
>
>
7
)
&
1
)
-
1
;
uint16_t
rm0
=
*
rawMapping
;
if
(
rm0
<
=
MAPPING_LENGTH_MASK
)
{
length
=
rm0
;
return
(
const
char16_t
*
)
rawMapping
-
rm0
;
}
else
{
buffer
[
0
]
=
(
char16_t
)
rm0
;
u_memcpy
(
buffer
+
1
(
const
char16_t
*
)
mapping
+
1
+
2
mLength
-
2
)
;
length
=
mLength
-
1
;
return
buffer
;
}
}
else
{
length
=
mLength
;
return
(
const
char16_t
*
)
mapping
+
1
;
}
}
void
Normalizer2Impl
:
:
decomposeAndAppend
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
doDecompose
UnicodeString
&
safeMiddle
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
{
buffer
.
copyReorderableSuffixTo
(
safeMiddle
)
;
if
(
doDecompose
)
{
decompose
(
src
limit
&
buffer
errorCode
)
;
return
;
}
bool
isFirst
=
true
;
uint8_t
firstCC
=
0
prevCC
=
0
cc
;
const
char16_t
*
p
=
src
;
while
(
p
!
=
limit
)
{
const
char16_t
*
codePointStart
=
p
;
UChar32
c
;
uint16_t
norm16
;
UCPTRIE_FAST_U16_NEXT
(
normTrie
UCPTRIE_16
p
limit
c
norm16
)
;
if
(
(
cc
=
getCC
(
norm16
)
)
=
=
0
)
{
p
=
codePointStart
;
break
;
}
if
(
isFirst
)
{
firstCC
=
cc
;
isFirst
=
false
;
}
prevCC
=
cc
;
}
if
(
limit
=
=
nullptr
)
{
limit
=
u_strchr
(
p
0
)
;
}
if
(
buffer
.
append
(
src
(
int32_t
)
(
p
-
src
)
false
firstCC
prevCC
errorCode
)
)
{
buffer
.
appendZeroCC
(
p
limit
errorCode
)
;
}
}
UBool
Normalizer2Impl
:
:
hasDecompBoundaryBefore
(
UChar32
c
)
const
{
return
c
<
minLcccCP
|
|
(
c
<
=
0xffff
&
&
!
singleLeadMightHaveNonZeroFCD16
(
c
)
)
|
|
norm16HasDecompBoundaryBefore
(
getNorm16
(
c
)
)
;
}
UBool
Normalizer2Impl
:
:
norm16HasDecompBoundaryBefore
(
uint16_t
norm16
)
const
{
if
(
norm16
<
minNoNoCompNoMaybeCC
)
{
return
true
;
}
if
(
norm16
>
=
limitNoNo
)
{
return
norm16
<
=
MIN_NORMAL_MAYBE_YES
|
|
norm16
=
=
JAMO_VT
;
}
const
uint16_t
*
mapping
=
getMapping
(
norm16
)
;
uint16_t
firstUnit
=
*
mapping
;
return
(
firstUnit
&
MAPPING_HAS_CCC_LCCC_WORD
)
=
=
0
|
|
(
*
(
mapping
-
1
)
&
0xff00
)
=
=
0
;
}
UBool
Normalizer2Impl
:
:
hasDecompBoundaryAfter
(
UChar32
c
)
const
{
if
(
c
<
minDecompNoCP
)
{
return
true
;
}
if
(
c
<
=
0xffff
&
&
!
singleLeadMightHaveNonZeroFCD16
(
c
)
)
{
return
true
;
}
return
norm16HasDecompBoundaryAfter
(
getNorm16
(
c
)
)
;
}
UBool
Normalizer2Impl
:
:
norm16HasDecompBoundaryAfter
(
uint16_t
norm16
)
const
{
if
(
norm16
<
=
minYesNo
|
|
isHangulLVT
(
norm16
)
)
{
return
true
;
}
if
(
norm16
>
=
limitNoNo
)
{
if
(
isMaybeOrNonZeroCC
(
norm16
)
)
{
return
norm16
<
=
MIN_NORMAL_MAYBE_YES
|
|
norm16
=
=
JAMO_VT
;
}
return
(
norm16
&
DELTA_TCCC_MASK
)
<
=
DELTA_TCCC_1
;
}
const
uint16_t
*
mapping
=
getMapping
(
norm16
)
;
uint16_t
firstUnit
=
*
mapping
;
if
(
firstUnit
>
0x1ff
)
{
return
false
;
}
if
(
firstUnit
<
=
0xff
)
{
return
true
;
}
return
(
firstUnit
&
MAPPING_HAS_CCC_LCCC_WORD
)
=
=
0
|
|
(
*
(
mapping
-
1
)
&
0xff00
)
=
=
0
;
}
int32_t
Normalizer2Impl
:
:
combine
(
const
uint16_t
*
list
UChar32
trail
)
{
uint16_t
key1
firstUnit
;
if
(
trail
<
COMP_1_TRAIL_LIMIT
)
{
key1
=
(
uint16_t
)
(
trail
<
<
1
)
;
while
(
key1
>
(
firstUnit
=
*
list
)
)
{
list
+
=
2
+
(
firstUnit
&
COMP_1_TRIPLE
)
;
}
if
(
key1
=
=
(
firstUnit
&
COMP_1_TRAIL_MASK
)
)
{
if
(
firstUnit
&
COMP_1_TRIPLE
)
{
return
(
(
int32_t
)
list
[
1
]
<
<
16
)
|
list
[
2
]
;
}
else
{
return
list
[
1
]
;
}
}
}
else
{
key1
=
(
uint16_t
)
(
COMP_1_TRAIL_LIMIT
+
(
(
(
trail
>
>
COMP_1_TRAIL_SHIFT
)
)
&
~
COMP_1_TRIPLE
)
)
;
uint16_t
key2
=
(
uint16_t
)
(
trail
<
<
COMP_2_TRAIL_SHIFT
)
;
uint16_t
secondUnit
;
for
(
;
;
)
{
if
(
key1
>
(
firstUnit
=
*
list
)
)
{
list
+
=
2
+
(
firstUnit
&
COMP_1_TRIPLE
)
;
}
else
if
(
key1
=
=
(
firstUnit
&
COMP_1_TRAIL_MASK
)
)
{
if
(
key2
>
(
secondUnit
=
list
[
1
]
)
)
{
if
(
firstUnit
&
COMP_1_LAST_TUPLE
)
{
break
;
}
else
{
list
+
=
3
;
}
}
else
if
(
key2
=
=
(
secondUnit
&
COMP_2_TRAIL_MASK
)
)
{
return
(
(
int32_t
)
(
secondUnit
&
~
COMP_2_TRAIL_MASK
)
<
<
16
)
|
list
[
2
]
;
}
else
{
break
;
}
}
else
{
break
;
}
}
}
return
-
1
;
}
void
Normalizer2Impl
:
:
addComposites
(
const
uint16_t
*
list
UnicodeSet
&
set
)
const
{
uint16_t
firstUnit
;
int32_t
compositeAndFwd
;
do
{
firstUnit
=
*
list
;
if
(
(
firstUnit
&
COMP_1_TRIPLE
)
=
=
0
)
{
compositeAndFwd
=
list
[
1
]
;
list
+
=
2
;
}
else
{
compositeAndFwd
=
(
(
(
int32_t
)
list
[
1
]
&
~
COMP_2_TRAIL_MASK
)
<
<
16
)
|
list
[
2
]
;
list
+
=
3
;
}
UChar32
composite
=
compositeAndFwd
>
>
1
;
if
(
(
compositeAndFwd
&
1
)
!
=
0
)
{
addComposites
(
getCompositionsListForComposite
(
getRawNorm16
(
composite
)
)
set
)
;
}
set
.
add
(
composite
)
;
}
while
(
(
firstUnit
&
COMP_1_LAST_TUPLE
)
=
=
0
)
;
}
void
Normalizer2Impl
:
:
recompose
(
ReorderingBuffer
&
buffer
int32_t
recomposeStartIndex
UBool
onlyContiguous
)
const
{
char16_t
*
p
=
buffer
.
getStart
(
)
+
recomposeStartIndex
;
char16_t
*
limit
=
buffer
.
getLimit
(
)
;
if
(
p
=
=
limit
)
{
return
;
}
char16_t
*
starter
*
pRemove
*
q
*
r
;
const
uint16_t
*
compositionsList
;
UChar32
c
compositeAndFwd
;
uint16_t
norm16
;
uint8_t
cc
prevCC
;
UBool
starterIsSupplementary
;
compositionsList
=
nullptr
;
starter
=
nullptr
;
starterIsSupplementary
=
false
;
prevCC
=
0
;
for
(
;
;
)
{
UCPTRIE_FAST_U16_NEXT
(
normTrie
UCPTRIE_16
p
limit
c
norm16
)
;
cc
=
getCCFromYesOrMaybe
(
norm16
)
;
if
(
isMaybe
(
norm16
)
&
&
compositionsList
!
=
nullptr
&
&
(
prevCC
<
cc
|
|
prevCC
=
=
0
)
)
{
if
(
isJamoVT
(
norm16
)
)
{
if
(
c
<
Hangul
:
:
JAMO_T_BASE
)
{
char16_t
prev
=
(
char16_t
)
(
*
starter
-
Hangul
:
:
JAMO_L_BASE
)
;
if
(
prev
<
Hangul
:
:
JAMO_L_COUNT
)
{
pRemove
=
p
-
1
;
char16_t
syllable
=
(
char16_t
)
(
Hangul
:
:
HANGUL_BASE
+
(
prev
*
Hangul
:
:
JAMO_V_COUNT
+
(
c
-
Hangul
:
:
JAMO_V_BASE
)
)
*
Hangul
:
:
JAMO_T_COUNT
)
;
char16_t
t
;
if
(
p
!
=
limit
&
&
(
t
=
(
char16_t
)
(
*
p
-
Hangul
:
:
JAMO_T_BASE
)
)
<
Hangul
:
:
JAMO_T_COUNT
)
{
+
+
p
;
syllable
+
=
t
;
}
*
starter
=
syllable
;
q
=
pRemove
;
r
=
p
;
while
(
r
<
limit
)
{
*
q
+
+
=
*
r
+
+
;
}
limit
=
q
;
p
=
pRemove
;
}
}
if
(
p
=
=
limit
)
{
break
;
}
compositionsList
=
nullptr
;
continue
;
}
else
if
(
(
compositeAndFwd
=
combine
(
compositionsList
c
)
)
>
=
0
)
{
UChar32
composite
=
compositeAndFwd
>
>
1
;
pRemove
=
p
-
U16_LENGTH
(
c
)
;
if
(
starterIsSupplementary
)
{
if
(
U_IS_SUPPLEMENTARY
(
composite
)
)
{
starter
[
0
]
=
U16_LEAD
(
composite
)
;
starter
[
1
]
=
U16_TRAIL
(
composite
)
;
}
else
{
*
starter
=
(
char16_t
)
composite
;
starterIsSupplementary
=
false
;
q
=
starter
+
1
;
r
=
q
+
1
;
while
(
r
<
pRemove
)
{
*
q
+
+
=
*
r
+
+
;
}
-
-
pRemove
;
}
}
else
if
(
U_IS_SUPPLEMENTARY
(
composite
)
)
{
starterIsSupplementary
=
true
;
+
+
starter
;
q
=
pRemove
;
r
=
+
+
pRemove
;
while
(
starter
<
q
)
{
*
-
-
r
=
*
-
-
q
;
}
*
starter
=
U16_TRAIL
(
composite
)
;
*
-
-
starter
=
U16_LEAD
(
composite
)
;
}
else
{
*
starter
=
(
char16_t
)
composite
;
}
if
(
pRemove
<
p
)
{
q
=
pRemove
;
r
=
p
;
while
(
r
<
limit
)
{
*
q
+
+
=
*
r
+
+
;
}
limit
=
q
;
p
=
pRemove
;
}
if
(
p
=
=
limit
)
{
break
;
}
if
(
compositeAndFwd
&
1
)
{
compositionsList
=
getCompositionsListForComposite
(
getRawNorm16
(
composite
)
)
;
}
else
{
compositionsList
=
nullptr
;
}
continue
;
}
}
prevCC
=
cc
;
if
(
p
=
=
limit
)
{
break
;
}
if
(
cc
=
=
0
)
{
if
(
(
compositionsList
=
getCompositionsListForDecompYes
(
norm16
)
)
!
=
nullptr
)
{
if
(
U_IS_BMP
(
c
)
)
{
starterIsSupplementary
=
false
;
starter
=
p
-
1
;
}
else
{
starterIsSupplementary
=
true
;
starter
=
p
-
2
;
}
}
}
else
if
(
onlyContiguous
)
{
compositionsList
=
nullptr
;
}
}
buffer
.
setReorderingLimit
(
limit
)
;
}
UChar32
Normalizer2Impl
:
:
composePair
(
UChar32
a
UChar32
b
)
const
{
uint16_t
norm16
=
getNorm16
(
a
)
;
const
uint16_t
*
list
;
if
(
isInert
(
norm16
)
)
{
return
U_SENTINEL
;
}
else
if
(
norm16
<
minYesNoMappingsOnly
)
{
if
(
isJamoL
(
norm16
)
)
{
b
-
=
Hangul
:
:
JAMO_V_BASE
;
if
(
0
<
=
b
&
&
b
<
Hangul
:
:
JAMO_V_COUNT
)
{
return
(
Hangul
:
:
HANGUL_BASE
+
(
(
a
-
Hangul
:
:
JAMO_L_BASE
)
*
Hangul
:
:
JAMO_V_COUNT
+
b
)
*
Hangul
:
:
JAMO_T_COUNT
)
;
}
else
{
return
U_SENTINEL
;
}
}
else
if
(
isHangulLV
(
norm16
)
)
{
b
-
=
Hangul
:
:
JAMO_T_BASE
;
if
(
0
<
b
&
&
b
<
Hangul
:
:
JAMO_T_COUNT
)
{
return
a
+
b
;
}
else
{
return
U_SENTINEL
;
}
}
else
{
list
=
getMapping
(
norm16
)
;
if
(
norm16
>
minYesNo
)
{
list
+
=
1
+
(
*
list
&
MAPPING_LENGTH_MASK
)
;
}
}
}
else
if
(
norm16
<
minMaybeYes
|
|
MIN_NORMAL_MAYBE_YES
<
=
norm16
)
{
return
U_SENTINEL
;
}
else
{
list
=
getCompositionsListForMaybe
(
norm16
)
;
}
if
(
b
<
0
|
|
0x10ffff
<
b
)
{
return
U_SENTINEL
;
}
#
if
U_SIGNED_RIGHT_SHIFT_IS_ARITHMETIC
return
combine
(
list
b
)
>
>
1
;
#
else
int32_t
compositeAndFwd
=
combine
(
list
b
)
;
return
compositeAndFwd
>
=
0
?
compositeAndFwd
>
>
1
:
U_SENTINEL
;
#
endif
}
UBool
Normalizer2Impl
:
:
compose
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
onlyContiguous
UBool
doCompose
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
{
const
char16_t
*
prevBoundary
=
src
;
UChar32
minNoMaybeCP
=
minCompNoMaybeCP
;
if
(
limit
=
=
nullptr
)
{
src
=
copyLowPrefixFromNulTerminated
(
src
minNoMaybeCP
doCompose
?
&
buffer
:
nullptr
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
false
;
}
limit
=
u_strchr
(
src
0
)
;
if
(
prevBoundary
!
=
src
)
{
if
(
hasCompBoundaryAfter
(
*
(
src
-
1
)
onlyContiguous
)
)
{
prevBoundary
=
src
;
}
else
{
buffer
.
removeSuffix
(
1
)
;
prevBoundary
=
-
-
src
;
}
}
}
for
(
;
;
)
{
const
char16_t
*
prevSrc
;
UChar32
c
=
0
;
uint16_t
norm16
=
0
;
for
(
;
;
)
{
if
(
src
=
=
limit
)
{
if
(
prevBoundary
!
=
limit
&
&
doCompose
)
{
buffer
.
appendZeroCC
(
prevBoundary
limit
errorCode
)
;
}
return
true
;
}
if
(
(
c
=
*
src
)
<
minNoMaybeCP
|
|
isCompYesAndZeroCC
(
norm16
=
UCPTRIE_FAST_BMP_GET
(
normTrie
UCPTRIE_16
c
)
)
)
{
+
+
src
;
}
else
{
prevSrc
=
src
+
+
;
if
(
!
U16_IS_LEAD
(
c
)
)
{
break
;
}
else
{
char16_t
c2
;
if
(
src
!
=
limit
&
&
U16_IS_TRAIL
(
c2
=
*
src
)
)
{
+
+
src
;
c
=
U16_GET_SUPPLEMENTARY
(
c
c2
)
;
norm16
=
UCPTRIE_FAST_SUPP_GET
(
normTrie
UCPTRIE_16
c
)
;
if
(
!
isCompYesAndZeroCC
(
norm16
)
)
{
break
;
}
}
}
}
}
if
(
!
isMaybeOrNonZeroCC
(
norm16
)
)
{
if
(
!
doCompose
)
{
return
false
;
}
if
(
isDecompNoAlgorithmic
(
norm16
)
)
{
if
(
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
|
|
hasCompBoundaryBefore
(
src
limit
)
)
{
if
(
prevBoundary
!
=
prevSrc
&
&
!
buffer
.
appendZeroCC
(
prevBoundary
prevSrc
errorCode
)
)
{
break
;
}
if
(
!
buffer
.
append
(
mapAlgorithmic
(
c
norm16
)
0
errorCode
)
)
{
break
;
}
prevBoundary
=
src
;
continue
;
}
}
else
if
(
norm16
<
minNoNoCompBoundaryBefore
)
{
if
(
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
|
|
hasCompBoundaryBefore
(
src
limit
)
)
{
if
(
prevBoundary
!
=
prevSrc
&
&
!
buffer
.
appendZeroCC
(
prevBoundary
prevSrc
errorCode
)
)
{
break
;
}
const
char16_t
*
mapping
=
reinterpret_cast
<
const
char16_t
*
>
(
getMapping
(
norm16
)
)
;
int32_t
length
=
*
mapping
+
+
&
MAPPING_LENGTH_MASK
;
if
(
!
buffer
.
appendZeroCC
(
mapping
mapping
+
length
errorCode
)
)
{
break
;
}
prevBoundary
=
src
;
continue
;
}
}
else
if
(
norm16
>
=
minNoNoEmpty
)
{
if
(
hasCompBoundaryBefore
(
src
limit
)
|
|
hasCompBoundaryAfter
(
prevBoundary
prevSrc
onlyContiguous
)
)
{
if
(
prevBoundary
!
=
prevSrc
&
&
!
buffer
.
appendZeroCC
(
prevBoundary
prevSrc
errorCode
)
)
{
break
;
}
prevBoundary
=
src
;
continue
;
}
}
}
else
if
(
isJamoVT
(
norm16
)
&
&
prevBoundary
!
=
prevSrc
)
{
char16_t
prev
=
*
(
prevSrc
-
1
)
;
if
(
c
<
Hangul
:
:
JAMO_T_BASE
)
{
char16_t
l
=
(
char16_t
)
(
prev
-
Hangul
:
:
JAMO_L_BASE
)
;
if
(
l
<
Hangul
:
:
JAMO_L_COUNT
)
{
if
(
!
doCompose
)
{
return
false
;
}
int32_t
t
;
if
(
src
!
=
limit
&
&
0
<
(
t
=
(
(
int32_t
)
*
src
-
Hangul
:
:
JAMO_T_BASE
)
)
&
&
t
<
Hangul
:
:
JAMO_T_COUNT
)
{
+
+
src
;
}
else
if
(
hasCompBoundaryBefore
(
src
limit
)
)
{
t
=
0
;
}
else
{
t
=
-
1
;
}
if
(
t
>
=
0
)
{
UChar32
syllable
=
Hangul
:
:
HANGUL_BASE
+
(
l
*
Hangul
:
:
JAMO_V_COUNT
+
(
c
-
Hangul
:
:
JAMO_V_BASE
)
)
*
Hangul
:
:
JAMO_T_COUNT
+
t
;
-
-
prevSrc
;
if
(
prevBoundary
!
=
prevSrc
&
&
!
buffer
.
appendZeroCC
(
prevBoundary
prevSrc
errorCode
)
)
{
break
;
}
if
(
!
buffer
.
appendBMP
(
(
char16_t
)
syllable
0
errorCode
)
)
{
break
;
}
prevBoundary
=
src
;
continue
;
}
}
}
else
if
(
Hangul
:
:
isHangulLV
(
prev
)
)
{
if
(
!
doCompose
)
{
return
false
;
}
UChar32
syllable
=
prev
+
c
-
Hangul
:
:
JAMO_T_BASE
;
-
-
prevSrc
;
if
(
prevBoundary
!
=
prevSrc
&
&
!
buffer
.
appendZeroCC
(
prevBoundary
prevSrc
errorCode
)
)
{
break
;
}
if
(
!
buffer
.
appendBMP
(
(
char16_t
)
syllable
0
errorCode
)
)
{
break
;
}
prevBoundary
=
src
;
continue
;
}
}
else
if
(
norm16
>
JAMO_VT
)
{
uint8_t
cc
=
getCCFromNormalYesOrMaybe
(
norm16
)
;
if
(
onlyContiguous
&
&
getPreviousTrailCC
(
prevBoundary
prevSrc
)
>
cc
)
{
if
(
!
doCompose
)
{
return
false
;
}
}
else
{
const
char16_t
*
nextSrc
;
uint16_t
n16
;
for
(
;
;
)
{
if
(
src
=
=
limit
)
{
if
(
doCompose
)
{
buffer
.
appendZeroCC
(
prevBoundary
limit
errorCode
)
;
}
return
true
;
}
uint8_t
prevCC
=
cc
;
nextSrc
=
src
;
UCPTRIE_FAST_U16_NEXT
(
normTrie
UCPTRIE_16
nextSrc
limit
c
n16
)
;
if
(
n16
>
=
MIN_YES_YES_WITH_CC
)
{
cc
=
getCCFromNormalYesOrMaybe
(
n16
)
;
if
(
prevCC
>
cc
)
{
if
(
!
doCompose
)
{
return
false
;
}
break
;
}
}
else
{
break
;
}
src
=
nextSrc
;
}
if
(
norm16HasCompBoundaryBefore
(
n16
)
)
{
if
(
isCompYesAndZeroCC
(
n16
)
)
{
src
=
nextSrc
;
}
continue
;
}
}
}
if
(
prevBoundary
!
=
prevSrc
&
&
!
norm16HasCompBoundaryBefore
(
norm16
)
)
{
const
char16_t
*
p
=
prevSrc
;
UCPTRIE_FAST_U16_PREV
(
normTrie
UCPTRIE_16
prevBoundary
p
c
norm16
)
;
if
(
!
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
)
{
prevSrc
=
p
;
}
}
if
(
doCompose
&
&
prevBoundary
!
=
prevSrc
&
&
!
buffer
.
appendZeroCC
(
prevBoundary
prevSrc
errorCode
)
)
{
break
;
}
int32_t
recomposeStartIndex
=
buffer
.
length
(
)
;
decomposeShort
(
prevSrc
src
false
onlyContiguous
buffer
errorCode
)
;
src
=
decomposeShort
(
src
limit
true
onlyContiguous
buffer
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
break
;
}
if
(
(
src
-
prevSrc
)
>
INT32_MAX
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
true
;
}
recompose
(
buffer
recomposeStartIndex
onlyContiguous
)
;
if
(
!
doCompose
)
{
if
(
!
buffer
.
equals
(
prevSrc
src
)
)
{
return
false
;
}
buffer
.
remove
(
)
;
}
prevBoundary
=
src
;
}
return
true
;
}
const
char16_t
*
Normalizer2Impl
:
:
composeQuickCheck
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
onlyContiguous
UNormalizationCheckResult
*
pQCResult
)
const
{
const
char16_t
*
prevBoundary
=
src
;
UChar32
minNoMaybeCP
=
minCompNoMaybeCP
;
if
(
limit
=
=
nullptr
)
{
UErrorCode
errorCode
=
U_ZERO_ERROR
;
src
=
copyLowPrefixFromNulTerminated
(
src
minNoMaybeCP
nullptr
errorCode
)
;
limit
=
u_strchr
(
src
0
)
;
if
(
prevBoundary
!
=
src
)
{
if
(
hasCompBoundaryAfter
(
*
(
src
-
1
)
onlyContiguous
)
)
{
prevBoundary
=
src
;
}
else
{
prevBoundary
=
-
-
src
;
}
}
}
for
(
;
;
)
{
const
char16_t
*
prevSrc
;
UChar32
c
=
0
;
uint16_t
norm16
=
0
;
for
(
;
;
)
{
if
(
src
=
=
limit
)
{
return
src
;
}
if
(
(
c
=
*
src
)
<
minNoMaybeCP
|
|
isCompYesAndZeroCC
(
norm16
=
UCPTRIE_FAST_BMP_GET
(
normTrie
UCPTRIE_16
c
)
)
)
{
+
+
src
;
}
else
{
prevSrc
=
src
+
+
;
if
(
!
U16_IS_LEAD
(
c
)
)
{
break
;
}
else
{
char16_t
c2
;
if
(
src
!
=
limit
&
&
U16_IS_TRAIL
(
c2
=
*
src
)
)
{
+
+
src
;
c
=
U16_GET_SUPPLEMENTARY
(
c
c2
)
;
norm16
=
UCPTRIE_FAST_SUPP_GET
(
normTrie
UCPTRIE_16
c
)
;
if
(
!
isCompYesAndZeroCC
(
norm16
)
)
{
break
;
}
}
}
}
}
uint16_t
prevNorm16
=
INERT
;
if
(
prevBoundary
!
=
prevSrc
)
{
if
(
norm16HasCompBoundaryBefore
(
norm16
)
)
{
prevBoundary
=
prevSrc
;
}
else
{
const
char16_t
*
p
=
prevSrc
;
uint16_t
n16
;
UCPTRIE_FAST_U16_PREV
(
normTrie
UCPTRIE_16
prevBoundary
p
c
n16
)
;
if
(
norm16HasCompBoundaryAfter
(
n16
onlyContiguous
)
)
{
prevBoundary
=
prevSrc
;
}
else
{
prevBoundary
=
p
;
prevNorm16
=
n16
;
}
}
}
if
(
isMaybeOrNonZeroCC
(
norm16
)
)
{
uint8_t
cc
=
getCCFromYesOrMaybe
(
norm16
)
;
if
(
onlyContiguous
&
&
cc
!
=
0
&
&
getTrailCCFromCompYesAndZeroCC
(
prevNorm16
)
>
cc
)
{
}
else
{
const
char16_t
*
nextSrc
;
for
(
;
;
)
{
if
(
norm16
<
MIN_YES_YES_WITH_CC
)
{
if
(
pQCResult
!
=
nullptr
)
{
*
pQCResult
=
UNORM_MAYBE
;
}
else
{
return
prevBoundary
;
}
}
if
(
src
=
=
limit
)
{
return
src
;
}
uint8_t
prevCC
=
cc
;
nextSrc
=
src
;
UCPTRIE_FAST_U16_NEXT
(
normTrie
UCPTRIE_16
nextSrc
limit
c
norm16
)
;
if
(
isMaybeOrNonZeroCC
(
norm16
)
)
{
cc
=
getCCFromYesOrMaybe
(
norm16
)
;
if
(
!
(
prevCC
<
=
cc
|
|
cc
=
=
0
)
)
{
break
;
}
}
else
{
break
;
}
src
=
nextSrc
;
}
if
(
isCompYesAndZeroCC
(
norm16
)
)
{
prevBoundary
=
src
;
src
=
nextSrc
;
continue
;
}
}
}
if
(
pQCResult
!
=
nullptr
)
{
*
pQCResult
=
UNORM_NO
;
}
return
prevBoundary
;
}
}
void
Normalizer2Impl
:
:
composeAndAppend
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
doCompose
UBool
onlyContiguous
UnicodeString
&
safeMiddle
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
{
if
(
!
buffer
.
isEmpty
(
)
)
{
const
char16_t
*
firstStarterInSrc
=
findNextCompBoundary
(
src
limit
onlyContiguous
)
;
if
(
src
!
=
firstStarterInSrc
)
{
const
char16_t
*
lastStarterInDest
=
findPreviousCompBoundary
(
buffer
.
getStart
(
)
buffer
.
getLimit
(
)
onlyContiguous
)
;
int32_t
destSuffixLength
=
(
int32_t
)
(
buffer
.
getLimit
(
)
-
lastStarterInDest
)
;
UnicodeString
middle
(
lastStarterInDest
destSuffixLength
)
;
buffer
.
removeSuffix
(
destSuffixLength
)
;
safeMiddle
=
middle
;
middle
.
append
(
src
(
int32_t
)
(
firstStarterInSrc
-
src
)
)
;
const
char16_t
*
middleStart
=
middle
.
getBuffer
(
)
;
compose
(
middleStart
middleStart
+
middle
.
length
(
)
onlyContiguous
true
buffer
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
src
=
firstStarterInSrc
;
}
}
if
(
doCompose
)
{
compose
(
src
limit
onlyContiguous
true
buffer
errorCode
)
;
}
else
{
if
(
limit
=
=
nullptr
)
{
limit
=
u_strchr
(
src
0
)
;
}
buffer
.
appendZeroCC
(
src
limit
errorCode
)
;
}
}
UBool
Normalizer2Impl
:
:
composeUTF8
(
uint32_t
options
UBool
onlyContiguous
const
uint8_t
*
src
const
uint8_t
*
limit
ByteSink
*
sink
Edits
*
edits
UErrorCode
&
errorCode
)
const
{
U_ASSERT
(
limit
!
=
nullptr
)
;
UnicodeString
s16
;
uint8_t
minNoMaybeLead
=
leadByteForCP
(
minCompNoMaybeCP
)
;
const
uint8_t
*
prevBoundary
=
src
;
for
(
;
;
)
{
const
uint8_t
*
prevSrc
;
uint16_t
norm16
=
0
;
for
(
;
;
)
{
if
(
src
=
=
limit
)
{
if
(
prevBoundary
!
=
limit
&
&
sink
!
=
nullptr
)
{
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
limit
*
sink
options
edits
errorCode
)
;
}
return
true
;
}
if
(
*
src
<
minNoMaybeLead
)
{
+
+
src
;
}
else
{
prevSrc
=
src
;
UCPTRIE_FAST_U8_NEXT
(
normTrie
UCPTRIE_16
src
limit
norm16
)
;
if
(
!
isCompYesAndZeroCC
(
norm16
)
)
{
break
;
}
}
}
if
(
!
isMaybeOrNonZeroCC
(
norm16
)
)
{
if
(
sink
=
=
nullptr
)
{
return
false
;
}
if
(
isDecompNoAlgorithmic
(
norm16
)
)
{
if
(
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
|
|
hasCompBoundaryBefore
(
src
limit
)
)
{
if
(
prevBoundary
!
=
prevSrc
&
&
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
prevSrc
*
sink
options
edits
errorCode
)
)
{
break
;
}
appendCodePointDelta
(
prevSrc
src
getAlgorithmicDelta
(
norm16
)
*
sink
edits
)
;
prevBoundary
=
src
;
continue
;
}
}
else
if
(
norm16
<
minNoNoCompBoundaryBefore
)
{
if
(
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
|
|
hasCompBoundaryBefore
(
src
limit
)
)
{
if
(
prevBoundary
!
=
prevSrc
&
&
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
prevSrc
*
sink
options
edits
errorCode
)
)
{
break
;
}
const
uint16_t
*
mapping
=
getMapping
(
norm16
)
;
int32_t
length
=
*
mapping
+
+
&
MAPPING_LENGTH_MASK
;
if
(
!
ByteSinkUtil
:
:
appendChange
(
prevSrc
src
(
const
char16_t
*
)
mapping
length
*
sink
edits
errorCode
)
)
{
break
;
}
prevBoundary
=
src
;
continue
;
}
}
else
if
(
norm16
>
=
minNoNoEmpty
)
{
if
(
hasCompBoundaryBefore
(
src
limit
)
|
|
hasCompBoundaryAfter
(
prevBoundary
prevSrc
onlyContiguous
)
)
{
if
(
prevBoundary
!
=
prevSrc
&
&
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
prevSrc
*
sink
options
edits
errorCode
)
)
{
break
;
}
if
(
edits
!
=
nullptr
)
{
edits
-
>
addReplace
(
(
int32_t
)
(
src
-
prevSrc
)
0
)
;
}
prevBoundary
=
src
;
continue
;
}
}
}
else
if
(
isJamoVT
(
norm16
)
)
{
U_ASSERT
(
(
src
-
prevSrc
)
=
=
3
&
&
*
prevSrc
=
=
0xe1
)
;
UChar32
prev
=
previousHangulOrJamo
(
prevBoundary
prevSrc
)
;
if
(
prevSrc
[
1
]
=
=
0x85
)
{
UChar32
l
=
prev
-
Hangul
:
:
JAMO_L_BASE
;
if
(
(
uint32_t
)
l
<
Hangul
:
:
JAMO_L_COUNT
)
{
if
(
sink
=
=
nullptr
)
{
return
false
;
}
int32_t
t
=
getJamoTMinusBase
(
src
limit
)
;
if
(
t
>
=
0
)
{
src
+
=
3
;
}
else
if
(
hasCompBoundaryBefore
(
src
limit
)
)
{
t
=
0
;
}
if
(
t
>
=
0
)
{
UChar32
syllable
=
Hangul
:
:
HANGUL_BASE
+
(
l
*
Hangul
:
:
JAMO_V_COUNT
+
(
prevSrc
[
2
]
-
0xa1
)
)
*
Hangul
:
:
JAMO_T_COUNT
+
t
;
prevSrc
-
=
3
;
if
(
prevBoundary
!
=
prevSrc
&
&
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
prevSrc
*
sink
options
edits
errorCode
)
)
{
break
;
}
ByteSinkUtil
:
:
appendCodePoint
(
prevSrc
src
syllable
*
sink
edits
)
;
prevBoundary
=
src
;
continue
;
}
}
}
else
if
(
Hangul
:
:
isHangulLV
(
prev
)
)
{
if
(
sink
=
=
nullptr
)
{
return
false
;
}
UChar32
syllable
=
prev
+
getJamoTMinusBase
(
prevSrc
src
)
;
prevSrc
-
=
3
;
if
(
prevBoundary
!
=
prevSrc
&
&
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
prevSrc
*
sink
options
edits
errorCode
)
)
{
break
;
}
ByteSinkUtil
:
:
appendCodePoint
(
prevSrc
src
syllable
*
sink
edits
)
;
prevBoundary
=
src
;
continue
;
}
}
else
if
(
norm16
>
JAMO_VT
)
{
uint8_t
cc
=
getCCFromNormalYesOrMaybe
(
norm16
)
;
if
(
onlyContiguous
&
&
getPreviousTrailCC
(
prevBoundary
prevSrc
)
>
cc
)
{
if
(
sink
=
=
nullptr
)
{
return
false
;
}
}
else
{
const
uint8_t
*
nextSrc
;
uint16_t
n16
;
for
(
;
;
)
{
if
(
src
=
=
limit
)
{
if
(
sink
!
=
nullptr
)
{
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
limit
*
sink
options
edits
errorCode
)
;
}
return
true
;
}
uint8_t
prevCC
=
cc
;
nextSrc
=
src
;
UCPTRIE_FAST_U8_NEXT
(
normTrie
UCPTRIE_16
nextSrc
limit
n16
)
;
if
(
n16
>
=
MIN_YES_YES_WITH_CC
)
{
cc
=
getCCFromNormalYesOrMaybe
(
n16
)
;
if
(
prevCC
>
cc
)
{
if
(
sink
=
=
nullptr
)
{
return
false
;
}
break
;
}
}
else
{
break
;
}
src
=
nextSrc
;
}
if
(
norm16HasCompBoundaryBefore
(
n16
)
)
{
if
(
isCompYesAndZeroCC
(
n16
)
)
{
src
=
nextSrc
;
}
continue
;
}
}
}
if
(
prevBoundary
!
=
prevSrc
&
&
!
norm16HasCompBoundaryBefore
(
norm16
)
)
{
const
uint8_t
*
p
=
prevSrc
;
UCPTRIE_FAST_U8_PREV
(
normTrie
UCPTRIE_16
prevBoundary
p
norm16
)
;
if
(
!
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
)
{
prevSrc
=
p
;
}
}
ReorderingBuffer
buffer
(
*
this
s16
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
break
;
}
decomposeShort
(
prevSrc
src
STOP_AT_LIMIT
onlyContiguous
buffer
errorCode
)
;
src
=
decomposeShort
(
src
limit
STOP_AT_COMP_BOUNDARY
onlyContiguous
buffer
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
break
;
}
if
(
(
src
-
prevSrc
)
>
INT32_MAX
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
true
;
}
recompose
(
buffer
0
onlyContiguous
)
;
if
(
!
buffer
.
equals
(
prevSrc
src
)
)
{
if
(
sink
=
=
nullptr
)
{
return
false
;
}
if
(
prevBoundary
!
=
prevSrc
&
&
!
ByteSinkUtil
:
:
appendUnchanged
(
prevBoundary
prevSrc
*
sink
options
edits
errorCode
)
)
{
break
;
}
if
(
!
ByteSinkUtil
:
:
appendChange
(
prevSrc
src
buffer
.
getStart
(
)
buffer
.
length
(
)
*
sink
edits
errorCode
)
)
{
break
;
}
prevBoundary
=
src
;
}
}
return
true
;
}
UBool
Normalizer2Impl
:
:
hasCompBoundaryBefore
(
const
char16_t
*
src
const
char16_t
*
limit
)
const
{
if
(
src
=
=
limit
|
|
*
src
<
minCompNoMaybeCP
)
{
return
true
;
}
UChar32
c
;
uint16_t
norm16
;
UCPTRIE_FAST_U16_NEXT
(
normTrie
UCPTRIE_16
src
limit
c
norm16
)
;
return
norm16HasCompBoundaryBefore
(
norm16
)
;
}
UBool
Normalizer2Impl
:
:
hasCompBoundaryBefore
(
const
uint8_t
*
src
const
uint8_t
*
limit
)
const
{
if
(
src
=
=
limit
)
{
return
true
;
}
uint16_t
norm16
;
UCPTRIE_FAST_U8_NEXT
(
normTrie
UCPTRIE_16
src
limit
norm16
)
;
return
norm16HasCompBoundaryBefore
(
norm16
)
;
}
UBool
Normalizer2Impl
:
:
hasCompBoundaryAfter
(
const
char16_t
*
start
const
char16_t
*
p
UBool
onlyContiguous
)
const
{
if
(
start
=
=
p
)
{
return
true
;
}
UChar32
c
;
uint16_t
norm16
;
UCPTRIE_FAST_U16_PREV
(
normTrie
UCPTRIE_16
start
p
c
norm16
)
;
return
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
;
}
UBool
Normalizer2Impl
:
:
hasCompBoundaryAfter
(
const
uint8_t
*
start
const
uint8_t
*
p
UBool
onlyContiguous
)
const
{
if
(
start
=
=
p
)
{
return
true
;
}
uint16_t
norm16
;
UCPTRIE_FAST_U8_PREV
(
normTrie
UCPTRIE_16
start
p
norm16
)
;
return
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
;
}
const
char16_t
*
Normalizer2Impl
:
:
findPreviousCompBoundary
(
const
char16_t
*
start
const
char16_t
*
p
UBool
onlyContiguous
)
const
{
while
(
p
!
=
start
)
{
const
char16_t
*
codePointLimit
=
p
;
UChar32
c
;
uint16_t
norm16
;
UCPTRIE_FAST_U16_PREV
(
normTrie
UCPTRIE_16
start
p
c
norm16
)
;
if
(
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
)
{
return
codePointLimit
;
}
if
(
hasCompBoundaryBefore
(
c
norm16
)
)
{
return
p
;
}
}
return
p
;
}
const
char16_t
*
Normalizer2Impl
:
:
findNextCompBoundary
(
const
char16_t
*
p
const
char16_t
*
limit
UBool
onlyContiguous
)
const
{
while
(
p
!
=
limit
)
{
const
char16_t
*
codePointStart
=
p
;
UChar32
c
;
uint16_t
norm16
;
UCPTRIE_FAST_U16_NEXT
(
normTrie
UCPTRIE_16
p
limit
c
norm16
)
;
if
(
hasCompBoundaryBefore
(
c
norm16
)
)
{
return
codePointStart
;
}
if
(
norm16HasCompBoundaryAfter
(
norm16
onlyContiguous
)
)
{
return
p
;
}
}
return
p
;
}
uint8_t
Normalizer2Impl
:
:
getPreviousTrailCC
(
const
char16_t
*
start
const
char16_t
*
p
)
const
{
if
(
start
=
=
p
)
{
return
0
;
}
int32_t
i
=
(
int32_t
)
(
p
-
start
)
;
UChar32
c
;
U16_PREV
(
start
0
i
c
)
;
return
(
uint8_t
)
getFCD16
(
c
)
;
}
uint8_t
Normalizer2Impl
:
:
getPreviousTrailCC
(
const
uint8_t
*
start
const
uint8_t
*
p
)
const
{
if
(
start
=
=
p
)
{
return
0
;
}
int32_t
i
=
(
int32_t
)
(
p
-
start
)
;
UChar32
c
;
U8_PREV
(
start
0
i
c
)
;
return
(
uint8_t
)
getFCD16
(
c
)
;
}
#
if
(
defined
(
_MSC_VER
)
&
&
(
defined
(
_M_ARM64
)
)
&
&
(
_MSC_VER
<
1924
)
)
#
pragma
optimize
(
"
"
off
)
#
endif
uint16_t
Normalizer2Impl
:
:
getFCD16FromNormData
(
UChar32
c
)
const
{
uint16_t
norm16
=
getNorm16
(
c
)
;
if
(
norm16
>
=
limitNoNo
)
{
if
(
norm16
>
=
MIN_NORMAL_MAYBE_YES
)
{
norm16
=
getCCFromNormalYesOrMaybe
(
norm16
)
;
return
norm16
|
(
norm16
<
<
8
)
;
}
else
if
(
norm16
>
=
minMaybeYes
)
{
return
0
;
}
else
{
uint16_t
deltaTrailCC
=
norm16
&
DELTA_TCCC_MASK
;
if
(
deltaTrailCC
<
=
DELTA_TCCC_1
)
{
return
deltaTrailCC
>
>
OFFSET_SHIFT
;
}
c
=
mapAlgorithmic
(
c
norm16
)
;
norm16
=
getRawNorm16
(
c
)
;
}
}
if
(
norm16
<
=
minYesNo
|
|
isHangulLVT
(
norm16
)
)
{
return
0
;
}
const
uint16_t
*
mapping
=
getMapping
(
norm16
)
;
uint16_t
firstUnit
=
*
mapping
;
norm16
=
firstUnit
>
>
8
;
if
(
firstUnit
&
MAPPING_HAS_CCC_LCCC_WORD
)
{
norm16
|
=
*
(
mapping
-
1
)
&
0xff00
;
}
return
norm16
;
}
#
if
(
defined
(
_MSC_VER
)
&
&
(
defined
(
_M_ARM64
)
)
&
&
(
_MSC_VER
<
1924
)
)
#
pragma
optimize
(
"
"
on
)
#
endif
const
char16_t
*
Normalizer2Impl
:
:
makeFCD
(
const
char16_t
*
src
const
char16_t
*
limit
ReorderingBuffer
*
buffer
UErrorCode
&
errorCode
)
const
{
const
char16_t
*
prevBoundary
=
src
;
int32_t
prevFCD16
=
0
;
if
(
limit
=
=
nullptr
)
{
src
=
copyLowPrefixFromNulTerminated
(
src
minLcccCP
buffer
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
src
;
}
if
(
prevBoundary
<
src
)
{
prevBoundary
=
src
;
prevFCD16
=
getFCD16
(
*
(
src
-
1
)
)
;
if
(
prevFCD16
>
1
)
{
-
-
prevBoundary
;
}
}
limit
=
u_strchr
(
src
0
)
;
}
const
char16_t
*
prevSrc
;
UChar32
c
=
0
;
uint16_t
fcd16
=
0
;
for
(
;
;
)
{
for
(
prevSrc
=
src
;
src
!
=
limit
;
)
{
if
(
(
c
=
*
src
)
<
minLcccCP
)
{
prevFCD16
=
~
c
;
+
+
src
;
}
else
if
(
!
singleLeadMightHaveNonZeroFCD16
(
c
)
)
{
prevFCD16
=
0
;
+
+
src
;
}
else
{
if
(
U16_IS_LEAD
(
c
)
)
{
char16_t
c2
;
if
(
(
src
+
1
)
!
=
limit
&
&
U16_IS_TRAIL
(
c2
=
src
[
1
]
)
)
{
c
=
U16_GET_SUPPLEMENTARY
(
c
c2
)
;
}
}
if
(
(
fcd16
=
getFCD16FromNormData
(
c
)
)
<
=
0xff
)
{
prevFCD16
=
fcd16
;
src
+
=
U16_LENGTH
(
c
)
;
}
else
{
break
;
}
}
}
if
(
src
!
=
prevSrc
)
{
if
(
buffer
!
=
nullptr
&
&
!
buffer
-
>
appendZeroCC
(
prevSrc
src
errorCode
)
)
{
break
;
}
if
(
src
=
=
limit
)
{
break
;
}
prevBoundary
=
src
;
if
(
prevFCD16
<
0
)
{
UChar32
prev
=
~
prevFCD16
;
if
(
prev
<
minDecompNoCP
)
{
prevFCD16
=
0
;
}
else
{
prevFCD16
=
getFCD16FromNormData
(
prev
)
;
if
(
prevFCD16
>
1
)
{
-
-
prevBoundary
;
}
}
}
else
{
const
char16_t
*
p
=
src
-
1
;
if
(
U16_IS_TRAIL
(
*
p
)
&
&
prevSrc
<
p
&
&
U16_IS_LEAD
(
*
(
p
-
1
)
)
)
{
-
-
p
;
prevFCD16
=
getFCD16FromNormData
(
U16_GET_SUPPLEMENTARY
(
p
[
0
]
p
[
1
]
)
)
;
}
if
(
prevFCD16
>
1
)
{
prevBoundary
=
p
;
}
}
prevSrc
=
src
;
}
else
if
(
src
=
=
limit
)
{
break
;
}
src
+
=
U16_LENGTH
(
c
)
;
if
(
(
prevFCD16
&
0xff
)
<
=
(
fcd16
>
>
8
)
)
{
if
(
(
fcd16
&
0xff
)
<
=
1
)
{
prevBoundary
=
src
;
}
if
(
buffer
!
=
nullptr
&
&
!
buffer
-
>
appendZeroCC
(
c
errorCode
)
)
{
break
;
}
prevFCD16
=
fcd16
;
continue
;
}
else
if
(
buffer
=
=
nullptr
)
{
return
prevBoundary
;
}
else
{
buffer
-
>
removeSuffix
(
(
int32_t
)
(
prevSrc
-
prevBoundary
)
)
;
src
=
findNextFCDBoundary
(
src
limit
)
;
decomposeShort
(
prevBoundary
src
false
false
*
buffer
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
break
;
}
prevBoundary
=
src
;
prevFCD16
=
0
;
}
}
return
src
;
}
void
Normalizer2Impl
:
:
makeFCDAndAppend
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
doMakeFCD
UnicodeString
&
safeMiddle
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
{
if
(
!
buffer
.
isEmpty
(
)
)
{
const
char16_t
*
firstBoundaryInSrc
=
findNextFCDBoundary
(
src
limit
)
;
if
(
src
!
=
firstBoundaryInSrc
)
{
const
char16_t
*
lastBoundaryInDest
=
findPreviousFCDBoundary
(
buffer
.
getStart
(
)
buffer
.
getLimit
(
)
)
;
int32_t
destSuffixLength
=
(
int32_t
)
(
buffer
.
getLimit
(
)
-
lastBoundaryInDest
)
;
UnicodeString
middle
(
lastBoundaryInDest
destSuffixLength
)
;
buffer
.
removeSuffix
(
destSuffixLength
)
;
safeMiddle
=
middle
;
middle
.
append
(
src
(
int32_t
)
(
firstBoundaryInSrc
-
src
)
)
;
const
char16_t
*
middleStart
=
middle
.
getBuffer
(
)
;
makeFCD
(
middleStart
middleStart
+
middle
.
length
(
)
&
buffer
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
src
=
firstBoundaryInSrc
;
}
}
if
(
doMakeFCD
)
{
makeFCD
(
src
limit
&
buffer
errorCode
)
;
}
else
{
if
(
limit
=
=
nullptr
)
{
limit
=
u_strchr
(
src
0
)
;
}
buffer
.
appendZeroCC
(
src
limit
errorCode
)
;
}
}
const
char16_t
*
Normalizer2Impl
:
:
findPreviousFCDBoundary
(
const
char16_t
*
start
const
char16_t
*
p
)
const
{
while
(
start
<
p
)
{
const
char16_t
*
codePointLimit
=
p
;
UChar32
c
;
uint16_t
norm16
;
UCPTRIE_FAST_U16_PREV
(
normTrie
UCPTRIE_16
start
p
c
norm16
)
;
if
(
c
<
minDecompNoCP
|
|
norm16HasDecompBoundaryAfter
(
norm16
)
)
{
return
codePointLimit
;
}
if
(
norm16HasDecompBoundaryBefore
(
norm16
)
)
{
return
p
;
}
}
return
p
;
}
const
char16_t
*
Normalizer2Impl
:
:
findNextFCDBoundary
(
const
char16_t
*
p
const
char16_t
*
limit
)
const
{
while
(
p
<
limit
)
{
const
char16_t
*
codePointStart
=
p
;
UChar32
c
;
uint16_t
norm16
;
UCPTRIE_FAST_U16_NEXT
(
normTrie
UCPTRIE_16
p
limit
c
norm16
)
;
if
(
c
<
minLcccCP
|
|
norm16HasDecompBoundaryBefore
(
norm16
)
)
{
return
codePointStart
;
}
if
(
norm16HasDecompBoundaryAfter
(
norm16
)
)
{
return
p
;
}
}
return
p
;
}
CanonIterData
:
:
CanonIterData
(
UErrorCode
&
errorCode
)
:
mutableTrie
(
umutablecptrie_open
(
0
0
&
errorCode
)
)
trie
(
nullptr
)
canonStartSets
(
uprv_deleteUObject
nullptr
errorCode
)
{
}
CanonIterData
:
:
~
CanonIterData
(
)
{
umutablecptrie_close
(
mutableTrie
)
;
ucptrie_close
(
trie
)
;
}
void
CanonIterData
:
:
addToStartSet
(
UChar32
origin
UChar32
decompLead
UErrorCode
&
errorCode
)
{
uint32_t
canonValue
=
umutablecptrie_get
(
mutableTrie
decompLead
)
;
if
(
(
canonValue
&
(
CANON_HAS_SET
|
CANON_VALUE_MASK
)
)
=
=
0
&
&
origin
!
=
0
)
{
umutablecptrie_set
(
mutableTrie
decompLead
canonValue
|
origin
&
errorCode
)
;
}
else
{
UnicodeSet
*
set
;
if
(
(
canonValue
&
CANON_HAS_SET
)
=
=
0
)
{
LocalPointer
<
UnicodeSet
>
lpSet
(
new
UnicodeSet
errorCode
)
;
set
=
lpSet
.
getAlias
(
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
UChar32
firstOrigin
=
(
UChar32
)
(
canonValue
&
CANON_VALUE_MASK
)
;
canonValue
=
(
canonValue
&
~
CANON_VALUE_MASK
)
|
CANON_HAS_SET
|
(
uint32_t
)
canonStartSets
.
size
(
)
;
umutablecptrie_set
(
mutableTrie
decompLead
canonValue
&
errorCode
)
;
canonStartSets
.
adoptElement
(
lpSet
.
orphan
(
)
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
if
(
firstOrigin
!
=
0
)
{
set
-
>
add
(
firstOrigin
)
;
}
}
else
{
set
=
(
UnicodeSet
*
)
canonStartSets
[
(
int32_t
)
(
canonValue
&
CANON_VALUE_MASK
)
]
;
}
set
-
>
add
(
origin
)
;
}
}
class
InitCanonIterData
{
public
:
static
void
doInit
(
Normalizer2Impl
*
impl
UErrorCode
&
errorCode
)
;
}
;
U_CDECL_BEGIN
static
void
U_CALLCONV
initCanonIterData
(
Normalizer2Impl
*
impl
UErrorCode
&
errorCode
)
{
InitCanonIterData
:
:
doInit
(
impl
errorCode
)
;
}
U_CDECL_END
void
InitCanonIterData
:
:
doInit
(
Normalizer2Impl
*
impl
UErrorCode
&
errorCode
)
{
U_ASSERT
(
impl
-
>
fCanonIterData
=
=
nullptr
)
;
impl
-
>
fCanonIterData
=
new
CanonIterData
(
errorCode
)
;
if
(
impl
-
>
fCanonIterData
=
=
nullptr
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
}
if
(
U_SUCCESS
(
errorCode
)
)
{
UChar32
start
=
0
end
;
uint32_t
value
;
while
(
(
end
=
ucptrie_getRange
(
impl
-
>
normTrie
start
UCPMAP_RANGE_FIXED_LEAD_SURROGATES
Normalizer2Impl
:
:
INERT
nullptr
nullptr
&
value
)
)
>
=
0
)
{
if
(
value
!
=
Normalizer2Impl
:
:
INERT
)
{
impl
-
>
makeCanonIterDataFromNorm16
(
start
end
value
*
impl
-
>
fCanonIterData
errorCode
)
;
}
start
=
end
+
1
;
}
#
ifdef
UCPTRIE_DEBUG
umutablecptrie_setName
(
impl
-
>
fCanonIterData
-
>
mutableTrie
"
CanonIterData
"
)
;
#
endif
impl
-
>
fCanonIterData
-
>
trie
=
umutablecptrie_buildImmutable
(
impl
-
>
fCanonIterData
-
>
mutableTrie
UCPTRIE_TYPE_SMALL
UCPTRIE_VALUE_BITS_32
&
errorCode
)
;
umutablecptrie_close
(
impl
-
>
fCanonIterData
-
>
mutableTrie
)
;
impl
-
>
fCanonIterData
-
>
mutableTrie
=
nullptr
;
}
if
(
U_FAILURE
(
errorCode
)
)
{
delete
impl
-
>
fCanonIterData
;
impl
-
>
fCanonIterData
=
nullptr
;
}
}
void
Normalizer2Impl
:
:
makeCanonIterDataFromNorm16
(
UChar32
start
UChar32
end
const
uint16_t
norm16
CanonIterData
&
newData
UErrorCode
&
errorCode
)
const
{
if
(
isInert
(
norm16
)
|
|
(
minYesNo
<
=
norm16
&
&
norm16
<
minNoNo
)
)
{
return
;
}
for
(
UChar32
c
=
start
;
c
<
=
end
;
+
+
c
)
{
uint32_t
oldValue
=
umutablecptrie_get
(
newData
.
mutableTrie
c
)
;
uint32_t
newValue
=
oldValue
;
if
(
isMaybeOrNonZeroCC
(
norm16
)
)
{
newValue
|
=
CANON_NOT_SEGMENT_STARTER
;
if
(
norm16
<
MIN_NORMAL_MAYBE_YES
)
{
newValue
|
=
CANON_HAS_COMPOSITIONS
;
}
}
else
if
(
norm16
<
minYesNo
)
{
newValue
|
=
CANON_HAS_COMPOSITIONS
;
}
else
{
UChar32
c2
=
c
;
uint16_t
norm16_2
=
norm16
;
if
(
isDecompNoAlgorithmic
(
norm16_2
)
)
{
c2
=
mapAlgorithmic
(
c2
norm16_2
)
;
norm16_2
=
getRawNorm16
(
c2
)
;
U_ASSERT
(
!
(
isHangulLV
(
norm16_2
)
|
|
isHangulLVT
(
norm16_2
)
)
)
;
}
if
(
norm16_2
>
minYesNo
)
{
const
uint16_t
*
mapping
=
getMapping
(
norm16_2
)
;
uint16_t
firstUnit
=
*
mapping
;
int32_t
length
=
firstUnit
&
MAPPING_LENGTH_MASK
;
if
(
(
firstUnit
&
MAPPING_HAS_CCC_LCCC_WORD
)
!
=
0
)
{
if
(
c
=
=
c2
&
&
(
*
(
mapping
-
1
)
&
0xff
)
!
=
0
)
{
newValue
|
=
CANON_NOT_SEGMENT_STARTER
;
}
}
if
(
length
!
=
0
)
{
+
+
mapping
;
int32_t
i
=
0
;
U16_NEXT_UNSAFE
(
mapping
i
c2
)
;
newData
.
addToStartSet
(
c
c2
errorCode
)
;
if
(
norm16_2
>
=
minNoNo
)
{
while
(
i
<
length
)
{
U16_NEXT_UNSAFE
(
mapping
i
c2
)
;
uint32_t
c2Value
=
umutablecptrie_get
(
newData
.
mutableTrie
c2
)
;
if
(
(
c2Value
&
CANON_NOT_SEGMENT_STARTER
)
=
=
0
)
{
umutablecptrie_set
(
newData
.
mutableTrie
c2
c2Value
|
CANON_NOT_SEGMENT_STARTER
&
errorCode
)
;
}
}
}
}
}
else
{
newData
.
addToStartSet
(
c
c2
errorCode
)
;
}
}
if
(
newValue
!
=
oldValue
)
{
umutablecptrie_set
(
newData
.
mutableTrie
c
newValue
&
errorCode
)
;
}
}
}
UBool
Normalizer2Impl
:
:
ensureCanonIterData
(
UErrorCode
&
errorCode
)
const
{
Normalizer2Impl
*
me
=
const_cast
<
Normalizer2Impl
*
>
(
this
)
;
umtx_initOnce
(
me
-
>
fCanonIterDataInitOnce
&
initCanonIterData
me
errorCode
)
;
return
U_SUCCESS
(
errorCode
)
;
}
int32_t
Normalizer2Impl
:
:
getCanonValue
(
UChar32
c
)
const
{
return
(
int32_t
)
ucptrie_get
(
fCanonIterData
-
>
trie
c
)
;
}
const
UnicodeSet
&
Normalizer2Impl
:
:
getCanonStartSet
(
int32_t
n
)
const
{
return
*
(
const
UnicodeSet
*
)
fCanonIterData
-
>
canonStartSets
[
n
]
;
}
UBool
Normalizer2Impl
:
:
isCanonSegmentStarter
(
UChar32
c
)
const
{
return
getCanonValue
(
c
)
>
=
0
;
}
UBool
Normalizer2Impl
:
:
getCanonStartSet
(
UChar32
c
UnicodeSet
&
set
)
const
{
int32_t
canonValue
=
getCanonValue
(
c
)
&
~
CANON_NOT_SEGMENT_STARTER
;
if
(
canonValue
=
=
0
)
{
return
false
;
}
set
.
clear
(
)
;
int32_t
value
=
canonValue
&
CANON_VALUE_MASK
;
if
(
(
canonValue
&
CANON_HAS_SET
)
!
=
0
)
{
set
.
addAll
(
getCanonStartSet
(
value
)
)
;
}
else
if
(
value
!
=
0
)
{
set
.
add
(
value
)
;
}
if
(
(
canonValue
&
CANON_HAS_COMPOSITIONS
)
!
=
0
)
{
uint16_t
norm16
=
getRawNorm16
(
c
)
;
if
(
norm16
=
=
JAMO_L
)
{
UChar32
syllable
=
(
UChar32
)
(
Hangul
:
:
HANGUL_BASE
+
(
c
-
Hangul
:
:
JAMO_L_BASE
)
*
Hangul
:
:
JAMO_VT_COUNT
)
;
set
.
add
(
syllable
syllable
+
Hangul
:
:
JAMO_VT_COUNT
-
1
)
;
}
else
{
addComposites
(
getCompositionsList
(
norm16
)
set
)
;
}
}
return
true
;
}
U_NAMESPACE_END
U_NAMESPACE_USE
U_CAPI
int32_t
U_EXPORT2
unorm2_swap
(
const
UDataSwapper
*
ds
const
void
*
inData
int32_t
length
void
*
outData
UErrorCode
*
pErrorCode
)
{
const
UDataInfo
*
pInfo
;
int32_t
headerSize
;
const
uint8_t
*
inBytes
;
uint8_t
*
outBytes
;
const
int32_t
*
inIndexes
;
int32_t
indexes
[
Normalizer2Impl
:
:
IX_TOTAL_SIZE
+
1
]
;
int32_t
i
offset
nextOffset
size
;
headerSize
=
udata_swapDataHeader
(
ds
inData
length
outData
pErrorCode
)
;
if
(
pErrorCode
=
=
nullptr
|
|
U_FAILURE
(
*
pErrorCode
)
)
{
return
0
;
}
pInfo
=
(
const
UDataInfo
*
)
(
(
const
char
*
)
inData
+
4
)
;
uint8_t
formatVersion0
=
pInfo
-
>
formatVersion
[
0
]
;
if
(
!
(
pInfo
-
>
dataFormat
[
0
]
=
=
0x4e
&
&
pInfo
-
>
dataFormat
[
1
]
=
=
0x72
&
&
pInfo
-
>
dataFormat
[
2
]
=
=
0x6d
&
&
pInfo
-
>
dataFormat
[
3
]
=
=
0x32
&
&
(
1
<
=
formatVersion0
&
&
formatVersion0
<
=
4
)
)
)
{
udata_printError
(
ds
"
unorm2_swap
(
)
:
data
format
%
02x
.
%
02x
.
%
02x
.
%
02x
(
format
version
%
02x
)
is
not
recognized
as
Normalizer2
data
\
n
"
pInfo
-
>
dataFormat
[
0
]
pInfo
-
>
dataFormat
[
1
]
pInfo
-
>
dataFormat
[
2
]
pInfo
-
>
dataFormat
[
3
]
pInfo
-
>
formatVersion
[
0
]
)
;
*
pErrorCode
=
U_UNSUPPORTED_ERROR
;
return
0
;
}
inBytes
=
(
const
uint8_t
*
)
inData
+
headerSize
;
outBytes
=
(
outData
=
=
nullptr
)
?
nullptr
:
(
uint8_t
*
)
outData
+
headerSize
;
inIndexes
=
(
const
int32_t
*
)
inBytes
;
int32_t
minIndexesLength
;
if
(
formatVersion0
=
=
1
)
{
minIndexesLength
=
Normalizer2Impl
:
:
IX_MIN_MAYBE_YES
+
1
;
}
else
if
(
formatVersion0
=
=
2
)
{
minIndexesLength
=
Normalizer2Impl
:
:
IX_MIN_YES_NO_MAPPINGS_ONLY
+
1
;
}
else
{
minIndexesLength
=
Normalizer2Impl
:
:
IX_MIN_LCCC_CP
+
1
;
}
if
(
length
>
=
0
)
{
length
-
=
headerSize
;
if
(
length
<
minIndexesLength
*
4
)
{
udata_printError
(
ds
"
unorm2_swap
(
)
:
too
few
bytes
(
%
d
after
header
)
for
Normalizer2
data
\
n
"
length
)
;
*
pErrorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
}
for
(
i
=
0
;
i
<
UPRV_LENGTHOF
(
indexes
)
;
+
+
i
)
{
indexes
[
i
]
=
udata_readInt32
(
ds
inIndexes
[
i
]
)
;
}
size
=
indexes
[
Normalizer2Impl
:
:
IX_TOTAL_SIZE
]
;
if
(
length
>
=
0
)
{
if
(
length
<
size
)
{
udata_printError
(
ds
"
unorm2_swap
(
)
:
too
few
bytes
(
%
d
after
header
)
for
all
of
Normalizer2
data
\
n
"
length
)
;
*
pErrorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
0
;
}
if
(
inBytes
!
=
outBytes
)
{
uprv_memcpy
(
outBytes
inBytes
size
)
;
}
offset
=
0
;
nextOffset
=
indexes
[
Normalizer2Impl
:
:
IX_NORM_TRIE_OFFSET
]
;
ds
-
>
swapArray32
(
ds
inBytes
nextOffset
-
offset
outBytes
pErrorCode
)
;
offset
=
nextOffset
;
nextOffset
=
indexes
[
Normalizer2Impl
:
:
IX_EXTRA_DATA_OFFSET
]
;
utrie_swapAnyVersion
(
ds
inBytes
+
offset
nextOffset
-
offset
outBytes
+
offset
pErrorCode
)
;
offset
=
nextOffset
;
nextOffset
=
indexes
[
Normalizer2Impl
:
:
IX_SMALL_FCD_OFFSET
]
;
ds
-
>
swapArray16
(
ds
inBytes
+
offset
nextOffset
-
offset
outBytes
+
offset
pErrorCode
)
;
offset
=
nextOffset
;
nextOffset
=
indexes
[
Normalizer2Impl
:
:
IX_SMALL_FCD_OFFSET
+
1
]
;
offset
=
nextOffset
;
U_ASSERT
(
offset
=
=
size
)
;
}
return
headerSize
+
size
;
}
#
endif
