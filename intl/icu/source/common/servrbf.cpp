#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_SERVICE
#
include
"
unicode
/
resbund
.
h
"
#
include
"
uresimp
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
servloc
.
h
"
#
include
"
ustrfmt
.
h
"
#
include
"
uhash
.
h
"
#
include
"
charstr
.
h
"
#
include
"
ucln_cmn
.
h
"
#
include
"
uassert
.
h
"
#
define
UNDERSCORE_CHAR
(
(
char16_t
)
0x005f
)
#
define
AT_SIGN_CHAR
(
(
char16_t
)
64
)
#
define
PERIOD_CHAR
(
(
char16_t
)
46
)
U_NAMESPACE_BEGIN
ICUResourceBundleFactory
:
:
ICUResourceBundleFactory
(
)
:
LocaleKeyFactory
(
VISIBLE
)
_bundleName
(
)
{
}
ICUResourceBundleFactory
:
:
ICUResourceBundleFactory
(
const
UnicodeString
&
bundleName
)
:
LocaleKeyFactory
(
VISIBLE
)
_bundleName
(
bundleName
)
{
}
ICUResourceBundleFactory
:
:
~
ICUResourceBundleFactory
(
)
{
}
const
Hashtable
*
ICUResourceBundleFactory
:
:
getSupportedIDs
(
UErrorCode
&
status
)
const
{
if
(
U_SUCCESS
(
status
)
)
{
return
LocaleUtility
:
:
getAvailableLocaleNames
(
_bundleName
)
;
}
return
nullptr
;
}
UObject
*
ICUResourceBundleFactory
:
:
handleCreate
(
const
Locale
&
loc
int32_t
const
ICUService
*
UErrorCode
&
status
)
const
{
if
(
U_SUCCESS
(
status
)
)
{
char
pkg
[
20
]
;
int32_t
length
;
length
=
_bundleName
.
extract
(
0
INT32_MAX
pkg
static_cast
<
int32_t
>
(
sizeof
(
pkg
)
)
US_INV
)
;
if
(
length
>
=
static_cast
<
int32_t
>
(
sizeof
(
pkg
)
)
)
{
return
nullptr
;
}
return
new
ResourceBundle
(
pkg
loc
status
)
;
}
return
nullptr
;
}
#
ifdef
SERVICE_DEBUG
UnicodeString
&
ICUResourceBundleFactory
:
:
debug
(
UnicodeString
&
result
)
const
{
LocaleKeyFactory
:
:
debug
(
result
)
;
result
.
append
(
(
UnicodeString
)
"
bundle
:
"
)
;
return
result
.
append
(
_bundleName
)
;
}
UnicodeString
&
ICUResourceBundleFactory
:
:
debugClass
(
UnicodeString
&
result
)
const
{
return
result
.
append
(
(
UnicodeString
)
"
ICUResourceBundleFactory
"
)
;
}
#
endif
UOBJECT_DEFINE_RTTI_IMPLEMENTATION
(
ICUResourceBundleFactory
)
U_NAMESPACE_END
#
endif
