#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
uset
.
h
"
#
include
"
unicode
/
udata
.
h
"
#
include
"
ucmndata
.
h
"
#
include
"
udatamem
.
h
"
#
include
"
uassert
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
utrie2
.
h
"
#
include
"
ubidi_props
.
h
"
#
include
"
ucln_cmn
.
h
"
struct
UBiDiProps
{
UDataMemory
*
mem
;
const
int32_t
*
indexes
;
const
uint32_t
*
mirrors
;
const
uint8_t
*
jgArray
;
const
uint8_t
*
jgArray2
;
UTrie2
trie
;
uint8_t
formatVersion
[
4
]
;
}
;
#
define
INCLUDED_FROM_UBIDI_PROPS_C
#
include
"
ubidi_props_data
.
h
"
static
UBool
U_CALLCONV
_enumPropertyStartsRange
(
const
void
*
context
UChar32
start
UChar32
end
uint32_t
value
)
{
(
void
)
end
;
(
void
)
value
;
const
USetAdder
*
sa
=
(
const
USetAdder
*
)
context
;
sa
-
>
add
(
sa
-
>
set
start
)
;
return
true
;
}
U_CFUNC
void
ubidi_addPropertyStarts
(
const
USetAdder
*
sa
UErrorCode
*
pErrorCode
)
{
int32_t
i
length
;
UChar32
c
start
limit
;
const
uint8_t
*
jgArray
;
uint8_t
prev
jg
;
if
(
U_FAILURE
(
*
pErrorCode
)
)
{
return
;
}
utrie2_enum
(
&
ubidi_props_singleton
.
trie
nullptr
_enumPropertyStartsRange
sa
)
;
length
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_MIRROR_LENGTH
]
;
for
(
i
=
0
;
i
<
length
;
+
+
i
)
{
c
=
UBIDI_GET_MIRROR_CODE_POINT
(
ubidi_props_singleton
.
mirrors
[
i
]
)
;
sa
-
>
addRange
(
sa
-
>
set
c
c
+
1
)
;
}
start
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_JG_START
]
;
limit
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_JG_LIMIT
]
;
jgArray
=
ubidi_props_singleton
.
jgArray
;
for
(
;
;
)
{
prev
=
0
;
while
(
start
<
limit
)
{
jg
=
*
jgArray
+
+
;
if
(
jg
!
=
prev
)
{
sa
-
>
add
(
sa
-
>
set
start
)
;
prev
=
jg
;
}
+
+
start
;
}
if
(
prev
!
=
0
)
{
sa
-
>
add
(
sa
-
>
set
limit
)
;
}
if
(
limit
=
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_JG_LIMIT
]
)
{
start
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_JG_START2
]
;
limit
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_JG_LIMIT2
]
;
jgArray
=
ubidi_props_singleton
.
jgArray2
;
}
else
{
break
;
}
}
}
U_CFUNC
int32_t
ubidi_getMaxValue
(
UProperty
which
)
{
int32_t
max
=
ubidi_props_singleton
.
indexes
[
UBIDI_MAX_VALUES_INDEX
]
;
switch
(
which
)
{
case
UCHAR_BIDI_CLASS
:
return
(
max
&
UBIDI_CLASS_MASK
)
;
case
UCHAR_JOINING_GROUP
:
return
(
max
&
UBIDI_MAX_JG_MASK
)
>
>
UBIDI_MAX_JG_SHIFT
;
case
UCHAR_JOINING_TYPE
:
return
(
max
&
UBIDI_JT_MASK
)
>
>
UBIDI_JT_SHIFT
;
case
UCHAR_BIDI_PAIRED_BRACKET_TYPE
:
return
(
max
&
UBIDI_BPT_MASK
)
>
>
UBIDI_BPT_SHIFT
;
default
:
return
-
1
;
}
}
U_CAPI
UCharDirection
ubidi_getClass
(
UChar32
c
)
{
uint16_t
props
=
UTRIE2_GET16
(
&
ubidi_props_singleton
.
trie
c
)
;
return
(
UCharDirection
)
UBIDI_GET_CLASS
(
props
)
;
}
U_CFUNC
UBool
ubidi_isMirrored
(
UChar32
c
)
{
uint16_t
props
=
UTRIE2_GET16
(
&
ubidi_props_singleton
.
trie
c
)
;
return
(
UBool
)
UBIDI_GET_FLAG
(
props
UBIDI_IS_MIRRORED_SHIFT
)
;
}
static
UChar32
getMirror
(
UChar32
c
uint16_t
props
)
{
int32_t
delta
=
UBIDI_GET_MIRROR_DELTA
(
props
)
;
if
(
delta
!
=
UBIDI_ESC_MIRROR_DELTA
)
{
return
c
+
delta
;
}
else
{
const
uint32_t
*
mirrors
;
uint32_t
m
;
int32_t
i
length
;
UChar32
c2
;
mirrors
=
ubidi_props_singleton
.
mirrors
;
length
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_MIRROR_LENGTH
]
;
for
(
i
=
0
;
i
<
length
;
+
+
i
)
{
m
=
mirrors
[
i
]
;
c2
=
UBIDI_GET_MIRROR_CODE_POINT
(
m
)
;
if
(
c
=
=
c2
)
{
return
UBIDI_GET_MIRROR_CODE_POINT
(
mirrors
[
UBIDI_GET_MIRROR_INDEX
(
m
)
]
)
;
}
else
if
(
c
<
c2
)
{
break
;
}
}
return
c
;
}
}
U_CFUNC
UChar32
ubidi_getMirror
(
UChar32
c
)
{
uint16_t
props
=
UTRIE2_GET16
(
&
ubidi_props_singleton
.
trie
c
)
;
return
getMirror
(
c
props
)
;
}
U_CFUNC
UBool
ubidi_isBidiControl
(
UChar32
c
)
{
uint16_t
props
=
UTRIE2_GET16
(
&
ubidi_props_singleton
.
trie
c
)
;
return
(
UBool
)
UBIDI_GET_FLAG
(
props
UBIDI_BIDI_CONTROL_SHIFT
)
;
}
U_CFUNC
UBool
ubidi_isJoinControl
(
UChar32
c
)
{
uint16_t
props
=
UTRIE2_GET16
(
&
ubidi_props_singleton
.
trie
c
)
;
return
(
UBool
)
UBIDI_GET_FLAG
(
props
UBIDI_JOIN_CONTROL_SHIFT
)
;
}
U_CFUNC
UJoiningType
ubidi_getJoiningType
(
UChar32
c
)
{
uint16_t
props
=
UTRIE2_GET16
(
&
ubidi_props_singleton
.
trie
c
)
;
return
(
UJoiningType
)
(
(
props
&
UBIDI_JT_MASK
)
>
>
UBIDI_JT_SHIFT
)
;
}
U_CFUNC
UJoiningGroup
ubidi_getJoiningGroup
(
UChar32
c
)
{
UChar32
start
limit
;
start
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_JG_START
]
;
limit
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_JG_LIMIT
]
;
if
(
start
<
=
c
&
&
c
<
limit
)
{
return
(
UJoiningGroup
)
ubidi_props_singleton
.
jgArray
[
c
-
start
]
;
}
start
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_JG_START2
]
;
limit
=
ubidi_props_singleton
.
indexes
[
UBIDI_IX_JG_LIMIT2
]
;
if
(
start
<
=
c
&
&
c
<
limit
)
{
return
(
UJoiningGroup
)
ubidi_props_singleton
.
jgArray2
[
c
-
start
]
;
}
return
U_JG_NO_JOINING_GROUP
;
}
U_CFUNC
UBidiPairedBracketType
ubidi_getPairedBracketType
(
UChar32
c
)
{
uint16_t
props
=
UTRIE2_GET16
(
&
ubidi_props_singleton
.
trie
c
)
;
return
(
UBidiPairedBracketType
)
(
(
props
&
UBIDI_BPT_MASK
)
>
>
UBIDI_BPT_SHIFT
)
;
}
U_CFUNC
UChar32
ubidi_getPairedBracket
(
UChar32
c
)
{
uint16_t
props
=
UTRIE2_GET16
(
&
ubidi_props_singleton
.
trie
c
)
;
if
(
(
props
&
UBIDI_BPT_MASK
)
=
=
0
)
{
return
c
;
}
else
{
return
getMirror
(
c
props
)
;
}
}
U_CFUNC
UCharDirection
u_charDirection
(
UChar32
c
)
{
return
ubidi_getClass
(
c
)
;
}
U_CFUNC
UBool
u_isMirrored
(
UChar32
c
)
{
return
ubidi_isMirrored
(
c
)
;
}
U_CFUNC
UChar32
u_charMirror
(
UChar32
c
)
{
return
ubidi_getMirror
(
c
)
;
}
U_CAPI
UChar32
U_EXPORT2
u_getBidiPairedBracket
(
UChar32
c
)
{
return
ubidi_getPairedBracket
(
c
)
;
}
