#
ifndef
__RBBIDATA_H__
#
define
__RBBIDATA_H__
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
udata
.
h
"
#
include
"
udataswp
.
h
"
U_CAPI
int32_t
U_EXPORT2
ubrk_swap
(
const
UDataSwapper
*
ds
const
void
*
inData
int32_t
length
void
*
outData
UErrorCode
*
pErrorCode
)
;
#
ifdef
__cplusplus
#
include
"
unicode
/
ucptrie
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
include
"
unicode
/
uversion
.
h
"
#
include
"
umutex
.
h
"
U_NAMESPACE_BEGIN
static
const
uint8_t
RBBI_DATA_FORMAT_VERSION
[
]
=
{
6
0
0
0
}
;
struct
RBBIDataHeader
{
uint32_t
fMagic
;
UVersionInfo
fFormatVersion
;
uint32_t
fLength
;
uint32_t
fCatCount
;
uint32_t
fFTable
;
uint32_t
fFTableLen
;
uint32_t
fRTable
;
uint32_t
fRTableLen
;
uint32_t
fTrie
;
uint32_t
fTrieLen
;
uint32_t
fRuleSource
;
uint32_t
fRuleSourceLen
;
uint32_t
fStatusTable
;
uint32_t
fStatusTableLen
;
uint32_t
fReserved
[
6
]
;
}
;
template
<
typename
T
>
struct
RBBIStateTableRowT
{
T
fAccepting
;
T
fLookAhead
;
T
fTagsIdx
;
T
fNextState
[
1
]
;
}
;
typedef
RBBIStateTableRowT
<
uint8_t
>
RBBIStateTableRow8
;
typedef
RBBIStateTableRowT
<
uint16_t
>
RBBIStateTableRow16
;
constexpr
uint16_t
ACCEPTING_UNCONDITIONAL
=
1
;
union
RBBIStateTableRow
{
RBBIStateTableRow16
r16
;
RBBIStateTableRow8
r8
;
}
;
struct
RBBIStateTable
{
uint32_t
fNumStates
;
uint32_t
fRowLen
;
uint32_t
fDictCategoriesStart
;
uint32_t
fLookAheadResultsSize
;
uint32_t
fFlags
;
char
fTableData
[
1
]
;
}
;
constexpr
uint32_t
RBBI_LOOKAHEAD_HARD_BREAK
=
1
;
constexpr
uint32_t
RBBI_BOF_REQUIRED
=
2
;
constexpr
uint32_t
RBBI_8BITS_ROWS
=
4
;
class
RBBIDataWrapper
:
public
UMemory
{
public
:
enum
EDontAdopt
{
kDontAdopt
}
;
RBBIDataWrapper
(
const
RBBIDataHeader
*
data
UErrorCode
&
status
)
;
RBBIDataWrapper
(
const
RBBIDataHeader
*
data
enum
EDontAdopt
dontAdopt
UErrorCode
&
status
)
;
RBBIDataWrapper
(
UDataMemory
*
udm
UErrorCode
&
status
)
;
~
RBBIDataWrapper
(
)
;
static
UBool
isDataVersionAcceptable
(
const
UVersionInfo
version
)
;
void
init0
(
)
;
void
init
(
const
RBBIDataHeader
*
data
UErrorCode
&
status
)
;
RBBIDataWrapper
*
addReference
(
)
;
void
removeReference
(
)
;
bool
operator
=
=
(
const
RBBIDataWrapper
&
other
)
const
;
int32_t
hashCode
(
)
;
const
UnicodeString
&
getRuleSourceString
(
)
const
;
void
printData
(
)
;
void
printTable
(
const
char
*
heading
const
RBBIStateTable
*
table
)
;
const
RBBIDataHeader
*
fHeader
;
const
RBBIStateTable
*
fForwardTable
;
const
RBBIStateTable
*
fReverseTable
;
const
char
*
fRuleSource
;
const
int32_t
*
fRuleStatusTable
;
int32_t
fStatusMaxIdx
;
UCPTrie
*
fTrie
;
private
:
u_atomic_int32_t
fRefCount
;
UDataMemory
*
fUDataMem
;
UnicodeString
fRuleString
;
UBool
fDontFreeData
;
RBBIDataWrapper
(
const
RBBIDataWrapper
&
other
)
=
delete
;
RBBIDataWrapper
&
operator
=
(
const
RBBIDataWrapper
&
other
)
=
delete
;
}
;
U_NAMESPACE_END
U_CFUNC
UBool
rbbi_cleanup
(
)
;
#
endif
#
endif
