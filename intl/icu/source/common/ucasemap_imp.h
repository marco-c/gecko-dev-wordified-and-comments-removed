#
ifndef
__UCASEMAP_IMP_H__
#
define
__UCASEMAP_IMP_H__
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
ucasemap
.
h
"
#
include
"
ucase
.
h
"
#
ifndef
U_COMPARE_IGNORE_CASE
#
define
U_COMPARE_IGNORE_CASE
0x10000
#
endif
U_CFUNC
int32_t
u_strcmpFold
(
const
UChar
*
s1
int32_t
length1
const
UChar
*
s2
int32_t
length2
uint32_t
options
UErrorCode
*
pErrorCode
)
;
U_CAPI
void
u_caseInsensitivePrefixMatch
(
const
UChar
*
s1
int32_t
length1
const
UChar
*
s2
int32_t
length2
uint32_t
options
int32_t
*
matchLen1
int32_t
*
matchLen2
UErrorCode
*
pErrorCode
)
;
U_CFUNC
UBool
uprv_haveProperties
(
UErrorCode
*
pErrorCode
)
;
#
ifdef
__cplusplus
#
include
"
unicode
/
unistr
.
h
"
struct
UCaseMap
:
public
icu
:
:
UMemory
{
UCaseMap
(
const
char
*
localeID
uint32_t
opts
UErrorCode
*
pErrorCode
)
;
~
UCaseMap
(
)
;
#
if
!
UCONFIG_NO_BREAK_ITERATION
icu
:
:
BreakIterator
*
iter
;
#
endif
char
locale
[
32
]
;
int32_t
caseLocale
;
uint32_t
options
;
}
;
#
if
UCONFIG_NO_BREAK_ITERATION
#
define
UCASEMAP_BREAK_ITERATOR_PARAM
#
define
UCASEMAP_BREAK_ITERATOR_UNUSED
#
define
UCASEMAP_BREAK_ITERATOR
#
define
UCASEMAP_BREAK_ITERATOR_NULL
#
else
#
define
UCASEMAP_BREAK_ITERATOR_PARAM
icu
:
:
BreakIterator
*
iter
#
define
UCASEMAP_BREAK_ITERATOR_UNUSED
icu
:
:
BreakIterator
*
#
define
UCASEMAP_BREAK_ITERATOR
iter
#
define
UCASEMAP_BREAK_ITERATOR_NULL
NULL
#
endif
U_CFUNC
int32_t
ustrcase_getCaseLocale
(
const
char
*
locale
)
;
U_CFUNC
int32_t
U_CALLCONV
ustrcase_internalToLower
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_PARAM
UChar
*
dest
int32_t
destCapacity
const
UChar
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
;
U_CFUNC
int32_t
U_CALLCONV
ustrcase_internalToUpper
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_PARAM
UChar
*
dest
int32_t
destCapacity
const
UChar
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
;
#
if
!
UCONFIG_NO_BREAK_ITERATION
U_CFUNC
int32_t
U_CALLCONV
ustrcase_internalToTitle
(
int32_t
caseLocale
uint32_t
options
icu
:
:
BreakIterator
*
iter
UChar
*
dest
int32_t
destCapacity
const
UChar
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
;
#
endif
U_CFUNC
int32_t
U_CALLCONV
ustrcase_internalFold
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_PARAM
UChar
*
dest
int32_t
destCapacity
const
UChar
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
;
U_CFUNC
int32_t
ustrcase_map
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_PARAM
UChar
*
dest
int32_t
destCapacity
const
UChar
*
src
int32_t
srcLength
UStringCaseMapper
*
stringCaseMapper
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
;
U_CFUNC
int32_t
ustrcase_mapWithOverlap
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_PARAM
UChar
*
dest
int32_t
destCapacity
const
UChar
*
src
int32_t
srcLength
UStringCaseMapper
*
stringCaseMapper
UErrorCode
&
errorCode
)
;
typedef
int32_t
U_CALLCONV
UTF8CaseMapper
(
int32_t
caseLocale
uint32_t
options
#
if
!
UCONFIG_NO_BREAK_ITERATION
icu
:
:
BreakIterator
*
iter
#
endif
uint8_t
*
dest
int32_t
destCapacity
const
uint8_t
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
;
#
if
!
UCONFIG_NO_BREAK_ITERATION
U_CFUNC
int32_t
U_CALLCONV
ucasemap_internalUTF8ToTitle
(
int32_t
caseLocale
uint32_t
options
icu
:
:
BreakIterator
*
iter
uint8_t
*
dest
int32_t
destCapacity
const
uint8_t
*
src
int32_t
srcLength
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
;
#
endif
U_CFUNC
int32_t
ucasemap_mapUTF8
(
int32_t
caseLocale
uint32_t
options
UCASEMAP_BREAK_ITERATOR_PARAM
uint8_t
*
dest
int32_t
destCapacity
const
uint8_t
*
src
int32_t
srcLength
UTF8CaseMapper
*
stringCaseMapper
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
;
U_NAMESPACE_BEGIN
namespace
GreekUpper
{
static
const
uint32_t
UPPER_MASK
=
0x3ff
;
static
const
uint32_t
HAS_VOWEL
=
0x1000
;
static
const
uint32_t
HAS_YPOGEGRAMMENI
=
0x2000
;
static
const
uint32_t
HAS_ACCENT
=
0x4000
;
static
const
uint32_t
HAS_DIALYTIKA
=
0x8000
;
static
const
uint32_t
HAS_COMBINING_DIALYTIKA
=
0x10000
;
static
const
uint32_t
HAS_OTHER_GREEK_DIACRITIC
=
0x20000
;
static
const
uint32_t
HAS_VOWEL_AND_ACCENT
=
HAS_VOWEL
|
HAS_ACCENT
;
static
const
uint32_t
HAS_VOWEL_AND_ACCENT_AND_DIALYTIKA
=
HAS_VOWEL_AND_ACCENT
|
HAS_DIALYTIKA
;
static
const
uint32_t
HAS_EITHER_DIALYTIKA
=
HAS_DIALYTIKA
|
HAS_COMBINING_DIALYTIKA
;
static
const
uint32_t
AFTER_CASED
=
1
;
static
const
uint32_t
AFTER_VOWEL_WITH_ACCENT
=
2
;
uint32_t
getLetterData
(
UChar32
c
)
;
uint32_t
getDiacriticData
(
UChar32
c
)
;
}
U_NAMESPACE_END
#
endif
#
endif
