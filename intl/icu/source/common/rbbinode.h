#
ifndef
RBBINODE_H
#
define
RBBINODE_H
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
include
"
unicode
/
uobject
.
h
"
U_NAMESPACE_BEGIN
class
UnicodeSet
;
class
UVector
;
class
RBBINode
:
public
UMemory
{
public
:
enum
NodeType
{
setRef
uset
varRef
leafChar
lookAhead
tag
endMark
opStart
opCat
opOr
opStar
opPlus
opQuestion
opBreak
opReverse
opLParen
}
;
enum
OpPrecedence
{
precZero
precStart
precLParen
precOpOr
precOpCat
}
;
NodeType
fType
;
RBBINode
*
fParent
;
RBBINode
*
fLeftChild
;
RBBINode
*
fRightChild
;
UnicodeSet
*
fInputSet
;
OpPrecedence
fPrecedence
;
UnicodeString
fText
;
int
fFirstPos
;
int
fLastPos
;
UBool
fNullable
;
int32_t
fVal
;
UBool
fLookAheadEnd
;
UBool
fRuleRoot
;
UBool
fChainIn
;
UVector
*
fFirstPosSet
;
UVector
*
fLastPosSet
;
UVector
*
fFollowPos
;
RBBINode
(
NodeType
t
)
;
RBBINode
(
const
RBBINode
&
other
)
;
~
RBBINode
(
)
;
static
void
NRDeleteNode
(
RBBINode
*
node
)
;
RBBINode
*
cloneTree
(
)
;
RBBINode
*
flattenVariables
(
UErrorCode
&
status
int
depth
=
0
)
;
void
flattenSets
(
)
;
void
findNodes
(
UVector
*
dest
RBBINode
:
:
NodeType
kind
UErrorCode
&
status
)
;
#
ifdef
RBBI_DEBUG
static
void
printNodeHeader
(
)
;
static
void
printNode
(
const
RBBINode
*
n
)
;
static
void
printTree
(
const
RBBINode
*
n
UBool
withHeading
)
;
#
endif
private
:
RBBINode
&
operator
=
(
const
RBBINode
&
other
)
;
bool
operator
=
=
(
const
RBBINode
&
other
)
;
#
ifdef
RBBI_DEBUG
public
:
int
fSerialNum
;
#
endif
}
;
#
ifdef
RBBI_DEBUG
U_CFUNC
void
RBBI_DEBUG_printUnicodeString
(
const
UnicodeString
&
s
int
minWidth
=
0
)
;
#
endif
U_NAMESPACE_END
#
endif
