#
ifndef
__LOCALPOINTER_H__
#
define
__LOCALPOINTER_H__
#
include
"
unicode
/
utypes
.
h
"
#
if
U_SHOW_CPLUSPLUS_API
U_NAMESPACE_BEGIN
template
<
typename
T
>
class
LocalPointerBase
{
public
:
explicit
LocalPointerBase
(
T
*
p
=
NULL
)
:
ptr
(
p
)
{
}
~
LocalPointerBase
(
)
{
}
UBool
isNull
(
)
const
{
return
ptr
=
=
NULL
;
}
UBool
isValid
(
)
const
{
return
ptr
!
=
NULL
;
}
bool
operator
=
=
(
const
T
*
other
)
const
{
return
ptr
=
=
other
;
}
bool
operator
!
=
(
const
T
*
other
)
const
{
return
ptr
!
=
other
;
}
T
*
getAlias
(
)
const
{
return
ptr
;
}
T
&
operator
*
(
)
const
{
return
*
ptr
;
}
T
*
operator
-
>
(
)
const
{
return
ptr
;
}
T
*
orphan
(
)
{
T
*
p
=
ptr
;
ptr
=
NULL
;
return
p
;
}
void
adoptInstead
(
T
*
p
)
{
ptr
=
p
;
}
protected
:
T
*
ptr
;
private
:
bool
operator
=
=
(
const
LocalPointerBase
<
T
>
&
other
)
;
bool
operator
!
=
(
const
LocalPointerBase
<
T
>
&
other
)
;
LocalPointerBase
(
const
LocalPointerBase
<
T
>
&
other
)
;
void
operator
=
(
const
LocalPointerBase
<
T
>
&
other
)
;
static
void
*
U_EXPORT2
operator
new
(
size_t
size
)
;
static
void
*
U_EXPORT2
operator
new
[
]
(
size_t
size
)
;
#
if
U_HAVE_PLACEMENT_NEW
static
void
*
U_EXPORT2
operator
new
(
size_t
void
*
ptr
)
;
#
endif
}
;
template
<
typename
T
>
class
LocalPointer
:
public
LocalPointerBase
<
T
>
{
public
:
using
LocalPointerBase
<
T
>
:
:
operator
*
;
using
LocalPointerBase
<
T
>
:
:
operator
-
>
;
explicit
LocalPointer
(
T
*
p
=
NULL
)
:
LocalPointerBase
<
T
>
(
p
)
{
}
LocalPointer
(
T
*
p
UErrorCode
&
errorCode
)
:
LocalPointerBase
<
T
>
(
p
)
{
if
(
p
=
=
NULL
&
&
U_SUCCESS
(
errorCode
)
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
}
}
#
if
U_HAVE_RVALUE_REFERENCES
LocalPointer
(
LocalPointer
<
T
>
&
&
src
)
U_NOEXCEPT
:
LocalPointerBase
<
T
>
(
src
.
ptr
)
{
src
.
ptr
=
NULL
;
}
#
endif
~
LocalPointer
(
)
{
delete
LocalPointerBase
<
T
>
:
:
ptr
;
}
#
if
U_HAVE_RVALUE_REFERENCES
LocalPointer
<
T
>
&
operator
=
(
LocalPointer
<
T
>
&
&
src
)
U_NOEXCEPT
{
return
moveFrom
(
src
)
;
}
#
endif
LocalPointer
<
T
>
&
moveFrom
(
LocalPointer
<
T
>
&
src
)
U_NOEXCEPT
{
delete
LocalPointerBase
<
T
>
:
:
ptr
;
LocalPointerBase
<
T
>
:
:
ptr
=
src
.
ptr
;
src
.
ptr
=
NULL
;
return
*
this
;
}
void
swap
(
LocalPointer
<
T
>
&
other
)
U_NOEXCEPT
{
T
*
temp
=
LocalPointerBase
<
T
>
:
:
ptr
;
LocalPointerBase
<
T
>
:
:
ptr
=
other
.
ptr
;
other
.
ptr
=
temp
;
}
friend
inline
void
swap
(
LocalPointer
<
T
>
&
p1
LocalPointer
<
T
>
&
p2
)
U_NOEXCEPT
{
p1
.
swap
(
p2
)
;
}
void
adoptInstead
(
T
*
p
)
{
delete
LocalPointerBase
<
T
>
:
:
ptr
;
LocalPointerBase
<
T
>
:
:
ptr
=
p
;
}
void
adoptInsteadAndCheckErrorCode
(
T
*
p
UErrorCode
&
errorCode
)
{
if
(
U_SUCCESS
(
errorCode
)
)
{
delete
LocalPointerBase
<
T
>
:
:
ptr
;
LocalPointerBase
<
T
>
:
:
ptr
=
p
;
if
(
p
=
=
NULL
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
}
}
else
{
delete
p
;
}
}
}
;
template
<
typename
T
>
class
LocalArray
:
public
LocalPointerBase
<
T
>
{
public
:
using
LocalPointerBase
<
T
>
:
:
operator
*
;
using
LocalPointerBase
<
T
>
:
:
operator
-
>
;
explicit
LocalArray
(
T
*
p
=
NULL
)
:
LocalPointerBase
<
T
>
(
p
)
{
}
LocalArray
(
T
*
p
UErrorCode
&
errorCode
)
:
LocalPointerBase
<
T
>
(
p
)
{
if
(
p
=
=
NULL
&
&
U_SUCCESS
(
errorCode
)
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
}
}
#
if
U_HAVE_RVALUE_REFERENCES
LocalArray
(
LocalArray
<
T
>
&
&
src
)
U_NOEXCEPT
:
LocalPointerBase
<
T
>
(
src
.
ptr
)
{
src
.
ptr
=
NULL
;
}
#
endif
~
LocalArray
(
)
{
delete
[
]
LocalPointerBase
<
T
>
:
:
ptr
;
}
#
if
U_HAVE_RVALUE_REFERENCES
LocalArray
<
T
>
&
operator
=
(
LocalArray
<
T
>
&
&
src
)
U_NOEXCEPT
{
return
moveFrom
(
src
)
;
}
#
endif
LocalArray
<
T
>
&
moveFrom
(
LocalArray
<
T
>
&
src
)
U_NOEXCEPT
{
delete
[
]
LocalPointerBase
<
T
>
:
:
ptr
;
LocalPointerBase
<
T
>
:
:
ptr
=
src
.
ptr
;
src
.
ptr
=
NULL
;
return
*
this
;
}
void
swap
(
LocalArray
<
T
>
&
other
)
U_NOEXCEPT
{
T
*
temp
=
LocalPointerBase
<
T
>
:
:
ptr
;
LocalPointerBase
<
T
>
:
:
ptr
=
other
.
ptr
;
other
.
ptr
=
temp
;
}
friend
inline
void
swap
(
LocalArray
<
T
>
&
p1
LocalArray
<
T
>
&
p2
)
U_NOEXCEPT
{
p1
.
swap
(
p2
)
;
}
void
adoptInstead
(
T
*
p
)
{
delete
[
]
LocalPointerBase
<
T
>
:
:
ptr
;
LocalPointerBase
<
T
>
:
:
ptr
=
p
;
}
void
adoptInsteadAndCheckErrorCode
(
T
*
p
UErrorCode
&
errorCode
)
{
if
(
U_SUCCESS
(
errorCode
)
)
{
delete
[
]
LocalPointerBase
<
T
>
:
:
ptr
;
LocalPointerBase
<
T
>
:
:
ptr
=
p
;
if
(
p
=
=
NULL
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
}
}
else
{
delete
[
]
p
;
}
}
T
&
operator
[
]
(
ptrdiff_t
i
)
const
{
return
LocalPointerBase
<
T
>
:
:
ptr
[
i
]
;
}
}
;
#
if
U_HAVE_RVALUE_REFERENCES
#
define
U_DEFINE_LOCAL_OPEN_POINTER
(
LocalPointerClassName
Type
closeFunction
)
\
class
LocalPointerClassName
:
public
LocalPointerBase
<
Type
>
{
\
public
:
\
using
LocalPointerBase
<
Type
>
:
:
operator
*
;
\
using
LocalPointerBase
<
Type
>
:
:
operator
-
>
;
\
explicit
LocalPointerClassName
(
Type
*
p
=
NULL
)
:
LocalPointerBase
<
Type
>
(
p
)
{
}
\
LocalPointerClassName
(
LocalPointerClassName
&
&
src
)
U_NOEXCEPT
\
:
LocalPointerBase
<
Type
>
(
src
.
ptr
)
{
\
src
.
ptr
=
NULL
;
\
}
\
~
LocalPointerClassName
(
)
{
if
(
ptr
!
=
NULL
)
{
closeFunction
(
ptr
)
;
}
}
\
LocalPointerClassName
&
operator
=
(
LocalPointerClassName
&
&
src
)
U_NOEXCEPT
{
\
return
moveFrom
(
src
)
;
\
}
\
LocalPointerClassName
&
moveFrom
(
LocalPointerClassName
&
src
)
U_NOEXCEPT
{
\
if
(
ptr
!
=
NULL
)
{
closeFunction
(
ptr
)
;
}
\
LocalPointerBase
<
Type
>
:
:
ptr
=
src
.
ptr
;
\
src
.
ptr
=
NULL
;
\
return
*
this
;
\
}
\
void
swap
(
LocalPointerClassName
&
other
)
U_NOEXCEPT
{
\
Type
*
temp
=
LocalPointerBase
<
Type
>
:
:
ptr
;
\
LocalPointerBase
<
Type
>
:
:
ptr
=
other
.
ptr
;
\
other
.
ptr
=
temp
;
\
}
\
friend
inline
void
swap
(
LocalPointerClassName
&
p1
LocalPointerClassName
&
p2
)
U_NOEXCEPT
{
\
p1
.
swap
(
p2
)
;
\
}
\
void
adoptInstead
(
Type
*
p
)
{
\
if
(
ptr
!
=
NULL
)
{
closeFunction
(
ptr
)
;
}
\
ptr
=
p
;
\
}
\
}
#
else
#
define
U_DEFINE_LOCAL_OPEN_POINTER
(
LocalPointerClassName
Type
closeFunction
)
\
class
LocalPointerClassName
:
public
LocalPointerBase
<
Type
>
{
\
public
:
\
using
LocalPointerBase
<
Type
>
:
:
operator
*
;
\
using
LocalPointerBase
<
Type
>
:
:
operator
-
>
;
\
explicit
LocalPointerClassName
(
Type
*
p
=
NULL
)
:
LocalPointerBase
<
Type
>
(
p
)
{
}
\
~
LocalPointerClassName
(
)
{
closeFunction
(
ptr
)
;
}
\
LocalPointerClassName
&
moveFrom
(
LocalPointerClassName
&
src
)
U_NOEXCEPT
{
\
if
(
ptr
!
=
NULL
)
{
closeFunction
(
ptr
)
;
}
\
LocalPointerBase
<
Type
>
:
:
ptr
=
src
.
ptr
;
\
src
.
ptr
=
NULL
;
\
return
*
this
;
\
}
\
void
swap
(
LocalPointerClassName
&
other
)
U_NOEXCEPT
{
\
Type
*
temp
=
LocalPointerBase
<
Type
>
:
:
ptr
;
\
LocalPointerBase
<
Type
>
:
:
ptr
=
other
.
ptr
;
\
other
.
ptr
=
temp
;
\
}
\
friend
inline
void
swap
(
LocalPointerClassName
&
p1
LocalPointerClassName
&
p2
)
U_NOEXCEPT
{
\
p1
.
swap
(
p2
)
;
\
}
\
void
adoptInstead
(
Type
*
p
)
{
\
if
(
ptr
!
=
NULL
)
{
closeFunction
(
ptr
)
;
}
\
ptr
=
p
;
\
}
\
}
#
endif
U_NAMESPACE_END
#
endif
#
endif
