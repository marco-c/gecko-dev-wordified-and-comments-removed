#
ifndef
LOCID_H
#
define
LOCID_H
#
include
"
unicode
/
utypes
.
h
"
#
if
U_SHOW_CPLUSPLUS_API
#
include
"
unicode
/
bytestream
.
h
"
#
include
"
unicode
/
localpointer
.
h
"
#
include
"
unicode
/
strenum
.
h
"
#
include
"
unicode
/
stringpiece
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
unicode
/
putil
.
h
"
#
include
"
unicode
/
uloc
.
h
"
U_NAMESPACE_BEGIN
void
U_CALLCONV
locale_available_init
(
)
;
class
StringEnumeration
;
class
UnicodeString
;
class
U_COMMON_API
Locale
:
public
UObject
{
public
:
static
const
Locale
&
U_EXPORT2
getRoot
(
)
;
static
const
Locale
&
U_EXPORT2
getEnglish
(
)
;
static
const
Locale
&
U_EXPORT2
getFrench
(
)
;
static
const
Locale
&
U_EXPORT2
getGerman
(
)
;
static
const
Locale
&
U_EXPORT2
getItalian
(
)
;
static
const
Locale
&
U_EXPORT2
getJapanese
(
)
;
static
const
Locale
&
U_EXPORT2
getKorean
(
)
;
static
const
Locale
&
U_EXPORT2
getChinese
(
)
;
static
const
Locale
&
U_EXPORT2
getSimplifiedChinese
(
)
;
static
const
Locale
&
U_EXPORT2
getTraditionalChinese
(
)
;
static
const
Locale
&
U_EXPORT2
getFrance
(
)
;
static
const
Locale
&
U_EXPORT2
getGermany
(
)
;
static
const
Locale
&
U_EXPORT2
getItaly
(
)
;
static
const
Locale
&
U_EXPORT2
getJapan
(
)
;
static
const
Locale
&
U_EXPORT2
getKorea
(
)
;
static
const
Locale
&
U_EXPORT2
getChina
(
)
;
static
const
Locale
&
U_EXPORT2
getPRC
(
)
;
static
const
Locale
&
U_EXPORT2
getTaiwan
(
)
;
static
const
Locale
&
U_EXPORT2
getUK
(
)
;
static
const
Locale
&
U_EXPORT2
getUS
(
)
;
static
const
Locale
&
U_EXPORT2
getCanada
(
)
;
static
const
Locale
&
U_EXPORT2
getCanadaFrench
(
)
;
Locale
(
)
;
Locale
(
const
char
*
language
const
char
*
country
=
nullptr
const
char
*
variant
=
nullptr
const
char
*
keywordsAndValues
=
nullptr
)
;
Locale
(
const
Locale
&
other
)
;
Locale
(
Locale
&
&
other
)
noexcept
;
virtual
~
Locale
(
)
;
Locale
&
operator
=
(
const
Locale
&
other
)
;
Locale
&
operator
=
(
Locale
&
&
other
)
noexcept
;
bool
operator
=
=
(
const
Locale
&
other
)
const
;
inline
bool
operator
!
=
(
const
Locale
&
other
)
const
;
Locale
*
clone
(
)
const
;
#
ifndef
U_HIDE_SYSTEM_API
static
const
Locale
&
U_EXPORT2
getDefault
(
)
;
static
void
U_EXPORT2
setDefault
(
const
Locale
&
newLocale
UErrorCode
&
success
)
;
#
endif
static
Locale
U_EXPORT2
forLanguageTag
(
StringPiece
tag
UErrorCode
&
status
)
;
void
toLanguageTag
(
ByteSink
&
sink
UErrorCode
&
status
)
const
;
template
<
typename
StringClass
>
inline
StringClass
toLanguageTag
(
UErrorCode
&
status
)
const
;
static
Locale
U_EXPORT2
createFromName
(
const
char
*
name
)
;
static
Locale
U_EXPORT2
createCanonical
(
const
char
*
name
)
;
inline
const
char
*
getLanguage
(
)
const
;
inline
const
char
*
getScript
(
)
const
;
inline
const
char
*
getCountry
(
)
const
;
inline
const
char
*
getVariant
(
)
const
;
inline
const
char
*
getName
(
)
const
;
const
char
*
getBaseName
(
)
const
;
void
addLikelySubtags
(
UErrorCode
&
status
)
;
void
minimizeSubtags
(
UErrorCode
&
status
)
;
void
canonicalize
(
UErrorCode
&
status
)
;
StringEnumeration
*
createKeywords
(
UErrorCode
&
status
)
const
;
StringEnumeration
*
createUnicodeKeywords
(
UErrorCode
&
status
)
const
;
template
<
typename
StringClass
typename
OutputIterator
>
inline
void
getKeywords
(
OutputIterator
iterator
UErrorCode
&
status
)
const
;
template
<
typename
StringClass
typename
OutputIterator
>
inline
void
getUnicodeKeywords
(
OutputIterator
iterator
UErrorCode
&
status
)
const
;
int32_t
getKeywordValue
(
const
char
*
keywordName
char
*
buffer
int32_t
bufferCapacity
UErrorCode
&
status
)
const
;
void
getKeywordValue
(
StringPiece
keywordName
ByteSink
&
sink
UErrorCode
&
status
)
const
;
template
<
typename
StringClass
>
inline
StringClass
getKeywordValue
(
StringPiece
keywordName
UErrorCode
&
status
)
const
;
void
getUnicodeKeywordValue
(
StringPiece
keywordName
ByteSink
&
sink
UErrorCode
&
status
)
const
;
template
<
typename
StringClass
>
inline
StringClass
getUnicodeKeywordValue
(
StringPiece
keywordName
UErrorCode
&
status
)
const
;
void
setKeywordValue
(
const
char
*
keywordName
const
char
*
keywordValue
UErrorCode
&
status
)
{
setKeywordValue
(
StringPiece
{
keywordName
}
StringPiece
{
keywordValue
}
status
)
;
}
void
setKeywordValue
(
StringPiece
keywordName
StringPiece
keywordValue
UErrorCode
&
status
)
;
void
setUnicodeKeywordValue
(
StringPiece
keywordName
StringPiece
keywordValue
UErrorCode
&
status
)
;
const
char
*
getISO3Language
(
)
const
;
const
char
*
getISO3Country
(
)
const
;
uint32_t
getLCID
(
)
const
;
UBool
isRightToLeft
(
)
const
;
UnicodeString
&
getDisplayLanguage
(
UnicodeString
&
dispLang
)
const
;
UnicodeString
&
getDisplayLanguage
(
const
Locale
&
displayLocale
UnicodeString
&
dispLang
)
const
;
UnicodeString
&
getDisplayScript
(
UnicodeString
&
dispScript
)
const
;
UnicodeString
&
getDisplayScript
(
const
Locale
&
displayLocale
UnicodeString
&
dispScript
)
const
;
UnicodeString
&
getDisplayCountry
(
UnicodeString
&
dispCountry
)
const
;
UnicodeString
&
getDisplayCountry
(
const
Locale
&
displayLocale
UnicodeString
&
dispCountry
)
const
;
UnicodeString
&
getDisplayVariant
(
UnicodeString
&
dispVar
)
const
;
UnicodeString
&
getDisplayVariant
(
const
Locale
&
displayLocale
UnicodeString
&
dispVar
)
const
;
UnicodeString
&
getDisplayName
(
UnicodeString
&
name
)
const
;
UnicodeString
&
getDisplayName
(
const
Locale
&
displayLocale
UnicodeString
&
name
)
const
;
int32_t
hashCode
(
)
const
;
void
setToBogus
(
)
;
inline
UBool
isBogus
(
)
const
;
static
const
Locale
*
U_EXPORT2
getAvailableLocales
(
int32_t
&
count
)
;
static
const
char
*
const
*
U_EXPORT2
getISOCountries
(
)
;
static
const
char
*
const
*
U_EXPORT2
getISOLanguages
(
)
;
static
UClassID
U_EXPORT2
getStaticClassID
(
)
;
virtual
UClassID
getDynamicClassID
(
)
const
override
;
class
U_COMMON_API
Iterator
{
public
:
virtual
~
Iterator
(
)
;
virtual
UBool
hasNext
(
)
const
=
0
;
virtual
const
Locale
&
next
(
)
=
0
;
}
;
template
<
typename
Iter
>
class
RangeIterator
:
public
Iterator
public
UMemory
{
public
:
RangeIterator
(
Iter
begin
Iter
end
)
:
it_
(
begin
)
end_
(
end
)
{
}
UBool
hasNext
(
)
const
override
{
return
it_
!
=
end_
;
}
const
Locale
&
next
(
)
override
{
return
*
it_
+
+
;
}
private
:
Iter
it_
;
const
Iter
end_
;
}
;
template
<
typename
Iter
typename
Conv
>
class
ConvertingIterator
:
public
Iterator
public
UMemory
{
public
:
ConvertingIterator
(
Iter
begin
Iter
end
Conv
converter
)
:
it_
(
begin
)
end_
(
end
)
converter_
(
converter
)
{
}
UBool
hasNext
(
)
const
override
{
return
it_
!
=
end_
;
}
const
Locale
&
next
(
)
override
{
return
converter_
(
*
it_
+
+
)
;
}
private
:
Iter
it_
;
const
Iter
end_
;
Conv
converter_
;
}
;
protected
:
#
ifndef
U_HIDE_INTERNAL_API
void
setFromPOSIXID
(
const
char
*
posixID
)
;
void
minimizeSubtags
(
bool
favorScript
UErrorCode
&
status
)
;
#
endif
private
:
Locale
&
init
(
const
char
*
cLocaleID
UBool
canonicalize
)
;
enum
ELocaleType
{
eBOGUS
}
;
Locale
(
ELocaleType
)
;
static
Locale
*
getLocaleCache
(
)
;
char
language
[
ULOC_LANG_CAPACITY
]
;
char
script
[
ULOC_SCRIPT_CAPACITY
]
;
char
country
[
ULOC_COUNTRY_CAPACITY
]
;
int32_t
variantBegin
;
char
*
fullName
;
char
fullNameBuffer
[
ULOC_FULLNAME_CAPACITY
]
;
char
*
baseName
;
void
initBaseName
(
UErrorCode
&
status
)
;
UBool
fIsBogus
;
static
const
Locale
&
getLocale
(
int
locid
)
;
friend
Locale
*
locale_set_default_internal
(
const
char
*
UErrorCode
&
status
)
;
friend
void
U_CALLCONV
locale_available_init
(
)
;
}
;
inline
bool
Locale
:
:
operator
!
=
(
const
Locale
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
template
<
typename
StringClass
>
inline
StringClass
Locale
:
:
toLanguageTag
(
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
StringClass
result
;
StringByteSink
<
StringClass
>
sink
(
&
result
)
;
toLanguageTag
(
sink
status
)
;
return
result
;
}
inline
const
char
*
Locale
:
:
getCountry
(
)
const
{
return
country
;
}
inline
const
char
*
Locale
:
:
getLanguage
(
)
const
{
return
language
;
}
inline
const
char
*
Locale
:
:
getScript
(
)
const
{
return
script
;
}
inline
const
char
*
Locale
:
:
getVariant
(
)
const
{
return
fIsBogus
?
"
"
:
&
baseName
[
variantBegin
]
;
}
inline
const
char
*
Locale
:
:
getName
(
)
const
{
return
fullName
;
}
template
<
typename
StringClass
typename
OutputIterator
>
inline
void
Locale
:
:
getKeywords
(
OutputIterator
iterator
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
LocalPointer
<
StringEnumeration
>
keys
(
createKeywords
(
status
)
)
;
if
(
U_FAILURE
(
status
)
|
|
keys
.
isNull
(
)
)
{
return
;
}
for
(
;
;
)
{
int32_t
resultLength
;
const
char
*
buffer
=
keys
-
>
next
(
&
resultLength
status
)
;
if
(
U_FAILURE
(
status
)
|
|
buffer
=
=
nullptr
)
{
return
;
}
*
iterator
+
+
=
StringClass
(
buffer
resultLength
)
;
}
}
template
<
typename
StringClass
typename
OutputIterator
>
inline
void
Locale
:
:
getUnicodeKeywords
(
OutputIterator
iterator
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
;
}
LocalPointer
<
StringEnumeration
>
keys
(
createUnicodeKeywords
(
status
)
)
;
if
(
U_FAILURE
(
status
)
|
|
keys
.
isNull
(
)
)
{
return
;
}
for
(
;
;
)
{
int32_t
resultLength
;
const
char
*
buffer
=
keys
-
>
next
(
&
resultLength
status
)
;
if
(
U_FAILURE
(
status
)
|
|
buffer
=
=
nullptr
)
{
return
;
}
*
iterator
+
+
=
StringClass
(
buffer
resultLength
)
;
}
}
template
<
typename
StringClass
>
inline
StringClass
Locale
:
:
getKeywordValue
(
StringPiece
keywordName
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
StringClass
result
;
StringByteSink
<
StringClass
>
sink
(
&
result
)
;
getKeywordValue
(
keywordName
sink
status
)
;
return
result
;
}
template
<
typename
StringClass
>
inline
StringClass
Locale
:
:
getUnicodeKeywordValue
(
StringPiece
keywordName
UErrorCode
&
status
)
const
{
if
(
U_FAILURE
(
status
)
)
{
return
{
}
;
}
StringClass
result
;
StringByteSink
<
StringClass
>
sink
(
&
result
)
;
getUnicodeKeywordValue
(
keywordName
sink
status
)
;
return
result
;
}
inline
UBool
Locale
:
:
isBogus
(
)
const
{
return
fIsBogus
;
}
U_NAMESPACE_END
#
endif
#
endif
