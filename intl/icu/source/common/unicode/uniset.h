#
ifndef
UNICODESET_H
#
define
UNICODESET_H
#
include
"
unicode
/
utypes
.
h
"
#
if
U_SHOW_CPLUSPLUS_API
#
include
"
unicode
/
ucpmap
.
h
"
#
include
"
unicode
/
unifilt
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
include
"
unicode
/
uset
.
h
"
U_NAMESPACE_BEGIN
class
BMPSet
;
class
ParsePosition
;
class
RBBIRuleScanner
;
class
SymbolTable
;
class
UnicodeSetStringSpan
;
class
UVector
;
class
RuleCharacterIterator
;
class
U_COMMON_API
UnicodeSet
final
:
public
UnicodeFilter
{
private
:
static
constexpr
int32_t
INITIAL_CAPACITY
=
25
;
static
constexpr
uint8_t
kIsBogus
=
1
;
UChar32
*
list
=
stackList
;
int32_t
capacity
=
INITIAL_CAPACITY
;
int32_t
len
=
1
;
uint8_t
fFlags
=
0
;
BMPSet
*
bmpSet
=
nullptr
;
UChar32
*
buffer
=
nullptr
;
int32_t
bufferCapacity
=
0
;
char16_t
*
pat
=
nullptr
;
int32_t
patLen
=
0
;
UVector
*
strings_
=
nullptr
;
UnicodeSetStringSpan
*
stringSpan
=
nullptr
;
UChar32
stackList
[
INITIAL_CAPACITY
]
;
public
:
inline
UBool
isBogus
(
)
const
;
void
setToBogus
(
)
;
public
:
enum
{
MIN_VALUE
=
0
MAX_VALUE
=
0x10ffff
}
;
public
:
UnicodeSet
(
)
;
UnicodeSet
(
UChar32
start
UChar32
end
)
;
#
ifndef
U_HIDE_INTERNAL_API
enum
ESerialization
{
kSerialized
}
;
UnicodeSet
(
const
uint16_t
buffer
[
]
int32_t
bufferLen
ESerialization
serialization
UErrorCode
&
status
)
;
#
endif
UnicodeSet
(
const
UnicodeString
&
pattern
UErrorCode
&
status
)
;
#
ifndef
U_HIDE_INTERNAL_API
UnicodeSet
(
const
UnicodeString
&
pattern
uint32_t
options
const
SymbolTable
*
symbols
UErrorCode
&
status
)
;
#
endif
UnicodeSet
(
const
UnicodeString
&
pattern
ParsePosition
&
pos
uint32_t
options
const
SymbolTable
*
symbols
UErrorCode
&
status
)
;
UnicodeSet
(
const
UnicodeSet
&
o
)
;
virtual
~
UnicodeSet
(
)
;
UnicodeSet
&
operator
=
(
const
UnicodeSet
&
o
)
;
bool
operator
=
=
(
const
UnicodeSet
&
o
)
const
;
inline
bool
operator
!
=
(
const
UnicodeSet
&
o
)
const
;
virtual
UnicodeSet
*
clone
(
)
const
override
;
int32_t
hashCode
(
)
const
;
inline
static
UnicodeSet
*
fromUSet
(
USet
*
uset
)
;
inline
static
const
UnicodeSet
*
fromUSet
(
const
USet
*
uset
)
;
inline
USet
*
toUSet
(
)
;
inline
const
USet
*
toUSet
(
)
const
;
inline
UBool
isFrozen
(
)
const
;
UnicodeSet
*
freeze
(
)
;
UnicodeSet
*
cloneAsThawed
(
)
const
;
UnicodeSet
&
set
(
UChar32
start
UChar32
end
)
;
static
UBool
resemblesPattern
(
const
UnicodeString
&
pattern
int32_t
pos
)
;
UnicodeSet
&
applyPattern
(
const
UnicodeString
&
pattern
UErrorCode
&
status
)
;
#
ifndef
U_HIDE_INTERNAL_API
UnicodeSet
&
applyPattern
(
const
UnicodeString
&
pattern
uint32_t
options
const
SymbolTable
*
symbols
UErrorCode
&
status
)
;
#
endif
UnicodeSet
&
applyPattern
(
const
UnicodeString
&
pattern
ParsePosition
&
pos
uint32_t
options
const
SymbolTable
*
symbols
UErrorCode
&
status
)
;
virtual
UnicodeString
&
toPattern
(
UnicodeString
&
result
UBool
escapeUnprintable
=
false
)
const
override
;
UnicodeSet
&
applyIntPropertyValue
(
UProperty
prop
int32_t
value
UErrorCode
&
ec
)
;
UnicodeSet
&
applyPropertyAlias
(
const
UnicodeString
&
prop
const
UnicodeString
&
value
UErrorCode
&
ec
)
;
int32_t
size
(
)
const
;
UBool
isEmpty
(
)
const
;
UBool
hasStrings
(
)
const
;
virtual
UBool
contains
(
UChar32
c
)
const
override
;
UBool
contains
(
UChar32
start
UChar32
end
)
const
;
UBool
contains
(
const
UnicodeString
&
s
)
const
;
UBool
containsAll
(
const
UnicodeSet
&
c
)
const
;
UBool
containsAll
(
const
UnicodeString
&
s
)
const
;
UBool
containsNone
(
UChar32
start
UChar32
end
)
const
;
UBool
containsNone
(
const
UnicodeSet
&
c
)
const
;
UBool
containsNone
(
const
UnicodeString
&
s
)
const
;
inline
UBool
containsSome
(
UChar32
start
UChar32
end
)
const
;
inline
UBool
containsSome
(
const
UnicodeSet
&
s
)
const
;
inline
UBool
containsSome
(
const
UnicodeString
&
s
)
const
;
int32_t
span
(
const
char16_t
*
s
int32_t
length
USetSpanCondition
spanCondition
)
const
;
inline
int32_t
span
(
const
UnicodeString
&
s
int32_t
start
USetSpanCondition
spanCondition
)
const
;
int32_t
spanBack
(
const
char16_t
*
s
int32_t
length
USetSpanCondition
spanCondition
)
const
;
inline
int32_t
spanBack
(
const
UnicodeString
&
s
int32_t
limit
USetSpanCondition
spanCondition
)
const
;
int32_t
spanUTF8
(
const
char
*
s
int32_t
length
USetSpanCondition
spanCondition
)
const
;
int32_t
spanBackUTF8
(
const
char
*
s
int32_t
length
USetSpanCondition
spanCondition
)
const
;
UMatchDegree
matches
(
const
Replaceable
&
text
int32_t
&
offset
int32_t
limit
UBool
incremental
)
override
;
private
:
static
int32_t
matchRest
(
const
Replaceable
&
text
int32_t
start
int32_t
limit
const
UnicodeString
&
s
)
;
int32_t
findCodePoint
(
UChar32
c
)
const
;
public
:
virtual
void
addMatchSetTo
(
UnicodeSet
&
toUnionTo
)
const
override
;
int32_t
indexOf
(
UChar32
c
)
const
;
UChar32
charAt
(
int32_t
index
)
const
;
inline
U_HEADER_NESTED_NAMESPACE
:
:
USetCodePoints
codePoints
(
)
const
{
return
U_HEADER_NESTED_NAMESPACE
:
:
USetCodePoints
(
toUSet
(
)
)
;
}
inline
U_HEADER_NESTED_NAMESPACE
:
:
USetRanges
ranges
(
)
const
{
return
U_HEADER_NESTED_NAMESPACE
:
:
USetRanges
(
toUSet
(
)
)
;
}
inline
U_HEADER_NESTED_NAMESPACE
:
:
USetStrings
strings
(
)
const
{
return
U_HEADER_NESTED_NAMESPACE
:
:
USetStrings
(
toUSet
(
)
)
;
}
#
ifndef
U_HIDE_DRAFT_API
inline
U_HEADER_NESTED_NAMESPACE
:
:
USetElementIterator
begin
(
)
const
{
return
U_HEADER_NESTED_NAMESPACE
:
:
USetElements
(
toUSet
(
)
)
.
begin
(
)
;
}
inline
U_HEADER_NESTED_NAMESPACE
:
:
USetElementIterator
end
(
)
const
{
return
U_HEADER_NESTED_NAMESPACE
:
:
USetElements
(
toUSet
(
)
)
.
end
(
)
;
}
#
endif
UnicodeSet
&
add
(
UChar32
start
UChar32
end
)
;
UnicodeSet
&
add
(
UChar32
c
)
;
UnicodeSet
&
add
(
const
UnicodeString
&
s
)
;
private
:
static
int32_t
getSingleCP
(
const
UnicodeString
&
s
)
;
void
_add
(
const
UnicodeString
&
s
)
;
public
:
UnicodeSet
&
addAll
(
const
UnicodeString
&
s
)
;
UnicodeSet
&
retainAll
(
const
UnicodeString
&
s
)
;
UnicodeSet
&
complementAll
(
const
UnicodeString
&
s
)
;
UnicodeSet
&
removeAll
(
const
UnicodeString
&
s
)
;
static
UnicodeSet
*
U_EXPORT2
createFrom
(
const
UnicodeString
&
s
)
;
static
UnicodeSet
*
U_EXPORT2
createFromAll
(
const
UnicodeString
&
s
)
;
UnicodeSet
&
retain
(
UChar32
start
UChar32
end
)
;
UnicodeSet
&
retain
(
UChar32
c
)
;
UnicodeSet
&
retain
(
const
UnicodeString
&
s
)
;
UnicodeSet
&
remove
(
UChar32
start
UChar32
end
)
;
UnicodeSet
&
remove
(
UChar32
c
)
;
UnicodeSet
&
remove
(
const
UnicodeString
&
s
)
;
UnicodeSet
&
complement
(
)
;
UnicodeSet
&
complement
(
UChar32
start
UChar32
end
)
;
UnicodeSet
&
complement
(
UChar32
c
)
;
UnicodeSet
&
complement
(
const
UnicodeString
&
s
)
;
UnicodeSet
&
addAll
(
const
UnicodeSet
&
c
)
;
UnicodeSet
&
retainAll
(
const
UnicodeSet
&
c
)
;
UnicodeSet
&
removeAll
(
const
UnicodeSet
&
c
)
;
UnicodeSet
&
complementAll
(
const
UnicodeSet
&
c
)
;
UnicodeSet
&
clear
(
)
;
UnicodeSet
&
closeOver
(
int32_t
attribute
)
;
UnicodeSet
&
removeAllStrings
(
)
;
int32_t
getRangeCount
(
)
const
;
UChar32
getRangeStart
(
int32_t
index
)
const
;
UChar32
getRangeEnd
(
int32_t
index
)
const
;
int32_t
serialize
(
uint16_t
*
dest
int32_t
destCapacity
UErrorCode
&
ec
)
const
;
UnicodeSet
&
compact
(
)
;
static
UClassID
U_EXPORT2
getStaticClassID
(
)
;
virtual
UClassID
getDynamicClassID
(
)
const
override
;
private
:
friend
class
USetAccess
;
const
UnicodeString
*
getString
(
int32_t
index
)
const
;
private
:
virtual
UBool
matchesIndexValue
(
uint8_t
v
)
const
override
;
private
:
friend
class
RBBIRuleScanner
;
UnicodeSet
(
const
UnicodeSet
&
o
UBool
)
;
UnicodeSet
&
copyFrom
(
const
UnicodeSet
&
o
UBool
asThawed
)
;
void
applyPatternIgnoreSpace
(
const
UnicodeString
&
pattern
ParsePosition
&
pos
const
SymbolTable
*
symbols
UErrorCode
&
status
)
;
void
applyPattern
(
RuleCharacterIterator
&
chars
const
SymbolTable
*
symbols
UnicodeString
&
rebuiltPat
uint32_t
options
UnicodeSet
&
(
UnicodeSet
:
:
*
caseClosure
)
(
int32_t
attribute
)
int32_t
depth
UErrorCode
&
ec
)
;
void
closeOverCaseInsensitive
(
bool
simple
)
;
void
closeOverAddCaseMappings
(
)
;
static
int32_t
nextCapacity
(
int32_t
minCapacity
)
;
bool
ensureCapacity
(
int32_t
newLen
)
;
bool
ensureBufferCapacity
(
int32_t
newLen
)
;
void
swapBuffers
(
)
;
UBool
allocateStrings
(
UErrorCode
&
status
)
;
int32_t
stringsSize
(
)
const
;
UBool
stringsContains
(
const
UnicodeString
&
s
)
const
;
UnicodeString
&
_toPattern
(
UnicodeString
&
result
UBool
escapeUnprintable
)
const
;
UnicodeString
&
_generatePattern
(
UnicodeString
&
result
UBool
escapeUnprintable
)
const
;
static
void
_appendToPat
(
UnicodeString
&
buf
const
UnicodeString
&
s
UBool
escapeUnprintable
)
;
static
void
_appendToPat
(
UnicodeString
&
buf
UChar32
c
UBool
escapeUnprintable
)
;
static
void
_appendToPat
(
UnicodeString
&
result
UChar32
start
UChar32
end
UBool
escapeUnprintable
)
;
void
exclusiveOr
(
const
UChar32
*
other
int32_t
otherLen
int8_t
polarity
)
;
void
add
(
const
UChar32
*
other
int32_t
otherLen
int8_t
polarity
)
;
void
retain
(
const
UChar32
*
other
int32_t
otherLen
int8_t
polarity
)
;
static
UBool
resemblesPropertyPattern
(
const
UnicodeString
&
pattern
int32_t
pos
)
;
static
UBool
resemblesPropertyPattern
(
RuleCharacterIterator
&
chars
int32_t
iterOpts
)
;
UnicodeSet
&
applyPropertyPattern
(
const
UnicodeString
&
pattern
ParsePosition
&
ppos
UErrorCode
&
ec
)
;
void
applyPropertyPattern
(
RuleCharacterIterator
&
chars
UnicodeString
&
rebuiltPat
UErrorCode
&
ec
)
;
typedef
UBool
(
*
Filter
)
(
UChar32
codePoint
void
*
context
)
;
void
applyFilter
(
Filter
filter
void
*
context
const
UnicodeSet
*
inclusions
UErrorCode
&
status
)
;
void
setPattern
(
const
UnicodeString
&
newPat
)
{
setPattern
(
newPat
.
getBuffer
(
)
newPat
.
length
(
)
)
;
}
void
setPattern
(
const
char16_t
*
newPat
int32_t
newPatLen
)
;
void
releasePattern
(
)
;
friend
class
UnicodeSetIterator
;
}
;
inline
bool
UnicodeSet
:
:
operator
!
=
(
const
UnicodeSet
&
o
)
const
{
return
!
operator
=
=
(
o
)
;
}
inline
UBool
UnicodeSet
:
:
isFrozen
(
)
const
{
return
bmpSet
!
=
nullptr
|
|
stringSpan
!
=
nullptr
;
}
inline
UBool
UnicodeSet
:
:
containsSome
(
UChar32
start
UChar32
end
)
const
{
return
!
containsNone
(
start
end
)
;
}
inline
UBool
UnicodeSet
:
:
containsSome
(
const
UnicodeSet
&
s
)
const
{
return
!
containsNone
(
s
)
;
}
inline
UBool
UnicodeSet
:
:
containsSome
(
const
UnicodeString
&
s
)
const
{
return
!
containsNone
(
s
)
;
}
inline
UBool
UnicodeSet
:
:
isBogus
(
)
const
{
return
fFlags
&
kIsBogus
;
}
inline
UnicodeSet
*
UnicodeSet
:
:
fromUSet
(
USet
*
uset
)
{
return
reinterpret_cast
<
UnicodeSet
*
>
(
uset
)
;
}
inline
const
UnicodeSet
*
UnicodeSet
:
:
fromUSet
(
const
USet
*
uset
)
{
return
reinterpret_cast
<
const
UnicodeSet
*
>
(
uset
)
;
}
inline
USet
*
UnicodeSet
:
:
toUSet
(
)
{
return
reinterpret_cast
<
USet
*
>
(
this
)
;
}
inline
const
USet
*
UnicodeSet
:
:
toUSet
(
)
const
{
return
reinterpret_cast
<
const
USet
*
>
(
this
)
;
}
inline
int32_t
UnicodeSet
:
:
span
(
const
UnicodeString
&
s
int32_t
start
USetSpanCondition
spanCondition
)
const
{
int32_t
sLength
=
s
.
length
(
)
;
if
(
start
<
0
)
{
start
=
0
;
}
else
if
(
start
>
sLength
)
{
start
=
sLength
;
}
return
start
+
span
(
s
.
getBuffer
(
)
+
start
sLength
-
start
spanCondition
)
;
}
inline
int32_t
UnicodeSet
:
:
spanBack
(
const
UnicodeString
&
s
int32_t
limit
USetSpanCondition
spanCondition
)
const
{
int32_t
sLength
=
s
.
length
(
)
;
if
(
limit
<
0
)
{
limit
=
0
;
}
else
if
(
limit
>
sLength
)
{
limit
=
sLength
;
}
return
spanBack
(
s
.
getBuffer
(
)
limit
spanCondition
)
;
}
U_NAMESPACE_END
#
endif
#
endif
