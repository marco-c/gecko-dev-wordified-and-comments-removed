#
ifndef
__UTFITERATOR_H__
#
define
__UTFITERATOR_H__
#
include
"
unicode
/
utypes
.
h
"
#
if
U_SHOW_CPLUSPLUS_API
|
|
U_SHOW_CPLUSPLUS_HEADER_API
|
|
!
defined
(
UTYPES_H
)
#
include
<
iterator
>
#
if
defined
(
__cpp_lib_ranges
)
#
include
<
ranges
>
#
endif
#
include
<
string
>
#
include
<
string_view
>
#
include
<
type_traits
>
#
include
"
unicode
/
utf16
.
h
"
#
include
"
unicode
/
utf8
.
h
"
#
include
"
unicode
/
uversion
.
h
"
#
ifndef
U_HIDE_DRAFT_API
typedef
enum
UTFIllFormedBehavior
{
UTF_BEHAVIOR_NEGATIVE
UTF_BEHAVIOR_FFFD
UTF_BEHAVIOR_SURROGATE
}
UTFIllFormedBehavior
;
namespace
U_HEADER_ONLY_NAMESPACE
{
namespace
prv
{
#
if
U_CPLUSPLUS_VERSION
>
=
20
template
<
typename
Iter
>
using
iter_value_t
=
typename
std
:
:
iter_value_t
<
Iter
>
;
template
<
typename
Iter
>
using
iter_difference_t
=
std
:
:
iter_difference_t
<
Iter
>
;
template
<
typename
Iter
>
constexpr
bool
forward_iterator
=
std
:
:
forward_iterator
<
Iter
>
;
template
<
typename
Iter
>
constexpr
bool
bidirectional_iterator
=
std
:
:
bidirectional_iterator
<
Iter
>
;
template
<
typename
Range
>
constexpr
bool
range
=
std
:
:
ranges
:
:
range
<
Range
>
;
#
else
template
<
typename
Iter
>
using
iter_value_t
=
typename
std
:
:
iterator_traits
<
Iter
>
:
:
value_type
;
template
<
typename
Iter
>
using
iter_difference_t
=
typename
std
:
:
iterator_traits
<
Iter
>
:
:
difference_type
;
template
<
typename
Iter
>
constexpr
bool
forward_iterator
=
std
:
:
is_base_of_v
<
std
:
:
forward_iterator_tag
typename
std
:
:
iterator_traits
<
Iter
>
:
:
iterator_category
>
;
template
<
typename
Iter
>
constexpr
bool
bidirectional_iterator
=
std
:
:
is_base_of_v
<
std
:
:
bidirectional_iterator_tag
typename
std
:
:
iterator_traits
<
Iter
>
:
:
iterator_category
>
;
template
<
typename
Range
typename
=
void
>
struct
range_type
:
std
:
:
false_type
{
}
;
template
<
typename
Range
>
struct
range_type
<
Range
std
:
:
void_t
<
decltype
(
std
:
:
declval
<
Range
>
(
)
.
begin
(
)
)
decltype
(
std
:
:
declval
<
Range
>
(
)
.
end
(
)
)
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
Range
>
constexpr
bool
range
=
range_type
<
Range
>
:
:
value
;
#
endif
template
<
typename
T
>
struct
is_basic_string_view
:
std
:
:
false_type
{
}
;
template
<
typename
.
.
.
Args
>
struct
is_basic_string_view
<
std
:
:
basic_string_view
<
Args
.
.
.
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
>
constexpr
bool
is_basic_string_view_v
=
is_basic_string_view
<
T
>
:
:
value
;
template
<
typename
CP32
bool
skipSurrogates
>
class
CodePointsIterator
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
using
value_type
=
CP32
;
using
reference
=
value_type
;
using
pointer
=
CP32
*
;
using
difference_type
=
int32_t
;
using
iterator_category
=
std
:
:
forward_iterator_tag
;
inline
CodePointsIterator
(
CP32
c
)
:
c_
(
c
)
{
}
inline
bool
operator
=
=
(
const
CodePointsIterator
&
other
)
const
{
return
c_
=
=
other
.
c_
;
}
inline
bool
operator
!
=
(
const
CodePointsIterator
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
inline
CP32
operator
*
(
)
const
{
return
c_
;
}
inline
CodePointsIterator
&
operator
+
+
(
)
{
+
+
c_
;
if
(
skipSurrogates
&
&
c_
=
=
0xd800
)
{
c_
=
0xe000
;
}
return
*
this
;
}
inline
CodePointsIterator
operator
+
+
(
int
)
{
CodePointsIterator
result
(
*
this
)
;
+
+
(
*
this
)
;
return
result
;
}
private
:
CP32
c_
;
}
;
}
template
<
typename
CP32
>
class
AllCodePoints
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
AllCodePoints
(
)
{
}
auto
begin
(
)
const
{
return
prv
:
:
CodePointsIterator
<
CP32
false
>
(
0
)
;
}
auto
end
(
)
const
{
return
prv
:
:
CodePointsIterator
<
CP32
false
>
(
0x110000
)
;
}
}
;
template
<
typename
CP32
>
class
AllScalarValues
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
AllScalarValues
(
)
{
}
auto
begin
(
)
const
{
return
prv
:
:
CodePointsIterator
<
CP32
true
>
(
0
)
;
}
auto
end
(
)
const
{
return
prv
:
:
CodePointsIterator
<
CP32
true
>
(
0x110000
)
;
}
}
;
template
<
typename
CP32
typename
UnitIter
typename
=
void
>
class
UnsafeCodeUnits
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
using
Unit
=
typename
prv
:
:
iter_value_t
<
UnitIter
>
;
public
:
UnsafeCodeUnits
(
CP32
codePoint
uint8_t
length
UnitIter
start
UnitIter
limit
)
:
c_
(
codePoint
)
len_
(
length
)
start_
(
start
)
limit_
(
limit
)
{
}
UnsafeCodeUnits
(
const
UnsafeCodeUnits
&
other
)
=
default
;
UnsafeCodeUnits
&
operator
=
(
const
UnsafeCodeUnits
&
other
)
=
default
;
CP32
codePoint
(
)
const
{
return
c_
;
}
UnitIter
begin
(
)
const
{
return
start_
;
}
UnitIter
end
(
)
const
{
return
limit_
;
}
uint8_t
length
(
)
const
{
return
len_
;
}
#
if
U_CPLUSPLUS_VERSION
>
=
20
template
<
std
:
:
contiguous_iterator
Iter
=
UnitIter
>
std
:
:
basic_string_view
<
Unit
>
stringView
(
)
const
{
return
std
:
:
basic_string_view
<
Unit
>
(
begin
(
)
end
(
)
)
;
}
#
else
template
<
typename
Iter
=
UnitIter
typename
Unit
=
typename
std
:
:
iterator_traits
<
Iter
>
:
:
value_type
>
std
:
:
enable_if_t
<
std
:
:
is_pointer_v
<
Iter
>
|
|
std
:
:
is_same_v
<
Iter
typename
std
:
:
basic_string
<
Unit
>
:
:
iterator
>
|
|
std
:
:
is_same_v
<
Iter
typename
std
:
:
basic_string
<
Unit
>
:
:
const_iterator
>
|
|
std
:
:
is_same_v
<
Iter
typename
std
:
:
basic_string_view
<
Unit
>
:
:
iterator
>
|
|
std
:
:
is_same_v
<
Iter
typename
std
:
:
basic_string_view
<
Unit
>
:
:
const_iterator
>
std
:
:
basic_string_view
<
Unit
>
>
stringView
(
)
const
{
return
std
:
:
basic_string_view
<
Unit
>
(
&
*
start_
len_
)
;
}
#
endif
private
:
CP32
c_
;
uint8_t
len_
;
UnitIter
start_
;
UnitIter
limit_
;
}
;
#
ifndef
U_IN_DOXYGEN
template
<
typename
CP32
typename
UnitIter
>
class
UnsafeCodeUnits
<
CP32
UnitIter
std
:
:
enable_if_t
<
!
prv
:
:
forward_iterator
<
UnitIter
>
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
UnsafeCodeUnits
(
CP32
codePoint
uint8_t
length
)
:
c_
(
codePoint
)
len_
(
length
)
{
}
UnsafeCodeUnits
(
const
UnsafeCodeUnits
&
other
)
=
default
;
UnsafeCodeUnits
&
operator
=
(
const
UnsafeCodeUnits
&
other
)
=
default
;
CP32
codePoint
(
)
const
{
return
c_
;
}
uint8_t
length
(
)
const
{
return
len_
;
}
private
:
CP32
c_
;
uint8_t
len_
;
}
;
#
endif
template
<
typename
CP32
typename
UnitIter
typename
=
void
>
class
CodeUnits
:
public
UnsafeCodeUnits
<
CP32
UnitIter
>
{
public
:
CodeUnits
(
CP32
codePoint
uint8_t
length
bool
wellFormed
UnitIter
start
UnitIter
limit
)
:
UnsafeCodeUnits
<
CP32
UnitIter
>
(
codePoint
length
start
limit
)
ok_
(
wellFormed
)
{
}
CodeUnits
(
const
CodeUnits
&
other
)
=
default
;
CodeUnits
&
operator
=
(
const
CodeUnits
&
other
)
=
default
;
bool
wellFormed
(
)
const
{
return
ok_
;
}
private
:
bool
ok_
;
}
;
#
ifndef
U_IN_DOXYGEN
template
<
typename
CP32
typename
UnitIter
>
class
CodeUnits
<
CP32
UnitIter
std
:
:
enable_if_t
<
!
prv
:
:
forward_iterator
<
UnitIter
>
>
>
:
public
UnsafeCodeUnits
<
CP32
UnitIter
>
{
public
:
CodeUnits
(
CP32
codePoint
uint8_t
length
bool
wellFormed
)
:
UnsafeCodeUnits
<
CP32
UnitIter
>
(
codePoint
length
)
ok_
(
wellFormed
)
{
}
CodeUnits
(
const
CodeUnits
&
other
)
=
default
;
CodeUnits
&
operator
=
(
const
CodeUnits
&
other
)
=
default
;
bool
wellFormed
(
)
const
{
return
ok_
;
}
private
:
bool
ok_
;
}
;
#
endif
#
ifndef
U_IN_DOXYGEN
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
typename
LimitIter
=
UnitIter
typename
=
void
>
class
UTFImpl
;
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
typename
LimitIter
>
class
UTFImpl
<
CP32
behavior
UnitIter
LimitIter
std
:
:
enable_if_t
<
sizeof
(
typename
prv
:
:
iter_value_t
<
UnitIter
>
)
=
=
1
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
static_assert
(
behavior
!
=
UTF_BEHAVIOR_SURROGATE
"
For
8
-
bit
strings
the
SURROGATE
option
does
not
have
an
equivalent
.
"
)
;
public
:
U_FORCE_INLINE
static
CP32
sub
(
)
{
switch
(
behavior
)
{
case
UTF_BEHAVIOR_NEGATIVE
:
return
U_SENTINEL
;
case
UTF_BEHAVIOR_FFFD
:
return
0xfffd
;
}
}
U_FORCE_INLINE
static
void
inc
(
UnitIter
&
p
const
LimitIter
&
limit
)
{
uint8_t
b
=
*
p
;
+
+
p
;
if
(
U8_IS_LEAD
(
b
)
&
&
p
!
=
limit
)
{
uint8_t
t1
=
*
p
;
if
(
(
0xe0
<
=
b
&
&
b
<
0xf0
)
)
{
if
(
U8_IS_VALID_LEAD3_AND_T1
(
b
t1
)
&
&
+
+
p
!
=
limit
&
&
U8_IS_TRAIL
(
*
p
)
)
{
+
+
p
;
}
}
else
if
(
b
<
0xe0
)
{
if
(
U8_IS_TRAIL
(
t1
)
)
{
+
+
p
;
}
}
else
{
if
(
U8_IS_VALID_LEAD4_AND_T1
(
b
t1
)
&
&
+
+
p
!
=
limit
&
&
U8_IS_TRAIL
(
*
p
)
&
&
+
+
p
!
=
limit
&
&
U8_IS_TRAIL
(
*
p
)
)
{
+
+
p
;
}
}
}
}
U_FORCE_INLINE
static
void
dec
(
UnitIter
start
UnitIter
&
p
)
{
uint8_t
c
=
*
-
-
p
;
if
(
U8_IS_TRAIL
(
c
)
&
&
p
!
=
start
)
{
UnitIter
p1
=
p
;
uint8_t
b1
=
*
-
-
p1
;
if
(
U8_IS_LEAD
(
b1
)
)
{
if
(
b1
<
0xe0
|
|
(
b1
<
0xf0
?
U8_IS_VALID_LEAD3_AND_T1
(
b1
c
)
:
U8_IS_VALID_LEAD4_AND_T1
(
b1
c
)
)
)
{
p
=
p1
;
return
;
}
}
else
if
(
U8_IS_TRAIL
(
b1
)
&
&
p1
!
=
start
)
{
uint8_t
b2
=
*
-
-
p1
;
if
(
0xe0
<
=
b2
&
&
b2
<
=
0xf4
)
{
if
(
b2
<
0xf0
?
U8_IS_VALID_LEAD3_AND_T1
(
b2
b1
)
:
U8_IS_VALID_LEAD4_AND_T1
(
b2
b1
)
)
{
p
=
p1
;
return
;
}
}
else
if
(
U8_IS_TRAIL
(
b2
)
&
&
p1
!
=
start
)
{
uint8_t
b3
=
*
-
-
p1
;
if
(
0xf0
<
=
b3
&
&
b3
<
=
0xf4
&
&
U8_IS_VALID_LEAD4_AND_T1
(
b3
b2
)
)
{
p
=
p1
;
return
;
}
}
}
}
}
U_FORCE_INLINE
static
CodeUnits
<
CP32
UnitIter
>
readAndInc
(
UnitIter
&
p0
UnitIter
&
p
const
LimitIter
&
limit
)
{
constexpr
bool
isMultiPass
=
prv
:
:
forward_iterator
<
UnitIter
>
;
CP32
c
=
uint8_t
(
*
p
)
;
+
+
p
;
if
(
U8_IS_SINGLE
(
c
)
)
{
if
constexpr
(
isMultiPass
)
{
return
{
c
1
true
p0
p
}
;
}
else
{
return
{
c
1
true
}
;
}
}
uint8_t
length
=
1
;
uint8_t
t
=
0
;
if
(
p
!
=
limit
&
&
(
c
>
=
0xe0
?
(
c
<
0xf0
?
U8_LEAD3_T1_BITS
[
c
&
=
0xf
]
&
(
1
<
<
(
(
t
=
*
p
)
>
>
5
)
)
&
&
(
t
&
=
0x3f
1
)
:
(
c
-
=
0xf0
)
<
=
4
&
&
U8_LEAD4_T1_BITS
[
(
t
=
*
p
)
>
>
4
]
&
(
1
<
<
c
)
&
&
(
c
=
(
c
<
<
6
)
|
(
t
&
0x3f
)
+
+
length
+
+
p
!
=
limit
)
&
&
(
t
=
*
p
-
0x80
)
<
=
0x3f
)
&
&
(
c
=
(
c
<
<
6
)
|
t
+
+
length
+
+
p
!
=
limit
)
:
c
>
=
0xc2
&
&
(
c
&
=
0x1f
1
)
)
&
&
(
t
=
*
p
-
0x80
)
<
=
0x3f
)
{
c
=
(
c
<
<
6
)
|
t
;
+
+
length
;
+
+
p
;
if
constexpr
(
isMultiPass
)
{
return
{
c
length
true
p0
p
}
;
}
else
{
return
{
c
length
true
}
;
}
}
if
constexpr
(
isMultiPass
)
{
return
{
sub
(
)
length
false
p0
p
}
;
}
else
{
return
{
sub
(
)
length
false
}
;
}
}
U_FORCE_INLINE
static
CodeUnits
<
CP32
UnitIter
>
decAndRead
(
UnitIter
start
UnitIter
&
p
)
{
UnitIter
p0
=
p
;
CP32
c
=
uint8_t
(
*
-
-
p
)
;
if
(
U8_IS_SINGLE
(
c
)
)
{
return
{
c
1
true
p
p0
}
;
}
if
(
U8_IS_TRAIL
(
c
)
&
&
p
!
=
start
)
{
UnitIter
p1
=
p
;
uint8_t
b1
=
*
-
-
p1
;
if
(
U8_IS_LEAD
(
b1
)
)
{
if
(
b1
<
0xe0
)
{
p
=
p1
;
c
=
(
(
b1
-
0xc0
)
<
<
6
)
|
(
c
&
0x3f
)
;
return
{
c
2
true
p
p0
}
;
}
else
if
(
b1
<
0xf0
?
U8_IS_VALID_LEAD3_AND_T1
(
b1
c
)
:
U8_IS_VALID_LEAD4_AND_T1
(
b1
c
)
)
{
p
=
p1
;
return
{
sub
(
)
2
false
p
p0
}
;
}
}
else
if
(
U8_IS_TRAIL
(
b1
)
&
&
p1
!
=
start
)
{
c
&
=
0x3f
;
uint8_t
b2
=
*
-
-
p1
;
if
(
0xe0
<
=
b2
&
&
b2
<
=
0xf4
)
{
if
(
b2
<
0xf0
)
{
b2
&
=
0xf
;
if
(
U8_IS_VALID_LEAD3_AND_T1
(
b2
b1
)
)
{
p
=
p1
;
c
=
(
b2
<
<
12
)
|
(
(
b1
&
0x3f
)
<
<
6
)
|
c
;
return
{
c
3
true
p
p0
}
;
}
}
else
if
(
U8_IS_VALID_LEAD4_AND_T1
(
b2
b1
)
)
{
p
=
p1
;
return
{
sub
(
)
3
false
p
p0
}
;
}
}
else
if
(
U8_IS_TRAIL
(
b2
)
&
&
p1
!
=
start
)
{
uint8_t
b3
=
*
-
-
p1
;
if
(
0xf0
<
=
b3
&
&
b3
<
=
0xf4
)
{
b3
&
=
7
;
if
(
U8_IS_VALID_LEAD4_AND_T1
(
b3
b2
)
)
{
p
=
p1
;
c
=
(
b3
<
<
18
)
|
(
(
b2
&
0x3f
)
<
<
12
)
|
(
(
b1
&
0x3f
)
<
<
6
)
|
c
;
return
{
c
4
true
p
p0
}
;
}
}
}
}
}
return
{
sub
(
)
1
false
p
p0
}
;
}
}
;
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
typename
LimitIter
>
class
UTFImpl
<
CP32
behavior
UnitIter
LimitIter
std
:
:
enable_if_t
<
sizeof
(
typename
prv
:
:
iter_value_t
<
UnitIter
>
)
=
=
2
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
U_FORCE_INLINE
static
CP32
sub
(
CP32
surrogate
)
{
switch
(
behavior
)
{
case
UTF_BEHAVIOR_NEGATIVE
:
return
U_SENTINEL
;
case
UTF_BEHAVIOR_FFFD
:
return
0xfffd
;
case
UTF_BEHAVIOR_SURROGATE
:
return
surrogate
;
}
}
U_FORCE_INLINE
static
void
inc
(
UnitIter
&
p
const
LimitIter
&
limit
)
{
auto
c
=
*
p
;
+
+
p
;
if
(
U16_IS_LEAD
(
c
)
&
&
p
!
=
limit
&
&
U16_IS_TRAIL
(
*
p
)
)
{
+
+
p
;
}
}
U_FORCE_INLINE
static
void
dec
(
UnitIter
start
UnitIter
&
p
)
{
UnitIter
p1
;
if
(
U16_IS_TRAIL
(
*
-
-
p
)
&
&
p
!
=
start
&
&
(
p1
=
p
U16_IS_LEAD
(
*
-
-
p1
)
)
)
{
p
=
p1
;
}
}
U_FORCE_INLINE
static
CodeUnits
<
CP32
UnitIter
>
readAndInc
(
UnitIter
&
p0
UnitIter
&
p
const
LimitIter
&
limit
)
{
constexpr
bool
isMultiPass
=
prv
:
:
forward_iterator
<
UnitIter
>
;
CP32
c
=
static_cast
<
CP32
>
(
*
p
)
;
+
+
p
;
if
(
!
U16_IS_SURROGATE
(
c
)
)
{
if
constexpr
(
isMultiPass
)
{
return
{
c
1
true
p0
p
}
;
}
else
{
return
{
c
1
true
}
;
}
}
else
{
uint16_t
c2
;
if
(
U16_IS_SURROGATE_LEAD
(
c
)
&
&
p
!
=
limit
&
&
U16_IS_TRAIL
(
c2
=
*
p
)
)
{
+
+
p
;
c
=
U16_GET_SUPPLEMENTARY
(
c
c2
)
;
if
constexpr
(
isMultiPass
)
{
return
{
c
2
true
p0
p
}
;
}
else
{
return
{
c
2
true
}
;
}
}
else
{
if
constexpr
(
isMultiPass
)
{
return
{
sub
(
c
)
1
false
p0
p
}
;
}
else
{
return
{
sub
(
c
)
1
false
}
;
}
}
}
}
U_FORCE_INLINE
static
CodeUnits
<
CP32
UnitIter
>
decAndRead
(
UnitIter
start
UnitIter
&
p
)
{
UnitIter
p0
=
p
;
CP32
c
=
static_cast
<
CP32
>
(
*
-
-
p
)
;
if
(
!
U16_IS_SURROGATE
(
c
)
)
{
return
{
c
1
true
p
p0
}
;
}
else
{
UnitIter
p1
;
uint16_t
c2
;
if
(
U16_IS_SURROGATE_TRAIL
(
c
)
&
&
p
!
=
start
&
&
(
p1
=
p
U16_IS_LEAD
(
c2
=
*
-
-
p1
)
)
)
{
p
=
p1
;
c
=
U16_GET_SUPPLEMENTARY
(
c2
c
)
;
return
{
c
2
true
p
p0
}
;
}
else
{
return
{
sub
(
c
)
1
false
p
p0
}
;
}
}
}
}
;
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
typename
LimitIter
>
class
UTFImpl
<
CP32
behavior
UnitIter
LimitIter
std
:
:
enable_if_t
<
sizeof
(
typename
prv
:
:
iter_value_t
<
UnitIter
>
)
=
=
4
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
U_FORCE_INLINE
static
CP32
sub
(
bool
forSurrogate
CP32
surrogate
)
{
switch
(
behavior
)
{
case
UTF_BEHAVIOR_NEGATIVE
:
return
U_SENTINEL
;
case
UTF_BEHAVIOR_FFFD
:
return
0xfffd
;
case
UTF_BEHAVIOR_SURROGATE
:
return
forSurrogate
?
surrogate
:
0xfffd
;
}
}
U_FORCE_INLINE
static
void
inc
(
UnitIter
&
p
const
LimitIter
&
)
{
+
+
p
;
}
U_FORCE_INLINE
static
void
dec
(
UnitIter
UnitIter
&
p
)
{
-
-
p
;
}
U_FORCE_INLINE
static
CodeUnits
<
CP32
UnitIter
>
readAndInc
(
UnitIter
&
p0
UnitIter
&
p
const
LimitIter
&
)
{
constexpr
bool
isMultiPass
=
prv
:
:
forward_iterator
<
UnitIter
>
;
uint32_t
uc
=
*
p
;
CP32
c
=
uc
;
+
+
p
;
if
(
uc
<
0xd800
|
|
(
0xe000
<
=
uc
&
&
uc
<
=
0x10ffff
)
)
{
if
constexpr
(
isMultiPass
)
{
return
{
c
1
true
p0
p
}
;
}
else
{
return
{
c
1
true
}
;
}
}
else
{
if
constexpr
(
isMultiPass
)
{
return
{
sub
(
uc
<
0xe000
c
)
1
false
p0
p
}
;
}
else
{
return
{
sub
(
uc
<
0xe000
c
)
1
false
}
;
}
}
}
U_FORCE_INLINE
static
CodeUnits
<
CP32
UnitIter
>
decAndRead
(
UnitIter
UnitIter
&
p
)
{
UnitIter
p0
=
p
;
uint32_t
uc
=
*
-
-
p
;
CP32
c
=
uc
;
if
(
uc
<
0xd800
|
|
(
0xe000
<
=
uc
&
&
uc
<
=
0x10ffff
)
)
{
return
{
c
1
true
p
p0
}
;
}
else
{
return
{
sub
(
uc
<
0xe000
c
)
1
false
p
p0
}
;
}
}
}
;
template
<
typename
CP32
typename
UnitIter
typename
=
void
>
class
UnsafeUTFImpl
;
template
<
typename
CP32
typename
UnitIter
>
class
UnsafeUTFImpl
<
CP32
UnitIter
std
:
:
enable_if_t
<
sizeof
(
typename
prv
:
:
iter_value_t
<
UnitIter
>
)
=
=
1
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
U_FORCE_INLINE
static
void
inc
(
UnitIter
&
p
)
{
uint8_t
b
=
*
p
;
std
:
:
advance
(
p
1
+
U8_COUNT_TRAIL_BYTES_UNSAFE
(
b
)
)
;
}
U_FORCE_INLINE
static
void
dec
(
UnitIter
&
p
)
{
while
(
U8_IS_TRAIL
(
*
-
-
p
)
)
{
}
}
U_FORCE_INLINE
static
UnsafeCodeUnits
<
CP32
UnitIter
>
readAndInc
(
UnitIter
&
p0
UnitIter
&
p
)
{
constexpr
bool
isMultiPass
=
prv
:
:
forward_iterator
<
UnitIter
>
;
CP32
c
=
uint8_t
(
*
p
)
;
+
+
p
;
if
(
U8_IS_SINGLE
(
c
)
)
{
if
constexpr
(
isMultiPass
)
{
return
{
c
1
p0
p
}
;
}
else
{
return
{
c
1
}
;
}
}
else
if
(
c
<
0xe0
)
{
c
=
(
(
c
&
0x1f
)
<
<
6
)
|
(
*
p
&
0x3f
)
;
+
+
p
;
if
constexpr
(
isMultiPass
)
{
return
{
c
2
p0
p
}
;
}
else
{
return
{
c
2
}
;
}
}
else
if
(
c
<
0xf0
)
{
c
=
uint16_t
(
c
<
<
12
)
|
(
(
*
p
&
0x3f
)
<
<
6
)
;
+
+
p
;
c
|
=
*
p
&
0x3f
;
+
+
p
;
if
constexpr
(
isMultiPass
)
{
return
{
c
3
p0
p
}
;
}
else
{
return
{
c
3
}
;
}
}
else
{
c
=
(
(
c
&
7
)
<
<
18
)
|
(
(
*
p
&
0x3f
)
<
<
12
)
;
+
+
p
;
c
|
=
(
*
p
&
0x3f
)
<
<
6
;
+
+
p
;
c
|
=
*
p
&
0x3f
;
+
+
p
;
if
constexpr
(
isMultiPass
)
{
return
{
c
4
p0
p
}
;
}
else
{
return
{
c
4
}
;
}
}
}
U_FORCE_INLINE
static
UnsafeCodeUnits
<
CP32
UnitIter
>
decAndRead
(
UnitIter
&
p
)
{
UnitIter
p0
=
p
;
CP32
c
=
uint8_t
(
*
-
-
p
)
;
if
(
U8_IS_SINGLE
(
c
)
)
{
return
{
c
1
p
p0
}
;
}
c
&
=
0x3f
;
uint8_t
count
=
1
;
for
(
uint8_t
shift
=
6
;
;
)
{
uint8_t
b
=
*
-
-
p
;
if
(
b
>
=
0xc0
)
{
U8_MASK_LEAD_BYTE
(
b
count
)
;
c
|
=
uint32_t
{
b
}
<
<
shift
;
break
;
}
else
{
c
|
=
(
uint32_t
{
b
}
&
0x3f
)
<
<
shift
;
+
+
count
;
shift
+
=
6
;
}
}
+
+
count
;
return
{
c
count
p
p0
}
;
}
}
;
template
<
typename
CP32
typename
UnitIter
>
class
UnsafeUTFImpl
<
CP32
UnitIter
std
:
:
enable_if_t
<
sizeof
(
typename
prv
:
:
iter_value_t
<
UnitIter
>
)
=
=
2
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
U_FORCE_INLINE
static
void
inc
(
UnitIter
&
p
)
{
auto
c
=
*
p
;
+
+
p
;
if
(
U16_IS_LEAD
(
c
)
)
{
+
+
p
;
}
}
U_FORCE_INLINE
static
void
dec
(
UnitIter
&
p
)
{
if
(
U16_IS_TRAIL
(
*
-
-
p
)
)
{
-
-
p
;
}
}
U_FORCE_INLINE
static
UnsafeCodeUnits
<
CP32
UnitIter
>
readAndInc
(
UnitIter
&
p0
UnitIter
&
p
)
{
constexpr
bool
isMultiPass
=
prv
:
:
forward_iterator
<
UnitIter
>
;
CP32
c
=
static_cast
<
CP32
>
(
*
p
)
;
+
+
p
;
if
(
!
U16_IS_LEAD
(
c
)
)
{
if
constexpr
(
isMultiPass
)
{
return
{
c
1
p0
p
}
;
}
else
{
return
{
c
1
}
;
}
}
else
{
uint16_t
c2
=
*
p
;
+
+
p
;
c
=
U16_GET_SUPPLEMENTARY
(
c
c2
)
;
if
constexpr
(
isMultiPass
)
{
return
{
c
2
p0
p
}
;
}
else
{
return
{
c
2
}
;
}
}
}
U_FORCE_INLINE
static
UnsafeCodeUnits
<
CP32
UnitIter
>
decAndRead
(
UnitIter
&
p
)
{
UnitIter
p0
=
p
;
CP32
c
=
static_cast
<
CP32
>
(
*
-
-
p
)
;
if
(
!
U16_IS_TRAIL
(
c
)
)
{
return
{
c
1
p
p0
}
;
}
else
{
uint16_t
c2
=
*
-
-
p
;
c
=
U16_GET_SUPPLEMENTARY
(
c2
c
)
;
return
{
c
2
p
p0
}
;
}
}
}
;
template
<
typename
CP32
typename
UnitIter
>
class
UnsafeUTFImpl
<
CP32
UnitIter
std
:
:
enable_if_t
<
sizeof
(
typename
prv
:
:
iter_value_t
<
UnitIter
>
)
=
=
4
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
U_FORCE_INLINE
static
void
inc
(
UnitIter
&
p
)
{
+
+
p
;
}
U_FORCE_INLINE
static
void
dec
(
UnitIter
&
p
)
{
-
-
p
;
}
U_FORCE_INLINE
static
UnsafeCodeUnits
<
CP32
UnitIter
>
readAndInc
(
UnitIter
&
p0
UnitIter
&
p
)
{
constexpr
bool
isMultiPass
=
prv
:
:
forward_iterator
<
UnitIter
>
;
CP32
c
=
*
p
;
+
+
p
;
if
constexpr
(
isMultiPass
)
{
return
{
c
1
p0
p
}
;
}
else
{
return
{
c
1
}
;
}
}
U_FORCE_INLINE
static
UnsafeCodeUnits
<
CP32
UnitIter
>
decAndRead
(
UnitIter
&
p
)
{
UnitIter
p0
=
p
;
CP32
c
=
*
-
-
p
;
return
{
c
1
p
p0
}
;
}
}
;
#
endif
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
typename
LimitIter
=
UnitIter
typename
=
void
>
class
UTFIterator
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
using
Impl
=
UTFImpl
<
CP32
behavior
UnitIter
LimitIter
>
;
class
Proxy
{
public
:
explicit
Proxy
(
CodeUnits
<
CP32
UnitIter
>
&
units
)
:
units_
(
units
)
{
}
CodeUnits
<
CP32
UnitIter
>
&
operator
*
(
)
{
return
units_
;
}
CodeUnits
<
CP32
UnitIter
>
*
operator
-
>
(
)
{
return
&
units_
;
}
private
:
CodeUnits
<
CP32
UnitIter
>
units_
;
}
;
public
:
using
value_type
=
CodeUnits
<
CP32
UnitIter
>
;
using
reference
=
value_type
;
using
pointer
=
Proxy
;
using
difference_type
=
prv
:
:
iter_difference_t
<
UnitIter
>
;
using
iterator_category
=
std
:
:
conditional_t
<
prv
:
:
bidirectional_iterator
<
UnitIter
>
std
:
:
bidirectional_iterator_tag
std
:
:
forward_iterator_tag
>
;
U_FORCE_INLINE
UTFIterator
(
UnitIter
start
UnitIter
p
LimitIter
limit
)
:
p_
(
p
)
start_
(
start
)
limit_
(
limit
)
units_
(
0
0
false
p
p
)
{
}
U_FORCE_INLINE
UTFIterator
(
UnitIter
p
LimitIter
limit
)
:
p_
(
p
)
start_
(
p
)
limit_
(
limit
)
units_
(
0
0
false
p
p
)
{
}
U_FORCE_INLINE
explicit
UTFIterator
(
UnitIter
p
)
:
p_
(
p
)
start_
(
p
)
limit_
(
p
)
units_
(
0
0
false
p
p
)
{
}
U_FORCE_INLINE
UTFIterator
(
)
:
p_
{
}
start_
{
}
limit_
{
}
units_
(
0
0
false
p_
p_
)
{
}
U_FORCE_INLINE
UTFIterator
(
UTFIterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
UTFIterator
&
operator
=
(
UTFIterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
UTFIterator
(
const
UTFIterator
&
other
)
=
default
;
U_FORCE_INLINE
UTFIterator
&
operator
=
(
const
UTFIterator
&
other
)
=
default
;
U_FORCE_INLINE
bool
operator
=
=
(
const
UTFIterator
&
other
)
const
{
return
getLogicalPosition
(
)
=
=
other
.
getLogicalPosition
(
)
;
}
U_FORCE_INLINE
bool
operator
!
=
(
const
UTFIterator
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
=
=
(
const
UTFIterator
&
iter
const
Sentinel
&
s
)
{
return
iter
.
getLogicalPosition
(
)
=
=
s
;
}
#
if
U_CPLUSPLUS_VERSION
<
20
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
=
=
(
const
Sentinel
&
s
const
UTFIterator
&
iter
)
{
return
iter
.
getLogicalPosition
(
)
=
=
s
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
!
=
(
const
UTFIterator
&
iter
const
Sentinel
&
s
)
{
return
!
(
iter
=
=
s
)
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
!
=
(
const
Sentinel
&
s
const
UTFIterator
&
iter
)
{
return
!
(
iter
=
=
s
)
;
}
#
endif
U_FORCE_INLINE
CodeUnits
<
CP32
UnitIter
>
operator
*
(
)
const
{
if
(
state_
=
=
0
)
{
UnitIter
p0
=
p_
;
units_
=
Impl
:
:
readAndInc
(
p0
p_
limit_
)
;
state_
=
1
;
}
return
units_
;
}
U_FORCE_INLINE
Proxy
operator
-
>
(
)
const
{
if
(
state_
=
=
0
)
{
UnitIter
p0
=
p_
;
units_
=
Impl
:
:
readAndInc
(
p0
p_
limit_
)
;
state_
=
1
;
}
return
Proxy
(
units_
)
;
}
U_FORCE_INLINE
UTFIterator
&
operator
+
+
(
)
{
if
(
state_
>
0
)
{
state_
=
0
;
}
else
if
(
state_
=
=
0
)
{
Impl
:
:
inc
(
p_
limit_
)
;
}
else
{
p_
=
units_
.
end
(
)
;
state_
=
0
;
}
return
*
this
;
}
U_FORCE_INLINE
UTFIterator
operator
+
+
(
int
)
{
if
(
state_
>
0
)
{
UTFIterator
result
(
*
this
)
;
state_
=
0
;
return
result
;
}
else
if
(
state_
=
=
0
)
{
UnitIter
p0
=
p_
;
units_
=
Impl
:
:
readAndInc
(
p0
p_
limit_
)
;
UTFIterator
result
(
*
this
)
;
result
.
state_
=
1
;
return
result
;
}
else
{
UTFIterator
result
(
*
this
)
;
p_
=
units_
.
end
(
)
;
state_
=
0
;
return
result
;
}
}
template
<
typename
Iter
=
UnitIter
>
U_FORCE_INLINE
std
:
:
enable_if_t
<
prv
:
:
bidirectional_iterator
<
Iter
>
UTFIterator
&
>
operator
-
-
(
)
{
if
(
state_
>
0
)
{
p_
=
units_
.
begin
(
)
;
}
units_
=
Impl
:
:
decAndRead
(
start_
p_
)
;
state_
=
-
1
;
return
*
this
;
}
template
<
typename
Iter
=
UnitIter
>
U_FORCE_INLINE
std
:
:
enable_if_t
<
prv
:
:
bidirectional_iterator
<
Iter
>
UTFIterator
>
operator
-
-
(
int
)
{
UTFIterator
result
(
*
this
)
;
operator
-
-
(
)
;
return
result
;
}
private
:
friend
class
std
:
:
reverse_iterator
<
UTFIterator
<
CP32
behavior
UnitIter
>
>
;
U_FORCE_INLINE
UnitIter
getLogicalPosition
(
)
const
{
return
state_
<
=
0
?
p_
:
units_
.
begin
(
)
;
}
mutable
UnitIter
p_
;
UnitIter
start_
;
LimitIter
limit_
;
mutable
CodeUnits
<
CP32
UnitIter
>
units_
;
mutable
int8_t
state_
=
0
;
}
;
#
ifndef
U_IN_DOXYGEN
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
typename
LimitIter
>
class
UTFIterator
<
CP32
behavior
UnitIter
LimitIter
std
:
:
enable_if_t
<
!
prv
:
:
forward_iterator
<
UnitIter
>
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
using
Impl
=
UTFImpl
<
CP32
behavior
UnitIter
LimitIter
>
;
class
Proxy
{
public
:
explicit
Proxy
(
CodeUnits
<
CP32
UnitIter
>
&
units
)
:
units_
(
units
)
{
}
CodeUnits
<
CP32
UnitIter
>
&
operator
*
(
)
{
return
units_
;
}
CodeUnits
<
CP32
UnitIter
>
*
operator
-
>
(
)
{
return
&
units_
;
}
private
:
CodeUnits
<
CP32
UnitIter
>
units_
;
}
;
public
:
using
value_type
=
CodeUnits
<
CP32
UnitIter
>
;
using
reference
=
value_type
;
using
pointer
=
Proxy
;
using
difference_type
=
prv
:
:
iter_difference_t
<
UnitIter
>
;
using
iterator_category
=
std
:
:
input_iterator_tag
;
U_FORCE_INLINE
UTFIterator
(
UnitIter
p
LimitIter
limit
)
:
p_
(
std
:
:
move
(
p
)
)
limit_
(
std
:
:
move
(
limit
)
)
{
}
U_FORCE_INLINE
explicit
UTFIterator
(
UnitIter
p
)
:
p_
(
std
:
:
move
(
p
)
)
limit_
(
p_
)
{
}
U_FORCE_INLINE
UTFIterator
(
UTFIterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
UTFIterator
&
operator
=
(
UTFIterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
UTFIterator
(
const
UTFIterator
&
other
)
=
default
;
U_FORCE_INLINE
UTFIterator
&
operator
=
(
const
UTFIterator
&
other
)
=
default
;
U_FORCE_INLINE
bool
operator
=
=
(
const
UTFIterator
&
other
)
const
{
return
p_
=
=
other
.
p_
&
&
ahead_
=
=
other
.
ahead_
;
}
U_FORCE_INLINE
bool
operator
!
=
(
const
UTFIterator
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
=
=
(
const
UTFIterator
&
iter
const
Sentinel
&
s
)
{
return
!
iter
.
ahead_
&
&
iter
.
p_
=
=
s
;
}
#
if
U_CPLUSPLUS_VERSION
<
20
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
=
=
(
const
Sentinel
&
s
const
UTFIterator
&
iter
)
{
return
!
iter
.
ahead_
&
&
iter
.
p_
=
=
s
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
!
=
(
const
UTFIterator
&
iter
const
Sentinel
&
s
)
{
return
!
(
iter
=
=
s
)
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
!
=
(
const
Sentinel
&
s
const
UTFIterator
&
iter
)
{
return
!
(
iter
=
=
s
)
;
}
#
endif
U_FORCE_INLINE
CodeUnits
<
CP32
UnitIter
>
operator
*
(
)
const
{
if
(
!
ahead_
)
{
units_
=
Impl
:
:
readAndInc
(
p_
p_
limit_
)
;
ahead_
=
true
;
}
return
units_
;
}
U_FORCE_INLINE
Proxy
operator
-
>
(
)
const
{
if
(
!
ahead_
)
{
units_
=
Impl
:
:
readAndInc
(
p_
p_
limit_
)
;
ahead_
=
true
;
}
return
Proxy
(
units_
)
;
}
U_FORCE_INLINE
UTFIterator
&
operator
+
+
(
)
{
if
(
ahead_
)
{
ahead_
=
false
;
}
else
{
Impl
:
:
inc
(
p_
limit_
)
;
}
return
*
this
;
}
U_FORCE_INLINE
Proxy
operator
+
+
(
int
)
{
if
(
ahead_
)
{
ahead_
=
false
;
}
else
{
units_
=
Impl
:
:
readAndInc
(
p_
p_
limit_
)
;
}
return
Proxy
(
units_
)
;
}
private
:
mutable
UnitIter
p_
;
LimitIter
limit_
;
mutable
CodeUnits
<
CP32
UnitIter
>
units_
=
{
0
0
false
}
;
mutable
bool
ahead_
=
false
;
}
;
#
endif
}
#
ifndef
U_IN_DOXYGEN
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
>
class
std
:
:
reverse_iterator
<
U_HEADER_ONLY_NAMESPACE
:
:
UTFIterator
<
CP32
behavior
UnitIter
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
using
Impl
=
U_HEADER_ONLY_NAMESPACE
:
:
UTFImpl
<
CP32
behavior
UnitIter
>
;
using
CodeUnits_
=
U_HEADER_ONLY_NAMESPACE
:
:
CodeUnits
<
CP32
UnitIter
>
;
class
Proxy
{
public
:
explicit
Proxy
(
CodeUnits_
units
)
:
units_
(
units
)
{
}
CodeUnits_
&
operator
*
(
)
{
return
units_
;
}
CodeUnits_
*
operator
-
>
(
)
{
return
&
units_
;
}
private
:
CodeUnits_
units_
;
}
;
public
:
using
value_type
=
CodeUnits_
;
using
reference
=
value_type
;
using
pointer
=
Proxy
;
using
difference_type
=
U_HEADER_ONLY_NAMESPACE
:
:
prv
:
:
iter_difference_t
<
UnitIter
>
;
using
iterator_category
=
std
:
:
bidirectional_iterator_tag
;
U_FORCE_INLINE
explicit
reverse_iterator
(
U_HEADER_ONLY_NAMESPACE
:
:
UTFIterator
<
CP32
behavior
UnitIter
>
iter
)
:
p_
(
iter
.
getLogicalPosition
(
)
)
start_
(
iter
.
start_
)
limit_
(
iter
.
limit_
)
units_
(
0
0
false
p_
p_
)
{
}
U_FORCE_INLINE
reverse_iterator
(
)
:
p_
{
}
start_
{
}
limit_
{
}
units_
(
0
0
false
p_
p_
)
{
}
U_FORCE_INLINE
reverse_iterator
(
reverse_iterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
reverse_iterator
&
operator
=
(
reverse_iterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
reverse_iterator
(
const
reverse_iterator
&
other
)
=
default
;
U_FORCE_INLINE
reverse_iterator
&
operator
=
(
const
reverse_iterator
&
other
)
=
default
;
U_FORCE_INLINE
bool
operator
=
=
(
const
reverse_iterator
&
other
)
const
{
return
getLogicalPosition
(
)
=
=
other
.
getLogicalPosition
(
)
;
}
U_FORCE_INLINE
bool
operator
!
=
(
const
reverse_iterator
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
U_FORCE_INLINE
CodeUnits_
operator
*
(
)
const
{
if
(
state_
=
=
0
)
{
units_
=
Impl
:
:
decAndRead
(
start_
p_
)
;
state_
=
-
1
;
}
return
units_
;
}
U_FORCE_INLINE
Proxy
operator
-
>
(
)
const
{
if
(
state_
=
=
0
)
{
units_
=
Impl
:
:
decAndRead
(
start_
p_
)
;
state_
=
-
1
;
}
return
Proxy
(
units_
)
;
}
U_FORCE_INLINE
reverse_iterator
&
operator
+
+
(
)
{
if
(
state_
<
0
)
{
state_
=
0
;
}
else
if
(
state_
=
=
0
)
{
Impl
:
:
dec
(
start_
p_
)
;
}
else
{
p_
=
units_
.
begin
(
)
;
state_
=
0
;
}
return
*
this
;
}
U_FORCE_INLINE
reverse_iterator
operator
+
+
(
int
)
{
if
(
state_
<
0
)
{
reverse_iterator
result
(
*
this
)
;
state_
=
0
;
return
result
;
}
else
if
(
state_
=
=
0
)
{
units_
=
Impl
:
:
decAndRead
(
start_
p_
)
;
reverse_iterator
result
(
*
this
)
;
result
.
state_
=
-
1
;
return
result
;
}
else
{
reverse_iterator
result
(
*
this
)
;
p_
=
units_
.
begin
(
)
;
state_
=
0
;
return
result
;
}
}
U_FORCE_INLINE
reverse_iterator
&
operator
-
-
(
)
{
if
(
state_
<
0
)
{
p_
=
units_
.
end
(
)
;
}
UnitIter
p0
=
p_
;
units_
=
Impl
:
:
readAndInc
(
p0
p_
limit_
)
;
state_
=
1
;
return
*
this
;
}
U_FORCE_INLINE
reverse_iterator
operator
-
-
(
int
)
{
reverse_iterator
result
(
*
this
)
;
operator
-
-
(
)
;
return
result
;
}
private
:
U_FORCE_INLINE
UnitIter
getLogicalPosition
(
)
const
{
return
state_
>
=
0
?
p_
:
units_
.
end
(
)
;
}
mutable
UnitIter
p_
;
UnitIter
start_
;
UnitIter
limit_
;
mutable
CodeUnits_
units_
;
mutable
int8_t
state_
=
0
;
}
;
#
endif
namespace
U_HEADER_ONLY_NAMESPACE
{
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
typename
LimitIter
=
UnitIter
>
auto
utfIterator
(
UnitIter
start
UnitIter
p
LimitIter
limit
)
{
return
UTFIterator
<
CP32
behavior
UnitIter
LimitIter
>
(
std
:
:
move
(
start
)
std
:
:
move
(
p
)
std
:
:
move
(
limit
)
)
;
}
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
typename
LimitIter
=
UnitIter
>
auto
utfIterator
(
UnitIter
p
LimitIter
limit
)
{
return
UTFIterator
<
CP32
behavior
UnitIter
LimitIter
>
(
std
:
:
move
(
p
)
std
:
:
move
(
limit
)
)
;
}
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
UnitIter
>
auto
utfIterator
(
UnitIter
p
)
{
return
UTFIterator
<
CP32
behavior
UnitIter
>
(
std
:
:
move
(
p
)
)
;
}
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
Range
>
class
UTFStringCodePoints
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
UTFStringCodePoints
(
)
=
default
;
template
<
typename
R
=
Range
typename
=
std
:
:
enable_if_t
<
!
std
:
:
is_reference_v
<
R
>
>
>
explicit
UTFStringCodePoints
(
Range
unitRange
)
:
unitRange
(
std
:
:
move
(
unitRange
)
)
{
}
template
<
typename
R
=
Range
typename
=
std
:
:
enable_if_t
<
std
:
:
is_reference_v
<
R
>
>
typename
=
void
>
explicit
UTFStringCodePoints
(
Range
unitRange
)
:
unitRange
(
unitRange
)
{
}
UTFStringCodePoints
(
const
UTFStringCodePoints
&
other
)
=
default
;
UTFStringCodePoints
&
operator
=
(
const
UTFStringCodePoints
&
other
)
=
default
;
auto
begin
(
)
{
return
utfIterator
<
CP32
behavior
>
(
unitRange
.
begin
(
)
unitRange
.
end
(
)
)
;
}
template
<
typename
R
=
Range
typename
=
std
:
:
enable_if_t
<
prv
:
:
range
<
const
R
>
>
>
auto
begin
(
)
const
{
return
utfIterator
<
CP32
behavior
>
(
unitRange
.
begin
(
)
unitRange
.
end
(
)
)
;
}
auto
end
(
)
{
using
UnitIter
=
decltype
(
unitRange
.
begin
(
)
)
;
using
LimitIter
=
decltype
(
unitRange
.
end
(
)
)
;
if
constexpr
(
!
std
:
:
is_same_v
<
UnitIter
LimitIter
>
)
{
return
unitRange
.
end
(
)
;
}
else
if
constexpr
(
prv
:
:
bidirectional_iterator
<
UnitIter
>
)
{
return
utfIterator
<
CP32
behavior
>
(
unitRange
.
begin
(
)
unitRange
.
end
(
)
unitRange
.
end
(
)
)
;
}
else
{
return
utfIterator
<
CP32
behavior
>
(
unitRange
.
end
(
)
unitRange
.
end
(
)
)
;
}
}
template
<
typename
R
=
Range
typename
=
std
:
:
enable_if_t
<
prv
:
:
range
<
const
R
>
>
>
auto
end
(
)
const
{
using
UnitIter
=
decltype
(
unitRange
.
begin
(
)
)
;
using
LimitIter
=
decltype
(
unitRange
.
end
(
)
)
;
if
constexpr
(
!
std
:
:
is_same_v
<
UnitIter
LimitIter
>
)
{
return
unitRange
.
end
(
)
;
}
else
if
constexpr
(
prv
:
:
bidirectional_iterator
<
UnitIter
>
)
{
return
utfIterator
<
CP32
behavior
>
(
unitRange
.
begin
(
)
unitRange
.
end
(
)
unitRange
.
end
(
)
)
;
}
else
{
return
utfIterator
<
CP32
behavior
>
(
unitRange
.
end
(
)
unitRange
.
end
(
)
)
;
}
}
auto
rbegin
(
)
const
{
return
std
:
:
make_reverse_iterator
(
end
(
)
)
;
}
auto
rend
(
)
const
{
return
std
:
:
make_reverse_iterator
(
begin
(
)
)
;
}
private
:
Range
unitRange
;
}
;
template
<
typename
CP32
UTFIllFormedBehavior
behavior
>
struct
UTFStringCodePointsAdaptor
#
if
U_CPLUSPLUS_VERSION
>
=
23
&
&
__cpp_lib_ranges
>
=
2022
'
02
&
&
\
__cpp_lib_bind_back
>
=
2022
'
02
:
std
:
:
ranges
:
:
range_adaptor_closure
<
UTFStringCodePointsAdaptor
<
CP32
behavior
>
>
#
endif
{
template
<
typename
Range
>
auto
operator
(
)
(
Range
&
&
unitRange
)
const
{
#
if
defined
(
__cpp_lib_ranges
)
&
&
__cpp_lib_ranges
>
=
2021
'
10
return
UTFStringCodePoints
<
CP32
behavior
std
:
:
ranges
:
:
views
:
:
all_t
<
Range
>
>
(
std
:
:
forward
<
Range
>
(
unitRange
)
)
;
#
else
if
constexpr
(
prv
:
:
is_basic_string_view_v
<
std
:
:
decay_t
<
Range
>
>
)
{
return
UTFStringCodePoints
<
CP32
behavior
std
:
:
decay_t
<
Range
>
>
(
std
:
:
forward
<
Range
>
(
unitRange
)
)
;
}
else
{
return
UTFStringCodePoints
<
CP32
behavior
Range
>
(
std
:
:
forward
<
Range
>
(
unitRange
)
)
;
}
#
endif
}
}
;
template
<
typename
CP32
UTFIllFormedBehavior
behavior
>
constexpr
UTFStringCodePointsAdaptor
<
CP32
behavior
>
utfStringCodePoints
;
template
<
typename
CP32
typename
UnitIter
typename
=
void
>
class
UnsafeUTFIterator
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
using
Impl
=
UnsafeUTFImpl
<
CP32
UnitIter
>
;
class
Proxy
{
public
:
explicit
Proxy
(
UnsafeCodeUnits
<
CP32
UnitIter
>
&
units
)
:
units_
(
units
)
{
}
UnsafeCodeUnits
<
CP32
UnitIter
>
&
operator
*
(
)
{
return
units_
;
}
UnsafeCodeUnits
<
CP32
UnitIter
>
*
operator
-
>
(
)
{
return
&
units_
;
}
private
:
UnsafeCodeUnits
<
CP32
UnitIter
>
units_
;
}
;
public
:
using
value_type
=
UnsafeCodeUnits
<
CP32
UnitIter
>
;
using
reference
=
value_type
;
using
pointer
=
Proxy
;
using
difference_type
=
prv
:
:
iter_difference_t
<
UnitIter
>
;
using
iterator_category
=
std
:
:
conditional_t
<
prv
:
:
bidirectional_iterator
<
UnitIter
>
std
:
:
bidirectional_iterator_tag
std
:
:
forward_iterator_tag
>
;
U_FORCE_INLINE
explicit
UnsafeUTFIterator
(
UnitIter
p
)
:
p_
(
p
)
units_
(
0
0
p
p
)
{
}
U_FORCE_INLINE
UnsafeUTFIterator
(
)
:
p_
{
}
units_
(
0
0
p_
p_
)
{
}
U_FORCE_INLINE
UnsafeUTFIterator
(
UnsafeUTFIterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
UnsafeUTFIterator
&
operator
=
(
UnsafeUTFIterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
UnsafeUTFIterator
(
const
UnsafeUTFIterator
&
other
)
=
default
;
U_FORCE_INLINE
UnsafeUTFIterator
&
operator
=
(
const
UnsafeUTFIterator
&
other
)
=
default
;
U_FORCE_INLINE
bool
operator
=
=
(
const
UnsafeUTFIterator
&
other
)
const
{
return
getLogicalPosition
(
)
=
=
other
.
getLogicalPosition
(
)
;
}
U_FORCE_INLINE
bool
operator
!
=
(
const
UnsafeUTFIterator
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UnsafeUTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
=
=
(
const
UnsafeUTFIterator
&
iter
const
Sentinel
&
s
)
{
return
iter
.
getLogicalPosition
(
)
=
=
s
;
}
#
if
U_CPLUSPLUS_VERSION
<
20
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UnsafeUTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
=
=
(
const
Sentinel
&
s
const
UnsafeUTFIterator
&
iter
)
{
return
iter
.
getLogicalPosition
(
)
=
=
s
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UnsafeUTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
!
=
(
const
UnsafeUTFIterator
&
iter
const
Sentinel
&
s
)
{
return
!
(
iter
=
=
s
)
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UnsafeUTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
!
=
(
const
Sentinel
&
s
const
UnsafeUTFIterator
&
iter
)
{
return
!
(
iter
=
=
s
)
;
}
#
endif
U_FORCE_INLINE
UnsafeCodeUnits
<
CP32
UnitIter
>
operator
*
(
)
const
{
if
(
state_
=
=
0
)
{
UnitIter
p0
=
p_
;
units_
=
Impl
:
:
readAndInc
(
p0
p_
)
;
state_
=
1
;
}
return
units_
;
}
U_FORCE_INLINE
Proxy
operator
-
>
(
)
const
{
if
(
state_
=
=
0
)
{
UnitIter
p0
=
p_
;
units_
=
Impl
:
:
readAndInc
(
p0
p_
)
;
state_
=
1
;
}
return
Proxy
(
units_
)
;
}
U_FORCE_INLINE
UnsafeUTFIterator
&
operator
+
+
(
)
{
if
(
state_
>
0
)
{
state_
=
0
;
}
else
if
(
state_
=
=
0
)
{
Impl
:
:
inc
(
p_
)
;
}
else
{
p_
=
units_
.
end
(
)
;
state_
=
0
;
}
return
*
this
;
}
U_FORCE_INLINE
UnsafeUTFIterator
operator
+
+
(
int
)
{
if
(
state_
>
0
)
{
UnsafeUTFIterator
result
(
*
this
)
;
state_
=
0
;
return
result
;
}
else
if
(
state_
=
=
0
)
{
UnitIter
p0
=
p_
;
units_
=
Impl
:
:
readAndInc
(
p0
p_
)
;
UnsafeUTFIterator
result
(
*
this
)
;
result
.
state_
=
1
;
return
result
;
}
else
{
UnsafeUTFIterator
result
(
*
this
)
;
p_
=
units_
.
end
(
)
;
state_
=
0
;
return
result
;
}
}
template
<
typename
Iter
=
UnitIter
>
U_FORCE_INLINE
std
:
:
enable_if_t
<
prv
:
:
bidirectional_iterator
<
Iter
>
UnsafeUTFIterator
&
>
operator
-
-
(
)
{
if
(
state_
>
0
)
{
p_
=
units_
.
begin
(
)
;
}
units_
=
Impl
:
:
decAndRead
(
p_
)
;
state_
=
-
1
;
return
*
this
;
}
template
<
typename
Iter
=
UnitIter
>
U_FORCE_INLINE
std
:
:
enable_if_t
<
prv
:
:
bidirectional_iterator
<
Iter
>
UnsafeUTFIterator
>
operator
-
-
(
int
)
{
UnsafeUTFIterator
result
(
*
this
)
;
operator
-
-
(
)
;
return
result
;
}
private
:
friend
class
std
:
:
reverse_iterator
<
UnsafeUTFIterator
<
CP32
UnitIter
>
>
;
U_FORCE_INLINE
UnitIter
getLogicalPosition
(
)
const
{
return
state_
<
=
0
?
p_
:
units_
.
begin
(
)
;
}
mutable
UnitIter
p_
;
mutable
UnsafeCodeUnits
<
CP32
UnitIter
>
units_
;
mutable
int8_t
state_
=
0
;
}
;
#
ifndef
U_IN_DOXYGEN
template
<
typename
CP32
typename
UnitIter
>
class
UnsafeUTFIterator
<
CP32
UnitIter
std
:
:
enable_if_t
<
!
prv
:
:
forward_iterator
<
UnitIter
>
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
using
Impl
=
UnsafeUTFImpl
<
CP32
UnitIter
>
;
class
Proxy
{
public
:
explicit
Proxy
(
UnsafeCodeUnits
<
CP32
UnitIter
>
&
units
)
:
units_
(
units
)
{
}
UnsafeCodeUnits
<
CP32
UnitIter
>
&
operator
*
(
)
{
return
units_
;
}
UnsafeCodeUnits
<
CP32
UnitIter
>
*
operator
-
>
(
)
{
return
&
units_
;
}
private
:
UnsafeCodeUnits
<
CP32
UnitIter
>
units_
;
}
;
public
:
using
value_type
=
UnsafeCodeUnits
<
CP32
UnitIter
>
;
using
reference
=
value_type
;
using
pointer
=
Proxy
;
using
difference_type
=
prv
:
:
iter_difference_t
<
UnitIter
>
;
using
iterator_category
=
std
:
:
input_iterator_tag
;
U_FORCE_INLINE
explicit
UnsafeUTFIterator
(
UnitIter
p
)
:
p_
(
std
:
:
move
(
p
)
)
{
}
U_FORCE_INLINE
UnsafeUTFIterator
(
UnsafeUTFIterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
UnsafeUTFIterator
&
operator
=
(
UnsafeUTFIterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
UnsafeUTFIterator
(
const
UnsafeUTFIterator
&
other
)
=
default
;
U_FORCE_INLINE
UnsafeUTFIterator
&
operator
=
(
const
UnsafeUTFIterator
&
other
)
=
default
;
U_FORCE_INLINE
bool
operator
=
=
(
const
UnsafeUTFIterator
&
other
)
const
{
return
p_
=
=
other
.
p_
&
&
ahead_
=
=
other
.
ahead_
;
}
U_FORCE_INLINE
bool
operator
!
=
(
const
UnsafeUTFIterator
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UnsafeUTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
=
=
(
const
UnsafeUTFIterator
&
iter
const
Sentinel
&
s
)
{
return
!
iter
.
ahead_
&
&
iter
.
p_
=
=
s
;
}
#
if
U_CPLUSPLUS_VERSION
<
20
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UnsafeUTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
=
=
(
const
Sentinel
&
s
const
UnsafeUTFIterator
&
iter
)
{
return
!
iter
.
ahead_
&
&
iter
.
p_
=
=
s
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UnsafeUTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
!
=
(
const
UnsafeUTFIterator
&
iter
const
Sentinel
&
s
)
{
return
!
(
iter
=
=
s
)
;
}
template
<
typename
Sentinel
>
U_FORCE_INLINE
friend
std
:
:
enable_if_t
<
!
std
:
:
is_same_v
<
Sentinel
UnsafeUTFIterator
>
&
&
!
std
:
:
is_same_v
<
Sentinel
UnitIter
>
bool
>
operator
!
=
(
const
Sentinel
&
s
const
UnsafeUTFIterator
&
iter
)
{
return
!
(
iter
=
=
s
)
;
}
#
endif
U_FORCE_INLINE
UnsafeCodeUnits
<
CP32
UnitIter
>
operator
*
(
)
const
{
if
(
!
ahead_
)
{
units_
=
Impl
:
:
readAndInc
(
p_
p_
)
;
ahead_
=
true
;
}
return
units_
;
}
U_FORCE_INLINE
Proxy
operator
-
>
(
)
const
{
if
(
!
ahead_
)
{
units_
=
Impl
:
:
readAndInc
(
p_
p_
)
;
ahead_
=
true
;
}
return
Proxy
(
units_
)
;
}
U_FORCE_INLINE
UnsafeUTFIterator
&
operator
+
+
(
)
{
if
(
ahead_
)
{
ahead_
=
false
;
}
else
{
Impl
:
:
inc
(
p_
)
;
}
return
*
this
;
}
U_FORCE_INLINE
Proxy
operator
+
+
(
int
)
{
if
(
ahead_
)
{
ahead_
=
false
;
}
else
{
units_
=
Impl
:
:
readAndInc
(
p_
p_
)
;
}
return
Proxy
(
units_
)
;
}
private
:
mutable
UnitIter
p_
;
mutable
UnsafeCodeUnits
<
CP32
UnitIter
>
units_
=
{
0
0
}
;
mutable
bool
ahead_
=
false
;
}
;
#
endif
}
#
ifndef
U_IN_DOXYGEN
template
<
typename
CP32
typename
UnitIter
>
class
std
:
:
reverse_iterator
<
U_HEADER_ONLY_NAMESPACE
:
:
UnsafeUTFIterator
<
CP32
UnitIter
>
>
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
using
Impl
=
U_HEADER_ONLY_NAMESPACE
:
:
UnsafeUTFImpl
<
CP32
UnitIter
>
;
using
UnsafeCodeUnits_
=
U_HEADER_ONLY_NAMESPACE
:
:
UnsafeCodeUnits
<
CP32
UnitIter
>
;
class
Proxy
{
public
:
explicit
Proxy
(
UnsafeCodeUnits_
units
)
:
units_
(
units
)
{
}
UnsafeCodeUnits_
&
operator
*
(
)
{
return
units_
;
}
UnsafeCodeUnits_
*
operator
-
>
(
)
{
return
&
units_
;
}
private
:
UnsafeCodeUnits_
units_
;
}
;
public
:
using
value_type
=
UnsafeCodeUnits_
;
using
reference
=
value_type
;
using
pointer
=
Proxy
;
using
difference_type
=
U_HEADER_ONLY_NAMESPACE
:
:
prv
:
:
iter_difference_t
<
UnitIter
>
;
using
iterator_category
=
std
:
:
bidirectional_iterator_tag
;
U_FORCE_INLINE
explicit
reverse_iterator
(
U_HEADER_ONLY_NAMESPACE
:
:
UnsafeUTFIterator
<
CP32
UnitIter
>
iter
)
:
p_
(
iter
.
getLogicalPosition
(
)
)
units_
(
0
0
p_
p_
)
{
}
U_FORCE_INLINE
reverse_iterator
(
)
:
p_
{
}
units_
(
0
0
p_
p_
)
{
}
U_FORCE_INLINE
reverse_iterator
(
reverse_iterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
reverse_iterator
&
operator
=
(
reverse_iterator
&
&
src
)
noexcept
=
default
;
U_FORCE_INLINE
reverse_iterator
(
const
reverse_iterator
&
other
)
=
default
;
U_FORCE_INLINE
reverse_iterator
&
operator
=
(
const
reverse_iterator
&
other
)
=
default
;
U_FORCE_INLINE
bool
operator
=
=
(
const
reverse_iterator
&
other
)
const
{
return
getLogicalPosition
(
)
=
=
other
.
getLogicalPosition
(
)
;
}
U_FORCE_INLINE
bool
operator
!
=
(
const
reverse_iterator
&
other
)
const
{
return
!
operator
=
=
(
other
)
;
}
U_FORCE_INLINE
UnsafeCodeUnits_
operator
*
(
)
const
{
if
(
state_
=
=
0
)
{
units_
=
Impl
:
:
decAndRead
(
p_
)
;
state_
=
-
1
;
}
return
units_
;
}
U_FORCE_INLINE
Proxy
operator
-
>
(
)
const
{
if
(
state_
=
=
0
)
{
units_
=
Impl
:
:
decAndRead
(
p_
)
;
state_
=
-
1
;
}
return
Proxy
(
units_
)
;
}
U_FORCE_INLINE
reverse_iterator
&
operator
+
+
(
)
{
if
(
state_
<
0
)
{
state_
=
0
;
}
else
if
(
state_
=
=
0
)
{
Impl
:
:
dec
(
p_
)
;
}
else
{
p_
=
units_
.
begin
(
)
;
state_
=
0
;
}
return
*
this
;
}
U_FORCE_INLINE
reverse_iterator
operator
+
+
(
int
)
{
if
(
state_
<
0
)
{
reverse_iterator
result
(
*
this
)
;
state_
=
0
;
return
result
;
}
else
if
(
state_
=
=
0
)
{
units_
=
Impl
:
:
decAndRead
(
p_
)
;
reverse_iterator
result
(
*
this
)
;
result
.
state_
=
-
1
;
return
result
;
}
else
{
reverse_iterator
result
(
*
this
)
;
p_
=
units_
.
begin
(
)
;
state_
=
0
;
return
result
;
}
}
U_FORCE_INLINE
reverse_iterator
&
operator
-
-
(
)
{
if
(
state_
<
0
)
{
p_
=
units_
.
end
(
)
;
}
UnitIter
p0
=
p_
;
units_
=
Impl
:
:
readAndInc
(
p0
p_
)
;
state_
=
1
;
return
*
this
;
}
U_FORCE_INLINE
reverse_iterator
operator
-
-
(
int
)
{
reverse_iterator
result
(
*
this
)
;
operator
-
-
(
)
;
return
result
;
}
private
:
U_FORCE_INLINE
UnitIter
getLogicalPosition
(
)
const
{
return
state_
>
=
0
?
p_
:
units_
.
end
(
)
;
}
mutable
UnitIter
p_
;
mutable
UnsafeCodeUnits_
units_
;
mutable
int8_t
state_
=
0
;
}
;
#
endif
namespace
U_HEADER_ONLY_NAMESPACE
{
template
<
typename
CP32
typename
UnitIter
>
auto
unsafeUTFIterator
(
UnitIter
iter
)
{
return
UnsafeUTFIterator
<
CP32
UnitIter
>
(
std
:
:
move
(
iter
)
)
;
}
template
<
typename
CP32
typename
Range
>
class
UnsafeUTFStringCodePoints
{
static_assert
(
sizeof
(
CP32
)
=
=
4
"
CP32
must
be
a
32
-
bit
type
to
hold
a
code
point
"
)
;
public
:
UnsafeUTFStringCodePoints
(
)
=
default
;
template
<
typename
R
=
Range
typename
=
std
:
:
enable_if_t
<
!
std
:
:
is_reference_v
<
R
>
>
>
explicit
UnsafeUTFStringCodePoints
(
Range
unitRange
)
:
unitRange
(
std
:
:
move
(
unitRange
)
)
{
}
template
<
typename
R
=
Range
typename
=
std
:
:
enable_if_t
<
std
:
:
is_reference_v
<
R
>
>
typename
=
void
>
explicit
UnsafeUTFStringCodePoints
(
Range
unitRange
)
:
unitRange
(
unitRange
)
{
}
UnsafeUTFStringCodePoints
(
const
UnsafeUTFStringCodePoints
&
other
)
=
default
;
UnsafeUTFStringCodePoints
&
operator
=
(
const
UnsafeUTFStringCodePoints
&
other
)
=
default
;
auto
begin
(
)
{
return
unsafeUTFIterator
<
CP32
>
(
unitRange
.
begin
(
)
)
;
}
template
<
typename
R
=
Range
typename
=
std
:
:
enable_if_t
<
prv
:
:
range
<
const
R
>
>
>
auto
begin
(
)
const
{
return
unsafeUTFIterator
<
CP32
>
(
unitRange
.
begin
(
)
)
;
}
auto
end
(
)
{
using
UnitIter
=
decltype
(
unitRange
.
begin
(
)
)
;
using
LimitIter
=
decltype
(
unitRange
.
end
(
)
)
;
if
constexpr
(
!
std
:
:
is_same_v
<
UnitIter
LimitIter
>
)
{
return
unitRange
.
end
(
)
;
}
else
{
return
unsafeUTFIterator
<
CP32
>
(
unitRange
.
end
(
)
)
;
}
}
template
<
typename
R
=
Range
typename
=
std
:
:
enable_if_t
<
prv
:
:
range
<
const
R
>
>
>
auto
end
(
)
const
{
using
UnitIter
=
decltype
(
unitRange
.
begin
(
)
)
;
using
LimitIter
=
decltype
(
unitRange
.
end
(
)
)
;
if
constexpr
(
!
std
:
:
is_same_v
<
UnitIter
LimitIter
>
)
{
return
unitRange
.
end
(
)
;
}
else
{
return
unsafeUTFIterator
<
CP32
>
(
unitRange
.
end
(
)
)
;
}
}
auto
rbegin
(
)
const
{
return
std
:
:
make_reverse_iterator
(
end
(
)
)
;
}
auto
rend
(
)
const
{
return
std
:
:
make_reverse_iterator
(
begin
(
)
)
;
}
private
:
Range
unitRange
;
}
;
template
<
typename
CP32
>
struct
UnsafeUTFStringCodePointsAdaptor
#
if
U_CPLUSPLUS_VERSION
>
=
23
&
&
__cpp_lib_ranges
>
=
2022
'
02
&
&
\
__cpp_lib_bind_back
>
=
2022
'
02
:
std
:
:
ranges
:
:
range_adaptor_closure
<
UnsafeUTFStringCodePointsAdaptor
<
CP32
>
>
#
endif
{
template
<
typename
Range
>
auto
operator
(
)
(
Range
&
&
unitRange
)
const
{
#
if
defined
(
__cpp_lib_ranges
)
&
&
__cpp_lib_ranges
>
=
2021
'
10
return
UnsafeUTFStringCodePoints
<
CP32
std
:
:
ranges
:
:
views
:
:
all_t
<
Range
>
>
(
std
:
:
forward
<
Range
>
(
unitRange
)
)
;
#
else
if
constexpr
(
prv
:
:
is_basic_string_view_v
<
std
:
:
decay_t
<
Range
>
>
)
{
return
UnsafeUTFStringCodePoints
<
CP32
std
:
:
decay_t
<
Range
>
>
(
std
:
:
forward
<
Range
>
(
unitRange
)
)
;
}
else
{
return
UnsafeUTFStringCodePoints
<
CP32
Range
>
(
std
:
:
forward
<
Range
>
(
unitRange
)
)
;
}
#
endif
}
}
;
template
<
typename
CP32
>
constexpr
UnsafeUTFStringCodePointsAdaptor
<
CP32
>
unsafeUTFStringCodePoints
;
}
#
if
defined
(
__cpp_lib_ranges
)
template
<
typename
CP32
UTFIllFormedBehavior
behavior
typename
Range
>
constexpr
bool
std
:
:
ranges
:
:
enable_borrowed_range
<
U_HEADER_ONLY_NAMESPACE
:
:
UTFStringCodePoints
<
CP32
behavior
Range
>
>
=
std
:
:
ranges
:
:
enable_borrowed_range
<
Range
>
;
template
<
typename
CP32
typename
Range
>
constexpr
bool
std
:
:
ranges
:
:
enable_borrowed_range
<
U_HEADER_ONLY_NAMESPACE
:
:
UnsafeUTFStringCodePoints
<
CP32
Range
>
>
=
std
:
:
ranges
:
:
enable_borrowed_range
<
Range
>
;
#
endif
#
endif
#
endif
#
endif
