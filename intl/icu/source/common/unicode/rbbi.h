#
ifndef
RBBI_H
#
define
RBBI_H
#
include
"
unicode
/
utypes
.
h
"
#
if
U_SHOW_CPLUSPLUS_API
#
if
!
UCONFIG_NO_BREAK_ITERATION
#
include
"
unicode
/
brkiter
.
h
"
#
include
"
unicode
/
udata
.
h
"
#
include
"
unicode
/
parseerr
.
h
"
#
include
"
unicode
/
schriter
.
h
"
struct
UCPTrie
;
U_NAMESPACE_BEGIN
class
LanguageBreakEngine
;
struct
RBBIDataHeader
;
class
RBBIDataWrapper
;
class
UnhandledEngine
;
class
UStack
;
#
ifndef
U_HIDE_INTERNAL_API
class
ExternalBreakEngine
:
public
UObject
{
public
:
virtual
~
ExternalBreakEngine
(
)
{
}
virtual
bool
isFor
(
UChar32
c
const
char
*
locale
)
const
=
0
;
virtual
bool
handles
(
UChar32
c
)
const
=
0
;
virtual
int32_t
fillBreaks
(
UText
*
text
int32_t
start
int32_t
end
int32_t
*
foundBreaks
int32_t
foundBreaksCapacity
UErrorCode
&
status
)
const
=
0
;
}
;
#
endif
class
U_COMMON_API
RuleBasedBreakIterator
:
public
BreakIterator
{
private
:
UText
fText
=
UTEXT_INITIALIZER
;
#
ifndef
U_HIDE_INTERNAL_API
public
:
#
endif
RBBIDataWrapper
*
fData
=
nullptr
;
private
:
UErrorCode
fErrorCode
=
U_ZERO_ERROR
;
int32_t
fPosition
=
0
;
int32_t
fRuleStatusIndex
=
0
;
class
BreakCache
;
BreakCache
*
fBreakCache
=
nullptr
;
class
DictionaryCache
;
DictionaryCache
*
fDictionaryCache
=
nullptr
;
UStack
*
fLanguageBreakEngines
=
nullptr
;
UnhandledEngine
*
fUnhandledBreakEngine
=
nullptr
;
uint32_t
fDictionaryCharCount
=
0
;
CharacterIterator
*
fCharIter
=
&
fSCharIter
;
UCharCharacterIterator
fSCharIter
{
u
"
"
0
}
;
bool
fDone
=
false
;
int32_t
*
fLookAheadMatches
=
nullptr
;
UBool
fIsPhraseBreaking
=
false
;
RuleBasedBreakIterator
(
RBBIDataHeader
*
data
UErrorCode
&
status
)
;
RuleBasedBreakIterator
(
UDataMemory
*
image
UBool
isPhraseBreaking
UErrorCode
&
status
)
;
friend
class
RBBIRuleBuilder
;
friend
class
BreakIterator
;
RuleBasedBreakIterator
(
UErrorCode
*
status
)
;
public
:
RuleBasedBreakIterator
(
)
;
RuleBasedBreakIterator
(
const
RuleBasedBreakIterator
&
that
)
;
RuleBasedBreakIterator
(
const
UnicodeString
&
rules
UParseError
&
parseError
UErrorCode
&
status
)
;
RuleBasedBreakIterator
(
const
uint8_t
*
compiledRules
uint32_t
ruleLength
UErrorCode
&
status
)
;
RuleBasedBreakIterator
(
UDataMemory
*
image
UErrorCode
&
status
)
;
virtual
~
RuleBasedBreakIterator
(
)
;
RuleBasedBreakIterator
&
operator
=
(
const
RuleBasedBreakIterator
&
that
)
;
virtual
bool
operator
=
=
(
const
BreakIterator
&
that
)
const
override
;
inline
bool
operator
!
=
(
const
BreakIterator
&
that
)
const
{
return
!
operator
=
=
(
that
)
;
}
virtual
RuleBasedBreakIterator
*
clone
(
)
const
override
;
virtual
int32_t
hashCode
(
)
const
;
virtual
const
UnicodeString
&
getRules
(
)
const
;
virtual
CharacterIterator
&
getText
(
)
const
override
;
virtual
UText
*
getUText
(
UText
*
fillIn
UErrorCode
&
status
)
const
override
;
virtual
void
adoptText
(
CharacterIterator
*
newText
)
override
;
virtual
void
setText
(
const
UnicodeString
&
newText
)
override
;
virtual
void
setText
(
UText
*
text
UErrorCode
&
status
)
override
;
virtual
int32_t
first
(
)
override
;
virtual
int32_t
last
(
)
override
;
virtual
int32_t
next
(
int32_t
n
)
override
;
virtual
int32_t
next
(
)
override
;
virtual
int32_t
previous
(
)
override
;
virtual
int32_t
following
(
int32_t
offset
)
override
;
virtual
int32_t
preceding
(
int32_t
offset
)
override
;
virtual
UBool
isBoundary
(
int32_t
offset
)
override
;
virtual
int32_t
current
(
)
const
override
;
virtual
int32_t
getRuleStatus
(
)
const
override
;
virtual
int32_t
getRuleStatusVec
(
int32_t
*
fillInVec
int32_t
capacity
UErrorCode
&
status
)
override
;
virtual
UClassID
getDynamicClassID
(
)
const
override
;
static
UClassID
U_EXPORT2
getStaticClassID
(
)
;
#
ifndef
U_FORCE_HIDE_DEPRECATED_API
virtual
RuleBasedBreakIterator
*
createBufferClone
(
void
*
stackBuffer
int32_t
&
BufferSize
UErrorCode
&
status
)
override
;
#
endif
virtual
const
uint8_t
*
getBinaryRules
(
uint32_t
&
length
)
;
virtual
RuleBasedBreakIterator
&
refreshInputText
(
UText
*
input
UErrorCode
&
status
)
override
;
private
:
int32_t
handleSafePrevious
(
int32_t
fromPosition
)
;
int32_t
handleNext
(
)
;
typedef
uint16_t
(
*
PTrieFunc
)
(
const
UCPTrie
*
UChar32
)
;
template
<
typename
RowType
PTrieFunc
trieFunc
>
int32_t
handleSafePrevious
(
int32_t
fromPosition
)
;
template
<
typename
RowType
PTrieFunc
trieFunc
>
int32_t
handleNext
(
)
;
const
LanguageBreakEngine
*
getLanguageBreakEngine
(
UChar32
c
const
char
*
locale
)
;
public
:
#
ifndef
U_HIDE_INTERNAL_API
void
dumpCache
(
)
;
void
dumpTables
(
)
;
#
endif
#
ifndef
U_HIDE_INTERNAL_API
static
void
U_EXPORT2
registerExternalBreakEngine
(
ExternalBreakEngine
*
toAdopt
UErrorCode
&
status
)
;
#
endif
}
;
U_NAMESPACE_END
#
endif
#
endif
#
endif
