#
ifndef
__NORMALIZER2IMPL_H__
#
define
__NORMALIZER2IMPL_H__
#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_NORMALIZATION
#
include
"
unicode
/
normalizer2
.
h
"
#
include
"
unicode
/
ucptrie
.
h
"
#
include
"
unicode
/
unistr
.
h
"
#
include
"
unicode
/
unorm
.
h
"
#
include
"
unicode
/
utf
.
h
"
#
include
"
unicode
/
utf16
.
h
"
#
include
"
mutex
.
h
"
#
include
"
udataswp
.
h
"
#
include
"
uset_imp
.
h
"
#
define
NORM2_HARDCODE_NFC_DATA
1
U_NAMESPACE_BEGIN
struct
CanonIterData
;
class
ByteSink
;
class
Edits
;
class
InitCanonIterData
;
class
LcccContext
;
class
U_COMMON_API
Hangul
{
public
:
enum
{
JAMO_L_BASE
=
0x1100
JAMO_L_END
=
0x1112
JAMO_V_BASE
=
0x1161
JAMO_V_END
=
0x1175
JAMO_T_BASE
=
0x11a7
JAMO_T_END
=
0x11c2
HANGUL_BASE
=
0xac00
HANGUL_END
=
0xd7a3
JAMO_L_COUNT
=
19
JAMO_V_COUNT
=
21
JAMO_T_COUNT
=
28
JAMO_VT_COUNT
=
JAMO_V_COUNT
*
JAMO_T_COUNT
HANGUL_COUNT
=
JAMO_L_COUNT
*
JAMO_V_COUNT
*
JAMO_T_COUNT
HANGUL_LIMIT
=
HANGUL_BASE
+
HANGUL_COUNT
}
;
static
inline
UBool
isHangul
(
UChar32
c
)
{
return
HANGUL_BASE
<
=
c
&
&
c
<
HANGUL_LIMIT
;
}
static
inline
UBool
isHangulLV
(
UChar32
c
)
{
c
-
=
HANGUL_BASE
;
return
0
<
=
c
&
&
c
<
HANGUL_COUNT
&
&
c
%
JAMO_T_COUNT
=
=
0
;
}
static
inline
UBool
isJamoL
(
UChar32
c
)
{
return
(
uint32_t
)
(
c
-
JAMO_L_BASE
)
<
JAMO_L_COUNT
;
}
static
inline
UBool
isJamoV
(
UChar32
c
)
{
return
(
uint32_t
)
(
c
-
JAMO_V_BASE
)
<
JAMO_V_COUNT
;
}
static
inline
UBool
isJamoT
(
UChar32
c
)
{
int32_t
t
=
c
-
JAMO_T_BASE
;
return
0
<
t
&
&
t
<
JAMO_T_COUNT
;
}
static
UBool
isJamo
(
UChar32
c
)
{
return
JAMO_L_BASE
<
=
c
&
&
c
<
=
JAMO_T_END
&
&
(
c
<
=
JAMO_L_END
|
|
(
JAMO_V_BASE
<
=
c
&
&
c
<
=
JAMO_V_END
)
|
|
JAMO_T_BASE
<
c
)
;
}
static
inline
int32_t
decompose
(
UChar32
c
char16_t
buffer
[
3
]
)
{
c
-
=
HANGUL_BASE
;
UChar32
c2
=
c
%
JAMO_T_COUNT
;
c
/
=
JAMO_T_COUNT
;
buffer
[
0
]
=
(
char16_t
)
(
JAMO_L_BASE
+
c
/
JAMO_V_COUNT
)
;
buffer
[
1
]
=
(
char16_t
)
(
JAMO_V_BASE
+
c
%
JAMO_V_COUNT
)
;
if
(
c2
=
=
0
)
{
return
2
;
}
else
{
buffer
[
2
]
=
(
char16_t
)
(
JAMO_T_BASE
+
c2
)
;
return
3
;
}
}
static
inline
void
getRawDecomposition
(
UChar32
c
char16_t
buffer
[
2
]
)
{
UChar32
orig
=
c
;
c
-
=
HANGUL_BASE
;
UChar32
c2
=
c
%
JAMO_T_COUNT
;
if
(
c2
=
=
0
)
{
c
/
=
JAMO_T_COUNT
;
buffer
[
0
]
=
(
char16_t
)
(
JAMO_L_BASE
+
c
/
JAMO_V_COUNT
)
;
buffer
[
1
]
=
(
char16_t
)
(
JAMO_V_BASE
+
c
%
JAMO_V_COUNT
)
;
}
else
{
buffer
[
0
]
=
(
char16_t
)
(
orig
-
c2
)
;
buffer
[
1
]
=
(
char16_t
)
(
JAMO_T_BASE
+
c2
)
;
}
}
private
:
Hangul
(
)
=
delete
;
}
;
class
Normalizer2Impl
;
class
U_COMMON_API
ReorderingBuffer
:
public
UMemory
{
public
:
ReorderingBuffer
(
const
Normalizer2Impl
&
ni
UnicodeString
&
dest
)
:
impl
(
ni
)
str
(
dest
)
start
(
NULL
)
reorderStart
(
NULL
)
limit
(
NULL
)
remainingCapacity
(
0
)
lastCC
(
0
)
{
}
ReorderingBuffer
(
const
Normalizer2Impl
&
ni
UnicodeString
&
dest
UErrorCode
&
errorCode
)
;
~
ReorderingBuffer
(
)
{
if
(
start
!
=
NULL
)
{
str
.
releaseBuffer
(
(
int32_t
)
(
limit
-
start
)
)
;
}
}
UBool
init
(
int32_t
destCapacity
UErrorCode
&
errorCode
)
;
UBool
isEmpty
(
)
const
{
return
start
=
=
limit
;
}
int32_t
length
(
)
const
{
return
(
int32_t
)
(
limit
-
start
)
;
}
char16_t
*
getStart
(
)
{
return
start
;
}
char16_t
*
getLimit
(
)
{
return
limit
;
}
uint8_t
getLastCC
(
)
const
{
return
lastCC
;
}
UBool
equals
(
const
char16_t
*
start
const
char16_t
*
limit
)
const
;
UBool
equals
(
const
uint8_t
*
otherStart
const
uint8_t
*
otherLimit
)
const
;
UBool
append
(
UChar32
c
uint8_t
cc
UErrorCode
&
errorCode
)
{
return
(
c
<
=
0xffff
)
?
appendBMP
(
(
char16_t
)
c
cc
errorCode
)
:
appendSupplementary
(
c
cc
errorCode
)
;
}
UBool
append
(
const
char16_t
*
s
int32_t
length
UBool
isNFD
uint8_t
leadCC
uint8_t
trailCC
UErrorCode
&
errorCode
)
;
UBool
appendBMP
(
char16_t
c
uint8_t
cc
UErrorCode
&
errorCode
)
{
if
(
remainingCapacity
=
=
0
&
&
!
resize
(
1
errorCode
)
)
{
return
false
;
}
if
(
lastCC
<
=
cc
|
|
cc
=
=
0
)
{
*
limit
+
+
=
c
;
lastCC
=
cc
;
if
(
cc
<
=
1
)
{
reorderStart
=
limit
;
}
}
else
{
insert
(
c
cc
)
;
}
-
-
remainingCapacity
;
return
true
;
}
UBool
appendZeroCC
(
UChar32
c
UErrorCode
&
errorCode
)
;
UBool
appendZeroCC
(
const
char16_t
*
s
const
char16_t
*
sLimit
UErrorCode
&
errorCode
)
;
void
remove
(
)
;
void
removeSuffix
(
int32_t
suffixLength
)
;
void
setReorderingLimit
(
char16_t
*
newLimit
)
{
remainingCapacity
+
=
(
int32_t
)
(
limit
-
newLimit
)
;
reorderStart
=
limit
=
newLimit
;
lastCC
=
0
;
}
void
copyReorderableSuffixTo
(
UnicodeString
&
s
)
const
{
s
.
setTo
(
ConstChar16Ptr
(
reorderStart
)
(
int32_t
)
(
limit
-
reorderStart
)
)
;
}
private
:
UBool
appendSupplementary
(
UChar32
c
uint8_t
cc
UErrorCode
&
errorCode
)
;
void
insert
(
UChar32
c
uint8_t
cc
)
;
static
void
writeCodePoint
(
char16_t
*
p
UChar32
c
)
{
if
(
c
<
=
0xffff
)
{
*
p
=
(
char16_t
)
c
;
}
else
{
p
[
0
]
=
U16_LEAD
(
c
)
;
p
[
1
]
=
U16_TRAIL
(
c
)
;
}
}
UBool
resize
(
int32_t
appendLength
UErrorCode
&
errorCode
)
;
const
Normalizer2Impl
&
impl
;
UnicodeString
&
str
;
char16_t
*
start
*
reorderStart
*
limit
;
int32_t
remainingCapacity
;
uint8_t
lastCC
;
void
setIterator
(
)
{
codePointStart
=
limit
;
}
void
skipPrevious
(
)
;
uint8_t
previousCC
(
)
;
char16_t
*
codePointStart
*
codePointLimit
;
}
;
class
U_COMMON_API
Normalizer2Impl
:
public
UObject
{
public
:
Normalizer2Impl
(
)
:
normTrie
(
NULL
)
fCanonIterData
(
NULL
)
{
}
virtual
~
Normalizer2Impl
(
)
;
void
init
(
const
int32_t
*
inIndexes
const
UCPTrie
*
inTrie
const
uint16_t
*
inExtraData
const
uint8_t
*
inSmallFCD
)
;
void
addLcccChars
(
UnicodeSet
&
set
)
const
;
void
addPropertyStarts
(
const
USetAdder
*
sa
UErrorCode
&
errorCode
)
const
;
void
addCanonIterPropertyStarts
(
const
USetAdder
*
sa
UErrorCode
&
errorCode
)
const
;
UBool
ensureCanonIterData
(
UErrorCode
&
errorCode
)
const
;
uint16_t
getNorm16
(
UChar32
c
)
const
{
return
U_IS_LEAD
(
c
)
?
static_cast
<
uint16_t
>
(
INERT
)
:
UCPTRIE_FAST_GET
(
normTrie
UCPTRIE_16
c
)
;
}
uint16_t
getRawNorm16
(
UChar32
c
)
const
{
return
UCPTRIE_FAST_GET
(
normTrie
UCPTRIE_16
c
)
;
}
UNormalizationCheckResult
getCompQuickCheck
(
uint16_t
norm16
)
const
{
if
(
norm16
<
minNoNo
|
|
MIN_YES_YES_WITH_CC
<
=
norm16
)
{
return
UNORM_YES
;
}
else
if
(
minMaybeYes
<
=
norm16
)
{
return
UNORM_MAYBE
;
}
else
{
return
UNORM_NO
;
}
}
UBool
isAlgorithmicNoNo
(
uint16_t
norm16
)
const
{
return
limitNoNo
<
=
norm16
&
&
norm16
<
minMaybeYes
;
}
UBool
isCompNo
(
uint16_t
norm16
)
const
{
return
minNoNo
<
=
norm16
&
&
norm16
<
minMaybeYes
;
}
UBool
isDecompYes
(
uint16_t
norm16
)
const
{
return
norm16
<
minYesNo
|
|
minMaybeYes
<
=
norm16
;
}
uint8_t
getCC
(
uint16_t
norm16
)
const
{
if
(
norm16
>
=
MIN_NORMAL_MAYBE_YES
)
{
return
getCCFromNormalYesOrMaybe
(
norm16
)
;
}
if
(
norm16
<
minNoNo
|
|
limitNoNo
<
=
norm16
)
{
return
0
;
}
return
getCCFromNoNo
(
norm16
)
;
}
static
uint8_t
getCCFromNormalYesOrMaybe
(
uint16_t
norm16
)
{
return
(
uint8_t
)
(
norm16
>
>
OFFSET_SHIFT
)
;
}
static
uint8_t
getCCFromYesOrMaybe
(
uint16_t
norm16
)
{
return
norm16
>
=
MIN_NORMAL_MAYBE_YES
?
getCCFromNormalYesOrMaybe
(
norm16
)
:
0
;
}
uint8_t
getCCFromYesOrMaybeCP
(
UChar32
c
)
const
{
if
(
c
<
minCompNoMaybeCP
)
{
return
0
;
}
return
getCCFromYesOrMaybe
(
getNorm16
(
c
)
)
;
}
uint16_t
getFCD16
(
UChar32
c
)
const
{
if
(
c
<
minDecompNoCP
)
{
return
0
;
}
else
if
(
c
<
=
0xffff
)
{
if
(
!
singleLeadMightHaveNonZeroFCD16
(
c
)
)
{
return
0
;
}
}
return
getFCD16FromNormData
(
c
)
;
}
uint16_t
nextFCD16
(
const
char16_t
*
&
s
const
char16_t
*
limit
)
const
{
UChar32
c
=
*
s
+
+
;
if
(
c
<
minDecompNoCP
|
|
!
singleLeadMightHaveNonZeroFCD16
(
c
)
)
{
return
0
;
}
char16_t
c2
;
if
(
U16_IS_LEAD
(
c
)
&
&
s
!
=
limit
&
&
U16_IS_TRAIL
(
c2
=
*
s
)
)
{
c
=
U16_GET_SUPPLEMENTARY
(
c
c2
)
;
+
+
s
;
}
return
getFCD16FromNormData
(
c
)
;
}
uint16_t
previousFCD16
(
const
char16_t
*
start
const
char16_t
*
&
s
)
const
{
UChar32
c
=
*
-
-
s
;
if
(
c
<
minDecompNoCP
)
{
return
0
;
}
if
(
!
U16_IS_TRAIL
(
c
)
)
{
if
(
!
singleLeadMightHaveNonZeroFCD16
(
c
)
)
{
return
0
;
}
}
else
{
char16_t
c2
;
if
(
start
<
s
&
&
U16_IS_LEAD
(
c2
=
*
(
s
-
1
)
)
)
{
c
=
U16_GET_SUPPLEMENTARY
(
c2
c
)
;
-
-
s
;
}
}
return
getFCD16FromNormData
(
c
)
;
}
UBool
singleLeadMightHaveNonZeroFCD16
(
UChar32
lead
)
const
{
uint8_t
bits
=
smallFCD
[
lead
>
>
8
]
;
if
(
bits
=
=
0
)
{
return
false
;
}
return
(
UBool
)
(
(
bits
>
>
(
(
lead
>
>
5
)
&
7
)
)
&
1
)
;
}
uint16_t
getFCD16FromNormData
(
UChar32
c
)
const
;
const
char16_t
*
getDecomposition
(
UChar32
c
char16_t
buffer
[
4
]
int32_t
&
length
)
const
;
const
char16_t
*
getRawDecomposition
(
UChar32
c
char16_t
buffer
[
30
]
int32_t
&
length
)
const
;
UChar32
composePair
(
UChar32
a
UChar32
b
)
const
;
UBool
isCanonSegmentStarter
(
UChar32
c
)
const
;
UBool
getCanonStartSet
(
UChar32
c
UnicodeSet
&
set
)
const
;
enum
{
MIN_YES_YES_WITH_CC
=
0xfe02
JAMO_VT
=
0xfe00
MIN_NORMAL_MAYBE_YES
=
0xfc00
JAMO_L
=
2
INERT
=
1
HAS_COMP_BOUNDARY_AFTER
=
1
OFFSET_SHIFT
=
1
DELTA_TCCC_0
=
0
DELTA_TCCC_1
=
2
DELTA_TCCC_GT_1
=
4
DELTA_TCCC_MASK
=
6
DELTA_SHIFT
=
3
MAX_DELTA
=
0x40
}
;
enum
{
IX_NORM_TRIE_OFFSET
IX_EXTRA_DATA_OFFSET
IX_SMALL_FCD_OFFSET
IX_RESERVED3_OFFSET
IX_RESERVED4_OFFSET
IX_RESERVED5_OFFSET
IX_RESERVED6_OFFSET
IX_TOTAL_SIZE
IX_MIN_DECOMP_NO_CP
IX_MIN_COMP_NO_MAYBE_CP
IX_MIN_YES_NO
IX_MIN_NO_NO
IX_LIMIT_NO_NO
IX_MIN_MAYBE_YES
IX_MIN_YES_NO_MAPPINGS_ONLY
IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE
IX_MIN_NO_NO_COMP_NO_MAYBE_CC
IX_MIN_NO_NO_EMPTY
IX_MIN_LCCC_CP
IX_RESERVED19
IX_COUNT
}
;
enum
{
MAPPING_HAS_CCC_LCCC_WORD
=
0x80
MAPPING_HAS_RAW_MAPPING
=
0x40
MAPPING_LENGTH_MASK
=
0x1f
}
;
enum
{
COMP_1_LAST_TUPLE
=
0x8000
COMP_1_TRIPLE
=
1
COMP_1_TRAIL_LIMIT
=
0x3400
COMP_1_TRAIL_MASK
=
0x7ffe
COMP_1_TRAIL_SHIFT
=
9
COMP_2_TRAIL_SHIFT
=
6
COMP_2_TRAIL_MASK
=
0xffc0
}
;
UnicodeString
&
decompose
(
const
UnicodeString
&
src
UnicodeString
&
dest
UErrorCode
&
errorCode
)
const
;
void
decompose
(
const
char16_t
*
src
const
char16_t
*
limit
UnicodeString
&
dest
int32_t
destLengthEstimate
UErrorCode
&
errorCode
)
const
;
const
char16_t
*
decompose
(
const
char16_t
*
src
const
char16_t
*
limit
ReorderingBuffer
*
buffer
UErrorCode
&
errorCode
)
const
;
void
decomposeAndAppend
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
doDecompose
UnicodeString
&
safeMiddle
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
;
const
uint8_t
*
decomposeUTF8
(
uint32_t
options
const
uint8_t
*
src
const
uint8_t
*
limit
ByteSink
*
sink
Edits
*
edits
UErrorCode
&
errorCode
)
const
;
UBool
compose
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
onlyContiguous
UBool
doCompose
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
;
const
char16_t
*
composeQuickCheck
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
onlyContiguous
UNormalizationCheckResult
*
pQCResult
)
const
;
void
composeAndAppend
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
doCompose
UBool
onlyContiguous
UnicodeString
&
safeMiddle
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
;
UBool
composeUTF8
(
uint32_t
options
UBool
onlyContiguous
const
uint8_t
*
src
const
uint8_t
*
limit
ByteSink
*
sink
icu
:
:
Edits
*
edits
UErrorCode
&
errorCode
)
const
;
const
char16_t
*
makeFCD
(
const
char16_t
*
src
const
char16_t
*
limit
ReorderingBuffer
*
buffer
UErrorCode
&
errorCode
)
const
;
void
makeFCDAndAppend
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
doMakeFCD
UnicodeString
&
safeMiddle
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
;
UBool
hasDecompBoundaryBefore
(
UChar32
c
)
const
;
UBool
norm16HasDecompBoundaryBefore
(
uint16_t
norm16
)
const
;
UBool
hasDecompBoundaryAfter
(
UChar32
c
)
const
;
UBool
norm16HasDecompBoundaryAfter
(
uint16_t
norm16
)
const
;
UBool
isDecompInert
(
UChar32
c
)
const
{
return
isDecompYesAndZeroCC
(
getNorm16
(
c
)
)
;
}
UBool
hasCompBoundaryBefore
(
UChar32
c
)
const
{
return
c
<
minCompNoMaybeCP
|
|
norm16HasCompBoundaryBefore
(
getNorm16
(
c
)
)
;
}
UBool
hasCompBoundaryAfter
(
UChar32
c
UBool
onlyContiguous
)
const
{
return
norm16HasCompBoundaryAfter
(
getNorm16
(
c
)
onlyContiguous
)
;
}
UBool
isCompInert
(
UChar32
c
UBool
onlyContiguous
)
const
{
uint16_t
norm16
=
getNorm16
(
c
)
;
return
isCompYesAndZeroCC
(
norm16
)
&
&
(
norm16
&
HAS_COMP_BOUNDARY_AFTER
)
!
=
0
&
&
(
!
onlyContiguous
|
|
isInert
(
norm16
)
|
|
*
getMapping
(
norm16
)
<
=
0x1ff
)
;
}
UBool
hasFCDBoundaryBefore
(
UChar32
c
)
const
{
return
hasDecompBoundaryBefore
(
c
)
;
}
UBool
hasFCDBoundaryAfter
(
UChar32
c
)
const
{
return
hasDecompBoundaryAfter
(
c
)
;
}
UBool
isFCDInert
(
UChar32
c
)
const
{
return
getFCD16
(
c
)
<
=
1
;
}
private
:
friend
class
InitCanonIterData
;
friend
class
LcccContext
;
UBool
isMaybe
(
uint16_t
norm16
)
const
{
return
minMaybeYes
<
=
norm16
&
&
norm16
<
=
JAMO_VT
;
}
UBool
isMaybeOrNonZeroCC
(
uint16_t
norm16
)
const
{
return
norm16
>
=
minMaybeYes
;
}
static
UBool
isInert
(
uint16_t
norm16
)
{
return
norm16
=
=
INERT
;
}
static
UBool
isJamoL
(
uint16_t
norm16
)
{
return
norm16
=
=
JAMO_L
;
}
static
UBool
isJamoVT
(
uint16_t
norm16
)
{
return
norm16
=
=
JAMO_VT
;
}
uint16_t
hangulLVT
(
)
const
{
return
minYesNoMappingsOnly
|
HAS_COMP_BOUNDARY_AFTER
;
}
UBool
isHangulLV
(
uint16_t
norm16
)
const
{
return
norm16
=
=
minYesNo
;
}
UBool
isHangulLVT
(
uint16_t
norm16
)
const
{
return
norm16
=
=
hangulLVT
(
)
;
}
UBool
isCompYesAndZeroCC
(
uint16_t
norm16
)
const
{
return
norm16
<
minNoNo
;
}
UBool
isDecompYesAndZeroCC
(
uint16_t
norm16
)
const
{
return
norm16
<
minYesNo
|
|
norm16
=
=
JAMO_VT
|
|
(
minMaybeYes
<
=
norm16
&
&
norm16
<
=
MIN_NORMAL_MAYBE_YES
)
;
}
UBool
isMostDecompYesAndZeroCC
(
uint16_t
norm16
)
const
{
return
norm16
<
minYesNo
|
|
norm16
=
=
MIN_NORMAL_MAYBE_YES
|
|
norm16
=
=
JAMO_VT
;
}
UBool
isDecompNoAlgorithmic
(
uint16_t
norm16
)
const
{
return
norm16
>
=
limitNoNo
;
}
uint8_t
getCCFromNoNo
(
uint16_t
norm16
)
const
{
const
uint16_t
*
mapping
=
getMapping
(
norm16
)
;
if
(
*
mapping
&
MAPPING_HAS_CCC_LCCC_WORD
)
{
return
(
uint8_t
)
*
(
mapping
-
1
)
;
}
else
{
return
0
;
}
}
uint8_t
getTrailCCFromCompYesAndZeroCC
(
uint16_t
norm16
)
const
{
if
(
norm16
<
=
minYesNo
)
{
return
0
;
}
else
{
return
(
uint8_t
)
(
*
getMapping
(
norm16
)
>
>
8
)
;
}
}
uint8_t
getPreviousTrailCC
(
const
char16_t
*
start
const
char16_t
*
p
)
const
;
uint8_t
getPreviousTrailCC
(
const
uint8_t
*
start
const
uint8_t
*
p
)
const
;
UChar32
mapAlgorithmic
(
UChar32
c
uint16_t
norm16
)
const
{
return
c
+
(
norm16
>
>
DELTA_SHIFT
)
-
centerNoNoDelta
;
}
UChar32
getAlgorithmicDelta
(
uint16_t
norm16
)
const
{
return
(
norm16
>
>
DELTA_SHIFT
)
-
centerNoNoDelta
;
}
const
uint16_t
*
getMapping
(
uint16_t
norm16
)
const
{
return
extraData
+
(
norm16
>
>
OFFSET_SHIFT
)
;
}
const
uint16_t
*
getCompositionsListForDecompYes
(
uint16_t
norm16
)
const
{
if
(
norm16
<
JAMO_L
|
|
MIN_NORMAL_MAYBE_YES
<
=
norm16
)
{
return
NULL
;
}
else
if
(
norm16
<
minMaybeYes
)
{
return
getMapping
(
norm16
)
;
}
else
{
return
maybeYesCompositions
+
norm16
-
minMaybeYes
;
}
}
const
uint16_t
*
getCompositionsListForComposite
(
uint16_t
norm16
)
const
{
const
uint16_t
*
list
=
getMapping
(
norm16
)
;
return
list
+
1
+
(
*
list
&
MAPPING_LENGTH_MASK
)
;
}
const
uint16_t
*
getCompositionsListForMaybe
(
uint16_t
norm16
)
const
{
return
maybeYesCompositions
+
(
(
norm16
-
minMaybeYes
)
>
>
OFFSET_SHIFT
)
;
}
const
uint16_t
*
getCompositionsList
(
uint16_t
norm16
)
const
{
return
isDecompYes
(
norm16
)
?
getCompositionsListForDecompYes
(
norm16
)
:
getCompositionsListForComposite
(
norm16
)
;
}
const
char16_t
*
copyLowPrefixFromNulTerminated
(
const
char16_t
*
src
UChar32
minNeedDataCP
ReorderingBuffer
*
buffer
UErrorCode
&
errorCode
)
const
;
enum
StopAt
{
STOP_AT_LIMIT
STOP_AT_DECOMP_BOUNDARY
STOP_AT_COMP_BOUNDARY
}
;
const
char16_t
*
decomposeShort
(
const
char16_t
*
src
const
char16_t
*
limit
UBool
stopAtCompBoundary
UBool
onlyContiguous
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
;
UBool
decompose
(
UChar32
c
uint16_t
norm16
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
;
const
uint8_t
*
decomposeShort
(
const
uint8_t
*
src
const
uint8_t
*
limit
StopAt
stopAt
UBool
onlyContiguous
ReorderingBuffer
&
buffer
UErrorCode
&
errorCode
)
const
;
static
int32_t
combine
(
const
uint16_t
*
list
UChar32
trail
)
;
void
addComposites
(
const
uint16_t
*
list
UnicodeSet
&
set
)
const
;
void
recompose
(
ReorderingBuffer
&
buffer
int32_t
recomposeStartIndex
UBool
onlyContiguous
)
const
;
UBool
hasCompBoundaryBefore
(
UChar32
c
uint16_t
norm16
)
const
{
return
c
<
minCompNoMaybeCP
|
|
norm16HasCompBoundaryBefore
(
norm16
)
;
}
UBool
norm16HasCompBoundaryBefore
(
uint16_t
norm16
)
const
{
return
norm16
<
minNoNoCompNoMaybeCC
|
|
isAlgorithmicNoNo
(
norm16
)
;
}
UBool
hasCompBoundaryBefore
(
const
char16_t
*
src
const
char16_t
*
limit
)
const
;
UBool
hasCompBoundaryBefore
(
const
uint8_t
*
src
const
uint8_t
*
limit
)
const
;
UBool
hasCompBoundaryAfter
(
const
char16_t
*
start
const
char16_t
*
p
UBool
onlyContiguous
)
const
;
UBool
hasCompBoundaryAfter
(
const
uint8_t
*
start
const
uint8_t
*
p
UBool
onlyContiguous
)
const
;
UBool
norm16HasCompBoundaryAfter
(
uint16_t
norm16
UBool
onlyContiguous
)
const
{
return
(
norm16
&
HAS_COMP_BOUNDARY_AFTER
)
!
=
0
&
&
(
!
onlyContiguous
|
|
isTrailCC01ForCompBoundaryAfter
(
norm16
)
)
;
}
UBool
isTrailCC01ForCompBoundaryAfter
(
uint16_t
norm16
)
const
{
return
isInert
(
norm16
)
|
|
(
isDecompNoAlgorithmic
(
norm16
)
?
(
norm16
&
DELTA_TCCC_MASK
)
<
=
DELTA_TCCC_1
:
*
getMapping
(
norm16
)
<
=
0x1ff
)
;
}
const
char16_t
*
findPreviousCompBoundary
(
const
char16_t
*
start
const
char16_t
*
p
UBool
onlyContiguous
)
const
;
const
char16_t
*
findNextCompBoundary
(
const
char16_t
*
p
const
char16_t
*
limit
UBool
onlyContiguous
)
const
;
const
char16_t
*
findPreviousFCDBoundary
(
const
char16_t
*
start
const
char16_t
*
p
)
const
;
const
char16_t
*
findNextFCDBoundary
(
const
char16_t
*
p
const
char16_t
*
limit
)
const
;
void
makeCanonIterDataFromNorm16
(
UChar32
start
UChar32
end
const
uint16_t
norm16
CanonIterData
&
newData
UErrorCode
&
errorCode
)
const
;
int32_t
getCanonValue
(
UChar32
c
)
const
;
const
UnicodeSet
&
getCanonStartSet
(
int32_t
n
)
const
;
char16_t
minDecompNoCP
;
char16_t
minCompNoMaybeCP
;
char16_t
minLcccCP
;
uint16_t
minYesNo
;
uint16_t
minYesNoMappingsOnly
;
uint16_t
minNoNo
;
uint16_t
minNoNoCompBoundaryBefore
;
uint16_t
minNoNoCompNoMaybeCC
;
uint16_t
minNoNoEmpty
;
uint16_t
limitNoNo
;
uint16_t
centerNoNoDelta
;
uint16_t
minMaybeYes
;
const
UCPTrie
*
normTrie
;
const
uint16_t
*
maybeYesCompositions
;
const
uint16_t
*
extraData
;
const
uint8_t
*
smallFCD
;
UInitOnce
fCanonIterDataInitOnce
{
}
;
CanonIterData
*
fCanonIterData
;
}
;
#
define
CANON_NOT_SEGMENT_STARTER
0x80000000
#
define
CANON_HAS_COMPOSITIONS
0x40000000
#
define
CANON_HAS_SET
0x200000
#
define
CANON_VALUE_MASK
0x1fffff
class
U_COMMON_API
Normalizer2Factory
{
public
:
static
const
Normalizer2
*
getFCDInstance
(
UErrorCode
&
errorCode
)
;
static
const
Normalizer2
*
getFCCInstance
(
UErrorCode
&
errorCode
)
;
static
const
Normalizer2
*
getNoopInstance
(
UErrorCode
&
errorCode
)
;
static
const
Normalizer2
*
getInstance
(
UNormalizationMode
mode
UErrorCode
&
errorCode
)
;
static
const
Normalizer2Impl
*
getNFCImpl
(
UErrorCode
&
errorCode
)
;
static
const
Normalizer2Impl
*
getNFKCImpl
(
UErrorCode
&
errorCode
)
;
static
const
Normalizer2Impl
*
getNFKC_CFImpl
(
UErrorCode
&
errorCode
)
;
static
const
Normalizer2Impl
*
getImpl
(
const
Normalizer2
*
norm2
)
;
private
:
Normalizer2Factory
(
)
=
delete
;
}
;
U_NAMESPACE_END
U_CAPI
int32_t
U_EXPORT2
unorm2_swap
(
const
UDataSwapper
*
ds
const
void
*
inData
int32_t
length
void
*
outData
UErrorCode
*
pErrorCode
)
;
U_CFUNC
UNormalizationCheckResult
unorm_getQuickCheck
(
UChar32
c
UNormalizationMode
mode
)
;
U_CFUNC
uint16_t
unorm_getFCD16
(
UChar32
c
)
;
#
endif
#
endif
