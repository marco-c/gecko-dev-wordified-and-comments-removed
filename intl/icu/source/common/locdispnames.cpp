#
include
<
string_view
>
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
brkiter
.
h
"
#
include
"
unicode
/
locid
.
h
"
#
include
"
unicode
/
uenum
.
h
"
#
include
"
unicode
/
uloc
.
h
"
#
include
"
unicode
/
ures
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
charstr
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
cstring
.
h
"
#
include
"
putilimp
.
h
"
#
include
"
ulocimp
.
h
"
#
include
"
uresimp
.
h
"
#
include
"
ureslocs
.
h
"
#
include
"
ustr_imp
.
h
"
U_NAMESPACE_BEGIN
UnicodeString
&
Locale
:
:
getDisplayLanguage
(
UnicodeString
&
dispLang
)
const
{
return
this
-
>
getDisplayLanguage
(
getDefault
(
)
dispLang
)
;
}
UnicodeString
&
Locale
:
:
getDisplayLanguage
(
const
Locale
&
displayLocale
UnicodeString
&
result
)
const
{
char16_t
*
buffer
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int32_t
length
;
buffer
=
result
.
getBuffer
(
ULOC_FULLNAME_CAPACITY
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
length
=
uloc_getDisplayLanguage
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
if
(
errorCode
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
buffer
=
result
.
getBuffer
(
length
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
errorCode
=
U_ZERO_ERROR
;
length
=
uloc_getDisplayLanguage
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
}
return
result
;
}
UnicodeString
&
Locale
:
:
getDisplayScript
(
UnicodeString
&
dispScript
)
const
{
return
this
-
>
getDisplayScript
(
getDefault
(
)
dispScript
)
;
}
UnicodeString
&
Locale
:
:
getDisplayScript
(
const
Locale
&
displayLocale
UnicodeString
&
result
)
const
{
char16_t
*
buffer
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int32_t
length
;
buffer
=
result
.
getBuffer
(
ULOC_FULLNAME_CAPACITY
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
length
=
uloc_getDisplayScript
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
if
(
errorCode
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
buffer
=
result
.
getBuffer
(
length
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
errorCode
=
U_ZERO_ERROR
;
length
=
uloc_getDisplayScript
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
}
return
result
;
}
UnicodeString
&
Locale
:
:
getDisplayCountry
(
UnicodeString
&
dispCntry
)
const
{
return
this
-
>
getDisplayCountry
(
getDefault
(
)
dispCntry
)
;
}
UnicodeString
&
Locale
:
:
getDisplayCountry
(
const
Locale
&
displayLocale
UnicodeString
&
result
)
const
{
char16_t
*
buffer
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int32_t
length
;
buffer
=
result
.
getBuffer
(
ULOC_FULLNAME_CAPACITY
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
length
=
uloc_getDisplayCountry
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
if
(
errorCode
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
buffer
=
result
.
getBuffer
(
length
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
errorCode
=
U_ZERO_ERROR
;
length
=
uloc_getDisplayCountry
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
}
return
result
;
}
UnicodeString
&
Locale
:
:
getDisplayVariant
(
UnicodeString
&
dispVar
)
const
{
return
this
-
>
getDisplayVariant
(
getDefault
(
)
dispVar
)
;
}
UnicodeString
&
Locale
:
:
getDisplayVariant
(
const
Locale
&
displayLocale
UnicodeString
&
result
)
const
{
char16_t
*
buffer
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int32_t
length
;
buffer
=
result
.
getBuffer
(
ULOC_FULLNAME_CAPACITY
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
length
=
uloc_getDisplayVariant
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
if
(
errorCode
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
buffer
=
result
.
getBuffer
(
length
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
errorCode
=
U_ZERO_ERROR
;
length
=
uloc_getDisplayVariant
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
}
return
result
;
}
UnicodeString
&
Locale
:
:
getDisplayName
(
UnicodeString
&
name
)
const
{
return
this
-
>
getDisplayName
(
getDefault
(
)
name
)
;
}
UnicodeString
&
Locale
:
:
getDisplayName
(
const
Locale
&
displayLocale
UnicodeString
&
result
)
const
{
char16_t
*
buffer
;
UErrorCode
errorCode
=
U_ZERO_ERROR
;
int32_t
length
;
buffer
=
result
.
getBuffer
(
ULOC_FULLNAME_CAPACITY
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
length
=
uloc_getDisplayName
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
if
(
errorCode
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
buffer
=
result
.
getBuffer
(
length
)
;
if
(
buffer
=
=
nullptr
)
{
result
.
truncate
(
0
)
;
return
result
;
}
errorCode
=
U_ZERO_ERROR
;
length
=
uloc_getDisplayName
(
getName
(
)
displayLocale
.
getName
(
)
buffer
result
.
getCapacity
(
)
&
errorCode
)
;
result
.
releaseBuffer
(
U_SUCCESS
(
errorCode
)
?
length
:
0
)
;
}
return
result
;
}
#
if
!
UCONFIG_NO_BREAK_ITERATION
UnicodeString
&
U_EXPORT2
BreakIterator
:
:
getDisplayName
(
const
Locale
&
objectLocale
UnicodeString
&
name
)
{
return
objectLocale
.
getDisplayName
(
name
)
;
}
UnicodeString
&
U_EXPORT2
BreakIterator
:
:
getDisplayName
(
const
Locale
&
objectLocale
const
Locale
&
displayLocale
UnicodeString
&
name
)
{
return
objectLocale
.
getDisplayName
(
displayLocale
name
)
;
}
#
endif
U_NAMESPACE_END
U_NAMESPACE_USE
namespace
{
constexpr
char
_kLanguages
[
]
=
"
Languages
"
;
constexpr
char
_kScripts
[
]
=
"
Scripts
"
;
constexpr
char
_kScriptsStandAlone
[
]
=
"
Scripts
%
stand
-
alone
"
;
constexpr
char
_kCountries
[
]
=
"
Countries
"
;
constexpr
char
_kVariants
[
]
=
"
Variants
"
;
constexpr
char
_kKeys
[
]
=
"
Keys
"
;
constexpr
char
_kTypes
[
]
=
"
Types
"
;
constexpr
char
_kCurrency
[
]
=
"
currency
"
;
constexpr
char
_kCurrencies
[
]
=
"
Currencies
"
;
constexpr
char
_kLocaleDisplayPattern
[
]
=
"
localeDisplayPattern
"
;
constexpr
char
_kPattern
[
]
=
"
pattern
"
;
constexpr
char
_kSeparator
[
]
=
"
separator
"
;
int32_t
_getStringOrCopyKey
(
const
char
*
path
const
char
*
locale
const
char
*
tableKey
const
char
*
subTableKey
const
char
*
itemKey
const
char
*
substitute
char16_t
*
dest
int32_t
destCapacity
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
0
;
}
const
char16_t
*
s
=
nullptr
;
int32_t
length
=
0
;
if
(
itemKey
=
=
nullptr
)
{
icu
:
:
LocalUResourceBundlePointer
rb
(
ures_open
(
path
locale
&
errorCode
)
)
;
if
(
U_SUCCESS
(
errorCode
)
)
{
s
=
ures_getStringByKey
(
rb
.
getAlias
(
)
tableKey
&
length
&
errorCode
)
;
}
}
else
{
bool
isLanguageCode
=
(
uprv_strncmp
(
tableKey
_kLanguages
9
)
=
=
0
)
;
if
(
isLanguageCode
&
&
uprv_strtol
(
itemKey
nullptr
10
)
)
{
errorCode
=
U_MISSING_RESOURCE_ERROR
;
}
else
{
s
=
uloc_getTableStringWithFallback
(
path
locale
tableKey
subTableKey
itemKey
&
length
&
errorCode
)
;
if
(
U_FAILURE
(
errorCode
)
&
&
isLanguageCode
&
&
itemKey
!
=
nullptr
)
{
errorCode
=
U_ZERO_ERROR
;
Locale
canonKey
=
Locale
:
:
createCanonical
(
itemKey
)
;
s
=
uloc_getTableStringWithFallback
(
path
locale
tableKey
subTableKey
canonKey
.
getName
(
)
&
length
&
errorCode
)
;
}
}
}
if
(
U_SUCCESS
(
errorCode
)
)
{
int32_t
copyLength
=
uprv_min
(
length
destCapacity
)
;
if
(
copyLength
>
0
&
&
s
!
=
nullptr
)
{
u_memcpy
(
dest
s
copyLength
)
;
}
}
else
{
length
=
static_cast
<
int32_t
>
(
uprv_strlen
(
substitute
)
)
;
u_charsToUChars
(
substitute
dest
uprv_min
(
length
destCapacity
)
)
;
errorCode
=
U_USING_DEFAULT_WARNING
;
}
return
u_terminateUChars
(
dest
destCapacity
length
&
errorCode
)
;
}
using
UDisplayNameGetter
=
icu
:
:
CharString
(
std
:
:
string_view
UErrorCode
&
)
;
int32_t
_getDisplayNameForComponent
(
const
char
*
locale
const
char
*
displayLocale
char16_t
*
dest
int32_t
destCapacity
UDisplayNameGetter
*
getter
const
char
*
tag
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
0
;
}
UErrorCode
localStatus
;
const
char
*
root
=
nullptr
;
if
(
destCapacity
<
0
|
|
(
destCapacity
>
0
&
&
dest
=
=
nullptr
)
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
if
(
locale
=
=
nullptr
)
{
locale
=
uloc_getDefault
(
)
;
}
localStatus
=
U_ZERO_ERROR
;
icu
:
:
CharString
localeBuffer
=
(
*
getter
)
(
locale
localStatus
)
;
if
(
U_FAILURE
(
localStatus
)
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
if
(
localeBuffer
.
isEmpty
(
)
)
{
if
(
getter
=
=
ulocimp_getLanguage
)
{
localeBuffer
.
append
(
"
und
"
errorCode
)
;
}
else
{
return
u_terminateUChars
(
dest
destCapacity
0
&
errorCode
)
;
}
}
root
=
tag
=
=
_kCountries
?
U_ICUDATA_REGION
:
U_ICUDATA_LANG
;
return
_getStringOrCopyKey
(
root
displayLocale
tag
nullptr
localeBuffer
.
data
(
)
localeBuffer
.
data
(
)
dest
destCapacity
errorCode
)
;
}
}
U_CAPI
int32_t
U_EXPORT2
uloc_getDisplayLanguage
(
const
char
*
locale
const
char
*
displayLocale
char16_t
*
dest
int32_t
destCapacity
UErrorCode
*
pErrorCode
)
{
return
_getDisplayNameForComponent
(
locale
displayLocale
dest
destCapacity
ulocimp_getLanguage
_kLanguages
*
pErrorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
uloc_getDisplayScript
(
const
char
*
locale
const
char
*
displayLocale
char16_t
*
dest
int32_t
destCapacity
UErrorCode
*
pErrorCode
)
{
if
(
U_FAILURE
(
*
pErrorCode
)
)
{
return
0
;
}
UErrorCode
err
=
U_ZERO_ERROR
;
int32_t
res
=
_getDisplayNameForComponent
(
locale
displayLocale
dest
destCapacity
ulocimp_getScript
_kScriptsStandAlone
err
)
;
if
(
destCapacity
=
=
0
&
&
err
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
int32_t
fallback_res
=
_getDisplayNameForComponent
(
locale
displayLocale
dest
destCapacity
ulocimp_getScript
_kScripts
*
pErrorCode
)
;
return
(
fallback_res
>
res
)
?
fallback_res
:
res
;
}
if
(
err
=
=
U_USING_DEFAULT_WARNING
)
{
return
_getDisplayNameForComponent
(
locale
displayLocale
dest
destCapacity
ulocimp_getScript
_kScripts
*
pErrorCode
)
;
}
else
{
*
pErrorCode
=
err
;
return
res
;
}
}
static
int32_t
uloc_getDisplayScriptInContext
(
const
char
*
locale
const
char
*
displayLocale
char16_t
*
dest
int32_t
destCapacity
UErrorCode
*
pErrorCode
)
{
return
_getDisplayNameForComponent
(
locale
displayLocale
dest
destCapacity
ulocimp_getScript
_kScripts
*
pErrorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
uloc_getDisplayCountry
(
const
char
*
locale
const
char
*
displayLocale
char16_t
*
dest
int32_t
destCapacity
UErrorCode
*
pErrorCode
)
{
return
_getDisplayNameForComponent
(
locale
displayLocale
dest
destCapacity
ulocimp_getRegion
_kCountries
*
pErrorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
uloc_getDisplayVariant
(
const
char
*
locale
const
char
*
displayLocale
char16_t
*
dest
int32_t
destCapacity
UErrorCode
*
pErrorCode
)
{
return
_getDisplayNameForComponent
(
locale
displayLocale
dest
destCapacity
ulocimp_getVariant
_kVariants
*
pErrorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
uloc_getDisplayName
(
const
char
*
locale
const
char
*
displayLocale
char16_t
*
dest
int32_t
destCapacity
UErrorCode
*
pErrorCode
)
{
static
const
char16_t
defaultSeparator
[
9
]
=
{
0x007b
0x0030
0x007d
0x002c
0x0020
0x007b
0x0031
0x007d
0x0000
}
;
static
const
char16_t
sub0
[
4
]
=
{
0x007b
0x0030
0x007d
0x0000
}
;
static
const
char16_t
sub1
[
4
]
=
{
0x007b
0x0031
0x007d
0x0000
}
;
static
const
int32_t
subLen
=
3
;
static
const
char16_t
defaultPattern
[
10
]
=
{
0x007b
0x0030
0x007d
0x0020
0x0028
0x007b
0x0031
0x007d
0x0029
0x0000
}
;
static
const
int32_t
defaultPatLen
=
9
;
static
const
int32_t
defaultSub0Pos
=
0
;
static
const
int32_t
defaultSub1Pos
=
5
;
int32_t
length
;
const
char16_t
*
separator
;
int32_t
sepLen
=
0
;
const
char16_t
*
pattern
;
int32_t
patLen
=
0
;
int32_t
sub0Pos
sub1Pos
;
char16_t
formatOpenParen
=
0x0028
;
char16_t
formatReplaceOpenParen
=
0x005B
;
char16_t
formatCloseParen
=
0x0029
;
char16_t
formatReplaceCloseParen
=
0x005D
;
UBool
haveLang
=
true
;
UBool
haveRest
=
true
;
UBool
retry
=
false
;
int32_t
langi
=
0
;
if
(
pErrorCode
=
=
nullptr
|
|
U_FAILURE
(
*
pErrorCode
)
)
{
return
0
;
}
if
(
destCapacity
<
0
|
|
(
destCapacity
>
0
&
&
dest
=
=
nullptr
)
)
{
*
pErrorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
{
UErrorCode
status
=
U_ZERO_ERROR
;
icu
:
:
LocalUResourceBundlePointer
locbundle
(
ures_open
(
U_ICUDATA_LANG
displayLocale
&
status
)
)
;
icu
:
:
LocalUResourceBundlePointer
dspbundle
(
ures_getByKeyWithFallback
(
locbundle
.
getAlias
(
)
_kLocaleDisplayPattern
nullptr
&
status
)
)
;
separator
=
ures_getStringByKeyWithFallback
(
dspbundle
.
getAlias
(
)
_kSeparator
&
sepLen
&
status
)
;
pattern
=
ures_getStringByKeyWithFallback
(
dspbundle
.
getAlias
(
)
_kPattern
&
patLen
&
status
)
;
}
if
(
sepLen
=
=
0
)
{
separator
=
defaultSeparator
;
}
{
char16_t
*
p0
=
u_strstr
(
separator
sub0
)
;
char16_t
*
p1
=
u_strstr
(
separator
sub1
)
;
if
(
p0
=
=
nullptr
|
|
p1
=
=
nullptr
|
|
p1
<
p0
)
{
*
pErrorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
separator
=
(
const
char16_t
*
)
p0
+
subLen
;
sepLen
=
static_cast
<
int32_t
>
(
p1
-
separator
)
;
}
if
(
patLen
=
=
0
|
|
(
patLen
=
=
defaultPatLen
&
&
!
u_strncmp
(
pattern
defaultPattern
patLen
)
)
)
{
pattern
=
defaultPattern
;
patLen
=
defaultPatLen
;
sub0Pos
=
defaultSub0Pos
;
sub1Pos
=
defaultSub1Pos
;
}
else
{
char16_t
*
p0
=
u_strstr
(
pattern
sub0
)
;
char16_t
*
p1
=
u_strstr
(
pattern
sub1
)
;
if
(
p0
=
=
nullptr
|
|
p1
=
=
nullptr
)
{
*
pErrorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
sub0Pos
=
static_cast
<
int32_t
>
(
p0
-
pattern
)
;
sub1Pos
=
static_cast
<
int32_t
>
(
p1
-
pattern
)
;
if
(
sub1Pos
<
sub0Pos
)
{
int32_t
t
=
sub0Pos
;
sub0Pos
=
sub1Pos
;
sub1Pos
=
t
;
langi
=
1
;
}
if
(
u_strchr
(
pattern
0xFF08
)
!
=
nullptr
)
{
formatOpenParen
=
0xFF08
;
formatReplaceOpenParen
=
0xFF3B
;
formatCloseParen
=
0xFF09
;
formatReplaceCloseParen
=
0xFF3D
;
}
}
do
{
char16_t
*
p
=
dest
;
int32_t
patPos
=
0
;
int32_t
langLen
=
0
;
int32_t
langPos
=
0
;
int32_t
restLen
=
0
;
int32_t
restPos
=
0
;
icu
:
:
LocalUEnumerationPointer
kenum
;
if
(
sub0Pos
)
{
if
(
destCapacity
>
=
sub0Pos
)
{
while
(
patPos
<
sub0Pos
)
{
*
p
+
+
=
pattern
[
patPos
+
+
]
;
}
}
else
{
patPos
=
sub0Pos
;
}
length
=
sub0Pos
;
}
else
{
length
=
0
;
}
for
(
int32_t
subi
=
0
resti
=
0
;
subi
<
2
;
)
{
UBool
subdone
=
false
;
int32_t
cap
=
destCapacity
-
length
;
if
(
cap
<
=
0
)
{
cap
=
0
;
}
else
{
p
=
dest
+
length
;
}
if
(
subi
=
=
langi
)
{
if
(
haveLang
)
{
langPos
=
length
;
langLen
=
uloc_getDisplayLanguage
(
locale
displayLocale
p
cap
pErrorCode
)
;
length
+
=
langLen
;
haveLang
=
langLen
>
0
;
}
subdone
=
true
;
}
else
{
if
(
!
haveRest
)
{
subdone
=
true
;
}
else
{
int32_t
len
;
switch
(
resti
+
+
)
{
case
0
:
restPos
=
length
;
len
=
uloc_getDisplayScriptInContext
(
locale
displayLocale
p
cap
pErrorCode
)
;
break
;
case
1
:
len
=
uloc_getDisplayCountry
(
locale
displayLocale
p
cap
pErrorCode
)
;
break
;
case
2
:
len
=
uloc_getDisplayVariant
(
locale
displayLocale
p
cap
pErrorCode
)
;
break
;
case
3
:
kenum
.
adoptInstead
(
uloc_openKeywords
(
locale
pErrorCode
)
)
;
U_FALLTHROUGH
;
default
:
{
const
char
*
kw
=
uenum_next
(
kenum
.
getAlias
(
)
&
len
pErrorCode
)
;
if
(
kw
=
=
nullptr
)
{
len
=
0
;
subdone
=
true
;
}
else
{
len
=
uloc_getDisplayKeyword
(
kw
displayLocale
p
cap
pErrorCode
)
;
if
(
len
)
{
if
(
len
<
cap
)
{
p
[
len
]
=
0x3d
;
}
len
+
=
1
;
cap
-
=
len
;
if
(
cap
<
=
0
)
{
cap
=
0
;
}
else
{
p
+
=
len
;
}
}
if
(
*
pErrorCode
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
*
pErrorCode
=
U_ZERO_ERROR
;
}
int32_t
vlen
=
uloc_getDisplayKeywordValue
(
locale
kw
displayLocale
p
cap
pErrorCode
)
;
if
(
len
)
{
if
(
vlen
=
=
0
)
{
-
-
len
;
}
cap
=
destCapacity
-
length
;
if
(
cap
<
=
0
)
{
cap
=
0
;
}
else
{
p
=
dest
+
length
;
}
}
len
+
=
vlen
;
}
}
break
;
}
if
(
len
>
0
)
{
if
(
len
+
sepLen
<
=
cap
)
{
const
char16_t
*
plimit
=
p
+
len
;
for
(
;
p
<
plimit
;
p
+
+
)
{
if
(
*
p
=
=
formatOpenParen
)
{
*
p
=
formatReplaceOpenParen
;
}
else
if
(
*
p
=
=
formatCloseParen
)
{
*
p
=
formatReplaceCloseParen
;
}
}
for
(
int32_t
i
=
0
;
i
<
sepLen
;
+
+
i
)
{
*
p
+
+
=
separator
[
i
]
;
}
}
length
+
=
len
+
sepLen
;
}
else
if
(
subdone
)
{
if
(
length
!
=
restPos
)
{
length
-
=
sepLen
;
}
restLen
=
length
-
restPos
;
haveRest
=
restLen
>
0
;
}
}
}
if
(
*
pErrorCode
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
*
pErrorCode
=
U_ZERO_ERROR
;
}
if
(
subdone
)
{
if
(
haveLang
&
&
haveRest
)
{
int32_t
padLen
;
patPos
+
=
subLen
;
padLen
=
(
subi
=
=
0
?
sub1Pos
:
patLen
)
-
patPos
;
if
(
length
+
padLen
<
=
destCapacity
)
{
p
=
dest
+
length
;
for
(
int32_t
i
=
0
;
i
<
padLen
;
+
+
i
)
{
*
p
+
+
=
pattern
[
patPos
+
+
]
;
}
}
else
{
patPos
+
=
padLen
;
}
length
+
=
padLen
;
}
else
if
(
subi
=
=
0
)
{
sub0Pos
=
0
;
length
=
0
;
}
else
if
(
length
>
0
)
{
length
=
haveLang
?
langLen
:
restLen
;
if
(
dest
&
&
sub0Pos
!
=
0
)
{
if
(
sub0Pos
+
length
<
=
destCapacity
)
{
u_memmove
(
dest
dest
+
(
haveLang
?
langPos
:
restPos
)
length
)
;
}
else
{
sub0Pos
=
0
;
retry
=
true
;
}
}
}
+
+
subi
;
}
}
}
while
(
retry
)
;
return
u_terminateUChars
(
dest
destCapacity
length
pErrorCode
)
;
}
U_CAPI
int32_t
U_EXPORT2
uloc_getDisplayKeyword
(
const
char
*
keyword
const
char
*
displayLocale
char16_t
*
dest
int32_t
destCapacity
UErrorCode
*
status
)
{
if
(
status
=
=
nullptr
|
|
U_FAILURE
(
*
status
)
)
{
return
0
;
}
if
(
destCapacity
<
0
|
|
(
destCapacity
>
0
&
&
dest
=
=
nullptr
)
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
return
_getStringOrCopyKey
(
U_ICUDATA_LANG
displayLocale
_kKeys
nullptr
keyword
keyword
dest
destCapacity
*
status
)
;
}
#
define
UCURRENCY_DISPLAY_NAME_INDEX
1
U_CAPI
int32_t
U_EXPORT2
uloc_getDisplayKeywordValue
(
const
char
*
locale
const
char
*
keyword
const
char
*
displayLocale
char16_t
*
dest
int32_t
destCapacity
UErrorCode
*
status
)
{
if
(
status
=
=
nullptr
|
|
U_FAILURE
(
*
status
)
)
{
return
0
;
}
if
(
destCapacity
<
0
|
|
(
destCapacity
>
0
&
&
dest
=
=
nullptr
)
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
0
;
}
CharString
keywordValue
;
if
(
keyword
!
=
nullptr
&
&
*
keyword
!
=
'
\
0
'
)
{
keywordValue
=
ulocimp_getKeywordValue
(
locale
keyword
*
status
)
;
}
if
(
uprv_stricmp
(
keyword
_kCurrency
)
=
=
0
)
{
int32_t
dispNameLen
=
0
;
const
char16_t
*
dispName
=
nullptr
;
icu
:
:
LocalUResourceBundlePointer
bundle
(
ures_open
(
U_ICUDATA_CURR
displayLocale
status
)
)
;
icu
:
:
LocalUResourceBundlePointer
currencies
(
ures_getByKey
(
bundle
.
getAlias
(
)
_kCurrencies
nullptr
status
)
)
;
icu
:
:
LocalUResourceBundlePointer
currency
(
ures_getByKeyWithFallback
(
currencies
.
getAlias
(
)
keywordValue
.
data
(
)
nullptr
status
)
)
;
dispName
=
ures_getStringByIndex
(
currency
.
getAlias
(
)
UCURRENCY_DISPLAY_NAME_INDEX
&
dispNameLen
status
)
;
if
(
U_FAILURE
(
*
status
)
)
{
if
(
*
status
=
=
U_MISSING_RESOURCE_ERROR
)
{
*
status
=
U_USING_DEFAULT_WARNING
;
}
else
{
return
0
;
}
}
if
(
dispName
!
=
nullptr
)
{
if
(
dispNameLen
<
=
destCapacity
)
{
u_memcpy
(
dest
dispName
dispNameLen
)
;
return
u_terminateUChars
(
dest
destCapacity
dispNameLen
status
)
;
}
else
{
*
status
=
U_BUFFER_OVERFLOW_ERROR
;
return
dispNameLen
;
}
}
else
{
if
(
keywordValue
.
length
(
)
<
=
destCapacity
)
{
u_charsToUChars
(
keywordValue
.
data
(
)
dest
keywordValue
.
length
(
)
)
;
return
u_terminateUChars
(
dest
destCapacity
keywordValue
.
length
(
)
status
)
;
}
else
{
*
status
=
U_BUFFER_OVERFLOW_ERROR
;
return
keywordValue
.
length
(
)
;
}
}
}
else
{
return
_getStringOrCopyKey
(
U_ICUDATA_LANG
displayLocale
_kTypes
keyword
keywordValue
.
data
(
)
keywordValue
.
data
(
)
dest
destCapacity
*
status
)
;
}
}
