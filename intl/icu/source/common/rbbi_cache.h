#
ifndef
RBBI_CACHE_H
#
define
RBBI_CACHE_H
#
include
"
unicode
/
utypes
.
h
"
#
if
!
UCONFIG_NO_BREAK_ITERATION
#
include
"
unicode
/
rbbi
.
h
"
#
include
"
unicode
/
uobject
.
h
"
#
include
"
uvectr32
.
h
"
U_NAMESPACE_BEGIN
class
RuleBasedBreakIterator
:
:
DictionaryCache
:
public
UMemory
{
public
:
DictionaryCache
(
RuleBasedBreakIterator
*
bi
UErrorCode
&
status
)
;
~
DictionaryCache
(
)
;
void
reset
(
)
;
UBool
following
(
int32_t
fromPos
int32_t
*
pos
int32_t
*
statusIndex
)
;
UBool
preceding
(
int32_t
fromPos
int32_t
*
pos
int32_t
*
statusIndex
)
;
void
populateDictionary
(
int32_t
startPos
int32_t
endPos
int32_t
firstRuleStatus
int32_t
otherRuleStatus
)
;
RuleBasedBreakIterator
*
fBI
;
UVector32
*
fBreaks
;
int32_t
fPositionInCache
;
int32_t
fStart
;
int32_t
fLimit
;
int32_t
fFirstRuleStatusIndex
;
int32_t
fOtherRuleStatusIndex
;
}
;
class
RuleBasedBreakIterator
:
:
BreakCache
:
public
UMemory
{
public
:
BreakCache
(
RuleBasedBreakIterator
*
bi
UErrorCode
&
status
)
;
virtual
~
BreakCache
(
)
;
void
reset
(
int32_t
pos
=
0
int32_t
ruleStatus
=
0
)
;
void
next
(
)
{
if
(
fBufIdx
=
=
fEndBufIdx
)
{
nextOL
(
)
;
}
else
{
fBufIdx
=
modChunkSize
(
fBufIdx
+
1
)
;
fTextIdx
=
fBI
-
>
fPosition
=
fBoundaries
[
fBufIdx
]
;
fBI
-
>
fRuleStatusIndex
=
fStatuses
[
fBufIdx
]
;
}
}
;
void
nextOL
(
)
;
void
previous
(
UErrorCode
&
status
)
;
void
following
(
int32_t
startPosition
UErrorCode
&
status
)
;
void
preceding
(
int32_t
startPosition
UErrorCode
&
status
)
;
int32_t
current
(
)
;
UBool
populateNear
(
int32_t
position
UErrorCode
&
status
)
;
UBool
populateFollowing
(
)
;
UBool
populatePreceding
(
UErrorCode
&
status
)
;
enum
UpdatePositionValues
{
RetainCachePosition
=
0
UpdateCachePosition
=
1
}
;
void
addFollowing
(
int32_t
position
int32_t
ruleStatusIdx
UpdatePositionValues
update
)
;
bool
addPreceding
(
int32_t
position
int32_t
ruleStatusIdx
UpdatePositionValues
update
)
;
UBool
seek
(
int32_t
startPosition
)
;
void
dumpCache
(
)
;
private
:
static
inline
int32_t
modChunkSize
(
int
index
)
{
return
index
&
(
CACHE_SIZE
-
1
)
;
}
;
static
constexpr
int32_t
CACHE_SIZE
=
128
;
static_assert
(
(
CACHE_SIZE
&
(
CACHE_SIZE
-
1
)
)
=
=
0
"
CACHE_SIZE
must
be
power
of
two
.
"
)
;
RuleBasedBreakIterator
*
fBI
;
int32_t
fStartBufIdx
;
int32_t
fEndBufIdx
;
int32_t
fTextIdx
;
int32_t
fBufIdx
;
int32_t
fBoundaries
[
CACHE_SIZE
]
;
uint16_t
fStatuses
[
CACHE_SIZE
]
;
UVector32
fSideBuffer
;
}
;
U_NAMESPACE_END
#
endif
#
endif
