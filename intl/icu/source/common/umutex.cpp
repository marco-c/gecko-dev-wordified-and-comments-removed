#
include
"
umutex
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
include
"
uassert
.
h
"
#
include
"
ucln_cmn
.
h
"
#
include
"
cmemory
.
h
"
U_NAMESPACE_BEGIN
#
if
defined
(
U_USER_MUTEX_CPP
)
#
error
U_USER_MUTEX_CPP
not
supported
#
endif
#
ifndef
__wasi__
namespace
{
std
:
:
mutex
*
initMutex
;
std
:
:
condition_variable
*
initCondition
;
UMutex
globalMutex
;
std
:
:
once_flag
initFlag
;
std
:
:
once_flag
*
pInitFlag
=
&
initFlag
;
}
#
endif
U_CDECL_BEGIN
static
UBool
U_CALLCONV
umtx_cleanup
(
)
{
#
ifndef
__wasi__
initMutex
-
>
~
mutex
(
)
;
initCondition
-
>
~
condition_variable
(
)
;
UMutex
:
:
cleanup
(
)
;
pInitFlag
-
>
~
once_flag
(
)
;
pInitFlag
=
new
(
&
initFlag
)
std
:
:
once_flag
(
)
;
#
endif
return
true
;
}
static
void
U_CALLCONV
umtx_init
(
)
{
#
ifndef
__wasi__
initMutex
=
STATIC_NEW
(
std
:
:
mutex
)
;
initCondition
=
STATIC_NEW
(
std
:
:
condition_variable
)
;
ucln_common_registerCleanup
(
UCLN_COMMON_MUTEX
umtx_cleanup
)
;
#
endif
}
U_CDECL_END
#
ifndef
__wasi__
std
:
:
mutex
*
UMutex
:
:
getMutex
(
)
{
std
:
:
mutex
*
retPtr
=
fMutex
.
load
(
std
:
:
memory_order_acquire
)
;
if
(
retPtr
=
=
nullptr
)
{
std
:
:
call_once
(
*
pInitFlag
umtx_init
)
;
std
:
:
lock_guard
<
std
:
:
mutex
>
guard
(
*
initMutex
)
;
retPtr
=
fMutex
.
load
(
std
:
:
memory_order_acquire
)
;
if
(
retPtr
=
=
nullptr
)
{
fMutex
=
new
(
fStorage
)
std
:
:
mutex
(
)
;
retPtr
=
fMutex
;
fListLink
=
gListHead
;
gListHead
=
this
;
}
}
U_ASSERT
(
retPtr
!
=
nullptr
)
;
return
retPtr
;
}
#
endif
UMutex
*
UMutex
:
:
gListHead
=
nullptr
;
void
UMutex
:
:
cleanup
(
)
{
UMutex
*
next
=
nullptr
;
for
(
UMutex
*
m
=
gListHead
;
m
!
=
nullptr
;
m
=
next
)
{
#
ifndef
__wasi__
(
*
m
-
>
fMutex
)
.
~
mutex
(
)
;
m
-
>
fMutex
=
nullptr
;
#
endif
next
=
m
-
>
fListLink
;
m
-
>
fListLink
=
nullptr
;
}
gListHead
=
nullptr
;
}
U_CAPI
void
U_EXPORT2
umtx_lock
(
UMutex
*
mutex
)
{
#
ifndef
__wasi__
if
(
mutex
=
=
nullptr
)
{
mutex
=
&
globalMutex
;
}
mutex
-
>
lock
(
)
;
#
endif
}
U_CAPI
void
U_EXPORT2
umtx_unlock
(
UMutex
*
mutex
)
{
#
ifndef
__wasi__
if
(
mutex
=
=
nullptr
)
{
mutex
=
&
globalMutex
;
}
mutex
-
>
unlock
(
)
;
#
endif
}
U_COMMON_API
UBool
U_EXPORT2
umtx_initImplPreInit
(
UInitOnce
&
uio
)
{
#
ifndef
__wasi__
std
:
:
call_once
(
*
pInitFlag
umtx_init
)
;
std
:
:
unique_lock
<
std
:
:
mutex
>
lock
(
*
initMutex
)
;
#
endif
if
(
umtx_loadAcquire
(
uio
.
fState
)
=
=
0
)
{
umtx_storeRelease
(
uio
.
fState
1
)
;
return
true
;
}
else
{
#
ifndef
__wasi__
while
(
umtx_loadAcquire
(
uio
.
fState
)
=
=
1
)
{
initCondition
-
>
wait
(
lock
)
;
}
U_ASSERT
(
uio
.
fState
=
=
2
)
;
#
endif
return
false
;
}
}
U_COMMON_API
void
U_EXPORT2
umtx_initImplPostInit
(
UInitOnce
&
uio
)
{
#
ifndef
__wasi__
{
std
:
:
unique_lock
<
std
:
:
mutex
>
lock
(
*
initMutex
)
;
umtx_storeRelease
(
uio
.
fState
2
)
;
}
initCondition
-
>
notify_all
(
)
;
#
endif
}
U_NAMESPACE_END
U_DEPRECATED
void
U_EXPORT2
u_setMutexFunctions
(
const
void
*
UMtxInitFn
*
UMtxFn
*
UMtxFn
*
UMtxFn
*
UErrorCode
*
status
)
{
if
(
U_SUCCESS
(
*
status
)
)
{
*
status
=
U_UNSUPPORTED_ERROR
;
}
}
U_DEPRECATED
void
U_EXPORT2
u_setAtomicIncDecFunctions
(
const
void
*
UMtxAtomicFn
*
UMtxAtomicFn
*
UErrorCode
*
status
)
{
if
(
U_SUCCESS
(
*
status
)
)
{
*
status
=
U_UNSUPPORTED_ERROR
;
}
}
