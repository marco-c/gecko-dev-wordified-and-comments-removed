#
include
"
unicode
/
bytestream
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
ures
.
h
"
#
include
"
unicode
/
localpointer
.
h
"
#
include
"
unicode
/
putil
.
h
"
#
include
"
unicode
/
uenum
.
h
"
#
include
"
unicode
/
uloc
.
h
"
#
include
"
ustr_imp
.
h
"
#
include
"
bytesinkutil
.
h
"
#
include
"
charstr
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
cstring
.
h
"
#
include
"
putilimp
.
h
"
#
include
"
uinvchar
.
h
"
#
include
"
ulocimp
.
h
"
#
include
"
uassert
.
h
"
typedef
struct
VariantListEntry
{
const
char
*
variant
;
struct
VariantListEntry
*
next
;
}
VariantListEntry
;
struct
AttributeListEntry
:
public
icu
:
:
UMemory
{
const
char
*
attribute
;
struct
AttributeListEntry
*
next
;
}
;
struct
ExtensionListEntry
:
public
icu
:
:
UMemory
{
const
char
*
key
;
const
char
*
value
;
struct
ExtensionListEntry
*
next
;
}
;
#
define
MAXEXTLANG
3
typedef
struct
ULanguageTag
{
char
*
buf
;
const
char
*
language
;
const
char
*
extlang
[
MAXEXTLANG
]
;
const
char
*
script
;
const
char
*
region
;
VariantListEntry
*
variants
;
ExtensionListEntry
*
extensions
;
const
char
*
privateuse
;
const
char
*
legacy
;
}
ULanguageTag
;
#
define
MINLEN
2
#
define
SEP
'
-
'
#
define
PRIVATEUSE
'
x
'
#
define
LDMLEXT
'
u
'
#
define
LOCALE_SEP
'
_
'
#
define
LOCALE_EXT_SEP
'
'
#
define
LOCALE_KEYWORD_SEP
'
;
'
#
define
LOCALE_KEY_TYPE_SEP
'
=
'
#
define
ISALPHA
(
c
)
uprv_isASCIILetter
(
c
)
#
define
ISNUMERIC
(
c
)
(
(
c
)
>
=
'
0
'
&
&
(
c
)
<
=
'
9
'
)
static
const
char
EMPTY
[
]
=
"
"
;
static
const
char
LANG_UND
[
]
=
"
und
"
;
static
const
char
PRIVATEUSE_KEY
[
]
=
"
x
"
;
static
const
char
_POSIX
[
]
=
"
_POSIX
"
;
static
const
char
POSIX_KEY
[
]
=
"
va
"
;
static
const
char
POSIX_VALUE
[
]
=
"
posix
"
;
static
const
char
LOCALE_ATTRIBUTE_KEY
[
]
=
"
attribute
"
;
static
const
char
PRIVUSE_VARIANT_PREFIX
[
]
=
"
lvariant
"
;
static
const
char
LOCALE_TYPE_YES
[
]
=
"
yes
"
;
#
define
LANG_UND_LEN
3
static
const
char
*
const
LEGACY
[
]
=
{
"
art
-
lojban
"
"
jbo
"
"
en
-
gb
-
oed
"
"
en
-
gb
-
oxendict
"
"
i
-
ami
"
"
ami
"
"
i
-
bnn
"
"
bnn
"
"
i
-
hak
"
"
hak
"
"
i
-
klingon
"
"
tlh
"
"
i
-
lux
"
"
lb
"
"
i
-
navajo
"
"
nv
"
"
i
-
pwn
"
"
pwn
"
"
i
-
tao
"
"
tao
"
"
i
-
tay
"
"
tay
"
"
i
-
tsu
"
"
tsu
"
"
no
-
bok
"
"
nb
"
"
no
-
nyn
"
"
nn
"
"
sgn
-
be
-
fr
"
"
sfb
"
"
sgn
-
be
-
nl
"
"
vgt
"
"
sgn
-
ch
-
de
"
"
sgg
"
"
zh
-
guoyu
"
"
cmn
"
"
zh
-
hakka
"
"
hak
"
"
zh
-
min
-
nan
"
"
nan
"
"
zh
-
xiang
"
"
hsn
"
"
i
-
default
"
"
en
-
x
-
i
-
default
"
"
i
-
enochian
"
"
und
-
x
-
i
-
enochian
"
"
i
-
mingo
"
"
see
-
x
-
i
-
mingo
"
"
zh
-
min
"
"
nan
-
x
-
zh
-
min
"
}
;
static
const
char
*
const
REDUNDANT
[
]
=
{
"
sgn
-
br
"
"
bzs
"
"
sgn
-
co
"
"
csn
"
"
sgn
-
de
"
"
gsg
"
"
sgn
-
dk
"
"
dsl
"
"
sgn
-
es
"
"
ssp
"
"
sgn
-
fr
"
"
fsl
"
"
sgn
-
gb
"
"
bfi
"
"
sgn
-
gr
"
"
gss
"
"
sgn
-
ie
"
"
isg
"
"
sgn
-
it
"
"
ise
"
"
sgn
-
jp
"
"
jsl
"
"
sgn
-
mx
"
"
mfs
"
"
sgn
-
ni
"
"
ncs
"
"
sgn
-
nl
"
"
dse
"
"
sgn
-
no
"
"
nsl
"
"
sgn
-
pt
"
"
psr
"
"
sgn
-
se
"
"
swl
"
"
sgn
-
us
"
"
ase
"
"
sgn
-
za
"
"
sfs
"
"
zh
-
cmn
"
"
cmn
"
"
zh
-
cmn
-
hans
"
"
cmn
-
hans
"
"
zh
-
cmn
-
hant
"
"
cmn
-
hant
"
"
zh
-
gan
"
"
gan
"
"
zh
-
wuu
"
"
wuu
"
"
zh
-
yue
"
"
yue
"
"
ja
-
latn
-
hepburn
-
heploc
"
"
ja
-
latn
-
alalc97
"
}
;
static
const
char
DEPRECATEDLANGS
[
]
[
4
]
=
{
"
in
"
"
id
"
"
iw
"
"
he
"
"
ji
"
"
yi
"
"
jw
"
"
jv
"
"
mo
"
"
ro
"
"
aam
"
"
aas
"
"
adp
"
"
dz
"
"
aue
"
"
ktz
"
"
ayx
"
"
nun
"
"
bgm
"
"
bcg
"
"
bjd
"
"
drl
"
"
ccq
"
"
rki
"
"
cjr
"
"
mom
"
"
cka
"
"
cmr
"
"
cmk
"
"
xch
"
"
coy
"
"
pij
"
"
cqu
"
"
quh
"
"
drh
"
"
khk
"
"
drw
"
"
prs
"
"
gav
"
"
dev
"
"
gfx
"
"
vaj
"
"
ggn
"
"
gvr
"
"
gti
"
"
nyc
"
"
guv
"
"
duz
"
"
hrr
"
"
jal
"
"
ibi
"
"
opa
"
"
ilw
"
"
gal
"
"
jeg
"
"
oyb
"
"
kgc
"
"
tdf
"
"
kgh
"
"
kml
"
"
koj
"
"
kwv
"
"
krm
"
"
bmf
"
"
ktr
"
"
dtp
"
"
kvs
"
"
gdj
"
"
kwq
"
"
yam
"
"
kxe
"
"
tvd
"
"
kzj
"
"
dtp
"
"
kzt
"
"
dtp
"
"
lii
"
"
raq
"
"
lmm
"
"
rmx
"
"
meg
"
"
cir
"
"
mst
"
"
mry
"
"
mwj
"
"
vaj
"
"
myt
"
"
mry
"
"
nad
"
"
xny
"
"
ncp
"
"
kdz
"
"
nnx
"
"
ngv
"
"
nts
"
"
pij
"
"
oun
"
"
vaj
"
"
pcr
"
"
adx
"
"
pmc
"
"
huw
"
"
pmu
"
"
phr
"
"
ppa
"
"
bfy
"
"
ppr
"
"
lcq
"
"
pry
"
"
prt
"
"
puz
"
"
pub
"
"
sca
"
"
hle
"
"
skk
"
"
oyb
"
"
tdu
"
"
dtp
"
"
thc
"
"
tpo
"
"
thx
"
"
oyb
"
"
tie
"
"
ras
"
"
tkk
"
"
twm
"
"
tlw
"
"
weo
"
"
tmp
"
"
tyj
"
"
tne
"
"
kak
"
"
tnf
"
"
prs
"
"
tsf
"
"
taj
"
"
uok
"
"
ema
"
"
xba
"
"
cax
"
"
xia
"
"
acn
"
"
xkh
"
"
waw
"
"
xsj
"
"
suj
"
"
ybd
"
"
rki
"
"
yma
"
"
lrr
"
"
ymt
"
"
mtm
"
"
yos
"
"
zom
"
"
yuu
"
"
yug
"
}
;
static
const
char
DEPRECATEDREGIONS
[
]
[
3
]
=
{
"
BU
"
"
MM
"
"
DD
"
"
DE
"
"
FX
"
"
FR
"
"
TP
"
"
TL
"
"
YD
"
"
YE
"
"
ZR
"
"
CD
"
}
;
static
ULanguageTag
*
ultag_parse
(
const
char
*
tag
int32_t
tagLen
int32_t
*
parsedLen
UErrorCode
*
status
)
;
static
void
ultag_close
(
ULanguageTag
*
langtag
)
;
static
const
char
*
ultag_getLanguage
(
const
ULanguageTag
*
langtag
)
;
#
if
0
static
const
char
*
ultag_getJDKLanguage
(
const
ULanguageTag
*
langtag
)
;
#
endif
static
const
char
*
ultag_getExtlang
(
const
ULanguageTag
*
langtag
int32_t
idx
)
;
static
int32_t
ultag_getExtlangSize
(
const
ULanguageTag
*
langtag
)
;
static
const
char
*
ultag_getScript
(
const
ULanguageTag
*
langtag
)
;
static
const
char
*
ultag_getRegion
(
const
ULanguageTag
*
langtag
)
;
static
const
char
*
ultag_getVariant
(
const
ULanguageTag
*
langtag
int32_t
idx
)
;
static
int32_t
ultag_getVariantsSize
(
const
ULanguageTag
*
langtag
)
;
static
const
char
*
ultag_getExtensionKey
(
const
ULanguageTag
*
langtag
int32_t
idx
)
;
static
const
char
*
ultag_getExtensionValue
(
const
ULanguageTag
*
langtag
int32_t
idx
)
;
static
int32_t
ultag_getExtensionsSize
(
const
ULanguageTag
*
langtag
)
;
static
const
char
*
ultag_getPrivateUse
(
const
ULanguageTag
*
langtag
)
;
#
if
0
static
const
char
*
ultag_getLegacy
(
const
ULanguageTag
*
langtag
)
;
#
endif
U_NAMESPACE_BEGIN
U_DEFINE_LOCAL_OPEN_POINTER
(
LocalULanguageTagPointer
ULanguageTag
ultag_close
)
;
U_NAMESPACE_END
static
UBool
_isAlphaString
(
const
char
*
s
int32_t
len
)
{
int32_t
i
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
ISALPHA
(
*
(
s
+
i
)
)
)
{
return
false
;
}
}
return
true
;
}
static
UBool
_isNumericString
(
const
char
*
s
int32_t
len
)
{
int32_t
i
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
ISNUMERIC
(
*
(
s
+
i
)
)
)
{
return
false
;
}
}
return
true
;
}
static
UBool
_isAlphaNumericString
(
const
char
*
s
int32_t
len
)
{
int32_t
i
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
ISALPHA
(
*
(
s
+
i
)
)
&
&
!
ISNUMERIC
(
*
(
s
+
i
)
)
)
{
return
false
;
}
}
return
true
;
}
static
UBool
_isAlphaNumericStringLimitedLength
(
const
char
*
s
int32_t
len
int32_t
min
int32_t
max
)
{
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
if
(
len
>
=
min
&
&
len
<
=
max
&
&
_isAlphaNumericString
(
s
len
)
)
{
return
true
;
}
return
false
;
}
U_CFUNC
UBool
ultag_isLanguageSubtag
(
const
char
*
s
int32_t
len
)
{
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
if
(
len
>
=
2
&
&
len
<
=
8
&
&
_isAlphaString
(
s
len
)
)
{
return
true
;
}
return
false
;
}
static
UBool
_isExtlangSubtag
(
const
char
*
s
int32_t
len
)
{
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
if
(
len
=
=
3
&
&
_isAlphaString
(
s
len
)
)
{
return
true
;
}
return
false
;
}
U_CFUNC
UBool
ultag_isScriptSubtag
(
const
char
*
s
int32_t
len
)
{
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
if
(
len
=
=
4
&
&
_isAlphaString
(
s
len
)
)
{
return
true
;
}
return
false
;
}
U_CFUNC
UBool
ultag_isRegionSubtag
(
const
char
*
s
int32_t
len
)
{
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
if
(
len
=
=
2
&
&
_isAlphaString
(
s
len
)
)
{
return
true
;
}
if
(
len
=
=
3
&
&
_isNumericString
(
s
len
)
)
{
return
true
;
}
return
false
;
}
static
UBool
_isVariantSubtag
(
const
char
*
s
int32_t
len
)
{
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
if
(
_isAlphaNumericStringLimitedLength
(
s
len
5
8
)
)
{
return
true
;
}
if
(
len
=
=
4
&
&
ISNUMERIC
(
*
s
)
&
&
_isAlphaNumericString
(
s
+
1
3
)
)
{
return
true
;
}
return
false
;
}
static
UBool
_isSepListOf
(
UBool
(
*
test
)
(
const
char
*
int32_t
)
const
char
*
s
int32_t
len
)
{
const
char
*
p
=
s
;
const
char
*
pSubtag
=
nullptr
;
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
while
(
(
p
-
s
)
<
len
)
{
if
(
*
p
=
=
SEP
)
{
if
(
pSubtag
=
=
nullptr
)
{
return
false
;
}
if
(
!
test
(
pSubtag
(
int32_t
)
(
p
-
pSubtag
)
)
)
{
return
false
;
}
pSubtag
=
nullptr
;
}
else
if
(
pSubtag
=
=
nullptr
)
{
pSubtag
=
p
;
}
p
+
+
;
}
if
(
pSubtag
=
=
nullptr
)
{
return
false
;
}
return
test
(
pSubtag
(
int32_t
)
(
p
-
pSubtag
)
)
;
}
U_CFUNC
UBool
ultag_isVariantSubtags
(
const
char
*
s
int32_t
len
)
{
return
_isSepListOf
(
&
_isVariantSubtag
s
len
)
;
}
static
UBool
_isPrivateuseVariantSubtag
(
const
char
*
s
int32_t
len
)
{
return
_isAlphaNumericStringLimitedLength
(
s
len
1
8
)
;
}
static
UBool
_isExtensionSingleton
(
const
char
*
s
int32_t
len
)
{
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
if
(
len
=
=
1
&
&
(
ISALPHA
(
*
s
)
|
|
ISNUMERIC
(
*
s
)
)
&
&
(
uprv_tolower
(
*
s
)
!
=
PRIVATEUSE
)
)
{
return
true
;
}
return
false
;
}
static
UBool
_isExtensionSubtag
(
const
char
*
s
int32_t
len
)
{
return
_isAlphaNumericStringLimitedLength
(
s
len
2
8
)
;
}
U_CFUNC
UBool
ultag_isExtensionSubtags
(
const
char
*
s
int32_t
len
)
{
return
_isSepListOf
(
&
_isExtensionSubtag
s
len
)
;
}
static
UBool
_isPrivateuseValueSubtag
(
const
char
*
s
int32_t
len
)
{
return
_isAlphaNumericStringLimitedLength
(
s
len
1
8
)
;
}
U_CFUNC
UBool
ultag_isPrivateuseValueSubtags
(
const
char
*
s
int32_t
len
)
{
return
_isSepListOf
(
&
_isPrivateuseValueSubtag
s
len
)
;
}
U_CFUNC
UBool
ultag_isUnicodeLocaleAttribute
(
const
char
*
s
int32_t
len
)
{
return
_isAlphaNumericStringLimitedLength
(
s
len
3
8
)
;
}
U_CFUNC
UBool
ultag_isUnicodeLocaleAttributes
(
const
char
*
s
int32_t
len
)
{
return
_isSepListOf
(
&
ultag_isUnicodeLocaleAttribute
s
len
)
;
}
U_CFUNC
UBool
ultag_isUnicodeLocaleKey
(
const
char
*
s
int32_t
len
)
{
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
if
(
len
=
=
2
&
&
(
ISALPHA
(
*
s
)
|
|
ISNUMERIC
(
*
s
)
)
&
&
ISALPHA
(
s
[
1
]
)
)
{
return
true
;
}
return
false
;
}
U_CFUNC
UBool
_isUnicodeLocaleTypeSubtag
(
const
char
*
s
int32_t
len
)
{
return
_isAlphaNumericStringLimitedLength
(
s
len
3
8
)
;
}
U_CFUNC
UBool
ultag_isUnicodeLocaleType
(
const
char
*
s
int32_t
len
)
{
return
_isSepListOf
(
&
_isUnicodeLocaleTypeSubtag
s
len
)
;
}
static
UBool
_isTKey
(
const
char
*
s
int32_t
len
)
{
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
if
(
len
=
=
2
&
&
ISALPHA
(
*
s
)
&
&
ISNUMERIC
(
*
(
s
+
1
)
)
)
{
return
true
;
}
return
false
;
}
U_CAPI
const
char
*
U_EXPORT2
ultag_getTKeyStart
(
const
char
*
localeID
)
{
const
char
*
result
=
localeID
;
const
char
*
sep
;
while
(
(
sep
=
uprv_strchr
(
result
SEP
)
)
!
=
nullptr
)
{
if
(
_isTKey
(
result
static_cast
<
int32_t
>
(
sep
-
result
)
)
)
{
return
result
;
}
result
=
+
+
sep
;
}
if
(
_isTKey
(
result
-
1
)
)
{
return
result
;
}
return
nullptr
;
}
static
UBool
_isTValue
(
const
char
*
s
int32_t
len
)
{
return
_isAlphaNumericStringLimitedLength
(
s
len
3
8
)
;
}
static
UBool
_isTransformedExtensionSubtag
(
int32_t
&
state
const
char
*
s
int32_t
len
)
{
const
int32_t
kStart
=
0
;
const
int32_t
kGotLanguage
=
1
;
const
int32_t
kGotScript
=
2
;
const
int32_t
kGotRegion
=
3
;
const
int32_t
kGotVariant
=
4
;
const
int32_t
kGotTKey
=
-
1
;
const
int32_t
kGotTValue
=
6
;
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
switch
(
state
)
{
case
kStart
:
if
(
ultag_isLanguageSubtag
(
s
len
)
&
&
len
!
=
4
)
{
state
=
kGotLanguage
;
return
true
;
}
if
(
_isTKey
(
s
len
)
)
{
state
=
kGotTKey
;
return
true
;
}
return
false
;
case
kGotLanguage
:
if
(
ultag_isScriptSubtag
(
s
len
)
)
{
state
=
kGotScript
;
return
true
;
}
U_FALLTHROUGH
;
case
kGotScript
:
if
(
ultag_isRegionSubtag
(
s
len
)
)
{
state
=
kGotRegion
;
return
true
;
}
U_FALLTHROUGH
;
case
kGotRegion
:
U_FALLTHROUGH
;
case
kGotVariant
:
if
(
_isVariantSubtag
(
s
len
)
)
{
state
=
kGotVariant
;
return
true
;
}
if
(
_isTKey
(
s
len
)
)
{
state
=
kGotTKey
;
return
true
;
}
return
false
;
case
kGotTKey
:
if
(
_isTValue
(
s
len
)
)
{
state
=
kGotTValue
;
return
true
;
}
return
false
;
case
kGotTValue
:
if
(
_isTKey
(
s
len
)
)
{
state
=
kGotTKey
;
return
true
;
}
if
(
_isTValue
(
s
len
)
)
{
return
true
;
}
return
false
;
}
return
false
;
}
static
UBool
_isUnicodeExtensionSubtag
(
int32_t
&
state
const
char
*
s
int32_t
len
)
{
const
int32_t
kStart
=
0
;
const
int32_t
kGotKey
=
1
;
const
int32_t
kGotType
=
2
;
switch
(
state
)
{
case
kStart
:
if
(
ultag_isUnicodeLocaleKey
(
s
len
)
)
{
state
=
kGotKey
;
return
true
;
}
if
(
ultag_isUnicodeLocaleAttribute
(
s
len
)
)
{
return
true
;
}
return
false
;
case
kGotKey
:
if
(
ultag_isUnicodeLocaleKey
(
s
len
)
)
{
return
true
;
}
if
(
_isUnicodeLocaleTypeSubtag
(
s
len
)
)
{
state
=
kGotType
;
return
true
;
}
return
false
;
case
kGotType
:
if
(
ultag_isUnicodeLocaleKey
(
s
len
)
)
{
state
=
kGotKey
;
return
true
;
}
if
(
_isUnicodeLocaleTypeSubtag
(
s
len
)
)
{
return
true
;
}
return
false
;
}
return
false
;
}
static
UBool
_isStatefulSepListOf
(
UBool
(
*
test
)
(
int32_t
&
const
char
*
int32_t
)
const
char
*
s
int32_t
len
)
{
int32_t
state
=
0
;
const
char
*
p
;
const
char
*
start
=
s
;
int32_t
subtagLen
=
0
;
if
(
len
<
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
s
)
;
}
for
(
p
=
s
;
len
>
0
;
p
+
+
len
-
-
)
{
if
(
*
p
=
=
SEP
)
{
if
(
!
test
(
state
start
subtagLen
)
)
{
return
false
;
}
subtagLen
=
0
;
start
=
p
+
1
;
}
else
{
subtagLen
+
+
;
}
}
if
(
test
(
state
start
subtagLen
)
&
&
state
>
=
0
)
{
return
true
;
}
return
false
;
}
U_CFUNC
UBool
ultag_isTransformedExtensionSubtags
(
const
char
*
s
int32_t
len
)
{
return
_isStatefulSepListOf
(
&
_isTransformedExtensionSubtag
s
len
)
;
}
U_CFUNC
UBool
ultag_isUnicodeExtensionSubtags
(
const
char
*
s
int32_t
len
)
{
return
_isStatefulSepListOf
(
&
_isUnicodeExtensionSubtag
s
len
)
;
}
static
UBool
_addVariantToList
(
VariantListEntry
*
*
first
VariantListEntry
*
var
)
{
UBool
bAdded
=
true
;
if
(
*
first
=
=
nullptr
)
{
var
-
>
next
=
nullptr
;
*
first
=
var
;
}
else
{
VariantListEntry
*
prev
*
cur
;
int32_t
cmp
;
prev
=
nullptr
;
cur
=
*
first
;
while
(
true
)
{
if
(
cur
=
=
nullptr
)
{
prev
-
>
next
=
var
;
var
-
>
next
=
nullptr
;
break
;
}
cmp
=
uprv_compareInvCharsAsAscii
(
var
-
>
variant
cur
-
>
variant
)
;
if
(
cmp
=
=
0
)
{
bAdded
=
false
;
break
;
}
prev
=
cur
;
cur
=
cur
-
>
next
;
}
}
return
bAdded
;
}
static
UBool
_addAttributeToList
(
AttributeListEntry
*
*
first
AttributeListEntry
*
attr
)
{
UBool
bAdded
=
true
;
if
(
*
first
=
=
nullptr
)
{
attr
-
>
next
=
nullptr
;
*
first
=
attr
;
}
else
{
AttributeListEntry
*
prev
*
cur
;
int32_t
cmp
;
prev
=
nullptr
;
cur
=
*
first
;
while
(
true
)
{
if
(
cur
=
=
nullptr
)
{
prev
-
>
next
=
attr
;
attr
-
>
next
=
nullptr
;
break
;
}
cmp
=
uprv_compareInvCharsAsAscii
(
attr
-
>
attribute
cur
-
>
attribute
)
;
if
(
cmp
<
0
)
{
if
(
prev
=
=
nullptr
)
{
*
first
=
attr
;
}
else
{
prev
-
>
next
=
attr
;
}
attr
-
>
next
=
cur
;
break
;
}
if
(
cmp
=
=
0
)
{
bAdded
=
false
;
break
;
}
prev
=
cur
;
cur
=
cur
-
>
next
;
}
}
return
bAdded
;
}
static
UBool
_addExtensionToList
(
ExtensionListEntry
*
*
first
ExtensionListEntry
*
ext
UBool
localeToBCP
)
{
UBool
bAdded
=
true
;
if
(
*
first
=
=
nullptr
)
{
ext
-
>
next
=
nullptr
;
*
first
=
ext
;
}
else
{
ExtensionListEntry
*
prev
*
cur
;
int32_t
cmp
;
prev
=
nullptr
;
cur
=
*
first
;
while
(
true
)
{
if
(
cur
=
=
nullptr
)
{
prev
-
>
next
=
ext
;
ext
-
>
next
=
nullptr
;
break
;
}
if
(
localeToBCP
)
{
int32_t
len
curlen
;
len
=
(
int32_t
)
uprv_strlen
(
ext
-
>
key
)
;
curlen
=
(
int32_t
)
uprv_strlen
(
cur
-
>
key
)
;
if
(
len
=
=
1
&
&
curlen
=
=
1
)
{
if
(
*
(
ext
-
>
key
)
=
=
*
(
cur
-
>
key
)
)
{
cmp
=
0
;
}
else
if
(
*
(
ext
-
>
key
)
=
=
PRIVATEUSE
)
{
cmp
=
1
;
}
else
if
(
*
(
cur
-
>
key
)
=
=
PRIVATEUSE
)
{
cmp
=
-
1
;
}
else
{
cmp
=
*
(
ext
-
>
key
)
-
*
(
cur
-
>
key
)
;
}
}
else
if
(
len
=
=
1
)
{
cmp
=
*
(
ext
-
>
key
)
-
LDMLEXT
;
}
else
if
(
curlen
=
=
1
)
{
cmp
=
LDMLEXT
-
*
(
cur
-
>
key
)
;
}
else
{
cmp
=
uprv_compareInvCharsAsAscii
(
ext
-
>
key
cur
-
>
key
)
;
if
(
cmp
!
=
0
)
{
if
(
uprv_strcmp
(
cur
-
>
key
LOCALE_ATTRIBUTE_KEY
)
=
=
0
)
{
cmp
=
1
;
}
else
if
(
uprv_strcmp
(
ext
-
>
key
LOCALE_ATTRIBUTE_KEY
)
=
=
0
)
{
cmp
=
-
1
;
}
}
}
}
else
{
cmp
=
uprv_compareInvCharsAsAscii
(
ext
-
>
key
cur
-
>
key
)
;
}
if
(
cmp
<
0
)
{
if
(
prev
=
=
nullptr
)
{
*
first
=
ext
;
}
else
{
prev
-
>
next
=
ext
;
}
ext
-
>
next
=
cur
;
break
;
}
if
(
cmp
=
=
0
)
{
bAdded
=
false
;
break
;
}
prev
=
cur
;
cur
=
cur
-
>
next
;
}
}
return
bAdded
;
}
static
void
_initializeULanguageTag
(
ULanguageTag
*
langtag
)
{
int32_t
i
;
langtag
-
>
buf
=
nullptr
;
langtag
-
>
language
=
EMPTY
;
for
(
i
=
0
;
i
<
MAXEXTLANG
;
i
+
+
)
{
langtag
-
>
extlang
[
i
]
=
nullptr
;
}
langtag
-
>
script
=
EMPTY
;
langtag
-
>
region
=
EMPTY
;
langtag
-
>
variants
=
nullptr
;
langtag
-
>
extensions
=
nullptr
;
langtag
-
>
legacy
=
EMPTY
;
langtag
-
>
privateuse
=
EMPTY
;
}
static
void
_appendLanguageToLanguageTag
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UBool
strict
UErrorCode
*
status
)
{
char
buf
[
ULOC_LANG_CAPACITY
]
;
UErrorCode
tmpStatus
=
U_ZERO_ERROR
;
int32_t
len
i
;
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
len
=
uloc_getLanguage
(
localeID
buf
sizeof
(
buf
)
&
tmpStatus
)
;
if
(
U_FAILURE
(
tmpStatus
)
|
|
tmpStatus
=
=
U_STRING_NOT_TERMINATED_WARNING
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
len
=
0
;
}
if
(
len
=
=
0
)
{
sink
.
Append
(
LANG_UND
LANG_UND_LEN
)
;
}
else
if
(
!
ultag_isLanguageSubtag
(
buf
len
)
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
sink
.
Append
(
LANG_UND
LANG_UND_LEN
)
;
}
else
{
for
(
i
=
0
;
i
<
UPRV_LENGTHOF
(
DEPRECATEDLANGS
)
;
i
+
=
2
)
{
if
(
uprv_strlen
(
buf
)
<
uprv_strlen
(
DEPRECATEDLANGS
[
i
]
)
)
break
;
if
(
uprv_compareInvCharsAsAscii
(
buf
DEPRECATEDLANGS
[
i
]
)
=
=
0
)
{
uprv_strcpy
(
buf
DEPRECATEDLANGS
[
i
+
1
]
)
;
len
=
(
int32_t
)
uprv_strlen
(
buf
)
;
break
;
}
}
sink
.
Append
(
buf
len
)
;
}
}
static
void
_appendScriptToLanguageTag
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UBool
strict
UErrorCode
*
status
)
{
char
buf
[
ULOC_SCRIPT_CAPACITY
]
;
UErrorCode
tmpStatus
=
U_ZERO_ERROR
;
int32_t
len
;
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
len
=
uloc_getScript
(
localeID
buf
sizeof
(
buf
)
&
tmpStatus
)
;
if
(
U_FAILURE
(
tmpStatus
)
|
|
tmpStatus
=
=
U_STRING_NOT_TERMINATED_WARNING
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
;
}
if
(
len
>
0
)
{
if
(
!
ultag_isScriptSubtag
(
buf
len
)
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
;
}
else
{
sink
.
Append
(
"
-
"
1
)
;
sink
.
Append
(
buf
len
)
;
}
}
}
static
void
_appendRegionToLanguageTag
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UBool
strict
UErrorCode
*
status
)
{
char
buf
[
ULOC_COUNTRY_CAPACITY
]
;
UErrorCode
tmpStatus
=
U_ZERO_ERROR
;
int32_t
len
;
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
len
=
uloc_getCountry
(
localeID
buf
sizeof
(
buf
)
&
tmpStatus
)
;
if
(
U_FAILURE
(
tmpStatus
)
|
|
tmpStatus
=
=
U_STRING_NOT_TERMINATED_WARNING
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
;
}
if
(
len
>
0
)
{
if
(
!
ultag_isRegionSubtag
(
buf
len
)
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
;
}
else
{
sink
.
Append
(
"
-
"
1
)
;
for
(
int
i
=
0
;
i
<
UPRV_LENGTHOF
(
DEPRECATEDREGIONS
)
;
i
+
=
2
)
{
if
(
uprv_compareInvCharsAsAscii
(
buf
DEPRECATEDREGIONS
[
i
]
)
=
=
0
)
{
uprv_strcpy
(
buf
DEPRECATEDREGIONS
[
i
+
1
]
)
;
len
=
(
int32_t
)
uprv_strlen
(
buf
)
;
break
;
}
}
sink
.
Append
(
buf
len
)
;
}
}
}
static
void
_sortVariants
(
VariantListEntry
*
first
)
{
for
(
VariantListEntry
*
var1
=
first
;
var1
!
=
nullptr
;
var1
=
var1
-
>
next
)
{
for
(
VariantListEntry
*
var2
=
var1
-
>
next
;
var2
!
=
nullptr
;
var2
=
var2
-
>
next
)
{
if
(
uprv_compareInvCharsAsAscii
(
var1
-
>
variant
var2
-
>
variant
)
>
0
)
{
const
char
*
temp
=
var1
-
>
variant
;
var1
-
>
variant
=
var2
-
>
variant
;
var2
-
>
variant
=
temp
;
}
}
}
}
static
void
_appendVariantsToLanguageTag
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UBool
strict
UBool
*
hadPosix
UErrorCode
*
status
)
{
char
buf
[
ULOC_FULLNAME_CAPACITY
]
;
UErrorCode
tmpStatus
=
U_ZERO_ERROR
;
int32_t
len
i
;
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
len
=
uloc_getVariant
(
localeID
buf
sizeof
(
buf
)
&
tmpStatus
)
;
if
(
U_FAILURE
(
tmpStatus
)
|
|
tmpStatus
=
=
U_STRING_NOT_TERMINATED_WARNING
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
;
}
if
(
len
>
0
)
{
char
*
p
*
pVar
;
UBool
bNext
=
true
;
VariantListEntry
*
var
;
VariantListEntry
*
varFirst
=
nullptr
;
pVar
=
nullptr
;
p
=
buf
;
while
(
bNext
)
{
if
(
*
p
=
=
SEP
|
|
*
p
=
=
LOCALE_SEP
|
|
*
p
=
=
0
)
{
if
(
*
p
=
=
0
)
{
bNext
=
false
;
}
else
{
*
p
=
0
;
}
if
(
pVar
=
=
nullptr
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
}
else
{
for
(
i
=
0
;
*
(
pVar
+
i
)
!
=
0
;
i
+
+
)
{
*
(
pVar
+
i
)
=
uprv_tolower
(
*
(
pVar
+
i
)
)
;
}
if
(
_isVariantSubtag
(
pVar
-
1
)
)
{
if
(
uprv_strcmp
(
pVar
POSIX_VALUE
)
|
|
len
!
=
(
int32_t
)
uprv_strlen
(
POSIX_VALUE
)
)
{
var
=
(
VariantListEntry
*
)
uprv_malloc
(
sizeof
(
VariantListEntry
)
)
;
if
(
var
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
var
-
>
variant
=
pVar
;
if
(
!
_addVariantToList
(
&
varFirst
var
)
)
{
uprv_free
(
var
)
;
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
}
}
else
{
*
hadPosix
=
true
;
}
}
else
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
else
if
(
_isPrivateuseValueSubtag
(
pVar
-
1
)
)
{
break
;
}
}
pVar
=
nullptr
;
}
else
if
(
pVar
=
=
nullptr
)
{
pVar
=
p
;
}
p
+
+
;
}
if
(
U_SUCCESS
(
*
status
)
)
{
if
(
varFirst
!
=
nullptr
)
{
int32_t
varLen
;
_sortVariants
(
varFirst
)
;
var
=
varFirst
;
while
(
var
!
=
nullptr
)
{
sink
.
Append
(
"
-
"
1
)
;
varLen
=
(
int32_t
)
uprv_strlen
(
var
-
>
variant
)
;
sink
.
Append
(
var
-
>
variant
varLen
)
;
var
=
var
-
>
next
;
}
}
}
var
=
varFirst
;
while
(
var
!
=
nullptr
)
{
VariantListEntry
*
tmpVar
=
var
-
>
next
;
uprv_free
(
var
)
;
var
=
tmpVar
;
}
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
}
}
static
void
_appendKeywordsToLanguageTag
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UBool
strict
UBool
hadPosix
UErrorCode
*
status
)
{
char
attrBuf
[
ULOC_KEYWORD_AND_VALUES_CAPACITY
]
=
{
0
}
;
int32_t
attrBufLength
=
0
;
icu
:
:
MemoryPool
<
AttributeListEntry
>
attrPool
;
icu
:
:
MemoryPool
<
ExtensionListEntry
>
extPool
;
icu
:
:
MemoryPool
<
icu
:
:
CharString
>
strPool
;
icu
:
:
LocalUEnumerationPointer
keywordEnum
(
uloc_openKeywords
(
localeID
status
)
)
;
if
(
U_FAILURE
(
*
status
)
&
&
!
hadPosix
)
{
return
;
}
if
(
keywordEnum
.
isValid
(
)
|
|
hadPosix
)
{
int32_t
len
;
const
char
*
key
;
ExtensionListEntry
*
firstExt
=
nullptr
;
ExtensionListEntry
*
ext
;
AttributeListEntry
*
firstAttr
=
nullptr
;
AttributeListEntry
*
attr
;
icu
:
:
MemoryPool
<
icu
:
:
CharString
>
extBufPool
;
const
char
*
bcpKey
=
nullptr
*
bcpValue
=
nullptr
;
UErrorCode
tmpStatus
=
U_ZERO_ERROR
;
int32_t
keylen
;
UBool
isBcpUExt
;
while
(
true
)
{
key
=
uenum_next
(
keywordEnum
.
getAlias
(
)
nullptr
status
)
;
if
(
key
=
=
nullptr
)
{
break
;
}
icu
:
:
CharString
buf
;
{
icu
:
:
CharStringByteSink
sink
(
&
buf
)
;
ulocimp_getKeywordValue
(
localeID
key
sink
&
tmpStatus
)
;
}
len
=
buf
.
length
(
)
;
if
(
U_FAILURE
(
tmpStatus
)
)
{
if
(
tmpStatus
=
=
U_MEMORY_ALLOCATION_ERROR
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
tmpStatus
=
U_ZERO_ERROR
;
continue
;
}
keylen
=
(
int32_t
)
uprv_strlen
(
key
)
;
isBcpUExt
=
(
keylen
>
1
)
;
if
(
uprv_strcmp
(
key
LOCALE_ATTRIBUTE_KEY
)
=
=
0
)
{
if
(
len
>
0
)
{
int32_t
i
=
0
;
while
(
true
)
{
attrBufLength
=
0
;
for
(
;
i
<
len
;
i
+
+
)
{
if
(
buf
[
i
]
!
=
'
-
'
)
{
attrBuf
[
attrBufLength
+
+
]
=
buf
[
i
]
;
}
else
{
i
+
+
;
break
;
}
}
if
(
attrBufLength
>
0
)
{
attrBuf
[
attrBufLength
]
=
0
;
}
else
if
(
i
>
=
len
)
{
break
;
}
attr
=
attrPool
.
create
(
)
;
if
(
attr
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
icu
:
:
CharString
*
attrValue
=
strPool
.
create
(
attrBuf
attrBufLength
*
status
)
;
if
(
attrValue
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
if
(
U_FAILURE
(
*
status
)
)
{
break
;
}
attr
-
>
attribute
=
attrValue
-
>
data
(
)
;
if
(
!
_addAttributeToList
(
&
firstAttr
attr
)
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
}
}
bcpKey
=
LOCALE_ATTRIBUTE_KEY
;
bcpValue
=
nullptr
;
}
}
else
if
(
isBcpUExt
)
{
bcpKey
=
uloc_toUnicodeLocaleKey
(
key
)
;
if
(
bcpKey
=
=
nullptr
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
continue
;
}
bcpValue
=
uloc_toUnicodeLocaleType
(
key
buf
.
data
(
)
)
;
if
(
bcpValue
=
=
nullptr
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
continue
;
}
if
(
bcpValue
=
=
buf
.
data
(
)
)
{
icu
:
:
CharString
*
extBuf
=
extBufPool
.
create
(
buf
tmpStatus
)
;
if
(
extBuf
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
if
(
U_FAILURE
(
tmpStatus
)
)
{
*
status
=
tmpStatus
;
break
;
}
T_CString_toLowerCase
(
extBuf
-
>
data
(
)
)
;
bcpValue
=
extBuf
-
>
data
(
)
;
}
}
else
{
if
(
*
key
=
=
PRIVATEUSE
)
{
if
(
!
ultag_isPrivateuseValueSubtags
(
buf
.
data
(
)
len
)
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
continue
;
}
}
else
{
if
(
!
_isExtensionSingleton
(
key
keylen
)
|
|
!
ultag_isExtensionSubtags
(
buf
.
data
(
)
len
)
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
continue
;
}
}
bcpKey
=
key
;
icu
:
:
CharString
*
extBuf
=
extBufPool
.
create
(
buf
.
data
(
)
len
tmpStatus
)
;
if
(
extBuf
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
if
(
U_FAILURE
(
tmpStatus
)
)
{
*
status
=
tmpStatus
;
break
;
}
bcpValue
=
extBuf
-
>
data
(
)
;
}
ext
=
extPool
.
create
(
)
;
if
(
ext
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
ext
-
>
key
=
bcpKey
;
ext
-
>
value
=
bcpValue
;
if
(
!
_addExtensionToList
(
&
firstExt
ext
true
)
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
}
}
if
(
hadPosix
)
{
ext
=
extPool
.
create
(
)
;
if
(
ext
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
ext
-
>
key
=
POSIX_KEY
;
ext
-
>
value
=
POSIX_VALUE
;
if
(
!
_addExtensionToList
(
&
firstExt
ext
true
)
)
{
}
}
if
(
U_SUCCESS
(
*
status
)
&
&
(
firstExt
!
=
nullptr
|
|
firstAttr
!
=
nullptr
)
)
{
UBool
startLDMLExtension
=
false
;
for
(
ext
=
firstExt
;
ext
;
ext
=
ext
-
>
next
)
{
if
(
!
startLDMLExtension
&
&
uprv_strlen
(
ext
-
>
key
)
>
1
)
{
sink
.
Append
(
"
-
u
"
2
)
;
startLDMLExtension
=
true
;
}
if
(
uprv_strcmp
(
ext
-
>
key
LOCALE_ATTRIBUTE_KEY
)
=
=
0
)
{
for
(
attr
=
firstAttr
;
attr
;
attr
=
attr
-
>
next
)
{
sink
.
Append
(
"
-
"
1
)
;
sink
.
Append
(
attr
-
>
attribute
static_cast
<
int32_t
>
(
uprv_strlen
(
attr
-
>
attribute
)
)
)
;
}
}
else
{
sink
.
Append
(
"
-
"
1
)
;
sink
.
Append
(
ext
-
>
key
static_cast
<
int32_t
>
(
uprv_strlen
(
ext
-
>
key
)
)
)
;
if
(
uprv_strcmp
(
ext
-
>
value
"
true
"
)
!
=
0
&
&
uprv_strcmp
(
ext
-
>
value
"
yes
"
)
!
=
0
)
{
sink
.
Append
(
"
-
"
1
)
;
sink
.
Append
(
ext
-
>
value
static_cast
<
int32_t
>
(
uprv_strlen
(
ext
-
>
value
)
)
)
;
}
}
}
}
}
}
static
void
_appendLDMLExtensionAsKeywords
(
const
char
*
ldmlext
ExtensionListEntry
*
*
appendTo
icu
:
:
MemoryPool
<
ExtensionListEntry
>
&
extPool
icu
:
:
MemoryPool
<
icu
:
:
CharString
>
&
kwdBuf
UBool
*
posixVariant
UErrorCode
*
status
)
{
const
char
*
pTag
;
const
char
*
pKwds
;
UBool
variantExists
=
*
posixVariant
;
ExtensionListEntry
*
kwdFirst
=
nullptr
;
ExtensionListEntry
*
kwd
*
nextKwd
;
int32_t
len
;
*
posixVariant
=
false
;
pTag
=
ldmlext
;
pKwds
=
nullptr
;
{
AttributeListEntry
*
attrFirst
=
nullptr
;
AttributeListEntry
*
attr
*
nextAttr
;
char
attrBuf
[
ULOC_KEYWORD_AND_VALUES_CAPACITY
]
;
int32_t
attrBufIdx
=
0
;
icu
:
:
MemoryPool
<
AttributeListEntry
>
attrPool
;
while
(
*
pTag
)
{
for
(
len
=
0
;
*
(
pTag
+
len
)
&
&
*
(
pTag
+
len
)
!
=
SEP
;
len
+
+
)
;
if
(
ultag_isUnicodeLocaleKey
(
pTag
len
)
)
{
pKwds
=
pTag
;
break
;
}
attr
=
attrPool
.
create
(
)
;
if
(
attr
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
if
(
len
<
(
int32_t
)
sizeof
(
attrBuf
)
-
attrBufIdx
)
{
uprv_memcpy
(
&
attrBuf
[
attrBufIdx
]
pTag
len
)
;
attrBuf
[
attrBufIdx
+
len
]
=
0
;
attr
-
>
attribute
=
&
attrBuf
[
attrBufIdx
]
;
attrBufIdx
+
=
(
len
+
1
)
;
}
else
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
_addAttributeToList
(
&
attrFirst
attr
)
;
pTag
+
=
len
;
if
(
*
pTag
)
{
pTag
+
+
;
}
}
if
(
attrFirst
)
{
kwd
=
extPool
.
create
(
)
;
if
(
kwd
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
icu
:
:
CharString
*
value
=
kwdBuf
.
create
(
)
;
if
(
value
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
attr
=
attrFirst
;
while
(
attr
!
=
nullptr
)
{
nextAttr
=
attr
-
>
next
;
if
(
attr
!
=
attrFirst
)
{
value
-
>
append
(
'
-
'
*
status
)
;
}
value
-
>
append
(
attr
-
>
attribute
*
status
)
;
attr
=
nextAttr
;
}
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
kwd
-
>
key
=
LOCALE_ATTRIBUTE_KEY
;
kwd
-
>
value
=
value
-
>
data
(
)
;
if
(
!
_addExtensionToList
(
&
kwdFirst
kwd
false
)
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
}
}
if
(
pKwds
)
{
const
char
*
pBcpKey
=
nullptr
;
const
char
*
pBcpType
=
nullptr
;
int32_t
bcpKeyLen
=
0
;
int32_t
bcpTypeLen
=
0
;
UBool
isDone
=
false
;
pTag
=
pKwds
;
while
(
!
isDone
)
{
const
char
*
pNextBcpKey
=
nullptr
;
int32_t
nextBcpKeyLen
=
0
;
UBool
emitKeyword
=
false
;
if
(
*
pTag
)
{
for
(
len
=
0
;
*
(
pTag
+
len
)
&
&
*
(
pTag
+
len
)
!
=
SEP
;
len
+
+
)
;
if
(
ultag_isUnicodeLocaleKey
(
pTag
len
)
)
{
if
(
pBcpKey
)
{
emitKeyword
=
true
;
pNextBcpKey
=
pTag
;
nextBcpKeyLen
=
len
;
}
else
{
pBcpKey
=
pTag
;
bcpKeyLen
=
len
;
}
}
else
{
U_ASSERT
(
pBcpKey
!
=
nullptr
)
;
if
(
pBcpType
)
{
bcpTypeLen
+
=
(
len
+
1
)
;
}
else
{
pBcpType
=
pTag
;
bcpTypeLen
=
len
;
}
}
pTag
+
=
len
;
if
(
*
pTag
)
{
pTag
+
+
;
}
}
else
{
emitKeyword
=
true
;
isDone
=
true
;
}
if
(
emitKeyword
)
{
const
char
*
pKey
=
nullptr
;
const
char
*
pType
=
nullptr
;
char
bcpKeyBuf
[
3
]
;
U_ASSERT
(
pBcpKey
!
=
nullptr
)
;
if
(
bcpKeyLen
>
=
(
int32_t
)
sizeof
(
bcpKeyBuf
)
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
U_ASSERT
(
bcpKeyLen
<
=
2
)
;
uprv_strncpy
(
bcpKeyBuf
pBcpKey
bcpKeyLen
)
;
bcpKeyBuf
[
bcpKeyLen
]
=
0
;
pKey
=
uloc_toLegacyKey
(
bcpKeyBuf
)
;
if
(
pKey
=
=
nullptr
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
if
(
pKey
=
=
bcpKeyBuf
)
{
T_CString_toLowerCase
(
bcpKeyBuf
)
;
icu
:
:
CharString
*
key
=
kwdBuf
.
create
(
bcpKeyBuf
bcpKeyLen
*
status
)
;
if
(
key
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
pKey
=
key
-
>
data
(
)
;
}
if
(
pBcpType
)
{
char
bcpTypeBuf
[
128
]
;
if
(
bcpTypeLen
>
=
(
int32_t
)
sizeof
(
bcpTypeBuf
)
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
uprv_strncpy
(
bcpTypeBuf
pBcpType
bcpTypeLen
)
;
bcpTypeBuf
[
bcpTypeLen
]
=
0
;
pType
=
uloc_toLegacyType
(
pKey
bcpTypeBuf
)
;
if
(
pType
=
=
nullptr
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
if
(
pType
=
=
bcpTypeBuf
)
{
T_CString_toLowerCase
(
bcpTypeBuf
)
;
icu
:
:
CharString
*
type
=
kwdBuf
.
create
(
bcpTypeBuf
bcpTypeLen
*
status
)
;
if
(
type
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
pType
=
type
-
>
data
(
)
;
}
}
else
{
pType
=
LOCALE_TYPE_YES
;
}
if
(
!
variantExists
&
&
!
uprv_strcmp
(
pKey
POSIX_KEY
)
&
&
!
uprv_strcmp
(
pType
POSIX_VALUE
)
)
{
*
posixVariant
=
true
;
}
else
{
kwd
=
extPool
.
create
(
)
;
if
(
kwd
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
;
}
kwd
-
>
key
=
pKey
;
kwd
-
>
value
=
pType
;
if
(
!
_addExtensionToList
(
&
kwdFirst
kwd
false
)
)
{
}
}
pBcpKey
=
pNextBcpKey
;
bcpKeyLen
=
pNextBcpKey
!
=
nullptr
?
nextBcpKeyLen
:
0
;
pBcpType
=
nullptr
;
bcpTypeLen
=
0
;
}
}
}
kwd
=
kwdFirst
;
while
(
kwd
!
=
nullptr
)
{
nextKwd
=
kwd
-
>
next
;
_addExtensionToList
(
appendTo
kwd
false
)
;
kwd
=
nextKwd
;
}
}
static
void
_appendKeywords
(
ULanguageTag
*
langtag
icu
:
:
ByteSink
&
sink
UErrorCode
*
status
)
{
int32_t
i
n
;
int32_t
len
;
ExtensionListEntry
*
kwdFirst
=
nullptr
;
ExtensionListEntry
*
kwd
;
const
char
*
key
*
type
;
icu
:
:
MemoryPool
<
ExtensionListEntry
>
extPool
;
icu
:
:
MemoryPool
<
icu
:
:
CharString
>
kwdBuf
;
UBool
posixVariant
=
false
;
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
n
=
ultag_getExtensionsSize
(
langtag
)
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
key
=
ultag_getExtensionKey
(
langtag
i
)
;
type
=
ultag_getExtensionValue
(
langtag
i
)
;
if
(
*
key
=
=
LDMLEXT
)
{
if
(
ultag_getVariantsSize
(
langtag
)
)
{
posixVariant
=
true
;
}
_appendLDMLExtensionAsKeywords
(
type
&
kwdFirst
extPool
kwdBuf
&
posixVariant
status
)
;
if
(
U_FAILURE
(
*
status
)
)
{
break
;
}
}
else
{
kwd
=
extPool
.
create
(
)
;
if
(
kwd
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
break
;
}
kwd
-
>
key
=
key
;
kwd
-
>
value
=
type
;
if
(
!
_addExtensionToList
(
&
kwdFirst
kwd
false
)
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
}
}
if
(
U_SUCCESS
(
*
status
)
)
{
type
=
ultag_getPrivateUse
(
langtag
)
;
if
(
(
int32_t
)
uprv_strlen
(
type
)
>
0
)
{
kwd
=
extPool
.
create
(
)
;
if
(
kwd
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
}
else
{
kwd
-
>
key
=
PRIVATEUSE_KEY
;
kwd
-
>
value
=
type
;
if
(
!
_addExtensionToList
(
&
kwdFirst
kwd
false
)
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
}
}
}
if
(
U_SUCCESS
(
*
status
)
&
&
posixVariant
)
{
len
=
(
int32_t
)
uprv_strlen
(
_POSIX
)
;
sink
.
Append
(
_POSIX
len
)
;
}
if
(
U_SUCCESS
(
*
status
)
&
&
kwdFirst
!
=
nullptr
)
{
UBool
firstValue
=
true
;
kwd
=
kwdFirst
;
do
{
if
(
firstValue
)
{
sink
.
Append
(
"
"
1
)
;
firstValue
=
false
;
}
else
{
sink
.
Append
(
"
;
"
1
)
;
}
len
=
(
int32_t
)
uprv_strlen
(
kwd
-
>
key
)
;
sink
.
Append
(
kwd
-
>
key
len
)
;
sink
.
Append
(
"
=
"
1
)
;
len
=
(
int32_t
)
uprv_strlen
(
kwd
-
>
value
)
;
sink
.
Append
(
kwd
-
>
value
len
)
;
kwd
=
kwd
-
>
next
;
}
while
(
kwd
)
;
}
}
static
void
_appendPrivateuseToLanguageTag
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UBool
strict
UBool
hadPosix
UErrorCode
*
status
)
{
(
void
)
hadPosix
;
char
buf
[
ULOC_FULLNAME_CAPACITY
]
;
char
tmpAppend
[
ULOC_FULLNAME_CAPACITY
]
;
UErrorCode
tmpStatus
=
U_ZERO_ERROR
;
int32_t
len
i
;
int32_t
reslen
=
0
;
int32_t
capacity
=
sizeof
tmpAppend
;
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
len
=
uloc_getVariant
(
localeID
buf
sizeof
(
buf
)
&
tmpStatus
)
;
if
(
U_FAILURE
(
tmpStatus
)
|
|
tmpStatus
=
=
U_STRING_NOT_TERMINATED_WARNING
)
{
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
}
return
;
}
if
(
len
>
0
)
{
char
*
p
*
pPriv
;
UBool
bNext
=
true
;
UBool
firstValue
=
true
;
UBool
writeValue
;
pPriv
=
nullptr
;
p
=
buf
;
while
(
bNext
)
{
writeValue
=
false
;
if
(
*
p
=
=
SEP
|
|
*
p
=
=
LOCALE_SEP
|
|
*
p
=
=
0
)
{
if
(
*
p
=
=
0
)
{
bNext
=
false
;
}
else
{
*
p
=
0
;
}
if
(
pPriv
!
=
nullptr
)
{
for
(
i
=
0
;
*
(
pPriv
+
i
)
!
=
0
;
i
+
+
)
{
*
(
pPriv
+
i
)
=
uprv_tolower
(
*
(
pPriv
+
i
)
)
;
}
if
(
_isPrivateuseValueSubtag
(
pPriv
-
1
)
)
{
if
(
firstValue
)
{
if
(
!
_isVariantSubtag
(
pPriv
-
1
)
)
{
writeValue
=
true
;
}
}
else
{
writeValue
=
true
;
}
}
else
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
break
;
}
else
{
break
;
}
if
(
writeValue
)
{
if
(
reslen
<
capacity
)
{
tmpAppend
[
reslen
+
+
]
=
SEP
;
}
if
(
firstValue
)
{
if
(
reslen
<
capacity
)
{
tmpAppend
[
reslen
+
+
]
=
*
PRIVATEUSE_KEY
;
}
if
(
reslen
<
capacity
)
{
tmpAppend
[
reslen
+
+
]
=
SEP
;
}
len
=
(
int32_t
)
uprv_strlen
(
PRIVUSE_VARIANT_PREFIX
)
;
if
(
reslen
<
capacity
)
{
uprv_memcpy
(
tmpAppend
+
reslen
PRIVUSE_VARIANT_PREFIX
uprv_min
(
len
capacity
-
reslen
)
)
;
}
reslen
+
=
len
;
if
(
reslen
<
capacity
)
{
tmpAppend
[
reslen
+
+
]
=
SEP
;
}
firstValue
=
false
;
}
len
=
(
int32_t
)
uprv_strlen
(
pPriv
)
;
if
(
reslen
<
capacity
)
{
uprv_memcpy
(
tmpAppend
+
reslen
pPriv
uprv_min
(
len
capacity
-
reslen
)
)
;
}
reslen
+
=
len
;
}
}
pPriv
=
nullptr
;
}
else
if
(
pPriv
=
=
nullptr
)
{
pPriv
=
p
;
}
p
+
+
;
}
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
}
if
(
U_SUCCESS
(
*
status
)
)
{
len
=
reslen
;
sink
.
Append
(
tmpAppend
len
)
;
}
}
#
define
LANG
0x0001
#
define
EXTL
0x0002
#
define
SCRT
0x0004
#
define
REGN
0x0008
#
define
VART
0x0010
#
define
EXTS
0x0020
#
define
EXTV
0x0040
#
define
PRIV
0x0080
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
>
=
1900
)
&
&
(
_MSC_VER
<
1924
)
#
pragma
optimize
(
"
"
off
)
#
endif
static
ULanguageTag
*
ultag_parse
(
const
char
*
tag
int32_t
tagLen
int32_t
*
parsedLen
UErrorCode
*
status
)
{
char
*
tagBuf
;
int16_t
next
;
char
*
pSubtag
*
pNext
*
pLastGoodPosition
;
int32_t
subtagLen
;
int32_t
extlangIdx
;
ExtensionListEntry
*
pExtension
;
char
*
pExtValueSubtag
*
pExtValueSubtagEnd
;
int32_t
i
;
UBool
privateuseVar
=
false
;
int32_t
legacyLen
=
0
;
if
(
parsedLen
!
=
nullptr
)
{
*
parsedLen
=
0
;
}
if
(
U_FAILURE
(
*
status
)
)
{
return
nullptr
;
}
if
(
tagLen
<
0
)
{
tagLen
=
(
int32_t
)
uprv_strlen
(
tag
)
;
}
tagBuf
=
(
char
*
)
uprv_malloc
(
tagLen
+
1
)
;
if
(
tagBuf
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
if
(
tagLen
>
0
)
{
uprv_memcpy
(
tagBuf
tag
tagLen
)
;
}
*
(
tagBuf
+
tagLen
)
=
0
;
icu
:
:
LocalULanguageTagPointer
t
(
(
ULanguageTag
*
)
uprv_malloc
(
sizeof
(
ULanguageTag
)
)
)
;
if
(
t
.
isNull
(
)
)
{
uprv_free
(
tagBuf
)
;
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
_initializeULanguageTag
(
t
.
getAlias
(
)
)
;
t
-
>
buf
=
tagBuf
;
if
(
tagLen
<
MINLEN
)
{
return
t
.
orphan
(
)
;
}
size_t
parsedLenDelta
=
0
;
for
(
i
=
0
;
i
<
UPRV_LENGTHOF
(
LEGACY
)
;
i
+
=
2
)
{
int32_t
checkLegacyLen
=
static_cast
<
int32_t
>
(
uprv_strlen
(
LEGACY
[
i
]
)
)
;
if
(
tagLen
<
checkLegacyLen
)
{
continue
;
}
if
(
tagLen
>
checkLegacyLen
&
&
tagBuf
[
checkLegacyLen
]
!
=
'
-
'
)
{
continue
;
}
if
(
uprv_strnicmp
(
LEGACY
[
i
]
tagBuf
checkLegacyLen
)
=
=
0
)
{
int32_t
newTagLength
;
legacyLen
=
checkLegacyLen
;
int32_t
replacementLen
=
static_cast
<
int32_t
>
(
uprv_strlen
(
LEGACY
[
i
+
1
]
)
)
;
newTagLength
=
replacementLen
+
tagLen
-
checkLegacyLen
;
int32_t
oldTagLength
=
tagLen
;
if
(
tagLen
<
newTagLength
)
{
uprv_free
(
tagBuf
)
;
tagBuf
=
(
char
*
)
uprv_malloc
(
newTagLength
+
1
)
;
if
(
tagBuf
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
t
-
>
buf
=
tagBuf
;
tagLen
=
newTagLength
;
}
parsedLenDelta
=
checkLegacyLen
-
replacementLen
;
uprv_strcpy
(
t
-
>
buf
LEGACY
[
i
+
1
]
)
;
if
(
checkLegacyLen
!
=
tagLen
)
{
uprv_memcpy
(
t
-
>
buf
+
replacementLen
tag
+
checkLegacyLen
oldTagLength
-
checkLegacyLen
)
;
t
-
>
buf
[
replacementLen
+
oldTagLength
-
checkLegacyLen
]
=
0
;
}
break
;
}
}
if
(
legacyLen
=
=
0
)
{
for
(
i
=
0
;
i
<
UPRV_LENGTHOF
(
REDUNDANT
)
;
i
+
=
2
)
{
const
char
*
redundantTag
=
REDUNDANT
[
i
]
;
size_t
redundantTagLen
=
uprv_strlen
(
redundantTag
)
;
if
(
uprv_strnicmp
(
redundantTag
tagBuf
static_cast
<
uint32_t
>
(
redundantTagLen
)
)
=
=
0
)
{
const
char
*
redundantTagEnd
=
tagBuf
+
redundantTagLen
;
if
(
*
redundantTagEnd
=
=
'
\
0
'
|
|
*
redundantTagEnd
=
=
SEP
)
{
const
char
*
preferredTag
=
REDUNDANT
[
i
+
1
]
;
size_t
preferredTagLen
=
uprv_strlen
(
preferredTag
)
;
uprv_memcpy
(
t
-
>
buf
preferredTag
preferredTagLen
)
;
if
(
*
redundantTagEnd
=
=
SEP
)
{
uprv_memmove
(
tagBuf
+
preferredTagLen
redundantTagEnd
tagLen
-
redundantTagLen
+
1
)
;
}
else
{
tagBuf
[
preferredTagLen
]
=
'
\
0
'
;
}
parsedLenDelta
=
redundantTagLen
-
preferredTagLen
;
break
;
}
}
}
}
next
=
LANG
|
PRIV
;
pNext
=
pLastGoodPosition
=
tagBuf
;
extlangIdx
=
0
;
pExtension
=
nullptr
;
pExtValueSubtag
=
nullptr
;
pExtValueSubtagEnd
=
nullptr
;
while
(
pNext
)
{
char
*
pSep
;
pSubtag
=
pNext
;
pSep
=
pSubtag
;
while
(
*
pSep
)
{
if
(
*
pSep
=
=
SEP
)
{
break
;
}
pSep
+
+
;
}
if
(
*
pSep
=
=
0
)
{
pNext
=
nullptr
;
}
else
{
pNext
=
pSep
+
1
;
}
subtagLen
=
(
int32_t
)
(
pSep
-
pSubtag
)
;
if
(
next
&
LANG
)
{
if
(
ultag_isLanguageSubtag
(
pSubtag
subtagLen
)
)
{
*
pSep
=
0
;
t
-
>
language
=
T_CString_toLowerCase
(
pSubtag
)
;
pLastGoodPosition
=
pSep
;
next
=
SCRT
|
REGN
|
VART
|
EXTS
|
PRIV
;
if
(
subtagLen
<
=
3
)
next
|
=
EXTL
;
continue
;
}
}
if
(
next
&
EXTL
)
{
if
(
_isExtlangSubtag
(
pSubtag
subtagLen
)
)
{
*
pSep
=
0
;
t
-
>
extlang
[
extlangIdx
+
+
]
=
T_CString_toLowerCase
(
pSubtag
)
;
pLastGoodPosition
=
pSep
;
if
(
extlangIdx
<
3
)
{
next
=
EXTL
|
SCRT
|
REGN
|
VART
|
EXTS
|
PRIV
;
}
else
{
next
=
SCRT
|
REGN
|
VART
|
EXTS
|
PRIV
;
}
continue
;
}
}
if
(
next
&
SCRT
)
{
if
(
ultag_isScriptSubtag
(
pSubtag
subtagLen
)
)
{
char
*
p
=
pSubtag
;
*
pSep
=
0
;
*
p
=
uprv_toupper
(
*
p
)
;
p
+
+
;
for
(
;
*
p
;
p
+
+
)
{
*
p
=
uprv_tolower
(
*
p
)
;
}
t
-
>
script
=
pSubtag
;
pLastGoodPosition
=
pSep
;
next
=
REGN
|
VART
|
EXTS
|
PRIV
;
continue
;
}
}
if
(
next
&
REGN
)
{
if
(
ultag_isRegionSubtag
(
pSubtag
subtagLen
)
)
{
*
pSep
=
0
;
t
-
>
region
=
T_CString_toUpperCase
(
pSubtag
)
;
pLastGoodPosition
=
pSep
;
next
=
VART
|
EXTS
|
PRIV
;
continue
;
}
}
if
(
next
&
VART
)
{
if
(
_isVariantSubtag
(
pSubtag
subtagLen
)
|
|
(
privateuseVar
&
&
_isPrivateuseVariantSubtag
(
pSubtag
subtagLen
)
)
)
{
VariantListEntry
*
var
;
UBool
isAdded
;
var
=
(
VariantListEntry
*
)
uprv_malloc
(
sizeof
(
VariantListEntry
)
)
;
if
(
var
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
*
pSep
=
0
;
var
-
>
variant
=
T_CString_toUpperCase
(
pSubtag
)
;
isAdded
=
_addVariantToList
(
&
(
t
-
>
variants
)
var
)
;
if
(
!
isAdded
)
{
uprv_free
(
var
)
;
break
;
}
pLastGoodPosition
=
pSep
;
next
=
VART
|
EXTS
|
PRIV
;
continue
;
}
}
if
(
next
&
EXTS
)
{
if
(
_isExtensionSingleton
(
pSubtag
subtagLen
)
)
{
if
(
pExtension
!
=
nullptr
)
{
if
(
pExtValueSubtag
=
=
nullptr
|
|
pExtValueSubtagEnd
=
=
nullptr
)
{
uprv_free
(
pExtension
)
;
pExtension
=
nullptr
;
break
;
}
*
pExtValueSubtagEnd
=
0
;
pExtension
-
>
value
=
T_CString_toLowerCase
(
pExtValueSubtag
)
;
if
(
_addExtensionToList
(
&
(
t
-
>
extensions
)
pExtension
false
)
)
{
pLastGoodPosition
=
pExtValueSubtagEnd
;
}
else
{
uprv_free
(
pExtension
)
;
pExtension
=
nullptr
;
break
;
}
}
pExtension
=
(
ExtensionListEntry
*
)
uprv_malloc
(
sizeof
(
ExtensionListEntry
)
)
;
if
(
pExtension
=
=
nullptr
)
{
*
status
=
U_MEMORY_ALLOCATION_ERROR
;
return
nullptr
;
}
*
pSep
=
0
;
pExtension
-
>
key
=
T_CString_toLowerCase
(
pSubtag
)
;
pExtension
-
>
value
=
nullptr
;
pExtValueSubtag
=
nullptr
;
pExtValueSubtagEnd
=
nullptr
;
next
=
EXTV
;
continue
;
}
}
if
(
next
&
EXTV
)
{
if
(
_isExtensionSubtag
(
pSubtag
subtagLen
)
)
{
if
(
pExtValueSubtag
=
=
nullptr
)
{
pExtValueSubtag
=
pSubtag
;
}
pExtValueSubtagEnd
=
pSep
;
next
=
EXTS
|
EXTV
|
PRIV
;
continue
;
}
}
if
(
next
&
PRIV
)
{
if
(
uprv_tolower
(
*
pSubtag
)
=
=
PRIVATEUSE
&
&
subtagLen
=
=
1
)
{
char
*
pPrivuseVal
;
if
(
pExtension
!
=
nullptr
)
{
if
(
pExtValueSubtag
=
=
nullptr
|
|
pExtValueSubtagEnd
=
=
nullptr
)
{
uprv_free
(
pExtension
)
;
pExtension
=
nullptr
;
break
;
}
else
{
*
pExtValueSubtagEnd
=
0
;
pExtension
-
>
value
=
T_CString_toLowerCase
(
pExtValueSubtag
)
;
if
(
_addExtensionToList
(
&
(
t
-
>
extensions
)
pExtension
false
)
)
{
pLastGoodPosition
=
pExtValueSubtagEnd
;
pExtension
=
nullptr
;
}
else
{
uprv_free
(
pExtension
)
;
pExtension
=
nullptr
;
break
;
}
}
}
if
(
pNext
=
=
nullptr
)
{
break
;
}
pPrivuseVal
=
pNext
;
while
(
pNext
)
{
pSubtag
=
pNext
;
pSep
=
pSubtag
;
while
(
*
pSep
)
{
if
(
*
pSep
=
=
SEP
)
{
break
;
}
pSep
+
+
;
}
if
(
*
pSep
=
=
0
)
{
pNext
=
nullptr
;
}
else
{
pNext
=
pSep
+
1
;
}
subtagLen
=
(
int32_t
)
(
pSep
-
pSubtag
)
;
if
(
uprv_strncmp
(
pSubtag
PRIVUSE_VARIANT_PREFIX
uprv_strlen
(
PRIVUSE_VARIANT_PREFIX
)
)
=
=
0
)
{
*
pSep
=
0
;
next
=
VART
;
privateuseVar
=
true
;
break
;
}
else
if
(
_isPrivateuseValueSubtag
(
pSubtag
subtagLen
)
)
{
pLastGoodPosition
=
pSep
;
}
else
{
break
;
}
}
if
(
next
=
=
VART
)
{
continue
;
}
if
(
pLastGoodPosition
-
pPrivuseVal
>
0
)
{
*
pLastGoodPosition
=
0
;
t
-
>
privateuse
=
T_CString_toLowerCase
(
pPrivuseVal
)
;
}
break
;
}
break
;
}
break
;
}
if
(
pExtension
!
=
nullptr
)
{
if
(
pExtValueSubtag
=
=
nullptr
|
|
pExtValueSubtagEnd
=
=
nullptr
)
{
uprv_free
(
pExtension
)
;
}
else
{
*
pExtValueSubtagEnd
=
0
;
pExtension
-
>
value
=
T_CString_toLowerCase
(
pExtValueSubtag
)
;
if
(
_addExtensionToList
(
&
(
t
-
>
extensions
)
pExtension
false
)
)
{
pLastGoodPosition
=
pExtValueSubtagEnd
;
}
else
{
uprv_free
(
pExtension
)
;
}
}
}
if
(
parsedLen
!
=
nullptr
)
{
*
parsedLen
=
(
int32_t
)
(
pLastGoodPosition
-
t
-
>
buf
+
parsedLenDelta
)
;
}
return
t
.
orphan
(
)
;
}
#
if
defined
(
_MSC_VER
)
&
&
(
_MSC_VER
>
=
1900
)
&
&
(
_MSC_VER
<
1924
)
#
pragma
optimize
(
"
"
on
)
#
endif
static
void
ultag_close
(
ULanguageTag
*
langtag
)
{
if
(
langtag
=
=
nullptr
)
{
return
;
}
uprv_free
(
langtag
-
>
buf
)
;
if
(
langtag
-
>
variants
)
{
VariantListEntry
*
curVar
=
langtag
-
>
variants
;
while
(
curVar
)
{
VariantListEntry
*
nextVar
=
curVar
-
>
next
;
uprv_free
(
curVar
)
;
curVar
=
nextVar
;
}
}
if
(
langtag
-
>
extensions
)
{
ExtensionListEntry
*
curExt
=
langtag
-
>
extensions
;
while
(
curExt
)
{
ExtensionListEntry
*
nextExt
=
curExt
-
>
next
;
uprv_free
(
curExt
)
;
curExt
=
nextExt
;
}
}
uprv_free
(
langtag
)
;
}
static
const
char
*
ultag_getLanguage
(
const
ULanguageTag
*
langtag
)
{
return
langtag
-
>
language
;
}
#
if
0
static
const
char
*
ultag_getJDKLanguage
(
const
ULanguageTag
*
langtag
)
{
int32_t
i
;
for
(
i
=
0
;
DEPRECATEDLANGS
[
i
]
!
=
nullptr
;
i
+
=
2
)
{
if
(
uprv_compareInvCharsAsAscii
(
DEPRECATEDLANGS
[
i
]
langtag
-
>
language
)
=
=
0
)
{
return
DEPRECATEDLANGS
[
i
+
1
]
;
}
}
return
langtag
-
>
language
;
}
#
endif
static
const
char
*
ultag_getExtlang
(
const
ULanguageTag
*
langtag
int32_t
idx
)
{
if
(
idx
>
=
0
&
&
idx
<
MAXEXTLANG
)
{
return
langtag
-
>
extlang
[
idx
]
;
}
return
nullptr
;
}
static
int32_t
ultag_getExtlangSize
(
const
ULanguageTag
*
langtag
)
{
int32_t
size
=
0
;
int32_t
i
;
for
(
i
=
0
;
i
<
MAXEXTLANG
;
i
+
+
)
{
if
(
langtag
-
>
extlang
[
i
]
)
{
size
+
+
;
}
}
return
size
;
}
static
const
char
*
ultag_getScript
(
const
ULanguageTag
*
langtag
)
{
return
langtag
-
>
script
;
}
static
const
char
*
ultag_getRegion
(
const
ULanguageTag
*
langtag
)
{
return
langtag
-
>
region
;
}
static
const
char
*
ultag_getVariant
(
const
ULanguageTag
*
langtag
int32_t
idx
)
{
const
char
*
var
=
nullptr
;
VariantListEntry
*
cur
=
langtag
-
>
variants
;
int32_t
i
=
0
;
while
(
cur
)
{
if
(
i
=
=
idx
)
{
var
=
cur
-
>
variant
;
break
;
}
cur
=
cur
-
>
next
;
i
+
+
;
}
return
var
;
}
static
int32_t
ultag_getVariantsSize
(
const
ULanguageTag
*
langtag
)
{
int32_t
size
=
0
;
VariantListEntry
*
cur
=
langtag
-
>
variants
;
while
(
true
)
{
if
(
cur
=
=
nullptr
)
{
break
;
}
size
+
+
;
cur
=
cur
-
>
next
;
}
return
size
;
}
static
const
char
*
ultag_getExtensionKey
(
const
ULanguageTag
*
langtag
int32_t
idx
)
{
const
char
*
key
=
nullptr
;
ExtensionListEntry
*
cur
=
langtag
-
>
extensions
;
int32_t
i
=
0
;
while
(
cur
)
{
if
(
i
=
=
idx
)
{
key
=
cur
-
>
key
;
break
;
}
cur
=
cur
-
>
next
;
i
+
+
;
}
return
key
;
}
static
const
char
*
ultag_getExtensionValue
(
const
ULanguageTag
*
langtag
int32_t
idx
)
{
const
char
*
val
=
nullptr
;
ExtensionListEntry
*
cur
=
langtag
-
>
extensions
;
int32_t
i
=
0
;
while
(
cur
)
{
if
(
i
=
=
idx
)
{
val
=
cur
-
>
value
;
break
;
}
cur
=
cur
-
>
next
;
i
+
+
;
}
return
val
;
}
static
int32_t
ultag_getExtensionsSize
(
const
ULanguageTag
*
langtag
)
{
int32_t
size
=
0
;
ExtensionListEntry
*
cur
=
langtag
-
>
extensions
;
while
(
true
)
{
if
(
cur
=
=
nullptr
)
{
break
;
}
size
+
+
;
cur
=
cur
-
>
next
;
}
return
size
;
}
static
const
char
*
ultag_getPrivateUse
(
const
ULanguageTag
*
langtag
)
{
return
langtag
-
>
privateuse
;
}
#
if
0
static
const
char
*
ultag_getLegacy
(
const
ULanguageTag
*
langtag
)
{
return
langtag
-
>
legacy
;
}
#
endif
U_CAPI
int32_t
U_EXPORT2
uloc_toLanguageTag
(
const
char
*
localeID
char
*
langtag
int32_t
langtagCapacity
UBool
strict
UErrorCode
*
status
)
{
if
(
U_FAILURE
(
*
status
)
)
{
return
0
;
}
icu
:
:
CheckedArrayByteSink
sink
(
langtag
langtagCapacity
)
;
ulocimp_toLanguageTag
(
localeID
sink
strict
status
)
;
int32_t
reslen
=
sink
.
NumberOfBytesAppended
(
)
;
if
(
U_FAILURE
(
*
status
)
)
{
return
reslen
;
}
if
(
sink
.
Overflowed
(
)
)
{
*
status
=
U_BUFFER_OVERFLOW_ERROR
;
}
else
{
u_terminateChars
(
langtag
langtagCapacity
reslen
status
)
;
}
return
reslen
;
}
U_CAPI
void
U_EXPORT2
ulocimp_toLanguageTag
(
const
char
*
localeID
icu
:
:
ByteSink
&
sink
UBool
strict
UErrorCode
*
status
)
{
icu
:
:
CharString
canonical
;
int32_t
reslen
;
UErrorCode
tmpStatus
=
U_ZERO_ERROR
;
UBool
hadPosix
=
false
;
const
char
*
pKeywordStart
;
int32_t
resultCapacity
=
static_cast
<
int32_t
>
(
uprv_strlen
(
localeID
)
)
;
if
(
resultCapacity
>
0
)
{
char
*
buffer
;
for
(
;
;
)
{
buffer
=
canonical
.
getAppendBuffer
(
resultCapacity
resultCapacity
resultCapacity
tmpStatus
)
;
if
(
U_FAILURE
(
tmpStatus
)
)
{
*
status
=
tmpStatus
;
return
;
}
reslen
=
uloc_canonicalize
(
localeID
buffer
resultCapacity
&
tmpStatus
)
;
if
(
tmpStatus
!
=
U_BUFFER_OVERFLOW_ERROR
)
{
break
;
}
resultCapacity
=
reslen
;
tmpStatus
=
U_ZERO_ERROR
;
}
if
(
U_FAILURE
(
tmpStatus
)
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
canonical
.
append
(
buffer
reslen
tmpStatus
)
;
if
(
tmpStatus
=
=
U_STRING_NOT_TERMINATED_WARNING
)
{
tmpStatus
=
U_ZERO_ERROR
;
}
if
(
U_FAILURE
(
tmpStatus
)
)
{
*
status
=
tmpStatus
;
return
;
}
}
pKeywordStart
=
locale_getKeywordsStart
(
canonical
.
data
(
)
)
;
if
(
pKeywordStart
=
=
canonical
.
data
(
)
)
{
int
kwdCnt
=
0
;
UBool
done
=
false
;
icu
:
:
LocalUEnumerationPointer
kwdEnum
(
uloc_openKeywords
(
canonical
.
data
(
)
&
tmpStatus
)
)
;
if
(
U_SUCCESS
(
tmpStatus
)
)
{
kwdCnt
=
uenum_count
(
kwdEnum
.
getAlias
(
)
&
tmpStatus
)
;
if
(
kwdCnt
=
=
1
)
{
const
char
*
key
;
int32_t
len
=
0
;
key
=
uenum_next
(
kwdEnum
.
getAlias
(
)
&
len
&
tmpStatus
)
;
if
(
len
=
=
1
&
&
*
key
=
=
PRIVATEUSE
)
{
icu
:
:
CharString
buf
;
{
icu
:
:
CharStringByteSink
sink
(
&
buf
)
;
ulocimp_getKeywordValue
(
localeID
key
sink
&
tmpStatus
)
;
}
if
(
U_SUCCESS
(
tmpStatus
)
)
{
if
(
ultag_isPrivateuseValueSubtags
(
buf
.
data
(
)
buf
.
length
(
)
)
)
{
sink
.
Append
(
"
und
-
x
-
"
6
)
;
sink
.
Append
(
buf
.
data
(
)
buf
.
length
(
)
)
;
done
=
true
;
}
else
if
(
strict
)
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
done
=
true
;
}
}
else
{
*
status
=
U_ILLEGAL_ARGUMENT_ERROR
;
done
=
true
;
}
}
}
if
(
done
)
{
return
;
}
}
}
_appendLanguageToLanguageTag
(
canonical
.
data
(
)
sink
strict
status
)
;
_appendScriptToLanguageTag
(
canonical
.
data
(
)
sink
strict
status
)
;
_appendRegionToLanguageTag
(
canonical
.
data
(
)
sink
strict
status
)
;
_appendVariantsToLanguageTag
(
canonical
.
data
(
)
sink
strict
&
hadPosix
status
)
;
_appendKeywordsToLanguageTag
(
canonical
.
data
(
)
sink
strict
hadPosix
status
)
;
_appendPrivateuseToLanguageTag
(
canonical
.
data
(
)
sink
strict
hadPosix
status
)
;
}
U_CAPI
int32_t
U_EXPORT2
uloc_forLanguageTag
(
const
char
*
langtag
char
*
localeID
int32_t
localeIDCapacity
int32_t
*
parsedLength
UErrorCode
*
status
)
{
if
(
U_FAILURE
(
*
status
)
)
{
return
0
;
}
icu
:
:
CheckedArrayByteSink
sink
(
localeID
localeIDCapacity
)
;
ulocimp_forLanguageTag
(
langtag
-
1
sink
parsedLength
status
)
;
int32_t
reslen
=
sink
.
NumberOfBytesAppended
(
)
;
if
(
U_FAILURE
(
*
status
)
)
{
return
reslen
;
}
if
(
sink
.
Overflowed
(
)
)
{
*
status
=
U_BUFFER_OVERFLOW_ERROR
;
}
else
{
u_terminateChars
(
localeID
localeIDCapacity
reslen
status
)
;
}
return
reslen
;
}
U_CAPI
void
U_EXPORT2
ulocimp_forLanguageTag
(
const
char
*
langtag
int32_t
tagLen
icu
:
:
ByteSink
&
sink
int32_t
*
parsedLength
UErrorCode
*
status
)
{
UBool
isEmpty
=
true
;
const
char
*
subtag
*
p
;
int32_t
len
;
int32_t
i
n
;
UBool
noRegion
=
true
;
icu
:
:
LocalULanguageTagPointer
lt
(
ultag_parse
(
langtag
tagLen
parsedLength
status
)
)
;
if
(
U_FAILURE
(
*
status
)
)
{
return
;
}
subtag
=
ultag_getExtlangSize
(
lt
.
getAlias
(
)
)
>
0
?
ultag_getExtlang
(
lt
.
getAlias
(
)
0
)
:
ultag_getLanguage
(
lt
.
getAlias
(
)
)
;
if
(
uprv_compareInvCharsAsAscii
(
subtag
LANG_UND
)
!
=
0
)
{
len
=
(
int32_t
)
uprv_strlen
(
subtag
)
;
if
(
len
>
0
)
{
sink
.
Append
(
subtag
len
)
;
isEmpty
=
false
;
}
}
subtag
=
ultag_getScript
(
lt
.
getAlias
(
)
)
;
len
=
(
int32_t
)
uprv_strlen
(
subtag
)
;
if
(
len
>
0
)
{
sink
.
Append
(
"
_
"
1
)
;
isEmpty
=
false
;
char
c
=
uprv_toupper
(
*
subtag
)
;
sink
.
Append
(
&
c
1
)
;
sink
.
Append
(
subtag
+
1
len
-
1
)
;
}
subtag
=
ultag_getRegion
(
lt
.
getAlias
(
)
)
;
len
=
(
int32_t
)
uprv_strlen
(
subtag
)
;
if
(
len
>
0
)
{
sink
.
Append
(
"
_
"
1
)
;
isEmpty
=
false
;
p
=
subtag
;
while
(
*
p
)
{
char
c
=
uprv_toupper
(
*
p
)
;
sink
.
Append
(
&
c
1
)
;
p
+
+
;
}
noRegion
=
false
;
}
_sortVariants
(
lt
.
getAlias
(
)
-
>
variants
)
;
n
=
ultag_getVariantsSize
(
lt
.
getAlias
(
)
)
;
if
(
n
>
0
)
{
if
(
noRegion
)
{
sink
.
Append
(
"
_
"
1
)
;
isEmpty
=
false
;
}
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
subtag
=
ultag_getVariant
(
lt
.
getAlias
(
)
i
)
;
sink
.
Append
(
"
_
"
1
)
;
p
=
subtag
;
while
(
*
p
)
{
char
c
=
uprv_toupper
(
*
p
)
;
sink
.
Append
(
&
c
1
)
;
p
+
+
;
}
}
}
n
=
ultag_getExtensionsSize
(
lt
.
getAlias
(
)
)
;
subtag
=
ultag_getPrivateUse
(
lt
.
getAlias
(
)
)
;
if
(
n
>
0
|
|
uprv_strlen
(
subtag
)
>
0
)
{
if
(
isEmpty
&
&
n
>
0
)
{
sink
.
Append
(
LANG_UND
LANG_UND_LEN
)
;
}
_appendKeywords
(
lt
.
getAlias
(
)
sink
status
)
;
}
}
