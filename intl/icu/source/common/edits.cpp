#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
edits
.
h
"
#
include
"
cmemory
.
h
"
#
include
"
uassert
.
h
"
U_NAMESPACE_BEGIN
namespace
{
const
int32_t
MAX_UNCHANGED_LENGTH
=
0x1000
;
const
int32_t
MAX_UNCHANGED
=
MAX_UNCHANGED_LENGTH
-
1
;
const
int32_t
MAX_SHORT_WIDTH
=
6
;
const
int32_t
MAX_SHORT_CHANGE_LENGTH
=
0xfff
;
const
int32_t
MAX_SHORT_CHANGE
=
0x6fff
;
const
int32_t
LENGTH_IN_1TRAIL
=
61
;
const
int32_t
LENGTH_IN_2TRAIL
=
62
;
}
Edits
:
:
~
Edits
(
)
{
if
(
array
!
=
stackArray
)
{
uprv_free
(
array
)
;
}
}
void
Edits
:
:
reset
(
)
{
length
=
delta
=
0
;
}
void
Edits
:
:
addUnchanged
(
int32_t
unchangedLength
)
{
if
(
U_FAILURE
(
errorCode
)
|
|
unchangedLength
=
=
0
)
{
return
;
}
if
(
unchangedLength
<
0
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
int32_t
last
=
lastUnit
(
)
;
if
(
last
<
MAX_UNCHANGED
)
{
int32_t
remaining
=
MAX_UNCHANGED
-
last
;
if
(
remaining
>
=
unchangedLength
)
{
setLastUnit
(
last
+
unchangedLength
)
;
return
;
}
setLastUnit
(
MAX_UNCHANGED
)
;
unchangedLength
-
=
remaining
;
}
while
(
unchangedLength
>
=
MAX_UNCHANGED_LENGTH
)
{
append
(
MAX_UNCHANGED
)
;
unchangedLength
-
=
MAX_UNCHANGED_LENGTH
;
}
if
(
unchangedLength
>
0
)
{
append
(
unchangedLength
-
1
)
;
}
}
void
Edits
:
:
addReplace
(
int32_t
oldLength
int32_t
newLength
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
;
}
if
(
oldLength
=
=
newLength
&
&
0
<
oldLength
&
&
oldLength
<
=
MAX_SHORT_WIDTH
)
{
int32_t
last
=
lastUnit
(
)
;
if
(
MAX_UNCHANGED
<
last
&
&
last
<
MAX_SHORT_CHANGE
&
&
(
last
>
>
12
)
=
=
oldLength
&
&
(
last
&
0xfff
)
<
MAX_SHORT_CHANGE_LENGTH
)
{
setLastUnit
(
last
+
1
)
;
return
;
}
append
(
oldLength
<
<
12
)
;
return
;
}
if
(
oldLength
<
0
|
|
newLength
<
0
)
{
errorCode
=
U_ILLEGAL_ARGUMENT_ERROR
;
return
;
}
if
(
oldLength
=
=
0
&
&
newLength
=
=
0
)
{
return
;
}
int32_t
newDelta
=
newLength
-
oldLength
;
if
(
newDelta
!
=
0
)
{
if
(
(
newDelta
>
0
&
&
delta
>
=
0
&
&
newDelta
>
(
INT32_MAX
-
delta
)
)
|
|
(
newDelta
<
0
&
&
delta
<
0
&
&
newDelta
<
(
INT32_MIN
-
delta
)
)
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
;
}
delta
+
=
newDelta
;
}
int32_t
head
=
0x7000
;
if
(
oldLength
<
LENGTH_IN_1TRAIL
&
&
newLength
<
LENGTH_IN_1TRAIL
)
{
head
|
=
oldLength
<
<
6
;
head
|
=
newLength
;
append
(
head
)
;
}
else
if
(
(
capacity
-
length
)
>
=
5
|
|
growArray
(
)
)
{
int32_t
limit
=
length
+
1
;
if
(
oldLength
<
LENGTH_IN_1TRAIL
)
{
head
|
=
oldLength
<
<
6
;
}
else
if
(
oldLength
<
=
0x7fff
)
{
head
|
=
LENGTH_IN_1TRAIL
<
<
6
;
array
[
limit
+
+
]
=
(
uint16_t
)
(
0x8000
|
oldLength
)
;
}
else
{
head
|
=
(
LENGTH_IN_2TRAIL
+
(
oldLength
>
>
30
)
)
<
<
6
;
array
[
limit
+
+
]
=
(
uint16_t
)
(
0x8000
|
(
oldLength
>
>
15
)
)
;
array
[
limit
+
+
]
=
(
uint16_t
)
(
0x8000
|
oldLength
)
;
}
if
(
newLength
<
LENGTH_IN_1TRAIL
)
{
head
|
=
newLength
;
}
else
if
(
newLength
<
=
0x7fff
)
{
head
|
=
LENGTH_IN_1TRAIL
;
array
[
limit
+
+
]
=
(
uint16_t
)
(
0x8000
|
newLength
)
;
}
else
{
head
|
=
LENGTH_IN_2TRAIL
+
(
newLength
>
>
30
)
;
array
[
limit
+
+
]
=
(
uint16_t
)
(
0x8000
|
(
newLength
>
>
15
)
)
;
array
[
limit
+
+
]
=
(
uint16_t
)
(
0x8000
|
newLength
)
;
}
array
[
length
]
=
(
uint16_t
)
head
;
length
=
limit
;
}
}
void
Edits
:
:
append
(
int32_t
r
)
{
if
(
length
<
capacity
|
|
growArray
(
)
)
{
array
[
length
+
+
]
=
(
uint16_t
)
r
;
}
}
UBool
Edits
:
:
growArray
(
)
{
int32_t
newCapacity
;
if
(
array
=
=
stackArray
)
{
newCapacity
=
2000
;
}
else
if
(
capacity
=
=
INT32_MAX
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
FALSE
;
}
else
if
(
capacity
>
=
(
INT32_MAX
/
2
)
)
{
newCapacity
=
INT32_MAX
;
}
else
{
newCapacity
=
2
*
capacity
;
}
if
(
(
newCapacity
-
capacity
)
<
5
)
{
errorCode
=
U_INDEX_OUTOFBOUNDS_ERROR
;
return
FALSE
;
}
uint16_t
*
newArray
=
(
uint16_t
*
)
uprv_malloc
(
(
size_t
)
newCapacity
*
2
)
;
if
(
newArray
=
=
NULL
)
{
errorCode
=
U_MEMORY_ALLOCATION_ERROR
;
return
FALSE
;
}
uprv_memcpy
(
newArray
array
(
size_t
)
length
*
2
)
;
if
(
array
!
=
stackArray
)
{
uprv_free
(
array
)
;
}
array
=
newArray
;
capacity
=
newCapacity
;
return
TRUE
;
}
UBool
Edits
:
:
copyErrorTo
(
UErrorCode
&
outErrorCode
)
{
if
(
U_FAILURE
(
outErrorCode
)
)
{
return
TRUE
;
}
if
(
U_SUCCESS
(
errorCode
)
)
{
return
FALSE
;
}
outErrorCode
=
errorCode
;
return
TRUE
;
}
UBool
Edits
:
:
hasChanges
(
)
const
{
if
(
delta
!
=
0
)
{
return
TRUE
;
}
for
(
int32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
array
[
i
]
>
MAX_UNCHANGED
)
{
return
TRUE
;
}
}
return
FALSE
;
}
Edits
:
:
Iterator
:
:
Iterator
(
const
uint16_t
*
a
int32_t
len
UBool
oc
UBool
crs
)
:
array
(
a
)
index
(
0
)
length
(
len
)
remaining
(
0
)
onlyChanges_
(
oc
)
coarse
(
crs
)
changed
(
FALSE
)
oldLength_
(
0
)
newLength_
(
0
)
srcIndex
(
0
)
replIndex
(
0
)
destIndex
(
0
)
{
}
int32_t
Edits
:
:
Iterator
:
:
readLength
(
int32_t
head
)
{
if
(
head
<
LENGTH_IN_1TRAIL
)
{
return
head
;
}
else
if
(
head
<
LENGTH_IN_2TRAIL
)
{
U_ASSERT
(
index
<
length
)
;
U_ASSERT
(
array
[
index
]
>
=
0x8000
)
;
return
array
[
index
+
+
]
&
0x7fff
;
}
else
{
U_ASSERT
(
(
index
+
2
)
<
=
length
)
;
U_ASSERT
(
array
[
index
]
>
=
0x8000
)
;
U_ASSERT
(
array
[
index
+
1
]
>
=
0x8000
)
;
int32_t
len
=
(
(
head
&
1
)
<
<
30
)
|
(
(
int32_t
)
(
array
[
index
]
&
0x7fff
)
<
<
15
)
|
(
array
[
index
+
1
]
&
0x7fff
)
;
index
+
=
2
;
return
len
;
}
}
void
Edits
:
:
Iterator
:
:
updateIndexes
(
)
{
srcIndex
+
=
oldLength_
;
if
(
changed
)
{
replIndex
+
=
newLength_
;
}
destIndex
+
=
newLength_
;
}
UBool
Edits
:
:
Iterator
:
:
noNext
(
)
{
changed
=
FALSE
;
oldLength_
=
newLength_
=
0
;
return
FALSE
;
}
UBool
Edits
:
:
Iterator
:
:
next
(
UBool
onlyChanges
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
)
{
return
FALSE
;
}
updateIndexes
(
)
;
if
(
remaining
>
0
)
{
-
-
remaining
;
return
TRUE
;
}
if
(
index
>
=
length
)
{
return
noNext
(
)
;
}
int32_t
u
=
array
[
index
+
+
]
;
if
(
u
<
=
MAX_UNCHANGED
)
{
changed
=
FALSE
;
oldLength_
=
u
+
1
;
while
(
index
<
length
&
&
(
u
=
array
[
index
]
)
<
=
MAX_UNCHANGED
)
{
+
+
index
;
oldLength_
+
=
u
+
1
;
}
newLength_
=
oldLength_
;
if
(
onlyChanges
)
{
updateIndexes
(
)
;
if
(
index
>
=
length
)
{
return
noNext
(
)
;
}
+
+
index
;
}
else
{
return
TRUE
;
}
}
changed
=
TRUE
;
if
(
u
<
=
MAX_SHORT_CHANGE
)
{
if
(
coarse
)
{
int32_t
w
=
u
>
>
12
;
int32_t
len
=
(
u
&
0xfff
)
+
1
;
oldLength_
=
newLength_
=
len
*
w
;
}
else
{
oldLength_
=
newLength_
=
u
>
>
12
;
remaining
=
u
&
0xfff
;
return
TRUE
;
}
}
else
{
U_ASSERT
(
u
<
=
0x7fff
)
;
oldLength_
=
readLength
(
(
u
>
>
6
)
&
0x3f
)
;
newLength_
=
readLength
(
u
&
0x3f
)
;
if
(
!
coarse
)
{
return
TRUE
;
}
}
while
(
index
<
length
&
&
(
u
=
array
[
index
]
)
>
MAX_UNCHANGED
)
{
+
+
index
;
if
(
u
<
=
MAX_SHORT_CHANGE
)
{
int32_t
w
=
u
>
>
12
;
int32_t
len
=
(
u
&
0xfff
)
+
1
;
len
=
len
*
w
;
oldLength_
+
=
len
;
newLength_
+
=
len
;
}
else
{
U_ASSERT
(
u
<
=
0x7fff
)
;
int32_t
oldLen
=
readLength
(
(
u
>
>
6
)
&
0x3f
)
;
int32_t
newLen
=
readLength
(
u
&
0x3f
)
;
oldLength_
+
=
oldLen
;
newLength_
+
=
newLen
;
}
}
return
TRUE
;
}
UBool
Edits
:
:
Iterator
:
:
findSourceIndex
(
int32_t
i
UErrorCode
&
errorCode
)
{
if
(
U_FAILURE
(
errorCode
)
|
|
i
<
0
)
{
return
FALSE
;
}
if
(
i
<
srcIndex
)
{
index
=
remaining
=
oldLength_
=
newLength_
=
srcIndex
=
replIndex
=
destIndex
=
0
;
}
else
if
(
i
<
(
srcIndex
+
oldLength_
)
)
{
return
TRUE
;
}
while
(
next
(
FALSE
errorCode
)
)
{
if
(
i
<
(
srcIndex
+
oldLength_
)
)
{
return
TRUE
;
}
if
(
remaining
>
0
)
{
int32_t
len
=
(
remaining
+
1
)
*
oldLength_
;
if
(
i
<
(
srcIndex
+
len
)
)
{
int32_t
n
=
(
i
-
srcIndex
)
/
oldLength_
;
len
=
n
*
oldLength_
;
srcIndex
+
=
len
;
replIndex
+
=
len
;
destIndex
+
=
len
;
remaining
-
=
n
;
return
TRUE
;
}
oldLength_
=
newLength_
=
len
;
remaining
=
0
;
}
}
return
FALSE
;
}
U_NAMESPACE_END
