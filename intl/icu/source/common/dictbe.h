#
ifndef
DICTBE_H
#
define
DICTBE_H
#
include
"
unicode
/
utypes
.
h
"
#
include
"
unicode
/
uniset
.
h
"
#
include
"
unicode
/
utext
.
h
"
#
include
"
brkeng
.
h
"
#
include
"
hash
.
h
"
#
include
"
mlbe
.
h
"
#
include
"
uvectr32
.
h
"
U_NAMESPACE_BEGIN
class
DictionaryMatcher
;
class
MlBreakEngine
;
class
Normalizer2
;
class
DictionaryBreakEngine
:
public
LanguageBreakEngine
{
private
:
UnicodeSet
fSet
;
public
:
DictionaryBreakEngine
(
)
;
virtual
~
DictionaryBreakEngine
(
)
;
virtual
UBool
handles
(
UChar32
c
)
const
override
;
virtual
int32_t
findBreaks
(
UText
*
text
int32_t
startPos
int32_t
endPos
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
override
;
protected
:
virtual
void
setCharacters
(
const
UnicodeSet
&
set
)
;
virtual
int32_t
divideUpDictionaryRange
(
UText
*
text
int32_t
rangeStart
int32_t
rangeEnd
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
=
0
;
}
;
class
ThaiBreakEngine
:
public
DictionaryBreakEngine
{
private
:
UnicodeSet
fEndWordSet
;
UnicodeSet
fBeginWordSet
;
UnicodeSet
fSuffixSet
;
UnicodeSet
fMarkSet
;
DictionaryMatcher
*
fDictionary
;
public
:
ThaiBreakEngine
(
DictionaryMatcher
*
adoptDictionary
UErrorCode
&
status
)
;
virtual
~
ThaiBreakEngine
(
)
;
protected
:
virtual
int32_t
divideUpDictionaryRange
(
UText
*
text
int32_t
rangeStart
int32_t
rangeEnd
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
override
;
}
;
class
LaoBreakEngine
:
public
DictionaryBreakEngine
{
private
:
UnicodeSet
fEndWordSet
;
UnicodeSet
fBeginWordSet
;
UnicodeSet
fMarkSet
;
DictionaryMatcher
*
fDictionary
;
public
:
LaoBreakEngine
(
DictionaryMatcher
*
adoptDictionary
UErrorCode
&
status
)
;
virtual
~
LaoBreakEngine
(
)
;
protected
:
virtual
int32_t
divideUpDictionaryRange
(
UText
*
text
int32_t
rangeStart
int32_t
rangeEnd
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
override
;
}
;
class
BurmeseBreakEngine
:
public
DictionaryBreakEngine
{
private
:
UnicodeSet
fEndWordSet
;
UnicodeSet
fBeginWordSet
;
UnicodeSet
fMarkSet
;
DictionaryMatcher
*
fDictionary
;
public
:
BurmeseBreakEngine
(
DictionaryMatcher
*
adoptDictionary
UErrorCode
&
status
)
;
virtual
~
BurmeseBreakEngine
(
)
;
protected
:
virtual
int32_t
divideUpDictionaryRange
(
UText
*
text
int32_t
rangeStart
int32_t
rangeEnd
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
override
;
}
;
class
KhmerBreakEngine
:
public
DictionaryBreakEngine
{
private
:
UnicodeSet
fEndWordSet
;
UnicodeSet
fBeginWordSet
;
UnicodeSet
fMarkSet
;
DictionaryMatcher
*
fDictionary
;
public
:
KhmerBreakEngine
(
DictionaryMatcher
*
adoptDictionary
UErrorCode
&
status
)
;
virtual
~
KhmerBreakEngine
(
)
;
protected
:
virtual
int32_t
divideUpDictionaryRange
(
UText
*
text
int32_t
rangeStart
int32_t
rangeEnd
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
override
;
}
;
#
if
!
UCONFIG_NO_NORMALIZATION
enum
LanguageType
{
kKorean
kChineseJapanese
}
;
class
CjkBreakEngine
:
public
DictionaryBreakEngine
{
protected
:
UnicodeSet
fHangulWordSet
;
UnicodeSet
fDigitOrOpenPunctuationOrAlphabetSet
;
UnicodeSet
fClosePunctuationSet
;
DictionaryMatcher
*
fDictionary
;
const
Normalizer2
*
nfkcNorm2
;
MlBreakEngine
*
fMlBreakEngine
;
bool
isCj
;
private
:
void
loadJapaneseExtensions
(
UErrorCode
&
error
)
;
void
loadHiragana
(
UErrorCode
&
error
)
;
void
initJapanesePhraseParameter
(
UErrorCode
&
error
)
;
Hashtable
fSkipSet
;
public
:
CjkBreakEngine
(
DictionaryMatcher
*
adoptDictionary
LanguageType
type
UErrorCode
&
status
)
;
virtual
~
CjkBreakEngine
(
)
;
protected
:
virtual
int32_t
divideUpDictionaryRange
(
UText
*
text
int32_t
rangeStart
int32_t
rangeEnd
UVector32
&
foundBreaks
UBool
isPhraseBreaking
UErrorCode
&
status
)
const
override
;
}
;
#
endif
U_NAMESPACE_END
#
endif
