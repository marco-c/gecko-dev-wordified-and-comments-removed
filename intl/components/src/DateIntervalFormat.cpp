#
include
"
unicode
/
udateintervalformat
.
h
"
#
include
"
ScopedICUObject
.
h
"
#
include
"
mozilla
/
intl
/
Calendar
.
h
"
#
include
"
mozilla
/
intl
/
DateIntervalFormat
.
h
"
namespace
mozilla
:
:
intl
{
static
ICUResult
DateFieldsPracticallyEqual
(
const
AutoFormattedDateInterval
&
aFormatted
bool
*
aEqual
)
{
const
UFormattedValue
*
formattedValue
=
aFormatted
.
Value
(
)
;
if
(
!
formattedValue
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
MOZ_ASSERT
(
aEqual
)
;
*
aEqual
=
false
;
UErrorCode
status
=
U_ZERO_ERROR
;
UConstrainedFieldPosition
*
fpos
=
ucfpos_open
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
ScopedICUObject
<
UConstrainedFieldPosition
ucfpos_close
>
toCloseFpos
(
fpos
)
;
ucfpos_constrainCategory
(
fpos
UFIELD_CATEGORY_DATE_INTERVAL_SPAN
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
bool
hasSpan
=
ufmtval_nextPosition
(
formattedValue
fpos
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
*
aEqual
=
!
hasSpan
;
return
Ok
(
)
;
}
Result
<
UniquePtr
<
DateIntervalFormat
>
ICUError
>
DateIntervalFormat
:
:
TryCreate
(
Span
<
const
char
>
aLocale
Span
<
const
char16_t
>
aSkeleton
Span
<
const
char16_t
>
aTimeZone
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UDateIntervalFormat
*
dif
=
udtitvfmt_open
(
IcuLocale
(
AssertNullTerminatedString
(
aLocale
)
)
aSkeleton
.
data
(
)
AssertedCast
<
int32_t
>
(
aSkeleton
.
size
(
)
)
aTimeZone
.
data
(
)
AssertedCast
<
int32_t
>
(
aTimeZone
.
size
(
)
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
return
UniquePtr
<
DateIntervalFormat
>
(
new
DateIntervalFormat
(
dif
)
)
;
}
DateIntervalFormat
:
:
~
DateIntervalFormat
(
)
{
MOZ_ASSERT
(
mDateIntervalFormat
)
;
udtitvfmt_close
(
mDateIntervalFormat
.
GetMut
(
)
)
;
}
AutoFormattedDateInterval
:
:
AutoFormattedDateInterval
(
)
{
mFormatted
=
udtitvfmt_openResult
(
&
mError
)
;
if
(
U_FAILURE
(
mError
)
)
{
mFormatted
=
nullptr
;
}
}
const
UFormattedValue
*
AutoFormattedDateInterval
:
:
Value
(
)
const
{
if
(
!
IsValid
(
)
)
{
return
nullptr
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
const
UFormattedValue
*
value
=
udtitvfmt_resultAsValue
(
mFormatted
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
nullptr
;
}
return
value
;
}
Result
<
Span
<
const
char16_t
>
ICUError
>
AutoFormattedDateInterval
:
:
ToSpan
(
)
const
{
if
(
!
IsValid
(
)
)
{
return
Err
(
GetError
(
)
)
;
}
const
UFormattedValue
*
value
=
Value
(
)
;
if
(
!
value
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
strLength
;
const
char16_t
*
str
=
ufmtval_getString
(
value
&
strLength
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
return
Span
{
str
AssertedCast
<
size_t
>
(
strLength
)
}
;
}
AutoFormattedDateInterval
:
:
~
AutoFormattedDateInterval
(
)
{
if
(
mFormatted
)
{
udtitvfmt_closeResult
(
mFormatted
)
;
}
}
ICUResult
DateIntervalFormat
:
:
TryFormatCalendar
(
const
Calendar
&
aStart
const
Calendar
&
aEnd
AutoFormattedDateInterval
&
aFormatted
bool
*
aPracticallyEqual
)
const
{
MOZ_ASSERT
(
aFormatted
.
IsValid
(
)
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
udtitvfmt_formatCalendarToResult
(
mDateIntervalFormat
.
GetConst
(
)
aStart
.
GetUCalendar
(
)
aEnd
.
GetUCalendar
(
)
aFormatted
.
GetUFormattedDateInterval
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
MOZ_TRY
(
DateFieldsPracticallyEqual
(
aFormatted
aPracticallyEqual
)
)
;
return
Ok
(
)
;
}
ICUResult
DateIntervalFormat
:
:
TryFormatDateTime
(
double
aStart
double
aEnd
AutoFormattedDateInterval
&
aFormatted
bool
*
aPracticallyEqual
)
const
{
MOZ_ASSERT
(
aFormatted
.
IsValid
(
)
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
udtitvfmt_formatToResult
(
mDateIntervalFormat
.
GetConst
(
)
aStart
aEnd
aFormatted
.
GetUFormattedDateInterval
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
MOZ_TRY
(
DateFieldsPracticallyEqual
(
aFormatted
aPracticallyEqual
)
)
;
return
Ok
(
)
;
}
}
