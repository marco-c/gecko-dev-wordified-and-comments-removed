#
include
"
DateTimeFormat
.
h
"
#
include
"
DateTimeFormatUtils
.
h
"
#
include
"
ScopedICUObject
.
h
"
#
include
"
mozilla
/
intl
/
Calendar
.
h
"
#
include
"
mozilla
/
intl
/
DateIntervalFormat
.
h
"
namespace
mozilla
:
:
intl
{
static
ICUResult
DateFieldsPracticallyEqual
(
const
UFormattedValue
*
aFormattedValue
bool
*
aEqual
)
{
if
(
!
aFormattedValue
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
MOZ_ASSERT
(
aEqual
)
;
*
aEqual
=
false
;
UErrorCode
status
=
U_ZERO_ERROR
;
UConstrainedFieldPosition
*
fpos
=
ucfpos_open
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
ScopedICUObject
<
UConstrainedFieldPosition
ucfpos_close
>
toCloseFpos
(
fpos
)
;
ucfpos_constrainCategory
(
fpos
UFIELD_CATEGORY_DATE_INTERVAL_SPAN
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
bool
hasSpan
=
ufmtval_nextPosition
(
aFormattedValue
fpos
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
*
aEqual
=
!
hasSpan
;
return
Ok
(
)
;
}
Result
<
UniquePtr
<
DateIntervalFormat
>
ICUError
>
DateIntervalFormat
:
:
TryCreate
(
Span
<
const
char
>
aLocale
Span
<
const
char16_t
>
aSkeleton
Span
<
const
char16_t
>
aTimeZone
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UDateIntervalFormat
*
dif
=
udtitvfmt_open
(
IcuLocale
(
aLocale
)
aSkeleton
.
data
(
)
AssertedCast
<
int32_t
>
(
aSkeleton
.
size
(
)
)
aTimeZone
.
data
(
)
AssertedCast
<
int32_t
>
(
aTimeZone
.
size
(
)
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
return
UniquePtr
<
DateIntervalFormat
>
(
new
DateIntervalFormat
(
dif
)
)
;
}
DateIntervalFormat
:
:
~
DateIntervalFormat
(
)
{
MOZ_ASSERT
(
mDateIntervalFormat
)
;
udtitvfmt_close
(
mDateIntervalFormat
.
GetMut
(
)
)
;
}
#
if
DATE_TIME_FORMAT_REPLACE_SPECIAL_SPACES
static
void
ReplaceSpecialSpaces
(
const
UFormattedValue
*
aValue
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
len
;
const
UChar
*
str
=
ufmtval_getString
(
aValue
&
len
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
;
}
for
(
const
auto
&
c
:
Span
(
str
len
)
)
{
if
(
IsSpecialSpace
(
c
)
)
{
const_cast
<
UChar
&
>
(
c
)
=
'
'
;
}
}
}
#
endif
ICUResult
DateIntervalFormat
:
:
TryFormatCalendar
(
const
Calendar
&
aStart
const
Calendar
&
aEnd
AutoFormattedDateInterval
&
aFormatted
bool
*
aPracticallyEqual
)
const
{
MOZ_ASSERT
(
aFormatted
.
IsValid
(
)
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
udtitvfmt_formatCalendarToResult
(
mDateIntervalFormat
.
GetConst
(
)
aStart
.
GetUCalendar
(
)
aEnd
.
GetUCalendar
(
)
aFormatted
.
GetFormatted
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
#
if
DATE_TIME_FORMAT_REPLACE_SPECIAL_SPACES
ReplaceSpecialSpaces
(
aFormatted
.
Value
(
)
)
;
#
endif
MOZ_TRY
(
DateFieldsPracticallyEqual
(
aFormatted
.
Value
(
)
aPracticallyEqual
)
)
;
return
Ok
(
)
;
}
ICUResult
DateIntervalFormat
:
:
TryFormatDateTime
(
double
aStart
double
aEnd
AutoFormattedDateInterval
&
aFormatted
bool
*
aPracticallyEqual
)
const
{
MOZ_ASSERT
(
aFormatted
.
IsValid
(
)
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
udtitvfmt_formatToResult
(
mDateIntervalFormat
.
GetConst
(
)
aStart
aEnd
aFormatted
.
GetFormatted
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
#
if
DATE_TIME_FORMAT_REPLACE_SPECIAL_SPACES
ReplaceSpecialSpaces
(
aFormatted
.
Value
(
)
)
;
#
endif
MOZ_TRY
(
DateFieldsPracticallyEqual
(
aFormatted
.
Value
(
)
aPracticallyEqual
)
)
;
return
Ok
(
)
;
}
ICUResult
DateIntervalFormat
:
:
TryFormattedToParts
(
const
AutoFormattedDateInterval
&
aFormatted
DateTimePartVector
&
aParts
)
const
{
MOZ_ASSERT
(
aFormatted
.
IsValid
(
)
)
;
const
UFormattedValue
*
value
=
aFormatted
.
Value
(
)
;
if
(
!
value
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
size_t
lastEndIndex
=
0
;
auto
AppendPart
=
[
&
]
(
DateTimePartType
type
size_t
endIndex
DateTimePartSource
source
)
{
if
(
!
aParts
.
emplaceBack
(
type
endIndex
source
)
)
{
return
false
;
}
lastEndIndex
=
endIndex
;
return
true
;
}
;
UErrorCode
status
=
U_ZERO_ERROR
;
UConstrainedFieldPosition
*
fpos
=
ucfpos_open
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
ScopedICUObject
<
UConstrainedFieldPosition
ucfpos_close
>
toCloseFpos
(
fpos
)
;
size_t
categoryEndIndex
=
0
;
DateTimePartSource
source
=
DateTimePartSource
:
:
Shared
;
while
(
true
)
{
bool
hasMore
=
ufmtval_nextPosition
(
value
fpos
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
if
(
!
hasMore
)
{
break
;
}
int32_t
category
=
ucfpos_getCategory
(
fpos
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
int32_t
field
=
ucfpos_getField
(
fpos
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
int32_t
beginIndexInt
endIndexInt
;
ucfpos_getIndexes
(
fpos
&
beginIndexInt
&
endIndexInt
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
MOZ_ASSERT
(
beginIndexInt
<
=
endIndexInt
"
field
iterator
returning
invalid
range
"
)
;
size_t
beginIndex
=
AssertedCast
<
size_t
>
(
beginIndexInt
)
;
size_t
endIndex
=
AssertedCast
<
size_t
>
(
endIndexInt
)
;
MOZ_ASSERT
(
lastEndIndex
<
=
beginIndex
"
field
iteration
didn
'
t
return
fields
in
order
start
to
"
"
finish
as
expected
"
)
;
if
(
category
=
=
UFIELD_CATEGORY_DATE_INTERVAL_SPAN
)
{
if
(
lastEndIndex
<
beginIndex
)
{
if
(
!
AppendPart
(
DateTimePartType
:
:
Literal
beginIndex
source
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
}
MOZ_ASSERT
(
field
=
=
0
|
|
field
=
=
1
"
span
category
has
unexpected
value
"
)
;
source
=
field
=
=
0
?
DateTimePartSource
:
:
StartRange
:
DateTimePartSource
:
:
EndRange
;
categoryEndIndex
=
endIndex
;
continue
;
}
if
(
category
!
=
UFIELD_CATEGORY_DATE
)
{
continue
;
}
DateTimePartType
type
=
ConvertUFormatFieldToPartType
(
static_cast
<
UDateFormatField
>
(
field
)
)
;
if
(
lastEndIndex
<
beginIndex
)
{
if
(
!
AppendPart
(
DateTimePartType
:
:
Literal
beginIndex
source
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
}
if
(
!
AppendPart
(
type
endIndex
source
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
if
(
endIndex
=
=
categoryEndIndex
)
{
if
(
lastEndIndex
<
endIndex
)
{
if
(
!
AppendPart
(
DateTimePartType
:
:
Literal
endIndex
source
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
}
source
=
DateTimePartSource
:
:
Shared
;
}
}
auto
spanResult
=
aFormatted
.
ToSpan
(
)
;
if
(
spanResult
.
isErr
(
)
)
{
return
spanResult
.
propagateErr
(
)
;
}
size_t
formattedSize
=
spanResult
.
unwrap
(
)
.
size
(
)
;
if
(
lastEndIndex
<
formattedSize
)
{
if
(
!
AppendPart
(
DateTimePartType
:
:
Literal
formattedSize
source
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
}
return
Ok
(
)
;
}
}
