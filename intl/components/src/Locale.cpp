#
include
"
mozilla
/
intl
/
Locale
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
ICU4CGlue
.
h
"
#
include
<
algorithm
>
#
include
<
iterator
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
>
#
include
<
string
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
unicode
/
uloc
.
h
"
#
include
"
unicode
/
utypes
.
h
"
namespace
mozilla
:
:
intl
{
using
namespace
intl
:
:
LanguageTagLimits
;
template
<
typename
CharT
>
bool
IsStructurallyValidLanguageTag
(
Span
<
const
CharT
>
language
)
{
size_t
length
=
language
.
size
(
)
;
const
CharT
*
str
=
language
.
data
(
)
;
return
(
(
2
<
=
length
&
&
length
<
=
3
)
|
|
(
5
<
=
length
&
&
length
<
=
8
)
)
&
&
std
:
:
all_of
(
str
str
+
length
IsAsciiAlpha
<
CharT
>
)
;
}
template
bool
IsStructurallyValidLanguageTag
(
Span
<
const
char
>
language
)
;
template
bool
IsStructurallyValidLanguageTag
(
Span
<
const
Latin1Char
>
language
)
;
template
bool
IsStructurallyValidLanguageTag
(
Span
<
const
char16_t
>
language
)
;
template
<
typename
CharT
>
bool
IsStructurallyValidScriptTag
(
Span
<
const
CharT
>
script
)
{
size_t
length
=
script
.
size
(
)
;
const
CharT
*
str
=
script
.
data
(
)
;
return
length
=
=
4
&
&
std
:
:
all_of
(
str
str
+
length
IsAsciiAlpha
<
CharT
>
)
;
}
template
bool
IsStructurallyValidScriptTag
(
Span
<
const
char
>
script
)
;
template
bool
IsStructurallyValidScriptTag
(
Span
<
const
Latin1Char
>
script
)
;
template
bool
IsStructurallyValidScriptTag
(
Span
<
const
char16_t
>
script
)
;
template
<
typename
CharT
>
bool
IsStructurallyValidRegionTag
(
Span
<
const
CharT
>
region
)
{
size_t
length
=
region
.
size
(
)
;
const
CharT
*
str
=
region
.
data
(
)
;
return
(
length
=
=
2
&
&
std
:
:
all_of
(
str
str
+
length
IsAsciiAlpha
<
CharT
>
)
)
|
|
(
length
=
=
3
&
&
std
:
:
all_of
(
str
str
+
length
IsAsciiDigit
<
CharT
>
)
)
;
}
template
bool
IsStructurallyValidRegionTag
(
Span
<
const
char
>
region
)
;
template
bool
IsStructurallyValidRegionTag
(
Span
<
const
Latin1Char
>
region
)
;
template
bool
IsStructurallyValidRegionTag
(
Span
<
const
char16_t
>
region
)
;
#
ifdef
DEBUG
bool
IsStructurallyValidVariantTag
(
Span
<
const
char
>
variant
)
{
size_t
length
=
variant
.
size
(
)
;
const
char
*
str
=
variant
.
data
(
)
;
return
(
(
5
<
=
length
&
&
length
<
=
8
)
|
|
(
length
=
=
4
&
&
IsAsciiDigit
(
str
[
0
]
)
)
)
&
&
std
:
:
all_of
(
str
str
+
length
IsAsciiAlphanumeric
<
char
>
)
;
}
bool
IsStructurallyValidUnicodeExtensionTag
(
Span
<
const
char
>
extension
)
{
return
LocaleParser
:
:
canParseUnicodeExtension
(
extension
)
.
isOk
(
)
;
}
static
bool
IsStructurallyValidExtensionTag
(
Span
<
const
char
>
extension
)
{
size_t
length
=
extension
.
size
(
)
;
const
char
*
str
=
extension
.
data
(
)
;
const
char
*
const
end
=
extension
.
data
(
)
+
length
;
if
(
length
<
=
2
)
{
return
false
;
}
if
(
!
IsAsciiAlphanumeric
(
str
[
0
]
)
|
|
str
[
0
]
=
=
'
x
'
|
|
str
[
0
]
=
=
'
X
'
)
{
return
false
;
}
str
+
+
;
if
(
*
str
+
+
!
=
'
-
'
)
{
return
false
;
}
while
(
true
)
{
const
char
*
sep
=
reinterpret_cast
<
const
char
*
>
(
memchr
(
str
'
-
'
end
-
str
)
)
;
size_t
len
=
(
sep
?
sep
:
end
)
-
str
;
if
(
len
<
2
|
|
len
>
8
|
|
!
std
:
:
all_of
(
str
str
+
len
IsAsciiAlphanumeric
<
char
>
)
)
{
return
false
;
}
if
(
!
sep
)
{
return
true
;
}
str
=
sep
+
1
;
}
}
bool
IsStructurallyValidPrivateUseTag
(
Span
<
const
char
>
privateUse
)
{
size_t
length
=
privateUse
.
size
(
)
;
const
char
*
str
=
privateUse
.
data
(
)
;
const
char
*
const
end
=
privateUse
.
data
(
)
+
length
;
if
(
length
<
=
2
)
{
return
false
;
}
if
(
str
[
0
]
!
=
'
x
'
&
&
str
[
0
]
!
=
'
X
'
)
{
return
false
;
}
str
+
+
;
if
(
*
str
+
+
!
=
'
-
'
)
{
return
false
;
}
while
(
true
)
{
const
char
*
sep
=
reinterpret_cast
<
const
char
*
>
(
memchr
(
str
'
-
'
end
-
str
)
)
;
size_t
len
=
(
sep
?
sep
:
end
)
-
str
;
if
(
len
=
=
0
|
|
len
>
8
|
|
!
std
:
:
all_of
(
str
str
+
len
IsAsciiAlphanumeric
<
char
>
)
)
{
return
false
;
}
if
(
!
sep
)
{
return
true
;
}
str
=
sep
+
1
;
}
}
#
endif
ptrdiff_t
Locale
:
:
unicodeExtensionIndex
(
)
const
{
auto
p
=
std
:
:
find_if
(
extensions
(
)
.
begin
(
)
extensions
(
)
.
end
(
)
[
]
(
const
auto
&
ext
)
{
return
ext
[
0
]
=
=
'
u
'
|
|
ext
[
0
]
=
=
'
U
'
;
}
)
;
if
(
p
!
=
extensions
(
)
.
end
(
)
)
{
return
std
:
:
distance
(
extensions
(
)
.
begin
(
)
p
)
;
}
return
-
1
;
}
const
char
*
Locale
:
:
unicodeExtension
(
)
const
{
ptrdiff_t
index
=
unicodeExtensionIndex
(
)
;
if
(
index
>
=
0
)
{
return
extensions
(
)
[
index
]
.
get
(
)
;
}
return
nullptr
;
}
ICUResult
Locale
:
:
setUnicodeExtension
(
Span
<
const
char
>
extension
)
{
MOZ_ASSERT
(
IsStructurallyValidUnicodeExtensionTag
(
extension
)
)
;
auto
duplicated
=
DuplicateStringToUniqueChars
(
extension
)
;
ptrdiff_t
index
=
unicodeExtensionIndex
(
)
;
if
(
index
>
=
0
)
{
extensions_
[
index
]
=
std
:
:
move
(
duplicated
)
;
return
Ok
(
)
;
}
if
(
!
extensions_
.
append
(
std
:
:
move
(
duplicated
)
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
return
Ok
(
)
;
}
void
Locale
:
:
clearUnicodeExtension
(
)
{
ptrdiff_t
index
=
unicodeExtensionIndex
(
)
;
if
(
index
>
=
0
)
{
extensions_
.
erase
(
extensions_
.
begin
(
)
+
index
)
;
}
}
template
<
size_t
InitialCapacity
>
static
bool
SortAlphabetically
(
Vector
<
UniqueChars
InitialCapacity
>
&
subtags
)
{
size_t
length
=
subtags
.
length
(
)
;
if
(
length
<
2
)
{
return
true
;
}
if
(
length
=
=
2
)
{
if
(
strcmp
(
subtags
[
0
]
.
get
(
)
subtags
[
1
]
.
get
(
)
)
>
0
)
{
subtags
[
0
]
.
swap
(
subtags
[
1
]
)
;
}
return
true
;
}
Vector
<
char
*
8
>
scratch
;
if
(
!
scratch
.
resizeUninitialized
(
length
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
scratch
[
i
]
=
subtags
[
i
]
.
release
(
)
;
}
std
:
:
stable_sort
(
scratch
.
begin
(
)
scratch
.
end
(
)
[
]
(
const
char
*
a
const
char
*
b
)
{
return
strcmp
(
a
b
)
<
0
;
}
)
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
subtags
[
i
]
=
UniqueChars
(
scratch
[
i
]
)
;
}
return
true
;
}
Result
<
Ok
Locale
:
:
CanonicalizationError
>
Locale
:
:
canonicalizeBaseName
(
)
{
language_
.
toLowerCase
(
)
;
MOZ_ASSERT
(
IsStructurallyValidLanguageTag
(
language
(
)
.
span
(
)
)
)
;
script_
.
toTitleCase
(
)
;
MOZ_ASSERT
(
script
(
)
.
missing
(
)
|
|
IsStructurallyValidScriptTag
(
script
(
)
.
span
(
)
)
)
;
region_
.
toUpperCase
(
)
;
MOZ_ASSERT
(
region
(
)
.
missing
(
)
|
|
IsStructurallyValidRegionTag
(
region
(
)
.
span
(
)
)
)
;
for
(
UniqueChars
&
variant
:
variants_
)
{
char
*
variantChars
=
variant
.
get
(
)
;
size_t
variantLength
=
strlen
(
variantChars
)
;
AsciiToLowerCase
(
variantChars
variantLength
variantChars
)
;
MOZ_ASSERT
(
IsStructurallyValidVariantTag
(
{
variantChars
variantLength
}
)
)
;
}
if
(
variants_
.
length
(
)
>
1
)
{
if
(
!
SortAlphabetically
(
variants_
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
const
UniqueChars
*
duplicate
=
std
:
:
adjacent_find
(
variants
(
)
.
begin
(
)
variants
(
)
.
end
(
)
[
]
(
const
auto
&
a
const
auto
&
b
)
{
return
strcmp
(
a
.
get
(
)
b
.
get
(
)
)
=
=
0
;
}
)
;
if
(
duplicate
!
=
variants
(
)
.
end
(
)
)
{
return
Err
(
CanonicalizationError
:
:
DuplicateVariant
)
;
}
}
if
(
!
updateLegacyMappings
(
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
if
(
!
languageMapping
(
language_
)
&
&
complexLanguageMapping
(
language_
)
)
{
performComplexLanguageMappings
(
)
;
}
if
(
script
(
)
.
present
(
)
)
{
scriptMapping
(
script_
)
;
}
if
(
region
(
)
.
present
(
)
)
{
if
(
!
regionMapping
(
region_
)
&
&
complexRegionMapping
(
region_
)
)
{
performComplexRegionMappings
(
)
;
}
}
if
(
!
performVariantMappings
(
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
return
Ok
(
)
;
}
#
ifdef
DEBUG
static
bool
IsAsciiLowercaseAlphanumericOrDash
(
Span
<
const
char
>
span
)
{
const
char
*
ptr
=
span
.
data
(
)
;
size_t
length
=
span
.
size
(
)
;
return
std
:
:
all_of
(
ptr
ptr
+
length
[
]
(
auto
c
)
{
return
IsAsciiLowercaseAlpha
(
c
)
|
|
IsAsciiDigit
(
c
)
|
|
c
=
=
'
-
'
;
}
)
;
}
#
endif
Result
<
Ok
Locale
:
:
CanonicalizationError
>
Locale
:
:
canonicalizeExtensions
(
)
{
for
(
UniqueChars
&
extension
:
extensions_
)
{
char
*
extensionChars
=
extension
.
get
(
)
;
size_t
extensionLength
=
strlen
(
extensionChars
)
;
AsciiToLowerCase
(
extensionChars
extensionLength
extensionChars
)
;
MOZ_ASSERT
(
IsStructurallyValidExtensionTag
(
{
extensionChars
extensionLength
}
)
)
;
}
if
(
!
SortAlphabetically
(
extensions_
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
for
(
UniqueChars
&
extension
:
extensions_
)
{
if
(
extension
[
0
]
=
=
'
u
'
)
{
MOZ_TRY
(
canonicalizeUnicodeExtension
(
extension
)
)
;
}
else
if
(
extension
[
0
]
=
=
'
t
'
)
{
MOZ_TRY
(
canonicalizeTransformExtension
(
extension
)
)
;
}
MOZ_ASSERT
(
IsAsciiLowercaseAlphanumericOrDash
(
MakeStringSpan
(
extension
.
get
(
)
)
)
)
;
}
if
(
char
*
privateuse
=
privateuse_
.
get
(
)
)
{
size_t
privateuseLength
=
strlen
(
privateuse
)
;
AsciiToLowerCase
(
privateuse
privateuseLength
privateuse
)
;
MOZ_ASSERT
(
IsStructurallyValidPrivateUseTag
(
{
privateuse
privateuseLength
}
)
)
;
}
return
Ok
(
)
;
}
template
<
size_t
N
>
static
inline
bool
AppendSpan
(
Vector
<
char
N
>
&
vector
Span
<
const
char
>
span
)
{
return
vector
.
append
(
span
.
data
(
)
span
.
size
(
)
)
;
}
Result
<
Ok
Locale
:
:
CanonicalizationError
>
Locale
:
:
canonicalizeUnicodeExtension
(
UniqueChars
&
unicodeExtension
)
{
Span
<
const
char
>
extension
=
MakeStringSpan
(
unicodeExtension
.
get
(
)
)
;
MOZ_ASSERT
(
extension
[
0
]
=
=
'
u
'
)
;
MOZ_ASSERT
(
extension
[
1
]
=
=
'
-
'
)
;
MOZ_ASSERT
(
IsStructurallyValidExtensionTag
(
extension
)
)
;
LocaleParser
:
:
AttributesVector
attributes
;
LocaleParser
:
:
KeywordsVector
keywords
;
using
Attribute
=
LocaleParser
:
:
AttributesVector
:
:
ElementType
;
using
Keyword
=
LocaleParser
:
:
KeywordsVector
:
:
ElementType
;
if
(
LocaleParser
:
:
parseUnicodeExtension
(
extension
attributes
keywords
)
.
isErr
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
invalid
Unicode
extension
subtag
"
)
;
return
Err
(
CanonicalizationError
:
:
InternalError
)
;
}
auto
attributesLess
=
[
extension
]
(
const
Attribute
&
a
const
Attribute
&
b
)
{
auto
astr
=
extension
.
Subspan
(
a
.
begin
(
)
a
.
length
(
)
)
;
auto
bstr
=
extension
.
Subspan
(
b
.
begin
(
)
b
.
length
(
)
)
;
return
astr
<
bstr
;
}
;
if
(
attributes
.
length
(
)
>
1
)
{
std
:
:
stable_sort
(
attributes
.
begin
(
)
attributes
.
end
(
)
attributesLess
)
;
}
auto
keywordsLess
=
[
extension
]
(
const
Keyword
&
a
const
Keyword
&
b
)
{
auto
astr
=
extension
.
Subspan
(
a
.
begin
(
)
UnicodeKeyLength
)
;
auto
bstr
=
extension
.
Subspan
(
b
.
begin
(
)
UnicodeKeyLength
)
;
return
astr
<
bstr
;
}
;
if
(
keywords
.
length
(
)
>
1
)
{
std
:
:
stable_sort
(
keywords
.
begin
(
)
keywords
.
end
(
)
keywordsLess
)
;
}
Vector
<
char
32
>
sb
;
if
(
!
sb
.
append
(
'
u
'
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
for
(
size_t
i
=
0
;
i
<
attributes
.
length
(
)
;
i
+
+
)
{
const
auto
&
attribute
=
attributes
[
i
]
;
auto
span
=
extension
.
Subspan
(
attribute
.
begin
(
)
attribute
.
length
(
)
)
;
if
(
i
>
0
)
{
const
auto
&
lastAttribute
=
attributes
[
i
-
1
]
;
if
(
span
=
=
extension
.
Subspan
(
lastAttribute
.
begin
(
)
lastAttribute
.
length
(
)
)
)
{
continue
;
}
MOZ_ASSERT
(
attributesLess
(
lastAttribute
attribute
)
)
;
}
if
(
!
sb
.
append
(
'
-
'
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
if
(
!
AppendSpan
(
sb
span
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
}
static
constexpr
size_t
UnicodeKeyWithSepLength
=
UnicodeKeyLength
+
1
;
using
StringSpan
=
Span
<
const
char
>
;
static
constexpr
StringSpan
True
=
MakeStringSpan
(
"
true
"
)
;
for
(
size_t
i
=
0
;
i
<
keywords
.
length
(
)
;
i
+
+
)
{
const
auto
&
keyword
=
keywords
[
i
]
;
if
(
i
>
0
)
{
const
auto
&
lastKeyword
=
keywords
[
i
-
1
]
;
if
(
extension
.
Subspan
(
keyword
.
begin
(
)
UnicodeKeyLength
)
=
=
extension
.
Subspan
(
lastKeyword
.
begin
(
)
UnicodeKeyLength
)
)
{
continue
;
}
MOZ_ASSERT
(
keywordsLess
(
lastKeyword
keyword
)
)
;
}
if
(
!
sb
.
append
(
'
-
'
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
StringSpan
span
=
extension
.
Subspan
(
keyword
.
begin
(
)
keyword
.
length
(
)
)
;
if
(
span
.
size
(
)
=
=
UnicodeKeyLength
)
{
if
(
!
AppendSpan
(
sb
span
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
}
else
{
StringSpan
key
=
span
.
To
(
UnicodeKeyLength
)
;
StringSpan
type
=
span
.
From
(
UnicodeKeyWithSepLength
)
;
if
(
const
char
*
replacement
=
replaceUnicodeExtensionType
(
key
type
)
)
{
StringSpan
repl
=
MakeStringSpan
(
replacement
)
;
if
(
repl
=
=
True
)
{
if
(
!
AppendSpan
(
sb
key
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
}
else
{
if
(
!
AppendSpan
(
sb
span
.
To
(
UnicodeKeyWithSepLength
)
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
if
(
!
AppendSpan
(
sb
repl
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
}
}
else
{
if
(
type
=
=
True
)
{
if
(
!
AppendSpan
(
sb
key
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
}
else
{
if
(
!
AppendSpan
(
sb
span
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
}
}
}
}
if
(
static_cast
<
Span
<
const
char
>
>
(
sb
)
!
=
extension
)
{
if
(
!
sb
.
append
(
'
\
0
'
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
UniqueChars
canonical
(
sb
.
extractOrCopyRawBuffer
(
)
)
;
if
(
!
canonical
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
unicodeExtension
=
std
:
:
move
(
canonical
)
;
}
return
Ok
(
)
;
}
template
<
class
Buffer
>
static
bool
LocaleToString
(
const
Locale
&
tag
Buffer
&
sb
)
{
auto
appendSubtag
=
[
&
sb
]
(
const
auto
&
subtag
)
{
auto
span
=
subtag
.
span
(
)
;
MOZ_ASSERT
(
!
span
.
empty
(
)
)
;
return
sb
.
append
(
span
.
data
(
)
span
.
size
(
)
)
;
}
;
auto
appendSubtagZ
=
[
&
sb
]
(
const
char
*
subtag
)
{
MOZ_ASSERT
(
strlen
(
subtag
)
>
0
)
;
return
sb
.
append
(
subtag
strlen
(
subtag
)
)
;
}
;
auto
appendSubtagsZ
=
[
&
sb
&
appendSubtagZ
]
(
const
auto
&
subtags
)
{
for
(
const
auto
&
subtag
:
subtags
)
{
if
(
!
sb
.
append
(
'
-
'
)
|
|
!
appendSubtagZ
(
subtag
.
get
(
)
)
)
{
return
false
;
}
}
return
true
;
}
;
if
(
!
appendSubtag
(
tag
.
language
(
)
)
)
{
return
false
;
}
if
(
tag
.
script
(
)
.
present
(
)
)
{
if
(
!
sb
.
append
(
'
-
'
)
|
|
!
appendSubtag
(
tag
.
script
(
)
)
)
{
return
false
;
}
}
if
(
tag
.
region
(
)
.
present
(
)
)
{
if
(
!
sb
.
append
(
'
-
'
)
|
|
!
appendSubtag
(
tag
.
region
(
)
)
)
{
return
false
;
}
}
if
(
!
appendSubtagsZ
(
tag
.
variants
(
)
)
)
{
return
false
;
}
if
(
!
appendSubtagsZ
(
tag
.
extensions
(
)
)
)
{
return
false
;
}
if
(
tag
.
privateuse
(
)
)
{
if
(
!
sb
.
append
(
'
-
'
)
|
|
!
appendSubtagZ
(
tag
.
privateuse
(
)
)
)
{
return
false
;
}
}
return
true
;
}
Result
<
Ok
Locale
:
:
CanonicalizationError
>
Locale
:
:
canonicalizeTransformExtension
(
UniqueChars
&
transformExtension
)
{
Span
<
const
char
>
extension
=
MakeStringSpan
(
transformExtension
.
get
(
)
)
;
MOZ_ASSERT
(
extension
[
0
]
=
=
'
t
'
)
;
MOZ_ASSERT
(
extension
[
1
]
=
=
'
-
'
)
;
MOZ_ASSERT
(
IsStructurallyValidExtensionTag
(
extension
)
)
;
Locale
tag
;
LocaleParser
:
:
TFieldVector
fields
;
using
TField
=
LocaleParser
:
:
TFieldVector
:
:
ElementType
;
if
(
LocaleParser
:
:
parseTransformExtension
(
extension
tag
fields
)
.
isErr
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
invalid
transform
extension
subtag
"
)
;
return
Err
(
CanonicalizationError
:
:
InternalError
)
;
}
auto
tfieldLess
=
[
extension
]
(
const
TField
&
a
const
TField
&
b
)
{
auto
astr
=
extension
.
Subspan
(
a
.
begin
(
)
TransformKeyLength
)
;
auto
bstr
=
extension
.
Subspan
(
b
.
begin
(
)
TransformKeyLength
)
;
return
astr
<
bstr
;
}
;
if
(
fields
.
length
(
)
>
1
)
{
std
:
:
stable_sort
(
fields
.
begin
(
)
fields
.
end
(
)
tfieldLess
)
;
}
Vector
<
char
32
>
sb
;
if
(
!
sb
.
append
(
'
t
'
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
if
(
tag
.
language
(
)
.
present
(
)
)
{
if
(
!
sb
.
append
(
'
-
'
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
MOZ_TRY
(
tag
.
canonicalizeBaseName
(
)
)
;
tag
.
script_
.
toLowerCase
(
)
;
tag
.
region_
.
toLowerCase
(
)
;
if
(
!
LocaleToString
(
tag
sb
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
}
static
constexpr
size_t
TransformKeyWithSepLength
=
TransformKeyLength
+
1
;
using
StringSpan
=
Span
<
const
char
>
;
for
(
const
auto
&
field
:
fields
)
{
if
(
!
sb
.
append
(
'
-
'
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
StringSpan
span
=
extension
.
Subspan
(
field
.
begin
(
)
field
.
length
(
)
)
;
StringSpan
key
=
span
.
To
(
TransformKeyLength
)
;
StringSpan
value
=
span
.
From
(
TransformKeyWithSepLength
)
;
if
(
const
char
*
replacement
=
replaceTransformExtensionType
(
key
value
)
)
{
if
(
!
AppendSpan
(
sb
span
.
To
(
TransformKeyWithSepLength
)
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
if
(
!
AppendSpan
(
sb
MakeStringSpan
(
replacement
)
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
}
else
{
if
(
!
AppendSpan
(
sb
span
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
}
}
if
(
static_cast
<
Span
<
const
char
>
>
(
sb
)
!
=
extension
)
{
if
(
!
sb
.
append
(
'
\
0
'
)
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
UniqueChars
canonical
(
sb
.
extractOrCopyRawBuffer
(
)
)
;
if
(
!
canonical
)
{
return
Err
(
CanonicalizationError
:
:
OutOfMemory
)
;
}
transformExtension
=
std
:
:
move
(
canonical
)
;
}
return
Ok
(
)
;
}
using
LocaleId
=
Vector
<
char
LanguageLength
+
1
+
ScriptLength
+
1
+
RegionLength
+
1
>
;
enum
class
LikelySubtags
:
bool
{
Add
Remove
}
;
static
bool
HasLikelySubtags
(
LikelySubtags
likelySubtags
const
Locale
&
tag
)
{
if
(
likelySubtags
=
=
LikelySubtags
:
:
Add
)
{
return
!
tag
.
language
(
)
.
equalTo
(
"
und
"
)
&
&
(
tag
.
script
(
)
.
present
(
)
&
&
!
tag
.
script
(
)
.
equalTo
(
"
Zzzz
"
)
)
&
&
(
tag
.
region
(
)
.
present
(
)
&
&
!
tag
.
region
(
)
.
equalTo
(
"
ZZ
"
)
)
;
}
return
!
tag
.
language
(
)
.
equalTo
(
"
und
"
)
&
&
tag
.
script
(
)
.
missing
(
)
&
&
tag
.
region
(
)
.
missing
(
)
;
}
static
bool
CreateLocaleForLikelySubtags
(
const
Locale
&
tag
LocaleId
&
locale
)
{
MOZ_ASSERT
(
locale
.
length
(
)
=
=
0
)
;
auto
appendSubtag
=
[
&
locale
]
(
const
auto
&
subtag
)
{
auto
span
=
subtag
.
span
(
)
;
MOZ_ASSERT
(
!
span
.
empty
(
)
)
;
return
locale
.
append
(
span
.
data
(
)
span
.
size
(
)
)
;
}
;
if
(
!
appendSubtag
(
tag
.
language
(
)
)
)
{
return
false
;
}
if
(
tag
.
script
(
)
.
present
(
)
)
{
if
(
!
locale
.
append
(
'
_
'
)
|
|
!
appendSubtag
(
tag
.
script
(
)
)
)
{
return
false
;
}
}
if
(
tag
.
region
(
)
.
present
(
)
)
{
if
(
!
locale
.
append
(
'
_
'
)
|
|
!
appendSubtag
(
tag
.
region
(
)
)
)
{
return
false
;
}
}
return
locale
.
append
(
'
\
0
'
)
;
}
static
ICUError
ParserErrorToICUError
(
LocaleParser
:
:
ParserError
err
)
{
using
ParserError
=
LocaleParser
:
:
ParserError
;
switch
(
err
)
{
case
ParserError
:
:
NotParseable
:
return
ICUError
:
:
InternalError
;
case
ParserError
:
:
OutOfMemory
:
return
ICUError
:
:
OutOfMemory
;
}
MOZ_CRASH
(
"
Unexpected
parser
error
"
)
;
}
static
ICUError
CanonicalizationErrorToICUError
(
Locale
:
:
CanonicalizationError
err
)
{
using
CanonicalizationError
=
Locale
:
:
CanonicalizationError
;
switch
(
err
)
{
case
CanonicalizationError
:
:
DuplicateVariant
:
case
CanonicalizationError
:
:
InternalError
:
return
ICUError
:
:
InternalError
;
case
CanonicalizationError
:
:
OutOfMemory
:
return
ICUError
:
:
OutOfMemory
;
}
MOZ_CRASH
(
"
Unexpected
canonicalization
error
"
)
;
}
static
ICUResult
AssignFromLocaleId
(
LocaleId
&
localeId
Locale
&
tag
)
{
std
:
:
replace
(
localeId
.
begin
(
)
localeId
.
end
(
)
'
_
'
'
-
'
)
;
if
(
localeId
.
empty
(
)
|
|
localeId
[
0
]
=
=
'
-
'
)
{
static
constexpr
auto
und
=
MakeStringSpan
(
"
und
"
)
;
constexpr
size_t
length
=
und
.
size
(
)
;
if
(
!
localeId
.
growBy
(
length
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
memmove
(
localeId
.
begin
(
)
+
length
localeId
.
begin
(
)
localeId
.
length
(
)
)
;
memmove
(
localeId
.
begin
(
)
und
.
data
(
)
length
)
;
}
Locale
localeTag
;
MOZ_TRY
(
LocaleParser
:
:
tryParseBaseName
(
localeId
localeTag
)
.
mapErr
(
ParserErrorToICUError
)
)
;
tag
.
setLanguage
(
localeTag
.
language
(
)
)
;
tag
.
setScript
(
localeTag
.
script
(
)
)
;
tag
.
setRegion
(
localeTag
.
region
(
)
)
;
return
Ok
(
)
;
}
template
<
decltype
(
uloc_addLikelySubtags
)
likelySubtagsFn
>
static
ICUResult
CallLikelySubtags
(
const
LocaleId
&
localeId
LocaleId
&
result
)
{
MOZ_ASSERT
(
localeId
.
back
(
)
=
=
'
\
0
'
)
;
MOZ_ASSERT
(
result
.
length
(
)
=
=
0
)
;
MOZ_ALWAYS_TRUE
(
result
.
resize
(
LocaleId
:
:
InlineLength
)
)
;
return
FillBufferWithICUCall
(
result
[
&
localeId
]
(
char
*
chars
int32_t
size
UErrorCode
*
status
)
{
return
likelySubtagsFn
(
localeId
.
begin
(
)
chars
size
status
)
;
}
)
;
}
static
ICUResult
LikelySubtags
(
LikelySubtags
likelySubtags
Locale
&
tag
)
{
if
(
HasLikelySubtags
(
likelySubtags
tag
)
)
{
return
Ok
(
)
;
}
LocaleId
locale
;
if
(
!
CreateLocaleForLikelySubtags
(
tag
locale
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
LocaleId
localeLikelySubtags
;
if
(
likelySubtags
=
=
LikelySubtags
:
:
Add
)
{
MOZ_TRY
(
CallLikelySubtags
<
uloc_addLikelySubtags
>
(
locale
localeLikelySubtags
)
)
;
}
else
{
MOZ_TRY
(
CallLikelySubtags
<
uloc_minimizeSubtags
>
(
locale
localeLikelySubtags
)
)
;
}
MOZ_TRY
(
AssignFromLocaleId
(
localeLikelySubtags
tag
)
)
;
MOZ_TRY
(
tag
.
canonicalizeBaseName
(
)
.
mapErr
(
CanonicalizationErrorToICUError
)
)
;
return
Ok
(
)
;
}
ICUResult
Locale
:
:
addLikelySubtags
(
)
{
return
LikelySubtags
(
LikelySubtags
:
:
Add
*
this
)
;
}
ICUResult
Locale
:
:
removeLikelySubtags
(
)
{
return
LikelySubtags
(
LikelySubtags
:
:
Remove
*
this
)
;
}
UniqueChars
Locale
:
:
DuplicateStringToUniqueChars
(
const
char
*
s
)
{
size_t
length
=
strlen
(
s
)
+
1
;
auto
duplicate
=
MakeUnique
<
char
[
]
>
(
length
)
;
memcpy
(
duplicate
.
get
(
)
s
length
)
;
return
duplicate
;
}
UniqueChars
Locale
:
:
DuplicateStringToUniqueChars
(
Span
<
const
char
>
s
)
{
size_t
length
=
s
.
size
(
)
;
auto
duplicate
=
MakeUnique
<
char
[
]
>
(
length
+
1
)
;
memcpy
(
duplicate
.
get
(
)
s
.
data
(
)
length
)
;
duplicate
[
length
]
=
'
\
0
'
;
return
duplicate
;
}
size_t
Locale
:
:
toStringCapacity
(
)
const
{
auto
lengthSubtag
=
[
]
(
const
auto
&
subtag
)
{
auto
span
=
subtag
.
span
(
)
;
MOZ_ASSERT
(
!
span
.
empty
(
)
)
;
return
span
.
size
(
)
;
}
;
auto
lengthSubtagZ
=
[
]
(
const
char
*
subtag
)
{
size_t
length
=
strlen
(
subtag
)
;
MOZ_ASSERT
(
length
>
0
)
;
return
length
;
}
;
auto
lengthSubtagsZ
=
[
&
lengthSubtagZ
]
(
const
auto
&
subtags
)
{
size_t
length
=
0
;
for
(
const
auto
&
subtag
:
subtags
)
{
length
+
=
lengthSubtagZ
(
subtag
.
get
(
)
)
+
1
;
}
return
length
;
}
;
size_t
capacity
=
0
;
capacity
+
=
lengthSubtag
(
language_
)
;
if
(
script_
.
present
(
)
)
{
capacity
+
=
lengthSubtag
(
script_
)
+
1
;
}
if
(
region_
.
present
(
)
)
{
capacity
+
=
lengthSubtag
(
region_
)
+
1
;
}
capacity
+
=
lengthSubtagsZ
(
variants_
)
;
capacity
+
=
lengthSubtagsZ
(
extensions_
)
;
if
(
privateuse_
.
get
(
)
)
{
capacity
+
=
lengthSubtagZ
(
privateuse_
.
get
(
)
)
+
1
;
}
return
capacity
;
}
size_t
Locale
:
:
toStringAppend
(
char
*
buffer
)
const
{
size_t
offset
=
0
;
auto
appendHyphen
=
[
&
offset
&
buffer
]
(
)
{
buffer
[
offset
]
=
'
-
'
;
offset
+
=
1
;
}
;
auto
appendSubtag
=
[
&
offset
&
buffer
]
(
const
auto
&
subtag
)
{
auto
span
=
subtag
.
span
(
)
;
memcpy
(
buffer
+
offset
span
.
data
(
)
span
.
size
(
)
)
;
offset
+
=
span
.
size
(
)
;
}
;
auto
appendSubtagZ
=
[
&
offset
&
buffer
]
(
const
char
*
subtag
)
{
size_t
length
=
strlen
(
subtag
)
;
memcpy
(
buffer
+
offset
subtag
length
)
;
offset
+
=
length
;
}
;
auto
appendSubtagsZ
=
[
&
appendHyphen
&
appendSubtagZ
]
(
const
auto
&
subtags
)
{
for
(
const
auto
&
subtag
:
subtags
)
{
appendHyphen
(
)
;
appendSubtagZ
(
subtag
.
get
(
)
)
;
}
}
;
appendSubtag
(
language_
)
;
if
(
script_
.
present
(
)
)
{
appendHyphen
(
)
;
appendSubtag
(
script_
)
;
}
if
(
region_
.
present
(
)
)
{
appendHyphen
(
)
;
appendSubtag
(
region_
)
;
}
appendSubtagsZ
(
variants_
)
;
appendSubtagsZ
(
extensions_
)
;
if
(
privateuse_
.
get
(
)
)
{
appendHyphen
(
)
;
appendSubtagZ
(
privateuse_
.
get
(
)
)
;
}
return
offset
;
}
LocaleParser
:
:
Token
LocaleParser
:
:
nextToken
(
)
{
MOZ_ASSERT
(
index_
<
=
length_
+
1
"
called
after
'
None
'
token
was
read
"
)
;
TokenKind
kind
=
TokenKind
:
:
None
;
size_t
tokenLength
=
0
;
for
(
size_t
i
=
index_
;
i
<
length_
;
i
+
+
)
{
char
c
=
charAt
(
i
)
;
if
(
IsAsciiAlpha
(
c
)
)
{
kind
|
=
TokenKind
:
:
Alpha
;
}
else
if
(
IsAsciiDigit
(
c
)
)
{
kind
|
=
TokenKind
:
:
Digit
;
}
else
if
(
c
=
=
'
-
'
&
&
i
>
index_
&
&
i
+
1
<
length_
)
{
break
;
}
else
{
return
{
TokenKind
:
:
Error
0
0
}
;
}
tokenLength
+
=
1
;
}
Token
token
{
kind
index_
tokenLength
}
;
index_
+
=
tokenLength
+
1
;
return
token
;
}
UniqueChars
LocaleParser
:
:
chars
(
size_t
index
size_t
length
)
const
{
auto
chars
=
MakeUnique
<
char
[
]
>
(
length
+
1
)
;
char
*
dest
=
chars
.
get
(
)
;
std
:
:
copy_n
(
locale_
+
index
length
dest
)
;
dest
[
length
]
=
'
\
0
'
;
return
chars
;
}
Result
<
Ok
LocaleParser
:
:
ParserError
>
LocaleParser
:
:
internalParseBaseName
(
LocaleParser
&
ts
Locale
&
tag
Token
&
tok
)
{
if
(
ts
.
isLanguage
(
tok
)
)
{
ts
.
copyChars
(
tok
tag
.
language_
)
;
tok
=
ts
.
nextToken
(
)
;
}
else
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
if
(
ts
.
isScript
(
tok
)
)
{
ts
.
copyChars
(
tok
tag
.
script_
)
;
tok
=
ts
.
nextToken
(
)
;
}
if
(
ts
.
isRegion
(
tok
)
)
{
ts
.
copyChars
(
tok
tag
.
region_
)
;
tok
=
ts
.
nextToken
(
)
;
}
auto
&
variants
=
tag
.
variants_
;
MOZ_ASSERT
(
variants
.
length
(
)
=
=
0
)
;
while
(
ts
.
isVariant
(
tok
)
)
{
auto
variant
=
ts
.
chars
(
tok
)
;
if
(
!
variants
.
append
(
std
:
:
move
(
variant
)
)
)
{
return
Err
(
ParserError
:
:
OutOfMemory
)
;
}
tok
=
ts
.
nextToken
(
)
;
}
return
Ok
(
)
;
}
Result
<
Ok
LocaleParser
:
:
ParserError
>
LocaleParser
:
:
tryParse
(
mozilla
:
:
Span
<
const
char
>
locale
Locale
&
tag
)
{
LocaleParser
ts
(
locale
)
;
Token
tok
=
ts
.
nextToken
(
)
;
MOZ_TRY
(
parseBaseName
(
ts
tag
tok
)
)
;
uint64_t
seenSingletons
=
0
;
auto
&
extensions
=
tag
.
extensions_
;
while
(
ts
.
isExtensionStart
(
tok
)
)
{
char
singleton
=
ts
.
singletonKey
(
tok
)
;
uint64_t
hash
=
1ULL
<
<
(
AsciiAlphanumericToNumber
(
singleton
)
+
1
)
;
if
(
seenSingletons
&
hash
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
seenSingletons
|
=
hash
;
Token
start
=
tok
;
tok
=
ts
.
nextToken
(
)
;
size_t
startValue
=
tok
.
index
(
)
;
if
(
singleton
=
=
'
u
'
)
{
while
(
ts
.
isUnicodeExtensionPart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
}
else
if
(
singleton
=
=
'
t
'
)
{
if
(
ts
.
isLanguage
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
if
(
ts
.
isScript
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
ts
.
isRegion
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
while
(
ts
.
isVariant
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
}
while
(
ts
.
isTransformExtensionKey
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
size_t
startTValue
=
tok
.
index
(
)
;
while
(
ts
.
isTransformExtensionPart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
index
(
)
<
=
startTValue
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
}
}
else
{
while
(
ts
.
isOtherExtensionPart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
}
if
(
tok
.
index
(
)
<
=
startValue
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
UniqueChars
extension
=
ts
.
extension
(
start
tok
)
;
if
(
!
extensions
.
append
(
std
:
:
move
(
extension
)
)
)
{
return
Err
(
ParserError
:
:
OutOfMemory
)
;
}
}
if
(
ts
.
isPrivateUseStart
(
tok
)
)
{
Token
start
=
tok
;
tok
=
ts
.
nextToken
(
)
;
size_t
startValue
=
tok
.
index
(
)
;
while
(
ts
.
isPrivateUsePart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
index
(
)
<
=
startValue
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
UniqueChars
privateUse
=
ts
.
extension
(
start
tok
)
;
tag
.
privateuse_
=
std
:
:
move
(
privateUse
)
;
}
if
(
!
tok
.
isNone
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
return
Ok
(
)
;
}
Result
<
Ok
LocaleParser
:
:
ParserError
>
LocaleParser
:
:
tryParseBaseName
(
Span
<
const
char
>
locale
Locale
&
tag
)
{
LocaleParser
ts
(
locale
)
;
Token
tok
=
ts
.
nextToken
(
)
;
MOZ_TRY
(
parseBaseName
(
ts
tag
tok
)
)
;
if
(
!
tok
.
isNone
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
return
Ok
(
)
;
}
Result
<
Ok
LocaleParser
:
:
ParserError
>
LocaleParser
:
:
parseTransformExtension
(
Span
<
const
char
>
extension
Locale
&
tag
TFieldVector
&
fields
)
{
LocaleParser
ts
(
extension
)
;
Token
tok
=
ts
.
nextToken
(
)
;
if
(
!
ts
.
isExtensionStart
(
tok
)
|
|
ts
.
singletonKey
(
tok
)
!
=
'
t
'
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
tok
=
ts
.
nextToken
(
)
;
if
(
tok
.
isNone
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
if
(
ts
.
isLanguage
(
tok
)
)
{
MOZ_TRY
(
parseTlangInTransformExtension
(
ts
tag
tok
)
)
;
MOZ_ASSERT
(
ts
.
isTransformExtensionKey
(
tok
)
|
|
tok
.
isNone
(
)
)
;
}
else
{
MOZ_ASSERT
(
ts
.
isTransformExtensionKey
(
tok
)
)
;
}
while
(
ts
.
isTransformExtensionKey
(
tok
)
)
{
size_t
begin
=
tok
.
index
(
)
;
tok
=
ts
.
nextToken
(
)
;
size_t
startTValue
=
tok
.
index
(
)
;
while
(
ts
.
isTransformExtensionPart
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
index
(
)
<
=
startTValue
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
size_t
length
=
tok
.
index
(
)
-
1
-
begin
;
if
(
!
fields
.
emplaceBack
(
begin
length
)
)
{
return
Err
(
ParserError
:
:
OutOfMemory
)
;
}
}
if
(
!
tok
.
isNone
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
return
Ok
(
)
;
}
Result
<
Ok
LocaleParser
:
:
ParserError
>
LocaleParser
:
:
parseUnicodeExtension
(
Span
<
const
char
>
extension
AttributesVector
&
attributes
KeywordsVector
&
keywords
)
{
LocaleParser
ts
(
extension
)
;
Token
tok
=
ts
.
nextToken
(
)
;
if
(
!
ts
.
isExtensionStart
(
tok
)
|
|
ts
.
singletonKey
(
tok
)
!
=
'
u
'
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
tok
=
ts
.
nextToken
(
)
;
if
(
tok
.
isNone
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
while
(
ts
.
isUnicodeExtensionAttribute
(
tok
)
)
{
if
(
!
attributes
.
emplaceBack
(
tok
.
index
(
)
tok
.
length
(
)
)
)
{
return
Err
(
ParserError
:
:
OutOfMemory
)
;
}
tok
=
ts
.
nextToken
(
)
;
}
while
(
ts
.
isUnicodeExtensionKey
(
tok
)
)
{
size_t
begin
=
tok
.
index
(
)
;
tok
=
ts
.
nextToken
(
)
;
while
(
ts
.
isUnicodeExtensionType
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
isError
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
size_t
length
=
tok
.
index
(
)
-
1
-
begin
;
if
(
!
keywords
.
emplaceBack
(
begin
length
)
)
{
return
Err
(
ParserError
:
:
OutOfMemory
)
;
}
}
if
(
!
tok
.
isNone
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
return
Ok
(
)
;
}
Result
<
Ok
LocaleParser
:
:
ParserError
>
LocaleParser
:
:
canParseUnicodeExtension
(
Span
<
const
char
>
extension
)
{
LocaleParser
ts
(
extension
)
;
Token
tok
=
ts
.
nextToken
(
)
;
if
(
!
ts
.
isExtensionStart
(
tok
)
|
|
ts
.
singletonKey
(
tok
)
!
=
'
u
'
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
tok
=
ts
.
nextToken
(
)
;
if
(
tok
.
isNone
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
while
(
ts
.
isUnicodeExtensionAttribute
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
while
(
ts
.
isUnicodeExtensionKey
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
while
(
ts
.
isUnicodeExtensionType
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
tok
.
isError
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
}
if
(
!
tok
.
isNone
(
)
)
{
return
Err
(
ParserError
:
:
OutOfMemory
)
;
}
return
Ok
(
)
;
}
Result
<
Ok
LocaleParser
:
:
ParserError
>
LocaleParser
:
:
canParseUnicodeExtensionType
(
Span
<
const
char
>
unicodeType
)
{
MOZ_ASSERT
(
!
unicodeType
.
empty
(
)
"
caller
must
exclude
empty
strings
"
)
;
LocaleParser
ts
(
unicodeType
)
;
Token
tok
=
ts
.
nextToken
(
)
;
while
(
ts
.
isUnicodeExtensionType
(
tok
)
)
{
tok
=
ts
.
nextToken
(
)
;
}
if
(
!
tok
.
isNone
(
)
)
{
return
Err
(
ParserError
:
:
NotParseable
)
;
}
return
Ok
(
)
;
}
}
