#
ifndef
intl_components_ICUUtils_h
#
define
intl_components_ICUUtils_h
#
include
"
unicode
/
uenum
.
h
"
#
include
"
unicode
/
utypes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
intl
/
ICUError
.
h
"
#
include
<
iterator
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
namespace
mozilla
:
:
intl
{
static
inline
const
char
*
IcuLocale
(
const
char
*
aLocale
)
{
const
char
*
locale
=
aLocale
;
if
(
!
strncmp
(
locale
"
und
"
3
)
)
{
locale
=
"
"
;
}
return
locale
;
}
using
ICUResult
=
Result
<
Ok
ICUError
>
;
ICUError
ToICUError
(
UErrorCode
status
)
;
ICUError
ToICUError
(
UErrorCode
status
)
;
ICUResult
ToICUResult
(
UErrorCode
status
)
;
static
inline
bool
ICUSuccessForStringSpan
(
UErrorCode
status
)
{
return
U_SUCCESS
(
status
)
|
|
status
=
=
U_STRING_NOT_TERMINATED_WARNING
;
}
template
<
typename
T
>
class
ICUPointer
{
public
:
explicit
ICUPointer
(
T
*
aPointer
)
:
mPointer
(
aPointer
)
{
}
ICUPointer
(
ICUPointer
&
&
other
)
noexcept
=
default
;
ICUPointer
&
operator
=
(
ICUPointer
&
&
other
)
noexcept
=
default
;
ICUPointer
&
operator
=
(
T
*
aPointer
)
noexcept
{
mPointer
=
aPointer
;
return
*
this
;
}
;
const
T
*
GetConst
(
)
const
{
return
const_cast
<
const
T
*
>
(
mPointer
)
;
}
T
*
GetMut
(
)
{
return
mPointer
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mPointer
;
}
private
:
T
*
mPointer
;
}
;
template
<
typename
ICUStringFunction
typename
Buffer
>
static
ICUResult
FillBufferWithICUCall
(
Buffer
&
buffer
const
ICUStringFunction
&
strFn
)
{
static_assert
(
std
:
:
is_same_v
<
typename
Buffer
:
:
CharType
char16_t
>
|
|
std
:
:
is_same_v
<
typename
Buffer
:
:
CharType
char
>
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
length
=
strFn
(
buffer
.
data
(
)
buffer
.
capacity
(
)
&
status
)
;
if
(
status
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
MOZ_ASSERT
(
length
>
=
0
)
;
if
(
!
buffer
.
reserve
(
length
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
status
=
U_ZERO_ERROR
;
mozilla
:
:
DebugOnly
<
int32_t
>
length2
=
strFn
(
buffer
.
data
(
)
length
&
status
)
;
MOZ_ASSERT
(
length
=
=
length2
)
;
}
if
(
!
ICUSuccessForStringSpan
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
buffer
.
written
(
length
)
;
return
Ok
{
}
;
}
template
<
typename
T
size_t
N
>
class
VectorToBufferAdaptor
{
mozilla
:
:
Vector
<
T
N
>
&
vector
;
public
:
using
CharType
=
T
;
explicit
VectorToBufferAdaptor
(
mozilla
:
:
Vector
<
T
N
>
&
vector
)
:
vector
(
vector
)
{
}
T
*
data
(
)
{
return
vector
.
begin
(
)
;
}
size_t
capacity
(
)
const
{
return
vector
.
capacity
(
)
;
}
bool
reserve
(
size_t
length
)
{
return
vector
.
reserve
(
length
)
;
}
void
written
(
size_t
length
)
{
mozilla
:
:
DebugOnly
<
bool
>
result
=
vector
.
resizeUninitialized
(
length
)
;
MOZ_ASSERT
(
result
)
;
}
}
;
template
<
typename
ICUStringFunction
size_t
InlineSize
typename
CharType
>
static
ICUResult
FillVectorWithICUCall
(
Vector
<
CharType
InlineSize
>
&
vector
const
ICUStringFunction
&
strFn
)
{
VectorToBufferAdaptor
buffer
(
vector
)
;
return
FillBufferWithICUCall
(
buffer
strFn
)
;
}
template
<
typename
Buffer
>
[
[
nodiscard
]
]
bool
FillBuffer
(
Span
<
const
char16_t
>
utf16Span
Buffer
&
targetBuffer
)
{
static_assert
(
std
:
:
is_same_v
<
typename
Buffer
:
:
CharType
char
>
|
|
std
:
:
is_same_v
<
typename
Buffer
:
:
CharType
unsigned
char
>
|
|
std
:
:
is_same_v
<
typename
Buffer
:
:
CharType
char16_t
>
)
;
if
constexpr
(
std
:
:
is_same_v
<
typename
Buffer
:
:
CharType
char
>
|
|
std
:
:
is_same_v
<
typename
Buffer
:
:
CharType
unsigned
char
>
)
{
if
(
utf16Span
.
Length
(
)
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
3
>
:
:
value
)
{
return
false
;
}
if
(
!
targetBuffer
.
reserve
(
3
*
utf16Span
.
Length
(
)
)
)
{
return
false
;
}
size_t
amount
=
ConvertUtf16toUtf8
(
utf16Span
Span
(
reinterpret_cast
<
char
*
>
(
targetBuffer
.
data
(
)
)
targetBuffer
.
capacity
(
)
)
)
;
targetBuffer
.
written
(
amount
)
;
}
if
constexpr
(
std
:
:
is_same_v
<
typename
Buffer
:
:
CharType
char16_t
>
)
{
size_t
amount
=
utf16Span
.
Length
(
)
;
if
(
!
targetBuffer
.
reserve
(
amount
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
amount
;
i
+
+
)
{
targetBuffer
.
data
(
)
[
i
]
=
utf16Span
[
i
]
;
}
targetBuffer
.
written
(
amount
)
;
}
return
true
;
}
template
<
size_t
StackSize
>
[
[
nodiscard
]
]
static
bool
FillUTF16Vector
(
Span
<
const
char
>
utf8Span
mozilla
:
:
Vector
<
char16_t
StackSize
>
&
utf16TargetVec
)
{
if
(
!
utf16TargetVec
.
reserve
(
utf8Span
.
Length
(
)
+
1
)
)
{
return
false
;
}
return
utf16TargetVec
.
resizeUninitialized
(
ConvertUtf8toUtf16
(
utf8Span
Span
(
utf16TargetVec
.
begin
(
)
utf16TargetVec
.
capacity
(
)
)
)
)
;
}
template
<
typename
CharType
typename
T
T
(
Mapper
)
(
const
CharType
*
int32_t
)
>
class
Enumeration
{
public
:
class
Iterator
;
friend
class
Iterator
;
Enumeration
(
Enumeration
&
&
other
)
noexcept
:
mUEnumeration
(
other
.
mUEnumeration
)
{
other
.
mUEnumeration
=
nullptr
;
}
Enumeration
&
operator
=
(
Enumeration
&
&
other
)
noexcept
{
if
(
this
=
=
&
other
)
{
return
*
this
;
}
if
(
mUEnumeration
)
{
uenum_close
(
mUEnumeration
)
;
}
mUEnumeration
=
other
.
mUEnumeration
;
other
.
mUEnumeration
=
nullptr
;
return
*
this
;
}
class
Iterator
:
public
std
:
:
iterator
<
std
:
:
input_iterator_tag
const
CharType
*
void
void
T
>
{
Enumeration
&
mEnumeration
;
Maybe
<
int32_t
>
mIteration
=
Nothing
{
}
;
const
CharType
*
mNext
=
nullptr
;
int32_t
mNextLength
=
0
;
public
:
explicit
Iterator
(
Enumeration
&
aEnumeration
bool
aIsBegin
)
:
mEnumeration
(
aEnumeration
)
{
if
(
aIsBegin
)
{
AdvanceUEnum
(
)
;
}
}
Iterator
&
operator
+
+
(
)
{
AdvanceUEnum
(
)
;
return
*
this
;
}
Iterator
operator
+
+
(
int
)
{
Iterator
retval
=
*
this
;
+
+
(
*
this
)
;
return
retval
;
}
bool
operator
=
=
(
Iterator
other
)
const
{
return
mIteration
=
=
other
.
mIteration
;
}
bool
operator
!
=
(
Iterator
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
T
operator
*
(
)
const
{
return
Mapper
(
mNext
mNextLength
)
;
}
private
:
void
AdvanceUEnum
(
)
{
if
(
mIteration
.
isNothing
(
)
)
{
mIteration
=
Some
(
-
1
)
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
if
constexpr
(
std
:
:
is_same_v
<
CharType
char16_t
>
)
{
mNext
=
uenum_unext
(
mEnumeration
.
mUEnumeration
&
mNextLength
&
status
)
;
}
else
{
static_assert
(
std
:
:
is_same_v
<
CharType
char
>
"
Only
char16_t
and
char
are
supported
by
"
"
mozilla
:
:
intl
:
:
Enumeration
.
"
)
;
mNext
=
uenum_next
(
mEnumeration
.
mUEnumeration
&
mNextLength
&
status
)
;
}
if
(
U_FAILURE
(
status
)
)
{
mNext
=
nullptr
;
}
if
(
mNext
)
{
(
*
mIteration
)
+
+
;
}
else
{
mIteration
=
Nothing
{
}
;
}
}
}
;
Iterator
begin
(
)
{
return
Iterator
(
*
this
true
)
;
}
Iterator
end
(
)
{
return
Iterator
(
*
this
false
)
;
}
explicit
Enumeration
(
UEnumeration
*
aUEnumeration
)
:
mUEnumeration
(
aUEnumeration
)
{
}
~
Enumeration
(
)
{
if
(
mUEnumeration
)
{
uenum_close
(
mUEnumeration
)
;
}
}
private
:
UEnumeration
*
mUEnumeration
=
nullptr
;
}
;
template
<
typename
CharType
>
Result
<
Span
<
const
CharType
>
InternalError
>
SpanMapper
(
const
CharType
*
string
int32_t
length
)
{
if
(
string
=
=
nullptr
)
{
return
Err
(
InternalError
{
}
)
;
}
MOZ_ASSERT
(
length
>
=
0
)
;
return
Span
<
const
CharType
>
(
string
static_cast
<
size_t
>
(
length
)
)
;
}
template
<
typename
CharType
>
using
SpanResult
=
Result
<
Span
<
const
CharType
>
InternalError
>
;
template
<
typename
CharType
>
using
SpanEnumeration
=
Enumeration
<
CharType
SpanResult
<
CharType
>
SpanMapper
>
;
template
<
int32_t
(
CountAvailable
)
(
)
const
char
*
(
GetAvailable
)
(
int32_t
)
>
class
AvailableLocalesEnumeration
final
{
int32_t
mLocalesCount
=
0
;
public
:
AvailableLocalesEnumeration
(
)
{
mLocalesCount
=
CountAvailable
(
)
;
}
class
Iterator
{
public
:
using
iterator_category
=
std
:
:
input_iterator_tag
;
using
value_type
=
const
char
*
;
using
difference_type
=
ptrdiff_t
;
using
pointer
=
value_type
*
;
using
reference
=
value_type
&
;
private
:
int32_t
mLocalesPos
=
0
;
public
:
explicit
Iterator
(
int32_t
aLocalesPos
)
:
mLocalesPos
(
aLocalesPos
)
{
}
Iterator
&
operator
+
+
(
)
{
mLocalesPos
+
+
;
return
*
this
;
}
Iterator
operator
+
+
(
int
)
{
Iterator
result
=
*
this
;
+
+
(
*
this
)
;
return
result
;
}
bool
operator
=
=
(
const
Iterator
&
aOther
)
const
{
return
mLocalesPos
=
=
aOther
.
mLocalesPos
;
}
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
value_type
operator
*
(
)
const
{
return
GetAvailable
(
mLocalesPos
)
;
}
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
0
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
mLocalesCount
)
;
}
}
;
}
#
endif
