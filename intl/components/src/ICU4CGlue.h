#
ifndef
intl_components_ICUUtils_h
#
define
intl_components_ICUUtils_h
#
include
"
unicode
/
utypes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
:
:
intl
{
enum
class
ICUError
:
uint8_t
{
OutOfMemory
InternalError
}
;
using
ICUResult
=
Result
<
Ok
ICUError
>
;
static
inline
bool
ICUSuccessForStringSpan
(
UErrorCode
status
)
{
return
U_SUCCESS
(
status
)
|
|
status
=
=
U_STRING_NOT_TERMINATED_WARNING
;
}
template
<
typename
ICUStringFunction
typename
Buffer
>
static
ICUResult
FillBufferWithICUCall
(
Buffer
&
buffer
const
ICUStringFunction
&
strFn
)
{
static_assert
(
std
:
:
is_same
<
typename
Buffer
:
:
CharType
char16_t
>
:
:
value
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
length
=
strFn
(
buffer
.
data
(
)
buffer
.
capacity
(
)
&
status
)
;
if
(
status
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
MOZ_ASSERT
(
length
>
=
0
)
;
if
(
!
buffer
.
allocate
(
length
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
status
=
U_ZERO_ERROR
;
mozilla
:
:
DebugOnly
<
int32_t
>
length2
=
strFn
(
buffer
.
data
(
)
length
&
status
)
;
MOZ_ASSERT
(
length
=
=
length2
)
;
}
if
(
!
ICUSuccessForStringSpan
(
status
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
buffer
.
written
(
length
)
;
return
Ok
{
}
;
}
template
<
typename
ICUStringFunction
size_t
InlineSize
>
static
ICUResult
FillVectorWithICUCall
(
Vector
<
char16_t
InlineSize
>
&
vector
const
ICUStringFunction
&
strFn
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
length
=
strFn
(
vector
.
begin
(
)
vector
.
capacity
(
)
&
status
)
;
if
(
status
=
=
U_BUFFER_OVERFLOW_ERROR
)
{
MOZ_ASSERT
(
length
>
=
0
)
;
if
(
!
vector
.
reserve
(
length
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
status
=
U_ZERO_ERROR
;
mozilla
:
:
DebugOnly
<
int32_t
>
length2
=
strFn
(
vector
.
begin
(
)
length
&
status
)
;
MOZ_ASSERT
(
length
=
=
length2
)
;
}
if
(
!
ICUSuccessForStringSpan
(
status
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
mozilla
:
:
DebugOnly
<
bool
>
result
=
vector
.
resizeUninitialized
(
length
)
;
MOZ_ASSERT
(
result
)
;
return
Ok
{
}
;
}
template
<
typename
Buffer
>
[
[
nodiscard
]
]
bool
FillUTF8Buffer
(
Span
<
const
char16_t
>
utf16Span
Buffer
&
utf8TargetBuffer
)
{
static_assert
(
std
:
:
is_same
<
typename
Buffer
:
:
CharType
char
>
:
:
value
|
|
std
:
:
is_same
<
typename
Buffer
:
:
CharType
unsigned
char
>
:
:
value
)
;
if
(
utf16Span
.
Length
(
)
&
mozilla
:
:
tl
:
:
MulOverflowMask
<
3
>
:
:
value
)
{
return
false
;
}
if
(
!
utf8TargetBuffer
.
allocate
(
3
*
utf16Span
.
Length
(
)
)
)
{
return
false
;
}
size_t
amount
=
ConvertUtf16toUtf8
(
utf16Span
Span
(
reinterpret_cast
<
char
*
>
(
std
:
:
data
(
utf8TargetBuffer
)
)
std
:
:
size
(
utf8TargetBuffer
)
)
)
;
utf8TargetBuffer
.
written
(
amount
)
;
return
true
;
}
template
<
size_t
StackSize
>
[
[
nodiscard
]
]
static
bool
FillUTF16Vector
(
Span
<
const
char
>
utf8Span
mozilla
:
:
Vector
<
char16_t
StackSize
>
&
utf16TargetVec
)
{
if
(
!
utf16TargetVec
.
reserve
(
utf8Span
.
Length
(
)
+
1
)
)
{
return
false
;
}
return
utf16TargetVec
.
resizeUninitialized
(
ConvertUtf8toUtf16
(
utf8Span
Span
(
utf16TargetVec
.
begin
(
)
utf16TargetVec
.
capacity
(
)
)
)
)
;
}
}
#
endif
