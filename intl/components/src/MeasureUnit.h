#
ifndef
intl_components_MeasureUnit_h_
#
define
intl_components_MeasureUnit_h_
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
mozilla
/
intl
/
ICUError
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
iterator
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
utility
>
struct
UResourceBundle
;
namespace
mozilla
:
:
intl
{
class
MeasureUnit
final
{
class
UResourceBundleDeleter
{
public
:
void
operator
(
)
(
UResourceBundle
*
aPtr
)
;
}
;
using
UniqueUResourceBundle
=
UniquePtr
<
UResourceBundle
UResourceBundleDeleter
>
;
public
:
MeasureUnit
(
)
=
delete
;
class
Enumeration
final
{
UniqueUResourceBundle
mRootLocale
=
nullptr
;
UniqueUResourceBundle
mUnits
=
nullptr
;
int32_t
mUnitsSize
=
0
;
public
:
Enumeration
(
UniqueUResourceBundle
aRootLocale
UniqueUResourceBundle
aUnits
)
;
class
Iterator
{
public
:
using
iterator_category
=
std
:
:
input_iterator_tag
;
using
value_type
=
SpanResult
<
char
>
;
using
difference_type
=
ptrdiff_t
;
using
pointer
=
value_type
*
;
using
reference
=
value_type
&
;
private
:
const
Enumeration
&
mEnumeration
;
UniqueUResourceBundle
mType
=
nullptr
;
UniqueUResourceBundle
mSubtype
=
nullptr
;
int32_t
mUnitsPos
=
0
;
int32_t
mTypeSize
=
0
;
int32_t
mTypePos
=
0
;
bool
mHasError
=
false
;
void
advance
(
)
;
public
:
Iterator
(
const
Enumeration
&
aEnumeration
int32_t
aUnitsPos
)
:
mEnumeration
(
aEnumeration
)
mUnitsPos
(
aUnitsPos
)
{
advance
(
)
;
}
Iterator
&
operator
+
+
(
)
{
advance
(
)
;
return
*
this
;
}
Iterator
operator
+
+
(
int
)
=
delete
;
bool
operator
=
=
(
const
Iterator
&
aOther
)
const
{
MOZ_ASSERT
(
&
mEnumeration
=
=
&
aOther
.
mEnumeration
)
;
return
mUnitsPos
=
=
aOther
.
mUnitsPos
&
&
mTypeSize
=
=
aOther
.
mTypeSize
&
&
mTypePos
=
=
aOther
.
mTypePos
&
&
mHasError
=
=
aOther
.
mHasError
;
}
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
value_type
operator
*
(
)
const
;
}
;
friend
class
Iterator
;
Iterator
begin
(
)
{
return
Iterator
(
*
this
0
)
;
}
Iterator
end
(
)
{
return
Iterator
(
*
this
mUnitsSize
)
;
}
static
Result
<
Enumeration
ICUError
>
TryCreate
(
)
;
}
;
static
Result
<
Enumeration
ICUError
>
GetAvailable
(
)
{
return
Enumeration
:
:
TryCreate
(
)
;
}
}
;
}
#
endif
