#
ifndef
intl_components_PluralRules_h_
#
define
intl_components_PluralRules_h_
#
include
<
string_view
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
intl
/
ICUError
.
h
"
#
include
"
mozilla
/
intl
/
NumberFormat
.
h
"
#
include
"
mozilla
/
intl
/
NumberRangeFormat
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
unicode
/
utypes
.
h
"
namespace
mozilla
:
:
intl
{
class
PluralRules
final
{
public
:
enum
class
Keyword
:
uint8_t
{
Few
Many
One
Other
Two
Zero
}
;
enum
class
Type
:
uint8_t
{
Cardinal
Ordinal
}
;
PluralRules
(
const
PluralRules
&
)
=
delete
;
PluralRules
&
operator
=
(
const
PluralRules
&
)
=
delete
;
static
Result
<
UniquePtr
<
PluralRules
>
ICUError
>
TryCreate
(
std
:
:
string_view
aLocale
const
PluralRulesOptions
&
aOptions
)
;
Result
<
PluralRules
:
:
Keyword
ICUError
>
Select
(
double
aNumber
)
const
;
Result
<
PluralRules
:
:
Keyword
ICUError
>
SelectRange
(
double
aStart
double
aEnd
)
const
;
Result
<
EnumSet
<
PluralRules
:
:
Keyword
>
ICUError
>
Categories
(
)
const
;
~
PluralRules
(
)
;
private
:
static
const
size_t
MAX_KEYWORD_LENGTH
=
5
;
UPluralRules
*
mPluralRules
=
nullptr
;
UniquePtr
<
NumberFormat
>
mNumberFormat
;
UniquePtr
<
NumberRangeFormat
>
mNumberRangeFormat
;
PluralRules
(
UPluralRules
*
&
UniquePtr
<
NumberFormat
>
&
&
UniquePtr
<
NumberRangeFormat
>
&
&
)
;
static
PluralRules
:
:
Keyword
KeywordFromUtf16
(
Span
<
const
char16_t
>
aKeyword
)
;
static
PluralRules
:
:
Keyword
KeywordFromAscii
(
Span
<
const
char
>
aKeyword
)
;
}
;
struct
MOZ_STACK_CLASS
PluralRulesOptions
{
NumberFormatOptions
ToNumberFormatOptions
(
)
const
{
NumberFormatOptions
options
;
options
.
mRoundingMode
=
NumberFormatOptions
:
:
RoundingMode
:
:
HalfExpand
;
if
(
mFractionDigits
.
isSome
(
)
)
{
options
.
mFractionDigits
.
emplace
(
mFractionDigits
.
ref
(
)
)
;
}
if
(
mMinIntegerDigits
.
isSome
(
)
)
{
options
.
mMinIntegerDigits
.
emplace
(
mMinIntegerDigits
.
ref
(
)
)
;
}
if
(
mSignificantDigits
.
isSome
(
)
)
{
options
.
mSignificantDigits
.
emplace
(
mSignificantDigits
.
ref
(
)
)
;
}
options
.
mRoundingPriority
=
NumberFormatOptions
:
:
RoundingPriority
(
mRoundingPriority
)
;
return
options
;
}
NumberRangeFormatOptions
ToNumberRangeFormatOptions
(
)
const
{
NumberRangeFormatOptions
options
;
options
.
mRoundingMode
=
NumberRangeFormatOptions
:
:
RoundingMode
:
:
HalfExpand
;
options
.
mRangeCollapse
=
NumberRangeFormatOptions
:
:
RangeCollapse
:
:
None
;
options
.
mRangeIdentityFallback
=
NumberRangeFormatOptions
:
:
RangeIdentityFallback
:
:
Range
;
if
(
mFractionDigits
.
isSome
(
)
)
{
options
.
mFractionDigits
.
emplace
(
mFractionDigits
.
ref
(
)
)
;
}
if
(
mMinIntegerDigits
.
isSome
(
)
)
{
options
.
mMinIntegerDigits
.
emplace
(
mMinIntegerDigits
.
ref
(
)
)
;
}
if
(
mSignificantDigits
.
isSome
(
)
)
{
options
.
mSignificantDigits
.
emplace
(
mSignificantDigits
.
ref
(
)
)
;
}
options
.
mRoundingPriority
=
NumberFormatOptions
:
:
RoundingPriority
(
mRoundingPriority
)
;
return
options
;
}
PluralRules
:
:
Type
mPluralType
=
PluralRules
:
:
Type
:
:
Cardinal
;
Maybe
<
uint32_t
>
mMinIntegerDigits
;
Maybe
<
std
:
:
pair
<
uint32_t
uint32_t
>
>
mFractionDigits
;
Maybe
<
std
:
:
pair
<
uint32_t
uint32_t
>
>
mSignificantDigits
;
enum
class
RoundingPriority
{
Auto
MorePrecision
LessPrecision
}
mRoundingPriority
=
RoundingPriority
:
:
Auto
;
static_assert
(
std
:
:
is_same_v
<
std
:
:
underlying_type_t
<
RoundingPriority
>
std
:
:
underlying_type_t
<
NumberFormatOptions
:
:
RoundingPriority
>
>
)
;
static_assert
(
RoundingPriority
:
:
Auto
=
=
RoundingPriority
(
NumberFormatOptions
:
:
RoundingPriority
:
:
Auto
)
)
;
static_assert
(
RoundingPriority
:
:
LessPrecision
=
=
RoundingPriority
(
NumberFormatOptions
:
:
RoundingPriority
:
:
LessPrecision
)
)
;
static_assert
(
RoundingPriority
:
:
MorePrecision
=
=
RoundingPriority
(
NumberFormatOptions
:
:
RoundingPriority
:
:
MorePrecision
)
)
;
}
;
}
#
endif
