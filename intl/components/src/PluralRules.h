#
ifndef
intl_components_PluralRules_h_
#
define
intl_components_PluralRules_h_
#
include
<
string_view
>
#
include
<
utility
>
#
include
"
mozilla
/
intl
/
NumberFormat
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
namespace
mozilla
{
namespace
intl
{
class
PluralRules
final
{
public
:
enum
class
Keyword
:
uint8_t
{
Few
Many
One
Other
Two
Zero
}
;
enum
class
Type
:
uint8_t
{
Cardinal
Ordinal
}
;
enum
class
Error
:
uint8_t
{
FormatError
InternalError
OutOfMemory
}
;
PluralRules
(
const
PluralRules
&
)
=
delete
;
PluralRules
&
operator
=
(
const
PluralRules
&
)
=
delete
;
static
Result
<
UniquePtr
<
PluralRules
>
PluralRules
:
:
Error
>
TryCreate
(
std
:
:
string_view
aLocale
const
PluralRulesOptions
&
aOptions
)
;
Result
<
PluralRules
:
:
Keyword
PluralRules
:
:
Error
>
Select
(
double
aNumber
)
const
;
Result
<
EnumSet
<
PluralRules
:
:
Keyword
>
PluralRules
:
:
Error
>
Categories
(
)
const
;
~
PluralRules
(
)
;
private
:
static
const
size_t
MAX_KEYWORD_LENGTH
=
5
;
UPluralRules
*
mPluralRules
=
nullptr
;
UniquePtr
<
NumberFormat
>
mNumberFormat
;
PluralRules
(
UPluralRules
*
&
UniquePtr
<
NumberFormat
>
&
&
)
;
static
PluralRules
:
:
Keyword
KeywordFromUtf16
(
Span
<
const
char16_t
>
aKeyword
)
;
static
PluralRules
:
:
Keyword
KeywordFromAscii
(
Span
<
const
char
>
aKeyword
)
;
}
;
struct
MOZ_STACK_CLASS
PluralRulesOptions
{
NumberFormatOptions
ToNumberFormatOptions
(
)
const
{
NumberFormatOptions
options
;
options
.
mRoundingModeHalfUp
=
true
;
if
(
mFractionDigits
.
isSome
(
)
)
{
options
.
mFractionDigits
.
emplace
(
mFractionDigits
.
ref
(
)
)
;
}
if
(
mMinIntegerDigits
.
isSome
(
)
)
{
options
.
mMinIntegerDigits
.
emplace
(
mMinIntegerDigits
.
ref
(
)
)
;
}
if
(
mSignificantDigits
.
isSome
(
)
)
{
options
.
mSignificantDigits
.
emplace
(
mSignificantDigits
.
ref
(
)
)
;
}
return
options
;
}
PluralRules
:
:
Type
mPluralType
=
PluralRules
:
:
Type
:
:
Cardinal
;
Maybe
<
uint32_t
>
mMinIntegerDigits
;
Maybe
<
std
:
:
pair
<
uint32_t
uint32_t
>
>
mFractionDigits
;
Maybe
<
std
:
:
pair
<
uint32_t
uint32_t
>
>
mSignificantDigits
;
}
;
}
}
#
endif
