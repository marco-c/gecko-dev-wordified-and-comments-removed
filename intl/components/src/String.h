#
ifndef
intl_components_String_h_
#
define
intl_components_String_h_
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
mozilla
/
intl
/
ICUError
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
unicode
/
uchar
.
h
"
#
include
"
unicode
/
unorm2
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
unicode
/
utext
.
h
"
#
include
"
unicode
/
utypes
.
h
"
namespace
mozilla
:
:
intl
{
class
String
final
{
public
:
String
(
)
=
delete
;
template
<
typename
B
>
static
Result
<
Ok
ICUError
>
ToLocaleLowerCase
(
const
char
*
aLocale
Span
<
const
char16_t
>
aString
B
&
aBuffer
)
{
if
(
!
aBuffer
.
reserve
(
aString
.
size
(
)
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
return
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
u_strToLower
(
target
length
aString
.
data
(
)
aString
.
size
(
)
aLocale
status
)
;
}
)
;
}
template
<
typename
B
>
static
Result
<
Ok
ICUError
>
ToLocaleUpperCase
(
const
char
*
aLocale
Span
<
const
char16_t
>
aString
B
&
aBuffer
)
{
if
(
!
aBuffer
.
reserve
(
aString
.
size
(
)
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
return
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
u_strToUpper
(
target
length
aString
.
data
(
)
aString
.
size
(
)
aLocale
status
)
;
}
)
;
}
enum
class
NormalizationForm
{
NFC
NFD
NFKC
NFKD
}
;
enum
class
AlreadyNormalized
:
bool
{
No
Yes
}
;
template
<
typename
B
>
static
Result
<
AlreadyNormalized
ICUError
>
Normalize
(
NormalizationForm
aForm
Span
<
const
char16_t
>
aString
B
&
aBuffer
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
const
UNormalizer2
*
normalizer
;
switch
(
aForm
)
{
case
NormalizationForm
:
:
NFC
:
normalizer
=
unorm2_getNFCInstance
(
&
status
)
;
break
;
case
NormalizationForm
:
:
NFD
:
normalizer
=
unorm2_getNFDInstance
(
&
status
)
;
break
;
case
NormalizationForm
:
:
NFKC
:
normalizer
=
unorm2_getNFKCInstance
(
&
status
)
;
break
;
case
NormalizationForm
:
:
NFKD
:
normalizer
=
unorm2_getNFKDInstance
(
&
status
)
;
break
;
}
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
int32_t
spanLengthInt
=
unorm2_spanQuickCheckYes
(
normalizer
aString
.
data
(
)
aString
.
size
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
size_t
spanLength
=
AssertedCast
<
size_t
>
(
spanLengthInt
)
;
MOZ_ASSERT
(
spanLength
<
=
aString
.
size
(
)
)
;
if
(
spanLength
=
=
aString
.
size
(
)
)
{
return
AlreadyNormalized
:
:
Yes
;
}
if
(
!
aBuffer
.
reserve
(
aString
.
size
(
)
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
if
(
spanLength
>
0
)
{
PodCopy
(
aBuffer
.
data
(
)
aString
.
data
(
)
spanLength
)
;
}
MOZ_TRY
(
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
Span
<
const
char16_t
>
remaining
=
aString
.
From
(
spanLength
)
;
return
unorm2_normalizeSecondAndAppend
(
normalizer
target
spanLength
length
remaining
.
data
(
)
remaining
.
size
(
)
status
)
;
}
)
)
;
return
AlreadyNormalized
:
:
No
;
}
static
bool
IsCased
(
char32_t
codePoint
)
{
return
u_hasBinaryProperty
(
static_cast
<
UChar32
>
(
codePoint
)
UCHAR_CASED
)
;
}
static
bool
IsCaseIgnorable
(
char32_t
codePoint
)
{
return
u_hasBinaryProperty
(
static_cast
<
UChar32
>
(
codePoint
)
UCHAR_CASE_IGNORABLE
)
;
}
static
char32_t
ComposePairNFC
(
char32_t
a
char32_t
b
)
{
static
UErrorCode
status
=
U_ZERO_ERROR
;
static
const
UNormalizer2
*
normalizer
=
unorm2_getNFCInstance
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
UChar32
ch
=
unorm2_composePair
(
normalizer
static_cast
<
UChar32
>
(
a
)
static_cast
<
UChar32
>
(
b
)
)
;
return
ch
<
0
?
0
:
static_cast
<
char32_t
>
(
ch
)
;
}
static
int
DecomposeRawNFD
(
char32_t
ab
char32_t
decomp
[
2
]
)
{
static
UErrorCode
status
=
U_ZERO_ERROR
;
static
const
UNormalizer2
*
normalizer
=
unorm2_getNFCInstance
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
0
;
}
const
unsigned
MAX_DECOMP_LENGTH
=
4
;
UErrorCode
error
=
U_ZERO_ERROR
;
UChar
decompUtf16
[
MAX_DECOMP_LENGTH
]
;
int32_t
len
=
unorm2_getRawDecomposition
(
normalizer
static_cast
<
UChar32
>
(
ab
)
decompUtf16
MAX_DECOMP_LENGTH
&
error
)
;
if
(
U_FAILURE
(
error
)
|
|
len
<
0
)
{
return
0
;
}
UText
text
=
UTEXT_INITIALIZER
;
utext_openUChars
(
&
text
decompUtf16
len
&
error
)
;
MOZ_ASSERT
(
U_SUCCESS
(
error
)
)
;
UChar32
ch
=
UTEXT_NEXT32
(
&
text
)
;
len
=
0
;
if
(
ch
!
=
U_SENTINEL
)
{
decomp
[
0
]
=
static_cast
<
char32_t
>
(
ch
)
;
+
+
len
;
ch
=
UTEXT_NEXT32
(
&
text
)
;
if
(
ch
!
=
U_SENTINEL
)
{
decomp
[
1
]
=
static_cast
<
char32_t
>
(
ch
)
;
+
+
len
;
}
}
utext_close
(
&
text
)
;
return
len
;
}
}
;
}
#
endif
