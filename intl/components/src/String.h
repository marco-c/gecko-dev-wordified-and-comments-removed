#
ifndef
intl_components_String_h_
#
define
intl_components_String_h_
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
mozilla
/
intl
/
ICUError
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
unicode
/
uchar
.
h
"
#
include
"
unicode
/
unorm2
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
unicode
/
utypes
.
h
"
namespace
mozilla
:
:
intl
{
class
String
final
{
public
:
String
(
)
=
delete
;
template
<
typename
B
>
static
Result
<
Ok
ICUError
>
ToLocaleLowerCase
(
const
char
*
aLocale
Span
<
const
char16_t
>
aString
B
&
aBuffer
)
{
if
(
!
aBuffer
.
reserve
(
aString
.
size
(
)
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
return
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
u_strToLower
(
target
length
aString
.
data
(
)
aString
.
size
(
)
aLocale
status
)
;
}
)
;
}
template
<
typename
B
>
static
Result
<
Ok
ICUError
>
ToLocaleUpperCase
(
const
char
*
aLocale
Span
<
const
char16_t
>
aString
B
&
aBuffer
)
{
if
(
!
aBuffer
.
reserve
(
aString
.
size
(
)
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
return
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
u_strToUpper
(
target
length
aString
.
data
(
)
aString
.
size
(
)
aLocale
status
)
;
}
)
;
}
enum
class
NormalizationForm
{
NFC
NFD
NFKC
NFKD
}
;
enum
class
AlreadyNormalized
:
bool
{
No
Yes
}
;
template
<
typename
B
>
static
Result
<
AlreadyNormalized
ICUError
>
Normalize
(
NormalizationForm
aForm
Span
<
const
char16_t
>
aString
B
&
aBuffer
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
const
UNormalizer2
*
normalizer
;
switch
(
aForm
)
{
case
NormalizationForm
:
:
NFC
:
normalizer
=
unorm2_getNFCInstance
(
&
status
)
;
break
;
case
NormalizationForm
:
:
NFD
:
normalizer
=
unorm2_getNFDInstance
(
&
status
)
;
break
;
case
NormalizationForm
:
:
NFKC
:
normalizer
=
unorm2_getNFKCInstance
(
&
status
)
;
break
;
case
NormalizationForm
:
:
NFKD
:
normalizer
=
unorm2_getNFKDInstance
(
&
status
)
;
break
;
}
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
int32_t
spanLengthInt
=
unorm2_spanQuickCheckYes
(
normalizer
aString
.
data
(
)
aString
.
size
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ToICUError
(
status
)
)
;
}
size_t
spanLength
=
AssertedCast
<
size_t
>
(
spanLengthInt
)
;
MOZ_ASSERT
(
spanLength
<
=
aString
.
size
(
)
)
;
if
(
spanLength
=
=
aString
.
size
(
)
)
{
return
AlreadyNormalized
:
:
Yes
;
}
if
(
!
aBuffer
.
reserve
(
aString
.
size
(
)
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
if
(
spanLength
>
0
)
{
PodCopy
(
aBuffer
.
data
(
)
aString
.
data
(
)
spanLength
)
;
}
MOZ_TRY
(
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
Span
<
const
char16_t
>
remaining
=
aString
.
From
(
spanLength
)
;
return
unorm2_normalizeSecondAndAppend
(
normalizer
target
spanLength
length
remaining
.
data
(
)
remaining
.
size
(
)
status
)
;
}
)
)
;
return
AlreadyNormalized
:
:
No
;
}
static
bool
IsCased
(
char32_t
codePoint
)
{
return
u_hasBinaryProperty
(
static_cast
<
UChar32
>
(
codePoint
)
UCHAR_CASED
)
;
}
static
bool
IsCaseIgnorable
(
char32_t
codePoint
)
{
return
u_hasBinaryProperty
(
static_cast
<
UChar32
>
(
codePoint
)
UCHAR_CASE_IGNORABLE
)
;
}
}
;
}
#
endif
