#
ifndef
intl_components_IDNA_h_
#
define
intl_components_IDNA_h_
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
unicode
/
uidna
.
h
"
namespace
mozilla
:
:
intl
{
class
IDNA
final
{
public
:
~
IDNA
(
)
;
enum
class
ProcessingType
{
Transitional
NonTransitional
}
;
static
Result
<
UniquePtr
<
IDNA
>
ICUError
>
TryCreate
(
ProcessingType
aProcessing
)
;
class
Info
final
{
public
:
bool
HasErrors
(
)
const
{
return
mErrorCode
!
=
0
;
}
bool
HasInvalidPunycode
(
)
const
{
return
(
mErrorCode
&
UIDNA_ERROR_PUNYCODE
)
!
=
0
;
}
bool
HasInvalidHyphen
(
)
const
{
uint32_t
hyphenErrors
=
UIDNA_ERROR_LEADING_HYPHEN
|
UIDNA_ERROR_TRAILING_HYPHEN
|
UIDNA_ERROR_HYPHEN_3_4
;
return
(
mErrorCode
&
hyphenErrors
)
!
=
0
;
}
private
:
friend
class
IDNA
;
explicit
Info
(
const
UIDNAInfo
*
aUinfo
)
:
mErrorCode
(
aUinfo
-
>
errors
)
{
}
uint32_t
mErrorCode
=
0
;
}
;
template
<
typename
Buffer
>
Result
<
Info
ICUError
>
LabelToUnicode
(
Span
<
const
char16_t
>
aLabel
Buffer
&
aBuffer
)
{
UIDNAInfo
uinfo
=
UIDNA_INFO_INITIALIZER
;
MOZ_TRY
(
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
uidna_labelToUnicode
(
mIDNA
.
GetConst
(
)
aLabel
.
data
(
)
aLabel
.
size
(
)
target
length
&
uinfo
status
)
;
}
)
)
;
return
Info
{
&
uinfo
}
;
}
private
:
explicit
IDNA
(
UIDNA
*
aIDNA
)
:
mIDNA
(
aIDNA
)
{
}
ICUPointer
<
UIDNA
>
mIDNA
=
ICUPointer
<
UIDNA
>
(
nullptr
)
;
}
;
}
#
endif
