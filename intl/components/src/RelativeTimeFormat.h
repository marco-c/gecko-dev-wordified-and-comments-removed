#
ifndef
intl_components_RelativeTimeFormat_h_
#
define
intl_components_RelativeTimeFormat_h_
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
mozilla
/
intl
/
NumberFormatFields
.
h
"
#
include
"
unicode
/
ureldatefmt
.
h
"
#
include
"
unicode
/
utypes
.
h
"
namespace
mozilla
{
namespace
intl
{
struct
RelativeTimeFormatOptions
{
enum
class
Style
{
Short
Narrow
Long
}
;
Style
style
=
Style
:
:
Long
;
enum
class
Numeric
{
Always
Auto
}
;
Numeric
numeric
=
Numeric
:
:
Always
;
}
;
class
RelativeTimeFormat
final
{
public
:
static
Result
<
UniquePtr
<
RelativeTimeFormat
>
ICUError
>
TryCreate
(
const
char
*
aLocale
const
RelativeTimeFormatOptions
&
aOptions
)
;
RelativeTimeFormat
(
)
=
default
;
RelativeTimeFormat
(
RelativeTimeFormatOptions
:
:
Numeric
aNumeric
URelativeDateTimeFormatter
*
aFormatter
UFormattedRelativeDateTime
*
aFormattedRelativeDateTime
)
;
RelativeTimeFormat
(
const
RelativeTimeFormat
&
)
=
delete
;
RelativeTimeFormat
&
operator
=
(
const
RelativeTimeFormat
&
)
=
delete
;
~
RelativeTimeFormat
(
)
;
enum
class
FormatUnit
{
Second
Minute
Hour
Day
Week
Month
Quarter
Year
}
;
template
<
typename
B
>
Result
<
Ok
ICUError
>
format
(
double
aNumber
FormatUnit
aUnit
B
&
aBuffer
)
const
{
static_assert
(
std
:
:
is_same_v
<
typename
B
:
:
CharType
char
>
|
|
std
:
:
is_same_v
<
typename
B
:
:
CharType
char16_t
>
"
The
only
buffer
CharTypes
supported
by
RelativeTimeFormat
are
char
"
"
(
for
UTF
-
8
support
)
and
char16_t
(
for
UTF
-
16
support
)
.
"
)
;
auto
fmt
=
mNumeric
=
=
RelativeTimeFormatOptions
:
:
Numeric
:
:
Auto
?
ureldatefmt_format
:
ureldatefmt_formatNumeric
;
if
constexpr
(
std
:
:
is_same
<
typename
B
:
:
CharType
char
>
:
:
value
)
{
mozilla
:
:
Vector
<
char16_t
StackU16VectorSize
>
u16Vec
;
MOZ_TRY
(
FillVectorWithICUCall
(
u16Vec
[
this
aNumber
aUnit
fmt
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
fmt
(
mFormatter
aNumber
ToURelativeDateTimeUnit
(
aUnit
)
target
length
status
)
;
}
)
)
;
if
(
!
FillUTF8Buffer
(
u16Vec
aBuffer
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
return
Ok
{
}
;
}
else
{
static_assert
(
std
:
:
is_same_v
<
typename
B
:
:
CharType
char16_t
>
)
;
return
FillBufferWithICUCall
(
aBuffer
[
this
aNumber
aUnit
fmt
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
fmt
(
mFormatter
aNumber
ToURelativeDateTimeUnit
(
aUnit
)
target
length
status
)
;
}
)
;
}
}
Result
<
Span
<
const
char16_t
>
ICUError
>
formatToParts
(
double
aNumber
FormatUnit
aUnit
NumberPartVector
&
aParts
)
const
;
private
:
RelativeTimeFormatOptions
:
:
Numeric
mNumeric
=
RelativeTimeFormatOptions
:
:
Numeric
:
:
Always
;
URelativeDateTimeFormatter
*
mFormatter
=
nullptr
;
UFormattedRelativeDateTime
*
mFormattedRelativeDateTime
=
nullptr
;
static
constexpr
size_t
StackU16VectorSize
=
128
;
URelativeDateTimeUnit
ToURelativeDateTimeUnit
(
FormatUnit
unit
)
const
;
}
;
}
}
#
endif
