#
ifndef
intl_components_DateTimeFormat_h_
#
define
intl_components_DateTimeFormat_h_
#
include
"
unicode
/
udat
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
:
:
intl
{
enum
class
DateTimeStyle
{
Full
Long
Medium
Short
None
}
;
class
DateTimeFormat
final
{
public
:
DateTimeFormat
(
const
DateTimeFormat
&
)
=
delete
;
DateTimeFormat
&
operator
=
(
const
DateTimeFormat
&
)
=
delete
;
enum
class
StyleError
{
DateFormatFailure
}
;
static
Result
<
UniquePtr
<
DateTimeFormat
>
DateTimeFormat
:
:
StyleError
>
TryCreateFromStyle
(
Span
<
const
char
>
aLocale
DateTimeStyle
aDateStyle
DateTimeStyle
aTimeStyle
Maybe
<
Span
<
const
char16_t
>
>
aTimeZoneOverride
=
Nothing
{
}
)
;
enum
class
SkeletonError
{
OutOfMemory
PatternGeneratorFailure
GetBestPatternFailure
DateFormatFailure
}
;
static
Result
<
UniquePtr
<
DateTimeFormat
>
DateTimeFormat
:
:
SkeletonError
>
TryCreateFromSkeleton
(
Span
<
const
char
>
aLocale
Span
<
const
char
>
aSkeleton
Maybe
<
Span
<
const
char
>
>
aTimeZoneOverride
=
Nothing
{
}
)
;
static
Result
<
UniquePtr
<
DateTimeFormat
>
DateTimeFormat
:
:
SkeletonError
>
TryCreateFromSkeleton
(
Span
<
const
char
>
aLocale
Span
<
const
char16_t
>
aSkeleton
Maybe
<
Span
<
const
char16_t
>
>
aTimeZoneOverride
=
Nothing
{
}
)
;
enum
class
PatternError
{
DateFormatFailure
}
;
static
Result
<
UniquePtr
<
DateTimeFormat
>
DateTimeFormat
:
:
PatternError
>
TryCreateFromPattern
(
Span
<
const
char
>
aLocale
Span
<
const
char16_t
>
aPattern
Maybe
<
Span
<
const
char16_t
>
>
aTimeZoneOverride
=
Nothing
{
}
)
;
template
<
typename
B
>
ICUResult
TryFormat
(
double
aUnixEpoch
B
&
aBuffer
)
const
{
static_assert
(
std
:
:
is_same
<
typename
B
:
:
CharType
unsigned
char
>
:
:
value
|
|
std
:
:
is_same
<
typename
B
:
:
CharType
char
>
:
:
value
|
|
std
:
:
is_same
<
typename
B
:
:
CharType
char16_t
>
:
:
value
"
The
only
buffer
CharTypes
supported
by
DateTimeFormat
are
char
"
"
(
for
UTF
-
8
support
)
and
char16_t
(
for
UTF
-
16
support
)
.
"
)
;
if
constexpr
(
std
:
:
is_same
<
typename
B
:
:
CharType
char
>
:
:
value
|
|
std
:
:
is_same
<
typename
B
:
:
CharType
unsigned
char
>
:
:
value
)
{
mozilla
:
:
Vector
<
char16_t
StackU16VectorSize
>
u16Vec
;
auto
result
=
FillVectorWithICUCall
(
u16Vec
[
this
&
aUnixEpoch
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
udat_format
(
mDateFormat
aUnixEpoch
target
length
nullptr
status
)
;
}
)
;
if
(
result
.
isErr
(
)
)
{
return
result
;
}
if
(
!
FillUTF8Buffer
(
u16Vec
aBuffer
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
return
Ok
{
}
;
}
else
{
static_assert
(
std
:
:
is_same
<
typename
B
:
:
CharType
char16_t
>
:
:
value
)
;
return
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
udat_format
(
mDateFormat
aUnixEpoch
target
length
nullptr
status
)
;
}
)
;
}
}
;
template
<
typename
B
>
ICUResult
GetPattern
(
B
&
aBuffer
)
const
{
return
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
udat_toPattern
(
mDateFormat
false
target
length
status
)
;
}
)
;
}
void
SetStartTimeIfGregorian
(
double
aTime
)
;
~
DateTimeFormat
(
)
;
UDateFormat
*
UnsafeGetUDateFormat
(
)
const
{
return
mDateFormat
;
}
private
:
explicit
DateTimeFormat
(
UDateFormat
*
aDateFormat
)
;
static
constexpr
size_t
StackU16VectorSize
=
128
;
UDateFormat
*
mDateFormat
=
nullptr
;
}
;
}
#
endif
