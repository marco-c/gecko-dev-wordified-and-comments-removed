#
ifndef
intl_components_Locale_h
#
define
intl_components_Locale_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
intl
/
ICUError
.
h
"
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
<
algorithm
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
utility
>
#
include
"
unicode
/
uloc
.
h
"
namespace
mozilla
:
:
intl
{
template
<
typename
CharT
>
bool
IsStructurallyValidLanguageTag
(
mozilla
:
:
Span
<
const
CharT
>
language
)
;
template
<
typename
CharT
>
bool
IsStructurallyValidScriptTag
(
mozilla
:
:
Span
<
const
CharT
>
script
)
;
template
<
typename
CharT
>
bool
IsStructurallyValidRegionTag
(
mozilla
:
:
Span
<
const
CharT
>
region
)
;
#
ifdef
DEBUG
bool
IsStructurallyValidVariantTag
(
mozilla
:
:
Span
<
const
char
>
variant
)
;
bool
IsStructurallyValidUnicodeExtensionTag
(
mozilla
:
:
Span
<
const
char
>
extension
)
;
bool
IsStructurallyValidPrivateUseTag
(
mozilla
:
:
Span
<
const
char
>
privateUse
)
;
#
endif
template
<
typename
CharT
>
char
AsciiToLowerCase
(
CharT
c
)
{
MOZ_ASSERT
(
mozilla
:
:
IsAscii
(
c
)
)
;
return
mozilla
:
:
IsAsciiUppercaseAlpha
(
c
)
?
(
c
+
0x20
)
:
c
;
}
template
<
typename
CharT
>
char
AsciiToUpperCase
(
CharT
c
)
{
MOZ_ASSERT
(
mozilla
:
:
IsAscii
(
c
)
)
;
return
mozilla
:
:
IsAsciiLowercaseAlpha
(
c
)
?
(
c
-
0x20
)
:
c
;
}
template
<
typename
CharT
>
void
AsciiToLowerCase
(
CharT
*
chars
size_t
length
char
*
dest
)
{
char
(
&
fn
)
(
CharT
)
=
AsciiToLowerCase
;
std
:
:
transform
(
chars
chars
+
length
dest
fn
)
;
}
template
<
typename
CharT
>
void
AsciiToUpperCase
(
CharT
*
chars
size_t
length
char
*
dest
)
{
char
(
&
fn
)
(
CharT
)
=
AsciiToUpperCase
;
std
:
:
transform
(
chars
chars
+
length
dest
fn
)
;
}
template
<
typename
CharT
>
void
AsciiToTitleCase
(
CharT
*
chars
size_t
length
char
*
dest
)
{
if
(
length
>
0
)
{
AsciiToUpperCase
(
chars
1
dest
)
;
AsciiToLowerCase
(
chars
+
1
length
-
1
dest
+
1
)
;
}
}
namespace
LanguageTagLimits
{
static
constexpr
size_t
LanguageLength
=
8
;
static
constexpr
size_t
ScriptLength
=
4
;
static
constexpr
size_t
RegionLength
=
3
;
static
constexpr
size_t
AlphaRegionLength
=
2
;
static
constexpr
size_t
DigitRegionLength
=
3
;
static
constexpr
size_t
UnicodeKeyLength
=
2
;
static
constexpr
size_t
TransformKeyLength
=
2
;
}
template
<
size_t
Length
>
class
LanguageTagSubtag
final
{
uint8_t
length_
=
0
;
char
chars_
[
Length
]
=
{
}
;
public
:
LanguageTagSubtag
(
)
=
default
;
LanguageTagSubtag
(
const
LanguageTagSubtag
&
)
=
delete
;
LanguageTagSubtag
&
operator
=
(
const
LanguageTagSubtag
&
)
=
delete
;
size_t
length
(
)
const
{
return
length_
;
}
bool
missing
(
)
const
{
return
length_
=
=
0
;
}
bool
present
(
)
const
{
return
length_
>
0
;
}
mozilla
:
:
Span
<
const
char
>
span
(
)
const
{
return
{
chars_
length_
}
;
}
template
<
typename
CharT
>
void
set
(
mozilla
:
:
Span
<
const
CharT
>
str
)
{
MOZ_ASSERT
(
str
.
size
(
)
<
=
Length
)
;
std
:
:
copy_n
(
str
.
data
(
)
str
.
size
(
)
chars_
)
;
length_
=
str
.
size
(
)
;
}
void
toLowerCase
(
)
{
AsciiToLowerCase
(
chars_
Length
chars_
)
;
}
void
toUpperCase
(
)
{
AsciiToUpperCase
(
chars_
Length
chars_
)
;
}
void
toTitleCase
(
)
{
AsciiToTitleCase
(
chars_
Length
chars_
)
;
}
template
<
size_t
N
>
bool
equalTo
(
const
char
(
&
str
)
[
N
]
)
const
{
static_assert
(
N
-
1
<
=
Length
"
subtag
literals
must
not
exceed
the
maximum
subtag
length
"
)
;
return
length_
=
=
N
-
1
&
&
memcmp
(
chars_
str
N
-
1
)
=
=
0
;
}
}
;
using
LanguageSubtag
=
LanguageTagSubtag
<
LanguageTagLimits
:
:
LanguageLength
>
;
using
ScriptSubtag
=
LanguageTagSubtag
<
LanguageTagLimits
:
:
ScriptLength
>
;
using
RegionSubtag
=
LanguageTagSubtag
<
LanguageTagLimits
:
:
RegionLength
>
;
using
Latin1Char
=
unsigned
char
;
using
UniqueChars
=
UniquePtr
<
char
[
]
>
;
class
MOZ_STACK_CLASS
Locale
final
{
LanguageSubtag
language_
=
{
}
;
ScriptSubtag
script_
=
{
}
;
RegionSubtag
region_
=
{
}
;
using
VariantsVector
=
Vector
<
UniqueChars
2
>
;
using
ExtensionsVector
=
Vector
<
UniqueChars
2
>
;
VariantsVector
variants_
;
ExtensionsVector
extensions_
;
UniqueChars
privateuse_
=
nullptr
;
friend
class
LocaleParser
;
public
:
enum
class
CanonicalizationError
:
uint8_t
{
DuplicateVariant
InternalError
OutOfMemory
}
;
private
:
Result
<
Ok
CanonicalizationError
>
canonicalizeUnicodeExtension
(
UniqueChars
&
unicodeExtension
)
;
Result
<
Ok
CanonicalizationError
>
canonicalizeTransformExtension
(
UniqueChars
&
transformExtension
)
;
public
:
static
bool
languageMapping
(
LanguageSubtag
&
language
)
;
static
bool
complexLanguageMapping
(
const
LanguageSubtag
&
language
)
;
private
:
static
bool
scriptMapping
(
ScriptSubtag
&
script
)
;
static
bool
regionMapping
(
RegionSubtag
&
region
)
;
static
bool
complexRegionMapping
(
const
RegionSubtag
&
region
)
;
void
performComplexLanguageMappings
(
)
;
void
performComplexRegionMappings
(
)
;
[
[
nodiscard
]
]
bool
performVariantMappings
(
)
;
[
[
nodiscard
]
]
bool
updateLegacyMappings
(
)
;
static
bool
signLanguageMapping
(
LanguageSubtag
&
language
const
RegionSubtag
&
region
)
;
static
const
char
*
replaceTransformExtensionType
(
mozilla
:
:
Span
<
const
char
>
key
mozilla
:
:
Span
<
const
char
>
type
)
;
public
:
static
const
char
*
replaceUnicodeExtensionType
(
mozilla
:
:
Span
<
const
char
>
key
mozilla
:
:
Span
<
const
char
>
type
)
;
public
:
Locale
(
)
=
default
;
Locale
(
const
Locale
&
)
=
delete
;
Locale
&
operator
=
(
const
Locale
&
)
=
delete
;
const
LanguageSubtag
&
language
(
)
const
{
return
language_
;
}
const
ScriptSubtag
&
script
(
)
const
{
return
script_
;
}
const
RegionSubtag
&
region
(
)
const
{
return
region_
;
}
const
auto
&
variants
(
)
const
{
return
variants_
;
}
const
auto
&
extensions
(
)
const
{
return
extensions_
;
}
const
char
*
privateuse
(
)
const
{
return
privateuse_
.
get
(
)
;
}
const
char
*
unicodeExtension
(
)
const
;
private
:
ptrdiff_t
unicodeExtensionIndex
(
)
const
;
public
:
template
<
size_t
N
>
void
setLanguage
(
const
char
(
&
language
)
[
N
]
)
{
mozilla
:
:
Span
<
const
char
>
span
(
language
N
-
1
)
;
MOZ_ASSERT
(
IsStructurallyValidLanguageTag
(
span
)
)
;
language_
.
set
(
span
)
;
}
void
setLanguage
(
const
LanguageSubtag
&
language
)
{
MOZ_ASSERT
(
IsStructurallyValidLanguageTag
(
language
.
span
(
)
)
)
;
language_
.
set
(
language
.
span
(
)
)
;
}
template
<
size_t
N
>
void
setScript
(
const
char
(
&
script
)
[
N
]
)
{
mozilla
:
:
Span
<
const
char
>
span
(
script
N
-
1
)
;
MOZ_ASSERT
(
IsStructurallyValidScriptTag
(
span
)
)
;
script_
.
set
(
span
)
;
}
void
setScript
(
const
ScriptSubtag
&
script
)
{
MOZ_ASSERT
(
script
.
missing
(
)
|
|
IsStructurallyValidScriptTag
(
script
.
span
(
)
)
)
;
script_
.
set
(
script
.
span
(
)
)
;
}
template
<
size_t
N
>
void
setRegion
(
const
char
(
&
region
)
[
N
]
)
{
mozilla
:
:
Span
<
const
char
>
span
(
region
N
-
1
)
;
MOZ_ASSERT
(
IsStructurallyValidRegionTag
(
span
)
)
;
region_
.
set
(
span
)
;
}
void
setRegion
(
const
RegionSubtag
&
region
)
{
MOZ_ASSERT
(
region
.
missing
(
)
|
|
IsStructurallyValidRegionTag
(
region
.
span
(
)
)
)
;
region_
.
set
(
region
.
span
(
)
)
;
}
void
clearVariants
(
)
{
variants_
.
clearAndFree
(
)
;
}
ICUResult
setUnicodeExtension
(
Span
<
const
char
>
extension
)
;
void
clearUnicodeExtension
(
)
;
Result
<
Ok
CanonicalizationError
>
canonicalizeBaseName
(
)
;
Result
<
Ok
CanonicalizationError
>
canonicalizeExtensions
(
)
;
Result
<
Ok
CanonicalizationError
>
canonicalize
(
)
{
MOZ_TRY
(
canonicalizeBaseName
(
)
)
;
return
canonicalizeExtensions
(
)
;
}
template
<
typename
B
>
ICUResult
toString
(
B
&
buffer
)
const
{
static_assert
(
std
:
:
is_same_v
<
typename
B
:
:
CharType
char
>
)
;
size_t
capacity
=
toStringCapacity
(
)
;
if
(
!
buffer
.
reserve
(
capacity
)
)
{
return
Err
(
ICUError
:
:
OutOfMemory
)
;
}
size_t
offset
=
toStringAppend
(
buffer
.
data
(
)
)
;
MOZ_ASSERT
(
capacity
=
=
offset
)
;
buffer
.
written
(
offset
)
;
return
Ok
(
)
;
}
ICUResult
addLikelySubtags
(
)
;
ICUResult
removeLikelySubtags
(
)
;
static
const
char
*
GetDefaultLocale
(
)
{
return
uloc_getDefault
(
)
;
}
static
auto
GetAvailableLocales
(
)
{
return
AvailableLocalesEnumeration
<
uloc_countAvailable
uloc_getAvailable
>
(
)
;
}
private
:
static
UniqueChars
DuplicateStringToUniqueChars
(
const
char
*
s
)
;
static
UniqueChars
DuplicateStringToUniqueChars
(
Span
<
const
char
>
s
)
;
size_t
toStringCapacity
(
)
const
;
size_t
toStringAppend
(
char
*
buffer
)
const
;
}
;
class
MOZ_STACK_CLASS
LocaleParser
final
{
public
:
enum
class
ParserError
:
uint8_t
{
NotParseable
OutOfMemory
}
;
enum
class
TokenKind
:
uint8_t
{
None
=
0b000
Alpha
=
0b001
Digit
=
0b010
AlphaDigit
=
0b011
Error
=
0b100
}
;
private
:
class
Token
final
{
size_t
index_
;
size_t
length_
;
TokenKind
kind_
;
public
:
Token
(
TokenKind
kind
size_t
index
size_t
length
)
:
index_
(
index
)
length_
(
length
)
kind_
(
kind
)
{
}
TokenKind
kind
(
)
const
{
return
kind_
;
}
size_t
index
(
)
const
{
return
index_
;
}
size_t
length
(
)
const
{
return
length_
;
}
bool
isError
(
)
const
{
return
kind_
=
=
TokenKind
:
:
Error
;
}
bool
isNone
(
)
const
{
return
kind_
=
=
TokenKind
:
:
None
;
}
bool
isAlpha
(
)
const
{
return
kind_
=
=
TokenKind
:
:
Alpha
;
}
bool
isDigit
(
)
const
{
return
kind_
=
=
TokenKind
:
:
Digit
;
}
bool
isAlphaDigit
(
)
const
{
return
kind_
=
=
TokenKind
:
:
AlphaDigit
;
}
}
;
const
char
*
locale_
;
size_t
length_
;
size_t
index_
=
0
;
explicit
LocaleParser
(
Span
<
const
char
>
locale
)
:
locale_
(
locale
.
data
(
)
)
length_
(
locale
.
size
(
)
)
{
}
char
charAt
(
size_t
index
)
const
{
return
locale_
[
index
]
;
}
template
<
size_t
N
>
void
copyChars
(
const
Token
&
tok
LanguageTagSubtag
<
N
>
&
subtag
)
const
{
subtag
.
set
(
mozilla
:
:
Span
(
locale_
+
tok
.
index
(
)
tok
.
length
(
)
)
)
;
}
UniqueChars
chars
(
size_t
index
size_t
length
)
const
;
UniqueChars
chars
(
const
Token
&
tok
)
const
{
return
chars
(
tok
.
index
(
)
tok
.
length
(
)
)
;
}
UniqueChars
extension
(
const
Token
&
start
const
Token
&
end
)
const
{
MOZ_ASSERT
(
start
.
index
(
)
<
end
.
index
(
)
)
;
size_t
length
=
end
.
index
(
)
-
1
-
start
.
index
(
)
;
return
chars
(
start
.
index
(
)
length
)
;
}
Token
nextToken
(
)
;
bool
isLanguage
(
const
Token
&
tok
)
const
{
return
tok
.
isAlpha
(
)
&
&
(
(
2
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
3
)
|
|
(
5
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
)
)
;
}
bool
isScript
(
const
Token
&
tok
)
const
{
return
tok
.
isAlpha
(
)
&
&
tok
.
length
(
)
=
=
4
;
}
bool
isRegion
(
const
Token
&
tok
)
const
{
return
(
tok
.
isAlpha
(
)
&
&
tok
.
length
(
)
=
=
2
)
|
|
(
tok
.
isDigit
(
)
&
&
tok
.
length
(
)
=
=
3
)
;
}
bool
isVariant
(
const
Token
&
tok
)
const
{
return
(
5
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
)
|
|
(
tok
.
length
(
)
=
=
4
&
&
mozilla
:
:
IsAsciiDigit
(
charAt
(
tok
.
index
(
)
)
)
)
;
}
char
singletonKey
(
const
Token
&
tok
)
const
{
MOZ_ASSERT
(
tok
.
length
(
)
=
=
1
)
;
return
AsciiToLowerCase
(
charAt
(
tok
.
index
(
)
)
)
;
}
bool
isExtensionStart
(
const
Token
&
tok
)
const
{
return
tok
.
length
(
)
=
=
1
&
&
singletonKey
(
tok
)
!
=
'
x
'
;
}
bool
isOtherExtensionPart
(
const
Token
&
tok
)
const
{
return
2
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
bool
isUnicodeExtensionPart
(
const
Token
&
tok
)
const
{
return
isUnicodeExtensionKey
(
tok
)
|
|
isUnicodeExtensionType
(
tok
)
|
|
isUnicodeExtensionAttribute
(
tok
)
;
}
bool
isUnicodeExtensionAttribute
(
const
Token
&
tok
)
const
{
return
3
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
bool
isUnicodeExtensionKey
(
const
Token
&
tok
)
const
{
return
tok
.
length
(
)
=
=
2
&
&
mozilla
:
:
IsAsciiAlpha
(
charAt
(
tok
.
index
(
)
+
1
)
)
;
}
bool
isUnicodeExtensionType
(
const
Token
&
tok
)
const
{
return
3
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
bool
isTransformExtensionKey
(
const
Token
&
tok
)
const
{
return
tok
.
length
(
)
=
=
2
&
&
mozilla
:
:
IsAsciiAlpha
(
charAt
(
tok
.
index
(
)
)
)
&
&
mozilla
:
:
IsAsciiDigit
(
charAt
(
tok
.
index
(
)
+
1
)
)
;
}
bool
isTransformExtensionPart
(
const
Token
&
tok
)
const
{
return
3
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
bool
isPrivateUseStart
(
const
Token
&
tok
)
const
{
return
tok
.
length
(
)
=
=
1
&
&
singletonKey
(
tok
)
=
=
'
x
'
;
}
bool
isPrivateUsePart
(
const
Token
&
tok
)
const
{
return
1
<
=
tok
.
length
(
)
&
&
tok
.
length
(
)
<
=
8
;
}
static
Result
<
Ok
ParserError
>
internalParseBaseName
(
LocaleParser
&
ts
Locale
&
tag
Token
&
tok
)
;
static
Result
<
Ok
ParserError
>
parseBaseName
(
LocaleParser
&
ts
Locale
&
tag
Token
&
tok
)
{
return
internalParseBaseName
(
ts
tag
tok
)
;
}
static
Result
<
Ok
ParserError
>
parseTlangInTransformExtension
(
LocaleParser
&
ts
Locale
&
tag
Token
&
tok
)
{
MOZ_ASSERT
(
ts
.
isLanguage
(
tok
)
)
;
return
internalParseBaseName
(
ts
tag
tok
)
;
}
friend
class
Locale
;
class
Range
final
{
size_t
begin_
;
size_t
length_
;
public
:
Range
(
size_t
begin
size_t
length
)
:
begin_
(
begin
)
length_
(
length
)
{
}
size_t
begin
(
)
const
{
return
begin_
;
}
size_t
length
(
)
const
{
return
length_
;
}
}
;
using
TFieldVector
=
Vector
<
Range
8
>
;
using
AttributesVector
=
Vector
<
Range
8
>
;
using
KeywordsVector
=
Vector
<
Range
8
>
;
static
Result
<
Ok
ParserError
>
parseTransformExtension
(
mozilla
:
:
Span
<
const
char
>
extension
Locale
&
tag
TFieldVector
&
fields
)
;
static
Result
<
Ok
ParserError
>
parseUnicodeExtension
(
mozilla
:
:
Span
<
const
char
>
extension
AttributesVector
&
attributes
KeywordsVector
&
keywords
)
;
public
:
static
Result
<
Ok
ParserError
>
tryParse
(
Span
<
const
char
>
locale
Locale
&
tag
)
;
static
Result
<
Ok
ParserError
>
tryParseBaseName
(
Span
<
const
char
>
locale
Locale
&
tag
)
;
static
Result
<
Ok
ParserError
>
canParseUnicodeExtension
(
Span
<
const
char
>
extension
)
;
static
Result
<
Ok
ParserError
>
canParseUnicodeExtensionType
(
Span
<
const
char
>
unicodeType
)
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
LocaleParser
:
:
TokenKind
)
}
#
endif
