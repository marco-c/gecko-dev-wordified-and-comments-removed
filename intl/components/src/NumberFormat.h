#
ifndef
intl_components_NumberFormat_h_
#
define
intl_components_NumberFormat_h_
#
include
<
string_view
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
unicode
/
unum
.
h
"
#
include
"
unicode
/
unumberformatter
.
h
"
namespace
mozilla
{
namespace
intl
{
struct
MOZ_STACK_CLASS
NumberFormatOptions
{
enum
class
CurrencyDisplayStyle
{
Symbol
Code
Name
NarrowSymbol
}
;
Maybe
<
std
:
:
pair
<
std
:
:
string_view
CurrencyDisplayStyle
>
>
mCurrency
;
Maybe
<
std
:
:
pair
<
uint32_t
uint32_t
>
>
mFractionDigits
;
Maybe
<
uint32_t
>
mMinIntegerDigits
;
Maybe
<
std
:
:
pair
<
uint32_t
uint32_t
>
>
mSignificantDigits
;
enum
class
UnitDisplay
{
Short
Narrow
Long
}
;
Maybe
<
std
:
:
pair
<
std
:
:
string_view
UnitDisplay
>
>
mUnit
;
bool
mPercent
=
false
;
bool
mUseGrouping
=
true
;
enum
class
Notation
{
Standard
Scientific
Engineering
CompactShort
CompactLong
}
mNotation
=
Notation
:
:
Standard
;
enum
class
SignDisplay
{
Auto
Never
Always
ExceptZero
Accounting
AccountingAlways
AccountingExceptZero
}
mSignDisplay
=
SignDisplay
:
:
Auto
;
bool
mRoundingModeHalfUp
=
true
;
}
;
class
NumberFormat
final
{
public
:
explicit
NumberFormat
(
std
:
:
string_view
aLocale
const
NumberFormatOptions
&
aOptions
=
{
}
)
;
~
NumberFormat
(
)
;
const
char16_t
*
format
(
double
number
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
nullptr
;
}
return
formatResult
(
)
.
data
(
)
;
}
template
<
typename
B
>
bool
format
(
double
number
B
&
buffer
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
false
;
}
return
formatResult
<
typename
B
:
:
CharType
B
>
(
buffer
)
;
}
const
char16_t
*
format
(
int64_t
number
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
nullptr
;
}
return
formatResult
(
)
.
data
(
)
;
}
template
<
typename
B
>
bool
format
(
int64_t
number
B
&
buffer
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
false
;
}
return
formatResult
<
typename
B
:
:
CharType
B
>
(
buffer
)
;
}
const
char16_t
*
format
(
std
:
:
string_view
number
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
nullptr
;
}
return
formatResult
(
)
.
data
(
)
;
}
template
<
typename
B
>
bool
format
(
std
:
:
string_view
number
B
&
buffer
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
false
;
}
return
formatResult
<
typename
B
:
:
CharType
B
>
(
buffer
)
;
}
private
:
UNumberFormatter
*
mNumberFormatter
=
nullptr
;
UFormattedNumber
*
mFormattedNumber
=
nullptr
;
bool
mIsInitialized
=
false
;
bool
formatInternal
(
double
number
)
const
;
bool
formatInternal
(
int64_t
number
)
const
;
bool
formatInternal
(
std
:
:
string_view
number
)
const
;
std
:
:
u16string_view
formatResult
(
)
const
;
template
<
typename
C
typename
B
>
bool
formatResult
(
B
&
buffer
)
const
{
std
:
:
u16string_view
result
=
formatResult
(
)
;
if
(
result
.
empty
(
)
)
{
return
false
;
}
if
constexpr
(
std
:
:
is_same
<
C
uint8_t
>
:
:
value
)
{
if
(
!
buffer
.
allocate
(
3
*
result
.
size
(
)
)
)
{
return
false
;
}
size_t
amount
=
ConvertUtf16toUtf8
(
Span
(
result
.
data
(
)
result
.
size
(
)
)
Span
(
static_cast
<
char
*
>
(
std
:
:
data
(
buffer
)
)
std
:
:
size
(
buffer
)
)
)
;
buffer
.
written
(
amount
)
;
}
else
{
if
(
!
buffer
.
allocate
(
result
.
size
(
)
)
)
{
return
false
;
}
PodCopy
(
static_cast
<
char16_t
*
>
(
buffer
.
data
(
)
)
result
.
data
(
)
result
.
size
(
)
)
;
buffer
.
written
(
result
.
size
(
)
)
;
}
return
true
;
}
}
;
}
}
#
endif
