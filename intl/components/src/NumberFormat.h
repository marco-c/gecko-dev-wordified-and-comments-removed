#
ifndef
intl_components_NumberFormat_h_
#
define
intl_components_NumberFormat_h_
#
include
<
string_view
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
unicode
/
ustring
.
h
"
#
include
"
unicode
/
unum
.
h
"
#
include
"
unicode
/
unumberformatter
.
h
"
namespace
mozilla
{
namespace
intl
{
struct
MOZ_STACK_CLASS
NumberFormatOptions
{
enum
class
CurrencyDisplay
{
Symbol
Code
Name
NarrowSymbol
}
;
Maybe
<
std
:
:
pair
<
std
:
:
string_view
CurrencyDisplay
>
>
mCurrency
;
Maybe
<
std
:
:
pair
<
uint32_t
uint32_t
>
>
mFractionDigits
;
Maybe
<
uint32_t
>
mMinIntegerDigits
;
Maybe
<
std
:
:
pair
<
uint32_t
uint32_t
>
>
mSignificantDigits
;
enum
class
UnitDisplay
{
Short
Narrow
Long
}
;
Maybe
<
std
:
:
pair
<
std
:
:
string_view
UnitDisplay
>
>
mUnit
;
bool
mPercent
=
false
;
bool
mUseGrouping
=
true
;
enum
class
Notation
{
Standard
Scientific
Engineering
CompactShort
CompactLong
}
mNotation
=
Notation
:
:
Standard
;
enum
class
SignDisplay
{
Auto
Never
Always
ExceptZero
Accounting
AccountingAlways
AccountingExceptZero
}
mSignDisplay
=
SignDisplay
:
:
Auto
;
bool
mRoundingModeHalfUp
=
true
;
}
;
enum
class
NumberPartType
{
Compact
Currency
Decimal
ExponentInteger
ExponentMinusSign
ExponentSeparator
Fraction
Group
Infinity
Integer
Literal
MinusSign
Nan
Percent
PlusSign
Unit
}
;
using
NumberPart
=
std
:
:
pair
<
NumberPartType
size_t
>
;
using
NumberPartVector
=
mozilla
:
:
Vector
<
NumberPart
8
*
sizeof
(
NumberPart
)
>
;
class
NumberFormat
final
{
public
:
explicit
NumberFormat
(
std
:
:
string_view
aLocale
const
NumberFormatOptions
&
aOptions
=
{
}
)
;
~
NumberFormat
(
)
;
enum
class
FormatError
{
InternalError
OutOfMemory
}
;
Result
<
std
:
:
u16string_view
NumberFormat
:
:
FormatError
>
format
(
double
number
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
Err
(
FormatError
:
:
InternalError
)
;
}
return
formatResult
(
)
;
}
Result
<
std
:
:
u16string_view
NumberFormat
:
:
FormatError
>
formatToParts
(
double
number
NumberPartVector
&
parts
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
Err
(
FormatError
:
:
InternalError
)
;
}
bool
isNegative
=
!
IsNaN
(
number
)
&
&
IsNegative
(
number
)
;
return
formatResultToParts
(
Some
(
number
)
isNegative
parts
)
;
}
template
<
typename
B
>
Result
<
Ok
NumberFormat
:
:
FormatError
>
format
(
double
number
B
&
buffer
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
Err
(
FormatError
:
:
InternalError
)
;
}
return
formatResult
<
typename
B
:
:
CharType
B
>
(
buffer
)
;
}
Result
<
std
:
:
u16string_view
NumberFormat
:
:
FormatError
>
format
(
int64_t
number
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
Err
(
FormatError
:
:
InternalError
)
;
}
return
formatResult
(
)
;
}
Result
<
std
:
:
u16string_view
NumberFormat
:
:
FormatError
>
formatToParts
(
int64_t
number
NumberPartVector
&
parts
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
Err
(
FormatError
:
:
InternalError
)
;
}
return
formatResultToParts
(
Nothing
(
)
number
<
0
parts
)
;
}
template
<
typename
B
>
Result
<
Ok
NumberFormat
:
:
FormatError
>
format
(
int64_t
number
B
&
buffer
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
Err
(
FormatError
:
:
InternalError
)
;
}
return
formatResult
<
typename
B
:
:
CharType
B
>
(
buffer
)
;
}
Result
<
std
:
:
u16string_view
NumberFormat
:
:
FormatError
>
format
(
std
:
:
string_view
number
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
Err
(
FormatError
:
:
InternalError
)
;
}
return
formatResult
(
)
;
}
Result
<
std
:
:
u16string_view
NumberFormat
:
:
FormatError
>
formatToParts
(
std
:
:
string_view
number
NumberPartVector
&
parts
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
Err
(
FormatError
:
:
InternalError
)
;
}
bool
isNegative
=
!
number
.
empty
(
)
&
&
number
[
0
]
=
=
'
-
'
;
return
formatResultToParts
(
Nothing
(
)
isNegative
parts
)
;
}
template
<
typename
B
>
Result
<
Ok
NumberFormat
:
:
FormatError
>
format
(
std
:
:
string_view
number
B
&
buffer
)
const
{
if
(
!
mIsInitialized
|
|
!
formatInternal
(
number
)
)
{
return
Err
(
FormatError
:
:
InternalError
)
;
}
return
formatResult
<
typename
B
:
:
CharType
B
>
(
buffer
)
;
}
private
:
UNumberFormatter
*
mNumberFormatter
=
nullptr
;
UFormattedNumber
*
mFormattedNumber
=
nullptr
;
bool
mFormatForUnit
=
false
;
bool
mIsInitialized
=
false
;
[
[
nodiscard
]
]
bool
formatInternal
(
double
number
)
const
;
[
[
nodiscard
]
]
bool
formatInternal
(
int64_t
number
)
const
;
[
[
nodiscard
]
]
bool
formatInternal
(
std
:
:
string_view
number
)
const
;
Maybe
<
NumberPartType
>
GetPartTypeForNumberField
(
UNumberFormatFields
fieldName
Maybe
<
double
>
number
bool
isNegative
)
const
;
Result
<
std
:
:
u16string_view
NumberFormat
:
:
FormatError
>
formatResult
(
)
const
;
Result
<
std
:
:
u16string_view
NumberFormat
:
:
FormatError
>
formatResultToParts
(
const
Maybe
<
double
>
number
bool
isNegative
NumberPartVector
&
parts
)
const
;
template
<
typename
C
typename
B
>
Result
<
Ok
NumberFormat
:
:
FormatError
>
formatResult
(
B
&
buffer
)
const
{
return
formatResult
(
)
.
andThen
(
[
&
buffer
]
(
std
:
:
u16string_view
result
)
-
>
Result
<
Ok
NumberFormat
:
:
FormatError
>
{
if
constexpr
(
std
:
:
is_same
<
C
uint8_t
>
:
:
value
)
{
if
(
!
buffer
.
allocate
(
3
*
result
.
size
(
)
)
)
{
return
Err
(
FormatError
:
:
OutOfMemory
)
;
}
size_t
amount
=
ConvertUtf16toUtf8
(
Span
(
result
.
data
(
)
result
.
size
(
)
)
Span
(
static_cast
<
char
*
>
(
std
:
:
data
(
buffer
)
)
std
:
:
size
(
buffer
)
)
)
;
buffer
.
written
(
amount
)
;
}
else
{
if
(
!
buffer
.
allocate
(
result
.
size
(
)
)
)
{
return
Err
(
FormatError
:
:
OutOfMemory
)
;
}
PodCopy
(
static_cast
<
char16_t
*
>
(
buffer
.
data
(
)
)
result
.
data
(
)
result
.
size
(
)
)
;
buffer
.
written
(
result
.
size
(
)
)
;
}
return
Ok
(
)
;
}
)
;
}
}
;
}
}
#
endif
