#
include
"
unicode
/
ucal
.
h
"
#
include
"
unicode
/
udat
.
h
"
#
include
"
unicode
/
udatpg
.
h
"
#
include
"
ScopedICUObject
.
h
"
#
include
"
mozilla
/
intl
/
DateTimeFormat
.
h
"
namespace
mozilla
:
:
intl
{
DateTimeFormat
:
:
~
DateTimeFormat
(
)
{
MOZ_ASSERT
(
mDateFormat
)
;
udat_close
(
mDateFormat
)
;
}
static
UDateFormatStyle
ToUDateFormatStyle
(
DateTimeStyle
aStyle
)
{
switch
(
aStyle
)
{
case
DateTimeStyle
:
:
Full
:
return
UDAT_FULL
;
case
DateTimeStyle
:
:
Long
:
return
UDAT_LONG
;
case
DateTimeStyle
:
:
Medium
:
return
UDAT_MEDIUM
;
case
DateTimeStyle
:
:
Short
:
return
UDAT_SHORT
;
case
DateTimeStyle
:
:
None
:
return
UDAT_NONE
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
UDAT_NONE
;
}
Result
<
UniquePtr
<
DateTimeFormat
>
DateTimeFormat
:
:
StyleError
>
DateTimeFormat
:
:
TryCreateFromStyle
(
Span
<
const
char
>
aLocale
DateTimeStyle
aDateStyle
DateTimeStyle
aTimeStyle
Maybe
<
Span
<
const
char16_t
>
>
aTimeZoneOverride
)
{
auto
dateStyle
=
ToUDateFormatStyle
(
aDateStyle
)
;
auto
timeStyle
=
ToUDateFormatStyle
(
aTimeStyle
)
;
if
(
dateStyle
=
=
UDAT_NONE
&
&
timeStyle
=
=
UDAT_NONE
)
{
dateStyle
=
UDAT_DEFAULT
;
timeStyle
=
UDAT_DEFAULT
;
}
int32_t
tzIDLength
=
-
1
;
const
UChar
*
tzID
=
nullptr
;
if
(
aTimeZoneOverride
)
{
tzIDLength
=
static_cast
<
int32_t
>
(
aTimeZoneOverride
-
>
size
(
)
)
;
tzID
=
aTimeZoneOverride
-
>
Elements
(
)
;
}
UErrorCode
status
=
U_ZERO_ERROR
;
UDateFormat
*
dateFormat
=
udat_open
(
dateStyle
timeStyle
aLocale
.
data
(
)
tzID
tzIDLength
nullptr
-
1
&
status
)
;
if
(
U_SUCCESS
(
status
)
)
{
return
UniquePtr
<
DateTimeFormat
>
(
new
DateTimeFormat
(
dateFormat
)
)
;
}
return
Err
(
DateTimeFormat
:
:
StyleError
:
:
DateFormatFailure
)
;
}
DateTimeFormat
:
:
DateTimeFormat
(
UDateFormat
*
aDateFormat
)
{
MOZ_RELEASE_ASSERT
(
aDateFormat
"
Expected
aDateFormat
to
not
be
a
nullptr
.
"
)
;
mDateFormat
=
aDateFormat
;
}
Result
<
UniquePtr
<
DateTimeFormat
>
DateTimeFormat
:
:
PatternError
>
DateTimeFormat
:
:
TryCreateFromPattern
(
Span
<
const
char
>
aLocale
Span
<
const
char16_t
>
aPattern
Maybe
<
Span
<
const
char16_t
>
>
aTimeZoneOverride
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
tzIDLength
=
-
1
;
const
UChar
*
tzID
=
nullptr
;
if
(
aTimeZoneOverride
)
{
tzIDLength
=
static_cast
<
int32_t
>
(
aTimeZoneOverride
-
>
size
(
)
)
;
tzID
=
aTimeZoneOverride
-
>
data
(
)
;
}
UDateFormat
*
dateFormat
=
udat_open
(
UDAT_PATTERN
UDAT_PATTERN
static_cast
<
const
char
*
>
(
aLocale
.
data
(
)
)
tzID
tzIDLength
aPattern
.
data
(
)
static_cast
<
int32_t
>
(
aPattern
.
size
(
)
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
PatternError
:
:
DateFormatFailure
)
;
}
return
UniquePtr
<
DateTimeFormat
>
(
new
DateTimeFormat
(
dateFormat
)
)
;
}
Result
<
UniquePtr
<
DateTimeFormat
>
DateTimeFormat
:
:
SkeletonError
>
DateTimeFormat
:
:
TryCreateFromSkeleton
(
Span
<
const
char
>
aLocale
Span
<
const
char16_t
>
aSkeleton
Maybe
<
Span
<
const
char16_t
>
>
aTimeZoneOverride
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UDateTimePatternGenerator
*
dtpg
=
udatpg_open
(
aLocale
.
data
(
)
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
SkeletonError
:
:
PatternGeneratorFailure
)
;
}
ScopedICUObject
<
UDateTimePatternGenerator
udatpg_close
>
datPgToClose
(
dtpg
)
;
mozilla
:
:
Vector
<
char16_t
DateTimeFormat
:
:
StackU16VectorSize
>
bestPattern
;
auto
result
=
FillVectorWithICUCall
(
bestPattern
[
&
dtpg
&
aSkeleton
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
udatpg_getBestPattern
(
dtpg
aSkeleton
.
data
(
)
static_cast
<
int32_t
>
(
aSkeleton
.
size
(
)
)
target
length
status
)
;
}
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
SkeletonError
:
:
GetBestPatternFailure
)
;
}
return
DateTimeFormat
:
:
TryCreateFromPattern
(
aLocale
bestPattern
aTimeZoneOverride
)
.
mapErr
(
[
]
(
DateTimeFormat
:
:
PatternError
error
)
{
switch
(
error
)
{
case
DateTimeFormat
:
:
PatternError
:
:
DateFormatFailure
:
return
SkeletonError
:
:
DateFormatFailure
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
SkeletonError
:
:
DateFormatFailure
;
}
)
;
}
Result
<
UniquePtr
<
DateTimeFormat
>
DateTimeFormat
:
:
SkeletonError
>
DateTimeFormat
:
:
TryCreateFromSkeleton
(
Span
<
const
char
>
aLocale
Span
<
const
char
>
aSkeleton
Maybe
<
Span
<
const
char
>
>
aTimeZoneOverride
)
{
mozilla
:
:
Vector
<
char16_t
DateTimeFormat
:
:
StackU16VectorSize
>
skeletonUtf16Buffer
;
if
(
!
FillUTF16Vector
(
aSkeleton
skeletonUtf16Buffer
)
)
{
return
Err
(
SkeletonError
:
:
OutOfMemory
)
;
}
mozilla
:
:
Vector
<
char16_t
DateTimeFormat
:
:
StackU16VectorSize
>
tzUtf16Vec
;
Maybe
<
Span
<
const
char16_t
>
>
timeZone
=
Nothing
{
}
;
if
(
aTimeZoneOverride
)
{
if
(
!
FillUTF16Vector
(
*
aTimeZoneOverride
tzUtf16Vec
)
)
{
return
Err
(
SkeletonError
:
:
OutOfMemory
)
;
}
;
timeZone
=
Some
(
Span
<
const
char16_t
>
(
tzUtf16Vec
.
begin
(
)
tzUtf16Vec
.
length
(
)
)
)
;
}
return
DateTimeFormat
:
:
TryCreateFromSkeleton
(
aLocale
skeletonUtf16Buffer
timeZone
)
;
}
void
DateTimeFormat
:
:
SetStartTimeIfGregorian
(
double
aTime
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UCalendar
*
cal
=
const_cast
<
UCalendar
*
>
(
udat_getCalendar
(
mDateFormat
)
)
;
ucal_setGregorianChange
(
cal
aTime
&
status
)
;
}
}
