#
include
"
NumberFormatFields
.
h
"
namespace
mozilla
{
namespace
intl
{
bool
NumberFormatFields
:
:
append
(
NumberPartType
type
int32_t
begin
int32_t
end
)
{
MOZ_ASSERT
(
begin
>
=
0
)
;
MOZ_ASSERT
(
end
>
=
0
)
;
MOZ_ASSERT
(
begin
<
end
"
erm
aren
'
t
fields
always
non
-
empty
?
"
)
;
return
fields_
.
emplaceBack
(
uint32_t
(
begin
)
uint32_t
(
end
)
type
)
;
}
bool
NumberFormatFields
:
:
toPartsVector
(
size_t
overallLength
const
NumberPartSourceMap
&
sourceMap
NumberPartVector
&
parts
)
{
std
:
:
sort
(
fields_
.
begin
(
)
fields_
.
end
(
)
[
]
(
const
NumberFormatField
&
left
const
NumberFormatField
&
right
)
{
return
left
.
begin
<
right
.
begin
|
|
(
left
.
begin
=
=
right
.
begin
&
&
left
.
end
>
right
.
end
)
;
}
)
;
class
PartGenerator
{
const
FieldsVector
&
fields
;
size_t
index
=
0
;
uint32_t
lastEnd
=
0
;
const
uint32_t
limit
=
0
;
NumberPartSourceMap
sourceMap
;
Vector
<
size_t
4
>
enclosingFields
;
void
popEnclosingFieldsEndingAt
(
uint32_t
end
)
{
MOZ_ASSERT_IF
(
enclosingFields
.
length
(
)
>
0
fields
[
enclosingFields
.
back
(
)
]
.
end
>
=
end
)
;
while
(
enclosingFields
.
length
(
)
>
0
&
&
fields
[
enclosingFields
.
back
(
)
]
.
end
=
=
end
)
{
enclosingFields
.
popBack
(
)
;
}
}
bool
nextPartInternal
(
NumberPart
*
part
)
{
size_t
len
=
fields
.
length
(
)
;
MOZ_ASSERT
(
index
<
=
len
)
;
if
(
index
=
=
len
)
{
if
(
enclosingFields
.
length
(
)
>
0
)
{
const
auto
&
enclosing
=
fields
[
enclosingFields
.
popCopy
(
)
]
;
*
part
=
{
enclosing
.
type
sourceMap
.
source
(
enclosing
)
enclosing
.
end
}
;
popEnclosingFieldsEndingAt
(
part
-
>
endIndex
)
;
}
else
{
*
part
=
{
NumberPartType
:
:
Literal
sourceMap
.
source
(
limit
)
limit
}
;
}
return
true
;
}
const
NumberFormatField
*
current
=
&
fields
[
index
]
;
MOZ_ASSERT
(
lastEnd
<
=
current
-
>
begin
)
;
MOZ_ASSERT
(
current
-
>
begin
<
current
-
>
end
)
;
if
(
lastEnd
<
current
-
>
begin
)
{
if
(
enclosingFields
.
length
(
)
>
0
)
{
const
auto
&
enclosing
=
fields
[
enclosingFields
.
back
(
)
]
;
*
part
=
{
enclosing
.
type
sourceMap
.
source
(
enclosing
)
std
:
:
min
(
enclosing
.
end
current
-
>
begin
)
}
;
popEnclosingFieldsEndingAt
(
part
-
>
endIndex
)
;
}
else
{
*
part
=
{
NumberPartType
:
:
Literal
sourceMap
.
source
(
current
-
>
begin
)
current
-
>
begin
}
;
}
return
true
;
}
const
NumberFormatField
*
next
;
do
{
current
=
&
fields
[
index
]
;
if
(
+
+
index
=
=
len
)
{
*
part
=
{
current
-
>
type
sourceMap
.
source
(
*
current
)
current
-
>
end
}
;
return
true
;
}
next
=
&
fields
[
index
]
;
MOZ_ASSERT
(
current
-
>
begin
<
=
next
-
>
begin
)
;
MOZ_ASSERT
(
current
-
>
begin
<
next
-
>
end
)
;
if
(
current
-
>
end
>
next
-
>
begin
)
{
if
(
!
enclosingFields
.
append
(
index
-
1
)
)
{
return
false
;
}
}
}
while
(
current
-
>
begin
=
=
next
-
>
begin
)
;
if
(
current
-
>
end
<
=
next
-
>
begin
)
{
*
part
=
{
current
-
>
type
sourceMap
.
source
(
*
current
)
current
-
>
end
}
;
popEnclosingFieldsEndingAt
(
part
-
>
endIndex
)
;
}
else
{
*
part
=
{
current
-
>
type
sourceMap
.
source
(
*
current
)
next
-
>
begin
}
;
}
return
true
;
}
public
:
PartGenerator
(
const
FieldsVector
&
vec
uint32_t
limit
const
NumberPartSourceMap
&
sourceMap
)
:
fields
(
vec
)
limit
(
limit
)
sourceMap
(
sourceMap
)
enclosingFields
(
)
{
}
bool
nextPart
(
bool
*
hasPart
NumberPart
*
part
)
{
if
(
lastEnd
=
=
limit
)
{
MOZ_ASSERT
(
enclosingFields
.
length
(
)
=
=
0
)
;
*
hasPart
=
false
;
return
true
;
}
if
(
!
nextPartInternal
(
part
)
)
{
return
false
;
}
*
hasPart
=
true
;
lastEnd
=
part
-
>
endIndex
;
return
true
;
}
}
;
size_t
lastEndIndex
=
0
;
PartGenerator
gen
(
fields_
overallLength
sourceMap
)
;
do
{
bool
hasPart
;
NumberPart
part
;
if
(
!
gen
.
nextPart
(
&
hasPart
&
part
)
)
{
return
false
;
}
if
(
!
hasPart
)
{
break
;
}
MOZ_ASSERT
(
lastEndIndex
<
part
.
endIndex
)
;
if
(
!
parts
.
append
(
part
)
)
{
return
false
;
}
lastEndIndex
=
part
.
endIndex
;
}
while
(
true
)
;
MOZ_ASSERT
(
lastEndIndex
=
=
overallLength
"
result
array
must
partition
the
entire
string
"
)
;
return
lastEndIndex
=
=
overallLength
;
}
}
}
