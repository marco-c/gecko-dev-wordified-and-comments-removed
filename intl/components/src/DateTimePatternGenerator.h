#
ifndef
intl_components_DateTimePatternGenerator_h_
#
define
intl_components_DateTimePatternGenerator_h_
#
include
"
unicode
/
udatpg
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
mozilla
/
intl
/
ICUError
.
h
"
namespace
mozilla
:
:
intl
{
class
DateTimePatternGenerator
final
{
public
:
explicit
DateTimePatternGenerator
(
UDateTimePatternGenerator
*
aGenerator
)
:
mGenerator
(
aGenerator
)
{
MOZ_ASSERT
(
aGenerator
)
;
}
;
DateTimePatternGenerator
(
DateTimePatternGenerator
&
&
other
)
noexcept
;
DateTimePatternGenerator
&
operator
=
(
DateTimePatternGenerator
&
&
other
)
noexcept
;
DateTimePatternGenerator
(
const
DateTimePatternGenerator
&
)
=
delete
;
DateTimePatternGenerator
&
operator
=
(
const
DateTimePatternGenerator
&
)
=
delete
;
~
DateTimePatternGenerator
(
)
;
static
Result
<
UniquePtr
<
DateTimePatternGenerator
>
ICUError
>
TryCreate
(
const
char
*
aLocale
)
;
enum
class
PatternMatchOption
{
HourField
MinuteField
SecondField
}
;
template
<
typename
B
>
ICUResult
GetBestPattern
(
Span
<
const
char16_t
>
aSkeleton
B
&
aBuffer
EnumSet
<
PatternMatchOption
>
options
=
{
}
)
{
return
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
udatpg_getBestPatternWithOptions
(
mGenerator
.
GetMut
(
)
aSkeleton
.
data
(
)
static_cast
<
int32_t
>
(
aSkeleton
.
Length
(
)
)
toUDateTimePatternMatchOptions
(
options
)
target
length
status
)
;
}
)
;
}
template
<
size_t
S
>
ICUResult
GetBestPattern
(
Span
<
const
char16_t
>
aSkeleton
Vector
<
char16_t
S
>
&
aVector
EnumSet
<
PatternMatchOption
>
options
=
{
}
)
{
return
FillVectorWithICUCall
(
aVector
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
udatpg_getBestPatternWithOptions
(
mGenerator
.
GetMut
(
)
aSkeleton
.
data
(
)
static_cast
<
int32_t
>
(
aSkeleton
.
Length
(
)
)
toUDateTimePatternMatchOptions
(
options
)
target
length
status
)
;
}
)
;
}
template
<
typename
B
>
static
ICUResult
GetSkeleton
(
Span
<
const
char16_t
>
aPattern
B
&
aBuffer
)
{
return
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
udatpg_getSkeleton
(
nullptr
aPattern
.
data
(
)
static_cast
<
int32_t
>
(
aPattern
.
Length
(
)
)
target
length
status
)
;
}
)
;
}
template
<
typename
V
size_t
N
typename
A
>
static
ICUResult
GetSkeleton
(
Span
<
const
char16_t
>
aPattern
Vector
<
V
N
A
>
&
aVector
)
{
return
FillVectorWithICUCall
(
aVector
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
udatpg_getSkeleton
(
nullptr
aPattern
.
data
(
)
static_cast
<
int32_t
>
(
aPattern
.
Length
(
)
)
target
length
status
)
;
}
)
;
}
UDateTimePatternGenerator
*
UnsafeGetUDateTimePatternGenerator
(
)
{
return
mGenerator
.
GetMut
(
)
;
}
private
:
ICUPointer
<
UDateTimePatternGenerator
>
mGenerator
=
ICUPointer
<
UDateTimePatternGenerator
>
(
nullptr
)
;
static
UDateTimePatternMatchOptions
toUDateTimePatternMatchOptions
(
EnumSet
<
PatternMatchOption
>
options
)
{
struct
OptionMap
{
PatternMatchOption
from
;
UDateTimePatternMatchOptions
to
;
}
static
constexpr
map
[
]
=
{
{
PatternMatchOption
:
:
HourField
UDATPG_MATCH_HOUR_FIELD_LENGTH
}
#
ifndef
U_HIDE_INTERNAL_API
{
PatternMatchOption
:
:
MinuteField
UDATPG_MATCH_MINUTE_FIELD_LENGTH
}
{
PatternMatchOption
:
:
SecondField
UDATPG_MATCH_SECOND_FIELD_LENGTH
}
#
endif
}
;
UDateTimePatternMatchOptions
result
=
UDATPG_MATCH_NO_OPTIONS
;
for
(
const
auto
&
entry
:
map
)
{
if
(
options
.
contains
(
entry
.
from
)
)
{
result
=
UDateTimePatternMatchOptions
(
result
|
entry
.
to
)
;
}
}
return
result
;
}
}
;
}
#
endif
