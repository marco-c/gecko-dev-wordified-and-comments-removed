#
include
"
mozilla
/
intl
/
ListFormat
.
h
"
#
include
"
ScopedICUObject
.
h
"
namespace
mozilla
:
:
intl
{
Result
<
UniquePtr
<
ListFormat
>
ICUError
>
ListFormat
:
:
TryCreate
(
mozilla
:
:
Span
<
const
char
>
aLocale
const
Options
&
aOptions
)
{
UListFormatterType
utype
=
ToUListFormatterType
(
aOptions
.
mType
)
;
UListFormatterWidth
uwidth
=
ToUListFormatterWidth
(
aOptions
.
mStyle
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
UListFormatter
*
fmt
=
ulistfmt_openForType
(
IcuLocale
(
AssertNullTerminatedString
(
aLocale
)
)
utype
uwidth
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
return
UniquePtr
<
ListFormat
>
(
new
ListFormat
(
fmt
)
)
;
}
ListFormat
:
:
~
ListFormat
(
)
{
if
(
mListFormatter
)
{
ulistfmt_close
(
mListFormatter
.
GetMut
(
)
)
;
}
}
UListFormatterType
ListFormat
:
:
ToUListFormatterType
(
Type
type
)
{
switch
(
type
)
{
case
Type
:
:
Conjunction
:
return
ULISTFMT_TYPE_AND
;
case
Type
:
:
Disjunction
:
return
ULISTFMT_TYPE_OR
;
case
Type
:
:
Unit
:
return
ULISTFMT_TYPE_UNITS
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
ULISTFMT_TYPE_AND
;
}
UListFormatterWidth
ListFormat
:
:
ToUListFormatterWidth
(
Style
style
)
{
switch
(
style
)
{
case
Style
:
:
Long
:
return
ULISTFMT_WIDTH_WIDE
;
case
Style
:
:
Short
:
return
ULISTFMT_WIDTH_SHORT
;
case
Style
:
:
Narrow
:
return
ULISTFMT_WIDTH_NARROW
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
ULISTFMT_WIDTH_WIDE
;
}
ICUResult
ListFormat
:
:
FormattedToParts
(
const
UFormattedValue
*
formattedValue
mozilla
:
:
Span
<
const
char16_t
>
formattedSpan
PartVector
&
parts
)
{
size_t
lastEndIndex
=
0
;
auto
AppendPart
=
[
&
]
(
PartType
type
size_t
beginIndex
size_t
endIndex
)
{
if
(
!
parts
.
emplaceBack
(
type
formattedSpan
.
FromTo
(
beginIndex
endIndex
)
)
)
{
return
false
;
}
lastEndIndex
=
endIndex
;
return
true
;
}
;
UErrorCode
status
=
U_ZERO_ERROR
;
UConstrainedFieldPosition
*
fpos
=
ucfpos_open
(
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
ScopedICUObject
<
UConstrainedFieldPosition
ucfpos_close
>
toCloseFpos
(
fpos
)
;
ucfpos_constrainField
(
fpos
UFIELD_CATEGORY_LIST
ULISTFMT_ELEMENT_FIELD
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
while
(
true
)
{
bool
hasMore
=
ufmtval_nextPosition
(
formattedValue
fpos
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
if
(
!
hasMore
)
{
break
;
}
int32_t
beginIndexInt
endIndexInt
;
ucfpos_getIndexes
(
fpos
&
beginIndexInt
&
endIndexInt
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
MOZ_ASSERT
(
beginIndexInt
<
=
endIndexInt
"
field
iterator
returning
invalid
range
"
)
;
size_t
beginIndex
=
AssertedCast
<
size_t
>
(
beginIndexInt
)
;
size_t
endIndex
=
AssertedCast
<
size_t
>
(
endIndexInt
)
;
MOZ_ASSERT
(
lastEndIndex
<
=
beginIndex
"
field
iteration
didn
'
t
return
fields
in
order
start
to
"
"
finish
as
expected
"
)
;
if
(
lastEndIndex
<
beginIndex
)
{
if
(
!
AppendPart
(
PartType
:
:
Literal
lastEndIndex
beginIndex
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
}
if
(
!
AppendPart
(
PartType
:
:
Element
beginIndex
endIndex
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
}
if
(
lastEndIndex
<
formattedSpan
.
size
(
)
)
{
if
(
!
AppendPart
(
PartType
:
:
Literal
lastEndIndex
formattedSpan
.
size
(
)
)
)
{
return
Err
(
ICUError
:
:
InternalError
)
;
}
}
return
Ok
(
)
;
}
}
