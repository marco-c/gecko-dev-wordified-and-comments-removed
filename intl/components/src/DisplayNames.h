#
ifndef
intl_components_DisplayNames_h_
#
define
intl_components_DisplayNames_h_
#
include
<
string_view
>
#
include
"
unicode
/
udat
.
h
"
#
include
"
unicode
/
udatpg
.
h
"
#
include
"
unicode
/
uldnames
.
h
"
#
include
"
unicode
/
uloc
.
h
"
#
include
"
unicode
/
ucurr
.
h
"
#
include
"
mozilla
/
intl
/
Calendar
.
h
"
#
include
"
mozilla
/
intl
/
DateTimePatternGenerator
.
h
"
#
include
"
mozilla
/
intl
/
ICU4CGlue
.
h
"
#
include
"
mozilla
/
intl
/
Locale
.
h
"
#
include
"
mozilla
/
Buffer
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
:
:
intl
{
enum
class
DisplayNamesError
{
InternalError
=
2
OutOfMemory
=
4
InvalidOption
=
6
DuplicateVariantSubtag
=
8
InvalidLanguageTag
=
10
}
;
}
namespace
mozilla
:
:
detail
{
template
<
>
struct
UnusedZero
<
intl
:
:
DisplayNamesError
>
:
UnusedZeroEnum
<
intl
:
:
DisplayNamesError
>
{
}
;
template
<
>
struct
HasFreeLSB
<
intl
:
:
DisplayNamesError
>
{
static
constexpr
bool
value
=
true
;
}
;
}
namespace
mozilla
:
:
intl
{
enum
class
Month
:
uint8_t
{
January
=
1
February
March
April
May
June
July
August
September
October
November
December
Undecimber
}
;
enum
class
Quarter
:
uint8_t
{
Q1
=
1
Q2
Q3
Q4
}
;
enum
class
DayPeriod
:
uint8_t
{
AM
=
1
PM
}
;
enum
class
DateTimeField
:
uint8_t
{
Era
=
1
Year
Quarter
Month
WeekOfYear
Weekday
Day
DayPeriod
Hour
Minute
Second
TimeZoneName
}
;
class
DisplayNames
final
{
public
:
enum
class
Style
{
Narrow
Short
Long
Abbreviated
}
;
enum
class
LanguageDisplay
{
Standard
Dialect
}
;
enum
class
Fallback
{
None
Code
}
;
struct
Options
{
Style
style
=
Style
:
:
Long
;
LanguageDisplay
languageDisplay
=
LanguageDisplay
:
:
Standard
;
}
;
DisplayNames
(
ULocaleDisplayNames
*
aDisplayNames
Span
<
const
char
>
aLocale
Options
aOptions
)
:
mOptions
(
aOptions
)
mULocaleDisplayNames
(
aDisplayNames
)
{
MOZ_ASSERT
(
aDisplayNames
)
;
mLocale
=
Buffer
<
char
>
(
aLocale
.
size
(
)
+
1
)
;
PodCopy
(
mLocale
.
begin
(
)
aLocale
.
data
(
)
aLocale
.
size
(
)
)
;
mLocale
[
aLocale
.
size
(
)
]
=
'
\
0
'
;
}
static
Result
<
UniquePtr
<
DisplayNames
>
ICUError
>
TryCreate
(
const
char
*
aLocale
Options
aOptions
)
;
DisplayNames
(
const
DisplayNames
&
)
=
delete
;
DisplayNames
&
operator
=
(
const
DisplayNames
&
)
=
delete
;
~
DisplayNames
(
)
;
DisplayNamesError
ToError
(
ICUError
aError
)
const
;
DisplayNamesError
ToError
(
Locale
:
:
CanonicalizationError
aError
)
const
;
private
:
template
<
typename
B
typename
Fn
>
static
Result
<
Ok
DisplayNamesError
>
HandleFallback
(
B
&
aBuffer
Fallback
aFallback
Fn
aGetFallbackSpan
)
{
if
(
aBuffer
.
length
(
)
=
=
0
&
&
aFallback
=
=
mozilla
:
:
intl
:
:
DisplayNames
:
:
Fallback
:
:
Code
)
{
if
(
!
FillBuffer
(
aGetFallbackSpan
(
)
aBuffer
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
}
return
Ok
(
)
;
}
template
<
typename
B
typename
F
>
static
ICUResult
FillBufferWithICUDisplayNames
(
B
&
aBuffer
UErrorCode
aNoDisplayNameStatus
F
aCallback
)
{
return
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
int32_t
res
=
aCallback
(
target
length
status
)
;
if
(
*
status
=
=
aNoDisplayNameStatus
)
{
*
status
=
U_ZERO_ERROR
;
res
=
0
;
}
return
res
;
}
)
;
}
Result
<
Ok
DisplayNamesError
>
ComputeDateTimeDisplayNames
(
UDateFormatSymbolType
symbolType
mozilla
:
:
Span
<
const
int32_t
>
indices
Span
<
const
char
>
aCalendar
)
;
static
constexpr
size_t
LocaleVecLength
=
32
;
static
constexpr
size_t
CalendarVecLength
=
32
;
static
inline
char16_t
AsciiAlphaToUpperCase
(
char16_t
aCh
)
{
MOZ_ASSERT
(
IsAsciiAlpha
(
aCh
)
)
;
return
AsciiToUpperCase
(
aCh
)
;
}
;
template
<
typename
T
>
inline
int32_t
EnumToIndex
(
size_t
aSize
T
aEnum
)
{
size_t
index
=
static_cast
<
size_t
>
(
aEnum
)
-
1
;
MOZ_RELEASE_ASSERT
(
index
<
aSize
"
Enum
indexing
mismatch
for
display
names
.
"
)
;
return
index
;
}
static
Span
<
const
char
>
ToCodeString
(
Month
aMonth
)
;
public
:
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetLanguage
(
B
&
aBuffer
Span
<
const
char
>
aLanguage
Fallback
aFallback
=
Fallback
:
:
None
)
const
{
static_assert
(
std
:
:
is_same
<
typename
B
:
:
CharType
char16_t
>
:
:
value
)
;
mozilla
:
:
intl
:
:
Locale
tag
;
if
(
LocaleParser
:
:
TryParseBaseName
(
aLanguage
tag
)
.
isErr
(
)
)
{
return
Err
(
DisplayNamesError
:
:
InvalidOption
)
;
}
{
auto
result
=
tag
.
CanonicalizeBaseName
(
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
}
Vector
<
char
DisplayNames
:
:
LocaleVecLength
>
tagVec
;
{
VectorToBufferAdaptor
tagBuffer
(
tagVec
)
;
auto
result
=
tag
.
ToString
(
tagBuffer
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
if
(
!
tagVec
.
append
(
'
\
0
'
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
}
auto
result
=
FillBufferWithICUDisplayNames
(
aBuffer
U_ILLEGAL_ARGUMENT_ERROR
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
uldn_localeDisplayName
(
mULocaleDisplayNames
.
GetConst
(
)
tagVec
.
begin
(
)
target
length
status
)
;
}
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
return
HandleFallback
(
aBuffer
aFallback
[
&
]
{
return
Span
(
tagVec
.
begin
(
)
tagVec
.
length
(
)
-
1
)
;
}
)
;
}
;
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetRegion
(
B
&
aBuffer
Span
<
const
char
>
aCode
Fallback
aFallback
=
Fallback
:
:
None
)
const
{
static_assert
(
std
:
:
is_same
<
typename
B
:
:
CharType
char16_t
>
:
:
value
)
;
if
(
!
IsStructurallyValidRegionTag
(
aCode
)
)
{
return
Err
(
DisplayNamesError
:
:
InvalidOption
)
;
}
mozilla
:
:
intl
:
:
RegionSubtag
region
{
aCode
}
;
mozilla
:
:
intl
:
:
Locale
tag
;
tag
.
SetLanguage
(
"
und
"
)
;
tag
.
SetRegion
(
region
)
;
{
auto
result
=
tag
.
CanonicalizeBaseName
(
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
}
MOZ_ASSERT
(
tag
.
Region
(
)
.
Present
(
)
)
;
const
mozilla
:
:
intl
:
:
RegionSubtag
&
canonicalRegion
=
tag
.
Region
(
)
;
char
regionChars
[
mozilla
:
:
intl
:
:
LanguageTagLimits
:
:
RegionLength
+
1
]
=
{
}
;
std
:
:
copy_n
(
canonicalRegion
.
Span
(
)
.
data
(
)
canonicalRegion
.
Length
(
)
regionChars
)
;
auto
result
=
FillBufferWithICUDisplayNames
(
aBuffer
U_ILLEGAL_ARGUMENT_ERROR
[
&
]
(
UChar
*
chars
uint32_t
size
UErrorCode
*
status
)
{
return
uldn_regionDisplayName
(
mULocaleDisplayNames
.
GetConst
(
)
regionChars
chars
AssertedCast
<
int32_t
uint32_t
>
(
size
)
status
)
;
}
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
return
HandleFallback
(
aBuffer
aFallback
[
&
]
{
region
.
ToUpperCase
(
)
;
return
region
.
Span
(
)
;
}
)
;
}
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetCurrency
(
B
&
aBuffer
Span
<
const
char
>
aCurrency
Fallback
aFallback
=
Fallback
:
:
None
)
const
{
static_assert
(
std
:
:
is_same
<
typename
B
:
:
CharType
char16_t
>
:
:
value
)
;
if
(
aCurrency
.
size
(
)
!
=
3
)
{
return
Err
(
DisplayNamesError
:
:
InvalidOption
)
;
}
if
(
!
mozilla
:
:
IsAsciiAlpha
(
aCurrency
[
0
]
)
|
|
!
mozilla
:
:
IsAsciiAlpha
(
aCurrency
[
1
]
)
|
|
!
mozilla
:
:
IsAsciiAlpha
(
aCurrency
[
2
]
)
)
{
return
Err
(
DisplayNamesError
:
:
InvalidOption
)
;
}
char16_t
currency
[
]
=
{
AsciiAlphaToUpperCase
(
aCurrency
[
0
]
)
AsciiAlphaToUpperCase
(
aCurrency
[
1
]
)
AsciiAlphaToUpperCase
(
aCurrency
[
2
]
)
u
'
\
0
'
}
;
UCurrNameStyle
style
;
switch
(
mOptions
.
style
)
{
case
Style
:
:
Long
:
style
=
UCURR_LONG_NAME
;
break
;
case
Style
:
:
Abbreviated
:
case
Style
:
:
Short
:
style
=
UCURR_SYMBOL_NAME
;
break
;
case
Style
:
:
Narrow
:
style
=
UCURR_NARROW_SYMBOL_NAME
;
break
;
}
int32_t
length
=
0
;
UErrorCode
status
=
U_ZERO_ERROR
;
const
char16_t
*
name
=
ucurr_getName
(
currency
IcuLocale
(
mLocale
)
style
nullptr
&
length
&
status
)
;
if
(
U_FAILURE
(
status
)
)
{
return
Err
(
DisplayNamesError
:
:
InternalError
)
;
}
if
(
aFallback
=
=
DisplayNames
:
:
Fallback
:
:
None
&
&
status
=
=
U_USING_DEFAULT_WARNING
&
&
length
=
=
3
&
&
std
:
:
u16string_view
{
name
3
}
=
=
std
:
:
u16string_view
{
currency
3
}
)
{
if
(
aBuffer
.
length
(
)
!
=
0
)
{
aBuffer
.
written
(
0
)
;
}
return
Ok
(
)
;
}
if
(
!
FillBuffer
(
Span
(
name
length
)
aBuffer
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
return
Ok
(
)
;
}
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetScript
(
B
&
aBuffer
Span
<
const
char
>
aScript
Fallback
aFallback
=
Fallback
:
:
None
)
const
{
static_assert
(
std
:
:
is_same
<
typename
B
:
:
CharType
char16_t
>
:
:
value
)
;
if
(
!
IsStructurallyValidScriptTag
(
aScript
)
)
{
return
Err
(
DisplayNamesError
:
:
InvalidOption
)
;
}
mozilla
:
:
intl
:
:
ScriptSubtag
script
{
aScript
}
;
mozilla
:
:
intl
:
:
Locale
tag
;
tag
.
SetLanguage
(
"
und
"
)
;
tag
.
SetScript
(
script
)
;
{
auto
result
=
tag
.
CanonicalizeBaseName
(
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
}
MOZ_ASSERT
(
tag
.
Script
(
)
.
Present
(
)
)
;
mozilla
:
:
Vector
<
char
DisplayNames
:
:
LocaleVecLength
>
tagString
;
VectorToBufferAdaptor
buffer
(
tagString
)
;
switch
(
mOptions
.
style
)
{
case
Style
:
:
Long
:
{
if
(
auto
result
=
tag
.
ToString
(
buffer
)
;
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
if
(
!
tagString
.
append
(
'
\
0
'
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
auto
result
=
FillBufferWithICUDisplayNames
(
aBuffer
U_USING_DEFAULT_WARNING
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
uloc_getDisplayScript
(
tagString
.
begin
(
)
IcuLocale
(
mLocale
)
target
length
status
)
;
}
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
break
;
}
case
Style
:
:
Abbreviated
:
case
Style
:
:
Short
:
case
Style
:
:
Narrow
:
{
const
mozilla
:
:
intl
:
:
ScriptSubtag
&
canonicalScript
=
tag
.
Script
(
)
;
char
scriptChars
[
mozilla
:
:
intl
:
:
LanguageTagLimits
:
:
ScriptLength
+
1
]
=
{
}
;
MOZ_ASSERT
(
canonicalScript
.
Length
(
)
<
=
mozilla
:
:
intl
:
:
LanguageTagLimits
:
:
ScriptLength
+
1
)
;
std
:
:
copy_n
(
canonicalScript
.
Span
(
)
.
data
(
)
canonicalScript
.
Length
(
)
scriptChars
)
;
auto
result
=
FillBufferWithICUDisplayNames
(
aBuffer
U_ILLEGAL_ARGUMENT_ERROR
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
uldn_scriptDisplayName
(
mULocaleDisplayNames
.
GetConst
(
)
scriptChars
target
length
status
)
;
}
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
break
;
}
}
return
HandleFallback
(
aBuffer
aFallback
[
&
]
{
script
.
ToTitleCase
(
)
;
return
script
.
Span
(
)
;
}
)
;
}
;
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetCalendar
(
B
&
aBuffer
Span
<
const
char
>
aCalendar
Fallback
aFallback
=
Fallback
:
:
None
)
const
{
if
(
aCalendar
.
empty
(
)
|
|
!
IsAscii
(
aCalendar
)
)
{
return
Err
(
DisplayNamesError
:
:
InvalidOption
)
;
}
if
(
LocaleParser
:
:
CanParseUnicodeExtensionType
(
aCalendar
)
.
isErr
(
)
)
{
return
Err
(
DisplayNamesError
:
:
InvalidOption
)
;
}
Vector
<
char
DisplayNames
:
:
CalendarVecLength
>
lowerCaseCalendar
;
for
(
size_t
i
=
0
;
i
<
aCalendar
.
size
(
)
;
i
+
+
)
{
if
(
!
lowerCaseCalendar
.
append
(
AsciiToLowerCase
(
aCalendar
[
i
]
)
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
}
if
(
!
lowerCaseCalendar
.
append
(
'
\
0
'
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
Span
<
const
char
>
canonicalCalendar
=
mozilla
:
:
Span
(
lowerCaseCalendar
.
begin
(
)
lowerCaseCalendar
.
length
(
)
-
1
)
;
{
Span
<
const
char
>
key
=
mozilla
:
:
MakeStringSpan
(
"
ca
"
)
;
Span
<
const
char
>
type
=
canonicalCalendar
;
if
(
const
char
*
replacement
=
mozilla
:
:
intl
:
:
Locale
:
:
ReplaceUnicodeExtensionType
(
key
type
)
)
{
canonicalCalendar
=
MakeStringSpan
(
replacement
)
;
}
}
static
constexpr
size_t
maximumCalendarLength
=
100
;
if
(
canonicalCalendar
.
size
(
)
<
=
maximumCalendarLength
)
{
if
(
const
char
*
legacyCalendar
=
uloc_toLegacyType
(
"
calendar
"
canonicalCalendar
.
Elements
(
)
)
)
{
auto
result
=
FillBufferWithICUDisplayNames
(
aBuffer
U_ILLEGAL_ARGUMENT_ERROR
[
&
]
(
UChar
*
chars
uint32_t
size
UErrorCode
*
status
)
{
return
uldn_keyValueDisplayName
(
mULocaleDisplayNames
.
GetConst
(
)
"
calendar
"
legacyCalendar
chars
size
status
)
;
}
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
}
else
{
aBuffer
.
written
(
0
)
;
}
}
else
{
aBuffer
.
written
(
0
)
;
}
return
HandleFallback
(
aBuffer
aFallback
[
&
]
{
return
canonicalCalendar
;
}
)
;
}
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetWeekday
(
B
&
aBuffer
Weekday
aWeekday
Span
<
const
char
>
aCalendar
Fallback
aFallback
=
Fallback
:
:
None
)
{
MOZ_ASSERT
(
aWeekday
>
=
Weekday
:
:
Monday
&
&
aWeekday
<
=
Weekday
:
:
Sunday
)
;
UDateFormatSymbolType
symbolType
;
switch
(
mOptions
.
style
)
{
case
DisplayNames
:
:
Style
:
:
Long
:
symbolType
=
UDAT_STANDALONE_WEEKDAYS
;
break
;
case
DisplayNames
:
:
Style
:
:
Abbreviated
:
symbolType
=
UDAT_STANDALONE_SHORT_WEEKDAYS
;
break
;
case
DisplayNames
:
:
Style
:
:
Short
:
symbolType
=
UDAT_STANDALONE_SHORTER_WEEKDAYS
;
break
;
case
DisplayNames
:
:
Style
:
:
Narrow
:
symbolType
=
UDAT_STANDALONE_NARROW_WEEKDAYS
;
break
;
}
static
constexpr
int32_t
indices
[
]
=
{
UCAL_MONDAY
UCAL_TUESDAY
UCAL_WEDNESDAY
UCAL_THURSDAY
UCAL_FRIDAY
UCAL_SATURDAY
UCAL_SUNDAY
}
;
if
(
auto
result
=
ComputeDateTimeDisplayNames
(
symbolType
mozilla
:
:
Span
(
indices
)
aCalendar
)
;
result
.
isErr
(
)
)
{
return
result
.
propagateErr
(
)
;
}
MOZ_ASSERT
(
mDateTimeDisplayNames
.
length
(
)
=
=
std
:
:
size
(
indices
)
)
;
auto
&
name
=
mDateTimeDisplayNames
[
EnumToIndex
(
std
:
:
size
(
indices
)
aWeekday
)
]
;
if
(
!
FillBuffer
(
name
.
AsSpan
(
)
aBuffer
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
return
Ok
(
)
;
}
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetMonth
(
B
&
aBuffer
Month
aMonth
Span
<
const
char
>
aCalendar
Fallback
aFallback
=
Fallback
:
:
None
)
{
MOZ_ASSERT
(
aMonth
>
=
Month
:
:
January
&
&
aMonth
<
=
Month
:
:
Undecimber
)
;
UDateFormatSymbolType
symbolType
;
switch
(
mOptions
.
style
)
{
case
DisplayNames
:
:
Style
:
:
Long
:
symbolType
=
UDAT_STANDALONE_MONTHS
;
break
;
case
DisplayNames
:
:
Style
:
:
Abbreviated
:
case
DisplayNames
:
:
Style
:
:
Short
:
symbolType
=
UDAT_STANDALONE_SHORT_MONTHS
;
break
;
case
DisplayNames
:
:
Style
:
:
Narrow
:
symbolType
=
UDAT_STANDALONE_NARROW_MONTHS
;
break
;
}
static
constexpr
int32_t
indices
[
]
=
{
UCAL_JANUARY
UCAL_FEBRUARY
UCAL_MARCH
UCAL_APRIL
UCAL_MAY
UCAL_JUNE
UCAL_JULY
UCAL_AUGUST
UCAL_SEPTEMBER
UCAL_OCTOBER
UCAL_NOVEMBER
UCAL_DECEMBER
UCAL_UNDECIMBER
}
;
if
(
auto
result
=
ComputeDateTimeDisplayNames
(
symbolType
mozilla
:
:
Span
(
indices
)
aCalendar
)
;
result
.
isErr
(
)
)
{
return
result
.
propagateErr
(
)
;
}
MOZ_ASSERT
(
mDateTimeDisplayNames
.
length
(
)
=
=
std
:
:
size
(
indices
)
)
;
auto
&
name
=
mDateTimeDisplayNames
[
EnumToIndex
(
std
:
:
size
(
indices
)
aMonth
)
]
;
if
(
!
FillBuffer
(
Span
(
name
.
AsSpan
(
)
)
aBuffer
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
return
HandleFallback
(
aBuffer
aFallback
[
&
]
{
return
ToCodeString
(
aMonth
)
;
}
)
;
}
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetQuarter
(
B
&
aBuffer
Quarter
aQuarter
Span
<
const
char
>
aCalendar
Fallback
aFallback
=
Fallback
:
:
None
)
{
MOZ_ASSERT
(
aQuarter
>
=
Quarter
:
:
Q1
&
&
aQuarter
<
=
Quarter
:
:
Q4
)
;
UDateFormatSymbolType
symbolType
;
switch
(
mOptions
.
style
)
{
case
DisplayNames
:
:
Style
:
:
Long
:
symbolType
=
UDAT_STANDALONE_QUARTERS
;
break
;
case
DisplayNames
:
:
Style
:
:
Abbreviated
:
case
DisplayNames
:
:
Style
:
:
Short
:
symbolType
=
UDAT_STANDALONE_SHORT_QUARTERS
;
break
;
case
DisplayNames
:
:
Style
:
:
Narrow
:
symbolType
=
UDAT_STANDALONE_NARROW_QUARTERS
;
break
;
}
static
constexpr
int32_t
indices
[
]
=
{
0
1
2
3
}
;
if
(
auto
result
=
ComputeDateTimeDisplayNames
(
symbolType
mozilla
:
:
Span
(
indices
)
aCalendar
)
;
result
.
isErr
(
)
)
{
return
result
.
propagateErr
(
)
;
}
MOZ_ASSERT
(
mDateTimeDisplayNames
.
length
(
)
=
=
std
:
:
size
(
indices
)
)
;
auto
&
name
=
mDateTimeDisplayNames
[
EnumToIndex
(
std
:
:
size
(
indices
)
aQuarter
)
]
;
if
(
!
FillBuffer
(
Span
(
name
.
AsSpan
(
)
)
aBuffer
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
return
Ok
(
)
;
}
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetDayPeriod
(
B
&
aBuffer
DayPeriod
aDayPeriod
Span
<
const
char
>
aCalendar
Fallback
aFallback
=
Fallback
:
:
None
)
{
UDateFormatSymbolType
symbolType
;
switch
(
mOptions
.
style
)
{
case
DisplayNames
:
:
Style
:
:
Long
:
#
ifndef
U_HIDE_DRAFT_API
symbolType
=
UDAT_AM_PMS_WIDE
;
#
else
symbolType
=
UDAT_AM_PMS
;
#
endif
break
;
case
DisplayNames
:
:
Style
:
:
Abbreviated
:
case
DisplayNames
:
:
Style
:
:
Short
:
symbolType
=
UDAT_AM_PMS
;
break
;
case
DisplayNames
:
:
Style
:
:
Narrow
:
#
ifndef
U_HIDE_DRAFT_API
symbolType
=
UDAT_AM_PMS_NARROW
;
#
else
symbolType
=
UDAT_AM_PMS
;
#
endif
break
;
}
static
constexpr
int32_t
indices
[
]
=
{
UCAL_AM
UCAL_PM
}
;
if
(
auto
result
=
ComputeDateTimeDisplayNames
(
symbolType
mozilla
:
:
Span
(
indices
)
aCalendar
)
;
result
.
isErr
(
)
)
{
return
result
.
propagateErr
(
)
;
}
MOZ_ASSERT
(
mDateTimeDisplayNames
.
length
(
)
=
=
std
:
:
size
(
indices
)
)
;
auto
&
name
=
mDateTimeDisplayNames
[
EnumToIndex
(
std
:
:
size
(
indices
)
aDayPeriod
)
]
;
if
(
!
FillBuffer
(
name
.
AsSpan
(
)
aBuffer
)
)
{
return
Err
(
DisplayNamesError
:
:
OutOfMemory
)
;
}
return
Ok
(
)
;
}
template
<
typename
B
>
Result
<
Ok
DisplayNamesError
>
GetDateTimeField
(
B
&
aBuffer
DateTimeField
aField
DateTimePatternGenerator
&
aDateTimePatternGen
Fallback
aFallback
=
Fallback
:
:
None
)
{
UDateTimePatternField
field
;
switch
(
aField
)
{
case
DateTimeField
:
:
Era
:
field
=
UDATPG_ERA_FIELD
;
break
;
case
DateTimeField
:
:
Year
:
field
=
UDATPG_YEAR_FIELD
;
break
;
case
DateTimeField
:
:
Quarter
:
field
=
UDATPG_QUARTER_FIELD
;
break
;
case
DateTimeField
:
:
Month
:
field
=
UDATPG_MONTH_FIELD
;
break
;
case
DateTimeField
:
:
WeekOfYear
:
field
=
UDATPG_WEEK_OF_YEAR_FIELD
;
break
;
case
DateTimeField
:
:
Weekday
:
field
=
UDATPG_WEEKDAY_FIELD
;
break
;
case
DateTimeField
:
:
Day
:
field
=
UDATPG_DAY_FIELD
;
break
;
case
DateTimeField
:
:
DayPeriod
:
field
=
UDATPG_DAYPERIOD_FIELD
;
break
;
case
DateTimeField
:
:
Hour
:
field
=
UDATPG_HOUR_FIELD
;
break
;
case
DateTimeField
:
:
Minute
:
field
=
UDATPG_MINUTE_FIELD
;
break
;
case
DateTimeField
:
:
Second
:
field
=
UDATPG_SECOND_FIELD
;
break
;
case
DateTimeField
:
:
TimeZoneName
:
field
=
UDATPG_ZONE_FIELD
;
break
;
}
UDateTimePGDisplayWidth
width
;
switch
(
mOptions
.
style
)
{
case
DisplayNames
:
:
Style
:
:
Long
:
width
=
UDATPG_WIDE
;
break
;
case
DisplayNames
:
:
Style
:
:
Abbreviated
:
case
DisplayNames
:
:
Style
:
:
Short
:
width
=
UDATPG_ABBREVIATED
;
break
;
case
DisplayNames
:
:
Style
:
:
Narrow
:
width
=
UDATPG_NARROW
;
break
;
}
auto
result
=
FillBufferWithICUCall
(
aBuffer
[
&
]
(
UChar
*
target
int32_t
length
UErrorCode
*
status
)
{
return
udatpg_getFieldDisplayName
(
aDateTimePatternGen
.
GetUDateTimePatternGenerator
(
)
field
width
target
length
status
)
;
}
)
;
if
(
result
.
isErr
(
)
)
{
return
Err
(
ToError
(
result
.
unwrapErr
(
)
)
)
;
}
return
Ok
(
)
;
}
Options
mOptions
;
Buffer
<
char
>
mLocale
;
Vector
<
Buffer
<
char16_t
>
>
mDateTimeDisplayNames
;
ICUPointer
<
ULocaleDisplayNames
>
mULocaleDisplayNames
=
ICUPointer
<
ULocaleDisplayNames
>
(
nullptr
)
;
}
;
}
#
endif
