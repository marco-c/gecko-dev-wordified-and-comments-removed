#
include
"
nsConverterInputStream
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsReadLine
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
<
algorithm
>
#
include
<
tuple
>
using
namespace
mozilla
;
#
define
CONVERTER_BUFFER_SIZE
8192
NS_IMPL_ISUPPORTS
(
nsConverterInputStream
nsIConverterInputStream
nsIUnicharInputStream
nsIUnicharLineInputStream
)
NS_IMETHODIMP
nsConverterInputStream
:
:
Init
(
nsIInputStream
*
aStream
const
char
*
aCharset
int32_t
aBufferSize
char16_t
aReplacementChar
)
{
nsAutoCString
label
;
if
(
!
aCharset
)
{
label
.
AssignLiteral
(
"
UTF
-
8
"
)
;
}
else
{
label
=
aCharset
;
}
auto
encoding
=
Encoding
:
:
ForLabelNoReplacement
(
label
)
;
if
(
!
encoding
)
{
return
NS_ERROR_UCONV_NOCONV
;
}
mConverter
=
encoding
-
>
NewDecoder
(
)
;
size_t
outputBufferSize
;
if
(
aBufferSize
<
=
0
)
{
aBufferSize
=
CONVERTER_BUFFER_SIZE
;
outputBufferSize
=
CONVERTER_BUFFER_SIZE
;
}
else
{
CheckedInt
<
size_t
>
needed
=
mConverter
-
>
MaxUTF16BufferLength
(
aBufferSize
)
;
if
(
!
needed
.
isValid
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
outputBufferSize
=
needed
.
value
(
)
;
}
if
(
!
mByteData
.
SetCapacity
(
aBufferSize
mozilla
:
:
fallible
)
|
|
!
mUnicharData
.
SetLength
(
outputBufferSize
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mInput
=
aStream
;
mErrorsAreFatal
=
!
aReplacementChar
;
return
NS_OK
;
}
NS_IMETHODIMP
nsConverterInputStream
:
:
Close
(
)
{
nsresult
rv
=
mInput
?
mInput
-
>
Close
(
)
:
NS_OK
;
mLineBuffer
=
nullptr
;
mInput
=
nullptr
;
mConverter
=
nullptr
;
mByteData
.
Clear
(
)
;
mUnicharData
.
Clear
(
)
;
return
rv
;
}
NS_IMETHODIMP
nsConverterInputStream
:
:
Read
(
char16_t
*
aBuf
uint32_t
aCount
uint32_t
*
aReadCount
)
{
NS_ASSERTION
(
mUnicharDataLength
>
=
mUnicharDataOffset
"
unsigned
madness
"
)
;
uint32_t
readCount
=
mUnicharDataLength
-
mUnicharDataOffset
;
if
(
0
=
=
readCount
)
{
readCount
=
Fill
(
&
mLastErrorCode
)
;
if
(
readCount
=
=
0
)
{
*
aReadCount
=
0
;
return
mLastErrorCode
;
}
}
if
(
readCount
>
aCount
)
{
readCount
=
aCount
;
}
memcpy
(
aBuf
mUnicharData
.
Elements
(
)
+
mUnicharDataOffset
readCount
*
sizeof
(
char16_t
)
)
;
mUnicharDataOffset
+
=
readCount
;
*
aReadCount
=
readCount
;
return
NS_OK
;
}
NS_IMETHODIMP
nsConverterInputStream
:
:
ReadSegments
(
nsWriteUnicharSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
aReadCount
)
{
NS_ASSERTION
(
mUnicharDataLength
>
=
mUnicharDataOffset
"
unsigned
madness
"
)
;
uint32_t
codeUnitsToWrite
=
mUnicharDataLength
-
mUnicharDataOffset
;
if
(
0
=
=
codeUnitsToWrite
)
{
codeUnitsToWrite
=
Fill
(
&
mLastErrorCode
)
;
if
(
codeUnitsToWrite
=
=
0
)
{
*
aReadCount
=
0
;
return
mLastErrorCode
;
}
}
if
(
codeUnitsToWrite
>
aCount
)
{
codeUnitsToWrite
=
aCount
;
}
uint32_t
codeUnitsWritten
;
uint32_t
totalCodeUnitsWritten
=
0
;
while
(
codeUnitsToWrite
)
{
nsresult
rv
=
aWriter
(
this
aClosure
mUnicharData
.
Elements
(
)
+
mUnicharDataOffset
totalCodeUnitsWritten
codeUnitsToWrite
&
codeUnitsWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
codeUnitsToWrite
-
=
codeUnitsWritten
;
totalCodeUnitsWritten
+
=
codeUnitsWritten
;
mUnicharDataOffset
+
=
codeUnitsWritten
;
}
*
aReadCount
=
totalCodeUnitsWritten
;
return
NS_OK
;
}
NS_IMETHODIMP
nsConverterInputStream
:
:
ReadString
(
uint32_t
aCount
nsAString
&
aString
uint32_t
*
aReadCount
)
{
NS_ASSERTION
(
mUnicharDataLength
>
=
mUnicharDataOffset
"
unsigned
madness
"
)
;
uint32_t
readCount
=
mUnicharDataLength
-
mUnicharDataOffset
;
if
(
0
=
=
readCount
)
{
readCount
=
Fill
(
&
mLastErrorCode
)
;
if
(
readCount
=
=
0
)
{
*
aReadCount
=
0
;
return
mLastErrorCode
;
}
}
if
(
readCount
>
aCount
)
{
readCount
=
aCount
;
}
const
char16_t
*
buf
=
mUnicharData
.
Elements
(
)
+
mUnicharDataOffset
;
aString
.
Assign
(
buf
readCount
)
;
mUnicharDataOffset
+
=
readCount
;
*
aReadCount
=
readCount
;
return
NS_OK
;
}
uint32_t
nsConverterInputStream
:
:
Fill
(
nsresult
*
aErrorCode
)
{
if
(
!
mInput
)
{
*
aErrorCode
=
NS_BASE_STREAM_CLOSED
;
return
0
;
}
if
(
NS_FAILED
(
mLastErrorCode
)
)
{
*
aErrorCode
=
mLastErrorCode
;
return
0
;
}
mUnicharDataLength
=
0
;
mUnicharDataOffset
=
0
;
while
(
mUnicharDataLength
=
=
0
&
&
mConverter
)
{
uint32_t
nb
;
*
aErrorCode
=
NS_FillArray
(
mByteData
mInput
mLeftOverBytes
&
nb
)
;
if
(
NS_FAILED
(
*
aErrorCode
)
)
{
return
0
;
}
NS_ASSERTION
(
uint32_t
(
nb
)
+
mLeftOverBytes
=
=
mByteData
.
Length
(
)
"
mByteData
is
lying
to
us
somewhere
"
)
;
bool
last
=
(
nb
=
=
0
)
;
auto
src
=
AsBytes
(
Span
(
mByteData
)
)
;
auto
dst
=
Span
(
mUnicharData
)
;
uint32_t
result
;
size_t
read
;
size_t
written
;
if
(
mErrorsAreFatal
)
{
std
:
:
tie
(
result
read
written
)
=
mConverter
-
>
DecodeToUTF16WithoutReplacement
(
src
dst
last
)
;
}
else
{
std
:
:
tie
(
result
read
written
std
:
:
ignore
)
=
mConverter
-
>
DecodeToUTF16
(
src
dst
last
)
;
}
mLeftOverBytes
=
mByteData
.
Length
(
)
-
read
;
mUnicharDataLength
=
written
;
if
(
last
)
{
MOZ_ASSERT
(
mLeftOverBytes
=
=
0
"
Failed
to
read
all
bytes
on
the
last
pass
?
"
)
;
mConverter
=
nullptr
;
}
if
(
result
!
=
kInputEmpty
&
&
result
!
=
kOutputFull
)
{
MOZ_ASSERT
(
mErrorsAreFatal
"
How
come
DecodeToUTF16
(
)
reported
error
?
"
)
;
*
aErrorCode
=
NS_ERROR_UDEC_ILLEGALINPUT
;
return
0
;
}
}
*
aErrorCode
=
NS_OK
;
return
mUnicharDataLength
;
}
NS_IMETHODIMP
nsConverterInputStream
:
:
ReadLine
(
nsAString
&
aLine
bool
*
aResult
)
{
if
(
!
mLineBuffer
)
{
mLineBuffer
=
MakeUnique
<
nsLineBuffer
<
char16_t
>
>
(
)
;
}
return
NS_ReadLine
(
this
mLineBuffer
.
get
(
)
aLine
aResult
)
;
}
