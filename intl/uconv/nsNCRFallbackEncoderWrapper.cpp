#
include
"
nsNCRFallbackEncoderWrapper
.
h
"
#
include
"
mozilla
/
dom
/
EncodingUtils
.
h
"
nsNCRFallbackEncoderWrapper
:
:
nsNCRFallbackEncoderWrapper
(
const
nsACString
&
aEncoding
)
:
mEncoder
(
mozilla
:
:
dom
:
:
EncodingUtils
:
:
EncoderForEncoding
(
aEncoding
)
)
{
}
nsNCRFallbackEncoderWrapper
:
:
~
nsNCRFallbackEncoderWrapper
(
)
{
}
bool
nsNCRFallbackEncoderWrapper
:
:
WriteNCR
(
nsACString
&
aBytes
uint32_t
&
aDstWritten
int32_t
aUnmappable
)
{
nsAutoCString
ncr
(
"
&
#
"
)
;
ncr
.
AppendInt
(
aUnmappable
)
;
ncr
.
Append
(
'
;
'
)
;
uint32_t
ncrLen
=
ncr
.
Length
(
)
;
uint32_t
needed
=
aDstWritten
+
ncrLen
;
if
(
needed
>
INT32_MAX
)
{
return
false
;
}
if
(
needed
>
aBytes
.
Length
(
)
&
&
!
aBytes
.
SetLength
(
needed
mozilla
:
:
fallible_t
(
)
)
)
{
return
false
;
}
memcpy
(
aBytes
.
BeginWriting
(
)
+
aDstWritten
ncr
.
BeginReading
(
)
ncrLen
)
;
aDstWritten
+
=
ncrLen
;
return
true
;
}
bool
nsNCRFallbackEncoderWrapper
:
:
Encode
(
const
nsAString
&
aUtf16
nsACString
&
aBytes
)
{
if
(
!
mEncoder
)
{
return
false
;
}
if
(
aUtf16
.
Length
(
)
>
INT32_MAX
)
{
return
false
;
}
const
char16_t
*
src
=
aUtf16
.
BeginReading
(
)
;
const
char16_t
*
srcEnd
=
aUtf16
.
EndReading
(
)
;
uint32_t
dstWritten
=
0
;
for
(
;
;
)
{
int32_t
srcLen
=
srcEnd
-
src
;
int32_t
dstLen
=
0
;
nsresult
rv
=
mEncoder
-
>
GetMaxLength
(
src
srcLen
&
dstLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
uint32_t
needed
=
dstWritten
+
dstLen
;
if
(
needed
>
INT32_MAX
)
{
return
false
;
}
if
(
needed
>
aBytes
.
Length
(
)
&
&
!
aBytes
.
SetLength
(
needed
mozilla
:
:
fallible_t
(
)
)
)
{
return
false
;
}
char
*
dst
=
aBytes
.
BeginWriting
(
)
+
dstWritten
;
dstLen
=
aBytes
.
Length
(
)
-
dstWritten
;
mEncoder
-
>
Reset
(
)
;
rv
=
mEncoder
-
>
Convert
(
src
&
srcLen
dst
&
dstLen
)
;
src
+
=
srcLen
;
dstWritten
+
=
dstLen
;
if
(
rv
=
=
NS_OK_UENC_MOREOUTPUT
)
{
MOZ_ASSERT_UNREACHABLE
(
"
GetMaxLength
must
have
returned
a
bogus
length
.
"
)
;
return
false
;
}
if
(
rv
=
=
NS_ERROR_UENC_NOMAPPING
)
{
int32_t
unmappable
;
MOZ_ASSERT
(
srcLen
>
0
"
Encoder
should
have
consumed
some
input
.
"
)
;
char16_t
codeUnit
=
src
[
-
1
]
;
size_t
highBits
=
(
codeUnit
&
0xFC00
)
;
if
(
highBits
=
=
0xD800
)
{
char16_t
next
;
if
(
src
<
srcEnd
&
&
NS_IS_LOW_SURROGATE
(
(
next
=
*
src
)
)
)
{
src
+
+
;
unmappable
=
SURROGATE_TO_UCS4
(
codeUnit
next
)
;
}
else
{
unmappable
=
0xFFFD
;
}
}
else
if
(
highBits
=
=
0xDC00
)
{
unmappable
=
0xFFFD
;
}
else
{
unmappable
=
codeUnit
;
}
dst
=
aBytes
.
BeginWriting
(
)
+
dstWritten
;
dstLen
=
aBytes
.
Length
(
)
-
dstWritten
;
rv
=
mEncoder
-
>
Finish
(
dst
&
dstLen
)
;
dstWritten
+
=
dstLen
;
if
(
rv
!
=
NS_OK
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Broken
encoder
.
"
)
;
return
false
;
}
if
(
!
WriteNCR
(
aBytes
dstWritten
unmappable
)
)
{
return
false
;
}
continue
;
}
if
(
!
(
rv
=
=
NS_OK
|
|
rv
=
=
NS_OK_UENC_MOREINPUT
)
)
{
return
false
;
}
MOZ_ASSERT
(
src
=
=
srcEnd
"
Converter
did
not
consume
all
input
.
"
)
;
dst
=
aBytes
.
BeginWriting
(
)
+
dstWritten
;
dstLen
=
aBytes
.
Length
(
)
-
dstWritten
;
rv
=
mEncoder
-
>
Finish
(
dst
&
dstLen
)
;
dstWritten
+
=
dstLen
;
if
(
rv
=
=
NS_OK_UENC_MOREOUTPUT
)
{
MOZ_ASSERT_UNREACHABLE
(
"
GetMaxLength
must
have
returned
a
bogus
length
.
"
)
;
return
false
;
}
if
(
rv
=
=
NS_ERROR_UENC_NOMAPPING
)
{
if
(
!
WriteNCR
(
aBytes
dstWritten
0xFFFD
)
)
{
return
false
;
}
}
return
aBytes
.
SetLength
(
dstWritten
mozilla
:
:
fallible_t
(
)
)
;
}
}
