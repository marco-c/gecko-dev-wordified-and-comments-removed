const
MAX_PLACEABLES
=
100
;
const
entryIdentifierRe
=
/
-
?
[
a
-
zA
-
Z
]
[
a
-
zA
-
Z0
-
9_
-
]
*
/
y
;
const
identifierRe
=
/
[
a
-
zA
-
Z
]
[
a
-
zA
-
Z0
-
9_
-
]
*
/
y
;
const
functionIdentifierRe
=
/
^
[
A
-
Z
]
[
A
-
Z_
?
-
]
*
/
;
class
RuntimeParser
{
getResource
(
string
)
{
this
.
_source
=
string
;
this
.
_index
=
0
;
this
.
_length
=
string
.
length
;
this
.
entries
=
{
}
;
const
errors
=
[
]
;
this
.
skipWS
(
)
;
while
(
this
.
_index
<
this
.
_length
)
{
try
{
this
.
getEntry
(
)
;
}
catch
(
e
)
{
if
(
e
instanceof
SyntaxError
)
{
errors
.
push
(
e
)
;
this
.
skipToNextEntryStart
(
)
;
}
else
{
throw
e
;
}
}
this
.
skipWS
(
)
;
}
return
[
this
.
entries
errors
]
;
}
getEntry
(
)
{
if
(
this
.
_index
!
=
=
0
&
&
this
.
_source
[
this
.
_index
-
1
]
!
=
=
"
\
n
"
)
{
throw
this
.
error
(
Expected
an
entry
to
start
at
the
beginning
of
the
file
or
on
a
new
line
.
)
;
}
const
ch
=
this
.
_source
[
this
.
_index
]
;
if
(
ch
=
=
=
"
/
"
|
|
(
ch
=
=
=
"
#
"
&
&
[
"
"
"
#
"
"
\
n
"
]
.
includes
(
this
.
_source
[
this
.
_index
+
1
]
)
)
)
{
this
.
skipComment
(
)
;
return
;
}
if
(
ch
=
=
=
"
[
"
)
{
this
.
skipSection
(
)
;
return
;
}
this
.
getMessage
(
)
;
}
skipSection
(
)
{
this
.
_index
+
=
1
;
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
[
"
)
{
throw
this
.
error
(
'
Expected
"
[
[
"
to
open
a
section
'
)
;
}
this
.
_index
+
=
1
;
this
.
skipInlineWS
(
)
;
this
.
getVariantName
(
)
;
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
]
"
|
|
this
.
_source
[
this
.
_index
+
1
]
!
=
=
"
]
"
)
{
throw
this
.
error
(
'
Expected
"
]
]
"
to
close
a
section
'
)
;
}
this
.
_index
+
=
2
;
}
getMessage
(
)
{
const
id
=
this
.
getEntryIdentifier
(
)
;
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
=
"
)
{
this
.
_index
+
+
;
}
this
.
skipInlineWS
(
)
;
const
val
=
this
.
getPattern
(
)
;
if
(
id
.
startsWith
(
"
-
"
)
&
&
val
=
=
=
null
)
{
throw
this
.
error
(
"
Expected
term
to
have
a
value
"
)
;
}
let
attrs
=
null
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
"
)
{
const
lineStart
=
this
.
_index
;
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
.
"
)
{
this
.
_index
=
lineStart
;
attrs
=
this
.
getAttributes
(
)
;
}
}
if
(
attrs
=
=
=
null
&
&
typeof
val
=
=
=
"
string
"
)
{
this
.
entries
[
id
]
=
val
;
}
else
{
if
(
val
=
=
=
null
&
&
attrs
=
=
=
null
)
{
throw
this
.
error
(
"
Expected
message
to
have
a
value
or
attributes
"
)
;
}
this
.
entries
[
id
]
=
{
}
;
if
(
val
!
=
=
null
)
{
this
.
entries
[
id
]
.
val
=
val
;
}
if
(
attrs
!
=
=
null
)
{
this
.
entries
[
id
]
.
attrs
=
attrs
;
}
}
}
skipWS
(
)
{
let
ch
=
this
.
_source
[
this
.
_index
]
;
while
(
ch
=
=
=
"
"
|
|
ch
=
=
=
"
\
n
"
|
|
ch
=
=
=
"
\
t
"
|
|
ch
=
=
=
"
\
r
"
)
{
ch
=
this
.
_source
[
+
+
this
.
_index
]
;
}
}
skipInlineWS
(
)
{
let
ch
=
this
.
_source
[
this
.
_index
]
;
while
(
ch
=
=
=
"
"
|
|
ch
=
=
=
"
\
t
"
)
{
ch
=
this
.
_source
[
+
+
this
.
_index
]
;
}
}
skipBlankLines
(
)
{
while
(
true
)
{
const
ptr
=
this
.
_index
;
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
\
n
"
)
{
this
.
_index
+
=
1
;
}
else
{
this
.
_index
=
ptr
;
break
;
}
}
}
getIdentifier
(
re
=
identifierRe
)
{
re
.
lastIndex
=
this
.
_index
;
const
result
=
re
.
exec
(
this
.
_source
)
;
if
(
result
=
=
=
null
)
{
this
.
_index
+
=
1
;
throw
this
.
error
(
Expected
an
identifier
[
{
re
.
toString
(
)
}
]
)
;
}
this
.
_index
=
re
.
lastIndex
;
return
result
[
0
]
;
}
getEntryIdentifier
(
)
{
return
this
.
getIdentifier
(
entryIdentifierRe
)
;
}
getVariantName
(
)
{
let
name
=
"
"
;
const
start
=
this
.
_index
;
let
cc
=
this
.
_source
.
charCodeAt
(
this
.
_index
)
;
if
(
(
cc
>
=
97
&
&
cc
<
=
122
)
|
|
(
cc
>
=
65
&
&
cc
<
=
90
)
|
|
cc
=
=
=
95
|
|
cc
=
=
=
32
)
{
cc
=
this
.
_source
.
charCodeAt
(
+
+
this
.
_index
)
;
}
else
{
throw
this
.
error
(
"
Expected
a
keyword
(
starting
with
[
a
-
zA
-
Z_
]
)
"
)
;
}
while
(
(
cc
>
=
97
&
&
cc
<
=
122
)
|
|
(
cc
>
=
65
&
&
cc
<
=
90
)
|
|
(
cc
>
=
48
&
&
cc
<
=
57
)
|
|
cc
=
=
=
95
|
|
cc
=
=
=
45
|
|
cc
=
=
=
32
)
{
cc
=
this
.
_source
.
charCodeAt
(
+
+
this
.
_index
)
;
}
while
(
this
.
_source
.
charCodeAt
(
this
.
_index
-
1
)
=
=
=
32
)
{
this
.
_index
-
-
;
}
name
+
=
this
.
_source
.
slice
(
start
this
.
_index
)
;
return
{
type
:
"
varname
"
name
}
;
}
getString
(
)
{
const
start
=
this
.
_index
+
1
;
while
(
+
+
this
.
_index
<
this
.
_length
)
{
const
ch
=
this
.
_source
[
this
.
_index
]
;
if
(
ch
=
=
=
'
"
'
)
{
break
;
}
if
(
ch
=
=
=
"
\
n
"
)
{
throw
this
.
error
(
"
Unterminated
string
expression
"
)
;
}
}
return
this
.
_source
.
substring
(
start
this
.
_index
+
+
)
;
}
getPattern
(
)
{
const
start
=
this
.
_index
;
let
eol
=
this
.
_source
.
indexOf
(
"
\
n
"
this
.
_index
)
;
if
(
eol
=
=
=
-
1
)
{
eol
=
this
.
_length
;
}
const
firstLineContent
=
start
!
=
=
eol
?
this
.
_source
.
slice
(
start
eol
)
:
null
;
if
(
firstLineContent
&
&
firstLineContent
.
includes
(
"
{
"
)
)
{
return
this
.
getComplexPattern
(
)
;
}
this
.
_index
=
eol
+
1
;
this
.
skipBlankLines
(
)
;
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
"
)
{
return
firstLineContent
;
}
const
lineStart
=
this
.
_index
;
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
.
"
)
{
this
.
_index
=
lineStart
;
return
firstLineContent
;
}
if
(
firstLineContent
)
{
this
.
_index
=
start
;
}
return
this
.
getComplexPattern
(
)
;
}
getComplexPattern
(
)
{
let
buffer
=
"
"
;
const
content
=
[
]
;
let
placeables
=
0
;
let
ch
=
this
.
_source
[
this
.
_index
]
;
while
(
this
.
_index
<
this
.
_length
)
{
if
(
ch
=
=
=
"
\
n
"
)
{
this
.
_index
+
+
;
const
blankLinesStart
=
this
.
_index
;
this
.
skipBlankLines
(
)
;
const
blankLinesEnd
=
this
.
_index
;
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
"
)
{
break
;
}
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
}
"
|
|
this
.
_source
[
this
.
_index
]
=
=
=
"
[
"
|
|
this
.
_source
[
this
.
_index
]
=
=
=
"
*
"
|
|
this
.
_source
[
this
.
_index
]
=
=
=
"
.
"
)
{
this
.
_index
=
blankLinesEnd
;
break
;
}
buffer
+
=
this
.
_source
.
substring
(
blankLinesStart
blankLinesEnd
)
;
if
(
buffer
.
length
|
|
content
.
length
)
{
buffer
+
=
"
\
n
"
;
}
ch
=
this
.
_source
[
this
.
_index
]
;
continue
;
}
else
if
(
ch
=
=
=
"
\
\
"
)
{
const
ch2
=
this
.
_source
[
this
.
_index
+
1
]
;
if
(
ch2
=
=
=
'
"
'
|
|
ch2
=
=
=
"
{
"
|
|
ch2
=
=
=
"
\
\
"
)
{
ch
=
ch2
;
this
.
_index
+
+
;
}
}
else
if
(
ch
=
=
=
"
{
"
)
{
if
(
buffer
.
length
)
{
content
.
push
(
buffer
)
;
}
if
(
placeables
>
MAX_PLACEABLES
-
1
)
{
throw
this
.
error
(
Too
many
placeables
maximum
allowed
is
{
MAX_PLACEABLES
}
)
;
}
buffer
=
"
"
;
content
.
push
(
this
.
getPlaceable
(
)
)
;
this
.
_index
+
+
;
ch
=
this
.
_source
[
this
.
_index
]
;
placeables
+
+
;
continue
;
}
if
(
ch
)
{
buffer
+
=
ch
;
}
this
.
_index
+
+
;
ch
=
this
.
_source
[
this
.
_index
]
;
}
if
(
content
.
length
=
=
=
0
)
{
return
buffer
.
length
?
buffer
:
null
;
}
if
(
buffer
.
length
)
{
content
.
push
(
buffer
)
;
}
return
content
;
}
getPlaceable
(
)
{
const
start
=
+
+
this
.
_index
;
this
.
skipWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
*
"
|
|
(
this
.
_source
[
this
.
_index
]
=
=
=
"
[
"
&
&
this
.
_source
[
this
.
_index
+
1
]
!
=
=
"
]
"
)
)
{
const
variants
=
this
.
getVariants
(
)
;
return
{
type
:
"
sel
"
exp
:
null
vars
:
variants
[
0
]
def
:
variants
[
1
]
}
;
}
this
.
_index
=
start
;
this
.
skipInlineWS
(
)
;
const
selector
=
this
.
getSelectorExpression
(
)
;
this
.
skipWS
(
)
;
const
ch
=
this
.
_source
[
this
.
_index
]
;
if
(
ch
=
=
=
"
}
"
)
{
if
(
selector
.
type
=
=
=
"
attr
"
&
&
selector
.
id
.
name
.
startsWith
(
"
-
"
)
)
{
throw
this
.
error
(
"
Attributes
of
private
messages
cannot
be
interpolated
.
"
)
;
}
return
selector
;
}
if
(
ch
!
=
=
"
-
"
|
|
this
.
_source
[
this
.
_index
+
1
]
!
=
=
"
>
"
)
{
throw
this
.
error
(
'
Expected
"
}
"
or
"
-
>
"
'
)
;
}
if
(
selector
.
type
=
=
=
"
ref
"
)
{
throw
this
.
error
(
"
Message
references
cannot
be
used
as
selectors
.
"
)
;
}
if
(
selector
.
type
=
=
=
"
var
"
)
{
throw
this
.
error
(
"
Variants
cannot
be
used
as
selectors
.
"
)
;
}
if
(
selector
.
type
=
=
=
"
attr
"
&
&
!
selector
.
id
.
name
.
startsWith
(
"
-
"
)
)
{
throw
this
.
error
(
"
Attributes
of
public
messages
cannot
be
used
as
selectors
.
"
)
;
}
this
.
_index
+
=
2
;
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
\
n
"
)
{
throw
this
.
error
(
"
Variants
should
be
listed
in
a
new
line
"
)
;
}
this
.
skipWS
(
)
;
const
variants
=
this
.
getVariants
(
)
;
if
(
variants
[
0
]
.
length
=
=
=
0
)
{
throw
this
.
error
(
"
Expected
members
for
the
select
expression
"
)
;
}
return
{
type
:
"
sel
"
exp
:
selector
vars
:
variants
[
0
]
def
:
variants
[
1
]
}
;
}
getSelectorExpression
(
)
{
const
literal
=
this
.
getLiteral
(
)
;
if
(
literal
.
type
!
=
=
"
ref
"
)
{
return
literal
;
}
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
.
"
)
{
this
.
_index
+
+
;
const
name
=
this
.
getIdentifier
(
)
;
this
.
_index
+
+
;
return
{
type
:
"
attr
"
id
:
literal
name
}
;
}
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
[
"
)
{
this
.
_index
+
+
;
const
key
=
this
.
getVariantKey
(
)
;
this
.
_index
+
+
;
return
{
type
:
"
var
"
id
:
literal
key
}
;
}
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
(
"
)
{
this
.
_index
+
+
;
const
args
=
this
.
getCallArgs
(
)
;
if
(
!
functionIdentifierRe
.
test
(
literal
.
name
)
)
{
throw
this
.
error
(
"
Function
names
must
be
all
upper
-
case
"
)
;
}
this
.
_index
+
+
;
literal
.
type
=
"
fun
"
;
return
{
type
:
"
call
"
fun
:
literal
args
}
;
}
return
literal
;
}
getCallArgs
(
)
{
const
args
=
[
]
;
while
(
this
.
_index
<
this
.
_length
)
{
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
)
"
)
{
return
args
;
}
const
exp
=
this
.
getSelectorExpression
(
)
;
if
(
exp
.
type
!
=
=
"
ref
"
)
{
args
.
push
(
exp
)
;
}
else
{
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
:
"
)
{
this
.
_index
+
+
;
this
.
skipInlineWS
(
)
;
const
val
=
this
.
getSelectorExpression
(
)
;
if
(
typeof
val
=
=
=
"
string
"
|
|
Array
.
isArray
(
val
)
|
|
val
.
type
=
=
=
"
num
"
)
{
args
.
push
(
{
type
:
"
narg
"
name
:
exp
.
name
val
}
)
;
}
else
{
this
.
_index
=
this
.
_source
.
lastIndexOf
(
"
:
"
this
.
_index
)
+
1
;
throw
this
.
error
(
"
Expected
string
in
quotes
number
.
"
)
;
}
}
else
{
args
.
push
(
exp
)
;
}
}
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
)
"
)
{
break
;
}
else
if
(
this
.
_source
[
this
.
_index
]
=
=
=
"
"
)
{
this
.
_index
+
+
;
}
else
{
throw
this
.
error
(
'
Expected
"
"
or
"
)
"
'
)
;
}
}
return
args
;
}
getNumber
(
)
{
let
num
=
"
"
;
let
cc
=
this
.
_source
.
charCodeAt
(
this
.
_index
)
;
if
(
cc
=
=
=
45
)
{
num
+
=
"
-
"
;
cc
=
this
.
_source
.
charCodeAt
(
+
+
this
.
_index
)
;
}
if
(
cc
<
48
|
|
cc
>
57
)
{
throw
this
.
error
(
Unknown
literal
"
{
num
}
"
)
;
}
while
(
cc
>
=
48
&
&
cc
<
=
57
)
{
num
+
=
this
.
_source
[
this
.
_index
+
+
]
;
cc
=
this
.
_source
.
charCodeAt
(
this
.
_index
)
;
}
if
(
cc
=
=
=
46
)
{
num
+
=
this
.
_source
[
this
.
_index
+
+
]
;
cc
=
this
.
_source
.
charCodeAt
(
this
.
_index
)
;
if
(
cc
<
48
|
|
cc
>
57
)
{
throw
this
.
error
(
Unknown
literal
"
{
num
}
"
)
;
}
while
(
cc
>
=
48
&
&
cc
<
=
57
)
{
num
+
=
this
.
_source
[
this
.
_index
+
+
]
;
cc
=
this
.
_source
.
charCodeAt
(
this
.
_index
)
;
}
}
return
{
type
:
"
num
"
val
:
num
}
;
}
getAttributes
(
)
{
const
attrs
=
{
}
;
while
(
this
.
_index
<
this
.
_length
)
{
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
"
)
{
break
;
}
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
.
"
)
{
break
;
}
this
.
_index
+
+
;
const
key
=
this
.
getIdentifier
(
)
;
this
.
skipInlineWS
(
)
;
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
=
"
)
{
throw
this
.
error
(
'
Expected
"
=
"
'
)
;
}
this
.
_index
+
+
;
this
.
skipInlineWS
(
)
;
const
val
=
this
.
getPattern
(
)
;
if
(
val
=
=
=
null
)
{
throw
this
.
error
(
"
Expected
attribute
to
have
a
value
"
)
;
}
if
(
typeof
val
=
=
=
"
string
"
)
{
attrs
[
key
]
=
val
;
}
else
{
attrs
[
key
]
=
{
val
}
;
}
this
.
skipBlankLines
(
)
;
}
return
attrs
;
}
getVariants
(
)
{
const
variants
=
[
]
;
let
index
=
0
;
let
defaultIndex
;
while
(
this
.
_index
<
this
.
_length
)
{
const
ch
=
this
.
_source
[
this
.
_index
]
;
if
(
(
ch
!
=
=
"
[
"
|
|
this
.
_source
[
this
.
_index
+
1
]
=
=
=
"
[
"
)
&
&
ch
!
=
=
"
*
"
)
{
break
;
}
if
(
ch
=
=
=
"
*
"
)
{
this
.
_index
+
+
;
defaultIndex
=
index
;
}
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
[
"
)
{
throw
this
.
error
(
'
Expected
"
[
"
'
)
;
}
this
.
_index
+
+
;
const
key
=
this
.
getVariantKey
(
)
;
this
.
skipInlineWS
(
)
;
const
val
=
this
.
getPattern
(
)
;
if
(
val
=
=
=
null
)
{
throw
this
.
error
(
"
Expected
variant
to
have
a
value
"
)
;
}
variants
[
index
+
+
]
=
{
key
val
}
;
this
.
skipWS
(
)
;
}
return
[
variants
defaultIndex
]
;
}
getVariantKey
(
)
{
const
cc
=
this
.
_source
.
charCodeAt
(
this
.
_index
)
;
let
literal
;
if
(
(
cc
>
=
48
&
&
cc
<
=
57
)
|
|
cc
=
=
=
45
)
{
literal
=
this
.
getNumber
(
)
;
}
else
{
literal
=
this
.
getVariantName
(
)
;
}
if
(
this
.
_source
[
this
.
_index
]
!
=
=
"
]
"
)
{
throw
this
.
error
(
'
Expected
"
]
"
'
)
;
}
this
.
_index
+
+
;
return
literal
;
}
getLiteral
(
)
{
const
cc0
=
this
.
_source
.
charCodeAt
(
this
.
_index
)
;
if
(
cc0
=
=
=
36
)
{
this
.
_index
+
+
;
return
{
type
:
"
ext
"
name
:
this
.
getIdentifier
(
)
}
;
}
const
cc1
=
cc0
=
=
=
45
?
this
.
_source
.
charCodeAt
(
this
.
_index
+
1
)
:
cc0
;
if
(
(
cc1
>
=
97
&
&
cc1
<
=
122
)
|
|
(
cc1
>
=
65
&
&
cc1
<
=
90
)
)
{
return
{
type
:
"
ref
"
name
:
this
.
getEntryIdentifier
(
)
}
;
}
if
(
(
cc1
>
=
48
&
&
cc1
<
=
57
)
)
{
return
this
.
getNumber
(
)
;
}
if
(
cc0
=
=
=
34
)
{
return
this
.
getString
(
)
;
}
throw
this
.
error
(
"
Expected
literal
"
)
;
}
skipComment
(
)
{
let
eol
=
this
.
_source
.
indexOf
(
"
\
n
"
this
.
_index
)
;
while
(
eol
!
=
=
-
1
&
&
(
(
this
.
_source
[
eol
+
1
]
=
=
=
"
/
"
&
&
this
.
_source
[
eol
+
2
]
=
=
=
"
/
"
)
|
|
(
this
.
_source
[
eol
+
1
]
=
=
=
"
#
"
&
&
[
"
"
"
#
"
]
.
includes
(
this
.
_source
[
eol
+
2
]
)
)
)
)
{
this
.
_index
=
eol
+
3
;
eol
=
this
.
_source
.
indexOf
(
"
\
n
"
this
.
_index
)
;
if
(
eol
=
=
=
-
1
)
{
break
;
}
}
if
(
eol
=
=
=
-
1
)
{
this
.
_index
=
this
.
_length
;
}
else
{
this
.
_index
=
eol
+
1
;
}
}
error
(
message
)
{
return
new
SyntaxError
(
message
)
;
}
skipToNextEntryStart
(
)
{
let
start
=
this
.
_index
;
while
(
true
)
{
if
(
start
=
=
=
0
|
|
this
.
_source
[
start
-
1
]
=
=
=
"
\
n
"
)
{
const
cc
=
this
.
_source
.
charCodeAt
(
start
)
;
if
(
(
cc
>
=
97
&
&
cc
<
=
122
)
|
|
(
cc
>
=
65
&
&
cc
<
=
90
)
|
|
cc
=
=
=
47
|
|
cc
=
=
=
91
)
{
this
.
_index
=
start
;
return
;
}
}
start
=
this
.
_source
.
indexOf
(
"
\
n
"
start
)
;
if
(
start
=
=
=
-
1
)
{
this
.
_index
=
this
.
_length
;
return
;
}
start
+
+
;
}
}
}
function
parse
(
string
)
{
const
parser
=
new
RuntimeParser
(
)
;
return
parser
.
getResource
(
string
)
;
}
class
FluentType
{
constructor
(
value
opts
)
{
this
.
value
=
value
;
this
.
opts
=
opts
;
}
valueOf
(
)
{
return
this
.
value
;
}
toString
(
)
{
throw
new
Error
(
"
Subclasses
of
FluentType
must
implement
toString
.
"
)
;
}
}
class
FluentNone
extends
FluentType
{
toString
(
)
{
return
this
.
value
|
|
"
?
?
?
"
;
}
}
class
FluentNumber
extends
FluentType
{
constructor
(
value
opts
)
{
super
(
parseFloat
(
value
)
opts
)
;
}
toString
(
ctx
)
{
try
{
const
nf
=
ctx
.
_memoizeIntlObject
(
Intl
.
NumberFormat
this
.
opts
)
;
return
nf
.
format
(
this
.
value
)
;
}
catch
(
e
)
{
return
this
.
value
;
}
}
match
(
ctx
other
)
{
if
(
other
instanceof
FluentNumber
)
{
return
this
.
value
=
=
=
other
.
value
;
}
return
false
;
}
}
class
FluentDateTime
extends
FluentType
{
constructor
(
value
opts
)
{
super
(
new
Date
(
value
)
opts
)
;
}
toString
(
ctx
)
{
try
{
const
dtf
=
ctx
.
_memoizeIntlObject
(
Intl
.
DateTimeFormat
this
.
opts
)
;
return
dtf
.
format
(
this
.
value
)
;
}
catch
(
e
)
{
return
this
.
value
;
}
}
}
class
FluentSymbol
extends
FluentType
{
toString
(
)
{
return
this
.
value
;
}
match
(
ctx
other
)
{
if
(
other
instanceof
FluentSymbol
)
{
return
this
.
value
=
=
=
other
.
value
;
}
else
if
(
typeof
other
=
=
=
"
string
"
)
{
return
this
.
value
=
=
=
other
;
}
else
if
(
other
instanceof
FluentNumber
)
{
const
pr
=
ctx
.
_memoizeIntlObject
(
Intl
.
PluralRules
other
.
opts
)
;
return
this
.
value
=
=
=
pr
.
select
(
other
.
value
)
;
}
return
false
;
}
}
const
builtins
=
{
"
NUMBER
"
:
(
[
arg
]
opts
)
=
>
new
FluentNumber
(
arg
.
valueOf
(
)
merge
(
arg
.
opts
opts
)
)
"
DATETIME
"
:
(
[
arg
]
opts
)
=
>
new
FluentDateTime
(
arg
.
valueOf
(
)
merge
(
arg
.
opts
opts
)
)
}
;
function
merge
(
argopts
opts
)
{
return
Object
.
assign
(
{
}
argopts
values
(
opts
)
)
;
}
function
values
(
opts
)
{
const
unwrapped
=
{
}
;
for
(
const
[
name
opt
]
of
Object
.
entries
(
opts
)
)
{
unwrapped
[
name
]
=
opt
.
valueOf
(
)
;
}
return
unwrapped
;
}
const
MAX_PLACEABLE_LENGTH
=
2500
;
const
FSI
=
"
\
u2068
"
;
const
PDI
=
"
\
u2069
"
;
function
DefaultMember
(
env
members
def
)
{
if
(
members
[
def
]
)
{
return
members
[
def
]
;
}
const
{
errors
}
=
env
;
errors
.
push
(
new
RangeError
(
"
No
default
"
)
)
;
return
new
FluentNone
(
)
;
}
function
MessageReference
(
env
{
name
}
)
{
const
{
ctx
errors
}
=
env
;
const
message
=
name
.
startsWith
(
"
-
"
)
?
ctx
.
_terms
.
get
(
name
)
:
ctx
.
_messages
.
get
(
name
)
;
if
(
!
message
)
{
const
err
=
name
.
startsWith
(
"
-
"
)
?
new
ReferenceError
(
Unknown
term
:
{
name
}
)
:
new
ReferenceError
(
Unknown
message
:
{
name
}
)
;
errors
.
push
(
err
)
;
return
new
FluentNone
(
name
)
;
}
return
message
;
}
function
VariantExpression
(
env
{
id
key
}
)
{
const
message
=
MessageReference
(
env
id
)
;
if
(
message
instanceof
FluentNone
)
{
return
message
;
}
const
{
ctx
errors
}
=
env
;
const
keyword
=
Type
(
env
key
)
;
function
isVariantList
(
node
)
{
return
Array
.
isArray
(
node
)
&
&
node
[
0
]
.
type
=
=
=
"
sel
"
&
&
node
[
0
]
.
exp
=
=
=
null
;
}
if
(
isVariantList
(
message
.
val
)
)
{
for
(
const
variant
of
message
.
val
[
0
]
.
vars
)
{
const
variantKey
=
Type
(
env
variant
.
key
)
;
if
(
keyword
.
match
(
ctx
variantKey
)
)
{
return
variant
;
}
}
}
errors
.
push
(
new
ReferenceError
(
Unknown
variant
:
{
keyword
.
toString
(
ctx
)
}
)
)
;
return
Type
(
env
message
)
;
}
function
AttributeExpression
(
env
{
id
name
}
)
{
const
message
=
MessageReference
(
env
id
)
;
if
(
message
instanceof
FluentNone
)
{
return
message
;
}
if
(
message
.
attrs
)
{
for
(
const
attrName
in
message
.
attrs
)
{
if
(
name
=
=
=
attrName
)
{
return
message
.
attrs
[
name
]
;
}
}
}
const
{
errors
}
=
env
;
errors
.
push
(
new
ReferenceError
(
Unknown
attribute
:
{
name
}
)
)
;
return
Type
(
env
message
)
;
}
function
SelectExpression
(
env
{
exp
vars
def
}
)
{
if
(
exp
=
=
=
null
)
{
return
DefaultMember
(
env
vars
def
)
;
}
const
selector
=
Type
(
env
exp
)
;
if
(
selector
instanceof
FluentNone
)
{
return
DefaultMember
(
env
vars
def
)
;
}
for
(
const
variant
of
vars
)
{
const
key
=
Type
(
env
variant
.
key
)
;
const
keyCanMatch
=
key
instanceof
FluentNumber
|
|
key
instanceof
FluentSymbol
;
if
(
!
keyCanMatch
)
{
continue
;
}
const
{
ctx
}
=
env
;
if
(
key
.
match
(
ctx
selector
)
)
{
return
variant
;
}
}
return
DefaultMember
(
env
vars
def
)
;
}
function
Type
(
env
expr
)
{
if
(
typeof
expr
=
=
=
"
string
"
)
{
return
env
.
ctx
.
_transform
(
expr
)
;
}
if
(
expr
instanceof
FluentNone
)
{
return
expr
;
}
if
(
Array
.
isArray
(
expr
)
)
{
return
Pattern
(
env
expr
)
;
}
switch
(
expr
.
type
)
{
case
"
varname
"
:
return
new
FluentSymbol
(
expr
.
name
)
;
case
"
num
"
:
return
new
FluentNumber
(
expr
.
val
)
;
case
"
ext
"
:
return
ExternalArgument
(
env
expr
)
;
case
"
fun
"
:
return
FunctionReference
(
env
expr
)
;
case
"
call
"
:
return
CallExpression
(
env
expr
)
;
case
"
ref
"
:
{
const
message
=
MessageReference
(
env
expr
)
;
return
Type
(
env
message
)
;
}
case
"
attr
"
:
{
const
attr
=
AttributeExpression
(
env
expr
)
;
return
Type
(
env
attr
)
;
}
case
"
var
"
:
{
const
variant
=
VariantExpression
(
env
expr
)
;
return
Type
(
env
variant
)
;
}
case
"
sel
"
:
{
const
member
=
SelectExpression
(
env
expr
)
;
return
Type
(
env
member
)
;
}
case
undefined
:
{
if
(
expr
.
val
!
=
=
null
&
&
expr
.
val
!
=
=
undefined
)
{
return
Type
(
env
expr
.
val
)
;
}
const
{
errors
}
=
env
;
errors
.
push
(
new
RangeError
(
"
No
value
"
)
)
;
return
new
FluentNone
(
)
;
}
default
:
return
new
FluentNone
(
)
;
}
}
function
ExternalArgument
(
env
{
name
}
)
{
const
{
args
errors
}
=
env
;
if
(
!
args
|
|
!
args
.
hasOwnProperty
(
name
)
)
{
errors
.
push
(
new
ReferenceError
(
Unknown
external
:
{
name
}
)
)
;
return
new
FluentNone
(
name
)
;
}
const
arg
=
args
[
name
]
;
if
(
arg
instanceof
FluentType
)
{
return
arg
;
}
switch
(
typeof
arg
)
{
case
"
string
"
:
return
arg
;
case
"
number
"
:
return
new
FluentNumber
(
arg
)
;
case
"
object
"
:
if
(
arg
instanceof
Date
)
{
return
new
FluentDateTime
(
arg
)
;
}
default
:
errors
.
push
(
new
TypeError
(
Unsupported
external
type
:
{
name
}
{
typeof
arg
}
)
)
;
return
new
FluentNone
(
name
)
;
}
}
function
FunctionReference
(
env
{
name
}
)
{
const
{
ctx
:
{
_functions
}
errors
}
=
env
;
const
func
=
_functions
[
name
]
|
|
builtins
[
name
]
;
if
(
!
func
)
{
errors
.
push
(
new
ReferenceError
(
Unknown
function
:
{
name
}
(
)
)
)
;
return
new
FluentNone
(
{
name
}
(
)
)
;
}
if
(
typeof
func
!
=
=
"
function
"
)
{
errors
.
push
(
new
TypeError
(
Function
{
name
}
(
)
is
not
callable
)
)
;
return
new
FluentNone
(
{
name
}
(
)
)
;
}
return
func
;
}
function
CallExpression
(
env
{
fun
args
}
)
{
const
callee
=
FunctionReference
(
env
fun
)
;
if
(
callee
instanceof
FluentNone
)
{
return
callee
;
}
const
posargs
=
[
]
;
const
keyargs
=
{
}
;
for
(
const
arg
of
args
)
{
if
(
arg
.
type
=
=
=
"
narg
"
)
{
keyargs
[
arg
.
name
]
=
Type
(
env
arg
.
val
)
;
}
else
{
posargs
.
push
(
Type
(
env
arg
)
)
;
}
}
try
{
return
callee
(
posargs
keyargs
)
;
}
catch
(
e
)
{
return
new
FluentNone
(
)
;
}
}
function
Pattern
(
env
ptn
)
{
const
{
ctx
dirty
errors
}
=
env
;
if
(
dirty
.
has
(
ptn
)
)
{
errors
.
push
(
new
RangeError
(
"
Cyclic
reference
"
)
)
;
return
new
FluentNone
(
)
;
}
dirty
.
add
(
ptn
)
;
const
result
=
[
]
;
const
useIsolating
=
ctx
.
_useIsolating
&
&
ptn
.
length
>
1
;
for
(
const
elem
of
ptn
)
{
if
(
typeof
elem
=
=
=
"
string
"
)
{
result
.
push
(
ctx
.
_transform
(
elem
)
)
;
continue
;
}
const
part
=
Type
(
env
elem
)
.
toString
(
ctx
)
;
if
(
useIsolating
)
{
result
.
push
(
FSI
)
;
}
if
(
part
.
length
>
MAX_PLACEABLE_LENGTH
)
{
errors
.
push
(
new
RangeError
(
"
Too
many
characters
in
placeable
"
+
(
{
part
.
length
}
max
allowed
is
{
MAX_PLACEABLE_LENGTH
}
)
)
)
;
result
.
push
(
part
.
slice
(
MAX_PLACEABLE_LENGTH
)
)
;
}
else
{
result
.
push
(
part
)
;
}
if
(
useIsolating
)
{
result
.
push
(
PDI
)
;
}
}
dirty
.
delete
(
ptn
)
;
return
result
.
join
(
"
"
)
;
}
function
resolve
(
ctx
args
message
errors
=
[
]
)
{
const
env
=
{
ctx
args
errors
dirty
:
new
WeakSet
(
)
}
;
return
Type
(
env
message
)
.
toString
(
ctx
)
;
}
class
FluentResource
extends
Map
{
constructor
(
entries
errors
=
[
]
)
{
super
(
entries
)
;
this
.
errors
=
errors
;
}
static
fromString
(
source
)
{
const
[
entries
errors
]
=
parse
(
source
)
;
return
new
FluentResource
(
Object
.
entries
(
entries
)
errors
)
;
}
}
class
MessageContext
{
constructor
(
locales
{
functions
=
{
}
useIsolating
=
true
transform
=
v
=
>
v
}
=
{
}
)
{
this
.
locales
=
Array
.
isArray
(
locales
)
?
locales
:
[
locales
]
;
this
.
_terms
=
new
Map
(
)
;
this
.
_messages
=
new
Map
(
)
;
this
.
_functions
=
functions
;
this
.
_useIsolating
=
useIsolating
;
this
.
_transform
=
transform
;
this
.
_intls
=
new
WeakMap
(
)
;
}
get
messages
(
)
{
return
this
.
_messages
[
Symbol
.
iterator
]
(
)
;
}
hasMessage
(
id
)
{
return
this
.
_messages
.
has
(
id
)
;
}
getMessage
(
id
)
{
return
this
.
_messages
.
get
(
id
)
;
}
addMessages
(
source
)
{
const
res
=
FluentResource
.
fromString
(
source
)
;
return
this
.
addResource
(
res
)
;
}
addResource
(
res
)
{
const
errors
=
res
.
errors
.
slice
(
)
;
for
(
const
[
id
value
]
of
res
)
{
if
(
id
.
startsWith
(
"
-
"
)
)
{
if
(
this
.
_terms
.
has
(
id
)
)
{
errors
.
push
(
Attempt
to
override
an
existing
term
:
"
{
id
}
"
)
;
continue
;
}
this
.
_terms
.
set
(
id
value
)
;
}
else
{
if
(
this
.
_messages
.
has
(
id
)
)
{
errors
.
push
(
Attempt
to
override
an
existing
message
:
"
{
id
}
"
)
;
continue
;
}
this
.
_messages
.
set
(
id
value
)
;
}
}
return
errors
;
}
format
(
message
args
errors
)
{
if
(
typeof
message
=
=
=
"
string
"
)
{
return
this
.
_transform
(
message
)
;
}
if
(
typeof
message
.
val
=
=
=
"
string
"
)
{
return
this
.
_transform
(
message
.
val
)
;
}
if
(
message
.
val
=
=
=
undefined
)
{
return
null
;
}
return
resolve
(
this
args
message
errors
)
;
}
_memoizeIntlObject
(
ctor
opts
)
{
const
cache
=
this
.
_intls
.
get
(
ctor
)
|
|
{
}
;
const
id
=
JSON
.
stringify
(
opts
)
;
if
(
!
cache
[
id
]
)
{
cache
[
id
]
=
new
ctor
(
this
.
locales
opts
)
;
this
.
_intls
.
set
(
ctor
cache
)
;
}
return
cache
[
id
]
;
}
}
this
.
MessageContext
=
MessageContext
;
this
.
FluentResource
=
FluentResource
;
var
EXPORTED_SYMBOLS
=
[
"
MessageContext
"
"
FluentResource
"
]
;
