const
{
L10nRegistry
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
L10nRegistry
.
jsm
"
{
}
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
{
}
)
;
class
CachedIterable
extends
Array
{
static
from
(
iterable
)
{
if
(
iterable
instanceof
this
)
{
return
iterable
;
}
return
new
this
(
iterable
)
;
}
}
class
CachedAsyncIterable
extends
CachedIterable
{
constructor
(
iterable
)
{
super
(
)
;
if
(
Symbol
.
asyncIterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
asyncIterator
]
(
)
;
}
else
if
(
Symbol
.
iterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
iterator
]
(
)
;
}
else
{
throw
new
TypeError
(
"
Argument
must
implement
the
iteration
protocol
.
"
)
;
}
}
[
Symbol
.
iterator
]
(
)
{
const
cached
=
this
;
let
cur
=
0
;
return
{
next
(
)
{
if
(
cached
.
length
=
=
=
cur
)
{
return
{
value
:
undefined
done
:
true
}
;
}
return
cached
[
cur
+
+
]
;
}
}
;
}
[
Symbol
.
asyncIterator
]
(
)
{
const
cached
=
this
;
let
cur
=
0
;
return
{
async
next
(
)
{
if
(
cached
.
length
<
=
cur
)
{
cached
.
push
(
await
cached
.
iterator
.
next
(
)
)
;
}
return
cached
[
cur
+
+
]
;
}
}
;
}
async
touchNext
(
count
=
1
)
{
let
idx
=
0
;
while
(
idx
+
+
<
count
)
{
const
last
=
this
[
this
.
length
-
1
]
;
if
(
last
&
&
last
.
done
)
{
break
;
}
this
.
push
(
await
this
.
iterator
.
next
(
)
)
;
}
return
this
[
this
.
length
-
1
]
;
}
}
function
defaultGenerateMessages
(
resourceIds
)
{
const
appLocales
=
Services
.
locale
.
getAppLocalesAsBCP47
(
)
;
return
L10nRegistry
.
generateContexts
(
appLocales
resourceIds
)
;
}
class
Localization
{
constructor
(
resourceIds
=
[
]
generateMessages
=
defaultGenerateMessages
)
{
this
.
resourceIds
=
resourceIds
;
this
.
generateMessages
=
generateMessages
;
this
.
ctxs
=
CachedAsyncIterable
.
from
(
this
.
generateMessages
(
this
.
resourceIds
)
)
;
}
addResourceIds
(
resourceIds
)
{
this
.
resourceIds
.
push
(
.
.
.
resourceIds
)
;
this
.
onChange
(
)
;
return
this
.
resourceIds
.
length
;
}
removeResourceIds
(
resourceIds
)
{
this
.
resourceIds
=
this
.
resourceIds
.
filter
(
r
=
>
!
resourceIds
.
includes
(
r
)
)
;
this
.
onChange
(
)
;
return
this
.
resourceIds
.
length
;
}
async
formatWithFallback
(
keys
method
)
{
const
translations
=
[
]
;
for
await
(
const
ctx
of
this
.
ctxs
)
{
const
missingIds
=
keysFromContext
(
method
ctx
keys
translations
)
;
if
(
missingIds
.
size
=
=
=
0
)
{
break
;
}
if
(
AppConstants
.
NIGHTLY_BUILD
|
|
Cu
.
isInAutomation
)
{
const
locale
=
ctx
.
locales
[
0
]
;
const
ids
=
Array
.
from
(
missingIds
)
.
join
(
"
"
)
;
if
(
Cu
.
isInAutomation
)
{
throw
new
Error
(
Missing
translations
in
{
locale
}
:
{
ids
}
)
;
}
console
.
warn
(
Missing
translations
in
{
locale
}
:
{
ids
}
)
;
}
}
return
translations
;
}
formatMessages
(
keys
)
{
return
this
.
formatWithFallback
(
keys
messageFromContext
)
;
}
formatValues
(
keys
)
{
return
this
.
formatWithFallback
(
keys
valueFromContext
)
;
}
async
formatValue
(
id
args
)
{
const
[
val
]
=
await
this
.
formatValues
(
[
{
id
args
}
]
)
;
return
val
;
}
registerObservers
(
)
{
Services
.
obs
.
addObserver
(
this
"
intl
:
app
-
locales
-
changed
"
true
)
;
Services
.
prefs
.
addObserver
(
"
intl
.
l10n
.
pseudo
"
this
true
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
intl
:
app
-
locales
-
changed
"
:
this
.
onChange
(
)
;
break
;
case
"
nsPref
:
changed
"
:
switch
(
data
)
{
case
"
intl
.
l10n
.
pseudo
"
:
this
.
onChange
(
)
;
}
break
;
default
:
break
;
}
}
onChange
(
)
{
this
.
ctxs
=
CachedAsyncIterable
.
from
(
this
.
generateMessages
(
this
.
resourceIds
)
)
;
this
.
ctxs
.
touchNext
(
2
)
;
}
}
Localization
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
]
)
;
function
valueFromContext
(
ctx
errors
id
args
)
{
const
msg
=
ctx
.
getMessage
(
id
)
;
return
ctx
.
format
(
msg
args
errors
)
;
}
function
messageFromContext
(
ctx
errors
id
args
)
{
const
msg
=
ctx
.
getMessage
(
id
)
;
const
formatted
=
{
value
:
ctx
.
format
(
msg
args
errors
)
attributes
:
null
}
;
if
(
msg
.
attrs
)
{
formatted
.
attributes
=
[
]
;
for
(
const
[
name
attr
]
of
Object
.
entries
(
msg
.
attrs
)
)
{
const
value
=
ctx
.
format
(
attr
args
errors
)
;
if
(
value
!
=
=
null
)
{
formatted
.
attributes
.
push
(
{
name
value
}
)
;
}
}
}
return
formatted
;
}
function
keysFromContext
(
method
ctx
keys
translations
)
{
const
messageErrors
=
[
]
;
const
missingIds
=
new
Set
(
)
;
keys
.
forEach
(
(
{
id
args
}
i
)
=
>
{
if
(
translations
[
i
]
!
=
=
undefined
)
{
return
;
}
if
(
ctx
.
hasMessage
(
id
)
)
{
messageErrors
.
length
=
0
;
translations
[
i
]
=
method
(
ctx
messageErrors
id
args
)
;
}
else
{
missingIds
.
add
(
id
)
;
}
}
)
;
return
missingIds
;
}
this
.
Localization
=
Localization
;
var
EXPORTED_SYMBOLS
=
[
"
Localization
"
]
;
