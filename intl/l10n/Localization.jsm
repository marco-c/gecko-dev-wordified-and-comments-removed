const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
{
}
)
;
const
{
L10nRegistry
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
L10nRegistry
.
jsm
"
{
}
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
{
}
)
;
class
CachedAsyncIterable
{
constructor
(
iterable
)
{
if
(
Symbol
.
asyncIterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
asyncIterator
]
(
)
;
}
else
if
(
Symbol
.
iterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
iterator
]
(
)
;
}
else
{
throw
new
TypeError
(
"
Argument
must
implement
the
iteration
protocol
.
"
)
;
}
this
.
seen
=
[
]
;
}
[
Symbol
.
iterator
]
(
)
{
const
{
seen
iterator
}
=
this
;
let
cur
=
0
;
return
{
next
(
)
{
if
(
seen
.
length
<
=
cur
)
{
seen
.
push
(
iterator
.
next
(
)
)
;
}
return
seen
[
cur
+
+
]
;
}
}
;
}
[
Symbol
.
asyncIterator
]
(
)
{
const
{
seen
iterator
}
=
this
;
let
cur
=
0
;
return
{
async
next
(
)
{
if
(
seen
.
length
<
=
cur
)
{
seen
.
push
(
await
iterator
.
next
(
)
)
;
}
return
seen
[
cur
+
+
]
;
}
}
;
}
async
touchNext
(
count
=
1
)
{
const
{
seen
iterator
}
=
this
;
let
idx
=
0
;
while
(
idx
+
+
<
count
)
{
if
(
seen
.
length
=
=
=
0
|
|
seen
[
seen
.
length
-
1
]
.
done
=
=
=
false
)
{
seen
.
push
(
await
iterator
.
next
(
)
)
;
}
}
}
}
function
defaultGenerateMessages
(
resourceIds
)
{
const
appLocales
=
Services
.
locale
.
getAppLocalesAsBCP47
(
)
;
return
L10nRegistry
.
generateContexts
(
appLocales
resourceIds
)
;
}
class
Localization
{
constructor
(
resourceIds
generateMessages
=
defaultGenerateMessages
)
{
this
.
resourceIds
=
resourceIds
;
this
.
generateMessages
=
generateMessages
;
this
.
ctxs
=
new
CachedAsyncIterable
(
this
.
generateMessages
(
this
.
resourceIds
)
)
;
}
async
formatWithFallback
(
keys
method
)
{
const
translations
=
[
]
;
for
await
(
let
ctx
of
this
.
ctxs
)
{
if
(
typeof
ctx
.
then
=
=
=
"
function
"
)
{
ctx
=
await
ctx
;
}
const
missingIds
=
keysFromContext
(
method
ctx
keys
translations
)
;
if
(
missingIds
.
size
=
=
=
0
)
{
break
;
}
if
(
AppConstants
.
NIGHTLY_BUILD
)
{
const
locale
=
ctx
.
locales
[
0
]
;
const
ids
=
Array
.
from
(
missingIds
)
.
join
(
"
"
)
;
console
.
warn
(
Missing
translations
in
{
locale
}
:
{
ids
}
)
;
}
}
return
translations
;
}
formatMessages
(
keys
)
{
return
this
.
formatWithFallback
(
keys
messageFromContext
)
;
}
formatValues
(
keys
)
{
return
this
.
formatWithFallback
(
keys
valueFromContext
)
;
}
async
formatValue
(
id
args
)
{
const
[
val
]
=
await
this
.
formatValues
(
[
[
id
args
]
]
)
;
return
val
;
}
registerObservers
(
)
{
Services
.
obs
.
addObserver
(
this
"
intl
:
app
-
locales
-
changed
"
true
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
intl
:
app
-
locales
-
changed
"
:
this
.
onLanguageChange
(
)
;
break
;
default
:
break
;
}
}
onLanguageChange
(
)
{
this
.
ctxs
=
new
CachedAsyncIterable
(
this
.
generateMessages
(
this
.
resourceIds
)
)
;
}
}
Localization
.
prototype
.
QueryInterface
=
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
]
)
;
function
valueFromContext
(
ctx
errors
id
args
)
{
const
msg
=
ctx
.
getMessage
(
id
)
;
return
ctx
.
format
(
msg
args
errors
)
;
}
function
messageFromContext
(
ctx
errors
id
args
)
{
const
msg
=
ctx
.
getMessage
(
id
)
;
const
formatted
=
{
value
:
ctx
.
format
(
msg
args
errors
)
attributes
:
null
}
;
if
(
msg
.
attrs
)
{
formatted
.
attributes
=
[
]
;
for
(
const
[
name
attr
]
of
Object
.
entries
(
msg
.
attrs
)
)
{
const
value
=
ctx
.
format
(
attr
args
errors
)
;
if
(
value
!
=
=
null
)
{
formatted
.
attributes
.
push
(
{
name
value
}
)
;
}
}
}
return
formatted
;
}
function
keysFromContext
(
method
ctx
keys
translations
)
{
const
messageErrors
=
[
]
;
const
missingIds
=
new
Set
(
)
;
keys
.
forEach
(
(
key
i
)
=
>
{
if
(
translations
[
i
]
!
=
=
undefined
)
{
return
;
}
if
(
ctx
.
hasMessage
(
key
[
0
]
)
)
{
messageErrors
.
length
=
0
;
translations
[
i
]
=
method
(
ctx
messageErrors
key
[
0
]
key
[
1
]
)
;
}
else
{
missingIds
.
add
(
key
[
0
]
)
;
}
}
)
;
return
missingIds
;
}
this
.
Localization
=
Localization
;
var
EXPORTED_SYMBOLS
=
[
"
Localization
"
]
;
