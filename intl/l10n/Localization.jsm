const
Cu
=
Components
.
utils
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
{
L10nRegistry
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
L10nRegistry
.
jsm
"
{
}
)
;
const
LocaleService
=
Cc
[
"
mozilla
.
org
/
intl
/
localeservice
;
1
"
]
.
getService
(
Ci
.
mozILocaleService
)
;
const
ObserverService
=
Cc
[
"
mozilla
.
org
/
observer
-
service
;
1
"
]
.
getService
(
Ci
.
nsIObserverService
)
;
class
CachedIterable
{
constructor
(
iterable
)
{
if
(
!
(
Symbol
.
asyncIterator
in
Object
(
iterable
)
)
)
{
throw
new
TypeError
(
'
Argument
must
implement
the
async
iteration
protocol
.
'
)
;
}
this
.
iterator
=
iterable
[
Symbol
.
asyncIterator
]
(
)
;
this
.
seen
=
[
]
;
}
[
Symbol
.
asyncIterator
]
(
)
{
const
{
seen
iterator
}
=
this
;
let
cur
=
0
;
return
{
async
next
(
)
{
if
(
seen
.
length
<
=
cur
)
{
seen
.
push
(
await
iterator
.
next
(
)
)
;
}
return
seen
[
cur
+
+
]
;
}
}
;
}
}
class
L10nError
extends
Error
{
constructor
(
message
)
{
super
(
)
;
this
.
name
=
'
L10nError
'
;
this
.
message
=
message
;
}
}
function
defaultGenerateMessages
(
resourceIds
)
{
const
availableLocales
=
L10nRegistry
.
getAvailableLocales
(
)
;
const
requestedLocales
=
LocaleService
.
getRequestedLocales
(
)
;
const
defaultLocale
=
LocaleService
.
defaultLocale
;
const
locales
=
LocaleService
.
negotiateLanguages
(
requestedLocales
availableLocales
defaultLocale
)
;
return
L10nRegistry
.
generateContexts
(
locales
resourceIds
)
;
}
class
Localization
{
constructor
(
resourceIds
generateMessages
=
defaultGenerateMessages
)
{
this
.
resourceIds
=
resourceIds
;
this
.
generateMessages
=
generateMessages
;
this
.
ctxs
=
new
CachedIterable
(
this
.
generateMessages
(
this
.
resourceIds
)
)
;
}
async
formatWithFallback
(
keys
method
)
{
const
translations
=
[
]
;
for
await
(
let
ctx
of
this
.
ctxs
)
{
if
(
typeof
ctx
.
then
=
=
=
'
function
'
)
{
ctx
=
await
ctx
;
}
const
errors
=
keysFromContext
(
method
ctx
keys
translations
)
;
if
(
!
errors
)
{
break
;
}
}
return
translations
;
}
formatMessages
(
keys
)
{
return
this
.
formatWithFallback
(
keys
messageFromContext
)
;
}
formatValues
(
keys
)
{
return
this
.
formatWithFallback
(
keys
valueFromContext
)
;
}
async
formatValue
(
id
args
)
{
const
[
val
]
=
await
this
.
formatValues
(
[
[
id
args
]
]
)
;
return
val
;
}
registerObservers
(
)
{
ObserverService
.
addObserver
(
this
'
l10n
:
available
-
locales
-
changed
'
false
)
;
ObserverService
.
addObserver
(
this
'
intl
:
requested
-
locales
-
changed
'
false
)
;
}
unregisterObservers
(
)
{
ObserverService
.
removeObserver
(
this
'
l10n
:
available
-
locales
-
changed
'
)
;
ObserverService
.
removeObserver
(
this
'
intl
:
requested
-
locales
-
changed
'
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
'
l10n
:
available
-
locales
-
changed
'
:
case
'
intl
:
requested
-
locales
-
changed
'
:
this
.
onLanguageChange
(
)
;
break
;
default
:
break
;
}
}
onLanguageChange
(
)
{
this
.
ctxs
=
new
CachedIterable
(
this
.
generateMessages
(
this
.
resourceIds
)
)
;
}
}
function
valueFromContext
(
ctx
errors
id
args
)
{
const
msg
=
ctx
.
getMessage
(
id
)
;
if
(
msg
=
=
=
undefined
)
{
errors
.
push
(
new
L10nError
(
Unknown
entity
:
{
id
}
)
)
;
return
id
;
}
return
ctx
.
format
(
msg
args
errors
)
;
}
function
messageFromContext
(
ctx
errors
id
args
)
{
const
msg
=
ctx
.
getMessage
(
id
)
;
if
(
msg
=
=
=
undefined
)
{
errors
.
push
(
new
L10nError
(
Unknown
message
:
{
id
}
)
)
;
return
{
value
:
id
attrs
:
null
}
;
}
const
formatted
=
{
value
:
ctx
.
format
(
msg
args
errors
)
attrs
:
null
}
;
if
(
msg
.
attrs
)
{
formatted
.
attrs
=
[
]
;
for
(
const
attrName
in
msg
.
attrs
)
{
const
formattedAttr
=
ctx
.
format
(
msg
.
attrs
[
attrName
]
args
errors
)
;
if
(
formattedAttr
!
=
=
null
)
{
formatted
.
attrs
.
push
(
[
attrName
formattedAttr
]
)
;
}
}
}
return
formatted
;
}
function
keysFromContext
(
method
ctx
keys
translations
)
{
const
messageErrors
=
[
]
;
let
hasErrors
=
false
;
keys
.
forEach
(
(
key
i
)
=
>
{
if
(
translations
[
i
]
!
=
=
undefined
)
{
return
;
}
messageErrors
.
length
=
0
;
const
translation
=
method
(
ctx
messageErrors
key
[
0
]
key
[
1
]
)
;
if
(
messageErrors
.
length
=
=
=
0
|
|
!
messageErrors
.
some
(
e
=
>
e
instanceof
L10nError
)
)
{
translations
[
i
]
=
translation
;
}
else
{
hasErrors
=
true
;
}
if
(
messageErrors
.
length
)
{
const
{
console
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
messageErrors
.
forEach
(
error
=
>
console
.
warn
(
error
)
)
;
}
}
)
;
return
hasErrors
;
}
this
.
Localization
=
Localization
;
this
.
EXPORTED_SYMBOLS
=
[
'
Localization
'
]
;
