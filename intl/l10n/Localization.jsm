const
{
L10nRegistry
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
L10nRegistry
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
class
CachedIterable
extends
Array
{
static
from
(
iterable
)
{
if
(
iterable
instanceof
this
)
{
return
iterable
;
}
return
new
this
(
iterable
)
;
}
}
class
CachedAsyncIterable
extends
CachedIterable
{
constructor
(
iterable
)
{
super
(
)
;
if
(
Symbol
.
asyncIterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
asyncIterator
]
(
)
;
}
else
if
(
Symbol
.
iterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
iterator
]
(
)
;
}
else
{
throw
new
TypeError
(
"
Argument
must
implement
the
iteration
protocol
.
"
)
;
}
}
[
Symbol
.
asyncIterator
]
(
)
{
const
cached
=
this
;
let
cur
=
0
;
return
{
async
next
(
)
{
if
(
cached
.
length
<
=
cur
)
{
cached
.
push
(
cached
.
iterator
.
next
(
)
)
;
}
return
cached
[
cur
+
+
]
;
}
}
;
}
async
touchNext
(
count
=
1
)
{
let
idx
=
0
;
while
(
idx
+
+
<
count
)
{
const
last
=
this
[
this
.
length
-
1
]
;
if
(
last
&
&
(
await
last
)
.
done
)
{
break
;
}
this
.
push
(
this
.
iterator
.
next
(
)
)
;
}
return
this
[
this
.
length
-
1
]
;
}
}
class
CachedSyncIterable
extends
CachedIterable
{
constructor
(
iterable
)
{
super
(
)
;
if
(
Symbol
.
iterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
iterator
]
(
)
;
}
else
{
throw
new
TypeError
(
"
Argument
must
implement
the
iteration
protocol
.
"
)
;
}
}
[
Symbol
.
iterator
]
(
)
{
const
cached
=
this
;
let
cur
=
0
;
return
{
next
(
)
{
if
(
cached
.
length
<
=
cur
)
{
cached
.
push
(
cached
.
iterator
.
next
(
)
)
;
}
return
cached
[
cur
+
+
]
;
}
}
;
}
touchNext
(
count
=
1
)
{
let
idx
=
0
;
while
(
idx
+
+
<
count
)
{
const
last
=
this
[
this
.
length
-
1
]
;
if
(
last
&
&
last
.
done
)
{
break
;
}
this
.
push
(
this
.
iterator
.
next
(
)
)
;
}
return
this
[
this
.
length
-
1
]
;
}
}
function
defaultGenerateBundles
(
resourceIds
)
{
const
appLocales
=
Services
.
locale
.
appLocalesAsBCP47
;
return
L10nRegistry
.
generateBundles
(
appLocales
resourceIds
)
;
}
function
defaultGenerateBundlesSync
(
resourceIds
)
{
const
appLocales
=
Services
.
locale
.
appLocalesAsBCP47
;
return
L10nRegistry
.
generateBundlesSync
(
appLocales
resourceIds
)
;
}
function
maybeReportErrorToGecko
(
error
)
{
if
(
AppConstants
.
NIGHTLY_BUILD
|
|
Cu
.
isInAutomation
)
{
if
(
Cu
.
isInAutomation
)
{
throw
error
;
}
console
.
warn
(
error
)
;
}
}
class
Localization
{
constructor
(
resourceIds
=
[
]
sync
=
false
generateBundles
=
defaultGenerateBundles
generateBundlesSync
=
defaultGenerateBundlesSync
)
{
this
.
isSync
=
sync
;
this
.
resourceIds
=
resourceIds
;
this
.
generateBundles
=
generateBundles
;
this
.
generateBundlesSync
=
generateBundlesSync
;
this
.
onChange
(
true
)
;
}
cached
(
iterable
)
{
if
(
this
.
isSync
)
{
return
CachedSyncIterable
.
from
(
iterable
)
;
}
else
{
return
CachedAsyncIterable
.
from
(
iterable
)
;
}
}
addResourceIds
(
resourceIds
eager
=
false
)
{
this
.
resourceIds
.
push
(
.
.
.
resourceIds
)
;
this
.
onChange
(
eager
)
;
return
this
.
resourceIds
.
length
;
}
removeResourceIds
(
resourceIds
)
{
this
.
resourceIds
=
this
.
resourceIds
.
filter
(
r
=
>
!
resourceIds
.
includes
(
r
)
)
;
this
.
onChange
(
)
;
return
this
.
resourceIds
.
length
;
}
async
formatWithFallback
(
keys
method
)
{
const
translations
=
new
Array
(
keys
.
length
)
;
let
hasAtLeastOneBundle
=
false
;
for
await
(
const
bundle
of
this
.
bundles
)
{
hasAtLeastOneBundle
=
true
;
const
missingIds
=
keysFromBundle
(
method
bundle
keys
translations
)
;
if
(
missingIds
.
size
=
=
=
0
)
{
break
;
}
const
locale
=
bundle
.
locales
[
0
]
;
const
ids
=
Array
.
from
(
missingIds
)
.
join
(
"
"
)
;
maybeReportErrorToGecko
(
[
fluent
]
Missing
translations
in
{
locale
}
:
{
ids
}
.
)
;
}
if
(
!
hasAtLeastOneBundle
)
{
maybeReportErrorToGecko
(
[
fluent
]
Request
for
keys
failed
because
no
resource
bundles
got
generated
.
\
n
keys
:
{
JSON
.
stringify
(
keys
)
}
.
\
n
resourceIds
:
{
JSON
.
stringify
(
this
.
resourceIds
)
}
.
)
;
}
return
translations
;
}
formatWithFallbackSync
(
keys
method
)
{
if
(
!
this
.
isSync
)
{
throw
new
Error
(
"
Can
'
t
use
sync
formatWithFallback
when
state
is
async
.
"
)
;
}
const
translations
=
new
Array
(
keys
.
length
)
;
let
hasAtLeastOneBundle
=
false
;
for
(
const
bundle
of
this
.
bundles
)
{
hasAtLeastOneBundle
=
true
;
const
missingIds
=
keysFromBundle
(
method
bundle
keys
translations
)
;
if
(
missingIds
.
size
=
=
=
0
)
{
break
;
}
const
locale
=
bundle
.
locales
[
0
]
;
const
ids
=
Array
.
from
(
missingIds
)
.
join
(
"
"
)
;
maybeReportErrorToGecko
(
[
fluent
]
Missing
translations
in
{
locale
}
:
{
ids
}
.
)
;
}
if
(
!
hasAtLeastOneBundle
)
{
maybeReportErrorToGecko
(
[
fluent
]
Request
for
keys
failed
because
no
resource
bundles
got
generated
.
\
n
keys
:
{
JSON
.
stringify
(
keys
)
}
.
\
n
resourceIds
:
{
JSON
.
stringify
(
this
.
resourceIds
)
}
.
)
;
}
return
translations
;
}
formatMessages
(
keys
)
{
return
this
.
formatWithFallback
(
keys
messageFromBundle
)
;
}
formatMessagesSync
(
keys
)
{
return
this
.
formatWithFallbackSync
(
keys
messageFromBundle
)
;
}
formatValues
(
keys
)
{
return
this
.
formatWithFallback
(
keys
valueFromBundle
)
;
}
formatValuesSync
(
keys
)
{
return
this
.
formatWithFallbackSync
(
keys
valueFromBundle
)
;
}
async
formatValue
(
id
args
)
{
const
[
val
]
=
await
this
.
formatValues
(
[
{
id
args
}
]
)
;
return
val
;
}
formatValueSync
(
id
args
)
{
const
[
val
]
=
this
.
formatValuesSync
(
[
{
id
args
}
]
)
;
return
val
;
}
registerObservers
(
)
{
Services
.
obs
.
addObserver
(
this
"
intl
:
app
-
locales
-
changed
"
true
)
;
Services
.
prefs
.
addObserver
(
"
intl
.
l10n
.
pseudo
"
this
true
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
intl
:
app
-
locales
-
changed
"
:
this
.
onChange
(
)
;
break
;
case
"
nsPref
:
changed
"
:
switch
(
data
)
{
case
"
intl
.
l10n
.
pseudo
"
:
this
.
onChange
(
)
;
}
break
;
default
:
break
;
}
}
onChange
(
eager
=
false
)
{
let
generateMessages
=
this
.
isSync
?
this
.
generateBundlesSync
:
this
.
generateBundles
;
this
.
bundles
=
this
.
cached
(
generateMessages
(
this
.
resourceIds
)
)
;
if
(
eager
)
{
const
appLocale
=
Services
.
locale
.
appLocaleAsBCP47
;
const
lastFallback
=
Services
.
locale
.
lastFallbackLocale
;
const
prefetchCount
=
appLocale
=
=
=
lastFallback
?
1
:
2
;
this
.
bundles
.
touchNext
(
prefetchCount
)
;
}
}
setIsSync
(
isSync
)
{
this
.
isSync
=
isSync
;
this
.
onChange
(
)
;
}
}
Localization
.
prototype
.
QueryInterface
=
ChromeUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
]
)
;
function
valueFromBundle
(
bundle
errors
id
args
)
{
const
msg
=
bundle
.
getMessage
(
id
)
;
return
bundle
.
format
(
msg
args
errors
)
;
}
function
messageFromBundle
(
bundle
errors
id
args
)
{
const
msg
=
bundle
.
getMessage
(
id
)
;
const
formatted
=
{
value
:
bundle
.
format
(
msg
args
errors
)
attributes
:
null
}
;
if
(
msg
.
attrs
)
{
formatted
.
attributes
=
[
]
;
for
(
const
[
name
attr
]
of
Object
.
entries
(
msg
.
attrs
)
)
{
const
value
=
bundle
.
format
(
attr
args
errors
)
;
if
(
value
!
=
=
null
)
{
formatted
.
attributes
.
push
(
{
name
value
}
)
;
}
}
}
return
formatted
;
}
function
keysFromBundle
(
method
bundle
keys
translations
)
{
const
messageErrors
=
[
]
;
const
missingIds
=
new
Set
(
)
;
keys
.
forEach
(
(
{
id
args
}
i
)
=
>
{
if
(
translations
[
i
]
!
=
=
undefined
)
{
return
;
}
if
(
bundle
.
hasMessage
(
id
)
)
{
messageErrors
.
length
=
0
;
translations
[
i
]
=
method
(
bundle
messageErrors
id
args
)
;
if
(
messageErrors
.
length
>
0
)
{
const
locale
=
bundle
.
locales
[
0
]
;
const
errors
=
messageErrors
.
join
(
"
"
)
;
maybeReportErrorToGecko
(
[
fluent
]
[
resolver
]
errors
in
{
locale
}
/
{
id
}
:
{
errors
}
.
)
;
}
}
else
{
missingIds
.
add
(
id
)
;
}
}
)
;
return
missingIds
;
}
var
getLocalization
=
(
resourceIds
sync
=
false
)
=
>
{
return
new
Localization
(
resourceIds
sync
)
;
}
;
var
getLocalizationWithCustomGenerateMessages
=
(
resourceIds
generateMessages
)
=
>
{
return
new
Localization
(
resourceIds
false
generateMessages
)
;
}
;
this
.
Localization
=
Localization
;
var
EXPORTED_SYMBOLS
=
[
"
Localization
"
"
getLocalization
"
"
getLocalizationWithCustomGenerateMessages
"
]
;
