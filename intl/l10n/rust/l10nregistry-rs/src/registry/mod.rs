mod
asynchronous
;
mod
synchronous
;
use
crate
:
:
{
env
:
:
ErrorReporter
errors
:
:
L10nRegistrySetupError
fluent
:
:
FluentBundle
source
:
:
{
FileSource
ResourceId
}
}
;
use
fluent_bundle
:
:
FluentResource
;
use
fluent_fallback
:
:
generator
:
:
BundleGenerator
;
use
rustc_hash
:
:
FxHashSet
;
use
std
:
:
{
cell
:
:
{
Ref
RefCell
RefMut
}
collections
:
:
HashSet
rc
:
:
Rc
}
;
use
unic_langid
:
:
LanguageIdentifier
;
pub
use
asynchronous
:
:
GenerateBundles
;
pub
use
synchronous
:
:
GenerateBundlesSync
;
pub
type
FluentResourceSet
=
Vec
<
Rc
<
FluentResource
>
>
;
#
[
derive
(
Default
)
]
struct
Shared
<
P
B
>
{
metasources
:
RefCell
<
MetaSources
>
provider
:
P
bundle_adapter
:
Option
<
B
>
}
#
[
derive
(
Default
Clone
)
]
pub
struct
MetaSources
(
Vec
<
Vec
<
Rc
<
FileSource
>
>
>
)
;
impl
MetaSources
{
pub
fn
filesources
(
&
self
)
-
>
impl
Iterator
<
Item
=
&
Rc
<
FileSource
>
>
{
self
.
0
.
iter
(
)
.
flatten
(
)
}
pub
fn
iter_mut
(
&
mut
self
)
-
>
impl
Iterator
<
Item
=
&
mut
Vec
<
Rc
<
FileSource
>
>
>
{
self
.
0
.
iter_mut
(
)
}
pub
fn
len
(
&
self
)
-
>
usize
{
self
.
0
.
len
(
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
0
.
is_empty
(
)
}
pub
fn
clear
(
&
mut
self
)
{
self
.
0
.
clear
(
)
;
}
pub
fn
clear_empty_metasources
(
&
mut
self
)
{
self
.
0
.
retain
(
|
metasource
|
!
metasource
.
is_empty
(
)
)
;
}
pub
fn
add_filesource
(
&
mut
self
new_source
:
FileSource
)
{
if
let
Some
(
metasource
)
=
self
.
0
.
iter_mut
(
)
.
find
(
|
source
|
source
[
0
]
.
metasource
=
=
new_source
.
metasource
)
{
metasource
.
push
(
Rc
:
:
new
(
new_source
)
)
;
}
else
{
self
.
0
.
push
(
vec
!
[
Rc
:
:
new
(
new_source
)
]
)
;
}
}
pub
fn
update_filesource
(
&
mut
self
new_source
:
&
FileSource
)
-
>
bool
{
if
let
Some
(
metasource
)
=
self
.
0
.
iter_mut
(
)
.
find
(
|
source
|
source
[
0
]
.
metasource
=
=
new_source
.
metasource
)
{
if
let
Some
(
idx
)
=
metasource
.
iter
(
)
.
position
(
|
source
|
*
*
source
=
=
*
new_source
)
{
*
metasource
.
get_mut
(
idx
)
.
unwrap
(
)
=
Rc
:
:
new
(
new_source
.
clone
(
)
)
;
return
true
;
}
}
false
}
pub
fn
get
(
&
self
metasource_idx
:
usize
)
-
>
&
Vec
<
Rc
<
FileSource
>
>
{
if
let
Some
(
metasource
)
=
self
.
0
.
get
(
metasource_idx
)
{
return
&
metasource
;
}
panic
!
(
"
Metasource
index
of
{
}
is
out
of
range
of
the
list
of
{
}
meta
sources
.
"
metasource_idx
self
.
0
.
len
(
)
)
;
}
pub
fn
filesource
(
&
self
metasource_idx
:
usize
filesource_idx
:
usize
)
-
>
&
FileSource
{
let
metasource
=
self
.
get
(
metasource_idx
)
;
let
reversed_idx
=
metasource
.
len
(
)
-
1
-
filesource_idx
;
if
let
Some
(
file_source
)
=
metasource
.
get
(
reversed_idx
)
{
return
file_source
;
}
panic
!
(
"
File
source
index
of
{
}
is
out
of
range
of
the
list
of
{
}
file
sources
.
"
filesource_idx
metasource
.
len
(
)
)
;
}
#
[
cfg
(
feature
=
"
test
-
fluent
"
)
]
pub
fn
file_source_by_name
(
&
self
metasource_idx
:
usize
name
:
&
str
)
-
>
Option
<
&
FileSource
>
{
use
std
:
:
borrow
:
:
Borrow
;
self
.
get
(
metasource_idx
)
.
iter
(
)
.
find
(
|
&
source
|
source
.
name
=
=
name
)
.
map
(
|
source
|
source
.
borrow
(
)
)
}
#
[
cfg
(
feature
=
"
test
-
fluent
"
)
]
pub
fn
get_sources_for_resource
<
'
l
>
(
&
'
l
self
metasource_idx
:
usize
langid
:
&
'
l
LanguageIdentifier
resource_id
:
&
'
l
ResourceId
)
-
>
impl
Iterator
<
Item
=
&
FileSource
>
{
use
std
:
:
borrow
:
:
Borrow
;
self
.
get
(
metasource_idx
)
.
iter
(
)
.
filter
(
move
|
source
|
source
.
has_file
(
langid
resource_id
)
!
=
Some
(
false
)
)
.
map
(
|
source
|
source
.
borrow
(
)
)
}
}
pub
trait
BundleAdapter
{
fn
adapt_bundle
(
&
self
bundle
:
&
mut
FluentBundle
)
;
}
#
[
derive
(
Clone
)
]
pub
struct
L10nRegistry
<
P
B
>
{
shared
:
Rc
<
Shared
<
P
B
>
>
}
impl
<
P
B
>
L10nRegistry
<
P
B
>
{
pub
fn
with_provider
(
provider
:
P
)
-
>
Self
{
Self
{
shared
:
Rc
:
:
new
(
Shared
{
metasources
:
Default
:
:
default
(
)
provider
bundle_adapter
:
None
}
)
}
}
pub
fn
set_bundle_adapter
(
&
mut
self
bundle_adapter
:
B
)
-
>
Result
<
(
)
L10nRegistrySetupError
>
where
B
:
BundleAdapter
{
let
shared
=
Rc
:
:
get_mut
(
&
mut
self
.
shared
)
.
ok_or
(
L10nRegistrySetupError
:
:
RegistryLocked
)
?
;
shared
.
bundle_adapter
=
Some
(
bundle_adapter
)
;
Ok
(
(
)
)
}
pub
fn
try_borrow_metasources
(
&
self
)
-
>
Result
<
Ref
<
MetaSources
>
L10nRegistrySetupError
>
{
self
.
shared
.
metasources
.
try_borrow
(
)
.
map_err
(
|
_
|
L10nRegistrySetupError
:
:
RegistryLocked
)
}
pub
fn
try_borrow_metasources_mut
(
&
self
)
-
>
Result
<
RefMut
<
MetaSources
>
L10nRegistrySetupError
>
{
self
.
shared
.
metasources
.
try_borrow_mut
(
)
.
map_err
(
|
_
|
L10nRegistrySetupError
:
:
RegistryLocked
)
}
pub
fn
register_sources
(
&
self
new_sources
:
Vec
<
FileSource
>
)
-
>
Result
<
(
)
L10nRegistrySetupError
>
{
for
new_source
in
new_sources
{
self
.
try_borrow_metasources_mut
(
)
?
.
add_filesource
(
new_source
)
;
}
Ok
(
(
)
)
}
pub
fn
update_sources
(
&
self
new_sources
:
Vec
<
FileSource
>
)
-
>
Result
<
(
)
L10nRegistrySetupError
>
{
for
new_source
in
new_sources
{
if
!
self
.
try_borrow_metasources_mut
(
)
?
.
update_filesource
(
&
new_source
)
{
return
Err
(
L10nRegistrySetupError
:
:
MissingSource
{
name
:
new_source
.
name
}
)
;
}
}
Ok
(
(
)
)
}
pub
fn
remove_sources
<
S
>
(
&
self
del_sources
:
Vec
<
S
>
)
-
>
Result
<
(
)
L10nRegistrySetupError
>
where
S
:
ToString
{
let
del_sources
:
Vec
<
String
>
=
del_sources
.
into_iter
(
)
.
map
(
|
s
|
s
.
to_string
(
)
)
.
collect
(
)
;
for
metasource
in
self
.
try_borrow_metasources_mut
(
)
?
.
iter_mut
(
)
{
metasource
.
retain
(
|
source
|
!
del_sources
.
contains
(
&
source
.
name
)
)
;
}
self
.
try_borrow_metasources_mut
(
)
?
.
clear_empty_metasources
(
)
;
Ok
(
(
)
)
}
pub
fn
clear_sources
(
&
self
)
-
>
Result
<
(
)
L10nRegistrySetupError
>
{
self
.
try_borrow_metasources_mut
(
)
?
.
clear
(
)
;
Ok
(
(
)
)
}
pub
fn
get_source_names
(
&
self
)
-
>
Result
<
Vec
<
String
>
L10nRegistrySetupError
>
{
Ok
(
self
.
try_borrow_metasources
(
)
?
.
filesources
(
)
.
map
(
|
s
|
s
.
name
.
clone
(
)
)
.
collect
(
)
)
}
pub
fn
has_source
(
&
self
name
:
&
str
)
-
>
Result
<
bool
L10nRegistrySetupError
>
{
Ok
(
self
.
try_borrow_metasources
(
)
?
.
filesources
(
)
.
any
(
|
source
|
source
.
name
=
=
name
)
)
}
pub
fn
file_source_by_name
(
&
self
name
:
&
str
)
-
>
Result
<
Option
<
FileSource
>
L10nRegistrySetupError
>
{
Ok
(
self
.
try_borrow_metasources
(
)
?
.
filesources
(
)
.
find
(
|
source
|
source
.
name
=
=
name
)
.
map
(
|
source
|
(
*
*
source
)
.
clone
(
)
)
)
}
pub
fn
get_available_locales
(
&
self
)
-
>
Result
<
Vec
<
LanguageIdentifier
>
L10nRegistrySetupError
>
{
let
mut
result
=
HashSet
:
:
new
(
)
;
let
metasources
=
self
.
try_borrow_metasources
(
)
?
;
for
source
in
metasources
.
filesources
(
)
{
for
locale
in
source
.
locales
(
)
{
result
.
insert
(
locale
)
;
}
}
Ok
(
result
.
into_iter
(
)
.
map
(
|
l
|
l
.
to_owned
(
)
)
.
collect
(
)
)
}
}
impl
<
P
B
>
BundleGenerator
for
L10nRegistry
<
P
B
>
where
P
:
ErrorReporter
+
Clone
B
:
BundleAdapter
+
Clone
{
type
Resource
=
Rc
<
FluentResource
>
;
type
Iter
=
GenerateBundlesSync
<
P
B
>
;
type
Stream
=
GenerateBundles
<
P
B
>
;
type
LocalesIter
=
std
:
:
vec
:
:
IntoIter
<
LanguageIdentifier
>
;
fn
bundles_iter
(
&
self
locales
:
Self
:
:
LocalesIter
resource_ids
:
FxHashSet
<
ResourceId
>
)
-
>
Self
:
:
Iter
{
let
resource_ids
=
resource_ids
.
into_iter
(
)
.
collect
(
)
;
self
.
generate_bundles_sync
(
locales
resource_ids
)
}
fn
bundles_stream
(
&
self
locales
:
Self
:
:
LocalesIter
resource_ids
:
FxHashSet
<
ResourceId
>
)
-
>
Self
:
:
Stream
{
let
resource_ids
=
resource_ids
.
into_iter
(
)
.
collect
(
)
;
self
.
generate_bundles
(
locales
resource_ids
)
.
expect
(
"
Unable
to
get
the
MetaSources
.
"
)
}
}
