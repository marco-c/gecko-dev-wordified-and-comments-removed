class
FluentType
{
constructor
(
value
)
{
this
.
value
=
value
;
}
valueOf
(
)
{
return
this
.
value
;
}
toString
(
scope
)
{
throw
new
Error
(
"
Subclasses
of
FluentType
must
implement
toString
.
"
)
;
}
}
class
FluentNone
extends
FluentType
{
constructor
(
value
=
"
?
?
?
"
)
{
super
(
value
)
;
}
toString
(
)
{
return
{
{
this
.
value
}
}
;
}
}
class
FluentNumber
extends
FluentType
{
constructor
(
value
opts
)
{
super
(
value
)
;
this
.
opts
=
opts
;
}
toString
(
scope
)
{
try
{
const
nf
=
scope
.
memoizeIntlObject
(
Intl
.
NumberFormat
this
.
opts
)
;
return
nf
.
format
(
this
.
value
)
;
}
catch
(
err
)
{
scope
.
reportError
(
err
)
;
return
this
.
value
.
toString
(
10
)
;
}
}
}
class
FluentDateTime
extends
FluentType
{
constructor
(
value
opts
)
{
super
(
value
)
;
this
.
opts
=
opts
;
}
toString
(
scope
)
{
try
{
const
dtf
=
scope
.
memoizeIntlObject
(
Intl
.
DateTimeFormat
this
.
opts
)
;
return
dtf
.
format
(
this
.
value
)
;
}
catch
(
err
)
{
scope
.
reportError
(
err
)
;
return
(
new
Date
(
this
.
value
)
)
.
toISOString
(
)
;
}
}
}
function
merge
(
argopts
opts
)
{
return
Object
.
assign
(
{
}
argopts
values
(
opts
)
)
;
}
function
values
(
opts
)
{
const
unwrapped
=
{
}
;
for
(
const
[
name
opt
]
of
Object
.
entries
(
opts
)
)
{
unwrapped
[
name
]
=
opt
.
valueOf
(
)
;
}
return
unwrapped
;
}
function
NUMBER
(
[
arg
]
opts
)
{
if
(
arg
instanceof
FluentNone
)
{
return
new
FluentNone
(
NUMBER
(
{
arg
.
valueOf
(
)
}
)
)
;
}
let
value
=
Number
(
arg
.
valueOf
(
)
)
;
if
(
Number
.
isNaN
(
value
)
)
{
throw
new
TypeError
(
"
Invalid
argument
to
NUMBER
"
)
;
}
return
new
FluentNumber
(
value
merge
(
arg
.
opts
opts
)
)
;
}
function
DATETIME
(
[
arg
]
opts
)
{
if
(
arg
instanceof
FluentNone
)
{
return
new
FluentNone
(
DATETIME
(
{
arg
.
valueOf
(
)
}
)
)
;
}
let
value
=
Number
(
arg
.
valueOf
(
)
)
;
if
(
Number
.
isNaN
(
value
)
)
{
throw
new
TypeError
(
"
Invalid
argument
to
DATETIME
"
)
;
}
return
new
FluentDateTime
(
value
merge
(
arg
.
opts
opts
)
)
;
}
const
builtins
=
Object
.
freeze
(
{
__proto__
:
null
NUMBER
:
NUMBER
DATETIME
:
DATETIME
}
)
;
const
MAX_PLACEABLES
=
100
;
const
FSI
=
"
\
u2068
"
;
const
PDI
=
"
\
u2069
"
;
function
match
(
scope
selector
key
)
{
if
(
key
=
=
=
selector
)
{
return
true
;
}
if
(
key
instanceof
FluentNumber
&
&
selector
instanceof
FluentNumber
&
&
key
.
value
=
=
=
selector
.
value
)
{
return
true
;
}
if
(
selector
instanceof
FluentNumber
&
&
typeof
key
=
=
=
"
string
"
)
{
let
category
=
scope
.
memoizeIntlObject
(
Intl
.
PluralRules
selector
.
opts
)
.
select
(
selector
.
value
)
;
if
(
key
=
=
=
category
)
{
return
true
;
}
}
return
false
;
}
function
getDefault
(
scope
variants
star
)
{
if
(
variants
[
star
]
)
{
return
resolvePattern
(
scope
variants
[
star
]
.
value
)
;
}
scope
.
reportError
(
new
RangeError
(
"
No
default
"
)
)
;
return
new
FluentNone
(
)
;
}
function
getArguments
(
scope
args
)
{
const
positional
=
[
]
;
const
named
=
Object
.
create
(
null
)
;
for
(
const
arg
of
args
)
{
if
(
arg
.
type
=
=
=
"
narg
"
)
{
named
[
arg
.
name
]
=
resolveExpression
(
scope
arg
.
value
)
;
}
else
{
positional
.
push
(
resolveExpression
(
scope
arg
)
)
;
}
}
return
{
positional
named
}
;
}
function
resolveExpression
(
scope
expr
)
{
switch
(
expr
.
type
)
{
case
"
str
"
:
return
expr
.
value
;
case
"
num
"
:
return
new
FluentNumber
(
expr
.
value
{
minimumFractionDigits
:
expr
.
precision
}
)
;
case
"
var
"
:
return
VariableReference
(
scope
expr
)
;
case
"
mesg
"
:
return
MessageReference
(
scope
expr
)
;
case
"
term
"
:
return
TermReference
(
scope
expr
)
;
case
"
func
"
:
return
FunctionReference
(
scope
expr
)
;
case
"
select
"
:
return
SelectExpression
(
scope
expr
)
;
default
:
return
new
FluentNone
(
)
;
}
}
function
VariableReference
(
scope
{
name
}
)
{
let
arg
;
if
(
scope
.
params
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
scope
.
params
name
)
)
{
arg
=
scope
.
params
[
name
]
;
}
else
{
return
new
FluentNone
(
{
name
}
)
;
}
}
else
if
(
scope
.
args
&
&
Object
.
prototype
.
hasOwnProperty
.
call
(
scope
.
args
name
)
)
{
arg
=
scope
.
args
[
name
]
;
}
else
{
scope
.
reportError
(
new
ReferenceError
(
Unknown
variable
:
{
name
}
)
)
;
return
new
FluentNone
(
{
name
}
)
;
}
if
(
arg
instanceof
FluentType
)
{
return
arg
;
}
switch
(
typeof
arg
)
{
case
"
string
"
:
return
arg
;
case
"
number
"
:
return
new
FluentNumber
(
arg
)
;
case
"
object
"
:
if
(
arg
instanceof
Date
)
{
return
new
FluentDateTime
(
arg
.
getTime
(
)
)
;
}
default
:
scope
.
reportError
(
new
TypeError
(
Variable
type
not
supported
:
{
name
}
{
typeof
arg
}
)
)
;
return
new
FluentNone
(
{
name
}
)
;
}
}
function
MessageReference
(
scope
{
name
attr
}
)
{
const
message
=
scope
.
bundle
.
_messages
.
get
(
name
)
;
if
(
!
message
)
{
scope
.
reportError
(
new
ReferenceError
(
Unknown
message
:
{
name
}
)
)
;
return
new
FluentNone
(
name
)
;
}
if
(
attr
)
{
const
attribute
=
message
.
attributes
[
attr
]
;
if
(
attribute
)
{
return
resolvePattern
(
scope
attribute
)
;
}
scope
.
reportError
(
new
ReferenceError
(
Unknown
attribute
:
{
attr
}
)
)
;
return
new
FluentNone
(
{
name
}
.
{
attr
}
)
;
}
if
(
message
.
value
)
{
return
resolvePattern
(
scope
message
.
value
)
;
}
scope
.
reportError
(
new
ReferenceError
(
No
value
:
{
name
}
)
)
;
return
new
FluentNone
(
name
)
;
}
function
TermReference
(
scope
{
name
attr
args
}
)
{
const
id
=
-
{
name
}
;
const
term
=
scope
.
bundle
.
_terms
.
get
(
id
)
;
if
(
!
term
)
{
scope
.
reportError
(
new
ReferenceError
(
Unknown
term
:
{
id
}
)
)
;
return
new
FluentNone
(
id
)
;
}
if
(
attr
)
{
const
attribute
=
term
.
attributes
[
attr
]
;
if
(
attribute
)
{
scope
.
params
=
getArguments
(
scope
args
)
.
named
;
const
resolved
=
resolvePattern
(
scope
attribute
)
;
scope
.
params
=
null
;
return
resolved
;
}
scope
.
reportError
(
new
ReferenceError
(
Unknown
attribute
:
{
attr
}
)
)
;
return
new
FluentNone
(
{
id
}
.
{
attr
}
)
;
}
scope
.
params
=
getArguments
(
scope
args
)
.
named
;
const
resolved
=
resolvePattern
(
scope
term
.
value
)
;
scope
.
params
=
null
;
return
resolved
;
}
function
FunctionReference
(
scope
{
name
args
}
)
{
const
func
=
scope
.
bundle
.
_functions
[
name
]
|
|
builtins
[
name
]
;
if
(
!
func
)
{
scope
.
reportError
(
new
ReferenceError
(
Unknown
function
:
{
name
}
(
)
)
)
;
return
new
FluentNone
(
{
name
}
(
)
)
;
}
if
(
typeof
func
!
=
=
"
function
"
)
{
scope
.
reportError
(
new
TypeError
(
Function
{
name
}
(
)
is
not
callable
)
)
;
return
new
FluentNone
(
{
name
}
(
)
)
;
}
try
{
let
resolved
=
getArguments
(
scope
args
)
;
return
func
(
resolved
.
positional
resolved
.
named
)
;
}
catch
(
err
)
{
scope
.
reportError
(
err
)
;
return
new
FluentNone
(
{
name
}
(
)
)
;
}
}
function
SelectExpression
(
scope
{
selector
variants
star
}
)
{
let
sel
=
resolveExpression
(
scope
selector
)
;
if
(
sel
instanceof
FluentNone
)
{
return
getDefault
(
scope
variants
star
)
;
}
for
(
const
variant
of
variants
)
{
const
key
=
resolveExpression
(
scope
variant
.
key
)
;
if
(
match
(
scope
sel
key
)
)
{
return
resolvePattern
(
scope
variant
.
value
)
;
}
}
return
getDefault
(
scope
variants
star
)
;
}
function
resolveComplexPattern
(
scope
ptn
)
{
if
(
scope
.
dirty
.
has
(
ptn
)
)
{
scope
.
reportError
(
new
RangeError
(
"
Cyclic
reference
"
)
)
;
return
new
FluentNone
(
)
;
}
scope
.
dirty
.
add
(
ptn
)
;
const
result
=
[
]
;
const
useIsolating
=
scope
.
bundle
.
_useIsolating
&
&
ptn
.
length
>
1
;
for
(
const
elem
of
ptn
)
{
if
(
typeof
elem
=
=
=
"
string
"
)
{
result
.
push
(
scope
.
bundle
.
_transform
(
elem
)
)
;
continue
;
}
scope
.
placeables
+
+
;
if
(
scope
.
placeables
>
MAX_PLACEABLES
)
{
scope
.
dirty
.
delete
(
ptn
)
;
throw
new
RangeError
(
Too
many
placeables
expanded
:
{
scope
.
placeables
}
+
max
allowed
is
{
MAX_PLACEABLES
}
)
;
}
if
(
useIsolating
)
{
result
.
push
(
FSI
)
;
}
result
.
push
(
resolveExpression
(
scope
elem
)
.
toString
(
scope
)
)
;
if
(
useIsolating
)
{
result
.
push
(
PDI
)
;
}
}
scope
.
dirty
.
delete
(
ptn
)
;
return
result
.
join
(
"
"
)
;
}
function
resolvePattern
(
scope
node
)
{
if
(
typeof
node
=
=
=
"
string
"
)
{
return
scope
.
bundle
.
_transform
(
node
)
;
}
return
resolveComplexPattern
(
scope
node
)
;
}
class
Scope
{
constructor
(
bundle
errors
args
)
{
this
.
bundle
=
bundle
;
this
.
errors
=
errors
;
this
.
args
=
args
;
this
.
dirty
=
new
WeakSet
(
)
;
this
.
params
=
null
;
this
.
placeables
=
0
;
}
reportError
(
error
)
{
if
(
!
this
.
errors
)
{
throw
error
;
}
this
.
errors
.
push
(
error
)
;
}
memoizeIntlObject
(
ctor
opts
)
{
let
cache
=
this
.
bundle
.
_intls
.
get
(
ctor
)
;
if
(
!
cache
)
{
cache
=
{
}
;
this
.
bundle
.
_intls
.
set
(
ctor
cache
)
;
}
let
id
=
JSON
.
stringify
(
opts
)
;
if
(
!
cache
[
id
]
)
{
cache
[
id
]
=
new
ctor
(
this
.
bundle
.
locales
opts
)
;
}
return
cache
[
id
]
;
}
}
class
FluentBundle
{
constructor
(
locales
{
functions
=
{
}
useIsolating
=
true
transform
=
v
=
>
v
}
=
{
}
)
{
this
.
locales
=
Array
.
isArray
(
locales
)
?
locales
:
[
locales
]
;
this
.
_terms
=
new
Map
(
)
;
this
.
_messages
=
new
Map
(
)
;
this
.
_functions
=
functions
;
this
.
_useIsolating
=
useIsolating
;
this
.
_transform
=
transform
;
this
.
_intls
=
new
WeakMap
(
)
;
}
hasMessage
(
id
)
{
return
this
.
_messages
.
has
(
id
)
;
}
getMessage
(
id
)
{
return
this
.
_messages
.
get
(
id
)
;
}
addResource
(
res
{
allowOverrides
=
false
}
=
{
}
)
{
const
errors
=
[
]
;
for
(
let
i
=
0
;
i
<
res
.
body
.
length
;
i
+
+
)
{
let
entry
=
res
.
body
[
i
]
;
if
(
entry
.
id
.
startsWith
(
"
-
"
)
)
{
if
(
allowOverrides
=
=
=
false
&
&
this
.
_terms
.
has
(
entry
.
id
)
)
{
errors
.
push
(
Attempt
to
override
an
existing
term
:
"
{
entry
.
id
}
"
)
;
continue
;
}
this
.
_terms
.
set
(
entry
.
id
entry
)
;
}
else
{
if
(
allowOverrides
=
=
=
false
&
&
this
.
_messages
.
has
(
entry
.
id
)
)
{
errors
.
push
(
Attempt
to
override
an
existing
message
:
"
{
entry
.
id
}
"
)
;
continue
;
}
this
.
_messages
.
set
(
entry
.
id
entry
)
;
}
}
return
errors
;
}
formatPattern
(
pattern
args
errors
)
{
if
(
typeof
pattern
=
=
=
"
string
"
)
{
return
this
.
_transform
(
pattern
)
;
}
let
scope
=
new
Scope
(
this
errors
args
)
;
try
{
let
value
=
resolveComplexPattern
(
scope
pattern
)
;
return
value
.
toString
(
scope
)
;
}
catch
(
err
)
{
if
(
scope
.
errors
)
{
scope
.
errors
.
push
(
err
)
;
return
new
FluentNone
(
)
.
toString
(
scope
)
;
}
throw
err
;
}
}
}
class
FluentError
extends
Error
{
}
const
RE_MESSAGE_START
=
/
^
(
-
?
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
*
=
*
/
mg
;
const
RE_ATTRIBUTE_START
=
/
\
.
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
*
=
*
/
y
;
const
RE_VARIANT_START
=
/
\
*
?
\
[
/
y
;
const
RE_NUMBER_LITERAL
=
/
(
-
?
[
0
-
9
]
+
(
?
:
\
.
(
[
0
-
9
]
+
)
)
?
)
/
y
;
const
RE_IDENTIFIER
=
/
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
/
y
;
const
RE_REFERENCE
=
/
(
[
-
]
)
?
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
(
?
:
\
.
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
)
?
/
y
;
const
RE_FUNCTION_NAME
=
/
^
[
A
-
Z
]
[
A
-
Z0
-
9_
-
]
*
/
;
const
RE_TEXT_RUN
=
/
(
[
^
{
}
\
n
\
r
]
+
)
/
y
;
const
RE_STRING_RUN
=
/
(
[
^
\
\
"
\
n
\
r
]
*
)
/
y
;
const
RE_STRING_ESCAPE
=
/
\
\
(
[
\
\
"
]
)
/
y
;
const
RE_UNICODE_ESCAPE
=
/
\
\
u
(
[
a
-
fA
-
F0
-
9
]
{
4
}
)
|
\
\
U
(
[
a
-
fA
-
F0
-
9
]
{
6
}
)
/
y
;
const
RE_LEADING_NEWLINES
=
/
^
\
n
+
/
;
const
RE_TRAILING_SPACES
=
/
+
/
;
const
RE_BLANK_LINES
=
/
*
\
r
?
\
n
/
g
;
const
RE_INDENT
=
/
(
*
)
/
;
const
TOKEN_BRACE_OPEN
=
/
{
\
s
*
/
y
;
const
TOKEN_BRACE_CLOSE
=
/
\
s
*
}
/
y
;
const
TOKEN_BRACKET_OPEN
=
/
\
[
\
s
*
/
y
;
const
TOKEN_BRACKET_CLOSE
=
/
\
s
*
]
*
/
y
;
const
TOKEN_PAREN_OPEN
=
/
\
s
*
\
(
\
s
*
/
y
;
const
TOKEN_ARROW
=
/
\
s
*
-
>
\
s
*
/
y
;
const
TOKEN_COLON
=
/
\
s
*
:
\
s
*
/
y
;
const
TOKEN_COMMA
=
/
\
s
*
?
\
s
*
/
y
;
const
TOKEN_BLANK
=
/
\
s
+
/
y
;
class
FluentResource
{
constructor
(
source
)
{
this
.
body
=
this
.
_parse
(
source
)
;
}
_parse
(
source
)
{
RE_MESSAGE_START
.
lastIndex
=
0
;
let
resource
=
[
]
;
let
cursor
=
0
;
while
(
true
)
{
let
next
=
RE_MESSAGE_START
.
exec
(
source
)
;
if
(
next
=
=
=
null
)
{
break
;
}
cursor
=
RE_MESSAGE_START
.
lastIndex
;
try
{
resource
.
push
(
parseMessage
(
next
[
1
]
)
)
;
}
catch
(
err
)
{
if
(
err
instanceof
FluentError
)
{
continue
;
}
throw
err
;
}
}
return
resource
;
function
test
(
re
)
{
re
.
lastIndex
=
cursor
;
return
re
.
test
(
source
)
;
}
function
consumeChar
(
char
errorClass
)
{
if
(
source
[
cursor
]
=
=
=
char
)
{
cursor
+
+
;
return
true
;
}
if
(
errorClass
)
{
throw
new
errorClass
(
Expected
{
char
}
)
;
}
return
false
;
}
function
consumeToken
(
re
errorClass
)
{
if
(
test
(
re
)
)
{
cursor
=
re
.
lastIndex
;
return
true
;
}
if
(
errorClass
)
{
throw
new
errorClass
(
Expected
{
re
.
toString
(
)
}
)
;
}
return
false
;
}
function
match
(
re
)
{
re
.
lastIndex
=
cursor
;
let
result
=
re
.
exec
(
source
)
;
if
(
result
=
=
=
null
)
{
throw
new
FluentError
(
Expected
{
re
.
toString
(
)
}
)
;
}
cursor
=
re
.
lastIndex
;
return
result
;
}
function
match1
(
re
)
{
return
match
(
re
)
[
1
]
;
}
function
parseMessage
(
id
)
{
let
value
=
parsePattern
(
)
;
let
attributes
=
parseAttributes
(
)
;
if
(
value
=
=
=
null
&
&
Object
.
keys
(
attributes
)
.
length
=
=
=
0
)
{
throw
new
FluentError
(
"
Expected
message
value
or
attributes
"
)
;
}
return
{
id
value
attributes
}
;
}
function
parseAttributes
(
)
{
let
attrs
=
Object
.
create
(
null
)
;
while
(
test
(
RE_ATTRIBUTE_START
)
)
{
let
name
=
match1
(
RE_ATTRIBUTE_START
)
;
let
value
=
parsePattern
(
)
;
if
(
value
=
=
=
null
)
{
throw
new
FluentError
(
"
Expected
attribute
value
"
)
;
}
attrs
[
name
]
=
value
;
}
return
attrs
;
}
function
parsePattern
(
)
{
if
(
test
(
RE_TEXT_RUN
)
)
{
var
first
=
match1
(
RE_TEXT_RUN
)
;
}
if
(
source
[
cursor
]
=
=
=
"
{
"
|
|
source
[
cursor
]
=
=
=
"
}
"
)
{
return
parsePatternElements
(
first
?
[
first
]
:
[
]
Infinity
)
;
}
let
indent
=
parseIndent
(
)
;
if
(
indent
)
{
if
(
first
)
{
return
parsePatternElements
(
[
first
indent
]
indent
.
length
)
;
}
indent
.
value
=
trim
(
indent
.
value
RE_LEADING_NEWLINES
)
;
return
parsePatternElements
(
[
indent
]
indent
.
length
)
;
}
if
(
first
)
{
return
trim
(
first
RE_TRAILING_SPACES
)
;
}
return
null
;
}
function
parsePatternElements
(
elements
=
[
]
commonIndent
)
{
while
(
true
)
{
if
(
test
(
RE_TEXT_RUN
)
)
{
elements
.
push
(
match1
(
RE_TEXT_RUN
)
)
;
continue
;
}
if
(
source
[
cursor
]
=
=
=
"
{
"
)
{
elements
.
push
(
parsePlaceable
(
)
)
;
continue
;
}
if
(
source
[
cursor
]
=
=
=
"
}
"
)
{
throw
new
FluentError
(
"
Unbalanced
closing
brace
"
)
;
}
let
indent
=
parseIndent
(
)
;
if
(
indent
)
{
elements
.
push
(
indent
)
;
commonIndent
=
Math
.
min
(
commonIndent
indent
.
length
)
;
continue
;
}
break
;
}
let
lastIndex
=
elements
.
length
-
1
;
if
(
typeof
elements
[
lastIndex
]
=
=
=
"
string
"
)
{
elements
[
lastIndex
]
=
trim
(
elements
[
lastIndex
]
RE_TRAILING_SPACES
)
;
}
let
baked
=
[
]
;
for
(
let
element
of
elements
)
{
if
(
element
.
type
=
=
=
"
indent
"
)
{
element
=
element
.
value
.
slice
(
0
element
.
value
.
length
-
commonIndent
)
;
}
if
(
element
)
{
baked
.
push
(
element
)
;
}
}
return
baked
;
}
function
parsePlaceable
(
)
{
consumeToken
(
TOKEN_BRACE_OPEN
FluentError
)
;
let
selector
=
parseInlineExpression
(
)
;
if
(
consumeToken
(
TOKEN_BRACE_CLOSE
)
)
{
return
selector
;
}
if
(
consumeToken
(
TOKEN_ARROW
)
)
{
let
variants
=
parseVariants
(
)
;
consumeToken
(
TOKEN_BRACE_CLOSE
FluentError
)
;
return
{
type
:
"
select
"
selector
.
.
.
variants
}
;
}
throw
new
FluentError
(
"
Unclosed
placeable
"
)
;
}
function
parseInlineExpression
(
)
{
if
(
source
[
cursor
]
=
=
=
"
{
"
)
{
return
parsePlaceable
(
)
;
}
if
(
test
(
RE_REFERENCE
)
)
{
let
[
sigil
name
attr
=
null
]
=
match
(
RE_REFERENCE
)
;
if
(
sigil
=
=
=
"
"
)
{
return
{
type
:
"
var
"
name
}
;
}
if
(
consumeToken
(
TOKEN_PAREN_OPEN
)
)
{
let
args
=
parseArguments
(
)
;
if
(
sigil
=
=
=
"
-
"
)
{
return
{
type
:
"
term
"
name
attr
args
}
;
}
if
(
RE_FUNCTION_NAME
.
test
(
name
)
)
{
return
{
type
:
"
func
"
name
args
}
;
}
throw
new
FluentError
(
"
Function
names
must
be
all
upper
-
case
"
)
;
}
if
(
sigil
=
=
=
"
-
"
)
{
return
{
type
:
"
term
"
name
attr
args
:
[
]
}
;
}
return
{
type
:
"
mesg
"
name
attr
}
;
}
return
parseLiteral
(
)
;
}
function
parseArguments
(
)
{
let
args
=
[
]
;
while
(
true
)
{
switch
(
source
[
cursor
]
)
{
case
"
)
"
:
cursor
+
+
;
return
args
;
case
undefined
:
throw
new
FluentError
(
"
Unclosed
argument
list
"
)
;
}
args
.
push
(
parseArgument
(
)
)
;
consumeToken
(
TOKEN_COMMA
)
;
}
}
function
parseArgument
(
)
{
let
expr
=
parseInlineExpression
(
)
;
if
(
expr
.
type
!
=
=
"
mesg
"
)
{
return
expr
;
}
if
(
consumeToken
(
TOKEN_COLON
)
)
{
return
{
type
:
"
narg
"
name
:
expr
.
name
value
:
parseLiteral
(
)
}
;
}
return
expr
;
}
function
parseVariants
(
)
{
let
variants
=
[
]
;
let
count
=
0
;
let
star
;
while
(
test
(
RE_VARIANT_START
)
)
{
if
(
consumeChar
(
"
*
"
)
)
{
star
=
count
;
}
let
key
=
parseVariantKey
(
)
;
let
value
=
parsePattern
(
)
;
if
(
value
=
=
=
null
)
{
throw
new
FluentError
(
"
Expected
variant
value
"
)
;
}
variants
[
count
+
+
]
=
{
key
value
}
;
}
if
(
count
=
=
=
0
)
{
return
null
;
}
if
(
star
=
=
=
undefined
)
{
throw
new
FluentError
(
"
Expected
default
variant
"
)
;
}
return
{
variants
star
}
;
}
function
parseVariantKey
(
)
{
consumeToken
(
TOKEN_BRACKET_OPEN
FluentError
)
;
let
key
=
test
(
RE_NUMBER_LITERAL
)
?
parseNumberLiteral
(
)
:
{
type
:
"
str
"
value
:
match1
(
RE_IDENTIFIER
)
}
;
consumeToken
(
TOKEN_BRACKET_CLOSE
FluentError
)
;
return
key
;
}
function
parseLiteral
(
)
{
if
(
test
(
RE_NUMBER_LITERAL
)
)
{
return
parseNumberLiteral
(
)
;
}
if
(
source
[
cursor
]
=
=
=
"
\
"
"
)
{
return
parseStringLiteral
(
)
;
}
throw
new
FluentError
(
"
Invalid
expression
"
)
;
}
function
parseNumberLiteral
(
)
{
let
[
value
fraction
=
"
"
]
=
match
(
RE_NUMBER_LITERAL
)
;
let
precision
=
fraction
.
length
;
return
{
type
:
"
num
"
value
:
parseFloat
(
value
)
precision
}
;
}
function
parseStringLiteral
(
)
{
consumeChar
(
"
\
"
"
FluentError
)
;
let
value
=
"
"
;
while
(
true
)
{
value
+
=
match1
(
RE_STRING_RUN
)
;
if
(
source
[
cursor
]
=
=
=
"
\
\
"
)
{
value
+
=
parseEscapeSequence
(
)
;
continue
;
}
if
(
consumeChar
(
"
\
"
"
)
)
{
return
{
type
:
"
str
"
value
}
;
}
throw
new
FluentError
(
"
Unclosed
string
literal
"
)
;
}
}
function
parseEscapeSequence
(
)
{
if
(
test
(
RE_STRING_ESCAPE
)
)
{
return
match1
(
RE_STRING_ESCAPE
)
;
}
if
(
test
(
RE_UNICODE_ESCAPE
)
)
{
let
[
codepoint4
codepoint6
]
=
match
(
RE_UNICODE_ESCAPE
)
;
let
codepoint
=
parseInt
(
codepoint4
|
|
codepoint6
16
)
;
return
codepoint
<
=
0xD7FF
|
|
0xE000
<
=
codepoint
?
String
.
fromCodePoint
(
codepoint
)
:
"
"
;
}
throw
new
FluentError
(
"
Unknown
escape
sequence
"
)
;
}
function
parseIndent
(
)
{
let
start
=
cursor
;
consumeToken
(
TOKEN_BLANK
)
;
switch
(
source
[
cursor
]
)
{
case
"
.
"
:
case
"
[
"
:
case
"
*
"
:
case
"
}
"
:
case
undefined
:
return
false
;
case
"
{
"
:
return
makeIndent
(
source
.
slice
(
start
cursor
)
)
;
}
if
(
source
[
cursor
-
1
]
=
=
=
"
"
)
{
return
makeIndent
(
source
.
slice
(
start
cursor
)
)
;
}
return
false
;
}
function
trim
(
text
re
)
{
return
text
.
replace
(
re
"
"
)
;
}
function
makeIndent
(
blank
)
{
let
value
=
blank
.
replace
(
RE_BLANK_LINES
"
\
n
"
)
;
let
length
=
RE_INDENT
.
exec
(
blank
)
[
1
]
.
length
;
return
{
type
:
"
indent
"
value
length
}
;
}
}
}
this
.
EXPORTED_SYMBOLS
=
[
.
.
.
Object
.
keys
(
{
FluentBundle
FluentResource
FluentError
FluentType
FluentNumber
FluentDateTime
}
)
]
;
