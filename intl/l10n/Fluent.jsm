class
FluentType
{
constructor
(
value
opts
)
{
this
.
value
=
value
;
this
.
opts
=
opts
;
}
valueOf
(
)
{
return
this
.
value
;
}
toString
(
)
{
throw
new
Error
(
"
Subclasses
of
FluentType
must
implement
toString
.
"
)
;
}
}
class
FluentNone
extends
FluentType
{
toString
(
)
{
return
this
.
value
|
|
"
?
?
?
"
;
}
}
class
FluentNumber
extends
FluentType
{
constructor
(
value
opts
)
{
super
(
parseFloat
(
value
)
opts
)
;
}
toString
(
bundle
)
{
try
{
const
nf
=
bundle
.
_memoizeIntlObject
(
Intl
.
NumberFormat
this
.
opts
)
;
return
nf
.
format
(
this
.
value
)
;
}
catch
(
e
)
{
return
this
.
value
;
}
}
}
class
FluentDateTime
extends
FluentType
{
constructor
(
value
opts
)
{
super
(
new
Date
(
value
)
opts
)
;
}
toString
(
bundle
)
{
try
{
const
dtf
=
bundle
.
_memoizeIntlObject
(
Intl
.
DateTimeFormat
this
.
opts
)
;
return
dtf
.
format
(
this
.
value
)
;
}
catch
(
e
)
{
return
this
.
value
;
}
}
}
const
builtins
=
{
"
NUMBER
"
:
(
[
arg
]
opts
)
=
>
new
FluentNumber
(
arg
.
valueOf
(
)
merge
(
arg
.
opts
opts
)
)
"
DATETIME
"
:
(
[
arg
]
opts
)
=
>
new
FluentDateTime
(
arg
.
valueOf
(
)
merge
(
arg
.
opts
opts
)
)
}
;
function
merge
(
argopts
opts
)
{
return
Object
.
assign
(
{
}
argopts
values
(
opts
)
)
;
}
function
values
(
opts
)
{
const
unwrapped
=
{
}
;
for
(
const
[
name
opt
]
of
Object
.
entries
(
opts
)
)
{
unwrapped
[
name
]
=
opt
.
valueOf
(
)
;
}
return
unwrapped
;
}
const
MAX_PLACEABLE_LENGTH
=
2500
;
const
FSI
=
"
\
u2068
"
;
const
PDI
=
"
\
u2069
"
;
function
match
(
bundle
selector
key
)
{
if
(
key
=
=
=
selector
)
{
return
true
;
}
if
(
key
instanceof
FluentNumber
&
&
selector
instanceof
FluentNumber
&
&
key
.
value
=
=
=
selector
.
value
)
{
return
true
;
}
if
(
selector
instanceof
FluentNumber
&
&
typeof
key
=
=
=
"
string
"
)
{
let
category
=
bundle
.
_memoizeIntlObject
(
Intl
.
PluralRules
selector
.
opts
)
.
select
(
selector
.
value
)
;
if
(
key
=
=
=
category
)
{
return
true
;
}
}
return
false
;
}
function
getDefault
(
scope
variants
star
)
{
if
(
variants
[
star
]
)
{
return
Type
(
scope
variants
[
star
]
)
;
}
scope
.
errors
.
push
(
new
RangeError
(
"
No
default
"
)
)
;
return
new
FluentNone
(
)
;
}
function
getArguments
(
scope
args
)
{
const
positional
=
[
]
;
const
named
=
{
}
;
for
(
const
arg
of
args
)
{
if
(
arg
.
type
=
=
=
"
narg
"
)
{
named
[
arg
.
name
]
=
Type
(
scope
arg
.
value
)
;
}
else
{
positional
.
push
(
Type
(
scope
arg
)
)
;
}
}
return
[
positional
named
]
;
}
function
Type
(
scope
expr
)
{
if
(
typeof
expr
=
=
=
"
string
"
)
{
return
scope
.
bundle
.
_transform
(
expr
)
;
}
if
(
expr
instanceof
FluentNone
)
{
return
expr
;
}
if
(
Array
.
isArray
(
expr
)
)
{
return
Pattern
(
scope
expr
)
;
}
switch
(
expr
.
type
)
{
case
"
str
"
:
return
expr
.
value
;
case
"
num
"
:
return
new
FluentNumber
(
expr
.
value
{
minimumFractionDigits
:
expr
.
precision
}
)
;
case
"
var
"
:
return
VariableReference
(
scope
expr
)
;
case
"
mesg
"
:
return
MessageReference
(
scope
expr
)
;
case
"
term
"
:
return
TermReference
(
scope
expr
)
;
case
"
func
"
:
return
FunctionReference
(
scope
expr
)
;
case
"
select
"
:
return
SelectExpression
(
scope
expr
)
;
case
undefined
:
{
if
(
expr
.
value
!
=
=
null
&
&
expr
.
value
!
=
=
undefined
)
{
return
Type
(
scope
expr
.
value
)
;
}
scope
.
errors
.
push
(
new
RangeError
(
"
No
value
"
)
)
;
return
new
FluentNone
(
)
;
}
default
:
return
new
FluentNone
(
)
;
}
}
function
VariableReference
(
scope
{
name
}
)
{
if
(
!
scope
.
args
|
|
!
scope
.
args
.
hasOwnProperty
(
name
)
)
{
if
(
scope
.
insideTermReference
=
=
=
false
)
{
scope
.
errors
.
push
(
new
ReferenceError
(
Unknown
variable
:
{
name
}
)
)
;
}
return
new
FluentNone
(
{
name
}
)
;
}
const
arg
=
scope
.
args
[
name
]
;
if
(
arg
instanceof
FluentType
)
{
return
arg
;
}
switch
(
typeof
arg
)
{
case
"
string
"
:
return
arg
;
case
"
number
"
:
return
new
FluentNumber
(
arg
)
;
case
"
object
"
:
if
(
arg
instanceof
Date
)
{
return
new
FluentDateTime
(
arg
)
;
}
default
:
scope
.
errors
.
push
(
new
TypeError
(
Unsupported
variable
type
:
{
name
}
{
typeof
arg
}
)
)
;
return
new
FluentNone
(
{
name
}
)
;
}
}
function
MessageReference
(
scope
{
name
attr
}
)
{
const
message
=
scope
.
bundle
.
_messages
.
get
(
name
)
;
if
(
!
message
)
{
const
err
=
new
ReferenceError
(
Unknown
message
:
{
name
}
)
;
scope
.
errors
.
push
(
err
)
;
return
new
FluentNone
(
name
)
;
}
if
(
attr
)
{
const
attribute
=
message
.
attrs
&
&
message
.
attrs
[
attr
]
;
if
(
attribute
)
{
return
Type
(
scope
attribute
)
;
}
scope
.
errors
.
push
(
new
ReferenceError
(
Unknown
attribute
:
{
attr
}
)
)
;
return
Type
(
scope
message
)
;
}
return
Type
(
scope
message
)
;
}
function
TermReference
(
scope
{
name
attr
args
}
)
{
const
id
=
-
{
name
}
;
const
term
=
scope
.
bundle
.
_terms
.
get
(
id
)
;
if
(
!
term
)
{
const
err
=
new
ReferenceError
(
Unknown
term
:
{
id
}
)
;
scope
.
errors
.
push
(
err
)
;
return
new
FluentNone
(
id
)
;
}
const
[
keyargs
]
=
getArguments
(
scope
args
)
;
const
local
=
{
.
.
.
scope
args
:
keyargs
insideTermReference
:
true
}
;
if
(
attr
)
{
const
attribute
=
term
.
attrs
&
&
term
.
attrs
[
attr
]
;
if
(
attribute
)
{
return
Type
(
local
attribute
)
;
}
scope
.
errors
.
push
(
new
ReferenceError
(
Unknown
attribute
:
{
attr
}
)
)
;
return
Type
(
local
term
)
;
}
return
Type
(
local
term
)
;
}
function
FunctionReference
(
scope
{
name
args
}
)
{
const
func
=
scope
.
bundle
.
_functions
[
name
]
|
|
builtins
[
name
]
;
if
(
!
func
)
{
scope
.
errors
.
push
(
new
ReferenceError
(
Unknown
function
:
{
name
}
(
)
)
)
;
return
new
FluentNone
(
{
name
}
(
)
)
;
}
if
(
typeof
func
!
=
=
"
function
"
)
{
scope
.
errors
.
push
(
new
TypeError
(
Function
{
name
}
(
)
is
not
callable
)
)
;
return
new
FluentNone
(
{
name
}
(
)
)
;
}
try
{
return
func
(
.
.
.
getArguments
(
scope
args
)
)
;
}
catch
(
e
)
{
return
new
FluentNone
(
)
;
}
}
function
SelectExpression
(
scope
{
selector
variants
star
}
)
{
let
sel
=
Type
(
scope
selector
)
;
if
(
sel
instanceof
FluentNone
)
{
const
variant
=
getDefault
(
scope
variants
star
)
;
return
Type
(
scope
variant
)
;
}
for
(
const
variant
of
variants
)
{
const
key
=
Type
(
scope
variant
.
key
)
;
if
(
match
(
scope
.
bundle
sel
key
)
)
{
return
Type
(
scope
variant
)
;
}
}
const
variant
=
getDefault
(
scope
variants
star
)
;
return
Type
(
scope
variant
)
;
}
function
Pattern
(
scope
ptn
)
{
if
(
scope
.
dirty
.
has
(
ptn
)
)
{
scope
.
errors
.
push
(
new
RangeError
(
"
Cyclic
reference
"
)
)
;
return
new
FluentNone
(
)
;
}
scope
.
dirty
.
add
(
ptn
)
;
const
result
=
[
]
;
const
useIsolating
=
scope
.
bundle
.
_useIsolating
&
&
ptn
.
length
>
1
;
for
(
const
elem
of
ptn
)
{
if
(
typeof
elem
=
=
=
"
string
"
)
{
result
.
push
(
scope
.
bundle
.
_transform
(
elem
)
)
;
continue
;
}
const
part
=
Type
(
scope
elem
)
.
toString
(
scope
.
bundle
)
;
if
(
useIsolating
)
{
result
.
push
(
FSI
)
;
}
if
(
part
.
length
>
MAX_PLACEABLE_LENGTH
)
{
scope
.
errors
.
push
(
new
RangeError
(
"
Too
many
characters
in
placeable
"
+
(
{
part
.
length
}
max
allowed
is
{
MAX_PLACEABLE_LENGTH
}
)
)
)
;
result
.
push
(
part
.
slice
(
MAX_PLACEABLE_LENGTH
)
)
;
}
else
{
result
.
push
(
part
)
;
}
if
(
useIsolating
)
{
result
.
push
(
PDI
)
;
}
}
scope
.
dirty
.
delete
(
ptn
)
;
return
result
.
join
(
"
"
)
;
}
function
resolve
(
bundle
args
message
errors
=
[
]
)
{
const
scope
=
{
bundle
args
errors
dirty
:
new
WeakSet
(
)
insideTermReference
:
false
}
;
return
Type
(
scope
message
)
.
toString
(
bundle
)
;
}
class
FluentError
extends
Error
{
}
const
RE_MESSAGE_START
=
/
^
(
-
?
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
*
=
*
/
mg
;
const
RE_ATTRIBUTE_START
=
/
\
.
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
*
=
*
/
y
;
const
RE_VARIANT_START
=
/
\
*
?
\
[
/
y
;
const
RE_NUMBER_LITERAL
=
/
(
-
?
[
0
-
9
]
+
(
?
:
\
.
(
[
0
-
9
]
+
)
)
?
)
/
y
;
const
RE_IDENTIFIER
=
/
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
/
y
;
const
RE_REFERENCE
=
/
(
[
-
]
)
?
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
(
?
:
\
.
(
[
a
-
zA
-
Z
]
[
\
w
-
]
*
)
)
?
/
y
;
const
RE_FUNCTION_NAME
=
/
^
[
A
-
Z
]
[
A
-
Z0
-
9_
-
]
*
/
;
const
RE_TEXT_RUN
=
/
(
[
^
{
}
\
n
\
r
]
+
)
/
y
;
const
RE_STRING_RUN
=
/
(
[
^
\
\
"
\
n
\
r
]
*
)
/
y
;
const
RE_STRING_ESCAPE
=
/
\
\
(
[
\
\
"
]
)
/
y
;
const
RE_UNICODE_ESCAPE
=
/
\
\
u
(
[
a
-
fA
-
F0
-
9
]
{
4
}
)
|
\
\
U
(
[
a
-
fA
-
F0
-
9
]
{
6
}
)
/
y
;
const
RE_LEADING_NEWLINES
=
/
^
\
n
+
/
;
const
RE_TRAILING_SPACES
=
/
+
/
;
const
RE_BLANK_LINES
=
/
*
\
r
?
\
n
/
g
;
const
RE_INDENT
=
/
(
*
)
/
;
const
TOKEN_BRACE_OPEN
=
/
{
\
s
*
/
y
;
const
TOKEN_BRACE_CLOSE
=
/
\
s
*
}
/
y
;
const
TOKEN_BRACKET_OPEN
=
/
\
[
\
s
*
/
y
;
const
TOKEN_BRACKET_CLOSE
=
/
\
s
*
]
*
/
y
;
const
TOKEN_PAREN_OPEN
=
/
\
s
*
\
(
\
s
*
/
y
;
const
TOKEN_ARROW
=
/
\
s
*
-
>
\
s
*
/
y
;
const
TOKEN_COLON
=
/
\
s
*
:
\
s
*
/
y
;
const
TOKEN_COMMA
=
/
\
s
*
?
\
s
*
/
y
;
const
TOKEN_BLANK
=
/
\
s
+
/
y
;
const
MAX_PLACEABLES
=
100
;
class
FluentResource
extends
Map
{
static
fromString
(
source
)
{
RE_MESSAGE_START
.
lastIndex
=
0
;
let
resource
=
new
this
(
)
;
let
cursor
=
0
;
while
(
true
)
{
let
next
=
RE_MESSAGE_START
.
exec
(
source
)
;
if
(
next
=
=
=
null
)
{
break
;
}
cursor
=
RE_MESSAGE_START
.
lastIndex
;
try
{
resource
.
set
(
next
[
1
]
parseMessage
(
)
)
;
}
catch
(
err
)
{
if
(
err
instanceof
FluentError
)
{
continue
;
}
throw
err
;
}
}
return
resource
;
function
test
(
re
)
{
re
.
lastIndex
=
cursor
;
return
re
.
test
(
source
)
;
}
function
consumeChar
(
char
errorClass
)
{
if
(
source
[
cursor
]
=
=
=
char
)
{
cursor
+
+
;
return
true
;
}
if
(
errorClass
)
{
throw
new
errorClass
(
Expected
{
char
}
)
;
}
return
false
;
}
function
consumeToken
(
re
errorClass
)
{
if
(
test
(
re
)
)
{
cursor
=
re
.
lastIndex
;
return
true
;
}
if
(
errorClass
)
{
throw
new
errorClass
(
Expected
{
re
.
toString
(
)
}
)
;
}
return
false
;
}
function
match
(
re
)
{
re
.
lastIndex
=
cursor
;
let
result
=
re
.
exec
(
source
)
;
if
(
result
=
=
=
null
)
{
throw
new
FluentError
(
Expected
{
re
.
toString
(
)
}
)
;
}
cursor
=
re
.
lastIndex
;
return
result
;
}
function
match1
(
re
)
{
return
match
(
re
)
[
1
]
;
}
function
parseMessage
(
)
{
let
value
=
parsePattern
(
)
;
let
attrs
=
parseAttributes
(
)
;
if
(
attrs
=
=
=
null
)
{
if
(
value
=
=
=
null
)
{
throw
new
FluentError
(
"
Expected
message
value
or
attributes
"
)
;
}
return
value
;
}
return
{
value
attrs
}
;
}
function
parseAttributes
(
)
{
let
attrs
=
{
}
;
while
(
test
(
RE_ATTRIBUTE_START
)
)
{
let
name
=
match1
(
RE_ATTRIBUTE_START
)
;
let
value
=
parsePattern
(
)
;
if
(
value
=
=
=
null
)
{
throw
new
FluentError
(
"
Expected
attribute
value
"
)
;
}
attrs
[
name
]
=
value
;
}
return
Object
.
keys
(
attrs
)
.
length
>
0
?
attrs
:
null
;
}
function
parsePattern
(
)
{
if
(
test
(
RE_TEXT_RUN
)
)
{
var
first
=
match1
(
RE_TEXT_RUN
)
;
}
if
(
source
[
cursor
]
=
=
=
"
{
"
|
|
source
[
cursor
]
=
=
=
"
}
"
)
{
return
parsePatternElements
(
first
?
[
first
]
:
[
]
Infinity
)
;
}
let
indent
=
parseIndent
(
)
;
if
(
indent
)
{
if
(
first
)
{
return
parsePatternElements
(
[
first
indent
]
indent
.
length
)
;
}
indent
.
value
=
trim
(
indent
.
value
RE_LEADING_NEWLINES
)
;
return
parsePatternElements
(
[
indent
]
indent
.
length
)
;
}
if
(
first
)
{
return
trim
(
first
RE_TRAILING_SPACES
)
;
}
return
null
;
}
function
parsePatternElements
(
elements
=
[
]
commonIndent
)
{
let
placeableCount
=
0
;
while
(
true
)
{
if
(
test
(
RE_TEXT_RUN
)
)
{
elements
.
push
(
match1
(
RE_TEXT_RUN
)
)
;
continue
;
}
if
(
source
[
cursor
]
=
=
=
"
{
"
)
{
if
(
+
+
placeableCount
>
MAX_PLACEABLES
)
{
throw
new
FluentError
(
"
Too
many
placeables
"
)
;
}
elements
.
push
(
parsePlaceable
(
)
)
;
continue
;
}
if
(
source
[
cursor
]
=
=
=
"
}
"
)
{
throw
new
FluentError
(
"
Unbalanced
closing
brace
"
)
;
}
let
indent
=
parseIndent
(
)
;
if
(
indent
)
{
elements
.
push
(
indent
)
;
commonIndent
=
Math
.
min
(
commonIndent
indent
.
length
)
;
continue
;
}
break
;
}
let
lastIndex
=
elements
.
length
-
1
;
if
(
typeof
elements
[
lastIndex
]
=
=
=
"
string
"
)
{
elements
[
lastIndex
]
=
trim
(
elements
[
lastIndex
]
RE_TRAILING_SPACES
)
;
}
let
baked
=
[
]
;
for
(
let
element
of
elements
)
{
if
(
element
.
type
=
=
=
"
indent
"
)
{
element
=
element
.
value
.
slice
(
0
element
.
value
.
length
-
commonIndent
)
;
}
else
if
(
element
.
type
=
=
=
"
str
"
)
{
element
=
element
.
value
;
}
if
(
element
)
{
baked
.
push
(
element
)
;
}
}
return
baked
;
}
function
parsePlaceable
(
)
{
consumeToken
(
TOKEN_BRACE_OPEN
FluentError
)
;
let
selector
=
parseInlineExpression
(
)
;
if
(
consumeToken
(
TOKEN_BRACE_CLOSE
)
)
{
return
selector
;
}
if
(
consumeToken
(
TOKEN_ARROW
)
)
{
let
variants
=
parseVariants
(
)
;
consumeToken
(
TOKEN_BRACE_CLOSE
FluentError
)
;
return
{
type
:
"
select
"
selector
.
.
.
variants
}
;
}
throw
new
FluentError
(
"
Unclosed
placeable
"
)
;
}
function
parseInlineExpression
(
)
{
if
(
source
[
cursor
]
=
=
=
"
{
"
)
{
return
parsePlaceable
(
)
;
}
if
(
test
(
RE_REFERENCE
)
)
{
let
[
sigil
name
attr
=
null
]
=
match
(
RE_REFERENCE
)
;
if
(
sigil
=
=
=
"
"
)
{
return
{
type
:
"
var
"
name
}
;
}
if
(
consumeToken
(
TOKEN_PAREN_OPEN
)
)
{
let
args
=
parseArguments
(
)
;
if
(
sigil
=
=
=
"
-
"
)
{
return
{
type
:
"
term
"
name
attr
args
}
;
}
if
(
RE_FUNCTION_NAME
.
test
(
name
)
)
{
return
{
type
:
"
func
"
name
args
}
;
}
throw
new
FluentError
(
"
Function
names
must
be
all
upper
-
case
"
)
;
}
if
(
sigil
=
=
=
"
-
"
)
{
return
{
type
:
"
term
"
name
attr
args
:
[
]
}
;
}
return
{
type
:
"
mesg
"
name
attr
}
;
}
return
parseLiteral
(
)
;
}
function
parseArguments
(
)
{
let
args
=
[
]
;
while
(
true
)
{
switch
(
source
[
cursor
]
)
{
case
"
)
"
:
cursor
+
+
;
return
args
;
case
undefined
:
throw
new
FluentError
(
"
Unclosed
argument
list
"
)
;
}
args
.
push
(
parseArgument
(
)
)
;
consumeToken
(
TOKEN_COMMA
)
;
}
}
function
parseArgument
(
)
{
let
expr
=
parseInlineExpression
(
)
;
if
(
expr
.
type
!
=
=
"
mesg
"
)
{
return
expr
;
}
if
(
consumeToken
(
TOKEN_COLON
)
)
{
return
{
type
:
"
narg
"
name
:
expr
.
name
value
:
parseLiteral
(
)
}
;
}
return
expr
;
}
function
parseVariants
(
)
{
let
variants
=
[
]
;
let
count
=
0
;
let
star
;
while
(
test
(
RE_VARIANT_START
)
)
{
if
(
consumeChar
(
"
*
"
)
)
{
star
=
count
;
}
let
key
=
parseVariantKey
(
)
;
let
value
=
parsePattern
(
)
;
if
(
value
=
=
=
null
)
{
throw
new
FluentError
(
"
Expected
variant
value
"
)
;
}
variants
[
count
+
+
]
=
{
key
value
}
;
}
if
(
count
=
=
=
0
)
{
return
null
;
}
if
(
star
=
=
=
undefined
)
{
throw
new
FluentError
(
"
Expected
default
variant
"
)
;
}
return
{
variants
star
}
;
}
function
parseVariantKey
(
)
{
consumeToken
(
TOKEN_BRACKET_OPEN
FluentError
)
;
let
key
=
test
(
RE_NUMBER_LITERAL
)
?
parseNumberLiteral
(
)
:
match1
(
RE_IDENTIFIER
)
;
consumeToken
(
TOKEN_BRACKET_CLOSE
FluentError
)
;
return
key
;
}
function
parseLiteral
(
)
{
if
(
test
(
RE_NUMBER_LITERAL
)
)
{
return
parseNumberLiteral
(
)
;
}
if
(
source
[
cursor
]
=
=
=
"
\
"
"
)
{
return
parseStringLiteral
(
)
;
}
throw
new
FluentError
(
"
Invalid
expression
"
)
;
}
function
parseNumberLiteral
(
)
{
let
[
value
fraction
=
"
"
]
=
match
(
RE_NUMBER_LITERAL
)
;
let
precision
=
fraction
.
length
;
return
{
type
:
"
num
"
value
:
parseFloat
(
value
)
precision
}
;
}
function
parseStringLiteral
(
)
{
consumeChar
(
"
\
"
"
FluentError
)
;
let
value
=
"
"
;
while
(
true
)
{
value
+
=
match1
(
RE_STRING_RUN
)
;
if
(
source
[
cursor
]
=
=
=
"
\
\
"
)
{
value
+
=
parseEscapeSequence
(
)
;
continue
;
}
if
(
consumeChar
(
"
\
"
"
)
)
{
return
{
type
:
"
str
"
value
}
;
}
throw
new
FluentError
(
"
Unclosed
string
literal
"
)
;
}
}
function
parseEscapeSequence
(
)
{
if
(
test
(
RE_STRING_ESCAPE
)
)
{
return
match1
(
RE_STRING_ESCAPE
)
;
}
if
(
test
(
RE_UNICODE_ESCAPE
)
)
{
let
[
codepoint4
codepoint6
]
=
match
(
RE_UNICODE_ESCAPE
)
;
let
codepoint
=
parseInt
(
codepoint4
|
|
codepoint6
16
)
;
return
codepoint
<
=
0xD7FF
|
|
0xE000
<
=
codepoint
?
String
.
fromCodePoint
(
codepoint
)
:
"
"
;
}
throw
new
FluentError
(
"
Unknown
escape
sequence
"
)
;
}
function
parseIndent
(
)
{
let
start
=
cursor
;
consumeToken
(
TOKEN_BLANK
)
;
switch
(
source
[
cursor
]
)
{
case
"
.
"
:
case
"
[
"
:
case
"
*
"
:
case
"
}
"
:
case
undefined
:
return
false
;
case
"
{
"
:
return
makeIndent
(
source
.
slice
(
start
cursor
)
)
;
}
if
(
source
[
cursor
-
1
]
=
=
=
"
"
)
{
return
makeIndent
(
source
.
slice
(
start
cursor
)
)
;
}
return
false
;
}
function
trim
(
text
re
)
{
return
text
.
replace
(
re
"
"
)
;
}
function
makeIndent
(
blank
)
{
let
value
=
blank
.
replace
(
RE_BLANK_LINES
"
\
n
"
)
;
let
length
=
RE_INDENT
.
exec
(
blank
)
[
1
]
.
length
;
return
{
type
:
"
indent
"
value
length
}
;
}
}
}
class
FluentBundle
{
constructor
(
locales
{
functions
=
{
}
useIsolating
=
true
transform
=
v
=
>
v
}
=
{
}
)
{
this
.
locales
=
Array
.
isArray
(
locales
)
?
locales
:
[
locales
]
;
this
.
_terms
=
new
Map
(
)
;
this
.
_messages
=
new
Map
(
)
;
this
.
_functions
=
functions
;
this
.
_useIsolating
=
useIsolating
;
this
.
_transform
=
transform
;
this
.
_intls
=
new
WeakMap
(
)
;
}
get
messages
(
)
{
return
this
.
_messages
[
Symbol
.
iterator
]
(
)
;
}
hasMessage
(
id
)
{
return
this
.
_messages
.
has
(
id
)
;
}
getMessage
(
id
)
{
return
this
.
_messages
.
get
(
id
)
;
}
addMessages
(
source
options
)
{
const
res
=
FluentResource
.
fromString
(
source
)
;
return
this
.
addResource
(
res
options
)
;
}
addResource
(
res
{
allowOverrides
=
false
}
=
{
}
)
{
const
errors
=
[
]
;
for
(
const
[
id
value
]
of
res
)
{
if
(
id
.
startsWith
(
"
-
"
)
)
{
if
(
allowOverrides
=
=
=
false
&
&
this
.
_terms
.
has
(
id
)
)
{
errors
.
push
(
Attempt
to
override
an
existing
term
:
"
{
id
}
"
)
;
continue
;
}
this
.
_terms
.
set
(
id
value
)
;
}
else
{
if
(
allowOverrides
=
=
=
false
&
&
this
.
_messages
.
has
(
id
)
)
{
errors
.
push
(
Attempt
to
override
an
existing
message
:
"
{
id
}
"
)
;
continue
;
}
this
.
_messages
.
set
(
id
value
)
;
}
}
return
errors
;
}
format
(
message
args
errors
)
{
if
(
typeof
message
=
=
=
"
string
"
)
{
return
this
.
_transform
(
message
)
;
}
if
(
message
=
=
=
null
|
|
message
.
value
=
=
=
null
)
{
return
null
;
}
if
(
typeof
message
.
value
=
=
=
"
string
"
)
{
return
this
.
_transform
(
message
.
value
)
;
}
return
resolve
(
this
args
message
errors
)
;
}
_memoizeIntlObject
(
ctor
opts
)
{
const
cache
=
this
.
_intls
.
get
(
ctor
)
|
|
{
}
;
const
id
=
JSON
.
stringify
(
opts
)
;
if
(
!
cache
[
id
]
)
{
cache
[
id
]
=
new
ctor
(
this
.
locales
opts
)
;
this
.
_intls
.
set
(
ctor
cache
)
;
}
return
cache
[
id
]
;
}
}
this
.
EXPORTED_SYMBOLS
=
[
.
.
.
Object
.
keys
(
{
FluentBundle
FluentResource
FluentError
FluentType
FluentNumber
FluentDateTime
}
)
]
;
