const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
appinfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
isParentProcess
=
appinfo
.
processType
=
=
=
appinfo
.
PROCESS_TYPE_DEFAULT
;
class
L10nRegistryService
{
constructor
(
)
{
this
.
sources
=
new
Map
(
)
;
if
(
isParentProcess
)
{
const
locales
=
Services
.
locale
.
packagedLocales
;
let
fileSources
=
[
]
;
for
(
let
{
entry
value
}
of
Services
.
catMan
.
enumerateCategory
(
"
l10n
-
registry
"
)
)
{
if
(
!
this
.
hasSource
(
entry
)
)
{
fileSources
.
push
(
new
L10nFileSource
(
entry
locales
value
)
)
;
}
}
this
.
registerSources
(
fileSources
)
;
}
else
{
this
.
_setSourcesFromSharedData
(
)
;
Services
.
cpmm
.
sharedData
.
addEventListener
(
"
change
"
this
)
;
}
}
clearSources
(
)
{
this
.
sources
=
new
Map
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
change
"
)
{
if
(
event
.
changedKeys
.
includes
(
"
L10nRegistry
:
Sources
"
)
)
{
this
.
_setSourcesFromSharedData
(
)
;
}
}
}
async
*
generateBundles
(
requestedLangs
resourceIds
)
{
const
resourceIdsDedup
=
Array
.
from
(
new
Set
(
resourceIds
)
)
;
const
sourcesOrder
=
Array
.
from
(
this
.
sources
.
keys
(
)
)
.
reverse
(
)
;
const
pseudoStrategy
=
Services
.
prefs
.
getStringPref
(
"
intl
.
l10n
.
pseudo
"
"
"
)
;
for
(
const
locale
of
requestedLangs
)
{
for
await
(
const
dataSets
of
generateResourceSetsForLocale
(
locale
sourcesOrder
resourceIdsDedup
)
)
{
const
bundle
=
new
FluentBundle
(
locale
{
.
.
.
MSG_CONTEXT_OPTIONS
pseudoStrategy
}
)
;
for
(
const
data
of
dataSets
)
{
if
(
data
=
=
=
null
)
{
return
;
}
bundle
.
addResource
(
data
)
;
}
yield
bundle
;
}
}
}
*
generateBundlesSync
(
requestedLangs
resourceIds
)
{
const
resourceIdsDedup
=
Array
.
from
(
new
Set
(
resourceIds
)
)
;
const
sourcesOrder
=
Array
.
from
(
this
.
sources
.
keys
(
)
)
.
reverse
(
)
;
const
pseudoStrategy
=
Services
.
prefs
.
getStringPref
(
"
intl
.
l10n
.
pseudo
"
"
"
)
;
for
(
const
locale
of
requestedLangs
)
{
for
(
const
dataSets
of
generateResourceSetsForLocaleSync
(
locale
sourcesOrder
resourceIdsDedup
)
)
{
const
bundle
=
new
FluentBundle
(
locale
{
.
.
.
MSG_CONTEXT_OPTIONS
pseudoStrategy
}
)
;
for
(
const
data
of
dataSets
)
{
if
(
data
=
=
=
null
)
{
return
;
}
bundle
.
addResource
(
data
)
;
}
yield
bundle
;
}
}
}
hasSource
(
sourceName
)
{
return
this
.
sources
.
has
(
sourceName
)
;
}
registerSources
(
sources
)
{
for
(
const
source
of
sources
)
{
if
(
this
.
hasSource
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
already
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
}
if
(
isParentProcess
&
&
sources
.
length
>
0
)
{
this
.
_synchronizeSharedData
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
}
updateSources
(
sources
)
{
for
(
const
source
of
sources
)
{
if
(
!
this
.
hasSource
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
is
not
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
}
if
(
isParentProcess
&
&
sources
.
length
>
0
)
{
this
.
_synchronizeSharedData
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
}
removeSources
(
sourceNames
)
{
for
(
const
sourceName
of
sourceNames
)
{
this
.
sources
.
delete
(
sourceName
)
;
}
if
(
isParentProcess
&
&
sourceNames
.
length
>
0
)
{
this
.
_synchronizeSharedData
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
}
_synchronizeSharedData
(
)
{
const
sources
=
new
Map
(
)
;
for
(
const
[
name
source
]
of
this
.
sources
.
entries
(
)
)
{
if
(
source
.
index
!
=
=
null
)
{
continue
;
}
sources
.
set
(
name
{
locales
:
source
.
locales
prePath
:
source
.
prePath
}
)
;
}
let
sharedData
=
Services
.
ppmm
.
sharedData
;
sharedData
.
set
(
"
L10nRegistry
:
Sources
"
sources
)
;
sharedData
.
flush
(
)
;
}
_setSourcesFromSharedData
(
)
{
let
sources
=
Services
.
cpmm
.
sharedData
.
get
(
"
L10nRegistry
:
Sources
"
)
;
if
(
!
sources
)
{
console
.
warn
(
[
l10nregistry
]
Failed
to
fetch
sources
from
shared
data
.
)
;
return
;
}
let
registerSourcesList
=
[
]
;
for
(
let
[
name
data
]
of
sources
.
entries
(
)
)
{
if
(
!
this
.
hasSource
(
name
)
)
{
const
source
=
new
L10nFileSource
(
name
data
.
locales
data
.
prePath
)
;
registerSourcesList
.
push
(
source
)
;
}
}
this
.
registerSources
(
registerSourcesList
)
;
let
removeSourcesList
=
[
]
;
for
(
let
name
of
this
.
sources
.
keys
(
)
)
{
if
(
!
sources
.
has
(
name
)
)
{
removeSourcesList
.
push
(
name
)
;
}
}
this
.
removeSources
(
removeSourcesList
)
;
}
getAvailableLocales
(
)
{
const
locales
=
new
Set
(
)
;
for
(
const
source
of
this
.
sources
.
values
(
)
)
{
for
(
const
locale
of
source
.
locales
)
{
locales
.
add
(
locale
)
;
}
}
return
Array
.
from
(
locales
)
;
}
}
async
function
*
generateResourceSetsForLocale
(
locale
sourcesOrder
resourceIds
resolvedOrder
=
[
]
)
{
const
resolvedLength
=
resolvedOrder
.
length
;
const
resourcesLength
=
resourceIds
.
length
;
for
(
const
sourceName
of
sourcesOrder
)
{
const
order
=
resolvedOrder
.
concat
(
sourceName
)
;
for
(
let
[
idx
sourceName
]
of
order
.
entries
(
)
)
{
const
source
=
L10nRegistry
.
sources
.
get
(
sourceName
)
;
if
(
!
source
|
|
source
.
hasFile
(
locale
resourceIds
[
idx
]
)
=
=
=
"
missing
"
)
{
if
(
idx
=
=
=
order
.
length
-
1
)
{
continue
;
}
else
{
return
;
}
}
}
if
(
resolvedLength
+
1
=
=
=
resourcesLength
)
{
let
dataSet
=
await
generateResourceSet
(
locale
order
resourceIds
)
;
if
(
!
dataSet
.
includes
(
null
)
)
{
yield
dataSet
;
}
}
else
if
(
resolvedLength
<
resourcesLength
)
{
yield
*
generateResourceSetsForLocale
(
locale
sourcesOrder
resourceIds
order
)
;
}
}
}
function
*
generateResourceSetsForLocaleSync
(
locale
sourcesOrder
resourceIds
resolvedOrder
=
[
]
)
{
const
resolvedLength
=
resolvedOrder
.
length
;
const
resourcesLength
=
resourceIds
.
length
;
for
(
const
sourceName
of
sourcesOrder
)
{
const
order
=
resolvedOrder
.
concat
(
sourceName
)
;
for
(
let
[
idx
sourceName
]
of
order
.
entries
(
)
)
{
const
source
=
L10nRegistry
.
sources
.
get
(
sourceName
)
;
if
(
!
source
|
|
source
.
hasFile
(
locale
resourceIds
[
idx
]
)
=
=
=
"
missing
"
)
{
if
(
idx
=
=
=
order
.
length
-
1
)
{
continue
;
}
else
{
return
;
}
}
}
if
(
resolvedLength
+
1
=
=
=
resourcesLength
)
{
let
dataSet
=
generateResourceSetSync
(
locale
order
resourceIds
)
;
if
(
!
dataSet
.
includes
(
null
)
)
{
yield
dataSet
;
}
}
else
if
(
resolvedLength
<
resourcesLength
)
{
yield
*
generateResourceSetsForLocaleSync
(
locale
sourcesOrder
resourceIds
order
)
;
}
}
}
const
MSG_CONTEXT_OPTIONS
=
{
useIsolating
:
Services
.
prefs
.
getBoolPref
(
"
intl
.
l10n
.
enable
-
bidi
-
marks
"
false
)
}
;
function
generateResourceSet
(
locale
sourcesOrder
resourceIds
)
{
return
Promise
.
all
(
resourceIds
.
map
(
(
resourceId
i
)
=
>
{
const
source
=
L10nRegistry
.
sources
.
get
(
sourcesOrder
[
i
]
)
;
if
(
!
source
)
{
return
null
;
}
return
source
.
fetchFile
(
locale
resourceId
)
;
}
)
)
;
}
function
generateResourceSetSync
(
locale
sourcesOrder
resourceIds
)
{
return
resourceIds
.
map
(
(
resourceId
i
)
=
>
{
const
source
=
L10nRegistry
.
sources
.
get
(
sourcesOrder
[
i
]
)
;
if
(
!
source
)
{
return
null
;
}
return
source
.
fetchFileSync
(
locale
resourceId
)
;
}
)
;
}
this
.
L10nRegistry
=
new
L10nRegistryService
(
)
;
var
EXPORTED_SYMBOLS
=
[
"
L10nRegistry
"
]
;
