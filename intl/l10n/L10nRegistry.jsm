const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
appinfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
isParentProcess
=
appinfo
.
processType
=
=
=
appinfo
.
PROCESS_TYPE_DEFAULT
;
class
L10nRegistryService
{
constructor
(
)
{
this
.
sources
=
new
Map
(
)
;
if
(
isParentProcess
)
{
const
locales
=
Services
.
locale
.
packagedLocales
;
let
fileSources
=
[
]
;
for
(
let
{
entry
value
}
of
Services
.
catMan
.
enumerateCategory
(
"
l10n
-
registry
"
)
)
{
if
(
!
this
.
hasSource
(
entry
)
)
{
fileSources
.
push
(
new
FileSource
(
entry
locales
value
)
)
;
}
}
this
.
registerSources
(
fileSources
)
;
}
else
{
this
.
_setSourcesFromSharedData
(
)
;
Services
.
cpmm
.
sharedData
.
addEventListener
(
"
change
"
this
)
;
}
}
clearSources
(
)
{
this
.
sources
=
new
Map
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
change
"
)
{
if
(
event
.
changedKeys
.
includes
(
"
L10nRegistry
:
Sources
"
)
)
{
this
.
_setSourcesFromSharedData
(
)
;
}
}
}
async
*
generateBundles
(
requestedLangs
resourceIds
)
{
const
resourceIdsDedup
=
Array
.
from
(
new
Set
(
resourceIds
)
)
;
const
sourcesOrder
=
Array
.
from
(
this
.
sources
.
keys
(
)
)
.
reverse
(
)
;
const
pseudoStrategy
=
Services
.
prefs
.
getStringPref
(
"
intl
.
l10n
.
pseudo
"
"
"
)
;
for
(
const
locale
of
requestedLangs
)
{
for
await
(
const
dataSets
of
generateResourceSetsForLocale
(
locale
sourcesOrder
resourceIdsDedup
)
)
{
const
bundle
=
new
FluentBundle
(
locale
{
.
.
.
MSG_CONTEXT_OPTIONS
pseudoStrategy
}
)
;
for
(
const
data
of
dataSets
)
{
if
(
data
=
=
=
null
)
{
return
;
}
bundle
.
addResource
(
data
)
;
}
yield
bundle
;
}
}
}
*
generateBundlesSync
(
requestedLangs
resourceIds
)
{
const
resourceIdsDedup
=
Array
.
from
(
new
Set
(
resourceIds
)
)
;
const
sourcesOrder
=
Array
.
from
(
this
.
sources
.
keys
(
)
)
.
reverse
(
)
;
const
pseudoStrategy
=
Services
.
prefs
.
getStringPref
(
"
intl
.
l10n
.
pseudo
"
"
"
)
;
for
(
const
locale
of
requestedLangs
)
{
for
(
const
dataSets
of
generateResourceSetsForLocaleSync
(
locale
sourcesOrder
resourceIdsDedup
)
)
{
const
bundle
=
new
FluentBundle
(
locale
{
.
.
.
MSG_CONTEXT_OPTIONS
pseudoStrategy
}
)
;
for
(
const
data
of
dataSets
)
{
if
(
data
=
=
=
null
)
{
return
;
}
bundle
.
addResource
(
data
)
;
}
yield
bundle
;
}
}
}
hasSource
(
sourceName
)
{
return
this
.
sources
.
has
(
sourceName
)
;
}
registerSources
(
sources
)
{
for
(
const
source
of
sources
)
{
if
(
this
.
hasSource
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
already
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
}
if
(
isParentProcess
&
&
sources
.
length
>
0
)
{
this
.
_synchronizeSharedData
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
}
updateSources
(
sources
)
{
for
(
const
source
of
sources
)
{
if
(
!
this
.
hasSource
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
is
not
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
}
if
(
isParentProcess
&
&
sources
.
length
>
0
)
{
this
.
_synchronizeSharedData
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
}
removeSources
(
sourceNames
)
{
for
(
const
sourceName
of
sourceNames
)
{
this
.
sources
.
delete
(
sourceName
)
;
}
if
(
isParentProcess
&
&
sourceNames
.
length
>
0
)
{
this
.
_synchronizeSharedData
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
}
_synchronizeSharedData
(
)
{
const
sources
=
new
Map
(
)
;
for
(
const
[
name
source
]
of
this
.
sources
.
entries
(
)
)
{
if
(
source
.
indexed
)
{
continue
;
}
sources
.
set
(
name
{
locales
:
source
.
locales
prePath
:
source
.
prePath
}
)
;
}
let
sharedData
=
Services
.
ppmm
.
sharedData
;
sharedData
.
set
(
"
L10nRegistry
:
Sources
"
sources
)
;
sharedData
.
flush
(
)
;
}
_setSourcesFromSharedData
(
)
{
let
sources
=
Services
.
cpmm
.
sharedData
.
get
(
"
L10nRegistry
:
Sources
"
)
;
if
(
!
sources
)
{
console
.
warn
(
[
l10nregistry
]
Failed
to
fetch
sources
from
shared
data
.
)
;
return
;
}
let
registerSourcesList
=
[
]
;
for
(
let
[
name
data
]
of
sources
.
entries
(
)
)
{
if
(
!
this
.
hasSource
(
name
)
)
{
const
source
=
new
FileSource
(
name
data
.
locales
data
.
prePath
)
;
registerSourcesList
.
push
(
source
)
;
}
}
this
.
registerSources
(
registerSourcesList
)
;
let
removeSourcesList
=
[
]
;
for
(
let
name
of
this
.
sources
.
keys
(
)
)
{
if
(
!
sources
.
has
(
name
)
)
{
removeSourcesList
.
push
(
name
)
;
}
}
this
.
removeSources
(
removeSourcesList
)
;
}
getAvailableLocales
(
)
{
const
locales
=
new
Set
(
)
;
for
(
const
source
of
this
.
sources
.
values
(
)
)
{
for
(
const
locale
of
source
.
locales
)
{
locales
.
add
(
locale
)
;
}
}
return
Array
.
from
(
locales
)
;
}
}
async
function
*
generateResourceSetsForLocale
(
locale
sourcesOrder
resourceIds
resolvedOrder
=
[
]
)
{
const
resolvedLength
=
resolvedOrder
.
length
;
const
resourcesLength
=
resourceIds
.
length
;
for
(
const
sourceName
of
sourcesOrder
)
{
const
order
=
resolvedOrder
.
concat
(
sourceName
)
;
for
(
let
[
idx
sourceName
]
of
order
.
entries
(
)
)
{
const
source
=
L10nRegistry
.
sources
.
get
(
sourceName
)
;
if
(
!
source
|
|
source
.
hasFile
(
locale
resourceIds
[
idx
]
)
=
=
=
false
)
{
if
(
idx
=
=
=
order
.
length
-
1
)
{
continue
;
}
else
{
return
;
}
}
}
if
(
resolvedLength
+
1
=
=
=
resourcesLength
)
{
let
dataSet
=
await
generateResourceSet
(
locale
order
resourceIds
)
;
if
(
!
dataSet
.
includes
(
false
)
)
{
yield
dataSet
;
}
}
else
if
(
resolvedLength
<
resourcesLength
)
{
yield
*
generateResourceSetsForLocale
(
locale
sourcesOrder
resourceIds
order
)
;
}
}
}
function
*
generateResourceSetsForLocaleSync
(
locale
sourcesOrder
resourceIds
resolvedOrder
=
[
]
)
{
const
resolvedLength
=
resolvedOrder
.
length
;
const
resourcesLength
=
resourceIds
.
length
;
for
(
const
sourceName
of
sourcesOrder
)
{
const
order
=
resolvedOrder
.
concat
(
sourceName
)
;
for
(
let
[
idx
sourceName
]
of
order
.
entries
(
)
)
{
const
source
=
L10nRegistry
.
sources
.
get
(
sourceName
)
;
if
(
!
source
|
|
source
.
hasFile
(
locale
resourceIds
[
idx
]
)
=
=
=
false
)
{
if
(
idx
=
=
=
order
.
length
-
1
)
{
continue
;
}
else
{
return
;
}
}
}
if
(
resolvedLength
+
1
=
=
=
resourcesLength
)
{
let
dataSet
=
generateResourceSetSync
(
locale
order
resourceIds
)
;
if
(
!
dataSet
.
includes
(
false
)
)
{
yield
dataSet
;
}
}
else
if
(
resolvedLength
<
resourcesLength
)
{
yield
*
generateResourceSetsForLocaleSync
(
locale
sourcesOrder
resourceIds
order
)
;
}
}
}
const
MSG_CONTEXT_OPTIONS
=
{
useIsolating
:
Services
.
prefs
.
getBoolPref
(
"
intl
.
l10n
.
enable
-
bidi
-
marks
"
false
)
}
;
function
generateResourceSet
(
locale
sourcesOrder
resourceIds
)
{
return
Promise
.
all
(
resourceIds
.
map
(
(
resourceId
i
)
=
>
{
const
source
=
L10nRegistry
.
sources
.
get
(
sourcesOrder
[
i
]
)
;
if
(
!
source
)
{
return
false
;
}
return
source
.
fetchFile
(
locale
resourceId
)
;
}
)
)
;
}
function
generateResourceSetSync
(
locale
sourcesOrder
resourceIds
)
{
return
resourceIds
.
map
(
(
resourceId
i
)
=
>
{
const
source
=
L10nRegistry
.
sources
.
get
(
sourcesOrder
[
i
]
)
;
if
(
!
source
)
{
return
false
;
}
return
source
.
fetchFile
(
locale
resourceId
{
sync
:
true
}
)
;
}
)
;
}
class
FileSource
{
constructor
(
name
locales
prePath
)
{
this
.
name
=
name
;
this
.
locales
=
locales
;
this
.
prePath
=
prePath
;
this
.
indexed
=
false
;
this
.
cache
=
{
}
;
}
getPath
(
locale
path
)
{
if
(
locale
=
=
=
"
ja
-
JP
-
macos
"
)
{
locale
=
"
ja
-
JP
-
mac
"
;
}
return
(
this
.
prePath
+
path
)
.
replace
(
/
\
{
locale
\
}
/
g
locale
)
;
}
hasFile
(
locale
path
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
false
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
if
(
!
this
.
cache
.
hasOwnProperty
(
fullPath
)
)
{
return
this
.
indexed
?
false
:
undefined
;
}
if
(
this
.
cache
[
fullPath
]
=
=
=
false
)
{
return
false
;
}
if
(
this
.
cache
[
fullPath
]
.
then
)
{
return
undefined
;
}
return
true
;
}
fetchFile
(
locale
path
options
=
{
sync
:
false
}
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
false
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
if
(
this
.
cache
.
hasOwnProperty
(
fullPath
)
)
{
if
(
this
.
cache
[
fullPath
]
=
=
=
false
)
{
return
false
;
}
if
(
this
.
cache
[
fullPath
]
!
=
=
true
)
{
if
(
this
.
cache
[
fullPath
]
instanceof
Promise
&
&
options
.
sync
)
{
console
.
warn
(
[
l10nregistry
]
Attempting
to
synchronously
load
file
{
fullPath
}
while
it
'
s
being
loaded
asynchronously
.
)
;
}
else
{
return
this
.
cache
[
fullPath
]
;
}
}
}
else
if
(
this
.
indexed
)
{
return
false
;
}
if
(
options
.
sync
)
{
let
data
=
L10nRegistry
.
loadSync
(
fullPath
)
;
if
(
data
=
=
=
false
)
{
this
.
cache
[
fullPath
]
=
false
;
}
else
{
this
.
cache
[
fullPath
]
=
new
FluentResource
(
data
)
;
}
return
this
.
cache
[
fullPath
]
;
}
return
this
.
cache
[
fullPath
]
=
L10nRegistry
.
load
(
fullPath
)
.
then
(
data
=
>
{
return
this
.
cache
[
fullPath
]
=
new
FluentResource
(
data
)
;
}
err
=
>
{
this
.
cache
[
fullPath
]
=
false
;
return
false
;
}
)
;
}
}
class
IndexedFileSource
extends
FileSource
{
constructor
(
name
locales
prePath
paths
)
{
super
(
name
locales
prePath
)
;
this
.
indexed
=
true
;
for
(
const
path
of
paths
)
{
this
.
cache
[
path
]
=
true
;
}
}
}
this
.
L10nRegistry
=
new
L10nRegistryService
(
)
;
L10nRegistry
.
load
=
function
(
url
)
{
return
fetch
(
url
)
.
then
(
response
=
>
{
if
(
!
response
.
ok
)
{
return
Promise
.
reject
(
response
.
statusText
)
;
}
return
response
.
text
(
)
;
}
)
;
}
;
L10nRegistry
.
loadSync
=
function
(
uri
)
{
try
{
let
url
=
Services
.
io
.
newURI
(
uri
)
;
let
data
=
Cu
.
readUTF8URI
(
url
)
;
return
data
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_INVALID_ARG
|
|
e
.
result
=
=
Cr
.
NS_ERROR_NOT_INITIALIZED
)
{
try
{
let
stream
=
NetUtil
.
newChannel
(
{
uri
loadUsingSystemPrincipal
:
true
}
)
.
open
(
)
;
return
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
{
charset
:
"
UTF
-
8
"
}
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
Cu
.
reportError
(
e
)
;
}
}
}
else
if
(
e
.
result
!
=
Cr
.
NS_ERROR_FILE_NOT_FOUND
)
{
Cu
.
reportError
(
e
)
;
}
}
return
false
;
}
;
this
.
FileSource
=
FileSource
;
this
.
IndexedFileSource
=
IndexedFileSource
;
var
EXPORTED_SYMBOLS
=
[
"
L10nRegistry
"
"
FileSource
"
"
IndexedFileSource
"
]
;
