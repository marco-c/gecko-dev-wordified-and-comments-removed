const
{
Services
}
=
Components
.
utils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
{
}
)
;
const
{
MessageContext
}
=
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
MessageContext
.
jsm
"
{
}
)
;
Components
.
utils
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
const
L10nRegistry
=
{
sources
:
new
Map
(
)
ctxCache
:
new
Map
(
)
*
generateContexts
(
requestedLangs
resourceIds
)
{
const
sourcesOrder
=
Array
.
from
(
this
.
sources
.
keys
(
)
)
.
reverse
(
)
;
for
(
const
locale
of
requestedLangs
)
{
yield
*
generateContextsForLocale
(
locale
sourcesOrder
resourceIds
)
;
}
}
registerSource
(
source
)
{
if
(
this
.
sources
.
has
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
already
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
Services
.
obs
.
notifyObservers
(
null
'
l10n
:
available
-
locales
-
changed
'
null
)
;
}
updateSource
(
source
)
{
if
(
!
this
.
sources
.
has
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
is
not
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
this
.
ctxCache
.
clear
(
)
;
Services
.
obs
.
notifyObservers
(
null
'
l10n
:
available
-
locales
-
changed
'
null
)
;
}
removeSource
(
sourceName
)
{
this
.
sources
.
delete
(
sourceName
)
;
Services
.
obs
.
notifyObservers
(
null
'
l10n
:
available
-
locales
-
changed
'
null
)
;
}
getAvailableLocales
(
)
{
const
locales
=
new
Set
(
)
;
for
(
const
source
of
this
.
sources
.
values
(
)
)
{
for
(
const
locale
of
source
.
locales
)
{
locales
.
add
(
locale
)
;
}
}
return
Array
.
from
(
locales
)
;
}
}
;
function
generateContextID
(
locale
sourcesOrder
resourceIds
)
{
const
sources
=
sourcesOrder
.
join
(
'
'
)
;
const
ids
=
resourceIds
.
join
(
'
'
)
;
return
{
locale
}
|
{
sources
}
|
{
ids
}
;
}
function
*
generateContextsForLocale
(
locale
sourcesOrder
resourceIds
resolvedOrder
=
[
]
)
{
const
resolvedLength
=
resolvedOrder
.
length
;
const
resourcesLength
=
resourceIds
.
length
;
for
(
const
sourceName
of
sourcesOrder
)
{
const
order
=
resolvedOrder
.
concat
(
sourceName
)
;
if
(
L10nRegistry
.
sources
.
get
(
sourceName
)
.
hasFile
(
locale
resourceIds
[
resolvedOrder
.
length
]
)
=
=
=
false
)
{
continue
;
}
if
(
resolvedLength
+
1
=
=
=
resourcesLength
)
{
yield
generateContext
(
locale
order
resourceIds
)
;
}
else
{
yield
*
generateContextsForLocale
(
locale
sourcesOrder
resourceIds
order
)
;
}
}
}
async
function
generateContext
(
locale
sourcesOrder
resourceIds
)
{
const
ctxId
=
generateContextID
(
locale
sourcesOrder
resourceIds
)
;
if
(
!
L10nRegistry
.
ctxCache
.
has
(
ctxId
)
)
{
const
ctx
=
new
MessageContext
(
locale
)
;
for
(
let
i
=
0
;
i
<
resourceIds
.
length
;
i
+
+
)
{
const
data
=
await
L10nRegistry
.
sources
.
get
(
sourcesOrder
[
i
]
)
.
fetchFile
(
locale
resourceIds
[
i
]
)
;
if
(
data
=
=
=
null
)
{
return
false
;
}
ctx
.
addMessages
(
data
)
;
}
L10nRegistry
.
ctxCache
.
set
(
ctxId
ctx
)
;
}
return
L10nRegistry
.
ctxCache
.
get
(
ctxId
)
;
}
class
FileSource
{
constructor
(
name
locales
prePath
)
{
this
.
name
=
name
;
this
.
locales
=
locales
;
this
.
prePath
=
prePath
;
this
.
cache
=
{
}
;
}
getPath
(
locale
path
)
{
return
(
this
.
prePath
+
path
)
.
replace
(
/
\
{
locale
\
}
/
g
locale
)
;
}
hasFile
(
locale
path
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
false
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
if
(
!
this
.
cache
.
hasOwnProperty
(
fullPath
)
)
{
return
undefined
;
}
if
(
this
.
cache
[
fullPath
]
=
=
=
null
)
{
return
false
;
}
return
true
;
}
async
fetchFile
(
locale
path
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
null
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
if
(
this
.
hasFile
(
locale
path
)
=
=
=
undefined
)
{
let
file
=
await
L10nRegistry
.
load
(
fullPath
)
;
if
(
file
=
=
=
undefined
)
{
this
.
cache
[
fullPath
]
=
null
;
}
else
{
this
.
cache
[
fullPath
]
=
file
;
}
}
return
this
.
cache
[
fullPath
]
;
}
}
class
IndexedFileSource
extends
FileSource
{
constructor
(
name
locales
prePath
paths
)
{
super
(
name
locales
prePath
)
;
this
.
paths
=
paths
;
}
hasFile
(
locale
path
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
false
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
return
this
.
paths
.
includes
(
fullPath
)
;
}
async
fetchFile
(
locale
path
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
null
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
if
(
this
.
paths
.
includes
(
fullPath
)
)
{
let
file
=
await
L10nRegistry
.
load
(
fullPath
)
;
if
(
file
=
=
=
undefined
)
{
return
null
;
}
else
{
return
file
;
}
}
else
{
return
null
;
}
}
}
L10nRegistry
.
load
=
function
(
url
)
{
return
fetch
(
url
)
.
then
(
data
=
>
data
.
text
(
)
)
.
catch
(
(
)
=
>
undefined
)
;
}
;
this
.
L10nRegistry
=
L10nRegistry
;
this
.
FileSource
=
FileSource
;
this
.
IndexedFileSource
=
IndexedFileSource
;
this
.
EXPORTED_SYMBOLS
=
[
'
L10nRegistry
'
'
FileSource
'
'
IndexedFileSource
'
]
;
