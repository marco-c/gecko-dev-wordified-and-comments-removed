const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
appinfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
const
{
FluentBundle
FluentResource
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Fluent
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
const
isParentProcess
=
appinfo
.
processType
=
=
=
appinfo
.
PROCESS_TYPE_DEFAULT
;
class
L10nRegistryService
{
constructor
(
)
{
this
.
sources
=
new
Map
(
)
;
if
(
!
isParentProcess
)
{
this
.
_setSourcesFromSharedData
(
)
;
Services
.
cpmm
.
sharedData
.
addEventListener
(
"
change
"
this
)
;
}
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
=
"
change
"
)
{
if
(
event
.
changedKeys
.
includes
(
"
L10nRegistry
:
Sources
"
)
)
{
this
.
_setSourcesFromSharedData
(
)
;
}
}
}
async
*
generateBundles
(
requestedLangs
resourceIds
)
{
const
sourcesOrder
=
Array
.
from
(
this
.
sources
.
keys
(
)
)
.
reverse
(
)
;
const
pseudoNameFromPref
=
Services
.
prefs
.
getStringPref
(
"
intl
.
l10n
.
pseudo
"
"
"
)
;
for
(
const
locale
of
requestedLangs
)
{
for
await
(
const
dataSets
of
generateResourceSetsForLocale
(
locale
sourcesOrder
resourceIds
)
)
{
const
bundle
=
new
FluentBundle
(
locale
{
.
.
.
MSG_CONTEXT_OPTIONS
transform
:
PSEUDO_STRATEGIES
[
pseudoNameFromPref
]
}
)
;
for
(
const
data
of
dataSets
)
{
if
(
data
=
=
=
null
)
{
return
;
}
bundle
.
addResource
(
data
)
;
}
yield
bundle
;
}
}
}
*
generateBundlesSync
(
requestedLangs
resourceIds
)
{
const
sourcesOrder
=
Array
.
from
(
this
.
sources
.
keys
(
)
)
.
reverse
(
)
;
const
pseudoNameFromPref
=
Services
.
prefs
.
getStringPref
(
"
intl
.
l10n
.
pseudo
"
"
"
)
;
for
(
const
locale
of
requestedLangs
)
{
for
(
const
dataSets
of
generateResourceSetsForLocaleSync
(
locale
sourcesOrder
resourceIds
)
)
{
const
bundle
=
new
FluentBundle
(
locale
{
.
.
.
MSG_CONTEXT_OPTIONS
transform
:
PSEUDO_STRATEGIES
[
pseudoNameFromPref
]
}
)
;
for
(
const
data
of
dataSets
)
{
if
(
data
=
=
=
null
)
{
return
;
}
bundle
.
addResource
(
data
)
;
}
yield
bundle
;
}
}
}
hasSource
(
sourceName
)
{
return
this
.
sources
.
has
(
sourceName
)
;
}
registerSource
(
source
)
{
if
(
this
.
hasSource
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
already
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
if
(
isParentProcess
)
{
this
.
_synchronizeSharedData
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
}
updateSource
(
source
)
{
if
(
!
this
.
hasSource
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
is
not
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
if
(
isParentProcess
)
{
this
.
_synchronizeSharedData
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
}
removeSource
(
sourceName
)
{
this
.
sources
.
delete
(
sourceName
)
;
if
(
isParentProcess
)
{
this
.
_synchronizeSharedData
(
)
;
Services
.
locale
.
availableLocales
=
this
.
getAvailableLocales
(
)
;
}
}
_synchronizeSharedData
(
)
{
const
sources
=
new
Map
(
)
;
for
(
const
[
name
source
]
of
this
.
sources
.
entries
(
)
)
{
if
(
source
.
indexed
)
{
continue
;
}
sources
.
set
(
name
{
locales
:
source
.
locales
prePath
:
source
.
prePath
}
)
;
}
Services
.
ppmm
.
sharedData
.
set
(
"
L10nRegistry
:
Sources
"
sources
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
}
_setSourcesFromSharedData
(
)
{
let
sources
=
Services
.
cpmm
.
sharedData
.
get
(
"
L10nRegistry
:
Sources
"
)
;
for
(
let
[
name
data
]
of
sources
.
entries
(
)
)
{
if
(
!
this
.
hasSource
(
name
)
)
{
const
source
=
new
FileSource
(
name
data
.
locales
data
.
prePath
)
;
this
.
registerSource
(
source
)
;
}
}
for
(
let
name
of
this
.
sources
.
keys
(
)
)
{
if
(
!
sources
.
has
(
name
)
)
{
this
.
removeSource
(
name
)
;
}
}
}
getAvailableLocales
(
)
{
const
locales
=
new
Set
(
)
;
for
(
const
source
of
this
.
sources
.
values
(
)
)
{
for
(
const
locale
of
source
.
locales
)
{
locales
.
add
(
locale
)
;
}
}
return
Array
.
from
(
locales
)
;
}
}
async
function
*
generateResourceSetsForLocale
(
locale
sourcesOrder
resourceIds
resolvedOrder
=
[
]
)
{
const
resolvedLength
=
resolvedOrder
.
length
;
const
resourcesLength
=
resourceIds
.
length
;
for
(
const
sourceName
of
sourcesOrder
)
{
const
order
=
resolvedOrder
.
concat
(
sourceName
)
;
for
(
let
[
idx
sourceName
]
of
order
.
entries
(
)
)
{
if
(
L10nRegistry
.
sources
.
get
(
sourceName
)
.
hasFile
(
locale
resourceIds
[
idx
]
)
=
=
=
false
)
{
if
(
idx
=
=
=
order
.
length
-
1
)
{
continue
;
}
else
{
return
;
}
}
}
if
(
resolvedLength
+
1
=
=
=
resourcesLength
)
{
let
dataSet
=
await
generateResourceSet
(
locale
order
resourceIds
)
;
if
(
!
dataSet
.
includes
(
false
)
)
{
yield
dataSet
;
}
}
else
if
(
resolvedLength
<
resourcesLength
)
{
yield
*
generateResourceSetsForLocale
(
locale
sourcesOrder
resourceIds
order
)
;
}
}
}
function
*
generateResourceSetsForLocaleSync
(
locale
sourcesOrder
resourceIds
resolvedOrder
=
[
]
)
{
const
resolvedLength
=
resolvedOrder
.
length
;
const
resourcesLength
=
resourceIds
.
length
;
for
(
const
sourceName
of
sourcesOrder
)
{
const
order
=
resolvedOrder
.
concat
(
sourceName
)
;
for
(
let
[
idx
sourceName
]
of
order
.
entries
(
)
)
{
if
(
L10nRegistry
.
sources
.
get
(
sourceName
)
.
hasFile
(
locale
resourceIds
[
idx
]
)
=
=
=
false
)
{
if
(
idx
=
=
=
order
.
length
-
1
)
{
continue
;
}
else
{
return
;
}
}
}
if
(
resolvedLength
+
1
=
=
=
resourcesLength
)
{
let
dataSet
=
generateResourceSetSync
(
locale
order
resourceIds
)
;
if
(
!
dataSet
.
includes
(
false
)
)
{
yield
dataSet
;
}
}
else
if
(
resolvedLength
<
resourcesLength
)
{
yield
*
generateResourceSetsForLocaleSync
(
locale
sourcesOrder
resourceIds
order
)
;
}
}
}
const
MSG_CONTEXT_OPTIONS
=
{
useIsolating
:
Services
.
prefs
.
getBoolPref
(
"
intl
.
l10n
.
enable
-
bidi
-
marks
"
false
)
functions
:
{
PLATFORM
:
(
)
=
>
{
switch
(
AppConstants
.
platform
)
{
case
"
linux
"
:
case
"
android
"
:
return
AppConstants
.
platform
;
case
"
win
"
:
return
"
windows
"
;
case
"
macosx
"
:
return
"
macos
"
;
default
:
return
"
other
"
;
}
}
}
}
;
const
ACCENTED_MAP
=
{
"
caps
"
:
[
550
385
391
7698
7702
401
403
294
298
308
310
319
7742
544
510
420
586
344
350
358
364
7804
7814
7818
7822
7824
]
"
small
"
:
[
551
384
392
7699
7703
402
608
295
299
309
311
320
7743
414
511
421
587
345
351
359
365
7805
7815
7819
7823
7825
]
}
;
const
FLIPPED_MAP
=
{
"
caps
"
:
[
8704
1296
8579
5601
398
8498
8513
72
73
383
1276
8514
87
78
79
1280
210
7450
83
8869
8745
581
77
88
8516
90
]
"
small
"
:
[
592
113
596
112
477
607
387
613
305
638
670
645
623
117
111
100
98
633
115
647
110
652
653
120
654
122
]
}
;
function
transformString
(
map
elongate
=
false
prefix
=
"
"
postfix
=
"
"
msg
)
{
if
(
msg
.
length
=
=
=
1
)
{
return
msg
;
}
const
reExcluded
=
/
(
&
[
#
\
w
]
+
;
|
<
\
s
*
.
+
?
\
s
*
>
)
/
;
const
parts
=
msg
.
split
(
reExcluded
)
;
const
modified
=
parts
.
map
(
(
part
)
=
>
{
if
(
reExcluded
.
test
(
part
)
)
{
return
part
;
}
return
prefix
+
part
.
replace
(
/
[
a
-
z
]
/
ig
(
ch
)
=
>
{
let
cc
=
ch
.
charCodeAt
(
0
)
;
if
(
cc
>
=
97
&
&
cc
<
=
122
)
{
const
newChar
=
String
.
fromCodePoint
(
map
.
small
[
cc
-
97
]
)
;
if
(
elongate
&
&
(
cc
=
=
=
97
|
|
cc
=
=
=
101
|
|
cc
=
=
=
111
|
|
cc
=
=
=
117
)
)
{
return
newChar
+
newChar
;
}
return
newChar
;
}
if
(
cc
>
=
65
&
&
cc
<
=
90
)
{
return
String
.
fromCodePoint
(
map
.
caps
[
cc
-
65
]
)
;
}
return
ch
;
}
)
+
postfix
;
}
)
;
return
modified
.
join
(
"
"
)
;
}
const
PSEUDO_STRATEGIES
=
{
"
accented
"
:
transformString
.
bind
(
null
ACCENTED_MAP
true
"
"
"
"
)
"
bidi
"
:
transformString
.
bind
(
null
FLIPPED_MAP
false
"
\
u202e
"
"
\
u202c
"
)
}
;
async
function
generateResourceSet
(
locale
sourcesOrder
resourceIds
)
{
return
Promise
.
all
(
resourceIds
.
map
(
(
resourceId
i
)
=
>
{
return
L10nRegistry
.
sources
.
get
(
sourcesOrder
[
i
]
)
.
fetchFile
(
locale
resourceId
)
;
}
)
)
;
}
function
generateResourceSetSync
(
locale
sourcesOrder
resourceIds
)
{
return
resourceIds
.
map
(
(
resourceId
i
)
=
>
{
return
L10nRegistry
.
sources
.
get
(
sourcesOrder
[
i
]
)
.
fetchFile
(
locale
resourceId
{
sync
:
true
}
)
;
}
)
;
}
class
FileSource
{
constructor
(
name
locales
prePath
)
{
this
.
name
=
name
;
this
.
locales
=
locales
;
this
.
prePath
=
prePath
;
this
.
indexed
=
false
;
this
.
cache
=
{
}
;
}
getPath
(
locale
path
)
{
if
(
locale
=
=
=
"
ja
-
JP
-
macos
"
)
{
locale
=
"
ja
-
JP
-
mac
"
;
}
return
(
this
.
prePath
+
path
)
.
replace
(
/
\
{
locale
\
}
/
g
locale
)
;
}
hasFile
(
locale
path
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
false
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
if
(
!
this
.
cache
.
hasOwnProperty
(
fullPath
)
)
{
return
this
.
indexed
?
false
:
undefined
;
}
if
(
this
.
cache
[
fullPath
]
=
=
=
false
)
{
return
false
;
}
if
(
this
.
cache
[
fullPath
]
.
then
)
{
return
undefined
;
}
return
true
;
}
fetchFile
(
locale
path
options
=
{
sync
:
false
}
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
false
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
if
(
this
.
cache
.
hasOwnProperty
(
fullPath
)
)
{
if
(
this
.
cache
[
fullPath
]
=
=
=
false
)
{
return
false
;
}
if
(
this
.
cache
[
fullPath
]
!
=
=
true
)
{
return
this
.
cache
[
fullPath
]
;
}
}
else
if
(
this
.
indexed
)
{
return
false
;
}
if
(
options
.
sync
)
{
let
data
=
L10nRegistry
.
loadSync
(
fullPath
)
;
if
(
data
=
=
=
false
)
{
this
.
cache
[
fullPath
]
=
false
;
}
else
{
this
.
cache
[
fullPath
]
=
FluentResource
.
fromString
(
data
)
;
}
return
this
.
cache
[
fullPath
]
;
}
return
this
.
cache
[
fullPath
]
=
L10nRegistry
.
load
(
fullPath
)
.
then
(
data
=
>
{
return
this
.
cache
[
fullPath
]
=
FluentResource
.
fromString
(
data
)
;
}
err
=
>
{
this
.
cache
[
fullPath
]
=
false
;
return
false
;
}
)
;
}
}
class
IndexedFileSource
extends
FileSource
{
constructor
(
name
locales
prePath
paths
)
{
super
(
name
locales
prePath
)
;
this
.
indexed
=
true
;
for
(
const
path
of
paths
)
{
this
.
cache
[
path
]
=
true
;
}
}
}
this
.
L10nRegistry
=
new
L10nRegistryService
(
)
;
this
.
L10nRegistry
.
load
=
function
(
url
)
{
return
fetch
(
url
)
.
then
(
response
=
>
{
if
(
!
response
.
ok
)
{
return
Promise
.
reject
(
response
.
statusText
)
;
}
return
response
.
text
(
)
;
}
)
;
}
;
this
.
L10nRegistry
.
loadSync
=
function
(
uri
)
{
try
{
let
url
=
Services
.
io
.
newURI
(
uri
)
;
let
data
=
Cu
.
readUTF8URI
(
url
)
;
return
data
;
}
catch
(
e
)
{
return
false
;
}
}
;
this
.
FileSource
=
FileSource
;
this
.
IndexedFileSource
=
IndexedFileSource
;
var
EXPORTED_SYMBOLS
=
[
"
L10nRegistry
"
"
FileSource
"
"
IndexedFileSource
"
]
;
