const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
{
}
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
{
}
)
;
const
{
MessageContext
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
MessageContext
.
jsm
"
{
}
)
;
Components
.
utils
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
const
L10nRegistry
=
{
sources
:
new
Map
(
)
ctxCache
:
new
Map
(
)
bootstrap
:
null
async
*
generateContexts
(
requestedLangs
resourceIds
)
{
if
(
this
.
bootstrap
!
=
=
null
)
{
await
this
.
bootstrap
;
}
const
sourcesOrder
=
Array
.
from
(
this
.
sources
.
keys
(
)
)
.
reverse
(
)
;
for
(
const
locale
of
requestedLangs
)
{
yield
*
generateContextsForLocale
(
locale
sourcesOrder
resourceIds
)
;
}
}
registerSource
(
source
)
{
if
(
this
.
sources
.
has
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
already
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
Services
.
locale
.
setAvailableLocales
(
this
.
getAvailableLocales
(
)
)
;
}
updateSource
(
source
)
{
if
(
!
this
.
sources
.
has
(
source
.
name
)
)
{
throw
new
Error
(
Source
with
name
"
{
source
.
name
}
"
is
not
registered
.
)
;
}
this
.
sources
.
set
(
source
.
name
source
)
;
this
.
ctxCache
.
clear
(
)
;
Services
.
locale
.
setAvailableLocales
(
this
.
getAvailableLocales
(
)
)
;
}
removeSource
(
sourceName
)
{
this
.
sources
.
delete
(
sourceName
)
;
Services
.
locale
.
setAvailableLocales
(
this
.
getAvailableLocales
(
)
)
;
}
getAvailableLocales
(
)
{
const
locales
=
new
Set
(
)
;
for
(
const
source
of
this
.
sources
.
values
(
)
)
{
for
(
const
locale
of
source
.
locales
)
{
locales
.
add
(
locale
)
;
}
}
return
Array
.
from
(
locales
)
;
}
}
;
function
generateContextID
(
locale
sourcesOrder
resourceIds
)
{
const
sources
=
sourcesOrder
.
join
(
'
'
)
;
const
ids
=
resourceIds
.
join
(
'
'
)
;
return
{
locale
}
|
{
sources
}
|
{
ids
}
;
}
async
function
*
generateContextsForLocale
(
locale
sourcesOrder
resourceIds
resolvedOrder
=
[
]
)
{
const
resolvedLength
=
resolvedOrder
.
length
;
const
resourcesLength
=
resourceIds
.
length
;
for
(
const
sourceName
of
sourcesOrder
)
{
const
order
=
resolvedOrder
.
concat
(
sourceName
)
;
if
(
L10nRegistry
.
sources
.
get
(
sourceName
)
.
hasFile
(
locale
resourceIds
[
resolvedOrder
.
length
]
)
=
=
=
false
)
{
continue
;
}
if
(
resolvedLength
+
1
=
=
=
resourcesLength
)
{
const
ctx
=
await
generateContext
(
locale
order
resourceIds
)
;
if
(
ctx
!
=
=
null
)
{
yield
ctx
;
}
}
else
{
yield
*
generateContextsForLocale
(
locale
sourcesOrder
resourceIds
order
)
;
}
}
}
const
MSG_CONTEXT_OPTIONS
=
{
useIsolating
:
Services
.
prefs
.
getBoolPref
(
"
intl
.
l10n
.
enable
-
bidi
-
marks
"
false
)
functions
:
{
PLATFORM
:
(
)
=
>
{
switch
(
AppConstants
.
platform
)
{
case
"
linux
"
:
case
"
android
"
:
return
AppConstants
.
platform
;
case
"
win
"
:
return
"
windows
"
;
case
"
macosx
"
:
return
"
macos
"
;
default
:
return
"
other
"
;
}
}
}
}
function
generateContext
(
locale
sourcesOrder
resourceIds
)
{
const
ctxId
=
generateContextID
(
locale
sourcesOrder
resourceIds
)
;
if
(
L10nRegistry
.
ctxCache
.
has
(
ctxId
)
)
{
return
L10nRegistry
.
ctxCache
.
get
(
ctxId
)
;
}
const
fetchPromises
=
resourceIds
.
map
(
(
resourceId
i
)
=
>
{
return
L10nRegistry
.
sources
.
get
(
sourcesOrder
[
i
]
)
.
fetchFile
(
locale
resourceId
)
;
}
)
;
const
ctxPromise
=
Promise
.
all
(
fetchPromises
)
.
then
(
dataSets
=
>
{
const
ctx
=
new
MessageContext
(
locale
MSG_CONTEXT_OPTIONS
)
;
for
(
const
data
of
dataSets
)
{
if
(
data
=
=
=
null
)
{
return
null
;
}
ctx
.
addMessages
(
data
)
;
}
return
ctx
;
}
(
)
=
>
null
)
;
L10nRegistry
.
ctxCache
.
set
(
ctxId
ctxPromise
)
;
return
ctxPromise
;
}
class
FileSource
{
constructor
(
name
locales
prePath
)
{
this
.
name
=
name
;
this
.
locales
=
locales
;
this
.
prePath
=
prePath
;
this
.
indexed
=
false
;
this
.
cache
=
{
}
;
}
getPath
(
locale
path
)
{
return
(
this
.
prePath
+
path
)
.
replace
(
/
\
{
locale
\
}
/
g
locale
)
;
}
hasFile
(
locale
path
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
false
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
if
(
!
this
.
cache
.
hasOwnProperty
(
fullPath
)
)
{
return
this
.
indexed
?
false
:
undefined
;
}
if
(
this
.
cache
[
fullPath
]
=
=
=
false
)
{
return
false
;
}
if
(
this
.
cache
[
fullPath
]
.
then
)
{
return
undefined
;
}
return
true
;
}
fetchFile
(
locale
path
)
{
if
(
!
this
.
locales
.
includes
(
locale
)
)
{
return
Promise
.
reject
(
The
source
has
no
resources
for
locale
"
{
locale
}
"
)
;
}
const
fullPath
=
this
.
getPath
(
locale
path
)
;
if
(
this
.
cache
.
hasOwnProperty
(
fullPath
)
)
{
if
(
this
.
cache
[
fullPath
]
=
=
=
false
)
{
return
Promise
.
reject
(
The
source
has
no
resources
for
path
"
{
fullPath
}
"
)
;
}
if
(
this
.
cache
[
fullPath
]
.
then
)
{
return
this
.
cache
[
fullPath
]
;
}
}
else
{
if
(
this
.
indexed
)
{
return
Promise
.
reject
(
The
source
has
no
resources
for
path
"
{
fullPath
}
"
)
;
}
}
return
this
.
cache
[
fullPath
]
=
L10nRegistry
.
load
(
fullPath
)
.
then
(
data
=
>
{
return
this
.
cache
[
fullPath
]
=
data
;
}
err
=
>
{
this
.
cache
[
fullPath
]
=
false
;
return
Promise
.
reject
(
err
)
;
}
)
;
}
}
class
IndexedFileSource
extends
FileSource
{
constructor
(
name
locales
prePath
paths
)
{
super
(
name
locales
prePath
)
;
this
.
indexed
=
true
;
for
(
const
path
of
paths
)
{
this
.
cache
[
path
]
=
true
;
}
}
}
L10nRegistry
.
load
=
function
(
url
)
{
return
fetch
(
url
)
.
then
(
response
=
>
{
if
(
!
response
.
ok
)
{
return
Promise
.
reject
(
response
.
statusText
)
;
}
return
response
.
text
(
)
}
)
;
}
;
this
.
L10nRegistry
=
L10nRegistry
;
this
.
FileSource
=
FileSource
;
this
.
IndexedFileSource
=
IndexedFileSource
;
this
.
EXPORTED_SYMBOLS
=
[
'
L10nRegistry
'
'
FileSource
'
'
IndexedFileSource
'
]
;
