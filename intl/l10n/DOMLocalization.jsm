const
{
Localization
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Localization
.
jsm
"
{
}
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
{
}
)
;
const
reOverlay
=
/
<
|
&
#
?
\
w
+
;
/
;
const
TEXT_LEVEL_ELEMENTS
=
{
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
:
[
"
em
"
"
strong
"
"
small
"
"
s
"
"
cite
"
"
q
"
"
dfn
"
"
abbr
"
"
data
"
"
time
"
"
code
"
"
var
"
"
samp
"
"
kbd
"
"
sub
"
"
sup
"
"
i
"
"
b
"
"
u
"
"
mark
"
"
bdi
"
"
bdo
"
"
span
"
"
br
"
"
wbr
"
]
}
;
const
LOCALIZABLE_ATTRIBUTES
=
{
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
:
{
global
:
[
"
title
"
"
aria
-
label
"
"
aria
-
valuetext
"
"
aria
-
moz
-
hint
"
]
a
:
[
"
download
"
]
area
:
[
"
download
"
"
alt
"
]
input
:
[
"
alt
"
"
placeholder
"
]
menuitem
:
[
"
label
"
]
menu
:
[
"
label
"
]
optgroup
:
[
"
label
"
]
option
:
[
"
label
"
]
track
:
[
"
label
"
]
img
:
[
"
alt
"
]
textarea
:
[
"
placeholder
"
]
th
:
[
"
abbr
"
]
}
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
:
{
global
:
[
"
accesskey
"
"
aria
-
label
"
"
aria
-
valuetext
"
"
aria
-
moz
-
hint
"
"
label
"
]
description
:
[
"
value
"
]
key
:
[
"
key
"
"
keycode
"
]
label
:
[
"
value
"
]
textbox
:
[
"
placeholder
"
]
toolbarbutton
:
[
"
tooltiptext
"
]
}
}
;
function
translateElement
(
element
translation
)
{
const
{
value
}
=
translation
;
if
(
typeof
value
=
=
=
"
string
"
)
{
if
(
!
reOverlay
.
test
(
value
)
)
{
element
.
textContent
=
value
;
}
else
{
const
templateElement
=
element
.
ownerDocument
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
template
"
)
;
templateElement
.
innerHTML
=
value
;
overlayChildNodes
(
templateElement
.
content
element
)
;
}
}
overlayAttributes
(
translation
element
)
;
}
function
overlayChildNodes
(
fromFragment
toElement
)
{
for
(
const
childNode
of
fromFragment
.
childNodes
)
{
if
(
childNode
.
nodeType
=
=
=
childNode
.
TEXT_NODE
)
{
continue
;
}
if
(
childNode
.
hasAttribute
(
"
data
-
l10n
-
name
"
)
)
{
const
sanitized
=
namedChildFrom
(
toElement
childNode
)
;
fromFragment
.
replaceChild
(
sanitized
childNode
)
;
continue
;
}
if
(
isElementAllowed
(
childNode
)
)
{
const
sanitized
=
allowedChild
(
childNode
)
;
fromFragment
.
replaceChild
(
sanitized
childNode
)
;
continue
;
}
console
.
warn
(
An
element
of
forbidden
type
"
{
childNode
.
localName
}
"
was
found
in
+
"
the
translation
.
Only
safe
text
-
level
elements
and
elements
with
"
+
"
data
-
l10n
-
name
are
allowed
.
"
)
;
fromFragment
.
replaceChild
(
textNode
(
childNode
)
childNode
)
;
}
toElement
.
textContent
=
"
"
;
toElement
.
appendChild
(
fromFragment
)
;
}
function
overlayAttributes
(
fromElement
toElement
)
{
const
explicitlyAllowed
=
toElement
.
hasAttribute
(
"
data
-
l10n
-
attrs
"
)
?
toElement
.
getAttribute
(
"
data
-
l10n
-
attrs
"
)
.
split
(
"
"
)
.
map
(
i
=
>
i
.
trim
(
)
)
:
null
;
for
(
const
attr
of
Array
.
from
(
toElement
.
attributes
)
)
{
if
(
isAttrNameLocalizable
(
attr
.
name
toElement
explicitlyAllowed
)
)
{
toElement
.
removeAttribute
(
attr
.
name
)
;
}
}
if
(
!
fromElement
.
attributes
)
{
return
;
}
for
(
const
attr
of
Array
.
from
(
fromElement
.
attributes
)
)
{
if
(
isAttrNameLocalizable
(
attr
.
name
toElement
explicitlyAllowed
)
)
{
toElement
.
setAttribute
(
attr
.
name
attr
.
value
)
;
}
}
}
function
namedChildFrom
(
sourceElement
translatedChild
)
{
const
childName
=
translatedChild
.
getAttribute
(
"
data
-
l10n
-
name
"
)
;
const
sourceChild
=
sourceElement
.
querySelector
(
[
data
-
l10n
-
name
=
"
{
childName
}
"
]
)
;
if
(
!
sourceChild
)
{
console
.
warn
(
An
element
named
"
{
childName
}
"
wasn
'
t
found
in
the
source
.
)
;
return
textNode
(
translatedChild
)
;
}
if
(
sourceChild
.
localName
!
=
=
translatedChild
.
localName
)
{
console
.
warn
(
An
element
named
"
{
childName
}
"
was
found
in
the
translation
+
but
its
type
{
translatedChild
.
localName
}
didn
'
t
match
the
+
element
found
in
the
source
(
{
sourceChild
.
localName
}
)
.
)
;
return
textNode
(
translatedChild
)
;
}
sourceElement
.
removeChild
(
sourceChild
)
;
const
clone
=
sourceChild
.
cloneNode
(
false
)
;
return
shallowPopulateUsing
(
translatedChild
clone
)
;
}
function
allowedChild
(
element
)
{
const
clone
=
element
.
ownerDocument
.
createElement
(
element
.
localName
)
;
return
shallowPopulateUsing
(
element
clone
)
;
}
function
textNode
(
element
)
{
return
element
.
ownerDocument
.
createTextNode
(
element
.
textContent
)
;
}
function
isElementAllowed
(
element
)
{
const
allowed
=
TEXT_LEVEL_ELEMENTS
[
element
.
namespaceURI
]
;
return
allowed
&
&
allowed
.
includes
(
element
.
localName
)
;
}
function
isAttrNameLocalizable
(
name
element
explicitlyAllowed
=
null
)
{
if
(
explicitlyAllowed
&
&
explicitlyAllowed
.
includes
(
name
)
)
{
return
true
;
}
const
allowed
=
LOCALIZABLE_ATTRIBUTES
[
element
.
namespaceURI
]
;
if
(
!
allowed
)
{
return
false
;
}
const
attrName
=
name
.
toLowerCase
(
)
;
const
elemName
=
element
.
localName
;
if
(
allowed
.
global
.
includes
(
attrName
)
)
{
return
true
;
}
if
(
!
allowed
[
elemName
]
)
{
return
false
;
}
if
(
allowed
[
elemName
]
.
includes
(
attrName
)
)
{
return
true
;
}
if
(
element
.
namespaceURI
=
=
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
&
&
elemName
=
=
=
"
input
"
&
&
attrName
=
=
=
"
value
"
)
{
const
type
=
element
.
type
.
toLowerCase
(
)
;
if
(
type
=
=
=
"
submit
"
|
|
type
=
=
=
"
button
"
|
|
type
=
=
=
"
reset
"
)
{
return
true
;
}
}
return
false
;
}
function
shallowPopulateUsing
(
fromElement
toElement
)
{
toElement
.
textContent
=
fromElement
.
textContent
;
overlayAttributes
(
fromElement
toElement
)
;
return
toElement
;
}
function
sanitizeTranslationForNodeLocalize
(
l10nItem
translation
)
{
if
(
reOverlay
.
test
(
translation
.
value
)
)
{
return
false
;
}
if
(
translation
.
attributes
)
{
const
explicitlyAllowed
=
l10nItem
.
l10nAttrs
=
=
=
null
?
null
:
l10nItem
.
l10nAttrs
.
split
(
"
"
)
.
map
(
i
=
>
i
.
trim
(
)
)
;
for
(
const
[
j
{
name
}
]
of
translation
.
attributes
.
entries
(
)
)
{
if
(
!
isAttrNameLocalizable
(
name
l10nItem
explicitlyAllowed
)
)
{
translation
.
attributes
.
splice
(
j
1
)
;
}
}
}
return
true
;
}
const
L10NID_ATTR_NAME
=
"
data
-
l10n
-
id
"
;
const
L10NARGS_ATTR_NAME
=
"
data
-
l10n
-
args
"
;
const
L10N_ELEMENT_QUERY
=
[
{
L10NID_ATTR_NAME
}
]
;
class
DOMLocalization
extends
Localization
{
constructor
(
resourceIds
generateMessages
)
{
super
(
resourceIds
generateMessages
)
;
this
.
roots
=
new
Set
(
)
;
this
.
pendingrAF
=
null
;
this
.
pendingElements
=
new
Set
(
)
;
this
.
windowElement
=
null
;
this
.
mutationObserver
=
null
;
this
.
observerConfig
=
{
attribute
:
true
characterData
:
false
childList
:
true
subtree
:
true
attributeFilter
:
[
L10NID_ATTR_NAME
L10NARGS_ATTR_NAME
]
}
;
}
onChange
(
eager
=
false
)
{
super
.
onChange
(
eager
)
;
this
.
translateRoots
(
)
;
}
setAttributes
(
element
id
args
)
{
element
.
setAttribute
(
L10NID_ATTR_NAME
id
)
;
if
(
args
)
{
element
.
setAttribute
(
L10NARGS_ATTR_NAME
JSON
.
stringify
(
args
)
)
;
}
else
{
element
.
removeAttribute
(
L10NARGS_ATTR_NAME
)
;
}
return
element
;
}
getAttributes
(
element
)
{
return
{
id
:
element
.
getAttribute
(
L10NID_ATTR_NAME
)
args
:
JSON
.
parse
(
element
.
getAttribute
(
L10NARGS_ATTR_NAME
)
|
|
null
)
}
;
}
connectRoot
(
newRoot
)
{
for
(
const
root
of
this
.
roots
)
{
if
(
root
=
=
=
newRoot
|
|
root
.
contains
(
newRoot
)
|
|
newRoot
.
contains
(
root
)
)
{
throw
new
Error
(
"
Cannot
add
a
root
that
overlaps
with
existing
root
.
"
)
;
}
}
if
(
this
.
windowElement
)
{
if
(
this
.
windowElement
!
=
=
newRoot
.
ownerGlobal
)
{
throw
new
Error
(
Cannot
connect
a
root
:
DOMLocalization
already
has
a
root
from
a
different
window
.
)
;
}
}
else
{
this
.
windowElement
=
newRoot
.
ownerGlobal
;
this
.
mutationObserver
=
new
this
.
windowElement
.
MutationObserver
(
mutations
=
>
this
.
translateMutations
(
mutations
)
)
;
}
this
.
roots
.
add
(
newRoot
)
;
this
.
mutationObserver
.
observe
(
newRoot
this
.
observerConfig
)
;
}
disconnectRoot
(
root
)
{
this
.
roots
.
delete
(
root
)
;
this
.
pauseObserving
(
)
;
if
(
this
.
roots
.
size
=
=
=
0
)
{
this
.
mutationObserver
=
null
;
this
.
windowElement
=
null
;
this
.
pendingrAF
=
null
;
this
.
pendingElements
.
clear
(
)
;
return
true
;
}
this
.
resumeObserving
(
)
;
return
false
;
}
translateRoots
(
)
{
const
roots
=
Array
.
from
(
this
.
roots
)
;
return
Promise
.
all
(
roots
.
map
(
async
root
=
>
{
await
this
.
translateFragment
(
root
)
;
let
primaryLocale
=
Services
.
locale
.
appLocaleAsBCP47
;
let
direction
=
Services
.
locale
.
isAppLocaleRTL
?
"
rtl
"
:
"
ltr
"
;
root
.
setAttribute
(
"
lang
"
primaryLocale
)
;
root
.
setAttribute
(
root
.
namespaceURI
=
=
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
?
"
localedir
"
:
"
dir
"
direction
)
;
}
)
)
;
}
pauseObserving
(
)
{
if
(
!
this
.
mutationObserver
)
{
return
;
}
this
.
translateMutations
(
this
.
mutationObserver
.
takeRecords
(
)
)
;
this
.
mutationObserver
.
disconnect
(
)
;
}
resumeObserving
(
)
{
if
(
!
this
.
mutationObserver
)
{
return
;
}
for
(
const
root
of
this
.
roots
)
{
this
.
mutationObserver
.
observe
(
root
this
.
observerConfig
)
;
}
}
translateMutations
(
mutations
)
{
for
(
const
mutation
of
mutations
)
{
switch
(
mutation
.
type
)
{
case
"
attributes
"
:
if
(
mutation
.
target
.
hasAttribute
(
"
data
-
l10n
-
id
"
)
)
{
this
.
pendingElements
.
add
(
mutation
.
target
)
;
}
break
;
case
"
childList
"
:
for
(
const
addedNode
of
mutation
.
addedNodes
)
{
if
(
addedNode
.
nodeType
=
=
=
addedNode
.
ELEMENT_NODE
)
{
if
(
addedNode
.
childElementCount
)
{
for
(
const
element
of
this
.
getTranslatables
(
addedNode
)
)
{
this
.
pendingElements
.
add
(
element
)
;
}
}
else
if
(
addedNode
.
hasAttribute
(
L10NID_ATTR_NAME
)
)
{
this
.
pendingElements
.
add
(
addedNode
)
;
}
}
}
break
;
}
}
if
(
this
.
pendingElements
.
size
>
0
)
{
if
(
this
.
pendingrAF
=
=
=
null
)
{
this
.
pendingrAF
=
this
.
windowElement
.
requestAnimationFrame
(
(
)
=
>
{
this
.
translateElements
(
Array
.
from
(
this
.
pendingElements
)
.
filter
(
elem
=
>
elem
.
hasAttribute
(
"
data
-
l10n
-
id
"
)
)
)
;
this
.
pendingElements
.
clear
(
)
;
this
.
pendingrAF
=
null
;
}
)
;
}
}
}
translateFragment
(
frag
)
{
if
(
frag
.
localize
)
{
const
overlayTranslations
=
[
]
;
const
getTranslationsForItems
=
async
l10nItems
=
>
{
const
keys
=
l10nItems
.
map
(
l10nItem
=
>
(
{
id
:
l10nItem
.
l10nId
args
:
l10nItem
.
l10nArgs
}
)
)
;
const
translations
=
await
this
.
formatMessages
(
keys
)
;
for
(
const
[
i
translation
]
of
translations
.
entries
(
)
)
{
if
(
translation
=
=
=
undefined
)
{
continue
;
}
const
hasOnlyText
=
sanitizeTranslationForNodeLocalize
(
l10nItems
[
i
]
translation
)
;
if
(
!
hasOnlyText
)
{
overlayTranslations
[
i
]
=
translations
[
i
]
;
translations
[
i
]
=
undefined
;
}
}
this
.
pauseObserving
(
)
;
return
translations
;
}
;
return
frag
.
localize
(
getTranslationsForItems
.
bind
(
this
)
)
.
then
(
untranslatedElements
=
>
{
for
(
let
i
=
0
;
i
<
overlayTranslations
.
length
;
i
+
+
)
{
if
(
overlayTranslations
[
i
]
!
=
=
undefined
&
&
untranslatedElements
[
i
]
!
=
=
undefined
)
{
translateElement
(
untranslatedElements
[
i
]
overlayTranslations
[
i
]
)
;
}
}
this
.
resumeObserving
(
)
;
}
)
.
catch
(
e
=
>
{
this
.
resumeObserving
(
)
;
throw
e
;
}
)
;
}
return
this
.
translateElements
(
this
.
getTranslatables
(
frag
)
)
;
}
async
translateElements
(
elements
)
{
if
(
!
elements
.
length
)
{
return
undefined
;
}
const
keys
=
elements
.
map
(
this
.
getKeysForElement
)
;
const
translations
=
await
this
.
formatMessages
(
keys
)
;
return
this
.
applyTranslations
(
elements
translations
)
;
}
applyTranslations
(
elements
translations
)
{
this
.
pauseObserving
(
)
;
for
(
let
i
=
0
;
i
<
elements
.
length
;
i
+
+
)
{
if
(
translations
[
i
]
!
=
=
undefined
)
{
translateElement
(
elements
[
i
]
translations
[
i
]
)
;
}
}
this
.
resumeObserving
(
)
;
}
getTranslatables
(
element
)
{
const
nodes
=
Array
.
from
(
element
.
querySelectorAll
(
L10N_ELEMENT_QUERY
)
)
;
if
(
typeof
element
.
hasAttribute
=
=
=
"
function
"
&
&
element
.
hasAttribute
(
L10NID_ATTR_NAME
)
)
{
nodes
.
push
(
element
)
;
}
return
nodes
;
}
getKeysForElement
(
element
)
{
return
{
id
:
element
.
getAttribute
(
L10NID_ATTR_NAME
)
args
:
JSON
.
parse
(
element
.
getAttribute
(
L10NARGS_ATTR_NAME
)
|
|
null
)
}
;
}
}
this
.
DOMLocalization
=
DOMLocalization
;
var
EXPORTED_SYMBOLS
=
[
"
DOMLocalization
"
]
;
