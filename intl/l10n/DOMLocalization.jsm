const
{
Localization
}
=
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Localization
.
jsm
"
{
}
)
;
const
reOverlay
=
/
<
|
&
#
?
\
w
+
;
/
;
const
ALLOWED_ELEMENTS
=
{
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
:
[
'
a
'
'
em
'
'
strong
'
'
small
'
'
s
'
'
cite
'
'
q
'
'
dfn
'
'
abbr
'
'
data
'
'
time
'
'
code
'
'
var
'
'
samp
'
'
kbd
'
'
sub
'
'
sup
'
'
i
'
'
b
'
'
u
'
'
mark
'
'
ruby
'
'
rt
'
'
rp
'
'
bdi
'
'
bdo
'
'
span
'
'
br
'
'
wbr
'
]
}
;
const
ALLOWED_ATTRIBUTES
=
{
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
:
{
global
:
[
'
title
'
'
aria
-
label
'
'
aria
-
valuetext
'
'
aria
-
moz
-
hint
'
]
a
:
[
'
download
'
]
area
:
[
'
download
'
'
alt
'
]
input
:
[
'
alt
'
'
placeholder
'
]
menuitem
:
[
'
label
'
]
menu
:
[
'
label
'
]
optgroup
:
[
'
label
'
]
option
:
[
'
label
'
]
track
:
[
'
label
'
]
img
:
[
'
alt
'
]
textarea
:
[
'
placeholder
'
]
th
:
[
'
abbr
'
]
}
'
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
'
:
{
global
:
[
'
accesskey
'
'
aria
-
label
'
'
aria
-
valuetext
'
'
aria
-
moz
-
hint
'
'
label
'
]
key
:
[
'
key
'
'
keycode
'
]
textbox
:
[
'
placeholder
'
]
toolbarbutton
:
[
'
tooltiptext
'
]
}
}
;
function
overlayElement
(
targetElement
translation
)
{
const
value
=
translation
.
value
;
if
(
typeof
value
=
=
=
'
string
'
)
{
if
(
!
reOverlay
.
test
(
value
)
)
{
targetElement
.
textContent
=
value
;
}
else
{
const
templateElement
=
targetElement
.
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
template
'
)
;
templateElement
.
innerHTML
=
value
;
targetElement
.
appendChild
(
sanitizeUsing
(
templateElement
.
content
targetElement
)
)
;
}
}
if
(
translation
.
attrs
=
=
=
null
)
{
return
;
}
const
explicitlyAllowed
=
targetElement
.
hasAttribute
(
'
data
-
l10n
-
attrs
'
)
?
targetElement
.
getAttribute
(
'
data
-
l10n
-
attrs
'
)
.
split
(
'
'
)
.
map
(
i
=
>
i
.
trim
(
)
)
:
null
;
for
(
const
[
name
val
]
of
translation
.
attrs
)
{
if
(
isAttrNameAllowed
(
name
targetElement
explicitlyAllowed
)
)
{
targetElement
.
setAttribute
(
name
val
)
;
}
}
}
function
sanitizeUsing
(
translationFragment
sourceElement
)
{
for
(
const
childNode
of
translationFragment
.
childNodes
)
{
if
(
childNode
.
nodeType
=
=
=
childNode
.
TEXT_NODE
)
{
continue
;
}
if
(
!
isElementAllowed
(
childNode
)
)
{
const
text
=
translationFragment
.
ownerDocument
.
createTextNode
(
childNode
.
textContent
)
;
translationFragment
.
replaceChild
(
text
childNode
)
;
continue
;
}
const
sourceChild
=
shiftNamedElement
(
sourceElement
childNode
.
localName
)
;
const
mergedChild
=
sourceChild
?
sourceChild
.
cloneNode
(
false
)
:
childNode
.
ownerDocument
.
createElement
(
childNode
.
localName
)
;
mergedChild
.
textContent
=
childNode
.
textContent
;
for
(
const
attr
of
Array
.
from
(
childNode
.
attributes
)
)
{
if
(
isAttrNameAllowed
(
attr
.
name
childNode
)
)
{
mergedChild
.
setAttribute
(
attr
.
name
attr
.
value
)
;
}
}
translationFragment
.
replaceChild
(
mergedChild
childNode
)
;
}
sourceElement
.
textContent
=
'
'
;
return
translationFragment
;
}
function
isElementAllowed
(
element
)
{
const
allowed
=
ALLOWED_ELEMENTS
[
element
.
namespaceURI
]
;
return
allowed
&
&
allowed
.
includes
(
element
.
localName
)
;
}
function
isAttrNameAllowed
(
name
element
explicitlyAllowed
=
null
)
{
if
(
explicitlyAllowed
&
&
explicitlyAllowed
.
includes
(
name
)
)
{
return
true
;
}
const
allowed
=
ALLOWED_ATTRIBUTES
[
element
.
namespaceURI
]
;
if
(
!
allowed
)
{
return
false
;
}
const
attrName
=
name
.
toLowerCase
(
)
;
const
elemName
=
element
.
localName
;
if
(
allowed
.
global
.
includes
(
attrName
)
)
{
return
true
;
}
if
(
!
allowed
[
elemName
]
)
{
return
false
;
}
if
(
allowed
[
elemName
]
.
includes
(
attrName
)
)
{
return
true
;
}
if
(
element
.
namespaceURI
=
=
=
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
&
&
elemName
=
=
=
'
input
'
&
&
attrName
=
=
=
'
value
'
)
{
const
type
=
element
.
type
.
toLowerCase
(
)
;
if
(
type
=
=
=
'
submit
'
|
|
type
=
=
=
'
button
'
|
|
type
=
=
=
'
reset
'
)
{
return
true
;
}
}
return
false
;
}
function
shiftNamedElement
(
element
localName
)
{
for
(
const
child
of
element
.
children
)
{
if
(
child
.
localName
=
=
=
localName
)
{
element
.
removeChild
(
child
)
;
return
child
;
}
}
return
null
;
}
const
L10NID_ATTR_NAME
=
'
data
-
l10n
-
id
'
;
const
L10NARGS_ATTR_NAME
=
'
data
-
l10n
-
args
'
;
const
L10N_ELEMENT_QUERY
=
[
{
L10NID_ATTR_NAME
}
]
;
class
DOMLocalization
extends
Localization
{
constructor
(
windowElement
resourceIds
generateMessages
)
{
super
(
resourceIds
generateMessages
)
;
this
.
roots
=
new
Set
(
)
;
this
.
pendingrAF
=
null
;
this
.
pendingElements
=
new
Set
(
)
;
this
.
windowElement
=
windowElement
;
this
.
mutationObserver
=
new
windowElement
.
MutationObserver
(
mutations
=
>
this
.
translateMutations
(
mutations
)
)
;
this
.
observerConfig
=
{
attribute
:
true
characterData
:
false
childList
:
true
subtree
:
true
attributeFilter
:
[
L10NID_ATTR_NAME
L10NARGS_ATTR_NAME
]
}
;
}
onLanguageChange
(
)
{
super
.
onLanguageChange
(
)
;
this
.
translateRoots
(
)
;
}
setAttributes
(
element
id
args
)
{
element
.
setAttribute
(
L10NID_ATTR_NAME
id
)
;
if
(
args
)
{
element
.
setAttribute
(
L10NARGS_ATTR_NAME
JSON
.
stringify
(
args
)
)
;
}
else
{
element
.
removeAttribute
(
L10NARGS_ATTR_NAME
)
;
}
return
element
;
}
getAttributes
(
element
)
{
return
{
id
:
element
.
getAttribute
(
L10NID_ATTR_NAME
)
args
:
JSON
.
parse
(
element
.
getAttribute
(
L10NARGS_ATTR_NAME
)
|
|
null
)
}
;
}
connectRoot
(
newRoot
)
{
for
(
const
root
of
this
.
roots
)
{
if
(
root
=
=
=
newRoot
|
|
root
.
contains
(
newRoot
)
|
|
newRoot
.
contains
(
root
)
)
{
throw
new
Error
(
'
Cannot
add
a
root
that
overlaps
with
existing
root
.
'
)
;
}
}
this
.
roots
.
add
(
newRoot
)
;
this
.
mutationObserver
.
observe
(
newRoot
this
.
observerConfig
)
;
}
disconnectRoot
(
root
)
{
this
.
roots
.
delete
(
root
)
;
this
.
pauseObserving
(
)
;
this
.
resumeObserving
(
)
;
return
this
.
roots
.
size
=
=
=
0
;
}
translateRoots
(
)
{
const
roots
=
Array
.
from
(
this
.
roots
)
;
return
Promise
.
all
(
roots
.
map
(
root
=
>
this
.
translateElements
(
this
.
getTranslatables
(
root
)
)
)
)
;
}
pauseObserving
(
)
{
this
.
translateMutations
(
this
.
mutationObserver
.
takeRecords
(
)
)
;
this
.
mutationObserver
.
disconnect
(
)
;
}
resumeObserving
(
)
{
for
(
const
root
of
this
.
roots
)
{
this
.
mutationObserver
.
observe
(
root
this
.
observerConfig
)
;
}
}
translateMutations
(
mutations
)
{
for
(
const
mutation
of
mutations
)
{
switch
(
mutation
.
type
)
{
case
'
attributes
'
:
this
.
pendingElements
.
add
(
mutation
.
target
)
;
break
;
case
'
childList
'
:
for
(
const
addedNode
of
mutation
.
addedNodes
)
{
if
(
addedNode
.
nodeType
=
=
=
addedNode
.
ELEMENT_NODE
)
{
if
(
addedNode
.
childElementCount
)
{
for
(
let
element
of
this
.
getTranslatables
(
addedNode
)
)
{
this
.
pendingElements
.
add
(
element
)
;
}
}
else
if
(
addedNode
.
hasAttribute
(
L10NID_ATTR_NAME
)
)
{
this
.
pendingElements
.
add
(
addedNode
)
;
}
}
}
break
;
}
}
if
(
this
.
pendingElements
.
size
>
0
)
{
if
(
this
.
pendingrAF
=
=
=
null
)
{
this
.
pendingrAF
=
this
.
windowElement
.
requestAnimationFrame
(
(
)
=
>
{
this
.
translateElements
(
Array
.
from
(
this
.
pendingElements
)
)
;
this
.
pendingElements
.
clear
(
)
;
this
.
pendingrAF
=
null
;
}
)
;
}
}
}
translateFragment
(
frag
)
{
return
this
.
translateElements
(
this
.
getTranslatables
(
frag
)
)
;
}
async
translateElements
(
elements
)
{
if
(
!
elements
.
length
)
{
return
undefined
;
}
const
keys
=
elements
.
map
(
this
.
getKeysForElement
)
;
const
translations
=
await
this
.
formatMessages
(
keys
)
;
return
this
.
applyTranslations
(
elements
translations
)
;
}
applyTranslations
(
elements
translations
)
{
this
.
pauseObserving
(
)
;
for
(
let
i
=
0
;
i
<
elements
.
length
;
i
+
+
)
{
overlayElement
(
elements
[
i
]
translations
[
i
]
)
;
}
this
.
resumeObserving
(
)
;
}
getTranslatables
(
element
)
{
const
nodes
=
Array
.
from
(
element
.
querySelectorAll
(
L10N_ELEMENT_QUERY
)
)
;
if
(
typeof
element
.
hasAttribute
=
=
=
'
function
'
&
&
element
.
hasAttribute
(
L10NID_ATTR_NAME
)
)
{
nodes
.
push
(
element
)
;
}
return
nodes
;
}
getKeysForElement
(
element
)
{
return
[
element
.
getAttribute
(
L10NID_ATTR_NAME
)
JSON
.
parse
(
element
.
getAttribute
(
L10NARGS_ATTR_NAME
)
|
|
null
)
]
;
}
}
this
.
DOMLocalization
=
DOMLocalization
;
this
.
EXPORTED_SYMBOLS
=
[
'
DOMLocalization
'
]
;
