const
{
Localization
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Localization
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
L10NID_ATTR_NAME
=
"
data
-
l10n
-
id
"
;
const
L10NARGS_ATTR_NAME
=
"
data
-
l10n
-
args
"
;
const
L10N_ELEMENT_QUERY
=
[
{
L10NID_ATTR_NAME
}
]
;
function
reportDOMOverlayErrors
(
errors
)
{
for
(
let
error
of
errors
)
{
switch
(
error
.
code
)
{
case
DOMOverlays
.
ERROR_FORBIDDEN_TYPE
:
{
console
.
warn
(
An
element
of
forbidden
type
"
{
error
.
translatedElementName
}
"
was
found
in
+
"
the
translation
.
Only
safe
text
-
level
elements
and
elements
with
"
+
"
data
-
l10n
-
name
are
allowed
.
"
)
;
break
;
}
case
DOMOverlays
.
ERROR_NAMED_ELEMENT_MISSING
:
{
console
.
warn
(
An
element
named
"
{
error
.
l10nName
}
"
wasn
'
t
found
in
the
source
.
)
;
break
;
}
case
DOMOverlays
.
ERROR_NAMED_ELEMENT_TYPE_MISMATCH
:
{
console
.
warn
(
An
element
named
"
{
error
.
l10nName
}
"
was
found
in
the
translation
+
but
its
type
{
error
.
translatedElementName
}
didn
'
t
match
the
+
element
found
in
the
source
(
{
error
.
sourceElementName
}
)
.
)
;
break
;
}
default
:
{
console
.
warn
(
Unknown
error
{
error
.
code
}
happend
while
translation
an
element
.
)
;
}
}
}
}
class
DOMLocalization
extends
Localization
{
constructor
(
resourceIds
generateBundles
)
{
super
(
resourceIds
generateBundles
)
;
this
.
roots
=
new
Set
(
)
;
this
.
pendingrAF
=
null
;
this
.
pendingElements
=
new
Set
(
)
;
this
.
windowElement
=
null
;
this
.
mutationObserver
=
null
;
this
.
observerConfig
=
{
attribute
:
true
characterData
:
false
childList
:
true
subtree
:
true
attributeFilter
:
[
L10NID_ATTR_NAME
L10NARGS_ATTR_NAME
]
}
;
}
onChange
(
eager
=
false
)
{
super
.
onChange
(
eager
)
;
this
.
translateRoots
(
)
;
}
setAttributes
(
element
id
args
=
null
)
{
if
(
element
.
getAttribute
(
L10NID_ATTR_NAME
)
!
=
=
id
)
{
element
.
setAttribute
(
L10NID_ATTR_NAME
id
)
;
}
if
(
args
)
{
let
argsString
=
JSON
.
stringify
(
args
)
;
if
(
argsString
!
=
=
element
.
getAttribute
(
L10NARGS_ATTR_NAME
)
)
{
element
.
setAttribute
(
L10NARGS_ATTR_NAME
argsString
)
;
}
}
else
{
element
.
removeAttribute
(
L10NARGS_ATTR_NAME
)
;
}
return
element
;
}
getAttributes
(
element
)
{
return
{
id
:
element
.
getAttribute
(
L10NID_ATTR_NAME
)
args
:
JSON
.
parse
(
element
.
getAttribute
(
L10NARGS_ATTR_NAME
)
|
|
null
)
}
;
}
connectRoot
(
newRoot
)
{
if
(
!
newRoot
.
ownerGlobal
)
{
return
;
}
for
(
const
root
of
this
.
roots
)
{
if
(
root
=
=
=
newRoot
|
|
root
.
contains
(
newRoot
)
|
|
newRoot
.
contains
(
root
)
)
{
throw
new
Error
(
"
Cannot
add
a
root
that
overlaps
with
existing
root
.
"
)
;
}
}
if
(
this
.
windowElement
)
{
if
(
this
.
windowElement
!
=
=
newRoot
.
ownerGlobal
)
{
throw
new
Error
(
Cannot
connect
a
root
:
DOMLocalization
already
has
a
root
from
a
different
window
.
)
;
}
}
else
{
this
.
windowElement
=
newRoot
.
ownerGlobal
;
this
.
mutationObserver
=
new
this
.
windowElement
.
MutationObserver
(
mutations
=
>
this
.
translateMutations
(
mutations
)
)
;
}
this
.
roots
.
add
(
newRoot
)
;
this
.
mutationObserver
.
observe
(
newRoot
this
.
observerConfig
)
;
}
disconnectRoot
(
root
)
{
this
.
roots
.
delete
(
root
)
;
this
.
pauseObserving
(
)
;
if
(
this
.
roots
.
size
=
=
=
0
)
{
this
.
mutationObserver
=
null
;
this
.
windowElement
=
null
;
this
.
pendingrAF
=
null
;
this
.
pendingElements
.
clear
(
)
;
return
true
;
}
this
.
resumeObserving
(
)
;
return
false
;
}
translateRoots
(
)
{
if
(
this
.
resourceIds
.
length
=
=
=
0
)
{
return
Promise
.
resolve
(
)
;
}
const
roots
=
Array
.
from
(
this
.
roots
)
;
return
Promise
.
all
(
roots
.
map
(
async
root
=
>
{
await
this
.
translateFragment
(
root
)
;
let
primaryLocale
=
Services
.
locale
.
appLocaleAsBCP47
;
let
direction
=
Services
.
locale
.
isAppLocaleRTL
?
"
rtl
"
:
"
ltr
"
;
root
.
setAttribute
(
"
lang
"
primaryLocale
)
;
root
.
setAttribute
(
root
.
namespaceURI
=
=
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
?
"
localedir
"
:
"
dir
"
direction
)
;
}
)
)
;
}
pauseObserving
(
)
{
if
(
!
this
.
mutationObserver
)
{
return
;
}
this
.
translateMutations
(
this
.
mutationObserver
.
takeRecords
(
)
)
;
this
.
mutationObserver
.
disconnect
(
)
;
}
resumeObserving
(
)
{
if
(
!
this
.
mutationObserver
)
{
return
;
}
for
(
const
root
of
this
.
roots
)
{
this
.
mutationObserver
.
observe
(
root
this
.
observerConfig
)
;
}
}
translateMutations
(
mutations
)
{
for
(
const
mutation
of
mutations
)
{
switch
(
mutation
.
type
)
{
case
"
attributes
"
:
if
(
mutation
.
target
.
hasAttribute
(
"
data
-
l10n
-
id
"
)
)
{
this
.
pendingElements
.
add
(
mutation
.
target
)
;
}
break
;
case
"
childList
"
:
for
(
const
addedNode
of
mutation
.
addedNodes
)
{
if
(
addedNode
.
nodeType
=
=
=
addedNode
.
ELEMENT_NODE
)
{
if
(
addedNode
.
childElementCount
)
{
for
(
const
element
of
this
.
getTranslatables
(
addedNode
)
)
{
this
.
pendingElements
.
add
(
element
)
;
}
}
else
if
(
addedNode
.
hasAttribute
(
L10NID_ATTR_NAME
)
)
{
this
.
pendingElements
.
add
(
addedNode
)
;
}
}
}
break
;
}
}
if
(
this
.
pendingElements
.
size
>
0
)
{
if
(
this
.
pendingrAF
=
=
=
null
)
{
this
.
pendingrAF
=
this
.
windowElement
.
requestAnimationFrame
(
(
)
=
>
{
this
.
translateElements
(
Array
.
from
(
this
.
pendingElements
)
.
filter
(
elem
=
>
elem
.
hasAttribute
(
"
data
-
l10n
-
id
"
)
)
)
;
this
.
pendingElements
.
clear
(
)
;
this
.
pendingrAF
=
null
;
}
)
;
}
}
}
translateFragment
(
frag
)
{
if
(
frag
.
localize
)
{
const
getTranslationsForItems
=
async
l10nItems
=
>
{
const
keys
=
l10nItems
.
map
(
l10nItem
=
>
(
{
id
:
l10nItem
.
l10nId
args
:
l10nItem
.
l10nArgs
}
)
)
;
const
translations
=
await
this
.
formatMessages
(
keys
)
;
this
.
pauseObserving
(
)
;
return
translations
;
}
;
return
frag
.
localize
(
getTranslationsForItems
.
bind
(
this
)
)
.
then
(
(
errors
)
=
>
{
if
(
errors
)
{
reportDOMOverlayErrors
(
errors
)
;
}
this
.
resumeObserving
(
)
;
}
)
.
catch
(
e
=
>
{
this
.
resumeObserving
(
)
;
throw
e
;
}
)
;
}
return
this
.
translateElements
(
this
.
getTranslatables
(
frag
)
)
;
}
async
translateElements
(
elements
)
{
if
(
!
elements
.
length
)
{
return
undefined
;
}
for
(
let
element
of
elements
)
{
this
.
pendingElements
.
delete
(
element
)
;
}
const
keys
=
elements
.
map
(
this
.
getKeysForElement
)
;
const
translations
=
await
this
.
formatMessages
(
keys
)
;
return
this
.
applyTranslations
(
elements
translations
)
;
}
applyTranslations
(
elements
translations
)
{
this
.
pauseObserving
(
)
;
const
errors
=
[
]
;
for
(
let
i
=
0
;
i
<
elements
.
length
;
i
+
+
)
{
if
(
translations
[
i
]
!
=
=
undefined
)
{
const
translationErrors
=
DOMOverlays
.
translateElement
(
elements
[
i
]
translations
[
i
]
)
;
if
(
translationErrors
)
{
errors
.
push
(
.
.
.
translationErrors
)
;
}
}
}
if
(
errors
.
length
)
{
reportDOMOverlayErrors
(
errors
)
;
}
this
.
resumeObserving
(
)
;
}
getTranslatables
(
element
)
{
const
nodes
=
Array
.
from
(
element
.
querySelectorAll
(
L10N_ELEMENT_QUERY
)
)
;
if
(
typeof
element
.
hasAttribute
=
=
=
"
function
"
&
&
element
.
hasAttribute
(
L10NID_ATTR_NAME
)
)
{
nodes
.
push
(
element
)
;
}
return
nodes
;
}
getKeysForElement
(
element
)
{
return
{
id
:
element
.
getAttribute
(
L10NID_ATTR_NAME
)
args
:
JSON
.
parse
(
element
.
getAttribute
(
L10NARGS_ATTR_NAME
)
|
|
null
)
}
;
}
}
var
getDOMLocalization
=
(
)
=
>
new
DOMLocalization
(
)
;
var
EXPORTED_SYMBOLS
=
[
"
DOMLocalization
"
"
getDOMLocalization
"
]
;
