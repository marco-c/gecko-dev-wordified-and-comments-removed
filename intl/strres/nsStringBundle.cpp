#
include
"
nsStringBundle
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsStringBundleService
.
h
"
#
include
"
nsArrayEnumerator
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsTextFormatter
.
h
"
#
include
"
nsErrorService
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsPersistentProperties
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsSimpleEnumerator
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
URLPreloader
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
SharedStringMap
.
h
"
#
ifdef
ASYNC_LOADING
#
include
"
nsIBinaryInputStream
.
h
"
#
include
"
nsIStringStream
.
h
"
#
endif
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
ContentParent
;
using
mozilla
:
:
dom
:
:
StringBundleDescriptor
;
using
mozilla
:
:
dom
:
:
ipc
:
:
SharedStringMap
;
using
mozilla
:
:
dom
:
:
ipc
:
:
SharedStringMapBuilder
;
using
mozilla
:
:
ipc
:
:
FileDescriptor
;
static
const
char
kContentBundles
[
]
[
52
]
=
{
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
"
chrome
:
/
/
global
/
locale
/
commonDialogs
.
properties
"
"
chrome
:
/
/
global
/
locale
/
css
.
properties
"
"
chrome
:
/
/
global
/
locale
/
dom
/
dom
.
properties
"
"
chrome
:
/
/
global
/
locale
/
layout
/
HtmlForm
.
properties
"
"
chrome
:
/
/
global
/
locale
/
layout
/
htmlparser
.
properties
"
"
chrome
:
/
/
global
/
locale
/
layout_errors
.
properties
"
"
chrome
:
/
/
global
/
locale
/
mathml
/
mathml
.
properties
"
"
chrome
:
/
/
global
/
locale
/
printing
.
properties
"
"
chrome
:
/
/
global
/
locale
/
security
/
csp
.
properties
"
"
chrome
:
/
/
global
/
locale
/
security
/
security
.
properties
"
"
chrome
:
/
/
global
/
locale
/
svg
/
svg
.
properties
"
"
chrome
:
/
/
global
/
locale
/
xul
.
properties
"
"
chrome
:
/
/
necko
/
locale
/
necko
.
properties
"
}
;
static
bool
IsContentBundle
(
const
nsCString
&
aUrl
)
{
size_t
index
;
return
BinarySearchIf
(
kContentBundles
0
MOZ_ARRAY_LENGTH
(
kContentBundles
)
[
&
]
(
const
char
*
aElem
)
{
return
aUrl
.
Compare
(
aElem
)
;
}
&
index
)
;
}
namespace
{
#
define
STRINGBUNDLEPROXY_IID
\
{
\
0x537cf21b
0x99fc
0x4002
{
\
0x9e
0xec
0x97
0xbe
0x4d
0xe0
0xb3
0xdc
\
}
\
}
class
StringBundleProxy
:
public
nsIStringBundle
{
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECLARE_STATIC_IID_ACCESSOR
(
STRINGBUNDLEPROXY_IID
)
explicit
StringBundleProxy
(
already_AddRefed
<
nsIStringBundle
>
aTarget
)
:
mMutex
(
"
StringBundleProxy
:
:
mMutex
"
)
mTarget
(
aTarget
)
{
}
NS_FORWARD_NSISTRINGBUNDLE
(
Target
(
)
-
>
)
;
void
Retarget
(
nsIStringBundle
*
aTarget
)
{
MutexAutoLock
automon
(
mMutex
)
;
mTarget
=
aTarget
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
;
}
size_t
SizeOfIncludingThisIfUnshared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
mRefCnt
=
=
1
?
SizeOfIncludingThis
(
aMallocSizeOf
)
:
0
;
}
protected
:
virtual
~
StringBundleProxy
(
)
=
default
;
private
:
Mutex
mMutex
;
nsCOMPtr
<
nsIStringBundle
>
mTarget
;
nsCOMPtr
<
nsIStringBundle
>
Target
(
)
{
MutexAutoLock
automon
(
mMutex
)
;
return
mTarget
;
}
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
StringBundleProxy
STRINGBUNDLEPROXY_IID
)
NS_IMPL_ISUPPORTS
(
StringBundleProxy
nsIStringBundle
StringBundleProxy
)
#
define
SHAREDSTRINGBUNDLE_IID
\
{
\
0x7a8df5f7
0x9e50
0x44f6
{
\
0xbf
0x89
0xc7
0xad
0x6c
0x17
0xf8
0x5f
\
}
\
}
class
SharedStringBundle
final
:
public
nsStringBundleBase
{
public
:
void
SetMapFile
(
const
FileDescriptor
&
aFile
size_t
aSize
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECLARE_STATIC_IID_ACCESSOR
(
SHAREDSTRINGBUNDLE_IID
)
nsresult
LoadProperties
(
)
override
;
FileDescriptor
CloneFileDescriptor
(
)
const
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
mMapFile
.
isSome
(
)
)
{
return
mMapFile
.
ref
(
)
;
}
return
mStringMap
-
>
CloneFileDescriptor
(
)
;
}
size_t
MapSize
(
)
const
{
if
(
mMapFile
.
isSome
(
)
)
{
return
mMapSize
;
}
if
(
mStringMap
)
{
return
mStringMap
-
>
MapSize
(
)
;
}
return
0
;
}
bool
Initialized
(
)
const
{
return
mStringMap
|
|
mMapFile
.
isSome
(
)
;
}
StringBundleDescriptor
GetDescriptor
(
)
const
{
MOZ_ASSERT
(
Initialized
(
)
)
;
StringBundleDescriptor
descriptor
;
descriptor
.
bundleURL
(
)
=
BundleURL
(
)
;
descriptor
.
mapFile
(
)
=
CloneFileDescriptor
(
)
;
descriptor
.
mapSize
(
)
=
MapSize
(
)
;
return
descriptor
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
static
SharedStringBundle
*
Cast
(
nsIStringBundle
*
aStringBundle
)
{
return
static_cast
<
SharedStringBundle
*
>
(
aStringBundle
)
;
}
protected
:
friend
class
nsStringBundleBase
;
explicit
SharedStringBundle
(
const
char
*
aURLSpec
)
:
nsStringBundleBase
(
aURLSpec
)
{
}
~
SharedStringBundle
(
)
override
=
default
;
nsresult
GetStringImpl
(
const
nsACString
&
aName
nsAString
&
aResult
)
override
;
nsresult
GetSimpleEnumerationImpl
(
nsISimpleEnumerator
*
*
elements
)
override
;
private
:
RefPtr
<
SharedStringMap
>
mStringMap
;
Maybe
<
FileDescriptor
>
mMapFile
;
size_t
mMapSize
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
SharedStringBundle
SHAREDSTRINGBUNDLE_IID
)
class
StringMapEnumerator
final
:
public
nsSimpleEnumerator
{
public
:
NS_DECL_NSISIMPLEENUMERATOR
explicit
StringMapEnumerator
(
SharedStringMap
*
aStringMap
)
:
mStringMap
(
aStringMap
)
{
}
const
nsID
&
DefaultInterface
(
)
override
{
return
NS_GET_IID
(
nsIPropertyElement
)
;
}
protected
:
virtual
~
StringMapEnumerator
(
)
=
default
;
private
:
RefPtr
<
SharedStringMap
>
mStringMap
;
uint32_t
mIndex
=
0
;
}
;
template
<
typename
T
typename
.
.
.
Args
>
already_AddRefed
<
T
>
MakeBundle
(
Args
.
.
.
args
)
{
return
nsStringBundleBase
:
:
Create
<
T
>
(
args
.
.
.
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
RefPtr
<
T
>
MakeBundleRefPtr
(
Args
.
.
.
args
)
{
return
nsStringBundleBase
:
:
Create
<
T
>
(
args
.
.
.
)
;
}
}
NS_IMPL_ISUPPORTS
(
nsStringBundleBase
nsIStringBundle
nsIMemoryReporter
)
NS_IMPL_ISUPPORTS_INHERITED0
(
nsStringBundle
nsStringBundleBase
)
NS_IMPL_ISUPPORTS_INHERITED
(
SharedStringBundle
nsStringBundleBase
SharedStringBundle
)
nsStringBundleBase
:
:
nsStringBundleBase
(
const
char
*
aURLSpec
)
:
mPropertiesURL
(
aURLSpec
)
mMutex
(
"
nsStringBundle
.
mMutex
"
)
mAttemptedLoad
(
false
)
mLoaded
(
false
)
{
}
nsStringBundleBase
:
:
~
nsStringBundleBase
(
)
{
UnregisterWeakMemoryReporter
(
this
)
;
}
void
nsStringBundleBase
:
:
RegisterMemoryReporter
(
)
{
RegisterWeakMemoryReporter
(
this
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
already_AddRefed
<
T
>
nsStringBundleBase
:
:
Create
(
Args
.
.
.
args
)
{
RefPtr
<
T
>
bundle
=
new
T
(
args
.
.
.
)
;
bundle
-
>
RegisterMemoryReporter
(
)
;
return
bundle
.
forget
(
)
;
}
nsStringBundle
:
:
nsStringBundle
(
const
char
*
aURLSpec
)
:
nsStringBundleBase
(
aURLSpec
)
{
}
nsStringBundle
:
:
~
nsStringBundle
(
)
=
default
;
NS_IMETHODIMP
nsStringBundleBase
:
:
AsyncPreload
(
)
{
return
NS_DispatchToCurrentThreadQueue
(
NewIdleRunnableMethod
(
"
nsStringBundleBase
:
:
LoadProperties
"
this
&
nsStringBundleBase
:
:
LoadProperties
)
EventQueuePriority
:
:
Idle
)
;
}
size_t
nsStringBundle
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
if
(
mProps
)
{
n
+
=
mProps
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
aMallocSizeOf
(
this
)
+
n
;
}
size_t
nsStringBundleBase
:
:
SizeOfIncludingThisIfUnshared
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
if
(
mRefCnt
=
=
1
)
{
return
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
else
{
return
0
;
}
}
size_t
SharedStringBundle
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
if
(
mStringMap
)
{
n
+
=
aMallocSizeOf
(
mStringMap
)
;
}
return
aMallocSizeOf
(
this
)
+
n
;
}
NS_IMETHODIMP
nsStringBundleBase
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
nsAutoCStringN
<
64
>
escapedURL
(
mPropertiesURL
)
;
escapedURL
.
ReplaceChar
(
'
/
'
'
\
\
'
)
;
size_t
sharedSize
=
0
;
size_t
heapSize
=
SizeOfIncludingThis
(
MallocSizeOf
)
;
nsAutoCStringN
<
256
>
path
(
"
explicit
/
string
-
bundles
/
"
)
;
if
(
RefPtr
<
SharedStringBundle
>
shared
=
do_QueryObject
(
this
)
)
{
path
.
AppendLiteral
(
"
SharedStringBundle
"
)
;
if
(
XRE_IsParentProcess
(
)
)
{
sharedSize
=
shared
-
>
MapSize
(
)
;
}
}
else
{
path
.
AppendLiteral
(
"
nsStringBundle
"
)
;
}
path
.
AppendLiteral
(
"
(
url
=
\
"
"
)
;
path
.
Append
(
escapedURL
)
;
path
.
AppendLiteral
(
"
\
"
shared
=
"
)
;
path
.
AppendASCII
(
mRefCnt
>
2
?
"
true
"
:
"
false
"
)
;
path
.
AppendLiteral
(
"
refCount
=
"
)
;
path
.
AppendInt
(
uint32_t
(
mRefCnt
-
1
)
)
;
if
(
sharedSize
)
{
path
.
AppendLiteral
(
"
sharedMemorySize
=
"
)
;
path
.
AppendInt
(
uint32_t
(
sharedSize
)
)
;
}
path
.
AppendLiteral
(
"
)
"
)
;
constexpr
auto
desc
=
"
A
StringBundle
instance
representing
the
data
in
a
(
probably
"
"
localized
)
.
properties
file
.
Data
may
be
shared
between
"
"
processes
.
"
_ns
;
aHandleReport
-
>
Callback
(
"
"
_ns
path
KIND_HEAP
UNITS_BYTES
heapSize
desc
aData
)
;
if
(
sharedSize
)
{
path
.
ReplaceLiteral
(
0
sizeof
(
"
explicit
/
"
)
-
1
"
shared
-
"
)
;
aHandleReport
-
>
Callback
(
"
"
_ns
path
KIND_OTHER
UNITS_BYTES
sharedSize
desc
aData
)
;
}
return
NS_OK
;
}
nsresult
nsStringBundleBase
:
:
ParseProperties
(
nsIPersistentProperties
*
*
aProps
)
{
if
(
mAttemptedLoad
)
{
if
(
mLoaded
)
return
NS_OK
;
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
String
bundles
must
be
initialized
on
the
main
thread
"
"
before
they
may
be
used
off
-
main
-
thread
"
)
;
mAttemptedLoad
=
true
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
mPropertiesURL
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCString
scheme
;
uri
-
>
GetScheme
(
scheme
)
;
if
(
!
scheme
.
EqualsLiteral
(
"
chrome
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
jar
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
resource
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
file
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
data
"
)
)
{
return
NS_ERROR_ABORT
;
}
nsCOMPtr
<
nsIInputStream
>
in
;
auto
result
=
URLPreloader
:
:
ReadURI
(
uri
)
;
if
(
result
.
isOk
(
)
)
{
MOZ_TRY
(
NS_NewCStringInputStream
(
getter_AddRefs
(
in
)
result
.
unwrap
(
)
)
)
;
}
else
{
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
uri
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
channel
-
>
SetContentType
(
"
text
/
plain
"
_ns
)
;
rv
=
channel
-
>
Open
(
getter_AddRefs
(
in
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
auto
props
=
MakeRefPtr
<
nsPersistentProperties
>
(
)
;
mAttemptedLoad
=
true
;
MOZ_TRY
(
props
-
>
Load
(
in
)
)
;
props
.
forget
(
aProps
)
;
mLoaded
=
true
;
return
NS_OK
;
}
nsresult
nsStringBundle
:
:
LoadProperties
(
)
{
if
(
PastShutdownPhase
(
ShutdownPhase
:
:
XPCOMShutdown
)
)
{
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
if
(
mProps
)
{
return
NS_OK
;
}
return
ParseProperties
(
getter_AddRefs
(
mProps
)
)
;
}
nsresult
SharedStringBundle
:
:
LoadProperties
(
)
{
if
(
mStringMap
)
return
NS_OK
;
if
(
mMapFile
.
isSome
(
)
)
{
mStringMap
=
new
SharedStringMap
(
mMapFile
.
ref
(
)
mMapSize
)
;
mMapFile
.
reset
(
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
String
bundles
must
be
initialized
on
the
main
thread
"
"
before
they
may
be
used
off
-
main
-
thread
"
)
;
if
(
PastShutdownPhase
(
ShutdownPhase
:
:
XPCOMShutdown
)
)
{
return
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
}
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIPersistentProperties
>
props
;
MOZ_TRY
(
ParseProperties
(
getter_AddRefs
(
props
)
)
)
;
SharedStringMapBuilder
builder
;
nsCOMPtr
<
nsISimpleEnumerator
>
iter
;
MOZ_TRY
(
props
-
>
Enumerate
(
getter_AddRefs
(
iter
)
)
)
;
bool
hasMore
;
while
(
NS_SUCCEEDED
(
iter
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
next
;
MOZ_TRY
(
iter
-
>
GetNext
(
getter_AddRefs
(
next
)
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPropertyElement
>
elem
=
do_QueryInterface
(
next
&
rv
)
;
MOZ_TRY
(
rv
)
;
nsCString
key
;
nsString
value
;
MOZ_TRY
(
elem
-
>
GetKey
(
key
)
)
;
MOZ_TRY
(
elem
-
>
GetValue
(
value
)
)
;
builder
.
Add
(
key
value
)
;
}
mStringMap
=
new
SharedStringMap
(
std
:
:
move
(
builder
)
)
;
ContentParent
:
:
BroadcastStringBundle
(
GetDescriptor
(
)
)
;
return
NS_OK
;
}
void
SharedStringBundle
:
:
SetMapFile
(
const
FileDescriptor
&
aFile
size_t
aSize
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
mStringMap
=
nullptr
;
mMapFile
.
emplace
(
aFile
)
;
mMapSize
=
aSize
;
}
NS_IMETHODIMP
nsStringBundleBase
:
:
GetStringFromID
(
int32_t
aID
nsAString
&
aResult
)
{
nsAutoCString
idStr
;
idStr
.
AppendInt
(
aID
10
)
;
return
GetStringFromName
(
idStr
.
get
(
)
aResult
)
;
}
NS_IMETHODIMP
nsStringBundleBase
:
:
GetStringFromAUTF8Name
(
const
nsACString
&
aName
nsAString
&
aResult
)
{
return
GetStringFromName
(
PromiseFlatCString
(
aName
)
.
get
(
)
aResult
)
;
}
NS_IMETHODIMP
nsStringBundleBase
:
:
GetStringFromName
(
const
char
*
aName
nsAString
&
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aName
)
;
MutexAutoLock
autolock
(
mMutex
)
;
return
GetStringImpl
(
nsDependentCString
(
aName
)
aResult
)
;
}
nsresult
nsStringBundle
:
:
GetStringImpl
(
const
nsACString
&
aName
nsAString
&
aResult
)
{
MOZ_TRY
(
LoadProperties
(
)
)
;
return
mProps
-
>
GetStringProperty
(
aName
aResult
)
;
}
nsresult
SharedStringBundle
:
:
GetStringImpl
(
const
nsACString
&
aName
nsAString
&
aResult
)
{
MOZ_TRY
(
LoadProperties
(
)
)
;
if
(
mStringMap
-
>
Get
(
PromiseFlatCString
(
aName
)
aResult
)
)
{
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsStringBundleBase
:
:
FormatStringFromID
(
int32_t
aID
const
nsTArray
<
nsString
>
&
aParams
nsAString
&
aResult
)
{
nsAutoCString
idStr
;
idStr
.
AppendInt
(
aID
10
)
;
return
FormatStringFromName
(
idStr
.
get
(
)
aParams
aResult
)
;
}
NS_IMETHODIMP
nsStringBundleBase
:
:
FormatStringFromAUTF8Name
(
const
nsACString
&
aName
const
nsTArray
<
nsString
>
&
aParams
nsAString
&
aResult
)
{
return
FormatStringFromName
(
PromiseFlatCString
(
aName
)
.
get
(
)
aParams
aResult
)
;
}
NS_IMETHODIMP
nsStringBundleBase
:
:
FormatStringFromName
(
const
char
*
aName
const
nsTArray
<
nsString
>
&
aParams
nsAString
&
aResult
)
{
NS_ASSERTION
(
!
aParams
.
IsEmpty
(
)
"
FormatStringFromName
(
)
without
format
parameters
:
use
"
"
GetStringFromName
(
)
instead
"
)
;
nsAutoString
formatStr
;
nsresult
rv
=
GetStringFromName
(
aName
formatStr
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
FormatString
(
formatStr
.
get
(
)
aParams
aResult
)
;
}
NS_IMETHODIMP
nsStringBundleBase
:
:
GetSimpleEnumeration
(
nsISimpleEnumerator
*
*
aElements
)
{
NS_ENSURE_ARG_POINTER
(
aElements
)
;
return
GetSimpleEnumerationImpl
(
aElements
)
;
}
nsresult
nsStringBundle
:
:
GetSimpleEnumerationImpl
(
nsISimpleEnumerator
*
*
elements
)
{
MOZ_TRY
(
LoadProperties
(
)
)
;
return
mProps
-
>
Enumerate
(
elements
)
;
}
nsresult
SharedStringBundle
:
:
GetSimpleEnumerationImpl
(
nsISimpleEnumerator
*
*
aEnumerator
)
{
MOZ_TRY
(
LoadProperties
(
)
)
;
auto
iter
=
MakeRefPtr
<
StringMapEnumerator
>
(
mStringMap
)
;
iter
.
forget
(
aEnumerator
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StringMapEnumerator
:
:
HasMoreElements
(
bool
*
aHasMore
)
{
*
aHasMore
=
mIndex
<
mStringMap
-
>
Count
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StringMapEnumerator
:
:
GetNext
(
nsISupports
*
*
aNext
)
{
if
(
mIndex
>
=
mStringMap
-
>
Count
(
)
)
{
return
NS_ERROR_FAILURE
;
}
auto
elem
=
MakeRefPtr
<
nsPropertyElement
>
(
mStringMap
-
>
GetKeyAt
(
mIndex
)
mStringMap
-
>
GetValueAt
(
mIndex
)
)
;
elem
.
forget
(
aNext
)
;
mIndex
+
+
;
return
NS_OK
;
}
nsresult
nsStringBundleBase
:
:
FormatString
(
const
char16_t
*
aFormatStr
const
nsTArray
<
nsString
>
&
aParams
nsAString
&
aResult
)
{
auto
length
=
aParams
.
Length
(
)
;
NS_ENSURE_ARG
(
length
<
=
10
)
;
nsTextFormatter
:
:
ssprintf
(
aResult
aFormatStr
length
>
=
1
?
aParams
[
0
]
.
get
(
)
:
nullptr
length
>
=
2
?
aParams
[
1
]
.
get
(
)
:
nullptr
length
>
=
3
?
aParams
[
2
]
.
get
(
)
:
nullptr
length
>
=
4
?
aParams
[
3
]
.
get
(
)
:
nullptr
length
>
=
5
?
aParams
[
4
]
.
get
(
)
:
nullptr
length
>
=
6
?
aParams
[
5
]
.
get
(
)
:
nullptr
length
>
=
7
?
aParams
[
6
]
.
get
(
)
:
nullptr
length
>
=
8
?
aParams
[
7
]
.
get
(
)
:
nullptr
length
>
=
9
?
aParams
[
8
]
.
get
(
)
:
nullptr
length
>
=
10
?
aParams
[
9
]
.
get
(
)
:
nullptr
)
;
return
NS_OK
;
}
#
define
MAX_CACHED_BUNDLES
16
struct
bundleCacheEntry_t
final
:
public
LinkedListElement
<
bundleCacheEntry_t
>
{
nsCString
mHashKey
;
nsCOMPtr
<
nsIStringBundle
>
mBundle
;
MOZ_COUNTED_DEFAULT_CTOR
(
bundleCacheEntry_t
)
MOZ_COUNTED_DTOR
(
bundleCacheEntry_t
)
}
;
nsStringBundleService
:
:
nsStringBundleService
(
)
:
mBundleMap
(
MAX_CACHED_BUNDLES
)
{
mErrorService
=
nsErrorService
:
:
GetOrCreate
(
)
;
MOZ_ALWAYS_TRUE
(
mErrorService
)
;
}
NS_IMPL_ISUPPORTS
(
nsStringBundleService
nsIStringBundleService
nsIObserver
nsISupportsWeakReference
nsIMemoryReporter
)
nsStringBundleService
:
:
~
nsStringBundleService
(
)
{
UnregisterWeakMemoryReporter
(
this
)
;
flushBundleCache
(
false
)
;
}
nsresult
nsStringBundleService
:
:
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
memory
-
pressure
"
true
)
;
os
-
>
AddObserver
(
this
"
profile
-
do
-
change
"
true
)
;
os
-
>
AddObserver
(
this
"
chrome
-
flush
-
caches
"
true
)
;
os
-
>
AddObserver
(
this
"
intl
:
app
-
locales
-
changed
"
true
)
;
}
RegisterWeakMemoryReporter
(
this
)
;
return
NS_OK
;
}
size_t
nsStringBundleService
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
mBundleMap
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mBundleMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
aMallocSizeOf
(
iter
.
Data
(
)
)
;
n
+
=
iter
.
Data
(
)
-
>
mHashKey
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
return
aMallocSizeOf
(
this
)
+
n
;
}
NS_IMETHODIMP
nsStringBundleService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aSomeData
)
{
if
(
strcmp
(
"
profile
-
do
-
change
"
aTopic
)
=
=
0
|
|
strcmp
(
"
chrome
-
flush
-
caches
"
aTopic
)
=
=
0
|
|
strcmp
(
"
intl
:
app
-
locales
-
changed
"
aTopic
)
=
=
0
)
{
flushBundleCache
(
false
)
;
}
else
if
(
strcmp
(
"
memory
-
pressure
"
aTopic
)
=
=
0
)
{
flushBundleCache
(
true
)
;
}
return
NS_OK
;
}
void
nsStringBundleService
:
:
flushBundleCache
(
bool
ignoreShared
)
{
LinkedList
<
bundleCacheEntry_t
>
newList
;
while
(
!
mBundleCache
.
isEmpty
(
)
)
{
UniquePtr
<
bundleCacheEntry_t
>
entry
(
mBundleCache
.
popFirst
(
)
)
;
auto
*
bundle
=
nsStringBundleBase
:
:
Cast
(
entry
-
>
mBundle
)
;
if
(
ignoreShared
&
&
bundle
-
>
IsShared
(
)
)
{
newList
.
insertBack
(
entry
.
release
(
)
)
;
}
else
{
mBundleMap
.
Remove
(
entry
-
>
mHashKey
)
;
}
}
mBundleCache
=
std
:
:
move
(
newList
)
;
}
NS_IMETHODIMP
nsStringBundleService
:
:
FlushBundles
(
)
{
flushBundleCache
(
false
)
;
return
NS_OK
;
}
void
nsStringBundleService
:
:
SendContentBundles
(
ContentParent
*
aContentParent
)
const
{
nsTArray
<
StringBundleDescriptor
>
bundles
;
for
(
auto
*
entry
:
mSharedBundles
)
{
auto
bundle
=
SharedStringBundle
:
:
Cast
(
entry
-
>
mBundle
)
;
if
(
bundle
-
>
Initialized
(
)
)
{
bundles
.
AppendElement
(
bundle
-
>
GetDescriptor
(
)
)
;
}
}
Unused
<
<
aContentParent
-
>
SendRegisterStringBundles
(
std
:
:
move
(
bundles
)
)
;
}
void
nsStringBundleService
:
:
RegisterContentBundle
(
const
nsCString
&
aBundleURL
const
FileDescriptor
&
aMapFile
size_t
aMapSize
)
{
RefPtr
<
StringBundleProxy
>
proxy
;
bundleCacheEntry_t
*
cacheEntry
=
mBundleMap
.
Get
(
aBundleURL
)
;
if
(
cacheEntry
)
{
if
(
RefPtr
<
SharedStringBundle
>
shared
=
do_QueryObject
(
cacheEntry
-
>
mBundle
)
)
{
return
;
}
proxy
=
do_QueryObject
(
cacheEntry
-
>
mBundle
)
;
MOZ_ASSERT
(
proxy
)
;
cacheEntry
-
>
remove
(
)
;
delete
cacheEntry
;
}
auto
bundle
=
MakeBundleRefPtr
<
SharedStringBundle
>
(
aBundleURL
.
get
(
)
)
;
bundle
-
>
SetMapFile
(
aMapFile
aMapSize
)
;
if
(
proxy
)
{
proxy
-
>
Retarget
(
bundle
)
;
}
cacheEntry
=
insertIntoCache
(
bundle
.
forget
(
)
aBundleURL
)
;
mSharedBundles
.
insertBack
(
cacheEntry
)
;
}
void
nsStringBundleService
:
:
getStringBundle
(
const
char
*
aURLSpec
nsIStringBundle
*
*
aResult
)
{
nsDependentCString
key
(
aURLSpec
)
;
bundleCacheEntry_t
*
cacheEntry
=
mBundleMap
.
Get
(
key
)
;
RefPtr
<
SharedStringBundle
>
shared
;
if
(
cacheEntry
)
{
cacheEntry
-
>
remove
(
)
;
shared
=
do_QueryObject
(
cacheEntry
-
>
mBundle
)
;
}
else
{
nsCOMPtr
<
nsIStringBundle
>
bundle
;
bool
isContent
=
IsContentBundle
(
key
)
;
if
(
!
isContent
|
|
!
XRE_IsParentProcess
(
)
)
{
bundle
=
MakeBundle
<
nsStringBundle
>
(
aURLSpec
)
;
}
if
(
isContent
)
{
if
(
XRE_IsParentProcess
(
)
)
{
shared
=
MakeBundle
<
SharedStringBundle
>
(
aURLSpec
)
;
bundle
=
shared
;
}
else
{
bundle
=
new
StringBundleProxy
(
bundle
.
forget
(
)
)
;
}
}
cacheEntry
=
insertIntoCache
(
bundle
.
forget
(
)
key
)
;
}
if
(
shared
)
{
mSharedBundles
.
insertBack
(
cacheEntry
)
;
}
else
{
mBundleCache
.
insertBack
(
cacheEntry
)
;
}
*
aResult
=
cacheEntry
-
>
mBundle
;
NS_ADDREF
(
*
aResult
)
;
}
UniquePtr
<
bundleCacheEntry_t
>
nsStringBundleService
:
:
evictOneEntry
(
)
{
for
(
auto
*
entry
:
mBundleCache
)
{
auto
*
bundle
=
nsStringBundleBase
:
:
Cast
(
entry
-
>
mBundle
)
;
if
(
!
bundle
-
>
IsShared
(
)
)
{
entry
-
>
remove
(
)
;
mBundleMap
.
Remove
(
entry
-
>
mHashKey
)
;
return
UniquePtr
<
bundleCacheEntry_t
>
(
entry
)
;
}
}
return
nullptr
;
}
bundleCacheEntry_t
*
nsStringBundleService
:
:
insertIntoCache
(
already_AddRefed
<
nsIStringBundle
>
aBundle
const
nsACString
&
aHashKey
)
{
UniquePtr
<
bundleCacheEntry_t
>
cacheEntry
;
if
(
mBundleMap
.
Count
(
)
>
=
MAX_CACHED_BUNDLES
)
{
cacheEntry
=
evictOneEntry
(
)
;
}
if
(
!
cacheEntry
)
{
cacheEntry
.
reset
(
new
bundleCacheEntry_t
(
)
)
;
}
cacheEntry
-
>
mHashKey
=
aHashKey
;
cacheEntry
-
>
mBundle
=
aBundle
;
mBundleMap
.
InsertOrUpdate
(
cacheEntry
-
>
mHashKey
cacheEntry
.
get
(
)
)
;
return
cacheEntry
.
release
(
)
;
}
NS_IMETHODIMP
nsStringBundleService
:
:
CreateBundle
(
const
char
*
aURLSpec
nsIStringBundle
*
*
aResult
)
{
getStringBundle
(
aURLSpec
aResult
)
;
return
NS_OK
;
}
#
define
GLOBAL_PROPERTIES
"
chrome
:
/
/
global
/
locale
/
global
-
strres
.
properties
"
nsresult
nsStringBundleService
:
:
FormatWithBundle
(
nsIStringBundle
*
bundle
nsresult
aStatus
const
nsTArray
<
nsString
>
&
argArray
nsAString
&
result
)
{
nsresult
rv
;
uint16_t
code
=
NS_ERROR_GET_CODE
(
aStatus
)
;
rv
=
bundle
-
>
FormatStringFromID
(
code
argArray
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
AutoTArray
<
nsString
1
>
otherArgArray
;
otherArgArray
.
AppendElement
(
)
-
>
AppendInt
(
static_cast
<
uint32_t
>
(
aStatus
)
16
)
;
uint16_t
code
=
NS_ERROR_GET_CODE
(
NS_ERROR_FAILURE
)
;
rv
=
bundle
-
>
FormatStringFromID
(
code
otherArgArray
result
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsStringBundleService
:
:
FormatStatusMessage
(
nsresult
aStatus
const
char16_t
*
aStatusArg
nsAString
&
result
)
{
nsresult
rv
;
uint32_t
i
argCount
=
0
;
nsCOMPtr
<
nsIStringBundle
>
bundle
;
nsCString
stringBundleURL
;
if
(
aStatus
=
=
NS_OK
&
&
aStatusArg
)
{
result
.
Assign
(
aStatusArg
)
;
return
NS_OK
;
}
if
(
aStatus
=
=
NS_OK
)
{
return
NS_ERROR_FAILURE
;
}
const
nsDependentString
args
(
aStatusArg
)
;
argCount
=
args
.
CountChar
(
char16_t
(
'
\
n
'
)
)
+
1
;
NS_ENSURE_ARG
(
argCount
<
=
10
)
;
AutoTArray
<
nsString
10
>
argArray
;
if
(
argCount
=
=
1
)
{
argArray
.
AppendElement
(
aStatusArg
)
;
}
else
if
(
argCount
>
1
)
{
int32_t
offset
=
0
;
for
(
i
=
0
;
i
<
argCount
;
i
+
+
)
{
int32_t
pos
=
args
.
FindChar
(
'
\
n
'
offset
)
;
if
(
pos
=
=
-
1
)
pos
=
args
.
Length
(
)
;
argArray
.
AppendElement
(
Substring
(
args
offset
pos
-
offset
)
)
;
offset
=
pos
+
1
;
}
}
rv
=
mErrorService
-
>
GetErrorStringBundle
(
NS_ERROR_GET_MODULE
(
aStatus
)
getter_Copies
(
stringBundleURL
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
getStringBundle
(
stringBundleURL
.
get
(
)
getter_AddRefs
(
bundle
)
)
;
rv
=
FormatWithBundle
(
bundle
aStatus
argArray
result
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
getStringBundle
(
GLOBAL_PROPERTIES
getter_AddRefs
(
bundle
)
)
;
rv
=
FormatWithBundle
(
bundle
aStatus
argArray
result
)
;
}
return
rv
;
}
