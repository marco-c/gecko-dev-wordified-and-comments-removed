#
define
TH_UNICODE
#
include
<
stdlib
.
h
>
#
include
<
stdint
.
h
>
#
include
<
assert
.
h
>
#
include
"
th_char
.
h
"
#
define
th_isalpha
(
c
)
(
(
(
c
)
>
=
'
a
'
&
&
(
c
)
<
=
'
z
'
)
|
|
(
(
c
)
>
=
'
A
'
&
&
(
c
)
<
=
'
Z
'
)
)
#
define
th_isspace
(
c
)
(
(
c
)
=
=
'
'
|
|
(
c
)
=
=
'
\
t
'
)
typedef
unsigned
short
twb_t
;
extern
const
twb_t
_TwbType
[
0x100
-
0xa0
]
;
#
define
VRS
0x0001
#
define
VRE
0x0002
#
define
VRX
0x0004
#
define
VRA
0x0008
#
define
VLA
0x0010
#
define
VLO
0x0020
#
define
VLI
0x0040
#
define
VC
0x0080
#
define
CC
0x0100
#
define
CS
0x0200
#
define
C2
0x0400
#
define
CHB
0x0800
#
define
CHE
0x1000
#
define
MT
0x2000
#
define
M
0x4000
#
define
T
0x8000
#
define
VL
(
VLA
|
VLO
|
VLI
)
#
define
VR
(
VRS
|
VRE
|
VRX
)
#
define
NE
(
VL
|
VRS
)
#
define
NB
(
VR
|
M
)
#
define
V
(
VL
|
VR
)
#
define
CX
(
CC
|
CS
)
#
define
C
(
CX
|
VC
)
#
define
A
(
C
|
V
|
M
)
#
define
twbtype
(
c
)
(
_TwbType
[
th_zcode
(
c
)
]
)
#
ifndef
TRUE
#
define
TRUE
1
#
define
FALSE
0
#
endif
#
define
RETURN
(
b
)
return
(
b
)
int
TrbWordBreakPos
(
const
th_char
*
pstr
int
left
const
th_char
*
rstr
int
right
)
{
const
th_char
*
lstr
=
pstr
+
left
;
th_char
_c
[
6
]
;
twb_t
_t
[
6
]
;
#
define
c
(
i
)
(
_c
[
(
i
)
+
3
]
)
#
define
t
(
i
)
(
_t
[
(
i
)
+
3
]
)
int
i
j
;
if
(
left
<
0
)
return
-
1
;
if
(
right
<
1
)
return
-
1
;
c
(
0
)
=
rstr
[
0
]
;
if
(
!
th_isthai
(
c
(
0
)
)
)
return
-
1
;
t
(
0
)
=
twbtype
(
c
(
0
)
)
;
if
(
!
(
t
(
0
)
&
A
)
)
return
-
1
;
if
(
left
>
=
1
)
{
c
(
-
1
)
=
lstr
[
-
1
]
;
if
(
!
th_isthai
(
c
(
-
1
)
)
)
return
0
;
t
(
-
1
)
=
twbtype
(
c
(
-
1
)
)
;
if
(
!
(
t
(
-
1
)
&
A
)
)
return
0
;
}
else
{
c
(
-
1
)
=
0
;
t
(
-
1
)
=
0
;
}
for
(
i
=
1
;
i
<
=
2
;
i
+
+
)
{
if
(
i
>
=
right
)
{
c
(
i
)
=
0
;
t
(
i
)
=
0
;
}
else
{
c
(
i
)
=
rstr
[
i
]
;
if
(
!
th_isthai
(
c
(
i
)
)
)
right
=
i
-
-
;
else
{
t
(
i
)
=
twbtype
(
c
(
i
)
)
;
if
(
!
(
t
(
i
)
&
A
)
)
right
=
i
-
-
;
}
}
}
for
(
i
=
-
2
j
=
-
2
;
i
>
=
-
3
;
j
-
-
)
{
if
(
j
<
-
left
)
{
c
(
i
)
=
0
;
t
(
i
)
=
0
;
i
-
-
;
}
else
{
c
(
i
)
=
lstr
[
j
]
;
if
(
!
th_isthai
(
c
(
i
)
)
)
left
=
0
;
else
{
t
(
i
)
=
(
twb_t
)
(
th_isthai
(
c
(
i
)
)
?
twbtype
(
c
(
i
)
)
:
0
)
;
if
(
!
(
t
(
i
)
&
A
)
)
left
=
0
;
else
{
if
(
(
t
(
i
+
1
)
&
MT
)
&
&
(
(
t
(
i
)
&
VR
)
|
|
(
t
(
i
+
2
)
&
VR
)
)
)
{
c
(
i
+
1
)
=
c
(
i
)
;
t
(
i
+
1
)
=
t
(
i
)
;
}
else
i
-
-
;
}
}
}
}
if
(
(
t
(
-
1
)
&
C
)
&
&
(
t
(
0
)
&
C
)
)
{
if
(
(
t
(
-
1
)
&
CHE
)
|
|
(
t
(
0
)
&
CHB
)
)
return
-
1
;
}
if
(
(
t
(
-
3
)
&
(
VLA
|
VLO
)
)
&
&
(
t
(
-
2
)
&
C
)
&
&
(
c
(
0
)
!
=
TH_SARA_A
)
&
&
(
c
(
-
1
)
=
=
TH_SARA_A
|
|
c
(
-
0
)
=
=
TH_SARA_AA
)
)
return
0
;
if
(
t
(
0
)
&
NB
)
return
-
1
;
if
(
t
(
-
1
)
&
NE
)
return
-
1
;
if
(
t
(
-
1
)
&
VRE
)
{
if
(
c
(
-
2
)
=
=
TH_SARA_AA
&
&
c
(
-
1
)
=
=
TH_SARA_A
)
return
0
;
return
-
1
;
}
if
(
t
(
-
2
)
&
VRE
)
return
-
1
;
if
(
(
t
(
0
)
&
C
)
&
&
(
t
(
1
)
&
(
VR
|
MT
)
)
&
&
(
c
(
2
)
!
=
TH_THANTHAKHAT
)
)
{
if
(
(
t
(
-
1
)
&
(
VRS
|
VRX
)
)
&
&
c
(
1
)
=
=
TH_SARA_I
)
return
-
1
;
if
(
t
(
-
1
)
&
(
V
|
M
)
)
return
0
;
if
(
t
(
-
2
)
&
VRS
)
return
0
;
if
(
!
(
t
(
0
)
&
C2
)
&
&
c
(
1
)
=
=
TH_SARA_I
)
{
if
(
t
(
-
2
)
&
VRX
)
return
0
;
if
(
t
(
-
2
)
&
VC
)
return
0
;
}
}
if
(
(
t
(
-
1
)
&
VRX
)
&
&
(
t
(
0
)
&
CC
)
)
return
0
;
if
(
(
t
(
-
2
)
&
VRS
)
&
&
(
t
(
-
1
)
&
C
)
&
&
(
t
(
0
)
&
(
V
|
M
)
)
)
return
0
;
if
(
(
t
(
0
)
&
CX
)
&
&
(
t
(
1
)
&
C2
)
&
&
(
c
(
2
)
!
=
TH_THANTHAKHAT
)
)
{
if
(
(
t
(
-
2
)
&
A
)
&
&
(
t
(
-
1
)
&
CX
)
)
return
0
;
if
(
(
t
(
-
2
)
&
CX
)
&
&
(
t
(
-
1
)
&
MT
)
)
return
0
;
}
if
(
t
(
0
)
&
VL
)
return
0
;
if
(
t
(
1
)
&
VL
)
return
-
1
;
if
(
c
(
-
1
)
=
=
TH_THANTHAKHAT
&
&
c
(
-
2
)
!
=
TH_RORUA
&
&
c
(
-
2
)
!
=
TH_LOLING
)
return
0
;
if
(
t
(
0
)
&
CHE
)
{
if
(
(
t
(
-
2
)
&
VRS
)
&
&
(
t
(
-
1
)
&
C
)
)
return
0
;
if
(
t
(
-
1
)
&
VC
)
return
0
;
}
if
(
t
(
-
1
)
&
CHB
)
{
if
(
(
t
(
0
)
&
C
)
&
&
(
t
(
1
)
&
VR
)
)
return
0
;
if
(
t
(
0
)
&
VC
)
return
0
;
}
if
(
(
t
(
-
2
)
&
VL
)
&
&
(
t
(
1
)
&
VR
)
)
{
if
(
t
(
-
2
)
&
VLI
)
return
0
;
else
{
if
(
c
(
1
)
=
=
TH_SARA_A
)
return
2
;
if
(
t
(
-
2
)
&
VLO
)
return
0
;
if
(
!
(
t
(
1
)
&
VRA
)
)
return
0
;
}
}
if
(
(
t
(
-
2
)
&
C
)
&
&
(
t
(
-
1
)
&
MT
)
&
&
(
t
(
0
)
&
CX
)
)
return
1
;
return
-
1
;
}
int
TrbFollowing
(
const
th_char
*
begin
int
length
int
offset
)
{
const
th_char
*
w
=
begin
+
offset
;
const
th_char
*
end
=
begin
+
length
;
while
(
w
<
end
&
&
*
w
&
&
!
th_isthai
(
*
w
)
&
&
th_isspace
(
*
w
)
)
w
+
+
;
if
(
w
<
end
&
&
*
w
&
&
!
th_isthai
(
*
w
)
)
{
int
english
=
FALSE
;
while
(
w
<
end
&
&
*
w
&
&
!
th_isthai
(
*
w
)
&
&
!
th_isspace
(
*
w
)
)
{
if
(
th_isalpha
(
*
w
)
)
english
=
TRUE
;
w
+
+
;
}
if
(
english
|
|
w
=
=
end
|
|
(
!
th_isthai
(
*
w
)
&
&
th_isspace
(
*
w
)
)
)
return
w
-
begin
;
}
if
(
w
=
=
end
|
|
*
w
=
=
0
|
|
!
th_isthai
(
*
w
)
)
return
w
-
begin
;
w
+
+
;
if
(
w
<
end
&
&
*
w
&
&
th_isthai
(
*
w
)
)
{
int
brk
=
TrbWordBreakPos
(
begin
w
-
begin
w
end
-
w
)
;
while
(
brk
<
0
)
{
w
+
+
;
if
(
w
=
=
end
|
|
*
w
=
=
0
|
|
!
th_isthai
(
*
w
)
)
break
;
brk
=
TrbWordBreakPos
(
begin
w
-
begin
w
end
-
w
)
;
}
if
(
brk
>
0
)
w
+
=
brk
;
}
if
(
w
<
end
&
&
*
w
&
&
!
th_isthai
(
*
w
)
)
{
while
(
w
<
end
&
&
*
w
&
&
!
th_isthai
(
*
w
)
&
&
!
th_isalpha
(
*
w
)
&
&
!
th_isspace
(
*
w
)
)
w
+
+
;
}
return
w
-
begin
;
}
const
twb_t
_TwbType
[
0x100
-
0xa0
]
=
{
#
if
0
T
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
T
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
#
endif
0
CS
CS
|
CHE
CC
|
CHE
CS
|
CHE
CC
|
CHE
CS
CS
|
CHB
CS
CC
|
CHE
CS
CC
|
CHE
CC
|
CHB
|
CHE
CS
|
CHB
CS
|
CHB
CS
|
CHB
CS
CS
|
CHB
|
CHE
CS
|
CHB
|
CHE
CS
|
CHB
CS
CS
CS
CS
CS
CS
CS
CS
CC
|
CHE
CC
|
CHE
CS
CS
CS
|
CHE
CS
CS
CS
|
C2
|
CHE
VC
|
CHE
CS
|
C2
VC
|
CHE
VC
|
C2
CS
CS
|
CHB
CS
|
CHE
CC
|
CHE
CS
|
CHB
|
CHE
VC
CC
|
CHE
T
VRE
|
VRA
VRS
VRX
|
VRA
VRE
VRX
|
VRA
VRX
|
VRA
VRS
VRS
|
VRA
VRX
VRX
T
0
0
0
0
T
VLA
VLO
VLO
VLI
VLI
VRE
M
M
M
|
MT
M
|
MT
M
|
MT
M
|
MT
M
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
0
0
0
0
}
;
