#
include
"
nsComplexBreaker
.
h
"
#
include
<
windows
.
h
>
#
include
<
usp10
.
h
>
#
include
"
nsUTF8Utils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
if
defined
(
NIGHTLY_BUILD
)
#
include
"
mozilla
/
WindowsProcessMitigations
.
h
"
#
define
TH_UNICODE
#
include
"
rulebrk
.
h
"
#
endif
void
NS_GetComplexLineBreaks
(
const
char16_t
*
aText
uint32_t
aLength
uint8_t
*
aBreakBefore
)
{
NS_ASSERTION
(
aText
"
aText
shouldn
'
t
be
null
"
)
;
#
if
defined
(
NIGHTLY_BUILD
)
if
(
mozilla
:
:
IsWin32kLockedDown
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
aLength
;
i
+
+
)
aBreakBefore
[
i
]
=
(
0
=
=
TrbWordBreakPos
(
aText
i
aText
+
i
aLength
-
i
)
)
;
return
;
}
#
endif
int
outItems
=
0
;
HRESULT
result
;
AutoTArray
<
SCRIPT_ITEM
64
>
items
;
char16ptr_t
text
=
aText
;
memset
(
aBreakBefore
false
aLength
)
;
items
.
AppendElements
(
64
)
;
do
{
result
=
ScriptItemize
(
text
aLength
items
.
Length
(
)
nullptr
nullptr
items
.
Elements
(
)
&
outItems
)
;
if
(
result
=
=
E_OUTOFMEMORY
)
{
items
.
AppendElements
(
items
.
Length
(
)
)
;
}
}
while
(
result
=
=
E_OUTOFMEMORY
)
;
for
(
int
iItem
=
0
;
iItem
<
outItems
;
+
+
iItem
)
{
uint32_t
endOffset
=
(
iItem
+
1
=
=
outItems
?
aLength
:
items
[
iItem
+
1
]
.
iCharPos
)
;
uint32_t
startOffset
=
items
[
iItem
]
.
iCharPos
;
AutoTArray
<
SCRIPT_LOGATTR
64
>
sla
;
sla
.
AppendElements
(
endOffset
-
startOffset
)
;
if
(
ScriptBreak
(
text
+
startOffset
endOffset
-
startOffset
&
items
[
iItem
]
.
a
sla
.
Elements
(
)
)
<
0
)
return
;
for
(
uint32_t
j
=
startOffset
?
0
:
1
;
j
+
startOffset
<
endOffset
;
+
+
j
)
{
aBreakBefore
[
j
+
startOffset
]
=
sla
[
j
]
.
fSoftBreak
;
}
}
}
