#
include
"
nsComplexBreaker
.
h
"
#
include
<
algorithm
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
;
using
CacheMap
=
nsTHashMap
<
nsString
nsTArray
<
uint8_t
>
>
;
static
UniquePtr
<
CacheMap
>
sBreakCache
;
static
const
int
kCacheLimit
=
3072
;
static
UniquePtr
<
CacheMap
>
sOldBreakCache
;
class
CacheDeleter
final
:
public
Runnable
{
public
:
explicit
CacheDeleter
(
UniquePtr
<
CacheMap
>
aCacheToDelete
)
:
Runnable
(
"
ComplexBreaker
CacheDeleter
"
)
mCacheToDelete
(
std
:
:
move
(
aCacheToDelete
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mCacheToDelete
=
nullptr
;
return
NS_OK
;
}
private
:
UniquePtr
<
CacheMap
>
mCacheToDelete
;
}
;
class
ComplexBreakObserver
final
:
public
nsIObserver
{
~
ComplexBreakObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
NS_IMPL_ISUPPORTS
(
ComplexBreakObserver
nsIObserver
)
NS_IMETHODIMP
ComplexBreakObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
strcmp
(
aTopic
"
memory
-
pressure
"
)
=
=
0
)
{
if
(
sOldBreakCache
)
{
NS_DispatchBackgroundTask
(
MakeAndAddRef
<
CacheDeleter
>
(
std
:
:
move
(
sOldBreakCache
)
)
)
;
}
else
if
(
sBreakCache
)
{
NS_DispatchBackgroundTask
(
MakeAndAddRef
<
CacheDeleter
>
(
std
:
:
move
(
sBreakCache
)
)
)
;
}
}
return
NS_OK
;
}
void
ComplexBreaker
:
:
Initialize
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
new
ComplexBreakObserver
(
)
"
memory
-
pressure
"
false
)
;
}
}
void
ComplexBreaker
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sBreakCache
=
nullptr
;
sOldBreakCache
=
nullptr
;
}
static
void
AddToCache
(
const
char16_t
*
aText
uint32_t
aLength
nsTArray
<
uint8_t
>
aBreakBefore
)
{
if
(
NS_WARN_IF
(
!
sBreakCache
-
>
InsertOrUpdate
(
nsString
(
aText
aLength
)
std
:
:
move
(
aBreakBefore
)
fallible
)
)
)
{
return
;
}
if
(
sBreakCache
-
>
Count
(
)
<
=
kCacheLimit
)
{
return
;
}
if
(
sOldBreakCache
)
{
NS_DispatchBackgroundTask
(
MakeAndAddRef
<
CacheDeleter
>
(
std
:
:
move
(
sOldBreakCache
)
)
)
;
}
sOldBreakCache
=
std
:
:
move
(
sBreakCache
)
;
}
static
void
CopyAndFill
(
const
nsTArray
<
uint8_t
>
&
aCachedBreakBefore
uint8_t
*
aBreakBefore
uint8_t
*
aEndBreakBefore
)
{
auto
*
startFill
=
std
:
:
copy
(
aCachedBreakBefore
.
begin
(
)
aCachedBreakBefore
.
end
(
)
aBreakBefore
)
;
std
:
:
fill
(
startFill
aEndBreakBefore
false
)
;
}
void
ComplexBreaker
:
:
GetBreaks
(
const
char16_t
*
aText
uint32_t
aLength
uint8_t
*
aBreakBefore
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aText
"
aText
shouldn
'
t
be
null
"
)
;
MOZ_ASSERT
(
aLength
"
aLength
shouldn
'
t
be
zero
"
)
;
MOZ_ASSERT
(
aBreakBefore
"
aBreakBefore
shouldn
'
t
be
null
"
)
;
if
(
sBreakCache
)
{
if
(
auto
entry
=
sBreakCache
-
>
Lookup
(
nsDependentSubstring
(
aText
aLength
)
)
)
{
auto
&
breakBefore
=
entry
.
Data
(
)
;
CopyAndFill
(
breakBefore
aBreakBefore
aBreakBefore
+
aLength
)
;
return
;
}
}
else
{
sBreakCache
=
MakeUnique
<
CacheMap
>
(
)
;
}
if
(
sOldBreakCache
)
{
auto
breakBefore
=
sOldBreakCache
-
>
Extract
(
nsDependentSubstring
(
aText
aLength
)
)
;
if
(
breakBefore
)
{
CopyAndFill
(
*
breakBefore
aBreakBefore
aBreakBefore
+
aLength
)
;
AddToCache
(
aText
aLength
std
:
:
move
(
*
breakBefore
)
)
;
return
;
}
}
NS_GetComplexLineBreaks
(
aText
aLength
aBreakBefore
)
;
auto
*
afterLastTrue
=
aBreakBefore
+
aLength
;
while
(
!
*
(
afterLastTrue
-
1
)
)
{
if
(
-
-
afterLastTrue
=
=
aBreakBefore
)
{
break
;
}
}
AddToCache
(
aText
aLength
nsTArray
<
uint8_t
>
(
aBreakBefore
afterLastTrue
-
aBreakBefore
)
)
;
}
