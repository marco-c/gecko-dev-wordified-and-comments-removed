#
include
"
mozilla
/
intl
/
LineBreaker
.
h
"
#
include
"
diplomat_runtime
.
hpp
"
#
include
"
icu4x
/
LineBreakIteratorLatin1
.
hpp
"
#
include
"
icu4x
/
LineBreakIteratorUtf16
.
hpp
"
#
include
"
icu4x
/
LineSegmenter
.
hpp
"
#
include
"
icu4x
/
Locale
.
hpp
"
#
include
"
jisx4051class
.
h
"
#
include
"
LineBreakCache
.
h
"
#
include
"
nsComplexBreaker
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
intl
/
Segmenter
.
h
"
#
include
"
mozilla
/
intl
/
UnicodeProperties
.
h
"
#
include
"
mozilla
/
StaticPrefs_intl
.
h
"
#
include
<
mutex
>
using
namespace
icu4x
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
intl
;
using
namespace
mozilla
:
:
unicode
;
#
define
MAX_CLASSES
12
static
const
uint16_t
gPair
[
MAX_CLASSES
]
=
{
0x0FFF
0x0C02
0x0806
0x0842
0x0802
0x0C06
0x0ED2
0x0EC2
0x0902
0x0FFF
0x0CC2
0x0FFF
}
;
static
const
uint16_t
gPairConservative
[
MAX_CLASSES
]
=
{
0x0FFF
0x0EC2
0x0EC6
0x0EC2
0x0EC2
0x0C06
0x0FDF
0x0FDF
0x0FC2
0x0FFF
0x0FDF
0x0FFF
}
;
#
define
CLASS_NONE
INT8_MAX
#
define
CLASS_OPEN
0x00
#
define
CLASS_CLOSE
0x01
#
define
CLASS_NON_BREAKABLE_BETWEEN_SAME_CLASS
0x02
#
define
CLASS_PREFIX
0x03
#
define
CLASS_POSTFFIX
0x04
#
define
CLASS_BREAKABLE
0x05
#
define
CLASS_NUMERIC
0x06
#
define
CLASS_CHARACTER
0x07
#
define
CLASS_COMPLEX
0x08
#
define
CLASS_OPEN_LIKE_CHARACTER
0x09
#
define
CLASS_CLOSE_LIKE_CHARACTER
0x0A
#
define
CLASS_NON_BREAKABLE
0x0B
#
define
U_NULL
char16_t
(
0x0000
)
#
define
U_SLASH
char16_t
(
'
/
'
)
#
define
U_SPACE
char16_t
(
'
'
)
#
define
U_HYPHEN
char16_t
(
'
-
'
)
#
define
U_EQUAL
char16_t
(
'
=
'
)
#
define
U_PERCENT
char16_t
(
'
%
'
)
#
define
U_AMPERSAND
char16_t
(
'
&
'
)
#
define
U_SEMICOLON
char16_t
(
'
;
'
)
#
define
U_BACKSLASH
char16_t
(
'
\
\
'
)
#
define
U_OPEN_SINGLE_QUOTE
char16_t
(
0x2018
)
#
define
U_OPEN_DOUBLE_QUOTE
char16_t
(
0x201C
)
#
define
U_OPEN_GUILLEMET
char16_t
(
0x00AB
)
#
define
NEED_CONTEXTUAL_ANALYSIS
(
c
)
\
(
IS_HYPHEN
(
c
)
|
|
(
c
)
=
=
U_SLASH
|
|
(
c
)
=
=
U_PERCENT
|
|
(
c
)
=
=
U_AMPERSAND
|
|
\
(
c
)
=
=
U_SEMICOLON
|
|
(
c
)
=
=
U_BACKSLASH
|
|
(
c
)
=
=
U_OPEN_SINGLE_QUOTE
|
|
\
(
c
)
=
=
U_OPEN_DOUBLE_QUOTE
|
|
(
c
)
=
=
U_OPEN_GUILLEMET
)
#
define
IS_ASCII_DIGIT
(
u
)
(
0x0030
<
=
(
u
)
&
&
(
u
)
<
=
0x0039
)
static
inline
int
GETCLASSFROMTABLE
(
const
uint32_t
*
t
uint16_t
l
)
{
return
(
(
(
(
t
)
[
(
l
>
>
3
)
]
)
>
>
(
(
l
&
0x0007
)
<
<
2
)
)
&
0x000f
)
;
}
static
inline
int
IS_HALFWIDTH_IN_JISx4051_CLASS3
(
char16_t
u
)
{
return
(
(
0xff66
<
=
(
u
)
)
&
&
(
(
u
)
<
=
0xff70
)
)
;
}
static
inline
int
IS_CJK_CHAR
(
char32_t
u
)
{
return
(
(
0x1100
<
=
(
u
)
&
&
(
u
)
<
=
0x11ff
)
|
|
(
0x2e80
<
=
(
u
)
&
&
(
u
)
<
=
0xd7ff
)
|
|
(
0xf900
<
=
(
u
)
&
&
(
u
)
<
=
0xfaff
)
|
|
(
0xff00
<
=
(
u
)
&
&
(
u
)
<
=
0xffef
)
|
|
(
0x20000
<
=
(
u
)
&
&
(
u
)
<
=
0x2fffd
)
)
;
}
static
inline
bool
IS_NONBREAKABLE_SPACE
(
char16_t
u
)
{
return
u
=
=
0x00A0
|
|
u
=
=
0x2007
;
}
static
inline
bool
IS_HYPHEN
(
char16_t
u
)
{
return
(
u
=
=
U_HYPHEN
|
|
u
=
=
0x2010
|
|
u
=
=
0x2012
|
|
u
=
=
0x2013
|
|
#
if
ANDROID
|
|
XP_WIN
u
=
=
0x0F0B
|
|
#
endif
u
=
=
0x058A
)
;
}
static
int8_t
GetClass
(
uint32_t
u
LineBreakRule
aLevel
bool
aIsChineseOrJapanese
)
{
static
const
int8_t
sUnicodeLineBreakToClass
[
]
=
{
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_OPEN_LIKE_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CLOSE_LIKE_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CLOSE_LIKE_CHARACTER
CLASS_NON_BREAKABLE
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CLOSE_LIKE_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CLOSE_LIKE_CHARACTER
CLASS_NUMERIC
CLASS_OPEN_LIKE_CHARACTER
CLASS_CLOSE_LIKE_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CHARACTER
CLASS_NON_BREAKABLE
CLASS_BREAKABLE
CLASS_BREAKABLE
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CLOSE_LIKE_CHARACTER
CLASS_CLOSE
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
}
;
static_assert
(
U_LB_COUNT
=
=
std
:
:
size
(
sUnicodeLineBreakToClass
)
"
Gecko
vs
ICU
LineBreak
class
mismatch
"
)
;
auto
cls
=
GetLineBreakClass
(
u
)
;
MOZ_ASSERT
(
cls
<
std
:
:
size
(
sUnicodeLineBreakToClass
)
)
;
switch
(
aLevel
)
{
case
LineBreakRule
:
:
Auto
:
break
;
case
LineBreakRule
:
:
Strict
:
if
(
cls
=
=
U_LB_CONDITIONAL_JAPANESE_STARTER
|
|
(
u
=
=
0x3095
|
|
u
=
=
0x3096
|
|
u
=
=
0x30f5
|
|
u
=
=
0x30f6
)
)
{
return
CLASS_CLOSE
;
}
if
(
cls
=
=
U_LB_INSEPARABLE
)
{
return
CLASS_NON_BREAKABLE_BETWEEN_SAME_CLASS
;
}
if
(
u
=
=
0x3005
|
|
u
=
=
0x303B
|
|
u
=
=
0x309D
|
|
u
=
=
0x309E
|
|
u
=
=
0x30FD
|
|
u
=
=
0x30FE
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
if
(
aIsChineseOrJapanese
)
{
if
(
cls
=
=
U_LB_POSTFIX_NUMERIC
&
&
UnicodeProperties
:
:
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
if
(
cls
=
=
U_LB_PREFIX_NUMERIC
&
&
UnicodeProperties
:
:
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_OPEN_LIKE_CHARACTER
;
}
if
(
u
=
=
0x2010
|
|
u
=
=
0x2013
|
|
u
=
=
0x301C
|
|
u
=
=
0x30A0
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
}
break
;
case
LineBreakRule
:
:
Normal
:
if
(
cls
=
=
U_LB_CONDITIONAL_JAPANESE_STARTER
)
{
return
CLASS_BREAKABLE
;
}
if
(
cls
=
=
U_LB_INSEPARABLE
)
{
return
CLASS_NON_BREAKABLE_BETWEEN_SAME_CLASS
;
}
if
(
u
=
=
0x3005
|
|
u
=
=
0x303B
|
|
u
=
=
0x309D
|
|
u
=
=
0x309E
|
|
u
=
=
0x30FD
|
|
u
=
=
0x30FE
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
if
(
aIsChineseOrJapanese
)
{
if
(
cls
=
=
U_LB_POSTFIX_NUMERIC
&
&
UnicodeProperties
:
:
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
if
(
cls
=
=
U_LB_PREFIX_NUMERIC
&
&
UnicodeProperties
:
:
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_OPEN_LIKE_CHARACTER
;
}
if
(
u
=
=
0x2010
|
|
u
=
=
0x2013
|
|
u
=
=
0x301C
|
|
u
=
=
0x30A0
)
{
return
CLASS_BREAKABLE
;
}
}
break
;
case
LineBreakRule
:
:
Loose
:
if
(
cls
=
=
U_LB_CONDITIONAL_JAPANESE_STARTER
)
{
return
CLASS_BREAKABLE
;
}
if
(
u
=
=
0x3005
|
|
u
=
=
0x303B
|
|
u
=
=
0x309D
|
|
u
=
=
0x309E
|
|
u
=
=
0x30FD
|
|
u
=
=
0x30FE
)
{
return
CLASS_BREAKABLE
;
}
if
(
cls
=
=
U_LB_INSEPARABLE
)
{
return
CLASS_BREAKABLE
;
}
if
(
aIsChineseOrJapanese
)
{
if
(
u
=
=
0x30FB
|
|
u
=
=
0xFF1A
|
|
u
=
=
0xFF1B
|
|
u
=
=
0xFF65
|
|
u
=
=
0x203C
|
|
u
=
=
0x2047
|
|
u
=
=
0x2048
|
|
u
=
=
0x2049
|
|
u
=
=
0xFF01
|
|
u
=
=
0xFF1F
)
{
return
CLASS_BREAKABLE
;
}
if
(
cls
=
=
U_LB_POSTFIX_NUMERIC
&
&
UnicodeProperties
:
:
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_BREAKABLE
;
}
if
(
cls
=
=
U_LB_PREFIX_NUMERIC
&
&
UnicodeProperties
:
:
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_BREAKABLE
;
}
if
(
u
=
=
0x2010
|
|
u
=
=
0x2013
|
|
u
=
=
0x301C
|
|
u
=
=
0x30A0
)
{
return
CLASS_BREAKABLE
;
}
}
break
;
case
LineBreakRule
:
:
Anywhere
:
MOZ_ASSERT_UNREACHABLE
(
"
should
have
been
handled
already
"
)
;
break
;
}
if
(
u
<
0x10000
)
{
uint16_t
h
=
u
&
0xFF00
;
uint16_t
l
=
u
&
0x00ff
;
if
(
0x0000
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass00
l
)
;
}
if
(
0x1700
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass17
l
)
;
}
if
(
NS_NeedsPlatformNativeHandling
(
u
)
)
{
return
CLASS_COMPLEX
;
}
if
(
0x0E00
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass0E
l
)
;
}
if
(
0x2000
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass20
l
)
;
}
if
(
0x2100
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass21
l
)
;
}
if
(
0x3000
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass30
l
)
;
}
if
(
0xff00
=
=
h
)
{
if
(
l
<
=
0x0060
)
{
return
sUnicodeLineBreakToClass
[
cls
]
;
}
if
(
l
<
0x00a0
)
{
switch
(
l
)
{
case
0x61
:
return
GetClass
(
0x3002
aLevel
aIsChineseOrJapanese
)
;
case
0x62
:
return
GetClass
(
0x300c
aLevel
aIsChineseOrJapanese
)
;
case
0x63
:
return
GetClass
(
0x300d
aLevel
aIsChineseOrJapanese
)
;
case
0x64
:
return
GetClass
(
0x3001
aLevel
aIsChineseOrJapanese
)
;
case
0x65
:
return
GetClass
(
0x30fb
aLevel
aIsChineseOrJapanese
)
;
case
0x9e
:
return
GetClass
(
0x309b
aLevel
aIsChineseOrJapanese
)
;
case
0x9f
:
return
GetClass
(
0x309c
aLevel
aIsChineseOrJapanese
)
;
default
:
if
(
IS_HALFWIDTH_IN_JISx4051_CLASS3
(
u
)
)
{
return
CLASS_CLOSE
;
}
return
CLASS_BREAKABLE
;
}
}
if
(
l
<
0x00e0
)
{
return
CLASS_CHARACTER
;
}
if
(
l
<
0x00f0
)
{
static
char16_t
NarrowFFEx
[
16
]
=
{
0x00A2
0x00A3
0x00AC
0x00AF
0x00A6
0x00A5
0x20A9
0x0000
0x2502
0x2190
0x2191
0x2192
0x2193
0x25A0
0x25CB
0x0000
}
;
return
GetClass
(
NarrowFFEx
[
l
-
0x00e0
]
aLevel
aIsChineseOrJapanese
)
;
}
}
else
if
(
0x3100
=
=
h
)
{
if
(
l
<
=
0xbf
)
{
return
CLASS_BREAKABLE
;
}
if
(
l
>
=
0xf0
)
{
return
CLASS_CLOSE
;
}
}
else
if
(
0x0300
=
=
h
)
{
if
(
0x4F
=
=
l
|
|
(
0x5C
<
=
l
&
&
l
<
=
0x62
)
)
{
return
CLASS_NON_BREAKABLE
;
}
}
else
if
(
0x0500
=
=
h
)
{
if
(
l
=
=
0x8A
)
{
return
GETCLASSFROMTABLE
(
gLBClass00
uint16_t
(
U_HYPHEN
)
)
;
}
}
else
if
(
0x0F00
=
=
h
)
{
if
(
l
=
=
0x0B
)
{
return
GETCLASSFROMTABLE
(
gLBClass00
uint16_t
(
U_HYPHEN
)
)
;
}
}
else
if
(
0x1800
=
=
h
)
{
if
(
0x0E
=
=
l
)
{
return
CLASS_NON_BREAKABLE
;
}
}
else
if
(
0x1600
=
=
h
)
{
if
(
0x80
=
=
l
)
{
return
CLASS_BREAKABLE
;
}
}
else
if
(
u
=
=
0xfeff
)
{
return
CLASS_NON_BREAKABLE
;
}
}
return
sUnicodeLineBreakToClass
[
cls
]
;
}
static
bool
GetPair
(
int8_t
c1
int8_t
c2
)
{
NS_ASSERTION
(
c1
<
MAX_CLASSES
"
illegal
classes
1
"
)
;
NS_ASSERTION
(
c2
<
MAX_CLASSES
"
illegal
classes
2
"
)
;
return
(
0
=
=
(
(
gPair
[
c1
]
>
>
c2
)
&
0x0001
)
)
;
}
static
bool
GetPairConservative
(
int8_t
c1
int8_t
c2
)
{
NS_ASSERTION
(
c1
<
MAX_CLASSES
"
illegal
classes
1
"
)
;
NS_ASSERTION
(
c2
<
MAX_CLASSES
"
illegal
classes
2
"
)
;
return
(
0
=
=
(
(
gPairConservative
[
c1
]
>
>
c2
)
&
0x0001
)
)
;
}
class
ContextState
{
public
:
ContextState
(
const
char16_t
*
aText
uint32_t
aLength
)
:
mUniText
(
aText
)
mText
(
nullptr
)
mLength
(
aLength
)
{
Init
(
)
;
}
ContextState
(
const
uint8_t
*
aText
uint32_t
aLength
)
:
mUniText
(
nullptr
)
mText
(
aText
)
mLength
(
aLength
)
{
Init
(
)
;
}
uint32_t
Length
(
)
const
{
return
mLength
;
}
uint32_t
Index
(
)
const
{
return
mIndex
;
}
char16_t
GetCodeUnitAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mLength
"
Out
of
range
!
"
)
;
return
mUniText
?
mUniText
[
aIndex
]
:
char16_t
(
mText
[
aIndex
]
)
;
}
char32_t
GetUnicodeCharAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
mUniText
"
Only
for
16
-
bit
text
!
"
)
;
MOZ_ASSERT
(
aIndex
<
mLength
"
Out
of
range
!
"
)
;
char32_t
c
=
mUniText
[
aIndex
]
;
if
(
aIndex
+
1
<
mLength
&
&
NS_IS_SURROGATE_PAIR
(
c
mUniText
[
aIndex
+
1
]
)
)
{
c
=
SURROGATE_TO_UCS4
(
c
mUniText
[
aIndex
+
1
]
)
;
}
return
c
;
}
void
AdvanceIndex
(
)
{
+
+
mIndex
;
}
void
NotifyBreakBefore
(
)
{
mLastBreakIndex
=
mIndex
;
}
#
define
CONSERVATIVE_RANGE_LETTER
2
#
define
CONSERVATIVE_RANGE_OTHER
6
bool
UseConservativeBreaking
(
uint32_t
aOffset
=
0
)
const
{
if
(
mHasCJKChar
)
return
false
;
uint32_t
index
=
mIndex
+
aOffset
;
uint32_t
conservativeRangeStart
conservativeRangeEnd
;
if
(
index
<
mLength
&
&
nsUGenCategory
:
:
kLetter
=
=
(
mText
?
GetGenCategory
(
mText
[
index
]
)
:
GetGenCategory
(
GetUnicodeCharAt
(
index
)
)
)
)
{
conservativeRangeEnd
=
CONSERVATIVE_RANGE_LETTER
;
conservativeRangeStart
=
CONSERVATIVE_RANGE_LETTER
+
1
;
}
else
{
conservativeRangeEnd
=
conservativeRangeStart
=
CONSERVATIVE_RANGE_OTHER
;
}
bool
result
=
(
index
<
conservativeRangeStart
|
|
mLength
-
index
<
conservativeRangeEnd
|
|
index
-
mLastBreakIndex
<
conservativeRangeStart
)
;
if
(
result
|
|
!
mHasNonbreakableSpace
)
return
result
;
for
(
uint32_t
i
=
index
;
index
-
conservativeRangeStart
<
i
;
-
-
i
)
{
if
(
IS_NONBREAKABLE_SPACE
(
GetCodeUnitAt
(
i
-
1
)
)
)
return
true
;
}
for
(
uint32_t
i
=
index
+
1
;
i
<
index
+
conservativeRangeEnd
;
+
+
i
)
{
if
(
IS_NONBREAKABLE_SPACE
(
GetCodeUnitAt
(
i
)
)
)
return
true
;
}
return
false
;
}
bool
HasPreviousEqualsSign
(
)
const
{
return
mHasPreviousEqualsSign
;
}
void
NotifySeenEqualsSign
(
)
{
mHasPreviousEqualsSign
=
true
;
}
bool
HasPreviousSlash
(
)
const
{
return
mHasPreviousSlash
;
}
void
NotifySeenSlash
(
)
{
mHasPreviousSlash
=
true
;
}
bool
HasPreviousBackslash
(
)
const
{
return
mHasPreviousBackslash
;
}
void
NotifySeenBackslash
(
)
{
mHasPreviousBackslash
=
true
;
}
uint32_t
GetPreviousNonHyphenCharacter
(
)
const
{
return
mPreviousNonHyphenCharacter
;
}
void
NotifyNonHyphenCharacter
(
uint32_t
ch
)
{
mPreviousNonHyphenCharacter
=
ch
;
}
private
:
void
Init
(
)
{
mIndex
=
0
;
mLastBreakIndex
=
0
;
mPreviousNonHyphenCharacter
=
U_NULL
;
mHasCJKChar
=
false
;
mHasNonbreakableSpace
=
false
;
mHasPreviousEqualsSign
=
false
;
mHasPreviousSlash
=
false
;
mHasPreviousBackslash
=
false
;
if
(
mText
)
{
for
(
uint32_t
i
=
0
;
i
<
mLength
;
+
+
i
)
{
if
(
IS_NONBREAKABLE_SPACE
(
mText
[
i
]
)
)
{
mHasNonbreakableSpace
=
true
;
break
;
}
}
}
else
{
for
(
uint32_t
i
=
0
;
i
<
mLength
;
+
+
i
)
{
char32_t
u
=
GetUnicodeCharAt
(
i
)
;
if
(
!
mHasNonbreakableSpace
&
&
IS_NONBREAKABLE_SPACE
(
u
)
)
{
mHasNonbreakableSpace
=
true
;
if
(
mHasCJKChar
)
{
break
;
}
}
else
if
(
!
mHasCJKChar
&
&
IS_CJK_CHAR
(
u
)
)
{
mHasCJKChar
=
true
;
if
(
mHasNonbreakableSpace
)
{
break
;
}
}
if
(
u
>
0xFFFFu
)
{
+
+
i
;
}
}
}
}
const
char16_t
*
const
mUniText
;
const
uint8_t
*
const
mText
;
uint32_t
mIndex
;
const
uint32_t
mLength
;
uint32_t
mLastBreakIndex
;
char32_t
mPreviousNonHyphenCharacter
;
bool
mHasCJKChar
;
bool
mHasNonbreakableSpace
;
bool
mHasPreviousEqualsSign
;
bool
mHasPreviousSlash
;
bool
mHasPreviousBackslash
;
}
;
static
int8_t
ContextualAnalysis
(
char32_t
prev
char32_t
cur
char32_t
next
ContextState
&
aState
LineBreakRule
aLevel
bool
aIsChineseOrJapanese
)
{
if
(
IS_HYPHEN
(
cur
)
)
{
if
(
IS_HYPHEN
(
next
)
)
return
CLASS_CHARACTER
;
bool
prevIsNum
=
IS_ASCII_DIGIT
(
prev
)
;
bool
nextIsNum
=
IS_ASCII_DIGIT
(
next
)
;
if
(
prevIsNum
&
&
nextIsNum
)
return
CLASS_NUMERIC
;
if
(
!
aState
.
UseConservativeBreaking
(
1
)
)
{
char32_t
prevOfHyphen
=
aState
.
GetPreviousNonHyphenCharacter
(
)
;
if
(
prevOfHyphen
&
&
next
)
{
int8_t
prevClass
=
GetClass
(
prevOfHyphen
aLevel
aIsChineseOrJapanese
)
;
int8_t
nextClass
=
GetClass
(
next
aLevel
aIsChineseOrJapanese
)
;
bool
prevIsNumOrCharOrClose
=
prevIsNum
|
|
(
prevClass
=
=
CLASS_CHARACTER
&
&
!
NEED_CONTEXTUAL_ANALYSIS
(
prevOfHyphen
)
)
|
|
prevClass
=
=
CLASS_CLOSE
|
|
prevClass
=
=
CLASS_CLOSE_LIKE_CHARACTER
;
bool
nextIsNumOrCharOrOpen
=
nextIsNum
|
|
(
nextClass
=
=
CLASS_CHARACTER
&
&
!
NEED_CONTEXTUAL_ANALYSIS
(
next
)
)
|
|
nextClass
=
=
CLASS_OPEN
|
|
nextClass
=
=
CLASS_OPEN_LIKE_CHARACTER
|
|
next
=
=
U_OPEN_SINGLE_QUOTE
|
|
next
=
=
U_OPEN_DOUBLE_QUOTE
|
|
next
=
=
U_OPEN_GUILLEMET
;
if
(
prevIsNumOrCharOrClose
&
&
nextIsNumOrCharOrOpen
)
{
return
CLASS_CLOSE
;
}
}
}
}
else
{
aState
.
NotifyNonHyphenCharacter
(
cur
)
;
if
(
cur
=
=
U_SLASH
|
|
cur
=
=
U_BACKSLASH
)
{
if
(
prev
=
=
cur
)
return
CLASS_CHARACTER
;
bool
shouldReturn
=
!
aState
.
UseConservativeBreaking
(
)
&
&
(
cur
=
=
U_SLASH
?
aState
.
HasPreviousSlash
(
)
:
aState
.
HasPreviousBackslash
(
)
)
;
if
(
cur
=
=
U_SLASH
)
{
aState
.
NotifySeenSlash
(
)
;
}
else
{
aState
.
NotifySeenBackslash
(
)
;
}
if
(
shouldReturn
)
return
CLASS_OPEN
;
}
else
if
(
cur
=
=
U_PERCENT
)
{
if
(
!
aState
.
UseConservativeBreaking
(
)
)
{
if
(
aState
.
Index
(
)
>
=
3
&
&
aState
.
GetCodeUnitAt
(
aState
.
Index
(
)
-
3
)
=
=
U_PERCENT
)
return
CLASS_OPEN
;
if
(
aState
.
Index
(
)
+
3
<
aState
.
Length
(
)
&
&
aState
.
GetCodeUnitAt
(
aState
.
Index
(
)
+
3
)
=
=
U_PERCENT
)
return
CLASS_OPEN
;
}
}
else
if
(
cur
=
=
U_AMPERSAND
|
|
cur
=
=
U_SEMICOLON
)
{
if
(
!
aState
.
UseConservativeBreaking
(
1
)
&
&
aState
.
HasPreviousEqualsSign
(
)
)
return
CLASS_CLOSE
;
}
else
if
(
cur
=
=
U_OPEN_SINGLE_QUOTE
|
|
cur
=
=
U_OPEN_DOUBLE_QUOTE
|
|
cur
=
=
U_OPEN_GUILLEMET
)
{
if
(
!
aState
.
UseConservativeBreaking
(
)
&
&
IS_CJK_CHAR
(
next
)
)
return
CLASS_OPEN
;
}
else
{
NS_ERROR
(
"
Forgot
to
handle
the
current
character
!
"
)
;
}
}
return
GetClass
(
cur
aLevel
aIsChineseOrJapanese
)
;
}
int32_t
LineBreaker
:
:
Next
(
const
char16_t
*
aText
uint32_t
aLen
uint32_t
aPos
)
{
MOZ_ASSERT
(
aText
)
;
if
(
aPos
>
=
aLen
)
{
return
NS_LINEBREAKER_NEED_MORE_TEXT
;
}
bool
textNeedsComplexLineBreak
=
false
;
int32_t
begin
end
;
for
(
begin
=
aPos
;
begin
>
0
&
&
!
NS_IsSpace
(
aText
[
begin
-
1
]
)
;
-
-
begin
)
{
if
(
IS_CJK_CHAR
(
aText
[
begin
]
)
|
|
NS_NeedsPlatformNativeHandling
(
aText
[
begin
]
)
)
{
textNeedsComplexLineBreak
=
true
;
}
}
for
(
end
=
aPos
+
1
;
end
<
int32_t
(
aLen
)
&
&
!
NS_IsSpace
(
aText
[
end
]
)
;
+
+
end
)
{
if
(
IS_CJK_CHAR
(
aText
[
end
]
)
|
|
NS_NeedsPlatformNativeHandling
(
aText
[
end
]
)
)
{
textNeedsComplexLineBreak
=
true
;
}
}
int32_t
ret
;
if
(
!
textNeedsComplexLineBreak
)
{
ret
=
end
;
}
else
{
AutoTArray
<
uint8_t
2000
>
breakState
;
breakState
.
AppendElements
(
end
-
begin
)
;
ComputeBreakPositions
(
aText
+
begin
end
-
begin
WordBreakRule
:
:
Normal
LineBreakRule
:
:
Auto
false
breakState
.
Elements
(
)
)
;
ret
=
aPos
;
do
{
+
+
ret
;
}
while
(
begin
<
ret
&
&
ret
<
end
&
&
!
breakState
[
ret
-
begin
]
)
;
}
return
ret
;
}
static
bool
SuppressBreakForKeepAll
(
uint32_t
aPrev
uint32_t
aCh
)
{
auto
affectedByKeepAll
=
[
]
(
uint8_t
aLBClass
)
{
switch
(
aLBClass
)
{
case
U_LB_ALPHABETIC
:
case
U_LB_AMBIGUOUS
:
case
U_LB_NUMERIC
:
case
U_LB_IDEOGRAPHIC
:
case
U_LB_H2
:
case
U_LB_H3
:
case
U_LB_JL
:
case
U_LB_JV
:
case
U_LB_JT
:
case
U_LB_CONDITIONAL_JAPANESE_STARTER
:
return
true
;
default
:
return
false
;
}
}
;
return
affectedByKeepAll
(
GetLineBreakClass
(
aPrev
)
)
&
&
affectedByKeepAll
(
GetLineBreakClass
(
aCh
)
)
;
}
static
LineBreakStrictness
ConvertLineBreakRuleToICU4X
(
LineBreakRule
aLevel
)
{
switch
(
aLevel
)
{
case
LineBreakRule
:
:
Auto
:
return
LineBreakStrictness
:
:
Strict
;
case
LineBreakRule
:
:
Strict
:
return
LineBreakStrictness
:
:
Strict
;
case
LineBreakRule
:
:
Loose
:
return
LineBreakStrictness
:
:
Loose
;
case
LineBreakRule
:
:
Normal
:
return
LineBreakStrictness
:
:
Normal
;
case
LineBreakRule
:
:
Anywhere
:
return
LineBreakStrictness
:
:
Anywhere
;
}
MOZ_ASSERT_UNREACHABLE
(
"
should
have
been
handled
already
"
)
;
return
LineBreakStrictness
:
:
Normal
;
}
static
LineBreakWordOption
ConvertWordBreakRuleToICU4X
(
WordBreakRule
aWordBreak
)
{
switch
(
aWordBreak
)
{
case
WordBreakRule
:
:
Normal
:
return
LineBreakWordOption
:
:
Normal
;
case
WordBreakRule
:
:
BreakAll
:
return
LineBreakWordOption
:
:
BreakAll
;
case
WordBreakRule
:
:
KeepAll
:
return
LineBreakWordOption
:
:
KeepAll
;
}
MOZ_ASSERT_UNREACHABLE
(
"
should
have
been
handled
already
"
)
;
return
LineBreakWordOption
:
:
Normal
;
}
static
capi
:
:
LineSegmenter
*
sLineSegmenter
=
nullptr
;
static
capi
:
:
Locale
*
sZhLocale
=
nullptr
;
static
capi
:
:
LineSegmenter
*
GetDefaultLineSegmenter
(
)
{
static
std
:
:
once_flag
sOnce
;
std
:
:
call_once
(
sOnce
[
]
{
sLineSegmenter
=
capi
:
:
icu4x_LineSegmenter_create_auto_mv1
(
)
;
}
)
;
return
sLineSegmenter
;
}
static
bool
UseDefaultLineSegmenter
(
WordBreakRule
aWordBreak
LineBreakRule
aLevel
bool
aIsChineseOrJapanese
)
{
return
aWordBreak
=
=
WordBreakRule
:
:
Normal
&
&
(
aLevel
=
=
LineBreakRule
:
:
Strict
|
|
aLevel
=
=
LineBreakRule
:
:
Auto
)
&
&
!
aIsChineseOrJapanese
;
}
static
void
InitDefaultLocale
(
)
{
static
std
:
:
once_flag
sOnce
;
std
:
:
call_once
(
sOnce
[
]
{
auto
locale
=
capi
:
:
icu4x_Locale_from_string_mv1
(
diplomat
:
:
capi
:
:
DiplomatStringView
{
"
zh
"
2
}
)
;
if
(
locale
.
is_ok
)
{
sZhLocale
=
locale
.
ok
;
}
}
)
;
}
static
capi
:
:
LineSegmenter
*
GetLineSegmenter
(
bool
aUseDefault
WordBreakRule
aWordBreak
LineBreakRule
aLevel
bool
aIsChineseOrJapanese
)
{
if
(
aUseDefault
)
{
MOZ_ASSERT
(
UseDefaultLineSegmenter
(
aWordBreak
aLevel
aIsChineseOrJapanese
)
)
;
return
GetDefaultLineSegmenter
(
)
;
}
if
(
!
sZhLocale
&
&
aIsChineseOrJapanese
)
{
InitDefaultLocale
(
)
;
}
LineBreakOptionsV2
options
;
options
.
word_option
=
ConvertWordBreakRuleToICU4X
(
aWordBreak
)
;
options
.
strictness
=
ConvertLineBreakRuleToICU4X
(
aLevel
)
;
auto
locale
=
aIsChineseOrJapanese
?
sZhLocale
:
nullptr
;
return
capi
:
:
icu4x_LineSegmenter_create_lstm_with_options_v2_mv1
(
locale
options
.
AsFFI
(
)
)
;
}
void
LineBreaker
:
:
ComputeBreakPositions
(
const
char16_t
*
aChars
uint32_t
aLength
WordBreakRule
aWordBreak
LineBreakRule
aLevel
bool
aIsChineseOrJapanese
uint8_t
*
aBreakBefore
)
{
if
(
StaticPrefs
:
:
intl_icu4x_segmenter_enabled
(
)
)
{
if
(
aLength
=
=
1
)
{
aBreakBefore
[
0
]
=
1
;
return
;
}
bool
useCache
=
[
=
]
(
)
{
const
uint32_t
kStride
=
8
;
for
(
uint32_t
i
=
0
;
i
<
aLength
;
i
+
=
kStride
)
{
if
(
intl
:
:
UnicodeProperties
:
:
IsScriptioContinua
(
aChars
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
(
)
;
Maybe
<
LineBreakCache
:
:
Entry
>
entry
;
if
(
useCache
)
{
LineBreakCache
:
:
KeyType
key
{
aChars
aLength
aWordBreak
aLevel
aIsChineseOrJapanese
}
;
entry
.
emplace
(
LineBreakCache
:
:
Cache
(
)
-
>
Lookup
(
key
)
)
;
if
(
*
entry
)
{
auto
&
breakBefore
=
entry
-
>
Data
(
)
.
mBreaks
;
LineBreakCache
:
:
CopyAndFill
(
breakBefore
aBreakBefore
aBreakBefore
+
aLength
)
;
return
;
}
}
memset
(
aBreakBefore
0
aLength
)
;
CheckedInt
<
int32_t
>
length
=
aLength
;
if
(
length
.
isValid
(
)
)
{
const
bool
useDefault
=
UseDefaultLineSegmenter
(
aWordBreak
aLevel
aIsChineseOrJapanese
)
;
auto
lineSegmenter
=
GetLineSegmenter
(
useDefault
aWordBreak
aLevel
aIsChineseOrJapanese
)
;
auto
segmenter
=
LineSegmenter
:
:
FromFFI
(
lineSegmenter
)
;
auto
iterator
=
segmenter
-
>
segment16
(
std
:
:
u16string_view
{
aChars
aLength
}
)
;
while
(
true
)
{
const
int32_t
nextPos
=
iterator
-
>
next
(
)
;
if
(
nextPos
<
0
|
|
nextPos
>
=
length
.
value
(
)
)
{
break
;
}
aBreakBefore
[
nextPos
]
=
1
;
}
if
(
!
useDefault
)
{
capi
:
:
icu4x_LineSegmenter_destroy_mv1
(
lineSegmenter
)
;
}
}
if
(
useCache
)
{
auto
*
afterLastTrue
=
aBreakBefore
+
aLength
;
while
(
!
*
(
afterLastTrue
-
1
)
)
{
if
(
-
-
afterLastTrue
=
=
aBreakBefore
)
{
break
;
}
}
entry
-
>
Set
(
LineBreakCache
:
:
EntryType
{
nsString
(
aChars
aLength
)
nsTArray
<
uint8_t
>
(
aBreakBefore
afterLastTrue
-
aBreakBefore
)
aWordBreak
aLevel
aIsChineseOrJapanese
}
)
;
}
return
;
}
uint32_t
cur
;
int8_t
lastClass
=
CLASS_NONE
;
ContextState
state
(
aChars
aLength
)
;
for
(
cur
=
0
;
cur
<
aLength
;
+
+
cur
state
.
AdvanceIndex
(
)
)
{
char32_t
ch
=
state
.
GetUnicodeCharAt
(
cur
)
;
uint32_t
chLen
=
ch
>
0xFFFFu
?
2
:
1
;
int8_t
cl
;
auto
prev
=
[
=
]
(
)
-
>
char32_t
{
if
(
!
cur
)
{
return
0
;
}
char32_t
c
=
aChars
[
cur
-
1
]
;
if
(
cur
>
1
&
&
NS_IS_SURROGATE_PAIR
(
aChars
[
cur
-
2
]
c
)
)
{
c
=
SURROGATE_TO_UCS4
(
aChars
[
cur
-
2
]
c
)
;
}
return
c
;
}
;
if
(
NEED_CONTEXTUAL_ANALYSIS
(
ch
)
)
{
char32_t
next
;
if
(
cur
+
chLen
<
aLength
)
{
next
=
state
.
GetUnicodeCharAt
(
cur
+
chLen
)
;
}
else
{
next
=
0
;
}
cl
=
ContextualAnalysis
(
prev
(
)
ch
next
state
aLevel
aIsChineseOrJapanese
)
;
}
else
{
if
(
ch
=
=
U_EQUAL
)
state
.
NotifySeenEqualsSign
(
)
;
state
.
NotifyNonHyphenCharacter
(
ch
)
;
cl
=
GetClass
(
ch
aLevel
aIsChineseOrJapanese
)
;
}
if
(
aWordBreak
=
=
WordBreakRule
:
:
BreakAll
&
&
(
cl
=
=
CLASS_CHARACTER
|
|
cl
=
=
CLASS_CLOSE
|
|
cl
=
=
CLASS_CLOSE_LIKE_CHARACTER
|
|
cl
=
=
CLASS_NUMERIC
)
)
{
auto
cls
=
GetLineBreakClass
(
ch
)
;
if
(
cls
=
=
U_LB_ALPHABETIC
|
|
cls
=
=
U_LB_NUMERIC
|
|
cls
=
=
U_LB_AMBIGUOUS
|
|
cls
=
=
U_LB_COMPLEX_CONTEXT
|
|
cls
=
=
U_LB_CONDITIONAL_JAPANESE_STARTER
|
|
(
cls
>
=
U_LB_H2
&
&
cls
<
=
U_LB_JV
)
)
{
cl
=
CLASS_BREAKABLE
;
}
}
bool
allowBreak
=
false
;
if
(
cur
>
0
)
{
NS_ASSERTION
(
CLASS_COMPLEX
!
=
lastClass
|
|
CLASS_COMPLEX
!
=
cl
"
Loop
should
have
prevented
adjacent
complex
chars
here
"
)
;
allowBreak
=
(
state
.
UseConservativeBreaking
(
)
?
GetPairConservative
(
lastClass
cl
)
:
GetPair
(
lastClass
cl
)
)
;
if
(
allowBreak
)
{
if
(
aWordBreak
=
=
WordBreakRule
:
:
KeepAll
&
&
SuppressBreakForKeepAll
(
prev
(
)
ch
)
)
{
allowBreak
=
false
;
}
if
(
ch
=
=
0x3000
&
&
prev
(
)
=
=
0x3000
&
&
aWordBreak
!
=
WordBreakRule
:
:
BreakAll
)
{
allowBreak
=
false
;
}
}
}
aBreakBefore
[
cur
]
=
allowBreak
;
if
(
allowBreak
)
state
.
NotifyBreakBefore
(
)
;
lastClass
=
cl
;
if
(
CLASS_COMPLEX
=
=
cl
)
{
uint32_t
end
=
cur
+
chLen
;
while
(
end
<
aLength
)
{
char32_t
c
=
state
.
GetUnicodeCharAt
(
end
)
;
if
(
CLASS_COMPLEX
!
=
GetClass
(
c
aLevel
false
)
)
{
break
;
}
+
+
end
;
if
(
c
>
0xFFFFU
)
{
+
+
end
;
}
}
if
(
aWordBreak
=
=
WordBreakRule
:
:
BreakAll
)
{
GraphemeClusterBreakIteratorUtf16
ci
(
Span
<
const
char16_t
>
(
aChars
+
cur
end
-
cur
)
)
;
while
(
Maybe
<
uint32_t
>
pos
=
ci
.
Next
(
)
)
{
aBreakBefore
[
cur
+
*
pos
]
=
true
;
}
}
else
{
ComplexBreaker
:
:
GetBreaks
(
aChars
+
cur
end
-
cur
aBreakBefore
+
cur
)
;
aBreakBefore
[
cur
]
=
allowBreak
;
}
cur
=
end
-
1
;
}
if
(
chLen
=
=
2
)
{
+
+
cur
;
aBreakBefore
[
cur
]
=
false
;
state
.
AdvanceIndex
(
)
;
}
}
}
void
LineBreaker
:
:
ComputeBreakPositions
(
const
uint8_t
*
aChars
uint32_t
aLength
WordBreakRule
aWordBreak
LineBreakRule
aLevel
bool
aIsChineseOrJapanese
uint8_t
*
aBreakBefore
)
{
if
(
StaticPrefs
:
:
intl_icu4x_segmenter_enabled
(
)
)
{
if
(
aLength
=
=
1
)
{
aBreakBefore
[
0
]
=
1
;
return
;
}
memset
(
aBreakBefore
0
aLength
)
;
CheckedInt
<
int32_t
>
length
=
aLength
;
if
(
!
length
.
isValid
(
)
)
{
return
;
}
const
bool
useDefault
=
UseDefaultLineSegmenter
(
aWordBreak
aLevel
aIsChineseOrJapanese
)
;
auto
lineSegmenter
=
GetLineSegmenter
(
useDefault
aWordBreak
aLevel
aIsChineseOrJapanese
)
;
auto
segmenter
=
icu4x
:
:
LineSegmenter
:
:
FromFFI
(
lineSegmenter
)
;
auto
iterator
=
segmenter
-
>
segment_latin1
(
diplomat
:
:
span
<
const
uint8_t
>
{
aChars
aLength
}
)
;
while
(
true
)
{
const
int32_t
nextPos
=
iterator
-
>
next
(
)
;
if
(
nextPos
<
0
|
|
nextPos
>
=
length
.
value
(
)
)
{
break
;
}
aBreakBefore
[
nextPos
]
=
1
;
}
if
(
!
useDefault
)
{
capi
:
:
icu4x_LineSegmenter_destroy_mv1
(
lineSegmenter
)
;
}
return
;
}
uint32_t
cur
;
int8_t
lastClass
=
CLASS_NONE
;
ContextState
state
(
aChars
aLength
)
;
for
(
cur
=
0
;
cur
<
aLength
;
+
+
cur
state
.
AdvanceIndex
(
)
)
{
char32_t
ch
=
aChars
[
cur
]
;
int8_t
cl
;
if
(
NEED_CONTEXTUAL_ANALYSIS
(
ch
)
)
{
cl
=
ContextualAnalysis
(
cur
>
0
?
aChars
[
cur
-
1
]
:
U_NULL
ch
cur
+
1
<
aLength
?
aChars
[
cur
+
1
]
:
U_NULL
state
aLevel
aIsChineseOrJapanese
)
;
}
else
{
if
(
ch
=
=
U_EQUAL
)
state
.
NotifySeenEqualsSign
(
)
;
state
.
NotifyNonHyphenCharacter
(
ch
)
;
cl
=
GetClass
(
ch
aLevel
aIsChineseOrJapanese
)
;
}
if
(
aWordBreak
=
=
WordBreakRule
:
:
BreakAll
&
&
(
cl
=
=
CLASS_CHARACTER
|
|
cl
=
=
CLASS_CLOSE
|
|
cl
=
=
CLASS_CLOSE_LIKE_CHARACTER
|
|
cl
=
=
CLASS_NUMERIC
)
)
{
auto
cls
=
GetLineBreakClass
(
ch
)
;
if
(
cls
=
=
U_LB_ALPHABETIC
|
|
cls
=
=
U_LB_NUMERIC
|
|
cls
=
=
U_LB_COMPLEX_CONTEXT
)
{
cl
=
CLASS_BREAKABLE
;
}
}
bool
allowBreak
=
false
;
if
(
cur
>
0
)
{
allowBreak
=
(
state
.
UseConservativeBreaking
(
)
?
GetPairConservative
(
lastClass
cl
)
:
GetPair
(
lastClass
cl
)
)
&
&
(
aWordBreak
!
=
WordBreakRule
:
:
KeepAll
|
|
!
SuppressBreakForKeepAll
(
aChars
[
cur
-
1
]
ch
)
)
;
}
aBreakBefore
[
cur
]
=
allowBreak
;
if
(
allowBreak
)
state
.
NotifyBreakBefore
(
)
;
lastClass
=
cl
;
}
}
void
LineBreaker
:
:
Shutdown
(
)
{
if
(
sLineSegmenter
)
{
capi
:
:
icu4x_LineSegmenter_destroy_mv1
(
sLineSegmenter
)
;
}
if
(
sZhLocale
)
{
capi
:
:
icu4x_Locale_destroy_mv1
(
sZhLocale
)
;
}
sLineSegmenter
=
nullptr
;
sZhLocale
=
nullptr
;
}
