#
include
"
mozilla
/
intl
/
LineBreaker
.
h
"
#
include
"
jisx4051class
.
h
"
#
include
"
nsComplexBreaker
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
using
namespace
mozilla
:
:
unicode
;
using
namespace
mozilla
:
:
intl
;
#
define
MAX_CLASSES
12
static
const
uint16_t
gPair
[
MAX_CLASSES
]
=
{
0x0FFF
0x0C02
0x0806
0x0842
0x0802
0x0C06
0x0ED2
0x0EC2
0x0902
0x0FFF
0x0CC2
0x0FFF
}
;
static
const
uint16_t
gPairConservative
[
MAX_CLASSES
]
=
{
0x0FFF
0x0EC2
0x0EC6
0x0EC2
0x0EC2
0x0C06
0x0FDF
0x0FDF
0x0FC2
0x0FFF
0x0FDF
0x0FFF
}
;
#
define
CLASS_NONE
INT8_MAX
#
define
CLASS_OPEN
0x00
#
define
CLASS_CLOSE
0x01
#
define
CLASS_NON_BREAKABLE_BETWEEN_SAME_CLASS
0x02
#
define
CLASS_PREFIX
0x03
#
define
CLASS_POSTFFIX
0x04
#
define
CLASS_BREAKABLE
0x05
#
define
CLASS_NUMERIC
0x06
#
define
CLASS_CHARACTER
0x07
#
define
CLASS_COMPLEX
0x08
#
define
CLASS_OPEN_LIKE_CHARACTER
0x09
#
define
CLASS_CLOSE_LIKE_CHARACTER
0x0A
#
define
CLASS_NON_BREAKABLE
0x0B
#
define
U_NULL
char16_t
(
0x0000
)
#
define
U_SLASH
char16_t
(
'
/
'
)
#
define
U_SPACE
char16_t
(
'
'
)
#
define
U_HYPHEN
char16_t
(
'
-
'
)
#
define
U_EQUAL
char16_t
(
'
=
'
)
#
define
U_PERCENT
char16_t
(
'
%
'
)
#
define
U_AMPERSAND
char16_t
(
'
&
'
)
#
define
U_SEMICOLON
char16_t
(
'
;
'
)
#
define
U_BACKSLASH
char16_t
(
'
\
\
'
)
#
define
U_OPEN_SINGLE_QUOTE
char16_t
(
0x2018
)
#
define
U_OPEN_DOUBLE_QUOTE
char16_t
(
0x201C
)
#
define
U_OPEN_GUILLEMET
char16_t
(
0x00AB
)
#
define
NEED_CONTEXTUAL_ANALYSIS
(
c
)
\
(
IS_HYPHEN
(
c
)
|
|
(
c
)
=
=
U_SLASH
|
|
(
c
)
=
=
U_PERCENT
|
|
(
c
)
=
=
U_AMPERSAND
|
|
\
(
c
)
=
=
U_SEMICOLON
|
|
(
c
)
=
=
U_BACKSLASH
|
|
(
c
)
=
=
U_OPEN_SINGLE_QUOTE
|
|
\
(
c
)
=
=
U_OPEN_DOUBLE_QUOTE
|
|
(
c
)
=
=
U_OPEN_GUILLEMET
)
#
define
IS_ASCII_DIGIT
(
u
)
(
0x0030
<
=
(
u
)
&
&
(
u
)
<
=
0x0039
)
static
inline
int
GETCLASSFROMTABLE
(
const
uint32_t
*
t
uint16_t
l
)
{
return
(
(
(
(
t
)
[
(
l
>
>
3
)
]
)
>
>
(
(
l
&
0x0007
)
<
<
2
)
)
&
0x000f
)
;
}
static
inline
int
IS_HALFWIDTH_IN_JISx4051_CLASS3
(
char16_t
u
)
{
return
(
(
0xff66
<
=
(
u
)
)
&
&
(
(
u
)
<
=
0xff70
)
)
;
}
static
inline
int
IS_CJK_CHAR
(
char32_t
u
)
{
return
(
(
0x1100
<
=
(
u
)
&
&
(
u
)
<
=
0x11ff
)
|
|
(
0x2e80
<
=
(
u
)
&
&
(
u
)
<
=
0xd7ff
)
|
|
(
0xf900
<
=
(
u
)
&
&
(
u
)
<
=
0xfaff
)
|
|
(
0xff00
<
=
(
u
)
&
&
(
u
)
<
=
0xffef
)
|
|
(
0x20000
<
=
(
u
)
&
&
(
u
)
<
=
0x2fffd
)
)
;
}
static
inline
bool
IS_NONBREAKABLE_SPACE
(
char16_t
u
)
{
return
u
=
=
0x00A0
|
|
u
=
=
0x2007
;
}
static
inline
bool
IS_HYPHEN
(
char16_t
u
)
{
return
(
u
=
=
U_HYPHEN
|
|
u
=
=
0x2010
|
|
u
=
=
0x2012
|
|
u
=
=
0x2013
|
|
#
if
ANDROID
|
|
XP_WIN
u
=
=
0x0F0B
|
|
#
endif
u
=
=
0x058A
)
;
}
static
int8_t
GetClass
(
uint32_t
u
LineBreaker
:
:
Strictness
aLevel
bool
aIsChineseOrJapanese
)
{
static
const
int8_t
sUnicodeLineBreakToClass
[
]
=
{
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_OPEN_LIKE_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CHARACTER
CLASS_NON_BREAKABLE
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CLOSE_LIKE_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CLOSE_LIKE_CHARACTER
CLASS_NUMERIC
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CHARACTER
CLASS_NON_BREAKABLE
CLASS_BREAKABLE
CLASS_BREAKABLE
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_CLOSE_LIKE_CHARACTER
CLASS_CLOSE
CLASS_CHARACTER
CLASS_CHARACTER
CLASS_BREAKABLE
CLASS_CHARACTER
CLASS_CHARACTER
}
;
static_assert
(
U_LB_COUNT
=
=
mozilla
:
:
ArrayLength
(
sUnicodeLineBreakToClass
)
"
Gecko
vs
ICU
LineBreak
class
mismatch
"
)
;
auto
cls
=
GetLineBreakClass
(
u
)
;
MOZ_ASSERT
(
cls
<
mozilla
:
:
ArrayLength
(
sUnicodeLineBreakToClass
)
)
;
switch
(
aLevel
)
{
case
LineBreaker
:
:
Strictness
:
:
Auto
:
break
;
case
LineBreaker
:
:
Strictness
:
:
Strict
:
if
(
cls
=
=
U_LB_CONDITIONAL_JAPANESE_STARTER
|
|
(
u
=
=
0x3095
|
|
u
=
=
0x3096
|
|
u
=
=
0x30f5
|
|
u
=
=
0x30f6
)
)
{
return
CLASS_CLOSE
;
}
if
(
cls
=
=
U_LB_INSEPARABLE
)
{
return
CLASS_NON_BREAKABLE_BETWEEN_SAME_CLASS
;
}
if
(
u
=
=
0x3005
|
|
u
=
=
0x303B
|
|
u
=
=
0x309D
|
|
u
=
=
0x309E
|
|
u
=
=
0x30FD
|
|
u
=
=
0x30FE
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
if
(
aIsChineseOrJapanese
)
{
if
(
cls
=
=
U_LB_POSTFIX_NUMERIC
&
&
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
if
(
cls
=
=
U_LB_PREFIX_NUMERIC
&
&
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_OPEN_LIKE_CHARACTER
;
}
if
(
u
=
=
0x2010
|
|
u
=
=
0x2013
|
|
u
=
=
0x301C
|
|
u
=
=
0x30A0
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
}
break
;
case
LineBreaker
:
:
Strictness
:
:
Normal
:
if
(
cls
=
=
U_LB_CONDITIONAL_JAPANESE_STARTER
)
{
return
CLASS_BREAKABLE
;
}
if
(
cls
=
=
U_LB_INSEPARABLE
)
{
return
CLASS_NON_BREAKABLE_BETWEEN_SAME_CLASS
;
}
if
(
u
=
=
0x3005
|
|
u
=
=
0x303B
|
|
u
=
=
0x309D
|
|
u
=
=
0x309E
|
|
u
=
=
0x30FD
|
|
u
=
=
0x30FE
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
if
(
aIsChineseOrJapanese
)
{
if
(
cls
=
=
U_LB_POSTFIX_NUMERIC
&
&
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_CLOSE_LIKE_CHARACTER
;
}
if
(
cls
=
=
U_LB_PREFIX_NUMERIC
&
&
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_OPEN_LIKE_CHARACTER
;
}
if
(
u
=
=
0x2010
|
|
u
=
=
0x2013
|
|
u
=
=
0x301C
|
|
u
=
=
0x30A0
)
{
return
CLASS_BREAKABLE
;
}
}
break
;
case
LineBreaker
:
:
Strictness
:
:
Loose
:
if
(
cls
=
=
U_LB_CONDITIONAL_JAPANESE_STARTER
)
{
return
CLASS_BREAKABLE
;
}
if
(
u
=
=
0x3005
|
|
u
=
=
0x303B
|
|
u
=
=
0x309D
|
|
u
=
=
0x309E
|
|
u
=
=
0x30FD
|
|
u
=
=
0x30FE
)
{
return
CLASS_BREAKABLE
;
}
if
(
cls
=
=
U_LB_INSEPARABLE
)
{
return
CLASS_BREAKABLE
;
}
if
(
aIsChineseOrJapanese
)
{
if
(
u
=
=
0x30FB
|
|
u
=
=
0xFF1A
|
|
u
=
=
0xFF1B
|
|
u
=
=
0xFF65
|
|
u
=
=
0x203C
|
|
u
=
=
0x2047
|
|
u
=
=
0x2048
|
|
u
=
=
0x2049
|
|
u
=
=
0xFF01
|
|
u
=
=
0xFF1F
)
{
return
CLASS_BREAKABLE
;
}
if
(
cls
=
=
U_LB_POSTFIX_NUMERIC
&
&
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_BREAKABLE
;
}
if
(
cls
=
=
U_LB_PREFIX_NUMERIC
&
&
IsEastAsianWidthAFW
(
u
)
)
{
return
CLASS_BREAKABLE
;
}
if
(
u
=
=
0x2010
|
|
u
=
=
0x2013
|
|
u
=
=
0x301C
|
|
u
=
=
0x30A0
)
{
return
CLASS_BREAKABLE
;
}
}
break
;
case
LineBreaker
:
:
Strictness
:
:
Anywhere
:
MOZ_ASSERT_UNREACHABLE
(
"
should
have
been
handled
already
"
)
;
break
;
}
if
(
u
<
0x10000
)
{
uint16_t
h
=
u
&
0xFF00
;
uint16_t
l
=
u
&
0x00ff
;
if
(
0x0000
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass00
l
)
;
}
if
(
0x1700
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass17
l
)
;
}
if
(
NS_NeedsPlatformNativeHandling
(
u
)
)
{
return
CLASS_COMPLEX
;
}
if
(
0x0E00
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass0E
l
)
;
}
if
(
0x2000
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass20
l
)
;
}
if
(
0x2100
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass21
l
)
;
}
if
(
0x3000
=
=
h
)
{
return
GETCLASSFROMTABLE
(
gLBClass30
l
)
;
}
if
(
0xff00
=
=
h
)
{
if
(
l
<
=
0x0060
)
{
if
(
l
+
0x20
=
=
'
'
|
|
l
+
0x20
=
=
'
.
'
)
{
return
CLASS_CLOSE
;
}
if
(
l
=
=
0x005f
)
{
return
CLASS_OPEN
;
}
if
(
l
=
=
0x0060
)
{
return
CLASS_CLOSE
;
}
return
GETCLASSFROMTABLE
(
gLBClass00
(
l
+
0x20
)
)
;
}
if
(
l
<
0x00a0
)
{
switch
(
l
)
{
case
0x61
:
return
GetClass
(
0x3002
aLevel
aIsChineseOrJapanese
)
;
case
0x62
:
return
GetClass
(
0x300c
aLevel
aIsChineseOrJapanese
)
;
case
0x63
:
return
GetClass
(
0x300d
aLevel
aIsChineseOrJapanese
)
;
case
0x64
:
return
GetClass
(
0x3001
aLevel
aIsChineseOrJapanese
)
;
case
0x65
:
return
GetClass
(
0x30fb
aLevel
aIsChineseOrJapanese
)
;
case
0x9e
:
return
GetClass
(
0x309b
aLevel
aIsChineseOrJapanese
)
;
case
0x9f
:
return
GetClass
(
0x309c
aLevel
aIsChineseOrJapanese
)
;
default
:
if
(
IS_HALFWIDTH_IN_JISx4051_CLASS3
(
u
)
)
{
return
CLASS_CLOSE
;
}
return
CLASS_BREAKABLE
;
}
}
if
(
l
<
0x00e0
)
{
return
CLASS_CHARACTER
;
}
if
(
l
<
0x00f0
)
{
static
char16_t
NarrowFFEx
[
16
]
=
{
0x00A2
0x00A3
0x00AC
0x00AF
0x00A6
0x00A5
0x20A9
0x0000
0x2502
0x2190
0x2191
0x2192
0x2193
0x25A0
0x25CB
0x0000
}
;
return
GetClass
(
NarrowFFEx
[
l
-
0x00e0
]
aLevel
aIsChineseOrJapanese
)
;
}
}
else
if
(
0x3100
=
=
h
)
{
if
(
l
<
=
0xbf
)
{
return
CLASS_BREAKABLE
;
}
if
(
l
>
=
0xf0
)
{
return
CLASS_CLOSE
;
}
}
else
if
(
0x0300
=
=
h
)
{
if
(
0x4F
=
=
l
|
|
(
0x5C
<
=
l
&
&
l
<
=
0x62
)
)
{
return
CLASS_NON_BREAKABLE
;
}
}
else
if
(
0x0500
=
=
h
)
{
if
(
l
=
=
0x8A
)
{
return
GETCLASSFROMTABLE
(
gLBClass00
uint16_t
(
U_HYPHEN
)
)
;
}
}
else
if
(
0x0F00
=
=
h
)
{
if
(
0x34
=
=
l
|
|
0x7f
=
=
l
|
|
0x85
=
=
l
|
|
0xbe
=
=
l
|
|
0xbf
=
=
l
|
|
0xd2
=
=
l
)
{
return
CLASS_BREAKABLE
;
}
}
else
if
(
0x1800
=
=
h
)
{
if
(
0x0E
=
=
l
)
{
return
CLASS_NON_BREAKABLE
;
}
}
else
if
(
0x1600
=
=
h
)
{
if
(
0x80
=
=
l
)
{
return
CLASS_BREAKABLE
;
}
}
else
if
(
u
=
=
0xfeff
)
{
return
CLASS_NON_BREAKABLE
;
}
}
return
sUnicodeLineBreakToClass
[
cls
]
;
}
static
bool
GetPair
(
int8_t
c1
int8_t
c2
)
{
NS_ASSERTION
(
c1
<
MAX_CLASSES
"
illegal
classes
1
"
)
;
NS_ASSERTION
(
c2
<
MAX_CLASSES
"
illegal
classes
2
"
)
;
return
(
0
=
=
(
(
gPair
[
c1
]
>
>
c2
)
&
0x0001
)
)
;
}
static
bool
GetPairConservative
(
int8_t
c1
int8_t
c2
)
{
NS_ASSERTION
(
c1
<
MAX_CLASSES
"
illegal
classes
1
"
)
;
NS_ASSERTION
(
c2
<
MAX_CLASSES
"
illegal
classes
2
"
)
;
return
(
0
=
=
(
(
gPairConservative
[
c1
]
>
>
c2
)
&
0x0001
)
)
;
}
class
ContextState
{
public
:
ContextState
(
const
char16_t
*
aText
uint32_t
aLength
)
:
mUniText
(
aText
)
mText
(
nullptr
)
mLength
(
aLength
)
{
Init
(
)
;
}
ContextState
(
const
uint8_t
*
aText
uint32_t
aLength
)
:
mUniText
(
nullptr
)
mText
(
aText
)
mLength
(
aLength
)
{
Init
(
)
;
}
uint32_t
Length
(
)
const
{
return
mLength
;
}
uint32_t
Index
(
)
const
{
return
mIndex
;
}
char16_t
GetCodeUnitAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mLength
"
Out
of
range
!
"
)
;
return
mUniText
?
mUniText
[
aIndex
]
:
char16_t
(
mText
[
aIndex
]
)
;
}
char32_t
GetUnicodeCharAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
mUniText
"
Only
for
16
-
bit
text
!
"
)
;
MOZ_ASSERT
(
aIndex
<
mLength
"
Out
of
range
!
"
)
;
char32_t
c
=
mUniText
[
aIndex
]
;
if
(
aIndex
+
1
<
mLength
&
&
NS_IS_SURROGATE_PAIR
(
c
mUniText
[
aIndex
+
1
]
)
)
{
c
=
SURROGATE_TO_UCS4
(
c
mUniText
[
aIndex
+
1
]
)
;
}
return
c
;
}
void
AdvanceIndex
(
)
{
+
+
mIndex
;
}
void
NotifyBreakBefore
(
)
{
mLastBreakIndex
=
mIndex
;
}
#
define
CONSERVATIVE_RANGE_LETTER
2
#
define
CONSERVATIVE_RANGE_OTHER
6
bool
UseConservativeBreaking
(
uint32_t
aOffset
=
0
)
const
{
if
(
mHasCJKChar
)
return
false
;
uint32_t
index
=
mIndex
+
aOffset
;
uint32_t
conservativeRangeStart
conservativeRangeEnd
;
if
(
index
<
mLength
&
&
nsUGenCategory
:
:
kLetter
=
=
(
mText
?
GetGenCategory
(
mText
[
index
]
)
:
GetGenCategory
(
GetUnicodeCharAt
(
index
)
)
)
)
{
conservativeRangeEnd
=
CONSERVATIVE_RANGE_LETTER
;
conservativeRangeStart
=
CONSERVATIVE_RANGE_LETTER
+
1
;
}
else
{
conservativeRangeEnd
=
conservativeRangeStart
=
CONSERVATIVE_RANGE_OTHER
;
}
bool
result
=
(
index
<
conservativeRangeStart
|
|
mLength
-
index
<
conservativeRangeEnd
|
|
index
-
mLastBreakIndex
<
conservativeRangeStart
)
;
if
(
result
|
|
!
mHasNonbreakableSpace
)
return
result
;
for
(
uint32_t
i
=
index
;
index
-
conservativeRangeStart
<
i
;
-
-
i
)
{
if
(
IS_NONBREAKABLE_SPACE
(
GetCodeUnitAt
(
i
-
1
)
)
)
return
true
;
}
for
(
uint32_t
i
=
index
+
1
;
i
<
index
+
conservativeRangeEnd
;
+
+
i
)
{
if
(
IS_NONBREAKABLE_SPACE
(
GetCodeUnitAt
(
i
)
)
)
return
true
;
}
return
false
;
}
bool
HasPreviousEqualsSign
(
)
const
{
return
mHasPreviousEqualsSign
;
}
void
NotifySeenEqualsSign
(
)
{
mHasPreviousEqualsSign
=
true
;
}
bool
HasPreviousSlash
(
)
const
{
return
mHasPreviousSlash
;
}
void
NotifySeenSlash
(
)
{
mHasPreviousSlash
=
true
;
}
bool
HasPreviousBackslash
(
)
const
{
return
mHasPreviousBackslash
;
}
void
NotifySeenBackslash
(
)
{
mHasPreviousBackslash
=
true
;
}
uint32_t
GetPreviousNonHyphenCharacter
(
)
const
{
return
mPreviousNonHyphenCharacter
;
}
void
NotifyNonHyphenCharacter
(
uint32_t
ch
)
{
mPreviousNonHyphenCharacter
=
ch
;
}
private
:
void
Init
(
)
{
mIndex
=
0
;
mLastBreakIndex
=
0
;
mPreviousNonHyphenCharacter
=
U_NULL
;
mHasCJKChar
=
false
;
mHasNonbreakableSpace
=
false
;
mHasPreviousEqualsSign
=
false
;
mHasPreviousSlash
=
false
;
mHasPreviousBackslash
=
false
;
if
(
mText
)
{
for
(
uint32_t
i
=
0
;
i
<
mLength
;
+
+
i
)
{
if
(
IS_NONBREAKABLE_SPACE
(
mText
[
i
]
)
)
{
mHasNonbreakableSpace
=
true
;
break
;
}
}
}
else
{
for
(
uint32_t
i
=
0
;
i
<
mLength
;
+
+
i
)
{
char32_t
u
=
GetUnicodeCharAt
(
i
)
;
if
(
!
mHasNonbreakableSpace
&
&
IS_NONBREAKABLE_SPACE
(
u
)
)
{
mHasNonbreakableSpace
=
true
;
if
(
mHasCJKChar
)
{
break
;
}
}
else
if
(
!
mHasCJKChar
&
&
IS_CJK_CHAR
(
u
)
)
{
mHasCJKChar
=
true
;
if
(
mHasNonbreakableSpace
)
{
break
;
}
}
if
(
u
>
0xFFFFu
)
{
+
+
i
;
}
}
}
}
const
char16_t
*
const
mUniText
;
const
uint8_t
*
const
mText
;
uint32_t
mIndex
;
const
uint32_t
mLength
;
uint32_t
mLastBreakIndex
;
char32_t
mPreviousNonHyphenCharacter
;
bool
mHasCJKChar
;
bool
mHasNonbreakableSpace
;
bool
mHasPreviousEqualsSign
;
bool
mHasPreviousSlash
;
bool
mHasPreviousBackslash
;
}
;
static
int8_t
ContextualAnalysis
(
char32_t
prev
char32_t
cur
char32_t
next
ContextState
&
aState
LineBreaker
:
:
Strictness
aLevel
bool
aIsChineseOrJapanese
)
{
if
(
IS_HYPHEN
(
cur
)
)
{
if
(
IS_HYPHEN
(
next
)
)
return
CLASS_CHARACTER
;
bool
prevIsNum
=
IS_ASCII_DIGIT
(
prev
)
;
bool
nextIsNum
=
IS_ASCII_DIGIT
(
next
)
;
if
(
prevIsNum
&
&
nextIsNum
)
return
CLASS_NUMERIC
;
if
(
!
aState
.
UseConservativeBreaking
(
1
)
)
{
char32_t
prevOfHyphen
=
aState
.
GetPreviousNonHyphenCharacter
(
)
;
if
(
prevOfHyphen
&
&
next
)
{
int8_t
prevClass
=
GetClass
(
prevOfHyphen
aLevel
aIsChineseOrJapanese
)
;
int8_t
nextClass
=
GetClass
(
next
aLevel
aIsChineseOrJapanese
)
;
bool
prevIsNumOrCharOrClose
=
prevIsNum
|
|
(
prevClass
=
=
CLASS_CHARACTER
&
&
!
NEED_CONTEXTUAL_ANALYSIS
(
prevOfHyphen
)
)
|
|
prevClass
=
=
CLASS_CLOSE
|
|
prevClass
=
=
CLASS_CLOSE_LIKE_CHARACTER
;
bool
nextIsNumOrCharOrOpen
=
nextIsNum
|
|
(
nextClass
=
=
CLASS_CHARACTER
&
&
!
NEED_CONTEXTUAL_ANALYSIS
(
next
)
)
|
|
nextClass
=
=
CLASS_OPEN
|
|
nextClass
=
=
CLASS_OPEN_LIKE_CHARACTER
|
|
next
=
=
U_OPEN_SINGLE_QUOTE
|
|
next
=
=
U_OPEN_DOUBLE_QUOTE
|
|
next
=
=
U_OPEN_GUILLEMET
;
if
(
prevIsNumOrCharOrClose
&
&
nextIsNumOrCharOrOpen
)
{
return
CLASS_CLOSE
;
}
}
}
}
else
{
aState
.
NotifyNonHyphenCharacter
(
cur
)
;
if
(
cur
=
=
U_SLASH
|
|
cur
=
=
U_BACKSLASH
)
{
if
(
prev
=
=
cur
)
return
CLASS_CHARACTER
;
bool
shouldReturn
=
!
aState
.
UseConservativeBreaking
(
)
&
&
(
cur
=
=
U_SLASH
?
aState
.
HasPreviousSlash
(
)
:
aState
.
HasPreviousBackslash
(
)
)
;
if
(
cur
=
=
U_SLASH
)
{
aState
.
NotifySeenSlash
(
)
;
}
else
{
aState
.
NotifySeenBackslash
(
)
;
}
if
(
shouldReturn
)
return
CLASS_OPEN
;
}
else
if
(
cur
=
=
U_PERCENT
)
{
if
(
!
aState
.
UseConservativeBreaking
(
)
)
{
if
(
aState
.
Index
(
)
>
=
3
&
&
aState
.
GetCodeUnitAt
(
aState
.
Index
(
)
-
3
)
=
=
U_PERCENT
)
return
CLASS_OPEN
;
if
(
aState
.
Index
(
)
+
3
<
aState
.
Length
(
)
&
&
aState
.
GetCodeUnitAt
(
aState
.
Index
(
)
+
3
)
=
=
U_PERCENT
)
return
CLASS_OPEN
;
}
}
else
if
(
cur
=
=
U_AMPERSAND
|
|
cur
=
=
U_SEMICOLON
)
{
if
(
!
aState
.
UseConservativeBreaking
(
1
)
&
&
aState
.
HasPreviousEqualsSign
(
)
)
return
CLASS_CLOSE
;
}
else
if
(
cur
=
=
U_OPEN_SINGLE_QUOTE
|
|
cur
=
=
U_OPEN_DOUBLE_QUOTE
|
|
cur
=
=
U_OPEN_GUILLEMET
)
{
if
(
!
aState
.
UseConservativeBreaking
(
)
&
&
IS_CJK_CHAR
(
next
)
)
return
CLASS_OPEN
;
}
else
{
NS_ERROR
(
"
Forgot
to
handle
the
current
character
!
"
)
;
}
}
return
GetClass
(
cur
aLevel
aIsChineseOrJapanese
)
;
}
int32_t
LineBreaker
:
:
Next
(
const
char16_t
*
aText
uint32_t
aLen
uint32_t
aPos
)
{
MOZ_ASSERT
(
aText
)
;
if
(
aPos
>
=
aLen
)
{
return
NS_LINEBREAKER_NEED_MORE_TEXT
;
}
bool
textNeedsComplexLineBreak
=
false
;
int32_t
begin
end
;
for
(
begin
=
aPos
;
begin
>
0
&
&
!
NS_IsSpace
(
aText
[
begin
-
1
]
)
;
-
-
begin
)
{
if
(
IS_CJK_CHAR
(
aText
[
begin
]
)
|
|
NS_NeedsPlatformNativeHandling
(
aText
[
begin
]
)
)
{
textNeedsComplexLineBreak
=
true
;
}
}
for
(
end
=
aPos
+
1
;
end
<
int32_t
(
aLen
)
&
&
!
NS_IsSpace
(
aText
[
end
]
)
;
+
+
end
)
{
if
(
IS_CJK_CHAR
(
aText
[
end
]
)
|
|
NS_NeedsPlatformNativeHandling
(
aText
[
end
]
)
)
{
textNeedsComplexLineBreak
=
true
;
}
}
int32_t
ret
;
if
(
!
textNeedsComplexLineBreak
)
{
ret
=
end
;
}
else
{
AutoTArray
<
uint8_t
2000
>
breakState
;
breakState
.
AppendElements
(
end
-
begin
)
;
ComputeBreakPositions
(
aText
+
begin
end
-
begin
WordBreak
:
:
Normal
Strictness
:
:
Auto
false
breakState
.
Elements
(
)
)
;
ret
=
aPos
;
do
{
+
+
ret
;
}
while
(
begin
<
ret
&
&
ret
<
end
&
&
!
breakState
[
ret
-
begin
]
)
;
}
return
ret
;
}
static
bool
SuppressBreakForKeepAll
(
uint32_t
aPrev
uint32_t
aCh
)
{
auto
affectedByKeepAll
=
[
]
(
uint8_t
aLBClass
)
{
switch
(
aLBClass
)
{
case
U_LB_ALPHABETIC
:
case
U_LB_AMBIGUOUS
:
case
U_LB_NUMERIC
:
case
U_LB_IDEOGRAPHIC
:
case
U_LB_H2
:
case
U_LB_H3
:
case
U_LB_JL
:
case
U_LB_JV
:
case
U_LB_JT
:
case
U_LB_CONDITIONAL_JAPANESE_STARTER
:
return
true
;
default
:
return
false
;
}
}
;
return
affectedByKeepAll
(
GetLineBreakClass
(
aPrev
)
)
&
&
affectedByKeepAll
(
GetLineBreakClass
(
aCh
)
)
;
}
void
LineBreaker
:
:
ComputeBreakPositions
(
const
char16_t
*
aChars
uint32_t
aLength
WordBreak
aWordBreak
Strictness
aLevel
bool
aIsChineseOrJapanese
uint8_t
*
aBreakBefore
)
{
uint32_t
cur
;
int8_t
lastClass
=
CLASS_NONE
;
ContextState
state
(
aChars
aLength
)
;
for
(
cur
=
0
;
cur
<
aLength
;
+
+
cur
state
.
AdvanceIndex
(
)
)
{
char32_t
ch
=
state
.
GetUnicodeCharAt
(
cur
)
;
uint32_t
chLen
=
ch
>
0xFFFFu
?
2
:
1
;
int8_t
cl
;
auto
prev
=
[
=
]
(
)
-
>
char32_t
{
if
(
!
cur
)
{
return
0
;
}
char32_t
c
=
aChars
[
cur
-
1
]
;
if
(
cur
>
1
&
&
NS_IS_SURROGATE_PAIR
(
aChars
[
cur
-
2
]
c
)
)
{
c
=
SURROGATE_TO_UCS4
(
aChars
[
cur
-
2
]
c
)
;
}
return
c
;
}
;
if
(
NEED_CONTEXTUAL_ANALYSIS
(
ch
)
)
{
char32_t
next
;
if
(
cur
+
chLen
<
aLength
)
{
next
=
state
.
GetUnicodeCharAt
(
cur
+
chLen
)
;
}
else
{
next
=
0
;
}
cl
=
ContextualAnalysis
(
prev
(
)
ch
next
state
aLevel
aIsChineseOrJapanese
)
;
}
else
{
if
(
ch
=
=
U_EQUAL
)
state
.
NotifySeenEqualsSign
(
)
;
state
.
NotifyNonHyphenCharacter
(
ch
)
;
cl
=
GetClass
(
ch
aLevel
aIsChineseOrJapanese
)
;
}
if
(
aWordBreak
=
=
WordBreak
:
:
BreakAll
&
&
(
cl
=
=
CLASS_CHARACTER
|
|
cl
=
=
CLASS_CLOSE
|
|
cl
=
=
CLASS_CLOSE_LIKE_CHARACTER
|
|
cl
=
=
CLASS_NUMERIC
)
)
{
auto
cls
=
GetLineBreakClass
(
ch
)
;
if
(
cls
=
=
U_LB_ALPHABETIC
|
|
cls
=
=
U_LB_NUMERIC
|
|
cls
=
=
U_LB_AMBIGUOUS
|
|
cls
=
=
U_LB_COMPLEX_CONTEXT
|
|
cls
=
=
U_LB_CONDITIONAL_JAPANESE_STARTER
|
|
(
cls
>
=
U_LB_H2
&
&
cls
<
=
U_LB_JV
)
)
{
cl
=
CLASS_BREAKABLE
;
}
}
bool
allowBreak
=
false
;
if
(
cur
>
0
)
{
NS_ASSERTION
(
CLASS_COMPLEX
!
=
lastClass
|
|
CLASS_COMPLEX
!
=
cl
"
Loop
should
have
prevented
adjacent
complex
chars
here
"
)
;
allowBreak
=
(
state
.
UseConservativeBreaking
(
)
?
GetPairConservative
(
lastClass
cl
)
:
GetPair
(
lastClass
cl
)
)
;
if
(
allowBreak
)
{
if
(
aWordBreak
=
=
WordBreak
:
:
KeepAll
&
&
SuppressBreakForKeepAll
(
prev
(
)
ch
)
)
{
allowBreak
=
false
;
}
if
(
ch
=
=
0x3000
&
&
prev
(
)
=
=
0x3000
&
&
aWordBreak
!
=
WordBreak
:
:
BreakAll
)
{
allowBreak
=
false
;
}
}
}
aBreakBefore
[
cur
]
=
allowBreak
;
if
(
allowBreak
)
state
.
NotifyBreakBefore
(
)
;
lastClass
=
cl
;
if
(
CLASS_COMPLEX
=
=
cl
)
{
uint32_t
end
=
cur
+
chLen
;
while
(
end
<
aLength
)
{
char32_t
c
=
state
.
GetUnicodeCharAt
(
end
)
;
if
(
CLASS_COMPLEX
!
=
GetClass
(
c
aLevel
false
)
)
{
break
;
}
+
+
end
;
if
(
c
>
0xFFFFU
)
{
+
+
end
;
}
}
if
(
aWordBreak
=
=
WordBreak
:
:
BreakAll
)
{
ClusterIterator
ci
(
aChars
+
cur
end
-
cur
)
;
while
(
!
ci
.
AtEnd
(
)
)
{
ci
.
Next
(
)
;
aBreakBefore
[
ci
-
aChars
]
=
true
;
}
}
else
{
ComplexBreaker
:
:
GetBreaks
(
aChars
+
cur
end
-
cur
aBreakBefore
+
cur
)
;
aBreakBefore
[
cur
]
=
allowBreak
;
}
cur
=
end
-
1
;
}
if
(
chLen
=
=
2
)
{
+
+
cur
;
aBreakBefore
[
cur
]
=
false
;
state
.
AdvanceIndex
(
)
;
}
}
}
void
LineBreaker
:
:
ComputeBreakPositions
(
const
uint8_t
*
aChars
uint32_t
aLength
WordBreak
aWordBreak
Strictness
aLevel
bool
aIsChineseOrJapanese
uint8_t
*
aBreakBefore
)
{
uint32_t
cur
;
int8_t
lastClass
=
CLASS_NONE
;
ContextState
state
(
aChars
aLength
)
;
for
(
cur
=
0
;
cur
<
aLength
;
+
+
cur
state
.
AdvanceIndex
(
)
)
{
char32_t
ch
=
aChars
[
cur
]
;
int8_t
cl
;
if
(
NEED_CONTEXTUAL_ANALYSIS
(
ch
)
)
{
cl
=
ContextualAnalysis
(
cur
>
0
?
aChars
[
cur
-
1
]
:
U_NULL
ch
cur
+
1
<
aLength
?
aChars
[
cur
+
1
]
:
U_NULL
state
aLevel
aIsChineseOrJapanese
)
;
}
else
{
if
(
ch
=
=
U_EQUAL
)
state
.
NotifySeenEqualsSign
(
)
;
state
.
NotifyNonHyphenCharacter
(
ch
)
;
cl
=
GetClass
(
ch
aLevel
aIsChineseOrJapanese
)
;
}
if
(
aWordBreak
=
=
WordBreak
:
:
BreakAll
&
&
(
cl
=
=
CLASS_CHARACTER
|
|
cl
=
=
CLASS_CLOSE
|
|
cl
=
=
CLASS_CLOSE_LIKE_CHARACTER
|
|
cl
=
=
CLASS_NUMERIC
)
)
{
auto
cls
=
GetLineBreakClass
(
ch
)
;
if
(
cls
=
=
U_LB_ALPHABETIC
|
|
cls
=
=
U_LB_NUMERIC
|
|
cls
=
=
U_LB_COMPLEX_CONTEXT
)
{
cl
=
CLASS_BREAKABLE
;
}
}
bool
allowBreak
=
false
;
if
(
cur
>
0
)
{
allowBreak
=
(
state
.
UseConservativeBreaking
(
)
?
GetPairConservative
(
lastClass
cl
)
:
GetPair
(
lastClass
cl
)
)
&
&
(
aWordBreak
!
=
WordBreak
:
:
KeepAll
|
|
!
SuppressBreakForKeepAll
(
aChars
[
cur
-
1
]
ch
)
)
;
}
aBreakBefore
[
cur
]
=
allowBreak
;
if
(
allowBreak
)
state
.
NotifyBreakBefore
(
)
;
lastClass
=
cl
;
}
}
