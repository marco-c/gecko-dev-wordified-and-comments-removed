#
ifdef
MOZILLA_INTERNAL_API
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ICUUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
intl
/
FormatBuffer
.
h
"
#
include
"
mozilla
/
intl
/
NumberFormat
.
h
"
#
include
"
mozilla
/
intl
/
NumberParser
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsString
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
intl
:
:
LocaleService
;
void
ICUUtils
:
:
LanguageTagIterForContent
:
:
GetNext
(
nsACString
&
aBCP47LangTag
)
{
if
(
mCurrentFallbackIndex
<
0
)
{
mCurrentFallbackIndex
=
0
;
nsAutoString
lang
;
mContent
-
>
GetLang
(
lang
)
;
if
(
!
lang
.
IsEmpty
(
)
)
{
CopyUTF16toUTF8
(
lang
aBCP47LangTag
)
;
return
;
}
}
if
(
mCurrentFallbackIndex
<
1
)
{
mCurrentFallbackIndex
=
1
;
nsAutoString
lang
;
mContent
-
>
OwnerDoc
(
)
-
>
GetContentLanguage
(
lang
)
;
if
(
!
lang
.
IsEmpty
(
)
)
{
CopyUTF16toUTF8
(
lang
aBCP47LangTag
)
;
return
;
}
}
if
(
mCurrentFallbackIndex
<
2
)
{
mCurrentFallbackIndex
=
2
;
nsAutoCString
appLocale
;
LocaleService
:
:
GetInstance
(
)
-
>
GetAppLocaleAsBCP47
(
aBCP47LangTag
)
;
return
;
}
aBCP47LangTag
.
Truncate
(
)
;
}
bool
ICUUtils
:
:
LocalizeNumber
(
double
aValue
LanguageTagIterForContent
&
aLangTags
nsAString
&
aLocalizedValue
)
{
MOZ_ASSERT
(
aLangTags
.
IsAtStart
(
)
"
Don
'
t
call
Next
(
)
before
passing
"
)
;
nsAutoCString
langTag
;
aLangTags
.
GetNext
(
langTag
)
;
intl
:
:
NumberFormatOptions
options
;
if
(
StaticPrefs
:
:
dom_forms_number_grouping
(
)
)
{
options
.
mGrouping
=
intl
:
:
NumberFormatOptions
:
:
Grouping
:
:
Always
;
}
else
{
options
.
mGrouping
=
intl
:
:
NumberFormatOptions
:
:
Grouping
:
:
Never
;
}
options
.
mFractionDigits
=
Some
(
std
:
:
make_pair
(
0
16
)
)
;
while
(
!
langTag
.
IsEmpty
(
)
)
{
auto
result
=
intl
:
:
NumberFormat
:
:
TryCreate
(
langTag
.
get
(
)
options
)
;
if
(
result
.
isErr
(
)
)
{
aLangTags
.
GetNext
(
langTag
)
;
continue
;
}
UniquePtr
<
intl
:
:
NumberFormat
>
nf
=
result
.
unwrap
(
)
;
intl
:
:
nsTStringToBufferAdapter
adapter
(
aLocalizedValue
)
;
if
(
nf
-
>
format
(
aValue
adapter
)
.
isOk
(
)
)
{
return
true
;
}
aLangTags
.
GetNext
(
langTag
)
;
}
return
false
;
}
double
ICUUtils
:
:
ParseNumber
(
nsAString
&
aValue
LanguageTagIterForContent
&
aLangTags
)
{
MOZ_ASSERT
(
aLangTags
.
IsAtStart
(
)
"
Don
'
t
call
Next
(
)
before
passing
"
)
;
if
(
aValue
.
IsEmpty
(
)
)
{
return
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
;
}
uint32_t
length
=
aValue
.
Length
(
)
;
nsAutoCString
langTag
;
aLangTags
.
GetNext
(
langTag
)
;
while
(
!
langTag
.
IsEmpty
(
)
)
{
auto
createResult
=
intl
:
:
NumberParser
:
:
TryCreate
(
langTag
.
get
(
)
StaticPrefs
:
:
dom_forms_number_grouping
(
)
)
;
if
(
createResult
.
isErr
(
)
)
{
aLangTags
.
GetNext
(
langTag
)
;
continue
;
}
UniquePtr
<
intl
:
:
NumberParser
>
np
=
createResult
.
unwrap
(
)
;
static_assert
(
sizeof
(
UChar
)
=
=
2
&
&
sizeof
(
nsAString
:
:
char_type
)
=
=
2
"
Unexpected
character
size
-
the
following
cast
is
unsafe
"
)
;
auto
parseResult
=
np
-
>
ParseDouble
(
mozilla
:
:
Span
<
const
char16_t
>
(
PromiseFlatString
(
aValue
)
.
get
(
)
length
)
)
;
if
(
parseResult
.
isOk
(
)
)
{
std
:
:
pair
<
double
int32_t
>
parsed
=
parseResult
.
unwrap
(
)
;
if
(
parsed
.
second
=
=
static_cast
<
int32_t
>
(
length
)
)
{
return
parsed
.
first
;
}
}
aLangTags
.
GetNext
(
langTag
)
;
}
return
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
;
}
void
ICUUtils
:
:
AssignUCharArrayToString
(
UChar
*
aICUString
int32_t
aLength
nsAString
&
aMozString
)
{
static_assert
(
sizeof
(
UChar
)
=
=
2
&
&
sizeof
(
nsAString
:
:
char_type
)
=
=
2
"
Unexpected
character
size
-
the
following
cast
is
unsafe
"
)
;
aMozString
.
Assign
(
(
const
nsAString
:
:
char_type
*
)
aICUString
aLength
)
;
NS_ASSERTION
(
(
int32_t
)
aMozString
.
Length
(
)
=
=
aLength
"
Conversion
failed
"
)
;
}
nsresult
ICUUtils
:
:
ICUErrorToNsResult
(
const
intl
:
:
ICUError
aError
)
{
switch
(
aError
)
{
case
intl
:
:
ICUError
:
:
OutOfMemory
:
return
NS_ERROR_OUT_OF_MEMORY
;
default
:
return
NS_ERROR_FAILURE
;
}
}
#
endif
