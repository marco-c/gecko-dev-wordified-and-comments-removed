#
ifdef
MOZILLA_INTERNAL_API
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ICUUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsString
.
h
"
#
include
"
unicode
/
uloc
.
h
"
#
include
"
unicode
/
unum
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
intl
:
:
LocaleService
;
class
NumberFormatDeleter
{
public
:
void
operator
(
)
(
UNumberFormat
*
aPtr
)
{
MOZ_ASSERT
(
aPtr
!
=
nullptr
"
UniquePtr
deleter
shouldn
'
t
be
called
for
nullptr
"
)
;
unum_close
(
aPtr
)
;
}
}
;
using
UniqueUNumberFormat
=
UniquePtr
<
UNumberFormat
NumberFormatDeleter
>
;
void
ICUUtils
:
:
LanguageTagIterForContent
:
:
GetNext
(
nsACString
&
aBCP47LangTag
)
{
if
(
mCurrentFallbackIndex
<
0
)
{
mCurrentFallbackIndex
=
0
;
nsAutoString
lang
;
mContent
-
>
GetLang
(
lang
)
;
if
(
!
lang
.
IsEmpty
(
)
)
{
CopyUTF16toUTF8
(
lang
aBCP47LangTag
)
;
return
;
}
}
if
(
mCurrentFallbackIndex
<
1
)
{
mCurrentFallbackIndex
=
1
;
nsAutoString
lang
;
mContent
-
>
OwnerDoc
(
)
-
>
GetContentLanguage
(
lang
)
;
if
(
!
lang
.
IsEmpty
(
)
)
{
CopyUTF16toUTF8
(
lang
aBCP47LangTag
)
;
return
;
}
}
if
(
mCurrentFallbackIndex
<
2
)
{
mCurrentFallbackIndex
=
2
;
nsAutoCString
appLocale
;
LocaleService
:
:
GetInstance
(
)
-
>
GetAppLocaleAsBCP47
(
aBCP47LangTag
)
;
return
;
}
aBCP47LangTag
.
Truncate
(
)
;
}
bool
ICUUtils
:
:
LocalizeNumber
(
double
aValue
LanguageTagIterForContent
&
aLangTags
nsAString
&
aLocalizedValue
)
{
MOZ_ASSERT
(
aLangTags
.
IsAtStart
(
)
"
Don
'
t
call
Next
(
)
before
passing
"
)
;
static
const
int32_t
kBufferSize
=
256
;
UChar
buffer
[
kBufferSize
]
;
nsAutoCString
langTag
;
aLangTags
.
GetNext
(
langTag
)
;
while
(
!
langTag
.
IsEmpty
(
)
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UniqueUNumberFormat
format
(
unum_open
(
UNUM_DECIMAL
nullptr
0
langTag
.
get
(
)
nullptr
&
status
)
)
;
if
(
U_FAILURE
(
status
)
)
{
aLangTags
.
GetNext
(
langTag
)
;
continue
;
}
unum_setAttribute
(
format
.
get
(
)
UNUM_GROUPING_USED
StaticPrefs
:
:
dom_forms_number_grouping
(
)
)
;
unum_setAttribute
(
format
.
get
(
)
UNUM_MAX_FRACTION_DIGITS
16
)
;
int32_t
length
=
unum_formatDouble
(
format
.
get
(
)
aValue
buffer
kBufferSize
nullptr
&
status
)
;
NS_ASSERTION
(
length
<
kBufferSize
&
&
status
!
=
U_BUFFER_OVERFLOW_ERROR
&
&
status
!
=
U_STRING_NOT_TERMINATED_WARNING
"
Need
a
bigger
buffer
?
!
"
)
;
if
(
U_SUCCESS
(
status
)
)
{
ICUUtils
:
:
AssignUCharArrayToString
(
buffer
length
aLocalizedValue
)
;
return
true
;
}
aLangTags
.
GetNext
(
langTag
)
;
}
return
false
;
}
double
ICUUtils
:
:
ParseNumber
(
nsAString
&
aValue
LanguageTagIterForContent
&
aLangTags
)
{
MOZ_ASSERT
(
aLangTags
.
IsAtStart
(
)
"
Don
'
t
call
Next
(
)
before
passing
"
)
;
if
(
aValue
.
IsEmpty
(
)
)
{
return
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
;
}
uint32_t
length
=
aValue
.
Length
(
)
;
nsAutoCString
langTag
;
aLangTags
.
GetNext
(
langTag
)
;
while
(
!
langTag
.
IsEmpty
(
)
)
{
UErrorCode
status
=
U_ZERO_ERROR
;
UniqueUNumberFormat
format
(
unum_open
(
UNUM_DECIMAL
nullptr
0
langTag
.
get
(
)
nullptr
&
status
)
)
;
if
(
!
StaticPrefs
:
:
dom_forms_number_grouping
(
)
)
{
unum_setAttribute
(
format
.
get
(
)
UNUM_GROUPING_USED
UBool
(
0
)
)
;
}
int32_t
parsePos
=
0
;
static_assert
(
sizeof
(
UChar
)
=
=
2
&
&
sizeof
(
nsAString
:
:
char_type
)
=
=
2
"
Unexpected
character
size
-
the
following
cast
is
unsafe
"
)
;
double
val
=
unum_parseDouble
(
format
.
get
(
)
(
const
UChar
*
)
PromiseFlatString
(
aValue
)
.
get
(
)
length
&
parsePos
&
status
)
;
if
(
U_SUCCESS
(
status
)
&
&
parsePos
=
=
(
int32_t
)
length
)
{
return
val
;
}
aLangTags
.
GetNext
(
langTag
)
;
}
return
std
:
:
numeric_limits
<
float
>
:
:
quiet_NaN
(
)
;
}
void
ICUUtils
:
:
AssignUCharArrayToString
(
UChar
*
aICUString
int32_t
aLength
nsAString
&
aMozString
)
{
static_assert
(
sizeof
(
UChar
)
=
=
2
&
&
sizeof
(
nsAString
:
:
char_type
)
=
=
2
"
Unexpected
character
size
-
the
following
cast
is
unsafe
"
)
;
aMozString
.
Assign
(
(
const
nsAString
:
:
char_type
*
)
aICUString
aLength
)
;
NS_ASSERTION
(
(
int32_t
)
aMozString
.
Length
(
)
=
=
aLength
"
Conversion
failed
"
)
;
}
nsresult
ICUUtils
:
:
UErrorToNsResult
(
const
UErrorCode
aErrorCode
)
{
if
(
U_SUCCESS
(
aErrorCode
)
)
{
return
NS_OK
;
}
switch
(
aErrorCode
)
{
case
U_ILLEGAL_ARGUMENT_ERROR
:
return
NS_ERROR_INVALID_ARG
;
case
U_MEMORY_ALLOCATION_ERROR
:
return
NS_ERROR_OUT_OF_MEMORY
;
default
:
return
NS_ERROR_FAILURE
;
}
}
#
if
0
Locale
ICUUtils
:
:
BCP47CodeToLocale
(
const
nsAString
&
aBCP47Code
)
{
MOZ_ASSERT
(
!
aBCP47Code
.
IsEmpty
(
)
"
Don
'
t
pass
an
empty
BCP
47
code
"
)
;
Locale
locale
;
locale
.
setToBogus
(
)
;
NS_LossyConvertUTF16toASCII
bcp47code
(
aBCP47Code
)
;
UErrorCode
status
=
U_ZERO_ERROR
;
int32_t
needed
;
char
localeID
[
256
]
;
needed
=
uloc_forLanguageTag
(
bcp47code
.
get
(
)
localeID
PR_ARRAY_SIZE
(
localeID
)
-
1
nullptr
&
status
)
;
MOZ_ASSERT
(
needed
<
int32_t
(
PR_ARRAY_SIZE
(
localeID
)
)
-
1
"
Need
a
bigger
buffer
"
)
;
if
(
needed
<
=
0
|
|
U_FAILURE
(
status
)
)
{
return
locale
;
}
char
lang
[
64
]
;
needed
=
uloc_getLanguage
(
localeID
lang
PR_ARRAY_SIZE
(
lang
)
-
1
&
status
)
;
MOZ_ASSERT
(
needed
<
int32_t
(
PR_ARRAY_SIZE
(
lang
)
)
-
1
"
Need
a
bigger
buffer
"
)
;
if
(
needed
<
=
0
|
|
U_FAILURE
(
status
)
)
{
return
locale
;
}
char
country
[
64
]
;
needed
=
uloc_getCountry
(
localeID
country
PR_ARRAY_SIZE
(
country
)
-
1
&
status
)
;
MOZ_ASSERT
(
needed
<
int32_t
(
PR_ARRAY_SIZE
(
country
)
)
-
1
"
Need
a
bigger
buffer
"
)
;
if
(
needed
>
0
&
&
U_SUCCESS
(
status
)
)
{
locale
=
Locale
(
lang
country
)
;
}
if
(
locale
.
isBogus
(
)
)
{
locale
=
Locale
(
lang
)
;
}
return
locale
;
}
void
ICUUtils
:
:
ToMozString
(
UnicodeString
&
aICUString
nsAString
&
aMozString
)
{
static_assert
(
sizeof
(
UChar
)
=
=
2
&
&
sizeof
(
nsAString
:
:
char_type
)
=
=
2
"
Unexpected
character
size
-
the
following
cast
is
unsafe
"
)
;
const
nsAString
:
:
char_type
*
buf
=
(
const
nsAString
:
:
char_type
*
)
aICUString
.
getTerminatedBuffer
(
)
;
aMozString
.
Assign
(
buf
)
;
NS_ASSERTION
(
aMozString
.
Length
(
)
=
=
(
uint32_t
)
aICUString
.
length
(
)
"
Conversion
failed
"
)
;
}
void
ICUUtils
:
:
ToICUString
(
nsAString
&
aMozString
UnicodeString
&
aICUString
)
{
static_assert
(
sizeof
(
UChar
)
=
=
2
&
&
sizeof
(
nsAString
:
:
char_type
)
=
=
2
"
Unexpected
character
size
-
the
following
cast
is
unsafe
"
)
;
aICUString
.
setTo
(
(
UChar
*
)
PromiseFlatString
(
aMozString
)
.
get
(
)
aMozString
.
Length
(
)
)
;
NS_ASSERTION
(
aMozString
.
Length
(
)
=
=
(
uint32_t
)
aICUString
.
length
(
)
"
Conversion
failed
"
)
;
}
#
endif
#
endif
