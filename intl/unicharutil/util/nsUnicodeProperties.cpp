#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsUnicodePropertyData
.
cpp
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
unicode
/
uchar
.
h
"
#
include
"
unicode
/
unorm2
.
h
"
#
define
UNICODE_BMP_LIMIT
0x10000
#
define
UNICODE_LIMIT
0x110000
const
nsCharProps2
&
GetCharProps2
(
uint32_t
aCh
)
{
if
(
aCh
<
UNICODE_BMP_LIMIT
)
{
return
sCharProp2Values
[
sCharProp2Pages
[
0
]
[
aCh
>
>
kCharProp2CharBits
]
]
[
aCh
&
(
(
1
<
<
kCharProp2CharBits
)
-
1
)
]
;
}
if
(
aCh
<
(
kCharProp2MaxPlane
+
1
)
*
0x10000
)
{
return
sCharProp2Values
[
sCharProp2Pages
[
sCharProp2Planes
[
(
aCh
>
>
16
)
-
1
]
]
[
(
aCh
&
0xffff
)
>
>
kCharProp2CharBits
]
]
[
aCh
&
(
(
1
<
<
kCharProp2CharBits
)
-
1
)
]
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Getting
CharProps
for
codepoint
outside
Unicode
"
"
range
"
)
;
using
namespace
mozilla
:
:
unicode
;
static
const
nsCharProps2
undefined
=
{
VERTICAL_ORIENTATION_R
0
}
;
return
undefined
;
}
namespace
mozilla
{
namespace
unicode
{
const
nsUGenCategory
sDetailedToGeneralCategory
[
]
=
{
nsUGenCategory
:
:
kOther
nsUGenCategory
:
:
kOther
nsUGenCategory
:
:
kOther
nsUGenCategory
:
:
kOther
nsUGenCategory
:
:
kOther
nsUGenCategory
:
:
kLetter
nsUGenCategory
:
:
kLetter
nsUGenCategory
:
:
kLetter
nsUGenCategory
:
:
kLetter
nsUGenCategory
:
:
kLetter
nsUGenCategory
:
:
kMark
nsUGenCategory
:
:
kMark
nsUGenCategory
:
:
kMark
nsUGenCategory
:
:
kNumber
nsUGenCategory
:
:
kNumber
nsUGenCategory
:
:
kNumber
nsUGenCategory
:
:
kPunctuation
nsUGenCategory
:
:
kPunctuation
nsUGenCategory
:
:
kPunctuation
nsUGenCategory
:
:
kPunctuation
nsUGenCategory
:
:
kPunctuation
nsUGenCategory
:
:
kPunctuation
nsUGenCategory
:
:
kPunctuation
nsUGenCategory
:
:
kSymbol
nsUGenCategory
:
:
kSymbol
nsUGenCategory
:
:
kSymbol
nsUGenCategory
:
:
kSymbol
nsUGenCategory
:
:
kSeparator
nsUGenCategory
:
:
kSeparator
nsUGenCategory
:
:
kSeparator
}
;
const
hb_unicode_general_category_t
sICUtoHBcategory
[
U_CHAR_CATEGORY_COUNT
]
=
{
HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED
HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER
HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER
HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER
HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER
HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER
HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK
HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK
HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK
HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER
HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER
HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER
HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR
HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR
HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR
HB_UNICODE_GENERAL_CATEGORY_CONTROL
HB_UNICODE_GENERAL_CATEGORY_FORMAT
HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE
HB_UNICODE_GENERAL_CATEGORY_SURROGATE
HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL
HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL
HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL
HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL
HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION
}
;
#
define
DEFINE_BMP_1PLANE_MAPPING_GET_FUNC
(
prefix_
)
\
uint32_t
Get
#
#
prefix_
(
uint32_t
aCh
)
{
\
if
(
aCh
>
=
UNICODE_BMP_LIMIT
)
{
\
return
aCh
;
\
}
\
auto
page
=
s
#
#
prefix_
#
#
Pages
[
aCh
>
>
k
#
#
prefix_
#
#
CharBits
]
;
\
auto
index
=
aCh
&
(
(
1
<
<
k
#
#
prefix_
#
#
CharBits
)
-
1
)
;
\
uint32_t
v
=
s
#
#
prefix_
#
#
Values
[
page
]
[
index
]
;
\
return
v
?
v
:
aCh
;
\
}
DEFINE_BMP_1PLANE_MAPPING_GET_FUNC
(
FullWidth
)
DEFINE_BMP_1PLANE_MAPPING_GET_FUNC
(
FullWidthInverse
)
bool
IsClusterExtender
(
uint32_t
aCh
uint8_t
aCategory
)
{
return
(
(
aCategory
>
=
HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK
&
&
aCategory
<
=
HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK
)
|
|
(
aCh
>
=
0x200c
&
&
aCh
<
=
0x200d
)
|
|
(
aCh
>
=
0xff9e
&
&
aCh
<
=
0xff9f
)
|
|
(
aCh
>
=
0x1F3FB
&
&
aCh
<
=
0x1F3FF
)
|
|
(
aCh
>
=
0xe0020
&
&
aCh
<
=
0xe007f
)
)
;
}
enum
HSType
{
HST_NONE
=
U_HST_NOT_APPLICABLE
HST_L
=
U_HST_LEADING_JAMO
HST_V
=
U_HST_VOWEL_JAMO
HST_T
=
U_HST_TRAILING_JAMO
HST_LV
=
U_HST_LV_SYLLABLE
HST_LVT
=
U_HST_LVT_SYLLABLE
}
;
static
HSType
GetHangulSyllableType
(
uint32_t
aCh
)
{
return
HSType
(
u_getIntPropertyValue
(
aCh
UCHAR_HANGUL_SYLLABLE_TYPE
)
)
;
}
void
ClusterIterator
:
:
Next
(
)
{
if
(
AtEnd
(
)
)
{
NS_WARNING
(
"
ClusterIterator
has
already
reached
the
end
"
)
;
return
;
}
uint32_t
ch
=
*
mPos
+
+
;
if
(
mPos
<
mLimit
&
&
NS_IS_SURROGATE_PAIR
(
ch
*
mPos
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
mPos
+
+
)
;
}
else
if
(
(
ch
&
~
0xff
)
=
=
0x1100
|
|
(
ch
>
=
0xa960
&
&
ch
<
=
0xa97f
)
|
|
(
ch
>
=
0xac00
&
&
ch
<
=
0xd7ff
)
)
{
HSType
hangulState
=
GetHangulSyllableType
(
ch
)
;
while
(
mPos
<
mLimit
)
{
ch
=
*
mPos
;
HSType
hangulType
=
GetHangulSyllableType
(
ch
)
;
switch
(
hangulType
)
{
case
HST_L
:
case
HST_LV
:
case
HST_LVT
:
if
(
hangulState
=
=
HST_L
)
{
hangulState
=
hangulType
;
mPos
+
+
;
continue
;
}
break
;
case
HST_V
:
if
(
(
hangulState
!
=
HST_NONE
)
&
&
(
hangulState
!
=
HST_T
)
&
&
(
hangulState
!
=
HST_LVT
)
)
{
hangulState
=
hangulType
;
mPos
+
+
;
continue
;
}
break
;
case
HST_T
:
if
(
hangulState
!
=
HST_NONE
&
&
hangulState
!
=
HST_L
)
{
hangulState
=
hangulType
;
mPos
+
+
;
continue
;
}
break
;
default
:
break
;
}
break
;
}
}
const
uint32_t
kVS16
=
0xfe0f
;
const
uint32_t
kZWJ
=
0x200d
;
const
uint32_t
kFitzpatrickHigh
=
0xD83C
;
const
uint32_t
kFitzpatrickLowFirst
=
0xDFFB
;
const
uint32_t
kFitzpatrickLowLast
=
0xDFFF
;
bool
baseIsEmoji
=
(
GetEmojiPresentation
(
ch
)
=
=
EmojiDefault
)
|
|
(
GetEmojiPresentation
(
ch
)
=
=
TextDefault
&
&
(
(
mPos
<
mLimit
&
&
*
mPos
=
=
kVS16
)
|
|
(
mPos
+
1
<
mLimit
&
&
*
mPos
=
=
kFitzpatrickHigh
&
&
*
(
mPos
+
1
)
>
=
kFitzpatrickLowFirst
&
&
*
(
mPos
+
1
)
<
=
kFitzpatrickLowLast
)
)
)
;
bool
prevWasZwj
=
false
;
while
(
mPos
<
mLimit
)
{
ch
=
*
mPos
;
size_t
chLen
=
1
;
if
(
mPos
<
mLimit
-
1
&
&
NS_IS_SURROGATE_PAIR
(
ch
*
(
mPos
+
1
)
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
(
mPos
+
1
)
)
;
chLen
=
2
;
}
bool
extendCluster
=
IsClusterExtender
(
ch
)
|
|
(
baseIsEmoji
&
&
prevWasZwj
&
&
(
(
GetEmojiPresentation
(
ch
)
=
=
EmojiDefault
)
|
|
(
GetEmojiPresentation
(
ch
)
=
=
TextDefault
&
&
mPos
+
chLen
<
mLimit
&
&
*
(
mPos
+
chLen
)
=
=
kVS16
)
)
)
;
if
(
!
extendCluster
)
{
break
;
}
prevWasZwj
=
(
ch
=
=
kZWJ
)
;
mPos
+
=
chLen
;
}
NS_ASSERTION
(
mText
<
mPos
&
&
mPos
<
=
mLimit
"
ClusterIterator
:
:
Next
has
overshot
the
string
!
"
)
;
}
void
ClusterReverseIterator
:
:
Next
(
)
{
if
(
AtEnd
(
)
)
{
NS_WARNING
(
"
ClusterReverseIterator
has
already
reached
the
end
"
)
;
return
;
}
uint32_t
ch
;
do
{
ch
=
*
-
-
mPos
;
if
(
mPos
>
mLimit
&
&
NS_IS_SURROGATE_PAIR
(
*
(
mPos
-
1
)
ch
)
)
{
ch
=
SURROGATE_TO_UCS4
(
*
-
-
mPos
ch
)
;
}
if
(
!
IsClusterExtender
(
ch
)
)
{
break
;
}
}
while
(
mPos
>
mLimit
)
;
NS_ASSERTION
(
mPos
>
=
mLimit
"
ClusterReverseIterator
:
:
Next
has
overshot
the
string
!
"
)
;
}
uint32_t
CountGraphemeClusters
(
const
char16_t
*
aText
uint32_t
aLength
)
{
ClusterIterator
iter
(
aText
aLength
)
;
uint32_t
result
=
0
;
while
(
!
iter
.
AtEnd
(
)
)
{
+
+
result
;
iter
.
Next
(
)
;
}
return
result
;
}
uint32_t
GetNaked
(
uint32_t
aCh
)
{
using
namespace
mozilla
;
static
const
UNormalizer2
*
normalizer
;
static
HashMap
<
uint32_t
uint32_t
>
nakedCharCache
;
HashMap
<
uint32_t
uint32_t
>
:
:
Ptr
entry
=
nakedCharCache
.
lookup
(
aCh
)
;
if
(
entry
.
found
(
)
)
{
return
entry
-
>
value
(
)
;
}
UErrorCode
error
=
U_ZERO_ERROR
;
if
(
!
normalizer
)
{
normalizer
=
unorm2_getNFDInstance
(
&
error
)
;
if
(
U_FAILURE
(
error
)
)
{
return
aCh
;
}
}
static
const
size_t
MAX_DECOMPOSITION_SIZE
=
16
;
UChar
decomposition
[
MAX_DECOMPOSITION_SIZE
]
;
UChar
*
combiners
;
int32_t
decompositionLen
;
uint32_t
baseChar
nextChar
;
decompositionLen
=
unorm2_getDecomposition
(
normalizer
aCh
decomposition
MAX_DECOMPOSITION_SIZE
&
error
)
;
if
(
decompositionLen
<
1
)
{
return
aCh
;
}
if
(
u_getIntPropertyValue
(
aCh
UCHAR_GENERAL_CATEGORY
)
&
U_GC_M_MASK
)
{
baseChar
=
aCh
;
goto
cache
;
}
if
(
NS_IS_HIGH_SURROGATE
(
decomposition
[
0
]
)
)
{
baseChar
=
SURROGATE_TO_UCS4
(
decomposition
[
0
]
decomposition
[
1
]
)
;
combiners
=
decomposition
+
2
;
}
else
{
baseChar
=
decomposition
[
0
]
;
combiners
=
decomposition
+
1
;
}
if
(
IS_IN_BMP
(
baseChar
)
!
=
IS_IN_BMP
(
aCh
)
)
{
baseChar
=
aCh
;
goto
cache
;
}
if
(
decompositionLen
>
1
)
{
if
(
NS_IS_HIGH_SURROGATE
(
combiners
[
0
]
)
)
{
nextChar
=
SURROGATE_TO_UCS4
(
combiners
[
0
]
combiners
[
1
]
)
;
}
else
{
nextChar
=
combiners
[
0
]
;
}
if
(
!
IsCombiningDiacritic
(
nextChar
)
)
{
baseChar
=
aCh
;
}
}
cache
:
if
(
!
nakedCharCache
.
putNew
(
aCh
baseChar
)
)
{
nakedCharCache
.
clearAndCompact
(
)
;
}
return
baseChar
;
}
}
}
