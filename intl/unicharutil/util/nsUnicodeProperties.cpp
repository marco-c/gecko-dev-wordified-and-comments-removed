#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsUnicodePropertyData
.
cpp
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsCharTraits
.
h
"
#
define
UNICODE_BMP_LIMIT
0x10000
#
define
UNICODE_LIMIT
0x110000
#
ifndef
ENABLE_INTL_API
static
const
nsCharProps1
&
GetCharProps1
(
uint32_t
aCh
)
{
if
(
aCh
<
UNICODE_BMP_LIMIT
)
{
return
sCharProp1Values
[
sCharProp1Pages
[
0
]
[
aCh
>
>
kCharProp1CharBits
]
]
[
aCh
&
(
(
1
<
<
kCharProp1CharBits
)
-
1
)
]
;
}
if
(
aCh
<
(
kCharProp1MaxPlane
+
1
)
*
0x10000
)
{
return
sCharProp1Values
[
sCharProp1Pages
[
sCharProp1Planes
[
(
aCh
>
>
16
)
-
1
]
]
[
(
aCh
&
0xffff
)
>
>
kCharProp1CharBits
]
]
[
aCh
&
(
(
1
<
<
kCharProp1CharBits
)
-
1
)
]
;
}
static
const
nsCharProps1
undefined
=
{
0
0
0
}
;
return
undefined
;
}
#
endif
const
nsCharProps2
&
GetCharProps2
(
uint32_t
aCh
)
{
if
(
aCh
<
UNICODE_BMP_LIMIT
)
{
return
sCharProp2Values
[
sCharProp2Pages
[
0
]
[
aCh
>
>
kCharProp2CharBits
]
]
[
aCh
&
(
(
1
<
<
kCharProp2CharBits
)
-
1
)
]
;
}
if
(
aCh
<
(
kCharProp2MaxPlane
+
1
)
*
0x10000
)
{
return
sCharProp2Values
[
sCharProp2Pages
[
sCharProp2Planes
[
(
aCh
>
>
16
)
-
1
]
]
[
(
aCh
&
0xffff
)
>
>
kCharProp2CharBits
]
]
[
aCh
&
(
(
1
<
<
kCharProp2CharBits
)
-
1
)
]
;
}
NS_NOTREACHED
(
"
Getting
CharProps
for
codepoint
outside
Unicode
range
"
)
;
using
namespace
mozilla
:
:
unicode
;
static
const
nsCharProps2
undefined
=
{
#
if
ENABLE_INTL_API
PAIRED_BRACKET_TYPE_NONE
VERTICAL_ORIENTATION_R
XIDMOD_NOT_CHARS
#
else
uint8_t
(
Script
:
:
UNKNOWN
)
PAIRED_BRACKET_TYPE_NONE
HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED
eCharType_LeftToRight
XIDMOD_NOT_CHARS
-
1
VERTICAL_ORIENTATION_R
#
endif
}
;
return
undefined
;
}
namespace
mozilla
{
namespace
unicode
{
const
nsIUGenCategory
:
:
nsUGenCategory
sDetailedToGeneralCategory
[
]
=
{
nsIUGenCategory
:
:
kOther
nsIUGenCategory
:
:
kOther
nsIUGenCategory
:
:
kOther
nsIUGenCategory
:
:
kOther
nsIUGenCategory
:
:
kOther
nsIUGenCategory
:
:
kLetter
nsIUGenCategory
:
:
kLetter
nsIUGenCategory
:
:
kLetter
nsIUGenCategory
:
:
kLetter
nsIUGenCategory
:
:
kLetter
nsIUGenCategory
:
:
kMark
nsIUGenCategory
:
:
kMark
nsIUGenCategory
:
:
kMark
nsIUGenCategory
:
:
kNumber
nsIUGenCategory
:
:
kNumber
nsIUGenCategory
:
:
kNumber
nsIUGenCategory
:
:
kPunctuation
nsIUGenCategory
:
:
kPunctuation
nsIUGenCategory
:
:
kPunctuation
nsIUGenCategory
:
:
kPunctuation
nsIUGenCategory
:
:
kPunctuation
nsIUGenCategory
:
:
kPunctuation
nsIUGenCategory
:
:
kPunctuation
nsIUGenCategory
:
:
kSymbol
nsIUGenCategory
:
:
kSymbol
nsIUGenCategory
:
:
kSymbol
nsIUGenCategory
:
:
kSymbol
nsIUGenCategory
:
:
kSeparator
nsIUGenCategory
:
:
kSeparator
nsIUGenCategory
:
:
kSeparator
}
;
#
ifdef
ENABLE_INTL_API
const
hb_unicode_general_category_t
sICUtoHBcategory
[
U_CHAR_CATEGORY_COUNT
]
=
{
HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED
HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER
HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER
HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER
HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER
HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER
HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK
HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK
HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK
HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER
HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER
HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER
HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR
HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR
HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR
HB_UNICODE_GENERAL_CATEGORY_CONTROL
HB_UNICODE_GENERAL_CATEGORY_FORMAT
HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE
HB_UNICODE_GENERAL_CATEGORY_SURROGATE
HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL
HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL
HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL
HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL
HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION
HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION
}
;
#
endif
#
if
!
ENABLE_INTL_API
uint8_t
GetGeneralCategory
(
uint32_t
aCh
)
{
return
GetCharProps2
(
aCh
)
.
mCategory
;
}
nsCharType
GetBidiCat
(
uint32_t
aCh
)
{
return
nsCharType
(
GetCharProps2
(
aCh
)
.
mBidiCategory
)
;
}
int8_t
GetNumericValue
(
uint32_t
aCh
)
{
return
GetCharProps2
(
aCh
)
.
mNumericValue
;
}
uint32_t
GetMirroredChar
(
uint32_t
aCh
)
{
return
aCh
+
sMirrorOffsets
[
GetCharProps1
(
aCh
)
.
mMirrorOffsetIndex
]
;
}
bool
HasMirroredChar
(
uint32_t
aCh
)
{
return
GetCharProps1
(
aCh
)
.
mMirrorOffsetIndex
!
=
0
;
}
uint8_t
GetCombiningClass
(
uint32_t
aCh
)
{
return
GetCharProps1
(
aCh
)
.
mCombiningClass
;
}
uint8_t
GetLineBreakClass
(
uint32_t
aCh
)
{
return
GetCharProps2
(
aCh
)
.
mLineBreak
;
}
Script
GetScriptCode
(
uint32_t
aCh
)
{
return
Script
(
GetCharProps2
(
aCh
)
.
mScriptCode
)
;
}
uint32_t
GetScriptTagForCode
(
Script
aScriptCode
)
{
if
(
static_cast
<
uint32_t
>
(
aScriptCode
)
>
ArrayLength
(
sScriptCodeToTag
)
)
{
return
0
;
}
return
sScriptCodeToTag
[
static_cast
<
uint32_t
>
(
aScriptCode
)
]
;
}
PairedBracketType
GetPairedBracketType
(
uint32_t
aCh
)
{
return
PairedBracketType
(
GetCharProps2
(
aCh
)
.
mPairedBracketType
)
;
}
uint32_t
GetPairedBracket
(
uint32_t
aCh
)
{
return
GetPairedBracketType
(
aCh
)
!
=
PAIRED_BRACKET_TYPE_NONE
?
GetMirroredChar
(
aCh
)
:
aCh
;
}
static
inline
uint32_t
GetCaseMapValue
(
uint32_t
aCh
)
{
if
(
aCh
<
UNICODE_BMP_LIMIT
)
{
return
sCaseMapValues
[
sCaseMapPages
[
0
]
[
aCh
>
>
kCaseMapCharBits
]
]
[
aCh
&
(
(
1
<
<
kCaseMapCharBits
)
-
1
)
]
;
}
if
(
aCh
<
(
kCaseMapMaxPlane
+
1
)
*
0x10000
)
{
return
sCaseMapValues
[
sCaseMapPages
[
sCaseMapPlanes
[
(
aCh
>
>
16
)
-
1
]
]
[
(
aCh
&
0xffff
)
>
>
kCaseMapCharBits
]
]
[
aCh
&
(
(
1
<
<
kCaseMapCharBits
)
-
1
)
]
;
}
return
0
;
}
uint32_t
GetUppercase
(
uint32_t
aCh
)
{
uint32_t
mapValue
=
GetCaseMapValue
(
aCh
)
;
if
(
mapValue
&
(
kLowerToUpper
|
kTitleToUpper
)
)
{
return
aCh
^
(
mapValue
&
kCaseMapCharMask
)
;
}
if
(
mapValue
&
kLowerToTitle
)
{
return
GetUppercase
(
aCh
^
(
mapValue
&
kCaseMapCharMask
)
)
;
}
return
aCh
;
}
uint32_t
GetLowercase
(
uint32_t
aCh
)
{
uint32_t
mapValue
=
GetCaseMapValue
(
aCh
)
;
if
(
mapValue
&
kUpperToLower
)
{
return
aCh
^
(
mapValue
&
kCaseMapCharMask
)
;
}
if
(
mapValue
&
kTitleToUpper
)
{
return
GetLowercase
(
aCh
^
(
mapValue
&
kCaseMapCharMask
)
)
;
}
return
aCh
;
}
uint32_t
GetTitlecaseForLower
(
uint32_t
aCh
)
{
uint32_t
mapValue
=
GetCaseMapValue
(
aCh
)
;
if
(
mapValue
&
(
kLowerToTitle
|
kLowerToUpper
)
)
{
return
aCh
^
(
mapValue
&
kCaseMapCharMask
)
;
}
return
aCh
;
}
uint32_t
GetTitlecaseForAll
(
uint32_t
aCh
)
{
uint32_t
mapValue
=
GetCaseMapValue
(
aCh
)
;
if
(
mapValue
&
(
kLowerToTitle
|
kLowerToUpper
)
)
{
return
aCh
^
(
mapValue
&
kCaseMapCharMask
)
;
}
if
(
mapValue
&
kUpperToLower
)
{
return
GetTitlecaseForLower
(
aCh
^
(
mapValue
&
kCaseMapCharMask
)
)
;
}
return
aCh
;
}
#
endif
#
define
DEFINE_BMP_1PLANE_MAPPING_GET_FUNC
(
prefix_
)
\
uint32_t
Get
#
#
prefix_
(
uint32_t
aCh
)
\
{
\
if
(
aCh
>
=
UNICODE_BMP_LIMIT
)
{
\
return
aCh
;
\
}
\
auto
page
=
s
#
#
prefix_
#
#
Pages
[
aCh
>
>
k
#
#
prefix_
#
#
CharBits
]
;
\
auto
index
=
aCh
&
(
(
1
<
<
k
#
#
prefix_
#
#
CharBits
)
-
1
)
;
\
uint32_t
v
=
s
#
#
prefix_
#
#
Values
[
page
]
[
index
]
;
\
return
v
?
v
:
aCh
;
\
}
DEFINE_BMP_1PLANE_MAPPING_GET_FUNC
(
FullWidth
)
DEFINE_BMP_1PLANE_MAPPING_GET_FUNC
(
FullWidthInverse
)
bool
IsClusterExtender
(
uint32_t
aCh
uint8_t
aCategory
)
{
return
(
(
aCategory
>
=
HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK
&
&
aCategory
<
=
HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK
)
|
|
(
aCh
>
=
0x200c
&
&
aCh
<
=
0x200d
)
|
|
(
aCh
>
=
0xff9e
&
&
aCh
<
=
0xff9f
)
)
;
}
enum
HSType
{
#
if
ENABLE_INTL_API
HST_NONE
=
U_HST_NOT_APPLICABLE
HST_L
=
U_HST_LEADING_JAMO
HST_V
=
U_HST_VOWEL_JAMO
HST_T
=
U_HST_TRAILING_JAMO
HST_LV
=
U_HST_LV_SYLLABLE
HST_LVT
=
U_HST_LVT_SYLLABLE
#
else
HST_NONE
=
0x00
HST_L
=
0x01
HST_V
=
0x02
HST_T
=
0x04
HST_LV
=
0x03
HST_LVT
=
0x07
#
endif
}
;
static
HSType
GetHangulSyllableType
(
uint32_t
aCh
)
{
#
if
ENABLE_INTL_API
return
HSType
(
u_getIntPropertyValue
(
aCh
UCHAR_HANGUL_SYLLABLE_TYPE
)
)
;
#
else
return
HSType
(
GetCharProps1
(
aCh
)
.
mHangulType
)
;
#
endif
}
void
ClusterIterator
:
:
Next
(
)
{
if
(
AtEnd
(
)
)
{
NS_WARNING
(
"
ClusterIterator
has
already
reached
the
end
"
)
;
return
;
}
uint32_t
ch
=
*
mPos
+
+
;
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
&
&
mPos
<
mLimit
&
&
NS_IS_LOW_SURROGATE
(
*
mPos
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
mPos
+
+
)
;
}
else
if
(
(
ch
&
~
0xff
)
=
=
0x1100
|
|
(
ch
>
=
0xa960
&
&
ch
<
=
0xa97f
)
|
|
(
ch
>
=
0xac00
&
&
ch
<
=
0xd7ff
)
)
{
HSType
hangulState
=
GetHangulSyllableType
(
ch
)
;
while
(
mPos
<
mLimit
)
{
ch
=
*
mPos
;
HSType
hangulType
=
GetHangulSyllableType
(
ch
)
;
switch
(
hangulType
)
{
case
HST_L
:
case
HST_LV
:
case
HST_LVT
:
if
(
hangulState
=
=
HST_L
)
{
hangulState
=
hangulType
;
mPos
+
+
;
continue
;
}
break
;
case
HST_V
:
if
(
(
hangulState
!
=
HST_NONE
)
&
&
(
hangulState
!
=
HST_T
)
&
&
(
hangulState
!
=
HST_LVT
)
)
{
hangulState
=
hangulType
;
mPos
+
+
;
continue
;
}
break
;
case
HST_T
:
if
(
hangulState
!
=
HST_NONE
&
&
hangulState
!
=
HST_L
)
{
hangulState
=
hangulType
;
mPos
+
+
;
continue
;
}
break
;
default
:
break
;
}
break
;
}
}
while
(
mPos
<
mLimit
)
{
ch
=
*
mPos
;
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
&
&
mPos
<
mLimit
-
1
&
&
NS_IS_LOW_SURROGATE
(
*
(
mPos
+
1
)
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
(
mPos
+
1
)
)
;
}
if
(
!
IsClusterExtender
(
ch
)
)
{
break
;
}
mPos
+
+
;
if
(
!
IS_IN_BMP
(
ch
)
)
{
mPos
+
+
;
}
}
NS_ASSERTION
(
mText
<
mPos
&
&
mPos
<
=
mLimit
"
ClusterIterator
:
:
Next
has
overshot
the
string
!
"
)
;
}
void
ClusterReverseIterator
:
:
Next
(
)
{
if
(
AtEnd
(
)
)
{
NS_WARNING
(
"
ClusterReverseIterator
has
already
reached
the
end
"
)
;
return
;
}
uint32_t
ch
;
do
{
ch
=
*
-
-
mPos
;
if
(
NS_IS_LOW_SURROGATE
(
ch
)
&
&
mPos
>
mLimit
&
&
NS_IS_HIGH_SURROGATE
(
*
(
mPos
-
1
)
)
)
{
ch
=
SURROGATE_TO_UCS4
(
*
-
-
mPos
ch
)
;
}
if
(
!
IsClusterExtender
(
ch
)
)
{
break
;
}
}
while
(
mPos
>
mLimit
)
;
NS_ASSERTION
(
mPos
>
=
mLimit
"
ClusterReverseIterator
:
:
Next
has
overshot
the
string
!
"
)
;
}
uint32_t
CountGraphemeClusters
(
const
char16_t
*
aText
uint32_t
aLength
)
{
ClusterIterator
iter
(
aText
aLength
)
;
uint32_t
result
=
0
;
while
(
!
iter
.
AtEnd
(
)
)
{
+
+
result
;
iter
.
Next
(
)
;
}
return
result
;
}
}
}
