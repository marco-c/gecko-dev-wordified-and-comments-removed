#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
<
stdlib
.
h
>
#
include
"
main_FLP
.
h
"
#
include
"
tuning_parameters
.
h
"
#
include
"
stack_alloc
.
h
"
static
OPUS_INLINE
void
silk_LBRR_encode_FLP
(
silk_encoder_state_FLP
*
psEnc
silk_encoder_control_FLP
*
psEncCtrl
const
silk_float
xfw
[
]
opus_int
condCoding
)
;
void
silk_encode_do_VAD_FLP
(
silk_encoder_state_FLP
*
psEnc
opus_int
activity
)
{
const
opus_int
activity_threshold
=
SILK_FIX_CONST
(
SPEECH_ACTIVITY_DTX_THRES
8
)
;
silk_VAD_GetSA_Q8
(
&
psEnc
-
>
sCmn
psEnc
-
>
sCmn
.
inputBuf
+
1
psEnc
-
>
sCmn
.
arch
)
;
if
(
activity
=
=
VAD_NO_ACTIVITY
&
&
psEnc
-
>
sCmn
.
speech_activity_Q8
>
=
activity_threshold
)
{
psEnc
-
>
sCmn
.
speech_activity_Q8
=
activity_threshold
-
1
;
}
if
(
psEnc
-
>
sCmn
.
speech_activity_Q8
<
activity_threshold
)
{
psEnc
-
>
sCmn
.
indices
.
signalType
=
TYPE_NO_VOICE_ACTIVITY
;
psEnc
-
>
sCmn
.
noSpeechCounter
+
+
;
if
(
psEnc
-
>
sCmn
.
noSpeechCounter
<
=
NB_SPEECH_FRAMES_BEFORE_DTX
)
{
psEnc
-
>
sCmn
.
inDTX
=
0
;
}
else
if
(
psEnc
-
>
sCmn
.
noSpeechCounter
>
MAX_CONSECUTIVE_DTX
+
NB_SPEECH_FRAMES_BEFORE_DTX
)
{
psEnc
-
>
sCmn
.
noSpeechCounter
=
NB_SPEECH_FRAMES_BEFORE_DTX
;
psEnc
-
>
sCmn
.
inDTX
=
0
;
}
psEnc
-
>
sCmn
.
VAD_flags
[
psEnc
-
>
sCmn
.
nFramesEncoded
]
=
0
;
}
else
{
psEnc
-
>
sCmn
.
noSpeechCounter
=
0
;
psEnc
-
>
sCmn
.
inDTX
=
0
;
psEnc
-
>
sCmn
.
indices
.
signalType
=
TYPE_UNVOICED
;
psEnc
-
>
sCmn
.
VAD_flags
[
psEnc
-
>
sCmn
.
nFramesEncoded
]
=
1
;
}
}
opus_int
silk_encode_frame_FLP
(
silk_encoder_state_FLP
*
psEnc
opus_int32
*
pnBytesOut
ec_enc
*
psRangeEnc
opus_int
condCoding
opus_int
maxBits
opus_int
useCBR
)
{
silk_encoder_control_FLP
sEncCtrl
;
opus_int
i
iter
maxIter
found_upper
found_lower
ret
=
0
;
silk_float
*
x_frame
*
res_pitch_frame
;
silk_float
res_pitch
[
2
*
MAX_FRAME_LENGTH
+
LA_PITCH_MAX
]
;
ec_enc
sRangeEnc_copy
sRangeEnc_copy2
;
VARDECL
(
silk_nsq_state
sNSQ_copy
)
;
opus_int32
seed_copy
nBits
nBits_lower
nBits_upper
gainMult_lower
gainMult_upper
;
opus_int32
gainsID
gainsID_lower
gainsID_upper
;
opus_int16
gainMult_Q8
;
opus_int16
ec_prevLagIndex_copy
;
opus_int
ec_prevSignalType_copy
;
opus_int8
LastGainIndex_copy2
;
opus_int32
pGains_Q16
[
MAX_NB_SUBFR
]
;
opus_int
gain_lock
[
MAX_NB_SUBFR
]
=
{
0
}
;
opus_int16
best_gain_mult
[
MAX_NB_SUBFR
]
;
opus_int
best_sum
[
MAX_NB_SUBFR
]
;
opus_int
bits_margin
;
SAVE_STACK
;
ALLOC
(
sNSQ_copy
2
silk_nsq_state
)
;
bits_margin
=
useCBR
?
5
:
maxBits
/
4
;
LastGainIndex_copy2
=
nBits_lower
=
nBits_upper
=
gainMult_lower
=
gainMult_upper
=
0
;
psEnc
-
>
sCmn
.
indices
.
Seed
=
psEnc
-
>
sCmn
.
frameCounter
+
+
&
3
;
x_frame
=
psEnc
-
>
x_buf
+
psEnc
-
>
sCmn
.
ltp_mem_length
;
res_pitch_frame
=
res_pitch
+
psEnc
-
>
sCmn
.
ltp_mem_length
;
silk_LP_variable_cutoff
(
&
psEnc
-
>
sCmn
.
sLP
psEnc
-
>
sCmn
.
inputBuf
+
1
psEnc
-
>
sCmn
.
frame_length
)
;
silk_short2float_array
(
x_frame
+
LA_SHAPE_MS
*
psEnc
-
>
sCmn
.
fs_kHz
psEnc
-
>
sCmn
.
inputBuf
+
1
psEnc
-
>
sCmn
.
frame_length
)
;
for
(
i
=
0
;
i
<
8
;
i
+
+
)
{
x_frame
[
LA_SHAPE_MS
*
psEnc
-
>
sCmn
.
fs_kHz
+
i
*
(
psEnc
-
>
sCmn
.
frame_length
>
>
3
)
]
+
=
(
1
-
(
i
&
2
)
)
*
1e
-
6f
;
}
if
(
!
psEnc
-
>
sCmn
.
prefillFlag
)
{
VARDECL
(
opus_uint8
ec_buf_copy
)
;
silk_find_pitch_lags_FLP
(
psEnc
&
sEncCtrl
res_pitch
x_frame
psEnc
-
>
sCmn
.
arch
)
;
silk_noise_shape_analysis_FLP
(
psEnc
&
sEncCtrl
res_pitch_frame
x_frame
)
;
silk_find_pred_coefs_FLP
(
psEnc
&
sEncCtrl
res_pitch_frame
x_frame
condCoding
)
;
silk_process_gains_FLP
(
psEnc
&
sEncCtrl
condCoding
)
;
silk_LBRR_encode_FLP
(
psEnc
&
sEncCtrl
x_frame
condCoding
)
;
maxIter
=
6
;
gainMult_Q8
=
SILK_FIX_CONST
(
1
8
)
;
found_lower
=
0
;
found_upper
=
0
;
gainsID
=
silk_gains_ID
(
psEnc
-
>
sCmn
.
indices
.
GainsIndices
psEnc
-
>
sCmn
.
nb_subfr
)
;
gainsID_lower
=
-
1
;
gainsID_upper
=
-
1
;
silk_memcpy
(
&
sRangeEnc_copy
psRangeEnc
sizeof
(
ec_enc
)
)
;
silk_memcpy
(
&
sNSQ_copy
[
0
]
&
psEnc
-
>
sCmn
.
sNSQ
sizeof
(
silk_nsq_state
)
)
;
seed_copy
=
psEnc
-
>
sCmn
.
indices
.
Seed
;
ec_prevLagIndex_copy
=
psEnc
-
>
sCmn
.
ec_prevLagIndex
;
ec_prevSignalType_copy
=
psEnc
-
>
sCmn
.
ec_prevSignalType
;
ALLOC
(
ec_buf_copy
1275
opus_uint8
)
;
for
(
iter
=
0
;
;
iter
+
+
)
{
if
(
gainsID
=
=
gainsID_lower
)
{
nBits
=
nBits_lower
;
}
else
if
(
gainsID
=
=
gainsID_upper
)
{
nBits
=
nBits_upper
;
}
else
{
if
(
iter
>
0
)
{
silk_memcpy
(
psRangeEnc
&
sRangeEnc_copy
sizeof
(
ec_enc
)
)
;
silk_memcpy
(
&
psEnc
-
>
sCmn
.
sNSQ
&
sNSQ_copy
[
0
]
sizeof
(
silk_nsq_state
)
)
;
psEnc
-
>
sCmn
.
indices
.
Seed
=
seed_copy
;
psEnc
-
>
sCmn
.
ec_prevLagIndex
=
ec_prevLagIndex_copy
;
psEnc
-
>
sCmn
.
ec_prevSignalType
=
ec_prevSignalType_copy
;
}
silk_NSQ_wrapper_FLP
(
psEnc
&
sEncCtrl
&
psEnc
-
>
sCmn
.
indices
&
psEnc
-
>
sCmn
.
sNSQ
psEnc
-
>
sCmn
.
pulses
x_frame
)
;
if
(
iter
=
=
maxIter
&
&
!
found_lower
)
{
silk_memcpy
(
&
sRangeEnc_copy2
psRangeEnc
sizeof
(
ec_enc
)
)
;
}
silk_encode_indices
(
&
psEnc
-
>
sCmn
psRangeEnc
psEnc
-
>
sCmn
.
nFramesEncoded
0
condCoding
)
;
silk_encode_pulses
(
psRangeEnc
psEnc
-
>
sCmn
.
indices
.
signalType
psEnc
-
>
sCmn
.
indices
.
quantOffsetType
psEnc
-
>
sCmn
.
pulses
psEnc
-
>
sCmn
.
frame_length
)
;
nBits
=
ec_tell
(
psRangeEnc
)
;
if
(
iter
=
=
maxIter
&
&
!
found_lower
&
&
nBits
>
maxBits
)
{
silk_memcpy
(
psRangeEnc
&
sRangeEnc_copy2
sizeof
(
ec_enc
)
)
;
psEnc
-
>
sShape
.
LastGainIndex
=
sEncCtrl
.
lastGainIndexPrev
;
for
(
i
=
0
;
i
<
psEnc
-
>
sCmn
.
nb_subfr
;
i
+
+
)
{
psEnc
-
>
sCmn
.
indices
.
GainsIndices
[
i
]
=
4
;
}
if
(
condCoding
!
=
CODE_CONDITIONALLY
)
{
psEnc
-
>
sCmn
.
indices
.
GainsIndices
[
0
]
=
sEncCtrl
.
lastGainIndexPrev
;
}
psEnc
-
>
sCmn
.
ec_prevLagIndex
=
ec_prevLagIndex_copy
;
psEnc
-
>
sCmn
.
ec_prevSignalType
=
ec_prevSignalType_copy
;
for
(
i
=
0
;
i
<
psEnc
-
>
sCmn
.
frame_length
;
i
+
+
)
{
psEnc
-
>
sCmn
.
pulses
[
i
]
=
0
;
}
silk_encode_indices
(
&
psEnc
-
>
sCmn
psRangeEnc
psEnc
-
>
sCmn
.
nFramesEncoded
0
condCoding
)
;
silk_encode_pulses
(
psRangeEnc
psEnc
-
>
sCmn
.
indices
.
signalType
psEnc
-
>
sCmn
.
indices
.
quantOffsetType
psEnc
-
>
sCmn
.
pulses
psEnc
-
>
sCmn
.
frame_length
)
;
nBits
=
ec_tell
(
psRangeEnc
)
;
}
if
(
useCBR
=
=
0
&
&
iter
=
=
0
&
&
nBits
<
=
maxBits
)
{
break
;
}
}
if
(
iter
=
=
maxIter
)
{
if
(
found_lower
&
&
(
gainsID
=
=
gainsID_lower
|
|
nBits
>
maxBits
)
)
{
silk_memcpy
(
psRangeEnc
&
sRangeEnc_copy2
sizeof
(
ec_enc
)
)
;
celt_assert
(
sRangeEnc_copy2
.
offs
<
=
1275
)
;
silk_memcpy
(
psRangeEnc
-
>
buf
ec_buf_copy
sRangeEnc_copy2
.
offs
)
;
silk_memcpy
(
&
psEnc
-
>
sCmn
.
sNSQ
&
sNSQ_copy
[
1
]
sizeof
(
silk_nsq_state
)
)
;
psEnc
-
>
sShape
.
LastGainIndex
=
LastGainIndex_copy2
;
}
break
;
}
if
(
nBits
>
maxBits
)
{
if
(
found_lower
=
=
0
&
&
iter
>
=
2
)
{
sEncCtrl
.
Lambda
=
silk_max_float
(
sEncCtrl
.
Lambda
*
1
.
5f
1
.
5f
)
;
psEnc
-
>
sCmn
.
indices
.
quantOffsetType
=
0
;
found_upper
=
0
;
gainsID_upper
=
-
1
;
}
else
{
found_upper
=
1
;
nBits_upper
=
nBits
;
gainMult_upper
=
gainMult_Q8
;
gainsID_upper
=
gainsID
;
}
}
else
if
(
nBits
<
maxBits
-
bits_margin
)
{
found_lower
=
1
;
nBits_lower
=
nBits
;
gainMult_lower
=
gainMult_Q8
;
if
(
gainsID
!
=
gainsID_lower
)
{
gainsID_lower
=
gainsID
;
silk_memcpy
(
&
sRangeEnc_copy2
psRangeEnc
sizeof
(
ec_enc
)
)
;
celt_assert
(
psRangeEnc
-
>
offs
<
=
1275
)
;
silk_memcpy
(
ec_buf_copy
psRangeEnc
-
>
buf
psRangeEnc
-
>
offs
)
;
silk_memcpy
(
&
sNSQ_copy
[
1
]
&
psEnc
-
>
sCmn
.
sNSQ
sizeof
(
silk_nsq_state
)
)
;
LastGainIndex_copy2
=
psEnc
-
>
sShape
.
LastGainIndex
;
}
}
else
{
break
;
}
if
(
!
found_lower
&
&
nBits
>
maxBits
)
{
int
j
;
for
(
i
=
0
;
i
<
psEnc
-
>
sCmn
.
nb_subfr
;
i
+
+
)
{
int
sum
=
0
;
for
(
j
=
i
*
psEnc
-
>
sCmn
.
subfr_length
;
j
<
(
i
+
1
)
*
psEnc
-
>
sCmn
.
subfr_length
;
j
+
+
)
{
sum
+
=
abs
(
psEnc
-
>
sCmn
.
pulses
[
j
]
)
;
}
if
(
iter
=
=
0
|
|
(
sum
<
best_sum
[
i
]
&
&
!
gain_lock
[
i
]
)
)
{
best_sum
[
i
]
=
sum
;
best_gain_mult
[
i
]
=
gainMult_Q8
;
}
else
{
gain_lock
[
i
]
=
1
;
}
}
}
if
(
(
found_lower
&
found_upper
)
=
=
0
)
{
if
(
nBits
>
maxBits
)
{
gainMult_Q8
=
silk_min_32
(
1024
gainMult_Q8
*
3
/
2
)
;
}
else
{
gainMult_Q8
=
silk_max_32
(
64
gainMult_Q8
*
4
/
5
)
;
}
}
else
{
gainMult_Q8
=
gainMult_lower
+
(
(
gainMult_upper
-
gainMult_lower
)
*
(
maxBits
-
nBits_lower
)
)
/
(
nBits_upper
-
nBits_lower
)
;
if
(
gainMult_Q8
>
silk_ADD_RSHIFT32
(
gainMult_lower
gainMult_upper
-
gainMult_lower
2
)
)
{
gainMult_Q8
=
silk_ADD_RSHIFT32
(
gainMult_lower
gainMult_upper
-
gainMult_lower
2
)
;
}
else
if
(
gainMult_Q8
<
silk_SUB_RSHIFT32
(
gainMult_upper
gainMult_upper
-
gainMult_lower
2
)
)
{
gainMult_Q8
=
silk_SUB_RSHIFT32
(
gainMult_upper
gainMult_upper
-
gainMult_lower
2
)
;
}
}
for
(
i
=
0
;
i
<
psEnc
-
>
sCmn
.
nb_subfr
;
i
+
+
)
{
opus_int16
tmp
;
if
(
gain_lock
[
i
]
)
{
tmp
=
best_gain_mult
[
i
]
;
}
else
{
tmp
=
gainMult_Q8
;
}
pGains_Q16
[
i
]
=
silk_LSHIFT_SAT32
(
silk_SMULWB
(
sEncCtrl
.
GainsUnq_Q16
[
i
]
tmp
)
8
)
;
}
psEnc
-
>
sShape
.
LastGainIndex
=
sEncCtrl
.
lastGainIndexPrev
;
silk_gains_quant
(
psEnc
-
>
sCmn
.
indices
.
GainsIndices
pGains_Q16
&
psEnc
-
>
sShape
.
LastGainIndex
condCoding
=
=
CODE_CONDITIONALLY
psEnc
-
>
sCmn
.
nb_subfr
)
;
gainsID
=
silk_gains_ID
(
psEnc
-
>
sCmn
.
indices
.
GainsIndices
psEnc
-
>
sCmn
.
nb_subfr
)
;
for
(
i
=
0
;
i
<
psEnc
-
>
sCmn
.
nb_subfr
;
i
+
+
)
{
sEncCtrl
.
Gains
[
i
]
=
pGains_Q16
[
i
]
/
65536
.
0f
;
}
}
}
silk_memmove
(
psEnc
-
>
x_buf
&
psEnc
-
>
x_buf
[
psEnc
-
>
sCmn
.
frame_length
]
(
psEnc
-
>
sCmn
.
ltp_mem_length
+
LA_SHAPE_MS
*
psEnc
-
>
sCmn
.
fs_kHz
)
*
sizeof
(
silk_float
)
)
;
if
(
psEnc
-
>
sCmn
.
prefillFlag
)
{
*
pnBytesOut
=
0
;
RESTORE_STACK
;
return
ret
;
}
psEnc
-
>
sCmn
.
prevLag
=
sEncCtrl
.
pitchL
[
psEnc
-
>
sCmn
.
nb_subfr
-
1
]
;
psEnc
-
>
sCmn
.
prevSignalType
=
psEnc
-
>
sCmn
.
indices
.
signalType
;
psEnc
-
>
sCmn
.
first_frame_after_reset
=
0
;
*
pnBytesOut
=
silk_RSHIFT
(
ec_tell
(
psRangeEnc
)
+
7
3
)
;
RESTORE_STACK
;
return
ret
;
}
static
OPUS_INLINE
void
silk_LBRR_encode_FLP
(
silk_encoder_state_FLP
*
psEnc
silk_encoder_control_FLP
*
psEncCtrl
const
silk_float
xfw
[
]
opus_int
condCoding
)
{
opus_int
k
;
opus_int32
Gains_Q16
[
MAX_NB_SUBFR
]
;
silk_float
TempGains
[
MAX_NB_SUBFR
]
;
SideInfoIndices
*
psIndices_LBRR
=
&
psEnc
-
>
sCmn
.
indices_LBRR
[
psEnc
-
>
sCmn
.
nFramesEncoded
]
;
VARDECL
(
silk_nsq_state
sNSQ_LBRR
)
;
SAVE_STACK
;
ALLOC
(
sNSQ_LBRR
1
silk_nsq_state
)
;
if
(
psEnc
-
>
sCmn
.
LBRR_enabled
&
&
psEnc
-
>
sCmn
.
speech_activity_Q8
>
SILK_FIX_CONST
(
LBRR_SPEECH_ACTIVITY_THRES
8
)
)
{
psEnc
-
>
sCmn
.
LBRR_flags
[
psEnc
-
>
sCmn
.
nFramesEncoded
]
=
1
;
silk_memcpy
(
&
sNSQ_LBRR
[
0
]
&
psEnc
-
>
sCmn
.
sNSQ
sizeof
(
silk_nsq_state
)
)
;
silk_memcpy
(
psIndices_LBRR
&
psEnc
-
>
sCmn
.
indices
sizeof
(
SideInfoIndices
)
)
;
silk_memcpy
(
TempGains
psEncCtrl
-
>
Gains
psEnc
-
>
sCmn
.
nb_subfr
*
sizeof
(
silk_float
)
)
;
if
(
psEnc
-
>
sCmn
.
nFramesEncoded
=
=
0
|
|
psEnc
-
>
sCmn
.
LBRR_flags
[
psEnc
-
>
sCmn
.
nFramesEncoded
-
1
]
=
=
0
)
{
psEnc
-
>
sCmn
.
LBRRprevLastGainIndex
=
psEnc
-
>
sShape
.
LastGainIndex
;
psIndices_LBRR
-
>
GainsIndices
[
0
]
+
=
psEnc
-
>
sCmn
.
LBRR_GainIncreases
;
psIndices_LBRR
-
>
GainsIndices
[
0
]
=
silk_min_int
(
psIndices_LBRR
-
>
GainsIndices
[
0
]
N_LEVELS_QGAIN
-
1
)
;
}
silk_gains_dequant
(
Gains_Q16
psIndices_LBRR
-
>
GainsIndices
&
psEnc
-
>
sCmn
.
LBRRprevLastGainIndex
condCoding
=
=
CODE_CONDITIONALLY
psEnc
-
>
sCmn
.
nb_subfr
)
;
for
(
k
=
0
;
k
<
psEnc
-
>
sCmn
.
nb_subfr
;
k
+
+
)
{
psEncCtrl
-
>
Gains
[
k
]
=
Gains_Q16
[
k
]
*
(
1
.
0f
/
65536
.
0f
)
;
}
silk_NSQ_wrapper_FLP
(
psEnc
psEncCtrl
psIndices_LBRR
&
sNSQ_LBRR
[
0
]
psEnc
-
>
sCmn
.
pulses_LBRR
[
psEnc
-
>
sCmn
.
nFramesEncoded
]
xfw
)
;
silk_memcpy
(
psEncCtrl
-
>
Gains
TempGains
psEnc
-
>
sCmn
.
nb_subfr
*
sizeof
(
silk_float
)
)
;
}
RESTORE_STACK
;
}
