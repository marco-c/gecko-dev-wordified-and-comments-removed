#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
"
SigProc_FLP
.
h
"
#
include
<
immintrin
.
h
>
double
silk_inner_product_FLP_avx2
(
const
silk_float
*
data1
const
silk_float
*
data2
opus_int
dataSize
)
{
opus_int
i
;
__m256d
accum1
accum2
;
double
result
;
result
=
0
.
0
;
accum1
=
accum2
=
_mm256_setzero_pd
(
)
;
for
(
i
=
0
;
i
<
dataSize
-
7
;
i
+
=
8
)
{
__m128
x1f
x2f
;
__m256d
x1d
x2d
;
x1f
=
_mm_loadu_ps
(
&
data1
[
i
]
)
;
x2f
=
_mm_loadu_ps
(
&
data2
[
i
]
)
;
x1d
=
_mm256_cvtps_pd
(
x1f
)
;
x2d
=
_mm256_cvtps_pd
(
x2f
)
;
accum1
=
_mm256_fmadd_pd
(
x1d
x2d
accum1
)
;
x1f
=
_mm_loadu_ps
(
&
data1
[
i
+
4
]
)
;
x2f
=
_mm_loadu_ps
(
&
data2
[
i
+
4
]
)
;
x1d
=
_mm256_cvtps_pd
(
x1f
)
;
x2d
=
_mm256_cvtps_pd
(
x2f
)
;
accum2
=
_mm256_fmadd_pd
(
x1d
x2d
accum2
)
;
}
for
(
;
i
<
dataSize
-
3
;
i
+
=
4
)
{
__m128
x1f
x2f
;
__m256d
x1d
x2d
;
x1f
=
_mm_loadu_ps
(
&
data1
[
i
]
)
;
x2f
=
_mm_loadu_ps
(
&
data2
[
i
]
)
;
x1d
=
_mm256_cvtps_pd
(
x1f
)
;
x2d
=
_mm256_cvtps_pd
(
x2f
)
;
accum1
=
_mm256_fmadd_pd
(
x1d
x2d
accum1
)
;
}
accum1
=
_mm256_add_pd
(
accum1
accum2
)
;
accum1
=
_mm256_add_pd
(
accum1
_mm256_permute2f128_pd
(
accum1
accum1
1
)
)
;
accum1
=
_mm256_hadd_pd
(
accum1
accum1
)
;
result
=
_mm256_cvtsd_f64
(
accum1
)
;
for
(
;
i
<
dataSize
;
i
+
+
)
{
result
+
=
data1
[
i
]
*
(
double
)
data2
[
i
]
;
}
return
result
;
}
