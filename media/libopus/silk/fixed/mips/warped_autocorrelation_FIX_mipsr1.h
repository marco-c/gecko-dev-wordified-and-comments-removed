#
ifndef
__WARPED_AUTOCORRELATION_FIX_MIPSR1_H__
#
define
__WARPED_AUTOCORRELATION_FIX_MIPSR1_H__
#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
"
main_FIX
.
h
"
#
undef
QC
#
define
QC
10
#
undef
QS
#
define
QS
14
#
define
OVERRIDE_silk_warped_autocorrelation_FIX
void
silk_warped_autocorrelation_FIX
(
opus_int32
*
corr
opus_int
*
scale
const
opus_int16
*
input
const
opus_int
warping_Q16
const
opus_int
length
const
opus_int
order
int
arch
)
{
opus_int
n
i
lsh
;
opus_int32
tmp1_QS
=
0
tmp2_QS
=
0
tmp3_QS
=
0
tmp4_QS
=
0
tmp5_QS
=
0
tmp6_QS
=
0
tmp7_QS
=
0
tmp8_QS
=
0
start_1
=
0
start_2
=
0
start_3
=
0
;
opus_int32
state_QS
[
MAX_SHAPE_LPC_ORDER
+
1
]
=
{
0
}
;
opus_int64
corr_QC
[
MAX_SHAPE_LPC_ORDER
+
1
]
=
{
0
}
;
opus_int64
temp64
;
opus_int32
val
;
val
=
2
*
QS
-
QC
;
silk_assert
(
(
order
&
1
)
=
=
0
)
;
silk_assert
(
2
*
QS
-
QC
>
=
0
)
;
for
(
n
=
0
;
n
<
length
;
n
=
n
+
4
)
{
tmp1_QS
=
silk_LSHIFT32
(
(
opus_int32
)
input
[
n
]
QS
)
;
start_1
=
tmp1_QS
;
tmp3_QS
=
silk_LSHIFT32
(
(
opus_int32
)
input
[
n
+
1
]
QS
)
;
start_2
=
tmp3_QS
;
tmp5_QS
=
silk_LSHIFT32
(
(
opus_int32
)
input
[
n
+
2
]
QS
)
;
start_3
=
tmp5_QS
;
tmp7_QS
=
silk_LSHIFT32
(
(
opus_int32
)
input
[
n
+
3
]
QS
)
;
for
(
i
=
0
;
i
<
order
;
i
+
=
2
)
{
tmp2_QS
=
silk_SMLAWB
(
state_QS
[
i
]
state_QS
[
i
+
1
]
-
tmp1_QS
warping_Q16
)
;
corr_QC
[
i
]
=
__builtin_mips_madd
(
corr_QC
[
i
]
tmp1_QS
start_1
)
;
tmp4_QS
=
silk_SMLAWB
(
tmp1_QS
tmp2_QS
-
tmp3_QS
warping_Q16
)
;
corr_QC
[
i
]
=
__builtin_mips_madd
(
corr_QC
[
i
]
tmp3_QS
start_2
)
;
tmp6_QS
=
silk_SMLAWB
(
tmp3_QS
tmp4_QS
-
tmp5_QS
warping_Q16
)
;
corr_QC
[
i
]
=
__builtin_mips_madd
(
corr_QC
[
i
]
tmp5_QS
start_3
)
;
tmp8_QS
=
silk_SMLAWB
(
tmp5_QS
tmp6_QS
-
tmp7_QS
warping_Q16
)
;
state_QS
[
i
]
=
tmp7_QS
;
corr_QC
[
i
]
=
__builtin_mips_madd
(
corr_QC
[
i
]
tmp7_QS
state_QS
[
0
]
)
;
tmp1_QS
=
silk_SMLAWB
(
state_QS
[
i
+
1
]
state_QS
[
i
+
2
]
-
tmp2_QS
warping_Q16
)
;
corr_QC
[
i
+
1
]
=
__builtin_mips_madd
(
corr_QC
[
i
+
1
]
tmp2_QS
start_1
)
;
tmp3_QS
=
silk_SMLAWB
(
tmp2_QS
tmp1_QS
-
tmp4_QS
warping_Q16
)
;
corr_QC
[
i
+
1
]
=
__builtin_mips_madd
(
corr_QC
[
i
+
1
]
tmp4_QS
start_2
)
;
tmp5_QS
=
silk_SMLAWB
(
tmp4_QS
tmp3_QS
-
tmp6_QS
warping_Q16
)
;
corr_QC
[
i
+
1
]
=
__builtin_mips_madd
(
corr_QC
[
i
+
1
]
tmp6_QS
start_3
)
;
tmp7_QS
=
silk_SMLAWB
(
tmp6_QS
tmp5_QS
-
tmp8_QS
warping_Q16
)
;
state_QS
[
i
+
1
]
=
tmp8_QS
;
corr_QC
[
i
+
1
]
=
__builtin_mips_madd
(
corr_QC
[
i
+
1
]
tmp8_QS
state_QS
[
0
]
)
;
}
state_QS
[
order
]
=
tmp7_QS
;
corr_QC
[
order
]
=
__builtin_mips_madd
(
corr_QC
[
order
]
tmp1_QS
start_1
)
;
corr_QC
[
order
]
=
__builtin_mips_madd
(
corr_QC
[
order
]
tmp3_QS
start_2
)
;
corr_QC
[
order
]
=
__builtin_mips_madd
(
corr_QC
[
order
]
tmp5_QS
start_3
)
;
corr_QC
[
order
]
=
__builtin_mips_madd
(
corr_QC
[
order
]
tmp7_QS
state_QS
[
0
]
)
;
}
for
(
;
n
<
length
;
n
+
+
)
{
tmp1_QS
=
silk_LSHIFT32
(
(
opus_int32
)
input
[
n
]
QS
)
;
for
(
i
=
0
;
i
<
order
;
i
+
=
2
)
{
tmp2_QS
=
silk_SMLAWB
(
state_QS
[
i
]
state_QS
[
i
+
1
]
-
tmp1_QS
warping_Q16
)
;
state_QS
[
i
]
=
tmp1_QS
;
corr_QC
[
i
]
=
__builtin_mips_madd
(
corr_QC
[
i
]
tmp1_QS
state_QS
[
0
]
)
;
tmp1_QS
=
silk_SMLAWB
(
state_QS
[
i
+
1
]
state_QS
[
i
+
2
]
-
tmp2_QS
warping_Q16
)
;
state_QS
[
i
+
1
]
=
tmp2_QS
;
corr_QC
[
i
+
1
]
=
__builtin_mips_madd
(
corr_QC
[
i
+
1
]
tmp2_QS
state_QS
[
0
]
)
;
}
state_QS
[
order
]
=
tmp1_QS
;
corr_QC
[
order
]
=
__builtin_mips_madd
(
corr_QC
[
order
]
tmp1_QS
state_QS
[
0
]
)
;
}
temp64
=
corr_QC
[
0
]
;
temp64
=
__builtin_mips_shilo
(
temp64
val
)
;
lsh
=
silk_CLZ64
(
temp64
)
-
35
;
lsh
=
silk_LIMIT
(
lsh
-
12
-
QC
30
-
QC
)
;
*
scale
=
-
(
QC
+
lsh
)
;
silk_assert
(
*
scale
>
=
-
30
&
&
*
scale
<
=
12
)
;
if
(
lsh
>
=
0
)
{
for
(
i
=
0
;
i
<
order
+
1
;
i
+
+
)
{
temp64
=
corr_QC
[
i
]
;
temp64
=
(
val
>
=
0
)
?
(
temp64
>
>
val
)
:
(
temp64
<
<
-
val
)
;
corr
[
i
]
=
(
opus_int32
)
silk_CHECK_FIT32
(
__builtin_mips_shilo
(
temp64
-
lsh
)
)
;
}
}
else
{
for
(
i
=
0
;
i
<
order
+
1
;
i
+
+
)
{
temp64
=
corr_QC
[
i
]
;
temp64
=
(
val
>
=
0
)
?
(
temp64
>
>
val
)
:
(
temp64
<
<
-
val
)
;
corr
[
i
]
=
(
opus_int32
)
silk_CHECK_FIT32
(
__builtin_mips_shilo
(
temp64
-
lsh
)
)
;
}
}
corr_QC
[
0
]
=
__builtin_mips_shilo
(
corr_QC
[
0
]
val
)
;
silk_assert
(
corr_QC
[
0
]
>
=
0
)
;
}
#
endif
