#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
<
xmmintrin
.
h
>
#
include
<
emmintrin
.
h
>
#
include
<
smmintrin
.
h
>
#
include
"
main
.
h
"
#
include
"
SigProc_FIX
.
h
"
#
include
"
pitch
.
h
"
opus_int64
silk_inner_prod16_sse4_1
(
const
opus_int16
*
inVec1
const
opus_int16
*
inVec2
const
opus_int
len
)
{
opus_int
i
dataSize4
;
opus_int64
sum
;
__m128i
xmm_prod_20
xmm_prod_31
;
__m128i
inVec1_3210
acc1
;
__m128i
inVec2_3210
acc2
;
sum
=
0
;
dataSize4
=
len
&
~
3
;
acc1
=
_mm_setzero_si128
(
)
;
acc2
=
_mm_setzero_si128
(
)
;
for
(
i
=
0
;
i
<
dataSize4
;
i
+
=
4
)
{
inVec1_3210
=
OP_CVTEPI16_EPI32_M64
(
&
inVec1
[
i
+
0
]
)
;
inVec2_3210
=
OP_CVTEPI16_EPI32_M64
(
&
inVec2
[
i
+
0
]
)
;
xmm_prod_20
=
_mm_mul_epi32
(
inVec1_3210
inVec2_3210
)
;
inVec1_3210
=
_mm_shuffle_epi32
(
inVec1_3210
_MM_SHUFFLE
(
0
3
2
1
)
)
;
inVec2_3210
=
_mm_shuffle_epi32
(
inVec2_3210
_MM_SHUFFLE
(
0
3
2
1
)
)
;
xmm_prod_31
=
_mm_mul_epi32
(
inVec1_3210
inVec2_3210
)
;
acc1
=
_mm_add_epi64
(
acc1
xmm_prod_20
)
;
acc2
=
_mm_add_epi64
(
acc2
xmm_prod_31
)
;
}
acc1
=
_mm_add_epi64
(
acc1
acc2
)
;
acc2
=
_mm_shuffle_epi32
(
acc1
_MM_SHUFFLE
(
0
0
3
2
)
)
;
acc1
=
_mm_add_epi64
(
acc1
acc2
)
;
_mm_storel_epi64
(
(
__m128i
*
)
&
sum
acc1
)
;
for
(
;
i
<
len
;
i
+
+
)
{
sum
=
silk_SMLABB
(
sum
inVec1
[
i
]
inVec2
[
i
]
)
;
}
#
ifdef
OPUS_CHECK_ASM
{
opus_int64
sum_c
=
silk_inner_prod16_c
(
inVec1
inVec2
len
)
;
silk_assert
(
sum
=
=
sum_c
)
;
}
#
endif
return
sum
;
}
