#
ifndef
SKIP_CONFIG_H
#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
endif
#
include
"
mdct
.
h
"
#
include
"
kiss_fft
.
h
"
#
include
"
_kiss_fft_guts
.
h
"
#
include
<
math
.
h
>
#
include
"
os_support
.
h
"
#
include
"
mathops
.
h
"
#
include
"
stack_alloc
.
h
"
#
if
defined
(
MIPSr1_ASM
)
#
include
"
mips
/
mdct_mipsr1
.
h
"
#
endif
#
ifndef
M_PI
#
define
M_PI
3
.
141592653
#
endif
#
ifdef
CUSTOM_MODES
int
clt_mdct_init
(
mdct_lookup
*
l
int
N
int
maxshift
int
arch
)
{
int
i
;
kiss_twiddle_scalar
*
trig
;
int
shift
;
int
N2
=
N
>
>
1
;
l
-
>
n
=
N
;
l
-
>
maxshift
=
maxshift
;
for
(
i
=
0
;
i
<
=
maxshift
;
i
+
+
)
{
if
(
i
=
=
0
)
l
-
>
kfft
[
i
]
=
opus_fft_alloc
(
N
>
>
2
>
>
i
0
0
arch
)
;
else
l
-
>
kfft
[
i
]
=
opus_fft_alloc_twiddles
(
N
>
>
2
>
>
i
0
0
l
-
>
kfft
[
0
]
arch
)
;
#
ifndef
ENABLE_TI_DSPLIB55
if
(
l
-
>
kfft
[
i
]
=
=
NULL
)
return
0
;
#
endif
}
l
-
>
trig
=
trig
=
(
kiss_twiddle_scalar
*
)
opus_alloc
(
(
N
-
(
N2
>
>
maxshift
)
)
*
sizeof
(
kiss_twiddle_scalar
)
)
;
if
(
l
-
>
trig
=
=
NULL
)
return
0
;
for
(
shift
=
0
;
shift
<
=
maxshift
;
shift
+
+
)
{
#
if
defined
(
FIXED_POINT
)
#
ifndef
ENABLE_QEXT
for
(
i
=
0
;
i
<
N2
;
i
+
+
)
trig
[
i
]
=
TRIG_UPSCALE
*
celt_cos_norm
(
DIV32
(
ADD32
(
SHL32
(
EXTEND32
(
i
)
17
)
N2
+
16384
)
N
)
)
;
#
else
for
(
i
=
0
;
i
<
N2
;
i
+
+
)
trig
[
i
]
=
(
kiss_twiddle_scalar
)
MAX32
(
-
2147483647
MIN32
(
2147483647
floor
(
.
5
+
2147483648
*
cos
(
2
*
M_PI
*
(
i
+
.
125
)
/
N
)
)
)
)
;
#
endif
#
else
for
(
i
=
0
;
i
<
N2
;
i
+
+
)
trig
[
i
]
=
(
kiss_twiddle_scalar
)
cos
(
2
*
PI
*
(
i
+
.
125
)
/
N
)
;
#
endif
trig
+
=
N2
;
N2
>
>
=
1
;
N
>
>
=
1
;
}
return
1
;
}
void
clt_mdct_clear
(
mdct_lookup
*
l
int
arch
)
{
int
i
;
for
(
i
=
0
;
i
<
=
l
-
>
maxshift
;
i
+
+
)
opus_fft_free
(
l
-
>
kfft
[
i
]
arch
)
;
opus_free
(
(
kiss_twiddle_scalar
*
)
l
-
>
trig
)
;
}
#
endif
#
ifndef
OVERRIDE_clt_mdct_forward
void
clt_mdct_forward_c
(
const
mdct_lookup
*
l
kiss_fft_scalar
*
in
kiss_fft_scalar
*
OPUS_RESTRICT
out
const
celt_coef
*
window
int
overlap
int
shift
int
stride
int
arch
)
{
int
i
;
int
N
N2
N4
;
VARDECL
(
kiss_fft_scalar
f
)
;
VARDECL
(
kiss_fft_cpx
f2
)
;
const
kiss_fft_state
*
st
=
l
-
>
kfft
[
shift
]
;
const
kiss_twiddle_scalar
*
trig
;
celt_coef
scale
;
#
ifdef
FIXED_POINT
int
scale_shift
=
st
-
>
scale_shift
-
1
;
int
headroom
;
#
endif
SAVE_STACK
;
(
void
)
arch
;
scale
=
st
-
>
scale
;
N
=
l
-
>
n
;
trig
=
l
-
>
trig
;
for
(
i
=
0
;
i
<
shift
;
i
+
+
)
{
N
>
>
=
1
;
trig
+
=
N
;
}
N2
=
N
>
>
1
;
N4
=
N
>
>
2
;
ALLOC
(
f
N2
kiss_fft_scalar
)
;
ALLOC
(
f2
N4
kiss_fft_cpx
)
;
{
const
kiss_fft_scalar
*
OPUS_RESTRICT
xp1
=
in
+
(
overlap
>
>
1
)
;
const
kiss_fft_scalar
*
OPUS_RESTRICT
xp2
=
in
+
N2
-
1
+
(
overlap
>
>
1
)
;
kiss_fft_scalar
*
OPUS_RESTRICT
yp
=
f
;
const
celt_coef
*
OPUS_RESTRICT
wp1
=
window
+
(
overlap
>
>
1
)
;
const
celt_coef
*
OPUS_RESTRICT
wp2
=
window
+
(
overlap
>
>
1
)
-
1
;
for
(
i
=
0
;
i
<
(
(
overlap
+
3
)
>
>
2
)
;
i
+
+
)
{
*
yp
+
+
=
S_MUL
(
xp1
[
N2
]
*
wp2
)
+
S_MUL
(
*
xp2
*
wp1
)
;
*
yp
+
+
=
S_MUL
(
*
xp1
*
wp1
)
-
S_MUL
(
xp2
[
-
N2
]
*
wp2
)
;
xp1
+
=
2
;
xp2
-
=
2
;
wp1
+
=
2
;
wp2
-
=
2
;
}
wp1
=
window
;
wp2
=
window
+
overlap
-
1
;
for
(
;
i
<
N4
-
(
(
overlap
+
3
)
>
>
2
)
;
i
+
+
)
{
*
yp
+
+
=
*
xp2
;
*
yp
+
+
=
*
xp1
;
xp1
+
=
2
;
xp2
-
=
2
;
}
for
(
;
i
<
N4
;
i
+
+
)
{
*
yp
+
+
=
-
S_MUL
(
xp1
[
-
N2
]
*
wp1
)
+
S_MUL
(
*
xp2
*
wp2
)
;
*
yp
+
+
=
S_MUL
(
*
xp1
*
wp2
)
+
S_MUL
(
xp2
[
N2
]
*
wp1
)
;
xp1
+
=
2
;
xp2
-
=
2
;
wp1
+
=
2
;
wp2
-
=
2
;
}
}
{
kiss_fft_scalar
*
OPUS_RESTRICT
yp
=
f
;
const
kiss_twiddle_scalar
*
t
=
&
trig
[
0
]
;
#
ifdef
FIXED_POINT
opus_val32
maxval
=
1
;
#
endif
for
(
i
=
0
;
i
<
N4
;
i
+
+
)
{
kiss_fft_cpx
yc
;
kiss_twiddle_scalar
t0
t1
;
kiss_fft_scalar
re
im
yr
yi
;
t0
=
t
[
i
]
;
t1
=
t
[
N4
+
i
]
;
re
=
*
yp
+
+
;
im
=
*
yp
+
+
;
yr
=
S_MUL
(
re
t0
)
-
S_MUL
(
im
t1
)
;
yi
=
S_MUL
(
im
t0
)
+
S_MUL
(
re
t1
)
;
#
ifdef
ENABLE_QEXT
yc
.
r
=
yr
;
yc
.
i
=
yi
;
#
else
yc
.
r
=
S_MUL2
(
yr
scale
)
;
yc
.
i
=
S_MUL2
(
yi
scale
)
;
#
endif
#
ifdef
FIXED_POINT
maxval
=
MAX32
(
maxval
MAX32
(
ABS32
(
yc
.
r
)
ABS32
(
yc
.
i
)
)
)
;
#
endif
f2
[
st
-
>
bitrev
[
i
]
]
=
yc
;
}
#
ifdef
FIXED_POINT
headroom
=
IMAX
(
0
IMIN
(
scale_shift
28
-
celt_ilog2
(
maxval
)
)
)
;
#
endif
}
opus_fft_impl
(
st
f2
ARG_FIXED
(
scale_shift
-
headroom
)
)
;
{
const
kiss_fft_cpx
*
OPUS_RESTRICT
fp
=
f2
;
kiss_fft_scalar
*
OPUS_RESTRICT
yp1
=
out
;
kiss_fft_scalar
*
OPUS_RESTRICT
yp2
=
out
+
stride
*
(
N2
-
1
)
;
const
kiss_twiddle_scalar
*
t
=
&
trig
[
0
]
;
for
(
i
=
0
;
i
<
N4
;
i
+
+
)
{
kiss_fft_scalar
yr
yi
;
kiss_fft_scalar
t0
t1
;
#
ifdef
ENABLE_QEXT
t0
=
S_MUL2
(
t
[
i
]
scale
)
;
t1
=
S_MUL2
(
t
[
N4
+
i
]
scale
)
;
#
else
t0
=
t
[
i
]
;
t1
=
t
[
N4
+
i
]
;
#
endif
yr
=
PSHR32
(
S_MUL
(
fp
-
>
i
t1
)
-
S_MUL
(
fp
-
>
r
t0
)
headroom
)
;
yi
=
PSHR32
(
S_MUL
(
fp
-
>
r
t1
)
+
S_MUL
(
fp
-
>
i
t0
)
headroom
)
;
*
yp1
=
yr
;
*
yp2
=
yi
;
fp
+
+
;
yp1
+
=
2
*
stride
;
yp2
-
=
2
*
stride
;
}
}
RESTORE_STACK
;
}
#
endif
#
ifndef
OVERRIDE_clt_mdct_backward
void
clt_mdct_backward_c
(
const
mdct_lookup
*
l
kiss_fft_scalar
*
in
kiss_fft_scalar
*
OPUS_RESTRICT
out
const
celt_coef
*
OPUS_RESTRICT
window
int
overlap
int
shift
int
stride
int
arch
)
{
int
i
;
int
N
N2
N4
;
const
kiss_twiddle_scalar
*
trig
;
(
void
)
arch
;
N
=
l
-
>
n
;
trig
=
l
-
>
trig
;
for
(
i
=
0
;
i
<
shift
;
i
+
+
)
{
N
>
>
=
1
;
trig
+
=
N
;
}
N2
=
N
>
>
1
;
N4
=
N
>
>
2
;
{
const
kiss_fft_scalar
*
OPUS_RESTRICT
xp1
=
in
;
const
kiss_fft_scalar
*
OPUS_RESTRICT
xp2
=
in
+
stride
*
(
N2
-
1
)
;
kiss_fft_scalar
*
OPUS_RESTRICT
yp
=
out
+
(
overlap
>
>
1
)
;
const
kiss_twiddle_scalar
*
OPUS_RESTRICT
t
=
&
trig
[
0
]
;
const
opus_int16
*
OPUS_RESTRICT
bitrev
=
l
-
>
kfft
[
shift
]
-
>
bitrev
;
for
(
i
=
0
;
i
<
N4
;
i
+
+
)
{
int
rev
;
kiss_fft_scalar
yr
yi
;
opus_val32
x1
x2
;
rev
=
*
bitrev
+
+
;
x1
=
SHL32
(
*
xp1
IMDCT_HEADROOM
)
;
x2
=
SHL32
(
*
xp2
IMDCT_HEADROOM
)
;
yr
=
ADD32_ovflw
(
S_MUL
(
x2
t
[
i
]
)
S_MUL
(
x1
t
[
N4
+
i
]
)
)
;
yi
=
SUB32_ovflw
(
S_MUL
(
x1
t
[
i
]
)
S_MUL
(
x2
t
[
N4
+
i
]
)
)
;
yp
[
2
*
rev
+
1
]
=
yr
;
yp
[
2
*
rev
]
=
yi
;
xp1
+
=
2
*
stride
;
xp2
-
=
2
*
stride
;
}
}
opus_fft_impl
(
l
-
>
kfft
[
shift
]
(
kiss_fft_cpx
*
)
(
out
+
(
overlap
>
>
1
)
)
ARG_FIXED
(
0
)
)
;
{
kiss_fft_scalar
*
yp0
=
out
+
(
overlap
>
>
1
)
;
kiss_fft_scalar
*
yp1
=
out
+
(
overlap
>
>
1
)
+
N2
-
2
;
const
kiss_twiddle_scalar
*
t
=
&
trig
[
0
]
;
for
(
i
=
0
;
i
<
(
N4
+
1
)
>
>
1
;
i
+
+
)
{
kiss_fft_scalar
re
im
yr
yi
;
kiss_twiddle_scalar
t0
t1
;
re
=
yp0
[
1
]
;
im
=
yp0
[
0
]
;
t0
=
t
[
i
]
;
t1
=
t
[
N4
+
i
]
;
yr
=
PSHR32_ovflw
(
ADD32_ovflw
(
S_MUL
(
re
t0
)
S_MUL
(
im
t1
)
)
IMDCT_HEADROOM
)
;
yi
=
PSHR32_ovflw
(
SUB32_ovflw
(
S_MUL
(
re
t1
)
S_MUL
(
im
t0
)
)
IMDCT_HEADROOM
)
;
re
=
yp1
[
1
]
;
im
=
yp1
[
0
]
;
yp0
[
0
]
=
yr
;
yp1
[
1
]
=
yi
;
t0
=
t
[
(
N4
-
i
-
1
)
]
;
t1
=
t
[
(
N2
-
i
-
1
)
]
;
yr
=
PSHR32_ovflw
(
ADD32_ovflw
(
S_MUL
(
re
t0
)
S_MUL
(
im
t1
)
)
IMDCT_HEADROOM
)
;
yi
=
PSHR32_ovflw
(
SUB32_ovflw
(
S_MUL
(
re
t1
)
S_MUL
(
im
t0
)
)
IMDCT_HEADROOM
)
;
yp1
[
0
]
=
yr
;
yp0
[
1
]
=
yi
;
yp0
+
=
2
;
yp1
-
=
2
;
}
}
{
kiss_fft_scalar
*
OPUS_RESTRICT
xp1
=
out
+
overlap
-
1
;
kiss_fft_scalar
*
OPUS_RESTRICT
yp1
=
out
;
const
celt_coef
*
OPUS_RESTRICT
wp1
=
window
;
const
celt_coef
*
OPUS_RESTRICT
wp2
=
window
+
overlap
-
1
;
for
(
i
=
0
;
i
<
overlap
/
2
;
i
+
+
)
{
kiss_fft_scalar
x1
x2
;
x1
=
*
xp1
;
x2
=
*
yp1
;
*
yp1
+
+
=
SUB32_ovflw
(
S_MUL
(
x2
*
wp2
)
S_MUL
(
x1
*
wp1
)
)
;
*
xp1
-
-
=
ADD32_ovflw
(
S_MUL
(
x2
*
wp1
)
S_MUL
(
x1
*
wp2
)
)
;
wp1
+
+
;
wp2
-
-
;
}
}
}
#
endif
