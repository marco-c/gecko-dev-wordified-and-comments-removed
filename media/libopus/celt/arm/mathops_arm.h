#
if
!
defined
(
MATHOPS_ARM_H
)
#
define
MATHOPS_ARM_H
#
include
"
armcpu
.
h
"
#
include
"
cpu_support
.
h
"
#
include
"
opus_defines
.
h
"
#
if
!
defined
(
DISABLE_FLOAT_API
)
&
&
defined
(
OPUS_ARM_MAY_HAVE_NEON_INTR
)
#
include
<
arm_neon
.
h
>
static
inline
int32x4_t
vroundf
(
float32x4_t
x
)
{
#
if
defined
(
__aarch64__
)
|
|
(
defined
(
__ARM_ARCH
)
&
&
__ARM_ARCH
>
=
8
)
return
vcvtaq_s32_f32
(
x
)
;
#
else
uint32x4_t
sign
=
vandq_u32
(
vreinterpretq_u32_f32
(
x
)
vdupq_n_u32
(
0x80000000
)
)
;
uint32x4_t
bias
=
vdupq_n_u32
(
0x3F000000
)
;
return
vcvtq_s32_f32
(
vaddq_f32
(
x
vreinterpretq_f32_u32
(
vorrq_u32
(
bias
sign
)
)
)
)
;
#
endif
}
void
celt_float2int16_neon
(
const
float
*
OPUS_RESTRICT
in
short
*
OPUS_RESTRICT
out
int
cnt
)
;
#
if
defined
(
OPUS_HAVE_RTCD
)
&
&
\
(
defined
(
OPUS_ARM_MAY_HAVE_NEON_INTR
)
&
&
!
defined
(
OPUS_ARM_PRESUME_NEON_INTR
)
)
extern
void
(
*
const
CELT_FLOAT2INT16_IMPL
[
OPUS_ARCHMASK
+
1
]
)
(
const
float
*
OPUS_RESTRICT
in
short
*
OPUS_RESTRICT
out
int
cnt
)
;
#
define
OVERRIDE_FLOAT2INT16
(
1
)
#
define
celt_float2int16
(
in
out
cnt
arch
)
\
(
(
*
CELT_FLOAT2INT16_IMPL
[
(
arch
)
&
OPUS_ARCHMASK
]
)
(
in
out
cnt
)
)
#
elif
defined
(
OPUS_ARM_PRESUME_NEON_INTR
)
#
define
OVERRIDE_FLOAT2INT16
(
1
)
#
define
celt_float2int16
(
in
out
cnt
arch
)
(
(
void
)
(
arch
)
celt_float2int16_neon
(
in
out
cnt
)
)
#
endif
#
endif
#
endif
