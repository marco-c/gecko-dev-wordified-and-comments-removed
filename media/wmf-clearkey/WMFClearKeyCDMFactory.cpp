#
include
"
WMFClearKeyCDMFactory
.
h
"
#
include
<
string
>
#
include
<
Mferror
.
h
>
#
include
"
WMFClearKeyCDMAccess
.
h
"
#
include
"
WMFClearKeyUtils
.
h
"
namespace
mozilla
{
using
Microsoft
:
:
WRL
:
:
MakeAndInitialize
;
ActivatableClass
(
WMFClearKeyCDMFactory
)
;
static
bool
isRequiringHDCP22OrAbove
(
LPCWSTR
aType
)
{
if
(
aType
=
=
nullptr
|
|
*
aType
=
=
L
'
\
0
'
)
{
return
false
;
}
std
:
:
wstring
wstr
(
aType
)
;
std
:
:
string
hdcpStr
(
wstr
.
begin
(
)
wstr
.
end
(
)
)
;
return
wstr
.
find
(
L
"
hdcp
=
2
"
)
!
=
std
:
:
string
:
:
npos
;
}
STDMETHODIMP_
(
BOOL
)
WMFClearKeyCDMFactory
:
:
IsTypeSupported
(
_In_
LPCWSTR
aKeySystem
_In_opt_
LPCWSTR
aContentType
)
{
bool
needHDCP22OrAbove
=
isRequiringHDCP22OrAbove
(
aContentType
)
;
ENTRY_LOG_ARGS
(
"
Need
-
HDCP2
.
2
+
=
%
d
"
needHDCP22OrAbove
)
;
return
!
needHDCP22OrAbove
;
}
STDMETHODIMP
WMFClearKeyCDMFactory
:
:
CreateContentDecryptionModuleAccess
(
LPCWSTR
aKeySystem
IPropertyStore
*
*
aConfigurations
DWORD
aNumConfigurations
IMFContentDecryptionModuleAccess
*
*
aCdmAccess
)
{
ENTRY_LOG
(
)
;
if
(
aKeySystem
=
=
nullptr
|
|
aKeySystem
[
0
]
=
=
L
'
\
0
'
)
{
ENTRY_LOG_ARGS
(
"
Key
system
is
null
or
empty
"
)
;
return
MF_TYPE_ERR
;
}
if
(
aNumConfigurations
=
=
0
)
{
ENTRY_LOG_ARGS
(
"
No
available
configration
"
)
;
return
MF_TYPE_ERR
;
}
if
(
!
IsTypeSupported
(
aKeySystem
nullptr
)
)
{
ENTRY_LOG_ARGS
(
"
Not
supported
type
"
)
;
return
MF_NOT_SUPPORTED_ERR
;
}
RETURN_IF_FAILED
(
(
MakeAndInitialize
<
WMFClearKeyCDMAccess
IMFContentDecryptionModuleAccess
>
(
aCdmAccess
)
)
)
;
ENTRY_LOG_ARGS
(
"
Created
CDM
access
!
"
)
;
return
S_OK
;
}
STDMETHODIMP
WMFClearKeyCDMFactory
:
:
IsTypeSupportedEx
(
BSTR
aType
BSTR
aKeySystem
MF_MEDIA_ENGINE_CANPLAY
*
aPAnswer
)
{
if
(
!
aPAnswer
)
{
return
E_POINTER
;
}
*
aPAnswer
=
IsTypeSupported
(
aKeySystem
aType
)
?
MF_MEDIA_ENGINE_CANPLAY_PROBABLY
:
MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED
;
return
S_OK
;
}
#
undef
LOG
}
