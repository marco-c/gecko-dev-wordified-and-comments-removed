use
futures
:
:
sync
:
:
{
mpsc
oneshot
}
;
use
futures
:
:
{
Async
Future
Poll
}
;
use
std
:
:
fmt
;
use
std
:
:
io
;
pub
type
Request
<
R
Q
>
=
(
R
oneshot
:
:
Sender
<
Q
>
)
;
pub
type
Receiver
<
R
Q
>
=
mpsc
:
:
UnboundedReceiver
<
Request
<
R
Q
>
>
;
pub
struct
Response
<
Q
>
{
inner
:
oneshot
:
:
Receiver
<
Q
>
}
pub
struct
ClientProxy
<
R
Q
>
{
tx
:
mpsc
:
:
UnboundedSender
<
Request
<
R
Q
>
>
}
impl
<
R
Q
>
Clone
for
ClientProxy
<
R
Q
>
{
fn
clone
(
&
self
)
-
>
Self
{
ClientProxy
{
tx
:
self
.
tx
.
clone
(
)
}
}
}
pub
fn
channel
<
R
Q
>
(
)
-
>
(
ClientProxy
<
R
Q
>
Receiver
<
R
Q
>
)
{
let
(
tx
rx
)
=
mpsc
:
:
unbounded
(
)
;
let
client
=
ClientProxy
{
tx
}
;
(
client
rx
)
}
impl
<
R
Q
>
ClientProxy
<
R
Q
>
{
pub
fn
call
(
&
self
request
:
R
)
-
>
Response
<
Q
>
{
let
(
tx
rx
)
=
oneshot
:
:
channel
(
)
;
let
_
=
self
.
tx
.
unbounded_send
(
(
request
tx
)
)
;
Response
{
inner
:
rx
}
}
}
impl
<
R
Q
>
fmt
:
:
Debug
for
ClientProxy
<
R
Q
>
where
R
:
fmt
:
:
Debug
Q
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
ClientProxy
{
{
.
.
.
}
}
"
)
}
}
impl
<
Q
>
Future
for
Response
<
Q
>
{
type
Item
=
Q
;
type
Error
=
io
:
:
Error
;
fn
poll
(
&
mut
self
)
-
>
Poll
<
Q
io
:
:
Error
>
{
match
self
.
inner
.
poll
(
)
{
Ok
(
Async
:
:
Ready
(
res
)
)
=
>
Ok
(
Async
:
:
Ready
(
res
)
)
Ok
(
Async
:
:
NotReady
)
=
>
Ok
(
Async
:
:
NotReady
)
Err
(
_
)
=
>
{
let
e
=
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
BrokenPipe
"
broken
pipe
"
)
;
Err
(
e
)
}
}
}
}
impl
<
Q
>
fmt
:
:
Debug
for
Response
<
Q
>
where
Q
:
fmt
:
:
Debug
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
"
Response
{
{
.
.
.
}
}
"
)
}
}
