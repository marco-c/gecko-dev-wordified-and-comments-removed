use
crate
:
:
rpc
:
:
driver
:
:
Driver
;
use
crate
:
:
rpc
:
:
Handler
;
use
futures
:
:
sync
:
:
oneshot
;
use
futures
:
:
{
Async
Future
Poll
Sink
Stream
}
;
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
io
;
use
tokio
:
:
runtime
:
:
current_thread
;
mod
proxy
;
pub
use
self
:
:
proxy
:
:
{
ClientProxy
Response
}
;
pub
fn
bind_client
<
C
>
(
transport
:
C
:
:
Transport
)
-
>
proxy
:
:
ClientProxy
<
C
:
:
Request
C
:
:
Response
>
where
C
:
Client
{
let
(
tx
rx
)
=
proxy
:
:
channel
(
)
;
let
fut
=
{
let
handler
=
ClientHandler
:
:
<
C
>
{
transport
requests
:
rx
in_flight
:
VecDeque
:
:
with_capacity
(
32
)
}
;
Driver
:
:
new
(
handler
)
}
;
current_thread
:
:
spawn
(
fut
.
map_err
(
|
_
|
(
)
)
)
;
tx
}
pub
trait
Client
:
'
static
{
type
Request
:
'
static
;
type
Response
:
'
static
;
type
Transport
:
'
static
+
Stream
<
Item
=
Self
:
:
Response
Error
=
io
:
:
Error
>
+
Sink
<
SinkItem
=
Self
:
:
Request
SinkError
=
io
:
:
Error
>
;
}
struct
ClientHandler
<
C
>
where
C
:
Client
{
transport
:
C
:
:
Transport
requests
:
proxy
:
:
Receiver
<
C
:
:
Request
C
:
:
Response
>
in_flight
:
VecDeque
<
oneshot
:
:
Sender
<
C
:
:
Response
>
>
}
impl
<
C
>
Handler
for
ClientHandler
<
C
>
where
C
:
Client
{
type
In
=
C
:
:
Response
;
type
Out
=
C
:
:
Request
;
type
Transport
=
C
:
:
Transport
;
fn
transport
(
&
mut
self
)
-
>
&
mut
Self
:
:
Transport
{
&
mut
self
.
transport
}
fn
consume
(
&
mut
self
response
:
Self
:
:
In
)
-
>
io
:
:
Result
<
(
)
>
{
trace
!
(
"
ClientHandler
:
:
consume
"
)
;
if
let
Some
(
complete
)
=
self
.
in_flight
.
pop_front
(
)
{
drop
(
complete
.
send
(
response
)
)
;
}
else
{
return
Err
(
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
request
/
response
mismatch
"
)
)
;
}
Ok
(
(
)
)
}
fn
produce
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Out
>
io
:
:
Error
>
{
trace
!
(
"
ClientHandler
:
:
produce
"
)
;
match
self
.
requests
.
poll
(
)
{
Ok
(
Async
:
:
Ready
(
Some
(
(
request
complete
)
)
)
)
=
>
{
trace
!
(
"
-
-
>
received
request
"
)
;
self
.
in_flight
.
push_back
(
complete
)
;
Ok
(
Some
(
request
)
.
into
(
)
)
}
Ok
(
Async
:
:
Ready
(
None
)
)
=
>
{
trace
!
(
"
-
-
>
client
dropped
"
)
;
Ok
(
None
.
into
(
)
)
}
Ok
(
Async
:
:
NotReady
)
=
>
{
trace
!
(
"
-
-
>
not
ready
"
)
;
Ok
(
Async
:
:
NotReady
)
}
Err
(
_
)
=
>
unreachable
!
(
)
}
}
fn
has_in_flight
(
&
self
)
-
>
bool
{
!
self
.
in_flight
.
is_empty
(
)
}
}
impl
<
C
:
Client
>
Drop
for
ClientHandler
<
C
>
{
fn
drop
(
&
mut
self
)
{
let
_
=
self
.
transport
.
close
(
)
;
self
.
in_flight
.
clear
(
)
;
}
}
