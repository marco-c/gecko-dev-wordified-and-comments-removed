use
futures
:
:
{
Async
Future
Poll
Sink
Stream
}
;
use
rpc
:
:
driver
:
:
Driver
;
use
rpc
:
:
Handler
;
use
std
:
:
collections
:
:
VecDeque
;
use
std
:
:
io
;
use
tokio_core
:
:
reactor
:
:
Handle
;
pub
fn
bind_server
<
S
>
(
transport
:
S
:
:
Transport
server
:
S
handle
:
&
Handle
)
where
S
:
Server
{
let
fut
=
{
let
handler
=
ServerHandler
{
server
:
server
transport
:
transport
in_flight
:
VecDeque
:
:
with_capacity
(
32
)
}
;
Driver
:
:
new
(
handler
)
}
;
handle
.
spawn
(
Box
:
:
new
(
fut
.
map_err
(
|
_
|
(
)
)
)
)
}
pub
trait
Server
:
'
static
{
type
Request
:
'
static
;
type
Response
:
'
static
;
type
Future
:
Future
<
Item
=
Self
:
:
Response
Error
=
(
)
>
;
type
Transport
:
'
static
+
Stream
<
Item
=
Self
:
:
Request
Error
=
io
:
:
Error
>
+
Sink
<
SinkItem
=
Self
:
:
Response
SinkError
=
io
:
:
Error
>
;
fn
process
(
&
mut
self
req
:
Self
:
:
Request
)
-
>
Self
:
:
Future
;
}
struct
ServerHandler
<
S
>
where
S
:
Server
{
server
:
S
transport
:
S
:
:
Transport
in_flight
:
VecDeque
<
InFlight
<
S
:
:
Future
>
>
}
impl
<
S
>
Handler
for
ServerHandler
<
S
>
where
S
:
Server
{
type
In
=
S
:
:
Request
;
type
Out
=
S
:
:
Response
;
type
Transport
=
S
:
:
Transport
;
fn
transport
(
&
mut
self
)
-
>
&
mut
Self
:
:
Transport
{
&
mut
self
.
transport
}
fn
consume
(
&
mut
self
request
:
Self
:
:
In
)
-
>
io
:
:
Result
<
(
)
>
{
trace
!
(
"
ServerHandler
:
:
consume
"
)
;
let
response
=
self
.
server
.
process
(
request
)
;
self
.
in_flight
.
push_back
(
InFlight
:
:
Active
(
response
)
)
;
Ok
(
(
)
)
}
fn
produce
(
&
mut
self
)
-
>
Poll
<
Option
<
Self
:
:
Out
>
io
:
:
Error
>
{
trace
!
(
"
ServerHandler
:
:
produce
"
)
;
for
pending
in
&
mut
self
.
in_flight
{
pending
.
poll
(
)
;
}
match
self
.
in_flight
.
front
(
)
{
Some
(
&
InFlight
:
:
Done
(
_
)
)
=
>
{
}
_
=
>
{
trace
!
(
"
-
-
>
not
ready
"
)
;
return
Ok
(
Async
:
:
NotReady
)
;
}
}
match
self
.
in_flight
.
pop_front
(
)
{
Some
(
InFlight
:
:
Done
(
res
)
)
=
>
{
trace
!
(
"
-
-
>
received
response
"
)
;
Ok
(
Async
:
:
Ready
(
Some
(
res
)
)
)
}
_
=
>
panic
!
(
)
}
}
fn
has_in_flight
(
&
self
)
-
>
bool
{
!
self
.
in_flight
.
is_empty
(
)
}
}
enum
InFlight
<
F
:
Future
<
Error
=
(
)
>
>
{
Active
(
F
)
Done
(
F
:
:
Item
)
}
impl
<
F
:
Future
<
Error
=
(
)
>
>
InFlight
<
F
>
{
fn
poll
(
&
mut
self
)
{
let
res
=
match
*
self
{
InFlight
:
:
Active
(
ref
mut
f
)
=
>
match
f
.
poll
(
)
{
Ok
(
Async
:
:
Ready
(
e
)
)
=
>
e
Err
(
_
)
=
>
unreachable
!
(
)
Ok
(
Async
:
:
NotReady
)
=
>
return
}
_
=
>
return
}
;
*
self
=
InFlight
:
:
Done
(
res
)
;
}
}
