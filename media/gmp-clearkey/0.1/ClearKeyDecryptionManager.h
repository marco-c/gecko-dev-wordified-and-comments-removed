#
ifndef
__ClearKeyDecryptionManager_h__
#
define
__ClearKeyDecryptionManager_h__
#
include
"
ClearKeyUtils
.
h
"
#
include
"
stddef
.
h
"
#
include
"
content_decryption_module
.
h
"
#
include
"
RefCounted
.
h
"
#
include
<
map
>
class
ClearKeyDecryptor
;
class
CryptoMetaData
{
public
:
CryptoMetaData
(
)
{
}
explicit
CryptoMetaData
(
const
cdm
:
:
InputBuffer
*
aInputBuffer
)
{
Init
(
aInputBuffer
)
;
}
void
Init
(
const
cdm
:
:
InputBuffer
*
aInputBuffer
)
{
if
(
!
aInputBuffer
)
{
assert
(
!
IsValid
(
)
)
;
return
;
}
Assign
(
mKeyId
aInputBuffer
-
>
key_id
aInputBuffer
-
>
key_id_size
)
;
Assign
(
mIV
aInputBuffer
-
>
iv
aInputBuffer
-
>
iv_size
)
;
for
(
uint32_t
i
=
0
;
i
<
aInputBuffer
-
>
num_subsamples
;
+
+
i
)
{
const
cdm
:
:
SubsampleEntry
&
subsample
=
aInputBuffer
-
>
subsamples
[
i
]
;
mCipherBytes
.
push_back
(
subsample
.
cipher_bytes
)
;
mClearBytes
.
push_back
(
subsample
.
clear_bytes
)
;
}
}
bool
IsValid
(
)
const
{
return
!
mKeyId
.
empty
(
)
&
&
!
mIV
.
empty
(
)
&
&
!
mCipherBytes
.
empty
(
)
&
&
!
mClearBytes
.
empty
(
)
;
}
size_t
NumSubsamples
(
)
const
{
assert
(
mClearBytes
.
size
(
)
=
=
mCipherBytes
.
size
(
)
)
;
return
mClearBytes
.
size
(
)
;
}
std
:
:
vector
<
uint8_t
>
mKeyId
;
std
:
:
vector
<
uint8_t
>
mIV
;
std
:
:
vector
<
uint32_t
>
mClearBytes
;
std
:
:
vector
<
uint32_t
>
mCipherBytes
;
}
;
class
ClearKeyDecryptionManager
:
public
RefCounted
{
private
:
ClearKeyDecryptionManager
(
)
;
~
ClearKeyDecryptionManager
(
)
;
static
ClearKeyDecryptionManager
*
sInstance
;
public
:
static
ClearKeyDecryptionManager
*
Get
(
)
;
bool
HasSeenKeyId
(
const
KeyId
&
aKeyId
)
const
;
bool
HasKeyForKeyId
(
const
KeyId
&
aKeyId
)
const
;
const
Key
&
GetDecryptionKey
(
const
KeyId
&
aKeyId
)
;
void
InitKey
(
KeyId
aKeyId
Key
aKey
)
;
void
ExpectKeyId
(
KeyId
aKeyId
)
;
void
ReleaseKeyId
(
KeyId
aKeyId
)
;
cdm
:
:
Status
Decrypt
(
uint8_t
*
aBuffer
uint32_t
aBufferSize
const
CryptoMetaData
&
aMetadata
)
;
cdm
:
:
Status
Decrypt
(
std
:
:
vector
<
uint8_t
>
&
aBuffer
const
CryptoMetaData
&
aMetadata
)
;
private
:
bool
IsExpectingKeyForKeyId
(
const
KeyId
&
aKeyId
)
const
;
std
:
:
map
<
KeyId
ClearKeyDecryptor
*
>
mDecryptors
;
}
;
#
endif
