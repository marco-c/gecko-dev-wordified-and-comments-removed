#
ifndef
__ClearKeyDecryptionManager_h__
#
define
__ClearKeyDecryptionManager_h__
#
include
<
map
>
#
include
"
ClearKeyUtils
.
h
"
#
include
"
RefCounted
.
h
"
class
ClearKeyDecryptor
;
class
CryptoMetaData
{
public
:
CryptoMetaData
(
)
{
}
explicit
CryptoMetaData
(
const
GMPEncryptedBufferMetadata
*
aCrypto
)
{
Init
(
aCrypto
)
;
}
void
Init
(
const
GMPEncryptedBufferMetadata
*
aCrypto
)
{
if
(
!
aCrypto
)
{
assert
(
!
IsValid
(
)
)
;
return
;
}
Assign
(
mKeyId
aCrypto
-
>
KeyId
(
)
aCrypto
-
>
KeyIdSize
(
)
)
;
Assign
(
mIV
aCrypto
-
>
IV
(
)
aCrypto
-
>
IVSize
(
)
)
;
Assign
(
mClearBytes
aCrypto
-
>
ClearBytes
(
)
aCrypto
-
>
NumSubsamples
(
)
)
;
Assign
(
mCipherBytes
aCrypto
-
>
CipherBytes
(
)
aCrypto
-
>
NumSubsamples
(
)
)
;
}
bool
IsValid
(
)
const
{
return
!
mKeyId
.
empty
(
)
&
&
!
mIV
.
empty
(
)
&
&
!
mCipherBytes
.
empty
(
)
&
&
!
mClearBytes
.
empty
(
)
;
}
size_t
NumSubsamples
(
)
const
{
assert
(
mClearBytes
.
size
(
)
=
=
mCipherBytes
.
size
(
)
)
;
return
mClearBytes
.
size
(
)
;
}
std
:
:
vector
<
uint8_t
>
mKeyId
;
std
:
:
vector
<
uint8_t
>
mIV
;
std
:
:
vector
<
uint16_t
>
mClearBytes
;
std
:
:
vector
<
uint32_t
>
mCipherBytes
;
}
;
class
ClearKeyDecryptionManager
:
public
RefCounted
{
private
:
ClearKeyDecryptionManager
(
)
;
~
ClearKeyDecryptionManager
(
)
;
static
ClearKeyDecryptionManager
*
sInstance
;
public
:
static
ClearKeyDecryptionManager
*
Get
(
)
;
bool
HasSeenKeyId
(
const
KeyId
&
aKeyId
)
const
;
bool
HasKeyForKeyId
(
const
KeyId
&
aKeyId
)
const
;
const
Key
&
GetDecryptionKey
(
const
KeyId
&
aKeyId
)
;
void
InitKey
(
KeyId
aKeyId
Key
aKey
)
;
void
ExpectKeyId
(
KeyId
aKeyId
)
;
void
ReleaseKeyId
(
KeyId
aKeyId
)
;
GMPErr
Decrypt
(
uint8_t
*
aBuffer
uint32_t
aBufferSize
const
CryptoMetaData
&
aMetadata
)
;
GMPErr
Decrypt
(
std
:
:
vector
<
uint8_t
>
&
aBuffer
const
CryptoMetaData
&
aMetadata
)
;
void
Shutdown
(
)
;
private
:
bool
IsExpectingKeyForKeyId
(
const
KeyId
&
aKeyId
)
const
;
std
:
:
map
<
KeyId
ClearKeyDecryptor
*
>
mDecryptors
;
}
;
#
endif
