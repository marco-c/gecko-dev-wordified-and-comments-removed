#
include
"
ClearKeyCencParser
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
ArrayUtils
.
h
"
#
include
"
BigEndian
.
h
"
#
include
<
memory
.
h
>
#
include
<
algorithm
>
#
include
<
assert
.
h
>
#
include
<
limits
>
class
ByteReader
{
public
:
ByteReader
(
const
uint8_t
*
aData
size_t
aSize
)
:
mPtr
(
aData
)
mRemaining
(
aSize
)
mLength
(
aSize
)
{
}
size_t
Offset
(
)
const
{
return
mLength
-
mRemaining
;
}
size_t
Remaining
(
)
const
{
return
mRemaining
;
}
size_t
Length
(
)
const
{
return
mLength
;
}
bool
CanRead8
(
)
const
{
return
mRemaining
>
=
1
;
}
uint8_t
ReadU8
(
)
{
auto
ptr
=
Read
(
1
)
;
if
(
!
ptr
)
{
MOZ_ASSERT
(
false
)
;
return
0
;
}
return
*
ptr
;
}
bool
CanRead32
(
)
const
{
return
mRemaining
>
=
4
;
}
uint32_t
ReadU32
(
)
{
auto
ptr
=
Read
(
4
)
;
if
(
!
ptr
)
{
MOZ_ASSERT
(
false
)
;
return
0
;
}
return
mozilla
:
:
BigEndian
:
:
readUint32
(
ptr
)
;
}
const
uint8_t
*
Read
(
size_t
aCount
)
{
if
(
aCount
>
mRemaining
)
{
mRemaining
=
0
;
return
nullptr
;
}
mRemaining
-
=
aCount
;
const
uint8_t
*
result
=
mPtr
;
mPtr
+
=
aCount
;
return
result
;
}
const
uint8_t
*
Seek
(
size_t
aOffset
)
{
if
(
aOffset
>
mLength
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
mPtr
=
mPtr
-
Offset
(
)
+
aOffset
;
mRemaining
=
mLength
-
aOffset
;
return
mPtr
;
}
private
:
const
uint8_t
*
mPtr
;
size_t
mRemaining
;
const
size_t
mLength
;
}
;
#
define
FOURCC
(
a
b
c
d
)
(
(
a
<
<
24
)
+
(
b
<
<
16
)
+
(
c
<
<
8
)
+
d
)
const
uint8_t
kSystemID
[
]
=
{
0x10
0x77
0xef
0xec
0xc0
0xb2
0x4d
0x02
0xac
0xe3
0x3c
0x1e
0x52
0xe2
0xfb
0x4b
}
;
void
ParseCENCInitData
(
const
uint8_t
*
aInitData
uint32_t
aInitDataSize
std
:
:
vector
<
std
:
:
vector
<
uint8_t
>
>
&
aOutKeyIds
)
{
ByteReader
reader
(
aInitData
aInitDataSize
)
;
while
(
reader
.
CanRead32
(
)
)
{
const
size_t
start
=
reader
.
Offset
(
)
;
const
size_t
size
=
reader
.
ReadU32
(
)
;
if
(
size
>
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
-
start
)
{
return
;
}
const
size_t
end
=
std
:
:
min
<
size_t
>
(
start
+
size
reader
.
Length
(
)
)
;
if
(
!
reader
.
CanRead32
(
)
)
{
return
;
}
uint32_t
box
=
reader
.
ReadU32
(
)
;
if
(
box
!
=
FOURCC
(
'
p
'
'
s
'
'
s
'
'
h
'
)
)
{
reader
.
Seek
(
std
:
:
max
<
size_t
>
(
reader
.
Offset
(
)
end
)
)
;
continue
;
}
if
(
!
reader
.
CanRead32
(
)
)
{
return
;
}
uint8_t
version
=
reader
.
ReadU8
(
)
;
if
(
version
!
=
1
)
{
reader
.
Seek
(
std
:
:
max
<
size_t
>
(
reader
.
Offset
(
)
end
)
)
;
continue
;
}
reader
.
Read
(
3
)
;
const
uint8_t
*
sid
=
reader
.
Read
(
sizeof
(
kSystemID
)
)
;
if
(
!
sid
)
{
return
;
}
if
(
memcmp
(
kSystemID
sid
sizeof
(
kSystemID
)
)
)
{
reader
.
Seek
(
std
:
:
max
<
size_t
>
(
reader
.
Offset
(
)
end
)
)
;
continue
;
}
if
(
!
reader
.
CanRead32
(
)
)
{
return
;
}
uint32_t
kidCount
=
reader
.
ReadU32
(
)
;
for
(
uint32_t
i
=
0
;
i
<
kidCount
;
i
+
+
)
{
if
(
reader
.
Remaining
(
)
<
CLEARKEY_KEY_LEN
)
{
return
;
}
const
uint8_t
*
kid
=
reader
.
Read
(
CLEARKEY_KEY_LEN
)
;
aOutKeyIds
.
push_back
(
std
:
:
vector
<
uint8_t
>
(
kid
kid
+
CLEARKEY_KEY_LEN
)
)
;
}
if
(
!
reader
.
CanRead32
(
)
)
{
return
;
}
reader
.
ReadU32
(
)
;
if
(
size
)
{
reader
.
Seek
(
end
)
;
}
}
}
