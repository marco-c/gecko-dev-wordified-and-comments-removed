#
include
<
assert
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
vector
>
#
include
"
ClearKeyCDM
.
h
"
#
include
"
ClearKeySessionManager
.
h
"
#
include
"
stddef
.
h
"
#
include
"
content_decryption_module
.
h
"
#
include
"
content_decryption_module_ext
.
h
"
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
XP_LINUX
)
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
ifdef
ENABLE_WMF
#
include
"
WMFUtils
.
h
"
#
endif
extern
"
C
"
{
CDM_API
void
INITIALIZE_CDM_MODULE
(
)
{
}
static
bool
sCanReadHostVerificationFiles
=
false
;
CDM_API
void
*
CreateCdmInstance
(
int
cdm_interface_version
const
char
*
key_system
uint32_t
key_system_size
GetCdmHostFunc
get_cdm_host_func
void
*
user_data
)
{
CK_LOGE
(
"
ClearKey
CreateCDMInstance
"
)
;
#
ifdef
ENABLE_WMF
if
(
!
wmf
:
:
EnsureLibs
(
)
)
{
CK_LOGE
(
"
Required
libraries
were
not
found
"
)
;
return
nullptr
;
}
#
endif
if
(
!
sCanReadHostVerificationFiles
)
{
return
nullptr
;
}
cdm
:
:
Host_8
*
host
=
static_cast
<
cdm
:
:
Host_8
*
>
(
get_cdm_host_func
(
cdm_interface_version
user_data
)
)
;
ClearKeyCDM
*
clearKey
=
new
ClearKeyCDM
(
host
)
;
CK_LOGE
(
"
Created
ClearKeyCDM
instance
!
"
)
;
return
clearKey
;
}
const
size_t
TEST_READ_SIZE
=
16
*
1024
;
bool
CanReadSome
(
cdm
:
:
PlatformFile
aFile
)
{
vector
<
uint8_t
>
data
;
data
.
resize
(
TEST_READ_SIZE
)
;
#
ifdef
XP_WIN
DWORD
bytesRead
=
0
;
return
ReadFile
(
aFile
&
data
.
front
(
)
TEST_READ_SIZE
&
bytesRead
nullptr
)
&
&
bytesRead
>
0
;
#
elif
defined
(
XP_MACOSX
)
|
|
defined
(
XP_LINUX
)
return
read
(
aFile
&
data
.
front
(
)
TEST_READ_SIZE
)
>
0
;
#
else
return
false
;
#
endif
}
void
ClosePlatformFile
(
cdm
:
:
PlatformFile
aFile
)
{
#
ifdef
XP_WIN
CloseHandle
(
aFile
)
;
#
elif
defined
(
XP_MACOSX
)
|
|
defined
(
XP_LINUX
)
close
(
aFile
)
;
#
endif
}
CDM_API
bool
VerifyCdmHost_0
(
const
cdm
:
:
HostFile
*
aHostFiles
uint32_t
aNumFiles
)
{
bool
rv
=
(
aNumFiles
=
=
4
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumFiles
;
i
+
+
)
{
const
cdm
:
:
HostFile
&
hostFile
=
aHostFiles
[
i
]
;
if
(
hostFile
.
file
!
=
cdm
:
:
kInvalidPlatformFile
)
{
if
(
!
CanReadSome
(
hostFile
.
file
)
)
{
rv
=
false
;
}
ClosePlatformFile
(
hostFile
.
file
)
;
}
if
(
hostFile
.
sig_file
!
=
cdm
:
:
kInvalidPlatformFile
)
{
ClosePlatformFile
(
hostFile
.
sig_file
)
;
}
}
sCanReadHostVerificationFiles
=
rv
;
return
rv
;
}
}
