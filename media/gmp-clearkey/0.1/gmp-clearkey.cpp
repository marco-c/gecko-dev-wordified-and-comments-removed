#
include
<
assert
.
h
>
#
include
<
stddef
.
h
>
#
include
<
string
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
content_decryption_module
.
h
"
#
include
"
content_decryption_module_ext
.
h
"
#
include
"
nss
.
h
"
#
include
"
ClearKeyCDM
.
h
"
#
include
"
ClearKeySessionManager
.
h
"
#
include
"
mozilla
/
dom
/
KeySystemNames
.
h
"
#
ifndef
XP_WIN
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
ifdef
ENABLE_WMF
#
include
"
WMFUtils
.
h
"
#
endif
extern
"
C
"
{
CDM_API
void
INITIALIZE_CDM_MODULE
(
)
{
}
static
bool
sCanReadHostVerificationFiles
=
false
;
CDM_API
void
*
CreateCdmInstance
(
int
cdm_interface_version
const
char
*
key_system
uint32_t
key_system_size
GetCdmHostFunc
get_cdm_host_func
void
*
user_data
)
{
CK_LOGE
(
"
ClearKey
CreateCDMInstance
"
)
;
if
(
cdm_interface_version
!
=
cdm
:
:
ContentDecryptionModule_11
:
:
kVersion
)
{
CK_LOGE
(
"
ClearKey
CreateCDMInstance
failed
due
to
requesting
unsupported
"
"
version
%
d
.
"
cdm_interface_version
)
;
return
nullptr
;
}
#
ifdef
ENABLE_WMF
if
(
!
wmf
:
:
EnsureLibs
(
)
)
{
CK_LOGE
(
"
Required
libraries
were
not
found
"
)
;
return
nullptr
;
}
#
endif
if
(
NSS_NoDB_Init
(
nullptr
)
=
=
SECFailure
)
{
CK_LOGE
(
"
Unable
to
initialize
NSS
"
)
;
return
nullptr
;
}
#
ifdef
MOZILLA_OFFICIAL
if
(
!
sCanReadHostVerificationFiles
)
{
return
nullptr
;
}
#
endif
cdm
:
:
Host_11
*
host
=
static_cast
<
cdm
:
:
Host_11
*
>
(
get_cdm_host_func
(
cdm_interface_version
user_data
)
)
;
ClearKeyCDM
*
clearKey
=
new
ClearKeyCDM
(
host
)
;
CK_LOGE
(
"
Created
ClearKeyCDM
instance
!
"
)
;
if
(
strncmp
(
key_system
mozilla
:
:
kClearKeyWithProtectionQueryKeySystemName
key_system_size
)
=
=
0
)
{
CK_LOGE
(
"
Enabling
protection
query
on
ClearKeyCDM
instance
!
"
)
;
clearKey
-
>
EnableProtectionQuery
(
)
;
}
return
clearKey
;
}
const
size_t
TEST_READ_SIZE
=
16
*
1024
;
bool
CanReadSome
(
cdm
:
:
PlatformFile
aFile
)
{
std
:
:
vector
<
uint8_t
>
data
;
data
.
resize
(
TEST_READ_SIZE
)
;
#
ifdef
XP_WIN
DWORD
bytesRead
=
0
;
return
ReadFile
(
aFile
&
data
.
front
(
)
TEST_READ_SIZE
&
bytesRead
nullptr
)
&
&
bytesRead
>
0
;
#
else
return
read
(
aFile
&
data
.
front
(
)
TEST_READ_SIZE
)
>
0
;
#
endif
}
void
ClosePlatformFile
(
cdm
:
:
PlatformFile
aFile
)
{
#
ifdef
XP_WIN
CloseHandle
(
aFile
)
;
#
else
close
(
aFile
)
;
#
endif
}
static
uint32_t
NumExpectedHostFiles
(
const
cdm
:
:
HostFile
*
aHostFiles
uint32_t
aNumFiles
)
{
#
if
defined
(
ANDROID
)
return
1
;
#
elif
!
defined
(
XP_WIN
)
return
4
;
#
else
bool
i686underAArch64
=
false
;
const
std
:
:
wstring
plugincontainer
=
L
"
i686
\
\
plugin
-
container
.
exe
"
;
for
(
uint32_t
i
=
0
;
i
<
aNumFiles
;
i
+
+
)
{
const
cdm
:
:
HostFile
&
hostFile
=
aHostFiles
[
i
]
;
if
(
hostFile
.
file
!
=
cdm
:
:
kInvalidPlatformFile
)
{
std
:
:
wstring
path
=
hostFile
.
file_path
;
auto
offset
=
path
.
find
(
plugincontainer
)
;
if
(
offset
!
=
std
:
:
string
:
:
npos
&
&
offset
=
=
path
.
size
(
)
-
plugincontainer
.
size
(
)
)
{
i686underAArch64
=
true
;
break
;
}
}
}
return
i686underAArch64
?
5
:
4
;
#
endif
}
CDM_API
bool
VerifyCdmHost_0
(
const
cdm
:
:
HostFile
*
aHostFiles
uint32_t
aNumFiles
)
{
bool
rv
=
(
aNumFiles
=
=
NumExpectedHostFiles
(
aHostFiles
aNumFiles
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aNumFiles
;
i
+
+
)
{
const
cdm
:
:
HostFile
&
hostFile
=
aHostFiles
[
i
]
;
if
(
hostFile
.
file
!
=
cdm
:
:
kInvalidPlatformFile
)
{
if
(
!
CanReadSome
(
hostFile
.
file
)
)
{
rv
=
false
;
}
ClosePlatformFile
(
hostFile
.
file
)
;
}
if
(
hostFile
.
sig_file
!
=
cdm
:
:
kInvalidPlatformFile
)
{
ClosePlatformFile
(
hostFile
.
sig_file
)
;
}
}
sCanReadHostVerificationFiles
=
rv
;
return
rv
;
}
}
