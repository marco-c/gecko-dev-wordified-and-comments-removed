#
define
JPEG_INTERNALS
#
include
"
jinclude
.
h
"
#
include
"
jpeglib
.
h
"
#
include
"
jlossls
.
h
"
#
include
"
jdhuff
.
h
"
#
ifdef
D_LOSSLESS_SUPPORTED
typedef
struct
{
int
ci
yoffset
MCU_width
;
}
lhd_output_ptr_info
;
typedef
struct
{
struct
jpeg_entropy_decoder
pub
;
bitread_perm_state
bitstate
;
d_derived_tbl
*
derived_tbls
[
NUM_HUFF_TBLS
]
;
d_derived_tbl
*
cur_tbls
[
D_MAX_BLOCKS_IN_MCU
]
;
JDIFFROW
output_ptr
[
D_MAX_BLOCKS_IN_MCU
]
;
int
num_output_ptrs
;
lhd_output_ptr_info
output_ptr_info
[
D_MAX_BLOCKS_IN_MCU
]
;
int
output_ptr_index
[
D_MAX_BLOCKS_IN_MCU
]
;
}
lhuff_entropy_decoder
;
typedef
lhuff_entropy_decoder
*
lhuff_entropy_ptr
;
METHODDEF
(
void
)
start_pass_lhuff_decoder
(
j_decompress_ptr
cinfo
)
{
lhuff_entropy_ptr
entropy
=
(
lhuff_entropy_ptr
)
cinfo
-
>
entropy
;
int
ci
dctbl
sampn
ptrn
yoffset
xoffset
;
jpeg_component_info
*
compptr
;
for
(
ci
=
0
;
ci
<
cinfo
-
>
comps_in_scan
;
ci
+
+
)
{
compptr
=
cinfo
-
>
cur_comp_info
[
ci
]
;
dctbl
=
compptr
-
>
dc_tbl_no
;
if
(
dctbl
<
0
|
|
dctbl
>
=
NUM_HUFF_TBLS
|
|
cinfo
-
>
dc_huff_tbl_ptrs
[
dctbl
]
=
=
NULL
)
ERREXIT1
(
cinfo
JERR_NO_HUFF_TABLE
dctbl
)
;
jpeg_make_d_derived_tbl
(
cinfo
TRUE
dctbl
&
entropy
-
>
derived_tbls
[
dctbl
]
)
;
}
for
(
sampn
=
0
ptrn
=
0
;
sampn
<
cinfo
-
>
blocks_in_MCU
;
)
{
compptr
=
cinfo
-
>
cur_comp_info
[
cinfo
-
>
MCU_membership
[
sampn
]
]
;
ci
=
compptr
-
>
component_index
;
for
(
yoffset
=
0
;
yoffset
<
compptr
-
>
MCU_height
;
yoffset
+
+
ptrn
+
+
)
{
entropy
-
>
output_ptr_info
[
ptrn
]
.
ci
=
ci
;
entropy
-
>
output_ptr_info
[
ptrn
]
.
yoffset
=
yoffset
;
entropy
-
>
output_ptr_info
[
ptrn
]
.
MCU_width
=
compptr
-
>
MCU_width
;
for
(
xoffset
=
0
;
xoffset
<
compptr
-
>
MCU_width
;
xoffset
+
+
sampn
+
+
)
{
entropy
-
>
output_ptr_index
[
sampn
]
=
ptrn
;
entropy
-
>
cur_tbls
[
sampn
]
=
entropy
-
>
derived_tbls
[
compptr
-
>
dc_tbl_no
]
;
}
}
}
entropy
-
>
num_output_ptrs
=
ptrn
;
entropy
-
>
bitstate
.
bits_left
=
0
;
entropy
-
>
bitstate
.
get_buffer
=
0
;
entropy
-
>
pub
.
insufficient_data
=
FALSE
;
}
#
define
AVOID_TABLES
#
ifdef
AVOID_TABLES
#
define
NEG_1
(
(
unsigned
int
)
-
1
)
#
define
HUFF_EXTEND
(
x
s
)
\
(
(
x
)
+
(
(
(
(
x
)
-
(
1
<
<
(
(
s
)
-
1
)
)
)
>
>
31
)
&
(
(
(
NEG_1
)
<
<
(
s
)
)
+
1
)
)
)
#
else
#
define
HUFF_EXTEND
(
x
s
)
\
(
(
x
)
<
extend_test
[
s
]
?
(
x
)
+
extend_offset
[
s
]
:
(
x
)
)
static
const
int
extend_test
[
16
]
=
{
0
0x0001
0x0002
0x0004
0x0008
0x0010
0x0020
0x0040
0x0080
0x0100
0x0200
0x0400
0x0800
0x1000
0x2000
0x4000
}
;
static
const
int
extend_offset
[
16
]
=
{
0
(
(
-
1
)
<
<
1
)
+
1
(
(
-
1
)
<
<
2
)
+
1
(
(
-
1
)
<
<
3
)
+
1
(
(
-
1
)
<
<
4
)
+
1
(
(
-
1
)
<
<
5
)
+
1
(
(
-
1
)
<
<
6
)
+
1
(
(
-
1
)
<
<
7
)
+
1
(
(
-
1
)
<
<
8
)
+
1
(
(
-
1
)
<
<
9
)
+
1
(
(
-
1
)
<
<
10
)
+
1
(
(
-
1
)
<
<
11
)
+
1
(
(
-
1
)
<
<
12
)
+
1
(
(
-
1
)
<
<
13
)
+
1
(
(
-
1
)
<
<
14
)
+
1
(
(
-
1
)
<
<
15
)
+
1
}
;
#
endif
LOCAL
(
boolean
)
process_restart
(
j_decompress_ptr
cinfo
)
{
lhuff_entropy_ptr
entropy
=
(
lhuff_entropy_ptr
)
cinfo
-
>
entropy
;
cinfo
-
>
marker
-
>
discarded_bytes
+
=
entropy
-
>
bitstate
.
bits_left
/
8
;
entropy
-
>
bitstate
.
bits_left
=
0
;
if
(
!
(
*
cinfo
-
>
marker
-
>
read_restart_marker
)
(
cinfo
)
)
return
FALSE
;
if
(
cinfo
-
>
unread_marker
=
=
0
)
entropy
-
>
pub
.
insufficient_data
=
FALSE
;
return
TRUE
;
}
METHODDEF
(
JDIMENSION
)
decode_mcus
(
j_decompress_ptr
cinfo
JDIFFIMAGE
diff_buf
JDIMENSION
MCU_row_num
JDIMENSION
MCU_col_num
JDIMENSION
nMCU
)
{
lhuff_entropy_ptr
entropy
=
(
lhuff_entropy_ptr
)
cinfo
-
>
entropy
;
int
sampn
ci
yoffset
MCU_width
ptrn
;
JDIMENSION
mcu_num
;
BITREAD_STATE_VARS
;
for
(
ptrn
=
0
;
ptrn
<
entropy
-
>
num_output_ptrs
;
ptrn
+
+
)
{
ci
=
entropy
-
>
output_ptr_info
[
ptrn
]
.
ci
;
yoffset
=
entropy
-
>
output_ptr_info
[
ptrn
]
.
yoffset
;
MCU_width
=
entropy
-
>
output_ptr_info
[
ptrn
]
.
MCU_width
;
entropy
-
>
output_ptr
[
ptrn
]
=
diff_buf
[
ci
]
[
MCU_row_num
+
yoffset
]
+
(
MCU_col_num
*
MCU_width
)
;
}
if
(
entropy
-
>
pub
.
insufficient_data
)
{
for
(
ptrn
=
0
;
ptrn
<
entropy
-
>
num_output_ptrs
;
ptrn
+
+
)
jzero_far
(
(
void
FAR
*
)
entropy
-
>
output_ptr
[
ptrn
]
nMCU
*
entropy
-
>
output_ptr_info
[
ptrn
]
.
MCU_width
*
sizeof
(
JDIFF
)
)
;
(
*
cinfo
-
>
idct
-
>
start_pass
)
(
cinfo
)
;
}
else
{
BITREAD_LOAD_STATE
(
cinfo
entropy
-
>
bitstate
)
;
for
(
mcu_num
=
0
;
mcu_num
<
nMCU
;
mcu_num
+
+
)
{
for
(
sampn
=
0
;
sampn
<
cinfo
-
>
blocks_in_MCU
;
sampn
+
+
)
{
d_derived_tbl
*
dctbl
=
entropy
-
>
cur_tbls
[
sampn
]
;
register
int
s
r
;
HUFF_DECODE
(
s
br_state
dctbl
return
mcu_num
label1
)
;
if
(
s
)
{
if
(
s
=
=
16
)
s
=
32768
;
else
{
CHECK_BIT_BUFFER
(
br_state
s
return
mcu_num
)
;
r
=
GET_BITS
(
s
)
;
s
=
HUFF_EXTEND
(
r
s
)
;
}
}
*
entropy
-
>
output_ptr
[
entropy
-
>
output_ptr_index
[
sampn
]
]
+
+
=
(
JDIFF
)
s
;
}
BITREAD_SAVE_STATE
(
cinfo
entropy
-
>
bitstate
)
;
}
}
return
nMCU
;
}
GLOBAL
(
void
)
jinit_lhuff_decoder
(
j_decompress_ptr
cinfo
)
{
lhuff_entropy_ptr
entropy
;
int
i
;
entropy
=
(
lhuff_entropy_ptr
)
(
*
cinfo
-
>
mem
-
>
alloc_small
)
(
(
j_common_ptr
)
cinfo
JPOOL_IMAGE
sizeof
(
lhuff_entropy_decoder
)
)
;
cinfo
-
>
entropy
=
(
struct
jpeg_entropy_decoder
*
)
entropy
;
entropy
-
>
pub
.
start_pass
=
start_pass_lhuff_decoder
;
entropy
-
>
pub
.
decode_mcus
=
decode_mcus
;
entropy
-
>
pub
.
process_restart
=
process_restart
;
for
(
i
=
0
;
i
<
NUM_HUFF_TBLS
;
i
+
+
)
{
entropy
-
>
derived_tbls
[
i
]
=
NULL
;
}
}
#
endif
