void
jsimd_rgb_ycc_convert_neon
(
JDIMENSION
image_width
JSAMPARRAY
input_buf
JSAMPIMAGE
output_buf
JDIMENSION
output_row
int
num_rows
)
{
JSAMPROW
inptr
;
JSAMPROW
outptr0
outptr1
outptr2
;
ALIGN
(
16
)
uint8_t
tmp_buf
[
8
*
RGB_PIXELSIZE
]
;
#
ifdef
HAVE_VLD1_U16_X2
const
uint16x4x2_t
consts
=
vld1_u16_x2
(
jsimd_rgb_ycc_neon_consts
)
;
#
else
const
uint16x4_t
consts1
=
vld1_u16
(
jsimd_rgb_ycc_neon_consts
)
;
const
uint16x4_t
consts2
=
vld1_u16
(
jsimd_rgb_ycc_neon_consts
+
4
)
;
const
uint16x4x2_t
consts
=
{
{
consts1
consts2
}
}
;
#
endif
const
uint32x4_t
scaled_128_5
=
vdupq_n_u32
(
(
128
<
<
16
)
+
32767
)
;
while
(
-
-
num_rows
>
=
0
)
{
inptr
=
*
input_buf
+
+
;
outptr0
=
output_buf
[
0
]
[
output_row
]
;
outptr1
=
output_buf
[
1
]
[
output_row
]
;
outptr2
=
output_buf
[
2
]
[
output_row
]
;
output_row
+
+
;
int
cols_remaining
=
image_width
;
for
(
;
cols_remaining
>
0
;
cols_remaining
-
=
8
)
{
if
(
cols_remaining
<
8
)
{
memcpy
(
tmp_buf
inptr
cols_remaining
*
RGB_PIXELSIZE
)
;
inptr
=
tmp_buf
;
}
#
if
RGB_PIXELSIZE
=
=
4
uint8x8x4_t
input_pixels
=
vld4_u8
(
inptr
)
;
#
else
uint8x8x3_t
input_pixels
=
vld3_u8
(
inptr
)
;
#
endif
uint16x8_t
r
=
vmovl_u8
(
input_pixels
.
val
[
RGB_RED
]
)
;
uint16x8_t
g
=
vmovl_u8
(
input_pixels
.
val
[
RGB_GREEN
]
)
;
uint16x8_t
b
=
vmovl_u8
(
input_pixels
.
val
[
RGB_BLUE
]
)
;
uint32x4_t
y_low
=
vmull_lane_u16
(
vget_low_u16
(
r
)
consts
.
val
[
0
]
0
)
;
y_low
=
vmlal_lane_u16
(
y_low
vget_low_u16
(
g
)
consts
.
val
[
0
]
1
)
;
y_low
=
vmlal_lane_u16
(
y_low
vget_low_u16
(
b
)
consts
.
val
[
0
]
2
)
;
uint32x4_t
y_high
=
vmull_lane_u16
(
vget_high_u16
(
r
)
consts
.
val
[
0
]
0
)
;
y_high
=
vmlal_lane_u16
(
y_high
vget_high_u16
(
g
)
consts
.
val
[
0
]
1
)
;
y_high
=
vmlal_lane_u16
(
y_high
vget_high_u16
(
b
)
consts
.
val
[
0
]
2
)
;
uint32x4_t
cb_low
=
scaled_128_5
;
cb_low
=
vmlsl_lane_u16
(
cb_low
vget_low_u16
(
r
)
consts
.
val
[
0
]
3
)
;
cb_low
=
vmlsl_lane_u16
(
cb_low
vget_low_u16
(
g
)
consts
.
val
[
1
]
0
)
;
cb_low
=
vmlal_lane_u16
(
cb_low
vget_low_u16
(
b
)
consts
.
val
[
1
]
1
)
;
uint32x4_t
cb_high
=
scaled_128_5
;
cb_high
=
vmlsl_lane_u16
(
cb_high
vget_high_u16
(
r
)
consts
.
val
[
0
]
3
)
;
cb_high
=
vmlsl_lane_u16
(
cb_high
vget_high_u16
(
g
)
consts
.
val
[
1
]
0
)
;
cb_high
=
vmlal_lane_u16
(
cb_high
vget_high_u16
(
b
)
consts
.
val
[
1
]
1
)
;
uint32x4_t
cr_low
=
scaled_128_5
;
cr_low
=
vmlal_lane_u16
(
cr_low
vget_low_u16
(
r
)
consts
.
val
[
1
]
1
)
;
cr_low
=
vmlsl_lane_u16
(
cr_low
vget_low_u16
(
g
)
consts
.
val
[
1
]
2
)
;
cr_low
=
vmlsl_lane_u16
(
cr_low
vget_low_u16
(
b
)
consts
.
val
[
1
]
3
)
;
uint32x4_t
cr_high
=
scaled_128_5
;
cr_high
=
vmlal_lane_u16
(
cr_high
vget_high_u16
(
r
)
consts
.
val
[
1
]
1
)
;
cr_high
=
vmlsl_lane_u16
(
cr_high
vget_high_u16
(
g
)
consts
.
val
[
1
]
2
)
;
cr_high
=
vmlsl_lane_u16
(
cr_high
vget_high_u16
(
b
)
consts
.
val
[
1
]
3
)
;
uint16x8_t
y_u16
=
vcombine_u16
(
vrshrn_n_u32
(
y_low
16
)
vrshrn_n_u32
(
y_high
16
)
)
;
uint16x8_t
cb_u16
=
vcombine_u16
(
vshrn_n_u32
(
cb_low
16
)
vshrn_n_u32
(
cb_high
16
)
)
;
uint16x8_t
cr_u16
=
vcombine_u16
(
vshrn_n_u32
(
cr_low
16
)
vshrn_n_u32
(
cr_high
16
)
)
;
vst1_u8
(
outptr0
vmovn_u16
(
y_u16
)
)
;
vst1_u8
(
outptr1
vmovn_u16
(
cb_u16
)
)
;
vst1_u8
(
outptr2
vmovn_u16
(
cr_u16
)
)
;
inptr
+
=
(
8
*
RGB_PIXELSIZE
)
;
outptr0
+
=
8
;
outptr1
+
=
8
;
outptr2
+
=
8
;
}
}
}
