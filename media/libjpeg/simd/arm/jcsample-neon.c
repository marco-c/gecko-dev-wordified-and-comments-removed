#
define
JPEG_INTERNALS
#
include
"
.
.
/
.
.
/
jinclude
.
h
"
#
include
"
.
.
/
.
.
/
jpeglib
.
h
"
#
include
"
.
.
/
.
.
/
jsimd
.
h
"
#
include
"
.
.
/
.
.
/
jdct
.
h
"
#
include
"
.
.
/
.
.
/
jsimddct
.
h
"
#
include
"
.
.
/
jsimd
.
h
"
#
include
"
align
.
h
"
#
include
<
arm_neon
.
h
>
ALIGN
(
16
)
static
const
uint8_t
jsimd_h2_downsample_consts
[
]
=
{
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0E
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0D
0x0D
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0C
0x0C
0x0C
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0B
0x0B
0x0B
0x0B
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0A
0x0A
0x0A
0x0A
0x0A
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x09
0x09
0x09
0x09
0x09
0x09
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x08
0x08
0x08
0x08
0x08
0x08
0x08
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x07
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x06
0x06
0x06
0x06
0x06
0x06
0x06
0x06
0x06
0x00
0x01
0x02
0x03
0x04
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x05
0x00
0x01
0x02
0x03
0x04
0x04
0x04
0x04
0x04
0x04
0x04
0x04
0x04
0x04
0x04
0x04
0x00
0x01
0x02
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x03
0x00
0x01
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x02
0x00
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x01
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
;
void
jsimd_h2v1_downsample_neon
(
JDIMENSION
image_width
int
max_v_samp_factor
JDIMENSION
v_samp_factor
JDIMENSION
width_in_blocks
JSAMPARRAY
input_data
JSAMPARRAY
output_data
)
{
JSAMPROW
inptr
outptr
;
const
int
mask_offset
=
16
*
(
(
width_in_blocks
*
2
*
DCTSIZE
)
-
image_width
)
;
const
uint8x16_t
expand_mask
=
vld1q_u8
(
&
jsimd_h2_downsample_consts
[
mask_offset
]
)
;
const
uint16x8_t
bias
=
vreinterpretq_u16_u32
(
vdupq_n_u32
(
0x00010000
)
)
;
unsigned
i
outrow
;
for
(
outrow
=
0
;
outrow
<
v_samp_factor
;
outrow
+
+
)
{
outptr
=
output_data
[
outrow
]
;
inptr
=
input_data
[
outrow
]
;
for
(
i
=
0
;
i
<
width_in_blocks
-
1
;
i
+
+
)
{
uint8x16_t
pixels
=
vld1q_u8
(
inptr
+
i
*
2
*
DCTSIZE
)
;
uint16x8_t
samples_u16
=
vpadalq_u8
(
bias
pixels
)
;
uint8x8_t
samples_u8
=
vshrn_n_u16
(
samples_u16
1
)
;
vst1_u8
(
outptr
+
i
*
DCTSIZE
samples_u8
)
;
}
uint8x16_t
pixels
=
vld1q_u8
(
inptr
+
(
width_in_blocks
-
1
)
*
2
*
DCTSIZE
)
;
#
if
defined
(
__aarch64__
)
|
|
defined
(
_M_ARM64
)
pixels
=
vqtbl1q_u8
(
pixels
expand_mask
)
;
#
else
uint8x8x2_t
table
=
{
{
vget_low_u8
(
pixels
)
vget_high_u8
(
pixels
)
}
}
;
pixels
=
vcombine_u8
(
vtbl2_u8
(
table
vget_low_u8
(
expand_mask
)
)
vtbl2_u8
(
table
vget_high_u8
(
expand_mask
)
)
)
;
#
endif
uint16x8_t
samples_u16
=
vpadalq_u8
(
bias
pixels
)
;
uint8x8_t
samples_u8
=
vshrn_n_u16
(
samples_u16
1
)
;
vst1_u8
(
outptr
+
(
width_in_blocks
-
1
)
*
DCTSIZE
samples_u8
)
;
}
}
void
jsimd_h2v2_downsample_neon
(
JDIMENSION
image_width
int
max_v_samp_factor
JDIMENSION
v_samp_factor
JDIMENSION
width_in_blocks
JSAMPARRAY
input_data
JSAMPARRAY
output_data
)
{
JSAMPROW
inptr0
inptr1
outptr
;
const
int
mask_offset
=
16
*
(
(
width_in_blocks
*
2
*
DCTSIZE
)
-
image_width
)
;
const
uint8x16_t
expand_mask
=
vld1q_u8
(
&
jsimd_h2_downsample_consts
[
mask_offset
]
)
;
const
uint16x8_t
bias
=
vreinterpretq_u16_u32
(
vdupq_n_u32
(
0x00020001
)
)
;
unsigned
i
outrow
;
for
(
outrow
=
0
;
outrow
<
v_samp_factor
;
outrow
+
+
)
{
outptr
=
output_data
[
outrow
]
;
inptr0
=
input_data
[
outrow
]
;
inptr1
=
input_data
[
outrow
+
1
]
;
for
(
i
=
0
;
i
<
width_in_blocks
-
1
;
i
+
+
)
{
uint8x16_t
pixels_r0
=
vld1q_u8
(
inptr0
+
i
*
2
*
DCTSIZE
)
;
uint8x16_t
pixels_r1
=
vld1q_u8
(
inptr1
+
i
*
2
*
DCTSIZE
)
;
uint16x8_t
samples_u16
=
vpadalq_u8
(
bias
pixels_r0
)
;
samples_u16
=
vpadalq_u8
(
samples_u16
pixels_r1
)
;
uint8x8_t
samples_u8
=
vshrn_n_u16
(
samples_u16
2
)
;
vst1_u8
(
outptr
+
i
*
DCTSIZE
samples_u8
)
;
}
uint8x16_t
pixels_r0
=
vld1q_u8
(
inptr0
+
(
width_in_blocks
-
1
)
*
2
*
DCTSIZE
)
;
uint8x16_t
pixels_r1
=
vld1q_u8
(
inptr1
+
(
width_in_blocks
-
1
)
*
2
*
DCTSIZE
)
;
#
if
defined
(
__aarch64__
)
|
|
defined
(
_M_ARM64
)
pixels_r0
=
vqtbl1q_u8
(
pixels_r0
expand_mask
)
;
pixels_r1
=
vqtbl1q_u8
(
pixels_r1
expand_mask
)
;
#
else
uint8x8x2_t
table_r0
=
{
{
vget_low_u8
(
pixels_r0
)
vget_high_u8
(
pixels_r0
)
}
}
;
uint8x8x2_t
table_r1
=
{
{
vget_low_u8
(
pixels_r1
)
vget_high_u8
(
pixels_r1
)
}
}
;
pixels_r0
=
vcombine_u8
(
vtbl2_u8
(
table_r0
vget_low_u8
(
expand_mask
)
)
vtbl2_u8
(
table_r0
vget_high_u8
(
expand_mask
)
)
)
;
pixels_r1
=
vcombine_u8
(
vtbl2_u8
(
table_r1
vget_low_u8
(
expand_mask
)
)
vtbl2_u8
(
table_r1
vget_high_u8
(
expand_mask
)
)
)
;
#
endif
uint16x8_t
samples_u16
=
vpadalq_u8
(
bias
pixels_r0
)
;
samples_u16
=
vpadalq_u8
(
samples_u16
pixels_r1
)
;
uint8x8_t
samples_u8
=
vshrn_n_u16
(
samples_u16
2
)
;
vst1_u8
(
outptr
+
(
width_in_blocks
-
1
)
*
DCTSIZE
samples_u8
)
;
}
}
