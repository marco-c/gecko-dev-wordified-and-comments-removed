#
define
JPEG_INTERNALS
#
include
"
jinclude
.
h
"
#
include
"
jpeglib
.
h
"
#
include
"
jlossls
.
h
"
#
ifdef
D_LOSSLESS_SUPPORTED
typedef
struct
{
struct
jpeg_d_coef_controller
pub
;
JDIMENSION
MCU_ctr
;
unsigned
int
restart_rows_to_go
;
unsigned
int
MCU_vert_offset
;
unsigned
int
MCU_rows_per_iMCU_row
;
JDIFFARRAY
diff_buf
[
MAX_COMPONENTS
]
;
JDIFFARRAY
undiff_buf
[
MAX_COMPONENTS
]
;
#
ifdef
D_MULTISCAN_FILES_SUPPORTED
jvirt_sarray_ptr
whole_image
[
MAX_COMPONENTS
]
;
#
endif
}
my_diff_controller
;
typedef
my_diff_controller
*
my_diff_ptr
;
METHODDEF
(
int
)
decompress_data
(
j_decompress_ptr
cinfo
_JSAMPIMAGE
output_buf
)
;
#
ifdef
D_MULTISCAN_FILES_SUPPORTED
METHODDEF
(
int
)
output_data
(
j_decompress_ptr
cinfo
_JSAMPIMAGE
output_buf
)
;
#
endif
LOCAL
(
void
)
start_iMCU_row
(
j_decompress_ptr
cinfo
)
{
my_diff_ptr
diff
=
(
my_diff_ptr
)
cinfo
-
>
coef
;
if
(
cinfo
-
>
comps_in_scan
>
1
)
{
diff
-
>
MCU_rows_per_iMCU_row
=
1
;
}
else
{
if
(
cinfo
-
>
input_iMCU_row
<
(
cinfo
-
>
total_iMCU_rows
-
1
)
)
diff
-
>
MCU_rows_per_iMCU_row
=
cinfo
-
>
cur_comp_info
[
0
]
-
>
v_samp_factor
;
else
diff
-
>
MCU_rows_per_iMCU_row
=
cinfo
-
>
cur_comp_info
[
0
]
-
>
last_row_height
;
}
diff
-
>
MCU_ctr
=
0
;
diff
-
>
MCU_vert_offset
=
0
;
}
METHODDEF
(
void
)
start_input_pass
(
j_decompress_ptr
cinfo
)
{
my_diff_ptr
diff
=
(
my_diff_ptr
)
cinfo
-
>
coef
;
(
*
cinfo
-
>
idct
-
>
start_pass
)
(
cinfo
)
;
if
(
cinfo
-
>
restart_interval
%
cinfo
-
>
MCUs_per_row
!
=
0
)
ERREXIT2
(
cinfo
JERR_BAD_RESTART
cinfo
-
>
restart_interval
cinfo
-
>
MCUs_per_row
)
;
diff
-
>
restart_rows_to_go
=
cinfo
-
>
restart_interval
/
cinfo
-
>
MCUs_per_row
;
cinfo
-
>
input_iMCU_row
=
0
;
start_iMCU_row
(
cinfo
)
;
}
METHODDEF
(
boolean
)
process_restart
(
j_decompress_ptr
cinfo
)
{
my_diff_ptr
diff
=
(
my_diff_ptr
)
cinfo
-
>
coef
;
if
(
!
(
*
cinfo
-
>
entropy
-
>
process_restart
)
(
cinfo
)
)
return
FALSE
;
(
*
cinfo
-
>
idct
-
>
start_pass
)
(
cinfo
)
;
diff
-
>
restart_rows_to_go
=
cinfo
-
>
restart_interval
/
cinfo
-
>
MCUs_per_row
;
return
TRUE
;
}
METHODDEF
(
void
)
start_output_pass
(
j_decompress_ptr
cinfo
)
{
cinfo
-
>
output_iMCU_row
=
0
;
}
METHODDEF
(
int
)
decompress_data
(
j_decompress_ptr
cinfo
_JSAMPIMAGE
output_buf
)
{
my_diff_ptr
diff
=
(
my_diff_ptr
)
cinfo
-
>
coef
;
lossless_decomp_ptr
losslessd
=
(
lossless_decomp_ptr
)
cinfo
-
>
idct
;
JDIMENSION
MCU_col_num
;
JDIMENSION
MCU_count
;
JDIMENSION
last_iMCU_row
=
cinfo
-
>
total_iMCU_rows
-
1
;
int
ci
compi
row
prev_row
;
unsigned
int
yoffset
;
jpeg_component_info
*
compptr
;
for
(
yoffset
=
diff
-
>
MCU_vert_offset
;
yoffset
<
diff
-
>
MCU_rows_per_iMCU_row
;
yoffset
+
+
)
{
if
(
cinfo
-
>
restart_interval
)
{
if
(
diff
-
>
restart_rows_to_go
=
=
0
)
if
(
!
process_restart
(
cinfo
)
)
return
JPEG_SUSPENDED
;
}
MCU_col_num
=
diff
-
>
MCU_ctr
;
MCU_count
=
(
*
cinfo
-
>
entropy
-
>
decode_mcus
)
(
cinfo
diff
-
>
diff_buf
yoffset
MCU_col_num
cinfo
-
>
MCUs_per_row
-
MCU_col_num
)
;
if
(
MCU_count
!
=
cinfo
-
>
MCUs_per_row
-
MCU_col_num
)
{
diff
-
>
MCU_vert_offset
=
yoffset
;
diff
-
>
MCU_ctr
+
=
MCU_count
;
return
JPEG_SUSPENDED
;
}
if
(
cinfo
-
>
restart_interval
)
diff
-
>
restart_rows_to_go
-
-
;
diff
-
>
MCU_ctr
=
0
;
}
for
(
ci
=
0
;
ci
<
cinfo
-
>
comps_in_scan
;
ci
+
+
)
{
compptr
=
cinfo
-
>
cur_comp_info
[
ci
]
;
compi
=
compptr
-
>
component_index
;
for
(
row
=
0
prev_row
=
compptr
-
>
v_samp_factor
-
1
;
row
<
(
cinfo
-
>
input_iMCU_row
=
=
last_iMCU_row
?
compptr
-
>
last_row_height
:
compptr
-
>
v_samp_factor
)
;
prev_row
=
row
row
+
+
)
{
(
*
losslessd
-
>
predict_undifference
[
compi
]
)
(
cinfo
compi
diff
-
>
diff_buf
[
compi
]
[
row
]
diff
-
>
undiff_buf
[
compi
]
[
prev_row
]
diff
-
>
undiff_buf
[
compi
]
[
row
]
compptr
-
>
width_in_blocks
)
;
(
*
losslessd
-
>
scaler_scale
)
(
cinfo
diff
-
>
undiff_buf
[
compi
]
[
row
]
output_buf
[
compi
]
[
row
]
compptr
-
>
width_in_blocks
)
;
}
}
if
(
+
+
(
cinfo
-
>
input_iMCU_row
)
<
cinfo
-
>
total_iMCU_rows
)
{
start_iMCU_row
(
cinfo
)
;
return
JPEG_ROW_COMPLETED
;
}
(
*
cinfo
-
>
inputctl
-
>
finish_input_pass
)
(
cinfo
)
;
return
JPEG_SCAN_COMPLETED
;
}
METHODDEF
(
int
)
dummy_consume_data
(
j_decompress_ptr
cinfo
)
{
return
JPEG_SUSPENDED
;
}
#
ifdef
D_MULTISCAN_FILES_SUPPORTED
METHODDEF
(
int
)
consume_data
(
j_decompress_ptr
cinfo
)
{
my_diff_ptr
diff
=
(
my_diff_ptr
)
cinfo
-
>
coef
;
int
ci
compi
;
_JSAMPARRAY
buffer
[
MAX_COMPS_IN_SCAN
]
;
jpeg_component_info
*
compptr
;
for
(
ci
=
0
;
ci
<
cinfo
-
>
comps_in_scan
;
ci
+
+
)
{
compptr
=
cinfo
-
>
cur_comp_info
[
ci
]
;
compi
=
compptr
-
>
component_index
;
buffer
[
compi
]
=
(
_JSAMPARRAY
)
(
*
cinfo
-
>
mem
-
>
access_virt_sarray
)
(
(
j_common_ptr
)
cinfo
diff
-
>
whole_image
[
compi
]
cinfo
-
>
input_iMCU_row
*
compptr
-
>
v_samp_factor
(
JDIMENSION
)
compptr
-
>
v_samp_factor
TRUE
)
;
}
return
decompress_data
(
cinfo
buffer
)
;
}
METHODDEF
(
int
)
output_data
(
j_decompress_ptr
cinfo
_JSAMPIMAGE
output_buf
)
{
my_diff_ptr
diff
=
(
my_diff_ptr
)
cinfo
-
>
coef
;
JDIMENSION
last_iMCU_row
=
cinfo
-
>
total_iMCU_rows
-
1
;
int
ci
samp_rows
row
;
_JSAMPARRAY
buffer
;
jpeg_component_info
*
compptr
;
while
(
cinfo
-
>
input_scan_number
<
cinfo
-
>
output_scan_number
|
|
(
cinfo
-
>
input_scan_number
=
=
cinfo
-
>
output_scan_number
&
&
cinfo
-
>
input_iMCU_row
<
=
cinfo
-
>
output_iMCU_row
)
)
{
if
(
(
*
cinfo
-
>
inputctl
-
>
consume_input
)
(
cinfo
)
=
=
JPEG_SUSPENDED
)
return
JPEG_SUSPENDED
;
}
for
(
ci
=
0
compptr
=
cinfo
-
>
comp_info
;
ci
<
cinfo
-
>
num_components
;
ci
+
+
compptr
+
+
)
{
buffer
=
(
_JSAMPARRAY
)
(
*
cinfo
-
>
mem
-
>
access_virt_sarray
)
(
(
j_common_ptr
)
cinfo
diff
-
>
whole_image
[
ci
]
cinfo
-
>
output_iMCU_row
*
compptr
-
>
v_samp_factor
(
JDIMENSION
)
compptr
-
>
v_samp_factor
FALSE
)
;
if
(
cinfo
-
>
output_iMCU_row
<
last_iMCU_row
)
samp_rows
=
compptr
-
>
v_samp_factor
;
else
{
samp_rows
=
(
int
)
(
compptr
-
>
height_in_blocks
%
compptr
-
>
v_samp_factor
)
;
if
(
samp_rows
=
=
0
)
samp_rows
=
compptr
-
>
v_samp_factor
;
}
for
(
row
=
0
;
row
<
samp_rows
;
row
+
+
)
{
memcpy
(
output_buf
[
ci
]
[
row
]
buffer
[
row
]
compptr
-
>
width_in_blocks
*
sizeof
(
_JSAMPLE
)
)
;
}
}
if
(
+
+
(
cinfo
-
>
output_iMCU_row
)
<
cinfo
-
>
total_iMCU_rows
)
return
JPEG_ROW_COMPLETED
;
return
JPEG_SCAN_COMPLETED
;
}
#
endif
GLOBAL
(
void
)
_jinit_d_diff_controller
(
j_decompress_ptr
cinfo
boolean
need_full_buffer
)
{
my_diff_ptr
diff
;
int
ci
;
jpeg_component_info
*
compptr
;
diff
=
(
my_diff_ptr
)
(
*
cinfo
-
>
mem
-
>
alloc_small
)
(
(
j_common_ptr
)
cinfo
JPOOL_IMAGE
sizeof
(
my_diff_controller
)
)
;
cinfo
-
>
coef
=
(
struct
jpeg_d_coef_controller
*
)
diff
;
diff
-
>
pub
.
start_input_pass
=
start_input_pass
;
diff
-
>
pub
.
start_output_pass
=
start_output_pass
;
for
(
ci
=
0
compptr
=
cinfo
-
>
comp_info
;
ci
<
cinfo
-
>
num_components
;
ci
+
+
compptr
+
+
)
{
diff
-
>
diff_buf
[
ci
]
=
ALLOC_DARRAY
(
JPOOL_IMAGE
(
JDIMENSION
)
jround_up
(
(
long
)
compptr
-
>
width_in_blocks
(
long
)
compptr
-
>
h_samp_factor
)
(
JDIMENSION
)
compptr
-
>
v_samp_factor
)
;
diff
-
>
undiff_buf
[
ci
]
=
ALLOC_DARRAY
(
JPOOL_IMAGE
(
JDIMENSION
)
jround_up
(
(
long
)
compptr
-
>
width_in_blocks
(
long
)
compptr
-
>
h_samp_factor
)
(
JDIMENSION
)
compptr
-
>
v_samp_factor
)
;
}
if
(
need_full_buffer
)
{
#
ifdef
D_MULTISCAN_FILES_SUPPORTED
int
access_rows
;
for
(
ci
=
0
compptr
=
cinfo
-
>
comp_info
;
ci
<
cinfo
-
>
num_components
;
ci
+
+
compptr
+
+
)
{
access_rows
=
compptr
-
>
v_samp_factor
;
diff
-
>
whole_image
[
ci
]
=
(
*
cinfo
-
>
mem
-
>
request_virt_sarray
)
(
(
j_common_ptr
)
cinfo
JPOOL_IMAGE
FALSE
(
JDIMENSION
)
jround_up
(
(
long
)
compptr
-
>
width_in_blocks
(
long
)
compptr
-
>
h_samp_factor
)
(
JDIMENSION
)
jround_up
(
(
long
)
compptr
-
>
height_in_blocks
(
long
)
compptr
-
>
v_samp_factor
)
(
JDIMENSION
)
access_rows
)
;
}
diff
-
>
pub
.
consume_data
=
consume_data
;
diff
-
>
pub
.
_decompress_data
=
output_data
;
#
else
ERREXIT
(
cinfo
JERR_NOT_COMPILED
)
;
#
endif
}
else
{
diff
-
>
pub
.
consume_data
=
dummy_consume_data
;
diff
-
>
pub
.
_decompress_data
=
decompress_data
;
diff
-
>
whole_image
[
0
]
=
NULL
;
}
}
#
endif
