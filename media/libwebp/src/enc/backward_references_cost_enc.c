#
include
<
assert
.
h
>
#
include
<
string
.
h
>
#
include
"
src
/
dsp
/
lossless_common
.
h
"
#
include
"
src
/
enc
/
backward_references_enc
.
h
"
#
include
"
src
/
enc
/
histogram_enc
.
h
"
#
include
"
src
/
utils
/
color_cache_utils
.
h
"
#
include
"
src
/
utils
/
utils
.
h
"
#
define
VALUES_IN_BYTE
256
extern
void
VP8LClearBackwardRefs
(
VP8LBackwardRefs
*
const
refs
)
;
extern
int
VP8LDistanceToPlaneCode
(
int
xsize
int
dist
)
;
extern
void
VP8LBackwardRefsCursorAdd
(
VP8LBackwardRefs
*
const
refs
const
PixOrCopy
v
)
;
typedef
struct
{
uint32_t
alpha_
[
VALUES_IN_BYTE
]
;
uint32_t
red_
[
VALUES_IN_BYTE
]
;
uint32_t
blue_
[
VALUES_IN_BYTE
]
;
uint32_t
distance_
[
NUM_DISTANCE_CODES
]
;
uint32_t
*
literal_
;
}
CostModel
;
static
void
ConvertPopulationCountTableToBitEstimates
(
int
num_symbols
const
uint32_t
population_counts
[
]
uint32_t
output
[
]
)
{
uint32_t
sum
=
0
;
int
nonzeros
=
0
;
int
i
;
for
(
i
=
0
;
i
<
num_symbols
;
+
+
i
)
{
sum
+
=
population_counts
[
i
]
;
if
(
population_counts
[
i
]
>
0
)
{
+
+
nonzeros
;
}
}
if
(
nonzeros
<
=
1
)
{
memset
(
output
0
num_symbols
*
sizeof
(
*
output
)
)
;
}
else
{
const
uint32_t
logsum
=
VP8LFastLog2
(
sum
)
;
for
(
i
=
0
;
i
<
num_symbols
;
+
+
i
)
{
output
[
i
]
=
logsum
-
VP8LFastLog2
(
population_counts
[
i
]
)
;
}
}
}
static
int
CostModelBuild
(
CostModel
*
const
m
int
xsize
int
cache_bits
const
VP8LBackwardRefs
*
const
refs
)
{
int
ok
=
0
;
VP8LRefsCursor
c
=
VP8LRefsCursorInit
(
refs
)
;
VP8LHistogram
*
const
histo
=
VP8LAllocateHistogram
(
cache_bits
)
;
if
(
histo
=
=
NULL
)
goto
Error
;
VP8LHistogramInit
(
histo
cache_bits
1
)
;
while
(
VP8LRefsCursorOk
(
&
c
)
)
{
VP8LHistogramAddSinglePixOrCopy
(
histo
c
.
cur_pos
VP8LDistanceToPlaneCode
xsize
)
;
VP8LRefsCursorNext
(
&
c
)
;
}
ConvertPopulationCountTableToBitEstimates
(
VP8LHistogramNumCodes
(
histo
-
>
palette_code_bits_
)
histo
-
>
literal_
m
-
>
literal_
)
;
ConvertPopulationCountTableToBitEstimates
(
VALUES_IN_BYTE
histo
-
>
red_
m
-
>
red_
)
;
ConvertPopulationCountTableToBitEstimates
(
VALUES_IN_BYTE
histo
-
>
blue_
m
-
>
blue_
)
;
ConvertPopulationCountTableToBitEstimates
(
VALUES_IN_BYTE
histo
-
>
alpha_
m
-
>
alpha_
)
;
ConvertPopulationCountTableToBitEstimates
(
NUM_DISTANCE_CODES
histo
-
>
distance_
m
-
>
distance_
)
;
ok
=
1
;
Error
:
VP8LFreeHistogram
(
histo
)
;
return
ok
;
}
static
WEBP_INLINE
int64_t
GetLiteralCost
(
const
CostModel
*
const
m
uint32_t
v
)
{
return
(
int64_t
)
m
-
>
alpha_
[
v
>
>
24
]
+
m
-
>
red_
[
(
v
>
>
16
)
&
0xff
]
+
m
-
>
literal_
[
(
v
>
>
8
)
&
0xff
]
+
m
-
>
blue_
[
v
&
0xff
]
;
}
static
WEBP_INLINE
int64_t
GetCacheCost
(
const
CostModel
*
const
m
uint32_t
idx
)
{
const
int
literal_idx
=
VALUES_IN_BYTE
+
NUM_LENGTH_CODES
+
idx
;
return
(
int64_t
)
m
-
>
literal_
[
literal_idx
]
;
}
static
WEBP_INLINE
int64_t
GetLengthCost
(
const
CostModel
*
const
m
uint32_t
length
)
{
int
code
extra_bits
;
VP8LPrefixEncodeBits
(
length
&
code
&
extra_bits
)
;
return
(
int64_t
)
m
-
>
literal_
[
VALUES_IN_BYTE
+
code
]
+
(
(
int64_t
)
extra_bits
<
<
LOG_2_PRECISION_BITS
)
;
}
static
WEBP_INLINE
int64_t
GetDistanceCost
(
const
CostModel
*
const
m
uint32_t
distance
)
{
int
code
extra_bits
;
VP8LPrefixEncodeBits
(
distance
&
code
&
extra_bits
)
;
return
(
int64_t
)
m
-
>
distance_
[
code
]
+
(
(
int64_t
)
extra_bits
<
<
LOG_2_PRECISION_BITS
)
;
}
static
WEBP_INLINE
void
AddSingleLiteralWithCostModel
(
const
uint32_t
*
const
argb
VP8LColorCache
*
const
hashers
const
CostModel
*
const
cost_model
int
idx
int
use_color_cache
int64_t
prev_cost
int64_t
*
const
cost
uint16_t
*
const
dist_array
)
{
int64_t
cost_val
=
prev_cost
;
const
uint32_t
color
=
argb
[
idx
]
;
const
int
ix
=
use_color_cache
?
VP8LColorCacheContains
(
hashers
color
)
:
-
1
;
if
(
ix
>
=
0
)
{
cost_val
+
=
DivRound
(
GetCacheCost
(
cost_model
ix
)
*
68
100
)
;
}
else
{
if
(
use_color_cache
)
VP8LColorCacheInsert
(
hashers
color
)
;
cost_val
+
=
DivRound
(
GetLiteralCost
(
cost_model
color
)
*
82
100
)
;
}
if
(
cost
[
idx
]
>
cost_val
)
{
cost
[
idx
]
=
cost_val
;
dist_array
[
idx
]
=
1
;
}
}
#
define
COST_CACHE_INTERVAL_SIZE_MAX
500
typedef
struct
CostInterval
CostInterval
;
struct
CostInterval
{
int64_t
cost_
;
int
start_
;
int
end_
;
int
index_
;
CostInterval
*
previous_
;
CostInterval
*
next_
;
}
;
typedef
struct
{
int64_t
cost_
;
int
start_
;
int
end_
;
}
CostCacheInterval
;
#
define
COST_MANAGER_MAX_FREE_LIST
10
typedef
struct
{
CostInterval
*
head_
;
int
count_
;
CostCacheInterval
*
cache_intervals_
;
size_t
cache_intervals_size_
;
int64_t
cost_cache_
[
MAX_LENGTH
]
;
int64_t
*
costs_
;
uint16_t
*
dist_array_
;
CostInterval
intervals_
[
COST_MANAGER_MAX_FREE_LIST
]
;
CostInterval
*
free_intervals_
;
CostInterval
*
recycled_intervals_
;
}
CostManager
;
static
void
CostIntervalAddToFreeList
(
CostManager
*
const
manager
CostInterval
*
const
interval
)
{
interval
-
>
next_
=
manager
-
>
free_intervals_
;
manager
-
>
free_intervals_
=
interval
;
}
static
int
CostIntervalIsInFreeList
(
const
CostManager
*
const
manager
const
CostInterval
*
const
interval
)
{
return
(
interval
>
=
&
manager
-
>
intervals_
[
0
]
&
&
interval
<
=
&
manager
-
>
intervals_
[
COST_MANAGER_MAX_FREE_LIST
-
1
]
)
;
}
static
void
CostManagerInitFreeList
(
CostManager
*
const
manager
)
{
int
i
;
manager
-
>
free_intervals_
=
NULL
;
for
(
i
=
0
;
i
<
COST_MANAGER_MAX_FREE_LIST
;
+
+
i
)
{
CostIntervalAddToFreeList
(
manager
&
manager
-
>
intervals_
[
i
]
)
;
}
}
static
void
DeleteIntervalList
(
CostManager
*
const
manager
const
CostInterval
*
interval
)
{
while
(
interval
!
=
NULL
)
{
const
CostInterval
*
const
next
=
interval
-
>
next_
;
if
(
!
CostIntervalIsInFreeList
(
manager
interval
)
)
{
WebPSafeFree
(
(
void
*
)
interval
)
;
}
interval
=
next
;
}
}
static
void
CostManagerClear
(
CostManager
*
const
manager
)
{
if
(
manager
=
=
NULL
)
return
;
WebPSafeFree
(
manager
-
>
costs_
)
;
WebPSafeFree
(
manager
-
>
cache_intervals_
)
;
DeleteIntervalList
(
manager
manager
-
>
head_
)
;
manager
-
>
head_
=
NULL
;
DeleteIntervalList
(
manager
manager
-
>
recycled_intervals_
)
;
manager
-
>
recycled_intervals_
=
NULL
;
memset
(
manager
0
sizeof
(
*
manager
)
)
;
CostManagerInitFreeList
(
manager
)
;
}
static
int
CostManagerInit
(
CostManager
*
const
manager
uint16_t
*
const
dist_array
int
pix_count
const
CostModel
*
const
cost_model
)
{
int
i
;
const
int
cost_cache_size
=
(
pix_count
>
MAX_LENGTH
)
?
MAX_LENGTH
:
pix_count
;
manager
-
>
costs_
=
NULL
;
manager
-
>
cache_intervals_
=
NULL
;
manager
-
>
head_
=
NULL
;
manager
-
>
recycled_intervals_
=
NULL
;
manager
-
>
count_
=
0
;
manager
-
>
dist_array_
=
dist_array
;
CostManagerInitFreeList
(
manager
)
;
for
(
i
=
0
;
i
<
cost_cache_size
;
+
+
i
)
{
manager
-
>
cost_cache_
[
i
]
=
GetLengthCost
(
cost_model
i
)
;
}
manager
-
>
cache_intervals_size_
=
1
;
for
(
i
=
1
;
i
<
cost_cache_size
;
+
+
i
)
{
if
(
manager
-
>
cost_cache_
[
i
]
!
=
manager
-
>
cost_cache_
[
i
-
1
]
)
{
+
+
manager
-
>
cache_intervals_size_
;
}
}
assert
(
manager
-
>
cache_intervals_size_
<
=
MAX_LENGTH
)
;
manager
-
>
cache_intervals_
=
(
CostCacheInterval
*
)
WebPSafeMalloc
(
manager
-
>
cache_intervals_size_
sizeof
(
*
manager
-
>
cache_intervals_
)
)
;
if
(
manager
-
>
cache_intervals_
=
=
NULL
)
{
CostManagerClear
(
manager
)
;
return
0
;
}
{
CostCacheInterval
*
cur
=
manager
-
>
cache_intervals_
;
cur
-
>
start_
=
0
;
cur
-
>
end_
=
1
;
cur
-
>
cost_
=
manager
-
>
cost_cache_
[
0
]
;
for
(
i
=
1
;
i
<
cost_cache_size
;
+
+
i
)
{
const
int64_t
cost_val
=
manager
-
>
cost_cache_
[
i
]
;
if
(
cost_val
!
=
cur
-
>
cost_
)
{
+
+
cur
;
cur
-
>
start_
=
i
;
cur
-
>
cost_
=
cost_val
;
}
cur
-
>
end_
=
i
+
1
;
}
assert
(
(
size_t
)
(
cur
-
manager
-
>
cache_intervals_
)
+
1
=
=
manager
-
>
cache_intervals_size_
)
;
}
manager
-
>
costs_
=
(
int64_t
*
)
WebPSafeMalloc
(
pix_count
sizeof
(
*
manager
-
>
costs_
)
)
;
if
(
manager
-
>
costs_
=
=
NULL
)
{
CostManagerClear
(
manager
)
;
return
0
;
}
for
(
i
=
0
;
i
<
pix_count
;
+
+
i
)
manager
-
>
costs_
[
i
]
=
WEBP_INT64_MAX
;
return
1
;
}
static
WEBP_INLINE
void
UpdateCost
(
CostManager
*
const
manager
int
i
int
position
int64_t
cost
)
{
const
int
k
=
i
-
position
;
assert
(
k
>
=
0
&
&
k
<
MAX_LENGTH
)
;
if
(
manager
-
>
costs_
[
i
]
>
cost
)
{
manager
-
>
costs_
[
i
]
=
cost
;
manager
-
>
dist_array_
[
i
]
=
k
+
1
;
}
}
static
WEBP_INLINE
void
UpdateCostPerInterval
(
CostManager
*
const
manager
int
start
int
end
int
position
int64_t
cost
)
{
int
i
;
for
(
i
=
start
;
i
<
end
;
+
+
i
)
UpdateCost
(
manager
i
position
cost
)
;
}
static
WEBP_INLINE
void
ConnectIntervals
(
CostManager
*
const
manager
CostInterval
*
const
prev
CostInterval
*
const
next
)
{
if
(
prev
!
=
NULL
)
{
prev
-
>
next_
=
next
;
}
else
{
manager
-
>
head_
=
next
;
}
if
(
next
!
=
NULL
)
next
-
>
previous_
=
prev
;
}
static
WEBP_INLINE
void
PopInterval
(
CostManager
*
const
manager
CostInterval
*
const
interval
)
{
if
(
interval
=
=
NULL
)
return
;
ConnectIntervals
(
manager
interval
-
>
previous_
interval
-
>
next_
)
;
if
(
CostIntervalIsInFreeList
(
manager
interval
)
)
{
CostIntervalAddToFreeList
(
manager
interval
)
;
}
else
{
interval
-
>
next_
=
manager
-
>
recycled_intervals_
;
manager
-
>
recycled_intervals_
=
interval
;
}
-
-
manager
-
>
count_
;
assert
(
manager
-
>
count_
>
=
0
)
;
}
static
WEBP_INLINE
void
UpdateCostAtIndex
(
CostManager
*
const
manager
int
i
int
do_clean_intervals
)
{
CostInterval
*
current
=
manager
-
>
head_
;
while
(
current
!
=
NULL
&
&
current
-
>
start_
<
=
i
)
{
CostInterval
*
const
next
=
current
-
>
next_
;
if
(
current
-
>
end_
<
=
i
)
{
if
(
do_clean_intervals
)
{
PopInterval
(
manager
current
)
;
}
}
else
{
UpdateCost
(
manager
i
current
-
>
index_
current
-
>
cost_
)
;
}
current
=
next
;
}
}
static
WEBP_INLINE
void
PositionOrphanInterval
(
CostManager
*
const
manager
CostInterval
*
const
current
CostInterval
*
previous
)
{
assert
(
current
!
=
NULL
)
;
if
(
previous
=
=
NULL
)
previous
=
manager
-
>
head_
;
while
(
previous
!
=
NULL
&
&
current
-
>
start_
<
previous
-
>
start_
)
{
previous
=
previous
-
>
previous_
;
}
while
(
previous
!
=
NULL
&
&
previous
-
>
next_
!
=
NULL
&
&
previous
-
>
next_
-
>
start_
<
current
-
>
start_
)
{
previous
=
previous
-
>
next_
;
}
if
(
previous
!
=
NULL
)
{
ConnectIntervals
(
manager
current
previous
-
>
next_
)
;
}
else
{
ConnectIntervals
(
manager
current
manager
-
>
head_
)
;
}
ConnectIntervals
(
manager
previous
current
)
;
}
static
WEBP_INLINE
void
InsertInterval
(
CostManager
*
const
manager
CostInterval
*
const
interval_in
int64_t
cost
int
position
int
start
int
end
)
{
CostInterval
*
interval_new
;
if
(
start
>
=
end
)
return
;
if
(
manager
-
>
count_
>
=
COST_CACHE_INTERVAL_SIZE_MAX
)
{
UpdateCostPerInterval
(
manager
start
end
position
cost
)
;
return
;
}
if
(
manager
-
>
free_intervals_
!
=
NULL
)
{
interval_new
=
manager
-
>
free_intervals_
;
manager
-
>
free_intervals_
=
interval_new
-
>
next_
;
}
else
if
(
manager
-
>
recycled_intervals_
!
=
NULL
)
{
interval_new
=
manager
-
>
recycled_intervals_
;
manager
-
>
recycled_intervals_
=
interval_new
-
>
next_
;
}
else
{
interval_new
=
(
CostInterval
*
)
WebPSafeMalloc
(
1
sizeof
(
*
interval_new
)
)
;
if
(
interval_new
=
=
NULL
)
{
UpdateCostPerInterval
(
manager
start
end
position
cost
)
;
return
;
}
}
interval_new
-
>
cost_
=
cost
;
interval_new
-
>
index_
=
position
;
interval_new
-
>
start_
=
start
;
interval_new
-
>
end_
=
end
;
PositionOrphanInterval
(
manager
interval_new
interval_in
)
;
+
+
manager
-
>
count_
;
}
static
WEBP_INLINE
void
PushInterval
(
CostManager
*
const
manager
int64_t
distance_cost
int
position
int
len
)
{
size_t
i
;
CostInterval
*
interval
=
manager
-
>
head_
;
CostInterval
*
interval_next
;
const
CostCacheInterval
*
const
cost_cache_intervals
=
manager
-
>
cache_intervals_
;
const
int
kSkipDistance
=
10
;
if
(
len
<
kSkipDistance
)
{
int
j
;
for
(
j
=
position
;
j
<
position
+
len
;
+
+
j
)
{
const
int
k
=
j
-
position
;
int64_t
cost_tmp
;
assert
(
k
>
=
0
&
&
k
<
MAX_LENGTH
)
;
cost_tmp
=
distance_cost
+
manager
-
>
cost_cache_
[
k
]
;
if
(
manager
-
>
costs_
[
j
]
>
cost_tmp
)
{
manager
-
>
costs_
[
j
]
=
cost_tmp
;
manager
-
>
dist_array_
[
j
]
=
k
+
1
;
}
}
return
;
}
for
(
i
=
0
;
i
<
manager
-
>
cache_intervals_size_
&
&
cost_cache_intervals
[
i
]
.
start_
<
len
;
+
+
i
)
{
int
start
=
position
+
cost_cache_intervals
[
i
]
.
start_
;
const
int
end
=
position
+
(
cost_cache_intervals
[
i
]
.
end_
>
len
?
len
:
cost_cache_intervals
[
i
]
.
end_
)
;
const
int64_t
cost
=
distance_cost
+
cost_cache_intervals
[
i
]
.
cost_
;
for
(
;
interval
!
=
NULL
&
&
interval
-
>
start_
<
end
;
interval
=
interval_next
)
{
interval_next
=
interval
-
>
next_
;
if
(
start
>
=
interval
-
>
end_
)
continue
;
if
(
cost
>
=
interval
-
>
cost_
)
{
const
int
start_new
=
interval
-
>
end_
;
InsertInterval
(
manager
interval
cost
position
start
interval
-
>
start_
)
;
start
=
start_new
;
if
(
start
>
=
end
)
break
;
continue
;
}
if
(
start
<
=
interval
-
>
start_
)
{
if
(
interval
-
>
end_
<
=
end
)
{
PopInterval
(
manager
interval
)
;
}
else
{
interval
-
>
start_
=
end
;
break
;
}
}
else
{
if
(
end
<
interval
-
>
end_
)
{
const
int
end_original
=
interval
-
>
end_
;
interval
-
>
end_
=
start
;
InsertInterval
(
manager
interval
interval
-
>
cost_
interval
-
>
index_
end
end_original
)
;
interval
=
interval
-
>
next_
;
break
;
}
else
{
interval
-
>
end_
=
start
;
}
}
}
InsertInterval
(
manager
interval
cost
position
start
end
)
;
}
}
static
int
BackwardReferencesHashChainDistanceOnly
(
int
xsize
int
ysize
const
uint32_t
*
const
argb
int
cache_bits
const
VP8LHashChain
*
const
hash_chain
const
VP8LBackwardRefs
*
const
refs
uint16_t
*
const
dist_array
)
{
int
i
;
int
ok
=
0
;
int
cc_init
=
0
;
const
int
pix_count
=
xsize
*
ysize
;
const
int
use_color_cache
=
(
cache_bits
>
0
)
;
const
size_t
literal_array_size
=
sizeof
(
*
(
(
CostModel
*
)
NULL
)
-
>
literal_
)
*
VP8LHistogramNumCodes
(
cache_bits
)
;
const
size_t
cost_model_size
=
sizeof
(
CostModel
)
+
literal_array_size
;
CostModel
*
const
cost_model
=
(
CostModel
*
)
WebPSafeCalloc
(
1ULL
cost_model_size
)
;
VP8LColorCache
hashers
;
CostManager
*
cost_manager
=
(
CostManager
*
)
WebPSafeCalloc
(
1ULL
sizeof
(
*
cost_manager
)
)
;
int
offset_prev
=
-
1
len_prev
=
-
1
;
int64_t
offset_cost
=
-
1
;
int
first_offset_is_constant
=
-
1
;
int
reach
=
0
;
if
(
cost_model
=
=
NULL
|
|
cost_manager
=
=
NULL
)
goto
Error
;
cost_model
-
>
literal_
=
(
uint32_t
*
)
(
cost_model
+
1
)
;
if
(
use_color_cache
)
{
cc_init
=
VP8LColorCacheInit
(
&
hashers
cache_bits
)
;
if
(
!
cc_init
)
goto
Error
;
}
if
(
!
CostModelBuild
(
cost_model
xsize
cache_bits
refs
)
)
{
goto
Error
;
}
if
(
!
CostManagerInit
(
cost_manager
dist_array
pix_count
cost_model
)
)
{
goto
Error
;
}
dist_array
[
0
]
=
0
;
AddSingleLiteralWithCostModel
(
argb
&
hashers
cost_model
0
use_color_cache
0
cost_manager
-
>
costs_
dist_array
)
;
for
(
i
=
1
;
i
<
pix_count
;
+
+
i
)
{
const
int64_t
prev_cost
=
cost_manager
-
>
costs_
[
i
-
1
]
;
int
offset
len
;
VP8LHashChainFindCopy
(
hash_chain
i
&
offset
&
len
)
;
AddSingleLiteralWithCostModel
(
argb
&
hashers
cost_model
i
use_color_cache
prev_cost
cost_manager
-
>
costs_
dist_array
)
;
if
(
len
>
=
2
)
{
if
(
offset
!
=
offset_prev
)
{
const
int
code
=
VP8LDistanceToPlaneCode
(
xsize
offset
)
;
offset_cost
=
GetDistanceCost
(
cost_model
code
)
;
first_offset_is_constant
=
1
;
PushInterval
(
cost_manager
prev_cost
+
offset_cost
i
len
)
;
}
else
{
assert
(
offset_cost
>
=
0
)
;
assert
(
len_prev
>
=
0
)
;
assert
(
first_offset_is_constant
=
=
0
|
|
first_offset_is_constant
=
=
1
)
;
if
(
first_offset_is_constant
)
{
reach
=
i
-
1
+
len_prev
-
1
;
first_offset_is_constant
=
0
;
}
if
(
i
+
len
-
1
>
reach
)
{
int
offset_j
len_j
=
0
;
int
j
;
assert
(
len
=
=
MAX_LENGTH
|
|
len
=
=
pix_count
-
i
)
;
for
(
j
=
i
;
j
<
=
reach
;
+
+
j
)
{
VP8LHashChainFindCopy
(
hash_chain
j
+
1
&
offset_j
&
len_j
)
;
if
(
offset_j
!
=
offset
)
{
VP8LHashChainFindCopy
(
hash_chain
j
&
offset_j
&
len_j
)
;
break
;
}
}
UpdateCostAtIndex
(
cost_manager
j
-
1
0
)
;
UpdateCostAtIndex
(
cost_manager
j
0
)
;
PushInterval
(
cost_manager
cost_manager
-
>
costs_
[
j
-
1
]
+
offset_cost
j
len_j
)
;
reach
=
j
+
len_j
-
1
;
}
}
}
UpdateCostAtIndex
(
cost_manager
i
1
)
;
offset_prev
=
offset
;
len_prev
=
len
;
}
ok
=
!
refs
-
>
error_
;
Error
:
if
(
cc_init
)
VP8LColorCacheClear
(
&
hashers
)
;
CostManagerClear
(
cost_manager
)
;
WebPSafeFree
(
cost_model
)
;
WebPSafeFree
(
cost_manager
)
;
return
ok
;
}
static
void
TraceBackwards
(
uint16_t
*
const
dist_array
int
dist_array_size
uint16_t
*
*
const
chosen_path
int
*
const
chosen_path_size
)
{
uint16_t
*
path
=
dist_array
+
dist_array_size
;
uint16_t
*
cur
=
dist_array
+
dist_array_size
-
1
;
while
(
cur
>
=
dist_array
)
{
const
int
k
=
*
cur
;
-
-
path
;
*
path
=
k
;
cur
-
=
k
;
}
*
chosen_path
=
path
;
*
chosen_path_size
=
(
int
)
(
dist_array
+
dist_array_size
-
path
)
;
}
static
int
BackwardReferencesHashChainFollowChosenPath
(
const
uint32_t
*
const
argb
int
cache_bits
const
uint16_t
*
const
chosen_path
int
chosen_path_size
const
VP8LHashChain
*
const
hash_chain
VP8LBackwardRefs
*
const
refs
)
{
const
int
use_color_cache
=
(
cache_bits
>
0
)
;
int
ix
;
int
i
=
0
;
int
ok
=
0
;
int
cc_init
=
0
;
VP8LColorCache
hashers
;
if
(
use_color_cache
)
{
cc_init
=
VP8LColorCacheInit
(
&
hashers
cache_bits
)
;
if
(
!
cc_init
)
goto
Error
;
}
VP8LClearBackwardRefs
(
refs
)
;
for
(
ix
=
0
;
ix
<
chosen_path_size
;
+
+
ix
)
{
const
int
len
=
chosen_path
[
ix
]
;
if
(
len
!
=
1
)
{
int
k
;
const
int
offset
=
VP8LHashChainFindOffset
(
hash_chain
i
)
;
VP8LBackwardRefsCursorAdd
(
refs
PixOrCopyCreateCopy
(
offset
len
)
)
;
if
(
use_color_cache
)
{
for
(
k
=
0
;
k
<
len
;
+
+
k
)
{
VP8LColorCacheInsert
(
&
hashers
argb
[
i
+
k
]
)
;
}
}
i
+
=
len
;
}
else
{
PixOrCopy
v
;
const
int
idx
=
use_color_cache
?
VP8LColorCacheContains
(
&
hashers
argb
[
i
]
)
:
-
1
;
if
(
idx
>
=
0
)
{
v
=
PixOrCopyCreateCacheIdx
(
idx
)
;
}
else
{
if
(
use_color_cache
)
VP8LColorCacheInsert
(
&
hashers
argb
[
i
]
)
;
v
=
PixOrCopyCreateLiteral
(
argb
[
i
]
)
;
}
VP8LBackwardRefsCursorAdd
(
refs
v
)
;
+
+
i
;
}
}
ok
=
!
refs
-
>
error_
;
Error
:
if
(
cc_init
)
VP8LColorCacheClear
(
&
hashers
)
;
return
ok
;
}
extern
int
VP8LBackwardReferencesTraceBackwards
(
int
xsize
int
ysize
const
uint32_t
*
const
argb
int
cache_bits
const
VP8LHashChain
*
const
hash_chain
const
VP8LBackwardRefs
*
const
refs_src
VP8LBackwardRefs
*
const
refs_dst
)
;
int
VP8LBackwardReferencesTraceBackwards
(
int
xsize
int
ysize
const
uint32_t
*
const
argb
int
cache_bits
const
VP8LHashChain
*
const
hash_chain
const
VP8LBackwardRefs
*
const
refs_src
VP8LBackwardRefs
*
const
refs_dst
)
{
int
ok
=
0
;
const
int
dist_array_size
=
xsize
*
ysize
;
uint16_t
*
chosen_path
=
NULL
;
int
chosen_path_size
=
0
;
uint16_t
*
dist_array
=
(
uint16_t
*
)
WebPSafeMalloc
(
dist_array_size
sizeof
(
*
dist_array
)
)
;
if
(
dist_array
=
=
NULL
)
goto
Error
;
if
(
!
BackwardReferencesHashChainDistanceOnly
(
xsize
ysize
argb
cache_bits
hash_chain
refs_src
dist_array
)
)
{
goto
Error
;
}
TraceBackwards
(
dist_array
dist_array_size
&
chosen_path
&
chosen_path_size
)
;
if
(
!
BackwardReferencesHashChainFollowChosenPath
(
argb
cache_bits
chosen_path
chosen_path_size
hash_chain
refs_dst
)
)
{
goto
Error
;
}
ok
=
1
;
Error
:
WebPSafeFree
(
dist_array
)
;
return
ok
;
}
