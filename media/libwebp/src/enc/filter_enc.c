#
include
<
assert
.
h
>
#
include
<
stddef
.
h
>
#
include
<
string
.
h
>
#
include
"
src
/
dec
/
common_dec
.
h
"
#
include
"
src
/
webp
/
types
.
h
"
#
include
"
src
/
dsp
/
dsp
.
h
"
#
include
"
src
/
enc
/
vp8i_enc
.
h
"
#
define
MAX_DELTA_SIZE
64
static
const
uint8_t
kLevelsFromDelta
[
8
]
[
MAX_DELTA_SIZE
]
=
{
{
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
}
{
0
1
2
3
5
6
7
8
9
11
12
13
14
15
17
18
20
21
23
24
26
27
29
30
32
33
35
36
38
39
41
42
44
45
47
48
50
51
53
54
56
57
59
60
62
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
}
{
0
1
2
3
5
6
7
8
9
11
12
13
14
16
17
19
20
22
23
25
26
28
29
31
32
34
35
37
38
40
41
43
44
46
47
49
50
52
53
55
56
58
59
61
62
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
}
{
0
1
2
3
5
6
7
8
9
11
12
13
15
16
18
19
21
22
24
25
27
28
30
31
33
34
36
37
39
40
42
43
45
46
48
49
51
52
54
55
57
58
60
61
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
}
{
0
1
2
3
5
6
7
8
9
11
12
14
15
17
18
20
21
23
24
26
27
29
30
32
33
35
36
38
39
41
42
44
45
47
48
50
51
53
54
56
57
59
60
62
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
}
{
0
1
2
4
5
7
8
9
11
12
13
15
16
17
19
20
22
23
25
26
28
29
31
32
34
35
37
38
40
41
43
44
46
47
49
50
52
53
55
56
58
59
61
62
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
}
{
0
1
2
4
5
7
8
9
11
12
13
15
16
18
19
21
22
24
25
27
28
30
31
33
34
36
37
39
40
42
43
45
46
48
49
51
52
54
55
57
58
60
61
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
}
{
0
1
2
4
5
7
8
9
11
12
14
15
17
18
20
21
23
24
26
27
29
30
32
33
35
36
38
39
41
42
44
45
47
48
50
51
53
54
56
57
59
60
62
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
63
}
}
;
int
VP8FilterStrengthFromDelta
(
int
sharpness
int
delta
)
{
const
int
pos
=
(
delta
<
MAX_DELTA_SIZE
)
?
delta
:
MAX_DELTA_SIZE
-
1
;
assert
(
sharpness
>
=
0
&
&
sharpness
<
=
7
)
;
return
kLevelsFromDelta
[
sharpness
]
[
pos
]
;
}
#
if
!
defined
(
WEBP_REDUCE_SIZE
)
static
int
GetILevel
(
int
sharpness
int
level
)
{
if
(
sharpness
>
0
)
{
if
(
sharpness
>
4
)
{
level
>
>
=
2
;
}
else
{
level
>
>
=
1
;
}
if
(
level
>
9
-
sharpness
)
{
level
=
9
-
sharpness
;
}
}
if
(
level
<
1
)
level
=
1
;
return
level
;
}
static
void
DoFilter
(
const
VP8EncIterator
*
const
it
int
level
)
{
const
VP8Encoder
*
const
enc
=
it
-
>
enc
;
const
int
ilevel
=
GetILevel
(
enc
-
>
config
-
>
filter_sharpness
level
)
;
const
int
limit
=
2
*
level
+
ilevel
;
uint8_t
*
const
y_dst
=
it
-
>
yuv_out2
+
Y_OFF_ENC
;
uint8_t
*
const
u_dst
=
it
-
>
yuv_out2
+
U_OFF_ENC
;
uint8_t
*
const
v_dst
=
it
-
>
yuv_out2
+
V_OFF_ENC
;
memcpy
(
y_dst
it
-
>
yuv_out
YUV_SIZE_ENC
*
sizeof
(
uint8_t
)
)
;
if
(
enc
-
>
filter_hdr
.
simple
=
=
1
)
{
VP8SimpleHFilter16i
(
y_dst
BPS
limit
)
;
VP8SimpleVFilter16i
(
y_dst
BPS
limit
)
;
}
else
{
const
int
hev_thresh
=
(
level
>
=
40
)
?
2
:
(
level
>
=
15
)
?
1
:
0
;
VP8HFilter16i
(
y_dst
BPS
limit
ilevel
hev_thresh
)
;
VP8HFilter8i
(
u_dst
v_dst
BPS
limit
ilevel
hev_thresh
)
;
VP8VFilter16i
(
y_dst
BPS
limit
ilevel
hev_thresh
)
;
VP8VFilter8i
(
u_dst
v_dst
BPS
limit
ilevel
hev_thresh
)
;
}
}
static
double
GetMBSSIM
(
const
uint8_t
*
yuv1
const
uint8_t
*
yuv2
)
{
int
x
y
;
double
sum
=
0
.
;
for
(
y
=
VP8_SSIM_KERNEL
;
y
<
16
-
VP8_SSIM_KERNEL
;
y
+
+
)
{
for
(
x
=
VP8_SSIM_KERNEL
;
x
<
16
-
VP8_SSIM_KERNEL
;
x
+
+
)
{
sum
+
=
VP8SSIMGetClipped
(
yuv1
+
Y_OFF_ENC
BPS
yuv2
+
Y_OFF_ENC
BPS
x
y
16
16
)
;
}
}
for
(
x
=
1
;
x
<
7
;
x
+
+
)
{
for
(
y
=
1
;
y
<
7
;
y
+
+
)
{
sum
+
=
VP8SSIMGetClipped
(
yuv1
+
U_OFF_ENC
BPS
yuv2
+
U_OFF_ENC
BPS
x
y
8
8
)
;
sum
+
=
VP8SSIMGetClipped
(
yuv1
+
V_OFF_ENC
BPS
yuv2
+
V_OFF_ENC
BPS
x
y
8
8
)
;
}
}
return
sum
;
}
#
endif
void
VP8InitFilter
(
VP8EncIterator
*
const
it
)
{
#
if
!
defined
(
WEBP_REDUCE_SIZE
)
if
(
it
-
>
lf_stats
!
=
NULL
)
{
int
s
i
;
for
(
s
=
0
;
s
<
NUM_MB_SEGMENTS
;
s
+
+
)
{
for
(
i
=
0
;
i
<
MAX_LF_LEVELS
;
i
+
+
)
{
(
*
it
-
>
lf_stats
)
[
s
]
[
i
]
=
0
;
}
}
VP8SSIMDspInit
(
)
;
}
#
else
(
void
)
it
;
#
endif
}
void
VP8StoreFilterStats
(
VP8EncIterator
*
const
it
)
{
#
if
!
defined
(
WEBP_REDUCE_SIZE
)
int
d
;
VP8Encoder
*
const
enc
=
it
-
>
enc
;
const
int
s
=
it
-
>
mb
-
>
segment
;
const
int
level0
=
enc
-
>
dqm
[
s
]
.
fstrength
;
const
int
delta_min
=
-
enc
-
>
dqm
[
s
]
.
quant
;
const
int
delta_max
=
enc
-
>
dqm
[
s
]
.
quant
;
const
int
step_size
=
(
delta_max
-
delta_min
>
=
4
)
?
4
:
1
;
if
(
it
-
>
lf_stats
=
=
NULL
)
return
;
if
(
it
-
>
mb
-
>
type
=
=
1
&
&
it
-
>
mb
-
>
skip
)
return
;
(
*
it
-
>
lf_stats
)
[
s
]
[
0
]
+
=
GetMBSSIM
(
it
-
>
yuv_in
it
-
>
yuv_out
)
;
for
(
d
=
delta_min
;
d
<
=
delta_max
;
d
+
=
step_size
)
{
const
int
level
=
level0
+
d
;
if
(
level
<
=
0
|
|
level
>
=
MAX_LF_LEVELS
)
{
continue
;
}
DoFilter
(
it
level
)
;
(
*
it
-
>
lf_stats
)
[
s
]
[
level
]
+
=
GetMBSSIM
(
it
-
>
yuv_in
it
-
>
yuv_out2
)
;
}
#
else
(
void
)
it
;
#
endif
}
void
VP8AdjustFilterStrength
(
VP8EncIterator
*
const
it
)
{
VP8Encoder
*
const
enc
=
it
-
>
enc
;
#
if
!
defined
(
WEBP_REDUCE_SIZE
)
if
(
it
-
>
lf_stats
!
=
NULL
)
{
int
s
;
for
(
s
=
0
;
s
<
NUM_MB_SEGMENTS
;
s
+
+
)
{
int
i
best_level
=
0
;
double
best_v
=
1
.
00001
*
(
*
it
-
>
lf_stats
)
[
s
]
[
0
]
;
for
(
i
=
1
;
i
<
MAX_LF_LEVELS
;
i
+
+
)
{
const
double
v
=
(
*
it
-
>
lf_stats
)
[
s
]
[
i
]
;
if
(
v
>
best_v
)
{
best_v
=
v
;
best_level
=
i
;
}
}
enc
-
>
dqm
[
s
]
.
fstrength
=
best_level
;
}
return
;
}
#
endif
if
(
enc
-
>
config
-
>
filter_strength
>
0
)
{
int
max_level
=
0
;
int
s
;
for
(
s
=
0
;
s
<
NUM_MB_SEGMENTS
;
s
+
+
)
{
VP8SegmentInfo
*
const
dqm
=
&
enc
-
>
dqm
[
s
]
;
const
int
delta
=
(
dqm
-
>
max_edge
*
dqm
-
>
y2
.
q
[
1
]
)
>
>
3
;
const
int
level
=
VP8FilterStrengthFromDelta
(
enc
-
>
filter_hdr
.
sharpness
delta
)
;
if
(
level
>
dqm
-
>
fstrength
)
{
dqm
-
>
fstrength
=
level
;
}
if
(
max_level
<
dqm
-
>
fstrength
)
{
max_level
=
dqm
-
>
fstrength
;
}
}
enc
-
>
filter_hdr
.
level
=
max_level
;
}
}
