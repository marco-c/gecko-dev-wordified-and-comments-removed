#
include
"
src
/
dsp
/
yuv
.
h
"
#
if
defined
(
WEBP_USE_SSE2
)
#
include
<
stdlib
.
h
>
#
include
<
emmintrin
.
h
>
#
include
"
src
/
dsp
/
common_sse2
.
h
"
#
include
"
src
/
utils
/
utils
.
h
"
static
void
ConvertYUV444ToRGB_SSE2
(
const
__m128i
*
const
Y0
const
__m128i
*
const
U0
const
__m128i
*
const
V0
__m128i
*
const
R
__m128i
*
const
G
__m128i
*
const
B
)
{
const
__m128i
k19077
=
_mm_set1_epi16
(
19077
)
;
const
__m128i
k26149
=
_mm_set1_epi16
(
26149
)
;
const
__m128i
k14234
=
_mm_set1_epi16
(
14234
)
;
const
__m128i
k33050
=
_mm_set1_epi16
(
(
short
)
33050
)
;
const
__m128i
k17685
=
_mm_set1_epi16
(
17685
)
;
const
__m128i
k6419
=
_mm_set1_epi16
(
6419
)
;
const
__m128i
k13320
=
_mm_set1_epi16
(
13320
)
;
const
__m128i
k8708
=
_mm_set1_epi16
(
8708
)
;
const
__m128i
Y1
=
_mm_mulhi_epu16
(
*
Y0
k19077
)
;
const
__m128i
R0
=
_mm_mulhi_epu16
(
*
V0
k26149
)
;
const
__m128i
R1
=
_mm_sub_epi16
(
Y1
k14234
)
;
const
__m128i
R2
=
_mm_add_epi16
(
R1
R0
)
;
const
__m128i
G0
=
_mm_mulhi_epu16
(
*
U0
k6419
)
;
const
__m128i
G1
=
_mm_mulhi_epu16
(
*
V0
k13320
)
;
const
__m128i
G2
=
_mm_add_epi16
(
Y1
k8708
)
;
const
__m128i
G3
=
_mm_add_epi16
(
G0
G1
)
;
const
__m128i
G4
=
_mm_sub_epi16
(
G2
G3
)
;
const
__m128i
B0
=
_mm_mulhi_epu16
(
*
U0
k33050
)
;
const
__m128i
B1
=
_mm_adds_epu16
(
B0
Y1
)
;
const
__m128i
B2
=
_mm_subs_epu16
(
B1
k17685
)
;
*
R
=
_mm_srai_epi16
(
R2
6
)
;
*
G
=
_mm_srai_epi16
(
G4
6
)
;
*
B
=
_mm_srli_epi16
(
B2
6
)
;
}
static
WEBP_INLINE
__m128i
Load_HI_16_SSE2
(
const
uint8_t
*
src
)
{
const
__m128i
zero
=
_mm_setzero_si128
(
)
;
return
_mm_unpacklo_epi8
(
zero
_mm_loadl_epi64
(
(
const
__m128i
*
)
src
)
)
;
}
static
WEBP_INLINE
__m128i
Load_UV_HI_8_SSE2
(
const
uint8_t
*
src
)
{
const
__m128i
zero
=
_mm_setzero_si128
(
)
;
const
__m128i
tmp0
=
_mm_cvtsi32_si128
(
WebPMemToInt32
(
src
)
)
;
const
__m128i
tmp1
=
_mm_unpacklo_epi8
(
zero
tmp0
)
;
return
_mm_unpacklo_epi16
(
tmp1
tmp1
)
;
}
static
void
YUV444ToRGB_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
const
y
const
uint8_t
*
WEBP_RESTRICT
const
u
const
uint8_t
*
WEBP_RESTRICT
const
v
__m128i
*
const
R
__m128i
*
const
G
__m128i
*
const
B
)
{
const
__m128i
Y0
=
Load_HI_16_SSE2
(
y
)
U0
=
Load_HI_16_SSE2
(
u
)
V0
=
Load_HI_16_SSE2
(
v
)
;
ConvertYUV444ToRGB_SSE2
(
&
Y0
&
U0
&
V0
R
G
B
)
;
}
static
void
YUV420ToRGB_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
const
y
const
uint8_t
*
WEBP_RESTRICT
const
u
const
uint8_t
*
WEBP_RESTRICT
const
v
__m128i
*
const
R
__m128i
*
const
G
__m128i
*
const
B
)
{
const
__m128i
Y0
=
Load_HI_16_SSE2
(
y
)
U0
=
Load_UV_HI_8_SSE2
(
u
)
V0
=
Load_UV_HI_8_SSE2
(
v
)
;
ConvertYUV444ToRGB_SSE2
(
&
Y0
&
U0
&
V0
R
G
B
)
;
}
static
WEBP_INLINE
void
PackAndStore4_SSE2
(
const
__m128i
*
const
R
const
__m128i
*
const
G
const
__m128i
*
const
B
const
__m128i
*
const
A
uint8_t
*
WEBP_RESTRICT
const
dst
)
{
const
__m128i
rb
=
_mm_packus_epi16
(
*
R
*
B
)
;
const
__m128i
ga
=
_mm_packus_epi16
(
*
G
*
A
)
;
const
__m128i
rg
=
_mm_unpacklo_epi8
(
rb
ga
)
;
const
__m128i
ba
=
_mm_unpackhi_epi8
(
rb
ga
)
;
const
__m128i
RGBA_lo
=
_mm_unpacklo_epi16
(
rg
ba
)
;
const
__m128i
RGBA_hi
=
_mm_unpackhi_epi16
(
rg
ba
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
dst
+
0
)
RGBA_lo
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
dst
+
16
)
RGBA_hi
)
;
}
static
WEBP_INLINE
void
PackAndStore4444_SSE2
(
const
__m128i
*
const
R
const
__m128i
*
const
G
const
__m128i
*
const
B
const
__m128i
*
const
A
uint8_t
*
WEBP_RESTRICT
const
dst
)
{
#
if
(
WEBP_SWAP_16BIT_CSP
=
=
0
)
const
__m128i
rg0
=
_mm_packus_epi16
(
*
R
*
G
)
;
const
__m128i
ba0
=
_mm_packus_epi16
(
*
B
*
A
)
;
#
else
const
__m128i
rg0
=
_mm_packus_epi16
(
*
B
*
A
)
;
const
__m128i
ba0
=
_mm_packus_epi16
(
*
R
*
G
)
;
#
endif
const
__m128i
mask_0xf0
=
_mm_set1_epi8
(
(
char
)
0xf0
)
;
const
__m128i
rb1
=
_mm_unpacklo_epi8
(
rg0
ba0
)
;
const
__m128i
ga1
=
_mm_unpackhi_epi8
(
rg0
ba0
)
;
const
__m128i
rb2
=
_mm_and_si128
(
rb1
mask_0xf0
)
;
const
__m128i
ga2
=
_mm_srli_epi16
(
_mm_and_si128
(
ga1
mask_0xf0
)
4
)
;
const
__m128i
rgba4444
=
_mm_or_si128
(
rb2
ga2
)
;
_mm_storeu_si128
(
(
__m128i
*
)
dst
rgba4444
)
;
}
static
WEBP_INLINE
void
PackAndStore565_SSE2
(
const
__m128i
*
const
R
const
__m128i
*
const
G
const
__m128i
*
const
B
uint8_t
*
WEBP_RESTRICT
const
dst
)
{
const
__m128i
r0
=
_mm_packus_epi16
(
*
R
*
R
)
;
const
__m128i
g0
=
_mm_packus_epi16
(
*
G
*
G
)
;
const
__m128i
b0
=
_mm_packus_epi16
(
*
B
*
B
)
;
const
__m128i
r1
=
_mm_and_si128
(
r0
_mm_set1_epi8
(
(
char
)
0xf8
)
)
;
const
__m128i
b1
=
_mm_and_si128
(
_mm_srli_epi16
(
b0
3
)
_mm_set1_epi8
(
0x1f
)
)
;
const
__m128i
g1
=
_mm_srli_epi16
(
_mm_and_si128
(
g0
_mm_set1_epi8
(
(
char
)
0xe0
)
)
5
)
;
const
__m128i
g2
=
_mm_slli_epi16
(
_mm_and_si128
(
g0
_mm_set1_epi8
(
0x1c
)
)
3
)
;
const
__m128i
rg
=
_mm_or_si128
(
r1
g1
)
;
const
__m128i
gb
=
_mm_or_si128
(
g2
b1
)
;
#
if
(
WEBP_SWAP_16BIT_CSP
=
=
0
)
const
__m128i
rgb565
=
_mm_unpacklo_epi8
(
rg
gb
)
;
#
else
const
__m128i
rgb565
=
_mm_unpacklo_epi8
(
gb
rg
)
;
#
endif
_mm_storeu_si128
(
(
__m128i
*
)
dst
rgb565
)
;
}
static
WEBP_INLINE
void
PlanarTo24b_SSE2
(
__m128i
*
const
in0
__m128i
*
const
in1
__m128i
*
const
in2
__m128i
*
const
in3
__m128i
*
const
in4
__m128i
*
const
in5
uint8_t
*
WEBP_RESTRICT
const
rgb
)
{
VP8PlanarTo24b_SSE2
(
in0
in1
in2
in3
in4
in5
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
rgb
+
0
)
*
in0
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
rgb
+
16
)
*
in1
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
rgb
+
32
)
*
in2
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
rgb
+
48
)
*
in3
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
rgb
+
64
)
*
in4
)
;
_mm_storeu_si128
(
(
__m128i
*
)
(
rgb
+
80
)
*
in5
)
;
}
void
VP8YuvToRgba32_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
)
{
const
__m128i
kAlpha
=
_mm_set1_epi16
(
255
)
;
int
n
;
for
(
n
=
0
;
n
<
32
;
n
+
=
8
dst
+
=
32
)
{
__m128i
R
G
B
;
YUV444ToRGB_SSE2
(
y
+
n
u
+
n
v
+
n
&
R
&
G
&
B
)
;
PackAndStore4_SSE2
(
&
R
&
G
&
B
&
kAlpha
dst
)
;
}
}
void
VP8YuvToBgra32_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
)
{
const
__m128i
kAlpha
=
_mm_set1_epi16
(
255
)
;
int
n
;
for
(
n
=
0
;
n
<
32
;
n
+
=
8
dst
+
=
32
)
{
__m128i
R
G
B
;
YUV444ToRGB_SSE2
(
y
+
n
u
+
n
v
+
n
&
R
&
G
&
B
)
;
PackAndStore4_SSE2
(
&
B
&
G
&
R
&
kAlpha
dst
)
;
}
}
void
VP8YuvToArgb32_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
)
{
const
__m128i
kAlpha
=
_mm_set1_epi16
(
255
)
;
int
n
;
for
(
n
=
0
;
n
<
32
;
n
+
=
8
dst
+
=
32
)
{
__m128i
R
G
B
;
YUV444ToRGB_SSE2
(
y
+
n
u
+
n
v
+
n
&
R
&
G
&
B
)
;
PackAndStore4_SSE2
(
&
kAlpha
&
R
&
G
&
B
dst
)
;
}
}
void
VP8YuvToRgba444432_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
)
{
const
__m128i
kAlpha
=
_mm_set1_epi16
(
255
)
;
int
n
;
for
(
n
=
0
;
n
<
32
;
n
+
=
8
dst
+
=
16
)
{
__m128i
R
G
B
;
YUV444ToRGB_SSE2
(
y
+
n
u
+
n
v
+
n
&
R
&
G
&
B
)
;
PackAndStore4444_SSE2
(
&
R
&
G
&
B
&
kAlpha
dst
)
;
}
}
void
VP8YuvToRgb56532_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
)
{
int
n
;
for
(
n
=
0
;
n
<
32
;
n
+
=
8
dst
+
=
16
)
{
__m128i
R
G
B
;
YUV444ToRGB_SSE2
(
y
+
n
u
+
n
v
+
n
&
R
&
G
&
B
)
;
PackAndStore565_SSE2
(
&
R
&
G
&
B
dst
)
;
}
}
void
VP8YuvToRgb32_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
)
{
__m128i
R0
R1
R2
R3
G0
G1
G2
G3
B0
B1
B2
B3
;
__m128i
rgb0
rgb1
rgb2
rgb3
rgb4
rgb5
;
YUV444ToRGB_SSE2
(
y
+
0
u
+
0
v
+
0
&
R0
&
G0
&
B0
)
;
YUV444ToRGB_SSE2
(
y
+
8
u
+
8
v
+
8
&
R1
&
G1
&
B1
)
;
YUV444ToRGB_SSE2
(
y
+
16
u
+
16
v
+
16
&
R2
&
G2
&
B2
)
;
YUV444ToRGB_SSE2
(
y
+
24
u
+
24
v
+
24
&
R3
&
G3
&
B3
)
;
rgb0
=
_mm_packus_epi16
(
R0
R1
)
;
rgb1
=
_mm_packus_epi16
(
R2
R3
)
;
rgb2
=
_mm_packus_epi16
(
G0
G1
)
;
rgb3
=
_mm_packus_epi16
(
G2
G3
)
;
rgb4
=
_mm_packus_epi16
(
B0
B1
)
;
rgb5
=
_mm_packus_epi16
(
B2
B3
)
;
PlanarTo24b_SSE2
(
&
rgb0
&
rgb1
&
rgb2
&
rgb3
&
rgb4
&
rgb5
dst
)
;
}
void
VP8YuvToBgr32_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
)
{
__m128i
R0
R1
R2
R3
G0
G1
G2
G3
B0
B1
B2
B3
;
__m128i
bgr0
bgr1
bgr2
bgr3
bgr4
bgr5
;
YUV444ToRGB_SSE2
(
y
+
0
u
+
0
v
+
0
&
R0
&
G0
&
B0
)
;
YUV444ToRGB_SSE2
(
y
+
8
u
+
8
v
+
8
&
R1
&
G1
&
B1
)
;
YUV444ToRGB_SSE2
(
y
+
16
u
+
16
v
+
16
&
R2
&
G2
&
B2
)
;
YUV444ToRGB_SSE2
(
y
+
24
u
+
24
v
+
24
&
R3
&
G3
&
B3
)
;
bgr0
=
_mm_packus_epi16
(
B0
B1
)
;
bgr1
=
_mm_packus_epi16
(
B2
B3
)
;
bgr2
=
_mm_packus_epi16
(
G0
G1
)
;
bgr3
=
_mm_packus_epi16
(
G2
G3
)
;
bgr4
=
_mm_packus_epi16
(
R0
R1
)
;
bgr5
=
_mm_packus_epi16
(
R2
R3
)
;
PlanarTo24b_SSE2
(
&
bgr0
&
bgr1
&
bgr2
&
bgr3
&
bgr4
&
bgr5
dst
)
;
}
static
void
YuvToRgbaRow_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
int
len
)
{
const
__m128i
kAlpha
=
_mm_set1_epi16
(
255
)
;
int
n
;
for
(
n
=
0
;
n
+
8
<
=
len
;
n
+
=
8
dst
+
=
32
)
{
__m128i
R
G
B
;
YUV420ToRGB_SSE2
(
y
u
v
&
R
&
G
&
B
)
;
PackAndStore4_SSE2
(
&
R
&
G
&
B
&
kAlpha
dst
)
;
y
+
=
8
;
u
+
=
4
;
v
+
=
4
;
}
for
(
;
n
<
len
;
+
+
n
)
{
VP8YuvToRgba
(
y
[
0
]
u
[
0
]
v
[
0
]
dst
)
;
dst
+
=
4
;
y
+
=
1
;
u
+
=
(
n
&
1
)
;
v
+
=
(
n
&
1
)
;
}
}
static
void
YuvToBgraRow_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
int
len
)
{
const
__m128i
kAlpha
=
_mm_set1_epi16
(
255
)
;
int
n
;
for
(
n
=
0
;
n
+
8
<
=
len
;
n
+
=
8
dst
+
=
32
)
{
__m128i
R
G
B
;
YUV420ToRGB_SSE2
(
y
u
v
&
R
&
G
&
B
)
;
PackAndStore4_SSE2
(
&
B
&
G
&
R
&
kAlpha
dst
)
;
y
+
=
8
;
u
+
=
4
;
v
+
=
4
;
}
for
(
;
n
<
len
;
+
+
n
)
{
VP8YuvToBgra
(
y
[
0
]
u
[
0
]
v
[
0
]
dst
)
;
dst
+
=
4
;
y
+
=
1
;
u
+
=
(
n
&
1
)
;
v
+
=
(
n
&
1
)
;
}
}
static
void
YuvToArgbRow_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
int
len
)
{
const
__m128i
kAlpha
=
_mm_set1_epi16
(
255
)
;
int
n
;
for
(
n
=
0
;
n
+
8
<
=
len
;
n
+
=
8
dst
+
=
32
)
{
__m128i
R
G
B
;
YUV420ToRGB_SSE2
(
y
u
v
&
R
&
G
&
B
)
;
PackAndStore4_SSE2
(
&
kAlpha
&
R
&
G
&
B
dst
)
;
y
+
=
8
;
u
+
=
4
;
v
+
=
4
;
}
for
(
;
n
<
len
;
+
+
n
)
{
VP8YuvToArgb
(
y
[
0
]
u
[
0
]
v
[
0
]
dst
)
;
dst
+
=
4
;
y
+
=
1
;
u
+
=
(
n
&
1
)
;
v
+
=
(
n
&
1
)
;
}
}
static
void
YuvToRgbRow_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
int
len
)
{
int
n
;
for
(
n
=
0
;
n
+
32
<
=
len
;
n
+
=
32
dst
+
=
32
*
3
)
{
__m128i
R0
R1
R2
R3
G0
G1
G2
G3
B0
B1
B2
B3
;
__m128i
rgb0
rgb1
rgb2
rgb3
rgb4
rgb5
;
YUV420ToRGB_SSE2
(
y
+
0
u
+
0
v
+
0
&
R0
&
G0
&
B0
)
;
YUV420ToRGB_SSE2
(
y
+
8
u
+
4
v
+
4
&
R1
&
G1
&
B1
)
;
YUV420ToRGB_SSE2
(
y
+
16
u
+
8
v
+
8
&
R2
&
G2
&
B2
)
;
YUV420ToRGB_SSE2
(
y
+
24
u
+
12
v
+
12
&
R3
&
G3
&
B3
)
;
rgb0
=
_mm_packus_epi16
(
R0
R1
)
;
rgb1
=
_mm_packus_epi16
(
R2
R3
)
;
rgb2
=
_mm_packus_epi16
(
G0
G1
)
;
rgb3
=
_mm_packus_epi16
(
G2
G3
)
;
rgb4
=
_mm_packus_epi16
(
B0
B1
)
;
rgb5
=
_mm_packus_epi16
(
B2
B3
)
;
PlanarTo24b_SSE2
(
&
rgb0
&
rgb1
&
rgb2
&
rgb3
&
rgb4
&
rgb5
dst
)
;
y
+
=
32
;
u
+
=
16
;
v
+
=
16
;
}
for
(
;
n
<
len
;
+
+
n
)
{
VP8YuvToRgb
(
y
[
0
]
u
[
0
]
v
[
0
]
dst
)
;
dst
+
=
3
;
y
+
=
1
;
u
+
=
(
n
&
1
)
;
v
+
=
(
n
&
1
)
;
}
}
static
void
YuvToBgrRow_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
y
const
uint8_t
*
WEBP_RESTRICT
u
const
uint8_t
*
WEBP_RESTRICT
v
uint8_t
*
WEBP_RESTRICT
dst
int
len
)
{
int
n
;
for
(
n
=
0
;
n
+
32
<
=
len
;
n
+
=
32
dst
+
=
32
*
3
)
{
__m128i
R0
R1
R2
R3
G0
G1
G2
G3
B0
B1
B2
B3
;
__m128i
bgr0
bgr1
bgr2
bgr3
bgr4
bgr5
;
YUV420ToRGB_SSE2
(
y
+
0
u
+
0
v
+
0
&
R0
&
G0
&
B0
)
;
YUV420ToRGB_SSE2
(
y
+
8
u
+
4
v
+
4
&
R1
&
G1
&
B1
)
;
YUV420ToRGB_SSE2
(
y
+
16
u
+
8
v
+
8
&
R2
&
G2
&
B2
)
;
YUV420ToRGB_SSE2
(
y
+
24
u
+
12
v
+
12
&
R3
&
G3
&
B3
)
;
bgr0
=
_mm_packus_epi16
(
B0
B1
)
;
bgr1
=
_mm_packus_epi16
(
B2
B3
)
;
bgr2
=
_mm_packus_epi16
(
G0
G1
)
;
bgr3
=
_mm_packus_epi16
(
G2
G3
)
;
bgr4
=
_mm_packus_epi16
(
R0
R1
)
;
bgr5
=
_mm_packus_epi16
(
R2
R3
)
;
PlanarTo24b_SSE2
(
&
bgr0
&
bgr1
&
bgr2
&
bgr3
&
bgr4
&
bgr5
dst
)
;
y
+
=
32
;
u
+
=
16
;
v
+
=
16
;
}
for
(
;
n
<
len
;
+
+
n
)
{
VP8YuvToBgr
(
y
[
0
]
u
[
0
]
v
[
0
]
dst
)
;
dst
+
=
3
;
y
+
=
1
;
u
+
=
(
n
&
1
)
;
v
+
=
(
n
&
1
)
;
}
}
extern
void
WebPInitSamplersSSE2
(
void
)
;
WEBP_TSAN_IGNORE_FUNCTION
void
WebPInitSamplersSSE2
(
void
)
{
WebPSamplers
[
MODE_RGB
]
=
YuvToRgbRow_SSE2
;
WebPSamplers
[
MODE_RGBA
]
=
YuvToRgbaRow_SSE2
;
WebPSamplers
[
MODE_BGR
]
=
YuvToBgrRow_SSE2
;
WebPSamplers
[
MODE_BGRA
]
=
YuvToBgraRow_SSE2
;
WebPSamplers
[
MODE_ARGB
]
=
YuvToArgbRow_SSE2
;
}
#
define
LOAD_16
(
src
)
_mm_loadu_si128
(
(
const
__m128i
*
)
(
src
)
)
#
define
STORE_16
(
V
dst
)
_mm_storeu_si128
(
(
__m128i
*
)
(
dst
)
(
V
)
)
static
WEBP_INLINE
void
RGB24PackedToPlanarHelper_SSE2
(
const
__m128i
*
const
in
__m128i
*
const
out
)
{
out
[
0
]
=
_mm_unpacklo_epi8
(
in
[
0
]
in
[
3
]
)
;
out
[
1
]
=
_mm_unpackhi_epi8
(
in
[
0
]
in
[
3
]
)
;
out
[
2
]
=
_mm_unpacklo_epi8
(
in
[
1
]
in
[
4
]
)
;
out
[
3
]
=
_mm_unpackhi_epi8
(
in
[
1
]
in
[
4
]
)
;
out
[
4
]
=
_mm_unpacklo_epi8
(
in
[
2
]
in
[
5
]
)
;
out
[
5
]
=
_mm_unpackhi_epi8
(
in
[
2
]
in
[
5
]
)
;
}
static
WEBP_INLINE
void
RGB24PackedToPlanar_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
const
rgb
__m128i
*
const
out
)
{
__m128i
tmp
[
6
]
;
tmp
[
0
]
=
_mm_loadu_si128
(
(
const
__m128i
*
)
(
rgb
+
0
)
)
;
tmp
[
1
]
=
_mm_loadu_si128
(
(
const
__m128i
*
)
(
rgb
+
16
)
)
;
tmp
[
2
]
=
_mm_loadu_si128
(
(
const
__m128i
*
)
(
rgb
+
32
)
)
;
tmp
[
3
]
=
_mm_loadu_si128
(
(
const
__m128i
*
)
(
rgb
+
48
)
)
;
tmp
[
4
]
=
_mm_loadu_si128
(
(
const
__m128i
*
)
(
rgb
+
64
)
)
;
tmp
[
5
]
=
_mm_loadu_si128
(
(
const
__m128i
*
)
(
rgb
+
80
)
)
;
RGB24PackedToPlanarHelper_SSE2
(
tmp
out
)
;
RGB24PackedToPlanarHelper_SSE2
(
out
tmp
)
;
RGB24PackedToPlanarHelper_SSE2
(
tmp
out
)
;
RGB24PackedToPlanarHelper_SSE2
(
out
tmp
)
;
RGB24PackedToPlanarHelper_SSE2
(
tmp
out
)
;
}
static
WEBP_INLINE
void
RGB32PackedToPlanar_SSE2
(
const
uint32_t
*
WEBP_RESTRICT
const
argb
__m128i
*
const
rgb
)
{
const
__m128i
zero
=
_mm_setzero_si128
(
)
;
__m128i
a0
=
LOAD_16
(
argb
+
0
)
;
__m128i
a1
=
LOAD_16
(
argb
+
4
)
;
__m128i
a2
=
LOAD_16
(
argb
+
8
)
;
__m128i
a3
=
LOAD_16
(
argb
+
12
)
;
VP8L32bToPlanar_SSE2
(
&
a0
&
a1
&
a2
&
a3
)
;
rgb
[
0
]
=
_mm_unpacklo_epi8
(
a1
zero
)
;
rgb
[
1
]
=
_mm_unpackhi_epi8
(
a1
zero
)
;
rgb
[
2
]
=
_mm_unpacklo_epi8
(
a2
zero
)
;
rgb
[
3
]
=
_mm_unpackhi_epi8
(
a2
zero
)
;
rgb
[
4
]
=
_mm_unpacklo_epi8
(
a3
zero
)
;
rgb
[
5
]
=
_mm_unpackhi_epi8
(
a3
zero
)
;
}
#
define
TRANSFORM
(
RG_LO
RG_HI
GB_LO
GB_HI
MULT_RG
MULT_GB
\
ROUNDER
DESCALE_FIX
OUT
)
do
{
\
const
__m128i
V0_lo
=
_mm_madd_epi16
(
RG_LO
MULT_RG
)
;
\
const
__m128i
V0_hi
=
_mm_madd_epi16
(
RG_HI
MULT_RG
)
;
\
const
__m128i
V1_lo
=
_mm_madd_epi16
(
GB_LO
MULT_GB
)
;
\
const
__m128i
V1_hi
=
_mm_madd_epi16
(
GB_HI
MULT_GB
)
;
\
const
__m128i
V2_lo
=
_mm_add_epi32
(
V0_lo
V1_lo
)
;
\
const
__m128i
V2_hi
=
_mm_add_epi32
(
V0_hi
V1_hi
)
;
\
const
__m128i
V3_lo
=
_mm_add_epi32
(
V2_lo
ROUNDER
)
;
\
const
__m128i
V3_hi
=
_mm_add_epi32
(
V2_hi
ROUNDER
)
;
\
const
__m128i
V5_lo
=
_mm_srai_epi32
(
V3_lo
DESCALE_FIX
)
;
\
const
__m128i
V5_hi
=
_mm_srai_epi32
(
V3_hi
DESCALE_FIX
)
;
\
(
OUT
)
=
_mm_packs_epi32
(
V5_lo
V5_hi
)
;
\
}
while
(
0
)
#
define
MK_CST_16
(
A
B
)
_mm_set_epi16
(
(
B
)
(
A
)
(
B
)
(
A
)
(
B
)
(
A
)
(
B
)
(
A
)
)
static
WEBP_INLINE
void
ConvertRGBToY_SSE2
(
const
__m128i
*
const
R
const
__m128i
*
const
G
const
__m128i
*
const
B
__m128i
*
const
Y
)
{
const
__m128i
kRG_y
=
MK_CST_16
(
16839
33059
-
16384
)
;
const
__m128i
kGB_y
=
MK_CST_16
(
16384
6420
)
;
const
__m128i
kHALF_Y
=
_mm_set1_epi32
(
(
16
<
<
YUV_FIX
)
+
YUV_HALF
)
;
const
__m128i
RG_lo
=
_mm_unpacklo_epi16
(
*
R
*
G
)
;
const
__m128i
RG_hi
=
_mm_unpackhi_epi16
(
*
R
*
G
)
;
const
__m128i
GB_lo
=
_mm_unpacklo_epi16
(
*
G
*
B
)
;
const
__m128i
GB_hi
=
_mm_unpackhi_epi16
(
*
G
*
B
)
;
TRANSFORM
(
RG_lo
RG_hi
GB_lo
GB_hi
kRG_y
kGB_y
kHALF_Y
YUV_FIX
*
Y
)
;
}
static
WEBP_INLINE
void
ConvertRGBToUV_SSE2
(
const
__m128i
*
const
R
const
__m128i
*
const
G
const
__m128i
*
const
B
__m128i
*
const
U
__m128i
*
const
V
)
{
const
__m128i
kRG_u
=
MK_CST_16
(
-
9719
-
19081
)
;
const
__m128i
kGB_u
=
MK_CST_16
(
0
28800
)
;
const
__m128i
kRG_v
=
MK_CST_16
(
28800
0
)
;
const
__m128i
kGB_v
=
MK_CST_16
(
-
24116
-
4684
)
;
const
__m128i
kHALF_UV
=
_mm_set1_epi32
(
(
(
128
<
<
YUV_FIX
)
+
YUV_HALF
)
<
<
2
)
;
const
__m128i
RG_lo
=
_mm_unpacklo_epi16
(
*
R
*
G
)
;
const
__m128i
RG_hi
=
_mm_unpackhi_epi16
(
*
R
*
G
)
;
const
__m128i
GB_lo
=
_mm_unpacklo_epi16
(
*
G
*
B
)
;
const
__m128i
GB_hi
=
_mm_unpackhi_epi16
(
*
G
*
B
)
;
TRANSFORM
(
RG_lo
RG_hi
GB_lo
GB_hi
kRG_u
kGB_u
kHALF_UV
YUV_FIX
+
2
*
U
)
;
TRANSFORM
(
RG_lo
RG_hi
GB_lo
GB_hi
kRG_v
kGB_v
kHALF_UV
YUV_FIX
+
2
*
V
)
;
}
#
undef
MK_CST_16
#
undef
TRANSFORM
static
void
ConvertRGB24ToY_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
rgb
uint8_t
*
WEBP_RESTRICT
y
int
width
)
{
const
int
max_width
=
width
&
~
31
;
int
i
;
for
(
i
=
0
;
i
<
max_width
;
rgb
+
=
3
*
16
*
2
)
{
__m128i
rgb_plane
[
6
]
;
int
j
;
RGB24PackedToPlanar_SSE2
(
rgb
rgb_plane
)
;
for
(
j
=
0
;
j
<
2
;
+
+
j
i
+
=
16
)
{
const
__m128i
zero
=
_mm_setzero_si128
(
)
;
__m128i
r
g
b
Y0
Y1
;
r
=
_mm_unpacklo_epi8
(
rgb_plane
[
0
+
j
]
zero
)
;
g
=
_mm_unpacklo_epi8
(
rgb_plane
[
2
+
j
]
zero
)
;
b
=
_mm_unpacklo_epi8
(
rgb_plane
[
4
+
j
]
zero
)
;
ConvertRGBToY_SSE2
(
&
r
&
g
&
b
&
Y0
)
;
r
=
_mm_unpackhi_epi8
(
rgb_plane
[
0
+
j
]
zero
)
;
g
=
_mm_unpackhi_epi8
(
rgb_plane
[
2
+
j
]
zero
)
;
b
=
_mm_unpackhi_epi8
(
rgb_plane
[
4
+
j
]
zero
)
;
ConvertRGBToY_SSE2
(
&
r
&
g
&
b
&
Y1
)
;
STORE_16
(
_mm_packus_epi16
(
Y0
Y1
)
y
+
i
)
;
}
}
for
(
;
i
<
width
;
+
+
i
rgb
+
=
3
)
{
y
[
i
]
=
VP8RGBToY
(
rgb
[
0
]
rgb
[
1
]
rgb
[
2
]
YUV_HALF
)
;
}
}
static
void
ConvertBGR24ToY_SSE2
(
const
uint8_t
*
WEBP_RESTRICT
bgr
uint8_t
*
WEBP_RESTRICT
y
int
width
)
{
const
int
max_width
=
width
&
~
31
;
int
i
;
for
(
i
=
0
;
i
<
max_width
;
bgr
+
=
3
*
16
*
2
)
{
__m128i
bgr_plane
[
6
]
;
int
j
;
RGB24PackedToPlanar_SSE2
(
bgr
bgr_plane
)
;
for
(
j
=
0
;
j
<
2
;
+
+
j
i
+
=
16
)
{
const
__m128i
zero
=
_mm_setzero_si128
(
)
;
__m128i
r
g
b
Y0
Y1
;
b
=
_mm_unpacklo_epi8
(
bgr_plane
[
0
+
j
]
zero
)
;
g
=
_mm_unpacklo_epi8
(
bgr_plane
[
2
+
j
]
zero
)
;
r
=
_mm_unpacklo_epi8
(
bgr_plane
[
4
+
j
]
zero
)
;
ConvertRGBToY_SSE2
(
&
r
&
g
&
b
&
Y0
)
;
b
=
_mm_unpackhi_epi8
(
bgr_plane
[
0
+
j
]
zero
)
;
g
=
_mm_unpackhi_epi8
(
bgr_plane
[
2
+
j
]
zero
)
;
r
=
_mm_unpackhi_epi8
(
bgr_plane
[
4
+
j
]
zero
)
;
ConvertRGBToY_SSE2
(
&
r
&
g
&
b
&
Y1
)
;
STORE_16
(
_mm_packus_epi16
(
Y0
Y1
)
y
+
i
)
;
}
}
for
(
;
i
<
width
;
+
+
i
bgr
+
=
3
)
{
y
[
i
]
=
VP8RGBToY
(
bgr
[
2
]
bgr
[
1
]
bgr
[
0
]
YUV_HALF
)
;
}
}
static
void
ConvertARGBToY_SSE2
(
const
uint32_t
*
WEBP_RESTRICT
argb
uint8_t
*
WEBP_RESTRICT
y
int
width
)
{
const
int
max_width
=
width
&
~
15
;
int
i
;
for
(
i
=
0
;
i
<
max_width
;
i
+
=
16
)
{
__m128i
Y0
Y1
rgb
[
6
]
;
RGB32PackedToPlanar_SSE2
(
&
argb
[
i
]
rgb
)
;
ConvertRGBToY_SSE2
(
&
rgb
[
0
]
&
rgb
[
2
]
&
rgb
[
4
]
&
Y0
)
;
ConvertRGBToY_SSE2
(
&
rgb
[
1
]
&
rgb
[
3
]
&
rgb
[
5
]
&
Y1
)
;
STORE_16
(
_mm_packus_epi16
(
Y0
Y1
)
y
+
i
)
;
}
for
(
;
i
<
width
;
+
+
i
)
{
const
uint32_t
p
=
argb
[
i
]
;
y
[
i
]
=
VP8RGBToY
(
(
p
>
>
16
)
&
0xff
(
p
>
>
8
)
&
0xff
(
p
>
>
0
)
&
0xff
YUV_HALF
)
;
}
}
static
void
HorizontalAddPack_SSE2
(
const
__m128i
*
const
A
const
__m128i
*
const
B
__m128i
*
const
out
)
{
const
__m128i
k2
=
_mm_set1_epi16
(
2
)
;
const
__m128i
C
=
_mm_madd_epi16
(
*
A
k2
)
;
const
__m128i
D
=
_mm_madd_epi16
(
*
B
k2
)
;
*
out
=
_mm_packs_epi32
(
C
D
)
;
}
static
void
ConvertARGBToUV_SSE2
(
const
uint32_t
*
WEBP_RESTRICT
argb
uint8_t
*
WEBP_RESTRICT
u
uint8_t
*
WEBP_RESTRICT
v
int
src_width
int
do_store
)
{
const
int
max_width
=
src_width
&
~
31
;
int
i
;
for
(
i
=
0
;
i
<
max_width
;
i
+
=
32
u
+
=
16
v
+
=
16
)
{
__m128i
rgb
[
6
]
U0
V0
U1
V1
;
RGB32PackedToPlanar_SSE2
(
&
argb
[
i
]
rgb
)
;
HorizontalAddPack_SSE2
(
&
rgb
[
0
]
&
rgb
[
1
]
&
rgb
[
0
]
)
;
HorizontalAddPack_SSE2
(
&
rgb
[
2
]
&
rgb
[
3
]
&
rgb
[
2
]
)
;
HorizontalAddPack_SSE2
(
&
rgb
[
4
]
&
rgb
[
5
]
&
rgb
[
4
]
)
;
ConvertRGBToUV_SSE2
(
&
rgb
[
0
]
&
rgb
[
2
]
&
rgb
[
4
]
&
U0
&
V0
)
;
RGB32PackedToPlanar_SSE2
(
&
argb
[
i
+
16
]
rgb
)
;
HorizontalAddPack_SSE2
(
&
rgb
[
0
]
&
rgb
[
1
]
&
rgb
[
0
]
)
;
HorizontalAddPack_SSE2
(
&
rgb
[
2
]
&
rgb
[
3
]
&
rgb
[
2
]
)
;
HorizontalAddPack_SSE2
(
&
rgb
[
4
]
&
rgb
[
5
]
&
rgb
[
4
]
)
;
ConvertRGBToUV_SSE2
(
&
rgb
[
0
]
&
rgb
[
2
]
&
rgb
[
4
]
&
U1
&
V1
)
;
U0
=
_mm_packus_epi16
(
U0
U1
)
;
V0
=
_mm_packus_epi16
(
V0
V1
)
;
if
(
!
do_store
)
{
const
__m128i
prev_u
=
LOAD_16
(
u
)
;
const
__m128i
prev_v
=
LOAD_16
(
v
)
;
U0
=
_mm_avg_epu8
(
U0
prev_u
)
;
V0
=
_mm_avg_epu8
(
V0
prev_v
)
;
}
STORE_16
(
U0
u
)
;
STORE_16
(
V0
v
)
;
}
if
(
i
<
src_width
)
{
WebPConvertARGBToUV_C
(
argb
+
i
u
v
src_width
-
i
do_store
)
;
}
}
static
WEBP_INLINE
void
RGBA32PackedToPlanar_16b_SSE2
(
const
uint16_t
*
WEBP_RESTRICT
const
rgbx
__m128i
*
const
r
__m128i
*
const
g
__m128i
*
const
b
)
{
const
__m128i
in0
=
LOAD_16
(
rgbx
+
0
)
;
const
__m128i
in1
=
LOAD_16
(
rgbx
+
8
)
;
const
__m128i
in2
=
LOAD_16
(
rgbx
+
16
)
;
const
__m128i
in3
=
LOAD_16
(
rgbx
+
24
)
;
const
__m128i
A0
=
_mm_unpacklo_epi16
(
in0
in1
)
;
const
__m128i
A1
=
_mm_unpackhi_epi16
(
in0
in1
)
;
const
__m128i
A2
=
_mm_unpacklo_epi16
(
in2
in3
)
;
const
__m128i
A3
=
_mm_unpackhi_epi16
(
in2
in3
)
;
const
__m128i
B0
=
_mm_unpacklo_epi16
(
A0
A1
)
;
const
__m128i
B1
=
_mm_unpackhi_epi16
(
A0
A1
)
;
const
__m128i
B2
=
_mm_unpacklo_epi16
(
A2
A3
)
;
const
__m128i
B3
=
_mm_unpackhi_epi16
(
A2
A3
)
;
*
r
=
_mm_unpacklo_epi64
(
B0
B2
)
;
*
g
=
_mm_unpackhi_epi64
(
B0
B2
)
;
*
b
=
_mm_unpacklo_epi64
(
B1
B3
)
;
}
static
void
ConvertRGBA32ToUV_SSE2
(
const
uint16_t
*
WEBP_RESTRICT
rgb
uint8_t
*
WEBP_RESTRICT
u
uint8_t
*
WEBP_RESTRICT
v
int
width
)
{
const
int
max_width
=
width
&
~
15
;
const
uint16_t
*
const
last_rgb
=
rgb
+
4
*
max_width
;
while
(
rgb
<
last_rgb
)
{
__m128i
r
g
b
U0
V0
U1
V1
;
RGBA32PackedToPlanar_16b_SSE2
(
rgb
+
0
&
r
&
g
&
b
)
;
ConvertRGBToUV_SSE2
(
&
r
&
g
&
b
&
U0
&
V0
)
;
RGBA32PackedToPlanar_16b_SSE2
(
rgb
+
32
&
r
&
g
&
b
)
;
ConvertRGBToUV_SSE2
(
&
r
&
g
&
b
&
U1
&
V1
)
;
STORE_16
(
_mm_packus_epi16
(
U0
U1
)
u
)
;
STORE_16
(
_mm_packus_epi16
(
V0
V1
)
v
)
;
u
+
=
16
;
v
+
=
16
;
rgb
+
=
2
*
32
;
}
if
(
max_width
<
width
)
{
WebPConvertRGBA32ToUV_C
(
rgb
u
v
width
-
max_width
)
;
}
}
extern
void
WebPInitConvertARGBToYUVSSE2
(
void
)
;
WEBP_TSAN_IGNORE_FUNCTION
void
WebPInitConvertARGBToYUVSSE2
(
void
)
{
WebPConvertARGBToY
=
ConvertARGBToY_SSE2
;
WebPConvertARGBToUV
=
ConvertARGBToUV_SSE2
;
WebPConvertRGB24ToY
=
ConvertRGB24ToY_SSE2
;
WebPConvertBGR24ToY
=
ConvertBGR24ToY_SSE2
;
WebPConvertRGBA32ToUV
=
ConvertRGBA32ToUV_SSE2
;
}
#
else
WEBP_DSP_INIT_STUB
(
WebPInitSamplersSSE2
)
WEBP_DSP_INIT_STUB
(
WebPInitConvertARGBToYUVSSE2
)
#
endif
