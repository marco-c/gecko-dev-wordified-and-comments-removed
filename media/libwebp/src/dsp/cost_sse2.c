#
include
"
src
/
dsp
/
dsp
.
h
"
#
if
defined
(
WEBP_USE_SSE2
)
#
include
<
emmintrin
.
h
>
#
include
"
src
/
enc
/
cost_enc
.
h
"
#
include
"
src
/
enc
/
vp8i_enc
.
h
"
#
include
"
src
/
utils
/
utils
.
h
"
static
void
SetResidualCoeffs_SSE2
(
const
int16_t
*
const
coeffs
VP8Residual
*
const
res
)
{
const
__m128i
c0
=
_mm_loadu_si128
(
(
const
__m128i
*
)
(
coeffs
+
0
)
)
;
const
__m128i
c1
=
_mm_loadu_si128
(
(
const
__m128i
*
)
(
coeffs
+
8
)
)
;
const
__m128i
zero
=
_mm_setzero_si128
(
)
;
const
__m128i
m0
=
_mm_packs_epi16
(
c0
c1
)
;
const
__m128i
m1
=
_mm_cmpeq_epi8
(
m0
zero
)
;
const
uint32_t
mask
=
0x0000ffffu
^
(
uint32_t
)
_mm_movemask_epi8
(
m1
)
;
assert
(
res
-
>
first
=
=
0
|
|
coeffs
[
0
]
=
=
0
)
;
res
-
>
last
=
mask
?
BitsLog2Floor
(
mask
)
:
-
1
;
res
-
>
coeffs
=
coeffs
;
}
static
int
GetResidualCost_SSE2
(
int
ctx0
const
VP8Residual
*
const
res
)
{
uint8_t
levels
[
16
]
ctxs
[
16
]
;
uint16_t
abs_levels
[
16
]
;
int
n
=
res
-
>
first
;
const
int
p0
=
res
-
>
prob
[
n
]
[
ctx0
]
[
0
]
;
CostArrayPtr
const
costs
=
res
-
>
costs
;
const
uint16_t
*
t
=
costs
[
n
]
[
ctx0
]
;
int
cost
=
(
ctx0
=
=
0
)
?
VP8BitCost
(
1
p0
)
:
0
;
if
(
res
-
>
last
<
0
)
{
return
VP8BitCost
(
0
p0
)
;
}
{
const
__m128i
zero
=
_mm_setzero_si128
(
)
;
const
__m128i
kCst2
=
_mm_set1_epi8
(
2
)
;
const
__m128i
kCst67
=
_mm_set1_epi8
(
MAX_VARIABLE_LEVEL
)
;
const
__m128i
c0
=
_mm_loadu_si128
(
(
const
__m128i
*
)
&
res
-
>
coeffs
[
0
]
)
;
const
__m128i
c1
=
_mm_loadu_si128
(
(
const
__m128i
*
)
&
res
-
>
coeffs
[
8
]
)
;
const
__m128i
D0
=
_mm_sub_epi16
(
zero
c0
)
;
const
__m128i
D1
=
_mm_sub_epi16
(
zero
c1
)
;
const
__m128i
E0
=
_mm_max_epi16
(
c0
D0
)
;
const
__m128i
E1
=
_mm_max_epi16
(
c1
D1
)
;
const
__m128i
F
=
_mm_packs_epi16
(
E0
E1
)
;
const
__m128i
G
=
_mm_min_epu8
(
F
kCst2
)
;
const
__m128i
H
=
_mm_min_epu8
(
F
kCst67
)
;
_mm_storeu_si128
(
(
__m128i
*
)
&
ctxs
[
0
]
G
)
;
_mm_storeu_si128
(
(
__m128i
*
)
&
levels
[
0
]
H
)
;
_mm_storeu_si128
(
(
__m128i
*
)
&
abs_levels
[
0
]
E0
)
;
_mm_storeu_si128
(
(
__m128i
*
)
&
abs_levels
[
8
]
E1
)
;
}
for
(
;
n
<
res
-
>
last
;
+
+
n
)
{
const
int
ctx
=
ctxs
[
n
]
;
const
int
level
=
levels
[
n
]
;
const
int
flevel
=
abs_levels
[
n
]
;
cost
+
=
VP8LevelFixedCosts
[
flevel
]
+
t
[
level
]
;
t
=
costs
[
n
+
1
]
[
ctx
]
;
}
{
const
int
level
=
levels
[
n
]
;
const
int
flevel
=
abs_levels
[
n
]
;
assert
(
flevel
!
=
0
)
;
cost
+
=
VP8LevelFixedCosts
[
flevel
]
+
t
[
level
]
;
if
(
n
<
15
)
{
const
int
b
=
VP8EncBands
[
n
+
1
]
;
const
int
ctx
=
ctxs
[
n
]
;
const
int
last_p0
=
res
-
>
prob
[
b
]
[
ctx
]
[
0
]
;
cost
+
=
VP8BitCost
(
0
last_p0
)
;
}
}
return
cost
;
}
extern
void
VP8EncDspCostInitSSE2
(
void
)
;
WEBP_TSAN_IGNORE_FUNCTION
void
VP8EncDspCostInitSSE2
(
void
)
{
VP8SetResidualCoeffs
=
SetResidualCoeffs_SSE2
;
VP8GetResidualCost
=
GetResidualCost_SSE2
;
}
#
else
WEBP_DSP_INIT_STUB
(
VP8EncDspCostInitSSE2
)
#
endif
