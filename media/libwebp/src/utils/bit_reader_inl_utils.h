#
ifndef
WEBP_UTILS_BIT_READER_INL_UTILS_H_
#
define
WEBP_UTILS_BIT_READER_INL_UTILS_H_
#
ifdef
HAVE_CONFIG_H
#
include
"
src
/
webp
/
config
.
h
"
#
endif
#
include
<
assert
.
h
>
#
include
<
string
.
h
>
#
include
"
src
/
dsp
/
cpu
.
h
"
#
include
"
src
/
dsp
/
dsp
.
h
"
#
include
"
src
/
utils
/
bit_reader_utils
.
h
"
#
include
"
src
/
utils
/
endian_inl_utils
.
h
"
#
include
"
src
/
utils
/
utils
.
h
"
#
include
"
src
/
webp
/
types
.
h
"
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
if
(
BITS
>
32
)
typedef
uint64_t
lbit_t
;
#
elif
(
BITS
>
16
)
typedef
uint32_t
lbit_t
;
#
elif
(
BITS
>
8
)
typedef
uint16_t
lbit_t
;
#
else
typedef
uint8_t
lbit_t
;
#
endif
extern
const
uint8_t
kVP8Log2Range
[
128
]
;
extern
const
uint8_t
kVP8NewRange
[
128
]
;
void
VP8LoadFinalBytes
(
VP8BitReader
*
const
br
)
;
static
WEBP_UBSAN_IGNORE_UNDEF
WEBP_INLINE
void
VP8LoadNewBytes
(
VP8BitReader
*
WEBP_RESTRICT
const
br
)
{
assert
(
br
!
=
NULL
&
&
br
-
>
buf
!
=
NULL
)
;
if
(
br
-
>
buf
<
br
-
>
buf_max
)
{
bit_t
bits
;
#
if
defined
(
WEBP_USE_MIPS32
)
lbit_t
in_bits
;
lbit_t
*
p_buf
=
(
lbit_t
*
)
br
-
>
buf
;
__asm__
volatile
(
"
.
set
push
\
n
\
t
"
"
.
set
at
\
n
\
t
"
"
.
set
macro
\
n
\
t
"
"
ulw
%
[
in_bits
]
0
(
%
[
p_buf
]
)
\
n
\
t
"
"
.
set
pop
\
n
\
t
"
:
[
in_bits
]
"
=
r
"
(
in_bits
)
:
[
p_buf
]
"
r
"
(
p_buf
)
:
"
memory
"
"
at
"
)
;
#
else
lbit_t
in_bits
;
memcpy
(
&
in_bits
br
-
>
buf
sizeof
(
in_bits
)
)
;
#
endif
br
-
>
buf
+
=
BITS
>
>
3
;
#
if
!
defined
(
WORDS_BIGENDIAN
)
#
if
(
BITS
>
32
)
bits
=
BSwap64
(
in_bits
)
;
bits
>
>
=
64
-
BITS
;
#
elif
(
BITS
>
=
24
)
bits
=
BSwap32
(
in_bits
)
;
bits
>
>
=
(
32
-
BITS
)
;
#
elif
(
BITS
=
=
16
)
bits
=
BSwap16
(
in_bits
)
;
#
else
bits
=
(
bit_t
)
in_bits
;
#
endif
#
else
bits
=
(
bit_t
)
in_bits
;
if
(
BITS
!
=
8
*
sizeof
(
bit_t
)
)
bits
>
>
=
(
8
*
sizeof
(
bit_t
)
-
BITS
)
;
#
endif
br
-
>
value
=
bits
|
(
br
-
>
value
<
<
BITS
)
;
br
-
>
bits
+
=
BITS
;
}
else
{
VP8LoadFinalBytes
(
br
)
;
}
}
static
WEBP_INLINE
int
VP8GetBit
(
VP8BitReader
*
WEBP_RESTRICT
const
br
int
prob
const
char
label
[
]
)
{
range_t
range
=
br
-
>
range
;
if
(
br
-
>
bits
<
0
)
{
VP8LoadNewBytes
(
br
)
;
}
{
const
int
pos
=
br
-
>
bits
;
const
range_t
split
=
(
range
*
prob
)
>
>
8
;
const
range_t
value
=
(
range_t
)
(
br
-
>
value
>
>
pos
)
;
const
int
bit
=
(
value
>
split
)
;
if
(
bit
)
{
range
-
=
split
;
br
-
>
value
-
=
(
bit_t
)
(
split
+
1
)
<
<
pos
;
}
else
{
range
=
split
+
1
;
}
{
const
int
shift
=
7
^
BitsLog2Floor
(
range
)
;
range
<
<
=
shift
;
br
-
>
bits
-
=
shift
;
}
br
-
>
range
=
range
-
1
;
BT_TRACK
(
br
)
;
return
bit
;
}
}
static
WEBP_UBSAN_IGNORE_UNSIGNED_OVERFLOW
WEBP_INLINE
int
VP8GetSigned
(
VP8BitReader
*
WEBP_RESTRICT
const
br
int
v
const
char
label
[
]
)
{
if
(
br
-
>
bits
<
0
)
{
VP8LoadNewBytes
(
br
)
;
}
{
const
int
pos
=
br
-
>
bits
;
const
range_t
split
=
br
-
>
range
>
>
1
;
const
range_t
value
=
(
range_t
)
(
br
-
>
value
>
>
pos
)
;
const
int32_t
mask
=
(
int32_t
)
(
split
-
value
)
>
>
31
;
br
-
>
bits
-
=
1
;
br
-
>
range
+
=
(
range_t
)
mask
;
br
-
>
range
|
=
1
;
br
-
>
value
-
=
(
bit_t
)
(
(
split
+
1
)
&
(
uint32_t
)
mask
)
<
<
pos
;
BT_TRACK
(
br
)
;
return
(
v
^
mask
)
-
mask
;
}
}
static
WEBP_INLINE
int
VP8GetBitAlt
(
VP8BitReader
*
WEBP_RESTRICT
const
br
int
prob
const
char
label
[
]
)
{
range_t
range
=
br
-
>
range
;
if
(
br
-
>
bits
<
0
)
{
VP8LoadNewBytes
(
br
)
;
}
{
const
int
pos
=
br
-
>
bits
;
const
range_t
split
=
(
range
*
prob
)
>
>
8
;
const
range_t
value
=
(
range_t
)
(
br
-
>
value
>
>
pos
)
;
int
bit
;
if
(
value
>
split
)
{
range
-
=
split
+
1
;
br
-
>
value
-
=
(
bit_t
)
(
split
+
1
)
<
<
pos
;
bit
=
1
;
}
else
{
range
=
split
;
bit
=
0
;
}
if
(
range
<
=
(
range_t
)
0x7e
)
{
const
int
shift
=
kVP8Log2Range
[
range
]
;
range
=
kVP8NewRange
[
range
]
;
br
-
>
bits
-
=
shift
;
}
br
-
>
range
=
range
;
BT_TRACK
(
br
)
;
return
bit
;
}
}
#
ifdef
__cplusplus
}
#
endif
#
endif
