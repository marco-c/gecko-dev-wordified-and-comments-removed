#
if
!
defined
(
CUBEB_UTILS
)
#
define
CUBEB_UTILS
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
assert
.
h
>
#
include
<
type_traits
>
#
if
defined
(
WIN32
)
#
include
"
cubeb_utils_win
.
h
"
#
else
#
include
"
cubeb_utils_unix
.
h
"
#
endif
template
<
typename
T
>
void
PodCopy
(
T
*
destination
const
T
*
source
size_t
count
)
{
static_assert
(
std
:
:
is_trivial
<
T
>
:
:
value
"
Requires
trivial
type
"
)
;
memcpy
(
destination
source
count
*
sizeof
(
T
)
)
;
}
template
<
typename
T
>
void
PodMove
(
T
*
destination
const
T
*
source
size_t
count
)
{
static_assert
(
std
:
:
is_trivial
<
T
>
:
:
value
"
Requires
trivial
type
"
)
;
memmove
(
destination
source
count
*
sizeof
(
T
)
)
;
}
template
<
typename
T
>
void
PodZero
(
T
*
destination
size_t
count
)
{
static_assert
(
std
:
:
is_trivial
<
T
>
:
:
value
"
Requires
trivial
type
"
)
;
memset
(
destination
0
count
*
sizeof
(
T
)
)
;
}
template
<
typename
T
>
class
auto_array
{
public
:
explicit
auto_array
(
uint32_t
capacity
=
0
)
:
data_
(
capacity
?
new
T
[
capacity
]
:
nullptr
)
capacity_
(
capacity
)
length_
(
0
)
{
}
~
auto_array
(
)
{
delete
[
]
data_
;
}
T
*
data
(
)
const
{
return
data_
;
}
const
T
&
at
(
size_t
index
)
const
{
assert
(
index
<
length_
&
&
"
out
of
range
"
)
;
return
data_
[
index
]
;
}
T
&
at
(
size_t
index
)
{
assert
(
index
<
length_
&
&
"
out
of
range
"
)
;
return
data_
[
index
]
;
}
size_t
capacity
(
)
const
{
return
capacity_
;
}
size_t
length
(
)
const
{
return
length_
;
}
void
clear
(
)
{
length_
=
0
;
}
bool
reserve
(
size_t
new_capacity
)
{
if
(
new_capacity
<
length_
)
{
return
false
;
}
T
*
new_data
=
new
T
[
new_capacity
]
;
if
(
data_
&
&
length_
)
{
PodCopy
(
new_data
data_
length_
)
;
}
capacity_
=
new_capacity
;
delete
[
]
data_
;
data_
=
new_data
;
return
true
;
}
void
push
(
const
T
*
elements
size_t
length
)
{
if
(
length_
+
length
>
capacity_
)
{
reserve
(
length_
+
length
)
;
}
PodCopy
(
data_
+
length_
elements
length
)
;
length_
+
=
length
;
}
void
push_silence
(
size_t
length
)
{
if
(
length_
+
length
>
capacity_
)
{
reserve
(
length
+
length_
)
;
}
PodZero
(
data_
+
length_
length
)
;
length_
+
=
length
;
}
void
push_front_silence
(
size_t
length
)
{
if
(
length_
+
length
>
capacity_
)
{
reserve
(
length
+
length_
)
;
}
PodMove
(
data_
+
length
data_
length_
)
;
PodZero
(
data_
length
)
;
length_
+
=
length
;
}
size_t
available
(
)
const
{
return
capacity_
-
length_
;
}
bool
pop
(
T
*
elements
size_t
length
)
{
if
(
length
>
length_
)
{
return
false
;
}
if
(
elements
)
{
PodCopy
(
elements
data_
length
)
;
}
PodMove
(
data_
data_
+
length
length_
-
length
)
;
length_
-
=
length
;
return
true
;
}
void
set_length
(
size_t
length
)
{
assert
(
length
<
=
capacity_
)
;
length_
=
length
;
}
private
:
T
*
data_
;
size_t
capacity_
;
size_t
length_
;
}
;
struct
auto_lock
{
explicit
auto_lock
(
owned_critical_section
&
lock
)
:
lock
(
lock
)
{
lock
.
enter
(
)
;
}
~
auto_lock
(
)
{
lock
.
leave
(
)
;
}
private
:
owned_critical_section
&
lock
;
}
;
struct
auto_unlock
{
explicit
auto_unlock
(
owned_critical_section
&
lock
)
:
lock
(
lock
)
{
lock
.
leave
(
)
;
}
~
auto_unlock
(
)
{
lock
.
enter
(
)
;
}
private
:
owned_critical_section
&
lock
;
}
;
#
endif
