#
include
<
cassert
>
#
include
"
cubeb
-
internal
.
h
"
#
include
"
cubeb_mixer
.
h
"
#
define
MASK_MONO
(
1
<
<
CHANNEL_MONO
)
#
define
MASK_MONO_LFE
(
MASK_MONO
|
(
1
<
<
CHANNEL_LFE
)
)
#
define
MASK_STEREO
(
(
1
<
<
CHANNEL_LEFT
)
|
(
1
<
<
CHANNEL_RIGHT
)
)
#
define
MASK_STEREO_LFE
(
MASK_STEREO
|
(
1
<
<
CHANNEL_LFE
)
)
#
define
MASK_3F
(
MASK_STEREO
|
(
1
<
<
CHANNEL_CENTER
)
)
#
define
MASK_3F_LFE
(
MASK_3F
|
(
1
<
<
CHANNEL_LFE
)
)
#
define
MASK_2F1
(
MASK_STEREO
|
(
1
<
<
CHANNEL_RCENTER
)
)
#
define
MASK_2F1_LFE
(
MASK_2F1
|
(
1
<
<
CHANNEL_LFE
)
)
#
define
MASK_3F1
(
MASK_3F
|
(
1
<
<
CHANNEL_RCENTER
)
)
#
define
MASK_3F1_LFE
(
MASK_3F1
|
(
1
<
<
CHANNEL_LFE
)
)
#
define
MASK_2F2
(
MASK_STEREO
|
(
1
<
<
CHANNEL_LS
)
|
(
1
<
<
CHANNEL_RS
)
)
#
define
MASK_2F2_LFE
(
MASK_2F2
|
(
1
<
<
CHANNEL_LFE
)
)
#
define
MASK_3F2
(
MASK_2F2
|
(
1
<
<
CHANNEL_CENTER
)
)
#
define
MASK_3F2_LFE
(
MASK_3F2
|
(
1
<
<
CHANNEL_LFE
)
)
#
define
MASK_3F3R_LFE
(
MASK_3F2_LFE
|
(
1
<
<
CHANNEL_RCENTER
)
)
#
define
MASK_3F4_LFE
(
MASK_3F2_LFE
|
(
1
<
<
CHANNEL_RLS
)
|
(
1
<
<
CHANNEL_RRS
)
)
cubeb_channel_layout
cubeb_channel_map_to_layout
(
cubeb_channel_map
const
*
channel_map
)
{
uint32_t
channel_mask
=
0
;
for
(
uint8_t
i
=
0
;
i
<
channel_map
-
>
channels
;
+
+
i
)
{
if
(
channel_map
-
>
map
[
i
]
=
=
CHANNEL_INVALID
|
|
channel_map
-
>
map
[
i
]
=
=
CHANNEL_UNMAPPED
)
{
return
CUBEB_LAYOUT_UNDEFINED
;
}
channel_mask
|
=
1
<
<
channel_map
-
>
map
[
i
]
;
}
switch
(
channel_mask
)
{
case
MASK_MONO
:
return
CUBEB_LAYOUT_MONO
;
case
MASK_MONO_LFE
:
return
CUBEB_LAYOUT_MONO_LFE
;
case
MASK_STEREO
:
return
CUBEB_LAYOUT_STEREO
;
case
MASK_STEREO_LFE
:
return
CUBEB_LAYOUT_STEREO_LFE
;
case
MASK_3F
:
return
CUBEB_LAYOUT_3F
;
case
MASK_3F_LFE
:
return
CUBEB_LAYOUT_3F_LFE
;
case
MASK_2F1
:
return
CUBEB_LAYOUT_2F1
;
case
MASK_2F1_LFE
:
return
CUBEB_LAYOUT_2F1_LFE
;
case
MASK_3F1
:
return
CUBEB_LAYOUT_3F1
;
case
MASK_3F1_LFE
:
return
CUBEB_LAYOUT_3F1_LFE
;
case
MASK_2F2
:
return
CUBEB_LAYOUT_2F2
;
case
MASK_2F2_LFE
:
return
CUBEB_LAYOUT_2F2_LFE
;
case
MASK_3F2
:
return
CUBEB_LAYOUT_3F2
;
case
MASK_3F2_LFE
:
return
CUBEB_LAYOUT_3F2_LFE
;
case
MASK_3F3R_LFE
:
return
CUBEB_LAYOUT_3F3R_LFE
;
case
MASK_3F4_LFE
:
return
CUBEB_LAYOUT_3F4_LFE
;
default
:
return
CUBEB_LAYOUT_UNDEFINED
;
}
}
cubeb_layout_map
const
CUBEB_CHANNEL_LAYOUT_MAPS
[
CUBEB_LAYOUT_MAX
]
=
{
{
"
undefined
"
0
CUBEB_LAYOUT_UNDEFINED
}
{
"
dual
mono
"
2
CUBEB_LAYOUT_DUAL_MONO
}
{
"
dual
mono
lfe
"
3
CUBEB_LAYOUT_DUAL_MONO_LFE
}
{
"
mono
"
1
CUBEB_LAYOUT_MONO
}
{
"
mono
lfe
"
2
CUBEB_LAYOUT_MONO_LFE
}
{
"
stereo
"
2
CUBEB_LAYOUT_STEREO
}
{
"
stereo
lfe
"
3
CUBEB_LAYOUT_STEREO_LFE
}
{
"
3f
"
3
CUBEB_LAYOUT_3F
}
{
"
3f
lfe
"
4
CUBEB_LAYOUT_3F_LFE
}
{
"
2f1
"
3
CUBEB_LAYOUT_2F1
}
{
"
2f1
lfe
"
4
CUBEB_LAYOUT_2F1_LFE
}
{
"
3f1
"
4
CUBEB_LAYOUT_3F1
}
{
"
3f1
lfe
"
5
CUBEB_LAYOUT_3F1_LFE
}
{
"
2f2
"
4
CUBEB_LAYOUT_2F2
}
{
"
2f2
lfe
"
5
CUBEB_LAYOUT_2F2_LFE
}
{
"
3f2
"
5
CUBEB_LAYOUT_3F2
}
{
"
3f2
lfe
"
6
CUBEB_LAYOUT_3F2_LFE
}
{
"
3f3r
lfe
"
7
CUBEB_LAYOUT_3F3R_LFE
}
{
"
3f4
lfe
"
8
CUBEB_LAYOUT_3F4_LFE
}
}
;
static
int
const
CHANNEL_ORDER_TO_INDEX
[
CUBEB_LAYOUT_MAX
]
[
CHANNEL_MAX
]
=
{
{
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
}
{
-
1
0
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
}
{
-
1
0
1
-
1
-
1
-
1
-
1
-
1
-
1
2
}
{
0
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
}
{
0
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
1
}
{
-
1
0
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
}
{
-
1
0
1
-
1
-
1
-
1
-
1
-
1
-
1
2
}
{
-
1
0
1
2
-
1
-
1
-
1
-
1
-
1
-
1
}
{
-
1
0
1
2
-
1
-
1
-
1
-
1
-
1
3
}
{
-
1
0
1
-
1
-
1
-
1
-
1
2
-
1
-
1
}
{
-
1
0
1
-
1
-
1
-
1
-
1
3
-
1
2
}
{
-
1
0
1
2
-
1
-
1
-
1
3
-
1
-
1
}
{
-
1
0
1
2
-
1
-
1
-
1
4
-
1
3
}
{
-
1
0
1
-
1
2
3
-
1
-
1
-
1
-
1
}
{
-
1
0
1
-
1
3
4
-
1
-
1
-
1
2
}
{
-
1
0
1
2
3
4
-
1
-
1
-
1
-
1
}
{
-
1
0
1
2
4
5
-
1
-
1
-
1
3
}
{
-
1
0
1
2
5
6
-
1
4
-
1
3
}
{
-
1
0
1
2
6
7
4
-
1
5
3
}
}
;
unsigned
int
const
SUPPORTED_LAYOUT_NUM
=
12
;
unsigned
int
const
INPUT_CHANNEL_NUM
=
6
;
unsigned
int
const
MAX_OUTPUT_CHANNEL_NUM
=
5
;
float
const
INV_SQRT_2
=
0
.
707106f
;
static
float
const
DOWNMIX_MATRIX_3F2_LFE
[
SUPPORTED_LAYOUT_NUM
]
[
MAX_OUTPUT_CHANNEL_NUM
]
[
INPUT_CHANNEL_NUM
]
=
{
{
{
INV_SQRT_2
INV_SQRT_2
1
0
0
.
5
0
.
5
}
}
{
{
INV_SQRT_2
INV_SQRT_2
1
0
0
.
5
0
.
5
}
{
0
0
0
1
0
0
}
}
{
{
1
0
INV_SQRT_2
0
INV_SQRT_2
0
}
{
0
1
INV_SQRT_2
0
0
INV_SQRT_2
}
}
{
{
1
0
INV_SQRT_2
0
INV_SQRT_2
0
}
{
0
1
INV_SQRT_2
0
0
INV_SQRT_2
}
{
0
0
0
1
0
0
}
}
{
{
1
0
0
0
INV_SQRT_2
0
}
{
0
1
0
0
0
INV_SQRT_2
}
{
0
0
1
0
0
0
}
}
{
{
1
0
0
0
INV_SQRT_2
0
}
{
0
1
0
0
0
INV_SQRT_2
}
{
0
0
1
0
0
0
}
{
0
0
0
1
0
0
}
}
{
{
1
0
INV_SQRT_2
0
0
0
}
{
0
1
INV_SQRT_2
0
0
0
}
{
0
0
0
0
INV_SQRT_2
INV_SQRT_2
}
}
{
{
1
0
INV_SQRT_2
0
0
0
}
{
0
1
INV_SQRT_2
0
0
0
}
{
0
0
0
1
0
0
}
{
0
0
0
0
INV_SQRT_2
INV_SQRT_2
}
}
{
{
1
0
0
0
0
0
}
{
0
1
0
0
0
0
}
{
0
0
1
0
0
0
}
{
0
0
0
0
INV_SQRT_2
INV_SQRT_2
}
}
{
{
1
0
0
0
0
0
}
{
0
1
0
0
0
0
}
{
0
0
1
0
0
0
}
{
0
0
0
1
0
0
}
{
0
0
0
0
INV_SQRT_2
INV_SQRT_2
}
}
{
{
1
0
INV_SQRT_2
0
0
0
}
{
0
1
INV_SQRT_2
0
0
0
}
{
0
0
0
0
1
0
}
{
0
0
0
0
0
1
}
}
{
{
1
0
INV_SQRT_2
0
0
0
}
{
0
1
INV_SQRT_2
0
0
0
}
{
0
0
0
1
0
0
}
{
0
0
0
0
1
0
}
{
0
0
0
0
0
1
}
}
}
;
template
<
typename
T
>
bool
downmix_3f2
(
T
const
*
const
in
unsigned
long
inframes
T
*
out
cubeb_channel_layout
in_layout
cubeb_channel_layout
out_layout
)
{
if
(
(
in_layout
!
=
CUBEB_LAYOUT_3F2
&
&
in_layout
!
=
CUBEB_LAYOUT_3F2_LFE
)
|
|
out_layout
<
CUBEB_LAYOUT_MONO
|
|
out_layout
>
CUBEB_LAYOUT_2F2_LFE
)
{
return
false
;
}
unsigned
int
in_channels
=
CUBEB_CHANNEL_LAYOUT_MAPS
[
in_layout
]
.
channels
;
unsigned
int
out_channels
=
CUBEB_CHANNEL_LAYOUT_MAPS
[
out_layout
]
.
channels
;
assert
(
out_channels
<
=
in_channels
)
;
auto
&
downmix_matrix
=
DOWNMIX_MATRIX_3F2_LFE
[
out_layout
-
CUBEB_LAYOUT_MONO
]
;
unsigned
long
out_index
=
0
;
for
(
unsigned
long
i
=
0
;
i
<
inframes
*
in_channels
;
i
+
=
in_channels
)
{
for
(
unsigned
int
j
=
0
;
j
<
out_channels
;
+
+
j
)
{
T
sample
=
0
;
for
(
unsigned
int
k
=
0
;
k
<
INPUT_CHANNEL_NUM
;
+
+
k
)
{
T
data
=
(
in_layout
=
=
CUBEB_LAYOUT_3F2_LFE
)
?
in
[
i
+
k
]
:
(
k
=
=
3
)
?
0
:
in
[
i
+
(
(
k
<
3
)
?
k
:
k
-
1
)
]
;
sample
+
=
downmix_matrix
[
j
]
[
k
]
*
data
;
}
out
[
out_index
+
j
]
=
sample
;
}
#
if
defined
(
USE_AUDIOUNIT
)
out_index
+
=
in_channels
;
#
else
out_index
+
=
out_channels
;
#
endif
}
return
true
;
}
template
<
class
T
>
bool
mix_remap
(
T
const
*
const
in
unsigned
long
inframes
T
*
out
cubeb_channel_layout
in_layout
cubeb_channel_layout
out_layout
)
{
assert
(
in_layout
!
=
out_layout
)
;
if
(
in
=
=
out
)
{
return
false
;
}
unsigned
int
in_channels
=
CUBEB_CHANNEL_LAYOUT_MAPS
[
in_layout
]
.
channels
;
unsigned
int
out_channels
=
CUBEB_CHANNEL_LAYOUT_MAPS
[
out_layout
]
.
channels
;
uint32_t
in_layout_mask
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
in_channels
;
+
+
i
)
{
in_layout_mask
|
=
1
<
<
CHANNEL_INDEX_TO_ORDER
[
in_layout
]
[
i
]
;
}
uint32_t
out_layout_mask
=
0
;
for
(
unsigned
int
i
=
0
;
i
<
out_channels
;
+
+
i
)
{
out_layout_mask
|
=
1
<
<
CHANNEL_INDEX_TO_ORDER
[
out_layout
]
[
i
]
;
}
if
(
!
(
out_layout_mask
&
in_layout_mask
)
)
{
return
false
;
}
for
(
unsigned
long
i
=
0
out_index
=
0
;
i
<
inframes
*
in_channels
;
i
+
=
in_channels
out_index
+
=
out_channels
)
{
for
(
unsigned
int
j
=
0
;
j
<
out_channels
;
+
+
j
)
{
cubeb_channel
channel
=
CHANNEL_INDEX_TO_ORDER
[
out_layout
]
[
j
]
;
uint32_t
channel_mask
=
1
<
<
channel
;
int
channel_index
=
CHANNEL_ORDER_TO_INDEX
[
in_layout
]
[
channel
]
;
if
(
in_layout_mask
&
channel_mask
)
{
assert
(
channel_index
!
=
-
1
)
;
out
[
out_index
+
j
]
=
in
[
i
+
channel_index
]
;
}
else
{
assert
(
channel_index
=
=
-
1
)
;
out
[
out_index
+
j
]
=
0
;
}
}
}
return
true
;
}
template
<
typename
T
>
void
downmix_fallback
(
T
const
*
const
in
unsigned
long
inframes
T
*
out
unsigned
int
in_channels
unsigned
int
out_channels
)
{
assert
(
in_channels
>
=
out_channels
)
;
if
(
in_channels
=
=
out_channels
&
&
in
=
=
out
)
{
return
;
}
for
(
unsigned
long
i
=
0
out_index
=
0
;
i
<
inframes
*
in_channels
;
i
+
=
in_channels
out_index
+
=
out_channels
)
{
for
(
unsigned
int
j
=
0
;
j
<
out_channels
;
+
+
j
)
{
out
[
out_index
+
j
]
=
in
[
i
+
j
]
;
}
}
}
template
<
typename
T
>
void
cubeb_downmix
(
T
const
*
const
in
long
inframes
T
*
out
cubeb_stream_params
const
*
stream_params
cubeb_stream_params
const
*
mixer_params
)
{
assert
(
in
&
&
out
)
;
assert
(
inframes
)
;
assert
(
stream_params
-
>
channels
>
=
mixer_params
-
>
channels
&
&
mixer_params
-
>
channels
>
0
)
;
assert
(
stream_params
-
>
layout
!
=
CUBEB_LAYOUT_UNDEFINED
)
;
unsigned
int
in_channels
=
stream_params
-
>
channels
;
cubeb_channel_layout
in_layout
=
stream_params
-
>
layout
;
unsigned
int
out_channels
=
mixer_params
-
>
channels
;
cubeb_channel_layout
out_layout
=
mixer_params
-
>
layout
;
if
(
out_channels
=
=
CUBEB_CHANNEL_LAYOUT_MAPS
[
out_layout
]
.
channels
&
&
in_channels
=
=
CUBEB_CHANNEL_LAYOUT_MAPS
[
in_layout
]
.
channels
)
{
if
(
downmix_3f2
(
in
inframes
out
in_layout
out_layout
)
)
{
return
;
}
#
if
defined
(
USE_AUDIOUNIT
)
return
;
#
endif
if
(
mix_remap
(
in
inframes
out
in_layout
out_layout
)
)
{
return
;
}
}
downmix_fallback
(
in
inframes
out
in_channels
out_channels
)
;
}
template
<
typename
T
>
void
mono_to_stereo
(
T
const
*
in
long
insamples
T
*
out
unsigned
int
out_channels
)
{
for
(
long
i
=
0
j
=
0
;
i
<
insamples
;
+
+
i
j
+
=
out_channels
)
{
out
[
j
]
=
out
[
j
+
1
]
=
in
[
i
]
;
}
}
template
<
typename
T
>
void
cubeb_upmix
(
T
const
*
in
long
inframes
T
*
out
cubeb_stream_params
const
*
stream_params
cubeb_stream_params
const
*
mixer_params
)
{
assert
(
in
&
&
out
)
;
assert
(
inframes
)
;
assert
(
mixer_params
-
>
channels
>
=
stream_params
-
>
channels
&
&
stream_params
-
>
channels
>
0
)
;
unsigned
int
in_channels
=
stream_params
-
>
channels
;
unsigned
int
out_channels
=
mixer_params
-
>
channels
;
if
(
in_channels
=
=
1
&
&
out_channels
>
=
2
)
{
mono_to_stereo
(
in
inframes
out
out_channels
)
;
}
else
{
for
(
unsigned
int
i
=
0
o
=
0
;
i
<
inframes
*
in_channels
;
i
+
=
in_channels
o
+
=
out_channels
)
{
for
(
unsigned
int
j
=
0
;
j
<
in_channels
;
+
+
j
)
{
out
[
o
+
j
]
=
in
[
i
+
j
]
;
}
}
}
if
(
out_channels
<
=
2
)
{
return
;
}
for
(
long
i
=
0
o
=
0
;
i
<
inframes
;
+
+
i
o
+
=
out_channels
)
{
for
(
unsigned
int
j
=
2
;
j
<
out_channels
;
+
+
j
)
{
out
[
o
+
j
]
=
0
.
0
;
}
}
}
bool
cubeb_should_upmix
(
cubeb_stream_params
const
*
stream
cubeb_stream_params
const
*
mixer
)
{
return
mixer
-
>
channels
>
stream
-
>
channels
;
}
bool
cubeb_should_downmix
(
cubeb_stream_params
const
*
stream
cubeb_stream_params
const
*
mixer
)
{
if
(
mixer
-
>
channels
>
stream
-
>
channels
|
|
mixer
-
>
layout
=
=
stream
-
>
layout
)
{
return
false
;
}
return
mixer
-
>
channels
<
stream
-
>
channels
|
|
mixer
-
>
layout
=
=
CUBEB_LAYOUT_UNDEFINED
|
|
(
stream
-
>
layout
=
=
CUBEB_LAYOUT_3F2
&
&
(
mixer
-
>
layout
=
=
CUBEB_LAYOUT_2F2_LFE
|
|
mixer
-
>
layout
=
=
CUBEB_LAYOUT_3F1_LFE
)
)
;
}
bool
cubeb_should_mix
(
cubeb_stream_params
const
*
stream
cubeb_stream_params
const
*
mixer
)
{
return
cubeb_should_upmix
(
stream
mixer
)
|
|
cubeb_should_downmix
(
stream
mixer
)
;
}
struct
cubeb_mixer
{
virtual
void
mix
(
void
*
input_buffer
long
frames
void
*
output_buffer
cubeb_stream_params
const
*
stream_params
cubeb_stream_params
const
*
mixer_params
)
=
0
;
virtual
~
cubeb_mixer
(
)
{
}
;
}
;
template
<
typename
T
>
struct
cubeb_mixer_impl
:
public
cubeb_mixer
{
explicit
cubeb_mixer_impl
(
unsigned
int
d
)
:
direction
(
d
)
{
}
void
mix
(
void
*
input_buffer
long
frames
void
*
output_buffer
cubeb_stream_params
const
*
stream_params
cubeb_stream_params
const
*
mixer_params
)
{
if
(
frames
<
=
0
)
{
return
;
}
T
*
in
=
static_cast
<
T
*
>
(
input_buffer
)
;
T
*
out
=
static_cast
<
T
*
>
(
output_buffer
)
;
if
(
(
direction
&
CUBEB_MIXER_DIRECTION_DOWNMIX
)
&
&
cubeb_should_downmix
(
stream_params
mixer_params
)
)
{
cubeb_downmix
(
in
frames
out
stream_params
mixer_params
)
;
}
else
if
(
(
direction
&
CUBEB_MIXER_DIRECTION_UPMIX
)
&
&
cubeb_should_upmix
(
stream_params
mixer_params
)
)
{
cubeb_upmix
(
in
frames
out
stream_params
mixer_params
)
;
}
}
~
cubeb_mixer_impl
(
)
{
}
;
unsigned
char
const
direction
;
}
;
cubeb_mixer
*
cubeb_mixer_create
(
cubeb_sample_format
format
unsigned
char
direction
)
{
assert
(
direction
&
CUBEB_MIXER_DIRECTION_DOWNMIX
|
|
direction
&
CUBEB_MIXER_DIRECTION_UPMIX
)
;
switch
(
format
)
{
case
CUBEB_SAMPLE_S16NE
:
return
new
cubeb_mixer_impl
<
short
>
(
direction
)
;
case
CUBEB_SAMPLE_FLOAT32NE
:
return
new
cubeb_mixer_impl
<
float
>
(
direction
)
;
default
:
assert
(
false
)
;
return
nullptr
;
}
}
void
cubeb_mixer_destroy
(
cubeb_mixer
*
mixer
)
{
delete
mixer
;
}
void
cubeb_mixer_mix
(
cubeb_mixer
*
mixer
void
*
const
input_buffer
long
frames
void
*
output_buffer
cubeb_stream_params
const
*
stream_params
cubeb_stream_params
const
*
mixer_params
)
{
assert
(
mixer
)
;
mixer
-
>
mix
(
input_buffer
frames
output_buffer
stream_params
mixer_params
)
;
}
