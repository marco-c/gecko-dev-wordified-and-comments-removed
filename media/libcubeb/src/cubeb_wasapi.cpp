#
define
NOMINMAX
#
if
defined
(
HAVE_CONFIG_H
)
#
include
"
config
.
h
"
#
endif
#
include
<
initguid
.
h
>
#
include
<
windows
.
h
>
#
include
<
mmdeviceapi
.
h
>
#
include
<
windef
.
h
>
#
include
<
audioclient
.
h
>
#
include
<
devicetopology
.
h
>
#
include
<
process
.
h
>
#
include
<
avrt
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdint
.
h
>
#
include
<
cmath
>
#
include
<
algorithm
>
#
include
<
memory
>
#
include
"
cubeb
/
cubeb
.
h
"
#
include
"
cubeb
-
internal
.
h
"
#
include
"
cubeb_resampler
.
h
"
#
include
"
cubeb_utils
.
h
"
#
ifndef
__devicetopology_h__
#
include
"
cubeb_devicetopology
.
h
"
#
endif
#
ifndef
STACK_SIZE_PARAM_IS_A_RESERVATION
#
define
STACK_SIZE_PARAM_IS_A_RESERVATION
0x00010000
/
/
Threads
only
#
endif
#
ifndef
PKEY_Device_FriendlyName
DEFINE_PROPERTYKEY
(
PKEY_Device_FriendlyName
0xa45c254e
0xdf1c
0x4efd
0x80
0x20
0x67
0xd1
0x46
0xa8
0x50
0xe0
14
)
;
#
endif
#
ifndef
PKEY_Device_InstanceId
DEFINE_PROPERTYKEY
(
PKEY_Device_InstanceId
0x78c34fc8
0x104a
0x4aca
0x9e
0xa4
0x52
0x4d
0x52
0x99
0x6e
0x57
0x00000100
)
;
#
endif
#
ifdef
LOGGING_ENABLED
#
define
LOG
(
.
.
.
)
do
{
\
fprintf
(
stderr
__VA_ARGS__
)
;
\
}
while
(
0
)
#
else
#
define
LOG
(
.
.
.
)
#
endif
#
define
ARRAY_LENGTH
(
array_
)
\
(
sizeof
(
array_
)
/
sizeof
(
array_
[
0
]
)
)
namespace
{
uint32_t
ms_to_hns
(
uint32_t
ms
)
{
return
ms
*
10000
;
}
uint32_t
hns_to_ms
(
REFERENCE_TIME
hns
)
{
return
static_cast
<
uint32_t
>
(
hns
/
10000
)
;
}
double
hns_to_s
(
REFERENCE_TIME
hns
)
{
return
static_cast
<
double
>
(
hns
)
/
10000000
;
}
void
SafeRelease
(
HANDLE
handle
)
{
if
(
handle
)
{
CloseHandle
(
handle
)
;
}
}
template
<
typename
T
>
void
SafeRelease
(
T
*
ptr
)
{
if
(
ptr
)
{
ptr
-
>
Release
(
)
;
}
}
class
owned_critical_section
{
public
:
owned_critical_section
(
)
#
ifdef
DEBUG
:
owner
(
0
)
#
endif
{
InitializeCriticalSection
(
&
critical_section
)
;
}
~
owned_critical_section
(
)
{
DeleteCriticalSection
(
&
critical_section
)
;
}
void
enter
(
)
{
EnterCriticalSection
(
&
critical_section
)
;
#
ifdef
DEBUG
XASSERT
(
owner
!
=
GetCurrentThreadId
(
)
&
&
"
recursive
locking
"
)
;
owner
=
GetCurrentThreadId
(
)
;
#
endif
}
void
leave
(
)
{
#
ifdef
DEBUG
owner
=
0
;
#
endif
LeaveCriticalSection
(
&
critical_section
)
;
}
void
assert_current_thread_owns
(
)
{
#
ifdef
DEBUG
XASSERT
(
owner
=
=
GetCurrentThreadId
(
)
)
;
#
endif
}
private
:
CRITICAL_SECTION
critical_section
;
#
ifdef
DEBUG
DWORD
owner
;
#
endif
}
;
struct
auto_lock
{
auto_lock
(
owned_critical_section
*
lock
)
:
lock
(
lock
)
{
lock
-
>
enter
(
)
;
}
~
auto_lock
(
)
{
lock
-
>
leave
(
)
;
}
private
:
owned_critical_section
*
lock
;
}
;
struct
auto_com
{
auto_com
(
)
{
result
=
CoInitializeEx
(
NULL
COINIT_MULTITHREADED
)
;
}
~
auto_com
(
)
{
if
(
result
=
=
RPC_E_CHANGED_MODE
)
{
LOG
(
"
COM
was
already
initialized
in
STA
.
\
n
"
)
;
}
else
if
(
result
=
=
S_FALSE
)
{
LOG
(
"
COM
was
already
initialized
in
MTA
\
n
"
)
;
}
if
(
SUCCEEDED
(
result
)
)
{
CoUninitialize
(
)
;
}
}
bool
ok
(
)
{
return
result
=
=
RPC_E_CHANGED_MODE
|
|
SUCCEEDED
(
result
)
;
}
private
:
HRESULT
result
;
}
;
typedef
HANDLE
(
WINAPI
*
set_mm_thread_characteristics_function
)
(
const
char
*
TaskName
LPDWORD
TaskIndex
)
;
typedef
BOOL
(
WINAPI
*
revert_mm_thread_characteristics_function
)
(
HANDLE
handle
)
;
extern
cubeb_ops
const
wasapi_ops
;
int
wasapi_stream_stop
(
cubeb_stream
*
stm
)
;
int
wasapi_stream_start
(
cubeb_stream
*
stm
)
;
void
close_wasapi_stream
(
cubeb_stream
*
stm
)
;
int
setup_wasapi_stream
(
cubeb_stream
*
stm
)
;
static
char
*
wstr_to_utf8
(
const
wchar_t
*
str
)
;
static
const
wchar_t
*
utf8_to_wstr
(
char
*
str
)
;
}
struct
cubeb
{
cubeb_ops
const
*
ops
;
HMODULE
mmcss_module
;
set_mm_thread_characteristics_function
set_mm_thread_characteristics
;
revert_mm_thread_characteristics_function
revert_mm_thread_characteristics
;
}
;
class
wasapi_endpoint_notification_client
;
typedef
bool
(
*
wasapi_refill_callback
)
(
cubeb_stream
*
stm
)
;
struct
cubeb_stream
{
cubeb
*
context
;
cubeb_stream_params
input_mix_params
;
cubeb_stream_params
output_mix_params
;
cubeb_stream_params
input_stream_params
;
cubeb_stream_params
output_stream_params
;
cubeb_devid
input_device
;
cubeb_devid
output_device
;
unsigned
latency
;
cubeb_state_callback
state_callback
;
cubeb_data_callback
data_callback
;
wasapi_refill_callback
refill_callback
;
void
*
user_ptr
;
IAudioClient
*
output_client
;
IAudioRenderClient
*
render_client
;
IAudioStreamVolume
*
audio_stream_volume
;
IAudioClock
*
audio_clock
;
UINT64
frames_written
;
UINT64
total_frames_written
;
UINT64
prev_position
;
IMMDeviceEnumerator
*
device_enumerator
;
wasapi_endpoint_notification_client
*
notification_client
;
IAudioClient
*
input_client
;
IAudioCaptureClient
*
capture_client
;
HANDLE
shutdown_event
;
HANDLE
reconfigure_event
;
HANDLE
refill_event
;
HANDLE
input_available_event
;
HANDLE
thread
;
owned_critical_section
*
stream_reset_lock
;
uint32_t
input_buffer_frame_count
;
uint32_t
output_buffer_frame_count
;
cubeb_resampler
*
resampler
;
float
*
mix_buffer
;
auto_array
<
float
>
linear_input_buffer
;
float
volume
;
bool
draining
;
}
;
class
wasapi_endpoint_notification_client
:
public
IMMNotificationClient
{
public
:
ULONG
STDMETHODCALLTYPE
AddRef
(
)
{
return
InterlockedIncrement
(
&
ref_count
)
;
}
ULONG
STDMETHODCALLTYPE
Release
(
)
{
ULONG
ulRef
=
InterlockedDecrement
(
&
ref_count
)
;
if
(
0
=
=
ulRef
)
{
delete
this
;
}
return
ulRef
;
}
HRESULT
STDMETHODCALLTYPE
QueryInterface
(
REFIID
riid
VOID
*
*
ppvInterface
)
{
if
(
__uuidof
(
IUnknown
)
=
=
riid
)
{
AddRef
(
)
;
*
ppvInterface
=
(
IUnknown
*
)
this
;
}
else
if
(
__uuidof
(
IMMNotificationClient
)
=
=
riid
)
{
AddRef
(
)
;
*
ppvInterface
=
(
IMMNotificationClient
*
)
this
;
}
else
{
*
ppvInterface
=
NULL
;
return
E_NOINTERFACE
;
}
return
S_OK
;
}
wasapi_endpoint_notification_client
(
HANDLE
event
)
:
ref_count
(
1
)
reconfigure_event
(
event
)
{
}
virtual
~
wasapi_endpoint_notification_client
(
)
{
}
HRESULT
STDMETHODCALLTYPE
OnDefaultDeviceChanged
(
EDataFlow
flow
ERole
role
LPCWSTR
device_id
)
{
LOG
(
"
Audio
device
default
changed
.
\
n
"
)
;
if
(
flow
!
=
eRender
&
&
role
!
=
eConsole
)
{
return
S_OK
;
}
BOOL
ok
=
SetEvent
(
reconfigure_event
)
;
if
(
!
ok
)
{
LOG
(
"
SetEvent
on
reconfigure_event
failed
:
%
x
\
n
"
GetLastError
(
)
)
;
}
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
OnDeviceAdded
(
LPCWSTR
device_id
)
{
LOG
(
"
Audio
device
added
.
\
n
"
)
;
return
S_OK
;
}
;
HRESULT
STDMETHODCALLTYPE
OnDeviceRemoved
(
LPCWSTR
device_id
)
{
LOG
(
"
Audio
device
removed
.
\
n
"
)
;
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
OnDeviceStateChanged
(
LPCWSTR
device_id
DWORD
new_state
)
{
LOG
(
"
Audio
device
state
changed
.
\
n
"
)
;
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
OnPropertyValueChanged
(
LPCWSTR
device_id
const
PROPERTYKEY
key
)
{
LOG
(
"
Audio
device
property
value
changed
.
\
n
"
)
;
return
S_OK
;
}
private
:
LONG
ref_count
;
HANDLE
reconfigure_event
;
}
;
namespace
{
bool
has_input
(
cubeb_stream
*
stm
)
{
return
stm
-
>
input_stream_params
.
rate
!
=
0
;
}
bool
has_output
(
cubeb_stream
*
stm
)
{
return
stm
-
>
output_stream_params
.
rate
!
=
0
;
}
bool
should_upmix
(
cubeb_stream_params
&
stream
cubeb_stream_params
&
mixer
)
{
return
mixer
.
channels
>
stream
.
channels
;
}
bool
should_downmix
(
cubeb_stream_params
&
stream
cubeb_stream_params
&
mixer
)
{
return
mixer
.
channels
<
stream
.
channels
;
}
double
stream_to_mix_samplerate_ratio
(
cubeb_stream_params
&
stream
cubeb_stream_params
&
mixer
)
{
return
double
(
stream
.
rate
)
/
mixer
.
rate
;
}
template
<
typename
T
>
void
mono_to_stereo
(
T
*
in
long
insamples
T
*
out
int32_t
out_channels
)
{
for
(
int
i
=
0
j
=
0
;
i
<
insamples
;
+
+
i
j
+
=
out_channels
)
{
out
[
j
]
=
out
[
j
+
1
]
=
in
[
i
]
;
}
}
template
<
typename
T
>
void
upmix
(
T
*
in
long
inframes
T
*
out
int32_t
in_channels
int32_t
out_channels
)
{
XASSERT
(
out_channels
>
=
in_channels
&
&
in_channels
>
0
)
;
if
(
in_channels
=
=
1
&
&
out_channels
>
=
2
)
{
mono_to_stereo
(
in
inframes
out
out_channels
)
;
}
else
{
for
(
int
i
=
0
o
=
0
;
i
<
inframes
*
in_channels
;
i
+
=
in_channels
o
+
=
out_channels
)
{
for
(
int
j
=
0
;
j
<
in_channels
;
+
+
j
)
{
out
[
o
+
j
]
=
in
[
i
+
j
]
;
}
}
}
if
(
out_channels
<
=
2
)
{
return
;
}
for
(
long
i
=
0
o
=
0
;
i
<
inframes
;
+
+
i
o
+
=
out_channels
)
{
for
(
int
j
=
2
;
j
<
out_channels
;
+
+
j
)
{
out
[
o
+
j
]
=
0
.
0
;
}
}
}
template
<
typename
T
>
void
downmix
(
T
*
in
long
inframes
T
*
out
int32_t
in_channels
int32_t
out_channels
)
{
XASSERT
(
in_channels
>
=
out_channels
)
;
long
out_index
=
0
;
for
(
long
i
=
0
;
i
<
inframes
*
in_channels
;
i
+
=
in_channels
)
{
for
(
int
j
=
0
;
j
<
out_channels
;
+
+
j
)
{
out
[
out_index
+
j
]
=
in
[
i
+
j
]
;
}
out_index
+
=
out_channels
;
}
}
static
size_t
frames_to_bytes_before_mix
(
cubeb_stream
*
stm
size_t
frames
)
{
size_t
stream_frame_size
=
stm
-
>
output_stream_params
.
channels
*
sizeof
(
float
)
;
return
stream_frame_size
*
frames
;
}
long
refill
(
cubeb_stream
*
stm
float
*
input_buffer
long
input_frames_count
float
*
output_buffer
long
output_frames_needed
)
{
float
*
dest
=
nullptr
;
if
(
has_output
(
stm
)
)
{
if
(
should_upmix
(
stm
-
>
output_stream_params
stm
-
>
output_mix_params
)
|
|
should_downmix
(
stm
-
>
output_stream_params
stm
-
>
output_mix_params
)
)
{
dest
=
stm
-
>
mix_buffer
;
}
else
{
dest
=
output_buffer
;
}
}
long
out_frames
=
cubeb_resampler_fill
(
stm
-
>
resampler
input_buffer
&
input_frames_count
dest
output_frames_needed
)
;
XASSERT
(
out_frames
>
=
0
)
;
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
stm
-
>
frames_written
+
=
out_frames
;
}
if
(
out_frames
<
output_frames_needed
)
{
LOG
(
"
start
draining
.
\
n
"
)
;
stm
-
>
draining
=
true
;
}
XASSERT
(
out_frames
=
=
output_frames_needed
|
|
stm
-
>
draining
|
|
!
has_output
(
stm
)
)
;
if
(
has_output
(
stm
)
)
{
if
(
should_upmix
(
stm
-
>
output_stream_params
stm
-
>
output_mix_params
)
)
{
upmix
(
dest
out_frames
output_buffer
stm
-
>
output_stream_params
.
channels
stm
-
>
output_mix_params
.
channels
)
;
}
else
if
(
should_downmix
(
stm
-
>
output_stream_params
stm
-
>
output_mix_params
)
)
{
downmix
(
dest
out_frames
output_buffer
stm
-
>
output_stream_params
.
channels
stm
-
>
output_mix_params
.
channels
)
;
}
}
return
out_frames
;
}
bool
get_input_buffer
(
cubeb_stream
*
stm
)
{
HRESULT
hr
;
UINT32
padding_in
;
XASSERT
(
has_input
(
stm
)
)
;
hr
=
stm
-
>
input_client
-
>
GetCurrentPadding
(
&
padding_in
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Failed
to
get
padding
\
n
"
)
;
return
false
;
}
XASSERT
(
padding_in
<
=
stm
-
>
input_buffer_frame_count
)
;
UINT32
total_available_input
=
padding_in
;
BYTE
*
input_packet
=
NULL
;
DWORD
flags
;
UINT64
dev_pos
;
UINT32
next
;
uint32_t
offset
=
0
;
uint32_t
input_channel_count
=
stm
-
>
input_mix_params
.
channels
;
while
(
offset
!
=
total_available_input
*
input_channel_count
&
&
total_available_input
)
{
hr
=
stm
-
>
capture_client
-
>
GetNextPacketSize
(
&
next
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
cannot
get
next
packet
size
:
%
x
\
n
"
hr
)
;
return
false
;
}
if
(
!
next
)
{
break
;
}
UINT32
packet_size
;
hr
=
stm
-
>
capture_client
-
>
GetBuffer
(
&
input_packet
&
packet_size
&
flags
&
dev_pos
NULL
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
GetBuffer
failed
for
capture
:
%
x
\
n
"
hr
)
;
return
false
;
}
XASSERT
(
packet_size
=
=
next
)
;
if
(
flags
&
AUDCLNT_BUFFERFLAGS_SILENT
)
{
LOG
(
"
insert
silence
:
ps
=
%
u
\
n
"
packet_size
)
;
stm
-
>
linear_input_buffer
.
push_silence
(
packet_size
*
stm
-
>
input_stream_params
.
channels
)
;
}
else
{
if
(
should_upmix
(
stm
-
>
input_mix_params
stm
-
>
input_stream_params
)
)
{
bool
ok
=
stm
-
>
linear_input_buffer
.
reserve
(
stm
-
>
linear_input_buffer
.
length
(
)
+
packet_size
*
stm
-
>
input_stream_params
.
channels
)
;
assert
(
ok
)
;
upmix
(
reinterpret_cast
<
float
*
>
(
input_packet
)
packet_size
stm
-
>
linear_input_buffer
.
data
(
)
+
stm
-
>
linear_input_buffer
.
length
(
)
input_channel_count
stm
-
>
input_stream_params
.
channels
)
;
stm
-
>
linear_input_buffer
.
set_length
(
stm
-
>
linear_input_buffer
.
length
(
)
+
packet_size
*
stm
-
>
input_stream_params
.
channels
)
;
}
else
if
(
should_downmix
(
stm
-
>
input_mix_params
stm
-
>
input_stream_params
)
)
{
bool
ok
=
stm
-
>
linear_input_buffer
.
reserve
(
stm
-
>
linear_input_buffer
.
length
(
)
+
packet_size
*
stm
-
>
input_stream_params
.
channels
)
;
assert
(
ok
)
;
downmix
(
reinterpret_cast
<
float
*
>
(
input_packet
)
packet_size
stm
-
>
linear_input_buffer
.
data
(
)
+
stm
-
>
linear_input_buffer
.
length
(
)
input_channel_count
stm
-
>
input_stream_params
.
channels
)
;
stm
-
>
linear_input_buffer
.
set_length
(
stm
-
>
linear_input_buffer
.
length
(
)
+
packet_size
*
stm
-
>
input_stream_params
.
channels
)
;
}
else
{
stm
-
>
linear_input_buffer
.
push
(
reinterpret_cast
<
float
*
>
(
input_packet
)
packet_size
*
stm
-
>
input_stream_params
.
channels
)
;
}
}
hr
=
stm
-
>
capture_client
-
>
ReleaseBuffer
(
packet_size
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
FAILED
to
release
intput
buffer
"
)
;
return
false
;
}
offset
+
=
packet_size
*
input_channel_count
;
}
assert
(
stm
-
>
linear_input_buffer
.
length
(
)
=
=
total_available_input
)
;
return
true
;
}
bool
get_output_buffer
(
cubeb_stream
*
stm
float
*
&
buffer
size_t
&
frame_count
)
{
UINT32
padding_out
;
HRESULT
hr
;
XASSERT
(
has_output
(
stm
)
)
;
hr
=
stm
-
>
output_client
-
>
GetCurrentPadding
(
&
padding_out
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Failed
to
get
padding
:
%
x
\
n
"
hr
)
;
return
false
;
}
XASSERT
(
padding_out
<
=
stm
-
>
output_buffer_frame_count
)
;
if
(
stm
-
>
draining
)
{
if
(
padding_out
=
=
0
)
{
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_DRAINED
)
;
return
false
;
}
return
true
;
}
frame_count
=
stm
-
>
output_buffer_frame_count
-
padding_out
;
BYTE
*
output_buffer
;
hr
=
stm
-
>
render_client
-
>
GetBuffer
(
frame_count
&
output_buffer
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
cannot
get
render
buffer
\
n
"
)
;
return
false
;
}
buffer
=
reinterpret_cast
<
float
*
>
(
output_buffer
)
;
return
true
;
}
bool
refill_callback_duplex
(
cubeb_stream
*
stm
)
{
HRESULT
hr
;
float
*
output_buffer
;
size_t
output_frames
;
bool
rv
;
XASSERT
(
has_input
(
stm
)
&
&
has_output
(
stm
)
)
;
rv
=
get_input_buffer
(
stm
)
;
if
(
!
rv
)
{
return
rv
;
}
rv
=
get_output_buffer
(
stm
output_buffer
output_frames
)
;
if
(
!
rv
)
{
return
rv
;
}
if
(
output_frames
=
=
0
)
{
return
true
;
}
size_t
input_frames
=
stm
-
>
linear_input_buffer
.
length
(
)
/
stm
-
>
input_stream_params
.
channels
;
double
output_duration
=
double
(
output_frames
)
/
stm
-
>
output_mix_params
.
rate
;
double
input_duration
=
double
(
input_frames
)
/
stm
-
>
input_mix_params
.
rate
;
if
(
input_duration
<
output_duration
)
{
size_t
padding
=
round
(
(
output_duration
-
input_duration
)
*
stm
-
>
input_mix_params
.
rate
)
;
LOG
(
"
padding
silence
:
out
=
%
f
in
=
%
f
pad
=
%
u
\
n
"
output_duration
input_duration
padding
)
;
stm
-
>
linear_input_buffer
.
push_front_silence
(
padding
*
stm
-
>
input_stream_params
.
channels
)
;
}
refill
(
stm
stm
-
>
linear_input_buffer
.
data
(
)
stm
-
>
linear_input_buffer
.
length
(
)
output_buffer
output_frames
)
;
stm
-
>
linear_input_buffer
.
clear
(
)
;
hr
=
stm
-
>
render_client
-
>
ReleaseBuffer
(
output_frames
0
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
failed
to
release
buffer
:
%
x
\
n
"
hr
)
;
return
false
;
}
return
true
;
}
bool
refill_callback_input
(
cubeb_stream
*
stm
)
{
bool
rv
consumed_all_buffer
;
XASSERT
(
has_input
(
stm
)
&
&
!
has_output
(
stm
)
)
;
rv
=
get_input_buffer
(
stm
)
;
if
(
!
rv
)
{
return
rv
;
}
long
read
=
refill
(
stm
stm
-
>
linear_input_buffer
.
data
(
)
stm
-
>
linear_input_buffer
.
length
(
)
nullptr
0
)
;
consumed_all_buffer
=
read
=
=
stm
-
>
linear_input_buffer
.
length
(
)
;
stm
-
>
linear_input_buffer
.
clear
(
)
;
return
consumed_all_buffer
;
}
bool
refill_callback_output
(
cubeb_stream
*
stm
)
{
bool
rv
;
HRESULT
hr
;
float
*
output_buffer
;
size_t
output_frames
;
XASSERT
(
!
has_input
(
stm
)
&
&
has_output
(
stm
)
)
;
rv
=
get_output_buffer
(
stm
output_buffer
output_frames
)
;
if
(
!
rv
)
{
return
rv
;
}
if
(
stm
-
>
draining
|
|
output_frames
=
=
0
)
{
return
true
;
}
long
got
=
refill
(
stm
nullptr
0
output_buffer
output_frames
)
;
hr
=
stm
-
>
render_client
-
>
ReleaseBuffer
(
output_frames
0
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
failed
to
release
buffer
:
%
x
\
n
"
hr
)
;
return
false
;
}
return
got
=
=
output_frames
|
|
stm
-
>
draining
;
}
static
unsigned
int
__stdcall
wasapi_stream_render_loop
(
LPVOID
stream
)
{
cubeb_stream
*
stm
=
static_cast
<
cubeb_stream
*
>
(
stream
)
;
bool
is_playing
=
true
;
HANDLE
wait_array
[
4
]
=
{
stm
-
>
shutdown_event
stm
-
>
reconfigure_event
stm
-
>
refill_event
stm
-
>
input_available_event
}
;
HANDLE
mmcss_handle
=
NULL
;
HRESULT
hr
=
0
;
DWORD
mmcss_task_index
=
0
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
LOG
(
"
COM
initialization
failed
on
render_loop
thread
.
\
n
"
)
;
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_ERROR
)
;
return
0
;
}
mmcss_handle
=
stm
-
>
context
-
>
set_mm_thread_characteristics
(
"
Audio
"
&
mmcss_task_index
)
;
if
(
!
mmcss_handle
)
{
LOG
(
"
Unable
to
use
mmcss
to
bump
the
render
thread
priority
:
%
x
\
n
"
GetLastError
(
)
)
;
}
unsigned
timeout_count
=
0
;
const
unsigned
timeout_limit
=
5
;
while
(
is_playing
)
{
DWORD
waitResult
=
WaitForMultipleObjects
(
ARRAY_LENGTH
(
wait_array
)
wait_array
FALSE
1000
)
;
if
(
waitResult
!
=
WAIT_TIMEOUT
)
{
timeout_count
=
0
;
}
switch
(
waitResult
)
{
case
WAIT_OBJECT_0
:
{
is_playing
=
false
;
if
(
stm
-
>
draining
)
{
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_DRAINED
)
;
}
continue
;
}
case
WAIT_OBJECT_0
+
1
:
{
if
(
stm
-
>
output_client
)
{
stm
-
>
output_client
-
>
Stop
(
)
;
}
if
(
stm
-
>
input_client
)
{
stm
-
>
input_client
-
>
Stop
(
)
;
}
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
close_wasapi_stream
(
stm
)
;
int
r
=
setup_wasapi_stream
(
stm
)
;
if
(
r
!
=
CUBEB_OK
)
{
is_playing
=
false
;
hr
=
E_FAIL
;
continue
;
}
}
if
(
stm
-
>
output_client
)
{
stm
-
>
output_client
-
>
Start
(
)
;
}
if
(
stm
-
>
input_client
)
{
stm
-
>
input_client
-
>
Start
(
)
;
}
break
;
}
case
WAIT_OBJECT_0
+
2
:
XASSERT
(
has_input
(
stm
)
&
&
has_output
(
stm
)
|
|
!
has_input
(
stm
)
&
&
has_output
(
stm
)
)
;
is_playing
=
stm
-
>
refill_callback
(
stm
)
;
break
;
case
WAIT_OBJECT_0
+
3
:
if
(
has_input
(
stm
)
&
&
has_output
(
stm
)
)
{
continue
;
}
is_playing
=
stm
-
>
refill_callback
(
stm
)
;
break
;
case
WAIT_TIMEOUT
:
XASSERT
(
stm
-
>
shutdown_event
=
=
wait_array
[
0
]
)
;
if
(
+
+
timeout_count
>
=
timeout_limit
)
{
is_playing
=
false
;
hr
=
E_FAIL
;
}
break
;
default
:
LOG
(
"
case
%
d
not
handled
in
render
loop
.
"
waitResult
)
;
abort
(
)
;
}
}
if
(
FAILED
(
hr
)
)
{
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_ERROR
)
;
}
stm
-
>
context
-
>
revert_mm_thread_characteristics
(
mmcss_handle
)
;
return
0
;
}
void
wasapi_destroy
(
cubeb
*
context
)
;
HANDLE
WINAPI
set_mm_thread_characteristics_noop
(
const
char
*
LPDWORD
mmcss_task_index
)
{
return
(
HANDLE
)
1
;
}
BOOL
WINAPI
revert_mm_thread_characteristics_noop
(
HANDLE
mmcss_handle
)
{
return
true
;
}
HRESULT
register_notification_client
(
cubeb_stream
*
stm
)
{
HRESULT
hr
=
CoCreateInstance
(
__uuidof
(
MMDeviceEnumerator
)
NULL
CLSCTX_INPROC_SERVER
IID_PPV_ARGS
(
&
stm
-
>
device_enumerator
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
device
enumerator
:
%
x
\
n
"
hr
)
;
return
hr
;
}
stm
-
>
notification_client
=
new
wasapi_endpoint_notification_client
(
stm
-
>
reconfigure_event
)
;
hr
=
stm
-
>
device_enumerator
-
>
RegisterEndpointNotificationCallback
(
stm
-
>
notification_client
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
register
endpoint
notification
callback
:
%
x
\
n
"
hr
)
;
SafeRelease
(
stm
-
>
notification_client
)
;
stm
-
>
notification_client
=
nullptr
;
SafeRelease
(
stm
-
>
device_enumerator
)
;
stm
-
>
device_enumerator
=
nullptr
;
}
return
hr
;
}
HRESULT
unregister_notification_client
(
cubeb_stream
*
stm
)
{
XASSERT
(
stm
)
;
HRESULT
hr
;
if
(
!
stm
-
>
device_enumerator
)
{
return
S_OK
;
}
hr
=
stm
-
>
device_enumerator
-
>
UnregisterEndpointNotificationCallback
(
stm
-
>
notification_client
)
;
if
(
FAILED
(
hr
)
)
{
SafeRelease
(
stm
-
>
device_enumerator
)
;
return
S_OK
;
}
SafeRelease
(
stm
-
>
notification_client
)
;
SafeRelease
(
stm
-
>
device_enumerator
)
;
return
S_OK
;
}
HRESULT
get_endpoint
(
IMMDevice
*
*
device
LPCWSTR
devid
)
{
IMMDeviceEnumerator
*
enumerator
;
HRESULT
hr
=
CoCreateInstance
(
__uuidof
(
MMDeviceEnumerator
)
NULL
CLSCTX_INPROC_SERVER
IID_PPV_ARGS
(
&
enumerator
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
device
enumerator
:
%
x
\
n
"
hr
)
;
return
hr
;
}
hr
=
enumerator
-
>
GetDevice
(
devid
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
device
:
%
x
\
n
"
hr
)
;
SafeRelease
(
enumerator
)
;
return
hr
;
}
SafeRelease
(
enumerator
)
;
return
S_OK
;
}
HRESULT
get_default_endpoint
(
IMMDevice
*
*
device
EDataFlow
direction
)
{
IMMDeviceEnumerator
*
enumerator
;
HRESULT
hr
=
CoCreateInstance
(
__uuidof
(
MMDeviceEnumerator
)
NULL
CLSCTX_INPROC_SERVER
IID_PPV_ARGS
(
&
enumerator
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
device
enumerator
:
%
x
\
n
"
hr
)
;
return
hr
;
}
hr
=
enumerator
-
>
GetDefaultAudioEndpoint
(
direction
eConsole
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
default
audio
endpoint
:
%
x
\
n
"
hr
)
;
SafeRelease
(
enumerator
)
;
return
hr
;
}
SafeRelease
(
enumerator
)
;
return
ERROR_SUCCESS
;
}
double
current_stream_delay
(
cubeb_stream
*
stm
)
{
stm
-
>
stream_reset_lock
-
>
assert_current_thread_owns
(
)
;
if
(
!
stm
-
>
audio_clock
)
{
return
0
;
}
UINT64
freq
;
HRESULT
hr
=
stm
-
>
audio_clock
-
>
GetFrequency
(
&
freq
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
GetFrequency
failed
:
%
x
\
n
"
hr
)
;
return
0
;
}
UINT64
pos
;
hr
=
stm
-
>
audio_clock
-
>
GetPosition
(
&
pos
NULL
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
GetPosition
failed
:
%
x
\
n
"
hr
)
;
return
0
;
}
double
cur_pos
=
static_cast
<
double
>
(
pos
)
/
freq
;
double
max_pos
=
static_cast
<
double
>
(
stm
-
>
frames_written
)
/
stm
-
>
output_mix_params
.
rate
;
double
delay
=
max_pos
-
cur_pos
;
XASSERT
(
delay
>
=
0
|
|
stm
-
>
draining
)
;
return
delay
;
}
int
stream_set_volume
(
cubeb_stream
*
stm
float
volume
)
{
stm
-
>
stream_reset_lock
-
>
assert_current_thread_owns
(
)
;
if
(
!
stm
-
>
audio_stream_volume
)
{
return
CUBEB_ERROR
;
}
uint32_t
channels
;
HRESULT
hr
=
stm
-
>
audio_stream_volume
-
>
GetChannelCount
(
&
channels
)
;
if
(
hr
!
=
S_OK
)
{
LOG
(
"
could
not
get
the
channel
count
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
if
(
channels
>
10
)
{
return
CUBEB_ERROR_NOT_SUPPORTED
;
}
float
volumes
[
10
]
;
for
(
uint32_t
i
=
0
;
i
<
channels
;
i
+
+
)
{
volumes
[
i
]
=
volume
;
}
hr
=
stm
-
>
audio_stream_volume
-
>
SetAllVolumes
(
channels
volumes
)
;
if
(
hr
!
=
S_OK
)
{
LOG
(
"
could
not
set
the
channels
volume
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
return
CUBEB_OK
;
}
}
extern
"
C
"
{
int
wasapi_init
(
cubeb
*
*
context
char
const
*
context_name
)
{
HRESULT
hr
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
IMMDevice
*
device
;
hr
=
get_default_endpoint
(
&
device
eRender
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
device
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
SafeRelease
(
device
)
;
cubeb
*
ctx
=
(
cubeb
*
)
calloc
(
1
sizeof
(
cubeb
)
)
;
if
(
!
ctx
)
{
return
CUBEB_ERROR
;
}
ctx
-
>
ops
=
&
wasapi_ops
;
ctx
-
>
mmcss_module
=
LoadLibraryA
(
"
Avrt
.
dll
"
)
;
if
(
ctx
-
>
mmcss_module
)
{
ctx
-
>
set_mm_thread_characteristics
=
(
set_mm_thread_characteristics_function
)
GetProcAddress
(
ctx
-
>
mmcss_module
"
AvSetMmThreadCharacteristicsA
"
)
;
ctx
-
>
revert_mm_thread_characteristics
=
(
revert_mm_thread_characteristics_function
)
GetProcAddress
(
ctx
-
>
mmcss_module
"
AvRevertMmThreadCharacteristics
"
)
;
if
(
!
(
ctx
-
>
set_mm_thread_characteristics
&
&
ctx
-
>
revert_mm_thread_characteristics
)
)
{
LOG
(
"
Could
not
load
AvSetMmThreadCharacteristics
or
AvRevertMmThreadCharacteristics
:
%
x
\
n
"
GetLastError
(
)
)
;
FreeLibrary
(
ctx
-
>
mmcss_module
)
;
}
}
else
{
LOG
(
"
Could
not
load
Avrt
.
dll
\
n
"
)
;
ctx
-
>
set_mm_thread_characteristics
=
&
set_mm_thread_characteristics_noop
;
ctx
-
>
revert_mm_thread_characteristics
=
&
revert_mm_thread_characteristics_noop
;
}
*
context
=
ctx
;
return
CUBEB_OK
;
}
}
namespace
{
void
stop_and_join_render_thread
(
cubeb_stream
*
stm
)
{
if
(
!
stm
-
>
thread
)
{
return
;
}
BOOL
ok
=
SetEvent
(
stm
-
>
shutdown_event
)
;
if
(
!
ok
)
{
LOG
(
"
Destroy
SetEvent
failed
:
%
d
\
n
"
GetLastError
(
)
)
;
}
DWORD
r
=
WaitForSingleObject
(
stm
-
>
thread
INFINITE
)
;
if
(
r
=
=
WAIT_FAILED
)
{
LOG
(
"
Destroy
WaitForSingleObject
on
thread
failed
:
%
d
\
n
"
GetLastError
(
)
)
;
}
CloseHandle
(
stm
-
>
thread
)
;
stm
-
>
thread
=
NULL
;
CloseHandle
(
stm
-
>
shutdown_event
)
;
stm
-
>
shutdown_event
=
0
;
}
void
wasapi_destroy
(
cubeb
*
context
)
{
if
(
context
-
>
mmcss_module
)
{
FreeLibrary
(
context
-
>
mmcss_module
)
;
}
free
(
context
)
;
}
char
const
*
wasapi_get_backend_id
(
cubeb
*
context
)
{
return
"
wasapi
"
;
}
int
wasapi_get_max_channel_count
(
cubeb
*
ctx
uint32_t
*
max_channels
)
{
HRESULT
hr
;
IAudioClient
*
client
;
WAVEFORMATEX
*
mix_format
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
XASSERT
(
ctx
&
&
max_channels
)
;
IMMDevice
*
device
;
hr
=
get_default_endpoint
(
&
device
eRender
)
;
if
(
FAILED
(
hr
)
)
{
return
CUBEB_ERROR
;
}
hr
=
device
-
>
Activate
(
__uuidof
(
IAudioClient
)
CLSCTX_INPROC_SERVER
NULL
(
void
*
*
)
&
client
)
;
SafeRelease
(
device
)
;
if
(
FAILED
(
hr
)
)
{
return
CUBEB_ERROR
;
}
hr
=
client
-
>
GetMixFormat
(
&
mix_format
)
;
if
(
FAILED
(
hr
)
)
{
SafeRelease
(
client
)
;
return
CUBEB_ERROR
;
}
*
max_channels
=
mix_format
-
>
nChannels
;
CoTaskMemFree
(
mix_format
)
;
SafeRelease
(
client
)
;
return
CUBEB_OK
;
}
int
wasapi_get_min_latency
(
cubeb
*
ctx
cubeb_stream_params
params
uint32_t
*
latency_ms
)
{
HRESULT
hr
;
IAudioClient
*
client
;
REFERENCE_TIME
default_period
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
if
(
params
.
format
!
=
CUBEB_SAMPLE_FLOAT32NE
)
{
return
CUBEB_ERROR_INVALID_FORMAT
;
}
IMMDevice
*
device
;
hr
=
get_default_endpoint
(
&
device
eRender
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
default
endpoint
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
hr
=
device
-
>
Activate
(
__uuidof
(
IAudioClient
)
CLSCTX_INPROC_SERVER
NULL
(
void
*
*
)
&
client
)
;
SafeRelease
(
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
activate
device
for
latency
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
hr
=
client
-
>
GetDevicePeriod
(
&
default_period
NULL
)
;
if
(
FAILED
(
hr
)
)
{
SafeRelease
(
client
)
;
LOG
(
"
Could
not
get
device
period
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
LOG
(
"
default
device
period
:
%
lld
\
n
"
default_period
)
;
*
latency_ms
=
hns_to_ms
(
default_period
)
;
SafeRelease
(
client
)
;
return
CUBEB_OK
;
}
int
wasapi_get_preferred_sample_rate
(
cubeb
*
ctx
uint32_t
*
rate
)
{
HRESULT
hr
;
IAudioClient
*
client
;
WAVEFORMATEX
*
mix_format
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
IMMDevice
*
device
;
hr
=
get_default_endpoint
(
&
device
eRender
)
;
if
(
FAILED
(
hr
)
)
{
return
CUBEB_ERROR
;
}
hr
=
device
-
>
Activate
(
__uuidof
(
IAudioClient
)
CLSCTX_INPROC_SERVER
NULL
(
void
*
*
)
&
client
)
;
SafeRelease
(
device
)
;
if
(
FAILED
(
hr
)
)
{
return
CUBEB_ERROR
;
}
hr
=
client
-
>
GetMixFormat
(
&
mix_format
)
;
if
(
FAILED
(
hr
)
)
{
SafeRelease
(
client
)
;
return
CUBEB_ERROR
;
}
*
rate
=
mix_format
-
>
nSamplesPerSec
;
CoTaskMemFree
(
mix_format
)
;
SafeRelease
(
client
)
;
return
CUBEB_OK
;
}
void
wasapi_stream_destroy
(
cubeb_stream
*
stm
)
;
static
void
handle_channel_layout
(
cubeb_stream
*
stm
WAVEFORMATEX
*
*
mix_format
const
cubeb_stream_params
*
stream_params
)
{
if
(
(
*
mix_format
)
-
>
nChannels
<
=
2
)
{
return
;
}
if
(
(
*
mix_format
)
-
>
wFormatTag
!
=
WAVE_FORMAT_EXTENSIBLE
)
{
return
;
}
WAVEFORMATEXTENSIBLE
*
format_pcm
=
reinterpret_cast
<
WAVEFORMATEXTENSIBLE
*
>
(
*
mix_format
)
;
WAVEFORMATEXTENSIBLE
hw_mix_format
=
*
format_pcm
;
switch
(
stream_params
-
>
channels
)
{
case
1
:
format_pcm
-
>
dwChannelMask
=
KSAUDIO_SPEAKER_MONO
;
break
;
case
2
:
format_pcm
-
>
dwChannelMask
=
KSAUDIO_SPEAKER_STEREO
;
break
;
default
:
XASSERT
(
false
&
&
"
Channel
layout
not
supported
.
"
)
;
break
;
}
(
*
mix_format
)
-
>
nChannels
=
stream_params
-
>
channels
;
(
*
mix_format
)
-
>
nBlockAlign
=
(
(
*
mix_format
)
-
>
wBitsPerSample
*
(
*
mix_format
)
-
>
nChannels
)
/
8
;
(
*
mix_format
)
-
>
nAvgBytesPerSec
=
(
*
mix_format
)
-
>
nSamplesPerSec
*
(
*
mix_format
)
-
>
nBlockAlign
;
format_pcm
-
>
SubFormat
=
KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
;
(
*
mix_format
)
-
>
wBitsPerSample
=
32
;
format_pcm
-
>
Samples
.
wValidBitsPerSample
=
(
*
mix_format
)
-
>
wBitsPerSample
;
WAVEFORMATEX
*
closest
;
HRESULT
hr
=
stm
-
>
output_client
-
>
IsFormatSupported
(
AUDCLNT_SHAREMODE_SHARED
*
mix_format
&
closest
)
;
if
(
hr
=
=
S_FALSE
)
{
LOG
(
"
Using
WASAPI
suggested
format
:
channels
:
%
d
\
n
"
closest
-
>
nChannels
)
;
WAVEFORMATEXTENSIBLE
*
closest_pcm
=
reinterpret_cast
<
WAVEFORMATEXTENSIBLE
*
>
(
closest
)
;
XASSERT
(
closest_pcm
-
>
SubFormat
=
=
format_pcm
-
>
SubFormat
)
;
CoTaskMemFree
(
*
mix_format
)
;
*
mix_format
=
closest
;
}
else
if
(
hr
=
=
AUDCLNT_E_UNSUPPORTED_FORMAT
)
{
*
reinterpret_cast
<
WAVEFORMATEXTENSIBLE
*
>
(
*
mix_format
)
=
hw_mix_format
;
}
else
if
(
hr
=
=
S_OK
)
{
LOG
(
"
Requested
format
accepted
by
WASAPI
.
\
n
"
)
;
}
else
{
LOG
(
"
IsFormatSupported
unhandled
error
:
%
x
\
n
"
hr
)
;
}
}
#
define
DIRECTION_NAME
(
direction
=
=
eCapture
?
"
capture
"
:
"
render
"
)
template
<
typename
T
>
int
setup_wasapi_stream_one_side
(
cubeb_stream
*
stm
cubeb_stream_params
*
stream_params
cubeb_devid
devid
EDataFlow
direction
REFIID
riid
IAudioClient
*
*
audio_client
uint32_t
*
buffer_frame_count
HANDLE
&
event
T
*
*
render_or_capture_client
cubeb_stream_params
*
mix_params
)
{
IMMDevice
*
device
;
WAVEFORMATEX
*
mix_format
;
HRESULT
hr
;
stm
-
>
stream_reset_lock
-
>
assert_current_thread_owns
(
)
;
if
(
devid
)
{
std
:
:
unique_ptr
<
const
wchar_t
>
id
;
id
.
reset
(
utf8_to_wstr
(
reinterpret_cast
<
char
*
>
(
devid
)
)
)
;
hr
=
get_endpoint
(
&
device
id
.
get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
%
s
endpoint
error
:
%
x
\
n
"
DIRECTION_NAME
hr
)
;
return
CUBEB_ERROR
;
}
}
else
{
hr
=
get_default_endpoint
(
&
device
direction
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
default
%
s
endpoint
error
:
%
x
\
n
"
DIRECTION_NAME
hr
)
;
return
CUBEB_ERROR
;
}
}
hr
=
device
-
>
Activate
(
__uuidof
(
IAudioClient
)
CLSCTX_INPROC_SERVER
NULL
(
void
*
*
)
audio_client
)
;
SafeRelease
(
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
activate
the
device
to
get
an
audio
"
"
client
for
%
s
:
error
:
%
x
\
n
"
DIRECTION_NAME
hr
)
;
return
CUBEB_ERROR
;
}
hr
=
(
*
audio_client
)
-
>
GetMixFormat
(
&
mix_format
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
fetch
current
mix
format
from
the
audio
"
"
client
for
%
s
:
error
:
%
x
\
n
"
DIRECTION_NAME
hr
)
;
return
CUBEB_ERROR
;
}
handle_channel_layout
(
stm
&
mix_format
stream_params
)
;
mix_params
-
>
format
=
CUBEB_SAMPLE_FLOAT32NE
;
mix_params
-
>
rate
=
mix_format
-
>
nSamplesPerSec
;
mix_params
-
>
channels
=
mix_format
-
>
nChannels
;
LOG
(
"
Setup
requested
=
[
f
=
%
d
r
=
%
u
c
=
%
u
]
mix
=
[
f
=
%
d
r
=
%
u
c
=
%
u
]
\
n
"
stream_params
-
>
format
stream_params
-
>
rate
stream_params
-
>
channels
mix_params
-
>
format
mix_params
-
>
rate
mix_params
-
>
channels
)
;
hr
=
(
*
audio_client
)
-
>
Initialize
(
AUDCLNT_SHAREMODE_SHARED
AUDCLNT_STREAMFLAGS_EVENTCALLBACK
|
AUDCLNT_STREAMFLAGS_NOPERSIST
ms_to_hns
(
stm
-
>
latency
)
0
mix_format
NULL
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Unable
to
initialize
audio
client
for
%
s
:
%
x
.
\
n
"
DIRECTION_NAME
hr
)
;
return
CUBEB_ERROR
;
}
CoTaskMemFree
(
mix_format
)
;
hr
=
(
*
audio_client
)
-
>
GetBufferSize
(
buffer_frame_count
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
the
buffer
size
from
the
client
"
"
for
%
s
%
x
.
\
n
"
DIRECTION_NAME
hr
)
;
return
CUBEB_ERROR
;
}
if
(
has_output
(
stm
)
&
&
(
should_upmix
(
*
stream_params
*
mix_params
)
|
|
should_downmix
(
*
stream_params
*
mix_params
)
)
)
{
stm
-
>
mix_buffer
=
(
float
*
)
malloc
(
frames_to_bytes_before_mix
(
stm
*
buffer_frame_count
)
)
;
}
hr
=
(
*
audio_client
)
-
>
SetEventHandle
(
event
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
set
the
event
handle
for
the
%
s
client
%
x
.
\
n
"
DIRECTION_NAME
hr
)
;
return
CUBEB_ERROR
;
}
hr
=
(
*
audio_client
)
-
>
GetService
(
riid
(
void
*
*
)
render_or_capture_client
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
the
%
s
client
%
x
.
\
n
"
DIRECTION_NAME
hr
)
;
return
CUBEB_ERROR
;
}
return
CUBEB_OK
;
}
#
undef
DIRECTION_NAME
int
setup_wasapi_stream
(
cubeb_stream
*
stm
)
{
HRESULT
hr
;
int
rv
;
stm
-
>
stream_reset_lock
-
>
assert_current_thread_owns
(
)
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
XASSERT
(
!
stm
-
>
output_client
&
&
"
WASAPI
stream
already
setup
close
it
first
.
"
)
;
if
(
has_input
(
stm
)
)
{
LOG
(
"
Setup
capture
:
device
=
%
x
\
n
"
(
int
)
stm
-
>
input_device
)
;
rv
=
setup_wasapi_stream_one_side
(
stm
&
stm
-
>
input_stream_params
stm
-
>
input_device
eCapture
__uuidof
(
IAudioCaptureClient
)
&
stm
-
>
input_client
&
stm
-
>
input_buffer_frame_count
stm
-
>
input_available_event
&
stm
-
>
capture_client
&
stm
-
>
input_mix_params
)
;
if
(
rv
!
=
CUBEB_OK
)
{
return
rv
;
}
}
if
(
has_output
(
stm
)
)
{
LOG
(
"
Setup
render
:
device
=
%
x
\
n
"
(
int
)
stm
-
>
output_device
)
;
rv
=
setup_wasapi_stream_one_side
(
stm
&
stm
-
>
output_stream_params
stm
-
>
output_device
eRender
__uuidof
(
IAudioRenderClient
)
&
stm
-
>
output_client
&
stm
-
>
output_buffer_frame_count
stm
-
>
refill_event
&
stm
-
>
render_client
&
stm
-
>
output_mix_params
)
;
if
(
rv
!
=
CUBEB_OK
)
{
return
rv
;
}
hr
=
stm
-
>
output_client
-
>
GetService
(
__uuidof
(
IAudioStreamVolume
)
(
void
*
*
)
&
stm
-
>
audio_stream_volume
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
the
IAudioStreamVolume
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
XASSERT
(
stm
-
>
frames_written
=
=
0
)
;
hr
=
stm
-
>
output_client
-
>
GetService
(
__uuidof
(
IAudioClock
)
(
void
*
*
)
&
stm
-
>
audio_clock
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
the
IAudioClock
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
if
(
stream_set_volume
(
stm
stm
-
>
volume
)
!
=
CUBEB_OK
)
{
return
CUBEB_ERROR
;
}
}
int32_t
target_sample_rate
;
if
(
has_input
(
stm
)
&
&
has_output
(
stm
)
)
{
assert
(
stm
-
>
input_stream_params
.
rate
=
=
stm
-
>
output_stream_params
.
rate
)
;
target_sample_rate
=
stm
-
>
input_stream_params
.
rate
;
}
else
if
(
has_input
(
stm
)
)
{
target_sample_rate
=
stm
-
>
input_stream_params
.
rate
;
}
else
{
XASSERT
(
has_output
(
stm
)
)
;
target_sample_rate
=
stm
-
>
output_stream_params
.
rate
;
}
cubeb_stream_params
input_params
=
stm
-
>
input_mix_params
;
input_params
.
channels
=
stm
-
>
input_stream_params
.
channels
;
cubeb_stream_params
output_params
=
stm
-
>
output_mix_params
;
output_params
.
channels
=
stm
-
>
output_stream_params
.
channels
;
stm
-
>
resampler
=
cubeb_resampler_create
(
stm
has_input
(
stm
)
?
&
input_params
:
nullptr
has_output
(
stm
)
?
&
output_params
:
nullptr
target_sample_rate
stm
-
>
data_callback
stm
-
>
user_ptr
CUBEB_RESAMPLER_QUALITY_DESKTOP
)
;
if
(
!
stm
-
>
resampler
)
{
LOG
(
"
Could
not
get
a
resampler
\
n
"
)
;
return
CUBEB_ERROR
;
}
XASSERT
(
has_input
(
stm
)
|
|
has_output
(
stm
)
)
;
if
(
has_input
(
stm
)
&
&
has_output
(
stm
)
)
{
stm
-
>
refill_callback
=
refill_callback_duplex
;
}
else
if
(
has_input
(
stm
)
)
{
stm
-
>
refill_callback
=
refill_callback_input
;
}
else
if
(
has_output
(
stm
)
)
{
stm
-
>
refill_callback
=
refill_callback_output
;
}
return
CUBEB_OK
;
}
int
wasapi_stream_init
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
{
HRESULT
hr
;
int
rv
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
XASSERT
(
context
&
&
stream
)
;
if
(
output_stream_params
&
&
output_stream_params
-
>
format
!
=
CUBEB_SAMPLE_FLOAT32NE
|
|
input_stream_params
&
&
input_stream_params
-
>
format
!
=
CUBEB_SAMPLE_FLOAT32NE
)
{
return
CUBEB_ERROR_INVALID_FORMAT
;
}
cubeb_stream
*
stm
=
(
cubeb_stream
*
)
calloc
(
1
sizeof
(
cubeb_stream
)
)
;
XASSERT
(
stm
)
;
stm
-
>
context
=
context
;
stm
-
>
data_callback
=
data_callback
;
stm
-
>
state_callback
=
state_callback
;
stm
-
>
user_ptr
=
user_ptr
;
stm
-
>
draining
=
false
;
if
(
input_stream_params
)
{
stm
-
>
input_stream_params
=
*
input_stream_params
;
stm
-
>
input_device
=
input_device
;
}
if
(
output_stream_params
)
{
stm
-
>
output_stream_params
=
*
output_stream_params
;
stm
-
>
output_device
=
output_device
;
}
stm
-
>
latency
=
latency
;
stm
-
>
volume
=
1
.
0
;
stm
-
>
stream_reset_lock
=
new
owned_critical_section
(
)
;
stm
-
>
reconfigure_event
=
CreateEvent
(
NULL
0
0
NULL
)
;
if
(
!
stm
-
>
reconfigure_event
)
{
LOG
(
"
Can
'
t
create
the
reconfigure
event
error
:
%
x
\
n
"
GetLastError
(
)
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
stm
-
>
refill_event
=
CreateEvent
(
NULL
0
0
NULL
)
;
if
(
!
stm
-
>
refill_event
)
{
LOG
(
"
Can
'
t
create
the
refill
event
error
:
%
x
\
n
"
GetLastError
(
)
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
stm
-
>
input_available_event
=
CreateEvent
(
NULL
0
0
NULL
)
;
if
(
!
stm
-
>
input_available_event
)
{
LOG
(
"
Can
'
t
create
the
input
available
event
error
:
%
x
\
n
"
GetLastError
(
)
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
rv
=
setup_wasapi_stream
(
stm
)
;
}
if
(
rv
!
=
CUBEB_OK
)
{
wasapi_stream_destroy
(
stm
)
;
return
rv
;
}
hr
=
register_notification_client
(
stm
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
failed
to
register
notification
client
%
x
\
n
"
hr
)
;
}
*
stream
=
stm
;
return
CUBEB_OK
;
}
void
close_wasapi_stream
(
cubeb_stream
*
stm
)
{
XASSERT
(
stm
)
;
stm
-
>
stream_reset_lock
-
>
assert_current_thread_owns
(
)
;
SafeRelease
(
stm
-
>
output_client
)
;
stm
-
>
output_client
=
NULL
;
SafeRelease
(
stm
-
>
input_client
)
;
stm
-
>
capture_client
=
NULL
;
SafeRelease
(
stm
-
>
render_client
)
;
stm
-
>
render_client
=
NULL
;
SafeRelease
(
stm
-
>
audio_stream_volume
)
;
stm
-
>
audio_stream_volume
=
NULL
;
SafeRelease
(
stm
-
>
audio_clock
)
;
stm
-
>
audio_clock
=
NULL
;
stm
-
>
total_frames_written
+
=
static_cast
<
UINT64
>
(
round
(
stm
-
>
frames_written
*
stream_to_mix_samplerate_ratio
(
stm
-
>
output_stream_params
stm
-
>
output_mix_params
)
)
)
;
stm
-
>
frames_written
=
0
;
if
(
stm
-
>
resampler
)
{
cubeb_resampler_destroy
(
stm
-
>
resampler
)
;
stm
-
>
resampler
=
NULL
;
}
free
(
stm
-
>
mix_buffer
)
;
stm
-
>
mix_buffer
=
NULL
;
}
void
wasapi_stream_destroy
(
cubeb_stream
*
stm
)
{
XASSERT
(
stm
)
;
stop_and_join_render_thread
(
stm
)
;
unregister_notification_client
(
stm
)
;
SafeRelease
(
stm
-
>
reconfigure_event
)
;
SafeRelease
(
stm
-
>
refill_event
)
;
SafeRelease
(
stm
-
>
input_available_event
)
;
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
close_wasapi_stream
(
stm
)
;
}
delete
stm
-
>
stream_reset_lock
;
free
(
stm
)
;
}
enum
StreamDirection
{
OUTPUT
INPUT
}
;
int
stream_start_one_side
(
cubeb_stream
*
stm
StreamDirection
dir
)
{
XASSERT
(
(
dir
=
=
OUTPUT
&
&
stm
-
>
output_client
)
|
|
(
dir
=
=
INPUT
&
&
stm
-
>
input_client
)
)
;
HRESULT
hr
=
dir
=
=
OUTPUT
?
stm
-
>
output_client
-
>
Start
(
)
:
stm
-
>
input_client
-
>
Start
(
)
;
if
(
hr
=
=
AUDCLNT_E_DEVICE_INVALIDATED
)
{
LOG
(
"
audioclient
invalidated
for
%
s
device
reconfiguring
\
n
"
dir
=
=
OUTPUT
?
"
output
"
:
"
input
"
)
;
BOOL
ok
=
ResetEvent
(
stm
-
>
reconfigure_event
)
;
if
(
!
ok
)
{
LOG
(
"
resetting
reconfig
event
failed
for
%
s
stream
:
%
x
\
n
"
dir
=
=
OUTPUT
?
"
output
"
:
"
input
"
GetLastError
(
)
)
;
}
close_wasapi_stream
(
stm
)
;
int
r
=
setup_wasapi_stream
(
stm
)
;
if
(
r
!
=
CUBEB_OK
)
{
LOG
(
"
reconfigure
failed
\
n
"
)
;
return
r
;
}
HRESULT
hr
=
dir
=
=
OUTPUT
?
stm
-
>
output_client
-
>
Start
(
)
:
stm
-
>
input_client
-
>
Start
(
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
could
not
start
the
%
s
stream
after
reconfig
:
%
x
\
n
"
dir
=
=
OUTPUT
?
"
output
"
:
"
input
"
hr
)
;
return
CUBEB_ERROR
;
}
}
else
if
(
FAILED
(
hr
)
)
{
LOG
(
"
could
not
start
the
%
s
stream
:
%
x
.
\
n
"
dir
=
=
OUTPUT
?
"
output
"
:
"
input
"
hr
)
;
return
CUBEB_ERROR
;
}
return
CUBEB_OK
;
}
int
wasapi_stream_start
(
cubeb_stream
*
stm
)
{
int
rv
;
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
XASSERT
(
stm
&
&
!
stm
-
>
thread
&
&
!
stm
-
>
shutdown_event
)
;
if
(
stm
-
>
output_client
)
{
rv
=
stream_start_one_side
(
stm
OUTPUT
)
;
if
(
rv
!
=
CUBEB_OK
)
{
return
rv
;
}
}
if
(
stm
-
>
input_client
)
{
rv
=
stream_start_one_side
(
stm
INPUT
)
;
if
(
rv
!
=
CUBEB_OK
)
{
return
rv
;
}
}
stm
-
>
shutdown_event
=
CreateEvent
(
NULL
0
0
NULL
)
;
if
(
!
stm
-
>
shutdown_event
)
{
LOG
(
"
Can
'
t
create
the
shutdown
event
error
:
%
x
\
n
"
GetLastError
(
)
)
;
return
CUBEB_ERROR
;
}
stm
-
>
thread
=
(
HANDLE
)
_beginthreadex
(
NULL
256
*
1024
wasapi_stream_render_loop
stm
STACK_SIZE_PARAM_IS_A_RESERVATION
NULL
)
;
if
(
stm
-
>
thread
=
=
NULL
)
{
LOG
(
"
could
not
create
WASAPI
render
thread
.
\
n
"
)
;
return
CUBEB_ERROR
;
}
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_STARTED
)
;
return
CUBEB_OK
;
}
int
wasapi_stream_stop
(
cubeb_stream
*
stm
)
{
XASSERT
(
stm
)
;
HRESULT
hr
;
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
if
(
stm
-
>
output_client
)
{
hr
=
stm
-
>
output_client
-
>
Stop
(
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
could
not
stop
AudioClient
(
output
)
\
n
"
)
;
return
CUBEB_ERROR
;
}
}
if
(
stm
-
>
input_client
)
{
hr
=
stm
-
>
input_client
-
>
Stop
(
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
could
not
stop
AudioClient
(
input
)
\
n
"
)
;
return
CUBEB_ERROR
;
}
}
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_STOPPED
)
;
}
stop_and_join_render_thread
(
stm
)
;
return
CUBEB_OK
;
}
int
wasapi_stream_get_position
(
cubeb_stream
*
stm
uint64_t
*
position
)
{
XASSERT
(
stm
&
&
position
)
;
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
if
(
!
has_output
(
stm
)
)
{
return
CUBEB_ERROR
;
}
uint64_t
stream_delay
=
static_cast
<
uint64_t
>
(
current_stream_delay
(
stm
)
*
stm
-
>
output_stream_params
.
rate
)
;
uint64_t
max_pos
=
stm
-
>
total_frames_written
+
static_cast
<
uint64_t
>
(
round
(
stm
-
>
frames_written
*
stream_to_mix_samplerate_ratio
(
stm
-
>
output_stream_params
stm
-
>
output_mix_params
)
)
)
;
*
position
=
max_pos
;
if
(
stream_delay
<
=
*
position
)
{
*
position
-
=
stream_delay
;
}
if
(
*
position
<
stm
-
>
prev_position
)
{
*
position
=
stm
-
>
prev_position
;
}
stm
-
>
prev_position
=
*
position
;
return
CUBEB_OK
;
}
int
wasapi_stream_get_latency
(
cubeb_stream
*
stm
uint32_t
*
latency
)
{
XASSERT
(
stm
&
&
latency
)
;
if
(
!
has_output
(
stm
)
)
{
return
CUBEB_ERROR
;
}
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
if
(
!
stm
-
>
output_client
)
{
return
CUBEB_ERROR
;
}
REFERENCE_TIME
latency_hns
;
HRESULT
hr
=
stm
-
>
output_client
-
>
GetStreamLatency
(
&
latency_hns
)
;
if
(
FAILED
(
hr
)
)
{
return
CUBEB_ERROR
;
}
double
latency_s
=
hns_to_s
(
latency_hns
)
;
*
latency
=
static_cast
<
uint32_t
>
(
latency_s
*
stm
-
>
output_stream_params
.
rate
)
;
return
CUBEB_OK
;
}
int
wasapi_stream_set_volume
(
cubeb_stream
*
stm
float
volume
)
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
if
(
!
has_output
(
stm
)
)
{
return
CUBEB_ERROR
;
}
if
(
stream_set_volume
(
stm
volume
)
!
=
CUBEB_OK
)
{
return
CUBEB_ERROR
;
}
stm
-
>
volume
=
volume
;
return
CUBEB_OK
;
}
static
char
*
wstr_to_utf8
(
LPCWSTR
str
)
{
char
*
ret
=
NULL
;
int
size
;
size
=
:
:
WideCharToMultiByte
(
CP_UTF8
0
str
-
1
ret
0
NULL
NULL
)
;
if
(
size
>
0
)
{
ret
=
new
char
[
size
]
;
:
:
WideCharToMultiByte
(
CP_UTF8
0
str
-
1
ret
size
NULL
NULL
)
;
}
return
ret
;
}
static
const
wchar_t
*
utf8_to_wstr
(
char
*
str
)
{
wchar_t
*
ret
=
nullptr
;
int
size
;
size
=
:
:
MultiByteToWideChar
(
CP_UTF8
0
str
-
1
ret
0
)
;
if
(
size
>
0
)
{
ret
=
new
wchar_t
[
size
]
;
:
:
MultiByteToWideChar
(
CP_UTF8
0
str
-
1
ret
size
)
;
}
return
ret
;
}
static
IMMDevice
*
wasapi_get_device_node
(
IMMDeviceEnumerator
*
enumerator
IMMDevice
*
dev
)
{
IMMDevice
*
ret
=
NULL
;
IDeviceTopology
*
devtopo
=
NULL
;
IConnector
*
connector
=
NULL
;
if
(
SUCCEEDED
(
dev
-
>
Activate
(
__uuidof
(
IDeviceTopology
)
CLSCTX_ALL
NULL
(
void
*
*
)
&
devtopo
)
)
&
&
SUCCEEDED
(
devtopo
-
>
GetConnector
(
0
&
connector
)
)
)
{
LPWSTR
filterid
;
if
(
SUCCEEDED
(
connector
-
>
GetDeviceIdConnectedTo
(
&
filterid
)
)
)
{
if
(
FAILED
(
enumerator
-
>
GetDevice
(
filterid
&
ret
)
)
)
ret
=
NULL
;
CoTaskMemFree
(
filterid
)
;
}
}
SafeRelease
(
connector
)
;
SafeRelease
(
devtopo
)
;
return
ret
;
}
static
BOOL
wasapi_is_default_device
(
EDataFlow
flow
ERole
role
LPCWSTR
device_id
IMMDeviceEnumerator
*
enumerator
)
{
BOOL
ret
=
FALSE
;
IMMDevice
*
dev
;
HRESULT
hr
;
hr
=
enumerator
-
>
GetDefaultAudioEndpoint
(
flow
role
&
dev
)
;
if
(
SUCCEEDED
(
hr
)
)
{
LPWSTR
defdevid
=
NULL
;
if
(
SUCCEEDED
(
dev
-
>
GetId
(
&
defdevid
)
)
)
ret
=
(
wcscmp
(
defdevid
device_id
)
=
=
0
)
;
if
(
defdevid
!
=
NULL
)
CoTaskMemFree
(
defdevid
)
;
SafeRelease
(
dev
)
;
}
return
ret
;
}
static
cubeb_device_info
*
wasapi_create_device
(
IMMDeviceEnumerator
*
enumerator
IMMDevice
*
dev
)
{
IMMEndpoint
*
endpoint
=
NULL
;
IMMDevice
*
devnode
=
NULL
;
IAudioClient
*
client
=
NULL
;
cubeb_device_info
*
ret
=
NULL
;
EDataFlow
flow
;
LPWSTR
device_id
=
NULL
;
DWORD
state
=
DEVICE_STATE_NOTPRESENT
;
IPropertyStore
*
propstore
=
NULL
;
PROPVARIANT
propvar
;
REFERENCE_TIME
def_period
min_period
;
HRESULT
hr
;
PropVariantInit
(
&
propvar
)
;
hr
=
dev
-
>
QueryInterface
(
IID_PPV_ARGS
(
&
endpoint
)
)
;
if
(
FAILED
(
hr
)
)
goto
done
;
hr
=
endpoint
-
>
GetDataFlow
(
&
flow
)
;
if
(
FAILED
(
hr
)
)
goto
done
;
hr
=
dev
-
>
GetId
(
&
device_id
)
;
if
(
FAILED
(
hr
)
)
goto
done
;
hr
=
dev
-
>
OpenPropertyStore
(
STGM_READ
&
propstore
)
;
if
(
FAILED
(
hr
)
)
goto
done
;
hr
=
dev
-
>
GetState
(
&
state
)
;
if
(
FAILED
(
hr
)
)
goto
done
;
ret
=
(
cubeb_device_info
*
)
calloc
(
1
sizeof
(
cubeb_device_info
)
)
;
ret
-
>
devid
=
ret
-
>
device_id
=
wstr_to_utf8
(
device_id
)
;
hr
=
propstore
-
>
GetValue
(
PKEY_Device_FriendlyName
&
propvar
)
;
if
(
SUCCEEDED
(
hr
)
)
ret
-
>
friendly_name
=
wstr_to_utf8
(
propvar
.
pwszVal
)
;
devnode
=
wasapi_get_device_node
(
enumerator
dev
)
;
if
(
devnode
!
=
NULL
)
{
IPropertyStore
*
ps
=
NULL
;
hr
=
devnode
-
>
OpenPropertyStore
(
STGM_READ
&
ps
)
;
if
(
FAILED
(
hr
)
)
goto
done
;
PropVariantClear
(
&
propvar
)
;
hr
=
ps
-
>
GetValue
(
PKEY_Device_InstanceId
&
propvar
)
;
if
(
SUCCEEDED
(
hr
)
)
{
ret
-
>
group_id
=
wstr_to_utf8
(
propvar
.
pwszVal
)
;
}
SafeRelease
(
ps
)
;
}
ret
-
>
preferred
=
CUBEB_DEVICE_PREF_NONE
;
if
(
wasapi_is_default_device
(
flow
eConsole
device_id
enumerator
)
)
ret
-
>
preferred
=
(
cubeb_device_pref
)
(
ret
-
>
preferred
|
CUBEB_DEVICE_PREF_MULTIMEDIA
)
;
if
(
wasapi_is_default_device
(
flow
eCommunications
device_id
enumerator
)
)
ret
-
>
preferred
=
(
cubeb_device_pref
)
(
ret
-
>
preferred
|
CUBEB_DEVICE_PREF_VOICE
)
;
if
(
wasapi_is_default_device
(
flow
eConsole
device_id
enumerator
)
)
ret
-
>
preferred
=
(
cubeb_device_pref
)
(
ret
-
>
preferred
|
CUBEB_DEVICE_PREF_NOTIFICATION
)
;
if
(
flow
=
=
eRender
)
ret
-
>
type
=
CUBEB_DEVICE_TYPE_OUTPUT
;
else
if
(
flow
=
=
eCapture
)
ret
-
>
type
=
CUBEB_DEVICE_TYPE_INPUT
;
switch
(
state
)
{
case
DEVICE_STATE_ACTIVE
:
ret
-
>
state
=
CUBEB_DEVICE_STATE_ENABLED
;
break
;
case
DEVICE_STATE_UNPLUGGED
:
ret
-
>
state
=
CUBEB_DEVICE_STATE_UNPLUGGED
;
break
;
default
:
ret
-
>
state
=
CUBEB_DEVICE_STATE_DISABLED
;
break
;
}
;
ret
-
>
format
=
CUBEB_DEVICE_FMT_F32NE
;
ret
-
>
default_format
=
CUBEB_DEVICE_FMT_F32NE
;
PropVariantClear
(
&
propvar
)
;
hr
=
propstore
-
>
GetValue
(
PKEY_AudioEngine_DeviceFormat
&
propvar
)
;
if
(
SUCCEEDED
(
hr
)
&
&
propvar
.
vt
=
=
VT_BLOB
)
{
if
(
propvar
.
blob
.
cbSize
=
=
sizeof
(
PCMWAVEFORMAT
)
)
{
const
PCMWAVEFORMAT
*
pcm
=
reinterpret_cast
<
const
PCMWAVEFORMAT
*
>
(
propvar
.
blob
.
pBlobData
)
;
ret
-
>
max_rate
=
ret
-
>
min_rate
=
ret
-
>
default_rate
=
pcm
-
>
wf
.
nSamplesPerSec
;
ret
-
>
max_channels
=
pcm
-
>
wf
.
nChannels
;
}
else
if
(
propvar
.
blob
.
cbSize
>
=
sizeof
(
WAVEFORMATEX
)
)
{
WAVEFORMATEX
*
wfx
=
reinterpret_cast
<
WAVEFORMATEX
*
>
(
propvar
.
blob
.
pBlobData
)
;
if
(
propvar
.
blob
.
cbSize
>
=
sizeof
(
WAVEFORMATEX
)
+
wfx
-
>
cbSize
|
|
wfx
-
>
wFormatTag
=
=
WAVE_FORMAT_PCM
)
{
ret
-
>
max_rate
=
ret
-
>
min_rate
=
ret
-
>
default_rate
=
wfx
-
>
nSamplesPerSec
;
ret
-
>
max_channels
=
wfx
-
>
nChannels
;
}
}
}
if
(
SUCCEEDED
(
dev
-
>
Activate
(
__uuidof
(
IAudioClient
)
CLSCTX_INPROC_SERVER
NULL
(
void
*
*
)
&
client
)
)
&
&
SUCCEEDED
(
client
-
>
GetDevicePeriod
(
&
def_period
&
min_period
)
)
)
{
ret
-
>
latency_lo_ms
=
hns_to_ms
(
min_period
)
;
ret
-
>
latency_hi_ms
=
hns_to_ms
(
def_period
)
;
}
else
{
ret
-
>
latency_lo_ms
=
0
;
ret
-
>
latency_hi_ms
=
0
;
}
SafeRelease
(
client
)
;
done
:
SafeRelease
(
devnode
)
;
SafeRelease
(
endpoint
)
;
SafeRelease
(
propstore
)
;
if
(
device_id
!
=
NULL
)
CoTaskMemFree
(
device_id
)
;
PropVariantClear
(
&
propvar
)
;
return
ret
;
}
static
int
wasapi_enumerate_devices
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
*
out
)
{
auto_com
com
;
IMMDeviceEnumerator
*
enumerator
;
IMMDeviceCollection
*
collection
;
IMMDevice
*
dev
;
cubeb_device_info
*
cur
;
HRESULT
hr
;
UINT
cc
i
;
EDataFlow
flow
;
*
out
=
NULL
;
if
(
!
com
.
ok
(
)
)
return
CUBEB_ERROR
;
hr
=
CoCreateInstance
(
__uuidof
(
MMDeviceEnumerator
)
NULL
CLSCTX_INPROC_SERVER
IID_PPV_ARGS
(
&
enumerator
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
device
enumerator
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
if
(
type
=
=
CUBEB_DEVICE_TYPE_OUTPUT
)
flow
=
eRender
;
else
if
(
type
=
=
CUBEB_DEVICE_TYPE_INPUT
)
flow
=
eCapture
;
else
if
(
type
&
(
CUBEB_DEVICE_TYPE_INPUT
|
CUBEB_DEVICE_TYPE_INPUT
)
)
flow
=
eAll
;
else
return
CUBEB_ERROR
;
hr
=
enumerator
-
>
EnumAudioEndpoints
(
flow
DEVICE_STATEMASK_ALL
&
collection
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
enumerate
audio
endpoints
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
hr
=
collection
-
>
GetCount
(
&
cc
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
IMMDeviceCollection
:
:
GetCount
(
)
failed
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
*
out
=
(
cubeb_device_collection
*
)
malloc
(
sizeof
(
cubeb_device_collection
)
+
sizeof
(
cubeb_device_info
*
)
*
(
cc
>
0
?
cc
-
1
:
0
)
)
;
(
*
out
)
-
>
count
=
0
;
for
(
i
=
0
;
i
<
cc
;
i
+
+
)
{
hr
=
collection
-
>
Item
(
i
&
dev
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
IMMDeviceCollection
:
:
Item
(
%
u
)
failed
:
%
x
\
n
"
i
-
1
hr
)
;
}
else
if
(
(
cur
=
wasapi_create_device
(
enumerator
dev
)
)
!
=
NULL
)
{
(
*
out
)
-
>
device
[
(
*
out
)
-
>
count
+
+
]
=
cur
;
}
}
SafeRelease
(
collection
)
;
SafeRelease
(
enumerator
)
;
return
CUBEB_OK
;
}
cubeb_ops
const
wasapi_ops
=
{
wasapi_init
wasapi_get_backend_id
wasapi_get_max_channel_count
wasapi_get_min_latency
wasapi_get_preferred_sample_rate
wasapi_enumerate_devices
wasapi_destroy
wasapi_stream_init
wasapi_stream_destroy
wasapi_stream_start
wasapi_stream_stop
wasapi_stream_get_position
wasapi_stream_get_latency
wasapi_stream_set_volume
NULL
NULL
NULL
NULL
NULL
}
;
}
