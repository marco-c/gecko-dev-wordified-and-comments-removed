#
ifdef
NDEBUG
#
define
DEBUG
#
undef
NDEBUG
#
endif
#
if
defined
(
HAVE_CONFIG_H
)
#
include
"
config
.
h
"
#
endif
#
include
<
assert
.
h
>
#
include
<
windows
.
h
>
#
include
<
mmdeviceapi
.
h
>
#
include
<
windef
.
h
>
#
include
<
audioclient
.
h
>
#
include
<
process
.
h
>
#
include
<
avrt
.
h
>
#
include
"
cubeb
/
cubeb
.
h
"
#
include
"
cubeb
-
internal
.
h
"
#
include
"
cubeb
/
cubeb
-
stdint
.
h
"
#
include
"
cubeb_resampler
.
h
"
#
include
<
stdio
.
h
>
#
include
<
cmath
>
#
ifndef
STACK_SIZE_PARAM_IS_A_RESERVATION
#
define
STACK_SIZE_PARAM_IS_A_RESERVATION
0x00010000
/
/
Threads
only
#
endif
#
ifdef
LOGGING_ENABLED
#
define
LOG
(
.
.
.
)
do
{
\
fprintf
(
stderr
__VA_ARGS__
)
;
\
}
while
(
0
)
#
else
#
define
LOG
(
.
.
.
)
#
endif
#
define
ARRAY_LENGTH
(
array_
)
\
(
sizeof
(
array_
)
/
sizeof
(
array_
[
0
]
)
)
namespace
{
uint32_t
ms_to_hns
(
uint32_t
ms
)
{
return
ms
*
10000
;
}
uint32_t
hns_to_ms
(
uint32_t
hns
)
{
return
hns
/
10000
;
}
double
hns_to_s
(
uint32_t
hns
)
{
return
static_cast
<
double
>
(
hns
)
/
10000000
;
}
void
SafeRelease
(
HANDLE
handle
)
{
if
(
handle
)
{
CloseHandle
(
handle
)
;
}
}
template
<
typename
T
>
void
SafeRelease
(
T
*
ptr
)
{
if
(
ptr
)
{
ptr
-
>
Release
(
)
;
}
}
class
owned_critical_section
{
public
:
owned_critical_section
(
)
#
ifdef
DEBUG
:
owner
(
0
)
#
endif
{
InitializeCriticalSection
(
&
critical_section
)
;
}
~
owned_critical_section
(
)
{
DeleteCriticalSection
(
&
critical_section
)
;
}
void
enter
(
)
{
EnterCriticalSection
(
&
critical_section
)
;
#
ifdef
DEBUG
assert
(
owner
!
=
GetCurrentThreadId
(
)
&
&
"
recursive
locking
"
)
;
owner
=
GetCurrentThreadId
(
)
;
#
endif
}
void
leave
(
)
{
#
ifdef
DEBUG
owner
=
0
;
#
endif
LeaveCriticalSection
(
&
critical_section
)
;
}
void
assert_current_thread_owns
(
)
{
#
ifdef
DEBUG
assert
(
owner
=
=
GetCurrentThreadId
(
)
)
;
#
endif
}
private
:
CRITICAL_SECTION
critical_section
;
#
ifdef
DEBUG
DWORD
owner
;
#
endif
}
;
struct
auto_lock
{
auto_lock
(
owned_critical_section
*
lock
)
:
lock
(
lock
)
{
lock
-
>
enter
(
)
;
}
~
auto_lock
(
)
{
lock
-
>
leave
(
)
;
}
private
:
owned_critical_section
*
lock
;
}
;
struct
auto_com
{
auto_com
(
)
{
result
=
CoInitializeEx
(
NULL
COINIT_MULTITHREADED
)
;
}
~
auto_com
(
)
{
if
(
result
=
=
RPC_E_CHANGED_MODE
)
{
LOG
(
"
COM
already
initialized
in
STA
.
\
n
"
)
;
}
else
if
(
result
=
=
S_FALSE
)
{
LOG
(
"
COM
already
initialized
in
MTA
\
n
"
)
;
}
if
(
SUCCEEDED
(
result
)
)
{
CoUninitialize
(
)
;
}
}
bool
ok
(
)
{
return
result
=
=
RPC_E_CHANGED_MODE
|
|
SUCCEEDED
(
result
)
;
}
private
:
HRESULT
result
;
}
;
typedef
HANDLE
(
WINAPI
*
set_mm_thread_characteristics_function
)
(
const
char
*
TaskName
LPDWORD
TaskIndex
)
;
typedef
BOOL
(
WINAPI
*
revert_mm_thread_characteristics_function
)
(
HANDLE
handle
)
;
extern
cubeb_ops
const
wasapi_ops
;
int
stream_stop
(
cubeb_stream
*
stm
bool
*
was_running
)
;
int
wasapi_stream_start
(
cubeb_stream
*
stm
)
;
void
close_wasapi_stream
(
cubeb_stream
*
stm
)
;
int
setup_wasapi_stream
(
cubeb_stream
*
stm
)
;
}
struct
cubeb
{
cubeb_ops
const
*
ops
;
HMODULE
mmcss_module
;
set_mm_thread_characteristics_function
set_mm_thread_characteristics
;
revert_mm_thread_characteristics_function
revert_mm_thread_characteristics
;
}
;
class
wasapi_endpoint_notification_client
;
struct
cubeb_stream
{
cubeb
*
context
;
cubeb_stream_params
mix_params
;
cubeb_stream_params
stream_params
;
unsigned
latency
;
cubeb_state_callback
state_callback
;
cubeb_data_callback
data_callback
;
void
*
user_ptr
;
IAudioClient
*
client
;
IAudioRenderClient
*
render_client
;
IAudioStreamVolume
*
audio_stream_volume
;
IMMDeviceEnumerator
*
device_enumerator
;
wasapi_endpoint_notification_client
*
notification_client
;
HANDLE
shutdown_event
;
HANDLE
refill_event
;
HANDLE
thread
;
LONG64
clock
;
owned_critical_section
*
stream_reset_lock
;
uint32_t
buffer_frame_count
;
cubeb_resampler
*
resampler
;
float
*
mix_buffer
;
bool
draining
;
}
;
class
wasapi_endpoint_notification_client
:
public
IMMNotificationClient
{
public
:
ULONG
STDMETHODCALLTYPE
AddRef
(
)
{
return
InterlockedIncrement
(
&
ref_count
)
;
}
ULONG
STDMETHODCALLTYPE
Release
(
)
{
ULONG
ulRef
=
InterlockedDecrement
(
&
ref_count
)
;
if
(
0
=
=
ulRef
)
{
delete
this
;
}
return
ulRef
;
}
HRESULT
STDMETHODCALLTYPE
QueryInterface
(
REFIID
riid
VOID
*
*
ppvInterface
)
{
if
(
__uuidof
(
IUnknown
)
=
=
riid
)
{
AddRef
(
)
;
*
ppvInterface
=
(
IUnknown
*
)
this
;
}
else
if
(
__uuidof
(
IMMNotificationClient
)
=
=
riid
)
{
AddRef
(
)
;
*
ppvInterface
=
(
IMMNotificationClient
*
)
this
;
}
else
{
*
ppvInterface
=
NULL
;
return
E_NOINTERFACE
;
}
return
S_OK
;
}
wasapi_endpoint_notification_client
(
cubeb_stream
*
stm
)
:
ref_count
(
1
)
stm
(
stm
)
{
}
HRESULT
STDMETHODCALLTYPE
OnDefaultDeviceChanged
(
EDataFlow
flow
ERole
role
LPCWSTR
device_id
)
{
if
(
flow
!
=
eRender
&
&
role
!
=
eMultimedia
)
{
return
S_OK
;
}
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
E_FAIL
;
}
bool
was_running
;
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
stream_stop
(
stm
&
was_running
)
;
close_wasapi_stream
(
stm
)
;
setup_wasapi_stream
(
stm
)
;
}
if
(
was_running
)
{
wasapi_stream_start
(
stm
)
;
}
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
OnDeviceAdded
(
LPCWSTR
device_id
)
{
LOG
(
"
Audio
device
added
.
\
n
"
)
;
return
S_OK
;
}
;
HRESULT
STDMETHODCALLTYPE
OnDeviceRemoved
(
LPCWSTR
device_id
)
{
LOG
(
"
Audio
device
removed
.
\
n
"
)
;
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
OnDeviceStateChanged
(
LPCWSTR
device_id
DWORD
new_state
)
{
LOG
(
"
Audio
device
state
changed
.
\
n
"
)
;
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
OnPropertyValueChanged
(
LPCWSTR
device_id
const
PROPERTYKEY
key
)
{
LOG
(
"
Audio
device
property
value
changed
.
\
n
"
)
;
return
S_OK
;
}
private
:
LONG
ref_count
;
cubeb_stream
*
stm
;
}
;
namespace
{
void
clock_add
(
cubeb_stream
*
stm
LONG64
value
)
{
InterlockedExchangeAdd64
(
&
stm
-
>
clock
value
)
;
}
LONG64
clock_get
(
cubeb_stream
*
stm
)
{
return
InterlockedExchangeAdd64
(
&
stm
-
>
clock
0
)
;
}
bool
should_upmix
(
cubeb_stream
*
stream
)
{
return
stream
-
>
mix_params
.
channels
>
stream
-
>
stream_params
.
channels
;
}
bool
should_downmix
(
cubeb_stream
*
stream
)
{
return
stream
-
>
mix_params
.
channels
<
stream
-
>
stream_params
.
channels
;
}
float
stream_to_mix_samplerate_ratio
(
cubeb_stream
*
stream
)
{
auto_lock
lock
(
stream
-
>
stream_reset_lock
)
;
return
float
(
stream
-
>
stream_params
.
rate
)
/
stream
-
>
mix_params
.
rate
;
}
template
<
typename
T
>
void
mono_to_stereo
(
T
*
in
long
insamples
T
*
out
)
{
int
j
=
0
;
for
(
int
i
=
0
;
i
<
insamples
;
+
+
i
j
+
=
2
)
{
out
[
j
]
=
out
[
j
+
1
]
=
in
[
i
]
;
}
}
template
<
typename
T
>
void
upmix
(
T
*
in
long
inframes
T
*
out
int32_t
in_channels
int32_t
out_channels
)
{
assert
(
out_channels
>
=
in_channels
)
;
if
(
in_channels
=
=
1
&
&
out_channels
=
=
2
)
{
mono_to_stereo
(
in
inframes
out
)
;
return
;
}
long
out_index
=
0
;
for
(
long
i
=
0
;
i
<
inframes
*
in_channels
;
i
+
=
in_channels
)
{
for
(
int
j
=
0
;
j
<
in_channels
;
+
+
j
)
{
out
[
out_index
+
j
]
=
in
[
i
+
j
]
;
}
for
(
int
j
=
in_channels
;
j
<
out_channels
;
+
+
j
)
{
out
[
out_index
+
j
]
=
0
.
0
;
}
out_index
+
=
out_channels
;
}
}
template
<
typename
T
>
void
downmix
(
T
*
in
long
inframes
T
*
out
int32_t
in_channels
int32_t
out_channels
)
{
assert
(
in_channels
>
=
out_channels
)
;
long
out_index
=
0
;
for
(
long
i
=
0
;
i
<
inframes
*
in_channels
;
i
+
=
in_channels
)
{
for
(
int
j
=
0
;
j
<
out_channels
;
+
+
j
)
{
out
[
out_index
+
j
]
=
in
[
i
+
j
]
;
}
out_index
+
=
out_channels
;
}
}
static
size_t
frames_to_bytes_before_mix
(
cubeb_stream
*
stm
size_t
frames
)
{
size_t
stream_frame_size
=
stm
-
>
stream_params
.
channels
*
sizeof
(
float
)
;
return
stream_frame_size
*
frames
;
}
void
refill
(
cubeb_stream
*
stm
float
*
data
long
frames_needed
)
{
float
*
dest
;
if
(
should_upmix
(
stm
)
|
|
should_downmix
(
stm
)
)
{
dest
=
stm
-
>
mix_buffer
;
}
else
{
dest
=
data
;
}
long
out_frames
=
cubeb_resampler_fill
(
stm
-
>
resampler
dest
frames_needed
)
;
clock_add
(
stm
roundf
(
frames_needed
*
stream_to_mix_samplerate_ratio
(
stm
)
)
)
;
if
(
out_frames
<
0
)
{
assert
(
false
)
;
}
if
(
out_frames
<
frames_needed
)
{
LOG
(
"
draining
.
\
n
"
)
;
stm
-
>
draining
=
true
;
}
assert
(
out_frames
=
=
frames_needed
|
|
stm
-
>
draining
)
;
if
(
should_upmix
(
stm
)
)
{
upmix
(
dest
out_frames
data
stm
-
>
stream_params
.
channels
stm
-
>
mix_params
.
channels
)
;
}
else
if
(
should_downmix
(
stm
)
)
{
downmix
(
dest
out_frames
data
stm
-
>
stream_params
.
channels
stm
-
>
mix_params
.
channels
)
;
}
}
static
unsigned
int
__stdcall
wasapi_stream_render_loop
(
LPVOID
stream
)
{
cubeb_stream
*
stm
=
static_cast
<
cubeb_stream
*
>
(
stream
)
;
bool
is_playing
=
true
;
HANDLE
wait_array
[
2
]
=
{
stm
-
>
shutdown_event
stm
-
>
refill_event
}
;
HANDLE
mmcss_handle
=
NULL
;
HRESULT
hr
=
0
;
bool
first
=
true
;
DWORD
mmcss_task_index
=
0
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
LOG
(
"
COM
initialization
failed
on
render_loop
thread
.
\
n
"
)
;
return
0
;
}
mmcss_handle
=
stm
-
>
context
-
>
set_mm_thread_characteristics
(
"
Audio
"
&
mmcss_task_index
)
;
if
(
!
mmcss_handle
)
{
LOG
(
"
Unable
to
use
mmcss
to
bump
the
render
thread
priority
:
%
x
\
n
"
GetLastError
(
)
)
;
}
while
(
is_playing
)
{
DWORD
waitResult
=
WaitForMultipleObjects
(
ARRAY_LENGTH
(
wait_array
)
wait_array
FALSE
1000
)
;
switch
(
waitResult
)
{
case
WAIT_OBJECT_0
:
{
is_playing
=
false
;
if
(
stm
-
>
draining
)
{
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_DRAINED
)
;
}
continue
;
}
case
WAIT_OBJECT_0
+
1
:
{
UINT32
padding
;
hr
=
stm
-
>
client
-
>
GetCurrentPadding
(
&
padding
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Failed
to
get
padding
\
n
"
)
;
is_playing
=
false
;
continue
;
}
assert
(
padding
<
=
stm
-
>
buffer_frame_count
)
;
if
(
stm
-
>
draining
)
{
if
(
padding
=
=
0
)
{
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_DRAINED
)
;
is_playing
=
false
;
}
continue
;
}
long
available
=
stm
-
>
buffer_frame_count
-
padding
;
if
(
available
=
=
0
)
{
continue
;
}
BYTE
*
data
;
hr
=
stm
-
>
render_client
-
>
GetBuffer
(
available
&
data
)
;
if
(
SUCCEEDED
(
hr
)
)
{
refill
(
stm
reinterpret_cast
<
float
*
>
(
data
)
available
)
;
hr
=
stm
-
>
render_client
-
>
ReleaseBuffer
(
available
0
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
failed
to
release
buffer
.
\
n
"
)
;
is_playing
=
false
;
}
}
else
{
LOG
(
"
failed
to
get
buffer
.
\
n
"
)
;
is_playing
=
false
;
}
}
break
;
case
WAIT_TIMEOUT
:
assert
(
stm
-
>
shutdown_event
=
=
wait_array
[
0
]
)
;
break
;
default
:
LOG
(
"
case
%
d
not
handled
in
render
loop
.
"
waitResult
)
;
abort
(
)
;
}
}
if
(
FAILED
(
hr
)
)
{
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_STOPPED
)
;
}
stm
-
>
context
-
>
revert_mm_thread_characteristics
(
mmcss_handle
)
;
return
0
;
}
void
wasapi_destroy
(
cubeb
*
context
)
;
HANDLE
WINAPI
set_mm_thread_characteristics_noop
(
const
char
*
LPDWORD
mmcss_task_index
)
{
return
(
HANDLE
)
1
;
}
BOOL
WINAPI
revert_mm_thread_characteristics_noop
(
HANDLE
mmcss_handle
)
{
return
true
;
}
HRESULT
register_notification_client
(
cubeb_stream
*
stm
)
{
HRESULT
hr
=
CoCreateInstance
(
__uuidof
(
MMDeviceEnumerator
)
NULL
CLSCTX_INPROC_SERVER
IID_PPV_ARGS
(
&
stm
-
>
device_enumerator
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
device
enumerator
:
%
x
\
n
"
hr
)
;
return
hr
;
}
stm
-
>
notification_client
=
new
wasapi_endpoint_notification_client
(
stm
)
;
hr
=
stm
-
>
device_enumerator
-
>
RegisterEndpointNotificationCallback
(
stm
-
>
notification_client
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
register
endpoint
notification
callback
:
%
x
\
n
"
hr
)
;
return
hr
;
}
return
hr
;
}
HRESULT
unregister_notification_client
(
cubeb_stream
*
stm
)
{
assert
(
stm
)
;
if
(
!
stm
-
>
device_enumerator
)
{
return
S_OK
;
}
stm
-
>
device_enumerator
-
>
UnregisterEndpointNotificationCallback
(
stm
-
>
notification_client
)
;
SafeRelease
(
stm
-
>
notification_client
)
;
SafeRelease
(
stm
-
>
device_enumerator
)
;
return
S_OK
;
}
HRESULT
get_default_endpoint
(
IMMDevice
*
*
device
)
{
IMMDeviceEnumerator
*
enumerator
;
HRESULT
hr
=
CoCreateInstance
(
__uuidof
(
MMDeviceEnumerator
)
NULL
CLSCTX_INPROC_SERVER
IID_PPV_ARGS
(
&
enumerator
)
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
device
enumerator
.
\
n
"
)
;
return
hr
;
}
hr
=
enumerator
-
>
GetDefaultAudioEndpoint
(
eRender
eMultimedia
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
default
audio
endpoint
.
%
d
\
n
"
__LINE__
)
;
SafeRelease
(
enumerator
)
;
return
hr
;
}
SafeRelease
(
enumerator
)
;
return
ERROR_SUCCESS
;
}
}
extern
"
C
"
{
int
wasapi_init
(
cubeb
*
*
context
char
const
*
context_name
)
{
HRESULT
hr
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
IMMDevice
*
device
;
hr
=
get_default_endpoint
(
&
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
device
.
\
n
"
)
;
return
CUBEB_ERROR
;
}
SafeRelease
(
device
)
;
cubeb
*
ctx
=
(
cubeb
*
)
calloc
(
1
sizeof
(
cubeb
)
)
;
ctx
-
>
ops
=
&
wasapi_ops
;
ctx
-
>
mmcss_module
=
LoadLibraryA
(
"
Avrt
.
dll
"
)
;
if
(
ctx
-
>
mmcss_module
)
{
ctx
-
>
set_mm_thread_characteristics
=
(
set_mm_thread_characteristics_function
)
GetProcAddress
(
ctx
-
>
mmcss_module
"
AvSetMmThreadCharacteristicsA
"
)
;
ctx
-
>
revert_mm_thread_characteristics
=
(
revert_mm_thread_characteristics_function
)
GetProcAddress
(
ctx
-
>
mmcss_module
"
AvRevertMmThreadCharacteristics
"
)
;
if
(
!
(
ctx
-
>
set_mm_thread_characteristics
&
&
ctx
-
>
revert_mm_thread_characteristics
)
)
{
LOG
(
"
Could
not
load
AvSetMmThreadCharacteristics
or
AvRevertMmThreadCharacteristics
:
%
x
\
n
"
GetLastError
(
)
)
;
FreeLibrary
(
ctx
-
>
mmcss_module
)
;
}
}
else
{
LOG
(
"
Could
not
load
Avrt
.
dll
\
n
"
)
;
ctx
-
>
set_mm_thread_characteristics
=
&
set_mm_thread_characteristics_noop
;
ctx
-
>
revert_mm_thread_characteristics
=
&
revert_mm_thread_characteristics_noop
;
}
*
context
=
ctx
;
return
CUBEB_OK
;
}
}
namespace
{
void
stop_and_join_render_thread
(
cubeb_stream
*
stm
)
{
if
(
!
stm
-
>
thread
)
{
return
;
}
BOOL
ok
=
SetEvent
(
stm
-
>
shutdown_event
)
;
if
(
!
ok
)
{
LOG
(
"
Destroy
SetEvent
failed
:
%
d
\
n
"
GetLastError
(
)
)
;
}
DWORD
r
=
WaitForSingleObject
(
stm
-
>
thread
INFINITE
)
;
if
(
r
=
=
WAIT_FAILED
)
{
LOG
(
"
Destroy
WaitForSingleObject
on
thread
failed
:
%
d
\
n
"
GetLastError
(
)
)
;
}
CloseHandle
(
stm
-
>
thread
)
;
stm
-
>
thread
=
NULL
;
CloseHandle
(
stm
-
>
shutdown_event
)
;
stm
-
>
shutdown_event
=
0
;
}
void
wasapi_destroy
(
cubeb
*
context
)
{
if
(
context
-
>
mmcss_module
)
{
FreeLibrary
(
context
-
>
mmcss_module
)
;
}
free
(
context
)
;
}
char
const
*
wasapi_get_backend_id
(
cubeb
*
context
)
{
return
"
wasapi
"
;
}
int
wasapi_get_max_channel_count
(
cubeb
*
ctx
uint32_t
*
max_channels
)
{
HRESULT
hr
;
IAudioClient
*
client
;
WAVEFORMATEX
*
mix_format
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
assert
(
ctx
&
&
max_channels
)
;
IMMDevice
*
device
;
hr
=
get_default_endpoint
(
&
device
)
;
if
(
FAILED
(
hr
)
)
{
return
CUBEB_ERROR
;
}
hr
=
device
-
>
Activate
(
__uuidof
(
IAudioClient
)
CLSCTX_INPROC_SERVER
NULL
(
void
*
*
)
&
client
)
;
SafeRelease
(
device
)
;
if
(
FAILED
(
hr
)
)
{
return
CUBEB_ERROR
;
}
hr
=
client
-
>
GetMixFormat
(
&
mix_format
)
;
if
(
FAILED
(
hr
)
)
{
SafeRelease
(
client
)
;
return
CUBEB_ERROR
;
}
*
max_channels
=
mix_format
-
>
nChannels
;
CoTaskMemFree
(
mix_format
)
;
SafeRelease
(
client
)
;
return
CUBEB_OK
;
}
int
wasapi_get_min_latency
(
cubeb
*
ctx
cubeb_stream_params
params
uint32_t
*
latency_ms
)
{
HRESULT
hr
;
IAudioClient
*
client
;
REFERENCE_TIME
default_period
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
IMMDevice
*
device
;
hr
=
get_default_endpoint
(
&
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
default
endpoint
:
%
x
.
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
hr
=
device
-
>
Activate
(
__uuidof
(
IAudioClient
)
CLSCTX_INPROC_SERVER
NULL
(
void
*
*
)
&
client
)
;
SafeRelease
(
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
activate
device
for
latency
:
%
x
.
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
hr
=
client
-
>
GetDevicePeriod
(
&
default_period
NULL
)
;
if
(
FAILED
(
hr
)
)
{
SafeRelease
(
client
)
;
LOG
(
"
Could
not
get
device
period
:
%
x
.
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
LOG
(
"
default
device
period
:
%
ld
\
n
"
default_period
)
;
*
latency_ms
=
hns_to_ms
(
default_period
)
;
SafeRelease
(
client
)
;
return
CUBEB_OK
;
}
int
wasapi_get_preferred_sample_rate
(
cubeb
*
ctx
uint32_t
*
rate
)
{
HRESULT
hr
;
IAudioClient
*
client
;
WAVEFORMATEX
*
mix_format
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
IMMDevice
*
device
;
hr
=
get_default_endpoint
(
&
device
)
;
if
(
FAILED
(
hr
)
)
{
return
CUBEB_ERROR
;
}
hr
=
device
-
>
Activate
(
__uuidof
(
IAudioClient
)
CLSCTX_INPROC_SERVER
NULL
(
void
*
*
)
&
client
)
;
SafeRelease
(
device
)
;
if
(
FAILED
(
hr
)
)
{
return
CUBEB_ERROR
;
}
hr
=
client
-
>
GetMixFormat
(
&
mix_format
)
;
if
(
FAILED
(
hr
)
)
{
SafeRelease
(
client
)
;
return
CUBEB_ERROR
;
}
*
rate
=
mix_format
-
>
nSamplesPerSec
;
CoTaskMemFree
(
mix_format
)
;
SafeRelease
(
client
)
;
return
CUBEB_OK
;
}
void
wasapi_stream_destroy
(
cubeb_stream
*
stm
)
;
static
void
handle_channel_layout
(
cubeb_stream
*
stm
WAVEFORMATEX
*
*
mix_format
const
cubeb_stream_params
*
stream_params
)
{
if
(
(
*
mix_format
)
-
>
nChannels
<
=
2
)
{
return
;
}
WAVEFORMATEX
hw_mixformat
=
*
*
mix_format
;
if
(
(
*
mix_format
)
-
>
wFormatTag
!
=
WAVE_FORMAT_EXTENSIBLE
)
{
return
;
}
WAVEFORMATEXTENSIBLE
*
format_pcm
=
reinterpret_cast
<
WAVEFORMATEXTENSIBLE
*
>
(
(
*
mix_format
)
)
;
switch
(
stream_params
-
>
channels
)
{
case
1
:
format_pcm
-
>
dwChannelMask
=
KSAUDIO_SPEAKER_MONO
;
break
;
case
2
:
format_pcm
-
>
dwChannelMask
=
KSAUDIO_SPEAKER_STEREO
;
break
;
default
:
assert
(
false
&
&
"
Channel
layout
not
supported
.
"
)
;
break
;
}
(
*
mix_format
)
-
>
nChannels
=
stream_params
-
>
channels
;
(
*
mix_format
)
-
>
nBlockAlign
=
(
(
*
mix_format
)
-
>
wBitsPerSample
*
(
*
mix_format
)
-
>
nChannels
)
/
8
;
(
*
mix_format
)
-
>
nAvgBytesPerSec
=
(
*
mix_format
)
-
>
nSamplesPerSec
*
(
*
mix_format
)
-
>
nBlockAlign
;
format_pcm
-
>
SubFormat
=
KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
;
(
*
mix_format
)
-
>
wBitsPerSample
=
32
;
format_pcm
-
>
Samples
.
wValidBitsPerSample
=
(
*
mix_format
)
-
>
wBitsPerSample
;
WAVEFORMATEX
*
closest
;
HRESULT
hr
=
stm
-
>
client
-
>
IsFormatSupported
(
AUDCLNT_SHAREMODE_SHARED
*
mix_format
&
closest
)
;
if
(
hr
=
=
S_FALSE
)
{
LOG
(
"
Using
WASAPI
suggested
format
:
channels
:
%
d
\
n
"
closest
-
>
nChannels
)
;
WAVEFORMATEXTENSIBLE
*
closest_pcm
=
reinterpret_cast
<
WAVEFORMATEXTENSIBLE
*
>
(
closest
)
;
assert
(
closest_pcm
-
>
SubFormat
=
=
format_pcm
-
>
SubFormat
)
;
CoTaskMemFree
(
*
mix_format
)
;
*
mix_format
=
closest
;
}
else
if
(
hr
=
=
AUDCLNT_E_UNSUPPORTED_FORMAT
)
{
*
*
mix_format
=
hw_mixformat
;
}
else
if
(
hr
=
=
S_OK
)
{
LOG
(
"
Requested
format
accepted
by
WASAPI
.
\
n
"
)
;
}
}
int
setup_wasapi_stream
(
cubeb_stream
*
stm
)
{
HRESULT
hr
;
IMMDevice
*
device
;
WAVEFORMATEX
*
mix_format
;
stm
-
>
stream_reset_lock
-
>
assert_current_thread_owns
(
)
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
assert
(
!
stm
-
>
client
&
&
"
WASAPI
stream
already
setup
close
it
first
.
"
)
;
hr
=
get_default_endpoint
(
&
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
default
endpoint
error
:
%
x
\
n
"
hr
)
;
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
hr
=
device
-
>
Activate
(
__uuidof
(
IAudioClient
)
CLSCTX_INPROC_SERVER
NULL
(
void
*
*
)
&
stm
-
>
client
)
;
SafeRelease
(
device
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
activate
the
device
to
get
an
audio
client
:
error
:
%
x
\
n
"
hr
)
;
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
hr
=
stm
-
>
client
-
>
GetMixFormat
(
&
mix_format
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
fetch
current
mix
format
from
the
audio
client
:
error
:
%
x
\
n
"
hr
)
;
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
handle_channel_layout
(
stm
&
mix_format
&
stm
-
>
stream_params
)
;
stm
-
>
mix_params
.
format
=
CUBEB_SAMPLE_FLOAT32NE
;
stm
-
>
mix_params
.
rate
=
mix_format
-
>
nSamplesPerSec
;
stm
-
>
mix_params
.
channels
=
mix_format
-
>
nChannels
;
hr
=
stm
-
>
client
-
>
Initialize
(
AUDCLNT_SHAREMODE_SHARED
AUDCLNT_STREAMFLAGS_EVENTCALLBACK
|
AUDCLNT_STREAMFLAGS_NOPERSIST
ms_to_hns
(
stm
-
>
latency
)
0
mix_format
NULL
)
;
CoTaskMemFree
(
mix_format
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Unable
to
initialize
audio
client
:
%
x
.
\
n
"
hr
)
;
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
hr
=
stm
-
>
client
-
>
GetBufferSize
(
&
stm
-
>
buffer_frame_count
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
the
buffer
size
from
the
client
%
x
.
\
n
"
hr
)
;
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
if
(
should_upmix
(
stm
)
|
|
should_downmix
(
stm
)
)
{
stm
-
>
mix_buffer
=
(
float
*
)
malloc
(
frames_to_bytes_before_mix
(
stm
stm
-
>
buffer_frame_count
)
)
;
}
hr
=
stm
-
>
client
-
>
SetEventHandle
(
stm
-
>
refill_event
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
set
the
event
handle
for
the
client
%
x
.
\
n
"
hr
)
;
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
hr
=
stm
-
>
client
-
>
GetService
(
__uuidof
(
IAudioRenderClient
)
(
void
*
*
)
&
stm
-
>
render_client
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
the
render
client
%
x
.
\
n
"
hr
)
;
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
hr
=
stm
-
>
client
-
>
GetService
(
__uuidof
(
IAudioStreamVolume
)
(
void
*
*
)
&
stm
-
>
audio_stream_volume
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
Could
not
get
the
IAudioStreamVolume
%
x
.
\
n
"
hr
)
;
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
stm
-
>
resampler
=
cubeb_resampler_create
(
stm
stm
-
>
stream_params
stm
-
>
mix_params
.
rate
stm
-
>
data_callback
stm
-
>
buffer_frame_count
stm
-
>
user_ptr
CUBEB_RESAMPLER_QUALITY_DESKTOP
)
;
if
(
!
stm
-
>
resampler
)
{
LOG
(
"
Could
not
get
a
resampler
\
n
"
)
;
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
return
CUBEB_OK
;
}
int
wasapi_stream_init
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_stream_params
stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
{
HRESULT
hr
;
int
rv
;
auto_com
com
;
if
(
!
com
.
ok
(
)
)
{
return
CUBEB_ERROR
;
}
assert
(
context
&
&
stream
)
;
cubeb_stream
*
stm
=
(
cubeb_stream
*
)
calloc
(
1
sizeof
(
cubeb_stream
)
)
;
assert
(
stm
)
;
stm
-
>
context
=
context
;
stm
-
>
data_callback
=
data_callback
;
stm
-
>
state_callback
=
state_callback
;
stm
-
>
user_ptr
=
user_ptr
;
stm
-
>
stream_params
=
stream_params
;
stm
-
>
draining
=
false
;
stm
-
>
latency
=
latency
;
stm
-
>
clock
=
0
;
stm
-
>
resampler
=
NULL
;
stm
-
>
client
=
NULL
;
stm
-
>
render_client
=
NULL
;
stm
-
>
audio_stream_volume
=
NULL
;
stm
-
>
device_enumerator
=
NULL
;
stm
-
>
notification_client
=
NULL
;
stm
-
>
stream_reset_lock
=
new
owned_critical_section
(
)
;
stm
-
>
refill_event
=
CreateEvent
(
NULL
0
0
NULL
)
;
if
(
!
stm
-
>
refill_event
)
{
LOG
(
"
Can
'
t
create
the
refill
event
error
:
%
x
\
n
"
GetLastError
(
)
)
;
wasapi_stream_destroy
(
stm
)
;
return
CUBEB_ERROR
;
}
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
rv
=
setup_wasapi_stream
(
stm
)
;
if
(
rv
!
=
CUBEB_OK
)
{
return
rv
;
}
}
hr
=
register_notification_client
(
stm
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
failed
to
register
notification
client
%
x
\
n
"
hr
)
;
}
*
stream
=
stm
;
return
CUBEB_OK
;
}
void
close_wasapi_stream
(
cubeb_stream
*
stm
)
{
assert
(
stm
)
;
stm
-
>
stream_reset_lock
-
>
assert_current_thread_owns
(
)
;
SafeRelease
(
stm
-
>
client
)
;
stm
-
>
client
=
NULL
;
SafeRelease
(
stm
-
>
render_client
)
;
stm
-
>
render_client
=
NULL
;
if
(
stm
-
>
resampler
)
{
cubeb_resampler_destroy
(
stm
-
>
resampler
)
;
stm
-
>
resampler
=
NULL
;
}
free
(
stm
-
>
mix_buffer
)
;
stm
-
>
mix_buffer
=
NULL
;
}
void
wasapi_stream_destroy
(
cubeb_stream
*
stm
)
{
assert
(
stm
)
;
unregister_notification_client
(
stm
)
;
stop_and_join_render_thread
(
stm
)
;
SafeRelease
(
stm
-
>
refill_event
)
;
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
close_wasapi_stream
(
stm
)
;
}
delete
stm
-
>
stream_reset_lock
;
free
(
stm
)
;
}
int
wasapi_stream_start
(
cubeb_stream
*
stm
)
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
assert
(
stm
&
&
!
stm
-
>
thread
&
&
!
stm
-
>
shutdown_event
)
;
stm
-
>
shutdown_event
=
CreateEvent
(
NULL
0
0
NULL
)
;
if
(
!
stm
-
>
shutdown_event
)
{
LOG
(
"
Can
'
t
create
the
shutdown
event
error
:
%
x
\
n
"
GetLastError
(
)
)
;
return
CUBEB_ERROR
;
}
stm
-
>
thread
=
(
HANDLE
)
_beginthreadex
(
NULL
256
*
1024
wasapi_stream_render_loop
stm
STACK_SIZE_PARAM_IS_A_RESERVATION
NULL
)
;
if
(
stm
-
>
thread
=
=
NULL
)
{
LOG
(
"
could
not
create
WASAPI
render
thread
.
\
n
"
)
;
return
CUBEB_ERROR
;
}
HRESULT
hr
=
stm
-
>
client
-
>
Start
(
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
could
not
start
the
stream
.
\
n
"
)
;
return
CUBEB_ERROR
;
}
else
{
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_STARTED
)
;
}
return
FAILED
(
hr
)
?
CUBEB_ERROR
:
CUBEB_OK
;
}
int
stream_stop
(
cubeb_stream
*
stm
bool
*
was_running
)
{
assert
(
stm
)
;
stm
-
>
stream_reset_lock
-
>
assert_current_thread_owns
(
)
;
HRESULT
hr
=
stm
-
>
client
-
>
Stop
(
)
;
if
(
FAILED
(
hr
)
)
{
LOG
(
"
could
not
stop
AudioClient
\
n
"
)
;
}
if
(
was_running
)
{
*
was_running
=
hr
=
=
S_OK
;
assert
(
*
was_running
=
=
!
!
stm
-
>
thread
)
;
}
{
stm
-
>
stream_reset_lock
-
>
leave
(
)
;
stop_and_join_render_thread
(
stm
)
;
stm
-
>
stream_reset_lock
-
>
enter
(
)
;
}
if
(
SUCCEEDED
(
hr
)
)
{
stm
-
>
state_callback
(
stm
stm
-
>
user_ptr
CUBEB_STATE_STOPPED
)
;
}
return
FAILED
(
hr
)
?
CUBEB_ERROR
:
CUBEB_OK
;
}
int
wasapi_stream_stop
(
cubeb_stream
*
stm
)
{
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
return
stream_stop
(
stm
NULL
)
;
}
int
wasapi_stream_get_position
(
cubeb_stream
*
stm
uint64_t
*
position
)
{
assert
(
stm
&
&
position
)
;
*
position
=
clock_get
(
stm
)
;
return
CUBEB_OK
;
}
int
wasapi_stream_get_latency
(
cubeb_stream
*
stm
uint32_t
*
latency
)
{
assert
(
stm
&
&
latency
)
;
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
if
(
!
stm
-
>
client
)
{
return
CUBEB_ERROR
;
}
REFERENCE_TIME
latency_hns
;
stm
-
>
client
-
>
GetStreamLatency
(
&
latency_hns
)
;
double
latency_s
=
hns_to_s
(
latency_hns
)
;
*
latency
=
static_cast
<
uint32_t
>
(
latency_s
*
stm
-
>
stream_params
.
rate
)
;
return
CUBEB_OK
;
}
int
wasapi_stream_set_volume
(
cubeb_stream
*
stm
float
volume
)
{
HRESULT
hr
;
uint32_t
channels
;
float
volumes
[
10
]
;
auto_lock
lock
(
stm
-
>
stream_reset_lock
)
;
hr
=
stm
-
>
audio_stream_volume
-
>
GetChannelCount
(
&
channels
)
;
if
(
hr
!
=
S_OK
)
{
LOG
(
"
could
not
get
the
channel
count
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
assert
(
channels
<
=
10
&
&
"
bump
the
array
size
"
)
;
for
(
uint32_t
i
=
0
;
i
<
channels
;
i
+
+
)
{
volumes
[
i
]
=
volume
;
}
hr
=
stm
-
>
audio_stream_volume
-
>
SetAllVolumes
(
channels
volumes
)
;
if
(
hr
!
=
S_OK
)
{
LOG
(
"
could
not
set
the
channels
volume
:
%
x
\
n
"
hr
)
;
return
CUBEB_ERROR
;
}
return
CUBEB_OK
;
}
cubeb_ops
const
wasapi_ops
=
{
wasapi_init
wasapi_get_backend_id
wasapi_get_max_channel_count
wasapi_get_min_latency
wasapi_get_preferred_sample_rate
wasapi_destroy
wasapi_stream_init
wasapi_stream_destroy
wasapi_stream_start
wasapi_stream_stop
wasapi_stream_get_position
wasapi_stream_get_latency
wasapi_stream_set_volume
NULL
NULL
NULL
NULL
}
;
}
