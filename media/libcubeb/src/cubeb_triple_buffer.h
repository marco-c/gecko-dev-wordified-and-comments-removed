#
ifndef
CUBEB_TRIPLE_BUFFER
#
define
CUBEB_TRIPLE_BUFFER
#
include
<
atomic
>
template
<
typename
T
>
class
triple_buffer
{
public
:
bool
write
(
T
&
input
)
{
storage
[
input_idx
]
=
input
;
return
publish
(
)
;
}
T
&
read
(
)
{
update
(
)
;
return
storage
[
output_idx
]
;
}
bool
updated
(
)
{
return
(
shared_state
.
load
(
std
:
:
memory_order_relaxed
)
&
BACK_DIRTY_BIT
)
!
=
0
;
}
void
invalidate
(
)
{
shared_state
.
store
(
0
std
:
:
memory_order_release
)
;
input_idx
=
1
;
output_idx
=
2
;
}
private
:
bool
publish
(
)
{
auto
former_back_idx
=
shared_state
.
exchange
(
input_idx
|
BACK_DIRTY_BIT
std
:
:
memory_order_acq_rel
)
;
input_idx
=
former_back_idx
&
BACK_INDEX_MASK
;
return
(
former_back_idx
&
BACK_DIRTY_BIT
)
!
=
0
;
}
bool
update
(
)
{
bool
was_updated
=
updated
(
)
;
if
(
was_updated
)
{
auto
former_back_idx
=
shared_state
.
exchange
(
output_idx
std
:
:
memory_order_acq_rel
)
;
output_idx
=
former_back_idx
&
BACK_INDEX_MASK
;
}
return
was_updated
;
}
T
storage
[
3
]
;
const
uint8_t
BACK_INDEX_MASK
=
0b11
;
const
uint8_t
BACK_DIRTY_BIT
=
0b100
;
std
:
:
atomic
<
uint8_t
>
shared_state
=
{
0
}
;
uint8_t
output_idx
=
1
;
uint8_t
input_idx
=
2
;
}
;
#
endif
