#
ifndef
CUBEB_RING_BUFFER_H
#
define
CUBEB_RING_BUFFER_H
#
include
"
cubeb_utils
.
h
"
#
include
<
algorithm
>
#
include
<
atomic
>
#
include
<
cstdint
>
#
include
<
memory
>
#
include
<
thread
>
enum
ThreadSafety
{
Unsafe
Safe
}
;
template
<
ThreadSafety
>
struct
ThreadSafePolicy
;
typedef
int
RingBufferIndex
;
template
<
>
struct
ThreadSafePolicy
<
Safe
>
{
typedef
std
:
:
atomic
<
RingBufferIndex
>
IndexType
;
}
;
template
<
>
struct
ThreadSafePolicy
<
Unsafe
>
{
typedef
RingBufferIndex
IndexType
;
}
;
template
<
typename
T
ThreadSafety
Safety
=
ThreadSafety
:
:
Safe
>
class
ring_buffer_base
{
public
:
ring_buffer_base
(
RingBufferIndex
capacity
)
:
capacity_
(
capacity
+
1
)
{
assert
(
storage_capacity
(
)
<
std
:
:
numeric_limits
<
RingBufferIndex
>
:
:
max
(
)
/
2
&
&
"
buffer
too
large
for
the
type
of
index
used
.
"
)
;
assert
(
capacity_
>
0
)
;
data_
.
reset
(
new
T
[
storage_capacity
(
)
]
)
;
write_index_
=
0
;
read_index_
=
0
;
}
RingBufferIndex
enqueue_default
(
RingBufferIndex
count
)
{
return
enqueue
(
nullptr
count
)
;
}
RingBufferIndex
enqueue
(
T
&
element
)
{
return
enqueue
(
&
element
1
)
;
}
RingBufferIndex
enqueue
(
T
*
elements
RingBufferIndex
count
)
{
#
ifndef
NDEBUG
assert_correct_thread
(
producer_id
)
;
#
endif
RingBufferIndex
rd_idx
=
read_index_
;
RingBufferIndex
wr_idx
=
write_index_
;
if
(
full_internal
(
rd_idx
wr_idx
)
)
{
return
0
;
}
RingBufferIndex
to_write
=
std
:
:
min
(
available_write_internal
(
rd_idx
wr_idx
)
count
)
;
RingBufferIndex
first_part
=
std
:
:
min
(
storage_capacity
(
)
-
wr_idx
to_write
)
;
RingBufferIndex
second_part
=
to_write
-
first_part
;
if
(
elements
)
{
Copy
(
data_
.
get
(
)
+
wr_idx
elements
first_part
)
;
Copy
(
data_
.
get
(
)
elements
+
first_part
second_part
)
;
}
else
{
ConstructDefault
(
data_
.
get
(
)
+
wr_idx
first_part
)
;
ConstructDefault
(
data_
.
get
(
)
second_part
)
;
}
write_index_
=
increment_index
(
wr_idx
to_write
)
;
return
to_write
;
}
RingBufferIndex
dequeue
(
T
*
elements
RingBufferIndex
count
)
{
#
ifndef
NDEBUG
assert_correct_thread
(
consumer_id
)
;
#
endif
RingBufferIndex
wr_idx
=
write_index_
;
RingBufferIndex
rd_idx
=
read_index_
;
if
(
empty_internal
(
rd_idx
wr_idx
)
)
{
return
0
;
}
RingBufferIndex
to_read
=
std
:
:
min
(
available_read_internal
(
rd_idx
wr_idx
)
count
)
;
RingBufferIndex
first_part
=
std
:
:
min
(
storage_capacity
(
)
-
rd_idx
to_read
)
;
RingBufferIndex
second_part
=
to_read
-
first_part
;
if
(
elements
)
{
Copy
(
elements
data_
.
get
(
)
+
rd_idx
first_part
)
;
Copy
(
elements
+
first_part
data_
.
get
(
)
second_part
)
;
}
read_index_
=
increment_index
(
rd_idx
to_read
)
;
return
to_read
;
}
RingBufferIndex
available_read
(
)
const
{
#
ifndef
NDEBUG
assert_correct_thread
(
consumer_id
)
;
#
endif
return
available_read_internal
(
read_index_
write_index_
)
;
}
RingBufferIndex
available_write
(
)
const
{
#
ifndef
NDEBUG
assert_correct_thread
(
producer_id
)
;
#
endif
return
available_write_internal
(
read_index_
write_index_
)
;
}
RingBufferIndex
capacity
(
)
const
{
return
storage_capacity
(
)
-
1
;
}
private
:
bool
empty_internal
(
RingBufferIndex
read_index
RingBufferIndex
write_index
)
const
{
return
write_index
=
=
read_index
;
}
bool
full_internal
(
RingBufferIndex
read_index
RingBufferIndex
write_index
)
const
{
return
(
write_index
+
1
)
%
storage_capacity
(
)
=
=
read_index
;
}
int
storage_capacity
(
)
const
{
return
capacity_
;
}
RingBufferIndex
available_read_internal
(
RingBufferIndex
read_index
RingBufferIndex
write_index
)
const
{
if
(
write_index
>
=
read_index
)
{
return
write_index
-
read_index
;
}
else
{
return
write_index
+
storage_capacity
(
)
-
read_index
;
}
}
RingBufferIndex
available_write_internal
(
RingBufferIndex
read_index
RingBufferIndex
write_index
)
const
{
int
rv
=
read_index
-
write_index
-
1
;
if
(
write_index
>
=
read_index
)
{
rv
+
=
storage_capacity
(
)
;
}
return
rv
;
}
RingBufferIndex
increment_index
(
RingBufferIndex
index
RingBufferIndex
increment
)
const
{
assert
(
increment
>
=
0
)
;
return
(
index
+
increment
)
%
storage_capacity
(
)
;
}
#
ifndef
NDEBUG
static
void
assert_correct_thread
(
std
:
:
thread
:
:
id
&
id
)
{
if
(
id
=
=
std
:
:
thread
:
:
id
(
)
)
{
id
=
std
:
:
this_thread
:
:
get_id
(
)
;
return
;
}
assert
(
id
=
=
std
:
:
this_thread
:
:
get_id
(
)
)
;
}
#
endif
typename
ThreadSafePolicy
<
Safety
>
:
:
IndexType
read_index_
;
typename
ThreadSafePolicy
<
Safety
>
:
:
IndexType
write_index_
;
const
int
capacity_
;
std
:
:
unique_ptr
<
T
[
]
>
data_
;
#
ifndef
NDEBUG
mutable
std
:
:
thread
:
:
id
consumer_id
;
mutable
std
:
:
thread
:
:
id
producer_id
;
#
endif
}
;
template
<
typename
T
ThreadSafety
Safety
=
ThreadSafety
:
:
Safe
>
class
audio_ring_buffer_base
{
public
:
audio_ring_buffer_base
(
int
channel_count
int
capacity_in_frames
)
:
channel_count
(
channel_count
)
ring_buffer
(
frames_to_samples
(
capacity_in_frames
)
)
{
assert
(
channel_count
>
0
)
;
}
int
enqueue_default
(
int
frame_count
)
{
return
samples_to_frames
(
ring_buffer
.
enqueue
(
nullptr
frames_to_samples
(
frame_count
)
)
)
;
}
int
enqueue
(
T
*
frames
int
frame_count
)
{
return
samples_to_frames
(
ring_buffer
.
enqueue
(
frames
frames_to_samples
(
frame_count
)
)
)
;
}
int
dequeue
(
T
*
frames
int
frame_count
)
{
return
samples_to_frames
(
ring_buffer
.
dequeue
(
frames
frames_to_samples
(
frame_count
)
)
)
;
}
int
available_read
(
)
const
{
return
samples_to_frames
(
ring_buffer
.
available_read
(
)
)
;
}
int
available_write
(
)
const
{
return
samples_to_frames
(
ring_buffer
.
available_write
(
)
)
;
}
int
capacity
(
)
const
{
return
samples_to_frames
(
ring_buffer
.
capacity
(
)
)
;
}
private
:
int
frames_to_samples
(
int
frames
)
const
{
return
frames
*
channel_count
;
}
int
samples_to_frames
(
int
samples
)
const
{
return
samples
/
channel_count
;
}
int
channel_count
;
ring_buffer_base
<
T
Safety
>
ring_buffer
;
}
;
template
<
typename
T
>
using
lock_free_queue
=
ring_buffer_base
<
T
Safe
>
;
template
<
typename
T
>
using
queue
=
ring_buffer_base
<
T
Unsafe
>
;
template
<
typename
T
>
using
lock_free_audio_ring_buffer
=
audio_ring_buffer_base
<
T
Safe
>
;
template
<
typename
T
>
using
audio_ring_buffer
=
audio_ring_buffer_base
<
T
Unsafe
>
;
#
endif
