#
ifndef
_JSEPCODECDESCRIPTION_H_
#
define
_JSEPCODECDESCRIPTION_H_
#
include
<
string
>
#
include
"
signaling
/
src
/
sdp
/
SdpMediaSection
.
h
"
#
include
"
signaling
/
src
/
sdp
/
SdpHelper
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
mozilla
/
net
/
DataChannelProtocol
.
h
"
namespace
mozilla
{
#
define
JSEP_CODEC_CLONE
(
T
)
\
virtual
JsepCodecDescription
*
Clone
(
)
const
override
{
return
new
T
(
*
this
)
;
}
class
JsepCodecDescription
{
public
:
JsepCodecDescription
(
mozilla
:
:
SdpMediaSection
:
:
MediaType
type
const
std
:
:
string
&
defaultPt
const
std
:
:
string
&
name
uint32_t
clock
uint32_t
channels
bool
enabled
)
:
mType
(
type
)
mDefaultPt
(
defaultPt
)
mName
(
name
)
mClock
(
clock
)
mChannels
(
channels
)
mEnabled
(
enabled
)
mStronglyPreferred
(
false
)
mDirection
(
sdp
:
:
kSend
)
{
}
virtual
~
JsepCodecDescription
(
)
{
}
virtual
JsepCodecDescription
*
Clone
(
)
const
=
0
;
bool
GetPtAsInt
(
uint16_t
*
ptOutparam
)
const
{
return
SdpHelper
:
:
GetPtAsInt
(
mDefaultPt
ptOutparam
)
;
}
virtual
bool
Matches
(
const
std
:
:
string
&
fmt
const
SdpMediaSection
&
remoteMsection
)
const
{
if
(
mType
!
=
remoteMsection
.
GetMediaType
(
)
)
{
return
false
;
}
const
SdpRtpmapAttributeList
:
:
Rtpmap
*
entry
(
remoteMsection
.
FindRtpmap
(
fmt
)
)
;
if
(
entry
)
{
if
(
!
nsCRT
:
:
strcasecmp
(
mName
.
c_str
(
)
entry
-
>
name
.
c_str
(
)
)
&
&
(
mClock
=
=
entry
-
>
clock
)
&
&
(
mChannels
=
=
entry
-
>
channels
)
)
{
return
ParametersMatch
(
fmt
remoteMsection
)
;
}
}
else
if
(
!
fmt
.
compare
(
"
9
"
)
&
&
mName
=
=
"
G722
"
)
{
return
true
;
}
else
if
(
!
fmt
.
compare
(
"
0
"
)
&
&
mName
=
=
"
PCMU
"
)
{
return
true
;
}
else
if
(
!
fmt
.
compare
(
"
8
"
)
&
&
mName
=
=
"
PCMA
"
)
{
return
true
;
}
return
false
;
}
virtual
bool
ParametersMatch
(
const
std
:
:
string
&
fmt
const
SdpMediaSection
&
remoteMsection
)
const
{
return
true
;
}
virtual
bool
Negotiate
(
const
std
:
:
string
&
pt
const
SdpMediaSection
&
remoteMsection
bool
isOffer
)
{
if
(
mDirection
=
=
sdp
:
:
kSend
|
|
isOffer
)
{
mDefaultPt
=
pt
;
}
return
true
;
}
virtual
void
AddToMediaSection
(
SdpMediaSection
&
msection
)
const
{
if
(
mEnabled
&
&
msection
.
GetMediaType
(
)
=
=
mType
)
{
if
(
mDirection
=
=
sdp
:
:
kRecv
)
{
msection
.
AddCodec
(
mDefaultPt
mName
mClock
mChannels
)
;
}
AddParametersToMSection
(
msection
)
;
}
}
virtual
void
AddParametersToMSection
(
SdpMediaSection
&
msection
)
const
{
}
mozilla
:
:
SdpMediaSection
:
:
MediaType
mType
;
std
:
:
string
mDefaultPt
;
std
:
:
string
mName
;
uint32_t
mClock
;
uint32_t
mChannels
;
bool
mEnabled
;
bool
mStronglyPreferred
;
sdp
:
:
Direction
mDirection
;
EncodingConstraints
mConstraints
;
}
;
class
JsepAudioCodecDescription
:
public
JsepCodecDescription
{
public
:
JsepAudioCodecDescription
(
const
std
:
:
string
&
defaultPt
const
std
:
:
string
&
name
uint32_t
clock
uint32_t
channels
bool
enabled
=
true
)
:
JsepCodecDescription
(
mozilla
:
:
SdpMediaSection
:
:
kAudio
defaultPt
name
clock
channels
enabled
)
mMaxPlaybackRate
(
0
)
mForceMono
(
false
)
mFECEnabled
(
false
)
mDtmfEnabled
(
false
)
{
}
JSEP_CODEC_CLONE
(
JsepAudioCodecDescription
)
SdpFmtpAttributeList
:
:
OpusParameters
GetOpusParameters
(
const
std
:
:
string
&
pt
const
SdpMediaSection
&
msection
)
const
{
SdpFmtpAttributeList
:
:
OpusParameters
result
;
auto
*
params
=
msection
.
FindFmtp
(
pt
)
;
if
(
params
&
&
params
-
>
codec_type
=
=
SdpRtpmapAttributeList
:
:
kOpus
)
{
result
=
static_cast
<
const
SdpFmtpAttributeList
:
:
OpusParameters
&
>
(
*
params
)
;
}
return
result
;
}
SdpFmtpAttributeList
:
:
TelephoneEventParameters
GetTelephoneEventParameters
(
const
std
:
:
string
&
pt
const
SdpMediaSection
&
msection
)
const
{
SdpFmtpAttributeList
:
:
TelephoneEventParameters
result
;
auto
*
params
=
msection
.
FindFmtp
(
pt
)
;
if
(
params
&
&
params
-
>
codec_type
=
=
SdpRtpmapAttributeList
:
:
kTelephoneEvent
)
{
result
=
static_cast
<
const
SdpFmtpAttributeList
:
:
TelephoneEventParameters
&
>
(
*
params
)
;
}
return
result
;
}
void
AddParametersToMSection
(
SdpMediaSection
&
msection
)
const
override
{
if
(
mDirection
=
=
sdp
:
:
kSend
)
{
return
;
}
if
(
mName
=
=
"
opus
"
)
{
SdpFmtpAttributeList
:
:
OpusParameters
opusParams
(
GetOpusParameters
(
mDefaultPt
msection
)
)
;
if
(
mMaxPlaybackRate
)
{
opusParams
.
maxplaybackrate
=
mMaxPlaybackRate
;
}
if
(
mChannels
=
=
2
&
&
!
mForceMono
)
{
opusParams
.
stereo
=
1
;
}
opusParams
.
useInBandFec
=
mFECEnabled
?
1
:
0
;
msection
.
SetFmtp
(
SdpFmtpAttributeList
:
:
Fmtp
(
mDefaultPt
opusParams
)
)
;
}
else
if
(
mName
=
=
"
telephone
-
event
"
)
{
SdpFmtpAttributeList
:
:
TelephoneEventParameters
teParams
(
GetTelephoneEventParameters
(
mDefaultPt
msection
)
)
;
msection
.
SetFmtp
(
SdpFmtpAttributeList
:
:
Fmtp
(
mDefaultPt
teParams
)
)
;
}
}
bool
Negotiate
(
const
std
:
:
string
&
pt
const
SdpMediaSection
&
remoteMsection
bool
isOffer
)
override
{
JsepCodecDescription
:
:
Negotiate
(
pt
remoteMsection
isOffer
)
;
if
(
mName
=
=
"
opus
"
&
&
mDirection
=
=
sdp
:
:
kSend
)
{
SdpFmtpAttributeList
:
:
OpusParameters
opusParams
(
GetOpusParameters
(
mDefaultPt
remoteMsection
)
)
;
mMaxPlaybackRate
=
opusParams
.
maxplaybackrate
;
mForceMono
=
!
opusParams
.
stereo
;
mFECEnabled
=
opusParams
.
useInBandFec
;
}
return
true
;
}
uint32_t
mMaxPlaybackRate
;
bool
mForceMono
;
bool
mFECEnabled
;
bool
mDtmfEnabled
;
}
;
class
JsepVideoCodecDescription
:
public
JsepCodecDescription
{
public
:
JsepVideoCodecDescription
(
const
std
:
:
string
&
defaultPt
const
std
:
:
string
&
name
uint32_t
clock
bool
enabled
=
true
)
:
JsepCodecDescription
(
mozilla
:
:
SdpMediaSection
:
:
kVideo
defaultPt
name
clock
0
enabled
)
mTmmbrEnabled
(
false
)
mRembEnabled
(
false
)
mFECEnabled
(
false
)
mTransportCCEnabled
(
false
)
mREDPayloadType
(
0
)
mULPFECPayloadType
(
0
)
mProfileLevelId
(
0
)
mPacketizationMode
(
0
)
{
mNackFbTypes
.
push_back
(
"
"
)
;
mNackFbTypes
.
push_back
(
SdpRtcpFbAttributeList
:
:
pli
)
;
mCcmFbTypes
.
push_back
(
SdpRtcpFbAttributeList
:
:
fir
)
;
}
virtual
void
EnableTmmbr
(
)
{
if
(
!
mTmmbrEnabled
)
{
mTmmbrEnabled
=
true
;
mCcmFbTypes
.
push_back
(
SdpRtcpFbAttributeList
:
:
tmmbr
)
;
}
}
virtual
void
EnableRemb
(
)
{
if
(
!
mRembEnabled
)
{
mRembEnabled
=
true
;
mOtherFbTypes
.
push_back
(
{
"
"
SdpRtcpFbAttributeList
:
:
kRemb
"
"
"
"
}
)
;
}
}
virtual
void
EnableFec
(
std
:
:
string
redPayloadType
std
:
:
string
ulpfecPayloadType
)
{
uint16_t
redPt
ulpfecPt
;
if
(
!
SdpHelper
:
:
GetPtAsInt
(
redPayloadType
&
redPt
)
|
|
!
SdpHelper
:
:
GetPtAsInt
(
ulpfecPayloadType
&
ulpfecPt
)
)
{
return
;
}
mFECEnabled
=
true
;
mREDPayloadType
=
redPt
;
mULPFECPayloadType
=
ulpfecPt
;
}
virtual
void
EnableTransportCC
(
)
{
if
(
!
mTransportCCEnabled
)
{
mTransportCCEnabled
=
true
;
mOtherFbTypes
.
push_back
(
{
"
"
SdpRtcpFbAttributeList
:
:
kTransportCC
"
"
"
"
}
)
;
}
}
void
AddParametersToMSection
(
SdpMediaSection
&
msection
)
const
override
{
AddFmtpsToMSection
(
msection
)
;
AddRtcpFbsToMSection
(
msection
)
;
}
void
AddFmtpsToMSection
(
SdpMediaSection
&
msection
)
const
{
if
(
mName
=
=
"
H264
"
)
{
SdpFmtpAttributeList
:
:
H264Parameters
h264Params
(
GetH264Parameters
(
mDefaultPt
msection
)
)
;
if
(
mDirection
=
=
sdp
:
:
kSend
)
{
if
(
!
h264Params
.
level_asymmetry_allowed
)
{
h264Params
.
profile_level_id
=
mProfileLevelId
;
}
}
else
{
h264Params
.
max_mbps
=
mConstraints
.
maxMbps
;
h264Params
.
max_fs
=
mConstraints
.
maxFs
;
h264Params
.
max_cpb
=
mConstraints
.
maxCpb
;
h264Params
.
max_dpb
=
mConstraints
.
maxDpb
;
h264Params
.
max_br
=
mConstraints
.
maxBr
;
strncpy
(
h264Params
.
sprop_parameter_sets
mSpropParameterSets
.
c_str
(
)
sizeof
(
h264Params
.
sprop_parameter_sets
)
-
1
)
;
h264Params
.
profile_level_id
=
mProfileLevelId
;
}
h264Params
.
packetization_mode
=
mPacketizationMode
;
h264Params
.
level_asymmetry_allowed
=
true
;
msection
.
SetFmtp
(
SdpFmtpAttributeList
:
:
Fmtp
(
mDefaultPt
h264Params
)
)
;
}
else
if
(
mName
=
=
"
red
"
&
&
!
mRedundantEncodings
.
empty
(
)
)
{
SdpFmtpAttributeList
:
:
RedParameters
redParams
(
GetRedParameters
(
mDefaultPt
msection
)
)
;
redParams
.
encodings
=
mRedundantEncodings
;
msection
.
SetFmtp
(
SdpFmtpAttributeList
:
:
Fmtp
(
mDefaultPt
redParams
)
)
;
}
else
if
(
mName
=
=
"
VP8
"
|
|
mName
=
=
"
VP9
"
)
{
if
(
mDirection
=
=
sdp
:
:
kRecv
)
{
SdpFmtpAttributeList
:
:
VP8Parameters
vp8Params
(
GetVP8Parameters
(
mDefaultPt
msection
)
)
;
vp8Params
.
max_fs
=
mConstraints
.
maxFs
;
vp8Params
.
max_fr
=
mConstraints
.
maxFps
;
msection
.
SetFmtp
(
SdpFmtpAttributeList
:
:
Fmtp
(
mDefaultPt
vp8Params
)
)
;
}
}
}
void
AddRtcpFbsToMSection
(
SdpMediaSection
&
msection
)
const
{
SdpRtcpFbAttributeList
rtcpfbs
(
msection
.
GetRtcpFbs
(
)
)
;
for
(
const
auto
&
rtcpfb
:
rtcpfbs
.
mFeedbacks
)
{
if
(
rtcpfb
.
pt
=
=
mDefaultPt
)
{
return
;
}
}
for
(
const
std
:
:
string
&
type
:
mAckFbTypes
)
{
rtcpfbs
.
PushEntry
(
mDefaultPt
SdpRtcpFbAttributeList
:
:
kAck
type
)
;
}
for
(
const
std
:
:
string
&
type
:
mNackFbTypes
)
{
rtcpfbs
.
PushEntry
(
mDefaultPt
SdpRtcpFbAttributeList
:
:
kNack
type
)
;
}
for
(
const
std
:
:
string
&
type
:
mCcmFbTypes
)
{
rtcpfbs
.
PushEntry
(
mDefaultPt
SdpRtcpFbAttributeList
:
:
kCcm
type
)
;
}
for
(
const
auto
&
fb
:
mOtherFbTypes
)
{
rtcpfbs
.
PushEntry
(
mDefaultPt
fb
.
type
fb
.
parameter
fb
.
extra
)
;
}
msection
.
SetRtcpFbs
(
rtcpfbs
)
;
}
SdpFmtpAttributeList
:
:
H264Parameters
GetH264Parameters
(
const
std
:
:
string
&
pt
const
SdpMediaSection
&
msection
)
const
{
SdpFmtpAttributeList
:
:
H264Parameters
result
;
auto
*
params
=
msection
.
FindFmtp
(
pt
)
;
if
(
params
&
&
params
-
>
codec_type
=
=
SdpRtpmapAttributeList
:
:
kH264
)
{
result
=
static_cast
<
const
SdpFmtpAttributeList
:
:
H264Parameters
&
>
(
*
params
)
;
}
return
result
;
}
SdpFmtpAttributeList
:
:
RedParameters
GetRedParameters
(
const
std
:
:
string
&
pt
const
SdpMediaSection
&
msection
)
const
{
SdpFmtpAttributeList
:
:
RedParameters
result
;
auto
*
params
=
msection
.
FindFmtp
(
pt
)
;
if
(
params
&
&
params
-
>
codec_type
=
=
SdpRtpmapAttributeList
:
:
kRed
)
{
result
=
static_cast
<
const
SdpFmtpAttributeList
:
:
RedParameters
&
>
(
*
params
)
;
}
return
result
;
}
SdpFmtpAttributeList
:
:
VP8Parameters
GetVP8Parameters
(
const
std
:
:
string
&
pt
const
SdpMediaSection
&
msection
)
const
{
SdpRtpmapAttributeList
:
:
CodecType
expectedType
(
mName
=
=
"
VP8
"
?
SdpRtpmapAttributeList
:
:
kVP8
:
SdpRtpmapAttributeList
:
:
kVP9
)
;
SdpFmtpAttributeList
:
:
VP8Parameters
result
(
expectedType
)
;
auto
*
params
=
msection
.
FindFmtp
(
pt
)
;
if
(
params
&
&
params
-
>
codec_type
=
=
expectedType
)
{
result
=
static_cast
<
const
SdpFmtpAttributeList
:
:
VP8Parameters
&
>
(
*
params
)
;
}
return
result
;
}
void
NegotiateRtcpFb
(
const
SdpMediaSection
&
remoteMsection
SdpRtcpFbAttributeList
:
:
Type
type
std
:
:
vector
<
std
:
:
string
>
*
supportedTypes
)
{
std
:
:
vector
<
std
:
:
string
>
temp
;
for
(
auto
&
subType
:
*
supportedTypes
)
{
if
(
remoteMsection
.
HasRtcpFb
(
mDefaultPt
type
subType
)
)
{
temp
.
push_back
(
subType
)
;
}
}
*
supportedTypes
=
temp
;
}
void
NegotiateRtcpFb
(
const
SdpMediaSection
&
remoteMsection
std
:
:
vector
<
SdpRtcpFbAttributeList
:
:
Feedback
>
*
supportedFbs
)
{
std
:
:
vector
<
SdpRtcpFbAttributeList
:
:
Feedback
>
temp
;
for
(
auto
&
fb
:
*
supportedFbs
)
{
if
(
remoteMsection
.
HasRtcpFb
(
mDefaultPt
fb
.
type
fb
.
parameter
)
)
{
temp
.
push_back
(
fb
)
;
}
}
*
supportedFbs
=
temp
;
}
void
NegotiateRtcpFb
(
const
SdpMediaSection
&
remote
)
{
NegotiateRtcpFb
(
remote
SdpRtcpFbAttributeList
:
:
kAck
&
mAckFbTypes
)
;
NegotiateRtcpFb
(
remote
SdpRtcpFbAttributeList
:
:
kNack
&
mNackFbTypes
)
;
NegotiateRtcpFb
(
remote
SdpRtcpFbAttributeList
:
:
kCcm
&
mCcmFbTypes
)
;
NegotiateRtcpFb
(
remote
&
mOtherFbTypes
)
;
}
virtual
bool
Negotiate
(
const
std
:
:
string
&
pt
const
SdpMediaSection
&
remoteMsection
bool
isOffer
)
override
{
JsepCodecDescription
:
:
Negotiate
(
pt
remoteMsection
isOffer
)
;
if
(
mName
=
=
"
H264
"
)
{
SdpFmtpAttributeList
:
:
H264Parameters
h264Params
(
GetH264Parameters
(
mDefaultPt
remoteMsection
)
)
;
if
(
!
h264Params
.
level_asymmetry_allowed
)
{
SetSaneH264Level
(
std
:
:
min
(
GetSaneH264Level
(
h264Params
.
profile_level_id
)
GetSaneH264Level
(
mProfileLevelId
)
)
&
mProfileLevelId
)
;
}
if
(
mDirection
=
=
sdp
:
:
kSend
)
{
mConstraints
.
maxFs
=
h264Params
.
max_fs
;
mConstraints
.
maxMbps
=
h264Params
.
max_mbps
;
mConstraints
.
maxCpb
=
h264Params
.
max_cpb
;
mConstraints
.
maxDpb
=
h264Params
.
max_dpb
;
mConstraints
.
maxBr
=
h264Params
.
max_br
;
mSpropParameterSets
=
h264Params
.
sprop_parameter_sets
;
if
(
h264Params
.
level_asymmetry_allowed
)
{
SetSaneH264Level
(
GetSaneH264Level
(
h264Params
.
profile_level_id
)
&
mProfileLevelId
)
;
}
}
else
{
}
}
else
if
(
mName
=
=
"
red
"
)
{
SdpFmtpAttributeList
:
:
RedParameters
redParams
(
GetRedParameters
(
mDefaultPt
remoteMsection
)
)
;
mRedundantEncodings
=
redParams
.
encodings
;
}
else
if
(
mName
=
=
"
VP8
"
|
|
mName
=
=
"
VP9
"
)
{
if
(
mDirection
=
=
sdp
:
:
kSend
)
{
SdpFmtpAttributeList
:
:
VP8Parameters
vp8Params
(
GetVP8Parameters
(
mDefaultPt
remoteMsection
)
)
;
mConstraints
.
maxFs
=
vp8Params
.
max_fs
;
mConstraints
.
maxFps
=
vp8Params
.
max_fr
;
}
}
NegotiateRtcpFb
(
remoteMsection
)
;
return
true
;
}
static
uint32_t
GetSaneH264Level
(
uint32_t
profileLevelId
)
{
uint32_t
profileIdc
=
(
profileLevelId
>
>
16
)
;
if
(
profileIdc
=
=
0x42
|
|
profileIdc
=
=
0x4D
|
|
profileIdc
=
=
0x58
)
{
if
(
(
profileLevelId
&
0x10FF
)
=
=
0x100B
)
{
return
0xAB
;
}
}
uint32_t
level
=
profileLevelId
&
0xFF
;
if
(
level
=
=
0x09
)
{
return
0xAB
;
}
return
level
<
<
4
;
}
static
void
SetSaneH264Level
(
uint32_t
level
uint32_t
*
profileLevelId
)
{
uint32_t
profileIdc
=
(
*
profileLevelId
>
>
16
)
;
uint32_t
levelMask
=
0xFF
;
if
(
profileIdc
=
=
0x42
|
|
profileIdc
=
=
0x4d
|
|
profileIdc
=
=
0x58
)
{
levelMask
=
0x10FF
;
if
(
level
=
=
0xAB
)
{
level
=
0x100B
;
}
else
{
level
=
level
>
>
4
;
}
}
else
if
(
level
=
=
0xAB
)
{
level
=
0x09
;
}
else
{
level
=
level
>
>
4
;
}
*
profileLevelId
=
(
*
profileLevelId
&
~
levelMask
)
|
level
;
}
enum
Subprofile
{
kH264ConstrainedBaseline
kH264Baseline
kH264Main
kH264Extended
kH264High
kH264High10
kH264High42
kH264High44
kH264High10I
kH264High42I
kH264High44I
kH264CALVC44
kH264UnknownSubprofile
}
;
static
Subprofile
GetSubprofile
(
uint32_t
profileLevelId
)
{
if
(
(
profileLevelId
&
0xFF4F00
)
=
=
0x424000
)
{
return
kH264ConstrainedBaseline
;
}
if
(
(
profileLevelId
&
0xFF8F00
)
=
=
0x4D8000
)
{
return
kH264ConstrainedBaseline
;
}
if
(
(
profileLevelId
&
0xFFCF00
)
=
=
0x58C000
)
{
return
kH264ConstrainedBaseline
;
}
if
(
(
profileLevelId
&
0xFF4F00
)
=
=
0x420000
)
{
return
kH264Baseline
;
}
if
(
(
profileLevelId
&
0xFFCF00
)
=
=
0x588000
)
{
return
kH264Baseline
;
}
if
(
(
profileLevelId
&
0xFFAF00
)
=
=
0x4D0000
)
{
return
kH264Main
;
}
if
(
(
profileLevelId
&
0xFF0000
)
=
=
0x580000
)
{
return
kH264Extended
;
}
if
(
(
profileLevelId
&
0xFFFF00
)
=
=
0x640000
)
{
return
kH264High
;
}
if
(
(
profileLevelId
&
0xFFFF00
)
=
=
0x6E0000
)
{
return
kH264High10
;
}
if
(
(
profileLevelId
&
0xFFFF00
)
=
=
0x7A0000
)
{
return
kH264High42
;
}
if
(
(
profileLevelId
&
0xFFFF00
)
=
=
0xF40000
)
{
return
kH264High44
;
}
if
(
(
profileLevelId
&
0xFFFF00
)
=
=
0x6E1000
)
{
return
kH264High10I
;
}
if
(
(
profileLevelId
&
0xFFFF00
)
=
=
0x7A1000
)
{
return
kH264High42I
;
}
if
(
(
profileLevelId
&
0xFFFF00
)
=
=
0xF41000
)
{
return
kH264High44I
;
}
if
(
(
profileLevelId
&
0xFFFF00
)
=
=
0x2C1000
)
{
return
kH264CALVC44
;
}
return
kH264UnknownSubprofile
;
}
virtual
bool
ParametersMatch
(
const
std
:
:
string
&
fmt
const
SdpMediaSection
&
remoteMsection
)
const
override
{
if
(
mName
=
=
"
H264
"
)
{
SdpFmtpAttributeList
:
:
H264Parameters
h264Params
(
GetH264Parameters
(
fmt
remoteMsection
)
)
;
if
(
h264Params
.
packetization_mode
!
=
mPacketizationMode
)
{
return
false
;
}
if
(
GetSubprofile
(
h264Params
.
profile_level_id
)
!
=
GetSubprofile
(
mProfileLevelId
)
)
{
return
false
;
}
}
return
true
;
}
virtual
bool
RtcpFbRembIsSet
(
)
const
{
for
(
const
auto
&
fb
:
mOtherFbTypes
)
{
if
(
fb
.
type
=
=
SdpRtcpFbAttributeList
:
:
kRemb
)
{
return
true
;
}
}
return
false
;
}
virtual
bool
RtcpFbTransportCCIsSet
(
)
const
{
for
(
const
auto
&
fb
:
mOtherFbTypes
)
{
if
(
fb
.
type
=
=
SdpRtcpFbAttributeList
:
:
kTransportCC
)
{
return
true
;
}
}
return
false
;
}
virtual
void
UpdateRedundantEncodings
(
const
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
codecs
)
{
for
(
const
auto
&
codec
:
codecs
)
{
if
(
codec
-
>
mType
=
=
SdpMediaSection
:
:
kVideo
&
&
codec
-
>
mEnabled
&
&
codec
-
>
mName
!
=
"
red
"
)
{
uint16_t
pt
;
if
(
!
SdpHelper
:
:
GetPtAsInt
(
codec
-
>
mDefaultPt
&
pt
)
)
{
continue
;
}
mRedundantEncodings
.
push_back
(
pt
)
;
}
}
}
JSEP_CODEC_CLONE
(
JsepVideoCodecDescription
)
std
:
:
vector
<
std
:
:
string
>
mAckFbTypes
;
std
:
:
vector
<
std
:
:
string
>
mNackFbTypes
;
std
:
:
vector
<
std
:
:
string
>
mCcmFbTypes
;
std
:
:
vector
<
SdpRtcpFbAttributeList
:
:
Feedback
>
mOtherFbTypes
;
bool
mTmmbrEnabled
;
bool
mRembEnabled
;
bool
mFECEnabled
;
bool
mTransportCCEnabled
;
uint8_t
mREDPayloadType
;
uint8_t
mULPFECPayloadType
;
std
:
:
vector
<
uint8_t
>
mRedundantEncodings
;
uint32_t
mProfileLevelId
;
uint32_t
mPacketizationMode
;
std
:
:
string
mSpropParameterSets
;
}
;
class
JsepApplicationCodecDescription
:
public
JsepCodecDescription
{
public
:
JsepApplicationCodecDescription
(
const
std
:
:
string
&
name
uint16_t
channels
uint16_t
localPort
uint32_t
localMaxMessageSize
bool
enabled
=
true
)
:
JsepCodecDescription
(
mozilla
:
:
SdpMediaSection
:
:
kApplication
"
"
name
0
channels
enabled
)
mLocalPort
(
localPort
)
mLocalMaxMessageSize
(
localMaxMessageSize
)
mRemotePort
(
0
)
mRemoteMaxMessageSize
(
0
)
mRemoteMMSSet
(
false
)
{
}
JSEP_CODEC_CLONE
(
JsepApplicationCodecDescription
)
virtual
bool
Matches
(
const
std
:
:
string
&
fmt
const
SdpMediaSection
&
remoteMsection
)
const
override
{
if
(
mType
!
=
remoteMsection
.
GetMediaType
(
)
)
{
return
false
;
}
int
sctp_port
=
remoteMsection
.
GetSctpPort
(
)
;
bool
fmt_matches
=
nsCRT
:
:
strcasecmp
(
mName
.
c_str
(
)
remoteMsection
.
GetFormats
(
)
[
0
]
.
c_str
(
)
)
=
=
0
;
if
(
sctp_port
&
&
fmt_matches
)
{
return
true
;
}
const
SdpSctpmapAttributeList
:
:
Sctpmap
*
sctp_map
(
remoteMsection
.
GetSctpmap
(
)
)
;
if
(
sctp_map
)
{
return
nsCRT
:
:
strcasecmp
(
mName
.
c_str
(
)
sctp_map
-
>
name
.
c_str
(
)
)
=
=
0
;
}
return
false
;
}
virtual
void
AddToMediaSection
(
SdpMediaSection
&
msection
)
const
override
{
if
(
mEnabled
&
&
msection
.
GetMediaType
(
)
=
=
mType
)
{
if
(
mDirection
=
=
sdp
:
:
kRecv
)
{
msection
.
AddDataChannel
(
mName
mLocalPort
mChannels
mLocalMaxMessageSize
)
;
}
AddParametersToMSection
(
msection
)
;
}
}
bool
Negotiate
(
const
std
:
:
string
&
pt
const
SdpMediaSection
&
remoteMsection
bool
isOffer
)
override
{
JsepCodecDescription
:
:
Negotiate
(
pt
remoteMsection
isOffer
)
;
uint32_t
message_size
;
mRemoteMMSSet
=
remoteMsection
.
GetMaxMessageSize
(
&
message_size
)
;
if
(
mRemoteMMSSet
)
{
mRemoteMaxMessageSize
=
message_size
;
}
else
{
mRemoteMaxMessageSize
=
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_REMOTE_DEFAULT
;
}
int
sctp_port
=
remoteMsection
.
GetSctpPort
(
)
;
if
(
sctp_port
)
{
mRemotePort
=
sctp_port
;
return
true
;
}
const
SdpSctpmapAttributeList
:
:
Sctpmap
*
sctp_map
(
remoteMsection
.
GetSctpmap
(
)
)
;
if
(
sctp_map
)
{
mRemotePort
=
std
:
:
stoi
(
sctp_map
-
>
pt
)
;
return
true
;
}
return
false
;
}
uint16_t
mLocalPort
;
uint32_t
mLocalMaxMessageSize
;
uint16_t
mRemotePort
;
uint32_t
mRemoteMaxMessageSize
;
bool
mRemoteMMSSet
;
}
;
}
#
endif
