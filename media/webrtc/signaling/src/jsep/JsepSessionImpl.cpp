#
include
"
signaling
/
src
/
jsep
/
JsepSessionImpl
.
h
"
#
include
<
iterator
>
#
include
<
string
>
#
include
<
set
>
#
include
<
bitset
>
#
include
<
stdlib
.
h
>
#
include
"
nspr
.
h
"
#
include
"
nss
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
logging
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
webrtc
/
config
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepTrack
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepTransport
.
h
"
#
include
"
signaling
/
src
/
sdp
/
RsdparsaSdpParser
.
h
"
#
include
"
signaling
/
src
/
sdp
/
Sdp
.
h
"
#
include
"
signaling
/
src
/
sdp
/
SipccSdp
.
h
"
#
include
"
signaling
/
src
/
sdp
/
SipccSdpParser
.
h
"
#
include
"
mozilla
/
net
/
DataChannelProtocol
.
h
"
#
include
"
signaling
/
src
/
sdp
/
ParsingResultComparer
.
h
"
namespace
mozilla
{
MOZ_MTLOG_MODULE
(
"
jsep
"
)
#
define
JSEP_SET_ERROR
(
error
)
\
do
{
\
std
:
:
ostringstream
os
;
\
os
<
<
error
;
\
mLastError
=
os
.
str
(
)
;
\
MOZ_MTLOG
(
ML_ERROR
"
[
"
<
<
mName
<
<
"
]
:
"
<
<
mLastError
)
;
\
}
while
(
0
)
;
static
std
:
:
bitset
<
128
>
GetForbiddenSdpPayloadTypes
(
)
{
std
:
:
bitset
<
128
>
forbidden
(
0
)
;
forbidden
[
1
]
=
true
;
forbidden
[
2
]
=
true
;
forbidden
[
19
]
=
true
;
for
(
uint16_t
i
=
64
;
i
<
96
;
+
+
i
)
{
forbidden
[
i
]
=
true
;
}
return
forbidden
;
}
nsresult
JsepSessionImpl
:
:
Init
(
)
{
mLastError
.
clear
(
)
;
MOZ_ASSERT
(
!
mSessionId
"
Init
called
more
than
once
"
)
;
nsresult
rv
=
SetupIds
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetupDefaultCodecs
(
)
;
SetupDefaultRtpExtensions
(
)
;
mRunRustParser
=
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
sdp
.
rust
.
enabled
"
false
)
;
mRunSdpComparer
=
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
sdp
.
rust
.
compare
"
false
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
AddTransceiver
(
RefPtr
<
JsepTransceiver
>
transceiver
)
{
mLastError
.
clear
(
)
;
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Adding
transceiver
.
"
)
;
if
(
transceiver
-
>
GetMediaType
(
)
!
=
SdpMediaSection
:
:
kApplication
)
{
transceiver
-
>
mSendTrack
.
EnsureSsrcs
(
mSsrcGenerator
)
;
transceiver
-
>
mSendTrack
.
SetCNAME
(
mCNAME
)
;
if
(
transceiver
-
>
mSendTrack
.
GetTrackId
(
)
.
empty
(
)
)
{
std
:
:
string
trackId
;
if
(
!
mUuidGen
-
>
Generate
(
&
trackId
)
)
{
JSEP_SET_ERROR
(
"
Failed
to
generate
UUID
for
JsepTrack
"
)
;
return
NS_ERROR_FAILURE
;
}
transceiver
-
>
mSendTrack
.
UpdateTrackIds
(
std
:
:
vector
<
std
:
:
string
>
(
)
trackId
)
;
}
}
else
{
transceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
kSendrecv
;
}
transceiver
-
>
mSendTrack
.
PopulateCodecs
(
mSupportedCodecs
.
values
)
;
transceiver
-
>
mRecvTrack
.
PopulateCodecs
(
mSupportedCodecs
.
values
)
;
mTransceivers
.
push_back
(
transceiver
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetIceCredentials
(
const
std
:
:
string
&
ufrag
const
std
:
:
string
&
pwd
)
{
mLastError
.
clear
(
)
;
mIceUfrag
=
ufrag
;
mIcePwd
=
pwd
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetBundlePolicy
(
JsepBundlePolicy
policy
)
{
mLastError
.
clear
(
)
;
if
(
mCurrentLocalDescription
)
{
JSEP_SET_ERROR
(
"
Changing
the
bundle
policy
is
only
supported
before
the
"
"
first
SetLocalDescription
.
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
mBundlePolicy
=
policy
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
AddDtlsFingerprint
(
const
std
:
:
string
&
algorithm
const
std
:
:
vector
<
uint8_t
>
&
value
)
{
mLastError
.
clear
(
)
;
JsepDtlsFingerprint
fp
;
fp
.
mAlgorithm
=
algorithm
;
fp
.
mValue
=
value
;
mDtlsFingerprints
.
push_back
(
fp
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
AddRtpExtension
(
JsepMediaType
mediaType
const
std
:
:
string
&
extensionName
SdpDirectionAttribute
:
:
Direction
direction
)
{
mLastError
.
clear
(
)
;
if
(
mRtpExtensions
.
size
(
)
+
1
>
UINT16_MAX
)
{
JSEP_SET_ERROR
(
"
Too
many
rtp
extensions
have
been
added
"
)
;
return
NS_ERROR_FAILURE
;
}
for
(
auto
ext
=
mRtpExtensions
.
begin
(
)
;
ext
!
=
mRtpExtensions
.
end
(
)
;
+
+
ext
)
{
if
(
ext
-
>
mExtmap
.
direction
=
=
direction
&
&
ext
-
>
mExtmap
.
extensionname
=
=
extensionName
)
{
if
(
ext
-
>
mMediaType
!
=
mediaType
)
{
ext
-
>
mMediaType
=
JsepMediaType
:
:
kAudioVideo
;
}
return
NS_OK
;
}
}
JsepExtmapMediaType
extMediaType
=
{
mediaType
{
static_cast
<
uint16_t
>
(
mRtpExtensions
.
size
(
)
+
1
)
direction
direction
!
=
SdpDirectionAttribute
:
:
kSendrecv
extensionName
"
"
}
}
;
mRtpExtensions
.
push_back
(
extMediaType
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
AddAudioRtpExtension
(
const
std
:
:
string
&
extensionName
SdpDirectionAttribute
:
:
Direction
direction
)
{
return
AddRtpExtension
(
JsepMediaType
:
:
kAudio
extensionName
direction
)
;
}
nsresult
JsepSessionImpl
:
:
AddVideoRtpExtension
(
const
std
:
:
string
&
extensionName
SdpDirectionAttribute
:
:
Direction
direction
)
{
return
AddRtpExtension
(
JsepMediaType
:
:
kVideo
extensionName
direction
)
;
}
nsresult
JsepSessionImpl
:
:
AddAudioVideoRtpExtension
(
const
std
:
:
string
&
extensionName
SdpDirectionAttribute
:
:
Direction
direction
)
{
return
AddRtpExtension
(
JsepMediaType
:
:
kAudioVideo
extensionName
direction
)
;
}
nsresult
JsepSessionImpl
:
:
CreateOfferMsection
(
const
JsepOfferOptions
&
options
JsepTransceiver
&
transceiver
Sdp
*
local
)
{
JsepTrack
&
sendTrack
(
transceiver
.
mSendTrack
)
;
JsepTrack
&
recvTrack
(
transceiver
.
mRecvTrack
)
;
SdpMediaSection
:
:
Protocol
protocol
(
SdpHelper
:
:
GetProtocolForMediaType
(
sendTrack
.
GetMediaType
(
)
)
)
;
const
Sdp
*
answer
(
GetAnswer
(
)
)
;
const
SdpMediaSection
*
lastAnswerMsection
=
nullptr
;
if
(
answer
&
&
(
local
-
>
GetMediaSectionCount
(
)
<
answer
-
>
GetMediaSectionCount
(
)
)
)
{
lastAnswerMsection
=
&
answer
-
>
GetMediaSection
(
local
-
>
GetMediaSectionCount
(
)
)
;
protocol
=
lastAnswerMsection
-
>
GetProtocol
(
)
;
}
SdpMediaSection
*
msection
=
&
local
-
>
AddMediaSection
(
sendTrack
.
GetMediaType
(
)
transceiver
.
mJsDirection
0
protocol
sdp
:
:
kIPv4
"
0
.
0
.
0
.
0
"
)
;
if
(
lastAnswerMsection
)
{
nsresult
rv
=
mSdpHelper
.
CopyStickyParams
(
*
lastAnswerMsection
msection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
transceiver
.
IsStopped
(
)
)
{
SdpHelper
:
:
DisableMsection
(
local
msection
)
;
return
NS_OK
;
}
msection
-
>
SetPort
(
9
)
;
if
(
mSdpHelper
.
HasRtcp
(
msection
-
>
GetProtocol
(
)
)
)
{
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
new
SdpFlagAttribute
(
SdpAttribute
:
:
kRtcpMuxAttribute
)
)
;
}
nsresult
rv
=
AddTransportAttributes
(
msection
SdpSetupAttribute
:
:
kActpass
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
sendTrack
.
AddToOffer
(
mSsrcGenerator
msection
)
;
recvTrack
.
AddToOffer
(
mSsrcGenerator
msection
)
;
AddExtmap
(
msection
)
;
if
(
lastAnswerMsection
&
&
lastAnswerMsection
-
>
GetPort
(
)
)
{
MOZ_ASSERT
(
transceiver
.
IsAssociated
(
)
)
;
MOZ_ASSERT
(
transceiver
.
GetMid
(
)
=
=
lastAnswerMsection
-
>
GetAttributeList
(
)
.
GetMid
(
)
)
;
}
else
{
std
:
:
string
mid
;
if
(
transceiver
.
IsAssociated
(
)
)
{
mid
=
transceiver
.
GetMid
(
)
;
}
else
{
mid
=
GetNewMid
(
)
;
}
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
new
SdpStringAttribute
(
SdpAttribute
:
:
kMidAttribute
mid
)
)
;
}
return
NS_OK
;
}
void
JsepSessionImpl
:
:
SetupBundle
(
Sdp
*
sdp
)
const
{
std
:
:
vector
<
std
:
:
string
>
mids
;
std
:
:
set
<
SdpMediaSection
:
:
MediaType
>
observedTypes
;
for
(
size_t
i
=
0
;
i
<
sdp
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
auto
&
attrs
=
sdp
-
>
GetMediaSection
(
i
)
.
GetAttributeList
(
)
;
if
(
(
sdp
-
>
GetMediaSection
(
i
)
.
GetPort
(
)
!
=
0
)
&
&
attrs
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
)
{
bool
useBundleOnly
=
false
;
switch
(
mBundlePolicy
)
{
case
kBundleMaxCompat
:
break
;
case
kBundleBalanced
:
if
(
observedTypes
.
count
(
sdp
-
>
GetMediaSection
(
i
)
.
GetMediaType
(
)
)
)
{
useBundleOnly
=
true
;
}
observedTypes
.
insert
(
sdp
-
>
GetMediaSection
(
i
)
.
GetMediaType
(
)
)
;
break
;
case
kBundleMaxBundle
:
useBundleOnly
=
!
mids
.
empty
(
)
;
break
;
}
if
(
useBundleOnly
)
{
attrs
.
SetAttribute
(
new
SdpFlagAttribute
(
SdpAttribute
:
:
kBundleOnlyAttribute
)
)
;
sdp
-
>
GetMediaSection
(
i
)
.
SetPort
(
0
)
;
}
mids
.
push_back
(
attrs
.
GetMid
(
)
)
;
}
}
if
(
!
mids
.
empty
(
)
)
{
UniquePtr
<
SdpGroupAttributeList
>
groupAttr
(
new
SdpGroupAttributeList
)
;
groupAttr
-
>
PushEntry
(
SdpGroupAttributeList
:
:
kBundle
mids
)
;
sdp
-
>
GetAttributeList
(
)
.
SetAttribute
(
groupAttr
.
release
(
)
)
;
}
}
nsresult
JsepSessionImpl
:
:
GetRemoteIds
(
const
Sdp
&
sdp
const
SdpMediaSection
&
msection
std
:
:
vector
<
std
:
:
string
>
*
streamIds
std
:
:
string
*
trackId
)
{
nsresult
rv
=
mSdpHelper
.
GetIdsFromMsid
(
sdp
msection
streamIds
trackId
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
streamIds
-
>
push_back
(
mDefaultRemoteStreamId
)
;
if
(
!
mUuidGen
-
>
Generate
(
trackId
)
)
{
JSEP_SET_ERROR
(
"
Failed
to
generate
UUID
for
JsepTrack
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
return
rv
;
}
nsresult
JsepSessionImpl
:
:
RemoveDuplicateTrackIds
(
Sdp
*
sdp
)
{
std
:
:
set
<
std
:
:
string
>
trackIds
;
for
(
size_t
i
=
0
;
i
<
sdp
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
SdpMediaSection
&
msection
(
sdp
-
>
GetMediaSection
(
i
)
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
msection
)
)
{
continue
;
}
std
:
:
vector
<
std
:
:
string
>
streamIds
;
std
:
:
string
trackId
;
nsresult
rv
=
mSdpHelper
.
GetIdsFromMsid
(
*
sdp
msection
&
streamIds
&
trackId
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
trackIds
.
count
(
trackId
)
)
{
if
(
!
mUuidGen
-
>
Generate
(
&
trackId
)
)
{
JSEP_SET_ERROR
(
"
Tried
to
replace
duplicate
track
id
in
SDP
but
"
"
failed
to
generate
a
UUID
.
"
)
;
return
NS_ERROR_FAILURE
;
}
auto
&
mediaAttrs
=
msection
.
GetAttributeList
(
)
;
UniquePtr
<
SdpMsidAttributeList
>
newMsids
(
new
SdpMsidAttributeList
(
mediaAttrs
.
GetMsid
(
)
)
)
;
for
(
auto
&
msid
:
newMsids
-
>
mMsids
)
{
msid
.
appdata
=
trackId
;
}
mediaAttrs
.
SetAttribute
(
newMsids
.
release
(
)
)
;
}
trackIds
.
insert
(
trackId
)
;
}
else
if
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
CreateOffer
(
const
JsepOfferOptions
&
options
std
:
:
string
*
offer
)
{
mLastError
.
clear
(
)
;
mLocalIceIsRestarting
=
options
.
mIceRestart
.
isSome
(
)
&
&
*
(
options
.
mIceRestart
)
;
if
(
mState
!
=
kJsepStateStable
)
{
JSEP_SET_ERROR
(
"
Cannot
create
offer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
UniquePtr
<
Sdp
>
sdp
;
nsresult
rv
=
CreateGenericSDP
(
&
sdp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
size_t
level
=
0
;
JsepTransceiver
*
transceiver
=
GetTransceiverForLocal
(
level
)
;
+
+
level
)
{
rv
=
CreateOfferMsection
(
options
*
transceiver
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
sdp
-
>
GetMediaSectionCount
(
)
)
{
JSEP_SET_ERROR
(
"
Cannot
create
offer
when
there
are
no
valid
transceivers
.
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
SetupBundle
(
sdp
.
get
(
)
)
;
rv
=
RemoveDuplicateTrackIds
(
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mCurrentLocalDescription
)
{
rv
=
CopyPreviousTransportParams
(
*
GetAnswer
(
)
*
mCurrentLocalDescription
*
sdp
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyPreviousMsid
(
*
mCurrentLocalDescription
sdp
.
get
(
)
)
;
}
*
offer
=
sdp
-
>
ToString
(
)
;
mGeneratedLocalDescription
=
std
:
:
move
(
sdp
)
;
+
+
mSessionVersion
;
return
NS_OK
;
}
std
:
:
string
JsepSessionImpl
:
:
GetLocalDescription
(
JsepDescriptionPendingOrCurrent
type
)
const
{
std
:
:
ostringstream
os
;
mozilla
:
:
Sdp
*
sdp
=
GetParsedLocalDescription
(
type
)
;
if
(
sdp
)
{
sdp
-
>
Serialize
(
os
)
;
}
return
os
.
str
(
)
;
}
std
:
:
string
JsepSessionImpl
:
:
GetRemoteDescription
(
JsepDescriptionPendingOrCurrent
type
)
const
{
std
:
:
ostringstream
os
;
mozilla
:
:
Sdp
*
sdp
=
GetParsedRemoteDescription
(
type
)
;
if
(
sdp
)
{
sdp
-
>
Serialize
(
os
)
;
}
return
os
.
str
(
)
;
}
void
JsepSessionImpl
:
:
AddExtmap
(
SdpMediaSection
*
msection
)
{
auto
extensions
=
GetRtpExtensions
(
*
msection
)
;
if
(
!
extensions
.
empty
(
)
)
{
SdpExtmapAttributeList
*
extmap
=
new
SdpExtmapAttributeList
;
extmap
-
>
mExtmaps
=
extensions
;
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
extmap
)
;
}
}
std
:
:
vector
<
SdpExtmapAttributeList
:
:
Extmap
>
JsepSessionImpl
:
:
GetRtpExtensions
(
const
SdpMediaSection
&
msection
)
{
std
:
:
vector
<
SdpExtmapAttributeList
:
:
Extmap
>
result
;
JsepMediaType
mediaType
=
JsepMediaType
:
:
kNone
;
switch
(
msection
.
GetMediaType
(
)
)
{
case
SdpMediaSection
:
:
kAudio
:
mediaType
=
JsepMediaType
:
:
kAudio
;
break
;
case
SdpMediaSection
:
:
kVideo
:
mediaType
=
JsepMediaType
:
:
kVideo
;
if
(
msection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kRidAttribute
)
)
{
AddVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kRtpStreamIdUri
SdpDirectionAttribute
:
:
kSendonly
)
;
}
break
;
default
:
;
}
if
(
mediaType
!
=
JsepMediaType
:
:
kNone
)
{
for
(
auto
ext
=
mRtpExtensions
.
begin
(
)
;
ext
!
=
mRtpExtensions
.
end
(
)
;
+
+
ext
)
{
if
(
ext
-
>
mMediaType
=
=
mediaType
|
|
ext
-
>
mMediaType
=
=
JsepMediaType
:
:
kAudioVideo
)
{
result
.
push_back
(
ext
-
>
mExtmap
)
;
}
}
}
return
result
;
}
std
:
:
string
JsepSessionImpl
:
:
GetNewMid
(
)
{
std
:
:
string
mid
;
do
{
std
:
:
ostringstream
osMid
;
osMid
<
<
mMidCounter
+
+
;
mid
=
osMid
.
str
(
)
;
}
while
(
mUsedMids
.
count
(
mid
)
)
;
mUsedMids
.
insert
(
mid
)
;
return
mid
;
}
void
JsepSessionImpl
:
:
AddCommonExtmaps
(
const
SdpMediaSection
&
remoteMsection
SdpMediaSection
*
msection
)
{
mSdpHelper
.
AddCommonExtmaps
(
remoteMsection
GetRtpExtensions
(
*
msection
)
msection
)
;
}
nsresult
JsepSessionImpl
:
:
CreateAnswer
(
const
JsepAnswerOptions
&
options
std
:
:
string
*
answer
)
{
mLastError
.
clear
(
)
;
if
(
mState
!
=
kJsepStateHaveRemoteOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
create
answer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
UniquePtr
<
Sdp
>
sdp
;
nsresult
rv
=
CreateGenericSDP
(
&
sdp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
Sdp
&
offer
=
*
mPendingRemoteDescription
;
UniquePtr
<
SdpGroupAttributeList
>
groupAttr
(
new
SdpGroupAttributeList
)
;
mSdpHelper
.
GetBundleGroups
(
offer
&
groupAttr
-
>
mGroups
)
;
sdp
-
>
GetAttributeList
(
)
.
SetAttribute
(
groupAttr
.
release
(
)
)
;
for
(
size_t
i
=
0
;
i
<
offer
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
JsepTransceiver
*
transceiver
(
GetTransceiverForLevel
(
i
)
)
;
if
(
!
transceiver
)
{
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
i
)
;
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
CreateAnswerMsection
(
options
*
transceiver
offer
.
GetMediaSection
(
i
)
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
RemoveDuplicateTrackIds
(
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mCurrentLocalDescription
)
{
rv
=
CopyPreviousTransportParams
(
*
GetAnswer
(
)
*
mCurrentRemoteDescription
offer
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyPreviousMsid
(
*
mCurrentLocalDescription
sdp
.
get
(
)
)
;
}
*
answer
=
sdp
-
>
ToString
(
)
;
mGeneratedLocalDescription
=
std
:
:
move
(
sdp
)
;
+
+
mSessionVersion
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
CreateAnswerMsection
(
const
JsepAnswerOptions
&
options
JsepTransceiver
&
transceiver
const
SdpMediaSection
&
remoteMsection
Sdp
*
sdp
)
{
SdpDirectionAttribute
:
:
Direction
direction
=
reverse
(
remoteMsection
.
GetDirection
(
)
)
&
transceiver
.
mJsDirection
;
SdpMediaSection
&
msection
=
sdp
-
>
AddMediaSection
(
remoteMsection
.
GetMediaType
(
)
direction
9
remoteMsection
.
GetProtocol
(
)
sdp
:
:
kIPv4
"
0
.
0
.
0
.
0
"
)
;
nsresult
rv
=
mSdpHelper
.
CopyStickyParams
(
remoteMsection
&
msection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
remoteMsection
)
|
|
transceiver
.
IsStopped
(
)
)
{
SdpHelper
:
:
DisableMsection
(
sdp
&
msection
)
;
return
NS_OK
;
}
SdpSetupAttribute
:
:
Role
role
;
rv
=
DetermineAnswererSetupRole
(
remoteMsection
&
role
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
AddTransportAttributes
(
&
msection
role
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
transceiver
.
mSendTrack
.
AddToAnswer
(
remoteMsection
mSsrcGenerator
&
msection
)
;
transceiver
.
mRecvTrack
.
AddToAnswer
(
remoteMsection
mSsrcGenerator
&
msection
)
;
AddCommonExtmaps
(
remoteMsection
&
msection
)
;
if
(
msection
.
GetFormats
(
)
.
empty
(
)
)
{
SdpHelper
:
:
DisableMsection
(
sdp
&
msection
)
;
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
DetermineAnswererSetupRole
(
const
SdpMediaSection
&
remoteMsection
SdpSetupAttribute
:
:
Role
*
rolep
)
{
SdpSetupAttribute
:
:
Role
role
=
SdpSetupAttribute
:
:
kActive
;
if
(
remoteMsection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kSetupAttribute
)
)
{
switch
(
remoteMsection
.
GetAttributeList
(
)
.
GetSetup
(
)
.
mRole
)
{
case
SdpSetupAttribute
:
:
kActive
:
role
=
SdpSetupAttribute
:
:
kPassive
;
break
;
case
SdpSetupAttribute
:
:
kPassive
:
case
SdpSetupAttribute
:
:
kActpass
:
role
=
SdpSetupAttribute
:
:
kActive
;
break
;
case
SdpSetupAttribute
:
:
kHoldconn
:
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
The
other
side
used
an
illegal
setup
attribute
"
"
(
\
"
holdconn
\
"
)
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
*
rolep
=
role
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetLocalDescription
(
JsepSdpType
type
const
std
:
:
string
&
sdp
)
{
mLastError
.
clear
(
)
;
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
SetLocalDescription
type
=
"
<
<
type
<
<
"
\
nSDP
=
\
n
"
<
<
sdp
)
;
if
(
type
=
=
kJsepSdpRollback
)
{
if
(
mState
!
=
kJsepStateHaveLocalOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
rollback
local
description
in
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
mPendingLocalDescription
.
reset
(
)
;
SetState
(
kJsepStateStable
)
;
RollbackLocalOffer
(
)
;
return
NS_OK
;
}
switch
(
mState
)
{
case
kJsepStateStable
:
if
(
type
!
=
kJsepSdpOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
local
answer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
mIsOfferer
=
true
;
break
;
case
kJsepStateHaveRemoteOffer
:
if
(
type
!
=
kJsepSdpAnswer
&
&
type
!
=
kJsepSdpPranswer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
local
offer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
break
;
default
:
JSEP_SET_ERROR
(
"
Cannot
set
local
offer
or
answer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
UniquePtr
<
Sdp
>
parsed
;
nsresult
rv
=
ParseSdp
(
sdp
&
parsed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ValidateLocalDescription
(
*
parsed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
switch
(
type
)
{
case
kJsepSdpOffer
:
rv
=
ValidateOffer
(
*
parsed
)
;
break
;
case
kJsepSdpAnswer
:
case
kJsepSdpPranswer
:
rv
=
ValidateAnswer
(
*
mPendingRemoteDescription
*
parsed
)
;
break
;
case
kJsepSdpRollback
:
MOZ_CRASH
(
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
type
=
=
kJsepSdpOffer
)
{
mOldTransceivers
.
clear
(
)
;
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
mOldTransceivers
.
push_back
(
new
JsepTransceiver
(
*
transceiver
)
)
;
}
}
for
(
size_t
i
=
0
;
i
<
parsed
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
JsepTransceiver
*
transceiver
(
GetTransceiverForLevel
(
i
)
)
;
if
(
!
transceiver
)
{
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
i
)
;
return
NS_ERROR_FAILURE
;
}
transceiver
-
>
Associate
(
parsed
-
>
GetMediaSection
(
i
)
.
GetAttributeList
(
)
.
GetMid
(
)
)
;
transceiver
-
>
mTransport
=
new
JsepTransport
;
InitTransport
(
parsed
-
>
GetMediaSection
(
i
)
transceiver
-
>
mTransport
.
get
(
)
)
;
}
switch
(
type
)
{
case
kJsepSdpOffer
:
rv
=
SetLocalDescriptionOffer
(
std
:
:
move
(
parsed
)
)
;
break
;
case
kJsepSdpAnswer
:
case
kJsepSdpPranswer
:
rv
=
SetLocalDescriptionAnswer
(
type
std
:
:
move
(
parsed
)
)
;
break
;
case
kJsepSdpRollback
:
MOZ_CRASH
(
)
;
}
return
rv
;
}
nsresult
JsepSessionImpl
:
:
SetLocalDescriptionOffer
(
UniquePtr
<
Sdp
>
offer
)
{
MOZ_ASSERT
(
mState
=
=
kJsepStateStable
)
;
mPendingLocalDescription
=
std
:
:
move
(
offer
)
;
SetState
(
kJsepStateHaveLocalOffer
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetLocalDescriptionAnswer
(
JsepSdpType
type
UniquePtr
<
Sdp
>
answer
)
{
MOZ_ASSERT
(
mState
=
=
kJsepStateHaveRemoteOffer
)
;
mPendingLocalDescription
=
std
:
:
move
(
answer
)
;
nsresult
rv
=
HandleNegotiatedSession
(
mPendingLocalDescription
mPendingRemoteDescription
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCurrentRemoteDescription
=
std
:
:
move
(
mPendingRemoteDescription
)
;
mCurrentLocalDescription
=
std
:
:
move
(
mPendingLocalDescription
)
;
MOZ_ASSERT
(
!
mIsOfferer
)
;
mWasOffererLastTime
=
false
;
SetState
(
kJsepStateStable
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetRemoteDescription
(
JsepSdpType
type
const
std
:
:
string
&
sdp
)
{
mLastError
.
clear
(
)
;
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
SetRemoteDescription
type
=
"
<
<
type
<
<
"
\
nSDP
=
\
n
"
<
<
sdp
)
;
if
(
type
=
=
kJsepSdpRollback
)
{
if
(
mState
!
=
kJsepStateHaveRemoteOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
rollback
remote
description
in
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
mPendingRemoteDescription
.
reset
(
)
;
SetState
(
kJsepStateStable
)
;
RollbackRemoteOffer
(
)
;
return
NS_OK
;
}
switch
(
mState
)
{
case
kJsepStateStable
:
if
(
type
!
=
kJsepSdpOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
remote
answer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
mIsOfferer
=
false
;
break
;
case
kJsepStateHaveLocalOffer
:
case
kJsepStateHaveRemotePranswer
:
if
(
type
!
=
kJsepSdpAnswer
&
&
type
!
=
kJsepSdpPranswer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
remote
offer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
break
;
default
:
JSEP_SET_ERROR
(
"
Cannot
set
remote
offer
or
answer
in
current
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
UniquePtr
<
Sdp
>
parsed
;
nsresult
rv
=
ParseSdp
(
sdp
&
parsed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ValidateRemoteDescription
(
*
parsed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
switch
(
type
)
{
case
kJsepSdpOffer
:
rv
=
ValidateOffer
(
*
parsed
)
;
break
;
case
kJsepSdpAnswer
:
case
kJsepSdpPranswer
:
rv
=
ValidateAnswer
(
*
mPendingLocalDescription
*
parsed
)
;
break
;
case
kJsepSdpRollback
:
MOZ_CRASH
(
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
iceLite
=
parsed
-
>
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kIceLiteAttribute
)
;
bool
iceRestarting
=
false
;
if
(
mCurrentRemoteDescription
.
get
(
)
)
{
for
(
size_t
i
=
0
;
!
iceRestarting
&
&
i
<
mCurrentRemoteDescription
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
newMsection
=
parsed
-
>
GetMediaSection
(
i
)
;
const
SdpMediaSection
&
oldMsection
=
mCurrentRemoteDescription
-
>
GetMediaSection
(
i
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
newMsection
)
|
|
mSdpHelper
.
MsectionIsDisabled
(
oldMsection
)
)
{
continue
;
}
iceRestarting
=
mSdpHelper
.
IceCredentialsDiffer
(
newMsection
oldMsection
)
;
}
}
std
:
:
vector
<
std
:
:
string
>
iceOptions
;
if
(
parsed
-
>
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kIceOptionsAttribute
)
)
{
iceOptions
=
parsed
-
>
GetAttributeList
(
)
.
GetIceOptions
(
)
.
mValues
;
}
if
(
type
=
=
kJsepSdpOffer
)
{
mOldTransceivers
.
clear
(
)
;
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
mOldTransceivers
.
push_back
(
new
JsepTransceiver
(
*
transceiver
)
)
;
}
}
rv
=
UpdateTransceiversFromRemoteDescription
(
*
parsed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
size_t
i
=
0
;
i
<
parsed
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
MOZ_ASSERT
(
GetTransceiverForLevel
(
i
)
)
;
}
switch
(
type
)
{
case
kJsepSdpOffer
:
rv
=
SetRemoteDescriptionOffer
(
std
:
:
move
(
parsed
)
)
;
break
;
case
kJsepSdpAnswer
:
case
kJsepSdpPranswer
:
rv
=
SetRemoteDescriptionAnswer
(
type
std
:
:
move
(
parsed
)
)
;
break
;
case
kJsepSdpRollback
:
MOZ_CRASH
(
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
mRemoteIsIceLite
=
iceLite
;
mIceOptions
=
iceOptions
;
mRemoteIceIsRestarting
=
iceRestarting
;
}
return
rv
;
}
nsresult
JsepSessionImpl
:
:
HandleNegotiatedSession
(
const
UniquePtr
<
Sdp
>
&
local
const
UniquePtr
<
Sdp
>
&
remote
)
{
bool
remoteIceLite
=
remote
-
>
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kIceLiteAttribute
)
;
mIceControlling
=
remoteIceLite
|
|
mIsOfferer
;
const
Sdp
&
answer
=
mIsOfferer
?
*
remote
:
*
local
;
SdpHelper
:
:
BundledMids
bundledMids
;
nsresult
rv
=
mSdpHelper
.
GetBundledMids
(
answer
&
bundledMids
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
size_t
i
=
0
;
i
<
local
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
JsepTransceiver
*
transceiver
(
GetTransceiverForLevel
(
i
)
)
;
if
(
!
transceiver
)
{
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
i
)
;
return
NS_ERROR_FAILURE
;
}
if
(
answer
.
GetMediaSection
(
i
)
.
GetPort
(
)
=
=
0
)
{
transceiver
-
>
mTransport
-
>
Close
(
)
;
transceiver
-
>
Stop
(
)
;
transceiver
-
>
Disassociate
(
)
;
transceiver
-
>
ClearBundleLevel
(
)
;
transceiver
-
>
mSendTrack
.
SetActive
(
false
)
;
transceiver
-
>
mRecvTrack
.
SetActive
(
false
)
;
continue
;
}
size_t
transportLevel
=
i
;
bool
usingBundle
=
false
;
{
const
SdpMediaSection
&
answerMsection
(
answer
.
GetMediaSection
(
i
)
)
;
if
(
answerMsection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
)
{
if
(
bundledMids
.
count
(
answerMsection
.
GetAttributeList
(
)
.
GetMid
(
)
)
)
{
const
SdpMediaSection
*
masterBundleMsection
=
bundledMids
[
answerMsection
.
GetAttributeList
(
)
.
GetMid
(
)
]
;
transportLevel
=
masterBundleMsection
-
>
GetLevel
(
)
;
usingBundle
=
true
;
}
}
}
rv
=
MakeNegotiatedTransceiver
(
remote
-
>
GetMediaSection
(
i
)
local
-
>
GetMediaSection
(
i
)
usingBundle
transportLevel
transceiver
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
std
:
:
vector
<
JsepTrack
*
>
remoteTracks
;
for
(
const
RefPtr
<
JsepTransceiver
>
&
transceiver
:
mTransceivers
)
{
remoteTracks
.
push_back
(
&
transceiver
-
>
mRecvTrack
)
;
}
JsepTrack
:
:
SetUniquePayloadTypes
(
remoteTracks
)
;
mGeneratedLocalDescription
.
reset
(
)
;
mNegotiations
+
+
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
MakeNegotiatedTransceiver
(
const
SdpMediaSection
&
remote
const
SdpMediaSection
&
local
bool
usingBundle
size_t
transportLevel
JsepTransceiver
*
transceiver
)
{
const
SdpMediaSection
&
answer
=
mIsOfferer
?
remote
:
local
;
bool
sending
=
false
;
bool
receiving
=
false
;
if
(
!
transceiver
-
>
IsStopped
(
)
)
{
if
(
mIsOfferer
)
{
receiving
=
answer
.
IsSending
(
)
;
sending
=
answer
.
IsReceiving
(
)
;
}
else
{
sending
=
answer
.
IsSending
(
)
;
receiving
=
answer
.
IsReceiving
(
)
;
}
}
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiated
m
=
line
"
<
<
"
index
=
"
<
<
local
.
GetLevel
(
)
<
<
"
type
=
"
<
<
local
.
GetMediaType
(
)
<
<
"
sending
=
"
<
<
sending
<
<
"
receiving
=
"
<
<
receiving
)
;
transceiver
-
>
SetNegotiated
(
)
;
if
(
usingBundle
)
{
transceiver
-
>
SetBundleLevel
(
transportLevel
)
;
}
else
{
transceiver
-
>
ClearBundleLevel
(
)
;
}
if
(
transportLevel
!
=
remote
.
GetLevel
(
)
)
{
JsepTransceiver
*
bundleTransceiver
(
GetTransceiverForLevel
(
transportLevel
)
)
;
if
(
!
bundleTransceiver
)
{
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
transportLevel
)
;
return
NS_ERROR_FAILURE
;
}
transceiver
-
>
mTransport
=
bundleTransceiver
-
>
mTransport
;
}
else
{
nsresult
rv
=
FinalizeTransport
(
remote
.
GetAttributeList
(
)
answer
.
GetAttributeList
(
)
transceiver
-
>
mTransport
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
transceiver
-
>
mSendTrack
.
SetActive
(
sending
)
;
transceiver
-
>
mSendTrack
.
Negotiate
(
answer
remote
)
;
JsepTrack
&
recvTrack
=
transceiver
-
>
mRecvTrack
;
recvTrack
.
SetActive
(
receiving
)
;
recvTrack
.
Negotiate
(
answer
remote
)
;
if
(
transceiver
-
>
HasBundleLevel
(
)
&
&
recvTrack
.
GetSsrcs
(
)
.
empty
(
)
&
&
recvTrack
.
GetMediaType
(
)
!
=
SdpMediaSection
:
:
kApplication
)
{
MOZ_MTLOG
(
ML_ERROR
"
[
"
<
<
mName
<
<
"
]
:
Bundled
m
-
section
has
no
ssrc
"
"
attributes
.
This
may
cause
media
packets
to
be
"
"
dropped
.
"
)
;
}
if
(
transceiver
-
>
mTransport
-
>
mComponents
=
=
2
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
RTCP
-
MUX
is
off
"
)
;
}
if
(
local
.
GetMediaType
(
)
!
=
SdpMediaSection
:
:
kApplication
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBRTC_RTCP_MUX
transceiver
-
>
mTransport
-
>
mComponents
=
=
1
)
;
}
return
NS_OK
;
}
void
JsepSessionImpl
:
:
InitTransport
(
const
SdpMediaSection
&
msection
JsepTransport
*
transport
)
{
if
(
mSdpHelper
.
MsectionIsDisabled
(
msection
)
)
{
transport
-
>
Close
(
)
;
return
;
}
if
(
mSdpHelper
.
HasRtcp
(
msection
.
GetProtocol
(
)
)
)
{
transport
-
>
mComponents
=
2
;
}
else
{
transport
-
>
mComponents
=
1
;
}
if
(
msection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
)
{
transport
-
>
mTransportId
=
msection
.
GetAttributeList
(
)
.
GetMid
(
)
;
}
else
{
std
:
:
ostringstream
os
;
os
<
<
"
no_mid_lvl_
"
<
<
msection
.
GetLevel
(
)
;
transport
-
>
mTransportId
=
os
.
str
(
)
;
}
MOZ_ASSERT
(
transport
-
>
mTransportId
.
length
(
)
<
=
16
)
;
}
nsresult
JsepSessionImpl
:
:
FinalizeTransport
(
const
SdpAttributeList
&
remote
const
SdpAttributeList
&
answer
const
RefPtr
<
JsepTransport
>
&
transport
)
{
UniquePtr
<
JsepIceTransport
>
ice
=
MakeUnique
<
JsepIceTransport
>
(
)
;
ice
-
>
mUfrag
=
remote
.
GetIceUfrag
(
)
;
ice
-
>
mPwd
=
remote
.
GetIcePwd
(
)
;
if
(
remote
.
HasAttribute
(
SdpAttribute
:
:
kCandidateAttribute
)
)
{
ice
-
>
mCandidates
=
remote
.
GetCandidate
(
)
;
}
UniquePtr
<
JsepDtlsTransport
>
dtls
=
MakeUnique
<
JsepDtlsTransport
>
(
)
;
dtls
-
>
mFingerprints
=
remote
.
GetFingerprint
(
)
;
if
(
!
answer
.
HasAttribute
(
mozilla
:
:
SdpAttribute
:
:
kSetupAttribute
)
)
{
dtls
-
>
mRole
=
mIsOfferer
?
JsepDtlsTransport
:
:
kJsepDtlsServer
:
JsepDtlsTransport
:
:
kJsepDtlsClient
;
}
else
{
if
(
mIsOfferer
)
{
dtls
-
>
mRole
=
(
answer
.
GetSetup
(
)
.
mRole
=
=
SdpSetupAttribute
:
:
kActive
)
?
JsepDtlsTransport
:
:
kJsepDtlsServer
:
JsepDtlsTransport
:
:
kJsepDtlsClient
;
}
else
{
dtls
-
>
mRole
=
(
answer
.
GetSetup
(
)
.
mRole
=
=
SdpSetupAttribute
:
:
kActive
)
?
JsepDtlsTransport
:
:
kJsepDtlsClient
:
JsepDtlsTransport
:
:
kJsepDtlsServer
;
}
}
transport
-
>
mIce
=
std
:
:
move
(
ice
)
;
transport
-
>
mDtls
=
std
:
:
move
(
dtls
)
;
if
(
answer
.
HasAttribute
(
SdpAttribute
:
:
kRtcpMuxAttribute
)
)
{
transport
-
>
mComponents
=
1
;
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
AddTransportAttributes
(
SdpMediaSection
*
msection
SdpSetupAttribute
:
:
Role
dtlsRole
)
{
if
(
mIceUfrag
.
empty
(
)
|
|
mIcePwd
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Missing
ICE
ufrag
or
password
"
)
;
return
NS_ERROR_FAILURE
;
}
SdpAttributeList
&
attrList
=
msection
-
>
GetAttributeList
(
)
;
attrList
.
SetAttribute
(
new
SdpStringAttribute
(
SdpAttribute
:
:
kIceUfragAttribute
mIceUfrag
)
)
;
attrList
.
SetAttribute
(
new
SdpStringAttribute
(
SdpAttribute
:
:
kIcePwdAttribute
mIcePwd
)
)
;
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
new
SdpSetupAttribute
(
dtlsRole
)
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
CopyPreviousTransportParams
(
const
Sdp
&
oldAnswer
const
Sdp
&
offerersPreviousSdp
const
Sdp
&
newOffer
Sdp
*
newLocal
)
{
for
(
size_t
i
=
0
;
i
<
oldAnswer
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
if
(
!
mSdpHelper
.
MsectionIsDisabled
(
newLocal
-
>
GetMediaSection
(
i
)
)
&
&
mSdpHelper
.
AreOldTransportParamsValid
(
oldAnswer
offerersPreviousSdp
newOffer
i
)
&
&
!
mRemoteIceIsRestarting
)
{
JsepTransceiver
*
transceiver
(
GetTransceiverForLevel
(
i
)
)
;
if
(
!
transceiver
)
{
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
i
)
;
return
NS_ERROR_FAILURE
;
}
size_t
numComponents
=
transceiver
-
>
mTransport
-
>
mComponents
;
nsresult
rv
=
mSdpHelper
.
CopyTransportParams
(
numComponents
mCurrentLocalDescription
-
>
GetMediaSection
(
i
)
&
newLocal
-
>
GetMediaSection
(
i
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
void
JsepSessionImpl
:
:
CopyPreviousMsid
(
const
Sdp
&
oldLocal
Sdp
*
newLocal
)
{
for
(
size_t
i
=
0
;
i
<
oldLocal
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
oldMsection
(
oldLocal
.
GetMediaSection
(
i
)
)
;
SdpMediaSection
&
newMsection
(
newLocal
-
>
GetMediaSection
(
i
)
)
;
if
(
oldMsection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kMsidAttribute
)
&
&
!
mSdpHelper
.
MsectionIsDisabled
(
newMsection
)
)
{
newMsection
.
GetAttributeList
(
)
.
SetAttribute
(
new
SdpMsidAttributeList
(
oldMsection
.
GetAttributeList
(
)
.
GetMsid
(
)
)
)
;
}
}
}
nsresult
JsepSessionImpl
:
:
ParseSdp
(
const
std
:
:
string
&
sdp
UniquePtr
<
Sdp
>
*
parsedp
)
{
UniquePtr
<
Sdp
>
parsed
=
mSipccParser
.
Parse
(
sdp
)
;
if
(
!
parsed
)
{
std
:
:
string
error
=
"
Failed
to
parse
SDP
:
"
;
mSdpHelper
.
appendSdpParseErrors
(
mSipccParser
.
GetParseErrors
(
)
&
error
)
;
JSEP_SET_ERROR
(
error
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mRunRustParser
)
{
UniquePtr
<
Sdp
>
rustParsed
=
mRsdparsaParser
.
Parse
(
sdp
)
;
if
(
mRunSdpComparer
)
{
ParsingResultComparer
comparer
;
if
(
rustParsed
)
{
comparer
.
Compare
(
*
rustParsed
*
parsed
sdp
)
;
}
else
{
comparer
.
TrackRustParsingFailed
(
mSipccParser
.
GetParseErrors
(
)
.
size
(
)
)
;
}
}
}
if
(
!
parsed
-
>
GetMediaSectionCount
(
)
)
{
JSEP_SET_ERROR
(
"
Description
has
no
media
sections
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
for
(
size_t
i
=
0
;
i
<
parsed
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
if
(
mSdpHelper
.
MsectionIsDisabled
(
parsed
-
>
GetMediaSection
(
i
)
)
)
{
continue
;
}
const
SdpMediaSection
&
msection
(
parsed
-
>
GetMediaSection
(
i
)
)
;
auto
&
mediaAttrs
=
msection
.
GetAttributeList
(
)
;
if
(
mediaAttrs
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
&
&
mediaAttrs
.
GetMid
(
)
.
length
(
)
>
16
)
{
JSEP_SET_ERROR
(
"
Invalid
description
mid
length
greater
than
16
"
"
unsupported
until
2
-
byte
rtp
header
extensions
are
"
"
supported
in
webrtc
.
org
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mediaAttrs
.
GetIceUfrag
(
)
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Invalid
description
no
ice
-
ufrag
attribute
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mediaAttrs
.
GetIcePwd
(
)
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Invalid
description
no
ice
-
pwd
attribute
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mediaAttrs
.
HasAttribute
(
SdpAttribute
:
:
kFingerprintAttribute
)
)
{
JSEP_SET_ERROR
(
"
Invalid
description
no
fingerprint
attribute
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
SdpFingerprintAttributeList
&
fingerprints
(
mediaAttrs
.
GetFingerprint
(
)
)
;
if
(
fingerprints
.
mFingerprints
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Invalid
description
no
supported
fingerprint
algorithms
"
"
present
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mediaAttrs
.
HasAttribute
(
SdpAttribute
:
:
kSetupAttribute
true
)
&
&
mediaAttrs
.
GetSetup
(
)
.
mRole
=
=
SdpSetupAttribute
:
:
kHoldconn
)
{
JSEP_SET_ERROR
(
"
Description
has
illegal
setup
attribute
"
"
\
"
holdconn
\
"
in
m
-
section
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
static
const
std
:
:
bitset
<
128
>
forbidden
=
GetForbiddenSdpPayloadTypes
(
)
;
if
(
msection
.
GetMediaType
(
)
=
=
SdpMediaSection
:
:
kAudio
|
|
msection
.
GetMediaType
(
)
=
=
SdpMediaSection
:
:
kVideo
)
{
for
(
const
std
:
:
string
&
fmt
:
msection
.
GetFormats
(
)
)
{
uint16_t
payloadType
;
if
(
!
SdpHelper
:
:
GetPtAsInt
(
fmt
&
payloadType
)
)
{
JSEP_SET_ERROR
(
"
Payload
type
\
"
"
<
<
fmt
<
<
"
\
"
is
not
a
16
-
bit
unsigned
int
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
payloadType
>
127
)
{
JSEP_SET_ERROR
(
"
audio
/
video
payload
type
\
"
"
<
<
fmt
<
<
"
\
"
is
too
large
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
forbidden
.
test
(
payloadType
)
)
{
JSEP_SET_ERROR
(
"
Illegal
audio
/
video
payload
type
\
"
"
<
<
fmt
<
<
"
\
"
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
}
}
nsresult
rv
=
RemoveDuplicateTrackIds
(
parsed
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
parsedp
=
std
:
:
move
(
parsed
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetRemoteDescriptionOffer
(
UniquePtr
<
Sdp
>
offer
)
{
MOZ_ASSERT
(
mState
=
=
kJsepStateStable
)
;
mPendingRemoteDescription
=
std
:
:
move
(
offer
)
;
SetState
(
kJsepStateHaveRemoteOffer
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetRemoteDescriptionAnswer
(
JsepSdpType
type
UniquePtr
<
Sdp
>
answer
)
{
MOZ_ASSERT
(
mState
=
=
kJsepStateHaveLocalOffer
|
|
mState
=
=
kJsepStateHaveRemotePranswer
)
;
mPendingRemoteDescription
=
std
:
:
move
(
answer
)
;
nsresult
rv
=
HandleNegotiatedSession
(
mPendingLocalDescription
mPendingRemoteDescription
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCurrentRemoteDescription
=
std
:
:
move
(
mPendingRemoteDescription
)
;
mCurrentLocalDescription
=
std
:
:
move
(
mPendingLocalDescription
)
;
MOZ_ASSERT
(
mIsOfferer
)
;
mWasOffererLastTime
=
true
;
SetState
(
kJsepStateStable
)
;
return
NS_OK
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
GetTransceiverForLevel
(
size_t
level
)
{
for
(
RefPtr
<
JsepTransceiver
>
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
HasLevel
(
)
&
&
(
transceiver
-
>
GetLevel
(
)
=
=
level
)
)
{
return
transceiver
.
get
(
)
;
}
}
return
nullptr
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
GetTransceiverForLocal
(
size_t
level
)
{
if
(
JsepTransceiver
*
transceiver
=
GetTransceiverForLevel
(
level
)
)
{
if
(
WasMsectionDisabledLastNegotiation
(
level
)
&
&
transceiver
-
>
IsStopped
(
)
)
{
transceiver
-
>
Disassociate
(
)
;
JsepTransceiver
*
newTransceiver
=
FindUnassociatedTransceiver
(
transceiver
-
>
GetMediaType
(
)
false
)
;
if
(
newTransceiver
)
{
newTransceiver
-
>
SetLevel
(
level
)
;
transceiver
-
>
ClearLevel
(
)
;
return
newTransceiver
;
}
}
return
transceiver
;
}
for
(
RefPtr
<
JsepTransceiver
>
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
GetMediaType
(
)
!
=
SdpMediaSection
:
:
kApplication
&
&
!
transceiver
-
>
IsStopped
(
)
&
&
!
transceiver
-
>
HasLevel
(
)
)
{
transceiver
-
>
SetLevel
(
level
)
;
return
transceiver
.
get
(
)
;
}
}
for
(
RefPtr
<
JsepTransceiver
>
&
transceiver
:
mTransceivers
)
{
if
(
!
transceiver
-
>
IsStopped
(
)
&
&
!
transceiver
-
>
HasLevel
(
)
)
{
transceiver
-
>
SetLevel
(
level
)
;
return
transceiver
.
get
(
)
;
}
}
return
nullptr
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
GetTransceiverForRemote
(
const
SdpMediaSection
&
msection
)
{
size_t
level
=
msection
.
GetLevel
(
)
;
if
(
JsepTransceiver
*
transceiver
=
GetTransceiverForLevel
(
level
)
)
{
if
(
!
WasMsectionDisabledLastNegotiation
(
level
)
|
|
!
transceiver
-
>
IsStopped
(
)
)
{
return
transceiver
;
}
transceiver
-
>
Disassociate
(
)
;
transceiver
-
>
ClearLevel
(
)
;
}
JsepTransceiver
*
transceiver
=
FindUnassociatedTransceiver
(
msection
.
GetMediaType
(
)
true
)
;
if
(
transceiver
)
{
transceiver
-
>
SetLevel
(
level
)
;
return
transceiver
;
}
RefPtr
<
JsepTransceiver
>
newTransceiver
(
new
JsepTransceiver
(
msection
.
GetMediaType
(
)
SdpDirectionAttribute
:
:
kRecvonly
)
)
;
newTransceiver
-
>
SetLevel
(
level
)
;
newTransceiver
-
>
SetCreatedBySetRemote
(
)
;
nsresult
rv
=
AddTransceiver
(
newTransceiver
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
mTransceivers
.
back
(
)
.
get
(
)
;
}
nsresult
JsepSessionImpl
:
:
UpdateTransceiversFromRemoteDescription
(
const
Sdp
&
remote
)
{
for
(
size_t
i
=
0
;
i
<
remote
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
msection
=
remote
.
GetMediaSection
(
i
)
;
JsepTransceiver
*
transceiver
(
GetTransceiverForRemote
(
msection
)
)
;
if
(
!
transceiver
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mSdpHelper
.
MsectionIsDisabled
(
msection
)
)
{
transceiver
-
>
Associate
(
msection
.
GetAttributeList
(
)
.
GetMid
(
)
)
;
if
(
!
transceiver
-
>
IsAssociated
(
)
)
{
transceiver
-
>
Associate
(
GetNewMid
(
)
)
;
}
else
{
mUsedMids
.
insert
(
transceiver
-
>
GetMid
(
)
)
;
}
}
else
{
transceiver
-
>
Disassociate
(
)
;
transceiver
-
>
Stop
(
)
;
continue
;
}
if
(
msection
.
GetMediaType
(
)
=
=
SdpMediaSection
:
:
MediaType
:
:
kApplication
)
{
continue
;
}
if
(
msection
.
IsSending
(
)
&
&
transceiver
-
>
mRecvTrack
.
GetTrackId
(
)
.
empty
(
)
)
{
std
:
:
vector
<
std
:
:
string
>
streamIds
;
std
:
:
string
trackId
;
nsresult
rv
=
GetRemoteIds
(
remote
msection
&
streamIds
&
trackId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
transceiver
-
>
mRecvTrack
.
UpdateTrackIds
(
streamIds
trackId
)
;
}
transceiver
-
>
mRecvTrack
.
UpdateRecvTrack
(
remote
msection
)
;
}
return
NS_OK
;
}
bool
JsepSessionImpl
:
:
WasMsectionDisabledLastNegotiation
(
size_t
level
)
const
{
const
Sdp
*
answer
(
GetAnswer
(
)
)
;
if
(
answer
&
&
(
level
<
answer
-
>
GetMediaSectionCount
(
)
)
)
{
return
mSdpHelper
.
MsectionIsDisabled
(
answer
-
>
GetMediaSection
(
level
)
)
;
}
return
false
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
FindUnassociatedTransceiver
(
SdpMediaSection
:
:
MediaType
type
bool
magic
)
{
for
(
RefPtr
<
JsepTransceiver
>
&
transceiver
:
mTransceivers
)
{
if
(
!
transceiver
-
>
IsStopped
(
)
&
&
!
transceiver
-
>
HasLevel
(
)
&
&
(
!
magic
|
|
transceiver
-
>
HasAddTrackMagic
(
)
)
&
&
(
transceiver
-
>
GetMediaType
(
)
=
=
type
)
)
{
return
transceiver
.
get
(
)
;
}
}
return
nullptr
;
}
void
JsepSessionImpl
:
:
RollbackLocalOffer
(
)
{
for
(
size_t
i
=
0
;
i
<
mTransceivers
.
size
(
)
;
+
+
i
)
{
RefPtr
<
JsepTransceiver
>
&
transceiver
(
mTransceivers
[
i
]
)
;
if
(
i
<
mOldTransceivers
.
size
(
)
)
{
transceiver
-
>
Rollback
(
*
mOldTransceivers
[
i
]
)
;
continue
;
}
RefPtr
<
JsepTransceiver
>
temp
(
new
JsepTransceiver
(
transceiver
-
>
GetMediaType
(
)
)
)
;
transceiver
-
>
Rollback
(
*
temp
)
;
}
mOldTransceivers
.
clear
(
)
;
}
void
JsepSessionImpl
:
:
RollbackRemoteOffer
(
)
{
for
(
size_t
i
=
0
;
i
<
mTransceivers
.
size
(
)
;
+
+
i
)
{
RefPtr
<
JsepTransceiver
>
&
transceiver
(
mTransceivers
[
i
]
)
;
if
(
i
<
mOldTransceivers
.
size
(
)
)
{
transceiver
-
>
Rollback
(
*
mOldTransceivers
[
i
]
)
;
continue
;
}
bool
shouldRemove
=
!
transceiver
-
>
HasAddTrackMagic
(
)
&
&
transceiver
-
>
WasCreatedBySetRemote
(
)
;
RefPtr
<
JsepTransceiver
>
temp
(
new
JsepTransceiver
(
transceiver
-
>
GetMediaType
(
)
)
)
;
transceiver
-
>
Rollback
(
*
temp
)
;
if
(
shouldRemove
)
{
transceiver
-
>
Stop
(
)
;
transceiver
-
>
SetRemoved
(
)
;
mTransceivers
.
erase
(
mTransceivers
.
begin
(
)
+
i
)
;
-
-
i
;
}
}
mOldTransceivers
.
clear
(
)
;
}
nsresult
JsepSessionImpl
:
:
ValidateLocalDescription
(
const
Sdp
&
description
)
{
if
(
!
mGeneratedLocalDescription
)
{
JSEP_SET_ERROR
(
"
Calling
SetLocal
without
first
calling
CreateOffer
/
Answer
"
"
is
not
supported
.
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
description
.
GetMediaSectionCount
(
)
!
=
mGeneratedLocalDescription
-
>
GetMediaSectionCount
(
)
)
{
JSEP_SET_ERROR
(
"
Changing
the
number
of
m
-
sections
is
not
allowed
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
for
(
size_t
i
=
0
;
i
<
description
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
auto
&
origMsection
=
mGeneratedLocalDescription
-
>
GetMediaSection
(
i
)
;
auto
&
finalMsection
=
description
.
GetMediaSection
(
i
)
;
if
(
origMsection
.
GetMediaType
(
)
!
=
finalMsection
.
GetMediaType
(
)
)
{
JSEP_SET_ERROR
(
"
Changing
the
media
-
type
of
m
-
sections
is
not
allowed
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mCurrentLocalDescription
)
{
if
(
finalMsection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kCandidateAttribute
)
)
{
JSEP_SET_ERROR
(
"
Adding
your
own
candidate
attributes
is
not
supported
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
finalMsection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kEndOfCandidatesAttribute
)
)
{
JSEP_SET_ERROR
(
"
Why
are
you
trying
to
set
a
=
end
-
of
-
candidates
?
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
}
if
(
description
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kIceLiteAttribute
)
)
{
JSEP_SET_ERROR
(
"
Running
ICE
in
lite
mode
is
unsupported
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
ValidateRemoteDescription
(
const
Sdp
&
description
)
{
if
(
!
mCurrentRemoteDescription
|
|
!
mCurrentLocalDescription
)
{
return
NS_OK
;
}
if
(
mCurrentRemoteDescription
-
>
GetMediaSectionCount
(
)
>
description
.
GetMediaSectionCount
(
)
)
{
JSEP_SET_ERROR
(
"
New
remote
description
has
fewer
m
-
sections
than
the
"
"
previous
remote
description
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
SdpHelper
:
:
BundledMids
bundledMids
;
nsresult
rv
=
GetNegotiatedBundledMids
(
&
bundledMids
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SdpHelper
:
:
BundledMids
newBundledMids
;
rv
=
mSdpHelper
.
GetBundledMids
(
description
&
newBundledMids
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Maybe
<
bool
>
iceCredsDiffer
;
for
(
size_t
i
=
0
;
i
<
mCurrentRemoteDescription
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
newMsection
=
description
.
GetMediaSection
(
i
)
;
const
SdpMediaSection
&
oldMsection
=
mCurrentRemoteDescription
-
>
GetMediaSection
(
i
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
newMsection
)
|
|
mSdpHelper
.
MsectionIsDisabled
(
oldMsection
)
)
{
continue
;
}
if
(
oldMsection
.
GetMediaType
(
)
!
=
newMsection
.
GetMediaType
(
)
)
{
JSEP_SET_ERROR
(
"
Remote
description
changes
the
media
type
of
m
-
line
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
bool
differ
=
mSdpHelper
.
IceCredentialsDiffer
(
newMsection
oldMsection
)
;
if
(
mIsOfferer
&
&
differ
&
&
!
mLocalIceIsRestarting
)
{
JSEP_SET_ERROR
(
"
Remote
description
indicates
ICE
restart
but
offer
did
not
"
"
request
ICE
restart
(
new
remote
description
changes
either
"
"
the
ice
-
ufrag
or
ice
-
pwd
)
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
iceCredsDiffer
.
isSome
(
)
)
{
iceCredsDiffer
=
mozilla
:
:
Some
(
differ
)
;
}
else
if
(
iceCredsDiffer
.
isSome
(
)
&
&
*
iceCredsDiffer
!
=
differ
)
{
JSEP_SET_ERROR
(
"
Partial
ICE
restart
is
unsupported
at
this
time
"
"
(
new
remote
description
changes
either
the
ice
-
ufrag
"
"
or
ice
-
pwd
on
fewer
than
all
msections
)
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
ValidateOffer
(
const
Sdp
&
offer
)
{
for
(
size_t
i
=
0
;
i
<
offer
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
offerMsection
=
offer
.
GetMediaSection
(
i
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
offerMsection
)
)
{
continue
;
}
const
SdpAttributeList
&
offerAttrs
(
offerMsection
.
GetAttributeList
(
)
)
;
if
(
!
offerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kSetupAttribute
true
)
)
{
JSEP_SET_ERROR
(
"
Offer
is
missing
required
setup
attribute
"
"
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
ValidateAnswer
(
const
Sdp
&
offer
const
Sdp
&
answer
)
{
if
(
offer
.
GetMediaSectionCount
(
)
!
=
answer
.
GetMediaSectionCount
(
)
)
{
JSEP_SET_ERROR
(
"
Offer
and
answer
have
different
number
of
m
-
lines
"
<
<
"
(
"
<
<
offer
.
GetMediaSectionCount
(
)
<
<
"
vs
"
<
<
answer
.
GetMediaSectionCount
(
)
<
<
"
)
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
for
(
size_t
i
=
0
;
i
<
offer
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
offerMsection
=
offer
.
GetMediaSection
(
i
)
;
const
SdpMediaSection
&
answerMsection
=
answer
.
GetMediaSection
(
i
)
;
if
(
offerMsection
.
GetMediaType
(
)
!
=
answerMsection
.
GetMediaType
(
)
)
{
JSEP_SET_ERROR
(
"
Answer
and
offer
have
different
media
types
at
m
-
line
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
offerMsection
.
IsSending
(
)
&
&
answerMsection
.
IsReceiving
(
)
)
{
JSEP_SET_ERROR
(
"
Answer
tried
to
set
recv
when
offer
did
not
set
send
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
offerMsection
.
IsReceiving
(
)
&
&
answerMsection
.
IsSending
(
)
)
{
JSEP_SET_ERROR
(
"
Answer
tried
to
set
send
when
offer
did
not
set
recv
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
SdpAttributeList
&
answerAttrs
(
answerMsection
.
GetAttributeList
(
)
)
;
const
SdpAttributeList
&
offerAttrs
(
offerMsection
.
GetAttributeList
(
)
)
;
if
(
answerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
&
&
offerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
&
&
offerAttrs
.
GetMid
(
)
!
=
answerAttrs
.
GetMid
(
)
)
{
JSEP_SET_ERROR
(
"
Answer
changes
mid
for
level
was
\
'
"
<
<
offerMsection
.
GetAttributeList
(
)
.
GetMid
(
)
<
<
"
\
'
now
\
'
"
<
<
answerMsection
.
GetAttributeList
(
)
.
GetMid
(
)
<
<
"
\
'
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
answerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kSetupAttribute
true
)
&
&
answerAttrs
.
GetSetup
(
)
.
mRole
=
=
SdpSetupAttribute
:
:
kActpass
)
{
JSEP_SET_ERROR
(
"
Answer
contains
illegal
setup
attribute
\
"
actpass
\
"
"
"
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
answerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kExtmapAttribute
)
)
{
if
(
!
offerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kExtmapAttribute
)
)
{
JSEP_SET_ERROR
(
"
Answer
adds
extmap
attributes
to
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
for
(
const
auto
&
ansExt
:
answerAttrs
.
GetExtmap
(
)
.
mExtmaps
)
{
bool
found
=
false
;
for
(
const
auto
&
offExt
:
offerAttrs
.
GetExtmap
(
)
.
mExtmaps
)
{
if
(
ansExt
.
extensionname
=
=
offExt
.
extensionname
)
{
if
(
(
ansExt
.
direction
&
reverse
(
offExt
.
direction
)
)
!
=
ansExt
.
direction
)
{
MOZ_MTLOG
(
ML_WARNING
"
[
"
<
<
mName
<
<
"
]
:
Answer
has
inconsistent
"
"
direction
on
extmap
attribute
at
level
"
<
<
i
<
<
"
(
"
<
<
ansExt
.
extensionname
<
<
"
)
.
Offer
had
"
<
<
offExt
.
direction
<
<
"
answer
had
"
<
<
ansExt
.
direction
<
<
"
.
"
)
;
}
if
(
offExt
.
entry
<
4096
&
&
(
offExt
.
entry
!
=
ansExt
.
entry
)
)
{
JSEP_SET_ERROR
(
"
Answer
changed
id
for
extmap
attribute
at
level
"
<
<
i
<
<
"
(
"
<
<
offExt
.
extensionname
<
<
"
)
from
"
<
<
offExt
.
entry
<
<
"
to
"
<
<
ansExt
.
entry
<
<
"
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
ansExt
.
entry
>
=
4096
)
{
JSEP_SET_ERROR
(
"
Answer
used
an
invalid
id
(
"
<
<
ansExt
.
entry
<
<
"
)
for
extmap
attribute
at
level
"
<
<
i
<
<
"
(
"
<
<
ansExt
.
extensionname
<
<
"
)
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
found
=
true
;
break
;
}
}
if
(
!
found
)
{
JSEP_SET_ERROR
(
"
Answer
has
extmap
"
<
<
ansExt
.
extensionname
<
<
"
at
"
"
level
"
<
<
i
<
<
"
that
was
not
present
in
offer
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
}
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
CreateGenericSDP
(
UniquePtr
<
Sdp
>
*
sdpp
)
{
auto
origin
=
SdpOrigin
(
"
mozilla
.
.
.
THIS_IS_SDPARTA
-
"
MOZ_APP_UA_VERSION
mSessionId
mSessionVersion
sdp
:
:
kIPv4
"
0
.
0
.
0
.
0
"
)
;
UniquePtr
<
Sdp
>
sdp
=
MakeUnique
<
SipccSdp
>
(
origin
)
;
if
(
mDtlsFingerprints
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Missing
DTLS
fingerprint
"
)
;
return
NS_ERROR_FAILURE
;
}
UniquePtr
<
SdpFingerprintAttributeList
>
fpl
=
MakeUnique
<
SdpFingerprintAttributeList
>
(
)
;
for
(
auto
&
dtlsFingerprint
:
mDtlsFingerprints
)
{
fpl
-
>
PushEntry
(
dtlsFingerprint
.
mAlgorithm
dtlsFingerprint
.
mValue
)
;
}
sdp
-
>
GetAttributeList
(
)
.
SetAttribute
(
fpl
.
release
(
)
)
;
auto
*
iceOpts
=
new
SdpOptionsAttribute
(
SdpAttribute
:
:
kIceOptionsAttribute
)
;
iceOpts
-
>
PushEntry
(
"
trickle
"
)
;
sdp
-
>
GetAttributeList
(
)
.
SetAttribute
(
iceOpts
)
;
std
:
:
vector
<
std
:
:
string
>
msids
;
msids
.
push_back
(
"
*
"
)
;
mSdpHelper
.
SetupMsidSemantic
(
msids
sdp
.
get
(
)
)
;
*
sdpp
=
std
:
:
move
(
sdp
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetupIds
(
)
{
SECStatus
rv
=
PK11_GenerateRandom
(
reinterpret_cast
<
unsigned
char
*
>
(
&
mSessionId
)
sizeof
(
mSessionId
)
)
;
mSessionId
=
mSessionId
>
>
1
;
if
(
rv
!
=
SECSuccess
)
{
JSEP_SET_ERROR
(
"
Failed
to
generate
session
id
:
"
<
<
rv
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mUuidGen
-
>
Generate
(
&
mDefaultRemoteStreamId
)
)
{
JSEP_SET_ERROR
(
"
Failed
to
generate
default
uuid
for
streams
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mUuidGen
-
>
Generate
(
&
mCNAME
)
)
{
JSEP_SET_ERROR
(
"
Failed
to
generate
CNAME
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
JsepSessionImpl
:
:
SetupDefaultCodecs
(
)
{
mSupportedCodecs
.
values
.
push_back
(
new
JsepAudioCodecDescription
(
"
109
"
"
opus
"
48000
2
960
40000
)
)
;
mSupportedCodecs
.
values
.
push_back
(
new
JsepAudioCodecDescription
(
"
9
"
"
G722
"
8000
1
320
64000
)
)
;
mSupportedCodecs
.
values
.
push_back
(
new
JsepAudioCodecDescription
(
"
0
"
"
PCMU
"
8000
1
8000
/
50
8
*
8000
*
1
)
)
;
mSupportedCodecs
.
values
.
push_back
(
new
JsepAudioCodecDescription
(
"
8
"
"
PCMA
"
8000
1
8000
/
50
8
*
8000
*
1
)
)
;
mSupportedCodecs
.
values
.
push_back
(
new
JsepAudioCodecDescription
(
"
101
"
"
telephone
-
event
"
8000
1
0
0
)
)
;
JsepVideoCodecDescription
*
vp8
=
new
JsepVideoCodecDescription
(
"
120
"
"
VP8
"
90000
)
;
vp8
-
>
mConstraints
.
maxFs
=
12288
;
vp8
-
>
mConstraints
.
maxFps
=
60
;
mSupportedCodecs
.
values
.
push_back
(
vp8
)
;
JsepVideoCodecDescription
*
vp9
=
new
JsepVideoCodecDescription
(
"
121
"
"
VP9
"
90000
)
;
vp9
-
>
mConstraints
.
maxFs
=
12288
;
vp9
-
>
mConstraints
.
maxFps
=
60
;
mSupportedCodecs
.
values
.
push_back
(
vp9
)
;
JsepVideoCodecDescription
*
h264_1
=
new
JsepVideoCodecDescription
(
"
126
"
"
H264
"
90000
)
;
h264_1
-
>
mPacketizationMode
=
1
;
h264_1
-
>
mProfileLevelId
=
0x42E00D
;
mSupportedCodecs
.
values
.
push_back
(
h264_1
)
;
JsepVideoCodecDescription
*
h264_0
=
new
JsepVideoCodecDescription
(
"
97
"
"
H264
"
90000
)
;
h264_0
-
>
mPacketizationMode
=
0
;
h264_0
-
>
mProfileLevelId
=
0x42E00D
;
mSupportedCodecs
.
values
.
push_back
(
h264_0
)
;
JsepVideoCodecDescription
*
red
=
new
JsepVideoCodecDescription
(
"
122
"
"
red
"
90000
)
;
mSupportedCodecs
.
values
.
push_back
(
red
)
;
JsepVideoCodecDescription
*
ulpfec
=
new
JsepVideoCodecDescription
(
"
123
"
"
ulpfec
"
90000
)
;
mSupportedCodecs
.
values
.
push_back
(
ulpfec
)
;
mSupportedCodecs
.
values
.
push_back
(
new
JsepApplicationCodecDescription
(
"
webrtc
-
datachannel
"
WEBRTC_DATACHANNEL_STREAMS_DEFAULT
WEBRTC_DATACHANNEL_PORT_DEFAULT
WEBRTC_DATACHANNEL_MAX_MESSAGE_SIZE_LOCAL
)
)
;
red
-
>
UpdateRedundantEncodings
(
mSupportedCodecs
.
values
)
;
}
void
JsepSessionImpl
:
:
SetupDefaultRtpExtensions
(
)
{
AddAudioRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kAudioLevelUri
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
)
;
AddAudioRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kCsrcAudioLevelUri
SdpDirectionAttribute
:
:
Direction
:
:
kRecvonly
)
;
AddAudioVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kMIdUri
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
)
;
AddVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kAbsSendTimeUri
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
)
;
AddVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kTimestampOffsetUri
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
)
;
}
void
JsepSessionImpl
:
:
SetState
(
JsepSignalingState
state
)
{
if
(
state
=
=
mState
)
return
;
MOZ_MTLOG
(
ML_NOTICE
"
[
"
<
<
mName
<
<
"
]
:
"
<
<
GetStateStr
(
mState
)
<
<
"
-
>
"
<
<
GetStateStr
(
state
)
)
;
mState
=
state
;
}
nsresult
JsepSessionImpl
:
:
AddRemoteIceCandidate
(
const
std
:
:
string
&
candidate
const
std
:
:
string
&
mid
uint16_t
level
)
{
mLastError
.
clear
(
)
;
mozilla
:
:
Sdp
*
sdp
=
GetParsedRemoteDescription
(
kJsepDescriptionPendingOrCurrent
)
;
if
(
!
sdp
)
{
JSEP_SET_ERROR
(
"
Cannot
add
ICE
candidate
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
return
mSdpHelper
.
AddCandidateToSdp
(
sdp
candidate
mid
level
)
;
}
nsresult
JsepSessionImpl
:
:
AddLocalIceCandidate
(
const
std
:
:
string
&
candidate
uint16_t
level
std
:
:
string
*
mid
bool
*
skipped
)
{
mLastError
.
clear
(
)
;
mozilla
:
:
Sdp
*
sdp
=
GetParsedLocalDescription
(
kJsepDescriptionPendingOrCurrent
)
;
if
(
!
sdp
)
{
JSEP_SET_ERROR
(
"
Cannot
add
ICE
candidate
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
sdp
-
>
GetMediaSectionCount
(
)
<
=
level
)
{
*
skipped
=
true
;
return
NS_OK
;
}
if
(
mSdpHelper
.
MsectionIsDisabled
(
sdp
-
>
GetMediaSection
(
level
)
)
)
{
*
skipped
=
true
;
return
NS_OK
;
}
if
(
mState
=
=
kJsepStateStable
)
{
const
Sdp
*
answer
(
GetAnswer
(
)
)
;
if
(
mSdpHelper
.
IsBundleSlave
(
*
answer
level
)
)
{
*
skipped
=
true
;
return
NS_OK
;
}
}
nsresult
rv
=
mSdpHelper
.
GetMidFromLevel
(
*
sdp
level
mid
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
skipped
=
false
;
return
mSdpHelper
.
AddCandidateToSdp
(
sdp
candidate
*
mid
level
)
;
}
nsresult
JsepSessionImpl
:
:
UpdateDefaultCandidate
(
const
std
:
:
string
&
defaultCandidateAddr
uint16_t
defaultCandidatePort
const
std
:
:
string
&
defaultRtcpCandidateAddr
uint16_t
defaultRtcpCandidatePort
uint16_t
level
)
{
mLastError
.
clear
(
)
;
mozilla
:
:
Sdp
*
sdp
=
GetParsedLocalDescription
(
kJsepDescriptionPendingOrCurrent
)
;
if
(
!
sdp
)
{
JSEP_SET_ERROR
(
"
Cannot
add
ICE
candidate
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
level
>
=
sdp
-
>
GetMediaSectionCount
(
)
)
{
return
NS_OK
;
}
if
(
mSdpHelper
.
MsectionIsDisabled
(
sdp
-
>
GetMediaSection
(
level
)
)
)
{
return
NS_OK
;
}
std
:
:
string
defaultRtcpCandidateAddrCopy
(
defaultRtcpCandidateAddr
)
;
if
(
mState
=
=
kJsepStateStable
)
{
JsepTransceiver
*
transceiver
(
GetTransceiverForLevel
(
level
)
)
;
if
(
!
transceiver
)
{
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
level
)
;
return
NS_ERROR_FAILURE
;
}
if
(
transceiver
-
>
mTransport
-
>
mComponents
=
=
1
)
{
defaultRtcpCandidateAddrCopy
=
"
"
;
defaultRtcpCandidatePort
=
0
;
}
}
SdpHelper
:
:
BundledMids
bundledMids
;
if
(
mState
=
=
kJsepStateStable
)
{
nsresult
rv
=
GetNegotiatedBundledMids
(
&
bundledMids
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
)
;
mLastError
+
=
"
(
This
should
have
been
caught
sooner
!
)
"
;
return
NS_ERROR_FAILURE
;
}
}
mSdpHelper
.
SetDefaultAddresses
(
defaultCandidateAddr
defaultCandidatePort
defaultRtcpCandidateAddrCopy
defaultRtcpCandidatePort
sdp
level
bundledMids
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
EndOfLocalCandidates
(
uint16_t
level
)
{
mLastError
.
clear
(
)
;
mozilla
:
:
Sdp
*
sdp
=
GetParsedLocalDescription
(
kJsepDescriptionPendingOrCurrent
)
;
if
(
!
sdp
)
{
JSEP_SET_ERROR
(
"
Cannot
mark
end
of
local
ICE
candidates
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
level
>
=
sdp
-
>
GetMediaSectionCount
(
)
)
{
return
NS_OK
;
}
SdpHelper
:
:
BundledMids
bundledMids
;
if
(
mState
=
=
kJsepStateStable
)
{
nsresult
rv
=
GetNegotiatedBundledMids
(
&
bundledMids
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
)
;
mLastError
+
=
"
(
This
should
have
been
caught
sooner
!
)
"
;
return
NS_ERROR_FAILURE
;
}
}
mSdpHelper
.
SetIceGatheringComplete
(
sdp
level
bundledMids
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
GetNegotiatedBundledMids
(
SdpHelper
:
:
BundledMids
*
bundledMids
)
{
const
Sdp
*
answerSdp
=
GetAnswer
(
)
;
if
(
!
answerSdp
)
{
return
NS_OK
;
}
return
mSdpHelper
.
GetBundledMids
(
*
answerSdp
bundledMids
)
;
}
mozilla
:
:
Sdp
*
JsepSessionImpl
:
:
GetParsedLocalDescription
(
JsepDescriptionPendingOrCurrent
type
)
const
{
if
(
type
=
=
kJsepDescriptionPending
)
{
return
mPendingLocalDescription
.
get
(
)
;
}
else
if
(
mPendingLocalDescription
&
&
type
=
=
kJsepDescriptionPendingOrCurrent
)
{
return
mPendingLocalDescription
.
get
(
)
;
}
return
mCurrentLocalDescription
.
get
(
)
;
}
mozilla
:
:
Sdp
*
JsepSessionImpl
:
:
GetParsedRemoteDescription
(
JsepDescriptionPendingOrCurrent
type
)
const
{
if
(
type
=
=
kJsepDescriptionPending
)
{
return
mPendingRemoteDescription
.
get
(
)
;
}
else
if
(
mPendingRemoteDescription
&
&
type
=
=
kJsepDescriptionPendingOrCurrent
)
{
return
mPendingRemoteDescription
.
get
(
)
;
}
return
mCurrentRemoteDescription
.
get
(
)
;
}
const
Sdp
*
JsepSessionImpl
:
:
GetAnswer
(
)
const
{
return
mWasOffererLastTime
?
mCurrentRemoteDescription
.
get
(
)
:
mCurrentLocalDescription
.
get
(
)
;
}
nsresult
JsepSessionImpl
:
:
Close
(
)
{
mLastError
.
clear
(
)
;
SetState
(
kJsepStateClosed
)
;
return
NS_OK
;
}
const
std
:
:
string
JsepSessionImpl
:
:
GetLastError
(
)
const
{
return
mLastError
;
}
bool
JsepSessionImpl
:
:
CheckNegotiationNeeded
(
)
const
{
MOZ_ASSERT
(
mState
=
=
kJsepStateStable
)
;
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
IsStopped
(
)
)
{
if
(
transceiver
-
>
IsAssociated
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
of
"
"
stopped
transceiver
that
still
has
a
mid
.
"
)
;
return
true
;
}
continue
;
}
if
(
!
transceiver
-
>
IsAssociated
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
of
"
"
unassociated
(
but
not
stopped
)
transceiver
.
"
)
;
return
true
;
}
if
(
!
mCurrentLocalDescription
|
|
!
mCurrentRemoteDescription
)
{
MOZ_CRASH
(
"
Transceivers
should
not
be
associated
if
we
'
re
in
stable
"
"
before
the
first
negotiation
.
"
)
;
continue
;
}
if
(
!
transceiver
-
>
HasLevel
(
)
)
{
MOZ_CRASH
(
"
Associated
transceivers
should
always
have
a
level
.
"
)
;
continue
;
}
if
(
transceiver
-
>
GetMediaType
(
)
=
=
SdpMediaSection
:
:
kApplication
)
{
continue
;
}
size_t
level
=
transceiver
-
>
GetLevel
(
)
;
const
SdpMediaSection
&
local
=
mCurrentLocalDescription
-
>
GetMediaSection
(
level
)
;
const
SdpMediaSection
&
remote
=
mCurrentRemoteDescription
-
>
GetMediaSection
(
level
)
;
if
(
!
local
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kMsidAttribute
)
&
&
(
transceiver
-
>
mJsDirection
&
sdp
:
:
kSend
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
of
"
"
lack
of
a
=
msid
and
transceiver
is
sending
.
"
)
;
return
true
;
}
if
(
IsOfferer
(
)
)
{
if
(
(
local
.
GetDirection
(
)
!
=
transceiver
-
>
mJsDirection
)
&
&
reverse
(
remote
.
GetDirection
(
)
)
!
=
transceiver
-
>
mJsDirection
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
"
"
the
direction
on
our
offer
and
the
remote
answer
does
not
"
"
match
the
direction
on
a
transceiver
.
"
)
;
return
true
;
}
}
else
if
(
local
.
GetDirection
(
)
!
=
(
transceiver
-
>
mJsDirection
&
reverse
(
remote
.
GetDirection
(
)
)
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
"
"
the
direction
on
our
answer
doesn
'
t
match
the
direction
on
a
"
"
transceiver
even
though
the
remote
offer
would
have
allowed
"
"
it
.
"
)
;
return
true
;
}
}
return
false
;
}
}
