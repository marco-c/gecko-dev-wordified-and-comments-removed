#
ifndef
_JSEPTRACK_H_
#
define
_JSEPTRACK_H_
#
include
<
algorithm
>
#
include
<
string
>
#
include
<
map
>
#
include
<
set
>
#
include
<
mozilla
/
RefPtr
.
h
>
#
include
<
mozilla
/
UniquePtr
.
h
>
#
include
<
mozilla
/
Maybe
.
h
>
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsError
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepTransport
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepTrackEncoding
.
h
"
#
include
"
signaling
/
src
/
sdp
/
Sdp
.
h
"
#
include
"
signaling
/
src
/
sdp
/
SdpAttribute
.
h
"
#
include
"
signaling
/
src
/
sdp
/
SdpMediaSection
.
h
"
#
include
"
signaling
/
src
/
common
/
PtrVector
.
h
"
namespace
mozilla
{
class
JsepTrackNegotiatedDetails
{
public
:
size_t
GetEncodingCount
(
)
const
{
return
mEncodings
.
values
.
size
(
)
;
}
const
JsepTrackEncoding
&
GetEncoding
(
size_t
index
)
const
{
MOZ_RELEASE_ASSERT
(
index
<
mEncodings
.
values
.
size
(
)
)
;
return
*
mEncodings
.
values
[
index
]
;
}
const
SdpExtmapAttributeList
:
:
Extmap
*
GetExt
(
const
std
:
:
string
&
ext_name
)
const
{
auto
it
=
mExtmap
.
find
(
ext_name
)
;
if
(
it
!
=
mExtmap
.
end
(
)
)
{
return
&
it
-
>
second
;
}
return
nullptr
;
}
std
:
:
vector
<
uint8_t
>
GetUniquePayloadTypes
(
)
const
{
return
mUniquePayloadTypes
;
}
private
:
friend
class
JsepTrack
;
std
:
:
map
<
std
:
:
string
SdpExtmapAttributeList
:
:
Extmap
>
mExtmap
;
std
:
:
vector
<
uint8_t
>
mUniquePayloadTypes
;
PtrVector
<
JsepTrackEncoding
>
mEncodings
;
}
;
class
JsepTrack
{
public
:
JsepTrack
(
mozilla
:
:
SdpMediaSection
:
:
MediaType
type
const
std
:
:
string
&
streamid
const
std
:
:
string
&
trackid
sdp
:
:
Direction
direction
=
sdp
:
:
kSend
)
:
mType
(
type
)
mStreamId
(
streamid
)
mTrackId
(
trackid
)
mDirection
(
direction
)
{
}
virtual
mozilla
:
:
SdpMediaSection
:
:
MediaType
GetMediaType
(
)
const
{
return
mType
;
}
virtual
const
std
:
:
string
&
GetStreamId
(
)
const
{
return
mStreamId
;
}
virtual
void
SetStreamId
(
const
std
:
:
string
&
id
)
{
mStreamId
=
id
;
}
virtual
const
std
:
:
string
&
GetTrackId
(
)
const
{
return
mTrackId
;
}
virtual
void
SetTrackId
(
const
std
:
:
string
&
id
)
{
mTrackId
=
id
;
}
virtual
const
std
:
:
string
&
GetCNAME
(
)
const
{
return
mCNAME
;
}
virtual
void
SetCNAME
(
const
std
:
:
string
&
cname
)
{
mCNAME
=
cname
;
}
virtual
sdp
:
:
Direction
GetDirection
(
)
const
{
return
mDirection
;
}
virtual
const
std
:
:
vector
<
uint32_t
>
&
GetSsrcs
(
)
const
{
return
mSsrcs
;
}
virtual
void
AddSsrc
(
uint32_t
ssrc
)
{
mSsrcs
.
push_back
(
ssrc
)
;
}
virtual
void
PopulateCodecs
(
const
std
:
:
vector
<
JsepCodecDescription
*
>
&
prototype
)
;
template
<
class
UnaryFunction
>
void
ForEachCodec
(
UnaryFunction
&
func
)
{
std
:
:
for_each
(
mPrototypeCodecs
.
values
.
begin
(
)
mPrototypeCodecs
.
values
.
end
(
)
func
)
;
}
template
<
class
BinaryPredicate
>
void
SortCodecs
(
BinaryPredicate
&
sorter
)
{
std
:
:
stable_sort
(
mPrototypeCodecs
.
values
.
begin
(
)
mPrototypeCodecs
.
values
.
end
(
)
sorter
)
;
}
virtual
void
AddToOffer
(
SdpMediaSection
*
offer
)
const
;
virtual
void
AddToAnswer
(
const
SdpMediaSection
&
offer
SdpMediaSection
*
answer
)
const
;
virtual
void
Negotiate
(
const
SdpMediaSection
&
answer
const
SdpMediaSection
&
remote
)
;
static
void
SetUniquePayloadTypes
(
const
std
:
:
vector
<
RefPtr
<
JsepTrack
>
>
&
tracks
)
;
virtual
void
GetNegotiatedPayloadTypes
(
std
:
:
vector
<
uint16_t
>
*
payloadTypes
)
;
virtual
const
JsepTrackNegotiatedDetails
*
GetNegotiatedDetails
(
)
const
{
if
(
mNegotiatedDetails
)
{
return
mNegotiatedDetails
.
get
(
)
;
}
return
nullptr
;
}
virtual
JsepTrackNegotiatedDetails
*
GetNegotiatedDetails
(
)
{
if
(
mNegotiatedDetails
)
{
return
mNegotiatedDetails
.
get
(
)
;
}
return
nullptr
;
}
virtual
void
ClearNegotiatedDetails
(
)
{
mNegotiatedDetails
.
reset
(
)
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
JsepTrack
)
;
struct
JsConstraints
{
std
:
:
string
rid
;
EncodingConstraints
constraints
;
}
;
void
SetJsConstraints
(
const
std
:
:
vector
<
JsConstraints
>
&
constraintsList
)
{
mJsEncodeConstraints
=
constraintsList
;
}
void
GetJsConstraints
(
std
:
:
vector
<
JsConstraints
>
*
outConstraintsList
)
const
{
MOZ_ASSERT
(
outConstraintsList
)
;
*
outConstraintsList
=
mJsEncodeConstraints
;
}
static
void
AddToMsection
(
const
std
:
:
vector
<
JsConstraints
>
&
constraintsList
sdp
:
:
Direction
direction
SdpMediaSection
*
msection
)
;
protected
:
virtual
~
JsepTrack
(
)
{
}
private
:
std
:
:
vector
<
JsepCodecDescription
*
>
GetCodecClones
(
)
const
;
static
void
EnsureNoDuplicatePayloadTypes
(
std
:
:
vector
<
JsepCodecDescription
*
>
*
codecs
)
;
static
void
GetPayloadTypes
(
const
std
:
:
vector
<
JsepCodecDescription
*
>
&
codecs
std
:
:
vector
<
uint16_t
>
*
pts
)
;
static
void
EnsurePayloadTypeIsUnique
(
std
:
:
set
<
uint16_t
>
*
uniquePayloadTypes
JsepCodecDescription
*
codec
)
;
void
AddToMsection
(
const
std
:
:
vector
<
JsepCodecDescription
*
>
&
codecs
SdpMediaSection
*
msection
)
const
;
void
GetRids
(
const
SdpMediaSection
&
msection
sdp
:
:
Direction
direction
std
:
:
vector
<
SdpRidAttributeList
:
:
Rid
>
*
rids
)
const
;
void
CreateEncodings
(
const
SdpMediaSection
&
remote
const
std
:
:
vector
<
JsepCodecDescription
*
>
&
negotiatedCodecs
JsepTrackNegotiatedDetails
*
details
)
;
virtual
void
NegotiateCodecs
(
const
SdpMediaSection
&
remote
std
:
:
vector
<
JsepCodecDescription
*
>
*
codecs
const
SdpMediaSection
*
answer
=
nullptr
std
:
:
map
<
std
:
:
string
std
:
:
string
>
*
formatChanges
=
nullptr
)
const
;
JsConstraints
*
FindConstraints
(
const
std
:
:
string
&
rid
std
:
:
vector
<
JsConstraints
>
&
constraintsList
)
const
;
void
NegotiateRids
(
const
std
:
:
vector
<
SdpRidAttributeList
:
:
Rid
>
&
rids
std
:
:
vector
<
JsConstraints
>
*
constraints
)
const
;
const
mozilla
:
:
SdpMediaSection
:
:
MediaType
mType
;
std
:
:
string
mStreamId
;
std
:
:
string
mTrackId
;
std
:
:
string
mCNAME
;
const
sdp
:
:
Direction
mDirection
;
PtrVector
<
JsepCodecDescription
>
mPrototypeCodecs
;
std
:
:
vector
<
JsConstraints
>
mJsEncodeConstraints
;
UniquePtr
<
JsepTrackNegotiatedDetails
>
mNegotiatedDetails
;
std
:
:
vector
<
uint32_t
>
mSsrcs
;
}
;
struct
JsepTrackPair
{
size_t
mLevel
;
Maybe
<
size_t
>
mBundleLevel
;
uint32_t
mRecvonlySsrc
;
RefPtr
<
JsepTrack
>
mSending
;
RefPtr
<
JsepTrack
>
mReceiving
;
RefPtr
<
JsepTransport
>
mRtpTransport
;
RefPtr
<
JsepTransport
>
mRtcpTransport
;
}
;
}
#
endif
