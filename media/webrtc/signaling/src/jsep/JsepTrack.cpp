#
include
"
signaling
/
src
/
jsep
/
JsepTrack
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepCodecDescription
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepTrackEncoding
.
h
"
#
include
<
algorithm
>
#
include
<
iostream
>
namespace
mozilla
{
void
JsepTrack
:
:
GetNegotiatedPayloadTypes
(
std
:
:
vector
<
uint16_t
>
*
payloadTypes
)
const
{
if
(
!
mNegotiatedDetails
)
{
return
;
}
for
(
const
auto
&
encoding
:
mNegotiatedDetails
-
>
mEncodings
)
{
GetPayloadTypes
(
encoding
-
>
GetCodecs
(
)
payloadTypes
)
;
}
std
:
:
sort
(
payloadTypes
-
>
begin
(
)
payloadTypes
-
>
end
(
)
)
;
auto
newEnd
=
std
:
:
unique
(
payloadTypes
-
>
begin
(
)
payloadTypes
-
>
end
(
)
)
;
payloadTypes
-
>
erase
(
newEnd
payloadTypes
-
>
end
(
)
)
;
}
void
JsepTrack
:
:
GetPayloadTypes
(
const
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
codecs
std
:
:
vector
<
uint16_t
>
*
payloadTypes
)
{
for
(
const
auto
&
codec
:
codecs
)
{
uint16_t
pt
;
if
(
!
codec
-
>
GetPtAsInt
(
&
pt
)
)
{
MOZ_ASSERT
(
false
)
;
continue
;
}
payloadTypes
-
>
push_back
(
pt
)
;
}
}
void
JsepTrack
:
:
EnsureNoDuplicatePayloadTypes
(
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
*
codecs
)
{
std
:
:
set
<
uint16_t
>
uniquePayloadTypes
;
for
(
auto
&
codec
:
*
codecs
)
{
if
(
!
codec
-
>
mEnabled
|
|
!
codec
-
>
mName
.
compare
(
"
webrtc
-
datachannel
"
)
)
{
continue
;
}
codec
-
>
mEnabled
=
false
;
uint16_t
currentPt
;
if
(
!
codec
-
>
GetPtAsInt
(
&
currentPt
)
)
{
MOZ_ASSERT
(
false
)
;
continue
;
}
if
(
!
uniquePayloadTypes
.
count
(
currentPt
)
)
{
codec
-
>
mEnabled
=
true
;
uniquePayloadTypes
.
insert
(
currentPt
)
;
continue
;
}
for
(
uint16_t
freePt
=
96
;
freePt
<
=
127
;
+
+
freePt
)
{
if
(
!
uniquePayloadTypes
.
count
(
freePt
)
)
{
uniquePayloadTypes
.
insert
(
freePt
)
;
codec
-
>
mEnabled
=
true
;
std
:
:
ostringstream
os
;
os
<
<
freePt
;
codec
-
>
mDefaultPt
=
os
.
str
(
)
;
break
;
}
}
}
}
void
JsepTrack
:
:
EnsureSsrcs
(
SsrcGenerator
&
ssrcGenerator
)
{
if
(
mSsrcs
.
empty
(
)
)
{
uint32_t
ssrc
;
if
(
!
ssrcGenerator
.
GenerateSsrc
(
&
ssrc
)
)
{
return
;
}
mSsrcs
.
push_back
(
ssrc
)
;
}
}
void
JsepTrack
:
:
PopulateCodecs
(
const
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
prototype
)
{
mPrototypeCodecs
.
clear
(
)
;
for
(
const
auto
&
prototypeCodec
:
prototype
)
{
if
(
prototypeCodec
-
>
mType
=
=
mType
)
{
mPrototypeCodecs
.
emplace_back
(
prototypeCodec
-
>
Clone
(
)
)
;
mPrototypeCodecs
.
back
(
)
-
>
mDirection
=
mDirection
;
}
}
EnsureNoDuplicatePayloadTypes
(
&
mPrototypeCodecs
)
;
}
void
JsepTrack
:
:
AddToOffer
(
SsrcGenerator
&
ssrcGenerator
SdpMediaSection
*
offer
)
{
AddToMsection
(
mPrototypeCodecs
offer
)
;
if
(
mDirection
=
=
sdp
:
:
kSend
)
{
std
:
:
vector
<
JsConstraints
>
constraints
;
if
(
offer
-
>
IsSending
(
)
)
{
constraints
=
mJsEncodeConstraints
;
}
AddToMsection
(
constraints
sdp
:
:
kSend
ssrcGenerator
offer
)
;
}
}
void
JsepTrack
:
:
AddToAnswer
(
const
SdpMediaSection
&
offer
SsrcGenerator
&
ssrcGenerator
SdpMediaSection
*
answer
)
{
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
codecs
=
NegotiateCodecs
(
offer
true
)
;
if
(
codecs
.
empty
(
)
)
{
return
;
}
AddToMsection
(
codecs
answer
)
;
if
(
mDirection
=
=
sdp
:
:
kSend
)
{
std
:
:
vector
<
JsConstraints
>
constraints
;
if
(
answer
-
>
IsSending
(
)
)
{
constraints
=
mJsEncodeConstraints
;
std
:
:
vector
<
std
:
:
pair
<
SdpRidAttributeList
:
:
Rid
bool
>
>
rids
;
GetRids
(
offer
sdp
:
:
kRecv
&
rids
)
;
NegotiateRids
(
rids
&
constraints
)
;
}
AddToMsection
(
constraints
sdp
:
:
kSend
ssrcGenerator
answer
)
;
}
}
bool
JsepTrack
:
:
SetJsConstraints
(
const
std
:
:
vector
<
JsConstraints
>
&
constraintsList
)
{
bool
constraintsChanged
=
mJsEncodeConstraints
!
=
constraintsList
;
mJsEncodeConstraints
=
constraintsList
;
if
(
!
mNegotiatedDetails
)
{
return
constraintsChanged
;
}
for
(
auto
&
encoding
:
mNegotiatedDetails
-
>
mEncodings
)
{
for
(
const
JsConstraints
&
jsConstraints
:
mJsEncodeConstraints
)
{
if
(
jsConstraints
.
rid
=
=
encoding
-
>
mRid
)
{
encoding
-
>
mConstraints
=
jsConstraints
.
constraints
;
}
}
}
return
constraintsChanged
;
}
void
JsepTrack
:
:
AddToMsection
(
const
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
codecs
SdpMediaSection
*
msection
)
{
MOZ_ASSERT
(
msection
-
>
GetMediaType
(
)
=
=
mType
)
;
MOZ_ASSERT
(
!
codecs
.
empty
(
)
)
;
for
(
const
auto
&
codec
:
codecs
)
{
codec
-
>
AddToMediaSection
(
*
msection
)
;
}
if
(
(
mDirection
=
=
sdp
:
:
kSend
)
&
&
(
mType
!
=
SdpMediaSection
:
:
kApplication
)
&
&
msection
-
>
IsSending
(
)
)
{
if
(
mStreamIds
.
empty
(
)
)
{
msection
-
>
AddMsid
(
"
-
"
mTrackId
)
;
}
else
{
for
(
const
std
:
:
string
&
streamId
:
mStreamIds
)
{
msection
-
>
AddMsid
(
streamId
mTrackId
)
;
}
}
}
}
void
JsepTrack
:
:
NegotiateRids
(
const
std
:
:
vector
<
std
:
:
pair
<
SdpRidAttributeList
:
:
Rid
bool
>
>
&
rids
std
:
:
vector
<
JsConstraints
>
*
constraintsList
)
const
{
for
(
const
auto
&
ridAndPaused
:
rids
)
{
if
(
!
FindConstraints
(
ridAndPaused
.
first
.
id
*
constraintsList
)
)
{
JsConstraints
*
constraints
=
FindConstraints
(
"
"
*
constraintsList
)
;
if
(
constraints
)
{
constraints
-
>
rid
=
ridAndPaused
.
first
.
id
;
constraints
-
>
paused
=
ridAndPaused
.
second
;
}
}
}
}
void
JsepTrack
:
:
UpdateSsrcs
(
SsrcGenerator
&
ssrcGenerator
size_t
encodings
)
{
MOZ_ASSERT
(
mDirection
=
=
sdp
:
:
kSend
)
;
MOZ_ASSERT
(
mType
!
=
SdpMediaSection
:
:
kApplication
)
;
size_t
numSsrcs
=
std
:
:
max
<
size_t
>
(
encodings
1U
)
;
while
(
mSsrcs
.
size
(
)
<
numSsrcs
)
{
uint32_t
ssrc
;
if
(
!
ssrcGenerator
.
GenerateSsrc
(
&
ssrc
)
)
{
return
;
}
mSsrcs
.
push_back
(
ssrc
)
;
}
mSsrcs
.
resize
(
numSsrcs
)
;
MOZ_ASSERT
(
!
mSsrcs
.
empty
(
)
)
;
}
void
JsepTrack
:
:
AddToMsection
(
const
std
:
:
vector
<
JsConstraints
>
&
constraintsList
sdp
:
:
Direction
direction
SsrcGenerator
&
ssrcGenerator
SdpMediaSection
*
msection
)
{
UniquePtr
<
SdpSimulcastAttribute
>
simulcast
(
new
SdpSimulcastAttribute
)
;
UniquePtr
<
SdpRidAttributeList
>
rids
(
new
SdpRidAttributeList
)
;
for
(
const
JsConstraints
&
constraints
:
constraintsList
)
{
if
(
!
constraints
.
rid
.
empty
(
)
)
{
SdpRidAttributeList
:
:
Rid
rid
;
rid
.
id
=
constraints
.
rid
;
rid
.
direction
=
direction
;
rids
-
>
mRids
.
push_back
(
rid
)
;
SdpSimulcastAttribute
:
:
Version
version
;
version
.
choices
.
push_back
(
SdpSimulcastAttribute
:
:
Encoding
(
constraints
.
rid
false
)
)
;
if
(
direction
=
=
sdp
:
:
kSend
)
{
simulcast
-
>
sendVersions
.
push_back
(
version
)
;
}
else
{
simulcast
-
>
recvVersions
.
push_back
(
version
)
;
}
}
}
if
(
rids
-
>
mRids
.
size
(
)
>
1
)
{
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
simulcast
.
release
(
)
)
;
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
rids
.
release
(
)
)
;
}
if
(
mType
!
=
SdpMediaSection
:
:
kApplication
&
&
mDirection
=
=
sdp
:
:
kSend
)
{
UpdateSsrcs
(
ssrcGenerator
constraintsList
.
size
(
)
)
;
msection
-
>
SetSsrcs
(
mSsrcs
mCNAME
)
;
}
}
void
JsepTrack
:
:
GetRids
(
const
SdpMediaSection
&
msection
sdp
:
:
Direction
direction
std
:
:
vector
<
std
:
:
pair
<
SdpRidAttributeList
:
:
Rid
bool
>
>
*
rids
)
const
{
rids
-
>
clear
(
)
;
if
(
!
msection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kSimulcastAttribute
)
)
{
return
;
}
const
SdpSimulcastAttribute
&
simulcast
(
msection
.
GetAttributeList
(
)
.
GetSimulcast
(
)
)
;
const
SdpSimulcastAttribute
:
:
Versions
*
versions
=
nullptr
;
switch
(
direction
)
{
case
sdp
:
:
kSend
:
versions
=
&
simulcast
.
sendVersions
;
break
;
case
sdp
:
:
kRecv
:
versions
=
&
simulcast
.
recvVersions
;
break
;
}
if
(
!
versions
-
>
IsSet
(
)
)
{
return
;
}
for
(
const
SdpSimulcastAttribute
:
:
Version
&
version
:
*
versions
)
{
if
(
!
version
.
choices
.
empty
(
)
)
{
rids
-
>
push_back
(
std
:
:
make_pair
(
*
msection
.
FindRid
(
version
.
choices
[
0
]
.
rid
)
version
.
choices
[
0
]
.
paused
)
)
;
}
}
}
JsepTrack
:
:
JsConstraints
*
JsepTrack
:
:
FindConstraints
(
const
std
:
:
string
&
id
std
:
:
vector
<
JsConstraints
>
&
constraintsList
)
const
{
for
(
JsConstraints
&
constraints
:
constraintsList
)
{
if
(
constraints
.
rid
=
=
id
)
{
return
&
constraints
;
}
}
return
nullptr
;
}
void
JsepTrack
:
:
CreateEncodings
(
const
SdpMediaSection
&
remote
const
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
negotiatedCodecs
JsepTrackNegotiatedDetails
*
negotiatedDetails
)
{
negotiatedDetails
-
>
mTias
=
remote
.
GetBandwidth
(
"
TIAS
"
)
;
std
:
:
vector
<
std
:
:
pair
<
SdpRidAttributeList
:
:
Rid
bool
>
>
rids
;
GetRids
(
remote
sdp
:
:
kRecv
&
rids
)
;
NegotiateRids
(
rids
&
mJsEncodeConstraints
)
;
if
(
rids
.
empty
(
)
)
{
rids
.
push_back
(
std
:
:
make_pair
(
SdpRidAttributeList
:
:
Rid
(
)
false
)
)
;
}
size_t
max_streams
=
1
;
if
(
!
mJsEncodeConstraints
.
empty
(
)
)
{
max_streams
=
std
:
:
min
(
rids
.
size
(
)
mJsEncodeConstraints
.
size
(
)
)
;
}
if
(
mSsrcs
.
size
(
)
>
max_streams
)
{
mSsrcs
.
resize
(
max_streams
)
;
}
for
(
size_t
i
=
0
;
i
<
max_streams
;
+
+
i
)
{
if
(
i
=
=
negotiatedDetails
-
>
mEncodings
.
size
(
)
)
{
negotiatedDetails
-
>
mEncodings
.
emplace_back
(
new
JsepTrackEncoding
)
;
}
auto
&
encoding
=
negotiatedDetails
-
>
mEncodings
[
i
]
;
for
(
const
auto
&
codec
:
negotiatedCodecs
)
{
if
(
rids
[
i
]
.
first
.
HasFormat
(
codec
-
>
mDefaultPt
)
)
{
encoding
-
>
AddCodec
(
*
codec
)
;
}
}
encoding
-
>
mRid
=
rids
[
i
]
.
first
.
id
;
encoding
-
>
mPaused
=
rids
[
i
]
.
second
;
for
(
const
JsConstraints
&
jsConstraints
:
mJsEncodeConstraints
)
{
if
(
jsConstraints
.
rid
=
=
rids
[
i
]
.
first
.
id
)
{
encoding
-
>
mConstraints
=
jsConstraints
.
constraints
;
}
}
}
}
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
JsepTrack
:
:
GetCodecClones
(
)
const
{
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
clones
;
for
(
const
auto
&
codec
:
mPrototypeCodecs
)
{
clones
.
emplace_back
(
codec
-
>
Clone
(
)
)
;
}
return
clones
;
}
static
bool
CompareCodec
(
const
UniquePtr
<
JsepCodecDescription
>
&
lhs
const
UniquePtr
<
JsepCodecDescription
>
&
rhs
)
{
return
lhs
-
>
mStronglyPreferred
&
&
!
rhs
-
>
mStronglyPreferred
;
}
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
JsepTrack
:
:
NegotiateCodecs
(
const
SdpMediaSection
&
remote
bool
isOffer
)
{
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
negotiatedCodecs
;
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
newPrototypeCodecs
;
for
(
const
std
:
:
string
&
fmt
:
remote
.
GetFormats
(
)
)
{
for
(
auto
&
codec
:
mPrototypeCodecs
)
{
if
(
!
codec
|
|
!
codec
-
>
mEnabled
|
|
!
codec
-
>
Matches
(
fmt
remote
)
)
{
continue
;
}
UniquePtr
<
JsepCodecDescription
>
clone
(
codec
-
>
Clone
(
)
)
;
if
(
clone
-
>
Negotiate
(
fmt
remote
isOffer
)
)
{
codec
-
>
mDefaultPt
=
clone
-
>
mDefaultPt
;
newPrototypeCodecs
.
emplace_back
(
std
:
:
move
(
codec
)
)
;
negotiatedCodecs
.
emplace_back
(
std
:
:
move
(
clone
)
)
;
break
;
}
}
}
for
(
auto
&
codec
:
mPrototypeCodecs
)
{
if
(
codec
)
{
newPrototypeCodecs
.
emplace_back
(
std
:
:
move
(
codec
)
)
;
}
}
EnsureNoDuplicatePayloadTypes
(
&
newPrototypeCodecs
)
;
std
:
:
swap
(
newPrototypeCodecs
mPrototypeCodecs
)
;
JsepVideoCodecDescription
*
red
=
nullptr
;
JsepVideoCodecDescription
*
ulpfec
=
nullptr
;
JsepAudioCodecDescription
*
dtmf
=
nullptr
;
for
(
auto
&
codec
:
negotiatedCodecs
)
{
if
(
codec
-
>
mName
=
=
"
red
"
)
{
red
=
static_cast
<
JsepVideoCodecDescription
*
>
(
codec
.
get
(
)
)
;
}
else
if
(
codec
-
>
mName
=
=
"
ulpfec
"
)
{
ulpfec
=
static_cast
<
JsepVideoCodecDescription
*
>
(
codec
.
get
(
)
)
;
}
else
if
(
codec
-
>
mName
=
=
"
telephone
-
event
"
)
{
dtmf
=
static_cast
<
JsepAudioCodecDescription
*
>
(
codec
.
get
(
)
)
;
}
}
if
(
red
)
{
std
:
:
vector
<
uint8_t
>
unnegotiatedEncodings
;
std
:
:
swap
(
unnegotiatedEncodings
red
-
>
mRedundantEncodings
)
;
for
(
auto
redundantPt
:
unnegotiatedEncodings
)
{
std
:
:
string
pt
=
std
:
:
to_string
(
redundantPt
)
;
for
(
const
auto
&
codec
:
negotiatedCodecs
)
{
if
(
pt
=
=
codec
-
>
mDefaultPt
)
{
red
-
>
mRedundantEncodings
.
push_back
(
redundantPt
)
;
break
;
}
}
}
}
if
(
red
&
&
ulpfec
)
{
for
(
auto
&
codec
:
negotiatedCodecs
)
{
if
(
codec
-
>
mName
!
=
"
red
"
&
&
codec
-
>
mName
!
=
"
ulpfec
"
)
{
JsepVideoCodecDescription
*
videoCodec
=
static_cast
<
JsepVideoCodecDescription
*
>
(
codec
.
get
(
)
)
;
videoCodec
-
>
EnableFec
(
red
-
>
mDefaultPt
ulpfec
-
>
mDefaultPt
)
;
}
}
}
if
(
dtmf
)
{
for
(
auto
&
codec
:
negotiatedCodecs
)
{
JsepAudioCodecDescription
*
audioCodec
=
static_cast
<
JsepAudioCodecDescription
*
>
(
codec
.
get
(
)
)
;
audioCodec
-
>
mDtmfEnabled
=
true
;
}
}
std
:
:
stable_sort
(
negotiatedCodecs
.
begin
(
)
negotiatedCodecs
.
end
(
)
CompareCodec
)
;
if
(
!
red
)
{
negotiatedCodecs
.
erase
(
std
:
:
remove_if
(
negotiatedCodecs
.
begin
(
)
negotiatedCodecs
.
end
(
)
[
ulpfec
]
(
const
UniquePtr
<
JsepCodecDescription
>
&
codec
)
{
return
codec
.
get
(
)
=
=
ulpfec
;
}
)
negotiatedCodecs
.
end
(
)
)
;
ulpfec
=
nullptr
;
}
return
negotiatedCodecs
;
}
void
JsepTrack
:
:
Negotiate
(
const
SdpMediaSection
&
answer
const
SdpMediaSection
&
remote
)
{
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
negotiatedCodecs
=
NegotiateCodecs
(
remote
&
answer
!
=
&
remote
)
;
UniquePtr
<
JsepTrackNegotiatedDetails
>
negotiatedDetails
=
MakeUnique
<
JsepTrackNegotiatedDetails
>
(
)
;
CreateEncodings
(
remote
negotiatedCodecs
negotiatedDetails
.
get
(
)
)
;
if
(
answer
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kExtmapAttribute
)
)
{
for
(
auto
&
extmapAttr
:
answer
.
GetAttributeList
(
)
.
GetExtmap
(
)
.
mExtmaps
)
{
SdpDirectionAttribute
:
:
Direction
direction
=
extmapAttr
.
direction
;
if
(
&
remote
=
=
&
answer
)
{
direction
=
reverse
(
direction
)
;
}
if
(
direction
&
mDirection
)
{
negotiatedDetails
-
>
mExtmap
[
extmapAttr
.
extensionname
]
=
extmapAttr
;
}
}
}
mNegotiatedDetails
=
std
:
:
move
(
negotiatedDetails
)
;
}
void
JsepTrack
:
:
SetUniquePayloadTypes
(
std
:
:
vector
<
JsepTrack
*
>
&
tracks
)
{
std
:
:
map
<
uint16_t
JsepTrackNegotiatedDetails
*
>
payloadTypeToDetailsMap
;
for
(
JsepTrack
*
track
:
tracks
)
{
if
(
track
-
>
GetMediaType
(
)
=
=
SdpMediaSection
:
:
kApplication
)
{
continue
;
}
auto
*
details
=
track
-
>
GetNegotiatedDetails
(
)
;
if
(
!
details
)
{
continue
;
}
std
:
:
vector
<
uint16_t
>
payloadTypesForTrack
;
track
-
>
GetNegotiatedPayloadTypes
(
&
payloadTypesForTrack
)
;
for
(
uint16_t
pt
:
payloadTypesForTrack
)
{
if
(
payloadTypeToDetailsMap
.
count
(
pt
)
)
{
payloadTypeToDetailsMap
[
pt
]
=
nullptr
;
}
else
{
payloadTypeToDetailsMap
[
pt
]
=
details
;
}
}
}
for
(
auto
ptAndDetails
:
payloadTypeToDetailsMap
)
{
uint16_t
uniquePt
=
ptAndDetails
.
first
;
MOZ_ASSERT
(
uniquePt
<
=
UINT8_MAX
)
;
auto
trackDetails
=
ptAndDetails
.
second
;
if
(
trackDetails
)
{
trackDetails
-
>
mUniquePayloadTypes
.
push_back
(
static_cast
<
uint8_t
>
(
uniquePt
)
)
;
}
}
}
}
