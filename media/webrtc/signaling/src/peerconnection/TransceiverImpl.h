#
ifndef
_TRANSCEIVERIMPL_H_
#
define
_TRANSCEIVERIMPL_H_
#
include
<
string
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrack
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
mtransport
/
transportflow
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepTransceiver
.
h
"
class
nsIPrincipal
;
namespace
mozilla
{
class
PeerIdentity
;
class
PeerConnectionMedia
;
class
JsepTransceiver
;
class
MediaSessionConduit
;
class
VideoSessionConduit
;
class
MediaPipelineReceive
;
class
MediaPipelineTransmit
;
class
MediaPipeline
;
class
MediaPipelineFilter
;
class
WebRtcCallWrapper
;
class
JsepTrackNegotiatedDetails
;
namespace
dom
{
class
RTCRtpTransceiver
;
struct
RTCRtpSourceEntry
;
}
class
TransceiverImpl
:
public
nsISupports
{
public
:
TransceiverImpl
(
const
std
:
:
string
&
aPCHandle
JsepTransceiver
*
aJsepTransceiver
nsIEventTarget
*
aMainThread
nsIEventTarget
*
aStsThread
dom
:
:
MediaStreamTrack
*
aReceiveTrack
dom
:
:
MediaStreamTrack
*
aSendTrack
WebRtcCallWrapper
*
aCallWrapper
)
;
bool
IsValid
(
)
const
{
return
!
!
mConduit
;
}
nsresult
UpdateSendTrack
(
dom
:
:
MediaStreamTrack
*
aSendTrack
)
;
nsresult
UpdateSinkIdentity
(
const
dom
:
:
MediaStreamTrack
*
aTrack
nsIPrincipal
*
aPrincipal
const
PeerIdentity
*
aSinkIdentity
)
;
nsresult
UpdateTransport
(
PeerConnectionMedia
&
aTransportManager
)
;
nsresult
UpdateConduit
(
)
;
nsresult
UpdatePrincipal
(
nsIPrincipal
*
aPrincipal
)
;
nsresult
SyncWithMatchingVideoConduits
(
std
:
:
vector
<
RefPtr
<
TransceiverImpl
>
>
&
transceivers
)
;
void
Shutdown_m
(
)
;
bool
ConduitHasPluginID
(
uint64_t
aPluginID
)
;
bool
HasSendTrack
(
const
dom
:
:
MediaStreamTrack
*
aSendTrack
)
const
;
RefPtr
<
dom
:
:
MediaStreamTrack
>
GetSendTrack
(
)
{
return
mSendTrack
;
}
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
;
already_AddRefed
<
dom
:
:
MediaStreamTrack
>
GetReceiveTrack
(
)
;
void
SyncWithJS
(
dom
:
:
RTCRtpTransceiver
&
aJsTransceiver
ErrorResult
&
aRv
)
;
void
InsertDTMFTone
(
int
tone
uint32_t
duration
)
;
bool
HasReceiveTrack
(
const
dom
:
:
MediaStreamTrack
*
aReceiveTrack
)
const
;
RefPtr
<
MediaPipeline
>
GetSendPipeline
(
)
;
RefPtr
<
MediaPipeline
>
GetReceivePipeline
(
)
;
void
AddRIDExtension
(
unsigned
short
aExtensionId
)
;
void
AddRIDFilter
(
const
nsAString
&
aRid
)
;
bool
IsVideo
(
)
const
;
void
GetRtpSources
(
const
int64_t
aTimeNow
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
&
outSources
)
const
;
void
InsertAudioLevelForContributingSource
(
uint32_t
aSource
int64_t
aTimestamp
bool
aHasLevel
uint8_t
aLevel
)
;
NS_DECL_THREADSAFE_ISUPPORTS
private
:
virtual
~
TransceiverImpl
(
)
;
void
InitAudio
(
)
;
void
InitVideo
(
)
;
nsresult
UpdateAudioConduit
(
)
;
nsresult
UpdateVideoConduit
(
)
;
nsresult
ConfigureVideoCodecMode
(
VideoSessionConduit
&
aConduit
)
;
void
UpdateVideoExtmap
(
const
JsepTrackNegotiatedDetails
&
aDetails
bool
aSending
)
;
void
Stop
(
)
;
const
std
:
:
string
mPCHandle
;
RefPtr
<
JsepTransceiver
>
mJsepTransceiver
;
std
:
:
string
mMid
;
bool
mHaveStartedReceiving
;
bool
mHaveSetupTransport
;
nsCOMPtr
<
nsIEventTarget
>
mMainThread
;
nsCOMPtr
<
nsIEventTarget
>
mStsThread
;
RefPtr
<
dom
:
:
MediaStreamTrack
>
mReceiveTrack
;
RefPtr
<
dom
:
:
MediaStreamTrack
>
mSendTrack
;
RefPtr
<
WebRtcCallWrapper
>
mCallWrapper
;
RefPtr
<
TransportFlow
>
mRtpFlow
;
RefPtr
<
TransportFlow
>
mRtcpFlow
;
RefPtr
<
MediaSessionConduit
>
mConduit
;
RefPtr
<
MediaPipelineReceive
>
mReceivePipeline
;
RefPtr
<
MediaPipelineTransmit
>
mTransmitPipeline
;
}
;
}
#
endif
