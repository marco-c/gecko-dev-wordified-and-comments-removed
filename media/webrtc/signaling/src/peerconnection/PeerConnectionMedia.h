#
ifndef
_PEER_CONNECTION_MEDIA_H_
#
define
_PEER_CONNECTION_MEDIA_H_
#
include
<
string
>
#
include
<
vector
>
#
include
<
map
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
net
/
StunAddrsRequestChild
.
h
"
#
include
"
MediaTransportHandler
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
TransceiverImpl
.
h
"
class
nsIPrincipal
;
namespace
mozilla
{
class
DataChannel
;
class
PeerIdentity
;
namespace
dom
{
class
MediaStreamTrack
;
}
}
#
include
"
nriceresolver
.
h
"
#
include
"
nricemediastream
.
h
"
namespace
mozilla
{
class
PeerConnectionImpl
;
class
PeerConnectionMedia
;
class
PCUuidGenerator
;
class
MediaPipeline
;
class
MediaPipelineReceive
;
class
MediaPipelineTransmit
;
class
MediaPipelineFilter
;
class
JsepSession
;
class
PeerConnectionMedia
:
public
sigslot
:
:
has_slots
<
>
{
~
PeerConnectionMedia
(
)
;
public
:
explicit
PeerConnectionMedia
(
PeerConnectionImpl
*
parent
)
;
nsresult
Init
(
)
;
void
SelfDestruct
(
)
;
void
EnsureTransports
(
const
JsepSession
&
aSession
)
;
nsresult
UpdateTransports
(
const
JsepSession
&
aSession
const
bool
forceIceTcp
)
;
void
ResetStunAddrsForIceRestart
(
)
{
mStunAddrs
.
Clear
(
)
;
}
void
StartIceChecks
(
const
JsepSession
&
session
)
;
void
AddIceCandidate
(
const
std
:
:
string
&
candidate
const
std
:
:
string
&
aTransportId
const
std
:
:
string
&
aUFrag
)
;
void
UpdateNetworkState
(
bool
online
)
;
nsresult
UpdateMediaPipelines
(
)
;
nsresult
AddTransceiver
(
JsepTransceiver
*
aJsepTransceiver
dom
:
:
MediaStreamTrack
*
aSendTrack
RefPtr
<
TransceiverImpl
>
*
aTransceiverImpl
)
;
void
GetTransmitPipelinesMatching
(
const
dom
:
:
MediaStreamTrack
*
aTrack
nsTArray
<
RefPtr
<
MediaPipelineTransmit
>
>
*
aPipelines
)
;
std
:
:
string
GetTransportIdMatchingSendTrack
(
const
dom
:
:
MediaStreamTrack
&
aTrack
)
const
;
void
UpdateSinkIdentity_m
(
const
dom
:
:
MediaStreamTrack
*
aTrack
nsIPrincipal
*
aPrincipal
const
PeerIdentity
*
aSinkIdentity
)
;
bool
AnyLocalTrackHasPeerIdentity
(
)
const
;
bool
AnyCodecHasPluginID
(
uint64_t
aPluginID
)
;
const
nsCOMPtr
<
nsIThread
>
&
GetMainThread
(
)
const
{
return
mMainThread
;
}
const
nsCOMPtr
<
nsISerialEventTarget
>
&
GetSTSThread
(
)
const
{
return
mSTSThread
;
}
std
:
:
vector
<
RefPtr
<
TransceiverImpl
>
>
&
GetTransceivers
(
)
{
return
mTransceivers
;
}
nsPIDOMWindowInner
*
GetWindow
(
)
const
;
already_AddRefed
<
nsIHttpChannelInternal
>
GetChannel
(
)
const
;
void
AlpnNegotiated_s
(
const
std
:
:
string
&
aAlpn
bool
aPrivacyRequested
)
;
void
AlpnNegotiated_m
(
bool
aPrivacyRequested
)
;
RefPtr
<
WebRtcCallWrapper
>
mCall
;
RefPtr
<
MediaTransportHandler
>
mTransportHandler
;
private
:
void
InitLocalAddrs
(
)
;
bool
ShouldForceProxy
(
)
const
;
std
:
:
unique_ptr
<
NrSocketProxyConfig
>
GetProxyConfig
(
)
const
;
class
StunAddrsHandler
:
public
net
:
:
StunAddrsListener
{
public
:
explicit
StunAddrsHandler
(
PeerConnectionMedia
*
pcm
)
:
pcm_
(
pcm
)
{
}
void
OnMDNSQueryComplete
(
const
nsCString
&
hostname
const
Maybe
<
nsCString
>
&
address
)
override
;
void
OnStunAddrsAvailable
(
const
mozilla
:
:
net
:
:
NrIceStunAddrArray
&
addrs
)
override
;
private
:
RefPtr
<
PeerConnectionMedia
>
pcm_
;
virtual
~
StunAddrsHandler
(
)
{
}
}
;
void
ShutdownMediaTransport_s
(
)
;
void
SelfDestruct_m
(
)
;
void
UpdateTransport
(
const
JsepTransceiver
&
aTransceiver
bool
aForceIceTcp
)
;
void
GatherIfReady
(
)
;
void
FlushIceCtxOperationQueueIfReady
(
)
;
void
PerformOrEnqueueIceCtxOperation
(
nsIRunnable
*
runnable
)
;
nsresult
SetTargetForDefaultLocalAddressLookup
(
)
;
void
EnsureIceGathering
(
bool
aDefaultRouteOnly
bool
aObfuscateHostAddresses
)
;
bool
GetPrefDefaultAddressOnly
(
)
const
;
bool
GetPrefObfuscateHostAddresses
(
)
const
;
void
ConnectSignals
(
)
;
void
IceGatheringStateChange_s
(
dom
:
:
RTCIceGatheringState
aState
)
;
void
IceConnectionStateChange_s
(
dom
:
:
RTCIceConnectionState
aState
)
;
void
OnCandidateFound_s
(
const
std
:
:
string
&
aTransportId
const
CandidateInfo
&
aCandidateInfo
)
;
void
IceGatheringStateChange_m
(
dom
:
:
RTCIceGatheringState
aState
)
;
void
IceConnectionStateChange_m
(
dom
:
:
RTCIceConnectionState
aState
)
;
void
OnCandidateFound_m
(
const
std
:
:
string
&
aTransportId
const
CandidateInfo
&
aCandidateInfo
)
;
bool
IsIceCtxReady
(
)
const
{
return
mLocalAddrsRequestState
=
=
STUN_ADDR_REQUEST_COMPLETE
;
}
PeerConnectionImpl
*
mParent
;
std
:
:
string
mParentHandle
;
std
:
:
string
mParentName
;
std
:
:
vector
<
RefPtr
<
TransceiverImpl
>
>
mTransceivers
;
nsCOMPtr
<
nsIThread
>
mMainThread
;
nsCOMPtr
<
nsISerialEventTarget
>
mSTSThread
;
std
:
:
vector
<
nsCOMPtr
<
nsIRunnable
>
>
mQueuedIceCtxOperations
;
bool
mForceProxy
;
RefPtr
<
net
:
:
StunAddrsRequestChild
>
mStunAddrsRequest
;
enum
StunAddrRequestState
{
STUN_ADDR_REQUEST_NONE
STUN_ADDR_REQUEST_PENDING
STUN_ADDR_REQUEST_COMPLETE
}
;
StunAddrRequestState
mLocalAddrsRequestState
;
nsTArray
<
NrIceStunAddr
>
mStunAddrs
;
bool
mTargetForDefaultLocalAddressLookupIsSet
;
bool
mDestroyed
;
std
:
:
map
<
std
:
:
string
std
:
:
string
>
mMDNSHostnamesToRegister
;
bool
mCanRegisterMDNSHostnamesDirectly
=
false
;
std
:
:
set
<
std
:
:
string
>
mRegisteredMDNSHostnames
;
struct
PendingIceCandidate
{
std
:
:
vector
<
std
:
:
string
>
mTokenizedCandidate
;
std
:
:
string
mTransportId
;
std
:
:
string
mUfrag
;
}
;
std
:
:
map
<
std
:
:
string
std
:
:
list
<
PendingIceCandidate
>
>
mQueriedMDNSHostnames
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PeerConnectionMedia
)
}
;
}
#
endif
