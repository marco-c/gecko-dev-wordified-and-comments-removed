#
ifndef
_PEER_CONNECTION_MEDIA_H_
#
define
_PEER_CONNECTION_MEDIA_H_
#
include
<
string
>
#
include
<
vector
>
#
include
<
map
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
net
/
StunAddrsRequestChild
.
h
"
#
include
"
nsIProtocolProxyCallback
.
h
"
#
include
"
TransceiverImpl
.
h
"
class
nsIPrincipal
;
namespace
mozilla
{
class
DataChannel
;
class
PeerIdentity
;
namespace
dom
{
struct
RTCInboundRTPStreamStats
;
struct
RTCOutboundRTPStreamStats
;
class
MediaStreamTrack
;
}
}
#
include
"
nricectxhandler
.
h
"
#
include
"
nriceresolver
.
h
"
#
include
"
nricemediastream
.
h
"
namespace
mozilla
{
class
PeerConnectionImpl
;
class
PeerConnectionMedia
;
class
PCUuidGenerator
;
class
MediaPipeline
;
class
MediaPipelineFilter
;
class
JsepSession
;
class
PeerConnectionMedia
:
public
sigslot
:
:
has_slots
<
>
{
~
PeerConnectionMedia
(
)
;
public
:
explicit
PeerConnectionMedia
(
PeerConnectionImpl
*
parent
)
;
enum
IceRestartState
{
ICE_RESTART_NONE
ICE_RESTART_PROVISIONAL
ICE_RESTART_COMMITTED
}
;
PeerConnectionImpl
*
GetPC
(
)
{
return
mParent
;
}
nsresult
Init
(
const
std
:
:
vector
<
NrIceStunServer
>
&
stun_servers
const
std
:
:
vector
<
NrIceTurnServer
>
&
turn_servers
NrIceCtx
:
:
Policy
policy
)
;
void
SelfDestruct
(
)
;
RefPtr
<
NrIceCtxHandler
>
ice_ctx_hdlr
(
)
const
{
return
mIceCtxHdlr
;
}
RefPtr
<
NrIceCtx
>
ice_ctx
(
)
const
{
return
mIceCtxHdlr
-
>
ctx
(
)
;
}
RefPtr
<
NrIceMediaStream
>
ice_media_stream
(
size_t
i
)
const
{
return
mIceCtxHdlr
-
>
ctx
(
)
-
>
GetStream
(
i
)
;
}
size_t
num_ice_media_streams
(
)
const
{
return
mIceCtxHdlr
-
>
ctx
(
)
-
>
GetStreamCount
(
)
;
}
void
EnsureTransports
(
const
JsepSession
&
aSession
)
;
nsresult
ActivateOrRemoveTransports
(
const
JsepSession
&
aSession
const
bool
forceIceTcp
)
;
nsresult
UpdateTransceiverTransports
(
const
JsepSession
&
aSession
)
;
void
StartIceChecks
(
const
JsepSession
&
session
)
;
bool
IsIceRestarting
(
)
const
;
IceRestartState
GetIceRestartState
(
)
const
;
void
BeginIceRestart
(
const
std
:
:
string
&
ufrag
const
std
:
:
string
&
pwd
)
;
void
CommitIceRestart
(
)
;
void
FinalizeIceRestart
(
)
;
void
RollbackIceRestart
(
)
;
void
AddIceCandidate
(
const
std
:
:
string
&
candidate
const
std
:
:
string
&
mid
uint32_t
aMLine
)
;
void
UpdateNetworkState
(
bool
online
)
;
nsresult
UpdateMediaPipelines
(
)
;
nsresult
AddTransceiver
(
JsepTransceiver
*
aJsepTransceiver
dom
:
:
MediaStreamTrack
&
aReceiveTrack
dom
:
:
MediaStreamTrack
*
aSendTrack
RefPtr
<
TransceiverImpl
>
*
aTransceiverImpl
)
;
void
GetTransmitPipelinesMatching
(
dom
:
:
MediaStreamTrack
*
aTrack
nsTArray
<
RefPtr
<
MediaPipeline
>
>
*
aPipelines
)
;
void
GetReceivePipelinesMatching
(
dom
:
:
MediaStreamTrack
*
aTrack
nsTArray
<
RefPtr
<
MediaPipeline
>
>
*
aPipelines
)
;
nsresult
AddRIDExtension
(
dom
:
:
MediaStreamTrack
&
aRecvTrack
unsigned
short
aExtensionId
)
;
nsresult
AddRIDFilter
(
dom
:
:
MediaStreamTrack
&
aRecvTrack
const
nsAString
&
aRid
)
;
void
UpdateSinkIdentity_m
(
dom
:
:
MediaStreamTrack
*
aTrack
nsIPrincipal
*
aPrincipal
const
PeerIdentity
*
aSinkIdentity
)
;
bool
AnyLocalTrackHasPeerIdentity
(
)
const
;
void
UpdateRemoteStreamPrincipals_m
(
nsIPrincipal
*
aPrincipal
)
;
bool
AnyCodecHasPluginID
(
uint64_t
aPluginID
)
;
const
nsCOMPtr
<
nsIThread
>
&
GetMainThread
(
)
const
{
return
mMainThread
;
}
const
nsCOMPtr
<
nsIEventTarget
>
&
GetSTSThread
(
)
const
{
return
mSTSThread
;
}
static
size_t
GetTransportFlowIndex
(
int
aStreamIndex
bool
aRtcp
)
{
return
aStreamIndex
*
2
+
(
aRtcp
?
1
:
0
)
;
}
RefPtr
<
TransportFlow
>
GetTransportFlow
(
int
aStreamIndex
bool
aIsRtcp
)
{
int
index_inner
=
GetTransportFlowIndex
(
aStreamIndex
aIsRtcp
)
;
if
(
mTransportFlows
.
find
(
index_inner
)
=
=
mTransportFlows
.
end
(
)
)
return
nullptr
;
return
mTransportFlows
[
index_inner
]
;
}
std
:
:
vector
<
RefPtr
<
TransceiverImpl
>
>
&
GetTransceivers
(
)
{
return
mTransceivers
;
}
void
AddTransportFlow
(
int
aIndex
bool
aRtcp
const
RefPtr
<
TransportFlow
>
&
aFlow
)
;
void
RemoveTransportFlow
(
int
aIndex
bool
aRtcp
)
;
void
ConnectDtlsListener_s
(
const
RefPtr
<
TransportFlow
>
&
aFlow
)
;
void
DtlsConnected_s
(
TransportLayer
*
aFlow
TransportLayer
:
:
State
state
)
;
static
void
DtlsConnected_m
(
const
std
:
:
string
&
aParentHandle
bool
aPrivacyRequested
)
;
sigslot
:
:
signal2
<
NrIceCtx
*
NrIceCtx
:
:
GatheringState
>
SignalIceGatheringStateChange
;
sigslot
:
:
signal2
<
NrIceCtx
*
NrIceCtx
:
:
ConnectionState
>
SignalIceConnectionStateChange
;
sigslot
:
:
signal2
<
const
std
:
:
string
&
uint16_t
>
SignalCandidate
;
sigslot
:
:
signal5
<
const
std
:
:
string
&
uint16_t
const
std
:
:
string
&
uint16_t
uint16_t
>
SignalUpdateDefaultCandidate
;
sigslot
:
:
signal1
<
uint16_t
>
SignalEndOfLocalCandidates
;
RefPtr
<
WebRtcCallWrapper
>
mCall
;
private
:
void
InitLocalAddrs
(
)
;
nsresult
InitProxy
(
)
;
class
ProtocolProxyQueryHandler
:
public
nsIProtocolProxyCallback
{
public
:
explicit
ProtocolProxyQueryHandler
(
PeerConnectionMedia
*
pcm
)
:
pcm_
(
pcm
)
{
}
NS_IMETHOD
OnProxyAvailable
(
nsICancelable
*
request
nsIChannel
*
aChannel
nsIProxyInfo
*
proxyinfo
nsresult
result
)
override
;
NS_DECL_ISUPPORTS
private
:
void
SetProxyOnPcm
(
nsIProxyInfo
&
proxyinfo
)
;
RefPtr
<
PeerConnectionMedia
>
pcm_
;
virtual
~
ProtocolProxyQueryHandler
(
)
{
}
}
;
class
StunAddrsHandler
:
public
net
:
:
StunAddrsListener
{
public
:
explicit
StunAddrsHandler
(
PeerConnectionMedia
*
pcm
)
:
pcm_
(
pcm
)
{
}
void
OnStunAddrsAvailable
(
const
mozilla
:
:
net
:
:
NrIceStunAddrArray
&
addrs
)
override
;
private
:
RefPtr
<
PeerConnectionMedia
>
pcm_
;
virtual
~
StunAddrsHandler
(
)
{
}
}
;
void
ShutdownMediaTransport_s
(
)
;
void
SelfDestruct_m
(
)
;
void
EnsureTransport_s
(
size_t
aLevel
size_t
aComponentCount
)
;
void
ActivateOrRemoveTransport_s
(
size_t
aMLine
size_t
aComponentCount
const
std
:
:
string
&
aUfrag
const
std
:
:
string
&
aPassword
const
std
:
:
vector
<
std
:
:
string
>
&
aCandidateList
)
;
void
RemoveTransportsAtOrAfter_s
(
size_t
aMLine
)
;
nsresult
UpdateTransportFlows
(
const
JsepTransceiver
&
transceiver
)
;
nsresult
UpdateTransportFlow
(
size_t
aLevel
bool
aIsRtcp
const
JsepTransport
&
aTransport
)
;
void
GatherIfReady
(
)
;
void
FlushIceCtxOperationQueueIfReady
(
)
;
void
PerformOrEnqueueIceCtxOperation
(
nsIRunnable
*
runnable
)
;
void
EnsureIceGathering_s
(
bool
aDefaultRouteOnly
bool
aProxyOnly
)
;
void
StartIceChecks_s
(
bool
aIsControlling
bool
aIsOfferer
bool
aIsIceLite
const
std
:
:
vector
<
std
:
:
string
>
&
aIceOptionsList
)
;
void
BeginIceRestart_s
(
RefPtr
<
NrIceCtx
>
new_ctx
)
;
void
FinalizeIceRestart_s
(
)
;
void
RollbackIceRestart_s
(
)
;
bool
GetPrefDefaultAddressOnly
(
)
const
;
bool
GetPrefProxyOnly
(
)
const
;
void
ConnectSignals
(
NrIceCtx
*
aCtx
NrIceCtx
*
aOldCtx
=
nullptr
)
;
void
AddIceCandidate_s
(
const
std
:
:
string
&
aCandidate
const
std
:
:
string
&
aMid
uint32_t
aMLine
)
;
void
UpdateNetworkState_s
(
bool
online
)
;
void
IceGatheringStateChange_s
(
NrIceCtx
*
ctx
NrIceCtx
:
:
GatheringState
state
)
;
void
IceConnectionStateChange_s
(
NrIceCtx
*
ctx
NrIceCtx
:
:
ConnectionState
state
)
;
void
IceStreamReady_s
(
NrIceMediaStream
*
aStream
)
;
void
OnCandidateFound_s
(
NrIceMediaStream
*
aStream
const
std
:
:
string
&
aCandidate
)
;
void
EndOfLocalCandidates
(
const
std
:
:
string
&
aDefaultAddr
uint16_t
aDefaultPort
const
std
:
:
string
&
aDefaultRtcpAddr
uint16_t
aDefaultRtcpPort
uint16_t
aMLine
)
;
void
GetDefaultCandidates
(
const
NrIceMediaStream
&
aStream
NrIceCandidate
*
aCandidate
NrIceCandidate
*
aRtcpCandidate
)
;
void
IceGatheringStateChange_m
(
NrIceCtx
*
ctx
NrIceCtx
:
:
GatheringState
state
)
;
void
IceConnectionStateChange_m
(
NrIceCtx
*
ctx
NrIceCtx
:
:
ConnectionState
state
)
;
void
OnCandidateFound_m
(
const
std
:
:
string
&
aCandidateLine
const
std
:
:
string
&
aDefaultAddr
uint16_t
aDefaultPort
const
std
:
:
string
&
aDefaultRtcpAddr
uint16_t
aDefaultRtcpPort
uint16_t
aMLine
)
;
void
EndOfLocalCandidates_m
(
const
std
:
:
string
&
aDefaultAddr
uint16_t
aDefaultPort
const
std
:
:
string
&
aDefaultRtcpAddr
uint16_t
aDefaultRtcpPort
uint16_t
aMLine
)
;
bool
IsIceCtxReady
(
)
const
{
return
mProxyResolveCompleted
&
&
mLocalAddrsCompleted
;
}
PeerConnectionImpl
*
mParent
;
std
:
:
string
mParentHandle
;
std
:
:
string
mParentName
;
std
:
:
vector
<
RefPtr
<
TransceiverImpl
>
>
mTransceivers
;
RefPtr
<
NrIceCtxHandler
>
mIceCtxHdlr
;
RefPtr
<
NrIceResolver
>
mDNSResolver
;
std
:
:
map
<
int
RefPtr
<
TransportFlow
>
>
mTransportFlows
;
UniquePtr
<
PCUuidGenerator
>
mUuidGen
;
nsCOMPtr
<
nsIThread
>
mMainThread
;
nsCOMPtr
<
nsIEventTarget
>
mSTSThread
;
std
:
:
vector
<
nsCOMPtr
<
nsIRunnable
>
>
mQueuedIceCtxOperations
;
nsCOMPtr
<
nsICancelable
>
mProxyRequest
;
bool
mProxyResolveCompleted
;
UniquePtr
<
NrIceProxyServer
>
mProxyServer
;
IceRestartState
mIceRestartState
;
RefPtr
<
net
:
:
StunAddrsRequestChild
>
mStunAddrsRequest
;
bool
mLocalAddrsCompleted
;
nsTArray
<
NrIceStunAddr
>
mStunAddrs
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PeerConnectionMedia
)
}
;
}
#
endif
