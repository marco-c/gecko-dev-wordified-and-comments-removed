#
ifndef
_PEER_CONNECTION_MEDIA_H_
#
define
_PEER_CONNECTION_MEDIA_H_
#
include
<
string
>
#
include
<
vector
>
#
include
<
map
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
net
/
StunAddrsRequestChild
.
h
"
#
include
"
nsIProtocolProxyCallback
.
h
"
#
include
"
MediaTransportHandler
.
h
"
#
include
"
TransceiverImpl
.
h
"
class
nsIPrincipal
;
namespace
mozilla
{
class
DataChannel
;
class
PeerIdentity
;
namespace
dom
{
class
MediaStreamTrack
;
}
}
#
include
"
nriceresolver
.
h
"
#
include
"
nricemediastream
.
h
"
namespace
mozilla
{
class
PeerConnectionImpl
;
class
PeerConnectionMedia
;
class
PCUuidGenerator
;
class
MediaPipeline
;
class
MediaPipelineFilter
;
class
JsepSession
;
class
PeerConnectionMedia
:
public
sigslot
:
:
has_slots
<
>
{
~
PeerConnectionMedia
(
)
;
public
:
explicit
PeerConnectionMedia
(
PeerConnectionImpl
*
parent
)
;
nsresult
Init
(
)
;
void
SelfDestruct
(
)
;
void
EnsureTransports
(
const
JsepSession
&
aSession
)
;
nsresult
UpdateTransports
(
const
JsepSession
&
aSession
const
bool
forceIceTcp
)
;
void
StartIceChecks
(
const
JsepSession
&
session
)
;
void
AddIceCandidate
(
const
std
:
:
string
&
candidate
const
std
:
:
string
&
aTransportId
)
;
void
UpdateNetworkState
(
bool
online
)
;
nsresult
UpdateMediaPipelines
(
)
;
nsresult
AddTransceiver
(
JsepTransceiver
*
aJsepTransceiver
dom
:
:
MediaStreamTrack
&
aReceiveTrack
dom
:
:
MediaStreamTrack
*
aSendTrack
RefPtr
<
TransceiverImpl
>
*
aTransceiverImpl
)
;
void
GetTransmitPipelinesMatching
(
const
dom
:
:
MediaStreamTrack
*
aTrack
nsTArray
<
RefPtr
<
MediaPipeline
>
>
*
aPipelines
)
;
void
GetReceivePipelinesMatching
(
const
dom
:
:
MediaStreamTrack
*
aTrack
nsTArray
<
RefPtr
<
MediaPipeline
>
>
*
aPipelines
)
;
std
:
:
string
GetTransportIdMatching
(
const
dom
:
:
MediaStreamTrack
&
aTrack
)
const
;
nsresult
AddRIDExtension
(
dom
:
:
MediaStreamTrack
&
aRecvTrack
unsigned
short
aExtensionId
)
;
nsresult
AddRIDFilter
(
dom
:
:
MediaStreamTrack
&
aRecvTrack
const
nsAString
&
aRid
)
;
void
UpdateSinkIdentity_m
(
const
dom
:
:
MediaStreamTrack
*
aTrack
nsIPrincipal
*
aPrincipal
const
PeerIdentity
*
aSinkIdentity
)
;
bool
AnyLocalTrackHasPeerIdentity
(
)
const
;
void
UpdateRemoteStreamPrincipals_m
(
nsIPrincipal
*
aPrincipal
)
;
bool
AnyCodecHasPluginID
(
uint64_t
aPluginID
)
;
const
nsCOMPtr
<
nsIThread
>
&
GetMainThread
(
)
const
{
return
mMainThread
;
}
const
nsCOMPtr
<
nsIEventTarget
>
&
GetSTSThread
(
)
const
{
return
mSTSThread
;
}
std
:
:
vector
<
RefPtr
<
TransceiverImpl
>
>
&
GetTransceivers
(
)
{
return
mTransceivers
;
}
nsPIDOMWindowInner
*
GetWindow
(
)
const
;
void
AlpnNegotiated_s
(
const
std
:
:
string
&
aAlpn
)
;
static
void
AlpnNegotiated_m
(
const
std
:
:
string
&
aParentHandle
const
std
:
:
string
&
aAlpn
)
;
sigslot
:
:
signal1
<
mozilla
:
:
dom
:
:
PCImplIceGatheringState
>
SignalIceGatheringStateChange
;
sigslot
:
:
signal1
<
mozilla
:
:
dom
:
:
PCImplIceConnectionState
>
SignalIceConnectionStateChange
;
sigslot
:
:
signal2
<
const
std
:
:
string
&
const
std
:
:
string
&
>
SignalCandidate
;
sigslot
:
:
signal5
<
const
std
:
:
string
&
uint16_t
const
std
:
:
string
&
uint16_t
const
std
:
:
string
&
>
SignalUpdateDefaultCandidate
;
RefPtr
<
WebRtcCallWrapper
>
mCall
;
RefPtr
<
MediaTransportHandler
>
mTransportHandler
;
private
:
void
InitLocalAddrs
(
)
;
nsresult
InitProxy
(
)
;
class
ProtocolProxyQueryHandler
:
public
nsIProtocolProxyCallback
{
public
:
explicit
ProtocolProxyQueryHandler
(
PeerConnectionMedia
*
pcm
)
:
pcm_
(
pcm
)
{
}
NS_IMETHOD
OnProxyAvailable
(
nsICancelable
*
request
nsIChannel
*
aChannel
nsIProxyInfo
*
proxyinfo
nsresult
result
)
override
;
NS_DECL_ISUPPORTS
private
:
void
SetProxyOnPcm
(
nsIProxyInfo
&
proxyinfo
)
;
RefPtr
<
PeerConnectionMedia
>
pcm_
;
virtual
~
ProtocolProxyQueryHandler
(
)
{
}
}
;
class
StunAddrsHandler
:
public
net
:
:
StunAddrsListener
{
public
:
explicit
StunAddrsHandler
(
PeerConnectionMedia
*
pcm
)
:
pcm_
(
pcm
)
{
}
void
OnStunAddrsAvailable
(
const
mozilla
:
:
net
:
:
NrIceStunAddrArray
&
addrs
)
override
;
private
:
RefPtr
<
PeerConnectionMedia
>
pcm_
;
virtual
~
StunAddrsHandler
(
)
{
}
}
;
void
ShutdownMediaTransport_s
(
)
;
void
SelfDestruct_m
(
)
;
void
UpdateTransport
(
const
JsepTransceiver
&
aTransceiver
bool
aForceIceTcp
)
;
void
GatherIfReady
(
)
;
void
FlushIceCtxOperationQueueIfReady
(
)
;
void
PerformOrEnqueueIceCtxOperation
(
nsIRunnable
*
runnable
)
;
void
EnsureIceGathering_s
(
bool
aDefaultRouteOnly
)
;
void
StartIceChecks_s
(
bool
aIsControlling
bool
aIsOfferer
bool
aIsIceLite
const
std
:
:
vector
<
std
:
:
string
>
&
aIceOptionsList
)
;
bool
GetPrefDefaultAddressOnly
(
)
const
;
void
ConnectSignals
(
)
;
void
IceGatheringStateChange_s
(
dom
:
:
PCImplIceGatheringState
aState
)
;
void
IceConnectionStateChange_s
(
dom
:
:
PCImplIceConnectionState
aState
)
;
void
OnCandidateFound_s
(
const
std
:
:
string
&
aTransportId
const
CandidateInfo
&
aCandidateInfo
)
;
void
IceGatheringStateChange_m
(
dom
:
:
PCImplIceGatheringState
aState
)
;
void
IceConnectionStateChange_m
(
dom
:
:
PCImplIceConnectionState
aState
)
;
void
OnCandidateFound_m
(
const
std
:
:
string
&
aTransportId
const
CandidateInfo
&
aCandidateInfo
)
;
bool
IsIceCtxReady
(
)
const
{
return
mProxyResolveCompleted
&
&
mLocalAddrsCompleted
;
}
PeerConnectionImpl
*
mParent
;
std
:
:
string
mParentHandle
;
std
:
:
string
mParentName
;
std
:
:
vector
<
RefPtr
<
TransceiverImpl
>
>
mTransceivers
;
nsCOMPtr
<
nsIThread
>
mMainThread
;
nsCOMPtr
<
nsIEventTarget
>
mSTSThread
;
std
:
:
vector
<
nsCOMPtr
<
nsIRunnable
>
>
mQueuedIceCtxOperations
;
nsCOMPtr
<
nsICancelable
>
mProxyRequest
;
bool
mProxyResolveCompleted
;
std
:
:
unique_ptr
<
NrSocketProxyConfig
>
mProxyConfig
;
RefPtr
<
net
:
:
StunAddrsRequestChild
>
mStunAddrsRequest
;
bool
mLocalAddrsCompleted
;
nsTArray
<
NrIceStunAddr
>
mStunAddrs
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PeerConnectionMedia
)
}
;
}
#
endif
