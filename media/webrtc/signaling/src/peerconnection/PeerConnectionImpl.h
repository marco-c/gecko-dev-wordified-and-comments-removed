#
ifndef
_PEER_CONNECTION_IMPL_H_
#
define
_PEER_CONNECTION_IMPL_H_
#
include
<
deque
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
map
>
#
include
<
cmath
>
#
include
"
prlock
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsWeakPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
IPeerConnection
.
h
"
#
include
"
sigslot
.
h
"
#
include
"
nricectx
.
h
"
#
include
"
nricemediastream
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
ifdef
GetLastError
#
undef
GetLastError
#
endif
#
include
"
signaling
/
src
/
jsep
/
JsepSession
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepSessionImpl
.
h
"
#
include
"
signaling
/
src
/
sdp
/
SdpMediaSection
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
PeerConnectionImplEnumsBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCPeerConnectionBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpTransceiverBinding
.
h
"
#
include
"
PrincipalChangeObserver
.
h
"
#
include
"
StreamTracks
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
net
/
DataChannel
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
mozilla
/
dom
/
RTCStatsReportBinding
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
mozilla
/
PeerIdentity
.
h
"
namespace
test
{
#
ifdef
USE_FAKE_PCOBSERVER
class
AFakePCObserver
;
#
endif
}
class
nsDOMDataChannel
;
namespace
mozilla
{
class
DataChannel
;
class
DtlsIdentity
;
class
NrIceCtx
;
class
NrIceMediaStream
;
class
NrIceStunServer
;
class
NrIceTurnServer
;
class
MediaPipeline
;
class
TransceiverImpl
;
namespace
dom
{
class
RTCCertificate
;
struct
RTCConfiguration
;
struct
RTCRtpSourceEntry
;
class
RTCDTMFSender
;
struct
RTCIceServer
;
struct
RTCOfferOptions
;
struct
RTCRtpParameters
;
class
RTCRtpSender
;
class
MediaStreamTrack
;
#
ifdef
USE_FAKE_PCOBSERVER
typedef
test
:
:
AFakePCObserver
PeerConnectionObserver
;
typedef
const
char
*
PCObserverString
;
#
else
class
PeerConnectionObserver
;
typedef
NS_ConvertUTF8toUTF16
PCObserverString
;
#
endif
}
}
#
if
defined
(
__cplusplus
)
&
&
__cplusplus
>
=
201103L
typedef
struct
Timecard
Timecard
;
#
else
#
include
"
timecard
.
h
"
#
endif
#
define
NS_IMETHODIMP_TO_ERRORRESULT
(
func
rv
.
.
.
)
\
NS_IMETHODIMP
func
(
__VA_ARGS__
)
;
\
void
func
(
__VA_ARGS__
rv
)
#
define
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
(
resulttype
func
rv
.
.
.
)
\
NS_IMETHODIMP
func
(
__VA_ARGS__
resulttype
*
*
result
)
;
\
already_AddRefed
<
resulttype
>
func
(
__VA_ARGS__
rv
)
struct
MediaStreamTable
;
namespace
mozilla
{
using
mozilla
:
:
dom
:
:
PeerConnectionObserver
;
using
mozilla
:
:
dom
:
:
RTCConfiguration
;
using
mozilla
:
:
dom
:
:
RTCIceServer
;
using
mozilla
:
:
dom
:
:
RTCOfferOptions
;
using
mozilla
:
:
NrIceCtx
;
using
mozilla
:
:
NrIceMediaStream
;
using
mozilla
:
:
DtlsIdentity
;
using
mozilla
:
:
ErrorResult
;
using
mozilla
:
:
NrIceStunServer
;
using
mozilla
:
:
NrIceTurnServer
;
using
mozilla
:
:
PeerIdentity
;
class
PeerConnectionWrapper
;
class
PeerConnectionMedia
;
class
RemoteSourceStreamInfo
;
class
PCUuidGenerator
:
public
mozilla
:
:
JsepUuidGenerator
{
public
:
virtual
bool
Generate
(
std
:
:
string
*
idp
)
override
;
private
:
nsCOMPtr
<
nsIUUIDGenerator
>
mGenerator
;
}
;
class
PeerConnectionConfiguration
{
public
:
PeerConnectionConfiguration
(
)
:
mBundlePolicy
(
kBundleBalanced
)
mIceTransportPolicy
(
NrIceCtx
:
:
ICE_POLICY_ALL
)
{
}
bool
addStunServer
(
const
std
:
:
string
&
addr
uint16_t
port
const
char
*
transport
)
{
UniquePtr
<
NrIceStunServer
>
server
(
NrIceStunServer
:
:
Create
(
addr
port
transport
)
)
;
if
(
!
server
)
{
return
false
;
}
addStunServer
(
*
server
)
;
return
true
;
}
bool
addTurnServer
(
const
std
:
:
string
&
addr
uint16_t
port
const
std
:
:
string
&
username
const
std
:
:
string
&
pwd
const
char
*
transport
)
{
std
:
:
vector
<
unsigned
char
>
password
(
pwd
.
begin
(
)
pwd
.
end
(
)
)
;
UniquePtr
<
NrIceTurnServer
>
server
(
NrIceTurnServer
:
:
Create
(
addr
port
username
password
transport
)
)
;
if
(
!
server
)
{
return
false
;
}
addTurnServer
(
*
server
)
;
return
true
;
}
void
addStunServer
(
const
NrIceStunServer
&
server
)
{
mStunServers
.
push_back
(
server
)
;
}
void
addTurnServer
(
const
NrIceTurnServer
&
server
)
{
mTurnServers
.
push_back
(
server
)
;
}
const
std
:
:
vector
<
NrIceStunServer
>
&
getStunServers
(
)
const
{
return
mStunServers
;
}
const
std
:
:
vector
<
NrIceTurnServer
>
&
getTurnServers
(
)
const
{
return
mTurnServers
;
}
void
setBundlePolicy
(
JsepBundlePolicy
policy
)
{
mBundlePolicy
=
policy
;
}
JsepBundlePolicy
getBundlePolicy
(
)
const
{
return
mBundlePolicy
;
}
void
setIceTransportPolicy
(
NrIceCtx
:
:
Policy
policy
)
{
mIceTransportPolicy
=
policy
;
}
NrIceCtx
:
:
Policy
getIceTransportPolicy
(
)
const
{
return
mIceTransportPolicy
;
}
nsresult
Init
(
const
RTCConfiguration
&
aSrc
)
;
nsresult
AddIceServer
(
const
RTCIceServer
&
aServer
)
;
private
:
std
:
:
vector
<
NrIceStunServer
>
mStunServers
;
std
:
:
vector
<
NrIceTurnServer
>
mTurnServers
;
JsepBundlePolicy
mBundlePolicy
;
NrIceCtx
:
:
Policy
mIceTransportPolicy
;
}
;
class
RTCStatsQuery
{
public
:
explicit
RTCStatsQuery
(
bool
internalStats
)
;
~
RTCStatsQuery
(
)
;
nsAutoPtr
<
mozilla
:
:
dom
:
:
RTCStatsReportInternal
>
report
;
std
:
:
string
error
;
mozilla
:
:
TimeStamp
iceStartTime
;
bool
failed
;
private
:
friend
class
PeerConnectionImpl
;
std
:
:
string
pcName
;
bool
internalStats
;
nsTArray
<
RefPtr
<
mozilla
:
:
MediaPipeline
>
>
pipelines
;
RefPtr
<
NrIceCtx
>
iceCtx
;
bool
grabAllLevels
;
DOMHighResTimeStamp
now
;
}
;
#
define
PC_AUTO_ENTER_API_CALL
(
assert_ice_ready
)
\
do
{
\
/
*
do
/
while
prevents
res
from
conflicting
with
locals
*
/
\
nsresult
res
=
CheckApiState
(
assert_ice_ready
)
;
\
if
(
NS_FAILED
(
res
)
)
return
res
;
\
}
while
(
0
)
#
define
PC_AUTO_ENTER_API_CALL_VOID_RETURN
(
assert_ice_ready
)
\
do
{
\
/
*
do
/
while
prevents
res
from
conflicting
with
locals
*
/
\
nsresult
res
=
CheckApiState
(
assert_ice_ready
)
;
\
if
(
NS_FAILED
(
res
)
)
return
;
\
}
while
(
0
)
#
define
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
CheckThread
(
)
class
PeerConnectionImpl
final
:
public
nsISupports
public
mozilla
:
:
DataChannelConnection
:
:
DataConnectionListener
public
dom
:
:
PrincipalChangeObserver
<
dom
:
:
MediaStreamTrack
>
public
sigslot
:
:
has_slots
<
>
{
struct
Internal
;
public
:
explicit
PeerConnectionImpl
(
const
mozilla
:
:
dom
:
:
GlobalObject
*
aGlobal
=
nullptr
)
;
enum
Error
{
kNoError
=
0
kInvalidCandidate
=
2
kInvalidMediastreamTrack
=
3
kInvalidState
=
4
kInvalidSessionDescription
=
5
kIncompatibleSessionDescription
=
6
kIncompatibleMediaStreamTrack
=
8
kInternalError
=
9
}
;
NS_DECL_THREADSAFE_ISUPPORTS
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
;
static
already_AddRefed
<
PeerConnectionImpl
>
Constructor
(
const
mozilla
:
:
dom
:
:
GlobalObject
&
aGlobal
ErrorResult
&
rv
)
;
static
PeerConnectionImpl
*
CreatePeerConnection
(
)
;
nsresult
CreateRemoteSourceStreamInfo
(
RefPtr
<
RemoteSourceStreamInfo
>
*
aInfo
const
std
:
:
string
&
aId
)
;
void
NotifyDataChannel
(
already_AddRefed
<
mozilla
:
:
DataChannel
>
aChannel
)
override
;
const
RefPtr
<
PeerConnectionMedia
>
&
media
(
)
const
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mMedia
;
}
void
SetAllowIceLoopback
(
bool
val
)
{
mAllowIceLoopback
=
val
;
}
bool
GetAllowIceLoopback
(
)
const
{
return
mAllowIceLoopback
;
}
void
SetAllowIceLinkLocal
(
bool
val
)
{
mAllowIceLinkLocal
=
val
;
}
bool
GetAllowIceLinkLocal
(
)
const
{
return
mAllowIceLinkLocal
;
}
virtual
const
std
:
:
string
&
GetHandle
(
)
;
virtual
const
std
:
:
string
&
GetName
(
)
;
void
IceConnectionStateChange
(
NrIceCtx
*
ctx
NrIceCtx
:
:
ConnectionState
state
)
;
void
IceGatheringStateChange
(
NrIceCtx
*
ctx
NrIceCtx
:
:
GatheringState
state
)
;
void
UpdateDefaultCandidate
(
const
std
:
:
string
&
defaultAddr
uint16_t
defaultPort
const
std
:
:
string
&
defaultRtcpAddr
uint16_t
defaultRtcpPort
uint16_t
level
)
;
void
EndOfLocalCandidates
(
uint16_t
level
)
;
void
IceStreamReady
(
NrIceMediaStream
*
aStream
)
;
static
void
ListenThread
(
void
*
aData
)
;
static
void
ConnectThread
(
void
*
aData
)
;
nsCOMPtr
<
nsIThread
>
GetMainThread
(
)
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mThread
;
}
nsIEventTarget
*
GetSTSThread
(
)
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mSTSThread
;
}
nsPIDOMWindowInner
*
GetWindow
(
)
const
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mWindow
;
}
nsresult
Initialize
(
PeerConnectionObserver
&
aObserver
nsGlobalWindowInner
*
aWindow
const
PeerConnectionConfiguration
&
aConfiguration
nsISupports
*
aThread
)
;
void
Initialize
(
PeerConnectionObserver
&
aObserver
nsGlobalWindowInner
&
aWindow
const
RTCConfiguration
&
aConfiguration
nsISupports
*
aThread
ErrorResult
&
rv
)
;
void
SetCertificate
(
mozilla
:
:
dom
:
:
RTCCertificate
&
aCertificate
)
;
const
RefPtr
<
mozilla
:
:
dom
:
:
RTCCertificate
>
&
Certificate
(
)
const
;
RefPtr
<
DtlsIdentity
>
Identity
(
)
const
;
NS_IMETHODIMP_TO_ERRORRESULT
(
CreateOffer
ErrorResult
&
rv
const
RTCOfferOptions
&
aOptions
)
{
rv
=
CreateOffer
(
aOptions
)
;
}
NS_IMETHODIMP
CreateAnswer
(
)
;
void
CreateAnswer
(
ErrorResult
&
rv
)
{
rv
=
CreateAnswer
(
)
;
}
NS_IMETHODIMP
CreateOffer
(
const
mozilla
:
:
JsepOfferOptions
&
aConstraints
)
;
NS_IMETHODIMP
SetLocalDescription
(
int32_t
aAction
const
char
*
aSDP
)
;
void
SetLocalDescription
(
int32_t
aAction
const
nsAString
&
aSDP
ErrorResult
&
rv
)
{
rv
=
SetLocalDescription
(
aAction
NS_ConvertUTF16toUTF8
(
aSDP
)
.
get
(
)
)
;
}
NS_IMETHODIMP
SetRemoteDescription
(
int32_t
aAction
const
char
*
aSDP
)
;
void
SetRemoteDescription
(
int32_t
aAction
const
nsAString
&
aSDP
ErrorResult
&
rv
)
{
rv
=
SetRemoteDescription
(
aAction
NS_ConvertUTF16toUTF8
(
aSDP
)
.
get
(
)
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetStats
ErrorResult
&
rv
mozilla
:
:
dom
:
:
MediaStreamTrack
*
aSelector
)
{
rv
=
GetStats
(
aSelector
)
;
}
NS_IMETHODIMP
AddIceCandidate
(
const
char
*
aCandidate
const
char
*
aMid
unsigned
short
aLevel
)
;
void
AddIceCandidate
(
const
nsAString
&
aCandidate
const
nsAString
&
aMid
unsigned
short
aLevel
ErrorResult
&
rv
)
{
rv
=
AddIceCandidate
(
NS_ConvertUTF16toUTF8
(
aCandidate
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aMid
)
.
get
(
)
aLevel
)
;
}
void
UpdateNetworkState
(
bool
online
)
;
NS_IMETHODIMP
CloseStreams
(
)
;
void
CloseStreams
(
ErrorResult
&
rv
)
{
rv
=
CloseStreams
(
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
RemoveTrack
ErrorResult
&
rv
mozilla
:
:
dom
:
:
MediaStreamTrack
&
aTrack
)
{
rv
=
RemoveTrack
(
aTrack
)
;
}
already_AddRefed
<
TransceiverImpl
>
CreateTransceiverImpl
(
const
nsAString
&
aKind
dom
:
:
MediaStreamTrack
*
aSendTrack
ErrorResult
&
rv
)
;
OwningNonNull
<
dom
:
:
MediaStreamTrack
>
CreateReceiveTrack
(
SdpMediaSection
:
:
MediaType
type
)
;
bool
CheckNegotiationNeeded
(
ErrorResult
&
rv
)
;
NS_IMETHODIMP_TO_ERRORRESULT
(
InsertDTMF
ErrorResult
&
rv
TransceiverImpl
&
transceiver
const
nsAString
&
tones
uint32_t
duration
uint32_t
interToneGap
)
{
rv
=
InsertDTMF
(
transceiver
tones
duration
interToneGap
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetDTMFToneBuffer
ErrorResult
&
rv
dom
:
:
RTCRtpSender
&
sender
nsAString
&
outToneBuffer
)
{
rv
=
GetDTMFToneBuffer
(
sender
outToneBuffer
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetRtpSources
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aRecvTrack
DOMHighResTimeStamp
aRtpSourceNow
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
&
outRtpSources
)
{
rv
=
GetRtpSources
(
aRecvTrack
aRtpSourceNow
outRtpSources
)
;
}
DOMHighResTimeStamp
GetNowInRtpSourceReferenceTime
(
)
;
NS_IMETHODIMP_TO_ERRORRESULT
(
ReplaceTrackNoRenegotiation
ErrorResult
&
rv
TransceiverImpl
&
aTransceiver
mozilla
:
:
dom
:
:
MediaStreamTrack
*
aWithTrack
)
{
rv
=
ReplaceTrackNoRenegotiation
(
aTransceiver
aWithTrack
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
SetParameters
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aTrack
const
dom
:
:
RTCRtpParameters
&
aParameters
)
{
rv
=
SetParameters
(
aTrack
aParameters
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetParameters
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aTrack
dom
:
:
RTCRtpParameters
&
aOutParameters
)
{
rv
=
GetParameters
(
aTrack
aOutParameters
)
;
}
nsresult
SetParameters
(
dom
:
:
MediaStreamTrack
&
aTrack
const
std
:
:
vector
<
JsepTrack
:
:
JsConstraints
>
&
aConstraints
)
;
nsresult
GetParameters
(
dom
:
:
MediaStreamTrack
&
aTrack
std
:
:
vector
<
JsepTrack
:
:
JsConstraints
>
*
aOutConstraints
)
;
NS_IMETHODIMP_TO_ERRORRESULT
(
InsertAudioLevelForContributingSource
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aRecvTrack
unsigned
long
aSource
DOMHighResTimeStamp
aTimestamp
bool
aHasLevel
uint8_t
aLevel
)
{
rv
=
InsertAudioLevelForContributingSource
(
aRecvTrack
aSource
aTimestamp
aHasLevel
aLevel
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
AddRIDExtension
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aRecvTrack
unsigned
short
aExtensionId
)
{
rv
=
AddRIDExtension
(
aRecvTrack
aExtensionId
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
AddRIDFilter
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aRecvTrack
const
nsAString
&
aRid
)
{
rv
=
AddRIDFilter
(
aRecvTrack
aRid
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
EnablePacketDump
ErrorResult
&
rv
unsigned
long
level
dom
:
:
mozPacketDumpType
type
bool
sending
)
{
rv
=
EnablePacketDump
(
level
type
sending
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
DisablePacketDump
ErrorResult
&
rv
unsigned
long
level
dom
:
:
mozPacketDumpType
type
bool
sending
)
{
rv
=
DisablePacketDump
(
level
type
sending
)
;
}
void
GetPeerIdentity
(
nsAString
&
peerIdentity
)
{
if
(
mPeerIdentity
)
{
peerIdentity
=
mPeerIdentity
-
>
ToString
(
)
;
}
peerIdentity
.
SetIsVoid
(
true
)
;
}
const
PeerIdentity
*
GetPeerIdentity
(
)
const
{
return
mPeerIdentity
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
SetPeerIdentity
ErrorResult
&
rv
const
nsAString
&
peerIdentity
)
{
rv
=
SetPeerIdentity
(
peerIdentity
)
;
}
const
std
:
:
string
&
GetIdAsAscii
(
)
const
{
return
mName
;
}
void
GetId
(
nsAString
&
id
)
{
id
=
NS_ConvertASCIItoUTF16
(
mName
.
c_str
(
)
)
;
}
void
SetId
(
const
nsAString
&
id
)
{
mName
=
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
;
}
bool
PrivacyRequested
(
)
const
{
return
mPrivacyRequested
;
}
NS_IMETHODIMP
GetFingerprint
(
char
*
*
fingerprint
)
;
void
GetFingerprint
(
nsAString
&
fingerprint
)
{
char
*
tmp
;
GetFingerprint
(
&
tmp
)
;
fingerprint
.
AssignASCII
(
tmp
)
;
delete
[
]
tmp
;
}
void
GetLocalDescription
(
nsAString
&
aSDP
)
;
void
GetCurrentLocalDescription
(
nsAString
&
aSDP
)
;
void
GetPendingLocalDescription
(
nsAString
&
aSDP
)
;
void
GetRemoteDescription
(
nsAString
&
aSDP
)
;
void
GetCurrentRemoteDescription
(
nsAString
&
aSDP
)
;
void
GetPendingRemoteDescription
(
nsAString
&
aSDP
)
;
NS_IMETHODIMP
SignalingState
(
mozilla
:
:
dom
:
:
PCImplSignalingState
*
aState
)
;
mozilla
:
:
dom
:
:
PCImplSignalingState
SignalingState
(
)
{
mozilla
:
:
dom
:
:
PCImplSignalingState
state
;
SignalingState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
IceConnectionState
(
mozilla
:
:
dom
:
:
PCImplIceConnectionState
*
aState
)
;
mozilla
:
:
dom
:
:
PCImplIceConnectionState
IceConnectionState
(
)
{
mozilla
:
:
dom
:
:
PCImplIceConnectionState
state
;
IceConnectionState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
IceGatheringState
(
mozilla
:
:
dom
:
:
PCImplIceGatheringState
*
aState
)
;
mozilla
:
:
dom
:
:
PCImplIceGatheringState
IceGatheringState
(
)
{
mozilla
:
:
dom
:
:
PCImplIceGatheringState
state
;
IceGatheringState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
Close
(
)
;
void
Close
(
ErrorResult
&
rv
)
{
rv
=
Close
(
)
;
}
bool
PluginCrash
(
uint32_t
aPluginID
const
nsAString
&
aPluginName
)
;
void
RecordEndOfCallTelemetry
(
)
const
;
nsresult
InitializeDataChannel
(
)
;
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
(
nsDOMDataChannel
CreateDataChannel
ErrorResult
&
rv
const
nsAString
&
aLabel
const
nsAString
&
aProtocol
uint16_t
aType
bool
outOfOrderAllowed
uint16_t
aMaxTime
uint16_t
aMaxNum
bool
aExternalNegotiated
uint16_t
aStream
)
;
void
OnSdpParseError
(
const
char
*
errorMessage
)
;
void
ClearSdpParseErrorMessages
(
)
;
const
std
:
:
vector
<
std
:
:
string
>
&
GetSdpParseErrors
(
)
;
void
SetSignalingState_m
(
mozilla
:
:
dom
:
:
PCImplSignalingState
aSignalingState
bool
rollback
=
false
)
;
void
UpdateSignalingState
(
bool
rollback
=
false
)
;
bool
IsClosed
(
)
const
;
nsresult
SetDtlsConnected
(
bool
aPrivacyRequested
)
;
bool
HasMedia
(
)
const
;
void
startCallTelem
(
)
;
nsresult
BuildStatsQuery_m
(
mozilla
:
:
dom
:
:
MediaStreamTrack
*
aSelector
RTCStatsQuery
*
query
)
;
static
nsresult
ExecuteStatsQuery_s
(
RTCStatsQuery
*
query
)
;
virtual
void
PrincipalChanged
(
dom
:
:
MediaStreamTrack
*
aTrack
)
override
;
void
OnMediaError
(
const
std
:
:
string
&
aError
)
;
bool
ShouldDumpPacket
(
size_t
level
dom
:
:
mozPacketDumpType
type
bool
sending
)
const
;
void
DumpPacket_m
(
size_t
level
dom
:
:
mozPacketDumpType
type
bool
sending
UniquePtr
<
uint8_t
[
]
>
&
packet
size_t
size
)
;
private
:
virtual
~
PeerConnectionImpl
(
)
;
PeerConnectionImpl
(
const
PeerConnectionImpl
&
rhs
)
;
PeerConnectionImpl
&
operator
=
(
PeerConnectionImpl
)
;
nsresult
CalculateFingerprint
(
const
std
:
:
string
&
algorithm
std
:
:
vector
<
uint8_t
>
*
fingerprint
)
const
;
nsresult
ConfigureJsepSessionCodecs
(
)
;
NS_IMETHODIMP
EnsureDataConnection
(
uint16_t
aLocalPort
uint16_t
aNumstreams
uint32_t
aMaxMessageSize
bool
aMMSSet
)
;
nsresult
CloseInt
(
)
;
nsresult
CheckApiState
(
bool
assert_ice_ready
)
const
;
void
CheckThread
(
)
const
{
MOZ_ASSERT
(
CheckThreadInt
(
)
"
Wrong
thread
"
)
;
}
bool
CheckThreadInt
(
)
const
{
bool
on
;
NS_ENSURE_SUCCESS
(
mThread
-
>
IsOnCurrentThread
(
&
on
)
false
)
;
NS_ENSURE_TRUE
(
on
false
)
;
return
true
;
}
RefPtr
<
MediaPipeline
>
GetMediaPipelineForTrack
(
dom
:
:
MediaStreamTrack
&
aRecvTrack
)
;
nsresult
GetTimeSinceEpoch
(
DOMHighResTimeStamp
*
result
)
;
void
ShutdownMedia
(
)
;
void
CandidateReady
(
const
std
:
:
string
&
candidate
uint16_t
level
)
;
void
SendLocalIceCandidateToContent
(
uint16_t
level
const
std
:
:
string
&
mid
const
std
:
:
string
&
candidate
)
;
nsresult
GetDatachannelParameters
(
uint32_t
*
channels
uint16_t
*
localport
uint16_t
*
remoteport
uint32_t
*
maxmessagesize
bool
*
mmsset
uint16_t
*
level
)
const
;
nsresult
AddRtpTransceiverToJsepSession
(
RefPtr
<
JsepTransceiver
>
&
transceiver
)
;
already_AddRefed
<
TransceiverImpl
>
CreateTransceiverImpl
(
JsepTransceiver
*
aJsepTransceiver
dom
:
:
MediaStreamTrack
*
aSendTrack
ErrorResult
&
aRv
)
;
nsresult
SetupIceRestartCredentials
(
)
;
void
BeginIceRestart
(
)
;
nsresult
ResetIceCredentials
(
)
;
nsresult
RollbackIceRestart
(
)
;
void
FinalizeIceRestart
(
)
;
static
void
GetStatsForPCObserver_s
(
const
std
:
:
string
&
pcHandle
nsAutoPtr
<
RTCStatsQuery
>
query
)
;
static
void
DeliverStatsReportToPCObserver_m
(
const
std
:
:
string
&
pcHandle
nsresult
result
nsAutoPtr
<
RTCStatsQuery
>
query
)
;
void
RecordLongtermICEStatistics
(
)
;
Timecard
*
mTimeCard
;
mozilla
:
:
dom
:
:
PCImplSignalingState
mSignalingState
;
mozilla
:
:
dom
:
:
PCImplIceConnectionState
mIceConnectionState
;
mozilla
:
:
dom
:
:
PCImplIceGatheringState
mIceGatheringState
;
bool
mDtlsConnected
;
nsCOMPtr
<
nsIThread
>
mThread
;
nsWeakPtr
mPCObserver
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
std
:
:
string
mLocalRequestedSDP
;
std
:
:
string
mRemoteRequestedSDP
;
std
:
:
string
mFingerprint
;
std
:
:
string
mRemoteFingerprint
;
RefPtr
<
PeerIdentity
>
mPeerIdentity
;
RefPtr
<
mozilla
:
:
dom
:
:
RTCCertificate
>
mCertificate
;
bool
mPrivacyRequested
;
std
:
:
string
mHandle
;
std
:
:
string
mName
;
nsCOMPtr
<
nsIEventTarget
>
mSTSThread
;
RefPtr
<
mozilla
:
:
DataChannelConnection
>
mDataConnection
;
bool
mAllowIceLoopback
;
bool
mAllowIceLinkLocal
;
bool
mForceIceTcp
;
RefPtr
<
PeerConnectionMedia
>
mMedia
;
mozilla
:
:
UniquePtr
<
PCUuidGenerator
>
mUuidGen
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
JsepSession
>
mJsepSession
;
std
:
:
string
mPreviousIceUfrag
;
std
:
:
string
mPreviousIcePwd
;
unsigned
long
mIceRestartCount
;
unsigned
long
mIceRollbackCount
;
mozilla
:
:
TimeStamp
mIceStartTime
;
mozilla
:
:
TimeStamp
mStartTime
;
bool
mHaveConfiguredCodecs
;
bool
mHaveDataStream
;
unsigned
int
mAddCandidateErrorCount
;
bool
mTrickle
;
bool
mPrivateWindow
;
bool
mActiveOnWindow
;
uint16_t
mMaxReceiving
[
SdpMediaSection
:
:
kMediaTypes
]
;
uint16_t
mMaxSending
[
SdpMediaSection
:
:
kMediaTypes
]
;
class
DTMFState
:
public
nsITimerCallback
{
virtual
~
DTMFState
(
)
;
public
:
DTMFState
(
)
;
NS_DECL_NSITIMERCALLBACK
NS_DECL_THREADSAFE_ISUPPORTS
nsWeakPtr
mPCObserver
;
RefPtr
<
TransceiverImpl
>
mTransceiver
;
nsCOMPtr
<
nsITimer
>
mSendTimer
;
nsString
mTones
;
uint32_t
mDuration
;
uint32_t
mInterToneGap
;
}
;
nsTArray
<
RefPtr
<
DTMFState
>
>
mDTMFStates
;
std
:
:
vector
<
unsigned
>
mSendPacketDumpFlags
;
std
:
:
vector
<
unsigned
>
mRecvPacketDumpFlags
;
Atomic
<
bool
>
mPacketDumpEnabled
;
mutable
Mutex
mPacketDumpFlagsMutex
;
std
:
:
vector
<
std
:
:
string
>
mRawTrickledCandidates
;
public
:
unsigned
short
listenPort
;
unsigned
short
connectPort
;
char
*
connectStr
;
}
;
class
PeerConnectionWrapper
{
public
:
explicit
PeerConnectionWrapper
(
const
std
:
:
string
&
handle
)
;
PeerConnectionImpl
*
impl
(
)
{
return
impl_
;
}
private
:
RefPtr
<
PeerConnectionImpl
>
impl_
;
}
;
}
#
undef
NS_IMETHODIMP_TO_ERRORRESULT
#
undef
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
#
endif
