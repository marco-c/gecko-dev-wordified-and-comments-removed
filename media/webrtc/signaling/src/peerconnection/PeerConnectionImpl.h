#
ifndef
_PEER_CONNECTION_IMPL_H_
#
define
_PEER_CONNECTION_IMPL_H_
#
include
<
deque
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
map
>
#
include
<
cmath
>
#
include
"
prlock
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
IPeerConnection
.
h
"
#
include
"
sigslot
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
ifdef
GetLastError
#
undef
GetLastError
#
endif
#
include
"
signaling
/
src
/
jsep
/
JsepSession
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepSessionImpl
.
h
"
#
include
"
signaling
/
src
/
sdp
/
SdpMediaSection
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
PeerConnectionImplEnumsBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCPeerConnectionBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpTransceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCConfigurationBinding
.
h
"
#
include
"
PrincipalChangeObserver
.
h
"
#
include
"
StreamTracks
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
net
/
DataChannel
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
mozilla
/
dom
/
RTCStatsReportBinding
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
mozilla
/
PeerIdentity
.
h
"
namespace
test
{
#
ifdef
USE_FAKE_PCOBSERVER
class
AFakePCObserver
;
#
endif
}
class
nsDOMDataChannel
;
namespace
mozilla
{
class
DataChannel
;
class
DtlsIdentity
;
class
MediaPipeline
;
class
TransceiverImpl
;
namespace
dom
{
class
RTCCertificate
;
struct
RTCConfiguration
;
struct
RTCRtpSourceEntry
;
class
RTCDTMFSender
;
struct
RTCIceServer
;
struct
RTCOfferOptions
;
struct
RTCRtpParameters
;
class
RTCRtpSender
;
class
MediaStreamTrack
;
#
ifdef
USE_FAKE_PCOBSERVER
typedef
test
:
:
AFakePCObserver
PeerConnectionObserver
;
typedef
const
char
*
PCObserverString
;
#
else
class
PeerConnectionObserver
;
typedef
NS_ConvertUTF8toUTF16
PCObserverString
;
#
endif
}
}
#
if
defined
(
__cplusplus
)
&
&
__cplusplus
>
=
201103L
typedef
struct
Timecard
Timecard
;
#
else
#
include
"
signaling
/
src
/
common
/
time_profiling
/
timecard
.
h
"
#
endif
#
define
NS_IMETHODIMP_TO_ERRORRESULT
(
func
rv
.
.
.
)
\
NS_IMETHODIMP
func
(
__VA_ARGS__
)
;
\
void
func
(
__VA_ARGS__
rv
)
#
define
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
(
resulttype
func
rv
.
.
.
)
\
NS_IMETHODIMP
func
(
__VA_ARGS__
resulttype
*
*
result
)
;
\
already_AddRefed
<
resulttype
>
func
(
__VA_ARGS__
rv
)
struct
MediaStreamTable
;
namespace
mozilla
{
using
mozilla
:
:
DtlsIdentity
;
using
mozilla
:
:
ErrorResult
;
using
mozilla
:
:
PeerIdentity
;
using
mozilla
:
:
dom
:
:
PeerConnectionObserver
;
using
mozilla
:
:
dom
:
:
RTCConfiguration
;
using
mozilla
:
:
dom
:
:
RTCIceServer
;
using
mozilla
:
:
dom
:
:
RTCOfferOptions
;
class
PeerConnectionWrapper
;
class
PeerConnectionMedia
;
class
RemoteSourceStreamInfo
;
class
PCUuidGenerator
:
public
mozilla
:
:
JsepUuidGenerator
{
public
:
virtual
bool
Generate
(
std
:
:
string
*
idp
)
override
;
private
:
nsCOMPtr
<
nsIUUIDGenerator
>
mGenerator
;
}
;
class
RTCStatsQuery
{
public
:
explicit
RTCStatsQuery
(
bool
internalStats
)
;
RTCStatsQuery
(
RTCStatsQuery
&
&
aOrig
)
=
default
;
~
RTCStatsQuery
(
)
;
std
:
:
unique_ptr
<
mozilla
:
:
dom
:
:
RTCStatsReportInternal
>
report
;
mozilla
:
:
TimeStamp
iceStartTime
;
bool
internalStats
;
std
:
:
string
transportId
;
bool
grabAllLevels
;
DOMHighResTimeStamp
now
;
}
;
typedef
MozPromise
<
UniquePtr
<
RTCStatsQuery
>
nsresult
true
>
RTCStatsQueryPromise
;
#
define
PC_AUTO_ENTER_API_CALL
(
assert_ice_ready
)
\
do
{
\
/
*
do
/
while
prevents
res
from
conflicting
with
locals
*
/
\
nsresult
res
=
CheckApiState
(
assert_ice_ready
)
;
\
if
(
NS_FAILED
(
res
)
)
return
res
;
\
}
while
(
0
)
#
define
PC_AUTO_ENTER_API_CALL_VOID_RETURN
(
assert_ice_ready
)
\
do
{
\
/
*
do
/
while
prevents
res
from
conflicting
with
locals
*
/
\
nsresult
res
=
CheckApiState
(
assert_ice_ready
)
;
\
if
(
NS_FAILED
(
res
)
)
return
;
\
}
while
(
0
)
#
define
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
CheckThread
(
)
class
PeerConnectionImpl
final
:
public
nsISupports
public
mozilla
:
:
DataChannelConnection
:
:
DataConnectionListener
public
dom
:
:
PrincipalChangeObserver
<
dom
:
:
MediaStreamTrack
>
public
sigslot
:
:
has_slots
<
>
{
struct
Internal
;
public
:
explicit
PeerConnectionImpl
(
const
mozilla
:
:
dom
:
:
GlobalObject
*
aGlobal
=
nullptr
)
;
enum
Error
{
kNoError
=
0
kInvalidCandidate
=
2
kInvalidMediastreamTrack
=
3
kInvalidState
=
4
kInvalidSessionDescription
=
5
kIncompatibleSessionDescription
=
6
kIncompatibleMediaStreamTrack
=
8
kInternalError
=
9
kTypeError
=
10
kOperationError
=
11
}
;
NS_DECL_THREADSAFE_ISUPPORTS
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
;
static
already_AddRefed
<
PeerConnectionImpl
>
Constructor
(
const
mozilla
:
:
dom
:
:
GlobalObject
&
aGlobal
ErrorResult
&
rv
)
;
static
PeerConnectionImpl
*
CreatePeerConnection
(
)
;
nsresult
CreateRemoteSourceStreamInfo
(
RefPtr
<
RemoteSourceStreamInfo
>
*
aInfo
const
std
:
:
string
&
aId
)
;
void
NotifyDataChannel
(
already_AddRefed
<
mozilla
:
:
DataChannel
>
aChannel
)
override
;
const
RefPtr
<
MediaTransportHandler
>
GetTransportHandler
(
)
const
;
const
RefPtr
<
PeerConnectionMedia
>
&
media
(
)
const
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mMedia
;
}
virtual
const
std
:
:
string
&
GetHandle
(
)
;
virtual
const
std
:
:
string
&
GetName
(
)
;
void
IceConnectionStateChange
(
dom
:
:
PCImplIceConnectionState
state
)
;
void
IceGatheringStateChange
(
dom
:
:
PCImplIceGatheringState
state
)
;
void
UpdateDefaultCandidate
(
const
std
:
:
string
&
defaultAddr
uint16_t
defaultPort
const
std
:
:
string
&
defaultRtcpAddr
uint16_t
defaultRtcpPort
const
std
:
:
string
&
transportId
)
;
static
void
ListenThread
(
void
*
aData
)
;
static
void
ConnectThread
(
void
*
aData
)
;
nsCOMPtr
<
nsIThread
>
GetMainThread
(
)
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mThread
;
}
nsIEventTarget
*
GetSTSThread
(
)
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mSTSThread
;
}
nsPIDOMWindowInner
*
GetWindow
(
)
const
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mWindow
;
}
nsresult
Initialize
(
PeerConnectionObserver
&
aObserver
nsGlobalWindowInner
*
aWindow
const
RTCConfiguration
&
aConfiguration
nsISupports
*
aThread
)
;
void
Initialize
(
PeerConnectionObserver
&
aObserver
nsGlobalWindowInner
&
aWindow
const
RTCConfiguration
&
aConfiguration
nsISupports
*
aThread
ErrorResult
&
rv
)
;
void
SetCertificate
(
mozilla
:
:
dom
:
:
RTCCertificate
&
aCertificate
)
;
const
RefPtr
<
mozilla
:
:
dom
:
:
RTCCertificate
>
&
Certificate
(
)
const
;
RefPtr
<
DtlsIdentity
>
Identity
(
)
const
;
NS_IMETHODIMP_TO_ERRORRESULT
(
CreateOffer
ErrorResult
&
rv
const
RTCOfferOptions
&
aOptions
)
{
rv
=
CreateOffer
(
aOptions
)
;
}
NS_IMETHODIMP
CreateAnswer
(
)
;
void
CreateAnswer
(
ErrorResult
&
rv
)
{
rv
=
CreateAnswer
(
)
;
}
NS_IMETHODIMP
CreateOffer
(
const
mozilla
:
:
JsepOfferOptions
&
aConstraints
)
;
NS_IMETHODIMP
SetLocalDescription
(
int32_t
aAction
const
char
*
aSDP
)
;
void
SetLocalDescription
(
int32_t
aAction
const
nsAString
&
aSDP
ErrorResult
&
rv
)
{
rv
=
SetLocalDescription
(
aAction
NS_ConvertUTF16toUTF8
(
aSDP
)
.
get
(
)
)
;
}
NS_IMETHODIMP
SetRemoteDescription
(
int32_t
aAction
const
char
*
aSDP
)
;
void
SetRemoteDescription
(
int32_t
aAction
const
nsAString
&
aSDP
ErrorResult
&
rv
)
{
rv
=
SetRemoteDescription
(
aAction
NS_ConvertUTF16toUTF8
(
aSDP
)
.
get
(
)
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetStats
ErrorResult
&
rv
mozilla
:
:
dom
:
:
MediaStreamTrack
*
aSelector
)
{
rv
=
GetStats
(
aSelector
)
;
}
NS_IMETHODIMP
AddIceCandidate
(
const
char
*
aCandidate
const
char
*
aMid
const
dom
:
:
Nullable
<
unsigned
short
>
&
aLevel
)
;
void
AddIceCandidate
(
const
nsAString
&
aCandidate
const
nsAString
&
aMid
const
dom
:
:
Nullable
<
unsigned
short
>
&
aLevel
ErrorResult
&
rv
)
{
rv
=
AddIceCandidate
(
NS_ConvertUTF16toUTF8
(
aCandidate
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aMid
)
.
get
(
)
aLevel
)
;
}
void
UpdateNetworkState
(
bool
online
)
;
NS_IMETHODIMP
CloseStreams
(
)
;
void
CloseStreams
(
ErrorResult
&
rv
)
{
rv
=
CloseStreams
(
)
;
}
already_AddRefed
<
TransceiverImpl
>
CreateTransceiverImpl
(
const
nsAString
&
aKind
dom
:
:
MediaStreamTrack
*
aSendTrack
ErrorResult
&
rv
)
;
OwningNonNull
<
dom
:
:
MediaStreamTrack
>
CreateReceiveTrack
(
SdpMediaSection
:
:
MediaType
type
)
;
bool
CheckNegotiationNeeded
(
ErrorResult
&
rv
)
;
NS_IMETHODIMP_TO_ERRORRESULT
(
InsertDTMF
ErrorResult
&
rv
TransceiverImpl
&
transceiver
const
nsAString
&
tones
uint32_t
duration
uint32_t
interToneGap
)
{
rv
=
InsertDTMF
(
transceiver
tones
duration
interToneGap
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetDTMFToneBuffer
ErrorResult
&
rv
dom
:
:
RTCRtpSender
&
sender
nsAString
&
outToneBuffer
)
{
rv
=
GetDTMFToneBuffer
(
sender
outToneBuffer
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetRtpSources
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aRecvTrack
DOMHighResTimeStamp
aRtpSourceNow
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
&
outRtpSources
)
{
rv
=
GetRtpSources
(
aRecvTrack
aRtpSourceNow
outRtpSources
)
;
}
DOMHighResTimeStamp
GetNowInRtpSourceReferenceTime
(
)
;
NS_IMETHODIMP_TO_ERRORRESULT
(
ReplaceTrackNoRenegotiation
ErrorResult
&
rv
TransceiverImpl
&
aTransceiver
mozilla
:
:
dom
:
:
MediaStreamTrack
*
aWithTrack
)
{
rv
=
ReplaceTrackNoRenegotiation
(
aTransceiver
aWithTrack
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
InsertAudioLevelForContributingSource
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aRecvTrack
unsigned
long
aSource
DOMHighResTimeStamp
aTimestamp
bool
aHasLevel
uint8_t
aLevel
)
{
rv
=
InsertAudioLevelForContributingSource
(
aRecvTrack
aSource
aTimestamp
aHasLevel
aLevel
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
AddRIDExtension
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aRecvTrack
unsigned
short
aExtensionId
)
{
rv
=
AddRIDExtension
(
aRecvTrack
aExtensionId
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
AddRIDFilter
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aRecvTrack
const
nsAString
&
aRid
)
{
rv
=
AddRIDFilter
(
aRecvTrack
aRid
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
EnablePacketDump
ErrorResult
&
rv
unsigned
long
level
dom
:
:
mozPacketDumpType
type
bool
sending
)
{
rv
=
EnablePacketDump
(
level
type
sending
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
DisablePacketDump
ErrorResult
&
rv
unsigned
long
level
dom
:
:
mozPacketDumpType
type
bool
sending
)
{
rv
=
DisablePacketDump
(
level
type
sending
)
;
}
void
GetPeerIdentity
(
nsAString
&
peerIdentity
)
{
if
(
mPeerIdentity
)
{
peerIdentity
=
mPeerIdentity
-
>
ToString
(
)
;
}
peerIdentity
.
SetIsVoid
(
true
)
;
}
const
PeerIdentity
*
GetPeerIdentity
(
)
const
{
return
mPeerIdentity
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
SetPeerIdentity
ErrorResult
&
rv
const
nsAString
&
peerIdentity
)
{
rv
=
SetPeerIdentity
(
peerIdentity
)
;
}
const
std
:
:
string
&
GetIdAsAscii
(
)
const
{
return
mName
;
}
void
GetId
(
nsAString
&
id
)
{
id
=
NS_ConvertASCIItoUTF16
(
mName
.
c_str
(
)
)
;
}
void
SetId
(
const
nsAString
&
id
)
{
mName
=
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
;
}
bool
PrivacyRequested
(
)
const
{
return
mPrivacyRequested
.
isSome
(
)
&
&
*
mPrivacyRequested
;
}
NS_IMETHODIMP
GetFingerprint
(
char
*
*
fingerprint
)
;
void
GetFingerprint
(
nsAString
&
fingerprint
)
{
char
*
tmp
;
GetFingerprint
(
&
tmp
)
;
fingerprint
.
AssignASCII
(
tmp
)
;
delete
[
]
tmp
;
}
void
GetLocalDescription
(
nsAString
&
aSDP
)
;
void
GetCurrentLocalDescription
(
nsAString
&
aSDP
)
;
void
GetPendingLocalDescription
(
nsAString
&
aSDP
)
;
void
GetRemoteDescription
(
nsAString
&
aSDP
)
;
void
GetCurrentRemoteDescription
(
nsAString
&
aSDP
)
;
void
GetPendingRemoteDescription
(
nsAString
&
aSDP
)
;
NS_IMETHODIMP
SignalingState
(
mozilla
:
:
dom
:
:
PCImplSignalingState
*
aState
)
;
mozilla
:
:
dom
:
:
PCImplSignalingState
SignalingState
(
)
{
mozilla
:
:
dom
:
:
PCImplSignalingState
state
;
SignalingState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
IceConnectionState
(
mozilla
:
:
dom
:
:
PCImplIceConnectionState
*
aState
)
;
mozilla
:
:
dom
:
:
PCImplIceConnectionState
IceConnectionState
(
)
{
mozilla
:
:
dom
:
:
PCImplIceConnectionState
state
;
IceConnectionState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
IceGatheringState
(
mozilla
:
:
dom
:
:
PCImplIceGatheringState
*
aState
)
;
mozilla
:
:
dom
:
:
PCImplIceGatheringState
IceGatheringState
(
)
{
mozilla
:
:
dom
:
:
PCImplIceGatheringState
state
;
IceGatheringState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
Close
(
)
;
void
Close
(
ErrorResult
&
rv
)
{
rv
=
Close
(
)
;
}
bool
PluginCrash
(
uint32_t
aPluginID
const
nsAString
&
aPluginName
)
;
void
RecordEndOfCallTelemetry
(
)
const
;
nsresult
InitializeDataChannel
(
)
;
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
(
nsDOMDataChannel
CreateDataChannel
ErrorResult
&
rv
const
nsAString
&
aLabel
const
nsAString
&
aProtocol
uint16_t
aType
bool
outOfOrderAllowed
uint16_t
aMaxTime
uint16_t
aMaxNum
bool
aExternalNegotiated
uint16_t
aStream
)
;
void
OnSdpParseError
(
const
char
*
errorMessage
)
;
void
ClearSdpParseErrorMessages
(
)
;
const
std
:
:
vector
<
std
:
:
string
>
&
GetSdpParseErrors
(
)
;
void
SetSignalingState_m
(
mozilla
:
:
dom
:
:
PCImplSignalingState
aSignalingState
bool
rollback
=
false
)
;
void
UpdateSignalingState
(
bool
rollback
=
false
)
;
bool
IsClosed
(
)
const
;
nsresult
OnAlpnNegotiated
(
const
std
:
:
string
&
aAlpn
)
;
bool
HasMedia
(
)
const
;
void
startCallTelem
(
)
;
RefPtr
<
RTCStatsQueryPromise
>
GetStats
(
dom
:
:
MediaStreamTrack
*
aSelector
bool
aInternalStats
)
;
virtual
void
PrincipalChanged
(
dom
:
:
MediaStreamTrack
*
aTrack
)
override
;
void
OnMediaError
(
const
std
:
:
string
&
aError
)
;
bool
ShouldDumpPacket
(
size_t
level
dom
:
:
mozPacketDumpType
type
bool
sending
)
const
;
void
DumpPacket_m
(
size_t
level
dom
:
:
mozPacketDumpType
type
bool
sending
UniquePtr
<
uint8_t
[
]
>
&
packet
size_t
size
)
;
private
:
virtual
~
PeerConnectionImpl
(
)
;
PeerConnectionImpl
(
const
PeerConnectionImpl
&
rhs
)
;
PeerConnectionImpl
&
operator
=
(
PeerConnectionImpl
)
;
nsresult
BuildStatsQuery_m
(
mozilla
:
:
dom
:
:
MediaStreamTrack
*
aSelector
RTCStatsQuery
*
query
)
;
static
RefPtr
<
RTCStatsQueryPromise
>
ExecuteStatsQuery_s
(
UniquePtr
<
RTCStatsQuery
>
&
&
query
const
nsTArray
<
RefPtr
<
MediaPipeline
>
>
&
aPipelines
const
RefPtr
<
MediaTransportHandler
>
&
aTransportHandler
)
;
nsresult
CalculateFingerprint
(
const
std
:
:
string
&
algorithm
std
:
:
vector
<
uint8_t
>
*
fingerprint
)
const
;
nsresult
ConfigureJsepSessionCodecs
(
)
;
NS_IMETHODIMP
EnsureDataConnection
(
uint16_t
aLocalPort
uint16_t
aNumstreams
uint32_t
aMaxMessageSize
bool
aMMSSet
)
;
nsresult
CloseInt
(
)
;
nsresult
CheckApiState
(
bool
assert_ice_ready
)
const
;
void
CheckThread
(
)
const
{
MOZ_ASSERT
(
CheckThreadInt
(
)
"
Wrong
thread
"
)
;
}
bool
CheckThreadInt
(
)
const
{
bool
on
;
NS_ENSURE_SUCCESS
(
mThread
-
>
IsOnCurrentThread
(
&
on
)
false
)
;
NS_ENSURE_TRUE
(
on
false
)
;
return
true
;
}
RefPtr
<
MediaPipeline
>
GetMediaPipelineForTrack
(
dom
:
:
MediaStreamTrack
&
aRecvTrack
)
;
nsresult
GetTimeSinceEpoch
(
DOMHighResTimeStamp
*
result
)
;
void
ShutdownMedia
(
)
;
void
CandidateReady
(
const
std
:
:
string
&
candidate
const
std
:
:
string
&
transportId
)
;
void
SendLocalIceCandidateToContent
(
uint16_t
level
const
std
:
:
string
&
mid
const
std
:
:
string
&
candidate
)
;
nsresult
GetDatachannelParameters
(
uint32_t
*
channels
uint16_t
*
localport
uint16_t
*
remoteport
uint32_t
*
maxmessagesize
bool
*
mmsset
std
:
:
string
*
transportId
bool
*
client
)
const
;
nsresult
AddRtpTransceiverToJsepSession
(
RefPtr
<
JsepTransceiver
>
&
transceiver
)
;
already_AddRefed
<
TransceiverImpl
>
CreateTransceiverImpl
(
JsepTransceiver
*
aJsepTransceiver
dom
:
:
MediaStreamTrack
*
aSendTrack
ErrorResult
&
aRv
)
;
static
void
DeliverStatsReportToPCObserver_m
(
const
std
:
:
string
&
pcHandle
nsresult
result
const
nsAutoPtr
<
RTCStatsQuery
>
&
query
)
;
void
RecordLongtermICEStatistics
(
)
;
void
RecordIceRestartStatistics
(
JsepSdpType
type
)
;
Timecard
*
mTimeCard
;
mozilla
:
:
dom
:
:
PCImplSignalingState
mSignalingState
;
mozilla
:
:
dom
:
:
PCImplIceConnectionState
mIceConnectionState
;
mozilla
:
:
dom
:
:
PCImplIceGatheringState
mIceGatheringState
;
nsCOMPtr
<
nsIThread
>
mThread
;
nsWeakPtr
mPCObserver
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
std
:
:
string
mLocalRequestedSDP
;
std
:
:
string
mRemoteRequestedSDP
;
std
:
:
string
mFingerprint
;
std
:
:
string
mRemoteFingerprint
;
RefPtr
<
PeerIdentity
>
mPeerIdentity
;
RefPtr
<
mozilla
:
:
dom
:
:
RTCCertificate
>
mCertificate
;
Maybe
<
bool
>
mPrivacyRequested
;
std
:
:
string
mHandle
;
std
:
:
string
mName
;
nsCOMPtr
<
nsISerialEventTarget
>
mSTSThread
;
RefPtr
<
mozilla
:
:
DataChannelConnection
>
mDataConnection
;
bool
mForceIceTcp
;
RefPtr
<
PeerConnectionMedia
>
mMedia
;
RefPtr
<
MediaTransportHandler
>
mTransportHandler
;
mozilla
:
:
UniquePtr
<
PCUuidGenerator
>
mUuidGen
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
JsepSession
>
mJsepSession
;
unsigned
long
mIceRestartCount
;
unsigned
long
mIceRollbackCount
;
mozilla
:
:
TimeStamp
mIceStartTime
;
mozilla
:
:
TimeStamp
mStartTime
;
bool
mHaveConfiguredCodecs
;
unsigned
int
mAddCandidateErrorCount
;
bool
mTrickle
;
bool
mPrivateWindow
;
bool
mActiveOnWindow
;
uint16_t
mMaxReceiving
[
SdpMediaSection
:
:
kMediaTypes
]
;
uint16_t
mMaxSending
[
SdpMediaSection
:
:
kMediaTypes
]
;
class
DTMFState
:
public
nsITimerCallback
{
virtual
~
DTMFState
(
)
;
public
:
DTMFState
(
)
;
NS_DECL_NSITIMERCALLBACK
NS_DECL_THREADSAFE_ISUPPORTS
nsWeakPtr
mPCObserver
;
RefPtr
<
TransceiverImpl
>
mTransceiver
;
nsCOMPtr
<
nsITimer
>
mSendTimer
;
nsString
mTones
;
uint32_t
mDuration
;
uint32_t
mInterToneGap
;
}
;
nsTArray
<
RefPtr
<
DTMFState
>
>
mDTMFStates
;
std
:
:
vector
<
unsigned
>
mSendPacketDumpFlags
;
std
:
:
vector
<
unsigned
>
mRecvPacketDumpFlags
;
Atomic
<
bool
>
mPacketDumpEnabled
;
mutable
Mutex
mPacketDumpFlagsMutex
;
std
:
:
vector
<
std
:
:
string
>
mRawTrickledCandidates
;
public
:
unsigned
short
listenPort
;
unsigned
short
connectPort
;
char
*
connectStr
;
}
;
class
PeerConnectionWrapper
{
public
:
explicit
PeerConnectionWrapper
(
const
std
:
:
string
&
handle
)
;
PeerConnectionImpl
*
impl
(
)
{
return
impl_
;
}
private
:
RefPtr
<
PeerConnectionImpl
>
impl_
;
}
;
}
#
undef
NS_IMETHODIMP_TO_ERRORRESULT
#
undef
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
#
endif
