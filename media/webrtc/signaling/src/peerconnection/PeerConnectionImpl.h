#
ifndef
_PEER_CONNECTION_IMPL_H_
#
define
_PEER_CONNECTION_IMPL_H_
#
include
<
deque
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
map
>
#
include
<
cmath
>
#
include
"
prlock
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsWeakPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
IPeerConnection
.
h
"
#
include
"
sigslot
.
h
"
#
include
"
nricectx
.
h
"
#
include
"
nricemediastream
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepSession
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepSessionImpl
.
h
"
#
include
"
signaling
/
src
/
sdp
/
SdpMediaSection
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
PeerConnectionImplEnumsBinding
.
h
"
#
include
"
StreamBuffer
.
h
"
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
net
/
DataChannel
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
mozilla
/
dom
/
RTCStatsReportBinding
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
mozilla
/
PeerIdentity
.
h
"
#
ifndef
USE_FAKE_MEDIA_STREAMS
#
include
"
DOMMediaStream
.
h
"
#
endif
#
endif
namespace
test
{
#
ifdef
USE_FAKE_PCOBSERVER
class
AFakePCObserver
;
#
endif
}
#
ifdef
USE_FAKE_MEDIA_STREAMS
class
Fake_DOMMediaStream
;
class
Fake_MediaStreamTrack
;
#
endif
class
nsGlobalWindow
;
class
nsDOMDataChannel
;
namespace
mozilla
{
class
DataChannel
;
class
DtlsIdentity
;
class
NrIceCtx
;
class
NrIceMediaStream
;
class
NrIceStunServer
;
class
NrIceTurnServer
;
class
MediaPipeline
;
#
ifdef
USE_FAKE_MEDIA_STREAMS
typedef
Fake_DOMMediaStream
DOMMediaStream
;
#
else
class
DOMMediaStream
;
#
endif
namespace
dom
{
class
RTCCertificate
;
struct
RTCConfiguration
;
struct
RTCIceServer
;
struct
RTCOfferOptions
;
struct
RTCRtpParameters
;
#
ifdef
USE_FAKE_MEDIA_STREAMS
typedef
Fake_MediaStreamTrack
MediaStreamTrack
;
#
else
class
MediaStreamTrack
;
#
endif
#
ifdef
USE_FAKE_PCOBSERVER
typedef
test
:
:
AFakePCObserver
PeerConnectionObserver
;
typedef
const
char
*
PCObserverString
;
#
else
class
PeerConnectionObserver
;
typedef
NS_ConvertUTF8toUTF16
PCObserverString
;
#
endif
}
}
#
if
defined
(
__cplusplus
)
&
&
__cplusplus
>
=
201103L
typedef
struct
Timecard
Timecard
;
#
else
#
include
"
timecard
.
h
"
#
endif
#
define
NS_IMETHODIMP_TO_ERRORRESULT
(
func
rv
.
.
.
)
\
NS_IMETHODIMP
func
(
__VA_ARGS__
)
;
\
void
func
(
__VA_ARGS__
rv
)
#
define
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
(
resulttype
func
rv
.
.
.
)
\
NS_IMETHODIMP
func
(
__VA_ARGS__
resulttype
*
*
result
)
;
\
already_AddRefed
<
resulttype
>
func
(
__VA_ARGS__
rv
)
struct
MediaStreamTable
;
namespace
mozilla
{
using
mozilla
:
:
dom
:
:
PeerConnectionObserver
;
using
mozilla
:
:
dom
:
:
RTCConfiguration
;
using
mozilla
:
:
dom
:
:
RTCIceServer
;
using
mozilla
:
:
dom
:
:
RTCOfferOptions
;
using
mozilla
:
:
DOMMediaStream
;
using
mozilla
:
:
NrIceCtx
;
using
mozilla
:
:
NrIceMediaStream
;
using
mozilla
:
:
DtlsIdentity
;
using
mozilla
:
:
ErrorResult
;
using
mozilla
:
:
NrIceStunServer
;
using
mozilla
:
:
NrIceTurnServer
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
using
mozilla
:
:
PeerIdentity
;
#
endif
class
PeerConnectionWrapper
;
class
PeerConnectionMedia
;
class
RemoteSourceStreamInfo
;
class
PCUuidGenerator
:
public
mozilla
:
:
JsepUuidGenerator
{
public
:
virtual
bool
Generate
(
std
:
:
string
*
idp
)
override
;
private
:
nsCOMPtr
<
nsIUUIDGenerator
>
mGenerator
;
}
;
class
PeerConnectionConfiguration
{
public
:
PeerConnectionConfiguration
(
)
:
mBundlePolicy
(
kBundleBalanced
)
mIceTransportPolicy
(
NrIceCtx
:
:
ICE_POLICY_ALL
)
{
}
bool
addStunServer
(
const
std
:
:
string
&
addr
uint16_t
port
const
char
*
transport
)
{
UniquePtr
<
NrIceStunServer
>
server
(
NrIceStunServer
:
:
Create
(
addr
port
transport
)
)
;
if
(
!
server
)
{
return
false
;
}
addStunServer
(
*
server
)
;
return
true
;
}
bool
addTurnServer
(
const
std
:
:
string
&
addr
uint16_t
port
const
std
:
:
string
&
username
const
std
:
:
string
&
pwd
const
char
*
transport
)
{
std
:
:
vector
<
unsigned
char
>
password
(
pwd
.
begin
(
)
pwd
.
end
(
)
)
;
UniquePtr
<
NrIceTurnServer
>
server
(
NrIceTurnServer
:
:
Create
(
addr
port
username
password
transport
)
)
;
if
(
!
server
)
{
return
false
;
}
addTurnServer
(
*
server
)
;
return
true
;
}
void
addStunServer
(
const
NrIceStunServer
&
server
)
{
mStunServers
.
push_back
(
server
)
;
}
void
addTurnServer
(
const
NrIceTurnServer
&
server
)
{
mTurnServers
.
push_back
(
server
)
;
}
const
std
:
:
vector
<
NrIceStunServer
>
&
getStunServers
(
)
const
{
return
mStunServers
;
}
const
std
:
:
vector
<
NrIceTurnServer
>
&
getTurnServers
(
)
const
{
return
mTurnServers
;
}
void
setBundlePolicy
(
JsepBundlePolicy
policy
)
{
mBundlePolicy
=
policy
;
}
JsepBundlePolicy
getBundlePolicy
(
)
const
{
return
mBundlePolicy
;
}
void
setIceTransportPolicy
(
NrIceCtx
:
:
Policy
policy
)
{
mIceTransportPolicy
=
policy
;
}
NrIceCtx
:
:
Policy
getIceTransportPolicy
(
)
const
{
return
mIceTransportPolicy
;
}
#
ifndef
MOZILLA_EXTERNAL_LINKAGE
nsresult
Init
(
const
RTCConfiguration
&
aSrc
)
;
nsresult
AddIceServer
(
const
RTCIceServer
&
aServer
)
;
#
endif
private
:
std
:
:
vector
<
NrIceStunServer
>
mStunServers
;
std
:
:
vector
<
NrIceTurnServer
>
mTurnServers
;
JsepBundlePolicy
mBundlePolicy
;
NrIceCtx
:
:
Policy
mIceTransportPolicy
;
}
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
class
RTCStatsQuery
{
public
:
explicit
RTCStatsQuery
(
bool
internalStats
)
;
~
RTCStatsQuery
(
)
;
nsAutoPtr
<
mozilla
:
:
dom
:
:
RTCStatsReportInternal
>
report
;
std
:
:
string
error
;
mozilla
:
:
TimeStamp
iceStartTime
;
bool
isHello
;
bool
failed
;
private
:
friend
class
PeerConnectionImpl
;
std
:
:
string
pcName
;
bool
internalStats
;
nsTArray
<
RefPtr
<
mozilla
:
:
MediaPipeline
>
>
pipelines
;
RefPtr
<
NrIceCtx
>
iceCtx
;
bool
grabAllLevels
;
DOMHighResTimeStamp
now
;
}
;
#
endif
#
define
PC_AUTO_ENTER_API_CALL
(
assert_ice_ready
)
\
do
{
\
/
*
do
/
while
prevents
res
from
conflicting
with
locals
*
/
\
nsresult
res
=
CheckApiState
(
assert_ice_ready
)
;
\
if
(
NS_FAILED
(
res
)
)
return
res
;
\
}
while
(
0
)
#
define
PC_AUTO_ENTER_API_CALL_VOID_RETURN
(
assert_ice_ready
)
\
do
{
\
/
*
do
/
while
prevents
res
from
conflicting
with
locals
*
/
\
nsresult
res
=
CheckApiState
(
assert_ice_ready
)
;
\
if
(
NS_FAILED
(
res
)
)
return
;
\
}
while
(
0
)
#
define
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
CheckThread
(
)
class
PeerConnectionImpl
final
:
public
nsISupports
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
public
mozilla
:
:
DataChannelConnection
:
:
DataConnectionListener
public
dom
:
:
PrincipalChangeObserver
<
DOMMediaStream
>
#
endif
public
sigslot
:
:
has_slots
<
>
{
struct
Internal
;
public
:
explicit
PeerConnectionImpl
(
const
mozilla
:
:
dom
:
:
GlobalObject
*
aGlobal
=
nullptr
)
;
enum
Error
{
kNoError
=
0
kInvalidCandidate
=
2
kInvalidMediastreamTrack
=
3
kInvalidState
=
4
kInvalidSessionDescription
=
5
kIncompatibleSessionDescription
=
6
kIncompatibleMediaStreamTrack
=
8
kInternalError
=
9
}
;
NS_DECL_THREADSAFE_ISUPPORTS
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
;
#
endif
static
already_AddRefed
<
PeerConnectionImpl
>
Constructor
(
const
mozilla
:
:
dom
:
:
GlobalObject
&
aGlobal
ErrorResult
&
rv
)
;
static
PeerConnectionImpl
*
CreatePeerConnection
(
)
;
already_AddRefed
<
DOMMediaStream
>
MakeMediaStream
(
)
;
nsresult
CreateRemoteSourceStreamInfo
(
RefPtr
<
RemoteSourceStreamInfo
>
*
aInfo
const
std
:
:
string
&
aId
)
;
void
NotifyDataChannel
(
already_AddRefed
<
mozilla
:
:
DataChannel
>
aChannel
)
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
override
#
endif
;
const
RefPtr
<
PeerConnectionMedia
>
&
media
(
)
const
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mMedia
;
}
void
SetAllowIceLoopback
(
bool
val
)
{
mAllowIceLoopback
=
val
;
}
bool
GetAllowIceLoopback
(
)
const
{
return
mAllowIceLoopback
;
}
void
SetAllowIceLinkLocal
(
bool
val
)
{
mAllowIceLinkLocal
=
val
;
}
bool
GetAllowIceLinkLocal
(
)
const
{
return
mAllowIceLinkLocal
;
}
virtual
const
std
:
:
string
&
GetHandle
(
)
;
virtual
const
std
:
:
string
&
GetName
(
)
;
void
IceConnectionStateChange
(
NrIceCtx
*
ctx
NrIceCtx
:
:
ConnectionState
state
)
;
void
IceGatheringStateChange
(
NrIceCtx
*
ctx
NrIceCtx
:
:
GatheringState
state
)
;
void
UpdateDefaultCandidate
(
const
std
:
:
string
&
defaultAddr
uint16_t
defaultPort
const
std
:
:
string
&
defaultRtcpAddr
uint16_t
defaultRtcpPort
uint16_t
level
)
;
void
EndOfLocalCandidates
(
uint16_t
level
)
;
void
IceStreamReady
(
NrIceMediaStream
*
aStream
)
;
static
void
ListenThread
(
void
*
aData
)
;
static
void
ConnectThread
(
void
*
aData
)
;
nsCOMPtr
<
nsIThread
>
GetMainThread
(
)
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mThread
;
}
nsCOMPtr
<
nsIEventTarget
>
GetSTSThread
(
)
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mSTSThread
;
}
nsPIDOMWindowInner
*
GetWindow
(
)
const
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mWindow
;
}
nsresult
Initialize
(
PeerConnectionObserver
&
aObserver
nsGlobalWindow
*
aWindow
const
PeerConnectionConfiguration
&
aConfiguration
nsISupports
*
aThread
)
;
#
ifndef
MOZILLA_EXTERNAL_LINKAGE
void
Initialize
(
PeerConnectionObserver
&
aObserver
nsGlobalWindow
&
aWindow
const
RTCConfiguration
&
aConfiguration
nsISupports
*
aThread
ErrorResult
&
rv
)
;
#
endif
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
void
SetCertificate
(
mozilla
:
:
dom
:
:
RTCCertificate
&
aCertificate
)
;
const
RefPtr
<
mozilla
:
:
dom
:
:
RTCCertificate
>
&
Certificate
(
)
const
;
#
endif
RefPtr
<
DtlsIdentity
>
Identity
(
)
const
;
NS_IMETHODIMP_TO_ERRORRESULT
(
CreateOffer
ErrorResult
&
rv
const
RTCOfferOptions
&
aOptions
)
{
rv
=
CreateOffer
(
aOptions
)
;
}
NS_IMETHODIMP
CreateAnswer
(
)
;
void
CreateAnswer
(
ErrorResult
&
rv
)
{
rv
=
CreateAnswer
(
)
;
}
NS_IMETHODIMP
CreateOffer
(
const
mozilla
:
:
JsepOfferOptions
&
aConstraints
)
;
NS_IMETHODIMP
SetLocalDescription
(
int32_t
aAction
const
char
*
aSDP
)
;
void
SetLocalDescription
(
int32_t
aAction
const
nsAString
&
aSDP
ErrorResult
&
rv
)
{
rv
=
SetLocalDescription
(
aAction
NS_ConvertUTF16toUTF8
(
aSDP
)
.
get
(
)
)
;
}
nsresult
CreateNewRemoteTracks
(
RefPtr
<
PeerConnectionObserver
>
&
aPco
)
;
void
RemoveOldRemoteTracks
(
RefPtr
<
PeerConnectionObserver
>
&
aPco
)
;
NS_IMETHODIMP
SetRemoteDescription
(
int32_t
aAction
const
char
*
aSDP
)
;
void
SetRemoteDescription
(
int32_t
aAction
const
nsAString
&
aSDP
ErrorResult
&
rv
)
{
rv
=
SetRemoteDescription
(
aAction
NS_ConvertUTF16toUTF8
(
aSDP
)
.
get
(
)
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetStats
ErrorResult
&
rv
mozilla
:
:
dom
:
:
MediaStreamTrack
*
aSelector
)
{
rv
=
GetStats
(
aSelector
)
;
}
NS_IMETHODIMP
AddIceCandidate
(
const
char
*
aCandidate
const
char
*
aMid
unsigned
short
aLevel
)
;
void
AddIceCandidate
(
const
nsAString
&
aCandidate
const
nsAString
&
aMid
unsigned
short
aLevel
ErrorResult
&
rv
)
{
rv
=
AddIceCandidate
(
NS_ConvertUTF16toUTF8
(
aCandidate
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aMid
)
.
get
(
)
aLevel
)
;
}
NS_IMETHODIMP
CloseStreams
(
)
;
void
CloseStreams
(
ErrorResult
&
rv
)
{
rv
=
CloseStreams
(
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
AddTrack
ErrorResult
&
rv
mozilla
:
:
dom
:
:
MediaStreamTrack
&
aTrack
const
mozilla
:
:
dom
:
:
Sequence
<
mozilla
:
:
OwningNonNull
<
DOMMediaStream
>
>
&
aStreams
)
{
rv
=
AddTrack
(
aTrack
aStreams
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
RemoveTrack
ErrorResult
&
rv
mozilla
:
:
dom
:
:
MediaStreamTrack
&
aTrack
)
{
rv
=
RemoveTrack
(
aTrack
)
;
}
nsresult
AddTrack
(
mozilla
:
:
dom
:
:
MediaStreamTrack
&
aTrack
DOMMediaStream
&
aStream
)
;
NS_IMETHODIMP_TO_ERRORRESULT
(
ReplaceTrack
ErrorResult
&
rv
mozilla
:
:
dom
:
:
MediaStreamTrack
&
aThisTrack
mozilla
:
:
dom
:
:
MediaStreamTrack
&
aWithTrack
)
{
rv
=
ReplaceTrack
(
aThisTrack
aWithTrack
)
;
}
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
NS_IMETHODIMP_TO_ERRORRESULT
(
SetParameters
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aTrack
const
dom
:
:
RTCRtpParameters
&
aParameters
)
{
rv
=
SetParameters
(
aTrack
aParameters
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetParameters
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aTrack
dom
:
:
RTCRtpParameters
&
aOutParameters
)
{
rv
=
GetParameters
(
aTrack
aOutParameters
)
;
}
#
endif
nsresult
SetParameters
(
dom
:
:
MediaStreamTrack
&
aTrack
const
std
:
:
vector
<
JsepTrack
:
:
JsConstraints
>
&
aConstraints
)
;
nsresult
GetParameters
(
dom
:
:
MediaStreamTrack
&
aTrack
std
:
:
vector
<
JsepTrack
:
:
JsConstraints
>
*
aOutConstraints
)
;
NS_IMETHODIMP_TO_ERRORRESULT
(
SelectSsrc
ErrorResult
&
rv
dom
:
:
MediaStreamTrack
&
aRecvTrack
unsigned
short
aSsrcIndex
)
{
rv
=
SelectSsrc
(
aRecvTrack
aSsrcIndex
)
;
}
nsresult
GetPeerIdentity
(
nsAString
&
peerIdentity
)
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
if
(
mPeerIdentity
)
{
peerIdentity
=
mPeerIdentity
-
>
ToString
(
)
;
return
NS_OK
;
}
#
endif
peerIdentity
.
SetIsVoid
(
true
)
;
return
NS_OK
;
}
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
const
PeerIdentity
*
GetPeerIdentity
(
)
const
{
return
mPeerIdentity
;
}
nsresult
SetPeerIdentity
(
const
nsAString
&
peerIdentity
)
;
const
std
:
:
string
&
GetIdAsAscii
(
)
const
{
return
mName
;
}
nsresult
GetId
(
nsAString
&
id
)
{
id
=
NS_ConvertASCIItoUTF16
(
mName
.
c_str
(
)
)
;
return
NS_OK
;
}
nsresult
SetId
(
const
nsAString
&
id
)
{
mName
=
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
;
return
NS_OK
;
}
#
endif
bool
IsLoop
(
)
const
{
return
mIsLoop
;
}
bool
PrivacyRequested
(
)
const
{
return
mPrivacyRequested
;
}
NS_IMETHODIMP
GetFingerprint
(
char
*
*
fingerprint
)
;
void
GetFingerprint
(
nsAString
&
fingerprint
)
{
char
*
tmp
;
GetFingerprint
(
&
tmp
)
;
fingerprint
.
AssignASCII
(
tmp
)
;
delete
[
]
tmp
;
}
NS_IMETHODIMP
GetLocalDescription
(
char
*
*
aSDP
)
;
void
GetLocalDescription
(
nsAString
&
aSDP
)
{
char
*
tmp
;
GetLocalDescription
(
&
tmp
)
;
aSDP
.
AssignASCII
(
tmp
)
;
delete
[
]
tmp
;
}
NS_IMETHODIMP
GetRemoteDescription
(
char
*
*
aSDP
)
;
void
GetRemoteDescription
(
nsAString
&
aSDP
)
{
char
*
tmp
;
GetRemoteDescription
(
&
tmp
)
;
aSDP
.
AssignASCII
(
tmp
)
;
delete
[
]
tmp
;
}
NS_IMETHODIMP
SignalingState
(
mozilla
:
:
dom
:
:
PCImplSignalingState
*
aState
)
;
mozilla
:
:
dom
:
:
PCImplSignalingState
SignalingState
(
)
{
mozilla
:
:
dom
:
:
PCImplSignalingState
state
;
SignalingState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
IceConnectionState
(
mozilla
:
:
dom
:
:
PCImplIceConnectionState
*
aState
)
;
mozilla
:
:
dom
:
:
PCImplIceConnectionState
IceConnectionState
(
)
{
mozilla
:
:
dom
:
:
PCImplIceConnectionState
state
;
IceConnectionState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
IceGatheringState
(
mozilla
:
:
dom
:
:
PCImplIceGatheringState
*
aState
)
;
mozilla
:
:
dom
:
:
PCImplIceGatheringState
IceGatheringState
(
)
{
mozilla
:
:
dom
:
:
PCImplIceGatheringState
state
;
IceGatheringState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
Close
(
)
;
void
Close
(
ErrorResult
&
rv
)
{
rv
=
Close
(
)
;
}
bool
PluginCrash
(
uint32_t
aPluginID
const
nsAString
&
aPluginName
)
;
void
RecordEndOfCallTelemetry
(
)
const
;
nsresult
InitializeDataChannel
(
)
;
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
(
nsDOMDataChannel
CreateDataChannel
ErrorResult
&
rv
const
nsAString
&
aLabel
const
nsAString
&
aProtocol
uint16_t
aType
bool
outOfOrderAllowed
uint16_t
aMaxTime
uint16_t
aMaxNum
bool
aExternalNegotiated
uint16_t
aStream
)
;
NS_IMETHODIMP_TO_ERRORRESULT
(
GetLocalStreams
ErrorResult
&
rv
nsTArray
<
RefPtr
<
DOMMediaStream
>
>
&
result
)
{
rv
=
GetLocalStreams
(
result
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
GetRemoteStreams
ErrorResult
&
rv
nsTArray
<
RefPtr
<
DOMMediaStream
>
>
&
result
)
{
rv
=
GetRemoteStreams
(
result
)
;
}
void
OnSdpParseError
(
const
char
*
errorMessage
)
;
void
ClearSdpParseErrorMessages
(
)
;
const
std
:
:
vector
<
std
:
:
string
>
&
GetSdpParseErrors
(
)
;
void
SetSignalingState_m
(
mozilla
:
:
dom
:
:
PCImplSignalingState
aSignalingState
bool
rollback
=
false
)
;
void
UpdateSignalingState
(
bool
rollback
=
false
)
;
bool
IsClosed
(
)
const
;
nsresult
SetDtlsConnected
(
bool
aPrivacyRequested
)
;
bool
HasMedia
(
)
const
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
void
startCallTelem
(
)
;
nsresult
BuildStatsQuery_m
(
mozilla
:
:
dom
:
:
MediaStreamTrack
*
aSelector
RTCStatsQuery
*
query
)
;
static
nsresult
ExecuteStatsQuery_s
(
RTCStatsQuery
*
query
)
;
virtual
void
PrincipalChanged
(
DOMMediaStream
*
aMediaStream
)
override
;
nsresult
GetRemoteTrackId
(
const
std
:
:
string
streamId
const
dom
:
:
MediaStreamTrack
&
track
std
:
:
string
*
trackId
)
const
;
#
endif
static
std
:
:
string
GetStreamId
(
const
DOMMediaStream
&
aStream
)
;
static
std
:
:
string
GetTrackId
(
const
dom
:
:
MediaStreamTrack
&
track
)
;
void
OnMediaError
(
const
std
:
:
string
&
aError
)
;
private
:
virtual
~
PeerConnectionImpl
(
)
;
PeerConnectionImpl
(
const
PeerConnectionImpl
&
rhs
)
;
PeerConnectionImpl
&
operator
=
(
PeerConnectionImpl
)
;
nsresult
CalculateFingerprint
(
const
std
:
:
string
&
algorithm
std
:
:
vector
<
uint8_t
>
*
fingerprint
)
const
;
nsresult
ConfigureJsepSessionCodecs
(
)
;
NS_IMETHODIMP
EnsureDataConnection
(
uint16_t
aNumstreams
)
;
nsresult
CloseInt
(
)
;
nsresult
CheckApiState
(
bool
assert_ice_ready
)
const
;
void
CheckThread
(
)
const
{
MOZ_ASSERT
(
CheckThreadInt
(
)
"
Wrong
thread
"
)
;
}
bool
CheckThreadInt
(
)
const
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
bool
on
;
NS_ENSURE_SUCCESS
(
mThread
-
>
IsOnCurrentThread
(
&
on
)
false
)
;
NS_ENSURE_TRUE
(
on
false
)
;
#
endif
return
true
;
}
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
nsresult
GetTimeSinceEpoch
(
DOMHighResTimeStamp
*
result
)
;
#
endif
void
ShutdownMedia
(
)
;
void
CandidateReady
(
const
std
:
:
string
&
candidate
uint16_t
level
)
;
void
SendLocalIceCandidateToContent
(
uint16_t
level
const
std
:
:
string
&
mid
const
std
:
:
string
&
candidate
)
;
nsresult
GetDatachannelParameters
(
const
mozilla
:
:
JsepApplicationCodecDescription
*
*
codec
uint16_t
*
level
)
const
;
static
void
DeferredAddTrackToJsepSession
(
const
std
:
:
string
&
pcHandle
SdpMediaSection
:
:
MediaType
type
const
std
:
:
string
&
streamId
const
std
:
:
string
&
trackId
)
;
nsresult
AddTrackToJsepSession
(
SdpMediaSection
:
:
MediaType
type
const
std
:
:
string
&
streamId
const
std
:
:
string
&
trackId
)
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
static
void
GetStatsForPCObserver_s
(
const
std
:
:
string
&
pcHandle
nsAutoPtr
<
RTCStatsQuery
>
query
)
;
static
void
DeliverStatsReportToPCObserver_m
(
const
std
:
:
string
&
pcHandle
nsresult
result
nsAutoPtr
<
RTCStatsQuery
>
query
)
;
#
endif
void
RecordLongtermICEStatistics
(
)
;
void
OnNegotiationNeeded
(
)
;
static
void
MaybeFireNegotiationNeeded_static
(
const
std
:
:
string
&
pcHandle
)
;
void
MaybeFireNegotiationNeeded
(
)
;
Timecard
*
mTimeCard
;
mozilla
:
:
dom
:
:
PCImplSignalingState
mSignalingState
;
mozilla
:
:
dom
:
:
PCImplIceConnectionState
mIceConnectionState
;
mozilla
:
:
dom
:
:
PCImplIceGatheringState
mIceGatheringState
;
bool
mDtlsConnected
;
nsCOMPtr
<
nsIThread
>
mThread
;
nsWeakPtr
mPCObserver
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
std
:
:
string
mLocalRequestedSDP
;
std
:
:
string
mRemoteRequestedSDP
;
std
:
:
string
mFingerprint
;
std
:
:
string
mRemoteFingerprint
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
RefPtr
<
PeerIdentity
>
mPeerIdentity
;
RefPtr
<
mozilla
:
:
dom
:
:
RTCCertificate
>
mCertificate
;
#
else
RefPtr
<
DtlsIdentity
>
mIdentity
;
#
endif
bool
mPrivacyRequested
;
std
:
:
string
mHandle
;
std
:
:
string
mName
;
bool
mIsLoop
;
nsCOMPtr
<
nsIEventTarget
>
mSTSThread
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
RefPtr
<
mozilla
:
:
DataChannelConnection
>
mDataConnection
;
#
endif
bool
mAllowIceLoopback
;
bool
mAllowIceLinkLocal
;
RefPtr
<
PeerConnectionMedia
>
mMedia
;
mozilla
:
:
UniquePtr
<
PCUuidGenerator
>
mUuidGen
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
JsepSession
>
mJsepSession
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
mozilla
:
:
TimeStamp
mIceStartTime
;
mozilla
:
:
TimeStamp
mStartTime
;
#
endif
int
mNumAudioStreams
;
int
mNumVideoStreams
;
bool
mHaveConfiguredCodecs
;
bool
mHaveDataStream
;
unsigned
int
mAddCandidateErrorCount
;
bool
mTrickle
;
bool
mNegotiationNeeded
;
bool
mPrivateWindow
;
uint16_t
mMaxReceiving
[
SdpMediaSection
:
:
kMediaTypes
]
;
uint16_t
mMaxSending
[
SdpMediaSection
:
:
kMediaTypes
]
;
public
:
unsigned
short
listenPort
;
unsigned
short
connectPort
;
char
*
connectStr
;
}
;
class
PeerConnectionWrapper
{
public
:
explicit
PeerConnectionWrapper
(
const
std
:
:
string
&
handle
)
;
PeerConnectionImpl
*
impl
(
)
{
return
impl_
;
}
private
:
RefPtr
<
PeerConnectionImpl
>
impl_
;
}
;
}
#
undef
NS_IMETHODIMP_TO_ERRORRESULT
#
undef
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
#
endif
