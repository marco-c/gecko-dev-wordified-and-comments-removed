#
include
"
TransceiverImpl
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
string
>
#
include
<
vector
>
#
include
"
AudioConduit
.
h
"
#
include
"
VideoConduit
.
h
"
#
include
"
MediaTrackGraph
.
h
"
#
include
"
MediaPipeline
.
h
"
#
include
"
MediaPipelineFilter
.
h
"
#
include
"
signaling
/
src
/
jsep
/
JsepTrack
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
logging
.
h
"
#
include
"
MediaEngine
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
RemoteTrackSource
.
h
"
#
include
"
MediaConduitInterface
.
h
"
#
include
"
MediaTransportHandler
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpReceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpSenderBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpTransceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
TransceiverImplBinding
.
h
"
#
include
"
RTCRtpReceiver
.
h
"
#
include
"
RTCDTMFSender
.
h
"
#
include
"
WebrtcGmpVideoCodec
.
h
"
namespace
mozilla
{
using
namespace
dom
;
MOZ_MTLOG_MODULE
(
"
transceiverimpl
"
)
using
LocalDirection
=
MediaSessionConduitLocalDirection
;
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
TransceiverImpl
mWindow
mSendTrack
mReceiver
mDtmf
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TransceiverImpl
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TransceiverImpl
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TransceiverImpl
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
TransceiverImpl
:
:
TransceiverImpl
(
nsPIDOMWindowInner
*
aWindow
bool
aPrivacyNeeded
const
std
:
:
string
&
aPCHandle
MediaTransportHandler
*
aTransportHandler
JsepTransceiver
*
aJsepTransceiver
nsISerialEventTarget
*
aMainThread
nsISerialEventTarget
*
aStsThread
dom
:
:
MediaStreamTrack
*
aSendTrack
WebRtcCallWrapper
*
aCallWrapper
)
:
mWindow
(
aWindow
)
mPCHandle
(
aPCHandle
)
mTransportHandler
(
aTransportHandler
)
mJsepTransceiver
(
aJsepTransceiver
)
mHaveSetupTransport
(
false
)
mMainThread
(
aMainThread
)
mStsThread
(
aStsThread
)
mSendTrack
(
aSendTrack
)
mCallWrapper
(
aCallWrapper
)
{
if
(
IsVideo
(
)
)
{
InitVideo
(
)
;
}
else
{
InitAudio
(
)
;
}
if
(
!
IsValid
(
)
)
{
return
;
}
mConduit
-
>
SetPCHandle
(
mPCHandle
)
;
mReceiver
=
new
RTCRtpReceiver
(
aWindow
aPrivacyNeeded
aPCHandle
aTransportHandler
aJsepTransceiver
aMainThread
aStsThread
mConduit
)
;
if
(
!
IsVideo
(
)
)
{
mDtmf
=
new
RTCDTMFSender
(
aWindow
this
static_cast
<
AudioSessionConduit
*
>
(
mConduit
.
get
(
)
)
)
;
}
mTransmitPipeline
=
new
MediaPipelineTransmit
(
mPCHandle
mTransportHandler
mMainThread
.
get
(
)
mStsThread
.
get
(
)
IsVideo
(
)
mConduit
)
;
mTransmitPipeline
-
>
SetTrack
(
mSendTrack
)
;
}
TransceiverImpl
:
:
~
TransceiverImpl
(
)
=
default
;
void
TransceiverImpl
:
:
InitAudio
(
)
{
mConduit
=
AudioSessionConduit
:
:
Create
(
mCallWrapper
mStsThread
)
;
if
(
!
mConduit
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
:
Failed
to
create
AudioSessionConduit
"
)
;
}
}
void
TransceiverImpl
:
:
InitVideo
(
)
{
mConduit
=
VideoSessionConduit
:
:
Create
(
mCallWrapper
mStsThread
)
;
if
(
!
mConduit
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
:
Failed
to
create
VideoSessionConduit
"
)
;
}
}
nsresult
TransceiverImpl
:
:
UpdateSinkIdentity
(
const
dom
:
:
MediaStreamTrack
*
aTrack
nsIPrincipal
*
aPrincipal
const
PeerIdentity
*
aSinkIdentity
)
{
if
(
mJsepTransceiver
-
>
IsStopped
(
)
)
{
return
NS_OK
;
}
mTransmitPipeline
-
>
UpdateSinkIdentity_m
(
aTrack
aPrincipal
aSinkIdentity
)
;
return
NS_OK
;
}
void
TransceiverImpl
:
:
Shutdown_m
(
)
{
Stop
(
)
;
mTransmitPipeline
=
nullptr
;
mTransportHandler
=
nullptr
;
}
nsresult
TransceiverImpl
:
:
UpdateSendTrack
(
dom
:
:
MediaStreamTrack
*
aSendTrack
)
{
if
(
mJsepTransceiver
-
>
IsStopped
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_MTLOG
(
ML_DEBUG
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
(
"
<
<
aSendTrack
<
<
"
)
"
)
;
mSendTrack
=
aSendTrack
;
return
mTransmitPipeline
-
>
SetTrack
(
mSendTrack
)
;
}
nsresult
TransceiverImpl
:
:
UpdateTransport
(
)
{
if
(
!
mJsepTransceiver
-
>
HasLevel
(
)
|
|
mJsepTransceiver
-
>
IsStopped
(
)
)
{
return
NS_OK
;
}
mReceiver
-
>
UpdateTransport
(
)
;
if
(
!
mHaveSetupTransport
)
{
mTransmitPipeline
-
>
SetLevel
(
mJsepTransceiver
-
>
GetLevel
(
)
)
;
mHaveSetupTransport
=
true
;
}
mTransmitPipeline
-
>
UpdateTransport_m
(
mJsepTransceiver
-
>
mTransport
.
mTransportId
nullptr
)
;
return
NS_OK
;
}
nsresult
TransceiverImpl
:
:
UpdateConduit
(
)
{
if
(
mJsepTransceiver
-
>
IsStopped
(
)
)
{
return
NS_OK
;
}
if
(
mJsepTransceiver
-
>
IsAssociated
(
)
)
{
mMid
=
mJsepTransceiver
-
>
GetMid
(
)
;
}
else
{
mMid
.
clear
(
)
;
}
mReceiver
-
>
Stop
(
)
;
mTransmitPipeline
-
>
Stop
(
)
;
if
(
mJsepTransceiver
-
>
mSendTrack
.
GetSsrcs
(
)
.
empty
(
)
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
No
local
SSRC
set
!
(
Should
be
set
regardless
of
"
"
whether
we
'
re
sending
RTP
;
we
need
a
local
SSRC
in
"
"
all
cases
)
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mConduit
-
>
SetLocalSSRCs
(
mJsepTransceiver
-
>
mSendTrack
.
GetSsrcs
(
)
)
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
SetLocalSSRCs
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
mConduit
-
>
SetLocalCNAME
(
mJsepTransceiver
-
>
mSendTrack
.
GetCNAME
(
)
.
c_str
(
)
)
;
mConduit
-
>
SetLocalMID
(
mMid
)
;
nsresult
rv
;
mReceiver
-
>
UpdateConduit
(
)
;
if
(
IsVideo
(
)
)
{
rv
=
UpdateVideoConduit
(
)
;
}
else
{
rv
=
UpdateAudioConduit
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mJsepTransceiver
-
>
mRecvTrack
.
GetActive
(
)
)
{
mReceiver
-
>
Start
(
)
;
}
if
(
mJsepTransceiver
-
>
mSendTrack
.
GetActive
(
)
)
{
if
(
!
mSendTrack
)
{
MOZ_MTLOG
(
ML_WARNING
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Starting
transmit
conduit
without
send
track
!
"
)
;
}
mTransmitPipeline
-
>
Start
(
)
;
}
return
NS_OK
;
}
void
TransceiverImpl
:
:
ResetSync
(
)
{
if
(
mConduit
)
{
mConduit
-
>
SetSyncGroup
(
"
"
)
;
}
}
nsresult
TransceiverImpl
:
:
SyncWithMatchingVideoConduits
(
std
:
:
vector
<
RefPtr
<
TransceiverImpl
>
>
&
transceivers
)
{
if
(
mJsepTransceiver
-
>
IsStopped
(
)
)
{
return
NS_OK
;
}
if
(
IsVideo
(
)
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
called
when
transceiver
is
not
"
"
video
!
This
should
never
happen
.
"
)
;
MOZ_CRASH
(
)
;
return
NS_ERROR_UNEXPECTED
;
}
std
:
:
set
<
std
:
:
string
>
myReceiveStreamIds
;
myReceiveStreamIds
.
insert
(
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
.
begin
(
)
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
.
end
(
)
)
;
for
(
RefPtr
<
TransceiverImpl
>
&
transceiver
:
transceivers
)
{
if
(
!
transceiver
-
>
IsValid
(
)
)
{
continue
;
}
if
(
!
transceiver
-
>
IsVideo
(
)
)
{
continue
;
}
for
(
const
std
:
:
string
&
streamId
:
transceiver
-
>
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
)
{
if
(
myReceiveStreamIds
.
count
(
streamId
)
)
{
mConduit
-
>
SetSyncGroup
(
streamId
)
;
transceiver
-
>
mConduit
-
>
SetSyncGroup
(
streamId
)
;
MOZ_MTLOG
(
ML_DEBUG
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Syncing
"
<
<
mConduit
.
get
(
)
<
<
"
to
"
<
<
transceiver
-
>
mConduit
.
get
(
)
)
;
break
;
}
}
}
return
NS_OK
;
}
bool
TransceiverImpl
:
:
ConduitHasPluginID
(
uint64_t
aPluginID
)
{
return
mConduit
?
mConduit
-
>
CodecPluginID
(
)
=
=
aPluginID
:
false
;
}
bool
TransceiverImpl
:
:
HasSendTrack
(
const
dom
:
:
MediaStreamTrack
*
aSendTrack
)
const
{
if
(
!
mSendTrack
)
{
return
false
;
}
if
(
!
aSendTrack
)
{
return
true
;
}
return
mSendTrack
.
get
(
)
=
=
aSendTrack
;
}
void
TransceiverImpl
:
:
SyncWithJS
(
dom
:
:
RTCRtpTransceiver
&
aJsTransceiver
ErrorResult
&
aRv
)
{
MOZ_MTLOG
(
ML_DEBUG
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Syncing
with
JS
transceiver
"
)
;
if
(
!
mTransmitPipeline
)
{
return
;
}
if
(
mJsepTransceiver
-
>
IsStopped
(
)
)
{
aJsTransceiver
.
SetStopped
(
aRv
)
;
Stop
(
)
;
}
else
if
(
aJsTransceiver
.
GetStopped
(
aRv
)
)
{
mJsepTransceiver
-
>
Stop
(
)
;
Stop
(
)
;
}
if
(
aRv
.
Failed
(
)
)
{
return
;
}
dom
:
:
RTCRtpTransceiverDirection
direction
=
aJsTransceiver
.
GetDirection
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
switch
(
direction
)
{
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendrecv
:
mJsepTransceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
;
break
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendonly
:
mJsepTransceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
Direction
:
:
kSendonly
;
break
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Recvonly
:
mJsepTransceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
Direction
:
:
kRecvonly
;
break
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Inactive
:
mJsepTransceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
Direction
:
:
kInactive
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
aRv
=
NS_ERROR_INVALID_ARG
;
return
;
}
RefPtr
<
dom
:
:
RTCRtpSender
>
sender
=
aJsTransceiver
.
GetSender
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
nsTArray
<
RefPtr
<
DOMMediaStream
>
>
streams
;
sender
-
>
GetStreams
(
streams
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
std
:
:
vector
<
std
:
:
string
>
streamIds
;
for
(
const
auto
&
stream
:
streams
)
{
nsString
wideStreamId
;
stream
-
>
GetId
(
wideStreamId
)
;
std
:
:
string
streamId
=
NS_ConvertUTF16toUTF8
(
wideStreamId
)
.
get
(
)
;
MOZ_ASSERT
(
!
streamId
.
empty
(
)
)
;
streamIds
.
push_back
(
streamId
)
;
}
mJsepTransceiver
-
>
mSendTrack
.
UpdateStreamIds
(
streamIds
)
;
dom
:
:
RTCRtpParameters
parameters
;
sender
-
>
GetParameters
(
parameters
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
std
:
:
vector
<
JsepTrack
:
:
JsConstraints
>
constraints
;
if
(
parameters
.
mEncodings
.
WasPassed
(
)
)
{
for
(
auto
&
encoding
:
parameters
.
mEncodings
.
Value
(
)
)
{
JsepTrack
:
:
JsConstraints
constraint
;
if
(
encoding
.
mRid
.
WasPassed
(
)
)
{
constraint
.
rid
=
NS_ConvertUTF16toUTF8
(
encoding
.
mRid
.
Value
(
)
)
.
get
(
)
;
}
if
(
encoding
.
mMaxBitrate
.
WasPassed
(
)
)
{
constraint
.
constraints
.
maxBr
=
encoding
.
mMaxBitrate
.
Value
(
)
;
}
constraint
.
constraints
.
scaleDownBy
=
encoding
.
mScaleResolutionDownBy
;
constraints
.
push_back
(
constraint
)
;
}
}
if
(
mJsepTransceiver
-
>
mSendTrack
.
SetJsConstraints
(
constraints
)
)
{
if
(
mTransmitPipeline
-
>
Transmitting
(
)
)
{
WebrtcGmpPCHandleSetter
setter
(
mPCHandle
)
;
DebugOnly
<
nsresult
>
rv
=
UpdateConduit
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
if
(
!
mJsepTransceiver
-
>
mRecvTrack
.
GetRemoteSetSendBit
(
)
|
|
!
mJsepTransceiver
-
>
mRecvTrack
.
GetActive
(
)
)
{
mReceiver
-
>
Stop
(
)
;
}
if
(
mJsepTransceiver
-
>
IsAssociated
(
)
)
{
aJsTransceiver
.
SetMid
(
NS_ConvertUTF8toUTF16
(
mJsepTransceiver
-
>
GetMid
(
)
.
c_str
(
)
)
aRv
)
;
}
else
{
aJsTransceiver
.
UnsetMid
(
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
mJsepTransceiver
-
>
HasLevel
(
)
&
&
mJsepTransceiver
-
>
IsNegotiated
(
)
)
{
if
(
IsReceiving
(
)
)
{
if
(
IsSending
(
)
)
{
aJsTransceiver
.
SetCurrentDirection
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendrecv
aRv
)
;
}
else
{
aJsTransceiver
.
SetCurrentDirection
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Recvonly
aRv
)
;
}
}
else
{
if
(
IsSending
(
)
)
{
aJsTransceiver
.
SetCurrentDirection
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendonly
aRv
)
;
}
else
{
aJsTransceiver
.
SetCurrentDirection
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Inactive
aRv
)
;
}
}
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
aJsTransceiver
.
GetAddTrackMagic
(
aRv
)
)
{
mJsepTransceiver
-
>
SetAddTrackMagic
(
)
;
}
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
mJsepTransceiver
-
>
IsRemoved
(
)
)
{
aJsTransceiver
.
SetShouldRemove
(
true
aRv
)
;
}
}
bool
TransceiverImpl
:
:
CanSendDTMF
(
)
const
{
if
(
!
IsSending
(
)
|
|
!
mSendTrack
)
{
return
false
;
}
JsepTrackNegotiatedDetails
*
details
=
mJsepTransceiver
-
>
mSendTrack
.
GetNegotiatedDetails
(
)
;
if
(
NS_WARN_IF
(
!
details
|
|
!
details
-
>
GetEncodingCount
(
)
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
details
-
>
GetEncodingCount
(
)
;
+
+
i
)
{
const
auto
&
encoding
=
details
-
>
GetEncoding
(
i
)
;
for
(
const
auto
&
codec
:
encoding
.
GetCodecs
(
)
)
{
if
(
codec
-
>
mName
=
=
"
telephone
-
event
"
)
{
return
true
;
}
}
}
return
false
;
}
JSObject
*
TransceiverImpl
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
TransceiverImpl_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsPIDOMWindowInner
*
TransceiverImpl
:
:
GetParentObject
(
)
const
{
return
mWindow
;
}
RefPtr
<
MediaPipelineTransmit
>
TransceiverImpl
:
:
GetSendPipeline
(
)
{
return
mTransmitPipeline
;
}
static
nsresult
JsepCodecDescToAudioCodecConfig
(
const
JsepCodecDescription
&
aCodec
UniquePtr
<
AudioCodecConfig
>
*
aConfig
)
{
MOZ_ASSERT
(
aCodec
.
mType
=
=
SdpMediaSection
:
:
kAudio
)
;
if
(
aCodec
.
mType
!
=
SdpMediaSection
:
:
kAudio
)
return
NS_ERROR_INVALID_ARG
;
const
JsepAudioCodecDescription
&
desc
=
static_cast
<
const
JsepAudioCodecDescription
&
>
(
aCodec
)
;
uint16_t
pt
;
if
(
!
desc
.
GetPtAsInt
(
&
pt
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Invalid
payload
type
:
"
<
<
desc
.
mDefaultPt
)
;
return
NS_ERROR_INVALID_ARG
;
}
aConfig
-
>
reset
(
new
AudioCodecConfig
(
pt
desc
.
mName
desc
.
mClock
desc
.
mForceMono
?
1
:
desc
.
mChannels
desc
.
mFECEnabled
)
)
;
(
*
aConfig
)
-
>
mMaxPlaybackRate
=
desc
.
mMaxPlaybackRate
;
(
*
aConfig
)
-
>
mDtmfEnabled
=
desc
.
mDtmfEnabled
;
return
NS_OK
;
}
nsresult
TransceiverImpl
:
:
NegotiatedDetailsToAudioCodecConfigs
(
const
JsepTrackNegotiatedDetails
&
aDetails
std
:
:
vector
<
UniquePtr
<
AudioCodecConfig
>
>
*
aConfigs
)
{
UniquePtr
<
AudioCodecConfig
>
telephoneEvent
;
if
(
aDetails
.
GetEncodingCount
(
)
)
{
for
(
const
auto
&
codec
:
aDetails
.
GetEncoding
(
0
)
.
GetCodecs
(
)
)
{
UniquePtr
<
AudioCodecConfig
>
config
;
if
(
NS_FAILED
(
JsepCodecDescToAudioCodecConfig
(
*
codec
&
config
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
config
-
>
mName
=
=
"
telephone
-
event
"
)
{
telephoneEvent
=
std
:
:
move
(
config
)
;
}
else
{
aConfigs
-
>
push_back
(
std
:
:
move
(
config
)
)
;
}
}
}
if
(
telephoneEvent
)
{
aConfigs
-
>
push_back
(
std
:
:
move
(
telephoneEvent
)
)
;
}
if
(
aConfigs
-
>
empty
(
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Can
'
t
set
up
a
conduit
with
0
codecs
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
TransceiverImpl
:
:
UpdateAudioConduit
(
)
{
MOZ_ASSERT
(
IsValid
(
)
)
;
RefPtr
<
AudioSessionConduit
>
conduit
=
static_cast
<
AudioSessionConduit
*
>
(
mConduit
.
get
(
)
)
;
if
(
mJsepTransceiver
-
>
mSendTrack
.
GetNegotiatedDetails
(
)
&
&
mJsepTransceiver
-
>
mSendTrack
.
GetActive
(
)
)
{
const
auto
&
details
(
*
mJsepTransceiver
-
>
mSendTrack
.
GetNegotiatedDetails
(
)
)
;
std
:
:
vector
<
UniquePtr
<
AudioCodecConfig
>
>
configs
;
nsresult
rv
=
TransceiverImpl
:
:
NegotiatedDetailsToAudioCodecConfigs
(
details
&
configs
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Failed
to
convert
JsepCodecDescriptions
to
"
"
AudioCodecConfigs
(
send
)
.
"
)
;
return
rv
;
}
for
(
const
auto
&
value
:
configs
)
{
if
(
value
-
>
mName
=
=
"
telephone
-
event
"
)
{
conduit
-
>
SetDtmfPayloadType
(
value
-
>
mType
value
-
>
mFreq
)
;
break
;
}
}
auto
error
=
conduit
-
>
ConfigureSendMediaCodec
(
configs
[
0
]
.
get
(
)
)
;
if
(
error
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
ConfigureSendMediaCodec
failed
:
"
<
<
error
)
;
return
NS_ERROR_FAILURE
;
}
UpdateConduitRtpExtmap
(
*
conduit
details
LocalDirection
:
:
kSend
)
;
}
return
NS_OK
;
}
static
nsresult
JsepCodecDescToVideoCodecConfig
(
const
JsepCodecDescription
&
aCodec
UniquePtr
<
VideoCodecConfig
>
*
aConfig
)
{
MOZ_ASSERT
(
aCodec
.
mType
=
=
SdpMediaSection
:
:
kVideo
)
;
if
(
aCodec
.
mType
!
=
SdpMediaSection
:
:
kVideo
)
{
MOZ_ASSERT
(
false
"
JsepCodecDescription
has
wrong
type
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
JsepVideoCodecDescription
&
desc
=
static_cast
<
const
JsepVideoCodecDescription
&
>
(
aCodec
)
;
uint16_t
pt
;
if
(
!
desc
.
GetPtAsInt
(
&
pt
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Invalid
payload
type
:
"
<
<
desc
.
mDefaultPt
)
;
return
NS_ERROR_INVALID_ARG
;
}
UniquePtr
<
VideoCodecConfigH264
>
h264Config
;
if
(
desc
.
mName
=
=
"
H264
"
)
{
h264Config
=
MakeUnique
<
VideoCodecConfigH264
>
(
)
;
size_t
spropSize
=
sizeof
(
h264Config
-
>
sprop_parameter_sets
)
;
strncpy
(
h264Config
-
>
sprop_parameter_sets
desc
.
mSpropParameterSets
.
c_str
(
)
spropSize
)
;
h264Config
-
>
sprop_parameter_sets
[
spropSize
-
1
]
=
'
\
0
'
;
h264Config
-
>
packetization_mode
=
desc
.
mPacketizationMode
;
h264Config
-
>
profile_level_id
=
desc
.
mProfileLevelId
;
h264Config
-
>
tias_bw
=
0
;
}
aConfig
-
>
reset
(
new
VideoCodecConfig
(
pt
desc
.
mName
desc
.
mConstraints
h264Config
.
get
(
)
)
)
;
(
*
aConfig
)
-
>
mAckFbTypes
=
desc
.
mAckFbTypes
;
(
*
aConfig
)
-
>
mNackFbTypes
=
desc
.
mNackFbTypes
;
(
*
aConfig
)
-
>
mCcmFbTypes
=
desc
.
mCcmFbTypes
;
(
*
aConfig
)
-
>
mRembFbSet
=
desc
.
RtcpFbRembIsSet
(
)
;
(
*
aConfig
)
-
>
mFECFbSet
=
desc
.
mFECEnabled
;
(
*
aConfig
)
-
>
mTransportCCFbSet
=
desc
.
RtcpFbTransportCCIsSet
(
)
;
if
(
desc
.
mFECEnabled
)
{
(
*
aConfig
)
-
>
mREDPayloadType
=
desc
.
mREDPayloadType
;
(
*
aConfig
)
-
>
mULPFECPayloadType
=
desc
.
mULPFECPayloadType
;
}
return
NS_OK
;
}
nsresult
TransceiverImpl
:
:
NegotiatedDetailsToVideoCodecConfigs
(
const
JsepTrackNegotiatedDetails
&
aDetails
std
:
:
vector
<
UniquePtr
<
VideoCodecConfig
>
>
*
aConfigs
)
{
if
(
aDetails
.
GetEncodingCount
(
)
)
{
for
(
const
auto
&
codec
:
aDetails
.
GetEncoding
(
0
)
.
GetCodecs
(
)
)
{
UniquePtr
<
VideoCodecConfig
>
config
;
if
(
NS_FAILED
(
JsepCodecDescToVideoCodecConfig
(
*
codec
&
config
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
config
-
>
mTias
=
aDetails
.
GetTias
(
)
;
for
(
size_t
i
=
0
;
i
<
aDetails
.
GetEncodingCount
(
)
;
+
+
i
)
{
const
JsepTrackEncoding
&
jsepEncoding
(
aDetails
.
GetEncoding
(
i
)
)
;
if
(
jsepEncoding
.
HasFormat
(
codec
-
>
mDefaultPt
)
)
{
VideoCodecConfig
:
:
Encoding
encoding
;
encoding
.
rid
=
jsepEncoding
.
mRid
;
encoding
.
constraints
=
jsepEncoding
.
mConstraints
;
config
-
>
mEncodings
.
push_back
(
encoding
)
;
}
}
aConfigs
-
>
push_back
(
std
:
:
move
(
config
)
)
;
}
}
return
NS_OK
;
}
nsresult
TransceiverImpl
:
:
UpdateVideoConduit
(
)
{
MOZ_ASSERT
(
IsValid
(
)
)
;
RefPtr
<
VideoSessionConduit
>
conduit
=
static_cast
<
VideoSessionConduit
*
>
(
mConduit
.
get
(
)
)
;
if
(
mJsepTransceiver
-
>
mSendTrack
.
GetNegotiatedDetails
(
)
&
&
mJsepTransceiver
-
>
mSendTrack
.
GetActive
(
)
&
&
mSendTrack
)
{
const
auto
&
details
(
*
mJsepTransceiver
-
>
mSendTrack
.
GetNegotiatedDetails
(
)
)
;
UpdateConduitRtpExtmap
(
*
conduit
details
LocalDirection
:
:
kSend
)
;
nsresult
rv
=
ConfigureVideoCodecMode
(
*
conduit
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
std
:
:
vector
<
UniquePtr
<
VideoCodecConfig
>
>
configs
;
rv
=
TransceiverImpl
:
:
NegotiatedDetailsToVideoCodecConfigs
(
details
&
configs
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Failed
to
convert
JsepCodecDescriptions
to
"
"
VideoCodecConfigs
(
send
)
.
"
)
;
return
rv
;
}
if
(
configs
.
empty
(
)
)
{
MOZ_MTLOG
(
ML_INFO
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
No
codecs
were
negotiated
(
send
)
.
"
)
;
return
NS_OK
;
}
auto
error
=
conduit
-
>
ConfigureSendMediaCodec
(
configs
[
0
]
.
get
(
)
)
;
if
(
error
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
ConfigureSendMediaCodec
failed
:
"
<
<
error
)
;
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
nsresult
TransceiverImpl
:
:
ConfigureVideoCodecMode
(
VideoSessionConduit
&
aConduit
)
{
RefPtr
<
mozilla
:
:
dom
:
:
VideoStreamTrack
>
videotrack
=
mSendTrack
-
>
AsVideoStreamTrack
(
)
;
if
(
!
videotrack
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
mSendTrack
is
not
video
!
This
should
never
happen
!
"
)
;
MOZ_CRASH
(
)
;
return
NS_ERROR_FAILURE
;
}
dom
:
:
MediaSourceEnum
source
=
videotrack
-
>
GetSource
(
)
.
GetMediaSource
(
)
;
webrtc
:
:
VideoCodecMode
mode
=
webrtc
:
:
kRealtimeVideo
;
switch
(
source
)
{
case
dom
:
:
MediaSourceEnum
:
:
Browser
:
case
dom
:
:
MediaSourceEnum
:
:
Screen
:
case
dom
:
:
MediaSourceEnum
:
:
Window
:
mode
=
webrtc
:
:
kScreensharing
;
break
;
case
dom
:
:
MediaSourceEnum
:
:
Camera
:
default
:
mode
=
webrtc
:
:
kRealtimeVideo
;
break
;
}
auto
error
=
aConduit
.
ConfigureCodecMode
(
mode
)
;
if
(
error
)
{
MOZ_MTLOG
(
ML_ERROR
mPCHandle
<
<
"
[
"
<
<
mMid
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
ConfigureCodecMode
failed
:
"
<
<
error
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
TransceiverImpl
:
:
UpdateConduitRtpExtmap
(
MediaSessionConduit
&
aConduit
const
JsepTrackNegotiatedDetails
&
aDetails
const
LocalDirection
aDirection
)
{
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
extmaps
;
aDetails
.
ForEachRTPHeaderExtension
(
[
&
extmaps
]
(
const
SdpExtmapAttributeList
:
:
Extmap
&
extmap
)
{
extmaps
.
emplace_back
(
extmap
.
extensionname
extmap
.
entry
)
;
}
)
;
if
(
!
extmaps
.
empty
(
)
)
{
aConduit
.
SetLocalRTPExtensions
(
aDirection
extmaps
)
;
}
}
void
TransceiverImpl
:
:
Stop
(
)
{
mTransmitPipeline
-
>
Shutdown_m
(
)
;
mReceiver
-
>
Shutdown
(
)
;
UpdateSendTrack
(
nullptr
)
;
if
(
mConduit
)
{
mConduit
-
>
DeleteStreams
(
)
;
}
mConduit
=
nullptr
;
if
(
mDtmf
)
{
mDtmf
-
>
StopPlayout
(
)
;
}
}
bool
TransceiverImpl
:
:
IsVideo
(
)
const
{
return
mJsepTransceiver
-
>
GetMediaType
(
)
=
=
SdpMediaSection
:
:
MediaType
:
:
kVideo
;
}
}
