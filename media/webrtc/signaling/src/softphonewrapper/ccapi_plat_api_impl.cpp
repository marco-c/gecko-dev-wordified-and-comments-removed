#
include
"
CSFLog
.
h
"
#
include
"
CC_Common
.
h
"
#
include
"
csf_common
.
h
"
#
ifdef
WIN32
#
include
<
windows
.
h
>
#
else
#
ifdef
LINUX
#
include
<
sys
/
ioctl
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
arpa
/
inet
.
h
>
#
include
<
net
/
if
.
h
>
#
include
<
fcntl
.
h
>
#
endif
#
endif
#
include
"
cpr_string
.
h
"
static
const
char
*
logTag
=
"
sipcc
"
;
extern
"
C
"
{
#
include
"
plat_api
.
h
"
#
include
<
stdarg
.
h
>
void
NotifyStateChange
(
cc_callid_t
callid
int32_t
state
)
{
}
#
ifndef
OSX
int
platGetFeatureAllowed
(
cc_sis_feature_id_e
featureId
)
{
return
1
;
}
void
platSetStatusMessage
(
char
*
msg
)
{
}
void
platSetCucmRegTime
(
void
)
{
}
extern
"
C
"
void
platSetSpeakerMode
(
cc_boolean
state
)
{
}
int
platGetAudioDeviceStatus
(
plat_audio_device_t
device_type
)
{
return
1
;
}
boolean
platGetSpeakerHeadsetMode
(
)
{
return
TRUE
;
}
#
endif
void
platGetMacAddr
(
char
*
maddr
)
{
for
(
int
i
=
0
;
i
<
6
;
i
+
+
)
{
*
(
maddr
+
i
)
=
'
\
0
'
;
}
}
#
ifndef
OSX
int
platThreadInit
(
char
*
tname
)
{
return
0
;
}
int
platInit
(
)
{
return
0
;
}
void
debugInit
(
)
{
return
;
}
void
platAddCallControlClassifiers
(
unsigned
long
myIPAddr
unsigned
short
myPort
unsigned
long
cucm1IPAddr
unsigned
short
cucm1Port
unsigned
long
cucm2IPAddr
unsigned
short
cucm2Port
unsigned
long
cucm3IPAddr
unsigned
short
cucm3Port
unsigned
char
protocol
)
{
}
void
platRemoveCallControlClassifiers
(
)
{
}
cpr_ip_mode_e
platGetIpAddressMode
(
)
{
return
CPR_IP_MODE_IPV4
;
}
cc_boolean
platWlanISActive
(
)
{
return
FALSE
;
}
boolean
platIsNetworkInterfaceChanged
(
)
{
return
FALSE
;
}
int
platGetActiveInactivePhoneLoadName
(
char
*
image_a
char
*
image_b
int
len
)
{
if
(
image_a
!
=
nullptr
)
{
sstrncpy
(
image_a
"
image_a
"
len
)
;
}
if
(
image_b
!
=
nullptr
)
{
sstrncpy
(
image_b
"
image_b
"
len
)
;
}
return
1
;
}
int
platGetPhraseText
(
int
index
char
*
phrase
unsigned
int
len
)
{
if
(
phrase
=
=
nullptr
)
{
return
CC_FAILURE
;
}
sstrncpy
(
phrase
"
?
?
?
?
?
"
len
)
;
return
(
int
)
CC_SUCCESS
;
}
int
platGetUnregReason
(
)
{
return
0
;
}
void
platSetUnregReason
(
int
reason
)
{
typedef
struct
_unRegRreasonEnumPair
{
int
reason
;
const
char
*
pReasonStr
;
}
unRegRreasonEnumPair
;
static
unRegRreasonEnumPair
unRegReasons
[
]
=
{
{
CC_UNREG_REASON_UNSPECIFIED
"
CC_UNREG_REASON_UNSPECIFIED
"
}
{
CC_UNREG_REASON_TCP_TIMEOUT
"
CC_UNREG_REASON_TCP_TIMEOUT
"
}
{
CC_UNREG_REASON_CM_RESET_TCP
"
CC_UNREG_REASON_CM_RESET_TCP
"
}
{
CC_UNREG_REASON_CM_ABORTED_TCP
"
CC_UNREG_REASON_CM_ABORTED_TCP
"
}
{
CC_UNREG_REASON_CM_CLOSED_TCP
"
C_UNREG_REASON_CM_CLOSED_TCP
"
}
{
CC_UNREG_REASON_REG_TIMEOUT
"
CC_UNREG_REASON_REG_TIMEOUT
"
}
{
CC_UNREG_REASON_FALLBACK
"
CC_UNREG_REASON_FALLBACK
"
}
{
CC_UNREG_REASON_PHONE_KEYPAD
"
CC_UNREG_REASON_PHONE_KEYPAD
"
}
{
CC_UNREG_REASON_RESET_RESET
"
CC_UNREG_REASON_RESET_RESET
"
}
{
CC_UNREG_REASON_RESET_RESTART
"
CC_UNREG_REASON_RESET_RESTART
"
}
{
CC_UNREG_REASON_PHONE_REG_REJ
"
CC_UNREG_REASON_PHONE_REG_REJ
"
}
{
CC_UNREG_REASON_PHONE_INITIALIZED
"
CC_UNREG_REASON_PHONE_INITIALIZED
"
}
{
CC_UNREG_REASON_VOICE_VLAN_CHANGED
"
CC_UNREG_REASON_VOICE_VLAN_CHANGED
"
}
{
CC_UNREG_REASON_POWER_SAVE_PLUS
"
CC_UNREG_REASON_POWER_SAVE_PLUS
"
}
{
CC_UNREG_REASON_VERSION_STAMP_MISMATCH
"
CC_UNREG_REASON_VERSION_STAMP_MISMATCH
"
}
{
CC_UNREG_REASON_VERSION_STAMP_MISMATCH_CONFIG
"
CC_UNREG_REASON_VERSION_STAMP_MISMATCH_CONFIG
"
}
{
CC_UNREG_REASON_VERSION_STAMP_MISMATCH_SOFTKEY
"
CC_UNREG_REASON_VERSION_STAMP_MISMATCH_SOFTKEY
"
}
{
CC_UNREG_REASON_VERSION_STAMP_MISMATCH_DIALPLAN
"
CC_UNREG_REASON_VERSION_STAMP_MISMATCH_DIALPLAN
"
}
{
CC_UNREG_REASON_APPLY_CONFIG_RESTART
"
CC_UNREG_REASON_APPLY_CONFIG_RESTART
"
}
{
CC_UNREG_REASON_CONFIG_RETRY_RESTART
"
CC_UNREG_REASON_CONFIG_RETRY_RESTART
"
}
{
CC_UNREG_REASON_TLS_ERROR
"
CC_UNREG_REASON_TLS_ERROR
"
}
{
CC_UNREG_REASON_RESET_TO_INACTIVE_PARTITION
"
CC_UNREG_REASON_RESET_TO_INACTIVE_PARTITION
"
}
{
CC_UNREG_REASON_VPN_CONNECTIVITY_LOST
"
CC_UNREG_REASON_VPN_CONNECTIVITY_LOST
"
}
}
;
for
(
int
i
=
0
;
i
<
(
int
)
csf_countof
(
unRegReasons
)
;
i
+
+
)
{
unRegRreasonEnumPair
*
pCurrentUnRegReasonPair
=
&
unRegReasons
[
i
]
;
if
(
pCurrentUnRegReasonPair
-
>
reason
=
=
reason
)
{
CSFLogDebug
(
logTag
"
platSetUnregReason
(
%
s
)
"
pCurrentUnRegReasonPair
-
>
pReasonStr
)
;
return
;
}
}
CSFLogError
(
logTag
"
Unknown
reason
code
(
%
d
)
passed
to
platSetUnregReason
(
)
"
reason
)
;
}
#
endif
#
ifndef
OSX
void
platSetKPMLConfig
(
cc_kpml_config_t
kpml_config
)
{
}
boolean
platGetMWIStatus
(
cc_lineid_t
line
)
{
return
TRUE
;
}
plat_soc_status_e
platSecIsServerSecure
(
void
)
{
return
PLAT_SOCK_NONSECURE
;
}
cpr_socket_t
platSecSocConnect
(
char
*
host
int
port
int
ipMode
boolean
mode
unsigned
int
tos
plat_soc_connect_mode_e
connectionMode
uint16_t
*
localPort
)
{
return
0
;
}
plat_soc_connect_status_e
platSecSockIsConnected
(
cpr_socket_t
sock
)
{
return
PLAT_SOCK_CONN_OK
;
}
#
endif
#
ifdef
LINUX
int
platGenerateCryptoRand
(
uint8_t
*
buf
int
*
len
)
{
int
fd
;
int
rc
=
0
;
ssize_t
s
;
if
(
(
fd
=
open
(
"
/
dev
/
urandom
"
O_RDONLY
)
)
=
=
-
1
)
{
CSFLogDebug
(
logTag
"
Failed
to
open
prng
driver
"
)
;
return
0
;
}
s
=
read
(
fd
buf
(
size_t
)
*
len
)
;
if
(
s
>
0
)
{
*
len
=
s
;
rc
=
1
;
}
else
{
*
len
=
0
;
rc
=
0
;
}
(
void
)
close
(
fd
)
;
return
rc
;
}
#
else
int
platGenerateCryptoRand
(
uint8_t
*
buf
int
*
len
)
{
return
0
;
}
#
endif
#
ifndef
OSX
static
cc_uint32_t
majorSIS
=
1
minorSIS
=
0
addtnlSIS
=
0
;
static
char
sis_ver_name
[
CC_MAX_LEN_REQ_SUPP_PARAM_CISCO_SISTAG
]
=
{
0
}
;
void
platSetSISProtocolVer
(
cc_uint32_t
a
cc_uint32_t
b
cc_uint32_t
c
char
*
name
)
{
majorSIS
=
a
;
minorSIS
=
b
;
addtnlSIS
=
c
;
if
(
name
)
{
sstrncpy
(
sis_ver_name
name
csf_countof
(
sis_ver_name
)
)
;
}
else
{
*
sis_ver_name
=
'
\
0
'
;
}
}
void
platGetSISProtocolVer
(
cc_uint32_t
*
a
cc_uint32_t
*
b
cc_uint32_t
*
c
char
*
name
)
{
if
(
a
!
=
nullptr
)
{
*
a
=
majorSIS
;
}
if
(
b
!
=
nullptr
)
{
*
b
=
minorSIS
;
}
if
(
c
!
=
nullptr
)
{
*
c
=
addtnlSIS
;
}
if
(
name
!
=
nullptr
)
{
sstrncpy
(
name
sis_ver_name
CC_MAX_LEN_REQ_SUPP_PARAM_CISCO_SISTAG
)
;
}
return
;
}
void
debug_bind_keyword
(
const
char
*
cmd
int32_t
*
flag_ptr
)
{
return
;
}
void
debugif_add_keyword
(
const
char
*
x
const
char
*
y
)
{
return
;
}
#
endif
int
debugif_printf
(
const
char
*
_format
.
.
.
)
{
va_list
ap
;
va_start
(
ap
_format
)
;
CSFLogDebugV
(
logTag
_format
ap
)
;
va_end
(
ap
)
;
return
1
;
}
}
