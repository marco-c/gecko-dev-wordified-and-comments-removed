#
ifndef
mediapipeline_h__
#
define
mediapipeline_h__
#
include
<
map
>
#
include
"
sigslot
.
h
"
#
include
"
signaling
/
src
/
media
-
conduit
/
MediaConduitInterface
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
SrtpFlow
.
h
"
#
include
"
databuffer
.
h
"
#
include
"
mtransport
/
runnable_utils
.
h
"
#
include
"
mtransport
/
transportflow
.
h
"
#
include
"
AudioPacketizer
.
h
"
#
include
"
StreamTracks
.
h
"
#
include
"
signaling
/
src
/
peerconnection
/
PacketDumper
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
rtp_header_parser
.
h
"
#
define
WEBRTC_MAX_SAMPLE_RATE
48000
class
nsIPrincipal
;
namespace
mozilla
{
class
MediaPipelineFilter
;
class
PeerIdentity
;
class
AudioProxyThread
;
class
VideoFrameConverter
;
namespace
dom
{
class
MediaStreamTrack
;
struct
RTCRTPContributingSourceStats
;
}
class
SourceMediaStream
;
class
MediaPipeline
:
public
sigslot
:
:
has_slots
<
>
{
public
:
enum
class
DirectionType
{
TRANSMIT
RECEIVE
}
;
enum
class
StateType
{
MP_CONNECTING
MP_OPEN
MP_CLOSED
}
;
MediaPipeline
(
const
std
:
:
string
&
aPc
DirectionType
aDirection
nsCOMPtr
<
nsIEventTarget
>
aMainThread
nsCOMPtr
<
nsIEventTarget
>
aStsThread
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
virtual
void
Start
(
)
=
0
;
virtual
void
Stop
(
)
=
0
;
virtual
void
DetachMedia
(
)
{
}
void
SetLevel
(
size_t
aLevel
)
{
mLevel
=
aLevel
;
}
void
Shutdown_m
(
)
;
void
UpdateTransport_m
(
RefPtr
<
TransportFlow
>
aRtpTransport
RefPtr
<
TransportFlow
>
aRtcpTransport
nsAutoPtr
<
MediaPipelineFilter
>
aFilter
)
;
void
UpdateTransport_s
(
RefPtr
<
TransportFlow
>
aRtpTransport
RefPtr
<
TransportFlow
>
aRtcpTransport
nsAutoPtr
<
MediaPipelineFilter
>
aFilter
)
;
void
AddRIDExtension_m
(
size_t
aExtensionId
)
;
void
AddRIDExtension_s
(
size_t
aExtensionId
)
;
void
AddRIDFilter_m
(
const
std
:
:
string
&
aRid
)
;
void
AddRIDFilter_s
(
const
std
:
:
string
&
aRid
)
;
virtual
DirectionType
Direction
(
)
const
{
return
mDirection
;
}
int
Level
(
)
const
{
return
mLevel
;
}
virtual
bool
IsVideo
(
)
const
=
0
;
bool
IsDoingRtcpMux
(
)
const
{
return
mRtp
.
mType
=
=
MUX
;
}
class
RtpCSRCStats
{
public
:
static
DOMHighResTimeStamp
GetExpiryFromTime
(
const
DOMHighResTimeStamp
aTime
)
;
RtpCSRCStats
(
const
uint32_t
aCsrc
const
DOMHighResTimeStamp
aTime
)
;
~
RtpCSRCStats
(
)
{
}
;
void
GetWebidlInstance
(
dom
:
:
RTCRTPContributingSourceStats
&
aWebidlObj
const
nsString
&
aInboundRtpStreamId
)
const
;
void
SetTimestamp
(
const
DOMHighResTimeStamp
aTime
)
{
mTimestamp
=
aTime
;
}
bool
Expired
(
const
DOMHighResTimeStamp
aExpiry
)
const
{
return
mTimestamp
<
aExpiry
;
}
private
:
static
const
double
constexpr
EXPIRY_TIME_MILLISECONDS
=
10
*
1000
;
uint32_t
mCsrc
;
DOMHighResTimeStamp
mTimestamp
;
}
;
void
GetContributingSourceStats
(
const
nsString
&
aInboundStreamId
FallibleTArray
<
dom
:
:
RTCRTPContributingSourceStats
>
&
aArr
)
const
;
int32_t
RtpPacketsSent
(
)
const
{
return
mRtpPacketsSent
;
}
int64_t
RtpBytesSent
(
)
const
{
return
mRtpBytesSent
;
}
int32_t
RtcpPacketsSent
(
)
const
{
return
mRtcpPacketsSent
;
}
int32_t
RtpPacketsReceived
(
)
const
{
return
mRtpPacketsReceived
;
}
int64_t
RtpBytesReceived
(
)
const
{
return
mRtpBytesReceived
;
}
int32_t
RtcpPacketsReceived
(
)
const
{
return
mRtcpPacketsReceived
;
}
MediaSessionConduit
*
Conduit
(
)
const
{
return
mConduit
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaPipeline
)
typedef
enum
{
RTP
RTCP
MUX
MAX_RTP_TYPE
}
RtpType
;
class
PipelineTransport
:
public
TransportInterface
{
public
:
explicit
PipelineTransport
(
MediaPipeline
*
aPipeline
)
:
mPipeline
(
aPipeline
)
mStsThread
(
aPipeline
-
>
mStsThread
)
{
}
void
Attach
(
MediaPipeline
*
pipeline
)
{
mPipeline
=
pipeline
;
}
void
Detach
(
)
{
mPipeline
=
nullptr
;
}
MediaPipeline
*
Pipeline
(
)
const
{
return
mPipeline
;
}
virtual
nsresult
SendRtpPacket
(
const
uint8_t
*
aData
size_t
aLen
)
;
virtual
nsresult
SendRtcpPacket
(
const
uint8_t
*
aData
size_t
aLen
)
;
private
:
nsresult
SendRtpRtcpPacket_s
(
nsAutoPtr
<
DataBuffer
>
aData
bool
aIsRtp
)
;
RefPtr
<
MediaPipeline
>
mPipeline
;
nsCOMPtr
<
nsIEventTarget
>
mStsThread
;
}
;
protected
:
virtual
~
MediaPipeline
(
)
;
nsresult
AttachTransport_s
(
)
;
friend
class
PipelineTransport
;
struct
TransportInfo
{
TransportInfo
(
RefPtr
<
TransportFlow
>
aFlow
RtpType
aType
)
:
mTransport
(
aFlow
)
mState
(
StateType
:
:
MP_CONNECTING
)
mType
(
aType
)
{
}
void
Detach
(
)
{
mTransport
=
nullptr
;
mSendSrtp
=
nullptr
;
mRecvSrtp
=
nullptr
;
}
RefPtr
<
TransportFlow
>
mTransport
;
StateType
mState
;
RefPtr
<
SrtpFlow
>
mSendSrtp
;
RefPtr
<
SrtpFlow
>
mRecvSrtp
;
RtpType
mType
;
}
;
virtual
nsresult
TransportFailed_s
(
TransportInfo
&
aInfo
)
;
virtual
nsresult
TransportReady_s
(
TransportInfo
&
aInfo
)
;
void
UpdateRtcpMuxState
(
TransportInfo
&
aInfo
)
;
nsresult
ConnectTransport_s
(
TransportInfo
&
aInfo
)
;
TransportInfo
*
GetTransportInfo_s
(
TransportFlow
*
aFlow
)
;
void
IncrementRtpPacketsSent
(
int
aBytes
)
;
void
IncrementRtcpPacketsSent
(
)
;
void
IncrementRtpPacketsReceived
(
int
aBytes
)
;
virtual
void
OnRtpPacketReceived
(
)
{
}
;
void
IncrementRtcpPacketsReceived
(
)
;
virtual
nsresult
SendPacket
(
TransportFlow
*
aFlow
const
void
*
aData
int
aLen
)
;
void
StateChange
(
TransportFlow
*
flow
TransportLayer
:
:
State
)
;
void
RtpPacketReceived
(
TransportLayer
*
aLayer
const
unsigned
char
*
aData
size_t
aLen
)
;
void
RtcpPacketReceived
(
TransportLayer
*
aLayer
const
unsigned
char
*
aData
size_t
aLen
)
;
void
PacketReceived
(
TransportLayer
*
aLayer
const
unsigned
char
*
aData
size_t
aLen
)
;
DirectionType
mDirection
;
size_t
mLevel
;
RefPtr
<
MediaSessionConduit
>
mConduit
;
TransportInfo
mRtp
;
TransportInfo
mRtcp
;
nsCOMPtr
<
nsIEventTarget
>
mMainThread
;
nsCOMPtr
<
nsIEventTarget
>
mStsThread
;
RefPtr
<
PipelineTransport
>
mTransport
;
int32_t
mRtpPacketsSent
;
int32_t
mRtcpPacketsSent
;
int32_t
mRtpPacketsReceived
;
int32_t
mRtcpPacketsReceived
;
int64_t
mRtpBytesSent
;
int64_t
mRtpBytesReceived
;
std
:
:
map
<
uint32_t
RtpCSRCStats
>
mCsrcStats
;
std
:
:
string
mPc
;
std
:
:
string
mDescription
;
nsAutoPtr
<
MediaPipelineFilter
>
mFilter
;
nsAutoPtr
<
webrtc
:
:
RtpHeaderParser
>
mRtpParser
;
nsAutoPtr
<
PacketDumper
>
mPacketDumper
;
private
:
static
DOMHighResTimeStamp
GetNow
(
)
;
bool
IsRtp
(
const
unsigned
char
*
aData
size_t
aLen
)
;
void
DetachTransport_s
(
)
;
}
;
class
ConduitDeleteEvent
:
public
Runnable
{
public
:
explicit
ConduitDeleteEvent
(
already_AddRefed
<
MediaSessionConduit
>
aConduit
)
:
Runnable
(
"
ConduitDeleteEvent
"
)
mConduit
(
aConduit
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
NS_OK
;
}
private
:
RefPtr
<
MediaSessionConduit
>
mConduit
;
}
;
class
MediaPipelineTransmit
:
public
MediaPipeline
{
public
:
MediaPipelineTransmit
(
const
std
:
:
string
&
aPc
nsCOMPtr
<
nsIEventTarget
>
aMainThread
nsCOMPtr
<
nsIEventTarget
>
aStsThread
bool
aIsVideo
dom
:
:
MediaStreamTrack
*
aDomTrack
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
void
Start
(
)
override
;
void
Stop
(
)
override
;
bool
IsVideo
(
)
const
override
;
virtual
void
UpdateSinkIdentity_m
(
dom
:
:
MediaStreamTrack
*
aTrack
nsIPrincipal
*
aPrincipal
const
PeerIdentity
*
aSinkIdentity
)
;
void
DetachMedia
(
)
override
;
nsresult
TransportReady_s
(
TransportInfo
&
aInfo
)
override
;
virtual
nsresult
ReplaceTrack
(
RefPtr
<
dom
:
:
MediaStreamTrack
>
&
aDomTrack
)
;
class
PipelineListener
;
class
VideoFrameFeeder
;
protected
:
~
MediaPipelineTransmit
(
)
;
void
SetDescription
(
)
;
private
:
RefPtr
<
PipelineListener
>
mListener
;
RefPtr
<
AudioProxyThread
>
mAudioProcessing
;
RefPtr
<
VideoFrameFeeder
>
mFeeder
;
RefPtr
<
VideoFrameConverter
>
mConverter
;
bool
mIsVideo
;
RefPtr
<
dom
:
:
MediaStreamTrack
>
mDomTrack
;
bool
mTransmitting
;
}
;
class
MediaPipelineReceive
:
public
MediaPipeline
{
public
:
MediaPipelineReceive
(
const
std
:
:
string
&
aPc
nsCOMPtr
<
nsIEventTarget
>
aMainThread
nsCOMPtr
<
nsIEventTarget
>
aStsThread
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
virtual
void
SetPrincipalHandle_m
(
const
PrincipalHandle
&
aPrincipalHandle
)
=
0
;
protected
:
~
MediaPipelineReceive
(
)
;
}
;
class
MediaPipelineReceiveAudio
:
public
MediaPipelineReceive
{
public
:
MediaPipelineReceiveAudio
(
const
std
:
:
string
&
aPc
nsCOMPtr
<
nsIEventTarget
>
aMainThread
nsCOMPtr
<
nsIEventTarget
>
aStsThread
RefPtr
<
AudioSessionConduit
>
aConduit
dom
:
:
MediaStreamTrack
*
aTrack
)
;
void
DetachMedia
(
)
override
;
bool
IsVideo
(
)
const
override
{
return
false
;
}
void
SetPrincipalHandle_m
(
const
PrincipalHandle
&
aPrincipalHandle
)
override
;
void
Start
(
)
override
;
void
Stop
(
)
override
;
void
OnRtpPacketReceived
(
)
override
;
private
:
class
PipelineListener
;
RefPtr
<
PipelineListener
>
mListener
;
}
;
class
MediaPipelineReceiveVideo
:
public
MediaPipelineReceive
{
public
:
MediaPipelineReceiveVideo
(
const
std
:
:
string
&
aPc
nsCOMPtr
<
nsIEventTarget
>
aMainThread
nsCOMPtr
<
nsIEventTarget
>
aStsThread
RefPtr
<
VideoSessionConduit
>
aConduit
dom
:
:
MediaStreamTrack
*
aTrack
)
;
void
DetachMedia
(
)
override
;
bool
IsVideo
(
)
const
override
{
return
true
;
}
void
SetPrincipalHandle_m
(
const
PrincipalHandle
&
aPrincipalHandle
)
override
;
void
Start
(
)
override
;
void
Stop
(
)
override
;
void
OnRtpPacketReceived
(
)
override
;
private
:
class
PipelineRenderer
;
friend
class
PipelineRenderer
;
class
PipelineListener
;
RefPtr
<
PipelineRenderer
>
mRenderer
;
RefPtr
<
PipelineListener
>
mListener
;
}
;
}
#
endif
