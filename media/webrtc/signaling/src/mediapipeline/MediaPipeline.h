#
ifndef
mediapipeline_h__
#
define
mediapipeline_h__
#
include
"
sigslot
.
h
"
#
ifdef
USE_FAKE_MEDIA_STREAMS
#
include
"
FakeMediaStreams
.
h
"
#
endif
#
include
"
MediaConduitInterface
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
SrtpFlow
.
h
"
#
include
"
databuffer
.
h
"
#
include
"
runnable_utils
.
h
"
#
include
"
transportflow
.
h
"
#
include
"
AudioPacketizer
.
h
"
#
include
"
StreamTracks
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
interface
/
rtp_header_parser
.
h
"
#
define
WEBRTC_DEFAULT_SAMPLE_RATE
32000
class
nsIPrincipal
;
namespace
mozilla
{
class
MediaPipelineFilter
;
class
PeerIdentity
;
class
AudioProxyThread
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
class
VideoFrameConverter
;
#
endif
#
ifndef
USE_FAKE_MEDIA_STREAMS
namespace
dom
{
class
MediaStreamTrack
;
}
class
SourceMediaStream
;
#
endif
class
MediaPipeline
:
public
sigslot
:
:
has_slots
<
>
{
public
:
enum
Direction
{
TRANSMIT
RECEIVE
}
;
enum
State
{
MP_CONNECTING
MP_OPEN
MP_CLOSED
}
;
MediaPipeline
(
const
std
:
:
string
&
pc
Direction
direction
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
const
std
:
:
string
&
track_id
int
level
RefPtr
<
MediaSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
;
void
DetachTransport_s
(
)
;
void
ShutdownMedia_m
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
if
(
direction_
=
=
RECEIVE
)
{
conduit_
-
>
StopReceiving
(
)
;
}
else
{
conduit_
-
>
StopTransmitting
(
)
;
}
DetachMedia
(
)
;
}
virtual
nsresult
Init
(
)
;
void
UpdateTransport_m
(
int
level
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
;
void
UpdateTransport_s
(
int
level
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
;
void
SelectSsrc_m
(
size_t
ssrc_index
)
;
void
SelectSsrc_s
(
size_t
ssrc_index
)
;
virtual
Direction
direction
(
)
const
{
return
direction_
;
}
virtual
const
std
:
:
string
&
trackid
(
)
const
{
return
track_id_
;
}
virtual
int
level
(
)
const
{
return
level_
;
}
virtual
bool
IsVideo
(
)
const
=
0
;
bool
IsDoingRtcpMux
(
)
const
{
return
(
rtp_
.
type_
=
=
MUX
)
;
}
int32_t
rtp_packets_sent
(
)
const
{
return
rtp_packets_sent_
;
}
int64_t
rtp_bytes_sent
(
)
const
{
return
rtp_bytes_sent_
;
}
int32_t
rtcp_packets_sent
(
)
const
{
return
rtcp_packets_sent_
;
}
int32_t
rtp_packets_received
(
)
const
{
return
rtp_packets_received_
;
}
int64_t
rtp_bytes_received
(
)
const
{
return
rtp_bytes_received_
;
}
int32_t
rtcp_packets_received
(
)
const
{
return
rtcp_packets_received_
;
}
MediaSessionConduit
*
Conduit
(
)
const
{
return
conduit_
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaPipeline
)
typedef
enum
{
RTP
RTCP
MUX
MAX_RTP_TYPE
}
RtpType
;
protected
:
virtual
~
MediaPipeline
(
)
;
virtual
void
DetachMedia
(
)
{
}
nsresult
AttachTransport_s
(
)
;
class
PipelineTransport
:
public
TransportInterface
{
public
:
explicit
PipelineTransport
(
MediaPipeline
*
pipeline
)
:
pipeline_
(
pipeline
)
sts_thread_
(
pipeline
-
>
sts_thread_
)
{
}
void
Attach
(
MediaPipeline
*
pipeline
)
{
pipeline_
=
pipeline
;
}
void
Detach
(
)
{
pipeline_
=
nullptr
;
}
MediaPipeline
*
pipeline
(
)
const
{
return
pipeline_
;
}
virtual
nsresult
SendRtpPacket
(
const
void
*
data
int
len
)
;
virtual
nsresult
SendRtcpPacket
(
const
void
*
data
int
len
)
;
private
:
nsresult
SendRtpRtcpPacket_s
(
nsAutoPtr
<
DataBuffer
>
data
bool
is_rtp
)
;
MediaPipeline
*
pipeline_
;
nsCOMPtr
<
nsIEventTarget
>
sts_thread_
;
}
;
friend
class
PipelineTransport
;
class
TransportInfo
{
public
:
TransportInfo
(
RefPtr
<
TransportFlow
>
flow
RtpType
type
)
:
transport_
(
flow
)
state_
(
MP_CONNECTING
)
type_
(
type
)
{
MOZ_ASSERT
(
flow
)
;
}
void
Detach
(
)
{
transport_
=
nullptr
;
send_srtp_
=
nullptr
;
recv_srtp_
=
nullptr
;
}
RefPtr
<
TransportFlow
>
transport_
;
State
state_
;
RefPtr
<
SrtpFlow
>
send_srtp_
;
RefPtr
<
SrtpFlow
>
recv_srtp_
;
RtpType
type_
;
}
;
virtual
nsresult
TransportFailed_s
(
TransportInfo
&
info
)
;
virtual
nsresult
TransportReady_s
(
TransportInfo
&
info
)
;
void
UpdateRtcpMuxState
(
TransportInfo
&
info
)
;
void
DisconnectTransport_s
(
TransportInfo
&
info
)
;
nsresult
ConnectTransport_s
(
TransportInfo
&
info
)
;
TransportInfo
*
GetTransportInfo_s
(
TransportFlow
*
flow
)
;
void
increment_rtp_packets_sent
(
int
bytes
)
;
void
increment_rtcp_packets_sent
(
)
;
void
increment_rtp_packets_received
(
int
bytes
)
;
void
increment_rtcp_packets_received
(
)
;
virtual
nsresult
SendPacket
(
TransportFlow
*
flow
const
void
*
data
int
len
)
;
void
StateChange
(
TransportFlow
*
flow
TransportLayer
:
:
State
)
;
void
RtpPacketReceived
(
TransportLayer
*
layer
const
unsigned
char
*
data
size_t
len
)
;
void
RtcpPacketReceived
(
TransportLayer
*
layer
const
unsigned
char
*
data
size_t
len
)
;
void
PacketReceived
(
TransportLayer
*
layer
const
unsigned
char
*
data
size_t
len
)
;
Direction
direction_
;
std
:
:
string
track_id_
;
Atomic
<
int
>
level_
;
RefPtr
<
MediaSessionConduit
>
conduit_
;
TransportInfo
rtp_
;
TransportInfo
rtcp_
;
nsCOMPtr
<
nsIEventTarget
>
main_thread_
;
nsCOMPtr
<
nsIEventTarget
>
sts_thread_
;
RefPtr
<
PipelineTransport
>
transport_
;
int32_t
rtp_packets_sent_
;
int32_t
rtcp_packets_sent_
;
int32_t
rtp_packets_received_
;
int32_t
rtcp_packets_received_
;
int64_t
rtp_bytes_sent_
;
int64_t
rtp_bytes_received_
;
std
:
:
vector
<
uint32_t
>
ssrcs_received_
;
std
:
:
string
pc_
;
std
:
:
string
description_
;
nsAutoPtr
<
MediaPipelineFilter
>
filter_
;
nsAutoPtr
<
webrtc
:
:
RtpHeaderParser
>
rtp_parser_
;
private
:
nsresult
Init_s
(
)
;
bool
IsRtp
(
const
unsigned
char
*
data
size_t
len
)
;
}
;
class
ConduitDeleteEvent
:
public
Runnable
{
public
:
explicit
ConduitDeleteEvent
(
already_AddRefed
<
MediaSessionConduit
>
aConduit
)
:
mConduit
(
aConduit
)
{
}
NS_IMETHOD
Run
(
)
{
return
NS_OK
;
}
private
:
RefPtr
<
MediaSessionConduit
>
mConduit
;
}
;
class
MediaPipelineTransmit
:
public
MediaPipeline
{
public
:
MediaPipelineTransmit
(
const
std
:
:
string
&
pc
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
dom
:
:
MediaStreamTrack
*
domtrack
const
std
:
:
string
&
track_id
int
level
RefPtr
<
MediaSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
;
nsresult
Init
(
)
override
;
virtual
void
AttachToTrack
(
const
std
:
:
string
&
track_id
)
;
bool
IsVideo
(
)
const
override
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
virtual
void
UpdateSinkIdentity_m
(
dom
:
:
MediaStreamTrack
*
track
nsIPrincipal
*
principal
const
PeerIdentity
*
sinkIdentity
)
;
#
endif
void
DetachMedia
(
)
override
;
nsresult
TransportReady_s
(
TransportInfo
&
info
)
override
;
virtual
nsresult
ReplaceTrack
(
dom
:
:
MediaStreamTrack
&
domtrack
)
;
class
PipelineListener
;
class
VideoFrameFeeder
;
class
PipelineVideoSink
;
protected
:
~
MediaPipelineTransmit
(
)
;
private
:
RefPtr
<
PipelineListener
>
listener_
;
RefPtr
<
AudioProxyThread
>
audio_processing_
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
RefPtr
<
VideoFrameFeeder
>
feeder_
;
RefPtr
<
VideoFrameConverter
>
converter_
;
#
endif
RefPtr
<
PipelineVideoSink
>
video_sink_
;
dom
:
:
MediaStreamTrack
*
domtrack_
;
}
;
class
MediaPipelineReceive
:
public
MediaPipeline
{
public
:
MediaPipelineReceive
(
const
std
:
:
string
&
pc
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
SourceMediaStream
*
stream
const
std
:
:
string
&
track_id
int
level
RefPtr
<
MediaSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
;
int
segments_added
(
)
const
{
return
segments_added_
;
}
#
ifndef
USE_FAKE_MEDIA_STREAMS
virtual
void
SetPrincipalHandle_m
(
const
PrincipalHandle
&
principal_handle
)
=
0
;
#
endif
protected
:
~
MediaPipelineReceive
(
)
;
RefPtr
<
SourceMediaStream
>
stream_
;
int
segments_added_
;
private
:
}
;
class
MediaPipelineReceiveAudio
:
public
MediaPipelineReceive
{
public
:
MediaPipelineReceiveAudio
(
const
std
:
:
string
&
pc
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
SourceMediaStream
*
stream
const
std
:
:
string
&
media_stream_track_id
TrackID
numeric_track_id
int
level
RefPtr
<
AudioSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
;
void
DetachMedia
(
)
override
;
nsresult
Init
(
)
override
;
bool
IsVideo
(
)
const
override
{
return
false
;
}
#
ifndef
USE_FAKE_MEDIA_STREAMS
void
SetPrincipalHandle_m
(
const
PrincipalHandle
&
principal_handle
)
override
;
#
endif
private
:
class
PipelineListener
;
RefPtr
<
PipelineListener
>
listener_
;
}
;
class
MediaPipelineReceiveVideo
:
public
MediaPipelineReceive
{
public
:
MediaPipelineReceiveVideo
(
const
std
:
:
string
&
pc
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
SourceMediaStream
*
stream
const
std
:
:
string
&
media_stream_track_id
TrackID
numeric_track_id
int
level
RefPtr
<
VideoSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
;
void
DetachMedia
(
)
override
;
nsresult
Init
(
)
override
;
bool
IsVideo
(
)
const
override
{
return
true
;
}
#
ifndef
USE_FAKE_MEDIA_STREAMS
void
SetPrincipalHandle_m
(
const
PrincipalHandle
&
principal_handle
)
override
;
#
endif
private
:
class
PipelineRenderer
;
friend
class
PipelineRenderer
;
class
PipelineListener
;
RefPtr
<
PipelineRenderer
>
renderer_
;
RefPtr
<
PipelineListener
>
listener_
;
}
;
}
#
endif
