#
include
"
MediaPipeline
.
h
"
#
ifndef
USE_FAKE_MEDIA_STREAMS
#
include
"
MediaStreamGraphImpl
.
h
"
#
endif
#
include
<
math
.
h
>
#
include
"
nspr
.
h
"
#
include
"
srtp
.
h
"
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
#
include
"
VideoSegment
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
VideoUtils
.
h
"
#
ifdef
WEBRTC_GONK
#
include
"
GrallocImages
.
h
"
#
include
"
mozilla
/
layers
/
GrallocTextureClient
.
h
"
#
endif
#
endif
#
include
"
nsError
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
databuffer
.
h
"
#
include
"
transportflow
.
h
"
#
include
"
transportlayer
.
h
"
#
include
"
transportlayerdtls
.
h
"
#
include
"
transportlayerice
.
h
"
#
include
"
runnable_utils
.
h
"
#
include
"
libyuv
/
convert
.
h
"
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
#
include
"
mozilla
/
PeerIdentity
.
h
"
#
endif
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
webrtc
/
common_types
.
h
"
#
include
"
webrtc
/
common_video
/
interface
/
native_handle
.
h
"
#
include
"
webrtc
/
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
include
"
webrtc
/
video_engine
/
include
/
vie_errors
.
h
"
#
include
"
logging
.
h
"
#
define
DEFAULT_SAMPLE_RATE
32000
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
MOZ_MTLOG_MODULE
(
"
mediapipeline
"
)
namespace
mozilla
{
static
char
kDTLSExporterLabel
[
]
=
"
EXTRACTOR
-
dtls_srtp
"
;
MediaPipeline
:
:
~
MediaPipeline
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
MOZ_ASSERT
(
!
stream_
)
;
MOZ_MTLOG
(
ML_INFO
"
Destroying
MediaPipeline
:
"
<
<
description_
)
;
}
nsresult
MediaPipeline
:
:
Init
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
if
(
direction_
=
=
RECEIVE
)
{
conduit_
-
>
SetReceiverTransport
(
transport_
)
;
}
else
{
conduit_
-
>
SetTransmitterTransport
(
transport_
)
;
}
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
RefPtr
<
MediaPipeline
>
(
this
)
&
MediaPipeline
:
:
Init_s
)
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
nsresult
MediaPipeline
:
:
Init_s
(
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
return
AttachTransport_s
(
)
;
}
void
MediaPipeline
:
:
ShutdownTransport_s
(
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
MOZ_ASSERT
(
!
stream_
)
;
DetachTransport_s
(
)
;
}
void
MediaPipeline
:
:
DetachTransport_s
(
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
disconnect_all
(
)
;
transport_
-
>
Detach
(
)
;
rtp_
.
Detach
(
)
;
rtcp_
.
Detach
(
)
;
}
nsresult
MediaPipeline
:
:
AttachTransport_s
(
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
nsresult
res
;
MOZ_ASSERT
(
rtp_
.
transport_
)
;
MOZ_ASSERT
(
rtcp_
.
transport_
)
;
res
=
ConnectTransport_s
(
rtp_
)
;
if
(
NS_FAILED
(
res
)
)
{
return
res
;
}
if
(
rtcp_
.
transport_
!
=
rtp_
.
transport_
)
{
res
=
ConnectTransport_s
(
rtcp_
)
;
if
(
NS_FAILED
(
res
)
)
{
return
res
;
}
}
return
NS_OK
;
}
void
MediaPipeline
:
:
UpdateTransport_m
(
int
level
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
{
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
this
&
MediaPipeline
:
:
UpdateTransport_s
level
rtp_transport
rtcp_transport
filter
)
NS_DISPATCH_NORMAL
)
;
}
void
MediaPipeline
:
:
UpdateTransport_s
(
int
level
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
{
bool
rtcp_mux
=
false
;
if
(
!
rtcp_transport
)
{
rtcp_transport
=
rtp_transport
;
rtcp_mux
=
true
;
}
if
(
(
rtp_transport
!
=
rtp_
.
transport_
)
|
|
(
rtcp_transport
!
=
rtcp_
.
transport_
)
)
{
DetachTransport_s
(
)
;
rtp_
=
TransportInfo
(
rtp_transport
rtcp_mux
?
MUX
:
RTP
)
;
rtcp_
=
TransportInfo
(
rtcp_transport
rtcp_mux
?
MUX
:
RTCP
)
;
AttachTransport_s
(
)
;
}
level_
=
level
;
if
(
filter_
&
&
filter
)
{
filter_
-
>
Update
(
*
filter
)
;
}
else
{
filter_
=
filter
;
}
}
void
MediaPipeline
:
:
SelectSsrc_m
(
size_t
ssrc_index
)
{
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
this
&
MediaPipeline
:
:
SelectSsrc_s
ssrc_index
)
NS_DISPATCH_NORMAL
)
;
}
void
MediaPipeline
:
:
SelectSsrc_s
(
size_t
ssrc_index
)
{
filter_
=
new
MediaPipelineFilter
;
if
(
ssrc_index
<
ssrcs_received_
.
size
(
)
)
{
filter_
-
>
AddRemoteSSRC
(
ssrcs_received_
[
ssrc_index
]
)
;
}
else
{
MOZ_MTLOG
(
ML_WARNING
"
SelectSsrc
called
with
"
<
<
ssrc_index
<
<
"
but
we
"
<
<
"
have
only
seen
"
<
<
ssrcs_received_
.
size
(
)
<
<
"
ssrcs
"
)
;
}
}
void
MediaPipeline
:
:
StateChange
(
TransportFlow
*
flow
TransportLayer
:
:
State
state
)
{
TransportInfo
*
info
=
GetTransportInfo_s
(
flow
)
;
MOZ_ASSERT
(
info
)
;
if
(
state
=
=
TransportLayer
:
:
TS_OPEN
)
{
MOZ_MTLOG
(
ML_INFO
"
Flow
is
ready
"
)
;
TransportReady_s
(
*
info
)
;
}
else
if
(
state
=
=
TransportLayer
:
:
TS_CLOSED
|
|
state
=
=
TransportLayer
:
:
TS_ERROR
)
{
TransportFailed_s
(
*
info
)
;
}
}
static
bool
MakeRtpTypeToStringArray
(
const
char
*
*
array
)
{
static
const
char
*
RTP_str
=
"
RTP
"
;
static
const
char
*
RTCP_str
=
"
RTCP
"
;
static
const
char
*
MUX_str
=
"
RTP
/
RTCP
mux
"
;
array
[
MediaPipeline
:
:
RTP
]
=
RTP_str
;
array
[
MediaPipeline
:
:
RTCP
]
=
RTCP_str
;
array
[
MediaPipeline
:
:
MUX
]
=
MUX_str
;
return
true
;
}
static
const
char
*
ToString
(
MediaPipeline
:
:
RtpType
type
)
{
static
const
char
*
array
[
(
int
)
MediaPipeline
:
:
MAX_RTP_TYPE
]
=
{
nullptr
}
;
static
bool
dummy
=
MakeRtpTypeToStringArray
(
array
)
;
(
void
)
dummy
;
return
array
[
type
]
;
}
nsresult
MediaPipeline
:
:
TransportReady_s
(
TransportInfo
&
info
)
{
MOZ_ASSERT
(
!
description_
.
empty
(
)
)
;
if
(
info
.
state_
!
=
MP_CONNECTING
)
{
MOZ_MTLOG
(
ML_ERROR
"
Transport
ready
for
flow
in
wrong
state
:
"
<
<
description_
<
<
"
:
"
<
<
ToString
(
info
.
type_
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_MTLOG
(
ML_INFO
"
Transport
ready
for
pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
flow
"
<
<
description_
<
<
"
:
"
<
<
ToString
(
info
.
type_
)
)
;
nsresult
res
;
TransportLayerDtls
*
dtls
=
static_cast
<
TransportLayerDtls
*
>
(
info
.
transport_
-
>
GetLayer
(
TransportLayerDtls
:
:
ID
(
)
)
)
;
MOZ_ASSERT
(
dtls
)
;
uint16_t
cipher_suite
;
res
=
dtls
-
>
GetSrtpCipher
(
&
cipher_suite
)
;
if
(
NS_FAILED
(
res
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Failed
to
negotiate
DTLS
-
SRTP
.
This
is
an
error
"
)
;
info
.
state_
=
MP_CLOSED
;
UpdateRtcpMuxState
(
info
)
;
return
res
;
}
unsigned
char
srtp_block
[
SRTP_TOTAL_KEY_LENGTH
*
2
]
;
res
=
dtls
-
>
ExportKeyingMaterial
(
kDTLSExporterLabel
false
"
"
srtp_block
sizeof
(
srtp_block
)
)
;
if
(
NS_FAILED
(
res
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Failed
to
compute
DTLS
-
SRTP
keys
.
This
is
an
error
"
)
;
info
.
state_
=
MP_CLOSED
;
UpdateRtcpMuxState
(
info
)
;
MOZ_CRASH
(
)
;
return
res
;
}
unsigned
char
client_write_key
[
SRTP_TOTAL_KEY_LENGTH
]
;
unsigned
char
server_write_key
[
SRTP_TOTAL_KEY_LENGTH
]
;
int
offset
=
0
;
memcpy
(
client_write_key
srtp_block
+
offset
SRTP_MASTER_KEY_LENGTH
)
;
offset
+
=
SRTP_MASTER_KEY_LENGTH
;
memcpy
(
server_write_key
srtp_block
+
offset
SRTP_MASTER_KEY_LENGTH
)
;
offset
+
=
SRTP_MASTER_KEY_LENGTH
;
memcpy
(
client_write_key
+
SRTP_MASTER_KEY_LENGTH
srtp_block
+
offset
SRTP_MASTER_SALT_LENGTH
)
;
offset
+
=
SRTP_MASTER_SALT_LENGTH
;
memcpy
(
server_write_key
+
SRTP_MASTER_KEY_LENGTH
srtp_block
+
offset
SRTP_MASTER_SALT_LENGTH
)
;
offset
+
=
SRTP_MASTER_SALT_LENGTH
;
MOZ_ASSERT
(
offset
=
=
sizeof
(
srtp_block
)
)
;
unsigned
char
*
write_key
;
unsigned
char
*
read_key
;
if
(
dtls
-
>
role
(
)
=
=
TransportLayerDtls
:
:
CLIENT
)
{
write_key
=
client_write_key
;
read_key
=
server_write_key
;
}
else
{
write_key
=
server_write_key
;
read_key
=
client_write_key
;
}
MOZ_ASSERT
(
!
info
.
send_srtp_
&
&
!
info
.
recv_srtp_
)
;
info
.
send_srtp_
=
SrtpFlow
:
:
Create
(
cipher_suite
false
write_key
SRTP_TOTAL_KEY_LENGTH
)
;
info
.
recv_srtp_
=
SrtpFlow
:
:
Create
(
cipher_suite
true
read_key
SRTP_TOTAL_KEY_LENGTH
)
;
if
(
!
info
.
send_srtp_
|
|
!
info
.
recv_srtp_
)
{
MOZ_MTLOG
(
ML_ERROR
"
Couldn
'
t
create
SRTP
flow
for
"
<
<
ToString
(
info
.
type_
)
)
;
info
.
state_
=
MP_CLOSED
;
UpdateRtcpMuxState
(
info
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_MTLOG
(
ML_INFO
"
Listening
for
"
<
<
ToString
(
info
.
type_
)
<
<
"
packets
received
on
"
<
<
static_cast
<
void
*
>
(
dtls
-
>
downward
(
)
)
)
;
switch
(
info
.
type_
)
{
case
RTP
:
dtls
-
>
downward
(
)
-
>
SignalPacketReceived
.
connect
(
this
&
MediaPipeline
:
:
RtpPacketReceived
)
;
break
;
case
RTCP
:
dtls
-
>
downward
(
)
-
>
SignalPacketReceived
.
connect
(
this
&
MediaPipeline
:
:
RtcpPacketReceived
)
;
break
;
case
MUX
:
dtls
-
>
downward
(
)
-
>
SignalPacketReceived
.
connect
(
this
&
MediaPipeline
:
:
PacketReceived
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
info
.
state_
=
MP_OPEN
;
UpdateRtcpMuxState
(
info
)
;
return
NS_OK
;
}
nsresult
MediaPipeline
:
:
TransportFailed_s
(
TransportInfo
&
info
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
info
.
state_
=
MP_CLOSED
;
UpdateRtcpMuxState
(
info
)
;
MOZ_MTLOG
(
ML_INFO
"
Transport
closed
for
flow
"
<
<
ToString
(
info
.
type_
)
)
;
NS_WARNING
(
"
MediaPipeline
Transport
failed
.
This
is
not
properly
cleaned
up
yet
"
)
;
return
NS_OK
;
}
void
MediaPipeline
:
:
UpdateRtcpMuxState
(
TransportInfo
&
info
)
{
if
(
info
.
type_
=
=
MUX
)
{
if
(
info
.
transport_
=
=
rtcp_
.
transport_
)
{
rtcp_
.
state_
=
info
.
state_
;
if
(
!
rtcp_
.
send_srtp_
)
{
rtcp_
.
send_srtp_
=
info
.
send_srtp_
;
rtcp_
.
recv_srtp_
=
info
.
recv_srtp_
;
}
}
}
}
nsresult
MediaPipeline
:
:
SendPacket
(
TransportFlow
*
flow
const
void
*
data
int
len
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
TransportLayerDtls
*
dtls
=
static_cast
<
TransportLayerDtls
*
>
(
flow
-
>
GetLayer
(
TransportLayerDtls
:
:
ID
(
)
)
)
;
MOZ_ASSERT
(
dtls
)
;
TransportResult
res
=
dtls
-
>
downward
(
)
-
>
SendPacket
(
static_cast
<
const
unsigned
char
*
>
(
data
)
len
)
;
if
(
res
!
=
len
)
{
if
(
res
=
=
TE_WOULDBLOCK
)
return
NS_OK
;
MOZ_MTLOG
(
ML_ERROR
"
Failed
write
on
stream
"
<
<
description_
)
;
return
NS_BASE_STREAM_CLOSED
;
}
return
NS_OK
;
}
void
MediaPipeline
:
:
increment_rtp_packets_sent
(
int32_t
bytes
)
{
+
+
rtp_packets_sent_
;
rtp_bytes_sent_
+
=
bytes
;
if
(
!
(
rtp_packets_sent_
%
100
)
)
{
MOZ_MTLOG
(
ML_INFO
"
RTP
sent
packet
count
for
"
<
<
description_
<
<
"
Pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
Flow
:
"
<
<
static_cast
<
void
*
>
(
rtp_
.
transport_
)
<
<
"
:
"
<
<
rtp_packets_sent_
<
<
"
(
"
<
<
rtp_bytes_sent_
<
<
"
bytes
)
"
)
;
}
}
void
MediaPipeline
:
:
increment_rtcp_packets_sent
(
)
{
+
+
rtcp_packets_sent_
;
if
(
!
(
rtcp_packets_sent_
%
100
)
)
{
MOZ_MTLOG
(
ML_INFO
"
RTCP
sent
packet
count
for
"
<
<
description_
<
<
"
Pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
Flow
:
"
<
<
static_cast
<
void
*
>
(
rtcp_
.
transport_
)
<
<
"
:
"
<
<
rtcp_packets_sent_
)
;
}
}
void
MediaPipeline
:
:
increment_rtp_packets_received
(
int32_t
bytes
)
{
+
+
rtp_packets_received_
;
rtp_bytes_received_
+
=
bytes
;
if
(
!
(
rtp_packets_received_
%
100
)
)
{
MOZ_MTLOG
(
ML_INFO
"
RTP
received
packet
count
for
"
<
<
description_
<
<
"
Pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
Flow
:
"
<
<
static_cast
<
void
*
>
(
rtp_
.
transport_
)
<
<
"
:
"
<
<
rtp_packets_received_
<
<
"
(
"
<
<
rtp_bytes_received_
<
<
"
bytes
)
"
)
;
}
}
void
MediaPipeline
:
:
increment_rtcp_packets_received
(
)
{
+
+
rtcp_packets_received_
;
if
(
!
(
rtcp_packets_received_
%
100
)
)
{
MOZ_MTLOG
(
ML_INFO
"
RTCP
received
packet
count
for
"
<
<
description_
<
<
"
Pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
Flow
:
"
<
<
static_cast
<
void
*
>
(
rtcp_
.
transport_
)
<
<
"
:
"
<
<
rtcp_packets_received_
)
;
}
}
void
MediaPipeline
:
:
RtpPacketReceived
(
TransportLayer
*
layer
const
unsigned
char
*
data
size_t
len
)
{
if
(
!
transport_
-
>
pipeline
(
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Discarding
incoming
packet
;
transport
disconnected
"
)
;
return
;
}
if
(
!
conduit_
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
media
disconnected
"
)
;
return
;
}
if
(
rtp_
.
state_
!
=
MP_OPEN
)
{
MOZ_MTLOG
(
ML_ERROR
"
Discarding
incoming
packet
;
pipeline
not
open
"
)
;
return
;
}
if
(
rtp_
.
transport_
-
>
state
(
)
!
=
TransportLayer
:
:
TS_OPEN
)
{
MOZ_MTLOG
(
ML_ERROR
"
Discarding
incoming
packet
;
transport
not
open
"
)
;
return
;
}
MOZ_ASSERT
(
rtp_
.
recv_srtp_
)
;
if
(
direction_
=
=
TRANSMIT
)
{
return
;
}
if
(
!
len
)
{
return
;
}
if
(
data
[
0
]
<
128
|
|
data
[
0
]
>
191
)
{
return
;
}
webrtc
:
:
RTPHeader
header
;
if
(
!
rtp_parser_
-
>
Parse
(
data
len
&
header
)
)
{
return
;
}
if
(
std
:
:
find
(
ssrcs_received_
.
begin
(
)
ssrcs_received_
.
end
(
)
header
.
ssrc
)
=
=
ssrcs_received_
.
end
(
)
)
{
ssrcs_received_
.
push_back
(
header
.
ssrc
)
;
}
if
(
filter_
&
&
!
filter_
-
>
Filter
(
header
)
)
{
return
;
}
ScopedDeletePtr
<
unsigned
char
>
inner_data
(
new
unsigned
char
[
len
]
)
;
memcpy
(
inner_data
data
len
)
;
int
out_len
=
0
;
nsresult
res
=
rtp_
.
recv_srtp_
-
>
UnprotectRtp
(
inner_data
len
len
&
out_len
)
;
if
(
!
NS_SUCCEEDED
(
res
)
)
{
char
tmp
[
16
]
;
PR_snprintf
(
tmp
sizeof
(
tmp
)
"
%
.
2x
%
.
2x
%
.
2x
%
.
2x
"
inner_data
[
0
]
inner_data
[
1
]
inner_data
[
2
]
inner_data
[
3
]
)
;
MOZ_MTLOG
(
ML_NOTICE
"
Error
unprotecting
RTP
in
"
<
<
description_
<
<
"
len
=
"
<
<
len
<
<
"
[
"
<
<
tmp
<
<
"
.
.
.
]
"
)
;
return
;
}
MOZ_MTLOG
(
ML_DEBUG
description_
<
<
"
received
RTP
packet
.
"
)
;
increment_rtp_packets_received
(
out_len
)
;
(
void
)
conduit_
-
>
ReceivedRTPPacket
(
inner_data
out_len
)
;
}
void
MediaPipeline
:
:
RtcpPacketReceived
(
TransportLayer
*
layer
const
unsigned
char
*
data
size_t
len
)
{
if
(
!
transport_
-
>
pipeline
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
transport
disconnected
"
)
;
return
;
}
if
(
!
conduit_
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
media
disconnected
"
)
;
return
;
}
if
(
rtcp_
.
state_
!
=
MP_OPEN
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
pipeline
not
open
"
)
;
return
;
}
if
(
rtcp_
.
transport_
-
>
state
(
)
!
=
TransportLayer
:
:
TS_OPEN
)
{
MOZ_MTLOG
(
ML_ERROR
"
Discarding
incoming
packet
;
transport
not
open
"
)
;
return
;
}
if
(
!
len
)
{
return
;
}
if
(
data
[
0
]
<
128
|
|
data
[
0
]
>
191
)
{
return
;
}
ScopedDeletePtr
<
unsigned
char
>
inner_data
(
new
unsigned
char
[
len
]
)
;
memcpy
(
inner_data
data
len
)
;
int
out_len
;
nsresult
res
=
rtcp_
.
recv_srtp_
-
>
UnprotectRtcp
(
inner_data
len
len
&
out_len
)
;
if
(
!
NS_SUCCEEDED
(
res
)
)
return
;
if
(
filter_
&
&
direction_
=
=
RECEIVE
)
{
if
(
!
filter_
-
>
FilterSenderReport
(
inner_data
out_len
)
)
{
MOZ_MTLOG
(
ML_NOTICE
"
Dropping
rtcp
packet
"
)
;
return
;
}
}
MOZ_MTLOG
(
ML_DEBUG
description_
<
<
"
received
RTCP
packet
.
"
)
;
increment_rtcp_packets_received
(
)
;
MOZ_ASSERT
(
rtcp_
.
recv_srtp_
)
;
(
void
)
conduit_
-
>
ReceivedRTCPPacket
(
inner_data
out_len
)
;
}
bool
MediaPipeline
:
:
IsRtp
(
const
unsigned
char
*
data
size_t
len
)
{
if
(
len
<
2
)
return
false
;
if
(
(
data
[
1
]
<
192
)
|
|
(
data
[
1
]
>
207
)
)
return
true
;
if
(
data
[
1
]
=
=
192
)
return
false
;
if
(
data
[
1
]
=
=
193
)
return
true
;
if
(
data
[
1
]
=
=
194
)
return
true
;
if
(
data
[
1
]
=
=
195
)
return
false
;
if
(
(
data
[
1
]
>
195
)
&
&
(
data
[
1
]
<
200
)
)
return
true
;
if
(
(
data
[
1
]
>
=
200
)
&
&
(
data
[
1
]
<
=
207
)
)
return
false
;
MOZ_ASSERT
(
false
)
;
return
true
;
}
void
MediaPipeline
:
:
PacketReceived
(
TransportLayer
*
layer
const
unsigned
char
*
data
size_t
len
)
{
if
(
!
transport_
-
>
pipeline
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
transport
disconnected
"
)
;
return
;
}
if
(
IsRtp
(
data
len
)
)
{
RtpPacketReceived
(
layer
data
len
)
;
}
else
{
RtcpPacketReceived
(
layer
data
len
)
;
}
}
nsresult
MediaPipelineTransmit
:
:
Init
(
)
{
AttachToTrack
(
track_id_
)
;
return
MediaPipeline
:
:
Init
(
)
;
}
void
MediaPipelineTransmit
:
:
AttachToTrack
(
const
std
:
:
string
&
track_id
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
description_
=
pc_
+
"
|
"
;
description_
+
=
conduit_
-
>
type
(
)
=
=
MediaSessionConduit
:
:
AUDIO
?
"
Transmit
audio
[
"
:
"
Transmit
video
[
"
;
description_
+
=
track_id
;
description_
+
=
"
]
"
;
MOZ_MTLOG
(
ML_DEBUG
"
Attaching
pipeline
to
stream
"
<
<
static_cast
<
void
*
>
(
stream_
)
<
<
"
conduit
type
=
"
<
<
(
conduit_
-
>
type
(
)
=
=
MediaSessionConduit
:
:
AUDIO
?
"
audio
"
:
"
video
"
)
)
;
stream_
-
>
AddListener
(
listener_
)
;
listener_
-
>
direct_connect_
=
domstream_
-
>
AddDirectListener
(
listener_
)
;
#
ifndef
MOZILLA_INTERNAL_API
listener_
-
>
SetEnabled
(
true
)
;
#
endif
}
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
void
MediaPipelineTransmit
:
:
UpdateSinkIdentity_m
(
nsIPrincipal
*
principal
const
PeerIdentity
*
sinkIdentity
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
bool
enableStream
=
principal
-
>
Subsumes
(
domstream_
-
>
GetPrincipal
(
)
)
;
if
(
!
enableStream
)
{
PeerIdentity
*
streamIdentity
=
domstream_
-
>
GetPeerIdentity
(
)
;
if
(
sinkIdentity
&
&
streamIdentity
)
{
enableStream
=
(
*
sinkIdentity
=
=
*
streamIdentity
)
;
}
}
listener_
-
>
SetEnabled
(
enableStream
)
;
}
#
endif
nsresult
MediaPipelineTransmit
:
:
TransportReady_s
(
TransportInfo
&
info
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
MediaPipeline
:
:
TransportReady_s
(
info
)
;
if
(
&
info
=
=
&
rtp_
)
{
listener_
-
>
SetActive
(
true
)
;
}
return
NS_OK
;
}
nsresult
MediaPipelineTransmit
:
:
ReplaceTrack
(
DOMMediaStream
*
domstream
const
std
:
:
string
&
track_id
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Reattaching
pipeline
"
<
<
description_
<
<
"
to
stream
"
<
<
static_cast
<
void
*
>
(
domstream
-
>
GetOwnedStream
(
)
)
<
<
"
track
"
<
<
track_id
<
<
"
conduit
type
=
"
<
<
(
conduit_
-
>
type
(
)
=
=
MediaSessionConduit
:
:
AUDIO
?
"
audio
"
:
"
video
"
)
)
;
if
(
domstream_
)
{
DetachMediaStream
(
)
;
}
domstream_
=
domstream
;
stream_
=
domstream
-
>
GetOwnedStream
(
)
;
listener_
-
>
UnsetTrackId
(
stream_
-
>
GraphImpl
(
)
)
;
track_id_
=
track_id
;
AttachToTrack
(
track_id
)
;
return
NS_OK
;
}
void
MediaPipeline
:
:
DisconnectTransport_s
(
TransportInfo
&
info
)
{
MOZ_ASSERT
(
info
.
transport_
)
;
ASSERT_ON_THREAD
(
sts_thread_
)
;
info
.
transport_
-
>
SignalStateChange
.
disconnect
(
this
)
;
TransportLayerDtls
*
dtls
=
static_cast
<
TransportLayerDtls
*
>
(
info
.
transport_
-
>
GetLayer
(
TransportLayerDtls
:
:
ID
(
)
)
)
;
MOZ_ASSERT
(
dtls
)
;
MOZ_ASSERT
(
dtls
-
>
downward
(
)
)
;
dtls
-
>
downward
(
)
-
>
SignalPacketReceived
.
disconnect
(
this
)
;
}
nsresult
MediaPipeline
:
:
ConnectTransport_s
(
TransportInfo
&
info
)
{
MOZ_ASSERT
(
info
.
transport_
)
;
ASSERT_ON_THREAD
(
sts_thread_
)
;
if
(
info
.
transport_
-
>
state
(
)
=
=
TransportLayer
:
:
TS_OPEN
)
{
nsresult
res
=
TransportReady_s
(
info
)
;
if
(
NS_FAILED
(
res
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Error
calling
TransportReady
(
)
;
res
=
"
<
<
static_cast
<
uint32_t
>
(
res
)
<
<
"
in
"
<
<
__FUNCTION__
)
;
return
res
;
}
}
else
if
(
info
.
transport_
-
>
state
(
)
=
=
TransportLayer
:
:
TS_ERROR
)
{
MOZ_MTLOG
(
ML_ERROR
ToString
(
info
.
type_
)
<
<
"
transport
is
already
in
error
state
"
)
;
TransportFailed_s
(
info
)
;
return
NS_ERROR_FAILURE
;
}
info
.
transport_
-
>
SignalStateChange
.
connect
(
this
&
MediaPipeline
:
:
StateChange
)
;
return
NS_OK
;
}
MediaPipeline
:
:
TransportInfo
*
MediaPipeline
:
:
GetTransportInfo_s
(
TransportFlow
*
flow
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
if
(
flow
=
=
rtp_
.
transport_
)
{
return
&
rtp_
;
}
if
(
flow
=
=
rtcp_
.
transport_
)
{
return
&
rtcp_
;
}
return
nullptr
;
}
nsresult
MediaPipeline
:
:
PipelineTransport
:
:
SendRtpPacket
(
const
void
*
data
int
len
)
{
nsAutoPtr
<
DataBuffer
>
buf
(
new
DataBuffer
(
static_cast
<
const
uint8_t
*
>
(
data
)
len
len
+
SRTP_MAX_EXPANSION
)
)
;
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
RefPtr
<
MediaPipeline
:
:
PipelineTransport
>
(
this
)
&
MediaPipeline
:
:
PipelineTransport
:
:
SendRtpRtcpPacket_s
buf
true
)
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
nsresult
MediaPipeline
:
:
PipelineTransport
:
:
SendRtpRtcpPacket_s
(
nsAutoPtr
<
DataBuffer
>
data
bool
is_rtp
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
if
(
!
pipeline_
)
{
return
NS_OK
;
}
TransportInfo
&
transport
=
is_rtp
?
pipeline_
-
>
rtp_
:
pipeline_
-
>
rtcp_
;
if
(
!
transport
.
send_srtp_
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Couldn
'
t
write
RTP
/
RTCP
packet
;
SRTP
not
set
up
yet
"
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
transport
.
transport_
)
;
NS_ENSURE_TRUE
(
transport
.
transport_
NS_ERROR_NULL_POINTER
)
;
MOZ_ASSERT
(
data
-
>
capacity
(
)
>
=
data
-
>
len
(
)
+
SRTP_MAX_EXPANSION
)
;
int
out_len
;
nsresult
res
;
if
(
is_rtp
)
{
res
=
transport
.
send_srtp_
-
>
ProtectRtp
(
data
-
>
data
(
)
data
-
>
len
(
)
data
-
>
capacity
(
)
&
out_len
)
;
}
else
{
res
=
transport
.
send_srtp_
-
>
ProtectRtcp
(
data
-
>
data
(
)
data
-
>
len
(
)
data
-
>
capacity
(
)
&
out_len
)
;
}
if
(
!
NS_SUCCEEDED
(
res
)
)
{
return
res
;
}
data
-
>
SetLength
(
out_len
)
;
MOZ_MTLOG
(
ML_DEBUG
pipeline_
-
>
description_
<
<
"
sending
"
<
<
(
is_rtp
?
"
RTP
"
:
"
RTCP
"
)
<
<
"
packet
"
)
;
if
(
is_rtp
)
{
pipeline_
-
>
increment_rtp_packets_sent
(
out_len
)
;
}
else
{
pipeline_
-
>
increment_rtcp_packets_sent
(
)
;
}
return
pipeline_
-
>
SendPacket
(
transport
.
transport_
data
-
>
data
(
)
out_len
)
;
}
nsresult
MediaPipeline
:
:
PipelineTransport
:
:
SendRtcpPacket
(
const
void
*
data
int
len
)
{
nsAutoPtr
<
DataBuffer
>
buf
(
new
DataBuffer
(
static_cast
<
const
uint8_t
*
>
(
data
)
len
len
+
SRTP_MAX_EXPANSION
)
)
;
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
RefPtr
<
MediaPipeline
:
:
PipelineTransport
>
(
this
)
&
MediaPipeline
:
:
PipelineTransport
:
:
SendRtpRtcpPacket_s
buf
false
)
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
UnsetTrackId
(
MediaStreamGraphImpl
*
graph
)
{
#
ifndef
USE_FAKE_MEDIA_STREAMS
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
PipelineListener
*
listener
)
:
ControlMessage
(
nullptr
)
listener_
(
listener
)
{
}
virtual
void
Run
(
)
override
{
listener_
-
>
UnsetTrackIdImpl
(
)
;
}
RefPtr
<
PipelineListener
>
listener_
;
}
;
graph
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
)
)
;
#
else
UnsetTrackIdImpl
(
)
;
#
endif
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
NotifyRealtimeData
(
MediaStreamGraph
*
graph
TrackID
tid
StreamTime
offset
uint32_t
events
const
MediaSegment
&
media
)
{
MOZ_MTLOG
(
ML_DEBUG
"
MediaPipeline
:
:
NotifyRealtimeData
(
)
"
)
;
NewData
(
graph
tid
offset
events
media
)
;
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
NotifyQueuedTrackChanges
(
MediaStreamGraph
*
graph
TrackID
tid
StreamTime
offset
uint32_t
events
const
MediaSegment
&
queued_media
MediaStream
*
aInputStream
TrackID
aInputTrackID
)
{
MOZ_MTLOG
(
ML_DEBUG
"
MediaPipeline
:
:
NotifyQueuedTrackChanges
(
)
"
)
;
if
(
!
direct_connect_
)
{
NewData
(
graph
tid
offset
events
queued_media
)
;
}
}
#
define
YSIZE
(
x
y
)
(
(
x
)
*
(
y
)
)
#
define
CRSIZE
(
x
y
)
(
(
(
(
x
)
+
1
)
>
>
1
)
*
(
(
(
y
)
+
1
)
>
>
1
)
)
#
define
I420SIZE
(
x
y
)
(
YSIZE
(
(
x
)
(
y
)
)
+
2
*
CRSIZE
(
(
x
)
(
y
)
)
)
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
NewData
(
MediaStreamGraph
*
graph
TrackID
tid
StreamTime
offset
uint32_t
events
const
MediaSegment
&
media
)
{
if
(
!
active_
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
packets
because
transport
not
ready
"
)
;
return
;
}
if
(
conduit_
-
>
type
(
)
!
=
(
media
.
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
?
MediaSessionConduit
:
:
AUDIO
:
MediaSessionConduit
:
:
VIDEO
)
)
{
return
;
}
if
(
track_id_
=
=
TRACK_INVALID
)
{
MutexAutoLock
lock
(
mMutex
)
;
track_id_
=
track_id_external_
=
tid
;
}
else
if
(
tid
!
=
track_id_
)
{
return
;
}
if
(
media
.
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
)
{
AudioSegment
*
audio
=
const_cast
<
AudioSegment
*
>
(
static_cast
<
const
AudioSegment
*
>
(
&
media
)
)
;
AudioSegment
:
:
ChunkIterator
iter
(
*
audio
)
;
while
(
!
iter
.
IsEnded
(
)
)
{
TrackRate
rate
;
#
ifdef
USE_FAKE_MEDIA_STREAMS
rate
=
Fake_MediaStream
:
:
GraphRate
(
)
;
#
else
rate
=
graph
-
>
GraphRate
(
)
;
#
endif
ProcessAudioChunk
(
static_cast
<
AudioSessionConduit
*
>
(
conduit_
.
get
(
)
)
rate
*
iter
)
;
iter
.
Next
(
)
;
}
}
else
if
(
media
.
GetType
(
)
=
=
MediaSegment
:
:
VIDEO
)
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
VideoSegment
*
video
=
const_cast
<
VideoSegment
*
>
(
static_cast
<
const
VideoSegment
*
>
(
&
media
)
)
;
VideoSegment
:
:
ChunkIterator
iter
(
*
video
)
;
while
(
!
iter
.
IsEnded
(
)
)
{
ProcessVideoChunk
(
static_cast
<
VideoSessionConduit
*
>
(
conduit_
.
get
(
)
)
*
iter
)
;
iter
.
Next
(
)
;
}
#
endif
}
else
{
}
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
ProcessAudioChunk
(
AudioSessionConduit
*
conduit
TrackRate
rate
AudioChunk
&
chunk
)
{
uint32_t
outputChannels
=
chunk
.
ChannelCount
(
)
=
=
1
?
1
:
2
;
const
int16_t
*
samples
=
nullptr
;
UniquePtr
<
int16_t
[
]
>
convertedSamples
;
if
(
!
enabled_
)
{
chunk
.
mBufferFormat
=
AUDIO_FORMAT_SILENCE
;
}
if
(
outputChannels
=
=
1
&
&
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_S16
)
{
samples
=
chunk
.
ChannelData
<
int16_t
>
(
)
.
Elements
(
)
[
0
]
;
}
else
{
convertedSamples
=
MakeUnique
<
int16_t
[
]
>
(
chunk
.
mDuration
*
outputChannels
)
;
switch
(
chunk
.
mBufferFormat
)
{
case
AUDIO_FORMAT_FLOAT32
:
DownmixAndInterleave
(
chunk
.
ChannelData
<
float
>
(
)
chunk
.
mDuration
chunk
.
mVolume
outputChannels
convertedSamples
.
get
(
)
)
;
break
;
case
AUDIO_FORMAT_S16
:
DownmixAndInterleave
(
chunk
.
ChannelData
<
int16_t
>
(
)
chunk
.
mDuration
chunk
.
mVolume
outputChannels
convertedSamples
.
get
(
)
)
;
break
;
case
AUDIO_FORMAT_SILENCE
:
PodZero
(
convertedSamples
.
get
(
)
chunk
.
mDuration
*
outputChannels
)
;
break
;
}
samples
=
convertedSamples
.
get
(
)
;
}
MOZ_ASSERT
(
!
(
rate
%
100
)
)
;
uint32_t
audio_10ms
=
rate
/
100
;
if
(
!
packetizer_
|
|
packetizer_
-
>
PacketSize
(
)
!
=
audio_10ms
|
|
packetizer_
-
>
Channels
(
)
!
=
outputChannels
)
{
packetizer_
=
new
AudioPacketizer
<
int16_t
int16_t
>
(
audio_10ms
outputChannels
)
;
}
packetizer_
-
>
Input
(
samples
chunk
.
mDuration
)
;
while
(
packetizer_
-
>
PacketsAvailable
(
)
)
{
uint32_t
samplesPerPacket
=
packetizer_
-
>
PacketSize
(
)
*
packetizer_
-
>
Channels
(
)
;
const
size_t
AUDIO_SAMPLE_BUFFER_MAX
=
1920
;
int16_t
packet
[
AUDIO_SAMPLE_BUFFER_MAX
]
;
packetizer_
-
>
Output
(
packet
)
;
conduit
-
>
SendAudioFrame
(
packet
samplesPerPacket
rate
0
)
;
}
}
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
ProcessVideoChunk
(
VideoSessionConduit
*
conduit
VideoChunk
&
chunk
)
{
Image
*
img
=
chunk
.
mFrame
.
GetImage
(
)
;
if
(
!
img
)
{
return
;
}
if
(
!
enabled_
|
|
chunk
.
mFrame
.
GetForceBlack
(
)
)
{
IntSize
size
=
img
-
>
GetSize
(
)
;
uint32_t
yPlaneLen
=
YSIZE
(
size
.
width
size
.
height
)
;
uint32_t
cbcrPlaneLen
=
2
*
CRSIZE
(
size
.
width
size
.
height
)
;
uint32_t
length
=
yPlaneLen
+
cbcrPlaneLen
;
auto
pixelData
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
length
)
;
if
(
pixelData
)
{
memset
(
pixelData
.
get
(
)
0x10
yPlaneLen
)
;
memset
(
pixelData
.
get
(
)
+
yPlaneLen
0x80
cbcrPlaneLen
)
;
MOZ_MTLOG
(
ML_DEBUG
"
Sending
a
black
video
frame
"
)
;
conduit
-
>
SendVideoFrame
(
pixelData
.
get
(
)
length
size
.
width
size
.
height
mozilla
:
:
kVideoI420
0
)
;
}
return
;
}
int32_t
serial
=
img
-
>
GetSerial
(
)
;
if
(
serial
=
=
last_img_
)
{
return
;
}
last_img_
=
serial
;
ImageFormat
format
=
img
-
>
GetFormat
(
)
;
#
ifdef
WEBRTC_GONK
GrallocImage
*
nativeImage
=
img
-
>
AsGrallocImage
(
)
;
if
(
nativeImage
)
{
android
:
:
sp
<
android
:
:
GraphicBuffer
>
graphicBuffer
=
nativeImage
-
>
GetGraphicBuffer
(
)
;
int
pixelFormat
=
graphicBuffer
-
>
getPixelFormat
(
)
;
mozilla
:
:
VideoType
destFormat
;
switch
(
pixelFormat
)
{
case
HAL_PIXEL_FORMAT_YV12
:
destFormat
=
mozilla
:
:
kVideoYV12
;
break
;
case
GrallocImage
:
:
HAL_PIXEL_FORMAT_YCbCr_420_SP
:
destFormat
=
mozilla
:
:
kVideoNV21
;
break
;
case
GrallocImage
:
:
HAL_PIXEL_FORMAT_YCbCr_420_P
:
destFormat
=
mozilla
:
:
kVideoI420
;
break
;
default
:
MOZ_MTLOG
(
ML_ERROR
"
Un
-
handled
GRALLOC
buffer
type
:
"
<
<
pixelFormat
)
;
MOZ_CRASH
(
)
;
}
void
*
basePtr
;
graphicBuffer
-
>
lock
(
android
:
:
GraphicBuffer
:
:
USAGE_SW_READ_MASK
&
basePtr
)
;
uint32_t
width
=
graphicBuffer
-
>
getWidth
(
)
;
uint32_t
height
=
graphicBuffer
-
>
getHeight
(
)
;
if
(
destFormat
!
=
mozilla
:
:
kVideoI420
)
{
unsigned
char
*
video_frame
=
static_cast
<
unsigned
char
*
>
(
basePtr
)
;
webrtc
:
:
I420VideoFrame
i420_frame
;
int
stride_y
=
width
;
int
stride_uv
=
(
width
+
1
)
/
2
;
int
target_width
=
width
;
int
target_height
=
height
;
if
(
i420_frame
.
CreateEmptyFrame
(
target_width
abs
(
target_height
)
stride_y
stride_uv
stride_uv
)
<
0
)
{
MOZ_ASSERT
(
false
"
Can
'
t
allocate
empty
i420frame
"
)
;
return
;
}
webrtc
:
:
VideoType
commonVideoType
=
webrtc
:
:
RawVideoTypeToCommonVideoVideoType
(
static_cast
<
webrtc
:
:
RawVideoType
>
(
(
int
)
destFormat
)
)
;
if
(
ConvertToI420
(
commonVideoType
video_frame
0
0
width
height
I420SIZE
(
width
height
)
webrtc
:
:
kVideoRotation_0
&
i420_frame
)
)
{
MOZ_ASSERT
(
false
"
Can
'
t
convert
video
type
for
sending
to
I420
"
)
;
return
;
}
i420_frame
.
set_ntp_time_ms
(
0
)
;
conduit
-
>
SendVideoFrame
(
i420_frame
)
;
}
else
{
conduit
-
>
SendVideoFrame
(
static_cast
<
unsigned
char
*
>
(
basePtr
)
I420SIZE
(
width
height
)
width
height
destFormat
0
)
;
}
graphicBuffer
-
>
unlock
(
)
;
return
;
}
else
#
endif
if
(
format
=
=
ImageFormat
:
:
PLANAR_YCBCR
)
{
PlanarYCbCrImage
*
yuv
=
const_cast
<
PlanarYCbCrImage
*
>
(
static_cast
<
const
PlanarYCbCrImage
*
>
(
img
)
)
;
const
PlanarYCbCrData
*
data
=
yuv
-
>
GetData
(
)
;
if
(
data
)
{
uint8_t
*
y
=
data
-
>
mYChannel
;
uint8_t
*
cb
=
data
-
>
mCbChannel
;
uint8_t
*
cr
=
data
-
>
mCrChannel
;
uint32_t
width
=
yuv
-
>
GetSize
(
)
.
width
;
uint32_t
height
=
yuv
-
>
GetSize
(
)
.
height
;
uint32_t
length
=
yuv
-
>
GetDataSize
(
)
;
if
(
cb
=
=
(
y
+
YSIZE
(
width
height
)
)
&
&
cr
=
=
(
cb
+
CRSIZE
(
width
height
)
)
&
&
length
>
=
I420SIZE
(
width
height
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Sending
an
I420
video
frame
"
)
;
conduit
-
>
SendVideoFrame
(
y
I420SIZE
(
width
height
)
width
height
mozilla
:
:
kVideoI420
0
)
;
return
;
}
else
{
MOZ_MTLOG
(
ML_ERROR
"
Unsupported
PlanarYCbCrImage
format
:
"
"
width
=
"
<
<
width
<
<
"
height
=
"
<
<
height
<
<
"
y
=
"
<
<
y
<
<
"
\
n
Expected
:
cb
=
y
+
"
<
<
YSIZE
(
width
height
)
<
<
"
cr
=
y
+
"
<
<
YSIZE
(
width
height
)
+
CRSIZE
(
width
height
)
<
<
"
\
n
Observed
:
cb
=
y
+
"
<
<
cb
-
y
<
<
"
cr
=
y
+
"
<
<
cr
-
y
<
<
"
\
n
ystride
=
"
<
<
data
-
>
mYStride
<
<
"
yskip
=
"
<
<
data
-
>
mYSkip
<
<
"
\
n
cbcrstride
=
"
<
<
data
-
>
mCbCrStride
<
<
"
cbskip
=
"
<
<
data
-
>
mCbSkip
<
<
"
crskip
=
"
<
<
data
-
>
mCrSkip
<
<
"
\
n
ywidth
=
"
<
<
data
-
>
mYSize
.
width
<
<
"
yheight
=
"
<
<
data
-
>
mYSize
.
height
<
<
"
\
n
cbcrwidth
=
"
<
<
data
-
>
mCbCrSize
.
width
<
<
"
cbcrheight
=
"
<
<
data
-
>
mCbCrSize
.
height
)
;
NS_ASSERTION
(
false
"
Unsupported
PlanarYCbCrImage
format
"
)
;
}
}
}
RefPtr
<
SourceSurface
>
surf
=
img
-
>
GetAsSourceSurface
(
)
;
if
(
!
surf
)
{
MOZ_MTLOG
(
ML_ERROR
"
Getting
surface
from
"
<
<
Stringify
(
format
)
<
<
"
image
failed
"
)
;
return
;
}
RefPtr
<
DataSourceSurface
>
data
=
surf
-
>
GetDataSurface
(
)
;
if
(
!
data
)
{
MOZ_MTLOG
(
ML_ERROR
"
Getting
data
surface
from
"
<
<
Stringify
(
format
)
<
<
"
image
with
"
<
<
Stringify
(
surf
-
>
GetType
(
)
)
<
<
"
(
"
<
<
Stringify
(
surf
-
>
GetFormat
(
)
)
<
<
"
)
surface
failed
"
)
;
return
;
}
IntSize
size
=
img
-
>
GetSize
(
)
;
int
half_width
=
(
size
.
width
+
1
)
>
>
1
;
int
half_height
=
(
size
.
height
+
1
)
>
>
1
;
int
c_size
=
half_width
*
half_height
;
int
buffer_size
=
YSIZE
(
size
.
width
size
.
height
)
+
2
*
c_size
;
auto
yuv_scoped
=
MakeUniqueFallible
<
uint8
[
]
>
(
buffer_size
)
;
if
(
!
yuv_scoped
)
return
;
uint8
*
yuv
=
yuv_scoped
.
get
(
)
;
DataSourceSurface
:
:
ScopedMap
map
(
data
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Reading
DataSourceSurface
from
"
<
<
Stringify
(
format
)
<
<
"
image
with
"
<
<
Stringify
(
surf
-
>
GetType
(
)
)
<
<
"
(
"
<
<
Stringify
(
surf
-
>
GetFormat
(
)
)
<
<
"
)
surface
failed
"
)
;
return
;
}
int
rv
;
int
cb_offset
=
YSIZE
(
size
.
width
size
.
height
)
;
int
cr_offset
=
cb_offset
+
c_size
;
switch
(
surf
-
>
GetFormat
(
)
)
{
case
SurfaceFormat
:
:
B8G8R8A8
:
case
SurfaceFormat
:
:
B8G8R8X8
:
rv
=
libyuv
:
:
ARGBToI420
(
static_cast
<
uint8
*
>
(
map
.
GetData
(
)
)
map
.
GetStride
(
)
yuv
size
.
width
yuv
+
cb_offset
half_width
yuv
+
cr_offset
half_width
size
.
width
size
.
height
)
;
break
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
rv
=
libyuv
:
:
RGB565ToI420
(
static_cast
<
uint8
*
>
(
map
.
GetData
(
)
)
map
.
GetStride
(
)
yuv
size
.
width
yuv
+
cb_offset
half_width
yuv
+
cr_offset
half_width
size
.
width
size
.
height
)
;
break
;
default
:
MOZ_MTLOG
(
ML_ERROR
"
Unsupported
RGB
video
format
"
<
<
Stringify
(
surf
-
>
GetFormat
(
)
)
)
;
MOZ_ASSERT
(
PR_FALSE
)
;
return
;
}
if
(
rv
!
=
0
)
{
MOZ_MTLOG
(
ML_ERROR
Stringify
(
surf
-
>
GetFormat
(
)
)
<
<
"
to
I420
conversion
failed
"
)
;
return
;
}
MOZ_MTLOG
(
ML_DEBUG
"
Sending
an
I420
video
frame
converted
from
"
<
<
Stringify
(
surf
-
>
GetFormat
(
)
)
)
;
conduit
-
>
SendVideoFrame
(
yuv
buffer_size
size
.
width
size
.
height
mozilla
:
:
kVideoI420
0
)
;
}
#
endif
nsresult
MediaPipelineReceiveAudio
:
:
Init
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
MOZ_MTLOG
(
ML_DEBUG
__FUNCTION__
)
;
description_
=
pc_
+
"
|
Receive
audio
[
"
;
description_
+
=
track_id_
;
description_
+
=
"
]
"
;
listener_
-
>
AddSelf
(
new
AudioSegment
(
)
)
;
return
MediaPipelineReceive
:
:
Init
(
)
;
}
static
void
AddTrackAndListener
(
MediaStream
*
source
TrackID
track_id
TrackRate
track_rate
MediaStreamListener
*
listener
MediaSegment
*
segment
const
RefPtr
<
TrackAddedCallback
>
&
completed
bool
queue_track
)
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaStream
*
stream
TrackID
track
TrackRate
rate
MediaSegment
*
segment
MediaStreamListener
*
listener
const
RefPtr
<
TrackAddedCallback
>
&
completed
)
:
ControlMessage
(
stream
)
track_id_
(
track
)
track_rate_
(
rate
)
segment_
(
segment
)
listener_
(
listener
)
completed_
(
completed
)
{
}
virtual
void
Run
(
)
override
{
StreamTime
current_end
=
mStream
-
>
GetBufferEnd
(
)
;
TrackTicks
current_ticks
=
mStream
-
>
TimeToTicksRoundUp
(
track_rate_
current_end
)
;
mStream
-
>
AddListenerImpl
(
listener_
.
forget
(
)
)
;
if
(
current_end
!
=
0L
)
{
MOZ_MTLOG
(
ML_DEBUG
"
added
track
"
<
<
current_end
<
<
"
-
>
"
<
<
mStream
-
>
StreamTimeToSeconds
(
current_end
)
)
;
}
segment_
-
>
AppendNullData
(
current_ticks
)
;
if
(
segment_
-
>
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
)
{
mStream
-
>
AsSourceStream
(
)
-
>
AddAudioTrack
(
track_id_
track_rate_
current_ticks
static_cast
<
AudioSegment
*
>
(
segment_
.
forget
(
)
)
)
;
}
else
{
NS_ASSERTION
(
mStream
-
>
GraphRate
(
)
=
=
track_rate_
"
Rate
mismatch
"
)
;
mStream
-
>
AsSourceStream
(
)
-
>
AddTrack
(
track_id_
current_ticks
segment_
.
forget
(
)
)
;
}
completed_
-
>
TrackAdded
(
current_ticks
)
;
}
private
:
TrackID
track_id_
;
TrackRate
track_rate_
;
nsAutoPtr
<
MediaSegment
>
segment_
;
RefPtr
<
MediaStreamListener
>
listener_
;
const
RefPtr
<
TrackAddedCallback
>
completed_
;
}
;
MOZ_ASSERT
(
listener
)
;
if
(
!
queue_track
)
{
source
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
source
track_id
track_rate
segment
listener
completed
)
)
;
MOZ_MTLOG
(
ML_INFO
"
Dispatched
track
-
add
for
track
id
"
<
<
track_id
<
<
"
on
stream
"
<
<
source
)
;
return
;
}
#
endif
source
-
>
AddListener
(
listener
)
;
if
(
segment
-
>
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
)
{
source
-
>
AsSourceStream
(
)
-
>
AddAudioTrack
(
track_id
track_rate
0
static_cast
<
AudioSegment
*
>
(
segment
)
SourceMediaStream
:
:
ADDTRACK_QUEUED
)
;
}
else
{
source
-
>
AsSourceStream
(
)
-
>
AddTrack
(
track_id
0
segment
SourceMediaStream
:
:
ADDTRACK_QUEUED
)
;
}
MOZ_MTLOG
(
ML_INFO
"
Queued
track
-
add
for
track
id
"
<
<
track_id
<
<
"
on
MediaStream
"
<
<
source
)
;
}
void
GenericReceiveListener
:
:
AddSelf
(
MediaSegment
*
segment
)
{
RefPtr
<
TrackAddedCallback
>
callback
=
new
GenericReceiveCallback
(
this
)
;
AddTrackAndListener
(
source_
track_id_
track_rate_
this
segment
callback
queue_track_
)
;
}
MediaPipelineReceiveAudio
:
:
PipelineListener
:
:
PipelineListener
(
SourceMediaStream
*
source
TrackID
track_id
const
RefPtr
<
MediaSessionConduit
>
&
conduit
bool
queue_track
)
:
GenericReceiveListener
(
source
track_id
DEFAULT_SAMPLE_RATE
queue_track
)
conduit_
(
conduit
)
{
MOZ_ASSERT
(
track_rate_
%
100
=
=
0
)
;
}
void
MediaPipelineReceiveAudio
:
:
PipelineListener
:
:
NotifyPull
(
MediaStreamGraph
*
graph
StreamTime
desired_time
)
{
MOZ_ASSERT
(
source_
)
;
if
(
!
source_
)
{
MOZ_MTLOG
(
ML_ERROR
"
NotifyPull
(
)
called
from
a
non
-
SourceMediaStream
"
)
;
return
;
}
while
(
source_
-
>
TicksToTimeRoundDown
(
track_rate_
played_ticks_
)
<
desired_time
)
{
const
size_t
AUDIO_SAMPLE_BUFFER_MAX
=
1920
;
MOZ_ASSERT
(
(
track_rate_
/
100
)
*
sizeof
(
uint16_t
)
*
2
<
=
AUDIO_SAMPLE_BUFFER_MAX
)
;
int16_t
scratch_buffer
[
AUDIO_SAMPLE_BUFFER_MAX
]
;
int
samples_length
;
MediaConduitErrorCode
err
=
static_cast
<
AudioSessionConduit
*
>
(
conduit_
.
get
(
)
)
-
>
GetAudioFrame
(
scratch_buffer
track_rate_
0
samples_length
)
;
if
(
err
!
=
kMediaConduitNoError
)
{
MOZ_MTLOG
(
ML_ERROR
"
Audio
conduit
failed
(
"
<
<
err
<
<
"
)
to
return
data
"
<
<
played_ticks_
<
<
"
(
desired
"
<
<
desired_time
<
<
"
-
>
"
<
<
source_
-
>
StreamTimeToSeconds
(
desired_time
)
<
<
"
)
"
)
;
samples_length
=
track_rate_
/
100
;
PodArrayZero
(
scratch_buffer
)
;
}
MOZ_ASSERT
(
samples_length
*
sizeof
(
uint16_t
)
<
AUDIO_SAMPLE_BUFFER_MAX
)
;
MOZ_MTLOG
(
ML_DEBUG
"
Audio
conduit
returned
buffer
of
length
"
<
<
samples_length
)
;
RefPtr
<
SharedBuffer
>
samples
=
SharedBuffer
:
:
Create
(
samples_length
*
sizeof
(
uint16_t
)
)
;
int16_t
*
samples_data
=
static_cast
<
int16_t
*
>
(
samples
-
>
Data
(
)
)
;
AudioSegment
segment
;
uint32_t
channelCount
=
samples_length
/
(
track_rate_
/
100
)
;
AutoTArray
<
int16_t
*
2
>
channels
;
AutoTArray
<
const
int16_t
*
2
>
outputChannels
;
size_t
frames
=
samples_length
/
channelCount
;
channels
.
SetLength
(
channelCount
)
;
size_t
offset
=
0
;
for
(
size_t
i
=
0
;
i
<
channelCount
;
i
+
+
)
{
channels
[
i
]
=
samples_data
+
offset
;
offset
+
=
frames
;
}
DeinterleaveAndConvertBuffer
(
scratch_buffer
frames
channelCount
channels
.
Elements
(
)
)
;
outputChannels
.
AppendElements
(
channels
)
;
segment
.
AppendFrames
(
samples
.
forget
(
)
outputChannels
frames
)
;
if
(
source_
-
>
AppendToTrack
(
track_id_
&
segment
)
)
{
played_ticks_
+
=
frames
;
}
else
{
MOZ_MTLOG
(
ML_ERROR
"
AppendToTrack
failed
"
)
;
return
;
}
}
}
nsresult
MediaPipelineReceiveVideo
:
:
Init
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
MOZ_MTLOG
(
ML_DEBUG
__FUNCTION__
)
;
description_
=
pc_
+
"
|
Receive
video
[
"
;
description_
+
=
track_id_
;
description_
+
=
"
]
"
;
#
if
defined
(
MOZILLA_INTERNAL_API
)
listener_
-
>
AddSelf
(
new
VideoSegment
(
)
)
;
#
endif
static_cast
<
VideoSessionConduit
*
>
(
conduit_
.
get
(
)
)
-
>
AttachRenderer
(
renderer_
)
;
return
MediaPipelineReceive
:
:
Init
(
)
;
}
MediaPipelineReceiveVideo
:
:
PipelineListener
:
:
PipelineListener
(
SourceMediaStream
*
source
TrackID
track_id
bool
queue_track
)
:
GenericReceiveListener
(
source
track_id
source
-
>
GraphRate
(
)
queue_track
)
width_
(
640
)
height_
(
480
)
#
if
defined
(
MOZILLA_XPCOMRT_API
)
image_
(
new
SimpleImageBuffer
)
#
elif
defined
(
MOZILLA_INTERNAL_API
)
image_container_
(
)
image_
(
)
#
endif
monitor_
(
"
Video
PipelineListener
"
)
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
image_container_
=
LayerManager
:
:
CreateImageContainer
(
)
;
#
endif
}
void
MediaPipelineReceiveVideo
:
:
PipelineListener
:
:
RenderVideoFrame
(
const
unsigned
char
*
buffer
size_t
buffer_size
uint32_t
time_stamp
int64_t
render_time
const
RefPtr
<
Image
>
&
video_image
)
{
RenderVideoFrame
(
buffer
buffer_size
width_
(
width_
+
1
)
>
>
1
time_stamp
render_time
video_image
)
;
}
void
MediaPipelineReceiveVideo
:
:
PipelineListener
:
:
RenderVideoFrame
(
const
unsigned
char
*
buffer
size_t
buffer_size
uint32_t
y_stride
uint32_t
cbcr_stride
uint32_t
time_stamp
int64_t
render_time
const
RefPtr
<
Image
>
&
video_image
)
{
#
ifdef
MOZILLA_INTERNAL_API
ReentrantMonitorAutoEnter
enter
(
monitor_
)
;
#
endif
#
if
defined
(
MOZILLA_XPCOMRT_API
)
if
(
buffer
)
{
image_
-
>
SetImage
(
buffer
buffer_size
width_
height_
)
;
}
#
elif
defined
(
MOZILLA_INTERNAL_API
)
if
(
buffer
)
{
#
ifdef
MOZ_WIDGET_GONK
RefPtr
<
PlanarYCbCrImage
>
yuvImage
=
new
GrallocImage
(
)
;
#
else
RefPtr
<
PlanarYCbCrImage
>
yuvImage
=
image_container_
-
>
CreatePlanarYCbCrImage
(
)
;
#
endif
uint8_t
*
frame
=
const_cast
<
uint8_t
*
>
(
static_cast
<
const
uint8_t
*
>
(
buffer
)
)
;
PlanarYCbCrData
yuvData
;
yuvData
.
mYChannel
=
frame
;
yuvData
.
mYSize
=
IntSize
(
y_stride
height_
)
;
yuvData
.
mYStride
=
y_stride
;
yuvData
.
mCbCrStride
=
cbcr_stride
;
yuvData
.
mCbChannel
=
frame
+
height_
*
yuvData
.
mYStride
;
yuvData
.
mCrChannel
=
yuvData
.
mCbChannel
+
(
(
height_
+
1
)
>
>
1
)
*
yuvData
.
mCbCrStride
;
yuvData
.
mCbCrSize
=
IntSize
(
yuvData
.
mCbCrStride
(
height_
+
1
)
>
>
1
)
;
yuvData
.
mPicX
=
0
;
yuvData
.
mPicY
=
0
;
yuvData
.
mPicSize
=
IntSize
(
width_
height_
)
;
yuvData
.
mStereoMode
=
StereoMode
:
:
MONO
;
if
(
!
yuvImage
-
>
SetData
(
yuvData
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
image_
=
yuvImage
;
}
#
ifdef
WEBRTC_GONK
else
{
MOZ_ASSERT
(
video_image
)
;
image_
=
video_image
;
}
#
endif
#
endif
}
void
MediaPipelineReceiveVideo
:
:
PipelineListener
:
:
NotifyPull
(
MediaStreamGraph
*
graph
StreamTime
desired_time
)
{
ReentrantMonitorAutoEnter
enter
(
monitor_
)
;
#
if
defined
(
MOZILLA_XPCOMRT_API
)
RefPtr
<
SimpleImageBuffer
>
image
=
image_
;
#
elif
defined
(
MOZILLA_INTERNAL_API
)
RefPtr
<
Image
>
image
=
image_
;
MOZ_ASSERT
(
track_rate_
=
=
source_
-
>
GraphRate
(
)
)
;
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
StreamTime
delta
=
desired_time
-
played_ticks_
;
if
(
delta
>
0
)
{
VideoSegment
segment
;
segment
.
AppendFrame
(
image
.
forget
(
)
delta
IntSize
(
width_
height_
)
)
;
if
(
source_
-
>
AppendToTrack
(
track_id_
&
segment
)
)
{
played_ticks_
=
desired_time
;
}
else
{
MOZ_MTLOG
(
ML_ERROR
"
AppendToTrack
failed
"
)
;
return
;
}
}
#
endif
#
if
defined
(
MOZILLA_XPCOMRT_API
)
image_
-
>
SetImage
(
nullptr
0
0
0
)
;
#
endif
}
}
