#
include
"
MediaPipeline
.
h
"
#
ifndef
USE_FAKE_MEDIA_STREAMS
#
include
"
MediaStreamGraphImpl
.
h
"
#
endif
#
include
<
math
.
h
>
#
include
"
nspr
.
h
"
#
include
"
srtp
.
h
"
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
#
include
"
VideoSegment
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
MediaStreamTrack
.
h
"
#
include
"
MediaStreamListener
.
h
"
#
include
"
MediaStreamVideoSink
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
VideoStreamTrack
.
h
"
#
ifdef
WEBRTC_GONK
#
include
"
GrallocImages
.
h
"
#
include
"
mozilla
/
layers
/
GrallocTextureClient
.
h
"
#
endif
#
endif
#
include
"
nsError
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
MediaPipelineFilter
.
h
"
#
include
"
databuffer
.
h
"
#
include
"
transportflow
.
h
"
#
include
"
transportlayer
.
h
"
#
include
"
transportlayerdtls
.
h
"
#
include
"
transportlayerice
.
h
"
#
include
"
runnable_utils
.
h
"
#
include
"
libyuv
/
convert
.
h
"
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
#
include
"
mozilla
/
PeerIdentity
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
endif
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
webrtc
/
common_types
.
h
"
#
include
"
webrtc
/
common_video
/
interface
/
native_handle
.
h
"
#
include
"
webrtc
/
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
include
"
webrtc
/
video_engine
/
include
/
vie_errors
.
h
"
#
include
"
logging
.
h
"
#
define
AUDIO_SAMPLE_BUFFER_MAX
480
*
2
*
2
static_assert
(
(
WEBRTC_DEFAULT_SAMPLE_RATE
/
100
)
*
sizeof
(
uint16_t
)
*
2
<
=
AUDIO_SAMPLE_BUFFER_MAX
"
AUDIO_SAMPLE_BUFFER_MAX
is
not
large
enough
"
)
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
MOZ_MTLOG_MODULE
(
"
mediapipeline
"
)
namespace
mozilla
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
class
VideoConverterListener
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VideoConverterListener
)
virtual
void
OnVideoFrameConverted
(
unsigned
char
*
aVideoFrame
unsigned
int
aVideoFrameLength
unsigned
short
aWidth
unsigned
short
aHeight
VideoType
aVideoType
uint64_t
aCaptureTime
)
=
0
;
virtual
void
OnVideoFrameConverted
(
webrtc
:
:
I420VideoFrame
&
aVideoFrame
)
=
0
;
protected
:
virtual
~
VideoConverterListener
(
)
{
}
}
;
#
define
YSIZE
(
x
y
)
(
(
x
)
*
(
y
)
)
#
define
CRSIZE
(
x
y
)
(
(
(
(
x
)
+
1
)
>
>
1
)
*
(
(
(
y
)
+
1
)
>
>
1
)
)
#
define
I420SIZE
(
x
y
)
(
YSIZE
(
(
x
)
(
y
)
)
+
2
*
CRSIZE
(
(
x
)
(
y
)
)
)
class
VideoFrameConverter
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VideoFrameConverter
)
VideoFrameConverter
(
)
:
mLength
(
0
)
last_img_
(
-
1
)
disabled_frame_sent_
(
false
)
#
ifdef
DEBUG
mThrottleCount
(
0
)
mThrottleRecord
(
0
)
#
endif
mMutex
(
"
VideoFrameConverter
"
)
{
MOZ_COUNT_CTOR
(
VideoFrameConverter
)
;
RefPtr
<
SharedThreadPool
>
pool
=
SharedThreadPool
:
:
Get
(
NS_LITERAL_CSTRING
(
"
VideoFrameConverter
"
)
)
;
mTaskQueue
=
MakeAndAddRef
<
TaskQueue
>
(
pool
.
forget
(
)
)
;
}
void
QueueVideoChunk
(
VideoChunk
&
aChunk
bool
aForceBlack
)
{
if
(
aChunk
.
IsNull
(
)
)
{
return
;
}
int32_t
serial
=
aChunk
.
mFrame
.
GetImage
(
)
-
>
GetSerial
(
)
;
if
(
serial
=
=
last_img_
)
{
return
;
}
last_img_
=
serial
;
const
int32_t
queueThrottlingLimit
=
1
;
if
(
mLength
>
queueThrottlingLimit
)
{
MOZ_MTLOG
(
ML_DEBUG
"
VideoFrameConverter
"
<
<
this
<
<
"
queue
is
full
.
"
<
<
"
Throttling
by
throwing
away
a
frame
.
"
)
;
#
ifdef
DEBUG
+
+
mThrottleCount
;
mThrottleRecord
=
std
:
:
max
(
mThrottleCount
mThrottleRecord
)
;
#
endif
return
;
}
#
ifdef
DEBUG
if
(
mThrottleCount
>
0
)
{
auto
level
=
ML_DEBUG
;
if
(
mThrottleCount
>
5
)
{
level
=
ML_INFO
;
}
MOZ_MTLOG
(
level
"
VideoFrameConverter
"
<
<
this
<
<
"
stopped
"
<
<
"
throttling
after
throwing
away
"
<
<
mThrottleCount
<
<
"
frames
.
Longest
throttle
so
far
was
"
<
<
mThrottleRecord
<
<
"
frames
.
"
)
;
mThrottleCount
=
0
;
}
#
endif
bool
forceBlack
=
aForceBlack
|
|
aChunk
.
mFrame
.
GetForceBlack
(
)
;
if
(
forceBlack
)
{
last_img_
=
-
1
;
if
(
disabled_frame_sent_
)
{
return
;
}
disabled_frame_sent_
=
true
;
}
else
{
disabled_frame_sent_
=
false
;
}
+
+
mLength
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
<
StorensRefPtrPassByPtr
<
Image
>
bool
>
(
this
&
VideoFrameConverter
:
:
ProcessVideoFrame
aChunk
.
mFrame
.
GetImage
(
)
forceBlack
)
;
mTaskQueue
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
void
AddListener
(
VideoConverterListener
*
aListener
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mListeners
.
Contains
(
aListener
)
)
;
mListeners
.
AppendElement
(
aListener
)
;
}
bool
RemoveListener
(
VideoConverterListener
*
aListener
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mListeners
.
RemoveElement
(
aListener
)
;
}
void
Shutdown
(
)
{
mTaskQueue
-
>
BeginShutdown
(
)
;
mTaskQueue
-
>
AwaitShutdownAndIdle
(
)
;
}
protected
:
virtual
~
VideoFrameConverter
(
)
{
MOZ_COUNT_DTOR
(
VideoFrameConverter
)
;
}
void
VideoFrameConverted
(
unsigned
char
*
aVideoFrame
unsigned
int
aVideoFrameLength
unsigned
short
aWidth
unsigned
short
aHeight
VideoType
aVideoType
uint64_t
aCaptureTime
)
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
RefPtr
<
VideoConverterListener
>
&
listener
:
mListeners
)
{
listener
-
>
OnVideoFrameConverted
(
aVideoFrame
aVideoFrameLength
aWidth
aHeight
aVideoType
aCaptureTime
)
;
}
}
void
VideoFrameConverted
(
webrtc
:
:
I420VideoFrame
&
aVideoFrame
)
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
RefPtr
<
VideoConverterListener
>
&
listener
:
mListeners
)
{
listener
-
>
OnVideoFrameConverted
(
aVideoFrame
)
;
}
}
void
ProcessVideoFrame
(
Image
*
aImage
bool
aForceBlack
)
{
-
-
mLength
;
MOZ_ASSERT
(
mLength
>
=
0
)
;
if
(
aForceBlack
)
{
IntSize
size
=
aImage
-
>
GetSize
(
)
;
uint32_t
yPlaneLen
=
YSIZE
(
size
.
width
size
.
height
)
;
uint32_t
cbcrPlaneLen
=
2
*
CRSIZE
(
size
.
width
size
.
height
)
;
uint32_t
length
=
yPlaneLen
+
cbcrPlaneLen
;
auto
pixelData
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
length
)
;
if
(
pixelData
)
{
memset
(
pixelData
.
get
(
)
0x10
yPlaneLen
)
;
memset
(
pixelData
.
get
(
)
+
yPlaneLen
0x80
cbcrPlaneLen
)
;
MOZ_MTLOG
(
ML_DEBUG
"
Sending
a
black
video
frame
"
)
;
VideoFrameConverted
(
pixelData
.
get
(
)
length
size
.
width
size
.
height
mozilla
:
:
kVideoI420
0
)
;
}
return
;
}
ImageFormat
format
=
aImage
-
>
GetFormat
(
)
;
#
ifdef
WEBRTC_GONK
GrallocImage
*
nativeImage
=
aImage
-
>
AsGrallocImage
(
)
;
if
(
nativeImage
)
{
android
:
:
sp
<
android
:
:
GraphicBuffer
>
graphicBuffer
=
nativeImage
-
>
GetGraphicBuffer
(
)
;
int
pixelFormat
=
graphicBuffer
-
>
getPixelFormat
(
)
;
mozilla
:
:
VideoType
destFormat
;
switch
(
pixelFormat
)
{
case
HAL_PIXEL_FORMAT_YV12
:
destFormat
=
mozilla
:
:
kVideoYV12
;
break
;
case
GrallocImage
:
:
HAL_PIXEL_FORMAT_YCbCr_420_SP
:
destFormat
=
mozilla
:
:
kVideoNV21
;
break
;
case
GrallocImage
:
:
HAL_PIXEL_FORMAT_YCbCr_420_P
:
destFormat
=
mozilla
:
:
kVideoI420
;
break
;
default
:
MOZ_MTLOG
(
ML_ERROR
"
Un
-
handled
GRALLOC
buffer
type
:
"
<
<
pixelFormat
)
;
MOZ_CRASH
(
)
;
}
void
*
basePtr
;
graphicBuffer
-
>
lock
(
android
:
:
GraphicBuffer
:
:
USAGE_SW_READ_MASK
&
basePtr
)
;
uint32_t
width
=
graphicBuffer
-
>
getWidth
(
)
;
uint32_t
height
=
graphicBuffer
-
>
getHeight
(
)
;
if
(
destFormat
!
=
mozilla
:
:
kVideoI420
)
{
unsigned
char
*
video_frame
=
static_cast
<
unsigned
char
*
>
(
basePtr
)
;
webrtc
:
:
I420VideoFrame
i420_frame
;
int
stride_y
=
width
;
int
stride_uv
=
(
width
+
1
)
/
2
;
int
target_width
=
width
;
int
target_height
=
height
;
if
(
i420_frame
.
CreateEmptyFrame
(
target_width
abs
(
target_height
)
stride_y
stride_uv
stride_uv
)
<
0
)
{
MOZ_ASSERT
(
false
"
Can
'
t
allocate
empty
i420frame
"
)
;
return
;
}
webrtc
:
:
VideoType
commonVideoType
=
webrtc
:
:
RawVideoTypeToCommonVideoVideoType
(
static_cast
<
webrtc
:
:
RawVideoType
>
(
(
int
)
destFormat
)
)
;
if
(
ConvertToI420
(
commonVideoType
video_frame
0
0
width
height
I420SIZE
(
width
height
)
webrtc
:
:
kVideoRotation_0
&
i420_frame
)
)
{
MOZ_ASSERT
(
false
"
Can
'
t
convert
video
type
for
sending
to
I420
"
)
;
return
;
}
i420_frame
.
set_ntp_time_ms
(
0
)
;
VideoFrameConverted
(
i420_frame
)
;
}
else
{
VideoFrameConverted
(
static_cast
<
unsigned
char
*
>
(
basePtr
)
I420SIZE
(
width
height
)
width
height
destFormat
0
)
;
}
graphicBuffer
-
>
unlock
(
)
;
return
;
}
else
#
endif
if
(
format
=
=
ImageFormat
:
:
PLANAR_YCBCR
)
{
PlanarYCbCrImage
*
yuv
=
const_cast
<
PlanarYCbCrImage
*
>
(
static_cast
<
const
PlanarYCbCrImage
*
>
(
aImage
)
)
;
const
PlanarYCbCrData
*
data
=
yuv
-
>
GetData
(
)
;
if
(
data
)
{
uint8_t
*
y
=
data
-
>
mYChannel
;
uint8_t
*
cb
=
data
-
>
mCbChannel
;
uint8_t
*
cr
=
data
-
>
mCrChannel
;
int32_t
yStride
=
data
-
>
mYStride
;
int32_t
cbCrStride
=
data
-
>
mCbCrStride
;
uint32_t
width
=
yuv
-
>
GetSize
(
)
.
width
;
uint32_t
height
=
yuv
-
>
GetSize
(
)
.
height
;
webrtc
:
:
I420VideoFrame
i420_frame
;
int
rv
=
i420_frame
.
CreateFrame
(
y
cb
cr
width
height
yStride
cbCrStride
cbCrStride
webrtc
:
:
kVideoRotation_0
)
;
if
(
rv
!
=
0
)
{
NS_ERROR
(
"
Creating
an
I420
frame
failed
"
)
;
return
;
}
MOZ_MTLOG
(
ML_DEBUG
"
Sending
an
I420
video
frame
"
)
;
VideoFrameConverted
(
i420_frame
)
;
return
;
}
}
RefPtr
<
SourceSurface
>
surf
=
aImage
-
>
GetAsSourceSurface
(
)
;
if
(
!
surf
)
{
MOZ_MTLOG
(
ML_ERROR
"
Getting
surface
from
"
<
<
Stringify
(
format
)
<
<
"
image
failed
"
)
;
return
;
}
RefPtr
<
DataSourceSurface
>
data
=
surf
-
>
GetDataSurface
(
)
;
if
(
!
data
)
{
MOZ_MTLOG
(
ML_ERROR
"
Getting
data
surface
from
"
<
<
Stringify
(
format
)
<
<
"
image
with
"
<
<
Stringify
(
surf
-
>
GetType
(
)
)
<
<
"
(
"
<
<
Stringify
(
surf
-
>
GetFormat
(
)
)
<
<
"
)
surface
failed
"
)
;
return
;
}
IntSize
size
=
aImage
-
>
GetSize
(
)
;
int
half_width
=
(
size
.
width
+
1
)
>
>
1
;
int
half_height
=
(
size
.
height
+
1
)
>
>
1
;
int
c_size
=
half_width
*
half_height
;
int
buffer_size
=
YSIZE
(
size
.
width
size
.
height
)
+
2
*
c_size
;
auto
yuv_scoped
=
MakeUniqueFallible
<
uint8
[
]
>
(
buffer_size
)
;
if
(
!
yuv_scoped
)
{
return
;
}
uint8
*
yuv
=
yuv_scoped
.
get
(
)
;
DataSourceSurface
:
:
ScopedMap
map
(
data
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Reading
DataSourceSurface
from
"
<
<
Stringify
(
format
)
<
<
"
image
with
"
<
<
Stringify
(
surf
-
>
GetType
(
)
)
<
<
"
(
"
<
<
Stringify
(
surf
-
>
GetFormat
(
)
)
<
<
"
)
surface
failed
"
)
;
return
;
}
int
rv
;
int
cb_offset
=
YSIZE
(
size
.
width
size
.
height
)
;
int
cr_offset
=
cb_offset
+
c_size
;
switch
(
surf
-
>
GetFormat
(
)
)
{
case
SurfaceFormat
:
:
B8G8R8A8
:
case
SurfaceFormat
:
:
B8G8R8X8
:
rv
=
libyuv
:
:
ARGBToI420
(
static_cast
<
uint8
*
>
(
map
.
GetData
(
)
)
map
.
GetStride
(
)
yuv
size
.
width
yuv
+
cb_offset
half_width
yuv
+
cr_offset
half_width
size
.
width
size
.
height
)
;
break
;
case
SurfaceFormat
:
:
R5G6B5_UINT16
:
rv
=
libyuv
:
:
RGB565ToI420
(
static_cast
<
uint8
*
>
(
map
.
GetData
(
)
)
map
.
GetStride
(
)
yuv
size
.
width
yuv
+
cb_offset
half_width
yuv
+
cr_offset
half_width
size
.
width
size
.
height
)
;
break
;
default
:
MOZ_MTLOG
(
ML_ERROR
"
Unsupported
RGB
video
format
"
<
<
Stringify
(
surf
-
>
GetFormat
(
)
)
)
;
MOZ_ASSERT
(
PR_FALSE
)
;
return
;
}
if
(
rv
!
=
0
)
{
MOZ_MTLOG
(
ML_ERROR
Stringify
(
surf
-
>
GetFormat
(
)
)
<
<
"
to
I420
conversion
failed
"
)
;
return
;
}
MOZ_MTLOG
(
ML_DEBUG
"
Sending
an
I420
video
frame
converted
from
"
<
<
Stringify
(
surf
-
>
GetFormat
(
)
)
)
;
VideoFrameConverted
(
yuv
buffer_size
size
.
width
size
.
height
mozilla
:
:
kVideoI420
0
)
;
}
Atomic
<
int32_t
Relaxed
>
mLength
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
int32_t
last_img_
;
bool
disabled_frame_sent_
;
#
ifdef
DEBUG
uint32_t
mThrottleCount
;
uint32_t
mThrottleRecord
;
#
endif
Mutex
mMutex
;
nsTArray
<
RefPtr
<
VideoConverterListener
>
>
mListeners
;
}
;
#
endif
static
char
kDTLSExporterLabel
[
]
=
"
EXTRACTOR
-
dtls_srtp
"
;
MediaPipeline
:
:
MediaPipeline
(
const
std
:
:
string
&
pc
Direction
direction
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
const
std
:
:
string
&
track_id
int
level
RefPtr
<
MediaSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
:
direction_
(
direction
)
track_id_
(
track_id
)
level_
(
level
)
conduit_
(
conduit
)
rtp_
(
rtp_transport
rtcp_transport
?
RTP
:
MUX
)
rtcp_
(
rtcp_transport
?
rtcp_transport
:
rtp_transport
rtcp_transport
?
RTCP
:
MUX
)
main_thread_
(
main_thread
)
sts_thread_
(
sts_thread
)
rtp_packets_sent_
(
0
)
rtcp_packets_sent_
(
0
)
rtp_packets_received_
(
0
)
rtcp_packets_received_
(
0
)
rtp_bytes_sent_
(
0
)
rtp_bytes_received_
(
0
)
pc_
(
pc
)
description_
(
)
filter_
(
filter
)
rtp_parser_
(
webrtc
:
:
RtpHeaderParser
:
:
Create
(
)
)
{
MOZ_ASSERT
(
rtp_transport
!
=
rtcp_transport
)
;
transport_
=
new
PipelineTransport
(
this
)
;
}
MediaPipeline
:
:
~
MediaPipeline
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
MOZ_MTLOG
(
ML_INFO
"
Destroying
MediaPipeline
:
"
<
<
description_
)
;
}
nsresult
MediaPipeline
:
:
Init
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
if
(
direction_
=
=
RECEIVE
)
{
conduit_
-
>
SetReceiverTransport
(
transport_
)
;
}
else
{
conduit_
-
>
SetTransmitterTransport
(
transport_
)
;
}
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
RefPtr
<
MediaPipeline
>
(
this
)
&
MediaPipeline
:
:
Init_s
)
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
nsresult
MediaPipeline
:
:
Init_s
(
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
return
AttachTransport_s
(
)
;
}
void
MediaPipeline
:
:
DetachTransport_s
(
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
disconnect_all
(
)
;
transport_
-
>
Detach
(
)
;
rtp_
.
Detach
(
)
;
rtcp_
.
Detach
(
)
;
}
nsresult
MediaPipeline
:
:
AttachTransport_s
(
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
nsresult
res
;
MOZ_ASSERT
(
rtp_
.
transport_
)
;
MOZ_ASSERT
(
rtcp_
.
transport_
)
;
res
=
ConnectTransport_s
(
rtp_
)
;
if
(
NS_FAILED
(
res
)
)
{
return
res
;
}
if
(
rtcp_
.
transport_
!
=
rtp_
.
transport_
)
{
res
=
ConnectTransport_s
(
rtcp_
)
;
if
(
NS_FAILED
(
res
)
)
{
return
res
;
}
}
transport_
-
>
Attach
(
this
)
;
return
NS_OK
;
}
void
MediaPipeline
:
:
UpdateTransport_m
(
int
level
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
{
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
this
&
MediaPipeline
:
:
UpdateTransport_s
level
rtp_transport
rtcp_transport
filter
)
NS_DISPATCH_NORMAL
)
;
}
void
MediaPipeline
:
:
UpdateTransport_s
(
int
level
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
{
bool
rtcp_mux
=
false
;
if
(
!
rtcp_transport
)
{
rtcp_transport
=
rtp_transport
;
rtcp_mux
=
true
;
}
if
(
(
rtp_transport
!
=
rtp_
.
transport_
)
|
|
(
rtcp_transport
!
=
rtcp_
.
transport_
)
)
{
DetachTransport_s
(
)
;
rtp_
=
TransportInfo
(
rtp_transport
rtcp_mux
?
MUX
:
RTP
)
;
rtcp_
=
TransportInfo
(
rtcp_transport
rtcp_mux
?
MUX
:
RTCP
)
;
AttachTransport_s
(
)
;
}
level_
=
level
;
if
(
filter_
&
&
filter
)
{
filter_
-
>
Update
(
*
filter
)
;
}
else
{
filter_
=
filter
;
}
}
void
MediaPipeline
:
:
SelectSsrc_m
(
size_t
ssrc_index
)
{
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
this
&
MediaPipeline
:
:
SelectSsrc_s
ssrc_index
)
NS_DISPATCH_NORMAL
)
;
}
void
MediaPipeline
:
:
SelectSsrc_s
(
size_t
ssrc_index
)
{
filter_
=
new
MediaPipelineFilter
;
if
(
ssrc_index
<
ssrcs_received_
.
size
(
)
)
{
filter_
-
>
AddRemoteSSRC
(
ssrcs_received_
[
ssrc_index
]
)
;
}
else
{
MOZ_MTLOG
(
ML_WARNING
"
SelectSsrc
called
with
"
<
<
ssrc_index
<
<
"
but
we
"
<
<
"
have
only
seen
"
<
<
ssrcs_received_
.
size
(
)
<
<
"
ssrcs
"
)
;
}
}
void
MediaPipeline
:
:
StateChange
(
TransportFlow
*
flow
TransportLayer
:
:
State
state
)
{
TransportInfo
*
info
=
GetTransportInfo_s
(
flow
)
;
MOZ_ASSERT
(
info
)
;
if
(
state
=
=
TransportLayer
:
:
TS_OPEN
)
{
MOZ_MTLOG
(
ML_INFO
"
Flow
is
ready
"
)
;
TransportReady_s
(
*
info
)
;
}
else
if
(
state
=
=
TransportLayer
:
:
TS_CLOSED
|
|
state
=
=
TransportLayer
:
:
TS_ERROR
)
{
TransportFailed_s
(
*
info
)
;
}
}
static
bool
MakeRtpTypeToStringArray
(
const
char
*
*
array
)
{
static
const
char
*
RTP_str
=
"
RTP
"
;
static
const
char
*
RTCP_str
=
"
RTCP
"
;
static
const
char
*
MUX_str
=
"
RTP
/
RTCP
mux
"
;
array
[
MediaPipeline
:
:
RTP
]
=
RTP_str
;
array
[
MediaPipeline
:
:
RTCP
]
=
RTCP_str
;
array
[
MediaPipeline
:
:
MUX
]
=
MUX_str
;
return
true
;
}
static
const
char
*
ToString
(
MediaPipeline
:
:
RtpType
type
)
{
static
const
char
*
array
[
(
int
)
MediaPipeline
:
:
MAX_RTP_TYPE
]
=
{
nullptr
}
;
static
bool
dummy
=
MakeRtpTypeToStringArray
(
array
)
;
(
void
)
dummy
;
return
array
[
type
]
;
}
nsresult
MediaPipeline
:
:
TransportReady_s
(
TransportInfo
&
info
)
{
MOZ_ASSERT
(
!
description_
.
empty
(
)
)
;
if
(
info
.
state_
!
=
MP_CONNECTING
)
{
MOZ_MTLOG
(
ML_ERROR
"
Transport
ready
for
flow
in
wrong
state
:
"
<
<
description_
<
<
"
:
"
<
<
ToString
(
info
.
type_
)
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_MTLOG
(
ML_INFO
"
Transport
ready
for
pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
flow
"
<
<
description_
<
<
"
:
"
<
<
ToString
(
info
.
type_
)
)
;
nsresult
res
;
TransportLayerDtls
*
dtls
=
static_cast
<
TransportLayerDtls
*
>
(
info
.
transport_
-
>
GetLayer
(
TransportLayerDtls
:
:
ID
(
)
)
)
;
MOZ_ASSERT
(
dtls
)
;
uint16_t
cipher_suite
;
res
=
dtls
-
>
GetSrtpCipher
(
&
cipher_suite
)
;
if
(
NS_FAILED
(
res
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Failed
to
negotiate
DTLS
-
SRTP
.
This
is
an
error
"
)
;
info
.
state_
=
MP_CLOSED
;
UpdateRtcpMuxState
(
info
)
;
return
res
;
}
unsigned
char
srtp_block
[
SRTP_TOTAL_KEY_LENGTH
*
2
]
;
res
=
dtls
-
>
ExportKeyingMaterial
(
kDTLSExporterLabel
false
"
"
srtp_block
sizeof
(
srtp_block
)
)
;
if
(
NS_FAILED
(
res
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Failed
to
compute
DTLS
-
SRTP
keys
.
This
is
an
error
"
)
;
info
.
state_
=
MP_CLOSED
;
UpdateRtcpMuxState
(
info
)
;
MOZ_CRASH
(
)
;
return
res
;
}
unsigned
char
client_write_key
[
SRTP_TOTAL_KEY_LENGTH
]
;
unsigned
char
server_write_key
[
SRTP_TOTAL_KEY_LENGTH
]
;
int
offset
=
0
;
memcpy
(
client_write_key
srtp_block
+
offset
SRTP_MASTER_KEY_LENGTH
)
;
offset
+
=
SRTP_MASTER_KEY_LENGTH
;
memcpy
(
server_write_key
srtp_block
+
offset
SRTP_MASTER_KEY_LENGTH
)
;
offset
+
=
SRTP_MASTER_KEY_LENGTH
;
memcpy
(
client_write_key
+
SRTP_MASTER_KEY_LENGTH
srtp_block
+
offset
SRTP_MASTER_SALT_LENGTH
)
;
offset
+
=
SRTP_MASTER_SALT_LENGTH
;
memcpy
(
server_write_key
+
SRTP_MASTER_KEY_LENGTH
srtp_block
+
offset
SRTP_MASTER_SALT_LENGTH
)
;
offset
+
=
SRTP_MASTER_SALT_LENGTH
;
MOZ_ASSERT
(
offset
=
=
sizeof
(
srtp_block
)
)
;
unsigned
char
*
write_key
;
unsigned
char
*
read_key
;
if
(
dtls
-
>
role
(
)
=
=
TransportLayerDtls
:
:
CLIENT
)
{
write_key
=
client_write_key
;
read_key
=
server_write_key
;
}
else
{
write_key
=
server_write_key
;
read_key
=
client_write_key
;
}
MOZ_ASSERT
(
!
info
.
send_srtp_
&
&
!
info
.
recv_srtp_
)
;
info
.
send_srtp_
=
SrtpFlow
:
:
Create
(
cipher_suite
false
write_key
SRTP_TOTAL_KEY_LENGTH
)
;
info
.
recv_srtp_
=
SrtpFlow
:
:
Create
(
cipher_suite
true
read_key
SRTP_TOTAL_KEY_LENGTH
)
;
if
(
!
info
.
send_srtp_
|
|
!
info
.
recv_srtp_
)
{
MOZ_MTLOG
(
ML_ERROR
"
Couldn
'
t
create
SRTP
flow
for
"
<
<
ToString
(
info
.
type_
)
)
;
info
.
state_
=
MP_CLOSED
;
UpdateRtcpMuxState
(
info
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_MTLOG
(
ML_INFO
"
Listening
for
"
<
<
ToString
(
info
.
type_
)
<
<
"
packets
received
on
"
<
<
static_cast
<
void
*
>
(
dtls
-
>
downward
(
)
)
)
;
switch
(
info
.
type_
)
{
case
RTP
:
dtls
-
>
downward
(
)
-
>
SignalPacketReceived
.
connect
(
this
&
MediaPipeline
:
:
RtpPacketReceived
)
;
break
;
case
RTCP
:
dtls
-
>
downward
(
)
-
>
SignalPacketReceived
.
connect
(
this
&
MediaPipeline
:
:
RtcpPacketReceived
)
;
break
;
case
MUX
:
dtls
-
>
downward
(
)
-
>
SignalPacketReceived
.
connect
(
this
&
MediaPipeline
:
:
PacketReceived
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
info
.
state_
=
MP_OPEN
;
UpdateRtcpMuxState
(
info
)
;
return
NS_OK
;
}
nsresult
MediaPipeline
:
:
TransportFailed_s
(
TransportInfo
&
info
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
info
.
state_
=
MP_CLOSED
;
UpdateRtcpMuxState
(
info
)
;
MOZ_MTLOG
(
ML_INFO
"
Transport
closed
for
flow
"
<
<
ToString
(
info
.
type_
)
)
;
NS_WARNING
(
"
MediaPipeline
Transport
failed
.
This
is
not
properly
cleaned
up
yet
"
)
;
return
NS_OK
;
}
void
MediaPipeline
:
:
UpdateRtcpMuxState
(
TransportInfo
&
info
)
{
if
(
info
.
type_
=
=
MUX
)
{
if
(
info
.
transport_
=
=
rtcp_
.
transport_
)
{
rtcp_
.
state_
=
info
.
state_
;
if
(
!
rtcp_
.
send_srtp_
)
{
rtcp_
.
send_srtp_
=
info
.
send_srtp_
;
rtcp_
.
recv_srtp_
=
info
.
recv_srtp_
;
}
}
}
}
nsresult
MediaPipeline
:
:
SendPacket
(
TransportFlow
*
flow
const
void
*
data
int
len
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
TransportLayerDtls
*
dtls
=
static_cast
<
TransportLayerDtls
*
>
(
flow
-
>
GetLayer
(
TransportLayerDtls
:
:
ID
(
)
)
)
;
MOZ_ASSERT
(
dtls
)
;
TransportResult
res
=
dtls
-
>
downward
(
)
-
>
SendPacket
(
static_cast
<
const
unsigned
char
*
>
(
data
)
len
)
;
if
(
res
!
=
len
)
{
if
(
res
=
=
TE_WOULDBLOCK
)
return
NS_OK
;
MOZ_MTLOG
(
ML_ERROR
"
Failed
write
on
stream
"
<
<
description_
)
;
return
NS_BASE_STREAM_CLOSED
;
}
return
NS_OK
;
}
void
MediaPipeline
:
:
increment_rtp_packets_sent
(
int32_t
bytes
)
{
+
+
rtp_packets_sent_
;
rtp_bytes_sent_
+
=
bytes
;
if
(
!
(
rtp_packets_sent_
%
100
)
)
{
MOZ_MTLOG
(
ML_INFO
"
RTP
sent
packet
count
for
"
<
<
description_
<
<
"
Pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
Flow
:
"
<
<
static_cast
<
void
*
>
(
rtp_
.
transport_
)
<
<
"
:
"
<
<
rtp_packets_sent_
<
<
"
(
"
<
<
rtp_bytes_sent_
<
<
"
bytes
)
"
)
;
}
}
void
MediaPipeline
:
:
increment_rtcp_packets_sent
(
)
{
+
+
rtcp_packets_sent_
;
if
(
!
(
rtcp_packets_sent_
%
100
)
)
{
MOZ_MTLOG
(
ML_INFO
"
RTCP
sent
packet
count
for
"
<
<
description_
<
<
"
Pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
Flow
:
"
<
<
static_cast
<
void
*
>
(
rtcp_
.
transport_
)
<
<
"
:
"
<
<
rtcp_packets_sent_
)
;
}
}
void
MediaPipeline
:
:
increment_rtp_packets_received
(
int32_t
bytes
)
{
+
+
rtp_packets_received_
;
rtp_bytes_received_
+
=
bytes
;
if
(
!
(
rtp_packets_received_
%
100
)
)
{
MOZ_MTLOG
(
ML_INFO
"
RTP
received
packet
count
for
"
<
<
description_
<
<
"
Pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
Flow
:
"
<
<
static_cast
<
void
*
>
(
rtp_
.
transport_
)
<
<
"
:
"
<
<
rtp_packets_received_
<
<
"
(
"
<
<
rtp_bytes_received_
<
<
"
bytes
)
"
)
;
}
}
void
MediaPipeline
:
:
increment_rtcp_packets_received
(
)
{
+
+
rtcp_packets_received_
;
if
(
!
(
rtcp_packets_received_
%
100
)
)
{
MOZ_MTLOG
(
ML_INFO
"
RTCP
received
packet
count
for
"
<
<
description_
<
<
"
Pipeline
"
<
<
static_cast
<
void
*
>
(
this
)
<
<
"
Flow
:
"
<
<
static_cast
<
void
*
>
(
rtcp_
.
transport_
)
<
<
"
:
"
<
<
rtcp_packets_received_
)
;
}
}
void
MediaPipeline
:
:
RtpPacketReceived
(
TransportLayer
*
layer
const
unsigned
char
*
data
size_t
len
)
{
if
(
!
transport_
-
>
pipeline
(
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Discarding
incoming
packet
;
transport
disconnected
"
)
;
return
;
}
if
(
!
conduit_
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
media
disconnected
"
)
;
return
;
}
if
(
rtp_
.
state_
!
=
MP_OPEN
)
{
MOZ_MTLOG
(
ML_ERROR
"
Discarding
incoming
packet
;
pipeline
not
open
"
)
;
return
;
}
if
(
rtp_
.
transport_
-
>
state
(
)
!
=
TransportLayer
:
:
TS_OPEN
)
{
MOZ_MTLOG
(
ML_ERROR
"
Discarding
incoming
packet
;
transport
not
open
"
)
;
return
;
}
MOZ_ASSERT
(
rtp_
.
recv_srtp_
)
;
if
(
direction_
=
=
TRANSMIT
)
{
return
;
}
if
(
!
len
)
{
return
;
}
if
(
data
[
0
]
<
128
|
|
data
[
0
]
>
191
)
{
return
;
}
webrtc
:
:
RTPHeader
header
;
if
(
!
rtp_parser_
-
>
Parse
(
data
len
&
header
)
)
{
return
;
}
if
(
std
:
:
find
(
ssrcs_received_
.
begin
(
)
ssrcs_received_
.
end
(
)
header
.
ssrc
)
=
=
ssrcs_received_
.
end
(
)
)
{
ssrcs_received_
.
push_back
(
header
.
ssrc
)
;
}
if
(
filter_
&
&
!
filter_
-
>
Filter
(
header
)
)
{
return
;
}
auto
inner_data
=
MakeUnique
<
unsigned
char
[
]
>
(
len
)
;
memcpy
(
inner_data
.
get
(
)
data
len
)
;
int
out_len
=
0
;
nsresult
res
=
rtp_
.
recv_srtp_
-
>
UnprotectRtp
(
inner_data
.
get
(
)
len
len
&
out_len
)
;
if
(
!
NS_SUCCEEDED
(
res
)
)
{
char
tmp
[
16
]
;
PR_snprintf
(
tmp
sizeof
(
tmp
)
"
%
.
2x
%
.
2x
%
.
2x
%
.
2x
"
inner_data
[
0
]
inner_data
[
1
]
inner_data
[
2
]
inner_data
[
3
]
)
;
MOZ_MTLOG
(
ML_NOTICE
"
Error
unprotecting
RTP
in
"
<
<
description_
<
<
"
len
=
"
<
<
len
<
<
"
[
"
<
<
tmp
<
<
"
.
.
.
]
"
)
;
return
;
}
MOZ_MTLOG
(
ML_DEBUG
description_
<
<
"
received
RTP
packet
.
"
)
;
increment_rtp_packets_received
(
out_len
)
;
(
void
)
conduit_
-
>
ReceivedRTPPacket
(
inner_data
.
get
(
)
out_len
)
;
}
void
MediaPipeline
:
:
RtcpPacketReceived
(
TransportLayer
*
layer
const
unsigned
char
*
data
size_t
len
)
{
if
(
!
transport_
-
>
pipeline
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
transport
disconnected
"
)
;
return
;
}
if
(
!
conduit_
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
media
disconnected
"
)
;
return
;
}
if
(
rtcp_
.
state_
!
=
MP_OPEN
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
pipeline
not
open
"
)
;
return
;
}
if
(
rtcp_
.
transport_
-
>
state
(
)
!
=
TransportLayer
:
:
TS_OPEN
)
{
MOZ_MTLOG
(
ML_ERROR
"
Discarding
incoming
packet
;
transport
not
open
"
)
;
return
;
}
if
(
!
len
)
{
return
;
}
if
(
data
[
0
]
<
128
|
|
data
[
0
]
>
191
)
{
return
;
}
if
(
filter_
&
&
direction_
=
=
RECEIVE
)
{
if
(
!
filter_
-
>
FilterSenderReport
(
data
len
)
)
{
MOZ_MTLOG
(
ML_NOTICE
"
Dropping
incoming
RTCP
packet
;
filtered
out
"
)
;
return
;
}
}
auto
inner_data
=
MakeUnique
<
unsigned
char
[
]
>
(
len
)
;
memcpy
(
inner_data
.
get
(
)
data
len
)
;
int
out_len
;
nsresult
res
=
rtcp_
.
recv_srtp_
-
>
UnprotectRtcp
(
inner_data
.
get
(
)
len
len
&
out_len
)
;
if
(
!
NS_SUCCEEDED
(
res
)
)
return
;
MOZ_MTLOG
(
ML_DEBUG
description_
<
<
"
received
RTCP
packet
.
"
)
;
increment_rtcp_packets_received
(
)
;
MOZ_ASSERT
(
rtcp_
.
recv_srtp_
)
;
(
void
)
conduit_
-
>
ReceivedRTCPPacket
(
inner_data
.
get
(
)
out_len
)
;
}
bool
MediaPipeline
:
:
IsRtp
(
const
unsigned
char
*
data
size_t
len
)
{
if
(
len
<
2
)
return
false
;
if
(
(
data
[
1
]
<
192
)
|
|
(
data
[
1
]
>
207
)
)
return
true
;
if
(
data
[
1
]
=
=
192
)
return
false
;
if
(
data
[
1
]
=
=
193
)
return
true
;
if
(
data
[
1
]
=
=
194
)
return
true
;
if
(
data
[
1
]
=
=
195
)
return
false
;
if
(
(
data
[
1
]
>
195
)
&
&
(
data
[
1
]
<
200
)
)
return
true
;
if
(
(
data
[
1
]
>
=
200
)
&
&
(
data
[
1
]
<
=
207
)
)
return
false
;
MOZ_ASSERT
(
false
)
;
return
true
;
}
void
MediaPipeline
:
:
PacketReceived
(
TransportLayer
*
layer
const
unsigned
char
*
data
size_t
len
)
{
if
(
!
transport_
-
>
pipeline
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
incoming
packet
;
transport
disconnected
"
)
;
return
;
}
if
(
IsRtp
(
data
len
)
)
{
RtpPacketReceived
(
layer
data
len
)
;
}
else
{
RtcpPacketReceived
(
layer
data
len
)
;
}
}
class
MediaPipelineTransmit
:
:
PipelineListener
:
public
DirectMediaStreamTrackListener
{
friend
class
MediaPipelineTransmit
;
public
:
explicit
PipelineListener
(
const
RefPtr
<
MediaSessionConduit
>
&
conduit
)
:
conduit_
(
conduit
)
track_id_
(
TRACK_INVALID
)
mMutex
(
"
MediaPipelineTransmit
:
:
PipelineListener
"
)
track_id_external_
(
TRACK_INVALID
)
active_
(
false
)
enabled_
(
false
)
direct_connect_
(
false
)
packetizer_
(
nullptr
)
{
}
~
PipelineListener
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsresult
rv
=
NS_DispatchToMainThread
(
new
ConduitDeleteEvent
(
conduit_
.
forget
(
)
)
)
;
MOZ_ASSERT
(
!
NS_FAILED
(
rv
)
"
Could
not
dispatch
conduit
shutdown
to
main
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
)
;
}
}
else
{
conduit_
=
nullptr
;
}
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
if
(
converter_
)
{
converter_
-
>
Shutdown
(
)
;
}
#
endif
}
void
UnsetTrackId
(
MediaStreamGraphImpl
*
graph
)
;
void
SetActive
(
bool
active
)
{
active_
=
active
;
}
void
SetEnabled
(
bool
enabled
)
{
enabled_
=
enabled
;
}
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
void
SetVideoFrameConverter
(
const
RefPtr
<
VideoFrameConverter
>
&
converter
)
{
converter_
=
converter
;
}
void
OnVideoFrameConverted
(
unsigned
char
*
aVideoFrame
unsigned
int
aVideoFrameLength
unsigned
short
aWidth
unsigned
short
aHeight
VideoType
aVideoType
uint64_t
aCaptureTime
)
{
MOZ_ASSERT
(
conduit_
-
>
type
(
)
=
=
MediaSessionConduit
:
:
VIDEO
)
;
static_cast
<
VideoSessionConduit
*
>
(
conduit_
.
get
(
)
)
-
>
SendVideoFrame
(
aVideoFrame
aVideoFrameLength
aWidth
aHeight
aVideoType
aCaptureTime
)
;
}
void
OnVideoFrameConverted
(
webrtc
:
:
I420VideoFrame
&
aVideoFrame
)
{
MOZ_ASSERT
(
conduit_
-
>
type
(
)
=
=
MediaSessionConduit
:
:
VIDEO
)
;
static_cast
<
VideoSessionConduit
*
>
(
conduit_
.
get
(
)
)
-
>
SendVideoFrame
(
aVideoFrame
)
;
}
#
endif
void
NotifyQueuedChanges
(
MediaStreamGraph
*
aGraph
StreamTime
aTrackOffset
const
MediaSegment
&
aQueuedMedia
)
override
;
void
NotifyRealtimeTrackData
(
MediaStreamGraph
*
aGraph
StreamTime
aTrackOffset
const
MediaSegment
&
aMedia
)
override
;
void
NotifyDirectListenerInstalled
(
InstallationResult
aResult
)
override
;
void
NotifyDirectListenerUninstalled
(
)
override
;
private
:
void
UnsetTrackIdImpl
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
track_id_
=
track_id_external_
=
TRACK_INVALID
;
}
void
NewData
(
MediaStreamGraph
*
graph
StreamTime
offset
const
MediaSegment
&
media
)
;
virtual
void
ProcessAudioChunk
(
AudioSessionConduit
*
conduit
TrackRate
rate
AudioChunk
&
chunk
)
;
RefPtr
<
MediaSessionConduit
>
conduit_
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
RefPtr
<
VideoFrameConverter
>
converter_
;
#
endif
TrackID
track_id_
;
Mutex
mMutex
;
TrackID
track_id_external_
;
mozilla
:
:
Atomic
<
bool
>
active_
;
mozilla
:
:
Atomic
<
bool
>
enabled_
;
bool
direct_connect_
;
nsAutoPtr
<
AudioPacketizer
<
int16_t
int16_t
>
>
packetizer_
;
}
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
class
MediaPipelineTransmit
:
:
VideoFrameFeeder
:
public
VideoConverterListener
{
public
:
explicit
VideoFrameFeeder
(
const
RefPtr
<
PipelineListener
>
&
listener
)
:
listener_
(
listener
)
mutex_
(
"
VideoFrameFeeder
"
)
{
MOZ_COUNT_CTOR
(
VideoFrameFeeder
)
;
}
void
Detach
(
)
{
MutexAutoLock
lock
(
mutex_
)
;
listener_
=
nullptr
;
}
void
OnVideoFrameConverted
(
unsigned
char
*
aVideoFrame
unsigned
int
aVideoFrameLength
unsigned
short
aWidth
unsigned
short
aHeight
VideoType
aVideoType
uint64_t
aCaptureTime
)
override
{
MutexAutoLock
lock
(
mutex_
)
;
if
(
!
listener_
)
{
return
;
}
listener_
-
>
OnVideoFrameConverted
(
aVideoFrame
aVideoFrameLength
aWidth
aHeight
aVideoType
aCaptureTime
)
;
}
void
OnVideoFrameConverted
(
webrtc
:
:
I420VideoFrame
&
aVideoFrame
)
override
{
MutexAutoLock
lock
(
mutex_
)
;
if
(
!
listener_
)
{
return
;
}
listener_
-
>
OnVideoFrameConverted
(
aVideoFrame
)
;
}
protected
:
virtual
~
VideoFrameFeeder
(
)
{
MOZ_COUNT_DTOR
(
VideoFrameFeeder
)
;
}
RefPtr
<
PipelineListener
>
listener_
;
Mutex
mutex_
;
}
;
#
endif
class
MediaPipelineTransmit
:
:
PipelineVideoSink
:
public
MediaStreamVideoSink
{
public
:
explicit
PipelineVideoSink
(
const
RefPtr
<
MediaSessionConduit
>
&
conduit
MediaPipelineTransmit
:
:
PipelineListener
*
listener
)
:
conduit_
(
conduit
)
pipelineListener_
(
listener
)
{
}
virtual
void
SetCurrentFrames
(
const
VideoSegment
&
aSegment
)
override
;
virtual
void
ClearFrames
(
)
override
{
}
private
:
~
PipelineVideoSink
(
)
{
nsresult
rv
=
NS_DispatchToMainThread
(
new
ConduitDeleteEvent
(
conduit_
.
forget
(
)
)
)
;
MOZ_ASSERT
(
!
NS_FAILED
(
rv
)
"
Could
not
dispatch
conduit
shutdown
to
main
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
)
;
}
}
RefPtr
<
MediaSessionConduit
>
conduit_
;
MediaPipelineTransmit
:
:
PipelineListener
*
pipelineListener_
;
}
;
MediaPipelineTransmit
:
:
MediaPipelineTransmit
(
const
std
:
:
string
&
pc
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
dom
:
:
MediaStreamTrack
*
domtrack
const
std
:
:
string
&
track_id
int
level
RefPtr
<
MediaSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
:
MediaPipeline
(
pc
TRANSMIT
main_thread
sts_thread
track_id
level
conduit
rtp_transport
rtcp_transport
filter
)
listener_
(
new
PipelineListener
(
conduit
)
)
video_sink_
(
new
PipelineVideoSink
(
conduit
listener_
)
)
domtrack_
(
domtrack
)
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
if
(
IsVideo
(
)
)
{
feeder_
=
MakeAndAddRef
<
VideoFrameFeeder
>
(
listener_
)
;
converter_
=
MakeAndAddRef
<
VideoFrameConverter
>
(
)
;
converter_
-
>
AddListener
(
feeder_
)
;
listener_
-
>
SetVideoFrameConverter
(
converter_
)
;
}
#
endif
}
MediaPipelineTransmit
:
:
~
MediaPipelineTransmit
(
)
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
if
(
feeder_
)
{
feeder_
-
>
Detach
(
)
;
}
#
endif
}
nsresult
MediaPipelineTransmit
:
:
Init
(
)
{
AttachToTrack
(
track_id_
)
;
return
MediaPipeline
:
:
Init
(
)
;
}
void
MediaPipelineTransmit
:
:
AttachToTrack
(
const
std
:
:
string
&
track_id
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
description_
=
pc_
+
"
|
"
;
description_
+
=
conduit_
-
>
type
(
)
=
=
MediaSessionConduit
:
:
AUDIO
?
"
Transmit
audio
[
"
:
"
Transmit
video
[
"
;
description_
+
=
track_id
;
description_
+
=
"
]
"
;
MOZ_MTLOG
(
ML_DEBUG
"
Attaching
pipeline
to
track
"
<
<
static_cast
<
void
*
>
(
domtrack_
)
<
<
"
conduit
type
=
"
<
<
(
conduit_
-
>
type
(
)
=
=
MediaSessionConduit
:
:
AUDIO
?
"
audio
"
:
"
video
"
)
)
;
domtrack_
-
>
AddDirectListener
(
listener_
)
;
domtrack_
-
>
AddListener
(
listener_
)
;
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
domtrack_
-
>
AddDirectListener
(
video_sink_
)
;
#
endif
#
ifndef
MOZILLA_INTERNAL_API
listener_
-
>
SetEnabled
(
true
)
;
#
endif
}
bool
MediaPipelineTransmit
:
:
IsVideo
(
)
const
{
return
!
!
domtrack_
-
>
AsVideoStreamTrack
(
)
;
}
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
void
MediaPipelineTransmit
:
:
UpdateSinkIdentity_m
(
MediaStreamTrack
*
track
nsIPrincipal
*
principal
const
PeerIdentity
*
sinkIdentity
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
if
(
track
!
=
nullptr
&
&
track
!
=
domtrack_
)
{
return
;
}
bool
enableTrack
=
principal
-
>
Subsumes
(
domtrack_
-
>
GetPrincipal
(
)
)
;
if
(
!
enableTrack
)
{
const
PeerIdentity
*
trackIdentity
=
domtrack_
-
>
GetPeerIdentity
(
)
;
if
(
sinkIdentity
&
&
trackIdentity
)
{
enableTrack
=
(
*
sinkIdentity
=
=
*
trackIdentity
)
;
}
}
listener_
-
>
SetEnabled
(
enableTrack
)
;
}
#
endif
void
MediaPipelineTransmit
:
:
DetachMedia
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
if
(
domtrack_
)
{
domtrack_
-
>
RemoveDirectListener
(
listener_
)
;
domtrack_
-
>
RemoveListener
(
listener_
)
;
domtrack_
-
>
RemoveDirectListener
(
video_sink_
)
;
domtrack_
=
nullptr
;
}
}
nsresult
MediaPipelineTransmit
:
:
TransportReady_s
(
TransportInfo
&
info
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
MediaPipeline
:
:
TransportReady_s
(
info
)
;
if
(
&
info
=
=
&
rtp_
)
{
listener_
-
>
SetActive
(
true
)
;
}
return
NS_OK
;
}
nsresult
MediaPipelineTransmit
:
:
ReplaceTrack
(
MediaStreamTrack
&
domtrack
)
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
nsString
nsTrackId
;
domtrack
.
GetId
(
nsTrackId
)
;
std
:
:
string
track_id
(
NS_ConvertUTF16toUTF8
(
nsTrackId
)
.
get
(
)
)
;
#
else
std
:
:
string
track_id
=
domtrack
.
GetId
(
)
;
#
endif
MOZ_MTLOG
(
ML_DEBUG
"
Reattaching
pipeline
"
<
<
description_
<
<
"
to
track
"
<
<
static_cast
<
void
*
>
(
&
domtrack
)
<
<
"
track
"
<
<
track_id
<
<
"
conduit
type
=
"
<
<
(
conduit_
-
>
type
(
)
=
=
MediaSessionConduit
:
:
AUDIO
?
"
audio
"
:
"
video
"
)
)
;
DetachMedia
(
)
;
domtrack_
=
&
domtrack
;
listener_
-
>
UnsetTrackId
(
domtrack_
-
>
GraphImpl
(
)
)
;
track_id_
=
track_id
;
AttachToTrack
(
track_id
)
;
return
NS_OK
;
}
void
MediaPipeline
:
:
DisconnectTransport_s
(
TransportInfo
&
info
)
{
MOZ_ASSERT
(
info
.
transport_
)
;
ASSERT_ON_THREAD
(
sts_thread_
)
;
info
.
transport_
-
>
SignalStateChange
.
disconnect
(
this
)
;
TransportLayerDtls
*
dtls
=
static_cast
<
TransportLayerDtls
*
>
(
info
.
transport_
-
>
GetLayer
(
TransportLayerDtls
:
:
ID
(
)
)
)
;
MOZ_ASSERT
(
dtls
)
;
MOZ_ASSERT
(
dtls
-
>
downward
(
)
)
;
dtls
-
>
downward
(
)
-
>
SignalPacketReceived
.
disconnect
(
this
)
;
}
nsresult
MediaPipeline
:
:
ConnectTransport_s
(
TransportInfo
&
info
)
{
MOZ_ASSERT
(
info
.
transport_
)
;
ASSERT_ON_THREAD
(
sts_thread_
)
;
if
(
info
.
transport_
-
>
state
(
)
=
=
TransportLayer
:
:
TS_OPEN
)
{
nsresult
res
=
TransportReady_s
(
info
)
;
if
(
NS_FAILED
(
res
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Error
calling
TransportReady
(
)
;
res
=
"
<
<
static_cast
<
uint32_t
>
(
res
)
<
<
"
in
"
<
<
__FUNCTION__
)
;
return
res
;
}
}
else
if
(
info
.
transport_
-
>
state
(
)
=
=
TransportLayer
:
:
TS_ERROR
)
{
MOZ_MTLOG
(
ML_ERROR
ToString
(
info
.
type_
)
<
<
"
transport
is
already
in
error
state
"
)
;
TransportFailed_s
(
info
)
;
return
NS_ERROR_FAILURE
;
}
info
.
transport_
-
>
SignalStateChange
.
connect
(
this
&
MediaPipeline
:
:
StateChange
)
;
return
NS_OK
;
}
MediaPipeline
:
:
TransportInfo
*
MediaPipeline
:
:
GetTransportInfo_s
(
TransportFlow
*
flow
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
if
(
flow
=
=
rtp_
.
transport_
)
{
return
&
rtp_
;
}
if
(
flow
=
=
rtcp_
.
transport_
)
{
return
&
rtcp_
;
}
return
nullptr
;
}
nsresult
MediaPipeline
:
:
PipelineTransport
:
:
SendRtpPacket
(
const
void
*
data
int
len
)
{
nsAutoPtr
<
DataBuffer
>
buf
(
new
DataBuffer
(
static_cast
<
const
uint8_t
*
>
(
data
)
len
len
+
SRTP_MAX_EXPANSION
)
)
;
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
RefPtr
<
MediaPipeline
:
:
PipelineTransport
>
(
this
)
&
MediaPipeline
:
:
PipelineTransport
:
:
SendRtpRtcpPacket_s
buf
true
)
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
nsresult
MediaPipeline
:
:
PipelineTransport
:
:
SendRtpRtcpPacket_s
(
nsAutoPtr
<
DataBuffer
>
data
bool
is_rtp
)
{
ASSERT_ON_THREAD
(
sts_thread_
)
;
if
(
!
pipeline_
)
{
return
NS_OK
;
}
TransportInfo
&
transport
=
is_rtp
?
pipeline_
-
>
rtp_
:
pipeline_
-
>
rtcp_
;
if
(
!
transport
.
send_srtp_
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Couldn
'
t
write
RTP
/
RTCP
packet
;
SRTP
not
set
up
yet
"
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
transport
.
transport_
)
;
NS_ENSURE_TRUE
(
transport
.
transport_
NS_ERROR_NULL_POINTER
)
;
MOZ_ASSERT
(
data
-
>
capacity
(
)
>
=
data
-
>
len
(
)
+
SRTP_MAX_EXPANSION
)
;
int
out_len
;
nsresult
res
;
if
(
is_rtp
)
{
res
=
transport
.
send_srtp_
-
>
ProtectRtp
(
data
-
>
data
(
)
data
-
>
len
(
)
data
-
>
capacity
(
)
&
out_len
)
;
}
else
{
res
=
transport
.
send_srtp_
-
>
ProtectRtcp
(
data
-
>
data
(
)
data
-
>
len
(
)
data
-
>
capacity
(
)
&
out_len
)
;
}
if
(
!
NS_SUCCEEDED
(
res
)
)
{
return
res
;
}
data
-
>
SetLength
(
out_len
)
;
MOZ_MTLOG
(
ML_DEBUG
pipeline_
-
>
description_
<
<
"
sending
"
<
<
(
is_rtp
?
"
RTP
"
:
"
RTCP
"
)
<
<
"
packet
"
)
;
if
(
is_rtp
)
{
pipeline_
-
>
increment_rtp_packets_sent
(
out_len
)
;
}
else
{
pipeline_
-
>
increment_rtcp_packets_sent
(
)
;
}
return
pipeline_
-
>
SendPacket
(
transport
.
transport_
data
-
>
data
(
)
out_len
)
;
}
nsresult
MediaPipeline
:
:
PipelineTransport
:
:
SendRtcpPacket
(
const
void
*
data
int
len
)
{
nsAutoPtr
<
DataBuffer
>
buf
(
new
DataBuffer
(
static_cast
<
const
uint8_t
*
>
(
data
)
len
len
+
SRTP_MAX_EXPANSION
)
)
;
RUN_ON_THREAD
(
sts_thread_
WrapRunnable
(
RefPtr
<
MediaPipeline
:
:
PipelineTransport
>
(
this
)
&
MediaPipeline
:
:
PipelineTransport
:
:
SendRtpRtcpPacket_s
buf
false
)
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
UnsetTrackId
(
MediaStreamGraphImpl
*
graph
)
{
#
ifndef
USE_FAKE_MEDIA_STREAMS
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
PipelineListener
*
listener
)
:
ControlMessage
(
nullptr
)
listener_
(
listener
)
{
}
virtual
void
Run
(
)
override
{
listener_
-
>
UnsetTrackIdImpl
(
)
;
}
RefPtr
<
PipelineListener
>
listener_
;
}
;
graph
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
)
)
;
#
else
UnsetTrackIdImpl
(
)
;
#
endif
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
NotifyRealtimeTrackData
(
MediaStreamGraph
*
graph
StreamTime
offset
const
MediaSegment
&
media
)
{
MOZ_MTLOG
(
ML_DEBUG
"
MediaPipeline
:
:
NotifyRealtimeTrackData
(
)
listener
=
"
<
<
this
<
<
"
offset
=
"
<
<
offset
<
<
"
duration
=
"
<
<
media
.
GetDuration
(
)
)
;
NewData
(
graph
offset
media
)
;
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
NotifyQueuedChanges
(
MediaStreamGraph
*
graph
StreamTime
offset
const
MediaSegment
&
queued_media
)
{
MOZ_MTLOG
(
ML_DEBUG
"
MediaPipeline
:
:
NotifyQueuedChanges
(
)
"
)
;
if
(
!
direct_connect_
)
{
NewData
(
graph
offset
queued_media
)
;
}
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
NotifyDirectListenerInstalled
(
InstallationResult
aResult
)
{
MOZ_MTLOG
(
ML_INFO
"
MediaPipeline
:
:
NotifyDirectListenerInstalled
(
)
listener
=
"
<
<
this
<
<
"
result
=
"
<
<
static_cast
<
int32_t
>
(
aResult
)
)
;
direct_connect_
=
InstallationResult
:
:
SUCCESS
=
=
aResult
;
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
NotifyDirectListenerUninstalled
(
)
{
MOZ_MTLOG
(
ML_INFO
"
MediaPipeline
:
:
NotifyDirectListenerUninstalled
(
)
listener
=
"
<
<
this
)
;
direct_connect_
=
false
;
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
NewData
(
MediaStreamGraph
*
graph
StreamTime
offset
const
MediaSegment
&
media
)
{
if
(
!
active_
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
packets
because
transport
not
ready
"
)
;
return
;
}
if
(
conduit_
-
>
type
(
)
!
=
(
media
.
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
?
MediaSessionConduit
:
:
AUDIO
:
MediaSessionConduit
:
:
VIDEO
)
)
{
MOZ_ASSERT
(
false
"
The
media
type
should
always
be
correct
since
the
"
"
listener
is
locked
to
a
specific
track
"
)
;
return
;
}
if
(
media
.
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
)
{
AudioSegment
*
audio
=
const_cast
<
AudioSegment
*
>
(
static_cast
<
const
AudioSegment
*
>
(
&
media
)
)
;
AudioSegment
:
:
ChunkIterator
iter
(
*
audio
)
;
while
(
!
iter
.
IsEnded
(
)
)
{
TrackRate
rate
;
#
ifdef
USE_FAKE_MEDIA_STREAMS
rate
=
Fake_MediaStream
:
:
GraphRate
(
)
;
#
else
rate
=
graph
-
>
GraphRate
(
)
;
#
endif
ProcessAudioChunk
(
static_cast
<
AudioSessionConduit
*
>
(
conduit_
.
get
(
)
)
rate
*
iter
)
;
iter
.
Next
(
)
;
}
}
else
{
}
}
void
MediaPipelineTransmit
:
:
PipelineListener
:
:
ProcessAudioChunk
(
AudioSessionConduit
*
conduit
TrackRate
rate
AudioChunk
&
chunk
)
{
uint32_t
outputChannels
=
chunk
.
ChannelCount
(
)
=
=
1
?
1
:
2
;
const
int16_t
*
samples
=
nullptr
;
UniquePtr
<
int16_t
[
]
>
convertedSamples
;
if
(
enabled_
&
&
outputChannels
=
=
1
&
&
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_S16
)
{
samples
=
chunk
.
ChannelData
<
int16_t
>
(
)
.
Elements
(
)
[
0
]
;
}
else
{
convertedSamples
=
MakeUnique
<
int16_t
[
]
>
(
chunk
.
mDuration
*
outputChannels
)
;
if
(
!
enabled_
|
|
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_SILENCE
)
{
PodZero
(
convertedSamples
.
get
(
)
chunk
.
mDuration
*
outputChannels
)
;
}
else
if
(
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
DownmixAndInterleave
(
chunk
.
ChannelData
<
float
>
(
)
chunk
.
mDuration
chunk
.
mVolume
outputChannels
convertedSamples
.
get
(
)
)
;
}
else
if
(
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_S16
)
{
DownmixAndInterleave
(
chunk
.
ChannelData
<
int16_t
>
(
)
chunk
.
mDuration
chunk
.
mVolume
outputChannels
convertedSamples
.
get
(
)
)
;
}
samples
=
convertedSamples
.
get
(
)
;
}
MOZ_ASSERT
(
!
(
rate
%
100
)
)
;
uint32_t
audio_10ms
=
rate
/
100
;
if
(
!
packetizer_
|
|
packetizer_
-
>
PacketSize
(
)
!
=
audio_10ms
|
|
packetizer_
-
>
Channels
(
)
!
=
outputChannels
)
{
packetizer_
=
new
AudioPacketizer
<
int16_t
int16_t
>
(
audio_10ms
outputChannels
)
;
}
packetizer_
-
>
Input
(
samples
chunk
.
mDuration
)
;
while
(
packetizer_
-
>
PacketsAvailable
(
)
)
{
uint32_t
samplesPerPacket
=
packetizer_
-
>
PacketSize
(
)
*
packetizer_
-
>
Channels
(
)
;
int16_t
packet
[
AUDIO_SAMPLE_BUFFER_MAX
]
;
packetizer_
-
>
Output
(
packet
)
;
conduit
-
>
SendAudioFrame
(
packet
samplesPerPacket
rate
0
)
;
}
}
void
MediaPipelineTransmit
:
:
PipelineVideoSink
:
:
SetCurrentFrames
(
const
VideoSegment
&
aSegment
)
{
MOZ_ASSERT
(
pipelineListener_
)
;
if
(
!
pipelineListener_
-
>
active_
)
{
MOZ_MTLOG
(
ML_DEBUG
"
Discarding
packets
because
transport
not
ready
"
)
;
return
;
}
if
(
conduit_
-
>
type
(
)
!
=
MediaSessionConduit
:
:
VIDEO
)
{
return
;
}
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
VideoSegment
*
video
=
const_cast
<
VideoSegment
*
>
(
&
aSegment
)
;
VideoSegment
:
:
ChunkIterator
iter
(
*
video
)
;
while
(
!
iter
.
IsEnded
(
)
)
{
pipelineListener_
-
>
converter_
-
>
QueueVideoChunk
(
*
iter
!
pipelineListener_
-
>
enabled_
)
;
iter
.
Next
(
)
;
}
#
endif
}
class
TrackAddedCallback
{
public
:
virtual
void
TrackAdded
(
TrackTicks
current_ticks
)
=
0
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
TrackAddedCallback
)
;
protected
:
virtual
~
TrackAddedCallback
(
)
{
}
}
;
class
GenericReceiveListener
;
class
GenericReceiveCallback
:
public
TrackAddedCallback
{
public
:
explicit
GenericReceiveCallback
(
GenericReceiveListener
*
listener
)
:
listener_
(
listener
)
{
}
void
TrackAdded
(
TrackTicks
time
)
;
private
:
RefPtr
<
GenericReceiveListener
>
listener_
;
}
;
static
void
AddListener
(
MediaStream
*
source
MediaStreamListener
*
listener
)
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaStream
*
stream
MediaStreamListener
*
listener
)
:
ControlMessage
(
stream
)
listener_
(
listener
)
{
}
virtual
void
Run
(
)
override
{
mStream
-
>
AddListenerImpl
(
listener_
.
forget
(
)
)
;
}
private
:
RefPtr
<
MediaStreamListener
>
listener_
;
}
;
MOZ_ASSERT
(
listener
)
;
source
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
source
listener
)
)
;
#
else
source
-
>
AddListener
(
listener
)
;
#
endif
}
class
GenericReceiveListener
:
public
MediaStreamListener
{
public
:
GenericReceiveListener
(
SourceMediaStream
*
source
TrackID
track_id
)
:
source_
(
source
)
track_id_
(
track_id
)
played_ticks_
(
0
)
principal_handle_
(
PRINCIPAL_HANDLE_NONE
)
{
}
virtual
~
GenericReceiveListener
(
)
{
}
void
AddSelf
(
)
{
AddListener
(
source_
this
)
;
}
#
ifndef
USE_FAKE_MEDIA_STREAMS
void
SetPrincipalHandle_m
(
const
PrincipalHandle
&
principal_handle
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
GenericReceiveListener
*
listener
MediaStream
*
stream
const
PrincipalHandle
&
principal_handle
)
:
ControlMessage
(
stream
)
listener_
(
listener
)
principal_handle_
(
principal_handle
)
{
}
void
Run
(
)
override
{
listener_
-
>
SetPrincipalHandle_msg
(
principal_handle_
)
;
}
RefPtr
<
GenericReceiveListener
>
listener_
;
PrincipalHandle
principal_handle_
;
}
;
source_
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
source_
principal_handle
)
)
;
}
void
SetPrincipalHandle_msg
(
const
PrincipalHandle
&
principal_handle
)
{
principal_handle_
=
principal_handle
;
}
#
endif
protected
:
SourceMediaStream
*
source_
;
TrackID
track_id_
;
TrackTicks
played_ticks_
;
PrincipalHandle
principal_handle_
;
}
;
MediaPipelineReceive
:
:
MediaPipelineReceive
(
const
std
:
:
string
&
pc
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
SourceMediaStream
*
stream
const
std
:
:
string
&
track_id
int
level
RefPtr
<
MediaSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
:
MediaPipeline
(
pc
RECEIVE
main_thread
sts_thread
track_id
level
conduit
rtp_transport
rtcp_transport
filter
)
stream_
(
stream
)
segments_added_
(
0
)
{
MOZ_ASSERT
(
stream_
)
;
}
MediaPipelineReceive
:
:
~
MediaPipelineReceive
(
)
{
MOZ_ASSERT
(
!
stream_
)
;
}
class
MediaPipelineReceiveAudio
:
:
PipelineListener
:
public
GenericReceiveListener
{
public
:
PipelineListener
(
SourceMediaStream
*
source
TrackID
track_id
const
RefPtr
<
MediaSessionConduit
>
&
conduit
)
:
GenericReceiveListener
(
source
track_id
)
conduit_
(
conduit
)
{
}
~
PipelineListener
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsresult
rv
=
NS_DispatchToMainThread
(
new
ConduitDeleteEvent
(
conduit_
.
forget
(
)
)
)
;
MOZ_ASSERT
(
!
NS_FAILED
(
rv
)
"
Could
not
dispatch
conduit
shutdown
to
main
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
)
;
}
}
else
{
conduit_
=
nullptr
;
}
}
void
NotifyPull
(
MediaStreamGraph
*
graph
StreamTime
desired_time
)
override
{
MOZ_ASSERT
(
source_
)
;
if
(
!
source_
)
{
MOZ_MTLOG
(
ML_ERROR
"
NotifyPull
(
)
called
from
a
non
-
SourceMediaStream
"
)
;
return
;
}
while
(
source_
-
>
TicksToTimeRoundDown
(
WEBRTC_DEFAULT_SAMPLE_RATE
played_ticks_
)
<
desired_time
)
{
int16_t
scratch_buffer
[
AUDIO_SAMPLE_BUFFER_MAX
]
;
int
samples_length
;
MediaConduitErrorCode
err
=
static_cast
<
AudioSessionConduit
*
>
(
conduit_
.
get
(
)
)
-
>
GetAudioFrame
(
scratch_buffer
WEBRTC_DEFAULT_SAMPLE_RATE
0
samples_length
)
;
if
(
err
!
=
kMediaConduitNoError
)
{
MOZ_MTLOG
(
ML_ERROR
"
Audio
conduit
failed
(
"
<
<
err
<
<
"
)
to
return
data
"
<
<
played_ticks_
<
<
"
(
desired
"
<
<
desired_time
<
<
"
-
>
"
<
<
source_
-
>
StreamTimeToSeconds
(
desired_time
)
<
<
"
)
"
)
;
samples_length
=
WEBRTC_DEFAULT_SAMPLE_RATE
/
100
;
PodArrayZero
(
scratch_buffer
)
;
}
MOZ_ASSERT
(
samples_length
*
sizeof
(
uint16_t
)
<
AUDIO_SAMPLE_BUFFER_MAX
)
;
MOZ_MTLOG
(
ML_DEBUG
"
Audio
conduit
returned
buffer
of
length
"
<
<
samples_length
)
;
RefPtr
<
SharedBuffer
>
samples
=
SharedBuffer
:
:
Create
(
samples_length
*
sizeof
(
uint16_t
)
)
;
int16_t
*
samples_data
=
static_cast
<
int16_t
*
>
(
samples
-
>
Data
(
)
)
;
AudioSegment
segment
;
uint32_t
channelCount
=
samples_length
/
(
WEBRTC_DEFAULT_SAMPLE_RATE
/
100
)
;
AutoTArray
<
int16_t
*
2
>
channels
;
AutoTArray
<
const
int16_t
*
2
>
outputChannels
;
size_t
frames
=
samples_length
/
channelCount
;
channels
.
SetLength
(
channelCount
)
;
size_t
offset
=
0
;
for
(
size_t
i
=
0
;
i
<
channelCount
;
i
+
+
)
{
channels
[
i
]
=
samples_data
+
offset
;
offset
+
=
frames
;
}
DeinterleaveAndConvertBuffer
(
scratch_buffer
frames
channelCount
channels
.
Elements
(
)
)
;
outputChannels
.
AppendElements
(
channels
)
;
segment
.
AppendFrames
(
samples
.
forget
(
)
outputChannels
frames
principal_handle_
)
;
if
(
source_
-
>
AppendToTrack
(
track_id_
&
segment
)
)
{
played_ticks_
+
=
frames
;
}
else
{
MOZ_MTLOG
(
ML_ERROR
"
AppendToTrack
failed
"
)
;
return
;
}
}
}
private
:
RefPtr
<
MediaSessionConduit
>
conduit_
;
}
;
MediaPipelineReceiveAudio
:
:
MediaPipelineReceiveAudio
(
const
std
:
:
string
&
pc
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
SourceMediaStream
*
stream
const
std
:
:
string
&
media_stream_track_id
TrackID
numeric_track_id
int
level
RefPtr
<
AudioSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
:
MediaPipelineReceive
(
pc
main_thread
sts_thread
stream
media_stream_track_id
level
conduit
rtp_transport
rtcp_transport
filter
)
listener_
(
new
PipelineListener
(
stream
numeric_track_id
conduit
)
)
{
}
void
MediaPipelineReceiveAudio
:
:
DetachMedia
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
if
(
stream_
)
{
stream_
-
>
RemoveListener
(
listener_
)
;
stream_
=
nullptr
;
}
}
nsresult
MediaPipelineReceiveAudio
:
:
Init
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
MOZ_MTLOG
(
ML_DEBUG
__FUNCTION__
)
;
description_
=
pc_
+
"
|
Receive
audio
[
"
;
description_
+
=
track_id_
;
description_
+
=
"
]
"
;
listener_
-
>
AddSelf
(
)
;
return
MediaPipelineReceive
:
:
Init
(
)
;
}
#
ifndef
USE_FAKE_MEDIA_STREAMS
void
MediaPipelineReceiveAudio
:
:
SetPrincipalHandle_m
(
const
PrincipalHandle
&
principal_handle
)
{
listener_
-
>
SetPrincipalHandle_m
(
principal_handle
)
;
}
#
endif
class
MediaPipelineReceiveVideo
:
:
PipelineListener
:
public
GenericReceiveListener
{
public
:
PipelineListener
(
SourceMediaStream
*
source
TrackID
track_id
)
:
GenericReceiveListener
(
source
track_id
)
width_
(
0
)
height_
(
0
)
#
if
defined
(
MOZILLA_INTERNAL_API
)
image_container_
(
)
image_
(
)
#
endif
monitor_
(
"
Video
PipelineListener
"
)
{
#
if
!
defined
(
MOZILLA_EXTERNAL_LINKAGE
)
image_container_
=
LayerManager
:
:
CreateImageContainer
(
ImageContainer
:
:
ASYNCHRONOUS
)
;
#
endif
}
void
NotifyPull
(
MediaStreamGraph
*
graph
StreamTime
desired_time
)
override
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
ReentrantMonitorAutoEnter
enter
(
monitor_
)
;
RefPtr
<
Image
>
image
=
image_
;
StreamTime
delta
=
desired_time
-
played_ticks_
;
if
(
delta
>
0
)
{
VideoSegment
segment
;
segment
.
AppendFrame
(
image
.
forget
(
)
delta
IntSize
(
width_
height_
)
principal_handle_
)
;
if
(
source_
-
>
AppendToTrack
(
track_id_
&
segment
)
)
{
played_ticks_
=
desired_time
;
}
else
{
MOZ_MTLOG
(
ML_ERROR
"
AppendToTrack
failed
"
)
;
return
;
}
}
#
endif
}
void
FrameSizeChange
(
unsigned
int
width
unsigned
int
height
unsigned
int
number_of_streams
)
{
ReentrantMonitorAutoEnter
enter
(
monitor_
)
;
width_
=
width
;
height_
=
height
;
}
void
RenderVideoFrame
(
const
unsigned
char
*
buffer
size_t
buffer_size
uint32_t
time_stamp
int64_t
render_time
const
RefPtr
<
layers
:
:
Image
>
&
video_image
)
{
RenderVideoFrame
(
buffer
buffer_size
width_
(
width_
+
1
)
>
>
1
time_stamp
render_time
video_image
)
;
}
void
RenderVideoFrame
(
const
unsigned
char
*
buffer
size_t
buffer_size
uint32_t
y_stride
uint32_t
cbcr_stride
uint32_t
time_stamp
int64_t
render_time
const
RefPtr
<
layers
:
:
Image
>
&
video_image
)
{
#
ifdef
MOZILLA_INTERNAL_API
ReentrantMonitorAutoEnter
enter
(
monitor_
)
;
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
if
(
buffer
)
{
#
ifdef
MOZ_WIDGET_GONK
RefPtr
<
PlanarYCbCrImage
>
yuvImage
=
new
GrallocImage
(
)
;
#
else
RefPtr
<
PlanarYCbCrImage
>
yuvImage
=
image_container_
-
>
CreatePlanarYCbCrImage
(
)
;
#
endif
uint8_t
*
frame
=
const_cast
<
uint8_t
*
>
(
static_cast
<
const
uint8_t
*
>
(
buffer
)
)
;
PlanarYCbCrData
yuvData
;
yuvData
.
mYChannel
=
frame
;
yuvData
.
mYSize
=
IntSize
(
y_stride
height_
)
;
yuvData
.
mYStride
=
y_stride
;
yuvData
.
mCbCrStride
=
cbcr_stride
;
yuvData
.
mCbChannel
=
frame
+
height_
*
yuvData
.
mYStride
;
yuvData
.
mCrChannel
=
yuvData
.
mCbChannel
+
(
(
height_
+
1
)
>
>
1
)
*
yuvData
.
mCbCrStride
;
yuvData
.
mCbCrSize
=
IntSize
(
yuvData
.
mCbCrStride
(
height_
+
1
)
>
>
1
)
;
yuvData
.
mPicX
=
0
;
yuvData
.
mPicY
=
0
;
yuvData
.
mPicSize
=
IntSize
(
width_
height_
)
;
yuvData
.
mStereoMode
=
StereoMode
:
:
MONO
;
if
(
!
yuvImage
-
>
CopyData
(
yuvData
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
image_
=
yuvImage
;
}
#
ifdef
WEBRTC_GONK
else
{
MOZ_ASSERT
(
video_image
)
;
image_
=
video_image
;
}
#
endif
#
endif
}
private
:
int
width_
;
int
height_
;
#
if
defined
(
MOZILLA_INTERNAL_API
)
RefPtr
<
layers
:
:
ImageContainer
>
image_container_
;
RefPtr
<
layers
:
:
Image
>
image_
;
#
endif
mozilla
:
:
ReentrantMonitor
monitor_
;
}
;
class
MediaPipelineReceiveVideo
:
:
PipelineRenderer
:
public
VideoRenderer
{
public
:
explicit
PipelineRenderer
(
MediaPipelineReceiveVideo
*
pipeline
)
:
pipeline_
(
pipeline
)
{
}
void
Detach
(
)
{
pipeline_
=
nullptr
;
}
void
FrameSizeChange
(
unsigned
int
width
unsigned
int
height
unsigned
int
number_of_streams
)
override
{
pipeline_
-
>
listener_
-
>
FrameSizeChange
(
width
height
number_of_streams
)
;
}
void
RenderVideoFrame
(
const
unsigned
char
*
buffer
size_t
buffer_size
uint32_t
time_stamp
int64_t
render_time
const
ImageHandle
&
handle
)
override
{
pipeline_
-
>
listener_
-
>
RenderVideoFrame
(
buffer
buffer_size
time_stamp
render_time
handle
.
GetImage
(
)
)
;
}
void
RenderVideoFrame
(
const
unsigned
char
*
buffer
size_t
buffer_size
uint32_t
y_stride
uint32_t
cbcr_stride
uint32_t
time_stamp
int64_t
render_time
const
ImageHandle
&
handle
)
override
{
pipeline_
-
>
listener_
-
>
RenderVideoFrame
(
buffer
buffer_size
y_stride
cbcr_stride
time_stamp
render_time
handle
.
GetImage
(
)
)
;
}
private
:
MediaPipelineReceiveVideo
*
pipeline_
;
}
;
MediaPipelineReceiveVideo
:
:
MediaPipelineReceiveVideo
(
const
std
:
:
string
&
pc
nsCOMPtr
<
nsIEventTarget
>
main_thread
nsCOMPtr
<
nsIEventTarget
>
sts_thread
SourceMediaStream
*
stream
const
std
:
:
string
&
media_stream_track_id
TrackID
numeric_track_id
int
level
RefPtr
<
VideoSessionConduit
>
conduit
RefPtr
<
TransportFlow
>
rtp_transport
RefPtr
<
TransportFlow
>
rtcp_transport
nsAutoPtr
<
MediaPipelineFilter
>
filter
)
:
MediaPipelineReceive
(
pc
main_thread
sts_thread
stream
media_stream_track_id
level
conduit
rtp_transport
rtcp_transport
filter
)
renderer_
(
new
PipelineRenderer
(
this
)
)
listener_
(
new
PipelineListener
(
stream
numeric_track_id
)
)
{
}
void
MediaPipelineReceiveVideo
:
:
DetachMedia
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
static_cast
<
VideoSessionConduit
*
>
(
conduit_
.
get
(
)
)
-
>
DetachRenderer
(
)
;
if
(
stream_
)
{
stream_
-
>
RemoveListener
(
listener_
)
;
stream_
=
nullptr
;
}
}
nsresult
MediaPipelineReceiveVideo
:
:
Init
(
)
{
ASSERT_ON_THREAD
(
main_thread_
)
;
MOZ_MTLOG
(
ML_DEBUG
__FUNCTION__
)
;
description_
=
pc_
+
"
|
Receive
video
[
"
;
description_
+
=
track_id_
;
description_
+
=
"
]
"
;
#
if
defined
(
MOZILLA_INTERNAL_API
)
listener_
-
>
AddSelf
(
)
;
#
endif
static_cast
<
VideoSessionConduit
*
>
(
conduit_
.
get
(
)
)
-
>
AttachRenderer
(
renderer_
)
;
return
MediaPipelineReceive
:
:
Init
(
)
;
}
#
ifndef
USE_FAKE_MEDIA_STREAMS
void
MediaPipelineReceiveVideo
:
:
SetPrincipalHandle_m
(
const
PrincipalHandle
&
principal_handle
)
{
listener_
-
>
SetPrincipalHandle_m
(
principal_handle
)
;
}
#
endif
}
