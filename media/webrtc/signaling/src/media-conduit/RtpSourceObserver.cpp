#
include
"
RtpSourceObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
clock
.
h
"
#
include
"
webrtc
/
modules
/
include
/
module_common_types
.
h
"
namespace
mozilla
{
using
EntryType
=
dom
:
:
RTCRtpSourceEntryType
;
double
RtpSourceObserver
:
:
RtpSourceEntry
:
:
ToLinearAudioLevel
(
)
const
{
if
(
audioLevel
=
=
127
)
{
return
0
;
}
return
std
:
:
pow
(
10
-
static_cast
<
double
>
(
audioLevel
)
/
20
)
;
}
RtpSourceObserver
:
:
RtpSourceObserver
(
)
:
mMaxJitterWindow
(
0
)
mLevelGuard
(
"
RtpSourceObserver
:
:
mLevelGuard
"
)
{
}
void
RtpSourceObserver
:
:
OnRtpPacket
(
const
webrtc
:
:
RTPHeader
&
aHeader
const
int64_t
aTimestamp
const
uint32_t
aJitter
)
{
MutexAutoLock
lock
(
mLevelGuard
)
;
{
mMaxJitterWindow
=
std
:
:
max
(
mMaxJitterWindow
static_cast
<
int64_t
>
(
aJitter
)
*
2
)
;
const
auto
jitterAdjusted
=
aTimestamp
+
aJitter
;
auto
&
hist
=
mRtpSources
[
GetKey
(
aHeader
.
ssrc
EntryType
:
:
Synchronization
)
]
;
hist
.
Prune
(
aTimestamp
)
;
hist
.
Insert
(
aTimestamp
jitterAdjusted
aHeader
.
timestamp
aHeader
.
extension
.
hasAudioLevel
aHeader
.
extension
.
audioLevel
)
;
const
auto
&
list
=
aHeader
.
extension
.
csrcAudioLevels
;
for
(
uint8_t
i
=
0
;
i
<
aHeader
.
numCSRCs
;
i
+
+
)
{
const
uint32_t
&
csrc
=
aHeader
.
arrOfCSRCs
[
i
]
;
auto
&
hist
=
mRtpSources
[
GetKey
(
csrc
EntryType
:
:
Contributing
)
]
;
hist
.
Prune
(
aTimestamp
)
;
bool
hasLevel
=
i
<
list
.
numAudioLevels
;
uint8_t
level
=
hasLevel
?
list
.
arrOfAudioLevels
[
i
]
:
0
;
hist
.
Insert
(
aTimestamp
jitterAdjusted
aHeader
.
timestamp
hasLevel
level
)
;
}
}
}
void
RtpSourceObserver
:
:
GetRtpSources
(
const
int64_t
aTimeNow
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
&
outSources
)
const
{
MutexAutoLock
lock
(
mLevelGuard
)
;
outSources
.
Clear
(
)
;
for
(
const
auto
&
it
:
mRtpSources
)
{
const
RtpSourceEntry
*
entry
=
it
.
second
.
FindClosestNotAfter
(
aTimeNow
)
;
if
(
entry
)
{
dom
:
:
RTCRtpSourceEntry
domEntry
;
domEntry
.
mSource
=
GetSourceFromKey
(
it
.
first
)
;
domEntry
.
mSourceType
=
GetTypeFromKey
(
it
.
first
)
;
domEntry
.
mTimestamp
=
entry
-
>
jitterAdjustedTimestamp
;
domEntry
.
mRtpTimestamp
=
entry
-
>
rtpTimestamp
;
if
(
entry
-
>
hasAudioLevel
)
{
domEntry
.
mAudioLevel
.
Construct
(
entry
-
>
ToLinearAudioLevel
(
)
)
;
}
outSources
.
AppendElement
(
std
:
:
move
(
domEntry
)
)
;
}
}
}
int64_t
RtpSourceObserver
:
:
NowInReportClockTime
(
)
{
return
webrtc
:
:
Clock
:
:
GetRealTimeClock
(
)
-
>
TimeInMilliseconds
(
)
;
}
const
RtpSourceObserver
:
:
RtpSourceEntry
*
RtpSourceObserver
:
:
RtpSourceHistory
:
:
FindClosestNotAfter
(
int64_t
aTime
)
const
{
auto
lastFound
=
mDetailedHistory
.
cbegin
(
)
;
bool
found
=
false
;
for
(
const
auto
&
it
:
mDetailedHistory
)
{
if
(
it
.
second
.
jitterAdjustedTimestamp
>
aTime
)
{
break
;
}
if
(
found
)
{
lastFound
+
+
;
}
found
=
true
;
}
if
(
found
)
{
return
&
lastFound
-
>
second
;
}
if
(
HasEvicted
(
)
&
&
aTime
>
=
mLatestEviction
.
jitterAdjustedTimestamp
)
{
return
&
mLatestEviction
;
}
return
nullptr
;
}
void
RtpSourceObserver
:
:
RtpSourceHistory
:
:
Prune
(
const
int64_t
aTimeNow
)
{
const
auto
aTimeT
=
aTimeNow
-
mMaxJitterWindow
;
const
auto
aTimePrehistory
=
aTimeNow
-
kHistoryWindow
;
bool
found
=
false
;
auto
lower
=
mDetailedHistory
.
begin
(
)
;
for
(
auto
&
it
:
mDetailedHistory
)
{
if
(
it
.
second
.
jitterAdjustedTimestamp
>
aTimeT
)
{
found
=
true
;
break
;
}
if
(
found
)
{
lower
+
+
;
}
found
=
true
;
}
if
(
found
)
{
if
(
lower
-
>
second
.
jitterAdjustedTimestamp
>
aTimePrehistory
)
{
mLatestEviction
=
lower
-
>
second
;
mHasEvictedEntry
=
true
;
}
lower
+
+
;
mDetailedHistory
.
erase
(
mDetailedHistory
.
begin
(
)
lower
)
;
}
if
(
HasEvicted
(
)
&
&
(
mLatestEviction
.
jitterAdjustedTimestamp
+
kHistoryWindow
)
<
aTimeNow
)
{
mHasEvictedEntry
=
false
;
}
}
void
RtpSourceObserver
:
:
RtpSourceHistory
:
:
Insert
(
const
int64_t
aTimeNow
const
int64_t
aTimestamp
const
uint32_t
aRtpTimestamp
const
bool
aHasAudioLevel
const
uint8_t
aAudioLevel
)
{
Insert
(
aTimeNow
aTimestamp
)
.
Update
(
aTimestamp
aRtpTimestamp
aHasAudioLevel
aAudioLevel
)
;
}
RtpSourceObserver
:
:
RtpSourceEntry
&
RtpSourceObserver
:
:
RtpSourceHistory
:
:
Insert
(
const
int64_t
aTimeNow
const
int64_t
aTimestamp
)
{
if
(
(
aTimestamp
+
kHistoryWindow
)
<
aTimeNow
|
|
aTimestamp
<
mLatestEviction
.
jitterAdjustedTimestamp
)
{
return
mPrehistory
;
}
mMaxJitterWindow
=
std
:
:
max
(
mMaxJitterWindow
(
aTimestamp
-
aTimeNow
)
*
2
)
;
const
int64_t
aTimeT
=
aTimeNow
-
mMaxJitterWindow
;
if
(
aTimestamp
<
aTimeT
)
{
mHasEvictedEntry
=
true
;
return
mLatestEviction
;
}
return
mDetailedHistory
[
aTimestamp
]
;
}
}
