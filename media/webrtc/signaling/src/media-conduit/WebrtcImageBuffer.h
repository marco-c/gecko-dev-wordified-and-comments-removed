#
ifndef
WebrtcImageBuffer_h__
#
define
WebrtcImageBuffer_h__
#
include
"
webrtc
/
common_video
/
include
/
video_frame_buffer
.
h
"
#
include
"
webrtc
/
rtc_base
/
keep_ref_until_done
.
h
"
namespace
mozilla
{
namespace
layers
{
class
Image
;
}
class
ImageBuffer
:
public
webrtc
:
:
VideoFrameBuffer
{
public
:
explicit
ImageBuffer
(
RefPtr
<
layers
:
:
Image
>
&
&
aImage
)
:
mImage
(
std
:
:
move
(
aImage
)
)
{
}
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420BufferInterface
>
ToI420
(
)
override
{
RefPtr
<
layers
:
:
PlanarYCbCrImage
>
image
=
mImage
-
>
AsPlanarYCbCrImage
(
)
;
MOZ_ASSERT
(
image
)
;
if
(
!
image
)
{
return
nullptr
;
}
const
layers
:
:
PlanarYCbCrData
*
data
=
image
-
>
GetData
(
)
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420BufferInterface
>
buf
(
new
rtc
:
:
RefCountedObject
<
webrtc
:
:
WrappedI420Buffer
>
(
data
-
>
mPicSize
.
width
data
-
>
mPicSize
.
height
data
-
>
mYChannel
data
-
>
mYStride
data
-
>
mCbChannel
data
-
>
mCbCrStride
data
-
>
mCrChannel
data
-
>
mCbCrStride
rtc
:
:
KeepRefUntilDone
(
image
.
get
(
)
)
)
)
;
return
buf
;
}
Type
type
(
)
const
override
{
return
Type
:
:
kNative
;
}
int
width
(
)
const
override
{
return
mImage
-
>
GetSize
(
)
.
width
;
}
int
height
(
)
const
override
{
return
mImage
-
>
GetSize
(
)
.
height
;
}
RefPtr
<
layers
:
:
Image
>
GetNativeImage
(
)
const
{
return
mImage
;
}
private
:
const
RefPtr
<
layers
:
:
Image
>
mImage
;
}
;
}
#
endif
