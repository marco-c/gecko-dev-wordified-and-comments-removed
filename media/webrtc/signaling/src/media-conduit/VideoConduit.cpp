#
include
"
CSFLog
.
h
"
#
include
"
nspr
.
h
"
#
include
"
plstr
.
h
"
#
include
"
VideoConduit
.
h
"
#
include
"
AudioConduit
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
LoadManager
.
h
"
#
include
"
YuvStamper
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
webrtc
/
common_types
.
h
"
#
include
"
webrtc
/
common_video
/
interface
/
native_handle
.
h
"
#
include
"
webrtc
/
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
include
"
webrtc
/
video_engine
/
include
/
vie_errors
.
h
"
#
include
"
webrtc
/
video_engine
/
vie_defines
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidJNIWrapper
.
h
"
#
endif
#
ifdef
_MSC_VER
#
include
"
Winsock2
.
h
"
#
else
#
include
<
netinet
/
in
.
h
>
#
endif
#
include
<
algorithm
>
#
include
<
math
.
h
>
#
define
DEFAULT_VIDEO_MAX_FRAMERATE
30
#
define
INVALID_RTP_PAYLOAD
255
/
/
valid
payload
types
are
0
to
127
namespace
mozilla
{
static
const
char
*
logTag
=
"
WebrtcVideoSessionConduit
"
;
const
unsigned
int
WebrtcVideoConduit
:
:
CODEC_PLNAME_SIZE
=
32
;
template
<
typename
T
>
T
MinIgnoreZero
(
const
T
&
a
const
T
&
b
)
{
return
std
:
:
min
(
a
?
a
:
b
b
?
b
:
a
)
;
}
RefPtr
<
VideoSessionConduit
>
VideoSessionConduit
:
:
Create
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
CSFLogDebug
(
logTag
"
%
s
"
__FUNCTION__
)
;
WebrtcVideoConduit
*
obj
=
new
WebrtcVideoConduit
(
)
;
if
(
obj
-
>
Init
(
)
!
=
kMediaConduitNoError
)
{
CSFLogError
(
logTag
"
%
s
VideoConduit
Init
Failed
"
__FUNCTION__
)
;
delete
obj
;
return
nullptr
;
}
CSFLogDebug
(
logTag
"
%
s
Successfully
created
VideoConduit
"
__FUNCTION__
)
;
return
obj
;
}
WebrtcVideoConduit
:
:
WebrtcVideoConduit
(
)
:
mVideoEngine
(
nullptr
)
mTransportMonitor
(
"
WebrtcVideoConduit
"
)
mTransmitterTransport
(
nullptr
)
mReceiverTransport
(
nullptr
)
mRenderer
(
nullptr
)
mPtrExtCapture
(
nullptr
)
mEngineTransmitting
(
false
)
mEngineReceiving
(
false
)
mChannel
(
-
1
)
mCapId
(
-
1
)
mCodecMutex
(
"
VideoConduit
codec
db
"
)
mInReconfig
(
false
)
mLastWidth
(
0
)
mLastHeight
(
0
)
mSendingWidth
(
0
)
mSendingHeight
(
0
)
mReceivingWidth
(
0
)
mReceivingHeight
(
0
)
mSendingFramerate
(
DEFAULT_VIDEO_MAX_FRAMERATE
)
mLastFramerateTenths
(
DEFAULT_VIDEO_MAX_FRAMERATE
*
10
)
mNumReceivingStreams
(
1
)
mVideoLatencyTestEnable
(
false
)
mVideoLatencyAvg
(
0
)
mMinBitrate
(
0
)
mStartBitrate
(
0
)
mPrefMaxBitrate
(
0
)
mNegotiatedMaxBitrate
(
0
)
mMinBitrateEstimate
(
0
)
mRtpStreamIdEnabled
(
false
)
mRtpStreamIdExtId
(
0
)
mCodecMode
(
webrtc
:
:
kRealtimeVideo
)
{
}
WebrtcVideoConduit
:
:
~
WebrtcVideoConduit
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
CSFLogDebug
(
logTag
"
%
s
"
__FUNCTION__
)
;
SyncTo
(
nullptr
)
;
Destroy
(
)
;
}
bool
WebrtcVideoConduit
:
:
SetLocalSSRC
(
unsigned
int
ssrc
)
{
unsigned
int
oldSsrc
;
if
(
!
GetLocalSSRC
(
&
oldSsrc
)
)
{
MOZ_ASSERT
(
false
"
GetLocalSSRC
failed
"
)
;
return
false
;
}
if
(
oldSsrc
=
=
ssrc
)
{
return
true
;
}
bool
wasTransmitting
=
mEngineTransmitting
;
if
(
StopTransmitting
(
)
!
=
kMediaConduitNoError
)
{
return
false
;
}
if
(
mPtrRTP
-
>
SetLocalSSRC
(
mChannel
ssrc
)
)
{
return
false
;
}
if
(
wasTransmitting
)
{
if
(
StartTransmitting
(
)
!
=
kMediaConduitNoError
)
{
return
false
;
}
}
return
true
;
}
bool
WebrtcVideoConduit
:
:
GetLocalSSRC
(
unsigned
int
*
ssrc
)
{
return
!
mPtrRTP
-
>
GetLocalSSRC
(
mChannel
*
ssrc
)
;
}
bool
WebrtcVideoConduit
:
:
GetRemoteSSRC
(
unsigned
int
*
ssrc
)
{
return
!
mPtrRTP
-
>
GetRemoteSSRC
(
mChannel
*
ssrc
)
;
}
bool
WebrtcVideoConduit
:
:
SetLocalCNAME
(
const
char
*
cname
)
{
char
temp
[
256
]
;
strncpy
(
temp
cname
sizeof
(
temp
)
-
1
)
;
temp
[
sizeof
(
temp
)
-
1
]
=
0
;
return
!
mPtrRTP
-
>
SetRTCPCName
(
mChannel
temp
)
;
}
bool
WebrtcVideoConduit
:
:
GetVideoEncoderStats
(
double
*
framerateMean
double
*
framerateStdDev
double
*
bitrateMean
double
*
bitrateStdDev
uint32_t
*
droppedFrames
)
{
if
(
!
mEngineTransmitting
)
{
return
false
;
}
MOZ_ASSERT
(
mVideoCodecStat
)
;
mVideoCodecStat
-
>
GetEncoderStats
(
framerateMean
framerateStdDev
bitrateMean
bitrateStdDev
droppedFrames
)
;
double
framerate
=
mLastFramerateTenths
/
10
.
0
;
if
(
std
:
:
abs
(
*
framerateMean
-
framerate
)
/
framerate
>
0
.
1
&
&
*
framerateMean
>
=
0
.
5
)
{
CSFLogDebug
(
logTag
"
Encoder
frame
rate
changed
from
%
f
to
%
f
"
(
mLastFramerateTenths
/
10
.
0
)
*
framerateMean
)
;
MutexAutoLock
lock
(
mCodecMutex
)
;
mLastFramerateTenths
=
*
framerateMean
*
10
;
SelectSendResolution
(
mSendingWidth
mSendingHeight
nullptr
)
;
}
return
true
;
}
bool
WebrtcVideoConduit
:
:
GetVideoDecoderStats
(
double
*
framerateMean
double
*
framerateStdDev
double
*
bitrateMean
double
*
bitrateStdDev
uint32_t
*
discardedPackets
)
{
if
(
!
mEngineReceiving
)
{
return
false
;
}
MOZ_ASSERT
(
mVideoCodecStat
)
;
mVideoCodecStat
-
>
GetDecoderStats
(
framerateMean
framerateStdDev
bitrateMean
bitrateStdDev
discardedPackets
)
;
return
true
;
}
bool
WebrtcVideoConduit
:
:
GetAVStats
(
int32_t
*
jitterBufferDelayMs
int32_t
*
playoutBufferDelayMs
int32_t
*
avSyncOffsetMs
)
{
return
false
;
}
bool
WebrtcVideoConduit
:
:
GetRTPStats
(
unsigned
int
*
jitterMs
unsigned
int
*
cumulativeLost
)
{
unsigned
short
fractionLost
;
unsigned
extendedMax
;
int64_t
rttMs
;
return
!
mPtrRTP
-
>
GetReceivedRTCPStatistics
(
mChannel
fractionLost
*
cumulativeLost
extendedMax
*
jitterMs
rttMs
)
;
}
bool
WebrtcVideoConduit
:
:
GetRTCPReceiverReport
(
DOMHighResTimeStamp
*
timestamp
uint32_t
*
jitterMs
uint32_t
*
packetsReceived
uint64_t
*
bytesReceived
uint32_t
*
cumulativeLost
int32_t
*
rttMs
)
{
uint32_t
ntpHigh
ntpLow
;
uint16_t
fractionLost
;
bool
result
=
!
mPtrRTP
-
>
GetRemoteRTCPReceiverInfo
(
mChannel
ntpHigh
ntpLow
*
packetsReceived
*
bytesReceived
jitterMs
&
fractionLost
cumulativeLost
rttMs
)
;
if
(
result
)
{
*
timestamp
=
NTPtoDOMHighResTimeStamp
(
ntpHigh
ntpLow
)
;
}
return
result
;
}
bool
WebrtcVideoConduit
:
:
GetRTCPSenderReport
(
DOMHighResTimeStamp
*
timestamp
unsigned
int
*
packetsSent
uint64_t
*
bytesSent
)
{
struct
webrtc
:
:
SenderInfo
senderInfo
;
bool
result
=
!
mPtrRTP
-
>
GetRemoteRTCPSenderInfo
(
mChannel
&
senderInfo
)
;
if
(
result
)
{
*
timestamp
=
NTPtoDOMHighResTimeStamp
(
senderInfo
.
NTP_timestamp_high
senderInfo
.
NTP_timestamp_low
)
;
*
packetsSent
=
senderInfo
.
sender_packet_count
;
*
bytesSent
=
senderInfo
.
sender_octet_count
;
}
return
result
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
InitMain
(
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPrefService
>
prefs
=
do_GetService
(
"
mozilla
.
org
/
preferences
-
service
;
1
"
&
rv
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
nsCOMPtr
<
nsIPrefBranch
>
branch
=
do_QueryInterface
(
prefs
)
;
if
(
branch
)
{
int32_t
temp
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
branch
-
>
GetBoolPref
(
"
media
.
video
.
test_latency
"
&
mVideoLatencyTestEnable
)
)
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
branch
-
>
GetIntPref
(
"
media
.
peerconnection
.
video
.
min_bitrate
"
&
temp
)
)
)
)
{
if
(
temp
>
=
0
)
{
mMinBitrate
=
temp
;
}
}
if
(
!
NS_WARN_IF
(
NS_FAILED
(
branch
-
>
GetIntPref
(
"
media
.
peerconnection
.
video
.
start_bitrate
"
&
temp
)
)
)
)
{
if
(
temp
>
=
0
)
{
mStartBitrate
=
temp
;
}
}
if
(
!
NS_WARN_IF
(
NS_FAILED
(
branch
-
>
GetIntPref
(
"
media
.
peerconnection
.
video
.
max_bitrate
"
&
temp
)
)
)
)
{
if
(
temp
>
=
0
)
{
mPrefMaxBitrate
=
temp
;
mNegotiatedMaxBitrate
=
temp
;
}
}
if
(
mMinBitrate
!
=
0
&
&
mMinBitrate
<
webrtc
:
:
kViEMinCodecBitrate
)
{
mMinBitrate
=
webrtc
:
:
kViEMinCodecBitrate
;
}
if
(
mStartBitrate
<
mMinBitrate
)
{
mStartBitrate
=
mMinBitrate
;
}
if
(
mPrefMaxBitrate
&
&
mStartBitrate
>
mPrefMaxBitrate
)
{
mStartBitrate
=
mPrefMaxBitrate
;
}
if
(
!
NS_WARN_IF
(
NS_FAILED
(
branch
-
>
GetIntPref
(
"
media
.
peerconnection
.
video
.
min_bitrate_estimate
"
&
temp
)
)
)
)
{
if
(
temp
>
=
0
)
{
mMinBitrateEstimate
=
temp
;
}
}
bool
use_loadmanager
=
false
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
branch
-
>
GetBoolPref
(
"
media
.
navigator
.
load_adapt
"
&
use_loadmanager
)
)
)
)
{
if
(
use_loadmanager
)
{
mLoadManager
=
LoadManagerBuild
(
)
;
}
}
}
}
#
ifdef
MOZ_WIDGET_ANDROID
JavaVM
*
jvm
=
jsjni_GetVM
(
)
;
if
(
webrtc
:
:
VideoEngine
:
:
SetAndroidObjects
(
jvm
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
:
could
not
set
Android
objects
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
#
endif
#
endif
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
Init
(
)
{
CSFLogDebug
(
logTag
"
%
s
this
=
%
p
"
__FUNCTION__
this
)
;
MediaConduitErrorCode
result
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
result
=
InitMain
(
)
;
if
(
result
!
=
kMediaConduitNoError
)
{
return
result
;
}
mVideoEngine
=
webrtc
:
:
VideoEngine
:
:
Create
(
)
;
if
(
!
mVideoEngine
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
create
video
engine
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
if
(
!
(
mPtrViEBase
=
ViEBase
:
:
GetInterface
(
mVideoEngine
)
)
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
get
video
base
interface
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
if
(
!
(
mPtrViECapture
=
ViECapture
:
:
GetInterface
(
mVideoEngine
)
)
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
get
video
capture
interface
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
if
(
!
(
mPtrViECodec
=
ViECodec
:
:
GetInterface
(
mVideoEngine
)
)
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
get
video
codec
interface
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
if
(
!
(
mPtrViENetwork
=
ViENetwork
:
:
GetInterface
(
mVideoEngine
)
)
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
get
video
network
interface
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
if
(
!
(
mPtrViERender
=
ViERender
:
:
GetInterface
(
mVideoEngine
)
)
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
get
video
render
interface
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
mPtrExtCodec
=
webrtc
:
:
ViEExternalCodec
:
:
GetInterface
(
mVideoEngine
)
;
if
(
!
mPtrExtCodec
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
get
external
codec
interface
:
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitSessionNotInited
;
}
if
(
!
(
mPtrRTP
=
webrtc
:
:
ViERTP_RTCP
:
:
GetInterface
(
mVideoEngine
)
)
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
get
video
RTCP
interface
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
if
(
!
(
mPtrExtCodec
=
webrtc
:
:
ViEExternalCodec
:
:
GetInterface
(
mVideoEngine
)
)
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
get
external
codec
interface
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitSessionNotInited
;
}
CSFLogDebug
(
logTag
"
%
s
Engine
Created
:
Init
'
ng
the
interfaces
"
__FUNCTION__
)
;
if
(
mPtrViEBase
-
>
Init
(
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Video
Engine
Init
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitSessionNotInited
;
}
if
(
mPtrViEBase
-
>
CreateChannel
(
mChannel
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Channel
creation
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitChannelError
;
}
if
(
mPtrViENetwork
-
>
RegisterSendTransport
(
mChannel
*
this
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
ViENetwork
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitTransportRegistrationFail
;
}
if
(
mPtrViECapture
-
>
AllocateExternalCaptureDevice
(
mCapId
mPtrExtCapture
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
Allocate
capture
module
:
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitCaptureError
;
}
if
(
mPtrViECapture
-
>
ConnectCaptureDevice
(
mCapId
mChannel
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
Connect
capture
module
:
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitCaptureError
;
}
if
(
mPtrViENetwork
-
>
SetMTU
(
mChannel
1200
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
MTU
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitMTUError
;
}
if
(
mPtrRTP
-
>
SetRTCPStatus
(
mChannel
webrtc
:
:
kRtcpCompound_RFC4585
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
RTCPStatus
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitRTCPStatusError
;
}
if
(
mPtrViERender
-
>
AddRenderer
(
mChannel
webrtc
:
:
kVideoI420
(
webrtc
:
:
ExternalRenderer
*
)
this
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Failed
to
added
external
renderer
"
__FUNCTION__
)
;
return
kMediaConduitInvalidRenderer
;
}
if
(
mLoadManager
)
{
mPtrViEBase
-
>
RegisterCpuOveruseObserver
(
mChannel
mLoadManager
)
;
mPtrViEBase
-
>
SetLoadManager
(
mLoadManager
)
;
}
CSFLogError
(
logTag
"
%
s
Initialization
Done
"
__FUNCTION__
)
;
return
kMediaConduitNoError
;
}
void
WebrtcVideoConduit
:
:
Destroy
(
)
{
if
(
mPtrViECapture
)
{
mPtrViECapture
-
>
DisconnectCaptureDevice
(
mCapId
)
;
mPtrViECapture
-
>
ReleaseCaptureDevice
(
mCapId
)
;
mPtrExtCapture
=
nullptr
;
}
if
(
mPtrExtCodec
)
{
mPtrExtCodec
-
>
Release
(
)
;
mPtrExtCodec
=
NULL
;
}
if
(
mPtrViERender
)
{
if
(
mRenderer
)
{
mPtrViERender
-
>
StopRender
(
mChannel
)
;
}
mPtrViERender
-
>
RemoveRenderer
(
mChannel
)
;
}
if
(
mPtrViENetwork
)
{
mPtrViENetwork
-
>
DeregisterSendTransport
(
mChannel
)
;
}
if
(
mPtrViEBase
)
{
mPtrViEBase
-
>
StopSend
(
mChannel
)
;
mPtrViEBase
-
>
StopReceive
(
mChannel
)
;
mPtrViEBase
-
>
DeleteChannel
(
mChannel
)
;
}
if
(
mVideoCodecStat
)
{
mVideoCodecStat
-
>
EndOfCallStats
(
)
;
}
mVideoCodecStat
=
nullptr
;
mPtrViEBase
=
nullptr
;
mPtrViECapture
=
nullptr
;
mPtrViECodec
=
nullptr
;
mPtrViENetwork
=
nullptr
;
mPtrViERender
=
nullptr
;
mPtrRTP
=
nullptr
;
mPtrExtCodec
=
nullptr
;
if
(
mVideoEngine
)
{
webrtc
:
:
VideoEngine
:
:
Delete
(
mVideoEngine
)
;
}
}
void
WebrtcVideoConduit
:
:
SyncTo
(
WebrtcAudioConduit
*
aConduit
)
{
CSFLogDebug
(
logTag
"
%
s
Synced
to
%
p
"
__FUNCTION__
aConduit
)
;
if
(
aConduit
)
{
mPtrViEBase
-
>
SetVoiceEngine
(
aConduit
-
>
GetVoiceEngine
(
)
)
;
mPtrViEBase
-
>
ConnectAudioChannel
(
mChannel
aConduit
-
>
GetChannel
(
)
)
;
}
else
{
mPtrViEBase
-
>
DisconnectAudioChannel
(
mChannel
)
;
mPtrViEBase
-
>
SetVoiceEngine
(
nullptr
)
;
}
mSyncedTo
=
aConduit
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
AttachRenderer
(
RefPtr
<
VideoRenderer
>
aVideoRenderer
)
{
CSFLogDebug
(
logTag
"
%
s
"
__FUNCTION__
)
;
if
(
!
aVideoRenderer
)
{
CSFLogError
(
logTag
"
%
s
NULL
Renderer
"
__FUNCTION__
)
;
MOZ_ASSERT
(
false
)
;
return
kMediaConduitInvalidRenderer
;
}
bool
wasRendering
;
{
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
wasRendering
=
!
!
mRenderer
;
mRenderer
=
aVideoRenderer
;
mRenderer
-
>
FrameSizeChange
(
mReceivingWidth
mReceivingHeight
mNumReceivingStreams
)
;
}
if
(
!
wasRendering
)
{
if
(
mPtrViERender
-
>
StartRender
(
mChannel
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Starting
the
Renderer
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
mRenderer
=
nullptr
;
return
kMediaConduitRendererFail
;
}
}
return
kMediaConduitNoError
;
}
void
WebrtcVideoConduit
:
:
DetachRenderer
(
)
{
{
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
mRenderer
)
{
mRenderer
=
nullptr
;
}
}
mPtrViERender
-
>
StopRender
(
mChannel
)
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SetTransmitterTransport
(
RefPtr
<
TransportInterface
>
aTransport
)
{
CSFLogDebug
(
logTag
"
%
s
"
__FUNCTION__
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
mTransmitterTransport
=
aTransport
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SetReceiverTransport
(
RefPtr
<
TransportInterface
>
aTransport
)
{
CSFLogDebug
(
logTag
"
%
s
"
__FUNCTION__
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
mReceiverTransport
=
aTransport
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
ConfigureCodecMode
(
webrtc
:
:
VideoCodecMode
mode
)
{
CSFLogDebug
(
logTag
"
%
s
"
__FUNCTION__
)
;
mCodecMode
=
mode
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
ConfigureSendMediaCodec
(
const
VideoCodecConfig
*
codecConfig
)
{
CSFLogDebug
(
logTag
"
%
s
for
%
s
"
__FUNCTION__
codecConfig
?
codecConfig
-
>
mName
.
c_str
(
)
:
"
<
null
>
"
)
;
bool
codecFound
=
false
;
MediaConduitErrorCode
condError
=
kMediaConduitNoError
;
int
error
=
0
;
webrtc
:
:
VideoCodec
video_codec
;
std
:
:
string
payloadName
;
memset
(
&
video_codec
0
sizeof
(
video_codec
)
)
;
{
if
(
(
condError
=
ValidateCodecConfig
(
codecConfig
true
)
)
!
=
kMediaConduitNoError
)
{
return
condError
;
}
}
condError
=
StopTransmitting
(
)
;
if
(
condError
!
=
kMediaConduitNoError
)
{
return
condError
;
}
if
(
mRtpStreamIdEnabled
)
{
video_codec
.
ridId
=
mRtpStreamIdExtId
;
}
if
(
mExternalSendCodec
&
&
codecConfig
-
>
mType
=
=
mExternalSendCodec
-
>
mType
)
{
CSFLogError
(
logTag
"
%
s
Configuring
External
H264
Send
Codec
"
__FUNCTION__
)
;
video_codec
.
width
=
320
;
video_codec
.
height
=
240
;
#
ifdef
MOZ_WEBRTC_OMX
if
(
codecConfig
-
>
mType
=
=
webrtc
:
:
kVideoCodecH264
)
{
video_codec
.
resolution_divisor
=
16
;
}
else
{
video_codec
.
resolution_divisor
=
1
;
}
#
else
video_codec
.
resolution_divisor
=
1
;
#
endif
video_codec
.
qpMax
=
56
;
video_codec
.
numberOfSimulcastStreams
=
1
;
video_codec
.
simulcastStream
[
0
]
.
jsScaleDownBy
=
codecConfig
-
>
mEncodingConstraints
.
scaleDownBy
;
video_codec
.
mode
=
mCodecMode
;
codecFound
=
true
;
}
else
{
for
(
int
idx
=
0
;
idx
<
mPtrViECodec
-
>
NumberOfCodecs
(
)
;
idx
+
+
)
{
if
(
0
=
=
mPtrViECodec
-
>
GetCodec
(
idx
video_codec
)
)
{
payloadName
=
video_codec
.
plName
;
if
(
codecConfig
-
>
mName
.
compare
(
payloadName
)
=
=
0
)
{
codecFound
=
true
;
break
;
}
}
}
}
if
(
codecFound
=
=
false
)
{
CSFLogError
(
logTag
"
%
s
Codec
Mismatch
"
__FUNCTION__
)
;
return
kMediaConduitInvalidSendCodec
;
}
CodecConfigToWebRTCCodec
(
codecConfig
video_codec
)
;
if
(
mSendingWidth
!
=
0
)
{
video_codec
.
width
=
mSendingWidth
;
video_codec
.
height
=
mSendingHeight
;
video_codec
.
maxFramerate
=
mSendingFramerate
;
}
else
{
mSendingWidth
=
0
;
mSendingHeight
=
0
;
mSendingFramerate
=
video_codec
.
maxFramerate
;
}
mNegotiatedMaxBitrate
=
MinIgnoreZero
(
mPrefMaxBitrate
video_codec
.
maxBitrate
)
;
video_codec
.
mode
=
mCodecMode
;
if
(
mPtrViECodec
-
>
SetSendCodec
(
mChannel
video_codec
)
=
=
-
1
)
{
error
=
mPtrViEBase
-
>
LastError
(
)
;
if
(
error
=
=
kViECodecInvalidCodec
)
{
CSFLogError
(
logTag
"
%
s
Invalid
Send
Codec
"
__FUNCTION__
)
;
return
kMediaConduitInvalidSendCodec
;
}
CSFLogError
(
logTag
"
%
s
SetSendCodec
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitUnknownError
;
}
if
(
mMinBitrateEstimate
!
=
0
)
{
mPtrViENetwork
-
>
SetBitrateConfig
(
mChannel
mMinBitrateEstimate
std
:
:
max
(
video_codec
.
startBitrate
mMinBitrateEstimate
)
std
:
:
max
(
video_codec
.
maxBitrate
mMinBitrateEstimate
)
)
;
}
if
(
!
mVideoCodecStat
)
{
mVideoCodecStat
=
new
VideoCodecStatistics
(
mChannel
mPtrViECodec
)
;
}
mVideoCodecStat
-
>
Register
(
true
)
;
bool
use_fec
=
codecConfig
-
>
RtcpFbFECIsSet
(
)
;
if
(
(
mExternalSendCodec
&
&
codecConfig
-
>
mType
=
=
mExternalSendCodec
-
>
mType
)
|
|
codecConfig
-
>
mType
=
=
webrtc
:
:
kVideoCodecH264
)
{
if
(
codecConfig
-
>
RtcpFbNackIsSet
(
"
"
)
)
{
use_fec
=
false
;
}
}
if
(
use_fec
)
{
uint8_t
payload_type_red
=
INVALID_RTP_PAYLOAD
;
uint8_t
payload_type_ulpfec
=
INVALID_RTP_PAYLOAD
;
if
(
!
DetermineREDAndULPFECPayloadTypes
(
payload_type_red
payload_type_ulpfec
)
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
set
FEC
status
:
could
not
determine
"
"
payload
type
:
red
%
u
ulpfec
%
u
"
__FUNCTION__
payload_type_red
payload_type_ulpfec
)
;
return
kMediaConduitFECStatusError
;
}
if
(
codecConfig
-
>
RtcpFbNackIsSet
(
"
"
)
)
{
CSFLogDebug
(
logTag
"
Enabling
NACK
/
FEC
(
send
)
for
video
stream
\
n
"
)
;
if
(
mPtrRTP
-
>
SetHybridNACKFECStatus
(
mChannel
true
payload_type_red
payload_type_ulpfec
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
SetHybridNACKFECStatus
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitHybridNACKFECStatusError
;
}
}
else
{
CSFLogDebug
(
logTag
"
Enabling
FEC
(
send
)
for
video
stream
\
n
"
)
;
if
(
mPtrRTP
-
>
SetFECStatus
(
mChannel
true
payload_type_red
payload_type_ulpfec
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
SetFECStatus
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitFECStatusError
;
}
}
}
else
if
(
codecConfig
-
>
RtcpFbNackIsSet
(
"
"
)
)
{
CSFLogDebug
(
logTag
"
Enabling
NACK
(
send
)
for
video
stream
\
n
"
)
;
if
(
mPtrRTP
-
>
SetNACKStatus
(
mChannel
true
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
NACKStatus
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitNACKStatusError
;
}
}
{
MutexAutoLock
lock
(
mCodecMutex
)
;
mCurSendCodecConfig
=
new
VideoCodecConfig
(
*
codecConfig
)
;
}
bool
remb_requested
=
codecConfig
-
>
RtcpFbRembIsSet
(
)
;
mPtrRTP
-
>
SetRembStatus
(
mChannel
true
remb_requested
)
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
ConfigureRecvMediaCodecs
(
const
std
:
:
vector
<
VideoCodecConfig
*
>
&
codecConfigList
)
{
CSFLogDebug
(
logTag
"
%
s
"
__FUNCTION__
)
;
MediaConduitErrorCode
condError
=
kMediaConduitNoError
;
bool
success
=
false
;
std
:
:
string
payloadName
;
condError
=
StopReceiving
(
)
;
if
(
condError
!
=
kMediaConduitNoError
)
{
return
condError
;
}
if
(
codecConfigList
.
empty
(
)
)
{
CSFLogError
(
logTag
"
%
s
Zero
number
of
codecs
to
configure
"
__FUNCTION__
)
;
return
kMediaConduitMalformedArgument
;
}
webrtc
:
:
ViEKeyFrameRequestMethod
kf_request
=
webrtc
:
:
kViEKeyFrameRequestNone
;
bool
use_nack_basic
=
false
;
bool
use_tmmbr
=
false
;
bool
use_remb
=
false
;
bool
use_fec
=
false
;
for
(
std
:
:
vector
<
VideoCodecConfig
*
>
:
:
size_type
i
=
0
;
i
<
codecConfigList
.
size
(
)
;
i
+
+
)
{
if
(
(
condError
=
ValidateCodecConfig
(
codecConfigList
[
i
]
false
)
)
!
=
kMediaConduitNoError
)
{
return
condError
;
}
if
(
codecConfigList
[
i
]
-
>
RtcpFbNackIsSet
(
"
pli
"
)
)
{
kf_request
=
webrtc
:
:
kViEKeyFrameRequestPliRtcp
;
}
else
if
(
kf_request
=
=
webrtc
:
:
kViEKeyFrameRequestNone
&
&
codecConfigList
[
i
]
-
>
RtcpFbCcmIsSet
(
"
fir
"
)
)
{
kf_request
=
webrtc
:
:
kViEKeyFrameRequestFirRtcp
;
}
if
(
codecConfigList
[
i
]
-
>
RtcpFbNackIsSet
(
"
"
)
)
{
use_nack_basic
=
true
;
}
if
(
codecConfigList
[
i
]
-
>
RtcpFbCcmIsSet
(
"
tmmbr
"
)
)
{
use_tmmbr
=
true
;
}
if
(
codecConfigList
[
i
]
-
>
RtcpFbRembIsSet
(
)
)
{
use_remb
=
true
;
}
if
(
codecConfigList
[
i
]
-
>
RtcpFbFECIsSet
(
)
)
{
use_fec
=
true
;
}
webrtc
:
:
VideoCodec
video_codec
;
memset
(
&
video_codec
0
sizeof
(
webrtc
:
:
VideoCodec
)
)
;
if
(
mExternalRecvCodec
&
&
codecConfigList
[
i
]
-
>
mType
=
=
mExternalRecvCodec
-
>
mType
)
{
CSFLogError
(
logTag
"
%
s
Configuring
External
H264
Receive
Codec
"
__FUNCTION__
)
;
CodecConfigToWebRTCCodec
(
codecConfigList
[
i
]
video_codec
)
;
if
(
mPtrViECodec
-
>
SetReceiveCodec
(
mChannel
video_codec
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Invalid
Receive
Codec
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
}
else
{
CSFLogError
(
logTag
"
%
s
Successfully
Set
the
codec
%
s
"
__FUNCTION__
codecConfigList
[
i
]
-
>
mName
.
c_str
(
)
)
;
success
=
true
;
}
}
else
{
for
(
int
idx
=
0
;
idx
<
mPtrViECodec
-
>
NumberOfCodecs
(
)
;
idx
+
+
)
{
if
(
mPtrViECodec
-
>
GetCodec
(
idx
video_codec
)
=
=
0
)
{
payloadName
=
video_codec
.
plName
;
if
(
codecConfigList
[
i
]
-
>
mName
.
compare
(
payloadName
)
=
=
0
)
{
CodecConfigToWebRTCCodec
(
codecConfigList
[
i
]
video_codec
)
;
if
(
mPtrViECodec
-
>
SetReceiveCodec
(
mChannel
video_codec
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Invalid
Receive
Codec
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
}
else
{
CSFLogError
(
logTag
"
%
s
Successfully
Set
the
codec
%
s
"
__FUNCTION__
codecConfigList
[
i
]
-
>
mName
.
c_str
(
)
)
;
success
=
true
;
}
break
;
}
}
}
}
}
if
(
!
success
)
{
CSFLogError
(
logTag
"
%
s
Setting
Receive
Codec
Failed
"
__FUNCTION__
)
;
return
kMediaConduitInvalidReceiveCodec
;
}
if
(
!
mVideoCodecStat
)
{
mVideoCodecStat
=
new
VideoCodecStatistics
(
mChannel
mPtrViECodec
)
;
}
mVideoCodecStat
-
>
Register
(
false
)
;
if
(
kf_request
!
=
webrtc
:
:
kViEKeyFrameRequestNone
)
{
CSFLogDebug
(
logTag
"
Enabling
%
s
frame
requests
for
video
stream
\
n
"
(
kf_request
=
=
webrtc
:
:
kViEKeyFrameRequestPliRtcp
?
"
PLI
"
:
"
FIR
"
)
)
;
if
(
mPtrRTP
-
>
SetKeyFrameRequestMethod
(
mChannel
kf_request
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
KeyFrameRequest
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitKeyFrameRequestError
;
}
}
switch
(
kf_request
)
{
case
webrtc
:
:
kViEKeyFrameRequestNone
:
mFrameRequestMethod
=
FrameRequestNone
;
break
;
case
webrtc
:
:
kViEKeyFrameRequestPliRtcp
:
mFrameRequestMethod
=
FrameRequestPli
;
break
;
case
webrtc
:
:
kViEKeyFrameRequestFirRtcp
:
mFrameRequestMethod
=
FrameRequestFir
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
mFrameRequestMethod
=
FrameRequestUnknown
;
}
if
(
use_fec
)
{
uint8_t
payload_type_red
=
INVALID_RTP_PAYLOAD
;
uint8_t
payload_type_ulpfec
=
INVALID_RTP_PAYLOAD
;
if
(
!
DetermineREDAndULPFECPayloadTypes
(
payload_type_red
payload_type_ulpfec
)
)
{
CSFLogError
(
logTag
"
%
s
Unable
to
set
FEC
status
:
could
not
determine
"
"
payload
type
:
red
%
u
ulpfec
%
u
"
__FUNCTION__
payload_type_red
payload_type_ulpfec
)
;
return
kMediaConduitFECStatusError
;
}
for
(
int
idx
=
0
;
idx
<
mPtrViECodec
-
>
NumberOfCodecs
(
)
;
idx
+
+
)
{
webrtc
:
:
VideoCodec
video_codec
;
if
(
mPtrViECodec
-
>
GetCodec
(
idx
video_codec
)
=
=
0
)
{
payloadName
=
video_codec
.
plName
;
if
(
video_codec
.
codecType
=
=
webrtc
:
:
VideoCodecType
:
:
kVideoCodecRED
|
|
video_codec
.
codecType
=
=
webrtc
:
:
VideoCodecType
:
:
kVideoCodecULPFEC
)
{
if
(
mPtrViECodec
-
>
SetReceiveCodec
(
mChannel
video_codec
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Invalid
Receive
Codec
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
}
else
{
CSFLogDebug
(
logTag
"
%
s
Successfully
Set
the
codec
%
s
"
__FUNCTION__
video_codec
.
plName
)
;
}
}
}
}
if
(
use_nack_basic
)
{
CSFLogDebug
(
logTag
"
Enabling
NACK
/
FEC
(
recv
)
for
video
stream
\
n
"
)
;
if
(
mPtrRTP
-
>
SetHybridNACKFECStatus
(
mChannel
true
payload_type_red
payload_type_ulpfec
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
SetHybridNACKFECStatus
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitNACKStatusError
;
}
}
else
{
CSFLogDebug
(
logTag
"
Enabling
FEC
(
recv
)
for
video
stream
\
n
"
)
;
if
(
mPtrRTP
-
>
SetFECStatus
(
mChannel
true
payload_type_red
payload_type_ulpfec
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
SetFECStatus
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitNACKStatusError
;
}
}
}
else
if
(
use_nack_basic
)
{
CSFLogDebug
(
logTag
"
Enabling
NACK
(
recv
)
for
video
stream
\
n
"
)
;
if
(
mPtrRTP
-
>
SetNACKStatus
(
mChannel
true
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
NACKStatus
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitNACKStatusError
;
}
}
mUsingNackBasic
=
use_nack_basic
;
mUsingFEC
=
use_fec
;
if
(
use_tmmbr
)
{
CSFLogDebug
(
logTag
"
Enabling
TMMBR
for
video
stream
"
)
;
if
(
mPtrRTP
-
>
SetTMMBRStatus
(
mChannel
true
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
SetTMMBRStatus
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitTMMBRStatusError
;
}
}
mUsingTmmbr
=
use_tmmbr
;
condError
=
StartReceiving
(
)
;
if
(
condError
!
=
kMediaConduitNoError
)
{
return
condError
;
}
CSFLogDebug
(
logTag
"
REMB
enabled
for
video
stream
%
s
"
(
use_remb
?
"
yes
"
:
"
no
"
)
)
;
mPtrRTP
-
>
SetRembStatus
(
mChannel
use_remb
true
)
;
return
kMediaConduitNoError
;
}
struct
ResolutionAndBitrateLimits
{
uint32_t
resolution_in_mb
;
uint16_t
min_bitrate
;
uint16_t
start_bitrate
;
uint16_t
max_bitrate
;
}
;
#
define
MB_OF
(
w
h
)
(
(
unsigned
int
)
(
(
(
(
w
+
15
)
>
>
4
)
)
*
(
(
unsigned
int
)
(
(
h
+
15
)
>
>
4
)
)
)
)
static
ResolutionAndBitrateLimits
kResolutionAndBitrateLimits
[
]
=
{
{
MB_OF
(
1920
1200
)
1500
2000
10000
}
{
MB_OF
(
1280
720
)
1200
1500
5000
}
{
MB_OF
(
800
480
)
600
800
2500
}
{
tl
:
:
Max
<
MB_OF
(
400
240
)
MB_OF
(
352
288
)
>
:
:
value
200
300
1300
}
{
MB_OF
(
176
144
)
100
150
500
}
{
0
40
80
250
}
}
;
void
WebrtcVideoConduit
:
:
SelectBitrates
(
unsigned
short
width
unsigned
short
height
unsigned
int
cap
mozilla
:
:
Atomic
<
int32_t
mozilla
:
:
Relaxed
>
&
aLastFramerateTenths
unsigned
int
&
out_min
unsigned
int
&
out_start
unsigned
int
&
out_max
)
{
unsigned
int
fs
=
MB_OF
(
width
height
)
;
for
(
ResolutionAndBitrateLimits
resAndLimits
:
kResolutionAndBitrateLimits
)
{
if
(
fs
>
resAndLimits
.
resolution_in_mb
&
&
(
!
cap
|
|
resAndLimits
.
start_bitrate
<
=
cap
|
|
resAndLimits
.
resolution_in_mb
=
=
0
)
)
{
out_min
=
MinIgnoreZero
(
(
unsigned
int
)
resAndLimits
.
min_bitrate
cap
)
;
out_start
=
MinIgnoreZero
(
(
unsigned
int
)
resAndLimits
.
start_bitrate
cap
)
;
out_max
=
MinIgnoreZero
(
(
unsigned
int
)
resAndLimits
.
max_bitrate
cap
)
;
break
;
}
}
double
framerate
=
std
:
:
min
(
(
aLastFramerateTenths
/
10
.
)
60
.
0
)
;
MOZ_ASSERT
(
framerate
>
0
)
;
if
(
framerate
>
=
10
)
{
out_min
=
out_min
*
(
framerate
/
30
)
;
out_start
=
out_start
*
(
framerate
/
30
)
;
out_max
=
std
:
:
max
(
(
unsigned
int
)
(
out_max
*
(
framerate
/
30
)
)
cap
)
;
}
else
{
out_min
=
out_min
*
(
(
10
-
(
framerate
/
2
)
)
/
30
)
;
out_start
=
out_start
*
(
(
10
-
(
framerate
/
2
)
)
/
30
)
;
out_max
=
std
:
:
max
(
(
unsigned
int
)
(
out_max
*
(
(
10
-
(
framerate
/
2
)
)
/
30
)
)
cap
)
;
}
if
(
mMinBitrate
&
&
mMinBitrate
>
out_min
)
{
out_min
=
mMinBitrate
;
}
out_min
=
std
:
:
max
(
(
unsigned
int
)
webrtc
:
:
kViEMinCodecBitrate
out_min
)
;
if
(
mStartBitrate
&
&
mStartBitrate
>
out_start
)
{
out_start
=
mStartBitrate
;
}
out_start
=
std
:
:
max
(
out_start
out_min
)
;
if
(
mNegotiatedMaxBitrate
!
=
0
&
&
mNegotiatedMaxBitrate
>
out_max
)
{
out_max
=
mNegotiatedMaxBitrate
;
}
MOZ_ASSERT
(
mPrefMaxBitrate
=
=
0
|
|
out_max
<
=
mPrefMaxBitrate
)
;
}
static
void
ConstrainPreservingAspectRatioExact
(
uint32_t
max_fs
unsigned
short
*
width
unsigned
short
*
height
)
{
for
(
size_t
d
=
1
;
d
<
std
:
:
min
(
*
width
*
height
)
;
+
+
d
)
{
if
(
(
*
width
%
d
)
|
|
(
*
height
%
d
)
)
{
continue
;
}
if
(
(
(
*
width
)
*
(
*
height
)
)
/
(
d
*
d
)
<
=
max_fs
)
{
*
width
/
=
d
;
*
height
/
=
d
;
return
;
}
}
*
width
=
0
;
*
height
=
0
;
}
static
void
ConstrainPreservingAspectRatio
(
uint16_t
max_width
uint16_t
max_height
unsigned
short
*
width
unsigned
short
*
height
)
{
if
(
(
(
*
width
)
<
=
max_width
)
&
&
(
(
*
height
)
<
=
max_height
)
)
{
return
;
}
if
(
(
*
width
)
*
max_height
>
max_width
*
(
*
height
)
)
{
(
*
height
)
=
max_width
*
(
*
height
)
/
(
*
width
)
;
(
*
width
)
=
max_width
;
}
else
{
(
*
width
)
=
max_height
*
(
*
width
)
/
(
*
height
)
;
(
*
height
)
=
max_height
;
}
}
bool
WebrtcVideoConduit
:
:
SelectSendResolution
(
unsigned
short
width
unsigned
short
height
webrtc
:
:
I420VideoFrame
*
frame
)
{
mCodecMutex
.
AssertCurrentThreadOwns
(
)
;
mLastWidth
=
width
;
mLastHeight
=
height
;
if
(
mCurSendCodecConfig
)
{
uint16_t
max_width
=
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxWidth
;
uint16_t
max_height
=
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxHeight
;
if
(
max_width
|
|
max_height
)
{
max_width
=
max_width
?
max_width
:
UINT16_MAX
;
max_height
=
max_height
?
max_height
:
UINT16_MAX
;
ConstrainPreservingAspectRatio
(
max_width
max_height
&
width
&
height
)
;
}
if
(
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxFs
)
{
uint32_t
max_fs
=
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxFs
;
unsigned
int
cur_fs
mb_width
mb_height
mb_max
;
mb_width
=
(
width
+
15
)
>
>
4
;
mb_height
=
(
height
+
15
)
>
>
4
;
cur_fs
=
mb_width
*
mb_height
;
if
(
cur_fs
>
max_fs
)
{
double
scale_ratio
;
scale_ratio
=
sqrt
(
(
double
)
max_fs
/
(
double
)
cur_fs
)
;
mb_width
=
mb_width
*
scale_ratio
;
mb_height
=
mb_height
*
scale_ratio
;
if
(
mb_width
=
=
0
)
{
mb_width
=
1
;
mb_height
=
std
:
:
min
(
mb_height
max_fs
)
;
}
if
(
mb_height
=
=
0
)
{
mb_height
=
1
;
mb_width
=
std
:
:
min
(
mb_width
max_fs
)
;
}
}
mb_max
=
(
unsigned
)
sqrt
(
8
*
(
double
)
max_fs
)
;
max_width
=
16
*
std
:
:
min
(
mb_width
mb_max
)
;
max_height
=
16
*
std
:
:
min
(
mb_height
mb_max
)
;
ConstrainPreservingAspectRatio
(
max_width
max_height
&
width
&
height
)
;
}
}
bool
changed
=
false
;
if
(
mSendingWidth
!
=
width
|
|
mSendingHeight
!
=
height
)
{
CSFLogDebug
(
logTag
"
%
s
:
resolution
changing
to
%
ux
%
u
(
from
%
ux
%
u
)
"
__FUNCTION__
width
height
mSendingWidth
mSendingHeight
)
;
mSendingWidth
=
width
;
mSendingHeight
=
height
;
changed
=
true
;
}
unsigned
int
framerate
=
SelectSendFrameRate
(
mSendingFramerate
)
;
if
(
mSendingFramerate
!
=
framerate
)
{
CSFLogDebug
(
logTag
"
%
s
:
framerate
changing
to
%
u
(
from
%
u
)
"
__FUNCTION__
framerate
mSendingFramerate
)
;
mSendingFramerate
=
framerate
;
changed
=
true
;
}
if
(
changed
)
{
if
(
!
NS_IsMainThread
(
)
)
{
mInReconfig
=
true
;
webrtc
:
:
I420VideoFrame
*
new_frame
=
nullptr
;
if
(
frame
)
{
new_frame
=
new
webrtc
:
:
I420VideoFrame
(
)
;
new_frame
-
>
ShallowCopy
(
*
frame
)
;
}
RefPtr
<
WebrtcVideoConduit
>
self
(
this
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
width
height
new_frame
]
(
)
-
>
nsresult
{
UniquePtr
<
webrtc
:
:
I420VideoFrame
>
local_frame
(
new_frame
)
;
MutexAutoLock
lock
(
self
-
>
mCodecMutex
)
;
return
self
-
>
ReconfigureSendCodec
(
width
height
new_frame
)
;
}
)
;
CSFLogDebug
(
logTag
"
%
s
:
proxying
lambda
to
WebRTC
thread
for
reconfig
(
width
%
u
/
%
u
height
%
u
/
%
u
"
__FUNCTION__
width
mLastWidth
height
mLastHeight
)
;
NS_DispatchToMainThread
(
webrtc_runnable
.
forget
(
)
)
;
if
(
new_frame
)
{
return
true
;
}
}
else
{
ReconfigureSendCodec
(
width
height
frame
)
;
}
}
return
false
;
}
nsresult
WebrtcVideoConduit
:
:
ReconfigureSendCodec
(
unsigned
short
width
unsigned
short
height
webrtc
:
:
I420VideoFrame
*
frame
)
{
mCodecMutex
.
AssertCurrentThreadOwns
(
)
;
webrtc
:
:
VideoCodec
vie_codec
;
int32_t
err
;
mInReconfig
=
false
;
if
(
(
err
=
mPtrViECodec
-
>
GetSendCodec
(
mChannel
vie_codec
)
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
:
GetSendCodec
failed
err
%
d
"
__FUNCTION__
err
)
;
return
NS_ERROR_FAILURE
;
}
CSFLogDebug
(
logTag
"
%
s
:
Requesting
resolution
change
to
%
ux
%
u
(
from
%
ux
%
u
)
"
__FUNCTION__
width
height
vie_codec
.
width
vie_codec
.
height
)
;
if
(
mRtpStreamIdEnabled
)
{
vie_codec
.
ridId
=
mRtpStreamIdExtId
;
}
vie_codec
.
width
=
width
;
vie_codec
.
height
=
height
;
vie_codec
.
maxFramerate
=
mSendingFramerate
;
SelectBitrates
(
vie_codec
.
width
vie_codec
.
height
0
mLastFramerateTenths
vie_codec
.
minBitrate
vie_codec
.
startBitrate
vie_codec
.
maxBitrate
)
;
uint32_t
minMinBitrate
=
0
;
uint32_t
minStartBitrate
=
0
;
uint32_t
totalMaxBitrate
=
0
;
for
(
size_t
i
=
vie_codec
.
numberOfSimulcastStreams
;
i
>
0
;
-
-
i
)
{
webrtc
:
:
SimulcastStream
&
stream
(
vie_codec
.
simulcastStream
[
i
-
1
]
)
;
stream
.
width
=
width
;
stream
.
height
=
height
;
MOZ_ASSERT
(
stream
.
jsScaleDownBy
>
=
1
.
0
)
;
uint32_t
new_width
=
uint32_t
(
width
/
stream
.
jsScaleDownBy
)
;
uint32_t
new_height
=
uint32_t
(
height
/
stream
.
jsScaleDownBy
)
;
if
(
new_width
!
=
width
|
|
new_height
!
=
height
)
{
if
(
vie_codec
.
numberOfSimulcastStreams
=
=
1
)
{
ConstrainPreservingAspectRatio
(
new_width
new_height
&
stream
.
width
&
stream
.
height
)
;
}
else
{
ConstrainPreservingAspectRatioExact
(
new_width
*
new_height
&
stream
.
width
&
stream
.
height
)
;
}
}
SelectBitrates
(
stream
.
width
stream
.
height
MinIgnoreZero
(
stream
.
jsMaxBitrate
vie_codec
.
maxBitrate
)
mLastFramerateTenths
stream
.
minBitrate
stream
.
targetBitrate
stream
.
maxBitrate
)
;
if
(
i
=
=
vie_codec
.
numberOfSimulcastStreams
)
{
vie_codec
.
width
=
stream
.
width
;
vie_codec
.
height
=
stream
.
height
;
}
minMinBitrate
=
MinIgnoreZero
(
stream
.
minBitrate
minMinBitrate
)
;
minStartBitrate
=
MinIgnoreZero
(
stream
.
targetBitrate
minStartBitrate
)
;
totalMaxBitrate
+
=
stream
.
maxBitrate
;
}
if
(
vie_codec
.
numberOfSimulcastStreams
!
=
0
)
{
vie_codec
.
minBitrate
=
std
:
:
max
(
minMinBitrate
vie_codec
.
minBitrate
)
;
vie_codec
.
maxBitrate
=
std
:
:
min
(
totalMaxBitrate
vie_codec
.
maxBitrate
)
;
vie_codec
.
startBitrate
=
std
:
:
max
(
vie_codec
.
minBitrate
std
:
:
min
(
minStartBitrate
vie_codec
.
maxBitrate
)
)
;
}
vie_codec
.
mode
=
mCodecMode
;
if
(
(
err
=
mPtrViECodec
-
>
SetSendCodec
(
mChannel
vie_codec
)
)
!
=
0
)
{
CSFLogError
(
logTag
"
%
s
:
SetSendCodec
(
%
ux
%
u
)
failed
err
%
d
"
__FUNCTION__
width
height
err
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mMinBitrateEstimate
!
=
0
)
{
mPtrViENetwork
-
>
SetBitrateConfig
(
mChannel
mMinBitrateEstimate
std
:
:
max
(
vie_codec
.
startBitrate
mMinBitrateEstimate
)
std
:
:
max
(
vie_codec
.
maxBitrate
mMinBitrateEstimate
)
)
;
}
CSFLogDebug
(
logTag
"
%
s
:
Encoder
resolution
changed
to
%
ux
%
u
%
ufps
bitrate
%
u
:
%
u
"
__FUNCTION__
width
height
mSendingFramerate
vie_codec
.
minBitrate
vie_codec
.
maxBitrate
)
;
if
(
frame
)
{
mPtrExtCapture
-
>
IncomingFrame
(
*
frame
)
;
mVideoCodecStat
-
>
SentFrame
(
)
;
CSFLogDebug
(
logTag
"
%
s
Inserted
a
frame
from
reconfig
lambda
"
__FUNCTION__
)
;
}
return
NS_OK
;
}
unsigned
int
WebrtcVideoConduit
:
:
SelectSendFrameRate
(
unsigned
int
framerate
)
const
{
mCodecMutex
.
AssertCurrentThreadOwns
(
)
;
unsigned
int
new_framerate
=
framerate
;
if
(
mCurSendCodecConfig
&
&
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxMbps
)
{
unsigned
int
cur_fs
mb_width
mb_height
max_fps
;
mb_width
=
(
mSendingWidth
+
15
)
>
>
4
;
mb_height
=
(
mSendingHeight
+
15
)
>
>
4
;
cur_fs
=
mb_width
*
mb_height
;
if
(
cur_fs
>
0
)
{
max_fps
=
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxMbps
/
cur_fs
;
if
(
max_fps
<
mSendingFramerate
)
{
new_framerate
=
max_fps
;
}
if
(
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxFps
!
=
0
&
&
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxFps
<
mSendingFramerate
)
{
new_framerate
=
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxFps
;
}
}
}
return
new_framerate
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SetExternalSendCodec
(
VideoCodecConfig
*
config
VideoEncoder
*
encoder
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
!
mPtrExtCodec
-
>
RegisterExternalSendCodec
(
mChannel
config
-
>
mType
static_cast
<
WebrtcVideoEncoder
*
>
(
encoder
)
false
)
)
{
mExternalSendCodecHandle
=
encoder
;
mExternalSendCodec
=
new
VideoCodecConfig
(
*
config
)
;
return
kMediaConduitNoError
;
}
return
kMediaConduitInvalidSendCodec
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SetExternalRecvCodec
(
VideoCodecConfig
*
config
VideoDecoder
*
decoder
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
!
mPtrExtCodec
-
>
RegisterExternalReceiveCodec
(
mChannel
config
-
>
mType
static_cast
<
WebrtcVideoDecoder
*
>
(
decoder
)
)
)
{
mExternalRecvCodecHandle
=
decoder
;
mExternalRecvCodec
=
new
VideoCodecConfig
(
*
config
)
;
return
kMediaConduitNoError
;
}
return
kMediaConduitInvalidReceiveCodec
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
EnableRTPStreamIdExtension
(
bool
enabled
uint8_t
id
)
{
mRtpStreamIdEnabled
=
enabled
;
mRtpStreamIdExtId
=
id
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SendVideoFrame
(
unsigned
char
*
video_frame
unsigned
int
video_frame_length
unsigned
short
width
unsigned
short
height
VideoType
video_type
uint64_t
capture_time
)
{
if
(
!
video_frame
|
|
video_frame_length
=
=
0
|
|
width
=
=
0
|
|
height
=
=
0
)
{
CSFLogError
(
logTag
"
%
s
Invalid
Parameters
"
__FUNCTION__
)
;
MOZ_ASSERT
(
false
)
;
return
kMediaConduitMalformedArgument
;
}
MOZ_ASSERT
(
video_type
=
=
VideoType
:
:
kVideoI420
)
;
MOZ_ASSERT
(
mPtrExtCapture
)
;
if
(
!
mEngineTransmitting
)
{
CSFLogError
(
logTag
"
%
s
Engine
not
transmitting
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
webrtc
:
:
I420VideoFrame
i420_frame
;
i420_frame
.
CreateFrame
(
video_frame
width
height
webrtc
:
:
kVideoRotation_0
)
;
i420_frame
.
set_timestamp
(
capture_time
)
;
i420_frame
.
set_render_time_ms
(
capture_time
)
;
return
SendVideoFrame
(
i420_frame
)
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SendVideoFrame
(
webrtc
:
:
I420VideoFrame
&
frame
)
{
CSFLogDebug
(
logTag
"
%
s
"
__FUNCTION__
)
;
{
MutexAutoLock
lock
(
mCodecMutex
)
;
if
(
mInReconfig
)
{
return
kMediaConduitNoError
;
}
if
(
frame
.
width
(
)
!
=
mLastWidth
|
|
frame
.
height
(
)
!
=
mLastHeight
)
{
CSFLogDebug
(
logTag
"
%
s
:
call
SelectSendResolution
with
%
ux
%
u
"
__FUNCTION__
frame
.
width
(
)
frame
.
height
(
)
)
;
if
(
SelectSendResolution
(
frame
.
width
(
)
frame
.
height
(
)
&
frame
)
)
{
return
kMediaConduitNoError
;
}
}
}
mPtrExtCapture
-
>
IncomingFrame
(
frame
)
;
mVideoCodecStat
-
>
SentFrame
(
)
;
CSFLogDebug
(
logTag
"
%
s
Inserted
a
frame
"
__FUNCTION__
)
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
ReceivedRTPPacket
(
const
void
*
data
int
len
)
{
CSFLogDebug
(
logTag
"
%
s
:
seq
#
%
u
Channel
%
d
Len
%
d
"
__FUNCTION__
(
uint16_t
)
ntohs
(
(
(
uint16_t
*
)
data
)
[
1
]
)
mChannel
len
)
;
if
(
mEngineReceiving
)
{
if
(
mPtrViENetwork
-
>
ReceivedRTPPacket
(
mChannel
data
len
webrtc
:
:
PacketTime
(
)
)
=
=
-
1
)
{
int
error
=
mPtrViEBase
-
>
LastError
(
)
;
CSFLogError
(
logTag
"
%
s
RTP
Processing
Failed
%
d
"
__FUNCTION__
error
)
;
if
(
error
>
=
kViERtpRtcpInvalidChannelId
&
&
error
<
=
kViERtpRtcpRtcpDisabled
)
{
return
kMediaConduitRTPProcessingFailed
;
}
return
kMediaConduitRTPRTCPModuleError
;
}
}
else
{
CSFLogError
(
logTag
"
Error
:
%
s
when
not
receiving
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
ReceivedRTCPPacket
(
const
void
*
data
int
len
)
{
CSFLogDebug
(
logTag
"
%
s
Channel
%
d
Len
%
d
"
__FUNCTION__
mChannel
len
)
;
if
(
mPtrViENetwork
-
>
ReceivedRTCPPacket
(
mChannel
data
len
)
=
=
-
1
)
{
int
error
=
mPtrViEBase
-
>
LastError
(
)
;
CSFLogError
(
logTag
"
%
s
RTCP
Processing
Failed
%
d
"
__FUNCTION__
error
)
;
if
(
error
>
=
kViERtpRtcpInvalidChannelId
&
&
error
<
=
kViERtpRtcpRtcpDisabled
)
{
return
kMediaConduitRTPProcessingFailed
;
}
return
kMediaConduitRTPRTCPModuleError
;
}
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StopTransmitting
(
)
{
if
(
mEngineTransmitting
)
{
CSFLogDebug
(
logTag
"
%
s
Engine
Already
Sending
.
Attemping
to
Stop
"
__FUNCTION__
)
;
if
(
mPtrViEBase
-
>
StopSend
(
mChannel
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
StopSend
(
)
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitUnknownError
;
}
mEngineTransmitting
=
false
;
}
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StartTransmitting
(
)
{
if
(
!
mEngineTransmitting
)
{
if
(
mPtrViEBase
-
>
StartSend
(
mChannel
)
=
=
-
1
)
{
CSFLogError
(
logTag
"
%
s
Start
Send
Error
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitUnknownError
;
}
mEngineTransmitting
=
true
;
}
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StopReceiving
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
mEngineReceiving
)
{
CSFLogDebug
(
logTag
"
%
s
Engine
Already
Receiving
.
Attemping
to
Stop
"
__FUNCTION__
)
;
if
(
mPtrViEBase
-
>
StopReceive
(
mChannel
)
=
=
-
1
)
{
int
error
=
mPtrViEBase
-
>
LastError
(
)
;
if
(
error
=
=
kViEBaseUnknownError
)
{
CSFLogDebug
(
logTag
"
%
s
StopReceive
(
)
Success
"
__FUNCTION__
)
;
}
else
{
CSFLogError
(
logTag
"
%
s
StopReceive
(
)
Failed
%
d
"
__FUNCTION__
mPtrViEBase
-
>
LastError
(
)
)
;
return
kMediaConduitUnknownError
;
}
}
mEngineReceiving
=
false
;
}
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StartReceiving
(
)
{
if
(
!
mEngineReceiving
)
{
CSFLogDebug
(
logTag
"
%
s
Attemping
to
start
.
.
.
"
__FUNCTION__
)
;
if
(
mPtrViEBase
-
>
StartReceive
(
mChannel
)
=
=
-
1
)
{
int
error
=
mPtrViEBase
-
>
LastError
(
)
;
CSFLogError
(
logTag
"
%
s
Start
Receive
Error
%
d
"
__FUNCTION__
error
)
;
return
kMediaConduitUnknownError
;
}
mEngineReceiving
=
true
;
}
return
kMediaConduitNoError
;
}
int
WebrtcVideoConduit
:
:
SendPacket
(
int
channel
const
void
*
data
size_t
len
)
{
CSFLogDebug
(
logTag
"
%
s
:
channel
%
d
len
%
lu
"
__FUNCTION__
channel
(
unsigned
long
)
len
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
mTransmitterTransport
&
&
(
mTransmitterTransport
-
>
SendRtpPacket
(
data
len
)
=
=
NS_OK
)
)
{
CSFLogDebug
(
logTag
"
%
s
Sent
RTP
Packet
"
__FUNCTION__
)
;
return
len
;
}
else
{
CSFLogError
(
logTag
"
%
s
RTP
Packet
Send
Failed
"
__FUNCTION__
)
;
return
-
1
;
}
}
int
WebrtcVideoConduit
:
:
SendRTCPPacket
(
int
channel
const
void
*
data
size_t
len
)
{
CSFLogDebug
(
logTag
"
%
s
:
channel
%
d
len
%
lu
"
__FUNCTION__
channel
(
unsigned
long
)
len
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
mReceiverTransport
&
&
mReceiverTransport
-
>
SendRtcpPacket
(
data
len
)
=
=
NS_OK
)
{
CSFLogDebug
(
logTag
"
%
s
Sent
RTCP
Packet
"
__FUNCTION__
)
;
return
len
;
}
else
if
(
mTransmitterTransport
&
&
(
mTransmitterTransport
-
>
SendRtcpPacket
(
data
len
)
=
=
NS_OK
)
)
{
CSFLogDebug
(
logTag
"
%
s
Sent
RTCP
Packet
(
sender
report
)
"
__FUNCTION__
)
;
return
len
;
}
else
{
CSFLogError
(
logTag
"
%
s
RTCP
Packet
Send
Failed
"
__FUNCTION__
)
;
return
-
1
;
}
}
int
WebrtcVideoConduit
:
:
FrameSizeChange
(
unsigned
int
width
unsigned
int
height
unsigned
int
numStreams
)
{
CSFLogDebug
(
logTag
"
%
s
"
__FUNCTION__
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
mReceivingWidth
=
width
;
mReceivingHeight
=
height
;
mNumReceivingStreams
=
numStreams
;
if
(
mRenderer
)
{
mRenderer
-
>
FrameSizeChange
(
width
height
numStreams
)
;
return
0
;
}
CSFLogError
(
logTag
"
%
s
Renderer
is
NULL
"
__FUNCTION__
)
;
return
-
1
;
}
int
WebrtcVideoConduit
:
:
DeliverFrame
(
unsigned
char
*
buffer
size_t
buffer_size
uint32_t
time_stamp
int64_t
ntp_time_ms
int64_t
render_time
void
*
handle
)
{
return
DeliverFrame
(
buffer
buffer_size
mReceivingWidth
(
mReceivingWidth
+
1
)
>
>
1
time_stamp
ntp_time_ms
render_time
handle
)
;
}
int
WebrtcVideoConduit
:
:
DeliverFrame
(
unsigned
char
*
buffer
size_t
buffer_size
uint32_t
y_stride
uint32_t
cbcr_stride
uint32_t
time_stamp
int64_t
ntp_time_ms
int64_t
render_time
void
*
handle
)
{
CSFLogDebug
(
logTag
"
%
s
Buffer
Size
%
lu
"
__FUNCTION__
(
unsigned
long
)
buffer_size
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
mRenderer
)
{
layers
:
:
Image
*
img
=
nullptr
;
if
(
handle
)
{
webrtc
:
:
NativeHandle
*
native_h
=
static_cast
<
webrtc
:
:
NativeHandle
*
>
(
handle
)
;
img
=
static_cast
<
layers
:
:
Image
*
>
(
native_h
-
>
GetHandle
(
)
)
;
}
if
(
mVideoLatencyTestEnable
&
&
mReceivingWidth
&
&
mReceivingHeight
)
{
uint64_t
now
=
PR_Now
(
)
;
uint64_t
timestamp
=
0
;
bool
ok
=
YuvStamper
:
:
Decode
(
mReceivingWidth
mReceivingHeight
mReceivingWidth
buffer
reinterpret_cast
<
unsigned
char
*
>
(
&
timestamp
)
sizeof
(
timestamp
)
0
0
)
;
if
(
ok
)
{
VideoLatencyUpdate
(
now
-
timestamp
)
;
}
}
const
ImageHandle
img_h
(
img
)
;
mRenderer
-
>
RenderVideoFrame
(
buffer
buffer_size
y_stride
cbcr_stride
time_stamp
render_time
img_h
)
;
return
0
;
}
CSFLogError
(
logTag
"
%
s
Renderer
is
NULL
"
__FUNCTION__
)
;
return
-
1
;
}
int
WebrtcVideoConduit
:
:
DeliverI420Frame
(
const
webrtc
:
:
I420VideoFrame
&
webrtc_frame
)
{
if
(
!
webrtc_frame
.
native_handle
(
)
)
{
uint32_t
y_stride
=
webrtc_frame
.
stride
(
static_cast
<
webrtc
:
:
PlaneType
>
(
0
)
)
;
return
DeliverFrame
(
const_cast
<
uint8_t
*
>
(
webrtc_frame
.
buffer
(
webrtc
:
:
kYPlane
)
)
CalcBufferSize
(
webrtc
:
:
kI420
y_stride
webrtc_frame
.
height
(
)
)
y_stride
webrtc_frame
.
stride
(
static_cast
<
webrtc
:
:
PlaneType
>
(
1
)
)
webrtc_frame
.
timestamp
(
)
webrtc_frame
.
ntp_time_ms
(
)
webrtc_frame
.
render_time_ms
(
)
nullptr
)
;
}
size_t
buffer_size
=
CalcBufferSize
(
webrtc
:
:
kI420
webrtc_frame
.
width
(
)
webrtc_frame
.
height
(
)
)
;
CSFLogDebug
(
logTag
"
%
s
Buffer
Size
%
lu
"
__FUNCTION__
(
unsigned
long
)
buffer_size
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
mRenderer
)
{
layers
:
:
Image
*
img
=
nullptr
;
webrtc
:
:
NativeHandle
*
native_h
=
static_cast
<
webrtc
:
:
NativeHandle
*
>
(
webrtc_frame
.
native_handle
(
)
)
;
if
(
native_h
)
{
img
=
static_cast
<
layers
:
:
Image
*
>
(
native_h
-
>
GetHandle
(
)
)
;
}
#
if
0
if
(
mVideoLatencyTestEnable
&
&
mReceivingWidth
&
&
mReceivingHeight
)
{
uint64_t
now
=
PR_Now
(
)
;
uint64_t
timestamp
=
0
;
bool
ok
=
YuvStamper
:
:
Decode
(
mReceivingWidth
mReceivingHeight
mReceivingWidth
buffer
reinterpret_cast
<
unsigned
char
*
>
(
&
timestamp
)
sizeof
(
timestamp
)
0
0
)
;
if
(
ok
)
{
VideoLatencyUpdate
(
now
-
timestamp
)
;
}
}
#
endif
const
ImageHandle
img_h
(
img
)
;
mRenderer
-
>
RenderVideoFrame
(
nullptr
buffer_size
webrtc_frame
.
timestamp
(
)
webrtc_frame
.
render_time_ms
(
)
img_h
)
;
return
0
;
}
CSFLogError
(
logTag
"
%
s
Renderer
is
NULL
"
__FUNCTION__
)
;
return
-
1
;
}
void
WebrtcVideoConduit
:
:
CodecConfigToWebRTCCodec
(
const
VideoCodecConfig
*
codecInfo
webrtc
:
:
VideoCodec
&
cinst
)
{
cinst
.
plType
=
codecInfo
-
>
mType
;
if
(
codecInfo
-
>
mName
=
=
"
H264
"
)
{
cinst
.
codecType
=
webrtc
:
:
kVideoCodecH264
;
PL_strncpyz
(
cinst
.
plName
"
H264
"
sizeof
(
cinst
.
plName
)
)
;
}
else
if
(
codecInfo
-
>
mName
=
=
"
VP8
"
)
{
cinst
.
codecType
=
webrtc
:
:
kVideoCodecVP8
;
PL_strncpyz
(
cinst
.
plName
"
VP8
"
sizeof
(
cinst
.
plName
)
)
;
}
else
if
(
codecInfo
-
>
mName
=
=
"
VP9
"
)
{
cinst
.
codecType
=
webrtc
:
:
kVideoCodecVP9
;
PL_strncpyz
(
cinst
.
plName
"
VP9
"
sizeof
(
cinst
.
plName
)
)
;
}
else
if
(
codecInfo
-
>
mName
=
=
"
I420
"
)
{
cinst
.
codecType
=
webrtc
:
:
kVideoCodecI420
;
PL_strncpyz
(
cinst
.
plName
"
I420
"
sizeof
(
cinst
.
plName
)
)
;
}
else
{
cinst
.
codecType
=
webrtc
:
:
kVideoCodecUnknown
;
PL_strncpyz
(
cinst
.
plName
"
Unknown
"
sizeof
(
cinst
.
plName
)
)
;
}
if
(
codecInfo
-
>
mEncodingConstraints
.
maxFps
>
0
)
{
cinst
.
maxFramerate
=
codecInfo
-
>
mEncodingConstraints
.
maxFps
;
}
else
{
cinst
.
maxFramerate
=
DEFAULT_VIDEO_MAX_FRAMERATE
;
}
cinst
.
minBitrate
=
mMinBitrate
?
mMinBitrate
:
200
;
cinst
.
startBitrate
=
mStartBitrate
?
mStartBitrate
:
300
;
cinst
.
targetBitrate
=
cinst
.
startBitrate
;
cinst
.
maxBitrate
=
MinIgnoreZero
(
2000U
codecInfo
-
>
mEncodingConstraints
.
maxBr
)
/
1000
;
cinst
.
maxBitrate
=
MinIgnoreZero
(
cinst
.
maxBitrate
mPrefMaxBitrate
)
;
if
(
cinst
.
codecType
=
=
webrtc
:
:
kVideoCodecH264
)
{
#
ifdef
MOZ_WEBRTC_OMX
cinst
.
resolution_divisor
=
16
;
#
endif
cinst
.
codecSpecific
.
H264
.
profile_byte
=
codecInfo
-
>
mProfile
;
cinst
.
codecSpecific
.
H264
.
constraints
=
codecInfo
-
>
mConstraints
;
cinst
.
codecSpecific
.
H264
.
level
=
codecInfo
-
>
mLevel
;
cinst
.
codecSpecific
.
H264
.
packetizationMode
=
codecInfo
-
>
mPacketizationMode
;
if
(
codecInfo
-
>
mEncodingConstraints
.
maxMbps
>
0
)
{
CSFLogError
(
logTag
"
%
s
H
.
264
max_mbps
not
supported
yet
"
__FUNCTION__
)
;
}
cinst
.
codecSpecific
.
H264
.
spsData
=
nullptr
;
cinst
.
codecSpecific
.
H264
.
spsLen
=
0
;
cinst
.
codecSpecific
.
H264
.
ppsData
=
nullptr
;
cinst
.
codecSpecific
.
H264
.
ppsLen
=
0
;
}
size_t
numberOfSimulcastEncodings
=
std
:
:
min
(
codecInfo
-
>
mSimulcastEncodings
.
size
(
)
(
size_t
)
webrtc
:
:
kMaxSimulcastStreams
)
;
for
(
size_t
i
=
0
;
i
<
numberOfSimulcastEncodings
;
+
+
i
)
{
const
VideoCodecConfig
:
:
SimulcastEncoding
&
encoding
=
codecInfo
-
>
mSimulcastEncodings
[
i
]
;
webrtc
:
:
SimulcastStream
stream
;
memset
(
&
stream
0
sizeof
(
stream
)
)
;
stream
.
width
=
cinst
.
width
;
stream
.
height
=
cinst
.
height
;
stream
.
numberOfTemporalLayers
=
1
;
stream
.
maxBitrate
=
cinst
.
maxBitrate
;
stream
.
targetBitrate
=
cinst
.
targetBitrate
;
stream
.
minBitrate
=
cinst
.
minBitrate
;
stream
.
qpMax
=
cinst
.
qpMax
;
strncpy
(
stream
.
rid
encoding
.
rid
.
c_str
(
)
sizeof
(
stream
.
rid
)
-
1
)
;
stream
.
rid
[
sizeof
(
stream
.
rid
)
-
1
]
=
0
;
stream
.
width
=
MinIgnoreZero
(
stream
.
width
(
unsigned
short
)
encoding
.
constraints
.
maxWidth
)
;
stream
.
height
=
MinIgnoreZero
(
stream
.
height
(
unsigned
short
)
encoding
.
constraints
.
maxHeight
)
;
stream
.
jsMaxBitrate
=
encoding
.
constraints
.
maxBr
/
1000
;
stream
.
jsScaleDownBy
=
encoding
.
constraints
.
scaleDownBy
;
MOZ_ASSERT
(
stream
.
jsScaleDownBy
>
=
1
.
0
)
;
uint32_t
width
=
stream
.
width
?
stream
.
width
:
640
;
uint32_t
height
=
stream
.
height
?
stream
.
height
:
480
;
uint32_t
new_width
=
uint32_t
(
width
/
stream
.
jsScaleDownBy
)
;
uint32_t
new_height
=
uint32_t
(
height
/
stream
.
jsScaleDownBy
)
;
if
(
new_width
!
=
width
|
|
new_height
!
=
height
)
{
SelectBitrates
(
new_width
new_height
stream
.
jsMaxBitrate
mLastFramerateTenths
stream
.
minBitrate
stream
.
targetBitrate
stream
.
maxBitrate
)
;
}
cinst
.
simulcastStream
[
numberOfSimulcastEncodings
-
i
-
1
]
=
stream
;
}
cinst
.
numberOfSimulcastStreams
=
numberOfSimulcastEncodings
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
ValidateCodecConfig
(
const
VideoCodecConfig
*
codecInfo
bool
send
)
{
if
(
!
codecInfo
)
{
CSFLogError
(
logTag
"
%
s
Null
CodecConfig
"
__FUNCTION__
)
;
return
kMediaConduitMalformedArgument
;
}
if
(
(
codecInfo
-
>
mName
.
empty
(
)
)
|
|
(
codecInfo
-
>
mName
.
length
(
)
>
=
CODEC_PLNAME_SIZE
)
)
{
CSFLogError
(
logTag
"
%
s
Invalid
Payload
Name
Length
"
__FUNCTION__
)
;
return
kMediaConduitMalformedArgument
;
}
return
kMediaConduitNoError
;
}
void
WebrtcVideoConduit
:
:
VideoLatencyUpdate
(
uint64_t
newSample
)
{
mVideoLatencyAvg
=
(
sRoundingPadding
*
newSample
+
sAlphaNum
*
mVideoLatencyAvg
)
/
sAlphaDen
;
}
uint64_t
WebrtcVideoConduit
:
:
MozVideoLatencyAvg
(
)
{
return
mVideoLatencyAvg
/
sRoundingPadding
;
}
uint64_t
WebrtcVideoConduit
:
:
CodecPluginID
(
)
{
if
(
mExternalSendCodecHandle
)
{
return
mExternalSendCodecHandle
-
>
PluginID
(
)
;
}
else
if
(
mExternalRecvCodecHandle
)
{
return
mExternalRecvCodecHandle
-
>
PluginID
(
)
;
}
return
0
;
}
bool
WebrtcVideoConduit
:
:
DetermineREDAndULPFECPayloadTypes
(
uint8_t
&
payload_type_red
uint8_t
&
payload_type_ulpfec
)
{
webrtc
:
:
VideoCodec
video_codec
;
payload_type_red
=
INVALID_RTP_PAYLOAD
;
payload_type_ulpfec
=
INVALID_RTP_PAYLOAD
;
for
(
int
idx
=
0
;
idx
<
mPtrViECodec
-
>
NumberOfCodecs
(
)
;
idx
+
+
)
{
if
(
mPtrViECodec
-
>
GetCodec
(
idx
video_codec
)
=
=
0
)
{
switch
(
video_codec
.
codecType
)
{
case
webrtc
:
:
VideoCodecType
:
:
kVideoCodecRED
:
payload_type_red
=
video_codec
.
plType
;
break
;
case
webrtc
:
:
VideoCodecType
:
:
kVideoCodecULPFEC
:
payload_type_ulpfec
=
video_codec
.
plType
;
break
;
default
:
break
;
}
}
}
return
payload_type_red
!
=
INVALID_RTP_PAYLOAD
&
&
payload_type_ulpfec
!
=
INVALID_RTP_PAYLOAD
;
}
}
