#
include
"
VideoStreamFactory
.
h
"
#
include
"
CSFLog
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
VideoConduit
.
h
"
namespace
mozilla
{
#
ifdef
LOGTAG
#
undef
LOGTAG
#
endif
#
define
LOGTAG
"
WebrtcVideoSessionConduit
"
#
define
MB_OF
(
w
h
)
(
(
unsigned
int
)
(
(
(
(
w
+
15
)
>
>
4
)
)
*
(
(
unsigned
int
)
(
(
h
+
15
)
>
>
4
)
)
)
)
static
VideoStreamFactory
:
:
ResolutionAndBitrateLimits
kResolutionAndBitrateLimits
[
]
=
{
{
MB_OF
(
1920
1200
)
KBPS
(
1500
)
KBPS
(
2000
)
KBPS
(
10000
)
}
{
MB_OF
(
1280
720
)
KBPS
(
1200
)
KBPS
(
1500
)
KBPS
(
5000
)
}
{
MB_OF
(
800
480
)
KBPS
(
600
)
KBPS
(
800
)
KBPS
(
2500
)
}
{
MB_OF
(
480
270
)
KBPS
(
150
)
KBPS
(
500
)
KBPS
(
2000
)
}
{
tl
:
:
Max
<
MB_OF
(
400
240
)
MB_OF
(
352
288
)
>
:
:
value
KBPS
(
125
)
KBPS
(
300
)
KBPS
(
1300
)
}
{
MB_OF
(
176
144
)
KBPS
(
100
)
KBPS
(
150
)
KBPS
(
500
)
}
{
0
KBPS
(
40
)
KBPS
(
80
)
KBPS
(
250
)
}
}
;
static
VideoStreamFactory
:
:
ResolutionAndBitrateLimits
GetLimitsFor
(
unsigned
int
aWidth
unsigned
int
aHeight
int
aCapBps
=
0
)
{
int
fs
=
MB_OF
(
aWidth
aHeight
)
;
for
(
const
auto
&
resAndLimits
:
kResolutionAndBitrateLimits
)
{
if
(
fs
>
resAndLimits
.
resolution_in_mb
&
&
(
aCapBps
=
=
0
|
|
resAndLimits
.
start_bitrate_bps
<
=
aCapBps
|
|
resAndLimits
.
resolution_in_mb
=
=
0
)
)
{
return
resAndLimits
;
}
}
MOZ_CRASH
(
"
Loop
should
have
handled
fallback
"
)
;
}
static
void
SelectBitrates
(
unsigned
short
width
unsigned
short
height
int
min
int
start
int
cap
int
pref_cap
int
negotiated_cap
webrtc
:
:
VideoStream
&
aVideoStream
)
{
int
&
out_min
=
aVideoStream
.
min_bitrate_bps
;
int
&
out_start
=
aVideoStream
.
target_bitrate_bps
;
int
&
out_max
=
aVideoStream
.
max_bitrate_bps
;
VideoStreamFactory
:
:
ResolutionAndBitrateLimits
resAndLimits
=
GetLimitsFor
(
width
height
)
;
out_min
=
MinIgnoreZero
(
resAndLimits
.
min_bitrate_bps
cap
)
;
out_start
=
MinIgnoreZero
(
resAndLimits
.
start_bitrate_bps
cap
)
;
out_max
=
MinIgnoreZero
(
resAndLimits
.
max_bitrate_bps
cap
)
;
out_max
=
MinIgnoreZero
(
negotiated_cap
out_max
)
;
out_min
=
std
:
:
min
(
out_min
out_max
)
;
out_start
=
std
:
:
min
(
out_start
out_max
)
;
if
(
min
&
&
min
>
out_min
)
{
out_min
=
min
;
}
out_min
=
std
:
:
max
(
kViEMinCodecBitrate_bps
out_min
)
;
out_max
=
std
:
:
max
(
kViEMinCodecBitrate_bps
out_max
)
;
if
(
start
&
&
start
>
out_start
)
{
out_start
=
start
;
}
if
(
out_min
>
out_max
)
{
out_min
=
out_max
;
}
out_start
=
std
:
:
min
(
out_max
std
:
:
max
(
out_start
out_min
)
)
;
MOZ_ASSERT
(
pref_cap
=
=
0
|
|
out_max
<
=
pref_cap
)
;
}
void
VideoStreamFactory
:
:
SetCodecMode
(
webrtc
:
:
VideoCodecMode
aCodecMode
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCodecMode
=
aCodecMode
;
}
void
VideoStreamFactory
:
:
SetSendingFramerate
(
unsigned
int
aSendingFramerate
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSendingFramerate
=
aSendingFramerate
;
}
std
:
:
vector
<
webrtc
:
:
VideoStream
>
VideoStreamFactory
:
:
CreateEncoderStreams
(
int
width
int
height
const
webrtc
:
:
VideoEncoderConfig
&
config
)
{
size_t
streamCount
=
config
.
number_of_streams
;
if
(
mCodecMode
=
=
webrtc
:
:
VideoCodecMode
:
:
kScreensharing
)
{
streamCount
=
1
;
}
std
:
:
vector
<
webrtc
:
:
VideoStream
>
streams
;
streams
.
reserve
(
streamCount
)
;
mSimulcastAdapter
-
>
OnOutputFormatRequest
(
cricket
:
:
VideoFormat
(
width
height
0
0
)
)
;
for
(
size_t
idx
=
streamCount
-
1
;
streamCount
>
0
;
idx
-
-
streamCount
-
-
)
{
webrtc
:
:
VideoStream
video_stream
;
auto
&
simulcastEncoding
=
mCodecConfig
.
mSimulcastEncodings
[
idx
]
;
MOZ_ASSERT
(
simulcastEncoding
.
constraints
.
scaleDownBy
>
=
1
.
0
)
;
int
unusedCropWidth
unusedCropHeight
outWidth
outHeight
;
if
(
idx
=
=
0
)
{
outWidth
=
width
;
outHeight
=
height
;
}
else
{
float
effectiveScaleDownBy
=
simulcastEncoding
.
constraints
.
scaleDownBy
/
mCodecConfig
.
mSimulcastEncodings
[
0
]
.
constraints
.
scaleDownBy
;
MOZ_ASSERT
(
effectiveScaleDownBy
>
=
1
.
0
)
;
mSimulcastAdapter
-
>
OnScaleResolutionBy
(
effectiveScaleDownBy
>
1
.
0
?
rtc
:
:
Optional
<
float
>
(
effectiveScaleDownBy
)
:
rtc
:
:
Optional
<
float
>
(
)
)
;
bool
rv
=
mSimulcastAdapter
-
>
AdaptFrameResolution
(
width
height
0
&
unusedCropWidth
&
unusedCropHeight
&
outWidth
&
outHeight
)
;
if
(
!
rv
)
{
outWidth
=
0
;
outHeight
=
0
;
}
}
if
(
outWidth
=
=
0
|
|
outHeight
=
=
0
)
{
CSFLogInfo
(
LOGTAG
"
%
s
Stream
with
RID
%
s
ignored
because
of
no
resolution
.
"
__FUNCTION__
simulcastEncoding
.
rid
.
c_str
(
)
)
;
continue
;
}
MOZ_ASSERT
(
outWidth
>
0
)
;
MOZ_ASSERT
(
outHeight
>
0
)
;
video_stream
.
width
=
outWidth
;
video_stream
.
height
=
outHeight
;
CSFLogInfo
(
LOGTAG
"
%
s
Input
frame
%
ux
%
u
RID
%
s
scaling
to
%
zux
%
zu
"
__FUNCTION__
width
height
simulcastEncoding
.
rid
.
c_str
(
)
video_stream
.
width
video_stream
.
height
)
;
if
(
video_stream
.
width
*
height
!
=
width
*
video_stream
.
height
)
{
CSFLogInfo
(
LOGTAG
"
%
s
Stream
with
RID
%
s
ignored
because
of
bad
aspect
ratio
.
"
__FUNCTION__
simulcastEncoding
.
rid
.
c_str
(
)
)
;
continue
;
}
video_stream
.
max_framerate
=
mSendingFramerate
;
SelectBitrates
(
video_stream
.
width
video_stream
.
height
mMinBitrate
mStartBitrate
simulcastEncoding
.
constraints
.
maxBr
mPrefMaxBitrate
mNegotiatedMaxBitrate
video_stream
)
;
video_stream
.
max_qp
=
kQpMax
;
video_stream
.
SetRid
(
simulcastEncoding
.
rid
)
;
video_stream
.
temporal_layer_thresholds_bps
.
clear
(
)
;
if
(
config
.
number_of_streams
>
1
)
{
if
(
mCodecMode
=
=
webrtc
:
:
VideoCodecMode
:
:
kScreensharing
)
{
video_stream
.
temporal_layer_thresholds_bps
.
push_back
(
video_stream
.
target_bitrate_bps
)
;
}
else
{
video_stream
.
temporal_layer_thresholds_bps
.
resize
(
2
)
;
}
}
if
(
mCodecConfig
.
mName
=
=
"
H264
"
)
{
if
(
mCodecConfig
.
mEncodingConstraints
.
maxMbps
>
0
)
{
CSFLogError
(
LOGTAG
"
%
s
H
.
264
max_mbps
not
supported
yet
"
__FUNCTION__
)
;
}
}
streams
.
push_back
(
video_stream
)
;
}
return
streams
;
}
}
