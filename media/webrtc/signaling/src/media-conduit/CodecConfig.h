#
ifndef
CODEC_CONFIG_H_
#
define
CODEC_CONFIG_H_
#
include
<
string
>
#
include
<
vector
>
#
include
"
signaling
/
src
/
common
/
EncodingConstraints
.
h
"
namespace
mozilla
{
struct
AudioCodecConfig
{
int
mType
;
std
:
:
string
mName
;
int
mFreq
;
int
mChannels
;
bool
mFECEnabled
;
bool
mDtmfEnabled
;
bool
mDTXEnabled
;
uint32_t
mMaxAverageBitrate
;
int
mMaxPlaybackRate
;
AudioCodecConfig
(
int
type
std
:
:
string
name
int
freq
int
channels
bool
FECEnabled
)
:
mType
(
type
)
mName
(
name
)
mFreq
(
freq
)
mChannels
(
channels
)
mFECEnabled
(
FECEnabled
)
mDtmfEnabled
(
false
)
mDTXEnabled
(
false
)
mMaxAverageBitrate
(
0
)
mMaxPlaybackRate
(
0
)
{
}
}
;
#
define
MAX_SPROP_LEN
128
struct
VideoCodecConfigH264
{
char
sprop_parameter_sets
[
MAX_SPROP_LEN
]
;
int
packetization_mode
;
int
profile_level_id
;
int
tias_bw
;
}
;
class
VideoCodecConfig
{
public
:
int
mType
;
std
:
:
string
mName
;
std
:
:
vector
<
std
:
:
string
>
mAckFbTypes
;
std
:
:
vector
<
std
:
:
string
>
mNackFbTypes
;
std
:
:
vector
<
std
:
:
string
>
mCcmFbTypes
;
bool
mRembFbSet
;
bool
mFECFbSet
;
bool
mTransportCCFbSet
;
int
mULPFECPayloadType
;
int
mREDPayloadType
;
int
mREDRTXPayloadType
;
int
mRTXPayloadType
;
uint32_t
mTias
;
EncodingConstraints
mEncodingConstraints
;
struct
Encoding
{
std
:
:
string
rid
;
EncodingConstraints
constraints
;
bool
operator
=
=
(
const
Encoding
&
aOther
)
const
{
return
rid
=
=
aOther
.
rid
&
&
constraints
=
=
aOther
.
constraints
;
}
}
;
std
:
:
vector
<
Encoding
>
mEncodings
;
std
:
:
string
mSpropParameterSets
;
uint8_t
mProfile
;
uint8_t
mConstraints
;
uint8_t
mLevel
;
uint8_t
mPacketizationMode
;
bool
operator
=
=
(
const
VideoCodecConfig
&
aRhs
)
const
{
if
(
mType
!
=
aRhs
.
mType
|
|
mName
!
=
aRhs
.
mName
|
|
mAckFbTypes
!
=
aRhs
.
mAckFbTypes
|
|
mNackFbTypes
!
=
aRhs
.
mNackFbTypes
|
|
mCcmFbTypes
!
=
aRhs
.
mCcmFbTypes
|
|
mRembFbSet
!
=
aRhs
.
mRembFbSet
|
|
mFECFbSet
!
=
aRhs
.
mFECFbSet
|
|
mTransportCCFbSet
!
=
aRhs
.
mTransportCCFbSet
|
|
mULPFECPayloadType
!
=
aRhs
.
mULPFECPayloadType
|
|
mREDPayloadType
!
=
aRhs
.
mREDPayloadType
|
|
mREDRTXPayloadType
!
=
aRhs
.
mREDRTXPayloadType
|
|
mRTXPayloadType
!
=
aRhs
.
mRTXPayloadType
|
|
mTias
!
=
aRhs
.
mTias
|
|
!
(
mEncodingConstraints
=
=
aRhs
.
mEncodingConstraints
)
|
|
!
(
mEncodings
=
=
aRhs
.
mEncodings
)
|
|
mSpropParameterSets
!
=
aRhs
.
mSpropParameterSets
|
|
mProfile
!
=
aRhs
.
mProfile
|
|
mConstraints
!
=
aRhs
.
mConstraints
|
|
mLevel
!
=
aRhs
.
mLevel
|
|
mPacketizationMode
!
=
aRhs
.
mPacketizationMode
)
{
return
false
;
}
return
true
;
}
VideoCodecConfig
(
int
type
std
:
:
string
name
const
EncodingConstraints
&
constraints
const
struct
VideoCodecConfigH264
*
h264
=
nullptr
)
:
mType
(
type
)
mName
(
name
)
mRembFbSet
(
false
)
mFECFbSet
(
false
)
mTransportCCFbSet
(
false
)
mULPFECPayloadType
(
123
)
mREDPayloadType
(
122
)
mREDRTXPayloadType
(
-
1
)
mRTXPayloadType
(
-
1
)
mTias
(
0
)
mEncodingConstraints
(
constraints
)
mProfile
(
0x42
)
mConstraints
(
0xE0
)
mLevel
(
0x0C
)
mPacketizationMode
(
1
)
{
if
(
h264
)
{
mProfile
=
(
h264
-
>
profile_level_id
&
0x00FF0000
)
>
>
16
;
mConstraints
=
(
h264
-
>
profile_level_id
&
0x0000FF00
)
>
>
8
;
mLevel
=
(
h264
-
>
profile_level_id
&
0x000000FF
)
;
mPacketizationMode
=
h264
-
>
packetization_mode
;
mSpropParameterSets
=
h264
-
>
sprop_parameter_sets
;
}
}
bool
ResolutionEquals
(
const
VideoCodecConfig
&
aConfig
)
const
{
if
(
mEncodings
.
size
(
)
!
=
aConfig
.
mEncodings
.
size
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
mEncodings
.
size
(
)
;
+
+
i
)
{
if
(
!
mEncodings
[
i
]
.
constraints
.
ResolutionEquals
(
aConfig
.
mEncodings
[
i
]
.
constraints
)
)
{
return
false
;
}
}
return
true
;
}
bool
RtcpFbAckIsSet
(
const
std
:
:
string
&
type
)
const
{
for
(
auto
i
=
mAckFbTypes
.
begin
(
)
;
i
!
=
mAckFbTypes
.
end
(
)
;
+
+
i
)
{
if
(
*
i
=
=
type
)
{
return
true
;
}
}
return
false
;
}
bool
RtcpFbNackIsSet
(
const
std
:
:
string
&
type
)
const
{
for
(
auto
i
=
mNackFbTypes
.
begin
(
)
;
i
!
=
mNackFbTypes
.
end
(
)
;
+
+
i
)
{
if
(
*
i
=
=
type
)
{
return
true
;
}
}
return
false
;
}
bool
RtcpFbCcmIsSet
(
const
std
:
:
string
&
type
)
const
{
for
(
auto
i
=
mCcmFbTypes
.
begin
(
)
;
i
!
=
mCcmFbTypes
.
end
(
)
;
+
+
i
)
{
if
(
*
i
=
=
type
)
{
return
true
;
}
}
return
false
;
}
bool
RtcpFbRembIsSet
(
)
const
{
return
mRembFbSet
;
}
bool
RtcpFbFECIsSet
(
)
const
{
return
mFECFbSet
;
}
bool
RtcpFbTransportCCIsSet
(
)
const
{
return
mTransportCCFbSet
;
}
bool
RtxPayloadTypeIsSet
(
)
const
{
return
mRTXPayloadType
!
=
-
1
;
}
}
;
}
#
endif
