#
include
"
rtc_base
/
sslidentity
.
h
"
#
include
<
ctime
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
rtc_base
/
base64
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
opensslidentity
.
h
"
#
include
"
rtc_base
/
ptr_util
.
h
"
#
include
"
rtc_base
/
sslfingerprint
.
h
"
namespace
rtc
{
const
char
kPemTypeCertificate
[
]
=
"
CERTIFICATE
"
;
const
char
kPemTypeRsaPrivateKey
[
]
=
"
RSA
PRIVATE
KEY
"
;
const
char
kPemTypeEcPrivateKey
[
]
=
"
EC
PRIVATE
KEY
"
;
SSLCertificateStats
:
:
SSLCertificateStats
(
std
:
:
string
&
&
fingerprint
std
:
:
string
&
&
fingerprint_algorithm
std
:
:
string
&
&
base64_certificate
std
:
:
unique_ptr
<
SSLCertificateStats
>
&
&
issuer
)
:
fingerprint
(
std
:
:
move
(
fingerprint
)
)
fingerprint_algorithm
(
std
:
:
move
(
fingerprint_algorithm
)
)
base64_certificate
(
std
:
:
move
(
base64_certificate
)
)
issuer
(
std
:
:
move
(
issuer
)
)
{
}
SSLCertificateStats
:
:
~
SSLCertificateStats
(
)
{
}
std
:
:
unique_ptr
<
SSLCertificateStats
>
SSLCertificate
:
:
GetStats
(
)
const
{
std
:
:
unique_ptr
<
SSLCertChain
>
chain
=
GetChain
(
)
;
std
:
:
unique_ptr
<
SSLCertificateStats
>
issuer
;
if
(
chain
)
{
for
(
ptrdiff_t
i
=
chain
-
>
GetSize
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
const
SSLCertificate
*
cert
=
&
chain
-
>
Get
(
i
)
;
issuer
=
cert
-
>
GetStats
(
std
:
:
move
(
issuer
)
)
;
}
}
return
GetStats
(
std
:
:
move
(
issuer
)
)
;
}
std
:
:
unique_ptr
<
SSLCertificate
>
SSLCertificate
:
:
GetUniqueReference
(
)
const
{
return
WrapUnique
(
GetReference
(
)
)
;
}
std
:
:
unique_ptr
<
SSLCertificateStats
>
SSLCertificate
:
:
GetStats
(
std
:
:
unique_ptr
<
SSLCertificateStats
>
issuer
)
const
{
std
:
:
string
digest_algorithm
;
if
(
!
GetSignatureDigestAlgorithm
(
&
digest_algorithm
)
)
return
nullptr
;
std
:
:
unique_ptr
<
SSLFingerprint
>
ssl_fingerprint
(
SSLFingerprint
:
:
Create
(
digest_algorithm
this
)
)
;
if
(
!
ssl_fingerprint
)
return
nullptr
;
std
:
:
string
fingerprint
=
ssl_fingerprint
-
>
GetRfc4572Fingerprint
(
)
;
Buffer
der_buffer
;
ToDER
(
&
der_buffer
)
;
std
:
:
string
der_base64
;
Base64
:
:
EncodeFromArray
(
der_buffer
.
data
(
)
der_buffer
.
size
(
)
&
der_base64
)
;
return
std
:
:
unique_ptr
<
SSLCertificateStats
>
(
new
SSLCertificateStats
(
std
:
:
move
(
fingerprint
)
std
:
:
move
(
digest_algorithm
)
std
:
:
move
(
der_base64
)
std
:
:
move
(
issuer
)
)
)
;
}
KeyParams
:
:
KeyParams
(
KeyType
key_type
)
{
if
(
key_type
=
=
KT_ECDSA
)
{
type_
=
KT_ECDSA
;
params_
.
curve
=
EC_NIST_P256
;
}
else
if
(
key_type
=
=
KT_RSA
)
{
type_
=
KT_RSA
;
params_
.
rsa
.
mod_size
=
kRsaDefaultModSize
;
params_
.
rsa
.
pub_exp
=
kRsaDefaultExponent
;
}
else
{
RTC_NOTREACHED
(
)
;
}
}
KeyParams
KeyParams
:
:
RSA
(
int
mod_size
int
pub_exp
)
{
KeyParams
kt
(
KT_RSA
)
;
kt
.
params_
.
rsa
.
mod_size
=
mod_size
;
kt
.
params_
.
rsa
.
pub_exp
=
pub_exp
;
return
kt
;
}
KeyParams
KeyParams
:
:
ECDSA
(
ECCurve
curve
)
{
KeyParams
kt
(
KT_ECDSA
)
;
kt
.
params_
.
curve
=
curve
;
return
kt
;
}
bool
KeyParams
:
:
IsValid
(
)
const
{
if
(
type_
=
=
KT_RSA
)
{
return
(
params_
.
rsa
.
mod_size
>
=
kRsaMinModSize
&
&
params_
.
rsa
.
mod_size
<
=
kRsaMaxModSize
&
&
params_
.
rsa
.
pub_exp
>
params_
.
rsa
.
mod_size
)
;
}
else
if
(
type_
=
=
KT_ECDSA
)
{
return
(
params_
.
curve
=
=
EC_NIST_P256
)
;
}
return
false
;
}
RSAParams
KeyParams
:
:
rsa_params
(
)
const
{
RTC_DCHECK
(
type_
=
=
KT_RSA
)
;
return
params_
.
rsa
;
}
ECCurve
KeyParams
:
:
ec_curve
(
)
const
{
RTC_DCHECK
(
type_
=
=
KT_ECDSA
)
;
return
params_
.
curve
;
}
KeyType
IntKeyTypeFamilyToKeyType
(
int
key_type_family
)
{
return
static_cast
<
KeyType
>
(
key_type_family
)
;
}
bool
SSLIdentity
:
:
PemToDer
(
const
std
:
:
string
&
pem_type
const
std
:
:
string
&
pem_string
std
:
:
string
*
der
)
{
size_t
header
=
pem_string
.
find
(
"
-
-
-
-
-
BEGIN
"
+
pem_type
+
"
-
-
-
-
-
"
)
;
if
(
header
=
=
std
:
:
string
:
:
npos
)
return
false
;
size_t
body
=
pem_string
.
find
(
"
\
n
"
header
)
;
if
(
body
=
=
std
:
:
string
:
:
npos
)
return
false
;
size_t
trailer
=
pem_string
.
find
(
"
-
-
-
-
-
END
"
+
pem_type
+
"
-
-
-
-
-
"
)
;
if
(
trailer
=
=
std
:
:
string
:
:
npos
)
return
false
;
std
:
:
string
inner
=
pem_string
.
substr
(
body
+
1
trailer
-
(
body
+
1
)
)
;
*
der
=
Base64
:
:
Decode
(
inner
Base64
:
:
DO_PARSE_WHITE
|
Base64
:
:
DO_PAD_ANY
|
Base64
:
:
DO_TERM_BUFFER
)
;
return
true
;
}
std
:
:
string
SSLIdentity
:
:
DerToPem
(
const
std
:
:
string
&
pem_type
const
unsigned
char
*
data
size_t
length
)
{
std
:
:
stringstream
result
;
result
<
<
"
-
-
-
-
-
BEGIN
"
<
<
pem_type
<
<
"
-
-
-
-
-
\
n
"
;
std
:
:
string
b64_encoded
;
Base64
:
:
EncodeFromArray
(
data
length
&
b64_encoded
)
;
static
const
size_t
kChunkSize
=
64
;
size_t
chunks
=
(
b64_encoded
.
size
(
)
+
(
kChunkSize
-
1
)
)
/
kChunkSize
;
for
(
size_t
i
=
0
chunk_offset
=
0
;
i
<
chunks
;
+
+
i
chunk_offset
+
=
kChunkSize
)
{
result
<
<
b64_encoded
.
substr
(
chunk_offset
kChunkSize
)
;
result
<
<
"
\
n
"
;
}
result
<
<
"
-
-
-
-
-
END
"
<
<
pem_type
<
<
"
-
-
-
-
-
\
n
"
;
return
result
.
str
(
)
;
}
SSLCertChain
:
:
SSLCertChain
(
std
:
:
vector
<
std
:
:
unique_ptr
<
SSLCertificate
>
>
certs
)
:
certs_
(
std
:
:
move
(
certs
)
)
{
}
SSLCertChain
:
:
SSLCertChain
(
const
std
:
:
vector
<
SSLCertificate
*
>
&
certs
)
{
RTC_DCHECK
(
!
certs
.
empty
(
)
)
;
certs_
.
resize
(
certs
.
size
(
)
)
;
std
:
:
transform
(
certs
.
begin
(
)
certs
.
end
(
)
certs_
.
begin
(
)
[
]
(
const
SSLCertificate
*
cert
)
-
>
std
:
:
unique_ptr
<
SSLCertificate
>
{
return
cert
-
>
GetUniqueReference
(
)
;
}
)
;
}
SSLCertChain
:
:
SSLCertChain
(
const
SSLCertificate
*
cert
)
{
certs_
.
push_back
(
cert
-
>
GetUniqueReference
(
)
)
;
}
SSLCertChain
:
:
~
SSLCertChain
(
)
{
}
SSLCertChain
*
SSLCertChain
:
:
Copy
(
)
const
{
std
:
:
vector
<
std
:
:
unique_ptr
<
SSLCertificate
>
>
new_certs
(
certs_
.
size
(
)
)
;
std
:
:
transform
(
certs_
.
begin
(
)
certs_
.
end
(
)
new_certs
.
begin
(
)
[
]
(
const
std
:
:
unique_ptr
<
SSLCertificate
>
&
cert
)
-
>
std
:
:
unique_ptr
<
SSLCertificate
>
{
return
cert
-
>
GetUniqueReference
(
)
;
}
)
;
return
new
SSLCertChain
(
std
:
:
move
(
new_certs
)
)
;
}
SSLCertificate
*
SSLCertificate
:
:
FromPEMString
(
const
std
:
:
string
&
pem_string
)
{
return
OpenSSLCertificate
:
:
FromPEMString
(
pem_string
)
;
}
SSLIdentity
*
SSLIdentity
:
:
GenerateWithExpiration
(
const
std
:
:
string
&
common_name
const
KeyParams
&
key_params
time_t
certificate_lifetime
)
{
return
OpenSSLIdentity
:
:
GenerateWithExpiration
(
common_name
key_params
certificate_lifetime
)
;
}
SSLIdentity
*
SSLIdentity
:
:
Generate
(
const
std
:
:
string
&
common_name
const
KeyParams
&
key_params
)
{
return
OpenSSLIdentity
:
:
GenerateWithExpiration
(
common_name
key_params
kDefaultCertificateLifetimeInSeconds
)
;
}
SSLIdentity
*
SSLIdentity
:
:
Generate
(
const
std
:
:
string
&
common_name
KeyType
key_type
)
{
return
OpenSSLIdentity
:
:
GenerateWithExpiration
(
common_name
KeyParams
(
key_type
)
kDefaultCertificateLifetimeInSeconds
)
;
}
SSLIdentity
*
SSLIdentity
:
:
GenerateForTest
(
const
SSLIdentityParams
&
params
)
{
return
OpenSSLIdentity
:
:
GenerateForTest
(
params
)
;
}
SSLIdentity
*
SSLIdentity
:
:
FromPEMStrings
(
const
std
:
:
string
&
private_key
const
std
:
:
string
&
certificate
)
{
return
OpenSSLIdentity
:
:
FromPEMStrings
(
private_key
certificate
)
;
}
SSLIdentity
*
SSLIdentity
:
:
FromPEMChainStrings
(
const
std
:
:
string
&
private_key
const
std
:
:
string
&
certificate_chain
)
{
return
OpenSSLIdentity
:
:
FromPEMChainStrings
(
private_key
certificate_chain
)
;
}
bool
operator
=
=
(
const
SSLIdentity
&
a
const
SSLIdentity
&
b
)
{
return
static_cast
<
const
OpenSSLIdentity
&
>
(
a
)
=
=
static_cast
<
const
OpenSSLIdentity
&
>
(
b
)
;
}
bool
operator
!
=
(
const
SSLIdentity
&
a
const
SSLIdentity
&
b
)
{
return
!
(
a
=
=
b
)
;
}
static
inline
int
ASN1ReadInt
(
const
unsigned
char
*
*
pp
size_t
*
np
size_t
n
)
{
const
unsigned
char
*
p
=
*
pp
;
int
x
=
0
;
for
(
size_t
i
=
0
;
i
<
n
;
i
+
+
)
x
=
10
*
x
+
p
[
i
]
-
'
0
'
;
*
pp
=
p
+
n
;
*
np
=
*
np
-
n
;
return
x
;
}
int64_t
ASN1TimeToSec
(
const
unsigned
char
*
s
size_t
length
bool
long_format
)
{
size_t
bytes_left
=
length
;
if
(
length
=
=
0
|
|
s
[
length
-
1
]
!
=
'
Z
'
)
return
-
1
;
size_t
n
=
strspn
(
reinterpret_cast
<
const
char
*
>
(
s
)
"
0123456789
"
)
;
if
(
n
+
1
!
=
length
)
return
-
1
;
int
year
;
if
(
long_format
)
{
if
(
bytes_left
<
11
)
return
-
1
;
year
=
ASN1ReadInt
(
&
s
&
bytes_left
4
)
;
year
-
=
1900
;
}
else
{
if
(
bytes_left
<
9
)
return
-
1
;
year
=
ASN1ReadInt
(
&
s
&
bytes_left
2
)
;
if
(
year
<
50
)
year
+
=
100
;
}
std
:
:
tm
tm
;
tm
.
tm_year
=
year
;
tm
.
tm_mon
=
ASN1ReadInt
(
&
s
&
bytes_left
2
)
-
1
;
tm
.
tm_mday
=
ASN1ReadInt
(
&
s
&
bytes_left
2
)
;
tm
.
tm_hour
=
ASN1ReadInt
(
&
s
&
bytes_left
2
)
;
tm
.
tm_min
=
ASN1ReadInt
(
&
s
&
bytes_left
2
)
;
tm
.
tm_sec
=
ASN1ReadInt
(
&
s
&
bytes_left
2
)
;
if
(
bytes_left
!
=
1
)
{
return
-
1
;
}
return
TmToSeconds
(
tm
)
;
}
}
