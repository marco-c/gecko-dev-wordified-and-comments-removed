#
ifndef
RTC_BASE_SSLSTREAMADAPTER_H_
#
define
RTC_BASE_SSLSTREAMADAPTER_H_
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
rtc_base
/
sslidentity
.
h
"
#
include
"
rtc_base
/
stream
.
h
"
namespace
rtc
{
const
int
TLS_NULL_WITH_NULL_NULL
=
0
;
const
int
SRTP_INVALID_CRYPTO_SUITE
=
0
;
#
ifndef
SRTP_AES128_CM_SHA1_80
const
int
SRTP_AES128_CM_SHA1_80
=
0x0001
;
#
endif
#
ifndef
SRTP_AES128_CM_SHA1_32
const
int
SRTP_AES128_CM_SHA1_32
=
0x0002
;
#
endif
#
ifndef
SRTP_AEAD_AES_128_GCM
const
int
SRTP_AEAD_AES_128_GCM
=
0x0007
;
#
endif
#
ifndef
SRTP_AEAD_AES_256_GCM
const
int
SRTP_AEAD_AES_256_GCM
=
0x0008
;
#
endif
extern
const
char
CS_AES_CM_128_HMAC_SHA1_80
[
]
;
extern
const
char
CS_AES_CM_128_HMAC_SHA1_32
[
]
;
extern
const
char
CS_AEAD_AES_128_GCM
[
]
;
extern
const
char
CS_AEAD_AES_256_GCM
[
]
;
std
:
:
string
SrtpCryptoSuiteToName
(
int
crypto_suite
)
;
int
SrtpCryptoSuiteFromName
(
const
std
:
:
string
&
crypto_suite
)
;
bool
GetSrtpKeyAndSaltLengths
(
int
crypto_suite
int
*
key_length
int
*
salt_length
)
;
bool
IsGcmCryptoSuite
(
int
crypto_suite
)
;
bool
IsGcmCryptoSuiteName
(
const
std
:
:
string
&
crypto_suite
)
;
struct
CryptoOptions
{
CryptoOptions
(
)
{
}
static
CryptoOptions
NoGcm
(
)
;
bool
enable_gcm_crypto_suites
=
false
;
bool
enable_encrypted_rtp_header_extensions
=
false
;
}
;
std
:
:
vector
<
int
>
GetSupportedDtlsSrtpCryptoSuites
(
const
rtc
:
:
CryptoOptions
&
crypto_options
)
;
enum
SSLRole
{
SSL_CLIENT
SSL_SERVER
}
;
enum
SSLMode
{
SSL_MODE_TLS
SSL_MODE_DTLS
}
;
enum
SSLProtocolVersion
{
SSL_PROTOCOL_TLS_10
SSL_PROTOCOL_TLS_11
SSL_PROTOCOL_TLS_12
SSL_PROTOCOL_DTLS_10
=
SSL_PROTOCOL_TLS_11
SSL_PROTOCOL_DTLS_12
=
SSL_PROTOCOL_TLS_12
}
;
enum
class
SSLPeerCertificateDigestError
{
NONE
UNKNOWN_ALGORITHM
INVALID_LENGTH
VERIFICATION_FAILED
}
;
enum
{
SSE_MSG_TRUNC
=
0xff0001
}
;
enum
class
SSLHandshakeError
{
UNKNOWN
INCOMPATIBLE_CIPHERSUITE
MAX_VALUE
}
;
class
SSLStreamAdapter
:
public
StreamAdapterInterface
{
public
:
static
SSLStreamAdapter
*
Create
(
StreamInterface
*
stream
)
;
explicit
SSLStreamAdapter
(
StreamInterface
*
stream
)
;
~
SSLStreamAdapter
(
)
override
;
void
set_ignore_bad_cert
(
bool
ignore
)
{
ignore_bad_cert_
=
ignore
;
}
bool
ignore_bad_cert
(
)
const
{
return
ignore_bad_cert_
;
}
void
set_client_auth_enabled
(
bool
enabled
)
{
client_auth_enabled_
=
enabled
;
}
bool
client_auth_enabled
(
)
const
{
return
client_auth_enabled_
;
}
virtual
void
SetIdentity
(
SSLIdentity
*
identity
)
=
0
;
virtual
void
SetServerRole
(
SSLRole
role
=
SSL_SERVER
)
=
0
;
virtual
void
SetMode
(
SSLMode
mode
)
=
0
;
virtual
void
SetMaxProtocolVersion
(
SSLProtocolVersion
version
)
=
0
;
virtual
void
SetInitialRetransmissionTimeout
(
int
timeout_ms
)
=
0
;
virtual
int
StartSSL
(
)
=
0
;
virtual
bool
SetPeerCertificateDigest
(
const
std
:
:
string
&
digest_alg
const
unsigned
char
*
digest_val
size_t
digest_len
SSLPeerCertificateDigestError
*
error
=
nullptr
)
=
0
;
virtual
std
:
:
unique_ptr
<
SSLCertificate
>
GetPeerCertificate
(
)
const
=
0
;
virtual
std
:
:
unique_ptr
<
SSLCertChain
>
GetPeerSSLCertChain
(
)
const
=
0
;
virtual
bool
GetSslCipherSuite
(
int
*
cipher_suite
)
;
virtual
int
GetSslVersion
(
)
const
=
0
;
virtual
bool
ExportKeyingMaterial
(
const
std
:
:
string
&
label
const
uint8_t
*
context
size_t
context_len
bool
use_context
uint8_t
*
result
size_t
result_len
)
;
virtual
bool
SetDtlsSrtpCryptoSuites
(
const
std
:
:
vector
<
int
>
&
crypto_suites
)
;
virtual
bool
GetDtlsSrtpCryptoSuite
(
int
*
crypto_suite
)
;
virtual
bool
IsTlsConnected
(
)
=
0
;
static
bool
IsBoringSsl
(
)
;
static
bool
IsAcceptableCipher
(
int
cipher
KeyType
key_type
)
;
static
bool
IsAcceptableCipher
(
const
std
:
:
string
&
cipher
KeyType
key_type
)
;
static
std
:
:
string
SslCipherSuiteToName
(
int
cipher_suite
)
;
static
void
enable_time_callback_for_testing
(
)
;
sigslot
:
:
signal1
<
SSLHandshakeError
>
SignalSSLHandshakeError
;
private
:
bool
ignore_bad_cert_
;
bool
client_auth_enabled_
;
}
;
}
#
endif
