#
ifndef
RTC_BASE_STRING_TO_NUMBER_H_
#
define
RTC_BASE_STRING_TO_NUMBER_H_
#
include
<
string
>
#
include
<
limits
>
#
include
"
api
/
optional
.
h
"
namespace
rtc
{
namespace
string_to_number_internal
{
using
unsigned_type
=
unsigned
long
long
;
using
signed_type
=
long
long
;
rtc
:
:
Optional
<
signed_type
>
ParseSigned
(
const
char
*
str
int
base
)
;
rtc
:
:
Optional
<
unsigned_type
>
ParseUnsigned
(
const
char
*
str
int
base
)
;
}
template
<
typename
T
>
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_signed
<
T
>
:
:
value
rtc
:
:
Optional
<
T
>
>
:
:
type
StringToNumber
(
const
char
*
str
int
base
=
10
)
{
using
string_to_number_internal
:
:
signed_type
;
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
<
=
std
:
:
numeric_limits
<
signed_type
>
:
:
max
(
)
&
&
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
>
=
std
:
:
numeric_limits
<
signed_type
>
:
:
lowest
(
)
"
StringToNumber
only
supports
signed
integers
as
large
as
long
long
int
"
)
;
rtc
:
:
Optional
<
signed_type
>
value
=
string_to_number_internal
:
:
ParseSigned
(
str
base
)
;
if
(
value
&
&
*
value
>
=
std
:
:
numeric_limits
<
T
>
:
:
lowest
(
)
&
&
*
value
<
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
)
{
return
static_cast
<
T
>
(
*
value
)
;
}
return
rtc
:
:
nullopt
;
}
template
<
typename
T
>
typename
std
:
:
enable_if
<
std
:
:
is_integral
<
T
>
:
:
value
&
&
std
:
:
is_unsigned
<
T
>
:
:
value
rtc
:
:
Optional
<
T
>
>
:
:
type
StringToNumber
(
const
char
*
str
int
base
=
10
)
{
using
string_to_number_internal
:
:
unsigned_type
;
static_assert
(
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
<
=
std
:
:
numeric_limits
<
unsigned_type
>
:
:
max
(
)
"
StringToNumber
only
supports
unsigned
integers
as
large
as
"
"
unsigned
long
long
int
"
)
;
rtc
:
:
Optional
<
unsigned_type
>
value
=
string_to_number_internal
:
:
ParseUnsigned
(
str
base
)
;
if
(
value
&
&
*
value
<
=
std
:
:
numeric_limits
<
T
>
:
:
max
(
)
)
{
return
static_cast
<
T
>
(
*
value
)
;
}
return
rtc
:
:
nullopt
;
}
template
<
typename
T
>
auto
StringToNumber
(
const
std
:
:
string
&
str
int
base
=
10
)
-
>
decltype
(
StringToNumber
<
T
>
(
str
.
c_str
(
)
base
)
)
{
return
StringToNumber
<
T
>
(
str
.
c_str
(
)
base
)
;
}
}
#
endif
