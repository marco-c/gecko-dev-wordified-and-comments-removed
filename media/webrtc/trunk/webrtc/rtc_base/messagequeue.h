#
ifndef
RTC_BASE_MESSAGEQUEUE_H_
#
define
RTC_BASE_MESSAGEQUEUE_H_
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
list
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
rtc_base
/
basictypes
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
location
.
h
"
#
include
"
rtc_base
/
messagehandler
.
h
"
#
include
"
rtc_base
/
scoped_ref_ptr
.
h
"
#
include
"
rtc_base
/
sigslot
.
h
"
#
include
"
rtc_base
/
socketserver
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
namespace
rtc
{
struct
Message
;
class
MessageQueue
;
class
MessageQueueManager
{
public
:
static
void
Add
(
MessageQueue
*
message_queue
)
;
static
void
Remove
(
MessageQueue
*
message_queue
)
;
static
void
Clear
(
MessageHandler
*
handler
)
;
static
bool
IsInitialized
(
)
;
static
void
ProcessAllMessageQueues
(
)
;
private
:
static
MessageQueueManager
*
Instance
(
)
;
MessageQueueManager
(
)
;
~
MessageQueueManager
(
)
;
void
AddInternal
(
MessageQueue
*
message_queue
)
;
void
RemoveInternal
(
MessageQueue
*
message_queue
)
;
void
ClearInternal
(
MessageHandler
*
handler
)
;
void
ProcessAllMessageQueuesInternal
(
)
;
static
MessageQueueManager
*
instance_
;
std
:
:
vector
<
MessageQueue
*
>
message_queues_
RTC_GUARDED_BY
(
crit_
)
;
CriticalSection
crit_
;
size_t
processing_
RTC_GUARDED_BY
(
crit_
)
;
}
;
class
MessageData
{
public
:
MessageData
(
)
{
}
virtual
~
MessageData
(
)
{
}
}
;
template
<
class
T
>
class
TypedMessageData
:
public
MessageData
{
public
:
explicit
TypedMessageData
(
const
T
&
data
)
:
data_
(
data
)
{
}
const
T
&
data
(
)
const
{
return
data_
;
}
T
&
data
(
)
{
return
data_
;
}
private
:
T
data_
;
}
;
template
<
class
T
>
class
ScopedMessageData
:
public
MessageData
{
public
:
explicit
ScopedMessageData
(
std
:
:
unique_ptr
<
T
>
data
)
:
data_
(
std
:
:
move
(
data
)
)
{
}
explicit
ScopedMessageData
(
T
*
data
)
:
data_
(
data
)
{
}
const
std
:
:
unique_ptr
<
T
>
&
data
(
)
const
{
return
data_
;
}
std
:
:
unique_ptr
<
T
>
&
data
(
)
{
return
data_
;
}
const
T
&
inner_data
(
)
const
{
return
*
data_
;
}
T
&
inner_data
(
)
{
return
*
data_
;
}
private
:
std
:
:
unique_ptr
<
T
>
data_
;
}
;
template
<
class
T
>
class
ScopedRefMessageData
:
public
MessageData
{
public
:
explicit
ScopedRefMessageData
(
T
*
data
)
:
data_
(
data
)
{
}
const
scoped_refptr
<
T
>
&
data
(
)
const
{
return
data_
;
}
scoped_refptr
<
T
>
&
data
(
)
{
return
data_
;
}
private
:
scoped_refptr
<
T
>
data_
;
}
;
template
<
class
T
>
inline
MessageData
*
WrapMessageData
(
const
T
&
data
)
{
return
new
TypedMessageData
<
T
>
(
data
)
;
}
template
<
class
T
>
inline
const
T
&
UseMessageData
(
MessageData
*
data
)
{
return
static_cast
<
TypedMessageData
<
T
>
*
>
(
data
)
-
>
data
(
)
;
}
template
<
class
T
>
class
DisposeData
:
public
MessageData
{
public
:
explicit
DisposeData
(
T
*
data
)
:
data_
(
data
)
{
}
virtual
~
DisposeData
(
)
{
delete
data_
;
}
private
:
T
*
data_
;
}
;
const
uint32_t
MQID_ANY
=
static_cast
<
uint32_t
>
(
-
1
)
;
const
uint32_t
MQID_DISPOSE
=
static_cast
<
uint32_t
>
(
-
2
)
;
struct
Message
{
Message
(
)
:
phandler
(
nullptr
)
message_id
(
0
)
pdata
(
nullptr
)
ts_sensitive
(
0
)
{
}
inline
bool
Match
(
MessageHandler
*
handler
uint32_t
id
)
const
{
return
(
handler
=
=
nullptr
|
|
handler
=
=
phandler
)
&
&
(
id
=
=
MQID_ANY
|
|
id
=
=
message_id
)
;
}
Location
posted_from
;
MessageHandler
*
phandler
;
uint32_t
message_id
;
MessageData
*
pdata
;
int64_t
ts_sensitive
;
}
;
typedef
std
:
:
list
<
Message
>
MessageList
;
class
DelayedMessage
{
public
:
DelayedMessage
(
int64_t
delay
int64_t
trigger
uint32_t
num
const
Message
&
msg
)
:
cmsDelay_
(
delay
)
msTrigger_
(
trigger
)
num_
(
num
)
msg_
(
msg
)
{
}
bool
operator
<
(
const
DelayedMessage
&
dmsg
)
const
{
return
(
dmsg
.
msTrigger_
<
msTrigger_
)
|
|
(
(
dmsg
.
msTrigger_
=
=
msTrigger_
)
&
&
(
dmsg
.
num_
<
num_
)
)
;
}
int64_t
cmsDelay_
;
int64_t
msTrigger_
;
uint32_t
num_
;
Message
msg_
;
}
;
class
MessageQueue
{
public
:
static
const
int
kForever
=
-
1
;
MessageQueue
(
SocketServer
*
ss
bool
init_queue
)
;
MessageQueue
(
std
:
:
unique_ptr
<
SocketServer
>
ss
bool
init_queue
)
;
virtual
~
MessageQueue
(
)
;
SocketServer
*
socketserver
(
)
;
virtual
void
Quit
(
)
;
virtual
bool
IsQuitting
(
)
;
virtual
void
Restart
(
)
;
virtual
bool
IsProcessingMessages
(
)
;
virtual
bool
Get
(
Message
*
pmsg
int
cmsWait
=
kForever
bool
process_io
=
true
)
;
virtual
bool
Peek
(
Message
*
pmsg
int
cmsWait
=
0
)
;
virtual
void
Post
(
const
Location
&
posted_from
MessageHandler
*
phandler
uint32_t
id
=
0
MessageData
*
pdata
=
nullptr
bool
time_sensitive
=
false
)
;
virtual
void
PostDelayed
(
const
Location
&
posted_from
int
cmsDelay
MessageHandler
*
phandler
uint32_t
id
=
0
MessageData
*
pdata
=
nullptr
)
;
virtual
void
PostAt
(
const
Location
&
posted_from
int64_t
tstamp
MessageHandler
*
phandler
uint32_t
id
=
0
MessageData
*
pdata
=
nullptr
)
;
virtual
void
PostAt
(
const
Location
&
posted_from
uint32_t
tstamp
MessageHandler
*
phandler
uint32_t
id
=
0
MessageData
*
pdata
=
nullptr
)
;
virtual
void
Clear
(
MessageHandler
*
phandler
uint32_t
id
=
MQID_ANY
MessageList
*
removed
=
nullptr
)
;
virtual
void
Dispatch
(
Message
*
pmsg
)
;
virtual
void
ReceiveSends
(
)
;
virtual
int
GetDelay
(
)
;
bool
empty
(
)
const
{
return
size
(
)
=
=
0u
;
}
size_t
size
(
)
const
{
CritScope
cs
(
&
crit_
)
;
return
msgq_
.
size
(
)
+
dmsgq_
.
size
(
)
+
(
fPeekKeep_
?
1u
:
0u
)
;
}
template
<
class
T
>
void
Dispose
(
T
*
doomed
)
{
if
(
doomed
)
{
Post
(
RTC_FROM_HERE
nullptr
MQID_DISPOSE
new
DisposeData
<
T
>
(
doomed
)
)
;
}
}
sigslot
:
:
signal0
<
>
SignalQueueDestroyed
;
protected
:
class
PriorityQueue
:
public
std
:
:
priority_queue
<
DelayedMessage
>
{
public
:
container_type
&
container
(
)
{
return
c
;
}
void
reheap
(
)
{
make_heap
(
c
.
begin
(
)
c
.
end
(
)
comp
)
;
}
}
;
void
DoDelayPost
(
const
Location
&
posted_from
int64_t
cmsDelay
int64_t
tstamp
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
)
;
void
DoInit
(
)
;
void
DoDestroy
(
)
;
void
WakeUpSocketServer
(
)
;
bool
fPeekKeep_
;
Message
msgPeek_
;
MessageList
msgq_
RTC_GUARDED_BY
(
crit_
)
;
PriorityQueue
dmsgq_
RTC_GUARDED_BY
(
crit_
)
;
uint32_t
dmsgq_next_num_
RTC_GUARDED_BY
(
crit_
)
;
CriticalSection
crit_
;
bool
fInitialized_
;
bool
fDestroyed_
;
private
:
volatile
int
stop_
;
SocketServer
*
const
ss_
;
std
:
:
unique_ptr
<
SocketServer
>
own_ss_
;
RTC_DISALLOW_IMPLICIT_CONSTRUCTORS
(
MessageQueue
)
;
}
;
}
#
endif
