#
ifndef
RTC_BASE_SWAP_QUEUE_H_
#
define
RTC_BASE_SWAP_QUEUE_H_
#
include
<
algorithm
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
namespace
webrtc
{
namespace
internal
{
template
<
typename
T
>
bool
NoopSwapQueueItemVerifierFunction
(
const
T
&
)
{
return
true
;
}
}
template
<
typename
T
bool
(
*
QueueItemVerifierFunction
)
(
const
T
&
)
=
internal
:
:
NoopSwapQueueItemVerifierFunction
>
class
SwapQueueItemVerifier
{
public
:
bool
operator
(
)
(
const
T
&
t
)
const
{
return
QueueItemVerifierFunction
(
t
)
;
}
}
;
template
<
typename
T
typename
QueueItemVerifier
=
SwapQueueItemVerifier
<
T
>
>
class
SwapQueue
{
public
:
explicit
SwapQueue
(
size_t
size
)
:
queue_
(
size
)
{
RTC_DCHECK
(
VerifyQueueSlots
(
)
)
;
}
SwapQueue
(
size_t
size
const
QueueItemVerifier
&
queue_item_verifier
)
:
queue_item_verifier_
(
queue_item_verifier
)
queue_
(
size
)
{
RTC_DCHECK
(
VerifyQueueSlots
(
)
)
;
}
SwapQueue
(
size_t
size
const
T
&
prototype
)
:
queue_
(
size
prototype
)
{
RTC_DCHECK
(
VerifyQueueSlots
(
)
)
;
}
SwapQueue
(
size_t
size
const
T
&
prototype
const
QueueItemVerifier
&
queue_item_verifier
)
:
queue_item_verifier_
(
queue_item_verifier
)
queue_
(
size
prototype
)
{
RTC_DCHECK
(
VerifyQueueSlots
(
)
)
;
}
void
Clear
(
)
{
rtc
:
:
CritScope
cs
(
&
crit_queue_
)
;
next_write_index_
=
0
;
next_read_index_
=
0
;
num_elements_
=
0
;
}
bool
Insert
(
T
*
input
)
RTC_WARN_UNUSED_RESULT
{
RTC_DCHECK
(
input
)
;
rtc
:
:
CritScope
cs
(
&
crit_queue_
)
;
RTC_DCHECK
(
queue_item_verifier_
(
*
input
)
)
;
if
(
num_elements_
=
=
queue_
.
size
(
)
)
{
return
false
;
}
using
std
:
:
swap
;
swap
(
*
input
queue_
[
next_write_index_
]
)
;
+
+
next_write_index_
;
if
(
next_write_index_
=
=
queue_
.
size
(
)
)
{
next_write_index_
=
0
;
}
+
+
num_elements_
;
RTC_DCHECK_LT
(
next_write_index_
queue_
.
size
(
)
)
;
RTC_DCHECK_LE
(
num_elements_
queue_
.
size
(
)
)
;
return
true
;
}
bool
Remove
(
T
*
output
)
RTC_WARN_UNUSED_RESULT
{
RTC_DCHECK
(
output
)
;
rtc
:
:
CritScope
cs
(
&
crit_queue_
)
;
RTC_DCHECK
(
queue_item_verifier_
(
*
output
)
)
;
if
(
num_elements_
=
=
0
)
{
return
false
;
}
using
std
:
:
swap
;
swap
(
*
output
queue_
[
next_read_index_
]
)
;
+
+
next_read_index_
;
if
(
next_read_index_
=
=
queue_
.
size
(
)
)
{
next_read_index_
=
0
;
}
-
-
num_elements_
;
RTC_DCHECK_LT
(
next_read_index_
queue_
.
size
(
)
)
;
RTC_DCHECK_LE
(
num_elements_
queue_
.
size
(
)
)
;
return
true
;
}
private
:
bool
VerifyQueueSlots
(
)
{
rtc
:
:
CritScope
cs
(
&
crit_queue_
)
;
for
(
const
auto
&
v
:
queue_
)
{
RTC_DCHECK
(
queue_item_verifier_
(
v
)
)
;
}
return
true
;
}
rtc
:
:
CriticalSection
crit_queue_
;
QueueItemVerifier
queue_item_verifier_
RTC_GUARDED_BY
(
crit_queue_
)
;
size_t
next_write_index_
RTC_GUARDED_BY
(
crit_queue_
)
=
0
;
size_t
next_read_index_
RTC_GUARDED_BY
(
crit_queue_
)
=
0
;
size_t
num_elements_
RTC_GUARDED_BY
(
crit_queue_
)
=
0
;
std
:
:
vector
<
T
>
queue_
RTC_GUARDED_BY
(
crit_queue_
)
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
SwapQueue
)
;
}
;
}
#
endif
