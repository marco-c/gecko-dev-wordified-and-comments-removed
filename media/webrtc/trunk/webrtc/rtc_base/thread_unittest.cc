#
include
<
memory
>
#
include
"
rtc_base
/
asyncinvoker
.
h
"
#
include
"
rtc_base
/
asyncudpsocket
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
nullsocketserver
.
h
"
#
include
"
rtc_base
/
physicalsocketserver
.
h
"
#
include
"
rtc_base
/
sigslot
.
h
"
#
include
"
rtc_base
/
socketaddress
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
if
defined
(
WEBRTC_WIN
)
#
include
<
comdef
.
h
>
#
endif
using
namespace
rtc
;
class
TestGenerator
{
public
:
TestGenerator
(
)
:
last
(
0
)
count
(
0
)
{
}
int
Next
(
int
prev
)
{
int
result
=
prev
+
last
;
last
=
result
;
count
+
=
1
;
return
result
;
}
int
last
;
int
count
;
}
;
struct
TestMessage
:
public
MessageData
{
explicit
TestMessage
(
int
v
)
:
value
(
v
)
{
}
int
value
;
}
;
class
SocketClient
:
public
TestGenerator
public
sigslot
:
:
has_slots
<
>
{
public
:
SocketClient
(
AsyncSocket
*
socket
const
SocketAddress
&
addr
Thread
*
post_thread
MessageHandler
*
phandler
)
:
socket_
(
AsyncUDPSocket
:
:
Create
(
socket
addr
)
)
post_thread_
(
post_thread
)
post_handler_
(
phandler
)
{
socket_
-
>
SignalReadPacket
.
connect
(
this
&
SocketClient
:
:
OnPacket
)
;
}
~
SocketClient
(
)
override
{
delete
socket_
;
}
SocketAddress
address
(
)
const
{
return
socket_
-
>
GetLocalAddress
(
)
;
}
void
OnPacket
(
AsyncPacketSocket
*
socket
const
char
*
buf
size_t
size
const
SocketAddress
&
remote_addr
const
PacketTime
&
packet_time
)
{
EXPECT_EQ
(
size
sizeof
(
uint32_t
)
)
;
uint32_t
prev
=
reinterpret_cast
<
const
uint32_t
*
>
(
buf
)
[
0
]
;
uint32_t
result
=
Next
(
prev
)
;
post_thread_
-
>
PostDelayed
(
RTC_FROM_HERE
200
post_handler_
0
new
TestMessage
(
result
)
)
;
}
private
:
AsyncUDPSocket
*
socket_
;
Thread
*
post_thread_
;
MessageHandler
*
post_handler_
;
}
;
class
MessageClient
:
public
MessageHandler
public
TestGenerator
{
public
:
MessageClient
(
Thread
*
pth
Socket
*
socket
)
:
socket_
(
socket
)
{
}
~
MessageClient
(
)
override
{
delete
socket_
;
}
void
OnMessage
(
Message
*
pmsg
)
override
{
TestMessage
*
msg
=
static_cast
<
TestMessage
*
>
(
pmsg
-
>
pdata
)
;
int
result
=
Next
(
msg
-
>
value
)
;
EXPECT_GE
(
socket_
-
>
Send
(
&
result
sizeof
(
result
)
)
0
)
;
delete
msg
;
}
private
:
Socket
*
socket_
;
}
;
class
CustomThread
:
public
rtc
:
:
Thread
{
public
:
CustomThread
(
)
:
Thread
(
std
:
:
unique_ptr
<
SocketServer
>
(
new
rtc
:
:
NullSocketServer
(
)
)
)
{
}
~
CustomThread
(
)
override
{
Stop
(
)
;
}
bool
Start
(
)
{
return
false
;
}
bool
WrapCurrent
(
)
{
return
Thread
:
:
WrapCurrent
(
)
;
}
void
UnwrapCurrent
(
)
{
Thread
:
:
UnwrapCurrent
(
)
;
}
}
;
class
SignalWhenDestroyedThread
:
public
Thread
{
public
:
SignalWhenDestroyedThread
(
Event
*
event
)
:
Thread
(
std
:
:
unique_ptr
<
SocketServer
>
(
new
NullSocketServer
(
)
)
)
event_
(
event
)
{
}
~
SignalWhenDestroyedThread
(
)
override
{
Stop
(
)
;
event_
-
>
Set
(
)
;
}
void
Run
(
)
override
{
}
private
:
Event
*
event_
;
}
;
class
AtomicBool
{
public
:
explicit
AtomicBool
(
bool
value
=
false
)
:
flag_
(
value
)
{
}
AtomicBool
&
operator
=
(
bool
value
)
{
CritScope
scoped_lock
(
&
cs_
)
;
flag_
=
value
;
return
*
this
;
}
bool
get
(
)
const
{
CritScope
scoped_lock
(
&
cs_
)
;
return
flag_
;
}
private
:
CriticalSection
cs_
;
bool
flag_
;
}
;
struct
FunctorA
{
int
operator
(
)
(
)
{
return
42
;
}
}
;
class
FunctorB
{
public
:
explicit
FunctorB
(
AtomicBool
*
flag
)
:
flag_
(
flag
)
{
}
void
operator
(
)
(
)
{
if
(
flag_
)
*
flag_
=
true
;
}
private
:
AtomicBool
*
flag_
;
}
;
struct
FunctorC
{
int
operator
(
)
(
)
{
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
50
)
;
return
24
;
}
}
;
TEST
(
ThreadTest
DISABLED_Main
)
{
const
SocketAddress
addr
(
"
127
.
0
.
0
.
1
"
0
)
;
auto
th1
=
Thread
:
:
CreateWithSocketServer
(
)
;
Socket
*
socket
=
th1
-
>
socketserver
(
)
-
>
CreateAsyncSocket
(
addr
.
family
(
)
SOCK_DGRAM
)
;
MessageClient
msg_client
(
th1
.
get
(
)
socket
)
;
auto
th2
=
Thread
:
:
CreateWithSocketServer
(
)
;
AsyncSocket
*
asocket
=
th2
-
>
socketserver
(
)
-
>
CreateAsyncSocket
(
addr
.
family
(
)
SOCK_DGRAM
)
;
SocketClient
sock_client
(
asocket
addr
th1
.
get
(
)
&
msg_client
)
;
socket
-
>
Connect
(
sock_client
.
address
(
)
)
;
th1
-
>
Start
(
)
;
th2
-
>
Start
(
)
;
th1
-
>
PostDelayed
(
RTC_FROM_HERE
100
&
msg_client
0
new
TestMessage
(
1
)
)
;
Thread
*
th_main
=
Thread
:
:
Current
(
)
;
th_main
-
>
ProcessMessages
(
1000
)
;
th1
-
>
Stop
(
)
;
th_main
-
>
ProcessMessages
(
200
)
;
th2
-
>
Stop
(
)
;
EXPECT_EQ
(
5
msg_client
.
count
)
;
EXPECT_EQ
(
34
msg_client
.
last
)
;
EXPECT_EQ
(
5
sock_client
.
count
)
;
EXPECT_EQ
(
55
sock_client
.
last
)
;
}
TEST
(
ThreadTest
Names
)
{
auto
thread
=
Thread
:
:
CreateWithSocketServer
(
)
;
EXPECT_TRUE
(
thread
-
>
Start
(
)
)
;
thread
-
>
Stop
(
)
;
thread
=
Thread
:
:
CreateWithSocketServer
(
)
;
EXPECT_TRUE
(
thread
-
>
SetName
(
"
No
object
"
nullptr
)
)
;
EXPECT_TRUE
(
thread
-
>
Start
(
)
)
;
thread
-
>
Stop
(
)
;
thread
=
Thread
:
:
CreateWithSocketServer
(
)
;
EXPECT_TRUE
(
thread
-
>
SetName
(
"
Abcdefghijklmnopqrstuvwxyz1234567890
"
this
)
)
;
EXPECT_TRUE
(
thread
-
>
Start
(
)
)
;
thread
-
>
Stop
(
)
;
}
TEST
(
ThreadTest
Wrap
)
{
Thread
*
current_thread
=
Thread
:
:
Current
(
)
;
current_thread
-
>
UnwrapCurrent
(
)
;
CustomThread
*
cthread
=
new
CustomThread
(
)
;
EXPECT_TRUE
(
cthread
-
>
WrapCurrent
(
)
)
;
EXPECT_TRUE
(
cthread
-
>
RunningForTest
(
)
)
;
EXPECT_FALSE
(
cthread
-
>
IsOwned
(
)
)
;
cthread
-
>
UnwrapCurrent
(
)
;
EXPECT_FALSE
(
cthread
-
>
RunningForTest
(
)
)
;
delete
cthread
;
current_thread
-
>
WrapCurrent
(
)
;
}
TEST
(
ThreadTest
Invoke
)
{
auto
thread
=
Thread
:
:
CreateWithSocketServer
(
)
;
thread
-
>
Start
(
)
;
EXPECT_EQ
(
42
thread
-
>
Invoke
<
int
>
(
RTC_FROM_HERE
FunctorA
(
)
)
)
;
AtomicBool
called
;
FunctorB
f2
(
&
called
)
;
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
f2
)
;
EXPECT_TRUE
(
called
.
get
(
)
)
;
struct
LocalFuncs
{
static
int
Func1
(
)
{
return
999
;
}
static
void
Func2
(
)
{
}
}
;
EXPECT_EQ
(
999
thread
-
>
Invoke
<
int
>
(
RTC_FROM_HERE
&
LocalFuncs
:
:
Func1
)
)
;
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
&
LocalFuncs
:
:
Func2
)
;
}
TEST
(
ThreadTest
TwoThreadsInvokeNoDeadlock
)
{
AutoThread
thread
;
Thread
*
current_thread
=
Thread
:
:
Current
(
)
;
ASSERT_TRUE
(
current_thread
!
=
nullptr
)
;
auto
other_thread
=
Thread
:
:
CreateWithSocketServer
(
)
;
other_thread
-
>
Start
(
)
;
struct
LocalFuncs
{
static
void
Set
(
bool
*
out
)
{
*
out
=
true
;
}
static
void
InvokeSet
(
Thread
*
thread
bool
*
out
)
{
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
Set
out
)
)
;
}
}
;
bool
called
=
false
;
other_thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
LocalFuncs
:
:
InvokeSet
current_thread
&
called
)
)
;
EXPECT_TRUE
(
called
)
;
}
TEST
(
ThreadTest
ThreeThreadsInvoke
)
{
AutoThread
thread
;
Thread
*
thread_a
=
Thread
:
:
Current
(
)
;
auto
thread_b
=
Thread
:
:
CreateWithSocketServer
(
)
;
auto
thread_c
=
Thread
:
:
CreateWithSocketServer
(
)
;
thread_b
-
>
Start
(
)
;
thread_c
-
>
Start
(
)
;
class
LockedBool
{
public
:
explicit
LockedBool
(
bool
value
)
:
value_
(
value
)
{
}
void
Set
(
bool
value
)
{
CritScope
lock
(
&
crit_
)
;
value_
=
value
;
}
bool
Get
(
)
{
CritScope
lock
(
&
crit_
)
;
return
value_
;
}
private
:
CriticalSection
crit_
;
bool
value_
RTC_GUARDED_BY
(
crit_
)
;
}
;
struct
LocalFuncs
{
static
void
Set
(
LockedBool
*
out
)
{
out
-
>
Set
(
true
)
;
}
static
void
InvokeSet
(
Thread
*
thread
LockedBool
*
out
)
{
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
Set
out
)
)
;
}
static
void
SetAndInvokeSet
(
LockedBool
*
out
Thread
*
thread
LockedBool
*
out_inner
)
{
out
-
>
Set
(
true
)
;
InvokeSet
(
thread
out_inner
)
;
}
static
void
AsyncInvokeSetAndWait
(
AsyncInvoker
*
invoker
Thread
*
thread1
Thread
*
thread2
LockedBool
*
out
)
{
CriticalSection
crit
;
LockedBool
async_invoked
(
false
)
;
invoker
-
>
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
thread1
Bind
(
&
SetAndInvokeSet
&
async_invoked
thread2
out
)
)
;
EXPECT_TRUE_WAIT
(
async_invoked
.
Get
(
)
2000
)
;
}
}
;
AsyncInvoker
invoker
;
LockedBool
thread_a_called
(
false
)
;
thread_b
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
LocalFuncs
:
:
AsyncInvokeSetAndWait
&
invoker
thread_c
.
get
(
)
thread_a
&
thread_a_called
)
)
;
EXPECT_FALSE
(
thread_a_called
.
Get
(
)
)
;
EXPECT_TRUE_WAIT
(
thread_a_called
.
Get
(
)
2000
)
;
}
class
SetNameOnSignalQueueDestroyedTester
:
public
sigslot
:
:
has_slots
<
>
{
public
:
SetNameOnSignalQueueDestroyedTester
(
Thread
*
thread
)
:
thread_
(
thread
)
{
thread
-
>
SignalQueueDestroyed
.
connect
(
this
&
SetNameOnSignalQueueDestroyedTester
:
:
OnQueueDestroyed
)
;
}
void
OnQueueDestroyed
(
)
{
thread_
-
>
SetName
(
"
foo
"
nullptr
)
;
}
private
:
Thread
*
thread_
;
}
;
TEST
(
ThreadTest
SetNameOnSignalQueueDestroyed
)
{
auto
thread1
=
Thread
:
:
CreateWithSocketServer
(
)
;
SetNameOnSignalQueueDestroyedTester
tester1
(
thread1
.
get
(
)
)
;
thread1
.
reset
(
)
;
Thread
*
thread2
=
new
AutoThread
(
)
;
SetNameOnSignalQueueDestroyedTester
tester2
(
thread2
)
;
delete
thread2
;
}
class
AsyncInvokeTest
:
public
testing
:
:
Test
{
public
:
void
IntCallback
(
int
value
)
{
EXPECT_EQ
(
expected_thread_
Thread
:
:
Current
(
)
)
;
int_value_
=
value
;
}
void
SetExpectedThreadForIntCallback
(
Thread
*
thread
)
{
expected_thread_
=
thread
;
}
protected
:
enum
{
kWaitTimeout
=
1000
}
;
AsyncInvokeTest
(
)
:
int_value_
(
0
)
expected_thread_
(
nullptr
)
{
}
int
int_value_
;
Thread
*
expected_thread_
;
}
;
TEST_F
(
AsyncInvokeTest
FireAndForget
)
{
AsyncInvoker
invoker
;
auto
thread
=
Thread
:
:
CreateWithSocketServer
(
)
;
thread
-
>
Start
(
)
;
AtomicBool
called
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
thread
.
get
(
)
FunctorB
(
&
called
)
)
;
EXPECT_TRUE_WAIT
(
called
.
get
(
)
kWaitTimeout
)
;
thread
-
>
Stop
(
)
;
}
TEST_F
(
AsyncInvokeTest
KillInvokerDuringExecute
)
{
Event
functor_started
(
false
false
)
;
Event
functor_continue
(
false
false
)
;
Event
functor_finished
(
false
false
)
;
auto
thread
=
Thread
:
:
CreateWithSocketServer
(
)
;
thread
-
>
Start
(
)
;
volatile
bool
invoker_destroyed
=
false
;
{
auto
functor
=
[
&
functor_started
&
functor_continue
&
functor_finished
&
invoker_destroyed
]
{
functor_started
.
Set
(
)
;
functor_continue
.
Wait
(
Event
:
:
kForever
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
SleepMs
(
kWaitTimeout
)
;
EXPECT_FALSE
(
invoker_destroyed
)
;
functor_finished
.
Set
(
)
;
}
;
AsyncInvoker
invoker
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
thread
.
get
(
)
functor
)
;
functor_started
.
Wait
(
Event
:
:
kForever
)
;
functor_continue
.
Set
(
)
;
}
invoker_destroyed
=
true
;
functor_finished
.
Wait
(
Event
:
:
kForever
)
;
}
TEST_F
(
AsyncInvokeTest
KillInvokerDuringExecuteWithReentrantInvoke
)
{
Event
functor_started
(
false
false
)
;
bool
reentrant_functor_run
=
false
;
Thread
*
main
=
Thread
:
:
Current
(
)
;
Thread
thread
;
thread
.
Start
(
)
;
{
AsyncInvoker
invoker
;
auto
reentrant_functor
=
[
&
reentrant_functor_run
]
{
reentrant_functor_run
=
true
;
}
;
auto
functor
=
[
&
functor_started
&
invoker
main
reentrant_functor
]
{
functor_started
.
Set
(
)
;
Thread
:
:
Current
(
)
-
>
SleepMs
(
kWaitTimeout
)
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
main
reentrant_functor
)
;
}
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
&
thread
functor
)
;
functor_started
.
Wait
(
Event
:
:
kForever
)
;
}
EXPECT_FALSE
(
reentrant_functor_run
)
;
}
TEST_F
(
AsyncInvokeTest
Flush
)
{
AsyncInvoker
invoker
;
AtomicBool
flag1
;
AtomicBool
flag2
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
Thread
:
:
Current
(
)
FunctorB
(
&
flag1
)
)
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
Thread
:
:
Current
(
)
FunctorB
(
&
flag2
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
invoker
.
Flush
(
Thread
:
:
Current
(
)
)
;
EXPECT_TRUE
(
flag1
.
get
(
)
)
;
EXPECT_TRUE
(
flag2
.
get
(
)
)
;
}
TEST_F
(
AsyncInvokeTest
FlushWithIds
)
{
AsyncInvoker
invoker
;
AtomicBool
flag1
;
AtomicBool
flag2
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
Thread
:
:
Current
(
)
FunctorB
(
&
flag1
)
5
)
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
Thread
:
:
Current
(
)
FunctorB
(
&
flag2
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
invoker
.
Flush
(
Thread
:
:
Current
(
)
5
)
;
EXPECT_TRUE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
flag1
=
false
;
invoker
.
Flush
(
Thread
:
:
Current
(
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_TRUE
(
flag2
.
get
(
)
)
;
}
class
GuardedAsyncInvokeTest
:
public
testing
:
:
Test
{
public
:
void
IntCallback
(
int
value
)
{
EXPECT_EQ
(
expected_thread_
Thread
:
:
Current
(
)
)
;
int_value_
=
value
;
}
void
SetExpectedThreadForIntCallback
(
Thread
*
thread
)
{
expected_thread_
=
thread
;
}
protected
:
const
static
int
kWaitTimeout
=
1000
;
GuardedAsyncInvokeTest
(
)
:
int_value_
(
0
)
expected_thread_
(
nullptr
)
{
}
int
int_value_
;
Thread
*
expected_thread_
;
}
;
struct
CreateInvoker
{
CreateInvoker
(
std
:
:
unique_ptr
<
GuardedAsyncInvoker
>
*
invoker
)
:
invoker_
(
invoker
)
{
}
void
operator
(
)
(
)
{
invoker_
-
>
reset
(
new
GuardedAsyncInvoker
(
)
)
;
}
std
:
:
unique_ptr
<
GuardedAsyncInvoker
>
*
invoker_
;
}
;
TEST_F
(
GuardedAsyncInvokeTest
KillThreadFireAndForget
)
{
std
:
:
unique_ptr
<
Thread
>
thread
(
Thread
:
:
Create
(
)
)
;
thread
-
>
Start
(
)
;
std
:
:
unique_ptr
<
GuardedAsyncInvoker
>
invoker
;
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
CreateInvoker
(
&
invoker
)
)
;
thread
=
nullptr
;
AtomicBool
called
;
EXPECT_FALSE
(
invoker
-
>
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
called
)
)
)
;
WAIT
(
called
.
get
(
)
kWaitTimeout
)
;
EXPECT_FALSE
(
called
.
get
(
)
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
FireAndForget
)
{
GuardedAsyncInvoker
invoker
;
AtomicBool
called
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
called
)
)
)
;
EXPECT_TRUE_WAIT
(
called
.
get
(
)
kWaitTimeout
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
Flush
)
{
GuardedAsyncInvoker
invoker
;
AtomicBool
flag1
;
AtomicBool
flag2
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
flag1
)
)
)
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
flag2
)
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
EXPECT_TRUE
(
invoker
.
Flush
(
)
)
;
EXPECT_TRUE
(
flag1
.
get
(
)
)
;
EXPECT_TRUE
(
flag2
.
get
(
)
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
FlushWithIds
)
{
GuardedAsyncInvoker
invoker
;
AtomicBool
flag1
;
AtomicBool
flag2
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
flag1
)
5
)
)
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
flag2
)
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
EXPECT_TRUE
(
invoker
.
Flush
(
5
)
)
;
EXPECT_TRUE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
flag1
=
false
;
EXPECT_TRUE
(
invoker
.
Flush
(
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_TRUE
(
flag2
.
get
(
)
)
;
}
