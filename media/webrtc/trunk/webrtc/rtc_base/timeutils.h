#
ifndef
RTC_BASE_TIMEUTILS_H_
#
define
RTC_BASE_TIMEUTILS_H_
#
include
<
stdint
.
h
>
#
include
<
time
.
h
>
#
include
<
ctime
>
#
include
<
string
>
#
include
"
rtc_base
/
checks
.
h
"
namespace
rtc
{
static
const
int64_t
kNumMillisecsPerSec
=
INT64_C
(
1000
)
;
static
const
int64_t
kNumMicrosecsPerSec
=
INT64_C
(
1000000
)
;
static
const
int64_t
kNumNanosecsPerSec
=
INT64_C
(
1000000000
)
;
static
const
int64_t
kNumMicrosecsPerMillisec
=
kNumMicrosecsPerSec
/
kNumMillisecsPerSec
;
static
const
int64_t
kNumNanosecsPerMillisec
=
kNumNanosecsPerSec
/
kNumMillisecsPerSec
;
static
const
int64_t
kNumNanosecsPerMicrosec
=
kNumNanosecsPerSec
/
kNumMicrosecsPerSec
;
class
ClockInterface
{
public
:
virtual
~
ClockInterface
(
)
{
}
virtual
int64_t
TimeNanos
(
)
const
=
0
;
}
;
ClockInterface
*
SetClockForTesting
(
ClockInterface
*
clock
)
;
ClockInterface
*
GetClockForTesting
(
)
;
int64_t
SystemTimeNanos
(
)
;
int64_t
SystemTimeMillis
(
)
;
uint32_t
Time32
(
)
;
int64_t
TimeMillis
(
)
;
inline
int64_t
Time
(
)
{
return
TimeMillis
(
)
;
}
int64_t
TimeMicros
(
)
;
int64_t
TimeNanos
(
)
;
int64_t
TimeAfter
(
int64_t
elapsed
)
;
int64_t
TimeDiff
(
int64_t
later
int64_t
earlier
)
;
int32_t
TimeDiff32
(
uint32_t
later
uint32_t
earlier
)
;
inline
int64_t
TimeSince
(
int64_t
earlier
)
{
return
TimeMillis
(
)
-
earlier
;
}
inline
int64_t
TimeUntil
(
int64_t
later
)
{
return
later
-
TimeMillis
(
)
;
}
class
TimestampWrapAroundHandler
{
public
:
TimestampWrapAroundHandler
(
)
;
int64_t
Unwrap
(
uint32_t
ts
)
;
private
:
uint32_t
last_ts_
;
int64_t
num_wrap_
;
}
;
int64_t
TmToSeconds
(
const
std
:
:
tm
&
tm
)
;
int64_t
TimeUTCMicros
(
)
;
class
IntervalRange
{
public
:
IntervalRange
(
)
:
min_
(
0
)
max_
(
0
)
{
}
IntervalRange
(
int
min
int
max
)
:
min_
(
min
)
max_
(
max
)
{
RTC_DCHECK_LE
(
min
max
)
;
}
int
min
(
)
const
{
return
min_
;
}
int
max
(
)
const
{
return
max_
;
}
std
:
:
string
ToString
(
)
const
{
std
:
:
stringstream
ss
;
ss
<
<
"
[
"
<
<
min_
<
<
"
"
<
<
max_
<
<
"
]
"
;
return
ss
.
str
(
)
;
}
bool
operator
=
=
(
const
IntervalRange
&
o
)
const
{
return
min_
=
=
o
.
min_
&
&
max_
=
=
o
.
max_
;
}
private
:
int
min_
;
int
max_
;
}
;
}
#
endif
