#
ifndef
RTC_BASE_TASK_QUEUE_H_
#
define
RTC_BASE_TASK_QUEUE_H_
#
include
<
list
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
ptr_util
.
h
"
#
include
"
rtc_base
/
scoped_ref_ptr
.
h
"
namespace
rtc
{
class
QueuedTask
{
public
:
QueuedTask
(
)
{
}
virtual
~
QueuedTask
(
)
{
}
virtual
bool
Run
(
)
=
0
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
QueuedTask
)
;
}
;
template
<
class
Closure
>
class
ClosureTask
:
public
QueuedTask
{
public
:
explicit
ClosureTask
(
Closure
&
&
closure
)
:
closure_
(
std
:
:
forward
<
Closure
>
(
closure
)
)
{
}
private
:
bool
Run
(
)
override
{
closure_
(
)
;
return
true
;
}
typename
std
:
:
remove_const
<
typename
std
:
:
remove_reference
<
Closure
>
:
:
type
>
:
:
type
closure_
;
}
;
template
<
class
Closure
class
Cleanup
>
class
ClosureTaskWithCleanup
:
public
ClosureTask
<
Closure
>
{
public
:
ClosureTaskWithCleanup
(
Closure
&
&
closure
Cleanup
&
&
cleanup
)
:
ClosureTask
<
Closure
>
(
std
:
:
forward
<
Closure
>
(
closure
)
)
cleanup_
(
std
:
:
forward
<
Cleanup
>
(
cleanup
)
)
{
}
~
ClosureTaskWithCleanup
(
)
{
cleanup_
(
)
;
}
private
:
typename
std
:
:
remove_const
<
typename
std
:
:
remove_reference
<
Cleanup
>
:
:
type
>
:
:
type
cleanup_
;
}
;
template
<
class
Closure
>
static
std
:
:
unique_ptr
<
QueuedTask
>
NewClosure
(
Closure
&
&
closure
)
{
return
rtc
:
:
MakeUnique
<
ClosureTask
<
Closure
>
>
(
std
:
:
forward
<
Closure
>
(
closure
)
)
;
}
template
<
class
Closure
class
Cleanup
>
static
std
:
:
unique_ptr
<
QueuedTask
>
NewClosure
(
Closure
&
&
closure
Cleanup
&
&
cleanup
)
{
return
rtc
:
:
MakeUnique
<
ClosureTaskWithCleanup
<
Closure
Cleanup
>
>
(
std
:
:
forward
<
Closure
>
(
closure
)
std
:
:
forward
<
Cleanup
>
(
cleanup
)
)
;
}
class
RTC_LOCKABLE
TaskQueue
{
public
:
enum
class
Priority
{
NORMAL
=
0
HIGH
LOW
}
;
explicit
TaskQueue
(
const
char
*
queue_name
Priority
priority
=
Priority
:
:
NORMAL
)
;
~
TaskQueue
(
)
;
static
TaskQueue
*
Current
(
)
;
bool
IsCurrent
(
)
const
;
void
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
;
void
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
TaskQueue
*
reply_queue
)
;
void
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
)
;
void
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
;
template
<
class
Closure
typename
std
:
:
enable_if
<
!
std
:
:
is_convertible
<
Closure
std
:
:
unique_ptr
<
QueuedTask
>
>
:
:
value
>
:
:
type
*
=
nullptr
>
void
PostTask
(
Closure
&
&
closure
)
{
PostTask
(
NewClosure
(
std
:
:
forward
<
Closure
>
(
closure
)
)
)
;
}
template
<
class
Closure
typename
std
:
:
enable_if
<
!
std
:
:
is_convertible
<
Closure
std
:
:
unique_ptr
<
QueuedTask
>
>
:
:
value
>
:
:
type
*
=
nullptr
>
void
PostDelayedTask
(
Closure
&
&
closure
uint32_t
milliseconds
)
{
PostDelayedTask
(
NewClosure
(
std
:
:
forward
<
Closure
>
(
closure
)
)
milliseconds
)
;
}
template
<
class
Closure1
class
Closure2
>
void
PostTaskAndReply
(
Closure1
&
&
task
Closure2
&
&
reply
TaskQueue
*
reply_queue
)
{
PostTaskAndReply
(
NewClosure
(
std
:
:
forward
<
Closure1
>
(
task
)
)
NewClosure
(
std
:
:
forward
<
Closure2
>
(
reply
)
)
reply_queue
)
;
}
template
<
class
Closure
>
void
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
Closure
&
&
reply
)
{
PostTaskAndReply
(
std
:
:
move
(
task
)
NewClosure
(
std
:
:
forward
<
Closure
>
(
reply
)
)
)
;
}
template
<
class
Closure
>
void
PostTaskAndReply
(
Closure
&
&
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
)
{
PostTaskAndReply
(
NewClosure
(
std
:
:
forward
<
Closure
>
(
task
)
)
std
:
:
move
(
reply
)
)
;
}
template
<
class
Closure1
class
Closure2
>
void
PostTaskAndReply
(
Closure1
&
&
task
Closure2
&
&
reply
)
{
PostTaskAndReply
(
NewClosure
(
std
:
:
forward
(
task
)
)
NewClosure
(
std
:
:
forward
(
reply
)
)
)
;
}
private
:
class
Impl
;
const
scoped_refptr
<
Impl
>
impl_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
TaskQueue
)
;
}
;
}
#
endif
