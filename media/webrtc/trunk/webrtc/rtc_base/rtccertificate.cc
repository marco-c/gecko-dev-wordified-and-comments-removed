#
include
<
memory
>
#
include
"
rtc_base
/
rtccertificate
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
refcountedobject
.
h
"
namespace
rtc
{
scoped_refptr
<
RTCCertificate
>
RTCCertificate
:
:
Create
(
std
:
:
unique_ptr
<
SSLIdentity
>
identity
)
{
return
new
RefCountedObject
<
RTCCertificate
>
(
identity
.
release
(
)
)
;
}
RTCCertificate
:
:
RTCCertificate
(
SSLIdentity
*
identity
)
:
identity_
(
identity
)
{
RTC_DCHECK
(
identity_
)
;
}
RTCCertificate
:
:
~
RTCCertificate
(
)
{
}
uint64_t
RTCCertificate
:
:
Expires
(
)
const
{
int64_t
expires
=
ssl_certificate
(
)
.
CertificateExpirationTime
(
)
;
if
(
expires
!
=
-
1
)
return
static_cast
<
uint64_t
>
(
expires
)
*
kNumMillisecsPerSec
;
return
0
;
}
bool
RTCCertificate
:
:
HasExpired
(
uint64_t
now
)
const
{
return
Expires
(
)
<
=
now
;
}
const
SSLCertificate
&
RTCCertificate
:
:
ssl_certificate
(
)
const
{
return
identity_
-
>
certificate
(
)
;
}
RTCCertificatePEM
RTCCertificate
:
:
ToPEM
(
)
const
{
return
RTCCertificatePEM
(
identity_
-
>
PrivateKeyToPEMString
(
)
ssl_certificate
(
)
.
ToPEMString
(
)
)
;
}
scoped_refptr
<
RTCCertificate
>
RTCCertificate
:
:
FromPEM
(
const
RTCCertificatePEM
&
pem
)
{
std
:
:
unique_ptr
<
SSLIdentity
>
identity
(
SSLIdentity
:
:
FromPEMStrings
(
pem
.
private_key
(
)
pem
.
certificate
(
)
)
)
;
if
(
!
identity
)
return
nullptr
;
return
new
RefCountedObject
<
RTCCertificate
>
(
identity
.
release
(
)
)
;
}
bool
RTCCertificate
:
:
operator
=
=
(
const
RTCCertificate
&
certificate
)
const
{
return
*
this
-
>
identity_
=
=
*
certificate
.
identity_
;
}
bool
RTCCertificate
:
:
operator
!
=
(
const
RTCCertificate
&
certificate
)
const
{
return
!
(
*
this
=
=
certificate
)
;
}
}
