#
include
<
algorithm
>
#
include
"
rtc_base
/
atomicops
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
messagequeue
.
h
"
#
include
"
rtc_base
/
stringencode
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
namespace
rtc
{
namespace
{
const
int
kMaxMsgLatency
=
150
;
const
int
kSlowDispatchLoggingThreshold
=
50
;
class
RTC_SCOPED_LOCKABLE
MarkProcessingCritScope
{
public
:
MarkProcessingCritScope
(
const
CriticalSection
*
cs
size_t
*
processing
)
RTC_EXCLUSIVE_LOCK_FUNCTION
(
cs
)
:
cs_
(
cs
)
processing_
(
processing
)
{
cs_
-
>
Enter
(
)
;
*
processing_
+
=
1
;
}
~
MarkProcessingCritScope
(
)
RTC_UNLOCK_FUNCTION
(
)
{
*
processing_
-
=
1
;
cs_
-
>
Leave
(
)
;
}
private
:
const
CriticalSection
*
const
cs_
;
size_t
*
processing_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
MarkProcessingCritScope
)
;
}
;
}
MessageQueueManager
*
MessageQueueManager
:
:
instance_
=
nullptr
;
MessageQueueManager
*
MessageQueueManager
:
:
Instance
(
)
{
if
(
!
instance_
)
instance_
=
new
MessageQueueManager
;
return
instance_
;
}
bool
MessageQueueManager
:
:
IsInitialized
(
)
{
return
instance_
!
=
nullptr
;
}
MessageQueueManager
:
:
MessageQueueManager
(
)
:
processing_
(
0
)
{
}
MessageQueueManager
:
:
~
MessageQueueManager
(
)
{
}
void
MessageQueueManager
:
:
Add
(
MessageQueue
*
message_queue
)
{
return
Instance
(
)
-
>
AddInternal
(
message_queue
)
;
}
void
MessageQueueManager
:
:
AddInternal
(
MessageQueue
*
message_queue
)
{
CritScope
cs
(
&
crit_
)
;
RTC_DCHECK_EQ
(
processing_
0
)
;
message_queues_
.
push_back
(
message_queue
)
;
}
void
MessageQueueManager
:
:
Remove
(
MessageQueue
*
message_queue
)
{
if
(
!
instance_
)
return
;
return
Instance
(
)
-
>
RemoveInternal
(
message_queue
)
;
}
void
MessageQueueManager
:
:
RemoveInternal
(
MessageQueue
*
message_queue
)
{
bool
destroy
=
false
;
{
CritScope
cs
(
&
crit_
)
;
RTC_DCHECK_EQ
(
processing_
0
)
;
std
:
:
vector
<
MessageQueue
*
>
:
:
iterator
iter
;
iter
=
std
:
:
find
(
message_queues_
.
begin
(
)
message_queues_
.
end
(
)
message_queue
)
;
if
(
iter
!
=
message_queues_
.
end
(
)
)
{
message_queues_
.
erase
(
iter
)
;
}
destroy
=
message_queues_
.
empty
(
)
;
}
if
(
destroy
)
{
instance_
=
nullptr
;
delete
this
;
}
}
void
MessageQueueManager
:
:
Clear
(
MessageHandler
*
handler
)
{
if
(
!
instance_
)
return
;
return
Instance
(
)
-
>
ClearInternal
(
handler
)
;
}
void
MessageQueueManager
:
:
ClearInternal
(
MessageHandler
*
handler
)
{
MarkProcessingCritScope
cs
(
&
crit_
&
processing_
)
;
std
:
:
vector
<
MessageQueue
*
>
:
:
iterator
iter
;
for
(
MessageQueue
*
queue
:
message_queues_
)
{
queue
-
>
Clear
(
handler
)
;
}
}
void
MessageQueueManager
:
:
ProcessAllMessageQueues
(
)
{
if
(
!
instance_
)
{
return
;
}
return
Instance
(
)
-
>
ProcessAllMessageQueuesInternal
(
)
;
}
void
MessageQueueManager
:
:
ProcessAllMessageQueuesInternal
(
)
{
volatile
int
queues_not_done
=
0
;
class
ScopedIncrement
:
public
MessageData
{
public
:
ScopedIncrement
(
volatile
int
*
value
)
:
value_
(
value
)
{
AtomicOps
:
:
Increment
(
value_
)
;
}
~
ScopedIncrement
(
)
override
{
AtomicOps
:
:
Decrement
(
value_
)
;
}
private
:
volatile
int
*
value_
;
}
;
{
MarkProcessingCritScope
cs
(
&
crit_
&
processing_
)
;
for
(
MessageQueue
*
queue
:
message_queues_
)
{
if
(
!
queue
-
>
IsProcessingMessages
(
)
)
{
continue
;
}
queue
-
>
PostDelayed
(
RTC_FROM_HERE
0
nullptr
MQID_DISPOSE
new
ScopedIncrement
(
&
queues_not_done
)
)
;
}
}
while
(
AtomicOps
:
:
AcquireLoad
(
&
queues_not_done
)
>
0
)
{
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
0
)
;
}
}
MessageQueue
:
:
MessageQueue
(
SocketServer
*
ss
bool
init_queue
)
:
fPeekKeep_
(
false
)
dmsgq_next_num_
(
0
)
fInitialized_
(
false
)
fDestroyed_
(
false
)
stop_
(
0
)
ss_
(
ss
)
{
RTC_DCHECK
(
ss
)
;
ss_
-
>
SetMessageQueue
(
this
)
;
if
(
init_queue
)
{
DoInit
(
)
;
}
}
MessageQueue
:
:
MessageQueue
(
std
:
:
unique_ptr
<
SocketServer
>
ss
bool
init_queue
)
:
MessageQueue
(
ss
.
get
(
)
init_queue
)
{
own_ss_
=
std
:
:
move
(
ss
)
;
}
MessageQueue
:
:
~
MessageQueue
(
)
{
DoDestroy
(
)
;
}
void
MessageQueue
:
:
DoInit
(
)
{
if
(
fInitialized_
)
{
return
;
}
fInitialized_
=
true
;
MessageQueueManager
:
:
Add
(
this
)
;
}
void
MessageQueue
:
:
DoDestroy
(
)
{
if
(
fDestroyed_
)
{
return
;
}
fDestroyed_
=
true
;
SignalQueueDestroyed
(
)
;
MessageQueueManager
:
:
Remove
(
this
)
;
Clear
(
nullptr
)
;
if
(
ss_
)
{
ss_
-
>
SetMessageQueue
(
nullptr
)
;
}
}
SocketServer
*
MessageQueue
:
:
socketserver
(
)
{
return
ss_
;
}
void
MessageQueue
:
:
WakeUpSocketServer
(
)
{
ss_
-
>
WakeUp
(
)
;
}
void
MessageQueue
:
:
Quit
(
)
{
AtomicOps
:
:
ReleaseStore
(
&
stop_
1
)
;
WakeUpSocketServer
(
)
;
}
bool
MessageQueue
:
:
IsQuitting
(
)
{
return
AtomicOps
:
:
AcquireLoad
(
&
stop_
)
!
=
0
;
}
bool
MessageQueue
:
:
IsProcessingMessages
(
)
{
return
!
IsQuitting
(
)
;
}
void
MessageQueue
:
:
Restart
(
)
{
AtomicOps
:
:
ReleaseStore
(
&
stop_
0
)
;
}
bool
MessageQueue
:
:
Peek
(
Message
*
pmsg
int
cmsWait
)
{
if
(
fPeekKeep_
)
{
*
pmsg
=
msgPeek_
;
return
true
;
}
if
(
!
Get
(
pmsg
cmsWait
)
)
return
false
;
msgPeek_
=
*
pmsg
;
fPeekKeep_
=
true
;
return
true
;
}
bool
MessageQueue
:
:
Get
(
Message
*
pmsg
int
cmsWait
bool
process_io
)
{
if
(
fPeekKeep_
)
{
*
pmsg
=
msgPeek_
;
fPeekKeep_
=
false
;
return
true
;
}
int64_t
cmsTotal
=
cmsWait
;
int64_t
cmsElapsed
=
0
;
int64_t
msStart
=
TimeMillis
(
)
;
int64_t
msCurrent
=
msStart
;
while
(
true
)
{
ReceiveSends
(
)
;
int64_t
cmsDelayNext
=
kForever
;
bool
first_pass
=
true
;
while
(
true
)
{
{
CritScope
cs
(
&
crit_
)
;
if
(
first_pass
)
{
first_pass
=
false
;
while
(
!
dmsgq_
.
empty
(
)
)
{
if
(
msCurrent
<
dmsgq_
.
top
(
)
.
msTrigger_
)
{
cmsDelayNext
=
TimeDiff
(
dmsgq_
.
top
(
)
.
msTrigger_
msCurrent
)
;
break
;
}
msgq_
.
push_back
(
dmsgq_
.
top
(
)
.
msg_
)
;
dmsgq_
.
pop
(
)
;
}
}
if
(
msgq_
.
empty
(
)
)
{
break
;
}
else
{
*
pmsg
=
msgq_
.
front
(
)
;
msgq_
.
pop_front
(
)
;
}
}
if
(
pmsg
-
>
ts_sensitive
)
{
int64_t
delay
=
TimeDiff
(
msCurrent
pmsg
-
>
ts_sensitive
)
;
if
(
delay
>
0
)
{
RTC_LOG_F
(
LS_WARNING
)
<
<
"
id
:
"
<
<
pmsg
-
>
message_id
<
<
"
delay
:
"
<
<
(
delay
+
kMaxMsgLatency
)
<
<
"
ms
"
;
}
}
if
(
MQID_DISPOSE
=
=
pmsg
-
>
message_id
)
{
RTC_DCHECK
(
nullptr
=
=
pmsg
-
>
phandler
)
;
delete
pmsg
-
>
pdata
;
*
pmsg
=
Message
(
)
;
continue
;
}
return
true
;
}
if
(
IsQuitting
(
)
)
break
;
int64_t
cmsNext
;
if
(
cmsWait
=
=
kForever
)
{
cmsNext
=
cmsDelayNext
;
}
else
{
cmsNext
=
std
:
:
max
<
int64_t
>
(
0
cmsTotal
-
cmsElapsed
)
;
if
(
(
cmsDelayNext
!
=
kForever
)
&
&
(
cmsDelayNext
<
cmsNext
)
)
cmsNext
=
cmsDelayNext
;
}
{
if
(
!
ss_
-
>
Wait
(
static_cast
<
int
>
(
cmsNext
)
process_io
)
)
return
false
;
}
msCurrent
=
TimeMillis
(
)
;
cmsElapsed
=
TimeDiff
(
msCurrent
msStart
)
;
if
(
cmsWait
!
=
kForever
)
{
if
(
cmsElapsed
>
=
cmsWait
)
return
false
;
}
}
return
false
;
}
void
MessageQueue
:
:
ReceiveSends
(
)
{
}
void
MessageQueue
:
:
Post
(
const
Location
&
posted_from
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
bool
time_sensitive
)
{
if
(
IsQuitting
(
)
)
return
;
{
CritScope
cs
(
&
crit_
)
;
Message
msg
;
msg
.
posted_from
=
posted_from
;
msg
.
phandler
=
phandler
;
msg
.
message_id
=
id
;
msg
.
pdata
=
pdata
;
if
(
time_sensitive
)
{
msg
.
ts_sensitive
=
TimeMillis
(
)
+
kMaxMsgLatency
;
}
msgq_
.
push_back
(
msg
)
;
}
WakeUpSocketServer
(
)
;
}
void
MessageQueue
:
:
PostDelayed
(
const
Location
&
posted_from
int
cmsDelay
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
)
{
return
DoDelayPost
(
posted_from
cmsDelay
TimeAfter
(
cmsDelay
)
phandler
id
pdata
)
;
}
void
MessageQueue
:
:
PostAt
(
const
Location
&
posted_from
uint32_t
tstamp
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
)
{
int64_t
delay
=
static_cast
<
uint32_t
>
(
TimeMillis
(
)
)
-
tstamp
;
return
DoDelayPost
(
posted_from
delay
tstamp
phandler
id
pdata
)
;
}
void
MessageQueue
:
:
PostAt
(
const
Location
&
posted_from
int64_t
tstamp
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
)
{
return
DoDelayPost
(
posted_from
TimeUntil
(
tstamp
)
tstamp
phandler
id
pdata
)
;
}
void
MessageQueue
:
:
DoDelayPost
(
const
Location
&
posted_from
int64_t
cmsDelay
int64_t
tstamp
MessageHandler
*
phandler
uint32_t
id
MessageData
*
pdata
)
{
if
(
IsQuitting
(
)
)
{
return
;
}
{
CritScope
cs
(
&
crit_
)
;
Message
msg
;
msg
.
posted_from
=
posted_from
;
msg
.
phandler
=
phandler
;
msg
.
message_id
=
id
;
msg
.
pdata
=
pdata
;
DelayedMessage
dmsg
(
cmsDelay
tstamp
dmsgq_next_num_
msg
)
;
dmsgq_
.
push
(
dmsg
)
;
+
+
dmsgq_next_num_
;
RTC_DCHECK_NE
(
0
dmsgq_next_num_
)
;
}
WakeUpSocketServer
(
)
;
}
int
MessageQueue
:
:
GetDelay
(
)
{
CritScope
cs
(
&
crit_
)
;
if
(
!
msgq_
.
empty
(
)
)
return
0
;
if
(
!
dmsgq_
.
empty
(
)
)
{
int
delay
=
TimeUntil
(
dmsgq_
.
top
(
)
.
msTrigger_
)
;
if
(
delay
<
0
)
delay
=
0
;
return
delay
;
}
return
kForever
;
}
void
MessageQueue
:
:
Clear
(
MessageHandler
*
phandler
uint32_t
id
MessageList
*
removed
)
{
CritScope
cs
(
&
crit_
)
;
if
(
fPeekKeep_
&
&
msgPeek_
.
Match
(
phandler
id
)
)
{
if
(
removed
)
{
removed
-
>
push_back
(
msgPeek_
)
;
}
else
{
delete
msgPeek_
.
pdata
;
}
fPeekKeep_
=
false
;
}
for
(
MessageList
:
:
iterator
it
=
msgq_
.
begin
(
)
;
it
!
=
msgq_
.
end
(
)
;
)
{
if
(
it
-
>
Match
(
phandler
id
)
)
{
if
(
removed
)
{
removed
-
>
push_back
(
*
it
)
;
}
else
{
delete
it
-
>
pdata
;
}
it
=
msgq_
.
erase
(
it
)
;
}
else
{
+
+
it
;
}
}
PriorityQueue
:
:
container_type
:
:
iterator
new_end
=
dmsgq_
.
container
(
)
.
begin
(
)
;
for
(
PriorityQueue
:
:
container_type
:
:
iterator
it
=
new_end
;
it
!
=
dmsgq_
.
container
(
)
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
msg_
.
Match
(
phandler
id
)
)
{
if
(
removed
)
{
removed
-
>
push_back
(
it
-
>
msg_
)
;
}
else
{
delete
it
-
>
msg_
.
pdata
;
}
}
else
{
*
new_end
+
+
=
*
it
;
}
}
dmsgq_
.
container
(
)
.
erase
(
new_end
dmsgq_
.
container
(
)
.
end
(
)
)
;
dmsgq_
.
reheap
(
)
;
}
void
MessageQueue
:
:
Dispatch
(
Message
*
pmsg
)
{
TRACE_EVENT2
(
"
webrtc
"
"
MessageQueue
:
:
Dispatch
"
"
src_file_and_line
"
pmsg
-
>
posted_from
.
file_and_line
(
)
"
src_func
"
pmsg
-
>
posted_from
.
function_name
(
)
)
;
int64_t
start_time
=
TimeMillis
(
)
;
pmsg
-
>
phandler
-
>
OnMessage
(
pmsg
)
;
int64_t
end_time
=
TimeMillis
(
)
;
int64_t
diff
=
TimeDiff
(
end_time
start_time
)
;
if
(
diff
>
=
kSlowDispatchLoggingThreshold
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
Message
took
"
<
<
diff
<
<
"
ms
to
dispatch
.
Posted
from
:
"
<
<
pmsg
-
>
posted_from
.
ToString
(
)
;
}
}
}
