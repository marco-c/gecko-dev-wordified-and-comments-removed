#
include
"
rtc_base
/
rtccertificategenerator
.
h
"
#
include
<
memory
>
#
include
"
api
/
optional
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
gunit
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
refcountedobject
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
namespace
rtc
{
class
RTCCertificateGeneratorFixture
:
public
RTCCertificateGeneratorCallback
{
public
:
RTCCertificateGeneratorFixture
(
)
:
signaling_thread_
(
Thread
:
:
Current
(
)
)
worker_thread_
(
Thread
:
:
Create
(
)
)
generate_async_completed_
(
false
)
{
RTC_CHECK
(
signaling_thread_
)
;
RTC_CHECK
(
worker_thread_
-
>
Start
(
)
)
;
generator_
.
reset
(
new
RTCCertificateGenerator
(
signaling_thread_
worker_thread_
.
get
(
)
)
)
;
}
~
RTCCertificateGeneratorFixture
(
)
override
{
}
RTCCertificateGenerator
*
generator
(
)
const
{
return
generator_
.
get
(
)
;
}
RTCCertificate
*
certificate
(
)
const
{
return
certificate_
.
get
(
)
;
}
void
OnSuccess
(
const
scoped_refptr
<
RTCCertificate
>
&
certificate
)
override
{
RTC_CHECK
(
signaling_thread_
-
>
IsCurrent
(
)
)
;
RTC_CHECK
(
certificate
)
;
certificate_
=
certificate
;
generate_async_completed_
=
true
;
}
void
OnFailure
(
)
override
{
RTC_CHECK
(
signaling_thread_
-
>
IsCurrent
(
)
)
;
certificate_
=
nullptr
;
generate_async_completed_
=
true
;
}
bool
GenerateAsyncCompleted
(
)
{
RTC_CHECK
(
signaling_thread_
-
>
IsCurrent
(
)
)
;
if
(
generate_async_completed_
)
{
generate_async_completed_
=
false
;
return
true
;
}
return
false
;
}
protected
:
Thread
*
const
signaling_thread_
;
std
:
:
unique_ptr
<
Thread
>
worker_thread_
;
std
:
:
unique_ptr
<
RTCCertificateGenerator
>
generator_
;
scoped_refptr
<
RTCCertificate
>
certificate_
;
bool
generate_async_completed_
;
}
;
class
RTCCertificateGeneratorTest
:
public
testing
:
:
Test
{
public
:
RTCCertificateGeneratorTest
(
)
:
fixture_
(
new
RefCountedObject
<
RTCCertificateGeneratorFixture
>
(
)
)
{
}
protected
:
static
const
int
kGenerationTimeoutMs
=
10000
;
scoped_refptr
<
RTCCertificateGeneratorFixture
>
fixture_
;
}
;
TEST_F
(
RTCCertificateGeneratorTest
GenerateECDSA
)
{
EXPECT_TRUE
(
RTCCertificateGenerator
:
:
GenerateCertificate
(
KeyParams
:
:
ECDSA
(
)
Optional
<
uint64_t
>
(
)
)
)
;
}
TEST_F
(
RTCCertificateGeneratorTest
GenerateRSA
)
{
EXPECT_TRUE
(
RTCCertificateGenerator
:
:
GenerateCertificate
(
KeyParams
:
:
RSA
(
)
Optional
<
uint64_t
>
(
)
)
)
;
}
TEST_F
(
RTCCertificateGeneratorTest
GenerateAsyncECDSA
)
{
EXPECT_FALSE
(
fixture_
-
>
certificate
(
)
)
;
fixture_
-
>
generator
(
)
-
>
GenerateCertificateAsync
(
KeyParams
:
:
ECDSA
(
)
Optional
<
uint64_t
>
(
)
fixture_
)
;
EXPECT_FALSE
(
fixture_
-
>
GenerateAsyncCompleted
(
)
)
;
EXPECT_FALSE
(
fixture_
-
>
certificate
(
)
)
;
EXPECT_TRUE_WAIT
(
fixture_
-
>
GenerateAsyncCompleted
(
)
kGenerationTimeoutMs
)
;
EXPECT_TRUE
(
fixture_
-
>
certificate
(
)
)
;
}
TEST_F
(
RTCCertificateGeneratorTest
GenerateWithExpires
)
{
scoped_refptr
<
RTCCertificate
>
cert_a
=
RTCCertificateGenerator
:
:
GenerateCertificate
(
KeyParams
:
:
ECDSA
(
)
Optional
<
uint64_t
>
(
0
)
)
;
EXPECT_TRUE
(
cert_a
)
;
const
uint64_t
kExpiresMs
=
60000
;
scoped_refptr
<
RTCCertificate
>
cert_b
=
RTCCertificateGenerator
:
:
GenerateCertificate
(
KeyParams
:
:
ECDSA
(
)
Optional
<
uint64_t
>
(
kExpiresMs
)
)
;
EXPECT_TRUE
(
cert_b
)
;
EXPECT_GT
(
cert_b
-
>
Expires
(
)
cert_a
-
>
Expires
(
)
)
;
uint64_t
expires_diff
=
cert_b
-
>
Expires
(
)
-
cert_a
-
>
Expires
(
)
;
EXPECT_GE
(
expires_diff
kExpiresMs
)
;
EXPECT_LE
(
expires_diff
kExpiresMs
+
2
*
kGenerationTimeoutMs
+
1000
)
;
}
TEST_F
(
RTCCertificateGeneratorTest
GenerateWithInvalidParamsShouldFail
)
{
KeyParams
invalid_params
=
KeyParams
:
:
RSA
(
0
0
)
;
EXPECT_FALSE
(
invalid_params
.
IsValid
(
)
)
;
EXPECT_FALSE
(
RTCCertificateGenerator
:
:
GenerateCertificate
(
invalid_params
Optional
<
uint64_t
>
(
)
)
)
;
fixture_
-
>
generator
(
)
-
>
GenerateCertificateAsync
(
invalid_params
Optional
<
uint64_t
>
(
)
fixture_
)
;
EXPECT_TRUE_WAIT
(
fixture_
-
>
GenerateAsyncCompleted
(
)
kGenerationTimeoutMs
)
;
EXPECT_FALSE
(
fixture_
-
>
certificate
(
)
)
;
}
}
