#
include
"
rtc_base
/
task_queue
.
h
"
#
include
<
fcntl
.
h
>
#
include
<
signal
.
h
>
#
include
<
string
.
h
>
#
include
<
unistd
.
h
>
#
include
"
event2
/
event
.
h
"
#
include
"
event2
/
event_compat
.
h
"
#
include
"
event2
/
event_struct
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
platform_thread
.
h
"
#
include
"
rtc_base
/
refcount
.
h
"
#
include
"
rtc_base
/
refcountedobject
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
rtc_base
/
task_queue_posix
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
namespace
rtc
{
using
internal
:
:
GetQueuePtrTls
;
using
internal
:
:
AutoSetCurrentQueuePtr
;
namespace
{
static
const
char
kQuit
=
1
;
static
const
char
kRunTask
=
2
;
static
const
char
kRunReplyTask
=
3
;
using
Priority
=
TaskQueue
:
:
Priority
;
void
IgnoreSigPipeSignalOnCurrentThread
(
)
{
sigset_t
sigpipe_mask
;
sigemptyset
(
&
sigpipe_mask
)
;
sigaddset
(
&
sigpipe_mask
SIGPIPE
)
;
pthread_sigmask
(
SIG_BLOCK
&
sigpipe_mask
nullptr
)
;
}
struct
TimerEvent
{
explicit
TimerEvent
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
:
task
(
std
:
:
move
(
task
)
)
{
}
~
TimerEvent
(
)
{
event_del
(
&
ev
)
;
}
event
ev
;
std
:
:
unique_ptr
<
QueuedTask
>
task
;
}
;
bool
SetNonBlocking
(
int
fd
)
{
const
int
flags
=
fcntl
(
fd
F_GETFL
)
;
RTC_CHECK
(
flags
!
=
-
1
)
;
return
(
flags
&
O_NONBLOCK
)
|
|
fcntl
(
fd
F_SETFL
flags
|
O_NONBLOCK
)
!
=
-
1
;
}
void
EventAssign
(
struct
event
*
ev
struct
event_base
*
base
int
fd
short
events
void
(
*
callback
)
(
int
short
void
*
)
void
*
arg
)
{
#
if
defined
(
_EVENT2_EVENT_H_
)
RTC_CHECK_EQ
(
0
event_assign
(
ev
base
fd
events
callback
arg
)
)
;
#
else
event_set
(
ev
fd
events
callback
arg
)
;
RTC_CHECK_EQ
(
0
event_base_set
(
base
ev
)
)
;
#
endif
}
ThreadPriority
TaskQueuePriorityToThreadPriority
(
Priority
priority
)
{
switch
(
priority
)
{
case
Priority
:
:
HIGH
:
return
kRealtimePriority
;
case
Priority
:
:
LOW
:
return
kLowPriority
;
case
Priority
:
:
NORMAL
:
return
kNormalPriority
;
default
:
RTC_NOTREACHED
(
)
;
break
;
}
return
kNormalPriority
;
}
}
class
TaskQueue
:
:
Impl
:
public
RefCountInterface
{
public
:
explicit
Impl
(
const
char
*
queue_name
TaskQueue
*
queue
Priority
priority
=
Priority
:
:
NORMAL
)
;
~
Impl
(
)
override
;
static
TaskQueue
:
:
Impl
*
Current
(
)
;
static
TaskQueue
*
CurrentQueue
(
)
;
bool
IsCurrent
(
)
const
;
void
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
;
void
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
TaskQueue
:
:
Impl
*
reply_queue
)
;
void
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
;
private
:
static
void
ThreadMain
(
void
*
context
)
;
static
void
OnWakeup
(
int
socket
short
flags
void
*
context
)
;
static
void
RunTask
(
int
fd
short
flags
void
*
context
)
;
static
void
RunTimer
(
int
fd
short
flags
void
*
context
)
;
class
ReplyTaskOwner
;
class
PostAndReplyTask
;
class
SetTimerTask
;
typedef
RefCountedObject
<
ReplyTaskOwner
>
ReplyTaskOwnerRef
;
void
PrepareReplyTask
(
scoped_refptr
<
ReplyTaskOwnerRef
>
reply_task
)
;
struct
QueueContext
;
TaskQueue
*
const
queue_
;
int
wakeup_pipe_in_
=
-
1
;
int
wakeup_pipe_out_
=
-
1
;
event_base
*
event_base_
;
std
:
:
unique_ptr
<
event
>
wakeup_event_
;
PlatformThread
thread_
;
rtc
:
:
CriticalSection
pending_lock_
;
std
:
:
list
<
std
:
:
unique_ptr
<
QueuedTask
>
>
pending_
RTC_GUARDED_BY
(
pending_lock_
)
;
std
:
:
list
<
scoped_refptr
<
ReplyTaskOwnerRef
>
>
pending_replies_
RTC_GUARDED_BY
(
pending_lock_
)
;
}
;
struct
TaskQueue
:
:
Impl
:
:
QueueContext
{
explicit
QueueContext
(
TaskQueue
:
:
Impl
*
q
)
:
queue
(
q
)
is_active
(
true
)
{
}
TaskQueue
:
:
Impl
*
queue
;
bool
is_active
;
std
:
:
list
<
TimerEvent
*
>
pending_timers_
;
}
;
class
TaskQueue
:
:
Impl
:
:
ReplyTaskOwner
{
public
:
ReplyTaskOwner
(
std
:
:
unique_ptr
<
QueuedTask
>
reply
)
:
reply_
(
std
:
:
move
(
reply
)
)
{
}
void
Run
(
)
{
RTC_DCHECK
(
reply_
)
;
if
(
run_task_
)
{
if
(
!
reply_
-
>
Run
(
)
)
reply_
.
release
(
)
;
}
reply_
.
reset
(
)
;
}
void
set_should_run_task
(
)
{
RTC_DCHECK
(
!
run_task_
)
;
run_task_
=
true
;
}
private
:
std
:
:
unique_ptr
<
QueuedTask
>
reply_
;
bool
run_task_
=
false
;
}
;
class
TaskQueue
:
:
Impl
:
:
PostAndReplyTask
:
public
QueuedTask
{
public
:
PostAndReplyTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
TaskQueue
:
:
Impl
*
reply_queue
int
reply_pipe
)
:
task_
(
std
:
:
move
(
task
)
)
reply_pipe_
(
reply_pipe
)
reply_task_owner_
(
new
RefCountedObject
<
ReplyTaskOwner
>
(
std
:
:
move
(
reply
)
)
)
{
reply_queue
-
>
PrepareReplyTask
(
reply_task_owner_
)
;
}
~
PostAndReplyTask
(
)
override
{
reply_task_owner_
=
nullptr
;
IgnoreSigPipeSignalOnCurrentThread
(
)
;
char
message
=
kRunReplyTask
;
write
(
reply_pipe_
&
message
sizeof
(
message
)
)
;
}
private
:
bool
Run
(
)
override
{
if
(
!
task_
-
>
Run
(
)
)
task_
.
release
(
)
;
reply_task_owner_
-
>
set_should_run_task
(
)
;
return
true
;
}
std
:
:
unique_ptr
<
QueuedTask
>
task_
;
int
reply_pipe_
;
scoped_refptr
<
RefCountedObject
<
ReplyTaskOwner
>
>
reply_task_owner_
;
}
;
class
TaskQueue
:
:
Impl
:
:
SetTimerTask
:
public
QueuedTask
{
public
:
SetTimerTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
:
task_
(
std
:
:
move
(
task
)
)
milliseconds_
(
milliseconds
)
posted_
(
Time32
(
)
)
{
}
private
:
bool
Run
(
)
override
{
uint32_t
post_time
=
Time32
(
)
-
posted_
;
TaskQueue
:
:
Impl
:
:
Current
(
)
-
>
PostDelayedTask
(
std
:
:
move
(
task_
)
post_time
>
milliseconds_
?
0
:
milliseconds_
-
post_time
)
;
return
true
;
}
std
:
:
unique_ptr
<
QueuedTask
>
task_
;
const
uint32_t
milliseconds_
;
const
uint32_t
posted_
;
}
;
TaskQueue
:
:
Impl
:
:
Impl
(
const
char
*
queue_name
TaskQueue
*
queue
Priority
priority
)
:
queue_
(
queue
)
event_base_
(
event_base_new
(
)
)
wakeup_event_
(
new
event
(
)
)
thread_
(
&
TaskQueue
:
:
Impl
:
:
ThreadMain
this
queue_name
TaskQueuePriorityToThreadPriority
(
priority
)
)
{
RTC_DCHECK
(
queue_name
)
;
int
fds
[
2
]
;
RTC_CHECK
(
pipe
(
fds
)
=
=
0
)
;
SetNonBlocking
(
fds
[
0
]
)
;
SetNonBlocking
(
fds
[
1
]
)
;
wakeup_pipe_out_
=
fds
[
0
]
;
wakeup_pipe_in_
=
fds
[
1
]
;
EventAssign
(
wakeup_event_
.
get
(
)
event_base_
wakeup_pipe_out_
EV_READ
|
EV_PERSIST
OnWakeup
this
)
;
event_add
(
wakeup_event_
.
get
(
)
0
)
;
thread_
.
Start
(
)
;
}
TaskQueue
:
:
Impl
:
:
~
Impl
(
)
{
RTC_DCHECK
(
!
IsCurrent
(
)
)
;
struct
timespec
ts
;
char
message
=
kQuit
;
while
(
write
(
wakeup_pipe_in_
&
message
sizeof
(
message
)
)
!
=
sizeof
(
message
)
)
{
RTC_CHECK_EQ
(
EAGAIN
errno
)
;
ts
.
tv_sec
=
0
;
ts
.
tv_nsec
=
1000000
;
nanosleep
(
&
ts
nullptr
)
;
}
thread_
.
Stop
(
)
;
event_del
(
wakeup_event_
.
get
(
)
)
;
IgnoreSigPipeSignalOnCurrentThread
(
)
;
close
(
wakeup_pipe_in_
)
;
close
(
wakeup_pipe_out_
)
;
wakeup_pipe_in_
=
-
1
;
wakeup_pipe_out_
=
-
1
;
event_base_free
(
event_base_
)
;
}
TaskQueue
:
:
Impl
*
TaskQueue
:
:
Impl
:
:
Current
(
)
{
QueueContext
*
ctx
=
static_cast
<
QueueContext
*
>
(
pthread_getspecific
(
GetQueuePtrTls
(
)
)
)
;
return
ctx
?
ctx
-
>
queue
:
nullptr
;
}
TaskQueue
*
TaskQueue
:
:
Impl
:
:
CurrentQueue
(
)
{
TaskQueue
:
:
Impl
*
current
=
Current
(
)
;
if
(
current
)
{
return
current
-
>
queue_
;
}
return
nullptr
;
}
bool
TaskQueue
:
:
Impl
:
:
IsCurrent
(
)
const
{
return
IsThreadRefEqual
(
thread_
.
GetThreadRef
(
)
CurrentThreadRef
(
)
)
;
}
void
TaskQueue
:
:
Impl
:
:
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
{
RTC_DCHECK
(
task
.
get
(
)
)
;
if
(
IsCurrent
(
)
)
{
if
(
event_base_once
(
event_base_
-
1
EV_TIMEOUT
&
TaskQueue
:
:
Impl
:
:
RunTask
task
.
get
(
)
nullptr
)
=
=
0
)
{
task
.
release
(
)
;
}
}
else
{
QueuedTask
*
task_id
=
task
.
get
(
)
;
{
CritScope
lock
(
&
pending_lock_
)
;
pending_
.
push_back
(
std
:
:
move
(
task
)
)
;
}
char
message
=
kRunTask
;
if
(
write
(
wakeup_pipe_in_
&
message
sizeof
(
message
)
)
!
=
sizeof
(
message
)
)
{
RTC_LOG
(
WARNING
)
<
<
"
Failed
to
queue
task
.
"
;
CritScope
lock
(
&
pending_lock_
)
;
pending_
.
remove_if
(
[
task_id
]
(
std
:
:
unique_ptr
<
QueuedTask
>
&
t
)
{
return
t
.
get
(
)
=
=
task_id
;
}
)
;
}
}
}
void
TaskQueue
:
:
Impl
:
:
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
{
if
(
IsCurrent
(
)
)
{
TimerEvent
*
timer
=
new
TimerEvent
(
std
:
:
move
(
task
)
)
;
EventAssign
(
&
timer
-
>
ev
event_base_
-
1
0
&
TaskQueue
:
:
Impl
:
:
RunTimer
timer
)
;
QueueContext
*
ctx
=
static_cast
<
QueueContext
*
>
(
pthread_getspecific
(
GetQueuePtrTls
(
)
)
)
;
ctx
-
>
pending_timers_
.
push_back
(
timer
)
;
timeval
tv
=
{
static_cast
<
time_t
>
(
milliseconds
)
/
1000
static_cast
<
suseconds_t
>
(
(
milliseconds
%
1000
)
*
1000
)
}
;
event_add
(
&
timer
-
>
ev
&
tv
)
;
}
else
{
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
(
new
SetTimerTask
(
std
:
:
move
(
task
)
milliseconds
)
)
)
;
}
}
void
TaskQueue
:
:
Impl
:
:
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
TaskQueue
:
:
Impl
*
reply_queue
)
{
std
:
:
unique_ptr
<
QueuedTask
>
wrapper_task
(
new
PostAndReplyTask
(
std
:
:
move
(
task
)
std
:
:
move
(
reply
)
reply_queue
reply_queue
-
>
wakeup_pipe_in_
)
)
;
PostTask
(
std
:
:
move
(
wrapper_task
)
)
;
}
void
TaskQueue
:
:
Impl
:
:
ThreadMain
(
void
*
context
)
{
TaskQueue
:
:
Impl
*
me
=
static_cast
<
TaskQueue
:
:
Impl
*
>
(
context
)
;
QueueContext
queue_context
(
me
)
;
pthread_setspecific
(
GetQueuePtrTls
(
)
&
queue_context
)
;
while
(
queue_context
.
is_active
)
event_base_loop
(
me
-
>
event_base_
0
)
;
pthread_setspecific
(
GetQueuePtrTls
(
)
nullptr
)
;
for
(
TimerEvent
*
timer
:
queue_context
.
pending_timers_
)
delete
timer
;
}
void
TaskQueue
:
:
Impl
:
:
OnWakeup
(
int
socket
short
flags
void
*
context
)
{
QueueContext
*
ctx
=
static_cast
<
QueueContext
*
>
(
pthread_getspecific
(
GetQueuePtrTls
(
)
)
)
;
RTC_DCHECK
(
ctx
-
>
queue
-
>
wakeup_pipe_out_
=
=
socket
)
;
char
buf
;
RTC_CHECK
(
sizeof
(
buf
)
=
=
read
(
socket
&
buf
sizeof
(
buf
)
)
)
;
switch
(
buf
)
{
case
kQuit
:
ctx
-
>
is_active
=
false
;
event_base_loopbreak
(
ctx
-
>
queue
-
>
event_base_
)
;
break
;
case
kRunTask
:
{
std
:
:
unique_ptr
<
QueuedTask
>
task
;
{
CritScope
lock
(
&
ctx
-
>
queue
-
>
pending_lock_
)
;
RTC_DCHECK
(
!
ctx
-
>
queue
-
>
pending_
.
empty
(
)
)
;
task
=
std
:
:
move
(
ctx
-
>
queue
-
>
pending_
.
front
(
)
)
;
ctx
-
>
queue
-
>
pending_
.
pop_front
(
)
;
RTC_DCHECK
(
task
.
get
(
)
)
;
}
if
(
!
task
-
>
Run
(
)
)
task
.
release
(
)
;
break
;
}
case
kRunReplyTask
:
{
scoped_refptr
<
ReplyTaskOwnerRef
>
reply_task
;
{
CritScope
lock
(
&
ctx
-
>
queue
-
>
pending_lock_
)
;
for
(
auto
it
=
ctx
-
>
queue
-
>
pending_replies_
.
begin
(
)
;
it
!
=
ctx
-
>
queue
-
>
pending_replies_
.
end
(
)
;
+
+
it
)
{
if
(
(
*
it
)
-
>
HasOneRef
(
)
)
{
reply_task
=
std
:
:
move
(
*
it
)
;
ctx
-
>
queue
-
>
pending_replies_
.
erase
(
it
)
;
break
;
}
}
}
reply_task
-
>
Run
(
)
;
break
;
}
default
:
RTC_NOTREACHED
(
)
;
break
;
}
}
void
TaskQueue
:
:
Impl
:
:
RunTask
(
int
fd
short
flags
void
*
context
)
{
auto
*
task
=
static_cast
<
QueuedTask
*
>
(
context
)
;
if
(
task
-
>
Run
(
)
)
delete
task
;
}
void
TaskQueue
:
:
Impl
:
:
RunTimer
(
int
fd
short
flags
void
*
context
)
{
TimerEvent
*
timer
=
static_cast
<
TimerEvent
*
>
(
context
)
;
if
(
!
timer
-
>
task
-
>
Run
(
)
)
timer
-
>
task
.
release
(
)
;
QueueContext
*
ctx
=
static_cast
<
QueueContext
*
>
(
pthread_getspecific
(
GetQueuePtrTls
(
)
)
)
;
ctx
-
>
pending_timers_
.
remove
(
timer
)
;
delete
timer
;
}
void
TaskQueue
:
:
Impl
:
:
PrepareReplyTask
(
scoped_refptr
<
ReplyTaskOwnerRef
>
reply_task
)
{
RTC_DCHECK
(
reply_task
)
;
CritScope
lock
(
&
pending_lock_
)
;
pending_replies_
.
push_back
(
std
:
:
move
(
reply_task
)
)
;
}
TaskQueue
:
:
TaskQueue
(
const
char
*
queue_name
Priority
priority
)
:
impl_
(
new
RefCountedObject
<
TaskQueue
:
:
Impl
>
(
queue_name
this
priority
)
)
{
}
TaskQueue
:
:
~
TaskQueue
(
)
{
}
TaskQueue
*
TaskQueue
:
:
Current
(
)
{
return
TaskQueue
:
:
Impl
:
:
CurrentQueue
(
)
;
}
bool
TaskQueue
:
:
IsCurrent
(
)
const
{
return
impl_
-
>
IsCurrent
(
)
;
}
void
TaskQueue
:
:
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
{
return
TaskQueue
:
:
impl_
-
>
PostTask
(
std
:
:
move
(
task
)
)
;
}
void
TaskQueue
:
:
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
TaskQueue
*
reply_queue
)
{
return
TaskQueue
:
:
impl_
-
>
PostTaskAndReply
(
std
:
:
move
(
task
)
std
:
:
move
(
reply
)
reply_queue
-
>
impl_
.
get
(
)
)
;
}
void
TaskQueue
:
:
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
)
{
return
TaskQueue
:
:
impl_
-
>
PostTaskAndReply
(
std
:
:
move
(
task
)
std
:
:
move
(
reply
)
impl_
.
get
(
)
)
;
}
void
TaskQueue
:
:
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
{
return
TaskQueue
:
:
impl_
-
>
PostDelayedTask
(
std
:
:
move
(
task
)
milliseconds
)
;
}
}
