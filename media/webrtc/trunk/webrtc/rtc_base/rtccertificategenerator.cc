#
include
"
rtc_base
/
rtccertificategenerator
.
h
"
#
include
<
algorithm
>
#
include
<
memory
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
refcountedobject
.
h
"
#
include
"
rtc_base
/
sslidentity
.
h
"
namespace
rtc
{
namespace
{
const
char
kIdentityName
[
]
=
"
WebRTC
"
;
const
uint64_t
kYearInSeconds
=
365
*
24
*
60
*
60
;
enum
{
MSG_GENERATE
MSG_GENERATE_DONE
}
;
class
RTCCertificateGenerationTask
:
public
RefCountInterface
public
MessageHandler
{
public
:
RTCCertificateGenerationTask
(
Thread
*
signaling_thread
Thread
*
worker_thread
const
KeyParams
&
key_params
const
Optional
<
uint64_t
>
&
expires_ms
const
scoped_refptr
<
RTCCertificateGeneratorCallback
>
&
callback
)
:
signaling_thread_
(
signaling_thread
)
worker_thread_
(
worker_thread
)
key_params_
(
key_params
)
expires_ms_
(
expires_ms
)
callback_
(
callback
)
{
RTC_DCHECK
(
signaling_thread_
)
;
RTC_DCHECK
(
worker_thread_
)
;
RTC_DCHECK
(
callback_
)
;
}
~
RTCCertificateGenerationTask
(
)
override
{
}
void
OnMessage
(
Message
*
msg
)
override
{
switch
(
msg
-
>
message_id
)
{
case
MSG_GENERATE
:
RTC_DCHECK
(
worker_thread_
-
>
IsCurrent
(
)
)
;
certificate_
=
RTCCertificateGenerator
:
:
GenerateCertificate
(
key_params_
expires_ms_
)
;
signaling_thread_
-
>
Post
(
RTC_FROM_HERE
this
MSG_GENERATE_DONE
msg
-
>
pdata
)
;
break
;
case
MSG_GENERATE_DONE
:
RTC_DCHECK
(
signaling_thread_
-
>
IsCurrent
(
)
)
;
if
(
certificate_
)
{
callback_
-
>
OnSuccess
(
certificate_
)
;
}
else
{
callback_
-
>
OnFailure
(
)
;
}
delete
msg
-
>
pdata
;
return
;
default
:
RTC_NOTREACHED
(
)
;
}
}
private
:
Thread
*
const
signaling_thread_
;
Thread
*
const
worker_thread_
;
const
KeyParams
key_params_
;
const
Optional
<
uint64_t
>
expires_ms_
;
const
scoped_refptr
<
RTCCertificateGeneratorCallback
>
callback_
;
scoped_refptr
<
RTCCertificate
>
certificate_
;
}
;
}
scoped_refptr
<
RTCCertificate
>
RTCCertificateGenerator
:
:
GenerateCertificate
(
const
KeyParams
&
key_params
const
Optional
<
uint64_t
>
&
expires_ms
)
{
if
(
!
key_params
.
IsValid
(
)
)
return
nullptr
;
SSLIdentity
*
identity
;
if
(
!
expires_ms
)
{
identity
=
SSLIdentity
:
:
Generate
(
kIdentityName
key_params
)
;
}
else
{
uint64_t
expires_s
=
*
expires_ms
/
1000
;
expires_s
=
std
:
:
min
(
expires_s
kYearInSeconds
)
;
time_t
cert_lifetime_s
=
static_cast
<
time_t
>
(
expires_s
)
;
identity
=
SSLIdentity
:
:
GenerateWithExpiration
(
kIdentityName
key_params
cert_lifetime_s
)
;
}
if
(
!
identity
)
return
nullptr
;
std
:
:
unique_ptr
<
SSLIdentity
>
identity_sptr
(
identity
)
;
return
RTCCertificate
:
:
Create
(
std
:
:
move
(
identity_sptr
)
)
;
}
RTCCertificateGenerator
:
:
RTCCertificateGenerator
(
Thread
*
signaling_thread
Thread
*
worker_thread
)
:
signaling_thread_
(
signaling_thread
)
worker_thread_
(
worker_thread
)
{
RTC_DCHECK
(
signaling_thread_
)
;
RTC_DCHECK
(
worker_thread_
)
;
}
void
RTCCertificateGenerator
:
:
GenerateCertificateAsync
(
const
KeyParams
&
key_params
const
Optional
<
uint64_t
>
&
expires_ms
const
scoped_refptr
<
RTCCertificateGeneratorCallback
>
&
callback
)
{
RTC_DCHECK
(
signaling_thread_
-
>
IsCurrent
(
)
)
;
RTC_DCHECK
(
callback
)
;
ScopedRefMessageData
<
RTCCertificateGenerationTask
>
*
msg_data
=
new
ScopedRefMessageData
<
RTCCertificateGenerationTask
>
(
new
RefCountedObject
<
RTCCertificateGenerationTask
>
(
signaling_thread_
worker_thread_
key_params
expires_ms
callback
)
)
;
worker_thread_
-
>
Post
(
RTC_FROM_HERE
msg_data
-
>
data
(
)
.
get
(
)
MSG_GENERATE
msg_data
)
;
}
}
