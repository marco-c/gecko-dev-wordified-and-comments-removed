#
ifndef
MODULES_AUDIO_PROCESSING_INCLUDE_AEC_DUMP_H_
#
define
MODULES_AUDIO_PROCESSING_INCLUDE_AEC_DUMP_H_
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
namespace
webrtc
{
class
AudioFrame
;
struct
InternalAPMConfig
{
InternalAPMConfig
(
)
;
InternalAPMConfig
(
const
InternalAPMConfig
&
)
;
InternalAPMConfig
(
InternalAPMConfig
&
&
)
;
InternalAPMConfig
&
operator
=
(
const
InternalAPMConfig
&
)
;
InternalAPMConfig
&
operator
=
(
InternalAPMConfig
&
&
)
=
delete
;
bool
operator
=
=
(
const
InternalAPMConfig
&
other
)
;
bool
aec_enabled
=
false
;
bool
aec_delay_agnostic_enabled
=
false
;
bool
aec_drift_compensation_enabled
=
false
;
bool
aec_extended_filter_enabled
=
false
;
int
aec_suppression_level
=
0
;
bool
aecm_enabled
=
false
;
bool
aecm_comfort_noise_enabled
=
false
;
int
aecm_routing_mode
=
0
;
bool
agc_enabled
=
false
;
int
agc_mode
=
0
;
bool
agc_limiter_enabled
=
false
;
bool
hpf_enabled
=
false
;
bool
ns_enabled
=
false
;
int
ns_level
=
0
;
bool
transient_suppression_enabled
=
false
;
bool
intelligibility_enhancer_enabled
=
false
;
bool
noise_robust_agc_enabled
=
false
;
std
:
:
string
experiments_description
=
"
"
;
}
;
struct
InternalAPMStreamsConfig
{
int
input_sample_rate
=
0
;
int
output_sample_rate
=
0
;
int
render_input_sample_rate
=
0
;
int
render_output_sample_rate
=
0
;
size_t
input_num_channels
=
0
;
size_t
output_num_channels
=
0
;
size_t
render_input_num_channels
=
0
;
size_t
render_output_num_channels
=
0
;
}
;
class
FloatAudioFrame
{
public
:
FloatAudioFrame
(
const
float
*
const
*
audio_samples
size_t
num_channels
size_t
channel_size
)
:
audio_samples_
(
audio_samples
)
num_channels_
(
num_channels
)
channel_size_
(
channel_size
)
{
}
FloatAudioFrame
(
)
=
delete
;
size_t
num_channels
(
)
const
{
return
num_channels_
;
}
rtc
:
:
ArrayView
<
const
float
>
channel
(
size_t
idx
)
const
{
RTC_DCHECK_LE
(
0
idx
)
;
RTC_DCHECK_LE
(
idx
num_channels_
)
;
return
rtc
:
:
ArrayView
<
const
float
>
(
audio_samples_
[
idx
]
channel_size_
)
;
}
private
:
const
float
*
const
*
audio_samples_
;
size_t
num_channels_
;
size_t
channel_size_
;
}
;
class
AecDump
{
public
:
struct
AudioProcessingState
{
int
delay
;
int
drift
;
int
level
;
bool
keypress
;
}
;
virtual
~
AecDump
(
)
=
default
;
virtual
void
WriteInitMessage
(
const
InternalAPMStreamsConfig
&
streams_config
)
=
0
;
virtual
void
AddCaptureStreamInput
(
const
FloatAudioFrame
&
src
)
=
0
;
virtual
void
AddCaptureStreamOutput
(
const
FloatAudioFrame
&
src
)
=
0
;
virtual
void
AddCaptureStreamInput
(
const
AudioFrame
&
frame
)
=
0
;
virtual
void
AddCaptureStreamOutput
(
const
AudioFrame
&
frame
)
=
0
;
virtual
void
AddAudioProcessingState
(
const
AudioProcessingState
&
state
)
=
0
;
virtual
void
WriteCaptureStreamMessage
(
)
=
0
;
virtual
void
WriteRenderStreamMessage
(
const
AudioFrame
&
frame
)
=
0
;
virtual
void
WriteRenderStreamMessage
(
const
FloatAudioFrame
&
src
)
=
0
;
virtual
void
WriteConfig
(
const
InternalAPMConfig
&
config
)
=
0
;
}
;
}
#
endif
