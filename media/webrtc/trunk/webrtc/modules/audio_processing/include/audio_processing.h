#
ifndef
MODULES_AUDIO_PROCESSING_INCLUDE_AUDIO_PROCESSING_H_
#
define
MODULES_AUDIO_PROCESSING_INCLUDE_AUDIO_PROCESSING_H_
#
include
<
math
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
vector
>
#
include
"
api
/
optional
.
h
"
#
include
"
modules
/
audio_processing
/
beamformer
/
array_util
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing_statistics
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
config
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
deprecation
.
h
"
#
include
"
rtc_base
/
platform_file
.
h
"
#
include
"
rtc_base
/
refcount
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
struct
AecCore
;
class
AecDump
;
class
AudioBuffer
;
class
AudioFrame
;
class
NonlinearBeamformer
;
class
StreamConfig
;
class
ProcessingConfig
;
class
EchoCancellation
;
class
EchoControlMobile
;
class
EchoControlFactory
;
class
GainControl
;
class
HighPassFilter
;
class
LevelEstimator
;
class
NoiseSuppression
;
class
PostProcessing
;
class
VoiceDetection
;
struct
ExtendedFilter
{
ExtendedFilter
(
)
:
enabled
(
false
)
{
}
explicit
ExtendedFilter
(
bool
enabled
)
:
enabled
(
enabled
)
{
}
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kExtendedFilter
;
bool
enabled
;
}
;
struct
RefinedAdaptiveFilter
{
RefinedAdaptiveFilter
(
)
:
enabled
(
false
)
{
}
explicit
RefinedAdaptiveFilter
(
bool
enabled
)
:
enabled
(
enabled
)
{
}
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kAecRefinedAdaptiveFilter
;
bool
enabled
;
}
;
struct
DelayAgnostic
{
DelayAgnostic
(
)
:
enabled
(
false
)
{
}
explicit
DelayAgnostic
(
bool
enabled
)
:
enabled
(
enabled
)
{
}
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kDelayAgnostic
;
bool
enabled
;
}
;
#
if
defined
(
WEBRTC_CHROMIUM_BUILD
)
static
const
int
kAgcStartupMinVolume
=
85
;
#
else
static
const
int
kAgcStartupMinVolume
=
0
;
#
endif
static
constexpr
int
kClippedLevelMin
=
70
;
struct
ExperimentalAgc
{
ExperimentalAgc
(
)
=
default
;
explicit
ExperimentalAgc
(
bool
enabled
)
:
enabled
(
enabled
)
{
}
ExperimentalAgc
(
bool
enabled
int
startup_min_volume
)
:
enabled
(
enabled
)
startup_min_volume
(
startup_min_volume
)
{
}
ExperimentalAgc
(
bool
enabled
int
startup_min_volume
int
clipped_level_min
)
:
enabled
(
enabled
)
startup_min_volume
(
startup_min_volume
)
clipped_level_min
(
clipped_level_min
)
{
}
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kExperimentalAgc
;
bool
enabled
=
true
;
int
startup_min_volume
=
kAgcStartupMinVolume
;
int
clipped_level_min
=
kClippedLevelMin
;
}
;
struct
ExperimentalNs
{
ExperimentalNs
(
)
:
enabled
(
false
)
{
}
explicit
ExperimentalNs
(
bool
enabled
)
:
enabled
(
enabled
)
{
}
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kExperimentalNs
;
bool
enabled
;
}
;
struct
Beamforming
{
Beamforming
(
)
;
Beamforming
(
bool
enabled
const
std
:
:
vector
<
Point
>
&
array_geometry
)
;
Beamforming
(
bool
enabled
const
std
:
:
vector
<
Point
>
&
array_geometry
SphericalPointf
target_direction
)
;
~
Beamforming
(
)
;
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kBeamforming
;
const
bool
enabled
;
const
std
:
:
vector
<
Point
>
array_geometry
;
const
SphericalPointf
target_direction
;
}
;
struct
Intelligibility
{
Intelligibility
(
)
:
enabled
(
false
)
{
}
explicit
Intelligibility
(
bool
enabled
)
:
enabled
(
enabled
)
{
}
static
const
ConfigOptionID
identifier
=
ConfigOptionID
:
:
kIntelligibility
;
bool
enabled
;
}
;
class
AudioProcessing
:
public
rtc
:
:
RefCountInterface
{
public
:
struct
Config
{
struct
LevelController
{
bool
enabled
=
false
;
float
initial_peak_level_dbfs
=
-
6
.
0206f
;
}
level_controller
;
struct
ResidualEchoDetector
{
bool
enabled
=
true
;
}
residual_echo_detector
;
struct
HighPassFilter
{
bool
enabled
=
false
;
}
high_pass_filter
;
struct
EchoCanceller3
{
bool
enabled
=
false
;
}
echo_canceller3
;
struct
GainController2
{
bool
enabled
=
false
;
float
fixed_gain_db
=
0
.
f
;
}
gain_controller2
;
Config
&
operator
=
(
const
Config
&
config
)
{
if
(
this
!
=
&
config
)
{
memcpy
(
this
&
config
sizeof
(
*
this
)
)
;
}
return
*
this
;
}
}
;
enum
ChannelLayout
{
kMono
kStereo
kMonoAndKeyboard
kStereoAndKeyboard
}
;
static
AudioProcessing
*
Create
(
)
;
static
AudioProcessing
*
Create
(
const
webrtc
:
:
Config
&
config
)
;
RTC_DEPRECATED
static
AudioProcessing
*
Create
(
const
webrtc
:
:
Config
&
config
NonlinearBeamformer
*
beamformer
)
;
static
AudioProcessing
*
Create
(
const
webrtc
:
:
Config
&
config
std
:
:
unique_ptr
<
PostProcessing
>
capture_post_processor
std
:
:
unique_ptr
<
EchoControlFactory
>
echo_control_factory
NonlinearBeamformer
*
beamformer
)
;
~
AudioProcessing
(
)
override
{
}
virtual
int
Initialize
(
)
=
0
;
virtual
int
Initialize
(
const
ProcessingConfig
&
processing_config
)
=
0
;
virtual
int
Initialize
(
int
capture_input_sample_rate_hz
int
capture_output_sample_rate_hz
int
render_sample_rate_hz
ChannelLayout
capture_input_layout
ChannelLayout
capture_output_layout
ChannelLayout
render_input_layout
)
=
0
;
virtual
void
ApplyConfig
(
const
Config
&
config
)
=
0
;
virtual
void
SetExtraOptions
(
const
webrtc
:
:
Config
&
config
)
=
0
;
virtual
int
proc_sample_rate_hz
(
)
const
=
0
;
virtual
int
proc_split_sample_rate_hz
(
)
const
=
0
;
virtual
size_t
num_input_channels
(
)
const
=
0
;
virtual
size_t
num_proc_channels
(
)
const
=
0
;
virtual
size_t
num_output_channels
(
)
const
=
0
;
virtual
size_t
num_reverse_channels
(
)
const
=
0
;
virtual
void
set_output_will_be_muted
(
bool
muted
)
=
0
;
virtual
int
ProcessStream
(
AudioFrame
*
frame
)
=
0
;
virtual
int
ProcessStream
(
const
float
*
const
*
src
size_t
samples_per_channel
int
input_sample_rate_hz
ChannelLayout
input_layout
int
output_sample_rate_hz
ChannelLayout
output_layout
float
*
const
*
dest
)
=
0
;
virtual
int
ProcessStream
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
float
*
const
*
dest
)
=
0
;
virtual
int
ProcessReverseStream
(
AudioFrame
*
frame
)
=
0
;
virtual
int
AnalyzeReverseStream
(
const
float
*
const
*
data
size_t
samples_per_channel
int
sample_rate_hz
ChannelLayout
layout
)
=
0
;
virtual
int
ProcessReverseStream
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
float
*
const
*
dest
)
=
0
;
virtual
int
set_stream_delay_ms
(
int
delay
)
=
0
;
virtual
int
stream_delay_ms
(
)
const
=
0
;
virtual
bool
was_stream_delay_set
(
)
const
=
0
;
virtual
void
set_stream_key_pressed
(
bool
key_pressed
)
=
0
;
virtual
void
set_delay_offset_ms
(
int
offset
)
=
0
;
virtual
int
delay_offset_ms
(
)
const
=
0
;
virtual
void
AttachAecDump
(
std
:
:
unique_ptr
<
AecDump
>
aec_dump
)
=
0
;
virtual
void
DetachAecDump
(
)
=
0
;
virtual
void
UpdateHistogramsOnCallEnd
(
)
=
0
;
struct
Statistic
{
int
instant
=
0
;
int
average
=
0
;
int
maximum
=
0
;
int
minimum
=
0
;
}
;
struct
Stat
{
void
Set
(
const
Statistic
&
other
)
{
Set
(
other
.
instant
other
.
average
other
.
maximum
other
.
minimum
)
;
}
void
Set
(
float
instant
float
average
float
maximum
float
minimum
)
{
instant_
=
instant
;
average_
=
average
;
maximum_
=
maximum
;
minimum_
=
minimum
;
}
float
instant
(
)
const
{
return
instant_
;
}
float
average
(
)
const
{
return
average_
;
}
float
maximum
(
)
const
{
return
maximum_
;
}
float
minimum
(
)
const
{
return
minimum_
;
}
private
:
float
instant_
=
0
.
0f
;
float
average_
=
0
.
0f
;
float
maximum_
=
0
.
0f
;
float
minimum_
=
0
.
0f
;
}
;
struct
AudioProcessingStatistics
{
AudioProcessingStatistics
(
)
;
AudioProcessingStatistics
(
const
AudioProcessingStatistics
&
other
)
;
~
AudioProcessingStatistics
(
)
;
Stat
residual_echo_return_loss
;
Stat
echo_return_loss
;
Stat
echo_return_loss_enhancement
;
Stat
a_nlp
;
float
divergent_filter_fraction
=
-
1
.
0f
;
int
delay_median
=
-
1
;
int
delay_standard_deviation
=
-
1
;
float
fraction_poor_delays
=
-
1
.
0f
;
float
residual_echo_likelihood
=
-
1
.
0f
;
float
residual_echo_likelihood_recent_max
=
-
1
.
0f
;
}
;
virtual
AudioProcessingStatistics
GetStatistics
(
)
const
;
virtual
AudioProcessingStats
GetStatistics
(
bool
has_remote_tracks
)
const
;
virtual
EchoCancellation
*
echo_cancellation
(
)
const
=
0
;
virtual
EchoControlMobile
*
echo_control_mobile
(
)
const
=
0
;
virtual
GainControl
*
gain_control
(
)
const
=
0
;
virtual
HighPassFilter
*
high_pass_filter
(
)
const
=
0
;
virtual
LevelEstimator
*
level_estimator
(
)
const
=
0
;
virtual
NoiseSuppression
*
noise_suppression
(
)
const
=
0
;
virtual
VoiceDetection
*
voice_detection
(
)
const
=
0
;
virtual
AudioProcessing
:
:
Config
GetConfig
(
)
const
=
0
;
enum
Error
{
kNoError
=
0
kUnspecifiedError
=
-
1
kCreationFailedError
=
-
2
kUnsupportedComponentError
=
-
3
kUnsupportedFunctionError
=
-
4
kNullPointerError
=
-
5
kBadParameterError
=
-
6
kBadSampleRateError
=
-
7
kBadDataLengthError
=
-
8
kBadNumberChannelsError
=
-
9
kFileError
=
-
10
kStreamParameterNotSetError
=
-
11
kNotEnabledError
=
-
12
kBadStreamParameterWarning
=
-
13
}
;
enum
NativeRate
{
kSampleRate8kHz
=
8000
kSampleRate16kHz
=
16000
kSampleRate32kHz
=
32000
kSampleRate44_1kHz
=
44100
kSampleRate48kHz
=
48000
}
;
static
constexpr
int
kNativeSampleRatesHz
[
4
]
=
{
kSampleRate8kHz
kSampleRate16kHz
kSampleRate32kHz
kSampleRate48kHz
}
;
static
constexpr
size_t
kNumNativeSampleRates
=
arraysize
(
kNativeSampleRatesHz
)
;
static
constexpr
int
kMaxNativeSampleRateHz
=
kNativeSampleRatesHz
[
kNumNativeSampleRates
-
1
]
;
static
const
int
kChunkSizeMs
=
10
;
}
;
class
StreamConfig
{
public
:
StreamConfig
(
int
sample_rate_hz
=
0
size_t
num_channels
=
0
bool
has_keyboard
=
false
)
:
sample_rate_hz_
(
sample_rate_hz
)
num_channels_
(
num_channels
)
has_keyboard_
(
has_keyboard
)
num_frames_
(
calculate_frames
(
sample_rate_hz
)
)
{
}
void
set_sample_rate_hz
(
int
value
)
{
sample_rate_hz_
=
value
;
num_frames_
=
calculate_frames
(
value
)
;
}
void
set_num_channels
(
size_t
value
)
{
num_channels_
=
value
;
}
void
set_has_keyboard
(
bool
value
)
{
has_keyboard_
=
value
;
}
int
sample_rate_hz
(
)
const
{
return
sample_rate_hz_
;
}
size_t
num_channels
(
)
const
{
return
num_channels_
;
}
bool
has_keyboard
(
)
const
{
return
has_keyboard_
;
}
size_t
num_frames
(
)
const
{
return
num_frames_
;
}
size_t
num_samples
(
)
const
{
return
num_channels_
*
num_frames_
;
}
bool
operator
=
=
(
const
StreamConfig
&
other
)
const
{
return
sample_rate_hz_
=
=
other
.
sample_rate_hz_
&
&
num_channels_
=
=
other
.
num_channels_
&
&
has_keyboard_
=
=
other
.
has_keyboard_
;
}
bool
operator
!
=
(
const
StreamConfig
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
private
:
static
size_t
calculate_frames
(
int
sample_rate_hz
)
{
return
static_cast
<
size_t
>
(
AudioProcessing
:
:
kChunkSizeMs
*
sample_rate_hz
/
1000
)
;
}
int
sample_rate_hz_
;
size_t
num_channels_
;
bool
has_keyboard_
;
size_t
num_frames_
;
}
;
class
ProcessingConfig
{
public
:
enum
StreamName
{
kInputStream
kOutputStream
kReverseInputStream
kReverseOutputStream
kNumStreamNames
}
;
const
StreamConfig
&
input_stream
(
)
const
{
return
streams
[
StreamName
:
:
kInputStream
]
;
}
const
StreamConfig
&
output_stream
(
)
const
{
return
streams
[
StreamName
:
:
kOutputStream
]
;
}
const
StreamConfig
&
reverse_input_stream
(
)
const
{
return
streams
[
StreamName
:
:
kReverseInputStream
]
;
}
const
StreamConfig
&
reverse_output_stream
(
)
const
{
return
streams
[
StreamName
:
:
kReverseOutputStream
]
;
}
StreamConfig
&
input_stream
(
)
{
return
streams
[
StreamName
:
:
kInputStream
]
;
}
StreamConfig
&
output_stream
(
)
{
return
streams
[
StreamName
:
:
kOutputStream
]
;
}
StreamConfig
&
reverse_input_stream
(
)
{
return
streams
[
StreamName
:
:
kReverseInputStream
]
;
}
StreamConfig
&
reverse_output_stream
(
)
{
return
streams
[
StreamName
:
:
kReverseOutputStream
]
;
}
bool
operator
=
=
(
const
ProcessingConfig
&
other
)
const
{
for
(
int
i
=
0
;
i
<
StreamName
:
:
kNumStreamNames
;
+
+
i
)
{
if
(
this
-
>
streams
[
i
]
!
=
other
.
streams
[
i
]
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
ProcessingConfig
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
StreamConfig
streams
[
StreamName
:
:
kNumStreamNames
]
;
}
;
class
EchoCancellation
{
public
:
virtual
int
Enable
(
bool
enable
)
=
0
;
virtual
bool
is_enabled
(
)
const
=
0
;
virtual
int
enable_drift_compensation
(
bool
enable
)
=
0
;
virtual
bool
is_drift_compensation_enabled
(
)
const
=
0
;
virtual
void
set_stream_drift_samples
(
int
drift
)
=
0
;
virtual
int
stream_drift_samples
(
)
const
=
0
;
enum
SuppressionLevel
{
kLowSuppression
kModerateSuppression
kHighSuppression
}
;
virtual
int
set_suppression_level
(
SuppressionLevel
level
)
=
0
;
virtual
SuppressionLevel
suppression_level
(
)
const
=
0
;
virtual
bool
stream_has_echo
(
)
const
=
0
;
virtual
int
enable_metrics
(
bool
enable
)
=
0
;
virtual
bool
are_metrics_enabled
(
)
const
=
0
;
struct
Metrics
{
AudioProcessing
:
:
Statistic
residual_echo_return_loss
;
AudioProcessing
:
:
Statistic
echo_return_loss
;
AudioProcessing
:
:
Statistic
echo_return_loss_enhancement
;
AudioProcessing
:
:
Statistic
a_nlp
;
float
divergent_filter_fraction
;
}
;
virtual
int
GetMetrics
(
Metrics
*
metrics
)
=
0
;
virtual
int
enable_delay_logging
(
bool
enable
)
=
0
;
virtual
bool
is_delay_logging_enabled
(
)
const
=
0
;
virtual
int
GetDelayMetrics
(
int
*
median
int
*
std
)
=
0
;
virtual
int
GetDelayMetrics
(
int
*
median
int
*
std
float
*
fraction_poor_delays
)
=
0
;
virtual
struct
AecCore
*
aec_core
(
)
const
=
0
;
protected
:
virtual
~
EchoCancellation
(
)
{
}
}
;
class
EchoControlMobile
{
public
:
virtual
int
Enable
(
bool
enable
)
=
0
;
virtual
bool
is_enabled
(
)
const
=
0
;
enum
RoutingMode
{
kQuietEarpieceOrHeadset
kEarpiece
kLoudEarpiece
kSpeakerphone
kLoudSpeakerphone
}
;
virtual
int
set_routing_mode
(
RoutingMode
mode
)
=
0
;
virtual
RoutingMode
routing_mode
(
)
const
=
0
;
virtual
int
enable_comfort_noise
(
bool
enable
)
=
0
;
virtual
bool
is_comfort_noise_enabled
(
)
const
=
0
;
virtual
int
SetEchoPath
(
const
void
*
echo_path
size_t
size_bytes
)
=
0
;
virtual
int
GetEchoPath
(
void
*
echo_path
size_t
size_bytes
)
const
=
0
;
static
size_t
echo_path_size_bytes
(
)
;
protected
:
virtual
~
EchoControlMobile
(
)
{
}
}
;
class
EchoControl
{
public
:
virtual
void
AnalyzeRender
(
AudioBuffer
*
render
)
=
0
;
virtual
void
AnalyzeCapture
(
AudioBuffer
*
capture
)
=
0
;
virtual
void
ProcessCapture
(
AudioBuffer
*
capture
bool
echo_path_change
)
=
0
;
struct
Metrics
{
double
echo_return_loss
;
double
echo_return_loss_enhancement
;
int
delay_ms
;
}
;
virtual
Metrics
GetMetrics
(
)
const
=
0
;
virtual
~
EchoControl
(
)
{
}
}
;
class
EchoControlFactory
{
public
:
virtual
std
:
:
unique_ptr
<
EchoControl
>
Create
(
int
sample_rate_hz
)
=
0
;
virtual
~
EchoControlFactory
(
)
=
default
;
}
;
class
GainControl
{
public
:
virtual
int
Enable
(
bool
enable
)
=
0
;
virtual
bool
is_enabled
(
)
const
=
0
;
virtual
int
set_stream_analog_level
(
int
level
)
=
0
;
virtual
int
stream_analog_level
(
)
=
0
;
enum
Mode
{
kAdaptiveAnalog
kAdaptiveDigital
kFixedDigital
}
;
virtual
int
set_mode
(
Mode
mode
)
=
0
;
virtual
Mode
mode
(
)
const
=
0
;
virtual
int
set_target_level_dbfs
(
int
level
)
=
0
;
virtual
int
target_level_dbfs
(
)
const
=
0
;
virtual
int
set_compression_gain_db
(
int
gain
)
=
0
;
virtual
int
compression_gain_db
(
)
const
=
0
;
virtual
int
enable_limiter
(
bool
enable
)
=
0
;
virtual
bool
is_limiter_enabled
(
)
const
=
0
;
virtual
int
set_analog_level_limits
(
int
minimum
int
maximum
)
=
0
;
virtual
int
analog_level_minimum
(
)
const
=
0
;
virtual
int
analog_level_maximum
(
)
const
=
0
;
virtual
bool
stream_is_saturated
(
)
const
=
0
;
protected
:
virtual
~
GainControl
(
)
{
}
}
;
class
HighPassFilter
{
public
:
virtual
int
Enable
(
bool
enable
)
=
0
;
virtual
bool
is_enabled
(
)
const
=
0
;
virtual
~
HighPassFilter
(
)
{
}
}
;
class
LevelEstimator
{
public
:
virtual
int
Enable
(
bool
enable
)
=
0
;
virtual
bool
is_enabled
(
)
const
=
0
;
virtual
int
RMS
(
)
=
0
;
protected
:
virtual
~
LevelEstimator
(
)
{
}
}
;
class
NoiseSuppression
{
public
:
virtual
int
Enable
(
bool
enable
)
=
0
;
virtual
bool
is_enabled
(
)
const
=
0
;
enum
Level
{
kLow
kModerate
kHigh
kVeryHigh
}
;
virtual
int
set_level
(
Level
level
)
=
0
;
virtual
Level
level
(
)
const
=
0
;
virtual
float
speech_probability
(
)
const
=
0
;
virtual
std
:
:
vector
<
float
>
NoiseEstimate
(
)
=
0
;
protected
:
virtual
~
NoiseSuppression
(
)
{
}
}
;
class
PostProcessing
{
public
:
virtual
void
Initialize
(
int
sample_rate_hz
int
num_channels
)
=
0
;
virtual
void
Process
(
AudioBuffer
*
audio
)
=
0
;
virtual
std
:
:
string
ToString
(
)
const
=
0
;
virtual
~
PostProcessing
(
)
{
}
}
;
class
VoiceDetection
{
public
:
virtual
int
Enable
(
bool
enable
)
=
0
;
virtual
bool
is_enabled
(
)
const
=
0
;
virtual
bool
stream_has_voice
(
)
const
=
0
;
virtual
int
set_stream_has_voice
(
bool
has_voice
)
=
0
;
enum
Likelihood
{
kVeryLowLikelihood
kLowLikelihood
kModerateLikelihood
kHighLikelihood
}
;
virtual
int
set_likelihood
(
Likelihood
likelihood
)
=
0
;
virtual
Likelihood
likelihood
(
)
const
=
0
;
virtual
int
set_frame_size_ms
(
int
size
)
=
0
;
virtual
int
frame_size_ms
(
)
const
=
0
;
protected
:
virtual
~
VoiceDetection
(
)
{
}
}
;
struct
EchoCanceller3Config
{
struct
Delay
{
size_t
default_delay
=
5
;
size_t
down_sampling_factor
=
4
;
size_t
num_filters
=
4
;
}
delay
;
struct
Erle
{
float
min
=
1
.
f
;
float
max_l
=
8
.
f
;
float
max_h
=
1
.
5f
;
}
erle
;
struct
EpStrength
{
float
lf
=
10
.
f
;
float
mf
=
10
.
f
;
float
hf
=
10
.
f
;
float
default_len
=
0
.
f
;
bool
echo_can_saturate
=
true
;
bool
bounded_erl
=
false
;
}
ep_strength
;
struct
Mask
{
float
m1
=
0
.
01f
;
float
m2
=
0
.
0001f
;
float
m3
=
0
.
01f
;
float
m4
=
0
.
1f
;
float
m5
=
0
.
3f
;
float
m6
=
0
.
0001f
;
float
m7
=
0
.
01f
;
float
m8
=
0
.
0001f
;
float
m9
=
0
.
1f
;
}
gain_mask
;
struct
EchoAudibility
{
float
low_render_limit
=
4
*
64
.
f
;
float
normal_render_limit
=
64
.
f
;
}
echo_audibility
;
struct
RenderLevels
{
float
active_render_limit
=
100
.
f
;
float
poor_excitation_render_limit
=
150
.
f
;
}
render_levels
;
struct
GainUpdates
{
struct
GainChanges
{
float
max_inc
;
float
max_dec
;
float
rate_inc
;
float
rate_dec
;
float
min_inc
;
float
min_dec
;
}
;
GainChanges
low_noise
=
{
3
.
f
3
.
f
1
.
5f
1
.
5f
1
.
5f
1
.
5f
}
;
GainChanges
normal
=
{
2
.
f
2
.
f
1
.
5f
1
.
5f
1
.
2f
1
.
2f
}
;
GainChanges
saturation
=
{
1
.
2f
1
.
2f
1
.
5f
1
.
5f
1
.
f
1
.
f
}
;
GainChanges
nonlinear
=
{
1
.
5f
1
.
5f
1
.
2f
1
.
2f
1
.
1f
1
.
1f
}
;
float
floor_first_increase
=
0
.
0001f
;
}
gain_updates
;
}
;
class
EchoCanceller3Factory
:
public
EchoControlFactory
{
public
:
EchoCanceller3Factory
(
)
;
EchoCanceller3Factory
(
const
EchoCanceller3Config
&
config
)
;
std
:
:
unique_ptr
<
EchoControl
>
Create
(
int
sample_rate_hz
)
override
;
private
:
EchoCanceller3Config
config_
;
}
;
}
#
endif
