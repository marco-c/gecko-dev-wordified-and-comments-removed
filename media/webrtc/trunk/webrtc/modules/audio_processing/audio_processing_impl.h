#
ifndef
WEBRTC_MODULES_AUDIO_PROCESSING_AUDIO_PROCESSING_IMPL_H_
#
define
WEBRTC_MODULES_AUDIO_PROCESSING_AUDIO_PROCESSING_IMPL_H_
#
include
<
list
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
criticalsection
.
h
"
#
include
"
webrtc
/
base
/
function_view
.
h
"
#
include
"
webrtc
/
base
/
gtest_prod_util
.
h
"
#
include
"
webrtc
/
base
/
ignore_wundef
.
h
"
#
include
"
webrtc
/
base
/
swap_queue
.
h
"
#
include
"
webrtc
/
base
/
thread_annotations
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
audio_buffer
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
render_queue_item_verifier
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
rms_level
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
file_wrapper
.
h
"
#
ifdef
WEBRTC_AUDIOPROC_DEBUG_DUMP
RTC_PUSH_IGNORING_WUNDEF
(
)
#
ifdef
WEBRTC_ANDROID_PLATFORM_BUILD
#
include
"
external
/
webrtc
/
webrtc
/
modules
/
audio_processing
/
debug
.
pb
.
h
"
#
else
#
include
"
webrtc
/
modules
/
audio_processing
/
debug
.
pb
.
h
"
#
endif
RTC_POP_IGNORING_WUNDEF
(
)
#
endif
namespace
webrtc
{
class
AgcManagerDirect
;
class
AudioConverter
;
class
NonlinearBeamformer
;
class
AudioProcessingImpl
:
public
AudioProcessing
{
public
:
explicit
AudioProcessingImpl
(
const
webrtc
:
:
Config
&
config
)
;
AudioProcessingImpl
(
const
webrtc
:
:
Config
&
config
NonlinearBeamformer
*
beamformer
)
;
~
AudioProcessingImpl
(
)
override
;
int
Initialize
(
)
override
;
int
Initialize
(
int
capture_input_sample_rate_hz
int
capture_output_sample_rate_hz
int
render_sample_rate_hz
ChannelLayout
capture_input_layout
ChannelLayout
capture_output_layout
ChannelLayout
render_input_layout
)
override
;
int
Initialize
(
const
ProcessingConfig
&
processing_config
)
override
;
void
ApplyConfig
(
const
AudioProcessing
:
:
Config
&
config
)
override
;
void
SetExtraOptions
(
const
webrtc
:
:
Config
&
config
)
override
;
void
UpdateHistogramsOnCallEnd
(
)
override
;
int
StartDebugRecording
(
const
char
filename
[
kMaxFilenameSize
]
int64_t
max_log_size_bytes
)
override
;
int
StartDebugRecording
(
FILE
*
handle
int64_t
max_log_size_bytes
)
override
;
int
StartDebugRecording
(
FILE
*
handle
)
override
;
int
StartDebugRecordingForPlatformFile
(
rtc
:
:
PlatformFile
handle
)
override
;
int
StopDebugRecording
(
)
override
;
int
ProcessStream
(
AudioFrame
*
frame
)
override
;
int
ProcessStream
(
const
float
*
const
*
src
size_t
samples_per_channel
int
input_sample_rate_hz
ChannelLayout
input_layout
int
output_sample_rate_hz
ChannelLayout
output_layout
float
*
const
*
dest
)
override
;
int
ProcessStream
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
float
*
const
*
dest
)
override
;
void
set_output_will_be_muted
(
bool
muted
)
override
;
int
set_stream_delay_ms
(
int
delay
)
override
;
void
set_delay_offset_ms
(
int
offset
)
override
;
int
delay_offset_ms
(
)
const
override
;
void
set_stream_key_pressed
(
bool
key_pressed
)
override
;
int
ProcessReverseStream
(
AudioFrame
*
frame
)
override
;
int
AnalyzeReverseStream
(
const
float
*
const
*
data
size_t
samples_per_channel
int
sample_rate_hz
ChannelLayout
layout
)
override
;
int
ProcessReverseStream
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
float
*
const
*
dest
)
override
;
int
proc_sample_rate_hz
(
)
const
override
;
int
proc_split_sample_rate_hz
(
)
const
override
;
size_t
num_input_channels
(
)
const
override
;
size_t
num_proc_channels
(
)
const
override
;
size_t
num_output_channels
(
)
const
override
;
size_t
num_reverse_channels
(
)
const
override
;
int
stream_delay_ms
(
)
const
override
;
bool
was_stream_delay_set
(
)
const
override
EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
AudioProcessingStatistics
GetStatistics
(
)
const
override
;
EchoCancellation
*
echo_cancellation
(
)
const
override
;
EchoControlMobile
*
echo_control_mobile
(
)
const
override
;
GainControl
*
gain_control
(
)
const
override
;
HighPassFilter
*
high_pass_filter
(
)
const
override
;
LevelEstimator
*
level_estimator
(
)
const
override
;
NoiseSuppression
*
noise_suppression
(
)
const
override
;
VoiceDetection
*
voice_detection
(
)
const
override
;
void
MutateConfig
(
rtc
:
:
FunctionView
<
void
(
AudioProcessing
:
:
Config
*
)
>
mutator
)
;
AudioProcessing
:
:
Config
GetConfig
(
)
const
;
protected
:
virtual
int
InitializeLocked
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
private
:
FRIEND_TEST_ALL_PREFIXES
(
ApmConfiguration
DefaultBehavior
)
;
FRIEND_TEST_ALL_PREFIXES
(
ApmConfiguration
ValidConfigBehavior
)
;
FRIEND_TEST_ALL_PREFIXES
(
ApmConfiguration
InValidConfigBehavior
)
;
struct
ApmPublicSubmodules
;
struct
ApmPrivateSubmodules
;
std
:
:
unique_ptr
<
HighPassFilter
>
high_pass_filter_impl_
;
class
ApmSubmoduleStates
{
public
:
ApmSubmoduleStates
(
)
;
bool
Update
(
bool
low_cut_filter_enabled
bool
echo_canceller_enabled
bool
mobile_echo_controller_enabled
bool
residual_echo_detector_enabled
bool
noise_suppressor_enabled
bool
intelligibility_enhancer_enabled
bool
beamformer_enabled
bool
adaptive_gain_controller_enabled
bool
level_controller_enabled
bool
echo_canceller3_enabled
bool
voice_activity_detector_enabled
bool
level_estimator_enabled
bool
transient_suppressor_enabled
)
;
bool
CaptureMultiBandSubModulesActive
(
)
const
;
bool
CaptureMultiBandProcessingActive
(
)
const
;
bool
RenderMultiBandSubModulesActive
(
)
const
;
bool
RenderMultiBandProcessingActive
(
)
const
;
private
:
bool
low_cut_filter_enabled_
=
false
;
bool
echo_canceller_enabled_
=
false
;
bool
mobile_echo_controller_enabled_
=
false
;
bool
residual_echo_detector_enabled_
=
false
;
bool
noise_suppressor_enabled_
=
false
;
bool
intelligibility_enhancer_enabled_
=
false
;
bool
beamformer_enabled_
=
false
;
bool
adaptive_gain_controller_enabled_
=
false
;
bool
level_controller_enabled_
=
false
;
bool
echo_canceller3_enabled_
=
false
;
bool
level_estimator_enabled_
=
false
;
bool
voice_activity_detector_enabled_
=
false
;
bool
transient_suppressor_enabled_
=
false
;
bool
first_update_
=
true
;
}
;
#
ifdef
WEBRTC_AUDIOPROC_DEBUG_DUMP
struct
ApmDebugDumpThreadState
{
ApmDebugDumpThreadState
(
)
;
~
ApmDebugDumpThreadState
(
)
;
std
:
:
unique_ptr
<
audioproc
:
:
Event
>
event_msg
;
std
:
:
string
event_str
;
std
:
:
string
last_serialized_config
;
}
;
struct
ApmDebugDumpState
{
ApmDebugDumpState
(
)
;
~
ApmDebugDumpState
(
)
;
int64_t
num_bytes_left_for_log_
=
-
1
;
std
:
:
unique_ptr
<
FileWrapper
>
debug_file
;
ApmDebugDumpThreadState
render
;
ApmDebugDumpThreadState
capture
;
}
;
#
endif
int
MaybeInitialize
(
const
ProcessingConfig
&
config
bool
force_initialization
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
int
MaybeInitializeRender
(
const
ProcessingConfig
&
processing_config
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
int
MaybeInitializeCapture
(
const
ProcessingConfig
&
processing_config
bool
force_initialization
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
bool
UpdateActiveSubmoduleStates
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
InitializeTransient
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
InitializeBeamformer
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
InitializeIntelligibility
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
int
InitializeLocked
(
const
ProcessingConfig
&
config
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
InitializeLevelController
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
InitializeResidualEchoDetector
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
InitializeLowCutFilter
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
InitializeEchoCanceller3
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
EmptyQueuedRenderAudio
(
)
;
void
AllocateRenderQueue
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
QueueRenderAudio
(
AudioBuffer
*
audio
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
int
ProcessCaptureStreamLocked
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
MaybeUpdateHistograms
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
int
AnalyzeReverseStreamLocked
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
int
ProcessRenderStreamLocked
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
#
ifdef
WEBRTC_AUDIOPROC_DEBUG_DUMP
static
int
WriteMessageToDebugFile
(
FileWrapper
*
debug_file
int64_t
*
filesize_limit_bytes
rtc
:
:
CriticalSection
*
crit_debug
ApmDebugDumpThreadState
*
debug_state
)
;
int
WriteInitMessage
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
int
WriteConfigMessage
(
bool
forced
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
rtc
:
:
CriticalSection
crit_debug_
;
ApmDebugDumpState
debug_dump_
;
#
endif
rtc
:
:
CriticalSection
crit_render_
ACQUIRED_BEFORE
(
crit_capture_
)
;
rtc
:
:
CriticalSection
crit_capture_
;
AudioProcessing
:
:
Config
config_
;
ApmSubmoduleStates
submodule_states_
;
std
:
:
unique_ptr
<
ApmPublicSubmodules
>
public_submodules_
;
std
:
:
unique_ptr
<
ApmPrivateSubmodules
>
private_submodules_
;
struct
ApmFormatState
{
ApmFormatState
(
)
:
api_format
(
{
{
{
kSampleRate16kHz
1
false
}
{
kSampleRate16kHz
1
false
}
{
kSampleRate16kHz
1
false
}
{
kSampleRate16kHz
1
false
}
}
}
)
render_processing_format
(
kSampleRate16kHz
1
)
{
}
ProcessingConfig
api_format
;
StreamConfig
render_processing_format
;
}
formats_
;
const
struct
ApmConstants
{
ApmConstants
(
int
agc_startup_min_volume
int
agc_clipped_level_min
bool
use_experimental_agc
)
:
agc_startup_min_volume
(
agc_startup_min_volume
)
agc_clipped_level_min
(
agc_clipped_level_min
)
use_experimental_agc
(
use_experimental_agc
)
{
}
int
agc_startup_min_volume
;
int
agc_clipped_level_min
;
bool
use_experimental_agc
;
}
constants_
;
struct
ApmCaptureState
{
ApmCaptureState
(
bool
transient_suppressor_enabled
const
std
:
:
vector
<
Point
>
&
array_geometry
SphericalPointf
target_direction
)
;
~
ApmCaptureState
(
)
;
int
aec_system_delay_jumps
;
int
delay_offset_ms
;
bool
was_stream_delay_set
;
int
last_stream_delay_ms
;
int
last_aec_system_delay_ms
;
int
stream_delay_jumps
;
bool
output_will_be_muted
;
bool
key_pressed
;
bool
transient_suppressor_enabled
;
std
:
:
vector
<
Point
>
array_geometry
;
SphericalPointf
target_direction
;
std
:
:
unique_ptr
<
AudioBuffer
>
capture_audio
;
StreamConfig
capture_processing_format
;
int
split_rate
;
}
capture_
GUARDED_BY
(
crit_capture_
)
;
struct
ApmCaptureNonLockedState
{
ApmCaptureNonLockedState
(
bool
beamformer_enabled
bool
intelligibility_enabled
)
:
capture_processing_format
(
kSampleRate16kHz
)
split_rate
(
kSampleRate16kHz
)
stream_delay_ms
(
0
)
beamformer_enabled
(
beamformer_enabled
)
intelligibility_enabled
(
intelligibility_enabled
)
{
}
StreamConfig
capture_processing_format
;
int
split_rate
;
int
stream_delay_ms
;
bool
beamformer_enabled
;
bool
intelligibility_enabled
;
bool
level_controller_enabled
=
false
;
bool
echo_canceller3_enabled
=
false
;
}
capture_nonlocked_
;
struct
ApmRenderState
{
ApmRenderState
(
)
;
~
ApmRenderState
(
)
;
std
:
:
unique_ptr
<
AudioConverter
>
render_converter
;
std
:
:
unique_ptr
<
AudioBuffer
>
render_audio
;
}
render_
GUARDED_BY
(
crit_render_
)
;
size_t
aec_render_queue_element_max_size_
GUARDED_BY
(
crit_render_
)
GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
vector
<
float
>
aec_render_queue_buffer_
GUARDED_BY
(
crit_render_
)
;
std
:
:
vector
<
float
>
aec_capture_queue_buffer_
GUARDED_BY
(
crit_capture_
)
;
size_t
aecm_render_queue_element_max_size_
GUARDED_BY
(
crit_render_
)
GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
vector
<
int16_t
>
aecm_render_queue_buffer_
GUARDED_BY
(
crit_render_
)
;
std
:
:
vector
<
int16_t
>
aecm_capture_queue_buffer_
GUARDED_BY
(
crit_capture_
)
;
size_t
agc_render_queue_element_max_size_
GUARDED_BY
(
crit_render_
)
GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
vector
<
int16_t
>
agc_render_queue_buffer_
GUARDED_BY
(
crit_render_
)
;
std
:
:
vector
<
int16_t
>
agc_capture_queue_buffer_
GUARDED_BY
(
crit_capture_
)
;
size_t
red_render_queue_element_max_size_
GUARDED_BY
(
crit_render_
)
GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
vector
<
float
>
red_render_queue_buffer_
GUARDED_BY
(
crit_render_
)
;
std
:
:
vector
<
float
>
red_capture_queue_buffer_
GUARDED_BY
(
crit_capture_
)
;
RmsLevel
capture_input_rms_
GUARDED_BY
(
crit_capture_
)
;
RmsLevel
capture_output_rms_
GUARDED_BY
(
crit_capture_
)
;
int
capture_rms_interval_counter_
GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
unique_ptr
<
SwapQueue
<
std
:
:
vector
<
float
>
RenderQueueItemVerifier
<
float
>
>
>
aec_render_signal_queue_
;
std
:
:
unique_ptr
<
SwapQueue
<
std
:
:
vector
<
int16_t
>
RenderQueueItemVerifier
<
int16_t
>
>
>
aecm_render_signal_queue_
;
std
:
:
unique_ptr
<
SwapQueue
<
std
:
:
vector
<
int16_t
>
RenderQueueItemVerifier
<
int16_t
>
>
>
agc_render_signal_queue_
;
std
:
:
unique_ptr
<
SwapQueue
<
std
:
:
vector
<
float
>
RenderQueueItemVerifier
<
float
>
>
>
red_render_signal_queue_
;
}
;
}
#
endif
