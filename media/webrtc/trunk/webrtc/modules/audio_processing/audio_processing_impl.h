#
ifndef
MODULES_AUDIO_PROCESSING_AUDIO_PROCESSING_IMPL_H_
#
define
MODULES_AUDIO_PROCESSING_AUDIO_PROCESSING_IMPL_H_
#
include
<
list
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
modules
/
audio_processing
/
audio_buffer
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
aec_dump
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
include
"
modules
/
audio_processing
/
render_queue_item_verifier
.
h
"
#
include
"
modules
/
audio_processing
/
rms_level
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
function_view
.
h
"
#
include
"
rtc_base
/
gtest_prod_util
.
h
"
#
include
"
rtc_base
/
ignore_wundef
.
h
"
#
include
"
rtc_base
/
protobuf_utils
.
h
"
#
include
"
rtc_base
/
swap_queue
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
system_wrappers
/
include
/
file_wrapper
.
h
"
namespace
webrtc
{
class
AudioConverter
;
class
NonlinearBeamformer
;
class
AudioProcessingImpl
:
public
AudioProcessing
{
public
:
explicit
AudioProcessingImpl
(
const
webrtc
:
:
Config
&
config
)
;
AudioProcessingImpl
(
const
webrtc
:
:
Config
&
config
std
:
:
unique_ptr
<
PostProcessing
>
capture_post_processor
std
:
:
unique_ptr
<
EchoControlFactory
>
echo_control_factory
NonlinearBeamformer
*
beamformer
)
;
~
AudioProcessingImpl
(
)
override
;
int
Initialize
(
)
override
;
int
Initialize
(
int
capture_input_sample_rate_hz
int
capture_output_sample_rate_hz
int
render_sample_rate_hz
ChannelLayout
capture_input_layout
ChannelLayout
capture_output_layout
ChannelLayout
render_input_layout
)
override
;
int
Initialize
(
const
ProcessingConfig
&
processing_config
)
override
;
void
ApplyConfig
(
const
AudioProcessing
:
:
Config
&
config
)
override
;
void
SetExtraOptions
(
const
webrtc
:
:
Config
&
config
)
override
;
void
UpdateHistogramsOnCallEnd
(
)
override
;
void
AttachAecDump
(
std
:
:
unique_ptr
<
AecDump
>
aec_dump
)
override
;
void
DetachAecDump
(
)
override
;
int
ProcessStream
(
AudioFrame
*
frame
)
override
;
int
ProcessStream
(
const
float
*
const
*
src
size_t
samples_per_channel
int
input_sample_rate_hz
ChannelLayout
input_layout
int
output_sample_rate_hz
ChannelLayout
output_layout
float
*
const
*
dest
)
override
;
int
ProcessStream
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
float
*
const
*
dest
)
override
;
void
set_output_will_be_muted
(
bool
muted
)
override
;
int
set_stream_delay_ms
(
int
delay
)
override
;
void
set_delay_offset_ms
(
int
offset
)
override
;
int
delay_offset_ms
(
)
const
override
;
void
set_stream_key_pressed
(
bool
key_pressed
)
override
;
int
ProcessReverseStream
(
AudioFrame
*
frame
)
override
;
int
AnalyzeReverseStream
(
const
float
*
const
*
data
size_t
samples_per_channel
int
sample_rate_hz
ChannelLayout
layout
)
override
;
int
ProcessReverseStream
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
float
*
const
*
dest
)
override
;
int
proc_sample_rate_hz
(
)
const
override
;
int
proc_split_sample_rate_hz
(
)
const
override
;
size_t
num_input_channels
(
)
const
override
;
size_t
num_proc_channels
(
)
const
override
;
size_t
num_output_channels
(
)
const
override
;
size_t
num_reverse_channels
(
)
const
override
;
int
stream_delay_ms
(
)
const
override
;
bool
was_stream_delay_set
(
)
const
override
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
AudioProcessingStatistics
GetStatistics
(
)
const
override
;
AudioProcessingStats
GetStatistics
(
bool
has_remote_tracks
)
const
override
;
EchoCancellation
*
echo_cancellation
(
)
const
override
;
EchoControlMobile
*
echo_control_mobile
(
)
const
override
;
GainControl
*
gain_control
(
)
const
override
;
HighPassFilter
*
high_pass_filter
(
)
const
override
;
LevelEstimator
*
level_estimator
(
)
const
override
;
NoiseSuppression
*
noise_suppression
(
)
const
override
;
VoiceDetection
*
voice_detection
(
)
const
override
;
void
MutateConfig
(
rtc
:
:
FunctionView
<
void
(
AudioProcessing
:
:
Config
*
)
>
mutator
)
;
AudioProcessing
:
:
Config
GetConfig
(
)
const
override
;
protected
:
virtual
int
InitializeLocked
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
private
:
FRIEND_TEST_ALL_PREFIXES
(
ApmConfiguration
DefaultBehavior
)
;
FRIEND_TEST_ALL_PREFIXES
(
ApmConfiguration
ValidConfigBehavior
)
;
FRIEND_TEST_ALL_PREFIXES
(
ApmConfiguration
InValidConfigBehavior
)
;
struct
ApmPublicSubmodules
;
struct
ApmPrivateSubmodules
;
std
:
:
unique_ptr
<
HighPassFilter
>
high_pass_filter_impl_
;
std
:
:
unique_ptr
<
EchoControlFactory
>
echo_control_factory_
;
class
ApmSubmoduleStates
{
public
:
explicit
ApmSubmoduleStates
(
bool
capture_post_processor_enabled
)
;
bool
Update
(
bool
low_cut_filter_enabled
bool
echo_canceller_enabled
bool
mobile_echo_controller_enabled
bool
residual_echo_detector_enabled
bool
noise_suppressor_enabled
bool
intelligibility_enhancer_enabled
bool
beamformer_enabled
bool
adaptive_gain_controller_enabled
bool
gain_controller2_enabled
bool
level_controller_enabled
bool
echo_controller_enabled
bool
voice_activity_detector_enabled
bool
level_estimator_enabled
bool
transient_suppressor_enabled
)
;
bool
CaptureMultiBandSubModulesActive
(
)
const
;
bool
CaptureMultiBandProcessingActive
(
)
const
;
bool
CaptureFullBandProcessingActive
(
)
const
;
bool
RenderMultiBandSubModulesActive
(
)
const
;
bool
RenderMultiBandProcessingActive
(
)
const
;
private
:
const
bool
capture_post_processor_enabled_
=
false
;
bool
low_cut_filter_enabled_
=
false
;
bool
echo_canceller_enabled_
=
false
;
bool
mobile_echo_controller_enabled_
=
false
;
bool
residual_echo_detector_enabled_
=
false
;
bool
noise_suppressor_enabled_
=
false
;
bool
intelligibility_enhancer_enabled_
=
false
;
bool
beamformer_enabled_
=
false
;
bool
adaptive_gain_controller_enabled_
=
false
;
bool
gain_controller2_enabled_
=
false
;
bool
level_controller_enabled_
=
false
;
bool
echo_controller_enabled_
=
false
;
bool
level_estimator_enabled_
=
false
;
bool
voice_activity_detector_enabled_
=
false
;
bool
transient_suppressor_enabled_
=
false
;
bool
first_update_
=
true
;
}
;
int
MaybeInitialize
(
const
ProcessingConfig
&
config
bool
force_initialization
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
int
MaybeInitializeRender
(
const
ProcessingConfig
&
processing_config
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
int
MaybeInitializeCapture
(
const
ProcessingConfig
&
processing_config
bool
force_initialization
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
bool
UpdateActiveSubmoduleStates
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
InitializeTransient
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
InitializeBeamformer
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
InitializeIntelligibility
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
int
InitializeLocked
(
const
ProcessingConfig
&
config
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
InitializeLevelController
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
InitializeResidualEchoDetector
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
InitializeLowCutFilter
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
InitializeEchoController
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
InitializeGainController2
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
InitializePostProcessor
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
EmptyQueuedRenderAudio
(
)
;
void
AllocateRenderQueue
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
crit_capture_
)
;
void
QueueBandedRenderAudio
(
AudioBuffer
*
audio
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
void
QueueNonbandedRenderAudio
(
AudioBuffer
*
audio
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
int
ProcessCaptureStreamLocked
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
MaybeUpdateHistograms
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
int
AnalyzeReverseStreamLocked
(
const
float
*
const
*
src
const
StreamConfig
&
input_config
const
StreamConfig
&
output_config
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
int
ProcessRenderStreamLocked
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_render_
)
;
void
WriteAecDumpConfigMessage
(
bool
forced
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
RecordUnprocessedCaptureStream
(
const
float
*
const
*
capture_stream
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
RecordUnprocessedCaptureStream
(
const
AudioFrame
&
capture_frame
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
RecordProcessedCaptureStream
(
const
float
*
const
*
processed_capture_stream
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
RecordProcessedCaptureStream
(
const
AudioFrame
&
processed_capture_frame
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
void
RecordAudioProcessingState
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_capture_
)
;
std
:
:
unique_ptr
<
AecDump
>
aec_dump_
;
InternalAPMConfig
apm_config_for_aec_dump_
RTC_GUARDED_BY
(
crit_capture_
)
;
rtc
:
:
CriticalSection
crit_render_
RTC_ACQUIRED_BEFORE
(
crit_capture_
)
;
rtc
:
:
CriticalSection
crit_capture_
;
AudioProcessing
:
:
Config
config_
;
ApmSubmoduleStates
submodule_states_
;
std
:
:
unique_ptr
<
ApmPublicSubmodules
>
public_submodules_
;
std
:
:
unique_ptr
<
ApmPrivateSubmodules
>
private_submodules_
;
struct
ApmFormatState
{
ApmFormatState
(
)
:
api_format
(
{
{
{
kSampleRate16kHz
1
false
}
{
kSampleRate16kHz
1
false
}
{
kSampleRate16kHz
1
false
}
{
kSampleRate16kHz
1
false
}
}
}
)
render_processing_format
(
kSampleRate16kHz
1
)
{
}
ProcessingConfig
api_format
;
StreamConfig
render_processing_format
;
}
formats_
;
const
struct
ApmConstants
{
ApmConstants
(
int
agc_startup_min_volume
int
agc_clipped_level_min
bool
use_experimental_agc
)
:
agc_startup_min_volume
(
agc_startup_min_volume
)
agc_clipped_level_min
(
agc_clipped_level_min
)
use_experimental_agc
(
use_experimental_agc
)
{
}
int
agc_startup_min_volume
;
int
agc_clipped_level_min
;
bool
use_experimental_agc
;
}
constants_
;
struct
ApmCaptureState
{
ApmCaptureState
(
bool
transient_suppressor_enabled
const
std
:
:
vector
<
Point
>
&
array_geometry
SphericalPointf
target_direction
)
;
~
ApmCaptureState
(
)
;
int
aec_system_delay_jumps
;
int
delay_offset_ms
;
bool
was_stream_delay_set
;
int
last_stream_delay_ms
;
int
last_aec_system_delay_ms
;
int
stream_delay_jumps
;
bool
output_will_be_muted
;
bool
key_pressed
;
bool
transient_suppressor_enabled
;
std
:
:
vector
<
Point
>
array_geometry
;
SphericalPointf
target_direction
;
std
:
:
unique_ptr
<
AudioBuffer
>
capture_audio
;
StreamConfig
capture_processing_format
;
int
split_rate
;
bool
echo_path_gain_change
;
}
capture_
RTC_GUARDED_BY
(
crit_capture_
)
;
struct
ApmCaptureNonLockedState
{
ApmCaptureNonLockedState
(
bool
beamformer_enabled
bool
intelligibility_enabled
)
:
capture_processing_format
(
kSampleRate16kHz
)
split_rate
(
kSampleRate16kHz
)
stream_delay_ms
(
0
)
beamformer_enabled
(
beamformer_enabled
)
intelligibility_enabled
(
intelligibility_enabled
)
{
}
StreamConfig
capture_processing_format
;
int
split_rate
;
int
stream_delay_ms
;
bool
beamformer_enabled
;
bool
intelligibility_enabled
;
bool
level_controller_enabled
=
false
;
bool
echo_controller_enabled
=
false
;
}
capture_nonlocked_
;
struct
ApmRenderState
{
ApmRenderState
(
)
;
~
ApmRenderState
(
)
;
std
:
:
unique_ptr
<
AudioConverter
>
render_converter
;
std
:
:
unique_ptr
<
AudioBuffer
>
render_audio
;
}
render_
RTC_GUARDED_BY
(
crit_render_
)
;
size_t
aec_render_queue_element_max_size_
RTC_GUARDED_BY
(
crit_render_
)
RTC_GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
vector
<
float
>
aec_render_queue_buffer_
RTC_GUARDED_BY
(
crit_render_
)
;
std
:
:
vector
<
float
>
aec_capture_queue_buffer_
RTC_GUARDED_BY
(
crit_capture_
)
;
size_t
aecm_render_queue_element_max_size_
RTC_GUARDED_BY
(
crit_render_
)
RTC_GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
vector
<
int16_t
>
aecm_render_queue_buffer_
RTC_GUARDED_BY
(
crit_render_
)
;
std
:
:
vector
<
int16_t
>
aecm_capture_queue_buffer_
RTC_GUARDED_BY
(
crit_capture_
)
;
size_t
agc_render_queue_element_max_size_
RTC_GUARDED_BY
(
crit_render_
)
RTC_GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
vector
<
int16_t
>
agc_render_queue_buffer_
RTC_GUARDED_BY
(
crit_render_
)
;
std
:
:
vector
<
int16_t
>
agc_capture_queue_buffer_
RTC_GUARDED_BY
(
crit_capture_
)
;
size_t
red_render_queue_element_max_size_
RTC_GUARDED_BY
(
crit_render_
)
RTC_GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
vector
<
float
>
red_render_queue_buffer_
RTC_GUARDED_BY
(
crit_render_
)
;
std
:
:
vector
<
float
>
red_capture_queue_buffer_
RTC_GUARDED_BY
(
crit_capture_
)
;
RmsLevel
capture_input_rms_
RTC_GUARDED_BY
(
crit_capture_
)
;
RmsLevel
capture_output_rms_
RTC_GUARDED_BY
(
crit_capture_
)
;
int
capture_rms_interval_counter_
RTC_GUARDED_BY
(
crit_capture_
)
=
0
;
std
:
:
unique_ptr
<
SwapQueue
<
std
:
:
vector
<
float
>
RenderQueueItemVerifier
<
float
>
>
>
aec_render_signal_queue_
;
std
:
:
unique_ptr
<
SwapQueue
<
std
:
:
vector
<
int16_t
>
RenderQueueItemVerifier
<
int16_t
>
>
>
aecm_render_signal_queue_
;
std
:
:
unique_ptr
<
SwapQueue
<
std
:
:
vector
<
int16_t
>
RenderQueueItemVerifier
<
int16_t
>
>
>
agc_render_signal_queue_
;
std
:
:
unique_ptr
<
SwapQueue
<
std
:
:
vector
<
float
>
RenderQueueItemVerifier
<
float
>
>
>
red_render_signal_queue_
;
}
;
}
#
endif
