#
include
"
webrtc
/
modules
/
audio_processing
/
residual_echo_detector
.
h
"
#
include
<
algorithm
>
#
include
<
numeric
>
#
include
"
webrtc
/
modules
/
audio_processing
/
audio_buffer
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
metrics
.
h
"
namespace
{
float
Power
(
rtc
:
:
ArrayView
<
const
float
>
input
)
{
return
std
:
:
inner_product
(
input
.
begin
(
)
input
.
end
(
)
input
.
begin
(
)
0
.
f
)
;
}
constexpr
size_t
kLookbackFrames
=
650
;
constexpr
size_t
kRenderBufferSize
=
30
;
constexpr
float
kAlpha
=
0
.
001f
;
constexpr
size_t
kAggregationBufferSize
=
10
*
100
;
}
namespace
webrtc
{
ResidualEchoDetector
:
:
ResidualEchoDetector
(
)
:
render_buffer_
(
kRenderBufferSize
)
render_power_
(
kLookbackFrames
)
render_power_mean_
(
kLookbackFrames
)
render_power_std_dev_
(
kLookbackFrames
)
covariances_
(
kLookbackFrames
)
recent_likelihood_max_
(
kAggregationBufferSize
)
{
}
ResidualEchoDetector
:
:
~
ResidualEchoDetector
(
)
=
default
;
void
ResidualEchoDetector
:
:
AnalyzeRenderAudio
(
rtc
:
:
ArrayView
<
const
float
>
render_audio
)
{
if
(
render_buffer_
.
Size
(
)
=
=
0
)
{
frames_since_zero_buffer_size_
=
0
;
}
else
if
(
frames_since_zero_buffer_size_
>
=
kRenderBufferSize
)
{
render_buffer_
.
Pop
(
)
;
frames_since_zero_buffer_size_
=
0
;
}
+
+
frames_since_zero_buffer_size_
;
float
power
=
Power
(
render_audio
)
;
render_buffer_
.
Push
(
power
)
;
}
void
ResidualEchoDetector
:
:
AnalyzeCaptureAudio
(
rtc
:
:
ArrayView
<
const
float
>
capture_audio
)
{
if
(
first_process_call_
)
{
render_buffer_
.
Clear
(
)
;
first_process_call_
=
false
;
}
const
rtc
:
:
Optional
<
float
>
buffered_render_power
=
render_buffer_
.
Pop
(
)
;
if
(
!
buffered_render_power
)
{
return
;
}
render_statistics_
.
Update
(
*
buffered_render_power
)
;
RTC_DCHECK_LT
(
next_insertion_index_
kLookbackFrames
)
;
render_power_
[
next_insertion_index_
]
=
*
buffered_render_power
;
render_power_mean_
[
next_insertion_index_
]
=
render_statistics_
.
mean
(
)
;
render_power_std_dev_
[
next_insertion_index_
]
=
render_statistics_
.
std_deviation
(
)
;
const
float
capture_power
=
Power
(
capture_audio
)
;
capture_statistics_
.
Update
(
capture_power
)
;
const
float
capture_mean
=
capture_statistics_
.
mean
(
)
;
const
float
capture_std_deviation
=
capture_statistics_
.
std_deviation
(
)
;
echo_likelihood_
=
0
.
f
;
for
(
size_t
delay
=
0
;
delay
<
covariances_
.
size
(
)
;
+
+
delay
)
{
const
size_t
read_index
=
(
kLookbackFrames
+
next_insertion_index_
-
delay
)
%
kLookbackFrames
;
RTC_DCHECK_LT
(
read_index
render_power_
.
size
(
)
)
;
covariances_
[
delay
]
.
Update
(
capture_power
capture_mean
capture_std_deviation
render_power_
[
read_index
]
render_power_mean_
[
read_index
]
render_power_std_dev_
[
read_index
]
)
;
echo_likelihood_
=
std
:
:
max
(
echo_likelihood_
covariances_
[
delay
]
.
normalized_cross_correlation
(
)
)
;
}
reliability_
=
(
1
.
0f
-
kAlpha
)
*
reliability_
+
kAlpha
*
1
.
0f
;
echo_likelihood_
*
=
reliability_
;
int
echo_percentage
=
static_cast
<
int
>
(
echo_likelihood_
*
100
)
;
RTC_HISTOGRAM_COUNTS
(
"
WebRTC
.
Audio
.
ResidualEchoDetector
.
EchoLikelihood
"
echo_percentage
0
100
100
)
;
recent_likelihood_max_
.
Update
(
echo_likelihood_
)
;
+
+
next_insertion_index_
;
next_insertion_index_
%
=
kLookbackFrames
;
}
void
ResidualEchoDetector
:
:
Initialize
(
)
{
render_buffer_
.
Clear
(
)
;
std
:
:
fill
(
render_power_
.
begin
(
)
render_power_
.
end
(
)
0
.
f
)
;
std
:
:
fill
(
render_power_mean_
.
begin
(
)
render_power_mean_
.
end
(
)
0
.
f
)
;
std
:
:
fill
(
render_power_std_dev_
.
begin
(
)
render_power_std_dev_
.
end
(
)
0
.
f
)
;
render_statistics_
.
Clear
(
)
;
capture_statistics_
.
Clear
(
)
;
recent_likelihood_max_
.
Clear
(
)
;
for
(
auto
&
cov
:
covariances_
)
{
cov
.
Clear
(
)
;
}
echo_likelihood_
=
0
.
f
;
next_insertion_index_
=
0
;
reliability_
=
0
.
f
;
}
void
ResidualEchoDetector
:
:
PackRenderAudioBuffer
(
AudioBuffer
*
audio
std
:
:
vector
<
float
>
*
packed_buffer
)
{
RTC_DCHECK_GE
(
160
audio
-
>
num_frames_per_band
(
)
)
;
packed_buffer
-
>
clear
(
)
;
packed_buffer
-
>
insert
(
packed_buffer
-
>
end
(
)
audio
-
>
split_bands_const_f
(
0
)
[
kBand0To8kHz
]
(
audio
-
>
split_bands_const_f
(
0
)
[
kBand0To8kHz
]
+
audio
-
>
num_frames_per_band
(
)
)
)
;
}
}
