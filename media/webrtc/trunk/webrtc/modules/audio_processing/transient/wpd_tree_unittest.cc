#
include
"
webrtc
/
modules
/
audio_processing
/
transient
/
wpd_tree
.
h
"
#
include
<
sstream
>
#
include
<
string
>
#
include
"
testing
/
gtest
/
include
/
gtest
/
gtest
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
transient
/
daubechies_8_wavelet_coeffs
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
transient
/
file_utils
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
file_wrapper
.
h
"
#
include
"
webrtc
/
test
/
testsupport
/
fileutils
.
h
"
namespace
webrtc
{
TEST
(
WPDTreeTest
Construction
)
{
const
size_t
kTestBufferSize
=
100
;
const
int
kLevels
=
5
;
const
int
kExpectedNumberOfNodes
=
(
1
<
<
(
kLevels
+
1
)
)
-
1
;
float
test_buffer
[
kTestBufferSize
]
;
memset
(
test_buffer
0
.
f
kTestBufferSize
*
sizeof
(
*
test_buffer
)
)
;
float
test_coefficients
[
]
=
{
1
.
f
2
.
f
3
.
f
4
.
f
5
.
f
}
;
const
size_t
kTestCoefficientsLength
=
sizeof
(
test_coefficients
)
/
sizeof
(
test_coefficients
[
0
]
)
;
WPDTree
tree
(
kTestBufferSize
test_coefficients
test_coefficients
kTestCoefficientsLength
kLevels
)
;
ASSERT_EQ
(
kExpectedNumberOfNodes
tree
.
num_nodes
(
)
)
;
int
nodes_at_level
=
0
;
for
(
int
level
=
0
;
level
<
=
kLevels
;
+
+
level
)
{
nodes_at_level
=
1
<
<
level
;
for
(
int
i
=
0
;
i
<
nodes_at_level
;
+
+
i
)
{
ASSERT_TRUE
(
NULL
!
=
tree
.
NodeAt
(
level
i
)
)
;
}
EXPECT_EQ
(
NULL
tree
.
NodeAt
(
level
-
1
)
)
;
EXPECT_EQ
(
NULL
tree
.
NodeAt
(
level
-
12
)
)
;
EXPECT_EQ
(
NULL
tree
.
NodeAt
(
level
nodes_at_level
)
)
;
EXPECT_EQ
(
NULL
tree
.
NodeAt
(
level
nodes_at_level
+
5
)
)
;
}
EXPECT_EQ
(
NULL
tree
.
NodeAt
(
-
1
0
)
)
;
EXPECT_EQ
(
NULL
tree
.
NodeAt
(
-
12
0
)
)
;
EXPECT_EQ
(
NULL
tree
.
NodeAt
(
kLevels
+
1
0
)
)
;
EXPECT_EQ
(
NULL
tree
.
NodeAt
(
kLevels
+
5
0
)
)
;
EXPECT_EQ
(
0
tree
.
Update
(
test_buffer
kTestBufferSize
)
)
;
EXPECT_EQ
(
-
1
tree
.
Update
(
NULL
kTestBufferSize
)
)
;
EXPECT_EQ
(
-
1
tree
.
Update
(
test_buffer
kTestBufferSize
-
1
)
)
;
}
TEST
(
WPDTreeTest
CorrectnessBasedOnMatlabFiles
)
{
const
size_t
kTestBufferSize
=
160
;
const
int
kLevels
=
3
;
const
int
kLeaves
=
1
<
<
kLevels
;
const
size_t
kLeavesSamples
=
kTestBufferSize
>
>
kLevels
;
WPDTree
tree
(
kTestBufferSize
kDaubechies8HighPassCoefficients
kDaubechies8LowPassCoefficients
kDaubechies8CoefficientsLength
kLevels
)
;
rtc
:
:
scoped_ptr
<
FileWrapper
>
matlab_files_data
[
kLeaves
]
;
rtc
:
:
scoped_ptr
<
FileWrapper
>
out_files_data
[
kLeaves
]
;
for
(
int
i
=
0
;
i
<
kLeaves
;
+
+
i
)
{
matlab_files_data
[
i
]
.
reset
(
FileWrapper
:
:
Create
(
)
)
;
std
:
:
ostringstream
matlab_stream
;
matlab_stream
<
<
"
audio_processing
/
transient
/
wpd
"
<
<
i
;
std
:
:
string
matlab_string
=
test
:
:
ResourcePath
(
matlab_stream
.
str
(
)
"
dat
"
)
;
matlab_files_data
[
i
]
-
>
OpenFile
(
matlab_string
.
c_str
(
)
true
false
false
)
;
bool
file_opened
=
matlab_files_data
[
i
]
-
>
Open
(
)
;
ASSERT_TRUE
(
file_opened
)
<
<
"
File
could
not
be
opened
.
\
n
"
<
<
matlab_string
;
out_files_data
[
i
]
.
reset
(
FileWrapper
:
:
Create
(
)
)
;
std
:
:
ostringstream
out_stream
;
out_stream
<
<
test
:
:
OutputPath
(
)
<
<
"
wpd_
"
<
<
i
<
<
"
.
out
"
;
std
:
:
string
out_string
=
out_stream
.
str
(
)
;
out_files_data
[
i
]
-
>
OpenFile
(
out_string
.
c_str
(
)
false
false
false
)
;
file_opened
=
out_files_data
[
i
]
-
>
Open
(
)
;
ASSERT_TRUE
(
file_opened
)
<
<
"
File
could
not
be
opened
.
\
n
"
<
<
out_string
;
}
std
:
:
string
test_file_name
=
test
:
:
ResourcePath
(
"
audio_processing
/
transient
/
ajm
-
macbook
-
1
-
spke16m
"
"
pcm
"
)
;
rtc
:
:
scoped_ptr
<
FileWrapper
>
test_file
(
FileWrapper
:
:
Create
(
)
)
;
test_file
-
>
OpenFile
(
test_file_name
.
c_str
(
)
true
false
false
)
;
bool
file_opened
=
test_file
-
>
Open
(
)
;
ASSERT_TRUE
(
file_opened
)
<
<
"
File
could
not
be
opened
.
\
n
"
<
<
test_file_name
;
float
test_buffer
[
kTestBufferSize
]
;
const
size_t
kMaxFramesToTest
=
100
;
const
float
kTolerance
=
0
.
03f
;
size_t
frames_read
=
0
;
size_t
file_samples_read
=
ReadInt16FromFileToFloatBuffer
(
test_file
.
get
(
)
kTestBufferSize
test_buffer
)
;
while
(
file_samples_read
>
0
&
&
frames_read
<
kMaxFramesToTest
)
{
+
+
frames_read
;
if
(
file_samples_read
<
kTestBufferSize
)
{
for
(
size_t
i
=
file_samples_read
;
i
<
kTestBufferSize
;
+
+
i
)
{
test_buffer
[
i
]
=
0
.
0
;
}
}
tree
.
Update
(
test_buffer
kTestBufferSize
)
;
double
matlab_buffer
[
kTestBufferSize
]
;
for
(
int
i
=
0
;
i
<
kLeaves
;
+
+
i
)
{
size_t
matlab_samples_read
=
ReadDoubleBufferFromFile
(
matlab_files_data
[
i
]
.
get
(
)
kLeavesSamples
matlab_buffer
)
;
ASSERT_EQ
(
kLeavesSamples
matlab_samples_read
)
<
<
"
Matlab
test
files
are
malformed
.
\
n
"
<
<
"
File
:
3_
"
<
<
i
;
const
float
*
node_data
=
tree
.
NodeAt
(
kLevels
i
)
-
>
data
(
)
;
for
(
size_t
j
=
0
;
j
<
kLeavesSamples
;
+
+
j
)
{
EXPECT_NEAR
(
matlab_buffer
[
j
]
node_data
[
j
]
kTolerance
)
<
<
"
\
nLeaf
:
"
<
<
i
<
<
"
\
nSample
:
"
<
<
j
<
<
"
\
nFrame
:
"
<
<
frames_read
-
1
;
}
WriteFloatBufferToFile
(
out_files_data
[
i
]
.
get
(
)
kLeavesSamples
node_data
)
;
}
file_samples_read
=
ReadInt16FromFileToFloatBuffer
(
test_file
.
get
(
)
kTestBufferSize
test_buffer
)
;
}
for
(
int
i
=
0
;
i
<
kLeaves
;
+
+
i
)
{
matlab_files_data
[
i
]
-
>
CloseFile
(
)
;
out_files_data
[
i
]
-
>
CloseFile
(
)
;
}
test_file
-
>
CloseFile
(
)
;
}
}
