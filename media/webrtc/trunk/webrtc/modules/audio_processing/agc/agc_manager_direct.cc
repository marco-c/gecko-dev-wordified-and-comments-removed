#
include
"
modules
/
audio_processing
/
agc
/
agc_manager_direct
.
h
"
#
include
<
cmath
>
#
ifdef
WEBRTC_AGC_DEBUG_DUMP
#
include
<
cstdio
>
#
endif
#
include
"
modules
/
audio_processing
/
agc
/
gain_map_internal
.
h
"
#
include
"
modules
/
audio_processing
/
gain_control_impl
.
h
"
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_minmax
.
h
"
#
include
"
system_wrappers
/
include
/
metrics
.
h
"
namespace
webrtc
{
namespace
{
const
int
kClippedLevelStep
=
15
;
const
float
kClippedRatioThreshold
=
0
.
1f
;
const
int
kClippedWaitFrames
=
300
;
const
int
kLevelQuantizationSlack
=
25
;
const
int
kDefaultCompressionGain
=
7
;
const
int
kMaxCompressionGain
=
12
;
const
int
kMinCompressionGain
=
2
;
const
float
kCompressionGainStep
=
0
.
05f
;
const
int
kMaxMicLevel
=
255
;
static_assert
(
kGainMapSize
>
kMaxMicLevel
"
gain
map
too
small
"
)
;
const
int
kMinMicLevel
=
12
;
const
int
kMaxResidualGainChange
=
15
;
const
int
kSurplusCompressionGain
=
6
;
int
ClampLevel
(
int
mic_level
)
{
return
rtc
:
:
SafeClamp
(
mic_level
kMinMicLevel
kMaxMicLevel
)
;
}
int
LevelFromGainError
(
int
gain_error
int
level
)
{
RTC_DCHECK_GE
(
level
0
)
;
RTC_DCHECK_LE
(
level
kMaxMicLevel
)
;
if
(
gain_error
=
=
0
)
{
return
level
;
}
int
new_level
=
level
;
if
(
gain_error
>
0
)
{
while
(
kGainMap
[
new_level
]
-
kGainMap
[
level
]
<
gain_error
&
&
new_level
<
kMaxMicLevel
)
{
+
+
new_level
;
}
}
else
{
while
(
kGainMap
[
new_level
]
-
kGainMap
[
level
]
>
gain_error
&
&
new_level
>
kMinMicLevel
)
{
-
-
new_level
;
}
}
return
new_level
;
}
}
class
DebugFile
{
#
ifdef
WEBRTC_AGC_DEBUG_DUMP
public
:
explicit
DebugFile
(
const
char
*
filename
)
:
file_
(
fopen
(
filename
"
wb
"
)
)
{
RTC_DCHECK
(
file_
)
;
}
~
DebugFile
(
)
{
fclose
(
file_
)
;
}
void
Write
(
const
int16_t
*
data
size_t
length_samples
)
{
fwrite
(
data
1
length_samples
*
sizeof
(
int16_t
)
file_
)
;
}
private
:
FILE
*
file_
;
#
else
public
:
explicit
DebugFile
(
const
char
*
filename
)
{
}
~
DebugFile
(
)
{
}
void
Write
(
const
int16_t
*
data
size_t
length_samples
)
{
}
#
endif
}
;
AgcManagerDirect
:
:
AgcManagerDirect
(
GainControl
*
gctrl
VolumeCallbacks
*
volume_callbacks
int
startup_min_level
int
clipped_level_min
)
:
agc_
(
new
Agc
(
)
)
gctrl_
(
gctrl
)
volume_callbacks_
(
volume_callbacks
)
frames_since_clipped_
(
kClippedWaitFrames
)
level_
(
0
)
max_level_
(
kMaxMicLevel
)
max_compression_gain_
(
kMaxCompressionGain
)
target_compression_
(
kDefaultCompressionGain
)
compression_
(
target_compression_
)
compression_accumulator_
(
compression_
)
capture_muted_
(
false
)
check_volume_on_next_process_
(
true
)
startup_
(
true
)
startup_min_level_
(
ClampLevel
(
startup_min_level
)
)
clipped_level_min_
(
clipped_level_min
)
file_preproc_
(
new
DebugFile
(
"
agc_preproc
.
pcm
"
)
)
file_postproc_
(
new
DebugFile
(
"
agc_postproc
.
pcm
"
)
)
{
}
AgcManagerDirect
:
:
AgcManagerDirect
(
Agc
*
agc
GainControl
*
gctrl
VolumeCallbacks
*
volume_callbacks
int
startup_min_level
int
clipped_level_min
)
:
agc_
(
agc
)
gctrl_
(
gctrl
)
volume_callbacks_
(
volume_callbacks
)
frames_since_clipped_
(
kClippedWaitFrames
)
level_
(
0
)
max_level_
(
kMaxMicLevel
)
max_compression_gain_
(
kMaxCompressionGain
)
target_compression_
(
kDefaultCompressionGain
)
compression_
(
target_compression_
)
compression_accumulator_
(
compression_
)
capture_muted_
(
false
)
check_volume_on_next_process_
(
true
)
startup_
(
true
)
startup_min_level_
(
ClampLevel
(
startup_min_level
)
)
clipped_level_min_
(
clipped_level_min
)
file_preproc_
(
new
DebugFile
(
"
agc_preproc
.
pcm
"
)
)
file_postproc_
(
new
DebugFile
(
"
agc_postproc
.
pcm
"
)
)
{
}
AgcManagerDirect
:
:
~
AgcManagerDirect
(
)
{
}
int
AgcManagerDirect
:
:
Initialize
(
)
{
max_level_
=
kMaxMicLevel
;
max_compression_gain_
=
kMaxCompressionGain
;
target_compression_
=
kDefaultCompressionGain
;
compression_
=
target_compression_
;
compression_accumulator_
=
compression_
;
capture_muted_
=
false
;
check_volume_on_next_process_
=
true
;
if
(
gctrl_
-
>
set_mode
(
GainControl
:
:
kFixedDigital
)
!
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
set_mode
(
GainControl
:
:
kFixedDigital
)
failed
.
"
;
return
-
1
;
}
if
(
gctrl_
-
>
set_target_level_dbfs
(
2
)
!
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
set_target_level_dbfs
(
2
)
failed
.
"
;
return
-
1
;
}
if
(
gctrl_
-
>
set_compression_gain_db
(
kDefaultCompressionGain
)
!
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
set_compression_gain_db
(
kDefaultCompressionGain
)
failed
.
"
;
return
-
1
;
}
if
(
gctrl_
-
>
enable_limiter
(
true
)
!
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
enable_limiter
(
true
)
failed
.
"
;
return
-
1
;
}
return
0
;
}
void
AgcManagerDirect
:
:
AnalyzePreProcess
(
int16_t
*
audio
int
num_channels
size_t
samples_per_channel
)
{
size_t
length
=
num_channels
*
samples_per_channel
;
if
(
capture_muted_
)
{
return
;
}
file_preproc_
-
>
Write
(
audio
length
)
;
if
(
frames_since_clipped_
<
kClippedWaitFrames
)
{
+
+
frames_since_clipped_
;
return
;
}
float
clipped_ratio
=
agc_
-
>
AnalyzePreproc
(
audio
length
)
;
if
(
clipped_ratio
>
kClippedRatioThreshold
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
[
agc
]
Clipping
detected
.
clipped_ratio
=
"
<
<
clipped_ratio
;
SetMaxLevel
(
std
:
:
max
(
clipped_level_min_
max_level_
-
kClippedLevelStep
)
)
;
RTC_HISTOGRAM_BOOLEAN
(
"
WebRTC
.
Audio
.
AgcClippingAdjustmentAllowed
"
level_
-
kClippedLevelStep
>
=
clipped_level_min_
)
;
if
(
level_
>
clipped_level_min_
)
{
SetLevel
(
std
:
:
max
(
clipped_level_min_
level_
-
kClippedLevelStep
)
)
;
agc_
-
>
Reset
(
)
;
}
frames_since_clipped_
=
0
;
}
}
void
AgcManagerDirect
:
:
Process
(
const
int16_t
*
audio
size_t
length
int
sample_rate_hz
)
{
if
(
capture_muted_
)
{
return
;
}
if
(
check_volume_on_next_process_
)
{
check_volume_on_next_process_
=
false
;
CheckVolumeAndReset
(
)
;
}
if
(
agc_
-
>
Process
(
audio
length
sample_rate_hz
)
!
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Agc
:
:
Process
failed
"
;
RTC_NOTREACHED
(
)
;
}
UpdateGain
(
)
;
UpdateCompressor
(
)
;
file_postproc_
-
>
Write
(
audio
length
)
;
}
void
AgcManagerDirect
:
:
SetLevel
(
int
new_level
)
{
int
voe_level
=
volume_callbacks_
-
>
GetMicVolume
(
)
;
if
(
voe_level
<
0
)
{
return
;
}
if
(
voe_level
=
=
0
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
[
agc
]
VolumeCallbacks
returned
level
=
0
taking
no
action
.
"
;
return
;
}
if
(
voe_level
>
kMaxMicLevel
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
VolumeCallbacks
returned
an
invalid
level
=
"
<
<
voe_level
;
return
;
}
if
(
voe_level
>
level_
+
kLevelQuantizationSlack
|
|
voe_level
<
level_
-
kLevelQuantizationSlack
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
[
agc
]
Mic
volume
was
manually
adjusted
.
Updating
"
<
<
"
stored
level
from
"
<
<
level_
<
<
"
to
"
<
<
voe_level
;
level_
=
voe_level
;
if
(
level_
>
max_level_
)
{
SetMaxLevel
(
level_
)
;
}
agc_
-
>
Reset
(
)
;
return
;
}
new_level
=
std
:
:
min
(
new_level
max_level_
)
;
if
(
new_level
=
=
level_
)
{
return
;
}
volume_callbacks_
-
>
SetMicVolume
(
new_level
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
[
agc
]
voe_level
=
"
<
<
voe_level
<
<
"
"
<
<
"
level_
=
"
<
<
level_
<
<
"
"
<
<
"
new_level
=
"
<
<
new_level
;
level_
=
new_level
;
}
void
AgcManagerDirect
:
:
SetMaxLevel
(
int
level
)
{
RTC_DCHECK_GE
(
level
clipped_level_min_
)
;
max_level_
=
level
;
max_compression_gain_
=
kMaxCompressionGain
+
std
:
:
floor
(
(
1
.
f
*
kMaxMicLevel
-
max_level_
)
/
(
kMaxMicLevel
-
clipped_level_min_
)
*
kSurplusCompressionGain
+
0
.
5f
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
[
agc
]
max_level_
=
"
<
<
max_level_
<
<
"
max_compression_gain_
=
"
<
<
max_compression_gain_
;
}
void
AgcManagerDirect
:
:
SetCaptureMuted
(
bool
muted
)
{
if
(
capture_muted_
=
=
muted
)
{
return
;
}
capture_muted_
=
muted
;
if
(
!
muted
)
{
check_volume_on_next_process_
=
true
;
}
}
float
AgcManagerDirect
:
:
voice_probability
(
)
{
return
agc_
-
>
voice_probability
(
)
;
}
int
AgcManagerDirect
:
:
CheckVolumeAndReset
(
)
{
int
level
=
volume_callbacks_
-
>
GetMicVolume
(
)
;
if
(
level
<
0
)
{
return
-
1
;
}
if
(
level
=
=
0
&
&
!
startup_
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
[
agc
]
VolumeCallbacks
returned
level
=
0
taking
no
action
.
"
;
return
0
;
}
if
(
level
>
kMaxMicLevel
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
VolumeCallbacks
returned
an
invalid
level
=
"
<
<
level
;
return
-
1
;
}
RTC_LOG
(
LS_INFO
)
<
<
"
[
agc
]
Initial
GetMicVolume
(
)
=
"
<
<
level
;
int
minLevel
=
startup_
?
startup_min_level_
:
kMinMicLevel
;
if
(
level
<
minLevel
)
{
level
=
minLevel
;
RTC_LOG
(
LS_INFO
)
<
<
"
[
agc
]
Initial
volume
too
low
raising
to
"
<
<
level
;
volume_callbacks_
-
>
SetMicVolume
(
level
)
;
}
agc_
-
>
Reset
(
)
;
level_
=
level
;
startup_
=
false
;
return
0
;
}
void
AgcManagerDirect
:
:
UpdateGain
(
)
{
int
rms_error
=
0
;
if
(
!
agc_
-
>
GetRmsErrorDb
(
&
rms_error
)
)
{
return
;
}
rms_error
+
=
kMinCompressionGain
;
int
raw_compression
=
rtc
:
:
SafeClamp
(
rms_error
kMinCompressionGain
max_compression_gain_
)
;
if
(
(
raw_compression
=
=
max_compression_gain_
&
&
target_compression_
=
=
max_compression_gain_
-
1
)
|
|
(
raw_compression
=
=
kMinCompressionGain
&
&
target_compression_
=
=
kMinCompressionGain
+
1
)
)
{
target_compression_
=
raw_compression
;
}
else
{
target_compression_
=
(
raw_compression
-
target_compression_
)
/
2
+
target_compression_
;
}
const
int
residual_gain
=
rtc
:
:
SafeClamp
(
rms_error
-
raw_compression
-
kMaxResidualGainChange
kMaxResidualGainChange
)
;
RTC_LOG
(
LS_INFO
)
<
<
"
[
agc
]
rms_error
=
"
<
<
rms_error
<
<
"
"
<
<
"
target_compression
=
"
<
<
target_compression_
<
<
"
"
<
<
"
residual_gain
=
"
<
<
residual_gain
;
if
(
residual_gain
=
=
0
)
return
;
int
old_level
=
level_
;
SetLevel
(
LevelFromGainError
(
residual_gain
level_
)
)
;
if
(
old_level
!
=
level_
)
{
RTC_HISTOGRAM_COUNTS_LINEAR
(
"
WebRTC
.
Audio
.
AgcSetLevel
"
level_
1
kMaxMicLevel
50
)
;
}
}
void
AgcManagerDirect
:
:
UpdateCompressor
(
)
{
if
(
compression_
=
=
target_compression_
)
{
return
;
}
if
(
target_compression_
>
compression_
)
{
compression_accumulator_
+
=
kCompressionGainStep
;
}
else
{
compression_accumulator_
-
=
kCompressionGainStep
;
}
int
new_compression
=
compression_
;
int
nearest_neighbor
=
std
:
:
floor
(
compression_accumulator_
+
0
.
5
)
;
if
(
std
:
:
fabs
(
compression_accumulator_
-
nearest_neighbor
)
<
kCompressionGainStep
/
2
)
{
new_compression
=
nearest_neighbor
;
}
if
(
new_compression
!
=
compression_
)
{
compression_
=
new_compression
;
compression_accumulator_
=
new_compression
;
if
(
gctrl_
-
>
set_compression_gain_db
(
compression_
)
!
=
0
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
set_compression_gain_db
(
"
<
<
compression_
<
<
"
)
failed
.
"
;
}
}
}
}
