#
ifndef
MODULES_AUDIO_PROCESSING_BEAMFORMER_ARRAY_UTIL_H_
#
define
MODULES_AUDIO_PROCESSING_BEAMFORMER_ARRAY_UTIL_H_
#
include
<
cmath
>
#
include
<
vector
>
#
include
"
api
/
optional
.
h
"
namespace
webrtc
{
template
<
typename
T
>
struct
CartesianPoint
{
CartesianPoint
(
)
{
c
[
0
]
=
0
;
c
[
1
]
=
0
;
c
[
2
]
=
0
;
}
CartesianPoint
(
T
x
T
y
T
z
)
{
c
[
0
]
=
x
;
c
[
1
]
=
y
;
c
[
2
]
=
z
;
}
T
x
(
)
const
{
return
c
[
0
]
;
}
T
y
(
)
const
{
return
c
[
1
]
;
}
T
z
(
)
const
{
return
c
[
2
]
;
}
T
c
[
3
]
;
}
;
using
Point
=
CartesianPoint
<
float
>
;
Point
PairDirection
(
const
Point
&
a
const
Point
&
b
)
;
float
DotProduct
(
const
Point
&
a
const
Point
&
b
)
;
Point
CrossProduct
(
const
Point
&
a
const
Point
&
b
)
;
bool
AreParallel
(
const
Point
&
a
const
Point
&
b
)
;
bool
ArePerpendicular
(
const
Point
&
a
const
Point
&
b
)
;
float
GetMinimumSpacing
(
const
std
:
:
vector
<
Point
>
&
array_geometry
)
;
rtc
:
:
Optional
<
Point
>
GetDirectionIfLinear
(
const
std
:
:
vector
<
Point
>
&
array_geometry
)
;
rtc
:
:
Optional
<
Point
>
GetNormalIfPlanar
(
const
std
:
:
vector
<
Point
>
&
array_geometry
)
;
rtc
:
:
Optional
<
Point
>
GetArrayNormalIfExists
(
const
std
:
:
vector
<
Point
>
&
array_geometry
)
;
Point
AzimuthToPoint
(
float
azimuth
)
;
template
<
typename
T
>
float
Distance
(
CartesianPoint
<
T
>
a
CartesianPoint
<
T
>
b
)
{
return
std
:
:
sqrt
(
(
a
.
x
(
)
-
b
.
x
(
)
)
*
(
a
.
x
(
)
-
b
.
x
(
)
)
+
(
a
.
y
(
)
-
b
.
y
(
)
)
*
(
a
.
y
(
)
-
b
.
y
(
)
)
+
(
a
.
z
(
)
-
b
.
z
(
)
)
*
(
a
.
z
(
)
-
b
.
z
(
)
)
)
;
}
template
<
typename
T
>
struct
SphericalPoint
{
SphericalPoint
(
T
azimuth
T
elevation
T
radius
)
{
s
[
0
]
=
azimuth
;
s
[
1
]
=
elevation
;
s
[
2
]
=
radius
;
}
T
azimuth
(
)
const
{
return
s
[
0
]
;
}
T
elevation
(
)
const
{
return
s
[
1
]
;
}
T
distance
(
)
const
{
return
s
[
2
]
;
}
T
s
[
3
]
;
}
;
using
SphericalPointf
=
SphericalPoint
<
float
>
;
template
<
typename
T
>
T
DegreesToRadians
(
T
angle_degrees
)
{
return
M_PI
*
angle_degrees
/
180
;
}
template
<
typename
T
>
T
RadiansToDegrees
(
T
angle_radians
)
{
return
180
*
angle_radians
/
M_PI
;
}
}
#
endif
