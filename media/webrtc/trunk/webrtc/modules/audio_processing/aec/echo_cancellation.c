#
include
"
webrtc
/
modules
/
audio_processing
/
aec
/
echo_cancellation
.
h
"
#
include
<
math
.
h
>
#
ifdef
WEBRTC_AEC_DEBUG_DUMP
#
include
<
stdio
.
h
>
#
endif
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
webrtc
/
common_audio
/
ring_buffer
.
h
"
#
include
"
webrtc
/
common_audio
/
signal_processing
/
include
/
signal_processing_library
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
aec
/
aec_core
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
aec
/
aec_resampler
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
aec
/
echo_cancellation_internal
.
h
"
#
include
"
webrtc
/
typedefs
.
h
"
#
if
defined
(
WEBRTC_CHROMIUM_BUILD
)
&
&
defined
(
WEBRTC_MAC
)
#
define
WEBRTC_UNTRUSTED_DELAY
#
endif
#
if
defined
(
WEBRTC_UNTRUSTED_DELAY
)
&
&
defined
(
WEBRTC_MAC
)
static
const
int
kDelayDiffOffsetSamples
=
-
160
;
#
else
static
const
int
kDelayDiffOffsetSamples
=
0
;
#
endif
#
if
defined
(
WEBRTC_MAC
)
static
const
int
kFixedDelayMs
=
20
;
#
else
static
const
int
kFixedDelayMs
=
50
;
#
endif
#
if
!
defined
(
WEBRTC_UNTRUSTED_DELAY
)
static
const
int
kMinTrustedDelayMs
=
20
;
#
endif
static
const
int
kMaxTrustedDelayMs
=
500
;
#
define
MAX_RESAMP_LEN
(
5
*
FRAME_LEN
)
static
const
int
kMaxBufSizeStart
=
62
;
static
const
int
sampMsNb
=
8
;
static
const
int
initCheck
=
42
;
#
ifdef
WEBRTC_AEC_DEBUG_DUMP
int
webrtc_aec_instance_count
=
0
;
#
endif
static
void
EstBufDelayNormal
(
Aec
*
aecInst
)
;
static
void
EstBufDelayExtended
(
Aec
*
aecInst
)
;
static
int
ProcessNormal
(
Aec
*
self
const
float
*
const
*
near
size_t
num_bands
float
*
const
*
out
size_t
num_samples
int16_t
reported_delay_ms
int32_t
skew
)
;
static
void
ProcessExtended
(
Aec
*
self
const
float
*
const
*
near
size_t
num_bands
float
*
const
*
out
size_t
num_samples
int16_t
reported_delay_ms
int32_t
skew
)
;
void
*
WebRtcAec_Create
(
)
{
Aec
*
aecpc
=
malloc
(
sizeof
(
Aec
)
)
;
if
(
!
aecpc
)
{
return
NULL
;
}
aecpc
-
>
aec
=
WebRtcAec_CreateAec
(
)
;
if
(
!
aecpc
-
>
aec
)
{
WebRtcAec_Free
(
aecpc
)
;
return
NULL
;
}
aecpc
-
>
resampler
=
WebRtcAec_CreateResampler
(
)
;
if
(
!
aecpc
-
>
resampler
)
{
WebRtcAec_Free
(
aecpc
)
;
return
NULL
;
}
aecpc
-
>
far_pre_buf
=
WebRtc_CreateBuffer
(
PART_LEN2
+
kResamplerBufferSize
sizeof
(
float
)
)
;
if
(
!
aecpc
-
>
far_pre_buf
)
{
WebRtcAec_Free
(
aecpc
)
;
return
NULL
;
}
aecpc
-
>
initFlag
=
0
;
#
ifdef
WEBRTC_AEC_DEBUG_DUMP
{
char
filename
[
64
]
;
sprintf
(
filename
"
aec_buf
%
d
.
dat
"
webrtc_aec_instance_count
)
;
aecpc
-
>
bufFile
=
fopen
(
filename
"
wb
"
)
;
sprintf
(
filename
"
aec_skew
%
d
.
dat
"
webrtc_aec_instance_count
)
;
aecpc
-
>
skewFile
=
fopen
(
filename
"
wb
"
)
;
sprintf
(
filename
"
aec_delay
%
d
.
dat
"
webrtc_aec_instance_count
)
;
aecpc
-
>
delayFile
=
fopen
(
filename
"
wb
"
)
;
webrtc_aec_instance_count
+
+
;
}
#
endif
return
aecpc
;
}
void
WebRtcAec_Free
(
void
*
aecInst
)
{
Aec
*
aecpc
=
aecInst
;
if
(
aecpc
=
=
NULL
)
{
return
;
}
WebRtc_FreeBuffer
(
aecpc
-
>
far_pre_buf
)
;
#
ifdef
WEBRTC_AEC_DEBUG_DUMP
fclose
(
aecpc
-
>
bufFile
)
;
fclose
(
aecpc
-
>
skewFile
)
;
fclose
(
aecpc
-
>
delayFile
)
;
#
endif
WebRtcAec_FreeAec
(
aecpc
-
>
aec
)
;
WebRtcAec_FreeResampler
(
aecpc
-
>
resampler
)
;
free
(
aecpc
)
;
}
int32_t
WebRtcAec_Init
(
void
*
aecInst
int32_t
sampFreq
int32_t
scSampFreq
)
{
Aec
*
aecpc
=
aecInst
;
AecConfig
aecConfig
;
if
(
sampFreq
!
=
8000
&
&
sampFreq
!
=
16000
&
&
sampFreq
!
=
32000
&
&
sampFreq
!
=
48000
)
{
return
AEC_BAD_PARAMETER_ERROR
;
}
aecpc
-
>
sampFreq
=
sampFreq
;
if
(
scSampFreq
<
1
|
|
scSampFreq
>
96000
)
{
return
AEC_BAD_PARAMETER_ERROR
;
}
aecpc
-
>
scSampFreq
=
scSampFreq
;
if
(
WebRtcAec_InitAec
(
aecpc
-
>
aec
aecpc
-
>
sampFreq
)
=
=
-
1
)
{
return
AEC_UNSPECIFIED_ERROR
;
}
if
(
WebRtcAec_InitResampler
(
aecpc
-
>
resampler
aecpc
-
>
scSampFreq
)
=
=
-
1
)
{
return
AEC_UNSPECIFIED_ERROR
;
}
WebRtc_InitBuffer
(
aecpc
-
>
far_pre_buf
)
;
WebRtc_MoveReadPtr
(
aecpc
-
>
far_pre_buf
-
PART_LEN
)
;
aecpc
-
>
initFlag
=
initCheck
;
if
(
aecpc
-
>
sampFreq
=
=
32000
|
|
aecpc
-
>
sampFreq
=
=
48000
)
{
aecpc
-
>
splitSampFreq
=
16000
;
}
else
{
aecpc
-
>
splitSampFreq
=
sampFreq
;
}
aecpc
-
>
delayCtr
=
0
;
aecpc
-
>
sampFactor
=
(
aecpc
-
>
scSampFreq
*
1
.
0f
)
/
aecpc
-
>
splitSampFreq
;
aecpc
-
>
rate_factor
=
aecpc
-
>
splitSampFreq
/
8000
;
aecpc
-
>
sum
=
0
;
aecpc
-
>
counter
=
0
;
aecpc
-
>
checkBuffSize
=
1
;
aecpc
-
>
firstVal
=
0
;
aecpc
-
>
startup_phase
=
WebRtcAec_extended_filter_enabled
(
aecpc
-
>
aec
)
|
|
!
WebRtcAec_delay_agnostic_enabled
(
aecpc
-
>
aec
)
;
aecpc
-
>
bufSizeStart
=
0
;
aecpc
-
>
checkBufSizeCtr
=
0
;
aecpc
-
>
msInSndCardBuf
=
0
;
aecpc
-
>
filtDelay
=
-
1
;
aecpc
-
>
timeForDelayChange
=
0
;
aecpc
-
>
knownDelay
=
0
;
aecpc
-
>
lastDelayDiff
=
0
;
aecpc
-
>
skewFrCtr
=
0
;
aecpc
-
>
resample
=
kAecFalse
;
aecpc
-
>
highSkewCtr
=
0
;
aecpc
-
>
skew
=
0
;
aecpc
-
>
farend_started
=
0
;
aecConfig
.
nlpMode
=
kAecNlpModerate
;
aecConfig
.
skewMode
=
kAecFalse
;
aecConfig
.
metricsMode
=
kAecFalse
;
aecConfig
.
delay_logging
=
kAecFalse
;
if
(
WebRtcAec_set_config
(
aecpc
aecConfig
)
=
=
-
1
)
{
return
AEC_UNSPECIFIED_ERROR
;
}
return
0
;
}
int32_t
WebRtcAec_GetBufferFarendError
(
void
*
aecInst
const
float
*
farend
size_t
nrOfSamples
)
{
Aec
*
aecpc
=
aecInst
;
if
(
!
farend
)
return
AEC_NULL_POINTER_ERROR
;
if
(
aecpc
-
>
initFlag
!
=
initCheck
)
return
AEC_UNINITIALIZED_ERROR
;
if
(
nrOfSamples
!
=
80
&
&
nrOfSamples
!
=
160
)
return
AEC_BAD_PARAMETER_ERROR
;
return
0
;
}
int32_t
WebRtcAec_BufferFarend
(
void
*
aecInst
const
float
*
farend
size_t
nrOfSamples
)
{
Aec
*
aecpc
=
aecInst
;
size_t
newNrOfSamples
=
nrOfSamples
;
float
new_farend
[
MAX_RESAMP_LEN
]
;
const
float
*
farend_ptr
=
farend
;
int32_t
error_code
=
WebRtcAec_GetBufferFarendError
(
aecInst
farend
nrOfSamples
)
;
if
(
error_code
!
=
0
)
return
error_code
;
if
(
aecpc
-
>
skewMode
=
=
kAecTrue
&
&
aecpc
-
>
resample
=
=
kAecTrue
)
{
WebRtcAec_ResampleLinear
(
aecpc
-
>
resampler
farend
nrOfSamples
aecpc
-
>
skew
new_farend
&
newNrOfSamples
)
;
farend_ptr
=
new_farend
;
}
aecpc
-
>
farend_started
=
1
;
WebRtcAec_SetSystemDelay
(
aecpc
-
>
aec
WebRtcAec_system_delay
(
aecpc
-
>
aec
)
+
(
int
)
newNrOfSamples
)
;
WebRtc_WriteBuffer
(
aecpc
-
>
far_pre_buf
farend_ptr
newNrOfSamples
)
;
while
(
WebRtc_available_read
(
aecpc
-
>
far_pre_buf
)
>
=
PART_LEN2
)
{
{
float
*
ptmp
=
NULL
;
float
tmp
[
PART_LEN2
]
;
WebRtc_ReadBuffer
(
aecpc
-
>
far_pre_buf
(
void
*
*
)
&
ptmp
tmp
PART_LEN2
)
;
WebRtcAec_BufferFarendPartition
(
aecpc
-
>
aec
ptmp
)
;
}
WebRtc_MoveReadPtr
(
aecpc
-
>
far_pre_buf
-
PART_LEN
)
;
}
return
0
;
}
int32_t
WebRtcAec_Process
(
void
*
aecInst
const
float
*
const
*
nearend
size_t
num_bands
float
*
const
*
out
size_t
nrOfSamples
int16_t
msInSndCardBuf
int32_t
skew
)
{
Aec
*
aecpc
=
aecInst
;
int32_t
retVal
=
0
;
if
(
out
=
=
NULL
)
{
return
AEC_NULL_POINTER_ERROR
;
}
if
(
aecpc
-
>
initFlag
!
=
initCheck
)
{
return
AEC_UNINITIALIZED_ERROR
;
}
if
(
nrOfSamples
!
=
80
&
&
nrOfSamples
!
=
160
)
{
return
AEC_BAD_PARAMETER_ERROR
;
}
if
(
msInSndCardBuf
<
0
)
{
msInSndCardBuf
=
0
;
retVal
=
AEC_BAD_PARAMETER_WARNING
;
}
else
if
(
msInSndCardBuf
>
kMaxTrustedDelayMs
)
{
retVal
=
AEC_BAD_PARAMETER_WARNING
;
}
if
(
WebRtcAec_extended_filter_enabled
(
aecpc
-
>
aec
)
)
{
ProcessExtended
(
aecpc
nearend
num_bands
out
nrOfSamples
msInSndCardBuf
skew
)
;
}
else
{
retVal
=
ProcessNormal
(
aecpc
nearend
num_bands
out
nrOfSamples
msInSndCardBuf
skew
)
;
}
#
ifdef
WEBRTC_AEC_DEBUG_DUMP
{
int16_t
far_buf_size_ms
=
(
int16_t
)
(
WebRtcAec_system_delay
(
aecpc
-
>
aec
)
/
(
sampMsNb
*
aecpc
-
>
rate_factor
)
)
;
(
void
)
fwrite
(
&
far_buf_size_ms
2
1
aecpc
-
>
bufFile
)
;
(
void
)
fwrite
(
&
aecpc
-
>
knownDelay
sizeof
(
aecpc
-
>
knownDelay
)
1
aecpc
-
>
delayFile
)
;
}
#
endif
return
retVal
;
}
int
WebRtcAec_set_config
(
void
*
handle
AecConfig
config
)
{
Aec
*
self
=
(
Aec
*
)
handle
;
if
(
self
-
>
initFlag
!
=
initCheck
)
{
return
AEC_UNINITIALIZED_ERROR
;
}
if
(
config
.
skewMode
!
=
kAecFalse
&
&
config
.
skewMode
!
=
kAecTrue
)
{
return
AEC_BAD_PARAMETER_ERROR
;
}
self
-
>
skewMode
=
config
.
skewMode
;
if
(
config
.
nlpMode
!
=
kAecNlpConservative
&
&
config
.
nlpMode
!
=
kAecNlpModerate
&
&
config
.
nlpMode
!
=
kAecNlpAggressive
)
{
return
AEC_BAD_PARAMETER_ERROR
;
}
if
(
config
.
metricsMode
!
=
kAecFalse
&
&
config
.
metricsMode
!
=
kAecTrue
)
{
return
AEC_BAD_PARAMETER_ERROR
;
}
if
(
config
.
delay_logging
!
=
kAecFalse
&
&
config
.
delay_logging
!
=
kAecTrue
)
{
return
AEC_BAD_PARAMETER_ERROR
;
}
WebRtcAec_SetConfigCore
(
self
-
>
aec
config
.
nlpMode
config
.
metricsMode
config
.
delay_logging
)
;
return
0
;
}
int
WebRtcAec_get_echo_status
(
void
*
handle
int
*
status
)
{
Aec
*
self
=
(
Aec
*
)
handle
;
if
(
status
=
=
NULL
)
{
return
AEC_NULL_POINTER_ERROR
;
}
if
(
self
-
>
initFlag
!
=
initCheck
)
{
return
AEC_UNINITIALIZED_ERROR
;
}
*
status
=
WebRtcAec_echo_state
(
self
-
>
aec
)
;
return
0
;
}
int
WebRtcAec_GetMetrics
(
void
*
handle
AecMetrics
*
metrics
)
{
const
float
kUpWeight
=
0
.
7f
;
float
dtmp
;
int
stmp
;
Aec
*
self
=
(
Aec
*
)
handle
;
Stats
erl
;
Stats
erle
;
Stats
a_nlp
;
if
(
handle
=
=
NULL
)
{
return
-
1
;
}
if
(
metrics
=
=
NULL
)
{
return
AEC_NULL_POINTER_ERROR
;
}
if
(
self
-
>
initFlag
!
=
initCheck
)
{
return
AEC_UNINITIALIZED_ERROR
;
}
WebRtcAec_GetEchoStats
(
self
-
>
aec
&
erl
&
erle
&
a_nlp
)
;
metrics
-
>
erl
.
instant
=
(
int
)
erl
.
instant
;
if
(
(
erl
.
himean
>
kOffsetLevel
)
&
&
(
erl
.
average
>
kOffsetLevel
)
)
{
dtmp
=
kUpWeight
*
erl
.
himean
+
(
1
-
kUpWeight
)
*
erl
.
average
;
metrics
-
>
erl
.
average
=
(
int
)
dtmp
;
}
else
{
metrics
-
>
erl
.
average
=
kOffsetLevel
;
}
metrics
-
>
erl
.
max
=
(
int
)
erl
.
max
;
if
(
erl
.
min
<
(
kOffsetLevel
*
(
-
1
)
)
)
{
metrics
-
>
erl
.
min
=
(
int
)
erl
.
min
;
}
else
{
metrics
-
>
erl
.
min
=
kOffsetLevel
;
}
metrics
-
>
erle
.
instant
=
(
int
)
erle
.
instant
;
if
(
(
erle
.
himean
>
kOffsetLevel
)
&
&
(
erle
.
average
>
kOffsetLevel
)
)
{
dtmp
=
kUpWeight
*
erle
.
himean
+
(
1
-
kUpWeight
)
*
erle
.
average
;
metrics
-
>
erle
.
average
=
(
int
)
dtmp
;
}
else
{
metrics
-
>
erle
.
average
=
kOffsetLevel
;
}
metrics
-
>
erle
.
max
=
(
int
)
erle
.
max
;
if
(
erle
.
min
<
(
kOffsetLevel
*
(
-
1
)
)
)
{
metrics
-
>
erle
.
min
=
(
int
)
erle
.
min
;
}
else
{
metrics
-
>
erle
.
min
=
kOffsetLevel
;
}
if
(
(
metrics
-
>
erl
.
average
>
kOffsetLevel
)
&
&
(
metrics
-
>
erle
.
average
>
kOffsetLevel
)
)
{
stmp
=
metrics
-
>
erl
.
average
+
metrics
-
>
erle
.
average
;
}
else
{
stmp
=
kOffsetLevel
;
}
metrics
-
>
rerl
.
average
=
stmp
;
metrics
-
>
rerl
.
instant
=
stmp
;
metrics
-
>
rerl
.
max
=
stmp
;
metrics
-
>
rerl
.
min
=
stmp
;
metrics
-
>
aNlp
.
instant
=
(
int
)
a_nlp
.
instant
;
if
(
(
a_nlp
.
himean
>
kOffsetLevel
)
&
&
(
a_nlp
.
average
>
kOffsetLevel
)
)
{
dtmp
=
kUpWeight
*
a_nlp
.
himean
+
(
1
-
kUpWeight
)
*
a_nlp
.
average
;
metrics
-
>
aNlp
.
average
=
(
int
)
dtmp
;
}
else
{
metrics
-
>
aNlp
.
average
=
kOffsetLevel
;
}
metrics
-
>
aNlp
.
max
=
(
int
)
a_nlp
.
max
;
if
(
a_nlp
.
min
<
(
kOffsetLevel
*
(
-
1
)
)
)
{
metrics
-
>
aNlp
.
min
=
(
int
)
a_nlp
.
min
;
}
else
{
metrics
-
>
aNlp
.
min
=
kOffsetLevel
;
}
return
0
;
}
int
WebRtcAec_GetDelayMetrics
(
void
*
handle
int
*
median
int
*
std
float
*
fraction_poor_delays
)
{
Aec
*
self
=
handle
;
if
(
median
=
=
NULL
)
{
return
AEC_NULL_POINTER_ERROR
;
}
if
(
std
=
=
NULL
)
{
return
AEC_NULL_POINTER_ERROR
;
}
if
(
self
-
>
initFlag
!
=
initCheck
)
{
return
AEC_UNINITIALIZED_ERROR
;
}
if
(
WebRtcAec_GetDelayMetricsCore
(
self
-
>
aec
median
std
fraction_poor_delays
)
=
=
-
1
)
{
return
AEC_UNSUPPORTED_FUNCTION_ERROR
;
}
return
0
;
}
AecCore
*
WebRtcAec_aec_core
(
void
*
handle
)
{
if
(
!
handle
)
{
return
NULL
;
}
return
(
(
Aec
*
)
handle
)
-
>
aec
;
}
static
int
ProcessNormal
(
Aec
*
aecpc
const
float
*
const
*
nearend
size_t
num_bands
float
*
const
*
out
size_t
nrOfSamples
int16_t
msInSndCardBuf
int32_t
skew
)
{
int
retVal
=
0
;
size_t
i
;
size_t
nBlocks10ms
;
const
float
minSkewEst
=
-
0
.
5f
;
const
float
maxSkewEst
=
1
.
0f
;
msInSndCardBuf
=
msInSndCardBuf
>
kMaxTrustedDelayMs
?
kMaxTrustedDelayMs
:
msInSndCardBuf
;
msInSndCardBuf
+
=
10
;
aecpc
-
>
msInSndCardBuf
=
msInSndCardBuf
;
if
(
aecpc
-
>
skewMode
=
=
kAecTrue
)
{
if
(
aecpc
-
>
skewFrCtr
<
25
)
{
aecpc
-
>
skewFrCtr
+
+
;
}
else
{
retVal
=
WebRtcAec_GetSkew
(
aecpc
-
>
resampler
skew
&
aecpc
-
>
skew
)
;
if
(
retVal
=
=
-
1
)
{
aecpc
-
>
skew
=
0
;
retVal
=
AEC_BAD_PARAMETER_WARNING
;
}
aecpc
-
>
skew
/
=
aecpc
-
>
sampFactor
*
nrOfSamples
;
if
(
aecpc
-
>
skew
<
1
.
0e
-
3
&
&
aecpc
-
>
skew
>
-
1
.
0e
-
3
)
{
aecpc
-
>
resample
=
kAecFalse
;
}
else
{
aecpc
-
>
resample
=
kAecTrue
;
}
if
(
aecpc
-
>
skew
<
minSkewEst
)
{
aecpc
-
>
skew
=
minSkewEst
;
}
else
if
(
aecpc
-
>
skew
>
maxSkewEst
)
{
aecpc
-
>
skew
=
maxSkewEst
;
}
#
ifdef
WEBRTC_AEC_DEBUG_DUMP
(
void
)
fwrite
(
&
aecpc
-
>
skew
sizeof
(
aecpc
-
>
skew
)
1
aecpc
-
>
skewFile
)
;
#
endif
}
}
nBlocks10ms
=
nrOfSamples
/
(
FRAME_LEN
*
aecpc
-
>
rate_factor
)
;
if
(
aecpc
-
>
startup_phase
)
{
for
(
i
=
0
;
i
<
num_bands
;
+
+
i
)
{
if
(
nearend
[
i
]
!
=
out
[
i
]
)
{
memcpy
(
out
[
i
]
nearend
[
i
]
sizeof
(
nearend
[
i
]
[
0
]
)
*
nrOfSamples
)
;
}
}
if
(
aecpc
-
>
checkBuffSize
)
{
aecpc
-
>
checkBufSizeCtr
+
+
;
if
(
aecpc
-
>
counter
=
=
0
)
{
aecpc
-
>
firstVal
=
aecpc
-
>
msInSndCardBuf
;
aecpc
-
>
sum
=
0
;
}
if
(
abs
(
aecpc
-
>
firstVal
-
aecpc
-
>
msInSndCardBuf
)
<
WEBRTC_SPL_MAX
(
0
.
2
*
aecpc
-
>
msInSndCardBuf
sampMsNb
)
)
{
aecpc
-
>
sum
+
=
aecpc
-
>
msInSndCardBuf
;
aecpc
-
>
counter
+
+
;
}
else
{
aecpc
-
>
counter
=
0
;
}
if
(
aecpc
-
>
counter
*
nBlocks10ms
>
=
6
)
{
aecpc
-
>
bufSizeStart
=
WEBRTC_SPL_MIN
(
(
3
*
aecpc
-
>
sum
*
aecpc
-
>
rate_factor
*
8
)
/
(
4
*
aecpc
-
>
counter
*
PART_LEN
)
kMaxBufSizeStart
)
;
aecpc
-
>
checkBuffSize
=
0
;
}
if
(
aecpc
-
>
checkBufSizeCtr
*
nBlocks10ms
>
50
)
{
aecpc
-
>
bufSizeStart
=
WEBRTC_SPL_MIN
(
(
aecpc
-
>
msInSndCardBuf
*
aecpc
-
>
rate_factor
*
3
)
/
40
kMaxBufSizeStart
)
;
aecpc
-
>
checkBuffSize
=
0
;
}
}
if
(
!
aecpc
-
>
checkBuffSize
)
{
int
overhead_elements
=
WebRtcAec_system_delay
(
aecpc
-
>
aec
)
/
PART_LEN
-
aecpc
-
>
bufSizeStart
;
if
(
overhead_elements
=
=
0
)
{
aecpc
-
>
startup_phase
=
0
;
}
else
if
(
overhead_elements
>
0
)
{
WebRtcAec_MoveFarReadPtr
(
aecpc
-
>
aec
overhead_elements
)
;
aecpc
-
>
startup_phase
=
0
;
}
}
}
else
{
EstBufDelayNormal
(
aecpc
)
;
WebRtcAec_ProcessFrames
(
aecpc
-
>
aec
nearend
num_bands
nrOfSamples
aecpc
-
>
knownDelay
out
)
;
}
return
retVal
;
}
static
void
ProcessExtended
(
Aec
*
self
const
float
*
const
*
near
size_t
num_bands
float
*
const
*
out
size_t
num_samples
int16_t
reported_delay_ms
int32_t
skew
)
{
size_t
i
;
const
int
delay_diff_offset
=
kDelayDiffOffsetSamples
;
#
if
defined
(
WEBRTC_UNTRUSTED_DELAY
)
reported_delay_ms
=
kFixedDelayMs
;
#
else
reported_delay_ms
=
reported_delay_ms
<
kMinTrustedDelayMs
?
kMinTrustedDelayMs
:
reported_delay_ms
;
reported_delay_ms
=
reported_delay_ms
>
=
kMaxTrustedDelayMs
?
kFixedDelayMs
:
reported_delay_ms
;
#
endif
self
-
>
msInSndCardBuf
=
reported_delay_ms
;
if
(
!
self
-
>
farend_started
)
{
for
(
i
=
0
;
i
<
num_bands
;
+
+
i
)
{
if
(
near
[
i
]
!
=
out
[
i
]
)
{
memcpy
(
out
[
i
]
near
[
i
]
sizeof
(
near
[
i
]
[
0
]
)
*
num_samples
)
;
}
}
return
;
}
if
(
self
-
>
startup_phase
)
{
int
startup_size_ms
=
reported_delay_ms
<
kFixedDelayMs
?
kFixedDelayMs
:
reported_delay_ms
;
#
if
defined
(
WEBRTC_ANDROID
)
int
target_delay
=
startup_size_ms
*
self
-
>
rate_factor
*
8
;
#
else
int
target_delay
=
startup_size_ms
*
self
-
>
rate_factor
*
8
/
2
;
#
endif
int
overhead_elements
=
(
WebRtcAec_system_delay
(
self
-
>
aec
)
-
target_delay
)
/
PART_LEN
;
WebRtcAec_MoveFarReadPtr
(
self
-
>
aec
overhead_elements
)
;
self
-
>
startup_phase
=
0
;
}
EstBufDelayExtended
(
self
)
;
{
const
int
adjusted_known_delay
=
WEBRTC_SPL_MAX
(
0
self
-
>
knownDelay
+
delay_diff_offset
)
;
WebRtcAec_ProcessFrames
(
self
-
>
aec
near
num_bands
num_samples
adjusted_known_delay
out
)
;
}
}
static
void
EstBufDelayNormal
(
Aec
*
aecpc
)
{
int
nSampSndCard
=
aecpc
-
>
msInSndCardBuf
*
sampMsNb
*
aecpc
-
>
rate_factor
;
int
current_delay
=
nSampSndCard
-
WebRtcAec_system_delay
(
aecpc
-
>
aec
)
;
int
delay_difference
=
0
;
current_delay
+
=
FRAME_LEN
*
aecpc
-
>
rate_factor
;
if
(
aecpc
-
>
skewMode
=
=
kAecTrue
&
&
aecpc
-
>
resample
=
=
kAecTrue
)
{
current_delay
-
=
kResamplingDelay
;
}
if
(
current_delay
<
PART_LEN
)
{
current_delay
+
=
WebRtcAec_MoveFarReadPtr
(
aecpc
-
>
aec
1
)
*
PART_LEN
;
}
aecpc
-
>
filtDelay
=
aecpc
-
>
filtDelay
<
0
?
0
:
aecpc
-
>
filtDelay
;
aecpc
-
>
filtDelay
=
WEBRTC_SPL_MAX
(
0
(
short
)
(
0
.
8
*
aecpc
-
>
filtDelay
+
0
.
2
*
current_delay
)
)
;
delay_difference
=
aecpc
-
>
filtDelay
-
aecpc
-
>
knownDelay
;
if
(
delay_difference
>
224
)
{
if
(
aecpc
-
>
lastDelayDiff
<
96
)
{
aecpc
-
>
timeForDelayChange
=
0
;
}
else
{
aecpc
-
>
timeForDelayChange
+
+
;
}
}
else
if
(
delay_difference
<
96
&
&
aecpc
-
>
knownDelay
>
0
)
{
if
(
aecpc
-
>
lastDelayDiff
>
224
)
{
aecpc
-
>
timeForDelayChange
=
0
;
}
else
{
aecpc
-
>
timeForDelayChange
+
+
;
}
}
else
{
aecpc
-
>
timeForDelayChange
=
0
;
}
aecpc
-
>
lastDelayDiff
=
delay_difference
;
if
(
aecpc
-
>
timeForDelayChange
>
25
)
{
aecpc
-
>
knownDelay
=
WEBRTC_SPL_MAX
(
(
int
)
aecpc
-
>
filtDelay
-
160
0
)
;
}
}
static
void
EstBufDelayExtended
(
Aec
*
self
)
{
int
reported_delay
=
self
-
>
msInSndCardBuf
*
sampMsNb
*
self
-
>
rate_factor
;
int
current_delay
=
reported_delay
-
WebRtcAec_system_delay
(
self
-
>
aec
)
;
int
delay_difference
=
0
;
current_delay
+
=
FRAME_LEN
*
self
-
>
rate_factor
;
if
(
self
-
>
skewMode
=
=
kAecTrue
&
&
self
-
>
resample
=
=
kAecTrue
)
{
current_delay
-
=
kResamplingDelay
;
}
if
(
current_delay
<
PART_LEN
)
{
current_delay
+
=
WebRtcAec_MoveFarReadPtr
(
self
-
>
aec
2
)
*
PART_LEN
;
}
if
(
self
-
>
filtDelay
=
=
-
1
)
{
self
-
>
filtDelay
=
WEBRTC_SPL_MAX
(
0
0
.
5
*
current_delay
)
;
}
else
{
self
-
>
filtDelay
=
WEBRTC_SPL_MAX
(
0
(
short
)
(
0
.
95
*
self
-
>
filtDelay
+
0
.
05
*
current_delay
)
)
;
}
delay_difference
=
self
-
>
filtDelay
-
self
-
>
knownDelay
;
if
(
delay_difference
>
384
)
{
if
(
self
-
>
lastDelayDiff
<
128
)
{
self
-
>
timeForDelayChange
=
0
;
}
else
{
self
-
>
timeForDelayChange
+
+
;
}
}
else
if
(
delay_difference
<
128
&
&
self
-
>
knownDelay
>
0
)
{
if
(
self
-
>
lastDelayDiff
>
384
)
{
self
-
>
timeForDelayChange
=
0
;
}
else
{
self
-
>
timeForDelayChange
+
+
;
}
}
else
{
self
-
>
timeForDelayChange
=
0
;
}
self
-
>
lastDelayDiff
=
delay_difference
;
if
(
self
-
>
timeForDelayChange
>
25
)
{
self
-
>
knownDelay
=
WEBRTC_SPL_MAX
(
(
int
)
self
-
>
filtDelay
-
256
0
)
;
}
}
