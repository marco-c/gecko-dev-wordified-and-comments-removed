#
include
"
modules
/
audio_processing
/
aec
/
aec_core
.
h
"
#
include
"
modules
/
audio_processing
/
aec
/
echo_cancellation
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
namespace
{
class
SystemDelayTest
:
public
:
:
testing
:
:
Test
{
protected
:
SystemDelayTest
(
)
;
virtual
void
SetUp
(
)
;
virtual
void
TearDown
(
)
;
void
Init
(
int
sample_rate_hz
)
;
void
RenderAndCapture
(
int
device_buffer_ms
)
;
size_t
BufferFillUp
(
)
;
void
RunStableStartup
(
)
;
int
MapBufferSizeToSamples
(
int
size_in_ms
bool
extended_filter
)
;
void
*
handle_
;
Aec
*
self_
;
size_t
samples_per_frame_
;
static
const
int
kSamplesPerChunk
=
160
;
float
far_
[
kSamplesPerChunk
]
;
float
near_
[
kSamplesPerChunk
]
;
float
out_
[
kSamplesPerChunk
]
;
const
float
*
near_ptr_
;
float
*
out_ptr_
;
}
;
SystemDelayTest
:
:
SystemDelayTest
(
)
:
handle_
(
NULL
)
self_
(
NULL
)
samples_per_frame_
(
0
)
{
for
(
int
i
=
0
;
i
<
kSamplesPerChunk
;
i
+
+
)
{
far_
[
i
]
=
257
.
0
;
near_
[
i
]
=
514
.
0
;
}
memset
(
out_
0
sizeof
(
out_
)
)
;
near_ptr_
=
near_
;
out_ptr_
=
out_
;
}
void
SystemDelayTest
:
:
SetUp
(
)
{
handle_
=
WebRtcAec_Create
(
)
;
ASSERT_TRUE
(
handle_
)
;
self_
=
reinterpret_cast
<
Aec
*
>
(
handle_
)
;
}
void
SystemDelayTest
:
:
TearDown
(
)
{
WebRtcAec_Free
(
handle_
)
;
handle_
=
NULL
;
}
static
const
int
kSampleRateHz
[
]
=
{
8000
16000
}
;
static
const
size_t
kNumSampleRates
=
sizeof
(
kSampleRateHz
)
/
sizeof
(
*
kSampleRateHz
)
;
static
const
int
kDeviceBufMs
=
100
;
static
const
int
kStableConvergenceMs
=
100
;
static
const
int
kMaxConvergenceMs
=
500
;
void
SystemDelayTest
:
:
Init
(
int
sample_rate_hz
)
{
EXPECT_EQ
(
0
WebRtcAec_Init
(
handle_
sample_rate_hz
48000
)
)
;
EXPECT_EQ
(
0
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
samples_per_frame_
=
static_cast
<
size_t
>
(
sample_rate_hz
/
100
)
;
}
void
SystemDelayTest
:
:
RenderAndCapture
(
int
device_buffer_ms
)
{
EXPECT_EQ
(
0
WebRtcAec_BufferFarend
(
handle_
far_
samples_per_frame_
)
)
;
EXPECT_EQ
(
0
WebRtcAec_Process
(
handle_
&
near_ptr_
1
&
out_ptr_
samples_per_frame_
device_buffer_ms
0
)
)
;
}
size_t
SystemDelayTest
:
:
BufferFillUp
(
)
{
size_t
buffer_size
=
0
;
for
(
int
i
=
0
;
i
<
kDeviceBufMs
/
10
;
i
+
+
)
{
EXPECT_EQ
(
0
WebRtcAec_BufferFarend
(
handle_
far_
samples_per_frame_
)
)
;
buffer_size
+
=
samples_per_frame_
;
EXPECT_EQ
(
static_cast
<
int
>
(
buffer_size
)
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
return
buffer_size
;
}
void
SystemDelayTest
:
:
RunStableStartup
(
)
{
size_t
buffer_size
=
BufferFillUp
(
)
;
if
(
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
=
=
1
)
{
RenderAndCapture
(
kDeviceBufMs
)
;
buffer_size
+
=
samples_per_frame_
;
EXPECT_EQ
(
0
self_
-
>
startup_phase
)
;
}
else
{
int
process_time_ms
=
0
;
for
(
;
process_time_ms
<
kStableConvergenceMs
;
process_time_ms
+
=
10
)
{
RenderAndCapture
(
kDeviceBufMs
)
;
buffer_size
+
=
samples_per_frame_
;
if
(
self_
-
>
startup_phase
=
=
0
)
{
break
;
}
}
EXPECT_GT
(
kStableConvergenceMs
process_time_ms
)
;
}
EXPECT_GE
(
static_cast
<
int
>
(
buffer_size
)
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
int
SystemDelayTest
:
:
MapBufferSizeToSamples
(
int
size_in_ms
bool
extended_filter
)
{
return
static_cast
<
int
>
(
(
size_in_ms
+
(
extended_filter
?
0
:
10
)
)
*
samples_per_frame_
/
10
)
;
}
TEST_F
(
SystemDelayTest
CorrectIncreaseWhenBufferFarend
)
{
for
(
int
extended_filter
=
0
;
extended_filter
<
=
1
;
+
+
extended_filter
)
{
WebRtcAec_enable_extended_filter
(
self_
-
>
aec
extended_filter
)
;
EXPECT_EQ
(
extended_filter
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
)
;
for
(
int
da_aec
=
0
;
da_aec
<
=
1
;
+
+
da_aec
)
{
WebRtcAec_enable_delay_agnostic
(
self_
-
>
aec
da_aec
)
;
EXPECT_EQ
(
da_aec
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
)
;
for
(
size_t
i
=
0
;
i
<
kNumSampleRates
;
i
+
+
)
{
Init
(
kSampleRateHz
[
i
]
)
;
for
(
int
j
=
1
;
j
<
=
5
;
j
+
+
)
{
EXPECT_EQ
(
0
WebRtcAec_BufferFarend
(
handle_
far_
samples_per_frame_
)
)
;
EXPECT_EQ
(
static_cast
<
int
>
(
j
*
samples_per_frame_
)
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
}
}
}
}
TEST_F
(
SystemDelayTest
CorrectDelayAfterStableStartup
)
{
for
(
int
extended_filter
=
0
;
extended_filter
<
=
1
;
+
+
extended_filter
)
{
WebRtcAec_enable_extended_filter
(
self_
-
>
aec
extended_filter
)
;
EXPECT_EQ
(
extended_filter
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
)
;
for
(
int
da_aec
=
0
;
da_aec
<
=
1
;
+
+
da_aec
)
{
WebRtcAec_enable_delay_agnostic
(
self_
-
>
aec
da_aec
)
;
EXPECT_EQ
(
da_aec
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
)
;
for
(
size_t
i
=
0
;
i
<
kNumSampleRates
;
i
+
+
)
{
Init
(
kSampleRateHz
[
i
]
)
;
RunStableStartup
(
)
;
int
average_reported_delay
=
static_cast
<
int
>
(
kDeviceBufMs
*
samples_per_frame_
/
10
)
;
EXPECT_GE
(
average_reported_delay
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
int
lower_bound
=
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
?
(
average_reported_delay
/
2
-
rtc
:
:
checked_cast
<
int
>
(
samples_per_frame_
)
)
:
average_reported_delay
*
3
/
4
;
EXPECT_LE
(
lower_bound
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
}
}
}
TEST_F
(
SystemDelayTest
CorrectDelayAfterUnstableStartup
)
{
WebRtcAec_enable_extended_filter
(
self_
-
>
aec
0
)
;
EXPECT_EQ
(
0
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
)
;
WebRtcAec_enable_delay_agnostic
(
self_
-
>
aec
0
)
;
EXPECT_EQ
(
0
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
)
;
for
(
size_t
i
=
0
;
i
<
kNumSampleRates
;
i
+
+
)
{
Init
(
kSampleRateHz
[
i
]
)
;
size_t
buffer_size
=
BufferFillUp
(
)
;
int
buffer_offset_ms
=
25
;
int
reported_delay_ms
=
0
;
int
process_time_ms
=
0
;
for
(
;
process_time_ms
<
=
kMaxConvergenceMs
;
process_time_ms
+
=
10
)
{
reported_delay_ms
=
kDeviceBufMs
+
buffer_offset_ms
;
RenderAndCapture
(
reported_delay_ms
)
;
buffer_size
+
=
samples_per_frame_
;
buffer_offset_ms
=
-
buffer_offset_ms
;
if
(
self_
-
>
startup_phase
=
=
0
)
{
break
;
}
}
EXPECT_GE
(
kMaxConvergenceMs
process_time_ms
)
;
EXPECT_GE
(
static_cast
<
int
>
(
buffer_size
)
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
EXPECT_GE
(
static_cast
<
int
>
(
reported_delay_ms
*
samples_per_frame_
/
10
)
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
EXPECT_LE
(
static_cast
<
int
>
(
reported_delay_ms
*
samples_per_frame_
/
10
*
3
/
5
)
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
}
TEST_F
(
SystemDelayTest
CorrectDelayAfterStableBufferBuildUp
)
{
WebRtcAec_enable_extended_filter
(
self_
-
>
aec
0
)
;
EXPECT_EQ
(
0
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
)
;
WebRtcAec_enable_delay_agnostic
(
self_
-
>
aec
0
)
;
EXPECT_EQ
(
0
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
)
;
for
(
size_t
i
=
0
;
i
<
kNumSampleRates
;
i
+
+
)
{
Init
(
kSampleRateHz
[
i
]
)
;
int
process_time_ms
=
0
;
for
(
;
process_time_ms
<
kStableConvergenceMs
;
process_time_ms
+
=
10
)
{
EXPECT_EQ
(
0
WebRtcAec_Process
(
handle_
&
near_ptr_
1
&
out_ptr_
samples_per_frame_
kDeviceBufMs
0
)
)
;
}
EXPECT_EQ
(
0
self_
-
>
checkBuffSize
)
;
size_t
buffer_size
=
0
;
size_t
target_buffer_size
=
kDeviceBufMs
*
samples_per_frame_
/
10
*
3
/
4
;
process_time_ms
=
0
;
for
(
;
process_time_ms
<
=
kMaxConvergenceMs
;
process_time_ms
+
=
10
)
{
RenderAndCapture
(
kDeviceBufMs
)
;
buffer_size
+
=
samples_per_frame_
;
if
(
self_
-
>
startup_phase
=
=
0
)
{
break
;
}
}
EXPECT_GT
(
kMaxConvergenceMs
process_time_ms
)
;
EXPECT_LE
(
static_cast
<
int
>
(
target_buffer_size
)
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
for
(
int
j
=
0
;
j
<
6
;
j
+
+
)
{
int
system_delay_before_calls
=
WebRtcAec_system_delay
(
self_
-
>
aec
)
;
RenderAndCapture
(
kDeviceBufMs
)
;
EXPECT_EQ
(
system_delay_before_calls
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
}
}
TEST_F
(
SystemDelayTest
CorrectDelayWhenBufferUnderrun
)
{
for
(
int
extended_filter
=
0
;
extended_filter
<
=
1
;
+
+
extended_filter
)
{
WebRtcAec_enable_extended_filter
(
self_
-
>
aec
extended_filter
)
;
EXPECT_EQ
(
extended_filter
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
)
;
for
(
int
da_aec
=
0
;
da_aec
<
=
1
;
+
+
da_aec
)
{
WebRtcAec_enable_delay_agnostic
(
self_
-
>
aec
da_aec
)
;
EXPECT_EQ
(
da_aec
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
)
;
for
(
size_t
i
=
0
;
i
<
kNumSampleRates
;
i
+
+
)
{
Init
(
kSampleRateHz
[
i
]
)
;
RunStableStartup
(
)
;
for
(
int
j
=
0
;
j
<
=
kStableConvergenceMs
;
j
+
=
10
)
{
EXPECT_EQ
(
0
WebRtcAec_Process
(
handle_
&
near_ptr_
1
&
out_ptr_
samples_per_frame_
kDeviceBufMs
0
)
)
;
EXPECT_LE
(
0
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
}
}
}
}
TEST_F
(
SystemDelayTest
CorrectDelayDuringDrift
)
{
for
(
int
extended_filter
=
0
;
extended_filter
<
=
1
;
+
+
extended_filter
)
{
WebRtcAec_enable_extended_filter
(
self_
-
>
aec
extended_filter
)
;
EXPECT_EQ
(
extended_filter
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
)
;
for
(
int
da_aec
=
0
;
da_aec
<
=
1
;
+
+
da_aec
)
{
WebRtcAec_enable_delay_agnostic
(
self_
-
>
aec
da_aec
)
;
EXPECT_EQ
(
da_aec
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
)
;
for
(
size_t
i
=
0
;
i
<
kNumSampleRates
;
i
+
+
)
{
Init
(
kSampleRateHz
[
i
]
)
;
RunStableStartup
(
)
;
int
jump
=
0
;
for
(
int
j
=
0
;
j
<
1000
;
j
+
+
)
{
int
device_buf_ms
=
kDeviceBufMs
-
(
j
/
10
)
+
jump
;
int
device_buf
=
MapBufferSizeToSamples
(
device_buf_ms
extended_filter
=
=
1
)
;
if
(
device_buf_ms
<
30
)
{
jump
+
=
10
;
}
RenderAndCapture
(
device_buf_ms
)
;
EXPECT_GE
(
device_buf
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
EXPECT_LE
(
0
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
}
}
}
}
TEST_F
(
SystemDelayTest
ShouldRecoverAfterGlitch
)
{
for
(
int
extended_filter
=
0
;
extended_filter
<
=
1
;
+
+
extended_filter
)
{
WebRtcAec_enable_extended_filter
(
self_
-
>
aec
extended_filter
)
;
EXPECT_EQ
(
extended_filter
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
)
;
for
(
int
da_aec
=
0
;
da_aec
<
=
1
;
+
+
da_aec
)
{
WebRtcAec_enable_delay_agnostic
(
self_
-
>
aec
da_aec
)
;
EXPECT_EQ
(
da_aec
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
)
;
for
(
size_t
i
=
0
;
i
<
kNumSampleRates
;
i
+
+
)
{
Init
(
kSampleRateHz
[
i
]
)
;
RunStableStartup
(
)
;
int
device_buf
=
MapBufferSizeToSamples
(
kDeviceBufMs
extended_filter
=
=
1
)
;
for
(
int
j
=
0
;
j
<
20
;
j
+
+
)
{
EXPECT_EQ
(
0
WebRtcAec_BufferFarend
(
handle_
far_
samples_per_frame_
)
)
;
}
EXPECT_LT
(
device_buf
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
bool
non_causal
=
true
;
for
(
int
j
=
0
;
j
<
50
;
j
+
+
)
{
int
system_delay_before
=
WebRtcAec_system_delay
(
self_
-
>
aec
)
;
RenderAndCapture
(
kDeviceBufMs
)
;
int
system_delay_after
=
WebRtcAec_system_delay
(
self_
-
>
aec
)
;
if
(
non_causal
)
{
EXPECT_LT
(
system_delay_after
system_delay_before
)
;
if
(
device_buf
-
system_delay_after
>
=
PART_LEN
)
{
non_causal
=
false
;
}
}
else
{
EXPECT_EQ
(
system_delay_before
system_delay_after
)
;
}
EXPECT_LE
(
0
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
EXPECT_FALSE
(
non_causal
)
;
}
}
}
}
TEST_F
(
SystemDelayTest
UnaffectedWhenSpuriousDeviceBufferValues
)
{
const
int
extended_filter
=
0
;
WebRtcAec_enable_extended_filter
(
self_
-
>
aec
extended_filter
)
;
EXPECT_EQ
(
extended_filter
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
)
;
for
(
int
da_aec
=
0
;
da_aec
<
=
1
;
+
+
da_aec
)
{
WebRtcAec_enable_delay_agnostic
(
self_
-
>
aec
da_aec
)
;
EXPECT_EQ
(
da_aec
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
)
;
for
(
size_t
i
=
0
;
i
<
kNumSampleRates
;
i
+
+
)
{
Init
(
kSampleRateHz
[
i
]
)
;
RunStableStartup
(
)
;
int
device_buf
=
MapBufferSizeToSamples
(
kDeviceBufMs
extended_filter
=
=
1
)
;
bool
non_causal
=
false
;
for
(
int
j
=
0
;
j
<
100
;
j
+
+
)
{
int
system_delay_before_calls
=
WebRtcAec_system_delay
(
self_
-
>
aec
)
;
int
device_buf_ms
=
j
%
10
=
=
0
?
500
:
kDeviceBufMs
;
RenderAndCapture
(
device_buf_ms
)
;
if
(
device_buf
-
WebRtcAec_system_delay
(
self_
-
>
aec
)
<
PART_LEN
)
{
non_causal
=
true
;
}
EXPECT_FALSE
(
non_causal
)
;
EXPECT_EQ
(
system_delay_before_calls
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
EXPECT_LE
(
0
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
}
}
}
TEST_F
(
SystemDelayTest
CorrectImpactWhenTogglingDeviceBufferValues
)
{
for
(
int
extended_filter
=
0
;
extended_filter
<
=
1
;
+
+
extended_filter
)
{
WebRtcAec_enable_extended_filter
(
self_
-
>
aec
extended_filter
)
;
EXPECT_EQ
(
extended_filter
WebRtcAec_extended_filter_enabled
(
self_
-
>
aec
)
)
;
for
(
int
da_aec
=
0
;
da_aec
<
=
1
;
+
+
da_aec
)
{
WebRtcAec_enable_delay_agnostic
(
self_
-
>
aec
da_aec
)
;
EXPECT_EQ
(
da_aec
WebRtcAec_delay_agnostic_enabled
(
self_
-
>
aec
)
)
;
if
(
extended_filter
=
=
0
&
&
da_aec
=
=
1
)
{
continue
;
}
for
(
size_t
i
=
0
;
i
<
kNumSampleRates
;
i
+
+
)
{
Init
(
kSampleRateHz
[
i
]
)
;
RunStableStartup
(
)
;
const
int
device_buf
=
MapBufferSizeToSamples
(
kDeviceBufMs
extended_filter
=
=
1
)
;
bool
non_causal
=
false
;
for
(
int
j
=
0
;
j
<
100
;
j
+
+
)
{
int
system_delay_before_calls
=
WebRtcAec_system_delay
(
self_
-
>
aec
)
;
int
device_buf_ms
=
2
*
(
j
%
2
)
*
kDeviceBufMs
;
RenderAndCapture
(
device_buf_ms
)
;
non_causal
|
=
(
device_buf
-
WebRtcAec_system_delay
(
self_
-
>
aec
)
<
64
)
;
EXPECT_GE
(
system_delay_before_calls
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
EXPECT_LE
(
0
WebRtcAec_system_delay
(
self_
-
>
aec
)
)
;
}
EXPECT_FALSE
(
non_causal
)
;
}
}
}
}
}
}
