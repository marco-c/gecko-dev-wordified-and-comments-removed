#
ifndef
WEBRTC_MODULES_AUDIO_PROCESSING_INTELLIGIBILITY_INTELLIGIBILITY_ENHANCER_H_
#
define
WEBRTC_MODULES_AUDIO_PROCESSING_INTELLIGIBILITY_INTELLIGIBILITY_ENHANCER_H_
#
include
<
complex
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
common_audio
/
lapped_transform
.
h
"
#
include
"
webrtc
/
common_audio
/
channel_buffer
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
intelligibility
/
intelligibility_utils
.
h
"
namespace
webrtc
{
class
IntelligibilityEnhancer
{
public
:
struct
Config
{
Config
(
)
:
sample_rate_hz
(
16000
)
num_capture_channels
(
1
)
num_render_channels
(
1
)
var_type
(
intelligibility
:
:
VarianceArray
:
:
kStepDecaying
)
var_decay_rate
(
0
.
9f
)
var_window_size
(
10
)
analysis_rate
(
800
)
gain_change_limit
(
0
.
1f
)
rho
(
0
.
02f
)
{
}
int
sample_rate_hz
;
size_t
num_capture_channels
;
size_t
num_render_channels
;
intelligibility
:
:
VarianceArray
:
:
StepType
var_type
;
float
var_decay_rate
;
size_t
var_window_size
;
int
analysis_rate
;
float
gain_change_limit
;
float
rho
;
}
;
explicit
IntelligibilityEnhancer
(
const
Config
&
config
)
;
IntelligibilityEnhancer
(
)
;
void
AnalyzeCaptureAudio
(
float
*
const
*
audio
int
sample_rate_hz
size_t
num_channels
)
;
void
ProcessRenderAudio
(
float
*
const
*
audio
int
sample_rate_hz
size_t
num_channels
)
;
bool
active
(
)
const
;
private
:
enum
AudioSource
{
kRenderStream
=
0
kCaptureStream
}
;
class
TransformCallback
:
public
LappedTransform
:
:
Callback
{
public
:
TransformCallback
(
IntelligibilityEnhancer
*
parent
AudioSource
source
)
;
void
ProcessAudioBlock
(
const
std
:
:
complex
<
float
>
*
const
*
in_block
size_t
in_channels
size_t
frames
size_t
out_channels
std
:
:
complex
<
float
>
*
const
*
out_block
)
override
;
private
:
IntelligibilityEnhancer
*
parent_
;
AudioSource
source_
;
}
;
friend
class
TransformCallback
;
FRIEND_TEST_ALL_PREFIXES
(
IntelligibilityEnhancerTest
TestErbCreation
)
;
FRIEND_TEST_ALL_PREFIXES
(
IntelligibilityEnhancerTest
TestSolveForGains
)
;
void
DispatchAudio
(
AudioSource
source
const
std
:
:
complex
<
float
>
*
in_block
std
:
:
complex
<
float
>
*
out_block
)
;
void
ProcessClearBlock
(
const
std
:
:
complex
<
float
>
*
in_block
std
:
:
complex
<
float
>
*
out_block
)
;
void
AnalyzeClearBlock
(
float
power_target
)
;
void
SolveForLambda
(
float
power_target
float
power_bot
float
power_top
)
;
void
UpdateErbGains
(
)
;
void
ProcessNoiseBlock
(
const
std
:
:
complex
<
float
>
*
in_block
std
:
:
complex
<
float
>
*
out_block
)
;
static
size_t
GetBankSize
(
int
sample_rate
size_t
erb_resolution
)
;
void
CreateErbBank
(
)
;
void
SolveForGainsGivenLambda
(
float
lambda
size_t
start_freq
float
*
sols
)
;
void
FilterVariance
(
const
float
*
var
float
*
result
)
;
static
float
DotProduct
(
const
float
*
a
const
float
*
b
size_t
length
)
;
const
size_t
freqs_
;
const
size_t
window_size_
;
const
size_t
chunk_length_
;
const
size_t
bank_size_
;
const
int
sample_rate_hz_
;
const
int
erb_resolution_
;
const
size_t
num_capture_channels_
;
const
size_t
num_render_channels_
;
const
int
analysis_rate_
;
const
bool
active_
;
intelligibility
:
:
VarianceArray
clear_variance_
;
intelligibility
:
:
VarianceArray
noise_variance_
;
rtc
:
:
scoped_ptr
<
float
[
]
>
filtered_clear_var_
;
rtc
:
:
scoped_ptr
<
float
[
]
>
filtered_noise_var_
;
std
:
:
vector
<
std
:
:
vector
<
float
>
>
filter_bank_
;
rtc
:
:
scoped_ptr
<
float
[
]
>
center_freqs_
;
size_t
start_freq_
;
rtc
:
:
scoped_ptr
<
float
[
]
>
rho_
;
rtc
:
:
scoped_ptr
<
float
[
]
>
gains_eq_
;
intelligibility
:
:
GainApplier
gain_applier_
;
ChannelBuffer
<
float
>
temp_render_out_buffer_
;
ChannelBuffer
<
float
>
temp_capture_out_buffer_
;
rtc
:
:
scoped_ptr
<
float
[
]
>
kbd_window_
;
TransformCallback
render_callback_
;
TransformCallback
capture_callback_
;
rtc
:
:
scoped_ptr
<
LappedTransform
>
render_mangler_
;
rtc
:
:
scoped_ptr
<
LappedTransform
>
capture_mangler_
;
int
block_count_
;
int
analysis_step_
;
}
;
}
#
endif
