#
ifndef
WEBRTC_MODULES_AUDIO_PROCESSING_INTELLIGIBILITY_INTELLIGIBILITY_ENHANCER_H_
#
define
WEBRTC_MODULES_AUDIO_PROCESSING_INTELLIGIBILITY_INTELLIGIBILITY_ENHANCER_H_
#
include
<
complex
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
swap_queue
.
h
"
#
include
"
webrtc
/
common_audio
/
channel_buffer
.
h
"
#
include
"
webrtc
/
common_audio
/
lapped_transform
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
audio_buffer
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
intelligibility
/
intelligibility_utils
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
render_queue_item_verifier
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
vad
/
voice_activity_detector
.
h
"
namespace
webrtc
{
class
IntelligibilityEnhancer
:
public
LappedTransform
:
:
Callback
{
public
:
IntelligibilityEnhancer
(
int
sample_rate_hz
size_t
num_render_channels
size_t
num_bands
size_t
num_noise_bins
)
;
~
IntelligibilityEnhancer
(
)
override
;
void
SetCaptureNoiseEstimate
(
std
:
:
vector
<
float
>
noise
float
gain
)
;
void
ProcessRenderAudio
(
AudioBuffer
*
audio
)
;
bool
active
(
)
const
;
protected
:
void
ProcessAudioBlock
(
const
std
:
:
complex
<
float
>
*
const
*
in_block
size_t
in_channels
size_t
frames
size_t
out_channels
std
:
:
complex
<
float
>
*
const
*
out_block
)
override
;
private
:
FRIEND_TEST_ALL_PREFIXES
(
IntelligibilityEnhancerTest
TestRenderUpdate
)
;
FRIEND_TEST_ALL_PREFIXES
(
IntelligibilityEnhancerTest
TestErbCreation
)
;
FRIEND_TEST_ALL_PREFIXES
(
IntelligibilityEnhancerTest
TestSolveForGains
)
;
FRIEND_TEST_ALL_PREFIXES
(
IntelligibilityEnhancerTest
TestNoiseGainHasExpectedResult
)
;
FRIEND_TEST_ALL_PREFIXES
(
IntelligibilityEnhancerTest
TestAllBandsHaveSameDelay
)
;
void
SnrBasedEffectActivation
(
)
;
void
SolveForLambda
(
float
power_target
)
;
void
UpdateErbGains
(
)
;
static
size_t
GetBankSize
(
int
sample_rate
size_t
erb_resolution
)
;
std
:
:
vector
<
std
:
:
vector
<
float
>
>
CreateErbBank
(
size_t
num_freqs
)
;
void
SolveForGainsGivenLambda
(
float
lambda
size_t
start_freq
float
*
sols
)
;
bool
IsSpeech
(
const
float
*
audio
)
;
void
DelayHighBands
(
AudioBuffer
*
audio
)
;
static
const
size_t
kMaxNumNoiseEstimatesToBuffer
=
5
;
const
size_t
freqs_
;
const
size_t
num_noise_bins_
;
const
size_t
chunk_length_
;
const
size_t
bank_size_
;
const
int
sample_rate_hz_
;
const
size_t
num_render_channels_
;
intelligibility
:
:
PowerEstimator
<
std
:
:
complex
<
float
>
>
clear_power_estimator_
;
intelligibility
:
:
PowerEstimator
<
float
>
noise_power_estimator_
;
std
:
:
vector
<
float
>
filtered_clear_pow_
;
std
:
:
vector
<
float
>
filtered_noise_pow_
;
std
:
:
vector
<
float
>
center_freqs_
;
std
:
:
vector
<
std
:
:
vector
<
float
>
>
capture_filter_bank_
;
std
:
:
vector
<
std
:
:
vector
<
float
>
>
render_filter_bank_
;
size_t
start_freq_
;
std
:
:
vector
<
float
>
gains_eq_
;
intelligibility
:
:
GainApplier
gain_applier_
;
std
:
:
unique_ptr
<
LappedTransform
>
render_mangler_
;
VoiceActivityDetector
vad_
;
std
:
:
vector
<
int16_t
>
audio_s16_
;
size_t
chunks_since_voice_
;
bool
is_speech_
;
float
snr_
;
bool
is_active_
;
unsigned
long
int
num_chunks_
;
unsigned
long
int
num_active_chunks_
;
std
:
:
vector
<
float
>
noise_estimation_buffer_
;
SwapQueue
<
std
:
:
vector
<
float
>
RenderQueueItemVerifier
<
float
>
>
noise_estimation_queue_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
intelligibility
:
:
DelayBuffer
>
>
high_bands_buffers_
;
}
;
}
#
endif
