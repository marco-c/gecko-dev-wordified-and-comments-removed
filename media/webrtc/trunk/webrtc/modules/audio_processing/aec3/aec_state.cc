#
include
"
modules
/
audio_processing
/
aec3
/
aec_state
.
h
"
#
include
<
math
.
h
>
#
include
<
numeric
>
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
#
include
"
modules
/
audio_processing
/
logging
/
apm_data_dumper
.
h
"
#
include
"
rtc_base
/
atomicops
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
namespace
{
int
EstimateFilterDelay
(
const
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
&
adaptive_filter_frequency_response
)
{
const
auto
&
H2
=
adaptive_filter_frequency_response
;
constexpr
size_t
kUpperBin
=
kFftLengthBy2
-
5
;
RTC_DCHECK_GE
(
kAdaptiveFilterLength
H2
.
size
(
)
)
;
std
:
:
array
<
int
kAdaptiveFilterLength
>
delays
;
delays
.
fill
(
0
)
;
for
(
size_t
k
=
1
;
k
<
kUpperBin
;
+
+
k
)
{
size_t
peak
=
0
;
for
(
size_t
j
=
0
;
j
<
H2
.
size
(
)
;
+
+
j
)
{
if
(
H2
[
j
]
[
k
]
>
H2
[
peak
]
[
k
]
)
{
peak
=
j
;
}
}
+
+
delays
[
peak
]
;
}
return
std
:
:
distance
(
delays
.
begin
(
)
std
:
:
max_element
(
delays
.
begin
(
)
delays
.
end
(
)
)
)
;
}
}
int
AecState
:
:
instance_count_
=
0
;
AecState
:
:
AecState
(
const
EchoCanceller3Config
&
config
)
:
data_dumper_
(
new
ApmDataDumper
(
rtc
:
:
AtomicOps
:
:
Increment
(
&
instance_count_
)
)
)
erle_estimator_
(
config
.
erle
.
min
config
.
erle
.
max_l
config
.
erle
.
max_h
)
config_
(
config
)
reverb_decay_
(
config_
.
ep_strength
.
default_len
)
{
max_render_
.
fill
(
0
.
f
)
;
}
AecState
:
:
~
AecState
(
)
=
default
;
void
AecState
:
:
HandleEchoPathChange
(
const
EchoPathVariability
&
echo_path_variability
)
{
if
(
echo_path_variability
.
AudioPathChanged
(
)
)
{
blocks_since_last_saturation_
=
0
;
usable_linear_estimate_
=
false
;
echo_leakage_detected_
=
false
;
capture_signal_saturation_
=
false
;
echo_saturation_
=
false
;
previous_max_sample_
=
0
.
f
;
max_render_
.
fill
(
0
.
f
)
;
if
(
echo_path_variability
.
delay_change
)
{
force_zero_gain_counter_
=
0
;
blocks_with_filter_adaptation_
=
0
;
blocks_with_strong_render_
=
0
;
initial_state_
=
true
;
linear_echo_estimate_
=
false
;
sufficient_filter_updates_
=
false
;
render_received_
=
false
;
force_zero_gain_
=
true
;
capture_block_counter_
=
0
;
}
if
(
echo_path_variability
.
gain_change
)
{
capture_block_counter_
=
kNumBlocksPerSecond
;
}
}
}
void
AecState
:
:
Update
(
const
std
:
:
vector
<
std
:
:
array
<
float
kFftLengthBy2Plus1
>
>
&
adaptive_filter_frequency_response
const
std
:
:
array
<
float
kAdaptiveFilterTimeDomainLength
>
&
adaptive_filter_impulse_response
bool
converged_filter
const
rtc
:
:
Optional
<
size_t
>
&
external_delay_samples
const
RenderBuffer
&
render_buffer
const
std
:
:
array
<
float
kFftLengthBy2Plus1
>
&
E2_main
const
std
:
:
array
<
float
kFftLengthBy2Plus1
>
&
Y2
rtc
:
:
ArrayView
<
const
float
>
x
const
std
:
:
array
<
float
kBlockSize
>
&
s
bool
echo_leakage_detected
)
{
echo_leakage_detected_
=
echo_leakage_detected
;
+
+
capture_block_counter_
;
force_zero_gain_
=
(
+
+
force_zero_gain_counter_
)
<
kNumBlocksPerSecond
/
5
;
filter_delay_
=
EstimateFilterDelay
(
adaptive_filter_frequency_response
)
;
external_delay_
=
external_delay_samples
?
rtc
:
:
Optional
<
size_t
>
(
*
external_delay_samples
/
kBlockSize
)
:
rtc
:
:
nullopt
;
if
(
converged_filter
&
&
capture_block_counter_
>
=
2
*
kNumBlocksPerSecond
)
{
const
auto
&
X2
=
render_buffer
.
Spectrum
(
*
filter_delay_
)
;
erle_estimator_
.
Update
(
X2
Y2
E2_main
)
;
erl_estimator_
.
Update
(
X2
Y2
)
;
}
echo_audibility_
.
Update
(
x
s
converged_filter
)
;
RTC_DCHECK_LT
(
0
x
.
size
(
)
)
;
const
float
max_sample
=
fabs
(
*
std
:
:
max_element
(
x
.
begin
(
)
x
.
end
(
)
[
]
(
float
a
float
b
)
{
return
a
*
a
<
b
*
b
;
}
)
)
;
if
(
config_
.
ep_strength
.
echo_can_saturate
)
{
const
bool
saturated_echo
=
(
previous_max_sample_
>
200
.
f
)
&
&
SaturatedCapture
(
)
;
constexpr
size_t
kSaturationLeakageBlocks
=
20
;
blocks_since_last_saturation_
=
saturated_echo
?
0
:
blocks_since_last_saturation_
+
1
;
echo_saturation_
=
blocks_since_last_saturation_
<
kSaturationLeakageBlocks
;
}
else
{
echo_saturation_
=
false
;
}
previous_max_sample_
=
max_sample
;
sufficient_filter_updates_
=
blocks_with_filter_adaptation_
>
=
kEchoPathChangeConvergenceBlocks
;
initial_state_
=
capture_block_counter_
<
3
*
kNumBlocksPerSecond
;
usable_linear_estimate_
=
(
!
echo_saturation_
)
&
&
(
converged_filter
|
|
SufficientFilterUpdates
(
)
)
&
&
capture_block_counter_
>
=
2
*
kNumBlocksPerSecond
&
&
external_delay_
;
linear_echo_estimate_
=
UsableLinearEstimate
(
)
&
&
!
TransparentMode
(
)
;
const
float
x_energy
=
std
:
:
inner_product
(
x
.
begin
(
)
x
.
end
(
)
x
.
begin
(
)
0
.
f
)
;
const
bool
active_render_block
=
x_energy
>
(
config_
.
render_levels
.
active_render_limit
*
config_
.
render_levels
.
active_render_limit
)
*
kFftLengthBy2
;
if
(
active_render_block
)
{
render_received_
=
true
;
}
blocks_with_filter_adaptation_
+
=
(
active_render_block
&
&
(
!
SaturatedCapture
(
)
)
?
1
:
0
)
;
transparent_mode_
=
!
converged_filter
&
&
(
!
render_received_
|
|
blocks_with_filter_adaptation_
>
=
5
*
kNumBlocksPerSecond
)
;
UpdateReverb
(
adaptive_filter_impulse_response
)
;
}
void
AecState
:
:
UpdateReverb
(
const
std
:
:
array
<
float
kAdaptiveFilterTimeDomainLength
>
&
impulse_response
)
{
if
(
(
!
(
filter_delay_
&
&
usable_linear_estimate_
)
)
|
|
(
*
filter_delay_
>
kAdaptiveFilterLength
-
4
)
)
{
return
;
}
std
:
:
array
<
float
kAdaptiveFilterTimeDomainLength
>
matching_data
;
std
:
:
transform
(
impulse_response
.
begin
(
)
impulse_response
.
end
(
)
matching_data
.
begin
(
)
[
]
(
float
a
)
{
return
a
*
a
;
}
)
;
constexpr
size_t
kTailLength
=
64
;
constexpr
size_t
tail_index
=
kAdaptiveFilterTimeDomainLength
-
kTailLength
;
const
float
tail_power
=
*
std
:
:
max_element
(
matching_data
.
begin
(
)
+
tail_index
matching_data
.
end
(
)
)
;
std
:
:
for_each
(
matching_data
.
begin
(
)
matching_data
.
begin
(
)
+
tail_index
[
tail_power
]
(
float
&
a
)
{
a
=
std
:
:
max
(
0
.
f
a
-
tail_power
)
;
}
)
;
const
size_t
peak_index
=
*
std
:
:
max_element
(
matching_data
.
begin
(
)
matching_data
.
begin
(
)
+
tail_index
)
;
if
(
peak_index
+
128
<
tail_index
)
{
size_t
start_index
=
peak_index
+
64
;
float
residual_sqr_sum
=
0
.
f
;
float
d_k
=
reverb_decay_to_test_
;
for
(
size_t
k
=
start_index
;
k
<
tail_index
;
+
+
k
)
{
if
(
matching_data
[
start_index
+
1
]
=
=
0
.
f
)
{
break
;
}
float
residual
=
matching_data
[
k
]
-
matching_data
[
peak_index
]
*
d_k
;
residual_sqr_sum
+
=
residual
*
residual
;
d_k
*
=
reverb_decay_to_test_
;
}
if
(
reverb_decay_candidate_residual_
<
0
.
f
|
|
residual_sqr_sum
<
reverb_decay_candidate_residual_
)
{
reverb_decay_candidate_residual_
=
residual_sqr_sum
;
reverb_decay_candidate_
=
reverb_decay_to_test_
;
}
}
reverb_decay_to_test_
+
=
(
0
.
9965f
-
0
.
9f
)
/
(
5
*
kNumBlocksPerSecond
)
;
if
(
reverb_decay_to_test_
>
=
0
.
9965f
)
{
if
(
reverb_decay_candidate_residual_
<
0
.
f
)
{
reverb_decay_
=
powf
(
reverb_decay_candidate_
kFftLengthBy2
)
;
reverb_decay_
=
std
:
:
min
(
config_
.
ep_strength
.
default_len
reverb_decay_
)
;
}
reverb_decay_to_test_
=
0
.
9f
;
reverb_decay_candidate_residual_
=
-
1
.
f
;
}
if
(
tail_power
>
0
.
0005f
)
{
reverb_decay_
=
config_
.
ep_strength
.
default_len
;
}
data_dumper_
-
>
DumpRaw
(
"
aec3_reverb_decay
"
reverb_decay_
)
;
data_dumper_
-
>
DumpRaw
(
"
aec3_tail_power
"
tail_power
)
;
}
void
AecState
:
:
EchoAudibility
:
:
Update
(
rtc
:
:
ArrayView
<
const
float
>
x
const
std
:
:
array
<
float
kBlockSize
>
&
s
bool
converged_filter
)
{
auto
result_x
=
std
:
:
minmax_element
(
x
.
begin
(
)
x
.
end
(
)
)
;
auto
result_s
=
std
:
:
minmax_element
(
s
.
begin
(
)
s
.
end
(
)
)
;
const
float
x_abs
=
std
:
:
max
(
fabsf
(
*
result_x
.
first
)
fabsf
(
*
result_x
.
second
)
)
;
const
float
s_abs
=
std
:
:
max
(
fabsf
(
*
result_s
.
first
)
fabsf
(
*
result_s
.
second
)
)
;
if
(
converged_filter
)
{
if
(
x_abs
<
20
.
f
)
{
+
+
low_farend_counter_
;
}
else
{
low_farend_counter_
=
0
;
}
}
else
{
if
(
x_abs
<
100
.
f
)
{
+
+
low_farend_counter_
;
}
else
{
low_farend_counter_
=
0
;
}
}
inaudible_echo_
=
(
max_nearend_
>
500
&
&
s_abs
<
30
.
f
)
|
|
(
!
converged_filter
&
&
x_abs
<
500
)
;
inaudible_echo_
=
inaudible_echo_
|
|
low_farend_counter_
>
20
;
}
void
AecState
:
:
EchoAudibility
:
:
UpdateWithOutput
(
rtc
:
:
ArrayView
<
const
float
>
e
)
{
const
float
e_max
=
*
std
:
:
max_element
(
e
.
begin
(
)
e
.
end
(
)
)
;
const
float
e_min
=
*
std
:
:
min_element
(
e
.
begin
(
)
e
.
end
(
)
)
;
const
float
e_abs
=
std
:
:
max
(
fabsf
(
e_max
)
fabsf
(
e_min
)
)
;
if
(
max_nearend_
<
e_abs
)
{
max_nearend_
=
e_abs
;
max_nearend_counter_
=
0
;
}
else
{
if
(
+
+
max_nearend_counter_
>
5
*
kNumBlocksPerSecond
)
{
max_nearend_
*
=
0
.
995f
;
}
}
}
}
