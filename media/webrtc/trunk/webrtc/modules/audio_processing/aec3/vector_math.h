#
ifndef
MODULES_AUDIO_PROCESSING_AEC3_VECTOR_MATH_H_
#
define
MODULES_AUDIO_PROCESSING_AEC3_VECTOR_MATH_H_
#
include
"
typedefs
.
h
"
#
if
defined
(
WEBRTC_HAS_NEON
)
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
#
include
<
arm64_neon
.
h
>
#
else
#
include
<
arm_neon
.
h
>
#
endif
#
endif
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
#
include
<
emmintrin
.
h
>
#
endif
#
include
<
math
.
h
>
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
functional
>
#
include
"
api
/
array_view
.
h
"
#
include
"
modules
/
audio_processing
/
aec3
/
aec3_common
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
namespace
aec3
{
class
VectorMath
{
public
:
explicit
VectorMath
(
Aec3Optimization
optimization
)
:
optimization_
(
optimization
)
{
}
void
Sqrt
(
rtc
:
:
ArrayView
<
float
>
x
)
{
switch
(
optimization_
)
{
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
case
Aec3Optimization
:
:
kSse2
:
{
const
int
x_size
=
static_cast
<
int
>
(
x
.
size
(
)
)
;
const
int
vector_limit
=
x_size
>
>
2
;
int
j
=
0
;
for
(
;
j
<
vector_limit
*
4
;
j
+
=
4
)
{
__m128
g
=
_mm_loadu_ps
(
&
x
[
j
]
)
;
g
=
_mm_sqrt_ps
(
g
)
;
_mm_storeu_ps
(
&
x
[
j
]
g
)
;
}
for
(
;
j
<
x_size
;
+
+
j
)
{
x
[
j
]
=
sqrtf
(
x
[
j
]
)
;
}
}
break
;
#
endif
#
if
defined
(
WEBRTC_HAS_NEON
)
case
Aec3Optimization
:
:
kNeon
:
{
const
int
x_size
=
static_cast
<
int
>
(
x
.
size
(
)
)
;
const
int
vector_limit
=
x_size
>
>
2
;
int
j
=
0
;
for
(
;
j
<
vector_limit
*
4
;
j
+
=
4
)
{
float32x4_t
g
=
vld1q_f32
(
&
x
[
j
]
)
;
#
if
!
defined
(
WEBRTC_ARCH_ARM64
)
|
|
(
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
)
float32x4_t
y
=
vrsqrteq_f32
(
g
)
;
const
uint32x4_t
vec_p_inf
=
vdupq_n_u32
(
0x7F800000
)
;
const
uint32x4_t
div_by_zero
=
vceqq_u32
(
vec_p_inf
vreinterpretq_u32_f32
(
y
)
)
;
y
=
vreinterpretq_f32_u32
(
vandq_u32
(
vmvnq_u32
(
div_by_zero
)
vreinterpretq_u32_f32
(
y
)
)
)
;
for
(
int
i
=
0
;
i
<
2
;
i
+
+
)
{
y
=
vmulq_f32
(
vrsqrtsq_f32
(
vmulq_f32
(
y
y
)
g
)
y
)
;
}
g
=
vmulq_f32
(
g
y
)
;
#
else
g
=
vsqrtq_f32
(
g
)
;
#
endif
vst1q_f32
(
&
x
[
j
]
g
)
;
}
for
(
;
j
<
x_size
;
+
+
j
)
{
x
[
j
]
=
sqrtf
(
x
[
j
]
)
;
}
}
#
endif
break
;
default
:
std
:
:
for_each
(
x
.
begin
(
)
x
.
end
(
)
[
]
(
float
&
a
)
{
a
=
sqrtf
(
a
)
;
}
)
;
}
}
void
Multiply
(
rtc
:
:
ArrayView
<
const
float
>
x
rtc
:
:
ArrayView
<
const
float
>
y
rtc
:
:
ArrayView
<
float
>
z
)
{
RTC_DCHECK_EQ
(
z
.
size
(
)
x
.
size
(
)
)
;
RTC_DCHECK_EQ
(
z
.
size
(
)
y
.
size
(
)
)
;
switch
(
optimization_
)
{
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
case
Aec3Optimization
:
:
kSse2
:
{
const
int
x_size
=
static_cast
<
int
>
(
x
.
size
(
)
)
;
const
int
vector_limit
=
x_size
>
>
2
;
int
j
=
0
;
for
(
;
j
<
vector_limit
*
4
;
j
+
=
4
)
{
const
__m128
x_j
=
_mm_loadu_ps
(
&
x
[
j
]
)
;
const
__m128
y_j
=
_mm_loadu_ps
(
&
y
[
j
]
)
;
const
__m128
z_j
=
_mm_mul_ps
(
x_j
y_j
)
;
_mm_storeu_ps
(
&
z
[
j
]
z_j
)
;
}
for
(
;
j
<
x_size
;
+
+
j
)
{
z
[
j
]
=
x
[
j
]
*
y
[
j
]
;
}
}
break
;
#
endif
#
if
defined
(
WEBRTC_HAS_NEON
)
case
Aec3Optimization
:
:
kNeon
:
{
const
int
x_size
=
static_cast
<
int
>
(
x
.
size
(
)
)
;
const
int
vector_limit
=
x_size
>
>
2
;
int
j
=
0
;
for
(
;
j
<
vector_limit
*
4
;
j
+
=
4
)
{
const
float32x4_t
x_j
=
vld1q_f32
(
&
x
[
j
]
)
;
const
float32x4_t
y_j
=
vld1q_f32
(
&
y
[
j
]
)
;
const
float32x4_t
z_j
=
vmulq_f32
(
x_j
y_j
)
;
vst1q_f32
(
&
z
[
j
]
z_j
)
;
}
for
(
;
j
<
x_size
;
+
+
j
)
{
z
[
j
]
=
x
[
j
]
*
y
[
j
]
;
}
}
break
;
#
endif
default
:
std
:
:
transform
(
x
.
begin
(
)
x
.
end
(
)
y
.
begin
(
)
z
.
begin
(
)
std
:
:
multiplies
<
float
>
(
)
)
;
}
}
void
Accumulate
(
rtc
:
:
ArrayView
<
const
float
>
x
rtc
:
:
ArrayView
<
float
>
z
)
{
RTC_DCHECK_EQ
(
z
.
size
(
)
x
.
size
(
)
)
;
switch
(
optimization_
)
{
#
if
defined
(
WEBRTC_ARCH_X86_FAMILY
)
case
Aec3Optimization
:
:
kSse2
:
{
const
int
x_size
=
static_cast
<
int
>
(
x
.
size
(
)
)
;
const
int
vector_limit
=
x_size
>
>
2
;
int
j
=
0
;
for
(
;
j
<
vector_limit
*
4
;
j
+
=
4
)
{
const
__m128
x_j
=
_mm_loadu_ps
(
&
x
[
j
]
)
;
__m128
z_j
=
_mm_loadu_ps
(
&
z
[
j
]
)
;
z_j
=
_mm_add_ps
(
x_j
z_j
)
;
_mm_storeu_ps
(
&
z
[
j
]
z_j
)
;
}
for
(
;
j
<
x_size
;
+
+
j
)
{
z
[
j
]
+
=
x
[
j
]
;
}
}
break
;
#
endif
#
if
defined
(
WEBRTC_HAS_NEON
)
case
Aec3Optimization
:
:
kNeon
:
{
const
int
x_size
=
static_cast
<
int
>
(
x
.
size
(
)
)
;
const
int
vector_limit
=
x_size
>
>
2
;
int
j
=
0
;
for
(
;
j
<
vector_limit
*
4
;
j
+
=
4
)
{
const
float32x4_t
x_j
=
vld1q_f32
(
&
x
[
j
]
)
;
float32x4_t
z_j
=
vld1q_f32
(
&
z
[
j
]
)
;
z_j
=
vaddq_f32
(
z_j
x_j
)
;
vst1q_f32
(
&
z
[
j
]
z_j
)
;
}
for
(
;
j
<
x_size
;
+
+
j
)
{
z
[
j
]
+
=
x
[
j
]
;
}
}
break
;
#
endif
default
:
std
:
:
transform
(
x
.
begin
(
)
x
.
end
(
)
z
.
begin
(
)
z
.
begin
(
)
std
:
:
plus
<
float
>
(
)
)
;
}
}
private
:
Aec3Optimization
optimization_
;
}
;
}
}
#
endif
