package
org
.
webrtc
.
videoengine
;
import
java
.
io
.
IOException
;
import
java
.
util
.
List
;
import
java
.
util
.
concurrent
.
Exchanger
;
import
android
.
content
.
Context
;
import
android
.
graphics
.
ImageFormat
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
hardware
.
Camera
.
Parameters
;
import
android
.
hardware
.
Camera
.
PreviewCallback
;
import
android
.
hardware
.
Camera
;
import
android
.
opengl
.
GLES11Ext
;
import
android
.
opengl
.
GLES20
;
import
android
.
os
.
Handler
;
import
android
.
os
.
Looper
;
import
android
.
os
.
SystemClock
;
import
android
.
util
.
Log
;
import
android
.
view
.
Surface
;
import
android
.
view
.
SurfaceHolder
.
Callback
;
import
android
.
view
.
SurfaceHolder
;
import
android
.
view
.
WindowManager
;
import
org
.
mozilla
.
gecko
.
annotation
.
WebRTCJNITarget
;
public
class
VideoCaptureAndroid
implements
PreviewCallback
Callback
{
private
final
static
String
TAG
=
"
WEBRTC
-
JC
"
;
private
static
SurfaceHolder
localPreview
;
private
Camera
camera
;
private
CameraThread
cameraThread
;
private
Handler
cameraThreadHandler
;
private
Context
context
;
private
final
int
id
;
private
final
Camera
.
CameraInfo
info
;
private
volatile
long
native_capturer
;
private
SurfaceTexture
cameraSurfaceTexture
;
private
int
[
]
cameraGlTextures
=
null
;
private
final
int
numCaptureBuffers
=
3
;
private
double
averageDurationMs
;
private
long
lastCaptureTimeMs
;
private
int
frameCount
;
private
int
frameDropRatio
;
public
static
void
setLocalPreview
(
SurfaceHolder
localPreview
)
{
VideoCaptureAndroid
.
localPreview
=
localPreview
;
}
WebRTCJNITarget
public
VideoCaptureAndroid
(
int
id
long
native_capturer
)
{
this
.
id
=
id
;
this
.
native_capturer
=
native_capturer
;
this
.
context
=
GetContext
(
)
;
this
.
info
=
new
Camera
.
CameraInfo
(
)
;
Camera
.
getCameraInfo
(
id
info
)
;
}
WebRTCJNITarget
private
static
native
Context
GetContext
(
)
;
private
static
final
class
CameraThread
extends
Thread
{
private
Exchanger
<
Handler
>
handlerExchanger
;
public
CameraThread
(
Exchanger
<
Handler
>
handlerExchanger
)
{
this
.
handlerExchanger
=
handlerExchanger
;
}
Override
public
void
run
(
)
{
Looper
.
prepare
(
)
;
exchange
(
handlerExchanger
new
Handler
(
)
)
;
Looper
.
loop
(
)
;
}
}
WebRTCJNITarget
private
synchronized
boolean
startCapture
(
final
int
width
final
int
height
final
int
min_mfps
final
int
max_mfps
)
{
Log
.
d
(
TAG
"
startCapture
:
"
+
width
+
"
x
"
+
height
+
"
"
+
min_mfps
+
"
:
"
+
max_mfps
)
;
if
(
cameraThread
=
=
null
&
&
cameraThreadHandler
=
=
null
)
{
Exchanger
<
Handler
>
handlerExchanger
=
new
Exchanger
<
Handler
>
(
)
;
cameraThread
=
new
CameraThread
(
handlerExchanger
)
;
cameraThread
.
start
(
)
;
cameraThreadHandler
=
exchange
(
handlerExchanger
null
)
;
}
final
Exchanger
<
Boolean
>
result
=
new
Exchanger
<
Boolean
>
(
)
;
cameraThreadHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
boolean
startResult
=
startCaptureOnCameraThread
(
width
height
min_mfps
max_mfps
)
;
if
(
!
startResult
)
{
Looper
.
myLooper
(
)
.
quit
(
)
;
}
exchange
(
result
startResult
)
;
}
}
)
;
boolean
startResult
=
exchange
(
result
false
)
;
if
(
!
startResult
)
{
try
{
cameraThread
.
join
(
)
;
}
catch
(
InterruptedException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
cameraThreadHandler
=
null
;
cameraThread
=
null
;
}
return
startResult
;
}
WebRTCJNITarget
private
void
unlinkCapturer
(
)
{
native_capturer
=
0
;
}
private
boolean
startCaptureOnCameraThread
(
int
width
int
height
int
min_mfps
int
max_mfps
)
{
Throwable
error
=
null
;
try
{
boolean
isRunning
=
camera
!
=
null
;
if
(
!
isRunning
)
{
camera
=
Camera
.
open
(
id
)
;
if
(
localPreview
!
=
null
)
{
localPreview
.
addCallback
(
this
)
;
if
(
localPreview
.
getSurface
(
)
!
=
null
&
&
localPreview
.
getSurface
(
)
.
isValid
(
)
)
{
try
{
camera
.
setPreviewDisplay
(
localPreview
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
}
else
{
try
{
cameraGlTextures
=
new
int
[
1
]
;
GLES20
.
glGenTextures
(
1
cameraGlTextures
0
)
;
GLES20
.
glBindTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
cameraGlTextures
[
0
]
)
;
GLES20
.
glTexParameterf
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
GLES20
.
GL_TEXTURE_MIN_FILTER
GLES20
.
GL_LINEAR
)
;
GLES20
.
glTexParameterf
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
GLES20
.
GL_TEXTURE_MAG_FILTER
GLES20
.
GL_LINEAR
)
;
GLES20
.
glTexParameteri
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
GLES20
.
GL_TEXTURE_WRAP_S
GLES20
.
GL_CLAMP_TO_EDGE
)
;
GLES20
.
glTexParameteri
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
GLES20
.
GL_TEXTURE_WRAP_T
GLES20
.
GL_CLAMP_TO_EDGE
)
;
cameraSurfaceTexture
=
new
SurfaceTexture
(
cameraGlTextures
[
0
]
)
;
cameraSurfaceTexture
.
setOnFrameAvailableListener
(
null
)
;
camera
.
setPreviewTexture
(
cameraSurfaceTexture
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
}
Log
.
d
(
TAG
"
Camera
orientation
:
"
+
info
.
orientation
+
"
.
Device
orientation
:
"
+
getDeviceOrientation
(
)
)
;
Camera
.
Parameters
parameters
=
camera
.
getParameters
(
)
;
if
(
isRunning
)
{
Camera
.
Size
size
=
parameters
.
getPreviewSize
(
)
;
int
[
]
fpsRange
=
new
int
[
2
]
;
parameters
.
getPreviewFpsRange
(
fpsRange
)
;
int
minFps
=
fpsRange
[
Parameters
.
PREVIEW_FPS_MIN_INDEX
]
/
frameDropRatio
;
int
maxFps
=
fpsRange
[
Parameters
.
PREVIEW_FPS_MAX_INDEX
]
/
frameDropRatio
;
if
(
size
.
width
=
=
width
&
&
size
.
height
=
=
height
&
&
minFps
=
=
min_mfps
&
&
maxFps
=
=
max_mfps
)
{
return
true
;
}
else
{
if
(
!
stopCaptureOnCameraThread
(
)
)
{
throw
new
RuntimeException
(
"
Stopping
on
reconfig
failed
"
)
;
}
return
startCaptureOnCameraThread
(
width
height
min_mfps
max_mfps
)
;
}
}
Log
.
d
(
TAG
"
isVideoStabilizationSupported
:
"
+
parameters
.
isVideoStabilizationSupported
(
)
)
;
if
(
parameters
.
isVideoStabilizationSupported
(
)
)
{
parameters
.
setVideoStabilization
(
true
)
;
}
List
<
String
>
focusModes
=
parameters
.
getSupportedFocusModes
(
)
;
if
(
focusModes
.
contains
(
android
.
hardware
.
Camera
.
Parameters
.
FOCUS_MODE_CONTINUOUS_VIDEO
)
)
{
Log
.
d
(
TAG
"
Enable
continuous
auto
focus
mode
.
"
)
;
parameters
.
setFocusMode
(
android
.
hardware
.
Camera
.
Parameters
.
FOCUS_MODE_CONTINUOUS_VIDEO
)
;
}
parameters
.
setPreviewSize
(
width
height
)
;
List
<
Camera
.
Size
>
supportedPictureSizes
=
parameters
.
getSupportedPictureSizes
(
)
;
Camera
.
Size
pictureSize
=
supportedPictureSizes
.
get
(
0
)
;
for
(
Camera
.
Size
size
:
supportedPictureSizes
)
{
if
(
size
.
width
<
width
|
|
size
.
height
<
height
)
{
continue
;
}
if
(
pictureSize
.
width
<
width
|
|
pictureSize
.
height
<
height
)
{
pictureSize
=
size
;
continue
;
}
if
(
size
.
width
<
=
pictureSize
.
width
&
&
size
.
height
<
=
pictureSize
.
height
)
{
pictureSize
=
size
;
}
}
parameters
.
setPictureSize
(
pictureSize
.
width
pictureSize
.
height
)
;
List
<
int
[
]
>
supportedFpsRanges
=
parameters
.
getSupportedPreviewFpsRange
(
)
;
frameDropRatio
=
Integer
.
MAX_VALUE
;
for
(
int
i
=
0
;
i
<
supportedFpsRanges
.
size
(
)
;
i
+
+
)
{
int
[
]
range
=
supportedFpsRanges
.
get
(
i
)
;
if
(
range
[
Parameters
.
PREVIEW_FPS_MIN_INDEX
]
=
=
min_mfps
&
&
range
[
Parameters
.
PREVIEW_FPS_MAX_INDEX
]
=
=
max_mfps
)
{
frameDropRatio
=
1
;
break
;
}
if
(
range
[
Parameters
.
PREVIEW_FPS_MIN_INDEX
]
%
min_mfps
=
=
0
&
&
range
[
Parameters
.
PREVIEW_FPS_MAX_INDEX
]
%
max_mfps
=
=
0
)
{
int
dropRatio
=
range
[
Parameters
.
PREVIEW_FPS_MAX_INDEX
]
/
max_mfps
;
frameDropRatio
=
Math
.
min
(
dropRatio
frameDropRatio
)
;
}
}
if
(
frameDropRatio
=
=
Integer
.
MAX_VALUE
)
{
Log
.
e
(
TAG
"
Can
not
find
camera
fps
range
"
)
;
throw
new
RuntimeException
(
"
Can
not
find
camera
fps
range
"
)
;
}
if
(
frameDropRatio
>
1
)
{
Log
.
d
(
TAG
"
Frame
dropper
is
enabled
.
Ratio
:
"
+
frameDropRatio
)
;
}
min_mfps
*
=
frameDropRatio
;
max_mfps
*
=
frameDropRatio
;
Log
.
d
(
TAG
"
Camera
preview
mfps
range
:
"
+
min_mfps
+
"
-
"
+
max_mfps
)
;
parameters
.
setPreviewFpsRange
(
min_mfps
max_mfps
)
;
int
format
=
ImageFormat
.
NV21
;
parameters
.
setPreviewFormat
(
format
)
;
camera
.
setParameters
(
parameters
)
;
int
bufSize
=
width
*
height
*
ImageFormat
.
getBitsPerPixel
(
format
)
/
8
;
for
(
int
i
=
0
;
i
<
numCaptureBuffers
;
i
+
+
)
{
camera
.
addCallbackBuffer
(
new
byte
[
bufSize
]
)
;
}
camera
.
setPreviewCallbackWithBuffer
(
this
)
;
frameCount
=
0
;
averageDurationMs
=
1000000
.
0f
/
(
max_mfps
/
frameDropRatio
)
;
camera
.
startPreview
(
)
;
return
true
;
}
catch
(
RuntimeException
e
)
{
error
=
e
;
}
Log
.
e
(
TAG
"
startCapture
failed
"
error
)
;
stopCaptureOnCameraThread
(
)
;
return
false
;
}
WebRTCJNITarget
private
synchronized
boolean
stopCapture
(
)
{
Log
.
d
(
TAG
"
stopCapture
"
)
;
final
Exchanger
<
Boolean
>
result
=
new
Exchanger
<
Boolean
>
(
)
;
cameraThreadHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
boolean
stopResult
=
stopCaptureOnCameraThread
(
)
;
Looper
.
myLooper
(
)
.
quit
(
)
;
exchange
(
result
stopResult
)
;
}
}
)
;
boolean
status
=
exchange
(
result
false
)
;
try
{
cameraThread
.
join
(
)
;
}
catch
(
InterruptedException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
cameraThreadHandler
=
null
;
cameraThread
=
null
;
Log
.
d
(
TAG
"
stopCapture
done
"
)
;
return
status
;
}
private
boolean
stopCaptureOnCameraThread
(
)
{
Throwable
error
=
null
;
try
{
if
(
camera
=
=
null
)
{
Log
.
e
(
TAG
"
Camera
is
already
stopped
!
"
)
;
throw
new
RuntimeException
(
"
Camera
is
already
stopped
!
"
)
;
}
camera
.
stopPreview
(
)
;
camera
.
setPreviewCallbackWithBuffer
(
null
)
;
camera
.
setPreviewTexture
(
null
)
;
cameraSurfaceTexture
=
null
;
if
(
cameraGlTextures
!
=
null
)
{
GLES20
.
glDeleteTextures
(
1
cameraGlTextures
0
)
;
cameraGlTextures
=
null
;
}
camera
.
release
(
)
;
camera
=
null
;
return
true
;
}
catch
(
IOException
e
)
{
error
=
e
;
}
catch
(
RuntimeException
e
)
{
error
=
e
;
}
Log
.
e
(
TAG
"
Failed
to
stop
camera
"
error
)
;
return
false
;
}
WebRTCJNITarget
private
int
getDeviceOrientation
(
)
{
int
orientation
=
0
;
if
(
context
!
=
null
)
{
WindowManager
wm
=
(
WindowManager
)
context
.
getSystemService
(
Context
.
WINDOW_SERVICE
)
;
switch
(
wm
.
getDefaultDisplay
(
)
.
getRotation
(
)
)
{
case
Surface
.
ROTATION_90
:
orientation
=
90
;
break
;
case
Surface
.
ROTATION_180
:
orientation
=
180
;
break
;
case
Surface
.
ROTATION_270
:
orientation
=
270
;
break
;
case
Surface
.
ROTATION_0
:
default
:
orientation
=
0
;
break
;
}
}
return
orientation
;
}
WebRTCJNITarget
private
native
void
ProvideCameraFrame
(
byte
[
]
data
int
length
int
rotation
long
timeStamp
long
captureObject
)
;
WebRTCJNITarget
Override
public
void
onPreviewFrame
(
byte
[
]
data
Camera
callbackCamera
)
{
if
(
Thread
.
currentThread
(
)
!
=
cameraThread
)
{
throw
new
RuntimeException
(
"
Camera
callback
not
on
camera
thread
?
!
?
"
)
;
}
if
(
camera
=
=
null
)
{
return
;
}
if
(
camera
!
=
callbackCamera
)
{
throw
new
RuntimeException
(
"
Unexpected
camera
in
callback
!
"
)
;
}
frameCount
+
+
;
if
(
(
frameDropRatio
>
1
)
&
&
(
frameCount
%
frameDropRatio
)
>
0
)
{
camera
.
addCallbackBuffer
(
data
)
;
return
;
}
long
captureTimeMs
=
SystemClock
.
elapsedRealtime
(
)
;
if
(
frameCount
>
frameDropRatio
)
{
double
durationMs
=
captureTimeMs
-
lastCaptureTimeMs
;
averageDurationMs
=
0
.
9
*
averageDurationMs
+
0
.
1
*
durationMs
;
if
(
(
frameCount
%
30
)
=
=
0
)
{
Log
.
d
(
TAG
"
Camera
TS
"
+
captureTimeMs
+
"
.
Duration
:
"
+
(
int
)
durationMs
+
"
ms
.
FPS
:
"
+
(
int
)
(
1000
/
averageDurationMs
+
0
.
5
)
)
;
}
}
lastCaptureTimeMs
=
captureTimeMs
;
int
rotation
=
getDeviceOrientation
(
)
;
if
(
info
.
facing
=
=
Camera
.
CameraInfo
.
CAMERA_FACING_BACK
)
{
rotation
=
360
-
rotation
;
}
rotation
=
(
info
.
orientation
+
rotation
)
%
360
;
ProvideCameraFrame
(
data
data
.
length
rotation
captureTimeMs
native_capturer
)
;
camera
.
addCallbackBuffer
(
data
)
;
}
private
synchronized
void
setPreviewRotation
(
final
int
rotation
)
{
if
(
camera
=
=
null
|
|
cameraThreadHandler
=
=
null
)
{
return
;
}
final
Exchanger
<
IOException
>
result
=
new
Exchanger
<
IOException
>
(
)
;
cameraThreadHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
setPreviewRotationOnCameraThread
(
rotation
result
)
;
}
}
)
;
exchange
(
result
null
)
;
}
private
void
setPreviewRotationOnCameraThread
(
int
rotation
Exchanger
<
IOException
>
result
)
{
Log
.
v
(
TAG
"
setPreviewRotation
:
"
+
rotation
)
;
int
resultRotation
=
0
;
if
(
info
.
facing
=
=
Camera
.
CameraInfo
.
CAMERA_FACING_FRONT
)
{
resultRotation
=
(
360
-
rotation
)
%
360
;
}
else
{
resultRotation
=
rotation
;
}
camera
.
setDisplayOrientation
(
resultRotation
)
;
exchange
(
result
null
)
;
}
WebRTCJNITarget
Override
public
synchronized
void
surfaceChanged
(
SurfaceHolder
holder
int
format
int
width
int
height
)
{
Log
.
d
(
TAG
"
VideoCaptureAndroid
:
:
surfaceChanged
ignored
:
"
+
format
+
"
:
"
+
width
+
"
x
"
+
height
)
;
}
WebRTCJNITarget
Override
public
synchronized
void
surfaceCreated
(
final
SurfaceHolder
holder
)
{
Log
.
d
(
TAG
"
VideoCaptureAndroid
:
:
surfaceCreated
"
)
;
if
(
camera
=
=
null
|
|
cameraThreadHandler
=
=
null
)
{
return
;
}
final
Exchanger
<
IOException
>
result
=
new
Exchanger
<
IOException
>
(
)
;
cameraThreadHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
setPreviewDisplayOnCameraThread
(
holder
result
)
;
}
}
)
;
IOException
e
=
exchange
(
result
null
)
;
if
(
e
!
=
null
)
{
throw
new
RuntimeException
(
e
)
;
}
}
WebRTCJNITarget
Override
public
synchronized
void
surfaceDestroyed
(
SurfaceHolder
holder
)
{
Log
.
d
(
TAG
"
VideoCaptureAndroid
:
:
surfaceDestroyed
"
)
;
if
(
camera
=
=
null
|
|
cameraThreadHandler
=
=
null
)
{
return
;
}
final
Exchanger
<
IOException
>
result
=
new
Exchanger
<
IOException
>
(
)
;
cameraThreadHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
setPreviewDisplayOnCameraThread
(
null
result
)
;
}
}
)
;
IOException
e
=
exchange
(
result
null
)
;
if
(
e
!
=
null
)
{
throw
new
RuntimeException
(
e
)
;
}
}
private
void
setPreviewDisplayOnCameraThread
(
SurfaceHolder
holder
Exchanger
<
IOException
>
result
)
{
try
{
camera
.
setPreviewDisplay
(
holder
)
;
}
catch
(
IOException
e
)
{
exchange
(
result
e
)
;
return
;
}
exchange
(
result
null
)
;
return
;
}
private
static
<
T
>
T
exchange
(
Exchanger
<
T
>
exchanger
T
value
)
{
try
{
return
exchanger
.
exchange
(
value
)
;
}
catch
(
InterruptedException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
}
