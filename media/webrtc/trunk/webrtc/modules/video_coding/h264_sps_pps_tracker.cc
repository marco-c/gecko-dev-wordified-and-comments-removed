#
include
"
webrtc
/
modules
/
video_coding
/
h264_sps_pps_tracker
.
h
"
#
include
<
string
>
#
include
<
utility
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
common_video
/
h264
/
h264_common
.
h
"
#
include
"
webrtc
/
common_video
/
h264
/
pps_parser
.
h
"
#
include
"
webrtc
/
common_video
/
h264
/
sps_parser
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
frame_object
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
packet_buffer
.
h
"
namespace
webrtc
{
namespace
video_coding
{
namespace
{
const
uint8_t
start_code_h264
[
]
=
{
0
0
0
1
}
;
}
H264SpsPpsTracker
:
:
PacketAction
H264SpsPpsTracker
:
:
CopyAndFixBitstream
(
VCMPacket
*
packet
)
{
RTC_DCHECK
(
packet
-
>
codec
=
=
kVideoCodecH264
)
;
const
uint8_t
*
data
=
packet
-
>
dataPtr
;
const
size_t
data_size
=
packet
-
>
sizeBytes
;
const
RTPVideoHeader
&
video_header
=
packet
-
>
video_header
;
const
RTPVideoHeaderH264
&
codec_header
=
video_header
.
codecHeader
.
H264
;
bool
insert_packet
=
codec_header
.
nalus_length
=
=
0
?
true
:
false
;
int
pps_id
=
-
1
;
size_t
required_size
=
0
;
for
(
size_t
i
=
0
;
i
<
codec_header
.
nalus_length
;
+
+
i
)
{
const
NaluInfo
&
nalu
=
codec_header
.
nalus
[
i
]
;
switch
(
nalu
.
type
)
{
case
H264
:
:
NaluType
:
:
kSps
:
{
sps_data_
[
nalu
.
sps_id
]
.
size
=
nalu
.
size
;
sps_data_
[
nalu
.
sps_id
]
.
data
.
reset
(
new
uint8_t
[
nalu
.
size
]
)
;
memcpy
(
sps_data_
[
nalu
.
sps_id
]
.
data
.
get
(
)
data
+
nalu
.
offset
nalu
.
size
)
;
break
;
}
case
H264
:
:
NaluType
:
:
kPps
:
{
pps_data_
[
nalu
.
pps_id
]
.
sps_id
=
nalu
.
sps_id
;
pps_data_
[
nalu
.
pps_id
]
.
size
=
nalu
.
size
;
pps_data_
[
nalu
.
pps_id
]
.
data
.
reset
(
new
uint8_t
[
nalu
.
size
]
)
;
memcpy
(
pps_data_
[
nalu
.
pps_id
]
.
data
.
get
(
)
data
+
nalu
.
offset
nalu
.
size
)
;
break
;
}
case
H264
:
:
NaluType
:
:
kIdr
:
{
if
(
video_header
.
is_first_packet_in_frame
)
{
if
(
nalu
.
pps_id
=
=
-
1
)
{
LOG
(
LS_WARNING
)
<
<
"
No
PPS
id
in
IDR
nalu
.
"
;
return
kRequestKeyframe
;
}
auto
pps
=
pps_data_
.
find
(
nalu
.
pps_id
)
;
if
(
pps
=
=
pps_data_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
No
PPS
with
id
<
<
"
<
<
nalu
.
pps_id
<
<
"
received
"
;
return
kRequestKeyframe
;
}
auto
sps
=
sps_data_
.
find
(
pps
-
>
second
.
sps_id
)
;
if
(
sps
=
=
sps_data_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
No
SPS
with
id
<
<
"
<
<
pps_data_
[
nalu
.
pps_id
]
.
sps_id
<
<
"
received
"
;
return
kRequestKeyframe
;
}
pps_id
=
nalu
.
pps_id
;
required_size
+
=
pps
-
>
second
.
size
+
sizeof
(
start_code_h264
)
;
required_size
+
=
sps
-
>
second
.
size
+
sizeof
(
start_code_h264
)
;
}
FALLTHROUGH
(
)
;
}
default
:
{
insert_packet
=
true
;
}
}
}
if
(
!
insert_packet
)
return
kDrop
;
if
(
codec_header
.
packetization_type
=
=
kH264StapA
)
{
const
uint8_t
*
nalu_ptr
=
data
+
1
;
while
(
nalu_ptr
<
data
+
data_size
)
{
RTC_DCHECK
(
video_header
.
is_first_packet_in_frame
)
;
required_size
+
=
sizeof
(
start_code_h264
)
;
uint16_t
segment_length
=
nalu_ptr
[
0
]
<
<
8
|
nalu_ptr
[
1
]
;
nalu_ptr
+
=
2
;
required_size
+
=
segment_length
;
nalu_ptr
+
=
segment_length
;
}
}
else
{
if
(
video_header
.
is_first_packet_in_frame
)
required_size
+
=
sizeof
(
start_code_h264
)
;
required_size
+
=
data_size
;
}
uint8_t
*
buffer
=
new
uint8_t
[
required_size
]
;
uint8_t
*
insert_at
=
buffer
;
if
(
pps_id
!
=
-
1
)
{
memcpy
(
insert_at
start_code_h264
sizeof
(
start_code_h264
)
)
;
insert_at
+
=
sizeof
(
start_code_h264
)
;
memcpy
(
insert_at
sps_data_
[
pps_data_
[
pps_id
]
.
sps_id
]
.
data
.
get
(
)
sps_data_
[
pps_data_
[
pps_id
]
.
sps_id
]
.
size
)
;
insert_at
+
=
sps_data_
[
pps_data_
[
pps_id
]
.
sps_id
]
.
size
;
memcpy
(
insert_at
start_code_h264
sizeof
(
start_code_h264
)
)
;
insert_at
+
=
sizeof
(
start_code_h264
)
;
memcpy
(
insert_at
pps_data_
[
pps_id
]
.
data
.
get
(
)
pps_data_
[
pps_id
]
.
size
)
;
insert_at
+
=
pps_data_
[
pps_id
]
.
size
;
}
if
(
codec_header
.
packetization_type
=
=
kH264StapA
)
{
const
uint8_t
*
nalu_ptr
=
data
+
1
;
while
(
nalu_ptr
<
data
+
data_size
)
{
memcpy
(
insert_at
start_code_h264
sizeof
(
start_code_h264
)
)
;
insert_at
+
=
sizeof
(
start_code_h264
)
;
uint16_t
segment_length
=
nalu_ptr
[
0
]
<
<
8
|
nalu_ptr
[
1
]
;
nalu_ptr
+
=
2
;
size_t
copy_end
=
nalu_ptr
-
data
+
segment_length
;
if
(
copy_end
>
data_size
)
{
delete
[
]
buffer
;
return
kDrop
;
}
memcpy
(
insert_at
nalu_ptr
segment_length
)
;
insert_at
+
=
segment_length
;
nalu_ptr
+
=
segment_length
;
}
}
else
{
if
(
video_header
.
is_first_packet_in_frame
)
{
memcpy
(
insert_at
start_code_h264
sizeof
(
start_code_h264
)
)
;
insert_at
+
=
sizeof
(
start_code_h264
)
;
}
memcpy
(
insert_at
data
data_size
)
;
}
packet
-
>
dataPtr
=
buffer
;
packet
-
>
sizeBytes
=
required_size
;
return
kInsert
;
}
void
H264SpsPpsTracker
:
:
InsertSpsPps
(
const
std
:
:
vector
<
uint8_t
>
&
sps
const
std
:
:
vector
<
uint8_t
>
&
pps
)
{
rtc
:
:
Optional
<
SpsParser
:
:
SpsState
>
parsed_sps
=
SpsParser
:
:
ParseSps
(
sps
.
data
(
)
sps
.
size
(
)
)
;
rtc
:
:
Optional
<
PpsParser
:
:
PpsState
>
parsed_pps
=
PpsParser
:
:
ParsePps
(
pps
.
data
(
)
pps
.
size
(
)
)
;
if
(
!
parsed_pps
|
|
!
parsed_sps
)
{
LOG
(
LS_WARNING
)
<
<
"
Failed
to
parse
SPS
or
PPS
parameters
.
"
;
return
;
}
SpsInfo
sps_info
;
sps_info
.
size
=
sps
.
size
(
)
;
uint8_t
*
sps_data
=
new
uint8_t
[
sps_info
.
size
]
;
memcpy
(
sps_data
sps
.
data
(
)
sps_info
.
size
)
;
sps_info
.
data
.
reset
(
sps_data
)
;
sps_data_
[
parsed_sps
-
>
id
]
=
std
:
:
move
(
sps_info
)
;
PpsInfo
pps_info
;
pps_info
.
size
=
pps
.
size
(
)
;
pps_info
.
sps_id
=
parsed_pps
-
>
sps_id
;
uint8_t
*
pps_data
=
new
uint8_t
[
pps_info
.
size
]
;
memcpy
(
pps_data
pps
.
data
(
)
pps_info
.
size
)
;
pps_info
.
data
.
reset
(
pps_data
)
;
pps_data_
[
parsed_pps
-
>
id
]
=
std
:
:
move
(
pps_info
)
;
}
}
}
