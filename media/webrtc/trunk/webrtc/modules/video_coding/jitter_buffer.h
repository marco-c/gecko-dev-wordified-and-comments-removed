#
ifndef
MODULES_VIDEO_CODING_JITTER_BUFFER_H_
#
define
MODULES_VIDEO_CODING_JITTER_BUFFER_H_
#
include
<
list
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
vector
>
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
modules
/
utility
/
include
/
process_thread
.
h
"
#
include
"
modules
/
video_coding
/
decoding_state
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_coding
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_coding_defines
.
h
"
#
include
"
modules
/
video_coding
/
inter_frame_delay
.
h
"
#
include
"
modules
/
video_coding
/
jitter_buffer_common
.
h
"
#
include
"
modules
/
video_coding
/
jitter_estimator
.
h
"
#
include
"
modules
/
video_coding
/
nack_module
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
thread_annotations
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
enum
VCMNackMode
{
kNack
kNoNack
}
;
class
Clock
;
class
EventFactory
;
class
EventWrapper
;
class
VCMFrameBuffer
;
class
VCMPacket
;
class
VCMEncodedFrame
;
typedef
std
:
:
list
<
VCMFrameBuffer
*
>
UnorderedFrameList
;
struct
VCMJitterSample
{
VCMJitterSample
(
)
:
timestamp
(
0
)
frame_size
(
0
)
latest_packet_time
(
-
1
)
{
}
uint32_t
timestamp
;
uint32_t
frame_size
;
int64_t
latest_packet_time
;
}
;
class
TimestampLessThan
{
public
:
bool
operator
(
)
(
uint32_t
timestamp1
uint32_t
timestamp2
)
const
{
return
IsNewerTimestamp
(
timestamp2
timestamp1
)
;
}
}
;
class
FrameList
:
public
std
:
:
map
<
uint32_t
VCMFrameBuffer
*
TimestampLessThan
>
{
public
:
void
InsertFrame
(
VCMFrameBuffer
*
frame
)
;
VCMFrameBuffer
*
FindFrame
(
uint16_t
seq_num
uint32_t
timestamp
)
;
VCMFrameBuffer
*
PopFrame
(
uint32_t
timestamp
)
;
VCMFrameBuffer
*
Front
(
)
const
;
VCMFrameBuffer
*
Back
(
)
const
;
int
RecycleFramesUntilKeyFrame
(
FrameList
:
:
iterator
*
key_frame_it
UnorderedFrameList
*
free_frames
)
;
void
CleanUpOldOrEmptyFrames
(
VCMDecodingState
*
decoding_state
UnorderedFrameList
*
free_frames
)
;
void
Reset
(
UnorderedFrameList
*
free_frames
)
;
}
;
class
Vp9SsMap
{
public
:
typedef
std
:
:
map
<
uint32_t
GofInfoVP9
TimestampLessThan
>
SsMap
;
bool
Insert
(
const
VCMPacket
&
packet
)
;
void
Reset
(
)
;
void
RemoveOld
(
uint32_t
timestamp
)
;
bool
UpdatePacket
(
VCMPacket
*
packet
)
;
void
UpdateFrames
(
FrameList
*
frames
)
;
bool
Find
(
uint32_t
timestamp
SsMap
:
:
iterator
*
it
)
;
private
:
bool
TimeForCleanup
(
uint32_t
timestamp
)
const
;
void
AdvanceFront
(
uint32_t
timestamp
)
;
SsMap
ss_map_
;
}
;
class
VCMJitterBuffer
{
public
:
VCMJitterBuffer
(
Clock
*
clock
std
:
:
unique_ptr
<
EventWrapper
>
event
NackSender
*
nack_sender
=
nullptr
KeyFrameRequestSender
*
keyframe_request_sender
=
nullptr
)
;
~
VCMJitterBuffer
(
)
;
void
Start
(
)
;
void
Stop
(
)
;
bool
Running
(
)
const
;
void
Flush
(
)
;
FrameCounts
FrameStatistics
(
)
const
;
int
num_packets
(
)
const
;
int
num_duplicated_packets
(
)
const
;
int
num_discarded_packets
(
)
const
;
void
IncomingRateStatistics
(
unsigned
int
*
framerate
unsigned
int
*
bitrate
)
;
VCMEncodedFrame
*
NextCompleteFrame
(
uint32_t
max_wait_time_ms
)
;
bool
NextMaybeIncompleteTimestamp
(
uint32_t
*
timestamp
)
;
VCMEncodedFrame
*
ExtractAndSetDecode
(
uint32_t
timestamp
)
;
void
ReleaseFrame
(
VCMEncodedFrame
*
frame
)
;
int64_t
LastPacketTime
(
const
VCMEncodedFrame
*
frame
bool
*
retransmitted
)
const
;
VCMFrameBufferEnum
InsertPacket
(
const
VCMPacket
&
packet
bool
*
retransmitted
)
;
uint32_t
EstimatedJitterMs
(
)
;
void
UpdateRtt
(
int64_t
rtt_ms
)
;
void
SetNackMode
(
VCMNackMode
mode
int64_t
low_rtt_nack_threshold_ms
int64_t
high_rtt_nack_threshold_ms
)
;
void
SetNackSettings
(
size_t
max_nack_list_size
int
max_packet_age_to_nack
int
max_incomplete_time_ms
)
;
VCMNackMode
nack_mode
(
)
const
;
std
:
:
vector
<
uint16_t
>
GetNackList
(
bool
*
request_key_frame
)
;
void
SetDecodeErrorMode
(
VCMDecodeErrorMode
error_mode
)
;
VCMDecodeErrorMode
decode_error_mode
(
)
const
{
return
decode_error_mode_
;
}
void
RegisterStatsCallback
(
VCMReceiveStatisticsCallback
*
callback
)
;
private
:
class
SequenceNumberLessThan
{
public
:
bool
operator
(
)
(
const
uint16_t
&
sequence_number1
const
uint16_t
&
sequence_number2
)
const
{
return
IsNewerSequenceNumber
(
sequence_number2
sequence_number1
)
;
}
}
;
typedef
std
:
:
set
<
uint16_t
SequenceNumberLessThan
>
SequenceNumberSet
;
VCMFrameBufferEnum
GetFrame
(
const
VCMPacket
&
packet
VCMFrameBuffer
*
*
frame
FrameList
*
*
frame_list
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
bool
IsContinuousInState
(
const
VCMFrameBuffer
&
frame
const
VCMDecodingState
&
decoding_state
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
bool
IsContinuous
(
const
VCMFrameBuffer
&
frame
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
void
FindAndInsertContinuousFramesWithState
(
const
VCMDecodingState
&
decoded_state
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
void
FindAndInsertContinuousFrames
(
const
VCMFrameBuffer
&
new_frame
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
VCMFrameBuffer
*
NextFrame
(
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
bool
UpdateNackList
(
uint16_t
sequence_number
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
bool
TooLargeNackList
(
)
const
;
bool
HandleTooLargeNackList
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
bool
MissingTooOldPacket
(
uint16_t
latest_sequence_number
)
const
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
bool
HandleTooOldPackets
(
uint16_t
latest_sequence_number
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
void
DropPacketsFromNackList
(
uint16_t
last_decoded_sequence_number
)
;
VCMFrameBuffer
*
GetEmptyFrame
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
bool
TryToIncreaseJitterBufferSize
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
bool
RecycleFramesUntilKeyFrame
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
void
CountFrame
(
const
VCMFrameBuffer
&
frame
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
void
UpdateAveragePacketsPerFrame
(
int
current_number_packets_
)
;
void
CleanUpOldOrEmptyFrames
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
bool
IsPacketRetransmitted
(
const
VCMPacket
&
packet
)
const
;
void
UpdateJitterEstimate
(
const
VCMJitterSample
&
sample
bool
incomplete_frame
)
;
void
UpdateJitterEstimate
(
const
VCMFrameBuffer
&
frame
bool
incomplete_frame
)
;
void
UpdateJitterEstimate
(
int64_t
latest_packet_time_ms
uint32_t
timestamp
unsigned
int
frame_size
bool
incomplete_frame
)
;
bool
WaitForRetransmissions
(
)
;
int
NonContinuousOrIncompleteDuration
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
uint16_t
EstimatedLowSequenceNumber
(
const
VCMFrameBuffer
&
frame
)
const
;
void
UpdateHistograms
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
void
RecycleFrameBuffer
(
VCMFrameBuffer
*
frame
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
Clock
*
clock_
;
bool
running_
;
rtc
:
:
CriticalSection
crit_sect_
;
std
:
:
unique_ptr
<
EventWrapper
>
frame_event_
;
int
max_number_of_frames_
;
UnorderedFrameList
free_frames_
RTC_GUARDED_BY
(
crit_sect_
)
;
FrameList
decodable_frames_
RTC_GUARDED_BY
(
crit_sect_
)
;
FrameList
incomplete_frames_
RTC_GUARDED_BY
(
crit_sect_
)
;
VCMDecodingState
last_decoded_state_
RTC_GUARDED_BY
(
crit_sect_
)
;
bool
first_packet_since_reset_
;
VCMReceiveStatisticsCallback
*
stats_callback_
RTC_GUARDED_BY
(
crit_sect_
)
;
FrameCounts
receive_statistics_
;
unsigned
int
incoming_frame_rate_
;
unsigned
int
incoming_frame_count_
;
int64_t
time_last_incoming_frame_count_
;
unsigned
int
incoming_bit_count_
;
unsigned
int
incoming_bit_rate_
;
int
num_consecutive_old_packets_
;
int
num_packets_
RTC_GUARDED_BY
(
crit_sect_
)
;
int
num_duplicated_packets_
RTC_GUARDED_BY
(
crit_sect_
)
;
int
num_discarded_packets_
RTC_GUARDED_BY
(
crit_sect_
)
;
int64_t
time_first_packet_ms_
RTC_GUARDED_BY
(
crit_sect_
)
;
VCMJitterEstimator
jitter_estimate_
;
VCMInterFrameDelay
inter_frame_delay_
;
VCMJitterSample
waiting_for_completion_
;
int64_t
rtt_ms_
;
VCMNackMode
nack_mode_
;
int64_t
low_rtt_nack_threshold_ms_
;
int64_t
high_rtt_nack_threshold_ms_
;
SequenceNumberSet
missing_sequence_numbers_
;
uint16_t
latest_received_sequence_number_
;
size_t
max_nack_list_size_
;
int
max_packet_age_to_nack_
;
int
max_incomplete_time_ms_
;
VCMDecodeErrorMode
decode_error_mode_
;
float
average_packets_per_frame_
;
int
frame_counter_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
VCMJitterBuffer
)
;
}
;
}
#
endif
