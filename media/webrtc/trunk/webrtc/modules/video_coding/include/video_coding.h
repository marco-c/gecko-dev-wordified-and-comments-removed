#
ifndef
MODULES_VIDEO_CODING_INCLUDE_VIDEO_CODING_H_
#
define
MODULES_VIDEO_CODING_INCLUDE_VIDEO_CODING_H_
#
if
defined
(
WEBRTC_WIN
)
#
include
<
windows
.
h
>
#
endif
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
modules
/
include
/
module
.
h
"
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_coding_defines
.
h
"
#
include
"
system_wrappers
/
include
/
event_wrapper
.
h
"
namespace
webrtc
{
class
Clock
;
class
EncodedImageCallback
;
class
VCMQMSettingsCallback
;
class
VideoBitrateAllocator
;
class
VideoEncoder
;
class
VideoDecoder
;
struct
CodecSpecificInfo
;
class
EventFactory
{
public
:
virtual
~
EventFactory
(
)
{
}
virtual
EventWrapper
*
CreateEvent
(
)
=
0
;
}
;
class
EventFactoryImpl
:
public
EventFactory
{
public
:
virtual
~
EventFactoryImpl
(
)
{
}
virtual
EventWrapper
*
CreateEvent
(
)
{
return
EventWrapper
:
:
Create
(
)
;
}
}
;
enum
VCMDecodeErrorMode
{
kNoErrors
kSelectiveErrors
kWithErrors
}
;
class
VideoCodingModule
:
public
Module
{
public
:
enum
SenderNackMode
{
kNackNone
kNackAll
kNackSelective
}
;
static
VideoCodingModule
*
Create
(
Clock
*
clock
EventFactory
*
event_factory
)
;
virtual
int32_t
RegisterSendCodec
(
const
VideoCodec
*
sendCodec
uint32_t
numberOfCores
uint32_t
maxPayloadSize
)
=
0
;
virtual
int32_t
RegisterExternalEncoder
(
VideoEncoder
*
externalEncoder
uint8_t
payloadType
bool
internalSource
=
false
)
=
0
;
virtual
int
Bitrate
(
unsigned
int
*
bitrate
)
const
=
0
;
virtual
int
FrameRate
(
unsigned
int
*
framerate
)
const
=
0
;
virtual
int32_t
SetChannelParameters
(
uint32_t
target_bitrate
uint8_t
lossRate
int64_t
rtt
)
=
0
;
virtual
int32_t
SetReceiveChannelParameters
(
int64_t
rtt
)
=
0
;
virtual
int32_t
RegisterProtectionCallback
(
VCMProtectionCallback
*
protection
)
=
0
;
virtual
int32_t
SetVideoProtection
(
VCMVideoProtection
videoProtection
bool
enable
)
=
0
;
virtual
int32_t
AddVideoFrame
(
const
VideoFrame
&
videoFrame
const
CodecSpecificInfo
*
codecSpecificInfo
=
NULL
)
=
0
;
virtual
int32_t
IntraFrameRequest
(
size_t
stream_index
)
=
0
;
virtual
int32_t
EnableFrameDropper
(
bool
enable
)
=
0
;
virtual
int32_t
RegisterReceiveCodec
(
const
VideoCodec
*
receiveCodec
int32_t
numberOfCores
bool
requireKeyFrame
=
false
)
=
0
;
virtual
void
RegisterExternalDecoder
(
VideoDecoder
*
externalDecoder
uint8_t
payloadType
)
=
0
;
virtual
int32_t
RegisterReceiveCallback
(
VCMReceiveCallback
*
receiveCallback
)
=
0
;
virtual
int32_t
RegisterReceiveStatisticsCallback
(
VCMReceiveStatisticsCallback
*
receiveStats
)
=
0
;
virtual
int32_t
RegisterFrameTypeCallback
(
VCMFrameTypeCallback
*
frameTypeCallback
)
=
0
;
virtual
int32_t
RegisterPacketRequestCallback
(
VCMPacketRequestCallback
*
callback
)
=
0
;
virtual
int32_t
Decode
(
uint16_t
maxWaitTimeMs
=
200
)
=
0
;
virtual
int32_t
IncomingPacket
(
const
uint8_t
*
incomingPayload
size_t
payloadLength
const
WebRtcRTPHeader
&
rtpInfo
)
=
0
;
virtual
int32_t
SetMinimumPlayoutDelay
(
uint32_t
minPlayoutDelayMs
)
=
0
;
virtual
int32_t
SetRenderDelay
(
uint32_t
timeMS
)
=
0
;
virtual
int32_t
Delay
(
)
const
=
0
;
enum
ReceiverRobustness
{
kNone
kHardNack
}
;
virtual
int
SetReceiverRobustnessMode
(
ReceiverRobustness
robustnessMode
VCMDecodeErrorMode
errorMode
)
=
0
;
virtual
void
SetDecodeErrorMode
(
VCMDecodeErrorMode
decode_error_mode
)
=
0
;
virtual
void
SetNackSettings
(
size_t
max_nack_list_size
int
max_packet_age_to_nack
int
max_incomplete_time_ms
)
=
0
;
virtual
int
SetMinReceiverDelay
(
int
desired_delay_ms
)
=
0
;
virtual
void
RegisterPostEncodeImageCallback
(
EncodedImageCallback
*
post_encode_callback
)
=
0
;
virtual
void
TriggerDecoderShutdown
(
)
=
0
;
}
;
}
#
endif
