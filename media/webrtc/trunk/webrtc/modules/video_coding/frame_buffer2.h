#
ifndef
WEBRTC_MODULES_VIDEO_CODING_FRAME_BUFFER2_H_
#
define
WEBRTC_MODULES_VIDEO_CODING_FRAME_BUFFER2_H_
#
include
<
array
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
utility
>
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
#
include
"
webrtc
/
base
/
criticalsection
.
h
"
#
include
"
webrtc
/
base
/
event
.
h
"
#
include
"
webrtc
/
base
/
thread_annotations
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
frame_object
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
include
/
video_coding_defines
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
inter_frame_delay
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
sequence_number_util
.
h
"
namespace
webrtc
{
class
Clock
;
class
VCMJitterEstimator
;
class
VCMTiming
;
namespace
video_coding
{
class
FrameBuffer
{
public
:
enum
ReturnReason
{
kFrameFound
kTimeout
kStopped
}
;
FrameBuffer
(
Clock
*
clock
VCMJitterEstimator
*
jitter_estimator
VCMTiming
*
timing
)
;
virtual
~
FrameBuffer
(
)
;
int
InsertFrame
(
std
:
:
unique_ptr
<
FrameObject
>
frame
)
;
ReturnReason
NextFrame
(
int64_t
max_wait_time_ms
std
:
:
unique_ptr
<
FrameObject
>
*
frame_out
)
;
void
SetProtectionMode
(
VCMVideoProtection
mode
)
;
void
Start
(
)
;
void
Stop
(
)
;
private
:
struct
FrameKey
{
FrameKey
(
)
:
picture_id
(
0
)
spatial_layer
(
0
)
{
}
FrameKey
(
uint16_t
picture_id
uint8_t
spatial_layer
)
:
picture_id
(
picture_id
)
spatial_layer
(
spatial_layer
)
{
}
bool
operator
<
(
const
FrameKey
&
rhs
)
const
{
if
(
picture_id
=
=
rhs
.
picture_id
)
return
spatial_layer
<
rhs
.
spatial_layer
;
return
AheadOf
(
rhs
.
picture_id
picture_id
)
;
}
bool
operator
<
=
(
const
FrameKey
&
rhs
)
const
{
return
!
(
rhs
<
*
this
)
;
}
uint16_t
picture_id
;
uint8_t
spatial_layer
;
}
;
struct
FrameInfo
{
static
constexpr
size_t
kMaxNumDependentFrames
=
8
;
FrameKey
dependent_frames
[
kMaxNumDependentFrames
]
;
size_t
num_dependent_frames
=
0
;
size_t
num_missing_continuous
=
0
;
size_t
num_missing_decodable
=
0
;
bool
continuous
=
false
;
std
:
:
unique_ptr
<
FrameObject
>
frame
;
}
;
using
FrameMap
=
std
:
:
map
<
FrameKey
FrameInfo
>
;
void
PropagateContinuity
(
FrameMap
:
:
iterator
start
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
void
PropagateDecodability
(
const
FrameInfo
&
info
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
void
AdvanceLastDecodedFrame
(
FrameMap
:
:
iterator
decoded
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
bool
UpdateFrameInfoWithIncomingFrame
(
const
FrameObject
&
frame
FrameMap
:
:
iterator
info
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
void
UpdateJitterDelay
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
void
ClearFramesAndHistory
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
void
UpdateHistograms
(
)
const
;
FrameMap
frames_
GUARDED_BY
(
crit_
)
;
rtc
:
:
CriticalSection
crit_
;
Clock
*
const
clock_
;
rtc
:
:
Event
new_countinuous_frame_event_
;
VCMJitterEstimator
*
const
jitter_estimator_
GUARDED_BY
(
crit_
)
;
VCMTiming
*
const
timing_
GUARDED_BY
(
crit_
)
;
VCMInterFrameDelay
inter_frame_delay_
GUARDED_BY
(
crit_
)
;
FrameMap
:
:
iterator
last_decoded_frame_it_
GUARDED_BY
(
crit_
)
;
FrameMap
:
:
iterator
last_continuous_frame_it_
GUARDED_BY
(
crit_
)
;
int
num_frames_history_
GUARDED_BY
(
crit_
)
;
int
num_frames_buffered_
GUARDED_BY
(
crit_
)
;
bool
stopped_
GUARDED_BY
(
crit_
)
;
VCMVideoProtection
protection_mode_
GUARDED_BY
(
crit_
)
;
RTC_DISALLOW_IMPLICIT_CONSTRUCTORS
(
FrameBuffer
)
;
int64_t
accumulated_delay_
=
0
;
int64_t
accumulated_delay_samples_
=
0
;
int64_t
num_total_frames_
=
0
;
int64_t
num_key_frames_
=
0
;
}
;
}
}
#
endif
