#
include
"
webrtc
/
modules
/
video_coding
/
codecs
/
vp9
/
vp9_impl
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
time
.
h
>
#
include
<
vector
>
#
include
"
vpx
/
vpx_encoder
.
h
"
#
include
"
vpx
/
vpx_decoder
.
h
"
#
include
"
vpx
/
vp8cx
.
h
"
#
include
"
vpx
/
vp8dx
.
h
"
#
include
"
webrtc
/
base
/
bind
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
trace_event
.
h
"
#
include
"
webrtc
/
common
.
h
"
#
include
"
webrtc
/
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
include
"
webrtc
/
modules
/
interface
/
module_common_types
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
codecs
/
vp9
/
screenshare_layers
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
logging
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
tick_util
.
h
"
namespace
{
static
void
WrappedI420BufferNoLongerUsedCb
(
webrtc
:
:
Vp9FrameBufferPool
:
:
Vp9FrameBuffer
*
img_buffer
)
{
img_buffer
-
>
Release
(
)
;
}
}
namespace
webrtc
{
int
GetCpuSpeed
(
int
width
int
height
)
{
if
(
width
*
height
<
=
352
*
288
)
return
5
;
else
return
7
;
}
VP9Encoder
*
VP9Encoder
:
:
Create
(
)
{
return
new
VP9EncoderImpl
(
)
;
}
void
VP9EncoderImpl
:
:
EncoderOutputCodedPacketCallback
(
vpx_codec_cx_pkt
*
pkt
void
*
user_data
)
{
VP9EncoderImpl
*
enc
=
(
VP9EncoderImpl
*
)
(
user_data
)
;
enc
-
>
GetEncodedLayerFrame
(
pkt
)
;
}
VP9EncoderImpl
:
:
VP9EncoderImpl
(
)
:
encoded_image_
(
)
encoded_complete_callback_
(
NULL
)
inited_
(
false
)
timestamp_
(
0
)
picture_id_
(
0
)
cpu_speed_
(
3
)
rc_max_intra_target_
(
0
)
encoder_
(
NULL
)
config_
(
NULL
)
raw_
(
NULL
)
input_image_
(
NULL
)
tl0_pic_idx_
(
0
)
frames_since_kf_
(
0
)
num_temporal_layers_
(
0
)
num_spatial_layers_
(
0
)
num_cores_
(
0
)
frames_encoded_
(
0
)
spatial_layer_
(
new
ScreenshareLayersVP9
(
2
)
)
{
memset
(
&
codec_
0
sizeof
(
codec_
)
)
;
uint32_t
seed
=
static_cast
<
uint32_t
>
(
TickTime
:
:
MillisecondTimestamp
(
)
)
;
srand
(
seed
)
;
}
VP9EncoderImpl
:
:
~
VP9EncoderImpl
(
)
{
Release
(
)
;
}
int
VP9EncoderImpl
:
:
Release
(
)
{
if
(
encoded_image_
.
_buffer
!
=
NULL
)
{
delete
[
]
encoded_image_
.
_buffer
;
encoded_image_
.
_buffer
=
NULL
;
}
if
(
encoder_
!
=
NULL
)
{
if
(
vpx_codec_destroy
(
encoder_
)
)
{
return
WEBRTC_VIDEO_CODEC_MEMORY
;
}
delete
encoder_
;
encoder_
=
NULL
;
}
if
(
config_
!
=
NULL
)
{
delete
config_
;
config_
=
NULL
;
}
if
(
raw_
!
=
NULL
)
{
vpx_img_free
(
raw_
)
;
raw_
=
NULL
;
}
inited_
=
false
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
bool
VP9EncoderImpl
:
:
ExplicitlyConfiguredSpatialLayers
(
)
const
{
#
ifdef
LIBVPX_SVC
return
num_spatial_layers_
>
1
&
&
codec_
.
spatialLayers
[
0
]
.
target_bitrate_bps
>
0
;
#
else
return
false
;
#
endif
}
bool
VP9EncoderImpl
:
:
SetSvcRates
(
)
{
uint8_t
i
=
0
;
if
(
ExplicitlyConfiguredSpatialLayers
(
)
)
{
#
ifdef
LIBVPX_SVC
if
(
num_temporal_layers_
>
1
)
{
LOG
(
LS_ERROR
)
<
<
"
Multiple
temporal
layers
when
manually
specifying
"
"
spatial
layers
not
implemented
yet
!
"
;
return
false
;
}
int
total_bitrate_bps
=
0
;
for
(
i
=
0
;
i
<
num_spatial_layers_
;
+
+
i
)
total_bitrate_bps
+
=
codec_
.
spatialLayers
[
i
]
.
target_bitrate_bps
;
for
(
i
=
0
;
i
<
num_spatial_layers_
;
+
+
i
)
{
config_
-
>
ss_target_bitrate
[
i
]
=
config_
-
>
layer_target_bitrate
[
i
]
=
static_cast
<
int
>
(
static_cast
<
int64_t
>
(
config_
-
>
rc_target_bitrate
)
*
codec_
.
spatialLayers
[
i
]
.
target_bitrate_bps
/
total_bitrate_bps
)
;
}
#
endif
}
else
{
float
rate_ratio
[
VPX_MAX_LAYERS
]
=
{
0
}
;
float
total
=
0
;
#
ifdef
LIBVPX_SVC
for
(
i
=
0
;
i
<
num_spatial_layers_
;
+
+
i
)
{
if
(
svc_internal_
.
svc_params
.
scaling_factor_num
[
i
]
<
=
0
|
|
svc_internal_
.
svc_params
.
scaling_factor_den
[
i
]
<
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
Scaling
factors
not
specified
!
"
;
return
false
;
}
rate_ratio
[
i
]
=
static_cast
<
float
>
(
svc_internal_
.
svc_params
.
scaling_factor_num
[
i
]
)
/
svc_internal_
.
svc_params
.
scaling_factor_den
[
i
]
;
total
+
=
rate_ratio
[
i
]
;
}
#
else
rate_ratio
[
0
]
=
1
;
total
=
1
;
#
endif
for
(
i
=
0
;
i
<
num_spatial_layers_
;
+
+
i
)
{
config_
-
>
ss_target_bitrate
[
i
]
=
static_cast
<
unsigned
int
>
(
config_
-
>
rc_target_bitrate
*
rate_ratio
[
i
]
/
total
)
;
if
(
num_temporal_layers_
=
=
1
)
{
config_
-
>
layer_target_bitrate
[
i
]
=
config_
-
>
ss_target_bitrate
[
i
]
;
}
else
if
(
num_temporal_layers_
=
=
2
)
{
config_
-
>
layer_target_bitrate
[
i
*
num_temporal_layers_
]
=
config_
-
>
ss_target_bitrate
[
i
]
*
2
/
3
;
config_
-
>
layer_target_bitrate
[
i
*
num_temporal_layers_
+
1
]
=
config_
-
>
ss_target_bitrate
[
i
]
;
}
else
if
(
num_temporal_layers_
=
=
3
)
{
config_
-
>
layer_target_bitrate
[
i
*
num_temporal_layers_
]
=
config_
-
>
ss_target_bitrate
[
i
]
/
2
;
config_
-
>
layer_target_bitrate
[
i
*
num_temporal_layers_
+
1
]
=
config_
-
>
layer_target_bitrate
[
i
*
num_temporal_layers_
]
+
(
config_
-
>
ss_target_bitrate
[
i
]
/
4
)
;
config_
-
>
layer_target_bitrate
[
i
*
num_temporal_layers_
+
2
]
=
config_
-
>
ss_target_bitrate
[
i
]
;
}
else
{
LOG
(
LS_ERROR
)
<
<
"
Unsupported
number
of
temporal
layers
:
"
<
<
num_temporal_layers_
;
return
false
;
}
}
}
if
(
num_spatial_layers_
=
=
1
)
{
for
(
i
=
0
;
i
<
num_temporal_layers_
;
+
+
i
)
{
config_
-
>
ts_target_bitrate
[
i
]
=
config_
-
>
layer_target_bitrate
[
i
]
;
}
}
return
true
;
}
int
VP9EncoderImpl
:
:
SetRates
(
uint32_t
new_bitrate_kbit
uint32_t
new_framerate
)
{
if
(
!
inited_
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
encoder_
-
>
err
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
if
(
new_framerate
<
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
codec_
.
maxBitrate
>
0
&
&
new_bitrate_kbit
>
codec_
.
maxBitrate
)
{
new_bitrate_kbit
=
codec_
.
maxBitrate
;
}
config_
-
>
rc_target_bitrate
=
new_bitrate_kbit
;
codec_
.
maxFramerate
=
new_framerate
;
spatial_layer_
-
>
ConfigureBitrate
(
new_bitrate_kbit
0
)
;
if
(
!
SetSvcRates
(
)
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
vpx_codec_enc_config_set
(
encoder_
config_
)
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
VP9EncoderImpl
:
:
InitEncode
(
const
VideoCodec
*
inst
int
number_of_cores
size_t
)
{
if
(
inst
=
=
NULL
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
maxFramerate
<
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
maxBitrate
>
0
&
&
inst
-
>
startBitrate
>
inst
-
>
maxBitrate
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
width
<
1
|
|
inst
-
>
height
<
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
number_of_cores
<
1
|
|
number_of_cores
>
UINT8_MAX
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
codecSpecific
.
VP9
.
numberOfTemporalLayers
>
3
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
codecSpecific
.
VP9
.
numberOfSpatialLayers
>
2
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
int
retVal
=
Release
(
)
;
if
(
retVal
<
0
)
{
return
retVal
;
}
if
(
encoder_
=
=
NULL
)
{
encoder_
=
new
vpx_codec_ctx_t
;
}
if
(
config_
=
=
NULL
)
{
config_
=
new
vpx_codec_enc_cfg_t
;
}
timestamp_
=
0
;
if
(
&
codec_
!
=
inst
)
{
codec_
=
*
inst
;
}
num_cores_
=
number_of_cores
;
num_spatial_layers_
=
inst
-
>
codecSpecific
.
VP9
.
numberOfSpatialLayers
;
num_temporal_layers_
=
inst
-
>
codecSpecific
.
VP9
.
numberOfTemporalLayers
;
if
(
num_temporal_layers_
=
=
0
)
num_temporal_layers_
=
1
;
picture_id_
=
static_cast
<
uint16_t
>
(
rand
(
)
)
&
0x7FFF
;
if
(
encoded_image_
.
_buffer
!
=
NULL
)
{
delete
[
]
encoded_image_
.
_buffer
;
}
encoded_image_
.
_size
=
CalcBufferSize
(
kI420
codec_
.
width
codec_
.
height
)
;
encoded_image_
.
_buffer
=
new
uint8_t
[
encoded_image_
.
_size
]
;
encoded_image_
.
_completeFrame
=
true
;
raw_
=
vpx_img_wrap
(
NULL
VPX_IMG_FMT_I420
codec_
.
width
codec_
.
height
1
NULL
)
;
if
(
vpx_codec_enc_config_default
(
vpx_codec_vp9_cx
(
)
config_
0
)
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
config_
-
>
g_w
=
codec_
.
width
;
config_
-
>
g_h
=
codec_
.
height
;
config_
-
>
rc_target_bitrate
=
inst
-
>
startBitrate
;
config_
-
>
g_error_resilient
=
1
;
config_
-
>
g_timebase
.
num
=
1
;
config_
-
>
g_timebase
.
den
=
90000
;
config_
-
>
g_lag_in_frames
=
0
;
config_
-
>
g_threads
=
1
;
config_
-
>
rc_dropframe_thresh
=
inst
-
>
codecSpecific
.
VP9
.
frameDroppingOn
?
30
:
0
;
config_
-
>
rc_end_usage
=
VPX_CBR
;
config_
-
>
g_pass
=
VPX_RC_ONE_PASS
;
config_
-
>
rc_min_quantizer
=
2
;
config_
-
>
rc_max_quantizer
=
52
;
config_
-
>
rc_undershoot_pct
=
50
;
config_
-
>
rc_overshoot_pct
=
50
;
config_
-
>
rc_buf_initial_sz
=
500
;
config_
-
>
rc_buf_optimal_sz
=
600
;
config_
-
>
rc_buf_sz
=
1000
;
rc_max_intra_target_
=
MaxIntraTarget
(
config_
-
>
rc_buf_optimal_sz
)
;
if
(
inst
-
>
codecSpecific
.
VP9
.
keyFrameInterval
>
0
)
{
config_
-
>
kf_mode
=
VPX_KF_AUTO
;
config_
-
>
kf_max_dist
=
inst
-
>
codecSpecific
.
VP9
.
keyFrameInterval
;
}
else
{
config_
-
>
kf_mode
=
VPX_KF_DISABLED
;
}
config_
-
>
rc_resize_allowed
=
inst
-
>
codecSpecific
.
VP9
.
automaticResizeOn
?
1
:
0
;
config_
-
>
g_threads
=
NumberOfThreads
(
config_
-
>
g_w
config_
-
>
g_h
num_cores_
)
;
cpu_speed_
=
GetCpuSpeed
(
config_
-
>
g_w
config_
-
>
g_h
)
;
is_flexible_mode_
=
inst
-
>
codecSpecific
.
VP9
.
flexibleMode
;
if
(
is_flexible_mode_
)
{
config_
-
>
temporal_layering_mode
=
VP9E_TEMPORAL_LAYERING_MODE_BYPASS
;
config_
-
>
ts_number_layers
=
num_temporal_layers_
;
if
(
codec_
.
mode
=
=
kScreensharing
)
spatial_layer_
-
>
ConfigureBitrate
(
inst
-
>
startBitrate
0
)
;
}
else
if
(
num_temporal_layers_
=
=
1
)
{
gof_
.
SetGofInfoVP9
(
kTemporalStructureMode1
)
;
config_
-
>
temporal_layering_mode
=
VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING
;
config_
-
>
ts_number_layers
=
1
;
config_
-
>
ts_rate_decimator
[
0
]
=
1
;
config_
-
>
ts_periodicity
=
1
;
config_
-
>
ts_layer_id
[
0
]
=
0
;
}
else
if
(
num_temporal_layers_
=
=
2
)
{
gof_
.
SetGofInfoVP9
(
kTemporalStructureMode2
)
;
config_
-
>
temporal_layering_mode
=
VP9E_TEMPORAL_LAYERING_MODE_0101
;
config_
-
>
ts_number_layers
=
2
;
config_
-
>
ts_rate_decimator
[
0
]
=
2
;
config_
-
>
ts_rate_decimator
[
1
]
=
1
;
config_
-
>
ts_periodicity
=
2
;
config_
-
>
ts_layer_id
[
0
]
=
0
;
config_
-
>
ts_layer_id
[
1
]
=
1
;
}
else
if
(
num_temporal_layers_
=
=
3
)
{
gof_
.
SetGofInfoVP9
(
kTemporalStructureMode3
)
;
config_
-
>
temporal_layering_mode
=
VP9E_TEMPORAL_LAYERING_MODE_0212
;
config_
-
>
ts_number_layers
=
3
;
config_
-
>
ts_rate_decimator
[
0
]
=
4
;
config_
-
>
ts_rate_decimator
[
1
]
=
2
;
config_
-
>
ts_rate_decimator
[
2
]
=
1
;
config_
-
>
ts_periodicity
=
4
;
config_
-
>
ts_layer_id
[
0
]
=
0
;
config_
-
>
ts_layer_id
[
1
]
=
2
;
config_
-
>
ts_layer_id
[
2
]
=
1
;
config_
-
>
ts_layer_id
[
3
]
=
2
;
}
else
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
tl0_pic_idx_
=
static_cast
<
uint8_t
>
(
rand
(
)
)
;
return
InitAndSetControlSettings
(
inst
)
;
}
int
VP9EncoderImpl
:
:
NumberOfThreads
(
int
width
int
height
int
number_of_cores
)
{
if
(
width
*
height
>
=
1280
*
720
&
&
number_of_cores
>
4
)
{
return
4
;
}
else
if
(
width
*
height
>
=
640
*
480
&
&
number_of_cores
>
2
)
{
return
2
;
}
else
{
return
1
;
}
}
int
VP9EncoderImpl
:
:
InitAndSetControlSettings
(
const
VideoCodec
*
inst
)
{
config_
-
>
ss_number_layers
=
num_spatial_layers_
;
#
ifdef
LIBVPX_SVC
if
(
ExplicitlyConfiguredSpatialLayers
(
)
)
{
for
(
int
i
=
0
;
i
<
num_spatial_layers_
;
+
+
i
)
{
const
auto
&
layer
=
codec_
.
spatialLayers
[
i
]
;
svc_internal_
.
svc_params
.
max_quantizers
[
i
]
=
config_
-
>
rc_max_quantizer
;
svc_internal_
.
svc_params
.
min_quantizers
[
i
]
=
config_
-
>
rc_min_quantizer
;
svc_internal_
.
svc_params
.
scaling_factor_num
[
i
]
=
layer
.
scaling_factor_num
;
svc_internal_
.
svc_params
.
scaling_factor_den
[
i
]
=
layer
.
scaling_factor_den
;
}
}
else
{
int
scaling_factor_num
=
256
;
for
(
int
i
=
num_spatial_layers_
-
1
;
i
>
=
0
;
-
-
i
)
{
svc_internal_
.
svc_params
.
max_quantizers
[
i
]
=
config_
-
>
rc_max_quantizer
;
svc_internal_
.
svc_params
.
min_quantizers
[
i
]
=
config_
-
>
rc_min_quantizer
;
svc_internal_
.
svc_params
.
scaling_factor_num
[
i
]
=
scaling_factor_num
;
svc_internal_
.
svc_params
.
scaling_factor_den
[
i
]
=
256
;
if
(
codec_
.
mode
!
=
kScreensharing
)
scaling_factor_num
/
=
2
;
}
}
#
endif
if
(
!
SetSvcRates
(
)
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
vpx_codec_enc_init
(
encoder_
vpx_codec_vp9_cx
(
)
config_
0
)
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
vpx_codec_control
(
encoder_
VP8E_SET_CPUUSED
cpu_speed_
)
;
vpx_codec_control
(
encoder_
VP8E_SET_MAX_INTRA_BITRATE_PCT
rc_max_intra_target_
)
;
vpx_codec_control
(
encoder_
VP9E_SET_AQ_MODE
inst
-
>
codecSpecific
.
VP9
.
adaptiveQpMode
?
3
:
0
)
;
#
ifdef
LIBVPX_SVC
vpx_codec_control
(
encoder_
VP9E_SET_SVC
(
num_temporal_layers_
>
1
|
|
num_spatial_layers_
>
1
)
?
1
:
0
)
;
if
(
num_temporal_layers_
>
1
|
|
num_spatial_layers_
>
1
)
{
vpx_codec_control
(
encoder_
VP9E_SET_SVC_PARAMETERS
&
svc_internal_
.
svc_params
)
;
}
#
endif
vpx_codec_priv_output_cx_pkt_cb_pair_t
cbp
=
{
VP9EncoderImpl
:
:
EncoderOutputCodedPacketCallback
(
void
*
)
(
this
)
}
;
vpx_codec_control
(
encoder_
VP9E_REGISTER_CX_CALLBACK
(
void
*
)
(
&
cbp
)
)
;
vpx_codec_control
(
encoder_
VP9E_SET_TILE_COLUMNS
(
config_
-
>
g_threads
>
>
1
)
)
;
#
if
!
defined
(
WEBRTC_ARCH_ARM
)
&
&
!
defined
(
WEBRTC_ARCH_ARM64
)
vpx_codec_control
(
encoder_
VP9E_SET_NOISE_SENSITIVITY
inst
-
>
codecSpecific
.
VP9
.
denoisingOn
?
1
:
0
)
;
#
endif
if
(
codec_
.
mode
=
=
kScreensharing
)
{
vpx_codec_control
(
encoder_
VP9E_SET_TUNE_CONTENT
1
)
;
}
vpx_codec_control
(
encoder_
VP8E_SET_STATIC_THRESHOLD
1
)
;
inited_
=
true
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
uint32_t
VP9EncoderImpl
:
:
MaxIntraTarget
(
uint32_t
optimal_buffer_size
)
{
float
scale_par
=
0
.
5
;
uint32_t
target_pct
=
optimal_buffer_size
*
scale_par
*
codec_
.
maxFramerate
/
10
;
const
uint32_t
min_intra_size
=
300
;
return
(
target_pct
<
min_intra_size
)
?
min_intra_size
:
target_pct
;
}
int
VP9EncoderImpl
:
:
Encode
(
const
I420VideoFrame
&
input_image
const
CodecSpecificInfo
*
codec_specific_info
const
std
:
:
vector
<
VideoFrameType
>
*
frame_types
)
{
if
(
!
inited_
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
input_image
.
IsZeroSize
(
)
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
encoded_complete_callback_
=
=
NULL
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
VideoFrameType
frame_type
=
kDeltaFrame
;
if
(
frame_types
&
&
frame_types
-
>
size
(
)
>
0
)
{
frame_type
=
(
*
frame_types
)
[
0
]
;
}
if
(
input_image
.
width
(
)
!
=
codec_
.
width
|
|
input_image
.
height
(
)
!
=
codec_
.
height
)
{
int
ret
=
UpdateCodecFrameSize
(
input_image
)
;
if
(
ret
<
0
)
{
return
ret
;
}
}
DCHECK_EQ
(
input_image
.
width
(
)
static_cast
<
int
>
(
raw_
-
>
d_w
)
)
;
DCHECK_EQ
(
input_image
.
height
(
)
static_cast
<
int
>
(
raw_
-
>
d_h
)
)
;
input_image_
=
&
input_image
;
raw_
-
>
planes
[
VPX_PLANE_Y
]
=
const_cast
<
uint8_t
*
>
(
input_image
.
buffer
(
kYPlane
)
)
;
raw_
-
>
planes
[
VPX_PLANE_U
]
=
const_cast
<
uint8_t
*
>
(
input_image
.
buffer
(
kUPlane
)
)
;
raw_
-
>
planes
[
VPX_PLANE_V
]
=
const_cast
<
uint8_t
*
>
(
input_image
.
buffer
(
kVPlane
)
)
;
raw_
-
>
stride
[
VPX_PLANE_Y
]
=
input_image
.
stride
(
kYPlane
)
;
raw_
-
>
stride
[
VPX_PLANE_U
]
=
input_image
.
stride
(
kUPlane
)
;
raw_
-
>
stride
[
VPX_PLANE_V
]
=
input_image
.
stride
(
kVPlane
)
;
vpx_enc_frame_flags_t
flags
=
0
;
bool
send_keyframe
=
(
frame_type
=
=
kKeyFrame
)
;
if
(
send_keyframe
)
{
flags
=
VPX_EFLAG_FORCE_KF
;
}
#
ifdef
LIBVPX_SVC
if
(
is_flexible_mode_
)
{
SuperFrameRefSettings
settings
;
vpx_svc_ref_frame_config
enc_layer_conf
;
vpx_svc_layer_id
layer_id
;
if
(
codec_
.
mode
=
=
kRealtimeVideo
)
{
RTC_NOTREACHED
(
)
;
}
else
{
settings
=
spatial_layer_
-
>
GetSuperFrameSettings
(
input_image
.
timestamp
(
)
send_keyframe
)
;
}
enc_layer_conf
=
GenerateRefsAndFlags
(
settings
)
;
layer_id
.
temporal_layer_id
=
0
;
layer_id
.
spatial_layer_id
=
settings
.
start_layer
;
vpx_codec_control
(
encoder_
VP9E_SET_SVC_LAYER_ID
&
layer_id
)
;
vpx_codec_control
(
encoder_
VP9E_SET_SVC_REF_FRAME_CONFIG
&
enc_layer_conf
)
;
}
#
endif
assert
(
codec_
.
maxFramerate
>
0
)
;
uint32_t
duration
=
90000
/
codec_
.
maxFramerate
;
if
(
vpx_codec_encode
(
encoder_
raw_
timestamp_
duration
flags
VPX_DL_REALTIME
)
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
timestamp_
+
=
duration
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
VP9EncoderImpl
:
:
UpdateCodecFrameSize
(
const
I420VideoFrame
&
input_image
)
{
fprintf
(
stderr
"
Reconfiging
VP
(
from
%
dx
%
d
to
%
dx
%
d
\
n
"
codec_
.
width
codec_
.
height
input_image
.
width
(
)
input_image
.
height
(
)
)
;
uint32_t
old_bitrate_kbit
=
config_
-
>
rc_target_bitrate
;
uint32_t
old_framerate
=
codec_
.
maxFramerate
;
codec_
.
width
=
input_image
.
width
(
)
;
codec_
.
height
=
input_image
.
height
(
)
;
vpx_img_free
(
raw_
)
;
raw_
=
vpx_img_wrap
(
NULL
VPX_IMG_FMT_I420
codec_
.
width
codec_
.
height
1
NULL
)
;
config_
-
>
g_w
=
codec_
.
width
;
config_
-
>
g_h
=
codec_
.
height
;
config_
-
>
g_threads
=
NumberOfThreads
(
codec_
.
width
codec_
.
height
num_cores_
)
;
cpu_speed_
=
GetCpuSpeed
(
codec_
.
width
codec_
.
height
)
;
vpx_codec_destroy
(
encoder_
)
;
int
result
=
InitAndSetControlSettings
(
&
codec_
)
;
if
(
result
=
=
WEBRTC_VIDEO_CODEC_OK
)
{
return
SetRates
(
old_bitrate_kbit
old_framerate
)
;
}
return
result
;
}
void
VP9EncoderImpl
:
:
PopulateCodecSpecific
(
CodecSpecificInfo
*
codec_specific
const
vpx_codec_cx_pkt
&
pkt
uint32_t
timestamp
)
{
assert
(
codec_specific
!
=
NULL
)
;
codec_specific
-
>
codecType
=
kVideoCodecVP9
;
CodecSpecificInfoVP9
*
vp9_info
=
&
(
codec_specific
-
>
codecSpecific
.
VP9
)
;
vp9_info
-
>
inter_pic_predicted
=
(
pkt
.
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
?
false
:
true
;
vp9_info
-
>
flexible_mode
=
codec_
.
codecSpecific
.
VP9
.
flexibleMode
;
vp9_info
-
>
ss_data_available
=
(
(
pkt
.
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
&
&
!
codec_
.
codecSpecific
.
VP9
.
flexibleMode
)
?
true
:
false
;
vpx_svc_layer_id_t
layer_id
=
{
0
}
;
vpx_codec_control
(
encoder_
VP9E_GET_SVC_LAYER_ID
&
layer_id
)
;
assert
(
num_temporal_layers_
>
0
)
;
assert
(
num_spatial_layers_
>
0
)
;
if
(
num_temporal_layers_
=
=
1
)
{
assert
(
layer_id
.
temporal_layer_id
=
=
0
)
;
vp9_info
-
>
temporal_idx
=
kNoTemporalIdx
;
}
else
{
vp9_info
-
>
temporal_idx
=
layer_id
.
temporal_layer_id
;
}
if
(
num_spatial_layers_
=
=
1
)
{
assert
(
layer_id
.
spatial_layer_id
=
=
0
)
;
vp9_info
-
>
spatial_idx
=
kNoSpatialIdx
;
}
else
{
vp9_info
-
>
spatial_idx
=
layer_id
.
spatial_layer_id
;
}
if
(
layer_id
.
spatial_layer_id
!
=
0
)
{
vp9_info
-
>
ss_data_available
=
false
;
}
vp9_info
-
>
temporal_up_switch
=
true
;
bool
is_first_frame
=
false
;
if
(
is_flexible_mode_
)
{
is_first_frame
=
layer_id
.
spatial_layer_id
=
=
spatial_layer_
-
>
GetStartLayer
(
)
;
}
else
{
is_first_frame
=
layer_id
.
spatial_layer_id
=
=
0
;
}
if
(
is_first_frame
)
{
picture_id_
=
(
picture_id_
+
1
)
&
0x7FFF
;
vp9_info
-
>
inter_layer_predicted
=
false
;
+
+
frames_since_kf_
;
}
else
{
vp9_info
-
>
inter_layer_predicted
=
true
;
}
if
(
pkt
.
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
{
frames_since_kf_
=
0
;
}
vp9_info
-
>
picture_id
=
picture_id_
;
if
(
!
vp9_info
-
>
flexible_mode
)
{
if
(
layer_id
.
temporal_layer_id
=
=
0
&
&
layer_id
.
spatial_layer_id
=
=
0
)
{
tl0_pic_idx_
+
+
;
}
vp9_info
-
>
tl0_pic_idx
=
tl0_pic_idx_
;
}
vp9_info
-
>
num_spatial_layers
=
num_spatial_layers_
;
vp9_info
-
>
num_ref_pics
=
0
;
if
(
vp9_info
-
>
flexible_mode
)
{
vp9_info
-
>
gof_idx
=
kNoGofIdx
;
vp9_info
-
>
num_ref_pics
=
num_ref_pics_
[
layer_id
.
spatial_layer_id
]
;
for
(
int
i
=
0
;
i
<
num_ref_pics_
[
layer_id
.
spatial_layer_id
]
;
+
+
i
)
{
vp9_info
-
>
p_diff
[
i
]
=
p_diff_
[
layer_id
.
spatial_layer_id
]
[
i
]
;
}
}
else
{
vp9_info
-
>
gof_idx
=
static_cast
<
uint8_t
>
(
frames_since_kf_
%
gof_
.
num_frames_in_gof
)
;
vp9_info
-
>
temporal_up_switch
=
gof_
.
temporal_up_switch
[
vp9_info
-
>
gof_idx
]
;
}
#
ifdef
LIBVPX_SVC
if
(
vp9_info
-
>
ss_data_available
)
{
vp9_info
-
>
spatial_layer_resolution_present
=
true
;
for
(
size_t
i
=
0
;
i
<
vp9_info
-
>
num_spatial_layers
;
+
+
i
)
{
vp9_info
-
>
width
[
i
]
=
codec_
.
width
*
svc_internal_
.
svc_params
.
scaling_factor_num
[
i
]
/
svc_internal_
.
svc_params
.
scaling_factor_den
[
i
]
;
vp9_info
-
>
height
[
i
]
=
codec_
.
height
*
svc_internal_
.
svc_params
.
scaling_factor_num
[
i
]
/
svc_internal_
.
svc_params
.
scaling_factor_den
[
i
]
;
}
}
#
endif
if
(
!
vp9_info
-
>
flexible_mode
)
{
vp9_info
-
>
gof
.
CopyGofInfoVP9
(
gof_
)
;
}
}
int
VP9EncoderImpl
:
:
GetEncodedLayerFrame
(
const
vpx_codec_cx_pkt
*
pkt
)
{
encoded_image_
.
_length
=
0
;
encoded_image_
.
_frameType
=
kDeltaFrame
;
RTPFragmentationHeader
frag_info
;
frag_info
.
VerifyAndAllocateFragmentationHeader
(
1
)
;
int
part_idx
=
0
;
CodecSpecificInfo
codec_specific
;
assert
(
pkt
-
>
kind
=
=
VPX_CODEC_CX_FRAME_PKT
)
;
memcpy
(
&
encoded_image_
.
_buffer
[
encoded_image_
.
_length
]
pkt
-
>
data
.
frame
.
buf
pkt
-
>
data
.
frame
.
sz
)
;
frag_info
.
fragmentationOffset
[
part_idx
]
=
encoded_image_
.
_length
;
frag_info
.
fragmentationLength
[
part_idx
]
=
static_cast
<
uint32_t
>
(
pkt
-
>
data
.
frame
.
sz
)
;
frag_info
.
fragmentationPlType
[
part_idx
]
=
0
;
frag_info
.
fragmentationTimeDiff
[
part_idx
]
=
0
;
encoded_image_
.
_length
+
=
static_cast
<
uint32_t
>
(
pkt
-
>
data
.
frame
.
sz
)
;
vpx_svc_layer_id_t
layer_id
=
{
0
}
;
vpx_codec_control
(
encoder_
VP9E_GET_SVC_LAYER_ID
&
layer_id
)
;
if
(
is_flexible_mode_
&
&
codec_
.
mode
=
=
kScreensharing
)
spatial_layer_
-
>
LayerFrameEncoded
(
static_cast
<
unsigned
int
>
(
encoded_image_
.
_length
)
layer_id
.
spatial_layer_id
)
;
assert
(
encoded_image_
.
_length
<
=
encoded_image_
.
_size
)
;
if
(
pkt
-
>
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
{
encoded_image_
.
_frameType
=
kKeyFrame
;
}
PopulateCodecSpecific
(
&
codec_specific
*
pkt
input_image_
-
>
timestamp
(
)
)
;
if
(
encoded_image_
.
_length
>
0
)
{
TRACE_COUNTER1
(
"
webrtc
"
"
EncodedFrameSize
"
encoded_image_
.
_length
)
;
encoded_image_
.
_timeStamp
=
input_image_
-
>
timestamp
(
)
;
encoded_image_
.
capture_time_ms_
=
input_image_
-
>
render_time_ms
(
)
;
encoded_image_
.
_encodedHeight
=
raw_
-
>
d_h
;
encoded_image_
.
_encodedWidth
=
raw_
-
>
d_w
;
encoded_complete_callback_
-
>
Encoded
(
encoded_image_
&
codec_specific
&
frag_info
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
#
ifdef
LIBVPX_SVC
vpx_svc_ref_frame_config
VP9EncoderImpl
:
:
GenerateRefsAndFlags
(
const
SuperFrameRefSettings
&
settings
)
{
static
const
vpx_enc_frame_flags_t
kAllFlags
=
VP8_EFLAG_NO_REF_ARF
|
VP8_EFLAG_NO_REF_GF
|
VP8_EFLAG_NO_REF_LAST
|
VP8_EFLAG_NO_UPD_LAST
|
VP8_EFLAG_NO_UPD_ARF
|
VP8_EFLAG_NO_UPD_GF
;
vpx_svc_ref_frame_config
sf_conf
=
{
}
;
if
(
settings
.
is_keyframe
)
{
memset
(
buffer_updated_at_frame_
-
1
sizeof
(
buffer_updated_at_frame_
)
)
;
for
(
int
layer
=
settings
.
start_layer
;
layer
<
=
settings
.
stop_layer
;
+
+
layer
)
{
num_ref_pics_
[
layer
]
=
0
;
buffer_updated_at_frame_
[
settings
.
layer
[
layer
]
.
upd_buf
]
=
frames_encoded_
;
sf_conf
.
alt_fb_idx
[
layer
]
=
settings
.
layer
[
layer
]
.
upd_buf
;
}
}
else
{
for
(
int
layer_idx
=
settings
.
start_layer
;
layer_idx
<
=
settings
.
stop_layer
;
+
+
layer_idx
)
{
vpx_enc_frame_flags_t
layer_flags
=
kAllFlags
;
num_ref_pics_
[
layer_idx
]
=
0
;
int8_t
refs
[
3
]
=
{
settings
.
layer
[
layer_idx
]
.
ref_buf1
settings
.
layer
[
layer_idx
]
.
ref_buf2
settings
.
layer
[
layer_idx
]
.
ref_buf3
}
;
for
(
unsigned
int
ref_idx
=
0
;
ref_idx
<
kMaxVp9RefPics
;
+
+
ref_idx
)
{
if
(
refs
[
ref_idx
]
=
=
-
1
)
continue
;
DCHECK_GE
(
refs
[
ref_idx
]
0
)
;
DCHECK_LE
(
refs
[
ref_idx
]
7
)
;
switch
(
num_ref_pics_
[
layer_idx
]
)
{
case
0
:
{
sf_conf
.
lst_fb_idx
[
layer_idx
]
=
refs
[
ref_idx
]
;
layer_flags
&
=
~
VP8_EFLAG_NO_REF_LAST
;
break
;
}
case
1
:
{
sf_conf
.
gld_fb_idx
[
layer_idx
]
=
refs
[
ref_idx
]
;
layer_flags
&
=
~
VP8_EFLAG_NO_REF_GF
;
break
;
}
case
2
:
{
sf_conf
.
alt_fb_idx
[
layer_idx
]
=
refs
[
ref_idx
]
;
layer_flags
&
=
~
VP8_EFLAG_NO_REF_ARF
;
break
;
}
}
DCHECK_NE
(
buffer_updated_at_frame_
[
refs
[
ref_idx
]
]
-
1
)
;
p_diff_
[
layer_idx
]
[
num_ref_pics_
[
layer_idx
]
]
=
frames_encoded_
-
buffer_updated_at_frame_
[
refs
[
ref_idx
]
]
;
num_ref_pics_
[
layer_idx
]
+
+
;
}
bool
upd_buf_same_as_a_ref
=
false
;
if
(
settings
.
layer
[
layer_idx
]
.
upd_buf
!
=
-
1
)
{
for
(
unsigned
int
ref_idx
=
0
;
ref_idx
<
kMaxVp9RefPics
;
+
+
ref_idx
)
{
if
(
settings
.
layer
[
layer_idx
]
.
upd_buf
=
=
refs
[
ref_idx
]
)
{
switch
(
ref_idx
)
{
case
0
:
{
layer_flags
&
=
~
VP8_EFLAG_NO_UPD_LAST
;
break
;
}
case
1
:
{
layer_flags
&
=
~
VP8_EFLAG_NO_UPD_GF
;
break
;
}
case
2
:
{
layer_flags
&
=
~
VP8_EFLAG_NO_UPD_ARF
;
break
;
}
}
upd_buf_same_as_a_ref
=
true
;
break
;
}
}
if
(
!
upd_buf_same_as_a_ref
)
{
RTC_CHECK_LT
(
num_ref_pics_
[
layer_idx
]
kMaxVp9RefPics
)
;
sf_conf
.
alt_fb_idx
[
layer_idx
]
=
settings
.
layer
[
layer_idx
]
.
upd_buf
;
layer_flags
^
=
VP8_EFLAG_NO_UPD_ARF
;
}
int
updated_buffer
=
settings
.
layer
[
layer_idx
]
.
upd_buf
;
buffer_updated_at_frame_
[
updated_buffer
]
=
frames_encoded_
;
sf_conf
.
frame_flags
[
layer_idx
]
=
layer_flags
;
}
}
}
+
+
frames_encoded_
;
return
sf_conf
;
}
#
endif
int
VP9EncoderImpl
:
:
SetChannelParameters
(
uint32_t
packet_loss
int64_t
rtt
)
{
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
VP9EncoderImpl
:
:
RegisterEncodeCompleteCallback
(
EncodedImageCallback
*
callback
)
{
encoded_complete_callback_
=
callback
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
VP9Decoder
*
VP9Decoder
:
:
Create
(
)
{
return
new
VP9DecoderImpl
(
)
;
}
VP9DecoderImpl
:
:
VP9DecoderImpl
(
)
:
decode_complete_callback_
(
NULL
)
inited_
(
false
)
decoder_
(
NULL
)
key_frame_required_
(
true
)
{
memset
(
&
codec_
0
sizeof
(
codec_
)
)
;
}
VP9DecoderImpl
:
:
~
VP9DecoderImpl
(
)
{
inited_
=
true
;
Release
(
)
;
int
num_buffers_in_use
=
frame_buffer_pool_
.
GetNumBuffersInUse
(
)
;
if
(
num_buffers_in_use
>
0
)
{
LOG
(
LS_INFO
)
<
<
num_buffers_in_use
<
<
"
Vp9FrameBuffers
are
still
"
<
<
"
referenced
during
~
VP9DecoderImpl
.
"
;
}
}
int
VP9DecoderImpl
:
:
Reset
(
)
{
if
(
!
inited_
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
InitDecode
(
&
codec_
1
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
VP9DecoderImpl
:
:
InitDecode
(
const
VideoCodec
*
inst
int
number_of_cores
)
{
if
(
inst
=
=
NULL
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
int
ret_val
=
Release
(
)
;
if
(
ret_val
<
0
)
{
return
ret_val
;
}
if
(
decoder_
=
=
NULL
)
{
decoder_
=
new
vpx_codec_ctx_t
;
}
vpx_codec_dec_cfg_t
cfg
;
cfg
.
threads
=
1
;
cfg
.
h
=
cfg
.
w
=
0
;
vpx_codec_flags_t
flags
=
0
;
if
(
vpx_codec_dec_init
(
decoder_
vpx_codec_vp9_dx
(
)
&
cfg
flags
)
)
{
return
WEBRTC_VIDEO_CODEC_MEMORY
;
}
if
(
&
codec_
!
=
inst
)
{
codec_
=
*
inst
;
}
if
(
!
frame_buffer_pool_
.
InitializeVpxUsePool
(
decoder_
)
)
{
return
WEBRTC_VIDEO_CODEC_MEMORY
;
}
inited_
=
true
;
key_frame_required_
=
true
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
VP9DecoderImpl
:
:
Decode
(
const
EncodedImage
&
input_image
bool
missing_frames
const
RTPFragmentationHeader
*
fragmentation
const
CodecSpecificInfo
*
codec_specific_info
int64_t
)
{
if
(
!
inited_
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
decode_complete_callback_
=
=
NULL
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
key_frame_required_
)
{
if
(
input_image
.
_frameType
!
=
kKeyFrame
)
return
WEBRTC_VIDEO_CODEC_ERROR
;
if
(
input_image
.
_completeFrame
)
{
key_frame_required_
=
false
;
}
else
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
}
vpx_codec_iter_t
iter
=
NULL
;
vpx_image_t
*
img
;
uint8_t
*
buffer
=
input_image
.
_buffer
;
if
(
input_image
.
_length
=
=
0
)
{
buffer
=
NULL
;
}
if
(
vpx_codec_decode
(
decoder_
buffer
static_cast
<
unsigned
int
>
(
input_image
.
_length
)
0
VPX_DL_REALTIME
)
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
img
=
vpx_codec_get_frame
(
decoder_
&
iter
)
;
int
ret
=
ReturnFrame
(
img
input_image
.
_timeStamp
)
;
if
(
ret
!
=
0
)
{
return
ret
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
VP9DecoderImpl
:
:
ReturnFrame
(
const
vpx_image_t
*
img
uint32_t
timestamp
)
{
if
(
img
=
=
NULL
)
{
return
WEBRTC_VIDEO_CODEC_NO_OUTPUT
;
}
#
ifdef
USE_WRAPPED_I420_BUFFER
Vp9FrameBufferPool
:
:
Vp9FrameBuffer
*
img_buffer
=
static_cast
<
Vp9FrameBufferPool
:
:
Vp9FrameBuffer
*
>
(
img
-
>
fb_priv
)
;
img_buffer
-
>
AddRef
(
)
;
rtc
:
:
scoped_refptr
<
WrappedI420Buffer
>
img_wrapped_buffer
(
new
rtc
:
:
RefCountedObject
<
webrtc
:
:
WrappedI420Buffer
>
(
img
-
>
d_w
img
-
>
d_h
img
-
>
d_w
img
-
>
d_h
img
-
>
planes
[
VPX_PLANE_Y
]
img
-
>
stride
[
VPX_PLANE_Y
]
img
-
>
planes
[
VPX_PLANE_U
]
img
-
>
stride
[
VPX_PLANE_U
]
img
-
>
planes
[
VPX_PLANE_V
]
img
-
>
stride
[
VPX_PLANE_V
]
rtc
:
:
Bind
(
&
WrappedI420BufferNoLongerUsedCb
img_buffer
)
)
)
;
I420VideoFrame
decoded_image_
;
decoded_image_
.
set_video_frame_buffer
(
img_wrapped_buffer
)
;
#
else
decoded_image_
.
CreateFrame
(
img
-
>
planes
[
VPX_PLANE_Y
]
img
-
>
planes
[
VPX_PLANE_U
]
img
-
>
planes
[
VPX_PLANE_V
]
img
-
>
d_w
img
-
>
d_h
img
-
>
stride
[
VPX_PLANE_Y
]
img
-
>
stride
[
VPX_PLANE_U
]
img
-
>
stride
[
VPX_PLANE_V
]
)
;
#
endif
decoded_image_
.
set_timestamp
(
timestamp
)
;
int
ret
=
decode_complete_callback_
-
>
Decoded
(
decoded_image_
)
;
if
(
ret
!
=
0
)
return
ret
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
VP9DecoderImpl
:
:
RegisterDecodeCompleteCallback
(
DecodedImageCallback
*
callback
)
{
decode_complete_callback_
=
callback
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
VP9DecoderImpl
:
:
Release
(
)
{
if
(
decoder_
!
=
NULL
)
{
if
(
vpx_codec_destroy
(
decoder_
)
)
{
return
WEBRTC_VIDEO_CODEC_MEMORY
;
}
delete
decoder_
;
decoder_
=
NULL
;
}
frame_buffer_pool_
.
ClearPool
(
)
;
inited_
=
false
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
}
