#
ifndef
WEBRTC_MODULES_VIDEO_CODING_CODECS_VP9_VP9_IMPL_H_
#
define
WEBRTC_MODULES_VIDEO_CODING_CODECS_VP9_VP9_IMPL_H_
#
include
<
memory
>
#
include
<
vector
>
#
include
"
webrtc
/
modules
/
video_coding
/
codecs
/
vp9
/
include
/
vp9
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
codecs
/
vp9
/
vp9_frame_buffer_pool
.
h
"
#
include
"
vpx
/
vp8cx
.
h
"
#
include
"
vpx
/
vpx_decoder
.
h
"
#
include
"
vpx
/
vpx_encoder
.
h
"
namespace
webrtc
{
class
ScreenshareLayersVP9
;
class
VP9EncoderImpl
:
public
VP9Encoder
{
public
:
VP9EncoderImpl
(
)
;
virtual
~
VP9EncoderImpl
(
)
;
int
Release
(
)
override
;
int
InitEncode
(
const
VideoCodec
*
codec_settings
int
number_of_cores
size_t
max_payload_size
)
override
;
int
Encode
(
const
VideoFrame
&
input_image
const
CodecSpecificInfo
*
codec_specific_info
const
std
:
:
vector
<
FrameType
>
*
frame_types
)
override
;
int
RegisterEncodeCompleteCallback
(
EncodedImageCallback
*
callback
)
override
;
int
SetChannelParameters
(
uint32_t
packet_loss
int64_t
rtt
)
override
;
int
SetRateAllocation
(
const
BitrateAllocation
&
bitrate_allocation
uint32_t
frame_rate
)
override
;
const
char
*
ImplementationName
(
)
const
override
;
struct
LayerFrameRefSettings
{
int8_t
upd_buf
=
-
1
;
int8_t
ref_buf1
=
-
1
;
int8_t
ref_buf2
=
-
1
;
int8_t
ref_buf3
=
-
1
;
}
;
struct
SuperFrameRefSettings
{
LayerFrameRefSettings
layer
[
kMaxVp9NumberOfSpatialLayers
]
;
uint8_t
start_layer
=
0
;
uint8_t
stop_layer
=
0
;
bool
is_keyframe
=
false
;
}
;
private
:
int
NumberOfThreads
(
int
width
int
height
int
number_of_cores
)
;
int
InitAndSetControlSettings
(
const
VideoCodec
*
inst
)
;
int
UpdateCodecFrameSize
(
const
VideoFrame
&
input_image
)
;
void
PopulateCodecSpecific
(
CodecSpecificInfo
*
codec_specific
const
vpx_codec_cx_pkt
&
pkt
uint32_t
timestamp
)
;
bool
ExplicitlyConfiguredSpatialLayers
(
)
const
;
bool
SetSvcRates
(
)
;
vpx_svc_ref_frame_config
GenerateRefsAndFlags
(
const
SuperFrameRefSettings
&
settings
)
;
virtual
int
GetEncodedLayerFrame
(
const
vpx_codec_cx_pkt
*
pkt
)
;
static
void
EncoderOutputCodedPacketCallback
(
vpx_codec_cx_pkt
*
pkt
void
*
user_data
)
;
uint32_t
MaxIntraTarget
(
uint32_t
optimal_buffer_size
)
;
EncodedImage
encoded_image_
;
EncodedImageCallback
*
encoded_complete_callback_
;
VideoCodec
codec_
;
bool
inited_
;
int64_t
timestamp_
;
uint16_t
picture_id_
;
int
cpu_speed_
;
uint32_t
rc_max_intra_target_
;
vpx_codec_ctx_t
*
encoder_
;
vpx_codec_enc_cfg_t
*
config_
;
vpx_image_t
*
raw_
;
vpx_svc_extra_cfg_t
svc_params_
;
const
VideoFrame
*
input_image_
;
GofInfoVP9
gof_
;
uint8_t
tl0_pic_idx_
;
size_t
frames_since_kf_
;
uint8_t
num_temporal_layers_
;
uint8_t
num_spatial_layers_
;
uint8_t
num_cores_
;
bool
is_flexible_mode_
;
int64_t
buffer_updated_at_frame_
[
kNumVp9Buffers
]
;
int64_t
frames_encoded_
;
uint8_t
num_ref_pics_
[
kMaxVp9NumberOfSpatialLayers
]
;
uint8_t
p_diff_
[
kMaxVp9NumberOfSpatialLayers
]
[
kMaxVp9RefPics
]
;
std
:
:
unique_ptr
<
ScreenshareLayersVP9
>
spatial_layer_
;
}
;
class
VP9DecoderImpl
:
public
VP9Decoder
{
public
:
VP9DecoderImpl
(
)
;
virtual
~
VP9DecoderImpl
(
)
;
int
InitDecode
(
const
VideoCodec
*
inst
int
number_of_cores
)
override
;
int
Decode
(
const
EncodedImage
&
input_image
bool
missing_frames
const
RTPFragmentationHeader
*
fragmentation
const
CodecSpecificInfo
*
codec_specific_info
int64_t
)
override
;
int
RegisterDecodeCompleteCallback
(
DecodedImageCallback
*
callback
)
override
;
int
Release
(
)
override
;
const
char
*
ImplementationName
(
)
const
override
;
private
:
int
ReturnFrame
(
const
vpx_image_t
*
img
uint32_t
timestamp
int64_t
ntp_time_ms
)
;
#
ifndef
USE_WRAPPED_I420_BUFFER
VideoFrame
decoded_image_
;
#
endif
Vp9FrameBufferPool
frame_buffer_pool_
;
DecodedImageCallback
*
decode_complete_callback_
;
bool
inited_
;
vpx_codec_ctx_t
*
decoder_
;
VideoCodec
codec_
;
bool
key_frame_required_
;
}
;
}
#
endif
