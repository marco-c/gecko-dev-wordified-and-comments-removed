#
include
"
webrtc
/
modules
/
video_coding
/
codecs
/
vp9
/
vp9_frame_buffer_pool
.
h
"
#
include
"
vpx
/
vpx_codec
.
h
"
#
include
"
vpx
/
vpx_decoder
.
h
"
#
include
"
vpx
/
vpx_frame_buffer
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
logging
.
h
"
namespace
webrtc
{
uint8_t
*
Vp9FrameBufferPool
:
:
Vp9FrameBuffer
:
:
GetData
(
)
{
return
(
uint8_t
*
)
(
data_
.
data
(
)
)
;
}
size_t
Vp9FrameBufferPool
:
:
Vp9FrameBuffer
:
:
GetDataSize
(
)
const
{
return
data_
.
size
(
)
;
}
void
Vp9FrameBufferPool
:
:
Vp9FrameBuffer
:
:
SetSize
(
size_t
size
)
{
data_
.
SetSize
(
size
)
;
}
bool
Vp9FrameBufferPool
:
:
InitializeVpxUsePool
(
vpx_codec_ctx
*
vpx_codec_context
)
{
DCHECK
(
vpx_codec_context
)
;
if
(
vpx_codec_set_frame_buffer_functions
(
vpx_codec_context
&
Vp9FrameBufferPool
:
:
VpxGetFrameBuffer
&
Vp9FrameBufferPool
:
:
VpxReleaseFrameBuffer
this
)
)
{
return
false
;
}
return
true
;
}
rtc
:
:
scoped_refptr
<
Vp9FrameBufferPool
:
:
Vp9FrameBuffer
>
Vp9FrameBufferPool
:
:
GetFrameBuffer
(
size_t
min_size
)
{
DCHECK_GT
(
min_size
0u
)
;
rtc
:
:
scoped_refptr
<
Vp9FrameBuffer
>
available_buffer
=
nullptr
;
{
rtc
:
:
CritScope
cs
(
&
buffers_lock_
)
;
for
(
const
auto
&
buffer
:
allocated_buffers_
)
{
if
(
buffer
-
>
HasOneRef
(
)
)
{
available_buffer
=
buffer
;
break
;
}
}
if
(
available_buffer
=
=
nullptr
)
{
available_buffer
=
new
rtc
:
:
RefCountedObject
<
Vp9FrameBuffer
>
(
)
;
allocated_buffers_
.
push_back
(
available_buffer
)
;
if
(
allocated_buffers_
.
size
(
)
>
max_num_buffers_
)
{
LOG
(
LS_WARNING
)
<
<
allocated_buffers_
.
size
(
)
<
<
"
Vp9FrameBuffers
have
been
"
<
<
"
allocated
by
a
Vp9FrameBufferPool
(
exceeding
what
is
"
<
<
"
considered
reasonable
"
<
<
max_num_buffers_
<
<
"
)
.
"
;
RTC_NOTREACHED
(
)
;
}
}
}
available_buffer
-
>
SetSize
(
min_size
)
;
return
available_buffer
;
}
int
Vp9FrameBufferPool
:
:
GetNumBuffersInUse
(
)
const
{
int
num_buffers_in_use
=
0
;
rtc
:
:
CritScope
cs
(
&
buffers_lock_
)
;
for
(
const
auto
&
buffer
:
allocated_buffers_
)
{
if
(
!
buffer
-
>
HasOneRef
(
)
)
+
+
num_buffers_in_use
;
}
return
num_buffers_in_use
;
}
void
Vp9FrameBufferPool
:
:
ClearPool
(
)
{
rtc
:
:
CritScope
cs
(
&
buffers_lock_
)
;
allocated_buffers_
.
clear
(
)
;
}
int32_t
Vp9FrameBufferPool
:
:
VpxGetFrameBuffer
(
void
*
user_priv
size_t
min_size
vpx_codec_frame_buffer
*
fb
)
{
DCHECK
(
user_priv
)
;
DCHECK
(
fb
)
;
Vp9FrameBufferPool
*
pool
=
static_cast
<
Vp9FrameBufferPool
*
>
(
user_priv
)
;
rtc
:
:
scoped_refptr
<
Vp9FrameBuffer
>
buffer
=
pool
-
>
GetFrameBuffer
(
min_size
)
;
fb
-
>
data
=
buffer
-
>
GetData
(
)
;
fb
-
>
size
=
buffer
-
>
GetDataSize
(
)
;
fb
-
>
priv
=
static_cast
<
void
*
>
(
buffer
.
release
(
)
)
;
return
0
;
}
int32_t
Vp9FrameBufferPool
:
:
VpxReleaseFrameBuffer
(
void
*
user_priv
vpx_codec_frame_buffer
*
fb
)
{
DCHECK
(
user_priv
)
;
DCHECK
(
fb
)
;
Vp9FrameBuffer
*
buffer
=
static_cast
<
Vp9FrameBuffer
*
>
(
fb
-
>
priv
)
;
if
(
buffer
!
=
nullptr
)
{
buffer
-
>
Release
(
)
;
fb
-
>
priv
=
nullptr
;
}
return
0
;
}
}
