#
include
"
webrtc
/
modules
/
video_coding
/
codecs
/
h264
/
h264_decoder_impl
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
extern
"
C
"
{
#
include
"
third_party
/
ffmpeg
/
libavcodec
/
avcodec
.
h
"
#
include
"
third_party
/
ffmpeg
/
libavformat
/
avformat
.
h
"
#
include
"
third_party
/
ffmpeg
/
libavutil
/
imgutils
.
h
"
}
#
include
"
webrtc
/
api
/
video
/
i420_buffer
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
criticalsection
.
h
"
#
include
"
webrtc
/
base
/
keep_ref_until_done
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
common_video
/
include
/
video_frame_buffer
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
metrics
.
h
"
namespace
webrtc
{
namespace
{
const
AVPixelFormat
kPixelFormat
=
AV_PIX_FMT_YUV420P
;
const
size_t
kYPlaneIndex
=
0
;
const
size_t
kUPlaneIndex
=
1
;
const
size_t
kVPlaneIndex
=
2
;
enum
H264DecoderImplEvent
{
kH264DecoderEventInit
=
0
kH264DecoderEventError
=
1
kH264DecoderEventMax
=
16
}
;
#
if
defined
(
WEBRTC_INITIALIZE_FFMPEG
)
rtc
:
:
CriticalSection
ffmpeg_init_lock
;
bool
ffmpeg_initialized
=
false
;
int
LockManagerOperation
(
void
*
*
lock
AVLockOp
op
)
EXCLUSIVE_LOCK_FUNCTION
(
)
UNLOCK_FUNCTION
(
)
{
switch
(
op
)
{
case
AV_LOCK_CREATE
:
*
lock
=
new
rtc
:
:
CriticalSection
(
)
;
return
0
;
case
AV_LOCK_OBTAIN
:
static_cast
<
rtc
:
:
CriticalSection
*
>
(
*
lock
)
-
>
Enter
(
)
;
return
0
;
case
AV_LOCK_RELEASE
:
static_cast
<
rtc
:
:
CriticalSection
*
>
(
*
lock
)
-
>
Leave
(
)
;
return
0
;
case
AV_LOCK_DESTROY
:
delete
static_cast
<
rtc
:
:
CriticalSection
*
>
(
*
lock
)
;
*
lock
=
nullptr
;
return
0
;
}
RTC_NOTREACHED
(
)
<
<
"
Unrecognized
AVLockOp
.
"
;
return
-
1
;
}
void
InitializeFFmpeg
(
)
{
rtc
:
:
CritScope
cs
(
&
ffmpeg_init_lock
)
;
if
(
!
ffmpeg_initialized
)
{
if
(
av_lockmgr_register
(
LockManagerOperation
)
<
0
)
{
RTC_NOTREACHED
(
)
<
<
"
av_lockmgr_register
failed
.
"
;
return
;
}
av_register_all
(
)
;
ffmpeg_initialized
=
true
;
}
}
#
endif
}
int
H264DecoderImpl
:
:
AVGetBuffer2
(
AVCodecContext
*
context
AVFrame
*
av_frame
int
flags
)
{
H264DecoderImpl
*
decoder
=
static_cast
<
H264DecoderImpl
*
>
(
context
-
>
opaque
)
;
RTC_DCHECK
(
decoder
)
;
RTC_DCHECK_EQ
(
context
-
>
pix_fmt
kPixelFormat
)
;
RTC_DCHECK
(
context
-
>
codec
-
>
capabilities
|
AV_CODEC_CAP_DR1
)
;
int
width
=
av_frame
-
>
width
;
int
height
=
av_frame
-
>
height
;
RTC_CHECK_EQ
(
context
-
>
lowres
0
)
;
avcodec_align_dimensions
(
context
&
width
&
height
)
;
RTC_CHECK_GE
(
width
0
)
;
RTC_CHECK_GE
(
height
0
)
;
int
ret
=
av_image_check_size
(
static_cast
<
unsigned
int
>
(
width
)
static_cast
<
unsigned
int
>
(
height
)
0
nullptr
)
;
if
(
ret
<
0
)
{
LOG
(
LS_ERROR
)
<
<
"
Invalid
picture
size
"
<
<
width
<
<
"
x
"
<
<
height
;
decoder
-
>
ReportError
(
)
;
return
ret
;
}
rtc
:
:
scoped_refptr
<
I420Buffer
>
frame_buffer
=
decoder
-
>
pool_
.
CreateBuffer
(
width
height
)
;
int
y_size
=
width
*
height
;
int
uv_size
=
(
(
width
+
1
)
/
2
)
*
(
(
height
+
1
)
/
2
)
;
RTC_DCHECK_EQ
(
frame_buffer
-
>
DataU
(
)
frame_buffer
-
>
DataY
(
)
+
y_size
)
;
RTC_DCHECK_EQ
(
frame_buffer
-
>
DataV
(
)
frame_buffer
-
>
DataU
(
)
+
uv_size
)
;
int
total_size
=
y_size
+
2
*
uv_size
;
av_frame
-
>
format
=
context
-
>
pix_fmt
;
av_frame
-
>
reordered_opaque
=
context
-
>
reordered_opaque
;
av_frame
-
>
data
[
kYPlaneIndex
]
=
frame_buffer
-
>
MutableDataY
(
)
;
av_frame
-
>
linesize
[
kYPlaneIndex
]
=
frame_buffer
-
>
StrideY
(
)
;
av_frame
-
>
data
[
kUPlaneIndex
]
=
frame_buffer
-
>
MutableDataU
(
)
;
av_frame
-
>
linesize
[
kUPlaneIndex
]
=
frame_buffer
-
>
StrideU
(
)
;
av_frame
-
>
data
[
kVPlaneIndex
]
=
frame_buffer
-
>
MutableDataV
(
)
;
av_frame
-
>
linesize
[
kVPlaneIndex
]
=
frame_buffer
-
>
StrideV
(
)
;
RTC_DCHECK_EQ
(
av_frame
-
>
extended_data
av_frame
-
>
data
)
;
av_frame
-
>
buf
[
0
]
=
av_buffer_create
(
av_frame
-
>
data
[
kYPlaneIndex
]
total_size
AVFreeBuffer2
static_cast
<
void
*
>
(
new
VideoFrame
(
frame_buffer
0
0
kVideoRotation_0
)
)
0
)
;
RTC_CHECK
(
av_frame
-
>
buf
[
0
]
)
;
return
0
;
}
void
H264DecoderImpl
:
:
AVFreeBuffer2
(
void
*
opaque
uint8_t
*
data
)
{
VideoFrame
*
video_frame
=
static_cast
<
VideoFrame
*
>
(
opaque
)
;
delete
video_frame
;
}
H264DecoderImpl
:
:
H264DecoderImpl
(
)
:
pool_
(
true
)
decoded_image_callback_
(
nullptr
)
has_reported_init_
(
false
)
has_reported_error_
(
false
)
{
}
H264DecoderImpl
:
:
~
H264DecoderImpl
(
)
{
Release
(
)
;
}
int32_t
H264DecoderImpl
:
:
InitDecode
(
const
VideoCodec
*
codec_settings
int32_t
number_of_cores
)
{
ReportInit
(
)
;
if
(
codec_settings
&
&
codec_settings
-
>
codecType
!
=
kVideoCodecH264
)
{
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
#
if
defined
(
WEBRTC_INITIALIZE_FFMPEG
)
InitializeFFmpeg
(
)
;
#
endif
int32_t
ret
=
Release
(
)
;
if
(
ret
!
=
WEBRTC_VIDEO_CODEC_OK
)
{
ReportError
(
)
;
return
ret
;
}
RTC_DCHECK
(
!
av_context_
)
;
av_context_
.
reset
(
avcodec_alloc_context3
(
nullptr
)
)
;
av_context_
-
>
codec_type
=
AVMEDIA_TYPE_VIDEO
;
av_context_
-
>
codec_id
=
AV_CODEC_ID_H264
;
if
(
codec_settings
)
{
av_context_
-
>
coded_width
=
codec_settings
-
>
width
;
av_context_
-
>
coded_height
=
codec_settings
-
>
height
;
}
av_context_
-
>
pix_fmt
=
kPixelFormat
;
av_context_
-
>
extradata
=
nullptr
;
av_context_
-
>
extradata_size
=
0
;
av_context_
-
>
thread_count
=
1
;
av_context_
-
>
thread_type
=
FF_THREAD_SLICE
;
av_context_
-
>
get_buffer2
=
AVGetBuffer2
;
av_context_
-
>
opaque
=
this
;
av_context_
-
>
refcounted_frames
=
1
;
AVCodec
*
codec
=
avcodec_find_decoder
(
av_context_
-
>
codec_id
)
;
if
(
!
codec
)
{
LOG
(
LS_ERROR
)
<
<
"
FFmpeg
H
.
264
decoder
not
found
.
"
;
Release
(
)
;
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
int
res
=
avcodec_open2
(
av_context_
.
get
(
)
codec
nullptr
)
;
if
(
res
<
0
)
{
LOG
(
LS_ERROR
)
<
<
"
avcodec_open2
error
:
"
<
<
res
;
Release
(
)
;
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
av_frame_
.
reset
(
av_frame_alloc
(
)
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int32_t
H264DecoderImpl
:
:
Release
(
)
{
av_context_
.
reset
(
)
;
av_frame_
.
reset
(
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int32_t
H264DecoderImpl
:
:
RegisterDecodeCompleteCallback
(
DecodedImageCallback
*
callback
)
{
decoded_image_callback_
=
callback
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int32_t
H264DecoderImpl
:
:
Decode
(
const
EncodedImage
&
input_image
bool
const
RTPFragmentationHeader
*
const
CodecSpecificInfo
*
codec_specific_info
int64_t
)
{
if
(
!
IsInitialized
(
)
)
{
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
!
decoded_image_callback_
)
{
LOG
(
LS_WARNING
)
<
<
"
InitDecode
(
)
has
been
called
but
a
callback
function
"
"
has
not
been
set
with
RegisterDecodeCompleteCallback
(
)
"
;
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
!
input_image
.
_buffer
|
|
!
input_image
.
_length
)
{
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
codec_specific_info
&
&
codec_specific_info
-
>
codecType
!
=
kVideoCodecH264
)
{
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
RTC_CHECK_GE
(
input_image
.
_size
input_image
.
_length
+
EncodedImage
:
:
GetBufferPaddingBytes
(
kVideoCodecH264
)
)
;
memset
(
input_image
.
_buffer
+
input_image
.
_length
0
EncodedImage
:
:
GetBufferPaddingBytes
(
kVideoCodecH264
)
)
;
AVPacket
packet
;
av_init_packet
(
&
packet
)
;
packet
.
data
=
input_image
.
_buffer
;
if
(
input_image
.
_length
>
static_cast
<
size_t
>
(
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
)
{
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
packet
.
size
=
static_cast
<
int
>
(
input_image
.
_length
)
;
av_context_
-
>
reordered_opaque
=
input_image
.
ntp_time_ms_
*
1000
;
int
frame_decoded
=
0
;
int
result
=
avcodec_decode_video2
(
av_context_
.
get
(
)
av_frame_
.
get
(
)
&
frame_decoded
&
packet
)
;
if
(
result
<
0
)
{
LOG
(
LS_ERROR
)
<
<
"
avcodec_decode_video2
error
:
"
<
<
result
;
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
if
(
result
!
=
packet
.
size
)
{
LOG
(
LS_ERROR
)
<
<
"
avcodec_decode_video2
consumed
"
<
<
result
<
<
"
bytes
"
"
when
"
<
<
packet
.
size
<
<
"
bytes
were
expected
.
"
;
ReportError
(
)
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
if
(
!
frame_decoded
)
{
LOG
(
LS_WARNING
)
<
<
"
avcodec_decode_video2
successful
but
no
frame
was
"
"
decoded
.
"
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
VideoFrame
*
video_frame
=
static_cast
<
VideoFrame
*
>
(
av_buffer_get_opaque
(
av_frame_
-
>
buf
[
0
]
)
)
;
RTC_DCHECK
(
video_frame
)
;
RTC_CHECK_EQ
(
av_frame_
-
>
data
[
kYPlaneIndex
]
video_frame
-
>
video_frame_buffer
(
)
-
>
DataY
(
)
)
;
RTC_CHECK_EQ
(
av_frame_
-
>
data
[
kUPlaneIndex
]
video_frame
-
>
video_frame_buffer
(
)
-
>
DataU
(
)
)
;
RTC_CHECK_EQ
(
av_frame_
-
>
data
[
kVPlaneIndex
]
video_frame
-
>
video_frame_buffer
(
)
-
>
DataV
(
)
)
;
video_frame
-
>
set_timestamp
(
input_image
.
_timeStamp
)
;
int32_t
ret
;
rtc
:
:
scoped_refptr
<
VideoFrameBuffer
>
buf
=
video_frame
-
>
video_frame_buffer
(
)
;
if
(
av_frame_
-
>
width
!
=
buf
-
>
width
(
)
|
|
av_frame_
-
>
height
!
=
buf
-
>
height
(
)
)
{
rtc
:
:
scoped_refptr
<
VideoFrameBuffer
>
cropped_buf
(
new
rtc
:
:
RefCountedObject
<
WrappedI420Buffer
>
(
av_frame_
-
>
width
av_frame_
-
>
height
buf
-
>
DataY
(
)
buf
-
>
StrideY
(
)
buf
-
>
DataU
(
)
buf
-
>
StrideU
(
)
buf
-
>
DataV
(
)
buf
-
>
StrideV
(
)
rtc
:
:
KeepRefUntilDone
(
buf
)
)
)
;
VideoFrame
cropped_frame
(
cropped_buf
video_frame
-
>
timestamp
(
)
video_frame
-
>
render_time_ms
(
)
video_frame
-
>
rotation
(
)
)
;
ret
=
decoded_image_callback_
-
>
Decoded
(
cropped_frame
)
;
}
else
{
ret
=
decoded_image_callback_
-
>
Decoded
(
*
video_frame
)
;
}
av_frame_unref
(
av_frame_
.
get
(
)
)
;
video_frame
=
nullptr
;
if
(
ret
)
{
LOG
(
LS_WARNING
)
<
<
"
DecodedImageCallback
:
:
Decoded
returned
"
<
<
ret
;
return
ret
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
const
char
*
H264DecoderImpl
:
:
ImplementationName
(
)
const
{
return
"
FFmpeg
"
;
}
bool
H264DecoderImpl
:
:
IsInitialized
(
)
const
{
return
av_context_
!
=
nullptr
;
}
void
H264DecoderImpl
:
:
ReportInit
(
)
{
if
(
has_reported_init_
)
return
;
RTC_HISTOGRAM_ENUMERATION
(
"
WebRTC
.
Video
.
H264DecoderImpl
.
Event
"
kH264DecoderEventInit
kH264DecoderEventMax
)
;
has_reported_init_
=
true
;
}
void
H264DecoderImpl
:
:
ReportError
(
)
{
if
(
has_reported_error_
)
return
;
RTC_HISTOGRAM_ENUMERATION
(
"
WebRTC
.
Video
.
H264DecoderImpl
.
Event
"
kH264DecoderEventError
kH264DecoderEventMax
)
;
has_reported_error_
=
true
;
}
}
