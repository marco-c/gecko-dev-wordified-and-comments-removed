#
include
"
webrtc
/
modules
/
video_coding
/
codecs
/
vp8
/
simulcast_encoder_adapter
.
h
"
#
include
<
algorithm
>
#
include
"
libyuv
/
scale
.
h
"
#
include
"
webrtc
/
common
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
codecs
/
vp8
/
screenshare_layers
.
h
"
namespace
{
const
unsigned
int
kDefaultMinQp
=
2
;
const
unsigned
int
kDefaultMaxQp
=
56
;
const
unsigned
int
kLowestResMaxQp
=
45
;
uint32_t
SumStreamTargetBitrate
(
int
streams
const
webrtc
:
:
VideoCodec
&
codec
)
{
uint32_t
bitrate_sum
=
0
;
for
(
int
i
=
0
;
i
<
streams
;
+
+
i
)
{
bitrate_sum
+
=
codec
.
simulcastStream
[
i
]
.
targetBitrate
;
}
return
bitrate_sum
;
}
uint32_t
SumStreamMaxBitrate
(
int
streams
const
webrtc
:
:
VideoCodec
&
codec
)
{
uint32_t
bitrate_sum
=
0
;
for
(
int
i
=
0
;
i
<
streams
;
+
+
i
)
{
bitrate_sum
+
=
codec
.
simulcastStream
[
i
]
.
maxBitrate
;
}
return
bitrate_sum
;
}
int
NumberOfStreams
(
const
webrtc
:
:
VideoCodec
&
codec
)
{
int
streams
=
codec
.
numberOfSimulcastStreams
<
1
?
1
:
codec
.
numberOfSimulcastStreams
;
uint32_t
simulcast_max_bitrate
=
SumStreamMaxBitrate
(
streams
codec
)
;
if
(
simulcast_max_bitrate
=
=
0
)
{
streams
=
1
;
}
return
streams
;
}
bool
ValidSimulcastResolutions
(
const
webrtc
:
:
VideoCodec
&
codec
int
num_streams
)
{
if
(
codec
.
width
!
=
codec
.
simulcastStream
[
num_streams
-
1
]
.
width
|
|
codec
.
height
!
=
codec
.
simulcastStream
[
num_streams
-
1
]
.
height
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
num_streams
;
+
+
i
)
{
if
(
codec
.
width
*
codec
.
simulcastStream
[
i
]
.
height
!
=
codec
.
height
*
codec
.
simulcastStream
[
i
]
.
width
)
{
return
false
;
}
}
return
true
;
}
int
VerifyCodec
(
const
webrtc
:
:
VideoCodec
*
inst
)
{
if
(
inst
=
=
NULL
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
maxFramerate
<
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
maxBitrate
>
0
&
&
inst
-
>
startBitrate
>
inst
-
>
maxBitrate
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
width
<
=
1
|
|
inst
-
>
height
<
=
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
codecSpecific
.
VP8
.
feedbackModeOn
&
&
inst
-
>
numberOfSimulcastStreams
>
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
inst
-
>
codecSpecific
.
VP8
.
automaticResizeOn
&
&
inst
-
>
numberOfSimulcastStreams
>
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
const
float
kTl1MaxTimeToDropFrames
=
20
.
0f
;
struct
ScreenshareTemporalLayersFactory
:
webrtc
:
:
TemporalLayers
:
:
Factory
{
ScreenshareTemporalLayersFactory
(
)
:
tl1_frame_dropper_
(
kTl1MaxTimeToDropFrames
)
{
}
virtual
~
ScreenshareTemporalLayersFactory
(
)
{
}
virtual
webrtc
:
:
TemporalLayers
*
Create
(
int
num_temporal_layers
uint8_t
initial_tl0_pic_idx
)
const
{
return
new
webrtc
:
:
ScreenshareLayers
(
num_temporal_layers
rand
(
)
&
tl0_frame_dropper_
&
tl1_frame_dropper_
)
;
}
mutable
webrtc
:
:
FrameDropper
tl0_frame_dropper_
;
mutable
webrtc
:
:
FrameDropper
tl1_frame_dropper_
;
}
;
}
namespace
webrtc
{
SimulcastEncoderAdapter
:
:
SimulcastEncoderAdapter
(
VideoEncoderFactory
*
factory
)
:
factory_
(
factory
)
encoded_complete_callback_
(
NULL
)
{
memset
(
&
codec_
0
sizeof
(
webrtc
:
:
VideoCodec
)
)
;
}
SimulcastEncoderAdapter
:
:
~
SimulcastEncoderAdapter
(
)
{
Release
(
)
;
}
int
SimulcastEncoderAdapter
:
:
Release
(
)
{
while
(
!
streaminfos_
.
empty
(
)
)
{
VideoEncoder
*
encoder
=
streaminfos_
.
back
(
)
.
encoder
;
factory_
-
>
Destroy
(
encoder
)
;
streaminfos_
.
pop_back
(
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
SimulcastEncoderAdapter
:
:
InitEncode
(
const
VideoCodec
*
inst
int
number_of_cores
size_t
max_payload_size
)
{
if
(
number_of_cores
<
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
int
ret
=
VerifyCodec
(
inst
)
;
if
(
ret
<
0
)
{
return
ret
;
}
ret
=
Release
(
)
;
if
(
ret
<
0
)
{
return
ret
;
}
int
number_of_streams
=
NumberOfStreams
(
*
inst
)
;
bool
doing_simulcast
=
(
number_of_streams
>
1
)
;
if
(
doing_simulcast
&
&
!
ValidSimulcastResolutions
(
*
inst
number_of_streams
)
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
codec_
=
*
inst
;
if
(
number_of_streams
=
=
1
&
&
inst
-
>
mode
=
=
kScreensharing
)
{
screensharing_extra_options_
.
reset
(
new
Config
(
)
)
;
screensharing_extra_options_
-
>
Set
<
TemporalLayers
:
:
Factory
>
(
new
ScreenshareTemporalLayersFactory
(
)
)
;
codec_
.
extra_options
=
screensharing_extra_options_
.
get
(
)
;
}
for
(
int
i
=
0
;
i
<
number_of_streams
;
+
+
i
)
{
VideoCodec
stream_codec
;
bool
send_stream
=
true
;
if
(
!
doing_simulcast
)
{
stream_codec
=
codec_
;
stream_codec
.
numberOfSimulcastStreams
=
1
;
}
else
{
bool
highest_resolution_stream
=
(
i
=
=
(
number_of_streams
-
1
)
)
;
PopulateStreamCodec
(
&
codec_
i
highest_resolution_stream
&
stream_codec
&
send_stream
)
;
}
if
(
stream_codec
.
qpMax
<
kDefaultMinQp
)
{
stream_codec
.
qpMax
=
kDefaultMaxQp
;
}
VideoEncoder
*
encoder
=
factory_
-
>
Create
(
)
;
ret
=
encoder
-
>
InitEncode
(
&
stream_codec
number_of_cores
max_payload_size
)
;
if
(
ret
<
0
)
{
Release
(
)
;
return
ret
;
}
encoder
-
>
RegisterEncodeCompleteCallback
(
this
)
;
streaminfos_
.
push_back
(
StreamInfo
(
encoder
stream_codec
.
width
stream_codec
.
height
send_stream
)
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
SimulcastEncoderAdapter
:
:
Encode
(
const
I420VideoFrame
&
input_image
const
CodecSpecificInfo
*
codec_specific_info
const
std
:
:
vector
<
VideoFrameType
>
*
frame_types
)
{
if
(
!
Initialized
(
)
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
encoded_complete_callback_
=
=
NULL
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
bool
send_key_frame
=
false
;
if
(
frame_types
)
{
for
(
size_t
i
=
0
;
i
<
frame_types
-
>
size
(
)
;
+
+
i
)
{
if
(
frame_types
-
>
at
(
i
)
=
=
kKeyFrame
)
{
send_key_frame
=
true
;
break
;
}
}
}
for
(
size_t
stream_idx
=
0
;
stream_idx
<
streaminfos_
.
size
(
)
;
+
+
stream_idx
)
{
if
(
streaminfos_
[
stream_idx
]
.
key_frame_request
&
&
streaminfos_
[
stream_idx
]
.
send_stream
)
{
send_key_frame
=
true
;
break
;
}
}
int
src_width
=
input_image
.
width
(
)
;
int
src_height
=
input_image
.
height
(
)
;
for
(
size_t
stream_idx
=
0
;
stream_idx
<
streaminfos_
.
size
(
)
;
+
+
stream_idx
)
{
std
:
:
vector
<
VideoFrameType
>
stream_frame_types
;
if
(
send_key_frame
)
{
stream_frame_types
.
push_back
(
kKeyFrame
)
;
streaminfos_
[
stream_idx
]
.
key_frame_request
=
false
;
}
else
{
stream_frame_types
.
push_back
(
kDeltaFrame
)
;
}
int
dst_width
=
streaminfos_
[
stream_idx
]
.
width
;
int
dst_height
=
streaminfos_
[
stream_idx
]
.
height
;
if
(
(
dst_width
=
=
src_width
&
&
dst_height
=
=
src_height
)
|
|
input_image
.
IsZeroSize
(
)
)
{
streaminfos_
[
stream_idx
]
.
encoder
-
>
Encode
(
input_image
codec_specific_info
&
stream_frame_types
)
;
}
else
{
I420VideoFrame
dst_frame
;
dst_frame
.
CreateEmptyFrame
(
dst_width
dst_height
dst_width
(
dst_width
+
1
)
/
2
(
dst_width
+
1
)
/
2
)
;
libyuv
:
:
I420Scale
(
input_image
.
buffer
(
kYPlane
)
input_image
.
stride
(
kYPlane
)
input_image
.
buffer
(
kUPlane
)
input_image
.
stride
(
kUPlane
)
input_image
.
buffer
(
kVPlane
)
input_image
.
stride
(
kVPlane
)
src_width
src_height
dst_frame
.
buffer
(
kYPlane
)
dst_frame
.
stride
(
kYPlane
)
dst_frame
.
buffer
(
kUPlane
)
dst_frame
.
stride
(
kUPlane
)
dst_frame
.
buffer
(
kVPlane
)
dst_frame
.
stride
(
kVPlane
)
dst_width
dst_height
libyuv
:
:
kFilterBilinear
)
;
dst_frame
.
set_timestamp
(
input_image
.
timestamp
(
)
)
;
dst_frame
.
set_render_time_ms
(
input_image
.
render_time_ms
(
)
)
;
streaminfos_
[
stream_idx
]
.
encoder
-
>
Encode
(
dst_frame
codec_specific_info
&
stream_frame_types
)
;
}
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
SimulcastEncoderAdapter
:
:
RegisterEncodeCompleteCallback
(
EncodedImageCallback
*
callback
)
{
encoded_complete_callback_
=
callback
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
SimulcastEncoderAdapter
:
:
SetChannelParameters
(
uint32_t
packet_loss
int64_t
rtt
)
{
for
(
size_t
stream_idx
=
0
;
stream_idx
<
streaminfos_
.
size
(
)
;
+
+
stream_idx
)
{
streaminfos_
[
stream_idx
]
.
encoder
-
>
SetChannelParameters
(
packet_loss
rtt
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
SimulcastEncoderAdapter
:
:
SetRates
(
uint32_t
new_bitrate_kbit
uint32_t
new_framerate
)
{
if
(
!
Initialized
(
)
)
{
return
WEBRTC_VIDEO_CODEC_UNINITIALIZED
;
}
if
(
new_framerate
<
1
)
{
return
WEBRTC_VIDEO_CODEC_ERR_PARAMETER
;
}
if
(
codec_
.
maxBitrate
>
0
&
&
new_bitrate_kbit
>
codec_
.
maxBitrate
)
{
new_bitrate_kbit
=
codec_
.
maxBitrate
;
}
if
(
new_bitrate_kbit
<
codec_
.
minBitrate
)
{
new_bitrate_kbit
=
codec_
.
minBitrate
;
}
if
(
codec_
.
numberOfSimulcastStreams
>
0
&
&
new_bitrate_kbit
<
codec_
.
simulcastStream
[
0
]
.
minBitrate
)
{
new_bitrate_kbit
=
codec_
.
simulcastStream
[
0
]
.
minBitrate
;
}
codec_
.
maxFramerate
=
new_framerate
;
bool
send_stream
=
true
;
uint32_t
stream_bitrate
=
0
;
for
(
size_t
stream_idx
=
0
;
stream_idx
<
streaminfos_
.
size
(
)
;
+
+
stream_idx
)
{
stream_bitrate
=
GetStreamBitrate
(
stream_idx
new_bitrate_kbit
&
send_stream
)
;
if
(
send_stream
&
&
!
streaminfos_
[
stream_idx
]
.
send_stream
)
{
streaminfos_
[
stream_idx
]
.
key_frame_request
=
true
;
}
streaminfos_
[
stream_idx
]
.
send_stream
=
send_stream
;
if
(
codec_
.
targetBitrate
>
0
&
&
(
codec_
.
codecSpecific
.
VP8
.
numberOfTemporalLayers
=
=
2
|
|
codec_
.
simulcastStream
[
0
]
.
numberOfTemporalLayers
=
=
2
)
)
{
stream_bitrate
=
std
:
:
min
(
codec_
.
maxBitrate
stream_bitrate
)
;
}
streaminfos_
[
stream_idx
]
.
encoder
-
>
SetRates
(
stream_bitrate
new_framerate
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int32_t
SimulcastEncoderAdapter
:
:
Encoded
(
const
EncodedImage
&
encodedImage
const
CodecSpecificInfo
*
codecSpecificInfo
const
RTPFragmentationHeader
*
fragmentation
)
{
size_t
stream_idx
=
GetStreamIndex
(
encodedImage
)
;
CodecSpecificInfo
stream_codec_specific
=
*
codecSpecificInfo
;
CodecSpecificInfoVP8
*
vp8Info
=
&
(
stream_codec_specific
.
codecSpecific
.
VP8
)
;
vp8Info
-
>
simulcastIdx
=
stream_idx
;
if
(
streaminfos_
[
stream_idx
]
.
send_stream
)
{
return
encoded_complete_callback_
-
>
Encoded
(
encodedImage
&
stream_codec_specific
fragmentation
)
;
}
else
{
EncodedImage
dummy_image
;
dummy_image
.
_timeStamp
=
encodedImage
.
_timeStamp
;
dummy_image
.
capture_time_ms_
=
encodedImage
.
capture_time_ms_
;
dummy_image
.
_encodedWidth
=
encodedImage
.
_encodedWidth
;
dummy_image
.
_encodedHeight
=
encodedImage
.
_encodedHeight
;
dummy_image
.
_length
=
0
;
dummy_image
.
_frameType
=
kSkipFrame
;
vp8Info
-
>
keyIdx
=
kNoKeyIdx
;
return
encoded_complete_callback_
-
>
Encoded
(
dummy_image
&
stream_codec_specific
NULL
)
;
}
}
uint32_t
SimulcastEncoderAdapter
:
:
GetStreamBitrate
(
int
stream_idx
uint32_t
new_bitrate_kbit
bool
*
send_stream
)
const
{
if
(
streaminfos_
.
size
(
)
=
=
1
)
{
*
send_stream
=
true
;
return
new_bitrate_kbit
;
}
uint32_t
sum_target_lower_streams
=
SumStreamTargetBitrate
(
stream_idx
codec_
)
;
uint32_t
bitrate_to_send_this_layer
=
codec_
.
simulcastStream
[
stream_idx
]
.
minBitrate
+
sum_target_lower_streams
;
if
(
new_bitrate_kbit
>
=
bitrate_to_send_this_layer
)
{
*
send_stream
=
true
;
if
(
stream_idx
<
codec_
.
numberOfSimulcastStreams
-
1
)
{
unsigned
int
max_rate
=
codec_
.
simulcastStream
[
stream_idx
]
.
maxBitrate
;
if
(
new_bitrate_kbit
>
=
SumStreamTargetBitrate
(
stream_idx
+
1
codec_
)
+
codec_
.
simulcastStream
[
stream_idx
+
1
]
.
minBitrate
)
{
max_rate
=
codec_
.
simulcastStream
[
stream_idx
]
.
targetBitrate
;
}
return
std
:
:
min
(
new_bitrate_kbit
-
sum_target_lower_streams
max_rate
)
;
}
else
{
return
new_bitrate_kbit
-
sum_target_lower_streams
;
}
}
else
{
*
send_stream
=
false
;
return
codec_
.
simulcastStream
[
stream_idx
-
1
]
.
maxBitrate
;
}
}
void
SimulcastEncoderAdapter
:
:
PopulateStreamCodec
(
const
webrtc
:
:
VideoCodec
*
inst
int
stream_index
bool
highest_resolution_stream
webrtc
:
:
VideoCodec
*
stream_codec
bool
*
send_stream
)
{
*
stream_codec
=
*
inst
;
stream_codec
-
>
codecSpecific
.
VP8
.
numberOfTemporalLayers
=
inst
-
>
simulcastStream
[
stream_index
]
.
numberOfTemporalLayers
;
stream_codec
-
>
numberOfSimulcastStreams
=
0
;
stream_codec
-
>
width
=
inst
-
>
simulcastStream
[
stream_index
]
.
width
;
stream_codec
-
>
height
=
inst
-
>
simulcastStream
[
stream_index
]
.
height
;
stream_codec
-
>
maxBitrate
=
inst
-
>
simulcastStream
[
stream_index
]
.
maxBitrate
;
stream_codec
-
>
minBitrate
=
inst
-
>
simulcastStream
[
stream_index
]
.
minBitrate
;
stream_codec
-
>
qpMax
=
inst
-
>
simulcastStream
[
stream_index
]
.
qpMax
;
if
(
stream_index
=
=
0
)
{
stream_codec
-
>
qpMax
=
kLowestResMaxQp
;
}
if
(
!
highest_resolution_stream
)
{
int
pixels_per_frame
=
stream_codec
-
>
width
*
stream_codec
-
>
height
;
if
(
pixels_per_frame
<
352
*
288
)
{
stream_codec
-
>
codecSpecific
.
VP8
.
complexity
=
webrtc
:
:
kComplexityHigher
;
}
stream_codec
-
>
codecSpecific
.
VP8
.
denoisingOn
=
false
;
}
int
stream_bitrate
=
GetStreamBitrate
(
stream_index
inst
-
>
startBitrate
send_stream
)
;
stream_codec
-
>
startBitrate
=
stream_bitrate
;
}
size_t
SimulcastEncoderAdapter
:
:
GetStreamIndex
(
const
EncodedImage
&
encodedImage
)
{
uint32_t
width
=
encodedImage
.
_encodedWidth
;
uint32_t
height
=
encodedImage
.
_encodedHeight
;
for
(
size_t
stream_idx
=
0
;
stream_idx
<
streaminfos_
.
size
(
)
;
+
+
stream_idx
)
{
if
(
streaminfos_
[
stream_idx
]
.
width
=
=
width
&
&
streaminfos_
[
stream_idx
]
.
height
=
=
height
)
{
return
stream_idx
;
}
}
assert
(
false
)
;
return
0
;
}
bool
SimulcastEncoderAdapter
:
:
Initialized
(
)
const
{
return
!
streaminfos_
.
empty
(
)
;
}
}
