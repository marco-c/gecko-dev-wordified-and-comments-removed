#
include
"
modules
/
video_coding
/
codecs
/
test
/
video_codec_test
.
h
"
#
include
"
api
/
video
/
i420_buffer
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_error_codes
.
h
"
#
include
"
test
/
frame_utils
.
h
"
#
include
"
test
/
testsupport
/
fileutils
.
h
"
static
const
int
kEncodeTimeoutMs
=
100
;
static
const
int
kDecodeTimeoutMs
=
25
;
static
const
int
kStartBitrate
=
300
;
static
const
int
kTargetBitrate
=
2000
;
static
const
int
kMaxBitrate
=
4000
;
static
const
int
kWidth
=
172
;
static
const
int
kHeight
=
144
;
static
const
int
kMaxFramerate
=
30
;
namespace
webrtc
{
EncodedImageCallback
:
:
Result
VideoCodecTest
:
:
FakeEncodeCompleteCallback
:
:
OnEncodedImage
(
const
EncodedImage
&
frame
const
CodecSpecificInfo
*
codec_specific_info
const
RTPFragmentationHeader
*
fragmentation
)
{
rtc
:
:
CritScope
lock
(
&
test_
-
>
encoded_frame_section_
)
;
test_
-
>
encoded_frame_
.
emplace
(
frame
)
;
RTC_DCHECK
(
codec_specific_info
)
;
test_
-
>
codec_specific_info_
.
codecType
=
codec_specific_info
-
>
codecType
;
test_
-
>
codec_specific_info_
.
codecSpecific
=
codec_specific_info
-
>
codecSpecific
;
test_
-
>
encoded_frame_event_
.
Set
(
)
;
return
Result
(
Result
:
:
OK
)
;
}
void
VideoCodecTest
:
:
FakeDecodeCompleteCallback
:
:
Decoded
(
VideoFrame
&
frame
rtc
:
:
Optional
<
int32_t
>
decode_time_ms
rtc
:
:
Optional
<
uint8_t
>
qp
)
{
rtc
:
:
CritScope
lock
(
&
test_
-
>
decoded_frame_section_
)
;
test_
-
>
decoded_frame_
.
emplace
(
frame
)
;
test_
-
>
decoded_qp_
=
qp
;
test_
-
>
decoded_frame_event_
.
Set
(
)
;
}
void
VideoCodecTest
:
:
SetUp
(
)
{
FILE
*
source_file_
=
fopen
(
test
:
:
ResourcePath
(
"
paris_qcif
"
"
yuv
"
)
.
c_str
(
)
"
rb
"
)
;
ASSERT_TRUE
(
source_file_
!
=
NULL
)
;
rtc
:
:
scoped_refptr
<
VideoFrameBuffer
>
video_frame_buffer
(
test
:
:
ReadI420Buffer
(
kWidth
kHeight
source_file_
)
)
;
input_frame_
.
reset
(
new
VideoFrame
(
video_frame_buffer
kVideoRotation_0
0
)
)
;
fclose
(
source_file_
)
;
encoder_
=
CreateEncoder
(
)
;
decoder_
=
CreateDecoder
(
)
;
encoder_
-
>
RegisterEncodeCompleteCallback
(
&
encode_complete_callback_
)
;
decoder_
-
>
RegisterDecodeCompleteCallback
(
&
decode_complete_callback_
)
;
InitCodecs
(
)
;
}
bool
VideoCodecTest
:
:
WaitForEncodedFrame
(
EncodedImage
*
frame
CodecSpecificInfo
*
codec_specific_info
)
{
bool
ret
=
encoded_frame_event_
.
Wait
(
kEncodeTimeoutMs
)
;
EXPECT_TRUE
(
ret
)
<
<
"
Timed
out
while
waiting
for
an
encoded
frame
.
"
;
rtc
:
:
CritScope
lock
(
&
encoded_frame_section_
)
;
EXPECT_TRUE
(
encoded_frame_
)
;
if
(
encoded_frame_
)
{
*
frame
=
std
:
:
move
(
*
encoded_frame_
)
;
encoded_frame_
.
reset
(
)
;
RTC_DCHECK
(
codec_specific_info
)
;
codec_specific_info
-
>
codecType
=
codec_specific_info_
.
codecType
;
codec_specific_info
-
>
codecSpecific
=
codec_specific_info_
.
codecSpecific
;
return
true
;
}
else
{
return
false
;
}
}
bool
VideoCodecTest
:
:
WaitForDecodedFrame
(
std
:
:
unique_ptr
<
VideoFrame
>
*
frame
rtc
:
:
Optional
<
uint8_t
>
*
qp
)
{
bool
ret
=
decoded_frame_event_
.
Wait
(
kDecodeTimeoutMs
)
;
EXPECT_TRUE
(
ret
)
<
<
"
Timed
out
while
waiting
for
a
decoded
frame
.
"
;
rtc
:
:
CritScope
lock
(
&
decoded_frame_section_
)
;
EXPECT_TRUE
(
decoded_frame_
)
;
if
(
decoded_frame_
)
{
frame
-
>
reset
(
new
VideoFrame
(
std
:
:
move
(
*
decoded_frame_
)
)
)
;
*
qp
=
decoded_qp_
;
decoded_frame_
.
reset
(
)
;
return
true
;
}
else
{
return
false
;
}
}
void
VideoCodecTest
:
:
InitCodecs
(
)
{
codec_settings_
=
codec_settings
(
)
;
codec_settings_
.
startBitrate
=
kStartBitrate
;
codec_settings_
.
targetBitrate
=
kTargetBitrate
;
codec_settings_
.
maxBitrate
=
kMaxBitrate
;
codec_settings_
.
maxFramerate
=
kMaxFramerate
;
codec_settings_
.
width
=
kWidth
;
codec_settings_
.
height
=
kHeight
;
EXPECT_EQ
(
WEBRTC_VIDEO_CODEC_OK
encoder_
-
>
InitEncode
(
&
codec_settings_
1
0
)
)
;
EXPECT_EQ
(
WEBRTC_VIDEO_CODEC_OK
decoder_
-
>
InitDecode
(
&
codec_settings_
1
)
)
;
}
}
