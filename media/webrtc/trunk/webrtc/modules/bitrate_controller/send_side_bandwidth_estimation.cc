#
include
"
webrtc
/
modules
/
bitrate_controller
/
send_side_bandwidth_estimation
.
h
"
#
include
<
cmath
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
field_trial
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
logging
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
metrics
.
h
"
namespace
webrtc
{
namespace
{
const
int64_t
kBweIncreaseIntervalMs
=
1000
;
const
int64_t
kBweDecreaseIntervalMs
=
300
;
const
int64_t
kStartPhaseMs
=
2000
;
const
int64_t
kBweConverganceTimeMs
=
20000
;
const
int
kLimitNumPackets
=
20
;
const
int
kAvgPacketSizeBytes
=
1000
;
const
int
kDefaultMinBitrateBps
=
10000
;
const
int
kDefaultMaxBitrateBps
=
1000000000
;
struct
UmaRampUpMetric
{
const
char
*
metric_name
;
int
bitrate_kbps
;
}
;
const
UmaRampUpMetric
kUmaRampupMetrics
[
]
=
{
{
"
WebRTC
.
BWE
.
RampUpTimeTo500kbpsInMs
"
500
}
{
"
WebRTC
.
BWE
.
RampUpTimeTo1000kbpsInMs
"
1000
}
{
"
WebRTC
.
BWE
.
RampUpTimeTo2000kbpsInMs
"
2000
}
}
;
const
size_t
kNumUmaRampupMetrics
=
sizeof
(
kUmaRampupMetrics
)
/
sizeof
(
kUmaRampupMetrics
[
0
]
)
;
uint32_t
CalcTfrcBps
(
int64_t
rtt
uint8_t
loss
)
{
if
(
rtt
=
=
0
|
|
loss
=
=
0
)
{
return
0
;
}
double
R
=
static_cast
<
double
>
(
rtt
)
/
1000
;
int
b
=
1
;
double
t_RTO
=
4
.
0
*
R
;
double
p
=
static_cast
<
double
>
(
loss
)
/
255
;
double
s
=
static_cast
<
double
>
(
kAvgPacketSizeBytes
)
;
double
X
=
s
/
(
R
*
std
:
:
sqrt
(
2
*
b
*
p
/
3
)
+
(
t_RTO
*
(
3
*
std
:
:
sqrt
(
3
*
b
*
p
/
8
)
*
p
*
(
1
+
32
*
p
*
p
)
)
)
)
;
return
(
static_cast
<
uint32_t
>
(
X
*
8
)
)
;
}
}
SendSideBandwidthEstimation
:
:
SendSideBandwidthEstimation
(
)
:
accumulate_lost_packets_Q8_
(
0
)
accumulate_expected_packets_
(
0
)
bitrate_
(
0
)
min_bitrate_configured_
(
kDefaultMinBitrateBps
)
max_bitrate_configured_
(
kDefaultMaxBitrateBps
)
time_last_receiver_block_ms_
(
0
)
last_fraction_loss_
(
0
)
last_round_trip_time_ms_
(
0
)
bwe_incoming_
(
0
)
time_last_decrease_ms_
(
0
)
first_report_time_ms_
(
-
1
)
initially_lost_packets_
(
0
)
bitrate_at_2_seconds_kbps_
(
0
)
uma_update_state_
(
kNoUpdate
)
rampup_uma_stats_updated_
(
kNumUmaRampupMetrics
false
)
{
}
SendSideBandwidthEstimation
:
:
~
SendSideBandwidthEstimation
(
)
{
}
void
SendSideBandwidthEstimation
:
:
SetSendBitrate
(
int
bitrate
)
{
DCHECK_GT
(
bitrate
0
)
;
bitrate_
=
bitrate
;
min_bitrate_history_
.
clear
(
)
;
}
void
SendSideBandwidthEstimation
:
:
SetMinMaxBitrate
(
int
min_bitrate
int
max_bitrate
)
{
DCHECK_GE
(
min_bitrate
0
)
;
min_bitrate_configured_
=
std
:
:
max
(
min_bitrate
kDefaultMinBitrateBps
)
;
if
(
max_bitrate
>
0
)
{
max_bitrate_configured_
=
std
:
:
max
<
uint32_t
>
(
min_bitrate_configured_
max_bitrate
)
;
}
else
{
max_bitrate_configured_
=
kDefaultMaxBitrateBps
;
}
}
int
SendSideBandwidthEstimation
:
:
GetMinBitrate
(
)
const
{
return
min_bitrate_configured_
;
}
void
SendSideBandwidthEstimation
:
:
CurrentEstimate
(
int
*
bitrate
uint8_t
*
loss
int64_t
*
rtt
)
const
{
*
bitrate
=
bitrate_
;
*
loss
=
last_fraction_loss_
;
*
rtt
=
last_round_trip_time_ms_
;
}
void
SendSideBandwidthEstimation
:
:
UpdateReceiverEstimate
(
uint32_t
bandwidth
)
{
bwe_incoming_
=
bandwidth
;
bitrate_
=
CapBitrateToThresholds
(
bitrate_
)
;
}
void
SendSideBandwidthEstimation
:
:
UpdateReceiverBlock
(
uint8_t
fraction_loss
int64_t
rtt
int
number_of_packets
int64_t
now_ms
)
{
if
(
first_report_time_ms_
=
=
-
1
)
first_report_time_ms_
=
now_ms
;
last_round_trip_time_ms_
=
rtt
;
if
(
number_of_packets
>
0
)
{
const
int
num_lost_packets_Q8
=
fraction_loss
*
number_of_packets
;
accumulate_lost_packets_Q8_
+
=
num_lost_packets_Q8
;
accumulate_expected_packets_
+
=
number_of_packets
;
if
(
accumulate_expected_packets_
>
=
kLimitNumPackets
)
{
last_fraction_loss_
=
accumulate_lost_packets_Q8_
/
accumulate_expected_packets_
;
accumulate_lost_packets_Q8_
=
0
;
accumulate_expected_packets_
=
0
;
}
else
{
return
;
}
}
time_last_receiver_block_ms_
=
now_ms
;
UpdateEstimate
(
now_ms
)
;
UpdateUmaStats
(
now_ms
rtt
(
fraction_loss
*
number_of_packets
)
>
>
8
)
;
}
void
SendSideBandwidthEstimation
:
:
UpdateUmaStats
(
int64_t
now_ms
int64_t
rtt
int
lost_packets
)
{
int
bitrate_kbps
=
static_cast
<
int
>
(
(
bitrate_
+
500
)
/
1000
)
;
for
(
size_t
i
=
0
;
i
<
kNumUmaRampupMetrics
;
+
+
i
)
{
if
(
!
rampup_uma_stats_updated_
[
i
]
&
&
bitrate_kbps
>
=
kUmaRampupMetrics
[
i
]
.
bitrate_kbps
)
{
RTC_HISTOGRAM_COUNTS_100000
(
kUmaRampupMetrics
[
i
]
.
metric_name
now_ms
-
first_report_time_ms_
)
;
rampup_uma_stats_updated_
[
i
]
=
true
;
}
}
if
(
IsInStartPhase
(
now_ms
)
)
{
initially_lost_packets_
+
=
lost_packets
;
}
else
if
(
uma_update_state_
=
=
kNoUpdate
)
{
uma_update_state_
=
kFirstDone
;
bitrate_at_2_seconds_kbps_
=
bitrate_kbps
;
RTC_HISTOGRAM_COUNTS
(
"
WebRTC
.
BWE
.
InitiallyLostPackets
"
initially_lost_packets_
0
100
50
)
;
RTC_HISTOGRAM_COUNTS
(
"
WebRTC
.
BWE
.
InitialRtt
"
static_cast
<
int
>
(
rtt
)
0
2000
50
)
;
RTC_HISTOGRAM_COUNTS
(
"
WebRTC
.
BWE
.
InitialBandwidthEstimate
"
bitrate_at_2_seconds_kbps_
0
2000
50
)
;
}
else
if
(
uma_update_state_
=
=
kFirstDone
&
&
now_ms
-
first_report_time_ms_
>
=
kBweConverganceTimeMs
)
{
uma_update_state_
=
kDone
;
int
bitrate_diff_kbps
=
std
:
:
max
(
bitrate_at_2_seconds_kbps_
-
bitrate_kbps
0
)
;
RTC_HISTOGRAM_COUNTS
(
"
WebRTC
.
BWE
.
InitialVsConvergedDiff
"
bitrate_diff_kbps
0
2000
50
)
;
}
}
void
SendSideBandwidthEstimation
:
:
UpdateEstimate
(
int64_t
now_ms
)
{
if
(
last_fraction_loss_
=
=
0
&
&
IsInStartPhase
(
now_ms
)
&
&
bwe_incoming_
>
bitrate_
)
{
bitrate_
=
CapBitrateToThresholds
(
bwe_incoming_
)
;
min_bitrate_history_
.
clear
(
)
;
min_bitrate_history_
.
push_back
(
std
:
:
make_pair
(
now_ms
bitrate_
)
)
;
return
;
}
UpdateMinHistory
(
now_ms
)
;
if
(
time_last_receiver_block_ms_
!
=
0
)
{
if
(
last_fraction_loss_
<
=
5
)
{
bitrate_
=
static_cast
<
uint32_t
>
(
min_bitrate_history_
.
front
(
)
.
second
*
1
.
08
+
0
.
5
)
;
bitrate_
+
=
1000
;
}
else
if
(
last_fraction_loss_
<
=
26
)
{
}
else
{
if
(
(
now_ms
-
time_last_decrease_ms_
)
>
=
(
kBweDecreaseIntervalMs
+
last_round_trip_time_ms_
)
)
{
time_last_decrease_ms_
=
now_ms
;
bitrate_
=
static_cast
<
uint32_t
>
(
(
bitrate_
*
static_cast
<
double
>
(
512
-
last_fraction_loss_
)
)
/
512
.
0
)
;
bitrate_
=
std
:
:
max
(
bitrate_
CalcTfrcBps
(
last_round_trip_time_ms_
last_fraction_loss_
)
)
;
}
}
}
bitrate_
=
CapBitrateToThresholds
(
bitrate_
)
;
}
bool
SendSideBandwidthEstimation
:
:
IsInStartPhase
(
int64_t
now_ms
)
const
{
return
first_report_time_ms_
=
=
-
1
|
|
now_ms
-
first_report_time_ms_
<
kStartPhaseMs
;
}
void
SendSideBandwidthEstimation
:
:
UpdateMinHistory
(
int64_t
now_ms
)
{
while
(
!
min_bitrate_history_
.
empty
(
)
&
&
now_ms
-
min_bitrate_history_
.
front
(
)
.
first
+
1
>
kBweIncreaseIntervalMs
)
{
min_bitrate_history_
.
pop_front
(
)
;
}
while
(
!
min_bitrate_history_
.
empty
(
)
&
&
bitrate_
<
=
min_bitrate_history_
.
back
(
)
.
second
)
{
min_bitrate_history_
.
pop_back
(
)
;
}
min_bitrate_history_
.
push_back
(
std
:
:
make_pair
(
now_ms
bitrate_
)
)
;
}
uint32_t
SendSideBandwidthEstimation
:
:
CapBitrateToThresholds
(
uint32_t
bitrate
)
{
if
(
bwe_incoming_
>
0
&
&
bitrate
>
bwe_incoming_
)
{
bitrate
=
bwe_incoming_
;
}
if
(
bitrate
>
max_bitrate_configured_
)
{
bitrate
=
max_bitrate_configured_
;
}
if
(
bitrate
<
min_bitrate_configured_
)
{
LOG
(
LS_WARNING
)
<
<
"
Estimated
available
bandwidth
"
<
<
bitrate
/
1000
<
<
"
kbps
is
below
configured
min
bitrate
"
<
<
min_bitrate_configured_
/
1000
<
<
"
kbps
.
"
;
bitrate
=
min_bitrate_configured_
;
}
return
bitrate
;
}
}
