#
include
"
webrtc
/
modules
/
pacing
/
packet_router
.
h
"
#
include
"
webrtc
/
base
/
atomicops
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
rtp_rtcp
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
transport_feedback
.
h
"
namespace
webrtc
{
PacketRouter
:
:
PacketRouter
(
)
:
transport_seq_
(
0
)
{
pacer_thread_checker_
.
DetachFromThread
(
)
;
}
PacketRouter
:
:
~
PacketRouter
(
)
{
RTC_DCHECK
(
rtp_modules_
.
empty
(
)
)
;
}
void
PacketRouter
:
:
AddRtpModule
(
RtpRtcp
*
rtp_module
)
{
rtc
:
:
CritScope
cs
(
&
modules_crit_
)
;
RTC_DCHECK
(
std
:
:
find
(
rtp_modules_
.
begin
(
)
rtp_modules_
.
end
(
)
rtp_module
)
=
=
rtp_modules_
.
end
(
)
)
;
rtp_modules_
.
push_back
(
rtp_module
)
;
}
void
PacketRouter
:
:
RemoveRtpModule
(
RtpRtcp
*
rtp_module
)
{
rtc
:
:
CritScope
cs
(
&
modules_crit_
)
;
RTC_DCHECK
(
std
:
:
find
(
rtp_modules_
.
begin
(
)
rtp_modules_
.
end
(
)
rtp_module
)
!
=
rtp_modules_
.
end
(
)
)
;
rtp_modules_
.
remove
(
rtp_module
)
;
}
bool
PacketRouter
:
:
TimeToSendPacket
(
uint32_t
ssrc
uint16_t
sequence_number
int64_t
capture_timestamp
bool
retransmission
int
probe_cluster_id
)
{
RTC_DCHECK
(
pacer_thread_checker_
.
CalledOnValidThread
(
)
)
;
rtc
:
:
CritScope
cs
(
&
modules_crit_
)
;
for
(
auto
*
rtp_module
:
rtp_modules_
)
{
if
(
!
rtp_module
-
>
SendingMedia
(
)
)
continue
;
if
(
ssrc
=
=
rtp_module
-
>
SSRC
(
)
|
|
ssrc
=
=
rtp_module
-
>
FlexfecSsrc
(
)
)
{
return
rtp_module
-
>
TimeToSendPacket
(
ssrc
sequence_number
capture_timestamp
retransmission
probe_cluster_id
)
;
}
}
return
true
;
}
size_t
PacketRouter
:
:
TimeToSendPadding
(
size_t
bytes_to_send
int
probe_cluster_id
)
{
RTC_DCHECK
(
pacer_thread_checker_
.
CalledOnValidThread
(
)
)
;
size_t
total_bytes_sent
=
0
;
rtc
:
:
CritScope
cs
(
&
modules_crit_
)
;
for
(
RtpRtcp
*
module
:
rtp_modules_
)
{
if
(
module
-
>
SendingMedia
(
)
)
{
size_t
bytes_sent
=
module
-
>
TimeToSendPadding
(
bytes_to_send
-
total_bytes_sent
probe_cluster_id
)
;
total_bytes_sent
+
=
bytes_sent
;
if
(
total_bytes_sent
>
=
bytes_to_send
)
break
;
}
}
return
total_bytes_sent
;
}
void
PacketRouter
:
:
SetTransportWideSequenceNumber
(
uint16_t
sequence_number
)
{
rtc
:
:
AtomicOps
:
:
ReleaseStore
(
&
transport_seq_
sequence_number
)
;
}
uint16_t
PacketRouter
:
:
AllocateSequenceNumber
(
)
{
int
prev_seq
=
rtc
:
:
AtomicOps
:
:
AcquireLoad
(
&
transport_seq_
)
;
int
desired_prev_seq
;
int
new_seq
;
do
{
desired_prev_seq
=
prev_seq
;
new_seq
=
(
desired_prev_seq
+
1
)
&
0xFFFF
;
prev_seq
=
rtc
:
:
AtomicOps
:
:
CompareAndSwap
(
&
transport_seq_
desired_prev_seq
new_seq
)
;
}
while
(
prev_seq
!
=
desired_prev_seq
)
;
return
new_seq
;
}
bool
PacketRouter
:
:
SendFeedback
(
rtcp
:
:
TransportFeedback
*
packet
)
{
rtc
:
:
CritScope
cs
(
&
modules_crit_
)
;
for
(
auto
*
rtp_module
:
rtp_modules_
)
{
packet
-
>
SetSenderSsrc
(
rtp_module
-
>
SSRC
(
)
)
;
if
(
rtp_module
-
>
SendFeedbackPacket
(
*
packet
)
)
return
true
;
}
return
false
;
}
}
