#
include
"
modules
/
audio_mixer
/
frame_combiner
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
functional
>
#
include
<
memory
>
#
include
"
api
/
array_view
.
h
"
#
include
"
audio
/
utility
/
audio_frame_operations
.
h
"
#
include
"
modules
/
audio_mixer
/
audio_frame_manipulator
.
h
"
#
include
"
modules
/
audio_mixer
/
audio_mixer_impl
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
webrtc
{
namespace
{
constexpr
int
kMaximalFrameSize
=
2
*
48
*
10
;
void
CombineZeroFrames
(
bool
use_limiter
AudioProcessing
*
limiter
AudioFrame
*
audio_frame_for_mixing
)
{
audio_frame_for_mixing
-
>
elapsed_time_ms_
=
-
1
;
AudioFrameOperations
:
:
Mute
(
audio_frame_for_mixing
)
;
if
(
use_limiter
)
{
RTC_DCHECK
(
limiter
)
;
limiter
-
>
ProcessStream
(
audio_frame_for_mixing
)
;
}
}
void
CombineOneFrame
(
const
AudioFrame
*
input_frame
bool
use_limiter
AudioProcessing
*
limiter
AudioFrame
*
audio_frame_for_mixing
)
{
audio_frame_for_mixing
-
>
timestamp_
=
input_frame
-
>
timestamp_
;
audio_frame_for_mixing
-
>
elapsed_time_ms_
=
input_frame
-
>
elapsed_time_ms_
;
std
:
:
copy
(
input_frame
-
>
data
(
)
input_frame
-
>
data
(
)
+
input_frame
-
>
num_channels_
*
input_frame
-
>
samples_per_channel_
audio_frame_for_mixing
-
>
mutable_data
(
)
)
;
if
(
use_limiter
)
{
AudioFrameOperations
:
:
ApplyHalfGain
(
audio_frame_for_mixing
)
;
RTC_DCHECK
(
limiter
)
;
limiter
-
>
ProcessStream
(
audio_frame_for_mixing
)
;
AudioFrameOperations
:
:
Add
(
*
audio_frame_for_mixing
audio_frame_for_mixing
)
;
}
}
void
CombineMultipleFrames
(
const
std
:
:
vector
<
rtc
:
:
ArrayView
<
const
int16_t
>
>
&
input_frames
bool
use_limiter
AudioProcessing
*
limiter
AudioFrame
*
audio_frame_for_mixing
)
{
RTC_DCHECK
(
!
input_frames
.
empty
(
)
)
;
RTC_DCHECK
(
audio_frame_for_mixing
)
;
const
size_t
frame_length
=
input_frames
.
front
(
)
.
size
(
)
;
for
(
const
auto
&
frame
:
input_frames
)
{
RTC_DCHECK_EQ
(
frame_length
frame
.
size
(
)
)
;
}
RTC_DCHECK_GE
(
kMaximalFrameSize
frame_length
)
;
std
:
:
array
<
int32_t
kMaximalFrameSize
>
add_buffer
;
add_buffer
.
fill
(
0
)
;
for
(
const
auto
&
frame
:
input_frames
)
{
std
:
:
transform
(
frame
.
begin
(
)
frame
.
end
(
)
add_buffer
.
begin
(
)
add_buffer
.
begin
(
)
std
:
:
plus
<
int32_t
>
(
)
)
;
}
if
(
use_limiter
)
{
std
:
:
transform
(
add_buffer
.
begin
(
)
add_buffer
.
begin
(
)
+
frame_length
audio_frame_for_mixing
-
>
mutable_data
(
)
[
]
(
int32_t
a
)
{
return
rtc
:
:
saturated_cast
<
int16_t
>
(
a
/
2
)
;
}
)
;
RTC_DCHECK
(
limiter
)
;
const
int
error
=
limiter
-
>
ProcessStream
(
audio_frame_for_mixing
)
;
if
(
error
!
=
limiter
-
>
kNoError
)
{
RTC_LOG_F
(
LS_ERROR
)
<
<
"
Error
from
AudioProcessing
:
"
<
<
error
;
RTC_NOTREACHED
(
)
;
}
AudioFrameOperations
:
:
Add
(
*
audio_frame_for_mixing
audio_frame_for_mixing
)
;
}
else
{
std
:
:
transform
(
add_buffer
.
begin
(
)
add_buffer
.
begin
(
)
+
frame_length
audio_frame_for_mixing
-
>
mutable_data
(
)
[
]
(
int32_t
a
)
{
return
rtc
:
:
saturated_cast
<
int16_t
>
(
a
)
;
}
)
;
}
}
std
:
:
unique_ptr
<
AudioProcessing
>
CreateLimiter
(
)
{
Config
config
;
config
.
Set
<
ExperimentalAgc
>
(
new
ExperimentalAgc
(
false
)
)
;
std
:
:
unique_ptr
<
AudioProcessing
>
limiter
(
AudioProcessing
:
:
Create
(
config
)
)
;
RTC_DCHECK
(
limiter
)
;
webrtc
:
:
AudioProcessing
:
:
Config
apm_config
;
apm_config
.
residual_echo_detector
.
enabled
=
false
;
limiter
-
>
ApplyConfig
(
apm_config
)
;
const
auto
check_no_error
=
[
]
(
int
x
)
{
RTC_DCHECK_EQ
(
x
AudioProcessing
:
:
kNoError
)
;
}
;
auto
*
const
gain_control
=
limiter
-
>
gain_control
(
)
;
check_no_error
(
gain_control
-
>
set_mode
(
GainControl
:
:
kFixedDigital
)
)
;
check_no_error
(
gain_control
-
>
set_target_level_dbfs
(
7
)
)
;
check_no_error
(
gain_control
-
>
set_compression_gain_db
(
0
)
)
;
check_no_error
(
gain_control
-
>
enable_limiter
(
true
)
)
;
check_no_error
(
gain_control
-
>
Enable
(
true
)
)
;
return
limiter
;
}
}
FrameCombiner
:
:
FrameCombiner
(
bool
use_apm_limiter
)
:
use_apm_limiter_
(
use_apm_limiter
)
limiter_
(
use_apm_limiter
?
CreateLimiter
(
)
:
nullptr
)
{
}
FrameCombiner
:
:
~
FrameCombiner
(
)
=
default
;
void
FrameCombiner
:
:
Combine
(
const
std
:
:
vector
<
AudioFrame
*
>
&
mix_list
size_t
number_of_channels
int
sample_rate
size_t
number_of_streams
AudioFrame
*
audio_frame_for_mixing
)
const
{
RTC_DCHECK
(
audio_frame_for_mixing
)
;
const
size_t
samples_per_channel
=
static_cast
<
size_t
>
(
(
sample_rate
*
webrtc
:
:
AudioMixerImpl
:
:
kFrameDurationInMs
)
/
1000
)
;
for
(
const
auto
*
frame
:
mix_list
)
{
RTC_DCHECK_EQ
(
samples_per_channel
frame
-
>
samples_per_channel_
)
;
RTC_DCHECK_EQ
(
sample_rate
frame
-
>
sample_rate_hz_
)
;
}
for
(
auto
*
frame
:
mix_list
)
{
RemixFrame
(
number_of_channels
frame
)
;
}
audio_frame_for_mixing
-
>
UpdateFrame
(
0
nullptr
samples_per_channel
sample_rate
AudioFrame
:
:
kUndefined
AudioFrame
:
:
kVadUnknown
number_of_channels
)
;
const
bool
use_limiter_this_round
=
use_apm_limiter_
&
&
number_of_streams
>
1
;
if
(
mix_list
.
empty
(
)
)
{
CombineZeroFrames
(
use_limiter_this_round
limiter_
.
get
(
)
audio_frame_for_mixing
)
;
}
else
if
(
mix_list
.
size
(
)
=
=
1
)
{
CombineOneFrame
(
mix_list
.
front
(
)
use_limiter_this_round
limiter_
.
get
(
)
audio_frame_for_mixing
)
;
}
else
{
std
:
:
vector
<
rtc
:
:
ArrayView
<
const
int16_t
>
>
input_frames
;
for
(
size_t
i
=
0
;
i
<
mix_list
.
size
(
)
;
+
+
i
)
{
input_frames
.
push_back
(
rtc
:
:
ArrayView
<
const
int16_t
>
(
mix_list
[
i
]
-
>
data
(
)
samples_per_channel
*
number_of_channels
)
)
;
}
CombineMultipleFrames
(
input_frames
use_limiter_this_round
limiter_
.
get
(
)
audio_frame_for_mixing
)
;
}
}
}
