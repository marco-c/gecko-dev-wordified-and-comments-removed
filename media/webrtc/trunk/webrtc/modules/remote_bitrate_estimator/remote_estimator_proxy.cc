#
include
"
modules
/
remote_bitrate_estimator
/
remote_estimator_proxy
.
h
"
#
include
<
limits
>
#
include
<
algorithm
>
#
include
"
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
transport_feedback
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_minmax
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
const
int
RemoteEstimatorProxy
:
:
kBackWindowMs
=
500
;
const
int
RemoteEstimatorProxy
:
:
kMinSendIntervalMs
=
50
;
const
int
RemoteEstimatorProxy
:
:
kMaxSendIntervalMs
=
250
;
const
int
RemoteEstimatorProxy
:
:
kDefaultSendIntervalMs
=
100
;
static
constexpr
int64_t
kMaxTimeMs
=
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
/
1000
;
RemoteEstimatorProxy
:
:
RemoteEstimatorProxy
(
const
Clock
*
clock
TransportFeedbackSenderInterface
*
feedback_sender
)
:
clock_
(
clock
)
feedback_sender_
(
feedback_sender
)
last_process_time_ms_
(
-
1
)
media_ssrc_
(
0
)
feedback_sequence_
(
0
)
window_start_seq_
(
-
1
)
send_interval_ms_
(
kDefaultSendIntervalMs
)
{
}
RemoteEstimatorProxy
:
:
~
RemoteEstimatorProxy
(
)
{
}
void
RemoteEstimatorProxy
:
:
IncomingPacket
(
int64_t
arrival_time_ms
size_t
payload_size
const
RTPHeader
&
header
)
{
if
(
!
header
.
extension
.
hasTransportSequenceNumber
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
RemoteEstimatorProxy
:
Incoming
packet
"
"
is
missing
the
transport
sequence
number
extension
!
"
;
return
;
}
rtc
:
:
CritScope
cs
(
&
lock_
)
;
media_ssrc_
=
header
.
ssrc
;
OnPacketArrival
(
header
.
extension
.
transportSequenceNumber
arrival_time_ms
)
;
}
bool
RemoteEstimatorProxy
:
:
LatestEstimate
(
std
:
:
vector
<
unsigned
int
>
*
ssrcs
unsigned
int
*
bitrate_bps
)
const
{
return
false
;
}
int64_t
RemoteEstimatorProxy
:
:
TimeUntilNextProcess
(
)
{
int64_t
time_until_next
=
0
;
if
(
last_process_time_ms_
!
=
-
1
)
{
rtc
:
:
CritScope
cs
(
&
lock_
)
;
int64_t
now
=
clock_
-
>
TimeInMilliseconds
(
)
;
if
(
now
-
last_process_time_ms_
<
send_interval_ms_
)
time_until_next
=
(
last_process_time_ms_
+
send_interval_ms_
-
now
)
;
}
return
time_until_next
;
}
void
RemoteEstimatorProxy
:
:
Process
(
)
{
last_process_time_ms_
=
clock_
-
>
TimeInMilliseconds
(
)
;
bool
more_to_build
=
true
;
while
(
more_to_build
)
{
rtcp
:
:
TransportFeedback
feedback_packet
;
if
(
BuildFeedbackPacket
(
&
feedback_packet
)
)
{
RTC_DCHECK
(
feedback_sender_
!
=
nullptr
)
;
feedback_sender_
-
>
SendTransportFeedback
(
&
feedback_packet
)
;
}
else
{
more_to_build
=
false
;
}
}
}
void
RemoteEstimatorProxy
:
:
OnBitrateChanged
(
int
bitrate_bps
)
{
constexpr
int
kTwccReportSize
=
20
+
8
+
10
+
30
;
constexpr
double
kMinTwccRate
=
kTwccReportSize
*
8
.
0
*
1000
.
0
/
kMaxSendIntervalMs
;
constexpr
double
kMaxTwccRate
=
kTwccReportSize
*
8
.
0
*
1000
.
0
/
kMinSendIntervalMs
;
rtc
:
:
CritScope
cs
(
&
lock_
)
;
send_interval_ms_
=
static_cast
<
int
>
(
0
.
5
+
kTwccReportSize
*
8
.
0
*
1000
.
0
/
rtc
:
:
SafeClamp
(
0
.
05
*
bitrate_bps
kMinTwccRate
kMaxTwccRate
)
)
;
}
void
RemoteEstimatorProxy
:
:
OnPacketArrival
(
uint16_t
sequence_number
int64_t
arrival_time
)
{
if
(
arrival_time
<
0
|
|
arrival_time
>
kMaxTimeMs
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Arrival
time
out
of
bounds
:
"
<
<
arrival_time
;
return
;
}
int64_t
seq
=
unwrapper_
.
Unwrap
(
sequence_number
)
;
if
(
seq
>
window_start_seq_
+
0xFFFF
/
2
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Skipping
this
sequence
number
(
"
<
<
sequence_number
<
<
"
)
since
it
likely
is
reordered
but
the
unwrapper
"
"
failed
to
handle
it
.
Feedback
window
starts
at
"
<
<
window_start_seq_
<
<
"
.
"
;
return
;
}
if
(
packet_arrival_times_
.
lower_bound
(
window_start_seq_
)
=
=
packet_arrival_times_
.
end
(
)
)
{
for
(
auto
it
=
packet_arrival_times_
.
begin
(
)
;
it
!
=
packet_arrival_times_
.
end
(
)
&
&
it
-
>
first
<
seq
&
&
arrival_time
-
it
-
>
second
>
=
kBackWindowMs
;
)
{
auto
delete_it
=
it
;
+
+
it
;
packet_arrival_times_
.
erase
(
delete_it
)
;
}
}
if
(
window_start_seq_
=
=
-
1
)
{
window_start_seq_
=
sequence_number
;
}
else
if
(
seq
<
window_start_seq_
)
{
window_start_seq_
=
seq
;
}
if
(
packet_arrival_times_
.
find
(
seq
)
!
=
packet_arrival_times_
.
end
(
)
)
return
;
packet_arrival_times_
[
seq
]
=
arrival_time
;
}
bool
RemoteEstimatorProxy
:
:
BuildFeedbackPacket
(
rtcp
:
:
TransportFeedback
*
feedback_packet
)
{
rtc
:
:
CritScope
cs
(
&
lock_
)
;
auto
it
=
packet_arrival_times_
.
lower_bound
(
window_start_seq_
)
;
if
(
it
=
=
packet_arrival_times_
.
end
(
)
)
{
return
false
;
}
const
int64_t
first_sequence
=
it
-
>
first
;
feedback_packet
-
>
SetMediaSsrc
(
media_ssrc_
)
;
feedback_packet
-
>
SetBase
(
static_cast
<
uint16_t
>
(
window_start_seq_
&
0xFFFF
)
it
-
>
second
*
1000
)
;
feedback_packet
-
>
SetFeedbackSequenceNumber
(
feedback_sequence_
+
+
)
;
for
(
;
it
!
=
packet_arrival_times_
.
end
(
)
;
+
+
it
)
{
if
(
!
feedback_packet
-
>
AddReceivedPacket
(
static_cast
<
uint16_t
>
(
it
-
>
first
&
0xFFFF
)
it
-
>
second
*
1000
)
)
{
RTC_CHECK_NE
(
first_sequence
it
-
>
first
)
;
break
;
}
window_start_seq_
=
it
-
>
first
+
1
;
}
return
true
;
}
}
