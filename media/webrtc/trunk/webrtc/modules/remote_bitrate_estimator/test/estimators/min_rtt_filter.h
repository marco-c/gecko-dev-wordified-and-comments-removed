#
ifndef
MODULES_REMOTE_BITRATE_ESTIMATOR_TEST_ESTIMATORS_MIN_RTT_FILTER_H_
#
define
MODULES_REMOTE_BITRATE_ESTIMATOR_TEST_ESTIMATORS_MIN_RTT_FILTER_H_
#
include
<
cstdint
>
#
include
<
limits
>
#
include
<
list
>
#
include
"
api
/
optional
.
h
"
namespace
webrtc
{
namespace
testing
{
namespace
bwe
{
const
float
kRttIncreaseThresholdForExpiry
=
2
.
3f
;
const
size_t
kRttFilterSize
=
25
;
class
MinRttFilter
{
public
:
MinRttFilter
(
)
{
}
~
MinRttFilter
(
)
{
}
rtc
:
:
Optional
<
int64_t
>
min_rtt_ms
(
)
{
return
min_rtt_ms_
;
}
void
AddRttSample
(
int64_t
rtt_ms
int64_t
now_ms
)
{
if
(
!
min_rtt_ms_
|
|
rtt_ms
<
=
*
min_rtt_ms_
|
|
MinRttExpired
(
now_ms
)
)
{
min_rtt_ms_
.
emplace
(
rtt_ms
)
;
}
rtt_samples_
.
push_back
(
rtt_ms
)
;
if
(
rtt_samples_
.
size
(
)
>
kRttFilterSize
)
rtt_samples_
.
pop_front
(
)
;
}
bool
MinRttExpired
(
int64_t
now_ms
)
{
if
(
rtt_samples_
.
size
(
)
<
kRttFilterSize
|
|
!
min_rtt_ms_
)
return
false
;
int64_t
sum_of_rtts_ms
=
0
;
for
(
int64_t
i
:
rtt_samples_
)
sum_of_rtts_ms
+
=
i
;
if
(
sum_of_rtts_ms
>
=
*
min_rtt_ms_
*
kRttIncreaseThresholdForExpiry
*
kRttFilterSize
)
{
rtt_samples_
.
clear
(
)
;
return
true
;
}
return
false
;
}
private
:
rtc
:
:
Optional
<
int64_t
>
min_rtt_ms_
;
std
:
:
list
<
int64_t
>
rtt_samples_
;
}
;
}
}
}
#
endif
