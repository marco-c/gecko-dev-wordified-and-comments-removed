#
include
"
webrtc
/
modules
/
remote_bitrate_estimator
/
remote_bitrate_estimator_single_stream
.
h
"
#
include
<
utility
>
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
thread_annotations
.
h
"
#
include
"
webrtc
/
modules
/
remote_bitrate_estimator
/
aimd_rate_control
.
h
"
#
include
"
webrtc
/
modules
/
remote_bitrate_estimator
/
inter_arrival
.
h
"
#
include
"
webrtc
/
modules
/
remote_bitrate_estimator
/
overuse_detector
.
h
"
#
include
"
webrtc
/
modules
/
remote_bitrate_estimator
/
overuse_estimator
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
clock
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
critical_section_wrapper
.
h
"
#
include
"
webrtc
/
typedefs
.
h
"
namespace
webrtc
{
enum
{
kTimestampGroupLengthMs
=
5
}
;
static
const
double
kTimestampToMs
=
1
.
0
/
90
.
0
;
struct
RemoteBitrateEstimatorSingleStream
:
:
Detector
{
explicit
Detector
(
int64_t
last_packet_time_ms
const
OverUseDetectorOptions
&
options
bool
enable_burst_grouping
)
:
last_packet_time_ms
(
last_packet_time_ms
)
inter_arrival
(
90
*
kTimestampGroupLengthMs
kTimestampToMs
enable_burst_grouping
)
estimator
(
options
)
detector
(
options
)
{
}
int64_t
last_packet_time_ms
;
InterArrival
inter_arrival
;
OveruseEstimator
estimator
;
OveruseDetector
detector
;
}
;
RemoteBitrateEstimatorSingleStream
:
:
RemoteBitrateEstimatorSingleStream
(
RemoteBitrateObserver
*
observer
Clock
*
clock
)
:
clock_
(
clock
)
incoming_bitrate_
(
kBitrateWindowMs
8000
)
remote_rate_
(
new
AimdRateControl
(
)
)
observer_
(
observer
)
crit_sect_
(
CriticalSectionWrapper
:
:
CreateCriticalSection
(
)
)
last_process_time_
(
-
1
)
process_interval_ms_
(
kProcessIntervalMs
)
{
assert
(
observer_
)
;
LOG
(
LS_INFO
)
<
<
"
RemoteBitrateEstimatorSingleStream
:
Instantiating
.
"
;
}
RemoteBitrateEstimatorSingleStream
:
:
~
RemoteBitrateEstimatorSingleStream
(
)
{
while
(
!
overuse_detectors_
.
empty
(
)
)
{
SsrcOveruseEstimatorMap
:
:
iterator
it
=
overuse_detectors_
.
begin
(
)
;
delete
it
-
>
second
;
overuse_detectors_
.
erase
(
it
)
;
}
}
void
RemoteBitrateEstimatorSingleStream
:
:
IncomingPacket
(
int64_t
arrival_time_ms
size_t
payload_size
const
RTPHeader
&
header
bool
was_paced
)
{
uint32_t
ssrc
=
header
.
ssrc
;
uint32_t
rtp_timestamp
=
header
.
timestamp
+
header
.
extension
.
transmissionTimeOffset
;
int64_t
now_ms
=
clock_
-
>
TimeInMilliseconds
(
)
;
CriticalSectionScoped
cs
(
crit_sect_
.
get
(
)
)
;
SsrcOveruseEstimatorMap
:
:
iterator
it
=
overuse_detectors_
.
find
(
ssrc
)
;
if
(
it
=
=
overuse_detectors_
.
end
(
)
)
{
std
:
:
pair
<
SsrcOveruseEstimatorMap
:
:
iterator
bool
>
insert_result
=
overuse_detectors_
.
insert
(
std
:
:
make_pair
(
ssrc
new
Detector
(
now_ms
OverUseDetectorOptions
(
)
true
)
)
)
;
it
=
insert_result
.
first
;
}
Detector
*
estimator
=
it
-
>
second
;
estimator
-
>
last_packet_time_ms
=
now_ms
;
incoming_bitrate_
.
Update
(
payload_size
now_ms
)
;
const
BandwidthUsage
prior_state
=
estimator
-
>
detector
.
State
(
)
;
uint32_t
timestamp_delta
=
0
;
int64_t
time_delta
=
0
;
int
size_delta
=
0
;
if
(
estimator
-
>
inter_arrival
.
ComputeDeltas
(
rtp_timestamp
arrival_time_ms
payload_size
&
timestamp_delta
&
time_delta
&
size_delta
)
)
{
double
timestamp_delta_ms
=
timestamp_delta
*
kTimestampToMs
;
estimator
-
>
estimator
.
Update
(
time_delta
timestamp_delta_ms
size_delta
estimator
-
>
detector
.
State
(
)
)
;
estimator
-
>
detector
.
Detect
(
estimator
-
>
estimator
.
offset
(
)
timestamp_delta_ms
estimator
-
>
estimator
.
num_of_deltas
(
)
now_ms
)
;
}
if
(
estimator
-
>
detector
.
State
(
)
=
=
kBwOverusing
)
{
uint32_t
incoming_bitrate_bps
=
incoming_bitrate_
.
Rate
(
now_ms
)
;
if
(
prior_state
!
=
kBwOverusing
|
|
remote_rate_
-
>
TimeToReduceFurther
(
now_ms
incoming_bitrate_bps
)
)
{
UpdateEstimate
(
now_ms
)
;
}
}
}
int32_t
RemoteBitrateEstimatorSingleStream
:
:
Process
(
)
{
if
(
TimeUntilNextProcess
(
)
>
0
)
{
return
0
;
}
{
CriticalSectionScoped
cs
(
crit_sect_
.
get
(
)
)
;
UpdateEstimate
(
clock_
-
>
TimeInMilliseconds
(
)
)
;
}
last_process_time_
=
clock_
-
>
TimeInMilliseconds
(
)
;
return
0
;
}
int64_t
RemoteBitrateEstimatorSingleStream
:
:
TimeUntilNextProcess
(
)
{
if
(
last_process_time_
<
0
)
{
return
0
;
}
{
CriticalSectionScoped
cs_
(
crit_sect_
.
get
(
)
)
;
return
last_process_time_
+
process_interval_ms_
-
clock_
-
>
TimeInMilliseconds
(
)
;
}
}
void
RemoteBitrateEstimatorSingleStream
:
:
UpdateEstimate
(
int64_t
now_ms
)
{
BandwidthUsage
bw_state
=
kBwNormal
;
double
sum_var_noise
=
0
.
0
;
SsrcOveruseEstimatorMap
:
:
iterator
it
=
overuse_detectors_
.
begin
(
)
;
while
(
it
!
=
overuse_detectors_
.
end
(
)
)
{
const
int64_t
time_of_last_received_packet
=
it
-
>
second
-
>
last_packet_time_ms
;
if
(
time_of_last_received_packet
>
=
0
&
&
now_ms
-
time_of_last_received_packet
>
kStreamTimeOutMs
)
{
delete
it
-
>
second
;
overuse_detectors_
.
erase
(
it
+
+
)
;
}
else
{
sum_var_noise
+
=
it
-
>
second
-
>
estimator
.
var_noise
(
)
;
if
(
it
-
>
second
-
>
detector
.
State
(
)
>
bw_state
)
{
bw_state
=
it
-
>
second
-
>
detector
.
State
(
)
;
}
+
+
it
;
}
}
if
(
overuse_detectors_
.
empty
(
)
)
{
remote_rate_
.
reset
(
new
AimdRateControl
(
)
)
;
return
;
}
double
mean_noise_var
=
sum_var_noise
/
static_cast
<
double
>
(
overuse_detectors_
.
size
(
)
)
;
const
RateControlInput
input
(
bw_state
incoming_bitrate_
.
Rate
(
now_ms
)
mean_noise_var
)
;
remote_rate_
-
>
Update
(
&
input
now_ms
)
;
unsigned
int
target_bitrate
=
remote_rate_
-
>
UpdateBandwidthEstimate
(
now_ms
)
;
if
(
remote_rate_
-
>
ValidEstimate
(
)
)
{
process_interval_ms_
=
remote_rate_
-
>
GetFeedbackInterval
(
)
;
std
:
:
vector
<
unsigned
int
>
ssrcs
;
GetSsrcs
(
&
ssrcs
)
;
observer_
-
>
OnReceiveBitrateChanged
(
ssrcs
target_bitrate
)
;
}
}
void
RemoteBitrateEstimatorSingleStream
:
:
OnRttUpdate
(
int64_t
avg_rtt_ms
int64_t
max_rtt_ms
)
{
CriticalSectionScoped
cs
(
crit_sect_
.
get
(
)
)
;
remote_rate_
-
>
SetRtt
(
avg_rtt_ms
)
;
}
void
RemoteBitrateEstimatorSingleStream
:
:
RemoveStream
(
unsigned
int
ssrc
)
{
CriticalSectionScoped
cs
(
crit_sect_
.
get
(
)
)
;
SsrcOveruseEstimatorMap
:
:
iterator
it
=
overuse_detectors_
.
find
(
ssrc
)
;
if
(
it
!
=
overuse_detectors_
.
end
(
)
)
{
delete
it
-
>
second
;
overuse_detectors_
.
erase
(
it
)
;
}
}
bool
RemoteBitrateEstimatorSingleStream
:
:
LatestEstimate
(
std
:
:
vector
<
unsigned
int
>
*
ssrcs
unsigned
int
*
bitrate_bps
)
const
{
CriticalSectionScoped
cs
(
crit_sect_
.
get
(
)
)
;
assert
(
bitrate_bps
)
;
if
(
!
remote_rate_
-
>
ValidEstimate
(
)
)
{
return
false
;
}
GetSsrcs
(
ssrcs
)
;
if
(
ssrcs
-
>
empty
(
)
)
*
bitrate_bps
=
0
;
else
*
bitrate_bps
=
remote_rate_
-
>
LatestEstimate
(
)
;
return
true
;
}
bool
RemoteBitrateEstimatorSingleStream
:
:
GetStats
(
ReceiveBandwidthEstimatorStats
*
output
)
const
{
return
false
;
}
void
RemoteBitrateEstimatorSingleStream
:
:
GetSsrcs
(
std
:
:
vector
<
unsigned
int
>
*
ssrcs
)
const
{
assert
(
ssrcs
)
;
ssrcs
-
>
resize
(
overuse_detectors_
.
size
(
)
)
;
int
i
=
0
;
for
(
SsrcOveruseEstimatorMap
:
:
const_iterator
it
=
overuse_detectors_
.
begin
(
)
;
it
!
=
overuse_detectors_
.
end
(
)
;
+
+
it
+
+
i
)
{
(
*
ssrcs
)
[
i
]
=
it
-
>
first
;
}
}
void
RemoteBitrateEstimatorSingleStream
:
:
SetMinBitrate
(
int
min_bitrate_bps
)
{
CriticalSectionScoped
cs
(
crit_sect_
.
get
(
)
)
;
remote_rate_
-
>
SetMinBitrate
(
min_bitrate_bps
)
;
}
}
