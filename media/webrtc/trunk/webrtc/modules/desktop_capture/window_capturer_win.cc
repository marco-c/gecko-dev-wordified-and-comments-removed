#
include
<
assert
.
h
>
#
include
<
memory
>
#
include
"
modules
/
desktop_capture
/
desktop_capturer
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_frame_win
.
h
"
#
include
"
modules
/
desktop_capture
/
window_finder_win
.
h
"
#
include
"
modules
/
desktop_capture
/
win
/
screen_capture_utils
.
h
"
#
include
"
modules
/
desktop_capture
/
win
/
window_capture_utils
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
win32
.
h
"
namespace
webrtc
{
namespace
{
BOOL
CALLBACK
WindowsEnumerationHandler
(
HWND
hwnd
LPARAM
param
)
{
DesktopCapturer
:
:
SourceList
*
list
=
reinterpret_cast
<
DesktopCapturer
:
:
SourceList
*
>
(
param
)
;
int
len
=
GetWindowTextLength
(
hwnd
)
;
HWND
owner
=
GetWindow
(
hwnd
GW_OWNER
)
;
LONG
exstyle
=
GetWindowLong
(
hwnd
GWL_EXSTYLE
)
;
if
(
len
=
=
0
|
|
IsIconic
(
hwnd
)
|
|
!
IsWindowVisible
(
hwnd
)
|
|
(
owner
&
&
!
(
exstyle
&
WS_EX_APPWINDOW
)
)
)
{
return
TRUE
;
}
const
size_t
kClassLength
=
256
;
WCHAR
class_name
[
kClassLength
]
;
const
int
class_name_length
=
GetClassName
(
hwnd
class_name
kClassLength
)
;
RTC_DCHECK
(
class_name_length
)
<
<
"
Error
retrieving
the
application
'
s
class
name
"
;
if
(
wcscmp
(
class_name
L
"
Progman
"
)
=
=
0
|
|
wcscmp
(
class_name
L
"
Button
"
)
=
=
0
)
return
TRUE
;
if
(
rtc
:
:
IsWindows8OrLater
(
)
&
&
(
wcscmp
(
class_name
L
"
ApplicationFrameWindow
"
)
=
=
0
|
|
wcscmp
(
class_name
L
"
Windows
.
UI
.
Core
.
CoreWindow
"
)
=
=
0
)
)
{
return
TRUE
;
}
DesktopCapturer
:
:
Source
window
;
window
.
id
=
reinterpret_cast
<
WindowId
>
(
hwnd
)
;
const
size_t
kTitleLength
=
500
;
WCHAR
window_title
[
kTitleLength
]
;
GetWindowText
(
hwnd
window_title
kTitleLength
)
;
window
.
title
=
rtc
:
:
ToUtf8
(
window_title
)
;
if
(
window
.
title
.
empty
(
)
)
return
TRUE
;
list
-
>
push_back
(
window
)
;
return
TRUE
;
}
bool
GetWindowDrawableRect
(
HWND
window
DesktopRect
*
drawable_rect
DesktopRect
*
original_rect
)
{
if
(
!
GetWindowRect
(
window
original_rect
)
)
{
return
false
;
}
bool
is_maximized
=
false
;
if
(
!
IsWindowMaximized
(
window
&
is_maximized
)
)
{
return
false
;
}
if
(
is_maximized
)
{
return
GetCroppedWindowRect
(
window
drawable_rect
nullptr
)
;
}
*
drawable_rect
=
*
original_rect
;
return
true
;
}
class
WindowCapturerWin
:
public
DesktopCapturer
{
public
:
WindowCapturerWin
(
)
;
~
WindowCapturerWin
(
)
override
;
void
Start
(
Callback
*
callback
)
override
;
void
CaptureFrame
(
)
override
;
bool
GetSourceList
(
SourceList
*
sources
)
override
;
bool
SelectSource
(
SourceId
id
)
override
;
bool
FocusOnSelectedSource
(
)
override
;
bool
IsOccluded
(
const
DesktopVector
&
pos
)
override
;
private
:
Callback
*
callback_
=
nullptr
;
HWND
window_
=
nullptr
;
DesktopSize
previous_size_
;
AeroChecker
aero_checker_
;
std
:
:
map
<
HWND
DesktopSize
>
window_size_map_
;
WindowFinderWin
window_finder_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
WindowCapturerWin
)
;
}
;
WindowCapturerWin
:
:
WindowCapturerWin
(
)
{
}
WindowCapturerWin
:
:
~
WindowCapturerWin
(
)
{
}
bool
WindowCapturerWin
:
:
GetSourceList
(
SourceList
*
sources
)
{
SourceList
result
;
LPARAM
param
=
reinterpret_cast
<
LPARAM
>
(
&
result
)
;
if
(
!
EnumWindows
(
&
WindowsEnumerationHandler
param
)
)
return
false
;
sources
-
>
swap
(
result
)
;
std
:
:
map
<
HWND
DesktopSize
>
new_map
;
for
(
const
auto
&
item
:
*
sources
)
{
HWND
hwnd
=
reinterpret_cast
<
HWND
>
(
item
.
id
)
;
new_map
[
hwnd
]
=
window_size_map_
[
hwnd
]
;
}
window_size_map_
.
swap
(
new_map
)
;
return
true
;
}
bool
WindowCapturerWin
:
:
SelectSource
(
SourceId
id
)
{
assert
(
IsGUIThread
(
false
)
)
;
HWND
window
=
reinterpret_cast
<
HWND
>
(
id
)
;
if
(
!
IsWindow
(
window
)
|
|
!
IsWindowVisible
(
window
)
|
|
IsIconic
(
window
)
)
return
false
;
window_
=
window
;
previous_size_
=
window_size_map_
[
window
]
;
return
true
;
}
bool
WindowCapturerWin
:
:
FocusOnSelectedSource
(
)
{
assert
(
IsGUIThread
(
false
)
)
;
if
(
!
window_
)
return
false
;
if
(
!
IsWindow
(
window_
)
|
|
!
IsWindowVisible
(
window_
)
|
|
IsIconic
(
window_
)
)
return
false
;
return
BringWindowToTop
(
window_
)
!
=
FALSE
&
&
SetForegroundWindow
(
window_
)
!
=
FALSE
;
}
bool
WindowCapturerWin
:
:
IsOccluded
(
const
DesktopVector
&
pos
)
{
DesktopVector
sys_pos
=
pos
.
add
(
GetFullscreenRect
(
)
.
top_left
(
)
)
;
return
reinterpret_cast
<
HWND
>
(
window_finder_
.
GetWindowUnderPoint
(
sys_pos
)
)
!
=
window_
;
}
void
WindowCapturerWin
:
:
Start
(
Callback
*
callback
)
{
assert
(
!
callback_
)
;
assert
(
callback
)
;
callback_
=
callback
;
}
void
WindowCapturerWin
:
:
CaptureFrame
(
)
{
if
(
!
window_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Window
hasn
'
t
been
selected
:
"
<
<
GetLastError
(
)
;
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_PERMANENT
nullptr
)
;
return
;
}
if
(
!
IsWindow
(
window_
)
)
{
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_PERMANENT
nullptr
)
;
return
;
}
DesktopRect
cropped_rect
;
DesktopRect
original_rect
;
if
(
!
GetWindowDrawableRect
(
window_
&
cropped_rect
&
original_rect
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
get
drawable
window
area
:
"
<
<
GetLastError
(
)
;
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_TEMPORARY
nullptr
)
;
return
;
}
if
(
original_rect
.
is_empty
(
)
|
|
IsIconic
(
window_
)
|
|
!
IsWindowVisible
(
window_
)
)
{
std
:
:
unique_ptr
<
DesktopFrame
>
frame
(
new
BasicDesktopFrame
(
DesktopSize
(
1
1
)
)
)
;
memset
(
frame
-
>
data
(
)
0
frame
-
>
stride
(
)
*
frame
-
>
size
(
)
.
height
(
)
)
;
previous_size_
=
frame
-
>
size
(
)
;
window_size_map_
[
window_
]
=
previous_size_
;
callback_
-
>
OnCaptureResult
(
Result
:
:
SUCCESS
std
:
:
move
(
frame
)
)
;
return
;
}
HDC
window_dc
=
GetWindowDC
(
window_
)
;
if
(
!
window_dc
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
get
window
DC
:
"
<
<
GetLastError
(
)
;
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_TEMPORARY
nullptr
)
;
return
;
}
DesktopSize
window_dc_size
;
if
(
GetDcSize
(
window_dc
&
window_dc_size
)
)
{
const
double
vertical_scale
=
static_cast
<
double
>
(
window_dc_size
.
width
(
)
)
/
original_rect
.
width
(
)
;
const
double
horizontal_scale
=
static_cast
<
double
>
(
window_dc_size
.
height
(
)
)
/
original_rect
.
height
(
)
;
original_rect
.
Scale
(
vertical_scale
horizontal_scale
)
;
cropped_rect
.
Scale
(
vertical_scale
horizontal_scale
)
;
}
std
:
:
unique_ptr
<
DesktopFrameWin
>
frame
(
DesktopFrameWin
:
:
Create
(
cropped_rect
.
size
(
)
nullptr
window_dc
)
)
;
if
(
!
frame
.
get
(
)
)
{
ReleaseDC
(
window_
window_dc
)
;
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_TEMPORARY
nullptr
)
;
return
;
}
HDC
mem_dc
=
CreateCompatibleDC
(
window_dc
)
;
HGDIOBJ
previous_object
=
SelectObject
(
mem_dc
frame
-
>
bitmap
(
)
)
;
BOOL
result
=
FALSE
;
if
(
!
aero_checker_
.
IsAeroEnabled
(
)
|
|
!
previous_size_
.
equals
(
frame
-
>
size
(
)
)
)
{
result
=
PrintWindow
(
window_
mem_dc
0
)
;
}
if
(
!
result
)
{
result
=
BitBlt
(
mem_dc
0
0
frame
-
>
size
(
)
.
width
(
)
frame
-
>
size
(
)
.
height
(
)
window_dc
cropped_rect
.
left
(
)
-
original_rect
.
left
(
)
cropped_rect
.
top
(
)
-
original_rect
.
top
(
)
SRCCOPY
)
;
}
SelectObject
(
mem_dc
previous_object
)
;
DeleteDC
(
mem_dc
)
;
ReleaseDC
(
window_
window_dc
)
;
previous_size_
=
frame
-
>
size
(
)
;
window_size_map_
[
window_
]
=
previous_size_
;
frame
-
>
mutable_updated_region
(
)
-
>
SetRect
(
DesktopRect
:
:
MakeSize
(
frame
-
>
size
(
)
)
)
;
frame
-
>
set_top_left
(
cropped_rect
.
top_left
(
)
.
subtract
(
GetFullscreenRect
(
)
.
top_left
(
)
)
)
;
if
(
result
)
{
callback_
-
>
OnCaptureResult
(
Result
:
:
SUCCESS
std
:
:
move
(
frame
)
)
;
}
else
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Both
PrintWindow
(
)
and
BitBlt
(
)
failed
.
"
;
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_TEMPORARY
nullptr
)
;
}
}
}
std
:
:
unique_ptr
<
DesktopCapturer
>
DesktopCapturer
:
:
CreateRawWindowCapturer
(
const
DesktopCaptureOptions
&
options
)
{
return
std
:
:
unique_ptr
<
DesktopCapturer
>
(
new
WindowCapturerWin
(
)
)
;
}
}
