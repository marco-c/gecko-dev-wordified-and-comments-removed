#
include
<
string
.
h
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
utility
>
#
include
<
X11
/
extensions
/
Xdamage
.
h
>
#
include
<
X11
/
extensions
/
Xfixes
.
h
>
#
include
<
X11
/
Xlib
.
h
>
#
include
<
X11
/
Xutil
.
h
>
#
include
"
modules
/
desktop_capture
/
desktop_capture_options
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_capturer
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_frame
.
h
"
#
include
"
modules
/
desktop_capture
/
screen_capture_frame_queue
.
h
"
#
include
"
modules
/
desktop_capture
/
screen_capturer_helper
.
h
"
#
include
"
modules
/
desktop_capture
/
shared_desktop_frame
.
h
"
#
include
"
modules
/
desktop_capture
/
x11
/
x_server_pixel_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
namespace
webrtc
{
namespace
{
class
ScreenCapturerLinux
:
public
DesktopCapturer
public
SharedXDisplay
:
:
XEventHandler
{
public
:
ScreenCapturerLinux
(
)
;
~
ScreenCapturerLinux
(
)
override
;
bool
Init
(
const
DesktopCaptureOptions
&
options
)
;
void
Start
(
Callback
*
delegate
)
override
;
void
Stop
(
)
override
;
void
CaptureFrame
(
)
override
;
bool
GetSourceList
(
SourceList
*
sources
)
override
;
bool
SelectSource
(
SourceId
id
)
override
;
private
:
Display
*
display
(
)
{
return
options_
.
x_display
(
)
-
>
display
(
)
;
}
bool
HandleXEvent
(
const
XEvent
&
event
)
override
;
void
InitXDamage
(
)
;
std
:
:
unique_ptr
<
DesktopFrame
>
CaptureScreen
(
)
;
void
ScreenConfigurationChanged
(
)
;
void
SynchronizeFrame
(
)
;
void
DeinitXlib
(
)
;
DesktopCaptureOptions
options_
;
Callback
*
callback_
=
nullptr
;
GC
gc_
=
nullptr
;
Window
root_window_
=
BadValue
;
bool
has_xfixes_
=
false
;
int
xfixes_event_base_
=
-
1
;
int
xfixes_error_base_
=
-
1
;
bool
use_damage_
=
false
;
Damage
damage_handle_
=
0
;
int
damage_event_base_
=
-
1
;
int
damage_error_base_
=
-
1
;
XserverRegion
damage_region_
=
0
;
XServerPixelBuffer
x_server_pixel_buffer_
;
ScreenCapturerHelper
helper_
;
ScreenCaptureFrameQueue
<
SharedDesktopFrame
>
queue_
;
DesktopRegion
last_invalid_region_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
ScreenCapturerLinux
)
;
}
;
ScreenCapturerLinux
:
:
ScreenCapturerLinux
(
)
{
helper_
.
SetLogGridSize
(
4
)
;
}
ScreenCapturerLinux
:
:
~
ScreenCapturerLinux
(
)
{
options_
.
x_display
(
)
-
>
RemoveEventHandler
(
ConfigureNotify
this
)
;
if
(
use_damage_
)
{
options_
.
x_display
(
)
-
>
RemoveEventHandler
(
damage_event_base_
+
XDamageNotify
this
)
;
}
DeinitXlib
(
)
;
}
bool
ScreenCapturerLinux
:
:
Init
(
const
DesktopCaptureOptions
&
options
)
{
options_
=
options
;
root_window_
=
RootWindow
(
display
(
)
DefaultScreen
(
display
(
)
)
)
;
if
(
root_window_
=
=
BadValue
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Unable
to
get
the
root
window
"
;
DeinitXlib
(
)
;
return
false
;
}
gc_
=
XCreateGC
(
display
(
)
root_window_
0
NULL
)
;
if
(
gc_
=
=
NULL
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Unable
to
get
graphics
context
"
;
DeinitXlib
(
)
;
return
false
;
}
options_
.
x_display
(
)
-
>
AddEventHandler
(
ConfigureNotify
this
)
;
if
(
XFixesQueryExtension
(
display
(
)
&
xfixes_event_base_
&
xfixes_error_base_
)
)
{
has_xfixes_
=
true
;
}
else
{
RTC_LOG
(
LS_INFO
)
<
<
"
X
server
does
not
support
XFixes
.
"
;
}
XSelectInput
(
display
(
)
root_window_
StructureNotifyMask
)
;
if
(
!
x_server_pixel_buffer_
.
Init
(
display
(
)
DefaultRootWindow
(
display
(
)
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
initialize
pixel
buffer
.
"
;
return
false
;
}
if
(
options_
.
use_update_notifications
(
)
)
{
InitXDamage
(
)
;
}
return
true
;
}
void
ScreenCapturerLinux
:
:
InitXDamage
(
)
{
if
(
!
has_xfixes_
)
{
return
;
}
if
(
!
XDamageQueryExtension
(
display
(
)
&
damage_event_base_
&
damage_error_base_
)
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
X
server
does
not
support
XDamage
.
"
;
return
;
}
damage_handle_
=
XDamageCreate
(
display
(
)
root_window_
XDamageReportNonEmpty
)
;
if
(
!
damage_handle_
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Unable
to
initialize
XDamage
.
"
;
return
;
}
damage_region_
=
XFixesCreateRegion
(
display
(
)
0
0
)
;
if
(
!
damage_region_
)
{
XDamageDestroy
(
display
(
)
damage_handle_
)
;
RTC_LOG
(
LS_ERROR
)
<
<
"
Unable
to
create
XFixes
region
.
"
;
return
;
}
options_
.
x_display
(
)
-
>
AddEventHandler
(
damage_event_base_
+
XDamageNotify
this
)
;
use_damage_
=
true
;
RTC_LOG
(
LS_INFO
)
<
<
"
Using
XDamage
extension
.
"
;
}
void
ScreenCapturerLinux
:
:
Start
(
Callback
*
callback
)
{
RTC_DCHECK
(
!
callback_
)
;
RTC_DCHECK
(
callback
)
;
callback_
=
callback
;
}
void
ScreenCapturerLinux
:
:
Stop
(
)
{
callback_
=
NULL
;
}
void
ScreenCapturerLinux
:
:
CaptureFrame
(
)
{
int64_t
capture_start_time_nanos
=
rtc
:
:
TimeNanos
(
)
;
queue_
.
MoveToNextFrame
(
)
;
RTC_DCHECK
(
!
queue_
.
current_frame
(
)
|
|
!
queue_
.
current_frame
(
)
-
>
IsShared
(
)
)
;
options_
.
x_display
(
)
-
>
ProcessPendingXEvents
(
)
;
if
(
!
x_server_pixel_buffer_
.
is_initialized
(
)
)
{
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_PERMANENT
nullptr
)
;
return
;
}
if
(
!
queue_
.
current_frame
(
)
)
{
queue_
.
ReplaceCurrentFrame
(
SharedDesktopFrame
:
:
Wrap
(
std
:
:
unique_ptr
<
DesktopFrame
>
(
new
BasicDesktopFrame
(
x_server_pixel_buffer_
.
window_size
(
)
)
)
)
)
;
}
std
:
:
unique_ptr
<
DesktopFrame
>
result
=
CaptureScreen
(
)
;
if
(
!
result
)
{
callback_
-
>
OnCaptureResult
(
Result
:
:
ERROR_TEMPORARY
nullptr
)
;
return
;
}
last_invalid_region_
=
result
-
>
updated_region
(
)
;
result
-
>
set_capture_time_ms
(
(
rtc
:
:
TimeNanos
(
)
-
capture_start_time_nanos
)
/
rtc
:
:
kNumNanosecsPerMillisec
)
;
callback_
-
>
OnCaptureResult
(
Result
:
:
SUCCESS
std
:
:
move
(
result
)
)
;
}
bool
ScreenCapturerLinux
:
:
GetSourceList
(
SourceList
*
sources
)
{
RTC_DCHECK
(
sources
-
>
size
(
)
=
=
0
)
;
sources
-
>
push_back
(
{
0
}
)
;
return
true
;
}
bool
ScreenCapturerLinux
:
:
SelectSource
(
SourceId
id
)
{
return
true
;
}
bool
ScreenCapturerLinux
:
:
HandleXEvent
(
const
XEvent
&
event
)
{
if
(
use_damage_
&
&
(
event
.
type
=
=
damage_event_base_
+
XDamageNotify
)
)
{
const
XDamageNotifyEvent
*
damage_event
=
reinterpret_cast
<
const
XDamageNotifyEvent
*
>
(
&
event
)
;
if
(
damage_event
-
>
damage
!
=
damage_handle_
)
return
false
;
RTC_DCHECK
(
damage_event
-
>
level
=
=
XDamageReportNonEmpty
)
;
return
true
;
}
else
if
(
event
.
type
=
=
ConfigureNotify
)
{
ScreenConfigurationChanged
(
)
;
return
true
;
}
return
false
;
}
std
:
:
unique_ptr
<
DesktopFrame
>
ScreenCapturerLinux
:
:
CaptureScreen
(
)
{
std
:
:
unique_ptr
<
SharedDesktopFrame
>
frame
=
queue_
.
current_frame
(
)
-
>
Share
(
)
;
RTC_DCHECK
(
x_server_pixel_buffer_
.
window_size
(
)
.
equals
(
frame
-
>
size
(
)
)
)
;
helper_
.
set_size_most_recent
(
frame
-
>
size
(
)
)
;
if
(
use_damage_
&
&
queue_
.
previous_frame
(
)
)
SynchronizeFrame
(
)
;
DesktopRegion
*
updated_region
=
frame
-
>
mutable_updated_region
(
)
;
x_server_pixel_buffer_
.
Synchronize
(
)
;
if
(
use_damage_
&
&
queue_
.
previous_frame
(
)
)
{
XDamageSubtract
(
display
(
)
damage_handle_
None
damage_region_
)
;
int
rects_num
=
0
;
XRectangle
bounds
;
XRectangle
*
rects
=
XFixesFetchRegionAndBounds
(
display
(
)
damage_region_
&
rects_num
&
bounds
)
;
for
(
int
i
=
0
;
i
<
rects_num
;
+
+
i
)
{
updated_region
-
>
AddRect
(
DesktopRect
:
:
MakeXYWH
(
rects
[
i
]
.
x
rects
[
i
]
.
y
rects
[
i
]
.
width
rects
[
i
]
.
height
)
)
;
}
XFree
(
rects
)
;
helper_
.
InvalidateRegion
(
*
updated_region
)
;
helper_
.
TakeInvalidRegion
(
updated_region
)
;
updated_region
-
>
IntersectWith
(
DesktopRect
:
:
MakeSize
(
x_server_pixel_buffer_
.
window_size
(
)
)
)
;
for
(
DesktopRegion
:
:
Iterator
it
(
*
updated_region
)
;
!
it
.
IsAtEnd
(
)
;
it
.
Advance
(
)
)
{
if
(
!
x_server_pixel_buffer_
.
CaptureRect
(
it
.
rect
(
)
frame
.
get
(
)
)
)
return
nullptr
;
}
}
else
{
DesktopRect
screen_rect
=
DesktopRect
:
:
MakeSize
(
frame
-
>
size
(
)
)
;
if
(
!
x_server_pixel_buffer_
.
CaptureRect
(
screen_rect
frame
.
get
(
)
)
)
return
nullptr
;
updated_region
-
>
SetRect
(
screen_rect
)
;
}
return
std
:
:
move
(
frame
)
;
}
void
ScreenCapturerLinux
:
:
ScreenConfigurationChanged
(
)
{
queue_
.
Reset
(
)
;
helper_
.
ClearInvalidRegion
(
)
;
if
(
!
x_server_pixel_buffer_
.
Init
(
display
(
)
DefaultRootWindow
(
display
(
)
)
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
initialize
pixel
buffer
after
screen
"
"
configuration
change
.
"
;
}
}
void
ScreenCapturerLinux
:
:
SynchronizeFrame
(
)
{
RTC_DCHECK
(
queue_
.
previous_frame
(
)
)
;
DesktopFrame
*
current
=
queue_
.
current_frame
(
)
;
DesktopFrame
*
last
=
queue_
.
previous_frame
(
)
;
RTC_DCHECK
(
current
!
=
last
)
;
for
(
DesktopRegion
:
:
Iterator
it
(
last_invalid_region_
)
;
!
it
.
IsAtEnd
(
)
;
it
.
Advance
(
)
)
{
current
-
>
CopyPixelsFrom
(
*
last
it
.
rect
(
)
.
top_left
(
)
it
.
rect
(
)
)
;
}
}
void
ScreenCapturerLinux
:
:
DeinitXlib
(
)
{
if
(
gc_
)
{
XFreeGC
(
display
(
)
gc_
)
;
gc_
=
nullptr
;
}
x_server_pixel_buffer_
.
Release
(
)
;
if
(
display
(
)
)
{
if
(
damage_handle_
)
{
XDamageDestroy
(
display
(
)
damage_handle_
)
;
damage_handle_
=
0
;
}
if
(
damage_region_
)
{
XFixesDestroyRegion
(
display
(
)
damage_region_
)
;
damage_region_
=
0
;
}
}
}
}
std
:
:
unique_ptr
<
DesktopCapturer
>
DesktopCapturer
:
:
CreateRawScreenCapturer
(
const
DesktopCaptureOptions
&
options
)
{
if
(
!
options
.
x_display
(
)
)
return
nullptr
;
std
:
:
unique_ptr
<
ScreenCapturerLinux
>
capturer
(
new
ScreenCapturerLinux
(
)
)
;
if
(
!
capturer
.
get
(
)
-
>
Init
(
options
)
)
{
return
nullptr
;
}
return
std
:
:
move
(
capturer
)
;
}
}
