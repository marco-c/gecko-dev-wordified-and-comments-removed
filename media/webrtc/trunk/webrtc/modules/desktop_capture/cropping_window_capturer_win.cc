#
include
"
webrtc
/
modules
/
desktop_capture
/
cropping_window_capturer
.
h
"
#
include
"
webrtc
/
base
/
win32
.
h
"
#
include
"
webrtc
/
modules
/
desktop_capture
/
win
/
scoped_gdi_object
.
h
"
#
include
"
webrtc
/
modules
/
desktop_capture
/
win
/
screen_capture_utils
.
h
"
#
include
"
webrtc
/
modules
/
desktop_capture
/
win
/
window_capture_utils
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
logging
.
h
"
namespace
webrtc
{
namespace
{
struct
TopWindowVerifierContext
{
TopWindowVerifierContext
(
HWND
selected_window
HWND
excluded_window
)
:
selected_window
(
selected_window
)
excluded_window
(
excluded_window
)
is_top_window
(
false
)
selected_window_process_id
(
0
)
{
}
HWND
selected_window
;
HWND
excluded_window
;
bool
is_top_window
;
DWORD
selected_window_process_id
;
DesktopRect
selected_window_rect
;
}
;
BOOL
CALLBACK
TopWindowVerifier
(
HWND
hwnd
LPARAM
param
)
{
TopWindowVerifierContext
*
context
=
reinterpret_cast
<
TopWindowVerifierContext
*
>
(
param
)
;
if
(
hwnd
=
=
context
-
>
selected_window
)
{
context
-
>
is_top_window
=
true
;
return
FALSE
;
}
if
(
hwnd
=
=
context
-
>
excluded_window
)
{
return
TRUE
;
}
if
(
IsIconic
(
hwnd
)
|
|
!
IsWindowVisible
(
hwnd
)
)
{
return
TRUE
;
}
if
(
GetAncestor
(
hwnd
GA_ROOTOWNER
)
=
=
context
-
>
selected_window
)
{
return
TRUE
;
}
const
size_t
kTitleLength
=
32
;
WCHAR
window_title
[
kTitleLength
]
;
GetWindowText
(
hwnd
window_title
kTitleLength
)
;
if
(
wcsnlen_s
(
window_title
kTitleLength
)
=
=
0
)
{
DWORD
enumerated_process
;
GetWindowThreadProcessId
(
hwnd
&
enumerated_process
)
;
if
(
!
context
-
>
selected_window_process_id
)
{
GetWindowThreadProcessId
(
context
-
>
selected_window
&
context
-
>
selected_window_process_id
)
;
}
if
(
context
-
>
selected_window_process_id
=
=
enumerated_process
)
{
return
TRUE
;
}
}
RECT
enumerated_rect
;
if
(
!
GetWindowRect
(
hwnd
&
enumerated_rect
)
)
{
context
-
>
is_top_window
=
false
;
return
FALSE
;
}
DesktopRect
intersect_rect
=
context
-
>
selected_window_rect
;
DesktopRect
enumerated_desktop_rect
=
DesktopRect
:
:
MakeLTRB
(
enumerated_rect
.
left
enumerated_rect
.
top
enumerated_rect
.
right
enumerated_rect
.
bottom
)
;
intersect_rect
.
IntersectWith
(
enumerated_desktop_rect
)
;
if
(
!
intersect_rect
.
is_empty
(
)
)
{
context
-
>
is_top_window
=
false
;
return
FALSE
;
}
return
TRUE
;
}
class
CroppingWindowCapturerWin
:
public
CroppingWindowCapturer
{
public
:
CroppingWindowCapturerWin
(
const
DesktopCaptureOptions
&
options
)
:
CroppingWindowCapturer
(
options
)
{
}
private
:
bool
ShouldUseScreenCapturer
(
)
override
;
DesktopRect
GetWindowRectInVirtualScreen
(
)
override
;
DesktopRect
window_region_rect_
;
}
;
bool
CroppingWindowCapturerWin
:
:
ShouldUseScreenCapturer
(
)
{
if
(
!
rtc
:
:
IsWindows8OrLater
(
)
)
return
false
;
HWND
selected
=
reinterpret_cast
<
HWND
>
(
selected_window
(
)
)
;
LONG
window_ex_style
=
GetWindowLong
(
selected
GWL_EXSTYLE
)
;
if
(
window_ex_style
&
WS_EX_LAYERED
)
{
COLORREF
color_ref_key
=
0
;
BYTE
alpha
=
0
;
DWORD
flags
=
0
;
if
(
!
GetLayeredWindowAttributes
(
selected
&
color_ref_key
&
alpha
&
flags
)
)
return
false
;
if
(
(
flags
&
LWA_COLORKEY
)
|
|
(
(
flags
&
LWA_ALPHA
)
&
&
(
alpha
<
255
)
)
)
return
false
;
}
TopWindowVerifierContext
context
(
selected
reinterpret_cast
<
HWND
>
(
excluded_window
(
)
)
)
;
RECT
selected_window_rect
;
if
(
!
GetWindowRect
(
selected
&
selected_window_rect
)
)
{
return
false
;
}
context
.
selected_window_rect
=
DesktopRect
:
:
MakeLTRB
(
selected_window_rect
.
left
selected_window_rect
.
top
selected_window_rect
.
right
selected_window_rect
.
bottom
)
;
win
:
:
ScopedGDIObject
<
HRGN
win
:
:
DeleteObjectTraits
<
HRGN
>
>
scoped_hrgn
(
CreateRectRgn
(
0
0
0
0
)
)
;
int
region_type
=
GetWindowRgn
(
selected
scoped_hrgn
.
Get
(
)
)
;
if
(
region_type
=
=
COMPLEXREGION
|
|
region_type
=
=
NULLREGION
)
return
false
;
if
(
region_type
=
=
SIMPLEREGION
)
{
RECT
region_rect
;
GetRgnBox
(
scoped_hrgn
.
Get
(
)
&
region_rect
)
;
DesktopRect
rgn_rect
=
DesktopRect
:
:
MakeLTRB
(
region_rect
.
left
region_rect
.
top
region_rect
.
right
region_rect
.
bottom
)
;
rgn_rect
.
Translate
(
context
.
selected_window_rect
.
left
(
)
context
.
selected_window_rect
.
top
(
)
)
;
context
.
selected_window_rect
.
IntersectWith
(
rgn_rect
)
;
}
window_region_rect_
=
context
.
selected_window_rect
;
EnumWindows
(
&
TopWindowVerifier
reinterpret_cast
<
LPARAM
>
(
&
context
)
)
;
return
context
.
is_top_window
;
}
DesktopRect
CroppingWindowCapturerWin
:
:
GetWindowRectInVirtualScreen
(
)
{
DesktopRect
original_rect
;
DesktopRect
window_rect
;
HWND
hwnd
=
reinterpret_cast
<
HWND
>
(
selected_window
(
)
)
;
if
(
!
GetCroppedWindowRect
(
hwnd
&
window_rect
&
original_rect
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Failed
to
get
window
info
:
"
<
<
GetLastError
(
)
;
return
window_rect
;
}
window_rect
.
IntersectWith
(
window_region_rect_
)
;
DesktopRect
screen_rect
(
GetScreenRect
(
kFullDesktopScreenId
L
"
"
)
)
;
window_rect
.
IntersectWith
(
screen_rect
)
;
window_rect
.
Translate
(
-
screen_rect
.
left
(
)
-
screen_rect
.
top
(
)
)
;
return
window_rect
;
}
}
WindowCapturer
*
CroppingWindowCapturer
:
:
Create
(
const
DesktopCaptureOptions
&
options
)
{
return
new
CroppingWindowCapturerWin
(
options
)
;
}
}
