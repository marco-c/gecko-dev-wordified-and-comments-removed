#
ifndef
WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H264_H_
#
define
WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H264_H_
#
include
<
deque
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
string
>
#
include
"
webrtc
/
base
/
buffer
.
h
"
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtp_format
.
h
"
namespace
webrtc
{
class
RtpPacketizerH264
:
public
RtpPacketizer
{
public
:
RtpPacketizerH264
(
size_t
max_payload_len
H264PacketizationMode
packetization_mode
)
;
virtual
~
RtpPacketizerH264
(
)
;
void
SetPayloadData
(
const
uint8_t
*
payload_data
size_t
payload_size
const
RTPFragmentationHeader
*
fragmentation
)
override
;
bool
NextPacket
(
RtpPacketToSend
*
rtp_packet
bool
*
last_packet
)
override
;
ProtectionType
GetProtectionType
(
)
override
;
StorageType
GetStorageType
(
uint32_t
retransmission_settings
)
override
;
std
:
:
string
ToString
(
)
override
;
private
:
struct
Fragment
{
Fragment
(
const
uint8_t
*
buffer
size_t
length
)
;
explicit
Fragment
(
const
Fragment
&
fragment
)
;
const
uint8_t
*
buffer
=
nullptr
;
size_t
length
=
0
;
std
:
:
unique_ptr
<
rtc
:
:
Buffer
>
tmp_buffer
;
}
;
struct
PacketUnit
{
PacketUnit
(
const
Fragment
&
source_fragment
bool
first_fragment
bool
last_fragment
bool
aggregated
uint8_t
header
)
:
source_fragment
(
source_fragment
)
first_fragment
(
first_fragment
)
last_fragment
(
last_fragment
)
aggregated
(
aggregated
)
header
(
header
)
{
}
const
Fragment
source_fragment
;
bool
first_fragment
;
bool
last_fragment
;
bool
aggregated
;
uint8_t
header
;
}
;
void
GeneratePackets
(
)
;
void
PacketizeFuA
(
size_t
fragment_index
)
;
size_t
PacketizeStapA
(
size_t
fragment_index
)
;
void
PacketizeSingleNalu
(
size_t
fragment_index
)
;
void
NextAggregatePacket
(
RtpPacketToSend
*
rtp_packet
)
;
void
NextFragmentPacket
(
RtpPacketToSend
*
rtp_packet
)
;
const
size_t
max_payload_len_
;
const
H264PacketizationMode
packetization_mode_
;
std
:
:
deque
<
Fragment
>
input_fragments_
;
std
:
:
queue
<
PacketUnit
>
packets_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
RtpPacketizerH264
)
;
}
;
class
RtpDepacketizerH264
:
public
RtpDepacketizer
{
public
:
RtpDepacketizerH264
(
)
;
virtual
~
RtpDepacketizerH264
(
)
;
bool
Parse
(
ParsedPayload
*
parsed_payload
const
uint8_t
*
payload_data
size_t
payload_data_length
)
override
;
private
:
bool
ParseFuaNalu
(
RtpDepacketizer
:
:
ParsedPayload
*
parsed_payload
const
uint8_t
*
payload_data
)
;
bool
ProcessStapAOrSingleNalu
(
RtpDepacketizer
:
:
ParsedPayload
*
parsed_payload
const
uint8_t
*
payload_data
)
;
size_t
offset_
;
size_t
length_
;
std
:
:
unique_ptr
<
rtc
:
:
Buffer
>
modified_buffer_
;
}
;
}
#
endif
