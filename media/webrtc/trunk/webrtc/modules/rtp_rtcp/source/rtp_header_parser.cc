#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
rtp_header_parser
.
h
"
#
include
"
webrtc
/
base
/
criticalsection
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtp_header_extension
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtp_utility
.
h
"
namespace
webrtc
{
class
RtpHeaderParserImpl
:
public
RtpHeaderParser
{
public
:
RtpHeaderParserImpl
(
)
;
virtual
~
RtpHeaderParserImpl
(
)
{
}
bool
Parse
(
const
uint8_t
*
packet
size_t
length
RTPHeader
*
header
bool
secured
)
const
override
;
bool
RegisterRtpHeaderExtension
(
RTPExtensionType
type
uint8_t
id
)
override
;
bool
DeregisterRtpHeaderExtension
(
RTPExtensionType
type
)
override
;
private
:
rtc
:
:
CriticalSection
critical_section_
;
RtpHeaderExtensionMap
rtp_header_extension_map_
GUARDED_BY
(
critical_section_
)
;
}
;
RtpHeaderParser
*
RtpHeaderParser
:
:
Create
(
)
{
return
new
RtpHeaderParserImpl
;
}
RtpHeaderParserImpl
:
:
RtpHeaderParserImpl
(
)
{
}
bool
RtpHeaderParser
:
:
IsRtcp
(
const
uint8_t
*
packet
size_t
length
)
{
RtpUtility
:
:
RtpHeaderParser
rtp_parser
(
packet
length
)
;
return
rtp_parser
.
RTCP
(
)
;
}
bool
RtpHeaderParserImpl
:
:
Parse
(
const
uint8_t
*
packet
size_t
length
RTPHeader
*
header
bool
secured
)
const
{
RtpUtility
:
:
RtpHeaderParser
rtp_parser
(
packet
length
)
;
memset
(
header
0
sizeof
(
*
header
)
)
;
RtpHeaderExtensionMap
map
;
{
rtc
:
:
CritScope
cs
(
&
critical_section_
)
;
map
=
rtp_header_extension_map_
;
}
const
bool
valid_rtpheader
=
rtp_parser
.
Parse
(
header
&
map
secured
)
;
if
(
!
valid_rtpheader
)
{
return
false
;
}
return
true
;
}
bool
RtpHeaderParserImpl
:
:
RegisterRtpHeaderExtension
(
RTPExtensionType
type
uint8_t
id
)
{
rtc
:
:
CritScope
cs
(
&
critical_section_
)
;
return
rtp_header_extension_map_
.
RegisterByType
(
id
type
)
;
}
bool
RtpHeaderParserImpl
:
:
DeregisterRtpHeaderExtension
(
RTPExtensionType
type
)
{
rtc
:
:
CritScope
cs
(
&
critical_section_
)
;
return
rtp_header_extension_map_
.
Deregister
(
type
)
=
=
0
;
}
}
