#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtp_utility
.
h
"
#
include
<
string
.
h
>
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
rtp_cvo
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
namespace
webrtc
{
RtpData
*
NullObjectRtpData
(
)
{
static
NullRtpData
null_rtp_data
;
return
&
null_rtp_data
;
}
RtpFeedback
*
NullObjectRtpFeedback
(
)
{
static
NullRtpFeedback
null_rtp_feedback
;
return
&
null_rtp_feedback
;
}
ReceiveStatistics
*
NullObjectReceiveStatistics
(
)
{
static
NullReceiveStatistics
null_receive_statistics
;
return
&
null_receive_statistics
;
}
namespace
RtpUtility
{
enum
{
kRtcpExpectedVersion
=
2
kRtcpMinHeaderLength
=
4
kRtcpMinParseLength
=
8
kRtpExpectedVersion
=
2
kRtpMinParseLength
=
12
}
;
#
if
defined
(
_WIN32
)
bool
StringCompare
(
const
char
*
str1
const
char
*
str2
const
uint32_t
length
)
{
return
_strnicmp
(
str1
str2
length
)
=
=
0
;
}
#
elif
defined
(
WEBRTC_LINUX
)
|
|
defined
(
WEBRTC_BSD
)
|
|
defined
(
WEBRTC_MAC
)
bool
StringCompare
(
const
char
*
str1
const
char
*
str2
const
uint32_t
length
)
{
return
strncasecmp
(
str1
str2
length
)
=
=
0
;
}
#
endif
size_t
Word32Align
(
size_t
size
)
{
uint32_t
remainder
=
size
%
4
;
if
(
remainder
!
=
0
)
return
size
+
4
-
remainder
;
return
size
;
}
RtpHeaderParser
:
:
RtpHeaderParser
(
const
uint8_t
*
rtpData
const
size_t
rtpDataLength
)
:
_ptrRTPDataBegin
(
rtpData
)
_ptrRTPDataEnd
(
rtpData
?
(
rtpData
+
rtpDataLength
)
:
NULL
)
{
}
RtpHeaderParser
:
:
~
RtpHeaderParser
(
)
{
}
bool
RtpHeaderParser
:
:
RTCP
(
)
const
{
const
ptrdiff_t
length
=
_ptrRTPDataEnd
-
_ptrRTPDataBegin
;
if
(
length
<
kRtcpMinHeaderLength
)
{
return
false
;
}
const
uint8_t
V
=
_ptrRTPDataBegin
[
0
]
>
>
6
;
if
(
V
!
=
kRtcpExpectedVersion
)
{
return
false
;
}
const
uint8_t
payloadType
=
_ptrRTPDataBegin
[
1
]
;
switch
(
payloadType
)
{
case
192
:
return
true
;
case
193
:
return
false
;
case
195
:
case
200
:
case
201
:
case
202
:
case
203
:
case
204
:
case
205
:
case
206
:
case
207
:
return
true
;
default
:
return
false
;
}
}
bool
RtpHeaderParser
:
:
ParseRtcp
(
RTPHeader
*
header
)
const
{
assert
(
header
!
=
NULL
)
;
const
ptrdiff_t
length
=
_ptrRTPDataEnd
-
_ptrRTPDataBegin
;
if
(
length
<
kRtcpMinParseLength
)
{
return
false
;
}
const
uint8_t
V
=
_ptrRTPDataBegin
[
0
]
>
>
6
;
if
(
V
!
=
kRtcpExpectedVersion
)
{
return
false
;
}
const
uint8_t
PT
=
_ptrRTPDataBegin
[
1
]
;
const
size_t
len
=
(
_ptrRTPDataBegin
[
2
]
<
<
8
)
+
_ptrRTPDataBegin
[
3
]
;
const
uint8_t
*
ptr
=
&
_ptrRTPDataBegin
[
4
]
;
uint32_t
SSRC
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
ptr
)
;
ptr
+
=
4
;
header
-
>
payloadType
=
PT
;
header
-
>
ssrc
=
SSRC
;
header
-
>
headerLength
=
4
+
(
len
<
<
2
)
;
if
(
header
-
>
headerLength
>
static_cast
<
size_t
>
(
length
)
)
{
return
false
;
}
return
true
;
}
bool
RtpHeaderParser
:
:
Parse
(
RTPHeader
*
header
RtpHeaderExtensionMap
*
ptrExtensionMap
)
const
{
const
ptrdiff_t
length
=
_ptrRTPDataEnd
-
_ptrRTPDataBegin
;
if
(
length
<
kRtpMinParseLength
)
{
return
false
;
}
const
uint8_t
V
=
_ptrRTPDataBegin
[
0
]
>
>
6
;
const
bool
P
=
(
(
_ptrRTPDataBegin
[
0
]
&
0x20
)
=
=
0
)
?
false
:
true
;
const
bool
X
=
(
(
_ptrRTPDataBegin
[
0
]
&
0x10
)
=
=
0
)
?
false
:
true
;
const
uint8_t
CC
=
_ptrRTPDataBegin
[
0
]
&
0x0f
;
const
bool
M
=
(
(
_ptrRTPDataBegin
[
1
]
&
0x80
)
=
=
0
)
?
false
:
true
;
const
uint8_t
PT
=
_ptrRTPDataBegin
[
1
]
&
0x7f
;
const
uint16_t
sequenceNumber
=
(
_ptrRTPDataBegin
[
2
]
<
<
8
)
+
_ptrRTPDataBegin
[
3
]
;
const
uint8_t
*
ptr
=
&
_ptrRTPDataBegin
[
4
]
;
uint32_t
RTPTimestamp
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
ptr
)
;
ptr
+
=
4
;
uint32_t
SSRC
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
ptr
)
;
ptr
+
=
4
;
if
(
V
!
=
kRtpExpectedVersion
)
{
return
false
;
}
header
-
>
markerBit
=
M
;
header
-
>
payloadType
=
PT
;
header
-
>
sequenceNumber
=
sequenceNumber
;
header
-
>
timestamp
=
RTPTimestamp
;
header
-
>
ssrc
=
SSRC
;
header
-
>
numCSRCs
=
CC
;
header
-
>
paddingLength
=
P
?
*
(
_ptrRTPDataEnd
-
1
)
:
0
;
header
-
>
headerLength
=
12
+
(
CC
*
4
)
;
if
(
header
-
>
paddingLength
+
header
-
>
headerLength
>
(
size_t
)
length
)
{
return
false
;
}
for
(
uint8_t
i
=
0
;
i
<
CC
;
+
+
i
)
{
uint32_t
CSRC
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
ptr
)
;
ptr
+
=
4
;
header
-
>
arrOfCSRCs
[
i
]
=
CSRC
;
}
assert
(
(
ptr
-
_ptrRTPDataBegin
)
=
=
(
ptrdiff_t
)
header
-
>
headerLength
)
;
header
-
>
extension
.
hasTransmissionTimeOffset
=
false
;
header
-
>
extension
.
transmissionTimeOffset
=
0
;
header
-
>
extension
.
hasAbsoluteSendTime
=
false
;
header
-
>
extension
.
absoluteSendTime
=
0
;
header
-
>
extension
.
hasAudioLevel
=
false
;
header
-
>
extension
.
voiceActivity
=
false
;
header
-
>
extension
.
audioLevel
=
0
;
header
-
>
extension
.
hasVideoRotation
=
false
;
header
-
>
extension
.
videoRotation
=
kVideoRotation_0
;
header
-
>
extension
.
playout_delay
.
min_ms
=
-
1
;
header
-
>
extension
.
playout_delay
.
max_ms
=
-
1
;
if
(
X
)
{
const
ptrdiff_t
remain
=
(
_ptrRTPDataEnd
-
ptr
)
-
header
-
>
paddingLength
;
if
(
remain
<
4
)
{
return
false
;
}
header
-
>
headerLength
+
=
4
;
uint16_t
definedByProfile
=
ByteReader
<
uint16_t
>
:
:
ReadBigEndian
(
ptr
)
;
ptr
+
=
2
;
size_t
XLen
=
ByteReader
<
uint16_t
>
:
:
ReadBigEndian
(
ptr
)
;
ptr
+
=
2
;
XLen
*
=
4
;
if
(
static_cast
<
size_t
>
(
remain
)
<
(
4
+
XLen
)
)
{
return
false
;
}
if
(
definedByProfile
=
=
kRtpOneByteHeaderExtensionId
)
{
const
uint8_t
*
ptrRTPDataExtensionEnd
=
ptr
+
XLen
;
ParseOneByteExtensionHeader
(
header
ptrExtensionMap
ptrRTPDataExtensionEnd
ptr
)
;
}
header
-
>
headerLength
+
=
XLen
;
}
if
(
header
-
>
headerLength
+
header
-
>
paddingLength
>
static_cast
<
size_t
>
(
length
)
)
return
false
;
return
true
;
}
void
RtpHeaderParser
:
:
ParseOneByteExtensionHeader
(
RTPHeader
*
header
const
RtpHeaderExtensionMap
*
ptrExtensionMap
const
uint8_t
*
ptrRTPDataExtensionEnd
const
uint8_t
*
ptr
)
const
{
if
(
!
ptrExtensionMap
)
{
return
;
}
while
(
ptrRTPDataExtensionEnd
-
ptr
>
0
)
{
const
int
id
=
(
*
ptr
&
0xf0
)
>
>
4
;
const
int
len
=
(
*
ptr
&
0x0f
)
;
if
(
ptr
+
len
+
1
>
ptrRTPDataExtensionEnd
)
{
LOG
(
LS_WARNING
)
<
<
"
RTP
extension
header
length
out
of
bounds
.
Terminate
parsing
.
"
;
return
;
}
ptr
+
+
;
if
(
id
=
=
0
)
{
continue
;
}
if
(
id
=
=
15
)
{
LOG
(
LS_VERBOSE
)
<
<
"
RTP
extension
header
15
encountered
.
Terminate
parsing
.
"
;
return
;
}
if
(
ptrRTPDataExtensionEnd
-
ptr
<
(
len
+
1
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Incorrect
one
-
byte
extension
len
:
"
<
<
(
len
+
1
)
<
<
"
bytes
left
in
buffer
:
"
<
<
(
ptrRTPDataExtensionEnd
-
ptr
)
;
return
;
}
RTPExtensionType
type
=
ptrExtensionMap
-
>
GetType
(
id
)
;
if
(
type
=
=
RtpHeaderExtensionMap
:
:
kInvalidType
)
{
LOG
(
LS_VERBOSE
)
<
<
"
Failed
to
find
extension
id
:
"
<
<
id
;
}
else
{
switch
(
type
)
{
case
kRtpExtensionTransmissionTimeOffset
:
{
if
(
len
!
=
2
)
{
LOG
(
LS_WARNING
)
<
<
"
Incorrect
transmission
time
offset
len
:
"
<
<
len
;
return
;
}
header
-
>
extension
.
transmissionTimeOffset
=
ByteReader
<
int32_t
3
>
:
:
ReadBigEndian
(
ptr
)
;
header
-
>
extension
.
hasTransmissionTimeOffset
=
true
;
break
;
}
case
kRtpExtensionAudioLevel
:
{
if
(
len
!
=
0
)
{
LOG
(
LS_WARNING
)
<
<
"
Incorrect
audio
level
len
:
"
<
<
len
;
return
;
}
header
-
>
extension
.
audioLevel
=
ptr
[
0
]
&
0x7f
;
header
-
>
extension
.
voiceActivity
=
(
ptr
[
0
]
&
0x80
)
!
=
0
;
header
-
>
extension
.
hasAudioLevel
=
true
;
break
;
}
case
kRtpExtensionAbsoluteSendTime
:
{
if
(
len
!
=
2
)
{
LOG
(
LS_WARNING
)
<
<
"
Incorrect
absolute
send
time
len
:
"
<
<
len
;
return
;
}
header
-
>
extension
.
absoluteSendTime
=
ByteReader
<
uint32_t
3
>
:
:
ReadBigEndian
(
ptr
)
;
header
-
>
extension
.
hasAbsoluteSendTime
=
true
;
break
;
}
case
kRtpExtensionVideoRotation
:
{
if
(
len
!
=
0
)
{
LOG
(
LS_WARNING
)
<
<
"
Incorrect
coordination
of
video
coordination
len
:
"
<
<
len
;
return
;
}
header
-
>
extension
.
hasVideoRotation
=
true
;
header
-
>
extension
.
videoRotation
=
ConvertCVOByteToVideoRotation
(
ptr
[
0
]
)
;
break
;
}
case
kRtpExtensionTransportSequenceNumber
:
{
if
(
len
!
=
1
)
{
LOG
(
LS_WARNING
)
<
<
"
Incorrect
transport
sequence
number
len
:
"
<
<
len
;
return
;
}
uint16_t
sequence_number
=
ptr
[
0
]
<
<
8
;
sequence_number
+
=
ptr
[
1
]
;
header
-
>
extension
.
transportSequenceNumber
=
sequence_number
;
header
-
>
extension
.
hasTransportSequenceNumber
=
true
;
break
;
}
case
kRtpExtensionPlayoutDelay
:
{
if
(
len
!
=
2
)
{
LOG
(
LS_WARNING
)
<
<
"
Incorrect
playout
delay
len
:
"
<
<
len
;
return
;
}
int
min_playout_delay
=
(
ptr
[
0
]
<
<
4
)
|
(
(
ptr
[
1
]
>
>
4
)
&
0xf
)
;
int
max_playout_delay
=
(
(
ptr
[
1
]
&
0xf
)
<
<
8
)
|
ptr
[
2
]
;
header
-
>
extension
.
playout_delay
.
min_ms
=
min_playout_delay
*
kPlayoutDelayGranularityMs
;
header
-
>
extension
.
playout_delay
.
max_ms
=
max_playout_delay
*
kPlayoutDelayGranularityMs
;
break
;
}
case
kRtpExtensionRtpStreamId
:
{
header
-
>
extension
.
rtpStreamId
.
Set
(
rtc
:
:
MakeArrayView
(
ptr
len
+
1
)
)
;
break
;
}
case
kRtpExtensionRepairedRtpStreamId
:
{
header
-
>
extension
.
repairedRtpStreamId
.
Set
(
rtc
:
:
MakeArrayView
(
ptr
len
+
1
)
)
;
break
;
}
default
:
case
kRtpExtensionNone
:
case
kRtpExtensionNumberOfExtensions
:
{
RTC_NOTREACHED
(
)
<
<
"
Invalid
extension
type
:
"
<
<
type
;
return
;
}
}
}
ptr
+
=
(
len
+
1
)
;
}
}
}
}
