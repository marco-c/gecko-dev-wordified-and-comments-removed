#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
h264_bitstream_parser
.
h
"
#
include
<
vector
>
#
include
"
webrtc
/
base
/
bitbuffer
.
h
"
#
include
"
webrtc
/
base
/
bytebuffer
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
namespace
webrtc
{
namespace
{
static
const
size_t
kNaluHeaderSize
=
4
;
static
const
size_t
kNaluHeaderAndTypeSize
=
kNaluHeaderSize
+
1
;
static
const
uint8_t
kNaluSps
=
0x7
;
static
const
uint8_t
kNaluPps
=
0x8
;
static
const
uint8_t
kNaluIdr
=
0x5
;
static
const
uint8_t
kNaluTypeMask
=
0x1F
;
static
const
uint8_t
kSliceTypeP
=
0x0
;
static
const
uint8_t
kSliceTypeB
=
0x1
;
static
const
uint8_t
kSliceTypeSp
=
0x3
;
std
:
:
vector
<
size_t
>
FindNaluStartSequences
(
const
uint8_t
*
buffer
size_t
buffer_size
)
{
std
:
:
vector
<
size_t
>
sequences
;
const
uint8_t
*
end
=
buffer
+
buffer_size
-
4
;
for
(
const
uint8_t
*
head
=
buffer
;
head
<
end
;
)
{
if
(
head
[
3
]
>
1
)
{
head
+
=
4
;
}
else
if
(
head
[
3
]
=
=
1
&
&
head
[
2
]
=
=
0
&
&
head
[
1
]
=
=
0
&
&
head
[
0
]
=
=
0
)
{
sequences
.
push_back
(
static_cast
<
size_t
>
(
head
-
buffer
)
)
;
head
+
=
4
;
}
else
{
head
+
+
;
}
}
return
sequences
;
}
}
rtc
:
:
ByteBuffer
*
ParseRbsp
(
const
uint8_t
*
bytes
size_t
length
)
{
rtc
:
:
ByteBuffer
*
rbsp_buffer
=
new
rtc
:
:
ByteBuffer
;
for
(
size_t
i
=
0
;
i
<
length
;
)
{
if
(
length
-
i
>
=
3
&
&
bytes
[
i
]
=
=
0
&
&
bytes
[
i
+
1
]
=
=
0
&
&
bytes
[
i
+
2
]
=
=
3
)
{
rbsp_buffer
-
>
WriteBytes
(
reinterpret_cast
<
const
char
*
>
(
bytes
)
+
i
2
)
;
i
+
=
3
;
}
else
{
rbsp_buffer
-
>
WriteBytes
(
reinterpret_cast
<
const
char
*
>
(
bytes
)
+
i
1
)
;
i
+
+
;
}
}
return
rbsp_buffer
;
}
#
define
RETURN_FALSE_ON_FAIL
(
x
)
\
if
(
!
(
x
)
)
{
\
LOG_F
(
LS_ERROR
)
<
<
"
FAILED
:
"
#
x
;
\
return
false
;
\
}
H264BitstreamParser
:
:
PpsState
:
:
PpsState
(
)
{
}
H264BitstreamParser
:
:
SpsState
:
:
SpsState
(
)
{
}
bool
H264BitstreamParser
:
:
ParseSpsNalu
(
const
uint8_t
*
sps
size_t
length
)
{
sps_
=
SpsState
(
)
;
sps_parsed_
=
false
;
rtc
:
:
scoped_ptr
<
rtc
:
:
ByteBuffer
>
sps_rbsp
(
ParseRbsp
(
sps
+
kNaluHeaderAndTypeSize
length
-
kNaluHeaderAndTypeSize
)
)
;
rtc
:
:
BitBuffer
sps_parser
(
reinterpret_cast
<
const
uint8_t
*
>
(
sps_rbsp
-
>
Data
(
)
)
sps_rbsp
-
>
Length
(
)
)
;
uint8_t
byte_tmp
;
uint32_t
golomb_tmp
;
uint32_t
bits_tmp
;
uint8_t
profile_idc
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadUInt8
(
&
profile_idc
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadUInt8
(
&
byte_tmp
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadUInt8
(
&
byte_tmp
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
sps_
.
separate_colour_plane_flag
=
0
;
if
(
profile_idc
=
=
100
|
|
profile_idc
=
=
110
|
|
profile_idc
=
=
122
|
|
profile_idc
=
=
244
|
|
profile_idc
=
=
44
|
|
profile_idc
=
=
83
|
|
profile_idc
=
=
86
|
|
profile_idc
=
=
118
|
|
profile_idc
=
=
128
|
|
profile_idc
=
=
138
|
|
profile_idc
=
=
139
|
|
profile_idc
=
=
134
)
{
uint32_t
chroma_format_idc
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
chroma_format_idc
)
)
;
if
(
chroma_format_idc
=
=
3
)
{
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadBits
(
&
sps_
.
separate_colour_plane_flag
1
)
)
;
}
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadBits
(
&
bits_tmp
1
)
)
;
uint32_t
seq_scaling_matrix_present_flag
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadBits
(
&
seq_scaling_matrix_present_flag
1
)
)
;
if
(
seq_scaling_matrix_present_flag
)
{
uint32_t
seq_scaling_list_present_flags
;
if
(
chroma_format_idc
!
=
3
)
{
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadBits
(
&
seq_scaling_list_present_flags
8
)
)
;
}
else
{
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadBits
(
&
seq_scaling_list_present_flags
12
)
)
;
}
RTC_CHECK
(
seq_scaling_list_present_flags
=
=
0
)
<
<
"
SPS
contains
scaling
lists
which
are
unsupported
.
"
;
}
}
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
sps_
.
log2_max_frame_num_minus4
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
sps_
.
pic_order_cnt_type
)
)
;
if
(
sps_
.
pic_order_cnt_type
=
=
0
)
{
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
sps_
.
log2_max_pic_order_cnt_lsb_minus4
)
)
;
}
else
if
(
sps_
.
pic_order_cnt_type
=
=
1
)
{
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadBits
(
&
sps_
.
delta_pic_order_always_zero_flag
1
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
uint32_t
num_ref_frames_in_pic_order_cnt_cycle
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
num_ref_frames_in_pic_order_cnt_cycle
)
)
;
for
(
uint32_t
i
=
0
;
i
<
num_ref_frames_in_pic_order_cnt_cycle
;
i
+
+
)
{
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadBits
(
&
bits_tmp
1
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
RETURN_FALSE_ON_FAIL
(
sps_parser
.
ReadBits
(
&
sps_
.
frame_mbs_only_flag
1
)
)
;
sps_parsed_
=
true
;
return
true
;
}
bool
H264BitstreamParser
:
:
ParsePpsNalu
(
const
uint8_t
*
pps
size_t
length
)
{
RTC_CHECK
(
sps_parsed_
)
;
pps_
=
PpsState
(
)
;
pps_parsed_
=
false
;
rtc
:
:
scoped_ptr
<
rtc
:
:
ByteBuffer
>
buffer
(
ParseRbsp
(
pps
+
kNaluHeaderAndTypeSize
length
-
kNaluHeaderAndTypeSize
)
)
;
rtc
:
:
BitBuffer
parser
(
reinterpret_cast
<
const
uint8_t
*
>
(
buffer
-
>
Data
(
)
)
buffer
-
>
Length
(
)
)
;
uint32_t
bits_tmp
;
uint32_t
golomb_ignored
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
uint32_t
entropy_coding_mode_flag
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
entropy_coding_mode_flag
1
)
)
;
RTC_CHECK
(
entropy_coding_mode_flag
=
=
0
)
<
<
"
Don
'
t
know
how
to
parse
CABAC
streams
.
"
;
uint32_t
bottom_field_pic_order_in_frame_present_flag
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
bottom_field_pic_order_in_frame_present_flag
1
)
)
;
pps_
.
bottom_field_pic_order_in_frame_present_flag
=
bottom_field_pic_order_in_frame_present_flag
!
=
0
;
uint32_t
num_slice_groups_minus1
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
num_slice_groups_minus1
)
)
;
if
(
num_slice_groups_minus1
>
0
)
{
uint32_t
slice_group_map_type
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
slice_group_map_type
)
)
;
if
(
slice_group_map_type
=
=
0
)
{
for
(
uint32_t
i_group
=
0
;
i_group
<
=
num_slice_groups_minus1
;
+
+
i_group
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
}
}
else
if
(
slice_group_map_type
=
=
2
)
{
for
(
uint32_t
i_group
=
0
;
i_group
<
=
num_slice_groups_minus1
;
+
+
i_group
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
}
}
else
if
(
slice_group_map_type
=
=
3
|
|
slice_group_map_type
=
=
4
|
|
slice_group_map_type
=
=
5
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
bits_tmp
1
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
}
else
if
(
slice_group_map_type
=
=
6
)
{
uint32_t
pic_size_in_map_units_minus1
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
pic_size_in_map_units_minus1
)
)
;
uint32_t
slice_group_id_bits
=
0
;
uint32_t
num_slice_groups
=
num_slice_groups_minus1
+
1
;
if
(
(
num_slice_groups
&
(
num_slice_groups
-
1
)
)
!
=
0
)
+
+
slice_group_id_bits
;
while
(
num_slice_groups
>
0
)
{
num_slice_groups
>
>
=
1
;
+
+
slice_group_id_bits
;
}
for
(
uint32_t
i
=
0
;
i
<
=
pic_size_in_map_units_minus1
;
i
+
+
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
bits_tmp
slice_group_id_bits
)
)
;
}
}
}
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
uint32_t
weighted_pred_flag
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
weighted_pred_flag
1
)
)
;
pps_
.
weighted_pred_flag
=
weighted_pred_flag
!
=
0
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
pps_
.
weighted_bipred_idc
2
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadSignedExponentialGolomb
(
&
pps_
.
pic_init_qp_minus26
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
bits_tmp
2
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
pps_
.
redundant_pic_cnt_present_flag
1
)
)
;
pps_parsed_
=
true
;
return
true
;
}
bool
H264BitstreamParser
:
:
ParseNonParameterSetNalu
(
const
uint8_t
*
source
size_t
source_length
uint8_t
nalu_type
)
{
RTC_CHECK
(
sps_parsed_
)
;
RTC_CHECK
(
pps_parsed_
)
;
last_slice_qp_delta_parsed_
=
false
;
rtc
:
:
scoped_ptr
<
rtc
:
:
ByteBuffer
>
slice_rbsp
(
ParseRbsp
(
source
+
kNaluHeaderAndTypeSize
source_length
-
kNaluHeaderAndTypeSize
)
)
;
rtc
:
:
BitBuffer
slice_reader
(
reinterpret_cast
<
const
uint8_t
*
>
(
slice_rbsp
-
>
Data
(
)
)
slice_rbsp
-
>
Length
(
)
)
;
bool
is_idr
=
(
source
[
kNaluHeaderSize
]
&
0x0F
)
=
=
kNaluIdr
;
uint8_t
nal_ref_idc
=
(
source
[
kNaluHeaderSize
]
&
0x60
)
>
>
5
;
uint32_t
golomb_tmp
;
uint32_t
bits_tmp
;
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
uint32_t
slice_type
;
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
slice_type
)
)
;
slice_type
%
=
5
;
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
if
(
sps_
.
separate_colour_plane_flag
=
=
1
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
2
)
)
;
}
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
sps_
.
log2_max_frame_num_minus4
+
4
)
)
;
uint32_t
field_pic_flag
=
0
;
if
(
sps_
.
frame_mbs_only_flag
=
=
0
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
field_pic_flag
1
)
)
;
if
(
field_pic_flag
!
=
0
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
1
)
)
;
}
}
if
(
is_idr
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
sps_
.
pic_order_cnt_type
=
=
0
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
sps_
.
log2_max_pic_order_cnt_lsb_minus4
+
4
)
)
;
if
(
pps_
.
bottom_field_pic_order_in_frame_present_flag
&
&
field_pic_flag
=
=
0
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
if
(
sps_
.
pic_order_cnt_type
=
=
1
&
&
!
sps_
.
delta_pic_order_always_zero_flag
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
if
(
pps_
.
bottom_field_pic_order_in_frame_present_flag
&
&
!
field_pic_flag
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
if
(
pps_
.
redundant_pic_cnt_present_flag
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
slice_type
=
=
kSliceTypeB
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
1
)
)
;
}
if
(
slice_type
=
=
kSliceTypeP
|
|
slice_type
=
=
kSliceTypeSp
|
|
slice_type
=
=
kSliceTypeB
)
{
uint32_t
num_ref_idx_active_override_flag
;
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
num_ref_idx_active_override_flag
1
)
)
;
if
(
num_ref_idx_active_override_flag
!
=
0
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
if
(
slice_type
=
=
kSliceTypeB
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
}
RTC_CHECK_NE
(
nalu_type
20
)
;
RTC_CHECK_NE
(
nalu_type
21
)
;
{
if
(
slice_type
%
5
!
=
2
&
&
slice_type
%
5
!
=
4
)
{
uint32_t
ref_pic_list_modification_flag_l0
;
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
ref_pic_list_modification_flag_l0
1
)
)
;
if
(
ref_pic_list_modification_flag_l0
)
{
uint32_t
modification_of_pic_nums_idc
;
do
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
modification_of_pic_nums_idc
)
)
;
if
(
modification_of_pic_nums_idc
=
=
0
|
|
modification_of_pic_nums_idc
=
=
1
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
else
if
(
modification_of_pic_nums_idc
=
=
2
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
while
(
modification_of_pic_nums_idc
!
=
3
)
;
}
}
if
(
slice_type
%
5
=
=
1
)
{
uint32_t
ref_pic_list_modification_flag_l1
;
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
ref_pic_list_modification_flag_l1
1
)
)
;
if
(
ref_pic_list_modification_flag_l1
)
{
uint32_t
modification_of_pic_nums_idc
;
do
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
modification_of_pic_nums_idc
)
)
;
if
(
modification_of_pic_nums_idc
=
=
0
|
|
modification_of_pic_nums_idc
=
=
1
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
else
if
(
modification_of_pic_nums_idc
=
=
2
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
while
(
modification_of_pic_nums_idc
!
=
3
)
;
}
}
}
RTC_CHECK
(
!
(
(
pps_
.
weighted_pred_flag
&
&
(
slice_type
=
=
kSliceTypeP
|
|
slice_type
=
=
kSliceTypeSp
)
)
|
|
(
pps_
.
weighted_bipred_idc
!
=
0
&
&
slice_type
=
=
kSliceTypeB
)
)
)
<
<
"
Missing
support
for
pred_weight_table
(
)
.
"
;
if
(
nal_ref_idc
!
=
0
)
{
if
(
is_idr
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
bits_tmp
2
)
)
;
}
else
{
uint32_t
adaptive_ref_pic_marking_mode_flag
;
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadBits
(
&
adaptive_ref_pic_marking_mode_flag
1
)
)
;
if
(
adaptive_ref_pic_marking_mode_flag
)
{
uint32_t
memory_management_control_operation
;
do
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
memory_management_control_operation
)
)
;
if
(
memory_management_control_operation
=
=
1
|
|
memory_management_control_operation
=
=
3
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
memory_management_control_operation
=
=
2
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
memory_management_control_operation
=
=
3
|
|
memory_management_control_operation
=
=
6
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
if
(
memory_management_control_operation
=
=
4
)
{
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadExponentialGolomb
(
&
golomb_tmp
)
)
;
}
}
while
(
memory_management_control_operation
!
=
0
)
;
}
}
}
RETURN_FALSE_ON_FAIL
(
slice_reader
.
ReadSignedExponentialGolomb
(
&
last_slice_qp_delta_
)
)
;
last_slice_qp_delta_parsed_
=
true
;
return
true
;
}
void
H264BitstreamParser
:
:
ParseSlice
(
const
uint8_t
*
slice
size_t
length
)
{
uint8_t
nalu_type
=
slice
[
4
]
&
kNaluTypeMask
;
switch
(
nalu_type
)
{
case
kNaluSps
:
RTC_CHECK
(
ParseSpsNalu
(
slice
length
)
)
<
<
"
Failed
to
parse
bitstream
SPS
.
"
;
break
;
case
kNaluPps
:
RTC_CHECK
(
ParsePpsNalu
(
slice
length
)
)
<
<
"
Failed
to
parse
bitstream
PPS
.
"
;
break
;
default
:
RTC_CHECK
(
ParseNonParameterSetNalu
(
slice
length
nalu_type
)
)
<
<
"
Failed
to
parse
picture
slice
.
"
;
break
;
}
}
void
H264BitstreamParser
:
:
ParseBitstream
(
const
uint8_t
*
bitstream
size_t
length
)
{
RTC_CHECK_GE
(
length
4u
)
;
std
:
:
vector
<
size_t
>
slice_markers
=
FindNaluStartSequences
(
bitstream
length
)
;
RTC_CHECK
(
!
slice_markers
.
empty
(
)
)
;
for
(
size_t
i
=
0
;
i
<
slice_markers
.
size
(
)
-
1
;
+
+
i
)
{
ParseSlice
(
bitstream
+
slice_markers
[
i
]
slice_markers
[
i
+
1
]
-
slice_markers
[
i
]
)
;
}
ParseSlice
(
bitstream
+
slice_markers
.
back
(
)
length
-
slice_markers
.
back
(
)
)
;
}
bool
H264BitstreamParser
:
:
GetLastSliceQp
(
int
*
qp
)
const
{
if
(
!
last_slice_qp_delta_parsed_
)
return
false
;
*
qp
=
26
+
pps_
.
pic_init_qp_minus26
+
last_slice_qp_delta_
;
return
true
;
}
}
