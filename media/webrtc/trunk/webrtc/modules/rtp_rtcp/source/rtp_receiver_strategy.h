#
ifndef
MODULES_RTP_RTCP_SOURCE_RTP_RECEIVER_STRATEGY_H_
#
define
MODULES_RTP_RTCP_SOURCE_RTP_RECEIVER_STRATEGY_H_
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_utility
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
struct
CodecInst
;
class
TelephoneEventHandler
;
class
RTPReceiverStrategy
{
public
:
static
RTPReceiverStrategy
*
CreateVideoStrategy
(
RtpData
*
data_callback
)
;
static
RTPReceiverStrategy
*
CreateAudioStrategy
(
RtpData
*
data_callback
)
;
virtual
~
RTPReceiverStrategy
(
)
{
}
virtual
int32_t
ParseRtpPacket
(
WebRtcRTPHeader
*
rtp_header
const
PayloadUnion
&
specific_payload
bool
is_red
const
uint8_t
*
payload
size_t
payload_length
int64_t
timestamp_ms
)
=
0
;
virtual
TelephoneEventHandler
*
GetTelephoneEventHandler
(
)
=
0
;
virtual
RTPAliveType
ProcessDeadOrAlive
(
uint16_t
last_payload_length
)
const
=
0
;
virtual
bool
ShouldReportCsrcChanges
(
uint8_t
payload_type
)
const
=
0
;
virtual
int32_t
OnNewPayloadTypeCreated
(
int
payload_type
const
SdpAudioFormat
&
audio_format
)
=
0
;
virtual
int32_t
InvokeOnInitializeDecoder
(
RtpFeedback
*
callback
int8_t
payload_type
const
char
payload_name
[
RTP_PAYLOAD_NAME_SIZE
]
const
PayloadUnion
&
specific_payload
)
const
=
0
;
virtual
void
CheckPayloadChanged
(
int8_t
payload_type
PayloadUnion
*
specific_payload
bool
*
should_discard_changes
)
;
virtual
int
Energy
(
uint8_t
array_of_energy
[
kRtpCsrcSize
]
)
const
;
void
GetLastMediaSpecificPayload
(
PayloadUnion
*
payload
)
const
;
void
SetLastMediaSpecificPayload
(
const
PayloadUnion
&
payload
)
;
protected
:
explicit
RTPReceiverStrategy
(
RtpData
*
data_callback
)
;
rtc
:
:
CriticalSection
crit_sect_
;
rtc
:
:
Optional
<
PayloadUnion
>
last_payload_
;
RtpData
*
data_callback_
;
}
;
}
#
endif
