#
include
"
modules
/
rtp_rtcp
/
source
/
ulpfec_generator
.
h
"
#
include
<
memory
>
#
include
<
utility
>
#
include
"
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
forward_error_correction
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_utility
.
h
"
#
include
"
rtc_base
/
basictypes
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
namespace
webrtc
{
namespace
{
constexpr
size_t
kRedForFecHeaderLength
=
1
;
constexpr
int
kMaxExcessOverhead
=
50
;
constexpr
size_t
kMinMediaPackets
=
4
;
constexpr
uint8_t
kHighProtectionThreshold
=
80
;
constexpr
float
kMinMediaPacketsAdaptationThreshold
=
2
.
0f
;
constexpr
uint32_t
kUnknownSsrc
=
0
;
}
RedPacket
:
:
RedPacket
(
size_t
length
)
:
data_
(
new
uint8_t
[
length
]
)
length_
(
length
)
header_length_
(
0
)
{
}
void
RedPacket
:
:
CreateHeader
(
const
uint8_t
*
rtp_header
size_t
header_length
int
red_payload_type
int
payload_type
)
{
RTC_DCHECK_LE
(
header_length
+
kRedForFecHeaderLength
length_
)
;
memcpy
(
data_
.
get
(
)
rtp_header
header_length
)
;
data_
[
1
]
&
=
0x80
;
data_
[
1
]
+
=
red_payload_type
;
data_
[
header_length
]
=
static_cast
<
uint8_t
>
(
payload_type
)
;
header_length_
=
header_length
+
kRedForFecHeaderLength
;
}
void
RedPacket
:
:
SetSeqNum
(
int
seq_num
)
{
RTC_DCHECK_GE
(
seq_num
0
)
;
RTC_DCHECK_LT
(
seq_num
1
<
<
16
)
;
ByteWriter
<
uint16_t
>
:
:
WriteBigEndian
(
&
data_
[
2
]
seq_num
)
;
}
void
RedPacket
:
:
AssignPayload
(
const
uint8_t
*
payload
size_t
length
)
{
RTC_DCHECK_LE
(
header_length_
+
length
length_
)
;
memcpy
(
data_
.
get
(
)
+
header_length_
payload
length
)
;
}
void
RedPacket
:
:
ClearMarkerBit
(
)
{
data_
[
1
]
&
=
0x7F
;
}
uint8_t
*
RedPacket
:
:
data
(
)
const
{
return
data_
.
get
(
)
;
}
size_t
RedPacket
:
:
length
(
)
const
{
return
length_
;
}
UlpfecGenerator
:
:
UlpfecGenerator
(
)
:
UlpfecGenerator
(
ForwardErrorCorrection
:
:
CreateUlpfec
(
kUnknownSsrc
)
)
{
}
UlpfecGenerator
:
:
UlpfecGenerator
(
std
:
:
unique_ptr
<
ForwardErrorCorrection
>
fec
)
:
fec_
(
std
:
:
move
(
fec
)
)
num_protected_frames_
(
0
)
min_num_media_packets_
(
1
)
{
memset
(
&
params_
0
sizeof
(
params_
)
)
;
memset
(
&
new_params_
0
sizeof
(
new_params_
)
)
;
}
UlpfecGenerator
:
:
~
UlpfecGenerator
(
)
=
default
;
void
UlpfecGenerator
:
:
SetFecParameters
(
const
FecProtectionParams
&
params
)
{
RTC_DCHECK_GE
(
params
.
fec_rate
0
)
;
RTC_DCHECK_LE
(
params
.
fec_rate
255
)
;
new_params_
=
params
;
if
(
params
.
fec_rate
>
kHighProtectionThreshold
)
{
min_num_media_packets_
=
kMinMediaPackets
;
}
else
{
min_num_media_packets_
=
1
;
}
}
int
UlpfecGenerator
:
:
AddRtpPacketAndGenerateFec
(
const
uint8_t
*
data_buffer
size_t
payload_length
size_t
rtp_header_length
)
{
RTC_DCHECK
(
generated_fec_packets_
.
empty
(
)
)
;
if
(
media_packets_
.
empty
(
)
)
{
params_
=
new_params_
;
}
bool
complete_frame
=
false
;
const
bool
marker_bit
=
(
data_buffer
[
1
]
&
kRtpMarkerBitMask
)
?
true
:
false
;
if
(
media_packets_
.
size
(
)
<
kUlpfecMaxMediaPackets
)
{
std
:
:
unique_ptr
<
ForwardErrorCorrection
:
:
Packet
>
packet
(
new
ForwardErrorCorrection
:
:
Packet
(
)
)
;
packet
-
>
length
=
payload_length
+
rtp_header_length
;
memcpy
(
packet
-
>
data
data_buffer
packet
-
>
length
)
;
media_packets_
.
push_back
(
std
:
:
move
(
packet
)
)
;
}
if
(
marker_bit
)
{
+
+
num_protected_frames_
;
complete_frame
=
true
;
}
if
(
complete_frame
&
&
(
num_protected_frames_
=
=
params_
.
max_fec_frames
|
|
(
ExcessOverheadBelowMax
(
)
&
&
MinimumMediaPacketsReached
(
)
)
)
)
{
constexpr
int
kNumImportantPackets
=
0
;
constexpr
bool
kUseUnequalProtection
=
false
;
int
ret
=
fec_
-
>
EncodeFec
(
media_packets_
params_
.
fec_rate
kNumImportantPackets
kUseUnequalProtection
params_
.
fec_mask_type
&
generated_fec_packets_
)
;
if
(
generated_fec_packets_
.
empty
(
)
)
{
ResetState
(
)
;
}
return
ret
;
}
return
0
;
}
bool
UlpfecGenerator
:
:
ExcessOverheadBelowMax
(
)
const
{
return
(
(
Overhead
(
)
-
params_
.
fec_rate
)
<
kMaxExcessOverhead
)
;
}
bool
UlpfecGenerator
:
:
MinimumMediaPacketsReached
(
)
const
{
float
average_num_packets_per_frame
=
static_cast
<
float
>
(
media_packets_
.
size
(
)
)
/
num_protected_frames_
;
int
num_media_packets
=
static_cast
<
int
>
(
media_packets_
.
size
(
)
)
;
if
(
average_num_packets_per_frame
<
kMinMediaPacketsAdaptationThreshold
)
{
return
num_media_packets
>
=
min_num_media_packets_
;
}
else
{
return
num_media_packets
>
=
min_num_media_packets_
+
1
;
}
}
bool
UlpfecGenerator
:
:
FecAvailable
(
)
const
{
return
!
generated_fec_packets_
.
empty
(
)
;
}
size_t
UlpfecGenerator
:
:
NumAvailableFecPackets
(
)
const
{
return
generated_fec_packets_
.
size
(
)
;
}
size_t
UlpfecGenerator
:
:
MaxPacketOverhead
(
)
const
{
return
fec_
-
>
MaxPacketOverhead
(
)
;
}
std
:
:
vector
<
std
:
:
unique_ptr
<
RedPacket
>
>
UlpfecGenerator
:
:
GetUlpfecPacketsAsRed
(
int
red_payload_type
int
ulpfec_payload_type
uint16_t
first_seq_num
size_t
rtp_header_length
)
{
std
:
:
vector
<
std
:
:
unique_ptr
<
RedPacket
>
>
red_packets
;
red_packets
.
reserve
(
generated_fec_packets_
.
size
(
)
)
;
RTC_DCHECK
(
!
media_packets_
.
empty
(
)
)
;
ForwardErrorCorrection
:
:
Packet
*
last_media_packet
=
media_packets_
.
back
(
)
.
get
(
)
;
uint16_t
seq_num
=
first_seq_num
;
for
(
const
auto
&
fec_packet
:
generated_fec_packets_
)
{
std
:
:
unique_ptr
<
RedPacket
>
red_packet
(
new
RedPacket
(
fec_packet
-
>
length
+
kRedForFecHeaderLength
+
rtp_header_length
)
)
;
red_packet
-
>
CreateHeader
(
last_media_packet
-
>
data
rtp_header_length
red_payload_type
ulpfec_payload_type
)
;
red_packet
-
>
SetSeqNum
(
seq_num
+
+
)
;
red_packet
-
>
ClearMarkerBit
(
)
;
red_packet
-
>
AssignPayload
(
fec_packet
-
>
data
fec_packet
-
>
length
)
;
red_packets
.
push_back
(
std
:
:
move
(
red_packet
)
)
;
}
ResetState
(
)
;
return
red_packets
;
}
int
UlpfecGenerator
:
:
Overhead
(
)
const
{
RTC_DCHECK
(
!
media_packets_
.
empty
(
)
)
;
int
num_fec_packets
=
fec_
-
>
NumFecPackets
(
media_packets_
.
size
(
)
params_
.
fec_rate
)
;
return
(
num_fec_packets
<
<
8
)
/
media_packets_
.
size
(
)
;
}
void
UlpfecGenerator
:
:
ResetState
(
)
{
media_packets_
.
clear
(
)
;
generated_fec_packets_
.
clear
(
)
;
num_protected_frames_
=
0
;
}
}
