#
include
"
modules
/
rtp_rtcp
/
source
/
ulpfec_receiver_impl
.
h
"
#
include
<
memory
>
#
include
<
utility
>
#
include
"
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_receiver_video
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
UlpfecReceiver
*
UlpfecReceiver
:
:
Create
(
uint32_t
ssrc
RecoveredPacketReceiver
*
callback
)
{
return
new
UlpfecReceiverImpl
(
ssrc
callback
)
;
}
UlpfecReceiverImpl
:
:
UlpfecReceiverImpl
(
uint32_t
ssrc
RecoveredPacketReceiver
*
callback
)
:
ssrc_
(
ssrc
)
recovered_packet_callback_
(
callback
)
fec_
(
ForwardErrorCorrection
:
:
CreateUlpfec
(
ssrc_
)
)
{
}
UlpfecReceiverImpl
:
:
~
UlpfecReceiverImpl
(
)
{
received_packets_
.
clear
(
)
;
fec_
-
>
ResetState
(
&
recovered_packets_
)
;
}
FecPacketCounter
UlpfecReceiverImpl
:
:
GetPacketCounter
(
)
const
{
rtc
:
:
CritScope
cs
(
&
crit_sect_
)
;
return
packet_counter_
;
}
int32_t
UlpfecReceiverImpl
:
:
AddReceivedRedPacket
(
const
RTPHeader
&
header
const
uint8_t
*
incoming_rtp_packet
size_t
packet_length
uint8_t
ulpfec_payload_type
)
{
if
(
header
.
ssrc
!
=
ssrc_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Received
RED
packet
with
different
SSRC
than
expected
;
dropping
.
"
;
return
-
1
;
}
if
(
packet_length
>
IP_PACKET_SIZE
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Received
RED
packet
with
length
exceeds
maximum
IP
"
"
packet
size
;
dropping
.
"
;
return
-
1
;
}
rtc
:
:
CritScope
cs
(
&
crit_sect_
)
;
uint8_t
red_header_length
=
1
;
size_t
payload_data_length
=
packet_length
-
header
.
headerLength
;
if
(
payload_data_length
=
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Corrupt
/
truncated
FEC
packet
.
"
;
return
-
1
;
}
std
:
:
unique_ptr
<
ForwardErrorCorrection
:
:
ReceivedPacket
>
received_packet
(
new
ForwardErrorCorrection
:
:
ReceivedPacket
(
)
)
;
received_packet
-
>
pkt
=
new
ForwardErrorCorrection
:
:
Packet
(
)
;
uint8_t
payload_type
=
incoming_rtp_packet
[
header
.
headerLength
]
&
0x7f
;
received_packet
-
>
is_fec
=
payload_type
=
=
ulpfec_payload_type
;
received_packet
-
>
ssrc
=
header
.
ssrc
;
received_packet
-
>
seq_num
=
header
.
sequenceNumber
;
uint16_t
block_length
=
0
;
if
(
incoming_rtp_packet
[
header
.
headerLength
]
&
0x80
)
{
red_header_length
=
4
;
if
(
payload_data_length
<
red_header_length
+
1u
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Corrupt
/
truncated
FEC
packet
.
"
;
return
-
1
;
}
uint16_t
timestamp_offset
=
incoming_rtp_packet
[
header
.
headerLength
+
1
]
<
<
8
;
timestamp_offset
+
=
incoming_rtp_packet
[
header
.
headerLength
+
2
]
;
timestamp_offset
=
timestamp_offset
>
>
2
;
if
(
timestamp_offset
!
=
0
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Corrupt
payload
found
.
"
;
return
-
1
;
}
block_length
=
(
0x3
&
incoming_rtp_packet
[
header
.
headerLength
+
2
]
)
<
<
8
;
block_length
+
=
incoming_rtp_packet
[
header
.
headerLength
+
3
]
;
if
(
incoming_rtp_packet
[
header
.
headerLength
+
4
]
&
0x80
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
More
than
2
blocks
in
packet
not
supported
.
"
;
return
-
1
;
}
if
(
block_length
>
payload_data_length
-
(
red_header_length
+
1
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Block
length
longer
than
packet
.
"
;
return
-
1
;
}
}
+
+
packet_counter_
.
num_packets
;
if
(
packet_counter_
.
first_packet_time_ms
=
=
-
1
)
{
packet_counter_
.
first_packet_time_ms
=
Clock
:
:
GetRealTimeClock
(
)
-
>
TimeInMilliseconds
(
)
;
}
std
:
:
unique_ptr
<
ForwardErrorCorrection
:
:
ReceivedPacket
>
second_received_packet
;
if
(
block_length
>
0
)
{
red_header_length
=
5
;
memcpy
(
received_packet
-
>
pkt
-
>
data
incoming_rtp_packet
header
.
headerLength
)
;
received_packet
-
>
pkt
-
>
data
[
1
]
&
=
0x80
;
received_packet
-
>
pkt
-
>
data
[
1
]
+
=
payload_type
;
memcpy
(
received_packet
-
>
pkt
-
>
data
+
header
.
headerLength
incoming_rtp_packet
+
header
.
headerLength
+
red_header_length
block_length
)
;
received_packet
-
>
pkt
-
>
length
=
block_length
;
second_received_packet
.
reset
(
new
ForwardErrorCorrection
:
:
ReceivedPacket
)
;
second_received_packet
-
>
pkt
=
new
ForwardErrorCorrection
:
:
Packet
;
second_received_packet
-
>
is_fec
=
true
;
second_received_packet
-
>
ssrc
=
header
.
ssrc
;
second_received_packet
-
>
seq_num
=
header
.
sequenceNumber
;
+
+
packet_counter_
.
num_fec_packets
;
memcpy
(
second_received_packet
-
>
pkt
-
>
data
incoming_rtp_packet
+
header
.
headerLength
+
red_header_length
+
block_length
payload_data_length
-
red_header_length
-
block_length
)
;
second_received_packet
-
>
pkt
-
>
length
=
payload_data_length
-
red_header_length
-
block_length
;
}
else
if
(
received_packet
-
>
is_fec
)
{
+
+
packet_counter_
.
num_fec_packets
;
memcpy
(
received_packet
-
>
pkt
-
>
data
incoming_rtp_packet
+
header
.
headerLength
+
red_header_length
payload_data_length
-
red_header_length
)
;
received_packet
-
>
pkt
-
>
length
=
payload_data_length
-
red_header_length
;
received_packet
-
>
ssrc
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
&
incoming_rtp_packet
[
8
]
)
;
}
else
{
memcpy
(
received_packet
-
>
pkt
-
>
data
incoming_rtp_packet
header
.
headerLength
)
;
received_packet
-
>
pkt
-
>
data
[
1
]
&
=
0x80
;
received_packet
-
>
pkt
-
>
data
[
1
]
+
=
payload_type
;
memcpy
(
received_packet
-
>
pkt
-
>
data
+
header
.
headerLength
incoming_rtp_packet
+
header
.
headerLength
+
red_header_length
payload_data_length
-
red_header_length
)
;
received_packet
-
>
pkt
-
>
length
=
header
.
headerLength
+
payload_data_length
-
red_header_length
;
}
if
(
received_packet
-
>
pkt
-
>
length
=
=
0
)
{
return
0
;
}
received_packets_
.
push_back
(
std
:
:
move
(
received_packet
)
)
;
if
(
second_received_packet
)
{
received_packets_
.
push_back
(
std
:
:
move
(
second_received_packet
)
)
;
}
return
0
;
}
int32_t
UlpfecReceiverImpl
:
:
ProcessReceivedFec
(
)
{
crit_sect_
.
Enter
(
)
;
for
(
const
auto
&
received_packet
:
received_packets_
)
{
if
(
!
received_packet
-
>
is_fec
)
{
ForwardErrorCorrection
:
:
Packet
*
packet
=
received_packet
-
>
pkt
;
crit_sect_
.
Leave
(
)
;
recovered_packet_callback_
-
>
OnRecoveredPacket
(
packet
-
>
data
packet
-
>
length
)
;
crit_sect_
.
Enter
(
)
;
}
fec_
-
>
DecodeFec
(
*
received_packet
&
recovered_packets_
)
;
}
received_packets_
.
clear
(
)
;
for
(
const
auto
&
recovered_packet
:
recovered_packets_
)
{
if
(
recovered_packet
-
>
returned
)
{
continue
;
}
ForwardErrorCorrection
:
:
Packet
*
packet
=
recovered_packet
-
>
pkt
;
+
+
packet_counter_
.
num_recovered_packets
;
recovered_packet
-
>
returned
=
true
;
crit_sect_
.
Leave
(
)
;
recovered_packet_callback_
-
>
OnRecoveredPacket
(
packet
-
>
data
packet
-
>
length
)
;
crit_sect_
.
Enter
(
)
;
}
crit_sect_
.
Leave
(
)
;
return
0
;
}
}
