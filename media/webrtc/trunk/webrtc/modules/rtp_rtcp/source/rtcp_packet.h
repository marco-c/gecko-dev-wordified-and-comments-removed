#
ifndef
WEBRTC_MODULES_RTP_RTCP_SOURCE_RTCP_PACKET_H_
#
define
WEBRTC_MODULES_RTP_RTCP_SOURCE_RTCP_PACKET_H_
#
include
<
map
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
dlrr
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
report_block
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
rrtr
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
voip_metric
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_utility
.
h
"
#
include
"
webrtc
/
typedefs
.
h
"
namespace
webrtc
{
namespace
rtcp
{
static
const
int
kCommonFbFmtLength
=
12
;
static
const
int
kReportBlockLength
=
24
;
class
RawPacket
;
class
RtcpPacket
{
public
:
virtual
~
RtcpPacket
(
)
{
}
void
Append
(
RtcpPacket
*
packet
)
;
class
PacketReadyCallback
{
public
:
PacketReadyCallback
(
)
{
}
virtual
~
PacketReadyCallback
(
)
{
}
virtual
void
OnPacketReady
(
uint8_t
*
data
size_t
length
)
=
0
;
}
;
rtc
:
:
scoped_ptr
<
RawPacket
>
Build
(
)
const
;
bool
Build
(
PacketReadyCallback
*
callback
)
const
;
bool
BuildExternalBuffer
(
uint8_t
*
buffer
size_t
max_length
PacketReadyCallback
*
callback
)
const
;
virtual
size_t
BlockLength
(
)
const
=
0
;
protected
:
RtcpPacket
(
)
{
}
virtual
bool
Create
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
PacketReadyCallback
*
callback
)
const
=
0
;
static
void
CreateHeader
(
uint8_t
count_or_format
uint8_t
packet_type
size_t
block_length
uint8_t
*
buffer
size_t
*
pos
)
;
bool
OnBufferFull
(
uint8_t
*
packet
size_t
*
index
RtcpPacket
:
:
PacketReadyCallback
*
callback
)
const
;
size_t
HeaderLength
(
)
const
;
static
const
size_t
kHeaderLength
=
4
;
std
:
:
vector
<
RtcpPacket
*
>
appended_packets_
;
private
:
bool
CreateAndAddAppended
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
PacketReadyCallback
*
callback
)
const
;
}
;
class
SenderReport
:
public
RtcpPacket
{
public
:
SenderReport
(
)
:
RtcpPacket
(
)
{
memset
(
&
sr_
0
sizeof
(
sr_
)
)
;
}
virtual
~
SenderReport
(
)
{
}
void
From
(
uint32_t
ssrc
)
{
sr_
.
SenderSSRC
=
ssrc
;
}
void
WithNtpSec
(
uint32_t
sec
)
{
sr_
.
NTPMostSignificant
=
sec
;
}
void
WithNtpFrac
(
uint32_t
frac
)
{
sr_
.
NTPLeastSignificant
=
frac
;
}
void
WithRtpTimestamp
(
uint32_t
rtp_timestamp
)
{
sr_
.
RTPTimestamp
=
rtp_timestamp
;
}
void
WithPacketCount
(
uint32_t
packet_count
)
{
sr_
.
SenderPacketCount
=
packet_count
;
}
void
WithOctetCount
(
uint32_t
octet_count
)
{
sr_
.
SenderOctetCount
=
octet_count
;
}
bool
WithReportBlock
(
const
ReportBlock
&
block
)
;
protected
:
bool
Create
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
RtcpPacket
:
:
PacketReadyCallback
*
callback
)
const
override
;
private
:
static
const
int
kMaxNumberOfReportBlocks
=
0x1f
;
size_t
BlockLength
(
)
const
override
{
const
size_t
kSrHeaderLength
=
8
;
const
size_t
kSenderInfoLength
=
20
;
return
kSrHeaderLength
+
kSenderInfoLength
+
report_blocks_
.
size
(
)
*
kReportBlockLength
;
}
RTCPUtility
:
:
RTCPPacketSR
sr_
;
std
:
:
vector
<
ReportBlock
>
report_blocks_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
SenderReport
)
;
}
;
class
Sdes
:
public
RtcpPacket
{
public
:
Sdes
(
)
:
RtcpPacket
(
)
{
}
virtual
~
Sdes
(
)
{
}
bool
WithCName
(
uint32_t
ssrc
const
std
:
:
string
&
cname
)
;
struct
Chunk
{
uint32_t
ssrc
;
std
:
:
string
name
;
int
null_octets
;
}
;
protected
:
bool
Create
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
RtcpPacket
:
:
PacketReadyCallback
*
callback
)
const
override
;
private
:
static
const
int
kMaxNumberOfChunks
=
0x1f
;
size_t
BlockLength
(
)
const
override
;
std
:
:
vector
<
Chunk
>
chunks_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
Sdes
)
;
}
;
class
Rpsi
:
public
RtcpPacket
{
public
:
Rpsi
(
)
:
RtcpPacket
(
)
padding_bytes_
(
0
)
{
memset
(
&
rpsi_
0
sizeof
(
rpsi_
)
)
;
}
virtual
~
Rpsi
(
)
{
}
void
From
(
uint32_t
ssrc
)
{
rpsi_
.
SenderSSRC
=
ssrc
;
}
void
To
(
uint32_t
ssrc
)
{
rpsi_
.
MediaSSRC
=
ssrc
;
}
void
WithPayloadType
(
uint8_t
payload
)
{
assert
(
payload
<
=
0x7f
)
;
rpsi_
.
PayloadType
=
payload
;
}
void
WithPictureId
(
uint64_t
picture_id
)
;
protected
:
bool
Create
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
RtcpPacket
:
:
PacketReadyCallback
*
callback
)
const
override
;
private
:
size_t
BlockLength
(
)
const
override
{
size_t
fci_length
=
2
+
(
rpsi_
.
NumberOfValidBits
/
8
)
+
padding_bytes_
;
return
kCommonFbFmtLength
+
fci_length
;
}
uint8_t
padding_bytes_
;
RTCPUtility
:
:
RTCPPacketPSFBRPSI
rpsi_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
Rpsi
)
;
}
;
class
Fir
:
public
RtcpPacket
{
public
:
Fir
(
)
:
RtcpPacket
(
)
{
memset
(
&
fir_
0
sizeof
(
fir_
)
)
;
memset
(
&
fir_item_
0
sizeof
(
fir_item_
)
)
;
}
virtual
~
Fir
(
)
{
}
void
From
(
uint32_t
ssrc
)
{
fir_
.
SenderSSRC
=
ssrc
;
}
void
To
(
uint32_t
ssrc
)
{
fir_item_
.
SSRC
=
ssrc
;
}
void
WithCommandSeqNum
(
uint8_t
seq_num
)
{
fir_item_
.
CommandSequenceNumber
=
seq_num
;
}
protected
:
bool
Create
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
RtcpPacket
:
:
PacketReadyCallback
*
callback
)
const
override
;
private
:
size_t
BlockLength
(
)
const
override
{
const
size_t
kFciLength
=
8
;
return
kCommonFbFmtLength
+
kFciLength
;
}
RTCPUtility
:
:
RTCPPacketPSFBFIR
fir_
;
RTCPUtility
:
:
RTCPPacketPSFBFIRItem
fir_item_
;
}
;
class
Remb
:
public
RtcpPacket
{
public
:
Remb
(
)
:
RtcpPacket
(
)
{
memset
(
&
remb_
0
sizeof
(
remb_
)
)
;
memset
(
&
remb_item_
0
sizeof
(
remb_item_
)
)
;
}
virtual
~
Remb
(
)
{
}
void
From
(
uint32_t
ssrc
)
{
remb_
.
SenderSSRC
=
ssrc
;
}
void
AppliesTo
(
uint32_t
ssrc
)
;
void
WithBitrateBps
(
uint32_t
bitrate_bps
)
{
remb_item_
.
BitRate
=
bitrate_bps
;
}
protected
:
bool
Create
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
RtcpPacket
:
:
PacketReadyCallback
*
callback
)
const
override
;
private
:
static
const
int
kMaxNumberOfSsrcs
=
0xff
;
size_t
BlockLength
(
)
const
override
{
return
(
remb_item_
.
NumberOfSSRCs
+
5
)
*
4
;
}
RTCPUtility
:
:
RTCPPacketPSFBAPP
remb_
;
RTCPUtility
:
:
RTCPPacketPSFBREMBItem
remb_item_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
Remb
)
;
}
;
class
Xr
:
public
RtcpPacket
{
public
:
typedef
std
:
:
vector
<
RTCPUtility
:
:
RTCPPacketXRDLRRReportBlockItem
>
DlrrBlock
;
Xr
(
)
:
RtcpPacket
(
)
{
memset
(
&
xr_header_
0
sizeof
(
xr_header_
)
)
;
}
virtual
~
Xr
(
)
{
}
void
From
(
uint32_t
ssrc
)
{
xr_header_
.
OriginatorSSRC
=
ssrc
;
}
bool
WithRrtr
(
Rrtr
*
rrtr
)
;
bool
WithDlrr
(
Dlrr
*
dlrr
)
;
bool
WithVoipMetric
(
VoipMetric
*
voip_metric
)
;
protected
:
bool
Create
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
RtcpPacket
:
:
PacketReadyCallback
*
callback
)
const
override
;
private
:
static
const
int
kMaxNumberOfRrtrBlocks
=
50
;
static
const
int
kMaxNumberOfDlrrBlocks
=
50
;
static
const
int
kMaxNumberOfVoipMetricBlocks
=
50
;
size_t
BlockLength
(
)
const
override
{
const
size_t
kXrHeaderLength
=
8
;
return
kXrHeaderLength
+
RrtrLength
(
)
+
DlrrLength
(
)
+
VoipMetricLength
(
)
;
}
size_t
RrtrLength
(
)
const
{
return
Rrtr
:
:
kLength
*
rrtr_blocks_
.
size
(
)
;
}
size_t
DlrrLength
(
)
const
;
size_t
VoipMetricLength
(
)
const
{
return
VoipMetric
:
:
kLength
*
voip_metric_blocks_
.
size
(
)
;
}
RTCPUtility
:
:
RTCPPacketXR
xr_header_
;
std
:
:
vector
<
Rrtr
>
rrtr_blocks_
;
std
:
:
vector
<
Dlrr
>
dlrr_blocks_
;
std
:
:
vector
<
VoipMetric
>
voip_metric_blocks_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
Xr
)
;
}
;
class
RawPacket
{
public
:
explicit
RawPacket
(
size_t
buffer_length
)
;
RawPacket
(
const
uint8_t
*
packet
size_t
packet_length
)
;
const
uint8_t
*
Buffer
(
)
const
;
uint8_t
*
MutableBuffer
(
)
;
size_t
BufferLength
(
)
const
;
size_t
Length
(
)
const
;
void
SetLength
(
size_t
length
)
;
private
:
const
size_t
buffer_length_
;
size_t
length_
;
rtc
:
:
scoped_ptr
<
uint8_t
[
]
>
buffer_
;
}
;
}
}
#
endif
