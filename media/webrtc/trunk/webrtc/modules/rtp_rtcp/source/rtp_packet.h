#
ifndef
WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_PACKET_H_
#
define
WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_PACKET_H_
#
include
<
vector
>
#
include
"
webrtc
/
base
/
array_view
.
h
"
#
include
"
webrtc
/
base
/
basictypes
.
h
"
#
include
"
webrtc
/
base
/
copyonwritebuffer
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
namespace
webrtc
{
struct
RTPHeader
;
class
RtpHeaderExtensionMap
;
class
Random
;
namespace
rtp
{
class
Packet
{
public
:
using
ExtensionType
=
RTPExtensionType
;
using
ExtensionManager
=
RtpHeaderExtensionMap
;
static
constexpr
size_t
kMaxExtensionHeaders
=
14
;
bool
Parse
(
const
uint8_t
*
buffer
size_t
size
)
;
bool
Parse
(
rtc
:
:
ArrayView
<
const
uint8_t
>
packet
)
;
bool
Parse
(
rtc
:
:
CopyOnWriteBuffer
packet
)
;
void
IdentifyExtensions
(
const
ExtensionManager
&
extensions
)
;
bool
Marker
(
)
const
;
uint8_t
PayloadType
(
)
const
;
uint16_t
SequenceNumber
(
)
const
;
uint32_t
Timestamp
(
)
const
;
uint32_t
Ssrc
(
)
const
;
std
:
:
vector
<
uint32_t
>
Csrcs
(
)
const
;
void
GetHeader
(
RTPHeader
*
header
)
const
;
size_t
headers_size
(
)
const
;
size_t
payload_size
(
)
const
;
size_t
padding_size
(
)
const
;
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
(
)
const
;
rtc
:
:
CopyOnWriteBuffer
Buffer
(
)
const
;
size_t
capacity
(
)
const
;
size_t
size
(
)
const
;
const
uint8_t
*
data
(
)
const
;
size_t
FreeCapacity
(
)
const
;
size_t
MaxPayloadSize
(
)
const
;
void
Clear
(
)
;
void
CopyHeaderFrom
(
const
Packet
&
packet
)
;
void
SetMarker
(
bool
marker_bit
)
;
void
SetPayloadType
(
uint8_t
payload_type
)
;
void
SetSequenceNumber
(
uint16_t
seq_no
)
;
void
SetTimestamp
(
uint32_t
timestamp
)
;
void
SetSsrc
(
uint32_t
ssrc
)
;
void
SetCsrcs
(
const
std
:
:
vector
<
uint32_t
>
&
csrcs
)
;
template
<
typename
Extension
>
bool
HasExtension
(
)
const
;
template
<
typename
Extension
typename
.
.
.
Values
>
bool
GetExtension
(
Values
.
.
.
)
const
;
template
<
typename
Extension
typename
.
.
.
Values
>
bool
SetExtension
(
Values
.
.
.
)
;
template
<
typename
Extension
>
bool
ReserveExtension
(
)
;
uint8_t
*
AllocatePayload
(
size_t
size_bytes
)
;
void
SetPayloadSize
(
size_t
size_bytes
)
;
bool
SetPadding
(
uint8_t
size_bytes
Random
*
random
)
;
protected
:
Packet
(
)
;
explicit
Packet
(
const
ExtensionManager
*
extensions
)
;
Packet
(
const
Packet
&
)
=
default
;
Packet
(
const
ExtensionManager
*
extensions
size_t
capacity
)
;
virtual
~
Packet
(
)
;
Packet
&
operator
=
(
const
Packet
&
)
=
default
;
private
:
struct
ExtensionInfo
{
ExtensionType
type
;
uint16_t
offset
;
uint8_t
length
;
}
;
bool
ParseBuffer
(
const
uint8_t
*
buffer
size_t
size
)
;
bool
FindExtension
(
ExtensionType
type
uint8_t
length
uint16_t
*
offset
)
const
;
bool
AllocateExtension
(
ExtensionType
type
uint8_t
length
uint16_t
*
offset
)
;
uint8_t
*
WriteAt
(
size_t
offset
)
;
void
WriteAt
(
size_t
offset
uint8_t
byte
)
;
bool
marker_
;
uint8_t
payload_type_
;
uint8_t
padding_size_
;
uint16_t
sequence_number_
;
uint32_t
timestamp_
;
uint32_t
ssrc_
;
size_t
payload_offset_
;
size_t
payload_size_
;
ExtensionInfo
extension_entries_
[
kMaxExtensionHeaders
]
;
uint16_t
extensions_size_
=
0
;
rtc
:
:
CopyOnWriteBuffer
buffer_
;
}
;
template
<
typename
Extension
>
bool
Packet
:
:
HasExtension
(
)
const
{
uint16_t
offset
=
0
;
return
FindExtension
(
Extension
:
:
kId
Extension
:
:
kValueSizeBytes
&
offset
)
;
}
template
<
typename
Extension
typename
.
.
.
Values
>
bool
Packet
:
:
GetExtension
(
Values
.
.
.
values
)
const
{
uint16_t
offset
=
0
;
if
(
!
FindExtension
(
Extension
:
:
kId
Extension
:
:
kValueSizeBytes
&
offset
)
)
return
false
;
return
Extension
:
:
Parse
(
data
(
)
+
offset
values
.
.
.
)
;
}
template
<
typename
Extension
typename
.
.
.
Values
>
bool
Packet
:
:
SetExtension
(
Values
.
.
.
values
)
{
uint16_t
offset
=
0
;
if
(
!
AllocateExtension
(
Extension
:
:
kId
Extension
:
:
kValueSizeBytes
&
offset
)
)
return
false
;
return
Extension
:
:
Write
(
WriteAt
(
offset
)
values
.
.
.
)
;
}
template
<
typename
Extension
>
bool
Packet
:
:
ReserveExtension
(
)
{
uint16_t
offset
=
0
;
if
(
!
AllocateExtension
(
Extension
:
:
kId
Extension
:
:
kValueSizeBytes
&
offset
)
)
return
false
;
memset
(
WriteAt
(
offset
)
0
Extension
:
:
kValueSizeBytes
)
;
return
true
;
}
}
}
#
endif
