#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
extended_jitter_report
.
h
"
#
include
<
utility
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
common_header
.
h
"
namespace
webrtc
{
namespace
rtcp
{
constexpr
uint8_t
ExtendedJitterReport
:
:
kPacketType
;
bool
ExtendedJitterReport
:
:
Parse
(
const
CommonHeader
&
packet
)
{
RTC_DCHECK_EQ
(
packet
.
type
(
)
kPacketType
)
;
const
uint8_t
number_of_jitters
=
packet
.
count
(
)
;
if
(
packet
.
payload_size_bytes
(
)
<
number_of_jitters
*
kJitterSizeBytes
)
{
LOG
(
LS_WARNING
)
<
<
"
Packet
is
too
small
to
contain
all
the
jitter
.
"
;
return
false
;
}
inter_arrival_jitters_
.
resize
(
number_of_jitters
)
;
for
(
size_t
index
=
0
;
index
<
number_of_jitters
;
+
+
index
)
{
inter_arrival_jitters_
[
index
]
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
&
packet
.
payload
(
)
[
index
*
kJitterSizeBytes
]
)
;
}
return
true
;
}
bool
ExtendedJitterReport
:
:
SetJitterValues
(
std
:
:
vector
<
uint32_t
>
values
)
{
if
(
values
.
size
(
)
>
kMaxNumberOfJitterValues
)
{
LOG
(
LS_WARNING
)
<
<
"
Too
many
inter
-
arrival
jitter
items
.
"
;
return
false
;
}
inter_arrival_jitters_
=
std
:
:
move
(
values
)
;
return
true
;
}
bool
ExtendedJitterReport
:
:
Create
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
RtcpPacket
:
:
PacketReadyCallback
*
callback
)
const
{
while
(
*
index
+
BlockLength
(
)
>
max_length
)
{
if
(
!
OnBufferFull
(
packet
index
callback
)
)
return
false
;
}
const
size_t
index_end
=
*
index
+
BlockLength
(
)
;
size_t
length
=
inter_arrival_jitters_
.
size
(
)
;
CreateHeader
(
length
kPacketType
length
packet
index
)
;
for
(
uint32_t
jitter
:
inter_arrival_jitters_
)
{
ByteWriter
<
uint32_t
>
:
:
WriteBigEndian
(
packet
+
*
index
jitter
)
;
*
index
+
=
kJitterSizeBytes
;
}
RTC_DCHECK_EQ
(
index_end
*
index
)
;
return
true
;
}
}
}
