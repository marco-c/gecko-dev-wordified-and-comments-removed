#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
common_header
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
namespace
webrtc
{
namespace
rtcp
{
bool
CommonHeader
:
:
Parse
(
const
uint8_t
*
buffer
size_t
size_bytes
)
{
const
size_t
kHeaderSizeBytes
=
4
;
const
uint8_t
kVersion
=
2
;
if
(
size_bytes
<
kHeaderSizeBytes
)
{
LOG
(
LS_WARNING
)
<
<
"
Too
little
data
(
"
<
<
size_bytes
<
<
"
byte
"
<
<
(
size_bytes
!
=
1
?
"
s
"
:
"
"
)
<
<
"
)
remaining
in
buffer
to
parse
RTCP
header
(
4
bytes
)
.
"
;
return
false
;
}
uint8_t
version
=
buffer
[
0
]
>
>
6
;
if
(
version
!
=
kVersion
)
{
LOG
(
LS_WARNING
)
<
<
"
Invalid
RTCP
header
:
Version
must
be
"
<
<
static_cast
<
int
>
(
kVersion
)
<
<
"
but
was
"
<
<
static_cast
<
int
>
(
version
)
;
return
false
;
}
bool
has_padding
=
(
buffer
[
0
]
&
0x20
)
!
=
0
;
count_or_format_
=
buffer
[
0
]
&
0x1F
;
packet_type_
=
buffer
[
1
]
;
payload_size_
=
ByteReader
<
uint16_t
>
:
:
ReadBigEndian
(
&
buffer
[
2
]
)
*
4
;
payload_
=
buffer
+
kHeaderSizeBytes
;
padding_size_
=
0
;
if
(
size_bytes
<
kHeaderSizeBytes
+
payload_size_
)
{
LOG
(
LS_WARNING
)
<
<
"
Buffer
too
small
(
"
<
<
size_bytes
<
<
"
bytes
)
to
fit
an
RtcpPacket
with
a
header
and
"
<
<
payload_size_
<
<
"
bytes
.
"
;
return
false
;
}
if
(
has_padding
)
{
if
(
payload_size_
=
=
0
)
{
LOG
(
LS_WARNING
)
<
<
"
Invalid
RTCP
header
:
Padding
bit
set
but
0
payload
"
"
size
specified
.
"
;
return
false
;
}
padding_size_
=
payload_
[
payload_size_
-
1
]
;
if
(
padding_size_
=
=
0
)
{
LOG
(
LS_WARNING
)
<
<
"
Invalid
RTCP
header
:
Padding
bit
set
but
0
padding
"
"
size
specified
.
"
;
return
false
;
}
if
(
padding_size_
>
payload_size_
)
{
LOG
(
LS_WARNING
)
<
<
"
Invalid
RTCP
header
:
Too
many
padding
bytes
(
"
<
<
padding_size_
<
<
"
)
for
a
packet
payload
size
of
"
<
<
payload_size_
<
<
"
bytes
.
"
;
return
false
;
}
payload_size_
-
=
padding_size_
;
}
return
true
;
}
}
}
