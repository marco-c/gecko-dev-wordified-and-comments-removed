#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
sli
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
common_header
.
h
"
namespace
webrtc
{
namespace
rtcp
{
constexpr
uint8_t
Sli
:
:
kFeedbackMessageType
;
Sli
:
:
Macroblocks
:
:
Macroblocks
(
uint8_t
picture_id
uint16_t
first
uint16_t
number
)
{
RTC_DCHECK_LE
(
first
0x1fff
)
;
RTC_DCHECK_LE
(
number
0x1fff
)
;
RTC_DCHECK_LE
(
picture_id
0x3f
)
;
item_
=
(
first
<
<
19
)
|
(
number
<
<
6
)
|
picture_id
;
}
void
Sli
:
:
Macroblocks
:
:
Parse
(
const
uint8_t
*
buffer
)
{
item_
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
buffer
)
;
}
void
Sli
:
:
Macroblocks
:
:
Create
(
uint8_t
*
buffer
)
const
{
ByteWriter
<
uint32_t
>
:
:
WriteBigEndian
(
buffer
item_
)
;
}
bool
Sli
:
:
Parse
(
const
CommonHeader
&
packet
)
{
RTC_DCHECK_EQ
(
packet
.
type
(
)
kPacketType
)
;
RTC_DCHECK_EQ
(
packet
.
fmt
(
)
kFeedbackMessageType
)
;
if
(
packet
.
payload_size_bytes
(
)
<
kCommonFeedbackLength
+
Macroblocks
:
:
kLength
)
{
LOG
(
LS_WARNING
)
<
<
"
Packet
is
too
small
to
be
a
valid
SLI
packet
"
;
return
false
;
}
size_t
number_of_items
=
(
packet
.
payload_size_bytes
(
)
-
kCommonFeedbackLength
)
/
Macroblocks
:
:
kLength
;
ParseCommonFeedback
(
packet
.
payload
(
)
)
;
items_
.
resize
(
number_of_items
)
;
const
uint8_t
*
next_item
=
packet
.
payload
(
)
+
kCommonFeedbackLength
;
for
(
Macroblocks
&
item
:
items_
)
{
item
.
Parse
(
next_item
)
;
next_item
+
=
Macroblocks
:
:
kLength
;
}
return
true
;
}
bool
Sli
:
:
Create
(
uint8_t
*
packet
size_t
*
index
size_t
max_length
RtcpPacket
:
:
PacketReadyCallback
*
callback
)
const
{
RTC_DCHECK
(
!
items_
.
empty
(
)
)
;
while
(
*
index
+
BlockLength
(
)
>
max_length
)
{
if
(
!
OnBufferFull
(
packet
index
callback
)
)
return
false
;
}
CreateHeader
(
kFeedbackMessageType
kPacketType
HeaderLength
(
)
packet
index
)
;
CreateCommonFeedback
(
packet
+
*
index
)
;
*
index
+
=
kCommonFeedbackLength
;
for
(
const
Macroblocks
&
item
:
items_
)
{
item
.
Create
(
packet
+
*
index
)
;
*
index
+
=
Macroblocks
:
:
kLength
;
}
return
true
;
}
}
}
