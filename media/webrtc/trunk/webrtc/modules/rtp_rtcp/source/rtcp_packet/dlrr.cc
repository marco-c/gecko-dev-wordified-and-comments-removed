#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtcp_packet
/
dlrr
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
namespace
webrtc
{
namespace
rtcp
{
bool
Dlrr
:
:
Parse
(
const
uint8_t
*
buffer
uint16_t
block_length_32bits
)
{
RTC_DCHECK
(
buffer
[
0
]
=
=
kBlockType
)
;
RTC_DCHECK_EQ
(
block_length_32bits
ByteReader
<
uint16_t
>
:
:
ReadBigEndian
(
&
buffer
[
2
]
)
)
;
if
(
block_length_32bits
%
3
!
=
0
)
{
LOG
(
LS_WARNING
)
<
<
"
Invalid
size
for
dlrr
block
.
"
;
return
false
;
}
size_t
blocks_count
=
block_length_32bits
/
3
;
const
uint8_t
*
read_at
=
buffer
+
kBlockHeaderLength
;
sub_blocks_
.
resize
(
blocks_count
)
;
for
(
SubBlock
&
sub_block
:
sub_blocks_
)
{
sub_block
.
ssrc
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
&
read_at
[
0
]
)
;
sub_block
.
last_rr
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
&
read_at
[
4
]
)
;
sub_block
.
delay_since_last_rr
=
ByteReader
<
uint32_t
>
:
:
ReadBigEndian
(
&
read_at
[
8
]
)
;
read_at
+
=
kSubBlockLength
;
}
return
true
;
}
size_t
Dlrr
:
:
BlockLength
(
)
const
{
if
(
sub_blocks_
.
empty
(
)
)
return
0
;
return
kBlockHeaderLength
+
kSubBlockLength
*
sub_blocks_
.
size
(
)
;
}
void
Dlrr
:
:
Create
(
uint8_t
*
buffer
)
const
{
if
(
sub_blocks_
.
empty
(
)
)
return
;
const
uint8_t
kReserved
=
0
;
buffer
[
0
]
=
kBlockType
;
buffer
[
1
]
=
kReserved
;
ByteWriter
<
uint16_t
>
:
:
WriteBigEndian
(
&
buffer
[
2
]
3
*
sub_blocks_
.
size
(
)
)
;
uint8_t
*
write_at
=
buffer
+
kBlockHeaderLength
;
for
(
const
SubBlock
&
sub_block
:
sub_blocks_
)
{
ByteWriter
<
uint32_t
>
:
:
WriteBigEndian
(
&
write_at
[
0
]
sub_block
.
ssrc
)
;
ByteWriter
<
uint32_t
>
:
:
WriteBigEndian
(
&
write_at
[
4
]
sub_block
.
last_rr
)
;
ByteWriter
<
uint32_t
>
:
:
WriteBigEndian
(
&
write_at
[
8
]
sub_block
.
delay_since_last_rr
)
;
write_at
+
=
kSubBlockLength
;
}
RTC_DCHECK_EQ
(
buffer
+
BlockLength
(
)
write_at
)
;
}
bool
Dlrr
:
:
WithDlrrItem
(
uint32_t
ssrc
uint32_t
last_rr
uint32_t
delay_last_rr
)
{
if
(
sub_blocks_
.
size
(
)
>
=
kMaxNumberOfDlrrItems
)
{
LOG
(
LS_WARNING
)
<
<
"
Max
DLRR
items
reached
.
"
;
return
false
;
}
SubBlock
block
;
block
.
ssrc
=
ssrc
;
block
.
last_rr
=
last_rr
;
block
.
delay_since_last_rr
=
delay_last_rr
;
sub_blocks_
.
push_back
(
block
)
;
return
true
;
}
}
}
