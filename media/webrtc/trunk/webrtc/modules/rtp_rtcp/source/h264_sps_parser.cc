#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
h264_sps_parser
.
h
"
#
include
"
webrtc
/
base
/
bitbuffer
.
h
"
#
include
"
webrtc
/
base
/
bytebuffer
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
define
RETURN_FALSE_ON_FAIL
(
x
)
\
if
(
!
(
x
)
)
{
\
return
false
;
\
}
namespace
webrtc
{
H264SpsParser
:
:
H264SpsParser
(
const
uint8_t
*
sps
size_t
byte_length
)
:
sps_
(
sps
)
byte_length_
(
byte_length
)
width_
(
)
height_
(
)
{
}
bool
H264SpsParser
:
:
Parse
(
)
{
const
char
*
sps_bytes
=
reinterpret_cast
<
const
char
*
>
(
sps_
)
;
rtc
:
:
ByteBuffer
rbsp_buffer
;
for
(
size_t
i
=
0
;
i
<
byte_length_
;
)
{
if
(
byte_length_
-
i
>
=
3
&
&
sps_
[
i
]
=
=
0
&
&
sps_
[
i
+
1
]
=
=
0
&
&
sps_
[
i
+
2
]
=
=
3
)
{
rbsp_buffer
.
WriteBytes
(
sps_bytes
+
i
2
)
;
i
+
=
3
;
}
else
{
rbsp_buffer
.
WriteBytes
(
sps_bytes
+
i
1
)
;
i
+
+
;
}
}
rtc
:
:
BitBuffer
parser
(
reinterpret_cast
<
const
uint8_t
*
>
(
rbsp_buffer
.
Data
(
)
)
rbsp_buffer
.
Length
(
)
)
;
uint32_t
golomb_ignored
;
uint32_t
separate_colour_plane_flag
=
0
;
uint32_t
chroma_format_idc
=
1
;
uint8_t
profile_idc
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadUInt8
(
&
profile_idc
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ConsumeBytes
(
1
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ConsumeBytes
(
1
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
if
(
profile_idc
=
=
100
|
|
profile_idc
=
=
110
|
|
profile_idc
=
=
122
|
|
profile_idc
=
=
244
|
|
profile_idc
=
=
44
|
|
profile_idc
=
=
83
|
|
profile_idc
=
=
86
|
|
profile_idc
=
=
118
|
|
profile_idc
=
=
128
|
|
profile_idc
=
=
138
|
|
profile_idc
=
=
139
|
|
profile_idc
=
=
134
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
chroma_format_idc
)
)
;
if
(
chroma_format_idc
=
=
3
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
separate_colour_plane_flag
1
)
)
;
}
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ConsumeBits
(
1
)
)
;
uint32_t
seq_scaling_matrix_present_flag
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
seq_scaling_matrix_present_flag
1
)
)
;
if
(
seq_scaling_matrix_present_flag
)
{
uint32_t
seq_scaling_list_present_flags
;
if
(
chroma_format_idc
!
=
3
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
seq_scaling_list_present_flags
8
)
)
;
}
else
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
seq_scaling_list_present_flags
12
)
)
;
}
if
(
seq_scaling_list_present_flags
>
0
)
{
LOG
(
LS_WARNING
)
<
<
"
SPS
contains
scaling
lists
which
are
unsupported
.
"
;
return
false
;
}
}
}
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
uint32_t
pic_order_cnt_type
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
pic_order_cnt_type
)
)
;
if
(
pic_order_cnt_type
=
=
0
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
}
else
if
(
pic_order_cnt_type
=
=
1
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ConsumeBits
(
1
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
uint32_t
num_ref_frames_in_pic_order_cnt_cycle
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
num_ref_frames_in_pic_order_cnt_cycle
)
)
;
for
(
size_t
i
=
0
;
i
<
num_ref_frames_in_pic_order_cnt_cycle
;
+
+
i
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
}
}
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
golomb_ignored
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ConsumeBits
(
1
)
)
;
uint32_t
pic_width_in_mbs_minus1
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
pic_width_in_mbs_minus1
)
)
;
uint32_t
pic_height_in_map_units_minus1
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
pic_height_in_map_units_minus1
)
)
;
uint32_t
frame_mbs_only_flag
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
frame_mbs_only_flag
1
)
)
;
if
(
!
frame_mbs_only_flag
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ConsumeBits
(
1
)
)
;
}
RETURN_FALSE_ON_FAIL
(
parser
.
ConsumeBits
(
1
)
)
;
uint32_t
frame_cropping_flag
;
uint32_t
frame_crop_left_offset
=
0
;
uint32_t
frame_crop_right_offset
=
0
;
uint32_t
frame_crop_top_offset
=
0
;
uint32_t
frame_crop_bottom_offset
=
0
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadBits
(
&
frame_cropping_flag
1
)
)
;
if
(
frame_cropping_flag
)
{
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
frame_crop_left_offset
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
frame_crop_right_offset
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
frame_crop_top_offset
)
)
;
RETURN_FALSE_ON_FAIL
(
parser
.
ReadExponentialGolomb
(
&
frame_crop_bottom_offset
)
)
;
}
int
width
=
16
*
(
pic_width_in_mbs_minus1
+
1
)
;
int
height
=
16
*
(
2
-
frame_mbs_only_flag
)
*
(
pic_height_in_map_units_minus1
+
1
)
;
if
(
separate_colour_plane_flag
|
|
chroma_format_idc
=
=
0
)
{
frame_crop_bottom_offset
*
=
(
2
-
frame_mbs_only_flag
)
;
frame_crop_top_offset
*
=
(
2
-
frame_mbs_only_flag
)
;
}
else
if
(
!
separate_colour_plane_flag
&
&
chroma_format_idc
>
0
)
{
if
(
chroma_format_idc
=
=
1
|
|
chroma_format_idc
=
=
2
)
{
frame_crop_left_offset
*
=
2
;
frame_crop_right_offset
*
=
2
;
}
if
(
chroma_format_idc
=
=
1
)
{
frame_crop_top_offset
*
=
2
;
frame_crop_bottom_offset
*
=
2
;
}
}
width
-
=
(
frame_crop_left_offset
+
frame_crop_right_offset
)
;
height
-
=
(
frame_crop_top_offset
+
frame_crop_bottom_offset
)
;
width_
=
width
;
height_
=
height
;
return
true
;
}
}
