#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
flexfec_receiver
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
scoped_ref_ptr
.
h
"
namespace
webrtc
{
namespace
{
using
Packet
=
ForwardErrorCorrection
:
:
Packet
;
using
ReceivedPacket
=
ForwardErrorCorrection
:
:
ReceivedPacket
;
constexpr
size_t
kMinFlexfecHeaderSize
=
20
;
constexpr
int
kPacketLogIntervalMs
=
10000
;
}
FlexfecReceiver
:
:
FlexfecReceiver
(
uint32_t
ssrc
uint32_t
protected_media_ssrc
RecoveredPacketReceiver
*
recovered_packet_receiver
)
:
ssrc_
(
ssrc
)
protected_media_ssrc_
(
protected_media_ssrc
)
erasure_code_
(
ForwardErrorCorrection
:
:
CreateFlexfec
(
)
)
recovered_packet_receiver_
(
recovered_packet_receiver
)
clock_
(
Clock
:
:
GetRealTimeClock
(
)
)
last_recovered_packet_ms_
(
-
1
)
{
sequence_checker_
.
Detach
(
)
;
}
FlexfecReceiver
:
:
~
FlexfecReceiver
(
)
=
default
;
bool
FlexfecReceiver
:
:
AddAndProcessReceivedPacket
(
const
RtpPacketReceived
&
packet
)
{
RTC_DCHECK_CALLED_SEQUENTIALLY
(
&
sequence_checker_
)
;
if
(
!
AddReceivedPacket
(
std
:
:
move
(
packet
)
)
)
{
return
false
;
}
return
ProcessReceivedPackets
(
)
;
}
FecPacketCounter
FlexfecReceiver
:
:
GetPacketCounter
(
)
const
{
RTC_DCHECK_CALLED_SEQUENTIALLY
(
&
sequence_checker_
)
;
return
packet_counter_
;
}
bool
FlexfecReceiver
:
:
AddReceivedPacket
(
const
RtpPacketReceived
&
packet
)
{
RTC_DCHECK_CALLED_SEQUENTIALLY
(
&
sequence_checker_
)
;
RTC_DCHECK_GE
(
packet
.
size
(
)
kRtpHeaderSize
)
;
std
:
:
unique_ptr
<
ReceivedPacket
>
received_packet
(
new
ReceivedPacket
(
)
)
;
received_packet
-
>
seq_num
=
packet
.
SequenceNumber
(
)
;
received_packet
-
>
ssrc
=
packet
.
Ssrc
(
)
;
if
(
received_packet
-
>
ssrc
=
=
ssrc_
)
{
if
(
packet
.
payload_size
(
)
<
kMinFlexfecHeaderSize
)
{
LOG
(
LS_WARNING
)
<
<
"
Truncated
FlexFEC
packet
discarding
.
"
;
return
false
;
}
received_packet
-
>
is_fec
=
true
;
+
+
packet_counter_
.
num_fec_packets
;
received_packet
-
>
pkt
=
rtc
:
:
scoped_refptr
<
Packet
>
(
new
Packet
(
)
)
;
auto
payload
=
packet
.
payload
(
)
;
memcpy
(
received_packet
-
>
pkt
-
>
data
payload
.
data
(
)
payload
.
size
(
)
)
;
received_packet
-
>
pkt
-
>
length
=
payload
.
size
(
)
;
}
else
{
if
(
received_packet
-
>
ssrc
!
=
protected_media_ssrc_
)
{
return
false
;
}
received_packet
-
>
is_fec
=
false
;
received_packet
-
>
pkt
=
rtc
:
:
scoped_refptr
<
Packet
>
(
new
Packet
(
)
)
;
memcpy
(
received_packet
-
>
pkt
-
>
data
packet
.
data
(
)
packet
.
size
(
)
)
;
received_packet
-
>
pkt
-
>
length
=
packet
.
size
(
)
;
}
received_packets_
.
push_back
(
std
:
:
move
(
received_packet
)
)
;
+
+
packet_counter_
.
num_packets
;
return
true
;
}
bool
FlexfecReceiver
:
:
ProcessReceivedPackets
(
)
{
RTC_DCHECK_CALLED_SEQUENTIALLY
(
&
sequence_checker_
)
;
if
(
!
received_packets_
.
empty
(
)
)
{
if
(
erasure_code_
-
>
DecodeFec
(
&
received_packets_
&
recovered_packets_
)
!
=
0
)
{
return
false
;
}
}
for
(
const
auto
&
recovered_packet
:
recovered_packets_
)
{
if
(
recovered_packet
-
>
returned
)
{
continue
;
}
+
+
packet_counter_
.
num_recovered_packets
;
if
(
!
recovered_packet_receiver_
-
>
OnRecoveredPacket
(
recovered_packet
-
>
pkt
-
>
data
recovered_packet
-
>
pkt
-
>
length
)
)
{
return
false
;
}
recovered_packet
-
>
returned
=
true
;
int64_t
now_ms
=
clock_
-
>
TimeInMilliseconds
(
)
;
if
(
now_ms
-
last_recovered_packet_ms_
>
kPacketLogIntervalMs
)
{
uint32_t
media_ssrc
=
ForwardErrorCorrection
:
:
ParseSsrc
(
recovered_packet
-
>
pkt
-
>
data
)
;
LOG
(
LS_VERBOSE
)
<
<
"
Recovered
media
packet
with
SSRC
:
"
<
<
media_ssrc
<
<
"
from
FlexFEC
stream
with
SSRC
:
"
<
<
ssrc_
<
<
"
.
"
;
last_recovered_packet_ms_
=
now_ms
;
}
}
return
true
;
}
}
