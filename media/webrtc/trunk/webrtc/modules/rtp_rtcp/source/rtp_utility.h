#
ifndef
MODULES_RTP_RTCP_SOURCE_RTP_UTILITY_H_
#
define
MODULES_RTP_RTCP_SOURCE_RTP_UTILITY_H_
#
include
<
cstring
>
#
include
<
map
>
#
include
"
modules
/
rtp_rtcp
/
include
/
receive_statistics
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_header_extension_map
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_rtcp_config
.
h
"
#
include
"
rtc_base
/
deprecation
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
const
uint8_t
kRtpMarkerBitMask
=
0x80
;
RtpFeedback
*
NullObjectRtpFeedback
(
)
;
namespace
RtpUtility
{
struct
Payload
{
Payload
(
const
char
*
name
const
PayloadUnion
&
pu
)
:
typeSpecific
(
pu
)
{
std
:
:
strncpy
(
this
-
>
name
name
sizeof
(
this
-
>
name
)
-
1
)
;
this
-
>
name
[
sizeof
(
this
-
>
name
)
-
1
]
=
'
\
0
'
;
}
char
name
[
RTP_PAYLOAD_NAME_SIZE
]
;
PayloadUnion
typeSpecific
;
}
;
bool
StringCompare
(
const
char
*
str1
const
char
*
str2
const
uint32_t
length
)
;
size_t
Word32Align
(
size_t
size
)
;
class
RtpHeaderParser
{
public
:
RtpHeaderParser
(
const
uint8_t
*
rtpData
size_t
rtpDataLength
)
;
~
RtpHeaderParser
(
)
;
bool
RTCP
(
)
const
;
bool
ParseRtcp
(
RTPHeader
*
header
)
const
;
bool
Parse
(
RTPHeader
*
parsedPacket
RtpHeaderExtensionMap
*
ptrExtensionMap
=
nullptr
bool
secured
=
false
)
const
;
private
:
void
ParseOneByteExtensionHeader
(
RTPHeader
*
parsedPacket
const
RtpHeaderExtensionMap
*
ptrExtensionMap
const
uint8_t
*
ptrRTPDataExtensionEnd
const
uint8_t
*
ptr
)
const
;
const
uint8_t
*
const
_ptrRTPDataBegin
;
const
uint8_t
*
const
_ptrRTPDataEnd
;
}
;
}
}
#
endif
