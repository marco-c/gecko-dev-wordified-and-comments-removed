#
ifndef
WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_UTILITY_H_
#
define
WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_UTILITY_H_
#
include
<
map
>
#
include
"
webrtc
/
base
/
deprecation
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
receive_statistics
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtp_header_extension
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtp_rtcp_config
.
h
"
#
include
"
webrtc
/
typedefs
.
h
"
namespace
webrtc
{
const
uint8_t
kRtpMarkerBitMask
=
0x80
;
RtpData
*
NullObjectRtpData
(
)
;
RtpFeedback
*
NullObjectRtpFeedback
(
)
;
RtpAudioFeedback
*
NullObjectRtpAudioFeedback
(
)
;
ReceiveStatistics
*
NullObjectReceiveStatistics
(
)
;
namespace
RtpUtility
{
struct
Payload
{
char
name
[
RTP_PAYLOAD_NAME_SIZE
]
;
bool
audio
;
PayloadUnion
typeSpecific
;
}
;
typedef
std
:
:
map
<
int8_t
Payload
*
>
PayloadTypeMap
;
bool
StringCompare
(
const
char
*
str1
const
char
*
str2
const
uint32_t
length
)
;
size_t
Word32Align
(
size_t
size
)
;
class
RtpHeaderParser
{
public
:
RtpHeaderParser
(
const
uint8_t
*
rtpData
size_t
rtpDataLength
)
;
~
RtpHeaderParser
(
)
;
bool
RTCP
(
)
const
;
bool
ParseRtcp
(
RTPHeader
*
header
)
const
;
bool
Parse
(
RTPHeader
*
parsedPacket
RtpHeaderExtensionMap
*
ptrExtensionMap
=
nullptr
)
const
;
RTC_DEPRECATED
bool
Parse
(
RTPHeader
&
parsedPacket
RtpHeaderExtensionMap
*
ptrExtensionMap
=
nullptr
)
const
{
return
Parse
(
&
parsedPacket
ptrExtensionMap
)
;
}
private
:
void
ParseOneByteExtensionHeader
(
RTPHeader
*
parsedPacket
const
RtpHeaderExtensionMap
*
ptrExtensionMap
const
uint8_t
*
ptrRTPDataExtensionEnd
const
uint8_t
*
ptr
)
const
;
uint8_t
ParsePaddingBytes
(
const
uint8_t
*
ptrRTPDataExtensionEnd
const
uint8_t
*
ptr
)
const
;
const
uint8_t
*
const
_ptrRTPDataBegin
;
const
uint8_t
*
const
_ptrRTPDataEnd
;
}
;
}
}
#
endif
