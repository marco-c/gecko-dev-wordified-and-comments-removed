package
org
.
webrtc
.
voiceengine
;
import
android
.
annotation
.
TargetApi
;
import
android
.
content
.
Context
;
import
android
.
media
.
AudioFormat
;
import
android
.
media
.
AudioRecord
;
import
android
.
media
.
MediaRecorder
.
AudioSource
;
import
android
.
os
.
Process
;
import
java
.
lang
.
System
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
org
.
webrtc
.
ContextUtils
;
import
org
.
webrtc
.
Logging
;
import
org
.
webrtc
.
ThreadUtils
;
public
class
WebRtcAudioRecord
{
private
static
final
boolean
DEBUG
=
false
;
private
static
final
String
TAG
=
"
WebRtcAudioRecord
"
;
private
static
final
int
BITS_PER_SAMPLE
=
16
;
private
static
final
int
CALLBACK_BUFFER_SIZE_MS
=
10
;
private
static
final
int
BUFFERS_PER_SECOND
=
1000
/
CALLBACK_BUFFER_SIZE_MS
;
private
static
final
int
BUFFER_SIZE_FACTOR
=
2
;
private
static
final
long
AUDIO_RECORD_THREAD_JOIN_TIMEOUT_MS
=
2000
;
private
static
final
int
DEFAULT_AUDIO_SOURCE
=
getDefaultAudioSource
(
)
;
private
static
int
audioSource
=
DEFAULT_AUDIO_SOURCE
;
private
final
long
nativeAudioRecord
;
private
WebRtcAudioEffects
effects
=
null
;
private
ByteBuffer
byteBuffer
;
private
AudioRecord
audioRecord
=
null
;
private
AudioRecordThread
audioThread
=
null
;
private
static
volatile
boolean
microphoneMute
=
false
;
private
byte
[
]
emptyBytes
;
public
enum
AudioRecordStartErrorCode
{
AUDIO_RECORD_START_EXCEPTION
AUDIO_RECORD_START_STATE_MISMATCH
}
public
static
interface
WebRtcAudioRecordErrorCallback
{
void
onWebRtcAudioRecordInitError
(
String
errorMessage
)
;
void
onWebRtcAudioRecordStartError
(
AudioRecordStartErrorCode
errorCode
String
errorMessage
)
;
void
onWebRtcAudioRecordError
(
String
errorMessage
)
;
}
private
static
WebRtcAudioRecordErrorCallback
errorCallback
=
null
;
public
static
void
setErrorCallback
(
WebRtcAudioRecordErrorCallback
errorCallback
)
{
Logging
.
d
(
TAG
"
Set
error
callback
"
)
;
WebRtcAudioRecord
.
errorCallback
=
errorCallback
;
}
private
class
AudioRecordThread
extends
Thread
{
private
volatile
boolean
keepAlive
=
true
;
public
AudioRecordThread
(
String
name
)
{
super
(
name
)
;
}
Override
public
void
run
(
)
{
Process
.
setThreadPriority
(
Process
.
THREAD_PRIORITY_URGENT_AUDIO
)
;
Logging
.
d
(
TAG
"
AudioRecordThread
"
+
WebRtcAudioUtils
.
getThreadInfo
(
)
)
;
assertTrue
(
audioRecord
.
getRecordingState
(
)
=
=
AudioRecord
.
RECORDSTATE_RECORDING
)
;
long
lastTime
=
System
.
nanoTime
(
)
;
while
(
keepAlive
)
{
int
bytesRead
=
audioRecord
.
read
(
byteBuffer
byteBuffer
.
capacity
(
)
)
;
if
(
bytesRead
=
=
byteBuffer
.
capacity
(
)
)
{
if
(
microphoneMute
)
{
byteBuffer
.
clear
(
)
;
byteBuffer
.
put
(
emptyBytes
)
;
}
nativeDataIsRecorded
(
bytesRead
nativeAudioRecord
)
;
}
else
{
String
errorMessage
=
"
AudioRecord
.
read
failed
:
"
+
bytesRead
;
Logging
.
e
(
TAG
errorMessage
)
;
if
(
bytesRead
=
=
AudioRecord
.
ERROR_INVALID_OPERATION
)
{
keepAlive
=
false
;
reportWebRtcAudioRecordError
(
errorMessage
)
;
}
}
if
(
DEBUG
)
{
long
nowTime
=
System
.
nanoTime
(
)
;
long
durationInMs
=
TimeUnit
.
NANOSECONDS
.
toMillis
(
(
nowTime
-
lastTime
)
)
;
lastTime
=
nowTime
;
Logging
.
d
(
TAG
"
bytesRead
[
"
+
durationInMs
+
"
]
"
+
bytesRead
)
;
}
}
try
{
if
(
audioRecord
!
=
null
)
{
audioRecord
.
stop
(
)
;
}
}
catch
(
IllegalStateException
e
)
{
Logging
.
e
(
TAG
"
AudioRecord
.
stop
failed
:
"
+
e
.
getMessage
(
)
)
;
}
}
public
void
stopThread
(
)
{
Logging
.
d
(
TAG
"
stopThread
"
)
;
keepAlive
=
false
;
}
}
WebRtcAudioRecord
(
long
nativeAudioRecord
)
{
Logging
.
d
(
TAG
"
ctor
"
+
WebRtcAudioUtils
.
getThreadInfo
(
)
)
;
this
.
nativeAudioRecord
=
nativeAudioRecord
;
if
(
DEBUG
)
{
WebRtcAudioUtils
.
logDeviceInfo
(
TAG
)
;
}
effects
=
WebRtcAudioEffects
.
create
(
)
;
}
private
boolean
enableBuiltInAEC
(
boolean
enable
)
{
Logging
.
d
(
TAG
"
enableBuiltInAEC
(
"
+
enable
+
'
)
'
)
;
if
(
effects
=
=
null
)
{
Logging
.
e
(
TAG
"
Built
-
in
AEC
is
not
supported
on
this
platform
"
)
;
return
false
;
}
return
effects
.
setAEC
(
enable
)
;
}
private
boolean
enableBuiltInNS
(
boolean
enable
)
{
Logging
.
d
(
TAG
"
enableBuiltInNS
(
"
+
enable
+
'
)
'
)
;
if
(
effects
=
=
null
)
{
Logging
.
e
(
TAG
"
Built
-
in
NS
is
not
supported
on
this
platform
"
)
;
return
false
;
}
return
effects
.
setNS
(
enable
)
;
}
private
int
initRecording
(
int
sampleRate
int
channels
)
{
Logging
.
d
(
TAG
"
initRecording
(
sampleRate
=
"
+
sampleRate
+
"
channels
=
"
+
channels
+
"
)
"
)
;
if
(
audioRecord
!
=
null
)
{
reportWebRtcAudioRecordInitError
(
"
InitRecording
called
twice
without
StopRecording
.
"
)
;
return
-
1
;
}
final
int
bytesPerFrame
=
channels
*
(
BITS_PER_SAMPLE
/
8
)
;
final
int
framesPerBuffer
=
sampleRate
/
BUFFERS_PER_SECOND
;
byteBuffer
=
ByteBuffer
.
allocateDirect
(
bytesPerFrame
*
framesPerBuffer
)
;
Logging
.
d
(
TAG
"
byteBuffer
.
capacity
:
"
+
byteBuffer
.
capacity
(
)
)
;
emptyBytes
=
new
byte
[
byteBuffer
.
capacity
(
)
]
;
nativeCacheDirectBufferAddress
(
byteBuffer
nativeAudioRecord
)
;
final
int
channelConfig
=
channelCountToConfiguration
(
channels
)
;
int
minBufferSize
=
AudioRecord
.
getMinBufferSize
(
sampleRate
channelConfig
AudioFormat
.
ENCODING_PCM_16BIT
)
;
if
(
minBufferSize
=
=
AudioRecord
.
ERROR
|
|
minBufferSize
=
=
AudioRecord
.
ERROR_BAD_VALUE
)
{
reportWebRtcAudioRecordInitError
(
"
AudioRecord
.
getMinBufferSize
failed
:
"
+
minBufferSize
)
;
return
-
1
;
}
Logging
.
d
(
TAG
"
AudioRecord
.
getMinBufferSize
:
"
+
minBufferSize
)
;
int
bufferSizeInBytes
=
Math
.
max
(
BUFFER_SIZE_FACTOR
*
minBufferSize
byteBuffer
.
capacity
(
)
)
;
Logging
.
d
(
TAG
"
bufferSizeInBytes
:
"
+
bufferSizeInBytes
)
;
try
{
audioRecord
=
new
AudioRecord
(
audioSource
sampleRate
channelConfig
AudioFormat
.
ENCODING_PCM_16BIT
bufferSizeInBytes
)
;
}
catch
(
IllegalArgumentException
e
)
{
reportWebRtcAudioRecordInitError
(
"
AudioRecord
ctor
error
:
"
+
e
.
getMessage
(
)
)
;
releaseAudioResources
(
)
;
return
-
1
;
}
if
(
audioRecord
=
=
null
|
|
audioRecord
.
getState
(
)
!
=
AudioRecord
.
STATE_INITIALIZED
)
{
reportWebRtcAudioRecordInitError
(
"
Failed
to
create
a
new
AudioRecord
instance
"
)
;
releaseAudioResources
(
)
;
return
-
1
;
}
if
(
effects
!
=
null
)
{
effects
.
enable
(
audioRecord
.
getAudioSessionId
(
)
)
;
}
logMainParameters
(
)
;
logMainParametersExtended
(
)
;
return
framesPerBuffer
;
}
private
boolean
startRecording
(
)
{
Logging
.
d
(
TAG
"
startRecording
"
)
;
assertTrue
(
audioRecord
!
=
null
)
;
assertTrue
(
audioThread
=
=
null
)
;
try
{
audioRecord
.
startRecording
(
)
;
}
catch
(
IllegalStateException
e
)
{
reportWebRtcAudioRecordStartError
(
AudioRecordStartErrorCode
.
AUDIO_RECORD_START_EXCEPTION
"
AudioRecord
.
startRecording
failed
:
"
+
e
.
getMessage
(
)
)
;
return
false
;
}
if
(
audioRecord
.
getRecordingState
(
)
!
=
AudioRecord
.
RECORDSTATE_RECORDING
)
{
reportWebRtcAudioRecordStartError
(
AudioRecordStartErrorCode
.
AUDIO_RECORD_START_STATE_MISMATCH
"
AudioRecord
.
startRecording
failed
-
incorrect
state
:
"
+
audioRecord
.
getRecordingState
(
)
)
;
return
false
;
}
audioThread
=
new
AudioRecordThread
(
"
AudioRecordJavaThread
"
)
;
audioThread
.
start
(
)
;
return
true
;
}
private
boolean
stopRecording
(
)
{
Logging
.
d
(
TAG
"
stopRecording
"
)
;
assertTrue
(
audioThread
!
=
null
)
;
audioThread
.
stopThread
(
)
;
if
(
!
ThreadUtils
.
joinUninterruptibly
(
audioThread
AUDIO_RECORD_THREAD_JOIN_TIMEOUT_MS
)
)
{
Logging
.
e
(
TAG
"
Join
of
AudioRecordJavaThread
timed
out
"
)
;
}
audioThread
=
null
;
if
(
effects
!
=
null
)
{
effects
.
release
(
)
;
}
releaseAudioResources
(
)
;
return
true
;
}
private
void
logMainParameters
(
)
{
Logging
.
d
(
TAG
"
AudioRecord
:
"
+
"
session
ID
:
"
+
audioRecord
.
getAudioSessionId
(
)
+
"
"
+
"
channels
:
"
+
audioRecord
.
getChannelCount
(
)
+
"
"
+
"
sample
rate
:
"
+
audioRecord
.
getSampleRate
(
)
)
;
}
TargetApi
(
23
)
private
void
logMainParametersExtended
(
)
{
if
(
WebRtcAudioUtils
.
runningOnMarshmallowOrHigher
(
)
)
{
Logging
.
d
(
TAG
"
AudioRecord
:
"
+
"
buffer
size
in
frames
:
"
+
audioRecord
.
getBufferSizeInFrames
(
)
)
;
}
}
private
static
void
assertTrue
(
boolean
condition
)
{
if
(
!
condition
)
{
throw
new
AssertionError
(
"
Expected
condition
to
be
true
"
)
;
}
}
private
int
channelCountToConfiguration
(
int
channels
)
{
return
(
channels
=
=
1
?
AudioFormat
.
CHANNEL_IN_MONO
:
AudioFormat
.
CHANNEL_IN_STEREO
)
;
}
private
native
void
nativeCacheDirectBufferAddress
(
ByteBuffer
byteBuffer
long
nativeAudioRecord
)
;
private
native
void
nativeDataIsRecorded
(
int
bytes
long
nativeAudioRecord
)
;
SuppressWarnings
(
"
NoSynchronizedMethodCheck
"
)
public
static
synchronized
void
setAudioSource
(
int
source
)
{
Logging
.
w
(
TAG
"
Audio
source
is
changed
from
:
"
+
audioSource
+
"
to
"
+
source
)
;
audioSource
=
source
;
}
private
static
int
getDefaultAudioSource
(
)
{
return
AudioSource
.
VOICE_COMMUNICATION
;
}
public
static
void
setMicrophoneMute
(
boolean
mute
)
{
Logging
.
w
(
TAG
"
setMicrophoneMute
(
"
+
mute
+
"
)
"
)
;
microphoneMute
=
mute
;
}
private
void
releaseAudioResources
(
)
{
if
(
audioRecord
!
=
null
)
{
audioRecord
.
release
(
)
;
audioRecord
=
null
;
}
}
private
void
reportWebRtcAudioRecordInitError
(
String
errorMessage
)
{
Logging
.
e
(
TAG
"
Init
recording
error
:
"
+
errorMessage
)
;
if
(
errorCallback
!
=
null
)
{
errorCallback
.
onWebRtcAudioRecordInitError
(
errorMessage
)
;
}
}
private
void
reportWebRtcAudioRecordStartError
(
AudioRecordStartErrorCode
errorCode
String
errorMessage
)
{
Logging
.
e
(
TAG
"
Start
recording
error
:
"
+
errorCode
+
"
.
"
+
errorMessage
)
;
if
(
errorCallback
!
=
null
)
{
errorCallback
.
onWebRtcAudioRecordStartError
(
errorCode
errorMessage
)
;
}
}
private
void
reportWebRtcAudioRecordError
(
String
errorMessage
)
{
Logging
.
e
(
TAG
"
Run
-
time
recording
error
:
"
+
errorMessage
)
;
if
(
errorCallback
!
=
null
)
{
errorCallback
.
onWebRtcAudioRecordError
(
errorMessage
)
;
}
}
}
