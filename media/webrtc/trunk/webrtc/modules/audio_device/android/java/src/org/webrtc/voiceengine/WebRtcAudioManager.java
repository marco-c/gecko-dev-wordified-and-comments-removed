package
org
.
webrtc
.
voiceengine
;
import
org
.
webrtc
.
ThreadUtils
;
import
android
.
util
.
Log
;
import
android
.
annotation
.
TargetApi
;
import
android
.
content
.
Context
;
import
android
.
content
.
pm
.
PackageManager
;
import
android
.
media
.
AudioFormat
;
import
android
.
media
.
AudioManager
;
import
android
.
media
.
AudioRecord
;
import
android
.
media
.
AudioTrack
;
import
android
.
os
.
Build
;
import
java
.
util
.
Timer
;
import
java
.
util
.
TimerTask
;
import
org
.
mozilla
.
gecko
.
annotation
.
WebRTCJNITarget
;
WebRTCJNITarget
public
class
WebRtcAudioManager
{
private
static
final
boolean
DEBUG
=
false
;
private
static
final
String
TAG
=
"
WebRtcAudioManager
"
;
private
static
boolean
useStereoOutput
=
false
;
private
static
boolean
useStereoInput
=
false
;
private
static
boolean
blacklistDeviceForOpenSLESUsage
=
false
;
private
static
boolean
blacklistDeviceForOpenSLESUsageIsOverridden
=
false
;
public
static
synchronized
void
setBlacklistDeviceForOpenSLESUsage
(
boolean
enable
)
{
blacklistDeviceForOpenSLESUsageIsOverridden
=
true
;
blacklistDeviceForOpenSLESUsage
=
enable
;
}
public
static
synchronized
void
setStereoOutput
(
boolean
enable
)
{
Log
.
w
(
TAG
"
Overriding
default
output
behavior
:
setStereoOutput
(
"
+
enable
+
'
)
'
)
;
useStereoOutput
=
enable
;
}
public
static
synchronized
void
setStereoInput
(
boolean
enable
)
{
Log
.
w
(
TAG
"
Overriding
default
input
behavior
:
setStereoInput
(
"
+
enable
+
'
)
'
)
;
useStereoInput
=
enable
;
}
public
static
synchronized
boolean
getStereoOutput
(
)
{
return
useStereoOutput
;
}
public
static
synchronized
boolean
getStereoInput
(
)
{
return
useStereoInput
;
}
private
static
final
int
BITS_PER_SAMPLE
=
16
;
private
static
final
int
DEFAULT_FRAME_PER_BUFFER
=
256
;
private
static
final
String
[
]
AUDIO_MODES
=
new
String
[
]
{
"
MODE_NORMAL
"
"
MODE_RINGTONE
"
"
MODE_IN_CALL
"
"
MODE_IN_COMMUNICATION
"
}
;
private
static
class
VolumeLogger
{
private
static
final
String
THREAD_NAME
=
"
WebRtcVolumeLevelLoggerThread
"
;
private
static
final
int
TIMER_PERIOD_IN_SECONDS
=
10
;
private
final
AudioManager
audioManager
;
private
Timer
timer
;
public
VolumeLogger
(
AudioManager
audioManager
)
{
this
.
audioManager
=
audioManager
;
}
public
void
start
(
)
{
timer
=
new
Timer
(
THREAD_NAME
)
;
timer
.
schedule
(
new
LogVolumeTask
(
audioManager
.
getStreamMaxVolume
(
AudioManager
.
STREAM_RING
)
audioManager
.
getStreamMaxVolume
(
AudioManager
.
STREAM_VOICE_CALL
)
)
0
TIMER_PERIOD_IN_SECONDS
*
1000
)
;
}
private
class
LogVolumeTask
extends
TimerTask
{
private
final
int
maxRingVolume
;
private
final
int
maxVoiceCallVolume
;
LogVolumeTask
(
int
maxRingVolume
int
maxVoiceCallVolume
)
{
this
.
maxRingVolume
=
maxRingVolume
;
this
.
maxVoiceCallVolume
=
maxVoiceCallVolume
;
}
public
void
run
(
)
{
final
int
mode
=
audioManager
.
getMode
(
)
;
if
(
mode
=
=
AudioManager
.
MODE_RINGTONE
)
{
Log
.
d
(
TAG
"
STREAM_RING
stream
volume
:
"
+
audioManager
.
getStreamVolume
(
AudioManager
.
STREAM_RING
)
+
"
(
max
=
"
+
maxRingVolume
+
"
)
"
)
;
}
else
if
(
mode
=
=
AudioManager
.
MODE_IN_COMMUNICATION
)
{
Log
.
d
(
TAG
"
VOICE_CALL
stream
volume
:
"
+
audioManager
.
getStreamVolume
(
AudioManager
.
STREAM_VOICE_CALL
)
+
"
(
max
=
"
+
maxVoiceCallVolume
+
"
)
"
)
;
}
}
}
private
void
stop
(
)
{
if
(
timer
!
=
null
)
{
timer
.
cancel
(
)
;
timer
=
null
;
}
}
}
private
final
long
nativeAudioManager
;
private
final
Context
context
;
private
final
AudioManager
audioManager
;
private
boolean
initialized
=
false
;
private
int
nativeSampleRate
;
private
int
nativeChannels
;
private
boolean
hardwareAEC
;
private
boolean
hardwareAGC
;
private
boolean
hardwareNS
;
private
boolean
lowLatencyOutput
;
private
boolean
lowLatencyInput
;
private
boolean
proAudio
;
private
int
sampleRate
;
private
int
outputChannels
;
private
int
inputChannels
;
private
int
outputBufferSize
;
private
int
inputBufferSize
;
private
final
VolumeLogger
volumeLogger
;
WebRtcAudioManager
(
Context
context
long
nativeAudioManager
)
{
Log
.
d
(
TAG
"
ctor
"
+
WebRtcAudioUtils
.
getThreadInfo
(
)
)
;
this
.
context
=
context
;
this
.
nativeAudioManager
=
nativeAudioManager
;
audioManager
=
(
AudioManager
)
context
.
getSystemService
(
Context
.
AUDIO_SERVICE
)
;
if
(
DEBUG
)
{
WebRtcAudioUtils
.
logDeviceInfo
(
TAG
)
;
}
volumeLogger
=
new
VolumeLogger
(
audioManager
)
;
storeAudioParameters
(
)
;
nativeCacheAudioParameters
(
sampleRate
outputChannels
inputChannels
hardwareAEC
hardwareAGC
hardwareNS
lowLatencyOutput
lowLatencyInput
proAudio
outputBufferSize
inputBufferSize
nativeAudioManager
)
;
}
private
boolean
init
(
)
{
Log
.
d
(
TAG
"
init
"
+
WebRtcAudioUtils
.
getThreadInfo
(
)
)
;
if
(
initialized
)
{
return
true
;
}
Log
.
d
(
TAG
"
audio
mode
is
:
"
+
AUDIO_MODES
[
audioManager
.
getMode
(
)
]
)
;
initialized
=
true
;
volumeLogger
.
start
(
)
;
return
true
;
}
private
void
dispose
(
)
{
Log
.
d
(
TAG
"
dispose
"
+
WebRtcAudioUtils
.
getThreadInfo
(
)
)
;
if
(
!
initialized
)
{
return
;
}
volumeLogger
.
stop
(
)
;
}
private
boolean
isCommunicationModeEnabled
(
)
{
return
(
audioManager
.
getMode
(
)
=
=
AudioManager
.
MODE_IN_COMMUNICATION
)
;
}
private
boolean
isDeviceBlacklistedForOpenSLESUsage
(
)
{
boolean
blacklisted
=
blacklistDeviceForOpenSLESUsageIsOverridden
?
blacklistDeviceForOpenSLESUsage
:
WebRtcAudioUtils
.
deviceIsBlacklistedForOpenSLESUsage
(
)
;
if
(
blacklisted
)
{
Log
.
e
(
TAG
Build
.
MODEL
+
"
is
blacklisted
for
OpenSL
ES
usage
!
"
)
;
}
return
blacklisted
;
}
private
void
storeAudioParameters
(
)
{
outputChannels
=
getStereoOutput
(
)
?
2
:
1
;
inputChannels
=
getStereoInput
(
)
?
2
:
1
;
sampleRate
=
getNativeOutputSampleRate
(
)
;
hardwareAEC
=
isAcousticEchoCancelerSupported
(
)
;
hardwareAGC
=
false
;
hardwareNS
=
isNoiseSuppressorSupported
(
)
;
lowLatencyOutput
=
isLowLatencyOutputSupported
(
)
;
lowLatencyInput
=
isLowLatencyInputSupported
(
)
;
proAudio
=
isProAudioSupported
(
)
;
outputBufferSize
=
lowLatencyOutput
?
getLowLatencyOutputFramesPerBuffer
(
)
:
getMinOutputFrameSize
(
sampleRate
outputChannels
)
;
inputBufferSize
=
lowLatencyInput
?
getLowLatencyInputFramesPerBuffer
(
)
:
getMinInputFrameSize
(
sampleRate
inputChannels
)
;
}
private
boolean
hasEarpiece
(
)
{
return
context
.
getPackageManager
(
)
.
hasSystemFeature
(
PackageManager
.
FEATURE_TELEPHONY
)
;
}
private
boolean
isLowLatencyOutputSupported
(
)
{
return
isOpenSLESSupported
(
)
&
&
context
.
getPackageManager
(
)
.
hasSystemFeature
(
PackageManager
.
FEATURE_AUDIO_LOW_LATENCY
)
;
}
public
boolean
isLowLatencyInputSupported
(
)
{
return
WebRtcAudioUtils
.
runningOnLollipopOrHigher
(
)
&
&
isLowLatencyOutputSupported
(
)
;
}
private
boolean
isProAudioSupported
(
)
{
return
WebRtcAudioUtils
.
runningOnMarshmallowOrHigher
(
)
&
&
context
.
getPackageManager
(
)
.
hasSystemFeature
(
PackageManager
.
FEATURE_AUDIO_PRO
)
;
}
private
int
getNativeOutputSampleRate
(
)
{
if
(
WebRtcAudioUtils
.
runningOnEmulator
(
)
)
{
Log
.
d
(
TAG
"
Running
emulator
overriding
sample
rate
to
8
kHz
.
"
)
;
return
8000
;
}
if
(
WebRtcAudioUtils
.
isDefaultSampleRateOverridden
(
)
)
{
Log
.
d
(
TAG
"
Default
sample
rate
is
overriden
to
"
+
WebRtcAudioUtils
.
getDefaultSampleRateHz
(
)
+
"
Hz
"
)
;
return
WebRtcAudioUtils
.
getDefaultSampleRateHz
(
)
;
}
final
int
sampleRateHz
;
if
(
WebRtcAudioUtils
.
runningOnJellyBeanMR1OrHigher
(
)
)
{
sampleRateHz
=
getSampleRateOnJellyBeanMR10OrHigher
(
)
;
}
else
{
sampleRateHz
=
WebRtcAudioUtils
.
getDefaultSampleRateHz
(
)
;
}
Log
.
d
(
TAG
"
Sample
rate
is
set
to
"
+
sampleRateHz
+
"
Hz
"
)
;
return
sampleRateHz
;
}
TargetApi
(
17
)
private
int
getSampleRateOnJellyBeanMR10OrHigher
(
)
{
String
sampleRateString
=
audioManager
.
getProperty
(
AudioManager
.
PROPERTY_OUTPUT_SAMPLE_RATE
)
;
return
(
sampleRateString
=
=
null
)
?
WebRtcAudioUtils
.
getDefaultSampleRateHz
(
)
:
Integer
.
parseInt
(
sampleRateString
)
;
}
TargetApi
(
17
)
private
int
getLowLatencyOutputFramesPerBuffer
(
)
{
assertTrue
(
isLowLatencyOutputSupported
(
)
)
;
if
(
!
WebRtcAudioUtils
.
runningOnJellyBeanMR1OrHigher
(
)
)
{
return
DEFAULT_FRAME_PER_BUFFER
;
}
String
framesPerBuffer
=
audioManager
.
getProperty
(
AudioManager
.
PROPERTY_OUTPUT_FRAMES_PER_BUFFER
)
;
return
framesPerBuffer
=
=
null
?
DEFAULT_FRAME_PER_BUFFER
:
Integer
.
parseInt
(
framesPerBuffer
)
;
}
private
static
boolean
isAcousticEchoCancelerSupported
(
)
{
return
WebRtcAudioEffects
.
canUseAcousticEchoCanceler
(
)
;
}
private
static
boolean
isNoiseSuppressorSupported
(
)
{
return
WebRtcAudioEffects
.
canUseNoiseSuppressor
(
)
;
}
private
static
int
getMinOutputFrameSize
(
int
sampleRateInHz
int
numChannels
)
{
final
int
bytesPerFrame
=
numChannels
*
(
BITS_PER_SAMPLE
/
8
)
;
final
int
channelConfig
=
(
numChannels
=
=
1
?
AudioFormat
.
CHANNEL_OUT_MONO
:
AudioFormat
.
CHANNEL_OUT_STEREO
)
;
return
AudioTrack
.
getMinBufferSize
(
sampleRateInHz
channelConfig
AudioFormat
.
ENCODING_PCM_16BIT
)
/
bytesPerFrame
;
}
private
int
getLowLatencyInputFramesPerBuffer
(
)
{
assertTrue
(
isLowLatencyInputSupported
(
)
)
;
return
getLowLatencyOutputFramesPerBuffer
(
)
;
}
private
static
int
getMinInputFrameSize
(
int
sampleRateInHz
int
numChannels
)
{
final
int
bytesPerFrame
=
numChannels
*
(
BITS_PER_SAMPLE
/
8
)
;
final
int
channelConfig
=
(
numChannels
=
=
1
?
AudioFormat
.
CHANNEL_IN_MONO
:
AudioFormat
.
CHANNEL_IN_STEREO
)
;
return
AudioRecord
.
getMinBufferSize
(
sampleRateInHz
channelConfig
AudioFormat
.
ENCODING_PCM_16BIT
)
/
bytesPerFrame
;
}
private
static
boolean
isOpenSLESSupported
(
)
{
return
WebRtcAudioUtils
.
runningOnGingerBreadOrHigher
(
)
;
}
private
static
void
assertTrue
(
boolean
condition
)
{
if
(
!
condition
)
{
throw
new
AssertionError
(
"
Expected
condition
to
be
true
"
)
;
}
}
private
native
void
nativeCacheAudioParameters
(
int
sampleRate
int
outputChannels
int
inputChannels
boolean
hardwareAEC
boolean
hardwareAGC
boolean
hardwareNS
boolean
lowLatencyOutput
boolean
lowLatencyInput
boolean
proAudio
int
outputBufferSize
int
inputBufferSize
long
nativeAudioManager
)
;
}
