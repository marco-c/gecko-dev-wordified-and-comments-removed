package
org
.
webrtc
.
voiceengine
;
import
java
.
lang
.
Thread
;
import
java
.
nio
.
ByteBuffer
;
import
android
.
content
.
Context
;
import
android
.
media
.
AudioFormat
;
import
android
.
media
.
AudioManager
;
import
android
.
media
.
AudioTrack
;
import
android
.
os
.
Process
;
import
android
.
util
.
Log
;
import
org
.
mozilla
.
gecko
.
annotation
.
WebRTCJNITarget
;
WebRTCJNITarget
class
WebRtcAudioTrack
{
private
static
final
boolean
DEBUG
=
false
;
private
static
final
String
TAG
=
"
WebRtcAudioTrack
"
;
private
static
final
int
BITS_PER_SAMPLE
=
16
;
private
static
final
int
CALLBACK_BUFFER_SIZE_MS
=
10
;
private
static
final
int
BUFFERS_PER_SECOND
=
1000
/
CALLBACK_BUFFER_SIZE_MS
;
private
final
Context
context
;
private
final
long
nativeAudioTrack
;
private
final
AudioManager
audioManager
;
private
ByteBuffer
byteBuffer
;
private
AudioTrack
audioTrack
;
private
AudioTrackThread
audioThread
=
null
;
private
class
AudioTrackThread
extends
Thread
{
private
volatile
boolean
keepAlive
=
true
;
public
AudioTrackThread
(
String
name
)
{
super
(
name
)
;
}
Override
public
void
run
(
)
{
Process
.
setThreadPriority
(
Process
.
THREAD_PRIORITY_URGENT_AUDIO
)
;
Logd
(
"
AudioTrackThread
"
+
WebRtcAudioUtils
.
getThreadInfo
(
)
)
;
try
{
audioTrack
.
play
(
)
;
assertTrue
(
audioTrack
.
getPlayState
(
)
=
=
AudioTrack
.
PLAYSTATE_PLAYING
)
;
}
catch
(
IllegalStateException
e
)
{
Loge
(
"
AudioTrack
.
play
failed
:
"
+
e
.
getMessage
(
)
)
;
return
;
}
final
int
sizeInBytes
=
byteBuffer
.
capacity
(
)
;
while
(
keepAlive
)
{
nativeGetPlayoutData
(
sizeInBytes
nativeAudioTrack
)
;
assertTrue
(
sizeInBytes
<
=
byteBuffer
.
remaining
(
)
)
;
int
bytesWritten
=
0
;
if
(
WebRtcAudioUtils
.
runningOnLollipopOrHigher
(
)
)
{
bytesWritten
=
audioTrack
.
write
(
byteBuffer
sizeInBytes
AudioTrack
.
WRITE_BLOCKING
)
;
}
else
{
bytesWritten
=
audioTrack
.
write
(
byteBuffer
.
array
(
)
byteBuffer
.
arrayOffset
(
)
sizeInBytes
)
;
}
if
(
bytesWritten
!
=
sizeInBytes
)
{
Loge
(
"
AudioTrack
.
write
failed
:
"
+
bytesWritten
)
;
if
(
bytesWritten
=
=
AudioTrack
.
ERROR_INVALID_OPERATION
)
{
keepAlive
=
false
;
}
}
byteBuffer
.
rewind
(
)
;
}
try
{
audioTrack
.
stop
(
)
;
}
catch
(
IllegalStateException
e
)
{
Loge
(
"
AudioTrack
.
stop
failed
:
"
+
e
.
getMessage
(
)
)
;
}
assertTrue
(
audioTrack
.
getPlayState
(
)
=
=
AudioTrack
.
PLAYSTATE_STOPPED
)
;
audioTrack
.
flush
(
)
;
}
public
void
joinThread
(
)
{
keepAlive
=
false
;
while
(
isAlive
(
)
)
{
try
{
join
(
)
;
}
catch
(
InterruptedException
e
)
{
}
}
}
}
WebRtcAudioTrack
(
Context
context
long
nativeAudioTrack
)
{
Logd
(
"
ctor
"
+
WebRtcAudioUtils
.
getThreadInfo
(
)
)
;
this
.
context
=
context
;
this
.
nativeAudioTrack
=
nativeAudioTrack
;
audioManager
=
(
AudioManager
)
context
.
getSystemService
(
Context
.
AUDIO_SERVICE
)
;
if
(
DEBUG
)
{
WebRtcAudioUtils
.
logDeviceInfo
(
TAG
)
;
}
}
private
int
InitPlayout
(
int
sampleRate
int
channels
)
{
Logd
(
"
InitPlayout
(
sampleRate
=
"
+
sampleRate
+
"
channels
=
"
+
channels
+
"
)
"
)
;
final
int
bytesPerFrame
=
channels
*
(
BITS_PER_SAMPLE
/
8
)
;
byteBuffer
=
ByteBuffer
.
allocateDirect
(
bytesPerFrame
*
(
sampleRate
/
BUFFERS_PER_SECOND
)
)
;
Logd
(
"
byteBuffer
.
capacity
:
"
+
byteBuffer
.
capacity
(
)
)
;
nativeCacheDirectBufferAddress
(
byteBuffer
nativeAudioTrack
)
;
final
int
minBufferSizeInBytes
=
AudioTrack
.
getMinBufferSize
(
sampleRate
AudioFormat
.
CHANNEL_OUT_MONO
AudioFormat
.
ENCODING_PCM_16BIT
)
;
Logd
(
"
AudioTrack
.
getMinBufferSize
:
"
+
minBufferSizeInBytes
)
;
assertTrue
(
audioTrack
=
=
null
)
;
assertTrue
(
byteBuffer
.
capacity
(
)
<
minBufferSizeInBytes
)
;
try
{
audioTrack
=
new
AudioTrack
(
AudioManager
.
STREAM_VOICE_CALL
sampleRate
AudioFormat
.
CHANNEL_OUT_MONO
AudioFormat
.
ENCODING_PCM_16BIT
minBufferSizeInBytes
AudioTrack
.
MODE_STREAM
)
;
}
catch
(
IllegalArgumentException
e
)
{
Logd
(
e
.
getMessage
(
)
)
;
return
-
1
;
}
assertTrue
(
audioTrack
.
getState
(
)
=
=
AudioTrack
.
STATE_INITIALIZED
)
;
assertTrue
(
audioTrack
.
getPlayState
(
)
=
=
AudioTrack
.
PLAYSTATE_STOPPED
)
;
assertTrue
(
audioTrack
.
getStreamType
(
)
=
=
AudioManager
.
STREAM_VOICE_CALL
)
;
return
(
1000
*
(
minBufferSizeInBytes
/
bytesPerFrame
)
/
sampleRate
)
;
}
private
boolean
StartPlayout
(
)
{
Logd
(
"
StartPlayout
"
)
;
assertTrue
(
audioTrack
!
=
null
)
;
assertTrue
(
audioThread
=
=
null
)
;
audioThread
=
new
AudioTrackThread
(
"
AudioTrackJavaThread
"
)
;
audioThread
.
start
(
)
;
return
true
;
}
private
boolean
StopPlayout
(
)
{
Logd
(
"
StopPlayout
"
)
;
assertTrue
(
audioThread
!
=
null
)
;
audioThread
.
joinThread
(
)
;
audioThread
=
null
;
if
(
audioTrack
!
=
null
)
{
audioTrack
.
release
(
)
;
audioTrack
=
null
;
}
return
true
;
}
private
int
GetStreamMaxVolume
(
)
{
Logd
(
"
GetStreamMaxVolume
"
)
;
assertTrue
(
audioManager
!
=
null
)
;
return
audioManager
.
getStreamMaxVolume
(
AudioManager
.
STREAM_VOICE_CALL
)
;
}
private
boolean
SetStreamVolume
(
int
volume
)
{
Logd
(
"
SetStreamVolume
(
"
+
volume
+
"
)
"
)
;
assertTrue
(
audioManager
!
=
null
)
;
if
(
WebRtcAudioUtils
.
runningOnLollipopOrHigher
(
)
)
{
if
(
audioManager
.
isVolumeFixed
(
)
)
{
Loge
(
"
The
device
implements
a
fixed
volume
policy
.
"
)
;
return
false
;
}
}
audioManager
.
setStreamVolume
(
AudioManager
.
STREAM_VOICE_CALL
volume
0
)
;
return
true
;
}
private
int
GetStreamVolume
(
)
{
Logd
(
"
GetStreamVolume
"
)
;
assertTrue
(
audioManager
!
=
null
)
;
return
audioManager
.
getStreamVolume
(
AudioManager
.
STREAM_VOICE_CALL
)
;
}
private
static
void
assertTrue
(
boolean
condition
)
{
if
(
!
condition
)
{
throw
new
AssertionError
(
"
Expected
condition
to
be
true
"
)
;
}
}
private
static
void
Logd
(
String
msg
)
{
Log
.
d
(
TAG
msg
)
;
}
private
static
void
Loge
(
String
msg
)
{
Log
.
e
(
TAG
msg
)
;
}
private
native
void
nativeCacheDirectBufferAddress
(
ByteBuffer
byteBuffer
long
nativeAudioRecord
)
;
private
native
void
nativeGetPlayoutData
(
int
bytes
long
nativeAudioRecord
)
;
}
