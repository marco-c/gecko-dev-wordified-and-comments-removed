#
include
<
algorithm
>
#
include
"
webrtc
/
modules
/
audio_device
/
audio_device_buffer
.
h
"
#
include
"
webrtc
/
base
/
arraysize
.
h
"
#
include
"
webrtc
/
base
/
bind
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
format_macros
.
h
"
#
include
"
webrtc
/
base
/
timeutils
.
h
"
#
include
"
webrtc
/
common_audio
/
signal_processing
/
include
/
signal_processing_library
.
h
"
#
include
"
webrtc
/
modules
/
audio_device
/
audio_device_config
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
metrics
.
h
"
namespace
webrtc
{
static
const
char
kTimerQueueName
[
]
=
"
AudioDeviceBufferTimer
"
;
static
const
size_t
kTimerIntervalInSeconds
=
10
;
static
const
size_t
kTimerIntervalInMilliseconds
=
kTimerIntervalInSeconds
*
rtc
:
:
kNumMillisecsPerSec
;
static
const
size_t
kMinValidCallTimeTimeInSeconds
=
10
;
static
const
size_t
kMinValidCallTimeTimeInMilliseconds
=
kMinValidCallTimeTimeInSeconds
*
rtc
:
:
kNumMillisecsPerSec
;
AudioDeviceBuffer
:
:
AudioDeviceBuffer
(
)
:
task_queue_
(
kTimerQueueName
)
audio_transport_cb_
(
nullptr
)
rec_sample_rate_
(
0
)
play_sample_rate_
(
0
)
rec_channels_
(
0
)
play_channels_
(
0
)
playing_
(
false
)
recording_
(
false
)
current_mic_level_
(
0
)
new_mic_level_
(
0
)
typing_status_
(
false
)
play_delay_ms_
(
0
)
rec_delay_ms_
(
0
)
clock_drift_
(
0
)
num_stat_reports_
(
0
)
rec_callbacks_
(
0
)
last_rec_callbacks_
(
0
)
play_callbacks_
(
0
)
last_play_callbacks_
(
0
)
rec_samples_
(
0
)
last_rec_samples_
(
0
)
play_samples_
(
0
)
last_play_samples_
(
0
)
max_rec_level_
(
0
)
max_play_level_
(
0
)
last_timer_task_time_
(
0
)
rec_stat_count_
(
0
)
play_stat_count_
(
0
)
play_start_time_
(
0
)
rec_start_time_
(
0
)
only_silence_recorded_
(
true
)
log_stats_
(
false
)
{
LOG
(
INFO
)
<
<
"
AudioDeviceBuffer
:
:
ctor
"
;
playout_thread_checker_
.
DetachFromThread
(
)
;
recording_thread_checker_
.
DetachFromThread
(
)
;
}
AudioDeviceBuffer
:
:
~
AudioDeviceBuffer
(
)
{
RTC_DCHECK_RUN_ON
(
&
main_thread_checker_
)
;
RTC_DCHECK
(
!
playing_
)
;
RTC_DCHECK
(
!
recording_
)
;
LOG
(
INFO
)
<
<
"
AudioDeviceBuffer
:
:
~
dtor
"
;
}
int32_t
AudioDeviceBuffer
:
:
RegisterAudioCallback
(
AudioTransport
*
audio_callback
)
{
RTC_DCHECK_RUN_ON
(
&
main_thread_checker_
)
;
LOG
(
INFO
)
<
<
__FUNCTION__
;
if
(
playing_
|
|
recording_
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
set
audio
transport
since
media
was
active
"
;
return
-
1
;
}
audio_transport_cb_
=
audio_callback
;
return
0
;
}
void
AudioDeviceBuffer
:
:
StartPlayout
(
)
{
RTC_DCHECK_RUN_ON
(
&
main_thread_checker_
)
;
if
(
playing_
)
{
return
;
}
LOG
(
INFO
)
<
<
__FUNCTION__
;
playout_thread_checker_
.
DetachFromThread
(
)
;
task_queue_
.
PostTask
(
[
this
]
{
ResetPlayStats
(
)
;
}
)
;
if
(
!
recording_
)
{
StartPeriodicLogging
(
)
;
}
const
int64_t
now_time
=
rtc
:
:
TimeMillis
(
)
;
play_start_time_
=
now_time
;
playing_
=
true
;
}
void
AudioDeviceBuffer
:
:
StartRecording
(
)
{
RTC_DCHECK_RUN_ON
(
&
main_thread_checker_
)
;
if
(
recording_
)
{
return
;
}
LOG
(
INFO
)
<
<
__FUNCTION__
;
recording_thread_checker_
.
DetachFromThread
(
)
;
task_queue_
.
PostTask
(
[
this
]
{
ResetRecStats
(
)
;
}
)
;
if
(
!
playing_
)
{
StartPeriodicLogging
(
)
;
}
rec_start_time_
=
rtc
:
:
TimeMillis
(
)
;
recording_
=
true
;
only_silence_recorded_
=
true
;
}
void
AudioDeviceBuffer
:
:
StopPlayout
(
)
{
RTC_DCHECK_RUN_ON
(
&
main_thread_checker_
)
;
if
(
!
playing_
)
{
return
;
}
LOG
(
INFO
)
<
<
__FUNCTION__
;
playing_
=
false
;
if
(
!
recording_
)
{
StopPeriodicLogging
(
)
;
}
LOG
(
INFO
)
<
<
"
total
playout
time
:
"
<
<
rtc
:
:
TimeSince
(
play_start_time_
)
;
}
void
AudioDeviceBuffer
:
:
StopRecording
(
)
{
RTC_DCHECK_RUN_ON
(
&
main_thread_checker_
)
;
if
(
!
recording_
)
{
return
;
}
LOG
(
INFO
)
<
<
__FUNCTION__
;
recording_
=
false
;
if
(
!
playing_
)
{
StopPeriodicLogging
(
)
;
}
const
size_t
time_since_start
=
rtc
:
:
TimeSince
(
rec_start_time_
)
;
if
(
time_since_start
>
kMinValidCallTimeTimeInMilliseconds
)
{
const
int
only_zeros
=
static_cast
<
int
>
(
only_silence_recorded_
)
;
RTC_HISTOGRAM_BOOLEAN
(
"
WebRTC
.
Audio
.
RecordedOnlyZeros
"
only_zeros
)
;
LOG
(
INFO
)
<
<
"
HISTOGRAM
(
WebRTC
.
Audio
.
RecordedOnlyZeros
)
:
"
<
<
only_zeros
;
}
LOG
(
INFO
)
<
<
"
total
recording
time
:
"
<
<
time_since_start
;
}
int32_t
AudioDeviceBuffer
:
:
SetRecordingSampleRate
(
uint32_t
fsHz
)
{
RTC_DCHECK
(
main_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
INFO
)
<
<
"
SetRecordingSampleRate
(
"
<
<
fsHz
<
<
"
)
"
;
rec_sample_rate_
=
fsHz
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
SetPlayoutSampleRate
(
uint32_t
fsHz
)
{
RTC_DCHECK
(
main_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
INFO
)
<
<
"
SetPlayoutSampleRate
(
"
<
<
fsHz
<
<
"
)
"
;
play_sample_rate_
=
fsHz
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
RecordingSampleRate
(
)
const
{
RTC_DCHECK
(
main_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
rec_sample_rate_
;
}
int32_t
AudioDeviceBuffer
:
:
PlayoutSampleRate
(
)
const
{
RTC_DCHECK
(
main_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
play_sample_rate_
;
}
int32_t
AudioDeviceBuffer
:
:
SetRecordingChannels
(
size_t
channels
)
{
RTC_DCHECK
(
main_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
INFO
)
<
<
"
SetRecordingChannels
(
"
<
<
channels
<
<
"
)
"
;
rec_channels_
=
channels
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
SetPlayoutChannels
(
size_t
channels
)
{
RTC_DCHECK
(
main_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
INFO
)
<
<
"
SetPlayoutChannels
(
"
<
<
channels
<
<
"
)
"
;
play_channels_
=
channels
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
SetRecordingChannel
(
const
AudioDeviceModule
:
:
ChannelType
channel
)
{
LOG
(
INFO
)
<
<
"
SetRecordingChannel
(
"
<
<
channel
<
<
"
)
"
;
LOG
(
LS_WARNING
)
<
<
"
Not
implemented
"
;
RTC_DCHECK_EQ
(
channel
AudioDeviceModule
:
:
kChannelBoth
)
;
return
-
1
;
}
int32_t
AudioDeviceBuffer
:
:
RecordingChannel
(
AudioDeviceModule
:
:
ChannelType
&
channel
)
const
{
LOG
(
LS_WARNING
)
<
<
"
Not
implemented
"
;
return
-
1
;
}
size_t
AudioDeviceBuffer
:
:
RecordingChannels
(
)
const
{
RTC_DCHECK
(
main_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
rec_channels_
;
}
size_t
AudioDeviceBuffer
:
:
PlayoutChannels
(
)
const
{
RTC_DCHECK
(
main_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
play_channels_
;
}
int32_t
AudioDeviceBuffer
:
:
SetCurrentMicLevel
(
uint32_t
level
)
{
#
if
!
defined
(
WEBRTC_WIN
)
RTC_DCHECK_RUN_ON
(
&
recording_thread_checker_
)
;
#
endif
current_mic_level_
=
level
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
SetTypingStatus
(
bool
typing_status
)
{
RTC_DCHECK_RUN_ON
(
&
recording_thread_checker_
)
;
typing_status_
=
typing_status
;
return
0
;
}
uint32_t
AudioDeviceBuffer
:
:
NewMicLevel
(
)
const
{
RTC_DCHECK_RUN_ON
(
&
recording_thread_checker_
)
;
return
new_mic_level_
;
}
void
AudioDeviceBuffer
:
:
SetVQEData
(
int
play_delay_ms
int
rec_delay_ms
int
clock_drift
)
{
RTC_DCHECK_RUN_ON
(
&
recording_thread_checker_
)
;
play_delay_ms_
=
play_delay_ms
;
rec_delay_ms_
=
rec_delay_ms
;
clock_drift_
=
clock_drift
;
}
int32_t
AudioDeviceBuffer
:
:
StartInputFileRecording
(
const
char
fileName
[
kAdmMaxFileNameSize
]
)
{
LOG
(
LS_WARNING
)
<
<
"
Not
implemented
"
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
StopInputFileRecording
(
)
{
LOG
(
LS_WARNING
)
<
<
"
Not
implemented
"
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
StartOutputFileRecording
(
const
char
fileName
[
kAdmMaxFileNameSize
]
)
{
LOG
(
LS_WARNING
)
<
<
"
Not
implemented
"
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
StopOutputFileRecording
(
)
{
LOG
(
LS_WARNING
)
<
<
"
Not
implemented
"
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
SetRecordedBuffer
(
const
void
*
audio_buffer
size_t
samples_per_channel
)
{
RTC_DCHECK_RUN_ON
(
&
recording_thread_checker_
)
;
const
size_t
old_size
=
rec_buffer_
.
size
(
)
;
rec_buffer_
.
SetData
(
static_cast
<
const
int16_t
*
>
(
audio_buffer
)
rec_channels_
*
samples_per_channel
)
;
if
(
old_size
!
=
rec_buffer_
.
size
(
)
)
{
LOG
(
LS_INFO
)
<
<
"
Size
of
recording
buffer
:
"
<
<
rec_buffer_
.
size
(
)
;
}
int16_t
max_abs
=
0
;
RTC_DCHECK_LT
(
rec_stat_count_
50
)
;
if
(
+
+
rec_stat_count_
>
=
50
)
{
max_abs
=
WebRtcSpl_MaxAbsValueW16
(
rec_buffer_
.
data
(
)
rec_buffer_
.
size
(
)
)
;
rec_stat_count_
=
0
;
if
(
max_abs
>
0
)
{
only_silence_recorded_
=
false
;
}
}
task_queue_
.
PostTask
(
[
this
max_abs
samples_per_channel
]
{
UpdateRecStats
(
max_abs
samples_per_channel
)
;
}
)
;
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
DeliverRecordedData
(
)
{
RTC_DCHECK_RUN_ON
(
&
recording_thread_checker_
)
;
if
(
!
audio_transport_cb_
)
{
LOG
(
LS_WARNING
)
<
<
"
Invalid
audio
transport
"
;
return
0
;
}
const
size_t
frames
=
rec_buffer_
.
size
(
)
/
rec_channels_
;
const
size_t
bytes_per_frame
=
rec_channels_
*
sizeof
(
int16_t
)
;
uint32_t
new_mic_level
(
0
)
;
uint32_t
total_delay_ms
=
play_delay_ms_
+
rec_delay_ms_
;
int32_t
res
=
audio_transport_cb_
-
>
RecordedDataIsAvailable
(
rec_buffer_
.
data
(
)
frames
bytes_per_frame
rec_channels_
rec_sample_rate_
total_delay_ms
clock_drift_
current_mic_level_
typing_status_
new_mic_level
)
;
if
(
res
!
=
-
1
)
{
new_mic_level_
=
new_mic_level
;
}
else
{
LOG
(
LS_ERROR
)
<
<
"
RecordedDataIsAvailable
(
)
failed
"
;
}
return
0
;
}
int32_t
AudioDeviceBuffer
:
:
RequestPlayoutData
(
size_t
samples_per_channel
)
{
RTC_DCHECK_RUN_ON
(
&
playout_thread_checker_
)
;
const
size_t
total_samples
=
play_channels_
*
samples_per_channel
;
if
(
play_buffer_
.
size
(
)
!
=
total_samples
)
{
play_buffer_
.
SetSize
(
total_samples
)
;
LOG
(
LS_INFO
)
<
<
"
Size
of
playout
buffer
:
"
<
<
play_buffer_
.
size
(
)
;
}
size_t
num_samples_out
(
0
)
;
if
(
!
audio_transport_cb_
)
{
LOG
(
LS_WARNING
)
<
<
"
Invalid
audio
transport
"
;
return
0
;
}
int64_t
elapsed_time_ms
=
-
1
;
int64_t
ntp_time_ms
=
-
1
;
const
size_t
bytes_per_frame
=
play_channels_
*
sizeof
(
int16_t
)
;
uint32_t
res
=
audio_transport_cb_
-
>
NeedMorePlayData
(
samples_per_channel
bytes_per_frame
play_channels_
play_sample_rate_
play_buffer_
.
data
(
)
num_samples_out
&
elapsed_time_ms
&
ntp_time_ms
)
;
if
(
res
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
NeedMorePlayData
(
)
failed
"
;
}
int16_t
max_abs
=
0
;
RTC_DCHECK_LT
(
play_stat_count_
50
)
;
if
(
+
+
play_stat_count_
>
=
50
)
{
max_abs
=
WebRtcSpl_MaxAbsValueW16
(
play_buffer_
.
data
(
)
play_buffer_
.
size
(
)
)
;
play_stat_count_
=
0
;
}
task_queue_
.
PostTask
(
[
this
max_abs
num_samples_out
]
{
UpdatePlayStats
(
max_abs
num_samples_out
)
;
}
)
;
return
static_cast
<
int32_t
>
(
num_samples_out
)
;
}
int32_t
AudioDeviceBuffer
:
:
GetPlayoutData
(
void
*
audio_buffer
)
{
RTC_DCHECK_RUN_ON
(
&
playout_thread_checker_
)
;
RTC_DCHECK_GT
(
play_buffer_
.
size
(
)
0
)
;
const
size_t
bytes_per_sample
=
sizeof
(
int16_t
)
;
memcpy
(
audio_buffer
play_buffer_
.
data
(
)
play_buffer_
.
size
(
)
*
bytes_per_sample
)
;
return
static_cast
<
int32_t
>
(
play_buffer_
.
size
(
)
/
play_channels_
)
;
}
void
AudioDeviceBuffer
:
:
StartPeriodicLogging
(
)
{
task_queue_
.
PostTask
(
rtc
:
:
Bind
(
&
AudioDeviceBuffer
:
:
LogStats
this
AudioDeviceBuffer
:
:
LOG_START
)
)
;
}
void
AudioDeviceBuffer
:
:
StopPeriodicLogging
(
)
{
task_queue_
.
PostTask
(
rtc
:
:
Bind
(
&
AudioDeviceBuffer
:
:
LogStats
this
AudioDeviceBuffer
:
:
LOG_STOP
)
)
;
}
void
AudioDeviceBuffer
:
:
LogStats
(
LogState
state
)
{
RTC_DCHECK_RUN_ON
(
&
task_queue_
)
;
int64_t
now_time
=
rtc
:
:
TimeMillis
(
)
;
if
(
state
=
=
AudioDeviceBuffer
:
:
LOG_START
)
{
num_stat_reports_
=
0
;
last_timer_task_time_
=
now_time
;
log_stats_
=
true
;
}
else
if
(
state
=
=
AudioDeviceBuffer
:
:
LOG_STOP
)
{
log_stats_
=
false
;
}
else
if
(
state
=
=
AudioDeviceBuffer
:
:
LOG_ACTIVE
)
{
}
if
(
!
log_stats_
)
{
return
;
}
int64_t
next_callback_time
=
now_time
+
kTimerIntervalInMilliseconds
;
int64_t
time_since_last
=
rtc
:
:
TimeDiff
(
now_time
last_timer_task_time_
)
;
last_timer_task_time_
=
now_time
;
if
(
+
+
num_stat_reports_
>
1
&
&
time_since_last
>
0
)
{
uint32_t
diff_samples
=
rec_samples_
-
last_rec_samples_
;
float
rate
=
diff_samples
/
(
static_cast
<
float
>
(
time_since_last
)
/
1000
.
0
)
;
LOG
(
INFO
)
<
<
"
[
REC
:
"
<
<
time_since_last
<
<
"
msec
"
<
<
rec_sample_rate_
/
1000
<
<
"
kHz
]
callbacks
:
"
<
<
rec_callbacks_
-
last_rec_callbacks_
<
<
"
"
<
<
"
samples
:
"
<
<
diff_samples
<
<
"
"
<
<
"
rate
:
"
<
<
static_cast
<
int
>
(
rate
+
0
.
5
)
<
<
"
"
<
<
"
level
:
"
<
<
max_rec_level_
;
diff_samples
=
play_samples_
-
last_play_samples_
;
rate
=
diff_samples
/
(
static_cast
<
float
>
(
time_since_last
)
/
1000
.
0
)
;
LOG
(
INFO
)
<
<
"
[
PLAY
:
"
<
<
time_since_last
<
<
"
msec
"
<
<
play_sample_rate_
/
1000
<
<
"
kHz
]
callbacks
:
"
<
<
play_callbacks_
-
last_play_callbacks_
<
<
"
"
<
<
"
samples
:
"
<
<
diff_samples
<
<
"
"
<
<
"
rate
:
"
<
<
static_cast
<
int
>
(
rate
+
0
.
5
)
<
<
"
"
<
<
"
level
:
"
<
<
max_play_level_
;
}
last_rec_callbacks_
=
rec_callbacks_
;
last_play_callbacks_
=
play_callbacks_
;
last_rec_samples_
=
rec_samples_
;
last_play_samples_
=
play_samples_
;
max_rec_level_
=
0
;
max_play_level_
=
0
;
int64_t
time_to_wait_ms
=
next_callback_time
-
rtc
:
:
TimeMillis
(
)
;
RTC_DCHECK_GT
(
time_to_wait_ms
0
)
<
<
"
Invalid
timer
interval
"
;
task_queue_
.
PostDelayedTask
(
rtc
:
:
Bind
(
&
AudioDeviceBuffer
:
:
LogStats
this
AudioDeviceBuffer
:
:
LOG_ACTIVE
)
time_to_wait_ms
)
;
}
void
AudioDeviceBuffer
:
:
ResetRecStats
(
)
{
RTC_DCHECK_RUN_ON
(
&
task_queue_
)
;
rec_callbacks_
=
0
;
last_rec_callbacks_
=
0
;
rec_samples_
=
0
;
last_rec_samples_
=
0
;
max_rec_level_
=
0
;
}
void
AudioDeviceBuffer
:
:
ResetPlayStats
(
)
{
RTC_DCHECK_RUN_ON
(
&
task_queue_
)
;
play_callbacks_
=
0
;
last_play_callbacks_
=
0
;
play_samples_
=
0
;
last_play_samples_
=
0
;
max_play_level_
=
0
;
}
void
AudioDeviceBuffer
:
:
UpdateRecStats
(
int16_t
max_abs
size_t
samples_per_channel
)
{
RTC_DCHECK_RUN_ON
(
&
task_queue_
)
;
+
+
rec_callbacks_
;
rec_samples_
+
=
samples_per_channel
;
if
(
max_abs
>
max_rec_level_
)
{
max_rec_level_
=
max_abs
;
}
}
void
AudioDeviceBuffer
:
:
UpdatePlayStats
(
int16_t
max_abs
size_t
samples_per_channel
)
{
RTC_DCHECK_RUN_ON
(
&
task_queue_
)
;
+
+
play_callbacks_
;
play_samples_
+
=
samples_per_channel
;
if
(
max_abs
>
max_play_level_
)
{
max_play_level_
=
max_abs
;
}
}
}
