#
include
"
webrtc
/
modules
/
audio_coding
/
main
/
acm2
/
acm_codec_database
.
h
"
#
include
<
assert
.
h
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
main
/
acm2
/
acm_common_defs
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
trace
.
h
"
namespace
webrtc
{
namespace
acm2
{
const
CodecInst
ACMCodecDB
:
:
database_
[
]
=
{
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
{
103
"
ISAC
"
16000
kIsacPacSize480
1
kIsacWbDefaultRate
}
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
)
{
104
"
ISAC
"
32000
kIsacPacSize960
1
kIsacSwbDefaultRate
}
{
105
"
ISAC
"
48000
kIsacPacSize1440
1
kIsacSwbDefaultRate
}
#
endif
#
endif
#
ifdef
WEBRTC_CODEC_PCM16
{
107
"
L16
"
8000
80
1
128000
}
{
108
"
L16
"
16000
160
1
256000
}
{
109
"
L16
"
32000
320
1
512000
}
{
111
"
L16
"
8000
80
2
128000
}
{
112
"
L16
"
16000
160
2
256000
}
{
113
"
L16
"
32000
320
2
512000
}
#
endif
{
0
"
PCMU
"
8000
160
1
64000
}
{
8
"
PCMA
"
8000
160
1
64000
}
{
110
"
PCMU
"
8000
160
2
64000
}
{
118
"
PCMA
"
8000
160
2
64000
}
#
ifdef
WEBRTC_CODEC_ILBC
{
102
"
ILBC
"
8000
240
1
13300
}
#
endif
#
ifdef
WEBRTC_CODEC_G722
{
9
"
G722
"
16000
320
1
64000
}
{
119
"
G722
"
16000
320
2
64000
}
#
endif
#
ifdef
WEBRTC_CODEC_OPUS
{
120
"
opus
"
48000
960
2
64000
}
#
endif
{
13
"
CN
"
8000
240
1
0
}
{
98
"
CN
"
16000
480
1
0
}
{
99
"
CN
"
32000
960
1
0
}
#
ifdef
ENABLE_48000_HZ
{
100
"
CN
"
48000
1440
1
0
}
#
endif
#
ifdef
WEBRTC_CODEC_AVT
{
106
"
telephone
-
event
"
8000
240
1
0
}
#
endif
#
ifdef
WEBRTC_CODEC_RED
{
127
"
red
"
8000
0
1
0
}
#
endif
{
-
1
"
Null
"
-
1
-
1
-
1
-
1
}
}
;
const
ACMCodecDB
:
:
CodecSettings
ACMCodecDB
:
:
codec_settings_
[
]
=
{
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
{
2
{
kIsacPacSize480
kIsacPacSize960
}
0
1
true
}
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
)
{
1
{
kIsacPacSize960
}
0
1
true
}
{
1
{
kIsacPacSize1440
}
0
1
true
}
#
endif
#
endif
#
ifdef
WEBRTC_CODEC_PCM16
{
4
{
80
160
240
320
}
0
2
false
}
{
4
{
160
320
480
640
}
0
2
false
}
{
2
{
320
640
}
0
2
false
}
{
4
{
80
160
240
320
}
0
2
false
}
{
4
{
160
320
480
640
}
0
2
false
}
{
2
{
320
640
}
0
2
}
#
endif
{
6
{
80
160
240
320
400
480
}
0
2
false
}
{
6
{
80
160
240
320
400
480
}
0
2
false
}
{
6
{
80
160
240
320
400
480
}
0
2
false
}
{
6
{
80
160
240
320
400
480
}
0
2
false
}
#
ifdef
WEBRTC_CODEC_ILBC
{
4
{
160
240
320
480
}
0
1
false
}
#
endif
#
ifdef
WEBRTC_CODEC_G722
{
6
{
160
320
480
640
800
960
}
0
2
false
}
{
6
{
160
320
480
640
800
960
}
0
2
false
}
#
endif
#
ifdef
WEBRTC_CODEC_OPUS
{
4
{
480
960
1920
2880
}
0
2
false
}
#
endif
{
1
{
240
}
240
1
false
}
{
1
{
480
}
480
1
false
}
{
1
{
960
}
960
1
false
}
#
ifdef
ENABLE_48000_HZ
{
1
{
1440
}
1440
1
false
}
#
endif
#
ifdef
WEBRTC_CODEC_AVT
{
1
{
240
}
240
1
false
}
#
endif
#
ifdef
WEBRTC_CODEC_RED
{
1
{
0
}
0
1
false
}
#
endif
{
-
1
{
-
1
}
-
1
-
1
false
}
}
;
const
NetEqDecoder
ACMCodecDB
:
:
neteq_decoders_
[
]
=
{
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
kDecoderISAC
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
)
kDecoderISACswb
kDecoderISACfb
#
endif
#
endif
#
ifdef
WEBRTC_CODEC_PCM16
kDecoderPCM16B
kDecoderPCM16Bwb
kDecoderPCM16Bswb32kHz
kDecoderPCM16B_2ch
kDecoderPCM16Bwb_2ch
kDecoderPCM16Bswb32kHz_2ch
#
endif
kDecoderPCMu
kDecoderPCMa
kDecoderPCMu_2ch
kDecoderPCMa_2ch
#
ifdef
WEBRTC_CODEC_ILBC
kDecoderILBC
#
endif
#
ifdef
WEBRTC_CODEC_G722
kDecoderG722
kDecoderG722_2ch
#
endif
#
ifdef
WEBRTC_CODEC_OPUS
kDecoderOpus
#
endif
kDecoderCNGnb
kDecoderCNGwb
kDecoderCNGswb32kHz
#
ifdef
ENABLE_48000_HZ
kDecoderCNGswb48kHz
#
endif
#
ifdef
WEBRTC_CODEC_AVT
kDecoderAVT
#
endif
#
ifdef
WEBRTC_CODEC_RED
kDecoderRED
#
endif
}
;
int
ACMCodecDB
:
:
Codec
(
int
codec_id
CodecInst
*
codec_inst
)
{
if
(
(
codec_id
<
0
)
|
|
(
codec_id
>
=
kNumCodecs
)
)
{
return
-
1
;
}
memcpy
(
codec_inst
&
database_
[
codec_id
]
sizeof
(
CodecInst
)
)
;
return
0
;
}
enum
{
kInvalidCodec
=
-
10
kInvalidPayloadtype
=
-
30
kInvalidPacketSize
=
-
40
kInvalidRate
=
-
50
}
;
int
ACMCodecDB
:
:
CodecNumber
(
const
CodecInst
&
codec_inst
int
*
mirror_id
)
{
int
codec_id
=
CodecId
(
codec_inst
)
;
if
(
codec_id
=
=
-
1
)
{
return
kInvalidCodec
;
}
if
(
!
ValidPayloadType
(
codec_inst
.
pltype
)
)
{
return
kInvalidPayloadtype
;
}
if
(
STR_CASE_CMP
(
database_
[
codec_id
]
.
plname
"
CN
"
)
=
=
0
)
{
*
mirror_id
=
codec_id
;
return
codec_id
;
}
if
(
STR_CASE_CMP
(
database_
[
codec_id
]
.
plname
"
red
"
)
=
=
0
)
{
*
mirror_id
=
codec_id
;
return
codec_id
;
}
if
(
codec_settings_
[
codec_id
]
.
num_packet_sizes
>
0
)
{
bool
packet_size_ok
=
false
;
int
i
;
int
packet_size_samples
;
for
(
i
=
0
;
i
<
codec_settings_
[
codec_id
]
.
num_packet_sizes
;
i
+
+
)
{
packet_size_samples
=
codec_settings_
[
codec_id
]
.
packet_sizes_samples
[
i
]
;
if
(
codec_inst
.
pacsize
=
=
packet_size_samples
)
{
packet_size_ok
=
true
;
break
;
}
}
if
(
!
packet_size_ok
)
{
return
kInvalidPacketSize
;
}
}
if
(
codec_inst
.
pacsize
<
1
)
{
return
kInvalidPacketSize
;
}
*
mirror_id
=
codec_id
;
if
(
STR_CASE_CMP
(
"
isac
"
codec_inst
.
plname
)
=
=
0
)
{
if
(
IsISACRateValid
(
codec_inst
.
rate
)
)
{
*
mirror_id
=
kISAC
;
return
codec_id
;
}
else
{
return
kInvalidRate
;
}
}
else
if
(
STR_CASE_CMP
(
"
ilbc
"
codec_inst
.
plname
)
=
=
0
)
{
return
IsILBCRateValid
(
codec_inst
.
rate
codec_inst
.
pacsize
)
?
codec_id
:
kInvalidRate
;
}
else
if
(
STR_CASE_CMP
(
"
amr
"
codec_inst
.
plname
)
=
=
0
)
{
return
IsAMRRateValid
(
codec_inst
.
rate
)
?
codec_id
:
kInvalidRate
;
}
else
if
(
STR_CASE_CMP
(
"
amr
-
wb
"
codec_inst
.
plname
)
=
=
0
)
{
return
IsAMRwbRateValid
(
codec_inst
.
rate
)
?
codec_id
:
kInvalidRate
;
}
else
if
(
STR_CASE_CMP
(
"
g7291
"
codec_inst
.
plname
)
=
=
0
)
{
return
IsG7291RateValid
(
codec_inst
.
rate
)
?
codec_id
:
kInvalidRate
;
}
else
if
(
STR_CASE_CMP
(
"
opus
"
codec_inst
.
plname
)
=
=
0
)
{
return
IsOpusRateValid
(
codec_inst
.
rate
)
?
codec_id
:
kInvalidRate
;
}
else
if
(
STR_CASE_CMP
(
"
speex
"
codec_inst
.
plname
)
=
=
0
)
{
return
IsSpeexRateValid
(
codec_inst
.
rate
)
?
codec_id
:
kInvalidRate
;
}
return
IsRateValid
(
codec_id
codec_inst
.
rate
)
?
codec_id
:
kInvalidRate
;
}
int
ACMCodecDB
:
:
CodecId
(
const
CodecInst
&
codec_inst
)
{
return
(
CodecId
(
codec_inst
.
plname
codec_inst
.
plfreq
codec_inst
.
channels
)
)
;
}
int
ACMCodecDB
:
:
CodecId
(
const
char
*
payload_name
int
frequency
int
channels
)
{
for
(
int
id
=
0
;
id
<
kNumCodecs
;
id
+
+
)
{
bool
name_match
=
false
;
bool
frequency_match
=
false
;
bool
channels_match
=
false
;
name_match
=
(
STR_CASE_CMP
(
database_
[
id
]
.
plname
payload_name
)
=
=
0
)
;
frequency_match
=
(
frequency
=
=
database_
[
id
]
.
plfreq
)
|
|
(
frequency
=
=
-
1
)
;
if
(
STR_CASE_CMP
(
payload_name
"
opus
"
)
!
=
0
)
{
channels_match
=
(
channels
=
=
database_
[
id
]
.
channels
)
;
}
else
{
channels_match
=
(
channels
=
=
1
|
|
channels
=
=
2
)
;
}
if
(
name_match
&
&
frequency_match
&
&
channels_match
)
{
return
id
;
}
}
return
-
1
;
}
int
ACMCodecDB
:
:
ReceiverCodecNumber
(
const
CodecInst
&
codec_inst
int
*
mirror_id
)
{
int
codec_id
=
CodecId
(
codec_inst
)
;
if
(
STR_CASE_CMP
(
codec_inst
.
plname
"
ISAC
"
)
!
=
0
)
{
*
mirror_id
=
codec_id
;
}
else
{
*
mirror_id
=
kISAC
;
}
return
codec_id
;
}
int
ACMCodecDB
:
:
CodecFreq
(
int
codec_id
)
{
if
(
codec_id
<
0
|
|
codec_id
>
=
kNumCodecs
)
{
return
-
1
;
}
return
database_
[
codec_id
]
.
plfreq
;
}
int
ACMCodecDB
:
:
BasicCodingBlock
(
int
codec_id
)
{
if
(
codec_id
<
0
|
|
codec_id
>
=
kNumCodecs
)
{
return
-
1
;
}
return
codec_settings_
[
codec_id
]
.
basic_block_samples
;
}
const
NetEqDecoder
*
ACMCodecDB
:
:
NetEQDecoders
(
)
{
return
neteq_decoders_
;
}
int
ACMCodecDB
:
:
MirrorID
(
int
codec_id
)
{
if
(
STR_CASE_CMP
(
database_
[
codec_id
]
.
plname
"
isac
"
)
=
=
0
)
{
return
kISAC
;
}
else
{
return
codec_id
;
}
}
ACMGenericCodec
*
ACMCodecDB
:
:
CreateCodecInstance
(
const
CodecInst
&
codec_inst
int
cng_pt_nb
int
cng_pt_wb
int
cng_pt_swb
int
cng_pt_fb
bool
enable_red
int
red_payload_type
)
{
if
(
!
STR_CASE_CMP
(
codec_inst
.
plname
"
ISAC
"
)
)
{
#
if
(
defined
(
WEBRTC_CODEC_ISAC
)
|
|
defined
(
WEBRTC_CODEC_ISACFX
)
)
return
new
ACMGenericCodec
(
codec_inst
cng_pt_nb
cng_pt_wb
cng_pt_swb
cng_pt_fb
enable_red
red_payload_type
)
;
#
endif
}
else
if
(
!
STR_CASE_CMP
(
codec_inst
.
plname
"
PCMU
"
)
|
|
!
STR_CASE_CMP
(
codec_inst
.
plname
"
PCMA
"
)
)
{
return
new
ACMGenericCodec
(
codec_inst
cng_pt_nb
cng_pt_wb
cng_pt_swb
cng_pt_fb
enable_red
red_payload_type
)
;
}
else
if
(
!
STR_CASE_CMP
(
codec_inst
.
plname
"
ILBC
"
)
)
{
#
ifdef
WEBRTC_CODEC_ILBC
return
new
ACMGenericCodec
(
codec_inst
cng_pt_nb
cng_pt_wb
cng_pt_swb
cng_pt_fb
enable_red
red_payload_type
)
;
#
endif
}
else
if
(
!
STR_CASE_CMP
(
codec_inst
.
plname
"
G722
"
)
)
{
#
ifdef
WEBRTC_CODEC_G722
return
new
ACMGenericCodec
(
codec_inst
cng_pt_nb
cng_pt_wb
cng_pt_swb
cng_pt_fb
enable_red
red_payload_type
)
;
#
endif
}
else
if
(
!
STR_CASE_CMP
(
codec_inst
.
plname
"
opus
"
)
)
{
#
ifdef
WEBRTC_CODEC_OPUS
return
new
ACMGenericCodec
(
codec_inst
cng_pt_nb
cng_pt_wb
cng_pt_swb
cng_pt_fb
enable_red
red_payload_type
)
;
#
endif
}
else
if
(
!
STR_CASE_CMP
(
codec_inst
.
plname
"
L16
"
)
)
{
#
ifdef
WEBRTC_CODEC_PCM16
return
new
ACMGenericCodec
(
codec_inst
cng_pt_nb
cng_pt_wb
cng_pt_swb
cng_pt_fb
enable_red
red_payload_type
)
;
#
endif
}
return
NULL
;
}
bool
ACMCodecDB
:
:
IsRateValid
(
int
codec_id
int
rate
)
{
return
database_
[
codec_id
]
.
rate
=
=
rate
;
}
bool
ACMCodecDB
:
:
IsISACRateValid
(
int
rate
)
{
return
(
rate
=
=
-
1
)
|
|
(
(
rate
<
=
56000
)
&
&
(
rate
>
=
10000
)
)
;
}
bool
ACMCodecDB
:
:
IsILBCRateValid
(
int
rate
int
frame_size_samples
)
{
if
(
(
(
frame_size_samples
=
=
240
)
|
|
(
frame_size_samples
=
=
480
)
)
&
&
(
rate
=
=
13300
)
)
{
return
true
;
}
else
if
(
(
(
frame_size_samples
=
=
160
)
|
|
(
frame_size_samples
=
=
320
)
)
&
&
(
rate
=
=
15200
)
)
{
return
true
;
}
else
{
return
false
;
}
}
bool
ACMCodecDB
:
:
IsAMRRateValid
(
int
rate
)
{
switch
(
rate
)
{
case
4750
:
case
5150
:
case
5900
:
case
6700
:
case
7400
:
case
7950
:
case
10200
:
case
12200
:
{
return
true
;
}
default
:
{
return
false
;
}
}
}
bool
ACMCodecDB
:
:
IsAMRwbRateValid
(
int
rate
)
{
switch
(
rate
)
{
case
7000
:
case
9000
:
case
12000
:
case
14000
:
case
16000
:
case
18000
:
case
20000
:
case
23000
:
case
24000
:
{
return
true
;
}
default
:
{
return
false
;
}
}
}
bool
ACMCodecDB
:
:
IsG7291RateValid
(
int
rate
)
{
switch
(
rate
)
{
case
8000
:
case
12000
:
case
14000
:
case
16000
:
case
18000
:
case
20000
:
case
22000
:
case
24000
:
case
26000
:
case
28000
:
case
30000
:
case
32000
:
{
return
true
;
}
default
:
{
return
false
;
}
}
}
bool
ACMCodecDB
:
:
IsSpeexRateValid
(
int
rate
)
{
return
rate
>
2000
;
}
bool
ACMCodecDB
:
:
IsOpusRateValid
(
int
rate
)
{
return
(
rate
>
=
6000
)
&
&
(
rate
<
=
510000
)
;
}
bool
ACMCodecDB
:
:
ValidPayloadType
(
int
payload_type
)
{
return
(
payload_type
>
=
0
)
&
&
(
payload_type
<
=
127
)
;
}
bool
ACMCodecDB
:
:
OwnsDecoder
(
int
codec_id
)
{
assert
(
codec_id
>
=
0
&
&
codec_id
<
ACMCodecDB
:
:
kNumCodecs
)
;
return
ACMCodecDB
:
:
codec_settings_
[
codec_id
]
.
owns_decoder
;
}
}
}
