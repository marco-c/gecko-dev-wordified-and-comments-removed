#
ifndef
WEBRTC_MODULES_AUDIO_CODING_INCLUDE_AUDIO_CODING_MODULE_H_
#
define
WEBRTC_MODULES_AUDIO_CODING_INCLUDE_AUDIO_CODING_MODULE_H_
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
deprecation
.
h
"
#
include
"
webrtc
/
base
/
function_view
.
h
"
#
include
"
webrtc
/
base
/
optional
.
h
"
#
include
"
webrtc
/
common_types
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
codecs
/
audio_decoder_factory
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
include
/
audio_coding_module_typedefs
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
include
/
neteq
.
h
"
#
include
"
webrtc
/
modules
/
include
/
module
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
clock
.
h
"
#
include
"
webrtc
/
typedefs
.
h
"
namespace
webrtc
{
struct
CodecInst
;
struct
WebRtcRTPHeader
;
class
AudioDecoder
;
class
AudioEncoder
;
class
AudioFrame
;
class
RTPFragmentationHeader
;
#
define
WEBRTC_10MS_PCM_AUDIO
960
/
/
16
bits
super
wideband
48
kHz
class
AudioPacketizationCallback
{
public
:
virtual
~
AudioPacketizationCallback
(
)
{
}
virtual
int32_t
SendData
(
FrameType
frame_type
uint8_t
payload_type
uint32_t
timestamp
const
uint8_t
*
payload_data
size_t
payload_len_bytes
const
RTPFragmentationHeader
*
fragmentation
)
=
0
;
}
;
class
ACMVADCallback
{
public
:
virtual
~
ACMVADCallback
(
)
{
}
virtual
int32_t
InFrameType
(
FrameType
frame_type
)
=
0
;
}
;
class
AudioCodingModule
{
protected
:
AudioCodingModule
(
)
{
}
public
:
struct
Config
{
Config
(
)
;
Config
(
const
Config
&
)
;
~
Config
(
)
;
int
id
;
NetEq
:
:
Config
neteq_config
;
Clock
*
clock
;
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
;
}
;
static
AudioCodingModule
*
Create
(
int
id
)
;
static
AudioCodingModule
*
Create
(
int
id
Clock
*
clock
)
;
static
AudioCodingModule
*
Create
(
const
Config
&
config
)
;
virtual
~
AudioCodingModule
(
)
=
default
;
static
int
NumberOfCodecs
(
)
;
static
int
Codec
(
int
list_id
CodecInst
*
codec
)
;
static
int
Codec
(
const
char
*
payload_name
CodecInst
*
codec
int
sampling_freq_hz
size_t
channels
)
;
static
int
Codec
(
const
char
*
payload_name
int
sampling_freq_hz
size_t
channels
)
;
static
bool
IsCodecValid
(
const
CodecInst
&
codec
)
;
virtual
int32_t
RegisterSendCodec
(
const
CodecInst
&
send_codec
)
=
0
;
virtual
void
RegisterExternalSendCodec
(
AudioEncoder
*
external_speech_encoder
)
=
0
;
virtual
void
ModifyEncoder
(
rtc
:
:
FunctionView
<
void
(
std
:
:
unique_ptr
<
AudioEncoder
>
*
)
>
modifier
)
=
0
;
virtual
void
QueryEncoder
(
rtc
:
:
FunctionView
<
void
(
AudioEncoder
const
*
)
>
query
)
=
0
;
void
SetEncoder
(
std
:
:
unique_ptr
<
AudioEncoder
>
new_encoder
)
{
ModifyEncoder
(
[
&
]
(
std
:
:
unique_ptr
<
AudioEncoder
>
*
encoder
)
{
*
encoder
=
std
:
:
move
(
new_encoder
)
;
}
)
;
}
virtual
rtc
:
:
Optional
<
CodecInst
>
SendCodec
(
)
const
=
0
;
virtual
int32_t
SendFrequency
(
)
const
=
0
;
virtual
void
SetBitRate
(
int
bitrate_bps
)
=
0
;
virtual
int32_t
RegisterTransportCallback
(
AudioPacketizationCallback
*
transport
)
=
0
;
virtual
int32_t
Add10MsData
(
const
AudioFrame
&
audio_frame
)
=
0
;
virtual
int32_t
SetREDStatus
(
bool
enable_red
)
=
0
;
virtual
bool
REDStatus
(
)
const
=
0
;
virtual
int
SetCodecFEC
(
bool
enable_codec_fec
)
=
0
;
virtual
bool
CodecFEC
(
)
const
=
0
;
virtual
int
SetPacketLossRate
(
int
packet_loss_rate
)
=
0
;
virtual
int32_t
SetVAD
(
const
bool
enable_dtx
=
true
const
bool
enable_vad
=
false
const
ACMVADMode
vad_mode
=
VADNormal
)
=
0
;
virtual
int32_t
VAD
(
bool
*
dtx_enabled
bool
*
vad_enabled
ACMVADMode
*
vad_mode
)
const
=
0
;
virtual
int32_t
RegisterVADCallback
(
ACMVADCallback
*
vad_callback
)
=
0
;
virtual
int32_t
InitializeReceiver
(
)
=
0
;
virtual
int32_t
ReceiveFrequency
(
)
const
=
0
;
virtual
int32_t
PlayoutFrequency
(
)
const
=
0
;
virtual
bool
RegisterReceiveCodec
(
int
rtp_payload_type
const
SdpAudioFormat
&
audio_format
)
=
0
;
virtual
int
RegisterReceiveCodec
(
const
CodecInst
&
receive_codec
)
=
0
;
virtual
int
RegisterReceiveCodec
(
const
CodecInst
&
receive_codec
rtc
:
:
FunctionView
<
std
:
:
unique_ptr
<
AudioDecoder
>
(
)
>
isac_factory
)
=
0
;
virtual
int
RegisterExternalReceiveCodec
(
int
rtp_payload_type
AudioDecoder
*
external_decoder
int
sample_rate_hz
int
num_channels
const
std
:
:
string
&
name
)
=
0
;
virtual
int
UnregisterReceiveCodec
(
uint8_t
payload_type
)
=
0
;
virtual
int32_t
ReceiveCodec
(
CodecInst
*
curr_receive_codec
)
const
=
0
;
virtual
rtc
:
:
Optional
<
SdpAudioFormat
>
ReceiveFormat
(
)
const
=
0
;
virtual
int32_t
IncomingPacket
(
const
uint8_t
*
incoming_payload
const
size_t
payload_len_bytes
const
WebRtcRTPHeader
&
rtp_info
)
=
0
;
virtual
int32_t
IncomingPayload
(
const
uint8_t
*
incoming_payload
const
size_t
payload_len_byte
const
uint8_t
payload_type
const
uint32_t
timestamp
=
0
)
=
0
;
virtual
int
SetMinimumPlayoutDelay
(
int
time_ms
)
=
0
;
virtual
int
SetMaximumPlayoutDelay
(
int
time_ms
)
=
0
;
virtual
int
LeastRequiredDelayMs
(
)
const
=
0
;
RTC_DEPRECATED
virtual
int32_t
PlayoutTimestamp
(
uint32_t
*
timestamp
)
=
0
;
virtual
rtc
:
:
Optional
<
uint32_t
>
PlayoutTimestamp
(
)
=
0
;
virtual
int
FilteredCurrentDelayMs
(
)
const
=
0
;
virtual
int32_t
PlayoutData10Ms
(
int32_t
desired_freq_hz
AudioFrame
*
audio_frame
bool
*
muted
)
=
0
;
virtual
int32_t
PlayoutData10Ms
(
int32_t
desired_freq_hz
AudioFrame
*
audio_frame
)
=
0
;
virtual
int
SetOpusApplication
(
OpusApplicationMode
application
)
=
0
;
virtual
int
SetOpusMaxPlaybackRate
(
int
frequency_hz
)
=
0
;
virtual
int
EnableOpusDtx
(
)
=
0
;
virtual
int
DisableOpusDtx
(
)
=
0
;
virtual
int32_t
GetNetworkStatistics
(
NetworkStatistics
*
network_statistics
)
=
0
;
virtual
int
EnableNack
(
size_t
max_nack_list_size
)
=
0
;
virtual
void
DisableNack
(
)
=
0
;
virtual
std
:
:
vector
<
uint16_t
>
GetNackList
(
int64_t
round_trip_time_ms
)
const
=
0
;
virtual
void
GetDecodingCallStatistics
(
AudioDecodingCallStats
*
call_stats
)
const
=
0
;
}
;
}
#
endif
