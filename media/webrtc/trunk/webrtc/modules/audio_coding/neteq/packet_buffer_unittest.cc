#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
packet_buffer
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
codecs
/
builtin_audio_decoder_factory
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
mock
/
mock_decoder_database
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
packet
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
tick_timer
.
h
"
#
include
"
webrtc
/
test
/
gmock
.
h
"
#
include
"
webrtc
/
test
/
gtest
.
h
"
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
_
;
namespace
webrtc
{
class
PacketGenerator
{
public
:
PacketGenerator
(
uint16_t
seq_no
uint32_t
ts
uint8_t
pt
int
frame_size
)
;
virtual
~
PacketGenerator
(
)
{
}
void
Reset
(
uint16_t
seq_no
uint32_t
ts
uint8_t
pt
int
frame_size
)
;
Packet
NextPacket
(
int
payload_size_bytes
)
;
uint16_t
seq_no_
;
uint32_t
ts_
;
uint8_t
pt_
;
int
frame_size_
;
}
;
PacketGenerator
:
:
PacketGenerator
(
uint16_t
seq_no
uint32_t
ts
uint8_t
pt
int
frame_size
)
{
Reset
(
seq_no
ts
pt
frame_size
)
;
}
void
PacketGenerator
:
:
Reset
(
uint16_t
seq_no
uint32_t
ts
uint8_t
pt
int
frame_size
)
{
seq_no_
=
seq_no
;
ts_
=
ts
;
pt_
=
pt
;
frame_size_
=
frame_size
;
}
Packet
PacketGenerator
:
:
NextPacket
(
int
payload_size_bytes
)
{
Packet
packet
;
packet
.
sequence_number
=
seq_no_
;
packet
.
timestamp
=
ts_
;
packet
.
payload_type
=
pt_
;
packet
.
payload
.
SetSize
(
payload_size_bytes
)
;
+
+
seq_no_
;
ts_
+
=
frame_size_
;
return
packet
;
}
struct
PacketsToInsert
{
uint16_t
sequence_number
;
uint32_t
timestamp
;
uint8_t
payload_type
;
bool
primary
;
int
extract_order
;
}
;
TEST
(
PacketBuffer
CreateAndDestroy
)
{
TickTimer
tick_timer
;
PacketBuffer
*
buffer
=
new
PacketBuffer
(
10
&
tick_timer
)
;
EXPECT_TRUE
(
buffer
-
>
Empty
(
)
)
;
delete
buffer
;
}
TEST
(
PacketBuffer
InsertPacket
)
{
TickTimer
tick_timer
;
PacketBuffer
buffer
(
10
&
tick_timer
)
;
PacketGenerator
gen
(
17u
4711u
0
10
)
;
const
int
payload_len
=
100
;
const
Packet
packet
=
gen
.
NextPacket
(
payload_len
)
;
EXPECT_EQ
(
0
buffer
.
InsertPacket
(
packet
.
Clone
(
)
)
)
;
uint32_t
next_ts
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
NextTimestamp
(
&
next_ts
)
)
;
EXPECT_EQ
(
4711u
next_ts
)
;
EXPECT_FALSE
(
buffer
.
Empty
(
)
)
;
EXPECT_EQ
(
1u
buffer
.
NumPacketsInBuffer
(
)
)
;
const
Packet
*
next_packet
=
buffer
.
PeekNextPacket
(
)
;
EXPECT_EQ
(
packet
*
next_packet
)
;
}
TEST
(
PacketBuffer
FlushBuffer
)
{
TickTimer
tick_timer
;
PacketBuffer
buffer
(
10
&
tick_timer
)
;
PacketGenerator
gen
(
0
0
0
10
)
;
const
int
payload_len
=
10
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
InsertPacket
(
gen
.
NextPacket
(
payload_len
)
)
)
;
}
EXPECT_EQ
(
10u
buffer
.
NumPacketsInBuffer
(
)
)
;
EXPECT_FALSE
(
buffer
.
Empty
(
)
)
;
buffer
.
Flush
(
)
;
EXPECT_EQ
(
0u
buffer
.
NumPacketsInBuffer
(
)
)
;
EXPECT_TRUE
(
buffer
.
Empty
(
)
)
;
}
TEST
(
PacketBuffer
OverfillBuffer
)
{
TickTimer
tick_timer
;
PacketBuffer
buffer
(
10
&
tick_timer
)
;
PacketGenerator
gen
(
0
0
0
10
)
;
const
int
payload_len
=
10
;
int
i
;
for
(
i
=
0
;
i
<
10
;
+
+
i
)
{
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
InsertPacket
(
gen
.
NextPacket
(
payload_len
)
)
)
;
}
EXPECT_EQ
(
10u
buffer
.
NumPacketsInBuffer
(
)
)
;
uint32_t
next_ts
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
NextTimestamp
(
&
next_ts
)
)
;
EXPECT_EQ
(
0u
next_ts
)
;
const
Packet
packet
=
gen
.
NextPacket
(
payload_len
)
;
EXPECT_EQ
(
PacketBuffer
:
:
kFlushed
buffer
.
InsertPacket
(
packet
.
Clone
(
)
)
)
;
EXPECT_EQ
(
1u
buffer
.
NumPacketsInBuffer
(
)
)
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
NextTimestamp
(
&
next_ts
)
)
;
EXPECT_EQ
(
packet
.
timestamp
next_ts
)
;
buffer
.
Flush
(
)
;
}
TEST
(
PacketBuffer
InsertPacketList
)
{
TickTimer
tick_timer
;
PacketBuffer
buffer
(
10
&
tick_timer
)
;
PacketGenerator
gen
(
0
0
0
10
)
;
PacketList
list
;
const
int
payload_len
=
10
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
list
.
push_back
(
gen
.
NextPacket
(
payload_len
)
)
;
}
MockDecoderDatabase
decoder_database
;
auto
factory
=
CreateBuiltinAudioDecoderFactory
(
)
;
const
DecoderDatabase
:
:
DecoderInfo
info
(
NetEqDecoder
:
:
kDecoderPCMu
factory
)
;
EXPECT_CALL
(
decoder_database
GetDecoderInfo
(
0
)
)
.
WillRepeatedly
(
Return
(
&
info
)
)
;
rtc
:
:
Optional
<
uint8_t
>
current_pt
;
rtc
:
:
Optional
<
uint8_t
>
current_cng_pt
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
InsertPacketList
(
&
list
decoder_database
&
current_pt
&
current_cng_pt
)
)
;
EXPECT_TRUE
(
list
.
empty
(
)
)
;
EXPECT_EQ
(
10u
buffer
.
NumPacketsInBuffer
(
)
)
;
EXPECT_EQ
(
rtc
:
:
Optional
<
uint8_t
>
(
0
)
current_pt
)
;
EXPECT_FALSE
(
current_cng_pt
)
;
buffer
.
Flush
(
)
;
EXPECT_CALL
(
decoder_database
Die
(
)
)
;
}
TEST
(
PacketBuffer
InsertPacketListChangePayloadType
)
{
TickTimer
tick_timer
;
PacketBuffer
buffer
(
10
&
tick_timer
)
;
PacketGenerator
gen
(
0
0
0
10
)
;
PacketList
list
;
const
int
payload_len
=
10
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
list
.
push_back
(
gen
.
NextPacket
(
payload_len
)
)
;
}
{
Packet
packet
=
gen
.
NextPacket
(
payload_len
)
;
packet
.
payload_type
=
1
;
list
.
push_back
(
std
:
:
move
(
packet
)
)
;
}
MockDecoderDatabase
decoder_database
;
auto
factory
=
CreateBuiltinAudioDecoderFactory
(
)
;
const
DecoderDatabase
:
:
DecoderInfo
info0
(
NetEqDecoder
:
:
kDecoderPCMu
factory
)
;
EXPECT_CALL
(
decoder_database
GetDecoderInfo
(
0
)
)
.
WillRepeatedly
(
Return
(
&
info0
)
)
;
const
DecoderDatabase
:
:
DecoderInfo
info1
(
NetEqDecoder
:
:
kDecoderPCMa
factory
)
;
EXPECT_CALL
(
decoder_database
GetDecoderInfo
(
1
)
)
.
WillRepeatedly
(
Return
(
&
info1
)
)
;
rtc
:
:
Optional
<
uint8_t
>
current_pt
;
rtc
:
:
Optional
<
uint8_t
>
current_cng_pt
;
EXPECT_EQ
(
PacketBuffer
:
:
kFlushed
buffer
.
InsertPacketList
(
&
list
decoder_database
&
current_pt
&
current_cng_pt
)
)
;
EXPECT_TRUE
(
list
.
empty
(
)
)
;
EXPECT_EQ
(
1u
buffer
.
NumPacketsInBuffer
(
)
)
;
EXPECT_EQ
(
rtc
:
:
Optional
<
uint8_t
>
(
1
)
current_pt
)
;
EXPECT_FALSE
(
current_cng_pt
)
;
buffer
.
Flush
(
)
;
EXPECT_CALL
(
decoder_database
Die
(
)
)
;
}
TEST
(
PacketBuffer
ExtractOrderRedundancy
)
{
TickTimer
tick_timer
;
PacketBuffer
buffer
(
100
&
tick_timer
)
;
const
int
kPackets
=
18
;
const
int
kFrameSize
=
10
;
const
int
kPayloadLength
=
10
;
PacketsToInsert
packet_facts
[
kPackets
]
=
{
{
0xFFFD
0xFFFFFFD7
0
true
0
}
{
0xFFFE
0xFFFFFFE1
0
true
1
}
{
0xFFFE
0xFFFFFFD7
1
false
-
1
}
{
0xFFFF
0xFFFFFFEB
0
true
2
}
{
0xFFFF
0xFFFFFFE1
1
false
-
1
}
{
0x0000
0xFFFFFFF5
0
true
3
}
{
0x0000
0xFFFFFFEB
1
false
-
1
}
{
0x0001
0xFFFFFFFF
0
true
4
}
{
0x0001
0xFFFFFFF5
1
false
-
1
}
{
0x0002
0x0000000A
0
true
5
}
{
0x0002
0xFFFFFFFF
1
false
-
1
}
{
0x0003
0x0000000A
1
false
-
1
}
{
0x0004
0x0000001E
0
true
7
}
{
0x0004
0x00000014
1
false
6
}
{
0x0005
0x0000001E
0
true
-
1
}
{
0x0005
0x00000014
1
false
-
1
}
{
0x0006
0x00000028
0
true
8
}
{
0x0006
0x0000001E
1
false
-
1
}
}
;
const
size_t
kExpectPacketsInBuffer
=
9
;
std
:
:
vector
<
Packet
>
expect_order
(
kExpectPacketsInBuffer
)
;
PacketGenerator
gen
(
0
0
0
kFrameSize
)
;
for
(
int
i
=
0
;
i
<
kPackets
;
+
+
i
)
{
gen
.
Reset
(
packet_facts
[
i
]
.
sequence_number
packet_facts
[
i
]
.
timestamp
packet_facts
[
i
]
.
payload_type
kFrameSize
)
;
Packet
packet
=
gen
.
NextPacket
(
kPayloadLength
)
;
packet
.
priority
.
red_level
=
packet_facts
[
i
]
.
primary
?
0
:
1
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
InsertPacket
(
packet
.
Clone
(
)
)
)
;
if
(
packet_facts
[
i
]
.
extract_order
>
=
0
)
{
expect_order
[
packet_facts
[
i
]
.
extract_order
]
=
std
:
:
move
(
packet
)
;
}
}
EXPECT_EQ
(
kExpectPacketsInBuffer
buffer
.
NumPacketsInBuffer
(
)
)
;
for
(
size_t
i
=
0
;
i
<
kExpectPacketsInBuffer
;
+
+
i
)
{
const
rtc
:
:
Optional
<
Packet
>
packet
=
buffer
.
GetNextPacket
(
)
;
EXPECT_EQ
(
packet
expect_order
[
i
]
)
;
}
EXPECT_TRUE
(
buffer
.
Empty
(
)
)
;
}
TEST
(
PacketBuffer
DiscardPackets
)
{
TickTimer
tick_timer
;
PacketBuffer
buffer
(
100
&
tick_timer
)
;
const
uint16_t
start_seq_no
=
17
;
const
uint32_t
start_ts
=
4711
;
const
uint32_t
ts_increment
=
10
;
PacketGenerator
gen
(
start_seq_no
start_ts
0
ts_increment
)
;
PacketList
list
;
const
int
payload_len
=
10
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
buffer
.
InsertPacket
(
gen
.
NextPacket
(
payload_len
)
)
;
}
EXPECT_EQ
(
10u
buffer
.
NumPacketsInBuffer
(
)
)
;
uint32_t
current_ts
=
start_ts
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
uint32_t
ts
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
NextTimestamp
(
&
ts
)
)
;
EXPECT_EQ
(
current_ts
ts
)
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
DiscardNextPacket
(
)
)
;
current_ts
+
=
ts_increment
;
}
EXPECT_TRUE
(
buffer
.
Empty
(
)
)
;
}
TEST
(
PacketBuffer
Reordering
)
{
TickTimer
tick_timer
;
PacketBuffer
buffer
(
100
&
tick_timer
)
;
const
uint16_t
start_seq_no
=
17
;
const
uint32_t
start_ts
=
4711
;
const
uint32_t
ts_increment
=
10
;
PacketGenerator
gen
(
start_seq_no
start_ts
0
ts_increment
)
;
const
int
payload_len
=
10
;
PacketList
list
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
Packet
packet
=
gen
.
NextPacket
(
payload_len
)
;
if
(
i
%
2
)
{
list
.
push_front
(
std
:
:
move
(
packet
)
)
;
}
else
{
list
.
push_back
(
std
:
:
move
(
packet
)
)
;
}
}
MockDecoderDatabase
decoder_database
;
auto
factory
=
CreateBuiltinAudioDecoderFactory
(
)
;
const
DecoderDatabase
:
:
DecoderInfo
info
(
NetEqDecoder
:
:
kDecoderPCMu
factory
)
;
EXPECT_CALL
(
decoder_database
GetDecoderInfo
(
0
)
)
.
WillRepeatedly
(
Return
(
&
info
)
)
;
rtc
:
:
Optional
<
uint8_t
>
current_pt
;
rtc
:
:
Optional
<
uint8_t
>
current_cng_pt
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
InsertPacketList
(
&
list
decoder_database
&
current_pt
&
current_cng_pt
)
)
;
EXPECT_EQ
(
10u
buffer
.
NumPacketsInBuffer
(
)
)
;
uint32_t
current_ts
=
start_ts
;
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
const
rtc
:
:
Optional
<
Packet
>
packet
=
buffer
.
GetNextPacket
(
)
;
ASSERT_TRUE
(
packet
)
;
EXPECT_EQ
(
current_ts
packet
-
>
timestamp
)
;
current_ts
+
=
ts_increment
;
}
EXPECT_TRUE
(
buffer
.
Empty
(
)
)
;
EXPECT_CALL
(
decoder_database
Die
(
)
)
;
}
TEST
(
PacketBuffer
CngFirstThenSpeechWithNewSampleRate
)
{
TickTimer
tick_timer
;
PacketBuffer
buffer
(
10
&
tick_timer
)
;
const
uint8_t
kCngPt
=
13
;
const
int
kPayloadLen
=
10
;
const
uint8_t
kSpeechPt
=
100
;
MockDecoderDatabase
decoder_database
;
auto
factory
=
CreateBuiltinAudioDecoderFactory
(
)
;
const
DecoderDatabase
:
:
DecoderInfo
info_cng
(
NetEqDecoder
:
:
kDecoderCNGnb
factory
)
;
EXPECT_CALL
(
decoder_database
GetDecoderInfo
(
kCngPt
)
)
.
WillRepeatedly
(
Return
(
&
info_cng
)
)
;
const
DecoderDatabase
:
:
DecoderInfo
info_speech
(
NetEqDecoder
:
:
kDecoderPCM16Bwb
factory
)
;
EXPECT_CALL
(
decoder_database
GetDecoderInfo
(
kSpeechPt
)
)
.
WillRepeatedly
(
Return
(
&
info_speech
)
)
;
PacketGenerator
gen
(
0
0
kCngPt
10
)
;
PacketList
list
;
list
.
push_back
(
gen
.
NextPacket
(
kPayloadLen
)
)
;
rtc
:
:
Optional
<
uint8_t
>
current_pt
;
rtc
:
:
Optional
<
uint8_t
>
current_cng_pt
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
.
InsertPacketList
(
&
list
decoder_database
&
current_pt
&
current_cng_pt
)
)
;
EXPECT_TRUE
(
list
.
empty
(
)
)
;
EXPECT_EQ
(
1u
buffer
.
NumPacketsInBuffer
(
)
)
;
ASSERT_TRUE
(
buffer
.
PeekNextPacket
(
)
)
;
EXPECT_EQ
(
kCngPt
buffer
.
PeekNextPacket
(
)
-
>
payload_type
)
;
EXPECT_FALSE
(
current_pt
)
;
EXPECT_EQ
(
rtc
:
:
Optional
<
uint8_t
>
(
kCngPt
)
current_cng_pt
)
;
{
Packet
packet
=
gen
.
NextPacket
(
kPayloadLen
)
;
packet
.
payload_type
=
kSpeechPt
;
list
.
push_back
(
std
:
:
move
(
packet
)
)
;
}
EXPECT_EQ
(
PacketBuffer
:
:
kFlushed
buffer
.
InsertPacketList
(
&
list
decoder_database
&
current_pt
&
current_cng_pt
)
)
;
EXPECT_TRUE
(
list
.
empty
(
)
)
;
EXPECT_EQ
(
1u
buffer
.
NumPacketsInBuffer
(
)
)
;
ASSERT_TRUE
(
buffer
.
PeekNextPacket
(
)
)
;
EXPECT_EQ
(
kSpeechPt
buffer
.
PeekNextPacket
(
)
-
>
payload_type
)
;
EXPECT_EQ
(
rtc
:
:
Optional
<
uint8_t
>
(
kSpeechPt
)
current_pt
)
;
EXPECT_FALSE
(
current_cng_pt
)
;
buffer
.
Flush
(
)
;
EXPECT_CALL
(
decoder_database
Die
(
)
)
;
}
TEST
(
PacketBuffer
Failures
)
{
const
uint16_t
start_seq_no
=
17
;
const
uint32_t
start_ts
=
4711
;
const
uint32_t
ts_increment
=
10
;
int
payload_len
=
100
;
PacketGenerator
gen
(
start_seq_no
start_ts
0
ts_increment
)
;
TickTimer
tick_timer
;
PacketBuffer
*
buffer
=
new
PacketBuffer
(
100
&
tick_timer
)
;
{
Packet
packet
=
gen
.
NextPacket
(
payload_len
)
;
packet
.
payload
.
Clear
(
)
;
EXPECT_EQ
(
PacketBuffer
:
:
kInvalidPacket
buffer
-
>
InsertPacket
(
std
:
:
move
(
packet
)
)
)
;
}
uint32_t
temp_ts
;
EXPECT_EQ
(
PacketBuffer
:
:
kBufferEmpty
buffer
-
>
NextTimestamp
(
&
temp_ts
)
)
;
EXPECT_EQ
(
PacketBuffer
:
:
kBufferEmpty
buffer
-
>
NextHigherTimestamp
(
0
&
temp_ts
)
)
;
EXPECT_EQ
(
NULL
buffer
-
>
PeekNextPacket
(
)
)
;
EXPECT_FALSE
(
buffer
-
>
GetNextPacket
(
)
)
;
EXPECT_EQ
(
PacketBuffer
:
:
kBufferEmpty
buffer
-
>
DiscardNextPacket
(
)
)
;
EXPECT_EQ
(
0
buffer
-
>
DiscardAllOldPackets
(
0
)
)
;
EXPECT_EQ
(
PacketBuffer
:
:
kOK
buffer
-
>
InsertPacket
(
gen
.
NextPacket
(
payload_len
)
)
)
;
EXPECT_EQ
(
PacketBuffer
:
:
kInvalidPointer
buffer
-
>
NextTimestamp
(
NULL
)
)
;
EXPECT_EQ
(
PacketBuffer
:
:
kInvalidPointer
buffer
-
>
NextHigherTimestamp
(
0
NULL
)
)
;
delete
buffer
;
buffer
=
new
PacketBuffer
(
100
&
tick_timer
)
;
PacketList
list
;
list
.
push_back
(
gen
.
NextPacket
(
payload_len
)
)
;
{
Packet
packet
=
gen
.
NextPacket
(
payload_len
)
;
packet
.
payload
.
Clear
(
)
;
list
.
push_back
(
std
:
:
move
(
packet
)
)
;
}
list
.
push_back
(
gen
.
NextPacket
(
payload_len
)
)
;
MockDecoderDatabase
decoder_database
;
auto
factory
=
CreateBuiltinAudioDecoderFactory
(
)
;
const
DecoderDatabase
:
:
DecoderInfo
info
(
NetEqDecoder
:
:
kDecoderPCMu
factory
)
;
EXPECT_CALL
(
decoder_database
GetDecoderInfo
(
0
)
)
.
WillRepeatedly
(
Return
(
&
info
)
)
;
rtc
:
:
Optional
<
uint8_t
>
current_pt
;
rtc
:
:
Optional
<
uint8_t
>
current_cng_pt
;
EXPECT_EQ
(
PacketBuffer
:
:
kInvalidPacket
buffer
-
>
InsertPacketList
(
&
list
decoder_database
&
current_pt
&
current_cng_pt
)
)
;
EXPECT_TRUE
(
list
.
empty
(
)
)
;
EXPECT_EQ
(
1u
buffer
-
>
NumPacketsInBuffer
(
)
)
;
delete
buffer
;
EXPECT_CALL
(
decoder_database
Die
(
)
)
;
}
TEST
(
PacketBuffer
ComparePackets
)
{
PacketGenerator
gen
(
0
0
0
10
)
;
Packet
a
(
gen
.
NextPacket
(
10
)
)
;
Packet
b
(
gen
.
NextPacket
(
10
)
)
;
EXPECT_FALSE
(
a
=
=
b
)
;
EXPECT_TRUE
(
a
!
=
b
)
;
EXPECT_TRUE
(
a
<
b
)
;
EXPECT_FALSE
(
a
>
b
)
;
EXPECT_TRUE
(
a
<
=
b
)
;
EXPECT_FALSE
(
a
>
=
b
)
;
a
.
timestamp
=
0xFFFFFFFF
-
10
;
EXPECT_FALSE
(
a
=
=
b
)
;
EXPECT_TRUE
(
a
!
=
b
)
;
EXPECT_TRUE
(
a
<
b
)
;
EXPECT_FALSE
(
a
>
b
)
;
EXPECT_TRUE
(
a
<
=
b
)
;
EXPECT_FALSE
(
a
>
=
b
)
;
EXPECT_TRUE
(
a
=
=
a
)
;
EXPECT_FALSE
(
a
!
=
a
)
;
EXPECT_FALSE
(
a
<
a
)
;
EXPECT_FALSE
(
a
>
a
)
;
EXPECT_TRUE
(
a
<
=
a
)
;
EXPECT_TRUE
(
a
>
=
a
)
;
a
.
timestamp
=
b
.
timestamp
;
EXPECT_FALSE
(
a
=
=
b
)
;
EXPECT_TRUE
(
a
!
=
b
)
;
EXPECT_TRUE
(
a
<
b
)
;
EXPECT_FALSE
(
a
>
b
)
;
EXPECT_TRUE
(
a
<
=
b
)
;
EXPECT_FALSE
(
a
>
=
b
)
;
a
.
sequence_number
=
0xFFFF
;
EXPECT_FALSE
(
a
=
=
b
)
;
EXPECT_TRUE
(
a
!
=
b
)
;
EXPECT_TRUE
(
a
<
b
)
;
EXPECT_FALSE
(
a
>
b
)
;
EXPECT_TRUE
(
a
<
=
b
)
;
EXPECT_FALSE
(
a
>
=
b
)
;
a
.
sequence_number
=
b
.
sequence_number
;
a
.
priority
=
{
1
0
}
;
b
.
priority
=
{
0
0
}
;
EXPECT_FALSE
(
a
=
=
b
)
;
EXPECT_TRUE
(
a
!
=
b
)
;
EXPECT_FALSE
(
a
<
b
)
;
EXPECT_TRUE
(
a
>
b
)
;
EXPECT_FALSE
(
a
<
=
b
)
;
EXPECT_TRUE
(
a
>
=
b
)
;
Packet
c
(
gen
.
NextPacket
(
0
)
)
;
Packet
d
(
gen
.
NextPacket
(
0
)
)
;
c
.
timestamp
=
b
.
timestamp
;
d
.
timestamp
=
b
.
timestamp
;
c
.
sequence_number
=
b
.
sequence_number
;
d
.
sequence_number
=
b
.
sequence_number
;
c
.
priority
=
{
1
1
}
;
d
.
priority
=
{
0
1
}
;
EXPECT_FALSE
(
c
=
=
d
)
;
EXPECT_TRUE
(
c
!
=
d
)
;
EXPECT_FALSE
(
c
<
d
)
;
EXPECT_TRUE
(
c
>
d
)
;
EXPECT_FALSE
(
c
<
=
d
)
;
EXPECT_TRUE
(
c
>
=
d
)
;
EXPECT_FALSE
(
c
=
=
a
)
;
EXPECT_TRUE
(
c
!
=
a
)
;
EXPECT_FALSE
(
c
<
a
)
;
EXPECT_TRUE
(
c
>
a
)
;
EXPECT_FALSE
(
c
<
=
a
)
;
EXPECT_TRUE
(
c
>
=
a
)
;
EXPECT_FALSE
(
c
=
=
b
)
;
EXPECT_TRUE
(
c
!
=
b
)
;
EXPECT_FALSE
(
c
<
b
)
;
EXPECT_TRUE
(
c
>
b
)
;
EXPECT_FALSE
(
c
<
=
b
)
;
EXPECT_TRUE
(
c
>
=
b
)
;
EXPECT_FALSE
(
a
=
=
d
)
;
EXPECT_TRUE
(
a
!
=
d
)
;
EXPECT_FALSE
(
a
<
d
)
;
EXPECT_TRUE
(
a
>
d
)
;
EXPECT_FALSE
(
a
<
=
d
)
;
EXPECT_TRUE
(
a
>
=
d
)
;
EXPECT_FALSE
(
d
=
=
b
)
;
EXPECT_TRUE
(
d
!
=
b
)
;
EXPECT_FALSE
(
d
<
b
)
;
EXPECT_TRUE
(
d
>
b
)
;
EXPECT_FALSE
(
d
<
=
b
)
;
EXPECT_TRUE
(
d
>
=
b
)
;
}
namespace
{
void
TestIsObsoleteTimestamp
(
uint32_t
limit_timestamp
)
{
static
const
uint32_t
kZeroHorizon
=
0
;
static
const
uint32_t
k2Pow31Minus1
=
0x7FFFFFFF
;
EXPECT_FALSE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
limit_timestamp
kZeroHorizon
)
)
;
EXPECT_TRUE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
-
1
limit_timestamp
kZeroHorizon
)
)
;
EXPECT_TRUE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
-
k2Pow31Minus1
limit_timestamp
kZeroHorizon
)
)
;
EXPECT_FALSE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
+
1
limit_timestamp
kZeroHorizon
)
)
;
uint32_t
other_timestamp
=
limit_timestamp
+
(
1
<
<
31
)
;
uint32_t
lowest_timestamp
=
std
:
:
min
(
limit_timestamp
other_timestamp
)
;
uint32_t
highest_timestamp
=
std
:
:
max
(
limit_timestamp
other_timestamp
)
;
EXPECT_TRUE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
lowest_timestamp
highest_timestamp
kZeroHorizon
)
)
;
EXPECT_FALSE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
highest_timestamp
lowest_timestamp
kZeroHorizon
)
)
;
static
const
uint32_t
kHorizon
=
10
;
EXPECT_FALSE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
limit_timestamp
kHorizon
)
)
;
EXPECT_TRUE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
-
1
limit_timestamp
kHorizon
)
)
;
EXPECT_TRUE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
-
9
limit_timestamp
kHorizon
)
)
;
EXPECT_FALSE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
-
10
limit_timestamp
kHorizon
)
)
;
EXPECT_FALSE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
-
k2Pow31Minus1
limit_timestamp
kHorizon
)
)
;
EXPECT_FALSE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
+
1
limit_timestamp
kHorizon
)
)
;
EXPECT_FALSE
(
PacketBuffer
:
:
IsObsoleteTimestamp
(
limit_timestamp
+
(
1
<
<
31
)
limit_timestamp
kHorizon
)
)
;
}
}
TEST
(
PacketBuffer
IsObsoleteTimestamp
)
{
TestIsObsoleteTimestamp
(
0
)
;
TestIsObsoleteTimestamp
(
1
)
;
TestIsObsoleteTimestamp
(
0xFFFFFFFF
)
;
TestIsObsoleteTimestamp
(
0x80000000
)
;
TestIsObsoleteTimestamp
(
0x80000001
)
;
TestIsObsoleteTimestamp
(
0x7FFFFFFF
)
;
}
}
