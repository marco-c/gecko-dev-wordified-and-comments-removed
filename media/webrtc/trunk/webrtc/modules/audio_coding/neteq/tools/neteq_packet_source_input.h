#
ifndef
MODULES_AUDIO_CODING_NETEQ_TOOLS_NETEQ_PACKET_SOURCE_INPUT_H_
#
define
MODULES_AUDIO_CODING_NETEQ_TOOLS_NETEQ_PACKET_SOURCE_INPUT_H_
#
include
<
map
>
#
include
<
string
>
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
neteq_input
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
namespace
webrtc
{
namespace
test
{
class
RtpFileSource
;
class
RtcEventLogSource
;
class
NetEqPacketSourceInput
:
public
NetEqInput
{
public
:
using
RtpHeaderExtensionMap
=
std
:
:
map
<
int
webrtc
:
:
RTPExtensionType
>
;
NetEqPacketSourceInput
(
)
;
rtc
:
:
Optional
<
int64_t
>
NextPacketTime
(
)
const
override
;
std
:
:
unique_ptr
<
PacketData
>
PopPacket
(
)
override
;
rtc
:
:
Optional
<
RTPHeader
>
NextHeader
(
)
const
override
;
bool
ended
(
)
const
override
{
return
!
next_output_event_ms_
;
}
protected
:
virtual
PacketSource
*
source
(
)
=
0
;
void
LoadNextPacket
(
)
;
rtc
:
:
Optional
<
int64_t
>
next_output_event_ms_
;
private
:
std
:
:
unique_ptr
<
Packet
>
packet_
;
}
;
class
NetEqRtpDumpInput
final
:
public
NetEqPacketSourceInput
{
public
:
NetEqRtpDumpInput
(
const
std
:
:
string
&
file_name
const
RtpHeaderExtensionMap
&
hdr_ext_map
)
;
rtc
:
:
Optional
<
int64_t
>
NextOutputEventTime
(
)
const
override
;
void
AdvanceOutputEvent
(
)
override
;
protected
:
PacketSource
*
source
(
)
override
;
private
:
static
constexpr
int64_t
kOutputPeriodMs
=
10
;
std
:
:
unique_ptr
<
RtpFileSource
>
source_
;
}
;
class
NetEqEventLogInput
final
:
public
NetEqPacketSourceInput
{
public
:
NetEqEventLogInput
(
const
std
:
:
string
&
file_name
const
RtpHeaderExtensionMap
&
hdr_ext_map
)
;
rtc
:
:
Optional
<
int64_t
>
NextOutputEventTime
(
)
const
override
;
void
AdvanceOutputEvent
(
)
override
;
protected
:
PacketSource
*
source
(
)
override
;
private
:
std
:
:
unique_ptr
<
RtcEventLogSource
>
source_
;
}
;
}
}
#
endif
