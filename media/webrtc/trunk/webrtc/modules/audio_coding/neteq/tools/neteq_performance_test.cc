#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
neteq_performance_test
.
h
"
#
include
"
api
/
audio_codecs
/
builtin_audio_decoder_factory
.
h
"
#
include
"
common_types
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
pcm16b
/
pcm16b
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
include
/
neteq
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
audio_loop
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
rtp_generator
.
h
"
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
#
include
"
test
/
testsupport
/
fileutils
.
h
"
#
include
"
typedefs
.
h
"
using
webrtc
:
:
NetEq
;
using
webrtc
:
:
test
:
:
AudioLoop
;
using
webrtc
:
:
test
:
:
RtpGenerator
;
namespace
webrtc
{
namespace
test
{
int64_t
NetEqPerformanceTest
:
:
Run
(
int
runtime_ms
int
lossrate
double
drift_factor
)
{
const
std
:
:
string
kInputFileName
=
webrtc
:
:
test
:
:
ResourcePath
(
"
audio_coding
/
testfile32kHz
"
"
pcm
"
)
;
const
int
kSampRateHz
=
32000
;
const
webrtc
:
:
NetEqDecoder
kDecoderType
=
webrtc
:
:
NetEqDecoder
:
:
kDecoderPCM16Bswb32kHz
;
const
std
:
:
string
kDecoderName
=
"
pcm16
-
swb32
"
;
const
int
kPayloadType
=
95
;
NetEq
:
:
Config
config
;
config
.
sample_rate_hz
=
kSampRateHz
;
NetEq
*
neteq
=
NetEq
:
:
Create
(
config
CreateBuiltinAudioDecoderFactory
(
)
)
;
if
(
neteq
-
>
RegisterPayloadType
(
kDecoderType
kDecoderName
kPayloadType
)
!
=
0
)
return
-
1
;
AudioLoop
audio_loop
;
const
size_t
kMaxLoopLengthSamples
=
kSampRateHz
*
10
;
const
size_t
kInputBlockSizeSamples
=
60
*
kSampRateHz
/
1000
;
if
(
!
audio_loop
.
Init
(
kInputFileName
kMaxLoopLengthSamples
kInputBlockSizeSamples
)
)
return
-
1
;
int32_t
time_now_ms
=
0
;
RTPHeader
rtp_header
;
RtpGenerator
rtp_gen
(
kSampRateHz
/
1000
)
;
rtp_gen
.
set_drift_factor
(
drift_factor
)
;
bool
drift_flipped
=
false
;
int32_t
packet_input_time_ms
=
rtp_gen
.
GetRtpHeader
(
kPayloadType
kInputBlockSizeSamples
&
rtp_header
)
;
auto
input_samples
=
audio_loop
.
GetNextBlock
(
)
;
if
(
input_samples
.
empty
(
)
)
exit
(
1
)
;
uint8_t
input_payload
[
kInputBlockSizeSamples
*
sizeof
(
int16_t
)
]
;
size_t
payload_len
=
WebRtcPcm16b_Encode
(
input_samples
.
data
(
)
input_samples
.
size
(
)
input_payload
)
;
RTC_CHECK_EQ
(
sizeof
(
input_payload
)
payload_len
)
;
webrtc
:
:
Clock
*
clock
=
webrtc
:
:
Clock
:
:
GetRealTimeClock
(
)
;
int64_t
start_time_ms
=
clock
-
>
TimeInMilliseconds
(
)
;
AudioFrame
out_frame
;
while
(
time_now_ms
<
runtime_ms
)
{
while
(
packet_input_time_ms
<
=
time_now_ms
)
{
bool
lost
=
false
;
if
(
lossrate
>
0
)
{
lost
=
(
(
rtp_header
.
sequenceNumber
-
1
)
%
lossrate
)
=
=
0
;
}
if
(
!
lost
)
{
int
error
=
neteq
-
>
InsertPacket
(
rtp_header
input_payload
packet_input_time_ms
*
kSampRateHz
/
1000
)
;
if
(
error
!
=
NetEq
:
:
kOK
)
return
-
1
;
}
packet_input_time_ms
=
rtp_gen
.
GetRtpHeader
(
kPayloadType
kInputBlockSizeSamples
&
rtp_header
)
;
input_samples
=
audio_loop
.
GetNextBlock
(
)
;
if
(
input_samples
.
empty
(
)
)
return
-
1
;
payload_len
=
WebRtcPcm16b_Encode
(
input_samples
.
data
(
)
input_samples
.
size
(
)
input_payload
)
;
assert
(
payload_len
=
=
kInputBlockSizeSamples
*
sizeof
(
int16_t
)
)
;
}
bool
muted
;
int
error
=
neteq
-
>
GetAudio
(
&
out_frame
&
muted
)
;
RTC_CHECK
(
!
muted
)
;
if
(
error
!
=
NetEq
:
:
kOK
)
return
-
1
;
assert
(
out_frame
.
samples_per_channel_
=
=
static_cast
<
size_t
>
(
kSampRateHz
*
10
/
1000
)
)
;
static
const
int
kOutputBlockSizeMs
=
10
;
time_now_ms
+
=
kOutputBlockSizeMs
;
if
(
time_now_ms
>
=
runtime_ms
/
2
&
&
!
drift_flipped
)
{
rtp_gen
.
set_drift_factor
(
-
drift_factor
)
;
drift_flipped
=
true
;
}
}
int64_t
end_time_ms
=
clock
-
>
TimeInMilliseconds
(
)
;
delete
neteq
;
return
end_time_ms
-
start_time_ms
;
}
}
}
