#
ifndef
MODULES_AUDIO_CODING_NETEQ_TOOLS_NETEQ_DELAY_ANALYZER_H_
#
define
MODULES_AUDIO_CODING_NETEQ_TOOLS_NETEQ_DELAY_ANALYZER_H_
#
include
<
map
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
optional
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
neteq_input
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
neteq_test
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
namespace
test
{
class
NetEqDelayAnalyzer
:
public
test
:
:
NetEqPostInsertPacket
public
test
:
:
NetEqGetAudioCallback
{
public
:
void
AfterInsertPacket
(
const
test
:
:
NetEqInput
:
:
PacketData
&
packet
NetEq
*
neteq
)
override
;
void
BeforeGetAudio
(
NetEq
*
neteq
)
override
;
void
AfterGetAudio
(
int64_t
time_now_ms
const
AudioFrame
&
audio_frame
bool
muted
NetEq
*
neteq
)
override
;
void
CreateGraphs
(
std
:
:
vector
<
float
>
*
send_times_s
std
:
:
vector
<
float
>
*
arrival_delay_ms
std
:
:
vector
<
float
>
*
corrected_arrival_delay_ms
std
:
:
vector
<
rtc
:
:
Optional
<
float
>
>
*
playout_delay_ms
std
:
:
vector
<
rtc
:
:
Optional
<
float
>
>
*
target_delay_ms
)
const
;
void
CreateMatlabScript
(
const
std
:
:
string
&
script_name
)
const
;
private
:
struct
TimingData
{
explicit
TimingData
(
double
at
)
:
arrival_time_ms
(
at
)
{
}
double
arrival_time_ms
;
rtc
:
:
Optional
<
int64_t
>
decode_get_audio_count
;
rtc
:
:
Optional
<
int64_t
>
sync_delay_ms
;
rtc
:
:
Optional
<
int
>
target_delay_ms
;
rtc
:
:
Optional
<
int
>
current_delay_ms
;
}
;
std
:
:
map
<
uint32_t
TimingData
>
data_
;
std
:
:
vector
<
int64_t
>
get_audio_time_ms_
;
size_t
get_audio_count_
=
0
;
size_t
last_sync_buffer_ms_
=
0
;
int
last_sample_rate_hz_
=
0
;
std
:
:
set
<
uint32_t
>
ssrcs_
;
std
:
:
set
<
int
>
payload_types_
;
}
;
}
}
#
endif
