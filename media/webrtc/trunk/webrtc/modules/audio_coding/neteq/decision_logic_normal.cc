#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
decision_logic_normal
.
h
"
#
include
<
assert
.
h
>
#
include
<
algorithm
>
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
buffer_level_filter
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
decoder_database
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
delay_manager
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
expand
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
packet_buffer
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
sync_buffer
.
h
"
#
include
"
webrtc
/
modules
/
include
/
module_common_types
.
h
"
namespace
webrtc
{
Operations
DecisionLogicNormal
:
:
GetDecisionSpecialized
(
const
SyncBuffer
&
sync_buffer
const
Expand
&
expand
size_t
decoder_frame_length
const
Packet
*
next_packet
Modes
prev_mode
bool
play_dtmf
bool
*
reset_decoder
size_t
generated_noise_samples
)
{
assert
(
playout_mode_
=
=
kPlayoutOn
|
|
playout_mode_
=
=
kPlayoutStreaming
)
;
if
(
prev_mode
=
=
kModeError
)
{
if
(
!
next_packet
)
{
return
kExpand
;
}
else
{
return
kUndefined
;
}
}
uint32_t
target_timestamp
=
sync_buffer
.
end_timestamp
(
)
;
uint32_t
available_timestamp
=
0
;
bool
is_cng_packet
=
false
;
if
(
next_packet
)
{
available_timestamp
=
next_packet
-
>
timestamp
;
is_cng_packet
=
decoder_database_
-
>
IsComfortNoise
(
next_packet
-
>
payload_type
)
;
}
if
(
is_cng_packet
)
{
return
CngOperation
(
prev_mode
target_timestamp
available_timestamp
generated_noise_samples
)
;
}
if
(
!
next_packet
)
{
return
NoPacket
(
play_dtmf
)
;
}
if
(
num_consecutive_expands_
>
kReinitAfterExpands
)
{
*
reset_decoder
=
true
;
return
kNormal
;
}
const
uint32_t
five_seconds_samples
=
static_cast
<
uint32_t
>
(
5
*
8000
*
fs_mult_
)
;
if
(
target_timestamp
=
=
available_timestamp
)
{
return
ExpectedPacketAvailable
(
prev_mode
play_dtmf
)
;
}
else
if
(
!
PacketBuffer
:
:
IsObsoleteTimestamp
(
available_timestamp
target_timestamp
five_seconds_samples
)
)
{
return
FuturePacketAvailable
(
sync_buffer
expand
decoder_frame_length
prev_mode
target_timestamp
available_timestamp
play_dtmf
generated_noise_samples
)
;
}
else
{
return
kUndefined
;
}
}
Operations
DecisionLogicNormal
:
:
CngOperation
(
Modes
prev_mode
uint32_t
target_timestamp
uint32_t
available_timestamp
size_t
generated_noise_samples
)
{
int32_t
timestamp_diff
=
static_cast
<
int32_t
>
(
static_cast
<
uint32_t
>
(
generated_noise_samples
+
target_timestamp
)
-
available_timestamp
)
;
int32_t
optimal_level_samp
=
static_cast
<
int32_t
>
(
(
delay_manager_
-
>
TargetLevel
(
)
*
packet_length_samples_
)
>
>
8
)
;
int32_t
excess_waiting_time_samp
=
-
timestamp_diff
-
optimal_level_samp
;
if
(
excess_waiting_time_samp
>
optimal_level_samp
/
2
)
{
noise_fast_forward_
+
=
excess_waiting_time_samp
;
timestamp_diff
+
=
excess_waiting_time_samp
;
}
if
(
timestamp_diff
<
0
&
&
prev_mode
=
=
kModeRfc3389Cng
)
{
return
kRfc3389CngNoPacket
;
}
else
{
noise_fast_forward_
=
0
;
return
kRfc3389Cng
;
}
}
Operations
DecisionLogicNormal
:
:
NoPacket
(
bool
play_dtmf
)
{
if
(
cng_state_
=
=
kCngRfc3389On
)
{
return
kRfc3389CngNoPacket
;
}
else
if
(
cng_state_
=
=
kCngInternalOn
)
{
return
kCodecInternalCng
;
}
else
if
(
play_dtmf
)
{
return
kDtmf
;
}
else
{
return
kExpand
;
}
}
Operations
DecisionLogicNormal
:
:
ExpectedPacketAvailable
(
Modes
prev_mode
bool
play_dtmf
)
{
if
(
prev_mode
!
=
kModeExpand
&
&
!
play_dtmf
)
{
int
low_limit
high_limit
;
delay_manager_
-
>
BufferLimits
(
&
low_limit
&
high_limit
)
;
if
(
buffer_level_filter_
-
>
filtered_current_level
(
)
>
=
high_limit
<
<
2
)
return
kFastAccelerate
;
if
(
TimescaleAllowed
(
)
)
{
if
(
buffer_level_filter_
-
>
filtered_current_level
(
)
>
=
high_limit
)
return
kAccelerate
;
if
(
buffer_level_filter_
-
>
filtered_current_level
(
)
<
low_limit
)
return
kPreemptiveExpand
;
}
}
return
kNormal
;
}
Operations
DecisionLogicNormal
:
:
FuturePacketAvailable
(
const
SyncBuffer
&
sync_buffer
const
Expand
&
expand
size_t
decoder_frame_length
Modes
prev_mode
uint32_t
target_timestamp
uint32_t
available_timestamp
bool
play_dtmf
size_t
generated_noise_samples
)
{
uint32_t
timestamp_leap
=
available_timestamp
-
target_timestamp
;
if
(
(
prev_mode
=
=
kModeExpand
)
&
&
!
ReinitAfterExpands
(
timestamp_leap
)
&
&
!
MaxWaitForPacket
(
)
&
&
PacketTooEarly
(
timestamp_leap
)
&
&
UnderTargetLevel
(
)
)
{
if
(
play_dtmf
)
{
return
kDtmf
;
}
else
{
return
kExpand
;
}
}
const
size_t
samples_left
=
sync_buffer
.
FutureLength
(
)
-
expand
.
overlap_length
(
)
;
const
size_t
cur_size_samples
=
samples_left
+
packet_buffer_
.
NumPacketsInBuffer
(
)
*
decoder_frame_length
;
if
(
prev_mode
=
=
kModeRfc3389Cng
|
|
prev_mode
=
=
kModeCodecInternalCng
)
{
if
(
static_cast
<
uint32_t
>
(
generated_noise_samples
+
target_timestamp
)
>
=
available_timestamp
|
|
cur_size_samples
>
(
(
delay_manager_
-
>
TargetLevel
(
)
*
packet_length_samples_
)
>
>
8
)
*
4
)
{
return
kNormal
;
}
else
{
if
(
prev_mode
=
=
kModeRfc3389Cng
)
{
return
kRfc3389CngNoPacket
;
}
else
{
return
kCodecInternalCng
;
}
}
}
if
(
prev_mode
=
=
kModeExpand
)
{
return
kMerge
;
}
else
if
(
play_dtmf
)
{
return
kDtmf
;
}
else
{
return
kExpand
;
}
}
bool
DecisionLogicNormal
:
:
UnderTargetLevel
(
)
const
{
return
buffer_level_filter_
-
>
filtered_current_level
(
)
<
=
delay_manager_
-
>
TargetLevel
(
)
;
}
bool
DecisionLogicNormal
:
:
ReinitAfterExpands
(
uint32_t
timestamp_leap
)
const
{
return
timestamp_leap
>
=
static_cast
<
uint32_t
>
(
output_size_samples_
*
kReinitAfterExpands
)
;
}
bool
DecisionLogicNormal
:
:
PacketTooEarly
(
uint32_t
timestamp_leap
)
const
{
return
timestamp_leap
>
static_cast
<
uint32_t
>
(
output_size_samples_
*
num_consecutive_expands_
)
;
}
bool
DecisionLogicNormal
:
:
MaxWaitForPacket
(
)
const
{
return
num_consecutive_expands_
>
=
kMaxWaitForPacket
;
}
}
