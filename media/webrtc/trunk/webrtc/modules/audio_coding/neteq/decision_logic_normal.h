#
ifndef
MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_NORMAL_H_
#
define
MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_NORMAL_H_
#
include
"
modules
/
audio_coding
/
neteq
/
decision_logic
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
class
DecisionLogicNormal
:
public
DecisionLogic
{
public
:
DecisionLogicNormal
(
int
fs_hz
size_t
output_size_samples
NetEqPlayoutMode
playout_mode
DecoderDatabase
*
decoder_database
const
PacketBuffer
&
packet_buffer
DelayManager
*
delay_manager
BufferLevelFilter
*
buffer_level_filter
const
TickTimer
*
tick_timer
)
:
DecisionLogic
(
fs_hz
output_size_samples
playout_mode
decoder_database
packet_buffer
delay_manager
buffer_level_filter
tick_timer
)
{
}
protected
:
static
const
int
kReinitAfterExpands
=
100
;
static
const
int
kMaxWaitForPacket
=
10
;
Operations
GetDecisionSpecialized
(
const
SyncBuffer
&
sync_buffer
const
Expand
&
expand
size_t
decoder_frame_length
const
Packet
*
next_packet
Modes
prev_mode
bool
play_dtmf
bool
*
reset_decoder
size_t
generated_noise_samples
)
override
;
virtual
Operations
FuturePacketAvailable
(
const
SyncBuffer
&
sync_buffer
const
Expand
&
expand
size_t
decoder_frame_length
Modes
prev_mode
uint32_t
target_timestamp
uint32_t
available_timestamp
bool
play_dtmf
size_t
generated_noise_samples
)
;
virtual
Operations
ExpectedPacketAvailable
(
Modes
prev_mode
bool
play_dtmf
)
;
virtual
Operations
NoPacket
(
bool
play_dtmf
)
;
private
:
Operations
CngOperation
(
Modes
prev_mode
uint32_t
target_timestamp
uint32_t
available_timestamp
size_t
generated_noise_samples
)
;
bool
TimescaleAllowed
(
)
const
{
return
!
timescale_countdown_
|
|
timescale_countdown_
-
>
Finished
(
)
;
}
bool
UnderTargetLevel
(
)
const
;
bool
ReinitAfterExpands
(
uint32_t
timestamp_leap
)
const
;
bool
PacketTooEarly
(
uint32_t
timestamp_leap
)
const
;
bool
MaxWaitForPacket
(
)
const
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
DecisionLogicNormal
)
;
}
;
}
#
endif
