#
ifndef
MODULES_AUDIO_CODING_NETEQ_TICK_TIMER_H_
#
define
MODULES_AUDIO_CODING_NETEQ_TICK_TIMER_H_
#
include
<
memory
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
class
TickTimer
{
public
:
class
Stopwatch
{
public
:
explicit
Stopwatch
(
const
TickTimer
&
ticktimer
)
;
uint64_t
ElapsedTicks
(
)
const
{
return
ticktimer_
.
ticks
(
)
-
starttick_
;
}
uint64_t
ElapsedMs
(
)
const
{
const
uint64_t
elapsed_ticks
=
ticktimer_
.
ticks
(
)
-
starttick_
;
const
int
ms_per_tick
=
ticktimer_
.
ms_per_tick
(
)
;
return
elapsed_ticks
<
UINT64_MAX
/
ms_per_tick
?
elapsed_ticks
*
ms_per_tick
:
UINT64_MAX
;
}
private
:
const
TickTimer
&
ticktimer_
;
const
uint64_t
starttick_
;
}
;
class
Countdown
{
public
:
Countdown
(
const
TickTimer
&
ticktimer
uint64_t
ticks_to_count
)
;
~
Countdown
(
)
;
bool
Finished
(
)
const
{
return
stopwatch_
-
>
ElapsedTicks
(
)
>
=
ticks_to_count_
;
}
private
:
const
std
:
:
unique_ptr
<
Stopwatch
>
stopwatch_
;
const
uint64_t
ticks_to_count_
;
}
;
TickTimer
(
)
:
TickTimer
(
10
)
{
}
explicit
TickTimer
(
int
ms_per_tick
)
:
ms_per_tick_
(
ms_per_tick
)
{
RTC_DCHECK_GT
(
ms_per_tick_
0
)
;
}
void
Increment
(
)
{
+
+
ticks_
;
}
void
Increment
(
uint64_t
x
)
{
ticks_
+
=
x
;
}
uint64_t
ticks
(
)
const
{
return
ticks_
;
}
int
ms_per_tick
(
)
const
{
return
ms_per_tick_
;
}
std
:
:
unique_ptr
<
Stopwatch
>
GetNewStopwatch
(
)
const
{
return
std
:
:
unique_ptr
<
Stopwatch
>
(
new
Stopwatch
(
*
this
)
)
;
}
std
:
:
unique_ptr
<
Countdown
>
GetNewCountdown
(
uint64_t
ticks_to_count
)
const
{
return
std
:
:
unique_ptr
<
Countdown
>
(
new
Countdown
(
*
this
ticks_to_count
)
)
;
}
private
:
uint64_t
ticks_
=
0
;
const
int
ms_per_tick_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
TickTimer
)
;
}
;
}
#
endif
