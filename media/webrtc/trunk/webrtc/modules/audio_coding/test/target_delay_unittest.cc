#
include
<
memory
>
#
include
"
common_types
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
pcm16b
/
pcm16b
.
h
"
#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module
.
h
"
#
include
"
modules
/
audio_coding
/
test
/
utility
.
h
"
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
testsupport
/
fileutils
.
h
"
namespace
webrtc
{
class
TargetDelayTest
:
public
:
:
testing
:
:
Test
{
protected
:
TargetDelayTest
(
)
:
acm_
(
AudioCodingModule
:
:
Create
(
)
)
{
}
~
TargetDelayTest
(
)
{
}
void
SetUp
(
)
{
EXPECT_TRUE
(
acm_
.
get
(
)
!
=
NULL
)
;
ASSERT_EQ
(
0
acm_
-
>
InitializeReceiver
(
)
)
;
constexpr
int
pltype
=
108
;
ASSERT_EQ
(
true
acm_
-
>
RegisterReceiveCodec
(
pltype
{
"
L16
"
kSampleRateHz
1
}
)
)
;
rtp_info_
.
header
.
payloadType
=
pltype
;
rtp_info_
.
header
.
timestamp
=
0
;
rtp_info_
.
header
.
ssrc
=
0x12345678
;
rtp_info_
.
header
.
markerBit
=
false
;
rtp_info_
.
header
.
sequenceNumber
=
0
;
rtp_info_
.
type
.
Audio
.
channel
=
1
;
rtp_info_
.
type
.
Audio
.
isCNG
=
false
;
rtp_info_
.
frameType
=
kAudioFrameSpeech
;
int16_t
audio
[
kFrameSizeSamples
]
;
const
int
kRange
=
0x7FF
;
for
(
size_t
n
=
0
;
n
<
kFrameSizeSamples
;
+
+
n
)
audio
[
n
]
=
(
rand
(
)
&
kRange
)
-
kRange
/
2
;
WebRtcPcm16b_Encode
(
audio
kFrameSizeSamples
payload_
)
;
}
void
OutOfRangeInput
(
)
{
EXPECT_EQ
(
-
1
SetMinimumDelay
(
-
1
)
)
;
EXPECT_EQ
(
-
1
SetMinimumDelay
(
10001
)
)
;
}
void
NoTargetDelayBufferSizeChanges
(
)
{
for
(
int
n
=
0
;
n
<
30
;
+
+
n
)
Run
(
true
)
;
int
clean_optimal_delay
=
GetCurrentOptimalDelayMs
(
)
;
Run
(
false
)
;
int
jittery_optimal_delay
=
GetCurrentOptimalDelayMs
(
)
;
EXPECT_GT
(
jittery_optimal_delay
clean_optimal_delay
)
;
int
required_delay
=
RequiredDelay
(
)
;
EXPECT_GT
(
required_delay
0
)
;
EXPECT_NEAR
(
required_delay
jittery_optimal_delay
1
)
;
}
void
WithTargetDelayBufferNotChanging
(
)
{
const
int
kTargetDelayMs
=
(
kInterarrivalJitterPacket
+
1
)
*
kNum10msPerFrame
*
10
;
ASSERT_EQ
(
0
SetMinimumDelay
(
kTargetDelayMs
)
)
;
for
(
int
n
=
0
;
n
<
30
;
+
+
n
)
Run
(
true
)
;
int
clean_optimal_delay
=
GetCurrentOptimalDelayMs
(
)
;
EXPECT_EQ
(
kTargetDelayMs
clean_optimal_delay
)
;
Run
(
false
)
;
int
jittery_optimal_delay
=
GetCurrentOptimalDelayMs
(
)
;
EXPECT_EQ
(
jittery_optimal_delay
clean_optimal_delay
)
;
}
void
RequiredDelayAtCorrectRange
(
)
{
for
(
int
n
=
0
;
n
<
30
;
+
+
n
)
Run
(
true
)
;
int
clean_optimal_delay
=
GetCurrentOptimalDelayMs
(
)
;
const
int
kTargetDelayMs
=
(
kInterarrivalJitterPacket
+
10
)
*
kNum10msPerFrame
*
10
;
ASSERT_EQ
(
0
SetMinimumDelay
(
kTargetDelayMs
)
)
;
for
(
int
n
=
0
;
n
<
300
;
+
+
n
)
Run
(
true
)
;
Run
(
false
)
;
int
jittery_optimal_delay
=
GetCurrentOptimalDelayMs
(
)
;
EXPECT_EQ
(
kTargetDelayMs
jittery_optimal_delay
)
;
int
required_delay
=
RequiredDelay
(
)
;
EXPECT_GT
(
required_delay
0
)
;
EXPECT_GT
(
jittery_optimal_delay
required_delay
)
;
EXPECT_GT
(
required_delay
clean_optimal_delay
)
;
EXPECT_NEAR
(
kInterarrivalJitterPacket
*
kNum10msPerFrame
*
10
required_delay
1
)
;
}
void
TargetDelayBufferMinMax
(
)
{
const
int
kTargetMinDelayMs
=
kNum10msPerFrame
*
10
;
ASSERT_EQ
(
0
SetMinimumDelay
(
kTargetMinDelayMs
)
)
;
for
(
int
m
=
0
;
m
<
30
;
+
+
m
)
Run
(
true
)
;
int
clean_optimal_delay
=
GetCurrentOptimalDelayMs
(
)
;
EXPECT_EQ
(
kTargetMinDelayMs
clean_optimal_delay
)
;
const
int
kTargetMaxDelayMs
=
2
*
(
kNum10msPerFrame
*
10
)
;
ASSERT_EQ
(
0
SetMaximumDelay
(
kTargetMaxDelayMs
)
)
;
for
(
int
n
=
0
;
n
<
30
;
+
+
n
)
Run
(
false
)
;
int
capped_optimal_delay
=
GetCurrentOptimalDelayMs
(
)
;
EXPECT_EQ
(
kTargetMaxDelayMs
capped_optimal_delay
)
;
}
private
:
static
const
int
kSampleRateHz
=
16000
;
static
const
int
kNum10msPerFrame
=
2
;
static
const
size_t
kFrameSizeSamples
=
320
;
static
const
int
kPayloadLenBytes
=
320
*
2
;
static
const
int
kInterarrivalJitterPacket
=
2
;
void
Push
(
)
{
rtp_info_
.
header
.
timestamp
+
=
kFrameSizeSamples
;
rtp_info_
.
header
.
sequenceNumber
+
+
;
ASSERT_EQ
(
0
acm_
-
>
IncomingPacket
(
payload_
kFrameSizeSamples
*
2
rtp_info_
)
)
;
}
void
Pull
(
)
{
AudioFrame
frame
;
bool
muted
;
for
(
int
k
=
0
;
k
<
kNum10msPerFrame
;
+
+
k
)
{
ASSERT_EQ
(
0
acm_
-
>
PlayoutData10Ms
(
-
1
&
frame
&
muted
)
)
;
ASSERT_FALSE
(
muted
)
;
ASSERT_TRUE
(
kSampleRateHz
=
=
frame
.
sample_rate_hz_
)
;
ASSERT_EQ
(
1u
frame
.
num_channels_
)
;
ASSERT_TRUE
(
kSampleRateHz
/
100
=
=
frame
.
samples_per_channel_
)
;
}
}
void
Run
(
bool
clean
)
{
for
(
int
n
=
0
;
n
<
10
;
+
+
n
)
{
for
(
int
m
=
0
;
m
<
5
;
+
+
m
)
{
Push
(
)
;
Pull
(
)
;
}
if
(
!
clean
)
{
for
(
int
m
=
0
;
m
<
10
;
+
+
m
)
{
Push
(
)
;
for
(
int
n
=
0
;
n
<
kInterarrivalJitterPacket
;
+
+
n
)
Pull
(
)
;
}
}
}
}
int
SetMinimumDelay
(
int
delay_ms
)
{
return
acm_
-
>
SetMinimumPlayoutDelay
(
delay_ms
)
;
}
int
SetMaximumDelay
(
int
delay_ms
)
{
return
acm_
-
>
SetMaximumPlayoutDelay
(
delay_ms
)
;
}
int
GetCurrentOptimalDelayMs
(
)
{
NetworkStatistics
stats
;
acm_
-
>
GetNetworkStatistics
(
&
stats
)
;
return
stats
.
preferredBufferSize
;
}
int
RequiredDelay
(
)
{
return
acm_
-
>
LeastRequiredDelayMs
(
)
;
}
std
:
:
unique_ptr
<
AudioCodingModule
>
acm_
;
WebRtcRTPHeader
rtp_info_
;
uint8_t
payload_
[
kPayloadLenBytes
]
;
}
;
#
if
defined
(
WEBRTC_ANDROID
)
|
|
defined
(
WEBRTC_IOS
)
#
define
MAYBE_OutOfRangeInput
DISABLED_OutOfRangeInput
#
else
#
define
MAYBE_OutOfRangeInput
OutOfRangeInput
#
endif
TEST_F
(
TargetDelayTest
MAYBE_OutOfRangeInput
)
{
OutOfRangeInput
(
)
;
}
#
if
defined
(
WEBRTC_ANDROID
)
|
|
defined
(
WEBRTC_IOS
)
#
define
MAYBE_NoTargetDelayBufferSizeChanges
\
DISABLED_NoTargetDelayBufferSizeChanges
#
else
#
define
MAYBE_NoTargetDelayBufferSizeChanges
NoTargetDelayBufferSizeChanges
#
endif
TEST_F
(
TargetDelayTest
MAYBE_NoTargetDelayBufferSizeChanges
)
{
NoTargetDelayBufferSizeChanges
(
)
;
}
#
if
defined
(
WEBRTC_ANDROID
)
|
|
defined
(
WEBRTC_IOS
)
#
define
MAYBE_WithTargetDelayBufferNotChanging
\
DISABLED_WithTargetDelayBufferNotChanging
#
else
#
define
MAYBE_WithTargetDelayBufferNotChanging
WithTargetDelayBufferNotChanging
#
endif
TEST_F
(
TargetDelayTest
MAYBE_WithTargetDelayBufferNotChanging
)
{
WithTargetDelayBufferNotChanging
(
)
;
}
#
if
defined
(
WEBRTC_ANDROID
)
|
|
defined
(
WEBRTC_IOS
)
#
define
MAYBE_RequiredDelayAtCorrectRange
DISABLED_RequiredDelayAtCorrectRange
#
else
#
define
MAYBE_RequiredDelayAtCorrectRange
RequiredDelayAtCorrectRange
#
endif
TEST_F
(
TargetDelayTest
MAYBE_RequiredDelayAtCorrectRange
)
{
RequiredDelayAtCorrectRange
(
)
;
}
#
if
defined
(
WEBRTC_ANDROID
)
|
|
defined
(
WEBRTC_IOS
)
#
define
MAYBE_TargetDelayBufferMinMax
DISABLED_TargetDelayBufferMinMax
#
else
#
define
MAYBE_TargetDelayBufferMinMax
TargetDelayBufferMinMax
#
endif
TEST_F
(
TargetDelayTest
MAYBE_TargetDelayBufferMinMax
)
{
TargetDelayBufferMinMax
(
)
;
}
}
