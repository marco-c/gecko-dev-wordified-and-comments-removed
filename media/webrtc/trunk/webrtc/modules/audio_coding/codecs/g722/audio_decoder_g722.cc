#
include
"
webrtc
/
modules
/
audio_coding
/
codecs
/
g722
/
audio_decoder_g722
.
h
"
#
include
<
string
.
h
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
codecs
/
g722
/
g722_interface
.
h
"
namespace
webrtc
{
AudioDecoderG722
:
:
AudioDecoderG722
(
)
{
WebRtcG722_CreateDecoder
(
&
dec_state_
)
;
WebRtcG722_DecoderInit
(
dec_state_
)
;
}
AudioDecoderG722
:
:
~
AudioDecoderG722
(
)
{
WebRtcG722_FreeDecoder
(
dec_state_
)
;
}
bool
AudioDecoderG722
:
:
HasDecodePlc
(
)
const
{
return
false
;
}
int
AudioDecoderG722
:
:
DecodeInternal
(
const
uint8_t
*
encoded
size_t
encoded_len
int
sample_rate_hz
int16_t
*
decoded
SpeechType
*
speech_type
)
{
RTC_DCHECK_EQ
(
sample_rate_hz
16000
)
;
int16_t
temp_type
=
1
;
size_t
ret
=
WebRtcG722_Decode
(
dec_state_
encoded
encoded_len
decoded
&
temp_type
)
;
*
speech_type
=
ConvertSpeechType
(
temp_type
)
;
return
static_cast
<
int
>
(
ret
)
;
}
void
AudioDecoderG722
:
:
Reset
(
)
{
WebRtcG722_DecoderInit
(
dec_state_
)
;
}
int
AudioDecoderG722
:
:
PacketDuration
(
const
uint8_t
*
encoded
size_t
encoded_len
)
const
{
return
static_cast
<
int
>
(
2
*
encoded_len
/
Channels
(
)
)
;
}
size_t
AudioDecoderG722
:
:
Channels
(
)
const
{
return
1
;
}
AudioDecoderG722Stereo
:
:
AudioDecoderG722Stereo
(
)
{
WebRtcG722_CreateDecoder
(
&
dec_state_left_
)
;
WebRtcG722_CreateDecoder
(
&
dec_state_right_
)
;
WebRtcG722_DecoderInit
(
dec_state_left_
)
;
WebRtcG722_DecoderInit
(
dec_state_right_
)
;
}
AudioDecoderG722Stereo
:
:
~
AudioDecoderG722Stereo
(
)
{
WebRtcG722_FreeDecoder
(
dec_state_left_
)
;
WebRtcG722_FreeDecoder
(
dec_state_right_
)
;
}
int
AudioDecoderG722Stereo
:
:
DecodeInternal
(
const
uint8_t
*
encoded
size_t
encoded_len
int
sample_rate_hz
int16_t
*
decoded
SpeechType
*
speech_type
)
{
RTC_DCHECK_EQ
(
sample_rate_hz
16000
)
;
int16_t
temp_type
=
1
;
uint8_t
*
encoded_deinterleaved
=
new
uint8_t
[
encoded_len
]
;
SplitStereoPacket
(
encoded
encoded_len
encoded_deinterleaved
)
;
size_t
decoded_len
=
WebRtcG722_Decode
(
dec_state_left_
encoded_deinterleaved
encoded_len
/
2
decoded
&
temp_type
)
;
size_t
ret
=
WebRtcG722_Decode
(
dec_state_right_
&
encoded_deinterleaved
[
encoded_len
/
2
]
encoded_len
/
2
&
decoded
[
decoded_len
]
&
temp_type
)
;
if
(
ret
=
=
decoded_len
)
{
ret
+
=
decoded_len
;
for
(
size_t
k
=
ret
/
2
;
k
<
ret
;
k
+
+
)
{
int16_t
temp
=
decoded
[
k
]
;
memmove
(
&
decoded
[
2
*
k
-
ret
+
2
]
&
decoded
[
2
*
k
-
ret
+
1
]
(
ret
-
k
-
1
)
*
sizeof
(
int16_t
)
)
;
decoded
[
2
*
k
-
ret
+
1
]
=
temp
;
}
}
*
speech_type
=
ConvertSpeechType
(
temp_type
)
;
delete
[
]
encoded_deinterleaved
;
return
static_cast
<
int
>
(
ret
)
;
}
size_t
AudioDecoderG722Stereo
:
:
Channels
(
)
const
{
return
2
;
}
void
AudioDecoderG722Stereo
:
:
Reset
(
)
{
WebRtcG722_DecoderInit
(
dec_state_left_
)
;
WebRtcG722_DecoderInit
(
dec_state_right_
)
;
}
void
AudioDecoderG722Stereo
:
:
SplitStereoPacket
(
const
uint8_t
*
encoded
size_t
encoded_len
uint8_t
*
encoded_deinterleaved
)
{
for
(
size_t
i
=
0
;
i
+
1
<
encoded_len
;
i
+
=
2
)
{
uint8_t
right_byte
=
(
(
encoded
[
i
]
&
0x0F
)
<
<
4
)
+
(
encoded
[
i
+
1
]
&
0x0F
)
;
encoded_deinterleaved
[
i
]
=
(
encoded
[
i
]
&
0xF0
)
+
(
encoded
[
i
+
1
]
>
>
4
)
;
encoded_deinterleaved
[
i
+
1
]
=
right_byte
;
}
for
(
size_t
i
=
0
;
i
<
encoded_len
/
2
;
i
+
+
)
{
uint8_t
right_byte
=
encoded_deinterleaved
[
i
+
1
]
;
memmove
(
&
encoded_deinterleaved
[
i
+
1
]
&
encoded_deinterleaved
[
i
+
2
]
encoded_len
-
i
-
2
)
;
encoded_deinterleaved
[
encoded_len
-
1
]
=
right_byte
;
}
}
}
