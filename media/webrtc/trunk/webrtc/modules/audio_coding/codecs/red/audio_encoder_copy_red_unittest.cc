#
include
<
vector
>
#
include
"
testing
/
gtest
/
include
/
gtest
/
gtest
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
codecs
/
red
/
audio_encoder_copy_red
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
codecs
/
mock
/
mock_audio_encoder
.
h
"
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
SetArgPointee
;
using
:
:
testing
:
:
InSequence
;
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
MockFunction
;
namespace
webrtc
{
namespace
{
static
const
size_t
kMockMaxEncodedBytes
=
1000
;
static
const
size_t
kMaxNumSamples
=
48
*
10
*
2
;
}
class
AudioEncoderCopyRedTest
:
public
:
:
testing
:
:
Test
{
protected
:
AudioEncoderCopyRedTest
(
)
:
timestamp_
(
4711
)
sample_rate_hz_
(
16000
)
num_audio_samples_10ms
(
sample_rate_hz_
/
100
)
red_payload_type_
(
200
)
{
AudioEncoderCopyRed
:
:
Config
config
;
config
.
payload_type
=
red_payload_type_
;
config
.
speech_encoder
=
&
mock_encoder_
;
red_
.
reset
(
new
AudioEncoderCopyRed
(
config
)
)
;
memset
(
audio_
0
sizeof
(
audio_
)
)
;
EXPECT_CALL
(
mock_encoder_
NumChannels
(
)
)
.
WillRepeatedly
(
Return
(
1
)
)
;
EXPECT_CALL
(
mock_encoder_
SampleRateHz
(
)
)
.
WillRepeatedly
(
Return
(
sample_rate_hz_
)
)
;
EXPECT_CALL
(
mock_encoder_
MaxEncodedBytes
(
)
)
.
WillRepeatedly
(
Return
(
kMockMaxEncodedBytes
)
)
;
encoded_
.
resize
(
red_
-
>
MaxEncodedBytes
(
)
0
)
;
}
void
TearDown
(
)
override
{
red_
.
reset
(
)
;
EXPECT_CALL
(
mock_encoder_
Die
(
)
)
.
Times
(
1
)
;
}
void
Encode
(
)
{
ASSERT_TRUE
(
red_
.
get
(
)
!
=
NULL
)
;
encoded_info_
=
red_
-
>
Encode
(
timestamp_
audio_
num_audio_samples_10ms
encoded_
.
size
(
)
&
encoded_
[
0
]
)
;
timestamp_
+
=
num_audio_samples_10ms
;
}
MockAudioEncoder
mock_encoder_
;
rtc
:
:
scoped_ptr
<
AudioEncoderCopyRed
>
red_
;
uint32_t
timestamp_
;
int16_t
audio_
[
kMaxNumSamples
]
;
const
int
sample_rate_hz_
;
size_t
num_audio_samples_10ms
;
std
:
:
vector
<
uint8_t
>
encoded_
;
AudioEncoder
:
:
EncodedInfo
encoded_info_
;
const
int
red_payload_type_
;
}
;
class
MockEncodeHelper
{
public
:
MockEncodeHelper
(
)
:
write_payload_
(
false
)
payload_
(
NULL
)
{
memset
(
&
info_
0
sizeof
(
info_
)
)
;
}
AudioEncoder
:
:
EncodedInfo
Encode
(
uint32_t
timestamp
const
int16_t
*
audio
size_t
max_encoded_bytes
uint8_t
*
encoded
)
{
if
(
write_payload_
)
{
CHECK
(
encoded
)
;
CHECK_LE
(
info_
.
encoded_bytes
max_encoded_bytes
)
;
memcpy
(
encoded
payload_
info_
.
encoded_bytes
)
;
}
return
info_
;
}
AudioEncoder
:
:
EncodedInfo
info_
;
bool
write_payload_
;
uint8_t
*
payload_
;
}
;
TEST_F
(
AudioEncoderCopyRedTest
CreateAndDestroy
)
{
}
TEST_F
(
AudioEncoderCopyRedTest
CheckSampleRatePropagation
)
{
EXPECT_CALL
(
mock_encoder_
SampleRateHz
(
)
)
.
WillOnce
(
Return
(
17
)
)
;
EXPECT_EQ
(
17
red_
-
>
SampleRateHz
(
)
)
;
}
TEST_F
(
AudioEncoderCopyRedTest
CheckNumChannelsPropagation
)
{
EXPECT_CALL
(
mock_encoder_
NumChannels
(
)
)
.
WillOnce
(
Return
(
17
)
)
;
EXPECT_EQ
(
17
red_
-
>
NumChannels
(
)
)
;
}
TEST_F
(
AudioEncoderCopyRedTest
CheckFrameSizePropagation
)
{
EXPECT_CALL
(
mock_encoder_
Num10MsFramesInNextPacket
(
)
)
.
WillOnce
(
Return
(
17
)
)
;
EXPECT_EQ
(
17
red_
-
>
Num10MsFramesInNextPacket
(
)
)
;
}
TEST_F
(
AudioEncoderCopyRedTest
CheckMaxFrameSizePropagation
)
{
EXPECT_CALL
(
mock_encoder_
Max10MsFramesInAPacket
(
)
)
.
WillOnce
(
Return
(
17
)
)
;
EXPECT_EQ
(
17
red_
-
>
Max10MsFramesInAPacket
(
)
)
;
}
TEST_F
(
AudioEncoderCopyRedTest
CheckSetBitratePropagation
)
{
EXPECT_CALL
(
mock_encoder_
SetTargetBitrate
(
4711
)
)
;
red_
-
>
SetTargetBitrate
(
4711
)
;
}
TEST_F
(
AudioEncoderCopyRedTest
CheckProjectedPacketLossRatePropagation
)
{
EXPECT_CALL
(
mock_encoder_
SetProjectedPacketLossRate
(
0
.
5
)
)
;
red_
-
>
SetProjectedPacketLossRate
(
0
.
5
)
;
}
TEST_F
(
AudioEncoderCopyRedTest
CheckImmediateEncode
)
{
InSequence
s
;
MockFunction
<
void
(
int
check_point_id
)
>
check
;
for
(
int
i
=
1
;
i
<
=
6
;
+
+
i
)
{
EXPECT_CALL
(
mock_encoder_
EncodeInternal
(
_
_
_
_
)
)
.
WillRepeatedly
(
Return
(
AudioEncoder
:
:
EncodedInfo
(
)
)
)
;
EXPECT_CALL
(
check
Call
(
i
)
)
;
Encode
(
)
;
check
.
Call
(
i
)
;
}
}
TEST_F
(
AudioEncoderCopyRedTest
CheckNoOutput
)
{
static
const
size_t
kEncodedSize
=
17
;
AudioEncoder
:
:
EncodedInfo
info
;
info
.
encoded_bytes
=
kEncodedSize
;
EXPECT_CALL
(
mock_encoder_
EncodeInternal
(
_
_
_
_
)
)
.
WillOnce
(
Return
(
info
)
)
;
Encode
(
)
;
EXPECT_EQ
(
1u
encoded_info_
.
redundant
.
size
(
)
)
;
EXPECT_EQ
(
kEncodedSize
encoded_info_
.
encoded_bytes
)
;
info
.
encoded_bytes
=
0
;
EXPECT_CALL
(
mock_encoder_
EncodeInternal
(
_
_
_
_
)
)
.
WillOnce
(
Return
(
info
)
)
;
Encode
(
)
;
EXPECT_EQ
(
0u
encoded_info_
.
encoded_bytes
)
;
info
.
encoded_bytes
=
kEncodedSize
;
EXPECT_CALL
(
mock_encoder_
EncodeInternal
(
_
_
_
_
)
)
.
WillOnce
(
Return
(
info
)
)
;
Encode
(
)
;
EXPECT_EQ
(
2
*
kEncodedSize
encoded_info_
.
encoded_bytes
)
;
ASSERT_EQ
(
2u
encoded_info_
.
redundant
.
size
(
)
)
;
}
TEST_F
(
AudioEncoderCopyRedTest
CheckPayloadSizes
)
{
static
const
int
kNumPackets
=
10
;
InSequence
s
;
for
(
int
encode_size
=
1
;
encode_size
<
=
kNumPackets
;
+
+
encode_size
)
{
AudioEncoder
:
:
EncodedInfo
info
;
info
.
encoded_bytes
=
encode_size
;
EXPECT_CALL
(
mock_encoder_
EncodeInternal
(
_
_
_
_
)
)
.
WillOnce
(
Return
(
info
)
)
;
}
Encode
(
)
;
EXPECT_EQ
(
1u
encoded_info_
.
redundant
.
size
(
)
)
;
EXPECT_EQ
(
1u
encoded_info_
.
encoded_bytes
)
;
for
(
size_t
i
=
2
;
i
<
=
kNumPackets
;
+
+
i
)
{
Encode
(
)
;
ASSERT_EQ
(
2u
encoded_info_
.
redundant
.
size
(
)
)
;
EXPECT_EQ
(
i
encoded_info_
.
redundant
[
0
]
.
encoded_bytes
)
;
EXPECT_EQ
(
i
-
1
encoded_info_
.
redundant
[
1
]
.
encoded_bytes
)
;
EXPECT_EQ
(
i
+
i
-
1
encoded_info_
.
encoded_bytes
)
;
}
}
TEST_F
(
AudioEncoderCopyRedTest
CheckTimestamps
)
{
MockEncodeHelper
helper
;
helper
.
info_
.
encoded_bytes
=
17
;
helper
.
info_
.
encoded_timestamp
=
timestamp_
;
uint32_t
primary_timestamp
=
timestamp_
;
EXPECT_CALL
(
mock_encoder_
EncodeInternal
(
_
_
_
_
)
)
.
WillRepeatedly
(
Invoke
(
&
helper
&
MockEncodeHelper
:
:
Encode
)
)
;
Encode
(
)
;
EXPECT_EQ
(
primary_timestamp
encoded_info_
.
encoded_timestamp
)
;
uint32_t
secondary_timestamp
=
primary_timestamp
;
primary_timestamp
=
timestamp_
;
helper
.
info_
.
encoded_timestamp
=
timestamp_
;
Encode
(
)
;
ASSERT_EQ
(
2u
encoded_info_
.
redundant
.
size
(
)
)
;
EXPECT_EQ
(
primary_timestamp
encoded_info_
.
redundant
[
0
]
.
encoded_timestamp
)
;
EXPECT_EQ
(
secondary_timestamp
encoded_info_
.
redundant
[
1
]
.
encoded_timestamp
)
;
EXPECT_EQ
(
primary_timestamp
encoded_info_
.
encoded_timestamp
)
;
}
TEST_F
(
AudioEncoderCopyRedTest
CheckPayloads
)
{
MockEncodeHelper
helper
;
static
const
size_t
kPayloadLenBytes
=
5
;
helper
.
info_
.
encoded_bytes
=
kPayloadLenBytes
;
helper
.
write_payload_
=
true
;
uint8_t
payload
[
kPayloadLenBytes
]
;
for
(
uint8_t
i
=
0
;
i
<
kPayloadLenBytes
;
+
+
i
)
{
payload
[
i
]
=
i
;
}
helper
.
payload_
=
payload
;
EXPECT_CALL
(
mock_encoder_
EncodeInternal
(
_
_
_
_
)
)
.
WillRepeatedly
(
Invoke
(
&
helper
&
MockEncodeHelper
:
:
Encode
)
)
;
Encode
(
)
;
EXPECT_EQ
(
kPayloadLenBytes
encoded_info_
.
encoded_bytes
)
;
for
(
size_t
i
=
0
;
i
<
kPayloadLenBytes
;
+
+
i
)
{
EXPECT_EQ
(
i
encoded_
[
i
]
)
;
}
for
(
int
j
=
0
;
j
<
5
;
+
+
j
)
{
for
(
size_t
i
=
0
;
i
<
kPayloadLenBytes
;
+
+
i
)
helper
.
payload_
[
i
]
+
=
10
;
Encode
(
)
;
ASSERT_EQ
(
2u
encoded_info_
.
redundant
.
size
(
)
)
;
EXPECT_EQ
(
kPayloadLenBytes
encoded_info_
.
redundant
[
0
]
.
encoded_bytes
)
;
EXPECT_EQ
(
kPayloadLenBytes
encoded_info_
.
redundant
[
1
]
.
encoded_bytes
)
;
for
(
size_t
i
=
0
;
i
<
kPayloadLenBytes
;
+
+
i
)
{
EXPECT_EQ
(
(
j
+
1
)
*
10
+
i
encoded_
[
i
]
)
;
EXPECT_EQ
(
j
*
10
+
i
encoded_
[
i
+
kPayloadLenBytes
]
)
;
}
}
}
TEST_F
(
AudioEncoderCopyRedTest
CheckPayloadType
)
{
MockEncodeHelper
helper
;
helper
.
info_
.
encoded_bytes
=
17
;
const
int
primary_payload_type
=
red_payload_type_
+
1
;
helper
.
info_
.
payload_type
=
primary_payload_type
;
EXPECT_CALL
(
mock_encoder_
EncodeInternal
(
_
_
_
_
)
)
.
WillRepeatedly
(
Invoke
(
&
helper
&
MockEncodeHelper
:
:
Encode
)
)
;
Encode
(
)
;
ASSERT_EQ
(
1u
encoded_info_
.
redundant
.
size
(
)
)
;
EXPECT_EQ
(
primary_payload_type
encoded_info_
.
redundant
[
0
]
.
payload_type
)
;
EXPECT_EQ
(
red_payload_type_
encoded_info_
.
payload_type
)
;
const
int
secondary_payload_type
=
red_payload_type_
+
2
;
helper
.
info_
.
payload_type
=
secondary_payload_type
;
Encode
(
)
;
ASSERT_EQ
(
2u
encoded_info_
.
redundant
.
size
(
)
)
;
EXPECT_EQ
(
secondary_payload_type
encoded_info_
.
redundant
[
0
]
.
payload_type
)
;
EXPECT_EQ
(
primary_payload_type
encoded_info_
.
redundant
[
1
]
.
payload_type
)
;
EXPECT_EQ
(
red_payload_type_
encoded_info_
.
payload_type
)
;
}
#
if
GTEST_HAS_DEATH_TEST
&
&
!
defined
(
WEBRTC_ANDROID
)
class
AudioEncoderCopyRedDeathTest
:
public
AudioEncoderCopyRedTest
{
protected
:
AudioEncoderCopyRedDeathTest
(
)
:
AudioEncoderCopyRedTest
(
)
{
}
}
;
TEST_F
(
AudioEncoderCopyRedDeathTest
WrongFrameSize
)
{
num_audio_samples_10ms
*
=
2
;
EXPECT_DEATH
(
Encode
(
)
"
"
)
;
num_audio_samples_10ms
=
0
;
EXPECT_DEATH
(
Encode
(
)
"
"
)
;
}
TEST_F
(
AudioEncoderCopyRedDeathTest
NullSpeechEncoder
)
{
AudioEncoderCopyRed
*
red
=
NULL
;
AudioEncoderCopyRed
:
:
Config
config
;
config
.
speech_encoder
=
NULL
;
EXPECT_DEATH
(
red
=
new
AudioEncoderCopyRed
(
config
)
"
Speech
encoder
not
provided
.
"
)
;
delete
red
;
}
#
endif
}
