#
include
<
memory
>
#
include
<
string
>
#
include
"
modules
/
audio_coding
/
codecs
/
opus
/
opus_inst
.
h
"
#
include
"
modules
/
audio_coding
/
codecs
/
opus
/
opus_interface
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
audio_loop
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
test
/
gtest
.
h
"
#
include
"
test
/
testsupport
/
fileutils
.
h
"
namespace
webrtc
{
using
test
:
:
AudioLoop
;
using
:
:
testing
:
:
TestWithParam
;
using
:
:
testing
:
:
Values
;
using
:
:
testing
:
:
Combine
;
const
size_t
kMaxBytes
=
1000
;
const
size_t
kOpusRateKhz
=
48
;
const
size_t
kOpus20msFrameSamples
=
kOpusRateKhz
*
20
;
const
size_t
kOpus10msFrameSamples
=
kOpusRateKhz
*
10
;
class
OpusTest
:
public
TestWithParam
<
:
:
testing
:
:
tuple
<
int
int
>
>
{
protected
:
OpusTest
(
)
;
void
TestDtxEffect
(
bool
dtx
int
block_length_ms
)
;
void
TestCbrEffect
(
bool
dtx
int
block_length_ms
)
;
void
PrepareSpeechData
(
size_t
channel
int
block_length_ms
int
loop_length_ms
)
;
int
EncodeDecode
(
WebRtcOpusEncInst
*
encoder
rtc
:
:
ArrayView
<
const
int16_t
>
input_audio
WebRtcOpusDecInst
*
decoder
int16_t
*
output_audio
int16_t
*
audio_type
)
;
void
SetMaxPlaybackRate
(
WebRtcOpusEncInst
*
encoder
opus_int32
expect
int32_t
set
)
;
void
CheckAudioBounded
(
const
int16_t
*
audio
size_t
samples
size_t
channels
uint16_t
bound
)
const
;
WebRtcOpusEncInst
*
opus_encoder_
;
WebRtcOpusDecInst
*
opus_decoder_
;
AudioLoop
speech_data_
;
uint8_t
bitstream_
[
kMaxBytes
]
;
size_t
encoded_bytes_
;
size_t
channels_
;
int
application_
;
}
;
OpusTest
:
:
OpusTest
(
)
:
opus_encoder_
(
NULL
)
opus_decoder_
(
NULL
)
encoded_bytes_
(
0
)
channels_
(
static_cast
<
size_t
>
(
:
:
testing
:
:
get
<
0
>
(
GetParam
(
)
)
)
)
application_
(
:
:
testing
:
:
get
<
1
>
(
GetParam
(
)
)
)
{
}
void
OpusTest
:
:
PrepareSpeechData
(
size_t
channel
int
block_length_ms
int
loop_length_ms
)
{
const
std
:
:
string
file_name
=
webrtc
:
:
test
:
:
ResourcePath
(
(
channel
=
=
1
)
?
"
audio_coding
/
testfile32kHz
"
:
"
audio_coding
/
teststereo32kHz
"
"
pcm
"
)
;
if
(
loop_length_ms
<
block_length_ms
)
{
loop_length_ms
=
block_length_ms
;
}
EXPECT_TRUE
(
speech_data_
.
Init
(
file_name
loop_length_ms
*
kOpusRateKhz
*
channel
block_length_ms
*
kOpusRateKhz
*
channel
)
)
;
}
void
OpusTest
:
:
SetMaxPlaybackRate
(
WebRtcOpusEncInst
*
encoder
opus_int32
expect
int32_t
set
)
{
opus_int32
bandwidth
;
EXPECT_EQ
(
0
WebRtcOpus_SetMaxPlaybackRate
(
opus_encoder_
set
)
)
;
opus_encoder_ctl
(
opus_encoder_
-
>
encoder
OPUS_GET_MAX_BANDWIDTH
(
&
bandwidth
)
)
;
EXPECT_EQ
(
expect
bandwidth
)
;
}
void
OpusTest
:
:
CheckAudioBounded
(
const
int16_t
*
audio
size_t
samples
size_t
channels
uint16_t
bound
)
const
{
for
(
size_t
i
=
0
;
i
<
samples
;
+
+
i
)
{
for
(
size_t
c
=
0
;
c
<
channels
;
+
+
c
)
{
ASSERT_GE
(
audio
[
i
*
channels
+
c
]
-
bound
)
;
ASSERT_LE
(
audio
[
i
*
channels
+
c
]
bound
)
;
}
}
}
int
OpusTest
:
:
EncodeDecode
(
WebRtcOpusEncInst
*
encoder
rtc
:
:
ArrayView
<
const
int16_t
>
input_audio
WebRtcOpusDecInst
*
decoder
int16_t
*
output_audio
int16_t
*
audio_type
)
{
int
encoded_bytes_int
=
WebRtcOpus_Encode
(
encoder
input_audio
.
data
(
)
rtc
:
:
CheckedDivExact
(
input_audio
.
size
(
)
channels_
)
kMaxBytes
bitstream_
)
;
EXPECT_GE
(
encoded_bytes_int
0
)
;
encoded_bytes_
=
static_cast
<
size_t
>
(
encoded_bytes_int
)
;
int
est_len
=
WebRtcOpus_DurationEst
(
decoder
bitstream_
encoded_bytes_
)
;
int
act_len
=
WebRtcOpus_Decode
(
decoder
bitstream_
encoded_bytes_
output_audio
audio_type
)
;
EXPECT_EQ
(
est_len
act_len
)
;
return
act_len
;
}
void
OpusTest
:
:
TestDtxEffect
(
bool
dtx
int
block_length_ms
)
{
PrepareSpeechData
(
channels_
block_length_ms
2000
)
;
const
size_t
samples
=
kOpusRateKhz
*
block_length_ms
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderCreate
(
&
opus_decoder_
channels_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBitRate
(
opus_encoder_
channels_
=
=
1
?
32000
:
64000
)
)
;
std
:
:
vector
<
int16_t
>
silence
(
samples
*
channels_
0
)
;
EXPECT_EQ
(
0
dtx
?
WebRtcOpus_EnableDtx
(
opus_encoder_
)
:
WebRtcOpus_DisableDtx
(
opus_encoder_
)
)
;
int16_t
audio_type
;
int16_t
*
output_data_decode
=
new
int16_t
[
samples
*
channels_
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
EXPECT_EQ
(
samples
static_cast
<
size_t
>
(
EncodeDecode
(
opus_encoder_
speech_data_
.
GetNextBlock
(
)
opus_decoder_
output_data_decode
&
audio_type
)
)
)
;
if
(
!
dtx
)
{
EXPECT_GT
(
encoded_bytes_
1U
)
;
EXPECT_EQ
(
0
opus_encoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
opus_decoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
audio_type
)
;
}
}
for
(
int
i
=
0
;
i
<
30
;
+
+
i
)
{
EXPECT_EQ
(
samples
static_cast
<
size_t
>
(
EncodeDecode
(
opus_encoder_
silence
opus_decoder_
output_data_decode
&
audio_type
)
)
)
;
if
(
!
dtx
)
{
EXPECT_GT
(
encoded_bytes_
1U
)
;
EXPECT_EQ
(
0
opus_encoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
opus_decoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
audio_type
)
;
}
else
if
(
encoded_bytes_
=
=
1
)
{
EXPECT_EQ
(
1
opus_encoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
1
opus_decoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
2
audio_type
)
;
break
;
}
}
const
int
max_dtx_frames
=
400
/
block_length_ms
+
1
;
const
int
kRunTimeMs
=
4500
;
const
int
kCheckTimeMs
=
4000
;
#
if
defined
(
OPUS_FIXED_POINT
)
const
uint16_t
kOutputValueBound
=
30
;
#
else
const
uint16_t
kOutputValueBound
=
2
;
#
endif
int
time
=
0
;
while
(
time
<
kRunTimeMs
)
{
int
i
=
0
;
for
(
;
i
<
max_dtx_frames
;
+
+
i
)
{
time
+
=
block_length_ms
;
EXPECT_EQ
(
samples
static_cast
<
size_t
>
(
EncodeDecode
(
opus_encoder_
silence
opus_decoder_
output_data_decode
&
audio_type
)
)
)
;
if
(
dtx
)
{
if
(
encoded_bytes_
>
1
)
break
;
EXPECT_EQ
(
0U
encoded_bytes_
)
<
<
"
Opus
should
have
entered
DTX
mode
.
"
;
EXPECT_EQ
(
1
opus_encoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
1
opus_decoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
2
audio_type
)
;
if
(
time
>
=
kCheckTimeMs
)
{
CheckAudioBounded
(
output_data_decode
samples
channels_
kOutputValueBound
)
;
}
}
else
{
EXPECT_GT
(
encoded_bytes_
1U
)
;
EXPECT_EQ
(
0
opus_encoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
opus_decoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
audio_type
)
;
}
}
if
(
dtx
)
{
EXPECT_GT
(
i
1
)
;
}
EXPECT_EQ
(
0
opus_encoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
opus_decoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
audio_type
)
;
time
+
=
block_length_ms
;
EXPECT_EQ
(
samples
static_cast
<
size_t
>
(
EncodeDecode
(
opus_encoder_
silence
opus_decoder_
output_data_decode
&
audio_type
)
)
)
;
if
(
dtx
)
{
EXPECT_EQ
(
1U
encoded_bytes_
)
;
EXPECT_EQ
(
1
opus_encoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
1
opus_decoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
2
audio_type
)
;
if
(
time
>
=
kCheckTimeMs
)
{
CheckAudioBounded
(
output_data_decode
samples
channels_
kOutputValueBound
)
;
}
}
else
{
EXPECT_GT
(
encoded_bytes_
1U
)
;
EXPECT_EQ
(
0
opus_encoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
opus_decoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
audio_type
)
;
}
}
silence
[
0
]
=
10000
;
if
(
dtx
)
{
EXPECT_EQ
(
samples
static_cast
<
size_t
>
(
EncodeDecode
(
opus_encoder_
silence
opus_decoder_
output_data_decode
&
audio_type
)
)
)
;
EXPECT_GT
(
encoded_bytes_
1U
)
;
EXPECT_EQ
(
0
opus_encoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
opus_decoder_
-
>
in_dtx_mode
)
;
EXPECT_EQ
(
0
audio_type
)
;
}
delete
[
]
output_data_decode
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderFree
(
opus_decoder_
)
)
;
}
void
OpusTest
:
:
TestCbrEffect
(
bool
cbr
int
block_length_ms
)
{
PrepareSpeechData
(
channels_
block_length_ms
2000
)
;
const
size_t
samples
=
kOpusRateKhz
*
block_length_ms
;
int32_t
max_pkt_size_diff
=
0
;
int32_t
prev_pkt_size
=
0
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderCreate
(
&
opus_decoder_
channels_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBitRate
(
opus_encoder_
channels_
=
=
1
?
32000
:
64000
)
)
;
EXPECT_EQ
(
0
cbr
?
WebRtcOpus_EnableCbr
(
opus_encoder_
)
:
WebRtcOpus_DisableCbr
(
opus_encoder_
)
)
;
int16_t
audio_type
;
std
:
:
vector
<
int16_t
>
audio_out
(
samples
*
channels_
)
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
EXPECT_EQ
(
samples
static_cast
<
size_t
>
(
EncodeDecode
(
opus_encoder_
speech_data_
.
GetNextBlock
(
)
opus_decoder_
audio_out
.
data
(
)
&
audio_type
)
)
)
;
if
(
prev_pkt_size
>
0
)
{
int32_t
diff
=
std
:
:
abs
(
(
int32_t
)
encoded_bytes_
-
prev_pkt_size
)
;
max_pkt_size_diff
=
std
:
:
max
(
max_pkt_size_diff
diff
)
;
}
prev_pkt_size
=
rtc
:
:
checked_cast
<
int32_t
>
(
encoded_bytes_
)
;
}
if
(
cbr
)
{
EXPECT_EQ
(
max_pkt_size_diff
0
)
;
}
else
{
EXPECT_GT
(
max_pkt_size_diff
0
)
;
}
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderFree
(
opus_decoder_
)
)
;
}
TEST
(
OpusTest
OpusCreateFail
)
{
WebRtcOpusEncInst
*
opus_encoder
;
WebRtcOpusDecInst
*
opus_decoder
;
EXPECT_EQ
(
-
1
WebRtcOpus_EncoderCreate
(
NULL
1
0
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_EncoderCreate
(
&
opus_encoder
3
0
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_EncoderCreate
(
&
opus_encoder
1
2
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_DecoderCreate
(
NULL
1
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_DecoderCreate
(
&
opus_decoder
3
)
)
;
}
TEST
(
OpusTest
OpusFreeFail
)
{
EXPECT_EQ
(
-
1
WebRtcOpus_EncoderFree
(
NULL
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_DecoderFree
(
NULL
)
)
;
}
TEST_P
(
OpusTest
OpusCreateFree
)
{
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderCreate
(
&
opus_decoder_
channels_
)
)
;
EXPECT_TRUE
(
opus_encoder_
!
=
NULL
)
;
EXPECT_TRUE
(
opus_decoder_
!
=
NULL
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderFree
(
opus_decoder_
)
)
;
}
TEST_P
(
OpusTest
OpusEncodeDecode
)
{
PrepareSpeechData
(
channels_
20
20
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderCreate
(
&
opus_decoder_
channels_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBitRate
(
opus_encoder_
channels_
=
=
1
?
32000
:
64000
)
)
;
EXPECT_EQ
(
channels_
WebRtcOpus_DecoderChannels
(
opus_decoder_
)
)
;
opus_int32
app
;
opus_encoder_ctl
(
opus_encoder_
-
>
encoder
OPUS_GET_APPLICATION
(
&
app
)
)
;
EXPECT_EQ
(
application_
=
=
0
?
OPUS_APPLICATION_VOIP
:
OPUS_APPLICATION_AUDIO
app
)
;
int16_t
audio_type
;
int16_t
*
output_data_decode
=
new
int16_t
[
kOpus20msFrameSamples
*
channels_
]
;
EXPECT_EQ
(
kOpus20msFrameSamples
static_cast
<
size_t
>
(
EncodeDecode
(
opus_encoder_
speech_data_
.
GetNextBlock
(
)
opus_decoder_
output_data_decode
&
audio_type
)
)
)
;
delete
[
]
output_data_decode
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderFree
(
opus_decoder_
)
)
;
}
TEST_P
(
OpusTest
OpusSetBitRate
)
{
EXPECT_EQ
(
-
1
WebRtcOpus_SetBitRate
(
opus_encoder_
60000
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBitRate
(
opus_encoder_
30000
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBitRate
(
opus_encoder_
60000
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBitRate
(
opus_encoder_
300000
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBitRate
(
opus_encoder_
600000
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
}
TEST_P
(
OpusTest
OpusSetComplexity
)
{
EXPECT_EQ
(
-
1
WebRtcOpus_SetComplexity
(
opus_encoder_
9
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetComplexity
(
opus_encoder_
0
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetComplexity
(
opus_encoder_
10
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_SetComplexity
(
opus_encoder_
11
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
}
TEST_P
(
OpusTest
OpusSetBandwidth
)
{
PrepareSpeechData
(
channels_
20
20
)
;
int16_t
audio_type
;
std
:
:
unique_ptr
<
int16_t
[
]
>
output_data_decode
(
new
int16_t
[
kOpus20msFrameSamples
*
channels_
]
(
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_SetBandwidth
(
opus_encoder_
OPUS_BANDWIDTH_NARROWBAND
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_GetBandwidth
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderCreate
(
&
opus_decoder_
channels_
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_SetBandwidth
(
opus_encoder_
OPUS_BANDWIDTH_NARROWBAND
-
1
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBandwidth
(
opus_encoder_
OPUS_BANDWIDTH_NARROWBAND
)
)
;
EncodeDecode
(
opus_encoder_
speech_data_
.
GetNextBlock
(
)
opus_decoder_
output_data_decode
.
get
(
)
&
audio_type
)
;
EXPECT_EQ
(
OPUS_BANDWIDTH_NARROWBAND
WebRtcOpus_GetBandwidth
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBandwidth
(
opus_encoder_
OPUS_BANDWIDTH_FULLBAND
)
)
;
EncodeDecode
(
opus_encoder_
speech_data_
.
GetNextBlock
(
)
opus_decoder_
output_data_decode
.
get
(
)
&
audio_type
)
;
EXPECT_EQ
(
OPUS_BANDWIDTH_FULLBAND
WebRtcOpus_GetBandwidth
(
opus_encoder_
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_SetBandwidth
(
opus_encoder_
OPUS_BANDWIDTH_FULLBAND
+
1
)
)
;
EncodeDecode
(
opus_encoder_
speech_data_
.
GetNextBlock
(
)
opus_decoder_
output_data_decode
.
get
(
)
&
audio_type
)
;
EXPECT_EQ
(
OPUS_BANDWIDTH_FULLBAND
WebRtcOpus_GetBandwidth
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderFree
(
opus_decoder_
)
)
;
}
TEST_P
(
OpusTest
OpusForceChannels
)
{
EXPECT_EQ
(
-
1
WebRtcOpus_SetForceChannels
(
opus_encoder_
1
)
)
;
ASSERT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
if
(
channels_
=
=
2
)
{
EXPECT_EQ
(
-
1
WebRtcOpus_SetForceChannels
(
opus_encoder_
3
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetForceChannels
(
opus_encoder_
2
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetForceChannels
(
opus_encoder_
1
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetForceChannels
(
opus_encoder_
0
)
)
;
}
else
{
EXPECT_EQ
(
-
1
WebRtcOpus_SetForceChannels
(
opus_encoder_
2
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetForceChannels
(
opus_encoder_
1
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetForceChannels
(
opus_encoder_
0
)
)
;
}
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
}
TEST_P
(
OpusTest
OpusDecodeInit
)
{
PrepareSpeechData
(
channels_
20
20
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderCreate
(
&
opus_decoder_
channels_
)
)
;
int16_t
audio_type
;
int16_t
*
output_data_decode
=
new
int16_t
[
kOpus20msFrameSamples
*
channels_
]
;
EXPECT_EQ
(
kOpus20msFrameSamples
static_cast
<
size_t
>
(
EncodeDecode
(
opus_encoder_
speech_data_
.
GetNextBlock
(
)
opus_decoder_
output_data_decode
&
audio_type
)
)
)
;
WebRtcOpus_DecoderInit
(
opus_decoder_
)
;
EXPECT_EQ
(
kOpus20msFrameSamples
static_cast
<
size_t
>
(
WebRtcOpus_Decode
(
opus_decoder_
bitstream_
encoded_bytes_
output_data_decode
&
audio_type
)
)
)
;
delete
[
]
output_data_decode
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderFree
(
opus_decoder_
)
)
;
}
TEST_P
(
OpusTest
OpusEnableDisableFec
)
{
EXPECT_EQ
(
-
1
WebRtcOpus_EnableFec
(
opus_encoder_
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_DisableFec
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EnableFec
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DisableFec
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
}
TEST_P
(
OpusTest
OpusEnableDisableDtx
)
{
EXPECT_EQ
(
-
1
WebRtcOpus_EnableDtx
(
opus_encoder_
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_DisableDtx
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
opus_int32
dtx
;
opus_encoder_ctl
(
opus_encoder_
-
>
encoder
OPUS_GET_DTX
(
&
dtx
)
)
;
EXPECT_EQ
(
0
dtx
)
;
EXPECT_EQ
(
0
WebRtcOpus_EnableDtx
(
opus_encoder_
)
)
;
opus_encoder_ctl
(
opus_encoder_
-
>
encoder
OPUS_GET_DTX
(
&
dtx
)
)
;
EXPECT_EQ
(
1
dtx
)
;
EXPECT_EQ
(
0
WebRtcOpus_DisableDtx
(
opus_encoder_
)
)
;
opus_encoder_ctl
(
opus_encoder_
-
>
encoder
OPUS_GET_DTX
(
&
dtx
)
)
;
EXPECT_EQ
(
0
dtx
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
}
TEST_P
(
OpusTest
OpusDtxOff
)
{
TestDtxEffect
(
false
10
)
;
TestDtxEffect
(
false
20
)
;
TestDtxEffect
(
false
40
)
;
}
TEST_P
(
OpusTest
OpusDtxOn
)
{
TestDtxEffect
(
true
10
)
;
TestDtxEffect
(
true
20
)
;
TestDtxEffect
(
true
40
)
;
}
TEST_P
(
OpusTest
OpusCbrOff
)
{
TestCbrEffect
(
false
10
)
;
TestCbrEffect
(
false
20
)
;
TestCbrEffect
(
false
40
)
;
}
TEST_P
(
OpusTest
OpusCbrOn
)
{
TestCbrEffect
(
true
10
)
;
TestCbrEffect
(
true
20
)
;
TestCbrEffect
(
true
40
)
;
}
TEST_P
(
OpusTest
OpusSetPacketLossRate
)
{
EXPECT_EQ
(
-
1
WebRtcOpus_SetPacketLossRate
(
opus_encoder_
50
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetPacketLossRate
(
opus_encoder_
50
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_SetPacketLossRate
(
opus_encoder_
-
1
)
)
;
EXPECT_EQ
(
-
1
WebRtcOpus_SetPacketLossRate
(
opus_encoder_
101
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
}
TEST_P
(
OpusTest
OpusSetMaxPlaybackRate
)
{
EXPECT_EQ
(
-
1
WebRtcOpus_SetMaxPlaybackRate
(
opus_encoder_
20000
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_FULLBAND
48000
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_FULLBAND
24001
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_SUPERWIDEBAND
24000
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_SUPERWIDEBAND
16001
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_WIDEBAND
16000
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_WIDEBAND
12001
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_MEDIUMBAND
12000
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_MEDIUMBAND
8001
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_NARROWBAND
8000
)
;
SetMaxPlaybackRate
(
opus_encoder_
OPUS_BANDWIDTH_NARROWBAND
4000
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
}
TEST_P
(
OpusTest
OpusDecodePlc
)
{
PrepareSpeechData
(
channels_
20
20
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderCreate
(
&
opus_decoder_
channels_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBitRate
(
opus_encoder_
channels_
=
=
1
?
32000
:
64000
)
)
;
EXPECT_EQ
(
channels_
WebRtcOpus_DecoderChannels
(
opus_decoder_
)
)
;
int16_t
audio_type
;
int16_t
*
output_data_decode
=
new
int16_t
[
kOpus20msFrameSamples
*
channels_
]
;
EXPECT_EQ
(
kOpus20msFrameSamples
static_cast
<
size_t
>
(
EncodeDecode
(
opus_encoder_
speech_data_
.
GetNextBlock
(
)
opus_decoder_
output_data_decode
&
audio_type
)
)
)
;
int16_t
*
plc_buffer
=
new
int16_t
[
kOpus20msFrameSamples
*
channels_
]
;
EXPECT_EQ
(
kOpus20msFrameSamples
static_cast
<
size_t
>
(
WebRtcOpus_DecodePlc
(
opus_decoder_
plc_buffer
1
)
)
)
;
delete
[
]
plc_buffer
;
delete
[
]
output_data_decode
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderFree
(
opus_decoder_
)
)
;
}
TEST_P
(
OpusTest
OpusDurationEstimation
)
{
PrepareSpeechData
(
channels_
20
20
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderCreate
(
&
opus_decoder_
channels_
)
)
;
auto
speech_block
=
speech_data_
.
GetNextBlock
(
)
;
int
encoded_bytes_int
=
WebRtcOpus_Encode
(
opus_encoder_
speech_block
.
data
(
)
rtc
:
:
CheckedDivExact
(
speech_block
.
size
(
)
2
*
channels_
)
kMaxBytes
bitstream_
)
;
EXPECT_GE
(
encoded_bytes_int
0
)
;
EXPECT_EQ
(
kOpus10msFrameSamples
static_cast
<
size_t
>
(
WebRtcOpus_DurationEst
(
opus_decoder_
bitstream_
static_cast
<
size_t
>
(
encoded_bytes_int
)
)
)
)
;
speech_block
=
speech_data_
.
GetNextBlock
(
)
;
encoded_bytes_int
=
WebRtcOpus_Encode
(
opus_encoder_
speech_block
.
data
(
)
rtc
:
:
CheckedDivExact
(
speech_block
.
size
(
)
channels_
)
kMaxBytes
bitstream_
)
;
EXPECT_GE
(
encoded_bytes_int
0
)
;
EXPECT_EQ
(
kOpus20msFrameSamples
static_cast
<
size_t
>
(
WebRtcOpus_DurationEst
(
opus_decoder_
bitstream_
static_cast
<
size_t
>
(
encoded_bytes_int
)
)
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderFree
(
opus_decoder_
)
)
;
}
TEST_P
(
OpusTest
OpusDecodeRepacketized
)
{
constexpr
size_t
kPackets
=
6
;
PrepareSpeechData
(
channels_
20
20
*
kPackets
)
;
ASSERT_EQ
(
0
WebRtcOpus_EncoderCreate
(
&
opus_encoder_
channels_
application_
)
)
;
ASSERT_EQ
(
0
WebRtcOpus_DecoderCreate
(
&
opus_decoder_
channels_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_SetBitRate
(
opus_encoder_
channels_
=
=
1
?
32000
:
64000
)
)
;
EXPECT_EQ
(
channels_
WebRtcOpus_DecoderChannels
(
opus_decoder_
)
)
;
int16_t
audio_type
;
std
:
:
unique_ptr
<
int16_t
[
]
>
output_data_decode
(
new
int16_t
[
kPackets
*
kOpus20msFrameSamples
*
channels_
]
)
;
OpusRepacketizer
*
rp
=
opus_repacketizer_create
(
)
;
size_t
num_packets
=
0
;
constexpr
size_t
kMaxCycles
=
100
;
for
(
size_t
idx
=
0
;
idx
<
kMaxCycles
;
+
+
idx
)
{
auto
speech_block
=
speech_data_
.
GetNextBlock
(
)
;
encoded_bytes_
=
WebRtcOpus_Encode
(
opus_encoder_
speech_block
.
data
(
)
rtc
:
:
CheckedDivExact
(
speech_block
.
size
(
)
channels_
)
kMaxBytes
bitstream_
)
;
if
(
opus_repacketizer_cat
(
rp
bitstream_
rtc
:
:
checked_cast
<
opus_int32
>
(
encoded_bytes_
)
)
=
=
OPUS_OK
)
{
+
+
num_packets
;
if
(
num_packets
=
=
kPackets
)
{
break
;
}
}
else
{
opus_repacketizer_init
(
rp
)
;
num_packets
=
0
;
}
}
EXPECT_EQ
(
kPackets
num_packets
)
;
encoded_bytes_
=
opus_repacketizer_out
(
rp
bitstream_
kMaxBytes
)
;
EXPECT_EQ
(
kOpus20msFrameSamples
*
kPackets
static_cast
<
size_t
>
(
WebRtcOpus_DurationEst
(
opus_decoder_
bitstream_
encoded_bytes_
)
)
)
;
EXPECT_EQ
(
kOpus20msFrameSamples
*
kPackets
static_cast
<
size_t
>
(
WebRtcOpus_Decode
(
opus_decoder_
bitstream_
encoded_bytes_
output_data_decode
.
get
(
)
&
audio_type
)
)
)
;
opus_repacketizer_destroy
(
rp
)
;
EXPECT_EQ
(
0
WebRtcOpus_EncoderFree
(
opus_encoder_
)
)
;
EXPECT_EQ
(
0
WebRtcOpus_DecoderFree
(
opus_decoder_
)
)
;
}
INSTANTIATE_TEST_CASE_P
(
VariousMode
OpusTest
Combine
(
Values
(
1
2
)
Values
(
0
1
)
)
)
;
}
