#
include
<
algorithm
>
#
include
"
webrtc
/
modules
/
audio_coding
/
audio_network_adaptor
/
channel_controller
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
namespace
webrtc
{
ChannelController
:
:
Config
:
:
Config
(
size_t
num_encoder_channels
size_t
intial_channels_to_encode
int
channel_1_to_2_bandwidth_bps
int
channel_2_to_1_bandwidth_bps
)
:
num_encoder_channels
(
num_encoder_channels
)
intial_channels_to_encode
(
intial_channels_to_encode
)
channel_1_to_2_bandwidth_bps
(
channel_1_to_2_bandwidth_bps
)
channel_2_to_1_bandwidth_bps
(
channel_2_to_1_bandwidth_bps
)
{
}
ChannelController
:
:
ChannelController
(
const
Config
&
config
)
:
config_
(
config
)
channels_to_encode_
(
config_
.
intial_channels_to_encode
)
{
RTC_DCHECK_GT
(
config_
.
intial_channels_to_encode
0lu
)
;
RTC_DCHECK_LE
(
config_
.
intial_channels_to_encode
2lu
)
;
RTC_DCHECK_GE
(
config_
.
num_encoder_channels
config_
.
intial_channels_to_encode
)
;
}
void
ChannelController
:
:
MakeDecision
(
const
NetworkMetrics
&
metrics
AudioNetworkAdaptor
:
:
EncoderRuntimeConfig
*
config
)
{
RTC_DCHECK
(
!
config
-
>
num_channels
)
;
if
(
metrics
.
uplink_bandwidth_bps
)
{
if
(
channels_to_encode_
=
=
2
&
&
*
metrics
.
uplink_bandwidth_bps
<
=
config_
.
channel_2_to_1_bandwidth_bps
)
{
channels_to_encode_
=
1
;
}
else
if
(
channels_to_encode_
=
=
1
&
&
*
metrics
.
uplink_bandwidth_bps
>
=
config_
.
channel_1_to_2_bandwidth_bps
)
{
channels_to_encode_
=
std
:
:
min
(
static_cast
<
size_t
>
(
2
)
config_
.
num_encoder_channels
)
;
}
}
config
-
>
num_channels
=
rtc
:
:
Optional
<
size_t
>
(
channels_to_encode_
)
;
}
}
