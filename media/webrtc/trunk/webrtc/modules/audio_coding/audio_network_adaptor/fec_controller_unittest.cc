#
include
<
utility
>
#
include
"
webrtc
/
common_audio
/
mocks
/
mock_smoothing_filter
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
audio_network_adaptor
/
fec_controller
.
h
"
#
include
"
webrtc
/
test
/
gtest
.
h
"
namespace
webrtc
{
using
:
:
testing
:
:
NiceMock
;
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
_
;
namespace
{
constexpr
int
kDisablingBandwidthLow
=
15000
;
constexpr
float
kDisablingPacketLossAtLowBw
=
0
.
08f
;
constexpr
int
kDisablingBandwidthHigh
=
64000
;
constexpr
float
kDisablingPacketLossAtHighBw
=
0
.
01f
;
constexpr
int
kEnablingBandwidthLow
=
17000
;
constexpr
float
kEnablingPacketLossAtLowBw
=
0
.
1f
;
constexpr
int
kEnablingBandwidthHigh
=
64000
;
constexpr
float
kEnablingPacketLossAtHighBw
=
0
.
05f
;
struct
FecControllerStates
{
std
:
:
unique_ptr
<
FecController
>
controller
;
MockSmoothingFilter
*
packet_loss_smoothed
;
}
;
FecControllerStates
CreateFecController
(
bool
initial_fec_enabled
)
{
FecControllerStates
states
;
std
:
:
unique_ptr
<
MockSmoothingFilter
>
mock_smoothing_filter
(
new
NiceMock
<
MockSmoothingFilter
>
(
)
)
;
states
.
packet_loss_smoothed
=
mock_smoothing_filter
.
get
(
)
;
using
Threshold
=
FecController
:
:
Config
:
:
Threshold
;
states
.
controller
.
reset
(
new
FecController
(
FecController
:
:
Config
(
initial_fec_enabled
Threshold
(
kEnablingBandwidthLow
kEnablingPacketLossAtLowBw
kEnablingBandwidthHigh
kEnablingPacketLossAtHighBw
)
Threshold
(
kDisablingBandwidthLow
kDisablingPacketLossAtLowBw
kDisablingBandwidthHigh
kDisablingPacketLossAtHighBw
)
0
nullptr
)
std
:
:
move
(
mock_smoothing_filter
)
)
)
;
return
states
;
}
void
CheckDecision
(
FecControllerStates
*
states
const
rtc
:
:
Optional
<
int
>
&
uplink_bandwidth_bps
const
rtc
:
:
Optional
<
float
>
&
uplink_packet_loss
bool
expected_enable_fec
)
{
Controller
:
:
NetworkMetrics
metrics
;
metrics
.
uplink_bandwidth_bps
=
uplink_bandwidth_bps
;
metrics
.
uplink_packet_loss_fraction
=
uplink_packet_loss
;
if
(
uplink_packet_loss
)
{
EXPECT_CALL
(
*
states
-
>
packet_loss_smoothed
AddSample
(
*
uplink_packet_loss
)
)
;
}
EXPECT_CALL
(
*
states
-
>
packet_loss_smoothed
GetAverage
(
)
)
.
WillRepeatedly
(
Return
(
uplink_packet_loss
)
)
;
AudioNetworkAdaptor
:
:
EncoderRuntimeConfig
config
;
states
-
>
controller
-
>
MakeDecision
(
metrics
&
config
)
;
EXPECT_EQ
(
rtc
:
:
Optional
<
bool
>
(
expected_enable_fec
)
config
.
enable_fec
)
;
EXPECT_EQ
(
uplink_packet_loss
?
uplink_packet_loss
:
rtc
:
:
Optional
<
float
>
(
0
.
0
)
config
.
uplink_packet_loss_fraction
)
;
}
}
TEST
(
FecControllerTest
OutputInitValueWhenUplinkBandwidthUnknown
)
{
constexpr
bool
kInitialFecEnabled
=
true
;
auto
states
=
CreateFecController
(
kInitialFecEnabled
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
)
rtc
:
:
Optional
<
float
>
(
kDisablingPacketLossAtHighBw
)
kInitialFecEnabled
)
;
}
TEST
(
FecControllerTest
OutputInitValueWhenUplinkPacketLossFractionUnknown
)
{
constexpr
bool
kInitialFecEnabled
=
true
;
auto
states
=
CreateFecController
(
kInitialFecEnabled
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthLow
-
1
)
rtc
:
:
Optional
<
float
>
(
)
kInitialFecEnabled
)
;
}
TEST
(
FecControllerTest
EnableFecForHighBandwidth
)
{
auto
states
=
CreateFecController
(
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kEnablingBandwidthHigh
)
rtc
:
:
Optional
<
float
>
(
kEnablingPacketLossAtHighBw
)
true
)
;
}
TEST
(
FecControllerTest
MaintainFecOffForHighBandwidth
)
{
auto
states
=
CreateFecController
(
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kEnablingBandwidthHigh
)
rtc
:
:
Optional
<
float
>
(
kEnablingPacketLossAtHighBw
*
0
.
99f
)
false
)
;
}
TEST
(
FecControllerTest
EnableFecForMediumBandwidth
)
{
auto
states
=
CreateFecController
(
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
(
kEnablingBandwidthHigh
+
kEnablingBandwidthLow
)
/
2
)
rtc
:
:
Optional
<
float
>
(
(
kEnablingPacketLossAtLowBw
+
kEnablingPacketLossAtHighBw
)
/
2
.
0
)
true
)
;
}
TEST
(
FecControllerTest
MaintainFecOffForMediumBandwidth
)
{
auto
states
=
CreateFecController
(
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
(
kEnablingBandwidthHigh
+
kEnablingBandwidthLow
)
/
2
)
rtc
:
:
Optional
<
float
>
(
kEnablingPacketLossAtLowBw
*
0
.
49f
+
kEnablingPacketLossAtHighBw
*
0
.
51f
)
false
)
;
}
TEST
(
FecControllerTest
EnableFecForLowBandwidth
)
{
auto
states
=
CreateFecController
(
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kEnablingBandwidthLow
)
rtc
:
:
Optional
<
float
>
(
kEnablingPacketLossAtLowBw
)
true
)
;
}
TEST
(
FecControllerTest
MaintainFecOffForLowBandwidth
)
{
auto
states
=
CreateFecController
(
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kEnablingBandwidthLow
)
rtc
:
:
Optional
<
float
>
(
kEnablingPacketLossAtLowBw
*
0
.
99f
)
false
)
;
}
TEST
(
FecControllerTest
MaintainFecOffForVeryLowBandwidth
)
{
auto
states
=
CreateFecController
(
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kEnablingBandwidthLow
-
1
)
rtc
:
:
Optional
<
float
>
(
1
.
0
)
false
)
;
}
TEST
(
FecControllerTest
DisableFecForHighBandwidth
)
{
auto
states
=
CreateFecController
(
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthHigh
)
rtc
:
:
Optional
<
float
>
(
kDisablingPacketLossAtHighBw
)
false
)
;
}
TEST
(
FecControllerTest
MaintainFecOnForHighBandwidth
)
{
auto
states
=
CreateFecController
(
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthHigh
)
rtc
:
:
Optional
<
float
>
(
kDisablingPacketLossAtHighBw
*
1
.
01f
)
true
)
;
}
TEST
(
FecControllerTest
DisableFecOnMediumBandwidth
)
{
auto
states
=
CreateFecController
(
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
(
kDisablingBandwidthHigh
+
kDisablingBandwidthLow
)
/
2
)
rtc
:
:
Optional
<
float
>
(
(
kDisablingPacketLossAtLowBw
+
kDisablingPacketLossAtHighBw
)
/
2
.
0f
)
false
)
;
}
TEST
(
FecControllerTest
MaintainFecOnForMediumBandwidth
)
{
auto
states
=
CreateFecController
(
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
(
kEnablingBandwidthHigh
+
kDisablingBandwidthLow
)
/
2
)
rtc
:
:
Optional
<
float
>
(
kDisablingPacketLossAtLowBw
*
0
.
51f
+
kDisablingPacketLossAtHighBw
*
0
.
49f
)
true
)
;
}
TEST
(
FecControllerTest
DisableFecForLowBandwidth
)
{
auto
states
=
CreateFecController
(
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthLow
)
rtc
:
:
Optional
<
float
>
(
kDisablingPacketLossAtLowBw
)
false
)
;
}
TEST
(
FecControllerTest
DisableFecForVeryLowBandwidth
)
{
auto
states
=
CreateFecController
(
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthLow
-
1
)
rtc
:
:
Optional
<
float
>
(
1
.
0
)
false
)
;
}
TEST
(
FecControllerTest
CheckBehaviorOnChangingNetworkMetrics
)
{
auto
states
=
CreateFecController
(
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthLow
-
1
)
rtc
:
:
Optional
<
float
>
(
1
.
0
)
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kEnablingBandwidthLow
)
rtc
:
:
Optional
<
float
>
(
kEnablingPacketLossAtLowBw
*
0
.
99f
)
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kEnablingBandwidthHigh
)
rtc
:
:
Optional
<
float
>
(
kEnablingPacketLossAtHighBw
)
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthHigh
)
rtc
:
:
Optional
<
float
>
(
kDisablingPacketLossAtHighBw
*
1
.
01f
)
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthHigh
+
1
)
rtc
:
:
Optional
<
float
>
(
0
.
0
)
false
)
;
}
TEST
(
FecControllerTest
CheckBehaviorOnSpecialCurves
)
{
constexpr
int
kEnablingBandwidthHigh
=
kEnablingBandwidthLow
;
constexpr
float
kDisablingPacketLossAtLowBw
=
kDisablingPacketLossAtHighBw
;
FecControllerStates
states
;
std
:
:
unique_ptr
<
MockSmoothingFilter
>
mock_smoothing_filter
(
new
NiceMock
<
MockSmoothingFilter
>
(
)
)
;
states
.
packet_loss_smoothed
=
mock_smoothing_filter
.
get
(
)
;
using
Threshold
=
FecController
:
:
Config
:
:
Threshold
;
states
.
controller
.
reset
(
new
FecController
(
FecController
:
:
Config
(
true
Threshold
(
kEnablingBandwidthLow
kEnablingPacketLossAtLowBw
kEnablingBandwidthHigh
kEnablingPacketLossAtHighBw
)
Threshold
(
kDisablingBandwidthLow
kDisablingPacketLossAtLowBw
kDisablingBandwidthHigh
kDisablingPacketLossAtHighBw
)
0
nullptr
)
std
:
:
move
(
mock_smoothing_filter
)
)
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthLow
-
1
)
rtc
:
:
Optional
<
float
>
(
1
.
0
)
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kEnablingBandwidthLow
)
rtc
:
:
Optional
<
float
>
(
kEnablingPacketLossAtHighBw
*
0
.
99f
)
false
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kEnablingBandwidthHigh
)
rtc
:
:
Optional
<
float
>
(
kEnablingPacketLossAtHighBw
)
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthHigh
)
rtc
:
:
Optional
<
float
>
(
kDisablingPacketLossAtHighBw
*
1
.
01f
)
true
)
;
CheckDecision
(
&
states
rtc
:
:
Optional
<
int
>
(
kDisablingBandwidthHigh
+
1
)
rtc
:
:
Optional
<
float
>
(
0
.
0
)
false
)
;
}
#
if
RTC_DCHECK_IS_ON
&
&
GTEST_HAS_DEATH_TEST
&
&
!
defined
(
WEBRTC_ANDROID
)
TEST
(
FecControllerDeathTest
InvalidConfig
)
{
FecControllerStates
states
;
std
:
:
unique_ptr
<
MockSmoothingFilter
>
mock_smoothing_filter
(
new
NiceMock
<
MockSmoothingFilter
>
(
)
)
;
states
.
packet_loss_smoothed
=
mock_smoothing_filter
.
get
(
)
;
using
Threshold
=
FecController
:
:
Config
:
:
Threshold
;
EXPECT_DEATH
(
states
.
controller
.
reset
(
new
FecController
(
FecController
:
:
Config
(
true
Threshold
(
kDisablingBandwidthLow
-
1
kEnablingPacketLossAtLowBw
kEnablingBandwidthHigh
kEnablingPacketLossAtHighBw
)
Threshold
(
kDisablingBandwidthLow
kDisablingPacketLossAtLowBw
kDisablingBandwidthHigh
kDisablingPacketLossAtHighBw
)
0
nullptr
)
std
:
:
move
(
mock_smoothing_filter
)
)
)
"
Check
failed
"
)
;
}
#
endif
}
