#
ifndef
MODULES_AUDIO_CODING_ACM2_ACM_SEND_TEST_H_
#
define
MODULES_AUDIO_CODING_ACM2_ACM_SEND_TEST_H_
#
include
<
memory
>
#
include
<
vector
>
#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module
.
h
"
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
packet_source
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
webrtc
{
class
AudioEncoder
;
namespace
test
{
class
InputAudioFile
;
class
Packet
;
class
AcmSendTestOldApi
:
public
AudioPacketizationCallback
public
PacketSource
{
public
:
AcmSendTestOldApi
(
InputAudioFile
*
audio_source
int
source_rate_hz
int
test_duration_ms
)
;
~
AcmSendTestOldApi
(
)
override
;
bool
RegisterCodec
(
const
char
*
payload_name
int
sampling_freq_hz
int
channels
int
payload_type
int
frame_size_samples
)
;
bool
RegisterExternalCodec
(
AudioEncoder
*
external_speech_encoder
)
;
std
:
:
unique_ptr
<
Packet
>
NextPacket
(
)
override
;
int32_t
SendData
(
FrameType
frame_type
uint8_t
payload_type
uint32_t
timestamp
const
uint8_t
*
payload_data
size_t
payload_len_bytes
const
RTPFragmentationHeader
*
fragmentation
)
override
;
AudioCodingModule
*
acm
(
)
{
return
acm_
.
get
(
)
;
}
private
:
static
const
int
kBlockSizeMs
=
10
;
std
:
:
unique_ptr
<
Packet
>
CreatePacket
(
)
;
SimulatedClock
clock_
;
std
:
:
unique_ptr
<
AudioCodingModule
>
acm_
;
InputAudioFile
*
audio_source_
;
int
source_rate_hz_
;
const
size_t
input_block_size_samples_
;
AudioFrame
input_frame_
;
bool
codec_registered_
;
int
test_duration_ms_
;
FrameType
frame_type_
;
int
payload_type_
;
uint32_t
timestamp_
;
uint16_t
sequence_number_
;
std
:
:
vector
<
uint8_t
>
last_payload_vec_
;
bool
data_to_send_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AcmSendTestOldApi
)
;
}
;
}
}
#
endif
