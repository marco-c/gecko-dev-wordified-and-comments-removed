#
ifndef
WEBRTC_MODULES_AUDIO_CODING_ACM2_AUDIO_CODING_MODULE_IMPL_H_
#
define
WEBRTC_MODULES_AUDIO_CODING_ACM2_AUDIO_CODING_MODULE_IMPL_H_
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
buffer
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
thread_annotations
.
h
"
#
include
"
webrtc
/
common_types
.
h
"
#
include
"
webrtc
/
engine_configurations
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
acm2
/
acm_receiver
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
acm2
/
acm_resampler
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
acm2
/
codec_manager
.
h
"
namespace
webrtc
{
class
CriticalSectionWrapper
;
class
AudioCodingImpl
;
namespace
acm2
{
class
AudioCodingModuleImpl
final
:
public
AudioCodingModule
{
public
:
friend
webrtc
:
:
AudioCodingImpl
;
explicit
AudioCodingModuleImpl
(
const
AudioCodingModule
:
:
Config
&
config
)
;
~
AudioCodingModuleImpl
(
)
override
;
int
RegisterSendCodec
(
const
CodecInst
&
send_codec
)
override
;
void
RegisterExternalSendCodec
(
AudioEncoder
*
external_speech_encoder
)
override
;
rtc
:
:
Optional
<
CodecInst
>
SendCodec
(
)
const
override
;
int
SendFrequency
(
)
const
override
;
void
SetBitRate
(
int
bitrate_bps
)
override
;
int
RegisterTransportCallback
(
AudioPacketizationCallback
*
transport
)
override
;
int
Add10MsData
(
const
AudioFrame
&
audio_frame
)
override
;
int
SetREDStatus
(
bool
enable_red
)
override
;
bool
REDStatus
(
)
const
override
;
int
SetCodecFEC
(
bool
enabled_codec_fec
)
override
;
bool
CodecFEC
(
)
const
override
;
int
SetPacketLossRate
(
int
loss_rate
)
override
;
int
SetVAD
(
bool
enable_dtx
=
true
bool
enable_vad
=
false
ACMVADMode
mode
=
VADNormal
)
override
;
int
VAD
(
bool
*
dtx_enabled
bool
*
vad_enabled
ACMVADMode
*
mode
)
const
override
;
int
RegisterVADCallback
(
ACMVADCallback
*
vad_callback
)
override
;
int
InitializeReceiver
(
)
override
;
int
ReceiveFrequency
(
)
const
override
;
int
PlayoutFrequency
(
)
const
override
;
int
RegisterReceiveCodec
(
const
CodecInst
&
receive_codec
)
override
;
int
RegisterExternalReceiveCodec
(
int
rtp_payload_type
AudioDecoder
*
external_decoder
int
sample_rate_hz
int
num_channels
const
std
:
:
string
&
name
)
override
;
int
ReceiveCodec
(
CodecInst
*
current_codec
)
const
override
;
int
IncomingPacket
(
const
uint8_t
*
incoming_payload
const
size_t
payload_length
const
WebRtcRTPHeader
&
rtp_info
)
override
;
int
IncomingPayload
(
const
uint8_t
*
incoming_payload
const
size_t
payload_length
uint8_t
payload_type
uint32_t
timestamp
)
override
;
int
SetMinimumPlayoutDelay
(
int
time_ms
)
override
;
int
SetMaximumPlayoutDelay
(
int
time_ms
)
override
;
int
LeastRequiredDelayMs
(
)
const
override
;
int
PlayoutTimestamp
(
uint32_t
*
timestamp
)
override
;
int
PlayoutData10Ms
(
int
desired_freq_hz
AudioFrame
*
audio_frame
)
override
;
int
GetNetworkStatistics
(
NetworkStatistics
*
statistics
)
override
;
int
SetOpusApplication
(
OpusApplicationMode
application
)
override
;
int
SetOpusMaxPlaybackRate
(
int
frequency_hz
)
override
;
int
EnableOpusDtx
(
)
override
;
int
DisableOpusDtx
(
)
override
;
int
UnregisterReceiveCodec
(
uint8_t
payload_type
)
override
;
int
EnableNack
(
size_t
max_nack_list_size
)
override
;
void
DisableNack
(
)
override
;
std
:
:
vector
<
uint16_t
>
GetNackList
(
int64_t
round_trip_time_ms
)
const
override
;
void
GetDecodingCallStatistics
(
AudioDecodingCallStats
*
stats
)
const
override
;
private
:
struct
InputData
{
uint32_t
input_timestamp
;
const
int16_t
*
audio
;
size_t
length_per_channel
;
size_t
audio_channel
;
int16_t
buffer
[
WEBRTC_10MS_PCM_AUDIO
]
;
}
;
class
ChangeLogger
{
public
:
explicit
ChangeLogger
(
const
std
:
:
string
&
histogram_name
)
:
histogram_name_
(
histogram_name
)
{
}
void
MaybeLog
(
int
value
)
;
private
:
int
last_value_
=
0
;
int
first_time_
=
true
;
const
std
:
:
string
histogram_name_
;
}
;
int
Add10MsDataInternal
(
const
AudioFrame
&
audio_frame
InputData
*
input_data
)
EXCLUSIVE_LOCKS_REQUIRED
(
acm_crit_sect_
)
;
int
Encode
(
const
InputData
&
input_data
)
EXCLUSIVE_LOCKS_REQUIRED
(
acm_crit_sect_
)
;
int
InitializeReceiverSafe
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
acm_crit_sect_
)
;
bool
HaveValidEncoder
(
const
char
*
caller_name
)
const
EXCLUSIVE_LOCKS_REQUIRED
(
acm_crit_sect_
)
;
int
PreprocessToAddData
(
const
AudioFrame
&
in_frame
const
AudioFrame
*
*
ptr_out
)
EXCLUSIVE_LOCKS_REQUIRED
(
acm_crit_sect_
)
;
int
UpdateUponReceivingCodec
(
int
index
)
;
const
rtc
:
:
scoped_ptr
<
CriticalSectionWrapper
>
acm_crit_sect_
;
rtc
:
:
Buffer
encode_buffer_
GUARDED_BY
(
acm_crit_sect_
)
;
int
id_
;
uint32_t
expected_codec_ts_
GUARDED_BY
(
acm_crit_sect_
)
;
uint32_t
expected_in_ts_
GUARDED_BY
(
acm_crit_sect_
)
;
ACMResampler
resampler_
GUARDED_BY
(
acm_crit_sect_
)
;
AcmReceiver
receiver_
;
ChangeLogger
bitrate_logger_
GUARDED_BY
(
acm_crit_sect_
)
;
CodecManager
codec_manager_
GUARDED_BY
(
acm_crit_sect_
)
;
RentACodec
rent_a_codec_
GUARDED_BY
(
acm_crit_sect_
)
;
uint8_t
previous_pltype_
GUARDED_BY
(
acm_crit_sect_
)
;
rtc
:
:
scoped_ptr
<
WebRtcRTPHeader
>
aux_rtp_header_
;
bool
receiver_initialized_
GUARDED_BY
(
acm_crit_sect_
)
;
AudioFrame
preprocess_frame_
GUARDED_BY
(
acm_crit_sect_
)
;
bool
first_10ms_data_
GUARDED_BY
(
acm_crit_sect_
)
;
bool
first_frame_
GUARDED_BY
(
acm_crit_sect_
)
;
uint32_t
last_timestamp_
GUARDED_BY
(
acm_crit_sect_
)
;
uint32_t
last_rtp_timestamp_
GUARDED_BY
(
acm_crit_sect_
)
;
const
rtc
:
:
scoped_ptr
<
CriticalSectionWrapper
>
callback_crit_sect_
;
AudioPacketizationCallback
*
packetization_callback_
GUARDED_BY
(
callback_crit_sect_
)
;
ACMVADCallback
*
vad_callback_
GUARDED_BY
(
callback_crit_sect_
)
;
}
;
}
}
#
endif
