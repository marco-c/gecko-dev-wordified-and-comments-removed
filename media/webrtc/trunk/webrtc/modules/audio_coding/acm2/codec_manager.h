#
ifndef
MODULES_AUDIO_CODING_ACM2_CODEC_MANAGER_H_
#
define
MODULES_AUDIO_CODING_ACM2_CODEC_MANAGER_H_
#
include
<
map
>
#
include
"
api
/
optional
.
h
"
#
include
"
common_types
.
h
"
#
include
"
modules
/
audio_coding
/
acm2
/
rent_a_codec
.
h
"
#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module
.
h
"
#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module_typedefs
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
thread_checker
.
h
"
namespace
webrtc
{
class
AudioDecoder
;
class
AudioEncoder
;
namespace
acm2
{
class
CodecManager
final
{
public
:
CodecManager
(
)
;
~
CodecManager
(
)
;
bool
RegisterEncoder
(
const
CodecInst
&
send_codec
)
;
static
CodecInst
ForgeCodecInst
(
const
AudioEncoder
*
external_speech_encoder
)
;
const
CodecInst
*
GetCodecInst
(
)
const
{
return
send_codec_inst_
?
&
*
send_codec_inst_
:
nullptr
;
}
void
UnsetCodecInst
(
)
{
send_codec_inst_
=
rtc
:
:
nullopt
;
}
const
RentACodec
:
:
StackParameters
*
GetStackParams
(
)
const
{
return
&
codec_stack_params_
;
}
RentACodec
:
:
StackParameters
*
GetStackParams
(
)
{
return
&
codec_stack_params_
;
}
bool
SetCopyRed
(
bool
enable
)
;
bool
SetVAD
(
bool
enable
ACMVADMode
mode
)
;
bool
SetCodecFEC
(
bool
enable_codec_fec
)
;
bool
MakeEncoder
(
RentACodec
*
rac
AudioCodingModule
*
acm
)
;
private
:
rtc
:
:
ThreadChecker
thread_checker_
;
rtc
:
:
Optional
<
CodecInst
>
send_codec_inst_
;
RentACodec
:
:
StackParameters
codec_stack_params_
;
bool
recreate_encoder_
=
true
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
CodecManager
)
;
}
;
}
}
#
endif
