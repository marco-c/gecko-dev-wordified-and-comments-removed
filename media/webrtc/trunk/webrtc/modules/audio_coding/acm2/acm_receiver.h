#
ifndef
WEBRTC_MODULES_AUDIO_CODING_ACM2_ACM_RECEIVER_H_
#
define
WEBRTC_MODULES_AUDIO_CODING_ACM2_ACM_RECEIVER_H_
#
include
<
map
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
array_view
.
h
"
#
include
"
webrtc
/
base
/
optional
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
thread_annotations
.
h
"
#
include
"
webrtc
/
common_audio
/
vad
/
include
/
webrtc_vad
.
h
"
#
include
"
webrtc
/
engine_configurations
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
include
/
audio_coding_module
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
acm2
/
acm_resampler
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
acm2
/
call_statistics
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
acm2
/
initial_delay_manager
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
neteq
/
include
/
neteq
.
h
"
#
include
"
webrtc
/
modules
/
include
/
module_common_types
.
h
"
#
include
"
webrtc
/
typedefs
.
h
"
namespace
webrtc
{
struct
CodecInst
;
class
CriticalSectionWrapper
;
class
NetEq
;
namespace
acm2
{
class
AcmReceiver
{
public
:
struct
Decoder
{
int
acm_codec_id
;
uint8_t
payload_type
;
size_t
channels
;
int
sample_rate_hz
;
}
;
explicit
AcmReceiver
(
const
AudioCodingModule
:
:
Config
&
config
)
;
~
AcmReceiver
(
)
;
int
InsertPacket
(
const
WebRtcRTPHeader
&
rtp_header
rtc
:
:
ArrayView
<
const
uint8_t
>
incoming_payload
)
;
int
GetAudio
(
int
desired_freq_hz
AudioFrame
*
audio_frame
)
;
int
AddCodec
(
int
acm_codec_id
uint8_t
payload_type
size_t
channels
int
sample_rate_hz
AudioDecoder
*
audio_decoder
const
std
:
:
string
&
name
)
;
int
SetMinimumDelay
(
int
delay_ms
)
;
int
SetMaximumDelay
(
int
delay_ms
)
;
int
LeastRequiredDelayMs
(
)
const
;
void
ResetInitialDelay
(
)
;
rtc
:
:
Optional
<
int
>
last_packet_sample_rate_hz
(
)
const
;
int
last_output_sample_rate_hz
(
)
const
;
void
GetNetworkStatistics
(
NetworkStatistics
*
statistics
)
;
void
EnableVad
(
)
;
void
DisableVad
(
)
;
bool
vad_enabled
(
)
const
{
return
vad_enabled_
;
}
void
FlushBuffers
(
)
;
int
RemoveCodec
(
uint8_t
payload_type
)
;
int
RemoveAllCodecs
(
)
;
void
set_id
(
int
id
)
;
bool
GetPlayoutTimestamp
(
uint32_t
*
timestamp
)
;
int
LastAudioCodec
(
CodecInst
*
codec
)
const
;
int
DecoderByPayloadType
(
uint8_t
payload_type
CodecInst
*
codec
)
const
;
int
EnableNack
(
size_t
max_nack_list_size
)
;
void
DisableNack
(
)
;
std
:
:
vector
<
uint16_t
>
GetNackList
(
int64_t
round_trip_time_ms
)
const
;
void
GetDecodingCallStatistics
(
AudioDecodingCallStats
*
stats
)
const
;
private
:
const
Decoder
*
RtpHeaderToDecoder
(
const
RTPHeader
&
rtp_header
uint8_t
payload_type
)
const
EXCLUSIVE_LOCKS_REQUIRED
(
crit_sect_
)
;
uint32_t
NowInTimestamp
(
int
decoder_sampling_rate
)
const
;
rtc
:
:
scoped_ptr
<
CriticalSectionWrapper
>
crit_sect_
;
int
id_
;
const
Decoder
*
last_audio_decoder_
GUARDED_BY
(
crit_sect_
)
;
AudioFrame
:
:
VADActivity
previous_audio_activity_
GUARDED_BY
(
crit_sect_
)
;
ACMResampler
resampler_
GUARDED_BY
(
crit_sect_
)
;
rtc
:
:
scoped_ptr
<
int16_t
[
]
>
audio_buffer_
GUARDED_BY
(
crit_sect_
)
;
rtc
:
:
scoped_ptr
<
int16_t
[
]
>
last_audio_buffer_
GUARDED_BY
(
crit_sect_
)
;
CallStatistics
call_stats_
GUARDED_BY
(
crit_sect_
)
;
NetEq
*
neteq_
;
std
:
:
map
<
uint8_t
Decoder
>
decoders_
GUARDED_BY
(
crit_sect_
)
;
bool
vad_enabled_
;
Clock
*
clock_
;
bool
resampled_last_output_frame_
GUARDED_BY
(
crit_sect_
)
;
rtc
:
:
Optional
<
int
>
last_packet_sample_rate_hz_
GUARDED_BY
(
crit_sect_
)
;
}
;
}
}
#
endif
