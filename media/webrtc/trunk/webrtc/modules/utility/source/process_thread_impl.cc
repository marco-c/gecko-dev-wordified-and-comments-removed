#
include
"
webrtc
/
modules
/
utility
/
source
/
process_thread_impl
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
modules
/
include
/
module
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
logging
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
tick_util
.
h
"
namespace
webrtc
{
namespace
{
const
int64_t
kCallProcessImmediately
=
-
1
;
int64_t
GetNextCallbackTime
(
Module
*
module
int64_t
time_now
)
{
int64_t
interval
=
module
-
>
TimeUntilNextProcess
(
)
;
if
(
interval
<
0
)
{
return
time_now
;
}
return
time_now
+
interval
;
}
}
ProcessThread
:
:
~
ProcessThread
(
)
{
}
rtc
:
:
scoped_ptr
<
ProcessThread
>
ProcessThread
:
:
Create
(
const
char
*
thread_name
)
{
return
rtc
:
:
scoped_ptr
<
ProcessThread
>
(
new
ProcessThreadImpl
(
thread_name
)
)
;
}
ProcessThreadImpl
:
:
ProcessThreadImpl
(
const
char
*
thread_name
)
:
wake_up_
(
EventWrapper
:
:
Create
(
)
)
stop_
(
false
)
thread_name_
(
thread_name
)
{
}
ProcessThreadImpl
:
:
~
ProcessThreadImpl
(
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
!
thread_
.
get
(
)
)
;
RTC_DCHECK
(
!
stop_
)
;
while
(
!
queue_
.
empty
(
)
)
{
delete
queue_
.
front
(
)
;
queue_
.
pop
(
)
;
}
}
void
ProcessThreadImpl
:
:
Start
(
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
!
thread_
.
get
(
)
)
;
if
(
thread_
.
get
(
)
)
return
;
RTC_DCHECK
(
!
stop_
)
;
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
for
(
ModuleCallback
&
m
:
modules_
)
m
.
module
-
>
ProcessThreadAttached
(
this
)
;
}
thread_
.
reset
(
new
rtc
:
:
PlatformThread
(
&
ProcessThreadImpl
:
:
Run
this
thread_name_
)
)
;
thread_
-
>
Start
(
)
;
}
void
ProcessThreadImpl
:
:
Stop
(
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
!
thread_
.
get
(
)
)
return
;
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
stop_
=
true
;
}
wake_up_
-
>
Set
(
)
;
thread_
-
>
Stop
(
)
;
stop_
=
false
;
rtc
:
:
CritScope
lock
(
&
lock_
)
;
thread_
.
reset
(
)
;
for
(
ModuleCallback
&
m
:
modules_
)
m
.
module
-
>
ProcessThreadAttached
(
nullptr
)
;
}
void
ProcessThreadImpl
:
:
WakeUp
(
Module
*
module
)
{
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
for
(
ModuleCallback
&
m
:
modules_
)
{
if
(
m
.
module
=
=
module
)
m
.
next_callback
=
kCallProcessImmediately
;
}
}
wake_up_
-
>
Set
(
)
;
}
void
ProcessThreadImpl
:
:
PostTask
(
rtc
:
:
scoped_ptr
<
ProcessTask
>
task
)
{
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
queue_
.
push
(
task
.
release
(
)
)
;
}
wake_up_
-
>
Set
(
)
;
}
void
ProcessThreadImpl
:
:
RegisterModule
(
Module
*
module
)
{
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
module
)
;
#
if
(
!
defined
(
NDEBUG
)
|
|
defined
(
DCHECK_ALWAYS_ON
)
)
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
for
(
const
ModuleCallback
&
mc
:
modules_
)
RTC_DCHECK
(
mc
.
module
!
=
module
)
;
}
#
endif
if
(
thread_
.
get
(
)
)
module
-
>
ProcessThreadAttached
(
this
)
;
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
modules_
.
push_back
(
ModuleCallback
(
module
)
)
;
}
wake_up_
-
>
Set
(
)
;
}
void
ProcessThreadImpl
:
:
DeRegisterModule
(
Module
*
module
)
{
RTC_DCHECK
(
module
)
;
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
modules_
.
remove_if
(
[
&
module
]
(
const
ModuleCallback
&
m
)
{
return
m
.
module
=
=
module
;
}
)
;
if
(
thread_
.
get
(
)
)
module
-
>
ProcessThreadAttached
(
nullptr
)
;
}
}
bool
ProcessThreadImpl
:
:
Run
(
void
*
obj
)
{
return
static_cast
<
ProcessThreadImpl
*
>
(
obj
)
-
>
Process
(
)
;
}
bool
ProcessThreadImpl
:
:
Process
(
)
{
int64_t
now
=
TickTime
:
:
MillisecondTimestamp
(
)
;
int64_t
next_checkpoint
=
now
+
(
1000
*
60
)
;
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
if
(
stop_
)
return
false
;
for
(
ModuleCallback
&
m
:
modules_
)
{
if
(
m
.
next_callback
=
=
0
)
m
.
next_callback
=
GetNextCallbackTime
(
m
.
module
now
)
;
if
(
m
.
next_callback
<
=
now
|
|
m
.
next_callback
=
=
kCallProcessImmediately
)
{
m
.
module
-
>
Process
(
)
;
int64_t
new_now
=
TickTime
:
:
MillisecondTimestamp
(
)
;
m
.
next_callback
=
GetNextCallbackTime
(
m
.
module
new_now
)
;
}
if
(
m
.
next_callback
<
next_checkpoint
)
next_checkpoint
=
m
.
next_callback
;
}
while
(
!
queue_
.
empty
(
)
)
{
ProcessTask
*
task
=
queue_
.
front
(
)
;
queue_
.
pop
(
)
;
lock_
.
Leave
(
)
;
task
-
>
Run
(
)
;
delete
task
;
lock_
.
Enter
(
)
;
}
}
int64_t
time_to_wait
=
next_checkpoint
-
TickTime
:
:
MillisecondTimestamp
(
)
;
if
(
time_to_wait
>
0
)
wake_up_
-
>
Wait
(
static_cast
<
unsigned
long
>
(
time_to_wait
)
)
;
return
true
;
}
}
