#
ifndef
WEBRTC_MODULES_UTILITY_SOURCE_PROCESS_THREAD_IMPL_H_
#
define
WEBRTC_MODULES_UTILITY_SOURCE_PROCESS_THREAD_IMPL_H_
#
include
<
list
>
#
include
<
memory
>
#
include
<
queue
>
#
include
"
webrtc
/
base
/
criticalsection
.
h
"
#
include
"
webrtc
/
base
/
platform_thread
.
h
"
#
include
"
webrtc
/
base
/
thread_checker
.
h
"
#
include
"
webrtc
/
modules
/
utility
/
include
/
process_thread
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
event_wrapper
.
h
"
#
include
"
webrtc
/
typedefs
.
h
"
namespace
webrtc
{
class
ProcessThreadImpl
:
public
ProcessThread
{
public
:
explicit
ProcessThreadImpl
(
const
char
*
thread_name
)
;
~
ProcessThreadImpl
(
)
override
;
void
Start
(
)
override
;
void
Stop
(
)
override
;
void
WakeUp
(
Module
*
module
)
override
;
void
PostTask
(
std
:
:
unique_ptr
<
rtc
:
:
QueuedTask
>
task
)
override
;
void
RegisterModule
(
Module
*
module
)
override
;
void
DeRegisterModule
(
Module
*
module
)
override
;
protected
:
static
bool
Run
(
void
*
obj
)
;
bool
Process
(
)
;
private
:
struct
ModuleCallback
{
ModuleCallback
(
)
:
module
(
nullptr
)
next_callback
(
0
)
{
}
ModuleCallback
(
const
ModuleCallback
&
cb
)
:
module
(
cb
.
module
)
next_callback
(
cb
.
next_callback
)
{
}
ModuleCallback
(
Module
*
module
)
:
module
(
module
)
next_callback
(
0
)
{
}
bool
operator
=
=
(
const
ModuleCallback
&
cb
)
const
{
return
cb
.
module
=
=
module
;
}
Module
*
const
module
;
int64_t
next_callback
;
private
:
ModuleCallback
&
operator
=
(
ModuleCallback
&
)
;
}
;
typedef
std
:
:
list
<
ModuleCallback
>
ModuleList
;
rtc
:
:
CriticalSection
lock_
;
rtc
:
:
ThreadChecker
thread_checker_
;
const
std
:
:
unique_ptr
<
EventWrapper
>
wake_up_
;
std
:
:
unique_ptr
<
rtc
:
:
PlatformThread
>
thread_
;
ModuleList
modules_
;
std
:
:
queue
<
rtc
:
:
QueuedTask
*
>
queue_
;
bool
stop_
;
const
char
*
thread_name_
;
}
;
}
#
endif
