#
ifndef
MODULES_INCLUDE_MODULE_COMMON_TYPES_H_
#
define
MODULES_INCLUDE_MODULE_COMMON_TYPES_H_
#
include
<
assert
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
limits
>
#
include
"
api
/
optional
.
h
"
#
include
"
api
/
video
/
video_rotation
.
h
"
#
include
"
common_types
.
h
"
#
include
"
modules
/
include
/
module_common_types_public
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
h264
/
include
/
h264_globals
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp8
/
include
/
vp8_globals
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp9
/
include
/
vp9_globals
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
deprecation
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
#
include
"
rtc_base
/
timeutils
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
struct
RTPAudioHeader
{
uint8_t
numEnergy
;
uint8_t
arrOfEnergy
[
kRtpCsrcSize
]
;
bool
isCNG
;
size_t
channel
;
}
;
union
RTPVideoTypeHeader
{
RTPVideoHeaderVP8
VP8
;
RTPVideoHeaderVP9
VP9
;
RTPVideoHeaderH264
H264
;
}
;
enum
RtpVideoCodecTypes
{
kRtpVideoNone
kRtpVideoGeneric
kRtpVideoVp8
kRtpVideoVp9
kRtpVideoH264
}
;
struct
RTPVideoHeader
{
uint16_t
width
;
uint16_t
height
;
VideoRotation
rotation
;
PlayoutDelay
playout_delay
;
VideoContentType
content_type
;
VideoSendTiming
video_timing
;
bool
is_first_packet_in_frame
;
uint8_t
simulcastIdx
;
RtpVideoCodecTypes
codec
;
RTPVideoTypeHeader
codecHeader
;
}
;
union
RTPTypeHeader
{
RTPAudioHeader
Audio
;
RTPVideoHeader
Video
;
}
;
struct
WebRtcRTPHeader
{
RTPHeader
header
;
FrameType
frameType
;
RTPTypeHeader
type
;
int64_t
ntp_time_ms
;
}
;
class
RTPFragmentationHeader
{
public
:
RTPFragmentationHeader
(
)
:
fragmentationVectorSize
(
0
)
fragmentationOffset
(
NULL
)
fragmentationLength
(
NULL
)
fragmentationTimeDiff
(
NULL
)
fragmentationPlType
(
NULL
)
{
}
RTPFragmentationHeader
(
RTPFragmentationHeader
&
&
other
)
:
RTPFragmentationHeader
(
)
{
std
:
:
swap
(
*
this
other
)
;
}
~
RTPFragmentationHeader
(
)
{
delete
[
]
fragmentationOffset
;
delete
[
]
fragmentationLength
;
delete
[
]
fragmentationTimeDiff
;
delete
[
]
fragmentationPlType
;
}
void
operator
=
(
RTPFragmentationHeader
&
&
other
)
{
std
:
:
swap
(
*
this
other
)
;
}
friend
void
swap
(
RTPFragmentationHeader
&
a
RTPFragmentationHeader
&
b
)
{
using
std
:
:
swap
;
swap
(
a
.
fragmentationVectorSize
b
.
fragmentationVectorSize
)
;
swap
(
a
.
fragmentationOffset
b
.
fragmentationOffset
)
;
swap
(
a
.
fragmentationLength
b
.
fragmentationLength
)
;
swap
(
a
.
fragmentationTimeDiff
b
.
fragmentationTimeDiff
)
;
swap
(
a
.
fragmentationPlType
b
.
fragmentationPlType
)
;
}
void
CopyFrom
(
const
RTPFragmentationHeader
&
src
)
{
if
(
this
=
=
&
src
)
{
return
;
}
if
(
src
.
fragmentationVectorSize
!
=
fragmentationVectorSize
)
{
delete
[
]
fragmentationOffset
;
fragmentationOffset
=
NULL
;
delete
[
]
fragmentationLength
;
fragmentationLength
=
NULL
;
delete
[
]
fragmentationTimeDiff
;
fragmentationTimeDiff
=
NULL
;
delete
[
]
fragmentationPlType
;
fragmentationPlType
=
NULL
;
if
(
src
.
fragmentationVectorSize
>
0
)
{
if
(
src
.
fragmentationOffset
)
{
fragmentationOffset
=
new
size_t
[
src
.
fragmentationVectorSize
]
;
}
if
(
src
.
fragmentationLength
)
{
fragmentationLength
=
new
size_t
[
src
.
fragmentationVectorSize
]
;
}
if
(
src
.
fragmentationTimeDiff
)
{
fragmentationTimeDiff
=
new
uint16_t
[
src
.
fragmentationVectorSize
]
;
}
if
(
src
.
fragmentationPlType
)
{
fragmentationPlType
=
new
uint8_t
[
src
.
fragmentationVectorSize
]
;
}
}
fragmentationVectorSize
=
src
.
fragmentationVectorSize
;
}
if
(
src
.
fragmentationVectorSize
>
0
)
{
if
(
src
.
fragmentationOffset
)
{
memcpy
(
fragmentationOffset
src
.
fragmentationOffset
src
.
fragmentationVectorSize
*
sizeof
(
size_t
)
)
;
}
if
(
src
.
fragmentationLength
)
{
memcpy
(
fragmentationLength
src
.
fragmentationLength
src
.
fragmentationVectorSize
*
sizeof
(
size_t
)
)
;
}
if
(
src
.
fragmentationTimeDiff
)
{
memcpy
(
fragmentationTimeDiff
src
.
fragmentationTimeDiff
src
.
fragmentationVectorSize
*
sizeof
(
uint16_t
)
)
;
}
if
(
src
.
fragmentationPlType
)
{
memcpy
(
fragmentationPlType
src
.
fragmentationPlType
src
.
fragmentationVectorSize
*
sizeof
(
uint8_t
)
)
;
}
}
}
void
VerifyAndAllocateFragmentationHeader
(
const
size_t
size
)
{
assert
(
size
<
=
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
)
;
const
uint16_t
size16
=
static_cast
<
uint16_t
>
(
size
)
;
if
(
fragmentationVectorSize
<
size16
)
{
uint16_t
oldVectorSize
=
fragmentationVectorSize
;
{
size_t
*
oldOffsets
=
fragmentationOffset
;
fragmentationOffset
=
new
size_t
[
size16
]
;
memset
(
fragmentationOffset
+
oldVectorSize
0
sizeof
(
size_t
)
*
(
size16
-
oldVectorSize
)
)
;
memcpy
(
fragmentationOffset
oldOffsets
sizeof
(
size_t
)
*
oldVectorSize
)
;
delete
[
]
oldOffsets
;
}
{
size_t
*
oldLengths
=
fragmentationLength
;
fragmentationLength
=
new
size_t
[
size16
]
;
memset
(
fragmentationLength
+
oldVectorSize
0
sizeof
(
size_t
)
*
(
size16
-
oldVectorSize
)
)
;
memcpy
(
fragmentationLength
oldLengths
sizeof
(
size_t
)
*
oldVectorSize
)
;
delete
[
]
oldLengths
;
}
{
uint16_t
*
oldTimeDiffs
=
fragmentationTimeDiff
;
fragmentationTimeDiff
=
new
uint16_t
[
size16
]
;
memset
(
fragmentationTimeDiff
+
oldVectorSize
0
sizeof
(
uint16_t
)
*
(
size16
-
oldVectorSize
)
)
;
memcpy
(
fragmentationTimeDiff
oldTimeDiffs
sizeof
(
uint16_t
)
*
oldVectorSize
)
;
delete
[
]
oldTimeDiffs
;
}
{
uint8_t
*
oldTimePlTypes
=
fragmentationPlType
;
fragmentationPlType
=
new
uint8_t
[
size16
]
;
memset
(
fragmentationPlType
+
oldVectorSize
0
sizeof
(
uint8_t
)
*
(
size16
-
oldVectorSize
)
)
;
memcpy
(
fragmentationPlType
oldTimePlTypes
sizeof
(
uint8_t
)
*
oldVectorSize
)
;
delete
[
]
oldTimePlTypes
;
}
fragmentationVectorSize
=
size16
;
}
}
uint16_t
fragmentationVectorSize
;
size_t
*
fragmentationOffset
;
size_t
*
fragmentationLength
;
uint16_t
*
fragmentationTimeDiff
;
uint8_t
*
fragmentationPlType
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
RTPFragmentationHeader
)
;
}
;
struct
RTCPVoIPMetric
{
uint8_t
lossRate
;
uint8_t
discardRate
;
uint8_t
burstDensity
;
uint8_t
gapDensity
;
uint16_t
burstDuration
;
uint16_t
gapDuration
;
uint16_t
roundTripDelay
;
uint16_t
endSystemDelay
;
uint8_t
signalLevel
;
uint8_t
noiseLevel
;
uint8_t
RERL
;
uint8_t
Gmin
;
uint8_t
Rfactor
;
uint8_t
extRfactor
;
uint8_t
MOSLQ
;
uint8_t
MOSCQ
;
uint8_t
RXconfig
;
uint16_t
JBnominal
;
uint16_t
JBmax
;
uint16_t
JBabsMax
;
}
;
enum
FecMaskType
{
kFecMaskRandom
kFecMaskBursty
}
;
struct
FecProtectionParams
{
int
fec_rate
;
int
max_fec_frames
;
FecMaskType
fec_mask_type
;
}
;
class
CallStatsObserver
{
public
:
virtual
void
OnRttUpdate
(
int64_t
avg_rtt_ms
int64_t
max_rtt_ms
)
=
0
;
virtual
~
CallStatsObserver
(
)
{
}
}
;
class
AudioFrame
{
public
:
enum
:
size_t
{
kMaxDataSizeSamples
=
3840
kMaxDataSizeBytes
=
kMaxDataSizeSamples
*
sizeof
(
int16_t
)
}
;
enum
VADActivity
{
kVadActive
=
0
kVadPassive
=
1
kVadUnknown
=
2
}
;
enum
SpeechType
{
kNormalSpeech
=
0
kPLC
=
1
kCNG
=
2
kPLCCNG
=
3
kUndefined
=
4
}
;
AudioFrame
(
)
;
void
Reset
(
)
;
void
ResetWithoutMuting
(
)
;
RTC_DEPRECATED
void
UpdateFrame
(
int
id
uint32_t
timestamp
const
int16_t
*
data
size_t
samples_per_channel
int
sample_rate_hz
SpeechType
speech_type
VADActivity
vad_activity
size_t
num_channels
=
1
)
{
RTC_UNUSED
(
id
)
;
UpdateFrame
(
timestamp
data
samples_per_channel
sample_rate_hz
speech_type
vad_activity
num_channels
)
;
}
void
UpdateFrame
(
uint32_t
timestamp
const
int16_t
*
data
size_t
samples_per_channel
int
sample_rate_hz
SpeechType
speech_type
VADActivity
vad_activity
size_t
num_channels
=
1
)
;
void
CopyFrom
(
const
AudioFrame
&
src
)
;
void
UpdateProfileTimeStamp
(
)
;
int64_t
ElapsedProfileTimeMs
(
)
const
;
const
int16_t
*
data
(
)
const
;
int16_t
*
mutable_data
(
)
;
void
Mute
(
)
;
bool
muted
(
)
const
;
RTC_DEPRECATED
AudioFrame
&
operator
>
>
=
(
const
int
rhs
)
;
RTC_DEPRECATED
AudioFrame
&
operator
+
=
(
const
AudioFrame
&
rhs
)
;
uint32_t
timestamp_
=
0
;
int64_t
elapsed_time_ms_
=
-
1
;
int64_t
ntp_time_ms_
=
-
1
;
size_t
samples_per_channel_
=
0
;
int
sample_rate_hz_
=
0
;
size_t
num_channels_
=
0
;
SpeechType
speech_type_
=
kUndefined
;
VADActivity
vad_activity_
=
kVadUnknown
;
int64_t
profile_timestamp_ms_
=
0
;
private
:
static
const
int16_t
*
empty_data
(
)
{
static
const
int16_t
kEmptyData
[
kMaxDataSizeSamples
]
=
{
0
}
;
static_assert
(
sizeof
(
kEmptyData
)
=
=
kMaxDataSizeBytes
"
kMaxDataSizeBytes
"
)
;
return
kEmptyData
;
}
int16_t
data_
[
kMaxDataSizeSamples
]
;
bool
muted_
=
true
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AudioFrame
)
;
}
;
inline
AudioFrame
:
:
AudioFrame
(
)
{
static_assert
(
sizeof
(
data_
)
=
=
kMaxDataSizeBytes
"
kMaxDataSizeBytes
"
)
;
}
inline
void
AudioFrame
:
:
Reset
(
)
{
ResetWithoutMuting
(
)
;
muted_
=
true
;
}
inline
void
AudioFrame
:
:
ResetWithoutMuting
(
)
{
timestamp_
=
0
;
elapsed_time_ms_
=
-
1
;
ntp_time_ms_
=
-
1
;
samples_per_channel_
=
0
;
sample_rate_hz_
=
0
;
num_channels_
=
0
;
speech_type_
=
kUndefined
;
vad_activity_
=
kVadUnknown
;
profile_timestamp_ms_
=
0
;
}
inline
void
AudioFrame
:
:
UpdateFrame
(
uint32_t
timestamp
const
int16_t
*
data
size_t
samples_per_channel
int
sample_rate_hz
SpeechType
speech_type
VADActivity
vad_activity
size_t
num_channels
)
{
timestamp_
=
timestamp
;
samples_per_channel_
=
samples_per_channel
;
sample_rate_hz_
=
sample_rate_hz
;
speech_type_
=
speech_type
;
vad_activity_
=
vad_activity
;
num_channels_
=
num_channels
;
const
size_t
length
=
samples_per_channel
*
num_channels
;
assert
(
length
<
=
kMaxDataSizeSamples
)
;
if
(
data
!
=
nullptr
)
{
memcpy
(
data_
data
sizeof
(
int16_t
)
*
length
)
;
muted_
=
false
;
}
else
{
muted_
=
true
;
}
}
inline
void
AudioFrame
:
:
CopyFrom
(
const
AudioFrame
&
src
)
{
if
(
this
=
=
&
src
)
return
;
timestamp_
=
src
.
timestamp_
;
elapsed_time_ms_
=
src
.
elapsed_time_ms_
;
ntp_time_ms_
=
src
.
ntp_time_ms_
;
muted_
=
src
.
muted
(
)
;
samples_per_channel_
=
src
.
samples_per_channel_
;
sample_rate_hz_
=
src
.
sample_rate_hz_
;
speech_type_
=
src
.
speech_type_
;
vad_activity_
=
src
.
vad_activity_
;
num_channels_
=
src
.
num_channels_
;
const
size_t
length
=
samples_per_channel_
*
num_channels_
;
assert
(
length
<
=
kMaxDataSizeSamples
)
;
if
(
!
src
.
muted
(
)
)
{
memcpy
(
data_
src
.
data
(
)
sizeof
(
int16_t
)
*
length
)
;
muted_
=
false
;
}
}
inline
void
AudioFrame
:
:
UpdateProfileTimeStamp
(
)
{
profile_timestamp_ms_
=
rtc
:
:
TimeMillis
(
)
;
}
inline
int64_t
AudioFrame
:
:
ElapsedProfileTimeMs
(
)
const
{
if
(
profile_timestamp_ms_
=
=
0
)
{
return
-
1
;
}
return
rtc
:
:
TimeSince
(
profile_timestamp_ms_
)
;
}
inline
const
int16_t
*
AudioFrame
:
:
data
(
)
const
{
return
muted_
?
empty_data
(
)
:
data_
;
}
inline
int16_t
*
AudioFrame
:
:
mutable_data
(
)
{
if
(
muted_
)
{
memset
(
data_
0
kMaxDataSizeBytes
)
;
muted_
=
false
;
}
return
data_
;
}
inline
void
AudioFrame
:
:
Mute
(
)
{
muted_
=
true
;
}
inline
bool
AudioFrame
:
:
muted
(
)
const
{
return
muted_
;
}
inline
AudioFrame
&
AudioFrame
:
:
operator
>
>
=
(
const
int
rhs
)
{
assert
(
(
num_channels_
>
0
)
&
&
(
num_channels_
<
3
)
)
;
if
(
(
num_channels_
>
2
)
|
|
(
num_channels_
<
1
)
)
return
*
this
;
if
(
muted_
)
return
*
this
;
for
(
size_t
i
=
0
;
i
<
samples_per_channel_
*
num_channels_
;
i
+
+
)
{
data_
[
i
]
=
static_cast
<
int16_t
>
(
data_
[
i
]
>
>
rhs
)
;
}
return
*
this
;
}
inline
AudioFrame
&
AudioFrame
:
:
operator
+
=
(
const
AudioFrame
&
rhs
)
{
assert
(
(
num_channels_
>
0
)
&
&
(
num_channels_
<
3
)
)
;
if
(
(
num_channels_
>
2
)
|
|
(
num_channels_
<
1
)
)
return
*
this
;
if
(
num_channels_
!
=
rhs
.
num_channels_
)
return
*
this
;
bool
noPrevData
=
muted_
;
if
(
samples_per_channel_
!
=
rhs
.
samples_per_channel_
)
{
if
(
samples_per_channel_
=
=
0
)
{
samples_per_channel_
=
rhs
.
samples_per_channel_
;
noPrevData
=
true
;
}
else
{
return
*
this
;
}
}
if
(
(
vad_activity_
=
=
kVadActive
)
|
|
rhs
.
vad_activity_
=
=
kVadActive
)
{
vad_activity_
=
kVadActive
;
}
else
if
(
vad_activity_
=
=
kVadUnknown
|
|
rhs
.
vad_activity_
=
=
kVadUnknown
)
{
vad_activity_
=
kVadUnknown
;
}
if
(
speech_type_
!
=
rhs
.
speech_type_
)
speech_type_
=
kUndefined
;
if
(
!
rhs
.
muted
(
)
)
{
muted_
=
false
;
if
(
noPrevData
)
{
memcpy
(
data_
rhs
.
data
(
)
sizeof
(
int16_t
)
*
rhs
.
samples_per_channel_
*
num_channels_
)
;
}
else
{
for
(
size_t
i
=
0
;
i
<
samples_per_channel_
*
num_channels_
;
i
+
+
)
{
int32_t
wrap_guard
=
static_cast
<
int32_t
>
(
data_
[
i
]
)
+
static_cast
<
int32_t
>
(
rhs
.
data_
[
i
]
)
;
data_
[
i
]
=
rtc
:
:
saturated_cast
<
int16_t
>
(
wrap_guard
)
;
}
}
}
return
*
this
;
}
struct
PacedPacketInfo
{
PacedPacketInfo
(
)
{
}
PacedPacketInfo
(
int
probe_cluster_id
int
probe_cluster_min_probes
int
probe_cluster_min_bytes
)
:
probe_cluster_id
(
probe_cluster_id
)
probe_cluster_min_probes
(
probe_cluster_min_probes
)
probe_cluster_min_bytes
(
probe_cluster_min_bytes
)
{
}
bool
operator
=
=
(
const
PacedPacketInfo
&
rhs
)
const
{
return
send_bitrate_bps
=
=
rhs
.
send_bitrate_bps
&
&
probe_cluster_id
=
=
rhs
.
probe_cluster_id
&
&
probe_cluster_min_probes
=
=
rhs
.
probe_cluster_min_probes
&
&
probe_cluster_min_bytes
=
=
rhs
.
probe_cluster_min_bytes
;
}
static
constexpr
int
kNotAProbe
=
-
1
;
int
send_bitrate_bps
=
-
1
;
int
probe_cluster_id
=
kNotAProbe
;
int
probe_cluster_min_probes
=
-
1
;
int
probe_cluster_min_bytes
=
-
1
;
}
;
inline
bool
IsNewerOrSameTimestamp
(
uint32_t
timestamp
uint32_t
prev_timestamp
)
{
return
timestamp
=
=
prev_timestamp
|
|
static_cast
<
uint32_t
>
(
timestamp
-
prev_timestamp
)
<
0x80000000
;
}
}
#
endif
