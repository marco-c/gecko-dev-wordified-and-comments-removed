#
include
"
webrtc
/
base
/
timeutils
.
h
"
#
include
"
webrtc
/
modules
/
audio_conference_mixer
/
source
/
time_scheduler
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
critical_section_wrapper
.
h
"
namespace
webrtc
{
TimeScheduler
:
:
TimeScheduler
(
const
int64_t
periodicityInMs
)
:
_crit
(
CriticalSectionWrapper
:
:
CreateCriticalSection
(
)
)
_isStarted
(
false
)
_lastPeriodMark
(
)
_periodicityInMs
(
periodicityInMs
)
_periodicityInTicks
(
periodicityInMs
*
rtc
:
:
kNumNanosecsPerMillisec
)
_missedPeriods
(
0
)
{
}
TimeScheduler
:
:
~
TimeScheduler
(
)
{
delete
_crit
;
}
int32_t
TimeScheduler
:
:
UpdateScheduler
(
)
{
CriticalSectionScoped
cs
(
_crit
)
;
if
(
!
_isStarted
)
{
_isStarted
=
true
;
_lastPeriodMark
=
rtc
:
:
TimeNanos
(
)
;
return
0
;
}
if
(
_missedPeriods
>
0
)
{
_missedPeriods
-
-
;
return
0
;
}
int64_t
tickNow
=
rtc
:
:
TimeNanos
(
)
;
int64_t
amassedTicks
=
tickNow
-
_lastPeriodMark
;
int64_t
amassedMs
=
amassedTicks
/
rtc
:
:
kNumNanosecsPerMillisec
;
int64_t
periodsToClaim
=
amassedMs
/
_periodicityInMs
;
if
(
periodsToClaim
<
1
)
{
periodsToClaim
=
1
;
}
for
(
int64_t
i
=
0
;
i
<
periodsToClaim
;
i
+
+
)
{
_lastPeriodMark
+
=
_periodicityInTicks
;
}
_missedPeriods
+
=
periodsToClaim
-
1
;
return
0
;
}
int32_t
TimeScheduler
:
:
TimeToNextUpdate
(
int64_t
&
updateTimeInMS
)
const
{
CriticalSectionScoped
cs
(
_crit
)
;
if
(
_missedPeriods
>
0
)
{
updateTimeInMS
=
0
;
return
0
;
}
int64_t
tickNow
=
rtc
:
:
TimeNanos
(
)
;
int64_t
ticksSinceLastUpdate
=
tickNow
-
_lastPeriodMark
;
const
int64_t
millisecondsSinceLastUpdate
=
ticksSinceLastUpdate
/
rtc
:
:
kNumNanosecsPerMillisec
;
updateTimeInMS
=
_periodicityInMs
-
millisecondsSinceLastUpdate
;
updateTimeInMS
=
(
updateTimeInMS
<
0
)
?
0
:
updateTimeInMS
;
return
0
;
}
}
