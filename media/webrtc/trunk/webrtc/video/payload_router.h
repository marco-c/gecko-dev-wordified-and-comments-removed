#
ifndef
WEBRTC_VIDEO_PAYLOAD_ROUTER_H_
#
define
WEBRTC_VIDEO_PAYLOAD_ROUTER_H_
#
include
<
list
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
thread_annotations
.
h
"
#
include
"
webrtc
/
common_types
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
atomic32
.
h
"
namespace
webrtc
{
class
CriticalSectionWrapper
;
class
RTPFragmentationHeader
;
class
RtpRtcp
;
struct
RTPVideoHeader
;
class
PayloadRouter
{
public
:
PayloadRouter
(
)
;
~
PayloadRouter
(
)
;
static
size_t
DefaultMaxPayloadLength
(
)
;
void
SetSendingRtpModules
(
const
std
:
:
list
<
RtpRtcp
*
>
&
rtp_modules
)
;
void
set_active
(
bool
active
)
;
bool
active
(
)
;
bool
RoutePayload
(
FrameType
frame_type
int8_t
payload_type
uint32_t
time_stamp
int64_t
capture_time_ms
const
uint8_t
*
payload_data
size_t
payload_size
const
RTPFragmentationHeader
*
fragmentation
const
RTPVideoHeader
*
rtp_video_hdr
)
;
void
SetTargetSendBitrates
(
const
std
:
:
vector
<
uint32_t
>
&
stream_bitrates
)
;
size_t
MaxPayloadLength
(
)
const
;
void
AddRef
(
)
{
+
+
ref_count_
;
}
void
Release
(
)
{
if
(
-
-
ref_count_
=
=
0
)
{
delete
this
;
}
}
private
:
rtc
:
:
scoped_ptr
<
CriticalSectionWrapper
>
crit_
;
std
:
:
vector
<
RtpRtcp
*
>
rtp_modules_
GUARDED_BY
(
crit_
.
get
(
)
)
;
bool
active_
GUARDED_BY
(
crit_
.
get
(
)
)
;
Atomic32
ref_count_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
PayloadRouter
)
;
}
;
}
#
endif
