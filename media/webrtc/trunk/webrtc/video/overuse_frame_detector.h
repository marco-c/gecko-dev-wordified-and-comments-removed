#
ifndef
WEBRTC_VIDEO_OVERUSE_FRAME_DETECTOR_H_
#
define
WEBRTC_VIDEO_OVERUSE_FRAME_DETECTOR_H_
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
#
include
"
webrtc
/
base
/
criticalsection
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
exp_filter
.
h
"
#
include
"
webrtc
/
base
/
thread_annotations
.
h
"
#
include
"
webrtc
/
base
/
thread_checker
.
h
"
#
include
"
webrtc
/
modules
/
include
/
module
.
h
"
namespace
webrtc
{
class
Clock
;
class
CpuOveruseObserver
{
public
:
virtual
void
OveruseDetected
(
)
=
0
;
virtual
void
NormalUsage
(
)
=
0
;
protected
:
virtual
~
CpuOveruseObserver
(
)
{
}
}
;
struct
CpuOveruseOptions
{
CpuOveruseOptions
(
)
:
low_encode_usage_threshold_percent
(
55
)
high_encode_usage_threshold_percent
(
85
)
frame_timeout_interval_ms
(
1500
)
min_frame_samples
(
120
)
min_process_count
(
3
)
high_threshold_consecutive_count
(
2
)
{
}
int
low_encode_usage_threshold_percent
;
int
high_encode_usage_threshold_percent
;
int
frame_timeout_interval_ms
;
int
min_frame_samples
;
int
min_process_count
;
int
high_threshold_consecutive_count
;
}
;
struct
CpuOveruseMetrics
{
CpuOveruseMetrics
(
)
:
encode_usage_percent
(
-
1
)
{
}
int
encode_usage_percent
;
}
;
class
CpuOveruseMetricsObserver
{
public
:
virtual
~
CpuOveruseMetricsObserver
(
)
{
}
virtual
void
CpuOveruseMetricsUpdated
(
const
CpuOveruseMetrics
&
metrics
)
=
0
;
}
;
class
OveruseFrameDetector
:
public
Module
{
public
:
OveruseFrameDetector
(
Clock
*
clock
const
CpuOveruseOptions
&
options
CpuOveruseObserver
*
overuse_observer
CpuOveruseMetricsObserver
*
metrics_observer
)
;
~
OveruseFrameDetector
(
)
;
void
FrameCaptured
(
int
width
int
height
int64_t
capture_time_ms
)
;
void
FrameSent
(
int64_t
capture_time_ms
)
;
int
LastProcessingTimeMs
(
)
const
;
int
FramesInQueue
(
)
const
;
int64_t
TimeUntilNextProcess
(
)
override
;
int32_t
Process
(
)
override
;
private
:
class
SendProcessingUsage
;
class
FrameQueue
;
void
UpdateCpuOveruseMetrics
(
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
void
AddProcessingTime
(
int
elapsed_ms
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
bool
IsOverusing
(
const
CpuOveruseMetrics
&
metrics
)
;
bool
IsUnderusing
(
const
CpuOveruseMetrics
&
metrics
int64_t
time_now
)
;
bool
FrameTimeoutDetected
(
int64_t
now
)
const
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
bool
FrameSizeChanged
(
int
num_pixels
)
const
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
void
ResetAll
(
int
num_pixels
)
EXCLUSIVE_LOCKS_REQUIRED
(
crit_
)
;
mutable
rtc
:
:
CriticalSection
crit_
;
const
CpuOveruseOptions
options_
;
CpuOveruseObserver
*
const
observer_
;
CpuOveruseMetricsObserver
*
const
metrics_observer_
;
CpuOveruseMetrics
metrics_
GUARDED_BY
(
crit_
)
;
Clock
*
const
clock_
;
int64_t
num_process_times_
GUARDED_BY
(
crit_
)
;
int64_t
last_capture_time_
GUARDED_BY
(
crit_
)
;
int
num_pixels_
GUARDED_BY
(
crit_
)
;
int64_t
next_process_time_
;
int64_t
last_overuse_time_
;
int
checks_above_threshold_
;
int
num_overuse_detections_
;
int64_t
last_rampup_time_
;
bool
in_quick_rampup_
;
int
current_rampup_delay_ms_
;
int64_t
last_sample_time_ms_
;
const
rtc
:
:
scoped_ptr
<
SendProcessingUsage
>
usage_
GUARDED_BY
(
crit_
)
;
const
rtc
:
:
scoped_ptr
<
FrameQueue
>
frame_queue_
GUARDED_BY
(
crit_
)
;
rtc
:
:
ThreadChecker
processing_thread_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
OveruseFrameDetector
)
;
}
;
}
#
endif
