#
ifndef
VIDEO_VIDEO_STREAM_ENCODER_H_
#
define
VIDEO_VIDEO_STREAM_ENCODER_H_
#
include
<
atomic
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
api
/
video
/
video_rotation
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder
.
h
"
#
include
"
call
/
call
.
h
"
#
include
"
common_types
.
h
"
#
include
"
common_video
/
include
/
video_bitrate_allocator
.
h
"
#
include
"
media
/
base
/
videosinkinterface
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_coding_defines
.
h
"
#
include
"
modules
/
video_coding
/
utility
/
quality_scaler
.
h
"
#
include
"
modules
/
video_coding
/
video_coding_impl
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
sequenced_task_checker
.
h
"
#
include
"
rtc_base
/
task_queue
.
h
"
#
include
"
typedefs
.
h
"
#
include
"
video
/
overuse_frame_detector
.
h
"
#
include
"
call
/
video_send_stream
.
h
"
namespace
webrtc
{
class
SendStatisticsProxy
;
class
VideoBitrateAllocationObserver
;
class
VideoStreamEncoder
:
public
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
public
EncodedImageCallback
public
AdaptationObserverInterface
{
public
:
class
EncoderSink
:
public
EncodedImageCallback
{
public
:
virtual
void
OnEncoderConfigurationChanged
(
std
:
:
vector
<
VideoStream
>
streams
int
min_transmit_bitrate_bps
)
=
0
;
}
;
struct
AdaptCounts
{
int
resolution
=
0
;
int
fps
=
0
;
}
;
static
const
int
kMaxCpuResolutionDowngrades
=
2
;
static
const
int
kMaxCpuFramerateDowngrades
=
4
;
VideoStreamEncoder
(
uint32_t
number_of_cores
SendStatisticsProxy
*
stats_proxy
const
VideoSendStream
:
:
Config
:
:
EncoderSettings
&
settings
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
pre_encode_callback
EncodedFrameObserver
*
encoder_timing
std
:
:
unique_ptr
<
OveruseFrameDetector
>
overuse_detector
)
;
~
VideoStreamEncoder
(
)
;
void
SetSource
(
rtc
:
:
VideoSourceInterface
<
VideoFrame
>
*
source
const
VideoSendStream
:
:
DegradationPreference
&
degradation_preference
)
;
void
SetSink
(
EncoderSink
*
sink
bool
rotation_applied
)
;
void
SetStartBitrate
(
int
start_bitrate_bps
)
;
void
SetBitrateObserver
(
VideoBitrateAllocationObserver
*
bitrate_observer
)
;
void
ConfigureEncoder
(
VideoEncoderConfig
config
size_t
max_data_payload_length
bool
nack_enabled
)
;
void
Stop
(
)
;
void
SendKeyFrame
(
)
;
virtual
void
OnReceivedIntraFrameRequest
(
size_t
stream_index
)
;
void
OnBitrateUpdated
(
uint32_t
bitrate_bps
uint8_t
fraction_lost
int64_t
round_trip_time_ms
)
;
protected
:
rtc
:
:
TaskQueue
*
encoder_queue
(
)
{
return
&
encoder_queue_
;
}
void
AdaptUp
(
AdaptReason
reason
)
override
;
void
AdaptDown
(
AdaptReason
reason
)
override
;
static
CpuOveruseOptions
GetCpuOveruseOptions
(
bool
full_overuse_time
)
;
private
:
class
ConfigureEncoderTask
;
class
EncodeTask
;
class
VideoSourceProxy
;
class
VideoFrameInfo
{
public
:
VideoFrameInfo
(
int
width
int
height
bool
is_texture
)
:
width
(
width
)
height
(
height
)
is_texture
(
is_texture
)
{
}
int
width
;
int
height
;
bool
is_texture
;
int
pixel_count
(
)
const
{
return
width
*
height
;
}
}
;
void
ConfigureEncoderOnTaskQueue
(
VideoEncoderConfig
config
size_t
max_data_payload_length
bool
nack_enabled
)
;
void
ReconfigureEncoder
(
)
;
void
ConfigureQualityScaler
(
)
;
void
OnFrame
(
const
VideoFrame
&
video_frame
)
override
;
void
OnDiscardedFrame
(
)
override
;
void
EncodeVideoFrame
(
const
VideoFrame
&
frame
int64_t
time_when_posted_in_ms
)
;
EncodedImageCallback
:
:
Result
OnEncodedImage
(
const
EncodedImage
&
encoded_image
const
CodecSpecificInfo
*
codec_specific_info
const
RTPFragmentationHeader
*
fragmentation
)
override
;
void
OnDroppedFrame
(
EncodedImageCallback
:
:
DropReason
reason
)
override
;
bool
EncoderPaused
(
)
const
;
void
TraceFrameDropStart
(
)
;
void
TraceFrameDropEnd
(
)
;
class
AdaptCounter
final
{
public
:
AdaptCounter
(
)
;
~
AdaptCounter
(
)
;
AdaptCounts
Counts
(
int
reason
)
const
;
std
:
:
string
ToString
(
)
const
;
void
IncrementFramerate
(
int
reason
)
;
void
IncrementResolution
(
int
reason
)
;
void
DecrementFramerate
(
int
reason
)
;
void
DecrementResolution
(
int
reason
)
;
void
DecrementFramerate
(
int
reason
int
cur_fps
)
;
int
FramerateCount
(
)
const
;
int
ResolutionCount
(
)
const
;
int
FramerateCount
(
int
reason
)
const
;
int
ResolutionCount
(
int
reason
)
const
;
int
TotalCount
(
int
reason
)
const
;
private
:
std
:
:
string
ToString
(
const
std
:
:
vector
<
int
>
&
counters
)
const
;
int
Count
(
const
std
:
:
vector
<
int
>
&
counters
)
const
;
void
MoveCount
(
std
:
:
vector
<
int
>
*
counters
int
from_reason
)
;
std
:
:
vector
<
int
>
fps_counters_
;
std
:
:
vector
<
int
>
resolution_counters_
;
}
;
AdaptCounter
&
GetAdaptCounter
(
)
RTC_RUN_ON
(
&
encoder_queue_
)
;
const
AdaptCounter
&
GetConstAdaptCounter
(
)
RTC_RUN_ON
(
&
encoder_queue_
)
;
void
UpdateAdaptationStats
(
AdaptReason
reason
)
RTC_RUN_ON
(
&
encoder_queue_
)
;
AdaptCounts
GetActiveCounts
(
AdaptReason
reason
)
RTC_RUN_ON
(
&
encoder_queue_
)
;
rtc
:
:
Event
shutdown_event_
;
const
uint32_t
number_of_cores_
;
int
initial_rampup_
;
const
std
:
:
unique_ptr
<
VideoSourceProxy
>
source_proxy_
;
EncoderSink
*
sink_
;
const
VideoSendStream
:
:
Config
:
:
EncoderSettings
settings_
;
const
VideoCodecType
codec_type_
;
vcm
:
:
VideoSender
video_sender_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
std
:
:
unique_ptr
<
OveruseFrameDetector
>
overuse_detector_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
std
:
:
unique_ptr
<
QualityScaler
>
quality_scaler_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
SendStatisticsProxy
*
const
stats_proxy_
;
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
const
pre_encode_callback_
;
rtc
:
:
ThreadChecker
thread_checker_
;
VideoEncoderConfig
encoder_config_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
std
:
:
unique_ptr
<
VideoBitrateAllocator
>
rate_allocator_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
int
max_framerate_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
bool
pending_encoder_reconfiguration_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
rtc
:
:
Optional
<
VideoFrameInfo
>
last_frame_info_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
int
crop_width_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
int
crop_height_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
uint32_t
encoder_start_bitrate_bps_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
size_t
max_data_payload_length_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
bool
nack_enabled_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
uint32_t
last_observed_bitrate_bps_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
bool
encoder_paused_and_dropped_frame_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
Clock
*
const
clock_
;
std
:
:
map
<
const
VideoSendStream
:
:
DegradationPreference
AdaptCounter
>
adapt_counters_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
VideoSendStream
:
:
DegradationPreference
degradation_preference_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
struct
AdaptationRequest
{
int
input_pixel_count_
;
int
framerate_fps_
;
enum
class
Mode
{
kAdaptUp
kAdaptDown
}
mode_
;
}
;
rtc
:
:
Optional
<
AdaptationRequest
>
last_adaptation_request_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
rtc
:
:
RaceChecker
incoming_frame_race_checker_
RTC_GUARDED_BY
(
incoming_frame_race_checker_
)
;
std
:
:
atomic
<
int
>
posted_frames_waiting_for_encode_
;
int64_t
last_captured_timestamp_
RTC_GUARDED_BY
(
incoming_frame_race_checker_
)
;
const
int64_t
delta_ntp_internal_ms_
RTC_GUARDED_BY
(
incoming_frame_race_checker_
)
;
int64_t
last_frame_log_ms_
RTC_GUARDED_BY
(
incoming_frame_race_checker_
)
;
int
captured_frame_count_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
int
dropped_frame_count_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
VideoBitrateAllocationObserver
*
bitrate_observer_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
rtc
:
:
Optional
<
int64_t
>
last_parameters_update_ms_
RTC_ACCESS_ON
(
&
encoder_queue_
)
;
rtc
:
:
TaskQueue
encoder_queue_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
VideoStreamEncoder
)
;
}
;
}
#
endif
