#
include
"
voice_engine
/
audio_level
.
h
"
#
include
"
common_audio
/
signal_processing
/
include
/
signal_processing_library
.
h
"
#
include
"
modules
/
include
/
module_common_types
.
h
"
namespace
webrtc
{
namespace
voe
{
constexpr
int8_t
kPermutation
[
33
]
=
{
0
1
2
3
4
4
5
5
5
5
6
6
6
6
6
7
7
7
7
8
8
8
9
9
9
9
9
9
9
9
9
9
9
}
;
AudioLevel
:
:
AudioLevel
(
)
:
abs_max_
(
0
)
count_
(
0
)
current_level_
(
0
)
current_level_full_range_
(
0
)
{
WebRtcSpl_Init
(
)
;
}
AudioLevel
:
:
~
AudioLevel
(
)
{
}
int8_t
AudioLevel
:
:
Level
(
)
const
{
rtc
:
:
CritScope
cs
(
&
crit_sect_
)
;
return
current_level_
;
}
int16_t
AudioLevel
:
:
LevelFullRange
(
)
const
{
rtc
:
:
CritScope
cs
(
&
crit_sect_
)
;
return
current_level_full_range_
;
}
void
AudioLevel
:
:
Clear
(
)
{
rtc
:
:
CritScope
cs
(
&
crit_sect_
)
;
abs_max_
=
0
;
count_
=
0
;
current_level_
=
0
;
current_level_full_range_
=
0
;
}
double
AudioLevel
:
:
TotalEnergy
(
)
const
{
rtc
:
:
CritScope
cs
(
&
crit_sect_
)
;
return
total_energy_
;
}
double
AudioLevel
:
:
TotalDuration
(
)
const
{
rtc
:
:
CritScope
cs
(
&
crit_sect_
)
;
return
total_duration_
;
}
void
AudioLevel
:
:
ComputeLevel
(
const
AudioFrame
&
audioFrame
double
duration
)
{
int16_t
abs_value
=
audioFrame
.
muted
(
)
?
0
:
WebRtcSpl_MaxAbsValueW16
(
audioFrame
.
data
(
)
audioFrame
.
samples_per_channel_
*
audioFrame
.
num_channels_
)
;
rtc
:
:
CritScope
cs
(
&
crit_sect_
)
;
if
(
abs_value
>
abs_max_
)
abs_max_
=
abs_value
;
if
(
count_
+
+
=
=
kUpdateFrequency
)
{
current_level_full_range_
=
abs_max_
;
count_
=
0
;
int32_t
position
=
abs_max_
/
1000
;
if
(
(
position
=
=
0
)
&
&
(
abs_max_
>
250
)
)
{
position
=
1
;
}
current_level_
=
kPermutation
[
position
]
;
abs_max_
>
>
=
2
;
}
double
additional_energy
=
static_cast
<
double
>
(
current_level_full_range_
)
/
INT16_MAX
;
additional_energy
*
=
additional_energy
;
total_energy_
+
=
additional_energy
*
duration
;
total_duration_
+
=
duration
;
}
}
}
