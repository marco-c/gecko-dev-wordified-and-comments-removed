#
ifndef
VOICE_ENGINE_CHANNEL_H_
#
define
VOICE_ENGINE_CHANNEL_H_
#
include
<
memory
>
#
include
"
api
/
audio
/
audio_mixer
.
h
"
#
include
"
api
/
audio_codecs
/
audio_encoder
.
h
"
#
include
"
api
/
call
/
audio_sink
.
h
"
#
include
"
api
/
call
/
transport
.
h
"
#
include
"
api
/
optional
.
h
"
#
include
"
common_audio
/
resampler
/
include
/
push_resampler
.
h
"
#
include
"
common_types
.
h
"
#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module
.
h
"
#
include
"
modules
/
audio_processing
/
rms_level
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
remote_ntp_time_estimator
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_header_parser
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_receiver
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
thread_checker
.
h
"
#
include
"
voice_engine
/
audio_level
.
h
"
#
include
"
voice_engine
/
include
/
voe_base
.
h
"
#
include
"
voice_engine
/
shared_data
.
h
"
namespace
rtc
{
class
TimestampWrapAroundHandler
;
}
namespace
webrtc
{
class
AudioDeviceModule
;
class
PacketRouter
;
class
ProcessThread
;
class
RateLimiter
;
class
ReceiveStatistics
;
class
RemoteNtpTimeEstimator
;
class
RtcEventLog
;
class
RtpPacketObserver
;
class
RTPPayloadRegistry
;
class
RTPReceiverAudio
;
class
RtpPacketReceived
;
class
RtpRtcp
;
class
RtpTransportControllerSendInterface
;
class
TelephoneEventHandler
;
struct
SenderInfo
;
struct
CallStatistics
{
unsigned
short
fractionLost
;
unsigned
int
cumulativeLost
;
unsigned
int
extendedMax
;
unsigned
int
jitterSamples
;
int64_t
rttMs
;
size_t
bytesSent
;
int
packetsSent
;
size_t
bytesReceived
;
int
packetsReceived
;
int64_t
capture_start_ntp_time_ms_
;
uint32_t
rtcp_sender_packets_sent
;
uint32_t
rtcp_sender_octets_sent
;
}
;
struct
ReportBlock
{
uint32_t
sender_SSRC
;
uint32_t
source_SSRC
;
uint8_t
fraction_lost
;
uint32_t
cumulative_num_packets_lost
;
uint32_t
extended_highest_sequence_number
;
uint32_t
interarrival_jitter
;
uint32_t
last_SR_timestamp
;
uint32_t
delay_since_last_SR
;
}
;
namespace
voe
{
class
RtcEventLogProxy
;
class
RtcpRttStatsProxy
;
class
RtpPacketSenderProxy
;
class
StatisticsProxy
;
class
TransportFeedbackProxy
;
class
TransportSequenceNumberProxy
;
class
VoERtcpObserver
;
class
ChannelState
{
public
:
struct
State
{
bool
playing
=
false
;
bool
sending
=
false
;
}
;
ChannelState
(
)
{
}
virtual
~
ChannelState
(
)
{
}
void
Reset
(
)
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
state_
=
State
(
)
;
}
State
Get
(
)
const
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
return
state_
;
}
void
SetPlaying
(
bool
enable
)
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
state_
.
playing
=
enable
;
}
void
SetSending
(
bool
enable
)
{
rtc
:
:
CritScope
lock
(
&
lock_
)
;
state_
.
sending
=
enable
;
}
private
:
rtc
:
:
CriticalSection
lock_
;
State
state_
;
}
;
class
Channel
:
public
RtpData
public
RtpFeedback
public
Transport
public
AudioPacketizationCallback
public
OverheadObserver
{
public
:
friend
class
VoERtcpObserver
;
enum
{
KNumSocketThreads
=
1
}
;
enum
{
KNumberOfSocketBuffers
=
8
}
;
virtual
~
Channel
(
)
;
static
int32_t
CreateChannel
(
Channel
*
&
channel
int32_t
channelId
uint32_t
instanceId
const
VoEBase
:
:
ChannelConfig
&
config
)
;
Channel
(
int32_t
channelId
uint32_t
instanceId
const
VoEBase
:
:
ChannelConfig
&
config
)
;
int32_t
Init
(
)
;
void
Terminate
(
)
;
int32_t
SetEngineInformation
(
ProcessThread
&
moduleProcessThread
AudioDeviceModule
&
audioDeviceModule
rtc
:
:
TaskQueue
*
encoder_queue
)
;
void
SetSink
(
std
:
:
unique_ptr
<
AudioSinkInterface
>
sink
)
;
const
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
&
GetAudioDecoderFactory
(
)
const
;
void
SetReceiveCodecs
(
const
std
:
:
map
<
int
SdpAudioFormat
>
&
codecs
)
;
bool
SetEncoder
(
int
payload_type
std
:
:
unique_ptr
<
AudioEncoder
>
encoder
)
;
void
ModifyEncoder
(
rtc
:
:
FunctionView
<
void
(
std
:
:
unique_ptr
<
AudioEncoder
>
*
)
>
modifier
)
;
int32_t
StartPlayout
(
)
;
int32_t
StopPlayout
(
)
;
int32_t
StartSend
(
)
;
void
StopSend
(
)
;
struct
EncoderProps
{
int
sample_rate_hz
;
size_t
num_channels
;
}
;
rtc
:
:
Optional
<
EncoderProps
>
GetEncoderProps
(
)
const
;
int32_t
GetRecCodec
(
CodecInst
&
codec
)
;
void
SetBitRate
(
int
bitrate_bps
int64_t
probing_interval_ms
)
;
bool
EnableAudioNetworkAdaptor
(
const
std
:
:
string
&
config_string
)
;
void
DisableAudioNetworkAdaptor
(
)
;
void
SetReceiverFrameLengthRange
(
int
min_frame_length_ms
int
max_frame_length_ms
)
;
void
RegisterTransport
(
Transport
*
transport
)
;
int32_t
ReceivedRTCPPacket
(
const
uint8_t
*
data
size_t
length
)
;
void
OnRtpPacket
(
const
RtpPacketReceived
&
packet
)
;
void
SetInputMute
(
bool
enable
)
;
void
SetChannelOutputVolumeScaling
(
float
scaling
)
;
int
GetSpeechOutputLevel
(
)
const
;
int
GetSpeechOutputLevelFullRange
(
)
const
;
double
GetTotalOutputEnergy
(
)
const
;
double
GetTotalOutputDuration
(
)
const
;
int
GetNetworkStatistics
(
NetworkStatistics
&
stats
)
;
void
GetDecodingCallStatistics
(
AudioDecodingCallStats
*
stats
)
const
;
ANAStats
GetANAStatistics
(
)
const
;
uint32_t
GetDelayEstimate
(
)
const
;
void
GetDelayEstimates
(
int
*
jitter_buffer_delay_ms
int
*
playout_buffer_delay_ms
int
*
avsync_offset_ms
)
const
;
int
SetMinimumPlayoutDelay
(
int
delayMs
)
;
void
SetCurrentSyncOffset
(
int
offsetMs
)
{
_current_sync_offset
=
offsetMs
;
}
int
GetPlayoutTimestamp
(
unsigned
int
&
timestamp
)
;
int
GetRtpRtcp
(
RtpRtcp
*
*
rtpRtcpModule
RtpReceiver
*
*
rtp_receiver
)
const
;
int
SendTelephoneEventOutband
(
int
event
int
duration_ms
)
;
int
SetSendTelephoneEventPayloadType
(
int
payload_type
int
payload_frequency
)
;
int
SetLocalMID
(
const
char
*
mid
)
;
int
SetLocalSSRC
(
unsigned
int
ssrc
)
;
int
SetSendAudioLevelIndicationStatus
(
bool
enable
unsigned
char
id
)
;
int
SetSendMIDStatus
(
bool
enable
unsigned
char
id
)
;
int
SetReceiveAudioLevelIndicationStatus
(
bool
enable
unsigned
char
id
bool
isLevelSsrc
)
;
int
SetReceiveCsrcAudioLevelIndicationStatus
(
bool
enable
unsigned
char
id
)
;
void
EnableSendTransportSequenceNumber
(
int
id
)
;
void
EnableReceiveTransportSequenceNumber
(
int
id
)
;
void
RegisterSenderCongestionControlObjects
(
RtpTransportControllerSendInterface
*
transport
RtcpBandwidthObserver
*
bandwidth_observer
)
;
void
RegisterReceiverCongestionControlObjects
(
PacketRouter
*
packet_router
)
;
void
ResetSenderCongestionControlObjects
(
)
;
void
ResetReceiverCongestionControlObjects
(
)
;
void
SetRTCPStatus
(
bool
enable
)
;
int
SetRTCP_CNAME
(
const
char
cName
[
256
]
)
;
int
GetRTCPPacketTypeCounters
(
RtcpPacketTypeCounter
&
stats
)
;
int
GetRemoteRTCPReportBlocks
(
std
:
:
vector
<
ReportBlock
>
*
report_blocks
)
;
int
GetRTPStatistics
(
CallStatistics
&
stats
)
;
void
SetNACKStatus
(
bool
enable
int
maxNumberOfPackets
)
;
int32_t
SendData
(
FrameType
frameType
uint8_t
payloadType
uint32_t
timeStamp
const
uint8_t
*
payloadData
size_t
payloadSize
const
RTPFragmentationHeader
*
fragmentation
)
override
;
int32_t
OnReceivedPayloadData
(
const
uint8_t
*
payloadData
size_t
payloadSize
const
WebRtcRTPHeader
*
rtpHeader
)
override
;
int32_t
OnInitializeDecoder
(
int
payload_type
const
SdpAudioFormat
&
audio_format
uint32_t
rate
)
override
;
void
OnIncomingSSRCChanged
(
uint32_t
ssrc
)
override
;
void
OnIncomingCSRCChanged
(
uint32_t
CSRC
bool
added
)
override
;
void
OnIncomingReceiverReports
(
const
ReportBlockList
&
aReportBlocks
const
int64_t
aRoundTripTime
const
int64_t
aReceptionTime
)
;
bool
SendRtp
(
const
uint8_t
*
data
size_t
len
const
PacketOptions
&
packet_options
)
override
;
bool
SendRtcp
(
const
uint8_t
*
data
size_t
len
)
override
;
AudioMixer
:
:
Source
:
:
AudioFrameInfo
GetAudioFrameWithInfo
(
int
sample_rate_hz
AudioFrame
*
audio_frame
)
;
int
PreferredSampleRate
(
)
const
;
uint32_t
InstanceId
(
)
const
{
return
_instanceId
;
}
int32_t
ChannelId
(
)
const
{
return
_channelId
;
}
bool
Playing
(
)
const
{
return
channel_state_
.
Get
(
)
.
playing
;
}
bool
Sending
(
)
const
{
return
channel_state_
.
Get
(
)
.
sending
;
}
RtpRtcp
*
RtpRtcpModulePtr
(
)
const
{
return
_rtpRtcpModule
.
get
(
)
;
}
int8_t
OutputEnergyLevel
(
)
const
{
return
_outputAudioLevel
.
Level
(
)
;
}
void
ProcessAndEncodeAudio
(
const
AudioFrame
&
audio_input
)
;
void
ProcessAndEncodeAudio
(
const
int16_t
*
audio_data
int
sample_rate
size_t
number_of_frames
size_t
number_of_channels
)
;
void
set_associate_send_channel
(
const
ChannelOwner
&
channel
)
;
void
DisassociateSendChannel
(
int
channel_id
)
;
void
SetRtcEventLog
(
RtcEventLog
*
event_log
)
;
void
SetRtcpRttStats
(
RtcpRttStats
*
rtcp_rtt_stats
)
;
void
SetTransportOverhead
(
size_t
transport_overhead_per_packet
)
;
void
OnOverheadChanged
(
size_t
overhead_bytes_per_packet
)
override
;
bool
GetRTCPReceiverStatistics
(
int64_t
*
timestamp
uint32_t
*
jitterMs
uint32_t
*
cumulativeLost
uint32_t
*
packetsReceived
uint64_t
*
bytesReceived
double
*
packetsFractionLost
int64_t
*
rtt
)
const
;
virtual
void
SetRtpPacketObserver
(
RtpPacketObserver
*
observer
)
;
void
OnTwccBasedUplinkPacketLossRate
(
float
packet_loss_rate
)
;
void
OnRecoverableUplinkPacketLossRate
(
float
recoverable_packet_loss_rate
)
;
std
:
:
vector
<
RtpSource
>
GetSources
(
)
const
{
return
rtp_receiver_
-
>
GetSources
(
)
;
}
int
GetPlayoutFrequency
(
)
const
{
if
(
audio_coding_
)
{
return
audio_coding_
-
>
PlayoutFrequency
(
)
;
}
return
0
;
}
private
:
class
ProcessAndEncodeAudioTask
;
void
OnUplinkPacketLossRate
(
float
packet_loss_rate
)
;
bool
InputMute
(
)
const
;
bool
OnRecoveredPacket
(
const
uint8_t
*
packet
size_t
packet_length
)
;
bool
ReceivePacket
(
const
uint8_t
*
packet
size_t
packet_length
const
RTPHeader
&
header
)
;
bool
IsPacketInOrder
(
const
RTPHeader
&
header
)
const
;
bool
IsPacketRetransmitted
(
const
RTPHeader
&
header
bool
in_order
)
const
;
int
ResendPackets
(
const
uint16_t
*
sequence_numbers
int
length
)
;
void
UpdatePlayoutTimestamp
(
bool
rtcp
)
;
void
RegisterReceiveCodecsToRTPModule
(
)
;
int
SetSendRtpHeaderExtension
(
bool
enable
RTPExtensionType
type
unsigned
char
id
)
;
void
UpdateOverheadForEncoder
(
)
RTC_EXCLUSIVE_LOCKS_REQUIRED
(
overhead_per_packet_lock_
)
;
int
GetRtpTimestampRateHz
(
)
const
;
int64_t
GetRTT
(
bool
allow_associate_channel
)
const
;
void
ProcessAndEncodeAudioOnTaskQueue
(
AudioFrame
*
audio_input
)
;
uint32_t
_instanceId
;
int32_t
_channelId
;
rtc
:
:
CriticalSection
_callbackCritSect
;
rtc
:
:
CriticalSection
volume_settings_critsect_
;
ChannelState
channel_state_
;
std
:
:
unique_ptr
<
voe
:
:
RtcEventLogProxy
>
event_log_proxy_
;
std
:
:
unique_ptr
<
voe
:
:
RtcpRttStatsProxy
>
rtcp_rtt_stats_proxy_
;
std
:
:
unique_ptr
<
RtpHeaderParser
>
rtp_header_parser_
;
std
:
:
unique_ptr
<
RTPPayloadRegistry
>
rtp_payload_registry_
;
std
:
:
unique_ptr
<
ReceiveStatistics
>
rtp_receive_statistics_
;
std
:
:
unique_ptr
<
StatisticsProxy
>
statistics_proxy_
;
std
:
:
unique_ptr
<
RtpReceiver
>
rtp_receiver_
;
TelephoneEventHandler
*
telephone_event_handler_
;
std
:
:
unique_ptr
<
RtpRtcp
>
_rtpRtcpModule
;
std
:
:
unique_ptr
<
AudioCodingModule
>
audio_coding_
;
std
:
:
unique_ptr
<
AudioSinkInterface
>
audio_sink_
;
AudioLevel
_outputAudioLevel
;
PushResampler
<
int16_t
>
input_resampler_
;
uint32_t
_timeStamp
RTC_ACCESS_ON
(
encoder_queue_
)
;
RemoteNtpTimeEstimator
ntp_estimator_
RTC_GUARDED_BY
(
ts_stats_lock_
)
;
rtc
:
:
Optional
<
uint32_t
>
jitter_buffer_playout_timestamp_
;
rtc
:
:
CriticalSection
video_sync_lock_
;
uint32_t
playout_timestamp_rtp_
RTC_GUARDED_BY
(
video_sync_lock_
)
;
uint32_t
playout_delay_ms_
RTC_GUARDED_BY
(
video_sync_lock_
)
;
int
_current_sync_offset
;
uint16_t
send_sequence_number_
;
rtc
:
:
CriticalSection
ts_stats_lock_
;
std
:
:
unique_ptr
<
rtc
:
:
TimestampWrapAroundHandler
>
rtp_ts_wraparound_handler_
;
int64_t
capture_start_rtp_time_stamp_
;
int64_t
capture_start_ntp_time_ms_
RTC_GUARDED_BY
(
ts_stats_lock_
)
;
ProcessThread
*
_moduleProcessThreadPtr
;
AudioDeviceModule
*
_audioDeviceModulePtr
;
Transport
*
_transportPtr
;
RmsLevel
rms_level_
RTC_ACCESS_ON
(
encoder_queue_
)
;
bool
input_mute_
RTC_GUARDED_BY
(
volume_settings_critsect_
)
;
bool
previous_frame_muted_
RTC_ACCESS_ON
(
encoder_queue_
)
;
float
_outputGain
RTC_GUARDED_BY
(
volume_settings_critsect_
)
;
bool
_includeAudioLevelIndication
;
size_t
transport_overhead_per_packet_
RTC_GUARDED_BY
(
overhead_per_packet_lock_
)
;
size_t
rtp_overhead_per_packet_
RTC_GUARDED_BY
(
overhead_per_packet_lock_
)
;
rtc
:
:
CriticalSection
overhead_per_packet_lock_
;
AudioFrame
:
:
SpeechType
_outputSpeechType
;
std
:
:
unique_ptr
<
VoERtcpObserver
>
rtcp_observer_
;
rtc
:
:
CriticalSection
assoc_send_channel_lock_
;
ChannelOwner
associate_send_channel_
RTC_GUARDED_BY
(
assoc_send_channel_lock_
)
;
bool
pacing_enabled_
;
PacketRouter
*
packet_router_
=
nullptr
;
std
:
:
unique_ptr
<
TransportFeedbackProxy
>
feedback_observer_proxy_
;
std
:
:
unique_ptr
<
TransportSequenceNumberProxy
>
seq_num_allocator_proxy_
;
std
:
:
unique_ptr
<
RtpPacketSenderProxy
>
rtp_packet_sender_proxy_
;
std
:
:
unique_ptr
<
RateLimiter
>
retransmission_rate_limiter_
;
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory_
;
RtpPacketObserver
*
rtp_source_observer_
=
nullptr
;
rtc
:
:
Optional
<
EncoderProps
>
cached_encoder_props_
;
rtc
:
:
ThreadChecker
construction_thread_
;
const
bool
use_twcc_plr_for_ana_
;
rtc
:
:
CriticalSection
encoder_queue_lock_
;
bool
encoder_queue_is_active_
RTC_GUARDED_BY
(
encoder_queue_lock_
)
=
false
;
rtc
:
:
TaskQueue
*
encoder_queue_
=
nullptr
;
}
;
}
}
#
endif
