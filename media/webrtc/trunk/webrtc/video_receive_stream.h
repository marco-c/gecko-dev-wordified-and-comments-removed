#
ifndef
WEBRTC_VIDEO_RECEIVE_STREAM_H_
#
define
WEBRTC_VIDEO_RECEIVE_STREAM_H_
#
include
<
limits
>
#
include
<
map
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
api
/
call
/
transport
.
h
"
#
include
"
webrtc
/
base
/
platform_file
.
h
"
#
include
"
webrtc
/
common_types
.
h
"
#
include
"
webrtc
/
common_video
/
include
/
frame_callback
.
h
"
#
include
"
webrtc
/
config
.
h
"
#
include
"
webrtc
/
media
/
base
/
videosinkinterface
.
h
"
#
include
"
webrtc
/
voice_engine
/
include
/
voe_base
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
namespace
webrtc
{
class
VideoDecoder
;
class
VideoReceiveStream
{
public
:
struct
Decoder
{
std
:
:
string
ToString
(
)
const
;
VideoDecoder
*
decoder
=
nullptr
;
int
payload_type
=
0
;
std
:
:
string
payload_name
;
std
:
:
map
<
std
:
:
string
std
:
:
string
>
codec_params
;
}
;
struct
Stats
{
std
:
:
string
ToString
(
int64_t
time_ms
)
const
;
int
network_frame_rate
=
0
;
int
decode_frame_rate
=
0
;
int
render_frame_rate
=
0
;
std
:
:
string
decoder_implementation_name
=
"
unknown
"
;
FrameCounts
frame_counts
;
int
decode_ms
=
0
;
int
max_decode_ms
=
0
;
int
current_delay_ms
=
0
;
int
target_delay_ms
=
0
;
int
jitter_buffer_ms
=
0
;
int
min_playout_delay_ms
=
0
;
int
render_delay_ms
=
10
;
uint32_t
frames_decoded
=
0
;
int
current_payload_type
=
-
1
;
int
total_bitrate_bps
=
0
;
int
discarded_packets
=
0
;
int
width
=
0
;
int
height
=
0
;
int
sync_offset_ms
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
;
uint32_t
ssrc
=
0
;
std
:
:
string
c_name
;
StreamDataCounters
rtp_stats
;
RtcpPacketTypeCounter
rtcp_packet_type_counts
;
RtcpStatistics
rtcp_stats
;
}
;
struct
Config
{
private
:
Config
(
const
Config
&
)
=
default
;
public
:
Config
(
)
=
delete
;
Config
(
Config
&
&
)
=
default
;
explicit
Config
(
Transport
*
rtcp_send_transport
)
:
rtcp_send_transport
(
rtcp_send_transport
)
{
}
Config
&
operator
=
(
Config
&
&
)
=
default
;
Config
&
operator
=
(
const
Config
&
)
=
delete
;
Config
Copy
(
)
const
{
return
Config
(
*
this
)
;
}
std
:
:
string
ToString
(
)
const
;
std
:
:
vector
<
Decoder
>
decoders
;
struct
Rtp
{
std
:
:
string
ToString
(
)
const
;
uint32_t
remote_ssrc
=
0
;
uint32_t
local_ssrc
=
0
;
RtcpMode
rtcp_mode
=
RtcpMode
:
:
kCompound
;
struct
RtcpXr
{
bool
receiver_reference_time_report
=
false
;
}
rtcp_xr
;
bool
remb
=
false
;
bool
tmmbr
=
false
;
bool
transport_cc
=
false
;
KeyFrameRequestMethod
keyframe_method
=
kKeyFrameReqPliRtcp
;
NackConfig
nack
;
UlpfecConfig
ulpfec
;
struct
Rtx
{
uint32_t
ssrc
=
0
;
int
payload_type
=
0
;
}
;
typedef
std
:
:
map
<
int
Rtx
>
RtxMap
;
RtxMap
rtx
;
std
:
:
vector
<
RtpExtension
>
extensions
;
}
rtp
;
Transport
*
rtcp_send_transport
=
nullptr
;
rtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
renderer
=
nullptr
;
int
render_delay_ms
=
10
;
bool
disable_prerenderer_smoothing
=
false
;
std
:
:
string
sync_group
;
EncodedFrameObserver
*
pre_decode_callback
=
nullptr
;
I420FrameCallback
*
pre_render_callback
=
nullptr
;
int
target_delay_ms
=
0
;
}
;
virtual
void
Start
(
)
=
0
;
virtual
void
Stop
(
)
=
0
;
virtual
Stats
GetStats
(
)
const
=
0
;
virtual
bool
GetRemoteRTCPSenderInfo
(
RTCPSenderInfo
*
sender_info
)
const
=
0
;
virtual
void
SetSyncChannel
(
VoiceEngine
*
voice_engine
int
audio_channel_id
)
=
0
;
virtual
void
EnableEncodedFrameRecording
(
rtc
:
:
PlatformFile
file
size_t
byte_limit
)
=
0
;
inline
void
DisableEncodedFrameRecording
(
)
{
EnableEncodedFrameRecording
(
rtc
:
:
kInvalidPlatformFileValue
0
)
;
}
protected
:
virtual
~
VideoReceiveStream
(
)
{
}
}
;
}
#
endif
