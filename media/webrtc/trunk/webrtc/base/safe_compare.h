#
ifndef
WEBRTC_BASE_SAFE_COMPARE_H_
#
define
WEBRTC_BASE_SAFE_COMPARE_H_
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
<
utility
>
namespace
rtc
{
namespace
safe_cmp
{
namespace
safe_cmp_impl
{
template
<
size_t
N
>
struct
LargerIntImpl
:
std
:
:
false_type
{
}
;
template
<
>
struct
LargerIntImpl
<
sizeof
(
int8_t
)
>
:
std
:
:
true_type
{
using
type
=
int16_t
;
}
;
template
<
>
struct
LargerIntImpl
<
sizeof
(
int16_t
)
>
:
std
:
:
true_type
{
using
type
=
int32_t
;
}
;
template
<
>
struct
LargerIntImpl
<
sizeof
(
int32_t
)
>
:
std
:
:
true_type
{
using
type
=
int64_t
;
}
;
template
<
typename
T1
typename
T2
>
struct
LargerInt
:
LargerIntImpl
<
sizeof
(
T1
)
<
sizeof
(
T2
)
|
|
sizeof
(
T1
)
<
sizeof
(
int
*
)
?
sizeof
(
T1
)
:
0
>
{
}
;
template
<
typename
T
>
inline
typename
std
:
:
make_unsigned
<
T
>
:
:
type
MakeUnsigned
(
T
a
)
{
return
static_cast
<
typename
std
:
:
make_unsigned
<
T
>
:
:
type
>
(
a
)
;
}
template
<
typename
Op
typename
T1
typename
T2
typename
std
:
:
enable_if
<
std
:
:
is_signed
<
T1
>
:
:
value
=
=
std
:
:
is_signed
<
T2
>
:
:
value
>
:
:
type
*
=
nullptr
>
inline
bool
Cmp
(
T1
a
T2
b
)
{
return
Op
:
:
Op
(
a
b
)
;
}
template
<
typename
Op
typename
T1
typename
T2
typename
std
:
:
enable_if
<
std
:
:
is_signed
<
T1
>
:
:
value
&
&
std
:
:
is_unsigned
<
T2
>
:
:
value
&
&
LargerInt
<
T2
T1
>
:
:
value
>
:
:
type
*
=
nullptr
>
inline
bool
Cmp
(
T1
a
T2
b
)
{
return
Op
:
:
Op
(
a
static_cast
<
typename
LargerInt
<
T2
T1
>
:
:
type
>
(
b
)
)
;
}
template
<
typename
Op
typename
T1
typename
T2
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T1
>
:
:
value
&
&
std
:
:
is_signed
<
T2
>
:
:
value
&
&
LargerInt
<
T1
T2
>
:
:
value
>
:
:
type
*
=
nullptr
>
inline
bool
Cmp
(
T1
a
T2
b
)
{
return
Op
:
:
Op
(
static_cast
<
typename
LargerInt
<
T1
T2
>
:
:
type
>
(
a
)
b
)
;
}
template
<
typename
Op
typename
T1
typename
T2
typename
std
:
:
enable_if
<
std
:
:
is_signed
<
T1
>
:
:
value
&
&
std
:
:
is_unsigned
<
T2
>
:
:
value
&
&
!
LargerInt
<
T2
T1
>
:
:
value
>
:
:
type
*
=
nullptr
>
inline
bool
Cmp
(
T1
a
T2
b
)
{
return
a
<
0
?
Op
:
:
Op
(
-
1
0
)
:
Op
:
:
Op
(
safe_cmp_impl
:
:
MakeUnsigned
(
a
)
b
)
;
}
template
<
typename
Op
typename
T1
typename
T2
typename
std
:
:
enable_if
<
std
:
:
is_unsigned
<
T1
>
:
:
value
&
&
std
:
:
is_signed
<
T2
>
:
:
value
&
&
!
LargerInt
<
T1
T2
>
:
:
value
>
:
:
type
*
=
nullptr
>
inline
bool
Cmp
(
T1
a
T2
b
)
{
return
b
<
0
?
Op
:
:
Op
(
0
-
1
)
:
Op
:
:
Op
(
a
safe_cmp_impl
:
:
MakeUnsigned
(
b
)
)
;
}
#
define
RTC_SAFECMP_MAKE_OP
(
name
op
)
\
struct
name
{
\
template
<
typename
T1
typename
T2
>
\
static
constexpr
bool
Op
(
T1
a
T2
b
)
{
\
return
a
op
b
;
\
}
\
}
;
RTC_SAFECMP_MAKE_OP
(
EqOp
=
=
)
RTC_SAFECMP_MAKE_OP
(
NeOp
!
=
)
RTC_SAFECMP_MAKE_OP
(
LtOp
<
)
RTC_SAFECMP_MAKE_OP
(
LeOp
<
=
)
RTC_SAFECMP_MAKE_OP
(
GtOp
>
)
RTC_SAFECMP_MAKE_OP
(
GeOp
>
=
)
#
undef
RTC_SAFECMP_MAKE_OP
template
<
typename
T
>
struct
IsIntEnum
{
private
:
template
<
typename
X
typename
std
:
:
enable_if
<
std
:
:
is_enum
<
X
>
:
:
value
&
&
std
:
:
is_integral
<
decltype
(
+
std
:
:
declval
<
X
>
(
)
)
>
:
:
value
>
:
:
type
*
=
nullptr
>
static
int
Test
(
int
)
;
template
<
typename
>
static
char
Test
(
.
.
.
)
;
public
:
static
constexpr
bool
value
=
std
:
:
is_same
<
decltype
(
Test
<
typename
std
:
:
remove_reference
<
T
>
:
:
type
>
(
0
)
)
int
>
:
:
value
;
}
;
template
<
typename
T
>
struct
IsIntlike
{
private
:
using
X
=
typename
std
:
:
remove_reference
<
T
>
:
:
type
;
public
:
static
constexpr
bool
value
=
std
:
:
is_integral
<
X
>
:
:
value
|
|
IsIntEnum
<
X
>
:
:
value
;
}
;
namespace
test_enum_intlike
{
enum
E1
{
e1
}
;
enum
{
e2
}
;
enum
class
E3
{
e3
}
;
struct
S
{
}
;
static_assert
(
IsIntEnum
<
E1
>
:
:
value
"
"
)
;
static_assert
(
IsIntEnum
<
decltype
(
e2
)
>
:
:
value
"
"
)
;
static_assert
(
!
IsIntEnum
<
E3
>
:
:
value
"
"
)
;
static_assert
(
!
IsIntEnum
<
int
>
:
:
value
"
"
)
;
static_assert
(
!
IsIntEnum
<
float
>
:
:
value
"
"
)
;
static_assert
(
!
IsIntEnum
<
S
>
:
:
value
"
"
)
;
static_assert
(
IsIntlike
<
E1
>
:
:
value
"
"
)
;
static_assert
(
IsIntlike
<
decltype
(
e2
)
>
:
:
value
"
"
)
;
static_assert
(
!
IsIntlike
<
E3
>
:
:
value
"
"
)
;
static_assert
(
IsIntlike
<
int
>
:
:
value
"
"
)
;
static_assert
(
!
IsIntlike
<
float
>
:
:
value
"
"
)
;
static_assert
(
!
IsIntlike
<
S
>
:
:
value
"
"
)
;
}
}
#
define
RTC_SAFECMP_MAKE_FUN
(
name
)
\
template
<
typename
T1
typename
T2
\
typename
std
:
:
enable_if
<
\
safe_cmp_impl
:
:
IsIntlike
<
T1
>
:
:
value
&
&
\
safe_cmp_impl
:
:
IsIntlike
<
T2
>
:
:
value
>
:
:
type
*
=
nullptr
>
\
inline
bool
name
(
T1
a
T2
b
)
{
\
/
*
Unary
plus
here
turns
enums
into
real
integral
types
.
*
/
\
return
safe_cmp_impl
:
:
Cmp
<
safe_cmp_impl
:
:
name
#
#
Op
>
(
+
a
+
b
)
;
\
}
\
template
<
typename
T1
typename
T2
\
typename
std
:
:
enable_if
<
\
!
safe_cmp_impl
:
:
IsIntlike
<
T1
>
:
:
value
|
|
\
!
safe_cmp_impl
:
:
IsIntlike
<
T2
>
:
:
value
>
:
:
type
*
=
nullptr
>
\
inline
bool
name
(
T1
&
&
a
T2
&
&
b
)
{
\
return
safe_cmp_impl
:
:
name
#
#
Op
:
:
Op
(
a
b
)
;
\
}
RTC_SAFECMP_MAKE_FUN
(
Eq
)
RTC_SAFECMP_MAKE_FUN
(
Ne
)
RTC_SAFECMP_MAKE_FUN
(
Lt
)
RTC_SAFECMP_MAKE_FUN
(
Le
)
RTC_SAFECMP_MAKE_FUN
(
Gt
)
RTC_SAFECMP_MAKE_FUN
(
Ge
)
#
undef
RTC_SAFECMP_MAKE_FUN
}
}
#
endif
