#
include
"
webrtc
/
base
/
thread_checker_impl
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
if
defined
(
WEBRTC_LINUX
)
#
include
<
sys
/
syscall
.
h
>
#
endif
#
if
defined
(
__NetBSD__
)
#
include
<
lwp
.
h
>
#
elif
defined
(
__FreeBSD__
)
#
include
<
sys
/
param
.
h
>
#
include
<
sys
/
thr
.
h
>
#
include
<
pthread_np
.
h
>
#
endif
namespace
rtc
{
PlatformThreadId
CurrentThreadId
(
)
{
PlatformThreadId
ret
;
#
if
defined
(
WEBRTC_WIN
)
ret
=
GetCurrentThreadId
(
)
;
#
elif
defined
(
WEBRTC_POSIX
)
#
if
defined
(
WEBRTC_MAC
)
|
|
defined
(
WEBRTC_IOS
)
ret
=
pthread_mach_thread_np
(
pthread_self
(
)
)
;
#
elif
defined
(
WEBRTC_LINUX
)
|
|
defined
(
WEBRTC_GONK
)
ret
=
syscall
(
__NR_gettid
)
;
#
elif
defined
(
WEBRTC_ANDROID
)
ret
=
gettid
(
)
;
#
elif
defined
(
__NetBSD__
)
return
_lwp_self
(
)
;
#
elif
defined
(
__DragonFly__
)
return
lwp_gettid
(
)
;
#
elif
defined
(
__OpenBSD__
)
return
reinterpret_cast
<
uintptr_t
>
(
pthread_self
(
)
)
;
#
elif
defined
(
__FreeBSD__
)
#
if
__FreeBSD_version
>
900030
return
pthread_getthreadid_np
(
)
;
#
else
long
lwpid
;
thr_self
(
&
lwpid
)
;
return
lwpid
;
#
endif
#
else
ret
=
reinterpret_cast
<
pid_t
>
(
pthread_self
(
)
)
;
#
endif
#
endif
DCHECK
(
ret
)
;
return
ret
;
}
PlatformThreadRef
CurrentThreadRef
(
)
{
#
if
defined
(
WEBRTC_WIN
)
return
GetCurrentThreadId
(
)
;
#
elif
defined
(
WEBRTC_POSIX
)
return
pthread_self
(
)
;
#
endif
}
bool
IsThreadRefEqual
(
const
PlatformThreadRef
&
a
const
PlatformThreadRef
&
b
)
{
#
if
defined
(
WEBRTC_WIN
)
return
a
=
=
b
;
#
elif
defined
(
WEBRTC_POSIX
)
return
pthread_equal
(
a
b
)
;
#
endif
}
ThreadCheckerImpl
:
:
ThreadCheckerImpl
(
)
:
valid_thread_
(
CurrentThreadRef
(
)
)
{
}
ThreadCheckerImpl
:
:
~
ThreadCheckerImpl
(
)
{
}
bool
ThreadCheckerImpl
:
:
CalledOnValidThread
(
)
const
{
const
PlatformThreadRef
current_thread
=
CurrentThreadRef
(
)
;
CritScope
scoped_lock
(
&
lock_
)
;
if
(
!
valid_thread_
)
valid_thread_
=
current_thread
;
return
IsThreadRefEqual
(
valid_thread_
current_thread
)
;
}
void
ThreadCheckerImpl
:
:
DetachFromThread
(
)
{
CritScope
scoped_lock
(
&
lock_
)
;
valid_thread_
=
0
;
}
}
