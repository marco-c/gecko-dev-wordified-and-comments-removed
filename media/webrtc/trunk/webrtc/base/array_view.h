#
ifndef
WEBRTC_BASE_ARRAY_VIEW_H_
#
define
WEBRTC_BASE_ARRAY_VIEW_H_
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
type_traits
.
h
"
namespace
rtc
{
template
<
typename
T
>
class
ArrayView
final
{
public
:
using
value_type
=
T
;
using
const_iterator
=
const
T
*
;
ArrayView
(
)
:
ArrayView
(
static_cast
<
T
*
>
(
nullptr
)
0
)
{
}
ArrayView
(
std
:
:
nullptr_t
)
:
ArrayView
(
)
{
}
template
<
typename
U
>
ArrayView
(
U
*
data
size_t
size
)
:
data_
(
size
=
=
0
?
nullptr
:
data
)
size_
(
size
)
{
CheckInvariant
(
)
;
}
template
<
typename
U
size_t
N
>
ArrayView
(
U
(
&
array
)
[
N
]
)
:
ArrayView
(
&
array
[
0
]
N
)
{
}
template
<
typename
U
typename
std
:
:
enable_if
<
HasDataAndSize
<
U
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
ArrayView
(
U
&
u
)
:
ArrayView
(
u
.
data
(
)
u
.
size
(
)
)
{
}
size_t
size
(
)
const
{
return
size_
;
}
bool
empty
(
)
const
{
return
size_
=
=
0
;
}
T
*
data
(
)
const
{
return
data_
;
}
T
&
operator
[
]
(
size_t
idx
)
const
{
RTC_DCHECK_LT
(
idx
size_
)
;
RTC_DCHECK
(
data_
)
;
return
data_
[
idx
]
;
}
T
*
begin
(
)
const
{
return
data_
;
}
T
*
end
(
)
const
{
return
data_
+
size_
;
}
const
T
*
cbegin
(
)
const
{
return
data_
;
}
const
T
*
cend
(
)
const
{
return
data_
+
size_
;
}
ArrayView
subview
(
size_t
offset
size_t
size
)
const
{
if
(
offset
>
=
size_
)
return
ArrayView
(
)
;
return
ArrayView
(
data_
+
offset
std
:
:
min
(
size
size_
-
offset
)
)
;
}
ArrayView
subview
(
size_t
offset
)
const
{
return
subview
(
offset
size_
)
;
}
friend
bool
operator
=
=
(
const
ArrayView
&
a
const
ArrayView
&
b
)
{
return
a
.
data_
=
=
b
.
data_
&
&
a
.
size_
=
=
b
.
size_
;
}
friend
bool
operator
!
=
(
const
ArrayView
&
a
const
ArrayView
&
b
)
{
return
!
(
a
=
=
b
)
;
}
private
:
void
CheckInvariant
(
)
const
{
RTC_DCHECK_EQ
(
!
data_
size_
=
=
0
)
;
}
T
*
data_
;
size_t
size_
;
}
;
template
<
typename
T
>
inline
ArrayView
<
T
>
MakeArrayView
(
T
*
data
size_t
size
)
{
return
ArrayView
<
T
>
(
data
size
)
;
}
}
#
endif
