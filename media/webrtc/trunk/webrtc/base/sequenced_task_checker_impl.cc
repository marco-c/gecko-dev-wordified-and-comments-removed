#
include
"
webrtc
/
base
/
sequenced_task_checker_impl
.
h
"
#
if
defined
(
WEBRTC_MAC
)
#
include
<
dispatch
/
dispatch
.
h
>
#
endif
#
include
"
webrtc
/
base
/
platform_thread
.
h
"
#
include
"
webrtc
/
base
/
sequenced_task_checker
.
h
"
#
include
"
webrtc
/
base
/
task_queue
.
h
"
namespace
rtc
{
SequencedTaskCheckerImpl
:
:
SequencedTaskCheckerImpl
(
)
:
attached_
(
true
)
valid_queue_
(
TaskQueue
:
:
Current
(
)
)
{
}
SequencedTaskCheckerImpl
:
:
~
SequencedTaskCheckerImpl
(
)
{
}
bool
SequencedTaskCheckerImpl
:
:
CalledSequentially
(
)
const
{
QueueId
current_queue
=
TaskQueue
:
:
Current
(
)
;
#
if
defined
(
WEBRTC_MAC
)
if
(
current_queue
=
=
nullptr
)
{
#
ifdef
DISPATCH_CURRENT_QUEUE_LABEL
current_queue
=
dispatch_queue_get_label
(
DISPATCH_CURRENT_QUEUE_LABEL
)
;
#
else
dispatch_queue_t
currentQueue
=
dispatch_get_current_queue
(
)
;
current_queue
=
dispatch_queue_get_label
(
currentQueue
)
;
#
endif
}
#
endif
CritScope
scoped_lock
(
&
lock_
)
;
if
(
!
attached_
)
{
valid_queue_
=
current_queue
;
attached_
=
true
;
}
if
(
!
valid_queue_
)
return
thread_checker_
.
CalledOnValidThread
(
)
;
return
valid_queue_
=
=
current_queue
;
}
void
SequencedTaskCheckerImpl
:
:
Detach
(
)
{
CritScope
scoped_lock
(
&
lock_
)
;
attached_
=
false
;
valid_queue_
=
nullptr
;
thread_checker_
.
DetachFromThread
(
)
;
}
namespace
internal
{
SequencedTaskCheckerScope
:
:
SequencedTaskCheckerScope
(
const
SequencedTaskChecker
*
checker
)
{
RTC_DCHECK
(
checker
-
>
CalledSequentially
(
)
)
;
}
SequencedTaskCheckerScope
:
:
~
SequencedTaskCheckerScope
(
)
{
}
}
}
