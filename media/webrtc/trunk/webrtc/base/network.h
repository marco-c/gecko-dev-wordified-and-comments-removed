#
ifndef
WEBRTC_BASE_NETWORK_H_
#
define
WEBRTC_BASE_NETWORK_H_
#
include
<
deque
>
#
include
<
map
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
basictypes
.
h
"
#
include
"
webrtc
/
base
/
ipaddress
.
h
"
#
include
"
webrtc
/
base
/
messagehandler
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
#
if
defined
(
WEBRTC_POSIX
)
struct
ifaddrs
;
#
endif
namespace
rtc
{
class
Network
;
class
Thread
;
enum
AdapterType
{
ADAPTER_TYPE_UNKNOWN
=
0
ADAPTER_TYPE_ETHERNET
=
1
<
<
0
ADAPTER_TYPE_WIFI
=
1
<
<
1
ADAPTER_TYPE_CELLULAR
=
1
<
<
2
ADAPTER_TYPE_VPN
=
1
<
<
3
ADAPTER_TYPE_LOOPBACK
=
1
<
<
4
}
;
const
int
kDefaultNetworkIgnoreMask
=
ADAPTER_TYPE_LOOPBACK
;
std
:
:
string
MakeNetworkKey
(
const
std
:
:
string
&
name
const
IPAddress
&
prefix
int
prefix_length
)
;
class
NetworkManager
{
public
:
typedef
std
:
:
vector
<
Network
*
>
NetworkList
;
NetworkManager
(
)
;
virtual
~
NetworkManager
(
)
;
sigslot
:
:
signal0
<
>
SignalNetworksChanged
;
sigslot
:
:
signal0
<
>
SignalError
;
virtual
void
StartUpdating
(
)
=
0
;
virtual
void
StopUpdating
(
)
=
0
;
virtual
void
GetNetworks
(
NetworkList
*
networks
)
const
=
0
;
virtual
void
GetAnyAddressNetworks
(
NetworkList
*
networks
)
{
}
virtual
void
DumpNetworks
(
bool
include_ignored
)
{
}
struct
Stats
{
int
ipv4_network_count
;
int
ipv6_network_count
;
Stats
(
)
{
ipv4_network_count
=
0
;
ipv6_network_count
=
0
;
}
}
;
}
;
class
NetworkManagerBase
:
public
NetworkManager
{
public
:
NetworkManagerBase
(
)
;
~
NetworkManagerBase
(
)
override
;
void
GetNetworks
(
std
:
:
vector
<
Network
*
>
*
networks
)
const
override
;
void
GetAnyAddressNetworks
(
NetworkList
*
networks
)
override
;
bool
ipv6_enabled
(
)
const
{
return
ipv6_enabled_
;
}
void
set_ipv6_enabled
(
bool
enabled
)
{
ipv6_enabled_
=
enabled
;
}
void
set_max_ipv6_networks
(
int
networks
)
{
max_ipv6_networks_
=
networks
;
}
int
max_ipv6_networks
(
)
{
return
max_ipv6_networks_
;
}
protected
:
typedef
std
:
:
map
<
std
:
:
string
Network
*
>
NetworkMap
;
void
MergeNetworkList
(
const
NetworkList
&
list
bool
*
changed
)
;
void
MergeNetworkList
(
const
NetworkList
&
list
bool
*
changed
NetworkManager
:
:
Stats
*
stats
)
;
private
:
friend
class
NetworkTest
;
void
DoUpdateNetworks
(
)
;
NetworkList
networks_
;
int
max_ipv6_networks_
;
NetworkMap
networks_map_
;
bool
ipv6_enabled_
;
rtc
:
:
scoped_ptr
<
rtc
:
:
Network
>
ipv4_any_address_network_
;
rtc
:
:
scoped_ptr
<
rtc
:
:
Network
>
ipv6_any_address_network_
;
}
;
class
BasicNetworkManager
:
public
NetworkManagerBase
public
MessageHandler
{
public
:
BasicNetworkManager
(
)
;
~
BasicNetworkManager
(
)
override
;
void
StartUpdating
(
)
override
;
void
StopUpdating
(
)
override
;
void
DumpNetworks
(
bool
include_ignored
)
override
;
void
OnMessage
(
Message
*
msg
)
override
;
bool
started
(
)
{
return
start_count_
>
0
;
}
void
set_network_ignore_list
(
const
std
:
:
vector
<
std
:
:
string
>
&
list
)
{
network_ignore_list_
=
list
;
}
void
set_network_ignore_mask
(
int
network_ignore_mask
)
{
network_ignore_mask_
=
network_ignore_mask
;
}
int
network_ignore_mask
(
)
const
{
return
network_ignore_mask_
;
}
#
if
defined
(
WEBRTC_LINUX
)
void
set_ignore_non_default_routes
(
bool
value
)
{
ignore_non_default_routes_
=
true
;
}
#
endif
protected
:
#
if
defined
(
WEBRTC_POSIX
)
void
ConvertIfAddrs
(
ifaddrs
*
interfaces
bool
include_ignored
NetworkList
*
networks
)
const
;
#
endif
bool
CreateNetworks
(
bool
include_ignored
NetworkList
*
networks
)
const
;
bool
IsIgnoredNetwork
(
const
Network
&
network
)
const
;
private
:
friend
class
NetworkTest
;
void
DoUpdateNetworks
(
)
;
Thread
*
thread_
;
bool
sent_first_update_
;
int
start_count_
;
std
:
:
vector
<
std
:
:
string
>
network_ignore_list_
;
int
network_ignore_mask_
;
bool
ignore_non_default_routes_
;
}
;
class
Network
{
public
:
Network
(
const
std
:
:
string
&
name
const
std
:
:
string
&
description
const
IPAddress
&
prefix
int
prefix_length
)
;
Network
(
const
std
:
:
string
&
name
const
std
:
:
string
&
description
const
IPAddress
&
prefix
int
prefix_length
AdapterType
type
)
;
~
Network
(
)
;
const
std
:
:
string
&
name
(
)
const
{
return
name_
;
}
const
std
:
:
string
&
description
(
)
const
{
return
description_
;
}
const
IPAddress
&
prefix
(
)
const
{
return
prefix_
;
}
int
prefix_length
(
)
const
{
return
prefix_length_
;
}
std
:
:
string
key
(
)
const
{
return
key_
;
}
IPAddress
GetBestIP
(
)
const
;
IPAddress
ip
(
)
const
{
return
GetBestIP
(
)
;
}
void
AddIP
(
const
InterfaceAddress
&
ip
)
{
ips_
.
push_back
(
ip
)
;
}
bool
SetIPs
(
const
std
:
:
vector
<
InterfaceAddress
>
&
ips
bool
already_changed
)
;
const
std
:
:
vector
<
InterfaceAddress
>
&
GetIPs
(
)
const
{
return
ips_
;
}
void
ClearIPs
(
)
{
ips_
.
clear
(
)
;
}
int
scope_id
(
)
const
{
return
scope_id_
;
}
void
set_scope_id
(
int
id
)
{
scope_id_
=
id
;
}
bool
ignored
(
)
const
{
return
ignored_
;
}
void
set_ignored
(
bool
ignored
)
{
ignored_
=
ignored
;
}
AdapterType
type
(
)
const
{
return
type_
;
}
int
preference
(
)
const
{
return
preference_
;
}
void
set_preference
(
int
preference
)
{
preference_
=
preference
;
}
std
:
:
string
ToString
(
)
const
;
private
:
std
:
:
string
name_
;
std
:
:
string
description_
;
IPAddress
prefix_
;
int
prefix_length_
;
std
:
:
string
key_
;
std
:
:
vector
<
InterfaceAddress
>
ips_
;
int
scope_id_
;
bool
ignored_
;
AdapterType
type_
;
int
preference_
;
friend
class
NetworkManager
;
}
;
}
#
endif
