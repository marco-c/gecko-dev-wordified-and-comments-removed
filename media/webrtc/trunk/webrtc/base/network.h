#
ifndef
WEBRTC_BASE_NETWORK_H_
#
define
WEBRTC_BASE_NETWORK_H_
#
include
<
stdint
.
h
>
#
include
<
deque
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
ipaddress
.
h
"
#
include
"
webrtc
/
base
/
networkmonitor
.
h
"
#
include
"
webrtc
/
base
/
messagehandler
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
#
if
defined
(
WEBRTC_POSIX
)
struct
ifaddrs
;
#
endif
namespace
rtc
{
extern
const
char
kPublicIPv4Host
[
]
;
extern
const
char
kPublicIPv6Host
[
]
;
class
IfAddrsConverter
;
class
Network
;
class
NetworkMonitorInterface
;
class
Thread
;
static
const
uint16_t
kNetworkCostMax
=
999
;
static
const
uint16_t
kNetworkCostHigh
=
900
;
static
const
uint16_t
kNetworkCostUnknown
=
50
;
static
const
uint16_t
kNetworkCostLow
=
10
;
static
const
uint16_t
kNetworkCostMin
=
0
;
const
int
kDefaultNetworkIgnoreMask
=
ADAPTER_TYPE_LOOPBACK
;
std
:
:
string
MakeNetworkKey
(
const
std
:
:
string
&
name
const
IPAddress
&
prefix
int
prefix_length
)
;
class
DefaultLocalAddressProvider
{
public
:
virtual
~
DefaultLocalAddressProvider
(
)
=
default
;
virtual
bool
GetDefaultLocalAddress
(
int
family
IPAddress
*
ipaddr
)
const
=
0
;
}
;
class
NetworkManager
:
public
DefaultLocalAddressProvider
{
public
:
typedef
std
:
:
vector
<
Network
*
>
NetworkList
;
enum
EnumerationPermission
{
ENUMERATION_ALLOWED
ENUMERATION_BLOCKED
}
;
NetworkManager
(
)
;
~
NetworkManager
(
)
override
;
sigslot
:
:
signal0
<
>
SignalNetworksChanged
;
sigslot
:
:
signal0
<
>
SignalError
;
virtual
void
Initialize
(
)
{
}
virtual
void
StartUpdating
(
)
=
0
;
virtual
void
StopUpdating
(
)
=
0
;
virtual
void
GetNetworks
(
NetworkList
*
networks
)
const
=
0
;
virtual
EnumerationPermission
enumeration_permission
(
)
const
;
virtual
void
GetAnyAddressNetworks
(
NetworkList
*
networks
)
{
}
virtual
void
DumpNetworks
(
)
{
}
bool
GetDefaultLocalAddress
(
int
family
IPAddress
*
ipaddr
)
const
override
;
struct
Stats
{
int
ipv4_network_count
;
int
ipv6_network_count
;
Stats
(
)
{
ipv4_network_count
=
0
;
ipv6_network_count
=
0
;
}
}
;
}
;
class
NetworkManagerBase
:
public
NetworkManager
{
public
:
NetworkManagerBase
(
)
;
~
NetworkManagerBase
(
)
override
;
void
GetNetworks
(
NetworkList
*
networks
)
const
override
;
void
GetAnyAddressNetworks
(
NetworkList
*
networks
)
override
;
bool
ipv6_enabled
(
)
const
{
return
ipv6_enabled_
;
}
void
set_ipv6_enabled
(
bool
enabled
)
{
ipv6_enabled_
=
enabled
;
}
void
set_max_ipv6_networks
(
int
networks
)
{
max_ipv6_networks_
=
networks
;
}
int
max_ipv6_networks
(
)
{
return
max_ipv6_networks_
;
}
EnumerationPermission
enumeration_permission
(
)
const
override
;
bool
GetDefaultLocalAddress
(
int
family
IPAddress
*
ipaddr
)
const
override
;
protected
:
typedef
std
:
:
map
<
std
:
:
string
Network
*
>
NetworkMap
;
void
MergeNetworkList
(
const
NetworkList
&
list
bool
*
changed
)
;
void
MergeNetworkList
(
const
NetworkList
&
list
bool
*
changed
NetworkManager
:
:
Stats
*
stats
)
;
void
set_enumeration_permission
(
EnumerationPermission
state
)
{
enumeration_permission_
=
state
;
}
void
set_default_local_addresses
(
const
IPAddress
&
ipv4
const
IPAddress
&
ipv6
)
;
private
:
friend
class
NetworkTest
;
Network
*
GetNetworkFromAddress
(
const
rtc
:
:
IPAddress
&
ip
)
const
;
EnumerationPermission
enumeration_permission_
;
NetworkList
networks_
;
int
max_ipv6_networks_
;
NetworkMap
networks_map_
;
bool
ipv6_enabled_
;
std
:
:
unique_ptr
<
rtc
:
:
Network
>
ipv4_any_address_network_
;
std
:
:
unique_ptr
<
rtc
:
:
Network
>
ipv6_any_address_network_
;
IPAddress
default_local_ipv4_address_
;
IPAddress
default_local_ipv6_address_
;
uint16_t
next_available_network_id_
=
1
;
}
;
class
BasicNetworkManager
:
public
NetworkManagerBase
public
MessageHandler
public
sigslot
:
:
has_slots
<
>
{
public
:
BasicNetworkManager
(
)
;
~
BasicNetworkManager
(
)
override
;
void
StartUpdating
(
)
override
;
void
StopUpdating
(
)
override
;
void
DumpNetworks
(
)
override
;
void
OnMessage
(
Message
*
msg
)
override
;
bool
started
(
)
{
return
start_count_
>
0
;
}
void
set_network_ignore_list
(
const
std
:
:
vector
<
std
:
:
string
>
&
list
)
{
network_ignore_list_
=
list
;
}
#
if
defined
(
WEBRTC_LINUX
)
void
set_ignore_non_default_routes
(
bool
value
)
{
ignore_non_default_routes_
=
true
;
}
#
endif
protected
:
#
if
defined
(
WEBRTC_POSIX
)
void
ConvertIfAddrs
(
ifaddrs
*
interfaces
IfAddrsConverter
*
converter
bool
include_ignored
NetworkList
*
networks
)
const
;
#
endif
bool
CreateNetworks
(
bool
include_ignored
NetworkList
*
networks
)
const
;
bool
IsIgnoredNetwork
(
const
Network
&
network
)
const
;
IPAddress
QueryDefaultLocalAddress
(
int
family
)
const
;
private
:
friend
class
NetworkTest
;
void
StartNetworkMonitor
(
)
;
void
StopNetworkMonitor
(
)
;
void
OnNetworksChanged
(
)
;
void
UpdateNetworksContinually
(
)
;
void
UpdateNetworksOnce
(
)
;
AdapterType
GetAdapterTypeFromName
(
const
char
*
network_name
)
const
;
Thread
*
thread_
;
bool
sent_first_update_
;
int
start_count_
;
std
:
:
vector
<
std
:
:
string
>
network_ignore_list_
;
bool
ignore_non_default_routes_
;
std
:
:
unique_ptr
<
NetworkMonitorInterface
>
network_monitor_
;
}
;
class
Network
{
public
:
Network
(
const
std
:
:
string
&
name
const
std
:
:
string
&
description
const
IPAddress
&
prefix
int
prefix_length
)
;
Network
(
const
std
:
:
string
&
name
const
std
:
:
string
&
description
const
IPAddress
&
prefix
int
prefix_length
AdapterType
type
)
;
~
Network
(
)
;
sigslot
:
:
signal1
<
const
Network
*
>
SignalTypeChanged
;
const
DefaultLocalAddressProvider
*
default_local_address_provider
(
)
{
return
default_local_address_provider_
;
}
void
set_default_local_address_provider
(
const
DefaultLocalAddressProvider
*
provider
)
{
default_local_address_provider_
=
provider
;
}
const
std
:
:
string
&
name
(
)
const
{
return
name_
;
}
const
std
:
:
string
&
description
(
)
const
{
return
description_
;
}
const
IPAddress
&
prefix
(
)
const
{
return
prefix_
;
}
int
prefix_length
(
)
const
{
return
prefix_length_
;
}
std
:
:
string
key
(
)
const
{
return
key_
;
}
IPAddress
GetBestIP
(
)
const
;
IPAddress
ip
(
)
const
{
return
GetBestIP
(
)
;
}
void
AddIP
(
const
InterfaceAddress
&
ip
)
{
ips_
.
push_back
(
ip
)
;
}
bool
SetIPs
(
const
std
:
:
vector
<
InterfaceAddress
>
&
ips
bool
already_changed
)
;
const
std
:
:
vector
<
InterfaceAddress
>
&
GetIPs
(
)
const
{
return
ips_
;
}
void
ClearIPs
(
)
{
ips_
.
clear
(
)
;
}
int
scope_id
(
)
const
{
return
scope_id_
;
}
void
set_scope_id
(
int
id
)
{
scope_id_
=
id
;
}
bool
ignored
(
)
const
{
return
ignored_
;
}
void
set_ignored
(
bool
ignored
)
{
ignored_
=
ignored
;
}
AdapterType
type
(
)
const
{
return
type_
;
}
void
set_type
(
AdapterType
type
)
{
if
(
type_
=
=
type
)
{
return
;
}
type_
=
type
;
SignalTypeChanged
(
this
)
;
}
uint16_t
GetCost
(
)
const
{
switch
(
type_
)
{
case
rtc
:
:
ADAPTER_TYPE_ETHERNET
:
case
rtc
:
:
ADAPTER_TYPE_LOOPBACK
:
return
kNetworkCostMin
;
case
rtc
:
:
ADAPTER_TYPE_WIFI
:
case
rtc
:
:
ADAPTER_TYPE_VPN
:
return
kNetworkCostLow
;
case
rtc
:
:
ADAPTER_TYPE_CELLULAR
:
return
kNetworkCostHigh
;
default
:
return
kNetworkCostUnknown
;
}
}
uint16_t
id
(
)
const
{
return
id_
;
}
void
set_id
(
uint16_t
id
)
{
id_
=
id
;
}
int
preference
(
)
const
{
return
preference_
;
}
void
set_preference
(
int
preference
)
{
preference_
=
preference
;
}
bool
active
(
)
const
{
return
active_
;
}
void
set_active
(
bool
active
)
{
if
(
active_
!
=
active
)
{
active_
=
active
;
}
}
std
:
:
string
ToString
(
)
const
;
private
:
const
DefaultLocalAddressProvider
*
default_local_address_provider_
=
nullptr
;
std
:
:
string
name_
;
std
:
:
string
description_
;
IPAddress
prefix_
;
int
prefix_length_
;
std
:
:
string
key_
;
std
:
:
vector
<
InterfaceAddress
>
ips_
;
int
scope_id_
;
bool
ignored_
;
AdapterType
type_
;
int
preference_
;
bool
active_
=
true
;
uint16_t
id_
=
0
;
friend
class
NetworkManager
;
}
;
}
#
endif
