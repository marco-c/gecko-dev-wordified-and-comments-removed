#
ifndef
WEBRTC_BASE_COPYONWRITEBUFFER_H_
#
define
WEBRTC_BASE_COPYONWRITEBUFFER_H_
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
webrtc
/
base
/
buffer
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
refcount
.
h
"
#
include
"
webrtc
/
base
/
scoped_ref_ptr
.
h
"
namespace
rtc
{
class
CopyOnWriteBuffer
{
public
:
CopyOnWriteBuffer
(
)
;
CopyOnWriteBuffer
(
const
CopyOnWriteBuffer
&
buf
)
;
CopyOnWriteBuffer
(
CopyOnWriteBuffer
&
&
buf
)
;
explicit
CopyOnWriteBuffer
(
size_t
size
)
;
CopyOnWriteBuffer
(
size_t
size
size_t
capacity
)
;
template
<
typename
T
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
CopyOnWriteBuffer
(
const
T
*
data
size_t
size
)
:
CopyOnWriteBuffer
(
data
size
size
)
{
}
template
<
typename
T
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
CopyOnWriteBuffer
(
const
T
*
data
size_t
size
size_t
capacity
)
:
CopyOnWriteBuffer
(
size
capacity
)
{
if
(
buffer_
)
{
std
:
:
memcpy
(
buffer_
-
>
data
(
)
data
size
)
;
}
}
template
<
typename
T
size_t
N
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
CopyOnWriteBuffer
(
const
T
(
&
array
)
[
N
]
)
:
CopyOnWriteBuffer
(
array
N
)
{
}
~
CopyOnWriteBuffer
(
)
;
template
<
typename
T
=
uint8_t
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
const
T
*
data
(
)
const
{
return
cdata
<
T
>
(
)
;
}
template
<
typename
T
=
uint8_t
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
T
*
data
(
)
{
RTC_DCHECK
(
IsConsistent
(
)
)
;
if
(
!
buffer_
)
{
return
nullptr
;
}
CloneDataIfReferenced
(
buffer_
-
>
capacity
(
)
)
;
return
buffer_
-
>
data
<
T
>
(
)
;
}
template
<
typename
T
=
uint8_t
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
const
T
*
cdata
(
)
const
{
RTC_DCHECK
(
IsConsistent
(
)
)
;
if
(
!
buffer_
)
{
return
nullptr
;
}
return
buffer_
-
>
data
<
T
>
(
)
;
}
size_t
size
(
)
const
{
RTC_DCHECK
(
IsConsistent
(
)
)
;
return
buffer_
?
buffer_
-
>
size
(
)
:
0
;
}
size_t
capacity
(
)
const
{
RTC_DCHECK
(
IsConsistent
(
)
)
;
return
buffer_
?
buffer_
-
>
capacity
(
)
:
0
;
}
CopyOnWriteBuffer
&
operator
=
(
const
CopyOnWriteBuffer
&
buf
)
{
RTC_DCHECK
(
IsConsistent
(
)
)
;
RTC_DCHECK
(
buf
.
IsConsistent
(
)
)
;
if
(
&
buf
!
=
this
)
{
buffer_
=
buf
.
buffer_
;
}
return
*
this
;
}
CopyOnWriteBuffer
&
operator
=
(
CopyOnWriteBuffer
&
&
buf
)
{
RTC_DCHECK
(
IsConsistent
(
)
)
;
RTC_DCHECK
(
buf
.
IsConsistent
(
)
)
;
buffer_
=
std
:
:
move
(
buf
.
buffer_
)
;
return
*
this
;
}
bool
operator
=
=
(
const
CopyOnWriteBuffer
&
buf
)
const
;
bool
operator
!
=
(
const
CopyOnWriteBuffer
&
buf
)
const
{
return
!
(
*
this
=
=
buf
)
;
}
uint8_t
&
operator
[
]
(
size_t
index
)
{
RTC_DCHECK_LT
(
index
size
(
)
)
;
return
data
(
)
[
index
]
;
}
uint8_t
operator
[
]
(
size_t
index
)
const
{
RTC_DCHECK_LT
(
index
size
(
)
)
;
return
cdata
(
)
[
index
]
;
}
template
<
typename
T
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
void
SetData
(
const
T
*
data
size_t
size
)
{
RTC_DCHECK
(
IsConsistent
(
)
)
;
if
(
!
buffer_
)
{
buffer_
=
size
>
0
?
new
RefCountedObject
<
Buffer
>
(
data
size
)
:
nullptr
;
}
else
if
(
!
buffer_
-
>
HasOneRef
(
)
)
{
buffer_
=
new
RefCountedObject
<
Buffer
>
(
data
size
buffer_
-
>
capacity
(
)
)
;
}
else
{
buffer_
-
>
SetData
(
data
size
)
;
}
RTC_DCHECK
(
IsConsistent
(
)
)
;
}
template
<
typename
T
size_t
N
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
void
SetData
(
const
T
(
&
array
)
[
N
]
)
{
SetData
(
array
N
)
;
}
void
SetData
(
const
CopyOnWriteBuffer
&
buf
)
{
RTC_DCHECK
(
IsConsistent
(
)
)
;
RTC_DCHECK
(
buf
.
IsConsistent
(
)
)
;
if
(
&
buf
!
=
this
)
{
buffer_
=
buf
.
buffer_
;
}
}
template
<
typename
T
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
void
AppendData
(
const
T
*
data
size_t
size
)
{
RTC_DCHECK
(
IsConsistent
(
)
)
;
if
(
!
buffer_
)
{
buffer_
=
new
RefCountedObject
<
Buffer
>
(
data
size
)
;
RTC_DCHECK
(
IsConsistent
(
)
)
;
return
;
}
CloneDataIfReferenced
(
std
:
:
max
(
buffer_
-
>
capacity
(
)
buffer_
-
>
size
(
)
+
size
)
)
;
buffer_
-
>
AppendData
(
data
size
)
;
RTC_DCHECK
(
IsConsistent
(
)
)
;
}
template
<
typename
T
size_t
N
typename
std
:
:
enable_if
<
internal
:
:
BufferCompat
<
uint8_t
T
>
:
:
value
>
:
:
type
*
=
nullptr
>
void
AppendData
(
const
T
(
&
array
)
[
N
]
)
{
AppendData
(
array
N
)
;
}
void
AppendData
(
const
CopyOnWriteBuffer
&
buf
)
{
AppendData
(
buf
.
data
(
)
buf
.
size
(
)
)
;
}
void
SetSize
(
size_t
size
)
;
void
EnsureCapacity
(
size_t
capacity
)
;
void
Clear
(
)
;
friend
void
swap
(
CopyOnWriteBuffer
&
a
CopyOnWriteBuffer
&
b
)
{
std
:
:
swap
(
a
.
buffer_
b
.
buffer_
)
;
}
private
:
void
CloneDataIfReferenced
(
size_t
new_capacity
)
;
bool
IsConsistent
(
)
const
{
return
(
!
buffer_
|
|
buffer_
-
>
capacity
(
)
>
0
)
;
}
scoped_refptr
<
RefCountedObject
<
Buffer
>
>
buffer_
;
}
;
}
#
endif
