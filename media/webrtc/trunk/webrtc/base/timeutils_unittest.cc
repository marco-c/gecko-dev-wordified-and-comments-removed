#
include
"
webrtc
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
gunit
.
h
"
#
include
"
webrtc
/
base
/
helpers
.
h
"
#
include
"
webrtc
/
base
/
thread
.
h
"
#
include
"
webrtc
/
base
/
timeutils
.
h
"
namespace
rtc
{
TEST
(
TimeTest
TimeInMs
)
{
uint32_t
ts_earlier
=
Time
(
)
;
Thread
:
:
SleepMs
(
100
)
;
uint32_t
ts_now
=
Time
(
)
;
EXPECT_GE
(
ts_now
ts_earlier
+
80
)
;
EXPECT_LT
(
ts_now
ts_earlier
+
1000
)
;
}
TEST
(
TimeTest
Comparison
)
{
TimeStamp
ts_earlier
=
Time
(
)
;
Thread
:
:
SleepMs
(
100
)
;
TimeStamp
ts_now
=
Time
(
)
;
EXPECT_NE
(
ts_earlier
ts_now
)
;
EXPECT_TRUE
(
TimeIsLaterOrEqual
(
ts_earlier
ts_now
)
)
;
EXPECT_TRUE
(
TimeIsLater
(
ts_earlier
ts_now
)
)
;
EXPECT_FALSE
(
TimeIsLaterOrEqual
(
ts_now
ts_earlier
)
)
;
EXPECT_FALSE
(
TimeIsLater
(
ts_now
ts_earlier
)
)
;
EXPECT_TRUE
(
TimeIsLaterOrEqual
(
ts_earlier
ts_earlier
)
)
;
EXPECT_FALSE
(
TimeIsLater
(
ts_earlier
ts_earlier
)
)
;
TimeStamp
ts_later
=
TimeAfter
(
100
)
;
EXPECT_NE
(
ts_now
ts_later
)
;
EXPECT_TRUE
(
TimeIsLater
(
ts_now
ts_later
)
)
;
EXPECT_TRUE
(
TimeIsLater
(
ts_earlier
ts_later
)
)
;
EXPECT_TRUE
(
TimeIsBetween
(
ts_earlier
ts_now
ts_later
)
)
;
EXPECT_FALSE
(
TimeIsBetween
(
ts_earlier
ts_later
ts_now
)
)
;
EXPECT_FALSE
(
TimeIsBetween
(
ts_now
ts_earlier
ts_later
)
)
;
EXPECT_TRUE
(
TimeIsBetween
(
ts_now
ts_later
ts_earlier
)
)
;
EXPECT_TRUE
(
TimeIsBetween
(
ts_later
ts_earlier
ts_now
)
)
;
EXPECT_FALSE
(
TimeIsBetween
(
ts_later
ts_now
ts_earlier
)
)
;
EXPECT_TRUE
(
TimeIsBetween
(
ts_earlier
ts_earlier
ts_earlier
)
)
;
EXPECT_TRUE
(
TimeIsBetween
(
ts_earlier
ts_earlier
ts_later
)
)
;
EXPECT_TRUE
(
TimeIsBetween
(
ts_earlier
ts_later
ts_later
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMin
(
ts_earlier
ts_earlier
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMin
(
ts_earlier
ts_now
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMin
(
ts_earlier
ts_later
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMin
(
ts_now
ts_earlier
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMin
(
ts_later
ts_earlier
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMax
(
ts_earlier
ts_earlier
)
)
;
EXPECT_EQ
(
ts_now
TimeMax
(
ts_earlier
ts_now
)
)
;
EXPECT_EQ
(
ts_later
TimeMax
(
ts_earlier
ts_later
)
)
;
EXPECT_EQ
(
ts_now
TimeMax
(
ts_now
ts_earlier
)
)
;
EXPECT_EQ
(
ts_later
TimeMax
(
ts_later
ts_earlier
)
)
;
}
TEST
(
TimeTest
Intervals
)
{
TimeStamp
ts_earlier
=
Time
(
)
;
TimeStamp
ts_later
=
TimeAfter
(
500
)
;
EXPECT_LE
(
500
TimeDiff
(
ts_later
ts_earlier
)
)
;
EXPECT_GE
(
-
500
TimeDiff
(
ts_earlier
ts_later
)
)
;
EXPECT_GE
(
TimeSince
(
ts_earlier
)
0
)
;
EXPECT_LE
(
TimeUntil
(
ts_earlier
)
0
)
;
EXPECT_GE
(
TimeSince
(
ts_later
)
-
500
)
;
EXPECT_LE
(
TimeUntil
(
ts_later
)
500
)
;
}
TEST
(
TimeTest
BoundaryComparison
)
{
TimeStamp
ts_earlier
=
static_cast
<
TimeStamp
>
(
-
50
)
;
TimeStamp
ts_later
=
ts_earlier
+
100
;
EXPECT_NE
(
ts_earlier
ts_later
)
;
EXPECT_TRUE
(
TimeIsLaterOrEqual
(
ts_earlier
ts_later
)
)
;
EXPECT_TRUE
(
TimeIsLater
(
ts_earlier
ts_later
)
)
;
EXPECT_FALSE
(
TimeIsLaterOrEqual
(
ts_later
ts_earlier
)
)
;
EXPECT_FALSE
(
TimeIsLater
(
ts_later
ts_earlier
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMin
(
ts_earlier
ts_earlier
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMin
(
ts_earlier
ts_later
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMin
(
ts_later
ts_earlier
)
)
;
EXPECT_EQ
(
ts_earlier
TimeMax
(
ts_earlier
ts_earlier
)
)
;
EXPECT_EQ
(
ts_later
TimeMax
(
ts_earlier
ts_later
)
)
;
EXPECT_EQ
(
ts_later
TimeMax
(
ts_later
ts_earlier
)
)
;
EXPECT_EQ
(
100
TimeDiff
(
ts_later
ts_earlier
)
)
;
EXPECT_EQ
(
-
100
TimeDiff
(
ts_earlier
ts_later
)
)
;
}
TEST
(
TimeTest
DISABLED_CurrentTmTime
)
{
struct
tm
tm
;
int
microseconds
;
time_t
before
=
:
:
time
(
NULL
)
;
CurrentTmTime
(
&
tm
&
microseconds
)
;
time_t
after
=
:
:
time
(
NULL
)
;
time_t
local_delta
=
before
-
:
:
mktime
(
:
:
gmtime
(
&
before
)
)
;
time_t
t
=
:
:
mktime
(
&
tm
)
+
local_delta
;
EXPECT_TRUE
(
before
<
=
t
&
&
t
<
=
after
)
;
EXPECT_TRUE
(
0
<
=
microseconds
&
&
microseconds
<
1000000
)
;
}
class
TimestampWrapAroundHandlerTest
:
public
testing
:
:
Test
{
public
:
TimestampWrapAroundHandlerTest
(
)
{
}
protected
:
TimestampWrapAroundHandler
wraparound_handler_
;
}
;
TEST_F
(
TimestampWrapAroundHandlerTest
Unwrap
)
{
uint32_t
ts
=
0xfffffff2
;
int64_t
unwrapped_ts
=
ts
;
EXPECT_EQ
(
ts
wraparound_handler_
.
Unwrap
(
ts
)
)
;
ts
=
2
;
unwrapped_ts
+
=
0x10
;
EXPECT_EQ
(
unwrapped_ts
wraparound_handler_
.
Unwrap
(
ts
)
)
;
ts
=
0xfffffff2
;
unwrapped_ts
+
=
0xfffffff0
;
EXPECT_EQ
(
unwrapped_ts
wraparound_handler_
.
Unwrap
(
ts
)
)
;
ts
=
0
;
unwrapped_ts
+
=
0xe
;
EXPECT_EQ
(
unwrapped_ts
wraparound_handler_
.
Unwrap
(
ts
)
)
;
}
class
TmToSeconds
:
public
testing
:
:
Test
{
public
:
TmToSeconds
(
)
{
rtc
:
:
SetRandomTestMode
(
true
)
;
}
~
TmToSeconds
(
)
{
rtc
:
:
SetRandomTestMode
(
false
)
;
}
void
TestTmToSeconds
(
int
times
)
{
static
char
mdays
[
12
]
=
{
31
28
31
30
31
30
31
31
30
31
30
31
}
;
for
(
int
i
=
0
;
i
<
times
;
i
+
+
)
{
int
year
=
rtc
:
:
CreateRandomId
(
)
%
400
+
1970
;
bool
leap_year
=
false
;
if
(
year
%
4
=
=
0
)
leap_year
=
true
;
if
(
year
%
100
=
=
0
)
leap_year
=
false
;
if
(
year
%
400
=
=
0
)
leap_year
=
true
;
std
:
:
tm
tm
;
tm
.
tm_year
=
year
-
1900
;
tm
.
tm_mon
=
rtc
:
:
CreateRandomId
(
)
%
12
;
tm
.
tm_mday
=
rtc
:
:
CreateRandomId
(
)
%
mdays
[
tm
.
tm_mon
]
+
1
;
tm
.
tm_hour
=
rtc
:
:
CreateRandomId
(
)
%
24
;
tm
.
tm_min
=
rtc
:
:
CreateRandomId
(
)
%
60
;
tm
.
tm_sec
=
rtc
:
:
CreateRandomId
(
)
%
60
;
int64_t
t
=
rtc
:
:
TmToSeconds
(
tm
)
;
EXPECT_TRUE
(
t
>
=
0
)
;
switch
(
rtc
:
:
CreateRandomId
(
)
%
11
)
{
case
0
:
tm
.
tm_year
=
1969
-
1900
;
break
;
case
1
:
tm
.
tm_mon
=
-
1
;
break
;
case
2
:
tm
.
tm_mon
=
12
;
break
;
case
3
:
tm
.
tm_mday
=
0
;
break
;
case
4
:
tm
.
tm_mday
=
mdays
[
tm
.
tm_mon
]
+
(
leap_year
&
&
tm
.
tm_mon
=
=
1
)
+
1
;
break
;
case
5
:
tm
.
tm_hour
=
-
1
;
break
;
case
6
:
tm
.
tm_hour
=
24
;
break
;
case
7
:
tm
.
tm_min
=
-
1
;
break
;
case
8
:
tm
.
tm_min
=
60
;
break
;
case
9
:
tm
.
tm_sec
=
-
1
;
break
;
case
10
:
tm
.
tm_sec
=
60
;
break
;
}
EXPECT_EQ
(
rtc
:
:
TmToSeconds
(
tm
)
-
1
)
;
}
for
(
int
i
=
0
;
i
<
times
;
i
+
+
)
{
time_t
t
=
rtc
:
:
CreateRandomId
(
)
%
0x80000000
;
#
if
defined
(
WEBRTC_WIN
)
std
:
:
tm
*
tm
=
std
:
:
gmtime
(
&
t
)
;
EXPECT_TRUE
(
tm
)
;
EXPECT_TRUE
(
rtc
:
:
TmToSeconds
(
*
tm
)
=
=
t
)
;
#
else
std
:
:
tm
tm
;
EXPECT_TRUE
(
gmtime_r
(
&
t
&
tm
)
)
;
EXPECT_TRUE
(
rtc
:
:
TmToSeconds
(
tm
)
=
=
t
)
;
#
endif
}
}
}
;
TEST_F
(
TmToSeconds
TestTmToSeconds
)
{
TestTmToSeconds
(
100000
)
;
}
}
