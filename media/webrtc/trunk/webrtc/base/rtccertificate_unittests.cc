#
include
<
utility
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
fakesslidentity
.
h
"
#
include
"
webrtc
/
base
/
gunit
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
rtccertificate
.
h
"
#
include
"
webrtc
/
base
/
safe_conversions
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
sslidentity
.
h
"
#
include
"
webrtc
/
base
/
thread
.
h
"
#
include
"
webrtc
/
base
/
timeutils
.
h
"
namespace
rtc
{
namespace
{
static
const
char
*
kTestCertCommonName
=
"
RTCCertificateTest
'
s
certificate
"
;
}
class
RTCCertificateTest
:
public
testing
:
:
Test
{
public
:
RTCCertificateTest
(
)
{
}
~
RTCCertificateTest
(
)
{
}
protected
:
uint64_t
NowSeconds
(
)
const
{
return
TimeNanos
(
)
/
kNumNanosecsPerSec
;
}
uint64_t
ExpiresSeconds
(
const
scoped_refptr
<
RTCCertificate
>
&
cert
)
const
{
uint64_t
exp_ms
=
cert
-
>
Expires
(
)
;
uint64_t
exp_s
=
exp_ms
/
kNumMillisecsPerSec
;
RTC_CHECK_EQ
(
exp_s
*
kNumMillisecsPerSec
exp_ms
)
;
return
exp_s
;
}
bool
HasExpiredSeconds
(
const
scoped_refptr
<
RTCCertificate
>
&
cert
uint64_t
now_s
)
const
{
return
cert
-
>
HasExpired
(
now_s
*
kNumMillisecsPerSec
)
;
}
scoped_refptr
<
RTCCertificate
>
GenerateCertificateWithExpires
(
uint64_t
expires_s
)
const
{
RTC_CHECK
(
IsValueInRangeForNumericType
<
time_t
>
(
expires_s
)
)
;
SSLIdentityParams
params
;
params
.
common_name
=
kTestCertCommonName
;
params
.
not_before
=
0
;
params
.
not_after
=
static_cast
<
time_t
>
(
expires_s
)
;
params
.
key_params
=
KeyParams
:
:
ECDSA
(
)
;
scoped_ptr
<
SSLIdentity
>
identity
(
SSLIdentity
:
:
GenerateForTest
(
params
)
)
;
return
RTCCertificate
:
:
Create
(
std
:
:
move
(
identity
)
)
;
}
}
;
TEST_F
(
RTCCertificateTest
NewCertificateNotExpired
)
{
scoped_ptr
<
SSLIdentity
>
identity
(
SSLIdentity
:
:
Generate
(
kTestCertCommonName
KeyParams
:
:
ECDSA
(
)
)
)
;
scoped_refptr
<
RTCCertificate
>
certificate
=
RTCCertificate
:
:
Create
(
std
:
:
move
(
identity
)
)
;
uint64_t
now
=
NowSeconds
(
)
;
EXPECT_FALSE
(
HasExpiredSeconds
(
certificate
now
)
)
;
EXPECT_FALSE
(
HasExpiredSeconds
(
certificate
now
+
30
*
60
)
)
;
}
TEST_F
(
RTCCertificateTest
UsesExpiresAskedFor
)
{
uint64_t
now
=
NowSeconds
(
)
;
scoped_refptr
<
RTCCertificate
>
certificate
=
GenerateCertificateWithExpires
(
now
)
;
EXPECT_EQ
(
now
ExpiresSeconds
(
certificate
)
)
;
}
TEST_F
(
RTCCertificateTest
ExpiresInOneSecond
)
{
uint64_t
now
=
NowSeconds
(
)
;
scoped_refptr
<
RTCCertificate
>
certificate
=
GenerateCertificateWithExpires
(
now
+
1
)
;
EXPECT_FALSE
(
HasExpiredSeconds
(
certificate
now
)
)
;
EXPECT_TRUE
(
HasExpiredSeconds
(
certificate
now
+
2
)
)
;
}
}
