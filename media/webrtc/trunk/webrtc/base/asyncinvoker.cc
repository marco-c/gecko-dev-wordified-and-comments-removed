#
include
"
webrtc
/
base
/
asyncinvoker
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
namespace
rtc
{
AsyncInvoker
:
:
AsyncInvoker
(
)
:
destroying_
(
false
)
{
}
AsyncInvoker
:
:
~
AsyncInvoker
(
)
{
destroying_
=
true
;
SignalInvokerDestroyed
(
)
;
MessageQueueManager
:
:
Clear
(
this
)
;
}
void
AsyncInvoker
:
:
OnMessage
(
Message
*
msg
)
{
ScopedRefMessageData
<
AsyncClosure
>
*
data
=
static_cast
<
ScopedRefMessageData
<
AsyncClosure
>
*
>
(
msg
-
>
pdata
)
;
scoped_refptr
<
AsyncClosure
>
closure
=
data
-
>
data
(
)
;
delete
msg
-
>
pdata
;
msg
-
>
pdata
=
NULL
;
closure
-
>
Execute
(
)
;
}
void
AsyncInvoker
:
:
Flush
(
Thread
*
thread
uint32_t
id
)
{
if
(
destroying_
)
return
;
if
(
Thread
:
:
Current
(
)
!
=
thread
)
{
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
AsyncInvoker
:
:
Flush
this
thread
id
)
)
;
return
;
}
MessageList
removed
;
thread
-
>
Clear
(
this
id
&
removed
)
;
for
(
MessageList
:
:
iterator
it
=
removed
.
begin
(
)
;
it
!
=
removed
.
end
(
)
;
+
+
it
)
{
thread
-
>
Send
(
it
-
>
posted_from
it
-
>
phandler
it
-
>
message_id
it
-
>
pdata
)
;
}
}
void
AsyncInvoker
:
:
DoInvoke
(
const
Location
&
posted_from
Thread
*
thread
const
scoped_refptr
<
AsyncClosure
>
&
closure
uint32_t
id
)
{
if
(
destroying_
)
{
LOG
(
LS_WARNING
)
<
<
"
Tried
to
invoke
while
destroying
the
invoker
.
"
;
return
;
}
thread
-
>
Post
(
posted_from
this
id
new
ScopedRefMessageData
<
AsyncClosure
>
(
closure
)
)
;
}
void
AsyncInvoker
:
:
DoInvokeDelayed
(
const
Location
&
posted_from
Thread
*
thread
const
scoped_refptr
<
AsyncClosure
>
&
closure
uint32_t
delay_ms
uint32_t
id
)
{
if
(
destroying_
)
{
LOG
(
LS_WARNING
)
<
<
"
Tried
to
invoke
while
destroying
the
invoker
.
"
;
return
;
}
thread
-
>
PostDelayed
(
posted_from
delay_ms
this
id
new
ScopedRefMessageData
<
AsyncClosure
>
(
closure
)
)
;
}
GuardedAsyncInvoker
:
:
GuardedAsyncInvoker
(
)
:
thread_
(
Thread
:
:
Current
(
)
)
{
thread_
-
>
SignalQueueDestroyed
.
connect
(
this
&
GuardedAsyncInvoker
:
:
ThreadDestroyed
)
;
}
GuardedAsyncInvoker
:
:
~
GuardedAsyncInvoker
(
)
{
}
bool
GuardedAsyncInvoker
:
:
Flush
(
uint32_t
id
)
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
Flush
(
thread_
id
)
;
return
true
;
}
void
GuardedAsyncInvoker
:
:
ThreadDestroyed
(
)
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
RTC_DCHECK
(
thread_
!
=
nullptr
)
;
thread_
=
nullptr
;
}
NotifyingAsyncClosureBase
:
:
NotifyingAsyncClosureBase
(
AsyncInvoker
*
invoker
const
Location
&
callback_posted_from
Thread
*
calling_thread
)
:
invoker_
(
invoker
)
callback_posted_from_
(
callback_posted_from
)
calling_thread_
(
calling_thread
)
{
calling_thread
-
>
SignalQueueDestroyed
.
connect
(
this
&
NotifyingAsyncClosureBase
:
:
CancelCallback
)
;
invoker
-
>
SignalInvokerDestroyed
.
connect
(
this
&
NotifyingAsyncClosureBase
:
:
CancelCallback
)
;
}
NotifyingAsyncClosureBase
:
:
~
NotifyingAsyncClosureBase
(
)
{
disconnect_all
(
)
;
}
void
NotifyingAsyncClosureBase
:
:
TriggerCallback
(
)
{
CritScope
cs
(
&
crit_
)
;
if
(
!
CallbackCanceled
(
)
&
&
!
callback_
.
empty
(
)
)
{
invoker_
-
>
AsyncInvoke
<
void
>
(
callback_posted_from_
calling_thread_
callback_
)
;
}
}
void
NotifyingAsyncClosureBase
:
:
CancelCallback
(
)
{
CritScope
cs
(
&
crit_
)
;
calling_thread_
=
NULL
;
}
}
