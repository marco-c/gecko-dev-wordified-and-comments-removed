#
ifndef
WEBRTC_BASE_NETWORKMONITOR_H_
#
define
WEBRTC_BASE_NETWORKMONITOR_H_
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
#
include
"
webrtc
/
base
/
thread
.
h
"
namespace
rtc
{
class
IPAddress
;
enum
NetworkBindingResults
{
NETWORK_BIND_SUCCESS
=
0
NETWORK_BIND_FAILURE
=
-
1
NETWORK_BIND_NOT_IMPLEMENTED
=
-
2
NETWORK_BIND_ADDRESS_NOT_FOUND
=
-
3
NETWORK_BIND_NETWORK_CHANGED
=
-
4
}
;
enum
AdapterType
{
ADAPTER_TYPE_UNKNOWN
=
0
ADAPTER_TYPE_ETHERNET
=
1
<
<
0
ADAPTER_TYPE_WIFI
=
1
<
<
1
ADAPTER_TYPE_CELLULAR
=
1
<
<
2
ADAPTER_TYPE_VPN
=
1
<
<
3
ADAPTER_TYPE_LOOPBACK
=
1
<
<
4
}
;
class
NetworkBinderInterface
{
public
:
virtual
int
BindSocketToNetwork
(
int
socket_fd
const
IPAddress
&
address
)
=
0
;
virtual
~
NetworkBinderInterface
(
)
{
}
}
;
class
NetworkMonitorInterface
{
public
:
NetworkMonitorInterface
(
)
;
virtual
~
NetworkMonitorInterface
(
)
;
sigslot
:
:
signal0
<
>
SignalNetworksChanged
;
virtual
void
Start
(
)
=
0
;
virtual
void
Stop
(
)
=
0
;
virtual
void
OnNetworksChanged
(
)
=
0
;
virtual
AdapterType
GetAdapterType
(
const
std
:
:
string
&
interface_name
)
=
0
;
}
;
class
NetworkMonitorBase
:
public
NetworkMonitorInterface
public
MessageHandler
public
sigslot
:
:
has_slots
<
>
{
public
:
NetworkMonitorBase
(
)
;
~
NetworkMonitorBase
(
)
override
;
void
OnNetworksChanged
(
)
override
;
void
OnMessage
(
Message
*
msg
)
override
;
protected
:
Thread
*
worker_thread
(
)
{
return
worker_thread_
;
}
private
:
Thread
*
worker_thread_
;
}
;
class
NetworkMonitorFactory
{
public
:
static
void
SetFactory
(
NetworkMonitorFactory
*
factory
)
;
static
void
ReleaseFactory
(
NetworkMonitorFactory
*
factory
)
;
static
NetworkMonitorFactory
*
GetFactory
(
)
;
virtual
NetworkMonitorInterface
*
CreateNetworkMonitor
(
)
=
0
;
virtual
~
NetworkMonitorFactory
(
)
;
protected
:
NetworkMonitorFactory
(
)
;
}
;
}
#
endif
