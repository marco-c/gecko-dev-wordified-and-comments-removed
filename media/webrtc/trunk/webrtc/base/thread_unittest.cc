#
include
<
memory
>
#
include
"
webrtc
/
base
/
asyncinvoker
.
h
"
#
include
"
webrtc
/
base
/
asyncudpsocket
.
h
"
#
include
"
webrtc
/
base
/
event
.
h
"
#
include
"
webrtc
/
base
/
gunit
.
h
"
#
include
"
webrtc
/
base
/
physicalsocketserver
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
#
include
"
webrtc
/
base
/
socketaddress
.
h
"
#
include
"
webrtc
/
base
/
thread
.
h
"
#
if
defined
(
WEBRTC_WIN
)
#
include
<
comdef
.
h
>
#
endif
using
namespace
rtc
;
class
TestGenerator
{
public
:
TestGenerator
(
)
:
last
(
0
)
count
(
0
)
{
}
int
Next
(
int
prev
)
{
int
result
=
prev
+
last
;
last
=
result
;
count
+
=
1
;
return
result
;
}
int
last
;
int
count
;
}
;
struct
TestMessage
:
public
MessageData
{
explicit
TestMessage
(
int
v
)
:
value
(
v
)
{
}
virtual
~
TestMessage
(
)
{
}
int
value
;
}
;
class
SocketClient
:
public
TestGenerator
public
sigslot
:
:
has_slots
<
>
{
public
:
SocketClient
(
AsyncSocket
*
socket
const
SocketAddress
&
addr
Thread
*
post_thread
MessageHandler
*
phandler
)
:
socket_
(
AsyncUDPSocket
:
:
Create
(
socket
addr
)
)
post_thread_
(
post_thread
)
post_handler_
(
phandler
)
{
socket_
-
>
SignalReadPacket
.
connect
(
this
&
SocketClient
:
:
OnPacket
)
;
}
~
SocketClient
(
)
{
delete
socket_
;
}
SocketAddress
address
(
)
const
{
return
socket_
-
>
GetLocalAddress
(
)
;
}
void
OnPacket
(
AsyncPacketSocket
*
socket
const
char
*
buf
size_t
size
const
SocketAddress
&
remote_addr
const
PacketTime
&
packet_time
)
{
EXPECT_EQ
(
size
sizeof
(
uint32_t
)
)
;
uint32_t
prev
=
reinterpret_cast
<
const
uint32_t
*
>
(
buf
)
[
0
]
;
uint32_t
result
=
Next
(
prev
)
;
post_thread_
-
>
PostDelayed
(
RTC_FROM_HERE
200
post_handler_
0
new
TestMessage
(
result
)
)
;
}
private
:
AsyncUDPSocket
*
socket_
;
Thread
*
post_thread_
;
MessageHandler
*
post_handler_
;
}
;
class
MessageClient
:
public
MessageHandler
public
TestGenerator
{
public
:
MessageClient
(
Thread
*
pth
Socket
*
socket
)
:
socket_
(
socket
)
{
}
virtual
~
MessageClient
(
)
{
delete
socket_
;
}
virtual
void
OnMessage
(
Message
*
pmsg
)
{
TestMessage
*
msg
=
static_cast
<
TestMessage
*
>
(
pmsg
-
>
pdata
)
;
int
result
=
Next
(
msg
-
>
value
)
;
EXPECT_GE
(
socket_
-
>
Send
(
&
result
sizeof
(
result
)
)
0
)
;
delete
msg
;
}
private
:
Socket
*
socket_
;
}
;
class
CustomThread
:
public
rtc
:
:
Thread
{
public
:
CustomThread
(
)
{
}
virtual
~
CustomThread
(
)
{
Stop
(
)
;
}
bool
Start
(
)
{
return
false
;
}
bool
WrapCurrent
(
)
{
return
Thread
:
:
WrapCurrent
(
)
;
}
void
UnwrapCurrent
(
)
{
Thread
:
:
UnwrapCurrent
(
)
;
}
}
;
class
SignalWhenDestroyedThread
:
public
Thread
{
public
:
SignalWhenDestroyedThread
(
Event
*
event
)
:
event_
(
event
)
{
}
virtual
~
SignalWhenDestroyedThread
(
)
{
Stop
(
)
;
event_
-
>
Set
(
)
;
}
virtual
void
Run
(
)
{
}
private
:
Event
*
event_
;
}
;
class
AtomicBool
{
public
:
explicit
AtomicBool
(
bool
value
=
false
)
:
flag_
(
value
)
{
}
AtomicBool
&
operator
=
(
bool
value
)
{
CritScope
scoped_lock
(
&
cs_
)
;
flag_
=
value
;
return
*
this
;
}
bool
get
(
)
const
{
CritScope
scoped_lock
(
&
cs_
)
;
return
flag_
;
}
private
:
CriticalSection
cs_
;
bool
flag_
;
}
;
struct
FunctorA
{
int
operator
(
)
(
)
{
return
42
;
}
}
;
class
FunctorB
{
public
:
explicit
FunctorB
(
AtomicBool
*
flag
)
:
flag_
(
flag
)
{
}
void
operator
(
)
(
)
{
if
(
flag_
)
*
flag_
=
true
;
}
private
:
AtomicBool
*
flag_
;
}
;
struct
FunctorC
{
int
operator
(
)
(
)
{
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
50
)
;
return
24
;
}
}
;
TEST
(
ThreadTest
DISABLED_Main
)
{
const
SocketAddress
addr
(
"
127
.
0
.
0
.
1
"
0
)
;
Thread
th1
;
Socket
*
socket
=
th1
.
socketserver
(
)
-
>
CreateAsyncSocket
(
addr
.
family
(
)
SOCK_DGRAM
)
;
MessageClient
msg_client
(
&
th1
socket
)
;
Thread
th2
;
AsyncSocket
*
asocket
=
th2
.
socketserver
(
)
-
>
CreateAsyncSocket
(
addr
.
family
(
)
SOCK_DGRAM
)
;
SocketClient
sock_client
(
asocket
addr
&
th1
&
msg_client
)
;
socket
-
>
Connect
(
sock_client
.
address
(
)
)
;
th1
.
Start
(
)
;
th2
.
Start
(
)
;
th1
.
PostDelayed
(
RTC_FROM_HERE
100
&
msg_client
0
new
TestMessage
(
1
)
)
;
Thread
*
th_main
=
Thread
:
:
Current
(
)
;
th_main
-
>
ProcessMessages
(
1000
)
;
th1
.
Stop
(
)
;
th_main
-
>
ProcessMessages
(
200
)
;
th2
.
Stop
(
)
;
EXPECT_EQ
(
5
msg_client
.
count
)
;
EXPECT_EQ
(
34
msg_client
.
last
)
;
EXPECT_EQ
(
5
sock_client
.
count
)
;
EXPECT_EQ
(
55
sock_client
.
last
)
;
}
TEST
(
ThreadTest
Names
)
{
Thread
*
thread
;
thread
=
new
Thread
(
)
;
EXPECT_TRUE
(
thread
-
>
Start
(
)
)
;
thread
-
>
Stop
(
)
;
delete
thread
;
thread
=
new
Thread
(
)
;
EXPECT_TRUE
(
thread
-
>
SetName
(
"
No
object
"
NULL
)
)
;
EXPECT_TRUE
(
thread
-
>
Start
(
)
)
;
thread
-
>
Stop
(
)
;
delete
thread
;
thread
=
new
Thread
(
)
;
EXPECT_TRUE
(
thread
-
>
SetName
(
"
Abcdefghijklmnopqrstuvwxyz1234567890
"
this
)
)
;
EXPECT_TRUE
(
thread
-
>
Start
(
)
)
;
thread
-
>
Stop
(
)
;
delete
thread
;
}
TEST
(
ThreadTest
Wrap
)
{
Thread
*
current_thread
=
Thread
:
:
Current
(
)
;
current_thread
-
>
UnwrapCurrent
(
)
;
CustomThread
*
cthread
=
new
CustomThread
(
)
;
EXPECT_TRUE
(
cthread
-
>
WrapCurrent
(
)
)
;
EXPECT_TRUE
(
cthread
-
>
RunningForTest
(
)
)
;
EXPECT_FALSE
(
cthread
-
>
IsOwned
(
)
)
;
cthread
-
>
UnwrapCurrent
(
)
;
EXPECT_FALSE
(
cthread
-
>
RunningForTest
(
)
)
;
delete
cthread
;
current_thread
-
>
WrapCurrent
(
)
;
}
TEST
(
ThreadTest
Invoke
)
{
Thread
thread
;
thread
.
Start
(
)
;
EXPECT_EQ
(
42
thread
.
Invoke
<
int
>
(
RTC_FROM_HERE
FunctorA
(
)
)
)
;
AtomicBool
called
;
FunctorB
f2
(
&
called
)
;
thread
.
Invoke
<
void
>
(
RTC_FROM_HERE
f2
)
;
EXPECT_TRUE
(
called
.
get
(
)
)
;
struct
LocalFuncs
{
static
int
Func1
(
)
{
return
999
;
}
static
void
Func2
(
)
{
}
}
;
EXPECT_EQ
(
999
thread
.
Invoke
<
int
>
(
RTC_FROM_HERE
&
LocalFuncs
:
:
Func1
)
)
;
thread
.
Invoke
<
void
>
(
RTC_FROM_HERE
&
LocalFuncs
:
:
Func2
)
;
}
TEST
(
ThreadTest
TwoThreadsInvokeNoDeadlock
)
{
AutoThread
thread
;
Thread
*
current_thread
=
Thread
:
:
Current
(
)
;
ASSERT_TRUE
(
current_thread
!
=
NULL
)
;
Thread
other_thread
;
other_thread
.
Start
(
)
;
struct
LocalFuncs
{
static
void
Set
(
bool
*
out
)
{
*
out
=
true
;
}
static
void
InvokeSet
(
Thread
*
thread
bool
*
out
)
{
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
Set
out
)
)
;
}
}
;
bool
called
=
false
;
other_thread
.
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
LocalFuncs
:
:
InvokeSet
current_thread
&
called
)
)
;
EXPECT_TRUE
(
called
)
;
}
TEST
(
ThreadTest
ThreeThreadsInvoke
)
{
AutoThread
thread
;
Thread
*
thread_a
=
Thread
:
:
Current
(
)
;
Thread
thread_b
thread_c
;
thread_b
.
Start
(
)
;
thread_c
.
Start
(
)
;
class
LockedBool
{
public
:
explicit
LockedBool
(
bool
value
)
:
value_
(
value
)
{
}
void
Set
(
bool
value
)
{
CritScope
lock
(
&
crit_
)
;
value_
=
value
;
}
bool
Get
(
)
{
CritScope
lock
(
&
crit_
)
;
return
value_
;
}
private
:
CriticalSection
crit_
;
bool
value_
GUARDED_BY
(
crit_
)
;
}
;
struct
LocalFuncs
{
static
void
Set
(
LockedBool
*
out
)
{
out
-
>
Set
(
true
)
;
}
static
void
InvokeSet
(
Thread
*
thread
LockedBool
*
out
)
{
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
Set
out
)
)
;
}
static
void
SetAndInvokeSet
(
LockedBool
*
out
Thread
*
thread
LockedBool
*
out_inner
)
{
out
-
>
Set
(
true
)
;
InvokeSet
(
thread
out_inner
)
;
}
static
void
AsyncInvokeSetAndWait
(
Thread
*
thread1
Thread
*
thread2
LockedBool
*
out
)
{
CriticalSection
crit
;
LockedBool
async_invoked
(
false
)
;
AsyncInvoker
invoker
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
thread1
Bind
(
&
SetAndInvokeSet
&
async_invoked
thread2
out
)
)
;
EXPECT_TRUE_WAIT
(
async_invoked
.
Get
(
)
2000
)
;
}
}
;
LockedBool
thread_a_called
(
false
)
;
thread_b
.
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
LocalFuncs
:
:
AsyncInvokeSetAndWait
&
thread_c
thread_a
&
thread_a_called
)
)
;
EXPECT_FALSE
(
thread_a_called
.
Get
(
)
)
;
EXPECT_TRUE_WAIT
(
thread_a_called
.
Get
(
)
2000
)
;
}
class
SetNameOnSignalQueueDestroyedTester
:
public
sigslot
:
:
has_slots
<
>
{
public
:
SetNameOnSignalQueueDestroyedTester
(
Thread
*
thread
)
:
thread_
(
thread
)
{
thread
-
>
SignalQueueDestroyed
.
connect
(
this
&
SetNameOnSignalQueueDestroyedTester
:
:
OnQueueDestroyed
)
;
}
void
OnQueueDestroyed
(
)
{
thread_
-
>
SetName
(
"
foo
"
nullptr
)
;
}
private
:
Thread
*
thread_
;
}
;
TEST
(
ThreadTest
SetNameOnSignalQueueDestroyed
)
{
Thread
*
thread1
=
new
Thread
(
)
;
SetNameOnSignalQueueDestroyedTester
tester1
(
thread1
)
;
delete
thread1
;
Thread
*
thread2
=
new
AutoThread
(
)
;
SetNameOnSignalQueueDestroyedTester
tester2
(
thread2
)
;
delete
thread2
;
#
if
defined
(
WEBRTC_WIN
)
Thread
*
thread3
=
new
ComThread
(
)
;
SetNameOnSignalQueueDestroyedTester
tester3
(
thread3
)
;
delete
thread3
;
#
endif
}
class
AsyncInvokeTest
:
public
testing
:
:
Test
{
public
:
void
IntCallback
(
int
value
)
{
EXPECT_EQ
(
expected_thread_
Thread
:
:
Current
(
)
)
;
int_value_
=
value
;
}
void
AsyncInvokeIntCallback
(
AsyncInvoker
*
invoker
Thread
*
thread
)
{
expected_thread_
=
thread
;
invoker
-
>
AsyncInvoke
(
RTC_FROM_HERE
RTC_FROM_HERE
thread
FunctorC
(
)
&
AsyncInvokeTest
:
:
IntCallback
static_cast
<
AsyncInvokeTest
*
>
(
this
)
)
;
invoke_started_
.
Set
(
)
;
}
void
SetExpectedThreadForIntCallback
(
Thread
*
thread
)
{
expected_thread_
=
thread
;
}
protected
:
enum
{
kWaitTimeout
=
1000
}
;
AsyncInvokeTest
(
)
:
int_value_
(
0
)
invoke_started_
(
true
false
)
expected_thread_
(
NULL
)
{
}
int
int_value_
;
Event
invoke_started_
;
Thread
*
expected_thread_
;
}
;
TEST_F
(
AsyncInvokeTest
FireAndForget
)
{
AsyncInvoker
invoker
;
Thread
thread
;
thread
.
Start
(
)
;
AtomicBool
called
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
&
thread
FunctorB
(
&
called
)
)
;
EXPECT_TRUE_WAIT
(
called
.
get
(
)
kWaitTimeout
)
;
}
TEST_F
(
AsyncInvokeTest
WithCallback
)
{
AsyncInvoker
invoker
;
Thread
thread
;
thread
.
Start
(
)
;
SetExpectedThreadForIntCallback
(
Thread
:
:
Current
(
)
)
;
invoker
.
AsyncInvoke
(
RTC_FROM_HERE
RTC_FROM_HERE
&
thread
FunctorA
(
)
&
AsyncInvokeTest
:
:
IntCallback
static_cast
<
AsyncInvokeTest
*
>
(
this
)
)
;
EXPECT_EQ_WAIT
(
42
int_value_
kWaitTimeout
)
;
}
TEST_F
(
AsyncInvokeTest
CancelInvoker
)
{
Thread
thread
;
thread
.
Start
(
)
;
{
AsyncInvoker
invoker
;
invoker
.
AsyncInvoke
(
RTC_FROM_HERE
RTC_FROM_HERE
&
thread
FunctorC
(
)
&
AsyncInvokeTest
:
:
IntCallback
static_cast
<
AsyncInvokeTest
*
>
(
this
)
)
;
}
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
kWaitTimeout
)
;
EXPECT_EQ
(
0
int_value_
)
;
}
TEST_F
(
AsyncInvokeTest
CancelCallingThread
)
{
AsyncInvoker
invoker
;
{
Thread
thread
;
thread
.
Start
(
)
;
thread
.
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
AsyncInvokeTest
:
:
AsyncInvokeIntCallback
static_cast
<
AsyncInvokeTest
*
>
(
this
)
&
invoker
Thread
:
:
Current
(
)
)
)
;
ASSERT_TRUE
(
invoke_started_
.
Wait
(
kWaitTimeout
)
)
;
}
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
kWaitTimeout
)
;
EXPECT_EQ
(
0
int_value_
)
;
}
TEST_F
(
AsyncInvokeTest
KillInvokerBeforeExecute
)
{
Thread
thread
;
thread
.
Start
(
)
;
{
AsyncInvoker
invoker
;
thread
.
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
AsyncInvokeTest
:
:
AsyncInvokeIntCallback
static_cast
<
AsyncInvokeTest
*
>
(
this
)
&
invoker
Thread
:
:
Current
(
)
)
)
;
ASSERT_TRUE
(
invoke_started_
.
Wait
(
kWaitTimeout
)
)
;
}
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
kWaitTimeout
)
;
EXPECT_EQ
(
0
int_value_
)
;
}
TEST_F
(
AsyncInvokeTest
Flush
)
{
AsyncInvoker
invoker
;
AtomicBool
flag1
;
AtomicBool
flag2
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
Thread
:
:
Current
(
)
FunctorB
(
&
flag1
)
)
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
Thread
:
:
Current
(
)
FunctorB
(
&
flag2
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
invoker
.
Flush
(
Thread
:
:
Current
(
)
)
;
EXPECT_TRUE
(
flag1
.
get
(
)
)
;
EXPECT_TRUE
(
flag2
.
get
(
)
)
;
}
TEST_F
(
AsyncInvokeTest
FlushWithIds
)
{
AsyncInvoker
invoker
;
AtomicBool
flag1
;
AtomicBool
flag2
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
Thread
:
:
Current
(
)
FunctorB
(
&
flag1
)
5
)
;
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
Thread
:
:
Current
(
)
FunctorB
(
&
flag2
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
invoker
.
Flush
(
Thread
:
:
Current
(
)
5
)
;
EXPECT_TRUE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
flag1
=
false
;
invoker
.
Flush
(
Thread
:
:
Current
(
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_TRUE
(
flag2
.
get
(
)
)
;
}
class
GuardedAsyncInvokeTest
:
public
testing
:
:
Test
{
public
:
void
IntCallback
(
int
value
)
{
EXPECT_EQ
(
expected_thread_
Thread
:
:
Current
(
)
)
;
int_value_
=
value
;
}
void
AsyncInvokeIntCallback
(
GuardedAsyncInvoker
*
invoker
Thread
*
thread
)
{
expected_thread_
=
thread
;
invoker
-
>
AsyncInvoke
(
RTC_FROM_HERE
RTC_FROM_HERE
FunctorC
(
)
&
GuardedAsyncInvokeTest
:
:
IntCallback
static_cast
<
GuardedAsyncInvokeTest
*
>
(
this
)
)
;
invoke_started_
.
Set
(
)
;
}
void
SetExpectedThreadForIntCallback
(
Thread
*
thread
)
{
expected_thread_
=
thread
;
}
protected
:
const
static
int
kWaitTimeout
=
1000
;
GuardedAsyncInvokeTest
(
)
:
int_value_
(
0
)
invoke_started_
(
true
false
)
expected_thread_
(
nullptr
)
{
}
int
int_value_
;
Event
invoke_started_
;
Thread
*
expected_thread_
;
}
;
struct
CreateInvoker
{
CreateInvoker
(
std
:
:
unique_ptr
<
GuardedAsyncInvoker
>
*
invoker
)
:
invoker_
(
invoker
)
{
}
void
operator
(
)
(
)
{
invoker_
-
>
reset
(
new
GuardedAsyncInvoker
(
)
)
;
}
std
:
:
unique_ptr
<
GuardedAsyncInvoker
>
*
invoker_
;
}
;
TEST_F
(
GuardedAsyncInvokeTest
KillThreadFireAndForget
)
{
std
:
:
unique_ptr
<
Thread
>
thread
(
new
Thread
(
)
)
;
thread
-
>
Start
(
)
;
std
:
:
unique_ptr
<
GuardedAsyncInvoker
>
invoker
;
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
CreateInvoker
(
&
invoker
)
)
;
thread
=
nullptr
;
AtomicBool
called
;
EXPECT_FALSE
(
invoker
-
>
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
called
)
)
)
;
WAIT
(
called
.
get
(
)
kWaitTimeout
)
;
EXPECT_FALSE
(
called
.
get
(
)
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
KillThreadWithCallback
)
{
std
:
:
unique_ptr
<
Thread
>
thread
(
new
Thread
(
)
)
;
thread
-
>
Start
(
)
;
std
:
:
unique_ptr
<
GuardedAsyncInvoker
>
invoker
;
thread
-
>
Invoke
<
void
>
(
RTC_FROM_HERE
CreateInvoker
(
&
invoker
)
)
;
thread
=
nullptr
;
EXPECT_FALSE
(
invoker
-
>
AsyncInvoke
(
RTC_FROM_HERE
RTC_FROM_HERE
FunctorC
(
)
&
GuardedAsyncInvokeTest
:
:
IntCallback
static_cast
<
GuardedAsyncInvokeTest
*
>
(
this
)
)
)
;
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
kWaitTimeout
)
;
EXPECT_EQ
(
0
int_value_
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
FireAndForget
)
{
GuardedAsyncInvoker
invoker
;
AtomicBool
called
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
called
)
)
)
;
EXPECT_TRUE_WAIT
(
called
.
get
(
)
kWaitTimeout
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
WithCallback
)
{
GuardedAsyncInvoker
invoker
;
SetExpectedThreadForIntCallback
(
Thread
:
:
Current
(
)
)
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
(
RTC_FROM_HERE
RTC_FROM_HERE
FunctorA
(
)
&
GuardedAsyncInvokeTest
:
:
IntCallback
static_cast
<
GuardedAsyncInvokeTest
*
>
(
this
)
)
)
;
EXPECT_EQ_WAIT
(
42
int_value_
kWaitTimeout
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
CancelInvoker
)
{
{
GuardedAsyncInvoker
invoker
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
(
RTC_FROM_HERE
RTC_FROM_HERE
FunctorC
(
)
&
GuardedAsyncInvokeTest
:
:
IntCallback
static_cast
<
GuardedAsyncInvokeTest
*
>
(
this
)
)
)
;
}
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
kWaitTimeout
)
;
EXPECT_EQ
(
0
int_value_
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
CancelCallingThread
)
{
GuardedAsyncInvoker
invoker
;
{
Thread
thread
;
thread
.
Start
(
)
;
thread
.
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
GuardedAsyncInvokeTest
:
:
AsyncInvokeIntCallback
static_cast
<
GuardedAsyncInvokeTest
*
>
(
this
)
&
invoker
Thread
:
:
Current
(
)
)
)
;
ASSERT_TRUE
(
invoke_started_
.
Wait
(
kWaitTimeout
)
)
;
}
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
kWaitTimeout
)
;
EXPECT_EQ
(
0
int_value_
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
KillInvokerBeforeExecute
)
{
Thread
thread
;
thread
.
Start
(
)
;
{
GuardedAsyncInvoker
invoker
;
thread
.
Invoke
<
void
>
(
RTC_FROM_HERE
Bind
(
&
GuardedAsyncInvokeTest
:
:
AsyncInvokeIntCallback
static_cast
<
GuardedAsyncInvokeTest
*
>
(
this
)
&
invoker
Thread
:
:
Current
(
)
)
)
;
ASSERT_TRUE
(
invoke_started_
.
Wait
(
kWaitTimeout
)
)
;
}
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
kWaitTimeout
)
;
EXPECT_EQ
(
0
int_value_
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
Flush
)
{
GuardedAsyncInvoker
invoker
;
AtomicBool
flag1
;
AtomicBool
flag2
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
flag1
)
)
)
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
flag2
)
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
EXPECT_TRUE
(
invoker
.
Flush
(
)
)
;
EXPECT_TRUE
(
flag1
.
get
(
)
)
;
EXPECT_TRUE
(
flag2
.
get
(
)
)
;
}
TEST_F
(
GuardedAsyncInvokeTest
FlushWithIds
)
{
GuardedAsyncInvoker
invoker
;
AtomicBool
flag1
;
AtomicBool
flag2
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
flag1
)
5
)
)
;
EXPECT_TRUE
(
invoker
.
AsyncInvoke
<
void
>
(
RTC_FROM_HERE
FunctorB
(
&
flag2
)
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
EXPECT_TRUE
(
invoker
.
Flush
(
5
)
)
;
EXPECT_TRUE
(
flag1
.
get
(
)
)
;
EXPECT_FALSE
(
flag2
.
get
(
)
)
;
flag1
=
false
;
EXPECT_TRUE
(
invoker
.
Flush
(
)
)
;
EXPECT_FALSE
(
flag1
.
get
(
)
)
;
EXPECT_TRUE
(
flag2
.
get
(
)
)
;
}
#
if
defined
(
WEBRTC_WIN
)
class
ComThreadTest
:
public
testing
:
:
Test
public
MessageHandler
{
public
:
ComThreadTest
(
)
:
done_
(
false
)
{
}
protected
:
virtual
void
OnMessage
(
Message
*
message
)
{
HRESULT
hr
=
CoInitializeEx
(
NULL
COINIT_MULTITHREADED
)
;
EXPECT_EQ
(
S_FALSE
hr
)
;
if
(
SUCCEEDED
(
hr
)
)
{
CoUninitialize
(
)
;
}
done_
=
true
;
}
bool
done_
;
}
;
TEST_F
(
ComThreadTest
ComInited
)
{
Thread
*
thread
=
new
ComThread
(
)
;
EXPECT_TRUE
(
thread
-
>
Start
(
)
)
;
thread
-
>
Post
(
RTC_FROM_HERE
this
0
)
;
EXPECT_TRUE_WAIT
(
done_
1000
)
;
delete
thread
;
}
#
endif
