#
ifndef
WEBRTC_BASE_ASYNCINVOKER_H_
#
define
WEBRTC_BASE_ASYNCINVOKER_H_
#
include
"
webrtc
/
base
/
asyncinvoker
-
inl
.
h
"
#
include
"
webrtc
/
base
/
bind
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
#
include
"
webrtc
/
base
/
scopedptrcollection
.
h
"
#
include
"
webrtc
/
base
/
thread
.
h
"
namespace
rtc
{
class
AsyncInvoker
:
public
MessageHandler
{
public
:
AsyncInvoker
(
)
;
~
AsyncInvoker
(
)
override
;
template
<
class
ReturnT
class
FunctorT
>
void
AsyncInvoke
(
Thread
*
thread
const
FunctorT
&
functor
uint32_t
id
=
0
)
{
scoped_refptr
<
AsyncClosure
>
closure
(
new
RefCountedObject
<
FireAndForgetAsyncClosure
<
FunctorT
>
>
(
functor
)
)
;
DoInvoke
(
thread
closure
id
)
;
}
template
<
class
ReturnT
class
FunctorT
>
void
AsyncInvokeDelayed
(
Thread
*
thread
const
FunctorT
&
functor
uint32_t
delay_ms
uint32_t
id
=
0
)
{
scoped_refptr
<
AsyncClosure
>
closure
(
new
RefCountedObject
<
FireAndForgetAsyncClosure
<
FunctorT
>
>
(
functor
)
)
;
DoInvokeDelayed
(
thread
closure
delay_ms
id
)
;
}
template
<
class
ReturnT
class
FunctorT
class
HostT
>
void
AsyncInvoke
(
Thread
*
thread
const
FunctorT
&
functor
void
(
HostT
:
:
*
callback
)
(
ReturnT
)
HostT
*
callback_host
uint32_t
id
=
0
)
{
scoped_refptr
<
AsyncClosure
>
closure
(
new
RefCountedObject
<
NotifyingAsyncClosure
<
ReturnT
FunctorT
HostT
>
>
(
this
Thread
:
:
Current
(
)
functor
callback
callback_host
)
)
;
DoInvoke
(
thread
closure
id
)
;
}
template
<
class
ReturnT
class
FunctorT
class
HostT
>
void
AsyncInvoke
(
Thread
*
thread
const
FunctorT
&
functor
void
(
HostT
:
:
*
callback
)
(
)
HostT
*
callback_host
uint32_t
id
=
0
)
{
scoped_refptr
<
AsyncClosure
>
closure
(
new
RefCountedObject
<
NotifyingAsyncClosure
<
void
FunctorT
HostT
>
>
(
this
Thread
:
:
Current
(
)
functor
callback
callback_host
)
)
;
DoInvoke
(
thread
closure
id
)
;
}
void
Flush
(
Thread
*
thread
uint32_t
id
=
MQID_ANY
)
;
sigslot
:
:
signal0
<
>
SignalInvokerDestroyed
;
private
:
void
OnMessage
(
Message
*
msg
)
override
;
void
DoInvoke
(
Thread
*
thread
const
scoped_refptr
<
AsyncClosure
>
&
closure
uint32_t
id
)
;
void
DoInvokeDelayed
(
Thread
*
thread
const
scoped_refptr
<
AsyncClosure
>
&
closure
uint32_t
delay_ms
uint32_t
id
)
;
bool
destroying_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AsyncInvoker
)
;
}
;
class
GuardedAsyncInvoker
:
public
sigslot
:
:
has_slots
<
>
{
public
:
GuardedAsyncInvoker
(
)
;
~
GuardedAsyncInvoker
(
)
override
;
bool
Flush
(
uint32_t
id
=
MQID_ANY
)
;
template
<
class
ReturnT
class
FunctorT
>
bool
AsyncInvoke
(
const
FunctorT
&
functor
uint32_t
id
=
0
)
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
AsyncInvoke
<
ReturnT
FunctorT
>
(
thread_
functor
id
)
;
return
true
;
}
template
<
class
ReturnT
class
FunctorT
>
bool
AsyncInvokeDelayed
(
const
FunctorT
&
functor
uint32_t
delay_ms
uint32_t
id
=
0
)
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
AsyncInvokeDelayed
<
ReturnT
FunctorT
>
(
thread_
functor
delay_ms
id
)
;
return
true
;
}
template
<
class
ReturnT
class
FunctorT
class
HostT
>
bool
AsyncInvoke
(
const
FunctorT
&
functor
void
(
HostT
:
:
*
callback
)
(
ReturnT
)
HostT
*
callback_host
uint32_t
id
=
0
)
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
AsyncInvoke
<
ReturnT
FunctorT
HostT
>
(
thread_
functor
callback
callback_host
id
)
;
return
true
;
}
template
<
class
ReturnT
class
FunctorT
class
HostT
>
bool
AsyncInvoke
(
const
FunctorT
&
functor
void
(
HostT
:
:
*
callback
)
(
)
HostT
*
callback_host
uint32_t
id
=
0
)
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
if
(
thread_
=
=
nullptr
)
return
false
;
invoker_
.
AsyncInvoke
<
ReturnT
FunctorT
HostT
>
(
thread_
functor
callback
callback_host
id
)
;
return
true
;
}
private
:
void
ThreadDestroyed
(
)
;
CriticalSection
crit_
;
Thread
*
thread_
GUARDED_BY
(
crit_
)
;
AsyncInvoker
invoker_
GUARDED_BY
(
crit_
)
;
}
;
}
#
endif
