#
ifndef
WEBRTC_BASE_TASK_QUEUE_H_
#
define
WEBRTC_BASE_TASK_QUEUE_H_
#
include
<
list
>
#
include
<
memory
>
#
include
<
unordered_map
>
#
if
defined
(
WEBRTC_MAC
)
&
&
!
defined
(
WEBRTC_BUILD_LIBEVENT
)
#
include
<
dispatch
/
dispatch
.
h
>
#
endif
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
#
include
"
webrtc
/
base
/
criticalsection
.
h
"
#
if
defined
(
WEBRTC_WIN
)
|
|
defined
(
WEBRTC_BUILD_LIBEVENT
)
#
include
"
webrtc
/
base
/
platform_thread
.
h
"
#
endif
#
if
defined
(
WEBRTC_BUILD_LIBEVENT
)
struct
event_base
;
struct
event
;
#
endif
namespace
rtc
{
class
QueuedTask
{
public
:
QueuedTask
(
)
{
}
virtual
~
QueuedTask
(
)
{
}
virtual
bool
Run
(
)
=
0
;
private
:
RTC_DISALLOW_COPY_AND_ASSIGN
(
QueuedTask
)
;
}
;
template
<
class
Closure
>
class
ClosureTask
:
public
QueuedTask
{
public
:
explicit
ClosureTask
(
const
Closure
&
closure
)
:
closure_
(
closure
)
{
}
private
:
bool
Run
(
)
override
{
closure_
(
)
;
return
true
;
}
Closure
closure_
;
}
;
template
<
class
Closure
class
Cleanup
>
class
ClosureTaskWithCleanup
:
public
ClosureTask
<
Closure
>
{
public
:
ClosureTaskWithCleanup
(
const
Closure
&
closure
Cleanup
cleanup
)
:
ClosureTask
<
Closure
>
(
closure
)
cleanup_
(
cleanup
)
{
}
~
ClosureTaskWithCleanup
(
)
{
cleanup_
(
)
;
}
private
:
Cleanup
cleanup_
;
}
;
template
<
class
Closure
>
static
std
:
:
unique_ptr
<
QueuedTask
>
NewClosure
(
const
Closure
&
closure
)
{
return
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTask
<
Closure
>
(
closure
)
)
;
}
template
<
class
Closure
class
Cleanup
>
static
std
:
:
unique_ptr
<
QueuedTask
>
NewClosure
(
const
Closure
&
closure
const
Cleanup
&
cleanup
)
{
return
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTaskWithCleanup
<
Closure
Cleanup
>
(
closure
cleanup
)
)
;
}
class
LOCKABLE
TaskQueue
{
public
:
explicit
TaskQueue
(
const
char
*
queue_name
)
;
~
TaskQueue
(
)
;
static
TaskQueue
*
Current
(
)
;
static
bool
IsCurrent
(
const
char
*
queue_name
)
;
bool
IsCurrent
(
)
const
;
void
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
)
;
void
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
TaskQueue
*
reply_queue
)
;
void
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
)
;
void
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
task
uint32_t
milliseconds
)
;
template
<
class
Closure
>
void
PostTask
(
const
Closure
&
closure
)
{
PostTask
(
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTask
<
Closure
>
(
closure
)
)
)
;
}
template
<
class
Closure
>
void
PostDelayedTask
(
const
Closure
&
closure
uint32_t
milliseconds
)
{
PostDelayedTask
(
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTask
<
Closure
>
(
closure
)
)
milliseconds
)
;
}
template
<
class
Closure1
class
Closure2
>
void
PostTaskAndReply
(
const
Closure1
&
task
const
Closure2
&
reply
TaskQueue
*
reply_queue
)
{
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTask
<
Closure1
>
(
task
)
)
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTask
<
Closure2
>
(
reply
)
)
reply_queue
)
;
}
template
<
class
Closure
>
void
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
task
const
Closure
&
reply
)
{
PostTaskAndReply
(
std
:
:
move
(
task
)
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTask
<
Closure
>
(
reply
)
)
)
;
}
template
<
class
Closure
>
void
PostTaskAndReply
(
const
Closure
&
task
std
:
:
unique_ptr
<
QueuedTask
>
reply
)
{
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTask
<
Closure
>
(
task
)
)
std
:
:
move
(
reply
)
)
;
}
template
<
class
Closure1
class
Closure2
>
void
PostTaskAndReply
(
const
Closure1
&
task
const
Closure2
&
reply
)
{
PostTaskAndReply
(
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTask
<
Closure1
>
(
task
)
)
std
:
:
unique_ptr
<
QueuedTask
>
(
new
ClosureTask
<
Closure2
>
(
reply
)
)
)
;
}
private
:
#
if
defined
(
WEBRTC_BUILD_LIBEVENT
)
static
bool
ThreadMain
(
void
*
context
)
;
static
void
OnWakeup
(
int
socket
short
flags
void
*
context
)
;
static
void
RunTask
(
int
fd
short
flags
void
*
context
)
;
static
void
RunTimer
(
int
fd
short
flags
void
*
context
)
;
class
PostAndReplyTask
;
class
SetTimerTask
;
void
PrepareReplyTask
(
PostAndReplyTask
*
reply_task
)
;
void
ReplyTaskDone
(
PostAndReplyTask
*
reply_task
)
;
struct
QueueContext
;
int
wakeup_pipe_in_
=
-
1
;
int
wakeup_pipe_out_
=
-
1
;
event_base
*
event_base_
;
std
:
:
unique_ptr
<
event
>
wakeup_event_
;
PlatformThread
thread_
;
rtc
:
:
CriticalSection
pending_lock_
;
std
:
:
list
<
std
:
:
unique_ptr
<
QueuedTask
>
>
pending_
GUARDED_BY
(
pending_lock_
)
;
std
:
:
list
<
PostAndReplyTask
*
>
pending_replies_
GUARDED_BY
(
pending_lock_
)
;
#
elif
defined
(
WEBRTC_MAC
)
struct
QueueContext
;
struct
TaskContext
;
struct
PostTaskAndReplyContext
;
dispatch_queue_t
queue_
;
QueueContext
*
const
context_
;
#
elif
defined
(
WEBRTC_WIN
)
typedef
std
:
:
unordered_map
<
UINT_PTR
std
:
:
unique_ptr
<
QueuedTask
>
>
DelayedTasks
;
static
bool
ThreadMain
(
void
*
context
)
;
static
bool
ProcessQueuedMessages
(
DelayedTasks
*
delayed_tasks
)
;
class
WorkerThread
:
public
PlatformThread
{
public
:
WorkerThread
(
ThreadRunFunction
func
void
*
obj
const
char
*
thread_name
)
:
PlatformThread
(
func
obj
thread_name
)
{
}
bool
QueueAPC
(
PAPCFUNC
apc_function
ULONG_PTR
data
)
{
return
PlatformThread
:
:
QueueAPC
(
apc_function
data
)
;
}
}
;
WorkerThread
thread_
;
#
else
#
error
not
supported
.
#
endif
RTC_DISALLOW_COPY_AND_ASSIGN
(
TaskQueue
)
;
}
;
}
#
endif
