#
ifndef
WEBRTC_BASE_OPTIONAL_H_
#
define
WEBRTC_BASE_OPTIONAL_H_
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
webrtc
/
base
/
checks
.
h
"
namespace
rtc
{
template
<
typename
T
>
class
Optional
final
{
public
:
Optional
(
)
:
has_value_
(
false
)
{
}
explicit
Optional
(
const
T
&
val
)
:
value_
(
val
)
has_value_
(
true
)
{
}
explicit
Optional
(
T
&
&
val
)
:
value_
(
std
:
:
move
(
val
)
)
has_value_
(
true
)
{
}
Optional
(
const
Optional
&
)
=
default
;
Optional
(
Optional
&
&
m
)
:
value_
(
std
:
:
move
(
m
.
value_
)
)
has_value_
(
m
.
has_value_
)
{
}
Optional
&
operator
=
(
const
Optional
&
)
=
default
;
Optional
&
operator
=
(
Optional
&
&
m
)
{
value_
=
std
:
:
move
(
m
.
value_
)
;
has_value_
=
m
.
has_value_
;
return
*
this
;
}
friend
void
swap
(
Optional
&
m1
Optional
&
m2
)
{
using
std
:
:
swap
;
swap
(
m1
.
value_
m2
.
value_
)
;
swap
(
m1
.
has_value_
m2
.
has_value_
)
;
}
explicit
operator
bool
(
)
const
{
return
has_value_
;
}
const
T
*
operator
-
>
(
)
const
{
RTC_DCHECK
(
has_value_
)
;
return
&
value_
;
}
T
*
operator
-
>
(
)
{
RTC_DCHECK
(
has_value_
)
;
return
&
value_
;
}
const
T
&
operator
*
(
)
const
{
RTC_DCHECK
(
has_value_
)
;
return
value_
;
}
T
&
operator
*
(
)
{
RTC_DCHECK
(
has_value_
)
;
return
value_
;
}
const
T
&
value_or
(
const
T
&
default_val
)
const
{
return
has_value_
?
value_
:
default_val
;
}
friend
bool
operator
=
=
(
const
Optional
&
m1
const
Optional
&
m2
)
{
return
m1
.
has_value_
&
&
m2
.
has_value_
?
m1
.
value_
=
=
m2
.
value_
:
m1
.
has_value_
=
=
m2
.
has_value_
;
}
friend
bool
operator
!
=
(
const
Optional
&
m1
const
Optional
&
m2
)
{
return
m1
.
has_value_
&
&
m2
.
has_value_
?
m1
.
value_
!
=
m2
.
value_
:
m1
.
has_value_
!
=
m2
.
has_value_
;
}
private
:
T
value_
;
bool
has_value_
;
}
;
}
#
endif
