#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
iostream
>
#
include
<
numeric
>
#
include
<
vector
>
#
include
"
webrtc
/
tools
/
frame_analyzer
/
reference_less_video_analysis_lib
.
h
"
#
include
"
webrtc
/
tools
/
frame_analyzer
/
video_quality_analysis
.
h
"
#
define
STATS_LINE_LENGTH
28
#
define
PSNR_FREEZE_THRESHOLD
47
#
define
SSIM_FREEZE_THRESHOLD
.
999
#
if
defined
(
_WIN32
)
|
|
defined
(
_WIN64
)
#
define
strtok_r
strtok_s
#
endif
void
get_height_width_fps
(
int
*
height
int
*
width
int
*
fps
const
std
:
:
string
&
video_file
)
{
char
frame_header
[
STATS_LINE_LENGTH
]
;
FILE
*
input_file
=
fopen
(
video_file
.
c_str
(
)
"
rb
"
)
;
size_t
bytes_read
=
fread
(
frame_header
1
STATS_LINE_LENGTH
-
1
input_file
)
;
frame_header
[
bytes_read
]
=
'
\
0
'
;
std
:
:
string
file_header_stats
[
5
]
;
int
no_of_stats
=
0
;
char
*
save_ptr
;
char
*
token
=
strtok_r
(
frame_header
"
"
&
save_ptr
)
;
while
(
token
!
=
NULL
)
{
file_header_stats
[
no_of_stats
+
+
]
=
token
;
token
=
strtok_r
(
NULL
"
"
&
save_ptr
)
;
}
*
width
=
std
:
:
stoi
(
file_header_stats
[
1
]
.
erase
(
0
1
)
)
;
*
height
=
std
:
:
stoi
(
file_header_stats
[
2
]
.
erase
(
0
1
)
)
;
*
fps
=
std
:
:
stoi
(
file_header_stats
[
3
]
.
erase
(
0
1
)
)
;
printf
(
"
Height
:
%
d
Width
:
%
d
fps
:
%
d
\
n
"
*
height
*
width
*
fps
)
;
fclose
(
input_file
)
;
}
bool
frozen_frame
(
std
:
:
vector
<
double
>
psnr_per_frame
std
:
:
vector
<
double
>
ssim_per_frame
size_t
frame
)
{
if
(
psnr_per_frame
[
frame
]
>
=
PSNR_FREEZE_THRESHOLD
|
|
ssim_per_frame
[
frame
]
>
=
SSIM_FREEZE_THRESHOLD
)
return
true
;
return
false
;
}
std
:
:
vector
<
int
>
find_frame_clusters
(
const
std
:
:
vector
<
double
>
&
psnr_per_frame
const
std
:
:
vector
<
double
>
&
ssim_per_frame
)
{
std
:
:
vector
<
int
>
identical_frame_clusters
;
int
num_frozen
=
0
;
size_t
total_no_of_frames
=
psnr_per_frame
.
size
(
)
;
for
(
size_t
each_frame
=
0
;
each_frame
<
total_no_of_frames
;
each_frame
+
+
)
{
if
(
frozen_frame
(
psnr_per_frame
ssim_per_frame
each_frame
)
)
{
num_frozen
+
+
;
}
else
if
(
num_frozen
>
0
)
{
identical_frame_clusters
.
push_back
(
num_frozen
)
;
num_frozen
=
0
;
}
}
return
identical_frame_clusters
;
}
void
print_freezing_metrics
(
const
std
:
:
vector
<
double
>
&
psnr_per_frame
const
std
:
:
vector
<
double
>
&
ssim_per_frame
)
{
size_t
total_no_of_frames
=
psnr_per_frame
.
size
(
)
;
std
:
:
vector
<
int
>
identical_frame_clusters
=
find_frame_clusters
(
psnr_per_frame
ssim_per_frame
)
;
int
total_identical_frames
=
std
:
:
accumulate
(
identical_frame_clusters
.
begin
(
)
identical_frame_clusters
.
end
(
)
0
)
;
size_t
unique_frames
=
total_no_of_frames
-
total_identical_frames
;
printf
(
"
Total
number
of
frames
received
:
%
zu
\
n
"
total_no_of_frames
)
;
printf
(
"
Total
identical
frames
:
%
d
\
n
"
total_identical_frames
)
;
printf
(
"
Number
of
unique
frames
:
%
zu
\
n
"
unique_frames
)
;
printf
(
"
Printing
Identical
Frames
:
\
n
"
)
;
for
(
size_t
frame
=
0
;
frame
<
total_no_of_frames
;
frame
+
+
)
{
if
(
frozen_frame
(
psnr_per_frame
ssim_per_frame
frame
)
)
{
printf
(
"
Frame
Number
:
%
zu
PSNR
:
%
f
SSIM
:
%
f
\
n
"
frame
psnr_per_frame
[
frame
]
ssim_per_frame
[
frame
]
)
;
}
}
printf
(
"
Print
identical
frame
which
appears
in
clusters
:
\
n
"
)
;
for
(
int
cluster
=
0
;
cluster
<
static_cast
<
int
>
(
identical_frame_clusters
.
size
(
)
)
;
cluster
+
+
)
printf
(
"
%
d
"
identical_frame_clusters
[
cluster
]
)
;
printf
(
"
\
n
"
)
;
}
void
compute_metrics
(
const
std
:
:
string
&
video_file_name
std
:
:
vector
<
double
>
*
psnr_per_frame
std
:
:
vector
<
double
>
*
ssim_per_frame
)
{
int
height
=
0
width
=
0
fps
=
0
;
get_height_width_fps
(
&
height
&
width
&
fps
video_file_name
)
;
int
no_of_frames
=
0
;
int
size
=
webrtc
:
:
test
:
:
GetI420FrameSize
(
width
height
)
;
uint8_t
*
current_frame
=
new
uint8_t
[
size
]
;
uint8_t
*
next_frame
=
new
uint8_t
[
size
]
;
while
(
true
)
{
if
(
!
(
webrtc
:
:
test
:
:
ExtractFrameFromY4mFile
(
video_file_name
.
c_str
(
)
width
height
no_of_frames
current_frame
)
)
)
{
break
;
}
if
(
!
(
webrtc
:
:
test
:
:
ExtractFrameFromY4mFile
(
video_file_name
.
c_str
(
)
width
height
no_of_frames
+
1
next_frame
)
)
)
{
break
;
}
double
result_psnr
=
webrtc
:
:
test
:
:
CalculateMetrics
(
webrtc
:
:
test
:
:
kPSNR
current_frame
next_frame
width
height
)
;
double
result_ssim
=
webrtc
:
:
test
:
:
CalculateMetrics
(
webrtc
:
:
test
:
:
kSSIM
current_frame
next_frame
width
height
)
;
psnr_per_frame
-
>
push_back
(
result_psnr
)
;
ssim_per_frame
-
>
push_back
(
result_ssim
)
;
no_of_frames
+
+
;
}
delete
[
]
current_frame
;
delete
[
]
next_frame
;
}
bool
check_file_extension
(
const
std
:
:
string
&
video_file_name
)
{
if
(
video_file_name
.
substr
(
video_file_name
.
length
(
)
-
3
3
)
!
=
"
y4m
"
)
{
printf
(
"
Only
y4m
video
file
format
is
supported
.
Given
:
%
s
\
n
"
video_file_name
.
c_str
(
)
)
;
return
false
;
}
return
true
;
}
int
run_analysis
(
const
std
:
:
string
&
video_file
)
{
std
:
:
vector
<
double
>
psnr_per_frame
;
std
:
:
vector
<
double
>
ssim_per_frame
;
if
(
check_file_extension
(
video_file
)
)
{
compute_metrics
(
video_file
&
psnr_per_frame
&
ssim_per_frame
)
;
}
else
{
return
-
1
;
}
printf
(
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
\
n
"
)
;
printf
(
"
Printing
metrics
for
file
:
%
s
\
n
"
video_file
.
c_str
(
)
)
;
printf
(
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
\
n
"
)
;
print_freezing_metrics
(
psnr_per_frame
ssim_per_frame
)
;
return
0
;
}
