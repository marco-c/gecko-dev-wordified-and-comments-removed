#
include
<
vector
>
#
include
"
webrtc
/
base
/
bitbuffer
.
h
"
#
include
"
webrtc
/
base
/
buffer
.
h
"
#
include
"
webrtc
/
base
/
fileutils
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
pathutils
.
h
"
#
include
"
webrtc
/
common_video
/
h264
/
h264_common
.
h
"
#
include
"
webrtc
/
common_video
/
h264
/
sps_vui_rewriter
.
h
"
#
include
"
webrtc
/
test
/
gtest
.
h
"
namespace
webrtc
{
enum
SpsMode
{
kNoRewriteRequired_PocCorrect
kNoRewriteRequired_VuiOptimal
kRewriteRequired_NoVui
kRewriteRequired_NoBitstreamRestriction
kRewriteRequired_VuiSuboptimal
}
;
static
const
size_t
kSpsBufferMaxSize
=
256
;
static
const
size_t
kWidth
=
640
;
static
const
size_t
kHeight
=
480
;
void
GenerateFakeSps
(
SpsMode
mode
rtc
:
:
Buffer
*
out_buffer
)
{
uint8_t
rbsp
[
kSpsBufferMaxSize
]
=
{
0
}
;
rtc
:
:
BitBufferWriter
writer
(
rbsp
kSpsBufferMaxSize
)
;
writer
.
WriteUInt8
(
0
)
;
writer
.
WriteUInt8
(
0
)
;
writer
.
WriteUInt8
(
3
)
;
writer
.
WriteExponentialGolomb
(
0
)
;
writer
.
WriteExponentialGolomb
(
0
)
;
if
(
mode
=
=
kNoRewriteRequired_PocCorrect
)
{
writer
.
WriteExponentialGolomb
(
2
)
;
}
else
{
writer
.
WriteExponentialGolomb
(
0
)
;
writer
.
WriteExponentialGolomb
(
0
)
;
}
writer
.
WriteExponentialGolomb
(
1
)
;
writer
.
WriteBits
(
0
1
)
;
uint16_t
width_in_mbs_minus1
=
(
kWidth
+
15
)
/
16
-
1
;
uint16_t
height_in_map_units_minus1
=
(
(
kHeight
+
15
)
/
16
-
1
)
/
2
;
writer
.
WriteExponentialGolomb
(
width_in_mbs_minus1
)
;
writer
.
WriteExponentialGolomb
(
height_in_map_units_minus1
)
;
writer
.
WriteBits
(
0
1
)
;
writer
.
WriteBits
(
0
1
)
;
writer
.
WriteBits
(
0
1
)
;
writer
.
WriteBits
(
1
1
)
;
writer
.
WriteExponentialGolomb
(
(
(
16
-
(
kWidth
%
16
)
)
%
16
)
/
2
)
;
writer
.
WriteExponentialGolomb
(
0
)
;
writer
.
WriteExponentialGolomb
(
(
(
16
-
(
kHeight
%
16
)
)
%
16
)
/
2
)
;
writer
.
WriteExponentialGolomb
(
0
)
;
if
(
mode
=
=
kNoRewriteRequired_PocCorrect
|
|
mode
=
=
kRewriteRequired_NoVui
)
{
writer
.
WriteBits
(
0
1
)
;
}
else
{
writer
.
WriteBits
(
1
1
)
;
writer
.
WriteBits
(
0
8
)
;
if
(
mode
=
=
kRewriteRequired_NoBitstreamRestriction
)
{
writer
.
WriteBits
(
0
1
)
;
}
else
{
writer
.
WriteBits
(
1
1
)
;
writer
.
WriteBits
(
1
1
)
;
writer
.
WriteExponentialGolomb
(
2
)
;
writer
.
WriteExponentialGolomb
(
1
)
;
writer
.
WriteExponentialGolomb
(
16
)
;
writer
.
WriteExponentialGolomb
(
16
)
;
if
(
mode
=
=
kRewriteRequired_VuiSuboptimal
)
{
writer
.
WriteExponentialGolomb
(
4
)
;
writer
.
WriteExponentialGolomb
(
4
)
;
}
else
if
(
kNoRewriteRequired_VuiOptimal
)
{
writer
.
WriteExponentialGolomb
(
0
)
;
writer
.
WriteExponentialGolomb
(
1
)
;
}
}
}
size_t
byte_count
bit_offset
;
writer
.
GetCurrentOffset
(
&
byte_count
&
bit_offset
)
;
if
(
bit_offset
>
0
)
{
byte_count
+
+
;
}
uint8_t
header
[
]
=
{
0
0
0
1
7
}
;
out_buffer
-
>
AppendData
(
header
sizeof
(
header
)
)
;
H264
:
:
WriteRbsp
(
rbsp
byte_count
out_buffer
)
;
}
void
TestSps
(
SpsMode
mode
SpsVuiRewriter
:
:
ParseResult
expected_parse_result
)
{
rtc
:
:
LogMessage
:
:
LogToDebug
(
rtc
:
:
LS_VERBOSE
)
;
rtc
:
:
Buffer
buffer
;
GenerateFakeSps
(
mode
&
buffer
)
;
std
:
:
vector
<
H264
:
:
NaluIndex
>
start_offsets
=
H264
:
:
FindNaluIndices
(
buffer
.
data
(
)
buffer
.
size
(
)
)
;
EXPECT_EQ
(
1u
start_offsets
.
size
(
)
)
;
H264
:
:
NaluIndex
index
=
start_offsets
[
0
]
;
H264
:
:
NaluType
nal_type
=
H264
:
:
ParseNaluType
(
buffer
[
index
.
payload_start_offset
]
)
;
EXPECT_EQ
(
H264
:
:
kSps
nal_type
)
;
index
.
payload_start_offset
+
=
H264
:
:
kNaluTypeSize
;
index
.
payload_size
-
=
H264
:
:
kNaluTypeSize
;
rtc
:
:
Optional
<
SpsParser
:
:
SpsState
>
sps
;
rtc
:
:
Buffer
out_buffer
;
SpsVuiRewriter
:
:
ParseResult
result
=
SpsVuiRewriter
:
:
ParseAndRewriteSps
(
&
buffer
[
index
.
payload_start_offset
]
index
.
payload_size
&
sps
&
out_buffer
)
;
EXPECT_EQ
(
expected_parse_result
result
)
;
}
#
define
REWRITE_TEST
(
test_name
mode
expected_parse_result
)
\
TEST
(
SpsVuiRewriterTest
test_name
)
{
TestSps
(
mode
expected_parse_result
)
;
}
REWRITE_TEST
(
PocCorrect
kNoRewriteRequired_PocCorrect
SpsVuiRewriter
:
:
ParseResult
:
:
kPocOk
)
;
REWRITE_TEST
(
VuiAlreadyOptimal
kNoRewriteRequired_VuiOptimal
SpsVuiRewriter
:
:
ParseResult
:
:
kVuiOk
)
;
REWRITE_TEST
(
RewriteFullVui
kRewriteRequired_NoVui
SpsVuiRewriter
:
:
ParseResult
:
:
kVuiRewritten
)
;
REWRITE_TEST
(
AddBitstreamRestriction
kRewriteRequired_NoBitstreamRestriction
SpsVuiRewriter
:
:
ParseResult
:
:
kVuiRewritten
)
;
REWRITE_TEST
(
RewriteSuboptimalVui
kRewriteRequired_VuiSuboptimal
SpsVuiRewriter
:
:
ParseResult
:
:
kVuiRewritten
)
;
}
