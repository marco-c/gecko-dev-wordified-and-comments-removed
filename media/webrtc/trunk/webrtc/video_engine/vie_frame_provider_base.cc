#
include
"
webrtc
/
video_engine
/
vie_frame_provider_base
.
h
"
#
include
<
algorithm
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
common_video
/
interface
/
i420_video_frame
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
critical_section_wrapper
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
logging
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
tick_util
.
h
"
#
include
"
webrtc
/
video_engine
/
vie_defines
.
h
"
namespace
webrtc
{
ViEFrameProviderBase
:
:
ViEFrameProviderBase
(
int
Id
int
engine_id
)
:
id_
(
Id
)
engine_id_
(
engine_id
)
provider_cs_
(
CriticalSectionWrapper
:
:
CreateCriticalSection
(
)
)
frame_delay_
(
0
)
{
frame_delivery_thread_checker_
.
DetachFromThread
(
)
;
}
ViEFrameProviderBase
:
:
~
ViEFrameProviderBase
(
)
{
DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
for
(
ViEFrameCallback
*
callback
:
frame_callbacks_
)
{
LOG_F
(
LS_WARNING
)
<
<
"
FrameCallback
still
registered
.
"
;
callback
-
>
ProviderDestroyed
(
id_
)
;
}
}
int
ViEFrameProviderBase
:
:
Id
(
)
const
{
return
id_
;
}
void
ViEFrameProviderBase
:
:
DeliverFrame
(
I420VideoFrame
*
video_frame
const
std
:
:
vector
<
uint32_t
>
&
csrcs
)
{
DCHECK
(
frame_delivery_thread_checker_
.
CalledOnValidThread
(
)
)
;
#
ifdef
DEBUG_
const
TickTime
start_process_time
=
TickTime
:
:
Now
(
)
;
#
endif
CriticalSectionScoped
cs
(
provider_cs_
.
get
(
)
)
;
if
(
frame_callbacks_
.
size
(
)
=
=
1
)
{
frame_callbacks_
.
front
(
)
-
>
DeliverFrame
(
id_
video_frame
csrcs
)
;
}
else
{
for
(
ViEFrameCallback
*
callback
:
frame_callbacks_
)
{
if
(
video_frame
-
>
native_handle
(
)
!
=
NULL
)
{
callback
-
>
DeliverFrame
(
id_
video_frame
csrcs
)
;
}
else
{
if
(
!
extra_frame_
.
get
(
)
)
{
extra_frame_
.
reset
(
new
I420VideoFrame
(
)
)
;
}
extra_frame_
-
>
CopyFrame
(
*
video_frame
)
;
callback
-
>
DeliverFrame
(
id_
extra_frame_
.
get
(
)
csrcs
)
;
}
}
}
#
ifdef
DEBUG_
const
int
process_time
=
static_cast
<
int
>
(
(
TickTime
:
:
Now
(
)
-
start_process_time
)
.
Milliseconds
(
)
)
;
if
(
process_time
>
25
)
{
LOG
(
LS_WARNING
)
<
<
"
Too
long
time
delivering
frame
"
<
<
process_time
;
}
#
endif
}
void
ViEFrameProviderBase
:
:
SetFrameDelay
(
int
frame_delay
)
{
CriticalSectionScoped
cs
(
provider_cs_
.
get
(
)
)
;
frame_delay_
=
frame_delay
;
for
(
ViEFrameCallback
*
callback
:
frame_callbacks_
)
{
callback
-
>
DelayChanged
(
id_
frame_delay
)
;
}
}
int
ViEFrameProviderBase
:
:
FrameDelay
(
)
{
return
frame_delay_
;
}
int
ViEFrameProviderBase
:
:
GetBestFormat
(
int
*
best_width
int
*
best_height
int
*
best_frame_rate
)
{
DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
int
largest_width
=
0
;
int
largest_height
=
0
;
int
highest_frame_rate
=
0
;
for
(
ViEFrameCallback
*
callback
:
frame_callbacks_
)
{
int
prefered_width
=
0
;
int
prefered_height
=
0
;
int
prefered_frame_rate
=
0
;
if
(
callback
-
>
GetPreferedFrameSettings
(
&
prefered_width
&
prefered_height
&
prefered_frame_rate
)
=
=
0
)
{
if
(
prefered_width
>
largest_width
)
{
largest_width
=
prefered_width
;
}
if
(
prefered_height
>
largest_height
)
{
largest_height
=
prefered_height
;
}
if
(
prefered_frame_rate
>
highest_frame_rate
)
{
highest_frame_rate
=
prefered_frame_rate
;
}
}
}
*
best_width
=
largest_width
;
*
best_height
=
largest_height
;
*
best_frame_rate
=
highest_frame_rate
;
return
0
;
}
int
ViEFrameProviderBase
:
:
RegisterFrameCallback
(
int
observer_id
ViEFrameCallback
*
callback_object
)
{
DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
DCHECK
(
callback_object
)
;
{
CriticalSectionScoped
cs
(
provider_cs_
.
get
(
)
)
;
if
(
std
:
:
find
(
frame_callbacks_
.
begin
(
)
frame_callbacks_
.
end
(
)
callback_object
)
!
=
frame_callbacks_
.
end
(
)
)
{
DCHECK
(
false
&
&
"
frameObserver
already
registered
"
)
;
return
-
1
;
}
frame_callbacks_
.
push_back
(
callback_object
)
;
}
callback_object
-
>
DelayChanged
(
id_
frame_delay_
)
;
FrameCallbackChanged
(
)
;
return
0
;
}
int
ViEFrameProviderBase
:
:
DeregisterFrameCallback
(
const
ViEFrameCallback
*
callback_object
)
{
DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
DCHECK
(
callback_object
)
;
{
CriticalSectionScoped
cs
(
provider_cs_
.
get
(
)
)
;
FrameCallbacks
:
:
iterator
it
=
std
:
:
find
(
frame_callbacks_
.
begin
(
)
frame_callbacks_
.
end
(
)
callback_object
)
;
if
(
it
=
=
frame_callbacks_
.
end
(
)
)
{
return
-
1
;
}
frame_callbacks_
.
erase
(
it
)
;
}
FrameCallbackChanged
(
)
;
return
0
;
}
bool
ViEFrameProviderBase
:
:
IsFrameCallbackRegistered
(
const
ViEFrameCallback
*
callback_object
)
{
DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
DCHECK
(
callback_object
)
;
return
std
:
:
find
(
frame_callbacks_
.
begin
(
)
frame_callbacks_
.
end
(
)
callback_object
)
!
=
frame_callbacks_
.
end
(
)
;
}
}
