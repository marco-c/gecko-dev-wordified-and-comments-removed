#
include
"
webrtc
/
sound
/
alsasoundsystem
.
h
"
#
include
<
algorithm
>
#
include
<
string
>
#
include
"
webrtc
/
base
/
arraysize
.
h
"
#
include
"
webrtc
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
stringutils
.
h
"
#
include
"
webrtc
/
base
/
timeutils
.
h
"
#
include
"
webrtc
/
base
/
worker
.
h
"
#
include
"
webrtc
/
sound
/
sounddevicelocator
.
h
"
#
include
"
webrtc
/
sound
/
soundinputstreaminterface
.
h
"
#
include
"
webrtc
/
sound
/
soundoutputstreaminterface
.
h
"
namespace
rtc
{
static
const
snd_pcm_format_t
kCricketFormatToAlsaFormatTable
[
]
=
{
SND_PCM_FORMAT_S16_LE
}
;
static
const
size_t
kCricketFormatToSampleSizeTable
[
]
=
{
sizeof
(
int16_t
)
}
;
static
const
int
kMinimumLatencyUsecs
=
20
*
1000
;
static
const
int
kDefaultLatencyUsecs
=
kMinimumLatencyUsecs
*
2
;
static
const
char
kAlsaDescriptionSearch
[
]
=
"
\
n
"
;
static
const
char
kAlsaDescriptionReplace
[
]
=
"
-
"
;
class
AlsaDeviceLocator
:
public
SoundDeviceLocator
{
public
:
AlsaDeviceLocator
(
const
std
:
:
string
&
name
const
std
:
:
string
&
device_name
)
:
SoundDeviceLocator
(
name
device_name
)
{
rtc
:
:
replace_substrs
(
kAlsaDescriptionSearch
sizeof
(
kAlsaDescriptionSearch
)
-
1
kAlsaDescriptionReplace
sizeof
(
kAlsaDescriptionReplace
)
-
1
&
name_
)
;
}
SoundDeviceLocator
*
Copy
(
)
const
override
{
return
new
AlsaDeviceLocator
(
*
this
)
;
}
}
;
class
AlsaStream
{
public
:
AlsaStream
(
AlsaSoundSystem
*
alsa
snd_pcm_t
*
handle
size_t
frame_size
int
wait_timeout_ms
int
flags
int
freq
)
:
alsa_
(
alsa
)
handle_
(
handle
)
frame_size_
(
frame_size
)
wait_timeout_ms_
(
wait_timeout_ms
)
flags_
(
flags
)
freq_
(
freq
)
{
}
~
AlsaStream
(
)
{
Close
(
)
;
}
snd_pcm_uframes_t
Wait
(
)
{
snd_pcm_sframes_t
frames
;
frames
=
symbol_table
(
)
-
>
snd_pcm_avail_update
(
)
(
handle_
)
;
if
(
frames
<
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_avail_update
(
)
:
"
<
<
GetError
(
frames
)
;
Recover
(
frames
)
;
return
0
;
}
else
if
(
frames
>
0
)
{
return
frames
;
}
int
ready
=
symbol_table
(
)
-
>
snd_pcm_wait
(
)
(
handle_
wait_timeout_ms_
)
;
if
(
ready
<
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_wait
(
)
:
"
<
<
GetError
(
ready
)
;
Recover
(
ready
)
;
return
0
;
}
else
if
(
ready
=
=
0
)
{
LOG
(
LS_WARNING
)
<
<
"
Timeout
while
waiting
on
stream
"
;
return
0
;
}
frames
=
symbol_table
(
)
-
>
snd_pcm_avail_update
(
)
(
handle_
)
;
if
(
frames
<
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_avail_update
(
)
:
"
<
<
GetError
(
frames
)
;
Recover
(
frames
)
;
return
0
;
}
else
if
(
frames
=
=
0
)
{
LOG
(
LS_WARNING
)
<
<
"
Spurious
wake
-
up
"
;
}
return
frames
;
}
int
CurrentDelayUsecs
(
)
{
if
(
!
(
flags_
&
SoundSystemInterface
:
:
FLAG_REPORT_LATENCY
)
)
{
return
0
;
}
snd_pcm_sframes_t
delay
;
int
err
=
symbol_table
(
)
-
>
snd_pcm_delay
(
)
(
handle_
&
delay
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_delay
(
)
:
"
<
<
GetError
(
err
)
;
Recover
(
err
)
;
return
0
;
}
return
delay
*
rtc
:
:
kNumMicrosecsPerSec
/
freq_
;
}
bool
Recover
(
int
error
)
{
int
err
;
err
=
symbol_table
(
)
-
>
snd_pcm_recover
(
)
(
handle_
error
1
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
Unable
to
recover
from
\
"
"
<
<
GetError
(
error
)
<
<
"
\
"
:
"
<
<
GetError
(
err
)
;
return
false
;
}
if
(
error
=
=
-
EPIPE
&
&
symbol_table
(
)
-
>
snd_pcm_stream
(
)
(
handle_
)
=
=
SND_PCM_STREAM_CAPTURE
)
{
err
=
symbol_table
(
)
-
>
snd_pcm_start
(
)
(
handle_
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_start
(
)
:
"
<
<
GetError
(
err
)
;
return
false
;
}
}
return
true
;
}
bool
Close
(
)
{
if
(
handle_
)
{
int
err
;
err
=
symbol_table
(
)
-
>
snd_pcm_drop
(
)
(
handle_
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_drop
(
)
:
"
<
<
GetError
(
err
)
;
}
err
=
symbol_table
(
)
-
>
snd_pcm_close
(
)
(
handle_
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_close
(
)
:
"
<
<
GetError
(
err
)
;
}
handle_
=
NULL
;
}
return
true
;
}
AlsaSymbolTable
*
symbol_table
(
)
{
return
&
alsa_
-
>
symbol_table_
;
}
snd_pcm_t
*
handle
(
)
{
return
handle_
;
}
const
char
*
GetError
(
int
err
)
{
return
alsa_
-
>
GetError
(
err
)
;
}
size_t
frame_size
(
)
{
return
frame_size_
;
}
private
:
AlsaSoundSystem
*
alsa_
;
snd_pcm_t
*
handle_
;
size_t
frame_size_
;
int
wait_timeout_ms_
;
int
flags_
;
int
freq_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AlsaStream
)
;
}
;
class
AlsaInputStream
:
public
SoundInputStreamInterface
private
rtc
:
:
Worker
{
public
:
AlsaInputStream
(
AlsaSoundSystem
*
alsa
snd_pcm_t
*
handle
size_t
frame_size
int
wait_timeout_ms
int
flags
int
freq
)
:
stream_
(
alsa
handle
frame_size
wait_timeout_ms
flags
freq
)
buffer_size_
(
0
)
{
}
~
AlsaInputStream
(
)
override
{
bool
success
=
StopReading
(
)
;
VERIFY
(
success
)
;
}
bool
StartReading
(
)
override
{
return
StartWork
(
)
;
}
bool
StopReading
(
)
override
{
return
StopWork
(
)
;
}
bool
GetVolume
(
int
*
volume
)
override
{
return
false
;
}
bool
SetVolume
(
int
volume
)
override
{
return
false
;
}
bool
Close
(
)
override
{
return
StopReading
(
)
&
&
stream_
.
Close
(
)
;
}
int
LatencyUsecs
(
)
override
{
return
stream_
.
CurrentDelayUsecs
(
)
;
}
private
:
void
OnStart
(
)
override
{
HaveWork
(
)
;
}
void
OnHaveWork
(
)
override
{
snd_pcm_uframes_t
avail
=
stream_
.
Wait
(
)
;
if
(
avail
>
0
)
{
size_t
size
=
avail
*
stream_
.
frame_size
(
)
;
if
(
size
>
buffer_size_
)
{
buffer_
.
reset
(
new
char
[
size
]
)
;
buffer_size_
=
size
;
}
snd_pcm_sframes_t
read
=
stream_
.
symbol_table
(
)
-
>
snd_pcm_readi
(
)
(
stream_
.
handle
(
)
buffer_
.
get
(
)
avail
)
;
if
(
read
<
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_readi
(
)
:
"
<
<
GetError
(
read
)
;
stream_
.
Recover
(
read
)
;
}
else
if
(
read
=
=
0
)
{
ASSERT
(
false
)
;
LOG
(
LS_ERROR
)
<
<
"
No
data
?
"
;
}
else
{
SignalSamplesRead
(
buffer_
.
get
(
)
read
*
stream_
.
frame_size
(
)
this
)
;
}
}
HaveWork
(
)
;
}
void
OnStop
(
)
override
{
}
const
char
*
GetError
(
int
err
)
{
return
stream_
.
GetError
(
err
)
;
}
AlsaStream
stream_
;
rtc
:
:
scoped_ptr
<
char
[
]
>
buffer_
;
size_t
buffer_size_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AlsaInputStream
)
;
}
;
class
AlsaOutputStream
:
public
SoundOutputStreamInterface
private
rtc
:
:
Worker
{
public
:
AlsaOutputStream
(
AlsaSoundSystem
*
alsa
snd_pcm_t
*
handle
size_t
frame_size
int
wait_timeout_ms
int
flags
int
freq
)
:
stream_
(
alsa
handle
frame_size
wait_timeout_ms
flags
freq
)
{
}
~
AlsaOutputStream
(
)
override
{
bool
success
=
DisableBufferMonitoring
(
)
;
VERIFY
(
success
)
;
}
bool
EnableBufferMonitoring
(
)
override
{
return
StartWork
(
)
;
}
bool
DisableBufferMonitoring
(
)
override
{
return
StopWork
(
)
;
}
bool
WriteSamples
(
const
void
*
sample_data
size_t
size
)
override
{
if
(
size
%
stream_
.
frame_size
(
)
!
=
0
)
{
ASSERT
(
false
)
;
LOG
(
LS_ERROR
)
<
<
"
Writes
with
fractional
frames
are
not
supported
"
;
return
false
;
}
snd_pcm_uframes_t
frames
=
size
/
stream_
.
frame_size
(
)
;
snd_pcm_sframes_t
written
=
stream_
.
symbol_table
(
)
-
>
snd_pcm_writei
(
)
(
stream_
.
handle
(
)
sample_data
frames
)
;
if
(
written
<
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_writei
(
)
:
"
<
<
GetError
(
written
)
;
stream_
.
Recover
(
written
)
;
return
false
;
}
else
if
(
static_cast
<
snd_pcm_uframes_t
>
(
written
)
<
frames
)
{
LOG
(
LS_ERROR
)
<
<
"
Stream
wrote
only
"
<
<
written
<
<
"
of
"
<
<
frames
<
<
"
frames
!
"
;
return
false
;
}
return
true
;
}
bool
GetVolume
(
int
*
volume
)
override
{
return
false
;
}
bool
SetVolume
(
int
volume
)
override
{
return
false
;
}
bool
Close
(
)
override
{
return
DisableBufferMonitoring
(
)
&
&
stream_
.
Close
(
)
;
}
int
LatencyUsecs
(
)
override
{
return
stream_
.
CurrentDelayUsecs
(
)
;
}
private
:
void
OnStart
(
)
override
{
HaveWork
(
)
;
}
void
OnHaveWork
(
)
override
{
snd_pcm_uframes_t
avail
=
stream_
.
Wait
(
)
;
if
(
avail
>
0
)
{
size_t
space
=
avail
*
stream_
.
frame_size
(
)
;
SignalBufferSpace
(
space
this
)
;
}
HaveWork
(
)
;
}
void
OnStop
(
)
override
{
}
const
char
*
GetError
(
int
err
)
{
return
stream_
.
GetError
(
err
)
;
}
AlsaStream
stream_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
AlsaOutputStream
)
;
}
;
AlsaSoundSystem
:
:
AlsaSoundSystem
(
)
:
initialized_
(
false
)
{
}
AlsaSoundSystem
:
:
~
AlsaSoundSystem
(
)
{
Terminate
(
)
;
}
bool
AlsaSoundSystem
:
:
Init
(
)
{
if
(
IsInitialized
(
)
)
{
return
true
;
}
if
(
!
symbol_table_
.
Load
(
)
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
load
symbol
table
"
;
return
false
;
}
initialized_
=
true
;
return
true
;
}
void
AlsaSoundSystem
:
:
Terminate
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
;
}
initialized_
=
false
;
}
bool
AlsaSoundSystem
:
:
EnumeratePlaybackDevices
(
SoundDeviceLocatorList
*
devices
)
{
return
EnumerateDevices
(
devices
false
)
;
}
bool
AlsaSoundSystem
:
:
EnumerateCaptureDevices
(
SoundDeviceLocatorList
*
devices
)
{
return
EnumerateDevices
(
devices
true
)
;
}
bool
AlsaSoundSystem
:
:
GetDefaultPlaybackDevice
(
SoundDeviceLocator
*
*
device
)
{
return
GetDefaultDevice
(
device
)
;
}
bool
AlsaSoundSystem
:
:
GetDefaultCaptureDevice
(
SoundDeviceLocator
*
*
device
)
{
return
GetDefaultDevice
(
device
)
;
}
SoundOutputStreamInterface
*
AlsaSoundSystem
:
:
OpenPlaybackDevice
(
const
SoundDeviceLocator
*
device
const
OpenParams
&
params
)
{
return
OpenDevice
<
SoundOutputStreamInterface
>
(
device
params
SND_PCM_STREAM_PLAYBACK
&
AlsaSoundSystem
:
:
StartOutputStream
)
;
}
SoundInputStreamInterface
*
AlsaSoundSystem
:
:
OpenCaptureDevice
(
const
SoundDeviceLocator
*
device
const
OpenParams
&
params
)
{
return
OpenDevice
<
SoundInputStreamInterface
>
(
device
params
SND_PCM_STREAM_CAPTURE
&
AlsaSoundSystem
:
:
StartInputStream
)
;
}
const
char
*
AlsaSoundSystem
:
:
GetName
(
)
const
{
return
"
ALSA
"
;
}
bool
AlsaSoundSystem
:
:
EnumerateDevices
(
SoundDeviceLocatorList
*
devices
bool
capture_not_playback
)
{
ClearSoundDeviceLocatorList
(
devices
)
;
if
(
!
IsInitialized
(
)
)
{
return
false
;
}
const
char
*
type
=
capture_not_playback
?
"
Input
"
:
"
Output
"
;
const
char
*
ignore_prefix
=
capture_not_playback
?
"
dmix
:
"
:
"
dsnoop
:
"
;
const
char
*
ignore_default
=
"
default
"
;
const
char
*
ignore_null
=
"
null
"
;
const
char
*
ignore_pulse
=
"
pulse
"
;
int
err
;
void
*
*
hints
;
err
=
symbol_table_
.
snd_device_name_hint
(
)
(
-
1
"
pcm
"
&
hints
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_device_name_hint
(
)
:
"
<
<
GetError
(
err
)
;
return
false
;
}
for
(
void
*
*
list
=
hints
;
*
list
!
=
NULL
;
+
+
list
)
{
char
*
actual_type
=
symbol_table_
.
snd_device_name_get_hint
(
)
(
*
list
"
IOID
"
)
;
if
(
actual_type
)
{
bool
wrong_type
=
(
strcmp
(
actual_type
type
)
!
=
0
)
;
free
(
actual_type
)
;
if
(
wrong_type
)
{
continue
;
}
}
char
*
name
=
symbol_table_
.
snd_device_name_get_hint
(
)
(
*
list
"
NAME
"
)
;
if
(
!
name
)
{
LOG
(
LS_ERROR
)
<
<
"
Device
has
no
name
?
?
?
"
;
continue
;
}
if
(
strcmp
(
name
ignore_default
)
!
=
0
&
&
strcmp
(
name
ignore_null
)
!
=
0
&
&
strcmp
(
name
ignore_pulse
)
!
=
0
&
&
!
rtc
:
:
starts_with
(
name
ignore_prefix
)
)
{
char
*
desc
=
symbol_table_
.
snd_device_name_get_hint
(
)
(
*
list
"
DESC
"
)
;
if
(
!
desc
)
{
desc
=
name
;
}
AlsaDeviceLocator
*
device
=
new
AlsaDeviceLocator
(
desc
name
)
;
devices
-
>
push_back
(
device
)
;
if
(
desc
!
=
name
)
{
free
(
desc
)
;
}
}
free
(
name
)
;
}
err
=
symbol_table_
.
snd_device_name_free_hint
(
)
(
hints
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_device_name_free_hint
(
)
:
"
<
<
GetError
(
err
)
;
}
return
true
;
}
bool
AlsaSoundSystem
:
:
GetDefaultDevice
(
SoundDeviceLocator
*
*
device
)
{
if
(
!
IsInitialized
(
)
)
{
return
false
;
}
*
device
=
new
AlsaDeviceLocator
(
"
Default
device
"
"
default
"
)
;
return
true
;
}
inline
size_t
AlsaSoundSystem
:
:
FrameSize
(
const
OpenParams
&
params
)
{
return
kCricketFormatToSampleSizeTable
[
params
.
format
]
*
params
.
channels
;
}
template
<
typename
StreamInterface
>
StreamInterface
*
AlsaSoundSystem
:
:
OpenDevice
(
const
SoundDeviceLocator
*
device
const
OpenParams
&
params
snd_pcm_stream_t
type
StreamInterface
*
(
AlsaSoundSystem
:
:
*
start_fn
)
(
snd_pcm_t
*
handle
size_t
frame_size
int
wait_timeout_ms
int
flags
int
freq
)
)
{
if
(
!
IsInitialized
(
)
)
{
return
NULL
;
}
StreamInterface
*
stream
;
int
err
;
const
char
*
dev
=
static_cast
<
const
AlsaDeviceLocator
*
>
(
device
)
-
>
device_name
(
)
.
c_str
(
)
;
snd_pcm_t
*
handle
=
NULL
;
err
=
symbol_table_
.
snd_pcm_open
(
)
(
&
handle
dev
type
0
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_open
(
"
<
<
dev
<
<
"
)
:
"
<
<
GetError
(
err
)
;
return
NULL
;
}
LOG
(
LS_VERBOSE
)
<
<
"
Opening
"
<
<
dev
;
ASSERT
(
handle
)
;
int
latency
;
if
(
params
.
latency
=
=
kNoLatencyRequirements
)
{
latency
=
kDefaultLatencyUsecs
;
}
else
{
latency
=
rtc
:
:
kNumMicrosecsPerSec
*
params
.
latency
/
params
.
freq
/
FrameSize
(
params
)
;
latency
=
std
:
:
max
(
latency
kMinimumLatencyUsecs
)
;
}
ASSERT
(
params
.
format
<
arraysize
(
kCricketFormatToAlsaFormatTable
)
)
;
err
=
symbol_table_
.
snd_pcm_set_params
(
)
(
handle
kCricketFormatToAlsaFormatTable
[
params
.
format
]
SND_PCM_ACCESS_RW_INTERLEAVED
params
.
channels
params
.
freq
1
latency
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_set_params
(
)
:
"
<
<
GetError
(
err
)
;
goto
fail
;
}
err
=
symbol_table_
.
snd_pcm_prepare
(
)
(
handle
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_prepare
(
)
:
"
<
<
GetError
(
err
)
;
goto
fail
;
}
stream
=
(
this
-
>
*
start_fn
)
(
handle
FrameSize
(
params
)
2
*
latency
/
rtc
:
:
kNumMicrosecsPerMillisec
params
.
flags
params
.
freq
)
;
if
(
stream
)
{
return
stream
;
}
fail
:
err
=
symbol_table_
.
snd_pcm_close
(
)
(
handle
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_close
(
)
:
"
<
<
GetError
(
err
)
;
}
return
NULL
;
}
SoundOutputStreamInterface
*
AlsaSoundSystem
:
:
StartOutputStream
(
snd_pcm_t
*
handle
size_t
frame_size
int
wait_timeout_ms
int
flags
int
freq
)
{
return
new
AlsaOutputStream
(
this
handle
frame_size
wait_timeout_ms
flags
freq
)
;
}
SoundInputStreamInterface
*
AlsaSoundSystem
:
:
StartInputStream
(
snd_pcm_t
*
handle
size_t
frame_size
int
wait_timeout_ms
int
flags
int
freq
)
{
int
err
;
err
=
symbol_table_
.
snd_pcm_start
(
)
(
handle
)
;
if
(
err
!
=
0
)
{
LOG
(
LS_ERROR
)
<
<
"
snd_pcm_start
(
)
:
"
<
<
GetError
(
err
)
;
return
NULL
;
}
return
new
AlsaInputStream
(
this
handle
frame_size
wait_timeout_ms
flags
freq
)
;
}
inline
const
char
*
AlsaSoundSystem
:
:
GetError
(
int
err
)
{
return
symbol_table_
.
snd_strerror
(
)
(
err
)
;
}
}
