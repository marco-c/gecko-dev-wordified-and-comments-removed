#
include
<
algorithm
>
#
include
<
memory
>
#
include
"
webrtc
/
api
/
fakemetricsobserver
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
fakeportallocator
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
packettransportinterface
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
p2ptransportchannel
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
testrelayserver
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
teststunserver
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
testturnserver
.
h
"
#
include
"
webrtc
/
p2p
/
client
/
basicportallocator
.
h
"
#
include
"
webrtc
/
base
/
dscp
.
h
"
#
include
"
webrtc
/
base
/
fakeclock
.
h
"
#
include
"
webrtc
/
base
/
fakenetwork
.
h
"
#
include
"
webrtc
/
base
/
firewallsocketserver
.
h
"
#
include
"
webrtc
/
base
/
gunit
.
h
"
#
include
"
webrtc
/
base
/
helpers
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
natserver
.
h
"
#
include
"
webrtc
/
base
/
natsocketfactory
.
h
"
#
include
"
webrtc
/
base
/
physicalsocketserver
.
h
"
#
include
"
webrtc
/
base
/
proxyserver
.
h
"
#
include
"
webrtc
/
base
/
socketaddress
.
h
"
#
include
"
webrtc
/
base
/
ssladapter
.
h
"
#
include
"
webrtc
/
base
/
thread
.
h
"
#
include
"
webrtc
/
base
/
virtualsocketserver
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
icetransportinternal
.
h
"
namespace
{
using
rtc
:
:
SocketAddress
;
static
const
int
kDefaultTimeout
=
10000
;
static
const
int
kMediumTimeout
=
3000
;
static
const
int
kShortTimeout
=
1000
;
static
const
int
kOnlyLocalPorts
=
cricket
:
:
PORTALLOCATOR_DISABLE_STUN
|
cricket
:
:
PORTALLOCATOR_DISABLE_RELAY
|
cricket
:
:
PORTALLOCATOR_DISABLE_TCP
;
static
const
int
LOW_RTT
=
20
;
static
const
SocketAddress
kPublicAddrs
[
2
]
=
{
SocketAddress
(
"
11
.
11
.
11
.
11
"
0
)
SocketAddress
(
"
22
.
22
.
22
.
22
"
0
)
}
;
static
const
SocketAddress
kIPv6PublicAddrs
[
2
]
=
{
SocketAddress
(
"
2400
:
4030
:
1
:
2c00
:
be30
:
abcd
:
efab
:
cdef
"
0
)
SocketAddress
(
"
2600
:
0
:
1000
:
1b03
:
2e41
:
38ff
:
fea6
:
f2a4
"
0
)
}
;
static
const
SocketAddress
kAlternateAddrs
[
2
]
=
{
SocketAddress
(
"
101
.
101
.
101
.
101
"
0
)
SocketAddress
(
"
202
.
202
.
202
.
202
"
0
)
}
;
static
const
SocketAddress
kIPv6AlternateAddrs
[
2
]
=
{
SocketAddress
(
"
2401
:
4030
:
1
:
2c00
:
be30
:
abcd
:
efab
:
cdef
"
0
)
SocketAddress
(
"
2601
:
0
:
1000
:
1b03
:
2e41
:
38ff
:
fea6
:
f2a4
"
0
)
}
;
static
const
SocketAddress
kHttpsProxyAddrs
[
2
]
=
{
SocketAddress
(
"
11
.
11
.
11
.
1
"
443
)
SocketAddress
(
"
22
.
22
.
22
.
1
"
443
)
}
;
static
const
SocketAddress
kSocksProxyAddrs
[
2
]
=
{
SocketAddress
(
"
11
.
11
.
11
.
1
"
1080
)
SocketAddress
(
"
22
.
22
.
22
.
1
"
1080
)
}
;
static
const
SocketAddress
kNatAddrs
[
2
]
=
{
SocketAddress
(
"
192
.
168
.
1
.
1
"
0
)
SocketAddress
(
"
192
.
168
.
2
.
1
"
0
)
}
;
static
const
SocketAddress
kPrivateAddrs
[
2
]
=
{
SocketAddress
(
"
192
.
168
.
1
.
11
"
0
)
SocketAddress
(
"
192
.
168
.
2
.
22
"
0
)
}
;
static
const
SocketAddress
kCascadedNatAddrs
[
2
]
=
{
SocketAddress
(
"
192
.
168
.
10
.
1
"
0
)
SocketAddress
(
"
192
.
168
.
20
.
1
"
0
)
}
;
static
const
SocketAddress
kCascadedPrivateAddrs
[
2
]
=
{
SocketAddress
(
"
192
.
168
.
10
.
11
"
0
)
SocketAddress
(
"
192
.
168
.
20
.
22
"
0
)
}
;
static
const
SocketAddress
kStunAddr
(
"
99
.
99
.
99
.
1
"
cricket
:
:
STUN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnUdpIntAddr
(
"
99
.
99
.
99
.
3
"
cricket
:
:
STUN_SERVER_PORT
)
;
static
const
SocketAddress
kTurnTcpIntAddr
(
"
99
.
99
.
99
.
4
"
cricket
:
:
STUN_SERVER_PORT
+
1
)
;
static
const
SocketAddress
kTurnUdpExtAddr
(
"
99
.
99
.
99
.
5
"
0
)
;
static
const
cricket
:
:
RelayCredentials
kRelayCredentials
(
"
test
"
"
test
"
)
;
const
char
*
kIceUfrag
[
4
]
=
{
"
UF00
"
"
UF01
"
"
UF02
"
"
UF03
"
}
;
const
char
*
kIcePwd
[
4
]
=
{
"
TESTICEPWD00000000000000
"
"
TESTICEPWD00000000000001
"
"
TESTICEPWD00000000000002
"
"
TESTICEPWD00000000000003
"
}
;
const
cricket
:
:
IceParameters
kIceParams
[
4
]
=
{
{
kIceUfrag
[
0
]
kIcePwd
[
0
]
false
}
{
kIceUfrag
[
1
]
kIcePwd
[
1
]
false
}
{
kIceUfrag
[
2
]
kIcePwd
[
2
]
false
}
{
kIceUfrag
[
3
]
kIcePwd
[
3
]
false
}
}
;
const
uint64_t
kLowTiebreaker
=
11111
;
const
uint64_t
kHighTiebreaker
=
22222
;
enum
{
MSG_ADD_CANDIDATES
MSG_REMOVE_CANDIDATES
}
;
cricket
:
:
IceConfig
CreateIceConfig
(
int
receiving_timeout
cricket
:
:
ContinualGatheringPolicy
continual_gathering_policy
int
backup_ping_interval
=
-
1
)
{
cricket
:
:
IceConfig
config
;
config
.
receiving_timeout
=
receiving_timeout
;
config
.
continual_gathering_policy
=
continual_gathering_policy
;
config
.
backup_connection_ping_interval
=
backup_ping_interval
;
return
config
;
}
cricket
:
:
Candidate
CreateUdpCandidate
(
const
std
:
:
string
&
type
const
std
:
:
string
&
ip
int
port
int
priority
const
std
:
:
string
&
ufrag
=
"
"
)
{
cricket
:
:
Candidate
c
;
c
.
set_address
(
rtc
:
:
SocketAddress
(
ip
port
)
)
;
c
.
set_component
(
cricket
:
:
ICE_CANDIDATE_COMPONENT_DEFAULT
)
;
c
.
set_protocol
(
cricket
:
:
UDP_PROTOCOL_NAME
)
;
c
.
set_priority
(
priority
)
;
c
.
set_username
(
ufrag
)
;
c
.
set_type
(
type
)
;
return
c
;
}
cricket
:
:
BasicPortAllocator
*
CreateBasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
const
cricket
:
:
ServerAddresses
&
stun_servers
const
rtc
:
:
SocketAddress
&
turn_server_udp
const
rtc
:
:
SocketAddress
&
turn_server_tcp
)
{
cricket
:
:
RelayServerConfig
turn_server
(
cricket
:
:
RELAY_TURN
)
;
turn_server
.
credentials
=
kRelayCredentials
;
if
(
!
turn_server_udp
.
IsNil
(
)
)
{
turn_server
.
ports
.
push_back
(
cricket
:
:
ProtocolAddress
(
turn_server_udp
cricket
:
:
PROTO_UDP
)
)
;
}
if
(
!
turn_server_tcp
.
IsNil
(
)
)
{
turn_server
.
ports
.
push_back
(
cricket
:
:
ProtocolAddress
(
turn_server_tcp
cricket
:
:
PROTO_TCP
)
)
;
}
std
:
:
vector
<
cricket
:
:
RelayServerConfig
>
turn_servers
(
1
turn_server
)
;
cricket
:
:
BasicPortAllocator
*
allocator
=
new
cricket
:
:
BasicPortAllocator
(
network_manager
)
;
allocator
-
>
SetConfiguration
(
stun_servers
turn_servers
0
false
)
;
return
allocator
;
}
}
namespace
cricket
{
class
P2PTransportChannelTestBase
:
public
testing
:
:
Test
public
rtc
:
:
MessageHandler
public
sigslot
:
:
has_slots
<
>
{
public
:
P2PTransportChannelTestBase
(
)
:
main_
(
rtc
:
:
Thread
:
:
Current
(
)
)
pss_
(
new
rtc
:
:
PhysicalSocketServer
)
vss_
(
new
rtc
:
:
VirtualSocketServer
(
pss_
.
get
(
)
)
)
nss_
(
new
rtc
:
:
NATSocketServer
(
vss_
.
get
(
)
)
)
ss_
(
new
rtc
:
:
FirewallSocketServer
(
nss_
.
get
(
)
)
)
ss_scope_
(
ss_
.
get
(
)
)
stun_server_
(
TestStunServer
:
:
Create
(
main_
kStunAddr
)
)
turn_server_
(
main_
kTurnUdpIntAddr
kTurnUdpExtAddr
)
socks_server1_
(
ss_
.
get
(
)
kSocksProxyAddrs
[
0
]
ss_
.
get
(
)
kSocksProxyAddrs
[
0
]
)
socks_server2_
(
ss_
.
get
(
)
kSocksProxyAddrs
[
1
]
ss_
.
get
(
)
kSocksProxyAddrs
[
1
]
)
force_relay_
(
false
)
{
ep1_
.
role_
=
ICEROLE_CONTROLLING
;
ep2_
.
role_
=
ICEROLE_CONTROLLED
;
ServerAddresses
stun_servers
;
stun_servers
.
insert
(
kStunAddr
)
;
ep1_
.
allocator_
.
reset
(
CreateBasicPortAllocator
(
&
ep1_
.
network_manager_
stun_servers
kTurnUdpIntAddr
rtc
:
:
SocketAddress
(
)
)
)
;
ep1_
.
metrics_observer_
=
new
rtc
:
:
RefCountedObject
<
webrtc
:
:
FakeMetricsObserver
>
(
)
;
ep1_
.
allocator_
-
>
SetMetricsObserver
(
ep1_
.
metrics_observer_
)
;
ep2_
.
allocator_
.
reset
(
CreateBasicPortAllocator
(
&
ep2_
.
network_manager_
stun_servers
kTurnUdpIntAddr
rtc
:
:
SocketAddress
(
)
)
)
;
ep2_
.
metrics_observer_
=
new
rtc
:
:
RefCountedObject
<
webrtc
:
:
FakeMetricsObserver
>
(
)
;
ep2_
.
allocator_
-
>
SetMetricsObserver
(
ep2_
.
metrics_observer_
)
;
}
protected
:
enum
Config
{
OPEN
NAT_FULL_CONE
NAT_ADDR_RESTRICTED
NAT_PORT_RESTRICTED
NAT_SYMMETRIC
NAT_DOUBLE_CONE
NAT_SYMMETRIC_THEN_CONE
BLOCK_UDP
BLOCK_UDP_AND_INCOMING_TCP
BLOCK_ALL_BUT_OUTGOING_HTTP
PROXY_HTTPS
PROXY_SOCKS
NUM_CONFIGS
}
;
struct
Result
{
Result
(
const
std
:
:
string
&
controlling_type
const
std
:
:
string
&
controlling_protocol
const
std
:
:
string
&
controlled_type
const
std
:
:
string
&
controlled_protocol
int
wait
)
:
controlling_type
(
controlling_type
)
controlling_protocol
(
controlling_protocol
)
controlled_type
(
controlled_type
)
controlled_protocol
(
controlled_protocol
)
connect_wait
(
wait
)
{
}
std
:
:
string
controlling_type
;
std
:
:
string
controlling_protocol
;
std
:
:
string
controlled_type
;
std
:
:
string
controlled_protocol
;
int
connect_wait
;
}
;
struct
ChannelData
{
bool
CheckData
(
const
char
*
data
int
len
)
{
bool
ret
=
false
;
if
(
!
ch_packets_
.
empty
(
)
)
{
std
:
:
string
packet
=
ch_packets_
.
front
(
)
;
ret
=
(
packet
=
=
std
:
:
string
(
data
len
)
)
;
ch_packets_
.
pop_front
(
)
;
}
return
ret
;
}
std
:
:
string
name_
;
std
:
:
list
<
std
:
:
string
>
ch_packets_
;
std
:
:
unique_ptr
<
P2PTransportChannel
>
ch_
;
}
;
struct
CandidatesData
:
public
rtc
:
:
MessageData
{
CandidatesData
(
IceTransportInternal
*
ch
const
Candidate
&
c
)
:
channel
(
ch
)
candidates
(
1
c
)
{
}
CandidatesData
(
IceTransportInternal
*
ch
const
std
:
:
vector
<
Candidate
>
&
cc
)
:
channel
(
ch
)
candidates
(
cc
)
{
}
IceTransportInternal
*
channel
;
Candidates
candidates
;
}
;
struct
Endpoint
{
Endpoint
(
)
:
role_
(
ICEROLE_UNKNOWN
)
tiebreaker_
(
0
)
role_conflict_
(
false
)
save_candidates_
(
false
)
{
}
bool
HasTransport
(
const
rtc
:
:
PacketTransportInterface
*
transport
)
{
return
(
transport
=
=
cd1_
.
ch_
.
get
(
)
|
|
transport
=
=
cd2_
.
ch_
.
get
(
)
)
;
}
ChannelData
*
GetChannelData
(
rtc
:
:
PacketTransportInterface
*
transport
)
{
if
(
!
HasTransport
(
transport
)
)
return
NULL
;
if
(
cd1_
.
ch_
.
get
(
)
=
=
transport
)
return
&
cd1_
;
else
return
&
cd2_
;
}
void
SetIceRole
(
IceRole
role
)
{
role_
=
role
;
}
IceRole
ice_role
(
)
{
return
role_
;
}
void
SetIceTiebreaker
(
uint64_t
tiebreaker
)
{
tiebreaker_
=
tiebreaker
;
}
uint64_t
GetIceTiebreaker
(
)
{
return
tiebreaker_
;
}
void
OnRoleConflict
(
bool
role_conflict
)
{
role_conflict_
=
role_conflict
;
}
bool
role_conflict
(
)
{
return
role_conflict_
;
}
void
SetAllocationStepDelay
(
uint32_t
delay
)
{
allocator_
-
>
set_step_delay
(
delay
)
;
}
void
SetAllowTcpListen
(
bool
allow_tcp_listen
)
{
allocator_
-
>
set_allow_tcp_listen
(
allow_tcp_listen
)
;
}
rtc
:
:
FakeNetworkManager
network_manager_
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
FakeMetricsObserver
>
metrics_observer_
;
std
:
:
unique_ptr
<
BasicPortAllocator
>
allocator_
;
ChannelData
cd1_
;
ChannelData
cd2_
;
IceRole
role_
;
uint64_t
tiebreaker_
;
bool
role_conflict_
;
bool
save_candidates_
;
std
:
:
vector
<
std
:
:
unique_ptr
<
CandidatesData
>
>
saved_candidates_
;
bool
ready_to_send_
=
false
;
}
;
ChannelData
*
GetChannelData
(
rtc
:
:
PacketTransportInterface
*
transport
)
{
if
(
ep1_
.
HasTransport
(
transport
)
)
return
ep1_
.
GetChannelData
(
transport
)
;
else
return
ep2_
.
GetChannelData
(
transport
)
;
}
IceParameters
IceParamsWithRenomination
(
const
IceParameters
&
ice
bool
renomination
)
{
IceParameters
new_ice
=
ice
;
new_ice
.
renomination
=
renomination
;
return
new_ice
;
}
void
CreateChannels
(
const
IceConfig
&
ep1_config
const
IceConfig
&
ep2_config
bool
renomination
=
false
)
{
IceParameters
ice_ep1_cd1_ch
=
IceParamsWithRenomination
(
kIceParams
[
0
]
renomination
)
;
IceParameters
ice_ep2_cd1_ch
=
IceParamsWithRenomination
(
kIceParams
[
1
]
renomination
)
;
ep1_
.
cd1_
.
ch_
.
reset
(
CreateChannel
(
0
ICE_CANDIDATE_COMPONENT_DEFAULT
ice_ep1_cd1_ch
ice_ep2_cd1_ch
)
)
;
ep2_
.
cd1_
.
ch_
.
reset
(
CreateChannel
(
1
ICE_CANDIDATE_COMPONENT_DEFAULT
ice_ep2_cd1_ch
ice_ep1_cd1_ch
)
)
;
ep1_
.
cd1_
.
ch_
-
>
SetMetricsObserver
(
ep1_
.
metrics_observer_
)
;
ep2_
.
cd1_
.
ch_
-
>
SetMetricsObserver
(
ep2_
.
metrics_observer_
)
;
ep1_
.
cd1_
.
ch_
-
>
SetIceConfig
(
ep1_config
)
;
ep2_
.
cd1_
.
ch_
-
>
SetIceConfig
(
ep2_config
)
;
ep1_
.
cd1_
.
ch_
-
>
MaybeStartGathering
(
)
;
ep2_
.
cd1_
.
ch_
-
>
MaybeStartGathering
(
)
;
}
void
CreateChannels
(
)
{
IceConfig
default_config
;
CreateChannels
(
default_config
default_config
false
)
;
}
P2PTransportChannel
*
CreateChannel
(
int
endpoint
int
component
const
IceParameters
&
local_ice
const
IceParameters
&
remote_ice
)
{
P2PTransportChannel
*
channel
=
new
P2PTransportChannel
(
"
test
content
name
"
component
GetAllocator
(
endpoint
)
)
;
channel
-
>
SignalReadyToSend
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnReadyToSend
)
;
channel
-
>
SignalCandidateGathered
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnCandidateGathered
)
;
channel
-
>
SignalCandidatesRemoved
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnCandidatesRemoved
)
;
channel
-
>
SignalReadPacket
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnReadPacket
)
;
channel
-
>
SignalRoleConflict
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnRoleConflict
)
;
channel
-
>
SignalSelectedCandidatePairChanged
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnSelectedCandidatePairChanged
)
;
channel
-
>
SetIceParameters
(
local_ice
)
;
if
(
remote_ice_parameter_source_
=
=
FROM_SETICEPARAMETERS
)
{
channel
-
>
SetRemoteIceParameters
(
remote_ice
)
;
}
channel
-
>
SetIceRole
(
GetEndpoint
(
endpoint
)
-
>
ice_role
(
)
)
;
channel
-
>
SetIceTiebreaker
(
GetEndpoint
(
endpoint
)
-
>
GetIceTiebreaker
(
)
)
;
return
channel
;
}
void
DestroyChannels
(
)
{
ep1_
.
cd1_
.
ch_
.
reset
(
)
;
ep2_
.
cd1_
.
ch_
.
reset
(
)
;
ep1_
.
cd2_
.
ch_
.
reset
(
)
;
ep2_
.
cd2_
.
ch_
.
reset
(
)
;
}
P2PTransportChannel
*
ep1_ch1
(
)
{
return
ep1_
.
cd1_
.
ch_
.
get
(
)
;
}
P2PTransportChannel
*
ep1_ch2
(
)
{
return
ep1_
.
cd2_
.
ch_
.
get
(
)
;
}
P2PTransportChannel
*
ep2_ch1
(
)
{
return
ep2_
.
cd1_
.
ch_
.
get
(
)
;
}
P2PTransportChannel
*
ep2_ch2
(
)
{
return
ep2_
.
cd2_
.
ch_
.
get
(
)
;
}
TestTurnServer
*
test_turn_server
(
)
{
return
&
turn_server_
;
}
rtc
:
:
VirtualSocketServer
*
virtual_socket_server
(
)
{
return
vss_
.
get
(
)
;
}
static
const
Result
kLocalUdpToLocalUdp
;
static
const
Result
kLocalUdpToStunUdp
;
static
const
Result
kLocalUdpToPrflxUdp
;
static
const
Result
kPrflxUdpToLocalUdp
;
static
const
Result
kStunUdpToLocalUdp
;
static
const
Result
kStunUdpToStunUdp
;
static
const
Result
kStunUdpToPrflxUdp
;
static
const
Result
kPrflxUdpToStunUdp
;
static
const
Result
kLocalUdpToRelayUdp
;
static
const
Result
kPrflxUdpToRelayUdp
;
static
const
Result
kRelayUdpToPrflxUdp
;
static
const
Result
kLocalTcpToLocalTcp
;
static
const
Result
kLocalTcpToPrflxTcp
;
static
const
Result
kPrflxTcpToLocalTcp
;
rtc
:
:
NATSocketServer
*
nat
(
)
{
return
nss_
.
get
(
)
;
}
rtc
:
:
FirewallSocketServer
*
fw
(
)
{
return
ss_
.
get
(
)
;
}
Endpoint
*
GetEndpoint
(
int
endpoint
)
{
if
(
endpoint
=
=
0
)
{
return
&
ep1_
;
}
else
if
(
endpoint
=
=
1
)
{
return
&
ep2_
;
}
else
{
return
NULL
;
}
}
BasicPortAllocator
*
GetAllocator
(
int
endpoint
)
{
return
GetEndpoint
(
endpoint
)
-
>
allocator_
.
get
(
)
;
}
webrtc
:
:
FakeMetricsObserver
*
GetMetricsObserver
(
int
endpoint
)
{
return
GetEndpoint
(
endpoint
)
-
>
metrics_observer_
;
}
void
AddAddress
(
int
endpoint
const
SocketAddress
&
addr
)
{
GetEndpoint
(
endpoint
)
-
>
network_manager_
.
AddInterface
(
addr
)
;
}
void
AddAddress
(
int
endpoint
const
SocketAddress
&
addr
const
std
:
:
string
&
ifname
rtc
:
:
AdapterType
adapter_type
)
{
GetEndpoint
(
endpoint
)
-
>
network_manager_
.
AddInterface
(
addr
ifname
adapter_type
)
;
}
void
RemoveAddress
(
int
endpoint
const
SocketAddress
&
addr
)
{
GetEndpoint
(
endpoint
)
-
>
network_manager_
.
RemoveInterface
(
addr
)
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
addr
)
;
}
void
SetProxy
(
int
endpoint
rtc
:
:
ProxyType
type
)
{
rtc
:
:
ProxyInfo
info
;
info
.
type
=
type
;
info
.
address
=
(
type
=
=
rtc
:
:
PROXY_HTTPS
)
?
kHttpsProxyAddrs
[
endpoint
]
:
kSocksProxyAddrs
[
endpoint
]
;
GetAllocator
(
endpoint
)
-
>
set_proxy
(
"
unittest
/
1
.
0
"
info
)
;
}
void
SetAllocatorFlags
(
int
endpoint
int
flags
)
{
GetAllocator
(
endpoint
)
-
>
set_flags
(
flags
)
;
}
void
SetIceRole
(
int
endpoint
IceRole
role
)
{
GetEndpoint
(
endpoint
)
-
>
SetIceRole
(
role
)
;
}
void
SetIceTiebreaker
(
int
endpoint
uint64_t
tiebreaker
)
{
GetEndpoint
(
endpoint
)
-
>
SetIceTiebreaker
(
tiebreaker
)
;
}
bool
GetRoleConflict
(
int
endpoint
)
{
return
GetEndpoint
(
endpoint
)
-
>
role_conflict
(
)
;
}
void
SetAllocationStepDelay
(
int
endpoint
uint32_t
delay
)
{
return
GetEndpoint
(
endpoint
)
-
>
SetAllocationStepDelay
(
delay
)
;
}
void
SetAllowTcpListen
(
int
endpoint
bool
allow_tcp_listen
)
{
return
GetEndpoint
(
endpoint
)
-
>
SetAllowTcpListen
(
allow_tcp_listen
)
;
}
bool
CheckCandidate1
(
const
Result
&
expected
)
{
const
std
:
:
string
&
local_type
=
LocalCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
local_protocol
=
LocalCandidate
(
ep1_ch1
(
)
)
-
>
protocol
(
)
;
const
std
:
:
string
&
remote_type
=
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
remote_protocol
=
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
protocol
(
)
;
return
(
local_protocol
=
=
expected
.
controlling_protocol
&
&
remote_protocol
=
=
expected
.
controlled_protocol
&
&
local_type
=
=
expected
.
controlling_type
&
&
remote_type
=
=
expected
.
controlled_type
)
;
}
void
ExpectCandidate1
(
const
Result
&
expected
)
{
if
(
CheckCandidate1
(
expected
)
)
{
return
;
}
const
std
:
:
string
&
local_type
=
LocalCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
local_protocol
=
LocalCandidate
(
ep1_ch1
(
)
)
-
>
protocol
(
)
;
const
std
:
:
string
&
remote_type
=
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
remote_protocol
=
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
protocol
(
)
;
EXPECT_EQ
(
expected
.
controlling_type
local_type
)
;
EXPECT_EQ
(
expected
.
controlled_type
remote_type
)
;
EXPECT_EQ
(
expected
.
controlling_protocol
local_protocol
)
;
EXPECT_EQ
(
expected
.
controlled_protocol
remote_protocol
)
;
}
bool
CheckCandidate2
(
const
Result
&
expected
)
{
const
std
:
:
string
&
local_type
=
LocalCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
local_protocol
=
LocalCandidate
(
ep2_ch1
(
)
)
-
>
protocol
(
)
;
const
std
:
:
string
&
remote_type
=
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
remote_protocol
=
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
protocol
(
)
;
return
(
local_protocol
=
=
expected
.
controlled_protocol
&
&
remote_protocol
=
=
expected
.
controlling_protocol
&
&
local_type
=
=
expected
.
controlled_type
&
&
remote_type
=
=
expected
.
controlling_type
)
;
}
void
ExpectCandidate2
(
const
Result
&
expected
)
{
if
(
CheckCandidate2
(
expected
)
)
{
return
;
}
const
std
:
:
string
&
local_type
=
LocalCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
local_protocol
=
LocalCandidate
(
ep2_ch1
(
)
)
-
>
protocol
(
)
;
const
std
:
:
string
&
remote_type
=
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
;
const
std
:
:
string
&
remote_protocol
=
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
protocol
(
)
;
EXPECT_EQ
(
expected
.
controlled_type
local_type
)
;
EXPECT_EQ
(
expected
.
controlling_type
remote_type
)
;
EXPECT_EQ
(
expected
.
controlled_protocol
local_protocol
)
;
EXPECT_EQ
(
expected
.
controlling_protocol
remote_protocol
)
;
}
void
Test
(
const
Result
&
expected
)
{
rtc
:
:
ScopedFakeClock
clock
;
int64_t
connect_start
=
rtc
:
:
TimeMillis
(
)
;
int64_t
connect_time
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
!
=
NULL
&
&
ep2_ch1
(
)
!
=
NULL
&
&
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
expected
.
connect_wait
+
kShortTimeout
clock
)
;
connect_time
=
rtc
:
:
TimeMillis
(
)
-
connect_start
;
if
(
connect_time
<
expected
.
connect_wait
)
{
LOG
(
LS_INFO
)
<
<
"
Connect
time
:
"
<
<
connect_time
<
<
"
ms
"
;
}
else
{
LOG
(
LS_INFO
)
<
<
"
Connect
time
:
"
<
<
"
TIMEOUT
(
"
<
<
expected
.
connect_wait
<
<
"
ms
)
"
;
}
if
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
)
{
int64_t
converge_start
=
rtc
:
:
TimeMillis
(
)
;
int64_t
converge_time
;
EXPECT_TRUE_SIMULATED_WAIT
(
CheckCandidate1
(
expected
)
&
&
CheckCandidate2
(
expected
)
kMediumTimeout
clock
)
;
ExpectCandidate1
(
expected
)
;
ExpectCandidate2
(
expected
)
;
converge_time
=
rtc
:
:
TimeMillis
(
)
-
converge_start
;
int64_t
converge_wait
=
2000
;
if
(
converge_time
<
converge_wait
)
{
LOG
(
LS_INFO
)
<
<
"
Converge
time
:
"
<
<
converge_time
<
<
"
ms
"
;
}
else
{
LOG
(
LS_INFO
)
<
<
"
Converge
time
:
"
<
<
"
TIMEOUT
(
"
<
<
converge_wait
<
<
"
ms
)
"
;
}
}
TestSendRecv
(
clock
)
;
DestroyChannels
(
)
;
}
void
TestSendRecv
(
rtc
:
:
FakeClock
&
clock
)
{
for
(
int
i
=
0
;
i
<
10
;
+
+
i
)
{
const
char
*
data
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890
"
;
int
len
=
static_cast
<
int
>
(
strlen
(
data
)
)
;
EXPECT_EQ_SIMULATED_WAIT
(
len
SendData
(
ep1_ch1
(
)
data
len
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
CheckDataOnChannel
(
ep2_ch1
(
)
data
len
)
kMediumTimeout
clock
)
;
EXPECT_EQ_SIMULATED_WAIT
(
len
SendData
(
ep2_ch1
(
)
data
len
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
CheckDataOnChannel
(
ep1_ch1
(
)
data
len
)
kMediumTimeout
clock
)
;
}
}
void
TestHandleIceUfragPasswordChanged
(
)
{
rtc
:
:
ScopedFakeClock
clock
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
0
]
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
const
Candidate
*
old_local_candidate1
=
LocalCandidate
(
ep1_ch1
(
)
)
;
const
Candidate
*
old_local_candidate2
=
LocalCandidate
(
ep2_ch1
(
)
)
;
const
Candidate
*
old_remote_candidate1
=
RemoteCandidate
(
ep1_ch1
(
)
)
;
const
Candidate
*
old_remote_candidate2
=
RemoteCandidate
(
ep2_ch1
(
)
)
;
ep1_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
2
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
ep2_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
generation
(
)
!
=
old_local_candidate1
-
>
generation
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
LocalCandidate
(
ep2_ch1
(
)
)
-
>
generation
(
)
!
=
old_local_candidate2
-
>
generation
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
generation
(
)
!
=
old_remote_candidate1
-
>
generation
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
generation
(
)
!
=
old_remote_candidate2
-
>
generation
(
)
kMediumTimeout
clock
)
;
EXPECT_EQ
(
1u
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
generation
(
)
)
;
EXPECT_EQ
(
1u
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
generation
(
)
)
;
}
void
TestSignalRoleConflict
(
)
{
rtc
:
:
ScopedFakeClock
clock
;
SetIceTiebreaker
(
0
kLowTiebreaker
)
;
SetIceRole
(
1
ICEROLE_CONTROLLING
)
;
SetIceTiebreaker
(
1
kHighTiebreaker
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
GetRoleConflict
(
0
)
kShortTimeout
clock
)
;
EXPECT_FALSE
(
GetRoleConflict
(
1
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kShortTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
)
;
TestSendRecv
(
clock
)
;
}
void
OnReadyToSend
(
rtc
:
:
PacketTransportInterface
*
transport
)
{
GetEndpoint
(
transport
)
-
>
ready_to_send_
=
true
;
}
void
OnCandidateGathered
(
IceTransportInternal
*
ch
const
Candidate
&
c
)
{
if
(
force_relay_
&
&
c
.
type
(
)
!
=
RELAY_PORT_TYPE
)
return
;
if
(
GetEndpoint
(
ch
)
-
>
save_candidates_
)
{
GetEndpoint
(
ch
)
-
>
saved_candidates_
.
push_back
(
std
:
:
unique_ptr
<
CandidatesData
>
(
new
CandidatesData
(
ch
c
)
)
)
;
}
else
{
main_
-
>
Post
(
RTC_FROM_HERE
this
MSG_ADD_CANDIDATES
new
CandidatesData
(
ch
c
)
)
;
}
}
void
OnSelectedCandidatePairChanged
(
IceTransportInternal
*
transport_channel
CandidatePairInterface
*
selected_candidate_pair
int
last_sent_packet_id
bool
ready_to_send
)
{
if
(
selected_candidate_pair
!
=
nullptr
)
{
+
+
selected_candidate_pair_switches_
;
}
}
int
reset_selected_candidate_pair_switches
(
)
{
int
switches
=
selected_candidate_pair_switches_
;
selected_candidate_pair_switches_
=
0
;
return
switches
;
}
void
PauseCandidates
(
int
endpoint
)
{
GetEndpoint
(
endpoint
)
-
>
save_candidates_
=
true
;
}
void
OnCandidatesRemoved
(
IceTransportInternal
*
ch
const
std
:
:
vector
<
Candidate
>
&
candidates
)
{
CandidatesData
*
candidates_data
=
new
CandidatesData
(
ch
candidates
)
;
main_
-
>
Post
(
RTC_FROM_HERE
this
MSG_REMOVE_CANDIDATES
candidates_data
)
;
}
void
VerifySavedTcpCandidates
(
int
endpoint
const
std
:
:
string
&
tcptype
)
{
for
(
auto
&
data
:
GetEndpoint
(
endpoint
)
-
>
saved_candidates_
)
{
for
(
auto
&
candidate
:
data
-
>
candidates
)
{
EXPECT_EQ
(
candidate
.
protocol
(
)
TCP_PROTOCOL_NAME
)
;
EXPECT_EQ
(
candidate
.
tcptype
(
)
tcptype
)
;
if
(
candidate
.
tcptype
(
)
=
=
TCPTYPE_ACTIVE_STR
)
{
EXPECT_EQ
(
candidate
.
address
(
)
.
port
(
)
DISCARD_PORT
)
;
}
else
if
(
candidate
.
tcptype
(
)
=
=
TCPTYPE_PASSIVE_STR
)
{
EXPECT_NE
(
candidate
.
address
(
)
.
port
(
)
DISCARD_PORT
)
;
}
else
{
FAIL
(
)
<
<
"
Unknown
tcptype
:
"
<
<
candidate
.
tcptype
(
)
;
}
}
}
}
void
ResumeCandidates
(
int
endpoint
)
{
Endpoint
*
ed
=
GetEndpoint
(
endpoint
)
;
for
(
auto
&
candidate
:
ed
-
>
saved_candidates_
)
{
main_
-
>
Post
(
RTC_FROM_HERE
this
MSG_ADD_CANDIDATES
candidate
.
release
(
)
)
;
}
ed
-
>
saved_candidates_
.
clear
(
)
;
ed
-
>
save_candidates_
=
false
;
}
void
OnMessage
(
rtc
:
:
Message
*
msg
)
{
switch
(
msg
-
>
message_id
)
{
case
MSG_ADD_CANDIDATES
:
{
std
:
:
unique_ptr
<
CandidatesData
>
data
(
static_cast
<
CandidatesData
*
>
(
msg
-
>
pdata
)
)
;
P2PTransportChannel
*
rch
=
GetRemoteChannel
(
data
-
>
channel
)
;
if
(
!
rch
)
{
return
;
}
for
(
auto
&
c
:
data
-
>
candidates
)
{
if
(
remote_ice_parameter_source_
!
=
FROM_CANDIDATE
)
{
c
.
set_username
(
"
"
)
;
c
.
set_password
(
"
"
)
;
}
LOG
(
LS_INFO
)
<
<
"
Candidate
(
"
<
<
data
-
>
channel
-
>
component
(
)
<
<
"
-
>
"
<
<
rch
-
>
component
(
)
<
<
"
)
:
"
<
<
c
.
ToString
(
)
;
rch
-
>
AddRemoteCandidate
(
c
)
;
}
break
;
}
case
MSG_REMOVE_CANDIDATES
:
{
std
:
:
unique_ptr
<
CandidatesData
>
data
(
static_cast
<
CandidatesData
*
>
(
msg
-
>
pdata
)
)
;
P2PTransportChannel
*
rch
=
GetRemoteChannel
(
data
-
>
channel
)
;
if
(
!
rch
)
{
return
;
}
for
(
Candidate
&
c
:
data
-
>
candidates
)
{
LOG
(
LS_INFO
)
<
<
"
Removed
remote
candidate
"
<
<
c
.
ToString
(
)
;
rch
-
>
RemoveRemoteCandidate
(
c
)
;
}
break
;
}
}
}
void
OnReadPacket
(
rtc
:
:
PacketTransportInterface
*
transport
const
char
*
data
size_t
len
const
rtc
:
:
PacketTime
&
packet_time
int
flags
)
{
std
:
:
list
<
std
:
:
string
>
&
packets
=
GetPacketList
(
transport
)
;
packets
.
push_front
(
std
:
:
string
(
data
len
)
)
;
}
void
OnRoleConflict
(
IceTransportInternal
*
channel
)
{
GetEndpoint
(
channel
)
-
>
OnRoleConflict
(
true
)
;
IceRole
new_role
=
GetEndpoint
(
channel
)
-
>
ice_role
(
)
=
=
ICEROLE_CONTROLLING
?
ICEROLE_CONTROLLED
:
ICEROLE_CONTROLLING
;
channel
-
>
SetIceRole
(
new_role
)
;
}
int
SendData
(
IceTransportInternal
*
channel
const
char
*
data
size_t
len
)
{
rtc
:
:
PacketOptions
options
;
return
channel
-
>
SendPacket
(
data
len
options
0
)
;
}
bool
CheckDataOnChannel
(
IceTransportInternal
*
channel
const
char
*
data
int
len
)
{
return
GetChannelData
(
channel
)
-
>
CheckData
(
data
len
)
;
}
static
const
Candidate
*
LocalCandidate
(
P2PTransportChannel
*
ch
)
{
return
(
ch
&
&
ch
-
>
selected_connection
(
)
)
?
&
ch
-
>
selected_connection
(
)
-
>
local_candidate
(
)
:
NULL
;
}
static
const
Candidate
*
RemoteCandidate
(
P2PTransportChannel
*
ch
)
{
return
(
ch
&
&
ch
-
>
selected_connection
(
)
)
?
&
ch
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
:
NULL
;
}
Endpoint
*
GetEndpoint
(
rtc
:
:
PacketTransportInterface
*
transport
)
{
if
(
ep1_
.
HasTransport
(
transport
)
)
{
return
&
ep1_
;
}
else
if
(
ep2_
.
HasTransport
(
transport
)
)
{
return
&
ep2_
;
}
else
{
return
NULL
;
}
}
P2PTransportChannel
*
GetRemoteChannel
(
IceTransportInternal
*
ch
)
{
if
(
ch
=
=
ep1_ch1
(
)
)
return
ep2_ch1
(
)
;
else
if
(
ch
=
=
ep1_ch2
(
)
)
return
ep2_ch2
(
)
;
else
if
(
ch
=
=
ep2_ch1
(
)
)
return
ep1_ch1
(
)
;
else
if
(
ch
=
=
ep2_ch2
(
)
)
return
ep1_ch2
(
)
;
else
return
NULL
;
}
std
:
:
list
<
std
:
:
string
>
&
GetPacketList
(
rtc
:
:
PacketTransportInterface
*
transport
)
{
return
GetChannelData
(
transport
)
-
>
ch_packets_
;
}
enum
RemoteIceParameterSource
{
FROM_CANDIDATE
FROM_SETICEPARAMETERS
}
;
void
set_remote_ice_parameter_source
(
RemoteIceParameterSource
source
)
{
remote_ice_parameter_source_
=
source
;
}
void
set_force_relay
(
bool
relay
)
{
force_relay_
=
relay
;
}
void
ConnectSignalNominated
(
Connection
*
conn
)
{
conn
-
>
SignalNominated
.
connect
(
this
&
P2PTransportChannelTestBase
:
:
OnNominated
)
;
}
void
OnNominated
(
Connection
*
conn
)
{
nominated_
=
true
;
}
bool
nominated
(
)
{
return
nominated_
;
}
private
:
rtc
:
:
Thread
*
main_
;
std
:
:
unique_ptr
<
rtc
:
:
PhysicalSocketServer
>
pss_
;
std
:
:
unique_ptr
<
rtc
:
:
VirtualSocketServer
>
vss_
;
std
:
:
unique_ptr
<
rtc
:
:
NATSocketServer
>
nss_
;
std
:
:
unique_ptr
<
rtc
:
:
FirewallSocketServer
>
ss_
;
rtc
:
:
SocketServerScope
ss_scope_
;
std
:
:
unique_ptr
<
TestStunServer
>
stun_server_
;
TestTurnServer
turn_server_
;
rtc
:
:
SocksProxyServer
socks_server1_
;
rtc
:
:
SocksProxyServer
socks_server2_
;
Endpoint
ep1_
;
Endpoint
ep2_
;
RemoteIceParameterSource
remote_ice_parameter_source_
=
FROM_CANDIDATE
;
bool
force_relay_
;
int
selected_candidate_pair_switches_
=
0
;
bool
nominated_
=
false
;
}
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalUdpToLocalUdp
(
"
local
"
"
udp
"
"
local
"
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalUdpToStunUdp
(
"
local
"
"
udp
"
"
stun
"
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalUdpToPrflxUdp
(
"
local
"
"
udp
"
"
prflx
"
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kPrflxUdpToLocalUdp
(
"
prflx
"
"
udp
"
"
local
"
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kStunUdpToLocalUdp
(
"
stun
"
"
udp
"
"
local
"
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kStunUdpToStunUdp
(
"
stun
"
"
udp
"
"
stun
"
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kStunUdpToPrflxUdp
(
"
stun
"
"
udp
"
"
prflx
"
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kPrflxUdpToStunUdp
(
"
prflx
"
"
udp
"
"
stun
"
"
udp
"
1000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalUdpToRelayUdp
(
"
local
"
"
udp
"
"
relay
"
"
udp
"
2000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kPrflxUdpToRelayUdp
(
"
prflx
"
"
udp
"
"
relay
"
"
udp
"
2000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kRelayUdpToPrflxUdp
(
"
relay
"
"
udp
"
"
prflx
"
"
udp
"
2000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalTcpToLocalTcp
(
"
local
"
"
tcp
"
"
local
"
"
tcp
"
3000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kLocalTcpToPrflxTcp
(
"
local
"
"
tcp
"
"
prflx
"
"
tcp
"
3000
)
;
const
P2PTransportChannelTestBase
:
:
Result
P2PTransportChannelTestBase
:
:
kPrflxTcpToLocalTcp
(
"
prflx
"
"
tcp
"
"
local
"
"
tcp
"
3000
)
;
class
P2PTransportChannelTest
:
public
P2PTransportChannelTestBase
{
protected
:
static
const
Result
*
kMatrix
[
NUM_CONFIGS
]
[
NUM_CONFIGS
]
;
void
ConfigureEndpoints
(
Config
config1
Config
config2
int
allocator_flags1
int
allocator_flags2
)
{
ConfigureEndpoint
(
0
config1
)
;
SetAllocatorFlags
(
0
allocator_flags1
)
;
SetAllocationStepDelay
(
0
kMinimumStepDelay
)
;
ConfigureEndpoint
(
1
config2
)
;
SetAllocatorFlags
(
1
allocator_flags2
)
;
SetAllocationStepDelay
(
1
kMinimumStepDelay
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
}
void
ConfigureEndpoint
(
int
endpoint
Config
config
)
{
switch
(
config
)
{
case
OPEN
:
AddAddress
(
endpoint
kPublicAddrs
[
endpoint
]
)
;
break
;
case
NAT_FULL_CONE
:
case
NAT_ADDR_RESTRICTED
:
case
NAT_PORT_RESTRICTED
:
case
NAT_SYMMETRIC
:
AddAddress
(
endpoint
kPrivateAddrs
[
endpoint
]
)
;
nat
(
)
-
>
AddTranslator
(
kPublicAddrs
[
endpoint
]
kNatAddrs
[
endpoint
]
static_cast
<
rtc
:
:
NATType
>
(
config
-
NAT_FULL_CONE
)
)
-
>
AddClient
(
kPrivateAddrs
[
endpoint
]
)
;
break
;
case
NAT_DOUBLE_CONE
:
case
NAT_SYMMETRIC_THEN_CONE
:
AddAddress
(
endpoint
kCascadedPrivateAddrs
[
endpoint
]
)
;
nat
(
)
-
>
AddTranslator
(
kPublicAddrs
[
endpoint
]
kNatAddrs
[
endpoint
]
(
config
=
=
NAT_DOUBLE_CONE
)
?
rtc
:
:
NAT_OPEN_CONE
:
rtc
:
:
NAT_SYMMETRIC
)
-
>
AddTranslator
(
kPrivateAddrs
[
endpoint
]
kCascadedNatAddrs
[
endpoint
]
rtc
:
:
NAT_OPEN_CONE
)
-
>
AddClient
(
kCascadedPrivateAddrs
[
endpoint
]
)
;
break
;
case
BLOCK_UDP
:
case
BLOCK_UDP_AND_INCOMING_TCP
:
case
BLOCK_ALL_BUT_OUTGOING_HTTP
:
case
PROXY_HTTPS
:
case
PROXY_SOCKS
:
AddAddress
(
endpoint
kPublicAddrs
[
endpoint
]
)
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_UDP
rtc
:
:
FD_ANY
kPublicAddrs
[
endpoint
]
)
;
if
(
config
=
=
BLOCK_UDP_AND_INCOMING_TCP
)
{
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_TCP
SocketAddress
(
)
kPublicAddrs
[
endpoint
]
)
;
}
else
if
(
config
=
=
BLOCK_ALL_BUT_OUTGOING_HTTP
)
{
fw
(
)
-
>
AddRule
(
true
rtc
:
:
FP_TCP
kPublicAddrs
[
endpoint
]
SocketAddress
(
rtc
:
:
IPAddress
(
INADDR_ANY
)
80
)
)
;
fw
(
)
-
>
AddRule
(
true
rtc
:
:
FP_TCP
kPublicAddrs
[
endpoint
]
SocketAddress
(
rtc
:
:
IPAddress
(
INADDR_ANY
)
443
)
)
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_TCP
rtc
:
:
FD_ANY
kPublicAddrs
[
endpoint
]
)
;
}
else
if
(
config
=
=
PROXY_HTTPS
)
{
fw
(
)
-
>
AddRule
(
true
rtc
:
:
FP_TCP
kPublicAddrs
[
endpoint
]
kHttpsProxyAddrs
[
endpoint
]
)
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_TCP
rtc
:
:
FD_ANY
kPublicAddrs
[
endpoint
]
)
;
SetProxy
(
endpoint
rtc
:
:
PROXY_HTTPS
)
;
}
else
if
(
config
=
=
PROXY_SOCKS
)
{
fw
(
)
-
>
AddRule
(
true
rtc
:
:
FP_TCP
kPublicAddrs
[
endpoint
]
kSocksProxyAddrs
[
endpoint
]
)
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_TCP
rtc
:
:
FD_ANY
kPublicAddrs
[
endpoint
]
)
;
SetProxy
(
endpoint
rtc
:
:
PROXY_SOCKS5
)
;
}
break
;
default
:
break
;
}
}
}
;
#
define
LULU
&
kLocalUdpToLocalUdp
#
define
LUSU
&
kLocalUdpToStunUdp
#
define
LUPU
&
kLocalUdpToPrflxUdp
#
define
PULU
&
kPrflxUdpToLocalUdp
#
define
SULU
&
kStunUdpToLocalUdp
#
define
SUSU
&
kStunUdpToStunUdp
#
define
SUPU
&
kStunUdpToPrflxUdp
#
define
PUSU
&
kPrflxUdpToStunUdp
#
define
LURU
&
kLocalUdpToRelayUdp
#
define
PURU
&
kPrflxUdpToRelayUdp
#
define
RUPU
&
kRelayUdpToPrflxUdp
#
define
LTLT
&
kLocalTcpToLocalTcp
#
define
LTPT
&
kLocalTcpToPrflxTcp
#
define
PTLT
&
kPrflxTcpToLocalTcp
#
define
LTRT
NULL
#
define
LSRS
NULL
const
P2PTransportChannelTest
:
:
Result
*
P2PTransportChannelTest
:
:
kMatrix
[
NUM_CONFIGS
]
[
NUM_CONFIGS
]
=
{
{
LULU
LUSU
LUSU
LUSU
LUPU
LUSU
LUPU
LTPT
LTPT
LSRS
NULL
LTPT
}
{
SULU
SUSU
SUSU
SUSU
SUPU
SUSU
SUPU
NULL
NULL
LSRS
NULL
LTRT
}
{
SULU
SUSU
SUSU
SUSU
SUPU
SUSU
SUPU
NULL
NULL
LSRS
NULL
LTRT
}
{
SULU
SUSU
SUSU
SUSU
RUPU
SUSU
RUPU
NULL
NULL
LSRS
NULL
LTRT
}
{
PULU
PUSU
PUSU
PURU
PURU
PUSU
PURU
NULL
NULL
LSRS
NULL
LTRT
}
{
SULU
SUSU
SUSU
SUSU
SUPU
SUSU
SUPU
NULL
NULL
LSRS
NULL
LTRT
}
{
PULU
PUSU
PUSU
PURU
PURU
PUSU
PURU
NULL
NULL
LSRS
NULL
LTRT
}
{
LTPT
NULL
NULL
NULL
NULL
NULL
NULL
LTPT
LTPT
LSRS
NULL
LTRT
}
{
PTLT
NULL
NULL
NULL
NULL
NULL
NULL
PTLT
LTRT
LSRS
NULL
LTRT
}
{
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
LSRS
NULL
LSRS
}
{
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
}
{
LTRT
LTRT
LTRT
LTRT
LTRT
LTRT
LTRT
LTRT
LTRT
LSRS
NULL
LTRT
}
}
;
#
define
P2P_TEST_DECLARATION
(
x
y
z
)
\
TEST_F
(
P2PTransportChannelTest
z
#
#
Test
#
#
x
#
#
To
#
#
y
)
{
\
ConfigureEndpoints
(
x
y
PORTALLOCATOR_ENABLE_SHARED_SOCKET
\
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
\
if
(
kMatrix
[
x
]
[
y
]
!
=
NULL
)
\
Test
(
*
kMatrix
[
x
]
[
y
]
)
;
\
else
\
LOG
(
LS_WARNING
)
<
<
"
Not
yet
implemented
"
;
\
}
#
define
P2P_TEST
(
x
y
)
\
P2P_TEST_DECLARATION
(
x
y
)
#
define
P2P_TEST_SET
(
x
)
\
P2P_TEST
(
x
OPEN
)
\
P2P_TEST
(
x
NAT_FULL_CONE
)
\
P2P_TEST
(
x
NAT_ADDR_RESTRICTED
)
\
P2P_TEST
(
x
NAT_PORT_RESTRICTED
)
\
P2P_TEST
(
x
NAT_SYMMETRIC
)
\
P2P_TEST
(
x
NAT_DOUBLE_CONE
)
\
P2P_TEST
(
x
NAT_SYMMETRIC_THEN_CONE
)
\
P2P_TEST
(
x
BLOCK_UDP
)
\
P2P_TEST
(
x
BLOCK_UDP_AND_INCOMING_TCP
)
\
P2P_TEST
(
x
BLOCK_ALL_BUT_OUTGOING_HTTP
)
\
P2P_TEST
(
x
PROXY_HTTPS
)
\
P2P_TEST
(
x
PROXY_SOCKS
)
P2P_TEST_SET
(
OPEN
)
P2P_TEST_SET
(
NAT_FULL_CONE
)
P2P_TEST_SET
(
NAT_ADDR_RESTRICTED
)
P2P_TEST_SET
(
NAT_PORT_RESTRICTED
)
P2P_TEST_SET
(
NAT_SYMMETRIC
)
P2P_TEST_SET
(
NAT_DOUBLE_CONE
)
P2P_TEST_SET
(
NAT_SYMMETRIC_THEN_CONE
)
P2P_TEST_SET
(
BLOCK_UDP
)
P2P_TEST_SET
(
BLOCK_UDP_AND_INCOMING_TCP
)
P2P_TEST_SET
(
BLOCK_ALL_BUT_OUTGOING_HTTP
)
P2P_TEST_SET
(
PROXY_HTTPS
)
P2P_TEST_SET
(
PROXY_SOCKS
)
TEST_F
(
P2PTransportChannelTest
HandleUfragPwdChange
)
{
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
)
;
TestHandleIceUfragPasswordChanged
(
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
HandleUfragPwdChangeSymmetricNat
)
{
ConfigureEndpoints
(
NAT_SYMMETRIC
NAT_SYMMETRIC
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
)
;
TestHandleIceUfragPasswordChanged
(
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
GetStats
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
TestSendRecv
(
clock
)
;
ConnectionInfos
infos
;
ASSERT_TRUE
(
ep1_ch1
(
)
-
>
GetStats
(
&
infos
)
)
;
ASSERT_TRUE
(
infos
.
size
(
)
>
=
1
)
;
ConnectionInfo
*
best_conn_info
=
nullptr
;
for
(
ConnectionInfo
&
info
:
infos
)
{
if
(
info
.
best_connection
)
{
best_conn_info
=
&
info
;
break
;
}
}
ASSERT_TRUE
(
best_conn_info
!
=
nullptr
)
;
EXPECT_TRUE
(
best_conn_info
-
>
new_connection
)
;
EXPECT_TRUE
(
best_conn_info
-
>
receiving
)
;
EXPECT_TRUE
(
best_conn_info
-
>
writable
)
;
EXPECT_FALSE
(
best_conn_info
-
>
timeout
)
;
EXPECT_EQ
(
10U
best_conn_info
-
>
sent_total_packets
)
;
EXPECT_EQ
(
0U
best_conn_info
-
>
sent_discarded_packets
)
;
EXPECT_EQ
(
10
*
36U
best_conn_info
-
>
sent_total_bytes
)
;
EXPECT_EQ
(
10
*
36U
best_conn_info
-
>
recv_total_bytes
)
;
EXPECT_GT
(
best_conn_info
-
>
rtt
0U
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestUMAIceRestartWhileDisconnected
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kDefaultTimeout
clock
)
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
const
int
kWriteTimeoutDelay
=
6000
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
ep1_ch1
(
)
-
>
writable
(
)
&
&
!
ep2_ch1
(
)
-
>
writable
(
)
kWriteTimeoutDelay
clock
)
;
ep1_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
2
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_EQ
(
1
GetMetricsObserver
(
0
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRestart
static_cast
<
int
>
(
IceRestartState
:
:
DISCONNECTED
)
)
)
;
ep2_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_EQ
(
1
GetMetricsObserver
(
1
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRestart
static_cast
<
int
>
(
IceRestartState
:
:
DISCONNECTED
)
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestUMAIceRestartWhileConnected
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kDefaultTimeout
clock
)
;
ep1_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
2
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_EQ
(
1
GetMetricsObserver
(
0
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRestart
static_cast
<
int
>
(
IceRestartState
:
:
CONNECTED
)
)
)
;
ep2_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_EQ
(
1
GetMetricsObserver
(
1
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRestart
static_cast
<
int
>
(
IceRestartState
:
:
CONNECTED
)
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestUMAIceRestartWhileConnecting
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
ep1_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
2
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_EQ
(
1
GetMetricsObserver
(
0
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRestart
static_cast
<
int
>
(
IceRestartState
:
:
CONNECTING
)
)
)
;
ep2_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_EQ
(
1
GetMetricsObserver
(
1
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRestart
static_cast
<
int
>
(
IceRestartState
:
:
CONNECTING
)
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIceRegatheringReasonContinualGatheringByNetworkChange
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
IceConfig
continual_gathering_config
=
CreateIceConfig
(
1000
GATHER_CONTINUALLY
)
;
IceConfig
default_config
;
CreateChannels
(
continual_gathering_config
default_config
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kDefaultTimeout
clock
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
EXPECT_EQ_SIMULATED_WAIT
(
1
GetMetricsObserver
(
0
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRegathering
static_cast
<
int
>
(
IceRegatheringReason
:
:
NETWORK_CHANGE
)
)
kDefaultTimeout
clock
)
;
ep2_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
SIMULATED_WAIT
(
false
kDefaultTimeout
clock
)
;
EXPECT_EQ
(
0
GetMetricsObserver
(
1
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRegathering
static_cast
<
int
>
(
IceRegatheringReason
:
:
NETWORK_CHANGE
)
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIceRegatheringReasonContinualGatheringByNetworkFailure
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
OPEN
kOnlyLocalPorts
kOnlyLocalPorts
)
;
IceConfig
config1
=
CreateIceConfig
(
1000
GATHER_CONTINUALLY
)
;
config1
.
regather_on_failed_networks_interval
=
rtc
:
:
Optional
<
int
>
(
2000
)
;
IceConfig
config2
;
config2
.
regather_on_failed_networks_interval
=
rtc
:
:
Optional
<
int
>
(
2000
)
;
CreateChannels
(
config1
config2
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kDefaultTimeout
clock
)
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
const
int
kNetworkFailureTimeout
=
35000
;
SIMULATED_WAIT
(
false
kNetworkFailureTimeout
clock
)
;
EXPECT_LE
(
1
GetMetricsObserver
(
0
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRegathering
static_cast
<
int
>
(
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
)
;
EXPECT_EQ
(
0
GetMetricsObserver
(
1
)
-
>
GetEnumCounter
(
webrtc
:
:
kEnumCounterIceRegathering
static_cast
<
int
>
(
IceRegatheringReason
:
:
NETWORK_FAILURE
)
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PeerReflexiveCandidateBeforeSignaling
)
{
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
set_remote_ice_parameter_source
(
FROM_CANDIDATE
)
;
CreateChannels
(
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
0
]
)
;
PauseCandidates
(
1
)
;
ASSERT_TRUE_WAIT
(
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
kMediumTimeout
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
const
Connection
*
selected_connection
=
nullptr
;
ASSERT_TRUE_WAIT
(
(
selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
)
!
=
nullptr
kMediumTimeout
)
;
EXPECT_EQ
(
"
prflx
"
selected_connection
-
>
remote_candidate
(
)
.
type
(
)
)
;
EXPECT_EQ
(
kIceUfrag
[
1
]
selected_connection
-
>
remote_candidate
(
)
.
username
(
)
)
;
EXPECT_EQ
(
kIcePwd
[
1
]
selected_connection
-
>
remote_candidate
(
)
.
password
(
)
)
;
EXPECT_EQ
(
1u
selected_connection
-
>
remote_candidate
(
)
.
generation
(
)
)
;
ResumeCandidates
(
1
)
;
EXPECT_EQ_WAIT
(
"
local
"
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
type
(
)
kMediumTimeout
)
;
EXPECT_EQ
(
selected_connection
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PeerReflexiveCandidateBeforeSignalingWithNAT
)
{
ConfigureEndpoints
(
OPEN
NAT_SYMMETRIC
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
set_remote_ice_parameter_source
(
FROM_CANDIDATE
)
;
CreateChannels
(
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
0
]
)
;
PauseCandidates
(
1
)
;
ASSERT_TRUE_WAIT
(
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
kMediumTimeout
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
const
Connection
*
selected_connection
=
nullptr
;
ASSERT_TRUE_WAIT
(
(
selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
)
!
=
nullptr
kMediumTimeout
)
;
EXPECT_EQ
(
"
prflx
"
selected_connection
-
>
remote_candidate
(
)
.
type
(
)
)
;
EXPECT_EQ
(
kIceUfrag
[
1
]
selected_connection
-
>
remote_candidate
(
)
.
username
(
)
)
;
EXPECT_EQ
(
kIcePwd
[
1
]
selected_connection
-
>
remote_candidate
(
)
.
password
(
)
)
;
EXPECT_EQ
(
1u
selected_connection
-
>
remote_candidate
(
)
.
generation
(
)
)
;
ResumeCandidates
(
1
)
;
EXPECT_EQ_WAIT
(
"
prflx
"
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
type
(
)
kMediumTimeout
)
;
EXPECT_EQ
(
selected_connection
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PeerReflexiveCandidateBeforeSignalingWithIceRestart
)
{
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
GetEndpoint
(
0
)
-
>
allocator_
-
>
set_candidate_filter
(
CF_RELAY
)
;
GetEndpoint
(
1
)
-
>
allocator_
-
>
set_candidate_filter
(
CF_RELAY
)
;
set_remote_ice_parameter_source
(
FROM_CANDIDATE
)
;
CreateChannels
(
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
0
]
)
;
EXPECT_TRUE_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kDefaultTimeout
)
;
PauseCandidates
(
1
)
;
ep2_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
3
]
)
;
ep1_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_EQ_WAIT
(
"
prflx
"
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
type
(
)
kDefaultTimeout
)
;
const
Connection
*
prflx_selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
ep1_ch1
(
)
-
>
SetIceParameters
(
kIceParams
[
2
]
)
;
ep2_ch1
(
)
-
>
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
ResumeCandidates
(
1
)
;
EXPECT_EQ_WAIT
(
"
relay
"
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_candidate
(
)
.
type
(
)
kDefaultTimeout
)
;
EXPECT_EQ
(
prflx_selected_connection
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
RemoteCandidatesWithoutUfragPwd
)
{
rtc
:
:
ScopedFakeClock
clock
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
CreateChannels
(
)
;
const
Connection
*
selected_connection
=
NULL
;
EXPECT_TRUE_SIMULATED_WAIT
(
(
selected_connection
=
ep2_ch1
(
)
-
>
selected_connection
(
)
)
!
=
NULL
kMediumTimeout
clock
)
;
SIMULATED_WAIT
(
ep2_ch1
(
)
-
>
selected_connection
(
)
!
=
selected_connection
kShortTimeout
clock
)
;
EXPECT_TRUE
(
ep2_ch1
(
)
-
>
selected_connection
(
)
=
=
selected_connection
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
IncomingOnlyBlocked
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
NAT_FULL_CONE
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
ep1_ch1
(
)
-
>
set_incoming_only
(
true
)
;
SIMULATED_WAIT
(
false
kShortTimeout
clock
)
;
EXPECT_FALSE
(
ep1_ch1
(
)
-
>
receiving
(
)
)
;
EXPECT_FALSE
(
ep1_ch1
(
)
-
>
writable
(
)
)
;
EXPECT_FALSE
(
ep2_ch1
(
)
-
>
receiving
(
)
)
;
EXPECT_FALSE
(
ep2_ch1
(
)
-
>
writable
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
IncomingOnlyOpen
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
NAT_FULL_CONE
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
ep1_ch1
(
)
-
>
set_incoming_only
(
true
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
!
=
NULL
&
&
ep2_ch1
(
)
!
=
NULL
&
&
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestTcpConnectionsFromActiveToPassive
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocationStepDelay
(
0
kMinimumStepDelay
)
;
SetAllocationStepDelay
(
1
kMinimumStepDelay
)
;
int
kOnlyLocalTcpPorts
=
PORTALLOCATOR_DISABLE_UDP
|
PORTALLOCATOR_DISABLE_STUN
|
PORTALLOCATOR_DISABLE_RELAY
;
SetAllocatorFlags
(
0
kOnlyLocalTcpPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalTcpPorts
)
;
SetAllowTcpListen
(
0
true
)
;
SetAllowTcpListen
(
1
false
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
PauseCandidates
(
0
)
;
PauseCandidates
(
1
)
;
CreateChannels
(
)
;
VerifySavedTcpCandidates
(
0
TCPTYPE_PASSIVE_STR
)
;
VerifySavedTcpCandidates
(
1
TCPTYPE_ACTIVE_STR
)
;
ResumeCandidates
(
0
)
;
ResumeCandidates
(
1
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kShortTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
TestSendRecv
(
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIceRoleConflict
)
{
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
TestSignalRoleConflict
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIceConfigWillPassDownToPort
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetIceRole
(
0
ICEROLE_CONTROLLING
)
;
SetIceTiebreaker
(
0
kHighTiebreaker
)
;
SetIceRole
(
1
ICEROLE_CONTROLLING
)
;
SetIceTiebreaker
(
1
kLowTiebreaker
)
;
CreateChannels
(
)
;
EXPECT_EQ_SIMULATED_WAIT
(
2u
ep1_ch1
(
)
-
>
ports
(
)
.
size
(
)
kShortTimeout
clock
)
;
const
std
:
:
vector
<
PortInterface
*
>
ports_before
=
ep1_ch1
(
)
-
>
ports
(
)
;
for
(
size_t
i
=
0
;
i
<
ports_before
.
size
(
)
;
+
+
i
)
{
EXPECT_EQ
(
ICEROLE_CONTROLLING
ports_before
[
i
]
-
>
GetIceRole
(
)
)
;
EXPECT_EQ
(
kHighTiebreaker
ports_before
[
i
]
-
>
IceTiebreaker
(
)
)
;
}
ep1_ch1
(
)
-
>
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ep1_ch1
(
)
-
>
SetIceTiebreaker
(
kLowTiebreaker
)
;
const
std
:
:
vector
<
PortInterface
*
>
ports_after
=
ep1_ch1
(
)
-
>
ports
(
)
;
for
(
size_t
i
=
0
;
i
<
ports_after
.
size
(
)
;
+
+
i
)
{
EXPECT_EQ
(
ICEROLE_CONTROLLED
ports_before
[
i
]
-
>
GetIceRole
(
)
)
;
EXPECT_EQ
(
kHighTiebreaker
ports_before
[
i
]
-
>
IceTiebreaker
(
)
)
;
}
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kShortTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
)
;
TestSendRecv
(
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestDefaultDscpValue
)
{
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
CreateChannels
(
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_NO_CHANGE
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_NO_CHANGE
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
SetOption
(
rtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_CS6
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
SetOption
(
rtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_CS6
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_CS6
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_CS6
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
SetOption
(
rtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_AF41
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
SetOption
(
rtc
:
:
Socket
:
:
OPT_DSCP
rtc
:
:
DSCP_AF41
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_AF41
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
EXPECT_EQ
(
rtc
:
:
DSCP_AF41
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
-
>
DefaultDscpValue
(
)
)
;
}
TEST_F
(
P2PTransportChannelTest
TestIPv6Connections
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kIPv6PublicAddrs
[
0
]
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kIPv6PublicAddrs
[
1
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocationStepDelay
(
0
kMinimumStepDelay
)
;
SetAllocationStepDelay
(
1
kMinimumStepDelay
)
;
SetAllocatorFlags
(
0
PORTALLOCATOR_ENABLE_IPV6
)
;
SetAllocatorFlags
(
1
PORTALLOCATOR_ENABLE_IPV6
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kShortTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kIPv6PublicAddrs
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kIPv6PublicAddrs
[
1
]
)
)
;
TestSendRecv
(
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestForceTurn
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
NAT_PORT_RESTRICTED
NAT_SYMMETRIC
kDefaultPortAllocatorFlags
|
PORTALLOCATOR_ENABLE_SHARED_SOCKET
kDefaultPortAllocatorFlags
|
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
;
set_force_relay
(
true
)
;
SetAllocationStepDelay
(
0
kMinimumStepDelay
)
;
SetAllocationStepDelay
(
1
kMinimumStepDelay
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
)
;
EXPECT_EQ
(
"
relay
"
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_EQ
(
"
relay
"
LocalCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_EQ
(
"
relay
"
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_EQ
(
"
relay
"
LocalCandidate
(
ep2_ch1
(
)
)
-
>
type
(
)
)
;
TestSendRecv
(
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestContinualGathering
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
SetAllocationStepDelay
(
0
kDefaultStepDelay
)
;
SetAllocationStepDelay
(
1
kDefaultStepDelay
)
;
IceConfig
continual_gathering_config
=
CreateIceConfig
(
1000
GATHER_CONTINUALLY
)
;
IceConfig
default_config
;
CreateChannels
(
continual_gathering_config
default_config
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
!
=
NULL
&
&
ep2_ch1
(
)
!
=
NULL
&
&
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
SIMULATED_WAIT
(
IceGatheringState
:
:
kIceGatheringComplete
=
=
ep1_ch1
(
)
-
>
gathering_state
(
)
kShortTimeout
clock
)
;
EXPECT_EQ
(
IceGatheringState
:
:
kIceGatheringGathering
ep1_ch1
(
)
-
>
gathering_state
(
)
)
;
EXPECT_EQ
(
IceGatheringState
:
:
kIceGatheringComplete
ep2_ch1
(
)
-
>
gathering_state
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
TestUsingPooledSessionBeforeDoneGathering
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
auto
&
allocator_1
=
GetEndpoint
(
0
)
-
>
allocator_
;
auto
&
allocator_2
=
GetEndpoint
(
1
)
-
>
allocator_
;
int
pool_size
=
1
;
allocator_1
-
>
SetConfiguration
(
allocator_1
-
>
stun_servers
(
)
allocator_1
-
>
turn_servers
(
)
pool_size
false
)
;
allocator_2
-
>
SetConfiguration
(
allocator_2
-
>
stun_servers
(
)
allocator_2
-
>
turn_servers
(
)
pool_size
false
)
;
const
PortAllocatorSession
*
pooled_session_1
=
allocator_1
-
>
GetPooledSession
(
)
;
const
PortAllocatorSession
*
pooled_session_2
=
allocator_2
-
>
GetPooledSession
(
)
;
ASSERT_NE
(
nullptr
pooled_session_1
)
;
ASSERT_NE
(
nullptr
pooled_session_2
)
;
EXPECT_TRUE
(
pooled_session_1
-
>
ReadyPorts
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
pooled_session_1
-
>
ReadyCandidates
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
pooled_session_2
-
>
ReadyPorts
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
pooled_session_2
-
>
ReadyCandidates
(
)
.
empty
(
)
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
!
=
NULL
&
&
ep2_ch1
(
)
!
=
NULL
&
&
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
TestSendRecv
(
clock
)
;
auto
pooled_ports_1
=
pooled_session_1
-
>
ReadyPorts
(
)
;
auto
pooled_ports_2
=
pooled_session_2
-
>
ReadyPorts
(
)
;
EXPECT_NE
(
pooled_ports_1
.
end
(
)
std
:
:
find
(
pooled_ports_1
.
begin
(
)
pooled_ports_1
.
end
(
)
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
port
(
)
)
)
;
EXPECT_NE
(
pooled_ports_2
.
end
(
)
std
:
:
find
(
pooled_ports_2
.
begin
(
)
pooled_ports_2
.
end
(
)
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
port
(
)
)
)
;
}
TEST_F
(
P2PTransportChannelTest
TestUsingPooledSessionAfterDoneGathering
)
{
rtc
:
:
ScopedFakeClock
clock
;
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
auto
&
allocator_1
=
GetEndpoint
(
0
)
-
>
allocator_
;
auto
&
allocator_2
=
GetEndpoint
(
1
)
-
>
allocator_
;
int
pool_size
=
1
;
allocator_1
-
>
SetConfiguration
(
allocator_1
-
>
stun_servers
(
)
allocator_1
-
>
turn_servers
(
)
pool_size
false
)
;
allocator_2
-
>
SetConfiguration
(
allocator_2
-
>
stun_servers
(
)
allocator_2
-
>
turn_servers
(
)
pool_size
false
)
;
const
PortAllocatorSession
*
pooled_session_1
=
allocator_1
-
>
GetPooledSession
(
)
;
const
PortAllocatorSession
*
pooled_session_2
=
allocator_2
-
>
GetPooledSession
(
)
;
ASSERT_NE
(
nullptr
pooled_session_1
)
;
ASSERT_NE
(
nullptr
pooled_session_2
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
pooled_session_1
-
>
CandidatesAllocationDone
(
)
&
&
pooled_session_2
-
>
CandidatesAllocationDone
(
)
kDefaultTimeout
clock
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
!
=
NULL
&
&
ep2_ch1
(
)
!
=
NULL
&
&
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
TestSendRecv
(
clock
)
;
auto
pooled_ports_1
=
pooled_session_1
-
>
ReadyPorts
(
)
;
auto
pooled_ports_2
=
pooled_session_2
-
>
ReadyPorts
(
)
;
EXPECT_NE
(
pooled_ports_1
.
end
(
)
std
:
:
find
(
pooled_ports_1
.
begin
(
)
pooled_ports_1
.
end
(
)
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
port
(
)
)
)
;
EXPECT_NE
(
pooled_ports_2
.
end
(
)
std
:
:
find
(
pooled_ports_2
.
begin
(
)
pooled_ports_2
.
end
(
)
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
port
(
)
)
)
;
}
TEST_F
(
P2PTransportChannelTest
TurnToTurnPresumedWritable
)
{
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
.
reset
(
CreateChannel
(
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
)
;
IceConfig
config
;
config
.
presume_writable_when_fully_relayed
=
true
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_EQ_WAIT
(
IceGatheringState
:
:
kIceGatheringComplete
ep1_ch1
(
)
-
>
gathering_state
(
)
kDefaultTimeout
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
100
)
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
RELAY_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
0
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
)
;
EXPECT_EQ
(
RELAY_PORT_TYPE
LocalCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_EQ
(
RELAY_PORT_TYPE
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
writable
(
)
)
;
EXPECT_TRUE
(
GetEndpoint
(
0
)
-
>
ready_to_send_
)
;
const
char
*
data
=
"
test
"
;
int
len
=
static_cast
<
int
>
(
strlen
(
data
)
)
;
EXPECT_EQ
(
len
SendData
(
ep1_ch1
(
)
data
len
)
)
;
}
TEST_F
(
P2PTransportChannelTest
TurnToPrflxPresumedWritable
)
{
rtc
:
:
ScopedFakeClock
fake_clock
;
virtual_socket_server
(
)
-
>
set_delay_mean
(
50
)
;
virtual_socket_server
(
)
-
>
UpdateDelayDistribution
(
)
;
ConfigureEndpoints
(
NAT_SYMMETRIC
NAT_SYMMETRIC
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
test_turn_server
(
)
-
>
set_enable_permission_checks
(
false
)
;
IceConfig
config
;
config
.
presume_writable_when_fully_relayed
=
true
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
.
reset
(
CreateChannel
(
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
.
reset
(
CreateChannel
(
1
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
1
]
kIceParams
[
0
]
)
)
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
PauseCandidates
(
1
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
kShortTimeout
fake_clock
)
;
ASSERT_NE
(
nullptr
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
EXPECT_EQ
(
RELAY_PORT_TYPE
LocalCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_EQ
(
PRFLX_PORT_TYPE
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_FALSE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
writable
(
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
writable
(
)
kShortTimeout
fake_clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
PresumedWritablePreferredOverUnreliable
)
{
rtc
:
:
ScopedFakeClock
fake_clock
;
ConfigureEndpoints
(
NAT_SYMMETRIC
NAT_SYMMETRIC
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
IceConfig
config
;
config
.
presume_writable_when_fully_relayed
=
true
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
.
reset
(
CreateChannel
(
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
.
reset
(
CreateChannel
(
1
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
1
]
kIceParams
[
0
]
)
)
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
ep2_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
writable
(
)
kShortTimeout
fake_clock
)
;
const
Connection
*
old_selected_connection
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
GetEndpoint
(
1
)
-
>
cd1_
.
ch_
.
reset
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
ep1_ch1
(
)
-
>
writable
(
)
kDefaultTimeout
fake_clock
)
;
EXPECT_NE
(
nullptr
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
RELAY_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
0
)
)
;
EXPECT_EQ
(
RELAY_PORT_TYPE
LocalCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_EQ
(
RELAY_PORT_TYPE
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
writable
(
)
)
;
EXPECT_TRUE
(
GetEndpoint
(
0
)
-
>
ready_to_send_
)
;
EXPECT_NE
(
old_selected_connection
ep1_ch1
(
)
-
>
selected_connection
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelTest
SignalReadyToSendWithPresumedWritable
)
{
ConfigureEndpoints
(
OPEN
OPEN
kDefaultPortAllocatorFlags
kDefaultPortAllocatorFlags
)
;
GetEndpoint
(
0
)
-
>
cd1_
.
ch_
.
reset
(
CreateChannel
(
0
ICE_CANDIDATE_COMPONENT_DEFAULT
kIceParams
[
0
]
kIceParams
[
1
]
)
)
;
IceConfig
config
;
config
.
presume_writable_when_fully_relayed
=
true
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep1_ch1
(
)
-
>
MaybeStartGathering
(
)
;
EXPECT_EQ_WAIT
(
IceGatheringState
:
:
kIceGatheringComplete
ep1_ch1
(
)
-
>
gathering_state
(
)
kDefaultTimeout
)
;
ep1_ch1
(
)
-
>
AddRemoteCandidate
(
CreateUdpCandidate
(
RELAY_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
0
)
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
nullptr
)
;
EXPECT_EQ
(
RELAY_PORT_TYPE
LocalCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
EXPECT_EQ
(
RELAY_PORT_TYPE
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
type
(
)
)
;
virtual_socket_server
(
)
-
>
SetSendingBlocked
(
true
)
;
const
char
*
data
=
"
test
"
;
int
len
=
static_cast
<
int
>
(
strlen
(
data
)
)
;
EXPECT_EQ
(
-
1
SendData
(
ep1_ch1
(
)
data
len
)
)
;
GetEndpoint
(
0
)
-
>
ready_to_send_
=
false
;
virtual_socket_server
(
)
-
>
SetSendingBlocked
(
false
)
;
EXPECT_TRUE
(
GetEndpoint
(
0
)
-
>
ready_to_send_
)
;
EXPECT_EQ
(
len
SendData
(
ep1_ch1
(
)
data
len
)
)
;
}
class
P2PTransportChannelSameNatTest
:
public
P2PTransportChannelTestBase
{
protected
:
void
ConfigureEndpoints
(
Config
nat_type
Config
config1
Config
config2
)
{
ASSERT
(
nat_type
>
=
NAT_FULL_CONE
&
&
nat_type
<
=
NAT_SYMMETRIC
)
;
rtc
:
:
NATSocketServer
:
:
Translator
*
outer_nat
=
nat
(
)
-
>
AddTranslator
(
kPublicAddrs
[
0
]
kNatAddrs
[
0
]
static_cast
<
rtc
:
:
NATType
>
(
nat_type
-
NAT_FULL_CONE
)
)
;
ConfigureEndpoint
(
outer_nat
0
config1
)
;
ConfigureEndpoint
(
outer_nat
1
config2
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
}
void
ConfigureEndpoint
(
rtc
:
:
NATSocketServer
:
:
Translator
*
nat
int
endpoint
Config
config
)
{
ASSERT
(
config
<
=
NAT_SYMMETRIC
)
;
if
(
config
=
=
OPEN
)
{
AddAddress
(
endpoint
kPrivateAddrs
[
endpoint
]
)
;
nat
-
>
AddClient
(
kPrivateAddrs
[
endpoint
]
)
;
}
else
{
AddAddress
(
endpoint
kCascadedPrivateAddrs
[
endpoint
]
)
;
nat
-
>
AddTranslator
(
kPrivateAddrs
[
endpoint
]
kCascadedNatAddrs
[
endpoint
]
static_cast
<
rtc
:
:
NATType
>
(
config
-
NAT_FULL_CONE
)
)
-
>
AddClient
(
kCascadedPrivateAddrs
[
endpoint
]
)
;
}
}
}
;
TEST_F
(
P2PTransportChannelSameNatTest
TestConesBehindSameCone
)
{
ConfigureEndpoints
(
NAT_FULL_CONE
NAT_FULL_CONE
NAT_FULL_CONE
)
;
Test
(
P2PTransportChannelTestBase
:
:
Result
(
"
prflx
"
"
udp
"
"
stun
"
"
udp
"
1000
)
)
;
}
class
P2PTransportChannelMultihomedTest
:
public
P2PTransportChannelTestBase
{
public
:
const
Connection
*
GetConnectionWithRemoteAddress
(
P2PTransportChannel
*
channel
const
SocketAddress
&
address
)
{
for
(
Connection
*
conn
:
channel
-
>
connections
(
)
)
{
if
(
conn
-
>
remote_candidate
(
)
.
address
(
)
.
EqualIPs
(
address
)
)
{
return
conn
;
}
}
return
nullptr
;
}
Connection
*
GetConnectionWithLocalAddress
(
P2PTransportChannel
*
channel
const
SocketAddress
&
address
)
{
for
(
Connection
*
conn
:
channel
-
>
connections
(
)
)
{
if
(
conn
-
>
local_candidate
(
)
.
address
(
)
.
EqualIPs
(
address
)
)
{
return
conn
;
}
}
return
nullptr
;
}
Connection
*
GetConnection
(
P2PTransportChannel
*
channel
const
SocketAddress
&
local
const
SocketAddress
&
remote
)
{
for
(
Connection
*
conn
:
channel
-
>
connections
(
)
)
{
if
(
conn
-
>
local_candidate
(
)
.
address
(
)
.
EqualIPs
(
local
)
&
&
conn
-
>
remote_candidate
(
)
.
address
(
)
.
EqualIPs
(
remote
)
)
{
return
conn
;
}
}
return
nullptr
;
}
void
DestroyAllButBestConnection
(
P2PTransportChannel
*
channel
)
{
const
Connection
*
selected_connection
=
channel
-
>
selected_connection
(
)
;
for
(
Connection
*
conn
:
channel
-
>
connections
(
)
)
{
if
(
conn
!
=
selected_connection
)
{
conn
-
>
Destroy
(
)
;
}
}
}
}
;
TEST_F
(
P2PTransportChannelMultihomedTest
TestBasic
)
{
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
Test
(
kLocalUdpToLocalUdp
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestFailoverControlledSide
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_ONCE
)
;
CreateChannels
(
config
config
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
kPublicAddrs
[
1
]
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
const
Connection
*
selected_connection2
=
ep2_ch1
(
)
-
>
selected_connection
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
selected_connection1
-
>
receiving
(
)
&
&
!
selected_connection2
-
>
receiving
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kAlternateAddrs
[
1
]
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kAlternateAddrs
[
1
]
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestFailoverControllingSide
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_ONCE
)
;
CreateChannels
(
config
config
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
const
Connection
*
selected_connection2
=
ep2_ch1
(
)
-
>
selected_connection
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
selected_connection1
-
>
receiving
(
)
&
&
!
selected_connection2
-
>
receiving
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kAlternateAddrs
[
0
]
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kAlternateAddrs
[
0
]
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestFailoverWithManyConnections
)
{
rtc
:
:
ScopedFakeClock
clock
;
test_turn_server
(
)
-
>
AddInternalSocket
(
kTurnTcpIntAddr
PROTO_TCP
)
;
RelayServerConfig
turn_server
(
RELAY_TURN
)
;
turn_server
.
credentials
=
kRelayCredentials
;
turn_server
.
ports
.
push_back
(
ProtocolAddress
(
kTurnTcpIntAddr
PROTO_TCP
)
)
;
GetAllocator
(
0
)
-
>
AddTurnServer
(
turn_server
)
;
GetAllocator
(
1
)
-
>
AddTurnServer
(
turn_server
)
;
SetAllocatorFlags
(
0
PORTALLOCATOR_ENABLE_IPV6
)
;
SetAllocatorFlags
(
1
PORTALLOCATOR_ENABLE_IPV6
)
;
SetAllocationStepDelay
(
0
kMinimumStepDelay
)
;
SetAllocationStepDelay
(
1
kMinimumStepDelay
)
;
auto
&
wifi
=
kPublicAddrs
;
auto
&
cellular
=
kAlternateAddrs
;
auto
&
wifiIpv6
=
kIPv6PublicAddrs
;
auto
&
cellularIpv6
=
kIPv6AlternateAddrs
;
AddAddress
(
0
wifi
[
0
]
"
wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
wifiIpv6
[
0
]
"
wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
cellular
[
0
]
"
cellular0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
0
cellularIpv6
[
0
]
"
cellular0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
wifi1
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
wifiIpv6
[
1
]
"
wifi1
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
cellular1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
cellularIpv6
[
1
]
"
cellular1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
virtual_socket_server
(
)
-
>
SetDelayOnAddress
(
kTurnTcpIntAddr
1
)
;
virtual_socket_server
(
)
-
>
SetDelayOnAddress
(
kTurnUdpExtAddr
1
)
;
virtual_socket_server
(
)
-
>
set_delay_mean
(
500
)
;
virtual_socket_server
(
)
-
>
UpdateDelayDistribution
(
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_CONTINUALLY
)
;
CreateChannels
(
config
config
true
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifiIpv6
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifiIpv6
[
1
]
)
kMediumTimeout
clock
)
;
LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
wifi
[
0
]
)
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
wifiIpv6
[
0
]
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
const
Connection
*
selected_connection2
=
ep2_ch1
(
)
-
>
selected_connection
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
selected_connection1
-
>
receiving
(
)
&
&
!
selected_connection2
-
>
receiving
(
)
kMediumTimeout
clock
)
;
Connection
*
per_network_best_connection1
=
GetConnection
(
ep1_ch1
(
)
cellularIpv6
[
0
]
wifiIpv6
[
1
]
)
;
ASSERT_NE
(
nullptr
per_network_best_connection1
)
;
int64_t
last_ping_sent1
=
per_network_best_connection1
-
>
last_ping_sent
(
)
;
int
num_pings_sent1
=
per_network_best_connection1
-
>
num_pings_sent
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
num_pings_sent1
<
per_network_best_connection1
-
>
num_pings_sent
(
)
kMediumTimeout
clock
)
;
int64_t
ping_interval1
=
(
per_network_best_connection1
-
>
last_ping_sent
(
)
-
last_ping_sent1
)
/
(
per_network_best_connection1
-
>
num_pings_sent
(
)
-
num_pings_sent1
)
;
constexpr
int
SCHEDULING_DELAY
=
200
;
EXPECT_LT
(
ping_interval1
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
+
SCHEDULING_DELAY
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
&
&
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
cellularIpv6
[
0
]
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
cellularIpv6
[
0
]
)
kMediumTimeout
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestIceRenomination
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
set_remote_ice_parameter_source
(
FROM_SETICEPARAMETERS
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_ONCE
)
;
CreateChannels
(
config
config
true
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_nomination
(
)
>
0
&
&
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
acked_nomination
(
)
>
0
kDefaultTimeout
clock
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
Connection
*
selected_connection2
=
const_cast
<
Connection
*
>
(
ep2_ch1
(
)
-
>
selected_connection
(
)
)
;
uint32_t
remote_nomination2
=
selected_connection2
-
>
remote_nomination
(
)
;
ConnectSignalNominated
(
selected_connection2
)
;
SIMULATED_WAIT
(
nominated
(
)
kMediumTimeout
clock
)
;
EXPECT_FALSE
(
nominated
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
!
=
selected_connection1
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
remote_nomination
(
)
>
remote_nomination2
kDefaultTimeout
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestConnectionSwitchDampeningControlledSide
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_ONCE
)
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
reset_selected_candidate_pair_switches
(
)
;
LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
kPublicAddrs
[
1
]
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
const
Connection
*
selected_connection2
=
ep2_ch1
(
)
-
>
selected_connection
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
selected_connection1
-
>
receiving
(
)
&
&
!
selected_connection2
-
>
receiving
(
)
kMediumTimeout
clock
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
fw
(
)
-
>
ClearRules
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestConnectionSwitchDampeningControllingSide
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_ONCE
)
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
reset_selected_candidate_pair_switches
(
)
;
LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
kPublicAddrs
[
0
]
)
;
const
Connection
*
selected_connection1
=
ep1_ch1
(
)
-
>
selected_connection
(
)
;
const
Connection
*
selected_connection2
=
ep2_ch1
(
)
-
>
selected_connection
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
selected_connection1
-
>
receiving
(
)
&
&
!
selected_connection2
-
>
receiving
(
)
kMediumTimeout
clock
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
fw
(
)
-
>
ClearRules
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
-
>
receiving
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
)
;
EXPECT_TRUE
(
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestRemoteFailover
)
{
rtc
:
:
ScopedFakeClock
clock
;
auto
&
wifi
=
kPublicAddrs
;
auto
&
cellular
=
kAlternateAddrs
;
AddAddress
(
0
wifi
[
0
]
"
wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
cellular
[
0
]
"
cellular0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_ONCE
25000
)
;
config
.
stable_writable_connection_ping_interval
=
900
;
ep1_ch1
(
)
-
>
SetIceConfig
(
config
)
;
ep2_ch1
(
)
-
>
SetIceConfig
(
config
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
1
]
)
kDefaultTimeout
clock
)
;
Connection
*
backup_conn
=
GetConnectionWithLocalAddress
(
ep1_ch1
(
)
cellular
[
0
]
)
;
ASSERT_NE
(
nullptr
backup_conn
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
backup_conn
-
>
writable
(
)
&
&
!
backup_conn
-
>
receiving
(
)
kDefaultTimeout
clock
)
;
reset_selected_candidate_pair_switches
(
)
;
LOG
(
LS_INFO
)
<
<
"
Failing
over
.
.
.
"
;
fw
(
)
-
>
AddRule
(
false
rtc
:
:
FP_ANY
rtc
:
:
FD_ANY
wifi
[
1
]
)
;
int
num_switches
=
0
;
SIMULATED_WAIT
(
(
num_switches
=
reset_selected_candidate_pair_switches
(
)
)
>
0
20000
clock
)
;
EXPECT_EQ
(
0
num_switches
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestPreferWifiToWifiConnection
)
{
auto
&
wifi
=
kAlternateAddrs
;
auto
&
cellular
=
kPublicAddrs
;
AddAddress
(
0
wifi
[
0
]
"
test0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
cellular
[
0
]
"
test1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
test0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
test1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
EXPECT_TRUE_WAIT_MARGIN
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
1000
1000
)
;
EXPECT_TRUE_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
1
]
)
1000
)
;
EXPECT_TRUE_WAIT
(
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
1
]
)
&
&
RemoteCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
0
]
)
1000
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestPreferWifiOverCellularNetwork
)
{
auto
&
wifi
=
kAlternateAddrs
;
auto
&
cellular
=
kPublicAddrs
;
AddAddress
(
0
cellular
[
0
]
"
test1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
test0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
test1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
EXPECT_TRUE_WAIT_MARGIN
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
1000
1000
)
;
EXPECT_TRUE_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
1
]
)
1000
)
;
EXPECT_TRUE_WAIT
(
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep2_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
1
]
)
1000
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestPingBackupConnectionRate
)
{
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
CreateChannels
(
)
;
EXPECT_TRUE_WAIT_MARGIN
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
1000
1000
)
;
int
backup_ping_interval
=
2000
;
ep2_ch1
(
)
-
>
SetIceConfig
(
CreateIceConfig
(
2000
GATHER_ONCE
backup_ping_interval
)
)
;
ASSERT_TRUE_WAIT
(
ep2_ch1
(
)
-
>
GetState
(
)
=
=
IceTransportState
:
:
STATE_COMPLETED
1000
)
;
const
std
:
:
vector
<
Connection
*
>
&
connections
=
ep2_ch1
(
)
-
>
connections
(
)
;
ASSERT_EQ
(
2U
connections
.
size
(
)
)
;
Connection
*
backup_conn
=
connections
[
1
]
;
EXPECT_TRUE_WAIT
(
backup_conn
-
>
writable
(
)
kMediumTimeout
)
;
int64_t
last_ping_response_ms
=
backup_conn
-
>
last_ping_response_received
(
)
;
EXPECT_TRUE_WAIT
(
last_ping_response_ms
<
backup_conn
-
>
last_ping_response_received
(
)
kDefaultTimeout
)
;
int
time_elapsed
=
backup_conn
-
>
last_ping_response_received
(
)
-
last_ping_response_ms
;
LOG
(
LS_INFO
)
<
<
"
Time
elapsed
:
"
<
<
time_elapsed
;
EXPECT_GE
(
time_elapsed
backup_ping_interval
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestGetState
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kAlternateAddrs
[
0
]
)
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
CreateChannels
(
)
;
EXPECT_EQ_SIMULATED_WAIT
(
IceTransportState
:
:
STATE_COMPLETED
ep1_ch1
(
)
-
>
GetState
(
)
kShortTimeout
clock
)
;
EXPECT_EQ_SIMULATED_WAIT
(
IceTransportState
:
:
STATE_COMPLETED
ep2_ch1
(
)
-
>
GetState
(
)
kShortTimeout
clock
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestNetworkBecomesInactive
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
IceConfig
ep1_config
=
CreateIceConfig
(
2000
GATHER_CONTINUALLY
)
;
IceConfig
ep2_config
=
CreateIceConfig
(
2000
GATHER_ONCE
)
;
CreateChannels
(
ep1_config
ep2_config
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kDefaultTimeout
clock
)
;
EXPECT_LE
(
1U
ep1_ch1
(
)
-
>
ports
(
)
.
size
(
)
)
;
RemoveAddress
(
0
kPublicAddrs
[
0
]
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
ports
(
)
.
empty
(
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep2_ch1
(
)
-
>
remote_candidates
(
)
.
empty
(
)
1000
clock
)
;
size_t
num_ports
=
ep2_ch1
(
)
-
>
ports
(
)
.
size
(
)
;
EXPECT_LE
(
1U
num_ports
)
;
size_t
num_remote_candidates
=
ep1_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
;
RemoveAddress
(
1
kPublicAddrs
[
1
]
)
;
EXPECT_EQ_SIMULATED_WAIT
(
0U
ep2_ch1
(
)
-
>
ports
(
)
.
size
(
)
kDefaultTimeout
clock
)
;
SIMULATED_WAIT
(
0U
=
=
ep1_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
500
clock
)
;
EXPECT_EQ
(
num_remote_candidates
ep1_ch1
(
)
-
>
remote_candidates
(
)
.
size
(
)
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestContinualGatheringOnNewInterface
)
{
auto
&
wifi
=
kAlternateAddrs
;
auto
&
cellular
=
kPublicAddrs
;
AddAddress
(
0
wifi
[
0
]
"
test_wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
test_cell1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
IceConfig
continual_gathering_config
=
CreateIceConfig
(
1000
GATHER_CONTINUALLY
)
;
CreateChannels
(
continual_gathering_config
continual_gathering_config
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
EXPECT_TRUE_WAIT_MARGIN
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kDefaultTimeout
kDefaultTimeout
)
;
AddAddress
(
1
wifi
[
1
]
"
test_wifi1
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
const
Connection
*
conn
;
EXPECT_TRUE_WAIT
(
(
conn
=
ep1_ch1
(
)
-
>
selected_connection
(
)
)
!
=
nullptr
&
&
conn
-
>
remote_candidate
(
)
.
address
(
)
.
EqualIPs
(
wifi
[
1
]
)
kDefaultTimeout
)
;
EXPECT_TRUE_WAIT
(
(
conn
=
ep2_ch1
(
)
-
>
selected_connection
(
)
)
!
=
nullptr
&
&
conn
-
>
local_candidate
(
)
.
address
(
)
.
EqualIPs
(
wifi
[
1
]
)
kDefaultTimeout
)
;
AddAddress
(
0
cellular
[
0
]
"
test_cellular0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
EXPECT_TRUE_WAIT
(
ep1_ch1
(
)
-
>
GetState
(
)
=
=
IceTransportState
:
:
STATE_COMPLETED
&
&
(
conn
=
GetConnectionWithLocalAddress
(
ep1_ch1
(
)
cellular
[
0
]
)
)
!
=
nullptr
&
&
conn
!
=
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
conn
-
>
writable
(
)
kDefaultTimeout
)
;
EXPECT_TRUE_WAIT
(
ep2_ch1
(
)
-
>
GetState
(
)
=
=
IceTransportState
:
:
STATE_COMPLETED
&
&
(
conn
=
GetConnectionWithRemoteAddress
(
ep2_ch1
(
)
cellular
[
0
]
)
)
!
=
nullptr
&
&
conn
!
=
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
conn
-
>
receiving
(
)
kDefaultTimeout
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestSwitchLinksViaContinualGathering
)
{
rtc
:
:
ScopedFakeClock
clock
;
AddAddress
(
0
kPublicAddrs
[
0
]
)
;
AddAddress
(
1
kPublicAddrs
[
1
]
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
IceConfig
continual_gathering_config
=
CreateIceConfig
(
1000
GATHER_CONTINUALLY
)
;
CreateChannels
(
continual_gathering_config
continual_gathering_config
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
1
]
)
)
;
LOG
(
LS_INFO
)
<
<
"
Draining
.
.
.
"
;
AddAddress
(
1
kAlternateAddrs
[
1
]
)
;
RemoveAddress
(
1
kPublicAddrs
[
1
]
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kAlternateAddrs
[
1
]
)
kMediumTimeout
clock
)
;
LOG
(
LS_INFO
)
<
<
"
Draining
again
.
.
.
"
;
RemoveAddress
(
1
kAlternateAddrs
[
1
]
)
;
AddAddress
(
1
kAlternateAddrs
[
0
]
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kPublicAddrs
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
kAlternateAddrs
[
0
]
)
kMediumTimeout
clock
)
;
DestroyChannels
(
)
;
}
TEST_F
(
P2PTransportChannelMultihomedTest
TestRestoreBackupConnection
)
{
rtc
:
:
ScopedFakeClock
clock
;
auto
&
wifi
=
kAlternateAddrs
;
auto
&
cellular
=
kPublicAddrs
;
AddAddress
(
0
wifi
[
0
]
"
test_wifi0
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
0
cellular
[
0
]
"
test_cell0
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
AddAddress
(
1
wifi
[
1
]
"
test_wifi1
"
rtc
:
:
ADAPTER_TYPE_WIFI
)
;
AddAddress
(
1
cellular
[
1
]
"
test_cell1
"
rtc
:
:
ADAPTER_TYPE_CELLULAR
)
;
SetAllocatorFlags
(
0
kOnlyLocalPorts
)
;
SetAllocatorFlags
(
1
kOnlyLocalPorts
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_CONTINUALLY
)
;
config
.
regather_on_failed_networks_interval
=
rtc
:
:
Optional
<
int
>
(
2000
)
;
CreateChannels
(
config
config
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ep1_ch1
(
)
-
>
receiving
(
)
&
&
ep1_ch1
(
)
-
>
writable
(
)
&
&
ep2_ch1
(
)
-
>
receiving
(
)
&
&
ep2_ch1
(
)
-
>
writable
(
)
kMediumTimeout
clock
)
;
EXPECT_TRUE
(
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
ep2_ch1
(
)
-
>
selected_connection
(
)
&
&
LocalCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
0
]
)
&
&
RemoteCandidate
(
ep1_ch1
(
)
)
-
>
address
(
)
.
EqualIPs
(
wifi
[
1
]
)
)
;
DestroyAllButBestConnection
(
ep1_ch1
(
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
GetConnectionWithLocalAddress
(
ep1_ch1
(
)
cellular
[
0
]
)
=
=
nullptr
kDefaultTimeout
clock
)
;
const
Connection
*
conn
;
EXPECT_TRUE_SIMULATED_WAIT
(
(
conn
=
GetConnectionWithLocalAddress
(
ep1_ch1
(
)
cellular
[
0
]
)
)
!
=
nullptr
&
&
conn
!
=
ep1_ch1
(
)
-
>
selected_connection
(
)
&
&
conn
-
>
writable
(
)
kDefaultTimeout
clock
)
;
DestroyChannels
(
)
;
}
class
P2PTransportChannelPingTest
:
public
testing
:
:
Test
public
sigslot
:
:
has_slots
<
>
{
public
:
P2PTransportChannelPingTest
(
)
:
pss_
(
new
rtc
:
:
PhysicalSocketServer
)
vss_
(
new
rtc
:
:
VirtualSocketServer
(
pss_
.
get
(
)
)
)
ss_scope_
(
vss_
.
get
(
)
)
{
}
protected
:
void
PrepareChannel
(
P2PTransportChannel
*
ch
)
{
ch
-
>
SetIceRole
(
ICEROLE_CONTROLLING
)
;
ch
-
>
SetIceParameters
(
kIceParams
[
0
]
)
;
ch
-
>
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
ch
-
>
SignalSelectedCandidatePairChanged
.
connect
(
this
&
P2PTransportChannelPingTest
:
:
OnSelectedCandidatePairChanged
)
;
ch
-
>
SignalReadyToSend
.
connect
(
this
&
P2PTransportChannelPingTest
:
:
OnReadyToSend
)
;
ch
-
>
SignalStateChanged
.
connect
(
this
&
P2PTransportChannelPingTest
:
:
OnChannelStateChanged
)
;
}
Connection
*
WaitForConnectionTo
(
P2PTransportChannel
*
ch
const
std
:
:
string
&
ip
int
port_num
rtc
:
:
FakeClock
*
clock
=
nullptr
)
{
if
(
clock
=
=
nullptr
)
{
EXPECT_TRUE_WAIT
(
GetConnectionTo
(
ch
ip
port_num
)
!
=
nullptr
kMediumTimeout
)
;
}
else
{
EXPECT_TRUE_SIMULATED_WAIT
(
GetConnectionTo
(
ch
ip
port_num
)
!
=
nullptr
kMediumTimeout
*
clock
)
;
}
return
GetConnectionTo
(
ch
ip
port_num
)
;
}
Port
*
GetPort
(
P2PTransportChannel
*
ch
)
{
if
(
ch
-
>
ports
(
)
.
empty
(
)
)
{
return
nullptr
;
}
return
static_cast
<
Port
*
>
(
ch
-
>
ports
(
)
[
0
]
)
;
}
Port
*
GetPrunedPort
(
P2PTransportChannel
*
ch
)
{
if
(
ch
-
>
pruned_ports
(
)
.
empty
(
)
)
{
return
nullptr
;
}
return
static_cast
<
Port
*
>
(
ch
-
>
pruned_ports
(
)
[
0
]
)
;
}
Connection
*
GetConnectionTo
(
P2PTransportChannel
*
ch
const
std
:
:
string
&
ip
int
port_num
)
{
Port
*
port
=
GetPort
(
ch
)
;
if
(
!
port
)
{
return
nullptr
;
}
return
port
-
>
GetConnection
(
rtc
:
:
SocketAddress
(
ip
port_num
)
)
;
}
Connection
*
FindNextPingableConnectionAndPingIt
(
P2PTransportChannel
*
ch
)
{
Connection
*
conn
=
ch
-
>
FindNextPingableConnection
(
)
;
if
(
conn
)
{
ch
-
>
MarkConnectionPinged
(
conn
)
;
}
return
conn
;
}
int
SendData
(
IceTransportInternal
&
channel
const
char
*
data
size_t
len
int
packet_id
)
{
rtc
:
:
PacketOptions
options
;
options
.
packet_id
=
packet_id
;
return
channel
.
SendPacket
(
data
len
options
0
)
;
}
Connection
*
CreateConnectionWithCandidate
(
P2PTransportChannel
&
channel
rtc
:
:
ScopedFakeClock
&
clock
const
std
:
:
string
&
ip_addr
int
port
int
priority
bool
writable
)
{
channel
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
ip_addr
port
priority
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
GetConnectionTo
(
&
channel
ip_addr
port
)
!
=
nullptr
kMediumTimeout
clock
)
;
Connection
*
conn
=
GetConnectionTo
(
&
channel
ip_addr
port
)
;
if
(
conn
&
&
writable
)
{
conn
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
}
return
conn
;
}
void
NominateConnection
(
Connection
*
conn
uint32_t
remote_nomination
=
1U
)
{
conn
-
>
set_remote_nomination
(
remote_nomination
)
;
conn
-
>
SignalNominated
(
conn
)
;
}
void
OnSelectedCandidatePairChanged
(
IceTransportInternal
*
transport_channel
CandidatePairInterface
*
selected_candidate_pair
int
last_sent_packet_id
bool
ready_to_send
)
{
last_selected_candidate_pair_
=
selected_candidate_pair
;
last_sent_packet_id_
=
last_sent_packet_id
;
+
+
selected_candidate_pair_switches_
;
}
void
ReceivePingOnConnection
(
Connection
*
conn
const
std
:
:
string
&
remote_ufrag
int
priority
uint32_t
nomination
=
0
)
{
IceMessage
msg
;
msg
.
SetType
(
STUN_BINDING_REQUEST
)
;
msg
.
AddAttribute
(
new
StunByteStringAttribute
(
STUN_ATTR_USERNAME
conn
-
>
local_candidate
(
)
.
username
(
)
+
"
:
"
+
remote_ufrag
)
)
;
msg
.
AddAttribute
(
new
StunUInt32Attribute
(
STUN_ATTR_PRIORITY
priority
)
)
;
if
(
nomination
!
=
0
)
{
msg
.
AddAttribute
(
new
StunUInt32Attribute
(
STUN_ATTR_NOMINATION
nomination
)
)
;
}
msg
.
SetTransactionID
(
rtc
:
:
CreateRandomString
(
kStunTransactionIdLength
)
)
;
msg
.
AddMessageIntegrity
(
conn
-
>
local_candidate
(
)
.
password
(
)
)
;
msg
.
AddFingerprint
(
)
;
rtc
:
:
ByteBufferWriter
buf
;
msg
.
Write
(
&
buf
)
;
conn
-
>
OnReadPacket
(
buf
.
Data
(
)
buf
.
Length
(
)
rtc
:
:
CreatePacketTime
(
0
)
)
;
}
void
OnReadyToSend
(
rtc
:
:
PacketTransportInterface
*
transport
)
{
channel_ready_to_send_
=
true
;
}
void
OnChannelStateChanged
(
IceTransportInternal
*
channel
)
{
channel_state_
=
channel
-
>
GetState
(
)
;
}
CandidatePairInterface
*
last_selected_candidate_pair
(
)
{
return
last_selected_candidate_pair_
;
}
int
last_sent_packet_id
(
)
{
return
last_sent_packet_id_
;
}
bool
channel_ready_to_send
(
)
{
return
channel_ready_to_send_
;
}
void
reset_channel_ready_to_send
(
)
{
channel_ready_to_send_
=
false
;
}
IceTransportState
channel_state
(
)
{
return
channel_state_
;
}
int
reset_selected_candidate_pair_switches
(
)
{
int
switches
=
selected_candidate_pair_switches_
;
selected_candidate_pair_switches_
=
0
;
return
switches
;
}
private
:
std
:
:
unique_ptr
<
rtc
:
:
PhysicalSocketServer
>
pss_
;
std
:
:
unique_ptr
<
rtc
:
:
VirtualSocketServer
>
vss_
;
rtc
:
:
SocketServerScope
ss_scope_
;
CandidatePairInterface
*
last_selected_candidate_pair_
=
nullptr
;
int
selected_candidate_pair_switches_
=
0
;
int
last_sent_packet_id_
=
-
1
;
bool
channel_ready_to_send_
=
false
;
IceTransportState
channel_state_
=
IceTransportState
:
:
STATE_INIT
;
}
;
TEST_F
(
P2PTransportChannelPingTest
TestTriggeredChecks
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
trigger
checks
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
conn2
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
conn1
-
>
ReceivedPing
(
)
;
EXPECT_EQ
(
conn1
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestAllConnectionsPingedSufficiently
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
ping
sufficiently
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE_WAIT
(
conn1
-
>
num_pings_sent
(
)
>
=
MIN_PINGS_AT_WEAK_PING_INTERVAL
&
&
conn2
-
>
num_pings_sent
(
)
>
=
MIN_PINGS_AT_WEAK_PING_INTERVAL
kDefaultTimeout
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestStunPingIntervals
)
{
rtc
:
:
ScopedFakeClock
clock
;
int
RTT_RATIO
=
4
;
int
SCHEDULING_RANGE
=
200
;
int
RTT_RANGE
=
10
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
TestChannel
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
1
kDefaultTimeout
clock
)
;
int64_t
start
=
clock
.
TimeNanos
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
>
=
MIN_PINGS_AT_WEAK_PING_INTERVAL
kDefaultTimeout
clock
)
;
int64_t
ping_interval_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
rtc
:
:
kNumNanosecsPerMillisec
/
(
MIN_PINGS_AT_WEAK_PING_INTERVAL
-
1
)
;
EXPECT_EQ
(
ping_interval_ms
WEAK_PING_INTERVAL
)
;
conn
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
int
ping_sent_before
=
conn
-
>
num_pings_sent
(
)
;
start
=
clock
.
TimeNanos
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
ping_sent_before
+
1
kMediumTimeout
clock
)
;
ping_interval_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
rtc
:
:
kNumNanosecsPerMillisec
;
EXPECT_GE
(
ping_interval_ms
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
)
;
EXPECT_LE
(
ping_interval_ms
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
+
SCHEDULING_RANGE
)
;
for
(
int
i
=
0
;
i
<
RTT_RATIO
;
i
+
+
)
{
conn
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
}
ping_sent_before
=
conn
-
>
num_pings_sent
(
)
;
start
=
clock
.
TimeNanos
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
ping_sent_before
+
1
kMediumTimeout
clock
)
;
ping_interval_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
rtc
:
:
kNumNanosecsPerMillisec
;
EXPECT_GE
(
ping_interval_ms
STRONG_AND_STABLE_WRITABLE_CONNECTION_PING_INTERVAL
)
;
EXPECT_LE
(
ping_interval_ms
STRONG_AND_STABLE_WRITABLE_CONNECTION_PING_INTERVAL
+
SCHEDULING_RANGE
)
;
conn
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
conn
-
>
Ping
(
clock
.
TimeNanos
(
)
/
rtc
:
:
kNumNanosecsPerMillisec
)
;
start
=
clock
.
TimeNanos
(
)
;
SIMULATED_WAIT
(
!
conn
-
>
stable
(
clock
.
TimeNanos
(
)
/
rtc
:
:
kNumNanosecsPerMillisec
)
kMediumTimeout
clock
)
;
int64_t
duration_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
rtc
:
:
kNumNanosecsPerMillisec
;
EXPECT_GE
(
duration_ms
2
*
conn
-
>
rtt
(
)
-
RTT_RANGE
)
;
EXPECT_LE
(
duration_ms
2
*
conn
-
>
rtt
(
)
+
RTT_RANGE
)
;
ping_sent_before
=
conn
-
>
num_pings_sent
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
ping_sent_before
+
1
kMediumTimeout
clock
)
;
start
=
clock
.
TimeNanos
(
)
;
ping_sent_before
=
conn
-
>
num_pings_sent
(
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
=
=
ping_sent_before
+
1
kMediumTimeout
clock
)
;
ping_interval_ms
=
(
clock
.
TimeNanos
(
)
-
start
)
/
rtc
:
:
kNumNanosecsPerMillisec
;
EXPECT_GE
(
ping_interval_ms
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
)
;
EXPECT_LE
(
ping_interval_ms
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
+
SCHEDULING_RANGE
)
;
}
TEST_F
(
P2PTransportChannelPingTest
PingingStartedAsSoonAsPossible
)
{
rtc
:
:
ScopedFakeClock
clock
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
TestChannel
"
1
&
pa
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLING
)
;
ch
.
SetIceParameters
(
kIceParams
[
0
]
)
;
ch
.
MaybeStartGathering
(
)
;
EXPECT_EQ_WAIT
(
IceGatheringState
:
:
kIceGatheringComplete
ch
.
gathering_state
(
)
kDefaultTimeout
)
;
IceMessage
request
;
request
.
SetType
(
STUN_BINDING_REQUEST
)
;
request
.
AddAttribute
(
new
StunByteStringAttribute
(
STUN_ATTR_USERNAME
kIceUfrag
[
1
]
)
)
;
uint32_t
prflx_priority
=
ICE_TYPE_PREFERENCE_PRFLX
<
<
24
;
request
.
AddAttribute
(
new
StunUInt32Attribute
(
STUN_ATTR_PRIORITY
prflx_priority
)
)
;
Port
*
port
=
GetPort
(
&
ch
)
;
ASSERT_NE
(
nullptr
port
)
;
port
-
>
SignalUnknownAddress
(
port
rtc
:
:
SocketAddress
(
"
1
.
1
.
1
.
1
"
1
)
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn
=
GetConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_NE
(
nullptr
conn
)
;
SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
>
0
1025
clock
)
;
EXPECT_EQ
(
0
conn
-
>
num_pings_sent
(
)
)
;
ch
.
SetRemoteIceParameters
(
kIceParams
[
1
]
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
conn
-
>
num_pings_sent
(
)
>
0
1
clock
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestNoTriggeredChecksWhenWritable
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
trigger
checks
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
conn2
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
EXPECT_EQ
(
conn1
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
ASSERT_TRUE
(
conn1
-
>
writable
(
)
)
;
conn1
-
>
ReceivedPing
(
)
;
EXPECT_EQ
(
conn2
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestFailedConnectionNotPingable
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
Do
not
ping
failed
connections
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
conn1
ch
.
FindNextPingableConnection
(
)
)
;
conn1
-
>
Prune
(
)
;
EXPECT_EQ
(
conn1
ch
.
FindNextPingableConnection
(
)
)
;
conn1
-
>
FailAndPrune
(
)
;
EXPECT_TRUE
(
nullptr
=
=
ch
.
FindNextPingableConnection
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestSignalStateChanged
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
state
change
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
Prune
(
)
;
EXPECT_EQ_WAIT
(
IceTransportState
:
:
STATE_FAILED
channel_state
(
)
kDefaultTimeout
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestAddRemoteCandidateWithVariousUfrags
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
add
candidate
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
kIceUfrag
[
2
]
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
const
Candidate
&
candidate
=
conn1
-
>
remote_candidate
(
)
;
EXPECT_EQ
(
kIceUfrag
[
2
]
candidate
.
username
(
)
)
;
EXPECT_TRUE
(
candidate
.
password
(
)
.
empty
(
)
)
;
EXPECT_TRUE
(
FindNextPingableConnectionAndPingIt
(
&
ch
)
=
=
nullptr
)
;
ch
.
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
EXPECT_EQ
(
kIceUfrag
[
2
]
candidate
.
username
(
)
)
;
EXPECT_EQ
(
kIcePwd
[
2
]
candidate
.
password
(
)
)
;
EXPECT_EQ
(
conn1
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
2
kIceUfrag
[
1
]
)
)
;
rtc
:
:
Thread
:
:
Current
(
)
-
>
ProcessMessages
(
500
)
;
EXPECT_TRUE
(
GetConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
=
=
nullptr
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
3
.
3
.
3
.
3
"
3
0
kIceUfrag
[
2
]
)
)
;
Connection
*
conn3
=
nullptr
;
ASSERT_TRUE_WAIT
(
(
conn3
=
GetConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
)
)
!
=
nullptr
kMediumTimeout
)
;
const
Candidate
&
new_candidate
=
conn3
-
>
remote_candidate
(
)
;
EXPECT_EQ
(
kIcePwd
[
2
]
new_candidate
.
password
(
)
)
;
EXPECT_EQ
(
1U
new_candidate
.
generation
(
)
)
;
for
(
const
RemoteCandidate
&
candidate
:
ch
.
remote_candidates
(
)
)
{
EXPECT_TRUE
(
candidate
.
username
(
)
=
=
kIceUfrag
[
1
]
|
|
candidate
.
username
(
)
=
=
kIceUfrag
[
2
]
)
;
if
(
candidate
.
username
(
)
=
=
kIceUfrag
[
1
]
)
{
EXPECT_EQ
(
kIcePwd
[
1
]
candidate
.
password
(
)
)
;
}
else
if
(
candidate
.
username
(
)
=
=
kIceUfrag
[
2
]
)
{
EXPECT_EQ
(
kIcePwd
[
2
]
candidate
.
password
(
)
)
;
}
}
}
TEST_F
(
P2PTransportChannelPingTest
ConnectionResurrection
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
connection
resurrection
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
uint32_t
remote_priority
=
conn1
-
>
remote_candidate
(
)
.
priority
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
2
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPing
(
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE_WAIT
(
conn1
-
>
pruned
(
)
kMediumTimeout
)
;
conn1
-
>
Destroy
(
)
;
EXPECT_TRUE_WAIT
(
GetConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
=
=
nullptr
kMediumTimeout
)
;
IceMessage
request
;
request
.
SetType
(
STUN_BINDING_REQUEST
)
;
request
.
AddAttribute
(
new
StunByteStringAttribute
(
STUN_ATTR_USERNAME
kIceUfrag
[
1
]
)
)
;
uint32_t
prflx_priority
=
ICE_TYPE_PREFERENCE_PRFLX
<
<
24
;
request
.
AddAttribute
(
new
StunUInt32Attribute
(
STUN_ATTR_PRIORITY
prflx_priority
)
)
;
EXPECT_NE
(
prflx_priority
remote_priority
)
;
Port
*
port
=
GetPort
(
&
ch
)
;
port
-
>
SignalUnknownAddress
(
port
rtc
:
:
SocketAddress
(
"
1
.
1
.
1
.
1
"
1
)
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
conn1
-
>
remote_candidate
(
)
.
priority
(
)
remote_priority
)
;
port
-
>
SignalUnknownAddress
(
port
rtc
:
:
SocketAddress
(
"
3
.
3
.
3
.
3
"
1
)
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
1
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
EXPECT_EQ
(
conn3
-
>
remote_candidate
(
)
.
priority
(
)
prflx_priority
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestReceivingStateChange
)
{
rtc
:
:
ScopedFakeClock
clock
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
EXPECT_LE
(
1000
ch
.
receiving_timeout
(
)
)
;
EXPECT_LE
(
200
ch
.
check_receiving_interval
(
)
)
;
ch
.
SetIceConfig
(
CreateIceConfig
(
500
GATHER_ONCE
)
)
;
EXPECT_EQ
(
500
ch
.
receiving_timeout
(
)
)
;
EXPECT_EQ
(
50
ch
.
check_receiving_interval
(
)
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
clock
.
AdvanceTime
(
rtc
:
:
TimeDelta
:
:
FromSeconds
(
1
)
)
;
conn1
-
>
ReceivedPing
(
)
;
conn1
-
>
OnReadPacket
(
"
ABC
"
3
rtc
:
:
CreatePacketTime
(
0
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ch
.
receiving
(
)
kShortTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
ch
.
receiving
(
)
kShortTimeout
clock
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestSelectConnectionBeforeNomination
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_FALSE
(
channel_ready_to_send
(
)
)
;
int
last_packet_id
=
0
;
const
char
*
data
=
"
ABCDEFGH
"
;
int
len
=
static_cast
<
int
>
(
strlen
(
data
)
)
;
EXPECT_EQ
(
-
1
SendData
(
ch
data
len
+
+
last_packet_id
)
)
;
EXPECT_EQ
(
-
1
last_sent_packet_id
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_WAIT
(
conn1
ch
.
selected_connection
(
)
kDefaultTimeout
)
;
EXPECT_EQ
(
conn1
last_selected_candidate_pair
(
)
)
;
EXPECT_EQ
(
len
SendData
(
ch
data
len
+
+
last_packet_id
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
10
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_WAIT
(
conn2
ch
.
selected_connection
(
)
kDefaultTimeout
)
;
EXPECT_EQ
(
conn2
last_selected_candidate_pair
(
)
)
;
EXPECT_TRUE
(
channel_ready_to_send
(
)
)
;
EXPECT_EQ
(
last_packet_id
last_sent_packet_id
(
)
)
;
EXPECT_EQ
(
len
SendData
(
ch
data
len
+
+
last_packet_id
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
3
.
3
.
3
.
3
"
3
1
)
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
conn3
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
NominateConnection
(
conn3
)
;
EXPECT_EQ
(
conn3
ch
.
selected_connection
(
)
)
;
EXPECT_EQ
(
conn3
last_selected_candidate_pair
(
)
)
;
EXPECT_EQ
(
last_packet_id
last_sent_packet_id
(
)
)
;
EXPECT_TRUE
(
channel_ready_to_send
(
)
)
;
EXPECT_EQ
(
len
SendData
(
ch
data
len
+
+
last_packet_id
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
4
.
4
.
4
.
4
"
4
100
)
)
;
Connection
*
conn4
=
WaitForConnectionTo
(
&
ch
"
4
.
4
.
4
.
4
"
4
)
;
ASSERT_TRUE
(
conn4
!
=
nullptr
)
;
EXPECT_EQ
(
conn3
ch
.
selected_connection
(
)
)
;
NominateConnection
(
conn4
)
;
EXPECT_EQ
(
conn3
ch
.
selected_connection
(
)
)
;
reset_channel_ready_to_send
(
)
;
conn4
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_WAIT
(
conn4
ch
.
selected_connection
(
)
kDefaultTimeout
)
;
EXPECT_EQ
(
conn4
last_selected_candidate_pair
(
)
)
;
EXPECT_EQ
(
last_packet_id
last_sent_packet_id
(
)
)
;
EXPECT_TRUE
(
channel_ready_to_send
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestSelectConnectionFromUnknownAddress
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
IceMessage
request
;
request
.
SetType
(
STUN_BINDING_REQUEST
)
;
request
.
AddAttribute
(
new
StunByteStringAttribute
(
STUN_ATTR_USERNAME
kIceUfrag
[
1
]
)
)
;
uint32_t
prflx_priority
=
ICE_TYPE_PREFERENCE_PRFLX
<
<
24
;
request
.
AddAttribute
(
new
StunUInt32Attribute
(
STUN_ATTR_PRIORITY
prflx_priority
)
)
;
TestUDPPort
*
port
=
static_cast
<
TestUDPPort
*
>
(
GetPort
(
&
ch
)
)
;
port
-
>
SignalUnknownAddress
(
port
rtc
:
:
SocketAddress
(
"
1
.
1
.
1
.
1
"
1
)
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_TRUE
(
port
-
>
sent_binding_response
(
)
)
;
EXPECT_NE
(
conn1
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_WAIT
(
conn1
ch
.
selected_connection
(
)
kDefaultTimeout
)
;
port
-
>
set_sent_binding_response
(
false
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
1
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
conn1
ch
.
selected_connection
(
)
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
NominateConnection
(
conn2
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
port
-
>
SignalUnknownAddress
(
port
rtc
:
:
SocketAddress
(
"
3
.
3
.
3
.
3
"
3
)
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
EXPECT_TRUE
(
port
-
>
sent_binding_response
(
)
)
;
conn3
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
port
-
>
set_sent_binding_response
(
false
)
;
request
.
AddAttribute
(
new
StunByteStringAttribute
(
STUN_ATTR_USE_CANDIDATE
)
)
;
port
-
>
SignalUnknownAddress
(
port
rtc
:
:
SocketAddress
(
"
4
.
4
.
4
.
4
"
4
)
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn4
=
WaitForConnectionTo
(
&
ch
"
4
.
4
.
4
.
4
"
4
)
;
ASSERT_TRUE
(
conn4
!
=
nullptr
)
;
EXPECT_TRUE
(
port
-
>
sent_binding_response
(
)
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
conn4
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_WAIT
(
conn4
ch
.
selected_connection
(
)
kDefaultTimeout
)
;
port
-
>
set_sent_binding_response
(
false
)
;
ch
.
SetRemoteIceParameters
(
kIceParams
[
2
]
)
;
ch
.
SetRemoteIceParameters
(
kIceParams
[
3
]
)
;
port
-
>
SignalUnknownAddress
(
port
rtc
:
:
SocketAddress
(
"
5
.
5
.
5
.
5
"
5
)
PROTO_UDP
&
request
kIceUfrag
[
2
]
false
)
;
Connection
*
conn5
=
WaitForConnectionTo
(
&
ch
"
5
.
5
.
5
.
5
"
5
)
;
ASSERT_TRUE
(
conn5
!
=
nullptr
)
;
EXPECT_TRUE
(
port
-
>
sent_binding_response
(
)
)
;
EXPECT_EQ
(
kIcePwd
[
2
]
conn5
-
>
remote_candidate
(
)
.
password
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestSelectConnectionBasedOnMediaReceived
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
receiving
state
change
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
10
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_WAIT
(
conn1
ch
.
selected_connection
(
)
kDefaultTimeout
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
1
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
conn2
-
>
OnReadPacket
(
"
ABC
"
3
rtc
:
:
CreatePacketTime
(
0
)
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
IceMessage
request
;
request
.
SetType
(
STUN_BINDING_REQUEST
)
;
request
.
AddAttribute
(
new
StunByteStringAttribute
(
STUN_ATTR_USERNAME
kIceUfrag
[
1
]
)
)
;
uint32_t
prflx_priority
=
ICE_TYPE_PREFERENCE_PRFLX
<
<
24
;
request
.
AddAttribute
(
new
StunUInt32Attribute
(
STUN_ATTR_PRIORITY
prflx_priority
)
)
;
request
.
AddAttribute
(
new
StunByteStringAttribute
(
STUN_ATTR_USE_CANDIDATE
)
)
;
Port
*
port
=
GetPort
(
&
ch
)
;
port
-
>
SignalUnknownAddress
(
port
rtc
:
:
SocketAddress
(
"
3
.
3
.
3
.
3
"
3
)
PROTO_UDP
&
request
kIceUfrag
[
1
]
false
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
EXPECT_EQ
(
conn2
ch
.
selected_connection
(
)
)
;
conn3
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_WAIT
(
conn3
ch
.
selected_connection
(
)
kDefaultTimeout
)
;
conn2
-
>
ReceivedPing
(
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
conn2
-
>
OnReadPacket
(
"
XYZ
"
3
rtc
:
:
CreatePacketTime
(
0
)
)
;
EXPECT_EQ_WAIT
(
conn3
ch
.
selected_connection
(
)
kDefaultTimeout
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentDataReceivingTakesHigherPrecedenceThanPriority
)
{
rtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
rtc
:
:
TimeDelta
:
:
FromSeconds
(
1
)
)
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
SwitchSelectedConnection
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
ch
clock
"
1
.
1
.
1
.
1
"
1
10
true
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
ch
clock
"
2
.
2
.
2
.
2
"
2
9
true
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn1
last_selected_candidate_pair
(
)
)
;
SIMULATED_WAIT
(
false
1
clock
)
;
conn2
-
>
OnReadPacket
(
"
XYZ
"
3
rtc
:
:
CreatePacketTime
(
0
)
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn2
last_selected_candidate_pair
(
)
)
;
conn1
-
>
OnReadPacket
(
"
XYZ
"
3
rtc
:
:
CreatePacketTime
(
0
)
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn1
last_selected_candidate_pair
(
)
)
;
SIMULATED_WAIT
(
false
1
clock
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
conn2
-
>
OnReadPacket
(
"
XYZ
"
3
rtc
:
:
CreatePacketTime
(
0
)
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn2
last_selected_candidate_pair
(
)
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentNominationTakesHigherPrecedenceThanDataReceiving
)
{
rtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
rtc
:
:
TimeDelta
:
:
FromSeconds
(
1
)
)
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
SwitchSelectedConnection
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
ch
clock
"
1
.
1
.
1
.
1
"
1
10
true
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
ch
clock
"
2
.
2
.
2
.
2
"
2
9
true
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
SIMULATED_WAIT
(
false
1
clock
)
;
conn1
-
>
OnReadPacket
(
"
XYZ
"
3
rtc
:
:
CreatePacketTime
(
0
)
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn1
last_selected_candidate_pair
(
)
)
;
NominateConnection
(
conn2
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn2
last_selected_candidate_pair
(
)
)
;
NominateConnection
(
conn1
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn1
last_selected_candidate_pair
(
)
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentSelectsConnectionWithHigherNomination
)
{
rtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
rtc
:
:
TimeDelta
:
:
FromSeconds
(
1
)
)
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
ch
clock
"
1
.
1
.
1
.
1
"
1
10
true
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
ch
clock
"
2
.
2
.
2
.
2
"
2
9
true
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ_SIMULATED_WAIT
(
conn1
last_selected_candidate_pair
(
)
kDefaultTimeout
clock
)
;
reset_selected_candidate_pair_switches
(
)
;
NominateConnection
(
conn2
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn2
last_selected_candidate_pair
(
)
)
;
NominateConnection
(
conn1
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn1
last_selected_candidate_pair
(
)
)
;
NominateConnection
(
conn2
2U
)
;
EXPECT_EQ
(
1
reset_selected_candidate_pair_switches
(
)
)
;
EXPECT_EQ
(
conn2
last_selected_candidate_pair
(
)
)
;
SIMULATED_WAIT
(
false
100
clock
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentIgnoresSmallerNomination
)
{
rtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
rtc
:
:
TimeDelta
:
:
FromSeconds
(
1
)
)
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn
=
CreateConnectionWithCandidate
(
ch
clock
"
1
.
1
.
1
.
1
"
1
10
false
)
;
ReceivePingOnConnection
(
conn
kIceUfrag
[
1
]
1
2U
)
;
EXPECT_EQ
(
2U
conn
-
>
remote_nomination
(
)
)
;
ReceivePingOnConnection
(
conn
kIceUfrag
[
1
]
1
1U
)
;
EXPECT_EQ
(
2U
conn
-
>
remote_nomination
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestControlledAgentWriteStateTakesHigherPrecedenceThanNomination
)
{
rtc
:
:
ScopedFakeClock
clock
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
SwitchSelectedConnection
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
ch
clock
"
1
.
1
.
1
.
1
"
1
10
false
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
ch
clock
"
2
.
2
.
2
.
2
"
2
9
false
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
NominateConnection
(
conn1
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_SIMULATED_WAIT
(
1
reset_selected_candidate_pair_switches
(
)
kDefaultTimeout
clock
)
;
EXPECT_EQ_SIMULATED_WAIT
(
conn2
last_selected_candidate_pair
(
)
kDefaultTimeout
clock
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_SIMULATED_WAIT
(
1
reset_selected_candidate_pair_switches
(
)
kDefaultTimeout
clock
)
;
EXPECT_EQ_SIMULATED_WAIT
(
conn1
last_selected_candidate_pair
(
)
kDefaultTimeout
clock
)
;
SIMULATED_WAIT
(
false
10
clock
)
;
EXPECT_EQ
(
0
reset_selected_candidate_pair_switches
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestAddRemoteCandidateWithAddressReuse
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
candidate
reuse
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
const
std
:
:
string
host_address
=
"
1
.
1
.
1
.
1
"
;
const
int
port_num
=
1
;
Candidate
candidate
=
CreateUdpCandidate
(
LOCAL_PORT_TYPE
host_address
port_num
1
kIceUfrag
[
1
]
)
;
ch
.
AddRemoteCandidate
(
candidate
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
host_address
port_num
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
0u
conn1
-
>
remote_candidate
(
)
.
generation
(
)
)
;
ch
.
AddRemoteCandidate
(
candidate
)
;
Connection
*
conn2
=
GetConnectionTo
(
&
ch
host_address
port_num
)
;
EXPECT_EQ
(
conn1
conn2
)
;
candidate
.
set_username
(
kIceUfrag
[
2
]
)
;
ch
.
AddRemoteCandidate
(
candidate
)
;
conn2
=
GetConnectionTo
(
&
ch
host_address
port_num
)
;
EXPECT_NE
(
conn1
conn2
)
;
EXPECT_EQ
(
kIceUfrag
[
2
]
conn2
-
>
remote_candidate
(
)
.
username
(
)
)
;
EXPECT_EQ
(
1u
conn2
-
>
remote_candidate
(
)
.
generation
(
)
)
;
EXPECT_EQ
(
0
conn2
-
>
last_ping_received
(
)
)
;
ReceivePingOnConnection
(
conn2
kIceUfrag
[
2
]
1
)
;
EXPECT_TRUE
(
conn2
-
>
last_ping_received
(
)
>
0
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestDontPruneWhenWeak
)
{
rtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
rtc
:
:
TimeDelta
:
:
FromSeconds
(
1
)
)
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
nullptr
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
10
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
NominateConnection
(
conn2
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
conn1
-
>
pruned
(
)
kMediumTimeout
clock
)
;
ch
.
SetIceConfig
(
CreateIceConfig
(
500
GATHER_ONCE
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
conn2
-
>
receiving
(
)
kMediumTimeout
clock
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
3
.
3
.
3
.
3
"
3
1
)
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
&
clock
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
SIMULATED_WAIT
(
conn3
-
>
pruned
(
)
kShortTimeout
clock
)
;
EXPECT_FALSE
(
conn3
-
>
pruned
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestDontPruneHighPriorityConnections
)
{
rtc
:
:
ScopedFakeClock
clock
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
Connection
*
conn1
=
CreateConnectionWithCandidate
(
ch
clock
"
1
.
1
.
1
.
1
"
1
100
true
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
Connection
*
conn2
=
CreateConnectionWithCandidate
(
ch
clock
"
2
.
2
.
2
.
2
"
2
200
false
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
NominateConnection
(
conn1
)
;
SIMULATED_WAIT
(
false
1
clock
)
;
conn1
-
>
OnReadPacket
(
"
XYZ
"
3
rtc
:
:
CreatePacketTime
(
0
)
)
;
SIMULATED_WAIT
(
conn2
-
>
pruned
(
)
100
clock
)
;
EXPECT_FALSE
(
conn2
-
>
pruned
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestGetState
)
{
rtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
rtc
:
:
TimeDelta
:
:
FromSeconds
(
1
)
)
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_INIT
ch
.
GetState
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
100
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
1
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_CONNECTING
ch
.
GetState
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
conn2
-
>
pruned
(
)
kShortTimeout
clock
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_COMPLETED
ch
.
GetState
(
)
)
;
conn1
-
>
Prune
(
)
;
EXPECT_EQ_SIMULATED_WAIT
(
IceTransportState
:
:
STATE_FAILED
ch
.
GetState
(
)
kShortTimeout
clock
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestConnectionPrunedAgain
)
{
rtc
:
:
ScopedFakeClock
clock
;
clock
.
AdvanceTime
(
rtc
:
:
TimeDelta
:
:
FromSeconds
(
1
)
)
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_ONCE
)
;
config
.
receiving_switching_delay
=
rtc
:
:
Optional
<
int
>
(
800
)
;
ch
.
SetIceConfig
(
config
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
EXPECT_EQ
(
nullptr
ch
.
selected_connection
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_SIMULATED_WAIT
(
conn1
ch
.
selected_connection
(
)
kDefaultTimeout
clock
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
1
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
conn2
-
>
active
(
)
kDefaultTimeout
clock
)
;
EXPECT_EQ
(
IceCandidatePairState
:
:
WAITING
conn2
-
>
state
(
)
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_COMPLETED
ch
.
GetState
(
)
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
conn1
-
>
receiving
(
)
kMediumTimeout
clock
)
;
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
EXPECT_EQ_SIMULATED_WAIT
(
IceCandidatePairState
:
:
IN_PROGRESS
conn2
-
>
state
(
)
kDefaultTimeout
clock
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_SIMULATED_WAIT
(
conn2
ch
.
selected_connection
(
)
kDefaultTimeout
clock
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_CONNECTING
ch
.
GetState
(
)
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_EQ_SIMULATED_WAIT
(
conn1
ch
.
selected_connection
(
)
kDefaultTimeout
clock
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
!
conn2
-
>
active
(
)
kDefaultTimeout
clock
)
;
EXPECT_EQ
(
IceTransportState
:
:
STATE_COMPLETED
ch
.
GetState
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestDeleteConnectionsIfAllWriteTimedout
)
{
rtc
:
:
ScopedFakeClock
clock
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
&
clock
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
ReceivedPing
(
)
;
conn1
-
>
Prune
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ch
.
connections
(
)
.
empty
(
)
kShortTimeout
clock
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
1
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
&
clock
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPing
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
3
.
3
.
3
.
3
"
3
2
)
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
3
.
3
.
3
.
3
"
3
&
clock
)
;
ASSERT_TRUE
(
conn3
!
=
nullptr
)
;
conn3
-
>
ReceivedPing
(
)
;
conn2
-
>
Prune
(
)
;
conn3
-
>
Prune
(
)
;
EXPECT_TRUE_SIMULATED_WAIT
(
ch
.
connections
(
)
.
empty
(
)
kShortTimeout
clock
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestStopPortAllocatorSessions
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
channel
"
1
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceConfig
(
CreateIceConfig
(
2000
GATHER_ONCE
)
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
100
)
)
;
Connection
*
conn1
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn1
!
=
nullptr
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE
(
!
ch
.
allocator_session
(
)
-
>
IsGettingPorts
(
)
)
;
ch
.
SetIceParameters
(
kIceParams
[
1
]
)
;
ch
.
MaybeStartGathering
(
)
;
conn1
-
>
Prune
(
)
;
conn1
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE
(
ch
.
allocator_session
(
)
-
>
IsGettingPorts
(
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
100
)
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
ASSERT_TRUE
(
conn2
!
=
nullptr
)
;
conn2
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
EXPECT_TRUE
(
!
ch
.
allocator_session
(
)
-
>
IsGettingPorts
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestIceRoleUpdatedOnRemovedPort
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
channel
"
ICE_CANDIDATE_COMPONENT_DEFAULT
&
pa
)
;
PrepareChannel
(
&
ch
)
;
IceConfig
config
=
CreateIceConfig
(
1000
GATHER_CONTINUALLY
)
;
ch
.
SetIceConfig
(
config
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
std
:
:
vector
<
PortInterface
*
>
ports
(
1
conn
-
>
port
(
)
)
;
ch
.
allocator_session
(
)
-
>
SignalPortsPruned
(
ch
.
allocator_session
(
)
ports
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
EXPECT_EQ
(
ICEROLE_CONTROLLED
conn
-
>
port
(
)
-
>
GetIceRole
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestIceRoleUpdatedOnPortAfterIceRestart
)
{
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
channel
"
ICE_CANDIDATE_COMPONENT_DEFAULT
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
ch
.
SetIceParameters
(
kIceParams
[
1
]
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
EXPECT_EQ
(
ICEROLE_CONTROLLED
conn
-
>
port
(
)
-
>
GetIceRole
(
)
)
;
}
TEST_F
(
P2PTransportChannelPingTest
TestPortDestroyedAfterTimeoutAndPruned
)
{
rtc
:
:
ScopedFakeClock
fake_clock
;
FakePortAllocator
pa
(
rtc
:
:
Thread
:
:
Current
(
)
nullptr
)
;
P2PTransportChannel
ch
(
"
test
channel
"
ICE_CANDIDATE_COMPONENT_DEFAULT
&
pa
)
;
PrepareChannel
(
&
ch
)
;
ch
.
SetIceRole
(
ICEROLE_CONTROLLED
)
;
ch
.
MaybeStartGathering
(
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
Connection
*
conn
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
ASSERT_TRUE
(
conn
!
=
nullptr
)
;
for
(
int
second
=
0
;
second
<
120
;
+
+
second
)
{
fake_clock
.
AdvanceTime
(
rtc
:
:
TimeDelta
:
:
FromSeconds
(
1
)
)
;
}
EXPECT_EQ
(
nullptr
GetConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
)
;
PortInterface
*
port
=
GetPort
(
&
ch
)
;
ASSERT_NE
(
nullptr
port
)
;
ch
.
allocator_session
(
)
-
>
PruneAllPorts
(
)
;
EXPECT_EQ_SIMULATED_WAIT
(
nullptr
GetPort
(
&
ch
)
1
fake_clock
)
;
EXPECT_EQ_SIMULATED_WAIT
(
nullptr
GetPrunedPort
(
&
ch
)
1
fake_clock
)
;
}
class
P2PTransportChannelMostLikelyToWorkFirstTest
:
public
P2PTransportChannelPingTest
{
public
:
P2PTransportChannelMostLikelyToWorkFirstTest
(
)
:
turn_server_
(
rtc
:
:
Thread
:
:
Current
(
)
kTurnUdpIntAddr
kTurnUdpExtAddr
)
{
network_manager_
.
AddInterface
(
kPublicAddrs
[
0
]
)
;
allocator_
.
reset
(
CreateBasicPortAllocator
(
&
network_manager_
ServerAddresses
(
)
kTurnUdpIntAddr
rtc
:
:
SocketAddress
(
)
)
)
;
allocator_
-
>
set_flags
(
allocator_
-
>
flags
(
)
|
PORTALLOCATOR_DISABLE_STUN
|
PORTALLOCATOR_DISABLE_TCP
)
;
allocator_
-
>
set_step_delay
(
kMinimumStepDelay
)
;
}
P2PTransportChannel
&
StartTransportChannel
(
bool
prioritize_most_likely_to_work
int
stable_writable_connection_ping_interval
)
{
channel_
.
reset
(
new
P2PTransportChannel
(
"
checks
"
1
allocator
(
)
)
)
;
IceConfig
config
=
channel_
-
>
config
(
)
;
config
.
prioritize_most_likely_candidate_pairs
=
prioritize_most_likely_to_work
;
config
.
stable_writable_connection_ping_interval
=
stable_writable_connection_ping_interval
;
channel_
-
>
SetIceConfig
(
config
)
;
PrepareChannel
(
channel_
.
get
(
)
)
;
channel_
-
>
MaybeStartGathering
(
)
;
return
*
channel_
.
get
(
)
;
}
BasicPortAllocator
*
allocator
(
)
{
return
allocator_
.
get
(
)
;
}
TestTurnServer
*
turn_server
(
)
{
return
&
turn_server_
;
}
void
VerifyNextPingableConnection
(
const
std
:
:
string
&
local_candidate_type
const
std
:
:
string
&
remote_candidate_type
const
std
:
:
string
&
relay_protocol_type
=
UDP_PROTOCOL_NAME
)
{
Connection
*
conn
=
FindNextPingableConnectionAndPingIt
(
channel_
.
get
(
)
)
;
EXPECT_EQ
(
conn
-
>
local_candidate
(
)
.
type
(
)
local_candidate_type
)
;
if
(
conn
-
>
local_candidate
(
)
.
type
(
)
=
=
RELAY_PORT_TYPE
)
{
EXPECT_EQ
(
conn
-
>
local_candidate
(
)
.
relay_protocol
(
)
relay_protocol_type
)
;
}
EXPECT_EQ
(
conn
-
>
remote_candidate
(
)
.
type
(
)
remote_candidate_type
)
;
}
private
:
std
:
:
unique_ptr
<
BasicPortAllocator
>
allocator_
;
rtc
:
:
FakeNetworkManager
network_manager_
;
TestTurnServer
turn_server_
;
std
:
:
unique_ptr
<
P2PTransportChannel
>
channel_
;
}
;
TEST_F
(
P2PTransportChannelMostLikelyToWorkFirstTest
TestRelayRelayFirstWhenNothingPingedYet
)
{
const
int
max_strong_interval
=
100
;
P2PTransportChannel
&
ch
=
StartTransportChannel
(
true
max_strong_interval
)
;
EXPECT_TRUE_WAIT
(
ch
.
ports
(
)
.
size
(
)
=
=
2
kDefaultTimeout
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
0
]
-
>
Type
(
)
LOCAL_PORT_TYPE
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
1
]
-
>
Type
(
)
RELAY_PORT_TYPE
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
RELAY_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
2
)
)
;
EXPECT_TRUE_WAIT
(
ch
.
connections
(
)
.
size
(
)
=
=
4
kDefaultTimeout
)
;
Connection
*
conn
=
FindNextPingableConnectionAndPingIt
(
&
ch
)
;
EXPECT_EQ
(
conn
-
>
local_candidate
(
)
.
type
(
)
RELAY_PORT_TYPE
)
;
EXPECT_EQ
(
conn
-
>
remote_candidate
(
)
.
type
(
)
RELAY_PORT_TYPE
)
;
Connection
*
conn2
=
WaitForConnectionTo
(
&
ch
"
2
.
2
.
2
.
2
"
2
)
;
EXPECT_EQ
(
conn2
-
>
local_candidate
(
)
.
type
(
)
LOCAL_PORT_TYPE
)
;
EXPECT_EQ
(
conn2
-
>
remote_candidate
(
)
.
type
(
)
LOCAL_PORT_TYPE
)
;
conn2
-
>
ReceivedPing
(
)
;
EXPECT_EQ
(
conn2
FindNextPingableConnectionAndPingIt
(
&
ch
)
)
;
Connection
*
conn3
=
WaitForConnectionTo
(
&
ch
"
1
.
1
.
1
.
1
"
1
)
;
EXPECT_EQ
(
conn3
-
>
local_candidate
(
)
.
type
(
)
LOCAL_PORT_TYPE
)
;
EXPECT_EQ
(
conn3
-
>
remote_candidate
(
)
.
type
(
)
RELAY_PORT_TYPE
)
;
conn3
-
>
ReceivedPingResponse
(
LOW_RTT
"
id
"
)
;
ASSERT_TRUE
(
conn3
-
>
writable
(
)
)
;
conn3
-
>
ReceivedPing
(
)
;
}
TEST_F
(
P2PTransportChannelMostLikelyToWorkFirstTest
TestRelayRelayFirstWhenEverythingPinged
)
{
P2PTransportChannel
&
ch
=
StartTransportChannel
(
true
100
)
;
EXPECT_TRUE_WAIT
(
ch
.
ports
(
)
.
size
(
)
=
=
2
kDefaultTimeout
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
0
]
-
>
Type
(
)
LOCAL_PORT_TYPE
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
1
]
-
>
Type
(
)
RELAY_PORT_TYPE
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
EXPECT_TRUE_WAIT
(
ch
.
connections
(
)
.
size
(
)
=
=
2
kDefaultTimeout
)
;
VerifyNextPingableConnection
(
LOCAL_PORT_TYPE
LOCAL_PORT_TYPE
)
;
VerifyNextPingableConnection
(
RELAY_PORT_TYPE
LOCAL_PORT_TYPE
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
RELAY_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
2
)
)
;
EXPECT_TRUE_WAIT
(
ch
.
connections
(
)
.
size
(
)
=
=
4
kDefaultTimeout
)
;
VerifyNextPingableConnection
(
RELAY_PORT_TYPE
RELAY_PORT_TYPE
)
;
VerifyNextPingableConnection
(
LOCAL_PORT_TYPE
RELAY_PORT_TYPE
)
;
VerifyNextPingableConnection
(
RELAY_PORT_TYPE
RELAY_PORT_TYPE
)
;
}
TEST_F
(
P2PTransportChannelMostLikelyToWorkFirstTest
TestNoStarvationOnNonRelayConnection
)
{
P2PTransportChannel
&
ch
=
StartTransportChannel
(
true
100
)
;
EXPECT_TRUE_WAIT
(
ch
.
ports
(
)
.
size
(
)
=
=
2
kDefaultTimeout
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
0
]
-
>
Type
(
)
LOCAL_PORT_TYPE
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
1
]
-
>
Type
(
)
RELAY_PORT_TYPE
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
RELAY_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
EXPECT_TRUE_WAIT
(
ch
.
connections
(
)
.
size
(
)
=
=
2
kDefaultTimeout
)
;
VerifyNextPingableConnection
(
RELAY_PORT_TYPE
RELAY_PORT_TYPE
)
;
VerifyNextPingableConnection
(
LOCAL_PORT_TYPE
RELAY_PORT_TYPE
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
LOCAL_PORT_TYPE
"
2
.
2
.
2
.
2
"
2
2
)
)
;
EXPECT_TRUE_WAIT
(
ch
.
connections
(
)
.
size
(
)
=
=
4
kDefaultTimeout
)
;
VerifyNextPingableConnection
(
LOCAL_PORT_TYPE
LOCAL_PORT_TYPE
)
;
VerifyNextPingableConnection
(
RELAY_PORT_TYPE
LOCAL_PORT_TYPE
)
;
VerifyNextPingableConnection
(
RELAY_PORT_TYPE
RELAY_PORT_TYPE
)
;
}
TEST_F
(
P2PTransportChannelMostLikelyToWorkFirstTest
TestTcpTurn
)
{
turn_server
(
)
-
>
AddInternalSocket
(
kTurnTcpIntAddr
PROTO_TCP
)
;
RelayServerConfig
config
(
RELAY_TURN
)
;
config
.
credentials
=
kRelayCredentials
;
config
.
ports
.
push_back
(
ProtocolAddress
(
kTurnTcpIntAddr
PROTO_TCP
)
)
;
allocator
(
)
-
>
AddTurnServer
(
config
)
;
P2PTransportChannel
&
ch
=
StartTransportChannel
(
true
100
)
;
EXPECT_TRUE_WAIT
(
ch
.
ports
(
)
.
size
(
)
=
=
3
kDefaultTimeout
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
0
]
-
>
Type
(
)
LOCAL_PORT_TYPE
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
1
]
-
>
Type
(
)
RELAY_PORT_TYPE
)
;
EXPECT_EQ
(
ch
.
ports
(
)
[
2
]
-
>
Type
(
)
RELAY_PORT_TYPE
)
;
ch
.
AddRemoteCandidate
(
CreateUdpCandidate
(
RELAY_PORT_TYPE
"
1
.
1
.
1
.
1
"
1
1
)
)
;
EXPECT_TRUE_WAIT
(
ch
.
connections
(
)
.
size
(
)
=
=
3
kDefaultTimeout
)
;
VerifyNextPingableConnection
(
RELAY_PORT_TYPE
RELAY_PORT_TYPE
)
;
VerifyNextPingableConnection
(
RELAY_PORT_TYPE
RELAY_PORT_TYPE
TCP_PROTOCOL_NAME
)
;
VerifyNextPingableConnection
(
LOCAL_PORT_TYPE
RELAY_PORT_TYPE
)
;
}
}
