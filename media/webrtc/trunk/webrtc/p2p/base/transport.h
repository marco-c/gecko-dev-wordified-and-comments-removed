#
ifndef
WEBRTC_P2P_BASE_TRANSPORT_H_
#
define
WEBRTC_P2P_BASE_TRANSPORT_H_
#
include
<
map
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
p2p
/
base
/
candidate
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
constants
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
sessiondescription
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
transportinfo
.
h
"
#
include
"
webrtc
/
base
/
messagequeue
.
h
"
#
include
"
webrtc
/
base
/
rtccertificate
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
#
include
"
webrtc
/
base
/
sslstreamadapter
.
h
"
namespace
cricket
{
class
PortAllocator
;
class
TransportChannel
;
class
TransportChannelImpl
;
typedef
std
:
:
vector
<
Candidate
>
Candidates
;
enum
IceConnectionState
{
kIceConnectionConnecting
=
0
kIceConnectionFailed
kIceConnectionConnected
kIceConnectionCompleted
}
;
enum
DtlsTransportState
{
DTLS_TRANSPORT_NEW
=
0
DTLS_TRANSPORT_CONNECTING
DTLS_TRANSPORT_CONNECTED
DTLS_TRANSPORT_CLOSED
DTLS_TRANSPORT_FAILED
}
;
enum
IceGatheringState
{
kIceGatheringNew
=
0
kIceGatheringGathering
kIceGatheringComplete
}
;
struct
ConnectionInfo
{
ConnectionInfo
(
)
:
best_connection
(
false
)
writable
(
false
)
receiving
(
false
)
timeout
(
false
)
new_connection
(
false
)
rtt
(
0
)
sent_total_bytes
(
0
)
sent_bytes_second
(
0
)
sent_discarded_packets
(
0
)
sent_total_packets
(
0
)
recv_total_bytes
(
0
)
recv_bytes_second
(
0
)
key
(
NULL
)
{
}
bool
best_connection
;
bool
writable
;
bool
receiving
;
bool
timeout
;
bool
new_connection
;
size_t
rtt
;
size_t
sent_total_bytes
;
size_t
sent_bytes_second
;
size_t
sent_discarded_packets
;
size_t
sent_total_packets
;
size_t
recv_total_bytes
;
size_t
recv_bytes_second
;
Candidate
local_candidate
;
Candidate
remote_candidate
;
void
*
key
;
}
;
typedef
std
:
:
vector
<
ConnectionInfo
>
ConnectionInfos
;
struct
TransportChannelStats
{
int
component
=
0
;
ConnectionInfos
connection_infos
;
int
srtp_crypto_suite
=
rtc
:
:
SRTP_INVALID_CRYPTO_SUITE
;
int
ssl_cipher_suite
=
rtc
:
:
TLS_NULL_WITH_NULL_NULL
;
}
;
typedef
std
:
:
vector
<
TransportChannelStats
>
TransportChannelStatsList
;
struct
TransportStats
{
std
:
:
string
transport_name
;
TransportChannelStatsList
channel_stats
;
}
;
struct
IceConfig
{
int
receiving_timeout_ms
=
-
1
;
int
backup_connection_ping_interval
=
-
1
;
bool
gather_continually
=
false
;
}
;
bool
BadTransportDescription
(
const
std
:
:
string
&
desc
std
:
:
string
*
err_desc
)
;
bool
IceCredentialsChanged
(
const
std
:
:
string
&
old_ufrag
const
std
:
:
string
&
old_pwd
const
std
:
:
string
&
new_ufrag
const
std
:
:
string
&
new_pwd
)
;
class
Transport
:
public
sigslot
:
:
has_slots
<
>
{
public
:
Transport
(
const
std
:
:
string
&
name
PortAllocator
*
allocator
)
;
virtual
~
Transport
(
)
;
const
std
:
:
string
&
name
(
)
const
{
return
name_
;
}
PortAllocator
*
port_allocator
(
)
{
return
allocator_
;
}
bool
ready_for_remote_candidates
(
)
const
{
return
local_description_set_
&
&
remote_description_set_
;
}
bool
connect_requested
(
)
const
{
return
connect_requested_
;
}
void
SetIceRole
(
IceRole
role
)
;
IceRole
ice_role
(
)
const
{
return
ice_role_
;
}
void
SetIceTiebreaker
(
uint64_t
IceTiebreaker
)
{
tiebreaker_
=
IceTiebreaker
;
}
uint64_t
IceTiebreaker
(
)
{
return
tiebreaker_
;
}
void
SetIceConfig
(
const
IceConfig
&
config
)
;
virtual
void
SetLocalCertificate
(
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
certificate
)
{
}
virtual
bool
GetLocalCertificate
(
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
*
certificate
)
{
return
false
;
}
bool
GetRemoteSSLCertificate
(
rtc
:
:
SSLCertificate
*
*
cert
)
;
TransportChannelImpl
*
CreateChannel
(
int
component
)
;
TransportChannelImpl
*
GetChannel
(
int
component
)
;
bool
HasChannel
(
int
component
)
{
return
(
NULL
!
=
GetChannel
(
component
)
)
;
}
bool
HasChannels
(
)
;
void
DestroyChannel
(
int
component
)
;
bool
SetLocalTransportDescription
(
const
TransportDescription
&
description
ContentAction
action
std
:
:
string
*
error_desc
)
;
bool
SetRemoteTransportDescription
(
const
TransportDescription
&
description
ContentAction
action
std
:
:
string
*
error_desc
)
;
void
ConnectChannels
(
)
;
void
MaybeStartGathering
(
)
;
void
ResetChannels
(
)
;
void
DestroyAllChannels
(
)
;
bool
GetStats
(
TransportStats
*
stats
)
;
bool
AddRemoteCandidates
(
const
std
:
:
vector
<
Candidate
>
&
candidates
std
:
:
string
*
error
)
;
virtual
bool
VerifyCandidate
(
const
Candidate
&
candidate
std
:
:
string
*
error
)
;
virtual
bool
GetSslRole
(
rtc
:
:
SSLRole
*
ssl_role
)
const
{
return
false
;
}
virtual
bool
SetSslMaxProtocolVersion
(
rtc
:
:
SSLProtocolVersion
version
)
{
return
false
;
}
protected
:
virtual
TransportChannelImpl
*
CreateTransportChannel
(
int
component
)
=
0
;
virtual
void
DestroyTransportChannel
(
TransportChannelImpl
*
channel
)
=
0
;
const
TransportDescription
*
local_description
(
)
const
{
return
local_description_
.
get
(
)
;
}
const
TransportDescription
*
remote_description
(
)
const
{
return
remote_description_
.
get
(
)
;
}
virtual
bool
ApplyLocalTransportDescription
(
TransportChannelImpl
*
channel
std
:
:
string
*
error_desc
)
;
virtual
bool
ApplyRemoteTransportDescription
(
TransportChannelImpl
*
ch
std
:
:
string
*
error_desc
)
;
virtual
bool
NegotiateTransportDescription
(
ContentAction
local_role
std
:
:
string
*
error_desc
)
;
virtual
bool
ApplyNegotiatedTransportDescription
(
TransportChannelImpl
*
channel
std
:
:
string
*
error_desc
)
;
private
:
typedef
std
:
:
map
<
int
TransportChannelImpl
*
>
ChannelMap
;
typedef
void
(
TransportChannelImpl
:
:
*
TransportChannelFunc
)
(
)
;
void
CallChannels
(
TransportChannelFunc
func
)
;
const
std
:
:
string
name_
;
PortAllocator
*
const
allocator_
;
bool
channels_destroyed_
=
false
;
bool
connect_requested_
=
false
;
IceRole
ice_role_
=
ICEROLE_UNKNOWN
;
uint64_t
tiebreaker_
=
0
;
IceMode
remote_ice_mode_
=
ICEMODE_FULL
;
IceConfig
ice_config_
;
rtc
:
:
scoped_ptr
<
TransportDescription
>
local_description_
;
rtc
:
:
scoped_ptr
<
TransportDescription
>
remote_description_
;
bool
local_description_set_
=
false
;
bool
remote_description_set_
=
false
;
ChannelMap
channels_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
Transport
)
;
}
;
}
#
endif
