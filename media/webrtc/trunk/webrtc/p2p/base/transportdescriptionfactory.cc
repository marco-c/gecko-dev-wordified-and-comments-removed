#
include
"
webrtc
/
p2p
/
base
/
transportdescriptionfactory
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
transportdescription
.
h
"
#
include
"
webrtc
/
base
/
helpers
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
messagedigest
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
sslfingerprint
.
h
"
namespace
cricket
{
static
TransportProtocol
kDefaultProtocol
=
ICEPROTO_RFC5245
;
TransportDescriptionFactory
:
:
TransportDescriptionFactory
(
)
:
protocol_
(
kDefaultProtocol
)
secure_
(
SEC_DISABLED
)
identity_
(
NULL
)
{
}
TransportDescription
*
TransportDescriptionFactory
:
:
CreateOffer
(
const
TransportOptions
&
options
const
TransportDescription
*
current_description
)
const
{
rtc
:
:
scoped_ptr
<
TransportDescription
>
desc
(
new
TransportDescription
(
)
)
;
if
(
protocol_
=
=
ICEPROTO_RFC5245
)
{
desc
-
>
transport_type
=
NS_JINGLE_ICE_UDP
;
}
else
if
(
protocol_
=
=
ICEPROTO_HYBRID
)
{
desc
-
>
transport_type
=
NS_JINGLE_ICE_UDP
;
desc
-
>
AddOption
(
ICE_OPTION_GICE
)
;
}
else
if
(
protocol_
=
=
ICEPROTO_GOOGLE
)
{
desc
-
>
transport_type
=
NS_GINGLE_P2P
;
}
if
(
!
current_description
|
|
options
.
ice_restart
)
{
desc
-
>
ice_ufrag
=
rtc
:
:
CreateRandomString
(
ICE_UFRAG_LENGTH
)
;
desc
-
>
ice_pwd
=
rtc
:
:
CreateRandomString
(
ICE_PWD_LENGTH
)
;
}
else
{
desc
-
>
ice_ufrag
=
current_description
-
>
ice_ufrag
;
desc
-
>
ice_pwd
=
current_description
-
>
ice_pwd
;
}
if
(
secure_
=
=
SEC_ENABLED
|
|
secure_
=
=
SEC_REQUIRED
)
{
if
(
!
SetSecurityInfo
(
desc
.
get
(
)
CONNECTIONROLE_ACTPASS
)
)
{
return
NULL
;
}
}
return
desc
.
release
(
)
;
}
TransportDescription
*
TransportDescriptionFactory
:
:
CreateAnswer
(
const
TransportDescription
*
offer
const
TransportOptions
&
options
const
TransportDescription
*
current_description
)
const
{
rtc
:
:
scoped_ptr
<
TransportDescription
>
desc
(
new
TransportDescription
(
)
)
;
if
(
offer
&
&
offer
-
>
transport_type
=
=
NS_JINGLE_ICE_UDP
&
&
(
protocol_
=
=
ICEPROTO_RFC5245
|
|
protocol_
=
=
ICEPROTO_HYBRID
)
)
{
desc
-
>
transport_type
=
NS_JINGLE_ICE_UDP
;
}
else
if
(
offer
&
&
offer
-
>
transport_type
=
=
NS_JINGLE_ICE_UDP
&
&
offer
-
>
HasOption
(
ICE_OPTION_GICE
)
&
&
protocol_
=
=
ICEPROTO_GOOGLE
)
{
desc
-
>
transport_type
=
NS_GINGLE_P2P
;
}
else
if
(
(
!
offer
|
|
offer
-
>
transport_type
=
=
NS_GINGLE_P2P
)
&
&
(
protocol_
=
=
ICEPROTO_HYBRID
|
|
protocol_
=
=
ICEPROTO_GOOGLE
)
)
{
desc
-
>
transport_type
=
NS_GINGLE_P2P
;
}
else
{
LOG
(
LS_WARNING
)
<
<
"
Failed
to
create
TransportDescription
answer
"
"
because
of
incompatible
transport
types
"
;
return
NULL
;
}
if
(
!
current_description
|
|
options
.
ice_restart
)
{
desc
-
>
ice_ufrag
=
rtc
:
:
CreateRandomString
(
ICE_UFRAG_LENGTH
)
;
desc
-
>
ice_pwd
=
rtc
:
:
CreateRandomString
(
ICE_PWD_LENGTH
)
;
}
else
{
desc
-
>
ice_ufrag
=
current_description
-
>
ice_ufrag
;
desc
-
>
ice_pwd
=
current_description
-
>
ice_pwd
;
}
if
(
offer
&
&
offer
-
>
identity_fingerprint
.
get
(
)
)
{
if
(
secure_
=
=
SEC_ENABLED
|
|
secure_
=
=
SEC_REQUIRED
)
{
ConnectionRole
role
=
(
options
.
prefer_passive_role
)
?
CONNECTIONROLE_PASSIVE
:
CONNECTIONROLE_ACTIVE
;
if
(
!
SetSecurityInfo
(
desc
.
get
(
)
role
)
)
{
return
NULL
;
}
}
}
else
if
(
secure_
=
=
SEC_REQUIRED
)
{
LOG
(
LS_WARNING
)
<
<
"
Failed
to
create
TransportDescription
answer
"
"
because
of
incompatible
security
settings
"
;
return
NULL
;
}
return
desc
.
release
(
)
;
}
bool
TransportDescriptionFactory
:
:
SetSecurityInfo
(
TransportDescription
*
desc
ConnectionRole
role
)
const
{
if
(
!
identity_
)
{
LOG
(
LS_ERROR
)
<
<
"
Cannot
create
identity
digest
with
no
identity
"
;
return
false
;
}
std
:
:
string
digest_alg
;
if
(
!
identity_
-
>
certificate
(
)
.
GetSignatureDigestAlgorithm
(
&
digest_alg
)
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
retrieve
the
certificate
'
s
digest
algorithm
"
;
return
false
;
}
desc
-
>
identity_fingerprint
.
reset
(
rtc
:
:
SSLFingerprint
:
:
Create
(
digest_alg
identity_
)
)
;
if
(
!
desc
-
>
identity_fingerprint
.
get
(
)
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
create
identity
fingerprint
alg
=
"
<
<
digest_alg
;
return
false
;
}
desc
-
>
connection_role
=
role
;
return
true
;
}
}
