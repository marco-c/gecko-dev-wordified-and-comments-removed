#
include
"
webrtc
/
p2p
/
base
/
transportdescriptionfactory
.
h
"
#
include
<
memory
>
#
include
"
webrtc
/
p2p
/
base
/
transportdescription
.
h
"
#
include
"
webrtc
/
base
/
helpers
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
messagedigest
.
h
"
#
include
"
webrtc
/
base
/
sslfingerprint
.
h
"
namespace
cricket
{
TransportDescriptionFactory
:
:
TransportDescriptionFactory
(
)
:
secure_
(
SEC_DISABLED
)
{
}
TransportDescription
*
TransportDescriptionFactory
:
:
CreateOffer
(
const
TransportOptions
&
options
const
TransportDescription
*
current_description
)
const
{
std
:
:
unique_ptr
<
TransportDescription
>
desc
(
new
TransportDescription
(
)
)
;
if
(
!
current_description
|
|
options
.
ice_restart
)
{
desc
-
>
ice_ufrag
=
rtc
:
:
CreateRandomString
(
ICE_UFRAG_LENGTH
)
;
desc
-
>
ice_pwd
=
rtc
:
:
CreateRandomString
(
ICE_PWD_LENGTH
)
;
}
else
{
desc
-
>
ice_ufrag
=
current_description
-
>
ice_ufrag
;
desc
-
>
ice_pwd
=
current_description
-
>
ice_pwd
;
}
if
(
options
.
enable_ice_renomination
)
{
desc
-
>
AddOption
(
ICE_RENOMINATION_STR
)
;
}
if
(
secure_
=
=
SEC_ENABLED
|
|
secure_
=
=
SEC_REQUIRED
)
{
if
(
!
SetSecurityInfo
(
desc
.
get
(
)
CONNECTIONROLE_ACTPASS
)
)
{
return
NULL
;
}
}
return
desc
.
release
(
)
;
}
TransportDescription
*
TransportDescriptionFactory
:
:
CreateAnswer
(
const
TransportDescription
*
offer
const
TransportOptions
&
options
const
TransportDescription
*
current_description
)
const
{
if
(
!
offer
)
{
LOG
(
LS_WARNING
)
<
<
"
Failed
to
create
TransportDescription
answer
"
<
<
"
because
offer
is
NULL
"
;
return
NULL
;
}
std
:
:
unique_ptr
<
TransportDescription
>
desc
(
new
TransportDescription
(
)
)
;
if
(
!
current_description
|
|
options
.
ice_restart
)
{
desc
-
>
ice_ufrag
=
rtc
:
:
CreateRandomString
(
ICE_UFRAG_LENGTH
)
;
desc
-
>
ice_pwd
=
rtc
:
:
CreateRandomString
(
ICE_PWD_LENGTH
)
;
}
else
{
desc
-
>
ice_ufrag
=
current_description
-
>
ice_ufrag
;
desc
-
>
ice_pwd
=
current_description
-
>
ice_pwd
;
}
if
(
options
.
enable_ice_renomination
)
{
desc
-
>
AddOption
(
ICE_RENOMINATION_STR
)
;
}
if
(
offer
&
&
offer
-
>
identity_fingerprint
.
get
(
)
)
{
if
(
secure_
=
=
SEC_ENABLED
|
|
secure_
=
=
SEC_REQUIRED
)
{
ConnectionRole
role
=
(
options
.
prefer_passive_role
)
?
CONNECTIONROLE_PASSIVE
:
CONNECTIONROLE_ACTIVE
;
if
(
!
SetSecurityInfo
(
desc
.
get
(
)
role
)
)
{
return
NULL
;
}
}
}
else
if
(
secure_
=
=
SEC_REQUIRED
)
{
LOG
(
LS_WARNING
)
<
<
"
Failed
to
create
TransportDescription
answer
"
"
because
of
incompatible
security
settings
"
;
return
NULL
;
}
return
desc
.
release
(
)
;
}
bool
TransportDescriptionFactory
:
:
SetSecurityInfo
(
TransportDescription
*
desc
ConnectionRole
role
)
const
{
if
(
!
certificate_
)
{
LOG
(
LS_ERROR
)
<
<
"
Cannot
create
identity
digest
with
no
certificate
"
;
return
false
;
}
desc
-
>
identity_fingerprint
.
reset
(
rtc
:
:
SSLFingerprint
:
:
CreateFromCertificate
(
certificate_
)
)
;
if
(
!
desc
-
>
identity_fingerprint
)
{
return
false
;
}
std
:
:
string
digest_alg
;
if
(
!
certificate_
-
>
ssl_certificate
(
)
.
GetSignatureDigestAlgorithm
(
&
digest_alg
)
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
retrieve
the
certificate
'
s
digest
algorithm
"
;
return
false
;
}
desc
-
>
identity_fingerprint
.
reset
(
rtc
:
:
SSLFingerprint
:
:
Create
(
digest_alg
certificate_
-
>
identity
(
)
)
)
;
if
(
!
desc
-
>
identity_fingerprint
.
get
(
)
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
create
identity
fingerprint
alg
=
"
<
<
digest_alg
;
return
false
;
}
desc
-
>
connection_role
=
role
;
return
true
;
}
}
