#
ifndef
WEBRTC_P2P_BASE_SESSIONDESCRIPTION_H_
#
define
WEBRTC_P2P_BASE_SESSIONDESCRIPTION_H_
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
p2p
/
base
/
transportinfo
.
h
"
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
namespace
cricket
{
class
ContentDescription
{
public
:
virtual
~
ContentDescription
(
)
{
}
virtual
ContentDescription
*
Copy
(
)
const
=
0
;
}
;
struct
ContentInfo
{
ContentInfo
(
)
:
description
(
NULL
)
{
}
ContentInfo
(
const
std
:
:
string
&
name
const
std
:
:
string
&
type
ContentDescription
*
description
)
:
name
(
name
)
type
(
type
)
rejected
(
false
)
description
(
description
)
{
}
ContentInfo
(
const
std
:
:
string
&
name
const
std
:
:
string
&
type
bool
rejected
ContentDescription
*
description
)
:
name
(
name
)
type
(
type
)
rejected
(
rejected
)
description
(
description
)
{
}
std
:
:
string
name
;
std
:
:
string
type
;
bool
rejected
;
ContentDescription
*
description
;
}
;
typedef
std
:
:
vector
<
std
:
:
string
>
ContentNames
;
class
ContentGroup
{
public
:
explicit
ContentGroup
(
const
std
:
:
string
&
semantics
)
:
semantics_
(
semantics
)
{
}
const
std
:
:
string
&
semantics
(
)
const
{
return
semantics_
;
}
const
ContentNames
&
content_names
(
)
const
{
return
content_names_
;
}
const
std
:
:
string
*
FirstContentName
(
)
const
;
bool
HasContentName
(
const
std
:
:
string
&
content_name
)
const
;
void
AddContentName
(
const
std
:
:
string
&
content_name
)
;
bool
RemoveContentName
(
const
std
:
:
string
&
content_name
)
;
private
:
std
:
:
string
semantics_
;
ContentNames
content_names_
;
}
;
typedef
std
:
:
vector
<
ContentInfo
>
ContentInfos
;
typedef
std
:
:
vector
<
ContentGroup
>
ContentGroups
;
const
ContentInfo
*
FindContentInfoByName
(
const
ContentInfos
&
contents
const
std
:
:
string
&
name
)
;
const
ContentInfo
*
FindContentInfoByType
(
const
ContentInfos
&
contents
const
std
:
:
string
&
type
)
;
class
SessionDescription
{
public
:
SessionDescription
(
)
{
}
explicit
SessionDescription
(
const
ContentInfos
&
contents
)
:
contents_
(
contents
)
{
}
SessionDescription
(
const
ContentInfos
&
contents
const
ContentGroups
&
groups
)
:
contents_
(
contents
)
content_groups_
(
groups
)
{
}
SessionDescription
(
const
ContentInfos
&
contents
const
TransportInfos
&
transports
const
ContentGroups
&
groups
)
:
contents_
(
contents
)
transport_infos_
(
transports
)
content_groups_
(
groups
)
{
}
~
SessionDescription
(
)
{
for
(
ContentInfos
:
:
iterator
content
=
contents_
.
begin
(
)
;
content
!
=
contents_
.
end
(
)
;
+
+
content
)
{
delete
content
-
>
description
;
}
}
SessionDescription
*
Copy
(
)
const
;
const
ContentInfos
&
contents
(
)
const
{
return
contents_
;
}
ContentInfos
&
contents
(
)
{
return
contents_
;
}
const
ContentInfo
*
GetContentByName
(
const
std
:
:
string
&
name
)
const
;
ContentInfo
*
GetContentByName
(
const
std
:
:
string
&
name
)
;
const
ContentDescription
*
GetContentDescriptionByName
(
const
std
:
:
string
&
name
)
const
;
ContentDescription
*
GetContentDescriptionByName
(
const
std
:
:
string
&
name
)
;
const
ContentInfo
*
FirstContentByType
(
const
std
:
:
string
&
type
)
const
;
const
ContentInfo
*
FirstContent
(
)
const
;
void
AddContent
(
const
std
:
:
string
&
name
const
std
:
:
string
&
type
ContentDescription
*
description
)
;
void
AddContent
(
const
std
:
:
string
&
name
const
std
:
:
string
&
type
bool
rejected
ContentDescription
*
description
)
;
bool
RemoveContentByName
(
const
std
:
:
string
&
name
)
;
const
TransportInfos
&
transport_infos
(
)
const
{
return
transport_infos_
;
}
TransportInfos
&
transport_infos
(
)
{
return
transport_infos_
;
}
const
TransportInfo
*
GetTransportInfoByName
(
const
std
:
:
string
&
name
)
const
;
TransportInfo
*
GetTransportInfoByName
(
const
std
:
:
string
&
name
)
;
const
TransportDescription
*
GetTransportDescriptionByName
(
const
std
:
:
string
&
name
)
const
{
const
TransportInfo
*
tinfo
=
GetTransportInfoByName
(
name
)
;
return
tinfo
?
&
tinfo
-
>
description
:
NULL
;
}
void
set_transport_infos
(
const
TransportInfos
&
transport_infos
)
{
transport_infos_
=
transport_infos
;
}
bool
AddTransportInfo
(
const
TransportInfo
&
transport_info
)
;
bool
RemoveTransportInfoByName
(
const
std
:
:
string
&
name
)
;
const
ContentGroups
&
groups
(
)
const
{
return
content_groups_
;
}
const
ContentGroup
*
GetGroupByName
(
const
std
:
:
string
&
name
)
const
;
bool
HasGroup
(
const
std
:
:
string
&
name
)
const
;
void
AddGroup
(
const
ContentGroup
&
group
)
{
content_groups_
.
push_back
(
group
)
;
}
void
RemoveGroupByName
(
const
std
:
:
string
&
name
)
;
private
:
ContentInfos
contents_
;
TransportInfos
transport_infos_
;
ContentGroups
content_groups_
;
}
;
enum
ContentAction
{
CA_OFFER
CA_PRANSWER
CA_ANSWER
CA_UPDATE
}
;
enum
ContentSource
{
CS_LOCAL
CS_REMOTE
}
;
}
#
endif
