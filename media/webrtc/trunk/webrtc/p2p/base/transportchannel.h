#
ifndef
WEBRTC_P2P_BASE_TRANSPORTCHANNEL_H_
#
define
WEBRTC_P2P_BASE_TRANSPORTCHANNEL_H_
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
p2p
/
base
/
candidate
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
transport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
transportdescription
.
h
"
#
include
"
webrtc
/
base
/
asyncpacketsocket
.
h
"
#
include
"
webrtc
/
base
/
basictypes
.
h
"
#
include
"
webrtc
/
base
/
dscp
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
#
include
"
webrtc
/
base
/
socket
.
h
"
#
include
"
webrtc
/
base
/
sslidentity
.
h
"
#
include
"
webrtc
/
base
/
sslstreamadapter
.
h
"
namespace
cricket
{
class
Candidate
;
enum
PacketFlags
{
PF_NORMAL
=
0x00
PF_SRTP_BYPASS
=
0x01
}
;
enum
TransportChannelState
{
STATE_INIT
STATE_CONNECTING
STATE_COMPLETED
STATE_FAILED
}
;
class
TransportChannel
:
public
sigslot
:
:
has_slots
<
>
{
public
:
TransportChannel
(
const
std
:
:
string
&
transport_name
int
component
)
:
transport_name_
(
transport_name
)
component_
(
component
)
writable_
(
false
)
receiving_
(
false
)
{
}
virtual
~
TransportChannel
(
)
{
}
virtual
TransportChannelState
GetState
(
)
const
{
return
TransportChannelState
:
:
STATE_CONNECTING
;
}
virtual
const
std
:
:
string
SessionId
(
)
const
{
return
std
:
:
string
(
)
;
}
const
std
:
:
string
&
transport_name
(
)
const
{
return
transport_name_
;
}
int
component
(
)
const
{
return
component_
;
}
bool
writable
(
)
const
{
return
writable_
;
}
bool
receiving
(
)
const
{
return
receiving_
;
}
DtlsTransportState
dtls_state
(
)
const
{
return
dtls_state_
;
}
sigslot
:
:
signal1
<
TransportChannel
*
>
SignalWritableState
;
sigslot
:
:
signal1
<
TransportChannel
*
>
SignalReadyToSend
;
sigslot
:
:
signal1
<
TransportChannel
*
>
SignalReceivingState
;
sigslot
:
:
signal2
<
TransportChannel
*
DtlsTransportState
>
SignalDtlsState
;
virtual
int
SendPacket
(
const
char
*
data
size_t
len
const
rtc
:
:
PacketOptions
&
options
int
flags
=
0
)
=
0
;
virtual
int
SetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
value
)
=
0
;
virtual
bool
GetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
*
value
)
{
return
false
;
}
virtual
int
GetError
(
)
=
0
;
virtual
bool
GetStats
(
ConnectionInfos
*
infos
)
=
0
;
virtual
bool
IsDtlsActive
(
)
const
=
0
;
virtual
bool
GetSslRole
(
rtc
:
:
SSLRole
*
role
)
const
=
0
;
virtual
bool
SetSrtpCryptoSuites
(
const
std
:
:
vector
<
int
>
&
ciphers
)
;
virtual
bool
SetSrtpCiphers
(
const
std
:
:
vector
<
std
:
:
string
>
&
ciphers
)
;
virtual
bool
GetSrtpCryptoSuite
(
int
*
cipher
)
{
return
false
;
}
virtual
bool
GetSslCipherSuite
(
int
*
cipher
)
{
return
false
;
}
virtual
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
GetLocalCertificate
(
)
const
=
0
;
virtual
bool
GetRemoteSSLCertificate
(
rtc
:
:
SSLCertificate
*
*
cert
)
const
=
0
;
virtual
bool
ExportKeyingMaterial
(
const
std
:
:
string
&
label
const
uint8_t
*
context
size_t
context_len
bool
use_context
uint8_t
*
result
size_t
result_len
)
=
0
;
sigslot
:
:
signal5
<
TransportChannel
*
const
char
*
size_t
const
rtc
:
:
PacketTime
&
int
>
SignalReadPacket
;
sigslot
:
:
signal2
<
TransportChannel
*
const
rtc
:
:
SentPacket
&
>
SignalSentPacket
;
sigslot
:
:
signal2
<
TransportChannel
*
const
Candidate
&
>
SignalRouteChange
;
sigslot
:
:
signal1
<
TransportChannel
*
>
SignalDestroyed
;
std
:
:
string
ToString
(
)
const
;
protected
:
void
set_writable
(
bool
writable
)
;
void
set_receiving
(
bool
receiving
)
;
void
set_dtls_state
(
DtlsTransportState
state
)
;
private
:
std
:
:
string
transport_name_
;
int
component_
;
bool
writable_
;
bool
receiving_
;
DtlsTransportState
dtls_state_
=
DTLS_TRANSPORT_NEW
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
TransportChannel
)
;
}
;
}
#
endif
