#
include
"
webrtc
/
p2p
/
base
/
tcpport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
namespace
cricket
{
TCPPort
:
:
TCPPort
(
rtc
:
:
Thread
*
thread
rtc
:
:
PacketSocketFactory
*
factory
rtc
:
:
Network
*
network
const
rtc
:
:
IPAddress
&
ip
uint16_t
min_port
uint16_t
max_port
const
std
:
:
string
&
username
const
std
:
:
string
&
password
bool
allow_listen
)
:
Port
(
thread
LOCAL_PORT_TYPE
factory
network
ip
min_port
max_port
username
password
)
incoming_only_
(
false
)
allow_listen_
(
allow_listen
)
socket_
(
NULL
)
error_
(
0
)
{
}
bool
TCPPort
:
:
Init
(
)
{
if
(
allow_listen_
)
{
socket_
=
socket_factory
(
)
-
>
CreateServerTcpSocket
(
rtc
:
:
SocketAddress
(
ip
(
)
0
)
min_port
(
)
max_port
(
)
false
)
;
if
(
!
socket_
)
{
LOG_J
(
LS_ERROR
this
)
<
<
"
TCP
socket
creation
failed
.
"
;
return
false
;
}
socket_
-
>
SignalNewConnection
.
connect
(
this
&
TCPPort
:
:
OnNewConnection
)
;
socket_
-
>
SignalAddressReady
.
connect
(
this
&
TCPPort
:
:
OnAddressReady
)
;
}
return
true
;
}
TCPPort
:
:
~
TCPPort
(
)
{
delete
socket_
;
std
:
:
list
<
Incoming
>
:
:
iterator
it
;
for
(
it
=
incoming_
.
begin
(
)
;
it
!
=
incoming_
.
end
(
)
;
+
+
it
)
delete
it
-
>
socket
;
incoming_
.
clear
(
)
;
}
Connection
*
TCPPort
:
:
CreateConnection
(
const
Candidate
&
address
CandidateOrigin
origin
)
{
if
(
!
SupportsProtocol
(
address
.
protocol
(
)
)
)
{
return
NULL
;
}
if
(
address
.
tcptype
(
)
=
=
TCPTYPE_ACTIVE_STR
|
|
(
address
.
tcptype
(
)
.
empty
(
)
&
&
address
.
address
(
)
.
port
(
)
=
=
0
)
)
{
return
NULL
;
}
if
(
origin
=
=
ORIGIN_OTHER_PORT
)
return
NULL
;
if
(
incoming_only_
&
&
(
origin
=
=
ORIGIN_MESSAGE
)
)
return
NULL
;
if
(
(
address
.
protocol
(
)
=
=
SSLTCP_PROTOCOL_NAME
)
&
&
(
origin
=
=
ORIGIN_THIS_PORT
)
)
{
return
NULL
;
}
if
(
!
IsCompatibleAddress
(
address
.
address
(
)
)
)
{
return
NULL
;
}
TCPConnection
*
conn
=
NULL
;
if
(
rtc
:
:
AsyncPacketSocket
*
socket
=
GetIncoming
(
address
.
address
(
)
true
)
)
{
socket
-
>
SignalReadPacket
.
disconnect
(
this
)
;
conn
=
new
TCPConnection
(
this
address
socket
)
;
}
else
{
conn
=
new
TCPConnection
(
this
address
)
;
}
AddConnection
(
conn
)
;
return
conn
;
}
void
TCPPort
:
:
PrepareAddress
(
)
{
if
(
socket_
)
{
LOG
(
LS_VERBOSE
)
<
<
"
Preparing
TCP
address
current
state
:
"
<
<
socket_
-
>
GetState
(
)
;
if
(
socket_
-
>
GetState
(
)
=
=
rtc
:
:
AsyncPacketSocket
:
:
STATE_BOUND
|
|
socket_
-
>
GetState
(
)
=
=
rtc
:
:
AsyncPacketSocket
:
:
STATE_CLOSED
)
AddAddress
(
socket_
-
>
GetLocalAddress
(
)
socket_
-
>
GetLocalAddress
(
)
rtc
:
:
SocketAddress
(
)
TCP_PROTOCOL_NAME
"
"
TCPTYPE_PASSIVE_STR
LOCAL_PORT_TYPE
ICE_TYPE_PREFERENCE_HOST_TCP
0
true
)
;
}
else
{
LOG_J
(
LS_INFO
this
)
<
<
"
Not
listening
due
to
firewall
restrictions
.
"
;
AddAddress
(
rtc
:
:
SocketAddress
(
ip
(
)
DISCARD_PORT
)
rtc
:
:
SocketAddress
(
ip
(
)
0
)
rtc
:
:
SocketAddress
(
)
TCP_PROTOCOL_NAME
"
"
TCPTYPE_ACTIVE_STR
LOCAL_PORT_TYPE
ICE_TYPE_PREFERENCE_HOST_TCP
0
true
)
;
}
}
int
TCPPort
:
:
SendTo
(
const
void
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
addr
const
rtc
:
:
PacketOptions
&
options
bool
payload
)
{
rtc
:
:
AsyncPacketSocket
*
socket
=
NULL
;
TCPConnection
*
conn
=
static_cast
<
TCPConnection
*
>
(
GetConnection
(
addr
)
)
;
if
(
conn
)
{
if
(
!
conn
-
>
connected
(
)
)
{
conn
-
>
MaybeReconnect
(
)
;
return
SOCKET_ERROR
;
}
socket
=
conn
-
>
socket
(
)
;
}
else
{
socket
=
GetIncoming
(
addr
)
;
}
if
(
!
socket
)
{
LOG_J
(
LS_ERROR
this
)
<
<
"
Attempted
to
send
to
an
unknown
destination
"
<
<
addr
.
ToSensitiveString
(
)
;
return
SOCKET_ERROR
;
}
int
sent
=
socket
-
>
Send
(
data
size
options
)
;
if
(
sent
<
0
)
{
error_
=
socket
-
>
GetError
(
)
;
LOG_J
(
LS_ERROR
this
)
<
<
"
TCP
send
of
"
<
<
size
<
<
"
bytes
failed
with
error
"
<
<
error_
;
}
return
sent
;
}
int
TCPPort
:
:
GetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
*
value
)
{
if
(
socket_
)
{
return
socket_
-
>
GetOption
(
opt
value
)
;
}
else
{
return
SOCKET_ERROR
;
}
}
int
TCPPort
:
:
SetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
value
)
{
if
(
socket_
)
{
return
socket_
-
>
SetOption
(
opt
value
)
;
}
else
{
return
SOCKET_ERROR
;
}
}
int
TCPPort
:
:
GetError
(
)
{
return
error_
;
}
void
TCPPort
:
:
OnNewConnection
(
rtc
:
:
AsyncPacketSocket
*
socket
rtc
:
:
AsyncPacketSocket
*
new_socket
)
{
ASSERT
(
socket
=
=
socket_
)
;
Incoming
incoming
;
incoming
.
addr
=
new_socket
-
>
GetRemoteAddress
(
)
;
incoming
.
socket
=
new_socket
;
incoming
.
socket
-
>
SignalReadPacket
.
connect
(
this
&
TCPPort
:
:
OnReadPacket
)
;
incoming
.
socket
-
>
SignalReadyToSend
.
connect
(
this
&
TCPPort
:
:
OnReadyToSend
)
;
incoming
.
socket
-
>
SignalSentPacket
.
connect
(
this
&
TCPPort
:
:
OnSentPacket
)
;
LOG_J
(
LS_VERBOSE
this
)
<
<
"
Accepted
connection
from
"
<
<
incoming
.
addr
.
ToSensitiveString
(
)
;
incoming_
.
push_back
(
incoming
)
;
}
rtc
:
:
AsyncPacketSocket
*
TCPPort
:
:
GetIncoming
(
const
rtc
:
:
SocketAddress
&
addr
bool
remove
)
{
rtc
:
:
AsyncPacketSocket
*
socket
=
NULL
;
for
(
std
:
:
list
<
Incoming
>
:
:
iterator
it
=
incoming_
.
begin
(
)
;
it
!
=
incoming_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
addr
=
=
addr
)
{
socket
=
it
-
>
socket
;
if
(
remove
)
incoming_
.
erase
(
it
)
;
break
;
}
}
return
socket
;
}
void
TCPPort
:
:
OnReadPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
char
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
remote_addr
const
rtc
:
:
PacketTime
&
packet_time
)
{
Port
:
:
OnReadPacket
(
data
size
remote_addr
PROTO_TCP
)
;
}
void
TCPPort
:
:
OnSentPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
SentPacket
&
sent_packet
)
{
PortInterface
:
:
SignalSentPacket
(
sent_packet
)
;
}
void
TCPPort
:
:
OnReadyToSend
(
rtc
:
:
AsyncPacketSocket
*
socket
)
{
Port
:
:
OnReadyToSend
(
)
;
}
void
TCPPort
:
:
OnAddressReady
(
rtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
SocketAddress
&
address
)
{
AddAddress
(
address
address
rtc
:
:
SocketAddress
(
)
TCP_PROTOCOL_NAME
"
"
TCPTYPE_PASSIVE_STR
LOCAL_PORT_TYPE
ICE_TYPE_PREFERENCE_HOST_TCP
0
true
)
;
}
TCPConnection
:
:
TCPConnection
(
TCPPort
*
port
const
Candidate
&
candidate
rtc
:
:
AsyncPacketSocket
*
socket
)
:
Connection
(
port
0
candidate
)
socket_
(
socket
)
error_
(
0
)
outgoing_
(
socket
=
=
NULL
)
connection_pending_
(
false
)
pretending_to_be_writable_
(
false
)
reconnection_timeout_
(
cricket
:
:
CONNECTION_WRITE_CONNECT_TIMEOUT
)
{
if
(
outgoing_
)
{
CreateOutgoingTcpSocket
(
)
;
}
else
{
LOG_J
(
LS_VERBOSE
this
)
<
<
"
socket
ipaddr
:
"
<
<
socket_
-
>
GetLocalAddress
(
)
.
ToString
(
)
<
<
"
port
(
)
ip
:
"
<
<
port
-
>
ip
(
)
.
ToString
(
)
;
ASSERT
(
socket_
-
>
GetLocalAddress
(
)
.
ipaddr
(
)
=
=
port
-
>
ip
(
)
)
;
ConnectSocketSignals
(
socket
)
;
}
}
TCPConnection
:
:
~
TCPConnection
(
)
{
}
int
TCPConnection
:
:
Send
(
const
void
*
data
size_t
size
const
rtc
:
:
PacketOptions
&
options
)
{
if
(
!
socket_
)
{
error_
=
ENOTCONN
;
return
SOCKET_ERROR
;
}
if
(
!
connected
(
)
)
{
MaybeReconnect
(
)
;
return
SOCKET_ERROR
;
}
if
(
pretending_to_be_writable_
|
|
write_state
(
)
!
=
STATE_WRITABLE
)
{
error_
=
EWOULDBLOCK
;
return
SOCKET_ERROR
;
}
sent_packets_total_
+
+
;
int
sent
=
socket_
-
>
Send
(
data
size
options
)
;
if
(
sent
<
0
)
{
sent_packets_discarded_
+
+
;
error_
=
socket_
-
>
GetError
(
)
;
}
else
{
send_rate_tracker_
.
AddSamples
(
sent
)
;
}
return
sent
;
}
int
TCPConnection
:
:
GetError
(
)
{
return
error_
;
}
void
TCPConnection
:
:
OnConnectionRequestResponse
(
ConnectionRequest
*
req
StunMessage
*
response
)
{
Connection
:
:
OnConnectionRequestResponse
(
req
response
)
;
if
(
pretending_to_be_writable_
)
{
Connection
:
:
OnReadyToSend
(
)
;
}
pretending_to_be_writable_
=
false
;
ASSERT
(
write_state
(
)
=
=
STATE_WRITABLE
)
;
}
void
TCPConnection
:
:
OnConnect
(
rtc
:
:
AsyncPacketSocket
*
socket
)
{
ASSERT
(
socket
=
=
socket_
)
;
const
rtc
:
:
IPAddress
&
socket_ip
=
socket
-
>
GetLocalAddress
(
)
.
ipaddr
(
)
;
if
(
socket_ip
=
=
port
(
)
-
>
ip
(
)
|
|
IPIsAny
(
port
(
)
-
>
ip
(
)
)
)
{
if
(
socket_ip
=
=
port
(
)
-
>
ip
(
)
)
{
LOG_J
(
LS_VERBOSE
this
)
<
<
"
Connection
established
to
"
<
<
socket
-
>
GetRemoteAddress
(
)
.
ToSensitiveString
(
)
;
}
else
{
LOG
(
LS_WARNING
)
<
<
"
Socket
is
bound
to
a
different
address
:
"
<
<
socket
-
>
GetLocalAddress
(
)
.
ipaddr
(
)
.
ToString
(
)
<
<
"
rather
then
the
local
port
:
"
<
<
port
(
)
-
>
ip
(
)
.
ToString
(
)
<
<
"
.
Still
allowing
it
since
it
'
s
any
address
"
<
<
"
possibly
caused
by
multi
-
routes
being
disabled
.
"
;
}
set_connected
(
true
)
;
connection_pending_
=
false
;
}
else
{
LOG_J
(
LS_WARNING
this
)
<
<
"
Dropping
connection
as
TCP
socket
bound
to
IP
"
<
<
socket_ip
.
ToSensitiveString
(
)
<
<
"
different
from
the
local
candidate
IP
"
<
<
port
(
)
-
>
ip
(
)
.
ToSensitiveString
(
)
;
OnClose
(
socket
0
)
;
}
}
void
TCPConnection
:
:
OnClose
(
rtc
:
:
AsyncPacketSocket
*
socket
int
error
)
{
ASSERT
(
socket
=
=
socket_
)
;
LOG_J
(
LS_INFO
this
)
<
<
"
Connection
closed
with
error
"
<
<
error
;
if
(
connected
(
)
)
{
set_connected
(
false
)
;
pretending_to_be_writable_
=
true
;
port
(
)
-
>
thread
(
)
-
>
PostDelayed
(
reconnection_timeout
(
)
this
MSG_TCPCONNECTION_DELAYED_ONCLOSE
)
;
}
else
if
(
!
pretending_to_be_writable_
)
{
Destroy
(
)
;
}
}
void
TCPConnection
:
:
OnMessage
(
rtc
:
:
Message
*
pmsg
)
{
switch
(
pmsg
-
>
message_id
)
{
case
MSG_TCPCONNECTION_DELAYED_ONCLOSE
:
if
(
pretending_to_be_writable_
)
{
Destroy
(
)
;
}
break
;
default
:
Connection
:
:
OnMessage
(
pmsg
)
;
}
}
void
TCPConnection
:
:
MaybeReconnect
(
)
{
if
(
connected
(
)
|
|
connection_pending_
|
|
!
outgoing_
)
{
return
;
}
LOG_J
(
LS_INFO
this
)
<
<
"
TCP
Connection
with
remote
is
closed
"
<
<
"
trying
to
reconnect
"
;
CreateOutgoingTcpSocket
(
)
;
error_
=
EPIPE
;
}
void
TCPConnection
:
:
OnReadPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
char
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
remote_addr
const
rtc
:
:
PacketTime
&
packet_time
)
{
ASSERT
(
socket
=
=
socket_
)
;
Connection
:
:
OnReadPacket
(
data
size
packet_time
)
;
}
void
TCPConnection
:
:
OnReadyToSend
(
rtc
:
:
AsyncPacketSocket
*
socket
)
{
ASSERT
(
socket
=
=
socket_
)
;
Connection
:
:
OnReadyToSend
(
)
;
}
void
TCPConnection
:
:
CreateOutgoingTcpSocket
(
)
{
ASSERT
(
outgoing_
)
;
int
opts
=
(
remote_candidate
(
)
.
protocol
(
)
=
=
SSLTCP_PROTOCOL_NAME
)
?
rtc
:
:
PacketSocketFactory
:
:
OPT_SSLTCP
:
0
;
socket_
.
reset
(
port
(
)
-
>
socket_factory
(
)
-
>
CreateClientTcpSocket
(
rtc
:
:
SocketAddress
(
port
(
)
-
>
ip
(
)
0
)
remote_candidate
(
)
.
address
(
)
port
(
)
-
>
proxy
(
)
port
(
)
-
>
user_agent
(
)
opts
)
)
;
if
(
socket_
)
{
LOG_J
(
LS_VERBOSE
this
)
<
<
"
Connecting
from
"
<
<
socket_
-
>
GetLocalAddress
(
)
.
ToSensitiveString
(
)
<
<
"
to
"
<
<
remote_candidate
(
)
.
address
(
)
.
ToSensitiveString
(
)
;
set_connected
(
false
)
;
connection_pending_
=
true
;
ConnectSocketSignals
(
socket_
.
get
(
)
)
;
}
else
{
LOG_J
(
LS_WARNING
this
)
<
<
"
Failed
to
create
connection
to
"
<
<
remote_candidate
(
)
.
address
(
)
.
ToSensitiveString
(
)
;
}
}
void
TCPConnection
:
:
ConnectSocketSignals
(
rtc
:
:
AsyncPacketSocket
*
socket
)
{
if
(
outgoing_
)
{
socket
-
>
SignalConnect
.
connect
(
this
&
TCPConnection
:
:
OnConnect
)
;
}
socket
-
>
SignalReadPacket
.
connect
(
this
&
TCPConnection
:
:
OnReadPacket
)
;
socket
-
>
SignalReadyToSend
.
connect
(
this
&
TCPConnection
:
:
OnReadyToSend
)
;
socket
-
>
SignalClose
.
connect
(
this
&
TCPConnection
:
:
OnClose
)
;
}
}
