#
ifndef
WEBRTC_P2P_BASE_TRANSPORTDESCRIPTION_H_
#
define
WEBRTC_P2P_BASE_TRANSPORTDESCRIPTION_H_
#
include
<
algorithm
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
p2p
/
base
/
candidate
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
constants
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
sslfingerprint
.
h
"
namespace
cricket
{
enum
SecurePolicy
{
SEC_DISABLED
SEC_ENABLED
SEC_REQUIRED
}
;
enum
TransportProtocol
{
ICEPROTO_GOOGLE
ICEPROTO_HYBRID
ICEPROTO_RFC5245
}
;
typedef
TransportProtocol
IceProtocolType
;
enum
IceRole
{
ICEROLE_CONTROLLING
=
0
ICEROLE_CONTROLLED
ICEROLE_UNKNOWN
}
;
enum
IceMode
{
ICEMODE_FULL
ICEMODE_LITE
}
;
enum
ConnectionRole
{
CONNECTIONROLE_NONE
=
0
CONNECTIONROLE_ACTIVE
CONNECTIONROLE_PASSIVE
CONNECTIONROLE_ACTPASS
CONNECTIONROLE_HOLDCONN
}
;
extern
const
char
CONNECTIONROLE_ACTIVE_STR
[
]
;
extern
const
char
CONNECTIONROLE_PASSIVE_STR
[
]
;
extern
const
char
CONNECTIONROLE_ACTPASS_STR
[
]
;
extern
const
char
CONNECTIONROLE_HOLDCONN_STR
[
]
;
bool
StringToConnectionRole
(
const
std
:
:
string
&
role_str
ConnectionRole
*
role
)
;
bool
ConnectionRoleToString
(
const
ConnectionRole
&
role
std
:
:
string
*
role_str
)
;
typedef
std
:
:
vector
<
Candidate
>
Candidates
;
struct
TransportDescription
{
TransportDescription
(
)
:
ice_mode
(
ICEMODE_FULL
)
connection_role
(
CONNECTIONROLE_NONE
)
{
}
TransportDescription
(
const
std
:
:
string
&
transport_type
const
std
:
:
vector
<
std
:
:
string
>
&
transport_options
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
IceMode
ice_mode
ConnectionRole
role
const
rtc
:
:
SSLFingerprint
*
identity_fingerprint
const
Candidates
&
candidates
)
:
transport_type
(
transport_type
)
transport_options
(
transport_options
)
ice_ufrag
(
ice_ufrag
)
ice_pwd
(
ice_pwd
)
ice_mode
(
ice_mode
)
connection_role
(
role
)
identity_fingerprint
(
CopyFingerprint
(
identity_fingerprint
)
)
candidates
(
candidates
)
{
}
TransportDescription
(
const
std
:
:
string
&
transport_type
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
:
transport_type
(
transport_type
)
ice_ufrag
(
ice_ufrag
)
ice_pwd
(
ice_pwd
)
ice_mode
(
ICEMODE_FULL
)
connection_role
(
CONNECTIONROLE_NONE
)
{
}
TransportDescription
(
const
TransportDescription
&
from
)
:
transport_type
(
from
.
transport_type
)
transport_options
(
from
.
transport_options
)
ice_ufrag
(
from
.
ice_ufrag
)
ice_pwd
(
from
.
ice_pwd
)
ice_mode
(
from
.
ice_mode
)
connection_role
(
from
.
connection_role
)
identity_fingerprint
(
CopyFingerprint
(
from
.
identity_fingerprint
.
get
(
)
)
)
candidates
(
from
.
candidates
)
{
}
TransportDescription
&
operator
=
(
const
TransportDescription
&
from
)
{
if
(
this
=
=
&
from
)
return
*
this
;
transport_type
=
from
.
transport_type
;
transport_options
=
from
.
transport_options
;
ice_ufrag
=
from
.
ice_ufrag
;
ice_pwd
=
from
.
ice_pwd
;
ice_mode
=
from
.
ice_mode
;
connection_role
=
from
.
connection_role
;
identity_fingerprint
.
reset
(
CopyFingerprint
(
from
.
identity_fingerprint
.
get
(
)
)
)
;
candidates
=
from
.
candidates
;
return
*
this
;
}
bool
HasOption
(
const
std
:
:
string
&
option
)
const
{
return
(
std
:
:
find
(
transport_options
.
begin
(
)
transport_options
.
end
(
)
option
)
!
=
transport_options
.
end
(
)
)
;
}
void
AddOption
(
const
std
:
:
string
&
option
)
{
transport_options
.
push_back
(
option
)
;
}
bool
secure
(
)
const
{
return
identity_fingerprint
!
=
NULL
;
}
static
rtc
:
:
SSLFingerprint
*
CopyFingerprint
(
const
rtc
:
:
SSLFingerprint
*
from
)
{
if
(
!
from
)
return
NULL
;
return
new
rtc
:
:
SSLFingerprint
(
*
from
)
;
}
std
:
:
string
transport_type
;
std
:
:
vector
<
std
:
:
string
>
transport_options
;
std
:
:
string
ice_ufrag
;
std
:
:
string
ice_pwd
;
IceMode
ice_mode
;
ConnectionRole
connection_role
;
rtc
:
:
scoped_ptr
<
rtc
:
:
SSLFingerprint
>
identity_fingerprint
;
Candidates
candidates
;
}
;
}
#
endif
