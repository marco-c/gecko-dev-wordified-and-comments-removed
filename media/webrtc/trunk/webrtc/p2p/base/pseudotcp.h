#
ifndef
WEBRTC_P2P_BASE_PSEUDOTCP_H_
#
define
WEBRTC_P2P_BASE_PSEUDOTCP_H_
#
include
<
list
>
#
include
"
webrtc
/
base
/
basictypes
.
h
"
#
include
"
webrtc
/
base
/
stream
.
h
"
namespace
cricket
{
class
PseudoTcp
;
class
IPseudoTcpNotify
{
public
:
virtual
void
OnTcpOpen
(
PseudoTcp
*
tcp
)
=
0
;
virtual
void
OnTcpReadable
(
PseudoTcp
*
tcp
)
=
0
;
virtual
void
OnTcpWriteable
(
PseudoTcp
*
tcp
)
=
0
;
virtual
void
OnTcpClosed
(
PseudoTcp
*
tcp
uint32
error
)
=
0
;
enum
WriteResult
{
WR_SUCCESS
WR_TOO_LARGE
WR_FAIL
}
;
virtual
WriteResult
TcpWritePacket
(
PseudoTcp
*
tcp
const
char
*
buffer
size_t
len
)
=
0
;
protected
:
virtual
~
IPseudoTcpNotify
(
)
{
}
}
;
class
PseudoTcp
{
public
:
static
uint32
Now
(
)
;
PseudoTcp
(
IPseudoTcpNotify
*
notify
uint32
conv
)
;
virtual
~
PseudoTcp
(
)
;
int
Connect
(
)
;
int
Recv
(
char
*
buffer
size_t
len
)
;
int
Send
(
const
char
*
buffer
size_t
len
)
;
void
Close
(
bool
force
)
;
int
GetError
(
)
;
enum
TcpState
{
TCP_LISTEN
TCP_SYN_SENT
TCP_SYN_RECEIVED
TCP_ESTABLISHED
TCP_CLOSED
}
;
TcpState
State
(
)
const
{
return
m_state
;
}
void
NotifyMTU
(
uint16
mtu
)
;
void
NotifyClock
(
uint32
now
)
;
bool
NotifyPacket
(
const
char
*
buffer
size_t
len
)
;
bool
GetNextClock
(
uint32
now
long
&
timeout
)
;
enum
Option
{
OPT_NODELAY
OPT_ACKDELAY
OPT_RCVBUF
OPT_SNDBUF
}
;
void
GetOption
(
Option
opt
int
*
value
)
;
void
SetOption
(
Option
opt
int
value
)
;
uint32
GetCongestionWindow
(
)
const
;
uint32
GetBytesInFlight
(
)
const
;
uint32
GetBytesBufferedNotSent
(
)
const
;
uint32
GetRoundTripTimeEstimateMs
(
)
const
;
protected
:
enum
SendFlags
{
sfNone
sfDelayedAck
sfImmediateAck
}
;
struct
Segment
{
uint32
conv
seq
ack
;
uint8
flags
;
uint16
wnd
;
const
char
*
data
;
uint32
len
;
uint32
tsval
tsecr
;
}
;
struct
SSegment
{
SSegment
(
uint32
s
uint32
l
bool
c
)
:
seq
(
s
)
len
(
l
)
xmit
(
0
)
bCtrl
(
c
)
{
}
uint32
seq
len
;
uint8
xmit
;
bool
bCtrl
;
}
;
typedef
std
:
:
list
<
SSegment
>
SList
;
struct
RSegment
{
uint32
seq
len
;
}
;
uint32
queue
(
const
char
*
data
uint32
len
bool
bCtrl
)
;
IPseudoTcpNotify
:
:
WriteResult
packet
(
uint32
seq
uint8
flags
uint32
offset
uint32
len
)
;
bool
parse
(
const
uint8
*
buffer
uint32
size
)
;
void
attemptSend
(
SendFlags
sflags
=
sfNone
)
;
void
closedown
(
uint32
err
=
0
)
;
bool
clock_check
(
uint32
now
long
&
nTimeout
)
;
bool
process
(
Segment
&
seg
)
;
bool
transmit
(
const
SList
:
:
iterator
&
seg
uint32
now
)
;
void
adjustMTU
(
)
;
protected
:
bool
isReceiveBufferFull
(
)
const
;
void
disableWindowScale
(
)
;
private
:
void
queueConnectMessage
(
)
;
void
parseOptions
(
const
char
*
data
uint32
len
)
;
void
applyOption
(
char
kind
const
char
*
data
uint32
len
)
;
void
applyWindowScaleOption
(
uint8
scale_factor
)
;
void
resizeSendBuffer
(
uint32
new_size
)
;
void
resizeReceiveBuffer
(
uint32
new_size
)
;
IPseudoTcpNotify
*
m_notify
;
enum
Shutdown
{
SD_NONE
SD_GRACEFUL
SD_FORCEFUL
}
m_shutdown
;
int
m_error
;
TcpState
m_state
;
uint32
m_conv
;
bool
m_bReadEnable
m_bWriteEnable
m_bOutgoing
;
uint32
m_lasttraffic
;
typedef
std
:
:
list
<
RSegment
>
RList
;
RList
m_rlist
;
uint32
m_rbuf_len
m_rcv_nxt
m_rcv_wnd
m_lastrecv
;
uint8
m_rwnd_scale
;
rtc
:
:
FifoBuffer
m_rbuf
;
SList
m_slist
;
uint32
m_sbuf_len
m_snd_nxt
m_snd_wnd
m_lastsend
m_snd_una
;
uint8
m_swnd_scale
;
rtc
:
:
FifoBuffer
m_sbuf
;
uint32
m_mss
m_msslevel
m_largest
m_mtu_advise
;
uint32
m_rto_base
;
uint32
m_ts_recent
m_ts_lastack
;
uint32
m_rx_rttvar
m_rx_srtt
m_rx_rto
;
uint32
m_ssthresh
m_cwnd
;
uint8
m_dup_acks
;
uint32
m_recover
;
uint32
m_t_ack
;
bool
m_use_nagling
;
uint32
m_ack_delay
;
bool
m_support_wnd_scale
;
}
;
}
#
endif
