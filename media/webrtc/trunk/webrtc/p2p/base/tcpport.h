#
ifndef
WEBRTC_P2P_BASE_TCPPORT_H_
#
define
WEBRTC_P2P_BASE_TCPPORT_H_
#
include
<
list
>
#
include
<
memory
>
#
include
<
string
>
#
include
"
webrtc
/
p2p
/
base
/
port
.
h
"
#
include
"
webrtc
/
base
/
asyncpacketsocket
.
h
"
namespace
cricket
{
class
TCPConnection
;
class
TCPPort
:
public
Port
{
public
:
static
TCPPort
*
Create
(
rtc
:
:
Thread
*
thread
rtc
:
:
PacketSocketFactory
*
factory
rtc
:
:
Network
*
network
const
rtc
:
:
IPAddress
&
ip
uint16_t
min_port
uint16_t
max_port
const
std
:
:
string
&
username
const
std
:
:
string
&
password
bool
allow_listen
)
{
TCPPort
*
port
=
new
TCPPort
(
thread
factory
network
ip
min_port
max_port
username
password
allow_listen
)
;
if
(
!
port
-
>
Init
(
)
)
{
delete
port
;
port
=
NULL
;
}
return
port
;
}
~
TCPPort
(
)
override
;
Connection
*
CreateConnection
(
const
Candidate
&
address
CandidateOrigin
origin
)
override
;
void
PrepareAddress
(
)
override
;
int
GetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
*
value
)
override
;
int
SetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
value
)
override
;
int
GetError
(
)
override
;
bool
SupportsProtocol
(
const
std
:
:
string
&
protocol
)
const
override
{
return
protocol
=
=
TCP_PROTOCOL_NAME
|
|
protocol
=
=
SSLTCP_PROTOCOL_NAME
;
}
ProtocolType
GetProtocol
(
)
const
override
{
return
PROTO_TCP
;
}
protected
:
TCPPort
(
rtc
:
:
Thread
*
thread
rtc
:
:
PacketSocketFactory
*
factory
rtc
:
:
Network
*
network
const
rtc
:
:
IPAddress
&
ip
uint16_t
min_port
uint16_t
max_port
const
std
:
:
string
&
username
const
std
:
:
string
&
password
bool
allow_listen
)
;
bool
Init
(
)
;
int
SendTo
(
const
void
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
addr
const
rtc
:
:
PacketOptions
&
options
bool
payload
)
override
;
void
OnNewConnection
(
rtc
:
:
AsyncPacketSocket
*
socket
rtc
:
:
AsyncPacketSocket
*
new_socket
)
;
private
:
struct
Incoming
{
rtc
:
:
SocketAddress
addr
;
rtc
:
:
AsyncPacketSocket
*
socket
;
}
;
rtc
:
:
AsyncPacketSocket
*
GetIncoming
(
const
rtc
:
:
SocketAddress
&
addr
bool
remove
=
false
)
;
void
OnReadPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
char
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
remote_addr
const
rtc
:
:
PacketTime
&
packet_time
)
;
void
OnSentPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
SentPacket
&
sent_packet
)
override
;
void
OnReadyToSend
(
rtc
:
:
AsyncPacketSocket
*
socket
)
;
void
OnAddressReady
(
rtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
SocketAddress
&
address
)
;
bool
incoming_only_
;
bool
allow_listen_
;
rtc
:
:
AsyncPacketSocket
*
socket_
;
int
error_
;
std
:
:
list
<
Incoming
>
incoming_
;
friend
class
TCPConnection
;
}
;
class
TCPConnection
:
public
Connection
{
public
:
TCPConnection
(
TCPPort
*
port
const
Candidate
&
candidate
rtc
:
:
AsyncPacketSocket
*
socket
=
0
)
;
~
TCPConnection
(
)
override
;
int
Send
(
const
void
*
data
size_t
size
const
rtc
:
:
PacketOptions
&
options
)
override
;
int
GetError
(
)
override
;
rtc
:
:
AsyncPacketSocket
*
socket
(
)
{
return
socket_
.
get
(
)
;
}
void
OnMessage
(
rtc
:
:
Message
*
pmsg
)
override
;
int
reconnection_timeout
(
)
const
{
return
reconnection_timeout_
;
}
void
set_reconnection_timeout
(
int
timeout_in_ms
)
{
reconnection_timeout_
=
timeout_in_ms
;
}
protected
:
enum
{
MSG_TCPCONNECTION_DELAYED_ONCLOSE
=
Connection
:
:
MSG_FIRST_AVAILABLE
}
;
void
OnConnectionRequestResponse
(
ConnectionRequest
*
req
StunMessage
*
response
)
override
;
private
:
void
MaybeReconnect
(
)
;
void
CreateOutgoingTcpSocket
(
)
;
void
ConnectSocketSignals
(
rtc
:
:
AsyncPacketSocket
*
socket
)
;
void
OnConnect
(
rtc
:
:
AsyncPacketSocket
*
socket
)
;
void
OnClose
(
rtc
:
:
AsyncPacketSocket
*
socket
int
error
)
;
void
OnReadPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
char
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
remote_addr
const
rtc
:
:
PacketTime
&
packet_time
)
;
void
OnReadyToSend
(
rtc
:
:
AsyncPacketSocket
*
socket
)
;
std
:
:
unique_ptr
<
rtc
:
:
AsyncPacketSocket
>
socket_
;
int
error_
;
bool
outgoing_
;
bool
connection_pending_
;
bool
pretending_to_be_writable_
;
int
reconnection_timeout_
;
friend
class
TCPPort
;
}
;
}
#
endif
