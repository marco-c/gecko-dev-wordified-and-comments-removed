#
ifndef
WEBRTC_P2P_BASE_PORTALLOCATOR_H_
#
define
WEBRTC_P2P_BASE_PORTALLOCATOR_H_
#
include
<
deque
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
p2p
/
base
/
port
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
portinterface
.
h
"
#
include
"
webrtc
/
base
/
helpers
.
h
"
#
include
"
webrtc
/
base
/
proxyinfo
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
#
include
"
webrtc
/
base
/
thread
.
h
"
namespace
webrtc
{
class
MetricsObserverInterface
;
}
namespace
cricket
{
enum
{
PORTALLOCATOR_DISABLE_UDP
=
0x01
PORTALLOCATOR_DISABLE_STUN
=
0x02
PORTALLOCATOR_DISABLE_RELAY
=
0x04
PORTALLOCATOR_DISABLE_TCP
=
0x08
PORTALLOCATOR_ENABLE_IPV6
=
0x40
PORTALLOCATOR_ENABLE_SHARED_UFRAG
=
0x80
PORTALLOCATOR_ENABLE_SHARED_SOCKET
=
0x100
PORTALLOCATOR_ENABLE_STUN_RETRANSMIT_ATTRIBUTE
=
0x200
PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION
=
0x400
PORTALLOCATOR_DISABLE_DEFAULT_LOCAL_CANDIDATE
=
0x800
PORTALLOCATOR_DISABLE_UDP_RELAY
=
0x1000
PORTALLOCATOR_DISABLE_COSTLY_NETWORKS
=
0x2000
}
;
enum
class
IceRegatheringReason
{
NETWORK_CHANGE
NETWORK_FAILURE
MAX_VALUE
}
;
const
uint32_t
kDefaultPortAllocatorFlags
=
0
;
const
uint32_t
kDefaultStepDelay
=
1000
;
const
uint32_t
kMinimumStepDelay
=
50
;
enum
{
CF_NONE
=
0x0
CF_HOST
=
0x1
CF_REFLEXIVE
=
0x2
CF_RELAY
=
0x4
CF_ALL
=
0x7
}
;
enum
class
TlsCertPolicy
{
TLS_CERT_POLICY_SECURE
TLS_CERT_POLICY_INSECURE_NO_CHECK
}
;
struct
RelayCredentials
{
RelayCredentials
(
)
{
}
RelayCredentials
(
const
std
:
:
string
&
username
const
std
:
:
string
&
password
)
:
username
(
username
)
password
(
password
)
{
}
bool
operator
=
=
(
const
RelayCredentials
&
o
)
const
{
return
username
=
=
o
.
username
&
&
password
=
=
o
.
password
;
}
bool
operator
!
=
(
const
RelayCredentials
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
std
:
:
string
username
;
std
:
:
string
password
;
}
;
typedef
std
:
:
vector
<
ProtocolAddress
>
PortList
;
struct
RelayServerConfig
{
RelayServerConfig
(
RelayType
type
)
:
type
(
type
)
{
}
RelayServerConfig
(
const
std
:
:
string
&
address
int
port
const
std
:
:
string
&
username
const
std
:
:
string
&
password
ProtocolType
proto
)
:
type
(
RELAY_TURN
)
credentials
(
username
password
)
{
ports
.
push_back
(
ProtocolAddress
(
rtc
:
:
SocketAddress
(
address
port
)
proto
)
)
;
}
RelayServerConfig
(
const
std
:
:
string
&
address
int
port
const
std
:
:
string
&
username
const
std
:
:
string
&
password
ProtocolType
proto
bool
secure
)
:
RelayServerConfig
(
address
port
username
password
(
proto
=
=
PROTO_TCP
&
&
secure
?
PROTO_TLS
:
proto
)
)
{
}
bool
operator
=
=
(
const
RelayServerConfig
&
o
)
const
{
return
type
=
=
o
.
type
&
&
ports
=
=
o
.
ports
&
&
credentials
=
=
o
.
credentials
&
&
priority
=
=
o
.
priority
;
}
bool
operator
!
=
(
const
RelayServerConfig
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
RelayType
type
;
PortList
ports
;
RelayCredentials
credentials
;
int
priority
=
0
;
TlsCertPolicy
tls_cert_policy
=
TlsCertPolicy
:
:
TLS_CERT_POLICY_SECURE
;
}
;
class
PortAllocatorSession
:
public
sigslot
:
:
has_slots
<
>
{
public
:
PortAllocatorSession
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
uint32_t
flags
)
;
virtual
~
PortAllocatorSession
(
)
{
}
uint32_t
flags
(
)
const
{
return
flags_
;
}
void
set_flags
(
uint32_t
flags
)
{
flags_
=
flags
;
}
std
:
:
string
content_name
(
)
const
{
return
content_name_
;
}
int
component
(
)
const
{
return
component_
;
}
const
std
:
:
string
&
ice_ufrag
(
)
const
{
return
ice_ufrag_
;
}
const
std
:
:
string
&
ice_pwd
(
)
const
{
return
ice_pwd_
;
}
bool
pooled
(
)
const
{
return
ice_ufrag_
.
empty
(
)
;
}
virtual
void
SetCandidateFilter
(
uint32_t
filter
)
=
0
;
virtual
void
StartGettingPorts
(
)
=
0
;
virtual
void
StopGettingPorts
(
)
=
0
;
virtual
bool
IsGettingPorts
(
)
=
0
;
virtual
void
ClearGettingPorts
(
)
=
0
;
virtual
bool
IsCleared
(
)
const
{
return
false
;
}
virtual
bool
IsStopped
(
)
const
{
return
false
;
}
virtual
void
RegatherOnFailedNetworks
(
)
{
}
virtual
void
RegatherOnAllNetworks
(
)
{
}
virtual
std
:
:
vector
<
PortInterface
*
>
ReadyPorts
(
)
const
=
0
;
virtual
std
:
:
vector
<
Candidate
>
ReadyCandidates
(
)
const
=
0
;
virtual
bool
CandidatesAllocationDone
(
)
const
=
0
;
virtual
void
PruneAllPorts
(
)
{
}
sigslot
:
:
signal2
<
PortAllocatorSession
*
PortInterface
*
>
SignalPortReady
;
sigslot
:
:
signal2
<
PortAllocatorSession
*
const
std
:
:
vector
<
PortInterface
*
>
&
>
SignalPortsPruned
;
sigslot
:
:
signal2
<
PortAllocatorSession
*
const
std
:
:
vector
<
Candidate
>
&
>
SignalCandidatesReady
;
sigslot
:
:
signal2
<
PortAllocatorSession
*
const
std
:
:
vector
<
Candidate
>
&
>
SignalCandidatesRemoved
;
sigslot
:
:
signal1
<
PortAllocatorSession
*
>
SignalCandidatesAllocationDone
;
sigslot
:
:
signal2
<
PortAllocatorSession
*
IceRegatheringReason
>
SignalIceRegathering
;
virtual
uint32_t
generation
(
)
{
return
generation_
;
}
virtual
void
set_generation
(
uint32_t
generation
)
{
generation_
=
generation
;
}
sigslot
:
:
signal1
<
PortAllocatorSession
*
>
SignalDestroyed
;
protected
:
virtual
void
UpdateIceParametersInternal
(
)
{
}
const
std
:
:
string
&
username
(
)
const
{
return
ice_ufrag_
;
}
const
std
:
:
string
&
password
(
)
const
{
return
ice_pwd_
;
}
private
:
void
SetIceParameters
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
{
content_name_
=
content_name
;
component_
=
component
;
ice_ufrag_
=
ice_ufrag
;
ice_pwd_
=
ice_pwd
;
UpdateIceParametersInternal
(
)
;
}
uint32_t
flags_
;
uint32_t
generation_
;
std
:
:
string
content_name_
;
int
component_
;
std
:
:
string
ice_ufrag_
;
std
:
:
string
ice_pwd_
;
friend
class
PortAllocator
;
}
;
class
PortAllocator
:
public
sigslot
:
:
has_slots
<
>
{
public
:
PortAllocator
(
)
:
flags_
(
kDefaultPortAllocatorFlags
)
min_port_
(
0
)
max_port_
(
0
)
step_delay_
(
kDefaultStepDelay
)
allow_tcp_listen_
(
true
)
candidate_filter_
(
CF_ALL
)
{
}
virtual
~
PortAllocator
(
)
{
}
virtual
void
Initialize
(
)
{
}
bool
SetConfiguration
(
const
ServerAddresses
&
stun_servers
const
std
:
:
vector
<
RelayServerConfig
>
&
turn_servers
int
candidate_pool_size
bool
prune_turn_ports
)
;
const
ServerAddresses
&
stun_servers
(
)
const
{
return
stun_servers_
;
}
const
std
:
:
vector
<
RelayServerConfig
>
&
turn_servers
(
)
const
{
return
turn_servers_
;
}
int
candidate_pool_size
(
)
const
{
return
candidate_pool_size_
;
}
virtual
void
SetNetworkIgnoreMask
(
int
network_ignore_mask
)
=
0
;
std
:
:
unique_ptr
<
PortAllocatorSession
>
CreateSession
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
;
std
:
:
unique_ptr
<
PortAllocatorSession
>
TakePooledSession
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
;
const
PortAllocatorSession
*
GetPooledSession
(
)
const
;
uint32_t
flags
(
)
const
{
return
flags_
;
}
void
set_flags
(
uint32_t
flags
)
{
flags_
=
flags
;
}
const
std
:
:
string
&
user_agent
(
)
const
{
return
agent_
;
}
const
rtc
:
:
ProxyInfo
&
proxy
(
)
const
{
return
proxy_
;
}
void
set_proxy
(
const
std
:
:
string
&
agent
const
rtc
:
:
ProxyInfo
&
proxy
)
{
agent_
=
agent
;
proxy_
=
proxy
;
}
int
min_port
(
)
const
{
return
min_port_
;
}
int
max_port
(
)
const
{
return
max_port_
;
}
bool
SetPortRange
(
int
min_port
int
max_port
)
{
if
(
min_port
>
max_port
)
{
return
false
;
}
min_port_
=
min_port
;
max_port_
=
max_port
;
return
true
;
}
uint32_t
step_delay
(
)
const
{
return
step_delay_
;
}
void
set_step_delay
(
uint32_t
delay
)
{
step_delay_
=
delay
;
}
bool
allow_tcp_listen
(
)
const
{
return
allow_tcp_listen_
;
}
void
set_allow_tcp_listen
(
bool
allow_tcp_listen
)
{
allow_tcp_listen_
=
allow_tcp_listen
;
}
uint32_t
candidate_filter
(
)
{
return
candidate_filter_
;
}
void
set_candidate_filter
(
uint32_t
filter
)
{
candidate_filter_
=
filter
;
}
bool
prune_turn_ports
(
)
const
{
return
prune_turn_ports_
;
}
const
std
:
:
string
&
origin
(
)
const
{
return
origin_
;
}
void
set_origin
(
const
std
:
:
string
&
origin
)
{
origin_
=
origin
;
}
void
SetMetricsObserver
(
webrtc
:
:
MetricsObserverInterface
*
observer
)
{
metrics_observer_
=
observer
;
}
protected
:
virtual
PortAllocatorSession
*
CreateSessionInternal
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
=
0
;
webrtc
:
:
MetricsObserverInterface
*
metrics_observer
(
)
{
return
metrics_observer_
;
}
const
std
:
:
deque
<
std
:
:
unique_ptr
<
PortAllocatorSession
>
>
&
pooled_sessions
(
)
{
return
pooled_sessions_
;
}
uint32_t
flags_
;
std
:
:
string
agent_
;
rtc
:
:
ProxyInfo
proxy_
;
int
min_port_
;
int
max_port_
;
uint32_t
step_delay_
;
bool
allow_tcp_listen_
;
uint32_t
candidate_filter_
;
std
:
:
string
origin_
;
private
:
ServerAddresses
stun_servers_
;
std
:
:
vector
<
RelayServerConfig
>
turn_servers_
;
int
candidate_pool_size_
=
0
;
std
:
:
deque
<
std
:
:
unique_ptr
<
PortAllocatorSession
>
>
pooled_sessions_
;
bool
prune_turn_ports_
=
false
;
webrtc
:
:
MetricsObserverInterface
*
metrics_observer_
=
nullptr
;
}
;
}
#
endif
