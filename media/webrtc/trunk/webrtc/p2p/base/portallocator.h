#
ifndef
WEBRTC_P2P_BASE_PORTALLOCATOR_H_
#
define
WEBRTC_P2P_BASE_PORTALLOCATOR_H_
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
p2p
/
base
/
portinterface
.
h
"
#
include
"
webrtc
/
base
/
helpers
.
h
"
#
include
"
webrtc
/
base
/
proxyinfo
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
namespace
cricket
{
enum
{
PORTALLOCATOR_DISABLE_UDP
=
0x01
PORTALLOCATOR_DISABLE_STUN
=
0x02
PORTALLOCATOR_DISABLE_RELAY
=
0x04
PORTALLOCATOR_DISABLE_TCP
=
0x08
PORTALLOCATOR_ENABLE_SHAKER
=
0x10
PORTALLOCATOR_ENABLE_BUNDLE
=
0x20
PORTALLOCATOR_ENABLE_IPV6
=
0x40
PORTALLOCATOR_ENABLE_SHARED_UFRAG
=
0x80
PORTALLOCATOR_ENABLE_SHARED_SOCKET
=
0x100
PORTALLOCATOR_ENABLE_STUN_RETRANSMIT_ATTRIBUTE
=
0x200
PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION
=
0x400
}
;
const
uint32
kDefaultPortAllocatorFlags
=
0
;
const
uint32
kDefaultStepDelay
=
1000
;
const
uint32
kMinimumStepDelay
=
50
;
enum
{
CF_NONE
=
0x0
CF_HOST
=
0x1
CF_REFLEXIVE
=
0x2
CF_RELAY
=
0x4
CF_ALL
=
0x7
}
;
class
PortAllocatorSessionMuxer
;
class
PortAllocatorSession
:
public
sigslot
:
:
has_slots
<
>
{
public
:
PortAllocatorSession
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
username
const
std
:
:
string
&
password
uint32
flags
)
;
virtual
~
PortAllocatorSession
(
)
{
}
uint32
flags
(
)
const
{
return
flags_
;
}
void
set_flags
(
uint32
flags
)
{
flags_
=
flags
;
}
std
:
:
string
content_name
(
)
const
{
return
content_name_
;
}
int
component
(
)
const
{
return
component_
;
}
virtual
void
StartGettingPorts
(
)
=
0
;
virtual
void
StopGettingPorts
(
)
=
0
;
virtual
bool
IsGettingPorts
(
)
=
0
;
sigslot
:
:
signal2
<
PortAllocatorSession
*
PortInterface
*
>
SignalPortReady
;
sigslot
:
:
signal2
<
PortAllocatorSession
*
const
std
:
:
vector
<
Candidate
>
&
>
SignalCandidatesReady
;
sigslot
:
:
signal1
<
PortAllocatorSession
*
>
SignalCandidatesAllocationDone
;
virtual
uint32
generation
(
)
{
return
generation_
;
}
virtual
void
set_generation
(
uint32
generation
)
{
generation_
=
generation
;
}
sigslot
:
:
signal1
<
PortAllocatorSession
*
>
SignalDestroyed
;
protected
:
const
std
:
:
string
&
username
(
)
const
{
return
username_
;
}
const
std
:
:
string
&
password
(
)
const
{
return
password_
;
}
std
:
:
string
content_name_
;
int
component_
;
private
:
uint32
flags_
;
uint32
generation_
;
std
:
:
string
username_
;
std
:
:
string
password_
;
}
;
class
PortAllocator
:
public
sigslot
:
:
has_slots
<
>
{
public
:
PortAllocator
(
)
:
flags_
(
kDefaultPortAllocatorFlags
)
min_port_
(
0
)
max_port_
(
0
)
step_delay_
(
kDefaultStepDelay
)
allow_tcp_listen_
(
true
)
candidate_filter_
(
CF_ALL
)
{
}
virtual
~
PortAllocator
(
)
;
PortAllocatorSession
*
CreateSession
(
const
std
:
:
string
&
sid
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
;
PortAllocatorSessionMuxer
*
GetSessionMuxer
(
const
std
:
:
string
&
key
)
const
;
void
OnSessionMuxerDestroyed
(
PortAllocatorSessionMuxer
*
session
)
;
uint32
flags
(
)
const
{
return
flags_
;
}
void
set_flags
(
uint32
flags
)
{
flags_
=
flags
;
}
const
std
:
:
string
&
user_agent
(
)
const
{
return
agent_
;
}
const
rtc
:
:
ProxyInfo
&
proxy
(
)
const
{
return
proxy_
;
}
void
set_proxy
(
const
std
:
:
string
&
agent
const
rtc
:
:
ProxyInfo
&
proxy
)
{
agent_
=
agent
;
proxy_
=
proxy
;
}
int
min_port
(
)
const
{
return
min_port_
;
}
int
max_port
(
)
const
{
return
max_port_
;
}
bool
SetPortRange
(
int
min_port
int
max_port
)
{
if
(
min_port
>
max_port
)
{
return
false
;
}
min_port_
=
min_port
;
max_port_
=
max_port
;
return
true
;
}
uint32
step_delay
(
)
const
{
return
step_delay_
;
}
void
set_step_delay
(
uint32
delay
)
{
step_delay_
=
delay
;
}
bool
allow_tcp_listen
(
)
const
{
return
allow_tcp_listen_
;
}
void
set_allow_tcp_listen
(
bool
allow_tcp_listen
)
{
allow_tcp_listen_
=
allow_tcp_listen
;
}
uint32
candidate_filter
(
)
{
return
candidate_filter_
;
}
bool
set_candidate_filter
(
uint32
filter
)
{
candidate_filter_
=
filter
;
return
true
;
}
const
std
:
:
string
&
origin
(
)
const
{
return
origin_
;
}
void
set_origin
(
const
std
:
:
string
&
origin
)
{
origin_
=
origin
;
}
protected
:
virtual
PortAllocatorSession
*
CreateSessionInternal
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
=
0
;
typedef
std
:
:
map
<
std
:
:
string
PortAllocatorSessionMuxer
*
>
SessionMuxerMap
;
uint32
flags_
;
std
:
:
string
agent_
;
rtc
:
:
ProxyInfo
proxy_
;
int
min_port_
;
int
max_port_
;
uint32
step_delay_
;
SessionMuxerMap
muxers_
;
bool
allow_tcp_listen_
;
uint32
candidate_filter_
;
std
:
:
string
origin_
;
}
;
}
#
endif
