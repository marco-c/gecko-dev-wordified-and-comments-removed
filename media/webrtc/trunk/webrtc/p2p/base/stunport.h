#
ifndef
WEBRTC_P2P_BASE_STUNPORT_H_
#
define
WEBRTC_P2P_BASE_STUNPORT_H_
#
include
<
memory
>
#
include
<
string
>
#
include
"
webrtc
/
p2p
/
base
/
port
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
stunrequest
.
h
"
#
include
"
webrtc
/
base
/
asyncpacketsocket
.
h
"
namespace
rtc
{
class
AsyncResolver
;
class
SignalThread
;
}
namespace
cricket
{
static
const
int
INFINITE_LIFETIME
=
-
1
;
static
const
int
HIGH_COST_PORT_KEEPALIVE_LIFETIME
=
2
*
60
*
1000
;
class
UDPPort
:
public
Port
{
public
:
static
UDPPort
*
Create
(
rtc
:
:
Thread
*
thread
rtc
:
:
PacketSocketFactory
*
factory
rtc
:
:
Network
*
network
rtc
:
:
AsyncPacketSocket
*
socket
const
std
:
:
string
&
username
const
std
:
:
string
&
password
const
std
:
:
string
&
origin
bool
emit_local_for_anyaddress
)
{
UDPPort
*
port
=
new
UDPPort
(
thread
factory
network
socket
username
password
origin
emit_local_for_anyaddress
)
;
if
(
!
port
-
>
Init
(
)
)
{
delete
port
;
port
=
NULL
;
}
return
port
;
}
static
UDPPort
*
Create
(
rtc
:
:
Thread
*
thread
rtc
:
:
PacketSocketFactory
*
factory
rtc
:
:
Network
*
network
const
rtc
:
:
IPAddress
&
ip
uint16_t
min_port
uint16_t
max_port
const
std
:
:
string
&
username
const
std
:
:
string
&
password
const
std
:
:
string
&
origin
bool
emit_local_for_anyaddress
)
{
UDPPort
*
port
=
new
UDPPort
(
thread
factory
network
ip
min_port
max_port
username
password
origin
emit_local_for_anyaddress
)
;
if
(
!
port
-
>
Init
(
)
)
{
delete
port
;
port
=
NULL
;
}
return
port
;
}
virtual
~
UDPPort
(
)
;
rtc
:
:
SocketAddress
GetLocalAddress
(
)
const
{
return
socket_
-
>
GetLocalAddress
(
)
;
}
const
ServerAddresses
&
server_addresses
(
)
const
{
return
server_addresses_
;
}
void
set_server_addresses
(
const
ServerAddresses
&
addresses
)
{
server_addresses_
=
addresses
;
}
virtual
void
PrepareAddress
(
)
;
virtual
Connection
*
CreateConnection
(
const
Candidate
&
address
CandidateOrigin
origin
)
;
virtual
int
SetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
value
)
;
virtual
int
GetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
*
value
)
;
virtual
int
GetError
(
)
;
virtual
bool
HandleIncomingPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
char
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
remote_addr
const
rtc
:
:
PacketTime
&
packet_time
)
{
OnReadPacket
(
socket
data
size
remote_addr
packet_time
)
;
return
true
;
}
virtual
bool
SupportsProtocol
(
const
std
:
:
string
&
protocol
)
const
{
return
protocol
=
=
UDP_PROTOCOL_NAME
;
}
virtual
ProtocolType
GetProtocol
(
)
const
{
return
PROTO_UDP
;
}
void
set_stun_keepalive_delay
(
int
delay
)
{
stun_keepalive_delay_
=
delay
;
}
int
stun_keepalive_delay
(
)
const
{
return
stun_keepalive_delay_
;
}
int
stun_keepalive_lifetime
(
)
const
{
return
stun_keepalive_lifetime_
;
}
void
set_stun_keepalive_lifetime
(
int
lifetime
)
{
stun_keepalive_lifetime_
=
lifetime
;
}
bool
HasPendingRequest
(
int
msg_type
)
{
return
requests_
.
HasRequest
(
msg_type
)
;
}
protected
:
UDPPort
(
rtc
:
:
Thread
*
thread
rtc
:
:
PacketSocketFactory
*
factory
rtc
:
:
Network
*
network
const
rtc
:
:
IPAddress
&
ip
uint16_t
min_port
uint16_t
max_port
const
std
:
:
string
&
username
const
std
:
:
string
&
password
const
std
:
:
string
&
origin
bool
emit_local_for_anyaddress
)
;
UDPPort
(
rtc
:
:
Thread
*
thread
rtc
:
:
PacketSocketFactory
*
factory
rtc
:
:
Network
*
network
rtc
:
:
AsyncPacketSocket
*
socket
const
std
:
:
string
&
username
const
std
:
:
string
&
password
const
std
:
:
string
&
origin
bool
emit_local_for_anyaddress
)
;
bool
Init
(
)
;
virtual
int
SendTo
(
const
void
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
addr
const
rtc
:
:
PacketOptions
&
options
bool
payload
)
;
virtual
void
UpdateNetworkCost
(
)
;
void
OnLocalAddressReady
(
rtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
SocketAddress
&
address
)
;
void
OnReadPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
char
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
remote_addr
const
rtc
:
:
PacketTime
&
packet_time
)
;
void
OnSentPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
SentPacket
&
sent_packet
)
;
void
OnReadyToSend
(
rtc
:
:
AsyncPacketSocket
*
socket
)
;
void
MaybePrepareStunCandidate
(
)
;
void
SendStunBindingRequests
(
)
;
bool
MaybeSetDefaultLocalAddress
(
rtc
:
:
SocketAddress
*
addr
)
const
;
private
:
class
AddressResolver
:
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
AddressResolver
(
rtc
:
:
PacketSocketFactory
*
factory
)
;
~
AddressResolver
(
)
;
void
Resolve
(
const
rtc
:
:
SocketAddress
&
address
)
;
bool
GetResolvedAddress
(
const
rtc
:
:
SocketAddress
&
input
int
family
rtc
:
:
SocketAddress
*
output
)
const
;
sigslot
:
:
signal2
<
const
rtc
:
:
SocketAddress
&
int
>
SignalDone
;
private
:
typedef
std
:
:
map
<
rtc
:
:
SocketAddress
rtc
:
:
AsyncResolverInterface
*
>
ResolverMap
;
void
OnResolveResult
(
rtc
:
:
AsyncResolverInterface
*
resolver
)
;
rtc
:
:
PacketSocketFactory
*
socket_factory_
;
ResolverMap
resolvers_
;
}
;
void
ResolveStunAddress
(
const
rtc
:
:
SocketAddress
&
stun_addr
)
;
void
OnResolveResult
(
const
rtc
:
:
SocketAddress
&
input
int
error
)
;
void
SendStunBindingRequest
(
const
rtc
:
:
SocketAddress
&
stun_addr
)
;
void
OnStunBindingRequestSucceeded
(
const
rtc
:
:
SocketAddress
&
stun_server_addr
const
rtc
:
:
SocketAddress
&
stun_reflected_addr
)
;
void
OnStunBindingOrResolveRequestFailed
(
const
rtc
:
:
SocketAddress
&
stun_server_addr
)
;
void
OnSendPacket
(
const
void
*
data
size_t
size
StunRequest
*
req
)
;
void
MaybeSetPortCompleteOrError
(
)
;
bool
HasCandidateWithAddress
(
const
rtc
:
:
SocketAddress
&
addr
)
const
;
int
GetStunKeepaliveLifetime
(
)
{
return
(
network_cost
(
)
>
=
rtc
:
:
kNetworkCostHigh
)
?
HIGH_COST_PORT_KEEPALIVE_LIFETIME
:
INFINITE_LIFETIME
;
}
ServerAddresses
server_addresses_
;
ServerAddresses
bind_request_succeeded_servers_
;
ServerAddresses
bind_request_failed_servers_
;
StunRequestManager
requests_
;
rtc
:
:
AsyncPacketSocket
*
socket_
;
int
error_
;
std
:
:
unique_ptr
<
AddressResolver
>
resolver_
;
bool
ready_
;
int
stun_keepalive_delay_
;
int
stun_keepalive_lifetime_
=
INFINITE_LIFETIME
;
bool
emit_local_for_anyaddress_
;
friend
class
StunBindingRequest
;
}
;
class
StunPort
:
public
UDPPort
{
public
:
static
StunPort
*
Create
(
rtc
:
:
Thread
*
thread
rtc
:
:
PacketSocketFactory
*
factory
rtc
:
:
Network
*
network
const
rtc
:
:
IPAddress
&
ip
uint16_t
min_port
uint16_t
max_port
const
std
:
:
string
&
username
const
std
:
:
string
&
password
const
ServerAddresses
&
servers
const
std
:
:
string
&
origin
)
{
StunPort
*
port
=
new
StunPort
(
thread
factory
network
ip
min_port
max_port
username
password
servers
origin
)
;
if
(
!
port
-
>
Init
(
)
)
{
delete
port
;
port
=
NULL
;
}
return
port
;
}
virtual
~
StunPort
(
)
{
}
virtual
void
PrepareAddress
(
)
{
SendStunBindingRequests
(
)
;
}
protected
:
StunPort
(
rtc
:
:
Thread
*
thread
rtc
:
:
PacketSocketFactory
*
factory
rtc
:
:
Network
*
network
const
rtc
:
:
IPAddress
&
ip
uint16_t
min_port
uint16_t
max_port
const
std
:
:
string
&
username
const
std
:
:
string
&
password
const
ServerAddresses
&
servers
const
std
:
:
string
&
origin
)
:
UDPPort
(
thread
factory
network
ip
min_port
max_port
username
password
origin
false
)
{
set_type
(
STUN_PORT_TYPE
)
;
set_server_addresses
(
servers
)
;
}
}
;
}
#
endif
