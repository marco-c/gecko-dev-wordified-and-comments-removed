#
include
"
webrtc
/
p2p
/
base
/
p2ptransportchannel
.
h
"
#
include
<
algorithm
>
#
include
<
set
>
#
include
"
webrtc
/
p2p
/
base
/
common
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
relayport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
stunport
.
h
"
#
include
"
webrtc
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
crc32
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
stringencode
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
field_trial
.
h
"
namespace
{
enum
{
MSG_SORT
=
1
MSG_CHECK_AND_PING
}
;
static
const
double
kMinImprovement
=
10
;
cricket
:
:
PortInterface
:
:
CandidateOrigin
GetOrigin
(
cricket
:
:
PortInterface
*
port
cricket
:
:
PortInterface
*
origin_port
)
{
if
(
!
origin_port
)
return
cricket
:
:
PortInterface
:
:
ORIGIN_MESSAGE
;
else
if
(
port
=
=
origin_port
)
return
cricket
:
:
PortInterface
:
:
ORIGIN_THIS_PORT
;
else
return
cricket
:
:
PortInterface
:
:
ORIGIN_OTHER_PORT
;
}
int
CompareConnectionCandidates
(
cricket
:
:
Connection
*
a
cricket
:
:
Connection
*
b
)
{
if
(
a
-
>
priority
(
)
>
b
-
>
priority
(
)
)
return
1
;
if
(
a
-
>
priority
(
)
<
b
-
>
priority
(
)
)
return
-
1
;
return
(
a
-
>
remote_candidate
(
)
.
generation
(
)
+
a
-
>
port
(
)
-
>
generation
(
)
)
-
(
b
-
>
remote_candidate
(
)
.
generation
(
)
+
b
-
>
port
(
)
-
>
generation
(
)
)
;
}
int
CompareConnectionStates
(
cricket
:
:
Connection
*
a
cricket
:
:
Connection
*
b
)
{
if
(
a
-
>
write_state
(
)
<
b
-
>
write_state
(
)
)
return
1
;
if
(
a
-
>
write_state
(
)
>
b
-
>
write_state
(
)
)
return
-
1
;
if
(
a
-
>
receiving
(
)
&
&
!
b
-
>
receiving
(
)
)
return
1
;
if
(
!
a
-
>
receiving
(
)
&
&
b
-
>
receiving
(
)
)
return
-
1
;
if
(
a
-
>
write_state
(
)
=
=
cricket
:
:
Connection
:
:
STATE_WRITABLE
&
&
b
-
>
write_state
(
)
=
=
cricket
:
:
Connection
:
:
STATE_WRITABLE
)
{
if
(
a
-
>
connected
(
)
&
&
!
b
-
>
connected
(
)
)
{
return
1
;
}
if
(
!
a
-
>
connected
(
)
&
&
b
-
>
connected
(
)
)
{
return
-
1
;
}
}
return
0
;
}
int
CompareConnections
(
cricket
:
:
Connection
*
a
cricket
:
:
Connection
*
b
)
{
int
state_cmp
=
CompareConnectionStates
(
a
b
)
;
if
(
state_cmp
!
=
0
)
{
return
state_cmp
;
}
return
CompareConnectionCandidates
(
a
b
)
;
}
class
ConnectionCompare
{
public
:
bool
operator
(
)
(
const
cricket
:
:
Connection
*
ca
const
cricket
:
:
Connection
*
cb
)
{
cricket
:
:
Connection
*
a
=
const_cast
<
cricket
:
:
Connection
*
>
(
ca
)
;
cricket
:
:
Connection
*
b
=
const_cast
<
cricket
:
:
Connection
*
>
(
cb
)
;
int
cmp
=
CompareConnections
(
a
b
)
;
if
(
cmp
>
0
)
return
true
;
if
(
cmp
<
0
)
return
false
;
return
a
-
>
rtt
(
)
<
b
-
>
rtt
(
)
;
}
}
;
bool
ShouldSwitch
(
cricket
:
:
Connection
*
a_conn
cricket
:
:
Connection
*
b_conn
cricket
:
:
IceRole
ice_role
)
{
if
(
a_conn
=
=
b_conn
)
return
false
;
if
(
!
a_conn
|
|
!
b_conn
)
return
true
;
int
state_cmp
=
CompareConnectionStates
(
a_conn
b_conn
)
;
if
(
state_cmp
!
=
0
)
{
return
state_cmp
<
0
;
}
if
(
ice_role
=
=
cricket
:
:
ICEROLE_CONTROLLED
&
&
a_conn
-
>
nominated
(
)
)
{
LOG
(
LS_VERBOSE
)
<
<
"
Controlled
side
did
not
switch
due
to
nominated
status
"
;
return
false
;
}
int
prefs_cmp
=
CompareConnectionCandidates
(
a_conn
b_conn
)
;
if
(
prefs_cmp
!
=
0
)
{
return
prefs_cmp
<
0
;
}
return
b_conn
-
>
rtt
(
)
<
=
a_conn
-
>
rtt
(
)
+
kMinImprovement
;
}
}
namespace
cricket
{
static
const
uint32_t
PING_PACKET_SIZE
=
60
*
8
;
static
const
uint32_t
STRONG_PING_DELAY
=
1000
*
PING_PACKET_SIZE
/
1000
;
const
uint32_t
WEAK_PING_DELAY
=
1000
*
PING_PACKET_SIZE
/
10000
;
static
const
uint32_t
MAX_CURRENT_STRONG_DELAY
=
900
;
static
const
int
MIN_CHECK_RECEIVING_DELAY
=
50
;
P2PTransportChannel
:
:
P2PTransportChannel
(
const
std
:
:
string
&
transport_name
int
component
P2PTransport
*
transport
PortAllocator
*
allocator
)
:
TransportChannelImpl
(
transport_name
component
)
transport_
(
transport
)
allocator_
(
allocator
)
worker_thread_
(
rtc
:
:
Thread
:
:
Current
(
)
)
incoming_only_
(
false
)
error_
(
0
)
best_connection_
(
NULL
)
pending_best_connection_
(
NULL
)
sort_dirty_
(
false
)
remote_ice_mode_
(
ICEMODE_FULL
)
ice_role_
(
ICEROLE_UNKNOWN
)
tiebreaker_
(
0
)
gathering_state_
(
kIceGatheringNew
)
check_receiving_delay_
(
MIN_CHECK_RECEIVING_DELAY
*
5
)
receiving_timeout_
(
MIN_CHECK_RECEIVING_DELAY
*
50
)
backup_connection_ping_interval_
(
0
)
{
uint32_t
weak_ping_delay
=
:
:
strtoul
(
webrtc
:
:
field_trial
:
:
FindFullName
(
"
WebRTC
-
StunInterPacketDelay
"
)
.
c_str
(
)
nullptr
10
)
;
if
(
weak_ping_delay
)
{
weak_ping_delay_
=
weak_ping_delay
;
}
}
P2PTransportChannel
:
:
~
P2PTransportChannel
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
for
(
size_t
i
=
0
;
i
<
allocator_sessions_
.
size
(
)
;
+
+
i
)
delete
allocator_sessions_
[
i
]
;
}
void
P2PTransportChannel
:
:
AddAllocatorSession
(
PortAllocatorSession
*
session
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
session
-
>
set_generation
(
static_cast
<
uint32_t
>
(
allocator_sessions_
.
size
(
)
)
)
;
allocator_sessions_
.
push_back
(
session
)
;
ports_
.
clear
(
)
;
session
-
>
SignalPortReady
.
connect
(
this
&
P2PTransportChannel
:
:
OnPortReady
)
;
session
-
>
SignalCandidatesReady
.
connect
(
this
&
P2PTransportChannel
:
:
OnCandidatesReady
)
;
session
-
>
SignalCandidatesAllocationDone
.
connect
(
this
&
P2PTransportChannel
:
:
OnCandidatesAllocationDone
)
;
session
-
>
StartGettingPorts
(
)
;
}
void
P2PTransportChannel
:
:
AddConnection
(
Connection
*
connection
)
{
connections_
.
push_back
(
connection
)
;
connection
-
>
set_remote_ice_mode
(
remote_ice_mode_
)
;
connection
-
>
set_receiving_timeout
(
receiving_timeout_
)
;
connection
-
>
SignalReadPacket
.
connect
(
this
&
P2PTransportChannel
:
:
OnReadPacket
)
;
connection
-
>
SignalReadyToSend
.
connect
(
this
&
P2PTransportChannel
:
:
OnReadyToSend
)
;
connection
-
>
SignalStateChange
.
connect
(
this
&
P2PTransportChannel
:
:
OnConnectionStateChange
)
;
connection
-
>
SignalDestroyed
.
connect
(
this
&
P2PTransportChannel
:
:
OnConnectionDestroyed
)
;
connection
-
>
SignalNominated
.
connect
(
this
&
P2PTransportChannel
:
:
OnNominated
)
;
had_connection_
=
true
;
}
void
P2PTransportChannel
:
:
SetIceRole
(
IceRole
ice_role
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
ice_role_
!
=
ice_role
)
{
ice_role_
=
ice_role
;
for
(
std
:
:
vector
<
PortInterface
*
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
(
*
it
)
-
>
SetIceRole
(
ice_role
)
;
}
}
}
void
P2PTransportChannel
:
:
SetIceTiebreaker
(
uint64_t
tiebreaker
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
!
ports_
.
empty
(
)
)
{
LOG
(
LS_ERROR
)
<
<
"
Attempt
to
change
tiebreaker
after
Port
has
been
allocated
.
"
;
return
;
}
tiebreaker_
=
tiebreaker
;
}
TransportChannelState
P2PTransportChannel
:
:
GetState
(
)
const
{
return
state_
;
}
TransportChannelState
P2PTransportChannel
:
:
ComputeState
(
)
const
{
if
(
!
had_connection_
)
{
return
TransportChannelState
:
:
STATE_INIT
;
}
std
:
:
vector
<
Connection
*
>
active_connections
;
for
(
Connection
*
connection
:
connections_
)
{
if
(
connection
-
>
active
(
)
)
{
active_connections
.
push_back
(
connection
)
;
}
}
if
(
active_connections
.
empty
(
)
)
{
return
TransportChannelState
:
:
STATE_FAILED
;
}
std
:
:
set
<
rtc
:
:
Network
*
>
networks
;
for
(
Connection
*
connection
:
active_connections
)
{
rtc
:
:
Network
*
network
=
connection
-
>
port
(
)
-
>
Network
(
)
;
if
(
networks
.
find
(
network
)
=
=
networks
.
end
(
)
)
{
networks
.
insert
(
network
)
;
}
else
{
LOG_J
(
LS_VERBOSE
this
)
<
<
"
Ice
not
completed
yet
for
this
channel
as
"
<
<
network
-
>
ToString
(
)
<
<
"
has
more
than
1
connection
.
"
;
return
TransportChannelState
:
:
STATE_CONNECTING
;
}
}
LOG_J
(
LS_VERBOSE
this
)
<
<
"
Ice
is
completed
for
this
channel
.
"
;
return
TransportChannelState
:
:
STATE_COMPLETED
;
}
void
P2PTransportChannel
:
:
SetIceCredentials
(
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
ice_ufrag_
=
ice_ufrag
;
ice_pwd_
=
ice_pwd
;
}
void
P2PTransportChannel
:
:
SetRemoteIceCredentials
(
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
IceParameters
*
current_ice
=
remote_ice
(
)
;
IceParameters
new_ice
(
ice_ufrag
ice_pwd
)
;
if
(
!
current_ice
|
|
*
current_ice
!
=
new_ice
)
{
remote_ice_parameters_
.
push_back
(
new_ice
)
;
}
for
(
RemoteCandidate
&
candidate
:
remote_candidates_
)
{
if
(
candidate
.
username
(
)
=
=
ice_ufrag
&
&
candidate
.
password
(
)
.
empty
(
)
)
{
candidate
.
set_password
(
ice_pwd
)
;
}
}
for
(
Connection
*
conn
:
connections_
)
{
conn
-
>
MaybeSetRemoteIceCredentials
(
ice_ufrag
ice_pwd
)
;
}
}
void
P2PTransportChannel
:
:
SetRemoteIceMode
(
IceMode
mode
)
{
remote_ice_mode_
=
mode
;
}
void
P2PTransportChannel
:
:
SetIceConfig
(
const
IceConfig
&
config
)
{
gather_continually_
=
config
.
gather_continually
;
LOG
(
LS_INFO
)
<
<
"
Set
gather_continually
to
"
<
<
gather_continually_
;
if
(
config
.
backup_connection_ping_interval
>
=
0
&
&
backup_connection_ping_interval_
!
=
config
.
backup_connection_ping_interval
)
{
backup_connection_ping_interval_
=
config
.
backup_connection_ping_interval
;
LOG
(
LS_INFO
)
<
<
"
Set
backup
connection
ping
interval
to
"
<
<
backup_connection_ping_interval_
<
<
"
milliseconds
.
"
;
}
if
(
config
.
receiving_timeout_ms
>
=
0
&
&
receiving_timeout_
!
=
config
.
receiving_timeout_ms
)
{
receiving_timeout_
=
config
.
receiving_timeout_ms
;
check_receiving_delay_
=
std
:
:
max
(
MIN_CHECK_RECEIVING_DELAY
receiving_timeout_
/
10
)
;
for
(
Connection
*
connection
:
connections_
)
{
connection
-
>
set_receiving_timeout
(
receiving_timeout_
)
;
}
LOG
(
LS_INFO
)
<
<
"
Set
ICE
receiving
timeout
to
"
<
<
receiving_timeout_
<
<
"
milliseconds
"
;
}
}
void
P2PTransportChannel
:
:
Connect
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
ice_ufrag_
.
empty
(
)
|
|
ice_pwd_
.
empty
(
)
)
{
ASSERT
(
false
)
;
LOG
(
LS_ERROR
)
<
<
"
P2PTransportChannel
:
:
Connect
:
The
ice_ufrag_
and
the
"
<
<
"
ice_pwd_
are
not
set
.
"
;
return
;
}
thread
(
)
-
>
Post
(
this
MSG_CHECK_AND_PING
)
;
}
void
P2PTransportChannel
:
:
MaybeStartGathering
(
)
{
if
(
allocator_sessions_
.
empty
(
)
|
|
IceCredentialsChanged
(
allocator_sessions_
.
back
(
)
-
>
ice_ufrag
(
)
allocator_sessions_
.
back
(
)
-
>
ice_pwd
(
)
ice_ufrag_
ice_pwd_
)
)
{
if
(
gathering_state_
!
=
kIceGatheringGathering
)
{
gathering_state_
=
kIceGatheringGathering
;
SignalGatheringState
(
this
)
;
}
AddAllocatorSession
(
allocator_
-
>
CreateSession
(
SessionId
(
)
transport_name
(
)
component
(
)
ice_ufrag_
ice_pwd_
)
)
;
}
}
void
P2PTransportChannel
:
:
OnPortReady
(
PortAllocatorSession
*
session
PortInterface
*
port
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
for
(
OptionMap
:
:
const_iterator
it
=
options_
.
begin
(
)
;
it
!
=
options_
.
end
(
)
;
+
+
it
)
{
int
val
=
port
-
>
SetOption
(
it
-
>
first
it
-
>
second
)
;
if
(
val
<
0
)
{
LOG_J
(
LS_WARNING
port
)
<
<
"
SetOption
(
"
<
<
it
-
>
first
<
<
"
"
<
<
it
-
>
second
<
<
"
)
failed
:
"
<
<
port
-
>
GetError
(
)
;
}
}
port
-
>
SetIceRole
(
ice_role_
)
;
port
-
>
SetIceTiebreaker
(
tiebreaker_
)
;
ports_
.
push_back
(
port
)
;
port
-
>
SignalUnknownAddress
.
connect
(
this
&
P2PTransportChannel
:
:
OnUnknownAddress
)
;
port
-
>
SignalDestroyed
.
connect
(
this
&
P2PTransportChannel
:
:
OnPortDestroyed
)
;
port
-
>
SignalRoleConflict
.
connect
(
this
&
P2PTransportChannel
:
:
OnRoleConflict
)
;
port
-
>
SignalSentPacket
.
connect
(
this
&
P2PTransportChannel
:
:
OnSentPacket
)
;
std
:
:
vector
<
RemoteCandidate
>
:
:
iterator
iter
;
for
(
iter
=
remote_candidates_
.
begin
(
)
;
iter
!
=
remote_candidates_
.
end
(
)
;
+
+
iter
)
{
CreateConnection
(
port
*
iter
iter
-
>
origin_port
(
)
)
;
}
SortConnections
(
)
;
}
void
P2PTransportChannel
:
:
OnCandidatesReady
(
PortAllocatorSession
*
session
const
std
:
:
vector
<
Candidate
>
&
candidates
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
for
(
size_t
i
=
0
;
i
<
candidates
.
size
(
)
;
+
+
i
)
{
SignalCandidateGathered
(
this
candidates
[
i
]
)
;
}
}
void
P2PTransportChannel
:
:
OnCandidatesAllocationDone
(
PortAllocatorSession
*
session
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
gathering_state_
=
kIceGatheringComplete
;
LOG
(
LS_INFO
)
<
<
"
P2PTransportChannel
:
"
<
<
transport_name
(
)
<
<
"
component
"
<
<
component
(
)
<
<
"
gathering
complete
"
;
SignalGatheringState
(
this
)
;
}
void
P2PTransportChannel
:
:
OnUnknownAddress
(
PortInterface
*
port
const
rtc
:
:
SocketAddress
&
address
ProtocolType
proto
IceMessage
*
stun_msg
const
std
:
:
string
&
remote_username
bool
port_muxed
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
bool
ufrag_per_port
=
false
;
std
:
:
vector
<
RemoteCandidate
>
:
:
iterator
it
;
if
(
remote_candidates_
.
size
(
)
>
0
)
{
it
=
remote_candidates_
.
begin
(
)
;
std
:
:
string
username
=
it
-
>
username
(
)
;
for
(
;
it
!
=
remote_candidates_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
username
(
)
!
=
username
)
{
ufrag_per_port
=
true
;
break
;
}
}
}
const
Candidate
*
candidate
=
NULL
;
std
:
:
string
remote_password
;
for
(
it
=
remote_candidates_
.
begin
(
)
;
it
!
=
remote_candidates_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
username
(
)
=
=
remote_username
)
{
remote_password
=
it
-
>
password
(
)
;
if
(
ufrag_per_port
|
|
(
it
-
>
address
(
)
=
=
address
&
&
it
-
>
protocol
(
)
=
=
ProtoToString
(
proto
)
)
)
{
candidate
=
&
(
*
it
)
;
break
;
}
}
}
uint32_t
remote_generation
=
0
;
if
(
remote_password
.
empty
(
)
)
{
const
IceParameters
*
ice_param
=
FindRemoteIceFromUfrag
(
remote_username
&
remote_generation
)
;
if
(
ice_param
!
=
nullptr
)
{
remote_password
=
ice_param
-
>
pwd
;
}
}
Candidate
remote_candidate
;
bool
remote_candidate_is_new
=
(
candidate
=
=
nullptr
)
;
if
(
!
remote_candidate_is_new
)
{
remote_candidate
=
*
candidate
;
if
(
ufrag_per_port
)
{
remote_candidate
.
set_address
(
address
)
;
}
}
else
{
int
remote_candidate_priority
;
const
StunUInt32Attribute
*
priority_attr
=
stun_msg
-
>
GetUInt32
(
STUN_ATTR_PRIORITY
)
;
if
(
!
priority_attr
)
{
LOG
(
LS_WARNING
)
<
<
"
P2PTransportChannel
:
:
OnUnknownAddress
-
"
<
<
"
No
STUN_ATTR_PRIORITY
found
in
the
"
<
<
"
stun
request
message
"
;
port
-
>
SendBindingErrorResponse
(
stun_msg
address
STUN_ERROR_BAD_REQUEST
STUN_ERROR_REASON_BAD_REQUEST
)
;
return
;
}
remote_candidate_priority
=
priority_attr
-
>
value
(
)
;
remote_candidate
=
Candidate
(
component
(
)
ProtoToString
(
proto
)
address
0
remote_username
remote_password
PRFLX_PORT_TYPE
remote_generation
"
"
)
;
remote_candidate
.
set_foundation
(
rtc
:
:
ToString
<
uint32_t
>
(
rtc
:
:
ComputeCrc32
(
remote_candidate
.
id
(
)
)
)
)
;
remote_candidate
.
set_priority
(
remote_candidate_priority
)
;
}
if
(
port
-
>
GetConnection
(
remote_candidate
.
address
(
)
)
)
{
if
(
port_muxed
)
{
LOG
(
LS_INFO
)
<
<
"
Connection
already
exists
for
peer
reflexive
"
<
<
"
candidate
:
"
<
<
remote_candidate
.
ToString
(
)
;
return
;
}
else
{
ASSERT
(
false
)
;
port
-
>
SendBindingErrorResponse
(
stun_msg
address
STUN_ERROR_SERVER_ERROR
STUN_ERROR_REASON_SERVER_ERROR
)
;
return
;
}
}
Connection
*
connection
=
port
-
>
CreateConnection
(
remote_candidate
cricket
:
:
PortInterface
:
:
ORIGIN_THIS_PORT
)
;
if
(
!
connection
)
{
ASSERT
(
false
)
;
port
-
>
SendBindingErrorResponse
(
stun_msg
address
STUN_ERROR_SERVER_ERROR
STUN_ERROR_REASON_SERVER_ERROR
)
;
return
;
}
LOG
(
LS_INFO
)
<
<
"
Adding
connection
from
"
<
<
(
remote_candidate_is_new
?
"
peer
reflexive
"
:
"
resurrected
"
)
<
<
"
candidate
:
"
<
<
remote_candidate
.
ToString
(
)
;
AddConnection
(
connection
)
;
connection
-
>
HandleBindingRequest
(
stun_msg
)
;
SortConnections
(
)
;
}
void
P2PTransportChannel
:
:
OnRoleConflict
(
PortInterface
*
port
)
{
SignalRoleConflict
(
this
)
;
}
const
IceParameters
*
P2PTransportChannel
:
:
FindRemoteIceFromUfrag
(
const
std
:
:
string
&
ufrag
uint32_t
*
generation
)
{
const
auto
&
params
=
remote_ice_parameters_
;
auto
it
=
std
:
:
find_if
(
params
.
rbegin
(
)
params
.
rend
(
)
[
ufrag
]
(
const
IceParameters
&
param
)
{
return
param
.
ufrag
=
=
ufrag
;
}
)
;
if
(
it
=
=
params
.
rend
(
)
)
{
return
nullptr
;
}
*
generation
=
params
.
rend
(
)
-
it
-
1
;
return
&
(
*
it
)
;
}
void
P2PTransportChannel
:
:
OnNominated
(
Connection
*
conn
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
ASSERT
(
ice_role_
=
=
ICEROLE_CONTROLLED
)
;
if
(
conn
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITABLE
)
{
if
(
best_connection_
!
=
conn
)
{
pending_best_connection_
=
NULL
;
LOG
(
LS_INFO
)
<
<
"
Switching
best
connection
on
controlled
side
:
"
<
<
conn
-
>
ToString
(
)
;
SwitchBestConnectionTo
(
conn
)
;
RequestSort
(
)
;
}
}
else
{
LOG
(
LS_INFO
)
<
<
"
Not
switching
the
best
connection
on
controlled
side
yet
"
<
<
"
because
it
'
s
not
writable
:
"
<
<
conn
-
>
ToString
(
)
;
pending_best_connection_
=
conn
;
}
}
void
P2PTransportChannel
:
:
AddRemoteCandidate
(
const
Candidate
&
candidate
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
uint32_t
generation
=
GetRemoteCandidateGeneration
(
candidate
)
;
if
(
generation
<
remote_ice_generation
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Dropping
a
remote
candidate
because
its
ufrag
"
<
<
candidate
.
username
(
)
<
<
"
indicates
it
was
for
a
previous
generation
.
"
;
return
;
}
Candidate
new_remote_candidate
(
candidate
)
;
new_remote_candidate
.
set_generation
(
generation
)
;
if
(
remote_ice
(
)
)
{
if
(
candidate
.
username
(
)
.
empty
(
)
)
{
new_remote_candidate
.
set_username
(
remote_ice
(
)
-
>
ufrag
)
;
}
if
(
new_remote_candidate
.
username
(
)
=
=
remote_ice
(
)
-
>
ufrag
)
{
if
(
candidate
.
password
(
)
.
empty
(
)
)
{
new_remote_candidate
.
set_password
(
remote_ice
(
)
-
>
pwd
)
;
}
}
else
{
LOG
(
LS_WARNING
)
<
<
"
A
remote
candidate
arrives
with
an
unknown
ufrag
:
"
<
<
candidate
.
username
(
)
;
}
}
CreateConnections
(
new_remote_candidate
NULL
)
;
SortConnections
(
)
;
}
bool
P2PTransportChannel
:
:
CreateConnections
(
const
Candidate
&
remote_candidate
PortInterface
*
origin_port
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
!
origin_port
&
&
IsDuplicateRemoteCandidate
(
remote_candidate
)
)
{
return
true
;
}
bool
created
=
false
;
std
:
:
vector
<
PortInterface
*
>
:
:
reverse_iterator
it
;
for
(
it
=
ports_
.
rbegin
(
)
;
it
!
=
ports_
.
rend
(
)
;
+
+
it
)
{
if
(
CreateConnection
(
*
it
remote_candidate
origin_port
)
)
{
if
(
*
it
=
=
origin_port
)
created
=
true
;
}
}
if
(
(
origin_port
!
=
NULL
)
&
&
std
:
:
find
(
ports_
.
begin
(
)
ports_
.
end
(
)
origin_port
)
=
=
ports_
.
end
(
)
)
{
if
(
CreateConnection
(
origin_port
remote_candidate
origin_port
)
)
created
=
true
;
}
RememberRemoteCandidate
(
remote_candidate
origin_port
)
;
return
created
;
}
bool
P2PTransportChannel
:
:
CreateConnection
(
PortInterface
*
port
const
Candidate
&
remote_candidate
PortInterface
*
origin_port
)
{
if
(
!
port
-
>
SupportsProtocol
(
remote_candidate
.
protocol
(
)
)
)
{
return
false
;
}
Connection
*
connection
=
port
-
>
GetConnection
(
remote_candidate
.
address
(
)
)
;
if
(
connection
!
=
NULL
)
{
connection
-
>
MaybeUpdatePeerReflexiveCandidate
(
remote_candidate
)
;
if
(
!
remote_candidate
.
IsEquivalent
(
connection
-
>
remote_candidate
(
)
)
)
{
LOG
(
INFO
)
<
<
"
Attempt
to
change
a
remote
candidate
.
"
<
<
"
Existing
remote
candidate
:
"
<
<
connection
-
>
remote_candidate
(
)
.
ToString
(
)
<
<
"
New
remote
candidate
:
"
<
<
remote_candidate
.
ToString
(
)
;
return
false
;
}
}
else
{
PortInterface
:
:
CandidateOrigin
origin
=
GetOrigin
(
port
origin_port
)
;
if
(
origin
=
=
cricket
:
:
PortInterface
:
:
ORIGIN_MESSAGE
&
&
incoming_only_
)
return
false
;
connection
=
port
-
>
CreateConnection
(
remote_candidate
origin
)
;
if
(
!
connection
)
return
false
;
AddConnection
(
connection
)
;
LOG_J
(
LS_INFO
this
)
<
<
"
Created
connection
with
origin
=
"
<
<
origin
<
<
"
(
"
<
<
connections_
.
size
(
)
<
<
"
total
)
"
;
}
return
true
;
}
bool
P2PTransportChannel
:
:
FindConnection
(
cricket
:
:
Connection
*
connection
)
const
{
std
:
:
vector
<
Connection
*
>
:
:
const_iterator
citer
=
std
:
:
find
(
connections_
.
begin
(
)
connections_
.
end
(
)
connection
)
;
return
citer
!
=
connections_
.
end
(
)
;
}
uint32_t
P2PTransportChannel
:
:
GetRemoteCandidateGeneration
(
const
Candidate
&
candidate
)
{
if
(
!
candidate
.
username
(
)
.
empty
(
)
)
{
uint32_t
generation
=
0
;
if
(
!
FindRemoteIceFromUfrag
(
candidate
.
username
(
)
&
generation
)
)
{
generation
=
static_cast
<
uint32_t
>
(
remote_ice_parameters_
.
size
(
)
)
;
}
return
generation
;
}
if
(
candidate
.
generation
(
)
>
0
)
{
return
candidate
.
generation
(
)
;
}
return
remote_ice_generation
(
)
;
}
bool
P2PTransportChannel
:
:
IsDuplicateRemoteCandidate
(
const
Candidate
&
candidate
)
{
for
(
size_t
i
=
0
;
i
<
remote_candidates_
.
size
(
)
;
+
+
i
)
{
if
(
remote_candidates_
[
i
]
.
IsEquivalent
(
candidate
)
)
{
return
true
;
}
}
return
false
;
}
void
P2PTransportChannel
:
:
RememberRemoteCandidate
(
const
Candidate
&
remote_candidate
PortInterface
*
origin_port
)
{
size_t
i
=
0
;
while
(
i
<
remote_candidates_
.
size
(
)
)
{
if
(
remote_candidates_
[
i
]
.
generation
(
)
<
remote_candidate
.
generation
(
)
)
{
LOG
(
INFO
)
<
<
"
Pruning
candidate
from
old
generation
:
"
<
<
remote_candidates_
[
i
]
.
address
(
)
.
ToSensitiveString
(
)
;
remote_candidates_
.
erase
(
remote_candidates_
.
begin
(
)
+
i
)
;
}
else
{
i
+
=
1
;
}
}
if
(
IsDuplicateRemoteCandidate
(
remote_candidate
)
)
{
LOG
(
INFO
)
<
<
"
Duplicate
candidate
:
"
<
<
remote_candidate
.
ToString
(
)
;
return
;
}
remote_candidates_
.
push_back
(
RemoteCandidate
(
remote_candidate
origin_port
)
)
;
}
int
P2PTransportChannel
:
:
SetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
value
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
OptionMap
:
:
iterator
it
=
options_
.
find
(
opt
)
;
if
(
it
=
=
options_
.
end
(
)
)
{
options_
.
insert
(
std
:
:
make_pair
(
opt
value
)
)
;
}
else
if
(
it
-
>
second
=
=
value
)
{
return
0
;
}
else
{
it
-
>
second
=
value
;
}
for
(
size_t
i
=
0
;
i
<
ports_
.
size
(
)
;
+
+
i
)
{
int
val
=
ports_
[
i
]
-
>
SetOption
(
opt
value
)
;
if
(
val
<
0
)
{
LOG
(
WARNING
)
<
<
"
SetOption
(
"
<
<
opt
<
<
"
"
<
<
value
<
<
"
)
failed
:
"
<
<
ports_
[
i
]
-
>
GetError
(
)
;
}
}
return
0
;
}
bool
P2PTransportChannel
:
:
GetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
*
value
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
const
auto
&
found
=
options_
.
find
(
opt
)
;
if
(
found
=
=
options_
.
end
(
)
)
{
return
false
;
}
*
value
=
found
-
>
second
;
return
true
;
}
int
P2PTransportChannel
:
:
SendPacket
(
const
char
*
data
size_t
len
const
rtc
:
:
PacketOptions
&
options
int
flags
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
flags
!
=
0
)
{
error_
=
EINVAL
;
return
-
1
;
}
if
(
best_connection_
=
=
NULL
)
{
error_
=
EWOULDBLOCK
;
return
-
1
;
}
int
sent
=
best_connection_
-
>
Send
(
data
len
options
)
;
if
(
sent
<
=
0
)
{
ASSERT
(
sent
<
0
)
;
error_
=
best_connection_
-
>
GetError
(
)
;
}
return
sent
;
}
bool
P2PTransportChannel
:
:
GetStats
(
ConnectionInfos
*
infos
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
infos
-
>
clear
(
)
;
std
:
:
vector
<
Connection
*
>
:
:
const_iterator
it
;
for
(
Connection
*
connection
:
connections_
)
{
ConnectionInfo
info
;
info
.
best_connection
=
(
best_connection_
=
=
connection
)
;
info
.
receiving
=
connection
-
>
receiving
(
)
;
info
.
writable
=
(
connection
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITABLE
)
;
info
.
timeout
=
(
connection
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITE_TIMEOUT
)
;
info
.
new_connection
=
!
connection
-
>
reported
(
)
;
connection
-
>
set_reported
(
true
)
;
info
.
rtt
=
connection
-
>
rtt
(
)
;
info
.
sent_total_bytes
=
connection
-
>
sent_total_bytes
(
)
;
info
.
sent_bytes_second
=
connection
-
>
sent_bytes_second
(
)
;
info
.
sent_discarded_packets
=
connection
-
>
sent_discarded_packets
(
)
;
info
.
sent_total_packets
=
connection
-
>
sent_total_packets
(
)
;
info
.
recv_total_bytes
=
connection
-
>
recv_total_bytes
(
)
;
info
.
recv_bytes_second
=
connection
-
>
recv_bytes_second
(
)
;
info
.
local_candidate
=
connection
-
>
local_candidate
(
)
;
info
.
remote_candidate
=
connection
-
>
remote_candidate
(
)
;
info
.
key
=
connection
;
infos
-
>
push_back
(
info
)
;
}
return
true
;
}
rtc
:
:
DiffServCodePoint
P2PTransportChannel
:
:
DefaultDscpValue
(
)
const
{
OptionMap
:
:
const_iterator
it
=
options_
.
find
(
rtc
:
:
Socket
:
:
OPT_DSCP
)
;
if
(
it
=
=
options_
.
end
(
)
)
{
return
rtc
:
:
DSCP_NO_CHANGE
;
}
return
static_cast
<
rtc
:
:
DiffServCodePoint
>
(
it
-
>
second
)
;
}
void
P2PTransportChannel
:
:
UpdateConnectionStates
(
)
{
uint32_t
now
=
rtc
:
:
Time
(
)
;
for
(
size_t
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
connections_
[
i
]
-
>
UpdateState
(
now
)
;
}
void
P2PTransportChannel
:
:
RequestSort
(
)
{
if
(
!
sort_dirty_
)
{
worker_thread_
-
>
Post
(
this
MSG_SORT
)
;
sort_dirty_
=
true
;
}
}
void
P2PTransportChannel
:
:
SortConnections
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
UpdateConnectionStates
(
)
;
sort_dirty_
=
false
;
ConnectionCompare
cmp
;
std
:
:
stable_sort
(
connections_
.
begin
(
)
connections_
.
end
(
)
cmp
)
;
LOG
(
LS_VERBOSE
)
<
<
"
Sorting
"
<
<
connections_
.
size
(
)
<
<
"
available
connections
:
"
;
for
(
size_t
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
LOG
(
LS_VERBOSE
)
<
<
connections_
[
i
]
-
>
ToString
(
)
;
}
Connection
*
top_connection
=
(
connections_
.
size
(
)
>
0
)
?
connections_
[
0
]
:
nullptr
;
if
(
ShouldSwitch
(
best_connection_
top_connection
ice_role_
)
)
{
LOG
(
LS_INFO
)
<
<
"
Switching
best
connection
:
"
<
<
top_connection
-
>
ToString
(
)
;
SwitchBestConnectionTo
(
top_connection
)
;
}
if
(
ice_role_
=
=
ICEROLE_CONTROLLING
|
|
best_nominated_connection
(
)
)
{
PruneConnections
(
)
;
}
bool
all_connections_timedout
=
true
;
for
(
size_t
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
if
(
connections_
[
i
]
-
>
write_state
(
)
!
=
Connection
:
:
STATE_WRITE_TIMEOUT
)
{
all_connections_timedout
=
false
;
break
;
}
}
if
(
all_connections_timedout
)
{
HandleAllTimedOut
(
)
;
}
UpdateState
(
)
;
}
Connection
*
P2PTransportChannel
:
:
best_nominated_connection
(
)
const
{
return
(
best_connection_
&
&
best_connection_
-
>
nominated
(
)
)
?
best_connection_
:
nullptr
;
}
void
P2PTransportChannel
:
:
PruneConnections
(
)
{
std
:
:
set
<
rtc
:
:
Network
*
>
networks
;
for
(
const
Connection
*
conn
:
connections_
)
{
networks
.
insert
(
conn
-
>
port
(
)
-
>
Network
(
)
)
;
}
for
(
rtc
:
:
Network
*
network
:
networks
)
{
Connection
*
premier
=
GetBestConnectionOnNetwork
(
network
)
;
if
(
!
premier
|
|
premier
-
>
weak
(
)
)
{
continue
;
}
for
(
Connection
*
conn
:
connections_
)
{
if
(
(
conn
!
=
premier
)
&
&
(
conn
-
>
port
(
)
-
>
Network
(
)
=
=
network
)
&
&
(
CompareConnectionCandidates
(
premier
conn
)
>
=
0
)
)
{
conn
-
>
Prune
(
)
;
}
}
}
}
void
P2PTransportChannel
:
:
SwitchBestConnectionTo
(
Connection
*
conn
)
{
Connection
*
old_best_connection
=
best_connection_
;
best_connection_
=
conn
;
if
(
best_connection_
)
{
if
(
old_best_connection
)
{
LOG_J
(
LS_INFO
this
)
<
<
"
Previous
best
connection
:
"
<
<
old_best_connection
-
>
ToString
(
)
;
}
LOG_J
(
LS_INFO
this
)
<
<
"
New
best
connection
:
"
<
<
best_connection_
-
>
ToString
(
)
;
SignalRouteChange
(
this
best_connection_
-
>
remote_candidate
(
)
)
;
}
else
{
LOG_J
(
LS_INFO
this
)
<
<
"
No
best
connection
"
;
}
}
void
P2PTransportChannel
:
:
UpdateState
(
)
{
state_
=
ComputeState
(
)
;
bool
writable
=
best_connection_
&
&
best_connection_
-
>
writable
(
)
;
set_writable
(
writable
)
;
bool
receiving
=
false
;
for
(
const
Connection
*
connection
:
connections_
)
{
if
(
connection
-
>
receiving
(
)
)
{
receiving
=
true
;
break
;
}
}
set_receiving
(
receiving
)
;
}
void
P2PTransportChannel
:
:
MaybeStopPortAllocatorSessions
(
)
{
if
(
!
IsGettingPorts
(
)
)
{
return
;
}
for
(
PortAllocatorSession
*
session
:
allocator_sessions_
)
{
if
(
!
session
-
>
IsGettingPorts
(
)
)
{
continue
;
}
if
(
gather_continually_
&
&
session
=
=
allocator_sessions_
.
back
(
)
)
{
session
-
>
ClearGettingPorts
(
)
;
break
;
}
session
-
>
StopGettingPorts
(
)
;
}
}
void
P2PTransportChannel
:
:
HandleAllTimedOut
(
)
{
for
(
Connection
*
connection
:
connections_
)
{
connection
-
>
Destroy
(
)
;
}
}
bool
P2PTransportChannel
:
:
weak
(
)
const
{
return
!
best_connection_
|
|
best_connection_
-
>
weak
(
)
;
}
Connection
*
P2PTransportChannel
:
:
GetBestConnectionOnNetwork
(
rtc
:
:
Network
*
network
)
const
{
if
(
best_connection_
&
&
(
best_connection_
-
>
port
(
)
-
>
Network
(
)
=
=
network
)
)
return
best_connection_
;
for
(
size_t
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
if
(
connections_
[
i
]
-
>
port
(
)
-
>
Network
(
)
=
=
network
)
return
connections_
[
i
]
;
}
return
NULL
;
}
void
P2PTransportChannel
:
:
OnMessage
(
rtc
:
:
Message
*
pmsg
)
{
switch
(
pmsg
-
>
message_id
)
{
case
MSG_SORT
:
OnSort
(
)
;
break
;
case
MSG_CHECK_AND_PING
:
OnCheckAndPing
(
)
;
break
;
default
:
ASSERT
(
false
)
;
break
;
}
}
void
P2PTransportChannel
:
:
OnSort
(
)
{
SortConnections
(
)
;
}
void
P2PTransportChannel
:
:
OnCheckAndPing
(
)
{
UpdateConnectionStates
(
)
;
int
ping_delay
=
weak
(
)
?
weak_ping_delay_
:
STRONG_PING_DELAY
;
if
(
rtc
:
:
Time
(
)
>
=
last_ping_sent_ms_
+
ping_delay
)
{
Connection
*
conn
=
FindNextPingableConnection
(
)
;
if
(
conn
)
{
PingConnection
(
conn
)
;
}
}
int
check_delay
=
std
:
:
min
(
ping_delay
check_receiving_delay_
)
;
thread
(
)
-
>
PostDelayed
(
check_delay
this
MSG_CHECK_AND_PING
)
;
}
bool
P2PTransportChannel
:
:
IsBackupConnection
(
Connection
*
conn
)
const
{
return
state_
=
=
STATE_COMPLETED
&
&
conn
!
=
best_connection_
&
&
conn
-
>
active
(
)
;
}
bool
P2PTransportChannel
:
:
IsPingable
(
Connection
*
conn
uint32_t
now
)
{
const
Candidate
&
remote
=
conn
-
>
remote_candidate
(
)
;
ASSERT
(
!
remote
.
username
(
)
.
empty
(
)
)
;
if
(
remote
.
username
(
)
.
empty
(
)
|
|
remote
.
password
(
)
.
empty
(
)
)
{
return
false
;
}
if
(
!
conn
-
>
connected
(
)
&
&
!
conn
-
>
writable
(
)
)
{
return
false
;
}
if
(
weak
(
)
)
{
return
true
;
}
if
(
IsBackupConnection
(
conn
)
)
{
return
(
now
>
=
conn
-
>
last_ping_response_received
(
)
+
backup_connection_ping_interval_
)
;
}
return
conn
-
>
active
(
)
;
}
Connection
*
P2PTransportChannel
:
:
FindNextPingableConnection
(
)
{
uint32_t
now
=
rtc
:
:
Time
(
)
;
if
(
best_connection_
&
&
best_connection_
-
>
connected
(
)
&
&
best_connection_
-
>
writable
(
)
&
&
(
best_connection_
-
>
last_ping_sent
(
)
+
MAX_CURRENT_STRONG_DELAY
<
=
now
)
)
{
return
best_connection_
;
}
Connection
*
oldest_needing_triggered_check
=
nullptr
;
Connection
*
oldest
=
nullptr
;
for
(
Connection
*
conn
:
connections_
)
{
if
(
!
IsPingable
(
conn
now
)
)
{
continue
;
}
bool
needs_triggered_check
=
(
!
conn
-
>
writable
(
)
&
&
conn
-
>
last_ping_received
(
)
>
conn
-
>
last_ping_sent
(
)
)
;
if
(
needs_triggered_check
&
&
(
!
oldest_needing_triggered_check
|
|
(
conn
-
>
last_ping_received
(
)
<
oldest_needing_triggered_check
-
>
last_ping_received
(
)
)
)
)
{
oldest_needing_triggered_check
=
conn
;
}
if
(
!
oldest
|
|
(
conn
-
>
last_ping_sent
(
)
<
oldest
-
>
last_ping_sent
(
)
)
)
{
oldest
=
conn
;
}
}
if
(
oldest_needing_triggered_check
)
{
LOG
(
LS_INFO
)
<
<
"
Selecting
connection
for
triggered
check
:
"
<
<
oldest_needing_triggered_check
-
>
ToString
(
)
;
return
oldest_needing_triggered_check
;
}
return
oldest
;
}
void
P2PTransportChannel
:
:
PingConnection
(
Connection
*
conn
)
{
bool
use_candidate
=
false
;
if
(
remote_ice_mode_
=
=
ICEMODE_FULL
&
&
ice_role_
=
=
ICEROLE_CONTROLLING
)
{
use_candidate
=
(
conn
=
=
best_connection_
)
|
|
(
best_connection_
=
=
NULL
)
|
|
(
!
best_connection_
-
>
writable
(
)
)
|
|
(
conn
-
>
priority
(
)
>
best_connection_
-
>
priority
(
)
)
;
}
else
if
(
remote_ice_mode_
=
=
ICEMODE_LITE
&
&
conn
=
=
best_connection_
)
{
use_candidate
=
best_connection_
-
>
writable
(
)
;
}
conn
-
>
set_use_candidate_attr
(
use_candidate
)
;
last_ping_sent_ms_
=
rtc
:
:
Time
(
)
;
conn
-
>
Ping
(
last_ping_sent_ms_
)
;
}
void
P2PTransportChannel
:
:
OnConnectionStateChange
(
Connection
*
connection
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
ice_role_
=
=
ICEROLE_CONTROLLED
)
{
if
(
connection
=
=
pending_best_connection_
&
&
connection
-
>
writable
(
)
)
{
pending_best_connection_
=
NULL
;
LOG
(
LS_INFO
)
<
<
"
Switching
best
connection
on
controlled
side
"
<
<
"
because
it
'
s
now
writable
:
"
<
<
connection
-
>
ToString
(
)
;
SwitchBestConnectionTo
(
connection
)
;
}
}
if
(
!
connection
-
>
weak
(
)
)
{
MaybeStopPortAllocatorSessions
(
)
;
}
RequestSort
(
)
;
}
void
P2PTransportChannel
:
:
OnConnectionDestroyed
(
Connection
*
connection
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
std
:
:
vector
<
Connection
*
>
:
:
iterator
iter
=
std
:
:
find
(
connections_
.
begin
(
)
connections_
.
end
(
)
connection
)
;
ASSERT
(
iter
!
=
connections_
.
end
(
)
)
;
connections_
.
erase
(
iter
)
;
LOG_J
(
LS_INFO
this
)
<
<
"
Removed
connection
(
"
<
<
static_cast
<
int
>
(
connections_
.
size
(
)
)
<
<
"
remaining
)
"
;
if
(
pending_best_connection_
=
=
connection
)
{
pending_best_connection_
=
NULL
;
}
if
(
best_connection_
=
=
connection
)
{
LOG
(
LS_INFO
)
<
<
"
Best
connection
destroyed
.
Will
choose
a
new
one
.
"
;
SwitchBestConnectionTo
(
NULL
)
;
RequestSort
(
)
;
}
UpdateState
(
)
;
SignalConnectionRemoved
(
this
)
;
}
void
P2PTransportChannel
:
:
OnPortDestroyed
(
PortInterface
*
port
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
std
:
:
vector
<
PortInterface
*
>
:
:
iterator
iter
=
std
:
:
find
(
ports_
.
begin
(
)
ports_
.
end
(
)
port
)
;
if
(
iter
!
=
ports_
.
end
(
)
)
ports_
.
erase
(
iter
)
;
LOG
(
INFO
)
<
<
"
Removed
port
from
p2p
socket
:
"
<
<
static_cast
<
int
>
(
ports_
.
size
(
)
)
<
<
"
remaining
"
;
}
void
P2PTransportChannel
:
:
OnReadPacket
(
Connection
*
connection
const
char
*
data
size_t
len
const
rtc
:
:
PacketTime
&
packet_time
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
!
FindConnection
(
connection
)
)
return
;
SignalReadPacket
(
this
data
len
packet_time
0
)
;
if
(
ice_role_
=
=
ICEROLE_CONTROLLED
&
&
!
best_nominated_connection
(
)
&
&
connection
-
>
writable
(
)
&
&
best_connection_
!
=
connection
)
{
SwitchBestConnectionTo
(
connection
)
;
}
}
void
P2PTransportChannel
:
:
OnSentPacket
(
const
rtc
:
:
SentPacket
&
sent_packet
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
SignalSentPacket
(
this
sent_packet
)
;
}
void
P2PTransportChannel
:
:
OnReadyToSend
(
Connection
*
connection
)
{
if
(
connection
=
=
best_connection_
&
&
writable
(
)
)
{
SignalReadyToSend
(
this
)
;
}
}
}
