#
include
"
webrtc
/
p2p
/
base
/
p2ptransportchannel
.
h
"
#
include
<
set
>
#
include
"
webrtc
/
p2p
/
base
/
common
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
relayport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
stunport
.
h
"
#
include
"
webrtc
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
crc32
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
stringencode
.
h
"
namespace
{
enum
{
MSG_SORT
=
1
MSG_PING
}
;
static
const
uint32
PING_PACKET_SIZE
=
60
*
8
;
static
const
uint32
WRITABLE_DELAY
=
1000
*
PING_PACKET_SIZE
/
1000
;
static
const
uint32
UNWRITABLE_DELAY
=
1000
*
PING_PACKET_SIZE
/
10000
;
static
const
uint32
MAX_CURRENT_WRITABLE_DELAY
=
900
;
static
const
double
kMinImprovement
=
10
;
cricket
:
:
PortInterface
:
:
CandidateOrigin
GetOrigin
(
cricket
:
:
PortInterface
*
port
cricket
:
:
PortInterface
*
origin_port
)
{
if
(
!
origin_port
)
return
cricket
:
:
PortInterface
:
:
ORIGIN_MESSAGE
;
else
if
(
port
=
=
origin_port
)
return
cricket
:
:
PortInterface
:
:
ORIGIN_THIS_PORT
;
else
return
cricket
:
:
PortInterface
:
:
ORIGIN_OTHER_PORT
;
}
int
CompareConnectionCandidates
(
cricket
:
:
Connection
*
a
cricket
:
:
Connection
*
b
)
{
if
(
a
-
>
priority
(
)
>
b
-
>
priority
(
)
)
return
1
;
if
(
a
-
>
priority
(
)
<
b
-
>
priority
(
)
)
return
-
1
;
return
(
a
-
>
remote_candidate
(
)
.
generation
(
)
+
a
-
>
port
(
)
-
>
generation
(
)
)
-
(
b
-
>
remote_candidate
(
)
.
generation
(
)
+
b
-
>
port
(
)
-
>
generation
(
)
)
;
}
int
CompareConnections
(
cricket
:
:
Connection
*
a
cricket
:
:
Connection
*
b
)
{
if
(
a
-
>
write_state
(
)
<
b
-
>
write_state
(
)
)
return
1
;
if
(
a
-
>
write_state
(
)
>
b
-
>
write_state
(
)
)
return
-
1
;
return
CompareConnectionCandidates
(
a
b
)
;
}
class
ConnectionCompare
{
public
:
bool
operator
(
)
(
const
cricket
:
:
Connection
*
ca
const
cricket
:
:
Connection
*
cb
)
{
cricket
:
:
Connection
*
a
=
const_cast
<
cricket
:
:
Connection
*
>
(
ca
)
;
cricket
:
:
Connection
*
b
=
const_cast
<
cricket
:
:
Connection
*
>
(
cb
)
;
ASSERT
(
a
-
>
port
(
)
-
>
IceProtocol
(
)
=
=
b
-
>
port
(
)
-
>
IceProtocol
(
)
|
|
a
-
>
port
(
)
-
>
IceProtocol
(
)
=
=
cricket
:
:
ICEPROTO_HYBRID
|
|
b
-
>
port
(
)
-
>
IceProtocol
(
)
=
=
cricket
:
:
ICEPROTO_HYBRID
)
;
int
cmp
=
CompareConnections
(
a
b
)
;
if
(
cmp
>
0
)
return
true
;
if
(
cmp
<
0
)
return
false
;
return
a
-
>
rtt
(
)
<
b
-
>
rtt
(
)
;
}
}
;
bool
ShouldSwitch
(
cricket
:
:
Connection
*
a_conn
cricket
:
:
Connection
*
b_conn
)
{
if
(
a_conn
=
=
b_conn
)
return
false
;
if
(
!
a_conn
|
|
!
b_conn
)
return
true
;
int
prefs_cmp
=
CompareConnections
(
a_conn
b_conn
)
;
if
(
prefs_cmp
<
0
)
return
true
;
if
(
prefs_cmp
>
0
)
return
false
;
return
b_conn
-
>
rtt
(
)
<
=
a_conn
-
>
rtt
(
)
+
kMinImprovement
;
}
}
namespace
cricket
{
P2PTransportChannel
:
:
P2PTransportChannel
(
const
std
:
:
string
&
content_name
int
component
P2PTransport
*
transport
PortAllocator
*
allocator
)
:
TransportChannelImpl
(
content_name
component
)
transport_
(
transport
)
allocator_
(
allocator
)
worker_thread_
(
rtc
:
:
Thread
:
:
Current
(
)
)
incoming_only_
(
false
)
waiting_for_signaling_
(
false
)
error_
(
0
)
best_connection_
(
NULL
)
pending_best_connection_
(
NULL
)
sort_dirty_
(
false
)
was_writable_
(
false
)
protocol_type_
(
ICEPROTO_HYBRID
)
remote_ice_mode_
(
ICEMODE_FULL
)
ice_role_
(
ICEROLE_UNKNOWN
)
tiebreaker_
(
0
)
remote_candidate_generation_
(
0
)
{
}
P2PTransportChannel
:
:
~
P2PTransportChannel
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
for
(
uint32
i
=
0
;
i
<
allocator_sessions_
.
size
(
)
;
+
+
i
)
delete
allocator_sessions_
[
i
]
;
}
void
P2PTransportChannel
:
:
AddAllocatorSession
(
PortAllocatorSession
*
session
)
{
session
-
>
set_generation
(
static_cast
<
uint32
>
(
allocator_sessions_
.
size
(
)
)
)
;
allocator_sessions_
.
push_back
(
session
)
;
ports_
.
clear
(
)
;
session
-
>
SignalPortReady
.
connect
(
this
&
P2PTransportChannel
:
:
OnPortReady
)
;
session
-
>
SignalCandidatesReady
.
connect
(
this
&
P2PTransportChannel
:
:
OnCandidatesReady
)
;
session
-
>
SignalCandidatesAllocationDone
.
connect
(
this
&
P2PTransportChannel
:
:
OnCandidatesAllocationDone
)
;
session
-
>
StartGettingPorts
(
)
;
}
void
P2PTransportChannel
:
:
AddConnection
(
Connection
*
connection
)
{
connections_
.
push_back
(
connection
)
;
connection
-
>
set_remote_ice_mode
(
remote_ice_mode_
)
;
connection
-
>
SignalReadPacket
.
connect
(
this
&
P2PTransportChannel
:
:
OnReadPacket
)
;
connection
-
>
SignalReadyToSend
.
connect
(
this
&
P2PTransportChannel
:
:
OnReadyToSend
)
;
connection
-
>
SignalStateChange
.
connect
(
this
&
P2PTransportChannel
:
:
OnConnectionStateChange
)
;
connection
-
>
SignalDestroyed
.
connect
(
this
&
P2PTransportChannel
:
:
OnConnectionDestroyed
)
;
connection
-
>
SignalUseCandidate
.
connect
(
this
&
P2PTransportChannel
:
:
OnUseCandidate
)
;
}
void
P2PTransportChannel
:
:
SetIceRole
(
IceRole
ice_role
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
ice_role_
!
=
ice_role
)
{
ice_role_
=
ice_role
;
for
(
std
:
:
vector
<
PortInterface
*
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
(
*
it
)
-
>
SetIceRole
(
ice_role
)
;
}
}
}
void
P2PTransportChannel
:
:
SetIceTiebreaker
(
uint64
tiebreaker
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
!
ports_
.
empty
(
)
)
{
LOG
(
LS_ERROR
)
<
<
"
Attempt
to
change
tiebreaker
after
Port
has
been
allocated
.
"
;
return
;
}
tiebreaker_
=
tiebreaker
;
}
TransportChannelState
P2PTransportChannel
:
:
GetState
(
)
const
{
std
:
:
set
<
rtc
:
:
Network
*
>
networks
;
if
(
connections_
.
size
(
)
=
=
0
)
{
return
TransportChannelState
:
:
STATE_FAILED
;
}
for
(
uint32
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
rtc
:
:
Network
*
network
=
connections_
[
i
]
-
>
port
(
)
-
>
Network
(
)
;
if
(
networks
.
find
(
network
)
=
=
networks
.
end
(
)
)
{
networks
.
insert
(
network
)
;
}
else
{
LOG_J
(
LS_VERBOSE
this
)
<
<
"
Ice
not
completed
yet
for
this
channel
as
"
<
<
network
-
>
ToString
(
)
<
<
"
has
more
than
1
connection
.
"
;
return
TransportChannelState
:
:
STATE_CONNECTING
;
}
}
LOG_J
(
LS_VERBOSE
this
)
<
<
"
Ice
is
completed
for
this
channel
.
"
;
return
TransportChannelState
:
:
STATE_COMPLETED
;
}
bool
P2PTransportChannel
:
:
GetIceProtocolType
(
IceProtocolType
*
type
)
const
{
*
type
=
protocol_type_
;
return
true
;
}
void
P2PTransportChannel
:
:
SetIceProtocolType
(
IceProtocolType
type
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
protocol_type_
=
type
;
for
(
std
:
:
vector
<
PortInterface
*
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
(
*
it
)
-
>
SetIceProtocolType
(
protocol_type_
)
;
}
}
void
P2PTransportChannel
:
:
SetIceCredentials
(
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
bool
ice_restart
=
false
;
if
(
!
ice_ufrag_
.
empty
(
)
&
&
!
ice_pwd_
.
empty
(
)
)
{
ice_restart
=
IceCredentialsChanged
(
ice_ufrag_
ice_pwd_
ice_ufrag
ice_pwd
)
;
}
ice_ufrag_
=
ice_ufrag
;
ice_pwd_
=
ice_pwd
;
if
(
ice_restart
)
{
Allocate
(
)
;
}
}
void
P2PTransportChannel
:
:
SetRemoteIceCredentials
(
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
bool
ice_restart
=
false
;
if
(
!
remote_ice_ufrag_
.
empty
(
)
&
&
!
remote_ice_pwd_
.
empty
(
)
)
{
ice_restart
=
(
remote_ice_ufrag_
!
=
ice_ufrag
)
|
|
(
remote_ice_pwd_
!
=
ice_pwd
)
;
}
remote_ice_ufrag_
=
ice_ufrag
;
remote_ice_pwd_
=
ice_pwd
;
std
:
:
vector
<
Connection
*
>
:
:
iterator
it
=
connections_
.
begin
(
)
;
for
(
;
it
!
=
connections_
.
end
(
)
;
+
+
it
)
{
(
*
it
)
-
>
MaybeSetRemoteIceCredentials
(
ice_ufrag
ice_pwd
)
;
}
if
(
ice_restart
)
{
+
+
remote_candidate_generation_
;
}
}
void
P2PTransportChannel
:
:
SetRemoteIceMode
(
IceMode
mode
)
{
remote_ice_mode_
=
mode
;
}
void
P2PTransportChannel
:
:
Connect
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
ice_ufrag_
.
empty
(
)
|
|
ice_pwd_
.
empty
(
)
)
{
ASSERT
(
false
)
;
LOG
(
LS_ERROR
)
<
<
"
P2PTransportChannel
:
:
Connect
:
The
ice_ufrag_
and
the
"
<
<
"
ice_pwd_
are
not
set
.
"
;
return
;
}
Allocate
(
)
;
thread
(
)
-
>
Post
(
this
MSG_PING
)
;
}
void
P2PTransportChannel
:
:
Reset
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
for
(
uint32
i
=
0
;
i
<
allocator_sessions_
.
size
(
)
;
+
+
i
)
delete
allocator_sessions_
[
i
]
;
allocator_sessions_
.
clear
(
)
;
ports_
.
clear
(
)
;
connections_
.
clear
(
)
;
best_connection_
=
NULL
;
remote_candidates_
.
clear
(
)
;
set_readable
(
false
)
;
set_writable
(
false
)
;
waiting_for_signaling_
=
false
;
sort_dirty_
=
false
;
if
(
transport_
-
>
connect_requested
(
)
)
Allocate
(
)
;
thread
(
)
-
>
Clear
(
this
)
;
thread
(
)
-
>
Post
(
this
MSG_PING
)
;
}
void
P2PTransportChannel
:
:
OnPortReady
(
PortAllocatorSession
*
session
PortInterface
*
port
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
for
(
OptionMap
:
:
const_iterator
it
=
options_
.
begin
(
)
;
it
!
=
options_
.
end
(
)
;
+
+
it
)
{
int
val
=
port
-
>
SetOption
(
it
-
>
first
it
-
>
second
)
;
if
(
val
<
0
)
{
LOG_J
(
LS_WARNING
port
)
<
<
"
SetOption
(
"
<
<
it
-
>
first
<
<
"
"
<
<
it
-
>
second
<
<
"
)
failed
:
"
<
<
port
-
>
GetError
(
)
;
}
}
port
-
>
SetIceProtocolType
(
protocol_type_
)
;
port
-
>
SetIceRole
(
ice_role_
)
;
port
-
>
SetIceTiebreaker
(
tiebreaker_
)
;
ports_
.
push_back
(
port
)
;
port
-
>
SignalUnknownAddress
.
connect
(
this
&
P2PTransportChannel
:
:
OnUnknownAddress
)
;
port
-
>
SignalDestroyed
.
connect
(
this
&
P2PTransportChannel
:
:
OnPortDestroyed
)
;
port
-
>
SignalRoleConflict
.
connect
(
this
&
P2PTransportChannel
:
:
OnRoleConflict
)
;
std
:
:
vector
<
RemoteCandidate
>
:
:
iterator
iter
;
for
(
iter
=
remote_candidates_
.
begin
(
)
;
iter
!
=
remote_candidates_
.
end
(
)
;
+
+
iter
)
{
CreateConnection
(
port
*
iter
iter
-
>
origin_port
(
)
false
)
;
}
SortConnections
(
)
;
}
void
P2PTransportChannel
:
:
OnCandidatesReady
(
PortAllocatorSession
*
session
const
std
:
:
vector
<
Candidate
>
&
candidates
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
for
(
size_t
i
=
0
;
i
<
candidates
.
size
(
)
;
+
+
i
)
{
SignalCandidateReady
(
this
candidates
[
i
]
)
;
}
}
void
P2PTransportChannel
:
:
OnCandidatesAllocationDone
(
PortAllocatorSession
*
session
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
SignalCandidatesAllocationDone
(
this
)
;
}
void
P2PTransportChannel
:
:
OnUnknownAddress
(
PortInterface
*
port
const
rtc
:
:
SocketAddress
&
address
ProtocolType
proto
IceMessage
*
stun_msg
const
std
:
:
string
&
remote_username
bool
port_muxed
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
bool
ufrag_per_port
=
false
;
std
:
:
vector
<
RemoteCandidate
>
:
:
iterator
it
;
if
(
remote_candidates_
.
size
(
)
>
0
)
{
it
=
remote_candidates_
.
begin
(
)
;
std
:
:
string
username
=
it
-
>
username
(
)
;
for
(
;
it
!
=
remote_candidates_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
username
(
)
!
=
username
)
{
ufrag_per_port
=
true
;
break
;
}
}
}
const
Candidate
*
candidate
=
NULL
;
std
:
:
string
remote_password
;
for
(
it
=
remote_candidates_
.
begin
(
)
;
it
!
=
remote_candidates_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
username
(
)
=
=
remote_username
)
{
remote_password
=
it
-
>
password
(
)
;
if
(
ufrag_per_port
|
|
(
it
-
>
address
(
)
=
=
address
&
&
it
-
>
protocol
(
)
=
=
ProtoToString
(
proto
)
)
)
{
candidate
=
&
(
*
it
)
;
break
;
}
}
}
if
(
remote_password
.
empty
(
)
&
&
remote_username
=
=
remote_ice_ufrag_
)
{
remote_password
=
remote_ice_pwd_
;
}
Candidate
new_remote_candidate
;
if
(
candidate
!
=
NULL
)
{
new_remote_candidate
=
*
candidate
;
if
(
ufrag_per_port
)
{
new_remote_candidate
.
set_address
(
address
)
;
}
}
else
{
std
:
:
string
type
;
if
(
port
-
>
IceProtocol
(
)
=
=
ICEPROTO_RFC5245
)
{
type
=
PRFLX_PORT_TYPE
;
}
else
{
if
(
port
-
>
Type
(
)
=
=
RELAY_PORT_TYPE
|
|
port
-
>
SharedSocket
(
)
)
{
type
=
STUN_PORT_TYPE
;
}
else
{
type
=
port
-
>
Type
(
)
;
}
}
new_remote_candidate
=
Candidate
(
component
(
)
ProtoToString
(
proto
)
address
0
remote_username
remote_password
type
0U
"
"
)
;
new_remote_candidate
.
set_foundation
(
rtc
:
:
ToString
<
uint32
>
(
rtc
:
:
ComputeCrc32
(
new_remote_candidate
.
id
(
)
)
)
)
;
new_remote_candidate
.
set_priority
(
new_remote_candidate
.
GetPriority
(
ICE_TYPE_PREFERENCE_PRFLX
port
-
>
Network
(
)
-
>
preference
(
)
0
)
)
;
}
if
(
port
-
>
IceProtocol
(
)
=
=
ICEPROTO_RFC5245
)
{
const
StunUInt32Attribute
*
priority_attr
=
stun_msg
-
>
GetUInt32
(
STUN_ATTR_PRIORITY
)
;
if
(
!
priority_attr
)
{
LOG
(
LS_WARNING
)
<
<
"
P2PTransportChannel
:
:
OnUnknownAddress
-
"
<
<
"
No
STUN_ATTR_PRIORITY
found
in
the
"
<
<
"
stun
request
message
"
;
port
-
>
SendBindingErrorResponse
(
stun_msg
address
STUN_ERROR_BAD_REQUEST
STUN_ERROR_REASON_BAD_REQUEST
)
;
return
;
}
new_remote_candidate
.
set_priority
(
priority_attr
-
>
value
(
)
)
;
if
(
port
-
>
GetConnection
(
new_remote_candidate
.
address
(
)
)
)
{
if
(
port_muxed
)
{
LOG
(
LS_INFO
)
<
<
"
Connection
already
exists
for
peer
reflexive
"
<
<
"
candidate
:
"
<
<
new_remote_candidate
.
ToString
(
)
;
return
;
}
else
{
ASSERT
(
false
)
;
port
-
>
SendBindingErrorResponse
(
stun_msg
address
STUN_ERROR_SERVER_ERROR
STUN_ERROR_REASON_SERVER_ERROR
)
;
return
;
}
}
Connection
*
connection
=
port
-
>
CreateConnection
(
new_remote_candidate
cricket
:
:
PortInterface
:
:
ORIGIN_THIS_PORT
)
;
if
(
!
connection
)
{
ASSERT
(
false
)
;
port
-
>
SendBindingErrorResponse
(
stun_msg
address
STUN_ERROR_SERVER_ERROR
STUN_ERROR_REASON_SERVER_ERROR
)
;
return
;
}
LOG
(
LS_INFO
)
<
<
"
Adding
connection
from
peer
reflexive
candidate
:
"
<
<
new_remote_candidate
.
ToString
(
)
;
AddConnection
(
connection
)
;
connection
-
>
ReceivedPing
(
)
;
port
-
>
SendBindingResponse
(
stun_msg
address
)
;
SortConnections
(
)
;
}
else
{
if
(
!
CreateConnections
(
new_remote_candidate
port
true
)
)
{
ASSERT
(
false
)
;
port
-
>
SendBindingErrorResponse
(
stun_msg
address
STUN_ERROR_SERVER_ERROR
STUN_ERROR_REASON_SERVER_ERROR
)
;
return
;
}
port
-
>
SendBindingResponse
(
stun_msg
address
)
;
SortConnections
(
)
;
}
}
void
P2PTransportChannel
:
:
OnRoleConflict
(
PortInterface
*
port
)
{
SignalRoleConflict
(
this
)
;
}
void
P2PTransportChannel
:
:
OnSignalingReady
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
waiting_for_signaling_
)
{
waiting_for_signaling_
=
false
;
AddAllocatorSession
(
allocator_
-
>
CreateSession
(
SessionId
(
)
content_name
(
)
component
(
)
ice_ufrag_
ice_pwd_
)
)
;
}
}
void
P2PTransportChannel
:
:
OnUseCandidate
(
Connection
*
conn
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
ASSERT
(
ice_role_
=
=
ICEROLE_CONTROLLED
)
;
ASSERT
(
protocol_type_
=
=
ICEPROTO_RFC5245
)
;
if
(
conn
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITABLE
)
{
if
(
best_connection_
!
=
conn
)
{
pending_best_connection_
=
NULL
;
SwitchBestConnectionTo
(
conn
)
;
RequestSort
(
)
;
}
}
else
{
pending_best_connection_
=
conn
;
}
}
void
P2PTransportChannel
:
:
OnCandidate
(
const
Candidate
&
candidate
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
CreateConnections
(
candidate
NULL
false
)
;
SortConnections
(
)
;
}
bool
P2PTransportChannel
:
:
CreateConnections
(
const
Candidate
&
remote_candidate
PortInterface
*
origin_port
bool
readable
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
Candidate
new_remote_candidate
(
remote_candidate
)
;
new_remote_candidate
.
set_generation
(
GetRemoteCandidateGeneration
(
remote_candidate
)
)
;
if
(
remote_candidate
.
username
(
)
.
empty
(
)
)
{
new_remote_candidate
.
set_username
(
remote_ice_ufrag_
)
;
}
if
(
remote_candidate
.
password
(
)
.
empty
(
)
)
{
new_remote_candidate
.
set_password
(
remote_ice_pwd_
)
;
}
if
(
!
origin_port
&
&
IsDuplicateRemoteCandidate
(
new_remote_candidate
)
)
{
return
true
;
}
bool
created
=
false
;
std
:
:
vector
<
PortInterface
*
>
:
:
reverse_iterator
it
;
for
(
it
=
ports_
.
rbegin
(
)
;
it
!
=
ports_
.
rend
(
)
;
+
+
it
)
{
if
(
CreateConnection
(
*
it
new_remote_candidate
origin_port
readable
)
)
{
if
(
*
it
=
=
origin_port
)
created
=
true
;
}
}
if
(
(
origin_port
!
=
NULL
)
&
&
std
:
:
find
(
ports_
.
begin
(
)
ports_
.
end
(
)
origin_port
)
=
=
ports_
.
end
(
)
)
{
if
(
CreateConnection
(
origin_port
new_remote_candidate
origin_port
readable
)
)
created
=
true
;
}
RememberRemoteCandidate
(
new_remote_candidate
origin_port
)
;
return
created
;
}
bool
P2PTransportChannel
:
:
CreateConnection
(
PortInterface
*
port
const
Candidate
&
remote_candidate
PortInterface
*
origin_port
bool
readable
)
{
Connection
*
connection
=
port
-
>
GetConnection
(
remote_candidate
.
address
(
)
)
;
if
(
connection
!
=
NULL
)
{
connection
-
>
MaybeUpdatePeerReflexiveCandidate
(
remote_candidate
)
;
if
(
!
remote_candidate
.
IsEquivalent
(
connection
-
>
remote_candidate
(
)
)
)
{
LOG
(
INFO
)
<
<
"
Attempt
to
change
a
remote
candidate
.
"
<
<
"
Existing
remote
candidate
:
"
<
<
connection
-
>
remote_candidate
(
)
.
ToString
(
)
<
<
"
New
remote
candidate
:
"
<
<
remote_candidate
.
ToString
(
)
;
return
false
;
}
}
else
{
PortInterface
:
:
CandidateOrigin
origin
=
GetOrigin
(
port
origin_port
)
;
if
(
origin
=
=
cricket
:
:
PortInterface
:
:
ORIGIN_MESSAGE
&
&
incoming_only_
)
return
false
;
connection
=
port
-
>
CreateConnection
(
remote_candidate
origin
)
;
if
(
!
connection
)
return
false
;
AddConnection
(
connection
)
;
LOG_J
(
LS_INFO
this
)
<
<
"
Created
connection
with
origin
=
"
<
<
origin
<
<
"
(
"
<
<
connections_
.
size
(
)
<
<
"
total
)
"
;
}
if
(
readable
)
connection
-
>
ReceivedPing
(
)
;
return
true
;
}
bool
P2PTransportChannel
:
:
FindConnection
(
cricket
:
:
Connection
*
connection
)
const
{
std
:
:
vector
<
Connection
*
>
:
:
const_iterator
citer
=
std
:
:
find
(
connections_
.
begin
(
)
connections_
.
end
(
)
connection
)
;
return
citer
!
=
connections_
.
end
(
)
;
}
uint32
P2PTransportChannel
:
:
GetRemoteCandidateGeneration
(
const
Candidate
&
candidate
)
{
if
(
protocol_type_
=
=
ICEPROTO_GOOGLE
)
{
return
candidate
.
generation
(
)
;
}
ASSERT
(
candidate
.
generation
(
)
=
=
0
|
|
candidate
.
generation
(
)
=
=
remote_candidate_generation_
)
;
return
remote_candidate_generation_
;
}
bool
P2PTransportChannel
:
:
IsDuplicateRemoteCandidate
(
const
Candidate
&
candidate
)
{
for
(
uint32
i
=
0
;
i
<
remote_candidates_
.
size
(
)
;
+
+
i
)
{
if
(
remote_candidates_
[
i
]
.
IsEquivalent
(
candidate
)
)
{
return
true
;
}
}
return
false
;
}
void
P2PTransportChannel
:
:
RememberRemoteCandidate
(
const
Candidate
&
remote_candidate
PortInterface
*
origin_port
)
{
uint32
i
=
0
;
while
(
i
<
remote_candidates_
.
size
(
)
)
{
if
(
remote_candidates_
[
i
]
.
generation
(
)
<
remote_candidate
.
generation
(
)
)
{
LOG
(
INFO
)
<
<
"
Pruning
candidate
from
old
generation
:
"
<
<
remote_candidates_
[
i
]
.
address
(
)
.
ToSensitiveString
(
)
;
remote_candidates_
.
erase
(
remote_candidates_
.
begin
(
)
+
i
)
;
}
else
{
i
+
=
1
;
}
}
if
(
IsDuplicateRemoteCandidate
(
remote_candidate
)
)
{
LOG
(
INFO
)
<
<
"
Duplicate
candidate
:
"
<
<
remote_candidate
.
ToString
(
)
;
return
;
}
remote_candidates_
.
push_back
(
RemoteCandidate
(
remote_candidate
origin_port
)
)
;
}
int
P2PTransportChannel
:
:
SetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
value
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
OptionMap
:
:
iterator
it
=
options_
.
find
(
opt
)
;
if
(
it
=
=
options_
.
end
(
)
)
{
options_
.
insert
(
std
:
:
make_pair
(
opt
value
)
)
;
}
else
if
(
it
-
>
second
=
=
value
)
{
return
0
;
}
else
{
it
-
>
second
=
value
;
}
for
(
uint32
i
=
0
;
i
<
ports_
.
size
(
)
;
+
+
i
)
{
int
val
=
ports_
[
i
]
-
>
SetOption
(
opt
value
)
;
if
(
val
<
0
)
{
LOG
(
WARNING
)
<
<
"
SetOption
(
"
<
<
opt
<
<
"
"
<
<
value
<
<
"
)
failed
:
"
<
<
ports_
[
i
]
-
>
GetError
(
)
;
}
}
return
0
;
}
bool
P2PTransportChannel
:
:
GetOption
(
rtc
:
:
Socket
:
:
Option
opt
int
*
value
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
const
auto
&
found
=
options_
.
find
(
opt
)
;
if
(
found
=
=
options_
.
end
(
)
)
{
return
false
;
}
*
value
=
found
-
>
second
;
return
true
;
}
int
P2PTransportChannel
:
:
SendPacket
(
const
char
*
data
size_t
len
const
rtc
:
:
PacketOptions
&
options
int
flags
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
flags
!
=
0
)
{
error_
=
EINVAL
;
return
-
1
;
}
if
(
best_connection_
=
=
NULL
)
{
error_
=
EWOULDBLOCK
;
return
-
1
;
}
int
sent
=
best_connection_
-
>
Send
(
data
len
options
)
;
if
(
sent
<
=
0
)
{
ASSERT
(
sent
<
0
)
;
error_
=
best_connection_
-
>
GetError
(
)
;
}
return
sent
;
}
bool
P2PTransportChannel
:
:
GetStats
(
ConnectionInfos
*
infos
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
infos
-
>
clear
(
)
;
std
:
:
vector
<
Connection
*
>
:
:
const_iterator
it
;
for
(
it
=
connections_
.
begin
(
)
;
it
!
=
connections_
.
end
(
)
;
+
+
it
)
{
Connection
*
connection
=
*
it
;
ConnectionInfo
info
;
info
.
best_connection
=
(
best_connection_
=
=
connection
)
;
info
.
readable
=
(
connection
-
>
read_state
(
)
=
=
Connection
:
:
STATE_READABLE
)
;
info
.
writable
=
(
connection
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITABLE
)
;
info
.
timeout
=
(
connection
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITE_TIMEOUT
)
;
info
.
new_connection
=
!
connection
-
>
reported
(
)
;
connection
-
>
set_reported
(
true
)
;
info
.
rtt
=
connection
-
>
rtt
(
)
;
info
.
sent_total_bytes
=
connection
-
>
sent_total_bytes
(
)
;
info
.
sent_bytes_second
=
connection
-
>
sent_bytes_second
(
)
;
info
.
sent_discarded_packets
=
connection
-
>
sent_discarded_packets
(
)
;
info
.
sent_total_packets
=
connection
-
>
sent_total_packets
(
)
;
info
.
recv_total_bytes
=
connection
-
>
recv_total_bytes
(
)
;
info
.
recv_bytes_second
=
connection
-
>
recv_bytes_second
(
)
;
info
.
local_candidate
=
connection
-
>
local_candidate
(
)
;
info
.
remote_candidate
=
connection
-
>
remote_candidate
(
)
;
info
.
key
=
connection
;
infos
-
>
push_back
(
info
)
;
}
return
true
;
}
rtc
:
:
DiffServCodePoint
P2PTransportChannel
:
:
DefaultDscpValue
(
)
const
{
OptionMap
:
:
const_iterator
it
=
options_
.
find
(
rtc
:
:
Socket
:
:
OPT_DSCP
)
;
if
(
it
=
=
options_
.
end
(
)
)
{
return
rtc
:
:
DSCP_NO_CHANGE
;
}
return
static_cast
<
rtc
:
:
DiffServCodePoint
>
(
it
-
>
second
)
;
}
void
P2PTransportChannel
:
:
Allocate
(
)
{
waiting_for_signaling_
=
true
;
SignalRequestSignaling
(
this
)
;
}
void
P2PTransportChannel
:
:
UpdateConnectionStates
(
)
{
uint32
now
=
rtc
:
:
Time
(
)
;
for
(
uint32
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
connections_
[
i
]
-
>
UpdateState
(
now
)
;
}
void
P2PTransportChannel
:
:
RequestSort
(
)
{
if
(
!
sort_dirty_
)
{
worker_thread_
-
>
Post
(
this
MSG_SORT
)
;
sort_dirty_
=
true
;
}
}
void
P2PTransportChannel
:
:
SortConnections
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
UpdateConnectionStates
(
)
;
if
(
protocol_type_
=
=
ICEPROTO_HYBRID
)
{
UpdateChannelState
(
)
;
return
;
}
sort_dirty_
=
false
;
std
:
:
set
<
rtc
:
:
Network
*
>
networks
;
for
(
uint32
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
networks
.
insert
(
connections_
[
i
]
-
>
port
(
)
-
>
Network
(
)
)
;
ConnectionCompare
cmp
;
std
:
:
stable_sort
(
connections_
.
begin
(
)
connections_
.
end
(
)
cmp
)
;
LOG
(
LS_VERBOSE
)
<
<
"
Sorting
available
connections
:
"
;
for
(
uint32
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
LOG
(
LS_VERBOSE
)
<
<
connections_
[
i
]
-
>
ToString
(
)
;
}
Connection
*
top_connection
=
NULL
;
if
(
connections_
.
size
(
)
>
0
)
top_connection
=
connections_
[
0
]
;
if
(
protocol_type_
!
=
ICEPROTO_RFC5245
|
|
ice_role_
=
=
ICEROLE_CONTROLLING
)
{
if
(
ShouldSwitch
(
best_connection_
top_connection
)
)
SwitchBestConnectionTo
(
top_connection
)
;
}
std
:
:
set
<
rtc
:
:
Network
*
>
:
:
iterator
network
;
for
(
network
=
networks
.
begin
(
)
;
network
!
=
networks
.
end
(
)
;
+
+
network
)
{
Connection
*
primier
=
GetBestConnectionOnNetwork
(
*
network
)
;
if
(
!
primier
|
|
(
primier
-
>
write_state
(
)
!
=
Connection
:
:
STATE_WRITABLE
)
)
continue
;
for
(
uint32
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
if
(
(
connections_
[
i
]
!
=
primier
)
&
&
(
connections_
[
i
]
-
>
port
(
)
-
>
Network
(
)
=
=
*
network
)
&
&
(
CompareConnectionCandidates
(
primier
connections_
[
i
]
)
>
=
0
)
)
{
connections_
[
i
]
-
>
Prune
(
)
;
}
}
}
bool
all_connections_timedout
=
true
;
for
(
uint32
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
if
(
connections_
[
i
]
-
>
write_state
(
)
!
=
Connection
:
:
STATE_WRITE_TIMEOUT
)
{
all_connections_timedout
=
false
;
break
;
}
}
if
(
best_connection_
&
&
best_connection_
-
>
writable
(
)
)
{
HandleWritable
(
)
;
}
else
if
(
all_connections_timedout
)
{
HandleAllTimedOut
(
)
;
}
else
{
HandleNotWritable
(
)
;
}
UpdateChannelState
(
)
;
}
void
P2PTransportChannel
:
:
SwitchBestConnectionTo
(
Connection
*
conn
)
{
Connection
*
old_best_connection
=
best_connection_
;
best_connection_
=
conn
;
if
(
best_connection_
)
{
if
(
old_best_connection
)
{
LOG_J
(
LS_INFO
this
)
<
<
"
Previous
best
connection
:
"
<
<
old_best_connection
-
>
ToString
(
)
;
}
LOG_J
(
LS_INFO
this
)
<
<
"
New
best
connection
:
"
<
<
best_connection_
-
>
ToString
(
)
;
SignalRouteChange
(
this
best_connection_
-
>
remote_candidate
(
)
)
;
}
else
{
LOG_J
(
LS_INFO
this
)
<
<
"
No
best
connection
"
;
}
}
void
P2PTransportChannel
:
:
UpdateChannelState
(
)
{
bool
writable
=
(
(
best_connection_
!
=
NULL
)
&
&
(
best_connection_
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITABLE
)
)
;
ASSERT
(
writable
=
=
this
-
>
writable
(
)
)
;
if
(
writable
!
=
this
-
>
writable
(
)
)
LOG
(
LS_ERROR
)
<
<
"
UpdateChannelState
:
writable
state
mismatch
"
;
bool
readable
=
false
;
for
(
uint32
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
if
(
connections_
[
i
]
-
>
read_state
(
)
=
=
Connection
:
:
STATE_READABLE
)
{
readable
=
true
;
break
;
}
}
set_readable
(
readable
)
;
}
void
P2PTransportChannel
:
:
HandleWritable
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
!
writable
(
)
)
{
for
(
uint32
i
=
0
;
i
<
allocator_sessions_
.
size
(
)
;
+
+
i
)
{
if
(
allocator_sessions_
[
i
]
-
>
IsGettingPorts
(
)
)
{
allocator_sessions_
[
i
]
-
>
StopGettingPorts
(
)
;
}
}
}
was_writable_
=
true
;
set_writable
(
true
)
;
}
void
P2PTransportChannel
:
:
HandleNotWritable
(
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
was_writable_
)
{
was_writable_
=
false
;
set_writable
(
false
)
;
}
}
void
P2PTransportChannel
:
:
HandleAllTimedOut
(
)
{
HandleNotWritable
(
)
;
}
Connection
*
P2PTransportChannel
:
:
GetBestConnectionOnNetwork
(
rtc
:
:
Network
*
network
)
const
{
if
(
best_connection_
&
&
(
best_connection_
-
>
port
(
)
-
>
Network
(
)
=
=
network
)
)
return
best_connection_
;
for
(
uint32
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
if
(
connections_
[
i
]
-
>
port
(
)
-
>
Network
(
)
=
=
network
)
return
connections_
[
i
]
;
}
return
NULL
;
}
void
P2PTransportChannel
:
:
OnMessage
(
rtc
:
:
Message
*
pmsg
)
{
switch
(
pmsg
-
>
message_id
)
{
case
MSG_SORT
:
OnSort
(
)
;
break
;
case
MSG_PING
:
OnPing
(
)
;
break
;
default
:
ASSERT
(
false
)
;
break
;
}
}
void
P2PTransportChannel
:
:
OnSort
(
)
{
SortConnections
(
)
;
}
void
P2PTransportChannel
:
:
OnPing
(
)
{
UpdateConnectionStates
(
)
;
Connection
*
conn
=
FindNextPingableConnection
(
)
;
if
(
conn
)
PingConnection
(
conn
)
;
uint32
delay
=
writable
(
)
?
WRITABLE_DELAY
:
UNWRITABLE_DELAY
;
thread
(
)
-
>
PostDelayed
(
delay
this
MSG_PING
)
;
}
bool
P2PTransportChannel
:
:
IsPingable
(
Connection
*
conn
)
{
const
Candidate
&
remote
=
conn
-
>
remote_candidate
(
)
;
ASSERT
(
!
remote
.
username
(
)
.
empty
(
)
)
;
if
(
remote
.
username
(
)
.
empty
(
)
|
|
remote
.
password
(
)
.
empty
(
)
)
{
return
false
;
}
if
(
!
conn
-
>
connected
(
)
)
return
false
;
if
(
writable
(
)
)
{
return
(
conn
-
>
write_state
(
)
!
=
Connection
:
:
STATE_WRITE_TIMEOUT
)
;
}
else
{
return
(
conn
-
>
write_state
(
)
!
=
Connection
:
:
STATE_WRITE_TIMEOUT
)
|
|
(
conn
-
>
read_state
(
)
!
=
Connection
:
:
STATE_READ_TIMEOUT
)
;
}
}
Connection
*
P2PTransportChannel
:
:
FindNextPingableConnection
(
)
{
uint32
now
=
rtc
:
:
Time
(
)
;
if
(
best_connection_
&
&
(
best_connection_
-
>
write_state
(
)
=
=
Connection
:
:
STATE_WRITABLE
)
&
&
(
best_connection_
-
>
last_ping_sent
(
)
+
MAX_CURRENT_WRITABLE_DELAY
<
=
now
)
)
{
return
best_connection_
;
}
Connection
*
oldest_conn
=
NULL
;
uint32
oldest_time
=
0xFFFFFFFF
;
for
(
uint32
i
=
0
;
i
<
connections_
.
size
(
)
;
+
+
i
)
{
if
(
IsPingable
(
connections_
[
i
]
)
)
{
if
(
connections_
[
i
]
-
>
last_ping_sent
(
)
<
oldest_time
)
{
oldest_time
=
connections_
[
i
]
-
>
last_ping_sent
(
)
;
oldest_conn
=
connections_
[
i
]
;
}
}
}
return
oldest_conn
;
}
void
P2PTransportChannel
:
:
PingConnection
(
Connection
*
conn
)
{
bool
use_candidate
=
false
;
if
(
protocol_type_
=
=
ICEPROTO_RFC5245
)
{
if
(
remote_ice_mode_
=
=
ICEMODE_FULL
&
&
ice_role_
=
=
ICEROLE_CONTROLLING
)
{
use_candidate
=
(
conn
=
=
best_connection_
)
|
|
(
best_connection_
=
=
NULL
)
|
|
(
!
best_connection_
-
>
writable
(
)
)
|
|
(
conn
-
>
priority
(
)
>
best_connection_
-
>
priority
(
)
)
;
}
else
if
(
remote_ice_mode_
=
=
ICEMODE_LITE
&
&
conn
=
=
best_connection_
)
{
use_candidate
=
best_connection_
-
>
writable
(
)
;
}
}
conn
-
>
set_use_candidate_attr
(
use_candidate
)
;
conn
-
>
Ping
(
rtc
:
:
Time
(
)
)
;
}
void
P2PTransportChannel
:
:
OnConnectionStateChange
(
Connection
*
connection
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
protocol_type_
=
=
ICEPROTO_RFC5245
&
&
ice_role_
=
=
ICEROLE_CONTROLLED
)
{
if
(
connection
=
=
pending_best_connection_
&
&
connection
-
>
writable
(
)
)
{
pending_best_connection_
=
NULL
;
SwitchBestConnectionTo
(
connection
)
;
}
}
RequestSort
(
)
;
}
void
P2PTransportChannel
:
:
OnConnectionDestroyed
(
Connection
*
connection
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
std
:
:
vector
<
Connection
*
>
:
:
iterator
iter
=
std
:
:
find
(
connections_
.
begin
(
)
connections_
.
end
(
)
connection
)
;
ASSERT
(
iter
!
=
connections_
.
end
(
)
)
;
connections_
.
erase
(
iter
)
;
LOG_J
(
LS_INFO
this
)
<
<
"
Removed
connection
(
"
<
<
static_cast
<
int
>
(
connections_
.
size
(
)
)
<
<
"
remaining
)
"
;
if
(
pending_best_connection_
=
=
connection
)
{
pending_best_connection_
=
NULL
;
}
if
(
best_connection_
=
=
connection
)
{
SwitchBestConnectionTo
(
NULL
)
;
RequestSort
(
)
;
}
SignalConnectionRemoved
(
this
)
;
}
void
P2PTransportChannel
:
:
OnPortDestroyed
(
PortInterface
*
port
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
std
:
:
vector
<
PortInterface
*
>
:
:
iterator
iter
=
std
:
:
find
(
ports_
.
begin
(
)
ports_
.
end
(
)
port
)
;
if
(
iter
!
=
ports_
.
end
(
)
)
ports_
.
erase
(
iter
)
;
LOG
(
INFO
)
<
<
"
Removed
port
from
p2p
socket
:
"
<
<
static_cast
<
int
>
(
ports_
.
size
(
)
)
<
<
"
remaining
"
;
}
void
P2PTransportChannel
:
:
OnReadPacket
(
Connection
*
connection
const
char
*
data
size_t
len
const
rtc
:
:
PacketTime
&
packet_time
)
{
ASSERT
(
worker_thread_
=
=
rtc
:
:
Thread
:
:
Current
(
)
)
;
if
(
!
FindConnection
(
connection
)
)
return
;
SignalReadPacket
(
this
data
len
packet_time
0
)
;
}
void
P2PTransportChannel
:
:
OnReadyToSend
(
Connection
*
connection
)
{
if
(
connection
=
=
best_connection_
&
&
writable
(
)
)
{
SignalReadyToSend
(
this
)
;
}
}
}
