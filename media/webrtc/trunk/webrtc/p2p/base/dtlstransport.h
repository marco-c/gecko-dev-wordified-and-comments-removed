#
ifndef
WEBRTC_P2P_BASE_DTLSTRANSPORT_H_
#
define
WEBRTC_P2P_BASE_DTLSTRANSPORT_H_
#
include
"
webrtc
/
p2p
/
base
/
dtlstransportchannel
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
transport
.
h
"
namespace
rtc
{
class
SSLIdentity
;
}
namespace
cricket
{
class
PortAllocator
;
template
<
class
Base
>
class
DtlsTransport
:
public
Base
{
public
:
DtlsTransport
(
const
std
:
:
string
&
name
PortAllocator
*
allocator
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
certificate
)
:
Base
(
name
allocator
)
certificate_
(
certificate
)
secure_role_
(
rtc
:
:
SSL_CLIENT
)
ssl_max_version_
(
rtc
:
:
SSL_PROTOCOL_DTLS_12
)
{
}
~
DtlsTransport
(
)
{
Base
:
:
DestroyAllChannels
(
)
;
}
void
SetLocalCertificate
(
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
certificate
)
override
{
certificate_
=
certificate
;
}
bool
GetLocalCertificate
(
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
*
certificate
)
override
{
if
(
!
certificate_
)
return
false
;
*
certificate
=
certificate_
;
return
true
;
}
bool
SetSslMaxProtocolVersion
(
rtc
:
:
SSLProtocolVersion
version
)
override
{
ssl_max_version_
=
version
;
return
true
;
}
bool
ApplyLocalTransportDescription
(
TransportChannelImpl
*
channel
std
:
:
string
*
error_desc
)
override
{
rtc
:
:
SSLFingerprint
*
local_fp
=
Base
:
:
local_description
(
)
-
>
identity_fingerprint
.
get
(
)
;
if
(
local_fp
)
{
if
(
certificate_
)
{
rtc
:
:
scoped_ptr
<
rtc
:
:
SSLFingerprint
>
local_fp_tmp
(
rtc
:
:
SSLFingerprint
:
:
Create
(
local_fp
-
>
algorithm
certificate_
-
>
identity
(
)
)
)
;
ASSERT
(
local_fp_tmp
.
get
(
)
!
=
NULL
)
;
if
(
!
(
*
local_fp_tmp
=
=
*
local_fp
)
)
{
std
:
:
ostringstream
desc
;
desc
<
<
"
Local
fingerprint
does
not
match
identity
.
Expected
:
"
;
desc
<
<
local_fp_tmp
-
>
ToString
(
)
;
desc
<
<
"
Got
:
"
<
<
local_fp
-
>
ToString
(
)
;
return
BadTransportDescription
(
desc
.
str
(
)
error_desc
)
;
}
}
else
{
return
BadTransportDescription
(
"
Local
fingerprint
provided
but
no
identity
available
.
"
error_desc
)
;
}
}
else
{
certificate_
=
nullptr
;
}
if
(
!
channel
-
>
SetLocalCertificate
(
certificate_
)
)
{
return
BadTransportDescription
(
"
Failed
to
set
local
identity
.
"
error_desc
)
;
}
return
Base
:
:
ApplyLocalTransportDescription
(
channel
error_desc
)
;
}
bool
NegotiateTransportDescription
(
ContentAction
local_role
std
:
:
string
*
error_desc
)
override
{
if
(
!
Base
:
:
local_description
(
)
|
|
!
Base
:
:
remote_description
(
)
)
{
const
std
:
:
string
msg
=
"
Local
and
Remote
description
must
be
set
before
"
"
transport
descriptions
are
negotiated
"
;
return
BadTransportDescription
(
msg
error_desc
)
;
}
rtc
:
:
SSLFingerprint
*
local_fp
=
Base
:
:
local_description
(
)
-
>
identity_fingerprint
.
get
(
)
;
rtc
:
:
SSLFingerprint
*
remote_fp
=
Base
:
:
remote_description
(
)
-
>
identity_fingerprint
.
get
(
)
;
if
(
remote_fp
&
&
local_fp
)
{
remote_fingerprint_
.
reset
(
new
rtc
:
:
SSLFingerprint
(
*
remote_fp
)
)
;
ConnectionRole
local_connection_role
=
Base
:
:
local_description
(
)
-
>
connection_role
;
ConnectionRole
remote_connection_role
=
Base
:
:
remote_description
(
)
-
>
connection_role
;
bool
is_remote_server
=
false
;
if
(
local_role
=
=
CA_OFFER
)
{
if
(
local_connection_role
!
=
CONNECTIONROLE_ACTPASS
)
{
return
BadTransportDescription
(
"
Offerer
must
use
actpass
value
for
setup
attribute
.
"
error_desc
)
;
}
if
(
remote_connection_role
=
=
CONNECTIONROLE_ACTIVE
|
|
remote_connection_role
=
=
CONNECTIONROLE_PASSIVE
|
|
remote_connection_role
=
=
CONNECTIONROLE_NONE
)
{
is_remote_server
=
(
remote_connection_role
=
=
CONNECTIONROLE_PASSIVE
)
;
}
else
{
const
std
:
:
string
msg
=
"
Answerer
must
use
either
active
or
passive
value
"
"
for
setup
attribute
.
"
;
return
BadTransportDescription
(
msg
error_desc
)
;
}
}
else
{
if
(
remote_connection_role
!
=
CONNECTIONROLE_ACTPASS
&
&
remote_connection_role
!
=
CONNECTIONROLE_NONE
)
{
return
BadTransportDescription
(
"
Offerer
must
use
actpass
value
for
setup
attribute
.
"
error_desc
)
;
}
if
(
local_connection_role
=
=
CONNECTIONROLE_ACTIVE
|
|
local_connection_role
=
=
CONNECTIONROLE_PASSIVE
)
{
is_remote_server
=
(
local_connection_role
=
=
CONNECTIONROLE_ACTIVE
)
;
}
else
{
const
std
:
:
string
msg
=
"
Answerer
must
use
either
active
or
passive
value
"
"
for
setup
attribute
.
"
;
return
BadTransportDescription
(
msg
error_desc
)
;
}
}
secure_role_
=
is_remote_server
?
rtc
:
:
SSL_CLIENT
:
rtc
:
:
SSL_SERVER
;
}
else
if
(
local_fp
&
&
(
local_role
=
=
CA_ANSWER
)
)
{
return
BadTransportDescription
(
"
Local
fingerprint
supplied
when
caller
didn
'
t
offer
DTLS
.
"
error_desc
)
;
}
else
{
remote_fingerprint_
.
reset
(
new
rtc
:
:
SSLFingerprint
(
"
"
NULL
0
)
)
;
}
return
Base
:
:
NegotiateTransportDescription
(
local_role
error_desc
)
;
}
DtlsTransportChannelWrapper
*
CreateTransportChannel
(
int
component
)
override
{
DtlsTransportChannelWrapper
*
channel
=
new
DtlsTransportChannelWrapper
(
this
Base
:
:
CreateTransportChannel
(
component
)
)
;
channel
-
>
SetSslMaxProtocolVersion
(
ssl_max_version_
)
;
return
channel
;
}
void
DestroyTransportChannel
(
TransportChannelImpl
*
channel
)
override
{
DtlsTransportChannelWrapper
*
dtls_channel
=
static_cast
<
DtlsTransportChannelWrapper
*
>
(
channel
)
;
TransportChannelImpl
*
base_channel
=
dtls_channel
-
>
channel
(
)
;
delete
dtls_channel
;
Base
:
:
DestroyTransportChannel
(
base_channel
)
;
}
bool
GetSslRole
(
rtc
:
:
SSLRole
*
ssl_role
)
const
override
{
ASSERT
(
ssl_role
!
=
NULL
)
;
*
ssl_role
=
secure_role_
;
return
true
;
}
private
:
bool
ApplyNegotiatedTransportDescription
(
TransportChannelImpl
*
channel
std
:
:
string
*
error_desc
)
override
{
if
(
!
channel
-
>
SetSslRole
(
secure_role_
)
)
{
return
BadTransportDescription
(
"
Failed
to
set
ssl
role
for
the
channel
.
"
error_desc
)
;
}
if
(
!
channel
-
>
SetRemoteFingerprint
(
remote_fingerprint_
-
>
algorithm
reinterpret_cast
<
const
uint8_t
*
>
(
remote_fingerprint_
-
>
digest
.
data
(
)
)
remote_fingerprint_
-
>
digest
.
size
(
)
)
)
{
return
BadTransportDescription
(
"
Failed
to
apply
remote
fingerprint
.
"
error_desc
)
;
}
return
Base
:
:
ApplyNegotiatedTransportDescription
(
channel
error_desc
)
;
}
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
certificate_
;
rtc
:
:
SSLRole
secure_role_
;
rtc
:
:
SSLProtocolVersion
ssl_max_version_
;
rtc
:
:
scoped_ptr
<
rtc
:
:
SSLFingerprint
>
remote_fingerprint_
;
}
;
}
#
endif
