#
ifndef
WEBRTC_P2P_BASE_DTLSTRANSPORT_H_
#
define
WEBRTC_P2P_BASE_DTLSTRANSPORT_H_
#
include
"
webrtc
/
p2p
/
base
/
dtlstransportchannel
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
transport
.
h
"
namespace
rtc
{
class
SSLIdentity
;
}
namespace
cricket
{
class
PortAllocator
;
template
<
class
Base
>
class
DtlsTransport
:
public
Base
{
public
:
DtlsTransport
(
rtc
:
:
Thread
*
signaling_thread
rtc
:
:
Thread
*
worker_thread
const
std
:
:
string
&
content_name
PortAllocator
*
allocator
rtc
:
:
SSLIdentity
*
identity
)
:
Base
(
signaling_thread
worker_thread
content_name
allocator
)
identity_
(
identity
)
secure_role_
(
rtc
:
:
SSL_CLIENT
)
{
}
~
DtlsTransport
(
)
{
Base
:
:
DestroyAllChannels
(
)
;
}
virtual
void
SetIdentity_w
(
rtc
:
:
SSLIdentity
*
identity
)
{
identity_
=
identity
;
}
virtual
bool
GetIdentity_w
(
rtc
:
:
SSLIdentity
*
*
identity
)
{
if
(
!
identity_
)
return
false
;
*
identity
=
identity_
-
>
GetReference
(
)
;
return
true
;
}
virtual
bool
ApplyLocalTransportDescription_w
(
TransportChannelImpl
*
channel
std
:
:
string
*
error_desc
)
{
rtc
:
:
SSLFingerprint
*
local_fp
=
Base
:
:
local_description
(
)
-
>
identity_fingerprint
.
get
(
)
;
if
(
local_fp
)
{
if
(
identity_
)
{
rtc
:
:
scoped_ptr
<
rtc
:
:
SSLFingerprint
>
local_fp_tmp
(
rtc
:
:
SSLFingerprint
:
:
Create
(
local_fp
-
>
algorithm
identity_
)
)
;
ASSERT
(
local_fp_tmp
.
get
(
)
!
=
NULL
)
;
if
(
!
(
*
local_fp_tmp
=
=
*
local_fp
)
)
{
std
:
:
ostringstream
desc
;
desc
<
<
"
Local
fingerprint
does
not
match
identity
.
Expected
:
"
;
desc
<
<
local_fp_tmp
-
>
ToString
(
)
;
desc
<
<
"
Got
:
"
<
<
local_fp
-
>
ToString
(
)
;
return
BadTransportDescription
(
desc
.
str
(
)
error_desc
)
;
}
}
else
{
return
BadTransportDescription
(
"
Local
fingerprint
provided
but
no
identity
available
.
"
error_desc
)
;
}
}
else
{
identity_
=
NULL
;
}
if
(
!
channel
-
>
SetLocalIdentity
(
identity_
)
)
{
return
BadTransportDescription
(
"
Failed
to
set
local
identity
.
"
error_desc
)
;
}
return
Base
:
:
ApplyLocalTransportDescription_w
(
channel
error_desc
)
;
}
virtual
bool
NegotiateTransportDescription_w
(
ContentAction
local_role
std
:
:
string
*
error_desc
)
{
if
(
!
Base
:
:
local_description
(
)
|
|
!
Base
:
:
remote_description
(
)
)
{
const
std
:
:
string
msg
=
"
Local
and
Remote
description
must
be
set
before
"
"
transport
descriptions
are
negotiated
"
;
return
BadTransportDescription
(
msg
error_desc
)
;
}
rtc
:
:
SSLFingerprint
*
local_fp
=
Base
:
:
local_description
(
)
-
>
identity_fingerprint
.
get
(
)
;
rtc
:
:
SSLFingerprint
*
remote_fp
=
Base
:
:
remote_description
(
)
-
>
identity_fingerprint
.
get
(
)
;
if
(
remote_fp
&
&
local_fp
)
{
remote_fingerprint_
.
reset
(
new
rtc
:
:
SSLFingerprint
(
*
remote_fp
)
)
;
ConnectionRole
local_connection_role
=
Base
:
:
local_description
(
)
-
>
connection_role
;
ConnectionRole
remote_connection_role
=
Base
:
:
remote_description
(
)
-
>
connection_role
;
bool
is_remote_server
=
false
;
if
(
local_role
=
=
CA_OFFER
)
{
if
(
local_connection_role
!
=
CONNECTIONROLE_ACTPASS
)
{
return
BadTransportDescription
(
"
Offerer
must
use
actpass
value
for
setup
attribute
.
"
error_desc
)
;
}
if
(
remote_connection_role
=
=
CONNECTIONROLE_ACTIVE
|
|
remote_connection_role
=
=
CONNECTIONROLE_PASSIVE
|
|
remote_connection_role
=
=
CONNECTIONROLE_NONE
)
{
is_remote_server
=
(
remote_connection_role
=
=
CONNECTIONROLE_PASSIVE
)
;
}
else
{
const
std
:
:
string
msg
=
"
Answerer
must
use
either
active
or
passive
value
"
"
for
setup
attribute
.
"
;
return
BadTransportDescription
(
msg
error_desc
)
;
}
}
else
{
if
(
remote_connection_role
!
=
CONNECTIONROLE_ACTPASS
&
&
remote_connection_role
!
=
CONNECTIONROLE_NONE
)
{
return
BadTransportDescription
(
"
Offerer
must
use
actpass
value
for
setup
attribute
.
"
error_desc
)
;
}
if
(
local_connection_role
=
=
CONNECTIONROLE_ACTIVE
|
|
local_connection_role
=
=
CONNECTIONROLE_PASSIVE
)
{
is_remote_server
=
(
local_connection_role
=
=
CONNECTIONROLE_ACTIVE
)
;
}
else
{
const
std
:
:
string
msg
=
"
Answerer
must
use
either
active
or
passive
value
"
"
for
setup
attribute
.
"
;
return
BadTransportDescription
(
msg
error_desc
)
;
}
}
secure_role_
=
is_remote_server
?
rtc
:
:
SSL_CLIENT
:
rtc
:
:
SSL_SERVER
;
}
else
if
(
local_fp
&
&
(
local_role
=
=
CA_ANSWER
)
)
{
return
BadTransportDescription
(
"
Local
fingerprint
supplied
when
caller
didn
'
t
offer
DTLS
.
"
error_desc
)
;
}
else
{
remote_fingerprint_
.
reset
(
new
rtc
:
:
SSLFingerprint
(
"
"
NULL
0
)
)
;
}
return
Base
:
:
NegotiateTransportDescription_w
(
local_role
error_desc
)
;
}
virtual
DtlsTransportChannelWrapper
*
CreateTransportChannel
(
int
component
)
{
return
new
DtlsTransportChannelWrapper
(
this
Base
:
:
CreateTransportChannel
(
component
)
)
;
}
virtual
void
DestroyTransportChannel
(
TransportChannelImpl
*
channel
)
{
DtlsTransportChannelWrapper
*
dtls_channel
=
static_cast
<
DtlsTransportChannelWrapper
*
>
(
channel
)
;
TransportChannelImpl
*
base_channel
=
dtls_channel
-
>
channel
(
)
;
delete
dtls_channel
;
Base
:
:
DestroyTransportChannel
(
base_channel
)
;
}
virtual
bool
GetSslRole_w
(
rtc
:
:
SSLRole
*
ssl_role
)
const
{
ASSERT
(
ssl_role
!
=
NULL
)
;
*
ssl_role
=
secure_role_
;
return
true
;
}
private
:
virtual
bool
ApplyNegotiatedTransportDescription_w
(
TransportChannelImpl
*
channel
std
:
:
string
*
error_desc
)
{
if
(
!
channel
-
>
SetSslRole
(
secure_role_
)
)
{
return
BadTransportDescription
(
"
Failed
to
set
ssl
role
for
the
channel
.
"
error_desc
)
;
}
if
(
!
channel
-
>
SetRemoteFingerprint
(
remote_fingerprint_
-
>
algorithm
reinterpret_cast
<
const
uint8
*
>
(
remote_fingerprint_
-
>
digest
.
data
(
)
)
remote_fingerprint_
-
>
digest
.
size
(
)
)
)
{
return
BadTransportDescription
(
"
Failed
to
apply
remote
fingerprint
.
"
error_desc
)
;
}
return
Base
:
:
ApplyNegotiatedTransportDescription_w
(
channel
error_desc
)
;
}
rtc
:
:
SSLIdentity
*
identity_
;
rtc
:
:
SSLRole
secure_role_
;
rtc
:
:
scoped_ptr
<
rtc
:
:
SSLFingerprint
>
remote_fingerprint_
;
}
;
}
#
endif
