#
ifndef
WEBRTC_P2P_BASE_JSEPTRANSPORT_H_
#
define
WEBRTC_P2P_BASE_JSEPTRANSPORT_H_
#
include
<
map
>
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
#
include
"
webrtc
/
base
/
messagequeue
.
h
"
#
include
"
webrtc
/
base
/
optional
.
h
"
#
include
"
webrtc
/
base
/
rtccertificate
.
h
"
#
include
"
webrtc
/
base
/
sigslot
.
h
"
#
include
"
webrtc
/
base
/
sslstreamadapter
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
candidate
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
p2pconstants
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
sessiondescription
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
transportinfo
.
h
"
namespace
cricket
{
class
TransportChannelImpl
;
class
TransportChannelImpl
;
enum
class
IceCandidatePairState
;
typedef
std
:
:
vector
<
Candidate
>
Candidates
;
enum
IceConnectionState
{
kIceConnectionConnecting
=
0
kIceConnectionFailed
kIceConnectionConnected
kIceConnectionCompleted
}
;
enum
DtlsTransportState
{
DTLS_TRANSPORT_NEW
=
0
DTLS_TRANSPORT_CONNECTING
DTLS_TRANSPORT_CONNECTED
DTLS_TRANSPORT_CLOSED
DTLS_TRANSPORT_FAILED
}
;
enum
IceGatheringState
{
kIceGatheringNew
=
0
kIceGatheringGathering
kIceGatheringComplete
}
;
enum
ContinualGatheringPolicy
{
GATHER_ONCE
=
0
GATHER_CONTINUALLY
GATHER_CONTINUALLY_AND_RECOVER
}
;
struct
ConnectionInfo
{
ConnectionInfo
(
)
;
bool
best_connection
;
bool
writable
;
bool
receiving
;
bool
timeout
;
bool
new_connection
;
size_t
rtt
;
size_t
sent_total_bytes
;
size_t
sent_bytes_second
;
size_t
sent_discarded_packets
;
size_t
sent_total_packets
;
size_t
sent_ping_requests_total
;
size_t
sent_ping_requests_before_first_response
;
size_t
sent_ping_responses
;
size_t
recv_total_bytes
;
size_t
recv_bytes_second
;
size_t
recv_ping_requests
;
size_t
recv_ping_responses
;
Candidate
local_candidate
;
Candidate
remote_candidate
;
void
*
key
;
IceCandidatePairState
state
;
uint64_t
priority
;
}
;
typedef
std
:
:
vector
<
ConnectionInfo
>
ConnectionInfos
;
struct
TransportChannelStats
{
int
component
=
0
;
ConnectionInfos
connection_infos
;
int
srtp_crypto_suite
=
rtc
:
:
SRTP_INVALID_CRYPTO_SUITE
;
int
ssl_cipher_suite
=
rtc
:
:
TLS_NULL_WITH_NULL_NULL
;
DtlsTransportState
dtls_state
=
DTLS_TRANSPORT_NEW
;
}
;
typedef
std
:
:
vector
<
TransportChannelStats
>
TransportChannelStatsList
;
struct
TransportStats
{
std
:
:
string
transport_name
;
TransportChannelStatsList
channel_stats
;
}
;
enum
class
NominationMode
{
REGULAR
AGGRESSIVE
SEMI_AGGRESSIVE
}
;
struct
IceConfig
{
int
receiving_timeout
=
-
1
;
int
backup_connection_ping_interval
=
-
1
;
ContinualGatheringPolicy
continual_gathering_policy
=
GATHER_ONCE
;
bool
gather_continually
(
)
const
{
return
continual_gathering_policy
=
=
GATHER_CONTINUALLY
|
|
continual_gathering_policy
=
=
GATHER_CONTINUALLY_AND_RECOVER
;
}
bool
prioritize_most_likely_candidate_pairs
=
false
;
int
stable_writable_connection_ping_interval
=
-
1
;
bool
presume_writable_when_fully_relayed
=
false
;
rtc
:
:
Optional
<
int
>
regather_on_failed_networks_interval
;
rtc
:
:
Optional
<
int
>
receiving_switching_delay
;
NominationMode
default_nomination_mode
=
NominationMode
:
:
SEMI_AGGRESSIVE
;
IceConfig
(
)
{
}
IceConfig
(
int
receiving_timeout_ms
int
backup_connection_ping_interval
ContinualGatheringPolicy
gathering_policy
bool
prioritize_most_likely_candidate_pairs
int
stable_writable_connection_ping_interval_ms
bool
presume_writable_when_fully_relayed
int
regather_on_failed_networks_interval_ms
int
receiving_switching_delay_ms
)
:
receiving_timeout
(
receiving_timeout_ms
)
backup_connection_ping_interval
(
backup_connection_ping_interval
)
continual_gathering_policy
(
gathering_policy
)
prioritize_most_likely_candidate_pairs
(
prioritize_most_likely_candidate_pairs
)
stable_writable_connection_ping_interval
(
stable_writable_connection_ping_interval_ms
)
presume_writable_when_fully_relayed
(
presume_writable_when_fully_relayed
)
regather_on_failed_networks_interval
(
regather_on_failed_networks_interval_ms
)
receiving_switching_delay
(
receiving_switching_delay_ms
)
{
}
}
;
bool
BadTransportDescription
(
const
std
:
:
string
&
desc
std
:
:
string
*
err_desc
)
;
bool
IceCredentialsChanged
(
const
std
:
:
string
&
old_ufrag
const
std
:
:
string
&
old_pwd
const
std
:
:
string
&
new_ufrag
const
std
:
:
string
&
new_pwd
)
;
bool
VerifyCandidate
(
const
Candidate
&
candidate
std
:
:
string
*
error
)
;
bool
VerifyCandidates
(
const
Candidates
&
candidates
std
:
:
string
*
error
)
;
class
JsepTransport
:
public
sigslot
:
:
has_slots
<
>
{
public
:
JsepTransport
(
const
std
:
:
string
&
mid
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
certificate
)
;
const
std
:
:
string
&
mid
(
)
const
{
return
mid_
;
}
bool
AddChannel
(
TransportChannelImpl
*
dtls
int
component
)
;
bool
RemoveChannel
(
int
component
)
;
bool
HasChannels
(
)
const
;
bool
ready_for_remote_candidates
(
)
const
{
return
local_description_set_
&
&
remote_description_set_
;
}
void
SetLocalCertificate
(
const
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
&
certificate
)
;
bool
GetLocalCertificate
(
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
*
certificate
)
const
;
bool
SetLocalTransportDescription
(
const
TransportDescription
&
description
ContentAction
action
std
:
:
string
*
error_desc
)
;
bool
SetRemoteTransportDescription
(
const
TransportDescription
&
description
ContentAction
action
std
:
:
string
*
error_desc
)
;
void
SetNeedsIceRestartFlag
(
)
;
bool
NeedsIceRestart
(
)
const
;
void
GetSslRole
(
rtc
:
:
SSLRole
*
ssl_role
)
const
;
bool
GetStats
(
TransportStats
*
stats
)
;
const
TransportDescription
*
local_description
(
)
const
{
return
local_description_
.
get
(
)
;
}
const
TransportDescription
*
remote_description
(
)
const
{
return
remote_description_
.
get
(
)
;
}
bool
VerifyCertificateFingerprint
(
const
rtc
:
:
RTCCertificate
*
certificate
const
rtc
:
:
SSLFingerprint
*
fingerprint
std
:
:
string
*
error_desc
)
const
;
bool
NegotiateRole
(
ContentAction
local_role
rtc
:
:
SSLRole
*
ssl_role
std
:
:
string
*
error_desc
)
const
;
private
:
bool
NegotiateTransportDescription
(
ContentAction
local_role
std
:
:
string
*
error_desc
)
;
bool
ApplyLocalTransportDescription
(
TransportChannelImpl
*
channel
std
:
:
string
*
error_desc
)
;
bool
ApplyRemoteTransportDescription
(
TransportChannelImpl
*
channel
std
:
:
string
*
error_desc
)
;
bool
ApplyNegotiatedTransportDescription
(
TransportChannelImpl
*
channel
std
:
:
string
*
error_desc
)
;
const
std
:
:
string
mid_
;
bool
needs_ice_restart_
=
false
;
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
certificate_
;
rtc
:
:
SSLRole
secure_role_
=
rtc
:
:
SSL_CLIENT
;
std
:
:
unique_ptr
<
rtc
:
:
SSLFingerprint
>
remote_fingerprint_
;
std
:
:
unique_ptr
<
TransportDescription
>
local_description_
;
std
:
:
unique_ptr
<
TransportDescription
>
remote_description_
;
bool
local_description_set_
=
false
;
bool
remote_description_set_
=
false
;
std
:
:
map
<
int
TransportChannelImpl
*
>
channels_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
JsepTransport
)
;
}
;
}
#
endif
