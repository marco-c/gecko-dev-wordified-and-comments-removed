#
ifndef
WEBRTC_P2P_CLIENT_BASICPORTALLOCATOR_H_
#
define
WEBRTC_P2P_CLIENT_BASICPORTALLOCATOR_H_
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
p2p
/
base
/
portallocator
.
h
"
#
include
"
webrtc
/
base
/
messagequeue
.
h
"
#
include
"
webrtc
/
base
/
network
.
h
"
#
include
"
webrtc
/
base
/
scoped_ptr
.
h
"
#
include
"
webrtc
/
base
/
thread
.
h
"
namespace
cricket
{
class
BasicPortAllocator
:
public
PortAllocator
{
public
:
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
rtc
:
:
PacketSocketFactory
*
socket_factory
)
;
explicit
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
)
;
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
rtc
:
:
PacketSocketFactory
*
socket_factory
const
ServerAddresses
&
stun_servers
)
;
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
const
ServerAddresses
&
stun_servers
const
rtc
:
:
SocketAddress
&
relay_server_udp
const
rtc
:
:
SocketAddress
&
relay_server_tcp
const
rtc
:
:
SocketAddress
&
relay_server_ssl
)
;
virtual
~
BasicPortAllocator
(
)
;
void
SetIceServers
(
const
ServerAddresses
&
stun_servers
const
std
:
:
vector
<
RelayServerConfig
>
&
turn_servers
)
override
{
stun_servers_
=
stun_servers
;
turn_servers_
=
turn_servers
;
}
void
SetNetworkIgnoreMask
(
int
network_ignore_mask
)
override
{
network_ignore_mask_
=
network_ignore_mask
;
}
int
network_ignore_mask
(
)
const
{
return
network_ignore_mask_
;
}
rtc
:
:
NetworkManager
*
network_manager
(
)
{
return
network_manager_
;
}
rtc
:
:
PacketSocketFactory
*
socket_factory
(
)
{
return
socket_factory_
;
}
const
ServerAddresses
&
stun_servers
(
)
const
{
return
stun_servers_
;
}
const
std
:
:
vector
<
RelayServerConfig
>
&
turn_servers
(
)
const
{
return
turn_servers_
;
}
virtual
void
AddTurnServer
(
const
RelayServerConfig
&
turn_server
)
{
turn_servers_
.
push_back
(
turn_server
)
;
}
PortAllocatorSession
*
CreateSessionInternal
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
override
;
private
:
void
Construct
(
)
;
rtc
:
:
NetworkManager
*
network_manager_
;
rtc
:
:
PacketSocketFactory
*
socket_factory_
;
ServerAddresses
stun_servers_
;
std
:
:
vector
<
RelayServerConfig
>
turn_servers_
;
bool
allow_tcp_listen_
;
int
network_ignore_mask_
=
rtc
:
:
kDefaultNetworkIgnoreMask
;
}
;
struct
PortConfiguration
;
class
AllocationSequence
;
class
BasicPortAllocatorSession
:
public
PortAllocatorSession
public
rtc
:
:
MessageHandler
{
public
:
BasicPortAllocatorSession
(
BasicPortAllocator
*
allocator
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
;
~
BasicPortAllocatorSession
(
)
;
virtual
BasicPortAllocator
*
allocator
(
)
{
return
allocator_
;
}
rtc
:
:
Thread
*
network_thread
(
)
{
return
network_thread_
;
}
rtc
:
:
PacketSocketFactory
*
socket_factory
(
)
{
return
socket_factory_
;
}
void
StartGettingPorts
(
)
override
;
void
StopGettingPorts
(
)
override
;
void
ClearGettingPorts
(
)
override
;
bool
IsGettingPorts
(
)
override
{
return
running_
;
}
protected
:
virtual
void
GetPortConfigurations
(
)
;
virtual
void
ConfigReady
(
PortConfiguration
*
config
)
;
void
OnMessage
(
rtc
:
:
Message
*
message
)
override
;
private
:
class
PortData
{
public
:
PortData
(
)
:
port_
(
NULL
)
sequence_
(
NULL
)
state_
(
STATE_INIT
)
{
}
PortData
(
Port
*
port
AllocationSequence
*
seq
)
:
port_
(
port
)
sequence_
(
seq
)
state_
(
STATE_INIT
)
{
}
Port
*
port
(
)
{
return
port_
;
}
AllocationSequence
*
sequence
(
)
{
return
sequence_
;
}
bool
ready
(
)
const
{
return
state_
=
=
STATE_READY
;
}
bool
complete
(
)
const
{
return
(
(
state_
=
=
STATE_COMPLETE
)
|
|
(
state_
=
=
STATE_ERROR
)
)
;
}
void
set_ready
(
)
{
ASSERT
(
state_
=
=
STATE_INIT
)
;
state_
=
STATE_READY
;
}
void
set_complete
(
)
{
state_
=
STATE_COMPLETE
;
}
void
set_error
(
)
{
ASSERT
(
state_
=
=
STATE_INIT
|
|
state_
=
=
STATE_READY
)
;
state_
=
STATE_ERROR
;
}
private
:
enum
State
{
STATE_INIT
STATE_READY
STATE_COMPLETE
STATE_ERROR
}
;
Port
*
port_
;
AllocationSequence
*
sequence_
;
State
state_
;
}
;
void
OnConfigReady
(
PortConfiguration
*
config
)
;
void
OnConfigStop
(
)
;
void
AllocatePorts
(
)
;
void
OnAllocate
(
)
;
void
DoAllocate
(
)
;
void
OnNetworksChanged
(
)
;
void
OnAllocationSequenceObjectsCreated
(
)
;
void
DisableEquivalentPhases
(
rtc
:
:
Network
*
network
PortConfiguration
*
config
uint32_t
*
flags
)
;
void
AddAllocatedPort
(
Port
*
port
AllocationSequence
*
seq
bool
prepare_address
)
;
void
OnCandidateReady
(
Port
*
port
const
Candidate
&
c
)
;
void
OnPortComplete
(
Port
*
port
)
;
void
OnPortError
(
Port
*
port
)
;
void
OnProtocolEnabled
(
AllocationSequence
*
seq
ProtocolType
proto
)
;
void
OnPortDestroyed
(
PortInterface
*
port
)
;
void
OnShake
(
)
;
void
MaybeSignalCandidatesAllocationDone
(
)
;
void
OnPortAllocationComplete
(
AllocationSequence
*
seq
)
;
PortData
*
FindPort
(
Port
*
port
)
;
void
GetNetworks
(
std
:
:
vector
<
rtc
:
:
Network
*
>
*
networks
)
;
bool
CheckCandidateFilter
(
const
Candidate
&
c
)
;
BasicPortAllocator
*
allocator_
;
rtc
:
:
Thread
*
network_thread_
;
rtc
:
:
scoped_ptr
<
rtc
:
:
PacketSocketFactory
>
owned_socket_factory_
;
rtc
:
:
PacketSocketFactory
*
socket_factory_
;
bool
allocation_started_
;
bool
network_manager_started_
;
bool
running_
;
bool
allocation_sequences_created_
;
std
:
:
vector
<
PortConfiguration
*
>
configs_
;
std
:
:
vector
<
AllocationSequence
*
>
sequences_
;
std
:
:
vector
<
PortData
>
ports_
;
friend
class
AllocationSequence
;
}
;
struct
PortConfiguration
:
public
rtc
:
:
MessageData
{
rtc
:
:
SocketAddress
stun_address
;
ServerAddresses
stun_servers
;
std
:
:
string
username
;
std
:
:
string
password
;
typedef
std
:
:
vector
<
RelayServerConfig
>
RelayList
;
RelayList
relays
;
PortConfiguration
(
const
rtc
:
:
SocketAddress
&
stun_address
const
std
:
:
string
&
username
const
std
:
:
string
&
password
)
;
PortConfiguration
(
const
ServerAddresses
&
stun_servers
const
std
:
:
string
&
username
const
std
:
:
string
&
password
)
;
ServerAddresses
StunServers
(
)
;
void
AddRelay
(
const
RelayServerConfig
&
config
)
;
bool
SupportsProtocol
(
const
RelayServerConfig
&
relay
ProtocolType
type
)
const
;
bool
SupportsProtocol
(
RelayType
turn_type
ProtocolType
type
)
const
;
ServerAddresses
GetRelayServerAddresses
(
RelayType
turn_type
ProtocolType
type
)
const
;
}
;
class
UDPPort
;
class
TurnPort
;
class
AllocationSequence
:
public
rtc
:
:
MessageHandler
public
sigslot
:
:
has_slots
<
>
{
public
:
enum
State
{
kInit
kRunning
kStopped
kCompleted
}
;
AllocationSequence
(
BasicPortAllocatorSession
*
session
rtc
:
:
Network
*
network
PortConfiguration
*
config
uint32_t
flags
)
;
~
AllocationSequence
(
)
;
bool
Init
(
)
;
void
Clear
(
)
;
void
OnNetworkRemoved
(
)
;
State
state
(
)
const
{
return
state_
;
}
const
rtc
:
:
Network
*
network
(
)
const
{
return
network_
;
}
bool
network_removed
(
)
const
{
return
network_removed_
;
}
void
DisableEquivalentPhases
(
rtc
:
:
Network
*
network
PortConfiguration
*
config
uint32_t
*
flags
)
;
void
Start
(
)
;
void
Stop
(
)
;
void
OnMessage
(
rtc
:
:
Message
*
msg
)
;
void
EnableProtocol
(
ProtocolType
proto
)
;
bool
ProtocolEnabled
(
ProtocolType
proto
)
const
;
sigslot
:
:
signal1
<
AllocationSequence
*
>
SignalPortAllocationComplete
;
protected
:
void
CreateTurnPort
(
const
RelayServerConfig
&
config
)
;
private
:
typedef
std
:
:
vector
<
ProtocolType
>
ProtocolList
;
bool
IsFlagSet
(
uint32_t
flag
)
{
return
(
(
flags_
&
flag
)
!
=
0
)
;
}
void
CreateUDPPorts
(
)
;
void
CreateTCPPorts
(
)
;
void
CreateStunPorts
(
)
;
void
CreateRelayPorts
(
)
;
void
CreateGturnPort
(
const
RelayServerConfig
&
config
)
;
void
OnReadPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
char
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
remote_addr
const
rtc
:
:
PacketTime
&
packet_time
)
;
void
OnPortDestroyed
(
PortInterface
*
port
)
;
BasicPortAllocatorSession
*
session_
;
bool
network_removed_
=
false
;
rtc
:
:
Network
*
network_
;
rtc
:
:
IPAddress
ip_
;
PortConfiguration
*
config_
;
State
state_
;
uint32_t
flags_
;
ProtocolList
protocols_
;
rtc
:
:
scoped_ptr
<
rtc
:
:
AsyncPacketSocket
>
udp_socket_
;
UDPPort
*
udp_port_
;
std
:
:
vector
<
TurnPort
*
>
turn_ports_
;
int
phase_
;
}
;
}
#
endif
