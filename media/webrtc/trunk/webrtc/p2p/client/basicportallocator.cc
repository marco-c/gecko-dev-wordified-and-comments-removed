#
include
"
webrtc
/
p2p
/
client
/
basicportallocator
.
h
"
#
include
<
algorithm
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
api
/
umametrics
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
basicpacketsocketfactory
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
common
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
port
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
relayport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
stunport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
tcpport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
turnport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
udpport
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
helpers
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
using
rtc
:
:
CreateRandomId
;
namespace
{
enum
{
MSG_CONFIG_START
MSG_CONFIG_READY
MSG_ALLOCATE
MSG_ALLOCATION_PHASE
MSG_SEQUENCEOBJECTS_CREATED
MSG_CONFIG_STOP
}
;
const
int
PHASE_UDP
=
0
;
const
int
PHASE_RELAY
=
1
;
const
int
PHASE_TCP
=
2
;
const
int
PHASE_SSLTCP
=
3
;
const
int
kNumPhases
=
4
;
int
GetProtocolPriority
(
cricket
:
:
ProtocolType
protocol
)
{
switch
(
protocol
)
{
case
cricket
:
:
PROTO_UDP
:
return
2
;
case
cricket
:
:
PROTO_TCP
:
return
1
;
case
cricket
:
:
PROTO_SSLTCP
:
return
0
;
default
:
RTC_NOTREACHED
(
)
;
return
0
;
}
}
int
GetAddressFamilyPriority
(
int
ip_family
)
{
switch
(
ip_family
)
{
case
AF_INET6
:
return
2
;
case
AF_INET
:
return
1
;
default
:
RTC_NOTREACHED
(
)
;
return
0
;
}
}
int
ComparePort
(
const
cricket
:
:
Port
*
a
const
cricket
:
:
Port
*
b
)
{
int
a_protocol
=
GetProtocolPriority
(
a
-
>
GetProtocol
(
)
)
;
int
b_protocol
=
GetProtocolPriority
(
b
-
>
GetProtocol
(
)
)
;
int
cmp_protocol
=
a_protocol
-
b_protocol
;
if
(
cmp_protocol
!
=
0
)
{
return
cmp_protocol
;
}
int
a_family
=
GetAddressFamilyPriority
(
a
-
>
Network
(
)
-
>
GetBestIP
(
)
.
family
(
)
)
;
int
b_family
=
GetAddressFamilyPriority
(
b
-
>
Network
(
)
-
>
GetBestIP
(
)
.
family
(
)
)
;
return
a_family
-
b_family
;
}
}
namespace
cricket
{
const
uint32_t
DISABLE_ALL_PHASES
=
PORTALLOCATOR_DISABLE_UDP
|
PORTALLOCATOR_DISABLE_TCP
|
PORTALLOCATOR_DISABLE_STUN
|
PORTALLOCATOR_DISABLE_RELAY
;
BasicPortAllocator
:
:
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
rtc
:
:
PacketSocketFactory
*
socket_factory
)
:
network_manager_
(
network_manager
)
socket_factory_
(
socket_factory
)
{
RTC_DCHECK
(
network_manager_
!
=
nullptr
)
;
RTC_DCHECK
(
socket_factory_
!
=
nullptr
)
;
Construct
(
)
;
}
BasicPortAllocator
:
:
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
)
:
network_manager_
(
network_manager
)
socket_factory_
(
nullptr
)
{
RTC_DCHECK
(
network_manager_
!
=
nullptr
)
;
Construct
(
)
;
}
BasicPortAllocator
:
:
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
rtc
:
:
PacketSocketFactory
*
socket_factory
const
ServerAddresses
&
stun_servers
)
:
network_manager_
(
network_manager
)
socket_factory_
(
socket_factory
)
{
RTC_DCHECK
(
socket_factory_
!
=
NULL
)
;
SetConfiguration
(
stun_servers
std
:
:
vector
<
RelayServerConfig
>
(
)
0
false
)
;
Construct
(
)
;
}
BasicPortAllocator
:
:
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
const
ServerAddresses
&
stun_servers
const
rtc
:
:
SocketAddress
&
relay_address_udp
const
rtc
:
:
SocketAddress
&
relay_address_tcp
const
rtc
:
:
SocketAddress
&
relay_address_ssl
)
:
network_manager_
(
network_manager
)
socket_factory_
(
NULL
)
{
std
:
:
vector
<
RelayServerConfig
>
turn_servers
;
RelayServerConfig
config
(
RELAY_GTURN
)
;
if
(
!
relay_address_udp
.
IsNil
(
)
)
{
config
.
ports
.
push_back
(
ProtocolAddress
(
relay_address_udp
PROTO_UDP
)
)
;
}
if
(
!
relay_address_tcp
.
IsNil
(
)
)
{
config
.
ports
.
push_back
(
ProtocolAddress
(
relay_address_tcp
PROTO_TCP
)
)
;
}
if
(
!
relay_address_ssl
.
IsNil
(
)
)
{
config
.
ports
.
push_back
(
ProtocolAddress
(
relay_address_ssl
PROTO_SSLTCP
)
)
;
}
if
(
!
config
.
ports
.
empty
(
)
)
{
turn_servers
.
push_back
(
config
)
;
}
SetConfiguration
(
stun_servers
turn_servers
0
false
)
;
Construct
(
)
;
}
void
BasicPortAllocator
:
:
Construct
(
)
{
allow_tcp_listen_
=
true
;
}
void
BasicPortAllocator
:
:
OnIceRegathering
(
PortAllocatorSession
*
session
IceRegatheringReason
reason
)
{
if
(
!
metrics_observer
(
)
)
{
return
;
}
for
(
auto
&
allocator_session
:
pooled_sessions
(
)
)
{
if
(
allocator_session
.
get
(
)
=
=
session
)
{
return
;
}
}
metrics_observer
(
)
-
>
IncrementEnumCounter
(
webrtc
:
:
kEnumCounterIceRegathering
static_cast
<
int
>
(
reason
)
static_cast
<
int
>
(
IceRegatheringReason
:
:
MAX_VALUE
)
)
;
}
BasicPortAllocator
:
:
~
BasicPortAllocator
(
)
{
}
PortAllocatorSession
*
BasicPortAllocator
:
:
CreateSessionInternal
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
{
PortAllocatorSession
*
session
=
new
BasicPortAllocatorSession
(
this
content_name
component
ice_ufrag
ice_pwd
)
;
session
-
>
SignalIceRegathering
.
connect
(
this
&
BasicPortAllocator
:
:
OnIceRegathering
)
;
return
session
;
}
void
BasicPortAllocator
:
:
AddTurnServer
(
const
RelayServerConfig
&
turn_server
)
{
std
:
:
vector
<
RelayServerConfig
>
new_turn_servers
=
turn_servers
(
)
;
new_turn_servers
.
push_back
(
turn_server
)
;
SetConfiguration
(
stun_servers
(
)
new_turn_servers
candidate_pool_size
(
)
prune_turn_ports
(
)
)
;
}
BasicPortAllocatorSession
:
:
BasicPortAllocatorSession
(
BasicPortAllocator
*
allocator
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
:
PortAllocatorSession
(
content_name
component
ice_ufrag
ice_pwd
allocator
-
>
flags
(
)
)
allocator_
(
allocator
)
network_thread_
(
NULL
)
socket_factory_
(
allocator
-
>
socket_factory
(
)
)
allocation_started_
(
false
)
network_manager_started_
(
false
)
allocation_sequences_created_
(
false
)
prune_turn_ports_
(
allocator
-
>
prune_turn_ports
(
)
)
{
allocator_
-
>
network_manager
(
)
-
>
SignalNetworksChanged
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnNetworksChanged
)
;
allocator_
-
>
network_manager
(
)
-
>
StartUpdating
(
)
;
}
BasicPortAllocatorSession
:
:
~
BasicPortAllocatorSession
(
)
{
allocator_
-
>
network_manager
(
)
-
>
StopUpdating
(
)
;
if
(
network_thread_
!
=
NULL
)
network_thread_
-
>
Clear
(
this
)
;
for
(
uint32_t
i
=
0
;
i
<
sequences_
.
size
(
)
;
+
+
i
)
{
sequences_
[
i
]
-
>
Clear
(
)
;
}
std
:
:
vector
<
PortData
>
:
:
iterator
it
;
for
(
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
it
+
+
)
delete
it
-
>
port
(
)
;
for
(
uint32_t
i
=
0
;
i
<
configs_
.
size
(
)
;
+
+
i
)
delete
configs_
[
i
]
;
for
(
uint32_t
i
=
0
;
i
<
sequences_
.
size
(
)
;
+
+
i
)
delete
sequences_
[
i
]
;
}
void
BasicPortAllocatorSession
:
:
SetCandidateFilter
(
uint32_t
filter
)
{
if
(
filter
=
=
candidate_filter_
)
{
return
;
}
RTC_DCHECK
(
candidate_filter_
=
=
CF_ALL
)
;
candidate_filter_
=
filter
;
for
(
PortData
&
port
:
ports_
)
{
if
(
!
port
.
has_pairable_candidate
(
)
)
{
continue
;
}
const
auto
&
candidates
=
port
.
port
(
)
-
>
Candidates
(
)
;
if
(
!
std
:
:
any_of
(
candidates
.
begin
(
)
candidates
.
end
(
)
[
this
&
port
]
(
const
Candidate
&
candidate
)
{
return
CandidatePairable
(
candidate
port
.
port
(
)
)
;
}
)
)
{
port
.
set_has_pairable_candidate
(
false
)
;
}
}
}
void
BasicPortAllocatorSession
:
:
StartGettingPorts
(
)
{
network_thread_
=
rtc
:
:
Thread
:
:
Current
(
)
;
state_
=
SessionState
:
:
GATHERING
;
if
(
!
socket_factory_
)
{
owned_socket_factory_
.
reset
(
new
rtc
:
:
BasicPacketSocketFactory
(
network_thread_
)
)
;
socket_factory_
=
owned_socket_factory_
.
get
(
)
;
}
network_thread_
-
>
Post
(
RTC_FROM_HERE
this
MSG_CONFIG_START
)
;
LOG
(
LS_INFO
)
<
<
"
Start
getting
ports
with
prune_turn_ports
"
<
<
(
prune_turn_ports_
?
"
enabled
"
:
"
disabled
"
)
;
}
void
BasicPortAllocatorSession
:
:
StopGettingPorts
(
)
{
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
ClearGettingPorts
(
)
;
state_
=
SessionState
:
:
STOPPED
;
}
void
BasicPortAllocatorSession
:
:
ClearGettingPorts
(
)
{
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
network_thread_
-
>
Clear
(
this
MSG_ALLOCATE
)
;
for
(
uint32_t
i
=
0
;
i
<
sequences_
.
size
(
)
;
+
+
i
)
{
sequences_
[
i
]
-
>
Stop
(
)
;
}
network_thread_
-
>
Post
(
RTC_FROM_HERE
this
MSG_CONFIG_STOP
)
;
state_
=
SessionState
:
:
CLEARED
;
}
std
:
:
vector
<
rtc
:
:
Network
*
>
BasicPortAllocatorSession
:
:
GetFailedNetworks
(
)
{
std
:
:
vector
<
rtc
:
:
Network
*
>
networks
=
GetNetworks
(
)
;
std
:
:
set
<
std
:
:
string
>
networks_with_connection
;
for
(
const
PortData
&
data
:
ports_
)
{
Port
*
port
=
data
.
port
(
)
;
if
(
!
port
-
>
connections
(
)
.
empty
(
)
)
{
networks_with_connection
.
insert
(
port
-
>
Network
(
)
-
>
name
(
)
)
;
}
}
networks
.
erase
(
std
:
:
remove_if
(
networks
.
begin
(
)
networks
.
end
(
)
[
networks_with_connection
]
(
rtc
:
:
Network
*
network
)
{
return
networks_with_connection
.
find
(
network
-
>
name
(
)
)
!
=
networks_with_connection
.
end
(
)
;
}
)
networks
.
end
(
)
)
;
return
networks
;
}
void
BasicPortAllocatorSession
:
:
RegatherOnFailedNetworks
(
)
{
std
:
:
vector
<
rtc
:
:
Network
*
>
failed_networks
=
GetFailedNetworks
(
)
;
if
(
failed_networks
.
empty
(
)
)
{
return
;
}
LOG
(
LS_INFO
)
<
<
"
Regather
candidates
on
failed
networks
"
;
for
(
AllocationSequence
*
sequence
:
sequences_
)
{
if
(
!
sequence
-
>
network_failed
(
)
&
&
std
:
:
find
(
failed_networks
.
begin
(
)
failed_networks
.
end
(
)
sequence
-
>
network
(
)
)
!
=
failed_networks
.
end
(
)
)
{
sequence
-
>
set_network_failed
(
)
;
}
}
std
:
:
vector
<
PortData
*
>
ports_to_prune
=
GetUnprunedPorts
(
failed_networks
)
;
if
(
!
ports_to_prune
.
empty
(
)
)
{
LOG
(
LS_INFO
)
<
<
"
Prune
"
<
<
ports_to_prune
.
size
(
)
<
<
"
ports
because
their
networks
failed
"
;
PrunePortsAndRemoveCandidates
(
ports_to_prune
)
;
}
if
(
allocation_started_
&
&
network_manager_started_
&
&
!
IsStopped
(
)
)
{
SignalIceRegathering
(
this
IceRegatheringReason
:
:
NETWORK_FAILURE
)
;
DoAllocate
(
)
;
}
}
std
:
:
vector
<
PortInterface
*
>
BasicPortAllocatorSession
:
:
ReadyPorts
(
)
const
{
std
:
:
vector
<
PortInterface
*
>
ret
;
for
(
const
PortData
&
data
:
ports_
)
{
if
(
data
.
ready
(
)
)
{
ret
.
push_back
(
data
.
port
(
)
)
;
}
}
return
ret
;
}
std
:
:
vector
<
Candidate
>
BasicPortAllocatorSession
:
:
ReadyCandidates
(
)
const
{
std
:
:
vector
<
Candidate
>
candidates
;
for
(
const
PortData
&
data
:
ports_
)
{
if
(
!
data
.
ready
(
)
)
{
continue
;
}
GetCandidatesFromPort
(
data
&
candidates
)
;
}
return
candidates
;
}
void
BasicPortAllocatorSession
:
:
GetCandidatesFromPort
(
const
PortData
&
data
std
:
:
vector
<
Candidate
>
*
candidates
)
const
{
RTC_CHECK
(
candidates
!
=
nullptr
)
;
for
(
const
Candidate
&
candidate
:
data
.
port
(
)
-
>
Candidates
(
)
)
{
if
(
!
CheckCandidateFilter
(
candidate
)
)
{
continue
;
}
ProtocolType
pvalue
;
if
(
!
StringToProto
(
candidate
.
protocol
(
)
.
c_str
(
)
&
pvalue
)
|
|
!
data
.
sequence
(
)
-
>
ProtocolEnabled
(
pvalue
)
)
{
continue
;
}
candidates
-
>
push_back
(
SanitizeRelatedAddress
(
candidate
)
)
;
}
}
Candidate
BasicPortAllocatorSession
:
:
SanitizeRelatedAddress
(
const
Candidate
&
c
)
const
{
Candidate
copy
=
c
;
bool
filter_stun_related_address
=
(
(
flags
(
)
&
PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION
)
&
&
(
flags
(
)
&
PORTALLOCATOR_DISABLE_DEFAULT_LOCAL_CANDIDATE
)
)
|
|
!
(
candidate_filter_
&
CF_HOST
)
;
bool
filter_turn_related_address
=
!
(
candidate_filter_
&
CF_REFLEXIVE
)
;
if
(
(
c
.
type
(
)
=
=
STUN_PORT_TYPE
&
&
filter_stun_related_address
)
|
|
(
c
.
type
(
)
=
=
RELAY_PORT_TYPE
&
&
filter_turn_related_address
)
)
{
copy
.
set_related_address
(
rtc
:
:
EmptySocketAddressWithFamily
(
copy
.
address
(
)
.
family
(
)
)
)
;
}
return
copy
;
}
bool
BasicPortAllocatorSession
:
:
CandidatesAllocationDone
(
)
const
{
if
(
!
allocation_sequences_created_
)
{
return
false
;
}
if
(
std
:
:
any_of
(
sequences_
.
begin
(
)
sequences_
.
end
(
)
[
]
(
const
AllocationSequence
*
sequence
)
{
return
sequence
-
>
state
(
)
=
=
AllocationSequence
:
:
kRunning
;
}
)
)
{
return
false
;
}
return
std
:
:
none_of
(
ports_
.
begin
(
)
ports_
.
end
(
)
[
]
(
const
PortData
&
port
)
{
return
port
.
inprogress
(
)
;
}
)
;
}
void
BasicPortAllocatorSession
:
:
OnMessage
(
rtc
:
:
Message
*
message
)
{
switch
(
message
-
>
message_id
)
{
case
MSG_CONFIG_START
:
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
GetPortConfigurations
(
)
;
break
;
case
MSG_CONFIG_READY
:
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
OnConfigReady
(
static_cast
<
PortConfiguration
*
>
(
message
-
>
pdata
)
)
;
break
;
case
MSG_ALLOCATE
:
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
OnAllocate
(
)
;
break
;
case
MSG_SEQUENCEOBJECTS_CREATED
:
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
OnAllocationSequenceObjectsCreated
(
)
;
break
;
case
MSG_CONFIG_STOP
:
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
OnConfigStop
(
)
;
break
;
default
:
RTC_NOTREACHED
(
)
;
}
}
void
BasicPortAllocatorSession
:
:
UpdateIceParametersInternal
(
)
{
for
(
PortData
&
port
:
ports_
)
{
port
.
port
(
)
-
>
set_content_name
(
content_name
(
)
)
;
port
.
port
(
)
-
>
SetIceParameters
(
component
(
)
ice_ufrag
(
)
ice_pwd
(
)
)
;
}
}
void
BasicPortAllocatorSession
:
:
GetPortConfigurations
(
)
{
PortConfiguration
*
config
=
new
PortConfiguration
(
allocator_
-
>
stun_servers
(
)
username
(
)
password
(
)
)
;
for
(
const
RelayServerConfig
&
turn_server
:
allocator_
-
>
turn_servers
(
)
)
{
config
-
>
AddRelay
(
turn_server
)
;
}
ConfigReady
(
config
)
;
}
void
BasicPortAllocatorSession
:
:
ConfigReady
(
PortConfiguration
*
config
)
{
network_thread_
-
>
Post
(
RTC_FROM_HERE
this
MSG_CONFIG_READY
config
)
;
}
void
BasicPortAllocatorSession
:
:
OnConfigReady
(
PortConfiguration
*
config
)
{
if
(
config
)
{
configs_
.
push_back
(
config
)
;
}
AllocatePorts
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnConfigStop
(
)
{
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
bool
send_signal
=
false
;
for
(
std
:
:
vector
<
PortData
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
inprogress
(
)
)
{
it
-
>
set_error
(
)
;
send_signal
=
true
;
}
}
for
(
std
:
:
vector
<
AllocationSequence
*
>
:
:
iterator
it
=
sequences_
.
begin
(
)
;
it
!
=
sequences_
.
end
(
)
&
&
!
send_signal
;
+
+
it
)
{
if
(
(
*
it
)
-
>
state
(
)
=
=
AllocationSequence
:
:
kStopped
)
{
send_signal
=
true
;
}
}
if
(
send_signal
)
{
MaybeSignalCandidatesAllocationDone
(
)
;
}
}
void
BasicPortAllocatorSession
:
:
AllocatePorts
(
)
{
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
network_thread_
-
>
Post
(
RTC_FROM_HERE
this
MSG_ALLOCATE
)
;
}
void
BasicPortAllocatorSession
:
:
OnAllocate
(
)
{
if
(
network_manager_started_
&
&
!
IsStopped
(
)
)
DoAllocate
(
)
;
allocation_started_
=
true
;
}
std
:
:
vector
<
rtc
:
:
Network
*
>
BasicPortAllocatorSession
:
:
GetNetworks
(
)
{
std
:
:
vector
<
rtc
:
:
Network
*
>
networks
;
rtc
:
:
NetworkManager
*
network_manager
=
allocator_
-
>
network_manager
(
)
;
RTC_DCHECK
(
network_manager
!
=
nullptr
)
;
if
(
network_manager
-
>
enumeration_permission
(
)
=
=
rtc
:
:
NetworkManager
:
:
ENUMERATION_BLOCKED
)
{
set_flags
(
flags
(
)
|
PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION
)
;
}
if
(
flags
(
)
&
PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION
)
{
network_manager
-
>
GetAnyAddressNetworks
(
&
networks
)
;
}
else
{
network_manager
-
>
GetNetworks
(
&
networks
)
;
if
(
networks
.
empty
(
)
)
{
network_manager
-
>
GetAnyAddressNetworks
(
&
networks
)
;
}
}
networks
.
erase
(
std
:
:
remove_if
(
networks
.
begin
(
)
networks
.
end
(
)
[
this
]
(
rtc
:
:
Network
*
network
)
{
return
allocator_
-
>
network_ignore_mask
(
)
&
network
-
>
type
(
)
;
}
)
networks
.
end
(
)
)
;
if
(
flags
(
)
&
PORTALLOCATOR_DISABLE_COSTLY_NETWORKS
)
{
uint16_t
lowest_cost
=
rtc
:
:
kNetworkCostMax
;
for
(
rtc
:
:
Network
*
network
:
networks
)
{
lowest_cost
=
std
:
:
min
<
uint16_t
>
(
lowest_cost
network
-
>
GetCost
(
)
)
;
}
networks
.
erase
(
std
:
:
remove_if
(
networks
.
begin
(
)
networks
.
end
(
)
[
lowest_cost
]
(
rtc
:
:
Network
*
network
)
{
return
network
-
>
GetCost
(
)
>
lowest_cost
+
rtc
:
:
kNetworkCostLow
;
}
)
networks
.
end
(
)
)
;
}
return
networks
;
}
void
BasicPortAllocatorSession
:
:
DoAllocate
(
)
{
bool
done_signal_needed
=
false
;
std
:
:
vector
<
rtc
:
:
Network
*
>
networks
=
GetNetworks
(
)
;
if
(
networks
.
empty
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Machine
has
no
networks
;
no
ports
will
be
allocated
"
;
done_signal_needed
=
true
;
}
else
{
LOG
(
LS_INFO
)
<
<
"
Allocate
ports
on
"
<
<
networks
.
size
(
)
<
<
"
networks
"
;
PortConfiguration
*
config
=
configs_
.
empty
(
)
?
nullptr
:
configs_
.
back
(
)
;
for
(
uint32_t
i
=
0
;
i
<
networks
.
size
(
)
;
+
+
i
)
{
uint32_t
sequence_flags
=
flags
(
)
;
if
(
(
sequence_flags
&
DISABLE_ALL_PHASES
)
=
=
DISABLE_ALL_PHASES
)
{
done_signal_needed
=
true
;
break
;
}
if
(
!
config
|
|
config
-
>
relays
.
empty
(
)
)
{
sequence_flags
|
=
PORTALLOCATOR_DISABLE_RELAY
;
}
if
(
!
(
sequence_flags
&
PORTALLOCATOR_ENABLE_IPV6
)
&
&
networks
[
i
]
-
>
GetBestIP
(
)
.
family
(
)
=
=
AF_INET6
)
{
continue
;
}
DisableEquivalentPhases
(
networks
[
i
]
config
&
sequence_flags
)
;
if
(
(
sequence_flags
&
DISABLE_ALL_PHASES
)
=
=
DISABLE_ALL_PHASES
)
{
continue
;
}
AllocationSequence
*
sequence
=
new
AllocationSequence
(
this
networks
[
i
]
config
sequence_flags
)
;
sequence
-
>
SignalPortAllocationComplete
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnPortAllocationComplete
)
;
sequence
-
>
Init
(
)
;
sequence
-
>
Start
(
)
;
sequences_
.
push_back
(
sequence
)
;
done_signal_needed
=
true
;
}
}
if
(
done_signal_needed
)
{
network_thread_
-
>
Post
(
RTC_FROM_HERE
this
MSG_SEQUENCEOBJECTS_CREATED
)
;
}
}
void
BasicPortAllocatorSession
:
:
OnNetworksChanged
(
)
{
std
:
:
vector
<
rtc
:
:
Network
*
>
networks
=
GetNetworks
(
)
;
std
:
:
vector
<
rtc
:
:
Network
*
>
failed_networks
;
for
(
AllocationSequence
*
sequence
:
sequences_
)
{
if
(
!
sequence
-
>
network_failed
(
)
&
&
std
:
:
find
(
networks
.
begin
(
)
networks
.
end
(
)
sequence
-
>
network
(
)
)
=
=
networks
.
end
(
)
)
{
sequence
-
>
OnNetworkFailed
(
)
;
failed_networks
.
push_back
(
sequence
-
>
network
(
)
)
;
}
}
std
:
:
vector
<
PortData
*
>
ports_to_prune
=
GetUnprunedPorts
(
failed_networks
)
;
if
(
!
ports_to_prune
.
empty
(
)
)
{
LOG
(
LS_INFO
)
<
<
"
Prune
"
<
<
ports_to_prune
.
size
(
)
<
<
"
ports
because
their
networks
were
gone
"
;
PrunePortsAndRemoveCandidates
(
ports_to_prune
)
;
}
if
(
allocation_started_
&
&
!
IsStopped
(
)
)
{
if
(
network_manager_started_
)
{
SignalIceRegathering
(
this
IceRegatheringReason
:
:
NETWORK_CHANGE
)
;
}
DoAllocate
(
)
;
}
if
(
!
network_manager_started_
)
{
LOG
(
LS_INFO
)
<
<
"
Network
manager
has
started
"
;
network_manager_started_
=
true
;
}
}
void
BasicPortAllocatorSession
:
:
DisableEquivalentPhases
(
rtc
:
:
Network
*
network
PortConfiguration
*
config
uint32_t
*
flags
)
{
for
(
uint32_t
i
=
0
;
i
<
sequences_
.
size
(
)
&
&
(
*
flags
&
DISABLE_ALL_PHASES
)
!
=
DISABLE_ALL_PHASES
;
+
+
i
)
{
sequences_
[
i
]
-
>
DisableEquivalentPhases
(
network
config
flags
)
;
}
}
void
BasicPortAllocatorSession
:
:
AddAllocatedPort
(
Port
*
port
AllocationSequence
*
seq
bool
prepare_address
)
{
if
(
!
port
)
return
;
LOG
(
LS_INFO
)
<
<
"
Adding
allocated
port
for
"
<
<
content_name
(
)
;
port
-
>
set_content_name
(
content_name
(
)
)
;
port
-
>
set_component
(
component
(
)
)
;
port
-
>
set_generation
(
generation
(
)
)
;
if
(
allocator_
-
>
proxy
(
)
.
type
!
=
rtc
:
:
PROXY_NONE
)
port
-
>
set_proxy
(
allocator_
-
>
user_agent
(
)
allocator_
-
>
proxy
(
)
)
;
port
-
>
set_send_retransmit_count_attribute
(
(
flags
(
)
&
PORTALLOCATOR_ENABLE_STUN_RETRANSMIT_ATTRIBUTE
)
!
=
0
)
;
PortData
data
(
port
seq
)
;
ports_
.
push_back
(
data
)
;
port
-
>
SignalCandidateReady
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnCandidateReady
)
;
port
-
>
SignalPortComplete
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnPortComplete
)
;
port
-
>
SignalDestroyed
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnPortDestroyed
)
;
port
-
>
SignalPortError
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnPortError
)
;
LOG_J
(
LS_INFO
port
)
<
<
"
Added
port
to
allocator
"
;
if
(
prepare_address
)
port
-
>
PrepareAddress
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnAllocationSequenceObjectsCreated
(
)
{
allocation_sequences_created_
=
true
;
MaybeSignalCandidatesAllocationDone
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnCandidateReady
(
Port
*
port
const
Candidate
&
c
)
{
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
PortData
*
data
=
FindPort
(
port
)
;
RTC_DCHECK
(
data
!
=
NULL
)
;
LOG_J
(
LS_INFO
port
)
<
<
"
Gathered
candidate
:
"
<
<
c
.
ToSensitiveString
(
)
;
if
(
!
data
-
>
inprogress
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Discarding
candidate
because
port
is
already
done
gathering
.
"
;
return
;
}
bool
pruned
=
false
;
if
(
CandidatePairable
(
c
port
)
&
&
!
data
-
>
has_pairable_candidate
(
)
)
{
data
-
>
set_has_pairable_candidate
(
true
)
;
if
(
prune_turn_ports_
&
&
port
-
>
Type
(
)
=
=
RELAY_PORT_TYPE
)
{
pruned
=
PruneTurnPorts
(
port
)
;
}
if
(
!
data
-
>
pruned
(
)
)
{
LOG_J
(
LS_INFO
port
)
<
<
"
Port
ready
.
"
;
SignalPortReady
(
this
port
)
;
port
-
>
KeepAliveUntilPruned
(
)
;
}
}
ProtocolType
pvalue
;
bool
candidate_protocol_enabled
=
StringToProto
(
c
.
protocol
(
)
.
c_str
(
)
&
pvalue
)
&
&
data
-
>
sequence
(
)
-
>
ProtocolEnabled
(
pvalue
)
;
if
(
data
-
>
ready
(
)
&
&
CheckCandidateFilter
(
c
)
&
&
candidate_protocol_enabled
)
{
std
:
:
vector
<
Candidate
>
candidates
;
candidates
.
push_back
(
SanitizeRelatedAddress
(
c
)
)
;
SignalCandidatesReady
(
this
candidates
)
;
}
else
if
(
!
candidate_protocol_enabled
)
{
LOG
(
LS_INFO
)
<
<
"
Not
yet
signaling
candidate
because
protocol
is
not
yet
enabled
.
"
;
}
else
{
LOG
(
LS_INFO
)
<
<
"
Discarding
candidate
because
it
doesn
'
t
match
filter
.
"
;
}
if
(
pruned
)
{
MaybeSignalCandidatesAllocationDone
(
)
;
}
}
Port
*
BasicPortAllocatorSession
:
:
GetBestTurnPortForNetwork
(
const
std
:
:
string
&
network_name
)
const
{
Port
*
best_turn_port
=
nullptr
;
for
(
const
PortData
&
data
:
ports_
)
{
if
(
data
.
port
(
)
-
>
Network
(
)
-
>
name
(
)
=
=
network_name
&
&
data
.
port
(
)
-
>
Type
(
)
=
=
RELAY_PORT_TYPE
&
&
data
.
ready
(
)
&
&
(
!
best_turn_port
|
|
ComparePort
(
data
.
port
(
)
best_turn_port
)
>
0
)
)
{
best_turn_port
=
data
.
port
(
)
;
}
}
return
best_turn_port
;
}
bool
BasicPortAllocatorSession
:
:
PruneTurnPorts
(
Port
*
newly_pairable_turn_port
)
{
const
std
:
:
string
&
network_name
=
newly_pairable_turn_port
-
>
Network
(
)
-
>
name
(
)
;
Port
*
best_turn_port
=
GetBestTurnPortForNetwork
(
network_name
)
;
RTC_CHECK
(
best_turn_port
!
=
nullptr
)
;
bool
pruned
=
false
;
std
:
:
vector
<
PortData
*
>
ports_to_prune
;
for
(
PortData
&
data
:
ports_
)
{
if
(
data
.
port
(
)
-
>
Network
(
)
-
>
name
(
)
=
=
network_name
&
&
data
.
port
(
)
-
>
Type
(
)
=
=
RELAY_PORT_TYPE
&
&
!
data
.
pruned
(
)
&
&
ComparePort
(
data
.
port
(
)
best_turn_port
)
<
0
)
{
pruned
=
true
;
if
(
data
.
port
(
)
!
=
newly_pairable_turn_port
)
{
ports_to_prune
.
push_back
(
&
data
)
;
}
else
{
data
.
Prune
(
)
;
}
}
}
if
(
!
ports_to_prune
.
empty
(
)
)
{
LOG
(
LS_INFO
)
<
<
"
Prune
"
<
<
ports_to_prune
.
size
(
)
<
<
"
low
-
priority
TURN
ports
"
;
PrunePortsAndRemoveCandidates
(
ports_to_prune
)
;
}
return
pruned
;
}
void
BasicPortAllocatorSession
:
:
PruneAllPorts
(
)
{
for
(
PortData
&
data
:
ports_
)
{
data
.
Prune
(
)
;
}
}
void
BasicPortAllocatorSession
:
:
OnPortComplete
(
Port
*
port
)
{
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
LOG_J
(
LS_INFO
port
)
<
<
"
Port
completed
gathering
candidates
.
"
;
PortData
*
data
=
FindPort
(
port
)
;
RTC_DCHECK
(
data
!
=
NULL
)
;
if
(
!
data
-
>
inprogress
(
)
)
{
return
;
}
data
-
>
set_complete
(
)
;
MaybeSignalCandidatesAllocationDone
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnPortError
(
Port
*
port
)
{
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
LOG_J
(
LS_INFO
port
)
<
<
"
Port
encountered
error
while
gathering
candidates
.
"
;
PortData
*
data
=
FindPort
(
port
)
;
RTC_DCHECK
(
data
!
=
NULL
)
;
if
(
!
data
-
>
inprogress
(
)
)
{
return
;
}
data
-
>
set_error
(
)
;
MaybeSignalCandidatesAllocationDone
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnProtocolEnabled
(
AllocationSequence
*
seq
ProtocolType
proto
)
{
std
:
:
vector
<
Candidate
>
candidates
;
for
(
std
:
:
vector
<
PortData
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
sequence
(
)
!
=
seq
)
continue
;
const
std
:
:
vector
<
Candidate
>
&
potentials
=
it
-
>
port
(
)
-
>
Candidates
(
)
;
for
(
size_t
i
=
0
;
i
<
potentials
.
size
(
)
;
+
+
i
)
{
if
(
!
CheckCandidateFilter
(
potentials
[
i
]
)
)
{
continue
;
}
ProtocolType
pvalue
;
bool
candidate_protocol_enabled
=
StringToProto
(
potentials
[
i
]
.
protocol
(
)
.
c_str
(
)
&
pvalue
)
&
&
pvalue
=
=
proto
;
if
(
candidate_protocol_enabled
)
{
LOG
(
LS_INFO
)
<
<
"
Signaling
candidate
because
protocol
was
enabled
:
"
<
<
potentials
[
i
]
.
ToSensitiveString
(
)
;
candidates
.
push_back
(
potentials
[
i
]
)
;
}
}
}
if
(
!
candidates
.
empty
(
)
)
{
SignalCandidatesReady
(
this
candidates
)
;
}
}
bool
BasicPortAllocatorSession
:
:
CheckCandidateFilter
(
const
Candidate
&
c
)
const
{
uint32_t
filter
=
candidate_filter_
;
if
(
c
.
address
(
)
.
IsAnyIP
(
)
)
{
return
false
;
}
if
(
c
.
type
(
)
=
=
RELAY_PORT_TYPE
)
{
return
(
(
filter
&
CF_RELAY
)
!
=
0
)
;
}
else
if
(
c
.
type
(
)
=
=
STUN_PORT_TYPE
)
{
return
(
(
filter
&
CF_REFLEXIVE
)
!
=
0
)
;
}
else
if
(
c
.
type
(
)
=
=
LOCAL_PORT_TYPE
)
{
if
(
(
filter
&
CF_REFLEXIVE
)
&
&
!
c
.
address
(
)
.
IsPrivateIP
(
)
)
{
return
true
;
}
return
(
(
filter
&
CF_HOST
)
!
=
0
)
;
}
return
false
;
}
bool
BasicPortAllocatorSession
:
:
CandidatePairable
(
const
Candidate
&
c
const
Port
*
port
)
const
{
bool
candidate_signalable
=
CheckCandidateFilter
(
c
)
;
bool
network_enumeration_disabled
=
c
.
address
(
)
.
IsAnyIP
(
)
;
bool
can_ping_from_candidate
=
(
port
-
>
SharedSocket
(
)
|
|
c
.
protocol
(
)
=
=
TCP_PROTOCOL_NAME
)
;
bool
host_candidates_disabled
=
!
(
candidate_filter_
&
CF_HOST
)
;
return
candidate_signalable
|
|
(
network_enumeration_disabled
&
&
can_ping_from_candidate
&
&
!
host_candidates_disabled
)
;
}
void
BasicPortAllocatorSession
:
:
OnPortAllocationComplete
(
AllocationSequence
*
seq
)
{
MaybeSignalCandidatesAllocationDone
(
)
;
}
void
BasicPortAllocatorSession
:
:
MaybeSignalCandidatesAllocationDone
(
)
{
if
(
CandidatesAllocationDone
(
)
)
{
if
(
pooled
(
)
)
{
LOG
(
LS_INFO
)
<
<
"
All
candidates
gathered
for
pooled
session
.
"
;
}
else
{
LOG
(
LS_INFO
)
<
<
"
All
candidates
gathered
for
"
<
<
content_name
(
)
<
<
"
:
"
<
<
component
(
)
<
<
"
:
"
<
<
generation
(
)
;
}
SignalCandidatesAllocationDone
(
this
)
;
}
}
void
BasicPortAllocatorSession
:
:
OnPortDestroyed
(
PortInterface
*
port
)
{
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
for
(
std
:
:
vector
<
PortData
>
:
:
iterator
iter
=
ports_
.
begin
(
)
;
iter
!
=
ports_
.
end
(
)
;
+
+
iter
)
{
if
(
port
=
=
iter
-
>
port
(
)
)
{
ports_
.
erase
(
iter
)
;
LOG_J
(
LS_INFO
port
)
<
<
"
Removed
port
from
allocator
(
"
<
<
static_cast
<
int
>
(
ports_
.
size
(
)
)
<
<
"
remaining
)
"
;
return
;
}
}
RTC_NOTREACHED
(
)
;
}
BasicPortAllocatorSession
:
:
PortData
*
BasicPortAllocatorSession
:
:
FindPort
(
Port
*
port
)
{
for
(
std
:
:
vector
<
PortData
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
port
(
)
=
=
port
)
{
return
&
*
it
;
}
}
return
NULL
;
}
std
:
:
vector
<
BasicPortAllocatorSession
:
:
PortData
*
>
BasicPortAllocatorSession
:
:
GetUnprunedPorts
(
const
std
:
:
vector
<
rtc
:
:
Network
*
>
&
networks
)
{
std
:
:
vector
<
PortData
*
>
unpruned_ports
;
for
(
PortData
&
port
:
ports_
)
{
if
(
!
port
.
pruned
(
)
&
&
std
:
:
find
(
networks
.
begin
(
)
networks
.
end
(
)
port
.
sequence
(
)
-
>
network
(
)
)
!
=
networks
.
end
(
)
)
{
unpruned_ports
.
push_back
(
&
port
)
;
}
}
return
unpruned_ports
;
}
void
BasicPortAllocatorSession
:
:
PrunePortsAndRemoveCandidates
(
const
std
:
:
vector
<
PortData
*
>
&
port_data_list
)
{
std
:
:
vector
<
PortInterface
*
>
pruned_ports
;
std
:
:
vector
<
Candidate
>
removed_candidates
;
for
(
PortData
*
data
:
port_data_list
)
{
data
-
>
Prune
(
)
;
pruned_ports
.
push_back
(
data
-
>
port
(
)
)
;
if
(
data
-
>
has_pairable_candidate
(
)
)
{
GetCandidatesFromPort
(
*
data
&
removed_candidates
)
;
data
-
>
set_has_pairable_candidate
(
false
)
;
}
}
if
(
!
pruned_ports
.
empty
(
)
)
{
SignalPortsPruned
(
this
pruned_ports
)
;
}
if
(
!
removed_candidates
.
empty
(
)
)
{
LOG
(
LS_INFO
)
<
<
"
Removed
"
<
<
removed_candidates
.
size
(
)
<
<
"
candidates
"
;
SignalCandidatesRemoved
(
this
removed_candidates
)
;
}
}
AllocationSequence
:
:
AllocationSequence
(
BasicPortAllocatorSession
*
session
rtc
:
:
Network
*
network
PortConfiguration
*
config
uint32_t
flags
)
:
session_
(
session
)
network_
(
network
)
ip_
(
network
-
>
GetBestIP
(
)
)
config_
(
config
)
state_
(
kInit
)
flags_
(
flags
)
udp_socket_
(
)
udp_port_
(
NULL
)
phase_
(
0
)
{
}
void
AllocationSequence
:
:
Init
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
)
{
udp_socket_
.
reset
(
session_
-
>
socket_factory
(
)
-
>
CreateUdpSocket
(
rtc
:
:
SocketAddress
(
ip_
0
)
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
)
)
;
if
(
udp_socket_
)
{
udp_socket_
-
>
SignalReadPacket
.
connect
(
this
&
AllocationSequence
:
:
OnReadPacket
)
;
}
}
}
void
AllocationSequence
:
:
Clear
(
)
{
udp_port_
=
NULL
;
turn_ports_
.
clear
(
)
;
}
void
AllocationSequence
:
:
OnNetworkFailed
(
)
{
RTC_DCHECK
(
!
network_failed_
)
;
network_failed_
=
true
;
Stop
(
)
;
}
AllocationSequence
:
:
~
AllocationSequence
(
)
{
session_
-
>
network_thread
(
)
-
>
Clear
(
this
)
;
}
void
AllocationSequence
:
:
DisableEquivalentPhases
(
rtc
:
:
Network
*
network
PortConfiguration
*
config
uint32_t
*
flags
)
{
if
(
network_failed_
)
{
return
;
}
if
(
!
(
(
network
=
=
network_
)
&
&
(
ip_
=
=
network
-
>
GetBestIP
(
)
)
)
)
{
return
;
}
*
flags
|
=
PORTALLOCATOR_DISABLE_UDP
;
*
flags
|
=
PORTALLOCATOR_DISABLE_TCP
;
if
(
config_
&
&
config
)
{
if
(
config_
-
>
StunServers
(
)
=
=
config
-
>
StunServers
(
)
)
{
*
flags
|
=
PORTALLOCATOR_DISABLE_STUN
;
}
if
(
!
config_
-
>
relays
.
empty
(
)
)
{
*
flags
|
=
PORTALLOCATOR_DISABLE_RELAY
;
}
}
}
void
AllocationSequence
:
:
Start
(
)
{
state_
=
kRunning
;
session_
-
>
network_thread
(
)
-
>
Post
(
RTC_FROM_HERE
this
MSG_ALLOCATION_PHASE
)
;
}
void
AllocationSequence
:
:
Stop
(
)
{
if
(
state_
=
=
kRunning
)
{
state_
=
kStopped
;
session_
-
>
network_thread
(
)
-
>
Clear
(
this
MSG_ALLOCATION_PHASE
)
;
}
}
void
AllocationSequence
:
:
OnMessage
(
rtc
:
:
Message
*
msg
)
{
RTC_DCHECK
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
session_
-
>
network_thread
(
)
)
;
RTC_DCHECK
(
msg
-
>
message_id
=
=
MSG_ALLOCATION_PHASE
)
;
const
char
*
const
PHASE_NAMES
[
kNumPhases
]
=
{
"
Udp
"
"
Relay
"
"
Tcp
"
"
SslTcp
"
}
;
LOG_J
(
LS_INFO
network_
)
<
<
"
Allocation
Phase
=
"
<
<
PHASE_NAMES
[
phase_
]
;
switch
(
phase_
)
{
case
PHASE_UDP
:
CreateUDPPorts
(
)
;
CreateStunPorts
(
)
;
EnableProtocol
(
PROTO_UDP
)
;
break
;
case
PHASE_RELAY
:
CreateRelayPorts
(
)
;
break
;
case
PHASE_TCP
:
CreateTCPPorts
(
)
;
EnableProtocol
(
PROTO_TCP
)
;
break
;
case
PHASE_SSLTCP
:
state_
=
kCompleted
;
EnableProtocol
(
PROTO_SSLTCP
)
;
break
;
default
:
RTC_NOTREACHED
(
)
;
}
if
(
state
(
)
=
=
kRunning
)
{
+
+
phase_
;
session_
-
>
network_thread
(
)
-
>
PostDelayed
(
RTC_FROM_HERE
session_
-
>
allocator
(
)
-
>
step_delay
(
)
this
MSG_ALLOCATION_PHASE
)
;
}
else
{
session_
-
>
network_thread
(
)
-
>
Clear
(
this
MSG_ALLOCATION_PHASE
)
;
SignalPortAllocationComplete
(
this
)
;
}
}
void
AllocationSequence
:
:
EnableProtocol
(
ProtocolType
proto
)
{
if
(
!
ProtocolEnabled
(
proto
)
)
{
protocols_
.
push_back
(
proto
)
;
session_
-
>
OnProtocolEnabled
(
this
proto
)
;
}
}
bool
AllocationSequence
:
:
ProtocolEnabled
(
ProtocolType
proto
)
const
{
for
(
ProtocolList
:
:
const_iterator
it
=
protocols_
.
begin
(
)
;
it
!
=
protocols_
.
end
(
)
;
+
+
it
)
{
if
(
*
it
=
=
proto
)
return
true
;
}
return
false
;
}
void
AllocationSequence
:
:
CreateUDPPorts
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_UDP
)
)
{
LOG
(
LS_VERBOSE
)
<
<
"
AllocationSequence
:
UDP
ports
disabled
skipping
.
"
;
return
;
}
UDPPort
*
port
=
NULL
;
bool
emit_local_candidate_for_anyaddress
=
!
IsFlagSet
(
PORTALLOCATOR_DISABLE_DEFAULT_LOCAL_CANDIDATE
)
;
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
&
&
udp_socket_
)
{
port
=
UDPPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
udp_socket_
.
get
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
session_
-
>
allocator
(
)
-
>
origin
(
)
emit_local_candidate_for_anyaddress
)
;
}
else
{
port
=
UDPPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
session_
-
>
allocator
(
)
-
>
origin
(
)
emit_local_candidate_for_anyaddress
)
;
}
if
(
port
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
)
{
udp_port_
=
port
;
port
-
>
SignalDestroyed
.
connect
(
this
&
AllocationSequence
:
:
OnPortDestroyed
)
;
if
(
!
IsFlagSet
(
PORTALLOCATOR_DISABLE_STUN
)
)
{
if
(
config_
&
&
!
config_
-
>
StunServers
(
)
.
empty
(
)
)
{
LOG
(
LS_INFO
)
<
<
"
AllocationSequence
:
UDPPort
will
be
handling
the
"
<
<
"
STUN
candidate
generation
.
"
;
port
-
>
set_server_addresses
(
config_
-
>
StunServers
(
)
)
;
}
}
}
session_
-
>
AddAllocatedPort
(
port
this
true
)
;
}
}
void
AllocationSequence
:
:
CreateTCPPorts
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_TCP
)
)
{
LOG
(
LS_VERBOSE
)
<
<
"
AllocationSequence
:
TCP
ports
disabled
skipping
.
"
;
return
;
}
Port
*
port
=
TCPPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
session_
-
>
allocator
(
)
-
>
allow_tcp_listen
(
)
)
;
if
(
port
)
{
session_
-
>
AddAllocatedPort
(
port
this
true
)
;
}
}
void
AllocationSequence
:
:
CreateStunPorts
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_STUN
)
)
{
LOG
(
LS_VERBOSE
)
<
<
"
AllocationSequence
:
STUN
ports
disabled
skipping
.
"
;
return
;
}
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
)
{
return
;
}
if
(
!
(
config_
&
&
!
config_
-
>
StunServers
(
)
.
empty
(
)
)
)
{
LOG
(
LS_WARNING
)
<
<
"
AllocationSequence
:
No
STUN
server
configured
skipping
.
"
;
return
;
}
StunPort
*
port
=
StunPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
config_
-
>
StunServers
(
)
session_
-
>
allocator
(
)
-
>
origin
(
)
)
;
if
(
port
)
{
session_
-
>
AddAllocatedPort
(
port
this
true
)
;
}
}
void
AllocationSequence
:
:
CreateRelayPorts
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_RELAY
)
)
{
LOG
(
LS_VERBOSE
)
<
<
"
AllocationSequence
:
Relay
ports
disabled
skipping
.
"
;
return
;
}
RTC_DCHECK
(
config_
&
&
!
config_
-
>
relays
.
empty
(
)
)
;
if
(
!
(
config_
&
&
!
config_
-
>
relays
.
empty
(
)
)
)
{
LOG
(
LS_WARNING
)
<
<
"
AllocationSequence
:
No
relay
server
configured
skipping
.
"
;
return
;
}
for
(
RelayServerConfig
&
relay
:
config_
-
>
relays
)
{
if
(
relay
.
type
=
=
RELAY_GTURN
)
{
CreateGturnPort
(
relay
)
;
}
else
if
(
relay
.
type
=
=
RELAY_TURN
)
{
CreateTurnPort
(
relay
)
;
}
else
{
RTC_NOTREACHED
(
)
;
}
}
}
void
AllocationSequence
:
:
CreateGturnPort
(
const
RelayServerConfig
&
config
)
{
RelayPort
*
port
=
RelayPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
config_
-
>
username
config_
-
>
password
)
;
if
(
port
)
{
session_
-
>
AddAllocatedPort
(
port
this
false
)
;
PortList
:
:
const_iterator
relay_port
;
for
(
relay_port
=
config
.
ports
.
begin
(
)
;
relay_port
!
=
config
.
ports
.
end
(
)
;
+
+
relay_port
)
{
port
-
>
AddServerAddress
(
*
relay_port
)
;
port
-
>
AddExternalAddress
(
*
relay_port
)
;
}
port
-
>
PrepareAddress
(
)
;
}
}
void
AllocationSequence
:
:
CreateTurnPort
(
const
RelayServerConfig
&
config
)
{
PortList
:
:
const_iterator
relay_port
;
for
(
relay_port
=
config
.
ports
.
begin
(
)
;
relay_port
!
=
config
.
ports
.
end
(
)
;
+
+
relay_port
)
{
TurnPort
*
port
=
NULL
;
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_UDP_RELAY
)
&
&
relay_port
-
>
proto
=
=
PROTO_UDP
)
{
continue
;
}
int
server_ip_family
=
relay_port
-
>
address
.
ipaddr
(
)
.
family
(
)
;
int
local_ip_family
=
ip_
.
family
(
)
;
if
(
server_ip_family
!
=
AF_UNSPEC
&
&
server_ip_family
!
=
local_ip_family
)
{
LOG
(
LS_INFO
)
<
<
"
Server
and
local
address
families
are
not
compatible
.
"
<
<
"
Server
address
:
"
<
<
relay_port
-
>
address
.
ipaddr
(
)
.
ToString
(
)
<
<
"
Local
address
:
"
<
<
ip_
.
ToString
(
)
;
continue
;
}
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
&
&
relay_port
-
>
proto
=
=
PROTO_UDP
&
&
udp_socket_
)
{
port
=
TurnPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
udp_socket_
.
get
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
*
relay_port
config
.
credentials
config
.
priority
session_
-
>
allocator
(
)
-
>
origin
(
)
)
;
turn_ports_
.
push_back
(
port
)
;
port
-
>
SignalDestroyed
.
connect
(
this
&
AllocationSequence
:
:
OnPortDestroyed
)
;
}
else
{
port
=
TurnPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
*
relay_port
config
.
credentials
config
.
priority
session_
-
>
allocator
(
)
-
>
origin
(
)
)
;
}
RTC_DCHECK
(
port
!
=
NULL
)
;
port
-
>
SetTlsCertPolicy
(
config
.
tls_cert_policy
)
;
session_
-
>
AddAllocatedPort
(
port
this
true
)
;
}
}
void
AllocationSequence
:
:
OnReadPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
char
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
remote_addr
const
rtc
:
:
PacketTime
&
packet_time
)
{
RTC_DCHECK
(
socket
=
=
udp_socket_
.
get
(
)
)
;
bool
turn_port_found
=
false
;
for
(
TurnPort
*
port
:
turn_ports_
)
{
if
(
port
-
>
server_address
(
)
.
address
=
=
remote_addr
)
{
if
(
port
-
>
HandleIncomingPacket
(
socket
data
size
remote_addr
packet_time
)
)
{
return
;
}
turn_port_found
=
true
;
}
}
if
(
udp_port_
)
{
const
ServerAddresses
&
stun_servers
=
udp_port_
-
>
server_addresses
(
)
;
if
(
!
turn_port_found
|
|
stun_servers
.
find
(
remote_addr
)
!
=
stun_servers
.
end
(
)
)
{
RTC_DCHECK
(
udp_port_
-
>
SharedSocket
(
)
)
;
udp_port_
-
>
HandleIncomingPacket
(
socket
data
size
remote_addr
packet_time
)
;
}
}
}
void
AllocationSequence
:
:
OnPortDestroyed
(
PortInterface
*
port
)
{
if
(
udp_port_
=
=
port
)
{
udp_port_
=
NULL
;
return
;
}
auto
it
=
std
:
:
find
(
turn_ports_
.
begin
(
)
turn_ports_
.
end
(
)
port
)
;
if
(
it
!
=
turn_ports_
.
end
(
)
)
{
turn_ports_
.
erase
(
it
)
;
}
else
{
LOG
(
LS_ERROR
)
<
<
"
Unexpected
OnPortDestroyed
for
nonexistent
port
.
"
;
RTC_NOTREACHED
(
)
;
}
}
PortConfiguration
:
:
PortConfiguration
(
const
rtc
:
:
SocketAddress
&
stun_address
const
std
:
:
string
&
username
const
std
:
:
string
&
password
)
:
stun_address
(
stun_address
)
username
(
username
)
password
(
password
)
{
if
(
!
stun_address
.
IsNil
(
)
)
stun_servers
.
insert
(
stun_address
)
;
}
PortConfiguration
:
:
PortConfiguration
(
const
ServerAddresses
&
stun_servers
const
std
:
:
string
&
username
const
std
:
:
string
&
password
)
:
stun_servers
(
stun_servers
)
username
(
username
)
password
(
password
)
{
if
(
!
stun_servers
.
empty
(
)
)
stun_address
=
*
(
stun_servers
.
begin
(
)
)
;
}
ServerAddresses
PortConfiguration
:
:
StunServers
(
)
{
if
(
!
stun_address
.
IsNil
(
)
&
&
stun_servers
.
find
(
stun_address
)
=
=
stun_servers
.
end
(
)
)
{
stun_servers
.
insert
(
stun_address
)
;
}
ServerAddresses
turn_servers
=
GetRelayServerAddresses
(
RELAY_TURN
PROTO_UDP
)
;
for
(
const
rtc
:
:
SocketAddress
&
turn_server
:
turn_servers
)
{
if
(
stun_servers
.
find
(
turn_server
)
=
=
stun_servers
.
end
(
)
)
{
stun_servers
.
insert
(
turn_server
)
;
}
}
return
stun_servers
;
}
void
PortConfiguration
:
:
AddRelay
(
const
RelayServerConfig
&
config
)
{
relays
.
push_back
(
config
)
;
}
bool
PortConfiguration
:
:
SupportsProtocol
(
const
RelayServerConfig
&
relay
ProtocolType
type
)
const
{
PortList
:
:
const_iterator
relay_port
;
for
(
relay_port
=
relay
.
ports
.
begin
(
)
;
relay_port
!
=
relay
.
ports
.
end
(
)
;
+
+
relay_port
)
{
if
(
relay_port
-
>
proto
=
=
type
)
return
true
;
}
return
false
;
}
bool
PortConfiguration
:
:
SupportsProtocol
(
RelayType
turn_type
ProtocolType
type
)
const
{
for
(
size_t
i
=
0
;
i
<
relays
.
size
(
)
;
+
+
i
)
{
if
(
relays
[
i
]
.
type
=
=
turn_type
&
&
SupportsProtocol
(
relays
[
i
]
type
)
)
return
true
;
}
return
false
;
}
ServerAddresses
PortConfiguration
:
:
GetRelayServerAddresses
(
RelayType
turn_type
ProtocolType
type
)
const
{
ServerAddresses
servers
;
for
(
size_t
i
=
0
;
i
<
relays
.
size
(
)
;
+
+
i
)
{
if
(
relays
[
i
]
.
type
=
=
turn_type
&
&
SupportsProtocol
(
relays
[
i
]
type
)
)
{
servers
.
insert
(
relays
[
i
]
.
ports
.
front
(
)
.
address
)
;
}
}
return
servers
;
}
}
