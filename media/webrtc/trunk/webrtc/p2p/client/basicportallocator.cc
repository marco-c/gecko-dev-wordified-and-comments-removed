#
include
"
webrtc
/
p2p
/
client
/
basicportallocator
.
h
"
#
include
<
algorithm
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
p2p
/
base
/
basicpacketsocketfactory
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
common
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
port
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
relayport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
stunport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
tcpport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
turnport
.
h
"
#
include
"
webrtc
/
p2p
/
base
/
udpport
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
helpers
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
using
rtc
:
:
CreateRandomId
;
using
rtc
:
:
CreateRandomString
;
namespace
{
enum
{
MSG_CONFIG_START
MSG_CONFIG_READY
MSG_ALLOCATE
MSG_ALLOCATION_PHASE
MSG_SHAKE
MSG_SEQUENCEOBJECTS_CREATED
MSG_CONFIG_STOP
}
;
const
int
PHASE_UDP
=
0
;
const
int
PHASE_RELAY
=
1
;
const
int
PHASE_TCP
=
2
;
const
int
PHASE_SSLTCP
=
3
;
const
int
kNumPhases
=
4
;
const
int
SHAKE_MIN_DELAY
=
45
*
1000
;
const
int
SHAKE_MAX_DELAY
=
90
*
1000
;
int
ShakeDelay
(
)
{
int
range
=
SHAKE_MAX_DELAY
-
SHAKE_MIN_DELAY
+
1
;
return
SHAKE_MIN_DELAY
+
CreateRandomId
(
)
%
range
;
}
}
namespace
cricket
{
const
uint32_t
DISABLE_ALL_PHASES
=
PORTALLOCATOR_DISABLE_UDP
|
PORTALLOCATOR_DISABLE_TCP
|
PORTALLOCATOR_DISABLE_STUN
|
PORTALLOCATOR_DISABLE_RELAY
;
BasicPortAllocator
:
:
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
rtc
:
:
PacketSocketFactory
*
socket_factory
)
:
network_manager_
(
network_manager
)
socket_factory_
(
socket_factory
)
stun_servers_
(
)
{
ASSERT
(
network_manager_
!
=
nullptr
)
;
ASSERT
(
socket_factory_
!
=
nullptr
)
;
Construct
(
)
;
}
BasicPortAllocator
:
:
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
)
:
network_manager_
(
network_manager
)
socket_factory_
(
nullptr
)
stun_servers_
(
)
{
ASSERT
(
network_manager_
!
=
nullptr
)
;
Construct
(
)
;
}
BasicPortAllocator
:
:
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
rtc
:
:
PacketSocketFactory
*
socket_factory
const
ServerAddresses
&
stun_servers
)
:
network_manager_
(
network_manager
)
socket_factory_
(
socket_factory
)
stun_servers_
(
stun_servers
)
{
ASSERT
(
socket_factory_
!
=
NULL
)
;
Construct
(
)
;
}
BasicPortAllocator
:
:
BasicPortAllocator
(
rtc
:
:
NetworkManager
*
network_manager
const
ServerAddresses
&
stun_servers
const
rtc
:
:
SocketAddress
&
relay_address_udp
const
rtc
:
:
SocketAddress
&
relay_address_tcp
const
rtc
:
:
SocketAddress
&
relay_address_ssl
)
:
network_manager_
(
network_manager
)
socket_factory_
(
NULL
)
stun_servers_
(
stun_servers
)
{
RelayServerConfig
config
(
RELAY_GTURN
)
;
if
(
!
relay_address_udp
.
IsNil
(
)
)
{
config
.
ports
.
push_back
(
ProtocolAddress
(
relay_address_udp
PROTO_UDP
)
)
;
}
if
(
!
relay_address_tcp
.
IsNil
(
)
)
{
config
.
ports
.
push_back
(
ProtocolAddress
(
relay_address_tcp
PROTO_TCP
)
)
;
}
if
(
!
relay_address_ssl
.
IsNil
(
)
)
{
config
.
ports
.
push_back
(
ProtocolAddress
(
relay_address_ssl
PROTO_SSLTCP
)
)
;
}
if
(
!
config
.
ports
.
empty
(
)
)
{
AddTurnServer
(
config
)
;
}
Construct
(
)
;
}
void
BasicPortAllocator
:
:
Construct
(
)
{
allow_tcp_listen_
=
true
;
}
BasicPortAllocator
:
:
~
BasicPortAllocator
(
)
{
}
PortAllocatorSession
*
BasicPortAllocator
:
:
CreateSessionInternal
(
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
{
return
new
BasicPortAllocatorSession
(
this
content_name
component
ice_ufrag
ice_pwd
)
;
}
BasicPortAllocatorSession
:
:
BasicPortAllocatorSession
(
BasicPortAllocator
*
allocator
const
std
:
:
string
&
content_name
int
component
const
std
:
:
string
&
ice_ufrag
const
std
:
:
string
&
ice_pwd
)
:
PortAllocatorSession
(
content_name
component
ice_ufrag
ice_pwd
allocator
-
>
flags
(
)
)
allocator_
(
allocator
)
network_thread_
(
NULL
)
socket_factory_
(
allocator
-
>
socket_factory
(
)
)
allocation_started_
(
false
)
network_manager_started_
(
false
)
running_
(
false
)
allocation_sequences_created_
(
false
)
{
allocator_
-
>
network_manager
(
)
-
>
SignalNetworksChanged
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnNetworksChanged
)
;
allocator_
-
>
network_manager
(
)
-
>
StartUpdating
(
)
;
}
BasicPortAllocatorSession
:
:
~
BasicPortAllocatorSession
(
)
{
allocator_
-
>
network_manager
(
)
-
>
StopUpdating
(
)
;
if
(
network_thread_
!
=
NULL
)
network_thread_
-
>
Clear
(
this
)
;
for
(
uint32_t
i
=
0
;
i
<
sequences_
.
size
(
)
;
+
+
i
)
{
sequences_
[
i
]
-
>
Clear
(
)
;
}
std
:
:
vector
<
PortData
>
:
:
iterator
it
;
for
(
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
it
+
+
)
delete
it
-
>
port
(
)
;
for
(
uint32_t
i
=
0
;
i
<
configs_
.
size
(
)
;
+
+
i
)
delete
configs_
[
i
]
;
for
(
uint32_t
i
=
0
;
i
<
sequences_
.
size
(
)
;
+
+
i
)
delete
sequences_
[
i
]
;
}
void
BasicPortAllocatorSession
:
:
StartGettingPorts
(
)
{
network_thread_
=
rtc
:
:
Thread
:
:
Current
(
)
;
if
(
!
socket_factory_
)
{
owned_socket_factory_
.
reset
(
new
rtc
:
:
BasicPacketSocketFactory
(
network_thread_
)
)
;
socket_factory_
=
owned_socket_factory_
.
get
(
)
;
}
running_
=
true
;
network_thread_
-
>
Post
(
this
MSG_CONFIG_START
)
;
if
(
flags
(
)
&
PORTALLOCATOR_ENABLE_SHAKER
)
network_thread_
-
>
PostDelayed
(
ShakeDelay
(
)
this
MSG_SHAKE
)
;
}
void
BasicPortAllocatorSession
:
:
StopGettingPorts
(
)
{
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
running_
=
false
;
network_thread_
-
>
Post
(
this
MSG_CONFIG_STOP
)
;
ClearGettingPorts
(
)
;
}
void
BasicPortAllocatorSession
:
:
ClearGettingPorts
(
)
{
network_thread_
-
>
Clear
(
this
MSG_ALLOCATE
)
;
for
(
uint32_t
i
=
0
;
i
<
sequences_
.
size
(
)
;
+
+
i
)
sequences_
[
i
]
-
>
Stop
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnMessage
(
rtc
:
:
Message
*
message
)
{
switch
(
message
-
>
message_id
)
{
case
MSG_CONFIG_START
:
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
GetPortConfigurations
(
)
;
break
;
case
MSG_CONFIG_READY
:
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
OnConfigReady
(
static_cast
<
PortConfiguration
*
>
(
message
-
>
pdata
)
)
;
break
;
case
MSG_ALLOCATE
:
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
OnAllocate
(
)
;
break
;
case
MSG_SHAKE
:
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
OnShake
(
)
;
break
;
case
MSG_SEQUENCEOBJECTS_CREATED
:
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
OnAllocationSequenceObjectsCreated
(
)
;
break
;
case
MSG_CONFIG_STOP
:
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
OnConfigStop
(
)
;
break
;
default
:
ASSERT
(
false
)
;
}
}
void
BasicPortAllocatorSession
:
:
GetPortConfigurations
(
)
{
PortConfiguration
*
config
=
new
PortConfiguration
(
allocator_
-
>
stun_servers
(
)
username
(
)
password
(
)
)
;
for
(
const
RelayServerConfig
&
turn_server
:
allocator_
-
>
turn_servers
(
)
)
{
config
-
>
AddRelay
(
turn_server
)
;
}
ConfigReady
(
config
)
;
}
void
BasicPortAllocatorSession
:
:
ConfigReady
(
PortConfiguration
*
config
)
{
network_thread_
-
>
Post
(
this
MSG_CONFIG_READY
config
)
;
}
void
BasicPortAllocatorSession
:
:
OnConfigReady
(
PortConfiguration
*
config
)
{
if
(
config
)
{
configs_
.
push_back
(
config
)
;
}
AllocatePorts
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnConfigStop
(
)
{
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
bool
send_signal
=
false
;
for
(
std
:
:
vector
<
PortData
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
if
(
!
it
-
>
complete
(
)
)
{
it
-
>
set_error
(
)
;
send_signal
=
true
;
}
}
for
(
std
:
:
vector
<
AllocationSequence
*
>
:
:
iterator
it
=
sequences_
.
begin
(
)
;
it
!
=
sequences_
.
end
(
)
&
&
!
send_signal
;
+
+
it
)
{
if
(
(
*
it
)
-
>
state
(
)
=
=
AllocationSequence
:
:
kStopped
)
{
send_signal
=
true
;
}
}
if
(
send_signal
)
{
MaybeSignalCandidatesAllocationDone
(
)
;
}
}
void
BasicPortAllocatorSession
:
:
AllocatePorts
(
)
{
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
network_thread_
-
>
Post
(
this
MSG_ALLOCATE
)
;
}
void
BasicPortAllocatorSession
:
:
OnAllocate
(
)
{
if
(
network_manager_started_
)
DoAllocate
(
)
;
allocation_started_
=
true
;
}
void
BasicPortAllocatorSession
:
:
GetNetworks
(
std
:
:
vector
<
rtc
:
:
Network
*
>
*
networks
)
{
networks
-
>
clear
(
)
;
rtc
:
:
NetworkManager
*
network_manager
=
allocator_
-
>
network_manager
(
)
;
ASSERT
(
network_manager
!
=
nullptr
)
;
if
(
network_manager
-
>
enumeration_permission
(
)
=
=
rtc
:
:
NetworkManager
:
:
ENUMERATION_BLOCKED
)
{
set_flags
(
flags
(
)
|
PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION
)
;
}
if
(
flags
(
)
&
PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION
)
{
network_manager
-
>
GetAnyAddressNetworks
(
networks
)
;
}
else
{
network_manager
-
>
GetNetworks
(
networks
)
;
}
networks
-
>
erase
(
std
:
:
remove_if
(
networks
-
>
begin
(
)
networks
-
>
end
(
)
[
this
]
(
rtc
:
:
Network
*
network
)
{
return
allocator_
-
>
network_ignore_mask
(
)
&
network
-
>
type
(
)
;
}
)
networks
-
>
end
(
)
)
;
}
void
BasicPortAllocatorSession
:
:
DoAllocate
(
)
{
bool
done_signal_needed
=
false
;
std
:
:
vector
<
rtc
:
:
Network
*
>
networks
;
GetNetworks
(
&
networks
)
;
if
(
networks
.
empty
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Machine
has
no
networks
;
no
ports
will
be
allocated
"
;
done_signal_needed
=
true
;
}
else
{
for
(
uint32_t
i
=
0
;
i
<
networks
.
size
(
)
;
+
+
i
)
{
PortConfiguration
*
config
=
NULL
;
if
(
configs_
.
size
(
)
>
0
)
config
=
configs_
.
back
(
)
;
uint32_t
sequence_flags
=
flags
(
)
;
if
(
(
sequence_flags
&
DISABLE_ALL_PHASES
)
=
=
DISABLE_ALL_PHASES
)
{
done_signal_needed
=
true
;
break
;
}
if
(
!
config
|
|
config
-
>
relays
.
empty
(
)
)
{
sequence_flags
|
=
PORTALLOCATOR_DISABLE_RELAY
;
}
if
(
!
(
sequence_flags
&
PORTALLOCATOR_ENABLE_IPV6
)
&
&
networks
[
i
]
-
>
GetBestIP
(
)
.
family
(
)
=
=
AF_INET6
)
{
continue
;
}
DisableEquivalentPhases
(
networks
[
i
]
config
&
sequence_flags
)
;
if
(
(
sequence_flags
&
DISABLE_ALL_PHASES
)
=
=
DISABLE_ALL_PHASES
)
{
continue
;
}
AllocationSequence
*
sequence
=
new
AllocationSequence
(
this
networks
[
i
]
config
sequence_flags
)
;
if
(
!
sequence
-
>
Init
(
)
)
{
delete
sequence
;
continue
;
}
done_signal_needed
=
true
;
sequence
-
>
SignalPortAllocationComplete
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnPortAllocationComplete
)
;
if
(
running_
)
sequence
-
>
Start
(
)
;
sequences_
.
push_back
(
sequence
)
;
}
}
if
(
done_signal_needed
)
{
network_thread_
-
>
Post
(
this
MSG_SEQUENCEOBJECTS_CREATED
)
;
}
}
void
BasicPortAllocatorSession
:
:
OnNetworksChanged
(
)
{
std
:
:
vector
<
rtc
:
:
Network
*
>
networks
;
GetNetworks
(
&
networks
)
;
for
(
AllocationSequence
*
sequence
:
sequences_
)
{
if
(
!
sequence
-
>
network_removed
(
)
&
&
std
:
:
find
(
networks
.
begin
(
)
networks
.
end
(
)
sequence
-
>
network
(
)
)
=
=
networks
.
end
(
)
)
{
sequence
-
>
OnNetworkRemoved
(
)
;
}
}
network_manager_started_
=
true
;
if
(
allocation_started_
)
DoAllocate
(
)
;
}
void
BasicPortAllocatorSession
:
:
DisableEquivalentPhases
(
rtc
:
:
Network
*
network
PortConfiguration
*
config
uint32_t
*
flags
)
{
for
(
uint32_t
i
=
0
;
i
<
sequences_
.
size
(
)
&
&
(
*
flags
&
DISABLE_ALL_PHASES
)
!
=
DISABLE_ALL_PHASES
;
+
+
i
)
{
sequences_
[
i
]
-
>
DisableEquivalentPhases
(
network
config
flags
)
;
}
}
void
BasicPortAllocatorSession
:
:
AddAllocatedPort
(
Port
*
port
AllocationSequence
*
seq
bool
prepare_address
)
{
if
(
!
port
)
return
;
LOG
(
LS_INFO
)
<
<
"
Adding
allocated
port
for
"
<
<
content_name
(
)
;
port
-
>
set_content_name
(
content_name
(
)
)
;
port
-
>
set_component
(
component_
)
;
port
-
>
set_generation
(
generation
(
)
)
;
if
(
allocator_
-
>
proxy
(
)
.
type
!
=
rtc
:
:
PROXY_NONE
)
port
-
>
set_proxy
(
allocator_
-
>
user_agent
(
)
allocator_
-
>
proxy
(
)
)
;
port
-
>
set_send_retransmit_count_attribute
(
(
allocator_
-
>
flags
(
)
&
PORTALLOCATOR_ENABLE_STUN_RETRANSMIT_ATTRIBUTE
)
!
=
0
)
;
uint32_t
candidate_filter
=
allocator_
-
>
candidate_filter
(
)
;
if
(
(
flags
(
)
&
PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION
)
&
&
(
flags
(
)
&
PORTALLOCATOR_DISABLE_DEFAULT_LOCAL_CANDIDATE
)
)
{
candidate_filter
&
=
~
CF_HOST
;
}
port
-
>
set_candidate_filter
(
candidate_filter
)
;
PortData
data
(
port
seq
)
;
ports_
.
push_back
(
data
)
;
port
-
>
SignalCandidateReady
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnCandidateReady
)
;
port
-
>
SignalPortComplete
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnPortComplete
)
;
port
-
>
SignalDestroyed
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnPortDestroyed
)
;
port
-
>
SignalPortError
.
connect
(
this
&
BasicPortAllocatorSession
:
:
OnPortError
)
;
LOG_J
(
LS_INFO
port
)
<
<
"
Added
port
to
allocator
"
;
if
(
prepare_address
)
port
-
>
PrepareAddress
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnAllocationSequenceObjectsCreated
(
)
{
allocation_sequences_created_
=
true
;
MaybeSignalCandidatesAllocationDone
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnCandidateReady
(
Port
*
port
const
Candidate
&
c
)
{
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
PortData
*
data
=
FindPort
(
port
)
;
ASSERT
(
data
!
=
NULL
)
;
if
(
data
-
>
complete
(
)
)
return
;
ProtocolType
pvalue
;
bool
candidate_signalable
=
CheckCandidateFilter
(
c
)
;
bool
network_enumeration_disabled
=
c
.
address
(
)
.
IsAnyIP
(
)
;
bool
can_ping_from_candidate
=
(
port
-
>
SharedSocket
(
)
|
|
c
.
protocol
(
)
=
=
TCP_PROTOCOL_NAME
)
;
bool
host_canidates_disabled
=
!
(
allocator_
-
>
candidate_filter
(
)
&
CF_HOST
)
;
bool
candidate_pairable
=
candidate_signalable
|
|
(
network_enumeration_disabled
&
&
can_ping_from_candidate
&
&
!
host_canidates_disabled
)
;
bool
candidate_protocol_enabled
=
StringToProto
(
c
.
protocol
(
)
.
c_str
(
)
&
pvalue
)
&
&
data
-
>
sequence
(
)
-
>
ProtocolEnabled
(
pvalue
)
;
if
(
candidate_signalable
&
&
candidate_protocol_enabled
)
{
std
:
:
vector
<
Candidate
>
candidates
;
candidates
.
push_back
(
c
)
;
SignalCandidatesReady
(
this
candidates
)
;
}
if
(
data
-
>
ready
(
)
)
{
return
;
}
if
(
candidate_pairable
)
{
data
-
>
set_ready
(
)
;
SignalPortReady
(
this
port
)
;
}
}
void
BasicPortAllocatorSession
:
:
OnPortComplete
(
Port
*
port
)
{
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
PortData
*
data
=
FindPort
(
port
)
;
ASSERT
(
data
!
=
NULL
)
;
if
(
data
-
>
complete
(
)
)
return
;
data
-
>
set_complete
(
)
;
MaybeSignalCandidatesAllocationDone
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnPortError
(
Port
*
port
)
{
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
PortData
*
data
=
FindPort
(
port
)
;
ASSERT
(
data
!
=
NULL
)
;
if
(
data
-
>
complete
(
)
)
return
;
data
-
>
set_error
(
)
;
MaybeSignalCandidatesAllocationDone
(
)
;
}
void
BasicPortAllocatorSession
:
:
OnProtocolEnabled
(
AllocationSequence
*
seq
ProtocolType
proto
)
{
std
:
:
vector
<
Candidate
>
candidates
;
for
(
std
:
:
vector
<
PortData
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
sequence
(
)
!
=
seq
)
continue
;
const
std
:
:
vector
<
Candidate
>
&
potentials
=
it
-
>
port
(
)
-
>
Candidates
(
)
;
for
(
size_t
i
=
0
;
i
<
potentials
.
size
(
)
;
+
+
i
)
{
if
(
!
CheckCandidateFilter
(
potentials
[
i
]
)
)
continue
;
ProtocolType
pvalue
;
bool
candidate_protocol_enabled
=
StringToProto
(
potentials
[
i
]
.
protocol
(
)
.
c_str
(
)
&
pvalue
)
&
&
pvalue
=
=
proto
;
if
(
candidate_protocol_enabled
)
{
candidates
.
push_back
(
potentials
[
i
]
)
;
}
}
}
if
(
!
candidates
.
empty
(
)
)
{
SignalCandidatesReady
(
this
candidates
)
;
}
}
bool
BasicPortAllocatorSession
:
:
CheckCandidateFilter
(
const
Candidate
&
c
)
{
uint32_t
filter
=
allocator_
-
>
candidate_filter
(
)
;
if
(
c
.
address
(
)
.
IsAnyIP
(
)
)
{
return
false
;
}
if
(
c
.
type
(
)
=
=
RELAY_PORT_TYPE
)
{
return
(
(
filter
&
CF_RELAY
)
!
=
0
)
;
}
else
if
(
c
.
type
(
)
=
=
STUN_PORT_TYPE
)
{
return
(
(
filter
&
CF_REFLEXIVE
)
!
=
0
)
;
}
else
if
(
c
.
type
(
)
=
=
LOCAL_PORT_TYPE
)
{
if
(
(
filter
&
CF_REFLEXIVE
)
&
&
!
c
.
address
(
)
.
IsPrivateIP
(
)
)
{
return
true
;
}
return
(
(
filter
&
CF_HOST
)
!
=
0
)
;
}
return
false
;
}
void
BasicPortAllocatorSession
:
:
OnPortAllocationComplete
(
AllocationSequence
*
seq
)
{
MaybeSignalCandidatesAllocationDone
(
)
;
}
void
BasicPortAllocatorSession
:
:
MaybeSignalCandidatesAllocationDone
(
)
{
if
(
!
allocation_sequences_created_
)
return
;
for
(
std
:
:
vector
<
AllocationSequence
*
>
:
:
iterator
it
=
sequences_
.
begin
(
)
;
it
!
=
sequences_
.
end
(
)
;
+
+
it
)
{
if
(
(
*
it
)
-
>
state
(
)
=
=
AllocationSequence
:
:
kRunning
)
return
;
}
for
(
std
:
:
vector
<
PortData
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
if
(
!
it
-
>
complete
(
)
)
return
;
}
LOG
(
LS_INFO
)
<
<
"
All
candidates
gathered
for
"
<
<
content_name_
<
<
"
:
"
<
<
component_
<
<
"
:
"
<
<
generation
(
)
;
SignalCandidatesAllocationDone
(
this
)
;
}
void
BasicPortAllocatorSession
:
:
OnPortDestroyed
(
PortInterface
*
port
)
{
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
network_thread_
)
;
for
(
std
:
:
vector
<
PortData
>
:
:
iterator
iter
=
ports_
.
begin
(
)
;
iter
!
=
ports_
.
end
(
)
;
+
+
iter
)
{
if
(
port
=
=
iter
-
>
port
(
)
)
{
ports_
.
erase
(
iter
)
;
LOG_J
(
LS_INFO
port
)
<
<
"
Removed
port
from
allocator
(
"
<
<
static_cast
<
int
>
(
ports_
.
size
(
)
)
<
<
"
remaining
)
"
;
return
;
}
}
ASSERT
(
false
)
;
}
void
BasicPortAllocatorSession
:
:
OnShake
(
)
{
LOG
(
INFO
)
<
<
"
>
>
>
>
>
SHAKE
<
<
<
<
<
>
>
>
>
>
SHAKE
<
<
<
<
<
>
>
>
>
>
SHAKE
<
<
<
<
<
"
;
std
:
:
vector
<
Port
*
>
ports
;
std
:
:
vector
<
Connection
*
>
connections
;
for
(
size_t
i
=
0
;
i
<
ports_
.
size
(
)
;
+
+
i
)
{
if
(
ports_
[
i
]
.
ready
(
)
)
ports
.
push_back
(
ports_
[
i
]
.
port
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
ports
.
size
(
)
;
+
+
i
)
{
Port
:
:
AddressMap
:
:
const_iterator
iter
;
for
(
iter
=
ports
[
i
]
-
>
connections
(
)
.
begin
(
)
;
iter
!
=
ports
[
i
]
-
>
connections
(
)
.
end
(
)
;
+
+
iter
)
{
connections
.
push_back
(
iter
-
>
second
)
;
}
}
LOG
(
INFO
)
<
<
"
>
>
>
>
>
Destroying
"
<
<
ports
.
size
(
)
<
<
"
ports
and
"
<
<
connections
.
size
(
)
<
<
"
connections
"
;
for
(
size_t
i
=
0
;
i
<
connections
.
size
(
)
;
+
+
i
)
connections
[
i
]
-
>
Destroy
(
)
;
if
(
running_
|
|
(
ports
.
size
(
)
>
0
)
|
|
(
connections
.
size
(
)
>
0
)
)
network_thread_
-
>
PostDelayed
(
ShakeDelay
(
)
this
MSG_SHAKE
)
;
}
BasicPortAllocatorSession
:
:
PortData
*
BasicPortAllocatorSession
:
:
FindPort
(
Port
*
port
)
{
for
(
std
:
:
vector
<
PortData
>
:
:
iterator
it
=
ports_
.
begin
(
)
;
it
!
=
ports_
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
port
(
)
=
=
port
)
{
return
&
*
it
;
}
}
return
NULL
;
}
AllocationSequence
:
:
AllocationSequence
(
BasicPortAllocatorSession
*
session
rtc
:
:
Network
*
network
PortConfiguration
*
config
uint32_t
flags
)
:
session_
(
session
)
network_
(
network
)
ip_
(
network
-
>
GetBestIP
(
)
)
config_
(
config
)
state_
(
kInit
)
flags_
(
flags
)
udp_socket_
(
)
udp_port_
(
NULL
)
phase_
(
0
)
{
}
bool
AllocationSequence
:
:
Init
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
)
{
udp_socket_
.
reset
(
session_
-
>
socket_factory
(
)
-
>
CreateUdpSocket
(
rtc
:
:
SocketAddress
(
ip_
0
)
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
)
)
;
if
(
udp_socket_
)
{
udp_socket_
-
>
SignalReadPacket
.
connect
(
this
&
AllocationSequence
:
:
OnReadPacket
)
;
}
}
return
true
;
}
void
AllocationSequence
:
:
Clear
(
)
{
udp_port_
=
NULL
;
turn_ports_
.
clear
(
)
;
}
void
AllocationSequence
:
:
OnNetworkRemoved
(
)
{
Stop
(
)
;
network_removed_
=
true
;
}
AllocationSequence
:
:
~
AllocationSequence
(
)
{
session_
-
>
network_thread
(
)
-
>
Clear
(
this
)
;
}
void
AllocationSequence
:
:
DisableEquivalentPhases
(
rtc
:
:
Network
*
network
PortConfiguration
*
config
uint32_t
*
flags
)
{
if
(
network_removed_
)
{
return
;
}
if
(
!
(
(
network
=
=
network_
)
&
&
(
ip_
=
=
network
-
>
GetBestIP
(
)
)
)
)
{
return
;
}
*
flags
|
=
PORTALLOCATOR_DISABLE_UDP
;
*
flags
|
=
PORTALLOCATOR_DISABLE_TCP
;
if
(
config_
&
&
config
)
{
if
(
config_
-
>
StunServers
(
)
=
=
config
-
>
StunServers
(
)
)
{
*
flags
|
=
PORTALLOCATOR_DISABLE_STUN
;
}
if
(
!
config_
-
>
relays
.
empty
(
)
)
{
*
flags
|
=
PORTALLOCATOR_DISABLE_RELAY
;
}
}
}
void
AllocationSequence
:
:
Start
(
)
{
state_
=
kRunning
;
session_
-
>
network_thread
(
)
-
>
Post
(
this
MSG_ALLOCATION_PHASE
)
;
}
void
AllocationSequence
:
:
Stop
(
)
{
if
(
state_
=
=
kRunning
)
{
state_
=
kStopped
;
session_
-
>
network_thread
(
)
-
>
Clear
(
this
MSG_ALLOCATION_PHASE
)
;
}
}
void
AllocationSequence
:
:
OnMessage
(
rtc
:
:
Message
*
msg
)
{
ASSERT
(
rtc
:
:
Thread
:
:
Current
(
)
=
=
session_
-
>
network_thread
(
)
)
;
ASSERT
(
msg
-
>
message_id
=
=
MSG_ALLOCATION_PHASE
)
;
const
char
*
const
PHASE_NAMES
[
kNumPhases
]
=
{
"
Udp
"
"
Relay
"
"
Tcp
"
"
SslTcp
"
}
;
LOG_J
(
LS_INFO
network_
)
<
<
"
Allocation
Phase
=
"
<
<
PHASE_NAMES
[
phase_
]
;
switch
(
phase_
)
{
case
PHASE_UDP
:
CreateUDPPorts
(
)
;
CreateStunPorts
(
)
;
EnableProtocol
(
PROTO_UDP
)
;
break
;
case
PHASE_RELAY
:
CreateRelayPorts
(
)
;
break
;
case
PHASE_TCP
:
CreateTCPPorts
(
)
;
EnableProtocol
(
PROTO_TCP
)
;
break
;
case
PHASE_SSLTCP
:
state_
=
kCompleted
;
EnableProtocol
(
PROTO_SSLTCP
)
;
break
;
default
:
ASSERT
(
false
)
;
}
if
(
state
(
)
=
=
kRunning
)
{
+
+
phase_
;
session_
-
>
network_thread
(
)
-
>
PostDelayed
(
session_
-
>
allocator
(
)
-
>
step_delay
(
)
this
MSG_ALLOCATION_PHASE
)
;
}
else
{
session_
-
>
network_thread
(
)
-
>
Clear
(
this
MSG_ALLOCATION_PHASE
)
;
SignalPortAllocationComplete
(
this
)
;
}
}
void
AllocationSequence
:
:
EnableProtocol
(
ProtocolType
proto
)
{
if
(
!
ProtocolEnabled
(
proto
)
)
{
protocols_
.
push_back
(
proto
)
;
session_
-
>
OnProtocolEnabled
(
this
proto
)
;
}
}
bool
AllocationSequence
:
:
ProtocolEnabled
(
ProtocolType
proto
)
const
{
for
(
ProtocolList
:
:
const_iterator
it
=
protocols_
.
begin
(
)
;
it
!
=
protocols_
.
end
(
)
;
+
+
it
)
{
if
(
*
it
=
=
proto
)
return
true
;
}
return
false
;
}
void
AllocationSequence
:
:
CreateUDPPorts
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_UDP
)
)
{
LOG
(
LS_VERBOSE
)
<
<
"
AllocationSequence
:
UDP
ports
disabled
skipping
.
"
;
return
;
}
UDPPort
*
port
=
NULL
;
bool
emit_local_candidate_for_anyaddress
=
!
IsFlagSet
(
PORTALLOCATOR_DISABLE_DEFAULT_LOCAL_CANDIDATE
)
;
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
&
&
udp_socket_
)
{
port
=
UDPPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
udp_socket_
.
get
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
session_
-
>
allocator
(
)
-
>
origin
(
)
emit_local_candidate_for_anyaddress
)
;
}
else
{
port
=
UDPPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
session_
-
>
allocator
(
)
-
>
origin
(
)
emit_local_candidate_for_anyaddress
)
;
}
if
(
port
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
)
{
udp_port_
=
port
;
port
-
>
SignalDestroyed
.
connect
(
this
&
AllocationSequence
:
:
OnPortDestroyed
)
;
if
(
!
IsFlagSet
(
PORTALLOCATOR_DISABLE_STUN
)
)
{
if
(
config_
&
&
!
config_
-
>
StunServers
(
)
.
empty
(
)
)
{
LOG
(
LS_INFO
)
<
<
"
AllocationSequence
:
UDPPort
will
be
handling
the
"
<
<
"
STUN
candidate
generation
.
"
;
port
-
>
set_server_addresses
(
config_
-
>
StunServers
(
)
)
;
}
}
}
session_
-
>
AddAllocatedPort
(
port
this
true
)
;
}
}
void
AllocationSequence
:
:
CreateTCPPorts
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_TCP
)
)
{
LOG
(
LS_VERBOSE
)
<
<
"
AllocationSequence
:
TCP
ports
disabled
skipping
.
"
;
return
;
}
Port
*
port
=
TCPPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
session_
-
>
allocator
(
)
-
>
allow_tcp_listen
(
)
)
;
if
(
port
)
{
session_
-
>
AddAllocatedPort
(
port
this
true
)
;
}
}
void
AllocationSequence
:
:
CreateStunPorts
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_STUN
)
)
{
LOG
(
LS_VERBOSE
)
<
<
"
AllocationSequence
:
STUN
ports
disabled
skipping
.
"
;
return
;
}
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
)
{
return
;
}
if
(
!
(
config_
&
&
!
config_
-
>
StunServers
(
)
.
empty
(
)
)
)
{
LOG
(
LS_WARNING
)
<
<
"
AllocationSequence
:
No
STUN
server
configured
skipping
.
"
;
return
;
}
StunPort
*
port
=
StunPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
config_
-
>
StunServers
(
)
session_
-
>
allocator
(
)
-
>
origin
(
)
)
;
if
(
port
)
{
session_
-
>
AddAllocatedPort
(
port
this
true
)
;
}
}
void
AllocationSequence
:
:
CreateRelayPorts
(
)
{
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_RELAY
)
)
{
LOG
(
LS_VERBOSE
)
<
<
"
AllocationSequence
:
Relay
ports
disabled
skipping
.
"
;
return
;
}
ASSERT
(
config_
&
&
!
config_
-
>
relays
.
empty
(
)
)
;
if
(
!
(
config_
&
&
!
config_
-
>
relays
.
empty
(
)
)
)
{
LOG
(
LS_WARNING
)
<
<
"
AllocationSequence
:
No
relay
server
configured
skipping
.
"
;
return
;
}
PortConfiguration
:
:
RelayList
:
:
const_iterator
relay
;
for
(
relay
=
config_
-
>
relays
.
begin
(
)
;
relay
!
=
config_
-
>
relays
.
end
(
)
;
+
+
relay
)
{
if
(
relay
-
>
type
=
=
RELAY_GTURN
)
{
CreateGturnPort
(
*
relay
)
;
}
else
if
(
relay
-
>
type
=
=
RELAY_TURN
)
{
CreateTurnPort
(
*
relay
)
;
}
else
{
ASSERT
(
false
)
;
}
}
}
void
AllocationSequence
:
:
CreateGturnPort
(
const
RelayServerConfig
&
config
)
{
RelayPort
*
port
=
RelayPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
config_
-
>
username
config_
-
>
password
)
;
if
(
port
)
{
session_
-
>
AddAllocatedPort
(
port
this
false
)
;
PortList
:
:
const_iterator
relay_port
;
for
(
relay_port
=
config
.
ports
.
begin
(
)
;
relay_port
!
=
config
.
ports
.
end
(
)
;
+
+
relay_port
)
{
port
-
>
AddServerAddress
(
*
relay_port
)
;
port
-
>
AddExternalAddress
(
*
relay_port
)
;
}
port
-
>
PrepareAddress
(
)
;
}
}
void
AllocationSequence
:
:
CreateTurnPort
(
const
RelayServerConfig
&
config
)
{
PortList
:
:
const_iterator
relay_port
;
for
(
relay_port
=
config
.
ports
.
begin
(
)
;
relay_port
!
=
config
.
ports
.
end
(
)
;
+
+
relay_port
)
{
TurnPort
*
port
=
NULL
;
if
(
IsFlagSet
(
PORTALLOCATOR_DISABLE_UDP_RELAY
)
&
&
relay_port
-
>
proto
=
=
PROTO_UDP
)
{
continue
;
}
if
(
IsFlagSet
(
PORTALLOCATOR_ENABLE_SHARED_SOCKET
)
&
&
relay_port
-
>
proto
=
=
PROTO_UDP
&
&
udp_socket_
)
{
port
=
TurnPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
udp_socket_
.
get
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
*
relay_port
config
.
credentials
config
.
priority
session_
-
>
allocator
(
)
-
>
origin
(
)
)
;
turn_ports_
.
push_back
(
port
)
;
port
-
>
SignalDestroyed
.
connect
(
this
&
AllocationSequence
:
:
OnPortDestroyed
)
;
}
else
{
port
=
TurnPort
:
:
Create
(
session_
-
>
network_thread
(
)
session_
-
>
socket_factory
(
)
network_
ip_
session_
-
>
allocator
(
)
-
>
min_port
(
)
session_
-
>
allocator
(
)
-
>
max_port
(
)
session_
-
>
username
(
)
session_
-
>
password
(
)
*
relay_port
config
.
credentials
config
.
priority
session_
-
>
allocator
(
)
-
>
origin
(
)
)
;
}
ASSERT
(
port
!
=
NULL
)
;
session_
-
>
AddAllocatedPort
(
port
this
true
)
;
}
}
void
AllocationSequence
:
:
OnReadPacket
(
rtc
:
:
AsyncPacketSocket
*
socket
const
char
*
data
size_t
size
const
rtc
:
:
SocketAddress
&
remote_addr
const
rtc
:
:
PacketTime
&
packet_time
)
{
ASSERT
(
socket
=
=
udp_socket_
.
get
(
)
)
;
bool
turn_port_found
=
false
;
for
(
std
:
:
vector
<
TurnPort
*
>
:
:
const_iterator
it
=
turn_ports_
.
begin
(
)
;
it
!
=
turn_ports_
.
end
(
)
;
+
+
it
)
{
TurnPort
*
port
=
*
it
;
if
(
port
-
>
server_address
(
)
.
address
=
=
remote_addr
)
{
port
-
>
HandleIncomingPacket
(
socket
data
size
remote_addr
packet_time
)
;
turn_port_found
=
true
;
break
;
}
}
if
(
udp_port_
)
{
const
ServerAddresses
&
stun_servers
=
udp_port_
-
>
server_addresses
(
)
;
if
(
!
turn_port_found
|
|
stun_servers
.
find
(
remote_addr
)
!
=
stun_servers
.
end
(
)
)
{
udp_port_
-
>
HandleIncomingPacket
(
socket
data
size
remote_addr
packet_time
)
;
}
}
}
void
AllocationSequence
:
:
OnPortDestroyed
(
PortInterface
*
port
)
{
if
(
udp_port_
=
=
port
)
{
udp_port_
=
NULL
;
return
;
}
auto
it
=
std
:
:
find
(
turn_ports_
.
begin
(
)
turn_ports_
.
end
(
)
port
)
;
if
(
it
!
=
turn_ports_
.
end
(
)
)
{
turn_ports_
.
erase
(
it
)
;
}
else
{
LOG
(
LS_ERROR
)
<
<
"
Unexpected
OnPortDestroyed
for
nonexistent
port
.
"
;
ASSERT
(
false
)
;
}
}
PortConfiguration
:
:
PortConfiguration
(
const
rtc
:
:
SocketAddress
&
stun_address
const
std
:
:
string
&
username
const
std
:
:
string
&
password
)
:
stun_address
(
stun_address
)
username
(
username
)
password
(
password
)
{
if
(
!
stun_address
.
IsNil
(
)
)
stun_servers
.
insert
(
stun_address
)
;
}
PortConfiguration
:
:
PortConfiguration
(
const
ServerAddresses
&
stun_servers
const
std
:
:
string
&
username
const
std
:
:
string
&
password
)
:
stun_servers
(
stun_servers
)
username
(
username
)
password
(
password
)
{
if
(
!
stun_servers
.
empty
(
)
)
stun_address
=
*
(
stun_servers
.
begin
(
)
)
;
}
ServerAddresses
PortConfiguration
:
:
StunServers
(
)
{
if
(
!
stun_address
.
IsNil
(
)
&
&
stun_servers
.
find
(
stun_address
)
=
=
stun_servers
.
end
(
)
)
{
stun_servers
.
insert
(
stun_address
)
;
}
ServerAddresses
turn_servers
=
GetRelayServerAddresses
(
RELAY_TURN
PROTO_UDP
)
;
for
(
const
rtc
:
:
SocketAddress
&
turn_server
:
turn_servers
)
{
if
(
stun_servers
.
find
(
turn_server
)
=
=
stun_servers
.
end
(
)
)
{
stun_servers
.
insert
(
turn_server
)
;
}
}
return
stun_servers
;
}
void
PortConfiguration
:
:
AddRelay
(
const
RelayServerConfig
&
config
)
{
relays
.
push_back
(
config
)
;
}
bool
PortConfiguration
:
:
SupportsProtocol
(
const
RelayServerConfig
&
relay
ProtocolType
type
)
const
{
PortList
:
:
const_iterator
relay_port
;
for
(
relay_port
=
relay
.
ports
.
begin
(
)
;
relay_port
!
=
relay
.
ports
.
end
(
)
;
+
+
relay_port
)
{
if
(
relay_port
-
>
proto
=
=
type
)
return
true
;
}
return
false
;
}
bool
PortConfiguration
:
:
SupportsProtocol
(
RelayType
turn_type
ProtocolType
type
)
const
{
for
(
size_t
i
=
0
;
i
<
relays
.
size
(
)
;
+
+
i
)
{
if
(
relays
[
i
]
.
type
=
=
turn_type
&
&
SupportsProtocol
(
relays
[
i
]
type
)
)
return
true
;
}
return
false
;
}
ServerAddresses
PortConfiguration
:
:
GetRelayServerAddresses
(
RelayType
turn_type
ProtocolType
type
)
const
{
ServerAddresses
servers
;
for
(
size_t
i
=
0
;
i
<
relays
.
size
(
)
;
+
+
i
)
{
if
(
relays
[
i
]
.
type
=
=
turn_type
&
&
SupportsProtocol
(
relays
[
i
]
type
)
)
{
servers
.
insert
(
relays
[
i
]
.
ports
.
front
(
)
.
address
)
;
}
}
return
servers
;
}
}
