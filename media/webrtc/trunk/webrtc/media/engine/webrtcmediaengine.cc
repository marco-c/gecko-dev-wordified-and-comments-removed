#
include
"
webrtc
/
media
/
engine
/
webrtcmediaengine
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
codecs
/
builtin_audio_decoder_factory
.
h
"
#
include
<
algorithm
>
#
ifdef
HAVE_WEBRTC_VIDEO
#
include
"
webrtc
/
media
/
engine
/
webrtcvideoengine2
.
h
"
#
else
#
include
"
webrtc
/
media
/
engine
/
nullwebrtcvideoengine
.
h
"
#
endif
#
include
"
webrtc
/
media
/
engine
/
webrtcvoiceengine
.
h
"
namespace
cricket
{
class
WebRtcMediaEngine2
#
ifdef
HAVE_WEBRTC_VIDEO
:
public
CompositeMediaEngine
<
WebRtcVoiceEngine
WebRtcVideoEngine2
>
{
#
else
:
public
CompositeMediaEngine
<
WebRtcVoiceEngine
NullWebRtcVideoEngine
>
{
#
endif
public
:
WebRtcMediaEngine2
(
webrtc
:
:
AudioDeviceModule
*
adm
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDecoderFactory
>
&
audio_decoder_factory
WebRtcVideoEncoderFactory
*
video_encoder_factory
WebRtcVideoDecoderFactory
*
video_decoder_factory
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioMixer
>
audio_mixer
)
#
ifdef
HAVE_WEBRTC_VIDEO
:
CompositeMediaEngine
<
WebRtcVoiceEngine
WebRtcVideoEngine2
>
(
adm
audio_decoder_factory
audio_mixer
)
{
#
else
:
CompositeMediaEngine
<
WebRtcVoiceEngine
NullWebRtcVideoEngine
>
(
adm
audio_decoder_factory
audio_mixer
)
{
#
endif
video_
.
SetExternalDecoderFactory
(
video_decoder_factory
)
;
video_
.
SetExternalEncoderFactory
(
video_encoder_factory
)
;
}
}
;
}
cricket
:
:
MediaEngineInterface
*
CreateWebRtcMediaEngine
(
webrtc
:
:
AudioDeviceModule
*
adm
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDecoderFactory
>
&
audio_decoder_factory
cricket
:
:
WebRtcVideoEncoderFactory
*
video_encoder_factory
cricket
:
:
WebRtcVideoDecoderFactory
*
video_decoder_factory
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioMixer
>
audio_mixer
)
{
return
new
cricket
:
:
WebRtcMediaEngine2
(
adm
audio_decoder_factory
video_encoder_factory
video_decoder_factory
audio_mixer
)
;
}
void
DestroyWebRtcMediaEngine
(
cricket
:
:
MediaEngineInterface
*
media_engine
)
{
delete
media_engine
;
}
namespace
cricket
{
MediaEngineInterface
*
WebRtcMediaEngineFactory
:
:
Create
(
webrtc
:
:
AudioDeviceModule
*
adm
WebRtcVideoEncoderFactory
*
video_encoder_factory
WebRtcVideoDecoderFactory
*
video_decoder_factory
)
{
return
CreateWebRtcMediaEngine
(
adm
webrtc
:
:
CreateBuiltinAudioDecoderFactory
(
)
video_encoder_factory
video_decoder_factory
nullptr
)
;
}
MediaEngineInterface
*
WebRtcMediaEngineFactory
:
:
Create
(
webrtc
:
:
AudioDeviceModule
*
adm
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDecoderFactory
>
&
audio_decoder_factory
WebRtcVideoEncoderFactory
*
video_encoder_factory
WebRtcVideoDecoderFactory
*
video_decoder_factory
)
{
return
CreateWebRtcMediaEngine
(
adm
audio_decoder_factory
video_encoder_factory
video_decoder_factory
nullptr
)
;
}
MediaEngineInterface
*
WebRtcMediaEngineFactory
:
:
Create
(
webrtc
:
:
AudioDeviceModule
*
adm
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDecoderFactory
>
&
audio_decoder_factory
WebRtcVideoEncoderFactory
*
video_encoder_factory
WebRtcVideoDecoderFactory
*
video_decoder_factory
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioMixer
>
audio_mixer
)
{
return
CreateWebRtcMediaEngine
(
adm
audio_decoder_factory
video_encoder_factory
video_decoder_factory
audio_mixer
)
;
}
namespace
{
void
DiscardRedundantExtensions
(
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
*
extensions
rtc
:
:
ArrayView
<
const
char
*
>
extensions_decreasing_prio
)
{
RTC_DCHECK
(
extensions
)
;
bool
found
=
false
;
for
(
const
char
*
uri
:
extensions_decreasing_prio
)
{
auto
it
=
std
:
:
find_if
(
extensions
-
>
begin
(
)
extensions
-
>
end
(
)
[
uri
]
(
const
webrtc
:
:
RtpExtension
&
rhs
)
{
return
rhs
.
uri
=
=
uri
;
}
)
;
if
(
it
!
=
extensions
-
>
end
(
)
)
{
if
(
found
)
{
extensions
-
>
erase
(
it
)
;
}
found
=
true
;
}
}
}
}
bool
ValidateRtpExtensions
(
const
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
&
extensions
)
{
bool
id_used
[
14
]
=
{
false
}
;
for
(
const
auto
&
extension
:
extensions
)
{
if
(
extension
.
id
<
=
0
|
|
extension
.
id
>
=
15
)
{
LOG
(
LS_ERROR
)
<
<
"
Bad
RTP
extension
ID
:
"
<
<
extension
.
ToString
(
)
;
return
false
;
}
if
(
id_used
[
extension
.
id
-
1
]
)
{
LOG
(
LS_ERROR
)
<
<
"
Duplicate
RTP
extension
ID
:
"
<
<
extension
.
ToString
(
)
;
return
false
;
}
id_used
[
extension
.
id
-
1
]
=
true
;
}
return
true
;
}
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
FilterRtpExtensions
(
const
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
&
extensions
bool
(
*
supported
)
(
const
std
:
:
string
&
)
bool
filter_redundant_extensions
)
{
RTC_DCHECK
(
ValidateRtpExtensions
(
extensions
)
)
;
RTC_DCHECK
(
supported
)
;
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
result
;
for
(
const
auto
&
extension
:
extensions
)
{
if
(
supported
(
extension
.
uri
)
)
{
result
.
push_back
(
extension
)
;
}
else
{
LOG
(
LS_WARNING
)
<
<
"
Unsupported
RTP
extension
:
"
<
<
extension
.
ToString
(
)
;
}
}
std
:
:
sort
(
result
.
begin
(
)
result
.
end
(
)
[
]
(
const
webrtc
:
:
RtpExtension
&
rhs
const
webrtc
:
:
RtpExtension
&
lhs
)
{
return
rhs
.
uri
<
lhs
.
uri
;
}
)
;
if
(
filter_redundant_extensions
)
{
auto
it
=
std
:
:
unique
(
result
.
begin
(
)
result
.
end
(
)
[
]
(
const
webrtc
:
:
RtpExtension
&
rhs
const
webrtc
:
:
RtpExtension
&
lhs
)
{
return
rhs
.
uri
=
=
lhs
.
uri
;
}
)
;
result
.
erase
(
it
result
.
end
(
)
)
;
static
const
char
*
kBweExtensionPriorities
[
]
=
{
webrtc
:
:
RtpExtension
:
:
kTransportSequenceNumberUri
webrtc
:
:
RtpExtension
:
:
kAbsSendTimeUri
webrtc
:
:
RtpExtension
:
:
kTimestampOffsetUri
}
;
DiscardRedundantExtensions
(
&
result
kBweExtensionPriorities
)
;
}
return
result
;
}
webrtc
:
:
Call
:
:
Config
:
:
BitrateConfig
GetBitrateConfigForCodec
(
const
Codec
&
codec
)
{
webrtc
:
:
Call
:
:
Config
:
:
BitrateConfig
config
;
int
bitrate_kbps
=
0
;
if
(
codec
.
GetParam
(
kCodecParamMinBitrate
&
bitrate_kbps
)
&
&
bitrate_kbps
>
0
)
{
config
.
min_bitrate_bps
=
bitrate_kbps
*
1000
;
}
else
{
config
.
min_bitrate_bps
=
0
;
}
if
(
codec
.
GetParam
(
kCodecParamStartBitrate
&
bitrate_kbps
)
&
&
bitrate_kbps
>
0
)
{
config
.
start_bitrate_bps
=
bitrate_kbps
*
1000
;
}
else
{
config
.
start_bitrate_bps
=
-
1
;
}
if
(
codec
.
GetParam
(
kCodecParamMaxBitrate
&
bitrate_kbps
)
&
&
bitrate_kbps
>
0
)
{
config
.
max_bitrate_bps
=
bitrate_kbps
*
1000
;
}
else
{
config
.
max_bitrate_bps
=
-
1
;
}
return
config
;
}
}
