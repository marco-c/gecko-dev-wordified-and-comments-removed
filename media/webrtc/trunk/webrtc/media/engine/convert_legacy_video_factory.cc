#
include
"
media
/
engine
/
convert_legacy_video_factory
.
h
"
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
video_codecs
/
video_decoder_factory
.
h
"
#
include
"
api
/
video_codecs
/
video_encoder_factory
.
h
"
#
include
"
media
/
base
/
h264_profile_level_id
.
h
"
#
include
"
media
/
engine
/
encoder_simulcast_proxy
.
h
"
#
include
"
media
/
engine
/
internaldecoderfactory
.
h
"
#
include
"
media
/
engine
/
internalencoderfactory
.
h
"
#
include
"
media
/
engine
/
scopedvideodecoder
.
h
"
#
include
"
media
/
engine
/
scopedvideoencoder
.
h
"
#
include
"
media
/
engine
/
simulcast_encoder_adapter
.
h
"
#
include
"
media
/
engine
/
videodecodersoftwarefallbackwrapper
.
h
"
#
include
"
media
/
engine
/
videoencodersoftwarefallbackwrapper
.
h
"
#
include
"
media
/
engine
/
webrtcvideodecoderfactory
.
h
"
#
include
"
media
/
engine
/
webrtcvideoencoderfactory
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
ptr_util
.
h
"
namespace
cricket
{
namespace
{
bool
IsFormatSupported
(
const
std
:
:
vector
<
webrtc
:
:
SdpVideoFormat
>
&
supported_formats
const
webrtc
:
:
SdpVideoFormat
&
format
)
{
for
(
const
webrtc
:
:
SdpVideoFormat
&
supported_format
:
supported_formats
)
{
if
(
IsSameCodec
(
format
.
name
format
.
parameters
supported_format
.
name
supported_format
.
parameters
)
)
{
return
true
;
}
}
return
false
;
}
class
CricketToWebRtcEncoderFactory
:
public
webrtc
:
:
VideoEncoderFactory
{
public
:
explicit
CricketToWebRtcEncoderFactory
(
std
:
:
unique_ptr
<
WebRtcVideoEncoderFactory
>
external_encoder_factory
)
:
external_encoder_factory_
(
std
:
:
move
(
external_encoder_factory
)
)
{
}
webrtc
:
:
VideoEncoderFactory
:
:
CodecInfo
QueryVideoEncoder
(
const
webrtc
:
:
SdpVideoFormat
&
format
)
const
override
{
CodecInfo
info
;
info
.
has_internal_source
=
false
;
info
.
is_hardware_accelerated
=
false
;
if
(
!
external_encoder_factory_
)
return
info
;
info
.
has_internal_source
=
external_encoder_factory_
-
>
EncoderTypeHasInternalSource
(
webrtc
:
:
PayloadStringToCodecType
(
format
.
name
)
)
;
info
.
is_hardware_accelerated
=
true
;
return
info
;
}
std
:
:
vector
<
webrtc
:
:
SdpVideoFormat
>
GetSupportedFormats
(
)
const
override
{
if
(
!
external_encoder_factory_
)
return
std
:
:
vector
<
webrtc
:
:
SdpVideoFormat
>
(
)
;
std
:
:
vector
<
webrtc
:
:
SdpVideoFormat
>
formats
;
for
(
const
VideoCodec
&
codec
:
external_encoder_factory_
-
>
supported_codecs
(
)
)
{
formats
.
push_back
(
webrtc
:
:
SdpVideoFormat
(
codec
.
name
codec
.
params
)
)
;
}
return
formats
;
}
std
:
:
unique_ptr
<
webrtc
:
:
VideoEncoder
>
CreateVideoEncoder
(
const
webrtc
:
:
SdpVideoFormat
&
format
)
override
{
return
CreateScopedVideoEncoder
(
external_encoder_factory_
.
get
(
)
VideoCodec
(
format
)
)
;
}
private
:
const
std
:
:
unique_ptr
<
WebRtcVideoEncoderFactory
>
external_encoder_factory_
;
}
;
class
EncoderAdapter
:
public
webrtc
:
:
VideoEncoderFactory
{
public
:
explicit
EncoderAdapter
(
std
:
:
unique_ptr
<
WebRtcVideoEncoderFactory
>
external_encoder_factory
)
:
internal_encoder_factory_
(
new
webrtc
:
:
InternalEncoderFactory
(
)
)
external_encoder_factory_
(
rtc
:
:
MakeUnique
<
CricketToWebRtcEncoderFactory
>
(
std
:
:
move
(
external_encoder_factory
)
)
)
{
}
webrtc
:
:
VideoEncoderFactory
:
:
CodecInfo
QueryVideoEncoder
(
const
webrtc
:
:
SdpVideoFormat
&
format
)
const
override
{
if
(
IsFormatSupported
(
external_encoder_factory_
-
>
GetSupportedFormats
(
)
format
)
)
{
return
external_encoder_factory_
-
>
QueryVideoEncoder
(
format
)
;
}
RTC_DCHECK
(
IsFormatSupported
(
internal_encoder_factory_
-
>
GetSupportedFormats
(
)
format
)
)
;
webrtc
:
:
VideoEncoderFactory
:
:
CodecInfo
info
;
info
.
has_internal_source
=
false
;
info
.
is_hardware_accelerated
=
false
;
return
info
;
}
std
:
:
unique_ptr
<
webrtc
:
:
VideoEncoder
>
CreateVideoEncoder
(
const
webrtc
:
:
SdpVideoFormat
&
format
)
override
{
std
:
:
unique_ptr
<
webrtc
:
:
VideoEncoder
>
internal_encoder
;
if
(
IsFormatSupported
(
internal_encoder_factory_
-
>
GetSupportedFormats
(
)
format
)
)
{
internal_encoder
=
rtc
:
:
MakeUnique
<
webrtc
:
:
EncoderSimulcastProxy
>
(
internal_encoder_factory_
.
get
(
)
format
)
;
}
std
:
:
unique_ptr
<
webrtc
:
:
VideoEncoder
>
external_encoder
;
if
(
IsFormatSupported
(
external_encoder_factory_
-
>
GetSupportedFormats
(
)
format
)
)
{
external_encoder
=
rtc
:
:
MakeUnique
<
webrtc
:
:
EncoderSimulcastProxy
>
(
internal_encoder_factory_
.
get
(
)
format
)
;
}
if
(
internal_encoder
&
&
external_encoder
)
{
return
rtc
:
:
MakeUnique
<
webrtc
:
:
VideoEncoderSoftwareFallbackWrapper
>
(
std
:
:
move
(
internal_encoder
)
std
:
:
move
(
external_encoder
)
)
;
}
return
external_encoder
?
std
:
:
move
(
external_encoder
)
:
std
:
:
move
(
internal_encoder
)
;
}
std
:
:
vector
<
webrtc
:
:
SdpVideoFormat
>
GetSupportedFormats
(
)
const
override
{
std
:
:
vector
<
webrtc
:
:
SdpVideoFormat
>
formats
=
internal_encoder_factory_
-
>
GetSupportedFormats
(
)
;
for
(
const
webrtc
:
:
SdpVideoFormat
&
format
:
external_encoder_factory_
-
>
GetSupportedFormats
(
)
)
{
if
(
!
IsFormatSupported
(
formats
format
)
)
formats
.
push_back
(
format
)
;
}
return
formats
;
}
private
:
const
std
:
:
unique_ptr
<
webrtc
:
:
VideoEncoderFactory
>
internal_encoder_factory_
;
const
std
:
:
unique_ptr
<
webrtc
:
:
VideoEncoderFactory
>
external_encoder_factory_
;
}
;
class
DecoderAdapter
:
public
webrtc
:
:
VideoDecoderFactory
{
public
:
explicit
DecoderAdapter
(
std
:
:
unique_ptr
<
WebRtcVideoDecoderFactory
>
external_decoder_factory
)
:
external_decoder_factory_
(
std
:
:
move
(
external_decoder_factory
)
)
{
}
std
:
:
unique_ptr
<
webrtc
:
:
VideoDecoder
>
CreateVideoDecoder
(
const
webrtc
:
:
SdpVideoFormat
&
format
)
override
{
std
:
:
unique_ptr
<
webrtc
:
:
VideoDecoder
>
internal_decoder
;
webrtc
:
:
InternalDecoderFactory
internal_decoder_factory
;
if
(
IsFormatSupported
(
internal_decoder_factory
.
GetSupportedFormats
(
)
format
)
)
{
internal_decoder
=
internal_decoder_factory
.
CreateVideoDecoder
(
format
)
;
}
const
VideoCodec
codec
(
format
)
;
const
VideoDecoderParams
params
=
{
}
;
if
(
external_decoder_factory_
!
=
nullptr
)
{
std
:
:
unique_ptr
<
webrtc
:
:
VideoDecoder
>
external_decoder
=
CreateScopedVideoDecoder
(
external_decoder_factory_
.
get
(
)
codec
params
)
;
if
(
external_decoder
)
{
if
(
!
internal_decoder
)
return
external_decoder
;
return
std
:
:
unique_ptr
<
webrtc
:
:
VideoDecoder
>
(
new
webrtc
:
:
VideoDecoderSoftwareFallbackWrapper
(
std
:
:
move
(
internal_decoder
)
std
:
:
move
(
external_decoder
)
)
)
;
}
}
return
internal_decoder
;
}
std
:
:
vector
<
webrtc
:
:
SdpVideoFormat
>
GetSupportedFormats
(
)
const
override
{
RTC_NOTREACHED
(
)
;
return
std
:
:
vector
<
webrtc
:
:
SdpVideoFormat
>
(
)
;
}
private
:
const
std
:
:
unique_ptr
<
WebRtcVideoDecoderFactory
>
external_decoder_factory_
;
}
;
}
std
:
:
unique_ptr
<
webrtc
:
:
VideoEncoderFactory
>
ConvertVideoEncoderFactory
(
std
:
:
unique_ptr
<
WebRtcVideoEncoderFactory
>
external_encoder_factory
)
{
return
std
:
:
unique_ptr
<
webrtc
:
:
VideoEncoderFactory
>
(
new
EncoderAdapter
(
std
:
:
move
(
external_encoder_factory
)
)
)
;
}
std
:
:
unique_ptr
<
webrtc
:
:
VideoDecoderFactory
>
ConvertVideoDecoderFactory
(
std
:
:
unique_ptr
<
WebRtcVideoDecoderFactory
>
external_decoder_factory
)
{
return
std
:
:
unique_ptr
<
webrtc
:
:
VideoDecoderFactory
>
(
new
DecoderAdapter
(
std
:
:
move
(
external_decoder_factory
)
)
)
;
}
}
