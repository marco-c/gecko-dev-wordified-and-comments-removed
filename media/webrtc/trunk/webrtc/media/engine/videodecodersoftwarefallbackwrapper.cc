#
include
"
webrtc
/
media
/
engine
/
videodecodersoftwarefallbackwrapper
.
h
"
#
include
<
string
>
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
media
/
engine
/
internaldecoderfactory
.
h
"
#
include
"
webrtc
/
modules
/
video_coding
/
include
/
video_error_codes
.
h
"
namespace
webrtc
{
VideoDecoderSoftwareFallbackWrapper
:
:
VideoDecoderSoftwareFallbackWrapper
(
VideoCodecType
codec_type
VideoDecoder
*
decoder
)
:
codec_type_
(
codec_type
)
decoder_
(
decoder
)
callback_
(
nullptr
)
{
}
int32_t
VideoDecoderSoftwareFallbackWrapper
:
:
InitDecode
(
const
VideoCodec
*
codec_settings
int32_t
number_of_cores
)
{
codec_settings_
=
*
codec_settings
;
number_of_cores_
=
number_of_cores
;
return
decoder_
-
>
InitDecode
(
codec_settings
number_of_cores
)
;
}
bool
VideoDecoderSoftwareFallbackWrapper
:
:
InitFallbackDecoder
(
)
{
RTC_CHECK
(
codec_type_
!
=
kVideoCodecUnknown
)
<
<
"
Decoder
requesting
fallback
to
codec
not
supported
in
software
.
"
;
LOG
(
LS_WARNING
)
<
<
"
Decoder
falling
back
to
software
decoding
.
"
;
cricket
:
:
InternalDecoderFactory
internal_decoder_factory
;
fallback_decoder_
.
reset
(
internal_decoder_factory
.
CreateVideoDecoder
(
codec_type_
)
)
;
if
(
fallback_decoder_
-
>
InitDecode
(
&
codec_settings_
number_of_cores_
)
!
=
WEBRTC_VIDEO_CODEC_OK
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
initialize
software
-
decoder
fallback
.
"
;
fallback_decoder_
.
reset
(
)
;
return
false
;
}
if
(
callback_
)
fallback_decoder_
-
>
RegisterDecodeCompleteCallback
(
callback_
)
;
fallback_implementation_name_
=
std
:
:
string
(
fallback_decoder_
-
>
ImplementationName
(
)
)
+
"
(
fallback
from
:
"
+
decoder_
-
>
ImplementationName
(
)
+
"
)
"
;
return
true
;
}
int32_t
VideoDecoderSoftwareFallbackWrapper
:
:
Decode
(
const
EncodedImage
&
input_image
bool
missing_frames
const
RTPFragmentationHeader
*
fragmentation
const
CodecSpecificInfo
*
codec_specific_info
int64_t
render_time_ms
)
{
if
(
!
fallback_decoder_
|
|
input_image
.
_frameType
=
=
kVideoFrameKey
)
{
int32_t
ret
=
decoder_
-
>
Decode
(
input_image
missing_frames
fragmentation
codec_specific_info
render_time_ms
)
;
if
(
ret
=
=
WEBRTC_VIDEO_CODEC_OK
)
{
if
(
fallback_decoder_
)
{
fallback_decoder_
-
>
Release
(
)
;
fallback_decoder_
.
reset
(
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
}
if
(
ret
!
=
WEBRTC_VIDEO_CODEC_FALLBACK_SOFTWARE
)
return
ret
;
if
(
!
fallback_decoder_
)
{
if
(
!
InitFallbackDecoder
(
)
)
return
ret
;
}
}
return
fallback_decoder_
-
>
Decode
(
input_image
missing_frames
fragmentation
codec_specific_info
render_time_ms
)
;
}
int32_t
VideoDecoderSoftwareFallbackWrapper
:
:
RegisterDecodeCompleteCallback
(
DecodedImageCallback
*
callback
)
{
callback_
=
callback
;
int32_t
ret
=
decoder_
-
>
RegisterDecodeCompleteCallback
(
callback
)
;
if
(
fallback_decoder_
)
return
fallback_decoder_
-
>
RegisterDecodeCompleteCallback
(
callback
)
;
return
ret
;
}
int32_t
VideoDecoderSoftwareFallbackWrapper
:
:
Release
(
)
{
if
(
fallback_decoder_
)
fallback_decoder_
-
>
Release
(
)
;
return
decoder_
-
>
Release
(
)
;
}
bool
VideoDecoderSoftwareFallbackWrapper
:
:
PrefersLateDecoding
(
)
const
{
if
(
fallback_decoder_
)
return
fallback_decoder_
-
>
PrefersLateDecoding
(
)
;
return
decoder_
-
>
PrefersLateDecoding
(
)
;
}
const
char
*
VideoDecoderSoftwareFallbackWrapper
:
:
ImplementationName
(
)
const
{
if
(
fallback_decoder_
)
return
fallback_implementation_name_
.
c_str
(
)
;
return
decoder_
-
>
ImplementationName
(
)
;
}
}
