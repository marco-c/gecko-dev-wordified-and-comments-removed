#
ifdef
HAVE_WEBRTC_VOICE
#
include
"
webrtc
/
media
/
engine
/
webrtcvoiceengine
.
h
"
#
include
<
algorithm
>
#
include
<
cstdio
>
#
include
<
functional
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
api
/
call
/
audio_sink
.
h
"
#
include
"
webrtc
/
base
/
arraysize
.
h
"
#
include
"
webrtc
/
base
/
base64
.
h
"
#
include
"
webrtc
/
base
/
byteorder
.
h
"
#
include
"
webrtc
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
#
include
"
webrtc
/
base
/
helpers
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
base
/
race_checker
.
h
"
#
include
"
webrtc
/
base
/
stringencode
.
h
"
#
include
"
webrtc
/
base
/
stringutils
.
h
"
#
include
"
webrtc
/
base
/
trace_event
.
h
"
#
include
"
webrtc
/
media
/
base
/
audiosource
.
h
"
#
include
"
webrtc
/
media
/
base
/
mediaconstants
.
h
"
#
include
"
webrtc
/
media
/
base
/
streamparams
.
h
"
#
include
"
webrtc
/
media
/
engine
/
payload_type_mapper
.
h
"
#
include
"
webrtc
/
media
/
engine
/
webrtcmediaengine
.
h
"
#
include
"
webrtc
/
media
/
engine
/
webrtcvoe
.
h
"
#
include
"
webrtc
/
modules
/
audio_coding
/
acm2
/
rent_a_codec
.
h
"
#
include
"
webrtc
/
modules
/
audio_mixer
/
audio_mixer_impl
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
field_trial
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
trace
.
h
"
namespace
cricket
{
namespace
{
const
int
kDefaultTraceFilter
=
webrtc
:
:
kTraceNone
|
webrtc
:
:
kTraceTerseInfo
|
webrtc
:
:
kTraceWarning
|
webrtc
:
:
kTraceError
|
webrtc
:
:
kTraceCritical
;
const
int
kElevatedTraceFilter
=
kDefaultTraceFilter
|
webrtc
:
:
kTraceStateInfo
|
webrtc
:
:
kTraceInfo
;
#
ifdef
WIN32
const
int
kDefaultAudioDeviceId
=
-
1
;
#
elif
!
defined
(
WEBRTC_IOS
)
const
int
kDefaultAudioDeviceId
=
0
;
#
endif
constexpr
int
kNackRtpHistoryMs
=
5000
;
#
if
!
defined
(
WEBRTC_INTELLIGIBILITY_ENHANCER
)
|
|
\
(
WEBRTC_INTELLIGIBILITY_ENHANCER
!
=
0
&
&
\
WEBRTC_INTELLIGIBILITY_ENHANCER
!
=
1
)
#
error
"
Set
WEBRTC_INTELLIGIBILITY_ENHANCER
to
either
0
or
1
"
#
endif
const
int
kOpusBitrateNbBps
=
12000
;
const
int
kOpusBitrateWbBps
=
20000
;
const
int
kOpusBitrateFbBps
=
32000
;
const
int
kOpusMinBitrateBps
=
6000
;
const
int
kOpusMaxBitrateBps
=
510000
;
const
int
kIsacMaxBitrateBps
=
56000
;
const
rtc
:
:
DiffServCodePoint
kAudioDscpValue
=
rtc
:
:
DSCP_EF
;
const
int
kMinTelephoneEventCode
=
0
;
const
int
kMaxTelephoneEventCode
=
255
;
const
int
kMinTelephoneEventDuration
=
100
;
const
int
kMaxTelephoneEventDuration
=
60000
;
const
int
kMinPayloadType
=
0
;
const
int
kMaxPayloadType
=
127
;
class
ProxySink
:
public
webrtc
:
:
AudioSinkInterface
{
public
:
ProxySink
(
AudioSinkInterface
*
sink
)
:
sink_
(
sink
)
{
RTC_DCHECK
(
sink
)
;
}
void
OnData
(
const
Data
&
audio
)
override
{
sink_
-
>
OnData
(
audio
)
;
}
private
:
webrtc
:
:
AudioSinkInterface
*
sink_
;
}
;
bool
ValidateStreamParams
(
const
StreamParams
&
sp
)
{
if
(
sp
.
ssrcs
.
empty
(
)
)
{
LOG
(
LS_ERROR
)
<
<
"
No
SSRCs
in
stream
parameters
:
"
<
<
sp
.
ToString
(
)
;
return
false
;
}
if
(
sp
.
ssrcs
.
size
(
)
>
1
)
{
LOG
(
LS_ERROR
)
<
<
"
Multiple
SSRCs
in
stream
parameters
:
"
<
<
sp
.
ToString
(
)
;
return
false
;
}
return
true
;
}
std
:
:
string
ToString
(
const
AudioCodec
&
codec
)
{
std
:
:
stringstream
ss
;
ss
<
<
codec
.
name
<
<
"
/
"
<
<
codec
.
clockrate
<
<
"
/
"
<
<
codec
.
channels
<
<
"
(
"
<
<
codec
.
id
<
<
"
)
"
;
return
ss
.
str
(
)
;
}
std
:
:
string
ToString
(
const
webrtc
:
:
CodecInst
&
codec
)
{
std
:
:
stringstream
ss
;
ss
<
<
codec
.
plname
<
<
"
/
"
<
<
codec
.
plfreq
<
<
"
/
"
<
<
codec
.
channels
<
<
"
(
"
<
<
codec
.
pltype
<
<
"
)
"
;
return
ss
.
str
(
)
;
}
bool
IsCodec
(
const
AudioCodec
&
codec
const
char
*
ref_name
)
{
return
(
_stricmp
(
codec
.
name
.
c_str
(
)
ref_name
)
=
=
0
)
;
}
bool
IsCodec
(
const
webrtc
:
:
CodecInst
&
codec
const
char
*
ref_name
)
{
return
(
_stricmp
(
codec
.
plname
ref_name
)
=
=
0
)
;
}
bool
FindCodec
(
const
std
:
:
vector
<
AudioCodec
>
&
codecs
const
AudioCodec
&
codec
AudioCodec
*
found_codec
)
{
for
(
const
AudioCodec
&
c
:
codecs
)
{
if
(
c
.
Matches
(
codec
)
)
{
if
(
found_codec
!
=
NULL
)
{
*
found_codec
=
c
;
}
return
true
;
}
}
return
false
;
}
bool
VerifyUniquePayloadTypes
(
const
std
:
:
vector
<
AudioCodec
>
&
codecs
)
{
if
(
codecs
.
empty
(
)
)
{
return
true
;
}
std
:
:
vector
<
int
>
payload_types
;
for
(
const
AudioCodec
&
codec
:
codecs
)
{
payload_types
.
push_back
(
codec
.
id
)
;
}
std
:
:
sort
(
payload_types
.
begin
(
)
payload_types
.
end
(
)
)
;
auto
it
=
std
:
:
unique
(
payload_types
.
begin
(
)
payload_types
.
end
(
)
)
;
return
it
=
=
payload_types
.
end
(
)
;
}
bool
IsCodecFeatureEnabled
(
const
AudioCodec
&
codec
const
char
*
feature
)
{
int
value
;
return
codec
.
GetParam
(
feature
&
value
)
&
&
value
=
=
1
;
}
rtc
:
:
Optional
<
std
:
:
string
>
GetAudioNetworkAdaptorConfig
(
const
AudioOptions
&
options
)
{
if
(
options
.
audio_network_adaptor
&
&
*
options
.
audio_network_adaptor
&
&
options
.
audio_network_adaptor_config
)
{
return
options
.
audio_network_adaptor_config
;
}
return
rtc
:
:
Optional
<
std
:
:
string
>
(
)
;
}
int
GetCodecFeatureInt
(
const
AudioCodec
&
codec
const
char
*
feature
int
default_value
)
{
int
value
=
0
;
if
(
codec
.
GetParam
(
feature
&
value
)
)
{
return
value
;
}
return
default_value
;
}
int
GetOpusBitrate
(
const
AudioCodec
&
codec
int
max_playback_rate
)
{
int
bitrate
=
0
;
bool
use_param
=
true
;
if
(
!
codec
.
GetParam
(
kCodecParamMaxAverageBitrate
&
bitrate
)
)
{
bitrate
=
codec
.
bitrate
;
use_param
=
false
;
}
if
(
bitrate
<
=
0
)
{
if
(
max_playback_rate
<
=
8000
)
{
bitrate
=
kOpusBitrateNbBps
;
}
else
if
(
max_playback_rate
<
=
16000
)
{
bitrate
=
kOpusBitrateWbBps
;
}
else
{
bitrate
=
kOpusBitrateFbBps
;
}
if
(
IsCodecFeatureEnabled
(
codec
kCodecParamStereo
)
)
{
bitrate
*
=
2
;
}
}
else
if
(
bitrate
<
kOpusMinBitrateBps
|
|
bitrate
>
kOpusMaxBitrateBps
)
{
bitrate
=
(
bitrate
<
kOpusMinBitrateBps
)
?
kOpusMinBitrateBps
:
kOpusMaxBitrateBps
;
std
:
:
string
rate_source
=
use_param
?
"
Codec
parameter
\
"
maxaveragebitrate
\
"
"
:
"
Supplied
Opus
bitrate
"
;
LOG
(
LS_WARNING
)
<
<
rate_source
<
<
"
is
invalid
and
is
replaced
by
:
"
<
<
bitrate
;
}
return
bitrate
;
}
void
GetOpusConfig
(
const
AudioCodec
&
codec
webrtc
:
:
CodecInst
*
voe_codec
bool
*
enable_codec_fec
int
*
max_playback_rate
bool
*
enable_codec_dtx
int
*
min_ptime_ms
int
*
max_ptime_ms
)
{
*
enable_codec_fec
=
IsCodecFeatureEnabled
(
codec
kCodecParamUseInbandFec
)
;
*
enable_codec_dtx
=
IsCodecFeatureEnabled
(
codec
kCodecParamUseDtx
)
;
*
max_playback_rate
=
GetCodecFeatureInt
(
codec
kCodecParamMaxPlaybackRate
kOpusDefaultMaxPlaybackRate
)
;
*
max_ptime_ms
=
GetCodecFeatureInt
(
codec
kCodecParamMaxPTime
kOpusDefaultMaxPTime
)
;
*
min_ptime_ms
=
GetCodecFeatureInt
(
codec
kCodecParamMinPTime
kOpusDefaultMinPTime
)
;
if
(
*
max_ptime_ms
<
*
min_ptime_ms
)
{
*
max_ptime_ms
=
kOpusDefaultMaxPTime
;
*
min_ptime_ms
=
kOpusDefaultMinPTime
;
}
voe_codec
-
>
channels
=
IsCodecFeatureEnabled
(
codec
kCodecParamStereo
)
?
2
:
1
;
voe_codec
-
>
rate
=
GetOpusBitrate
(
codec
*
max_playback_rate
)
;
}
webrtc
:
:
AudioState
:
:
Config
MakeAudioStateConfig
(
VoEWrapper
*
voe_wrapper
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioMixer
>
audio_mixer
)
{
webrtc
:
:
AudioState
:
:
Config
config
;
config
.
voice_engine
=
voe_wrapper
-
>
engine
(
)
;
if
(
audio_mixer
)
{
config
.
audio_mixer
=
audio_mixer
;
}
else
{
config
.
audio_mixer
=
webrtc
:
:
AudioMixerImpl
:
:
Create
(
)
;
}
return
config
;
}
class
WebRtcVoiceCodecs
final
{
public
:
static
std
:
:
vector
<
AudioCodec
>
SupportedSendCodecs
(
)
{
std
:
:
vector
<
AudioCodec
>
result
;
for
(
size_t
i
=
0
;
i
<
arraysize
(
kCodecPrefs
)
;
+
+
i
)
{
const
CodecPref
*
pref
=
&
kCodecPrefs
[
i
]
;
for
(
webrtc
:
:
CodecInst
voe_codec
:
webrtc
:
:
acm2
:
:
RentACodec
:
:
Database
(
)
)
{
MaybeFixupG722
(
&
voe_codec
8000
)
;
if
(
IsCodec
(
voe_codec
kL16CodecName
)
)
{
continue
;
}
if
(
!
IsCodec
(
voe_codec
pref
-
>
name
)
|
|
pref
-
>
clockrate
!
=
voe_codec
.
plfreq
|
|
pref
-
>
channels
!
=
voe_codec
.
channels
)
{
continue
;
}
AudioCodec
codec
(
pref
-
>
payload_type
voe_codec
.
plname
voe_codec
.
plfreq
voe_codec
.
rate
voe_codec
.
channels
)
;
LOG
(
LS_INFO
)
<
<
"
Adding
supported
codec
:
"
<
<
ToString
(
codec
)
;
if
(
IsCodec
(
codec
kIsacCodecName
)
)
{
codec
.
bitrate
=
0
;
}
if
(
IsCodec
(
codec
kOpusCodecName
)
)
{
if
(
kPreferredMinPTime
!
=
kOpusDefaultMinPTime
)
{
codec
.
params
[
kCodecParamMinPTime
]
=
rtc
:
:
ToString
(
kPreferredMinPTime
)
;
}
if
(
kPreferredMaxPTime
!
=
kOpusDefaultMaxPTime
)
{
codec
.
params
[
kCodecParamMaxPTime
]
=
rtc
:
:
ToString
(
kPreferredMaxPTime
)
;
}
codec
.
SetParam
(
kCodecParamUseInbandFec
1
)
;
codec
.
AddFeedbackParam
(
FeedbackParam
(
kRtcpFbParamTransportCc
kParamValueEmpty
)
)
;
}
result
.
push_back
(
codec
)
;
}
}
return
result
;
}
static
bool
ToCodecInst
(
const
AudioCodec
&
in
webrtc
:
:
CodecInst
*
out
)
{
for
(
webrtc
:
:
CodecInst
voe_codec
:
webrtc
:
:
acm2
:
:
RentACodec
:
:
Database
(
)
)
{
MaybeFixupG722
(
&
voe_codec
8000
)
;
AudioCodec
codec
(
voe_codec
.
pltype
voe_codec
.
plname
voe_codec
.
plfreq
voe_codec
.
rate
voe_codec
.
channels
)
;
bool
multi_rate
=
IsCodecMultiRate
(
voe_codec
)
;
if
(
multi_rate
)
{
codec
.
bitrate
=
0
;
}
if
(
codec
.
Matches
(
in
)
)
{
if
(
out
)
{
voe_codec
.
pltype
=
in
.
id
;
if
(
multi_rate
&
&
in
.
bitrate
!
=
0
)
{
voe_codec
.
rate
=
in
.
bitrate
;
}
MaybeFixupG722
(
&
voe_codec
16000
)
;
if
(
IsCodec
(
codec
kIsacCodecName
)
)
{
voe_codec
.
rate
=
(
in
.
bitrate
>
0
)
?
in
.
bitrate
:
-
1
;
}
*
out
=
voe_codec
;
}
return
true
;
}
}
return
false
;
}
static
bool
IsCodecMultiRate
(
const
webrtc
:
:
CodecInst
&
codec
)
{
for
(
size_t
i
=
0
;
i
<
arraysize
(
kCodecPrefs
)
;
+
+
i
)
{
if
(
IsCodec
(
codec
kCodecPrefs
[
i
]
.
name
)
&
&
kCodecPrefs
[
i
]
.
clockrate
=
=
codec
.
plfreq
)
{
return
kCodecPrefs
[
i
]
.
is_multi_rate
;
}
}
return
false
;
}
static
int
MaxBitrateBps
(
const
webrtc
:
:
CodecInst
&
codec
)
{
for
(
size_t
i
=
0
;
i
<
arraysize
(
kCodecPrefs
)
;
+
+
i
)
{
if
(
IsCodec
(
codec
kCodecPrefs
[
i
]
.
name
)
&
&
kCodecPrefs
[
i
]
.
clockrate
=
=
codec
.
plfreq
)
{
return
kCodecPrefs
[
i
]
.
max_bitrate_bps
;
}
}
return
0
;
}
static
rtc
:
:
ArrayView
<
const
int
>
GetPacketSizesMs
(
const
webrtc
:
:
CodecInst
&
codec
)
{
for
(
size_t
i
=
0
;
i
<
arraysize
(
kCodecPrefs
)
;
+
+
i
)
{
if
(
IsCodec
(
codec
kCodecPrefs
[
i
]
.
name
)
)
{
size_t
num_packet_sizes
=
kMaxNumPacketSize
;
for
(
int
index
=
0
;
index
<
kMaxNumPacketSize
;
index
+
+
)
{
if
(
kCodecPrefs
[
i
]
.
packet_sizes_ms
[
index
]
=
=
0
)
{
num_packet_sizes
=
index
;
break
;
}
}
return
rtc
:
:
ArrayView
<
const
int
>
(
kCodecPrefs
[
i
]
.
packet_sizes_ms
num_packet_sizes
)
;
}
}
return
rtc
:
:
ArrayView
<
const
int
>
(
)
;
}
static
bool
SetPTimeAsPacketSize
(
webrtc
:
:
CodecInst
*
codec
int
ptime_ms
)
{
for
(
const
CodecPref
&
codec_pref
:
kCodecPrefs
)
{
if
(
(
IsCodec
(
*
codec
codec_pref
.
name
)
&
&
codec_pref
.
clockrate
=
=
codec
-
>
plfreq
)
|
|
IsCodec
(
*
codec
kG722CodecName
)
)
{
int
packet_size_ms
=
SelectPacketSize
(
codec_pref
ptime_ms
)
;
if
(
packet_size_ms
)
{
codec
-
>
pacsize
=
(
codec
-
>
plfreq
/
1000
)
*
packet_size_ms
;
return
true
;
}
}
}
return
false
;
}
static
const
AudioCodec
*
GetPreferredCodec
(
const
std
:
:
vector
<
AudioCodec
>
&
codecs
webrtc
:
:
CodecInst
*
out
)
{
RTC_DCHECK
(
out
)
;
for
(
const
AudioCodec
&
codec
:
codecs
)
{
if
(
IsCodec
(
codec
kDtmfCodecName
)
|
|
IsCodec
(
codec
kCnCodecName
)
)
{
continue
;
}
if
(
!
ToCodecInst
(
codec
out
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Unknown
codec
"
<
<
ToString
(
codec
)
;
continue
;
}
return
&
codec
;
}
return
nullptr
;
}
private
:
static
const
int
kMaxNumPacketSize
=
6
;
struct
CodecPref
{
const
char
*
name
;
int
clockrate
;
size_t
channels
;
int
payload_type
;
bool
is_multi_rate
;
int
packet_sizes_ms
[
kMaxNumPacketSize
]
;
int
max_bitrate_bps
;
}
;
static
const
CodecPref
kCodecPrefs
[
14
]
;
static
int
SelectPacketSize
(
const
CodecPref
&
codec_pref
int
ptime_ms
)
{
int
selected_packet_size_ms
=
codec_pref
.
packet_sizes_ms
[
0
]
;
for
(
int
packet_size_ms
:
codec_pref
.
packet_sizes_ms
)
{
if
(
packet_size_ms
&
&
packet_size_ms
<
=
ptime_ms
)
{
selected_packet_size_ms
=
packet_size_ms
;
}
}
return
selected_packet_size_ms
;
}
static
void
MaybeFixupG722
(
webrtc
:
:
CodecInst
*
voe_codec
int
new_plfreq
)
{
if
(
IsCodec
(
*
voe_codec
kG722CodecName
)
)
{
RTC_DCHECK
(
voe_codec
-
>
plfreq
!
=
new_plfreq
)
;
voe_codec
-
>
plfreq
=
new_plfreq
;
}
}
}
;
const
WebRtcVoiceCodecs
:
:
CodecPref
WebRtcVoiceCodecs
:
:
kCodecPrefs
[
14
]
=
{
{
kOpusCodecName
48000
2
111
true
{
10
20
40
60
}
kOpusMaxBitrateBps
}
{
kIsacCodecName
16000
1
103
true
{
30
60
}
kIsacMaxBitrateBps
}
{
kIsacCodecName
32000
1
104
true
{
30
}
kIsacMaxBitrateBps
}
{
kG722CodecName
8000
1
9
false
{
10
20
30
40
50
60
}
}
{
kIlbcCodecName
8000
1
102
false
{
20
30
40
60
}
}
{
kPcmuCodecName
8000
1
0
false
{
10
20
30
40
50
60
}
}
{
kPcmaCodecName
8000
1
8
false
{
10
20
30
40
50
60
}
}
{
kCnCodecName
32000
1
106
false
{
}
}
{
kCnCodecName
16000
1
105
false
{
}
}
{
kCnCodecName
8000
1
13
false
{
}
}
{
kDtmfCodecName
48000
1
110
false
{
}
}
{
kDtmfCodecName
32000
1
112
false
{
}
}
{
kDtmfCodecName
16000
1
113
false
{
}
}
{
kDtmfCodecName
8000
1
126
false
{
}
}
}
;
rtc
:
:
Optional
<
int
>
ComputeSendBitrate
(
int
max_send_bitrate_bps
int
rtp_max_bitrate_bps
const
webrtc
:
:
CodecInst
&
codec_inst
)
{
const
int
bps
=
MinPositive
(
max_send_bitrate_bps
rtp_max_bitrate_bps
)
;
const
int
codec_rate
=
codec_inst
.
rate
;
if
(
bps
<
=
0
)
{
return
rtc
:
:
Optional
<
int
>
(
codec_rate
)
;
}
if
(
codec_inst
.
pltype
=
=
-
1
)
{
return
rtc
:
:
Optional
<
int
>
(
codec_rate
)
;
;
}
if
(
WebRtcVoiceCodecs
:
:
IsCodecMultiRate
(
codec_inst
)
)
{
return
rtc
:
:
Optional
<
int
>
(
std
:
:
min
(
bps
WebRtcVoiceCodecs
:
:
MaxBitrateBps
(
codec_inst
)
)
)
;
}
if
(
bps
<
codec_inst
.
rate
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
set
codec
"
<
<
codec_inst
.
plname
<
<
"
to
bitrate
"
<
<
bps
<
<
"
bps
"
<
<
"
requires
at
least
"
<
<
codec_inst
.
rate
<
<
"
bps
.
"
;
return
rtc
:
:
Optional
<
int
>
(
)
;
}
return
rtc
:
:
Optional
<
int
>
(
codec_rate
)
;
}
}
bool
WebRtcVoiceEngine
:
:
ToCodecInst
(
const
AudioCodec
&
in
webrtc
:
:
CodecInst
*
out
)
{
return
WebRtcVoiceCodecs
:
:
ToCodecInst
(
in
out
)
;
}
WebRtcVoiceEngine
:
:
WebRtcVoiceEngine
(
webrtc
:
:
AudioDeviceModule
*
adm
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDecoderFactory
>
&
decoder_factory
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioMixer
>
audio_mixer
)
:
WebRtcVoiceEngine
(
adm
decoder_factory
audio_mixer
new
VoEWrapper
(
)
)
{
audio_state_
=
webrtc
:
:
AudioState
:
:
Create
(
MakeAudioStateConfig
(
voe
(
)
audio_mixer
)
)
;
}
WebRtcVoiceEngine
:
:
WebRtcVoiceEngine
(
webrtc
:
:
AudioDeviceModule
*
adm
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDecoderFactory
>
&
decoder_factory
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioMixer
>
audio_mixer
VoEWrapper
*
voe_wrapper
)
:
adm_
(
adm
)
decoder_factory_
(
decoder_factory
)
voe_wrapper_
(
voe_wrapper
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
WebRtcVoiceEngine
:
:
WebRtcVoiceEngine
"
;
RTC_DCHECK
(
voe_wrapper
)
;
RTC_DCHECK
(
decoder_factory
)
;
signal_thread_checker_
.
DetachFromThread
(
)
;
LOG
(
LS_INFO
)
<
<
"
Supported
send
codecs
in
order
of
preference
:
"
;
send_codecs_
=
WebRtcVoiceCodecs
:
:
SupportedSendCodecs
(
)
;
for
(
const
AudioCodec
&
codec
:
send_codecs_
)
{
LOG
(
LS_INFO
)
<
<
ToString
(
codec
)
;
}
LOG
(
LS_INFO
)
<
<
"
Supported
recv
codecs
in
order
of
preference
:
"
;
recv_codecs_
=
CollectRecvCodecs
(
)
;
for
(
const
AudioCodec
&
codec
:
recv_codecs_
)
{
LOG
(
LS_INFO
)
<
<
ToString
(
codec
)
;
}
channel_config_
.
enable_voice_pacing
=
true
;
webrtc
:
:
Trace
:
:
SetTraceCallback
(
this
)
;
webrtc
:
:
Trace
:
:
set_level_filter
(
kElevatedTraceFilter
)
;
LOG
(
LS_INFO
)
<
<
webrtc
:
:
VoiceEngine
:
:
GetVersionString
(
)
;
RTC_CHECK_EQ
(
0
voe_wrapper_
-
>
base
(
)
-
>
Init
(
adm_
.
get
(
)
nullptr
decoder_factory_
)
)
;
webrtc
:
:
Trace
:
:
set_level_filter
(
kDefaultTraceFilter
)
;
if
(
!
adm_
)
{
adm_
=
voe_wrapper_
-
>
base
(
)
-
>
audio_device_module
(
)
;
}
RTC_DCHECK
(
adm_
)
;
apm_
=
voe_wrapper_
-
>
base
(
)
-
>
audio_processing
(
)
;
RTC_DCHECK
(
apm_
)
;
int
error
=
voe_wrapper_
-
>
processing
(
)
-
>
GetAgcConfig
(
default_agc_config_
)
;
RTC_DCHECK_EQ
(
0
error
)
;
{
AudioOptions
options
;
options
.
echo_cancellation
=
rtc
:
:
Optional
<
bool
>
(
true
)
;
options
.
auto_gain_control
=
rtc
:
:
Optional
<
bool
>
(
true
)
;
options
.
noise_suppression
=
rtc
:
:
Optional
<
bool
>
(
true
)
;
options
.
highpass_filter
=
rtc
:
:
Optional
<
bool
>
(
true
)
;
options
.
stereo_swapping
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
audio_jitter_buffer_max_packets
=
rtc
:
:
Optional
<
int
>
(
50
)
;
options
.
audio_jitter_buffer_fast_accelerate
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
typing_detection
=
rtc
:
:
Optional
<
bool
>
(
true
)
;
options
.
adjust_agc_delta
=
rtc
:
:
Optional
<
int
>
(
0
)
;
options
.
experimental_agc
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
extended_filter_aec
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
delay_agnostic_aec
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
experimental_ns
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
intelligibility_enhancer
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
level_control
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
#
if
defined
(
WEBRTC_ANDROID
)
|
|
defined
(
WEBRTC_IOS
)
options
.
residual_echo_detector
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
#
else
options
.
residual_echo_detector
=
rtc
:
:
Optional
<
bool
>
(
true
)
;
#
endif
bool
error
=
ApplyOptions
(
options
)
;
RTC_DCHECK
(
error
)
;
}
SetDefaultDevices
(
)
;
}
WebRtcVoiceEngine
:
:
~
WebRtcVoiceEngine
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
WebRtcVoiceEngine
:
:
~
WebRtcVoiceEngine
"
;
StopAecDump
(
)
;
voe_wrapper_
-
>
base
(
)
-
>
Terminate
(
)
;
webrtc
:
:
Trace
:
:
SetTraceCallback
(
nullptr
)
;
}
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioState
>
WebRtcVoiceEngine
:
:
GetAudioState
(
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
audio_state_
;
}
VoiceMediaChannel
*
WebRtcVoiceEngine
:
:
CreateChannel
(
webrtc
:
:
Call
*
call
const
MediaConfig
&
config
const
AudioOptions
&
options
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
new
WebRtcVoiceMediaChannel
(
this
config
options
call
)
;
}
bool
WebRtcVoiceEngine
:
:
ApplyOptions
(
const
AudioOptions
&
options_in
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
WebRtcVoiceEngine
:
:
ApplyOptions
:
"
<
<
options_in
.
ToString
(
)
;
AudioOptions
options
=
options_in
;
webrtc
:
:
EcModes
ec_mode
=
webrtc
:
:
kEcConference
;
webrtc
:
:
AecmModes
aecm_mode
=
webrtc
:
:
kAecmSpeakerphone
;
webrtc
:
:
AgcModes
agc_mode
=
webrtc
:
:
kAgcAdaptiveAnalog
;
webrtc
:
:
NsModes
ns_mode
=
webrtc
:
:
kNsHighSuppression
;
if
(
options
.
aecm_generate_comfort_noise
)
{
LOG
(
LS_VERBOSE
)
<
<
"
Comfort
noise
explicitly
set
to
"
<
<
*
options
.
aecm_generate_comfort_noise
<
<
"
(
default
is
false
)
.
"
;
}
#
if
defined
(
WEBRTC_IOS
)
options
.
echo_cancellation
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
auto_gain_control
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
noise_suppression
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
LOG
(
LS_INFO
)
<
<
"
Always
disable
AEC
NS
and
AGC
on
iOS
.
Use
built
-
in
instead
.
"
;
#
elif
defined
(
ANDROID
)
ec_mode
=
webrtc
:
:
kEcAecm
;
#
endif
#
if
defined
(
WEBRTC_IOS
)
|
|
defined
(
ANDROID
)
agc_mode
=
webrtc
:
:
kAgcFixedDigital
;
options
.
typing_detection
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
experimental_agc
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
extended_filter_aec
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
experimental_ns
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
options
.
residual_echo_detector
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
#
endif
bool
use_delay_agnostic_aec
=
false
;
#
if
!
defined
(
WEBRTC_IOS
)
if
(
options
.
delay_agnostic_aec
)
{
use_delay_agnostic_aec
=
*
options
.
delay_agnostic_aec
;
if
(
use_delay_agnostic_aec
)
{
options
.
echo_cancellation
=
rtc
:
:
Optional
<
bool
>
(
true
)
;
options
.
extended_filter_aec
=
rtc
:
:
Optional
<
bool
>
(
true
)
;
ec_mode
=
webrtc
:
:
kEcConference
;
}
}
#
endif
#
if
(
WEBRTC_INTELLIGIBILITY_ENHANCER
=
=
0
)
options
.
intelligibility_enhancer
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
#
endif
webrtc
:
:
VoEAudioProcessing
*
voep
=
voe_wrapper_
-
>
processing
(
)
;
if
(
options
.
echo_cancellation
)
{
const
bool
built_in_aec
=
adm
(
)
-
>
BuiltInAECIsAvailable
(
)
;
if
(
built_in_aec
)
{
const
bool
enable_built_in_aec
=
*
options
.
echo_cancellation
&
&
!
use_delay_agnostic_aec
;
if
(
adm
(
)
-
>
EnableBuiltInAEC
(
enable_built_in_aec
)
=
=
0
&
&
enable_built_in_aec
)
{
options
.
echo_cancellation
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
LOG
(
LS_INFO
)
<
<
"
Disabling
EC
since
built
-
in
EC
will
be
used
instead
"
;
}
}
if
(
voep
-
>
SetEcStatus
(
*
options
.
echo_cancellation
ec_mode
)
=
=
-
1
)
{
LOG_RTCERR2
(
SetEcStatus
*
options
.
echo_cancellation
ec_mode
)
;
return
false
;
}
else
{
LOG
(
LS_INFO
)
<
<
"
Echo
control
set
to
"
<
<
*
options
.
echo_cancellation
<
<
"
with
mode
"
<
<
ec_mode
;
}
#
if
!
defined
(
ANDROID
)
if
(
voep
-
>
SetEcMetricsStatus
(
*
options
.
echo_cancellation
)
=
=
-
1
)
{
LOG_RTCERR1
(
SetEcMetricsStatus
*
options
.
echo_cancellation
)
;
return
false
;
}
#
endif
if
(
ec_mode
=
=
webrtc
:
:
kEcAecm
)
{
bool
cn
=
options
.
aecm_generate_comfort_noise
.
value_or
(
false
)
;
if
(
voep
-
>
SetAecmMode
(
aecm_mode
cn
)
!
=
0
)
{
LOG_RTCERR2
(
SetAecmMode
aecm_mode
cn
)
;
return
false
;
}
}
}
if
(
options
.
auto_gain_control
)
{
bool
built_in_agc_avaliable
=
adm
(
)
-
>
BuiltInAGCIsAvailable
(
)
;
if
(
built_in_agc_avaliable
)
{
if
(
adm
(
)
-
>
EnableBuiltInAGC
(
*
options
.
auto_gain_control
)
=
=
0
&
&
*
options
.
auto_gain_control
)
{
options
.
auto_gain_control
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
LOG
(
LS_INFO
)
<
<
"
Disabling
AGC
since
built
-
in
AGC
will
be
used
instead
"
;
}
}
if
(
voep
-
>
SetAgcStatus
(
*
options
.
auto_gain_control
agc_mode
)
=
=
-
1
)
{
LOG_RTCERR2
(
SetAgcStatus
*
options
.
auto_gain_control
agc_mode
)
;
return
false
;
}
else
{
LOG
(
LS_INFO
)
<
<
"
Auto
gain
set
to
"
<
<
*
options
.
auto_gain_control
<
<
"
with
mode
"
<
<
agc_mode
;
}
}
if
(
options
.
tx_agc_target_dbov
|
|
options
.
tx_agc_digital_compression_gain
|
|
options
.
tx_agc_limiter
)
{
default_agc_config_
.
targetLeveldBOv
=
options
.
tx_agc_target_dbov
.
value_or
(
default_agc_config_
.
targetLeveldBOv
)
;
default_agc_config_
.
digitalCompressionGaindB
=
options
.
tx_agc_digital_compression_gain
.
value_or
(
default_agc_config_
.
digitalCompressionGaindB
)
;
default_agc_config_
.
limiterEnable
=
options
.
tx_agc_limiter
.
value_or
(
default_agc_config_
.
limiterEnable
)
;
if
(
voe_wrapper_
-
>
processing
(
)
-
>
SetAgcConfig
(
default_agc_config_
)
=
=
-
1
)
{
LOG_RTCERR3
(
SetAgcConfig
default_agc_config_
.
targetLeveldBOv
default_agc_config_
.
digitalCompressionGaindB
default_agc_config_
.
limiterEnable
)
;
return
false
;
}
}
if
(
options
.
intelligibility_enhancer
)
{
intelligibility_enhancer_
=
options
.
intelligibility_enhancer
;
}
if
(
intelligibility_enhancer_
&
&
*
intelligibility_enhancer_
)
{
LOG
(
LS_INFO
)
<
<
"
Enabling
NS
when
Intelligibility
Enhancer
is
active
.
"
;
options
.
noise_suppression
=
intelligibility_enhancer_
;
}
if
(
options
.
noise_suppression
)
{
if
(
adm
(
)
-
>
BuiltInNSIsAvailable
(
)
)
{
bool
builtin_ns
=
*
options
.
noise_suppression
&
&
!
(
intelligibility_enhancer_
&
&
*
intelligibility_enhancer_
)
;
if
(
adm
(
)
-
>
EnableBuiltInNS
(
builtin_ns
)
=
=
0
&
&
builtin_ns
)
{
options
.
noise_suppression
=
rtc
:
:
Optional
<
bool
>
(
false
)
;
LOG
(
LS_INFO
)
<
<
"
Disabling
NS
since
built
-
in
NS
will
be
used
instead
"
;
}
}
if
(
voep
-
>
SetNsStatus
(
*
options
.
noise_suppression
ns_mode
)
=
=
-
1
)
{
LOG_RTCERR2
(
SetNsStatus
*
options
.
noise_suppression
ns_mode
)
;
return
false
;
}
else
{
LOG
(
LS_INFO
)
<
<
"
Noise
suppression
set
to
"
<
<
*
options
.
noise_suppression
<
<
"
with
mode
"
<
<
ns_mode
;
}
}
if
(
options
.
stereo_swapping
)
{
LOG
(
LS_INFO
)
<
<
"
Stereo
swapping
enabled
?
"
<
<
*
options
.
stereo_swapping
;
voep
-
>
EnableStereoChannelSwapping
(
*
options
.
stereo_swapping
)
;
if
(
voep
-
>
IsStereoChannelSwappingEnabled
(
)
!
=
*
options
.
stereo_swapping
)
{
LOG_RTCERR1
(
EnableStereoChannelSwapping
*
options
.
stereo_swapping
)
;
return
false
;
}
}
if
(
options
.
audio_jitter_buffer_max_packets
)
{
LOG
(
LS_INFO
)
<
<
"
NetEq
capacity
is
"
<
<
*
options
.
audio_jitter_buffer_max_packets
;
channel_config_
.
acm_config
.
neteq_config
.
max_packets_in_buffer
=
std
:
:
max
(
20
*
options
.
audio_jitter_buffer_max_packets
)
;
}
if
(
options
.
audio_jitter_buffer_fast_accelerate
)
{
LOG
(
LS_INFO
)
<
<
"
NetEq
fast
mode
?
"
<
<
*
options
.
audio_jitter_buffer_fast_accelerate
;
channel_config_
.
acm_config
.
neteq_config
.
enable_fast_accelerate
=
*
options
.
audio_jitter_buffer_fast_accelerate
;
}
if
(
options
.
typing_detection
)
{
LOG
(
LS_INFO
)
<
<
"
Typing
detection
is
enabled
?
"
<
<
*
options
.
typing_detection
;
if
(
voep
-
>
SetTypingDetectionStatus
(
*
options
.
typing_detection
)
=
=
-
1
)
{
LOG_RTCERR1
(
SetTypingDetectionStatus
*
options
.
typing_detection
)
;
}
}
if
(
options
.
adjust_agc_delta
)
{
LOG
(
LS_INFO
)
<
<
"
Adjust
agc
delta
is
"
<
<
*
options
.
adjust_agc_delta
;
if
(
!
AdjustAgcLevel
(
*
options
.
adjust_agc_delta
)
)
{
return
false
;
}
}
webrtc
:
:
Config
config
;
if
(
options
.
delay_agnostic_aec
)
delay_agnostic_aec_
=
options
.
delay_agnostic_aec
;
if
(
delay_agnostic_aec_
)
{
LOG
(
LS_INFO
)
<
<
"
Delay
agnostic
aec
is
enabled
?
"
<
<
*
delay_agnostic_aec_
;
config
.
Set
<
webrtc
:
:
DelayAgnostic
>
(
new
webrtc
:
:
DelayAgnostic
(
*
delay_agnostic_aec_
)
)
;
}
if
(
options
.
extended_filter_aec
)
{
extended_filter_aec_
=
options
.
extended_filter_aec
;
}
if
(
extended_filter_aec_
)
{
LOG
(
LS_INFO
)
<
<
"
Extended
filter
aec
is
enabled
?
"
<
<
*
extended_filter_aec_
;
config
.
Set
<
webrtc
:
:
ExtendedFilter
>
(
new
webrtc
:
:
ExtendedFilter
(
*
extended_filter_aec_
)
)
;
}
if
(
options
.
experimental_ns
)
{
experimental_ns_
=
options
.
experimental_ns
;
}
if
(
experimental_ns_
)
{
LOG
(
LS_INFO
)
<
<
"
Experimental
ns
is
enabled
?
"
<
<
*
experimental_ns_
;
config
.
Set
<
webrtc
:
:
ExperimentalNs
>
(
new
webrtc
:
:
ExperimentalNs
(
*
experimental_ns_
)
)
;
}
if
(
intelligibility_enhancer_
)
{
LOG
(
LS_INFO
)
<
<
"
Intelligibility
Enhancer
is
enabled
?
"
<
<
*
intelligibility_enhancer_
;
config
.
Set
<
webrtc
:
:
Intelligibility
>
(
new
webrtc
:
:
Intelligibility
(
*
intelligibility_enhancer_
)
)
;
}
if
(
options
.
level_control
)
{
level_control_
=
options
.
level_control
;
}
LOG
(
LS_INFO
)
<
<
"
Level
control
:
"
<
<
(
!
!
level_control_
?
*
level_control_
:
-
1
)
;
if
(
level_control_
)
{
apm_config_
.
level_controller
.
enabled
=
*
level_control_
;
if
(
options
.
level_control_initial_peak_level_dbfs
)
{
apm_config_
.
level_controller
.
initial_peak_level_dbfs
=
*
options
.
level_control_initial_peak_level_dbfs
;
}
}
if
(
options
.
highpass_filter
)
{
apm_config_
.
high_pass_filter
.
enabled
=
*
options
.
highpass_filter
;
}
apm
(
)
-
>
SetExtraOptions
(
config
)
;
apm
(
)
-
>
ApplyConfig
(
apm_config_
)
;
if
(
options
.
recording_sample_rate
)
{
LOG
(
LS_INFO
)
<
<
"
Recording
sample
rate
is
"
<
<
*
options
.
recording_sample_rate
;
if
(
adm
(
)
-
>
SetRecordingSampleRate
(
*
options
.
recording_sample_rate
)
)
{
LOG_RTCERR1
(
SetRecordingSampleRate
*
options
.
recording_sample_rate
)
;
}
}
if
(
options
.
playout_sample_rate
)
{
LOG
(
LS_INFO
)
<
<
"
Playout
sample
rate
is
"
<
<
*
options
.
playout_sample_rate
;
if
(
adm
(
)
-
>
SetPlayoutSampleRate
(
*
options
.
playout_sample_rate
)
)
{
LOG_RTCERR1
(
SetPlayoutSampleRate
*
options
.
playout_sample_rate
)
;
}
}
return
true
;
}
void
WebRtcVoiceEngine
:
:
SetDefaultDevices
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
#
if
!
defined
(
WEBRTC_IOS
)
int
in_id
=
kDefaultAudioDeviceId
;
int
out_id
=
kDefaultAudioDeviceId
;
LOG
(
LS_INFO
)
<
<
"
Setting
microphone
to
(
id
=
"
<
<
in_id
<
<
"
)
and
speaker
to
(
id
=
"
<
<
out_id
<
<
"
)
"
;
bool
ret
=
true
;
if
(
voe_wrapper_
-
>
hw
(
)
-
>
SetRecordingDevice
(
in_id
)
=
=
-
1
)
{
LOG_RTCERR1
(
SetRecordingDevice
in_id
)
;
ret
=
false
;
}
apm
(
)
-
>
Initialize
(
)
;
if
(
voe_wrapper_
-
>
hw
(
)
-
>
SetPlayoutDevice
(
out_id
)
=
=
-
1
)
{
LOG_RTCERR1
(
SetPlayoutDevice
out_id
)
;
ret
=
false
;
}
if
(
ret
)
{
LOG
(
LS_INFO
)
<
<
"
Set
microphone
to
(
id
=
"
<
<
in_id
<
<
"
)
and
speaker
to
(
id
=
"
<
<
out_id
<
<
"
)
"
;
}
#
endif
}
int
WebRtcVoiceEngine
:
:
GetInputLevel
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
unsigned
int
ulevel
;
return
(
voe_wrapper_
-
>
volume
(
)
-
>
GetSpeechInputLevel
(
ulevel
)
!
=
-
1
)
?
static_cast
<
int
>
(
ulevel
)
:
-
1
;
}
const
std
:
:
vector
<
AudioCodec
>
&
WebRtcVoiceEngine
:
:
send_codecs
(
)
const
{
RTC_DCHECK
(
signal_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
send_codecs_
;
}
const
std
:
:
vector
<
AudioCodec
>
&
WebRtcVoiceEngine
:
:
recv_codecs
(
)
const
{
RTC_DCHECK
(
signal_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
recv_codecs_
;
}
RtpCapabilities
WebRtcVoiceEngine
:
:
GetCapabilities
(
)
const
{
RTC_DCHECK
(
signal_thread_checker_
.
CalledOnValidThread
(
)
)
;
RtpCapabilities
capabilities
;
capabilities
.
header_extensions
.
push_back
(
webrtc
:
:
RtpExtension
(
webrtc
:
:
RtpExtension
:
:
kAudioLevelUri
webrtc
:
:
RtpExtension
:
:
kAudioLevelDefaultId
)
)
;
if
(
webrtc
:
:
field_trial
:
:
FindFullName
(
"
WebRTC
-
Audio
-
SendSideBwe
"
)
=
=
"
Enabled
"
)
{
capabilities
.
header_extensions
.
push_back
(
webrtc
:
:
RtpExtension
(
webrtc
:
:
RtpExtension
:
:
kTransportSequenceNumberUri
webrtc
:
:
RtpExtension
:
:
kTransportSequenceNumberDefaultId
)
)
;
}
return
capabilities
;
}
int
WebRtcVoiceEngine
:
:
GetLastEngineError
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
voe_wrapper_
-
>
error
(
)
;
}
void
WebRtcVoiceEngine
:
:
Print
(
webrtc
:
:
TraceLevel
level
const
char
*
trace
int
length
)
{
rtc
:
:
LoggingSeverity
sev
=
rtc
:
:
LS_VERBOSE
;
if
(
level
=
=
webrtc
:
:
kTraceError
|
|
level
=
=
webrtc
:
:
kTraceCritical
)
sev
=
rtc
:
:
LS_ERROR
;
else
if
(
level
=
=
webrtc
:
:
kTraceWarning
)
sev
=
rtc
:
:
LS_WARNING
;
else
if
(
level
=
=
webrtc
:
:
kTraceStateInfo
|
|
level
=
=
webrtc
:
:
kTraceInfo
)
sev
=
rtc
:
:
LS_INFO
;
else
if
(
level
=
=
webrtc
:
:
kTraceTerseInfo
)
sev
=
rtc
:
:
LS_INFO
;
if
(
length
<
72
)
{
std
:
:
string
msg
(
trace
length
)
;
LOG
(
LS_ERROR
)
<
<
"
Malformed
webrtc
log
message
:
"
;
LOG_V
(
sev
)
<
<
msg
;
}
else
{
std
:
:
string
msg
(
trace
+
71
length
-
72
)
;
LOG_V
(
sev
)
<
<
"
webrtc
:
"
<
<
msg
;
}
}
void
WebRtcVoiceEngine
:
:
RegisterChannel
(
WebRtcVoiceMediaChannel
*
channel
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
channel
)
;
channels_
.
push_back
(
channel
)
;
}
void
WebRtcVoiceEngine
:
:
UnregisterChannel
(
WebRtcVoiceMediaChannel
*
channel
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
auto
it
=
std
:
:
find
(
channels_
.
begin
(
)
channels_
.
end
(
)
channel
)
;
RTC_DCHECK
(
it
!
=
channels_
.
end
(
)
)
;
channels_
.
erase
(
it
)
;
}
bool
WebRtcVoiceEngine
:
:
AdjustAgcLevel
(
int
delta
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
webrtc
:
:
AgcConfig
config
=
default_agc_config_
;
config
.
targetLeveldBOv
-
=
delta
;
LOG
(
LS_INFO
)
<
<
"
Adjusting
AGC
level
from
default
-
"
<
<
default_agc_config_
.
targetLeveldBOv
<
<
"
dB
to
-
"
<
<
config
.
targetLeveldBOv
<
<
"
dB
"
;
if
(
voe_wrapper_
-
>
processing
(
)
-
>
SetAgcConfig
(
config
)
=
=
-
1
)
{
LOG_RTCERR1
(
SetAgcConfig
config
.
targetLeveldBOv
)
;
return
false
;
}
return
true
;
}
bool
WebRtcVoiceEngine
:
:
StartAecDump
(
rtc
:
:
PlatformFile
file
int64_t
max_size_bytes
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
FILE
*
aec_dump_file_stream
=
rtc
:
:
FdopenPlatformFileForWriting
(
file
)
;
if
(
!
aec_dump_file_stream
)
{
LOG
(
LS_ERROR
)
<
<
"
Could
not
open
AEC
dump
file
stream
.
"
;
if
(
!
rtc
:
:
ClosePlatformFile
(
file
)
)
LOG
(
LS_WARNING
)
<
<
"
Could
not
close
file
.
"
;
return
false
;
}
StopAecDump
(
)
;
if
(
apm
(
)
-
>
StartDebugRecording
(
aec_dump_file_stream
max_size_bytes
)
!
=
webrtc
:
:
AudioProcessing
:
:
kNoError
)
{
LOG_RTCERR0
(
StartDebugRecording
)
;
fclose
(
aec_dump_file_stream
)
;
return
false
;
}
is_dumping_aec_
=
true
;
return
true
;
}
void
WebRtcVoiceEngine
:
:
StartAecDump
(
const
std
:
:
string
&
filename
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
!
is_dumping_aec_
)
{
if
(
apm
(
)
-
>
StartDebugRecording
(
filename
.
c_str
(
)
-
1
)
!
=
webrtc
:
:
AudioProcessing
:
:
kNoError
)
{
LOG_RTCERR1
(
StartDebugRecording
filename
.
c_str
(
)
)
;
}
else
{
is_dumping_aec_
=
true
;
}
}
}
void
WebRtcVoiceEngine
:
:
StopAecDump
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
is_dumping_aec_
)
{
if
(
apm
(
)
-
>
StopDebugRecording
(
)
!
=
webrtc
:
:
AudioProcessing
:
:
kNoError
)
{
LOG_RTCERR0
(
StopDebugRecording
)
;
}
is_dumping_aec_
=
false
;
}
}
int
WebRtcVoiceEngine
:
:
CreateVoEChannel
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
voe_wrapper_
-
>
base
(
)
-
>
CreateChannel
(
channel_config_
)
;
}
webrtc
:
:
AudioDeviceModule
*
WebRtcVoiceEngine
:
:
adm
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
adm_
)
;
return
adm_
;
}
webrtc
:
:
AudioProcessing
*
WebRtcVoiceEngine
:
:
apm
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
apm_
)
;
return
apm_
;
}
AudioCodecs
WebRtcVoiceEngine
:
:
CollectRecvCodecs
(
)
const
{
PayloadTypeMapper
mapper
;
AudioCodecs
out
;
const
std
:
:
vector
<
webrtc
:
:
AudioCodecSpec
>
&
specs
=
decoder_factory_
-
>
GetSupportedDecoders
(
)
;
std
:
:
map
<
int
bool
std
:
:
greater
<
int
>
>
generate_cn
=
{
{
8000
false
}
{
16000
false
}
{
32000
false
}
}
;
std
:
:
map
<
int
bool
std
:
:
greater
<
int
>
>
generate_dtmf
=
{
{
8000
false
}
{
16000
false
}
{
32000
false
}
{
48000
false
}
}
;
auto
map_format
=
[
&
mapper
&
out
]
(
const
webrtc
:
:
SdpAudioFormat
&
format
)
{
rtc
:
:
Optional
<
AudioCodec
>
opt_codec
=
mapper
.
ToAudioCodec
(
format
)
;
if
(
!
opt_codec
)
{
LOG
(
LS_ERROR
)
<
<
"
Unable
to
assign
payload
type
to
format
:
"
<
<
format
;
return
false
;
}
auto
&
codec
=
*
opt_codec
;
if
(
IsCodec
(
codec
kOpusCodecName
)
)
{
codec
.
AddFeedbackParam
(
FeedbackParam
(
kRtcpFbParamTransportCc
kParamValueEmpty
)
)
;
}
out
.
push_back
(
codec
)
;
return
true
;
}
;
for
(
const
auto
&
spec
:
specs
)
{
if
(
map_format
(
spec
.
format
)
)
{
if
(
spec
.
allow_comfort_noise
)
{
auto
cn
=
generate_cn
.
find
(
spec
.
format
.
clockrate_hz
)
;
if
(
cn
!
=
generate_cn
.
end
(
)
)
{
cn
-
>
second
=
true
;
}
}
auto
dtmf
=
generate_dtmf
.
find
(
spec
.
format
.
clockrate_hz
)
;
if
(
dtmf
!
=
generate_dtmf
.
end
(
)
)
{
dtmf
-
>
second
=
true
;
}
}
}
for
(
const
auto
&
cn
:
generate_cn
)
{
if
(
cn
.
second
)
{
map_format
(
{
kCnCodecName
cn
.
first
1
}
)
;
}
}
for
(
const
auto
&
dtmf
:
generate_dtmf
)
{
if
(
dtmf
.
second
)
{
map_format
(
{
kDtmfCodecName
dtmf
.
first
1
}
)
;
}
}
return
out
;
}
class
WebRtcVoiceMediaChannel
:
:
WebRtcAudioSendStream
:
public
AudioSource
:
:
Sink
{
public
:
WebRtcAudioSendStream
(
int
ch
webrtc
:
:
AudioTransport
*
voe_audio_transport
uint32_t
ssrc
const
std
:
:
string
&
c_name
const
webrtc
:
:
AudioSendStream
:
:
Config
:
:
SendCodecSpec
&
send_codec_spec
const
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
&
extensions
int
max_send_bitrate_bps
const
rtc
:
:
Optional
<
std
:
:
string
>
&
audio_network_adaptor_config
webrtc
:
:
Call
*
call
webrtc
:
:
Transport
*
send_transport
)
:
voe_audio_transport_
(
voe_audio_transport
)
call_
(
call
)
config_
(
send_transport
)
max_send_bitrate_bps_
(
max_send_bitrate_bps
)
rtp_parameters_
(
CreateRtpParametersWithOneEncoding
(
)
)
{
RTC_DCHECK_GE
(
ch
0
)
;
RTC_DCHECK
(
call
)
;
config_
.
rtp
.
ssrc
=
ssrc
;
config_
.
rtp
.
c_name
=
c_name
;
config_
.
voe_channel_id
=
ch
;
config_
.
rtp
.
extensions
=
extensions
;
config_
.
audio_network_adaptor_config
=
audio_network_adaptor_config
;
rtp_parameters_
.
encodings
[
0
]
.
ssrc
=
rtc
:
:
Optional
<
uint32_t
>
(
ssrc
)
;
RecreateAudioSendStream
(
send_codec_spec
)
;
}
~
WebRtcAudioSendStream
(
)
override
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
ClearSource
(
)
;
call_
-
>
DestroyAudioSendStream
(
stream_
)
;
}
void
RecreateAudioSendStream
(
const
webrtc
:
:
AudioSendStream
:
:
Config
:
:
SendCodecSpec
&
send_codec_spec
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
send_codec_spec_
=
send_codec_spec
;
config_
.
rtp
.
nack
.
rtp_history_ms
=
send_codec_spec_
.
nack_enabled
?
kNackRtpHistoryMs
:
0
;
config_
.
send_codec_spec
=
send_codec_spec_
;
auto
send_rate
=
ComputeSendBitrate
(
max_send_bitrate_bps_
rtp_parameters_
.
encodings
[
0
]
.
max_bitrate_bps
send_codec_spec
.
codec_inst
)
;
if
(
send_rate
)
{
config_
.
send_codec_spec
.
codec_inst
.
rate
=
*
send_rate
;
}
RecreateAudioSendStream
(
)
;
}
void
RecreateAudioSendStream
(
const
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
&
extensions
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
config_
.
rtp
.
extensions
=
extensions
;
RecreateAudioSendStream
(
)
;
}
void
RecreateAudioSendStream
(
const
rtc
:
:
Optional
<
std
:
:
string
>
&
audio_network_adaptor_config
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
config_
.
audio_network_adaptor_config
=
=
audio_network_adaptor_config
)
{
return
;
}
config_
.
audio_network_adaptor_config
=
audio_network_adaptor_config
;
RecreateAudioSendStream
(
)
;
}
bool
SetMaxSendBitrate
(
int
bps
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
auto
send_rate
=
ComputeSendBitrate
(
bps
rtp_parameters_
.
encodings
[
0
]
.
max_bitrate_bps
send_codec_spec_
.
codec_inst
)
;
if
(
!
send_rate
)
{
return
false
;
}
max_send_bitrate_bps_
=
bps
;
if
(
config_
.
send_codec_spec
.
codec_inst
.
rate
!
=
*
send_rate
)
{
config_
.
send_codec_spec
.
codec_inst
.
rate
=
*
send_rate
;
RecreateAudioSendStream
(
)
;
}
return
true
;
}
bool
SendTelephoneEvent
(
int
payload_type
int
payload_freq
int
event
int
duration_ms
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
stream_
)
;
return
stream_
-
>
SendTelephoneEvent
(
payload_type
payload_freq
event
duration_ms
)
;
}
void
SetSend
(
bool
send
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
send_
=
send
;
UpdateSendState
(
)
;
}
void
SetMuted
(
bool
muted
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
stream_
)
;
stream_
-
>
SetMuted
(
muted
)
;
muted_
=
muted
;
}
bool
muted
(
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
muted_
;
}
webrtc
:
:
AudioSendStream
:
:
Stats
GetStats
(
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
stream_
)
;
return
stream_
-
>
GetStats
(
)
;
}
void
SetSource
(
AudioSource
*
source
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
source
)
;
if
(
source_
)
{
RTC_DCHECK
(
source_
=
=
source
)
;
return
;
}
source
-
>
SetSink
(
this
)
;
source_
=
source
;
UpdateSendState
(
)
;
}
void
ClearSource
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
source_
)
{
source_
-
>
SetSink
(
nullptr
)
;
source_
=
nullptr
;
}
UpdateSendState
(
)
;
}
void
OnData
(
const
void
*
audio_data
int
bits_per_sample
int
sample_rate
size_t
number_of_channels
size_t
number_of_frames
)
override
{
RTC_CHECK_RUNS_SERIALIZED
(
&
audio_capture_race_checker_
)
;
RTC_DCHECK
(
voe_audio_transport_
)
;
voe_audio_transport_
-
>
PushCaptureData
(
config_
.
voe_channel_id
audio_data
bits_per_sample
sample_rate
number_of_channels
number_of_frames
)
;
}
void
OnClose
(
)
override
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
source_
=
nullptr
;
UpdateSendState
(
)
;
}
int
channel
(
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
config_
.
voe_channel_id
;
}
const
webrtc
:
:
RtpParameters
&
rtp_parameters
(
)
const
{
return
rtp_parameters_
;
}
bool
ValidateRtpParameters
(
const
webrtc
:
:
RtpParameters
&
rtp_parameters
)
{
if
(
rtp_parameters
.
encodings
.
size
(
)
!
=
1
)
{
LOG
(
LS_ERROR
)
<
<
"
Attempted
to
set
RtpParameters
without
exactly
one
encoding
"
;
return
false
;
}
if
(
rtp_parameters
.
encodings
[
0
]
.
ssrc
!
=
rtp_parameters_
.
encodings
[
0
]
.
ssrc
)
{
LOG
(
LS_ERROR
)
<
<
"
Attempted
to
set
RtpParameters
with
modified
SSRC
"
;
return
false
;
}
return
true
;
}
bool
SetRtpParameters
(
const
webrtc
:
:
RtpParameters
&
parameters
)
{
if
(
!
ValidateRtpParameters
(
parameters
)
)
{
return
false
;
}
auto
send_rate
=
ComputeSendBitrate
(
max_send_bitrate_bps_
parameters
.
encodings
[
0
]
.
max_bitrate_bps
send_codec_spec_
.
codec_inst
)
;
if
(
!
send_rate
)
{
return
false
;
}
rtp_parameters_
=
parameters
;
if
(
config_
.
send_codec_spec
.
codec_inst
.
rate
!
=
*
send_rate
)
{
config_
.
send_codec_spec
.
codec_inst
.
rate
=
*
send_rate
;
RecreateAudioSendStream
(
)
;
}
else
{
UpdateSendState
(
)
;
}
return
true
;
}
private
:
void
UpdateSendState
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
stream_
)
;
RTC_DCHECK_EQ
(
1UL
rtp_parameters_
.
encodings
.
size
(
)
)
;
if
(
send_
&
&
source_
!
=
nullptr
&
&
rtp_parameters_
.
encodings
[
0
]
.
active
)
{
stream_
-
>
Start
(
)
;
}
else
{
stream_
-
>
Stop
(
)
;
}
}
void
RecreateAudioSendStream
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
stream_
)
{
call_
-
>
DestroyAudioSendStream
(
stream_
)
;
stream_
=
nullptr
;
}
RTC_DCHECK
(
!
stream_
)
;
if
(
webrtc
:
:
field_trial
:
:
FindFullName
(
"
WebRTC
-
Audio
-
SendSideBwe
"
)
=
=
"
Enabled
"
)
{
if
(
webrtc
:
:
field_trial
:
:
FindFullName
(
"
WebRTC
-
SendSideBwe
-
WithOverhead
"
)
=
=
"
Enabled
"
)
{
auto
packet_sizes_ms
=
WebRtcVoiceCodecs
:
:
GetPacketSizesMs
(
config_
.
send_codec_spec
.
codec_inst
)
;
if
(
!
packet_sizes_ms
.
empty
(
)
)
{
int
max_packet_size_ms
=
*
std
:
:
max_element
(
packet_sizes_ms
.
begin
(
)
packet_sizes_ms
.
end
(
)
)
;
int
min_packet_size_ms
=
*
std
:
:
min_element
(
packet_sizes_ms
.
begin
(
)
packet_sizes_ms
.
end
(
)
)
;
if
(
config_
.
audio_network_adaptor_config
&
&
IsCodec
(
config_
.
send_codec_spec
.
codec_inst
kOpusCodecName
)
)
{
max_packet_size_ms
=
60
;
min_packet_size_ms
=
20
;
}
constexpr
int
kOverheadPerPacket
=
20
+
8
+
10
+
12
;
int
min_overhead_bps
=
kOverheadPerPacket
*
8
*
1000
/
max_packet_size_ms
;
int
max_overhead_bps
=
kOverheadPerPacket
*
8
*
1000
/
min_packet_size_ms
;
config_
.
min_bitrate_bps
=
kOpusMinBitrateBps
+
min_overhead_bps
;
config_
.
max_bitrate_bps
=
kOpusBitrateFbBps
+
max_overhead_bps
;
}
}
else
{
config_
.
min_bitrate_bps
=
kOpusMinBitrateBps
;
config_
.
max_bitrate_bps
=
kOpusBitrateFbBps
;
}
}
stream_
=
call_
-
>
CreateAudioSendStream
(
config_
)
;
RTC_CHECK
(
stream_
)
;
UpdateSendState
(
)
;
}
rtc
:
:
ThreadChecker
worker_thread_checker_
;
rtc
:
:
RaceChecker
audio_capture_race_checker_
;
webrtc
:
:
AudioTransport
*
const
voe_audio_transport_
=
nullptr
;
webrtc
:
:
Call
*
call_
=
nullptr
;
webrtc
:
:
AudioSendStream
:
:
Config
config_
;
webrtc
:
:
AudioSendStream
*
stream_
=
nullptr
;
AudioSource
*
source_
=
nullptr
;
bool
send_
=
false
;
bool
muted_
=
false
;
int
max_send_bitrate_bps_
;
webrtc
:
:
RtpParameters
rtp_parameters_
;
webrtc
:
:
AudioSendStream
:
:
Config
:
:
SendCodecSpec
send_codec_spec_
;
RTC_DISALLOW_IMPLICIT_CONSTRUCTORS
(
WebRtcAudioSendStream
)
;
}
;
class
WebRtcVoiceMediaChannel
:
:
WebRtcAudioReceiveStream
{
public
:
WebRtcAudioReceiveStream
(
int
ch
uint32_t
remote_ssrc
uint32_t
local_ssrc
bool
use_transport_cc
bool
use_nack
const
std
:
:
string
&
sync_group
const
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
&
extensions
webrtc
:
:
Call
*
call
webrtc
:
:
Transport
*
rtcp_send_transport
const
rtc
:
:
scoped_refptr
<
webrtc
:
:
AudioDecoderFactory
>
&
decoder_factory
)
:
call_
(
call
)
config_
(
)
{
RTC_DCHECK_GE
(
ch
0
)
;
RTC_DCHECK
(
call
)
;
config_
.
rtp
.
remote_ssrc
=
remote_ssrc
;
config_
.
rtcp_send_transport
=
rtcp_send_transport
;
config_
.
voe_channel_id
=
ch
;
config_
.
sync_group
=
sync_group
;
config_
.
decoder_factory
=
decoder_factory
;
RecreateAudioReceiveStream
(
local_ssrc
use_transport_cc
use_nack
extensions
)
;
}
~
WebRtcAudioReceiveStream
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
call_
-
>
DestroyAudioReceiveStream
(
stream_
)
;
}
void
RecreateAudioReceiveStream
(
uint32_t
local_ssrc
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RecreateAudioReceiveStream
(
local_ssrc
config_
.
rtp
.
transport_cc
config_
.
rtp
.
nack
.
rtp_history_ms
!
=
0
config_
.
rtp
.
extensions
)
;
}
void
RecreateAudioReceiveStream
(
bool
use_transport_cc
bool
use_nack
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RecreateAudioReceiveStream
(
config_
.
rtp
.
local_ssrc
use_transport_cc
use_nack
config_
.
rtp
.
extensions
)
;
}
void
RecreateAudioReceiveStream
(
const
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
&
extensions
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RecreateAudioReceiveStream
(
config_
.
rtp
.
local_ssrc
config_
.
rtp
.
transport_cc
config_
.
rtp
.
nack
.
rtp_history_ms
!
=
0
extensions
)
;
}
webrtc
:
:
AudioReceiveStream
:
:
Stats
GetStats
(
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
stream_
)
;
return
stream_
-
>
GetStats
(
)
;
}
int
channel
(
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
return
config_
.
voe_channel_id
;
}
void
SetRawAudioSink
(
std
:
:
unique_ptr
<
webrtc
:
:
AudioSinkInterface
>
sink
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
stream_
-
>
SetSink
(
std
:
:
move
(
sink
)
)
;
}
void
SetOutputVolume
(
double
volume
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
stream_
-
>
SetGain
(
volume
)
;
}
void
SetPlayout
(
bool
playout
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
stream_
)
;
if
(
playout
)
{
LOG
(
LS_INFO
)
<
<
"
Starting
playout
for
channel
#
"
<
<
channel
(
)
;
stream_
-
>
Start
(
)
;
}
else
{
LOG
(
LS_INFO
)
<
<
"
Stopping
playout
for
channel
#
"
<
<
channel
(
)
;
stream_
-
>
Stop
(
)
;
}
playout_
=
playout
;
}
private
:
void
RecreateAudioReceiveStream
(
uint32_t
local_ssrc
bool
use_transport_cc
bool
use_nack
const
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
&
extensions
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
stream_
)
{
call_
-
>
DestroyAudioReceiveStream
(
stream_
)
;
stream_
=
nullptr
;
}
config_
.
rtp
.
local_ssrc
=
local_ssrc
;
config_
.
rtp
.
transport_cc
=
use_transport_cc
;
config_
.
rtp
.
nack
.
rtp_history_ms
=
use_nack
?
kNackRtpHistoryMs
:
0
;
config_
.
rtp
.
extensions
=
extensions
;
RTC_DCHECK
(
!
stream_
)
;
stream_
=
call_
-
>
CreateAudioReceiveStream
(
config_
)
;
RTC_CHECK
(
stream_
)
;
SetPlayout
(
playout_
)
;
}
rtc
:
:
ThreadChecker
worker_thread_checker_
;
webrtc
:
:
Call
*
call_
=
nullptr
;
webrtc
:
:
AudioReceiveStream
:
:
Config
config_
;
webrtc
:
:
AudioReceiveStream
*
stream_
=
nullptr
;
bool
playout_
=
false
;
RTC_DISALLOW_IMPLICIT_CONSTRUCTORS
(
WebRtcAudioReceiveStream
)
;
}
;
WebRtcVoiceMediaChannel
:
:
WebRtcVoiceMediaChannel
(
WebRtcVoiceEngine
*
engine
const
MediaConfig
&
config
const
AudioOptions
&
options
webrtc
:
:
Call
*
call
)
:
VoiceMediaChannel
(
config
)
engine_
(
engine
)
call_
(
call
)
{
LOG
(
LS_VERBOSE
)
<
<
"
WebRtcVoiceMediaChannel
:
:
WebRtcVoiceMediaChannel
"
;
RTC_DCHECK
(
call
)
;
engine
-
>
RegisterChannel
(
this
)
;
SetOptions
(
options
)
;
}
WebRtcVoiceMediaChannel
:
:
~
WebRtcVoiceMediaChannel
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_VERBOSE
)
<
<
"
WebRtcVoiceMediaChannel
:
:
~
WebRtcVoiceMediaChannel
"
;
while
(
!
send_streams_
.
empty
(
)
)
{
RemoveSendStream
(
send_streams_
.
begin
(
)
-
>
first
)
;
}
while
(
!
recv_streams_
.
empty
(
)
)
{
RemoveRecvStream
(
recv_streams_
.
begin
(
)
-
>
first
)
;
}
engine
(
)
-
>
UnregisterChannel
(
this
)
;
}
rtc
:
:
DiffServCodePoint
WebRtcVoiceMediaChannel
:
:
PreferredDscp
(
)
const
{
return
kAudioDscpValue
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetSendParameters
(
const
AudioSendParameters
&
params
)
{
TRACE_EVENT0
(
"
webrtc
"
"
WebRtcVoiceMediaChannel
:
:
SetSendParameters
"
)
;
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
WebRtcVoiceMediaChannel
:
:
SetSendParameters
:
"
<
<
params
.
ToString
(
)
;
if
(
!
SetSendCodecs
(
params
.
codecs
)
)
{
return
false
;
}
if
(
params
.
max_bandwidth_bps
>
=
0
)
{
bitrate_config_
.
max_bitrate_bps
=
params
.
max_bandwidth_bps
=
=
0
?
-
1
:
params
.
max_bandwidth_bps
;
}
call_
-
>
SetBitrateConfig
(
bitrate_config_
)
;
if
(
!
ValidateRtpExtensions
(
params
.
extensions
)
)
{
return
false
;
}
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
filtered_extensions
=
FilterRtpExtensions
(
params
.
extensions
webrtc
:
:
RtpExtension
:
:
IsSupportedForAudio
true
)
;
if
(
send_rtp_extensions_
!
=
filtered_extensions
)
{
send_rtp_extensions_
.
swap
(
filtered_extensions
)
;
for
(
auto
&
it
:
send_streams_
)
{
it
.
second
-
>
RecreateAudioSendStream
(
send_rtp_extensions_
)
;
}
}
if
(
!
SetMaxSendBitrate
(
params
.
max_bandwidth_bps
)
)
{
return
false
;
}
return
SetOptions
(
params
.
options
)
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetRecvParameters
(
const
AudioRecvParameters
&
params
)
{
TRACE_EVENT0
(
"
webrtc
"
"
WebRtcVoiceMediaChannel
:
:
SetRecvParameters
"
)
;
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
WebRtcVoiceMediaChannel
:
:
SetRecvParameters
:
"
<
<
params
.
ToString
(
)
;
if
(
!
SetRecvCodecs
(
params
.
codecs
)
)
{
return
false
;
}
if
(
!
ValidateRtpExtensions
(
params
.
extensions
)
)
{
return
false
;
}
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
filtered_extensions
=
FilterRtpExtensions
(
params
.
extensions
webrtc
:
:
RtpExtension
:
:
IsSupportedForAudio
false
)
;
if
(
recv_rtp_extensions_
!
=
filtered_extensions
)
{
recv_rtp_extensions_
.
swap
(
filtered_extensions
)
;
for
(
auto
&
it
:
recv_streams_
)
{
it
.
second
-
>
RecreateAudioReceiveStream
(
recv_rtp_extensions_
)
;
}
}
return
true
;
}
webrtc
:
:
RtpParameters
WebRtcVoiceMediaChannel
:
:
GetRtpSendParameters
(
uint32_t
ssrc
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
auto
it
=
send_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
send_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Attempting
to
get
RTP
send
parameters
for
stream
"
<
<
"
with
ssrc
"
<
<
ssrc
<
<
"
which
doesn
'
t
exist
.
"
;
return
webrtc
:
:
RtpParameters
(
)
;
}
webrtc
:
:
RtpParameters
rtp_params
=
it
-
>
second
-
>
rtp_parameters
(
)
;
for
(
const
AudioCodec
&
codec
:
send_codecs_
)
{
rtp_params
.
codecs
.
push_back
(
codec
.
ToCodecParameters
(
)
)
;
}
return
rtp_params
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetRtpSendParameters
(
uint32_t
ssrc
const
webrtc
:
:
RtpParameters
&
parameters
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
auto
it
=
send_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
send_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Attempting
to
set
RTP
send
parameters
for
stream
"
<
<
"
with
ssrc
"
<
<
ssrc
<
<
"
which
doesn
'
t
exist
.
"
;
return
false
;
}
webrtc
:
:
RtpParameters
current_parameters
=
GetRtpSendParameters
(
ssrc
)
;
if
(
current_parameters
.
codecs
!
=
parameters
.
codecs
)
{
LOG
(
LS_ERROR
)
<
<
"
Using
SetParameters
to
change
the
set
of
codecs
"
<
<
"
is
not
currently
supported
.
"
;
return
false
;
}
webrtc
:
:
RtpParameters
reduced_params
=
parameters
;
reduced_params
.
codecs
.
clear
(
)
;
return
it
-
>
second
-
>
SetRtpParameters
(
reduced_params
)
;
}
webrtc
:
:
RtpParameters
WebRtcVoiceMediaChannel
:
:
GetRtpReceiveParameters
(
uint32_t
ssrc
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
auto
it
=
recv_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
recv_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Attempting
to
get
RTP
receive
parameters
for
stream
"
<
<
"
with
ssrc
"
<
<
ssrc
<
<
"
which
doesn
'
t
exist
.
"
;
return
webrtc
:
:
RtpParameters
(
)
;
}
webrtc
:
:
RtpParameters
rtp_params
=
CreateRtpParametersWithOneEncoding
(
)
;
for
(
const
AudioCodec
&
codec
:
recv_codecs_
)
{
rtp_params
.
codecs
.
push_back
(
codec
.
ToCodecParameters
(
)
)
;
}
rtp_params
.
encodings
[
0
]
.
ssrc
=
rtc
:
:
Optional
<
uint32_t
>
(
ssrc
)
;
return
rtp_params
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetRtpReceiveParameters
(
uint32_t
ssrc
const
webrtc
:
:
RtpParameters
&
parameters
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
auto
it
=
recv_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
recv_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Attempting
to
set
RTP
receive
parameters
for
stream
"
<
<
"
with
ssrc
"
<
<
ssrc
<
<
"
which
doesn
'
t
exist
.
"
;
return
false
;
}
webrtc
:
:
RtpParameters
current_parameters
=
GetRtpReceiveParameters
(
ssrc
)
;
if
(
current_parameters
!
=
parameters
)
{
LOG
(
LS_ERROR
)
<
<
"
Changing
the
RTP
receive
parameters
is
currently
"
<
<
"
unsupported
.
"
;
return
false
;
}
return
true
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetOptions
(
const
AudioOptions
&
options
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
Setting
voice
channel
options
:
"
<
<
options
.
ToString
(
)
;
options_
.
SetAll
(
options
)
;
if
(
!
engine
(
)
-
>
ApplyOptions
(
options_
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Failed
to
apply
engine
options
during
channel
SetOptions
.
"
;
return
false
;
}
rtc
:
:
Optional
<
std
:
:
string
>
audio_network_adatptor_config
=
GetAudioNetworkAdaptorConfig
(
options_
)
;
for
(
auto
&
it
:
send_streams_
)
{
it
.
second
-
>
RecreateAudioSendStream
(
audio_network_adatptor_config
)
;
}
LOG
(
LS_INFO
)
<
<
"
Set
voice
channel
options
.
Current
options
:
"
<
<
options_
.
ToString
(
)
;
return
true
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetRecvCodecs
(
const
std
:
:
vector
<
AudioCodec
>
&
codecs
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
Setting
receive
voice
codecs
.
"
;
if
(
!
VerifyUniquePayloadTypes
(
codecs
)
)
{
LOG
(
LS_ERROR
)
<
<
"
Codec
payload
types
overlap
.
"
;
return
false
;
}
std
:
:
vector
<
AudioCodec
>
new_codecs
;
for
(
const
AudioCodec
&
codec
:
codecs
)
{
AudioCodec
old_codec
;
if
(
FindCodec
(
recv_codecs_
codec
&
old_codec
)
)
{
if
(
old_codec
.
id
!
=
codec
.
id
)
{
LOG
(
LS_ERROR
)
<
<
codec
.
name
<
<
"
payload
type
changed
.
"
;
return
false
;
}
}
else
{
new_codecs
.
push_back
(
codec
)
;
}
}
if
(
new_codecs
.
empty
(
)
)
{
return
true
;
}
if
(
playout_
)
{
ChangePlayout
(
false
)
;
}
bool
result
=
true
;
for
(
const
AudioCodec
&
codec
:
new_codecs
)
{
webrtc
:
:
CodecInst
voe_codec
=
{
0
}
;
if
(
WebRtcVoiceEngine
:
:
ToCodecInst
(
codec
&
voe_codec
)
)
{
LOG
(
LS_INFO
)
<
<
ToString
(
codec
)
;
voe_codec
.
pltype
=
codec
.
id
;
for
(
const
auto
&
ch
:
recv_streams_
)
{
if
(
engine
(
)
-
>
voe
(
)
-
>
codec
(
)
-
>
SetRecPayloadType
(
ch
.
second
-
>
channel
(
)
voe_codec
)
=
=
-
1
)
{
LOG_RTCERR2
(
SetRecPayloadType
ch
.
second
-
>
channel
(
)
ToString
(
voe_codec
)
)
;
result
=
false
;
}
}
}
else
{
LOG
(
LS_WARNING
)
<
<
"
Unknown
codec
"
<
<
ToString
(
codec
)
;
result
=
false
;
break
;
}
}
if
(
result
)
{
recv_codecs_
=
codecs
;
}
if
(
desired_playout_
&
&
!
playout_
)
{
ChangePlayout
(
desired_playout_
)
;
}
return
result
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetSendCodecs
(
const
std
:
:
vector
<
AudioCodec
>
&
codecs
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
dtmf_payload_type_
=
rtc
:
:
Optional
<
int
>
(
)
;
dtmf_payload_freq_
=
-
1
;
for
(
const
AudioCodec
&
codec
:
codecs
)
{
if
(
codec
.
id
<
kMinPayloadType
|
|
codec
.
id
>
kMaxPayloadType
)
{
LOG
(
LS_WARNING
)
<
<
"
Codec
payload
type
out
of
range
:
"
<
<
ToString
(
codec
)
;
return
false
;
}
}
std
:
:
vector
<
AudioCodec
>
dtmf_codecs
;
for
(
const
AudioCodec
&
codec
:
codecs
)
{
if
(
IsCodec
(
codec
kDtmfCodecName
)
)
{
dtmf_codecs
.
push_back
(
codec
)
;
if
(
!
dtmf_payload_type_
|
|
codec
.
clockrate
<
dtmf_payload_freq_
)
{
dtmf_payload_type_
=
rtc
:
:
Optional
<
int
>
(
codec
.
id
)
;
dtmf_payload_freq_
=
codec
.
clockrate
;
}
}
}
webrtc
:
:
AudioSendStream
:
:
Config
:
:
SendCodecSpec
send_codec_spec
;
{
send_codec_spec
.
nack_enabled
=
send_codec_spec_
.
nack_enabled
;
const
AudioCodec
*
codec
=
WebRtcVoiceCodecs
:
:
GetPreferredCodec
(
codecs
&
send_codec_spec
.
codec_inst
)
;
if
(
!
codec
)
{
LOG
(
LS_WARNING
)
<
<
"
Received
empty
list
of
codecs
.
"
;
return
false
;
}
send_codec_spec
.
transport_cc_enabled
=
HasTransportCc
(
*
codec
)
;
send_codec_spec
.
nack_enabled
=
HasNack
(
*
codec
)
;
bitrate_config_
=
GetBitrateConfigForCodec
(
*
codec
)
;
if
(
IsCodec
(
*
codec
kOpusCodecName
)
)
{
GetOpusConfig
(
*
codec
&
send_codec_spec
.
codec_inst
&
send_codec_spec
.
enable_codec_fec
&
send_codec_spec
.
opus_max_playback_rate
&
send_codec_spec
.
enable_opus_dtx
&
send_codec_spec
.
min_ptime_ms
&
send_codec_spec
.
max_ptime_ms
)
;
}
int
ptime_ms
=
0
;
if
(
codec
-
>
GetParam
(
kCodecParamPTime
&
ptime_ms
)
)
{
if
(
!
WebRtcVoiceCodecs
:
:
SetPTimeAsPacketSize
(
&
send_codec_spec
.
codec_inst
ptime_ms
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Failed
to
set
packet
size
for
codec
"
<
<
send_codec_spec
.
codec_inst
.
plname
;
return
false
;
}
}
for
(
const
AudioCodec
&
codec
:
codecs
)
{
webrtc
:
:
CodecInst
voe_codec
=
{
0
}
;
if
(
!
WebRtcVoiceEngine
:
:
ToCodecInst
(
codec
&
voe_codec
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Unknown
codec
"
<
<
ToString
(
codec
)
;
continue
;
}
if
(
IsCodec
(
codec
kCnCodecName
)
)
{
int
cng_plfreq
=
-
1
;
switch
(
codec
.
clockrate
)
{
case
8000
:
case
16000
:
case
32000
:
cng_plfreq
=
codec
.
clockrate
;
break
;
default
:
LOG
(
LS_WARNING
)
<
<
"
CN
frequency
"
<
<
codec
.
clockrate
<
<
"
not
supported
.
"
;
continue
;
}
send_codec_spec
.
cng_payload_type
=
codec
.
id
;
send_codec_spec
.
cng_plfreq
=
cng_plfreq
;
break
;
}
}
for
(
const
AudioCodec
&
dtmf_codec
:
dtmf_codecs
)
{
if
(
dtmf_codec
.
clockrate
=
=
codec
-
>
clockrate
)
{
dtmf_payload_type_
=
rtc
:
:
Optional
<
int
>
(
dtmf_codec
.
id
)
;
dtmf_payload_freq_
=
dtmf_codec
.
clockrate
;
break
;
}
}
}
if
(
send_codec_spec_
!
=
send_codec_spec
)
{
send_codec_spec_
=
std
:
:
move
(
send_codec_spec
)
;
for
(
const
auto
&
kv
:
send_streams_
)
{
kv
.
second
-
>
RecreateAudioSendStream
(
send_codec_spec_
)
;
}
}
else
{
bitrate_config_
.
start_bitrate_bps
=
-
1
;
}
if
(
recv_transport_cc_enabled_
!
=
send_codec_spec_
.
transport_cc_enabled
|
|
recv_nack_enabled_
!
=
send_codec_spec_
.
nack_enabled
)
{
LOG
(
LS_INFO
)
<
<
"
Recreate
all
the
receive
streams
because
the
send
"
"
codec
has
changed
.
"
;
recv_transport_cc_enabled_
=
send_codec_spec_
.
transport_cc_enabled
;
recv_nack_enabled_
=
send_codec_spec_
.
nack_enabled
;
for
(
auto
&
kv
:
recv_streams_
)
{
kv
.
second
-
>
RecreateAudioReceiveStream
(
recv_transport_cc_enabled_
recv_nack_enabled_
)
;
}
}
send_codecs_
=
codecs
;
return
true
;
}
void
WebRtcVoiceMediaChannel
:
:
SetPlayout
(
bool
playout
)
{
desired_playout_
=
playout
;
return
ChangePlayout
(
desired_playout_
)
;
}
void
WebRtcVoiceMediaChannel
:
:
ChangePlayout
(
bool
playout
)
{
TRACE_EVENT0
(
"
webrtc
"
"
WebRtcVoiceMediaChannel
:
:
ChangePlayout
"
)
;
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
playout_
=
=
playout
)
{
return
;
}
for
(
const
auto
&
kv
:
recv_streams_
)
{
kv
.
second
-
>
SetPlayout
(
playout
)
;
}
playout_
=
playout
;
}
void
WebRtcVoiceMediaChannel
:
:
SetSend
(
bool
send
)
{
TRACE_EVENT0
(
"
webrtc
"
"
WebRtcVoiceMediaChannel
:
:
SetSend
"
)
;
if
(
send_
=
=
send
)
{
return
;
}
if
(
send
)
{
engine
(
)
-
>
ApplyOptions
(
options_
)
;
if
(
!
engine
(
)
-
>
adm
(
)
-
>
RecordingIsInitialized
(
)
&
&
!
engine
(
)
-
>
adm
(
)
-
>
Recording
(
)
)
{
if
(
engine
(
)
-
>
adm
(
)
-
>
InitRecording
(
)
!
=
0
)
{
LOG
(
LS_WARNING
)
<
<
"
Failed
to
initialize
recording
"
;
}
}
}
for
(
auto
&
kv
:
send_streams_
)
{
kv
.
second
-
>
SetSend
(
send
)
;
}
send_
=
send
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetAudioSend
(
uint32_t
ssrc
bool
enable
const
AudioOptions
*
options
AudioSource
*
source
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
!
SetLocalSource
(
ssrc
source
)
)
{
return
false
;
}
if
(
!
MuteStream
(
ssrc
!
enable
)
)
{
return
false
;
}
if
(
enable
&
&
options
)
{
return
SetOptions
(
*
options
)
;
}
return
true
;
}
int
WebRtcVoiceMediaChannel
:
:
CreateVoEChannel
(
)
{
int
id
=
engine
(
)
-
>
CreateVoEChannel
(
)
;
if
(
id
=
=
-
1
)
{
LOG_RTCERR0
(
CreateVoEChannel
)
;
return
-
1
;
}
return
id
;
}
bool
WebRtcVoiceMediaChannel
:
:
DeleteVoEChannel
(
int
channel
)
{
if
(
engine
(
)
-
>
voe
(
)
-
>
base
(
)
-
>
DeleteChannel
(
channel
)
=
=
-
1
)
{
LOG_RTCERR1
(
DeleteChannel
channel
)
;
return
false
;
}
return
true
;
}
bool
WebRtcVoiceMediaChannel
:
:
AddSendStream
(
const
StreamParams
&
sp
)
{
TRACE_EVENT0
(
"
webrtc
"
"
WebRtcVoiceMediaChannel
:
:
AddSendStream
"
)
;
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
AddSendStream
:
"
<
<
sp
.
ToString
(
)
;
uint32_t
ssrc
=
sp
.
first_ssrc
(
)
;
RTC_DCHECK
(
0
!
=
ssrc
)
;
if
(
GetSendChannelId
(
ssrc
)
!
=
-
1
)
{
LOG
(
LS_ERROR
)
<
<
"
Stream
already
exists
with
ssrc
"
<
<
ssrc
;
return
false
;
}
int
channel
=
CreateVoEChannel
(
)
;
if
(
channel
=
=
-
1
)
{
return
false
;
}
webrtc
:
:
AudioTransport
*
audio_transport
=
engine
(
)
-
>
voe
(
)
-
>
base
(
)
-
>
audio_transport
(
)
;
rtc
:
:
Optional
<
std
:
:
string
>
audio_network_adaptor_config
=
GetAudioNetworkAdaptorConfig
(
options_
)
;
WebRtcAudioSendStream
*
stream
=
new
WebRtcAudioSendStream
(
channel
audio_transport
ssrc
sp
.
cname
send_codec_spec_
send_rtp_extensions_
max_send_bitrate_bps_
audio_network_adaptor_config
call_
this
)
;
send_streams_
.
insert
(
std
:
:
make_pair
(
ssrc
stream
)
)
;
if
(
send_streams_
.
size
(
)
=
=
1
)
{
receiver_reports_ssrc_
=
ssrc
;
for
(
const
auto
&
kv
:
recv_streams_
)
{
kv
.
second
-
>
RecreateAudioReceiveStream
(
ssrc
)
;
}
}
send_streams_
[
ssrc
]
-
>
SetSend
(
send_
)
;
return
true
;
}
bool
WebRtcVoiceMediaChannel
:
:
RemoveSendStream
(
uint32_t
ssrc
)
{
TRACE_EVENT0
(
"
webrtc
"
"
WebRtcVoiceMediaChannel
:
:
RemoveSendStream
"
)
;
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
RemoveSendStream
:
"
<
<
ssrc
;
auto
it
=
send_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
send_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Try
to
remove
stream
with
ssrc
"
<
<
ssrc
<
<
"
which
doesn
'
t
exist
.
"
;
return
false
;
}
it
-
>
second
-
>
SetSend
(
false
)
;
int
channel
=
it
-
>
second
-
>
channel
(
)
;
LOG
(
LS_INFO
)
<
<
"
Removing
audio
send
stream
"
<
<
ssrc
<
<
"
with
VoiceEngine
channel
#
"
<
<
channel
<
<
"
.
"
;
delete
it
-
>
second
;
send_streams_
.
erase
(
it
)
;
if
(
!
DeleteVoEChannel
(
channel
)
)
{
return
false
;
}
if
(
send_streams_
.
empty
(
)
)
{
SetSend
(
false
)
;
}
return
true
;
}
bool
WebRtcVoiceMediaChannel
:
:
AddRecvStream
(
const
StreamParams
&
sp
)
{
TRACE_EVENT0
(
"
webrtc
"
"
WebRtcVoiceMediaChannel
:
:
AddRecvStream
"
)
;
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
AddRecvStream
:
"
<
<
sp
.
ToString
(
)
;
if
(
!
ValidateStreamParams
(
sp
)
)
{
return
false
;
}
const
uint32_t
ssrc
=
sp
.
first_ssrc
(
)
;
if
(
ssrc
=
=
0
)
{
LOG
(
LS_WARNING
)
<
<
"
AddRecvStream
with
ssrc
=
=
0
is
not
supported
.
"
;
return
false
;
}
if
(
IsDefaultRecvStream
(
ssrc
)
)
{
RemoveRecvStream
(
ssrc
)
;
}
if
(
GetReceiveChannelId
(
ssrc
)
!
=
-
1
)
{
LOG
(
LS_ERROR
)
<
<
"
Stream
already
exists
with
ssrc
"
<
<
ssrc
;
return
false
;
}
const
int
channel
=
CreateVoEChannel
(
)
;
if
(
channel
=
=
-
1
)
{
return
false
;
}
for
(
webrtc
:
:
CodecInst
voe_codec
:
webrtc
:
:
acm2
:
:
RentACodec
:
:
Database
(
)
)
{
voe_codec
.
pltype
=
-
1
;
if
(
engine
(
)
-
>
voe
(
)
-
>
codec
(
)
-
>
SetRecPayloadType
(
channel
voe_codec
)
=
=
-
1
)
{
LOG_RTCERR2
(
SetRecPayloadType
channel
ToString
(
voe_codec
)
)
;
DeleteVoEChannel
(
channel
)
;
return
false
;
}
}
for
(
const
auto
&
codec
:
recv_codecs_
)
{
webrtc
:
:
CodecInst
voe_codec
=
{
0
}
;
if
(
WebRtcVoiceEngine
:
:
ToCodecInst
(
codec
&
voe_codec
)
)
{
voe_codec
.
pltype
=
codec
.
id
;
if
(
engine
(
)
-
>
voe
(
)
-
>
codec
(
)
-
>
SetRecPayloadType
(
channel
voe_codec
)
=
=
-
1
)
{
LOG_RTCERR2
(
SetRecPayloadType
channel
ToString
(
voe_codec
)
)
;
DeleteVoEChannel
(
channel
)
;
return
false
;
}
}
}
recv_streams_
.
insert
(
std
:
:
make_pair
(
ssrc
new
WebRtcAudioReceiveStream
(
channel
ssrc
receiver_reports_ssrc_
recv_transport_cc_enabled_
recv_nack_enabled_
sp
.
sync_label
recv_rtp_extensions_
call_
this
engine
(
)
-
>
decoder_factory_
)
)
)
;
recv_streams_
[
ssrc
]
-
>
SetPlayout
(
playout_
)
;
return
true
;
}
bool
WebRtcVoiceMediaChannel
:
:
RemoveRecvStream
(
uint32_t
ssrc
)
{
TRACE_EVENT0
(
"
webrtc
"
"
WebRtcVoiceMediaChannel
:
:
RemoveRecvStream
"
)
;
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
RemoveRecvStream
:
"
<
<
ssrc
;
const
auto
it
=
recv_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
recv_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Try
to
remove
stream
with
ssrc
"
<
<
ssrc
<
<
"
which
doesn
'
t
exist
.
"
;
return
false
;
}
if
(
IsDefaultRecvStream
(
ssrc
)
)
{
default_recv_ssrc_
=
-
1
;
}
const
int
channel
=
it
-
>
second
-
>
channel
(
)
;
LOG
(
LS_INFO
)
<
<
"
Removing
audio
receive
stream
"
<
<
ssrc
<
<
"
with
VoiceEngine
channel
#
"
<
<
channel
<
<
"
.
"
;
it
-
>
second
-
>
SetRawAudioSink
(
nullptr
)
;
delete
it
-
>
second
;
recv_streams_
.
erase
(
it
)
;
return
DeleteVoEChannel
(
channel
)
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetLocalSource
(
uint32_t
ssrc
AudioSource
*
source
)
{
auto
it
=
send_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
send_streams_
.
end
(
)
)
{
if
(
source
)
{
LOG
(
LS_ERROR
)
<
<
"
SetLocalSource
failed
with
ssrc
"
<
<
ssrc
;
return
false
;
}
return
true
;
}
if
(
source
)
{
it
-
>
second
-
>
SetSource
(
source
)
;
}
else
{
it
-
>
second
-
>
ClearSource
(
)
;
}
return
true
;
}
bool
WebRtcVoiceMediaChannel
:
:
GetActiveStreams
(
AudioInfo
:
:
StreamList
*
actives
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
actives
-
>
clear
(
)
;
for
(
const
auto
&
ch
:
recv_streams_
)
{
int
level
=
GetOutputLevel
(
ch
.
second
-
>
channel
(
)
)
;
if
(
level
>
0
)
{
actives
-
>
push_back
(
std
:
:
make_pair
(
ch
.
first
level
)
)
;
}
}
return
true
;
}
int
WebRtcVoiceMediaChannel
:
:
GetOutputLevel
(
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
int
highest
=
0
;
for
(
const
auto
&
ch
:
recv_streams_
)
{
highest
=
std
:
:
max
(
GetOutputLevel
(
ch
.
second
-
>
channel
(
)
)
highest
)
;
}
return
highest
;
}
int
WebRtcVoiceMediaChannel
:
:
GetTimeSinceLastTyping
(
)
{
int
ret
;
if
(
engine
(
)
-
>
voe
(
)
-
>
processing
(
)
-
>
TimeSinceLastTyping
(
ret
)
=
=
-
1
)
{
LOG_RTCERR0
(
TimeSinceLastTyping
)
;
ret
=
-
1
;
}
else
{
ret
*
=
1000
;
}
return
ret
;
}
void
WebRtcVoiceMediaChannel
:
:
SetTypingDetectionParameters
(
int
time_window
int
cost_per_typing
int
reporting_threshold
int
penalty_decay
int
type_event_delay
)
{
if
(
engine
(
)
-
>
voe
(
)
-
>
processing
(
)
-
>
SetTypingDetectionParameters
(
time_window
cost_per_typing
reporting_threshold
penalty_decay
type_event_delay
)
=
=
-
1
)
{
LOG_RTCERR5
(
SetTypingDetectionParameters
time_window
cost_per_typing
reporting_threshold
penalty_decay
type_event_delay
)
;
}
}
bool
WebRtcVoiceMediaChannel
:
:
SetOutputVolume
(
uint32_t
ssrc
double
volume
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
ssrc
=
=
0
)
{
default_recv_volume_
=
volume
;
if
(
default_recv_ssrc_
=
=
-
1
)
{
return
true
;
}
ssrc
=
static_cast
<
uint32_t
>
(
default_recv_ssrc_
)
;
}
const
auto
it
=
recv_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
recv_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
SetOutputVolume
:
no
recv
stream
"
<
<
ssrc
;
return
false
;
}
it
-
>
second
-
>
SetOutputVolume
(
volume
)
;
LOG
(
LS_INFO
)
<
<
"
SetOutputVolume
(
)
to
"
<
<
volume
<
<
"
for
recv
stream
with
ssrc
"
<
<
ssrc
;
return
true
;
}
bool
WebRtcVoiceMediaChannel
:
:
CanInsertDtmf
(
)
{
return
dtmf_payload_type_
?
true
:
false
;
}
bool
WebRtcVoiceMediaChannel
:
:
InsertDtmf
(
uint32_t
ssrc
int
event
int
duration
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_INFO
)
<
<
"
WebRtcVoiceMediaChannel
:
:
InsertDtmf
"
;
if
(
!
dtmf_payload_type_
)
{
return
false
;
}
auto
it
=
ssrc
!
=
0
?
send_streams_
.
find
(
ssrc
)
:
send_streams_
.
begin
(
)
;
if
(
it
=
=
send_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
The
specified
ssrc
"
<
<
ssrc
<
<
"
is
not
in
use
.
"
;
return
false
;
}
if
(
event
<
kMinTelephoneEventCode
|
|
event
>
kMaxTelephoneEventCode
)
{
LOG
(
LS_WARNING
)
<
<
"
DTMF
event
code
"
<
<
event
<
<
"
out
of
range
.
"
;
return
false
;
}
if
(
duration
<
kMinTelephoneEventDuration
|
|
duration
>
kMaxTelephoneEventDuration
)
{
LOG
(
LS_WARNING
)
<
<
"
DTMF
event
duration
"
<
<
duration
<
<
"
out
of
range
.
"
;
return
false
;
}
RTC_DCHECK_NE
(
-
1
dtmf_payload_freq_
)
;
return
it
-
>
second
-
>
SendTelephoneEvent
(
*
dtmf_payload_type_
dtmf_payload_freq_
event
duration
)
;
}
void
WebRtcVoiceMediaChannel
:
:
OnPacketReceived
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketTime
&
packet_time
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
const
webrtc
:
:
PacketTime
webrtc_packet_time
(
packet_time
.
timestamp
packet_time
.
not_before
)
;
webrtc
:
:
PacketReceiver
:
:
DeliveryStatus
delivery_result
=
call_
-
>
Receiver
(
)
-
>
DeliverPacket
(
webrtc
:
:
MediaType
:
:
AUDIO
packet
-
>
cdata
(
)
packet
-
>
size
(
)
webrtc_packet_time
)
;
if
(
delivery_result
!
=
webrtc
:
:
PacketReceiver
:
:
DELIVERY_UNKNOWN_SSRC
)
{
return
;
}
uint32_t
ssrc
=
0
;
if
(
!
GetRtpSsrc
(
packet
-
>
cdata
(
)
packet
-
>
size
(
)
&
ssrc
)
)
{
return
;
}
if
(
default_recv_ssrc_
!
=
-
1
)
{
LOG
(
LS_INFO
)
<
<
"
Removing
default
receive
stream
with
ssrc
"
<
<
default_recv_ssrc_
;
RTC_DCHECK_NE
(
ssrc
default_recv_ssrc_
)
;
RemoveRecvStream
(
default_recv_ssrc_
)
;
default_recv_ssrc_
=
-
1
;
}
StreamParams
sp
;
sp
.
ssrcs
.
push_back
(
ssrc
)
;
LOG
(
LS_INFO
)
<
<
"
Creating
default
receive
stream
for
SSRC
=
"
<
<
ssrc
<
<
"
.
"
;
if
(
!
AddRecvStream
(
sp
)
)
{
LOG
(
LS_WARNING
)
<
<
"
Could
not
create
default
receive
stream
.
"
;
return
;
}
default_recv_ssrc_
=
ssrc
;
SetOutputVolume
(
default_recv_ssrc_
default_recv_volume_
)
;
if
(
default_sink_
)
{
std
:
:
unique_ptr
<
webrtc
:
:
AudioSinkInterface
>
proxy_sink
(
new
ProxySink
(
default_sink_
.
get
(
)
)
)
;
SetRawAudioSink
(
default_recv_ssrc_
std
:
:
move
(
proxy_sink
)
)
;
}
delivery_result
=
call_
-
>
Receiver
(
)
-
>
DeliverPacket
(
webrtc
:
:
MediaType
:
:
AUDIO
packet
-
>
cdata
(
)
packet
-
>
size
(
)
webrtc_packet_time
)
;
RTC_DCHECK_NE
(
webrtc
:
:
PacketReceiver
:
:
DELIVERY_UNKNOWN_SSRC
delivery_result
)
;
}
void
WebRtcVoiceMediaChannel
:
:
OnRtcpReceived
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketTime
&
packet_time
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
const
webrtc
:
:
PacketTime
webrtc_packet_time
(
packet_time
.
timestamp
packet_time
.
not_before
)
;
call_
-
>
Receiver
(
)
-
>
DeliverPacket
(
webrtc
:
:
MediaType
:
:
AUDIO
packet
-
>
cdata
(
)
packet
-
>
size
(
)
webrtc_packet_time
)
;
}
void
WebRtcVoiceMediaChannel
:
:
OnNetworkRouteChanged
(
const
std
:
:
string
&
transport_name
const
rtc
:
:
NetworkRoute
&
network_route
)
{
call_
-
>
OnNetworkRouteChanged
(
transport_name
network_route
)
;
}
bool
WebRtcVoiceMediaChannel
:
:
MuteStream
(
uint32_t
ssrc
bool
muted
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
const
auto
it
=
send_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
send_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
The
specified
ssrc
"
<
<
ssrc
<
<
"
is
not
in
use
.
"
;
return
false
;
}
it
-
>
second
-
>
SetMuted
(
muted
)
;
bool
all_muted
=
muted
;
for
(
const
auto
&
kv
:
send_streams_
)
{
all_muted
=
all_muted
&
&
kv
.
second
-
>
muted
(
)
;
}
engine
(
)
-
>
apm
(
)
-
>
set_output_will_be_muted
(
all_muted
)
;
return
true
;
}
bool
WebRtcVoiceMediaChannel
:
:
SetMaxSendBitrate
(
int
bps
)
{
LOG
(
LS_INFO
)
<
<
"
WebRtcVoiceMediaChannel
:
:
SetMaxSendBitrate
.
"
;
max_send_bitrate_bps_
=
bps
;
bool
success
=
true
;
for
(
const
auto
&
kv
:
send_streams_
)
{
if
(
!
kv
.
second
-
>
SetMaxSendBitrate
(
max_send_bitrate_bps_
)
)
{
success
=
false
;
}
}
return
success
;
}
void
WebRtcVoiceMediaChannel
:
:
OnReadyToSend
(
bool
ready
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_VERBOSE
)
<
<
"
OnReadyToSend
:
"
<
<
(
ready
?
"
Ready
.
"
:
"
Not
ready
.
"
)
;
call_
-
>
SignalChannelNetworkState
(
webrtc
:
:
MediaType
:
:
AUDIO
ready
?
webrtc
:
:
kNetworkUp
:
webrtc
:
:
kNetworkDown
)
;
}
void
WebRtcVoiceMediaChannel
:
:
OnTransportOverheadChanged
(
int
transport_overhead_per_packet
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
call_
-
>
OnTransportOverheadChanged
(
webrtc
:
:
MediaType
:
:
AUDIO
transport_overhead_per_packet
)
;
}
bool
WebRtcVoiceMediaChannel
:
:
GetStats
(
VoiceMediaInfo
*
info
)
{
TRACE_EVENT0
(
"
webrtc
"
"
WebRtcVoiceMediaChannel
:
:
GetStats
"
)
;
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
RTC_DCHECK
(
info
)
;
RTC_DCHECK_EQ
(
info
-
>
senders
.
size
(
)
0U
)
;
for
(
const
auto
&
stream
:
send_streams_
)
{
webrtc
:
:
AudioSendStream
:
:
Stats
stats
=
stream
.
second
-
>
GetStats
(
)
;
VoiceSenderInfo
sinfo
;
sinfo
.
add_ssrc
(
stats
.
local_ssrc
)
;
sinfo
.
bytes_sent
=
stats
.
bytes_sent
;
sinfo
.
packets_sent
=
stats
.
packets_sent
;
sinfo
.
packets_lost
=
stats
.
packets_lost
;
sinfo
.
fraction_lost
=
stats
.
fraction_lost
;
sinfo
.
codec_name
=
stats
.
codec_name
;
sinfo
.
codec_payload_type
=
stats
.
codec_payload_type
;
sinfo
.
ext_seqnum
=
stats
.
ext_seqnum
;
sinfo
.
jitter_ms
=
stats
.
jitter_ms
;
sinfo
.
rtt_ms
=
stats
.
rtt_ms
;
sinfo
.
audio_level
=
stats
.
audio_level
;
sinfo
.
aec_quality_min
=
stats
.
aec_quality_min
;
sinfo
.
echo_delay_median_ms
=
stats
.
echo_delay_median_ms
;
sinfo
.
echo_delay_std_ms
=
stats
.
echo_delay_std_ms
;
sinfo
.
echo_return_loss
=
stats
.
echo_return_loss
;
sinfo
.
echo_return_loss_enhancement
=
stats
.
echo_return_loss_enhancement
;
sinfo
.
residual_echo_likelihood
=
stats
.
residual_echo_likelihood
;
sinfo
.
residual_echo_likelihood_recent_max
=
stats
.
residual_echo_likelihood_recent_max
;
sinfo
.
typing_noise_detected
=
(
send_
?
stats
.
typing_noise_detected
:
false
)
;
info
-
>
senders
.
push_back
(
sinfo
)
;
}
RTC_DCHECK_EQ
(
info
-
>
receivers
.
size
(
)
0U
)
;
for
(
const
auto
&
stream
:
recv_streams_
)
{
webrtc
:
:
AudioReceiveStream
:
:
Stats
stats
=
stream
.
second
-
>
GetStats
(
)
;
VoiceReceiverInfo
rinfo
;
rinfo
.
add_ssrc
(
stats
.
remote_ssrc
)
;
rinfo
.
bytes_rcvd
=
stats
.
bytes_rcvd
;
rinfo
.
packets_rcvd
=
stats
.
packets_rcvd
;
rinfo
.
packets_lost
=
stats
.
packets_lost
;
rinfo
.
fraction_lost
=
stats
.
fraction_lost
;
rinfo
.
codec_name
=
stats
.
codec_name
;
rinfo
.
codec_payload_type
=
stats
.
codec_payload_type
;
rinfo
.
ext_seqnum
=
stats
.
ext_seqnum
;
rinfo
.
jitter_ms
=
stats
.
jitter_ms
;
rinfo
.
jitter_buffer_ms
=
stats
.
jitter_buffer_ms
;
rinfo
.
jitter_buffer_preferred_ms
=
stats
.
jitter_buffer_preferred_ms
;
rinfo
.
delay_estimate_ms
=
stats
.
delay_estimate_ms
;
rinfo
.
audio_level
=
stats
.
audio_level
;
rinfo
.
expand_rate
=
stats
.
expand_rate
;
rinfo
.
speech_expand_rate
=
stats
.
speech_expand_rate
;
rinfo
.
secondary_decoded_rate
=
stats
.
secondary_decoded_rate
;
rinfo
.
accelerate_rate
=
stats
.
accelerate_rate
;
rinfo
.
preemptive_expand_rate
=
stats
.
preemptive_expand_rate
;
rinfo
.
decoding_calls_to_silence_generator
=
stats
.
decoding_calls_to_silence_generator
;
rinfo
.
decoding_calls_to_neteq
=
stats
.
decoding_calls_to_neteq
;
rinfo
.
decoding_normal
=
stats
.
decoding_normal
;
rinfo
.
decoding_plc
=
stats
.
decoding_plc
;
rinfo
.
decoding_cng
=
stats
.
decoding_cng
;
rinfo
.
decoding_plc_cng
=
stats
.
decoding_plc_cng
;
rinfo
.
decoding_muted_output
=
stats
.
decoding_muted_output
;
rinfo
.
capture_start_ntp_time_ms
=
stats
.
capture_start_ntp_time_ms
;
info
-
>
receivers
.
push_back
(
rinfo
)
;
}
for
(
const
AudioCodec
&
codec
:
send_codecs_
)
{
webrtc
:
:
RtpCodecParameters
codec_params
=
codec
.
ToCodecParameters
(
)
;
info
-
>
send_codecs
.
insert
(
std
:
:
make_pair
(
codec_params
.
payload_type
std
:
:
move
(
codec_params
)
)
)
;
}
for
(
const
AudioCodec
&
codec
:
recv_codecs_
)
{
webrtc
:
:
RtpCodecParameters
codec_params
=
codec
.
ToCodecParameters
(
)
;
info
-
>
receive_codecs
.
insert
(
std
:
:
make_pair
(
codec_params
.
payload_type
std
:
:
move
(
codec_params
)
)
)
;
}
return
true
;
}
void
WebRtcVoiceMediaChannel
:
:
SetRawAudioSink
(
uint32_t
ssrc
std
:
:
unique_ptr
<
webrtc
:
:
AudioSinkInterface
>
sink
)
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
LOG
(
LS_VERBOSE
)
<
<
"
WebRtcVoiceMediaChannel
:
:
SetRawAudioSink
:
ssrc
:
"
<
<
ssrc
<
<
"
"
<
<
(
sink
?
"
(
ptr
)
"
:
"
NULL
"
)
;
if
(
ssrc
=
=
0
)
{
if
(
default_recv_ssrc_
!
=
-
1
)
{
std
:
:
unique_ptr
<
webrtc
:
:
AudioSinkInterface
>
proxy_sink
(
sink
?
new
ProxySink
(
sink
.
get
(
)
)
:
nullptr
)
;
SetRawAudioSink
(
default_recv_ssrc_
std
:
:
move
(
proxy_sink
)
)
;
}
default_sink_
=
std
:
:
move
(
sink
)
;
return
;
}
const
auto
it
=
recv_streams_
.
find
(
ssrc
)
;
if
(
it
=
=
recv_streams_
.
end
(
)
)
{
LOG
(
LS_WARNING
)
<
<
"
SetRawAudioSink
:
no
recv
stream
"
<
<
ssrc
;
return
;
}
it
-
>
second
-
>
SetRawAudioSink
(
std
:
:
move
(
sink
)
)
;
}
int
WebRtcVoiceMediaChannel
:
:
GetOutputLevel
(
int
channel
)
{
unsigned
int
ulevel
=
0
;
int
ret
=
engine
(
)
-
>
voe
(
)
-
>
volume
(
)
-
>
GetSpeechOutputLevel
(
channel
ulevel
)
;
return
(
ret
=
=
0
)
?
static_cast
<
int
>
(
ulevel
)
:
-
1
;
}
int
WebRtcVoiceMediaChannel
:
:
GetReceiveChannelId
(
uint32_t
ssrc
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
const
auto
it
=
recv_streams_
.
find
(
ssrc
)
;
if
(
it
!
=
recv_streams_
.
end
(
)
)
{
return
it
-
>
second
-
>
channel
(
)
;
}
return
-
1
;
}
int
WebRtcVoiceMediaChannel
:
:
GetSendChannelId
(
uint32_t
ssrc
)
const
{
RTC_DCHECK
(
worker_thread_checker_
.
CalledOnValidThread
(
)
)
;
const
auto
it
=
send_streams_
.
find
(
ssrc
)
;
if
(
it
!
=
send_streams_
.
end
(
)
)
{
return
it
-
>
second
-
>
channel
(
)
;
}
return
-
1
;
}
}
#
endif
