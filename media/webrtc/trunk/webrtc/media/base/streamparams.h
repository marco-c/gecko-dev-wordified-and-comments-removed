#
ifndef
MEDIA_BASE_STREAMPARAMS_H_
#
define
MEDIA_BASE_STREAMPARAMS_H_
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
rtc_base
/
constructormagic
.
h
"
namespace
cricket
{
extern
const
char
kFecSsrcGroupSemantics
[
]
;
extern
const
char
kFecFrSsrcGroupSemantics
[
]
;
extern
const
char
kFidSsrcGroupSemantics
[
]
;
extern
const
char
kSimSsrcGroupSemantics
[
]
;
struct
SsrcGroup
{
SsrcGroup
(
const
std
:
:
string
&
usage
const
std
:
:
vector
<
uint32_t
>
&
ssrcs
)
:
semantics
(
usage
)
ssrcs
(
ssrcs
)
{
}
bool
operator
=
=
(
const
SsrcGroup
&
other
)
const
{
return
(
semantics
=
=
other
.
semantics
&
&
ssrcs
=
=
other
.
ssrcs
)
;
}
bool
operator
!
=
(
const
SsrcGroup
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
has_semantics
(
const
std
:
:
string
&
semantics
)
const
;
std
:
:
string
ToString
(
)
const
;
std
:
:
string
semantics
;
std
:
:
vector
<
uint32_t
>
ssrcs
;
}
;
struct
StreamParams
{
static
StreamParams
CreateLegacy
(
uint32_t
ssrc
)
{
StreamParams
stream
;
stream
.
ssrcs
.
push_back
(
ssrc
)
;
return
stream
;
}
bool
operator
=
=
(
const
StreamParams
&
other
)
const
{
return
(
groupid
=
=
other
.
groupid
&
&
id
=
=
other
.
id
&
&
ssrcs
=
=
other
.
ssrcs
&
&
ssrc_groups
=
=
other
.
ssrc_groups
&
&
type
=
=
other
.
type
&
&
display
=
=
other
.
display
&
&
cname
=
=
other
.
cname
&
&
sync_label
=
=
other
.
sync_label
)
;
}
bool
operator
!
=
(
const
StreamParams
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
uint32_t
first_ssrc
(
)
const
{
if
(
ssrcs
.
empty
(
)
)
{
return
0
;
}
return
ssrcs
[
0
]
;
}
bool
has_ssrcs
(
)
const
{
return
!
ssrcs
.
empty
(
)
;
}
bool
has_ssrc
(
uint32_t
ssrc
)
const
{
return
std
:
:
find
(
ssrcs
.
begin
(
)
ssrcs
.
end
(
)
ssrc
)
!
=
ssrcs
.
end
(
)
;
}
void
add_ssrc
(
uint32_t
ssrc
)
{
ssrcs
.
push_back
(
ssrc
)
;
}
bool
has_ssrc_groups
(
)
const
{
return
!
ssrc_groups
.
empty
(
)
;
}
bool
has_ssrc_group
(
const
std
:
:
string
&
semantics
)
const
{
return
(
get_ssrc_group
(
semantics
)
!
=
NULL
)
;
}
const
SsrcGroup
*
get_ssrc_group
(
const
std
:
:
string
&
semantics
)
const
{
for
(
std
:
:
vector
<
SsrcGroup
>
:
:
const_iterator
it
=
ssrc_groups
.
begin
(
)
;
it
!
=
ssrc_groups
.
end
(
)
;
+
+
it
)
{
if
(
it
-
>
has_semantics
(
semantics
)
)
{
return
&
(
*
it
)
;
}
}
return
NULL
;
}
bool
AddFidSsrc
(
uint32_t
primary_ssrc
uint32_t
fid_ssrc
)
{
return
AddSecondarySsrc
(
kFidSsrcGroupSemantics
primary_ssrc
fid_ssrc
)
;
}
bool
GetFidSsrc
(
uint32_t
primary_ssrc
uint32_t
*
fid_ssrc
)
const
{
return
GetSecondarySsrc
(
kFidSsrcGroupSemantics
primary_ssrc
fid_ssrc
)
;
}
bool
AddFecFrSsrc
(
uint32_t
primary_ssrc
uint32_t
fecfr_ssrc
)
{
return
AddSecondarySsrc
(
kFecFrSsrcGroupSemantics
primary_ssrc
fecfr_ssrc
)
;
}
bool
GetFecFrSsrc
(
uint32_t
primary_ssrc
uint32_t
*
fecfr_ssrc
)
const
{
return
GetSecondarySsrc
(
kFecFrSsrcGroupSemantics
primary_ssrc
fecfr_ssrc
)
;
}
void
GetPrimarySsrcs
(
std
:
:
vector
<
uint32_t
>
*
ssrcs
)
const
;
void
GetFidSsrcs
(
const
std
:
:
vector
<
uint32_t
>
&
primary_ssrcs
std
:
:
vector
<
uint32_t
>
*
fid_ssrcs
)
const
;
std
:
:
string
ToString
(
)
const
;
std
:
:
string
groupid
;
std
:
:
string
id
;
std
:
:
vector
<
uint32_t
>
ssrcs
;
std
:
:
vector
<
SsrcGroup
>
ssrc_groups
;
std
:
:
string
type
;
std
:
:
string
display
;
std
:
:
string
cname
;
std
:
:
string
sync_label
;
private
:
bool
AddSecondarySsrc
(
const
std
:
:
string
&
semantics
uint32_t
primary_ssrc
uint32_t
secondary_ssrc
)
;
bool
GetSecondarySsrc
(
const
std
:
:
string
&
semantics
uint32_t
primary_ssrc
uint32_t
*
secondary_ssrc
)
const
;
}
;
struct
StreamSelector
{
explicit
StreamSelector
(
uint32_t
ssrc
)
:
ssrc
(
ssrc
)
{
}
StreamSelector
(
const
std
:
:
string
&
groupid
const
std
:
:
string
&
streamid
)
:
ssrc
(
0
)
groupid
(
groupid
)
streamid
(
streamid
)
{
}
bool
Matches
(
const
StreamParams
&
stream
)
const
{
if
(
ssrc
=
=
0
)
{
return
stream
.
groupid
=
=
groupid
&
&
stream
.
id
=
=
streamid
;
}
else
{
return
stream
.
has_ssrc
(
ssrc
)
;
}
}
uint32_t
ssrc
;
std
:
:
string
groupid
;
std
:
:
string
streamid
;
}
;
typedef
std
:
:
vector
<
StreamParams
>
StreamParamsVec
;
struct
MediaStreams
{
public
:
MediaStreams
(
)
{
}
void
CopyFrom
(
const
MediaStreams
&
sources
)
;
bool
empty
(
)
const
{
return
audio_
.
empty
(
)
&
&
video_
.
empty
(
)
&
&
data_
.
empty
(
)
;
}
std
:
:
vector
<
StreamParams
>
*
mutable_audio
(
)
{
return
&
audio_
;
}
std
:
:
vector
<
StreamParams
>
*
mutable_video
(
)
{
return
&
video_
;
}
std
:
:
vector
<
StreamParams
>
*
mutable_data
(
)
{
return
&
data_
;
}
const
std
:
:
vector
<
StreamParams
>
&
audio
(
)
const
{
return
audio_
;
}
const
std
:
:
vector
<
StreamParams
>
&
video
(
)
const
{
return
video_
;
}
const
std
:
:
vector
<
StreamParams
>
&
data
(
)
const
{
return
data_
;
}
bool
GetAudioStream
(
const
StreamSelector
&
selector
StreamParams
*
stream
)
;
bool
GetVideoStream
(
const
StreamSelector
&
selector
StreamParams
*
stream
)
;
bool
GetDataStream
(
const
StreamSelector
&
selector
StreamParams
*
stream
)
;
void
AddAudioStream
(
const
StreamParams
&
stream
)
;
void
AddVideoStream
(
const
StreamParams
&
stream
)
;
void
AddDataStream
(
const
StreamParams
&
stream
)
;
bool
RemoveAudioStream
(
const
StreamSelector
&
selector
)
;
bool
RemoveVideoStream
(
const
StreamSelector
&
selector
)
;
bool
RemoveDataStream
(
const
StreamSelector
&
selector
)
;
private
:
std
:
:
vector
<
StreamParams
>
audio_
;
std
:
:
vector
<
StreamParams
>
video_
;
std
:
:
vector
<
StreamParams
>
data_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
MediaStreams
)
;
}
;
template
<
class
Condition
>
const
StreamParams
*
GetStream
(
const
StreamParamsVec
&
streams
Condition
condition
)
{
StreamParamsVec
:
:
const_iterator
found
=
std
:
:
find_if
(
streams
.
begin
(
)
streams
.
end
(
)
condition
)
;
return
found
=
=
streams
.
end
(
)
?
nullptr
:
&
(
*
found
)
;
}
template
<
class
Condition
>
StreamParams
*
GetStream
(
StreamParamsVec
&
streams
Condition
condition
)
{
StreamParamsVec
:
:
iterator
found
=
std
:
:
find_if
(
streams
.
begin
(
)
streams
.
end
(
)
condition
)
;
return
found
=
=
streams
.
end
(
)
?
nullptr
:
&
(
*
found
)
;
}
inline
const
StreamParams
*
GetStreamBySsrc
(
const
StreamParamsVec
&
streams
uint32_t
ssrc
)
{
return
GetStream
(
streams
[
&
ssrc
]
(
const
StreamParams
&
sp
)
{
return
sp
.
has_ssrc
(
ssrc
)
;
}
)
;
}
inline
const
StreamParams
*
GetStreamByIds
(
const
StreamParamsVec
&
streams
const
std
:
:
string
&
groupid
const
std
:
:
string
&
id
)
{
return
GetStream
(
streams
[
&
groupid
&
id
]
(
const
StreamParams
&
sp
)
{
return
sp
.
groupid
=
=
groupid
&
&
sp
.
id
=
=
id
;
}
)
;
}
inline
StreamParams
*
GetStreamByIds
(
StreamParamsVec
&
streams
const
std
:
:
string
&
groupid
const
std
:
:
string
&
id
)
{
return
GetStream
(
streams
[
&
groupid
&
id
]
(
const
StreamParams
&
sp
)
{
return
sp
.
groupid
=
=
groupid
&
&
sp
.
id
=
=
id
;
}
)
;
}
inline
const
StreamParams
*
GetStream
(
const
StreamParamsVec
&
streams
const
StreamSelector
&
selector
)
{
return
GetStream
(
streams
[
&
selector
]
(
const
StreamParams
&
sp
)
{
return
selector
.
Matches
(
sp
)
;
}
)
;
}
template
<
class
Condition
>
bool
RemoveStream
(
StreamParamsVec
*
streams
Condition
condition
)
{
auto
iter
(
std
:
:
remove_if
(
streams
-
>
begin
(
)
streams
-
>
end
(
)
condition
)
)
;
if
(
iter
=
=
streams
-
>
end
(
)
)
return
false
;
streams
-
>
erase
(
iter
streams
-
>
end
(
)
)
;
return
true
;
}
inline
bool
RemoveStream
(
StreamParamsVec
*
streams
const
StreamSelector
&
selector
)
{
return
RemoveStream
(
streams
[
&
selector
]
(
const
StreamParams
&
sp
)
{
return
selector
.
Matches
(
sp
)
;
}
)
;
}
inline
bool
RemoveStreamBySsrc
(
StreamParamsVec
*
streams
uint32_t
ssrc
)
{
return
RemoveStream
(
streams
[
&
ssrc
]
(
const
StreamParams
&
sp
)
{
return
sp
.
has_ssrc
(
ssrc
)
;
}
)
;
}
inline
bool
RemoveStreamByIds
(
StreamParamsVec
*
streams
const
std
:
:
string
&
groupid
const
std
:
:
string
&
id
)
{
return
RemoveStream
(
streams
[
&
groupid
&
id
]
(
const
StreamParams
&
sp
)
{
return
sp
.
groupid
=
=
groupid
&
&
sp
.
id
=
=
id
;
}
)
;
}
bool
IsOneSsrcStream
(
const
StreamParams
&
sp
)
;
bool
IsSimulcastStream
(
const
StreamParams
&
sp
)
;
}
#
endif
