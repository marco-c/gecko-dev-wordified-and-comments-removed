#
include
"
media
/
base
/
videoadapter
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
limits
>
#
include
<
utility
>
#
include
"
api
/
optional
.
h
"
#
include
"
media
/
base
/
mediaconstants
.
h
"
#
include
"
media
/
base
/
videocommon
.
h
"
#
include
"
rtc_base
/
arraysize
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
namespace
{
struct
Fraction
{
int
numerator
;
int
denominator
;
int
scale_pixel_count
(
int
input_pixels
)
{
return
(
numerator
*
numerator
*
input_pixels
)
/
(
denominator
*
denominator
)
;
}
}
;
int
roundUp
(
int
value_to_round
int
multiple
int
max_value
)
{
const
int
rounded_value
=
(
value_to_round
+
multiple
-
1
)
/
multiple
*
multiple
;
return
rounded_value
<
=
max_value
?
rounded_value
:
(
max_value
/
multiple
*
multiple
)
;
}
Fraction
FindScale
(
int
input_pixels
int
target_pixels
int
max_pixels
)
{
RTC_DCHECK_GT
(
target_pixels
0
)
;
RTC_DCHECK_GT
(
max_pixels
0
)
;
RTC_DCHECK_GE
(
max_pixels
target_pixels
)
;
if
(
target_pixels
>
=
input_pixels
)
return
Fraction
{
1
1
}
;
Fraction
current_scale
=
Fraction
{
1
1
}
;
Fraction
best_scale
=
Fraction
{
1
1
}
;
int
min_pixel_diff
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
;
if
(
input_pixels
<
=
max_pixels
)
{
min_pixel_diff
=
std
:
:
abs
(
input_pixels
-
target_pixels
)
;
}
while
(
current_scale
.
scale_pixel_count
(
input_pixels
)
>
target_pixels
)
{
if
(
current_scale
.
numerator
%
3
=
=
0
&
&
current_scale
.
denominator
%
2
=
=
0
)
{
current_scale
.
numerator
/
=
3
;
current_scale
.
denominator
/
=
2
;
}
else
{
current_scale
.
numerator
*
=
3
;
current_scale
.
denominator
*
=
4
;
}
int
output_pixels
=
current_scale
.
scale_pixel_count
(
input_pixels
)
;
if
(
output_pixels
<
=
max_pixels
)
{
int
diff
=
std
:
:
abs
(
target_pixels
-
output_pixels
)
;
if
(
diff
<
min_pixel_diff
)
{
min_pixel_diff
=
diff
;
best_scale
=
current_scale
;
}
}
}
return
best_scale
;
}
}
namespace
cricket
{
VideoAdapter
:
:
VideoAdapter
(
int
required_resolution_alignment
)
:
frames_in_
(
0
)
frames_out_
(
0
)
frames_scaled_
(
0
)
adaption_changes_
(
0
)
previous_width_
(
0
)
previous_height_
(
0
)
required_resolution_alignment_
(
required_resolution_alignment
)
resolution_request_target_pixel_count_
(
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
resolution_request_max_pixel_count_
(
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
max_framerate_request_
(
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
{
}
VideoAdapter
:
:
VideoAdapter
(
)
:
VideoAdapter
(
1
)
{
}
VideoAdapter
:
:
~
VideoAdapter
(
)
{
}
bool
VideoAdapter
:
:
KeepFrame
(
int64_t
in_timestamp_ns
)
{
rtc
:
:
CritScope
cs
(
&
critical_section_
)
;
if
(
max_framerate_request_
<
=
0
)
return
false
;
int64_t
frame_interval_ns
=
requested_format_
?
requested_format_
-
>
interval
:
0
;
frame_interval_ns
=
std
:
:
max
<
int64_t
>
(
frame_interval_ns
rtc
:
:
kNumNanosecsPerSec
/
max_framerate_request_
)
;
if
(
frame_interval_ns
<
=
0
)
{
return
true
;
}
if
(
next_frame_timestamp_ns_
)
{
const
int64_t
time_until_next_frame_ns
=
(
*
next_frame_timestamp_ns_
-
in_timestamp_ns
)
;
if
(
std
:
:
abs
(
time_until_next_frame_ns
)
<
2
*
frame_interval_ns
)
{
if
(
time_until_next_frame_ns
>
0
)
return
false
;
*
next_frame_timestamp_ns_
+
=
frame_interval_ns
;
return
true
;
}
}
next_frame_timestamp_ns_
=
in_timestamp_ns
+
frame_interval_ns
/
2
;
return
true
;
}
bool
VideoAdapter
:
:
AdaptFrameResolution
(
int
in_width
int
in_height
int64_t
in_timestamp_ns
int
*
cropped_width
int
*
cropped_height
int
*
out_width
int
*
out_height
)
{
rtc
:
:
CritScope
cs
(
&
critical_section_
)
;
+
+
frames_in_
;
int
max_pixel_count
=
resolution_request_max_pixel_count_
;
if
(
scale_
)
{
int
scaled_pixel_count
=
(
in_width
*
in_height
/
scale_resolution_by_
)
/
scale_resolution_by_
;
max_pixel_count
=
std
:
:
min
(
max_pixel_count
scaled_pixel_count
)
;
}
if
(
requested_format_
)
{
max_pixel_count
=
std
:
:
min
(
max_pixel_count
requested_format_
-
>
width
*
requested_format_
-
>
height
)
;
}
int
target_pixel_count
=
std
:
:
min
(
resolution_request_target_pixel_count_
max_pixel_count
)
;
if
(
max_pixel_count
<
=
0
|
|
!
KeepFrame
(
in_timestamp_ns
)
)
{
if
(
(
frames_in_
-
frames_out_
)
%
90
=
=
0
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
VAdapt
Drop
Frame
:
scaled
"
<
<
frames_scaled_
<
<
"
/
out
"
<
<
frames_out_
<
<
"
/
in
"
<
<
frames_in_
<
<
"
Changes
:
"
<
<
adaption_changes_
<
<
"
Input
:
"
<
<
in_width
<
<
"
x
"
<
<
in_height
<
<
"
timestamp
:
"
<
<
in_timestamp_ns
<
<
"
Output
:
i
"
<
<
(
requested_format_
?
requested_format_
-
>
interval
:
0
)
;
}
return
false
;
}
if
(
!
requested_format_
|
|
requested_format_
-
>
width
=
=
0
|
|
requested_format_
-
>
height
=
=
0
)
{
*
cropped_width
=
in_width
;
*
cropped_height
=
in_height
;
}
else
{
if
(
(
in_width
>
in_height
)
!
=
(
requested_format_
-
>
width
>
requested_format_
-
>
height
)
)
{
std
:
:
swap
(
requested_format_
-
>
width
requested_format_
-
>
height
)
;
}
const
float
requested_aspect
=
requested_format_
-
>
width
/
static_cast
<
float
>
(
requested_format_
-
>
height
)
;
*
cropped_width
=
std
:
:
min
(
in_width
static_cast
<
int
>
(
in_height
*
requested_aspect
)
)
;
*
cropped_height
=
std
:
:
min
(
in_height
static_cast
<
int
>
(
in_width
/
requested_aspect
)
)
;
}
const
Fraction
scale
=
FindScale
(
(
*
cropped_width
)
*
(
*
cropped_height
)
target_pixel_count
max_pixel_count
)
;
*
cropped_width
=
roundUp
(
*
cropped_width
scale
.
denominator
*
required_resolution_alignment_
in_width
)
;
*
cropped_height
=
roundUp
(
*
cropped_height
scale
.
denominator
*
required_resolution_alignment_
in_height
)
;
RTC_DCHECK_EQ
(
0
*
cropped_width
%
scale
.
denominator
)
;
RTC_DCHECK_EQ
(
0
*
cropped_height
%
scale
.
denominator
)
;
*
out_width
=
*
cropped_width
/
scale
.
denominator
*
scale
.
numerator
;
*
out_height
=
*
cropped_height
/
scale
.
denominator
*
scale
.
numerator
;
RTC_DCHECK_EQ
(
0
*
out_width
%
required_resolution_alignment_
)
;
RTC_DCHECK_EQ
(
0
*
out_height
%
required_resolution_alignment_
)
;
+
+
frames_out_
;
if
(
scale
.
numerator
!
=
scale
.
denominator
)
+
+
frames_scaled_
;
if
(
(
previous_width_
|
|
scale_
)
&
&
(
previous_width_
!
=
*
out_width
|
|
previous_height_
!
=
*
out_height
)
)
{
+
+
adaption_changes_
;
RTC_LOG
(
LS_INFO
)
<
<
"
Frame
size
changed
:
scaled
"
<
<
frames_scaled_
<
<
"
/
out
"
<
<
frames_out_
<
<
"
/
in
"
<
<
frames_in_
<
<
"
Changes
:
"
<
<
adaption_changes_
<
<
"
Input
:
"
<
<
in_width
<
<
"
x
"
<
<
in_height
<
<
"
Scale
:
"
<
<
scale
.
numerator
<
<
"
/
"
<
<
scale
.
denominator
<
<
"
Output
:
"
<
<
*
out_width
<
<
"
x
"
<
<
*
out_height
<
<
"
i
"
<
<
(
requested_format_
?
requested_format_
-
>
interval
:
0
)
;
}
previous_width_
=
*
out_width
;
previous_height_
=
*
out_height
;
return
true
;
}
void
VideoAdapter
:
:
OnOutputFormatRequest
(
const
VideoFormat
&
format
)
{
rtc
:
:
CritScope
cs
(
&
critical_section_
)
;
requested_format_
=
format
;
next_frame_timestamp_ns_
=
rtc
:
:
nullopt
;
}
void
VideoAdapter
:
:
OnResolutionFramerateRequest
(
const
rtc
:
:
Optional
<
int
>
&
target_pixel_count
int
max_pixel_count
int
max_framerate_fps
)
{
rtc
:
:
CritScope
cs
(
&
critical_section_
)
;
resolution_request_max_pixel_count_
=
max_pixel_count
;
resolution_request_target_pixel_count_
=
target_pixel_count
.
value_or
(
resolution_request_max_pixel_count_
)
;
max_framerate_request_
=
max_framerate_fps
;
}
void
VideoAdapter
:
:
OnScaleResolutionBy
(
rtc
:
:
Optional
<
float
>
scale_resolution_by
)
{
rtc
:
:
CritScope
cs
(
&
critical_section_
)
;
scale_resolution_by_
=
scale_resolution_by
.
value_or
(
1
.
0
)
;
RTC_DCHECK_GE
(
scale_resolution_by_
1
.
0
)
;
scale_
=
static_cast
<
bool
>
(
scale_resolution_by
)
;
}
}
