#
include
"
webrtc
/
api
/
video
/
i420_buffer
.
h
"
#
include
"
webrtc
/
api
/
video
/
video_frame
.
h
"
#
include
"
webrtc
/
media
/
devices
/
gtkvideorenderer
.
h
"
#
include
<
gdk
/
gdk
.
h
>
#
include
<
glib
.
h
>
#
include
<
gtk
/
gtk
.
h
>
#
include
"
libyuv
/
convert_argb
.
h
"
namespace
cricket
{
class
ScopedGdkLock
{
public
:
ScopedGdkLock
(
)
{
gdk_threads_enter
(
)
;
}
~
ScopedGdkLock
(
)
{
gdk_threads_leave
(
)
;
}
}
;
GtkVideoRenderer
:
:
GtkVideoRenderer
(
int
x
int
y
)
:
window_
(
NULL
)
draw_area_
(
NULL
)
initial_x_
(
x
)
initial_y_
(
y
)
width_
(
0
)
height_
(
0
)
{
g_type_init
(
)
;
#
if
!
GLIB_CHECK_VERSION
(
2
31
0
)
g_thread_init
(
NULL
)
;
#
endif
gdk_threads_init
(
)
;
}
GtkVideoRenderer
:
:
~
GtkVideoRenderer
(
)
{
if
(
window_
)
{
ScopedGdkLock
lock
;
gtk_widget_destroy
(
window_
)
;
Pump
(
)
;
}
}
bool
GtkVideoRenderer
:
:
SetSize
(
int
width
int
height
)
{
ScopedGdkLock
lock
;
if
(
width_
=
=
width
&
&
height_
=
=
height
)
{
return
true
;
}
if
(
(
!
window_
&
&
!
Initialize
(
width
height
)
)
|
|
IsClosed
(
)
)
{
return
false
;
}
image_
.
reset
(
new
uint8_t
[
width
*
height
*
4
]
)
;
gtk_widget_set_size_request
(
draw_area_
width
height
)
;
width_
=
width
;
height_
=
height
;
return
true
;
}
void
GtkVideoRenderer
:
:
OnFrame
(
const
webrtc
:
:
VideoFrame
&
video_frame
)
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
buffer
(
video_frame
.
video_frame_buffer
(
)
)
;
if
(
video_frame
.
rotation
(
)
!
=
webrtc
:
:
kVideoRotation_0
)
{
buffer
=
webrtc
:
:
I420Buffer
:
:
Rotate
(
*
buffer
video_frame
.
rotation
(
)
)
;
}
if
(
!
SetSize
(
buffer
-
>
width
(
)
buffer
-
>
height
(
)
)
)
{
return
;
}
libyuv
:
:
I420ToARGB
(
buffer
-
>
DataY
(
)
buffer
-
>
StrideY
(
)
buffer
-
>
DataU
(
)
buffer
-
>
StrideU
(
)
buffer
-
>
DataV
(
)
buffer
-
>
StrideV
(
)
image_
.
get
(
)
buffer
-
>
width
(
)
*
4
buffer
-
>
width
(
)
buffer
-
>
height
(
)
)
;
ScopedGdkLock
lock
;
if
(
IsClosed
(
)
)
{
return
;
}
gdk_draw_rgb_32_image
(
draw_area_
-
>
window
draw_area_
-
>
style
-
>
fg_gc
[
GTK_STATE_NORMAL
]
0
0
buffer
-
>
width
(
)
buffer
-
>
height
(
)
GDK_RGB_DITHER_MAX
image_
.
get
(
)
buffer
-
>
width
(
)
*
4
)
;
Pump
(
)
;
}
bool
GtkVideoRenderer
:
:
Initialize
(
int
width
int
height
)
{
gtk_init
(
NULL
NULL
)
;
window_
=
gtk_window_new
(
GTK_WINDOW_TOPLEVEL
)
;
draw_area_
=
gtk_drawing_area_new
(
)
;
if
(
!
window_
|
|
!
draw_area_
)
{
return
false
;
}
gtk_window_set_position
(
GTK_WINDOW
(
window_
)
GTK_WIN_POS_CENTER
)
;
gtk_window_set_title
(
GTK_WINDOW
(
window_
)
"
Video
Renderer
"
)
;
gtk_window_set_resizable
(
GTK_WINDOW
(
window_
)
FALSE
)
;
gtk_widget_set_size_request
(
draw_area_
width
height
)
;
gtk_container_add
(
GTK_CONTAINER
(
window_
)
draw_area_
)
;
gtk_widget_show_all
(
window_
)
;
gtk_window_move
(
GTK_WINDOW
(
window_
)
initial_x_
initial_y_
)
;
image_
.
reset
(
new
uint8_t
[
width
*
height
*
4
]
)
;
return
true
;
}
void
GtkVideoRenderer
:
:
Pump
(
)
{
while
(
gtk_events_pending
(
)
)
{
gtk_main_iteration
(
)
;
}
}
bool
GtkVideoRenderer
:
:
IsClosed
(
)
const
{
if
(
!
window_
)
{
return
false
;
}
if
(
!
GTK_IS_WINDOW
(
window_
)
|
|
!
GTK_IS_DRAWING_AREA
(
draw_area_
)
)
{
return
true
;
}
return
false
;
}
}
