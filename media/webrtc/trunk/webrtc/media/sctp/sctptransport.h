#
ifndef
MEDIA_SCTP_SCTPTRANSPORT_H_
#
define
MEDIA_SCTP_SCTPTRANSPORT_H_
#
include
<
errno
.
h
>
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
rtc_base
/
asyncinvoker
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
copyonwritebuffer
.
h
"
#
include
"
rtc_base
/
sigslot
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
#
include
"
media
/
base
/
mediachannel
.
h
"
#
include
"
media
/
sctp
/
sctptransportinternal
.
h
"
struct
sockaddr_conn
;
struct
sctp_assoc_change
;
struct
sctp_stream_reset_event
;
struct
socket
;
namespace
cricket
{
struct
SctpInboundPacket
;
class
SctpTransport
:
public
SctpTransportInternal
public
sigslot
:
:
has_slots
<
>
{
public
:
SctpTransport
(
rtc
:
:
Thread
*
network_thread
rtc
:
:
PacketTransportInternal
*
channel
)
;
~
SctpTransport
(
)
override
;
void
SetTransportChannel
(
rtc
:
:
PacketTransportInternal
*
channel
)
override
;
bool
Start
(
int
local_port
int
remote_port
)
override
;
bool
OpenStream
(
int
sid
)
override
;
bool
ResetStream
(
int
sid
)
override
;
bool
SendData
(
const
SendDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
payload
SendDataResult
*
result
=
nullptr
)
override
;
bool
ReadyToSendData
(
)
override
;
void
set_debug_name_for_testing
(
const
char
*
debug_name
)
override
{
debug_name_
=
debug_name
;
}
rtc
:
:
Thread
*
network_thread
(
)
const
{
return
network_thread_
;
}
private
:
void
ConnectTransportChannelSignals
(
)
;
void
DisconnectTransportChannelSignals
(
)
;
bool
Connect
(
)
;
bool
OpenSctpSocket
(
)
;
bool
ConfigureSctpSocket
(
)
;
void
CloseSctpSocket
(
)
;
bool
SendQueuedStreamResets
(
)
;
void
SetReadyToSendData
(
)
;
void
OnWritableState
(
rtc
:
:
PacketTransportInternal
*
transport
)
;
virtual
void
OnPacketRead
(
rtc
:
:
PacketTransportInternal
*
transport
const
char
*
data
size_t
len
const
rtc
:
:
PacketTime
&
packet_time
int
flags
)
;
void
OnSendThresholdCallback
(
)
;
sockaddr_conn
GetSctpSockAddr
(
int
port
)
;
void
OnPacketFromSctpToNetwork
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
void
OnInboundPacketFromSctpToChannel
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
ReceiveDataParams
params
int
flags
)
;
void
OnDataFromSctpToChannel
(
const
ReceiveDataParams
&
params
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
void
OnNotificationFromSctp
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
void
OnNotificationAssocChange
(
const
sctp_assoc_change
&
change
)
;
void
OnStreamResetEvent
(
const
struct
sctp_stream_reset_event
*
evt
)
;
rtc
:
:
Thread
*
network_thread_
;
rtc
:
:
AsyncInvoker
invoker_
;
rtc
:
:
PacketTransportInternal
*
transport_channel_
;
bool
was_ever_writable_
=
false
;
int
local_port_
=
kSctpDefaultPort
;
int
remote_port_
=
kSctpDefaultPort
;
struct
socket
*
sock_
=
nullptr
;
bool
started_
=
false
;
bool
ready_to_send_data_
=
false
;
typedef
std
:
:
set
<
uint32_t
>
StreamSet
;
StreamSet
open_streams_
;
StreamSet
queued_reset_streams_
;
StreamSet
sent_reset_streams_
;
const
char
*
debug_name_
=
"
SctpTransport
"
;
class
UsrSctpWrapper
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
SctpTransport
)
;
}
;
class
SctpTransportFactory
:
public
SctpTransportInternalFactory
{
public
:
explicit
SctpTransportFactory
(
rtc
:
:
Thread
*
network_thread
)
:
network_thread_
(
network_thread
)
{
}
std
:
:
unique_ptr
<
SctpTransportInternal
>
CreateSctpTransport
(
rtc
:
:
PacketTransportInternal
*
channel
)
override
{
return
std
:
:
unique_ptr
<
SctpTransportInternal
>
(
new
SctpTransport
(
network_thread_
channel
)
)
;
}
private
:
rtc
:
:
Thread
*
network_thread_
;
}
;
}
#
endif
