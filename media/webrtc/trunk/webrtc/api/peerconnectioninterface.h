#
ifndef
API_PEERCONNECTIONINTERFACE_H_
#
define
API_PEERCONNECTIONINTERFACE_H_
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
api
/
audio_codecs
/
audio_decoder_factory
.
h
"
#
include
"
api
/
audio_codecs
/
audio_encoder_factory
.
h
"
#
include
"
api
/
datachannelinterface
.
h
"
#
include
"
api
/
dtmfsenderinterface
.
h
"
#
include
"
api
/
jsep
.
h
"
#
include
"
api
/
mediastreaminterface
.
h
"
#
include
"
api
/
rtcerror
.
h
"
#
include
"
api
/
rtceventlogoutput
.
h
"
#
include
"
api
/
rtpreceiverinterface
.
h
"
#
include
"
api
/
rtpsenderinterface
.
h
"
#
include
"
api
/
rtptransceiverinterface
.
h
"
#
include
"
api
/
setremotedescriptionobserverinterface
.
h
"
#
include
"
api
/
stats
/
rtcstatscollectorcallback
.
h
"
#
include
"
api
/
statstypes
.
h
"
#
include
"
api
/
turncustomizer
.
h
"
#
include
"
api
/
umametrics
.
h
"
#
include
"
call
/
callfactoryinterface
.
h
"
#
include
"
logging
/
rtc_event_log
/
rtc_event_log_factory_interface
.
h
"
#
include
"
media
/
base
/
mediachannel
.
h
"
#
include
"
media
/
base
/
videocapturer
.
h
"
#
include
"
p2p
/
base
/
portallocator
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
rtccertificate
.
h
"
#
include
"
rtc_base
/
rtccertificategenerator
.
h
"
#
include
"
rtc_base
/
socketaddress
.
h
"
#
include
"
rtc_base
/
sslstreamadapter
.
h
"
namespace
rtc
{
class
SSLIdentity
;
class
Thread
;
}
namespace
cricket
{
class
MediaEngineInterface
;
class
WebRtcVideoDecoderFactory
;
class
WebRtcVideoEncoderFactory
;
}
namespace
webrtc
{
class
AudioDeviceModule
;
class
AudioMixer
;
class
CallFactoryInterface
;
class
MediaConstraintsInterface
;
class
VideoDecoderFactory
;
class
VideoEncoderFactory
;
class
StreamCollectionInterface
:
public
rtc
:
:
RefCountInterface
{
public
:
virtual
size_t
count
(
)
=
0
;
virtual
MediaStreamInterface
*
at
(
size_t
index
)
=
0
;
virtual
MediaStreamInterface
*
find
(
const
std
:
:
string
&
label
)
=
0
;
virtual
MediaStreamTrackInterface
*
FindAudioTrack
(
const
std
:
:
string
&
id
)
=
0
;
virtual
MediaStreamTrackInterface
*
FindVideoTrack
(
const
std
:
:
string
&
id
)
=
0
;
protected
:
~
StreamCollectionInterface
(
)
{
}
}
;
class
StatsObserver
:
public
rtc
:
:
RefCountInterface
{
public
:
virtual
void
OnComplete
(
const
StatsReports
&
reports
)
=
0
;
protected
:
virtual
~
StatsObserver
(
)
{
}
}
;
enum
class
SdpSemantics
{
kDefault
kPlanB
kUnifiedPlan
}
;
class
PeerConnectionInterface
:
public
rtc
:
:
RefCountInterface
{
public
:
enum
SignalingState
{
kStable
kHaveLocalOffer
kHaveLocalPrAnswer
kHaveRemoteOffer
kHaveRemotePrAnswer
kClosed
}
;
enum
IceGatheringState
{
kIceGatheringNew
kIceGatheringGathering
kIceGatheringComplete
}
;
enum
IceConnectionState
{
kIceConnectionNew
kIceConnectionChecking
kIceConnectionConnected
kIceConnectionCompleted
kIceConnectionFailed
kIceConnectionDisconnected
kIceConnectionClosed
kIceConnectionMax
}
;
enum
TlsCertPolicy
{
kTlsCertPolicySecure
kTlsCertPolicyInsecureNoCheck
}
;
struct
IceServer
{
std
:
:
string
uri
;
std
:
:
vector
<
std
:
:
string
>
urls
;
std
:
:
string
username
;
std
:
:
string
password
;
TlsCertPolicy
tls_cert_policy
=
kTlsCertPolicySecure
;
std
:
:
string
hostname
;
std
:
:
vector
<
std
:
:
string
>
tls_alpn_protocols
;
std
:
:
vector
<
std
:
:
string
>
tls_elliptic_curves
;
bool
operator
=
=
(
const
IceServer
&
o
)
const
{
return
uri
=
=
o
.
uri
&
&
urls
=
=
o
.
urls
&
&
username
=
=
o
.
username
&
&
password
=
=
o
.
password
&
&
tls_cert_policy
=
=
o
.
tls_cert_policy
&
&
hostname
=
=
o
.
hostname
&
&
tls_alpn_protocols
=
=
o
.
tls_alpn_protocols
&
&
tls_elliptic_curves
=
=
o
.
tls_elliptic_curves
;
}
bool
operator
!
=
(
const
IceServer
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
}
;
typedef
std
:
:
vector
<
IceServer
>
IceServers
;
enum
IceTransportsType
{
kNone
kRelay
kNoHost
kAll
}
;
enum
BundlePolicy
{
kBundlePolicyBalanced
kBundlePolicyMaxBundle
kBundlePolicyMaxCompat
}
;
enum
RtcpMuxPolicy
{
kRtcpMuxPolicyNegotiate
kRtcpMuxPolicyRequire
}
;
enum
TcpCandidatePolicy
{
kTcpCandidatePolicyEnabled
kTcpCandidatePolicyDisabled
}
;
enum
CandidateNetworkPolicy
{
kCandidateNetworkPolicyAll
kCandidateNetworkPolicyLowCost
}
;
enum
ContinualGatheringPolicy
{
GATHER_ONCE
GATHER_CONTINUALLY
}
;
enum
class
RTCConfigurationType
{
kSafe
kAggressive
}
;
struct
RTCConfiguration
{
RTCConfiguration
(
)
=
default
;
explicit
RTCConfiguration
(
RTCConfigurationType
type
)
{
if
(
type
=
=
RTCConfigurationType
:
:
kAggressive
)
{
bundle_policy
=
kBundlePolicyMaxBundle
;
rtcp_mux_policy
=
kRtcpMuxPolicyRequire
;
ice_connection_receiving_timeout
=
kAggressiveIceConnectionReceivingTimeout
;
enable_ice_renomination
=
true
;
redetermine_role_on_ice_restart
=
false
;
}
}
bool
operator
=
=
(
const
RTCConfiguration
&
o
)
const
;
bool
operator
!
=
(
const
RTCConfiguration
&
o
)
const
;
bool
dscp
(
)
{
return
media_config
.
enable_dscp
;
}
void
set_dscp
(
bool
enable
)
{
media_config
.
enable_dscp
=
enable
;
}
bool
cpu_adaptation
(
)
{
return
media_config
.
video
.
enable_cpu_overuse_detection
;
}
void
set_cpu_adaptation
(
bool
enable
)
{
media_config
.
video
.
enable_cpu_overuse_detection
=
enable
;
}
bool
suspend_below_min_bitrate
(
)
{
return
media_config
.
video
.
suspend_below_min_bitrate
;
}
void
set_suspend_below_min_bitrate
(
bool
enable
)
{
media_config
.
video
.
suspend_below_min_bitrate
=
enable
;
}
bool
prerenderer_smoothing
(
)
{
return
!
media_config
.
video
.
disable_prerenderer_smoothing
;
}
void
set_prerenderer_smoothing
(
bool
enable
)
{
media_config
.
video
.
disable_prerenderer_smoothing
=
!
enable
;
}
static
const
int
kUndefined
=
-
1
;
static
const
int
kAudioJitterBufferMaxPackets
=
50
;
static
const
int
kAggressiveIceConnectionReceivingTimeout
=
1000
;
IceServers
servers
;
IceTransportsType
type
=
kAll
;
BundlePolicy
bundle_policy
=
kBundlePolicyBalanced
;
RtcpMuxPolicy
rtcp_mux_policy
=
kRtcpMuxPolicyRequire
;
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
rtc
:
:
RTCCertificate
>
>
certificates
;
int
ice_candidate_pool_size
=
0
;
bool
disable_ipv6
=
false
;
bool
disable_ipv6_on_wifi
=
false
;
int
max_ipv6_networks
=
cricket
:
:
kDefaultMaxIPv6Networks
;
bool
enable_rtp_data_channel
=
false
;
rtc
:
:
Optional
<
int
>
screencast_min_bitrate
;
rtc
:
:
Optional
<
bool
>
combined_audio_video_bwe
;
rtc
:
:
Optional
<
bool
>
enable_dtls_srtp
;
TcpCandidatePolicy
tcp_candidate_policy
=
kTcpCandidatePolicyEnabled
;
CandidateNetworkPolicy
candidate_network_policy
=
kCandidateNetworkPolicyAll
;
int
audio_jitter_buffer_max_packets
=
kAudioJitterBufferMaxPackets
;
bool
audio_jitter_buffer_fast_accelerate
=
false
;
int
ice_connection_receiving_timeout
=
kUndefined
;
int
ice_backup_candidate_pair_ping_interval
=
kUndefined
;
ContinualGatheringPolicy
continual_gathering_policy
=
GATHER_ONCE
;
bool
prioritize_most_likely_ice_candidate_pairs
=
false
;
struct
cricket
:
:
MediaConfig
media_config
;
bool
prune_turn_ports
=
false
;
bool
presume_writable_when_fully_relayed
=
false
;
bool
enable_ice_renomination
=
false
;
bool
redetermine_role_on_ice_restart
=
true
;
rtc
:
:
Optional
<
int
>
ice_check_min_interval
;
rtc
:
:
Optional
<
rtc
:
:
IntervalRange
>
ice_regather_interval_range
;
webrtc
:
:
TurnCustomizer
*
turn_customizer
=
nullptr
;
SdpSemantics
sdp_semantics
=
SdpSemantics
:
:
kDefault
;
}
;
struct
RTCOfferAnswerOptions
{
static
const
int
kUndefined
=
-
1
;
static
const
int
kMaxOfferToReceiveMedia
=
1
;
static
const
int
kOfferToReceiveMediaTrue
=
1
;
int
offer_to_receive_video
=
kUndefined
;
int
offer_to_receive_audio
=
kUndefined
;
bool
voice_activity_detection
=
true
;
bool
ice_restart
=
false
;
bool
use_rtp_mux
=
true
;
RTCOfferAnswerOptions
(
)
=
default
;
RTCOfferAnswerOptions
(
int
offer_to_receive_video
int
offer_to_receive_audio
bool
voice_activity_detection
bool
ice_restart
bool
use_rtp_mux
)
:
offer_to_receive_video
(
offer_to_receive_video
)
offer_to_receive_audio
(
offer_to_receive_audio
)
voice_activity_detection
(
voice_activity_detection
)
ice_restart
(
ice_restart
)
use_rtp_mux
(
use_rtp_mux
)
{
}
}
;
enum
StatsOutputLevel
{
kStatsOutputLevelStandard
kStatsOutputLevelDebug
}
;
virtual
rtc
:
:
scoped_refptr
<
StreamCollectionInterface
>
local_streams
(
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
StreamCollectionInterface
>
remote_streams
(
)
=
0
;
virtual
bool
AddStream
(
MediaStreamInterface
*
stream
)
=
0
;
virtual
void
RemoveStream
(
MediaStreamInterface
*
stream
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
AddTrack
(
MediaStreamTrackInterface
*
track
std
:
:
vector
<
MediaStreamInterface
*
>
streams
)
=
0
;
virtual
bool
RemoveTrack
(
RtpSenderInterface
*
sender
)
=
0
;
virtual
RTCErrorOr
<
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
>
AddTransceiver
(
rtc
:
:
scoped_refptr
<
MediaStreamTrackInterface
>
track
)
{
return
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
not
implemented
"
)
;
}
virtual
RTCErrorOr
<
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
>
AddTransceiver
(
rtc
:
:
scoped_refptr
<
MediaStreamTrackInterface
>
track
const
RtpTransceiverInit
&
init
)
{
return
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
not
implemented
"
)
;
}
virtual
RTCErrorOr
<
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
>
AddTransceiver
(
cricket
:
:
MediaType
media_type
)
{
return
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
not
implemented
"
)
;
}
virtual
RTCErrorOr
<
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
>
AddTransceiver
(
cricket
:
:
MediaType
media_type
const
RtpTransceiverInit
&
init
)
{
return
RTCError
(
RTCErrorType
:
:
INTERNAL_ERROR
"
not
implemented
"
)
;
}
virtual
rtc
:
:
scoped_refptr
<
DtmfSenderInterface
>
CreateDtmfSender
(
AudioTrackInterface
*
track
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
CreateSender
(
const
std
:
:
string
&
kind
const
std
:
:
string
&
stream_id
)
{
return
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
(
)
;
}
virtual
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
>
GetSenders
(
)
const
{
return
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
RtpSenderInterface
>
>
(
)
;
}
virtual
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
RtpReceiverInterface
>
>
GetReceivers
(
)
const
{
return
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
RtpReceiverInterface
>
>
(
)
;
}
virtual
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
RtpTransceiverInterface
>
>
GetTransceivers
(
)
const
{
return
{
}
;
}
virtual
bool
GetStats
(
StatsObserver
*
observer
MediaStreamTrackInterface
*
track
StatsOutputLevel
level
)
=
0
;
virtual
void
GetStats
(
RTCStatsCollectorCallback
*
callback
)
{
}
virtual
rtc
:
:
scoped_refptr
<
DataChannelInterface
>
CreateDataChannel
(
const
std
:
:
string
&
label
const
DataChannelInit
*
config
)
=
0
;
virtual
const
SessionDescriptionInterface
*
local_description
(
)
const
=
0
;
virtual
const
SessionDescriptionInterface
*
remote_description
(
)
const
=
0
;
virtual
const
SessionDescriptionInterface
*
current_local_description
(
)
const
{
return
nullptr
;
}
virtual
const
SessionDescriptionInterface
*
current_remote_description
(
)
const
{
return
nullptr
;
}
virtual
const
SessionDescriptionInterface
*
pending_local_description
(
)
const
{
return
nullptr
;
}
virtual
const
SessionDescriptionInterface
*
pending_remote_description
(
)
const
{
return
nullptr
;
}
virtual
void
CreateOffer
(
CreateSessionDescriptionObserver
*
observer
const
MediaConstraintsInterface
*
constraints
)
{
}
virtual
void
CreateOffer
(
CreateSessionDescriptionObserver
*
observer
const
RTCOfferAnswerOptions
&
options
)
{
}
virtual
void
CreateAnswer
(
CreateSessionDescriptionObserver
*
observer
const
RTCOfferAnswerOptions
&
options
)
{
}
virtual
void
CreateAnswer
(
CreateSessionDescriptionObserver
*
observer
const
MediaConstraintsInterface
*
constraints
)
{
}
virtual
void
SetLocalDescription
(
SetSessionDescriptionObserver
*
observer
SessionDescriptionInterface
*
desc
)
=
0
;
virtual
void
SetRemoteDescription
(
SetSessionDescriptionObserver
*
observer
SessionDescriptionInterface
*
desc
)
{
}
virtual
void
SetRemoteDescription
(
std
:
:
unique_ptr
<
SessionDescriptionInterface
>
desc
rtc
:
:
scoped_refptr
<
SetRemoteDescriptionObserverInterface
>
observer
)
{
}
virtual
bool
UpdateIce
(
const
IceServers
&
configuration
const
MediaConstraintsInterface
*
constraints
)
{
return
false
;
}
virtual
bool
UpdateIce
(
const
IceServers
&
configuration
)
{
return
false
;
}
virtual
PeerConnectionInterface
:
:
RTCConfiguration
GetConfiguration
(
)
{
return
PeerConnectionInterface
:
:
RTCConfiguration
(
)
;
}
virtual
bool
SetConfiguration
(
const
PeerConnectionInterface
:
:
RTCConfiguration
&
config
RTCError
*
error
)
{
return
false
;
}
virtual
bool
SetConfiguration
(
const
PeerConnectionInterface
:
:
RTCConfiguration
&
config
)
{
return
false
;
}
virtual
bool
AddIceCandidate
(
const
IceCandidateInterface
*
candidate
)
=
0
;
virtual
bool
RemoveIceCandidates
(
const
std
:
:
vector
<
cricket
:
:
Candidate
>
&
candidates
)
{
return
false
;
}
virtual
void
RegisterUMAObserver
(
UMAObserver
*
observer
)
=
0
;
struct
BitrateParameters
{
rtc
:
:
Optional
<
int
>
min_bitrate_bps
;
rtc
:
:
Optional
<
int
>
current_bitrate_bps
;
rtc
:
:
Optional
<
int
>
max_bitrate_bps
;
}
;
virtual
RTCError
SetBitrate
(
const
BitrateParameters
&
bitrate
)
=
0
;
virtual
void
SetBitrateAllocationStrategy
(
std
:
:
unique_ptr
<
rtc
:
:
BitrateAllocationStrategy
>
bitrate_allocation_strategy
)
{
}
virtual
void
SetAudioPlayout
(
bool
playout
)
{
}
virtual
void
SetAudioRecording
(
bool
recording
)
{
}
virtual
SignalingState
signaling_state
(
)
=
0
;
virtual
IceConnectionState
ice_connection_state
(
)
=
0
;
virtual
IceGatheringState
ice_gathering_state
(
)
=
0
;
virtual
bool
StartRtcEventLog
(
rtc
:
:
PlatformFile
file
int64_t
max_size_bytes
)
{
return
false
;
}
virtual
bool
StartRtcEventLog
(
std
:
:
unique_ptr
<
RtcEventLogOutput
>
output
int64_t
output_period_ms
)
{
return
false
;
}
virtual
void
StopRtcEventLog
(
)
{
}
virtual
void
Close
(
)
=
0
;
protected
:
~
PeerConnectionInterface
(
)
{
}
}
;
class
PeerConnectionObserver
{
public
:
enum
StateType
{
kSignalingState
kIceState
}
;
virtual
void
OnSignalingChange
(
PeerConnectionInterface
:
:
SignalingState
new_state
)
=
0
;
virtual
void
OnAddStream
(
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
stream
)
=
0
;
virtual
void
OnRemoveStream
(
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
stream
)
=
0
;
virtual
void
OnDataChannel
(
rtc
:
:
scoped_refptr
<
DataChannelInterface
>
data_channel
)
=
0
;
virtual
void
OnRenegotiationNeeded
(
)
=
0
;
virtual
void
OnIceConnectionChange
(
PeerConnectionInterface
:
:
IceConnectionState
new_state
)
=
0
;
virtual
void
OnIceGatheringChange
(
PeerConnectionInterface
:
:
IceGatheringState
new_state
)
=
0
;
virtual
void
OnIceCandidate
(
const
IceCandidateInterface
*
candidate
)
=
0
;
virtual
void
OnIceCandidatesRemoved
(
const
std
:
:
vector
<
cricket
:
:
Candidate
>
&
candidates
)
{
}
virtual
void
OnIceConnectionReceivingChange
(
bool
receiving
)
{
}
virtual
void
OnAddTrack
(
rtc
:
:
scoped_refptr
<
RtpReceiverInterface
>
receiver
const
std
:
:
vector
<
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
>
&
streams
)
{
}
virtual
void
OnRemoveTrack
(
rtc
:
:
scoped_refptr
<
RtpReceiverInterface
>
receiver
)
{
}
protected
:
~
PeerConnectionObserver
(
)
{
}
}
;
class
PeerConnectionFactoryInterface
:
public
rtc
:
:
RefCountInterface
{
public
:
class
Options
{
public
:
Options
(
)
:
crypto_options
(
rtc
:
:
CryptoOptions
:
:
NoGcm
(
)
)
{
}
bool
disable_encryption
=
false
;
bool
disable_sctp_data_channels
=
false
;
bool
disable_network_monitor
=
false
;
int
network_ignore_mask
=
rtc
:
:
kDefaultNetworkIgnoreMask
;
rtc
:
:
SSLProtocolVersion
ssl_max_version
=
rtc
:
:
SSL_PROTOCOL_DTLS_12
;
rtc
:
:
CryptoOptions
crypto_options
;
}
;
virtual
void
SetOptions
(
const
Options
&
options
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
PeerConnectionInterface
>
CreatePeerConnection
(
const
PeerConnectionInterface
:
:
RTCConfiguration
&
configuration
std
:
:
unique_ptr
<
cricket
:
:
PortAllocator
>
allocator
std
:
:
unique_ptr
<
rtc
:
:
RTCCertificateGeneratorInterface
>
cert_generator
PeerConnectionObserver
*
observer
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
PeerConnectionInterface
>
CreatePeerConnection
(
const
PeerConnectionInterface
:
:
RTCConfiguration
&
configuration
const
MediaConstraintsInterface
*
constraints
std
:
:
unique_ptr
<
cricket
:
:
PortAllocator
>
allocator
std
:
:
unique_ptr
<
rtc
:
:
RTCCertificateGeneratorInterface
>
cert_generator
PeerConnectionObserver
*
observer
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
MediaStreamInterface
>
CreateLocalMediaStream
(
const
std
:
:
string
&
label
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
AudioSourceInterface
>
CreateAudioSource
(
const
cricket
:
:
AudioOptions
&
options
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
AudioSourceInterface
>
CreateAudioSource
(
const
MediaConstraintsInterface
*
constraints
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
VideoTrackSourceInterface
>
CreateVideoSource
(
std
:
:
unique_ptr
<
cricket
:
:
VideoCapturer
>
capturer
)
{
return
nullptr
;
}
virtual
rtc
:
:
scoped_refptr
<
VideoTrackSourceInterface
>
CreateVideoSource
(
std
:
:
unique_ptr
<
cricket
:
:
VideoCapturer
>
capturer
const
MediaConstraintsInterface
*
constraints
)
{
return
nullptr
;
}
virtual
rtc
:
:
scoped_refptr
<
VideoTrackSourceInterface
>
CreateVideoSource
(
cricket
:
:
VideoCapturer
*
capturer
)
{
return
CreateVideoSource
(
std
:
:
unique_ptr
<
cricket
:
:
VideoCapturer
>
(
capturer
)
)
;
}
virtual
rtc
:
:
scoped_refptr
<
VideoTrackSourceInterface
>
CreateVideoSource
(
cricket
:
:
VideoCapturer
*
capturer
const
MediaConstraintsInterface
*
constraints
)
{
return
CreateVideoSource
(
std
:
:
unique_ptr
<
cricket
:
:
VideoCapturer
>
(
capturer
)
constraints
)
;
}
virtual
rtc
:
:
scoped_refptr
<
VideoTrackInterface
>
CreateVideoTrack
(
const
std
:
:
string
&
label
VideoTrackSourceInterface
*
source
)
=
0
;
virtual
rtc
:
:
scoped_refptr
<
AudioTrackInterface
>
CreateAudioTrack
(
const
std
:
:
string
&
label
AudioSourceInterface
*
source
)
=
0
;
virtual
bool
StartAecDump
(
rtc
:
:
PlatformFile
file
int64_t
max_size_bytes
)
=
0
;
virtual
void
StopAecDump
(
)
=
0
;
protected
:
PeerConnectionFactoryInterface
(
)
{
}
~
PeerConnectionFactoryInterface
(
)
{
}
}
;
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
CreatePeerConnectionFactory
(
rtc
:
:
scoped_refptr
<
AudioEncoderFactory
>
audio_encoder_factory
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
audio_decoder_factory
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
CreatePeerConnectionFactory
(
rtc
:
:
Thread
*
network_thread
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
signaling_thread
AudioDeviceModule
*
default_adm
rtc
:
:
scoped_refptr
<
AudioEncoderFactory
>
audio_encoder_factory
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
audio_decoder_factory
cricket
:
:
WebRtcVideoEncoderFactory
*
video_encoder_factory
cricket
:
:
WebRtcVideoDecoderFactory
*
video_decoder_factory
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
CreatePeerConnectionFactory
(
rtc
:
:
Thread
*
network_thread
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
signaling_thread
AudioDeviceModule
*
default_adm
rtc
:
:
scoped_refptr
<
AudioEncoderFactory
>
audio_encoder_factory
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
audio_decoder_factory
cricket
:
:
WebRtcVideoEncoderFactory
*
video_encoder_factory
cricket
:
:
WebRtcVideoDecoderFactory
*
video_decoder_factory
rtc
:
:
scoped_refptr
<
AudioMixer
>
audio_mixer
rtc
:
:
scoped_refptr
<
AudioProcessing
>
audio_processing
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
CreatePeerConnectionFactory
(
rtc
:
:
Thread
*
network_thread
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
signaling_thread
rtc
:
:
scoped_refptr
<
AudioDeviceModule
>
default_adm
rtc
:
:
scoped_refptr
<
AudioEncoderFactory
>
audio_encoder_factory
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
audio_decoder_factory
std
:
:
unique_ptr
<
VideoEncoderFactory
>
video_encoder_factory
std
:
:
unique_ptr
<
VideoDecoderFactory
>
video_decoder_factory
rtc
:
:
scoped_refptr
<
AudioMixer
>
audio_mixer
rtc
:
:
scoped_refptr
<
AudioProcessing
>
audio_processing
)
;
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
CreatePeerConnectionFactoryWithAudioMixer
(
rtc
:
:
Thread
*
network_thread
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
signaling_thread
AudioDeviceModule
*
default_adm
rtc
:
:
scoped_refptr
<
AudioEncoderFactory
>
audio_encoder_factory
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
audio_decoder_factory
cricket
:
:
WebRtcVideoEncoderFactory
*
video_encoder_factory
cricket
:
:
WebRtcVideoDecoderFactory
*
video_decoder_factory
rtc
:
:
scoped_refptr
<
AudioMixer
>
audio_mixer
)
;
inline
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
CreatePeerConnectionFactory
(
rtc
:
:
Thread
*
worker_and_network_thread
rtc
:
:
Thread
*
signaling_thread
AudioDeviceModule
*
default_adm
rtc
:
:
scoped_refptr
<
AudioEncoderFactory
>
audio_encoder_factory
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
audio_decoder_factory
cricket
:
:
WebRtcVideoEncoderFactory
*
video_encoder_factory
cricket
:
:
WebRtcVideoDecoderFactory
*
video_decoder_factory
)
{
return
CreatePeerConnectionFactory
(
worker_and_network_thread
worker_and_network_thread
signaling_thread
default_adm
audio_encoder_factory
audio_decoder_factory
video_encoder_factory
video_decoder_factory
)
;
}
rtc
:
:
scoped_refptr
<
PeerConnectionFactoryInterface
>
CreateModularPeerConnectionFactory
(
rtc
:
:
Thread
*
network_thread
rtc
:
:
Thread
*
worker_thread
rtc
:
:
Thread
*
signaling_thread
std
:
:
unique_ptr
<
cricket
:
:
MediaEngineInterface
>
media_engine
std
:
:
unique_ptr
<
CallFactoryInterface
>
call_factory
std
:
:
unique_ptr
<
RtcEventLogFactoryInterface
>
event_log_factory
)
;
}
#
endif
