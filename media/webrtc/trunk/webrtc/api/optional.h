#
ifndef
API_OPTIONAL_H_
#
define
API_OPTIONAL_H_
#
include
<
algorithm
>
#
include
<
memory
>
#
include
<
utility
>
#
ifdef
UNIT_TEST
#
include
<
iomanip
>
#
include
<
ostream
>
#
endif
#
include
"
api
/
array_view
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
sanitizer
.
h
"
namespace
rtc
{
namespace
optional_internal
{
#
if
RTC_HAS_ASAN
void
*
FunctionThatDoesNothingImpl
(
void
*
)
;
template
<
typename
T
>
inline
T
*
FunctionThatDoesNothing
(
T
*
x
)
{
return
reinterpret_cast
<
T
*
>
(
FunctionThatDoesNothingImpl
(
reinterpret_cast
<
void
*
>
(
x
)
)
)
;
}
#
else
template
<
typename
T
>
inline
T
*
FunctionThatDoesNothing
(
T
*
x
)
{
return
x
;
}
#
endif
struct
NulloptArg
;
}
struct
nullopt_t
{
constexpr
explicit
nullopt_t
(
rtc
:
:
optional_internal
:
:
NulloptArg
&
)
{
}
}
;
extern
const
nullopt_t
nullopt
;
template
<
typename
T
>
class
Optional
final
{
public
:
Optional
(
)
:
has_value_
(
false
)
empty_
(
'
\
0
'
)
{
PoisonValue
(
)
;
}
Optional
(
rtc
:
:
nullopt_t
)
:
Optional
(
)
{
}
Optional
(
const
T
&
value
)
:
has_value_
(
true
)
{
new
(
&
value_
)
T
(
value
)
;
}
Optional
(
T
&
&
value
)
:
has_value_
(
true
)
{
new
(
&
value_
)
T
(
std
:
:
move
(
value
)
)
;
}
Optional
(
const
Optional
&
m
)
:
has_value_
(
m
.
has_value_
)
{
if
(
has_value_
)
new
(
&
value_
)
T
(
m
.
value_
)
;
else
PoisonValue
(
)
;
}
Optional
(
Optional
&
&
m
)
:
has_value_
(
m
.
has_value_
)
{
if
(
has_value_
)
new
(
&
value_
)
T
(
std
:
:
move
(
m
.
value_
)
)
;
else
PoisonValue
(
)
;
}
~
Optional
(
)
{
if
(
has_value_
)
value_
.
~
T
(
)
;
else
UnpoisonValue
(
)
;
}
Optional
&
operator
=
(
rtc
:
:
nullopt_t
)
{
reset
(
)
;
return
*
this
;
}
Optional
&
operator
=
(
const
Optional
&
m
)
{
if
(
m
.
has_value_
)
{
if
(
has_value_
)
{
value_
=
m
.
value_
;
}
else
{
UnpoisonValue
(
)
;
new
(
&
value_
)
T
(
m
.
value_
)
;
has_value_
=
true
;
}
}
else
{
reset
(
)
;
}
return
*
this
;
}
Optional
&
operator
=
(
Optional
&
&
m
)
{
if
(
m
.
has_value_
)
{
if
(
has_value_
)
{
value_
=
std
:
:
move
(
m
.
value_
)
;
}
else
{
UnpoisonValue
(
)
;
new
(
&
value_
)
T
(
std
:
:
move
(
m
.
value_
)
)
;
has_value_
=
true
;
}
}
else
{
reset
(
)
;
}
return
*
this
;
}
friend
void
swap
(
Optional
&
m1
Optional
&
m2
)
{
if
(
m1
.
has_value_
)
{
if
(
m2
.
has_value_
)
{
using
std
:
:
swap
;
swap
(
m1
.
value_
m2
.
value_
)
;
}
else
{
m2
.
UnpoisonValue
(
)
;
new
(
&
m2
.
value_
)
T
(
std
:
:
move
(
m1
.
value_
)
)
;
m1
.
value_
.
~
T
(
)
;
m1
.
has_value_
=
false
;
m2
.
has_value_
=
true
;
m1
.
PoisonValue
(
)
;
}
}
else
if
(
m2
.
has_value_
)
{
m1
.
UnpoisonValue
(
)
;
new
(
&
m1
.
value_
)
T
(
std
:
:
move
(
m2
.
value_
)
)
;
m2
.
value_
.
~
T
(
)
;
m1
.
has_value_
=
true
;
m2
.
has_value_
=
false
;
m2
.
PoisonValue
(
)
;
}
}
void
reset
(
)
{
if
(
!
has_value_
)
return
;
value_
.
~
T
(
)
;
has_value_
=
false
;
PoisonValue
(
)
;
}
template
<
class
.
.
.
Args
>
void
emplace
(
Args
&
&
.
.
.
args
)
{
if
(
has_value_
)
value_
.
~
T
(
)
;
else
UnpoisonValue
(
)
;
new
(
&
value_
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
has_value_
=
true
;
}
explicit
operator
bool
(
)
const
{
return
has_value_
;
}
bool
has_value
(
)
const
{
return
has_value_
;
}
const
T
*
operator
-
>
(
)
const
{
RTC_DCHECK
(
has_value_
)
;
return
&
value_
;
}
T
*
operator
-
>
(
)
{
RTC_DCHECK
(
has_value_
)
;
return
&
value_
;
}
const
T
&
operator
*
(
)
const
{
RTC_DCHECK
(
has_value_
)
;
return
value_
;
}
T
&
operator
*
(
)
{
RTC_DCHECK
(
has_value_
)
;
return
value_
;
}
const
T
&
value
(
)
const
{
RTC_DCHECK
(
has_value_
)
;
return
value_
;
}
T
&
value
(
)
{
RTC_DCHECK
(
has_value_
)
;
return
value_
;
}
const
T
&
value_or
(
const
T
&
default_val
)
const
{
return
has_value_
?
*
optional_internal
:
:
FunctionThatDoesNothing
(
&
value_
)
:
default_val
;
}
T
MoveValue
(
)
{
RTC_DCHECK
(
has_value_
)
;
return
std
:
:
move
(
value_
)
;
}
friend
bool
operator
=
=
(
const
Optional
&
m1
const
Optional
&
m2
)
{
return
m1
.
has_value_
&
&
m2
.
has_value_
?
m1
.
value_
=
=
m2
.
value_
:
m1
.
has_value_
=
=
m2
.
has_value_
;
}
friend
bool
operator
=
=
(
const
Optional
&
opt
const
T
&
value
)
{
return
opt
.
has_value_
&
&
opt
.
value_
=
=
value
;
}
friend
bool
operator
=
=
(
const
T
&
value
const
Optional
&
opt
)
{
return
opt
.
has_value_
&
&
value
=
=
opt
.
value_
;
}
friend
bool
operator
=
=
(
const
Optional
&
opt
rtc
:
:
nullopt_t
)
{
return
!
opt
.
has_value_
;
}
friend
bool
operator
=
=
(
rtc
:
:
nullopt_t
const
Optional
&
opt
)
{
return
!
opt
.
has_value_
;
}
friend
bool
operator
!
=
(
const
Optional
&
m1
const
Optional
&
m2
)
{
return
m1
.
has_value_
&
&
m2
.
has_value_
?
m1
.
value_
!
=
m2
.
value_
:
m1
.
has_value_
!
=
m2
.
has_value_
;
}
friend
bool
operator
!
=
(
const
Optional
&
opt
const
T
&
value
)
{
return
!
opt
.
has_value_
|
|
opt
.
value_
!
=
value
;
}
friend
bool
operator
!
=
(
const
T
&
value
const
Optional
&
opt
)
{
return
!
opt
.
has_value_
|
|
value
!
=
opt
.
value_
;
}
friend
bool
operator
!
=
(
const
Optional
&
opt
rtc
:
:
nullopt_t
)
{
return
opt
.
has_value_
;
}
friend
bool
operator
!
=
(
rtc
:
:
nullopt_t
const
Optional
&
opt
)
{
return
opt
.
has_value_
;
}
private
:
void
PoisonValue
(
)
{
rtc
:
:
AsanPoison
(
rtc
:
:
MakeArrayView
(
&
value_
1
)
)
;
rtc
:
:
MsanMarkUninitialized
(
rtc
:
:
MakeArrayView
(
&
value_
1
)
)
;
}
void
UnpoisonValue
(
)
{
rtc
:
:
AsanUnpoison
(
rtc
:
:
MakeArrayView
(
&
value_
1
)
)
;
}
bool
has_value_
;
union
{
char
empty_
;
T
value_
;
}
;
}
;
#
ifdef
UNIT_TEST
namespace
optional_internal
{
template
<
typename
T
>
struct
HasPrintTo
{
private
:
struct
No
{
}
;
template
<
typename
T2
>
static
auto
Test
(
const
T2
&
obj
)
-
>
decltype
(
PrintTo
(
obj
std
:
:
declval
<
std
:
:
ostream
*
>
(
)
)
)
;
template
<
typename
>
static
No
Test
(
.
.
.
)
;
public
:
static
constexpr
bool
value
=
!
std
:
:
is_same
<
decltype
(
Test
<
T
>
(
std
:
:
declval
<
const
T
&
>
(
)
)
)
No
>
:
:
value
;
}
;
template
<
typename
T
>
struct
HasOstreamOperator
{
private
:
struct
No
{
}
;
template
<
typename
T2
>
static
auto
Test
(
const
T2
&
obj
)
-
>
decltype
(
std
:
:
declval
<
std
:
:
ostream
&
>
(
)
<
<
obj
)
;
template
<
typename
>
static
No
Test
(
.
.
.
)
;
public
:
static
constexpr
bool
value
=
!
std
:
:
is_same
<
decltype
(
Test
<
T
>
(
std
:
:
declval
<
const
T
&
>
(
)
)
)
No
>
:
:
value
;
}
;
template
<
typename
T
>
typename
std
:
:
enable_if
<
HasPrintTo
<
T
>
:
:
value
void
>
:
:
type
OptionalPrintToHelper
(
const
T
&
value
std
:
:
ostream
*
os
)
{
PrintTo
(
value
os
)
;
}
template
<
typename
T
>
typename
std
:
:
enable_if
<
HasOstreamOperator
<
T
>
:
:
value
&
&
!
HasPrintTo
<
T
>
:
:
value
void
>
:
:
type
OptionalPrintToHelper
(
const
T
&
value
std
:
:
ostream
*
os
)
{
*
os
<
<
value
;
}
inline
void
OptionalPrintObjectBytes
(
const
unsigned
char
*
bytes
size_t
size
std
:
:
ostream
*
os
)
{
*
os
<
<
"
<
optional
with
"
<
<
size
<
<
"
-
byte
object
[
"
;
for
(
size_t
i
=
0
;
i
!
=
size
;
+
+
i
)
{
*
os
<
<
(
i
=
=
0
?
"
"
:
(
(
i
&
1
)
?
"
-
"
:
"
"
)
)
;
*
os
<
<
std
:
:
hex
<
<
std
:
:
setw
(
2
)
<
<
std
:
:
setfill
(
'
0
'
)
<
<
static_cast
<
int
>
(
bytes
[
i
]
)
;
}
*
os
<
<
"
]
>
"
;
}
template
<
typename
T
>
typename
std
:
:
enable_if
<
!
HasOstreamOperator
<
T
>
:
:
value
&
&
!
HasPrintTo
<
T
>
:
:
value
void
>
:
:
type
OptionalPrintToHelper
(
const
T
&
value
std
:
:
ostream
*
os
)
{
OptionalPrintObjectBytes
(
reinterpret_cast
<
const
unsigned
char
*
>
(
&
value
)
sizeof
(
value
)
os
)
;
}
}
template
<
typename
T
>
void
PrintTo
(
const
rtc
:
:
Optional
<
T
>
&
opt
std
:
:
ostream
*
os
)
{
if
(
opt
)
{
optional_internal
:
:
OptionalPrintToHelper
(
*
opt
os
)
;
}
else
{
*
os
<
<
"
<
empty
optional
>
"
;
}
}
#
endif
}
#
endif
