#
include
"
webrtc
/
api
/
test
/
fakeaudiocapturemodule
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
common
.
h
"
#
include
"
webrtc
/
base
/
refcount
.
h
"
#
include
"
webrtc
/
base
/
thread
.
h
"
#
include
"
webrtc
/
base
/
timeutils
.
h
"
static
const
int
kHighSampleValue
=
10000
;
static
const
int
kAdmMaxIdleTimeProcess
=
1000
;
static
const
int
kTimePerFrameMs
=
10
;
static
const
uint8_t
kNumberOfChannels
=
1
;
static
const
int
kSamplesPerSecond
=
44000
;
static
const
int
kTotalDelayMs
=
0
;
static
const
int
kClockDriftMs
=
0
;
static
const
uint32_t
kMaxVolume
=
14392
;
enum
{
MSG_START_PROCESS
MSG_RUN_PROCESS
}
;
FakeAudioCaptureModule
:
:
FakeAudioCaptureModule
(
)
:
last_process_time_ms_
(
0
)
audio_callback_
(
nullptr
)
recording_
(
false
)
playing_
(
false
)
play_is_initialized_
(
false
)
rec_is_initialized_
(
false
)
current_mic_level_
(
kMaxVolume
)
started_
(
false
)
next_frame_time_
(
0
)
frames_received_
(
0
)
{
}
FakeAudioCaptureModule
:
:
~
FakeAudioCaptureModule
(
)
{
if
(
process_thread_
)
{
process_thread_
-
>
Stop
(
)
;
}
}
rtc
:
:
scoped_refptr
<
FakeAudioCaptureModule
>
FakeAudioCaptureModule
:
:
Create
(
)
{
rtc
:
:
scoped_refptr
<
FakeAudioCaptureModule
>
capture_module
(
new
rtc
:
:
RefCountedObject
<
FakeAudioCaptureModule
>
(
)
)
;
if
(
!
capture_module
-
>
Initialize
(
)
)
{
return
nullptr
;
}
return
capture_module
;
}
int
FakeAudioCaptureModule
:
:
frames_received
(
)
const
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
return
frames_received_
;
}
int64_t
FakeAudioCaptureModule
:
:
TimeUntilNextProcess
(
)
{
const
int64_t
current_time
=
rtc
:
:
TimeMillis
(
)
;
if
(
current_time
<
last_process_time_ms_
)
{
return
0
;
}
const
int64_t
elapsed_time
=
current_time
-
last_process_time_ms_
;
if
(
kAdmMaxIdleTimeProcess
<
elapsed_time
)
{
return
0
;
}
return
kAdmMaxIdleTimeProcess
-
elapsed_time
;
}
void
FakeAudioCaptureModule
:
:
Process
(
)
{
last_process_time_ms_
=
rtc
:
:
TimeMillis
(
)
;
}
int32_t
FakeAudioCaptureModule
:
:
ActiveAudioLayer
(
AudioLayer
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
webrtc
:
:
AudioDeviceModule
:
:
ErrorCode
FakeAudioCaptureModule
:
:
LastError
(
)
const
{
RTC_NOTREACHED
(
)
;
return
webrtc
:
:
AudioDeviceModule
:
:
kAdmErrNone
;
}
int32_t
FakeAudioCaptureModule
:
:
RegisterEventObserver
(
webrtc
:
:
AudioDeviceObserver
*
)
{
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
RegisterAudioCallback
(
webrtc
:
:
AudioTransport
*
audio_callback
)
{
rtc
:
:
CritScope
cs
(
&
crit_callback_
)
;
audio_callback_
=
audio_callback
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
Init
(
)
{
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
Terminate
(
)
{
return
0
;
}
bool
FakeAudioCaptureModule
:
:
Initialized
(
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int16_t
FakeAudioCaptureModule
:
:
PlayoutDevices
(
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int16_t
FakeAudioCaptureModule
:
:
RecordingDevices
(
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
PlayoutDeviceName
(
uint16_t
char
[
webrtc
:
:
kAdmMaxDeviceNameSize
]
char
[
webrtc
:
:
kAdmMaxGuidSize
]
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
RecordingDeviceName
(
uint16_t
char
[
webrtc
:
:
kAdmMaxDeviceNameSize
]
char
[
webrtc
:
:
kAdmMaxGuidSize
]
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetPlayoutDevice
(
uint16_t
)
{
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetPlayoutDevice
(
WindowsDeviceType
)
{
if
(
play_is_initialized_
)
{
return
-
1
;
}
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetRecordingDevice
(
uint16_t
)
{
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetRecordingDevice
(
WindowsDeviceType
)
{
if
(
rec_is_initialized_
)
{
return
-
1
;
}
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
PlayoutIsAvailable
(
bool
*
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
InitPlayout
(
)
{
play_is_initialized_
=
true
;
return
0
;
}
bool
FakeAudioCaptureModule
:
:
PlayoutIsInitialized
(
)
const
{
return
play_is_initialized_
;
}
int32_t
FakeAudioCaptureModule
:
:
RecordingIsAvailable
(
bool
*
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
InitRecording
(
)
{
rec_is_initialized_
=
true
;
return
0
;
}
bool
FakeAudioCaptureModule
:
:
RecordingIsInitialized
(
)
const
{
return
rec_is_initialized_
;
}
int32_t
FakeAudioCaptureModule
:
:
StartPlayout
(
)
{
if
(
!
play_is_initialized_
)
{
return
-
1
;
}
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
playing_
=
true
;
}
bool
start
=
true
;
UpdateProcessing
(
start
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
StopPlayout
(
)
{
bool
start
=
false
;
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
playing_
=
false
;
start
=
ShouldStartProcessing
(
)
;
}
UpdateProcessing
(
start
)
;
return
0
;
}
bool
FakeAudioCaptureModule
:
:
Playing
(
)
const
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
return
playing_
;
}
int32_t
FakeAudioCaptureModule
:
:
StartRecording
(
)
{
if
(
!
rec_is_initialized_
)
{
return
-
1
;
}
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
recording_
=
true
;
}
bool
start
=
true
;
UpdateProcessing
(
start
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
StopRecording
(
)
{
bool
start
=
false
;
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
recording_
=
false
;
start
=
ShouldStartProcessing
(
)
;
}
UpdateProcessing
(
start
)
;
return
0
;
}
bool
FakeAudioCaptureModule
:
:
Recording
(
)
const
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
return
recording_
;
}
int32_t
FakeAudioCaptureModule
:
:
SetAGC
(
bool
)
{
return
0
;
}
bool
FakeAudioCaptureModule
:
:
AGC
(
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetWaveOutVolume
(
uint16_t
uint16_t
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
WaveOutVolume
(
uint16_t
*
uint16_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
InitSpeaker
(
)
{
return
0
;
}
bool
FakeAudioCaptureModule
:
:
SpeakerIsInitialized
(
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
InitMicrophone
(
)
{
return
0
;
}
bool
FakeAudioCaptureModule
:
:
MicrophoneIsInitialized
(
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SpeakerVolumeIsAvailable
(
bool
*
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetSpeakerVolume
(
uint32_t
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SpeakerVolume
(
uint32_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MaxSpeakerVolume
(
uint32_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MinSpeakerVolume
(
uint32_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SpeakerVolumeStepSize
(
uint16_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MicrophoneVolumeIsAvailable
(
bool
*
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetMicrophoneVolume
(
uint32_t
volume
)
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
current_mic_level_
=
volume
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MicrophoneVolume
(
uint32_t
*
volume
)
const
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
*
volume
=
current_mic_level_
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MaxMicrophoneVolume
(
uint32_t
*
max_volume
)
const
{
*
max_volume
=
kMaxVolume
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MinMicrophoneVolume
(
uint32_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MicrophoneVolumeStepSize
(
uint16_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SpeakerMuteIsAvailable
(
bool
*
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetSpeakerMute
(
bool
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SpeakerMute
(
bool
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MicrophoneMuteIsAvailable
(
bool
*
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetMicrophoneMute
(
bool
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MicrophoneMute
(
bool
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MicrophoneBoostIsAvailable
(
bool
*
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetMicrophoneBoost
(
bool
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
MicrophoneBoost
(
bool
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
StereoPlayoutIsAvailable
(
bool
*
available
)
const
{
*
available
=
true
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetStereoPlayout
(
bool
)
{
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
StereoPlayout
(
bool
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
StereoRecordingIsAvailable
(
bool
*
available
)
const
{
*
available
=
false
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetStereoRecording
(
bool
enable
)
{
if
(
!
enable
)
{
return
0
;
}
return
-
1
;
}
int32_t
FakeAudioCaptureModule
:
:
StereoRecording
(
bool
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetRecordingChannel
(
const
ChannelType
channel
)
{
if
(
channel
!
=
AudioDeviceModule
:
:
kChannelBoth
)
{
RTC_NOTREACHED
(
)
;
return
-
1
;
}
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
RecordingChannel
(
ChannelType
*
channel
)
const
{
*
channel
=
AudioDeviceModule
:
:
kChannelBoth
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetPlayoutBuffer
(
const
BufferType
uint16_t
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
PlayoutBuffer
(
BufferType
*
uint16_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
PlayoutDelay
(
uint16_t
*
delay_ms
)
const
{
*
delay_ms
=
0
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
RecordingDelay
(
uint16_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
CPULoad
(
uint16_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
StartRawOutputFileRecording
(
const
char
[
webrtc
:
:
kAdmMaxFileNameSize
]
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
StopRawOutputFileRecording
(
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
StartRawInputFileRecording
(
const
char
[
webrtc
:
:
kAdmMaxFileNameSize
]
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
StopRawInputFileRecording
(
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetRecordingSampleRate
(
const
uint32_t
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
RecordingSampleRate
(
uint32_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetPlayoutSampleRate
(
const
uint32_t
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
PlayoutSampleRate
(
uint32_t
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
ResetAudioDevice
(
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
SetLoudspeakerStatus
(
bool
)
{
RTC_NOTREACHED
(
)
;
return
0
;
}
int32_t
FakeAudioCaptureModule
:
:
GetLoudspeakerStatus
(
bool
*
)
const
{
RTC_NOTREACHED
(
)
;
return
0
;
}
void
FakeAudioCaptureModule
:
:
OnMessage
(
rtc
:
:
Message
*
msg
)
{
switch
(
msg
-
>
message_id
)
{
case
MSG_START_PROCESS
:
StartProcessP
(
)
;
break
;
case
MSG_RUN_PROCESS
:
ProcessFrameP
(
)
;
break
;
default
:
RTC_NOTREACHED
(
)
;
}
}
bool
FakeAudioCaptureModule
:
:
Initialize
(
)
{
SetSendBuffer
(
kHighSampleValue
)
;
last_process_time_ms_
=
rtc
:
:
TimeMillis
(
)
;
return
true
;
}
void
FakeAudioCaptureModule
:
:
SetSendBuffer
(
int
value
)
{
Sample
*
buffer_ptr
=
reinterpret_cast
<
Sample
*
>
(
send_buffer_
)
;
const
size_t
buffer_size_in_samples
=
sizeof
(
send_buffer_
)
/
kNumberBytesPerSample
;
for
(
size_t
i
=
0
;
i
<
buffer_size_in_samples
;
+
+
i
)
{
buffer_ptr
[
i
]
=
value
;
}
}
void
FakeAudioCaptureModule
:
:
ResetRecBuffer
(
)
{
memset
(
rec_buffer_
0
sizeof
(
rec_buffer_
)
)
;
}
bool
FakeAudioCaptureModule
:
:
CheckRecBuffer
(
int
value
)
{
const
Sample
*
buffer_ptr
=
reinterpret_cast
<
const
Sample
*
>
(
rec_buffer_
)
;
const
size_t
buffer_size_in_samples
=
sizeof
(
rec_buffer_
)
/
kNumberBytesPerSample
;
for
(
size_t
i
=
0
;
i
<
buffer_size_in_samples
;
+
+
i
)
{
if
(
buffer_ptr
[
i
]
>
=
value
)
return
true
;
}
return
false
;
}
bool
FakeAudioCaptureModule
:
:
ShouldStartProcessing
(
)
{
return
recording_
|
|
playing_
;
}
void
FakeAudioCaptureModule
:
:
UpdateProcessing
(
bool
start
)
{
if
(
start
)
{
if
(
!
process_thread_
)
{
process_thread_
.
reset
(
new
rtc
:
:
Thread
(
)
)
;
process_thread_
-
>
Start
(
)
;
}
process_thread_
-
>
Post
(
RTC_FROM_HERE
this
MSG_START_PROCESS
)
;
}
else
{
if
(
process_thread_
)
{
process_thread_
-
>
Stop
(
)
;
process_thread_
.
reset
(
nullptr
)
;
}
started_
=
false
;
}
}
void
FakeAudioCaptureModule
:
:
StartProcessP
(
)
{
ASSERT
(
process_thread_
-
>
IsCurrent
(
)
)
;
if
(
started_
)
{
return
;
}
ProcessFrameP
(
)
;
}
void
FakeAudioCaptureModule
:
:
ProcessFrameP
(
)
{
ASSERT
(
process_thread_
-
>
IsCurrent
(
)
)
;
if
(
!
started_
)
{
next_frame_time_
=
rtc
:
:
TimeMillis
(
)
;
started_
=
true
;
}
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
if
(
playing_
)
{
ReceiveFrameP
(
)
;
}
if
(
recording_
)
{
SendFrameP
(
)
;
}
}
next_frame_time_
+
=
kTimePerFrameMs
;
const
int64_t
current_time
=
rtc
:
:
TimeMillis
(
)
;
const
int64_t
wait_time
=
(
next_frame_time_
>
current_time
)
?
next_frame_time_
-
current_time
:
0
;
process_thread_
-
>
PostDelayed
(
RTC_FROM_HERE
wait_time
this
MSG_RUN_PROCESS
)
;
}
void
FakeAudioCaptureModule
:
:
ReceiveFrameP
(
)
{
ASSERT
(
process_thread_
-
>
IsCurrent
(
)
)
;
{
rtc
:
:
CritScope
cs
(
&
crit_callback_
)
;
if
(
!
audio_callback_
)
{
return
;
}
ResetRecBuffer
(
)
;
size_t
nSamplesOut
=
0
;
int64_t
elapsed_time_ms
=
0
;
int64_t
ntp_time_ms
=
0
;
if
(
audio_callback_
-
>
NeedMorePlayData
(
kNumberSamples
kNumberBytesPerSample
kNumberOfChannels
kSamplesPerSecond
rec_buffer_
nSamplesOut
&
elapsed_time_ms
&
ntp_time_ms
)
!
=
0
)
{
RTC_NOTREACHED
(
)
;
}
ASSERT
(
nSamplesOut
=
=
kNumberSamples
)
;
}
if
(
CheckRecBuffer
(
kHighSampleValue
)
)
{
rtc
:
:
CritScope
cs
(
&
crit_
)
;
+
+
frames_received_
;
}
}
void
FakeAudioCaptureModule
:
:
SendFrameP
(
)
{
ASSERT
(
process_thread_
-
>
IsCurrent
(
)
)
;
rtc
:
:
CritScope
cs
(
&
crit_callback_
)
;
if
(
!
audio_callback_
)
{
return
;
}
bool
key_pressed
=
false
;
uint32_t
current_mic_level
=
0
;
MicrophoneVolume
(
&
current_mic_level
)
;
if
(
audio_callback_
-
>
RecordedDataIsAvailable
(
send_buffer_
kNumberSamples
kNumberBytesPerSample
kNumberOfChannels
kSamplesPerSecond
kTotalDelayMs
kClockDriftMs
current_mic_level
key_pressed
current_mic_level
)
!
=
0
)
{
RTC_NOTREACHED
(
)
;
}
SetMicrophoneVolume
(
current_mic_level
)
;
}
