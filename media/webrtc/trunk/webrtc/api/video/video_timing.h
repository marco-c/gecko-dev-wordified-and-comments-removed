#
ifndef
API_VIDEO_VIDEO_TIMING_H_
#
define
API_VIDEO_VIDEO_TIMING_H_
#
include
<
stdint
.
h
>
#
include
<
limits
>
#
include
<
string
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
namespace
webrtc
{
enum
TimingFrameFlags
:
uint8_t
{
kNotTriggered
=
0
kDefault
=
0
kTriggeredByTimer
=
1
<
<
0
kTriggeredBySize
=
1
<
<
1
kInvalid
=
std
:
:
numeric_limits
<
uint8_t
>
:
:
max
(
)
}
;
struct
VideoSendTiming
{
static
constexpr
uint8_t
kFlagsOffset
=
0
;
static
constexpr
uint8_t
kEncodeStartDeltaOffset
=
1
;
static
constexpr
uint8_t
kEncodeFinishDeltaOffset
=
3
;
static
constexpr
uint8_t
kPacketizationFinishDeltaOffset
=
5
;
static
constexpr
uint8_t
kPacerExitDeltaOffset
=
7
;
static
constexpr
uint8_t
kNetworkTimestampDeltaOffset
=
9
;
static
constexpr
uint8_t
kNetwork2TimestampDeltaOffset
=
11
;
static
uint16_t
GetDeltaCappedMs
(
int64_t
base_ms
int64_t
time_ms
)
{
RTC_DCHECK_GE
(
time_ms
base_ms
)
;
return
rtc
:
:
saturated_cast
<
uint16_t
>
(
time_ms
-
base_ms
)
;
}
uint16_t
encode_start_delta_ms
;
uint16_t
encode_finish_delta_ms
;
uint16_t
packetization_finish_delta_ms
;
uint16_t
pacer_exit_delta_ms
;
uint16_t
network_timestamp_delta_ms
;
uint16_t
network2_timestamp_delta_ms
;
uint8_t
flags
;
}
;
struct
TimingFrameInfo
{
TimingFrameInfo
(
)
;
int64_t
EndToEndDelay
(
)
const
;
bool
IsLongerThan
(
const
TimingFrameInfo
&
other
)
const
;
bool
IsOutlier
(
)
const
;
bool
IsTimerTriggered
(
)
const
;
bool
IsInvalid
(
)
const
;
std
:
:
string
ToString
(
)
const
;
bool
operator
<
(
const
TimingFrameInfo
&
other
)
const
;
bool
operator
<
=
(
const
TimingFrameInfo
&
other
)
const
;
uint32_t
rtp_timestamp
;
int64_t
capture_time_ms
;
int64_t
encode_start_ms
;
int64_t
encode_finish_ms
;
int64_t
packetization_finish_ms
;
int64_t
pacer_exit_ms
;
int64_t
network_timestamp_ms
;
int64_t
network2_timestamp_ms
;
int64_t
receive_start_ms
;
int64_t
receive_finish_ms
;
int64_t
decode_start_ms
;
int64_t
decode_finish_ms
;
int64_t
render_time_ms
;
uint8_t
flags
;
}
;
}
#
endif
