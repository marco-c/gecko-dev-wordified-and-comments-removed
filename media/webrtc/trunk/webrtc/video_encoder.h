#
ifndef
WEBRTC_VIDEO_ENCODER_H_
#
define
WEBRTC_VIDEO_ENCODER_H_
#
include
<
memory
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
common_types
.
h
"
#
include
"
webrtc
/
typedefs
.
h
"
#
include
"
webrtc
/
video_frame
.
h
"
#
include
"
webrtc
/
base
/
optional
.
h
"
namespace
webrtc
{
class
RTPFragmentationHeader
;
struct
CodecSpecificInfo
;
class
VideoCodec
;
class
EncodedImageCallback
{
public
:
virtual
~
EncodedImageCallback
(
)
{
}
struct
Result
{
enum
Error
{
OK
ERROR_SEND_FAILED
}
;
Result
(
Error
error
)
:
error
(
error
)
{
}
Result
(
Error
error
uint32_t
frame_id
)
:
error
(
error
)
frame_id
(
frame_id
)
{
}
Error
error
;
uint32_t
frame_id
=
0
;
bool
drop_next_frame
=
false
;
}
;
virtual
Result
OnEncodedImage
(
const
EncodedImage
&
encoded_image
const
CodecSpecificInfo
*
codec_specific_info
const
RTPFragmentationHeader
*
fragmentation
)
=
0
;
virtual
void
OnDroppedFrame
(
)
{
}
}
;
class
VideoEncoder
{
public
:
enum
EncoderType
{
kH264
kVp8
kVp9
kUnsupportedCodec
}
;
struct
QpThresholds
{
QpThresholds
(
int
l
int
h
)
:
low
(
l
)
high
(
h
)
{
}
QpThresholds
(
)
:
low
(
-
1
)
high
(
-
1
)
{
}
int
low
;
int
high
;
}
;
struct
ScalingSettings
{
ScalingSettings
(
bool
on
int
low
int
high
)
:
enabled
(
on
)
thresholds
(
rtc
:
:
Optional
<
QpThresholds
>
(
QpThresholds
(
low
high
)
)
)
{
}
explicit
ScalingSettings
(
bool
on
)
:
enabled
(
on
)
{
}
const
bool
enabled
;
const
rtc
:
:
Optional
<
QpThresholds
>
thresholds
;
}
;
static
VideoEncoder
*
Create
(
EncoderType
codec_type
bool
enable_simulcast
=
false
)
;
static
bool
IsSupportedSoftware
(
EncoderType
codec_type
)
;
static
EncoderType
CodecToEncoderType
(
VideoCodecType
codec_type
)
;
static
VideoCodecVP8
GetDefaultVp8Settings
(
)
;
static
VideoCodecVP9
GetDefaultVp9Settings
(
)
;
static
VideoCodecH264
GetDefaultH264Settings
(
)
;
virtual
~
VideoEncoder
(
)
{
}
virtual
int32_t
InitEncode
(
const
VideoCodec
*
codec_settings
int32_t
number_of_cores
size_t
max_payload_size
)
=
0
;
virtual
int32_t
RegisterEncodeCompleteCallback
(
EncodedImageCallback
*
callback
)
=
0
;
virtual
int32_t
Release
(
)
=
0
;
virtual
int32_t
Encode
(
const
VideoFrame
&
frame
const
CodecSpecificInfo
*
codec_specific_info
const
std
:
:
vector
<
FrameType
>
*
frame_types
)
=
0
;
virtual
int32_t
SetChannelParameters
(
uint32_t
packet_loss
int64_t
rtt
)
=
0
;
virtual
int32_t
SetRates
(
uint32_t
bitrate
uint32_t
framerate
)
{
RTC_NOTREACHED
(
)
<
<
"
SetRate
(
uint32_t
uint32_t
)
is
deprecated
.
"
;
return
-
1
;
}
virtual
int32_t
SetRateAllocation
(
const
BitrateAllocation
&
allocation
uint32_t
framerate
)
{
return
SetRates
(
allocation
.
get_sum_kbps
(
)
framerate
)
;
}
virtual
ScalingSettings
GetScalingSettings
(
)
const
{
return
ScalingSettings
(
false
)
;
}
virtual
int32_t
SetPeriodicKeyFrames
(
bool
enable
)
{
return
-
1
;
}
virtual
bool
SupportsNativeHandle
(
)
const
{
return
false
;
}
virtual
const
char
*
ImplementationName
(
)
const
{
return
"
unknown
"
;
}
}
;
}
#
endif
