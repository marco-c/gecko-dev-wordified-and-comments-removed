#
ifndef
TEST_FAKE_NETWORK_PIPE_H_
#
define
TEST_FAKE_NETWORK_PIPE_H_
#
include
<
string
.
h
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
queue
>
#
include
<
set
>
#
include
"
common_types
.
h
"
#
include
"
rtc_base
/
constructormagic
.
h
"
#
include
"
rtc_base
/
criticalsection
.
h
"
#
include
"
rtc_base
/
random
.
h
"
#
include
"
typedefs
.
h
"
namespace
webrtc
{
class
Clock
;
class
PacketReceiver
;
enum
class
MediaType
;
class
NetworkPacket
{
public
:
NetworkPacket
(
const
uint8_t
*
data
size_t
length
int64_t
send_time
int64_t
arrival_time
)
:
data_
(
new
uint8_t
[
length
]
)
data_length_
(
length
)
send_time_
(
send_time
)
arrival_time_
(
arrival_time
)
{
memcpy
(
data_
.
get
(
)
data
length
)
;
}
uint8_t
*
data
(
)
const
{
return
data_
.
get
(
)
;
}
size_t
data_length
(
)
const
{
return
data_length_
;
}
int64_t
send_time
(
)
const
{
return
send_time_
;
}
int64_t
arrival_time
(
)
const
{
return
arrival_time_
;
}
void
IncrementArrivalTime
(
int64_t
extra_delay
)
{
arrival_time_
+
=
extra_delay
;
}
private
:
std
:
:
unique_ptr
<
uint8_t
[
]
>
data_
;
size_t
data_length_
;
const
int64_t
send_time_
;
int64_t
arrival_time_
;
}
;
class
Demuxer
{
public
:
virtual
~
Demuxer
(
)
=
default
;
virtual
void
SetReceiver
(
PacketReceiver
*
receiver
)
=
0
;
virtual
void
DeliverPacket
(
const
NetworkPacket
*
packet
const
PacketTime
&
packet_time
)
=
0
;
}
;
class
DemuxerImpl
final
:
public
Demuxer
{
public
:
explicit
DemuxerImpl
(
const
std
:
:
map
<
uint8_t
MediaType
>
&
payload_type_map
)
;
void
SetReceiver
(
PacketReceiver
*
receiver
)
override
;
void
DeliverPacket
(
const
NetworkPacket
*
packet
const
PacketTime
&
packet_time
)
override
;
private
:
PacketReceiver
*
packet_receiver_
;
const
std
:
:
map
<
uint8_t
MediaType
>
payload_type_map_
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
DemuxerImpl
)
;
}
;
class
FakeNetworkPipe
{
public
:
struct
Config
{
Config
(
)
{
}
size_t
queue_length_packets
=
0
;
int
queue_delay_ms
=
0
;
int
delay_standard_deviation_ms
=
0
;
int
link_capacity_kbps
=
0
;
int
loss_percent
=
0
;
bool
allow_reordering
=
false
;
int
avg_burst_loss_length
=
-
1
;
}
;
FakeNetworkPipe
(
Clock
*
clock
const
FakeNetworkPipe
:
:
Config
&
config
std
:
:
unique_ptr
<
Demuxer
>
demuxer
)
;
FakeNetworkPipe
(
Clock
*
clock
const
FakeNetworkPipe
:
:
Config
&
config
std
:
:
unique_ptr
<
Demuxer
>
demuxer
uint64_t
seed
)
;
virtual
~
FakeNetworkPipe
(
)
;
void
SetConfig
(
const
FakeNetworkPipe
:
:
Config
&
config
)
;
virtual
void
SendPacket
(
const
uint8_t
*
packet
size_t
packet_length
)
;
void
SetReceiver
(
PacketReceiver
*
receiver
)
;
virtual
void
Process
(
)
;
int64_t
TimeUntilNextProcess
(
)
const
;
float
PercentageLoss
(
)
;
int
AverageDelay
(
)
;
size_t
dropped_packets
(
)
{
return
dropped_packets_
;
}
size_t
sent_packets
(
)
{
return
sent_packets_
;
}
protected
:
Clock
*
const
clock_
;
rtc
:
:
CriticalSection
lock_
;
const
std
:
:
unique_ptr
<
Demuxer
>
demuxer_
;
std
:
:
queue
<
NetworkPacket
*
>
capacity_link_
;
Random
random_
;
struct
PacketArrivalTimeComparator
{
bool
operator
(
)
(
const
NetworkPacket
*
p1
const
NetworkPacket
*
p2
)
{
return
p1
-
>
arrival_time
(
)
<
p2
-
>
arrival_time
(
)
;
}
}
;
std
:
:
multiset
<
NetworkPacket
*
PacketArrivalTimeComparator
>
delay_link_
;
Config
config_
;
size_t
dropped_packets_
;
size_t
sent_packets_
;
int64_t
total_packet_delay_
;
bool
bursting_
;
double
prob_loss_bursting_
;
double
prob_start_bursting_
;
int64_t
next_process_time_
;
int64_t
last_log_time_
;
int64_t
capacity_delay_error_bytes_
=
0
;
RTC_DISALLOW_COPY_AND_ASSIGN
(
FakeNetworkPipe
)
;
}
;
}
#
endif
