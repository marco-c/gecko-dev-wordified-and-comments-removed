#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtp_header_extension
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtp_header_extensions
.
h
"
#
include
"
webrtc
/
modules
/
rtp_rtcp
/
source
/
rtp_packet_received
.
h
"
namespace
webrtc
{
static_assert
(
kRtpExtensionNumberOfExtensions
<
=
8
"
Insufficient
bits
read
to
configure
all
header
extensions
.
Add
"
"
an
extra
byte
and
update
the
switches
.
"
)
;
void
FuzzOneInput
(
const
uint8_t
*
data
size_t
size
)
{
if
(
size
<
=
1
)
return
;
std
:
:
bitset
<
8
>
extensionMask
(
data
[
0
]
)
;
data
+
+
;
size
-
-
;
RtpPacketReceived
:
:
ExtensionManager
extensions
;
for
(
int
i
=
0
;
i
<
kRtpExtensionNumberOfExtensions
;
i
+
+
)
{
RTPExtensionType
extension_type
=
static_cast
<
RTPExtensionType
>
(
i
)
;
if
(
extensionMask
[
i
]
&
&
extension_type
!
=
kRtpExtensionNone
)
{
extensions
.
Register
(
extension_type
i
)
;
}
}
RtpPacketReceived
packet
(
&
extensions
)
;
packet
.
Parse
(
data
size
)
;
packet
.
Marker
(
)
;
packet
.
PayloadType
(
)
;
packet
.
SequenceNumber
(
)
;
packet
.
Timestamp
(
)
;
packet
.
Ssrc
(
)
;
packet
.
Csrcs
(
)
;
for
(
int
i
=
0
;
i
<
kRtpExtensionNumberOfExtensions
;
i
+
+
)
{
switch
(
static_cast
<
RTPExtensionType
>
(
i
)
)
{
case
kRtpExtensionNone
:
case
kRtpExtensionNumberOfExtensions
:
break
;
case
kRtpExtensionTransmissionTimeOffset
:
int32_t
offset
;
packet
.
GetExtension
<
TransmissionOffset
>
(
&
offset
)
;
break
;
case
kRtpExtensionAudioLevel
:
bool
voice_activity
;
uint8_t
audio_level
;
packet
.
GetExtension
<
AudioLevel
>
(
&
voice_activity
&
audio_level
)
;
break
;
case
kRtpExtensionAbsoluteSendTime
:
uint32_t
sendtime
;
packet
.
GetExtension
<
AbsoluteSendTime
>
(
&
sendtime
)
;
break
;
case
kRtpExtensionVideoRotation
:
uint8_t
rotation
;
packet
.
GetExtension
<
VideoOrientation
>
(
&
rotation
)
;
break
;
case
kRtpExtensionTransportSequenceNumber
:
uint16_t
seqnum
;
packet
.
GetExtension
<
TransportSequenceNumber
>
(
&
seqnum
)
;
break
;
case
kRtpExtensionPlayoutDelay
:
PlayoutDelay
playout
;
packet
.
GetExtension
<
PlayoutDelayLimits
>
(
&
playout
)
;
break
;
}
}
}
}
