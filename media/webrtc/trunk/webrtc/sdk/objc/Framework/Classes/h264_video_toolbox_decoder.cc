#
include
"
webrtc
/
sdk
/
objc
/
Framework
/
Classes
/
h264_video_toolbox_decoder
.
h
"
#
include
<
memory
>
#
if
defined
(
WEBRTC_IOS
)
#
include
"
RTCUIApplication
.
h
"
#
endif
#
include
"
libyuv
/
convert
.
h
"
#
include
"
webrtc
/
api
/
video
/
video_frame
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
common_video
/
include
/
corevideo_frame_buffer
.
h
"
#
include
"
webrtc
/
sdk
/
objc
/
Framework
/
Classes
/
h264_video_toolbox_nalu
.
h
"
#
include
"
webrtc
/
video_frame
.
h
"
namespace
internal
{
static
const
int64_t
kMsPerSec
=
1000
;
inline
CFDictionaryRef
CreateCFDictionary
(
CFTypeRef
*
keys
CFTypeRef
*
values
size_t
size
)
{
return
CFDictionaryCreate
(
nullptr
keys
values
size
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
;
}
struct
FrameDecodeParams
{
FrameDecodeParams
(
webrtc
:
:
DecodedImageCallback
*
cb
int64_t
ts
)
:
callback
(
cb
)
timestamp
(
ts
)
{
}
webrtc
:
:
DecodedImageCallback
*
callback
;
int64_t
timestamp
;
}
;
void
VTDecompressionOutputCallback
(
void
*
decoder
void
*
params
OSStatus
status
VTDecodeInfoFlags
info_flags
CVImageBufferRef
image_buffer
CMTime
timestamp
CMTime
duration
)
{
std
:
:
unique_ptr
<
FrameDecodeParams
>
decode_params
(
reinterpret_cast
<
FrameDecodeParams
*
>
(
params
)
)
;
if
(
status
!
=
noErr
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
decode
frame
.
Status
:
"
<
<
status
;
return
;
}
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
buffer
=
new
rtc
:
:
RefCountedObject
<
webrtc
:
:
CoreVideoFrameBuffer
>
(
image_buffer
)
;
webrtc
:
:
VideoFrame
decoded_frame
(
buffer
decode_params
-
>
timestamp
CMTimeGetSeconds
(
timestamp
)
*
kMsPerSec
webrtc
:
:
kVideoRotation_0
)
;
decode_params
-
>
callback
-
>
Decoded
(
decoded_frame
)
;
}
}
namespace
webrtc
{
H264VideoToolboxDecoder
:
:
H264VideoToolboxDecoder
(
)
:
callback_
(
nullptr
)
video_format_
(
nullptr
)
decompression_session_
(
nullptr
)
{
}
H264VideoToolboxDecoder
:
:
~
H264VideoToolboxDecoder
(
)
{
DestroyDecompressionSession
(
)
;
SetVideoFormat
(
nullptr
)
;
}
int
H264VideoToolboxDecoder
:
:
InitDecode
(
const
VideoCodec
*
video_codec
int
number_of_cores
)
{
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
H264VideoToolboxDecoder
:
:
Decode
(
const
EncodedImage
&
input_image
bool
missing_frames
const
RTPFragmentationHeader
*
fragmentation
const
CodecSpecificInfo
*
codec_specific_info
int64_t
render_time_ms
)
{
RTC_DCHECK
(
input_image
.
_buffer
)
;
#
if
defined
(
WEBRTC_IOS
)
if
(
!
RTCIsUIApplicationActive
(
)
)
{
SetVideoFormat
(
nullptr
)
;
return
WEBRTC_VIDEO_CODEC_NO_OUTPUT
;
}
#
endif
CMVideoFormatDescriptionRef
input_format
=
nullptr
;
if
(
H264AnnexBBufferHasVideoFormatDescription
(
input_image
.
_buffer
input_image
.
_length
)
)
{
input_format
=
CreateVideoFormatDescription
(
input_image
.
_buffer
input_image
.
_length
)
;
if
(
input_format
)
{
if
(
!
CMFormatDescriptionEqual
(
input_format
video_format_
)
)
{
SetVideoFormat
(
input_format
)
;
ResetDecompressionSession
(
)
;
}
CFRelease
(
input_format
)
;
}
}
if
(
!
video_format_
)
{
LOG
(
LS_WARNING
)
<
<
"
Missing
video
format
.
Frame
with
sps
/
pps
required
.
"
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
CMSampleBufferRef
sample_buffer
=
nullptr
;
if
(
!
H264AnnexBBufferToCMSampleBuffer
(
input_image
.
_buffer
input_image
.
_length
video_format_
&
sample_buffer
)
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
RTC_DCHECK
(
sample_buffer
)
;
VTDecodeFrameFlags
decode_flags
=
kVTDecodeFrame_EnableAsynchronousDecompression
;
std
:
:
unique_ptr
<
internal
:
:
FrameDecodeParams
>
frame_decode_params
;
frame_decode_params
.
reset
(
new
internal
:
:
FrameDecodeParams
(
callback_
input_image
.
_timeStamp
)
)
;
OSStatus
status
=
VTDecompressionSessionDecodeFrame
(
decompression_session_
sample_buffer
decode_flags
frame_decode_params
.
release
(
)
nullptr
)
;
#
if
defined
(
WEBRTC_IOS
)
if
(
status
=
=
kVTInvalidSessionErr
&
&
ResetDecompressionSession
(
)
=
=
WEBRTC_VIDEO_CODEC_OK
)
{
frame_decode_params
.
reset
(
new
internal
:
:
FrameDecodeParams
(
callback_
input_image
.
_timeStamp
)
)
;
status
=
VTDecompressionSessionDecodeFrame
(
decompression_session_
sample_buffer
decode_flags
frame_decode_params
.
release
(
)
nullptr
)
;
}
#
endif
CFRelease
(
sample_buffer
)
;
if
(
status
!
=
noErr
)
{
LOG
(
LS_ERROR
)
<
<
"
Failed
to
decode
frame
with
code
:
"
<
<
status
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
H264VideoToolboxDecoder
:
:
RegisterDecodeCompleteCallback
(
DecodedImageCallback
*
callback
)
{
RTC_DCHECK
(
!
callback_
)
;
callback_
=
callback
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
H264VideoToolboxDecoder
:
:
Release
(
)
{
DestroyDecompressionSession
(
)
;
SetVideoFormat
(
nullptr
)
;
callback_
=
nullptr
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int
H264VideoToolboxDecoder
:
:
ResetDecompressionSession
(
)
{
DestroyDecompressionSession
(
)
;
if
(
!
video_format_
)
{
return
WEBRTC_VIDEO_CODEC_OK
;
}
static
size_t
const
attributes_size
=
3
;
CFTypeRef
keys
[
attributes_size
]
=
{
#
if
defined
(
WEBRTC_IOS
)
kCVPixelBufferOpenGLESCompatibilityKey
#
elif
defined
(
WEBRTC_MAC
)
kCVPixelBufferOpenGLCompatibilityKey
#
endif
kCVPixelBufferIOSurfacePropertiesKey
kCVPixelBufferPixelFormatTypeKey
}
;
CFDictionaryRef
io_surface_value
=
internal
:
:
CreateCFDictionary
(
nullptr
nullptr
0
)
;
int64_t
nv12type
=
kCVPixelFormatType_420YpCbCr8BiPlanarFullRange
;
CFNumberRef
pixel_format
=
CFNumberCreate
(
nullptr
kCFNumberLongType
&
nv12type
)
;
CFTypeRef
values
[
attributes_size
]
=
{
kCFBooleanTrue
io_surface_value
pixel_format
}
;
CFDictionaryRef
attributes
=
internal
:
:
CreateCFDictionary
(
keys
values
attributes_size
)
;
if
(
io_surface_value
)
{
CFRelease
(
io_surface_value
)
;
io_surface_value
=
nullptr
;
}
if
(
pixel_format
)
{
CFRelease
(
pixel_format
)
;
pixel_format
=
nullptr
;
}
VTDecompressionOutputCallbackRecord
record
=
{
internal
:
:
VTDecompressionOutputCallback
this
}
;
OSStatus
status
=
VTDecompressionSessionCreate
(
nullptr
video_format_
nullptr
attributes
&
record
&
decompression_session_
)
;
CFRelease
(
attributes
)
;
if
(
status
!
=
noErr
)
{
DestroyDecompressionSession
(
)
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
ConfigureDecompressionSession
(
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
H264VideoToolboxDecoder
:
:
ConfigureDecompressionSession
(
)
{
RTC_DCHECK
(
decompression_session_
)
;
#
if
defined
(
WEBRTC_IOS
)
VTSessionSetProperty
(
decompression_session_
kVTDecompressionPropertyKey_RealTime
kCFBooleanTrue
)
;
#
endif
}
void
H264VideoToolboxDecoder
:
:
DestroyDecompressionSession
(
)
{
if
(
decompression_session_
)
{
VTDecompressionSessionInvalidate
(
decompression_session_
)
;
CFRelease
(
decompression_session_
)
;
decompression_session_
=
nullptr
;
}
}
void
H264VideoToolboxDecoder
:
:
SetVideoFormat
(
CMVideoFormatDescriptionRef
video_format
)
{
if
(
video_format_
=
=
video_format
)
{
return
;
}
if
(
video_format_
)
{
CFRelease
(
video_format_
)
;
}
video_format_
=
video_format
;
if
(
video_format_
)
{
CFRetain
(
video_format_
)
;
}
}
const
char
*
H264VideoToolboxDecoder
:
:
ImplementationName
(
)
const
{
return
"
VideoToolbox
"
;
}
}
