package
org
.
webrtc
;
import
android
.
annotation
.
TargetApi
;
import
android
.
media
.
MediaCodec
;
import
android
.
media
.
MediaCodecInfo
.
CodecCapabilities
;
import
android
.
media
.
MediaFormat
;
import
android
.
os
.
SystemClock
;
import
android
.
view
.
Surface
;
import
java
.
io
.
IOException
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
concurrent
.
BlockingDeque
;
import
java
.
util
.
concurrent
.
LinkedBlockingDeque
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
org
.
webrtc
.
ThreadUtils
.
ThreadChecker
;
TargetApi
(
16
)
SuppressWarnings
(
"
deprecation
"
)
class
HardwareVideoDecoder
implements
VideoDecoder
SurfaceTextureHelper
.
OnTextureFrameAvailableListener
{
private
static
final
String
TAG
=
"
HardwareVideoDecoder
"
;
private
static
final
String
MEDIA_FORMAT_KEY_STRIDE
=
"
stride
"
;
private
static
final
String
MEDIA_FORMAT_KEY_SLICE_HEIGHT
=
"
slice
-
height
"
;
private
static
final
String
MEDIA_FORMAT_KEY_CROP_LEFT
=
"
crop
-
left
"
;
private
static
final
String
MEDIA_FORMAT_KEY_CROP_RIGHT
=
"
crop
-
right
"
;
private
static
final
String
MEDIA_FORMAT_KEY_CROP_TOP
=
"
crop
-
top
"
;
private
static
final
String
MEDIA_FORMAT_KEY_CROP_BOTTOM
=
"
crop
-
bottom
"
;
private
static
final
int
MEDIA_CODEC_RELEASE_TIMEOUT_MS
=
5000
;
private
static
final
int
DEQUEUE_INPUT_TIMEOUT_US
=
500000
;
private
static
final
int
DEQUEUE_OUTPUT_BUFFER_TIMEOUT_US
=
100000
;
private
final
String
codecName
;
private
final
VideoCodecType
codecType
;
private
static
class
FrameInfo
{
final
long
decodeStartTimeMs
;
final
int
rotation
;
FrameInfo
(
long
decodeStartTimeMs
int
rotation
)
{
this
.
decodeStartTimeMs
=
decodeStartTimeMs
;
this
.
rotation
=
rotation
;
}
}
private
final
BlockingDeque
<
FrameInfo
>
frameInfos
;
private
int
colorFormat
;
private
Thread
outputThread
;
private
ThreadChecker
outputThreadChecker
;
private
ThreadChecker
decoderThreadChecker
;
private
volatile
boolean
running
=
false
;
private
volatile
Exception
shutdownException
=
null
;
private
final
Object
dimensionLock
=
new
Object
(
)
;
private
int
width
;
private
int
height
;
private
int
stride
;
private
int
sliceHeight
;
private
boolean
hasDecodedFirstFrame
;
private
boolean
keyFrameRequired
;
private
final
EglBase
.
Context
sharedContext
;
private
SurfaceTextureHelper
surfaceTextureHelper
;
private
Surface
surface
=
null
;
private
static
class
DecodedTextureMetadata
{
final
int
width
;
final
int
height
;
final
int
rotation
;
final
long
presentationTimestampUs
;
final
Integer
decodeTimeMs
;
DecodedTextureMetadata
(
int
width
int
height
int
rotation
long
presentationTimestampUs
Integer
decodeTimeMs
)
{
this
.
width
=
width
;
this
.
height
=
height
;
this
.
rotation
=
rotation
;
this
.
presentationTimestampUs
=
presentationTimestampUs
;
this
.
decodeTimeMs
=
decodeTimeMs
;
}
}
private
final
Object
renderedTextureMetadataLock
=
new
Object
(
)
;
private
DecodedTextureMetadata
renderedTextureMetadata
;
private
Callback
callback
;
private
MediaCodec
codec
=
null
;
HardwareVideoDecoder
(
String
codecName
VideoCodecType
codecType
int
colorFormat
EglBase
.
Context
sharedContext
)
{
if
(
!
isSupportedColorFormat
(
colorFormat
)
)
{
throw
new
IllegalArgumentException
(
"
Unsupported
color
format
:
"
+
colorFormat
)
;
}
this
.
codecName
=
codecName
;
this
.
codecType
=
codecType
;
this
.
colorFormat
=
colorFormat
;
this
.
sharedContext
=
sharedContext
;
this
.
frameInfos
=
new
LinkedBlockingDeque
<
>
(
)
;
}
Override
public
VideoCodecStatus
initDecode
(
Settings
settings
Callback
callback
)
{
this
.
decoderThreadChecker
=
new
ThreadChecker
(
)
;
this
.
callback
=
callback
;
if
(
sharedContext
!
=
null
)
{
surfaceTextureHelper
=
SurfaceTextureHelper
.
create
(
"
decoder
-
texture
-
thread
"
sharedContext
)
;
surface
=
new
Surface
(
surfaceTextureHelper
.
getSurfaceTexture
(
)
)
;
surfaceTextureHelper
.
startListening
(
this
)
;
}
return
initDecodeInternal
(
settings
.
width
settings
.
height
)
;
}
private
VideoCodecStatus
initDecodeInternal
(
int
width
int
height
)
{
decoderThreadChecker
.
checkIsOnValidThread
(
)
;
Logging
.
d
(
TAG
"
initDecodeInternal
"
)
;
if
(
outputThread
!
=
null
)
{
Logging
.
e
(
TAG
"
initDecodeInternal
called
while
the
codec
is
already
running
"
)
;
return
VideoCodecStatus
.
ERROR
;
}
this
.
width
=
width
;
this
.
height
=
height
;
stride
=
width
;
sliceHeight
=
height
;
hasDecodedFirstFrame
=
false
;
keyFrameRequired
=
true
;
try
{
codec
=
MediaCodec
.
createByCodecName
(
codecName
)
;
}
catch
(
IOException
|
IllegalArgumentException
e
)
{
Logging
.
e
(
TAG
"
Cannot
create
media
decoder
"
+
codecName
)
;
return
VideoCodecStatus
.
ERROR
;
}
try
{
MediaFormat
format
=
MediaFormat
.
createVideoFormat
(
codecType
.
mimeType
(
)
width
height
)
;
if
(
sharedContext
=
=
null
)
{
format
.
setInteger
(
MediaFormat
.
KEY_COLOR_FORMAT
colorFormat
)
;
}
codec
.
configure
(
format
surface
null
0
)
;
codec
.
start
(
)
;
}
catch
(
IllegalStateException
e
)
{
Logging
.
e
(
TAG
"
initDecode
failed
"
e
)
;
release
(
)
;
return
VideoCodecStatus
.
ERROR
;
}
running
=
true
;
outputThread
=
createOutputThread
(
)
;
outputThread
.
start
(
)
;
Logging
.
d
(
TAG
"
initDecodeInternal
done
"
)
;
return
VideoCodecStatus
.
OK
;
}
Override
public
VideoCodecStatus
decode
(
EncodedImage
frame
DecodeInfo
info
)
{
decoderThreadChecker
.
checkIsOnValidThread
(
)
;
if
(
codec
=
=
null
|
|
callback
=
=
null
)
{
Logging
.
d
(
TAG
"
decode
uninitalized
codec
:
"
+
codec
+
"
callback
:
"
+
callback
)
;
return
VideoCodecStatus
.
UNINITIALIZED
;
}
if
(
frame
.
buffer
=
=
null
)
{
Logging
.
e
(
TAG
"
decode
(
)
-
no
input
data
"
)
;
return
VideoCodecStatus
.
ERR_PARAMETER
;
}
int
size
=
frame
.
buffer
.
remaining
(
)
;
if
(
size
=
=
0
)
{
Logging
.
e
(
TAG
"
decode
(
)
-
input
buffer
empty
"
)
;
return
VideoCodecStatus
.
ERR_PARAMETER
;
}
int
width
height
;
synchronized
(
dimensionLock
)
{
width
=
this
.
width
;
height
=
this
.
height
;
}
if
(
frame
.
encodedWidth
*
frame
.
encodedHeight
>
0
&
&
(
frame
.
encodedWidth
!
=
width
|
|
frame
.
encodedHeight
!
=
height
)
)
{
VideoCodecStatus
status
=
reinitDecode
(
frame
.
encodedWidth
frame
.
encodedHeight
)
;
if
(
status
!
=
VideoCodecStatus
.
OK
)
{
return
status
;
}
}
if
(
keyFrameRequired
)
{
if
(
frame
.
frameType
!
=
EncodedImage
.
FrameType
.
VideoFrameKey
)
{
Logging
.
e
(
TAG
"
decode
(
)
-
key
frame
required
first
"
)
;
return
VideoCodecStatus
.
ERROR
;
}
if
(
!
frame
.
completeFrame
)
{
Logging
.
e
(
TAG
"
decode
(
)
-
complete
frame
required
first
"
)
;
return
VideoCodecStatus
.
ERROR
;
}
}
int
index
;
try
{
index
=
codec
.
dequeueInputBuffer
(
DEQUEUE_INPUT_TIMEOUT_US
)
;
}
catch
(
IllegalStateException
e
)
{
Logging
.
e
(
TAG
"
dequeueInputBuffer
failed
"
e
)
;
return
VideoCodecStatus
.
ERROR
;
}
if
(
index
<
0
)
{
Logging
.
e
(
TAG
"
decode
(
)
-
no
HW
buffers
available
;
decoder
falling
behind
"
)
;
return
VideoCodecStatus
.
ERROR
;
}
ByteBuffer
buffer
;
try
{
buffer
=
codec
.
getInputBuffers
(
)
[
index
]
;
}
catch
(
IllegalStateException
e
)
{
Logging
.
e
(
TAG
"
getInputBuffers
failed
"
e
)
;
return
VideoCodecStatus
.
ERROR
;
}
if
(
buffer
.
capacity
(
)
<
size
)
{
Logging
.
e
(
TAG
"
decode
(
)
-
HW
buffer
too
small
"
)
;
return
VideoCodecStatus
.
ERROR
;
}
buffer
.
put
(
frame
.
buffer
)
;
frameInfos
.
offer
(
new
FrameInfo
(
SystemClock
.
elapsedRealtime
(
)
frame
.
rotation
)
)
;
try
{
codec
.
queueInputBuffer
(
index
0
size
TimeUnit
.
NANOSECONDS
.
toMicros
(
frame
.
captureTimeNs
)
0
)
;
}
catch
(
IllegalStateException
e
)
{
Logging
.
e
(
TAG
"
queueInputBuffer
failed
"
e
)
;
frameInfos
.
pollLast
(
)
;
return
VideoCodecStatus
.
ERROR
;
}
if
(
keyFrameRequired
)
{
keyFrameRequired
=
false
;
}
return
VideoCodecStatus
.
OK
;
}
Override
public
boolean
getPrefersLateDecoding
(
)
{
return
true
;
}
Override
public
String
getImplementationName
(
)
{
return
"
HWDecoder
"
;
}
Override
public
VideoCodecStatus
release
(
)
{
Logging
.
d
(
TAG
"
release
"
)
;
VideoCodecStatus
status
=
releaseInternal
(
)
;
if
(
surface
!
=
null
)
{
surface
.
release
(
)
;
surface
=
null
;
surfaceTextureHelper
.
stopListening
(
)
;
surfaceTextureHelper
.
dispose
(
)
;
surfaceTextureHelper
=
null
;
}
synchronized
(
renderedTextureMetadataLock
)
{
renderedTextureMetadata
=
null
;
}
callback
=
null
;
frameInfos
.
clear
(
)
;
return
status
;
}
private
VideoCodecStatus
releaseInternal
(
)
{
if
(
!
running
)
{
Logging
.
d
(
TAG
"
release
:
Decoder
is
not
running
.
"
)
;
return
VideoCodecStatus
.
OK
;
}
try
{
running
=
false
;
if
(
!
ThreadUtils
.
joinUninterruptibly
(
outputThread
MEDIA_CODEC_RELEASE_TIMEOUT_MS
)
)
{
Logging
.
e
(
TAG
"
Media
decoder
release
timeout
"
new
RuntimeException
(
)
)
;
return
VideoCodecStatus
.
TIMEOUT
;
}
if
(
shutdownException
!
=
null
)
{
Logging
.
e
(
TAG
"
Media
decoder
release
error
"
new
RuntimeException
(
shutdownException
)
)
;
shutdownException
=
null
;
return
VideoCodecStatus
.
ERROR
;
}
}
finally
{
codec
=
null
;
outputThread
=
null
;
}
return
VideoCodecStatus
.
OK
;
}
private
VideoCodecStatus
reinitDecode
(
int
newWidth
int
newHeight
)
{
decoderThreadChecker
.
checkIsOnValidThread
(
)
;
VideoCodecStatus
status
=
releaseInternal
(
)
;
if
(
status
!
=
VideoCodecStatus
.
OK
)
{
return
status
;
}
return
initDecodeInternal
(
newWidth
newHeight
)
;
}
private
Thread
createOutputThread
(
)
{
return
new
Thread
(
"
HardwareVideoDecoder
.
outputThread
"
)
{
Override
public
void
run
(
)
{
outputThreadChecker
=
new
ThreadChecker
(
)
;
while
(
running
)
{
deliverDecodedFrame
(
)
;
}
releaseCodecOnOutputThread
(
)
;
}
}
;
}
private
void
deliverDecodedFrame
(
)
{
outputThreadChecker
.
checkIsOnValidThread
(
)
;
try
{
MediaCodec
.
BufferInfo
info
=
new
MediaCodec
.
BufferInfo
(
)
;
int
result
=
codec
.
dequeueOutputBuffer
(
info
DEQUEUE_OUTPUT_BUFFER_TIMEOUT_US
)
;
if
(
result
=
=
MediaCodec
.
INFO_OUTPUT_FORMAT_CHANGED
)
{
reformat
(
codec
.
getOutputFormat
(
)
)
;
return
;
}
if
(
result
<
0
)
{
Logging
.
v
(
TAG
"
dequeueOutputBuffer
returned
"
+
result
)
;
return
;
}
FrameInfo
frameInfo
=
frameInfos
.
poll
(
)
;
Integer
decodeTimeMs
=
null
;
int
rotation
=
0
;
if
(
frameInfo
!
=
null
)
{
decodeTimeMs
=
(
int
)
(
SystemClock
.
elapsedRealtime
(
)
-
frameInfo
.
decodeStartTimeMs
)
;
rotation
=
frameInfo
.
rotation
;
}
hasDecodedFirstFrame
=
true
;
if
(
surfaceTextureHelper
!
=
null
)
{
deliverTextureFrame
(
result
info
rotation
decodeTimeMs
)
;
}
else
{
deliverByteFrame
(
result
info
rotation
decodeTimeMs
)
;
}
}
catch
(
IllegalStateException
e
)
{
Logging
.
e
(
TAG
"
deliverDecodedFrame
failed
"
e
)
;
}
}
private
void
deliverTextureFrame
(
final
int
index
final
MediaCodec
.
BufferInfo
info
final
int
rotation
final
Integer
decodeTimeMs
)
{
final
int
width
height
;
synchronized
(
dimensionLock
)
{
width
=
this
.
width
;
height
=
this
.
height
;
}
synchronized
(
renderedTextureMetadataLock
)
{
if
(
renderedTextureMetadata
!
=
null
)
{
return
;
}
renderedTextureMetadata
=
new
DecodedTextureMetadata
(
width
height
rotation
info
.
presentationTimeUs
decodeTimeMs
)
;
codec
.
releaseOutputBuffer
(
index
true
)
;
}
}
Override
public
void
onTextureFrameAvailable
(
int
oesTextureId
float
[
]
transformMatrix
long
timestampNs
)
{
final
VideoFrame
frame
;
final
int
decodeTimeMs
;
synchronized
(
renderedTextureMetadataLock
)
{
if
(
renderedTextureMetadata
=
=
null
)
{
throw
new
IllegalStateException
(
"
Rendered
texture
metadata
was
null
in
onTextureFrameAvailable
.
"
)
;
}
VideoFrame
.
TextureBuffer
oesBuffer
=
surfaceTextureHelper
.
createTextureBuffer
(
renderedTextureMetadata
.
width
renderedTextureMetadata
.
height
RendererCommon
.
convertMatrixToAndroidGraphicsMatrix
(
transformMatrix
)
)
;
frame
=
new
VideoFrame
(
oesBuffer
renderedTextureMetadata
.
rotation
renderedTextureMetadata
.
presentationTimestampUs
*
1000
)
;
decodeTimeMs
=
renderedTextureMetadata
.
decodeTimeMs
;
renderedTextureMetadata
=
null
;
}
callback
.
onDecodedFrame
(
frame
decodeTimeMs
null
)
;
frame
.
release
(
)
;
}
private
void
deliverByteFrame
(
int
result
MediaCodec
.
BufferInfo
info
int
rotation
Integer
decodeTimeMs
)
{
int
width
height
stride
sliceHeight
;
synchronized
(
dimensionLock
)
{
width
=
this
.
width
;
height
=
this
.
height
;
stride
=
this
.
stride
;
sliceHeight
=
this
.
sliceHeight
;
}
if
(
info
.
size
<
width
*
height
*
3
/
2
)
{
Logging
.
e
(
TAG
"
Insufficient
output
buffer
size
:
"
+
info
.
size
)
;
return
;
}
if
(
info
.
size
<
stride
*
height
*
3
/
2
&
&
sliceHeight
=
=
height
&
&
stride
>
width
)
{
stride
=
info
.
size
*
2
/
(
height
*
3
)
;
}
ByteBuffer
buffer
=
codec
.
getOutputBuffers
(
)
[
result
]
;
buffer
.
position
(
info
.
offset
)
;
buffer
.
limit
(
info
.
offset
+
info
.
size
)
;
buffer
=
buffer
.
slice
(
)
;
final
VideoFrame
.
Buffer
frameBuffer
;
if
(
colorFormat
=
=
CodecCapabilities
.
COLOR_FormatYUV420Planar
)
{
frameBuffer
=
copyI420Buffer
(
buffer
stride
sliceHeight
width
height
)
;
}
else
{
frameBuffer
=
copyNV12ToI420Buffer
(
buffer
stride
sliceHeight
width
height
)
;
}
codec
.
releaseOutputBuffer
(
result
false
)
;
long
presentationTimeNs
=
info
.
presentationTimeUs
*
1000
;
VideoFrame
frame
=
new
VideoFrame
(
frameBuffer
rotation
presentationTimeNs
)
;
callback
.
onDecodedFrame
(
frame
decodeTimeMs
null
)
;
frame
.
release
(
)
;
}
private
VideoFrame
.
Buffer
copyNV12ToI420Buffer
(
ByteBuffer
buffer
int
stride
int
sliceHeight
int
width
int
height
)
{
return
new
NV12Buffer
(
width
height
stride
sliceHeight
buffer
null
)
.
toI420
(
)
;
}
private
VideoFrame
.
Buffer
copyI420Buffer
(
ByteBuffer
buffer
int
stride
int
sliceHeight
int
width
int
height
)
{
final
int
uvStride
=
stride
/
2
;
final
int
yPos
=
0
;
final
int
uPos
=
yPos
+
stride
*
sliceHeight
;
final
int
uEnd
=
uPos
+
uvStride
*
(
sliceHeight
/
2
)
;
final
int
vPos
=
uPos
+
uvStride
*
sliceHeight
/
2
;
final
int
vEnd
=
vPos
+
uvStride
*
(
sliceHeight
/
2
)
;
VideoFrame
.
I420Buffer
frameBuffer
=
JavaI420Buffer
.
allocate
(
width
height
)
;
ByteBuffer
dataY
=
frameBuffer
.
getDataY
(
)
;
buffer
.
position
(
yPos
)
;
buffer
.
limit
(
uPos
)
;
dataY
.
put
(
buffer
)
;
ByteBuffer
dataU
=
frameBuffer
.
getDataU
(
)
;
buffer
.
position
(
uPos
)
;
buffer
.
limit
(
uEnd
)
;
dataU
.
put
(
buffer
)
;
if
(
sliceHeight
%
2
!
=
0
)
{
buffer
.
position
(
uEnd
-
uvStride
)
;
dataU
.
put
(
buffer
)
;
}
ByteBuffer
dataV
=
frameBuffer
.
getDataV
(
)
;
buffer
.
position
(
vPos
)
;
buffer
.
limit
(
vEnd
)
;
dataV
.
put
(
buffer
)
;
if
(
sliceHeight
%
2
!
=
0
)
{
buffer
.
position
(
vEnd
-
uvStride
)
;
dataV
.
put
(
buffer
)
;
}
return
frameBuffer
;
}
private
void
reformat
(
MediaFormat
format
)
{
outputThreadChecker
.
checkIsOnValidThread
(
)
;
Logging
.
d
(
TAG
"
Decoder
format
changed
:
"
+
format
.
toString
(
)
)
;
final
int
newWidth
;
final
int
newHeight
;
if
(
format
.
containsKey
(
MEDIA_FORMAT_KEY_CROP_LEFT
)
&
&
format
.
containsKey
(
MEDIA_FORMAT_KEY_CROP_RIGHT
)
&
&
format
.
containsKey
(
MEDIA_FORMAT_KEY_CROP_BOTTOM
)
&
&
format
.
containsKey
(
MEDIA_FORMAT_KEY_CROP_TOP
)
)
{
newWidth
=
1
+
format
.
getInteger
(
MEDIA_FORMAT_KEY_CROP_RIGHT
)
-
format
.
getInteger
(
MEDIA_FORMAT_KEY_CROP_LEFT
)
;
newHeight
=
1
+
format
.
getInteger
(
MEDIA_FORMAT_KEY_CROP_BOTTOM
)
-
format
.
getInteger
(
MEDIA_FORMAT_KEY_CROP_TOP
)
;
}
else
{
newWidth
=
format
.
getInteger
(
MediaFormat
.
KEY_WIDTH
)
;
newHeight
=
format
.
getInteger
(
MediaFormat
.
KEY_HEIGHT
)
;
}
synchronized
(
dimensionLock
)
{
if
(
hasDecodedFirstFrame
&
&
(
width
!
=
newWidth
|
|
height
!
=
newHeight
)
)
{
stopOnOutputThread
(
new
RuntimeException
(
"
Unexpected
size
change
.
Configured
"
+
width
+
"
*
"
+
height
+
"
.
New
"
+
newWidth
+
"
*
"
+
newHeight
)
)
;
return
;
}
width
=
newWidth
;
height
=
newHeight
;
}
if
(
surfaceTextureHelper
=
=
null
&
&
format
.
containsKey
(
MediaFormat
.
KEY_COLOR_FORMAT
)
)
{
colorFormat
=
format
.
getInteger
(
MediaFormat
.
KEY_COLOR_FORMAT
)
;
Logging
.
d
(
TAG
"
Color
:
0x
"
+
Integer
.
toHexString
(
colorFormat
)
)
;
if
(
!
isSupportedColorFormat
(
colorFormat
)
)
{
stopOnOutputThread
(
new
IllegalStateException
(
"
Unsupported
color
format
:
"
+
colorFormat
)
)
;
return
;
}
}
synchronized
(
dimensionLock
)
{
if
(
format
.
containsKey
(
MEDIA_FORMAT_KEY_STRIDE
)
)
{
stride
=
format
.
getInteger
(
MEDIA_FORMAT_KEY_STRIDE
)
;
}
if
(
format
.
containsKey
(
MEDIA_FORMAT_KEY_SLICE_HEIGHT
)
)
{
sliceHeight
=
format
.
getInteger
(
MEDIA_FORMAT_KEY_SLICE_HEIGHT
)
;
}
Logging
.
d
(
TAG
"
Frame
stride
and
slice
height
:
"
+
stride
+
"
x
"
+
sliceHeight
)
;
stride
=
Math
.
max
(
width
stride
)
;
sliceHeight
=
Math
.
max
(
height
sliceHeight
)
;
}
}
private
void
releaseCodecOnOutputThread
(
)
{
outputThreadChecker
.
checkIsOnValidThread
(
)
;
Logging
.
d
(
TAG
"
Releasing
MediaCodec
on
output
thread
"
)
;
try
{
codec
.
stop
(
)
;
}
catch
(
Exception
e
)
{
Logging
.
e
(
TAG
"
Media
decoder
stop
failed
"
e
)
;
}
try
{
codec
.
release
(
)
;
}
catch
(
Exception
e
)
{
Logging
.
e
(
TAG
"
Media
decoder
release
failed
"
e
)
;
shutdownException
=
e
;
}
Logging
.
d
(
TAG
"
Release
on
output
thread
done
"
)
;
}
private
void
stopOnOutputThread
(
Exception
e
)
{
outputThreadChecker
.
checkIsOnValidThread
(
)
;
running
=
false
;
shutdownException
=
e
;
}
private
boolean
isSupportedColorFormat
(
int
colorFormat
)
{
for
(
int
supported
:
MediaCodecUtils
.
DECODER_COLOR_FORMATS
)
{
if
(
supported
=
=
colorFormat
)
{
return
true
;
}
}
return
false
;
}
}
