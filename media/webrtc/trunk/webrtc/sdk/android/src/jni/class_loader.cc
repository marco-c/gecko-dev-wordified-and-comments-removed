#
include
"
sdk
/
android
/
src
/
jni
/
class_loader
.
h
"
#
include
<
algorithm
>
#
include
<
string
>
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
sdk
/
android
/
generated_base_jni
/
jni
/
WebRtcClassLoader_jni
.
h
"
#
define
CHECK_EXCEPTION
(
jni
)
\
RTC_CHECK
(
!
jni
-
>
ExceptionCheck
(
)
)
\
<
<
(
jni
-
>
ExceptionDescribe
(
)
jni
-
>
ExceptionClear
(
)
"
"
)
namespace
webrtc
{
namespace
jni
{
namespace
{
class
ClassLoader
{
public
:
explicit
ClassLoader
(
JNIEnv
*
env
)
{
class_loader_class_
=
reinterpret_cast
<
jclass
>
(
env
-
>
NewGlobalRef
(
env
-
>
FindClass
(
"
java
/
lang
/
ClassLoader
"
)
)
)
;
CHECK_EXCEPTION
(
env
)
;
load_class_method_
=
env
-
>
GetMethodID
(
class_loader_class_
"
loadClass
"
"
(
Ljava
/
lang
/
String
;
)
Ljava
/
lang
/
Class
;
"
)
;
CHECK_EXCEPTION
(
env
)
;
class_loader_
=
env
-
>
NewGlobalRef
(
Java_WebRtcClassLoader_getClassLoader
(
env
)
)
;
CHECK_EXCEPTION
(
env
)
;
}
jclass
FindClass
(
JNIEnv
*
env
const
char
*
c_name
)
{
std
:
:
string
name
(
c_name
)
;
std
:
:
replace
(
name
.
begin
(
)
name
.
end
(
)
'
/
'
'
.
'
)
;
jstring
jstr
=
env
-
>
NewStringUTF
(
name
.
c_str
(
)
)
;
const
jclass
clazz
=
static_cast
<
jclass
>
(
env
-
>
CallObjectMethod
(
class_loader_
load_class_method_
jstr
)
)
;
CHECK_EXCEPTION
(
env
)
;
return
clazz
;
}
private
:
jclass
class_loader_class_
;
jmethodID
load_class_method_
;
jobject
class_loader_
;
}
;
static
ClassLoader
*
g_class_loader
=
nullptr
;
}
void
InitClassLoader
(
JNIEnv
*
env
)
{
RTC_CHECK
(
g_class_loader
=
=
nullptr
)
;
g_class_loader
=
new
ClassLoader
(
env
)
;
}
jclass
GetClass
(
JNIEnv
*
env
const
char
*
name
)
{
return
(
g_class_loader
=
=
nullptr
)
?
env
-
>
FindClass
(
name
)
:
g_class_loader
-
>
FindClass
(
env
name
)
;
}
}
}
