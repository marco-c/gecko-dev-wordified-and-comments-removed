package
org
.
webrtc
;
import
static
org
.
junit
.
Assert
.
assertEquals
;
import
static
org
.
junit
.
Assert
.
assertFalse
;
import
static
org
.
junit
.
Assert
.
assertNotNull
;
import
static
org
.
junit
.
Assert
.
assertNull
;
import
static
org
.
junit
.
Assert
.
assertTrue
;
import
static
org
.
junit
.
Assert
.
fail
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
opengl
.
GLES11Ext
;
import
android
.
opengl
.
GLES20
;
import
android
.
support
.
test
.
InstrumentationRegistry
;
import
android
.
support
.
test
.
filters
.
SmallTest
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
concurrent
.
CountDownLatch
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
org
.
chromium
.
base
.
test
.
BaseJUnit4ClassRunner
;
import
org
.
junit
.
After
;
import
org
.
junit
.
Before
;
import
org
.
junit
.
Test
;
import
org
.
junit
.
runner
.
RunWith
;
RunWith
(
BaseJUnit4ClassRunner
.
class
)
public
class
EglRendererTest
{
final
static
String
TAG
=
"
EglRendererTest
"
;
final
static
int
RENDER_WAIT_MS
=
1000
;
final
static
int
SURFACE_WAIT_MS
=
1000
;
final
static
int
TEST_FRAME_WIDTH
=
4
;
final
static
int
TEST_FRAME_HEIGHT
=
4
;
final
static
int
REMOVE_FRAME_LISTENER_RACY_NUM_TESTS
=
10
;
final
static
ByteBuffer
[
]
[
]
TEST_FRAMES
=
{
{
ByteBuffer
.
wrap
(
new
byte
[
]
{
11
-
12
13
-
14
-
15
16
-
17
18
19
-
110
111
-
112
-
113
114
-
115
116
}
)
ByteBuffer
.
wrap
(
new
byte
[
]
{
117
118
119
120
}
)
ByteBuffer
.
wrap
(
new
byte
[
]
{
121
122
123
124
}
)
}
{
ByteBuffer
.
wrap
(
new
byte
[
]
{
-
11
-
12
-
13
-
14
-
15
-
16
-
17
-
18
-
19
-
110
-
111
-
112
-
113
-
114
-
115
-
116
}
)
ByteBuffer
.
wrap
(
new
byte
[
]
{
-
121
-
122
-
123
-
124
}
)
ByteBuffer
.
wrap
(
new
byte
[
]
{
-
117
-
118
-
119
-
120
}
)
}
{
ByteBuffer
.
wrap
(
new
byte
[
]
{
-
11
-
12
-
13
-
14
-
15
-
16
-
17
-
18
-
19
-
110
-
111
-
112
-
113
-
114
-
115
-
116
}
)
ByteBuffer
.
wrap
(
new
byte
[
]
{
117
118
119
120
}
)
ByteBuffer
.
wrap
(
new
byte
[
]
{
121
122
123
124
}
)
}
}
;
private
class
TestFrameListener
implements
EglRenderer
.
FrameListener
{
final
private
ArrayList
<
Bitmap
>
bitmaps
=
new
ArrayList
<
Bitmap
>
(
)
;
boolean
bitmapReceived
;
Bitmap
storedBitmap
;
Override
public
synchronized
void
onFrame
(
Bitmap
bitmap
)
{
if
(
bitmapReceived
)
{
fail
(
"
Unexpected
bitmap
was
received
.
"
)
;
}
bitmapReceived
=
true
;
storedBitmap
=
bitmap
;
notify
(
)
;
}
public
synchronized
boolean
waitForBitmap
(
int
timeoutMs
)
throws
InterruptedException
{
if
(
!
bitmapReceived
)
{
wait
(
timeoutMs
)
;
}
return
bitmapReceived
;
}
public
synchronized
Bitmap
resetAndGetBitmap
(
)
{
bitmapReceived
=
false
;
return
storedBitmap
;
}
}
final
TestFrameListener
testFrameListener
=
new
TestFrameListener
(
)
;
EglRenderer
eglRenderer
;
CountDownLatch
surfaceReadyLatch
=
new
CountDownLatch
(
1
)
;
int
oesTextureId
;
SurfaceTexture
surfaceTexture
;
Before
public
void
setUp
(
)
throws
Exception
{
PeerConnectionFactory
.
initializeAndroidGlobals
(
InstrumentationRegistry
.
getTargetContext
(
)
true
true
true
)
;
eglRenderer
=
new
EglRenderer
(
"
TestRenderer
:
"
)
;
eglRenderer
.
init
(
null
EglBase
.
CONFIG_RGBA
new
GlRectDrawer
(
)
)
;
oesTextureId
=
GlUtil
.
generateTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
)
;
surfaceTexture
=
new
SurfaceTexture
(
oesTextureId
)
;
surfaceTexture
.
setDefaultBufferSize
(
1
1
)
;
eglRenderer
.
createEglSurface
(
surfaceTexture
)
;
}
After
public
void
tearDown
(
)
{
surfaceTexture
.
release
(
)
;
GLES20
.
glDeleteTextures
(
1
new
int
[
]
{
oesTextureId
}
0
)
;
eglRenderer
.
release
(
)
;
}
private
static
void
checkBitmap
(
Bitmap
bitmap
float
scale
)
{
assertNotNull
(
bitmap
)
;
assertEquals
(
(
int
)
(
TEST_FRAME_WIDTH
*
scale
)
bitmap
.
getWidth
(
)
)
;
assertEquals
(
(
int
)
(
TEST_FRAME_HEIGHT
*
scale
)
bitmap
.
getHeight
(
)
)
;
}
private
static
float
linearSample
(
ByteBuffer
plane
int
planeWidth
int
planeHeight
float
x
float
y
)
{
final
int
stride
=
planeWidth
;
final
float
coordX
=
x
*
planeWidth
;
final
float
coordY
=
y
*
planeHeight
;
int
lowIndexX
=
(
int
)
Math
.
floor
(
coordX
-
0
.
5f
)
;
int
lowIndexY
=
(
int
)
Math
.
floor
(
coordY
-
0
.
5f
)
;
int
highIndexX
=
lowIndexX
+
1
;
int
highIndexY
=
lowIndexY
+
1
;
final
float
highWeightX
=
coordX
-
lowIndexX
-
0
.
5f
;
final
float
highWeightY
=
coordY
-
lowIndexY
-
0
.
5f
;
final
float
lowWeightX
=
1f
-
highWeightX
;
final
float
lowWeightY
=
1f
-
highWeightY
;
lowIndexX
=
Math
.
max
(
0
lowIndexX
)
;
lowIndexY
=
Math
.
max
(
0
lowIndexY
)
;
highIndexX
=
Math
.
min
(
planeWidth
-
1
highIndexX
)
;
highIndexY
=
Math
.
min
(
planeHeight
-
1
highIndexY
)
;
float
lowYValue
=
(
plane
.
get
(
lowIndexY
*
stride
+
lowIndexX
)
&
0xFF
)
*
lowWeightX
+
(
plane
.
get
(
lowIndexY
*
stride
+
highIndexX
)
&
0xFF
)
*
highWeightX
;
float
highYValue
=
(
plane
.
get
(
highIndexY
*
stride
+
lowIndexX
)
&
0xFF
)
*
lowWeightX
+
(
plane
.
get
(
highIndexY
*
stride
+
highIndexX
)
&
0xFF
)
*
highWeightX
;
return
(
lowWeightY
*
lowYValue
+
highWeightY
*
highYValue
)
/
255f
;
}
private
static
byte
saturatedFloatToByte
(
float
c
)
{
return
(
byte
)
Math
.
round
(
255f
*
Math
.
max
(
0f
Math
.
min
(
1f
c
)
)
)
;
}
private
static
byte
[
]
convertYUVFrameToRGBA
(
ByteBuffer
[
]
yuvFrame
)
{
final
byte
[
]
argbFrame
=
new
byte
[
TEST_FRAME_WIDTH
*
TEST_FRAME_HEIGHT
*
4
]
;
final
int
argbStride
=
TEST_FRAME_WIDTH
*
4
;
final
int
yStride
=
TEST_FRAME_WIDTH
;
final
int
vStride
=
TEST_FRAME_WIDTH
/
2
;
for
(
int
y
=
0
;
y
<
TEST_FRAME_HEIGHT
;
y
+
+
)
{
for
(
int
x
=
0
;
x
<
TEST_FRAME_WIDTH
;
x
+
+
)
{
final
int
x2
=
x
/
2
;
final
int
y2
=
y
/
2
;
final
float
yC
=
(
yuvFrame
[
0
]
.
get
(
y
*
yStride
+
x
)
&
0xFF
)
/
255f
;
final
float
uC
=
linearSample
(
yuvFrame
[
1
]
TEST_FRAME_WIDTH
/
2
TEST_FRAME_HEIGHT
/
2
(
x
+
0
.
5f
)
/
TEST_FRAME_WIDTH
(
y
+
0
.
5f
)
/
TEST_FRAME_HEIGHT
)
-
0
.
5f
;
final
float
vC
=
linearSample
(
yuvFrame
[
2
]
TEST_FRAME_WIDTH
/
2
TEST_FRAME_HEIGHT
/
2
(
x
+
0
.
5f
)
/
TEST_FRAME_WIDTH
(
y
+
0
.
5f
)
/
TEST_FRAME_HEIGHT
)
-
0
.
5f
;
final
float
rC
=
yC
+
1
.
403f
*
vC
;
final
float
gC
=
yC
-
0
.
344f
*
uC
-
0
.
714f
*
vC
;
final
float
bC
=
yC
+
1
.
77f
*
uC
;
argbFrame
[
y
*
argbStride
+
x
*
4
+
0
]
=
saturatedFloatToByte
(
rC
)
;
argbFrame
[
y
*
argbStride
+
x
*
4
+
1
]
=
saturatedFloatToByte
(
gC
)
;
argbFrame
[
y
*
argbStride
+
x
*
4
+
2
]
=
saturatedFloatToByte
(
bC
)
;
argbFrame
[
y
*
argbStride
+
x
*
4
+
3
]
=
(
byte
)
255
;
}
}
return
argbFrame
;
}
private
static
void
checkBitmapContent
(
Bitmap
bitmap
int
frame
)
{
checkBitmap
(
bitmap
1f
)
;
byte
[
]
expectedRGBA
=
convertYUVFrameToRGBA
(
TEST_FRAMES
[
frame
]
)
;
ByteBuffer
bitmapBuffer
=
ByteBuffer
.
allocateDirect
(
bitmap
.
getByteCount
(
)
)
;
bitmap
.
copyPixelsToBuffer
(
bitmapBuffer
)
;
for
(
int
i
=
0
;
i
<
expectedRGBA
.
length
;
i
+
+
)
{
int
expected
=
expectedRGBA
[
i
]
&
0xFF
;
int
value
=
bitmapBuffer
.
get
(
i
)
&
0xFF
;
if
(
Math
.
abs
(
value
-
expected
)
>
1
)
{
Logging
.
d
(
TAG
"
Expected
bitmap
content
:
"
+
Arrays
.
toString
(
expectedRGBA
)
)
;
Logging
.
d
(
TAG
"
Bitmap
content
:
"
+
Arrays
.
toString
(
bitmapBuffer
.
array
(
)
)
)
;
fail
(
"
Frame
doesn
'
t
match
original
frame
on
byte
"
+
i
+
"
.
Expected
:
"
+
expected
+
"
Result
:
"
+
value
)
;
}
}
}
private
void
feedFrame
(
int
i
)
{
eglRenderer
.
renderFrame
(
new
VideoRenderer
.
I420Frame
(
TEST_FRAME_WIDTH
TEST_FRAME_HEIGHT
0
new
int
[
]
{
TEST_FRAME_WIDTH
TEST_FRAME_WIDTH
/
2
TEST_FRAME_WIDTH
/
2
}
TEST_FRAMES
[
i
]
0
)
)
;
}
Test
SmallTest
public
void
testAddFrameListener
(
)
throws
Exception
{
eglRenderer
.
addFrameListener
(
testFrameListener
0f
)
;
feedFrame
(
0
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
assertNull
(
testFrameListener
.
resetAndGetBitmap
(
)
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
0f
)
;
feedFrame
(
1
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
assertNull
(
testFrameListener
.
resetAndGetBitmap
(
)
)
;
feedFrame
(
2
)
;
assertFalse
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
}
Test
SmallTest
public
void
testAddFrameListenerBitmap
(
)
throws
Exception
{
eglRenderer
.
addFrameListener
(
testFrameListener
1f
)
;
feedFrame
(
0
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
checkBitmapContent
(
testFrameListener
.
resetAndGetBitmap
(
)
0
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
1f
)
;
feedFrame
(
1
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
checkBitmapContent
(
testFrameListener
.
resetAndGetBitmap
(
)
1
)
;
}
Test
SmallTest
public
void
testAddFrameListenerBitmapScale
(
)
throws
Exception
{
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
float
scale
=
i
*
0
.
5f
+
0
.
5f
;
eglRenderer
.
addFrameListener
(
testFrameListener
scale
)
;
feedFrame
(
i
)
;
assertTrue
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
checkBitmap
(
testFrameListener
.
resetAndGetBitmap
(
)
scale
)
;
}
}
Test
SmallTest
public
void
testFrameListenerNotCalledWithOldFrames
(
)
throws
Exception
{
feedFrame
(
0
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
0f
)
;
assertFalse
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
}
Test
SmallTest
public
void
testRemoveFrameListenerNotRacy
(
)
throws
Exception
{
for
(
int
i
=
0
;
i
<
REMOVE_FRAME_LISTENER_RACY_NUM_TESTS
;
i
+
+
)
{
feedFrame
(
0
)
;
eglRenderer
.
addFrameListener
(
testFrameListener
0f
)
;
eglRenderer
.
removeFrameListener
(
testFrameListener
)
;
feedFrame
(
1
)
;
}
assertFalse
(
testFrameListener
.
waitForBitmap
(
RENDER_WAIT_MS
)
)
;
}
}
