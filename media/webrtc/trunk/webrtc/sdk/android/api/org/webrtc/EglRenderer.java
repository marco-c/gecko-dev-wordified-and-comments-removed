package
org
.
webrtc
;
import
android
.
graphics
.
Bitmap
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
opengl
.
GLES20
;
import
android
.
os
.
Handler
;
import
android
.
os
.
HandlerThread
;
import
android
.
os
.
Looper
;
import
android
.
view
.
Surface
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Locale
;
import
java
.
util
.
concurrent
.
CountDownLatch
;
import
java
.
util
.
concurrent
.
TimeUnit
;
public
class
EglRenderer
implements
VideoRenderer
.
Callbacks
{
private
static
final
String
TAG
=
"
EglRenderer
"
;
private
static
final
long
LOG_INTERVAL_SEC
=
4
;
private
static
final
int
MAX_SURFACE_CLEAR_COUNT
=
3
;
public
interface
FrameListener
{
void
onFrame
(
Bitmap
frame
)
;
}
private
static
class
FrameListenerAndParams
{
public
final
FrameListener
listener
;
public
final
float
scale
;
public
final
RendererCommon
.
GlDrawer
drawer
;
public
FrameListenerAndParams
(
FrameListener
listener
float
scale
RendererCommon
.
GlDrawer
drawer
)
{
this
.
listener
=
listener
;
this
.
scale
=
scale
;
this
.
drawer
=
drawer
;
}
}
private
class
EglSurfaceCreation
implements
Runnable
{
private
Object
surface
;
public
synchronized
void
setSurface
(
Object
surface
)
{
this
.
surface
=
surface
;
}
Override
public
synchronized
void
run
(
)
{
if
(
surface
!
=
null
&
&
eglBase
!
=
null
&
&
!
eglBase
.
hasSurface
(
)
)
{
if
(
surface
instanceof
Surface
)
{
eglBase
.
createSurface
(
(
Surface
)
surface
)
;
}
else
if
(
surface
instanceof
SurfaceTexture
)
{
eglBase
.
createSurface
(
(
SurfaceTexture
)
surface
)
;
}
else
{
throw
new
IllegalStateException
(
"
Invalid
surface
:
"
+
surface
)
;
}
eglBase
.
makeCurrent
(
)
;
GLES20
.
glPixelStorei
(
GLES20
.
GL_UNPACK_ALIGNMENT
1
)
;
}
}
}
private
final
String
name
;
private
final
Object
handlerLock
=
new
Object
(
)
;
private
Handler
renderThreadHandler
;
private
final
ArrayList
<
FrameListenerAndParams
>
frameListeners
=
new
ArrayList
<
>
(
)
;
private
final
Object
fpsReductionLock
=
new
Object
(
)
;
private
long
nextFrameTimeNs
;
private
long
minRenderPeriodNs
;
private
EglBase
eglBase
;
private
final
RendererCommon
.
YuvUploader
yuvUploader
=
new
RendererCommon
.
YuvUploader
(
)
;
private
RendererCommon
.
GlDrawer
drawer
;
private
int
[
]
yuvTextures
=
null
;
private
final
Object
frameLock
=
new
Object
(
)
;
private
VideoRenderer
.
I420Frame
pendingFrame
;
private
final
Object
layoutLock
=
new
Object
(
)
;
private
float
layoutAspectRatio
;
private
boolean
mirror
;
private
final
Object
statisticsLock
=
new
Object
(
)
;
private
int
framesReceived
;
private
int
framesDropped
;
private
int
framesRendered
;
private
long
statisticsStartTimeNs
;
private
long
renderTimeNs
;
private
long
renderSwapBufferTimeNs
;
private
GlTextureFrameBuffer
bitmapTextureFramebuffer
;
private
final
Runnable
renderFrameRunnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
renderFrameOnRenderThread
(
)
;
}
}
;
private
final
Runnable
logStatisticsRunnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
logStatistics
(
)
;
synchronized
(
handlerLock
)
{
if
(
renderThreadHandler
!
=
null
)
{
renderThreadHandler
.
removeCallbacks
(
logStatisticsRunnable
)
;
renderThreadHandler
.
postDelayed
(
logStatisticsRunnable
TimeUnit
.
SECONDS
.
toMillis
(
LOG_INTERVAL_SEC
)
)
;
}
}
}
}
;
private
final
EglSurfaceCreation
eglSurfaceCreationRunnable
=
new
EglSurfaceCreation
(
)
;
public
EglRenderer
(
String
name
)
{
this
.
name
=
name
;
}
public
void
init
(
final
EglBase
.
Context
sharedContext
final
int
[
]
configAttributes
RendererCommon
.
GlDrawer
drawer
)
{
synchronized
(
handlerLock
)
{
if
(
renderThreadHandler
!
=
null
)
{
throw
new
IllegalStateException
(
name
+
"
Already
initialized
"
)
;
}
logD
(
"
Initializing
EglRenderer
"
)
;
this
.
drawer
=
drawer
;
final
HandlerThread
renderThread
=
new
HandlerThread
(
name
+
"
EglRenderer
"
)
;
renderThread
.
start
(
)
;
renderThreadHandler
=
new
Handler
(
renderThread
.
getLooper
(
)
)
;
ThreadUtils
.
invokeAtFrontUninterruptibly
(
renderThreadHandler
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
sharedContext
=
=
null
)
{
logD
(
"
EglBase10
.
create
context
"
)
;
eglBase
=
new
EglBase10
(
null
configAttributes
)
;
}
else
{
logD
(
"
EglBase
.
create
shared
context
"
)
;
eglBase
=
EglBase
.
create
(
sharedContext
configAttributes
)
;
}
}
}
)
;
renderThreadHandler
.
post
(
eglSurfaceCreationRunnable
)
;
final
long
currentTimeNs
=
System
.
nanoTime
(
)
;
resetStatistics
(
currentTimeNs
)
;
renderThreadHandler
.
postDelayed
(
logStatisticsRunnable
TimeUnit
.
SECONDS
.
toMillis
(
LOG_INTERVAL_SEC
)
)
;
}
}
public
void
createEglSurface
(
Surface
surface
)
{
createEglSurfaceInternal
(
surface
)
;
}
public
void
createEglSurface
(
SurfaceTexture
surfaceTexture
)
{
createEglSurfaceInternal
(
surfaceTexture
)
;
}
private
void
createEglSurfaceInternal
(
Object
surface
)
{
eglSurfaceCreationRunnable
.
setSurface
(
surface
)
;
postToRenderThread
(
eglSurfaceCreationRunnable
)
;
}
public
void
release
(
)
{
logD
(
"
Releasing
.
"
)
;
final
CountDownLatch
eglCleanupBarrier
=
new
CountDownLatch
(
1
)
;
synchronized
(
handlerLock
)
{
if
(
renderThreadHandler
=
=
null
)
{
logD
(
"
Already
released
"
)
;
return
;
}
renderThreadHandler
.
removeCallbacks
(
logStatisticsRunnable
)
;
renderThreadHandler
.
postAtFrontOfQueue
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
drawer
!
=
null
)
{
drawer
.
release
(
)
;
drawer
=
null
;
}
if
(
yuvTextures
!
=
null
)
{
GLES20
.
glDeleteTextures
(
3
yuvTextures
0
)
;
yuvTextures
=
null
;
}
if
(
bitmapTextureFramebuffer
!
=
null
)
{
bitmapTextureFramebuffer
.
release
(
)
;
bitmapTextureFramebuffer
=
null
;
}
if
(
eglBase
!
=
null
)
{
logD
(
"
eglBase
detach
and
release
.
"
)
;
eglBase
.
detachCurrent
(
)
;
eglBase
.
release
(
)
;
eglBase
=
null
;
}
eglCleanupBarrier
.
countDown
(
)
;
}
}
)
;
final
Looper
renderLooper
=
renderThreadHandler
.
getLooper
(
)
;
renderThreadHandler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
logD
(
"
Quitting
render
thread
.
"
)
;
renderLooper
.
quit
(
)
;
}
}
)
;
renderThreadHandler
=
null
;
}
ThreadUtils
.
awaitUninterruptibly
(
eglCleanupBarrier
)
;
synchronized
(
frameLock
)
{
if
(
pendingFrame
!
=
null
)
{
VideoRenderer
.
renderFrameDone
(
pendingFrame
)
;
pendingFrame
=
null
;
}
}
logD
(
"
Releasing
done
.
"
)
;
}
private
void
resetStatistics
(
long
currentTimeNs
)
{
synchronized
(
statisticsLock
)
{
statisticsStartTimeNs
=
currentTimeNs
;
framesReceived
=
0
;
framesDropped
=
0
;
framesRendered
=
0
;
renderTimeNs
=
0
;
renderSwapBufferTimeNs
=
0
;
}
}
public
void
printStackTrace
(
)
{
synchronized
(
handlerLock
)
{
final
Thread
renderThread
=
(
renderThreadHandler
=
=
null
)
?
null
:
renderThreadHandler
.
getLooper
(
)
.
getThread
(
)
;
if
(
renderThread
!
=
null
)
{
final
StackTraceElement
[
]
renderStackTrace
=
renderThread
.
getStackTrace
(
)
;
if
(
renderStackTrace
.
length
>
0
)
{
logD
(
"
EglRenderer
stack
trace
:
"
)
;
for
(
StackTraceElement
traceElem
:
renderStackTrace
)
{
logD
(
traceElem
.
toString
(
)
)
;
}
}
}
}
}
public
void
setMirror
(
final
boolean
mirror
)
{
logD
(
"
setMirror
:
"
+
mirror
)
;
synchronized
(
layoutLock
)
{
this
.
mirror
=
mirror
;
}
}
public
void
setLayoutAspectRatio
(
float
layoutAspectRatio
)
{
logD
(
"
setLayoutAspectRatio
:
"
+
layoutAspectRatio
)
;
synchronized
(
layoutLock
)
{
this
.
layoutAspectRatio
=
layoutAspectRatio
;
}
}
public
void
setFpsReduction
(
float
fps
)
{
logD
(
"
setFpsReduction
:
"
+
fps
)
;
synchronized
(
fpsReductionLock
)
{
final
long
previousRenderPeriodNs
=
minRenderPeriodNs
;
if
(
fps
<
=
0
)
{
minRenderPeriodNs
=
Long
.
MAX_VALUE
;
}
else
{
minRenderPeriodNs
=
(
long
)
(
TimeUnit
.
SECONDS
.
toNanos
(
1
)
/
fps
)
;
}
if
(
minRenderPeriodNs
!
=
previousRenderPeriodNs
)
{
nextFrameTimeNs
=
System
.
nanoTime
(
)
;
}
}
}
public
void
disableFpsReduction
(
)
{
setFpsReduction
(
Float
.
POSITIVE_INFINITY
)
;
}
public
void
pauseVideo
(
)
{
setFpsReduction
(
0
)
;
}
public
void
addFrameListener
(
final
FrameListener
listener
final
float
scale
)
{
postToRenderThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
frameListeners
.
add
(
new
FrameListenerAndParams
(
listener
scale
drawer
)
)
;
}
}
)
;
}
public
void
addFrameListener
(
final
FrameListener
listener
final
float
scale
final
RendererCommon
.
GlDrawer
drawer
)
{
postToRenderThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
frameListeners
.
add
(
new
FrameListenerAndParams
(
listener
scale
drawer
)
)
;
}
}
)
;
}
public
void
removeFrameListener
(
final
FrameListener
listener
)
{
final
CountDownLatch
latch
=
new
CountDownLatch
(
1
)
;
postToRenderThread
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
latch
.
countDown
(
)
;
final
Iterator
<
FrameListenerAndParams
>
iter
=
frameListeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
if
(
iter
.
next
(
)
.
listener
=
=
listener
)
{
iter
.
remove
(
)
;
}
}
}
}
)
;
ThreadUtils
.
awaitUninterruptibly
(
latch
)
;
}
Override
public
void
renderFrame
(
VideoRenderer
.
I420Frame
frame
)
{
synchronized
(
statisticsLock
)
{
+
+
framesReceived
;
}
final
boolean
dropOldFrame
;
synchronized
(
handlerLock
)
{
if
(
renderThreadHandler
=
=
null
)
{
logD
(
"
Dropping
frame
-
Not
initialized
or
already
released
.
"
)
;
VideoRenderer
.
renderFrameDone
(
frame
)
;
return
;
}
synchronized
(
fpsReductionLock
)
{
if
(
minRenderPeriodNs
>
0
)
{
final
long
currentTimeNs
=
System
.
nanoTime
(
)
;
if
(
currentTimeNs
<
nextFrameTimeNs
)
{
logD
(
"
Dropping
frame
-
fps
reduction
is
active
.
"
)
;
VideoRenderer
.
renderFrameDone
(
frame
)
;
return
;
}
nextFrameTimeNs
+
=
minRenderPeriodNs
;
nextFrameTimeNs
=
Math
.
max
(
nextFrameTimeNs
currentTimeNs
)
;
}
}
synchronized
(
frameLock
)
{
dropOldFrame
=
(
pendingFrame
!
=
null
)
;
if
(
dropOldFrame
)
{
VideoRenderer
.
renderFrameDone
(
pendingFrame
)
;
}
pendingFrame
=
frame
;
renderThreadHandler
.
post
(
renderFrameRunnable
)
;
}
}
if
(
dropOldFrame
)
{
synchronized
(
statisticsLock
)
{
+
+
framesDropped
;
}
}
}
public
void
releaseEglSurface
(
final
Runnable
completionCallback
)
{
eglSurfaceCreationRunnable
.
setSurface
(
null
)
;
synchronized
(
handlerLock
)
{
if
(
renderThreadHandler
!
=
null
)
{
renderThreadHandler
.
removeCallbacks
(
eglSurfaceCreationRunnable
)
;
renderThreadHandler
.
postAtFrontOfQueue
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
eglBase
!
=
null
)
{
eglBase
.
detachCurrent
(
)
;
eglBase
.
releaseSurface
(
)
;
}
completionCallback
.
run
(
)
;
}
}
)
;
return
;
}
}
completionCallback
.
run
(
)
;
}
private
void
postToRenderThread
(
Runnable
runnable
)
{
synchronized
(
handlerLock
)
{
if
(
renderThreadHandler
!
=
null
)
{
renderThreadHandler
.
post
(
runnable
)
;
}
}
}
private
void
clearSurfaceOnRenderThread
(
)
{
if
(
eglBase
!
=
null
&
&
eglBase
.
hasSurface
(
)
)
{
logD
(
"
clearSurface
"
)
;
GLES20
.
glClearColor
(
0
0
0
0
)
;
GLES20
.
glClear
(
GLES20
.
GL_COLOR_BUFFER_BIT
)
;
eglBase
.
swapBuffers
(
)
;
}
}
public
void
clearImage
(
)
{
synchronized
(
handlerLock
)
{
if
(
renderThreadHandler
=
=
null
)
{
return
;
}
renderThreadHandler
.
postAtFrontOfQueue
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
clearSurfaceOnRenderThread
(
)
;
}
}
)
;
}
}
private
void
renderFrameOnRenderThread
(
)
{
final
VideoRenderer
.
I420Frame
frame
;
synchronized
(
frameLock
)
{
if
(
pendingFrame
=
=
null
)
{
return
;
}
frame
=
pendingFrame
;
pendingFrame
=
null
;
}
if
(
eglBase
=
=
null
|
|
!
eglBase
.
hasSurface
(
)
)
{
logD
(
"
Dropping
frame
-
No
surface
"
)
;
VideoRenderer
.
renderFrameDone
(
frame
)
;
return
;
}
final
long
startTimeNs
=
System
.
nanoTime
(
)
;
final
float
[
]
texMatrix
=
RendererCommon
.
rotateTextureMatrix
(
frame
.
samplingMatrix
frame
.
rotationDegree
)
;
final
float
[
]
drawMatrix
;
final
int
drawnFrameWidth
;
final
int
drawnFrameHeight
;
synchronized
(
layoutLock
)
{
final
float
[
]
layoutMatrix
;
if
(
layoutAspectRatio
>
0
)
{
final
float
frameAspectRatio
=
frame
.
rotatedWidth
(
)
/
(
float
)
frame
.
rotatedHeight
(
)
;
layoutMatrix
=
RendererCommon
.
getLayoutMatrix
(
mirror
frameAspectRatio
layoutAspectRatio
)
;
if
(
frameAspectRatio
>
layoutAspectRatio
)
{
drawnFrameWidth
=
(
int
)
(
frame
.
rotatedHeight
(
)
*
layoutAspectRatio
)
;
drawnFrameHeight
=
frame
.
rotatedHeight
(
)
;
}
else
{
drawnFrameWidth
=
frame
.
rotatedWidth
(
)
;
drawnFrameHeight
=
(
int
)
(
frame
.
rotatedWidth
(
)
/
layoutAspectRatio
)
;
}
}
else
{
layoutMatrix
=
mirror
?
RendererCommon
.
horizontalFlipMatrix
(
)
:
RendererCommon
.
identityMatrix
(
)
;
drawnFrameWidth
=
frame
.
rotatedWidth
(
)
;
drawnFrameHeight
=
frame
.
rotatedHeight
(
)
;
}
drawMatrix
=
RendererCommon
.
multiplyMatrices
(
texMatrix
layoutMatrix
)
;
}
GLES20
.
glClearColor
(
0
0
0
0
)
;
GLES20
.
glClear
(
GLES20
.
GL_COLOR_BUFFER_BIT
)
;
if
(
frame
.
yuvFrame
)
{
if
(
yuvTextures
=
=
null
)
{
yuvTextures
=
new
int
[
3
]
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
yuvTextures
[
i
]
=
GlUtil
.
generateTexture
(
GLES20
.
GL_TEXTURE_2D
)
;
}
}
yuvUploader
.
uploadYuvData
(
yuvTextures
frame
.
width
frame
.
height
frame
.
yuvStrides
frame
.
yuvPlanes
)
;
drawer
.
drawYuv
(
yuvTextures
drawMatrix
drawnFrameWidth
drawnFrameHeight
0
0
eglBase
.
surfaceWidth
(
)
eglBase
.
surfaceHeight
(
)
)
;
}
else
{
drawer
.
drawOes
(
frame
.
textureId
drawMatrix
drawnFrameWidth
drawnFrameHeight
0
0
eglBase
.
surfaceWidth
(
)
eglBase
.
surfaceHeight
(
)
)
;
}
final
long
swapBuffersStartTimeNs
=
System
.
nanoTime
(
)
;
eglBase
.
swapBuffers
(
)
;
final
long
currentTimeNs
=
System
.
nanoTime
(
)
;
synchronized
(
statisticsLock
)
{
+
+
framesRendered
;
renderTimeNs
+
=
(
currentTimeNs
-
startTimeNs
)
;
renderSwapBufferTimeNs
+
=
(
currentTimeNs
-
swapBuffersStartTimeNs
)
;
}
notifyCallbacks
(
frame
texMatrix
)
;
VideoRenderer
.
renderFrameDone
(
frame
)
;
}
private
void
notifyCallbacks
(
VideoRenderer
.
I420Frame
frame
float
[
]
texMatrix
)
{
final
ArrayList
<
FrameListenerAndParams
>
tmpList
;
if
(
frameListeners
.
isEmpty
(
)
)
return
;
tmpList
=
new
ArrayList
<
>
(
frameListeners
)
;
frameListeners
.
clear
(
)
;
final
float
[
]
bitmapMatrix
=
RendererCommon
.
multiplyMatrices
(
RendererCommon
.
multiplyMatrices
(
texMatrix
mirror
?
RendererCommon
.
horizontalFlipMatrix
(
)
:
RendererCommon
.
identityMatrix
(
)
)
RendererCommon
.
verticalFlipMatrix
(
)
)
;
for
(
FrameListenerAndParams
listenerAndParams
:
tmpList
)
{
final
int
scaledWidth
=
(
int
)
(
listenerAndParams
.
scale
*
frame
.
rotatedWidth
(
)
)
;
final
int
scaledHeight
=
(
int
)
(
listenerAndParams
.
scale
*
frame
.
rotatedHeight
(
)
)
;
if
(
scaledWidth
=
=
0
|
|
scaledHeight
=
=
0
)
{
listenerAndParams
.
listener
.
onFrame
(
null
)
;
continue
;
}
if
(
bitmapTextureFramebuffer
=
=
null
)
{
bitmapTextureFramebuffer
=
new
GlTextureFrameBuffer
(
GLES20
.
GL_RGBA
)
;
}
bitmapTextureFramebuffer
.
setSize
(
scaledWidth
scaledHeight
)
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
bitmapTextureFramebuffer
.
getFrameBufferId
(
)
)
;
GLES20
.
glFramebufferTexture2D
(
GLES20
.
GL_FRAMEBUFFER
GLES20
.
GL_COLOR_ATTACHMENT0
GLES20
.
GL_TEXTURE_2D
bitmapTextureFramebuffer
.
getTextureId
(
)
0
)
;
if
(
frame
.
yuvFrame
)
{
listenerAndParams
.
drawer
.
drawYuv
(
yuvTextures
bitmapMatrix
frame
.
rotatedWidth
(
)
frame
.
rotatedHeight
(
)
0
0
scaledWidth
scaledHeight
)
;
}
else
{
listenerAndParams
.
drawer
.
drawOes
(
frame
.
textureId
bitmapMatrix
frame
.
rotatedWidth
(
)
frame
.
rotatedHeight
(
)
0
0
scaledWidth
scaledHeight
)
;
}
final
ByteBuffer
bitmapBuffer
=
ByteBuffer
.
allocateDirect
(
scaledWidth
*
scaledHeight
*
4
)
;
GLES20
.
glViewport
(
0
0
scaledWidth
scaledHeight
)
;
GLES20
.
glReadPixels
(
0
0
scaledWidth
scaledHeight
GLES20
.
GL_RGBA
GLES20
.
GL_UNSIGNED_BYTE
bitmapBuffer
)
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
0
)
;
GlUtil
.
checkNoGLES2Error
(
"
EglRenderer
.
notifyCallbacks
"
)
;
final
Bitmap
bitmap
=
Bitmap
.
createBitmap
(
scaledWidth
scaledHeight
Bitmap
.
Config
.
ARGB_8888
)
;
bitmap
.
copyPixelsFromBuffer
(
bitmapBuffer
)
;
listenerAndParams
.
listener
.
onFrame
(
bitmap
)
;
}
}
private
String
averageTimeAsString
(
long
sumTimeNs
int
count
)
{
return
(
count
<
=
0
)
?
"
NA
"
:
TimeUnit
.
NANOSECONDS
.
toMicros
(
sumTimeNs
/
count
)
+
"
s
"
;
}
private
void
logStatistics
(
)
{
final
long
currentTimeNs
=
System
.
nanoTime
(
)
;
synchronized
(
statisticsLock
)
{
final
long
elapsedTimeNs
=
currentTimeNs
-
statisticsStartTimeNs
;
if
(
elapsedTimeNs
<
=
0
)
{
return
;
}
final
float
renderFps
=
framesRendered
*
TimeUnit
.
SECONDS
.
toNanos
(
1
)
/
(
float
)
elapsedTimeNs
;
logD
(
"
Duration
:
"
+
TimeUnit
.
NANOSECONDS
.
toMillis
(
elapsedTimeNs
)
+
"
ms
.
"
+
"
Frames
received
:
"
+
framesReceived
+
"
.
"
+
"
Dropped
:
"
+
framesDropped
+
"
.
"
+
"
Rendered
:
"
+
framesRendered
+
"
.
"
+
"
Render
fps
:
"
+
String
.
format
(
Locale
.
US
"
%
.
1f
"
renderFps
)
+
"
.
"
+
"
Average
render
time
:
"
+
averageTimeAsString
(
renderTimeNs
framesRendered
)
+
"
.
"
+
"
Average
swapBuffer
time
:
"
+
averageTimeAsString
(
renderSwapBufferTimeNs
framesRendered
)
+
"
.
"
)
;
resetStatistics
(
currentTimeNs
)
;
}
}
private
void
logD
(
String
string
)
{
Logging
.
d
(
TAG
name
+
string
)
;
}
}
