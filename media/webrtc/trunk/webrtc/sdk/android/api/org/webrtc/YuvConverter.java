package
org
.
webrtc
;
import
android
.
opengl
.
GLES11Ext
;
import
android
.
opengl
.
GLES20
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
FloatBuffer
;
import
org
.
webrtc
.
VideoFrame
.
I420Buffer
;
import
org
.
webrtc
.
VideoFrame
.
TextureBuffer
;
public
class
YuvConverter
{
private
static
final
FloatBuffer
DEVICE_RECTANGLE
=
GlUtil
.
createFloatBuffer
(
new
float
[
]
{
-
1
.
0f
-
1
.
0f
1
.
0f
-
1
.
0f
-
1
.
0f
1
.
0f
1
.
0f
1
.
0f
}
)
;
private
static
final
FloatBuffer
TEXTURE_RECTANGLE
=
GlUtil
.
createFloatBuffer
(
new
float
[
]
{
0
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
1
.
0f
1
.
0f
1
.
0f
}
)
;
private
static
final
String
VERTEX_SHADER
=
"
varying
vec2
interp_tc
;
\
n
"
+
"
attribute
vec4
in_pos
;
\
n
"
+
"
attribute
vec4
in_tc
;
\
n
"
+
"
\
n
"
+
"
uniform
mat4
texMatrix
;
\
n
"
+
"
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
gl_Position
=
in_pos
;
\
n
"
+
"
interp_tc
=
(
texMatrix
*
in_tc
)
.
xy
;
\
n
"
+
"
}
\
n
"
;
private
static
final
String
OES_FRAGMENT_SHADER
=
"
#
extension
GL_OES_EGL_image_external
:
require
\
n
"
+
"
precision
mediump
float
;
\
n
"
+
"
varying
vec2
interp_tc
;
\
n
"
+
"
\
n
"
+
"
uniform
samplerExternalOES
tex
;
\
n
"
+
"
uniform
vec2
xUnit
;
\
n
"
+
"
uniform
vec4
coeffs
;
\
n
"
+
"
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
gl_FragColor
.
r
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
tex
interp_tc
-
1
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
gl_FragColor
.
g
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
tex
interp_tc
-
0
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
gl_FragColor
.
b
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
tex
interp_tc
+
0
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
gl_FragColor
.
a
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
tex
interp_tc
+
1
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
}
\
n
"
;
private
static
final
String
RGB_FRAGMENT_SHADER
=
"
precision
mediump
float
;
\
n
"
+
"
varying
vec2
interp_tc
;
\
n
"
+
"
\
n
"
+
"
uniform
sampler2D
tex
;
\
n
"
+
"
uniform
vec2
xUnit
;
\
n
"
+
"
uniform
vec4
coeffs
;
\
n
"
+
"
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
gl_FragColor
.
r
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
tex
interp_tc
-
1
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
gl_FragColor
.
g
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
tex
interp_tc
-
0
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
gl_FragColor
.
b
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
tex
interp_tc
+
0
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
gl_FragColor
.
a
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
tex
interp_tc
+
1
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
}
\
n
"
;
private
final
ThreadUtils
.
ThreadChecker
threadChecker
=
new
ThreadUtils
.
ThreadChecker
(
)
;
private
final
GlTextureFrameBuffer
textureFrameBuffer
;
private
TextureBuffer
.
Type
shaderTextureType
;
private
GlShader
shader
;
private
int
texMatrixLoc
;
private
int
xUnitLoc
;
private
int
coeffsLoc
;
private
boolean
released
=
false
;
public
YuvConverter
(
)
{
threadChecker
.
checkIsOnValidThread
(
)
;
textureFrameBuffer
=
new
GlTextureFrameBuffer
(
GLES20
.
GL_RGBA
)
;
}
public
I420Buffer
convert
(
TextureBuffer
textureBuffer
)
{
final
int
width
=
textureBuffer
.
getWidth
(
)
;
final
int
height
=
textureBuffer
.
getHeight
(
)
;
final
int
stride
=
(
(
width
+
7
)
/
8
)
*
8
;
final
int
uvHeight
=
(
height
+
1
)
/
2
;
final
int
size
=
stride
*
(
height
+
uvHeight
+
1
)
;
ByteBuffer
buffer
=
JniCommon
.
allocateNativeByteBuffer
(
size
)
;
convert
(
buffer
width
height
stride
textureBuffer
.
getTextureId
(
)
RendererCommon
.
convertMatrixFromAndroidGraphicsMatrix
(
textureBuffer
.
getTransformMatrix
(
)
)
textureBuffer
.
getType
(
)
)
;
final
int
yPos
=
0
;
final
int
uPos
=
yPos
+
stride
*
height
;
final
int
vPos
=
uPos
+
stride
/
2
;
buffer
.
position
(
yPos
)
;
buffer
.
limit
(
yPos
+
stride
*
height
)
;
ByteBuffer
dataY
=
buffer
.
slice
(
)
;
buffer
.
position
(
uPos
)
;
buffer
.
limit
(
uPos
+
stride
*
uvHeight
)
;
ByteBuffer
dataU
=
buffer
.
slice
(
)
;
buffer
.
position
(
vPos
)
;
buffer
.
limit
(
vPos
+
stride
*
uvHeight
)
;
ByteBuffer
dataV
=
buffer
.
slice
(
)
;
return
JavaI420Buffer
.
wrap
(
width
height
dataY
stride
dataU
stride
dataV
stride
(
)
-
>
{
JniCommon
.
freeNativeByteBuffer
(
buffer
)
;
}
)
;
}
Deprecated
void
convert
(
ByteBuffer
buf
int
width
int
height
int
stride
int
srcTextureId
float
[
]
transformMatrix
)
{
convert
(
buf
width
height
stride
srcTextureId
transformMatrix
TextureBuffer
.
Type
.
OES
)
;
}
private
void
initShader
(
TextureBuffer
.
Type
textureType
)
{
if
(
shader
!
=
null
)
{
shader
.
release
(
)
;
}
final
String
fragmentShader
;
switch
(
textureType
)
{
case
OES
:
fragmentShader
=
OES_FRAGMENT_SHADER
;
break
;
case
RGB
:
fragmentShader
=
RGB_FRAGMENT_SHADER
;
break
;
default
:
throw
new
IllegalArgumentException
(
"
Unsupported
texture
type
.
"
)
;
}
shaderTextureType
=
textureType
;
shader
=
new
GlShader
(
VERTEX_SHADER
fragmentShader
)
;
shader
.
useProgram
(
)
;
texMatrixLoc
=
shader
.
getUniformLocation
(
"
texMatrix
"
)
;
xUnitLoc
=
shader
.
getUniformLocation
(
"
xUnit
"
)
;
coeffsLoc
=
shader
.
getUniformLocation
(
"
coeffs
"
)
;
GLES20
.
glUniform1i
(
shader
.
getUniformLocation
(
"
tex
"
)
0
)
;
GlUtil
.
checkNoGLES2Error
(
"
Initialize
fragment
shader
uniform
values
.
"
)
;
shader
.
setVertexAttribArray
(
"
in_pos
"
2
DEVICE_RECTANGLE
)
;
shader
.
setVertexAttribArray
(
"
in_tc
"
2
TEXTURE_RECTANGLE
)
;
}
private
void
convert
(
ByteBuffer
buf
int
width
int
height
int
stride
int
srcTextureId
float
[
]
transformMatrix
TextureBuffer
.
Type
textureType
)
{
threadChecker
.
checkIsOnValidThread
(
)
;
if
(
released
)
{
throw
new
IllegalStateException
(
"
YuvConverter
.
convert
called
on
released
object
"
)
;
}
if
(
textureType
!
=
shaderTextureType
)
{
initShader
(
textureType
)
;
}
shader
.
useProgram
(
)
;
if
(
stride
%
8
!
=
0
)
{
throw
new
IllegalArgumentException
(
"
Invalid
stride
must
be
a
multiple
of
8
"
)
;
}
if
(
stride
<
width
)
{
throw
new
IllegalArgumentException
(
"
Invalid
stride
must
>
=
width
"
)
;
}
int
y_width
=
(
width
+
3
)
/
4
;
int
uv_width
=
(
width
+
7
)
/
8
;
int
uv_height
=
(
height
+
1
)
/
2
;
int
total_height
=
height
+
uv_height
;
int
size
=
stride
*
total_height
;
if
(
buf
.
capacity
(
)
<
size
)
{
throw
new
IllegalArgumentException
(
"
YuvConverter
.
convert
called
with
too
small
buffer
"
)
;
}
transformMatrix
=
RendererCommon
.
multiplyMatrices
(
transformMatrix
RendererCommon
.
verticalFlipMatrix
(
)
)
;
final
int
frameBufferWidth
=
stride
/
4
;
final
int
frameBufferHeight
=
total_height
;
textureFrameBuffer
.
setSize
(
frameBufferWidth
frameBufferHeight
)
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
textureFrameBuffer
.
getFrameBufferId
(
)
)
;
GlUtil
.
checkNoGLES2Error
(
"
glBindFramebuffer
"
)
;
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
)
;
GLES20
.
glBindTexture
(
textureType
.
getGlTarget
(
)
srcTextureId
)
;
GLES20
.
glUniformMatrix4fv
(
texMatrixLoc
1
false
transformMatrix
0
)
;
GLES20
.
glViewport
(
0
0
y_width
height
)
;
GLES20
.
glUniform2f
(
xUnitLoc
transformMatrix
[
0
]
/
width
transformMatrix
[
1
]
/
width
)
;
GLES20
.
glUniform4f
(
coeffsLoc
0
.
299f
0
.
587f
0
.
114f
0
.
0f
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
GLES20
.
glViewport
(
0
height
uv_width
uv_height
)
;
GLES20
.
glUniform2f
(
xUnitLoc
2
.
0f
*
transformMatrix
[
0
]
/
width
2
.
0f
*
transformMatrix
[
1
]
/
width
)
;
GLES20
.
glUniform4f
(
coeffsLoc
-
0
.
169f
-
0
.
331f
0
.
499f
0
.
5f
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
GLES20
.
glViewport
(
stride
/
8
height
uv_width
uv_height
)
;
GLES20
.
glUniform4f
(
coeffsLoc
0
.
499f
-
0
.
418f
-
0
.
0813f
0
.
5f
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
GLES20
.
glReadPixels
(
0
0
frameBufferWidth
frameBufferHeight
GLES20
.
GL_RGBA
GLES20
.
GL_UNSIGNED_BYTE
buf
)
;
GlUtil
.
checkNoGLES2Error
(
"
YuvConverter
.
convert
"
)
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
0
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
0
)
;
GLES20
.
glBindTexture
(
textureType
.
getGlTarget
(
)
0
)
;
}
public
void
release
(
)
{
threadChecker
.
checkIsOnValidThread
(
)
;
released
=
true
;
if
(
shader
!
=
null
)
{
shader
.
release
(
)
;
}
textureFrameBuffer
.
release
(
)
;
}
}
