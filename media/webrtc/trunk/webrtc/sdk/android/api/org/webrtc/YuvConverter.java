package
org
.
webrtc
;
import
android
.
opengl
.
GLES11Ext
;
import
android
.
opengl
.
GLES20
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
FloatBuffer
;
class
YuvConverter
{
private
static
final
FloatBuffer
DEVICE_RECTANGLE
=
GlUtil
.
createFloatBuffer
(
new
float
[
]
{
-
1
.
0f
-
1
.
0f
1
.
0f
-
1
.
0f
-
1
.
0f
1
.
0f
1
.
0f
1
.
0f
}
)
;
private
static
final
FloatBuffer
TEXTURE_RECTANGLE
=
GlUtil
.
createFloatBuffer
(
new
float
[
]
{
0
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
1
.
0f
1
.
0f
1
.
0f
}
)
;
private
static
final
String
VERTEX_SHADER
=
"
varying
vec2
interp_tc
;
\
n
"
+
"
attribute
vec4
in_pos
;
\
n
"
+
"
attribute
vec4
in_tc
;
\
n
"
+
"
\
n
"
+
"
uniform
mat4
texMatrix
;
\
n
"
+
"
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
gl_Position
=
in_pos
;
\
n
"
+
"
interp_tc
=
(
texMatrix
*
in_tc
)
.
xy
;
\
n
"
+
"
}
\
n
"
;
private
static
final
String
FRAGMENT_SHADER
=
"
#
extension
GL_OES_EGL_image_external
:
require
\
n
"
+
"
precision
mediump
float
;
\
n
"
+
"
varying
vec2
interp_tc
;
\
n
"
+
"
\
n
"
+
"
uniform
samplerExternalOES
oesTex
;
\
n
"
+
"
uniform
vec2
xUnit
;
\
n
"
+
"
uniform
vec4
coeffs
;
\
n
"
+
"
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
gl_FragColor
.
r
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
oesTex
interp_tc
-
1
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
gl_FragColor
.
g
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
oesTex
interp_tc
-
0
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
gl_FragColor
.
b
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
oesTex
interp_tc
+
0
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
gl_FragColor
.
a
=
coeffs
.
a
+
dot
(
coeffs
.
rgb
\
n
"
+
"
texture2D
(
oesTex
interp_tc
+
1
.
5
*
xUnit
)
.
rgb
)
;
\
n
"
+
"
}
\
n
"
;
private
final
int
frameBufferId
;
private
final
int
frameTextureId
;
private
final
GlShader
shader
;
private
final
int
texMatrixLoc
;
private
final
int
xUnitLoc
;
private
final
int
coeffsLoc
;
private
final
ThreadUtils
.
ThreadChecker
threadChecker
=
new
ThreadUtils
.
ThreadChecker
(
)
;
private
int
frameBufferWidth
;
private
int
frameBufferHeight
;
private
boolean
released
=
false
;
public
YuvConverter
(
)
{
threadChecker
.
checkIsOnValidThread
(
)
;
frameTextureId
=
GlUtil
.
generateTexture
(
GLES20
.
GL_TEXTURE_2D
)
;
this
.
frameBufferWidth
=
0
;
this
.
frameBufferHeight
=
0
;
final
int
frameBuffers
[
]
=
new
int
[
1
]
;
GLES20
.
glGenFramebuffers
(
1
frameBuffers
0
)
;
frameBufferId
=
frameBuffers
[
0
]
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
frameBufferId
)
;
GlUtil
.
checkNoGLES2Error
(
"
Generate
framebuffer
"
)
;
GLES20
.
glFramebufferTexture2D
(
GLES20
.
GL_FRAMEBUFFER
GLES20
.
GL_COLOR_ATTACHMENT0
GLES20
.
GL_TEXTURE_2D
frameTextureId
0
)
;
GlUtil
.
checkNoGLES2Error
(
"
Attach
texture
to
framebuffer
"
)
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
0
)
;
shader
=
new
GlShader
(
VERTEX_SHADER
FRAGMENT_SHADER
)
;
shader
.
useProgram
(
)
;
texMatrixLoc
=
shader
.
getUniformLocation
(
"
texMatrix
"
)
;
xUnitLoc
=
shader
.
getUniformLocation
(
"
xUnit
"
)
;
coeffsLoc
=
shader
.
getUniformLocation
(
"
coeffs
"
)
;
GLES20
.
glUniform1i
(
shader
.
getUniformLocation
(
"
oesTex
"
)
0
)
;
GlUtil
.
checkNoGLES2Error
(
"
Initialize
fragment
shader
uniform
values
.
"
)
;
shader
.
setVertexAttribArray
(
"
in_pos
"
2
DEVICE_RECTANGLE
)
;
shader
.
setVertexAttribArray
(
"
in_tc
"
2
TEXTURE_RECTANGLE
)
;
}
public
void
convert
(
ByteBuffer
buf
int
width
int
height
int
stride
int
srcTextureId
float
[
]
transformMatrix
)
{
threadChecker
.
checkIsOnValidThread
(
)
;
if
(
released
)
{
throw
new
IllegalStateException
(
"
YuvConverter
.
convert
called
on
released
object
"
)
;
}
if
(
stride
%
8
!
=
0
)
{
throw
new
IllegalArgumentException
(
"
Invalid
stride
must
be
a
multiple
of
8
"
)
;
}
if
(
stride
<
width
)
{
throw
new
IllegalArgumentException
(
"
Invalid
stride
must
>
=
width
"
)
;
}
int
y_width
=
(
width
+
3
)
/
4
;
int
uv_width
=
(
width
+
7
)
/
8
;
int
uv_height
=
(
height
+
1
)
/
2
;
int
total_height
=
height
+
uv_height
;
int
size
=
stride
*
total_height
;
if
(
buf
.
capacity
(
)
<
size
)
{
throw
new
IllegalArgumentException
(
"
YuvConverter
.
convert
called
with
too
small
buffer
"
)
;
}
transformMatrix
=
RendererCommon
.
multiplyMatrices
(
transformMatrix
RendererCommon
.
verticalFlipMatrix
(
)
)
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
frameBufferId
)
;
GlUtil
.
checkNoGLES2Error
(
"
glBindFramebuffer
"
)
;
if
(
frameBufferWidth
!
=
stride
/
4
|
|
frameBufferHeight
!
=
total_height
)
{
frameBufferWidth
=
stride
/
4
;
frameBufferHeight
=
total_height
;
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
frameTextureId
)
;
GLES20
.
glTexImage2D
(
GLES20
.
GL_TEXTURE_2D
0
GLES20
.
GL_RGBA
frameBufferWidth
frameBufferHeight
0
GLES20
.
GL_RGBA
GLES20
.
GL_UNSIGNED_BYTE
null
)
;
final
int
status
=
GLES20
.
glCheckFramebufferStatus
(
GLES20
.
GL_FRAMEBUFFER
)
;
if
(
status
!
=
GLES20
.
GL_FRAMEBUFFER_COMPLETE
)
{
throw
new
IllegalStateException
(
"
Framebuffer
not
complete
status
:
"
+
status
)
;
}
}
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
)
;
GLES20
.
glBindTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
srcTextureId
)
;
GLES20
.
glUniformMatrix4fv
(
texMatrixLoc
1
false
transformMatrix
0
)
;
GLES20
.
glViewport
(
0
0
y_width
height
)
;
GLES20
.
glUniform2f
(
xUnitLoc
transformMatrix
[
0
]
/
width
transformMatrix
[
1
]
/
width
)
;
GLES20
.
glUniform4f
(
coeffsLoc
0
.
299f
0
.
587f
0
.
114f
0
.
0f
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
GLES20
.
glViewport
(
0
height
uv_width
uv_height
)
;
GLES20
.
glUniform2f
(
xUnitLoc
2
.
0f
*
transformMatrix
[
0
]
/
width
2
.
0f
*
transformMatrix
[
1
]
/
width
)
;
GLES20
.
glUniform4f
(
coeffsLoc
-
0
.
169f
-
0
.
331f
0
.
499f
0
.
5f
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
GLES20
.
glViewport
(
stride
/
8
height
uv_width
uv_height
)
;
GLES20
.
glUniform4f
(
coeffsLoc
0
.
499f
-
0
.
418f
-
0
.
0813f
0
.
5f
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
GLES20
.
glReadPixels
(
0
0
frameBufferWidth
frameBufferHeight
GLES20
.
GL_RGBA
GLES20
.
GL_UNSIGNED_BYTE
buf
)
;
GlUtil
.
checkNoGLES2Error
(
"
YuvConverter
.
convert
"
)
;
GLES20
.
glBindFramebuffer
(
GLES20
.
GL_FRAMEBUFFER
0
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
0
)
;
GLES20
.
glBindTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
0
)
;
}
public
void
release
(
)
{
threadChecker
.
checkIsOnValidThread
(
)
;
released
=
true
;
shader
.
release
(
)
;
GLES20
.
glDeleteTextures
(
1
new
int
[
]
{
frameTextureId
}
0
)
;
GLES20
.
glDeleteFramebuffers
(
1
new
int
[
]
{
frameBufferId
}
0
)
;
frameBufferWidth
=
0
;
frameBufferHeight
=
0
;
}
}
