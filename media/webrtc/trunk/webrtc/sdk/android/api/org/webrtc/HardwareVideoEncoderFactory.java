package
org
.
webrtc
;
import
static
org
.
webrtc
.
MediaCodecUtils
.
EXYNOS_PREFIX
;
import
static
org
.
webrtc
.
MediaCodecUtils
.
INTEL_PREFIX
;
import
static
org
.
webrtc
.
MediaCodecUtils
.
QCOM_PREFIX
;
import
android
.
media
.
MediaCodecInfo
;
import
android
.
media
.
MediaCodecList
;
import
android
.
os
.
Build
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
SuppressWarnings
(
"
deprecation
"
)
public
class
HardwareVideoEncoderFactory
implements
VideoEncoderFactory
{
private
static
final
String
TAG
=
"
HardwareVideoEncoderFactory
"
;
private
static
final
int
QCOM_VP8_KEY_FRAME_INTERVAL_ANDROID_L_MS
=
15000
;
private
static
final
int
QCOM_VP8_KEY_FRAME_INTERVAL_ANDROID_M_MS
=
20000
;
private
static
final
int
QCOM_VP8_KEY_FRAME_INTERVAL_ANDROID_N_MS
=
15000
;
private
static
final
List
<
String
>
H264_HW_EXCEPTION_MODELS
=
Arrays
.
asList
(
"
SAMSUNG
-
SGH
-
I337
"
"
Nexus
7
"
"
Nexus
4
"
)
;
private
final
EglBase14
.
Context
sharedContext
;
private
final
boolean
enableIntelVp8Encoder
;
private
final
boolean
enableH264HighProfile
;
private
final
boolean
fallbackToSoftware
;
public
HardwareVideoEncoderFactory
(
EglBase
.
Context
sharedContext
boolean
enableIntelVp8Encoder
boolean
enableH264HighProfile
)
{
this
(
sharedContext
enableIntelVp8Encoder
enableH264HighProfile
true
)
;
}
HardwareVideoEncoderFactory
(
EglBase
.
Context
sharedContext
boolean
enableIntelVp8Encoder
boolean
enableH264HighProfile
boolean
fallbackToSoftware
)
{
if
(
sharedContext
instanceof
EglBase14
.
Context
)
{
this
.
sharedContext
=
(
EglBase14
.
Context
)
sharedContext
;
}
else
{
Logging
.
w
(
TAG
"
No
shared
EglBase
.
Context
.
Encoders
will
not
use
texture
mode
.
"
)
;
this
.
sharedContext
=
null
;
}
this
.
enableIntelVp8Encoder
=
enableIntelVp8Encoder
;
this
.
enableH264HighProfile
=
enableH264HighProfile
;
this
.
fallbackToSoftware
=
fallbackToSoftware
;
}
Deprecated
public
HardwareVideoEncoderFactory
(
boolean
enableIntelVp8Encoder
boolean
enableH264HighProfile
)
{
this
(
null
enableIntelVp8Encoder
enableH264HighProfile
)
;
}
Override
public
VideoEncoder
createEncoder
(
VideoCodecInfo
input
)
{
VideoCodecType
type
=
VideoCodecType
.
valueOf
(
input
.
name
)
;
MediaCodecInfo
info
=
findCodecForType
(
type
)
;
if
(
info
=
=
null
)
{
if
(
fallbackToSoftware
)
{
SoftwareVideoEncoderFactory
softwareVideoEncoderFactory
=
new
SoftwareVideoEncoderFactory
(
)
;
return
softwareVideoEncoderFactory
.
createEncoder
(
input
)
;
}
else
{
return
null
;
}
}
String
codecName
=
info
.
getName
(
)
;
String
mime
=
type
.
mimeType
(
)
;
Integer
surfaceColorFormat
=
MediaCodecUtils
.
selectColorFormat
(
MediaCodecUtils
.
TEXTURE_COLOR_FORMATS
info
.
getCapabilitiesForType
(
mime
)
)
;
Integer
yuvColorFormat
=
MediaCodecUtils
.
selectColorFormat
(
MediaCodecUtils
.
ENCODER_COLOR_FORMATS
info
.
getCapabilitiesForType
(
mime
)
)
;
if
(
type
=
=
VideoCodecType
.
H264
)
{
boolean
isHighProfile
=
isSameH264Profile
(
input
.
params
getCodecProperties
(
type
true
)
)
&
&
isH264HighProfileSupported
(
info
)
;
boolean
isBaselineProfile
=
isSameH264Profile
(
input
.
params
getCodecProperties
(
type
false
)
)
;
if
(
!
isHighProfile
&
&
!
isBaselineProfile
)
{
return
null
;
}
}
return
new
HardwareVideoEncoder
(
codecName
type
surfaceColorFormat
yuvColorFormat
input
.
params
getKeyFrameIntervalSec
(
type
)
getForcedKeyFrameIntervalMs
(
type
codecName
)
createBitrateAdjuster
(
type
codecName
)
sharedContext
)
;
}
Override
public
VideoCodecInfo
[
]
getSupportedCodecs
(
)
{
List
<
VideoCodecInfo
>
supportedCodecInfos
=
new
ArrayList
<
VideoCodecInfo
>
(
)
;
for
(
VideoCodecType
type
:
new
VideoCodecType
[
]
{
VideoCodecType
.
VP8
VideoCodecType
.
VP9
VideoCodecType
.
H264
}
)
{
MediaCodecInfo
codec
=
findCodecForType
(
type
)
;
if
(
codec
!
=
null
)
{
String
name
=
type
.
name
(
)
;
if
(
type
=
=
VideoCodecType
.
H264
&
&
isH264HighProfileSupported
(
codec
)
)
{
supportedCodecInfos
.
add
(
new
VideoCodecInfo
(
name
getCodecProperties
(
type
true
)
)
)
;
}
supportedCodecInfos
.
add
(
new
VideoCodecInfo
(
name
getCodecProperties
(
type
false
)
)
)
;
}
}
if
(
fallbackToSoftware
)
{
for
(
VideoCodecInfo
info
:
SoftwareVideoEncoderFactory
.
supportedCodecs
(
)
)
{
if
(
!
supportedCodecInfos
.
contains
(
info
)
)
{
supportedCodecInfos
.
add
(
info
)
;
}
}
}
return
supportedCodecInfos
.
toArray
(
new
VideoCodecInfo
[
supportedCodecInfos
.
size
(
)
]
)
;
}
private
MediaCodecInfo
findCodecForType
(
VideoCodecType
type
)
{
for
(
int
i
=
0
;
i
<
MediaCodecList
.
getCodecCount
(
)
;
+
+
i
)
{
MediaCodecInfo
info
=
null
;
try
{
info
=
MediaCodecList
.
getCodecInfoAt
(
i
)
;
}
catch
(
IllegalArgumentException
e
)
{
Logging
.
e
(
TAG
"
Cannot
retrieve
encoder
codec
info
"
e
)
;
}
if
(
info
=
=
null
|
|
!
info
.
isEncoder
(
)
)
{
continue
;
}
if
(
isSupportedCodec
(
info
type
)
)
{
return
info
;
}
}
return
null
;
}
private
boolean
isSupportedCodec
(
MediaCodecInfo
info
VideoCodecType
type
)
{
if
(
!
MediaCodecUtils
.
codecSupportsType
(
info
type
)
)
{
return
false
;
}
if
(
MediaCodecUtils
.
selectColorFormat
(
MediaCodecUtils
.
ENCODER_COLOR_FORMATS
info
.
getCapabilitiesForType
(
type
.
mimeType
(
)
)
)
=
=
null
)
{
return
false
;
}
return
isHardwareSupportedInCurrentSdk
(
info
type
)
;
}
private
boolean
isHardwareSupportedInCurrentSdk
(
MediaCodecInfo
info
VideoCodecType
type
)
{
switch
(
type
)
{
case
VP8
:
return
isHardwareSupportedInCurrentSdkVp8
(
info
)
;
case
VP9
:
return
isHardwareSupportedInCurrentSdkVp9
(
info
)
;
case
H264
:
return
isHardwareSupportedInCurrentSdkH264
(
info
)
;
}
return
false
;
}
private
boolean
isHardwareSupportedInCurrentSdkVp8
(
MediaCodecInfo
info
)
{
String
name
=
info
.
getName
(
)
;
return
(
name
.
startsWith
(
QCOM_PREFIX
)
&
&
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
KITKAT
)
|
|
(
name
.
startsWith
(
EXYNOS_PREFIX
)
&
&
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
M
)
|
|
(
name
.
startsWith
(
INTEL_PREFIX
)
&
&
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
LOLLIPOP
&
&
enableIntelVp8Encoder
)
;
}
private
boolean
isHardwareSupportedInCurrentSdkVp9
(
MediaCodecInfo
info
)
{
String
name
=
info
.
getName
(
)
;
return
(
name
.
startsWith
(
QCOM_PREFIX
)
|
|
name
.
startsWith
(
EXYNOS_PREFIX
)
)
&
&
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
N
;
}
private
boolean
isHardwareSupportedInCurrentSdkH264
(
MediaCodecInfo
info
)
{
if
(
H264_HW_EXCEPTION_MODELS
.
contains
(
Build
.
MODEL
)
)
{
return
false
;
}
String
name
=
info
.
getName
(
)
;
return
(
name
.
startsWith
(
QCOM_PREFIX
)
&
&
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
KITKAT
)
|
|
(
name
.
startsWith
(
EXYNOS_PREFIX
)
&
&
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
LOLLIPOP
)
;
}
private
int
getKeyFrameIntervalSec
(
VideoCodecType
type
)
{
switch
(
type
)
{
case
VP8
:
case
VP9
:
return
100
;
case
H264
:
return
20
;
}
throw
new
IllegalArgumentException
(
"
Unsupported
VideoCodecType
"
+
type
)
;
}
private
int
getForcedKeyFrameIntervalMs
(
VideoCodecType
type
String
codecName
)
{
if
(
type
=
=
VideoCodecType
.
VP8
&
&
codecName
.
startsWith
(
QCOM_PREFIX
)
)
{
if
(
Build
.
VERSION
.
SDK_INT
=
=
Build
.
VERSION_CODES
.
LOLLIPOP
|
|
Build
.
VERSION
.
SDK_INT
=
=
Build
.
VERSION_CODES
.
LOLLIPOP_MR1
)
{
return
QCOM_VP8_KEY_FRAME_INTERVAL_ANDROID_L_MS
;
}
else
if
(
Build
.
VERSION
.
SDK_INT
=
=
Build
.
VERSION_CODES
.
M
)
{
return
QCOM_VP8_KEY_FRAME_INTERVAL_ANDROID_M_MS
;
}
else
if
(
Build
.
VERSION
.
SDK_INT
>
Build
.
VERSION_CODES
.
M
)
{
return
QCOM_VP8_KEY_FRAME_INTERVAL_ANDROID_N_MS
;
}
}
return
0
;
}
private
BitrateAdjuster
createBitrateAdjuster
(
VideoCodecType
type
String
codecName
)
{
if
(
codecName
.
startsWith
(
EXYNOS_PREFIX
)
)
{
if
(
type
=
=
VideoCodecType
.
VP8
)
{
return
new
DynamicBitrateAdjuster
(
)
;
}
else
{
return
new
FramerateBitrateAdjuster
(
)
;
}
}
return
new
BaseBitrateAdjuster
(
)
;
}
private
boolean
isH264HighProfileSupported
(
MediaCodecInfo
info
)
{
return
enableH264HighProfile
&
&
info
.
getName
(
)
.
startsWith
(
QCOM_PREFIX
)
;
}
private
Map
<
String
String
>
getCodecProperties
(
VideoCodecType
type
boolean
highProfile
)
{
switch
(
type
)
{
case
VP8
:
case
VP9
:
return
new
HashMap
<
String
String
>
(
)
;
case
H264
:
Map
<
String
String
>
properties
=
new
HashMap
<
>
(
)
;
properties
.
put
(
VideoCodecInfo
.
H264_FMTP_LEVEL_ASYMMETRY_ALLOWED
"
1
"
)
;
properties
.
put
(
VideoCodecInfo
.
H264_FMTP_PACKETIZATION_MODE
"
1
"
)
;
properties
.
put
(
VideoCodecInfo
.
H264_FMTP_PROFILE_LEVEL_ID
highProfile
?
VideoCodecInfo
.
H264_CONSTRAINED_HIGH_3_1
:
VideoCodecInfo
.
H264_CONSTRAINED_BASELINE_3_1
)
;
return
properties
;
default
:
throw
new
IllegalArgumentException
(
"
Unsupported
codec
:
"
+
type
)
;
}
}
private
static
native
boolean
isSameH264Profile
(
Map
<
String
String
>
params1
Map
<
String
String
>
params2
)
;
}
