package
org
.
webrtc
;
import
android
.
graphics
.
SurfaceTexture
;
import
android
.
opengl
.
GLES11Ext
;
import
android
.
opengl
.
GLES20
;
import
android
.
os
.
Build
;
import
android
.
os
.
Handler
;
import
android
.
os
.
HandlerThread
;
import
android
.
os
.
SystemClock
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
FloatBuffer
;
import
java
.
util
.
concurrent
.
Callable
;
import
java
.
util
.
concurrent
.
TimeUnit
;
public
class
SurfaceTextureHelper
{
private
static
final
String
TAG
=
"
SurfaceTextureHelper
"
;
public
interface
OnTextureFrameAvailableListener
{
abstract
void
onTextureFrameAvailable
(
int
oesTextureId
float
[
]
transformMatrix
long
timestampNs
)
;
}
public
static
SurfaceTextureHelper
create
(
final
String
threadName
final
EglBase
.
Context
sharedContext
)
{
final
HandlerThread
thread
=
new
HandlerThread
(
threadName
)
;
thread
.
start
(
)
;
final
Handler
handler
=
new
Handler
(
thread
.
getLooper
(
)
)
;
return
ThreadUtils
.
invokeAtFrontUninterruptibly
(
handler
new
Callable
<
SurfaceTextureHelper
>
(
)
{
Override
public
SurfaceTextureHelper
call
(
)
{
try
{
return
new
SurfaceTextureHelper
(
sharedContext
handler
)
;
}
catch
(
RuntimeException
e
)
{
Logging
.
e
(
TAG
threadName
+
"
create
failure
"
e
)
;
return
null
;
}
}
}
)
;
}
private
final
Handler
handler
;
private
final
EglBase
eglBase
;
private
final
SurfaceTexture
surfaceTexture
;
private
final
int
oesTextureId
;
private
YuvConverter
yuvConverter
;
private
OnTextureFrameAvailableListener
listener
;
private
boolean
hasPendingTexture
=
false
;
private
volatile
boolean
isTextureInUse
=
false
;
private
boolean
isQuitting
=
false
;
private
OnTextureFrameAvailableListener
pendingListener
;
final
Runnable
setListenerRunnable
=
new
Runnable
(
)
{
Override
public
void
run
(
)
{
Logging
.
d
(
TAG
"
Setting
listener
to
"
+
pendingListener
)
;
listener
=
pendingListener
;
pendingListener
=
null
;
if
(
hasPendingTexture
)
{
updateTexImage
(
)
;
hasPendingTexture
=
false
;
}
}
}
;
private
SurfaceTextureHelper
(
EglBase
.
Context
sharedContext
Handler
handler
)
{
if
(
handler
.
getLooper
(
)
.
getThread
(
)
!
=
Thread
.
currentThread
(
)
)
{
throw
new
IllegalStateException
(
"
SurfaceTextureHelper
must
be
created
on
the
handler
thread
"
)
;
}
this
.
handler
=
handler
;
eglBase
=
EglBase
.
create
(
sharedContext
EglBase
.
CONFIG_PIXEL_BUFFER
)
;
try
{
eglBase
.
createDummyPbufferSurface
(
)
;
eglBase
.
makeCurrent
(
)
;
}
catch
(
RuntimeException
e
)
{
eglBase
.
release
(
)
;
handler
.
getLooper
(
)
.
quit
(
)
;
throw
e
;
}
oesTextureId
=
GlUtil
.
generateTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
)
;
surfaceTexture
=
new
SurfaceTexture
(
oesTextureId
)
;
surfaceTexture
.
setOnFrameAvailableListener
(
new
SurfaceTexture
.
OnFrameAvailableListener
(
)
{
Override
public
void
onFrameAvailable
(
SurfaceTexture
surfaceTexture
)
{
hasPendingTexture
=
true
;
tryDeliverTextureFrame
(
)
;
}
}
)
;
}
public
void
startListening
(
final
OnTextureFrameAvailableListener
listener
)
{
if
(
this
.
listener
!
=
null
|
|
this
.
pendingListener
!
=
null
)
{
throw
new
IllegalStateException
(
"
SurfaceTextureHelper
listener
has
already
been
set
.
"
)
;
}
this
.
pendingListener
=
listener
;
handler
.
post
(
setListenerRunnable
)
;
}
public
void
stopListening
(
)
{
Logging
.
d
(
TAG
"
stopListening
(
)
"
)
;
handler
.
removeCallbacks
(
setListenerRunnable
)
;
ThreadUtils
.
invokeAtFrontUninterruptibly
(
handler
new
Runnable
(
)
{
Override
public
void
run
(
)
{
listener
=
null
;
pendingListener
=
null
;
}
}
)
;
}
public
SurfaceTexture
getSurfaceTexture
(
)
{
return
surfaceTexture
;
}
public
Handler
getHandler
(
)
{
return
handler
;
}
public
void
returnTextureFrame
(
)
{
handler
.
post
(
new
Runnable
(
)
{
Override
public
void
run
(
)
{
isTextureInUse
=
false
;
if
(
isQuitting
)
{
release
(
)
;
}
else
{
tryDeliverTextureFrame
(
)
;
}
}
}
)
;
}
public
boolean
isTextureInUse
(
)
{
return
isTextureInUse
;
}
public
void
dispose
(
)
{
Logging
.
d
(
TAG
"
dispose
(
)
"
)
;
ThreadUtils
.
invokeAtFrontUninterruptibly
(
handler
new
Runnable
(
)
{
Override
public
void
run
(
)
{
isQuitting
=
true
;
if
(
!
isTextureInUse
)
{
release
(
)
;
}
}
}
)
;
}
public
void
textureToYUV
(
final
ByteBuffer
buf
final
int
width
final
int
height
final
int
stride
final
int
textureId
final
float
[
]
transformMatrix
)
{
if
(
textureId
!
=
oesTextureId
)
{
throw
new
IllegalStateException
(
"
textureToByteBuffer
called
with
unexpected
textureId
"
)
;
}
ThreadUtils
.
invokeAtFrontUninterruptibly
(
handler
new
Runnable
(
)
{
Override
public
void
run
(
)
{
if
(
yuvConverter
=
=
null
)
{
yuvConverter
=
new
YuvConverter
(
)
;
}
yuvConverter
.
convert
(
buf
width
height
stride
textureId
transformMatrix
)
;
}
}
)
;
}
private
void
updateTexImage
(
)
{
synchronized
(
EglBase
.
lock
)
{
surfaceTexture
.
updateTexImage
(
)
;
}
}
private
void
tryDeliverTextureFrame
(
)
{
if
(
handler
.
getLooper
(
)
.
getThread
(
)
!
=
Thread
.
currentThread
(
)
)
{
throw
new
IllegalStateException
(
"
Wrong
thread
.
"
)
;
}
if
(
isQuitting
|
|
!
hasPendingTexture
|
|
isTextureInUse
|
|
listener
=
=
null
)
{
return
;
}
isTextureInUse
=
true
;
hasPendingTexture
=
false
;
updateTexImage
(
)
;
final
float
[
]
transformMatrix
=
new
float
[
16
]
;
surfaceTexture
.
getTransformMatrix
(
transformMatrix
)
;
final
long
timestampNs
=
(
Build
.
VERSION
.
SDK_INT
>
=
Build
.
VERSION_CODES
.
ICE_CREAM_SANDWICH
)
?
surfaceTexture
.
getTimestamp
(
)
:
TimeUnit
.
MILLISECONDS
.
toNanos
(
SystemClock
.
elapsedRealtime
(
)
)
;
listener
.
onTextureFrameAvailable
(
oesTextureId
transformMatrix
timestampNs
)
;
}
private
void
release
(
)
{
if
(
handler
.
getLooper
(
)
.
getThread
(
)
!
=
Thread
.
currentThread
(
)
)
{
throw
new
IllegalStateException
(
"
Wrong
thread
.
"
)
;
}
if
(
isTextureInUse
|
|
!
isQuitting
)
{
throw
new
IllegalStateException
(
"
Unexpected
release
.
"
)
;
}
if
(
yuvConverter
!
=
null
)
{
yuvConverter
.
release
(
)
;
}
GLES20
.
glDeleteTextures
(
1
new
int
[
]
{
oesTextureId
}
0
)
;
surfaceTexture
.
release
(
)
;
eglBase
.
release
(
)
;
handler
.
getLooper
(
)
.
quit
(
)
;
}
}
