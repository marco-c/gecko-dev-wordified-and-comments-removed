package
org
.
webrtc
;
import
android
.
opengl
.
GLES11Ext
;
import
android
.
opengl
.
GLES20
;
import
java
.
nio
.
FloatBuffer
;
import
java
.
util
.
IdentityHashMap
;
import
java
.
util
.
Map
;
public
class
GlRectDrawer
implements
RendererCommon
.
GlDrawer
{
private
static
final
String
VERTEX_SHADER_STRING
=
"
varying
vec2
interp_tc
;
\
n
"
+
"
attribute
vec4
in_pos
;
\
n
"
+
"
attribute
vec4
in_tc
;
\
n
"
+
"
\
n
"
+
"
uniform
mat4
texMatrix
;
\
n
"
+
"
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
gl_Position
=
in_pos
;
\
n
"
+
"
interp_tc
=
(
texMatrix
*
in_tc
)
.
xy
;
\
n
"
+
"
}
\
n
"
;
private
static
final
String
YUV_FRAGMENT_SHADER_STRING
=
"
precision
mediump
float
;
\
n
"
+
"
varying
vec2
interp_tc
;
\
n
"
+
"
\
n
"
+
"
uniform
sampler2D
y_tex
;
\
n
"
+
"
uniform
sampler2D
u_tex
;
\
n
"
+
"
uniform
sampler2D
v_tex
;
\
n
"
+
"
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
float
y
=
texture2D
(
y_tex
interp_tc
)
.
r
;
\
n
"
+
"
float
u
=
texture2D
(
u_tex
interp_tc
)
.
r
-
0
.
5
;
\
n
"
+
"
float
v
=
texture2D
(
v_tex
interp_tc
)
.
r
-
0
.
5
;
\
n
"
+
"
gl_FragColor
=
vec4
(
y
+
1
.
403
*
v
"
+
"
y
-
0
.
344
*
u
-
0
.
714
*
v
"
+
"
y
+
1
.
77
*
u
1
)
;
\
n
"
+
"
}
\
n
"
;
private
static
final
String
RGB_FRAGMENT_SHADER_STRING
=
"
precision
mediump
float
;
\
n
"
+
"
varying
vec2
interp_tc
;
\
n
"
+
"
\
n
"
+
"
uniform
sampler2D
rgb_tex
;
\
n
"
+
"
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
gl_FragColor
=
texture2D
(
rgb_tex
interp_tc
)
;
\
n
"
+
"
}
\
n
"
;
private
static
final
String
OES_FRAGMENT_SHADER_STRING
=
"
#
extension
GL_OES_EGL_image_external
:
require
\
n
"
+
"
precision
mediump
float
;
\
n
"
+
"
varying
vec2
interp_tc
;
\
n
"
+
"
\
n
"
+
"
uniform
samplerExternalOES
oes_tex
;
\
n
"
+
"
\
n
"
+
"
void
main
(
)
{
\
n
"
+
"
gl_FragColor
=
texture2D
(
oes_tex
interp_tc
)
;
\
n
"
+
"
}
\
n
"
;
private
static
final
FloatBuffer
FULL_RECTANGLE_BUF
=
GlUtil
.
createFloatBuffer
(
new
float
[
]
{
-
1
.
0f
-
1
.
0f
1
.
0f
-
1
.
0f
-
1
.
0f
1
.
0f
1
.
0f
1
.
0f
}
)
;
private
static
final
FloatBuffer
FULL_RECTANGLE_TEX_BUF
=
GlUtil
.
createFloatBuffer
(
new
float
[
]
{
0
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
1
.
0f
1
.
0f
1
.
0f
}
)
;
private
static
class
Shader
{
public
final
GlShader
glShader
;
public
final
int
texMatrixLocation
;
public
Shader
(
String
fragmentShader
)
{
this
.
glShader
=
new
GlShader
(
VERTEX_SHADER_STRING
fragmentShader
)
;
this
.
texMatrixLocation
=
glShader
.
getUniformLocation
(
"
texMatrix
"
)
;
}
}
private
final
Map
<
String
Shader
>
shaders
=
new
IdentityHashMap
<
String
Shader
>
(
)
;
Override
public
void
drawOes
(
int
oesTextureId
float
[
]
texMatrix
int
frameWidth
int
frameHeight
int
viewportX
int
viewportY
int
viewportWidth
int
viewportHeight
)
{
prepareShader
(
OES_FRAGMENT_SHADER_STRING
texMatrix
)
;
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
)
;
GLES20
.
glBindTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
oesTextureId
)
;
drawRectangle
(
viewportX
viewportY
viewportWidth
viewportHeight
)
;
GLES20
.
glBindTexture
(
GLES11Ext
.
GL_TEXTURE_EXTERNAL_OES
0
)
;
}
Override
public
void
drawRgb
(
int
textureId
float
[
]
texMatrix
int
frameWidth
int
frameHeight
int
viewportX
int
viewportY
int
viewportWidth
int
viewportHeight
)
{
prepareShader
(
RGB_FRAGMENT_SHADER_STRING
texMatrix
)
;
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
textureId
)
;
drawRectangle
(
viewportX
viewportY
viewportWidth
viewportHeight
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
0
)
;
}
Override
public
void
drawYuv
(
int
[
]
yuvTextures
float
[
]
texMatrix
int
frameWidth
int
frameHeight
int
viewportX
int
viewportY
int
viewportWidth
int
viewportHeight
)
{
prepareShader
(
YUV_FRAGMENT_SHADER_STRING
texMatrix
)
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
+
i
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
yuvTextures
[
i
]
)
;
}
drawRectangle
(
viewportX
viewportY
viewportWidth
viewportHeight
)
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
GLES20
.
glActiveTexture
(
GLES20
.
GL_TEXTURE0
+
i
)
;
GLES20
.
glBindTexture
(
GLES20
.
GL_TEXTURE_2D
0
)
;
}
}
private
void
drawRectangle
(
int
x
int
y
int
width
int
height
)
{
GLES20
.
glViewport
(
x
y
width
height
)
;
GLES20
.
glDrawArrays
(
GLES20
.
GL_TRIANGLE_STRIP
0
4
)
;
}
private
void
prepareShader
(
String
fragmentShader
float
[
]
texMatrix
)
{
final
Shader
shader
;
if
(
shaders
.
containsKey
(
fragmentShader
)
)
{
shader
=
shaders
.
get
(
fragmentShader
)
;
}
else
{
shader
=
new
Shader
(
fragmentShader
)
;
shaders
.
put
(
fragmentShader
shader
)
;
shader
.
glShader
.
useProgram
(
)
;
if
(
YUV_FRAGMENT_SHADER_STRING
.
equals
(
fragmentShader
)
)
{
GLES20
.
glUniform1i
(
shader
.
glShader
.
getUniformLocation
(
"
y_tex
"
)
0
)
;
GLES20
.
glUniform1i
(
shader
.
glShader
.
getUniformLocation
(
"
u_tex
"
)
1
)
;
GLES20
.
glUniform1i
(
shader
.
glShader
.
getUniformLocation
(
"
v_tex
"
)
2
)
;
}
else
if
(
RGB_FRAGMENT_SHADER_STRING
.
equals
(
fragmentShader
)
)
{
GLES20
.
glUniform1i
(
shader
.
glShader
.
getUniformLocation
(
"
rgb_tex
"
)
0
)
;
}
else
if
(
OES_FRAGMENT_SHADER_STRING
.
equals
(
fragmentShader
)
)
{
GLES20
.
glUniform1i
(
shader
.
glShader
.
getUniformLocation
(
"
oes_tex
"
)
0
)
;
}
else
{
throw
new
IllegalStateException
(
"
Unknown
fragment
shader
:
"
+
fragmentShader
)
;
}
GlUtil
.
checkNoGLES2Error
(
"
Initialize
fragment
shader
uniform
values
.
"
)
;
shader
.
glShader
.
setVertexAttribArray
(
"
in_pos
"
2
FULL_RECTANGLE_BUF
)
;
shader
.
glShader
.
setVertexAttribArray
(
"
in_tc
"
2
FULL_RECTANGLE_TEX_BUF
)
;
}
shader
.
glShader
.
useProgram
(
)
;
GLES20
.
glUniformMatrix4fv
(
shader
.
texMatrixLocation
1
false
texMatrix
0
)
;
}
Override
public
void
release
(
)
{
for
(
Shader
shader
:
shaders
.
values
(
)
)
{
shader
.
glShader
.
release
(
)
;
}
shaders
.
clear
(
)
;
}
}
