#
ifndef
WEBRTC_LOGGING_RTC_EVENT_LOG_RINGBUFFER_H_
#
define
WEBRTC_LOGGING_RTC_EVENT_LOG_RINGBUFFER_H_
#
include
<
memory
>
#
include
<
utility
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
base
/
constructormagic
.
h
"
namespace
webrtc
{
template
<
typename
T
>
class
RingBuffer
{
public
:
explicit
RingBuffer
(
size_t
capacity
)
:
data_
(
new
T
[
capacity
+
1
]
)
{
RTC_DCHECK
(
capacity
>
0
)
;
end_
=
data_
.
get
(
)
+
(
capacity
+
1
)
;
front_
=
data_
.
get
(
)
;
back_
=
data_
.
get
(
)
;
}
~
RingBuffer
(
)
{
}
void
pop_front
(
)
{
RTC_DCHECK
(
!
empty
(
)
)
;
+
+
front_
;
if
(
front_
=
=
end_
)
{
front_
=
data_
.
get
(
)
;
}
}
void
push_back
(
const
T
&
elem
)
{
*
back_
=
elem
;
+
+
back_
;
if
(
back_
=
=
end_
)
{
back_
=
data_
.
get
(
)
;
}
if
(
back_
=
=
front_
)
{
+
+
front_
;
}
if
(
front_
=
=
end_
)
{
front_
=
data_
.
get
(
)
;
}
}
void
push_back
(
T
&
&
elem
)
{
*
back_
=
std
:
:
move
(
elem
)
;
+
+
back_
;
if
(
back_
=
=
end_
)
{
back_
=
data_
.
get
(
)
;
}
if
(
back_
=
=
front_
)
{
+
+
front_
;
}
if
(
front_
=
=
end_
)
{
front_
=
data_
.
get
(
)
;
}
}
T
&
front
(
)
{
return
*
front_
;
}
const
T
&
front
(
)
const
{
return
*
front_
;
}
bool
empty
(
)
const
{
return
(
front_
=
=
back_
)
;
}
private
:
std
:
:
unique_ptr
<
T
[
]
>
data_
;
T
*
end_
;
T
*
front_
;
T
*
back_
;
RTC_DISALLOW_IMPLICIT_CONSTRUCTORS
(
RingBuffer
)
;
}
;
}
#
endif
