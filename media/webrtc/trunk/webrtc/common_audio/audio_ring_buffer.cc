#
include
"
webrtc
/
common_audio
/
audio_ring_buffer
.
h
"
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
common_audio
/
ring_buffer
.
h
"
namespace
webrtc
{
AudioRingBuffer
:
:
AudioRingBuffer
(
size_t
channels
size_t
max_frames
)
{
for
(
size_t
i
=
0
;
i
<
channels
;
+
+
i
)
buffers_
.
push_back
(
WebRtc_CreateBuffer
(
max_frames
sizeof
(
float
)
)
)
;
}
AudioRingBuffer
:
:
~
AudioRingBuffer
(
)
{
for
(
auto
buf
:
buffers_
)
WebRtc_FreeBuffer
(
buf
)
;
}
void
AudioRingBuffer
:
:
Write
(
const
float
*
const
*
data
size_t
channels
size_t
frames
)
{
DCHECK_EQ
(
buffers_
.
size
(
)
channels
)
;
for
(
size_t
i
=
0
;
i
<
channels
;
+
+
i
)
{
size_t
written
=
WebRtc_WriteBuffer
(
buffers_
[
i
]
data
[
i
]
frames
)
;
CHECK_EQ
(
written
frames
)
;
}
}
void
AudioRingBuffer
:
:
Read
(
float
*
const
*
data
size_t
channels
size_t
frames
)
{
DCHECK_EQ
(
buffers_
.
size
(
)
channels
)
;
for
(
size_t
i
=
0
;
i
<
channels
;
+
+
i
)
{
size_t
read
=
WebRtc_ReadBuffer
(
buffers_
[
i
]
nullptr
data
[
i
]
frames
)
;
CHECK_EQ
(
read
frames
)
;
}
}
size_t
AudioRingBuffer
:
:
ReadFramesAvailable
(
)
const
{
return
WebRtc_available_read
(
buffers_
[
0
]
)
;
}
size_t
AudioRingBuffer
:
:
WriteFramesAvailable
(
)
const
{
return
WebRtc_available_write
(
buffers_
[
0
]
)
;
}
void
AudioRingBuffer
:
:
MoveReadPosition
(
int
frames
)
{
for
(
auto
buf
:
buffers_
)
{
int
moved
=
WebRtc_MoveReadPtr
(
buf
frames
)
;
CHECK_EQ
(
moved
frames
)
;
}
}
}
