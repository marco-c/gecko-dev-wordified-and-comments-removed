#
if
defined
(
WEBRTC_WIN
)
#
include
"
webrtc
/
base
/
platform_thread
.
h
"
#
include
"
webrtc
/
base
/
timeutils
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
critical_section_wrapper
.
h
"
#
include
"
webrtc
/
system_wrappers
/
include
/
trace
.
h
"
#
include
"
webrtc
/
system_wrappers
/
source
/
condition_variable_event_win
.
h
"
#
include
"
webrtc
/
test
/
gtest
.
h
"
namespace
webrtc
{
namespace
{
const
int
kLongWaitMs
=
100
*
1000
;
const
int
kShortWaitMs
=
2
*
1000
;
const
int
kVeryShortWaitMs
=
20
;
class
Baton
{
public
:
Baton
(
)
:
being_passed_
(
false
)
pass_count_
(
0
)
{
InitializeCriticalSection
(
&
crit_sect_
)
;
}
~
Baton
(
)
{
DeleteCriticalSection
(
&
crit_sect_
)
;
}
bool
Pass
(
uint32_t
max_msecs
)
{
CriticalSectionScoped
cs_giver
(
&
giver_sect_
)
;
EnterCriticalSection
(
&
crit_sect_
)
;
SignalBatonAvailable
(
)
;
const
bool
result
=
TakeBatonIfStillFree
(
max_msecs
)
;
if
(
result
)
{
+
+
pass_count_
;
}
LeaveCriticalSection
(
&
crit_sect_
)
;
return
result
;
}
bool
Grab
(
uint32_t
max_msecs
)
{
EnterCriticalSection
(
&
crit_sect_
)
;
bool
ret
=
WaitUntilBatonOffered
(
max_msecs
)
;
LeaveCriticalSection
(
&
crit_sect_
)
;
return
ret
;
}
int
PassCount
(
)
{
CriticalSectionScoped
cs
(
&
giver_sect_
)
;
return
pass_count_
;
}
private
:
bool
WaitUntilBatonOffered
(
int
timeout_ms
)
{
while
(
!
being_passed_
)
{
if
(
!
cond_var_
.
SleepCS
(
&
crit_sect_
timeout_ms
)
)
{
return
false
;
}
}
being_passed_
=
false
;
cond_var_
.
Wake
(
)
;
return
true
;
}
void
SignalBatonAvailable
(
)
{
assert
(
!
being_passed_
)
;
being_passed_
=
true
;
cond_var_
.
Wake
(
)
;
}
bool
TakeBatonIfStillFree
(
int
timeout_ms
)
{
bool
not_timeout
=
true
;
while
(
being_passed_
&
&
not_timeout
)
{
not_timeout
=
cond_var_
.
SleepCS
(
&
crit_sect_
timeout_ms
)
;
}
if
(
!
being_passed_
)
return
true
;
assert
(
!
not_timeout
)
;
being_passed_
=
false
;
return
false
;
}
CriticalSectionWrapper
giver_sect_
;
CRITICAL_SECTION
crit_sect_
;
ConditionVariableEventWin
cond_var_
;
bool
being_passed_
;
int
pass_count_
;
}
;
bool
WaitingRunFunction
(
void
*
obj
)
{
Baton
*
the_baton
=
static_cast
<
Baton
*
>
(
obj
)
;
EXPECT_TRUE
(
the_baton
-
>
Grab
(
kLongWaitMs
)
)
;
EXPECT_TRUE
(
the_baton
-
>
Pass
(
kLongWaitMs
)
)
;
return
true
;
}
class
CondVarTest
:
public
:
:
testing
:
:
Test
{
public
:
CondVarTest
(
)
:
thread_
(
&
WaitingRunFunction
&
baton_
"
CondVarTest
"
)
{
}
virtual
void
SetUp
(
)
{
thread_
.
Start
(
)
;
}
virtual
void
TearDown
(
)
{
ASSERT_TRUE
(
baton_
.
Pass
(
kShortWaitMs
)
)
;
ASSERT_TRUE
(
baton_
.
Grab
(
kShortWaitMs
)
)
;
thread_
.
Stop
(
)
;
}
protected
:
Baton
baton_
;
private
:
rtc
:
:
PlatformThread
thread_
;
}
;
TEST_F
(
CondVarTest
DISABLED_InitFunctionsWork
)
{
}
TEST_F
(
CondVarTest
DISABLED_PassBatonMultipleTimes
)
{
const
int
kNumberOfRounds
=
2
;
for
(
int
i
=
0
;
i
<
kNumberOfRounds
;
+
+
i
)
{
ASSERT_TRUE
(
baton_
.
Pass
(
kShortWaitMs
)
)
;
ASSERT_TRUE
(
baton_
.
Grab
(
kShortWaitMs
)
)
;
}
EXPECT_EQ
(
2
*
kNumberOfRounds
baton_
.
PassCount
(
)
)
;
}
TEST
(
CondVarWaitTest
WaitingWaits
)
{
CRITICAL_SECTION
crit_sect
;
InitializeCriticalSection
(
&
crit_sect
)
;
ConditionVariableEventWin
cond_var
;
EnterCriticalSection
(
&
crit_sect
)
;
int64_t
start_ms
=
rtc
:
:
TimeMillis
(
)
;
EXPECT_FALSE
(
cond_var
.
SleepCS
(
&
crit_sect
kVeryShortWaitMs
)
)
;
int64_t
end_ms
=
rtc
:
:
TimeMillis
(
)
;
EXPECT_LE
(
start_ms
+
kVeryShortWaitMs
end_ms
)
<
<
"
actual
elapsed
:
"
<
<
end_ms
-
start_ms
;
LeaveCriticalSection
(
&
crit_sect
)
;
DeleteCriticalSection
(
&
crit_sect
)
;
}
}
}
#
endif
