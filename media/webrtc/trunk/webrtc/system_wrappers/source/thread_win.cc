#
include
"
webrtc
/
system_wrappers
/
source
/
thread_win
.
h
"
#
include
<
process
.
h
>
#
include
<
stdio
.
h
>
#
include
<
windows
.
h
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
trace
.
h
"
namespace
webrtc
{
namespace
{
void
CALLBACK
RaiseFlag
(
ULONG_PTR
param
)
{
*
reinterpret_cast
<
bool
*
>
(
param
)
=
true
;
}
#
define
MSDEV_SET_THREAD_NAME
0x406D1388
typedef
struct
tagTHREADNAME_INFO
{
DWORD
dwType
;
LPCSTR
szName
;
DWORD
dwThreadID
;
DWORD
dwFlags
;
}
THREADNAME_INFO
;
void
SetThreadName
(
DWORD
dwThreadID
LPCSTR
szThreadName
)
{
THREADNAME_INFO
info
;
info
.
dwType
=
0x1000
;
info
.
szName
=
szThreadName
;
info
.
dwThreadID
=
dwThreadID
;
info
.
dwFlags
=
0
;
__try
{
RaiseException
(
MSDEV_SET_THREAD_NAME
0
sizeof
(
info
)
/
sizeof
(
DWORD
)
reinterpret_cast
<
ULONG_PTR
*
>
(
&
info
)
)
;
}
__except
(
EXCEPTION_CONTINUE_EXECUTION
)
{
}
}
}
ThreadWindows
:
:
ThreadWindows
(
ThreadRunFunction
func
void
*
obj
const
char
*
thread_name
)
:
run_function_
(
func
)
obj_
(
obj
)
stop_
(
false
)
thread_
(
NULL
)
name_
(
thread_name
?
thread_name
:
"
webrtc
"
)
{
DCHECK
(
func
)
;
}
ThreadWindows
:
:
~
ThreadWindows
(
)
{
DCHECK
(
main_thread_
.
CalledOnValidThread
(
)
)
;
DCHECK
(
!
thread_
)
;
}
uint32_t
ThreadWrapper
:
:
GetThreadId
(
)
{
return
GetCurrentThreadId
(
)
;
}
DWORD
WINAPI
ThreadWindows
:
:
StartThread
(
void
*
param
)
{
static_cast
<
ThreadWindows
*
>
(
param
)
-
>
Run
(
)
;
return
0
;
}
bool
ThreadWindows
:
:
Start
(
)
{
DCHECK
(
main_thread_
.
CalledOnValidThread
(
)
)
;
DCHECK
(
!
thread_
)
;
stop_
=
false
;
DWORD
thread_id
;
thread_
=
:
:
CreateThread
(
NULL
1024
*
1024
&
StartThread
this
STACK_SIZE_PARAM_IS_A_RESERVATION
&
thread_id
)
;
if
(
!
thread_
)
{
DCHECK
(
false
)
<
<
"
CreateThread
failed
"
;
return
false
;
}
return
true
;
}
bool
ThreadWindows
:
:
Stop
(
)
{
DCHECK
(
main_thread_
.
CalledOnValidThread
(
)
)
;
if
(
thread_
)
{
QueueUserAPC
(
&
RaiseFlag
thread_
reinterpret_cast
<
ULONG_PTR
>
(
&
stop_
)
)
;
WaitForSingleObject
(
thread_
INFINITE
)
;
CloseHandle
(
thread_
)
;
thread_
=
nullptr
;
}
return
true
;
}
bool
ThreadWindows
:
:
SetPriority
(
ThreadPriority
priority
)
{
DCHECK
(
main_thread_
.
CalledOnValidThread
(
)
)
;
return
thread_
&
&
SetThreadPriority
(
thread_
priority
)
;
}
void
ThreadWindows
:
:
Run
(
)
{
if
(
!
name_
.
empty
(
)
)
SetThreadName
(
static_cast
<
DWORD
>
(
-
1
)
name_
.
c_str
(
)
)
;
do
{
if
(
!
run_function_
(
obj_
)
)
break
;
SleepEx
(
0
true
)
;
}
while
(
!
stop_
)
;
}
}
