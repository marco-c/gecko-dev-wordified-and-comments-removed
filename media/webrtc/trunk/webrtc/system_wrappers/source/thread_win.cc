#
include
"
webrtc
/
system_wrappers
/
source
/
thread_win
.
h
"
#
include
<
process
.
h
>
#
include
<
stdio
.
h
>
#
include
<
windows
.
h
>
#
include
"
webrtc
/
base
/
checks
.
h
"
#
include
"
webrtc
/
system_wrappers
/
interface
/
trace
.
h
"
namespace
webrtc
{
namespace
{
void
CALLBACK
RaiseFlag
(
ULONG_PTR
param
)
{
*
reinterpret_cast
<
bool
*
>
(
param
)
=
true
;
}
#
define
MSDEV_SET_THREAD_NAME
0x406D1388
typedef
struct
tagTHREADNAME_INFO
{
DWORD
dwType
;
LPCSTR
szName
;
DWORD
dwThreadID
;
DWORD
dwFlags
;
}
THREADNAME_INFO
;
void
SetThreadName
(
DWORD
dwThreadID
LPCSTR
szThreadName
)
{
THREADNAME_INFO
info
;
info
.
dwType
=
0x1000
;
info
.
szName
=
szThreadName
;
info
.
dwThreadID
=
dwThreadID
;
info
.
dwFlags
=
0
;
__try
{
RaiseException
(
MSDEV_SET_THREAD_NAME
0
sizeof
(
info
)
/
sizeof
(
DWORD
)
reinterpret_cast
<
ULONG_PTR
*
>
(
&
info
)
)
;
}
__except
(
EXCEPTION_CONTINUE_EXECUTION
)
{
}
}
}
static
UINT
static_reg_windows_msg
=
RegisterWindowMessageW
(
L
"
WebrtcWindowsUIThreadEvent
"
)
;
static
const
UINT_PTR
kTimerId
=
1
;
static
const
wchar_t
kThisProperty
[
]
=
L
"
ThreadWindowsUIPtr
"
;
static
const
wchar_t
kThreadWindow
[
]
=
L
"
WebrtcWindowsUIThread
"
;
ThreadWindows
:
:
ThreadWindows
(
ThreadRunFunction
func
void
*
obj
const
char
*
thread_name
)
:
run_function_
(
func
)
obj_
(
obj
)
stop_
(
false
)
thread_
(
NULL
)
name_
(
thread_name
?
thread_name
:
"
webrtc
"
)
{
DCHECK
(
func
)
;
}
ThreadWindows
:
:
~
ThreadWindows
(
)
{
DCHECK
(
main_thread_
.
CalledOnValidThread
(
)
)
;
DCHECK
(
!
thread_
)
;
}
uint32_t
ThreadWrapper
:
:
GetThreadId
(
)
{
return
GetCurrentThreadId
(
)
;
}
DWORD
WINAPI
ThreadWindows
:
:
StartThread
(
void
*
param
)
{
static_cast
<
ThreadWindows
*
>
(
param
)
-
>
Run
(
)
;
return
0
;
}
bool
ThreadWindows
:
:
Start
(
)
{
DCHECK
(
main_thread_
.
CalledOnValidThread
(
)
)
;
DCHECK
(
!
thread_
)
;
stop_
=
false
;
DWORD
thread_id
;
thread_
=
:
:
CreateThread
(
NULL
1024
*
1024
&
StartThread
this
STACK_SIZE_PARAM_IS_A_RESERVATION
&
thread_id
)
;
if
(
!
thread_
)
{
DCHECK
(
false
)
<
<
"
CreateThread
failed
"
;
return
false
;
}
return
true
;
}
bool
ThreadWindows
:
:
Stop
(
)
{
DCHECK
(
main_thread_
.
CalledOnValidThread
(
)
)
;
if
(
thread_
)
{
QueueUserAPC
(
&
RaiseFlag
thread_
reinterpret_cast
<
ULONG_PTR
>
(
&
stop_
)
)
;
WaitForSingleObject
(
thread_
INFINITE
)
;
CloseHandle
(
thread_
)
;
thread_
=
nullptr
;
}
return
true
;
}
bool
ThreadWindows
:
:
SetPriority
(
ThreadPriority
priority
)
{
DCHECK
(
main_thread_
.
CalledOnValidThread
(
)
)
;
return
thread_
&
&
SetThreadPriority
(
thread_
priority
)
;
}
void
ThreadWindows
:
:
Run
(
)
{
if
(
!
name_
.
empty
(
)
)
SetThreadName
(
static_cast
<
DWORD
>
(
-
1
)
name_
.
c_str
(
)
)
;
do
{
if
(
!
run_function_
(
obj_
)
)
break
;
SleepEx
(
0
true
)
;
}
while
(
!
stop_
)
;
}
bool
ThreadWindowsUI
:
:
Stop
(
)
{
DCHECK
(
main_thread_
.
CalledOnValidThread
(
)
)
;
if
(
timerid_
)
{
KillTimer
(
hwnd_
timerid_
)
;
timerid_
=
0
;
}
PostMessage
(
hwnd_
WM_CLOSE
0
0
)
;
return
ThreadWindows
:
:
Stop
(
)
;
}
bool
ThreadWindowsUI
:
:
InternalInit
(
)
{
if
(
hwnd_
=
=
NULL
)
{
WNDCLASSW
wc
;
HMODULE
hModule
=
GetModuleHandle
(
NULL
)
;
if
(
!
GetClassInfoW
(
hModule
kThreadWindow
&
wc
)
)
{
ZeroMemory
(
&
wc
sizeof
(
WNDCLASSW
)
)
;
wc
.
hInstance
=
hModule
;
wc
.
lpfnWndProc
=
EventWindowProc
;
wc
.
lpszClassName
=
kThreadWindow
;
RegisterClassW
(
&
wc
)
;
}
hwnd_
=
CreateWindowW
(
kThreadWindow
L
"
"
0
0
0
0
0
NULL
NULL
hModule
NULL
)
;
assert
(
hwnd_
)
;
SetPropW
(
hwnd_
kThisProperty
this
)
;
if
(
timeout_
)
{
RequestCallbackTimer
(
timeout_
)
;
}
}
return
!
!
hwnd_
;
}
void
ThreadWindowsUI
:
:
RequestCallback
(
)
{
assert
(
hwnd_
)
;
assert
(
static_reg_windows_msg
)
;
PostMessage
(
hwnd_
static_reg_windows_msg
0
0
)
;
}
bool
ThreadWindowsUI
:
:
RequestCallbackTimer
(
unsigned
int
milliseconds
)
{
if
(
!
hwnd_
)
{
assert
(
!
thread_
)
;
}
else
{
if
(
timerid_
)
{
KillTimer
(
hwnd_
timerid_
)
;
}
timerid_
=
SetTimer
(
hwnd_
kTimerId
milliseconds
NULL
)
;
}
timeout_
=
milliseconds
;
return
!
!
timerid_
;
}
void
ThreadWindowsUI
:
:
Run
(
)
{
if
(
!
InternalInit
(
)
)
{
assert
(
false
)
;
}
if
(
!
name_
.
empty
(
)
)
SetThreadName
(
static_cast
<
DWORD
>
(
-
1
)
name_
.
c_str
(
)
)
;
do
{
if
(
!
run_function_
(
obj_
)
)
break
;
if
(
MsgWaitForMultipleObjectsEx
(
0
nullptr
INFINITE
QS_ALLINPUT
MWMO_ALERTABLE
|
MWMO_INPUTAVAILABLE
)
=
=
WAIT_OBJECT_0
)
{
MSG
msg
;
if
(
PeekMessage
(
&
msg
NULL
0
0
PM_REMOVE
)
)
{
if
(
msg
.
message
=
=
WM_QUIT
)
{
stop_
=
true
;
break
;
}
TranslateMessage
(
&
msg
)
;
DispatchMessage
(
&
msg
)
;
}
}
}
while
(
!
stop_
)
;
}
;
void
ThreadWindowsUI
:
:
NativeEventCallback
(
)
{
if
(
!
run_function_
)
{
stop_
=
true
;
return
;
}
stop_
=
!
run_function_
(
obj_
)
;
}
LRESULT
CALLBACK
ThreadWindowsUI
:
:
EventWindowProc
(
HWND
hwnd
UINT
uMsg
WPARAM
wParam
LPARAM
lParam
)
{
if
(
uMsg
=
=
WM_DESTROY
)
{
RemovePropW
(
hwnd
kThisProperty
)
;
PostQuitMessage
(
0
)
;
return
0
;
}
ThreadWindowsUI
*
twui
=
static_cast
<
ThreadWindowsUI
*
>
(
GetPropW
(
hwnd
kThisProperty
)
)
;
if
(
!
twui
)
{
return
DefWindowProc
(
hwnd
uMsg
wParam
lParam
)
;
}
if
(
(
uMsg
=
=
static_reg_windows_msg
&
&
uMsg
!
=
WM_NULL
)
|
|
(
uMsg
=
=
WM_TIMER
&
&
wParam
=
=
kTimerId
)
)
{
twui
-
>
NativeEventCallback
(
)
;
return
0
;
}
return
DefWindowProc
(
hwnd
uMsg
wParam
lParam
)
;
}
}
