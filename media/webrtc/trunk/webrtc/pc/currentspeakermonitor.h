#
ifndef
WEBRTC_PC_CURRENTSPEAKERMONITOR_H_
#
define
WEBRTC_PC_CURRENTSPEAKERMONITOR_H_
#
include
<
stdint
.
h
>
#
include
<
map
>
#
include
"
webrtc
/
base
/
sigslot
.
h
"
namespace
cricket
{
struct
AudioInfo
;
struct
MediaStreams
;
class
AudioSourceContext
{
public
:
sigslot
:
:
signal2
<
AudioSourceContext
*
const
cricket
:
:
AudioInfo
&
>
SignalAudioMonitor
;
sigslot
:
:
signal1
<
AudioSourceContext
*
>
SignalMediaStreamsReset
;
sigslot
:
:
signal3
<
AudioSourceContext
*
const
cricket
:
:
MediaStreams
&
const
cricket
:
:
MediaStreams
&
>
SignalMediaStreamsUpdate
;
}
;
class
CurrentSpeakerMonitor
:
public
sigslot
:
:
has_slots
<
>
{
public
:
explicit
CurrentSpeakerMonitor
(
AudioSourceContext
*
audio_source_context
)
;
~
CurrentSpeakerMonitor
(
)
;
void
Start
(
)
;
void
Stop
(
)
;
void
set_min_time_between_switches
(
int
min_time_between_switches
)
;
sigslot
:
:
signal2
<
CurrentSpeakerMonitor
*
uint32_t
>
SignalUpdate
;
private
:
void
OnAudioMonitor
(
AudioSourceContext
*
audio_source_context
const
AudioInfo
&
info
)
;
void
OnMediaStreamsUpdate
(
AudioSourceContext
*
audio_source_context
const
MediaStreams
&
added
const
MediaStreams
&
removed
)
;
void
OnMediaStreamsReset
(
AudioSourceContext
*
audio_source_context
)
;
enum
SpeakingState
{
SS_NOT_SPEAKING
SS_MIGHT_BE_SPEAKING
SS_SPEAKING
SS_WAS_SPEAKING_RECENTLY1
SS_WAS_SPEAKING_RECENTLY2
}
;
bool
started_
;
AudioSourceContext
*
audio_source_context_
;
std
:
:
map
<
uint32_t
SpeakingState
>
ssrc_to_speaking_state_map_
;
uint32_t
current_speaker_ssrc_
;
int64_t
earliest_permitted_switch_time_
;
int
min_time_between_switches_
;
}
;
}
#
endif
