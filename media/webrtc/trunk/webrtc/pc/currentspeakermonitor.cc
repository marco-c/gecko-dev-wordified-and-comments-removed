#
include
"
webrtc
/
pc
/
currentspeakermonitor
.
h
"
#
include
<
vector
>
#
include
"
webrtc
/
base
/
logging
.
h
"
#
include
"
webrtc
/
media
/
base
/
streamparams
.
h
"
#
include
"
webrtc
/
pc
/
audiomonitor
.
h
"
namespace
cricket
{
namespace
{
const
int
kMaxAudioLevel
=
9
;
const
int
kDefaultMinTimeBetweenSwitches
=
1000
;
}
CurrentSpeakerMonitor
:
:
CurrentSpeakerMonitor
(
AudioSourceContext
*
audio_source_context
)
:
started_
(
false
)
audio_source_context_
(
audio_source_context
)
current_speaker_ssrc_
(
0
)
earliest_permitted_switch_time_
(
0
)
min_time_between_switches_
(
kDefaultMinTimeBetweenSwitches
)
{
}
CurrentSpeakerMonitor
:
:
~
CurrentSpeakerMonitor
(
)
{
Stop
(
)
;
}
void
CurrentSpeakerMonitor
:
:
Start
(
)
{
if
(
!
started_
)
{
audio_source_context_
-
>
SignalAudioMonitor
.
connect
(
this
&
CurrentSpeakerMonitor
:
:
OnAudioMonitor
)
;
audio_source_context_
-
>
SignalMediaStreamsUpdate
.
connect
(
this
&
CurrentSpeakerMonitor
:
:
OnMediaStreamsUpdate
)
;
audio_source_context_
-
>
SignalMediaStreamsReset
.
connect
(
this
&
CurrentSpeakerMonitor
:
:
OnMediaStreamsReset
)
;
started_
=
true
;
}
}
void
CurrentSpeakerMonitor
:
:
Stop
(
)
{
if
(
started_
)
{
audio_source_context_
-
>
SignalAudioMonitor
.
disconnect
(
this
)
;
audio_source_context_
-
>
SignalMediaStreamsUpdate
.
disconnect
(
this
)
;
started_
=
false
;
ssrc_to_speaking_state_map_
.
clear
(
)
;
current_speaker_ssrc_
=
0
;
earliest_permitted_switch_time_
=
0
;
}
}
void
CurrentSpeakerMonitor
:
:
set_min_time_between_switches
(
int
min_time_between_switches
)
{
min_time_between_switches_
=
min_time_between_switches
;
}
void
CurrentSpeakerMonitor
:
:
OnAudioMonitor
(
AudioSourceContext
*
audio_source_context
const
AudioInfo
&
info
)
{
std
:
:
map
<
uint32_t
int
>
active_ssrc_to_level_map
;
cricket
:
:
AudioInfo
:
:
StreamList
:
:
const_iterator
stream_list_it
;
for
(
stream_list_it
=
info
.
active_streams
.
begin
(
)
;
stream_list_it
!
=
info
.
active_streams
.
end
(
)
;
+
+
stream_list_it
)
{
uint32_t
ssrc
=
stream_list_it
-
>
first
;
active_ssrc_to_level_map
[
ssrc
]
=
stream_list_it
-
>
second
;
if
(
ssrc_to_speaking_state_map_
.
find
(
ssrc
)
=
=
ssrc_to_speaking_state_map_
.
end
(
)
)
{
ssrc_to_speaking_state_map_
[
ssrc
]
=
SS_NOT_SPEAKING
;
}
}
int
max_level
=
0
;
uint32_t
loudest_speaker_ssrc
=
0
;
std
:
:
map
<
uint32_t
SpeakingState
>
:
:
iterator
state_it
;
for
(
state_it
=
ssrc_to_speaking_state_map_
.
begin
(
)
;
state_it
!
=
ssrc_to_speaking_state_map_
.
end
(
)
;
+
+
state_it
)
{
bool
is_previous_speaker
=
current_speaker_ssrc_
=
=
state_it
-
>
first
;
std
:
:
map
<
uint32_t
int
>
:
:
const_iterator
level_it
=
active_ssrc_to_level_map
.
find
(
state_it
-
>
first
)
;
int
level
=
(
level_it
!
=
active_ssrc_to_level_map
.
end
(
)
)
?
level_it
-
>
second
:
0
;
switch
(
state_it
-
>
second
)
{
case
SS_NOT_SPEAKING
:
if
(
level
>
0
)
{
level
=
0
;
state_it
-
>
second
=
SS_MIGHT_BE_SPEAKING
;
}
else
{
}
break
;
case
SS_MIGHT_BE_SPEAKING
:
if
(
level
>
0
)
{
state_it
-
>
second
=
SS_SPEAKING
;
}
else
{
state_it
-
>
second
=
SS_NOT_SPEAKING
;
}
break
;
case
SS_SPEAKING
:
if
(
level
>
0
)
{
}
else
{
state_it
-
>
second
=
SS_WAS_SPEAKING_RECENTLY1
;
if
(
is_previous_speaker
)
{
level
=
kMaxAudioLevel
;
}
}
break
;
case
SS_WAS_SPEAKING_RECENTLY1
:
if
(
level
>
0
)
{
state_it
-
>
second
=
SS_SPEAKING
;
}
else
{
state_it
-
>
second
=
SS_WAS_SPEAKING_RECENTLY2
;
if
(
is_previous_speaker
)
{
level
=
kMaxAudioLevel
;
}
}
break
;
case
SS_WAS_SPEAKING_RECENTLY2
:
if
(
level
>
0
)
{
state_it
-
>
second
=
SS_SPEAKING
;
}
else
{
state_it
-
>
second
=
SS_NOT_SPEAKING
;
}
break
;
}
if
(
level
>
max_level
)
{
loudest_speaker_ssrc
=
state_it
-
>
first
;
max_level
=
level
;
}
else
if
(
level
>
0
&
&
level
=
=
max_level
&
&
is_previous_speaker
)
{
loudest_speaker_ssrc
=
state_it
-
>
first
;
}
}
int64_t
now
=
rtc
:
:
TimeMillis
(
)
;
if
(
earliest_permitted_switch_time_
<
=
now
&
&
current_speaker_ssrc_
!
=
loudest_speaker_ssrc
)
{
current_speaker_ssrc_
=
loudest_speaker_ssrc
;
LOG
(
LS_INFO
)
<
<
"
Current
speaker
changed
to
"
<
<
current_speaker_ssrc_
;
earliest_permitted_switch_time_
=
now
+
min_time_between_switches_
;
SignalUpdate
(
this
current_speaker_ssrc_
)
;
}
}
void
CurrentSpeakerMonitor
:
:
OnMediaStreamsUpdate
(
AudioSourceContext
*
audio_source_context
const
MediaStreams
&
added
const
MediaStreams
&
removed
)
{
if
(
audio_source_context
=
=
audio_source_context_
)
{
for
(
std
:
:
vector
<
cricket
:
:
StreamParams
>
:
:
const_iterator
it
=
removed
.
audio
(
)
.
begin
(
)
;
it
!
=
removed
.
audio
(
)
.
end
(
)
;
+
+
it
)
{
ssrc_to_speaking_state_map_
.
erase
(
it
-
>
first_ssrc
(
)
)
;
}
for
(
std
:
:
vector
<
cricket
:
:
StreamParams
>
:
:
const_iterator
it
=
added
.
audio
(
)
.
begin
(
)
;
it
!
=
added
.
audio
(
)
.
end
(
)
;
+
+
it
)
{
ssrc_to_speaking_state_map_
[
it
-
>
first_ssrc
(
)
]
=
SS_NOT_SPEAKING
;
}
}
}
void
CurrentSpeakerMonitor
:
:
OnMediaStreamsReset
(
AudioSourceContext
*
audio_source_context
)
{
if
(
audio_source_context
=
=
audio_source_context_
)
{
ssrc_to_speaking_state_map_
.
clear
(
)
;
}
}
}
