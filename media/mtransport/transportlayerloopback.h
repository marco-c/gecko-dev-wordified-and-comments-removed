#
ifndef
transportlayerloopback_h__
#
define
transportlayerloopback_h__
#
include
"
nspr
.
h
"
#
include
"
prio
.
h
"
#
include
"
prlock
.
h
"
#
include
<
memory
>
#
include
<
queue
>
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
m_cpp_utils
.
h
"
#
include
"
transportflow
.
h
"
#
include
"
transportlayer
.
h
"
namespace
mozilla
{
class
TransportLayerLoopback
:
public
TransportLayer
{
public
:
TransportLayerLoopback
(
)
:
peer_
(
nullptr
)
timer_
(
nullptr
)
packets_
(
)
packets_lock_
(
nullptr
)
deliverer_
(
nullptr
)
combinePackets_
(
false
)
{
}
~
TransportLayerLoopback
(
)
{
while
(
!
packets_
.
empty
(
)
)
{
MediaPacket
*
packet
=
packets_
.
front
(
)
;
packets_
.
pop
(
)
;
delete
packet
;
}
if
(
packets_lock_
)
{
PR_DestroyLock
(
packets_lock_
)
;
}
timer_
-
>
Cancel
(
)
;
deliverer_
-
>
Detach
(
)
;
}
nsresult
Init
(
)
;
void
Connect
(
TransportLayerLoopback
*
peer
)
;
void
Disconnect
(
)
{
TransportLayerLoopback
*
peer
=
peer_
;
peer_
=
nullptr
;
if
(
peer
)
{
peer
-
>
Disconnect
(
)
;
}
}
void
CombinePackets
(
bool
combine
)
{
combinePackets_
=
combine
;
}
TransportResult
SendPacket
(
MediaPacket
&
packet
)
override
;
void
DeliverPackets
(
)
;
TRANSPORT_LAYER_ID
(
"
loopback
"
)
private
:
DISALLOW_COPY_ASSIGN
(
TransportLayerLoopback
)
;
class
Deliverer
:
public
nsITimerCallback
public
nsINamed
{
public
:
explicit
Deliverer
(
TransportLayerLoopback
*
layer
)
:
layer_
(
layer
)
{
}
void
Detach
(
)
{
layer_
=
nullptr
;
}
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
private
:
virtual
~
Deliverer
(
)
{
}
DISALLOW_COPY_ASSIGN
(
Deliverer
)
;
TransportLayerLoopback
*
layer_
;
}
;
nsresult
QueuePacket
(
MediaPacket
&
packet
)
;
TransportLayerLoopback
*
peer_
;
nsCOMPtr
<
nsITimer
>
timer_
;
std
:
:
queue
<
MediaPacket
*
>
packets_
;
PRLock
*
packets_lock_
;
RefPtr
<
Deliverer
>
deliverer_
;
bool
combinePackets_
;
}
;
}
#
endif
