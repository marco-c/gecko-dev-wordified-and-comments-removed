#
include
<
deque
>
#
include
"
logging
.
h
"
#
include
"
runnable_utils
.
h
"
#
include
"
transportflow
.
h
"
#
include
"
transportlayer
.
h
"
namespace
mozilla
{
MOZ_MTLOG_MODULE
(
"
mtransport
"
)
NS_IMPL_ISUPPORTS0
(
TransportFlow
)
TransportFlow
:
:
~
TransportFlow
(
)
{
if
(
target_
)
{
nsAutoPtr
<
std
:
:
deque
<
TransportLayer
*
>
>
layers_tmp
(
layers_
.
release
(
)
)
;
RUN_ON_THREAD
(
target_
WrapRunnableNM
(
&
TransportFlow
:
:
DestroyFinal
layers_tmp
)
NS_DISPATCH_NORMAL
)
;
}
}
void
TransportFlow
:
:
DestroyFinal
(
nsAutoPtr
<
std
:
:
deque
<
TransportLayer
*
>
>
layers
)
{
ClearLayers
(
layers
.
get
(
)
)
;
}
void
TransportFlow
:
:
ClearLayers
(
std
:
:
deque
<
TransportLayer
*
>
*
layers
)
{
while
(
!
layers
-
>
empty
(
)
)
{
delete
layers
-
>
front
(
)
;
layers
-
>
pop_front
(
)
;
}
}
nsresult
TransportFlow
:
:
PushLayer
(
TransportLayer
*
layer
)
{
CheckThread
(
)
;
if
(
!
layers_
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
layer
-
>
Init
(
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
MOZ_MTLOG
(
ML_ERROR
id_
<
<
"
:
Layer
initialization
failed
"
)
;
delete
layer
;
ClearLayers
(
layers_
.
get
(
)
)
;
layers_
.
reset
(
)
;
return
rv
;
}
TransportLayer
*
old_layer
=
layers_
-
>
empty
(
)
?
nullptr
:
layers_
-
>
front
(
)
;
layers_
-
>
push_front
(
layer
)
;
EnsureSameThread
(
layer
)
;
layer
-
>
Inserted
(
this
old_layer
)
;
return
NS_OK
;
}
TransportLayer
*
TransportFlow
:
:
GetLayer
(
const
std
:
:
string
&
id
)
const
{
CheckThread
(
)
;
if
(
layers_
)
{
for
(
TransportLayer
*
layer
:
*
layers_
)
{
if
(
layer
-
>
id
(
)
=
=
id
)
return
layer
;
}
}
return
nullptr
;
}
void
TransportFlow
:
:
EnsureSameThread
(
TransportLayer
*
layer
)
{
if
(
target_
)
{
const
nsCOMPtr
<
nsIEventTarget
>
&
lthread
=
layer
-
>
GetThread
(
)
;
if
(
lthread
&
&
(
lthread
!
=
target_
)
)
MOZ_CRASH
(
)
;
}
else
{
target_
=
layer
-
>
GetThread
(
)
;
}
}
}
