#
include
<
deque
>
#
include
"
logging
.
h
"
#
include
"
runnable_utils
.
h
"
#
include
"
transportflow
.
h
"
#
include
"
transportlayer
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
namespace
mozilla
{
NS_IMPL_ISUPPORTS0
(
TransportFlow
)
TransportFlow
:
:
~
TransportFlow
(
)
{
MOZ_RELEASE_ASSERT
(
target_
)
;
DebugOnly
<
nsresult
>
rv
=
target_
-
>
Dispatch
(
WrapRunnableNM
(
&
TransportFlow
:
:
DestroyFinal
std
:
:
move
(
layers_
)
)
NS_DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
TransportFlow
:
:
DestroyFinal
(
UniquePtr
<
std
:
:
deque
<
TransportLayer
*
>
>
layers
)
{
ClearLayers
(
layers
.
get
(
)
)
;
}
void
TransportFlow
:
:
ClearLayers
(
std
:
:
deque
<
TransportLayer
*
>
*
layers
)
{
while
(
!
layers
-
>
empty
(
)
)
{
delete
layers
-
>
front
(
)
;
layers
-
>
pop_front
(
)
;
}
}
void
TransportFlow
:
:
PushLayer
(
TransportLayer
*
layer
)
{
CheckThread
(
)
;
layers_
-
>
push_front
(
layer
)
;
EnsureSameThread
(
layer
)
;
layer
-
>
SetFlowId
(
id_
)
;
}
TransportLayer
*
TransportFlow
:
:
GetLayer
(
const
std
:
:
string
&
id
)
const
{
CheckThread
(
)
;
if
(
layers_
)
{
for
(
TransportLayer
*
layer
:
*
layers_
)
{
if
(
layer
-
>
id
(
)
=
=
id
)
return
layer
;
}
}
return
nullptr
;
}
void
TransportFlow
:
:
EnsureSameThread
(
TransportLayer
*
layer
)
{
if
(
target_
)
{
const
nsCOMPtr
<
nsIEventTarget
>
&
lthread
=
layer
-
>
GetThread
(
)
;
if
(
lthread
&
&
(
lthread
!
=
target_
)
)
MOZ_CRASH
(
)
;
}
else
{
target_
=
layer
-
>
GetThread
(
)
;
}
}
}
