#
include
"
rlogconnector
.
h
"
#
include
<
cstdarg
>
#
include
<
deque
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
logging
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
extern
"
C
"
{
#
include
<
csi_platform
.
h
>
#
include
"
r_log
.
h
"
#
include
"
registry
.
h
"
}
static
int
ringbuffer_vlog
(
int
facility
int
level
const
char
*
format
va_list
ap
)
{
if
(
mozilla
:
:
RLogConnector
:
:
GetInstance
(
)
-
>
ShouldLog
(
level
)
)
{
char
temp
[
4096
]
;
VsprintfLiteral
(
temp
format
ap
)
;
mozilla
:
:
RLogConnector
:
:
GetInstance
(
)
-
>
Log
(
level
std
:
:
string
(
temp
)
)
;
}
return
0
;
}
static
mozilla
:
:
LogLevel
rLogLvlToMozLogLvl
(
int
level
)
{
switch
(
level
)
{
case
LOG_EMERG
:
case
LOG_ALERT
:
case
LOG_CRIT
:
case
LOG_ERR
:
return
mozilla
:
:
LogLevel
:
:
Error
;
case
LOG_WARNING
:
return
mozilla
:
:
LogLevel
:
:
Warning
;
case
LOG_NOTICE
:
return
mozilla
:
:
LogLevel
:
:
Info
;
case
LOG_INFO
:
return
mozilla
:
:
LogLevel
:
:
Debug
;
case
LOG_DEBUG
:
default
:
return
mozilla
:
:
LogLevel
:
:
Verbose
;
}
}
MOZ_MTLOG_MODULE
(
"
nicer
"
)
;
namespace
mozilla
{
RLogConnector
*
RLogConnector
:
:
instance
;
RLogConnector
:
:
RLogConnector
(
)
:
log_limit_
(
4096
)
mutex_
(
"
RLogConnector
:
:
mutex_
"
)
disableCount_
(
0
)
{
}
RLogConnector
:
:
~
RLogConnector
(
)
=
default
;
void
RLogConnector
:
:
SetLogLimit
(
uint32_t
new_limit
)
{
OffTheBooksMutexAutoLock
lock
(
mutex_
)
;
log_limit_
=
new_limit
;
RemoveOld
(
)
;
}
bool
RLogConnector
:
:
ShouldLog
(
int
level
)
const
{
return
level
<
=
LOG_INFO
|
|
MOZ_LOG_TEST
(
getLogModule
(
)
rLogLvlToMozLogLvl
(
level
)
)
;
}
void
RLogConnector
:
:
Log
(
int
level
std
:
:
string
&
&
log
)
{
MOZ_MTLOG
(
rLogLvlToMozLogLvl
(
level
)
log
)
;
OffTheBooksMutexAutoLock
lock
(
mutex_
)
;
if
(
disableCount_
=
=
0
)
{
AddMsg
(
std
:
:
move
(
log
)
)
;
}
}
void
RLogConnector
:
:
AddMsg
(
std
:
:
string
&
&
msg
)
{
log_messages_
.
push_front
(
std
:
:
move
(
msg
)
)
;
RemoveOld
(
)
;
}
inline
void
RLogConnector
:
:
RemoveOld
(
)
{
if
(
log_messages_
.
size
(
)
>
log_limit_
)
{
log_messages_
.
resize
(
log_limit_
)
;
}
}
RLogConnector
*
RLogConnector
:
:
CreateInstance
(
)
{
if
(
!
instance
)
{
instance
=
new
RLogConnector
;
NR_reg_init
(
NR_REG_MODE_LOCAL
)
;
r_log_set_extra_destination
(
LOG_DEBUG
&
ringbuffer_vlog
)
;
}
return
instance
;
}
RLogConnector
*
RLogConnector
:
:
GetInstance
(
)
{
return
instance
;
}
void
RLogConnector
:
:
DestroyInstance
(
)
{
r_log_set_extra_destination
(
LOG_DEBUG
nullptr
)
;
delete
instance
;
instance
=
nullptr
;
}
void
RLogConnector
:
:
EnterPrivateMode
(
)
{
OffTheBooksMutexAutoLock
lock
(
mutex_
)
;
+
+
disableCount_
;
MOZ_ASSERT
(
disableCount_
!
=
0
)
;
if
(
disableCount_
=
=
1
)
{
AddMsg
(
"
LOGGING
SUSPENDED
:
a
connection
is
active
in
a
Private
Window
*
*
*
"
)
;
}
}
void
RLogConnector
:
:
ExitPrivateMode
(
)
{
OffTheBooksMutexAutoLock
lock
(
mutex_
)
;
MOZ_ASSERT
(
disableCount_
!
=
0
)
;
if
(
-
-
disableCount_
=
=
0
)
{
AddMsg
(
"
LOGGING
RESUMED
:
no
connections
are
active
in
a
Private
Window
*
*
*
"
)
;
}
}
void
RLogConnector
:
:
Clear
(
)
{
OffTheBooksMutexAutoLock
lock
(
mutex_
)
;
log_messages_
.
clear
(
)
;
}
void
RLogConnector
:
:
Filter
(
const
std
:
:
string
&
substring
uint32_t
limit
std
:
:
deque
<
std
:
:
string
>
*
matching_logs
)
{
std
:
:
vector
<
std
:
:
string
>
substrings
;
substrings
.
push_back
(
substring
)
;
FilterAny
(
substrings
limit
matching_logs
)
;
}
inline
bool
AnySubstringMatches
(
const
std
:
:
vector
<
std
:
:
string
>
&
substrings
const
std
:
:
string
&
string
)
{
for
(
auto
sub
=
substrings
.
begin
(
)
;
sub
!
=
substrings
.
end
(
)
;
+
+
sub
)
{
if
(
string
.
find
(
*
sub
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
}
return
false
;
}
void
RLogConnector
:
:
FilterAny
(
const
std
:
:
vector
<
std
:
:
string
>
&
substrings
uint32_t
limit
std
:
:
deque
<
std
:
:
string
>
*
matching_logs
)
{
OffTheBooksMutexAutoLock
lock
(
mutex_
)
;
if
(
limit
=
=
0
)
{
limit
=
log_limit_
;
}
for
(
auto
log
=
log_messages_
.
begin
(
)
;
log
!
=
log_messages_
.
end
(
)
&
&
matching_logs
-
>
size
(
)
<
limit
;
+
+
log
)
{
if
(
AnySubstringMatches
(
substrings
*
log
)
)
{
matching_logs
-
>
push_front
(
*
log
)
;
}
}
}
}
