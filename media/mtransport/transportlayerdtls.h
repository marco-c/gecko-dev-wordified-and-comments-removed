#
ifndef
transportlayerdtls_h__
#
define
transportlayerdtls_h__
#
include
<
queue
>
#
include
<
set
>
#
include
"
sigslot
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
ScopedNSSTypes
.
h
"
#
include
"
m_cpp_utils
.
h
"
#
include
"
dtlsidentity
.
h
"
#
include
"
transportlayer
.
h
"
#
include
"
ssl
.
h
"
namespace
mozilla
{
static
const
uint16_t
kDtlsSrtpAes128CmHmacSha1_80
=
0x0001
;
static
const
uint16_t
kDtlsSrtpAes128CmHmacSha1_32
=
0x0002
;
static
const
uint16_t
kDtlsSrtpAeadAes128Gcm
=
0x0007
;
static
const
uint16_t
kDtlsSrtpAeadAes256Gcm
=
0x0008
;
struct
Packet
;
class
TransportLayerNSPRAdapter
{
public
:
explicit
TransportLayerNSPRAdapter
(
TransportLayer
*
output
)
:
output_
(
output
)
input_
(
)
enabled_
(
true
)
{
}
void
PacketReceived
(
MediaPacket
&
packet
)
;
int32_t
Recv
(
void
*
buf
int32_t
buflen
)
;
int32_t
Write
(
const
void
*
buf
int32_t
length
)
;
void
SetEnabled
(
bool
enabled
)
{
enabled_
=
enabled
;
}
private
:
DISALLOW_COPY_ASSIGN
(
TransportLayerNSPRAdapter
)
;
TransportLayer
*
output_
;
std
:
:
queue
<
MediaPacket
*
>
input_
;
bool
enabled_
;
}
;
class
TransportLayerDtls
final
:
public
TransportLayer
{
public
:
TransportLayerDtls
(
)
=
default
;
virtual
~
TransportLayerDtls
(
)
;
enum
Role
{
CLIENT
SERVER
}
;
enum
Verification
{
VERIFY_UNSET
VERIFY_ALLOW_ALL
VERIFY_DIGEST
}
;
const
static
size_t
kMaxDigestLength
=
HASH_LENGTH_MAX
;
void
SetRole
(
Role
role
)
{
role_
=
role
;
}
Role
role
(
)
{
return
role_
;
}
void
SetIdentity
(
const
RefPtr
<
DtlsIdentity
>
&
identity
)
{
identity_
=
identity
;
}
nsresult
SetAlpn
(
const
std
:
:
set
<
std
:
:
string
>
&
allowedAlpn
const
std
:
:
string
&
alpnDefault
)
;
const
std
:
:
string
&
GetNegotiatedAlpn
(
)
const
{
return
alpn_
;
}
nsresult
SetVerificationAllowAll
(
)
;
nsresult
SetVerificationDigest
(
const
std
:
:
string
digest_algorithm
const
unsigned
char
*
digest_value
size_t
digest_len
)
;
nsresult
GetCipherSuite
(
uint16_t
*
cipherSuite
)
const
;
nsresult
SetSrtpCiphers
(
const
std
:
:
vector
<
uint16_t
>
&
ciphers
)
;
nsresult
GetSrtpCipher
(
uint16_t
*
cipher
)
const
;
static
std
:
:
vector
<
uint16_t
>
GetDefaultSrtpCiphers
(
)
;
nsresult
ExportKeyingMaterial
(
const
std
:
:
string
&
label
bool
use_context
const
std
:
:
string
&
context
unsigned
char
*
out
unsigned
int
outlen
)
;
nsresult
InitInternal
(
)
override
;
void
WasInserted
(
)
override
;
TransportResult
SendPacket
(
MediaPacket
&
packet
)
override
;
void
StateChange
(
TransportLayer
*
layer
State
state
)
;
void
PacketReceived
(
TransportLayer
*
layer
MediaPacket
&
packet
)
;
PRFileDesc
*
internal_fd
(
)
{
CheckThread
(
)
;
return
ssl_fd_
.
get
(
)
;
}
TRANSPORT_LAYER_ID
(
"
dtls
"
)
protected
:
void
SetState
(
State
state
const
char
*
file
unsigned
line
)
override
;
private
:
DISALLOW_COPY_ASSIGN
(
TransportLayerDtls
)
;
class
VerificationDigest
{
public
:
VerificationDigest
(
std
:
:
string
algorithm
const
unsigned
char
*
value
size_t
len
)
{
MOZ_ASSERT
(
len
<
=
sizeof
(
value_
)
)
;
algorithm_
=
algorithm
;
memcpy
(
value_
value
len
)
;
len_
=
len
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VerificationDigest
)
std
:
:
string
algorithm_
;
size_t
len_
;
unsigned
char
value_
[
kMaxDigestLength
]
;
private
:
~
VerificationDigest
(
)
{
}
DISALLOW_COPY_ASSIGN
(
VerificationDigest
)
;
}
;
bool
Setup
(
)
;
bool
SetupCipherSuites
(
UniquePRFileDesc
&
ssl_fd
)
;
bool
SetupAlpn
(
UniquePRFileDesc
&
ssl_fd
)
const
;
void
GetDecryptedPackets
(
)
;
void
Handshake
(
)
;
bool
CheckAlpn
(
)
;
static
SECStatus
GetClientAuthDataHook
(
void
*
arg
PRFileDesc
*
fd
CERTDistNames
*
caNames
CERTCertificate
*
*
pRetCert
SECKEYPrivateKey
*
*
pRetKey
)
;
static
SECStatus
AuthCertificateHook
(
void
*
arg
PRFileDesc
*
fd
PRBool
checksig
PRBool
isServer
)
;
SECStatus
AuthCertificateHook
(
PRFileDesc
*
fd
PRBool
checksig
PRBool
isServer
)
;
static
void
TimerCallback
(
nsITimer
*
timer
void
*
arg
)
;
SECStatus
CheckDigest
(
const
RefPtr
<
VerificationDigest
>
&
digest
UniqueCERTCertificate
&
cert
)
const
;
void
RecordHandshakeCompletionTelemetry
(
TransportLayer
:
:
State
endState
)
;
void
RecordTlsTelemetry
(
)
;
static
PRBool
WriteSrtpXtn
(
PRFileDesc
*
fd
SSLHandshakeType
message
uint8_t
*
data
unsigned
int
*
len
unsigned
int
max_len
void
*
arg
)
;
static
SECStatus
HandleSrtpXtn
(
PRFileDesc
*
fd
SSLHandshakeType
message
const
uint8_t
*
data
unsigned
int
len
SSLAlertDescription
*
alert
void
*
arg
)
;
RefPtr
<
DtlsIdentity
>
identity_
;
std
:
:
set
<
std
:
:
string
>
alpn_allowed_
;
std
:
:
string
alpn_default_
;
std
:
:
string
alpn_
;
std
:
:
vector
<
uint16_t
>
enabled_srtp_ciphers_
;
uint16_t
srtp_cipher_
=
0
;
Role
role_
=
CLIENT
;
Verification
verification_mode_
=
VERIFY_UNSET
;
std
:
:
vector
<
RefPtr
<
VerificationDigest
>
>
digests_
;
UniquePtr
<
TransportLayerNSPRAdapter
>
nspr_io_adapter_
=
nullptr
;
UniquePRFileDesc
ssl_fd_
=
nullptr
;
nsCOMPtr
<
nsITimer
>
timer_
=
nullptr
;
bool
auth_hook_called_
=
false
;
bool
cert_ok_
=
false
;
TimeStamp
handshake_started_
;
}
;
}
#
endif
