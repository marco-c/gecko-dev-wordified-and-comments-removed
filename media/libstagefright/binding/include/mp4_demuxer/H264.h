#
ifndef
MP4_DEMUXER_H264_H_
#
define
MP4_DEMUXER_H264_H_
#
include
"
mp4_demuxer
/
DecoderData
.
h
"
namespace
mp4_demuxer
{
#
define
MAX_SPS_COUNT
32
#
define
MAX_PPS_COUNT
256
enum
NAL_TYPES
{
H264_NAL_SLICE
=
1
H264_NAL_DPA
=
2
H264_NAL_DPB
=
3
H264_NAL_DPC
=
4
H264_NAL_IDR_SLICE
=
5
H264_NAL_SEI
=
6
H264_NAL_SPS
=
7
H264_NAL_PPS
=
8
H264_NAL_AUD
=
9
H264_NAL_END_SEQUENCE
=
10
H264_NAL_END_STREAM
=
11
H264_NAL_FILLER_DATA
=
12
H264_NAL_SPS_EXT
=
13
H264_NAL_PREFIX
=
14
H264_NAL_AUXILIARY_SLICE
=
19
H264_NAL_SLICE_EXT
=
20
H264_NAL_SLICE_EXT_DVC
=
21
}
;
class
BitReader
;
struct
SPSData
{
bool
operator
=
=
(
const
SPSData
&
aOther
)
const
;
bool
operator
!
=
(
const
SPSData
&
aOther
)
const
;
bool
valid
;
uint32_t
pic_width
;
uint32_t
pic_height
;
bool
interlaced
;
uint32_t
display_width
;
uint32_t
display_height
;
float
sample_ratio
;
uint32_t
crop_left
;
uint32_t
crop_right
;
uint32_t
crop_top
;
uint32_t
crop_bottom
;
bool
constraint_set0_flag
;
bool
constraint_set1_flag
;
bool
constraint_set2_flag
;
bool
constraint_set3_flag
;
bool
constraint_set4_flag
;
bool
constraint_set5_flag
;
uint8_t
profile_idc
;
uint8_t
level_idc
;
uint8_t
seq_parameter_set_id
;
uint8_t
chroma_format_idc
;
uint8_t
bit_depth_luma_minus8
;
uint8_t
bit_depth_chroma_minus8
;
bool
separate_colour_plane_flag
;
bool
seq_scaling_matrix_present_flag
;
uint8_t
log2_max_frame_num
;
uint8_t
pic_order_cnt_type
;
uint8_t
log2_max_pic_order_cnt_lsb
;
bool
delta_pic_order_always_zero_flag
;
int8_t
offset_for_non_ref_pic
;
int8_t
offset_for_top_to_bottom_field
;
uint32_t
max_num_ref_frames
;
bool
gaps_in_frame_num_allowed_flag
;
uint32_t
pic_width_in_mbs
;
uint32_t
pic_height_in_map_units
;
bool
frame_mbs_only_flag
;
bool
mb_adaptive_frame_field_flag
;
bool
direct_8x8_inference_flag
;
bool
frame_cropping_flag
;
uint32_t
frame_crop_left_offset
;
uint32_t
frame_crop_right_offset
;
uint32_t
frame_crop_top_offset
;
uint32_t
frame_crop_bottom_offset
;
bool
vui_parameters_present_flag
;
bool
aspect_ratio_info_present_flag
;
uint8_t
aspect_ratio_idc
;
uint32_t
sar_width
;
uint32_t
sar_height
;
bool
video_signal_type_present_flag
;
bool
overscan_info_present_flag
;
bool
overscan_appropriate_flag
;
uint8_t
video_format
;
bool
video_full_range_flag
;
bool
colour_description_present_flag
;
uint8_t
colour_primaries
;
uint8_t
transfer_characteristics
;
uint8_t
matrix_coefficients
;
bool
chroma_loc_info_present_flag
;
uint8_t
chroma_sample_loc_type_top_field
;
uint8_t
chroma_sample_loc_type_bottom_field
;
bool
timing_info_present_flag
;
uint32_t
num_units_in_tick
;
uint32_t
time_scale
;
bool
fixed_frame_rate_flag
;
bool
scaling_matrix_present
;
uint8_t
scaling_matrix4x4
[
6
]
[
16
]
;
uint8_t
scaling_matrix8x8
[
6
]
[
64
]
;
SPSData
(
)
;
}
;
class
H264
{
public
:
static
bool
HasSPS
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData
)
;
static
already_AddRefed
<
mozilla
:
:
MediaByteBuffer
>
ExtractExtraData
(
const
mozilla
:
:
MediaRawData
*
aSample
)
;
static
bool
CompareExtraData
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData1
const
mozilla
:
:
MediaByteBuffer
*
aExtraData2
)
;
static
bool
EnsureSPSIsSane
(
SPSData
&
aSPS
)
;
static
bool
DecodeSPSFromExtraData
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData
SPSData
&
aDest
)
;
static
uint32_t
ComputeMaxRefFrames
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData
)
;
enum
class
FrameType
{
I_FRAME
OTHER
INVALID
}
;
static
FrameType
GetFrameType
(
const
mozilla
:
:
MediaRawData
*
aSample
)
;
private
:
friend
class
SPSNAL
;
static
already_AddRefed
<
mozilla
:
:
MediaByteBuffer
>
DecodeNALUnit
(
const
uint8_t
*
aNAL
size_t
aLength
)
;
static
bool
DecodeSPS
(
const
mozilla
:
:
MediaByteBuffer
*
aSPS
SPSData
&
aDest
)
;
static
bool
vui_parameters
(
BitReader
&
aBr
SPSData
&
aDest
)
;
static
void
hrd_parameters
(
BitReader
&
aBr
)
;
static
uint8_t
NumSPS
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData
)
;
}
;
}
#
endif
