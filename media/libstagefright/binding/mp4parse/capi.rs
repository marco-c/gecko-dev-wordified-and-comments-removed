use
std
;
use
std
:
:
io
:
:
Cursor
;
use
MediaContext
;
use
TrackType
;
use
read_mp4
;
use
Error
;
use
media_time_to_ms
;
use
track_time_to_ms
;
use
SampleEntry
;
const
MP4PARSE_OK
:
i32
=
0
;
const
MP4PARSE_ERROR_BADARG
:
i32
=
-
1
;
const
MP4PARSE_ERROR_INVALID
:
i32
=
-
2
;
const
MP4PARSE_ERROR_UNSUPPORTED
:
i32
=
-
3
;
const
MP4PARSE_ERROR_EOF
:
i32
=
-
4
;
const
MP4PARSE_ASSERT
:
i32
=
-
5
;
const
MP4PARSE_ERROR_IO
:
i32
=
-
6
;
const
TRACK_TYPE_H264
:
u32
=
0
;
const
TRACK_TYPE_AAC
:
u32
=
1
;
#
[
repr
(
C
)
]
pub
struct
TrackInfo
{
track_type
:
u32
track_id
:
u32
duration
:
u64
media_time
:
i64
}
#
[
repr
(
C
)
]
pub
struct
TrackAudioInfo
{
channels
:
u16
bit_depth
:
u16
sample_rate
:
u32
}
#
[
repr
(
C
)
]
pub
struct
TrackVideoInfo
{
display_width
:
u32
display_height
:
u32
image_width
:
u16
image_height
:
u16
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
mp4parse_new
(
)
-
>
*
mut
MediaContext
{
let
context
=
Box
:
:
new
(
MediaContext
:
:
new
(
)
)
;
Box
:
:
into_raw
(
context
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mp4parse_free
(
context
:
*
mut
MediaContext
)
{
assert
!
(
!
context
.
is_null
(
)
)
;
let
_
=
Box
:
:
from_raw
(
context
)
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mp4parse_read
(
context
:
*
mut
MediaContext
buffer
:
*
const
u8
size
:
usize
)
-
>
i32
{
if
context
.
is_null
(
)
|
|
buffer
.
is_null
(
)
|
|
size
<
8
{
return
MP4PARSE_ERROR_BADARG
;
}
let
mut
context
:
&
mut
MediaContext
=
&
mut
*
context
;
let
b
=
std
:
:
slice
:
:
from_raw_parts
(
buffer
size
)
;
let
mut
c
=
Cursor
:
:
new
(
b
)
;
let
task
=
std
:
:
thread
:
:
spawn
(
move
|
|
read_mp4
(
&
mut
c
&
mut
context
)
)
;
match
task
.
join
(
)
.
unwrap_or
(
Err
(
Error
:
:
AssertCaught
)
)
{
Ok
(
_
)
=
>
MP4PARSE_OK
Err
(
Error
:
:
InvalidData
)
=
>
MP4PARSE_ERROR_INVALID
Err
(
Error
:
:
Unsupported
)
=
>
MP4PARSE_ERROR_UNSUPPORTED
Err
(
Error
:
:
UnexpectedEOF
)
=
>
MP4PARSE_ERROR_EOF
Err
(
Error
:
:
AssertCaught
)
=
>
MP4PARSE_ASSERT
Err
(
Error
:
:
Io
(
_
)
)
=
>
MP4PARSE_ERROR_IO
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mp4parse_get_track_count
(
context
:
*
const
MediaContext
)
-
>
u32
{
assert
!
(
!
context
.
is_null
(
)
)
;
let
context
=
&
*
context
;
assert
!
(
context
.
tracks
.
len
(
)
<
u32
:
:
max_value
(
)
as
usize
)
;
context
.
tracks
.
len
(
)
as
u32
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mp4parse_get_track_info
(
context
:
*
mut
MediaContext
track
:
u32
info
:
*
mut
TrackInfo
)
-
>
i32
{
if
context
.
is_null
(
)
|
|
info
.
is_null
(
)
{
return
MP4PARSE_ERROR_BADARG
;
}
let
context
:
&
mut
MediaContext
=
&
mut
*
context
;
let
track_index
:
usize
=
track
as
usize
;
let
info
:
&
mut
TrackInfo
=
&
mut
*
info
;
if
track_index
>
=
context
.
tracks
.
len
(
)
{
return
MP4PARSE_ERROR_BADARG
;
}
info
.
track_type
=
match
context
.
tracks
[
track_index
]
.
track_type
{
TrackType
:
:
Video
=
>
TRACK_TYPE_H264
TrackType
:
:
Audio
=
>
TRACK_TYPE_AAC
TrackType
:
:
Unknown
=
>
return
MP4PARSE_ERROR_UNSUPPORTED
}
;
if
context
.
timescale
.
is_none
(
)
|
|
context
.
tracks
[
track_index
]
.
timescale
.
is_none
(
)
|
|
context
.
tracks
[
track_index
]
.
duration
.
is_none
(
)
|
|
context
.
tracks
[
track_index
]
.
track_id
.
is_none
(
)
{
return
MP4PARSE_ERROR_INVALID
;
}
std
:
:
thread
:
:
spawn
(
move
|
|
{
let
track
=
&
context
.
tracks
[
track_index
]
;
let
empty_duration
=
if
track
.
empty_duration
.
is_some
(
)
{
media_time_to_ms
(
track
.
empty_duration
.
unwrap
(
)
context
.
timescale
.
unwrap
(
)
)
}
else
{
0
}
;
info
.
media_time
=
if
track
.
media_time
.
is_some
(
)
{
track_time_to_ms
(
track
.
media_time
.
unwrap
(
)
track
.
timescale
.
unwrap
(
)
)
as
i64
-
empty_duration
as
i64
}
else
{
0
}
;
info
.
duration
=
track_time_to_ms
(
track
.
duration
.
unwrap
(
)
track
.
timescale
.
unwrap
(
)
)
;
info
.
track_id
=
track
.
track_id
.
unwrap
(
)
;
MP4PARSE_OK
}
)
.
join
(
)
.
unwrap_or
(
MP4PARSE_ERROR_INVALID
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mp4parse_get_track_audio_info
(
context
:
*
mut
MediaContext
track
:
u32
info
:
*
mut
TrackAudioInfo
)
-
>
i32
{
if
context
.
is_null
(
)
|
|
info
.
is_null
(
)
{
return
MP4PARSE_ERROR_BADARG
;
}
let
context
:
&
mut
MediaContext
=
&
mut
*
context
;
if
track
as
usize
>
=
context
.
tracks
.
len
(
)
{
return
MP4PARSE_ERROR_BADARG
;
}
let
track
=
&
context
.
tracks
[
track
as
usize
]
;
match
track
.
track_type
{
TrackType
:
:
Audio
=
>
{
}
_
=
>
return
MP4PARSE_ERROR_INVALID
}
;
let
audio
=
match
track
.
data
{
Some
(
ref
data
)
=
>
data
None
=
>
return
MP4PARSE_ERROR_INVALID
}
;
let
audio
=
match
*
audio
{
SampleEntry
:
:
Audio
(
ref
x
)
=
>
x
_
=
>
return
MP4PARSE_ERROR_INVALID
}
;
(
*
info
)
.
channels
=
audio
.
channelcount
;
(
*
info
)
.
bit_depth
=
audio
.
samplesize
;
(
*
info
)
.
sample_rate
=
audio
.
samplerate
>
>
16
;
MP4PARSE_OK
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mp4parse_get_track_video_info
(
context
:
*
mut
MediaContext
track
:
u32
info
:
*
mut
TrackVideoInfo
)
-
>
i32
{
if
context
.
is_null
(
)
|
|
info
.
is_null
(
)
{
return
MP4PARSE_ERROR_BADARG
;
}
let
context
:
&
mut
MediaContext
=
&
mut
*
context
;
if
track
as
usize
>
=
context
.
tracks
.
len
(
)
{
return
MP4PARSE_ERROR_BADARG
;
}
let
track
=
&
context
.
tracks
[
track
as
usize
]
;
match
track
.
track_type
{
TrackType
:
:
Video
=
>
{
}
_
=
>
return
MP4PARSE_ERROR_INVALID
}
;
let
video
=
match
track
.
data
{
Some
(
ref
data
)
=
>
data
None
=
>
return
MP4PARSE_ERROR_INVALID
}
;
let
video
=
match
*
video
{
SampleEntry
:
:
Video
(
ref
x
)
=
>
x
_
=
>
return
MP4PARSE_ERROR_INVALID
}
;
if
let
Some
(
ref
tkhd
)
=
track
.
tkhd
{
(
*
info
)
.
display_width
=
tkhd
.
width
>
>
16
;
(
*
info
)
.
display_height
=
tkhd
.
height
>
>
16
;
}
else
{
return
MP4PARSE_ERROR_INVALID
;
}
(
*
info
)
.
image_width
=
video
.
width
;
(
*
info
)
.
image_width
=
video
.
height
;
MP4PARSE_OK
}
#
[
test
]
fn
new_context
(
)
{
let
context
=
mp4parse_new
(
)
;
assert
!
(
!
context
.
is_null
(
)
)
;
unsafe
{
mp4parse_free
(
context
)
;
}
}
#
[
test
]
#
[
should_panic
(
expected
=
"
assertion
failed
"
)
]
fn
free_null_context
(
)
{
unsafe
{
mp4parse_free
(
std
:
:
ptr
:
:
null_mut
(
)
)
;
}
}
#
[
test
]
fn
arg_validation
(
)
{
let
null_buffer
=
std
:
:
ptr
:
:
null
(
)
;
let
null_context
=
std
:
:
ptr
:
:
null_mut
(
)
;
let
context
=
mp4parse_new
(
)
;
assert
!
(
!
context
.
is_null
(
)
)
;
let
buffer
=
vec
!
[
0u8
;
8
]
;
unsafe
{
assert_eq
!
(
MP4PARSE_ERROR_BADARG
mp4parse_read
(
null_context
null_buffer
0
)
)
;
assert_eq
!
(
MP4PARSE_ERROR_BADARG
mp4parse_read
(
context
null_buffer
0
)
)
;
}
for
size
in
0
.
.
buffer
.
len
(
)
{
println
!
(
"
testing
buffer
length
{
}
"
size
)
;
unsafe
{
assert_eq
!
(
MP4PARSE_ERROR_BADARG
mp4parse_read
(
context
buffer
.
as_ptr
(
)
size
)
)
;
}
}
unsafe
{
mp4parse_free
(
context
)
;
}
}
