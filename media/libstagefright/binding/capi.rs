use
std
;
use
std
:
:
io
:
:
Cursor
;
use
MediaContext
;
use
read_box
;
use
Error
;
#
[
no_mangle
]
pub
extern
"
C
"
fn
mp4parse_new
(
)
-
>
*
mut
MediaContext
{
let
context
=
Box
:
:
new
(
MediaContext
:
:
new
(
)
)
;
Box
:
:
into_raw
(
context
)
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mp4parse_free
(
context
:
*
mut
MediaContext
)
{
assert
!
(
!
context
.
is_null
(
)
)
;
let
_
=
Box
:
:
from_raw
(
context
)
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
mp4parse_read
(
context
:
*
mut
MediaContext
buffer
:
*
const
u8
size
:
usize
)
-
>
i32
{
if
context
.
is_null
(
)
|
|
buffer
.
is_null
(
)
|
|
size
<
8
{
return
-
1
;
}
let
mut
context
:
&
mut
MediaContext
=
&
mut
*
context
;
let
b
=
std
:
:
slice
:
:
from_raw_parts
(
buffer
size
)
;
let
mut
c
=
Cursor
:
:
new
(
b
)
;
let
task
=
std
:
:
thread
:
:
spawn
(
move
|
|
{
loop
{
match
read_box
(
&
mut
c
&
mut
context
)
{
Ok
(
_
)
=
>
{
}
Err
(
Error
:
:
UnexpectedEOF
)
=
>
{
break
}
Err
(
e
)
=
>
{
panic
!
(
e
)
;
}
}
}
assert
!
(
context
.
tracks
.
len
(
)
<
i32
:
:
max_value
(
)
as
usize
)
;
context
.
tracks
.
len
(
)
as
i32
}
)
;
task
.
join
(
)
.
unwrap_or
(
-
1
)
}
#
[
test
]
fn
new_context
(
)
{
let
context
=
mp4parse_new
(
)
;
assert
!
(
!
context
.
is_null
(
)
)
;
unsafe
{
mp4parse_free
(
context
)
;
}
}
#
[
test
]
#
[
should_panic
(
expected
=
"
assertion
failed
"
)
]
fn
free_null_context
(
)
{
unsafe
{
mp4parse_free
(
std
:
:
ptr
:
:
null_mut
(
)
)
;
}
}
#
[
test
]
fn
arg_validation
(
)
{
let
null_buffer
=
std
:
:
ptr
:
:
null
(
)
;
let
null_context
=
std
:
:
ptr
:
:
null_mut
(
)
;
let
context
=
mp4parse_new
(
)
;
assert
!
(
!
context
.
is_null
(
)
)
;
let
buffer
=
vec
!
[
0u8
;
8
]
;
unsafe
{
assert_eq
!
(
-
1
mp4parse_read
(
null_context
null_buffer
0
)
)
;
assert_eq
!
(
-
1
mp4parse_read
(
context
null_buffer
0
)
)
;
}
for
size
in
0
.
.
buffer
.
len
(
)
{
println
!
(
"
testing
buffer
length
{
}
"
size
)
;
unsafe
{
assert_eq
!
(
-
1
mp4parse_read
(
context
buffer
.
as_ptr
(
)
size
)
)
;
}
}
unsafe
{
mp4parse_free
(
context
)
;
}
}
