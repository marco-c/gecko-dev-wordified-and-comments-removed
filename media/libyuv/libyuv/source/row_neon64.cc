#
include
"
libyuv
/
row
.
h
"
#
ifdef
__cplusplus
namespace
libyuv
{
extern
"
C
"
{
#
endif
#
if
!
defined
(
LIBYUV_DISABLE_NEON
)
&
&
defined
(
__aarch64__
)
#
define
READYUV422
\
"
ldr
d0
[
%
[
src_y
]
]
#
8
\
n
"
\
"
ldr
s1
[
%
[
src_u
]
]
#
4
\
n
"
\
"
ldr
s2
[
%
[
src_v
]
]
#
4
\
n
"
\
"
zip1
v0
.
16b
v0
.
16b
v0
.
16b
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_y
]
448
]
\
n
"
\
"
zip1
v1
.
8b
v1
.
8b
v1
.
8b
\
n
"
\
"
zip1
v2
.
8b
v2
.
8b
v2
.
8b
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_u
]
128
]
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_v
]
128
]
\
n
"
#
define
READYUV210
\
"
ldr
q2
[
%
[
src_y
]
]
#
16
\
n
"
\
"
ldr
d1
[
%
[
src_u
]
]
#
8
\
n
"
\
"
ldr
d3
[
%
[
src_v
]
]
#
8
\
n
"
\
"
shl
v0
.
8h
v2
.
8h
#
6
\
n
"
\
"
usra
v0
.
8h
v2
.
8h
#
4
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_y
]
448
]
\
n
"
\
"
zip1
v2
.
8h
v3
.
8h
v3
.
8h
\
n
"
\
"
zip1
v3
.
8h
v1
.
8h
v1
.
8h
\
n
"
\
"
uqshrn
v1
.
8b
v3
.
8h
#
2
\
n
"
\
"
uqshrn2
v1
.
16b
v2
.
8h
#
2
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_u
]
128
]
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_v
]
128
]
\
n
"
#
define
READYUVP210
\
"
ldr
q0
[
%
[
src_y
]
]
#
16
\
n
"
\
"
ldr
q1
[
%
[
src_uv
]
]
#
16
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_y
]
448
]
\
n
"
\
"
tbl
v1
.
16b
{
v1
.
16b
}
v2
.
16b
\
n
"
#
define
READYUV212
\
"
ldr
q2
[
%
[
src_y
]
]
#
16
\
n
"
\
"
ldr
d1
[
%
[
src_u
]
]
#
8
\
n
"
\
"
ldr
d3
[
%
[
src_v
]
]
#
8
\
n
"
\
"
shl
v0
.
8h
v2
.
8h
#
4
\
n
"
\
"
usra
v0
.
8h
v2
.
8h
#
8
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_y
]
448
]
\
n
"
\
"
zip1
v2
.
8h
v3
.
8h
v3
.
8h
\
n
"
\
"
zip1
v3
.
8h
v1
.
8h
v1
.
8h
\
n
"
\
"
uqshrn
v1
.
8b
v3
.
8h
#
4
\
n
"
\
"
uqshrn2
v1
.
16b
v2
.
8h
#
4
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_u
]
128
]
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_v
]
128
]
\
n
"
#
define
READYUV410
\
"
ldr
q1
[
%
[
src_y
]
]
#
16
\
n
"
\
"
ldr
q2
[
%
[
src_u
]
]
#
16
\
n
"
\
"
ldr
q3
[
%
[
src_v
]
]
#
16
\
n
"
\
"
shl
v0
.
8h
v1
.
8h
#
6
\
n
"
\
"
usra
v0
.
8h
v1
.
8h
#
4
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_y
]
448
]
\
n
"
\
"
uqshrn
v1
.
8b
v2
.
8h
#
2
\
n
"
\
"
uqshrn2
v1
.
16b
v3
.
8h
#
2
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_u
]
128
]
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_v
]
128
]
\
n
"
#
define
READYUVP410
\
"
ldr
q0
[
%
[
src_y
]
]
#
16
\
n
"
\
"
ldp
q4
q5
[
%
[
src_uv
]
]
#
32
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_y
]
448
]
\
n
"
\
"
tbl
v1
.
16b
{
v4
.
16b
v5
.
16b
}
v2
.
16b
\
n
"
#
define
READYUV444
\
"
ldr
d0
[
%
[
src_y
]
]
#
8
\
n
"
\
"
ldr
d1
[
%
[
src_u
]
]
#
8
\
n
"
\
"
ldr
d2
[
%
[
src_v
]
]
#
8
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_y
]
448
]
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_u
]
448
]
\
n
"
\
"
zip1
v0
.
16b
v0
.
16b
v0
.
16b
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_v
]
448
]
\
n
"
#
define
READYUV400
\
"
ldr
d0
[
%
[
src_y
]
]
#
8
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_y
]
448
]
\
n
"
\
"
zip1
v0
.
16b
v0
.
16b
v0
.
16b
\
n
"
static
const
uvec8
kNV12Table
=
{
0
0
2
2
4
4
6
6
1
1
3
3
5
5
7
7
}
;
static
const
uvec8
kNV12InterleavedTable
=
{
0
0
4
4
8
8
12
12
2
2
6
6
10
10
14
14
}
;
static
const
uvec8
kNV21Table
=
{
1
1
3
3
5
5
7
7
0
0
2
2
4
4
6
6
}
;
static
const
uvec8
kNV21InterleavedTable
=
{
1
1
5
5
9
9
13
13
3
3
7
7
11
11
15
15
}
;
#
define
READNV12
\
"
ldr
d0
[
%
[
src_y
]
]
#
8
\
n
"
\
"
ldr
d1
[
%
[
src_uv
]
]
#
8
\
n
"
\
"
zip1
v0
.
16b
v0
.
16b
v0
.
16b
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_y
]
448
]
\
n
"
\
"
tbl
v1
.
16b
{
v1
.
16b
}
v2
.
16b
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_uv
]
448
]
\
n
"
#
define
READYUY2
\
"
ld1
{
v3
.
16b
}
[
%
[
src_yuy2
]
]
#
16
\
n
"
\
"
trn1
v0
.
16b
v3
.
16b
v3
.
16b
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_yuy2
]
448
]
\
n
"
\
"
tbl
v1
.
16b
{
v3
.
16b
}
v2
.
16b
\
n
"
#
define
READUYVY
\
"
ld1
{
v3
.
16b
}
[
%
[
src_uyvy
]
]
#
16
\
n
"
\
"
trn2
v0
.
16b
v3
.
16b
v3
.
16b
\
n
"
\
"
prfm
pldl1keep
[
%
[
src_uyvy
]
448
]
\
n
"
\
"
tbl
v1
.
16b
{
v3
.
16b
}
v2
.
16b
\
n
"
#
define
YUVTORGB_SETUP
\
"
ld4r
{
v28
.
16b
v29
.
16b
v30
.
16b
v31
.
16b
}
[
%
[
kUVCoeff
]
]
\
n
"
\
"
ld4r
{
v24
.
8h
v25
.
8h
v26
.
8h
v27
.
8h
}
[
%
[
kRGBCoeffBias
]
]
\
n
"
#
define
NVTORGB
\
"
umull2
v3
.
4s
v0
.
8h
v24
.
8h
\
n
"
\
"
umull
v6
.
8h
v1
.
8b
v30
.
8b
\
n
"
\
"
umull
v0
.
4s
v0
.
4h
v24
.
4h
\
n
"
\
"
umlal2
v6
.
8h
v1
.
16b
v31
.
16b
\
n
"
/
*
DG
*
/
\
"
uzp2
v0
.
8h
v0
.
8h
v3
.
8h
\
n
"
/
*
Y
*
/
\
"
umull
v4
.
8h
v1
.
8b
v28
.
8b
\
n
"
/
*
DB
*
/
\
"
umull2
v5
.
8h
v1
.
16b
v29
.
16b
\
n
"
/
*
DR
*
/
\
"
add
v17
.
8h
v0
.
8h
v26
.
8h
\
n
"
/
*
G
*
/
\
"
add
v16
.
8h
v0
.
8h
v4
.
8h
\
n
"
/
*
B
*
/
\
"
add
v18
.
8h
v0
.
8h
v5
.
8h
\
n
"
/
*
R
*
/
\
"
uqsub
v17
.
8h
v17
.
8h
v6
.
8h
\
n
"
/
*
G
*
/
\
"
uqsub
v16
.
8h
v16
.
8h
v25
.
8h
\
n
"
/
*
B
*
/
\
"
uqsub
v18
.
8h
v18
.
8h
v27
.
8h
\
n
"
/
*
R
*
/
#
define
I4XXTORGB
\
"
umull2
v3
.
4s
v0
.
8h
v24
.
8h
\
n
"
\
"
umull
v6
.
8h
v1
.
8b
v30
.
8b
\
n
"
\
"
umull
v0
.
4s
v0
.
4h
v24
.
4h
\
n
"
\
"
umlal
v6
.
8h
v2
.
8b
v31
.
8b
\
n
"
/
*
DG
*
/
\
"
uzp2
v0
.
8h
v0
.
8h
v3
.
8h
\
n
"
/
*
Y
*
/
\
"
umull
v4
.
8h
v1
.
8b
v28
.
8b
\
n
"
/
*
DB
*
/
\
"
umull
v5
.
8h
v2
.
8b
v29
.
8b
\
n
"
/
*
DR
*
/
\
"
add
v17
.
8h
v0
.
8h
v26
.
8h
\
n
"
/
*
G
*
/
\
"
add
v16
.
8h
v0
.
8h
v4
.
8h
\
n
"
/
*
B
*
/
\
"
add
v18
.
8h
v0
.
8h
v5
.
8h
\
n
"
/
*
R
*
/
\
"
uqsub
v17
.
8h
v17
.
8h
v6
.
8h
\
n
"
/
*
G
*
/
\
"
uqsub
v16
.
8h
v16
.
8h
v25
.
8h
\
n
"
/
*
B
*
/
\
"
uqsub
v18
.
8h
v18
.
8h
v27
.
8h
\
n
"
/
*
R
*
/
#
define
I400TORGB
\
"
umull2
v3
.
4s
v0
.
8h
v24
.
8h
\
n
"
\
"
umull
v0
.
4s
v0
.
4h
v24
.
4h
\
n
"
\
"
uzp2
v0
.
8h
v0
.
8h
v3
.
8h
\
n
"
/
*
Y
*
/
\
"
add
v17
.
8h
v0
.
8h
v26
.
8h
\
n
"
/
*
G
*
/
\
"
add
v16
.
8h
v0
.
8h
v4
.
8h
\
n
"
/
*
B
*
/
\
"
add
v18
.
8h
v0
.
8h
v5
.
8h
\
n
"
/
*
R
*
/
\
"
uqsub
v17
.
8h
v17
.
8h
v6
.
8h
\
n
"
/
*
G
*
/
\
"
uqsub
v16
.
8h
v16
.
8h
v25
.
8h
\
n
"
/
*
B
*
/
\
"
uqsub
v18
.
8h
v18
.
8h
v27
.
8h
\
n
"
/
*
R
*
/
#
define
RGBTORGB8
\
"
uqshrn
v17
.
8b
v17
.
8h
#
6
\
n
"
\
"
uqshrn
v16
.
8b
v16
.
8h
#
6
\
n
"
\
"
uqshrn
v18
.
8b
v18
.
8h
#
6
\
n
"
#
define
RGBTORGB8_TOP
\
"
uqshl
v17
.
8h
v17
.
8h
#
2
\
n
"
\
"
uqshl
v16
.
8h
v16
.
8h
#
2
\
n
"
\
"
uqshl
v18
.
8h
v18
.
8h
#
2
\
n
"
#
define
STOREAR30
\
"
uqshl
v0
.
8h
v16
.
8h
#
2
\
n
"
/
*
bbbbbbbbbbxxxxxx
*
/
\
"
uqshl
v1
.
8h
v17
.
8h
#
2
\
n
"
/
*
ggggggggggxxxxxx
*
/
\
"
umin
v6
.
8h
v18
.
8h
v22
.
8h
\
n
"
/
*
00rrrrrrrrrrxxxx
*
/
\
"
shl
v4
.
8h
v1
.
8h
#
4
\
n
"
/
*
ggggggxxxxxx0000
*
/
\
"
orr
v5
.
16b
v6
.
16b
v23
.
16b
\
n
"
/
*
11rrrrrrrrrrxxxx
*
/
\
"
sri
v4
.
8h
v0
.
8h
#
6
\
n
"
/
*
ggggggbbbbbbbbbb
*
/
\
"
sri
v5
.
8h
v1
.
8h
#
12
\
n
"
/
*
11rrrrrrrrrrgggg
*
/
\
"
st2
{
v4
.
8h
v5
.
8h
}
[
%
[
dst_ar30
]
]
#
32
\
n
"
#
define
YUVTORGB_REGS
\
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v16
"
"
v17
"
"
v18
"
"
v24
"
\
"
v25
"
"
v26
"
"
v27
"
"
v28
"
"
v29
"
"
v30
"
"
v31
"
void
I444ToARGBRow_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
1
:
\
n
"
READYUV444
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
I4XXTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
I444ToRGB24Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_rgb24
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
1
:
\
n
"
READYUV444
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
I4XXTORGB
RGBTORGB8
"
st3
{
v16
.
8b
v17
.
8b
v18
.
8b
}
[
%
[
dst_rgb24
]
]
#
24
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_rgb24
]
"
+
r
"
(
dst_rgb24
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
)
;
}
void
I210ToAR30Row_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_u
const
uint16_t
*
src_v
uint8_t
*
dst_ar30
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
const
uvec8
*
uv_coeff
=
&
yuvconstants
-
>
kUVCoeff
;
const
vec16
*
rgb_coeff
=
&
yuvconstants
-
>
kRGBCoeffBias
;
uint16_t
limit
=
0x3ff0
;
uint16_t
alpha
=
0xc000
;
asm
volatile
(
YUVTORGB_SETUP
"
dup
v22
.
8h
%
w
[
limit
]
\
n
"
"
dup
v23
.
8h
%
w
[
alpha
]
\
n
"
"
1
:
\
n
"
READYUV210
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
STOREAR30
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_ar30
]
"
+
r
"
(
dst_ar30
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
uv_coeff
)
[
kRGBCoeffBias
]
"
r
"
(
rgb_coeff
)
[
limit
]
"
r
"
(
limit
)
[
alpha
]
"
r
"
(
alpha
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v22
"
"
v23
"
)
;
}
void
I410ToAR30Row_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_u
const
uint16_t
*
src_v
uint8_t
*
dst_ar30
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
const
uvec8
*
uv_coeff
=
&
yuvconstants
-
>
kUVCoeff
;
const
vec16
*
rgb_coeff
=
&
yuvconstants
-
>
kRGBCoeffBias
;
uint16_t
limit
=
0x3ff0
;
uint16_t
alpha
=
0xc000
;
asm
volatile
(
YUVTORGB_SETUP
"
dup
v22
.
8h
%
w
[
limit
]
\
n
"
"
dup
v23
.
8h
%
w
[
alpha
]
\
n
"
"
1
:
\
n
"
READYUV410
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
STOREAR30
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_ar30
]
"
+
r
"
(
dst_ar30
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
uv_coeff
)
[
kRGBCoeffBias
]
"
r
"
(
rgb_coeff
)
[
limit
]
"
r
"
(
limit
)
[
alpha
]
"
r
"
(
alpha
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v22
"
"
v23
"
)
;
}
void
I212ToAR30Row_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_u
const
uint16_t
*
src_v
uint8_t
*
dst_ar30
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
const
uvec8
*
uv_coeff
=
&
yuvconstants
-
>
kUVCoeff
;
const
vec16
*
rgb_coeff
=
&
yuvconstants
-
>
kRGBCoeffBias
;
const
uint16_t
limit
=
0x3ff0
;
asm
volatile
(
YUVTORGB_SETUP
"
dup
v22
.
8h
%
w
[
limit
]
\
n
"
"
movi
v23
.
8h
#
0xc0
lsl
#
8
\
n
"
"
1
:
\
n
"
READYUV212
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
STOREAR30
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_ar30
]
"
+
r
"
(
dst_ar30
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
uv_coeff
)
[
kRGBCoeffBias
]
"
r
"
(
rgb_coeff
)
[
limit
]
"
r
"
(
limit
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v22
"
"
v23
"
)
;
}
void
I210ToARGBRow_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_u
const
uint16_t
*
src_v
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
1
:
\
n
"
READYUV210
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
I410ToARGBRow_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_u
const
uint16_t
*
src_v
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
1
:
\
n
"
READYUV410
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
I212ToARGBRow_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_u
const
uint16_t
*
src_v
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
const
uvec8
*
uv_coeff
=
&
yuvconstants
-
>
kUVCoeff
;
const
vec16
*
rgb_coeff
=
&
yuvconstants
-
>
kRGBCoeffBias
;
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
1
:
\
n
"
READYUV212
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
uv_coeff
)
[
kRGBCoeffBias
]
"
r
"
(
rgb_coeff
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
I422ToARGBRow_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
1
:
\
n
"
READYUV422
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
I4XXTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
uint8_t
kP210LoadShuffleIndices
[
]
=
{
1
1
5
5
9
9
13
13
3
3
7
7
11
11
15
15
}
;
void
P210ToARGBRow_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_uv
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
const
uvec8
*
uv_coeff
=
&
yuvconstants
-
>
kUVCoeff
;
const
vec16
*
rgb_coeff
=
&
yuvconstants
-
>
kRGBCoeffBias
;
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
ldr
q2
[
%
[
kIndices
]
]
\
n
"
"
1
:
\
n
"
READYUVP210
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_uv
]
"
+
r
"
(
src_uv
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
uv_coeff
)
[
kRGBCoeffBias
]
"
r
"
(
rgb_coeff
)
[
kIndices
]
"
r
"
(
kP210LoadShuffleIndices
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
uint8_t
kP410LoadShuffleIndices
[
]
=
{
1
5
9
13
17
21
25
29
3
7
11
15
19
23
27
31
}
;
void
P410ToARGBRow_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_uv
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
const
uvec8
*
uv_coeff
=
&
yuvconstants
-
>
kUVCoeff
;
const
vec16
*
rgb_coeff
=
&
yuvconstants
-
>
kRGBCoeffBias
;
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
ldr
q2
[
%
[
kIndices
]
]
\
n
"
"
1
:
\
n
"
READYUVP410
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_uv
]
"
+
r
"
(
src_uv
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
uv_coeff
)
[
kRGBCoeffBias
]
"
r
"
(
rgb_coeff
)
[
kIndices
]
"
r
"
(
kP410LoadShuffleIndices
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
P210ToAR30Row_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_uv
uint8_t
*
dst_ar30
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
const
uvec8
*
uv_coeff
=
&
yuvconstants
-
>
kUVCoeff
;
const
vec16
*
rgb_coeff
=
&
yuvconstants
-
>
kRGBCoeffBias
;
const
uint16_t
limit
=
0x3ff0
;
asm
volatile
(
YUVTORGB_SETUP
"
dup
v22
.
8h
%
w
[
limit
]
\
n
"
"
movi
v23
.
8h
#
0xc0
lsl
#
8
\
n
"
"
ldr
q2
[
%
[
kIndices
]
]
\
n
"
"
1
:
\
n
"
READYUVP210
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
STOREAR30
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_uv
]
"
+
r
"
(
src_uv
)
[
dst_ar30
]
"
+
r
"
(
dst_ar30
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
uv_coeff
)
[
kRGBCoeffBias
]
"
r
"
(
rgb_coeff
)
[
limit
]
"
r
"
(
limit
)
[
kIndices
]
"
r
"
(
kP210LoadShuffleIndices
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v22
"
"
v23
"
)
;
}
void
P410ToAR30Row_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_uv
uint8_t
*
dst_ar30
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
const
uvec8
*
uv_coeff
=
&
yuvconstants
-
>
kUVCoeff
;
const
vec16
*
rgb_coeff
=
&
yuvconstants
-
>
kRGBCoeffBias
;
uint16_t
limit
=
0x3ff0
;
asm
volatile
(
YUVTORGB_SETUP
"
dup
v22
.
8h
%
w
[
limit
]
\
n
"
"
movi
v23
.
8h
#
0xc0
lsl
#
8
\
n
"
"
ldr
q2
[
%
[
kIndices
]
]
\
n
"
"
1
:
\
n
"
READYUVP410
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
STOREAR30
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_uv
]
"
+
r
"
(
src_uv
)
[
dst_ar30
]
"
+
r
"
(
dst_ar30
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
uv_coeff
)
[
kRGBCoeffBias
]
"
r
"
(
rgb_coeff
)
[
limit
]
"
r
"
(
limit
)
[
kIndices
]
"
r
"
(
kP410LoadShuffleIndices
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v22
"
"
v23
"
)
;
}
void
I422ToAR30Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_ar30
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
const
uvec8
*
uv_coeff
=
&
yuvconstants
-
>
kUVCoeff
;
const
vec16
*
rgb_coeff
=
&
yuvconstants
-
>
kRGBCoeffBias
;
const
uint16_t
limit
=
0x3ff0
;
asm
volatile
(
YUVTORGB_SETUP
"
dup
v22
.
8h
%
w
[
limit
]
\
n
"
"
movi
v23
.
8h
#
0xc0
lsl
#
8
\
n
"
"
1
:
\
n
"
READYUV422
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
I4XXTORGB
STOREAR30
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_ar30
]
"
+
r
"
(
dst_ar30
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
uv_coeff
)
[
kRGBCoeffBias
]
"
r
"
(
rgb_coeff
)
[
limit
]
"
r
"
(
limit
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v22
"
"
v23
"
)
;
}
void
I444AlphaToARGBRow_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
const
uint8_t
*
src_a
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
1
:
\
n
"
"
ld1
{
v19
.
8b
}
[
%
[
src_a
]
]
#
8
\
n
"
READYUV444
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
"
prfm
pldl1keep
[
%
[
src_a
]
448
]
\
n
"
I4XXTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
src_a
]
"
+
r
"
(
src_a
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
I410AlphaToARGBRow_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_u
const
uint16_t
*
src_v
const
uint16_t
*
src_a
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
1
:
\
n
"
"
ld1
{
v19
.
16b
}
[
%
[
src_a
]
]
#
16
\
n
"
READYUV410
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
"
uqshrn
v19
.
8b
v19
.
8h
#
2
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
src_a
]
"
+
r
"
(
src_a
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
I210AlphaToARGBRow_NEON
(
const
uint16_t
*
src_y
const
uint16_t
*
src_u
const
uint16_t
*
src_v
const
uint16_t
*
src_a
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
1
:
\
n
"
"
ld1
{
v19
.
16b
}
[
%
[
src_a
]
]
#
16
\
n
"
READYUV210
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
"
uqshrn
v19
.
8b
v19
.
8h
#
2
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
src_a
]
"
+
r
"
(
src_a
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
I422AlphaToARGBRow_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
const
uint8_t
*
src_a
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
1
:
\
n
"
"
ld1
{
v19
.
8b
}
[
%
[
src_a
]
]
#
8
\
n
"
READYUV422
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
"
prfm
pldl1keep
[
%
[
src_a
]
448
]
\
n
"
I4XXTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
src_a
]
"
+
r
"
(
src_a
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
I422ToRGBARow_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_rgba
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v15
.
8b
#
255
\
n
"
"
1
:
\
n
"
READYUV422
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
I4XXTORGB
RGBTORGB8
"
st4
{
v15
.
8b
v16
.
8b
v17
.
8b
v18
.
8b
}
[
%
[
dst_rgba
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_rgba
]
"
+
r
"
(
dst_rgba
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v15
"
)
;
}
void
I422ToRGB24Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_rgb24
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
1
:
\
n
"
READYUV422
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
I4XXTORGB
RGBTORGB8
"
st3
{
v16
.
8b
v17
.
8b
v18
.
8b
}
[
%
[
dst_rgb24
]
]
#
24
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_rgb24
]
"
+
r
"
(
dst_rgb24
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
)
;
}
#
define
ARGBTORGB565
\
"
shll
v18
.
8h
v18
.
8b
#
8
\
n
"
/
*
rrrrrrxx00000000
*
/
\
"
shll
v17
.
8h
v17
.
8b
#
8
\
n
"
/
*
gggggxxx00000000
*
/
\
"
shll
v16
.
8h
v16
.
8b
#
8
\
n
"
/
*
bbbbbbxx00000000
*
/
\
"
sri
v18
.
8h
v17
.
8h
#
5
\
n
"
/
*
rrrrrgggggg00000
*
/
\
"
sri
v18
.
8h
v16
.
8h
#
11
\
n
"
/
*
rrrrrggggggbbbbb
*
/
#
define
ARGBTORGB565_FROM_TOP
\
"
sri
v18
.
8h
v17
.
8h
#
5
\
n
"
/
*
rrrrrgggggg00000
*
/
\
"
sri
v18
.
8h
v16
.
8h
#
11
\
n
"
/
*
rrrrrggggggbbbbb
*
/
void
I422ToRGB565Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_rgb565
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
1
:
\
n
"
READYUV422
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
I4XXTORGB
RGBTORGB8_TOP
ARGBTORGB565_FROM_TOP
"
st1
{
v18
.
8h
}
[
%
[
dst_rgb565
]
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_rgb565
]
"
+
r
"
(
dst_rgb565
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
)
;
}
#
define
ARGBTOARGB1555
\
"
shl
v1
.
8h
v16
.
8h
#
8
\
n
"
/
*
bbbbbxxx00000000
*
/
\
"
shl
v2
.
8h
v17
.
8h
#
8
\
n
"
/
*
rrrrrxxx00000000
*
/
\
"
sri
v17
.
8h
v2
.
8h
#
1
\
n
"
/
*
arrrrrxxxrrrrxxx
*
/
\
"
sri
v17
.
8h
v16
.
8h
#
6
\
n
"
/
*
arrrrrgggggxxxbb
*
/
\
"
sri
v17
.
8h
v1
.
8h
#
11
\
n
"
/
*
arrrrrgggggbbbbb
*
/
#
define
ARGBTOARGB1555_FROM_TOP
\
"
sri
v19
.
8h
v18
.
8h
#
1
\
n
"
/
*
arrrrrxxxxxxxxxx
*
/
\
"
sri
v19
.
8h
v17
.
8h
#
6
\
n
"
/
*
arrrrrgggggxxxxx
*
/
\
"
sri
v19
.
8h
v16
.
8h
#
11
\
n
"
/
*
arrrrrgggggbbbbb
*
/
void
I422ToARGB1555Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_argb1555
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8h
#
0x80
lsl
#
8
\
n
"
"
1
:
\
n
"
READYUV422
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
I4XXTORGB
RGBTORGB8_TOP
ARGBTOARGB1555_FROM_TOP
"
st1
{
v19
.
8h
}
[
%
[
dst_argb1555
]
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_argb1555
]
"
+
r
"
(
dst_argb1555
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
#
define
ARGBTOARGB4444
\
"
sri
v17
.
8b
v16
.
8b
#
4
\
n
"
/
*
BG
*
/
\
"
sri
v19
.
8b
v18
.
8b
#
4
\
n
"
/
*
RA
*
/
\
"
zip1
v0
.
16b
v17
.
16b
v19
.
16b
\
n
"
/
*
BGRA
*
/
void
I422ToARGB4444Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_argb4444
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
1
:
\
n
"
READYUV422
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
I4XXTORGB
RGBTORGB8
"
movi
v19
.
8b
#
255
\
n
"
ARGBTOARGB4444
"
st1
{
v0
.
8h
}
[
%
[
dst_argb4444
]
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_u
]
"
+
r
"
(
src_u
)
[
src_v
]
"
+
r
"
(
src_v
)
[
dst_argb4444
]
"
+
r
"
(
dst_argb4444
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
void
I400ToARGBRow_NEON
(
const
uint8_t
*
src_y
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v1
.
16b
#
128
\
n
"
"
movi
v19
.
8b
#
255
\
n
"
"
umull
v6
.
8h
v1
.
8b
v30
.
8b
\
n
"
"
umlal2
v6
.
8h
v1
.
16b
v31
.
16b
\
n
"
"
umull
v4
.
8h
v1
.
8b
v28
.
8b
\
n
"
"
umull2
v5
.
8h
v1
.
16b
v29
.
16b
\
n
"
"
1
:
\
n
"
READYUV400
I400TORGB
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v19
"
)
;
}
#
if
defined
(
LIBYUV_USE_ST4
)
void
J400ToARGBRow_NEON
(
const
uint8_t
*
src_y
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v23
.
8b
#
255
\
n
"
"
1
:
\
n
"
"
ld1
{
v20
.
8b
}
[
%
0
]
#
8
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mov
v21
.
8b
v20
.
8b
\
n
"
"
mov
v22
.
8b
v20
.
8b
\
n
"
"
st4
{
v20
.
8b
v21
.
8b
v22
.
8b
v23
.
8b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
)
;
}
#
else
void
J400ToARGBRow_NEON
(
const
uint8_t
*
src_y
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v20
.
8b
#
255
\
n
"
"
1
:
\
n
"
"
ldr
d16
[
%
0
]
#
8
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
zip1
v18
.
16b
v16
.
16b
v16
.
16b
\
n
"
"
zip1
v19
.
16b
v16
.
16b
v20
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
zip1
v16
.
16b
v18
.
16b
v19
.
16b
\
n
"
"
zip2
v17
.
16b
v18
.
16b
v19
.
16b
\
n
"
"
stp
q16
q17
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
"
v20
"
)
;
}
#
endif
void
NV12ToARGBRow_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_uv
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
ldr
q2
[
%
[
kNV12Table
]
]
\
n
"
"
1
:
\
n
"
READNV12
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_uv
]
"
+
r
"
(
src_uv
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
[
kNV12Table
]
"
r
"
(
&
kNV12Table
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v2
"
"
v19
"
)
;
}
void
NV21ToARGBRow_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_vu
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
ldr
q2
[
%
[
kNV12Table
]
]
\
n
"
"
1
:
\
n
"
READNV12
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_uv
]
"
+
r
"
(
src_vu
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
[
kNV12Table
]
"
r
"
(
&
kNV21Table
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v2
"
"
v19
"
)
;
}
void
NV12ToRGB24Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_uv
uint8_t
*
dst_rgb24
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
ldr
q2
[
%
[
kNV12Table
]
]
\
n
"
"
1
:
\
n
"
READNV12
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st3
{
v16
.
8b
v17
.
8b
v18
.
8b
}
[
%
[
dst_rgb24
]
]
#
24
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_uv
]
"
+
r
"
(
src_uv
)
[
dst_rgb24
]
"
+
r
"
(
dst_rgb24
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
[
kNV12Table
]
"
r
"
(
&
kNV12Table
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v2
"
)
;
}
void
NV21ToRGB24Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_vu
uint8_t
*
dst_rgb24
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
ldr
q2
[
%
[
kNV12Table
]
]
\
n
"
"
1
:
\
n
"
READNV12
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st3
{
v16
.
8b
v17
.
8b
v18
.
8b
}
[
%
[
dst_rgb24
]
]
#
24
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_uv
]
"
+
r
"
(
src_vu
)
[
dst_rgb24
]
"
+
r
"
(
dst_rgb24
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
[
kNV12Table
]
"
r
"
(
&
kNV21Table
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v2
"
)
;
}
void
NV12ToRGB565Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_uv
uint8_t
*
dst_rgb565
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
ldr
q2
[
%
[
kNV12Table
]
]
\
n
"
"
1
:
\
n
"
READNV12
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8_TOP
ARGBTORGB565_FROM_TOP
"
st1
{
v18
.
8h
}
[
%
[
dst_rgb565
]
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_y
]
"
+
r
"
(
src_y
)
[
src_uv
]
"
+
r
"
(
src_uv
)
[
dst_rgb565
]
"
+
r
"
(
dst_rgb565
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
[
kNV12Table
]
"
r
"
(
&
kNV12Table
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v2
"
)
;
}
void
YUY2ToARGBRow_NEON
(
const
uint8_t
*
src_yuy2
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
ldr
q2
[
%
[
kNV21InterleavedTable
]
]
\
n
"
"
1
:
\
n
"
READYUY2
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_yuy2
]
"
+
r
"
(
src_yuy2
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
[
kNV21InterleavedTable
]
"
r
"
(
&
kNV21InterleavedTable
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v2
"
"
v19
"
)
;
}
void
UYVYToARGBRow_NEON
(
const
uint8_t
*
src_uyvy
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
asm
volatile
(
YUVTORGB_SETUP
"
movi
v19
.
8b
#
255
\
n
"
"
ldr
q2
[
%
[
kNV12InterleavedTable
]
]
\
n
"
"
1
:
\
n
"
READUYVY
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
NVTORGB
RGBTORGB8
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
[
dst_argb
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_uyvy
]
"
+
r
"
(
src_uyvy
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
kUVCoeff
]
"
r
"
(
&
yuvconstants
-
>
kUVCoeff
)
[
kRGBCoeffBias
]
"
r
"
(
&
yuvconstants
-
>
kRGBCoeffBias
)
[
kNV12InterleavedTable
]
"
r
"
(
&
kNV12InterleavedTable
)
:
"
cc
"
"
memory
"
YUVTORGB_REGS
"
v2
"
"
v19
"
)
;
}
void
SplitUVRow_NEON
(
const
uint8_t
*
src_uv
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld2
{
v0
.
16b
v1
.
16b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v0
.
16b
}
[
%
1
]
#
16
\
n
"
"
st1
{
v1
.
16b
}
[
%
2
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_uv
)
"
+
r
"
(
dst_u
)
"
+
r
"
(
dst_v
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
)
;
}
void
DetileRow_NEON
(
const
uint8_t
*
src
ptrdiff_t
src_tile_stride
uint8_t
*
dst
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
%
3
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
1792
]
\
n
"
"
st1
{
v0
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
"
+
r
"
(
dst
)
"
+
r
"
(
width
)
:
"
r
"
(
src_tile_stride
)
:
"
cc
"
"
memory
"
"
v0
"
)
;
}
void
DetileRow_16_NEON
(
const
uint16_t
*
src
ptrdiff_t
src_tile_stride
uint16_t
*
dst
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
8h
v1
.
8h
}
[
%
0
]
%
3
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
3584
]
\
n
"
"
st1
{
v0
.
8h
v1
.
8h
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
"
+
r
"
(
dst
)
"
+
r
"
(
width
)
:
"
r
"
(
src_tile_stride
*
2
)
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
)
;
}
void
DetileSplitUVRow_NEON
(
const
uint8_t
*
src_uv
ptrdiff_t
src_tile_stride
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld2
{
v0
.
8b
v1
.
8b
}
[
%
0
]
%
4
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
1792
]
\
n
"
"
st1
{
v0
.
8b
}
[
%
1
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
2
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_uv
)
"
+
r
"
(
dst_u
)
"
+
r
"
(
dst_v
)
"
+
r
"
(
width
)
:
"
r
"
(
src_tile_stride
)
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
)
;
}
#
if
defined
(
LIBYUV_USE_ST2
)
void
DetileToYUY2_NEON
(
const
uint8_t
*
src_y
ptrdiff_t
src_y_tile_stride
const
uint8_t
*
src_uv
ptrdiff_t
src_uv_tile_stride
uint8_t
*
dst_yuy2
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
%
4
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
1792
]
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
%
5
\
n
"
"
prfm
pldl1keep
[
%
1
1792
]
\
n
"
"
st2
{
v0
.
16b
v1
.
16b
}
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
src_uv
)
/
/
%
1
"
+
r
"
(
dst_yuy2
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
"
r
"
(
src_y_tile_stride
)
/
/
%
4
"
r
"
(
src_uv_tile_stride
)
/
/
%
5
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
/
/
Clobber
list
)
;
}
#
else
void
DetileToYUY2_NEON
(
const
uint8_t
*
src_y
ptrdiff_t
src_y_tile_stride
const
uint8_t
*
src_uv
ptrdiff_t
src_uv_tile_stride
uint8_t
*
dst_yuy2
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
%
4
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
%
5
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
1792
]
\
n
"
"
zip1
v2
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
1792
]
\
n
"
"
zip2
v3
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
st1
{
v2
.
16b
v3
.
16b
}
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
src_uv
)
/
/
%
1
"
+
r
"
(
dst_yuy2
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
"
r
"
(
src_y_tile_stride
)
/
/
%
4
"
r
"
(
src_uv_tile_stride
)
/
/
%
5
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
/
/
Clobber
list
)
;
}
#
endif
void
UnpackMT2T_NEON
(
const
uint8_t
*
src
uint16_t
*
dst
size_t
size
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v7
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v0
.
16b
-
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
2
%
2
#
80
\
n
"
"
shl
v4
.
16b
v7
.
16b
#
6
\
n
"
"
shl
v5
.
16b
v7
.
16b
#
4
\
n
"
"
shl
v6
.
16b
v7
.
16b
#
2
\
n
"
"
zip1
v16
.
16b
v4
.
16b
v0
.
16b
\
n
"
"
zip1
v18
.
16b
v5
.
16b
v1
.
16b
\
n
"
"
zip1
v20
.
16b
v6
.
16b
v2
.
16b
\
n
"
"
zip1
v22
.
16b
v7
.
16b
v3
.
16b
\
n
"
"
zip2
v17
.
16b
v4
.
16b
v0
.
16b
\
n
"
"
zip2
v19
.
16b
v5
.
16b
v1
.
16b
\
n
"
"
zip2
v21
.
16b
v6
.
16b
v2
.
16b
\
n
"
"
zip2
v23
.
16b
v7
.
16b
v3
.
16b
\
n
"
"
sri
v16
.
8h
v16
.
8h
#
10
\
n
"
"
sri
v17
.
8h
v17
.
8h
#
10
\
n
"
"
sri
v18
.
8h
v18
.
8h
#
10
\
n
"
"
sri
v19
.
8h
v19
.
8h
#
10
\
n
"
"
st1
{
v16
.
8h
-
v19
.
8h
}
[
%
1
]
#
64
\
n
"
"
sri
v20
.
8h
v20
.
8h
#
10
\
n
"
"
sri
v21
.
8h
v21
.
8h
#
10
\
n
"
"
sri
v22
.
8h
v22
.
8h
#
10
\
n
"
"
sri
v23
.
8h
v23
.
8h
#
10
\
n
"
"
st1
{
v20
.
8h
-
v23
.
8h
}
[
%
1
]
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
size
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
w0
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
)
;
}
#
if
defined
(
LIBYUV_USE_ST2
)
void
MergeUVRow_NEON
(
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_uv
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
st2
{
v0
.
16b
v1
.
16b
}
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_u
)
/
/
%
0
"
+
r
"
(
src_v
)
/
/
%
1
"
+
r
"
(
dst_uv
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
/
/
Output
registers
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
/
/
Clobber
List
)
;
}
void
MergeUVRow_16_NEON
(
const
uint16_t
*
src_u
const
uint16_t
*
src_v
uint16_t
*
dst_uv
int
depth
int
width
)
{
int
shift
=
16
-
depth
;
asm
volatile
(
"
dup
v2
.
8h
%
w4
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
8h
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v1
.
8h
}
[
%
1
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v2
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
ushl
v1
.
8h
v1
.
8h
v2
.
8h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
st2
{
v0
.
8h
v1
.
8h
}
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_u
)
/
/
%
0
"
+
r
"
(
src_v
)
/
/
%
1
"
+
r
"
(
dst_uv
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
"
r
"
(
shift
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
)
;
}
#
else
void
MergeUVRow_NEON
(
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_uv
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
zip1
v2
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
zip2
v3
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
st1
{
v2
.
16b
v3
.
16b
}
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_u
)
/
/
%
0
"
+
r
"
(
src_v
)
/
/
%
1
"
+
r
"
(
dst_uv
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
/
/
Output
registers
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
/
/
Clobber
List
)
;
}
void
MergeUVRow_16_NEON
(
const
uint16_t
*
src_u
const
uint16_t
*
src_v
uint16_t
*
dst_uv
int
depth
int
width
)
{
int
shift
=
16
-
depth
;
asm
volatile
(
"
dup
v4
.
8h
%
w4
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
8h
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v1
.
8h
}
[
%
1
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v4
.
8h
\
n
"
"
ushl
v1
.
8h
v1
.
8h
v4
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
zip1
v2
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
zip2
v3
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
st1
{
v2
.
8h
v3
.
8h
}
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_u
)
/
/
%
0
"
+
r
"
(
src_v
)
/
/
%
1
"
+
r
"
(
dst_uv
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
"
r
"
(
shift
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
#
endif
void
SplitRGBRow_NEON
(
const
uint8_t
*
src_rgb
uint8_t
*
dst_r
uint8_t
*
dst_g
uint8_t
*
dst_b
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
0
]
#
48
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v0
.
16b
}
[
%
1
]
#
16
\
n
"
"
st1
{
v1
.
16b
}
[
%
2
]
#
16
\
n
"
"
st1
{
v2
.
16b
}
[
%
3
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgb
)
/
/
%
0
"
+
r
"
(
dst_r
)
/
/
%
1
"
+
r
"
(
dst_g
)
/
/
%
2
"
+
r
"
(
dst_b
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
/
/
Clobber
List
)
;
}
void
MergeRGBRow_NEON
(
const
uint8_t
*
src_r
const
uint8_t
*
src_g
const
uint8_t
*
src_b
uint8_t
*
dst_rgb
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v2
.
16b
}
[
%
2
]
#
16
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
st3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
3
]
#
48
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_r
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_b
)
/
/
%
2
"
+
r
"
(
dst_rgb
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
/
/
Clobber
List
)
;
}
void
SplitARGBRow_NEON
(
const
uint8_t
*
src_rgba
uint8_t
*
dst_r
uint8_t
*
dst_g
uint8_t
*
dst_b
uint8_t
*
dst_a
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w5
%
w5
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v0
.
16b
}
[
%
3
]
#
16
\
n
"
"
st1
{
v1
.
16b
}
[
%
2
]
#
16
\
n
"
"
st1
{
v2
.
16b
}
[
%
1
]
#
16
\
n
"
"
st1
{
v3
.
16b
}
[
%
4
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgba
)
/
/
%
0
"
+
r
"
(
dst_r
)
/
/
%
1
"
+
r
"
(
dst_g
)
/
/
%
2
"
+
r
"
(
dst_b
)
/
/
%
3
"
+
r
"
(
dst_a
)
/
/
%
4
"
+
r
"
(
width
)
/
/
%
5
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
/
/
Clobber
List
)
;
}
#
if
defined
(
LIBYUV_USE_ST4
)
void
MergeARGBRow_NEON
(
const
uint8_t
*
src_r
const
uint8_t
*
src_g
const
uint8_t
*
src_b
const
uint8_t
*
src_a
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
2
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v2
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v3
.
16b
}
[
%
3
]
#
16
\
n
"
"
subs
%
w5
%
w5
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
prfm
pldl1keep
[
%
3
448
]
\
n
"
"
st4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
4
]
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_r
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_b
)
/
/
%
2
"
+
r
"
(
src_a
)
/
/
%
3
"
+
r
"
(
dst_argb
)
/
/
%
4
"
+
r
"
(
width
)
/
/
%
5
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
/
/
Clobber
List
)
;
}
#
else
void
MergeARGBRow_NEON
(
const
uint8_t
*
src_r
const
uint8_t
*
src_g
const
uint8_t
*
src_b
const
uint8_t
*
src_a
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
2
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v2
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v3
.
16b
}
[
%
3
]
#
16
\
n
"
"
subs
%
w5
%
w5
#
16
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
zip1
v4
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
zip1
v5
.
16b
v2
.
16b
v3
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
zip2
v6
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
zip2
v7
.
16b
v2
.
16b
v3
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
zip1
v0
.
8h
v4
.
8h
v5
.
8h
\
n
"
"
zip2
v1
.
8h
v4
.
8h
v5
.
8h
\
n
"
"
prfm
pldl1keep
[
%
3
448
]
\
n
"
"
zip1
v2
.
8h
v6
.
8h
v7
.
8h
\
n
"
"
zip2
v3
.
8h
v6
.
8h
v7
.
8h
\
n
"
"
st1
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
4
]
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_r
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_b
)
/
/
%
2
"
+
r
"
(
src_a
)
/
/
%
3
"
+
r
"
(
dst_argb
)
/
/
%
4
"
+
r
"
(
width
)
/
/
%
5
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
/
/
Clobber
List
)
;
}
#
endif
void
SplitXRGBRow_NEON
(
const
uint8_t
*
src_rgba
uint8_t
*
dst_r
uint8_t
*
dst_g
uint8_t
*
dst_b
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v0
.
16b
}
[
%
3
]
#
16
\
n
"
"
st1
{
v1
.
16b
}
[
%
2
]
#
16
\
n
"
"
st1
{
v2
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgba
)
/
/
%
0
"
+
r
"
(
dst_r
)
/
/
%
1
"
+
r
"
(
dst_g
)
/
/
%
2
"
+
r
"
(
dst_b
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
/
/
Clobber
List
)
;
}
void
MergeXRGBRow_NEON
(
const
uint8_t
*
src_r
const
uint8_t
*
src_g
const
uint8_t
*
src_b
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v3
.
16b
#
255
\
n
"
"
1
:
\
n
"
"
ld1
{
v2
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v0
.
16b
}
[
%
2
]
#
16
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
st4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
3
]
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_r
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_b
)
/
/
%
2
"
+
r
"
(
dst_argb
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
/
/
Clobber
List
)
;
}
void
MergeXR30Row_NEON
(
const
uint16_t
*
src_r
const
uint16_t
*
src_g
const
uint16_t
*
src_b
uint8_t
*
dst_ar30
int
depth
int
width
)
{
int
shift
=
10
-
depth
;
asm
volatile
(
"
movi
v30
.
16b
#
255
\
n
"
"
ushr
v30
.
4s
v30
.
4s
#
22
\
n
"
"
dup
v31
.
4s
%
w5
\
n
"
"
1
:
\
n
"
"
ldr
d2
[
%
2
]
#
8
\
n
"
"
ldr
d1
[
%
1
]
#
8
\
n
"
"
ldr
d0
[
%
0
]
#
8
\
n
"
"
subs
%
w4
%
w4
#
4
\
n
"
"
ushll
v2
.
4s
v2
.
4h
#
0
\
n
"
"
ushll
v1
.
4s
v1
.
4h
#
0
\
n
"
"
ushll
v0
.
4s
v0
.
4h
#
0
\
n
"
"
ushl
v2
.
4s
v2
.
4s
v31
.
4s
\
n
"
"
ushl
v1
.
4s
v1
.
4s
v31
.
4s
\
n
"
"
ushl
v0
.
4s
v0
.
4s
v31
.
4s
\
n
"
"
umin
v2
.
4s
v2
.
4s
v30
.
4s
\
n
"
"
umin
v1
.
4s
v1
.
4s
v30
.
4s
\
n
"
"
umin
v0
.
4s
v0
.
4s
v30
.
4s
\
n
"
"
sli
v2
.
4s
v1
.
4s
#
10
\
n
"
"
sli
v2
.
4s
v0
.
4s
#
20
\
n
"
"
orr
v2
.
4s
#
0xc0
lsl
#
24
\
n
"
"
str
q2
[
%
3
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_r
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_b
)
/
/
%
2
"
+
r
"
(
dst_ar30
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
"
r
"
(
shift
)
/
/
%
5
:
"
memory
"
"
cc
"
"
v0
"
"
v1
"
"
v2
"
"
v30
"
"
v31
"
)
;
}
void
MergeXR30Row_10_NEON
(
const
uint16_t
*
src_r
const
uint16_t
*
src_g
const
uint16_t
*
src_b
uint8_t
*
dst_ar30
int
int
width
)
{
int
limit
=
1023
;
asm
volatile
(
"
dup
v5
.
8h
%
w
[
limit
]
\
n
"
"
movi
v6
.
8h
#
16
\
n
"
"
movi
v7
.
8h
#
4
lsl
#
8
\
n
"
"
1
:
\
n
"
"
ldr
q0
[
%
0
]
#
16
\
n
"
"
ldr
q1
[
%
1
]
#
16
\
n
"
"
ldr
q2
[
%
2
]
#
16
\
n
"
"
subs
%
w4
%
w4
#
8
\
n
"
"
umin
v0
.
8h
v0
.
8h
v5
.
8h
\
n
"
"
umin
v1
.
8h
v1
.
8h
v5
.
8h
\
n
"
"
movi
v4
.
8h
#
0xc0
lsl
#
8
\
n
"
"
umin
v3
.
8h
v2
.
8h
v5
.
8h
\
n
"
"
mla
v4
.
8h
v0
.
8h
v6
.
8h
\
n
"
"
mla
v3
.
8h
v1
.
8h
v7
.
8h
\
n
"
"
usra
v4
.
8h
v1
.
8h
#
6
\
n
"
"
st2
{
v3
.
8h
v4
.
8h
}
[
%
3
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_r
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_b
)
/
/
%
2
"
+
r
"
(
dst_ar30
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
[
limit
]
"
r
"
(
limit
)
:
"
memory
"
"
cc
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
void
MergeAR64Row_NEON
(
const
uint16_t
*
src_r
const
uint16_t
*
src_g
const
uint16_t
*
src_b
const
uint16_t
*
src_a
uint16_t
*
dst_ar64
int
depth
int
width
)
{
int
shift
=
16
-
depth
;
int
mask
=
(
1
<
<
depth
)
-
1
;
asm
volatile
(
"
dup
v30
.
8h
%
w7
\
n
"
"
dup
v31
.
8h
%
w6
\
n
"
"
1
:
\
n
"
"
ldr
q2
[
%
0
]
#
16
\
n
"
"
ldr
q1
[
%
1
]
#
16
\
n
"
"
ldr
q0
[
%
2
]
#
16
\
n
"
"
ldr
q3
[
%
3
]
#
16
\
n
"
"
subs
%
w5
%
w5
#
8
\
n
"
"
umin
v2
.
8h
v2
.
8h
v30
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umin
v1
.
8h
v1
.
8h
v30
.
8h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
umin
v0
.
8h
v0
.
8h
v30
.
8h
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
umin
v3
.
8h
v3
.
8h
v30
.
8h
\
n
"
"
prfm
pldl1keep
[
%
3
448
]
\
n
"
"
ushl
v2
.
8h
v2
.
8h
v31
.
8h
\
n
"
"
ushl
v1
.
8h
v1
.
8h
v31
.
8h
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v31
.
8h
\
n
"
"
ushl
v3
.
8h
v3
.
8h
v31
.
8h
\
n
"
"
st4
{
v0
.
8h
v1
.
8h
v2
.
8h
v3
.
8h
}
[
%
4
]
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_r
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_b
)
/
/
%
2
"
+
r
"
(
src_a
)
/
/
%
3
"
+
r
"
(
dst_ar64
)
/
/
%
4
"
+
r
"
(
width
)
/
/
%
5
:
"
r
"
(
shift
)
/
/
%
6
"
r
"
(
mask
)
/
/
%
7
:
"
memory
"
"
cc
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v31
"
)
;
}
void
MergeXR64Row_NEON
(
const
uint16_t
*
src_r
const
uint16_t
*
src_g
const
uint16_t
*
src_b
uint16_t
*
dst_ar64
int
depth
int
width
)
{
int
shift
=
16
-
depth
;
int
mask
=
(
1
<
<
depth
)
-
1
;
asm
volatile
(
"
movi
v3
.
16b
#
0xff
\
n
"
"
dup
v30
.
8h
%
w6
\
n
"
"
dup
v31
.
8h
%
w5
\
n
"
"
1
:
\
n
"
"
ldr
q2
[
%
0
]
#
16
\
n
"
"
ldr
q1
[
%
1
]
#
16
\
n
"
"
ldr
q0
[
%
2
]
#
16
\
n
"
"
subs
%
w4
%
w4
#
8
\
n
"
"
umin
v2
.
8h
v2
.
8h
v30
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umin
v1
.
8h
v1
.
8h
v30
.
8h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
umin
v0
.
8h
v0
.
8h
v30
.
8h
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
ushl
v2
.
8h
v2
.
8h
v31
.
8h
\
n
"
"
ushl
v1
.
8h
v1
.
8h
v31
.
8h
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v31
.
8h
\
n
"
"
st4
{
v0
.
8h
v1
.
8h
v2
.
8h
v3
.
8h
}
[
%
3
]
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_r
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_b
)
/
/
%
2
"
+
r
"
(
dst_ar64
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
"
r
"
(
shift
)
/
/
%
5
"
r
"
(
mask
)
/
/
%
6
:
"
memory
"
"
cc
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v31
"
)
;
}
void
MergeARGB16To8Row_NEON
(
const
uint16_t
*
src_r
const
uint16_t
*
src_g
const
uint16_t
*
src_b
const
uint16_t
*
src_a
uint8_t
*
dst_argb
int
depth
int
width
)
{
int
shift
=
16
-
depth
;
asm
volatile
(
"
dup
v31
.
8h
%
w6
\
n
"
"
1
:
\
n
"
"
ldr
q0
[
%
0
]
#
16
\
n
"
"
ldr
q1
[
%
1
]
#
16
\
n
"
"
ldr
q2
[
%
2
]
#
16
\
n
"
"
ldr
q3
[
%
3
]
#
16
\
n
"
"
subs
%
w5
%
w5
#
8
\
n
"
"
uqshl
v0
.
8h
v0
.
8h
v31
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uqshl
v1
.
8h
v1
.
8h
v31
.
8h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uqshl
v2
.
8h
v2
.
8h
v31
.
8h
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
uqshl
v3
.
8h
v3
.
8h
v31
.
8h
\
n
"
"
prfm
pldl1keep
[
%
3
448
]
\
n
"
"
trn2
v0
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
trn2
v1
.
16b
v2
.
16b
v3
.
16b
\
n
"
"
st2
{
v0
.
8h
v1
.
8h
}
[
%
4
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_b
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_r
)
/
/
%
2
"
+
r
"
(
src_a
)
/
/
%
3
"
+
r
"
(
dst_argb
)
/
/
%
4
"
+
r
"
(
width
)
/
/
%
5
:
"
r
"
(
shift
)
/
/
%
6
:
"
memory
"
"
cc
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v31
"
)
;
}
void
MergeXRGB16To8Row_NEON
(
const
uint16_t
*
src_r
const
uint16_t
*
src_g
const
uint16_t
*
src_b
uint8_t
*
dst_argb
int
depth
int
width
)
{
int
shift
=
16
-
depth
;
asm
volatile
(
"
dup
v31
.
8h
%
w5
\
n
"
"
movi
v3
.
16b
#
0xff
\
n
"
"
1
:
\
n
"
"
ldr
q0
[
%
0
]
#
16
\
n
"
"
ldr
q1
[
%
1
]
#
16
\
n
"
"
ldr
q2
[
%
2
]
#
16
\
n
"
"
subs
%
w4
%
w4
#
8
\
n
"
"
uqshl
v0
.
8h
v0
.
8h
v31
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uqshl
v1
.
8h
v1
.
8h
v31
.
8h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uqshl
v2
.
8h
v2
.
8h
v31
.
8h
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
trn2
v0
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
trn2
v1
.
16b
v2
.
16b
v3
.
16b
\
n
"
"
st2
{
v0
.
8h
v1
.
8h
}
[
%
3
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_b
)
/
/
%
0
"
+
r
"
(
src_g
)
/
/
%
1
"
+
r
"
(
src_r
)
/
/
%
2
"
+
r
"
(
dst_argb
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
"
r
"
(
shift
)
/
/
%
5
:
"
memory
"
"
cc
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v31
"
)
;
}
void
CopyRow_NEON
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
subs
%
w2
%
w2
#
32
\
n
"
"
stp
q0
q1
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
"
+
r
"
(
dst
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
)
;
}
void
SetRow_NEON
(
uint8_t
*
dst
uint8_t
v8
int
width
)
{
asm
volatile
(
"
dup
v0
.
16b
%
w2
\
n
"
"
1
:
\
n
"
"
subs
%
w1
%
w1
#
16
\
n
"
"
st1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
dst
)
"
+
r
"
(
width
)
:
"
r
"
(
v8
)
:
"
cc
"
"
memory
"
"
v0
"
)
;
}
void
ARGBSetRow_NEON
(
uint8_t
*
dst
uint32_t
v32
int
width
)
{
asm
volatile
(
"
dup
v0
.
4s
%
w2
\
n
"
"
1
:
\
n
"
"
subs
%
w1
%
w1
#
4
\
n
"
"
st1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
dst
)
"
+
r
"
(
width
)
:
"
r
"
(
v32
)
:
"
cc
"
"
memory
"
"
v0
"
)
;
}
static
const
uvec8
kShuffleMirror
=
{
15u
14u
13u
12u
11u
10u
9u
8u
7u
6u
5u
4u
3u
2u
1u
0u
}
;
void
MirrorRow_NEON
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
asm
volatile
(
"
ld1
{
v3
.
16b
}
[
%
3
]
\
n
"
"
add
%
0
%
0
%
w2
sxtw
\
n
"
"
sub
%
0
%
0
#
32
\
n
"
"
1
:
\
n
"
"
ldr
q2
[
%
0
16
]
\
n
"
"
ldr
q1
[
%
0
]
-
32
\
n
"
"
subs
%
w2
%
w2
#
32
\
n
"
"
tbl
v0
.
16b
{
v2
.
16b
}
v3
.
16b
\
n
"
"
tbl
v1
.
16b
{
v1
.
16b
}
v3
.
16b
\
n
"
"
st1
{
v0
.
16b
v1
.
16b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
&
kShuffleMirror
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
static
const
uvec8
kShuffleMirrorUV
=
{
14u
15u
12u
13u
10u
11u
8u
9u
6u
7u
4u
5u
2u
3u
0u
1u
}
;
void
MirrorUVRow_NEON
(
const
uint8_t
*
src_uv
uint8_t
*
dst_uv
int
width
)
{
asm
volatile
(
"
ld1
{
v4
.
16b
}
[
%
3
]
\
n
"
"
add
%
0
%
0
%
w2
sxtw
#
1
\
n
"
"
sub
%
0
%
0
#
32
\
n
"
"
1
:
\
n
"
"
ldr
q1
[
%
0
16
]
\
n
"
"
ldr
q0
[
%
0
]
-
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
tbl
v2
.
16b
{
v1
.
16b
}
v4
.
16b
\
n
"
"
tbl
v3
.
16b
{
v0
.
16b
}
v4
.
16b
\
n
"
"
st1
{
v2
.
16b
v3
.
16b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_uv
)
/
/
%
0
"
+
r
"
(
dst_uv
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
&
kShuffleMirrorUV
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
void
MirrorSplitUVRow_NEON
(
const
uint8_t
*
src_uv
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
asm
volatile
(
"
ld1
{
v4
.
16b
}
[
%
4
]
\
n
"
"
add
%
0
%
0
%
w3
sxtw
#
1
\
n
"
"
sub
%
0
%
0
#
32
\
n
"
"
1
:
\
n
"
"
ldr
q1
[
%
0
16
]
\
n
"
"
ldr
q0
[
%
0
]
-
32
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
tbl
v2
.
16b
{
v1
.
16b
}
v4
.
16b
\
n
"
"
tbl
v3
.
16b
{
v0
.
16b
}
v4
.
16b
\
n
"
"
uzp1
v0
.
16b
v2
.
16b
v3
.
16b
\
n
"
"
uzp2
v1
.
16b
v2
.
16b
v3
.
16b
\
n
"
"
st1
{
v0
.
16b
}
[
%
1
]
#
16
\
n
"
"
st1
{
v1
.
16b
}
[
%
2
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_uv
)
/
/
%
0
"
+
r
"
(
dst_u
)
/
/
%
1
"
+
r
"
(
dst_v
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
"
r
"
(
&
kShuffleMirrorUV
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
static
const
uvec8
kShuffleMirrorARGB
=
{
12u
13u
14u
15u
8u
9u
10u
11u
4u
5u
6u
7u
0u
1u
2u
3u
}
;
void
ARGBMirrorRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
ld1
{
v4
.
16b
}
[
%
3
]
\
n
"
"
add
%
0
%
0
%
w2
sxtw
#
2
\
n
"
"
sub
%
0
%
0
#
32
\
n
"
"
1
:
\
n
"
"
ldr
q1
[
%
0
16
]
\
n
"
"
ldr
q0
[
%
0
]
-
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
tbl
v2
.
16b
{
v1
.
16b
}
v4
.
16b
\
n
"
"
tbl
v3
.
16b
{
v0
.
16b
}
v4
.
16b
\
n
"
"
st1
{
v2
.
16b
v3
.
16b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
&
kShuffleMirrorARGB
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
void
RGB24MirrorRow_NEON
(
const
uint8_t
*
src_rgb24
uint8_t
*
dst_rgb24
int
width
)
{
asm
volatile
(
"
ld1
{
v3
.
16b
}
[
%
4
]
\
n
"
"
add
%
0
%
0
%
w2
sxtw
#
1
\
n
"
"
add
%
0
%
0
%
w2
sxtw
\
n
"
"
sub
%
0
%
0
#
48
\
n
"
"
1
:
\
n
"
"
ld3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
0
]
%
3
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
tbl
v0
.
16b
{
v0
.
16b
}
v3
.
16b
\
n
"
"
tbl
v1
.
16b
{
v1
.
16b
}
v3
.
16b
\
n
"
"
tbl
v2
.
16b
{
v2
.
16b
}
v3
.
16b
\
n
"
"
st3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
1
]
#
48
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgb24
)
/
/
%
0
"
+
r
"
(
dst_rgb24
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
(
ptrdiff_t
)
-
48
)
/
/
%
3
"
r
"
(
&
kShuffleMirror
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
RGB24ToARGBRow_NEON
(
const
uint8_t
*
src_rgb24
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v4
.
8b
#
255
\
n
"
"
1
:
\
n
"
"
ld3
{
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
24
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st4
{
v1
.
8b
v2
.
8b
v3
.
8b
v4
.
8b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgb24
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
/
/
Clobber
List
)
;
}
void
RAWToARGBRow_NEON
(
const
uint8_t
*
src_raw
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v5
.
8b
#
255
\
n
"
"
1
:
\
n
"
"
ld3
{
v0
.
8b
v1
.
8b
v2
.
8b
}
[
%
0
]
#
24
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
mov
v3
.
8b
v1
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mov
v4
.
8b
v0
.
8b
\
n
"
"
st4
{
v2
.
8b
v3
.
8b
v4
.
8b
v5
.
8b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_raw
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
/
/
Clobber
List
)
;
}
void
RAWToRGBARow_NEON
(
const
uint8_t
*
src_raw
uint8_t
*
dst_rgba
int
width
)
{
asm
volatile
(
"
movi
v0
.
8b
#
255
\
n
"
"
1
:
\
n
"
"
ld3
{
v3
.
8b
v4
.
8b
v5
.
8b
}
[
%
0
]
#
24
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
mov
v2
.
8b
v4
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mov
v1
.
8b
v5
.
8b
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_raw
)
/
/
%
0
"
+
r
"
(
dst_rgba
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
/
/
Clobber
List
)
;
}
void
RAWToRGB24Row_NEON
(
const
uint8_t
*
src_raw
uint8_t
*
dst_rgb24
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld3
{
v0
.
8b
v1
.
8b
v2
.
8b
}
[
%
0
]
#
24
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
mov
v3
.
8b
v1
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mov
v4
.
8b
v0
.
8b
\
n
"
"
st3
{
v2
.
8b
v3
.
8b
v4
.
8b
}
[
%
1
]
#
24
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_raw
)
/
/
%
0
"
+
r
"
(
dst_rgb24
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
/
/
Clobber
List
)
;
}
#
define
RGB565TOARGB
\
"
shrn
v1
.
8b
v0
.
8h
#
3
\
n
"
/
*
G
GGGGGGxx
*
/
\
"
shrn2
v1
.
16b
v4
.
8h
#
3
\
n
"
/
*
G
GGGGGGxx
*
/
\
"
uzp2
v2
.
16b
v0
.
16b
v4
.
16b
\
n
"
/
*
R
RRRRRxxx
*
/
\
"
uzp1
v0
.
16b
v0
.
16b
v4
.
16b
\
n
"
/
*
B
xxxBBBBB
*
/
\
"
sri
v1
.
16b
v1
.
16b
#
6
\
n
"
/
*
G
GGGGGGGG
fill
2
*
/
\
"
shl
v0
.
16b
v0
.
16b
#
3
\
n
"
/
*
B
BBBBB000
*
/
\
"
sri
v2
.
16b
v2
.
16b
#
5
\
n
"
/
*
R
RRRRRRRR
fill
3
*
/
\
"
sri
v0
.
16b
v0
.
16b
#
5
\
n
"
/
*
R
BBBBBBBB
fill
3
*
/
void
RGB565ToARGBRow_NEON
(
const
uint8_t
*
src_rgb565
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v3
.
16b
#
255
\
n
"
"
1
:
\
n
"
"
ldp
q0
q4
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
RGB565TOARGB
"
st4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
1
]
\
n
"
"
add
%
1
%
1
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgb565
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v6
"
/
/
Clobber
List
)
;
}
#
define
ARGB1555TOARGB
\
"
shrn
v2
.
8b
v0
.
8h
#
7
\
n
"
/
*
RRRRRxxx
*
/
\
"
uzp1
v29
.
16b
v0
.
16b
v4
.
16b
\
n
"
/
*
xxxBBBBB
*
/
\
"
shrn
v1
.
8b
v0
.
8h
#
2
\
n
"
/
*
GGGGGxxx
*
/
\
"
uzp2
v3
.
16b
v0
.
16b
v4
.
16b
\
n
"
/
*
Axxxxxxx
*
/
\
"
shrn2
v2
.
16b
v4
.
8h
#
7
\
n
"
/
*
RRRRRxxx
*
/
\
"
shl
v0
.
16b
v29
.
16b
#
3
\
n
"
/
*
BBBBB000
*
/
\
"
shrn2
v1
.
16b
v4
.
8h
#
2
\
n
"
/
*
GGGGGxxx
*
/
\
"
sshr
v3
.
16b
v3
.
16b
#
7
\
n
"
/
*
AAAAAAAA
*
/
\
"
sri
v2
.
16b
v2
.
16b
#
5
\
n
"
/
*
RRRRRRRR
*
/
\
"
sri
v1
.
16b
v1
.
16b
#
5
\
n
"
/
*
GGGGGGGG
*
/
\
"
sri
v0
.
16b
v0
.
16b
#
5
\
n
"
/
*
BBBBBBBB
*
/
#
define
RGB555TOARGB
\
"
uzp1
v29
.
16b
v0
.
16b
v3
.
16b
\
n
"
/
*
xxxBBBBB
*
/
\
"
shrn
v2
.
8b
v0
.
8h
#
7
\
n
"
/
*
RRRRRxxx
*
/
\
"
shrn
v1
.
8b
v0
.
8h
#
2
\
n
"
/
*
GGGGGxxx
*
/
\
"
shl
v0
.
16b
v29
.
16b
#
3
\
n
"
/
*
BBBBB000
*
/
\
"
shrn2
v2
.
16b
v3
.
8h
#
7
\
n
"
/
*
RRRRRxxx
*
/
\
"
shrn2
v1
.
16b
v3
.
8h
#
2
\
n
"
/
*
GGGGGxxx
*
/
\
\
"
sri
v0
.
16b
v0
.
16b
#
5
\
n
"
/
*
BBBBBBBB
*
/
\
"
sri
v2
.
16b
v2
.
16b
#
5
\
n
"
/
*
RRRRRRRR
*
/
\
"
sri
v1
.
16b
v1
.
16b
#
5
\
n
"
/
*
GGGGGGGG
*
/
void
ARGB1555ToARGBRow_NEON
(
const
uint8_t
*
src_argb1555
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ldp
q0
q4
[
%
0
]
#
32
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
ARGB1555TOARGB
"
st4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
1
]
\
n
"
"
add
%
1
%
1
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb1555
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v29
"
/
/
Clobber
List
)
;
}
#
define
ARGB4444TOARGB
\
"
shl
v0
.
16b
v1
.
16b
#
4
\
n
"
/
*
RRRR0000_BBBB0000
*
/
\
"
sri
v1
.
16b
v1
.
16b
#
4
\
n
"
/
*
AAAAAAAA_GGGGGGGG
*
/
\
"
sri
v0
.
16b
v0
.
16b
#
4
\
n
"
/
*
RRRRRRRR_BBBBBBBB
*
/
#
define
ARGB4444TORGB
\
"
uzp1
v1
.
16b
v0
.
16b
v3
.
16b
\
n
"
/
*
GGGGBBBB
*
/
\
"
shrn
v2
.
8b
v0
.
8h
#
4
\
n
"
/
*
RRRRxxxx
*
/
\
"
shl
v0
.
16b
v1
.
16b
#
4
\
n
"
/
*
BBBB0000
*
/
\
"
shrn2
v2
.
16b
v3
.
8h
#
4
\
n
"
/
*
RRRRxxxx
*
/
\
"
sri
v1
.
16b
v1
.
16b
#
4
\
n
"
/
*
GGGGGGGG
*
/
\
"
sri
v2
.
16b
v2
.
16b
#
4
\
n
"
/
*
RRRRRRRR
*
/
\
"
sri
v0
.
16b
v0
.
16b
#
4
\
n
"
/
*
BBBBBBBB
*
/
void
ARGB4444ToARGBRow_NEON
(
const
uint8_t
*
src_argb4444
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v1
.
16b
}
[
%
0
]
#
16
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
ARGB4444TOARGB
"
st2
{
v0
.
16b
v1
.
16b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb4444
)
"
+
r
"
(
dst_argb
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
static
const
int16_t
kAR30Row_BoxShifts
[
]
=
{
0
-
6
0
-
6
0
-
6
0
-
6
}
;
static
const
uint8_t
kABGRToAR30Row_BoxIndices
[
]
=
{
2
2
1
1
6
6
5
5
10
10
9
9
14
14
13
13
0
0
3
3
4
4
7
7
8
8
11
11
12
12
15
15
}
;
static
const
uint8_t
kARGBToAR30Row_BoxIndices
[
]
=
{
0
0
1
1
4
4
5
5
8
8
9
9
12
12
13
13
2
2
3
3
6
6
7
7
10
10
11
11
14
14
15
15
}
;
static
void
ABCDToAR30Row_NEON
(
const
uint8_t
*
src_abcd
uint8_t
*
dst_ar30
int
width
const
uint8_t
*
indices
)
{
asm
volatile
(
"
movi
v2
.
4s
#
0xf
msl
16
\
n
"
"
ldr
q3
[
%
[
kAR30Row_BoxShifts
]
]
\
n
"
"
ldp
q4
q5
[
%
[
indices
]
]
\
n
"
"
1
:
\
n
"
"
ldp
q0
q20
[
%
[
src
]
]
#
32
\
n
"
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
"
tbl
v1
.
16b
{
v0
.
16b
}
v5
.
16b
\
n
"
"
tbl
v21
.
16b
{
v20
.
16b
}
v5
.
16b
\
n
"
"
tbl
v0
.
16b
{
v0
.
16b
}
v4
.
16b
\
n
"
"
tbl
v20
.
16b
{
v20
.
16b
}
v4
.
16b
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v3
.
8h
\
n
"
"
ushl
v20
.
8h
v20
.
8h
v3
.
8h
\
n
"
"
ushl
v1
.
8h
v1
.
8h
v3
.
8h
\
n
"
"
ushl
v21
.
8h
v21
.
8h
v3
.
8h
\
n
"
"
ushr
v0
.
4s
v0
.
4s
#
6
\
n
"
"
ushr
v20
.
4s
v20
.
4s
#
6
\
n
"
"
shl
v1
.
4s
v1
.
4s
#
14
\
n
"
"
shl
v21
.
4s
v21
.
4s
#
14
\
n
"
"
bif
v0
.
16b
v1
.
16b
v2
.
16b
\
n
"
"
bif
v20
.
16b
v21
.
16b
v2
.
16b
\
n
"
"
stp
q0
q20
[
%
[
dst
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src
]
"
+
r
"
(
src_abcd
)
[
dst
]
"
+
r
"
(
dst_ar30
)
[
width
]
"
+
r
"
(
width
)
:
[
kAR30Row_BoxShifts
]
"
r
"
(
kAR30Row_BoxShifts
)
[
indices
]
"
r
"
(
indices
)
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v20
"
"
v21
"
)
;
}
void
ABGRToAR30Row_NEON
(
const
uint8_t
*
src_abgr
uint8_t
*
dst_ar30
int
width
)
{
ABCDToAR30Row_NEON
(
src_abgr
dst_ar30
width
kABGRToAR30Row_BoxIndices
)
;
}
void
ARGBToAR30Row_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_ar30
int
width
)
{
ABCDToAR30Row_NEON
(
src_argb
dst_ar30
width
kARGBToAR30Row_BoxIndices
)
;
}
void
ARGBToRGB24Row_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb24
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
1
]
#
48
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
"
+
r
"
(
dst_rgb24
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
ARGBToRAWRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_raw
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v1
.
8b
v2
.
8b
v3
.
8b
v4
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
mov
v4
.
8b
v2
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mov
v5
.
8b
v1
.
8b
\
n
"
"
st3
{
v3
.
8b
v4
.
8b
v5
.
8b
}
[
%
1
]
#
24
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_raw
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
/
/
Clobber
List
)
;
}
void
YUY2ToYRow_NEON
(
const
uint8_t
*
src_yuy2
uint8_t
*
dst_y
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld2
{
v0
.
16b
v1
.
16b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v0
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_yuy2
)
"
+
r
"
(
dst_y
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
)
;
}
void
UYVYToYRow_NEON
(
const
uint8_t
*
src_uyvy
uint8_t
*
dst_y
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld2
{
v0
.
16b
v1
.
16b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_uyvy
)
"
+
r
"
(
dst_y
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
)
;
}
void
YUY2ToUV422Row_NEON
(
const
uint8_t
*
src_yuy2
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v1
.
8b
}
[
%
1
]
#
8
\
n
"
"
st1
{
v3
.
8b
}
[
%
2
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_yuy2
)
"
+
r
"
(
dst_u
)
"
+
r
"
(
dst_v
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
UYVYToUV422Row_NEON
(
const
uint8_t
*
src_uyvy
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v0
.
8b
}
[
%
1
]
#
8
\
n
"
"
st1
{
v2
.
8b
}
[
%
2
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_uyvy
)
"
+
r
"
(
dst_u
)
"
+
r
"
(
dst_v
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
YUY2ToUVRow_NEON
(
const
uint8_t
*
src_yuy2
int
stride_yuy2
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_yuy2b
=
src_yuy2
+
stride_yuy2
;
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
ld4
{
v4
.
8b
v5
.
8b
v6
.
8b
v7
.
8b
}
[
%
1
]
#
32
\
n
"
"
urhadd
v1
.
8b
v1
.
8b
v5
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
urhadd
v3
.
8b
v3
.
8b
v7
.
8b
\
n
"
"
st1
{
v1
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v3
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_yuy2
)
/
/
%
0
"
+
r
"
(
src_yuy2b
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
/
/
Clobber
List
)
;
}
void
UYVYToUVRow_NEON
(
const
uint8_t
*
src_uyvy
int
stride_uyvy
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_uyvyb
=
src_uyvy
+
stride_uyvy
;
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
ld4
{
v4
.
8b
v5
.
8b
v6
.
8b
v7
.
8b
}
[
%
1
]
#
32
\
n
"
"
urhadd
v0
.
8b
v0
.
8b
v4
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
urhadd
v2
.
8b
v2
.
8b
v6
.
8b
\
n
"
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v2
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_uyvy
)
/
/
%
0
"
+
r
"
(
src_uyvyb
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
/
/
Clobber
List
)
;
}
void
YUY2ToNVUVRow_NEON
(
const
uint8_t
*
src_yuy2
int
stride_yuy2
uint8_t
*
dst_uv
int
width
)
{
const
uint8_t
*
src_yuy2b
=
src_yuy2
+
stride_yuy2
;
asm
volatile
(
"
1
:
\
n
"
"
ld2
{
v0
.
16b
v1
.
16b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
ld2
{
v2
.
16b
v3
.
16b
}
[
%
1
]
#
32
\
n
"
"
urhadd
v4
.
16b
v1
.
16b
v3
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v4
.
16b
}
[
%
2
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_yuy2
)
/
/
%
0
"
+
r
"
(
src_yuy2b
)
/
/
%
1
"
+
r
"
(
dst_uv
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
/
/
Clobber
List
)
;
}
void
ARGBShuffleRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
const
uint8_t
*
shuffler
int
width
)
{
asm
volatile
(
"
ld1
{
v2
.
16b
}
[
%
3
]
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
subs
%
w2
%
w2
#
4
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
tbl
v1
.
16b
{
v0
.
16b
}
v2
.
16b
\
n
"
"
st1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
shuffler
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
/
/
Clobber
List
)
;
}
void
I422ToYUY2Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_yuy2
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld2
{
v0
.
8b
v1
.
8b
}
[
%
0
]
#
16
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
mov
v2
.
8b
v1
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
ld1
{
v1
.
8b
}
[
%
1
]
#
8
\
n
"
"
ld1
{
v3
.
8b
}
[
%
2
]
#
8
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
3
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
src_u
)
/
/
%
1
"
+
r
"
(
src_v
)
/
/
%
2
"
+
r
"
(
dst_yuy2
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
I422ToUYVYRow_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_uyvy
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld2
{
v1
.
8b
v2
.
8b
}
[
%
0
]
#
16
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
mov
v3
.
8b
v2
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
ld1
{
v0
.
8b
}
[
%
1
]
#
8
\
n
"
"
ld1
{
v2
.
8b
}
[
%
2
]
#
8
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
3
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
src_u
)
/
/
%
1
"
+
r
"
(
src_v
)
/
/
%
2
"
+
r
"
(
dst_uyvy
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
ARGBToRGB565Row_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb565
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
ARGBTORGB565
"
st1
{
v18
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_rgb565
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
)
;
}
void
ARGBToRGB565DitherRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
uint32_t
dither4
int
width
)
{
asm
volatile
(
"
dup
v1
.
4s
%
w3
\
n
"
"
1
:
\
n
"
"
ld4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
uqadd
v16
.
8b
v16
.
8b
v1
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uqadd
v17
.
8b
v17
.
8b
v1
.
8b
\
n
"
"
uqadd
v18
.
8b
v18
.
8b
v1
.
8b
\
n
"
ARGBTORGB565
"
st1
{
v18
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_rgb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
dither4
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v1
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
)
;
}
void
ARGBToARGB1555Row_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb1555
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld2
{
v16
.
8h
v17
.
8h
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
ARGBTOARGB1555
"
st1
{
v17
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
"
+
r
"
(
dst_argb1555
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v1
"
"
v2
"
"
v16
"
"
v17
"
)
;
}
void
ARGBToARGB4444Row_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb4444
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
ARGBTOARGB4444
"
st1
{
v0
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_argb4444
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
)
;
}
#
if
defined
(
LIBYUV_USE_ST2
)
void
ARGBToAR64Row_NEON
(
const
uint8_t
*
src_argb
uint16_t
*
dst_ar64
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ldp
q0
q2
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
mov
v1
.
16b
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mov
v3
.
16b
v2
.
16b
\
n
"
"
st2
{
v0
.
16b
v1
.
16b
}
[
%
1
]
#
32
\
n
"
"
st2
{
v2
.
16b
v3
.
16b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_ar64
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
static
const
uvec8
kShuffleARGBToABGR
=
{
2
1
0
3
6
5
4
7
10
9
8
11
14
13
12
15
}
;
void
ARGBToAB64Row_NEON
(
const
uint8_t
*
src_argb
uint16_t
*
dst_ab64
int
width
)
{
asm
volatile
(
"
ldr
q4
[
%
3
]
\
n
"
"
1
:
\
n
"
"
ldp
q0
q2
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
tbl
v0
.
16b
{
v0
.
16b
}
v4
.
16b
\
n
"
"
tbl
v2
.
16b
{
v2
.
16b
}
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mov
v1
.
16b
v0
.
16b
\
n
"
"
mov
v3
.
16b
v2
.
16b
\
n
"
"
st2
{
v0
.
16b
v1
.
16b
}
[
%
1
]
#
32
\
n
"
"
st2
{
v2
.
16b
v3
.
16b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_ab64
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
&
kShuffleARGBToABGR
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
#
else
void
ARGBToAR64Row_NEON
(
const
uint8_t
*
src_argb
uint16_t
*
dst_ar64
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
zip1
v2
.
16b
v0
.
16b
v0
.
16b
\
n
"
"
zip2
v3
.
16b
v0
.
16b
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
zip1
v4
.
16b
v1
.
16b
v1
.
16b
\
n
"
"
zip2
v5
.
16b
v1
.
16b
v1
.
16b
\
n
"
"
st1
{
v2
.
8h
v3
.
8h
v4
.
8h
v5
.
8h
}
[
%
1
]
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_ar64
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
)
;
}
static
const
uvec8
kShuffleARGBToAB64
[
2
]
=
{
{
2
2
1
1
0
0
3
3
6
6
5
5
4
4
7
7
}
{
10
10
9
9
8
8
11
11
14
14
13
13
12
12
15
15
}
}
;
void
ARGBToAB64Row_NEON
(
const
uint8_t
*
src_argb
uint16_t
*
dst_ab64
int
width
)
{
asm
volatile
(
"
ldp
q6
q7
[
%
3
]
\
n
"
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
tbl
v2
.
16b
{
v0
.
16b
}
v6
.
16b
\
n
"
"
tbl
v3
.
16b
{
v0
.
16b
}
v7
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
tbl
v4
.
16b
{
v1
.
16b
}
v6
.
16b
\
n
"
"
tbl
v5
.
16b
{
v1
.
16b
}
v7
.
16b
\
n
"
"
st1
{
v2
.
8h
v3
.
8h
v4
.
8h
v5
.
8h
}
[
%
1
]
#
64
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_ab64
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
&
kShuffleARGBToAB64
[
0
]
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
#
endif
static
const
uvec8
kShuffleAR64ToARGB
=
{
1
3
5
7
9
11
13
15
17
19
21
23
25
27
29
31
}
;
void
AR64ToARGBRow_NEON
(
const
uint16_t
*
src_ar64
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
ldr
q4
[
%
3
]
\
n
"
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
ldp
q2
q3
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
tbl
v0
.
16b
{
v0
.
16b
v1
.
16b
}
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
tbl
v2
.
16b
{
v2
.
16b
v3
.
16b
}
v4
.
16b
\
n
"
"
stp
q0
q2
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_ar64
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
&
kShuffleAR64ToARGB
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
static
const
uvec8
kShuffleAB64ToARGB
=
{
5
3
1
7
13
11
9
15
21
19
17
23
29
27
25
31
}
;
void
AB64ToARGBRow_NEON
(
const
uint16_t
*
src_ab64
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
ldr
q4
[
%
3
]
\
n
"
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
ldp
q2
q3
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
tbl
v0
.
16b
{
v0
.
16b
v1
.
16b
}
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
tbl
v2
.
16b
{
v2
.
16b
v3
.
16b
}
v4
.
16b
\
n
"
"
stp
q0
q2
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_ab64
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
&
kShuffleAB64ToARGB
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
void
ARGBExtractAlphaRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_a
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
st1
{
v3
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
"
+
r
"
(
dst_a
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
struct
RgbUVConstants
{
int8_t
kRGBToU
[
4
]
;
int8_t
kRGBToV
[
4
]
;
}
;
static
void
ARGBToUV444MatrixRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
const
struct
RgbUVConstants
*
rgbuvconstants
)
{
asm
volatile
(
"
ldr
d0
[
%
4
]
\
n
"
"
dup
v24
.
16b
v0
.
b
[
0
]
\
n
"
"
dup
v25
.
16b
v0
.
b
[
1
]
\
n
"
"
dup
v26
.
16b
v0
.
b
[
2
]
\
n
"
"
dup
v27
.
16b
v0
.
b
[
4
]
\
n
"
"
dup
v28
.
16b
v0
.
b
[
5
]
\
n
"
"
neg
v24
.
16b
v24
.
16b
\
n
"
"
movi
v29
.
8h
#
0x80
lsl
#
8
\
n
"
"
1
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
umull
v4
.
8h
v0
.
8b
v24
.
8b
\
n
"
"
umlsl
v4
.
8h
v1
.
8b
v25
.
8b
\
n
"
"
umlsl
v4
.
8h
v2
.
8b
v26
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umull
v3
.
8h
v2
.
8b
v24
.
8b
\
n
"
"
umlsl
v3
.
8h
v1
.
8b
v28
.
8b
\
n
"
"
umlsl
v3
.
8h
v0
.
8b
v27
.
8b
\
n
"
"
addhn
v0
.
8b
v4
.
8h
v29
.
8h
\
n
"
"
addhn
v1
.
8b
v3
.
8h
v29
.
8h
\
n
"
"
st1
{
v0
.
8b
}
[
%
1
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
2
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_u
)
/
/
%
1
"
+
r
"
(
dst_v
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
"
r
"
(
rgbuvconstants
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v24
"
"
v25
"
"
v26
"
"
v27
"
"
v28
"
"
v29
"
)
;
}
static
void
ARGBToUV444MatrixRow_NEON_I8MM
(
const
uint8_t
*
src_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
const
struct
RgbUVConstants
*
rgbuvconstants
)
{
asm
volatile
(
"
ld2r
{
v16
.
4s
v17
.
4s
}
[
%
[
rgbuvconstants
]
]
\
n
"
"
movi
v29
.
8h
#
0x80
lsl
#
8
\
n
"
"
1
:
\
n
"
"
ldp
q0
q1
[
%
[
src
]
]
#
32
\
n
"
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
"
movi
v2
.
4s
#
0
\
n
"
"
movi
v3
.
4s
#
0
\
n
"
"
movi
v4
.
4s
#
0
\
n
"
"
movi
v5
.
4s
#
0
\
n
"
"
usdot
v2
.
4s
v0
.
16b
v16
.
16b
\
n
"
"
usdot
v3
.
4s
v1
.
16b
v16
.
16b
\
n
"
"
usdot
v4
.
4s
v0
.
16b
v17
.
16b
\
n
"
"
usdot
v5
.
4s
v1
.
16b
v17
.
16b
\
n
"
"
prfm
pldl1keep
[
%
[
src
]
448
]
\
n
"
"
uzp1
v0
.
8h
v2
.
8h
v3
.
8h
\
n
"
"
uzp1
v1
.
8h
v4
.
8h
v5
.
8h
\
n
"
"
subhn
v0
.
8b
v29
.
8h
v0
.
8h
\
n
"
"
subhn
v1
.
8b
v29
.
8h
v1
.
8h
\
n
"
"
str
d0
[
%
[
dst_u
]
]
#
8
\
n
"
"
str
d1
[
%
[
dst_v
]
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src
]
"
+
r
"
(
src_argb
)
[
dst_u
]
"
+
r
"
(
dst_u
)
[
dst_v
]
"
+
r
"
(
dst_v
)
[
width
]
"
+
r
"
(
width
)
:
[
rgbuvconstants
]
"
r
"
(
rgbuvconstants
)
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v16
"
"
v17
"
"
v29
"
)
;
}
static
const
struct
RgbUVConstants
kARGBI601UVConstants
=
{
{
-
112
74
38
0
}
{
18
94
-
112
0
}
}
;
void
ARGBToUV444Row_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ARGBToUV444MatrixRow_NEON
(
src_argb
dst_u
dst_v
width
&
kARGBI601UVConstants
)
;
}
void
ARGBToUV444Row_NEON_I8MM
(
const
uint8_t
*
src_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ARGBToUV444MatrixRow_NEON_I8MM
(
src_argb
dst_u
dst_v
width
&
kARGBI601UVConstants
)
;
}
static
const
struct
RgbUVConstants
kARGBJPEGUVConstants
=
{
{
-
128
85
43
0
}
{
21
107
-
128
0
}
}
;
void
ARGBToUVJ444Row_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ARGBToUV444MatrixRow_NEON
(
src_argb
dst_u
dst_v
width
&
kARGBJPEGUVConstants
)
;
}
void
ARGBToUVJ444Row_NEON_I8MM
(
const
uint8_t
*
src_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ARGBToUV444MatrixRow_NEON_I8MM
(
src_argb
dst_u
dst_v
width
&
kARGBJPEGUVConstants
)
;
}
#
define
RGBTOUV_SETUP_REG
\
"
movi
v20
.
8h
#
112
\
n
"
/
*
UB
/
VR
coefficient
(
0
.
875
)
*
/
\
"
movi
v21
.
8h
#
74
\
n
"
/
*
UG
coefficient
(
-
0
.
5781
)
*
/
\
"
movi
v22
.
8h
#
38
\
n
"
/
*
UR
coefficient
(
-
0
.
2969
)
*
/
\
"
movi
v23
.
8h
#
18
\
n
"
/
*
VB
coefficient
(
-
0
.
1406
)
*
/
\
"
movi
v24
.
8h
#
94
\
n
"
/
*
VG
coefficient
(
-
0
.
7344
)
*
/
\
"
movi
v25
.
8h
#
0x80
lsl
#
8
\
n
"
/
*
128
.
0
(
0x8000
in
16
-
bit
)
*
/
#
define
RGBTOUV
(
QB
QG
QR
)
\
"
mul
v3
.
8h
"
#
QB
"
v20
.
8h
\
n
"
/
*
B
*
/
\
"
mul
v4
.
8h
"
#
QR
"
v20
.
8h
\
n
"
/
*
R
*
/
\
"
mls
v3
.
8h
"
#
QG
"
v21
.
8h
\
n
"
/
*
G
*
/
\
"
mls
v4
.
8h
"
#
QG
"
v24
.
8h
\
n
"
/
*
G
*
/
\
"
mls
v3
.
8h
"
#
QR
"
v22
.
8h
\
n
"
/
*
R
*
/
\
"
mls
v4
.
8h
"
#
QB
"
v23
.
8h
\
n
"
/
*
B
*
/
\
"
addhn
v0
.
8b
v3
.
8h
v25
.
8h
\
n
"
/
*
+
128
-
>
unsigned
*
/
\
"
addhn
v1
.
8b
v4
.
8h
v25
.
8h
\
n
"
/
*
+
128
-
>
unsigned
*
/
void
ARGBToUVRow_NEON
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_argb_1
=
src_argb
+
src_stride_argb
;
asm
volatile
(
RGBTOUV_SETUP_REG
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
uaddlp
v2
.
8h
v2
.
16b
\
n
"
"
ld4
{
v4
.
16b
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
1
]
#
64
\
n
"
"
uadalp
v0
.
8h
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v1
.
8h
v5
.
16b
\
n
"
"
uadalp
v2
.
8h
v6
.
16b
\
n
"
"
urshr
v0
.
8h
v0
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v1
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v1
.
8h
v2
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
src_argb_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
ARGBToUVJRow_NEON
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_argb_1
=
src_argb
+
src_stride_argb
;
asm
volatile
(
"
movi
v20
.
8h
#
128
\
n
"
"
movi
v21
.
8h
#
85
\
n
"
"
movi
v22
.
8h
#
43
\
n
"
"
movi
v23
.
8h
#
21
\
n
"
"
movi
v24
.
8h
#
107
\
n
"
"
movi
v25
.
8h
#
0x80
lsl
#
8
\
n
"
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
uaddlp
v2
.
8h
v2
.
16b
\
n
"
"
ld4
{
v4
.
16b
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
1
]
#
64
\
n
"
"
uadalp
v0
.
8h
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v1
.
8h
v5
.
16b
\
n
"
"
uadalp
v2
.
8h
v6
.
16b
\
n
"
"
urshr
v0
.
8h
v0
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v1
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v1
.
8h
v2
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
src_argb_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
ABGRToUVJRow_NEON
(
const
uint8_t
*
src_abgr
int
src_stride_abgr
uint8_t
*
dst_uj
uint8_t
*
dst_vj
int
width
)
{
const
uint8_t
*
src_abgr_1
=
src_abgr
+
src_stride_abgr
;
asm
volatile
(
"
movi
v20
.
8h
#
128
\
n
"
"
movi
v21
.
8h
#
85
\
n
"
"
movi
v22
.
8h
#
43
\
n
"
"
movi
v23
.
8h
#
21
\
n
"
"
movi
v24
.
8h
#
107
\
n
"
"
movi
v25
.
8h
#
0x80
lsl
#
8
\
n
"
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
uaddlp
v2
.
8h
v2
.
16b
\
n
"
"
ld4
{
v4
.
16b
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
1
]
#
64
\
n
"
"
uadalp
v0
.
8h
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v1
.
8h
v5
.
16b
\
n
"
"
uadalp
v2
.
8h
v6
.
16b
\
n
"
"
urshr
v0
.
8h
v0
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v1
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
RGBTOUV
(
v2
.
8h
v1
.
8h
v0
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_abgr
)
/
/
%
0
"
+
r
"
(
src_abgr_1
)
/
/
%
1
"
+
r
"
(
dst_uj
)
/
/
%
2
"
+
r
"
(
dst_vj
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
RGB24ToUVJRow_NEON
(
const
uint8_t
*
src_rgb24
int
src_stride_rgb24
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_rgb24_1
=
src_rgb24
+
src_stride_rgb24
;
asm
volatile
(
"
movi
v20
.
8h
#
128
\
n
"
"
movi
v21
.
8h
#
85
\
n
"
"
movi
v22
.
8h
#
43
\
n
"
"
movi
v23
.
8h
#
21
\
n
"
"
movi
v24
.
8h
#
107
\
n
"
"
movi
v25
.
8h
#
0x80
lsl
#
8
\
n
"
"
1
:
\
n
"
"
ld3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
0
]
#
48
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
uaddlp
v2
.
8h
v2
.
16b
\
n
"
"
ld3
{
v4
.
16b
v5
.
16b
v6
.
16b
}
[
%
1
]
#
48
\
n
"
"
uadalp
v0
.
8h
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v1
.
8h
v5
.
16b
\
n
"
"
uadalp
v2
.
8h
v6
.
16b
\
n
"
"
urshr
v0
.
8h
v0
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v1
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v1
.
8h
v2
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgb24
)
/
/
%
0
"
+
r
"
(
src_rgb24_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
RAWToUVJRow_NEON
(
const
uint8_t
*
src_raw
int
src_stride_raw
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_raw_1
=
src_raw
+
src_stride_raw
;
asm
volatile
(
"
movi
v20
.
8h
#
128
\
n
"
"
movi
v21
.
8h
#
85
\
n
"
"
movi
v22
.
8h
#
43
\
n
"
"
movi
v23
.
8h
#
21
\
n
"
"
movi
v24
.
8h
#
107
\
n
"
"
movi
v25
.
8h
#
0x80
lsl
#
8
\
n
"
"
1
:
\
n
"
"
ld3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
0
]
#
48
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
uaddlp
v2
.
8h
v2
.
16b
\
n
"
"
ld3
{
v4
.
16b
v5
.
16b
v6
.
16b
}
[
%
1
]
#
48
\
n
"
"
uadalp
v0
.
8h
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v1
.
8h
v5
.
16b
\
n
"
"
uadalp
v2
.
8h
v6
.
16b
\
n
"
"
urshr
v0
.
8h
v0
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v1
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
RGBTOUV
(
v2
.
8h
v1
.
8h
v0
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_raw
)
/
/
%
0
"
+
r
"
(
src_raw_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
BGRAToUVRow_NEON
(
const
uint8_t
*
src_bgra
int
src_stride_bgra
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_bgra_1
=
src_bgra
+
src_stride_bgra
;
asm
volatile
(
RGBTOUV_SETUP_REG
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v0
.
8h
v3
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v3
.
8h
v2
.
16b
\
n
"
"
uaddlp
v2
.
8h
v1
.
16b
\
n
"
"
ld4
{
v4
.
16b
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
1
]
#
64
\
n
"
"
uadalp
v0
.
8h
v7
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v3
.
8h
v6
.
16b
\
n
"
"
uadalp
v2
.
8h
v5
.
16b
\
n
"
"
urshr
v0
.
8h
v0
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v3
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v1
.
8h
v2
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_bgra
)
/
/
%
0
"
+
r
"
(
src_bgra_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
ABGRToUVRow_NEON
(
const
uint8_t
*
src_abgr
int
src_stride_abgr
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_abgr_1
=
src_abgr
+
src_stride_abgr
;
asm
volatile
(
RGBTOUV_SETUP_REG
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v3
.
8h
v2
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v2
.
8h
v1
.
16b
\
n
"
"
uaddlp
v1
.
8h
v0
.
16b
\
n
"
"
ld4
{
v4
.
16b
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
1
]
#
64
\
n
"
"
uadalp
v3
.
8h
v6
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v2
.
8h
v5
.
16b
\
n
"
"
uadalp
v1
.
8h
v4
.
16b
\
n
"
"
urshr
v0
.
8h
v3
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v1
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v2
.
8h
v1
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_abgr
)
/
/
%
0
"
+
r
"
(
src_abgr_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
RGBAToUVRow_NEON
(
const
uint8_t
*
src_rgba
int
src_stride_rgba
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_rgba_1
=
src_rgba
+
src_stride_rgba
;
asm
volatile
(
RGBTOUV_SETUP_REG
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v0
.
8h
v1
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v2
.
16b
\
n
"
"
uaddlp
v2
.
8h
v3
.
16b
\
n
"
"
ld4
{
v4
.
16b
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
1
]
#
64
\
n
"
"
uadalp
v0
.
8h
v5
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v1
.
8h
v6
.
16b
\
n
"
"
uadalp
v2
.
8h
v7
.
16b
\
n
"
"
urshr
v0
.
8h
v0
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v1
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v1
.
8h
v2
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgba
)
/
/
%
0
"
+
r
"
(
src_rgba_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
RGB24ToUVRow_NEON
(
const
uint8_t
*
src_rgb24
int
src_stride_rgb24
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_rgb24_1
=
src_rgb24
+
src_stride_rgb24
;
asm
volatile
(
RGBTOUV_SETUP_REG
"
1
:
\
n
"
"
ld3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
0
]
#
48
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
uaddlp
v2
.
8h
v2
.
16b
\
n
"
"
ld3
{
v4
.
16b
v5
.
16b
v6
.
16b
}
[
%
1
]
#
48
\
n
"
"
uadalp
v0
.
8h
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v1
.
8h
v5
.
16b
\
n
"
"
uadalp
v2
.
8h
v6
.
16b
\
n
"
"
urshr
v0
.
8h
v0
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v1
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v1
.
8h
v2
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgb24
)
/
/
%
0
"
+
r
"
(
src_rgb24_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
RAWToUVRow_NEON
(
const
uint8_t
*
src_raw
int
src_stride_raw
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_raw_1
=
src_raw
+
src_stride_raw
;
asm
volatile
(
RGBTOUV_SETUP_REG
"
1
:
\
n
"
"
ld3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
0
]
#
48
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
"
uaddlp
v2
.
8h
v2
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
ld3
{
v4
.
16b
v5
.
16b
v6
.
16b
}
[
%
1
]
#
48
\
n
"
"
uadalp
v2
.
8h
v6
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v1
.
8h
v5
.
16b
\
n
"
"
uadalp
v0
.
8h
v4
.
16b
\
n
"
"
urshr
v2
.
8h
v2
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v1
.
8h
#
2
\
n
"
"
urshr
v0
.
8h
v0
.
8h
#
2
\
n
"
RGBTOUV
(
v2
.
8h
v1
.
8h
v0
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_raw
)
/
/
%
0
"
+
r
"
(
src_raw_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
RGB565ToUVRow_NEON
(
const
uint8_t
*
src_rgb565
int
src_stride_rgb565
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_rgb565_1
=
src_rgb565
+
src_stride_rgb565
;
asm
volatile
(
RGBTOUV_SETUP_REG
"
1
:
\
n
"
"
ldp
q0
q4
[
%
0
]
#
32
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
RGB565TOARGB
"
uaddlp
v16
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v17
.
8h
v1
.
16b
\
n
"
"
uaddlp
v18
.
8h
v2
.
16b
\
n
"
"
ldp
q0
q4
[
%
1
]
#
32
\
n
"
RGB565TOARGB
"
uadalp
v16
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v17
.
8h
v1
.
16b
\
n
"
"
uadalp
v18
.
8h
v2
.
16b
\
n
"
"
urshr
v0
.
8h
v16
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v17
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v18
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v1
.
8h
v2
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgb565
)
/
/
%
0
"
+
r
"
(
src_rgb565_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
"
v26
"
"
v27
"
"
v28
"
)
;
}
void
ARGB1555ToUVRow_NEON
(
const
uint8_t
*
src_argb1555
int
src_stride_argb1555
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_argb1555_1
=
src_argb1555
+
src_stride_argb1555
;
asm
volatile
(
RGBTOUV_SETUP_REG
"
1
:
\
n
"
"
ldp
q0
q3
[
%
0
]
#
32
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
RGB555TOARGB
"
uaddlp
v16
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v17
.
8h
v1
.
16b
\
n
"
"
uaddlp
v18
.
8h
v2
.
16b
\
n
"
"
ldp
q0
q3
[
%
1
]
#
32
\
n
"
RGB555TOARGB
"
uadalp
v16
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v17
.
8h
v1
.
16b
\
n
"
"
uadalp
v18
.
8h
v2
.
16b
\
n
"
"
urshr
v0
.
8h
v16
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v17
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v18
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v1
.
8h
v2
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb1555
)
/
/
%
0
"
+
r
"
(
src_argb1555_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
"
v26
"
"
v27
"
"
v28
"
"
v29
"
)
;
}
void
ARGB4444ToUVRow_NEON
(
const
uint8_t
*
src_argb4444
int
src_stride_argb4444
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
const
uint8_t
*
src_argb4444_1
=
src_argb4444
+
src_stride_argb4444
;
asm
volatile
(
RGBTOUV_SETUP_REG
"
1
:
\
n
"
"
ldp
q0
q3
[
%
0
]
#
32
\
n
"
"
subs
%
w4
%
w4
#
16
\
n
"
ARGB4444TORGB
"
uaddlp
v16
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v17
.
8h
v1
.
16b
\
n
"
"
uaddlp
v18
.
8h
v2
.
16b
\
n
"
"
ldp
q0
q3
[
%
1
]
#
32
\
n
"
ARGB4444TORGB
"
uadalp
v16
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v17
.
8h
v1
.
16b
\
n
"
"
uadalp
v18
.
8h
v2
.
16b
\
n
"
"
urshr
v0
.
8h
v16
.
8h
#
2
\
n
"
"
urshr
v1
.
8h
v17
.
8h
#
2
\
n
"
"
urshr
v2
.
8h
v18
.
8h
#
2
\
n
"
RGBTOUV
(
v0
.
8h
v1
.
8h
v2
.
8h
)
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
st1
{
v1
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb4444
)
/
/
%
0
"
+
r
"
(
src_argb4444_1
)
/
/
%
1
"
+
r
"
(
dst_u
)
/
/
%
2
"
+
r
"
(
dst_v
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
"
v26
"
"
v27
"
"
v28
"
)
;
}
static
void
ABCDToUVMatrixRow_NEON_I8MM
(
const
uint8_t
*
src
int
src_stride
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
const
int8_t
*
uvconstants
)
{
const
uint8_t
*
src1
=
src
+
src_stride
;
asm
volatile
(
"
movi
v23
.
8h
#
0x80
lsl
#
8
\
n
"
"
ld2r
{
v24
.
4s
v25
.
4s
}
[
%
[
uvconstants
]
]
\
n
"
"
1
:
\
n
"
"
ld2
{
v0
.
4s
v1
.
4s
}
[
%
[
src
]
]
#
32
\
n
"
"
ld2
{
v2
.
4s
v3
.
4s
}
[
%
[
src
]
]
#
32
\
n
"
"
subs
%
w
[
width
]
%
w
[
width
]
#
16
\
n
"
"
uaddl
v4
.
8h
v0
.
8b
v1
.
8b
\
n
"
"
uaddl2
v5
.
8h
v0
.
16b
v1
.
16b
\
n
"
"
uaddl
v6
.
8h
v2
.
8b
v3
.
8b
\
n
"
"
uaddl2
v7
.
8h
v2
.
16b
v3
.
16b
\
n
"
"
ld2
{
v0
.
4s
v1
.
4s
}
[
%
[
src1
]
]
#
32
\
n
"
"
ld2
{
v2
.
4s
v3
.
4s
}
[
%
[
src1
]
]
#
32
\
n
"
"
uaddw
v4
.
8h
v4
.
8h
v0
.
8b
\
n
"
"
uaddw2
v5
.
8h
v5
.
8h
v0
.
16b
\
n
"
"
uaddw
v6
.
8h
v6
.
8h
v2
.
8b
\
n
"
"
uaddw2
v7
.
8h
v7
.
8h
v2
.
16b
\
n
"
"
prfm
pldl1keep
[
%
[
src
]
448
]
\
n
"
"
uaddw
v4
.
8h
v4
.
8h
v1
.
8b
\
n
"
"
uaddw2
v5
.
8h
v5
.
8h
v1
.
16b
\
n
"
"
uaddw
v6
.
8h
v6
.
8h
v3
.
8b
\
n
"
"
uaddw2
v7
.
8h
v7
.
8h
v3
.
16b
\
n
"
"
prfm
pldl1keep
[
%
[
src1
]
448
]
\
n
"
"
rshrn
v4
.
8b
v4
.
8h
#
2
\
n
"
"
rshrn
v6
.
8b
v6
.
8h
#
2
\
n
"
"
rshrn2
v4
.
16b
v5
.
8h
#
2
\
n
"
"
rshrn2
v6
.
16b
v7
.
8h
#
2
\
n
"
"
movi
v0
.
4s
#
0
\
n
"
"
movi
v1
.
4s
#
0
\
n
"
"
usdot
v0
.
4s
v4
.
16b
v24
.
16b
\
n
"
"
usdot
v1
.
4s
v6
.
16b
v24
.
16b
\
n
"
"
movi
v2
.
4s
#
0
\
n
"
"
movi
v3
.
4s
#
0
\
n
"
"
usdot
v2
.
4s
v4
.
16b
v25
.
16b
\
n
"
"
usdot
v3
.
4s
v6
.
16b
v25
.
16b
\
n
"
"
uzp1
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
uzp1
v1
.
8h
v2
.
8h
v3
.
8h
\
n
"
"
subhn
v0
.
8b
v23
.
8h
v0
.
8h
\
n
"
"
subhn
v1
.
8b
v23
.
8h
v1
.
8h
\
n
"
"
str
d0
[
%
[
dst_u
]
]
#
8
\
n
"
"
str
d1
[
%
[
dst_v
]
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src
]
"
+
r
"
(
src
)
[
src1
]
"
+
r
"
(
src1
)
[
dst_u
]
"
+
r
"
(
dst_u
)
[
dst_v
]
"
+
r
"
(
dst_v
)
[
width
]
"
+
r
"
(
width
)
:
[
uvconstants
]
"
r
"
(
uvconstants
)
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
static
const
int8_t
kARGBToUVCoefficients
[
]
=
{
-
112
74
38
0
18
94
-
112
0
}
;
static
const
int8_t
kABGRToUVCoefficients
[
]
=
{
38
74
-
112
0
-
112
94
18
0
}
;
static
const
int8_t
kBGRAToUVCoefficients
[
]
=
{
0
38
74
-
112
0
-
112
94
18
}
;
static
const
int8_t
kRGBAToUVCoefficients
[
]
=
{
0
-
112
74
38
0
18
94
-
112
}
;
void
ARGBToUVRow_NEON_I8MM
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ABCDToUVMatrixRow_NEON_I8MM
(
src_argb
src_stride_argb
dst_u
dst_v
width
kARGBToUVCoefficients
)
;
}
void
ABGRToUVRow_NEON_I8MM
(
const
uint8_t
*
src_abgr
int
src_stride_abgr
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ABCDToUVMatrixRow_NEON_I8MM
(
src_abgr
src_stride_abgr
dst_u
dst_v
width
kABGRToUVCoefficients
)
;
}
void
BGRAToUVRow_NEON_I8MM
(
const
uint8_t
*
src_bgra
int
src_stride_bgra
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ABCDToUVMatrixRow_NEON_I8MM
(
src_bgra
src_stride_bgra
dst_u
dst_v
width
kBGRAToUVCoefficients
)
;
}
void
RGBAToUVRow_NEON_I8MM
(
const
uint8_t
*
src_rgba
int
src_stride_rgba
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ABCDToUVMatrixRow_NEON_I8MM
(
src_rgba
src_stride_rgba
dst_u
dst_v
width
kRGBAToUVCoefficients
)
;
}
static
const
int8_t
kARGBToUVJCoefficients
[
]
=
{
-
128
85
43
0
21
107
-
128
0
}
;
static
const
int8_t
kABGRToUVJCoefficients
[
]
=
{
43
85
-
128
0
-
128
107
21
0
}
;
void
ARGBToUVJRow_NEON_I8MM
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ABCDToUVMatrixRow_NEON_I8MM
(
src_argb
src_stride_argb
dst_u
dst_v
width
kARGBToUVJCoefficients
)
;
}
void
ABGRToUVJRow_NEON_I8MM
(
const
uint8_t
*
src_abgr
int
src_stride_abgr
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
ABCDToUVMatrixRow_NEON_I8MM
(
src_abgr
src_stride_abgr
dst_u
dst_v
width
kABGRToUVJCoefficients
)
;
}
void
RGB565ToYRow_NEON
(
const
uint8_t
*
src_rgb565
uint8_t
*
dst_y
int
width
)
{
asm
volatile
(
"
movi
v24
.
16b
#
25
\
n
"
"
movi
v25
.
16b
#
129
\
n
"
"
movi
v26
.
16b
#
66
\
n
"
"
movi
v27
.
16b
#
16
\
n
"
"
1
:
\
n
"
"
ldp
q0
q4
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
RGB565TOARGB
"
umull
v3
.
8h
v0
.
8b
v24
.
8b
\
n
"
"
umull2
v4
.
8h
v0
.
16b
v24
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umlal
v3
.
8h
v1
.
8b
v25
.
8b
\
n
"
"
umlal2
v4
.
8h
v1
.
16b
v25
.
16b
\
n
"
"
umlal
v3
.
8h
v2
.
8b
v26
.
8b
\
n
"
"
umlal2
v4
.
8h
v2
.
16b
v26
.
16b
\
n
"
"
uqrshrn
v0
.
8b
v3
.
8h
#
8
\
n
"
"
uqrshrn
v1
.
8b
v4
.
8h
#
8
\
n
"
"
uqadd
v0
.
8b
v0
.
8b
v27
.
8b
\
n
"
"
uqadd
v1
.
8b
v1
.
8b
v27
.
8b
\
n
"
"
stp
d0
d1
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgb565
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v6
"
"
v24
"
"
v25
"
"
v26
"
"
v27
"
)
;
}
void
ARGB1555ToYRow_NEON
(
const
uint8_t
*
src_argb1555
uint8_t
*
dst_y
int
width
)
{
asm
volatile
(
"
movi
v4
.
16b
#
25
\
n
"
"
movi
v5
.
16b
#
129
\
n
"
"
movi
v6
.
16b
#
66
\
n
"
"
movi
v7
.
16b
#
16
\
n
"
"
1
:
\
n
"
"
ldp
q0
q3
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
RGB555TOARGB
"
umull
v16
.
8h
v0
.
8b
v4
.
8b
\
n
"
"
umull2
v17
.
8h
v0
.
16b
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umlal
v16
.
8h
v1
.
8b
v5
.
8b
\
n
"
"
umlal2
v17
.
8h
v1
.
16b
v5
.
16b
\
n
"
"
umlal
v16
.
8h
v2
.
8b
v6
.
8b
\
n
"
"
umlal2
v17
.
8h
v2
.
16b
v6
.
16b
\
n
"
"
uqrshrn
v0
.
8b
v16
.
8h
#
8
\
n
"
"
uqrshrn2
v0
.
16b
v17
.
8h
#
8
\
n
"
"
uqadd
v0
.
16b
v0
.
16b
v7
.
16b
\
n
"
"
str
q0
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb1555
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v16
"
"
v17
"
"
v29
"
)
;
}
void
ARGB4444ToYRow_NEON
(
const
uint8_t
*
src_argb4444
uint8_t
*
dst_y
int
width
)
{
asm
volatile
(
"
movi
v24
.
16b
#
25
\
n
"
"
movi
v25
.
16b
#
129
\
n
"
"
movi
v26
.
16b
#
66
\
n
"
"
movi
v27
.
16b
#
16
\
n
"
"
1
:
\
n
"
"
ldp
q0
q3
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
ARGB4444TORGB
"
umull
v16
.
8h
v0
.
8b
v24
.
8b
\
n
"
"
umull2
v17
.
8h
v0
.
16b
v24
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umlal
v16
.
8h
v1
.
8b
v25
.
8b
\
n
"
"
umlal2
v17
.
8h
v1
.
16b
v25
.
16b
\
n
"
"
umlal
v16
.
8h
v2
.
8b
v26
.
8b
\
n
"
"
umlal2
v17
.
8h
v2
.
16b
v26
.
16b
\
n
"
"
uqrshrn
v0
.
8b
v16
.
8h
#
8
\
n
"
"
uqrshrn2
v0
.
16b
v17
.
8h
#
8
\
n
"
"
uqadd
v0
.
16b
v0
.
16b
v27
.
16b
\
n
"
"
str
q0
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb4444
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v24
"
"
v25
"
"
v26
"
"
v27
"
)
;
}
struct
RgbConstants
{
uint8_t
kRGBToY
[
4
]
;
uint16_t
kAddY
;
}
;
static
void
ARGBToYMatrixRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
const
struct
RgbConstants
*
rgbconstants
)
{
asm
volatile
(
"
ldr
d0
[
%
3
]
\
n
"
"
dup
v6
.
16b
v0
.
b
[
0
]
\
n
"
"
dup
v7
.
16b
v0
.
b
[
1
]
\
n
"
"
dup
v16
.
16b
v0
.
b
[
2
]
\
n
"
"
dup
v17
.
8h
v0
.
h
[
2
]
\
n
"
"
1
:
\
n
"
"
ld4
{
v2
.
16b
v3
.
16b
v4
.
16b
v5
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
umull
v0
.
8h
v2
.
8b
v6
.
8b
\
n
"
"
umull2
v1
.
8h
v2
.
16b
v6
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umlal
v0
.
8h
v3
.
8b
v7
.
8b
\
n
"
"
umlal2
v1
.
8h
v3
.
16b
v7
.
16b
\
n
"
"
umlal
v0
.
8h
v4
.
8b
v16
.
8b
\
n
"
"
umlal2
v1
.
8h
v4
.
16b
v16
.
16b
\
n
"
"
addhn
v0
.
8b
v0
.
8h
v17
.
8h
\
n
"
"
addhn
v1
.
8b
v1
.
8h
v17
.
8h
\
n
"
"
st1
{
v0
.
8b
v1
.
8b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
rgbconstants
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v16
"
"
v17
"
)
;
}
static
void
ARGBToYMatrixRow_NEON_DotProd
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
const
struct
RgbConstants
*
rgbconstants
)
{
asm
volatile
(
"
ldr
d0
[
%
3
]
\
n
"
"
dup
v16
.
4s
v0
.
s
[
0
]
\
n
"
"
dup
v17
.
8h
v0
.
h
[
2
]
\
n
"
"
1
:
\
n
"
"
ld1
{
v4
.
16b
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
movi
v0
.
16b
#
0
\
n
"
"
movi
v1
.
16b
#
0
\
n
"
"
movi
v2
.
16b
#
0
\
n
"
"
movi
v3
.
16b
#
0
\
n
"
"
udot
v0
.
4s
v4
.
16b
v16
.
16b
\
n
"
"
udot
v1
.
4s
v5
.
16b
v16
.
16b
\
n
"
"
udot
v2
.
4s
v6
.
16b
v16
.
16b
\
n
"
"
udot
v3
.
4s
v7
.
16b
v16
.
16b
\
n
"
"
uzp1
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
uzp1
v1
.
8h
v2
.
8h
v3
.
8h
\
n
"
"
addhn
v0
.
8b
v0
.
8h
v17
.
8h
\
n
"
"
addhn
v1
.
8b
v1
.
8h
v17
.
8h
\
n
"
"
st1
{
v0
.
8b
v1
.
8b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
rgbconstants
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v16
"
"
v17
"
)
;
}
static
const
struct
RgbConstants
kRgb24JPEGConstants
=
{
{
29
150
77
0
}
0x0080
}
;
static
const
struct
RgbConstants
kRgb24JPEGDotProdConstants
=
{
{
0
29
150
77
}
0x0080
}
;
static
const
struct
RgbConstants
kRawJPEGConstants
=
{
{
77
150
29
0
}
0x0080
}
;
static
const
struct
RgbConstants
kRgb24I601Constants
=
{
{
25
129
66
0
}
0x1080
}
;
static
const
struct
RgbConstants
kRgb24I601DotProdConstants
=
{
{
0
25
129
66
}
0x1080
}
;
static
const
struct
RgbConstants
kRawI601Constants
=
{
{
66
129
25
0
}
0x1080
}
;
static
const
struct
RgbConstants
kRawI601DotProdConstants
=
{
{
0
66
129
25
}
0x1080
}
;
void
ARGBToYRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
)
{
ARGBToYMatrixRow_NEON
(
src_argb
dst_y
width
&
kRgb24I601Constants
)
;
}
void
ARGBToYJRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_yj
int
width
)
{
ARGBToYMatrixRow_NEON
(
src_argb
dst_yj
width
&
kRgb24JPEGConstants
)
;
}
void
ABGRToYRow_NEON
(
const
uint8_t
*
src_abgr
uint8_t
*
dst_y
int
width
)
{
ARGBToYMatrixRow_NEON
(
src_abgr
dst_y
width
&
kRawI601Constants
)
;
}
void
ABGRToYJRow_NEON
(
const
uint8_t
*
src_abgr
uint8_t
*
dst_yj
int
width
)
{
ARGBToYMatrixRow_NEON
(
src_abgr
dst_yj
width
&
kRawJPEGConstants
)
;
}
void
ARGBToYRow_NEON_DotProd
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
)
{
ARGBToYMatrixRow_NEON_DotProd
(
src_argb
dst_y
width
&
kRgb24I601Constants
)
;
}
void
ARGBToYJRow_NEON_DotProd
(
const
uint8_t
*
src_argb
uint8_t
*
dst_yj
int
width
)
{
ARGBToYMatrixRow_NEON_DotProd
(
src_argb
dst_yj
width
&
kRgb24JPEGConstants
)
;
}
void
ABGRToYRow_NEON_DotProd
(
const
uint8_t
*
src_abgr
uint8_t
*
dst_y
int
width
)
{
ARGBToYMatrixRow_NEON_DotProd
(
src_abgr
dst_y
width
&
kRawI601Constants
)
;
}
void
ABGRToYJRow_NEON_DotProd
(
const
uint8_t
*
src_abgr
uint8_t
*
dst_yj
int
width
)
{
ARGBToYMatrixRow_NEON_DotProd
(
src_abgr
dst_yj
width
&
kRawJPEGConstants
)
;
}
static
void
RGBAToYMatrixRow_NEON
(
const
uint8_t
*
src_rgba
uint8_t
*
dst_y
int
width
const
struct
RgbConstants
*
rgbconstants
)
{
asm
volatile
(
"
ldr
d0
[
%
3
]
\
n
"
"
dup
v6
.
16b
v0
.
b
[
0
]
\
n
"
"
dup
v7
.
16b
v0
.
b
[
1
]
\
n
"
"
dup
v16
.
16b
v0
.
b
[
2
]
\
n
"
"
dup
v17
.
8h
v0
.
h
[
2
]
\
n
"
"
1
:
\
n
"
"
ld4
{
v1
.
16b
v2
.
16b
v3
.
16b
v4
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
umull
v0
.
8h
v2
.
8b
v6
.
8b
\
n
"
"
umull2
v1
.
8h
v2
.
16b
v6
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umlal
v0
.
8h
v3
.
8b
v7
.
8b
\
n
"
"
umlal2
v1
.
8h
v3
.
16b
v7
.
16b
\
n
"
"
umlal
v0
.
8h
v4
.
8b
v16
.
8b
\
n
"
"
umlal2
v1
.
8h
v4
.
16b
v16
.
16b
\
n
"
"
addhn
v0
.
8b
v0
.
8h
v17
.
8h
\
n
"
"
addhn
v1
.
8b
v1
.
8h
v17
.
8h
\
n
"
"
st1
{
v0
.
8b
v1
.
8b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgba
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
rgbconstants
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v16
"
"
v17
"
)
;
}
void
RGBAToYRow_NEON
(
const
uint8_t
*
src_rgba
uint8_t
*
dst_y
int
width
)
{
RGBAToYMatrixRow_NEON
(
src_rgba
dst_y
width
&
kRgb24I601Constants
)
;
}
void
RGBAToYJRow_NEON
(
const
uint8_t
*
src_rgba
uint8_t
*
dst_yj
int
width
)
{
RGBAToYMatrixRow_NEON
(
src_rgba
dst_yj
width
&
kRgb24JPEGConstants
)
;
}
void
BGRAToYRow_NEON
(
const
uint8_t
*
src_bgra
uint8_t
*
dst_y
int
width
)
{
RGBAToYMatrixRow_NEON
(
src_bgra
dst_y
width
&
kRawI601Constants
)
;
}
void
RGBAToYRow_NEON_DotProd
(
const
uint8_t
*
src_rgba
uint8_t
*
dst_y
int
width
)
{
ARGBToYMatrixRow_NEON_DotProd
(
src_rgba
dst_y
width
&
kRgb24I601DotProdConstants
)
;
}
void
RGBAToYJRow_NEON_DotProd
(
const
uint8_t
*
src_rgba
uint8_t
*
dst_yj
int
width
)
{
ARGBToYMatrixRow_NEON_DotProd
(
src_rgba
dst_yj
width
&
kRgb24JPEGDotProdConstants
)
;
}
void
BGRAToYRow_NEON_DotProd
(
const
uint8_t
*
src_bgra
uint8_t
*
dst_y
int
width
)
{
ARGBToYMatrixRow_NEON_DotProd
(
src_bgra
dst_y
width
&
kRawI601DotProdConstants
)
;
}
static
void
RGBToYMatrixRow_NEON
(
const
uint8_t
*
src_rgb
uint8_t
*
dst_y
int
width
const
struct
RgbConstants
*
rgbconstants
)
{
asm
volatile
(
"
ldr
d0
[
%
3
]
\
n
"
"
dup
v5
.
16b
v0
.
b
[
0
]
\
n
"
"
dup
v6
.
16b
v0
.
b
[
1
]
\
n
"
"
dup
v7
.
16b
v0
.
b
[
2
]
\
n
"
"
dup
v16
.
8h
v0
.
h
[
2
]
\
n
"
"
1
:
\
n
"
"
ld3
{
v2
.
16b
v3
.
16b
v4
.
16b
}
[
%
0
]
#
48
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
umull
v0
.
8h
v2
.
8b
v5
.
8b
\
n
"
"
umull2
v1
.
8h
v2
.
16b
v5
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umlal
v0
.
8h
v3
.
8b
v6
.
8b
\
n
"
"
umlal2
v1
.
8h
v3
.
16b
v6
.
16b
\
n
"
"
umlal
v0
.
8h
v4
.
8b
v7
.
8b
\
n
"
"
umlal2
v1
.
8h
v4
.
16b
v7
.
16b
\
n
"
"
addhn
v0
.
8b
v0
.
8h
v16
.
8h
\
n
"
"
addhn
v1
.
8b
v1
.
8h
v16
.
8h
\
n
"
"
st1
{
v0
.
8b
v1
.
8b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_rgb
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
rgbconstants
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v16
"
)
;
}
void
RGB24ToYJRow_NEON
(
const
uint8_t
*
src_rgb24
uint8_t
*
dst_yj
int
width
)
{
RGBToYMatrixRow_NEON
(
src_rgb24
dst_yj
width
&
kRgb24JPEGConstants
)
;
}
void
RAWToYJRow_NEON
(
const
uint8_t
*
src_raw
uint8_t
*
dst_yj
int
width
)
{
RGBToYMatrixRow_NEON
(
src_raw
dst_yj
width
&
kRawJPEGConstants
)
;
}
void
RGB24ToYRow_NEON
(
const
uint8_t
*
src_rgb24
uint8_t
*
dst_y
int
width
)
{
RGBToYMatrixRow_NEON
(
src_rgb24
dst_y
width
&
kRgb24I601Constants
)
;
}
void
RAWToYRow_NEON
(
const
uint8_t
*
src_raw
uint8_t
*
dst_y
int
width
)
{
RGBToYMatrixRow_NEON
(
src_raw
dst_y
width
&
kRawI601Constants
)
;
}
void
InterpolateRow_NEON
(
uint8_t
*
dst_ptr
const
uint8_t
*
src_ptr
ptrdiff_t
src_stride
int
dst_width
int
source_y_fraction
)
{
int
y1_fraction
=
source_y_fraction
;
int
y0_fraction
=
256
-
y1_fraction
;
const
uint8_t
*
src_ptr1
=
src_ptr
+
src_stride
;
asm
volatile
(
"
cmp
%
w4
#
0
\
n
"
"
b
.
eq
100f
\
n
"
"
cmp
%
w4
#
128
\
n
"
"
b
.
eq
50f
\
n
"
"
dup
v5
.
16b
%
w4
\
n
"
"
dup
v4
.
16b
%
w5
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
2
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
umull
v2
.
8h
v0
.
8b
v4
.
8b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
umull2
v3
.
8h
v0
.
16b
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
umlal
v2
.
8h
v1
.
8b
v5
.
8b
\
n
"
"
umlal2
v3
.
8h
v1
.
16b
v5
.
16b
\
n
"
"
rshrn
v0
.
8b
v2
.
8h
#
8
\
n
"
"
rshrn2
v0
.
16b
v3
.
8h
#
8
\
n
"
"
st1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
"
b
99f
\
n
"
"
50
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
2
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
urhadd
v0
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
st1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
b
.
gt
50b
\
n
"
"
b
99f
\
n
"
"
100
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
1
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
st1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
b
.
gt
100b
\
n
"
"
99
:
\
n
"
:
"
+
r
"
(
dst_ptr
)
/
/
%
0
"
+
r
"
(
src_ptr
)
/
/
%
1
"
+
r
"
(
src_ptr1
)
/
/
%
2
"
+
r
"
(
dst_width
)
/
/
%
3
"
+
r
"
(
y1_fraction
)
/
/
%
4
"
+
r
"
(
y0_fraction
)
/
/
%
5
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v3
"
"
v4
"
"
v5
"
)
;
}
void
InterpolateRow_16_NEON
(
uint16_t
*
dst_ptr
const
uint16_t
*
src_ptr
ptrdiff_t
src_stride
int
dst_width
int
source_y_fraction
)
{
int
y1_fraction
=
source_y_fraction
;
int
y0_fraction
=
256
-
y1_fraction
;
const
uint16_t
*
src_ptr1
=
src_ptr
+
src_stride
;
asm
volatile
(
"
cmp
%
w4
#
0
\
n
"
"
b
.
eq
100f
\
n
"
"
cmp
%
w4
#
128
\
n
"
"
b
.
eq
50f
\
n
"
"
dup
v5
.
8h
%
w4
\
n
"
"
dup
v4
.
8h
%
w5
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
8h
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v1
.
8h
}
[
%
2
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
umull
v2
.
4s
v0
.
4h
v4
.
4h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
umull2
v3
.
4s
v0
.
8h
v4
.
8h
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
umlal
v2
.
4s
v1
.
4h
v5
.
4h
\
n
"
"
umlal2
v3
.
4s
v1
.
8h
v5
.
8h
\
n
"
"
rshrn
v0
.
4h
v2
.
4s
#
8
\
n
"
"
rshrn2
v0
.
8h
v3
.
4s
#
8
\
n
"
"
st1
{
v0
.
8h
}
[
%
0
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
"
b
99f
\
n
"
"
50
:
\
n
"
"
ld1
{
v0
.
8h
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v1
.
8h
}
[
%
2
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
urhadd
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
st1
{
v0
.
8h
}
[
%
0
]
#
16
\
n
"
"
b
.
gt
50b
\
n
"
"
b
99f
\
n
"
"
100
:
\
n
"
"
ld1
{
v0
.
8h
}
[
%
1
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
st1
{
v0
.
8h
}
[
%
0
]
#
16
\
n
"
"
b
.
gt
100b
\
n
"
"
99
:
\
n
"
:
"
+
r
"
(
dst_ptr
)
/
/
%
0
"
+
r
"
(
src_ptr
)
/
/
%
1
"
+
r
"
(
src_ptr1
)
/
/
%
2
"
+
r
"
(
dst_width
)
/
/
%
3
:
"
r
"
(
y1_fraction
)
/
/
%
4
"
r
"
(
y0_fraction
)
/
/
%
5
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
)
;
}
void
InterpolateRow_16To8_NEON
(
uint8_t
*
dst_ptr
const
uint16_t
*
src_ptr
ptrdiff_t
src_stride
int
scale
int
dst_width
int
source_y_fraction
)
{
int
y1_fraction
=
source_y_fraction
;
int
y0_fraction
=
256
-
y1_fraction
;
const
uint16_t
*
src_ptr1
=
src_ptr
+
src_stride
;
int
shift
=
15
-
__builtin_clz
(
(
int32_t
)
scale
)
;
asm
volatile
(
"
dup
v6
.
8h
%
w6
\
n
"
"
cmp
%
w4
#
0
\
n
"
"
b
.
eq
100f
\
n
"
"
cmp
%
w4
#
128
\
n
"
"
b
.
eq
50f
\
n
"
"
dup
v5
.
8h
%
w4
\
n
"
"
dup
v4
.
8h
%
w5
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
8h
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v1
.
8h
}
[
%
2
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
umull
v2
.
4s
v0
.
4h
v4
.
4h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
umull2
v3
.
4s
v0
.
8h
v4
.
8h
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
umlal
v2
.
4s
v1
.
4h
v5
.
4h
\
n
"
"
umlal2
v3
.
4s
v1
.
8h
v5
.
8h
\
n
"
"
rshrn
v0
.
4h
v2
.
4s
#
8
\
n
"
"
rshrn2
v0
.
8h
v3
.
4s
#
8
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v6
.
8h
\
n
"
"
uqxtn
v0
.
8b
v0
.
8h
\
n
"
"
st1
{
v0
.
8b
}
[
%
0
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
"
b
99f
\
n
"
"
50
:
\
n
"
"
ld1
{
v0
.
8h
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v1
.
8h
}
[
%
2
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
urhadd
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v6
.
8h
\
n
"
"
uqxtn
v0
.
8b
v0
.
8h
\
n
"
"
st1
{
v0
.
8b
}
[
%
0
]
#
8
\
n
"
"
b
.
gt
50b
\
n
"
"
b
99f
\
n
"
"
100
:
\
n
"
"
ldr
q0
[
%
1
]
#
16
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v2
.
8h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uqxtn
v0
.
8b
v0
.
8h
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
str
d0
[
%
0
]
#
8
\
n
"
"
b
.
gt
100b
\
n
"
"
99
:
\
n
"
:
"
+
r
"
(
dst_ptr
)
/
/
%
0
"
+
r
"
(
src_ptr
)
/
/
%
1
"
+
r
"
(
src_ptr1
)
/
/
%
2
"
+
r
"
(
dst_width
)
/
/
%
3
:
"
r
"
(
y1_fraction
)
/
/
%
4
"
r
"
(
y0_fraction
)
/
/
%
5
"
r
"
(
shift
)
/
/
%
6
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
)
;
}
void
ARGBBlendRow_NEON
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
subs
%
w3
%
w3
#
8
\
n
"
"
b
.
lt
89f
\
n
"
"
8
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
ld4
{
v4
.
8b
v5
.
8b
v6
.
8b
v7
.
8b
}
[
%
1
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
umull
v16
.
8h
v4
.
8b
v3
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umull
v17
.
8h
v5
.
8b
v3
.
8b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
umull
v18
.
8h
v6
.
8b
v3
.
8b
\
n
"
"
uqrshrn
v16
.
8b
v16
.
8h
#
8
\
n
"
"
uqrshrn
v17
.
8b
v17
.
8h
#
8
\
n
"
"
uqrshrn
v18
.
8b
v18
.
8h
#
8
\
n
"
"
uqsub
v4
.
8b
v4
.
8b
v16
.
8b
\
n
"
"
uqsub
v5
.
8b
v5
.
8b
v17
.
8b
\
n
"
"
uqsub
v6
.
8b
v6
.
8b
v18
.
8b
\
n
"
"
uqadd
v0
.
8b
v0
.
8b
v4
.
8b
\
n
"
"
uqadd
v1
.
8b
v1
.
8b
v5
.
8b
\
n
"
"
uqadd
v2
.
8b
v2
.
8b
v6
.
8b
\
n
"
"
movi
v3
.
8b
#
255
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
2
]
#
32
\
n
"
"
b
.
ge
8b
\
n
"
"
89
:
\
n
"
"
adds
%
w3
%
w3
#
8
-
1
\
n
"
"
b
.
lt
99f
\
n
"
"
1
:
\
n
"
"
ld4
{
v0
.
b
v1
.
b
v2
.
b
v3
.
b
}
[
0
]
[
%
0
]
#
4
\
n
"
"
ld4
{
v4
.
b
v5
.
b
v6
.
b
v7
.
b
}
[
0
]
[
%
1
]
#
4
\
n
"
"
subs
%
w3
%
w3
#
1
\
n
"
"
umull
v16
.
8h
v4
.
8b
v3
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umull
v17
.
8h
v5
.
8b
v3
.
8b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
umull
v18
.
8h
v6
.
8b
v3
.
8b
\
n
"
"
uqrshrn
v16
.
8b
v16
.
8h
#
8
\
n
"
"
uqrshrn
v17
.
8b
v17
.
8h
#
8
\
n
"
"
uqrshrn
v18
.
8b
v18
.
8h
#
8
\
n
"
"
uqsub
v4
.
8b
v4
.
8b
v16
.
8b
\
n
"
"
uqsub
v5
.
8b
v5
.
8b
v17
.
8b
\
n
"
"
uqsub
v6
.
8b
v6
.
8b
v18
.
8b
\
n
"
"
uqadd
v0
.
8b
v0
.
8b
v4
.
8b
\
n
"
"
uqadd
v1
.
8b
v1
.
8b
v5
.
8b
\
n
"
"
uqadd
v2
.
8b
v2
.
8b
v6
.
8b
\
n
"
"
movi
v3
.
8b
#
255
\
n
"
"
st4
{
v0
.
b
v1
.
b
v2
.
b
v3
.
b
}
[
0
]
[
%
2
]
#
4
\
n
"
"
b
.
ge
1b
\
n
"
"
99
:
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
src_argb1
)
/
/
%
1
"
+
r
"
(
dst_argb
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v16
"
"
v17
"
"
v18
"
)
;
}
void
ARGBAttenuateRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v7
.
8h
#
0x00ff
\
n
"
"
1
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
umull
v4
.
8h
v0
.
8b
v3
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umull
v5
.
8h
v1
.
8b
v3
.
8b
\
n
"
"
umull
v6
.
8h
v2
.
8b
v3
.
8b
\
n
"
"
addhn
v0
.
8b
v4
.
8h
v7
.
8h
\
n
"
"
addhn
v1
.
8b
v5
.
8h
v7
.
8h
\
n
"
"
addhn
v2
.
8b
v6
.
8h
v7
.
8h
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
void
ARGBQuantizeRow_NEON
(
uint8_t
*
dst_argb
int
scale
int
interval_size
int
interval_offset
int
width
)
{
asm
volatile
(
"
dup
v4
.
8h
%
w2
\
n
"
"
ushr
v4
.
8h
v4
.
8h
#
1
\
n
"
"
dup
v5
.
8h
%
w3
\
n
"
"
dup
v6
.
8h
%
w4
\
n
"
"
1
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
\
n
"
"
subs
%
w1
%
w1
#
8
\
n
"
"
uxtl
v0
.
8h
v0
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uxtl
v1
.
8h
v1
.
8b
\
n
"
"
uxtl
v2
.
8h
v2
.
8b
\
n
"
"
sqdmulh
v0
.
8h
v0
.
8h
v4
.
8h
\
n
"
"
sqdmulh
v1
.
8h
v1
.
8h
v4
.
8h
\
n
"
"
sqdmulh
v2
.
8h
v2
.
8h
v4
.
8h
\
n
"
"
mul
v0
.
8h
v0
.
8h
v5
.
8h
\
n
"
"
mul
v1
.
8h
v1
.
8h
v5
.
8h
\
n
"
"
mul
v2
.
8h
v2
.
8h
v5
.
8h
\
n
"
"
add
v0
.
8h
v0
.
8h
v6
.
8h
\
n
"
"
add
v1
.
8h
v1
.
8h
v6
.
8h
\
n
"
"
add
v2
.
8h
v2
.
8h
v6
.
8h
\
n
"
"
uqxtn
v0
.
8b
v0
.
8h
\
n
"
"
uqxtn
v1
.
8b
v1
.
8h
\
n
"
"
uqxtn
v2
.
8b
v2
.
8h
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
dst_argb
)
/
/
%
0
"
+
r
"
(
width
)
/
/
%
1
:
"
r
"
(
scale
)
/
/
%
2
"
r
"
(
interval_size
)
/
/
%
3
"
r
"
(
interval_offset
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
)
;
}
void
ARGBShadeRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
uint32_t
value
)
{
asm
volatile
(
"
dup
v0
.
4s
%
w3
\
n
"
"
zip1
v0
.
16b
v0
.
16b
v0
.
16b
\
n
"
"
ushr
v0
.
8h
v0
.
8h
#
1
\
n
"
"
1
:
\
n
"
"
ld1
{
v4
.
8b
v5
.
8b
v6
.
8b
v7
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
uxtl
v4
.
8h
v4
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uxtl
v5
.
8h
v5
.
8b
\
n
"
"
uxtl
v6
.
8h
v6
.
8b
\
n
"
"
uxtl
v7
.
8h
v7
.
8b
\
n
"
"
sqrdmulh
v4
.
8h
v4
.
8h
v0
.
8h
\
n
"
"
sqrdmulh
v5
.
8h
v5
.
8h
v0
.
8h
\
n
"
"
sqrdmulh
v6
.
8h
v6
.
8h
v0
.
8h
\
n
"
"
sqrdmulh
v7
.
8h
v7
.
8h
v0
.
8h
\
n
"
"
uqxtn
v4
.
8b
v4
.
8h
\
n
"
"
uqxtn
v5
.
8b
v5
.
8h
\
n
"
"
uqxtn
v6
.
8b
v6
.
8h
\
n
"
"
uqxtn
v7
.
8b
v7
.
8h
\
n
"
"
st1
{
v4
.
8b
v5
.
8b
v6
.
8b
v7
.
8b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
value
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
void
ARGBGrayRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v24
.
8b
#
29
\
n
"
"
movi
v25
.
8b
#
150
\
n
"
"
movi
v26
.
8b
#
77
\
n
"
"
1
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
umull
v4
.
8h
v0
.
8b
v24
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umlal
v4
.
8h
v1
.
8b
v25
.
8b
\
n
"
"
umlal
v4
.
8h
v2
.
8b
v26
.
8b
\
n
"
"
uqrshrn
v0
.
8b
v4
.
8h
#
8
\
n
"
"
mov
v1
.
8b
v0
.
8b
\
n
"
"
mov
v2
.
8b
v0
.
8b
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v24
"
"
v25
"
"
v26
"
)
;
}
static
const
uvec8
kARGBGrayRowCoeffs
=
{
29
150
77
0
}
;
static
const
uvec8
kARGBGrayRowIndices
=
{
0
0
0
19
2
2
2
23
4
4
4
27
6
6
6
31
}
;
void
ARGBGrayRow_NEON_DotProd
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
ld1r
{
v24
.
4s
}
[
%
[
coeffs
]
]
\
n
"
"
ldr
q25
[
%
[
indices
]
]
\
n
"
"
1
:
\
n
"
"
ldp
q1
q3
[
%
[
src
]
]
#
32
\
n
"
"
subs
%
w
[
width
]
%
w
[
width
]
#
8
\
n
"
"
movi
v0
.
4s
#
0
\
n
"
"
movi
v2
.
4s
#
0
\
n
"
"
udot
v0
.
4s
v1
.
16b
v24
.
16b
\
n
"
"
udot
v2
.
4s
v3
.
16b
v24
.
16b
\
n
"
"
prfm
pldl1keep
[
%
[
src
]
448
]
\
n
"
"
uqrshrn
v0
.
8b
v0
.
8h
#
8
\
n
"
"
uqrshrn
v2
.
8b
v2
.
8h
#
8
\
n
"
"
tbl
v0
.
16b
{
v0
.
16b
v1
.
16b
}
v25
.
16b
\
n
"
"
tbl
v1
.
16b
{
v2
.
16b
v3
.
16b
}
v25
.
16b
\
n
"
"
stp
q0
q1
[
%
[
dst
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src
]
"
+
r
"
(
src_argb
)
[
dst
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
coeffs
]
"
r
"
(
&
kARGBGrayRowCoeffs
)
[
indices
]
"
r
"
(
&
kARGBGrayRowIndices
)
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v24
"
"
v25
"
)
;
}
void
ARGBSepiaRow_NEON
(
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v20
.
8b
#
17
\
n
"
"
movi
v21
.
8b
#
68
\
n
"
"
movi
v22
.
8b
#
35
\
n
"
"
movi
v24
.
8b
#
22
\
n
"
"
movi
v25
.
8b
#
88
\
n
"
"
movi
v26
.
8b
#
45
\
n
"
"
movi
v28
.
8b
#
24
\
n
"
"
movi
v29
.
8b
#
98
\
n
"
"
movi
v30
.
8b
#
50
\
n
"
"
1
:
\
n
"
"
ld4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
\
n
"
"
subs
%
w1
%
w1
#
8
\
n
"
"
umull
v4
.
8h
v0
.
8b
v20
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umlal
v4
.
8h
v1
.
8b
v21
.
8b
\
n
"
"
umlal
v4
.
8h
v2
.
8b
v22
.
8b
\
n
"
"
umull
v5
.
8h
v0
.
8b
v24
.
8b
\
n
"
"
umlal
v5
.
8h
v1
.
8b
v25
.
8b
\
n
"
"
umlal
v5
.
8h
v2
.
8b
v26
.
8b
\
n
"
"
umull
v6
.
8h
v0
.
8b
v28
.
8b
\
n
"
"
umlal
v6
.
8h
v1
.
8b
v29
.
8b
\
n
"
"
umlal
v6
.
8h
v2
.
8b
v30
.
8b
\
n
"
"
uqshrn
v0
.
8b
v4
.
8h
#
7
\
n
"
"
uqshrn
v1
.
8b
v5
.
8h
#
7
\
n
"
"
uqshrn
v2
.
8b
v6
.
8h
#
7
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
dst_argb
)
/
/
%
0
"
+
r
"
(
width
)
/
/
%
1
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v24
"
"
v25
"
"
v26
"
"
v28
"
"
v29
"
"
v30
"
)
;
}
static
const
uvec8
kARGBSepiaRowCoeffs
=
{
17
68
35
0
22
88
45
0
24
98
50
0
}
;
static
const
uvec8
kARGBSepiaRowAlphaIndices
=
{
3
7
11
15
19
23
27
31
}
;
void
ARGBSepiaRow_NEON_DotProd
(
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
ld3r
{
v20
.
4s
v21
.
4s
v22
.
4s
}
[
%
[
coeffs
]
]
\
n
"
"
ldr
d23
[
%
[
indices
]
]
\
n
"
"
1
:
\
n
"
"
ldp
q0
q1
[
%
[
dst
]
]
\
n
"
"
subs
%
w1
%
w1
#
8
\
n
"
"
movi
v2
.
4s
#
0
\
n
"
"
movi
v3
.
4s
#
0
\
n
"
"
movi
v4
.
4s
#
0
\
n
"
"
movi
v5
.
4s
#
0
\
n
"
"
movi
v6
.
4s
#
0
\
n
"
"
movi
v7
.
4s
#
0
\
n
"
"
udot
v2
.
4s
v0
.
16b
v20
.
16b
\
n
"
"
udot
v3
.
4s
v1
.
16b
v20
.
16b
\
n
"
"
udot
v4
.
4s
v0
.
16b
v21
.
16b
\
n
"
"
udot
v5
.
4s
v1
.
16b
v21
.
16b
\
n
"
"
udot
v6
.
4s
v0
.
16b
v22
.
16b
\
n
"
"
udot
v7
.
4s
v1
.
16b
v22
.
16b
\
n
"
"
prfm
pldl1keep
[
%
[
dst
]
448
]
\
n
"
"
uzp1
v6
.
8h
v6
.
8h
v7
.
8h
\
n
"
"
uzp1
v5
.
8h
v4
.
8h
v5
.
8h
\
n
"
"
uzp1
v4
.
8h
v2
.
8h
v3
.
8h
\
n
"
"
tbl
v3
.
16b
{
v0
.
16b
v1
.
16b
}
v23
.
16b
\
n
"
"
uqshrn
v0
.
8b
v4
.
8h
#
7
\
n
"
"
uqshrn
v1
.
8b
v5
.
8h
#
7
\
n
"
"
uqshrn
v2
.
8b
v6
.
8h
#
7
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
[
dst
]
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
[
dst
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
coeffs
]
"
r
"
(
&
kARGBSepiaRowCoeffs
)
[
indices
]
"
r
"
(
&
kARGBSepiaRowAlphaIndices
)
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v20
"
"
v21
"
"
v22
"
"
v24
"
"
v25
"
"
v26
"
"
v28
"
"
v29
"
"
v30
"
)
;
}
void
ARGBColorMatrixRow_NEON
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
const
int8_t
*
matrix_argb
int
width
)
{
asm
volatile
(
"
ld1
{
v2
.
16b
}
[
%
3
]
\
n
"
"
sxtl
v0
.
8h
v2
.
8b
\
n
"
"
sxtl2
v1
.
8h
v2
.
16b
\
n
"
"
1
:
\
n
"
"
ld4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
uxtl
v16
.
8h
v16
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uxtl
v17
.
8h
v17
.
8b
\
n
"
"
uxtl
v18
.
8h
v18
.
8b
\
n
"
"
uxtl
v19
.
8h
v19
.
8b
\
n
"
"
mul
v22
.
8h
v16
.
8h
v0
.
h
[
0
]
\
n
"
"
mul
v23
.
8h
v16
.
8h
v0
.
h
[
4
]
\
n
"
"
mul
v24
.
8h
v16
.
8h
v1
.
h
[
0
]
\
n
"
"
mul
v25
.
8h
v16
.
8h
v1
.
h
[
4
]
\
n
"
"
mul
v4
.
8h
v17
.
8h
v0
.
h
[
1
]
\
n
"
"
mul
v5
.
8h
v17
.
8h
v0
.
h
[
5
]
\
n
"
"
mul
v6
.
8h
v17
.
8h
v1
.
h
[
1
]
\
n
"
"
mul
v7
.
8h
v17
.
8h
v1
.
h
[
5
]
\
n
"
"
sqadd
v22
.
8h
v22
.
8h
v4
.
8h
\
n
"
"
sqadd
v23
.
8h
v23
.
8h
v5
.
8h
\
n
"
"
sqadd
v24
.
8h
v24
.
8h
v6
.
8h
\
n
"
"
sqadd
v25
.
8h
v25
.
8h
v7
.
8h
\
n
"
"
mul
v4
.
8h
v18
.
8h
v0
.
h
[
2
]
\
n
"
"
mul
v5
.
8h
v18
.
8h
v0
.
h
[
6
]
\
n
"
"
mul
v6
.
8h
v18
.
8h
v1
.
h
[
2
]
\
n
"
"
mul
v7
.
8h
v18
.
8h
v1
.
h
[
6
]
\
n
"
"
sqadd
v22
.
8h
v22
.
8h
v4
.
8h
\
n
"
"
sqadd
v23
.
8h
v23
.
8h
v5
.
8h
\
n
"
"
sqadd
v24
.
8h
v24
.
8h
v6
.
8h
\
n
"
"
sqadd
v25
.
8h
v25
.
8h
v7
.
8h
\
n
"
"
mul
v4
.
8h
v19
.
8h
v0
.
h
[
3
]
\
n
"
"
mul
v5
.
8h
v19
.
8h
v0
.
h
[
7
]
\
n
"
"
mul
v6
.
8h
v19
.
8h
v1
.
h
[
3
]
\
n
"
"
mul
v7
.
8h
v19
.
8h
v1
.
h
[
7
]
\
n
"
"
sqadd
v22
.
8h
v22
.
8h
v4
.
8h
\
n
"
"
sqadd
v23
.
8h
v23
.
8h
v5
.
8h
\
n
"
"
sqadd
v24
.
8h
v24
.
8h
v6
.
8h
\
n
"
"
sqadd
v25
.
8h
v25
.
8h
v7
.
8h
\
n
"
"
sqshrun
v16
.
8b
v22
.
8h
#
6
\
n
"
"
sqshrun
v17
.
8b
v23
.
8h
#
6
\
n
"
"
sqshrun
v18
.
8b
v24
.
8h
#
6
\
n
"
"
sqshrun
v19
.
8b
v25
.
8h
#
6
\
n
"
"
st4
{
v16
.
8b
v17
.
8b
v18
.
8b
v19
.
8b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
dst_argb
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
matrix_argb
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
"
v22
"
"
v23
"
"
v24
"
"
v25
"
)
;
}
void
ARGBColorMatrixRow_NEON_I8MM
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
const
int8_t
*
matrix_argb
int
width
)
{
asm
volatile
(
"
ld1
{
v31
.
16b
}
[
%
[
matrix_argb
]
]
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
16b
v1
.
16b
}
[
%
[
src_argb
]
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
movi
v16
.
4s
#
0
\
n
"
"
movi
v17
.
4s
#
0
\
n
"
"
movi
v18
.
4s
#
0
\
n
"
"
movi
v19
.
4s
#
0
\
n
"
"
movi
v20
.
4s
#
0
\
n
"
"
movi
v21
.
4s
#
0
\
n
"
"
movi
v22
.
4s
#
0
\
n
"
"
movi
v23
.
4s
#
0
\
n
"
"
prfm
pldl1keep
[
%
[
src_argb
]
448
]
\
n
"
"
sudot
v16
.
4s
v31
.
16b
v0
.
4b
[
0
]
\
n
"
"
sudot
v17
.
4s
v31
.
16b
v0
.
4b
[
1
]
\
n
"
"
sudot
v18
.
4s
v31
.
16b
v0
.
4b
[
2
]
\
n
"
"
sudot
v19
.
4s
v31
.
16b
v0
.
4b
[
3
]
\
n
"
"
sudot
v20
.
4s
v31
.
16b
v1
.
4b
[
0
]
\
n
"
"
sudot
v21
.
4s
v31
.
16b
v1
.
4b
[
1
]
\
n
"
"
sudot
v22
.
4s
v31
.
16b
v1
.
4b
[
2
]
\
n
"
"
sudot
v23
.
4s
v31
.
16b
v1
.
4b
[
3
]
\
n
"
"
shrn
v16
.
4h
v16
.
4s
#
6
\
n
"
"
shrn
v18
.
4h
v18
.
4s
#
6
\
n
"
"
shrn
v20
.
4h
v20
.
4s
#
6
\
n
"
"
shrn
v22
.
4h
v22
.
4s
#
6
\
n
"
"
shrn2
v16
.
8h
v17
.
4s
#
6
\
n
"
"
shrn2
v18
.
8h
v19
.
4s
#
6
\
n
"
"
shrn2
v20
.
8h
v21
.
4s
#
6
\
n
"
"
shrn2
v22
.
8h
v23
.
4s
#
6
\
n
"
"
uqxtn
v16
.
8b
v16
.
8h
\
n
"
"
uqxtn
v18
.
8b
v18
.
8h
\
n
"
"
uqxtn
v20
.
8b
v20
.
8h
\
n
"
"
uqxtn
v22
.
8b
v22
.
8h
\
n
"
"
stp
d16
d18
[
%
[
dst_argb
]
]
#
16
\
n
"
"
stp
d20
d22
[
%
[
dst_argb
]
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
[
src_argb
]
"
+
r
"
(
src_argb
)
[
dst_argb
]
"
+
r
"
(
dst_argb
)
[
width
]
"
+
r
"
(
width
)
:
[
matrix_argb
]
"
r
"
(
matrix_argb
)
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v16
"
"
v17
"
"
v18
"
"
v19
"
"
v20
"
"
v21
"
"
v22
"
"
v23
"
"
v31
"
)
;
}
void
ARGBMultiplyRow_NEON
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
0
]
#
32
\
n
"
"
ld1
{
v4
.
8b
v5
.
8b
v6
.
8b
v7
.
8b
}
[
%
1
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
umull
v0
.
8h
v0
.
8b
v4
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
umull
v1
.
8h
v1
.
8b
v5
.
8b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
umull
v2
.
8h
v2
.
8b
v6
.
8b
\
n
"
"
umull
v3
.
8h
v3
.
8b
v7
.
8b
\
n
"
"
rshrn
v0
.
8b
v0
.
8h
#
8
\
n
"
"
rshrn
v1
.
8b
v1
.
8h
#
8
\
n
"
"
rshrn
v2
.
8b
v2
.
8h
#
8
\
n
"
"
rshrn
v3
.
8b
v3
.
8h
#
8
\
n
"
"
st1
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
src_argb1
)
/
/
%
1
"
+
r
"
(
dst_argb
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
void
ARGBAddRow_NEON
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
ldp
q4
q5
[
%
1
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uqadd
v0
.
16b
v0
.
16b
v4
.
16b
\
n
"
"
uqadd
v1
.
16b
v1
.
16b
v5
.
16b
\
n
"
"
stp
q0
q1
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
src_argb1
)
/
/
%
1
"
+
r
"
(
dst_argb
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
void
ARGBSubtractRow_NEON
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
ldp
q4
q5
[
%
1
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uqsub
v0
.
16b
v0
.
16b
v4
.
16b
\
n
"
"
uqsub
v1
.
16b
v1
.
16b
v5
.
16b
\
n
"
"
stp
q0
q1
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_argb
)
/
/
%
0
"
+
r
"
(
src_argb1
)
/
/
%
1
"
+
r
"
(
dst_argb
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
void
SobelRow_NEON
(
const
uint8_t
*
src_sobelx
const
uint8_t
*
src_sobely
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v3
.
8b
#
255
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
8b
}
[
%
0
]
#
8
\
n
"
"
ld1
{
v1
.
8b
}
[
%
1
]
#
8
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
uqadd
v0
.
8b
v0
.
8b
v1
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mov
v1
.
8b
v0
.
8b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
mov
v2
.
8b
v0
.
8b
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_sobelx
)
/
/
%
0
"
+
r
"
(
src_sobely
)
/
/
%
1
"
+
r
"
(
dst_argb
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
SobelToPlaneRow_NEON
(
const
uint8_t
*
src_sobelx
const
uint8_t
*
src_sobely
uint8_t
*
dst_y
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uqadd
v0
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
st1
{
v0
.
16b
}
[
%
2
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_sobelx
)
/
/
%
0
"
+
r
"
(
src_sobely
)
/
/
%
1
"
+
r
"
(
dst_y
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
)
;
}
void
SobelXYRow_NEON
(
const
uint8_t
*
src_sobelx
const
uint8_t
*
src_sobely
uint8_t
*
dst_argb
int
width
)
{
asm
volatile
(
"
movi
v3
.
8b
#
255
\
n
"
"
1
:
\
n
"
"
ld1
{
v2
.
8b
}
[
%
0
]
#
8
\
n
"
"
ld1
{
v0
.
8b
}
[
%
1
]
#
8
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uqadd
v1
.
8b
v0
.
8b
v2
.
8b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
st4
{
v0
.
8b
v1
.
8b
v2
.
8b
v3
.
8b
}
[
%
2
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_sobelx
)
/
/
%
0
"
+
r
"
(
src_sobely
)
/
/
%
1
"
+
r
"
(
dst_argb
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
SobelXRow_NEON
(
const
uint8_t
*
src_y0
const
uint8_t
*
src_y1
const
uint8_t
*
src_y2
uint8_t
*
dst_sobelx
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
8b
}
[
%
0
]
%
5
\
n
"
"
ld1
{
v1
.
8b
}
[
%
0
]
%
6
\
n
"
"
subs
%
w4
%
w4
#
8
\
n
"
"
usubl
v0
.
8h
v0
.
8b
v1
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
ld1
{
v2
.
8b
}
[
%
1
]
%
5
\
n
"
"
ld1
{
v3
.
8b
}
[
%
1
]
%
6
\
n
"
"
usubl
v1
.
8h
v2
.
8b
v3
.
8b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
add
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
add
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
ld1
{
v2
.
8b
}
[
%
2
]
%
5
\
n
"
"
ld1
{
v3
.
8b
}
[
%
2
]
%
6
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
usubl
v1
.
8h
v2
.
8b
v3
.
8b
\
n
"
"
add
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
abs
v0
.
8h
v0
.
8h
\
n
"
"
uqxtn
v0
.
8b
v0
.
8h
\
n
"
"
st1
{
v0
.
8b
}
[
%
3
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y0
)
/
/
%
0
"
+
r
"
(
src_y1
)
/
/
%
1
"
+
r
"
(
src_y2
)
/
/
%
2
"
+
r
"
(
dst_sobelx
)
/
/
%
3
"
+
r
"
(
width
)
/
/
%
4
:
"
r
"
(
2LL
)
/
/
%
5
"
r
"
(
6LL
)
/
/
%
6
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
/
/
Clobber
List
)
;
}
void
SobelYRow_NEON
(
const
uint8_t
*
src_y0
const
uint8_t
*
src_y1
uint8_t
*
dst_sobely
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
8b
}
[
%
0
]
%
4
\
n
"
"
ld1
{
v1
.
8b
}
[
%
1
]
%
4
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
usubl
v0
.
8h
v0
.
8b
v1
.
8b
\
n
"
"
ld1
{
v2
.
8b
}
[
%
0
]
%
4
\
n
"
"
ld1
{
v3
.
8b
}
[
%
1
]
%
4
\
n
"
"
usubl
v1
.
8h
v2
.
8b
v3
.
8b
\
n
"
"
add
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
add
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
ld1
{
v2
.
8b
}
[
%
0
]
%
5
\
n
"
"
ld1
{
v3
.
8b
}
[
%
1
]
%
5
\
n
"
"
usubl
v1
.
8h
v2
.
8b
v3
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
add
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
abs
v0
.
8h
v0
.
8h
\
n
"
"
uqxtn
v0
.
8b
v0
.
8h
\
n
"
"
st1
{
v0
.
8b
}
[
%
2
]
#
8
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y0
)
/
/
%
0
"
+
r
"
(
src_y1
)
/
/
%
1
"
+
r
"
(
dst_sobely
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
"
r
"
(
1LL
)
/
/
%
4
"
r
"
(
6LL
)
/
/
%
5
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
/
/
Clobber
List
)
;
}
void
HalfFloatRow_NEON
(
const
uint16_t
*
src
uint16_t
*
dst
float
scale
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
uxtl
v2
.
4s
v0
.
4h
\
n
"
"
uxtl
v4
.
4s
v1
.
4h
\
n
"
"
uxtl2
v3
.
4s
v0
.
8h
\
n
"
"
uxtl2
v5
.
4s
v1
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
scvtf
v2
.
4s
v2
.
4s
\
n
"
"
scvtf
v4
.
4s
v4
.
4s
\
n
"
"
scvtf
v3
.
4s
v3
.
4s
\
n
"
"
scvtf
v5
.
4s
v5
.
4s
\
n
"
"
fmul
v2
.
4s
v2
.
4s
%
3
.
s
[
0
]
\
n
"
"
fmul
v4
.
4s
v4
.
4s
%
3
.
s
[
0
]
\
n
"
"
fmul
v3
.
4s
v3
.
4s
%
3
.
s
[
0
]
\
n
"
"
fmul
v5
.
4s
v5
.
4s
%
3
.
s
[
0
]
\
n
"
"
uqshrn
v0
.
4h
v2
.
4s
#
13
\
n
"
"
uqshrn
v1
.
4h
v4
.
4s
#
13
\
n
"
"
uqshrn2
v0
.
8h
v3
.
4s
#
13
\
n
"
"
uqshrn2
v1
.
8h
v5
.
4s
#
13
\
n
"
"
stp
q0
q1
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
w
"
(
scale
*
1
.
9259299444e
-
34f
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
)
;
}
void
ByteToFloatRow_NEON
(
const
uint8_t
*
src
float
*
dst
float
scale
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v1
.
8b
}
[
%
0
]
#
8
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
uxtl
v1
.
8h
v1
.
8b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uxtl
v2
.
4s
v1
.
4h
\
n
"
"
uxtl2
v3
.
4s
v1
.
8h
\
n
"
"
scvtf
v2
.
4s
v2
.
4s
\
n
"
"
scvtf
v3
.
4s
v3
.
4s
\
n
"
"
fmul
v2
.
4s
v2
.
4s
%
3
.
s
[
0
]
\
n
"
"
fmul
v3
.
4s
v3
.
4s
%
3
.
s
[
0
]
\
n
"
"
st1
{
v2
.
16b
v3
.
16b
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
w
"
(
scale
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
ConvertFP16ToFP32Row_NEON
(
const
uint16_t
*
src
float
*
dst
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v1
.
8h
}
[
%
0
]
#
16
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
fcvtl
v2
.
4s
v1
.
4h
\
n
"
"
fcvtl2
v3
.
4s
v1
.
8h
\
n
"
"
stp
q2
q3
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
ConvertFP16ToFP32Column_NEON
(
const
uint16_t
*
src
int
src_stride
float
*
dst
int
width
)
{
asm
volatile
(
"
cmp
%
w2
#
8
\
n
"
"
b
.
lo
2f
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
h
}
[
0
]
[
%
0
]
%
3
\
n
"
"
ld1
{
v0
.
h
}
[
1
]
[
%
0
]
%
3
\
n
"
"
ld1
{
v0
.
h
}
[
2
]
[
%
0
]
%
3
\
n
"
"
ld1
{
v0
.
h
}
[
3
]
[
%
0
]
%
3
\
n
"
"
ld1
{
v1
.
h
}
[
0
]
[
%
0
]
%
3
\
n
"
"
ld1
{
v1
.
h
}
[
1
]
[
%
0
]
%
3
\
n
"
"
ld1
{
v1
.
h
}
[
2
]
[
%
0
]
%
3
\
n
"
"
ld1
{
v1
.
h
}
[
3
]
[
%
0
]
%
3
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
fcvtl
v2
.
4s
v0
.
4h
\
n
"
"
fcvtl
v3
.
4s
v1
.
4h
\
n
"
"
stp
q2
q3
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
"
cmp
%
w2
#
1
\
n
"
"
b
.
lo
3f
\
n
"
"
2
:
\
n
"
"
ld1
{
v1
.
h
}
[
0
]
[
%
0
]
%
3
\
n
"
"
subs
%
w2
%
w2
#
1
\
n
"
"
fcvtl
v2
.
4s
v1
.
4h
\
n
"
"
str
s2
[
%
1
]
#
4
\
n
"
"
b
.
gt
2b
\
n
"
"
3
:
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
(
ptrdiff_t
)
(
src_stride
*
2
)
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
ConvertFP32ToFP16Row_NEON
(
const
float
*
src
uint16_t
*
dst
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ldp
q2
q3
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
fcvtn
v1
.
4h
v2
.
4s
\
n
"
"
fcvtn2
v1
.
8h
v3
.
4s
\
n
"
"
str
q1
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
float
ScaleMaxSamples_NEON
(
const
float
*
src
float
*
dst
float
scale
int
width
)
{
float
fmax
;
asm
volatile
(
"
movi
v5
.
4s
#
0
\
n
"
"
movi
v6
.
4s
#
0
\
n
"
"
1
:
\
n
"
"
ld1
{
v1
.
4s
v2
.
4s
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
fmul
v3
.
4s
v1
.
4s
%
4
.
s
[
0
]
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
fmul
v4
.
4s
v2
.
4s
%
4
.
s
[
0
]
\
n
"
"
fmax
v5
.
4s
v5
.
4s
v1
.
4s
\
n
"
"
fmax
v6
.
4s
v6
.
4s
v2
.
4s
\
n
"
"
st1
{
v3
.
4s
v4
.
4s
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
"
fmax
v5
.
4s
v5
.
4s
v6
.
4s
\
n
"
"
fmaxv
%
s3
v5
.
4s
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
"
=
w
"
(
fmax
)
/
/
%
3
:
"
w
"
(
scale
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
)
;
return
fmax
;
}
float
ScaleSumSamples_NEON
(
const
float
*
src
float
*
dst
float
scale
int
width
)
{
float
fsum
;
asm
volatile
(
"
movi
v5
.
4s
#
0
\
n
"
"
movi
v6
.
4s
#
0
\
n
"
"
1
:
\
n
"
"
ld1
{
v1
.
4s
v2
.
4s
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
fmul
v3
.
4s
v1
.
4s
%
4
.
s
[
0
]
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
fmul
v4
.
4s
v2
.
4s
%
4
.
s
[
0
]
\
n
"
"
fmla
v5
.
4s
v1
.
4s
v1
.
4s
\
n
"
"
fmla
v6
.
4s
v2
.
4s
v2
.
4s
\
n
"
"
st1
{
v3
.
4s
v4
.
4s
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
"
faddp
v5
.
4s
v5
.
4s
v6
.
4s
\
n
"
"
faddp
v5
.
4s
v5
.
4s
v5
.
4s
\
n
"
"
faddp
%
3
.
4s
v5
.
4s
v5
.
4s
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
"
=
w
"
(
fsum
)
/
/
%
3
:
"
w
"
(
scale
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
)
;
return
fsum
;
}
void
ScaleSamples_NEON
(
const
float
*
src
float
*
dst
float
scale
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v1
.
4s
v2
.
4s
}
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
fmul
v1
.
4s
v1
.
4s
%
3
.
s
[
0
]
\
n
"
"
fmul
v2
.
4s
v2
.
4s
%
3
.
s
[
0
]
\
n
"
"
st1
{
v1
.
4s
v2
.
4s
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
w
"
(
scale
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v1
"
"
v2
"
)
;
}
void
GaussCol_NEON
(
const
uint16_t
*
src0
const
uint16_t
*
src1
const
uint16_t
*
src2
const
uint16_t
*
src3
const
uint16_t
*
src4
uint32_t
*
dst
int
width
)
{
asm
volatile
(
"
movi
v6
.
8h
#
4
\
n
"
"
movi
v7
.
8h
#
6
\
n
"
"
1
:
\
n
"
"
ld1
{
v1
.
8h
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v2
.
8h
}
[
%
4
]
#
16
\
n
"
"
subs
%
w6
%
w6
#
8
\
n
"
"
uaddl
v0
.
4s
v1
.
4h
v2
.
4h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddl2
v1
.
4s
v1
.
8h
v2
.
8h
\
n
"
"
ld1
{
v2
.
8h
}
[
%
1
]
#
16
\
n
"
"
umlal
v0
.
4s
v2
.
4h
v6
.
4h
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
umlal2
v1
.
4s
v2
.
8h
v6
.
8h
\
n
"
"
ld1
{
v2
.
8h
}
[
%
2
]
#
16
\
n
"
"
umlal
v0
.
4s
v2
.
4h
v7
.
4h
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
umlal2
v1
.
4s
v2
.
8h
v7
.
8h
\
n
"
"
ld1
{
v2
.
8h
}
[
%
3
]
#
16
\
n
"
"
umlal
v0
.
4s
v2
.
4h
v6
.
4h
\
n
"
"
prfm
pldl1keep
[
%
3
448
]
\
n
"
"
umlal2
v1
.
4s
v2
.
8h
v6
.
8h
\
n
"
"
st1
{
v0
.
4s
v1
.
4s
}
[
%
5
]
#
32
\
n
"
"
prfm
pldl1keep
[
%
4
448
]
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src0
)
/
/
%
0
"
+
r
"
(
src1
)
/
/
%
1
"
+
r
"
(
src2
)
/
/
%
2
"
+
r
"
(
src3
)
/
/
%
3
"
+
r
"
(
src4
)
/
/
%
4
"
+
r
"
(
dst
)
/
/
%
5
"
+
r
"
(
width
)
/
/
%
6
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v6
"
"
v7
"
)
;
}
void
GaussRow_NEON
(
const
uint32_t
*
src
uint16_t
*
dst
int
width
)
{
const
uint32_t
*
src1
=
src
+
1
;
const
uint32_t
*
src2
=
src
+
2
;
const
uint32_t
*
src3
=
src
+
3
;
asm
volatile
(
"
movi
v6
.
4s
#
4
\
n
"
"
movi
v7
.
4s
#
6
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
4s
v1
.
4s
v2
.
4s
}
[
%
0
]
%
6
\
n
"
"
subs
%
w5
%
w5
#
8
\
n
"
"
add
v0
.
4s
v0
.
4s
v1
.
4s
\
n
"
"
add
v1
.
4s
v1
.
4s
v2
.
4s
\
n
"
"
ld1
{
v2
.
4s
v3
.
4s
}
[
%
2
]
#
32
\
n
"
"
mla
v0
.
4s
v2
.
4s
v7
.
4s
\
n
"
"
mla
v1
.
4s
v3
.
4s
v7
.
4s
\
n
"
"
ld1
{
v2
.
4s
v3
.
4s
}
[
%
1
]
#
32
\
n
"
"
ld1
{
v4
.
4s
v5
.
4s
}
[
%
3
]
#
32
\
n
"
"
add
v2
.
4s
v2
.
4s
v4
.
4s
\
n
"
"
add
v3
.
4s
v3
.
4s
v5
.
4s
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mla
v0
.
4s
v2
.
4s
v6
.
4s
\
n
"
"
mla
v1
.
4s
v3
.
4s
v6
.
4s
\
n
"
"
uqrshrn
v0
.
4h
v0
.
4s
#
8
\
n
"
"
uqrshrn2
v0
.
8h
v1
.
4s
#
8
\
n
"
"
st1
{
v0
.
8h
}
[
%
4
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
src1
)
/
/
%
1
"
+
r
"
(
src2
)
/
/
%
2
"
+
r
"
(
src3
)
/
/
%
3
"
+
r
"
(
dst
)
/
/
%
4
"
+
r
"
(
width
)
/
/
%
5
:
"
r
"
(
32LL
)
/
/
%
6
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
static
const
vecf32
kGaussCoefficients
=
{
4
.
0f
6
.
0f
1
.
0f
/
256
.
0f
0
.
0f
}
;
void
GaussCol_F32_NEON
(
const
float
*
src0
const
float
*
src1
const
float
*
src2
const
float
*
src3
const
float
*
src4
float
*
dst
int
width
)
{
asm
volatile
(
"
ld2r
{
v6
.
4s
v7
.
4s
}
[
%
7
]
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
4s
v1
.
4s
}
[
%
0
]
#
32
\
n
"
"
ld1
{
v2
.
4s
v3
.
4s
}
[
%
1
]
#
32
\
n
"
"
subs
%
w6
%
w6
#
8
\
n
"
"
fmla
v0
.
4s
v2
.
4s
v6
.
4s
\
n
"
"
ld1
{
v4
.
4s
v5
.
4s
}
[
%
2
]
#
32
\
n
"
"
fmla
v1
.
4s
v3
.
4s
v6
.
4s
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
fmla
v0
.
4s
v4
.
4s
v7
.
4s
\
n
"
"
ld1
{
v2
.
4s
v3
.
4s
}
[
%
3
]
#
32
\
n
"
"
fmla
v1
.
4s
v5
.
4s
v7
.
4s
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
fmla
v0
.
4s
v2
.
4s
v6
.
4s
\
n
"
"
ld1
{
v4
.
4s
v5
.
4s
}
[
%
4
]
#
32
\
n
"
"
fmla
v1
.
4s
v3
.
4s
v6
.
4s
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
fadd
v0
.
4s
v0
.
4s
v4
.
4s
\
n
"
"
prfm
pldl1keep
[
%
3
448
]
\
n
"
"
fadd
v1
.
4s
v1
.
4s
v5
.
4s
\
n
"
"
prfm
pldl1keep
[
%
4
448
]
\
n
"
"
st1
{
v0
.
4s
v1
.
4s
}
[
%
5
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src0
)
/
/
%
0
"
+
r
"
(
src1
)
/
/
%
1
"
+
r
"
(
src2
)
/
/
%
2
"
+
r
"
(
src3
)
/
/
%
3
"
+
r
"
(
src4
)
/
/
%
4
"
+
r
"
(
dst
)
/
/
%
5
"
+
r
"
(
width
)
/
/
%
6
:
"
r
"
(
&
kGaussCoefficients
)
/
/
%
7
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
void
GaussRow_F32_NEON
(
const
float
*
src
float
*
dst
int
width
)
{
asm
volatile
(
"
ld3r
{
v6
.
4s
v7
.
4s
v8
.
4s
}
[
%
3
]
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
4s
v1
.
4s
v2
.
4s
}
[
%
0
]
%
4
\
n
"
"
subs
%
w2
%
w2
#
8
\
n
"
"
fadd
v0
.
4s
v0
.
4s
v1
.
4s
\
n
"
"
ld1
{
v4
.
4s
v5
.
4s
}
[
%
0
]
%
5
\
n
"
"
fadd
v1
.
4s
v1
.
4s
v2
.
4s
\
n
"
"
fmla
v0
.
4s
v4
.
4s
v7
.
4s
\
n
"
"
ld1
{
v2
.
4s
v3
.
4s
}
[
%
0
]
%
4
\
n
"
"
fmla
v1
.
4s
v5
.
4s
v7
.
4s
\
n
"
"
ld1
{
v4
.
4s
v5
.
4s
}
[
%
0
]
%
6
\
n
"
"
fadd
v2
.
4s
v2
.
4s
v4
.
4s
\
n
"
"
fadd
v3
.
4s
v3
.
4s
v5
.
4s
\
n
"
"
fmla
v0
.
4s
v2
.
4s
v6
.
4s
\
n
"
"
fmla
v1
.
4s
v3
.
4s
v6
.
4s
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
fmul
v0
.
4s
v0
.
4s
v8
.
4s
\
n
"
"
fmul
v1
.
4s
v1
.
4s
v8
.
4s
\
n
"
"
st1
{
v0
.
4s
v1
.
4s
}
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src
)
/
/
%
0
"
+
r
"
(
dst
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
&
kGaussCoefficients
)
/
/
%
3
"
r
"
(
8LL
)
/
/
%
4
"
r
"
(
-
4LL
)
/
/
%
5
"
r
"
(
20LL
)
/
/
%
6
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
"
v8
"
)
;
}
#
if
defined
(
LIBYUV_USE_ST3
)
void
NV21ToYUV24Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_vu
uint8_t
*
dst_yuv24
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v2
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld2
{
v0
.
8b
v1
.
8b
}
[
%
1
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
zip1
v0
.
16b
v0
.
16b
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
zip1
v1
.
16b
v1
.
16b
v1
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
st3
{
v0
.
16b
v1
.
16b
v2
.
16b
}
[
%
2
]
#
48
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
src_vu
)
/
/
%
1
"
+
r
"
(
dst_yuv24
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
)
;
}
#
else
static
const
uvec8
kYUV24Shuffle
[
3
]
=
{
{
16
17
0
16
17
1
18
19
2
18
19
3
20
21
4
20
}
{
21
5
22
23
6
22
23
7
24
25
8
24
25
9
26
27
}
{
10
26
27
11
28
29
12
28
29
13
30
31
14
30
31
15
}
}
;
void
NV21ToYUV24Row_NEON
(
const
uint8_t
*
src_y
const
uint8_t
*
src_vu
uint8_t
*
dst_yuv24
int
width
)
{
asm
volatile
(
"
ld1
{
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
4
]
\
n
"
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
1
]
#
16
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
tbl
v2
.
16b
{
v0
.
16b
v1
.
16b
}
v5
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
tbl
v3
.
16b
{
v0
.
16b
v1
.
16b
}
v6
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
tbl
v4
.
16b
{
v0
.
16b
v1
.
16b
}
v7
.
16b
\
n
"
"
st1
{
v2
.
16b
v3
.
16b
v4
.
16b
}
[
%
2
]
#
48
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
src_vu
)
/
/
%
1
"
+
r
"
(
dst_yuv24
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
"
r
"
(
&
kYUV24Shuffle
[
0
]
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
#
endif
void
AYUVToUVRow_NEON
(
const
uint8_t
*
src_ayuv
int
src_stride_ayuv
uint8_t
*
dst_uv
int
width
)
{
const
uint8_t
*
src_ayuv_1
=
src_ayuv
+
src_stride_ayuv
;
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
ld4
{
v4
.
16b
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
1
]
#
64
\
n
"
"
uadalp
v0
.
8h
v4
.
16b
\
n
"
"
uadalp
v1
.
8h
v5
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uqrshrn
v3
.
8b
v0
.
8h
#
2
\
n
"
"
uqrshrn
v2
.
8b
v1
.
8h
#
2
\
n
"
"
st2
{
v2
.
8b
v3
.
8b
}
[
%
2
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_ayuv
)
/
/
%
0
"
+
r
"
(
src_ayuv_1
)
/
/
%
1
"
+
r
"
(
dst_uv
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
void
AYUVToVURow_NEON
(
const
uint8_t
*
src_ayuv
int
src_stride_ayuv
uint8_t
*
dst_vu
int
width
)
{
const
uint8_t
*
src_ayuv_1
=
src_ayuv
+
src_stride_ayuv
;
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w3
%
w3
#
16
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
ld4
{
v4
.
16b
v5
.
16b
v6
.
16b
v7
.
16b
}
[
%
1
]
#
64
\
n
"
"
uadalp
v0
.
8h
v4
.
16b
\
n
"
"
uadalp
v1
.
8h
v5
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uqrshrn
v0
.
8b
v0
.
8h
#
2
\
n
"
"
uqrshrn
v1
.
8b
v1
.
8h
#
2
\
n
"
"
st2
{
v0
.
8b
v1
.
8b
}
[
%
2
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_ayuv
)
/
/
%
0
"
+
r
"
(
src_ayuv_1
)
/
/
%
1
"
+
r
"
(
dst_vu
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
"
v6
"
"
v7
"
)
;
}
void
AYUVToYRow_NEON
(
const
uint8_t
*
src_ayuv
uint8_t
*
dst_y
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld4
{
v0
.
16b
v1
.
16b
v2
.
16b
v3
.
16b
}
[
%
0
]
#
64
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
st1
{
v2
.
16b
}
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_ayuv
)
"
+
r
"
(
dst_y
)
"
+
r
"
(
width
)
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
SwapUVRow_NEON
(
const
uint8_t
*
src_uv
uint8_t
*
dst_vu
int
width
)
{
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
0
]
16
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
rev16
v0
.
16b
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
rev16
v1
.
16b
v1
.
16b
\
n
"
"
stp
q0
q1
[
%
1
]
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_uv
)
/
/
%
0
"
+
r
"
(
dst_vu
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
)
;
}
void
HalfMergeUVRow_NEON
(
const
uint8_t
*
src_u
int
src_stride_u
const
uint8_t
*
src_v
int
src_stride_v
uint8_t
*
dst_uv
int
width
)
{
const
uint8_t
*
src_u_1
=
src_u
+
src_stride_u
;
const
uint8_t
*
src_v_1
=
src_v
+
src_stride_v
;
asm
volatile
(
"
1
:
\
n
"
"
ld1
{
v0
.
16b
}
[
%
0
]
#
16
\
n
"
"
ld1
{
v1
.
16b
}
[
%
2
]
#
16
\
n
"
"
ld1
{
v2
.
16b
}
[
%
1
]
#
16
\
n
"
"
ld1
{
v3
.
16b
}
[
%
3
]
#
16
\
n
"
"
subs
%
w5
%
w5
#
16
\
n
"
"
uaddlp
v0
.
8h
v0
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uaddlp
v1
.
8h
v1
.
16b
\
n
"
"
prfm
pldl1keep
[
%
2
448
]
\
n
"
"
uadalp
v0
.
8h
v2
.
16b
\
n
"
"
prfm
pldl1keep
[
%
1
448
]
\
n
"
"
uadalp
v1
.
8h
v3
.
16b
\
n
"
"
prfm
pldl1keep
[
%
3
448
]
\
n
"
"
uqrshrn
v0
.
8b
v0
.
8h
#
2
\
n
"
"
uqrshrn
v1
.
8b
v1
.
8h
#
2
\
n
"
"
st2
{
v0
.
8b
v1
.
8b
}
[
%
4
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_u
)
/
/
%
0
"
+
r
"
(
src_u_1
)
/
/
%
1
"
+
r
"
(
src_v
)
/
/
%
2
"
+
r
"
(
src_v_1
)
/
/
%
3
"
+
r
"
(
dst_uv
)
/
/
%
4
"
+
r
"
(
width
)
/
/
%
5
:
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
)
;
}
void
SplitUVRow_16_NEON
(
const
uint16_t
*
src_uv
uint16_t
*
dst_u
uint16_t
*
dst_v
int
depth
int
width
)
{
int
shift
=
depth
-
16
;
asm
volatile
(
"
dup
v2
.
8h
%
w4
\
n
"
"
1
:
\
n
"
"
ld2
{
v0
.
8h
v1
.
8h
}
[
%
0
]
#
32
\
n
"
"
subs
%
w3
%
w3
#
8
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v2
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
ushl
v1
.
8h
v1
.
8h
v2
.
8h
\
n
"
"
st1
{
v0
.
8h
}
[
%
1
]
#
16
\
n
"
"
st1
{
v1
.
8h
}
[
%
2
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_uv
)
/
/
%
0
"
+
r
"
(
dst_u
)
/
/
%
1
"
+
r
"
(
dst_v
)
/
/
%
2
"
+
r
"
(
width
)
/
/
%
3
:
"
r
"
(
shift
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
)
;
}
void
MultiplyRow_16_NEON
(
const
uint16_t
*
src_y
uint16_t
*
dst_y
int
scale
int
width
)
{
asm
volatile
(
"
dup
v2
.
8h
%
w3
\
n
"
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
mul
v0
.
8h
v0
.
8h
v2
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
mul
v1
.
8h
v1
.
8h
v2
.
8h
\
n
"
"
stp
q0
q1
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
scale
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
)
;
}
void
DivideRow_16_NEON
(
const
uint16_t
*
src_y
uint16_t
*
dst_y
int
scale
int
width
)
{
asm
volatile
(
"
dup
v4
.
8h
%
w3
\
n
"
"
1
:
\
n
"
"
ldp
q2
q3
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
umull
v0
.
4s
v2
.
4h
v4
.
4h
\
n
"
"
umull2
v1
.
4s
v2
.
8h
v4
.
8h
\
n
"
"
umull
v2
.
4s
v3
.
4h
v4
.
4h
\
n
"
"
umull2
v3
.
4s
v3
.
8h
v4
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uzp2
v0
.
8h
v0
.
8h
v1
.
8h
\
n
"
"
uzp2
v1
.
8h
v2
.
8h
v3
.
8h
\
n
"
"
stp
q0
q1
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
scale
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
)
;
}
void
Convert16To8Row_NEON
(
const
uint16_t
*
src_y
uint8_t
*
dst_y
int
scale
int
width
)
{
int
shift
=
23
-
__builtin_clz
(
(
int32_t
)
scale
)
;
asm
volatile
(
"
dup
v2
.
8h
%
w3
\
n
"
"
1
:
\
n
"
"
ldp
q0
q1
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
16
\
n
"
"
uqshl
v0
.
8h
v0
.
8h
v2
.
8h
\
n
"
"
uqshl
v1
.
8h
v1
.
8h
v2
.
8h
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uzp2
v0
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
str
q0
[
%
1
]
#
16
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
shift
)
/
/
%
3
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
)
;
}
void
Convert8To8Row_NEON
(
const
uint8_t
*
src_y
uint8_t
*
dst_y
int
scale
int
bias
int
width
)
{
asm
volatile
(
"
dup
v4
.
16b
%
w3
\
n
"
"
dup
v5
.
16b
%
w4
\
n
"
"
1
:
\
n
"
"
ldp
q2
q3
[
%
0
]
#
32
\
n
"
"
subs
%
w2
%
w2
#
32
\
n
"
"
umull
v0
.
8h
v2
.
8b
v4
.
8b
\
n
"
"
umull2
v1
.
8h
v2
.
16b
v4
.
16b
\
n
"
"
umull
v2
.
8h
v3
.
8b
v4
.
8b
\
n
"
"
umull2
v3
.
8h
v3
.
16b
v4
.
16b
\
n
"
"
prfm
pldl1keep
[
%
0
448
]
\
n
"
"
uzp2
v0
.
16b
v0
.
16b
v1
.
16b
\
n
"
"
uzp2
v1
.
16b
v2
.
16b
v3
.
16b
\
n
"
"
add
v0
.
16b
v0
.
16b
v5
.
16b
\
n
"
"
add
v1
.
16b
v1
.
16b
v5
.
16b
\
n
"
"
stp
q0
q1
[
%
1
]
#
32
\
n
"
"
b
.
gt
1b
\
n
"
:
"
+
r
"
(
src_y
)
/
/
%
0
"
+
r
"
(
dst_y
)
/
/
%
1
"
+
r
"
(
width
)
/
/
%
2
:
"
r
"
(
scale
)
/
/
%
3
"
r
"
(
bias
)
/
/
%
4
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
"
v3
"
"
v4
"
"
v5
"
)
;
}
void
Convert8To16Row_NEON
(
const
uint8_t
*
src_y
uint16_t
*
dst_y
int
scale
int
width
)
{
int
shift
=
15
-
__builtin_clz
(
scale
)
;
asm
volatile
(
"
dup
v2
.
8h
%
w
[
shift
]
\
n
"
"
1
:
\
n
"
"
ldr
q0
[
%
[
src
]
]
#
16
\
n
"
"
zip2
v1
.
16b
v0
.
16b
v0
.
16b
\
n
"
"
zip1
v0
.
16b
v0
.
16b
v0
.
16b
\
n
"
"
subs
%
w
[
width
]
%
w
[
width
]
#
16
\
n
"
"
ushl
v1
.
8h
v1
.
8h
v2
.
8h
\
n
"
"
ushl
v0
.
8h
v0
.
8h
v2
.
8h
\
n
"
"
stp
q0
q1
[
%
[
dst
]
]
#
32
\
n
"
"
b
.
ne
1b
\
n
"
:
[
src
]
"
+
r
"
(
src_y
)
[
dst
]
"
+
r
"
(
dst_y
)
[
width
]
"
+
r
"
(
width
)
:
[
shift
]
"
r
"
(
shift
)
:
"
cc
"
"
memory
"
"
v0
"
"
v1
"
"
v2
"
)
;
}
#
endif
#
ifdef
__cplusplus
}
}
#
endif
