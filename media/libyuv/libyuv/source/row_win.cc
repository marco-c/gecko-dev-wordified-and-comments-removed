#
include
"
libyuv
/
row
.
h
"
#
if
!
defined
(
LIBYUV_DISABLE_X86
)
&
&
defined
(
_MSC_VER
)
&
&
\
(
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
)
&
&
\
(
!
defined
(
__clang__
)
|
|
defined
(
LIBYUV_ENABLE_ROWWIN
)
)
#
if
defined
(
_M_ARM64EC
)
#
include
<
intrin
.
h
>
#
elif
defined
(
_M_X64
)
#
include
<
emmintrin
.
h
>
#
include
<
tmmintrin
.
h
>
#
endif
#
ifdef
__cplusplus
namespace
libyuv
{
extern
"
C
"
{
#
endif
#
if
defined
(
_M_X64
)
#
define
READYUV444
\
xmm3
=
_mm_loadl_epi64
(
(
__m128i
*
)
u_buf
)
;
\
xmm1
=
_mm_loadl_epi64
(
(
__m128i
*
)
(
u_buf
+
offset
)
)
;
\
xmm3
=
_mm_unpacklo_epi8
(
xmm3
xmm1
)
;
\
u_buf
+
=
8
;
\
xmm4
=
_mm_loadl_epi64
(
(
__m128i
*
)
y_buf
)
;
\
xmm4
=
_mm_unpacklo_epi8
(
xmm4
xmm4
)
;
\
y_buf
+
=
8
;
#
define
READYUVA444
\
xmm3
=
_mm_loadl_epi64
(
(
__m128i
*
)
u_buf
)
;
\
xmm1
=
_mm_loadl_epi64
(
(
__m128i
*
)
(
u_buf
+
offset
)
)
;
\
xmm3
=
_mm_unpacklo_epi8
(
xmm3
xmm1
)
;
\
u_buf
+
=
8
;
\
xmm4
=
_mm_loadl_epi64
(
(
__m128i
*
)
y_buf
)
;
\
xmm4
=
_mm_unpacklo_epi8
(
xmm4
xmm4
)
;
\
y_buf
+
=
8
;
\
xmm5
=
_mm_loadl_epi64
(
(
__m128i
*
)
a_buf
)
;
\
a_buf
+
=
8
;
#
define
READYUV422
\
xmm3
=
_mm_cvtsi32_si128
(
*
(
uint32_t
*
)
u_buf
)
;
\
xmm1
=
_mm_cvtsi32_si128
(
*
(
uint32_t
*
)
(
u_buf
+
offset
)
)
;
\
xmm3
=
_mm_unpacklo_epi8
(
xmm3
xmm1
)
;
\
xmm3
=
_mm_unpacklo_epi16
(
xmm3
xmm3
)
;
\
u_buf
+
=
4
;
\
xmm4
=
_mm_loadl_epi64
(
(
__m128i
*
)
y_buf
)
;
\
xmm4
=
_mm_unpacklo_epi8
(
xmm4
xmm4
)
;
\
y_buf
+
=
8
;
#
define
READYUVA422
\
xmm3
=
_mm_cvtsi32_si128
(
*
(
uint32_t
*
)
u_buf
)
;
\
xmm1
=
_mm_cvtsi32_si128
(
*
(
uint32_t
*
)
(
u_buf
+
offset
)
)
;
\
xmm3
=
_mm_unpacklo_epi8
(
xmm3
xmm1
)
;
\
xmm3
=
_mm_unpacklo_epi16
(
xmm3
xmm3
)
;
\
u_buf
+
=
4
;
\
xmm4
=
_mm_loadl_epi64
(
(
__m128i
*
)
y_buf
)
;
\
xmm4
=
_mm_unpacklo_epi8
(
xmm4
xmm4
)
;
\
y_buf
+
=
8
;
\
xmm5
=
_mm_loadl_epi64
(
(
__m128i
*
)
a_buf
)
;
\
a_buf
+
=
8
;
#
define
YUVTORGB
(
yuvconstants
)
\
xmm3
=
_mm_sub_epi8
(
xmm3
_mm_set1_epi8
(
(
char
)
0x80
)
)
;
\
xmm4
=
_mm_mulhi_epu16
(
xmm4
*
(
__m128i
*
)
yuvconstants
-
>
kYToRgb
)
;
\
xmm4
=
_mm_add_epi16
(
xmm4
*
(
__m128i
*
)
yuvconstants
-
>
kYBiasToRgb
)
;
\
xmm0
=
_mm_maddubs_epi16
(
*
(
__m128i
*
)
yuvconstants
-
>
kUVToB
xmm3
)
;
\
xmm1
=
_mm_maddubs_epi16
(
*
(
__m128i
*
)
yuvconstants
-
>
kUVToG
xmm3
)
;
\
xmm2
=
_mm_maddubs_epi16
(
*
(
__m128i
*
)
yuvconstants
-
>
kUVToR
xmm3
)
;
\
xmm0
=
_mm_adds_epi16
(
xmm4
xmm0
)
;
\
xmm1
=
_mm_subs_epi16
(
xmm4
xmm1
)
;
\
xmm2
=
_mm_adds_epi16
(
xmm4
xmm2
)
;
\
xmm0
=
_mm_srai_epi16
(
xmm0
6
)
;
\
xmm1
=
_mm_srai_epi16
(
xmm1
6
)
;
\
xmm2
=
_mm_srai_epi16
(
xmm2
6
)
;
\
xmm0
=
_mm_packus_epi16
(
xmm0
xmm0
)
;
\
xmm1
=
_mm_packus_epi16
(
xmm1
xmm1
)
;
\
xmm2
=
_mm_packus_epi16
(
xmm2
xmm2
)
;
#
define
STOREARGB
\
xmm0
=
_mm_unpacklo_epi8
(
xmm0
xmm1
)
;
\
xmm2
=
_mm_unpacklo_epi8
(
xmm2
xmm5
)
;
\
xmm1
=
_mm_loadu_si128
(
&
xmm0
)
;
\
xmm0
=
_mm_unpacklo_epi16
(
xmm0
xmm2
)
;
\
xmm1
=
_mm_unpackhi_epi16
(
xmm1
xmm2
)
;
\
_mm_storeu_si128
(
(
__m128i
*
)
dst_argb
xmm0
)
;
\
_mm_storeu_si128
(
(
__m128i
*
)
(
dst_argb
+
16
)
xmm1
)
;
\
dst_argb
+
=
32
;
#
if
defined
(
HAS_I422TOARGBROW_SSSE3
)
void
I422ToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__m128i
xmm0
xmm1
xmm2
xmm3
xmm4
;
const
__m128i
xmm5
=
_mm_set1_epi8
(
-
1
)
;
const
ptrdiff_t
offset
=
(
uint8_t
*
)
v_buf
-
(
uint8_t
*
)
u_buf
;
while
(
width
>
0
)
{
READYUV422
YUVTORGB
(
yuvconstants
)
STOREARGB
width
-
=
8
;
}
}
#
endif
#
if
defined
(
HAS_I422ALPHATOARGBROW_SSSE3
)
void
I422AlphaToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
const
uint8_t
*
a_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__m128i
xmm0
xmm1
xmm2
xmm3
xmm4
xmm5
;
const
ptrdiff_t
offset
=
(
uint8_t
*
)
v_buf
-
(
uint8_t
*
)
u_buf
;
while
(
width
>
0
)
{
READYUVA422
YUVTORGB
(
yuvconstants
)
STOREARGB
width
-
=
8
;
}
}
#
endif
#
if
defined
(
HAS_I444TOARGBROW_SSSE3
)
void
I444ToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__m128i
xmm0
xmm1
xmm2
xmm3
xmm4
;
const
__m128i
xmm5
=
_mm_set1_epi8
(
-
1
)
;
const
ptrdiff_t
offset
=
(
uint8_t
*
)
v_buf
-
(
uint8_t
*
)
u_buf
;
while
(
width
>
0
)
{
READYUV444
YUVTORGB
(
yuvconstants
)
STOREARGB
width
-
=
8
;
}
}
#
endif
#
if
defined
(
HAS_I444ALPHATOARGBROW_SSSE3
)
void
I444AlphaToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
const
uint8_t
*
a_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__m128i
xmm0
xmm1
xmm2
xmm3
xmm4
xmm5
;
const
ptrdiff_t
offset
=
(
uint8_t
*
)
v_buf
-
(
uint8_t
*
)
u_buf
;
while
(
width
>
0
)
{
READYUVA444
YUVTORGB
(
yuvconstants
)
STOREARGB
width
-
=
8
;
}
}
#
endif
#
else
static
const
ulvec8
kBiasUV128
=
{
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
0x80
}
;
static
const
lvec8
kShuffleNV21
=
{
1
0
1
0
3
2
3
2
5
4
5
4
7
6
7
6
1
0
1
0
3
2
3
2
5
4
5
4
7
6
7
6
}
;
static
const
lvec8
kShuffleYUY2Y
=
{
0
0
2
2
4
4
6
6
8
8
10
10
12
12
14
14
0
0
2
2
4
4
6
6
8
8
10
10
12
12
14
14
}
;
static
const
lvec8
kShuffleYUY2UV
=
{
1
3
1
3
5
7
5
7
9
11
9
11
13
15
13
15
1
3
1
3
5
7
5
7
9
11
9
11
13
15
13
15
}
;
static
const
lvec8
kShuffleUYVYY
=
{
1
1
3
3
5
5
7
7
9
9
11
11
13
13
15
15
1
1
3
3
5
5
7
7
9
9
11
11
13
13
15
15
}
;
static
const
lvec8
kShuffleUYVYUV
=
{
0
2
0
2
4
6
4
6
8
10
8
10
12
14
12
14
0
2
0
2
4
6
4
6
8
10
8
10
12
14
12
14
}
;
static
const
vec8
kARGBToYJ
=
{
15
75
38
0
15
75
38
0
15
75
38
0
15
75
38
0
}
;
static
const
lvec32
kPermdARGBToY_AVX
=
{
0
4
1
5
2
6
3
7
}
;
static
const
vec8
kARGBToY
=
{
13
65
33
0
13
65
33
0
13
65
33
0
13
65
33
0
}
;
static
const
vec8
kARGBToU
=
{
112
-
74
-
38
0
112
-
74
-
38
0
112
-
74
-
38
0
112
-
74
-
38
0
}
;
static
const
vec8
kARGBToUJ
=
{
127
-
84
-
43
0
127
-
84
-
43
0
127
-
84
-
43
0
127
-
84
-
43
0
}
;
static
const
vec8
kARGBToV
=
{
-
18
-
94
112
0
-
18
-
94
112
0
-
18
-
94
112
0
-
18
-
94
112
0
}
;
static
const
vec8
kARGBToVJ
=
{
-
20
-
107
127
0
-
20
-
107
127
0
-
20
-
107
127
0
-
20
-
107
127
0
}
;
static
const
lvec8
kShufARGBToUV_AVX
=
{
0
1
8
9
2
3
10
11
4
5
12
13
6
7
14
15
0
1
8
9
2
3
10
11
4
5
12
13
6
7
14
15
}
;
static
const
vec8
kBGRAToY
=
{
0
33
65
13
0
33
65
13
0
33
65
13
0
33
65
13
}
;
static
const
vec8
kBGRAToU
=
{
0
-
38
-
74
112
0
-
38
-
74
112
0
-
38
-
74
112
0
-
38
-
74
112
}
;
static
const
vec8
kBGRAToV
=
{
0
112
-
94
-
18
0
112
-
94
-
18
0
112
-
94
-
18
0
112
-
94
-
18
}
;
static
const
vec8
kABGRToY
=
{
33
65
13
0
33
65
13
0
33
65
13
0
33
65
13
0
}
;
static
const
vec8
kABGRToU
=
{
-
38
-
74
112
0
-
38
-
74
112
0
-
38
-
74
112
0
-
38
-
74
112
0
}
;
static
const
vec8
kABGRToV
=
{
112
-
94
-
18
0
112
-
94
-
18
0
112
-
94
-
18
0
112
-
94
-
18
0
}
;
static
const
vec8
kRGBAToY
=
{
0
13
65
33
0
13
65
33
0
13
65
33
0
13
65
33
}
;
static
const
vec8
kRGBAToU
=
{
0
112
-
74
-
38
0
112
-
74
-
38
0
112
-
74
-
38
0
112
-
74
-
38
}
;
static
const
vec8
kRGBAToV
=
{
0
-
18
-
94
112
0
-
18
-
94
112
0
-
18
-
94
112
0
-
18
-
94
112
}
;
static
const
uvec8
kAddY16
=
{
16u
16u
16u
16u
16u
16u
16u
16u
16u
16u
16u
16u
16u
16u
16u
16u
}
;
static
const
vec16
kAddYJ64
=
{
64
64
64
64
64
64
64
64
}
;
static
const
uvec8
kShuffleMaskRGB24ToARGB
=
{
0u
1u
2u
12u
3u
4u
5u
13u
6u
7u
8u
14u
9u
10u
11u
15u
}
;
static
const
uvec8
kShuffleMaskRAWToARGB
=
{
2u
1u
0u
12u
5u
4u
3u
13u
8u
7u
6u
14u
11u
10u
9u
15u
}
;
static
const
uvec8
kShuffleMaskRAWToRGB24_0
=
{
2u
1u
0u
5u
4u
3u
8u
7u
128u
128u
128u
128u
128u
128u
128u
128u
}
;
static
const
uvec8
kShuffleMaskRAWToRGB24_1
=
{
2u
7u
6u
5u
10u
9u
8u
13u
128u
128u
128u
128u
128u
128u
128u
128u
}
;
static
const
uvec8
kShuffleMaskRAWToRGB24_2
=
{
8u
7u
12u
11u
10u
15u
14u
13u
128u
128u
128u
128u
128u
128u
128u
128u
}
;
static
const
uvec8
kShuffleMaskARGBToRGB24
=
{
0u
1u
2u
4u
5u
6u
8u
9u
10u
12u
13u
14u
128u
128u
128u
128u
}
;
static
const
uvec8
kShuffleMaskARGBToRAW
=
{
2u
1u
0u
6u
5u
4u
10u
9u
8u
14u
13u
12u
128u
128u
128u
128u
}
;
static
const
uvec8
kShuffleMaskARGBToRGB24_0
=
{
0u
1u
2u
4u
5u
6u
8u
9u
128u
128u
128u
128u
10u
12u
13u
14u
}
;
__declspec
(
naked
)
void
J400ToARGBRow_SSE2
(
const
uint8_t
*
src_y
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm5
xmm5
pslld
xmm5
24
convertloop
:
movq
xmm0
qword
ptr
[
eax
]
lea
eax
[
eax
+
8
]
punpcklbw
xmm0
xmm0
movdqa
xmm1
xmm0
punpcklwd
xmm0
xmm0
punpckhwd
xmm1
xmm1
por
xmm0
xmm5
por
xmm1
xmm5
movdqu
[
edx
]
xmm0
movdqu
[
edx
+
16
]
xmm1
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
ret
}
}
#
ifdef
HAS_J400TOARGBROW_AVX2
__declspec
(
naked
)
void
J400ToARGBRow_AVX2
(
const
uint8_t
*
src_y
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vpcmpeqb
ymm5
ymm5
ymm5
vpslld
ymm5
ymm5
24
convertloop
:
vmovdqu
xmm0
[
eax
]
lea
eax
[
eax
+
16
]
vpermq
ymm0
ymm0
0xd8
vpunpcklbw
ymm0
ymm0
ymm0
vpermq
ymm0
ymm0
0xd8
vpunpckhwd
ymm1
ymm0
ymm0
vpunpcklwd
ymm0
ymm0
ymm0
vpor
ymm0
ymm0
ymm5
vpor
ymm1
ymm1
ymm5
vmovdqu
[
edx
]
ymm0
vmovdqu
[
edx
+
32
]
ymm1
lea
edx
[
edx
+
64
]
sub
ecx
16
jg
convertloop
vzeroupper
ret
}
}
#
endif
__declspec
(
naked
)
void
RGB24ToARGBRow_SSSE3
(
const
uint8_t
*
src_rgb24
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm5
xmm5
pslld
xmm5
24
movdqa
xmm4
xmmword
ptr
kShuffleMaskRGB24ToARGB
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm3
[
eax
+
32
]
lea
eax
[
eax
+
48
]
movdqa
xmm2
xmm3
palignr
xmm2
xmm1
8
pshufb
xmm2
xmm4
por
xmm2
xmm5
palignr
xmm1
xmm0
12
pshufb
xmm0
xmm4
movdqu
[
edx
+
32
]
xmm2
por
xmm0
xmm5
pshufb
xmm1
xmm4
movdqu
[
edx
]
xmm0
por
xmm1
xmm5
palignr
xmm3
xmm3
4
pshufb
xmm3
xmm4
movdqu
[
edx
+
16
]
xmm1
por
xmm3
xmm5
movdqu
[
edx
+
48
]
xmm3
lea
edx
[
edx
+
64
]
sub
ecx
16
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
RAWToARGBRow_SSSE3
(
const
uint8_t
*
src_raw
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm5
xmm5
pslld
xmm5
24
movdqa
xmm4
xmmword
ptr
kShuffleMaskRAWToARGB
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm3
[
eax
+
32
]
lea
eax
[
eax
+
48
]
movdqa
xmm2
xmm3
palignr
xmm2
xmm1
8
pshufb
xmm2
xmm4
por
xmm2
xmm5
palignr
xmm1
xmm0
12
pshufb
xmm0
xmm4
movdqu
[
edx
+
32
]
xmm2
por
xmm0
xmm5
pshufb
xmm1
xmm4
movdqu
[
edx
]
xmm0
por
xmm1
xmm5
palignr
xmm3
xmm3
4
pshufb
xmm3
xmm4
movdqu
[
edx
+
16
]
xmm1
por
xmm3
xmm5
movdqu
[
edx
+
48
]
xmm3
lea
edx
[
edx
+
64
]
sub
ecx
16
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
RAWToRGB24Row_SSSE3
(
const
uint8_t
*
src_raw
uint8_t
*
dst_rgb24
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm3
xmmword
ptr
kShuffleMaskRAWToRGB24_0
movdqa
xmm4
xmmword
ptr
kShuffleMaskRAWToRGB24_1
movdqa
xmm5
xmmword
ptr
kShuffleMaskRAWToRGB24_2
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
4
]
movdqu
xmm2
[
eax
+
8
]
lea
eax
[
eax
+
24
]
pshufb
xmm0
xmm3
pshufb
xmm1
xmm4
pshufb
xmm2
xmm5
movq
qword
ptr
[
edx
]
xmm0
movq
qword
ptr
[
edx
+
8
]
xmm1
movq
qword
ptr
[
edx
+
16
]
xmm2
lea
edx
[
edx
+
24
]
sub
ecx
8
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
RGB565ToARGBRow_SSE2
(
const
uint8_t
*
src_rgb565
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
0x01080108
movd
xmm5
eax
pshufd
xmm5
xmm5
0
mov
eax
0x20802080
movd
xmm6
eax
pshufd
xmm6
xmm6
0
pcmpeqb
xmm3
xmm3
psllw
xmm3
11
pcmpeqb
xmm4
xmm4
psllw
xmm4
10
psrlw
xmm4
5
pcmpeqb
xmm7
xmm7
psllw
xmm7
8
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
sub
edx
eax
sub
edx
eax
convertloop
:
movdqu
xmm0
[
eax
]
movdqa
xmm1
xmm0
movdqa
xmm2
xmm0
pand
xmm1
xmm3
psllw
xmm2
11
pmulhuw
xmm1
xmm5
pmulhuw
xmm2
xmm5
psllw
xmm1
8
por
xmm1
xmm2
pand
xmm0
xmm4
pmulhuw
xmm0
xmm6
por
xmm0
xmm7
movdqa
xmm2
xmm1
punpcklbw
xmm1
xmm0
punpckhbw
xmm2
xmm0
movdqu
[
eax
*
2
+
edx
]
xmm1
movdqu
[
eax
*
2
+
edx
+
16
]
xmm2
lea
eax
[
eax
+
16
]
sub
ecx
8
jg
convertloop
ret
}
}
#
ifdef
HAS_RGB565TOARGBROW_AVX2
__declspec
(
naked
)
void
RGB565ToARGBRow_AVX2
(
const
uint8_t
*
src_rgb565
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
0x01080108
vmovd
xmm5
eax
vbroadcastss
ymm5
xmm5
mov
eax
0x20802080
vmovd
xmm6
eax
vbroadcastss
ymm6
xmm6
vpcmpeqb
ymm3
ymm3
ymm3
vpsllw
ymm3
ymm3
11
vpcmpeqb
ymm4
ymm4
ymm4
vpsllw
ymm4
ymm4
10
vpsrlw
ymm4
ymm4
5
vpcmpeqb
ymm7
ymm7
ymm7
vpsllw
ymm7
ymm7
8
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
sub
edx
eax
sub
edx
eax
convertloop
:
vmovdqu
ymm0
[
eax
]
vpand
ymm1
ymm0
ymm3
vpsllw
ymm2
ymm0
11
vpmulhuw
ymm1
ymm1
ymm5
vpmulhuw
ymm2
ymm2
ymm5
vpsllw
ymm1
ymm1
8
vpor
ymm1
ymm1
ymm2
vpand
ymm0
ymm0
ymm4
vpmulhuw
ymm0
ymm0
ymm6
vpor
ymm0
ymm0
ymm7
vpermq
ymm0
ymm0
0xd8
vpermq
ymm1
ymm1
0xd8
vpunpckhbw
ymm2
ymm1
ymm0
vpunpcklbw
ymm1
ymm1
ymm0
vmovdqu
[
eax
*
2
+
edx
]
ymm1
vmovdqu
[
eax
*
2
+
edx
+
32
]
ymm2
lea
eax
[
eax
+
32
]
sub
ecx
16
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGB1555TOARGBROW_AVX2
__declspec
(
naked
)
void
ARGB1555ToARGBRow_AVX2
(
const
uint8_t
*
src_argb1555
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
0x01080108
vmovd
xmm5
eax
vbroadcastss
ymm5
xmm5
mov
eax
0x42004200
vmovd
xmm6
eax
vbroadcastss
ymm6
xmm6
vpcmpeqb
ymm3
ymm3
ymm3
vpsllw
ymm3
ymm3
11
vpsrlw
ymm4
ymm3
6
vpcmpeqb
ymm7
ymm7
ymm7
vpsllw
ymm7
ymm7
8
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
sub
edx
eax
sub
edx
eax
convertloop
:
vmovdqu
ymm0
[
eax
]
vpsllw
ymm1
ymm0
1
vpsllw
ymm2
ymm0
11
vpand
ymm1
ymm1
ymm3
vpmulhuw
ymm2
ymm2
ymm5
vpmulhuw
ymm1
ymm1
ymm5
vpsllw
ymm1
ymm1
8
vpor
ymm1
ymm1
ymm2
vpsraw
ymm2
ymm0
8
vpand
ymm0
ymm0
ymm4
vpmulhuw
ymm0
ymm0
ymm6
vpand
ymm2
ymm2
ymm7
vpor
ymm0
ymm0
ymm2
vpermq
ymm0
ymm0
0xd8
vpermq
ymm1
ymm1
0xd8
vpunpckhbw
ymm2
ymm1
ymm0
vpunpcklbw
ymm1
ymm1
ymm0
vmovdqu
[
eax
*
2
+
edx
]
ymm1
vmovdqu
[
eax
*
2
+
edx
+
32
]
ymm2
lea
eax
[
eax
+
32
]
sub
ecx
16
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGB4444TOARGBROW_AVX2
__declspec
(
naked
)
void
ARGB4444ToARGBRow_AVX2
(
const
uint8_t
*
src_argb4444
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
0x0f0f0f0f
vmovd
xmm4
eax
vbroadcastss
ymm4
xmm4
vpslld
ymm5
ymm4
4
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
sub
edx
eax
sub
edx
eax
convertloop
:
vmovdqu
ymm0
[
eax
]
vpand
ymm2
ymm0
ymm5
vpand
ymm0
ymm0
ymm4
vpsrlw
ymm3
ymm2
4
vpsllw
ymm1
ymm0
4
vpor
ymm2
ymm2
ymm3
vpor
ymm0
ymm0
ymm1
vpermq
ymm0
ymm0
0xd8
vpermq
ymm2
ymm2
0xd8
vpunpckhbw
ymm1
ymm0
ymm2
vpunpcklbw
ymm0
ymm0
ymm2
vmovdqu
[
eax
*
2
+
edx
]
ymm0
vmovdqu
[
eax
*
2
+
edx
+
32
]
ymm1
lea
eax
[
eax
+
32
]
sub
ecx
16
jg
convertloop
vzeroupper
ret
}
}
#
endif
__declspec
(
naked
)
void
ARGB1555ToARGBRow_SSE2
(
const
uint8_t
*
src_argb1555
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
0x01080108
movd
xmm5
eax
pshufd
xmm5
xmm5
0
mov
eax
0x42004200
movd
xmm6
eax
pshufd
xmm6
xmm6
0
pcmpeqb
xmm3
xmm3
psllw
xmm3
11
movdqa
xmm4
xmm3
psrlw
xmm4
6
pcmpeqb
xmm7
xmm7
psllw
xmm7
8
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
sub
edx
eax
sub
edx
eax
convertloop
:
movdqu
xmm0
[
eax
]
movdqa
xmm1
xmm0
movdqa
xmm2
xmm0
psllw
xmm1
1
psllw
xmm2
11
pand
xmm1
xmm3
pmulhuw
xmm2
xmm5
pmulhuw
xmm1
xmm5
psllw
xmm1
8
por
xmm1
xmm2
movdqa
xmm2
xmm0
pand
xmm0
xmm4
psraw
xmm2
8
pmulhuw
xmm0
xmm6
pand
xmm2
xmm7
por
xmm0
xmm2
movdqa
xmm2
xmm1
punpcklbw
xmm1
xmm0
punpckhbw
xmm2
xmm0
movdqu
[
eax
*
2
+
edx
]
xmm1
movdqu
[
eax
*
2
+
edx
+
16
]
xmm2
lea
eax
[
eax
+
16
]
sub
ecx
8
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
ARGB4444ToARGBRow_SSE2
(
const
uint8_t
*
src_argb4444
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
0x0f0f0f0f
movd
xmm4
eax
pshufd
xmm4
xmm4
0
movdqa
xmm5
xmm4
pslld
xmm5
4
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
sub
edx
eax
sub
edx
eax
convertloop
:
movdqu
xmm0
[
eax
]
movdqa
xmm2
xmm0
pand
xmm0
xmm4
pand
xmm2
xmm5
movdqa
xmm1
xmm0
movdqa
xmm3
xmm2
psllw
xmm1
4
psrlw
xmm3
4
por
xmm0
xmm1
por
xmm2
xmm3
movdqa
xmm1
xmm0
punpcklbw
xmm0
xmm2
punpckhbw
xmm1
xmm2
movdqu
[
eax
*
2
+
edx
]
xmm0
movdqu
[
eax
*
2
+
edx
+
16
]
xmm1
lea
eax
[
eax
+
16
]
sub
ecx
8
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
ARGBToRGB24Row_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm6
xmmword
ptr
kShuffleMaskARGBToRGB24
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
lea
eax
[
eax
+
64
]
pshufb
xmm0
xmm6
pshufb
xmm1
xmm6
pshufb
xmm2
xmm6
pshufb
xmm3
xmm6
movdqa
xmm4
xmm1
psrldq
xmm1
4
pslldq
xmm4
12
movdqa
xmm5
xmm2
por
xmm0
xmm4
pslldq
xmm5
8
movdqu
[
edx
]
xmm0
por
xmm1
xmm5
psrldq
xmm2
8
pslldq
xmm3
4
por
xmm2
xmm3
movdqu
[
edx
+
16
]
xmm1
movdqu
[
edx
+
32
]
xmm2
lea
edx
[
edx
+
48
]
sub
ecx
16
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
ARGBToRAWRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm6
xmmword
ptr
kShuffleMaskARGBToRAW
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
lea
eax
[
eax
+
64
]
pshufb
xmm0
xmm6
pshufb
xmm1
xmm6
pshufb
xmm2
xmm6
pshufb
xmm3
xmm6
movdqa
xmm4
xmm1
psrldq
xmm1
4
pslldq
xmm4
12
movdqa
xmm5
xmm2
por
xmm0
xmm4
pslldq
xmm5
8
movdqu
[
edx
]
xmm0
por
xmm1
xmm5
psrldq
xmm2
8
pslldq
xmm3
4
por
xmm2
xmm3
movdqu
[
edx
+
16
]
xmm1
movdqu
[
edx
+
32
]
xmm2
lea
edx
[
edx
+
48
]
sub
ecx
16
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
ARGBToRGB565Row_SSE2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm3
xmm3
psrld
xmm3
27
pcmpeqb
xmm4
xmm4
psrld
xmm4
26
pslld
xmm4
5
pcmpeqb
xmm5
xmm5
pslld
xmm5
11
convertloop
:
movdqu
xmm0
[
eax
]
movdqa
xmm1
xmm0
movdqa
xmm2
xmm0
pslld
xmm0
8
psrld
xmm1
3
psrld
xmm2
5
psrad
xmm0
16
pand
xmm1
xmm3
pand
xmm2
xmm4
pand
xmm0
xmm5
por
xmm1
xmm2
por
xmm0
xmm1
packssdw
xmm0
xmm0
lea
eax
[
eax
+
16
]
movq
qword
ptr
[
edx
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
4
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
ARGBToRGB565DitherRow_SSE2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
uint32_t
dither4
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
movd
xmm6
[
esp
+
12
]
mov
ecx
[
esp
+
16
]
punpcklbw
xmm6
xmm6
movdqa
xmm7
xmm6
punpcklwd
xmm6
xmm6
punpckhwd
xmm7
xmm7
pcmpeqb
xmm3
xmm3
psrld
xmm3
27
pcmpeqb
xmm4
xmm4
psrld
xmm4
26
pslld
xmm4
5
pcmpeqb
xmm5
xmm5
pslld
xmm5
11
convertloop
:
movdqu
xmm0
[
eax
]
paddusb
xmm0
xmm6
movdqa
xmm1
xmm0
movdqa
xmm2
xmm0
pslld
xmm0
8
psrld
xmm1
3
psrld
xmm2
5
psrad
xmm0
16
pand
xmm1
xmm3
pand
xmm2
xmm4
pand
xmm0
xmm5
por
xmm1
xmm2
por
xmm0
xmm1
packssdw
xmm0
xmm0
lea
eax
[
eax
+
16
]
movq
qword
ptr
[
edx
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
4
jg
convertloop
ret
}
}
#
ifdef
HAS_ARGBTORGB565DITHERROW_AVX2
__declspec
(
naked
)
void
ARGBToRGB565DitherRow_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
uint32_t
dither4
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
vbroadcastss
xmm6
[
esp
+
12
]
mov
ecx
[
esp
+
16
]
vpunpcklbw
xmm6
xmm6
xmm6
vpermq
ymm6
ymm6
0xd8
vpunpcklwd
ymm6
ymm6
ymm6
vpcmpeqb
ymm3
ymm3
ymm3
vpsrld
ymm3
ymm3
27
vpcmpeqb
ymm4
ymm4
ymm4
vpsrld
ymm4
ymm4
26
vpslld
ymm4
ymm4
5
vpslld
ymm5
ymm3
11
convertloop
:
vmovdqu
ymm0
[
eax
]
vpaddusb
ymm0
ymm0
ymm6
vpsrld
ymm2
ymm0
5
vpsrld
ymm1
ymm0
3
vpsrld
ymm0
ymm0
8
vpand
ymm2
ymm2
ymm4
vpand
ymm1
ymm1
ymm3
vpand
ymm0
ymm0
ymm5
vpor
ymm1
ymm1
ymm2
vpor
ymm0
ymm0
ymm1
vpackusdw
ymm0
ymm0
ymm0
vpermq
ymm0
ymm0
0xd8
lea
eax
[
eax
+
32
]
vmovdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
8
jg
convertloop
vzeroupper
ret
}
}
#
endif
__declspec
(
naked
)
void
ARGBToARGB1555Row_SSE2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm4
xmm4
psrld
xmm4
27
movdqa
xmm5
xmm4
pslld
xmm5
5
movdqa
xmm6
xmm4
pslld
xmm6
10
pcmpeqb
xmm7
xmm7
pslld
xmm7
15
convertloop
:
movdqu
xmm0
[
eax
]
movdqa
xmm1
xmm0
movdqa
xmm2
xmm0
movdqa
xmm3
xmm0
psrad
xmm0
16
psrld
xmm1
3
psrld
xmm2
6
psrld
xmm3
9
pand
xmm0
xmm7
pand
xmm1
xmm4
pand
xmm2
xmm5
pand
xmm3
xmm6
por
xmm0
xmm1
por
xmm2
xmm3
por
xmm0
xmm2
packssdw
xmm0
xmm0
lea
eax
[
eax
+
16
]
movq
qword
ptr
[
edx
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
4
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
ARGBToARGB4444Row_SSE2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm4
xmm4
psllw
xmm4
12
movdqa
xmm3
xmm4
psrlw
xmm3
8
convertloop
:
movdqu
xmm0
[
eax
]
movdqa
xmm1
xmm0
pand
xmm0
xmm3
pand
xmm1
xmm4
psrld
xmm0
4
psrld
xmm1
8
por
xmm0
xmm1
packuswb
xmm0
xmm0
lea
eax
[
eax
+
16
]
movq
qword
ptr
[
edx
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
4
jg
convertloop
ret
}
}
#
ifdef
HAS_ARGBTORGB565ROW_AVX2
__declspec
(
naked
)
void
ARGBToRGB565Row_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vpcmpeqb
ymm3
ymm3
ymm3
vpsrld
ymm3
ymm3
27
vpcmpeqb
ymm4
ymm4
ymm4
vpsrld
ymm4
ymm4
26
vpslld
ymm4
ymm4
5
vpslld
ymm5
ymm3
11
convertloop
:
vmovdqu
ymm0
[
eax
]
vpsrld
ymm2
ymm0
5
vpsrld
ymm1
ymm0
3
vpsrld
ymm0
ymm0
8
vpand
ymm2
ymm2
ymm4
vpand
ymm1
ymm1
ymm3
vpand
ymm0
ymm0
ymm5
vpor
ymm1
ymm1
ymm2
vpor
ymm0
ymm0
ymm1
vpackusdw
ymm0
ymm0
ymm0
vpermq
ymm0
ymm0
0xd8
lea
eax
[
eax
+
32
]
vmovdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
8
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBTOARGB1555ROW_AVX2
__declspec
(
naked
)
void
ARGBToARGB1555Row_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vpcmpeqb
ymm4
ymm4
ymm4
vpsrld
ymm4
ymm4
27
vpslld
ymm5
ymm4
5
vpslld
ymm6
ymm4
10
vpcmpeqb
ymm7
ymm7
ymm7
vpslld
ymm7
ymm7
15
convertloop
:
vmovdqu
ymm0
[
eax
]
vpsrld
ymm3
ymm0
9
vpsrld
ymm2
ymm0
6
vpsrld
ymm1
ymm0
3
vpsrad
ymm0
ymm0
16
vpand
ymm3
ymm3
ymm6
vpand
ymm2
ymm2
ymm5
vpand
ymm1
ymm1
ymm4
vpand
ymm0
ymm0
ymm7
vpor
ymm0
ymm0
ymm1
vpor
ymm2
ymm2
ymm3
vpor
ymm0
ymm0
ymm2
vpackssdw
ymm0
ymm0
ymm0
vpermq
ymm0
ymm0
0xd8
lea
eax
[
eax
+
32
]
vmovdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
8
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBTOARGB4444ROW_AVX2
__declspec
(
naked
)
void
ARGBToARGB4444Row_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_rgb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vpcmpeqb
ymm4
ymm4
ymm4
vpsllw
ymm4
ymm4
12
vpsrlw
ymm3
ymm4
8
convertloop
:
vmovdqu
ymm0
[
eax
]
vpand
ymm1
ymm0
ymm4
vpand
ymm0
ymm0
ymm3
vpsrld
ymm1
ymm1
8
vpsrld
ymm0
ymm0
4
vpor
ymm0
ymm0
ymm1
vpackuswb
ymm0
ymm0
ymm0
vpermq
ymm0
ymm0
0xd8
lea
eax
[
eax
+
32
]
vmovdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
8
jg
convertloop
vzeroupper
ret
}
}
#
endif
__declspec
(
naked
)
void
ARGBToYRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm4
xmmword
ptr
kARGBToY
movdqa
xmm5
xmmword
ptr
kAddY16
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
pmaddubsw
xmm0
xmm4
pmaddubsw
xmm1
xmm4
pmaddubsw
xmm2
xmm4
pmaddubsw
xmm3
xmm4
lea
eax
[
eax
+
64
]
phaddw
xmm0
xmm1
phaddw
xmm2
xmm3
psrlw
xmm0
7
psrlw
xmm2
7
packuswb
xmm0
xmm2
paddb
xmm0
xmm5
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
ret
}
}
#
ifdef
HAS_ARGBTOUVROW_SSSE3
__declspec
(
naked
)
void
ARGBToYJRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm4
xmmword
ptr
kARGBToYJ
movdqa
xmm5
xmmword
ptr
kAddYJ64
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
pmaddubsw
xmm0
xmm4
pmaddubsw
xmm1
xmm4
pmaddubsw
xmm2
xmm4
pmaddubsw
xmm3
xmm4
lea
eax
[
eax
+
64
]
phaddw
xmm0
xmm1
phaddw
xmm2
xmm3
paddw
xmm0
xmm5
paddw
xmm2
xmm5
psrlw
xmm0
7
psrlw
xmm2
7
packuswb
xmm0
xmm2
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBTOYROW_AVX2
__declspec
(
naked
)
void
ARGBToYRow_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vbroadcastf128
ymm4
xmmword
ptr
kARGBToY
vbroadcastf128
ymm5
xmmword
ptr
kAddY16
vmovdqu
ymm6
ymmword
ptr
kPermdARGBToY_AVX
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
vmovdqu
ymm2
[
eax
+
64
]
vmovdqu
ymm3
[
eax
+
96
]
vpmaddubsw
ymm0
ymm0
ymm4
vpmaddubsw
ymm1
ymm1
ymm4
vpmaddubsw
ymm2
ymm2
ymm4
vpmaddubsw
ymm3
ymm3
ymm4
lea
eax
[
eax
+
128
]
vphaddw
ymm0
ymm0
ymm1
vphaddw
ymm2
ymm2
ymm3
vpsrlw
ymm0
ymm0
7
vpsrlw
ymm2
ymm2
7
vpackuswb
ymm0
ymm0
ymm2
vpermd
ymm0
ymm6
ymm0
vpaddb
ymm0
ymm0
ymm5
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
32
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBTOYJROW_AVX2
__declspec
(
naked
)
void
ARGBToYJRow_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vbroadcastf128
ymm4
xmmword
ptr
kARGBToYJ
vbroadcastf128
ymm5
xmmword
ptr
kAddYJ64
vmovdqu
ymm6
ymmword
ptr
kPermdARGBToY_AVX
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
vmovdqu
ymm2
[
eax
+
64
]
vmovdqu
ymm3
[
eax
+
96
]
vpmaddubsw
ymm0
ymm0
ymm4
vpmaddubsw
ymm1
ymm1
ymm4
vpmaddubsw
ymm2
ymm2
ymm4
vpmaddubsw
ymm3
ymm3
ymm4
lea
eax
[
eax
+
128
]
vphaddw
ymm0
ymm0
ymm1
vphaddw
ymm2
ymm2
ymm3
vpaddw
ymm0
ymm0
ymm5
vpaddw
ymm2
ymm2
ymm5
vpsrlw
ymm0
ymm0
7
vpsrlw
ymm2
ymm2
7
vpackuswb
ymm0
ymm0
ymm2
vpermd
ymm0
ymm6
ymm0
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
32
jg
convertloop
vzeroupper
ret
}
}
#
endif
__declspec
(
naked
)
void
BGRAToYRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm4
xmmword
ptr
kBGRAToY
movdqa
xmm5
xmmword
ptr
kAddY16
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
pmaddubsw
xmm0
xmm4
pmaddubsw
xmm1
xmm4
pmaddubsw
xmm2
xmm4
pmaddubsw
xmm3
xmm4
lea
eax
[
eax
+
64
]
phaddw
xmm0
xmm1
phaddw
xmm2
xmm3
psrlw
xmm0
7
psrlw
xmm2
7
packuswb
xmm0
xmm2
paddb
xmm0
xmm5
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
ABGRToYRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm4
xmmword
ptr
kABGRToY
movdqa
xmm5
xmmword
ptr
kAddY16
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
pmaddubsw
xmm0
xmm4
pmaddubsw
xmm1
xmm4
pmaddubsw
xmm2
xmm4
pmaddubsw
xmm3
xmm4
lea
eax
[
eax
+
64
]
phaddw
xmm0
xmm1
phaddw
xmm2
xmm3
psrlw
xmm0
7
psrlw
xmm2
7
packuswb
xmm0
xmm2
paddb
xmm0
xmm5
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
RGBAToYRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm4
xmmword
ptr
kRGBAToY
movdqa
xmm5
xmmword
ptr
kAddY16
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
pmaddubsw
xmm0
xmm4
pmaddubsw
xmm1
xmm4
pmaddubsw
xmm2
xmm4
pmaddubsw
xmm3
xmm4
lea
eax
[
eax
+
64
]
phaddw
xmm0
xmm1
phaddw
xmm2
xmm3
psrlw
xmm0
7
psrlw
xmm2
7
packuswb
xmm0
xmm2
paddb
xmm0
xmm5
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
ret
}
}
#
ifdef
HAS_ARGBTOUVROW_SSSE3
__declspec
(
naked
)
void
ARGBToUVRow_SSSE3
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
movdqa
xmm5
xmmword
ptr
kBiasUV128
movdqa
xmm6
xmmword
ptr
kARGBToV
movdqa
xmm7
xmmword
ptr
kARGBToU
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm4
[
eax
+
esi
]
pavgb
xmm0
xmm4
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm4
[
eax
+
esi
+
16
]
pavgb
xmm1
xmm4
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm4
[
eax
+
esi
+
32
]
pavgb
xmm2
xmm4
movdqu
xmm3
[
eax
+
48
]
movdqu
xmm4
[
eax
+
esi
+
48
]
pavgb
xmm3
xmm4
lea
eax
[
eax
+
64
]
movdqa
xmm4
xmm0
shufps
xmm0
xmm1
0x88
shufps
xmm4
xmm1
0xdd
pavgb
xmm0
xmm4
movdqa
xmm4
xmm2
shufps
xmm2
xmm3
0x88
shufps
xmm4
xmm3
0xdd
pavgb
xmm2
xmm4
movdqa
xmm1
xmm0
movdqa
xmm3
xmm2
pmaddubsw
xmm0
xmm7
pmaddubsw
xmm2
xmm7
pmaddubsw
xmm1
xmm6
pmaddubsw
xmm3
xmm6
phaddw
xmm0
xmm2
phaddw
xmm1
xmm3
psraw
xmm0
8
psraw
xmm1
8
packsswb
xmm0
xmm1
paddb
xmm0
xmm5
movlps
qword
ptr
[
edx
]
xmm0
movhps
qword
ptr
[
edx
+
edi
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
16
jg
convertloop
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
ARGBToUVJRow_SSSE3
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
movdqa
xmm5
xmmword
ptr
kBiasUV128
movdqa
xmm6
xmmword
ptr
kARGBToVJ
movdqa
xmm7
xmmword
ptr
kARGBToUJ
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm4
[
eax
+
esi
]
pavgb
xmm0
xmm4
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm4
[
eax
+
esi
+
16
]
pavgb
xmm1
xmm4
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm4
[
eax
+
esi
+
32
]
pavgb
xmm2
xmm4
movdqu
xmm3
[
eax
+
48
]
movdqu
xmm4
[
eax
+
esi
+
48
]
pavgb
xmm3
xmm4
lea
eax
[
eax
+
64
]
movdqa
xmm4
xmm0
shufps
xmm0
xmm1
0x88
shufps
xmm4
xmm1
0xdd
pavgb
xmm0
xmm4
movdqa
xmm4
xmm2
shufps
xmm2
xmm3
0x88
shufps
xmm4
xmm3
0xdd
pavgb
xmm2
xmm4
movdqa
xmm1
xmm0
movdqa
xmm3
xmm2
pmaddubsw
xmm0
xmm7
pmaddubsw
xmm2
xmm7
pmaddubsw
xmm1
xmm6
pmaddubsw
xmm3
xmm6
phaddw
xmm0
xmm2
phaddw
xmm1
xmm3
paddw
xmm0
xmm5
paddw
xmm1
xmm5
psraw
xmm0
8
psraw
xmm1
8
packsswb
xmm0
xmm1
movlps
qword
ptr
[
edx
]
xmm0
movhps
qword
ptr
[
edx
+
edi
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
16
jg
convertloop
pop
edi
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_ARGBTOUVROW_AVX2
__declspec
(
naked
)
void
ARGBToUVRow_AVX2
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
vbroadcastf128
ymm5
xmmword
ptr
kBiasUV128
vbroadcastf128
ymm6
xmmword
ptr
kARGBToV
vbroadcastf128
ymm7
xmmword
ptr
kARGBToU
sub
edi
edx
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
vmovdqu
ymm2
[
eax
+
64
]
vmovdqu
ymm3
[
eax
+
96
]
vpavgb
ymm0
ymm0
[
eax
+
esi
]
vpavgb
ymm1
ymm1
[
eax
+
esi
+
32
]
vpavgb
ymm2
ymm2
[
eax
+
esi
+
64
]
vpavgb
ymm3
ymm3
[
eax
+
esi
+
96
]
lea
eax
[
eax
+
128
]
vshufps
ymm4
ymm0
ymm1
0x88
vshufps
ymm0
ymm0
ymm1
0xdd
vpavgb
ymm0
ymm0
ymm4
vshufps
ymm4
ymm2
ymm3
0x88
vshufps
ymm2
ymm2
ymm3
0xdd
vpavgb
ymm2
ymm2
ymm4
vpmaddubsw
ymm1
ymm0
ymm7
vpmaddubsw
ymm3
ymm2
ymm7
vpmaddubsw
ymm0
ymm0
ymm6
vpmaddubsw
ymm2
ymm2
ymm6
vphaddw
ymm1
ymm1
ymm3
vphaddw
ymm0
ymm0
ymm2
vpsraw
ymm1
ymm1
8
vpsraw
ymm0
ymm0
8
vpacksswb
ymm0
ymm1
ymm0
vpermq
ymm0
ymm0
0xd8
vpshufb
ymm0
ymm0
ymmword
ptr
kShufARGBToUV_AVX
vpaddb
ymm0
ymm0
ymm5
vextractf128
[
edx
]
ymm0
0
vextractf128
[
edx
+
edi
]
ymm0
1
lea
edx
[
edx
+
16
]
sub
ecx
32
jg
convertloop
pop
edi
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBTOUVJROW_AVX2
__declspec
(
naked
)
void
ARGBToUVJRow_AVX2
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
vbroadcastf128
ymm5
xmmword
ptr
kBiasUV128
vbroadcastf128
ymm6
xmmword
ptr
kARGBToVJ
vbroadcastf128
ymm7
xmmword
ptr
kARGBToUJ
sub
edi
edx
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
vmovdqu
ymm2
[
eax
+
64
]
vmovdqu
ymm3
[
eax
+
96
]
vpavgb
ymm0
ymm0
[
eax
+
esi
]
vpavgb
ymm1
ymm1
[
eax
+
esi
+
32
]
vpavgb
ymm2
ymm2
[
eax
+
esi
+
64
]
vpavgb
ymm3
ymm3
[
eax
+
esi
+
96
]
lea
eax
[
eax
+
128
]
vshufps
ymm4
ymm0
ymm1
0x88
vshufps
ymm0
ymm0
ymm1
0xdd
vpavgb
ymm0
ymm0
ymm4
vshufps
ymm4
ymm2
ymm3
0x88
vshufps
ymm2
ymm2
ymm3
0xdd
vpavgb
ymm2
ymm2
ymm4
vpmaddubsw
ymm1
ymm0
ymm7
vpmaddubsw
ymm3
ymm2
ymm7
vpmaddubsw
ymm0
ymm0
ymm6
vpmaddubsw
ymm2
ymm2
ymm6
vphaddw
ymm1
ymm1
ymm3
vphaddw
ymm0
ymm0
ymm2
vpaddw
ymm1
ymm1
ymm5
vpaddw
ymm0
ymm0
ymm5
vpsraw
ymm1
ymm1
8
vpsraw
ymm0
ymm0
8
vpacksswb
ymm0
ymm1
ymm0
vpermq
ymm0
ymm0
0xd8
vpshufb
ymm0
ymm0
ymmword
ptr
kShufARGBToUV_AVX
vextractf128
[
edx
]
ymm0
0
vextractf128
[
edx
+
edi
]
ymm0
1
lea
edx
[
edx
+
16
]
sub
ecx
32
jg
convertloop
pop
edi
pop
esi
vzeroupper
ret
}
}
#
endif
__declspec
(
naked
)
void
ARGBToUV444Row_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
movdqa
xmm5
xmmword
ptr
kBiasUV128
movdqa
xmm6
xmmword
ptr
kARGBToV
movdqa
xmm7
xmmword
ptr
kARGBToU
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
pmaddubsw
xmm0
xmm7
pmaddubsw
xmm1
xmm7
pmaddubsw
xmm2
xmm7
pmaddubsw
xmm3
xmm7
phaddw
xmm0
xmm1
phaddw
xmm2
xmm3
psraw
xmm0
8
psraw
xmm2
8
packsswb
xmm0
xmm2
paddb
xmm0
xmm5
movdqu
[
edx
]
xmm0
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
pmaddubsw
xmm0
xmm6
pmaddubsw
xmm1
xmm6
pmaddubsw
xmm2
xmm6
pmaddubsw
xmm3
xmm6
phaddw
xmm0
xmm1
phaddw
xmm2
xmm3
psraw
xmm0
8
psraw
xmm2
8
packsswb
xmm0
xmm2
paddb
xmm0
xmm5
lea
eax
[
eax
+
64
]
movdqu
[
edx
+
edi
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
pop
edi
ret
}
}
__declspec
(
naked
)
void
BGRAToUVRow_SSSE3
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
movdqa
xmm5
xmmword
ptr
kBiasUV128
movdqa
xmm6
xmmword
ptr
kBGRAToV
movdqa
xmm7
xmmword
ptr
kBGRAToU
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm4
[
eax
+
esi
]
pavgb
xmm0
xmm4
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm4
[
eax
+
esi
+
16
]
pavgb
xmm1
xmm4
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm4
[
eax
+
esi
+
32
]
pavgb
xmm2
xmm4
movdqu
xmm3
[
eax
+
48
]
movdqu
xmm4
[
eax
+
esi
+
48
]
pavgb
xmm3
xmm4
lea
eax
[
eax
+
64
]
movdqa
xmm4
xmm0
shufps
xmm0
xmm1
0x88
shufps
xmm4
xmm1
0xdd
pavgb
xmm0
xmm4
movdqa
xmm4
xmm2
shufps
xmm2
xmm3
0x88
shufps
xmm4
xmm3
0xdd
pavgb
xmm2
xmm4
movdqa
xmm1
xmm0
movdqa
xmm3
xmm2
pmaddubsw
xmm0
xmm7
pmaddubsw
xmm2
xmm7
pmaddubsw
xmm1
xmm6
pmaddubsw
xmm3
xmm6
phaddw
xmm0
xmm2
phaddw
xmm1
xmm3
psraw
xmm0
8
psraw
xmm1
8
packsswb
xmm0
xmm1
paddb
xmm0
xmm5
movlps
qword
ptr
[
edx
]
xmm0
movhps
qword
ptr
[
edx
+
edi
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
16
jg
convertloop
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
ABGRToUVRow_SSSE3
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
movdqa
xmm5
xmmword
ptr
kBiasUV128
movdqa
xmm6
xmmword
ptr
kABGRToV
movdqa
xmm7
xmmword
ptr
kABGRToU
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm4
[
eax
+
esi
]
pavgb
xmm0
xmm4
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm4
[
eax
+
esi
+
16
]
pavgb
xmm1
xmm4
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm4
[
eax
+
esi
+
32
]
pavgb
xmm2
xmm4
movdqu
xmm3
[
eax
+
48
]
movdqu
xmm4
[
eax
+
esi
+
48
]
pavgb
xmm3
xmm4
lea
eax
[
eax
+
64
]
movdqa
xmm4
xmm0
shufps
xmm0
xmm1
0x88
shufps
xmm4
xmm1
0xdd
pavgb
xmm0
xmm4
movdqa
xmm4
xmm2
shufps
xmm2
xmm3
0x88
shufps
xmm4
xmm3
0xdd
pavgb
xmm2
xmm4
movdqa
xmm1
xmm0
movdqa
xmm3
xmm2
pmaddubsw
xmm0
xmm7
pmaddubsw
xmm2
xmm7
pmaddubsw
xmm1
xmm6
pmaddubsw
xmm3
xmm6
phaddw
xmm0
xmm2
phaddw
xmm1
xmm3
psraw
xmm0
8
psraw
xmm1
8
packsswb
xmm0
xmm1
paddb
xmm0
xmm5
movlps
qword
ptr
[
edx
]
xmm0
movhps
qword
ptr
[
edx
+
edi
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
16
jg
convertloop
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
RGBAToUVRow_SSSE3
(
const
uint8_t
*
src_argb
int
src_stride_argb
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
movdqa
xmm5
xmmword
ptr
kBiasUV128
movdqa
xmm6
xmmword
ptr
kRGBAToV
movdqa
xmm7
xmmword
ptr
kRGBAToU
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm4
[
eax
+
esi
]
pavgb
xmm0
xmm4
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm4
[
eax
+
esi
+
16
]
pavgb
xmm1
xmm4
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm4
[
eax
+
esi
+
32
]
pavgb
xmm2
xmm4
movdqu
xmm3
[
eax
+
48
]
movdqu
xmm4
[
eax
+
esi
+
48
]
pavgb
xmm3
xmm4
lea
eax
[
eax
+
64
]
movdqa
xmm4
xmm0
shufps
xmm0
xmm1
0x88
shufps
xmm4
xmm1
0xdd
pavgb
xmm0
xmm4
movdqa
xmm4
xmm2
shufps
xmm2
xmm3
0x88
shufps
xmm4
xmm3
0xdd
pavgb
xmm2
xmm4
movdqa
xmm1
xmm0
movdqa
xmm3
xmm2
pmaddubsw
xmm0
xmm7
pmaddubsw
xmm2
xmm7
pmaddubsw
xmm1
xmm6
pmaddubsw
xmm3
xmm6
phaddw
xmm0
xmm2
phaddw
xmm1
xmm3
psraw
xmm0
8
psraw
xmm1
8
packsswb
xmm0
xmm1
paddb
xmm0
xmm5
movlps
qword
ptr
[
edx
]
xmm0
movhps
qword
ptr
[
edx
+
edi
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
16
jg
convertloop
pop
edi
pop
esi
ret
}
}
#
define
READYUV444_AVX2
\
__asm
{
\
__asm
vmovdqu
xmm3
[
esi
]
/
*
U
*
/
\
__asm
vmovdqu
xmm1
[
esi
+
edi
]
/
*
V
*
/
\
__asm
lea
esi
[
esi
+
16
]
\
__asm
vpermq
ymm3
ymm3
0xd8
\
__asm
vpermq
ymm1
ymm1
0xd8
\
__asm
vpunpcklbw
ymm3
ymm3
ymm1
/
*
UV
*
/
\
__asm
vmovdqu
xmm4
[
eax
]
/
*
Y
*
/
\
__asm
vpermq
ymm4
ymm4
0xd8
\
__asm
vpunpcklbw
ymm4
ymm4
ymm4
\
__asm
lea
eax
[
eax
+
16
]
}
#
define
READYUVA444_AVX2
\
__asm
{
\
__asm
vmovdqu
xmm3
[
esi
]
/
*
U
*
/
\
__asm
vmovdqu
xmm1
[
esi
+
edi
]
/
*
V
*
/
\
__asm
lea
esi
[
esi
+
16
]
\
__asm
vpermq
ymm3
ymm3
0xd8
\
__asm
vpermq
ymm1
ymm1
0xd8
\
__asm
vpunpcklbw
ymm3
ymm3
ymm1
/
*
UV
*
/
\
__asm
vmovdqu
xmm4
[
eax
]
/
*
Y
*
/
\
__asm
vpermq
ymm4
ymm4
0xd8
\
__asm
vpunpcklbw
ymm4
ymm4
ymm4
\
__asm
lea
eax
[
eax
+
16
]
\
__asm
vmovdqu
xmm5
[
ebp
]
/
*
A
*
/
\
__asm
vpermq
ymm5
ymm5
0xd8
\
__asm
lea
ebp
[
ebp
+
16
]
}
#
define
READYUV422_AVX2
\
__asm
{
\
__asm
vmovq
xmm3
qword
ptr
[
esi
]
/
*
U
*
/
\
__asm
vmovq
xmm1
qword
ptr
[
esi
+
edi
]
/
*
V
*
/
\
__asm
lea
esi
[
esi
+
8
]
\
__asm
vpunpcklbw
ymm3
ymm3
ymm1
/
*
UV
*
/
\
__asm
vpermq
ymm3
ymm3
0xd8
\
__asm
vpunpcklwd
ymm3
ymm3
ymm3
/
*
UVUV
(
upsample
)
*
/
\
__asm
vmovdqu
xmm4
[
eax
]
/
*
Y
*
/
\
__asm
vpermq
ymm4
ymm4
0xd8
\
__asm
vpunpcklbw
ymm4
ymm4
ymm4
\
__asm
lea
eax
[
eax
+
16
]
}
#
define
READYUVA422_AVX2
\
__asm
{
\
__asm
vmovq
xmm3
qword
ptr
[
esi
]
/
*
U
*
/
\
__asm
vmovq
xmm1
qword
ptr
[
esi
+
edi
]
/
*
V
*
/
\
__asm
lea
esi
[
esi
+
8
]
\
__asm
vpunpcklbw
ymm3
ymm3
ymm1
/
*
UV
*
/
\
__asm
vpermq
ymm3
ymm3
0xd8
\
__asm
vpunpcklwd
ymm3
ymm3
ymm3
/
*
UVUV
(
upsample
)
*
/
\
__asm
vmovdqu
xmm4
[
eax
]
/
*
Y
*
/
\
__asm
vpermq
ymm4
ymm4
0xd8
\
__asm
vpunpcklbw
ymm4
ymm4
ymm4
\
__asm
lea
eax
[
eax
+
16
]
\
__asm
vmovdqu
xmm5
[
ebp
]
/
*
A
*
/
\
__asm
vpermq
ymm5
ymm5
0xd8
\
__asm
lea
ebp
[
ebp
+
16
]
}
#
define
READNV12_AVX2
\
__asm
{
\
__asm
vmovdqu
xmm3
[
esi
]
/
*
UV
*
/
\
__asm
lea
esi
[
esi
+
16
]
\
__asm
vpermq
ymm3
ymm3
0xd8
\
__asm
vpunpcklwd
ymm3
ymm3
ymm3
/
*
UVUV
(
upsample
)
*
/
\
__asm
vmovdqu
xmm4
[
eax
]
/
*
Y
*
/
\
__asm
vpermq
ymm4
ymm4
0xd8
\
__asm
vpunpcklbw
ymm4
ymm4
ymm4
\
__asm
lea
eax
[
eax
+
16
]
}
#
define
READNV21_AVX2
\
__asm
{
\
__asm
vmovdqu
xmm3
[
esi
]
/
*
UV
*
/
\
__asm
lea
esi
[
esi
+
16
]
\
__asm
vpermq
ymm3
ymm3
0xd8
\
__asm
vpshufb
ymm3
ymm3
ymmword
ptr
kShuffleNV21
\
__asm
vmovdqu
xmm4
[
eax
]
/
*
Y
*
/
\
__asm
vpermq
ymm4
ymm4
0xd8
\
__asm
vpunpcklbw
ymm4
ymm4
ymm4
\
__asm
lea
eax
[
eax
+
16
]
}
#
define
READYUY2_AVX2
\
__asm
{
\
__asm
vmovdqu
ymm4
[
eax
]
/
*
YUY2
*
/
\
__asm
vpshufb
ymm4
ymm4
ymmword
ptr
kShuffleYUY2Y
\
__asm
vmovdqu
ymm3
[
eax
]
/
*
UV
*
/
\
__asm
vpshufb
ymm3
ymm3
ymmword
ptr
kShuffleYUY2UV
\
__asm
lea
eax
[
eax
+
32
]
}
#
define
READUYVY_AVX2
\
__asm
{
\
__asm
vmovdqu
ymm4
[
eax
]
/
*
UYVY
*
/
\
__asm
vpshufb
ymm4
ymm4
ymmword
ptr
kShuffleUYVYY
\
__asm
vmovdqu
ymm3
[
eax
]
/
*
UV
*
/
\
__asm
vpshufb
ymm3
ymm3
ymmword
ptr
kShuffleUYVYUV
\
__asm
lea
eax
[
eax
+
32
]
}
#
define
YUVTORGB_AVX2
(
YuvConstants
)
\
__asm
{
\
__asm
vpsubb
ymm3
ymm3
ymmword
ptr
kBiasUV128
\
__asm
vpmulhuw
ymm4
ymm4
ymmword
ptr
[
YuvConstants
+
KYTORGB
]
\
__asm
vmovdqa
ymm0
ymmword
ptr
[
YuvConstants
+
KUVTOB
]
\
__asm
vmovdqa
ymm1
ymmword
ptr
[
YuvConstants
+
KUVTOG
]
\
__asm
vmovdqa
ymm2
ymmword
ptr
[
YuvConstants
+
KUVTOR
]
\
__asm
vpmaddubsw
ymm0
ymm0
ymm3
/
*
B
UV
*
/
\
__asm
vpmaddubsw
ymm1
ymm1
ymm3
/
*
G
UV
*
/
\
__asm
vpmaddubsw
ymm2
ymm2
ymm3
/
*
B
UV
*
/
\
__asm
vmovdqu
ymm3
ymmword
ptr
[
YuvConstants
+
KYBIASTORGB
]
\
__asm
vpaddw
ymm4
ymm3
ymm4
\
__asm
vpaddsw
ymm0
ymm0
ymm4
\
__asm
vpsubsw
ymm1
ymm4
ymm1
\
__asm
vpaddsw
ymm2
ymm2
ymm4
\
__asm
vpsraw
ymm0
ymm0
6
\
__asm
vpsraw
ymm1
ymm1
6
\
__asm
vpsraw
ymm2
ymm2
6
\
__asm
vpackuswb
ymm0
ymm0
ymm0
\
__asm
vpackuswb
ymm1
ymm1
ymm1
\
__asm
vpackuswb
ymm2
ymm2
ymm2
}
#
define
STOREARGB_AVX2
\
__asm
{
\
__asm
vpunpcklbw
ymm0
ymm0
ymm1
/
*
BG
*
/
\
__asm
vpermq
ymm0
ymm0
0xd8
\
__asm
vpunpcklbw
ymm2
ymm2
ymm5
/
*
RA
*
/
\
__asm
vpermq
ymm2
ymm2
0xd8
\
__asm
vpunpcklwd
ymm1
ymm0
ymm2
/
*
BGRA
first
8
pixels
*
/
\
__asm
vpunpckhwd
ymm0
ymm0
ymm2
/
*
BGRA
next
8
pixels
*
/
\
__asm
vmovdqu
0
[
edx
]
ymm1
\
__asm
vmovdqu
32
[
edx
]
ymm0
\
__asm
lea
edx
[
edx
+
64
]
}
#
define
STORERGBA_AVX2
\
__asm
{
\
__asm
vpunpcklbw
ymm1
ymm1
ymm2
/
*
GR
*
/
\
__asm
vpermq
ymm1
ymm1
0xd8
\
__asm
vpunpcklbw
ymm2
ymm5
ymm0
/
*
AB
*
/
\
__asm
vpermq
ymm2
ymm2
0xd8
\
__asm
vpunpcklwd
ymm0
ymm2
ymm1
/
*
ABGR
first
8
pixels
*
/
\
__asm
vpunpckhwd
ymm1
ymm2
ymm1
/
*
ABGR
next
8
pixels
*
/
\
__asm
vmovdqu
[
edx
]
ymm0
\
__asm
vmovdqu
[
edx
+
32
]
ymm1
\
__asm
lea
edx
[
edx
+
64
]
}
#
ifdef
HAS_I422TOARGBROW_AVX2
__declspec
(
naked
)
void
I422ToARGBRow_AVX2
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
mov
eax
[
esp
+
12
+
4
]
mov
esi
[
esp
+
12
+
8
]
mov
edi
[
esp
+
12
+
12
]
mov
edx
[
esp
+
12
+
16
]
mov
ebx
[
esp
+
12
+
20
]
mov
ecx
[
esp
+
12
+
24
]
sub
edi
esi
vpcmpeqb
ymm5
ymm5
ymm5
convertloop
:
READYUV422_AVX2
YUVTORGB_AVX2
(
ebx
)
STOREARGB_AVX2
sub
ecx
16
jg
convertloop
pop
ebx
pop
edi
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_I422ALPHATOARGBROW_AVX2
__declspec
(
naked
)
void
I422AlphaToARGBRow_AVX2
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
const
uint8_t
*
a_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
push
ebp
mov
eax
[
esp
+
16
+
4
]
mov
esi
[
esp
+
16
+
8
]
mov
edi
[
esp
+
16
+
12
]
mov
ebp
[
esp
+
16
+
16
]
mov
edx
[
esp
+
16
+
20
]
mov
ebx
[
esp
+
16
+
24
]
mov
ecx
[
esp
+
16
+
28
]
sub
edi
esi
convertloop
:
READYUVA422_AVX2
YUVTORGB_AVX2
(
ebx
)
STOREARGB_AVX2
sub
ecx
16
jg
convertloop
pop
ebp
pop
ebx
pop
edi
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_I444TOARGBROW_AVX2
__declspec
(
naked
)
void
I444ToARGBRow_AVX2
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
mov
eax
[
esp
+
12
+
4
]
mov
esi
[
esp
+
12
+
8
]
mov
edi
[
esp
+
12
+
12
]
mov
edx
[
esp
+
12
+
16
]
mov
ebx
[
esp
+
12
+
20
]
mov
ecx
[
esp
+
12
+
24
]
sub
edi
esi
vpcmpeqb
ymm5
ymm5
ymm5
convertloop
:
READYUV444_AVX2
YUVTORGB_AVX2
(
ebx
)
STOREARGB_AVX2
sub
ecx
16
jg
convertloop
pop
ebx
pop
edi
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_I444ALPHATOARGBROW_AVX2
__declspec
(
naked
)
void
I444AlphaToARGBRow_AVX2
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
const
uint8_t
*
a_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
push
ebp
mov
eax
[
esp
+
16
+
4
]
mov
esi
[
esp
+
16
+
8
]
mov
edi
[
esp
+
16
+
12
]
mov
ebp
[
esp
+
16
+
16
]
mov
edx
[
esp
+
16
+
20
]
mov
ebx
[
esp
+
16
+
24
]
mov
ecx
[
esp
+
16
+
28
]
sub
edi
esi
convertloop
:
READYUVA444_AVX2
YUVTORGB_AVX2
(
ebx
)
STOREARGB_AVX2
sub
ecx
16
jg
convertloop
pop
ebp
pop
ebx
pop
edi
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_NV12TOARGBROW_AVX2
__declspec
(
naked
)
void
NV12ToARGBRow_AVX2
(
const
uint8_t
*
y_buf
const
uint8_t
*
uv_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
ebx
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
ebx
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
vpcmpeqb
ymm5
ymm5
ymm5
convertloop
:
READNV12_AVX2
YUVTORGB_AVX2
(
ebx
)
STOREARGB_AVX2
sub
ecx
16
jg
convertloop
pop
ebx
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_NV21TOARGBROW_AVX2
__declspec
(
naked
)
void
NV21ToARGBRow_AVX2
(
const
uint8_t
*
y_buf
const
uint8_t
*
vu_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
ebx
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
ebx
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
vpcmpeqb
ymm5
ymm5
ymm5
convertloop
:
READNV21_AVX2
YUVTORGB_AVX2
(
ebx
)
STOREARGB_AVX2
sub
ecx
16
jg
convertloop
pop
ebx
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_YUY2TOARGBROW_AVX2
__declspec
(
naked
)
void
YUY2ToARGBRow_AVX2
(
const
uint8_t
*
src_yuy2
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
ebx
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
ebx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
vpcmpeqb
ymm5
ymm5
ymm5
convertloop
:
READYUY2_AVX2
YUVTORGB_AVX2
(
ebx
)
STOREARGB_AVX2
sub
ecx
16
jg
convertloop
pop
ebx
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_UYVYTOARGBROW_AVX2
__declspec
(
naked
)
void
UYVYToARGBRow_AVX2
(
const
uint8_t
*
src_uyvy
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
ebx
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
ebx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
vpcmpeqb
ymm5
ymm5
ymm5
convertloop
:
READUYVY_AVX2
YUVTORGB_AVX2
(
ebx
)
STOREARGB_AVX2
sub
ecx
16
jg
convertloop
pop
ebx
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_I422TORGBAROW_AVX2
__declspec
(
naked
)
void
I422ToRGBARow_AVX2
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
mov
eax
[
esp
+
12
+
4
]
mov
esi
[
esp
+
12
+
8
]
mov
edi
[
esp
+
12
+
12
]
mov
edx
[
esp
+
12
+
16
]
mov
ebx
[
esp
+
12
+
20
]
mov
ecx
[
esp
+
12
+
24
]
sub
edi
esi
vpcmpeqb
ymm5
ymm5
ymm5
convertloop
:
READYUV422_AVX2
YUVTORGB_AVX2
(
ebx
)
STORERGBA_AVX2
sub
ecx
16
jg
convertloop
pop
ebx
pop
edi
pop
esi
vzeroupper
ret
}
}
#
endif
#
if
defined
(
HAS_I422TOARGBROW_SSSE3
)
#
define
READYUV444
\
__asm
{
\
__asm
movq
xmm3
qword
ptr
[
esi
]
/
*
U
*
/
\
__asm
movq
xmm1
qword
ptr
[
esi
+
edi
]
/
*
V
*
/
\
__asm
lea
esi
[
esi
+
8
]
\
__asm
punpcklbw
xmm3
xmm1
/
*
UV
*
/
\
__asm
movq
xmm4
qword
ptr
[
eax
]
\
__asm
punpcklbw
xmm4
xmm4
\
__asm
lea
eax
[
eax
+
8
]
}
#
define
READYUVA444
\
__asm
{
\
__asm
movq
xmm3
qword
ptr
[
esi
]
/
*
U
*
/
\
__asm
movq
xmm1
qword
ptr
[
esi
+
edi
]
/
*
V
*
/
\
__asm
lea
esi
[
esi
+
8
]
\
__asm
punpcklbw
xmm3
xmm1
/
*
UV
*
/
\
__asm
movq
xmm4
qword
ptr
[
eax
]
\
__asm
punpcklbw
xmm4
xmm4
\
__asm
lea
eax
[
eax
+
8
]
\
__asm
movq
xmm5
qword
ptr
[
ebp
]
/
*
A
*
/
\
__asm
lea
ebp
[
ebp
+
8
]
}
#
define
READYUV422
\
__asm
{
\
__asm
movd
xmm3
[
esi
]
/
*
U
*
/
\
__asm
movd
xmm1
[
esi
+
edi
]
/
*
V
*
/
\
__asm
lea
esi
[
esi
+
4
]
\
__asm
punpcklbw
xmm3
xmm1
/
*
UV
*
/
\
__asm
punpcklwd
xmm3
xmm3
/
*
UVUV
(
upsample
)
*
/
\
__asm
movq
xmm4
qword
ptr
[
eax
]
\
__asm
punpcklbw
xmm4
xmm4
\
__asm
lea
eax
[
eax
+
8
]
}
#
define
READYUVA422
\
__asm
{
\
__asm
movd
xmm3
[
esi
]
/
*
U
*
/
\
__asm
movd
xmm1
[
esi
+
edi
]
/
*
V
*
/
\
__asm
lea
esi
[
esi
+
4
]
\
__asm
punpcklbw
xmm3
xmm1
/
*
UV
*
/
\
__asm
punpcklwd
xmm3
xmm3
/
*
UVUV
(
upsample
)
*
/
\
__asm
movq
xmm4
qword
ptr
[
eax
]
/
*
Y
*
/
\
__asm
punpcklbw
xmm4
xmm4
\
__asm
lea
eax
[
eax
+
8
]
\
__asm
movq
xmm5
qword
ptr
[
ebp
]
/
*
A
*
/
\
__asm
lea
ebp
[
ebp
+
8
]
}
#
define
READNV12
\
__asm
{
\
__asm
movq
xmm3
qword
ptr
[
esi
]
/
*
UV
*
/
\
__asm
lea
esi
[
esi
+
8
]
\
__asm
punpcklwd
xmm3
xmm3
/
*
UVUV
(
upsample
)
*
/
\
__asm
movq
xmm4
qword
ptr
[
eax
]
\
__asm
punpcklbw
xmm4
xmm4
\
__asm
lea
eax
[
eax
+
8
]
}
#
define
READNV21
\
__asm
{
\
__asm
movq
xmm3
qword
ptr
[
esi
]
/
*
UV
*
/
\
__asm
lea
esi
[
esi
+
8
]
\
__asm
pshufb
xmm3
xmmword
ptr
kShuffleNV21
\
__asm
movq
xmm4
qword
ptr
[
eax
]
\
__asm
punpcklbw
xmm4
xmm4
\
__asm
lea
eax
[
eax
+
8
]
}
#
define
READYUY2
\
__asm
{
\
__asm
movdqu
xmm4
[
eax
]
/
*
YUY2
*
/
\
__asm
pshufb
xmm4
xmmword
ptr
kShuffleYUY2Y
\
__asm
movdqu
xmm3
[
eax
]
/
*
UV
*
/
\
__asm
pshufb
xmm3
xmmword
ptr
kShuffleYUY2UV
\
__asm
lea
eax
[
eax
+
16
]
}
#
define
READUYVY
\
__asm
{
\
__asm
movdqu
xmm4
[
eax
]
/
*
UYVY
*
/
\
__asm
pshufb
xmm4
xmmword
ptr
kShuffleUYVYY
\
__asm
movdqu
xmm3
[
eax
]
/
*
UV
*
/
\
__asm
pshufb
xmm3
xmmword
ptr
kShuffleUYVYUV
\
__asm
lea
eax
[
eax
+
16
]
}
#
define
YUVTORGB
(
YuvConstants
)
\
__asm
{
\
__asm
psubb
xmm3
xmmword
ptr
kBiasUV128
\
__asm
pmulhuw
xmm4
xmmword
ptr
[
YuvConstants
+
KYTORGB
]
\
__asm
movdqa
xmm0
xmmword
ptr
[
YuvConstants
+
KUVTOB
]
\
__asm
movdqa
xmm1
xmmword
ptr
[
YuvConstants
+
KUVTOG
]
\
__asm
movdqa
xmm2
xmmword
ptr
[
YuvConstants
+
KUVTOR
]
\
__asm
pmaddubsw
xmm0
xmm3
\
__asm
pmaddubsw
xmm1
xmm3
\
__asm
pmaddubsw
xmm2
xmm3
\
__asm
movdqa
xmm3
xmmword
ptr
[
YuvConstants
+
KYBIASTORGB
]
\
__asm
paddw
xmm4
xmm3
\
__asm
paddsw
xmm0
xmm4
\
__asm
paddsw
xmm2
xmm4
\
__asm
psubsw
xmm4
xmm1
\
__asm
movdqa
xmm1
xmm4
\
__asm
psraw
xmm0
6
\
__asm
psraw
xmm1
6
\
__asm
psraw
xmm2
6
\
__asm
packuswb
xmm0
xmm0
/
*
B
*
/
\
__asm
packuswb
xmm1
xmm1
/
*
G
*
/
\
__asm
packuswb
xmm2
xmm2
/
*
R
*
/
\
}
#
define
STOREARGB
\
__asm
{
\
__asm
punpcklbw
xmm0
xmm1
/
*
BG
*
/
\
__asm
punpcklbw
xmm2
xmm5
/
*
RA
*
/
\
__asm
movdqa
xmm1
xmm0
\
__asm
punpcklwd
xmm0
xmm2
/
*
BGRA
first
4
pixels
*
/
\
__asm
punpckhwd
xmm1
xmm2
/
*
BGRA
next
4
pixels
*
/
\
__asm
movdqu
0
[
edx
]
xmm0
\
__asm
movdqu
16
[
edx
]
xmm1
\
__asm
lea
edx
[
edx
+
32
]
}
#
define
STOREBGRA
\
__asm
{
\
__asm
pcmpeqb
xmm5
xmm5
/
*
generate
0xffffffff
for
alpha
*
/
\
__asm
punpcklbw
xmm1
xmm0
/
*
GB
*
/
\
__asm
punpcklbw
xmm5
xmm2
/
*
AR
*
/
\
__asm
movdqa
xmm0
xmm5
\
__asm
punpcklwd
xmm5
xmm1
/
*
BGRA
first
4
pixels
*
/
\
__asm
punpckhwd
xmm0
xmm1
/
*
BGRA
next
4
pixels
*
/
\
__asm
movdqu
0
[
edx
]
xmm5
\
__asm
movdqu
16
[
edx
]
xmm0
\
__asm
lea
edx
[
edx
+
32
]
}
#
define
STORERGBA
\
__asm
{
\
__asm
pcmpeqb
xmm5
xmm5
/
*
generate
0xffffffff
for
alpha
*
/
\
__asm
punpcklbw
xmm1
xmm2
/
*
GR
*
/
\
__asm
punpcklbw
xmm5
xmm0
/
*
AB
*
/
\
__asm
movdqa
xmm0
xmm5
\
__asm
punpcklwd
xmm5
xmm1
/
*
RGBA
first
4
pixels
*
/
\
__asm
punpckhwd
xmm0
xmm1
/
*
RGBA
next
4
pixels
*
/
\
__asm
movdqu
0
[
edx
]
xmm5
\
__asm
movdqu
16
[
edx
]
xmm0
\
__asm
lea
edx
[
edx
+
32
]
}
#
define
STORERGB24
\
__asm
{
/
*
Weave
into
RRGB
*
/
\
__asm
punpcklbw
xmm0
xmm1
/
*
BG
*
/
\
__asm
punpcklbw
xmm2
xmm2
/
*
RR
*
/
\
__asm
movdqa
xmm1
xmm0
\
__asm
punpcklwd
xmm0
xmm2
/
*
BGRR
first
4
pixels
*
/
\
__asm
punpckhwd
xmm1
xmm2
/
*
BGRR
next
4
pixels
*
/
/
*
RRGB
-
>
RGB24
*
/
\
__asm
pshufb
xmm0
xmm5
/
*
Pack
first
8
and
last
4
bytes
.
*
/
\
__asm
pshufb
xmm1
xmm6
/
*
Pack
first
12
bytes
.
*
/
\
__asm
palignr
xmm1
xmm0
12
/
*
last
4
bytes
of
xmm0
+
12
xmm1
*
/
\
__asm
movq
qword
ptr
0
[
edx
]
xmm0
/
*
First
8
bytes
*
/
\
__asm
movdqu
8
[
edx
]
xmm1
/
*
Last
16
bytes
*
/
\
__asm
lea
edx
[
edx
+
24
]
}
#
define
STORERGB565
\
__asm
{
/
*
Weave
into
RRGB
*
/
\
__asm
punpcklbw
xmm0
xmm1
/
*
BG
*
/
\
__asm
punpcklbw
xmm2
xmm2
/
*
RR
*
/
\
__asm
movdqa
xmm1
xmm0
\
__asm
punpcklwd
xmm0
xmm2
/
*
BGRR
first
4
pixels
*
/
\
__asm
punpckhwd
xmm1
xmm2
/
*
BGRR
next
4
pixels
*
/
/
*
RRGB
-
>
RGB565
*
/
\
__asm
movdqa
xmm3
xmm0
/
*
B
first
4
pixels
of
argb
*
/
\
__asm
movdqa
xmm2
xmm0
/
*
G
*
/
\
__asm
pslld
xmm0
8
/
*
R
*
/
\
__asm
psrld
xmm3
3
/
*
B
*
/
\
__asm
psrld
xmm2
5
/
*
G
*
/
\
__asm
psrad
xmm0
16
/
*
R
*
/
\
__asm
pand
xmm3
xmm5
/
*
B
*
/
\
__asm
pand
xmm2
xmm6
/
*
G
*
/
\
__asm
pand
xmm0
xmm7
/
*
R
*
/
\
__asm
por
xmm3
xmm2
/
*
BG
*
/
\
__asm
por
xmm0
xmm3
/
*
BGR
*
/
\
__asm
movdqa
xmm3
xmm1
/
*
B
next
4
pixels
of
argb
*
/
\
__asm
movdqa
xmm2
xmm1
/
*
G
*
/
\
__asm
pslld
xmm1
8
/
*
R
*
/
\
__asm
psrld
xmm3
3
/
*
B
*
/
\
__asm
psrld
xmm2
5
/
*
G
*
/
\
__asm
psrad
xmm1
16
/
*
R
*
/
\
__asm
pand
xmm3
xmm5
/
*
B
*
/
\
__asm
pand
xmm2
xmm6
/
*
G
*
/
\
__asm
pand
xmm1
xmm7
/
*
R
*
/
\
__asm
por
xmm3
xmm2
/
*
BG
*
/
\
__asm
por
xmm1
xmm3
/
*
BGR
*
/
\
__asm
packssdw
xmm0
xmm1
\
__asm
movdqu
0
[
edx
]
xmm0
/
*
store
8
pixels
of
RGB565
*
/
\
__asm
lea
edx
[
edx
+
16
]
}
__declspec
(
naked
)
void
I444ToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
mov
eax
[
esp
+
12
+
4
]
mov
esi
[
esp
+
12
+
8
]
mov
edi
[
esp
+
12
+
12
]
mov
edx
[
esp
+
12
+
16
]
mov
ebx
[
esp
+
12
+
20
]
mov
ecx
[
esp
+
12
+
24
]
sub
edi
esi
pcmpeqb
xmm5
xmm5
convertloop
:
READYUV444
YUVTORGB
(
ebx
)
STOREARGB
sub
ecx
8
jg
convertloop
pop
ebx
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
I444AlphaToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
const
uint8_t
*
a_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
push
ebp
mov
eax
[
esp
+
16
+
4
]
mov
esi
[
esp
+
16
+
8
]
mov
edi
[
esp
+
16
+
12
]
mov
ebp
[
esp
+
16
+
16
]
mov
edx
[
esp
+
16
+
20
]
mov
ebx
[
esp
+
16
+
24
]
mov
ecx
[
esp
+
16
+
28
]
sub
edi
esi
convertloop
:
READYUVA444
YUVTORGB
(
ebx
)
STOREARGB
sub
ecx
8
jg
convertloop
pop
ebp
pop
ebx
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
I422ToRGB24Row_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_rgb24
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
mov
eax
[
esp
+
12
+
4
]
mov
esi
[
esp
+
12
+
8
]
mov
edi
[
esp
+
12
+
12
]
mov
edx
[
esp
+
12
+
16
]
mov
ebx
[
esp
+
12
+
20
]
mov
ecx
[
esp
+
12
+
24
]
sub
edi
esi
movdqa
xmm5
xmmword
ptr
kShuffleMaskARGBToRGB24_0
movdqa
xmm6
xmmword
ptr
kShuffleMaskARGBToRGB24
convertloop
:
READYUV422
YUVTORGB
(
ebx
)
STORERGB24
sub
ecx
8
jg
convertloop
pop
ebx
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
I444ToRGB24Row_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_rgb24
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
mov
eax
[
esp
+
12
+
4
]
mov
esi
[
esp
+
12
+
8
]
mov
edi
[
esp
+
12
+
12
]
mov
edx
[
esp
+
12
+
16
]
mov
ebx
[
esp
+
12
+
20
]
mov
ecx
[
esp
+
12
+
24
]
sub
edi
esi
movdqa
xmm5
xmmword
ptr
kShuffleMaskARGBToRGB24_0
movdqa
xmm6
xmmword
ptr
kShuffleMaskARGBToRGB24
convertloop
:
READYUV444
YUVTORGB
(
ebx
)
STORERGB24
sub
ecx
8
jg
convertloop
pop
ebx
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
I422ToRGB565Row_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
rgb565_buf
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
mov
eax
[
esp
+
12
+
4
]
mov
esi
[
esp
+
12
+
8
]
mov
edi
[
esp
+
12
+
12
]
mov
edx
[
esp
+
12
+
16
]
mov
ebx
[
esp
+
12
+
20
]
mov
ecx
[
esp
+
12
+
24
]
sub
edi
esi
pcmpeqb
xmm5
xmm5
psrld
xmm5
27
pcmpeqb
xmm6
xmm6
psrld
xmm6
26
pslld
xmm6
5
pcmpeqb
xmm7
xmm7
pslld
xmm7
11
convertloop
:
READYUV422
YUVTORGB
(
ebx
)
STORERGB565
sub
ecx
8
jg
convertloop
pop
ebx
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
I422ToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
mov
eax
[
esp
+
12
+
4
]
mov
esi
[
esp
+
12
+
8
]
mov
edi
[
esp
+
12
+
12
]
mov
edx
[
esp
+
12
+
16
]
mov
ebx
[
esp
+
12
+
20
]
mov
ecx
[
esp
+
12
+
24
]
sub
edi
esi
pcmpeqb
xmm5
xmm5
convertloop
:
READYUV422
YUVTORGB
(
ebx
)
STOREARGB
sub
ecx
8
jg
convertloop
pop
ebx
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
I422AlphaToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
const
uint8_t
*
a_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
push
ebp
mov
eax
[
esp
+
16
+
4
]
mov
esi
[
esp
+
16
+
8
]
mov
edi
[
esp
+
16
+
12
]
mov
ebp
[
esp
+
16
+
16
]
mov
edx
[
esp
+
16
+
20
]
mov
ebx
[
esp
+
16
+
24
]
mov
ecx
[
esp
+
16
+
28
]
sub
edi
esi
convertloop
:
READYUVA422
YUVTORGB
(
ebx
)
STOREARGB
sub
ecx
8
jg
convertloop
pop
ebp
pop
ebx
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
NV12ToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
uv_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
ebx
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
ebx
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
pcmpeqb
xmm5
xmm5
convertloop
:
READNV12
YUVTORGB
(
ebx
)
STOREARGB
sub
ecx
8
jg
convertloop
pop
ebx
pop
esi
ret
}
}
__declspec
(
naked
)
void
NV21ToARGBRow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
vu_buf
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
ebx
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
ebx
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
pcmpeqb
xmm5
xmm5
convertloop
:
READNV21
YUVTORGB
(
ebx
)
STOREARGB
sub
ecx
8
jg
convertloop
pop
ebx
pop
esi
ret
}
}
__declspec
(
naked
)
void
YUY2ToARGBRow_SSSE3
(
const
uint8_t
*
src_yuy2
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
ebx
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
ebx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
pcmpeqb
xmm5
xmm5
convertloop
:
READYUY2
YUVTORGB
(
ebx
)
STOREARGB
sub
ecx
8
jg
convertloop
pop
ebx
ret
}
}
__declspec
(
naked
)
void
UYVYToARGBRow_SSSE3
(
const
uint8_t
*
src_uyvy
uint8_t
*
dst_argb
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
ebx
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
ebx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
pcmpeqb
xmm5
xmm5
convertloop
:
READUYVY
YUVTORGB
(
ebx
)
STOREARGB
sub
ecx
8
jg
convertloop
pop
ebx
ret
}
}
__declspec
(
naked
)
void
I422ToRGBARow_SSSE3
(
const
uint8_t
*
y_buf
const
uint8_t
*
u_buf
const
uint8_t
*
v_buf
uint8_t
*
dst_rgba
const
struct
YuvConstants
*
yuvconstants
int
width
)
{
__asm
{
push
esi
push
edi
push
ebx
mov
eax
[
esp
+
12
+
4
]
mov
esi
[
esp
+
12
+
8
]
mov
edi
[
esp
+
12
+
12
]
mov
edx
[
esp
+
12
+
16
]
mov
ebx
[
esp
+
12
+
20
]
mov
ecx
[
esp
+
12
+
24
]
sub
edi
esi
convertloop
:
READYUV422
YUVTORGB
(
ebx
)
STORERGBA
sub
ecx
8
jg
convertloop
pop
ebx
pop
edi
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_I400TOARGBROW_SSE2
__declspec
(
naked
)
void
I400ToARGBRow_SSE2
(
const
uint8_t
*
y_buf
uint8_t
*
rgb_buf
const
struct
YuvConstants
*
int
width
)
{
__asm
{
mov
eax
0x4a354a35
movd
xmm2
eax
pshufd
xmm2
xmm2
0
mov
eax
0x04880488
movd
xmm3
eax
pshufd
xmm3
xmm3
0
pcmpeqb
xmm4
xmm4
pslld
xmm4
24
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
convertloop
:
movq
xmm0
qword
ptr
[
eax
]
lea
eax
[
eax
+
8
]
punpcklbw
xmm0
xmm0
pmulhuw
xmm0
xmm2
psubusw
xmm0
xmm3
psrlw
xmm0
6
packuswb
xmm0
xmm0
punpcklbw
xmm0
xmm0
movdqa
xmm1
xmm0
punpcklwd
xmm0
xmm0
punpckhwd
xmm1
xmm1
por
xmm0
xmm4
por
xmm1
xmm4
movdqu
[
edx
]
xmm0
movdqu
[
edx
+
16
]
xmm1
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_I400TOARGBROW_AVX2
__declspec
(
naked
)
void
I400ToARGBRow_AVX2
(
const
uint8_t
*
y_buf
uint8_t
*
rgb_buf
const
struct
YuvConstants
*
int
width
)
{
__asm
{
mov
eax
0x4a354a35
vmovd
xmm2
eax
vbroadcastss
ymm2
xmm2
mov
eax
0x04880488
vmovd
xmm3
eax
vbroadcastss
ymm3
xmm3
vpcmpeqb
ymm4
ymm4
ymm4
vpslld
ymm4
ymm4
24
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
convertloop
:
vmovdqu
xmm0
[
eax
]
lea
eax
[
eax
+
16
]
vpermq
ymm0
ymm0
0xd8
vpunpcklbw
ymm0
ymm0
ymm0
vpmulhuw
ymm0
ymm0
ymm2
vpsubusw
ymm0
ymm0
ymm3
vpsrlw
ymm0
ymm0
6
vpackuswb
ymm0
ymm0
ymm0
vpunpcklbw
ymm1
ymm0
ymm0
vpermq
ymm1
ymm1
0xd8
vpunpcklwd
ymm0
ymm1
ymm1
vpunpckhwd
ymm1
ymm1
ymm1
vpor
ymm0
ymm0
ymm4
vpor
ymm1
ymm1
ymm4
vmovdqu
[
edx
]
ymm0
vmovdqu
[
edx
+
32
]
ymm1
lea
edx
[
edx
+
64
]
sub
ecx
16
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_MIRRORROW_SSSE3
static
const
uvec8
kShuffleMirror
=
{
15u
14u
13u
12u
11u
10u
9u
8u
7u
6u
5u
4u
3u
2u
1u
0u
}
;
__declspec
(
naked
)
void
MirrorRow_SSSE3
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm5
xmmword
ptr
kShuffleMirror
convertloop
:
movdqu
xmm0
[
eax
-
16
+
ecx
]
pshufb
xmm0
xmm5
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_MIRRORROW_AVX2
__declspec
(
naked
)
void
MirrorRow_AVX2
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vbroadcastf128
ymm5
xmmword
ptr
kShuffleMirror
convertloop
:
vmovdqu
ymm0
[
eax
-
32
+
ecx
]
vpshufb
ymm0
ymm0
ymm5
vpermq
ymm0
ymm0
0x4e
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
32
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_MIRRORSPLITUVROW_SSSE3
static
const
uvec8
kShuffleMirrorUV
=
{
14u
12u
10u
8u
6u
4u
2u
0u
15u
13u
11u
9u
7u
5u
3u
1u
}
;
__declspec
(
naked
)
void
MirrorSplitUVRow_SSSE3
(
const
uint8_t
*
src
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
movdqa
xmm1
xmmword
ptr
kShuffleMirrorUV
lea
eax
[
eax
+
ecx
*
2
-
16
]
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
lea
eax
[
eax
-
16
]
pshufb
xmm0
xmm1
movlpd
qword
ptr
[
edx
]
xmm0
movhpd
qword
ptr
[
edx
+
edi
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
8
jg
convertloop
pop
edi
ret
}
}
#
endif
#
ifdef
HAS_ARGBMIRRORROW_SSE2
__declspec
(
naked
)
void
ARGBMirrorRow_SSE2
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
lea
eax
[
eax
-
16
+
ecx
*
4
]
convertloop
:
movdqu
xmm0
[
eax
]
lea
eax
[
eax
-
16
]
pshufd
xmm0
xmm0
0x1b
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
4
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBMIRRORROW_AVX2
static
const
ulvec32
kARGBShuffleMirror_AVX2
=
{
7u
6u
5u
4u
3u
2u
1u
0u
}
;
__declspec
(
naked
)
void
ARGBMirrorRow_AVX2
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vmovdqu
ymm5
ymmword
ptr
kARGBShuffleMirror_AVX2
convertloop
:
vpermd
ymm0
ymm5
[
eax
-
32
+
ecx
*
4
]
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_SPLITUVROW_SSE2
__declspec
(
naked
)
void
SplitUVRow_SSE2
(
const
uint8_t
*
src_uv
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
pcmpeqb
xmm5
xmm5
psrlw
xmm5
8
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
lea
eax
[
eax
+
32
]
movdqa
xmm2
xmm0
movdqa
xmm3
xmm1
pand
xmm0
xmm5
pand
xmm1
xmm5
packuswb
xmm0
xmm1
psrlw
xmm2
8
psrlw
xmm3
8
packuswb
xmm2
xmm3
movdqu
[
edx
]
xmm0
movdqu
[
edx
+
edi
]
xmm2
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
pop
edi
ret
}
}
#
endif
#
ifdef
HAS_SPLITUVROW_AVX2
__declspec
(
naked
)
void
SplitUVRow_AVX2
(
const
uint8_t
*
src_uv
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
vpcmpeqb
ymm5
ymm5
ymm5
vpsrlw
ymm5
ymm5
8
sub
edi
edx
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
lea
eax
[
eax
+
64
]
vpsrlw
ymm2
ymm0
8
vpsrlw
ymm3
ymm1
8
vpand
ymm0
ymm0
ymm5
vpand
ymm1
ymm1
ymm5
vpackuswb
ymm0
ymm0
ymm1
vpackuswb
ymm2
ymm2
ymm3
vpermq
ymm0
ymm0
0xd8
vpermq
ymm2
ymm2
0xd8
vmovdqu
[
edx
]
ymm0
vmovdqu
[
edx
+
edi
]
ymm2
lea
edx
[
edx
+
32
]
sub
ecx
32
jg
convertloop
pop
edi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_MERGEUVROW_SSE2
__declspec
(
naked
)
void
MergeUVRow_SSE2
(
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_uv
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
sub
edx
eax
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
edx
]
lea
eax
[
eax
+
16
]
movdqa
xmm2
xmm0
punpcklbw
xmm0
xmm1
punpckhbw
xmm2
xmm1
movdqu
[
edi
]
xmm0
movdqu
[
edi
+
16
]
xmm2
lea
edi
[
edi
+
32
]
sub
ecx
16
jg
convertloop
pop
edi
ret
}
}
#
endif
#
ifdef
HAS_MERGEUVROW_AVX2
__declspec
(
naked
)
void
MergeUVRow_AVX2
(
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_uv
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
sub
edx
eax
convertloop
:
vpmovzxbw
ymm0
[
eax
]
vpmovzxbw
ymm1
[
eax
+
edx
]
lea
eax
[
eax
+
16
]
vpsllw
ymm1
ymm1
8
vpor
ymm2
ymm1
ymm0
vmovdqu
[
edi
]
ymm2
lea
edi
[
edi
+
32
]
sub
ecx
16
jg
convertloop
pop
edi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_COPYROW_SSE2
__declspec
(
naked
)
void
CopyRow_SSE2
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
test
eax
15
jne
convertloopu
test
edx
15
jne
convertloopu
convertloopa
:
movdqa
xmm0
[
eax
]
movdqa
xmm1
[
eax
+
16
]
lea
eax
[
eax
+
32
]
movdqa
[
edx
]
xmm0
movdqa
[
edx
+
16
]
xmm1
lea
edx
[
edx
+
32
]
sub
ecx
32
jg
convertloopa
ret
convertloopu
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
lea
eax
[
eax
+
32
]
movdqu
[
edx
]
xmm0
movdqu
[
edx
+
16
]
xmm1
lea
edx
[
edx
+
32
]
sub
ecx
32
jg
convertloopu
ret
}
}
#
endif
#
ifdef
HAS_COPYROW_AVX
__declspec
(
naked
)
void
CopyRow_AVX
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
lea
eax
[
eax
+
64
]
vmovdqu
[
edx
]
ymm0
vmovdqu
[
edx
+
32
]
ymm1
lea
edx
[
edx
+
64
]
sub
ecx
64
jg
convertloop
vzeroupper
ret
}
}
#
endif
__declspec
(
naked
)
void
CopyRow_ERMS
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
esi
mov
edx
edi
mov
esi
[
esp
+
4
]
mov
edi
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
rep
movsb
mov
edi
edx
mov
esi
eax
ret
}
}
#
ifdef
HAS_ARGBCOPYALPHAROW_SSE2
__declspec
(
naked
)
void
ARGBCopyAlphaRow_SSE2
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm0
xmm0
pslld
xmm0
24
pcmpeqb
xmm1
xmm1
psrld
xmm1
8
convertloop
:
movdqu
xmm2
[
eax
]
movdqu
xmm3
[
eax
+
16
]
lea
eax
[
eax
+
32
]
movdqu
xmm4
[
edx
]
movdqu
xmm5
[
edx
+
16
]
pand
xmm2
xmm0
pand
xmm3
xmm0
pand
xmm4
xmm1
pand
xmm5
xmm1
por
xmm2
xmm4
por
xmm3
xmm5
movdqu
[
edx
]
xmm2
movdqu
[
edx
+
16
]
xmm3
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBCOPYALPHAROW_AVX2
__declspec
(
naked
)
void
ARGBCopyAlphaRow_AVX2
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vpcmpeqb
ymm0
ymm0
ymm0
vpsrld
ymm0
ymm0
8
convertloop
:
vmovdqu
ymm1
[
eax
]
vmovdqu
ymm2
[
eax
+
32
]
lea
eax
[
eax
+
64
]
vpblendvb
ymm1
ymm1
[
edx
]
ymm0
vpblendvb
ymm2
ymm2
[
edx
+
32
]
ymm0
vmovdqu
[
edx
]
ymm1
vmovdqu
[
edx
+
32
]
ymm2
lea
edx
[
edx
+
64
]
sub
ecx
16
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBEXTRACTALPHAROW_SSE2
__declspec
(
naked
)
void
ARGBExtractAlphaRow_SSE2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_a
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
extractloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
lea
eax
[
eax
+
32
]
psrld
xmm0
24
psrld
xmm1
24
packssdw
xmm0
xmm1
packuswb
xmm0
xmm0
movq
qword
ptr
[
edx
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
8
jg
extractloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBEXTRACTALPHAROW_AVX2
__declspec
(
naked
)
void
ARGBExtractAlphaRow_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_a
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vmovdqa
ymm4
ymmword
ptr
kPermdARGBToY_AVX
extractloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
vpsrld
ymm0
ymm0
24
vpsrld
ymm1
ymm1
24
vmovdqu
ymm2
[
eax
+
64
]
vmovdqu
ymm3
[
eax
+
96
]
lea
eax
[
eax
+
128
]
vpackssdw
ymm0
ymm0
ymm1
vpsrld
ymm2
ymm2
24
vpsrld
ymm3
ymm3
24
vpackssdw
ymm2
ymm2
ymm3
vpackuswb
ymm0
ymm0
ymm2
vpermd
ymm0
ymm4
ymm0
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
32
jg
extractloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBCOPYYTOALPHAROW_SSE2
__declspec
(
naked
)
void
ARGBCopyYToAlphaRow_SSE2
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm0
xmm0
pslld
xmm0
24
pcmpeqb
xmm1
xmm1
psrld
xmm1
8
convertloop
:
movq
xmm2
qword
ptr
[
eax
]
lea
eax
[
eax
+
8
]
punpcklbw
xmm2
xmm2
punpckhwd
xmm3
xmm2
punpcklwd
xmm2
xmm2
movdqu
xmm4
[
edx
]
movdqu
xmm5
[
edx
+
16
]
pand
xmm2
xmm0
pand
xmm3
xmm0
pand
xmm4
xmm1
pand
xmm5
xmm1
por
xmm2
xmm4
por
xmm3
xmm5
movdqu
[
edx
]
xmm2
movdqu
[
edx
+
16
]
xmm3
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBCOPYYTOALPHAROW_AVX2
__declspec
(
naked
)
void
ARGBCopyYToAlphaRow_AVX2
(
const
uint8_t
*
src
uint8_t
*
dst
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vpcmpeqb
ymm0
ymm0
ymm0
vpsrld
ymm0
ymm0
8
convertloop
:
vpmovzxbd
ymm1
qword
ptr
[
eax
]
vpmovzxbd
ymm2
qword
ptr
[
eax
+
8
]
lea
eax
[
eax
+
16
]
vpslld
ymm1
ymm1
24
vpslld
ymm2
ymm2
24
vpblendvb
ymm1
ymm1
[
edx
]
ymm0
vpblendvb
ymm2
ymm2
[
edx
+
32
]
ymm0
vmovdqu
[
edx
]
ymm1
vmovdqu
[
edx
+
32
]
ymm2
lea
edx
[
edx
+
64
]
sub
ecx
16
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_SETROW_X86
__declspec
(
naked
)
void
SetRow_X86
(
uint8_t
*
dst
uint8_t
v8
int
width
)
{
__asm
{
movzx
eax
byte
ptr
[
esp
+
8
]
mov
edx
0x01010101
mul
edx
mov
edx
edi
mov
edi
[
esp
+
4
]
mov
ecx
[
esp
+
12
]
shr
ecx
2
rep
stosd
mov
edi
edx
ret
}
}
__declspec
(
naked
)
void
SetRow_ERMS
(
uint8_t
*
dst
uint8_t
v8
int
width
)
{
__asm
{
mov
edx
edi
mov
edi
[
esp
+
4
]
mov
eax
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
rep
stosb
mov
edi
edx
ret
}
}
__declspec
(
naked
)
void
ARGBSetRow_X86
(
uint8_t
*
dst_argb
uint32_t
v32
int
width
)
{
__asm
{
mov
edx
edi
mov
edi
[
esp
+
4
]
mov
eax
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
rep
stosd
mov
edi
edx
ret
}
}
#
endif
#
ifdef
HAS_YUY2TOYROW_AVX2
__declspec
(
naked
)
void
YUY2ToYRow_AVX2
(
const
uint8_t
*
src_yuy2
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vpcmpeqb
ymm5
ymm5
ymm5
vpsrlw
ymm5
ymm5
8
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
lea
eax
[
eax
+
64
]
vpand
ymm0
ymm0
ymm5
vpand
ymm1
ymm1
ymm5
vpackuswb
ymm0
ymm0
ymm1
vpermq
ymm0
ymm0
0xd8
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
32
jg
convertloop
vzeroupper
ret
}
}
__declspec
(
naked
)
void
YUY2ToUVRow_AVX2
(
const
uint8_t
*
src_yuy2
int
stride_yuy2
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
vpcmpeqb
ymm5
ymm5
ymm5
vpsrlw
ymm5
ymm5
8
sub
edi
edx
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
vpavgb
ymm0
ymm0
[
eax
+
esi
]
vpavgb
ymm1
ymm1
[
eax
+
esi
+
32
]
lea
eax
[
eax
+
64
]
vpsrlw
ymm0
ymm0
8
vpsrlw
ymm1
ymm1
8
vpackuswb
ymm0
ymm0
ymm1
vpermq
ymm0
ymm0
0xd8
vpand
ymm1
ymm0
ymm5
vpsrlw
ymm0
ymm0
8
vpackuswb
ymm1
ymm1
ymm1
vpackuswb
ymm0
ymm0
ymm0
vpermq
ymm1
ymm1
0xd8
vpermq
ymm0
ymm0
0xd8
vextractf128
[
edx
]
ymm1
0
vextractf128
[
edx
+
edi
]
ymm0
0
lea
edx
[
edx
+
16
]
sub
ecx
32
jg
convertloop
pop
edi
pop
esi
vzeroupper
ret
}
}
__declspec
(
naked
)
void
YUY2ToUV422Row_AVX2
(
const
uint8_t
*
src_yuy2
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
vpcmpeqb
ymm5
ymm5
ymm5
vpsrlw
ymm5
ymm5
8
sub
edi
edx
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
lea
eax
[
eax
+
64
]
vpsrlw
ymm0
ymm0
8
vpsrlw
ymm1
ymm1
8
vpackuswb
ymm0
ymm0
ymm1
vpermq
ymm0
ymm0
0xd8
vpand
ymm1
ymm0
ymm5
vpsrlw
ymm0
ymm0
8
vpackuswb
ymm1
ymm1
ymm1
vpackuswb
ymm0
ymm0
ymm0
vpermq
ymm1
ymm1
0xd8
vpermq
ymm0
ymm0
0xd8
vextractf128
[
edx
]
ymm1
0
vextractf128
[
edx
+
edi
]
ymm0
0
lea
edx
[
edx
+
16
]
sub
ecx
32
jg
convertloop
pop
edi
vzeroupper
ret
}
}
__declspec
(
naked
)
void
UYVYToYRow_AVX2
(
const
uint8_t
*
src_uyvy
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
lea
eax
[
eax
+
64
]
vpsrlw
ymm0
ymm0
8
vpsrlw
ymm1
ymm1
8
vpackuswb
ymm0
ymm0
ymm1
vpermq
ymm0
ymm0
0xd8
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
32
jg
convertloop
vzeroupper
ret
}
}
__declspec
(
naked
)
void
UYVYToUVRow_AVX2
(
const
uint8_t
*
src_uyvy
int
stride_uyvy
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
vpcmpeqb
ymm5
ymm5
ymm5
vpsrlw
ymm5
ymm5
8
sub
edi
edx
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
vpavgb
ymm0
ymm0
[
eax
+
esi
]
vpavgb
ymm1
ymm1
[
eax
+
esi
+
32
]
lea
eax
[
eax
+
64
]
vpand
ymm0
ymm0
ymm5
vpand
ymm1
ymm1
ymm5
vpackuswb
ymm0
ymm0
ymm1
vpermq
ymm0
ymm0
0xd8
vpand
ymm1
ymm0
ymm5
vpsrlw
ymm0
ymm0
8
vpackuswb
ymm1
ymm1
ymm1
vpackuswb
ymm0
ymm0
ymm0
vpermq
ymm1
ymm1
0xd8
vpermq
ymm0
ymm0
0xd8
vextractf128
[
edx
]
ymm1
0
vextractf128
[
edx
+
edi
]
ymm0
0
lea
edx
[
edx
+
16
]
sub
ecx
32
jg
convertloop
pop
edi
pop
esi
vzeroupper
ret
}
}
__declspec
(
naked
)
void
UYVYToUV422Row_AVX2
(
const
uint8_t
*
src_uyvy
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
vpcmpeqb
ymm5
ymm5
ymm5
vpsrlw
ymm5
ymm5
8
sub
edi
edx
convertloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
lea
eax
[
eax
+
64
]
vpand
ymm0
ymm0
ymm5
vpand
ymm1
ymm1
ymm5
vpackuswb
ymm0
ymm0
ymm1
vpermq
ymm0
ymm0
0xd8
vpand
ymm1
ymm0
ymm5
vpsrlw
ymm0
ymm0
8
vpackuswb
ymm1
ymm1
ymm1
vpackuswb
ymm0
ymm0
ymm0
vpermq
ymm1
ymm1
0xd8
vpermq
ymm0
ymm0
0xd8
vextractf128
[
edx
]
ymm1
0
vextractf128
[
edx
+
edi
]
ymm0
0
lea
edx
[
edx
+
16
]
sub
ecx
32
jg
convertloop
pop
edi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_YUY2TOYROW_SSE2
__declspec
(
naked
)
void
YUY2ToYRow_SSE2
(
const
uint8_t
*
src_yuy2
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm5
xmm5
psrlw
xmm5
8
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
lea
eax
[
eax
+
32
]
pand
xmm0
xmm5
pand
xmm1
xmm5
packuswb
xmm0
xmm1
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
YUY2ToUVRow_SSE2
(
const
uint8_t
*
src_yuy2
int
stride_yuy2
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
pcmpeqb
xmm5
xmm5
psrlw
xmm5
8
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
esi
]
movdqu
xmm3
[
eax
+
esi
+
16
]
lea
eax
[
eax
+
32
]
pavgb
xmm0
xmm2
pavgb
xmm1
xmm3
psrlw
xmm0
8
psrlw
xmm1
8
packuswb
xmm0
xmm1
movdqa
xmm1
xmm0
pand
xmm0
xmm5
packuswb
xmm0
xmm0
psrlw
xmm1
8
packuswb
xmm1
xmm1
movq
qword
ptr
[
edx
]
xmm0
movq
qword
ptr
[
edx
+
edi
]
xmm1
lea
edx
[
edx
+
8
]
sub
ecx
16
jg
convertloop
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
YUY2ToUV422Row_SSE2
(
const
uint8_t
*
src_yuy2
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
pcmpeqb
xmm5
xmm5
psrlw
xmm5
8
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
lea
eax
[
eax
+
32
]
psrlw
xmm0
8
psrlw
xmm1
8
packuswb
xmm0
xmm1
movdqa
xmm1
xmm0
pand
xmm0
xmm5
packuswb
xmm0
xmm0
psrlw
xmm1
8
packuswb
xmm1
xmm1
movq
qword
ptr
[
edx
]
xmm0
movq
qword
ptr
[
edx
+
edi
]
xmm1
lea
edx
[
edx
+
8
]
sub
ecx
16
jg
convertloop
pop
edi
ret
}
}
__declspec
(
naked
)
void
UYVYToYRow_SSE2
(
const
uint8_t
*
src_uyvy
uint8_t
*
dst_y
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
lea
eax
[
eax
+
32
]
psrlw
xmm0
8
psrlw
xmm1
8
packuswb
xmm0
xmm1
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
ret
}
}
__declspec
(
naked
)
void
UYVYToUVRow_SSE2
(
const
uint8_t
*
src_uyvy
int
stride_uyvy
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
pcmpeqb
xmm5
xmm5
psrlw
xmm5
8
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
esi
]
movdqu
xmm3
[
eax
+
esi
+
16
]
lea
eax
[
eax
+
32
]
pavgb
xmm0
xmm2
pavgb
xmm1
xmm3
pand
xmm0
xmm5
pand
xmm1
xmm5
packuswb
xmm0
xmm1
movdqa
xmm1
xmm0
pand
xmm0
xmm5
packuswb
xmm0
xmm0
psrlw
xmm1
8
packuswb
xmm1
xmm1
movq
qword
ptr
[
edx
]
xmm0
movq
qword
ptr
[
edx
+
edi
]
xmm1
lea
edx
[
edx
+
8
]
sub
ecx
16
jg
convertloop
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
UYVYToUV422Row_SSE2
(
const
uint8_t
*
src_uyvy
uint8_t
*
dst_u
uint8_t
*
dst_v
int
width
)
{
__asm
{
push
edi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
edi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
pcmpeqb
xmm5
xmm5
psrlw
xmm5
8
sub
edi
edx
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
lea
eax
[
eax
+
32
]
pand
xmm0
xmm5
pand
xmm1
xmm5
packuswb
xmm0
xmm1
movdqa
xmm1
xmm0
pand
xmm0
xmm5
packuswb
xmm0
xmm0
psrlw
xmm1
8
packuswb
xmm1
xmm1
movq
qword
ptr
[
edx
]
xmm0
movq
qword
ptr
[
edx
+
edi
]
xmm1
lea
edx
[
edx
+
8
]
sub
ecx
16
jg
convertloop
pop
edi
ret
}
}
#
endif
#
ifdef
HAS_BLENDPLANEROW_SSSE3
__declspec
(
naked
)
void
BlendPlaneRow_SSSE3
(
const
uint8_t
*
src0
const
uint8_t
*
src1
const
uint8_t
*
alpha
uint8_t
*
dst
int
width
)
{
__asm
{
push
esi
push
edi
pcmpeqb
xmm5
xmm5
psllw
xmm5
8
mov
eax
0x80808080
movd
xmm6
eax
pshufd
xmm6
xmm6
0x00
mov
eax
0x807f807f
movd
xmm7
eax
pshufd
xmm7
xmm7
0x00
mov
eax
[
esp
+
8
+
4
]
mov
edx
[
esp
+
8
+
8
]
mov
esi
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
sub
eax
esi
sub
edx
esi
sub
edi
esi
convertloop8
:
movq
xmm0
qword
ptr
[
esi
]
punpcklbw
xmm0
xmm0
pxor
xmm0
xmm5
movq
xmm1
qword
ptr
[
eax
+
esi
]
movq
xmm2
qword
ptr
[
edx
+
esi
]
punpcklbw
xmm1
xmm2
psubb
xmm1
xmm6
pmaddubsw
xmm0
xmm1
paddw
xmm0
xmm7
psrlw
xmm0
8
packuswb
xmm0
xmm0
movq
qword
ptr
[
edi
+
esi
]
xmm0
lea
esi
[
esi
+
8
]
sub
ecx
8
jg
convertloop8
pop
edi
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_BLENDPLANEROW_AVX2
__declspec
(
naked
)
void
BlendPlaneRow_AVX2
(
const
uint8_t
*
src0
const
uint8_t
*
src1
const
uint8_t
*
alpha
uint8_t
*
dst
int
width
)
{
__asm
{
push
esi
push
edi
vpcmpeqb
ymm5
ymm5
ymm5
vpsllw
ymm5
ymm5
8
mov
eax
0x80808080
vmovd
xmm6
eax
vbroadcastss
ymm6
xmm6
mov
eax
0x807f807f
vmovd
xmm7
eax
vbroadcastss
ymm7
xmm7
mov
eax
[
esp
+
8
+
4
]
mov
edx
[
esp
+
8
+
8
]
mov
esi
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
sub
eax
esi
sub
edx
esi
sub
edi
esi
convertloop32
:
vmovdqu
ymm0
[
esi
]
vpunpckhbw
ymm3
ymm0
ymm0
vpunpcklbw
ymm0
ymm0
ymm0
vpxor
ymm3
ymm3
ymm5
vpxor
ymm0
ymm0
ymm5
vmovdqu
ymm1
[
eax
+
esi
]
vmovdqu
ymm2
[
edx
+
esi
]
vpunpckhbw
ymm4
ymm1
ymm2
vpunpcklbw
ymm1
ymm1
ymm2
vpsubb
ymm4
ymm4
ymm6
vpsubb
ymm1
ymm1
ymm6
vpmaddubsw
ymm3
ymm3
ymm4
vpmaddubsw
ymm0
ymm0
ymm1
vpaddw
ymm3
ymm3
ymm7
vpaddw
ymm0
ymm0
ymm7
vpsrlw
ymm3
ymm3
8
vpsrlw
ymm0
ymm0
8
vpackuswb
ymm0
ymm0
ymm3
vmovdqu
[
edi
+
esi
]
ymm0
lea
esi
[
esi
+
32
]
sub
ecx
32
jg
convertloop32
pop
edi
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBBLENDROW_SSSE3
static
const
uvec8
kShuffleAlpha
=
{
3u
0x80
3u
0x80
7u
0x80
7u
0x80
11u
0x80
11u
0x80
15u
0x80
15u
0x80
}
;
__declspec
(
naked
)
void
ARGBBlendRow_SSSE3
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
pcmpeqb
xmm7
xmm7
psrlw
xmm7
15
pcmpeqb
xmm6
xmm6
psrlw
xmm6
8
pcmpeqb
xmm5
xmm5
psllw
xmm5
8
pcmpeqb
xmm4
xmm4
pslld
xmm4
24
sub
ecx
4
jl
convertloop4b
convertloop4
:
movdqu
xmm3
[
eax
]
lea
eax
[
eax
+
16
]
movdqa
xmm0
xmm3
pxor
xmm3
xmm4
movdqu
xmm2
[
esi
]
pshufb
xmm3
xmmword
ptr
kShuffleAlpha
pand
xmm2
xmm6
paddw
xmm3
xmm7
pmullw
xmm2
xmm3
movdqu
xmm1
[
esi
]
lea
esi
[
esi
+
16
]
psrlw
xmm1
8
por
xmm0
xmm4
pmullw
xmm1
xmm3
psrlw
xmm2
8
paddusb
xmm0
xmm2
pand
xmm1
xmm5
paddusb
xmm0
xmm1
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
4
jge
convertloop4
convertloop4b
:
add
ecx
4
-
1
jl
convertloop1b
convertloop1
:
movd
xmm3
[
eax
]
lea
eax
[
eax
+
4
]
movdqa
xmm0
xmm3
pxor
xmm3
xmm4
movd
xmm2
[
esi
]
pshufb
xmm3
xmmword
ptr
kShuffleAlpha
pand
xmm2
xmm6
paddw
xmm3
xmm7
pmullw
xmm2
xmm3
movd
xmm1
[
esi
]
lea
esi
[
esi
+
4
]
psrlw
xmm1
8
por
xmm0
xmm4
pmullw
xmm1
xmm3
psrlw
xmm2
8
paddusb
xmm0
xmm2
pand
xmm1
xmm5
paddusb
xmm0
xmm1
movd
[
edx
]
xmm0
lea
edx
[
edx
+
4
]
sub
ecx
1
jge
convertloop1
convertloop1b
:
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_ARGBATTENUATEROW_SSSE3
static
const
uvec8
kShuffleAlpha0
=
{
3u
3u
3u
3u
3u
3u
128u
128u
7u
7u
7u
7u
7u
7u
128u
128u
}
;
static
const
uvec8
kShuffleAlpha1
=
{
11u
11u
11u
11u
11u
11u
128u
128u
15u
15u
15u
15u
15u
15u
128u
128u
}
;
__declspec
(
naked
)
void
ARGBAttenuateRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
pcmpeqb
xmm3
xmm3
pslld
xmm3
24
movdqa
xmm4
xmmword
ptr
kShuffleAlpha0
movdqa
xmm5
xmmword
ptr
kShuffleAlpha1
convertloop
:
movdqu
xmm0
[
eax
]
pshufb
xmm0
xmm4
movdqu
xmm1
[
eax
]
punpcklbw
xmm1
xmm1
pmulhuw
xmm0
xmm1
movdqu
xmm1
[
eax
]
pshufb
xmm1
xmm5
movdqu
xmm2
[
eax
]
punpckhbw
xmm2
xmm2
pmulhuw
xmm1
xmm2
movdqu
xmm2
[
eax
]
lea
eax
[
eax
+
16
]
pand
xmm2
xmm3
psrlw
xmm0
8
psrlw
xmm1
8
packuswb
xmm0
xmm1
por
xmm0
xmm2
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
4
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBATTENUATEROW_AVX2
static
const
uvec8
kShuffleAlpha_AVX2
=
{
6u
7u
6u
7u
6u
7u
128u
128u
14u
15u
14u
15u
14u
15u
128u
128u
}
;
__declspec
(
naked
)
void
ARGBAttenuateRow_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
sub
edx
eax
vbroadcastf128
ymm4
xmmword
ptr
kShuffleAlpha_AVX2
vpcmpeqb
ymm5
ymm5
ymm5
vpslld
ymm5
ymm5
24
convertloop
:
vmovdqu
ymm6
[
eax
]
vpunpcklbw
ymm0
ymm6
ymm6
vpunpckhbw
ymm1
ymm6
ymm6
vpshufb
ymm2
ymm0
ymm4
vpshufb
ymm3
ymm1
ymm4
vpmulhuw
ymm0
ymm0
ymm2
vpmulhuw
ymm1
ymm1
ymm3
vpand
ymm6
ymm6
ymm5
vpsrlw
ymm0
ymm0
8
vpsrlw
ymm1
ymm1
8
vpackuswb
ymm0
ymm0
ymm1
vpor
ymm0
ymm0
ymm6
vmovdqu
[
eax
+
edx
]
ymm0
lea
eax
[
eax
+
32
]
sub
ecx
8
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBUNATTENUATEROW_SSE2
__declspec
(
naked
)
void
ARGBUnattenuateRow_SSE2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
ebx
push
esi
push
edi
mov
eax
[
esp
+
12
+
4
]
mov
edx
[
esp
+
12
+
8
]
mov
ecx
[
esp
+
12
+
12
]
lea
ebx
fixed_invtbl8
convertloop
:
movdqu
xmm0
[
eax
]
movzx
esi
byte
ptr
[
eax
+
3
]
movzx
edi
byte
ptr
[
eax
+
7
]
punpcklbw
xmm0
xmm0
movd
xmm2
dword
ptr
[
ebx
+
esi
*
4
]
movd
xmm3
dword
ptr
[
ebx
+
edi
*
4
]
pshuflw
xmm2
xmm2
040h
pshuflw
xmm3
xmm3
040h
movlhps
xmm2
xmm3
pmulhuw
xmm0
xmm2
movdqu
xmm1
[
eax
]
movzx
esi
byte
ptr
[
eax
+
11
]
movzx
edi
byte
ptr
[
eax
+
15
]
punpckhbw
xmm1
xmm1
movd
xmm2
dword
ptr
[
ebx
+
esi
*
4
]
movd
xmm3
dword
ptr
[
ebx
+
edi
*
4
]
pshuflw
xmm2
xmm2
040h
pshuflw
xmm3
xmm3
040h
movlhps
xmm2
xmm3
pmulhuw
xmm1
xmm2
lea
eax
[
eax
+
16
]
packuswb
xmm0
xmm1
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
4
jg
convertloop
pop
edi
pop
esi
pop
ebx
ret
}
}
#
endif
#
ifdef
HAS_ARGBUNATTENUATEROW_AVX2
static
const
uvec8
kUnattenShuffleAlpha_AVX2
=
{
0u
1u
0u
1u
0u
1u
6u
7u
8u
9u
8u
9u
8u
9u
14u
15u
}
;
#
ifdef
USE_GATHER
__declspec
(
naked
)
void
ARGBUnattenuateRow_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
sub
edx
eax
vbroadcastf128
ymm4
xmmword
ptr
kUnattenShuffleAlpha_AVX2
convertloop
:
vmovdqu
ymm6
[
eax
]
vpcmpeqb
ymm5
ymm5
ymm5
vpsrld
ymm2
ymm6
24
vpunpcklbw
ymm0
ymm6
ymm6
vpunpckhbw
ymm1
ymm6
ymm6
vpgatherdd
ymm3
[
ymm2
*
4
+
fixed_invtbl8
]
ymm5
vpunpcklwd
ymm2
ymm3
ymm3
vpunpckhwd
ymm3
ymm3
ymm3
vpshufb
ymm2
ymm2
ymm4
vpshufb
ymm3
ymm3
ymm4
vpmulhuw
ymm0
ymm0
ymm2
vpmulhuw
ymm1
ymm1
ymm3
vpackuswb
ymm0
ymm0
ymm1
vmovdqu
[
eax
+
edx
]
ymm0
lea
eax
[
eax
+
32
]
sub
ecx
8
jg
convertloop
vzeroupper
ret
}
}
#
else
__declspec
(
naked
)
void
ARGBUnattenuateRow_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
ebx
push
esi
push
edi
mov
eax
[
esp
+
12
+
4
]
mov
edx
[
esp
+
12
+
8
]
mov
ecx
[
esp
+
12
+
12
]
sub
edx
eax
lea
ebx
fixed_invtbl8
vbroadcastf128
ymm5
xmmword
ptr
kUnattenShuffleAlpha_AVX2
convertloop
:
movzx
esi
byte
ptr
[
eax
+
3
]
movzx
edi
byte
ptr
[
eax
+
7
]
vmovd
xmm0
dword
ptr
[
ebx
+
esi
*
4
]
vmovd
xmm1
dword
ptr
[
ebx
+
edi
*
4
]
movzx
esi
byte
ptr
[
eax
+
11
]
movzx
edi
byte
ptr
[
eax
+
15
]
vpunpckldq
xmm6
xmm0
xmm1
vmovd
xmm2
dword
ptr
[
ebx
+
esi
*
4
]
vmovd
xmm3
dword
ptr
[
ebx
+
edi
*
4
]
movzx
esi
byte
ptr
[
eax
+
19
]
movzx
edi
byte
ptr
[
eax
+
23
]
vpunpckldq
xmm7
xmm2
xmm3
vmovd
xmm0
dword
ptr
[
ebx
+
esi
*
4
]
vmovd
xmm1
dword
ptr
[
ebx
+
edi
*
4
]
movzx
esi
byte
ptr
[
eax
+
27
]
movzx
edi
byte
ptr
[
eax
+
31
]
vpunpckldq
xmm0
xmm0
xmm1
vmovd
xmm2
dword
ptr
[
ebx
+
esi
*
4
]
vmovd
xmm3
dword
ptr
[
ebx
+
edi
*
4
]
vpunpckldq
xmm2
xmm2
xmm3
vpunpcklqdq
xmm3
xmm6
xmm7
vpunpcklqdq
xmm0
xmm0
xmm2
vinserti128
ymm3
ymm3
xmm0
1
vmovdqu
ymm6
[
eax
]
vpunpcklbw
ymm0
ymm6
ymm6
vpunpckhbw
ymm1
ymm6
ymm6
vpunpcklwd
ymm2
ymm3
ymm3
vpunpckhwd
ymm3
ymm3
ymm3
vpshufb
ymm2
ymm2
ymm5
vpshufb
ymm3
ymm3
ymm5
vpmulhuw
ymm0
ymm0
ymm2
vpmulhuw
ymm1
ymm1
ymm3
vpackuswb
ymm0
ymm0
ymm1
vmovdqu
[
eax
+
edx
]
ymm0
lea
eax
[
eax
+
32
]
sub
ecx
8
jg
convertloop
pop
edi
pop
esi
pop
ebx
vzeroupper
ret
}
}
#
endif
#
endif
#
ifdef
HAS_ARGBGRAYROW_SSSE3
__declspec
(
naked
)
void
ARGBGrayRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqa
xmm4
xmmword
ptr
kARGBToYJ
movdqa
xmm5
xmmword
ptr
kAddYJ64
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
pmaddubsw
xmm0
xmm4
pmaddubsw
xmm1
xmm4
phaddw
xmm0
xmm1
paddw
xmm0
xmm5
psrlw
xmm0
7
packuswb
xmm0
xmm0
movdqu
xmm2
[
eax
]
movdqu
xmm3
[
eax
+
16
]
lea
eax
[
eax
+
32
]
psrld
xmm2
24
psrld
xmm3
24
packuswb
xmm2
xmm3
packuswb
xmm2
xmm2
movdqa
xmm3
xmm0
punpcklbw
xmm0
xmm0
punpcklbw
xmm3
xmm2
movdqa
xmm1
xmm0
punpcklwd
xmm0
xmm3
punpckhwd
xmm1
xmm3
movdqu
[
edx
]
xmm0
movdqu
[
edx
+
16
]
xmm1
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBSEPIAROW_SSSE3
static
const
vec8
kARGBToSepiaB
=
{
17
68
35
0
17
68
35
0
17
68
35
0
17
68
35
0
}
;
static
const
vec8
kARGBToSepiaG
=
{
22
88
45
0
22
88
45
0
22
88
45
0
22
88
45
0
}
;
static
const
vec8
kARGBToSepiaR
=
{
24
98
50
0
24
98
50
0
24
98
50
0
24
98
50
0
}
;
__declspec
(
naked
)
void
ARGBSepiaRow_SSSE3
(
uint8_t
*
dst_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
ecx
[
esp
+
8
]
movdqa
xmm2
xmmword
ptr
kARGBToSepiaB
movdqa
xmm3
xmmword
ptr
kARGBToSepiaG
movdqa
xmm4
xmmword
ptr
kARGBToSepiaR
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm6
[
eax
+
16
]
pmaddubsw
xmm0
xmm2
pmaddubsw
xmm6
xmm2
phaddw
xmm0
xmm6
psrlw
xmm0
7
packuswb
xmm0
xmm0
movdqu
xmm5
[
eax
]
movdqu
xmm1
[
eax
+
16
]
pmaddubsw
xmm5
xmm3
pmaddubsw
xmm1
xmm3
phaddw
xmm5
xmm1
psrlw
xmm5
7
packuswb
xmm5
xmm5
punpcklbw
xmm0
xmm5
movdqu
xmm5
[
eax
]
movdqu
xmm1
[
eax
+
16
]
pmaddubsw
xmm5
xmm4
pmaddubsw
xmm1
xmm4
phaddw
xmm5
xmm1
psrlw
xmm5
7
packuswb
xmm5
xmm5
movdqu
xmm6
[
eax
]
movdqu
xmm1
[
eax
+
16
]
psrld
xmm6
24
psrld
xmm1
24
packuswb
xmm6
xmm1
packuswb
xmm6
xmm6
punpcklbw
xmm5
xmm6
movdqa
xmm1
xmm0
punpcklwd
xmm0
xmm5
punpckhwd
xmm1
xmm5
movdqu
[
eax
]
xmm0
movdqu
[
eax
+
16
]
xmm1
lea
eax
[
eax
+
32
]
sub
ecx
8
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBCOLORMATRIXROW_SSSE3
__declspec
(
naked
)
void
ARGBColorMatrixRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
const
int8_t
*
matrix_argb
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqu
xmm5
[
ecx
]
pshufd
xmm2
xmm5
0x00
pshufd
xmm3
xmm5
0x55
pshufd
xmm4
xmm5
0xaa
pshufd
xmm5
xmm5
0xff
mov
ecx
[
esp
+
16
]
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm7
[
eax
+
16
]
pmaddubsw
xmm0
xmm2
pmaddubsw
xmm7
xmm2
movdqu
xmm6
[
eax
]
movdqu
xmm1
[
eax
+
16
]
pmaddubsw
xmm6
xmm3
pmaddubsw
xmm1
xmm3
phaddsw
xmm0
xmm7
phaddsw
xmm6
xmm1
psraw
xmm0
6
psraw
xmm6
6
packuswb
xmm0
xmm0
packuswb
xmm6
xmm6
punpcklbw
xmm0
xmm6
movdqu
xmm1
[
eax
]
movdqu
xmm7
[
eax
+
16
]
pmaddubsw
xmm1
xmm4
pmaddubsw
xmm7
xmm4
phaddsw
xmm1
xmm7
movdqu
xmm6
[
eax
]
movdqu
xmm7
[
eax
+
16
]
pmaddubsw
xmm6
xmm5
pmaddubsw
xmm7
xmm5
phaddsw
xmm6
xmm7
psraw
xmm1
6
psraw
xmm6
6
packuswb
xmm1
xmm1
packuswb
xmm6
xmm6
punpcklbw
xmm1
xmm6
movdqa
xmm6
xmm0
punpcklwd
xmm0
xmm1
punpckhwd
xmm6
xmm1
movdqu
[
edx
]
xmm0
movdqu
[
edx
+
16
]
xmm6
lea
eax
[
eax
+
32
]
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBQUANTIZEROW_SSE2
__declspec
(
naked
)
void
ARGBQuantizeRow_SSE2
(
uint8_t
*
dst_argb
int
scale
int
interval_size
int
interval_offset
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
movd
xmm2
[
esp
+
8
]
movd
xmm3
[
esp
+
12
]
movd
xmm4
[
esp
+
16
]
mov
ecx
[
esp
+
20
]
pshuflw
xmm2
xmm2
040h
pshufd
xmm2
xmm2
044h
pshuflw
xmm3
xmm3
040h
pshufd
xmm3
xmm3
044h
pshuflw
xmm4
xmm4
040h
pshufd
xmm4
xmm4
044h
pxor
xmm5
xmm5
pcmpeqb
xmm6
xmm6
pslld
xmm6
24
convertloop
:
movdqu
xmm0
[
eax
]
punpcklbw
xmm0
xmm5
pmulhuw
xmm0
xmm2
movdqu
xmm1
[
eax
]
punpckhbw
xmm1
xmm5
pmulhuw
xmm1
xmm2
pmullw
xmm0
xmm3
movdqu
xmm7
[
eax
]
pmullw
xmm1
xmm3
pand
xmm7
xmm6
paddw
xmm0
xmm4
paddw
xmm1
xmm4
packuswb
xmm0
xmm1
por
xmm0
xmm7
movdqu
[
eax
]
xmm0
lea
eax
[
eax
+
16
]
sub
ecx
4
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBSHADEROW_SSE2
__declspec
(
naked
)
void
ARGBShadeRow_SSE2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
uint32_t
value
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movd
xmm2
[
esp
+
16
]
punpcklbw
xmm2
xmm2
punpcklqdq
xmm2
xmm2
convertloop
:
movdqu
xmm0
[
eax
]
lea
eax
[
eax
+
16
]
movdqa
xmm1
xmm0
punpcklbw
xmm0
xmm0
punpckhbw
xmm1
xmm1
pmulhuw
xmm0
xmm2
pmulhuw
xmm1
xmm2
psrlw
xmm0
8
psrlw
xmm1
8
packuswb
xmm0
xmm1
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
4
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_ARGBMULTIPLYROW_SSE2
__declspec
(
naked
)
void
ARGBMultiplyRow_SSE2
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
pxor
xmm5
xmm5
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm2
[
esi
]
movdqu
xmm1
xmm0
movdqu
xmm3
xmm2
punpcklbw
xmm0
xmm0
punpckhbw
xmm1
xmm1
punpcklbw
xmm2
xmm5
punpckhbw
xmm3
xmm5
pmulhuw
xmm0
xmm2
pmulhuw
xmm1
xmm3
lea
eax
[
eax
+
16
]
lea
esi
[
esi
+
16
]
packuswb
xmm0
xmm1
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
4
jg
convertloop
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_ARGBADDROW_SSE2
__declspec
(
naked
)
void
ARGBAddRow_SSE2
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
sub
ecx
4
jl
convertloop49
convertloop4
:
movdqu
xmm0
[
eax
]
lea
eax
[
eax
+
16
]
movdqu
xmm1
[
esi
]
lea
esi
[
esi
+
16
]
paddusb
xmm0
xmm1
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
4
jge
convertloop4
convertloop49
:
add
ecx
4
-
1
jl
convertloop19
convertloop1
:
movd
xmm0
[
eax
]
lea
eax
[
eax
+
4
]
movd
xmm1
[
esi
]
lea
esi
[
esi
+
4
]
paddusb
xmm0
xmm1
movd
[
edx
]
xmm0
lea
edx
[
edx
+
4
]
sub
ecx
1
jge
convertloop1
convertloop19
:
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_ARGBSUBTRACTROW_SSE2
__declspec
(
naked
)
void
ARGBSubtractRow_SSE2
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
convertloop
:
movdqu
xmm0
[
eax
]
lea
eax
[
eax
+
16
]
movdqu
xmm1
[
esi
]
lea
esi
[
esi
+
16
]
psubusb
xmm0
xmm1
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
4
jg
convertloop
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_ARGBMULTIPLYROW_AVX2
__declspec
(
naked
)
void
ARGBMultiplyRow_AVX2
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
vpxor
ymm5
ymm5
ymm5
convertloop
:
vmovdqu
ymm1
[
eax
]
lea
eax
[
eax
+
32
]
vmovdqu
ymm3
[
esi
]
lea
esi
[
esi
+
32
]
vpunpcklbw
ymm0
ymm1
ymm1
vpunpckhbw
ymm1
ymm1
ymm1
vpunpcklbw
ymm2
ymm3
ymm5
vpunpckhbw
ymm3
ymm3
ymm5
vpmulhuw
ymm0
ymm0
ymm2
vpmulhuw
ymm1
ymm1
ymm3
vpackuswb
ymm0
ymm0
ymm1
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBADDROW_AVX2
__declspec
(
naked
)
void
ARGBAddRow_AVX2
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
convertloop
:
vmovdqu
ymm0
[
eax
]
lea
eax
[
eax
+
32
]
vpaddusb
ymm0
ymm0
[
esi
]
lea
esi
[
esi
+
32
]
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBSUBTRACTROW_AVX2
__declspec
(
naked
)
void
ARGBSubtractRow_AVX2
(
const
uint8_t
*
src_argb
const
uint8_t
*
src_argb1
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
convertloop
:
vmovdqu
ymm0
[
eax
]
lea
eax
[
eax
+
32
]
vpsubusb
ymm0
ymm0
[
esi
]
lea
esi
[
esi
+
32
]
vmovdqu
[
edx
]
ymm0
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
convertloop
pop
esi
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_SOBELXROW_SSE2
__declspec
(
naked
)
void
SobelXRow_SSE2
(
const
uint8_t
*
src_y0
const
uint8_t
*
src_y1
const
uint8_t
*
src_y2
uint8_t
*
dst_sobelx
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edi
[
esp
+
8
+
12
]
mov
edx
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
sub
esi
eax
sub
edi
eax
sub
edx
eax
pxor
xmm5
xmm5
convertloop
:
movq
xmm0
qword
ptr
[
eax
]
movq
xmm1
qword
ptr
[
eax
+
2
]
punpcklbw
xmm0
xmm5
punpcklbw
xmm1
xmm5
psubw
xmm0
xmm1
movq
xmm1
qword
ptr
[
eax
+
esi
]
movq
xmm2
qword
ptr
[
eax
+
esi
+
2
]
punpcklbw
xmm1
xmm5
punpcklbw
xmm2
xmm5
psubw
xmm1
xmm2
movq
xmm2
qword
ptr
[
eax
+
edi
]
movq
xmm3
qword
ptr
[
eax
+
edi
+
2
]
punpcklbw
xmm2
xmm5
punpcklbw
xmm3
xmm5
psubw
xmm2
xmm3
paddw
xmm0
xmm2
paddw
xmm0
xmm1
paddw
xmm0
xmm1
pxor
xmm1
xmm1
psubw
xmm1
xmm0
pmaxsw
xmm0
xmm1
packuswb
xmm0
xmm0
movq
qword
ptr
[
eax
+
edx
]
xmm0
lea
eax
[
eax
+
8
]
sub
ecx
8
jg
convertloop
pop
edi
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_SOBELYROW_SSE2
__declspec
(
naked
)
void
SobelYRow_SSE2
(
const
uint8_t
*
src_y0
const
uint8_t
*
src_y1
uint8_t
*
dst_sobely
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
sub
esi
eax
sub
edx
eax
pxor
xmm5
xmm5
convertloop
:
movq
xmm0
qword
ptr
[
eax
]
movq
xmm1
qword
ptr
[
eax
+
esi
]
punpcklbw
xmm0
xmm5
punpcklbw
xmm1
xmm5
psubw
xmm0
xmm1
movq
xmm1
qword
ptr
[
eax
+
1
]
movq
xmm2
qword
ptr
[
eax
+
esi
+
1
]
punpcklbw
xmm1
xmm5
punpcklbw
xmm2
xmm5
psubw
xmm1
xmm2
movq
xmm2
qword
ptr
[
eax
+
2
]
movq
xmm3
qword
ptr
[
eax
+
esi
+
2
]
punpcklbw
xmm2
xmm5
punpcklbw
xmm3
xmm5
psubw
xmm2
xmm3
paddw
xmm0
xmm2
paddw
xmm0
xmm1
paddw
xmm0
xmm1
pxor
xmm1
xmm1
psubw
xmm1
xmm0
pmaxsw
xmm0
xmm1
packuswb
xmm0
xmm0
movq
qword
ptr
[
eax
+
edx
]
xmm0
lea
eax
[
eax
+
8
]
sub
ecx
8
jg
convertloop
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_SOBELROW_SSE2
__declspec
(
naked
)
void
SobelRow_SSE2
(
const
uint8_t
*
src_sobelx
const
uint8_t
*
src_sobely
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
sub
esi
eax
pcmpeqb
xmm5
xmm5
pslld
xmm5
24
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
esi
]
lea
eax
[
eax
+
16
]
paddusb
xmm0
xmm1
movdqa
xmm2
xmm0
punpcklbw
xmm2
xmm0
punpckhbw
xmm0
xmm0
movdqa
xmm1
xmm2
punpcklwd
xmm1
xmm2
punpckhwd
xmm2
xmm2
por
xmm1
xmm5
por
xmm2
xmm5
movdqa
xmm3
xmm0
punpcklwd
xmm3
xmm0
punpckhwd
xmm0
xmm0
por
xmm3
xmm5
por
xmm0
xmm5
movdqu
[
edx
]
xmm1
movdqu
[
edx
+
16
]
xmm2
movdqu
[
edx
+
32
]
xmm3
movdqu
[
edx
+
48
]
xmm0
lea
edx
[
edx
+
64
]
sub
ecx
16
jg
convertloop
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_SOBELTOPLANEROW_SSE2
__declspec
(
naked
)
void
SobelToPlaneRow_SSE2
(
const
uint8_t
*
src_sobelx
const
uint8_t
*
src_sobely
uint8_t
*
dst_y
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
sub
esi
eax
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
esi
]
lea
eax
[
eax
+
16
]
paddusb
xmm0
xmm1
movdqu
[
edx
]
xmm0
lea
edx
[
edx
+
16
]
sub
ecx
16
jg
convertloop
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_SOBELXYROW_SSE2
__declspec
(
naked
)
void
SobelXYRow_SSE2
(
const
uint8_t
*
src_sobelx
const
uint8_t
*
src_sobely
uint8_t
*
dst_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
edx
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
sub
esi
eax
pcmpeqb
xmm5
xmm5
convertloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
esi
]
lea
eax
[
eax
+
16
]
movdqa
xmm2
xmm0
paddusb
xmm2
xmm1
movdqa
xmm3
xmm0
punpcklbw
xmm3
xmm5
punpckhbw
xmm0
xmm5
movdqa
xmm4
xmm1
punpcklbw
xmm4
xmm2
punpckhbw
xmm1
xmm2
movdqa
xmm6
xmm4
punpcklwd
xmm6
xmm3
punpckhwd
xmm4
xmm3
movdqa
xmm7
xmm1
punpcklwd
xmm7
xmm0
punpckhwd
xmm1
xmm0
movdqu
[
edx
]
xmm6
movdqu
[
edx
+
16
]
xmm4
movdqu
[
edx
+
32
]
xmm7
movdqu
[
edx
+
48
]
xmm1
lea
edx
[
edx
+
64
]
sub
ecx
16
jg
convertloop
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_CUMULATIVESUMTOAVERAGEROW_SSE2
void
CumulativeSumToAverageRow_SSE2
(
const
int32_t
*
topleft
const
int32_t
*
botleft
int
width
int
area
uint8_t
*
dst
int
count
)
{
__asm
{
mov
eax
topleft
mov
esi
botleft
mov
edx
width
movd
xmm5
area
mov
edi
dst
mov
ecx
count
cvtdq2ps
xmm5
xmm5
rcpss
xmm4
xmm5
pshufd
xmm4
xmm4
0
sub
ecx
4
jl
l4b
cmp
area
128
ja
l4
pshufd
xmm5
xmm5
0
pcmpeqb
xmm6
xmm6
psrld
xmm6
16
cvtdq2ps
xmm6
xmm6
addps
xmm5
xmm6
mulps
xmm5
xmm4
cvtps2dq
xmm5
xmm5
packssdw
xmm5
xmm5
s4
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
psubd
xmm0
[
eax
+
edx
*
4
]
psubd
xmm1
[
eax
+
edx
*
4
+
16
]
psubd
xmm2
[
eax
+
edx
*
4
+
32
]
psubd
xmm3
[
eax
+
edx
*
4
+
48
]
lea
eax
[
eax
+
64
]
psubd
xmm0
[
esi
]
psubd
xmm1
[
esi
+
16
]
psubd
xmm2
[
esi
+
32
]
psubd
xmm3
[
esi
+
48
]
paddd
xmm0
[
esi
+
edx
*
4
]
paddd
xmm1
[
esi
+
edx
*
4
+
16
]
paddd
xmm2
[
esi
+
edx
*
4
+
32
]
paddd
xmm3
[
esi
+
edx
*
4
+
48
]
lea
esi
[
esi
+
64
]
packssdw
xmm0
xmm1
packssdw
xmm2
xmm3
pmulhuw
xmm0
xmm5
pmulhuw
xmm2
xmm5
packuswb
xmm0
xmm2
movdqu
[
edi
]
xmm0
lea
edi
[
edi
+
16
]
sub
ecx
4
jge
s4
jmp
l4b
l4
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
movdqu
xmm2
[
eax
+
32
]
movdqu
xmm3
[
eax
+
48
]
psubd
xmm0
[
eax
+
edx
*
4
]
psubd
xmm1
[
eax
+
edx
*
4
+
16
]
psubd
xmm2
[
eax
+
edx
*
4
+
32
]
psubd
xmm3
[
eax
+
edx
*
4
+
48
]
lea
eax
[
eax
+
64
]
psubd
xmm0
[
esi
]
psubd
xmm1
[
esi
+
16
]
psubd
xmm2
[
esi
+
32
]
psubd
xmm3
[
esi
+
48
]
paddd
xmm0
[
esi
+
edx
*
4
]
paddd
xmm1
[
esi
+
edx
*
4
+
16
]
paddd
xmm2
[
esi
+
edx
*
4
+
32
]
paddd
xmm3
[
esi
+
edx
*
4
+
48
]
lea
esi
[
esi
+
64
]
cvtdq2ps
xmm0
xmm0
cvtdq2ps
xmm1
xmm1
mulps
xmm0
xmm4
mulps
xmm1
xmm4
cvtdq2ps
xmm2
xmm2
cvtdq2ps
xmm3
xmm3
mulps
xmm2
xmm4
mulps
xmm3
xmm4
cvtps2dq
xmm0
xmm0
cvtps2dq
xmm1
xmm1
cvtps2dq
xmm2
xmm2
cvtps2dq
xmm3
xmm3
packssdw
xmm0
xmm1
packssdw
xmm2
xmm3
packuswb
xmm0
xmm2
movdqu
[
edi
]
xmm0
lea
edi
[
edi
+
16
]
sub
ecx
4
jge
l4
l4b
:
add
ecx
4
-
1
jl
l1b
l1
:
movdqu
xmm0
[
eax
]
psubd
xmm0
[
eax
+
edx
*
4
]
lea
eax
[
eax
+
16
]
psubd
xmm0
[
esi
]
paddd
xmm0
[
esi
+
edx
*
4
]
lea
esi
[
esi
+
16
]
cvtdq2ps
xmm0
xmm0
mulps
xmm0
xmm4
cvtps2dq
xmm0
xmm0
packssdw
xmm0
xmm0
packuswb
xmm0
xmm0
movd
dword
ptr
[
edi
]
xmm0
lea
edi
[
edi
+
4
]
sub
ecx
1
jge
l1
l1b
:
}
}
#
endif
#
ifdef
HAS_COMPUTECUMULATIVESUMROW_SSE2
void
ComputeCumulativeSumRow_SSE2
(
const
uint8_t
*
row
int32_t
*
cumsum
const
int32_t
*
previous_cumsum
int
width
)
{
__asm
{
mov
eax
row
mov
edx
cumsum
mov
esi
previous_cumsum
mov
ecx
width
pxor
xmm0
xmm0
pxor
xmm1
xmm1
sub
ecx
4
jl
l4b
test
edx
15
jne
l4b
l4
:
movdqu
xmm2
[
eax
]
lea
eax
[
eax
+
16
]
movdqa
xmm4
xmm2
punpcklbw
xmm2
xmm1
movdqa
xmm3
xmm2
punpcklwd
xmm2
xmm1
punpckhwd
xmm3
xmm1
punpckhbw
xmm4
xmm1
movdqa
xmm5
xmm4
punpcklwd
xmm4
xmm1
punpckhwd
xmm5
xmm1
paddd
xmm0
xmm2
movdqu
xmm2
[
esi
]
paddd
xmm2
xmm0
paddd
xmm0
xmm3
movdqu
xmm3
[
esi
+
16
]
paddd
xmm3
xmm0
paddd
xmm0
xmm4
movdqu
xmm4
[
esi
+
32
]
paddd
xmm4
xmm0
paddd
xmm0
xmm5
movdqu
xmm5
[
esi
+
48
]
lea
esi
[
esi
+
64
]
paddd
xmm5
xmm0
movdqu
[
edx
]
xmm2
movdqu
[
edx
+
16
]
xmm3
movdqu
[
edx
+
32
]
xmm4
movdqu
[
edx
+
48
]
xmm5
lea
edx
[
edx
+
64
]
sub
ecx
4
jge
l4
l4b
:
add
ecx
4
-
1
jl
l1b
l1
:
movd
xmm2
dword
ptr
[
eax
]
lea
eax
[
eax
+
4
]
punpcklbw
xmm2
xmm1
punpcklwd
xmm2
xmm1
paddd
xmm0
xmm2
movdqu
xmm2
[
esi
]
lea
esi
[
esi
+
16
]
paddd
xmm2
xmm0
movdqu
[
edx
]
xmm2
lea
edx
[
edx
+
16
]
sub
ecx
1
jge
l1
l1b
:
}
}
#
endif
#
ifdef
HAS_ARGBAFFINEROW_SSE2
__declspec
(
naked
)
LIBYUV_API
void
ARGBAffineRow_SSE2
(
const
uint8_t
*
src_argb
int
src_argb_stride
uint8_t
*
dst_argb
const
float
*
uv_dudv
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
12
]
mov
esi
[
esp
+
16
]
mov
edx
[
esp
+
20
]
mov
ecx
[
esp
+
24
]
movq
xmm2
qword
ptr
[
ecx
]
movq
xmm7
qword
ptr
[
ecx
+
8
]
mov
ecx
[
esp
+
28
]
shl
esi
16
add
esi
4
movd
xmm5
esi
sub
ecx
4
jl
l4b
pshufd
xmm7
xmm7
0x44
pshufd
xmm5
xmm5
0
movdqa
xmm0
xmm2
addps
xmm0
xmm7
movlhps
xmm2
xmm0
movdqa
xmm4
xmm7
addps
xmm4
xmm4
movdqa
xmm3
xmm2
addps
xmm3
xmm4
addps
xmm4
xmm4
l4
:
cvttps2dq
xmm0
xmm2
cvttps2dq
xmm1
xmm3
packssdw
xmm0
xmm1
pmaddwd
xmm0
xmm5
movd
esi
xmm0
pshufd
xmm0
xmm0
0x39
movd
edi
xmm0
pshufd
xmm0
xmm0
0x39
movd
xmm1
[
eax
+
esi
]
movd
xmm6
[
eax
+
edi
]
punpckldq
xmm1
xmm6
addps
xmm2
xmm4
movq
qword
ptr
[
edx
]
xmm1
movd
esi
xmm0
pshufd
xmm0
xmm0
0x39
movd
edi
xmm0
movd
xmm6
[
eax
+
esi
]
movd
xmm0
[
eax
+
edi
]
punpckldq
xmm6
xmm0
addps
xmm3
xmm4
movq
qword
ptr
8
[
edx
]
xmm6
lea
edx
[
edx
+
16
]
sub
ecx
4
jge
l4
l4b
:
add
ecx
4
-
1
jl
l1b
l1
:
cvttps2dq
xmm0
xmm2
packssdw
xmm0
xmm0
pmaddwd
xmm0
xmm5
addps
xmm2
xmm7
movd
esi
xmm0
movd
xmm0
[
eax
+
esi
]
movd
[
edx
]
xmm0
lea
edx
[
edx
+
4
]
sub
ecx
1
jge
l1
l1b
:
pop
edi
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_INTERPOLATEROW_AVX2
__declspec
(
naked
)
void
InterpolateRow_AVX2
(
uint8_t
*
dst_ptr
const
uint8_t
*
src_ptr
ptrdiff_t
src_stride
int
dst_width
int
source_y_fraction
)
{
__asm
{
push
esi
push
edi
mov
edi
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
ecx
[
esp
+
8
+
16
]
mov
eax
[
esp
+
8
+
20
]
cmp
eax
0
je
xloop100
sub
edi
esi
cmp
eax
128
je
xloop50
vmovd
xmm0
eax
neg
eax
add
eax
256
vmovd
xmm5
eax
vpunpcklbw
xmm5
xmm5
xmm0
vpunpcklwd
xmm5
xmm5
xmm5
vbroadcastss
ymm5
xmm5
mov
eax
0x80808080
vmovd
xmm4
eax
vbroadcastss
ymm4
xmm4
xloop
:
vmovdqu
ymm0
[
esi
]
vmovdqu
ymm2
[
esi
+
edx
]
vpunpckhbw
ymm1
ymm0
ymm2
vpunpcklbw
ymm0
ymm0
ymm2
vpsubb
ymm1
ymm1
ymm4
vpsubb
ymm0
ymm0
ymm4
vpmaddubsw
ymm1
ymm5
ymm1
vpmaddubsw
ymm0
ymm5
ymm0
vpaddw
ymm1
ymm1
ymm4
vpaddw
ymm0
ymm0
ymm4
vpsrlw
ymm1
ymm1
8
vpsrlw
ymm0
ymm0
8
vpackuswb
ymm0
ymm0
ymm1
vmovdqu
[
esi
+
edi
]
ymm0
lea
esi
[
esi
+
32
]
sub
ecx
32
jg
xloop
jmp
xloop99
xloop50
:
vmovdqu
ymm0
[
esi
]
vpavgb
ymm0
ymm0
[
esi
+
edx
]
vmovdqu
[
esi
+
edi
]
ymm0
lea
esi
[
esi
+
32
]
sub
ecx
32
jg
xloop50
jmp
xloop99
xloop100
:
rep
movsb
xloop99
:
pop
edi
pop
esi
vzeroupper
ret
}
}
#
endif
__declspec
(
naked
)
void
InterpolateRow_SSSE3
(
uint8_t
*
dst_ptr
const
uint8_t
*
src_ptr
ptrdiff_t
src_stride
int
dst_width
int
source_y_fraction
)
{
__asm
{
push
esi
push
edi
mov
edi
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
ecx
[
esp
+
8
+
16
]
mov
eax
[
esp
+
8
+
20
]
sub
edi
esi
cmp
eax
0
je
xloop100
cmp
eax
128
je
xloop50
movd
xmm0
eax
neg
eax
add
eax
256
movd
xmm5
eax
punpcklbw
xmm5
xmm0
punpcklwd
xmm5
xmm5
pshufd
xmm5
xmm5
0
mov
eax
0x80808080
movd
xmm4
eax
pshufd
xmm4
xmm4
0x00
xloop
:
movdqu
xmm0
[
esi
]
movdqu
xmm2
[
esi
+
edx
]
movdqu
xmm1
xmm0
punpcklbw
xmm0
xmm2
punpckhbw
xmm1
xmm2
psubb
xmm0
xmm4
psubb
xmm1
xmm4
movdqa
xmm2
xmm5
movdqa
xmm3
xmm5
pmaddubsw
xmm2
xmm0
pmaddubsw
xmm3
xmm1
paddw
xmm2
xmm4
paddw
xmm3
xmm4
psrlw
xmm2
8
psrlw
xmm3
8
packuswb
xmm2
xmm3
movdqu
[
esi
+
edi
]
xmm2
lea
esi
[
esi
+
16
]
sub
ecx
16
jg
xloop
jmp
xloop99
xloop50
:
movdqu
xmm0
[
esi
]
movdqu
xmm1
[
esi
+
edx
]
pavgb
xmm0
xmm1
movdqu
[
esi
+
edi
]
xmm0
lea
esi
[
esi
+
16
]
sub
ecx
16
jg
xloop50
jmp
xloop99
xloop100
:
movdqu
xmm0
[
esi
]
movdqu
[
esi
+
edi
]
xmm0
lea
esi
[
esi
+
16
]
sub
ecx
16
jg
xloop100
xloop99
:
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
ARGBShuffleRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
const
uint8_t
*
shuffler
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
movdqu
xmm5
[
ecx
]
mov
ecx
[
esp
+
16
]
wloop
:
movdqu
xmm0
[
eax
]
movdqu
xmm1
[
eax
+
16
]
lea
eax
[
eax
+
32
]
pshufb
xmm0
xmm5
pshufb
xmm1
xmm5
movdqu
[
edx
]
xmm0
movdqu
[
edx
+
16
]
xmm1
lea
edx
[
edx
+
32
]
sub
ecx
8
jg
wloop
ret
}
}
#
ifdef
HAS_ARGBSHUFFLEROW_AVX2
__declspec
(
naked
)
void
ARGBShuffleRow_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
const
uint8_t
*
shuffler
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vbroadcastf128
ymm5
[
ecx
]
mov
ecx
[
esp
+
16
]
wloop
:
vmovdqu
ymm0
[
eax
]
vmovdqu
ymm1
[
eax
+
32
]
lea
eax
[
eax
+
64
]
vpshufb
ymm0
ymm0
ymm5
vpshufb
ymm1
ymm1
ymm5
vmovdqu
[
edx
]
ymm0
vmovdqu
[
edx
+
32
]
ymm1
lea
edx
[
edx
+
64
]
sub
ecx
16
jg
wloop
vzeroupper
ret
}
}
#
endif
__declspec
(
naked
)
void
I422ToYUY2Row_SSE2
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_frame
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
sub
edx
esi
convertloop
:
movq
xmm2
qword
ptr
[
esi
]
movq
xmm3
qword
ptr
[
esi
+
edx
]
lea
esi
[
esi
+
8
]
punpcklbw
xmm2
xmm3
movdqu
xmm0
[
eax
]
lea
eax
[
eax
+
16
]
movdqa
xmm1
xmm0
punpcklbw
xmm0
xmm2
punpckhbw
xmm1
xmm2
movdqu
[
edi
]
xmm0
movdqu
[
edi
+
16
]
xmm1
lea
edi
[
edi
+
32
]
sub
ecx
16
jg
convertloop
pop
edi
pop
esi
ret
}
}
__declspec
(
naked
)
void
I422ToUYVYRow_SSE2
(
const
uint8_t
*
src_y
const
uint8_t
*
src_u
const
uint8_t
*
src_v
uint8_t
*
dst_frame
int
width
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
esi
[
esp
+
8
+
8
]
mov
edx
[
esp
+
8
+
12
]
mov
edi
[
esp
+
8
+
16
]
mov
ecx
[
esp
+
8
+
20
]
sub
edx
esi
convertloop
:
movq
xmm2
qword
ptr
[
esi
]
movq
xmm3
qword
ptr
[
esi
+
edx
]
lea
esi
[
esi
+
8
]
punpcklbw
xmm2
xmm3
movdqu
xmm0
[
eax
]
movdqa
xmm1
xmm2
lea
eax
[
eax
+
16
]
punpcklbw
xmm1
xmm0
punpckhbw
xmm2
xmm0
movdqu
[
edi
]
xmm1
movdqu
[
edi
+
16
]
xmm2
lea
edi
[
edi
+
32
]
sub
ecx
16
jg
convertloop
pop
edi
pop
esi
ret
}
}
#
ifdef
HAS_ARGBPOLYNOMIALROW_SSE2
__declspec
(
naked
)
void
ARGBPolynomialRow_SSE2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
const
float
*
poly
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
edx
[
esp
+
4
+
8
]
mov
esi
[
esp
+
4
+
12
]
mov
ecx
[
esp
+
4
+
16
]
pxor
xmm3
xmm3
convertloop
:
movq
xmm0
qword
ptr
[
eax
]
lea
eax
[
eax
+
8
]
punpcklbw
xmm0
xmm3
movdqa
xmm4
xmm0
punpcklwd
xmm0
xmm3
punpckhwd
xmm4
xmm3
cvtdq2ps
xmm0
xmm0
cvtdq2ps
xmm4
xmm4
movdqa
xmm1
xmm0
movdqa
xmm5
xmm4
mulps
xmm0
[
esi
+
16
]
mulps
xmm4
[
esi
+
16
]
addps
xmm0
[
esi
]
addps
xmm4
[
esi
]
movdqa
xmm2
xmm1
movdqa
xmm6
xmm5
mulps
xmm2
xmm1
mulps
xmm6
xmm5
mulps
xmm1
xmm2
mulps
xmm5
xmm6
mulps
xmm2
[
esi
+
32
]
mulps
xmm6
[
esi
+
32
]
mulps
xmm1
[
esi
+
48
]
mulps
xmm5
[
esi
+
48
]
addps
xmm0
xmm2
addps
xmm4
xmm6
addps
xmm0
xmm1
addps
xmm4
xmm5
cvttps2dq
xmm0
xmm0
cvttps2dq
xmm4
xmm4
packuswb
xmm0
xmm4
packuswb
xmm0
xmm0
movq
qword
ptr
[
edx
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
2
jg
convertloop
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_ARGBPOLYNOMIALROW_AVX2
__declspec
(
naked
)
void
ARGBPolynomialRow_AVX2
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
const
float
*
poly
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
vbroadcastf128
ymm4
[
ecx
]
vbroadcastf128
ymm5
[
ecx
+
16
]
vbroadcastf128
ymm6
[
ecx
+
32
]
vbroadcastf128
ymm7
[
ecx
+
48
]
mov
ecx
[
esp
+
16
]
convertloop
:
vpmovzxbd
ymm0
qword
ptr
[
eax
]
lea
eax
[
eax
+
8
]
vcvtdq2ps
ymm0
ymm0
vmulps
ymm2
ymm0
ymm0
vmulps
ymm3
ymm0
ymm7
vfmadd132ps
ymm0
ymm4
ymm5
vfmadd231ps
ymm0
ymm2
ymm6
vfmadd231ps
ymm0
ymm2
ymm3
vcvttps2dq
ymm0
ymm0
vpackusdw
ymm0
ymm0
ymm0
vpermq
ymm0
ymm0
0xd8
vpackuswb
xmm0
xmm0
xmm0
vmovq
qword
ptr
[
edx
]
xmm0
lea
edx
[
edx
+
8
]
sub
ecx
2
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_HALFFLOATROW_SSE2
static
float
kExpBias
=
1
.
9259299444e
-
34f
;
__declspec
(
naked
)
void
HalfFloatRow_SSE2
(
const
uint16_t
*
src
uint16_t
*
dst
float
scale
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
movd
xmm4
dword
ptr
[
esp
+
12
]
mov
ecx
[
esp
+
16
]
mulss
xmm4
kExpBias
pshufd
xmm4
xmm4
0
pxor
xmm5
xmm5
sub
edx
eax
convertloop
:
movdqu
xmm2
xmmword
ptr
[
eax
]
add
eax
16
movdqa
xmm3
xmm2
punpcklwd
xmm2
xmm5
cvtdq2ps
xmm2
xmm2
punpckhwd
xmm3
xmm5
cvtdq2ps
xmm3
xmm3
mulps
xmm2
xmm4
mulps
xmm3
xmm4
psrld
xmm2
13
psrld
xmm3
13
packssdw
xmm2
xmm3
movdqu
[
eax
+
edx
-
16
]
xmm2
sub
ecx
8
jg
convertloop
ret
}
}
#
endif
#
ifdef
HAS_HALFFLOATROW_AVX2
__declspec
(
naked
)
void
HalfFloatRow_AVX2
(
const
uint16_t
*
src
uint16_t
*
dst
float
scale
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
movd
xmm4
dword
ptr
[
esp
+
12
]
mov
ecx
[
esp
+
16
]
vmulss
xmm4
xmm4
kExpBias
vbroadcastss
ymm4
xmm4
vpxor
ymm5
ymm5
ymm5
sub
edx
eax
convertloop
:
vmovdqu
ymm2
[
eax
]
add
eax
32
vpunpckhwd
ymm3
ymm2
ymm5
vpunpcklwd
ymm2
ymm2
ymm5
vcvtdq2ps
ymm3
ymm3
vcvtdq2ps
ymm2
ymm2
vmulps
ymm3
ymm3
ymm4
vmulps
ymm2
ymm2
ymm4
vpsrld
ymm3
ymm3
13
vpsrld
ymm2
ymm2
13
vpackssdw
ymm2
ymm2
ymm3
vmovdqu
[
eax
+
edx
-
32
]
ymm2
sub
ecx
16
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_HALFFLOATROW_F16C
__declspec
(
naked
)
void
HalfFloatRow_F16C
(
const
uint16_t
*
src
uint16_t
*
dst
float
scale
int
width
)
{
__asm
{
mov
eax
[
esp
+
4
]
mov
edx
[
esp
+
8
]
vbroadcastss
ymm4
[
esp
+
12
]
mov
ecx
[
esp
+
16
]
sub
edx
eax
convertloop
:
vpmovzxwd
ymm2
xmmword
ptr
[
eax
]
vpmovzxwd
ymm3
xmmword
ptr
[
eax
+
16
]
add
eax
32
vcvtdq2ps
ymm2
ymm2
vcvtdq2ps
ymm3
ymm3
vmulps
ymm2
ymm2
ymm4
vmulps
ymm3
ymm3
ymm4
vcvtps2ph
xmm2
ymm2
3
vcvtps2ph
xmm3
ymm3
3
vmovdqu
[
eax
+
edx
+
32
]
xmm2
vmovdqu
[
eax
+
edx
+
32
+
16
]
xmm3
sub
ecx
16
jg
convertloop
vzeroupper
ret
}
}
#
endif
#
ifdef
HAS_ARGBCOLORTABLEROW_X86
__declspec
(
naked
)
void
ARGBColorTableRow_X86
(
uint8_t
*
dst_argb
const
uint8_t
*
table_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
ecx
[
esp
+
4
+
12
]
convertloop
:
movzx
edx
byte
ptr
[
eax
]
lea
eax
[
eax
+
4
]
movzx
edx
byte
ptr
[
esi
+
edx
*
4
]
mov
byte
ptr
[
eax
-
4
]
dl
movzx
edx
byte
ptr
[
eax
-
4
+
1
]
movzx
edx
byte
ptr
[
esi
+
edx
*
4
+
1
]
mov
byte
ptr
[
eax
-
4
+
1
]
dl
movzx
edx
byte
ptr
[
eax
-
4
+
2
]
movzx
edx
byte
ptr
[
esi
+
edx
*
4
+
2
]
mov
byte
ptr
[
eax
-
4
+
2
]
dl
movzx
edx
byte
ptr
[
eax
-
4
+
3
]
movzx
edx
byte
ptr
[
esi
+
edx
*
4
+
3
]
mov
byte
ptr
[
eax
-
4
+
3
]
dl
dec
ecx
jg
convertloop
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_RGBCOLORTABLEROW_X86
__declspec
(
naked
)
void
RGBColorTableRow_X86
(
uint8_t
*
dst_argb
const
uint8_t
*
table_argb
int
width
)
{
__asm
{
push
esi
mov
eax
[
esp
+
4
+
4
]
mov
esi
[
esp
+
4
+
8
]
mov
ecx
[
esp
+
4
+
12
]
convertloop
:
movzx
edx
byte
ptr
[
eax
]
lea
eax
[
eax
+
4
]
movzx
edx
byte
ptr
[
esi
+
edx
*
4
]
mov
byte
ptr
[
eax
-
4
]
dl
movzx
edx
byte
ptr
[
eax
-
4
+
1
]
movzx
edx
byte
ptr
[
esi
+
edx
*
4
+
1
]
mov
byte
ptr
[
eax
-
4
+
1
]
dl
movzx
edx
byte
ptr
[
eax
-
4
+
2
]
movzx
edx
byte
ptr
[
esi
+
edx
*
4
+
2
]
mov
byte
ptr
[
eax
-
4
+
2
]
dl
dec
ecx
jg
convertloop
pop
esi
ret
}
}
#
endif
#
ifdef
HAS_ARGBLUMACOLORTABLEROW_SSSE3
__declspec
(
naked
)
void
ARGBLumaColorTableRow_SSSE3
(
const
uint8_t
*
src_argb
uint8_t
*
dst_argb
int
width
const
uint8_t
*
luma
uint32_t
lumacoeff
)
{
__asm
{
push
esi
push
edi
mov
eax
[
esp
+
8
+
4
]
mov
edi
[
esp
+
8
+
8
]
mov
ecx
[
esp
+
8
+
12
]
movd
xmm2
dword
ptr
[
esp
+
8
+
16
]
movd
xmm3
dword
ptr
[
esp
+
8
+
20
]
pshufd
xmm2
xmm2
0
pshufd
xmm3
xmm3
0
pcmpeqb
xmm4
xmm4
psllw
xmm4
8
pxor
xmm5
xmm5
convertloop
:
movdqu
xmm0
xmmword
ptr
[
eax
]
pmaddubsw
xmm0
xmm3
phaddw
xmm0
xmm0
pand
xmm0
xmm4
punpcklwd
xmm0
xmm5
paddd
xmm0
xmm2
movd
esi
xmm0
pshufd
xmm0
xmm0
0x39
movzx
edx
byte
ptr
[
eax
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
]
dl
movzx
edx
byte
ptr
[
eax
+
1
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
1
]
dl
movzx
edx
byte
ptr
[
eax
+
2
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
2
]
dl
movzx
edx
byte
ptr
[
eax
+
3
]
mov
byte
ptr
[
edi
+
3
]
dl
movd
esi
xmm0
pshufd
xmm0
xmm0
0x39
movzx
edx
byte
ptr
[
eax
+
4
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
4
]
dl
movzx
edx
byte
ptr
[
eax
+
5
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
5
]
dl
movzx
edx
byte
ptr
[
eax
+
6
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
6
]
dl
movzx
edx
byte
ptr
[
eax
+
7
]
mov
byte
ptr
[
edi
+
7
]
dl
movd
esi
xmm0
pshufd
xmm0
xmm0
0x39
movzx
edx
byte
ptr
[
eax
+
8
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
8
]
dl
movzx
edx
byte
ptr
[
eax
+
9
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
9
]
dl
movzx
edx
byte
ptr
[
eax
+
10
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
10
]
dl
movzx
edx
byte
ptr
[
eax
+
11
]
mov
byte
ptr
[
edi
+
11
]
dl
movd
esi
xmm0
movzx
edx
byte
ptr
[
eax
+
12
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
12
]
dl
movzx
edx
byte
ptr
[
eax
+
13
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
13
]
dl
movzx
edx
byte
ptr
[
eax
+
14
]
movzx
edx
byte
ptr
[
esi
+
edx
]
mov
byte
ptr
[
edi
+
14
]
dl
movzx
edx
byte
ptr
[
eax
+
15
]
mov
byte
ptr
[
edi
+
15
]
dl
lea
eax
[
eax
+
16
]
lea
edi
[
edi
+
16
]
sub
ecx
4
jg
convertloop
pop
edi
pop
esi
ret
}
}
#
endif
#
endif
#
ifdef
__cplusplus
}
}
#
endif
#
endif
