#
include
"
libyuv
/
cpu_id
.
h
"
#
if
defined
(
_MSC_VER
)
#
include
<
intrin
.
h
>
#
endif
#
if
!
defined
(
__pnacl__
)
&
&
!
defined
(
__CLR_VER
)
&
&
\
!
defined
(
__native_client__
)
&
&
(
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
)
&
&
\
defined
(
_MSC_FULL_VER
)
&
&
(
_MSC_FULL_VER
>
=
160040219
)
#
include
<
immintrin
.
h
>
#
endif
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
ifdef
__cplusplus
namespace
libyuv
{
extern
"
C
"
{
#
endif
#
if
defined
(
_MSC_FULL_VER
)
&
&
(
_MSC_FULL_VER
>
=
160040219
)
&
&
\
!
defined
(
__clang__
)
#
define
SAFEBUFFERS
__declspec
(
safebuffers
)
#
else
#
define
SAFEBUFFERS
#
endif
LIBYUV_API
int
cpu_info_
=
0
;
#
if
(
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
|
|
defined
(
__i386__
)
|
|
\
defined
(
__x86_64__
)
)
&
&
\
!
defined
(
__pnacl__
)
&
&
!
defined
(
__CLR_VER
)
LIBYUV_API
void
CpuId
(
int
info_eax
int
info_ecx
int
*
cpu_info
)
{
#
if
defined
(
_MSC_VER
)
#
if
defined
(
_MSC_FULL_VER
)
&
&
(
_MSC_FULL_VER
>
=
160040219
)
__cpuidex
(
cpu_info
info_eax
info_ecx
)
;
#
elif
defined
(
_M_IX86
)
__asm
{
mov
eax
info_eax
mov
ecx
info_ecx
mov
edi
cpu_info
cpuid
mov
[
edi
]
eax
mov
[
edi
+
4
]
ebx
mov
[
edi
+
8
]
ecx
mov
[
edi
+
12
]
edx
}
#
else
if
(
info_ecx
=
=
0
)
{
__cpuid
(
cpu_info
info_eax
)
;
}
else
{
cpu_info
[
3
]
=
cpu_info
[
2
]
=
cpu_info
[
1
]
=
cpu_info
[
0
]
=
0u
;
}
#
endif
#
else
int
info_ebx
info_edx
;
asm
volatile
(
#
if
defined
(
__i386__
)
&
&
defined
(
__PIC__
)
"
mov
%
%
ebx
%
%
edi
\
n
"
"
cpuid
\
n
"
"
xchg
%
%
edi
%
%
ebx
\
n
"
:
"
=
D
"
(
info_ebx
)
#
else
"
cpuid
\
n
"
:
"
=
b
"
(
info_ebx
)
#
endif
"
+
a
"
(
info_eax
)
"
+
c
"
(
info_ecx
)
"
=
d
"
(
info_edx
)
)
;
cpu_info
[
0
]
=
info_eax
;
cpu_info
[
1
]
=
info_ebx
;
cpu_info
[
2
]
=
info_ecx
;
cpu_info
[
3
]
=
info_edx
;
#
endif
}
#
else
LIBYUV_API
void
CpuId
(
int
eax
int
ecx
int
*
cpu_info
)
{
(
void
)
eax
;
(
void
)
ecx
;
cpu_info
[
0
]
=
cpu_info
[
1
]
=
cpu_info
[
2
]
=
cpu_info
[
3
]
=
0
;
}
#
endif
#
if
defined
(
_M_IX86
)
&
&
(
_MSC_VER
<
1900
)
#
pragma
optimize
(
"
g
"
off
)
#
endif
#
if
(
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
|
|
defined
(
__i386__
)
|
|
\
defined
(
__x86_64__
)
)
&
&
\
!
defined
(
__pnacl__
)
&
&
!
defined
(
__CLR_VER
)
&
&
!
defined
(
__native_client__
)
int
GetXCR0
(
)
{
int
xcr0
=
0
;
#
if
defined
(
_MSC_FULL_VER
)
&
&
(
_MSC_FULL_VER
>
=
160040219
)
xcr0
=
(
int
)
_xgetbv
(
0
)
;
#
elif
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
asm
(
"
.
byte
0x0f
0x01
0xd0
"
:
"
=
a
"
(
xcr0
)
:
"
c
"
(
0
)
:
"
%
edx
"
)
;
#
endif
return
xcr0
;
}
#
else
#
define
GetXCR0
(
)
0
#
endif
#
if
defined
(
_M_IX86
)
&
&
(
_MSC_VER
<
1900
)
#
pragma
optimize
(
"
g
"
on
)
#
endif
LIBYUV_API
SAFEBUFFERS
int
ArmCpuCaps
(
const
char
*
cpuinfo_name
)
{
char
cpuinfo_line
[
512
]
;
FILE
*
f
=
fopen
(
cpuinfo_name
"
r
"
)
;
if
(
!
f
)
{
return
kCpuHasNEON
;
}
while
(
fgets
(
cpuinfo_line
sizeof
(
cpuinfo_line
)
-
1
f
)
)
{
if
(
memcmp
(
cpuinfo_line
"
Features
"
8
)
=
=
0
)
{
char
*
p
=
strstr
(
cpuinfo_line
"
neon
"
)
;
if
(
p
&
&
(
p
[
5
]
=
=
'
'
|
|
p
[
5
]
=
=
'
\
n
'
)
)
{
fclose
(
f
)
;
return
kCpuHasNEON
;
}
p
=
strstr
(
cpuinfo_line
"
asimd
"
)
;
if
(
p
)
{
fclose
(
f
)
;
return
kCpuHasNEON
;
}
}
}
fclose
(
f
)
;
return
0
;
}
LIBYUV_API
SAFEBUFFERS
int
MipsCpuCaps
(
const
char
*
cpuinfo_name
)
{
char
cpuinfo_line
[
512
]
;
int
flag
=
0x0
;
FILE
*
f
=
fopen
(
cpuinfo_name
"
r
"
)
;
if
(
!
f
)
{
return
0
;
}
while
(
fgets
(
cpuinfo_line
sizeof
(
cpuinfo_line
)
-
1
f
)
)
{
if
(
memcmp
(
cpuinfo_line
"
cpu
model
"
9
)
=
=
0
)
{
if
(
strstr
(
cpuinfo_line
"
Loongson
-
2K
"
)
)
{
flag
|
=
kCpuHasMSA
;
}
}
if
(
memcmp
(
cpuinfo_line
"
ASEs
implemented
"
16
)
=
=
0
)
{
if
(
strstr
(
cpuinfo_line
"
msa
"
)
)
{
flag
|
=
kCpuHasMSA
;
}
break
;
}
}
fclose
(
f
)
;
return
flag
;
}
#
define
LOONGARCH_CFG2
0x2
#
define
LOONGARCH_CFG2_LSX
(
1
<
<
6
)
#
define
LOONGARCH_CFG2_LASX
(
1
<
<
7
)
#
if
defined
(
__loongarch__
)
LIBYUV_API
SAFEBUFFERS
int
LoongarchCpuCaps
(
void
)
{
int
flag
=
0x0
;
uint32_t
cfg2
=
0
;
__asm__
volatile
(
"
cpucfg
%
0
%
1
\
n
\
t
"
:
"
+
&
r
"
(
cfg2
)
:
"
r
"
(
LOONGARCH_CFG2
)
)
;
if
(
cfg2
&
LOONGARCH_CFG2_LSX
)
flag
|
=
kCpuHasLSX
;
if
(
cfg2
&
LOONGARCH_CFG2_LASX
)
flag
|
=
kCpuHasLASX
;
return
flag
;
}
#
endif
static
SAFEBUFFERS
int
GetCpuFlags
(
void
)
{
int
cpu_info
=
0
;
#
if
!
defined
(
__pnacl__
)
&
&
!
defined
(
__CLR_VER
)
&
&
\
(
defined
(
__x86_64__
)
|
|
defined
(
_M_X64
)
|
|
defined
(
__i386__
)
|
|
\
defined
(
_M_IX86
)
)
int
cpu_info0
[
4
]
=
{
0
0
0
0
}
;
int
cpu_info1
[
4
]
=
{
0
0
0
0
}
;
int
cpu_info7
[
4
]
=
{
0
0
0
0
}
;
CpuId
(
0
0
cpu_info0
)
;
CpuId
(
1
0
cpu_info1
)
;
if
(
cpu_info0
[
0
]
>
=
7
)
{
CpuId
(
7
0
cpu_info7
)
;
}
cpu_info
=
kCpuHasX86
|
(
(
cpu_info1
[
3
]
&
0x04000000
)
?
kCpuHasSSE2
:
0
)
|
(
(
cpu_info1
[
2
]
&
0x00000200
)
?
kCpuHasSSSE3
:
0
)
|
(
(
cpu_info1
[
2
]
&
0x00080000
)
?
kCpuHasSSE41
:
0
)
|
(
(
cpu_info1
[
2
]
&
0x00100000
)
?
kCpuHasSSE42
:
0
)
|
(
(
cpu_info7
[
1
]
&
0x00000200
)
?
kCpuHasERMS
:
0
)
;
if
(
(
(
cpu_info1
[
2
]
&
0x1c000000
)
=
=
0x1c000000
)
&
&
(
(
GetXCR0
(
)
&
6
)
=
=
6
)
)
{
cpu_info
|
=
kCpuHasAVX
|
(
(
cpu_info7
[
1
]
&
0x00000020
)
?
kCpuHasAVX2
:
0
)
|
(
(
cpu_info1
[
2
]
&
0x00001000
)
?
kCpuHasFMA3
:
0
)
|
(
(
cpu_info1
[
2
]
&
0x20000000
)
?
kCpuHasF16C
:
0
)
;
if
(
(
GetXCR0
(
)
&
0xe0
)
=
=
0xe0
)
{
cpu_info
|
=
(
cpu_info7
[
1
]
&
0x40000000
)
?
kCpuHasAVX512BW
:
0
;
cpu_info
|
=
(
cpu_info7
[
1
]
&
0x80000000
)
?
kCpuHasAVX512VL
:
0
;
cpu_info
|
=
(
cpu_info7
[
2
]
&
0x00000002
)
?
kCpuHasAVX512VBMI
:
0
;
cpu_info
|
=
(
cpu_info7
[
2
]
&
0x00000040
)
?
kCpuHasAVX512VBMI2
:
0
;
cpu_info
|
=
(
cpu_info7
[
2
]
&
0x00000800
)
?
kCpuHasAVX512VNNI
:
0
;
cpu_info
|
=
(
cpu_info7
[
2
]
&
0x00001000
)
?
kCpuHasAVX512VBITALG
:
0
;
cpu_info
|
=
(
cpu_info7
[
2
]
&
0x00004000
)
?
kCpuHasAVX512VPOPCNTDQ
:
0
;
cpu_info
|
=
(
cpu_info7
[
2
]
&
0x00000100
)
?
kCpuHasGFNI
:
0
;
}
}
#
endif
#
if
defined
(
__mips__
)
&
&
defined
(
__linux__
)
cpu_info
=
MipsCpuCaps
(
"
/
proc
/
cpuinfo
"
)
;
cpu_info
|
=
kCpuHasMIPS
;
#
endif
#
if
defined
(
__loongarch__
)
&
&
defined
(
__linux__
)
cpu_info
=
LoongarchCpuCaps
(
)
;
cpu_info
|
=
kCpuHasLOONGARCH
;
#
endif
#
if
defined
(
__arm__
)
|
|
defined
(
__aarch64__
)
#
if
defined
(
__ARM_NEON__
)
|
|
defined
(
__native_client__
)
|
|
!
defined
(
__linux__
)
cpu_info
=
kCpuHasNEON
;
#
endif
#
if
defined
(
__aarch64__
)
cpu_info
=
kCpuHasNEON
;
#
else
cpu_info
=
ArmCpuCaps
(
"
/
proc
/
cpuinfo
"
)
;
#
endif
cpu_info
|
=
kCpuHasARM
;
#
endif
cpu_info
|
=
kCpuInitialized
;
return
cpu_info
;
}
LIBYUV_API
int
MaskCpuFlags
(
int
enable_flags
)
{
int
cpu_info
=
GetCpuFlags
(
)
&
enable_flags
;
SetCpuFlags
(
cpu_info
)
;
return
cpu_info
;
}
LIBYUV_API
int
InitCpuFlags
(
void
)
{
return
MaskCpuFlags
(
-
1
)
;
}
#
ifdef
__cplusplus
}
}
#
endif
