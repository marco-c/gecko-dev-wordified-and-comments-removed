#
include
"
libyuv
/
rotate_row
.
h
"
#
include
"
libyuv
/
row
.
h
"
#
include
"
libyuv
/
basic_types
.
h
"
#
ifdef
__cplusplus
namespace
libyuv
{
extern
"
C
"
{
#
endif
#
if
!
defined
(
LIBYUV_DISABLE_SME
)
&
&
defined
(
CLANG_HAS_SME
)
&
&
\
defined
(
__aarch64__
)
__arm_locally_streaming
__arm_new
(
"
za
"
)
void
TransposeWxH_SME
(
const
uint8_t
*
src
int
src_stride
uint8_t
*
dst
int
dst_stride
int
width
int
height
)
{
int
vl
;
asm
(
"
cntb
%
x0
"
:
"
=
r
"
(
vl
)
)
;
do
{
const
uint8_t
*
src2
=
src
;
uint8_t
*
dst2
=
dst
;
int
block_height
=
height
>
vl
?
vl
:
height
;
int
width2
=
width
;
do
{
const
uint8_t
*
src3
=
src2
;
int
block_width
=
width2
>
vl
?
vl
:
width2
;
asm
volatile
(
"
mov
w12
#
0
\
n
"
"
whilelt
p0
.
b
wzr
%
w
[
block_width
]
\
n
"
"
1
:
\
n
"
"
ld1b
{
za0h
.
b
[
w12
0
]
}
p0
/
z
[
%
[
src3
]
]
\
n
"
"
add
%
[
src3
]
%
[
src3
]
%
[
src_stride
]
\
n
"
"
add
w12
w12
#
1
\
n
"
"
cmp
w12
%
w
[
block_height
]
\
n
"
"
b
.
ne
1b
\
n
"
"
whilelt
p0
.
b
wzr
%
w
[
block_height
]
\
n
"
"
mov
w12
#
0
\
n
"
"
2
:
\
n
"
"
st1b
{
za0v
.
b
[
w12
0
]
}
p0
[
%
[
dst2
]
]
\
n
"
"
add
%
[
dst2
]
%
[
dst2
]
%
[
dst_stride
]
\
n
"
"
add
w12
w12
#
1
\
n
"
"
cmp
w12
%
w
[
block_width
]
\
n
"
"
b
.
ne
2b
\
n
"
:
[
src3
]
"
+
r
"
(
src3
)
[
dst2
]
"
+
r
"
(
dst2
)
:
[
src_stride
]
"
r
"
(
(
ptrdiff_t
)
src_stride
)
[
dst_stride
]
"
r
"
(
(
ptrdiff_t
)
dst_stride
)
[
block_width
]
"
r
"
(
block_width
)
[
block_height
]
"
r
"
(
block_height
)
:
"
cc
"
"
memory
"
"
p0
"
"
w12
"
"
za
"
)
;
src2
+
=
vl
;
width2
-
=
vl
;
}
while
(
width2
>
0
)
;
src
+
=
vl
*
src_stride
;
dst
+
=
vl
;
height
-
=
vl
;
}
while
(
height
>
0
)
;
}
__arm_locally_streaming
__arm_new
(
"
za
"
)
void
TransposeUVWxH_SME
(
const
uint8_t
*
src
int
src_stride
uint8_t
*
dst_a
int
dst_stride_a
uint8_t
*
dst_b
int
dst_stride_b
int
width
int
height
)
{
int
vl
;
asm
(
"
cnth
%
x0
"
:
"
=
r
"
(
vl
)
)
;
do
{
const
uint8_t
*
src2
=
src
;
uint8_t
*
dst2_a
=
dst_a
;
uint8_t
*
dst2_b
=
dst_b
;
int
block_height
=
height
>
vl
*
2
?
vl
*
2
:
height
;
int
width2
=
width
;
do
{
const
uint8_t
*
src3
=
src2
;
int
block_width
=
width2
>
vl
?
vl
:
width2
;
asm
volatile
(
"
mov
w12
#
0
\
n
"
"
whilelt
p0
.
b
wzr
%
w
[
block_width
]
\
n
"
"
1
:
\
n
"
"
ld1b
{
za0h
.
b
[
w12
0
]
}
p0
/
z
[
%
[
src
]
]
\
n
"
"
add
%
[
src
]
%
[
src
]
%
[
src_stride
]
\
n
"
"
add
w12
w12
#
1
\
n
"
"
cmp
w12
%
w
[
block_height
]
\
n
"
"
b
.
ne
1b
\
n
"
"
whilelt
p0
.
b
wzr
%
w
[
block_height
]
\
n
"
"
mov
w12
#
0
\
n
"
"
2
:
\
n
"
"
st1b
{
za0v
.
b
[
w12
0
]
}
p0
[
%
[
dst_a
]
]
\
n
"
"
st1b
{
za0v
.
b
[
w12
1
]
}
p0
[
%
[
dst_b
]
]
\
n
"
"
add
%
[
dst_a
]
%
[
dst_a
]
%
[
dst_stride_a
]
\
n
"
"
add
%
[
dst_b
]
%
[
dst_b
]
%
[
dst_stride_b
]
\
n
"
"
add
w12
w12
#
2
\
n
"
"
cmp
w12
%
w
[
block_width
]
\
n
"
"
b
.
ne
2b
\
n
"
:
[
src
]
"
+
r
"
(
src3
)
[
dst_a
]
"
+
r
"
(
dst2_a
)
[
dst_b
]
"
+
r
"
(
dst2_b
)
:
[
src_stride
]
"
r
"
(
(
ptrdiff_t
)
src_stride
)
[
dst_stride_a
]
"
r
"
(
(
ptrdiff_t
)
dst_stride_a
)
[
dst_stride_b
]
"
r
"
(
(
ptrdiff_t
)
dst_stride_b
)
[
block_width
]
"
r
"
(
block_width
*
2
)
[
block_height
]
"
r
"
(
block_height
)
:
"
cc
"
"
memory
"
"
p0
"
"
w12
"
"
za
"
)
;
src2
+
=
2
*
vl
;
width2
-
=
vl
;
}
while
(
width2
>
0
)
;
src
+
=
2
*
vl
*
src_stride
;
dst_a
+
=
2
*
vl
;
dst_b
+
=
2
*
vl
;
height
-
=
2
*
vl
;
}
while
(
height
>
0
)
;
}
#
endif
#
ifdef
__cplusplus
}
}
#
endif
