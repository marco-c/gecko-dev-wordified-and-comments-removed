#
include
"
config_components
.
h
"
#
include
"
avcodec
.
h
"
#
include
"
codec_internal
.
h
"
#
include
"
libavutil
/
avassert
.
h
"
#
include
"
libavutil
/
internal
.
h
"
#
include
"
libavutil
/
mem
.
h
"
#
include
"
libavutil
/
opt
.
h
"
#
include
<
string
.
h
>
FF_DISABLE_DEPRECATION_WARNINGS
#
include
"
options_table
.
h
"
FF_ENABLE_DEPRECATION_WARNINGS
static
const
char
*
context_to_name
(
void
*
ptr
)
{
AVCodecContext
*
avc
=
ptr
;
if
(
avc
&
&
avc
-
>
codec
)
return
avc
-
>
codec
-
>
name
;
else
return
"
NULL
"
;
}
static
void
*
codec_child_next
(
void
*
obj
void
*
prev
)
{
AVCodecContext
*
s
=
obj
;
if
(
!
prev
&
&
s
-
>
codec
&
&
s
-
>
codec
-
>
priv_class
&
&
s
-
>
priv_data
)
return
s
-
>
priv_data
;
return
NULL
;
}
static
const
AVClass
*
codec_child_class_iterate
(
void
*
*
iter
)
{
const
AVCodec
*
c
;
while
(
c
=
av_codec_iterate
(
iter
)
)
if
(
c
-
>
priv_class
)
return
c
-
>
priv_class
;
return
NULL
;
}
static
AVClassCategory
get_category
(
void
*
ptr
)
{
AVCodecContext
*
avctx
=
ptr
;
if
(
avctx
-
>
codec
&
&
av_codec_is_decoder
(
avctx
-
>
codec
)
)
return
AV_CLASS_CATEGORY_DECODER
;
else
return
AV_CLASS_CATEGORY_ENCODER
;
}
static
const
AVClass
av_codec_context_class
=
{
.
class_name
=
"
AVCodecContext
"
.
item_name
=
context_to_name
.
option
=
avcodec_options
.
version
=
LIBAVUTIL_VERSION_INT
.
log_level_offset_offset
=
offsetof
(
AVCodecContext
log_level_offset
)
.
child_next
=
codec_child_next
.
child_class_iterate
=
codec_child_class_iterate
.
category
=
AV_CLASS_CATEGORY_ENCODER
.
get_category
=
get_category
}
;
static
int
init_context_defaults
(
AVCodecContext
*
s
const
AVCodec
*
codec
)
{
const
FFCodec
*
const
codec2
=
ffcodec
(
codec
)
;
int
flags
=
0
;
memset
(
s
0
sizeof
(
AVCodecContext
)
)
;
s
-
>
av_class
=
&
av_codec_context_class
;
s
-
>
codec_type
=
codec
?
codec
-
>
type
:
AVMEDIA_TYPE_UNKNOWN
;
if
(
codec
)
{
s
-
>
codec
=
codec
;
s
-
>
codec_id
=
codec
-
>
id
;
}
if
(
s
-
>
codec_type
=
=
AVMEDIA_TYPE_AUDIO
)
flags
=
AV_OPT_FLAG_AUDIO_PARAM
;
else
if
(
s
-
>
codec_type
=
=
AVMEDIA_TYPE_VIDEO
)
flags
=
AV_OPT_FLAG_VIDEO_PARAM
;
else
if
(
s
-
>
codec_type
=
=
AVMEDIA_TYPE_SUBTITLE
)
flags
=
AV_OPT_FLAG_SUBTITLE_PARAM
;
av_opt_set_defaults2
(
s
flags
flags
)
;
av_channel_layout_uninit
(
&
s
-
>
ch_layout
)
;
s
-
>
time_base
=
(
AVRational
)
{
0
1
}
;
s
-
>
framerate
=
(
AVRational
)
{
0
1
}
;
s
-
>
pkt_timebase
=
(
AVRational
)
{
0
1
}
;
s
-
>
get_buffer2
=
avcodec_default_get_buffer2
;
s
-
>
get_format
=
avcodec_default_get_format
;
s
-
>
get_encode_buffer
=
avcodec_default_get_encode_buffer
;
s
-
>
execute
=
avcodec_default_execute
;
s
-
>
execute2
=
avcodec_default_execute2
;
s
-
>
sample_aspect_ratio
=
(
AVRational
)
{
0
1
}
;
s
-
>
ch_layout
.
order
=
AV_CHANNEL_ORDER_UNSPEC
;
s
-
>
pix_fmt
=
AV_PIX_FMT_NONE
;
s
-
>
sw_pix_fmt
=
AV_PIX_FMT_NONE
;
s
-
>
sample_fmt
=
AV_SAMPLE_FMT_NONE
;
#
if
FF_API_REORDERED_OPAQUE
FF_DISABLE_DEPRECATION_WARNINGS
s
-
>
reordered_opaque
=
AV_NOPTS_VALUE
;
FF_ENABLE_DEPRECATION_WARNINGS
#
endif
if
(
codec
&
&
codec2
-
>
priv_data_size
)
{
s
-
>
priv_data
=
av_mallocz
(
codec2
-
>
priv_data_size
)
;
if
(
!
s
-
>
priv_data
)
return
AVERROR
(
ENOMEM
)
;
if
(
codec
-
>
priv_class
)
{
*
(
const
AVClass
*
*
)
s
-
>
priv_data
=
codec
-
>
priv_class
;
av_opt_set_defaults
(
s
-
>
priv_data
)
;
}
}
if
(
codec
&
&
codec2
-
>
defaults
)
{
int
ret
;
const
FFCodecDefault
*
d
=
codec2
-
>
defaults
;
while
(
d
-
>
key
)
{
ret
=
av_opt_set
(
s
d
-
>
key
d
-
>
value
0
)
;
av_assert0
(
ret
>
=
0
)
;
d
+
+
;
}
}
return
0
;
}
AVCodecContext
*
avcodec_alloc_context3
(
const
AVCodec
*
codec
)
{
AVCodecContext
*
avctx
=
av_malloc
(
sizeof
(
AVCodecContext
)
)
;
if
(
!
avctx
)
return
NULL
;
if
(
init_context_defaults
(
avctx
codec
)
<
0
)
{
av_free
(
avctx
)
;
return
NULL
;
}
return
avctx
;
}
void
avcodec_free_context
(
AVCodecContext
*
*
pavctx
)
{
AVCodecContext
*
avctx
=
*
pavctx
;
if
(
!
avctx
)
return
;
avcodec_close
(
avctx
)
;
av_freep
(
&
avctx
-
>
extradata
)
;
av_freep
(
&
avctx
-
>
subtitle_header
)
;
av_freep
(
&
avctx
-
>
intra_matrix
)
;
av_freep
(
&
avctx
-
>
inter_matrix
)
;
av_freep
(
&
avctx
-
>
rc_override
)
;
av_channel_layout_uninit
(
&
avctx
-
>
ch_layout
)
;
av_freep
(
pavctx
)
;
}
const
AVClass
*
avcodec_get_class
(
void
)
{
return
&
av_codec_context_class
;
}
#
define
SROFFSET
(
x
)
offsetof
(
AVSubtitleRect
x
)
static
const
AVOption
subtitle_rect_options
[
]
=
{
{
"
x
"
"
"
SROFFSET
(
x
)
AV_OPT_TYPE_INT
{
.
i64
=
0
}
0
INT_MAX
0
}
{
"
y
"
"
"
SROFFSET
(
y
)
AV_OPT_TYPE_INT
{
.
i64
=
0
}
0
INT_MAX
0
}
{
"
w
"
"
"
SROFFSET
(
w
)
AV_OPT_TYPE_INT
{
.
i64
=
0
}
0
INT_MAX
0
}
{
"
h
"
"
"
SROFFSET
(
h
)
AV_OPT_TYPE_INT
{
.
i64
=
0
}
0
INT_MAX
0
}
{
"
type
"
"
"
SROFFSET
(
type
)
AV_OPT_TYPE_INT
{
.
i64
=
0
}
0
INT_MAX
0
}
{
"
flags
"
"
"
SROFFSET
(
flags
)
AV_OPT_TYPE_FLAGS
{
.
i64
=
0
}
0
1
0
"
flags
"
}
{
"
forced
"
"
"
SROFFSET
(
flags
)
AV_OPT_TYPE_FLAGS
{
.
i64
=
0
}
0
1
0
}
{
NULL
}
}
;
static
const
AVClass
av_subtitle_rect_class
=
{
.
class_name
=
"
AVSubtitleRect
"
.
item_name
=
NULL
.
option
=
subtitle_rect_options
.
version
=
LIBAVUTIL_VERSION_INT
}
;
const
AVClass
*
avcodec_get_subtitle_rect_class
(
void
)
{
return
&
av_subtitle_rect_class
;
}
