#
ifndef
AVCODEC_GET_BITS_H
#
define
AVCODEC_GET_BITS_H
#
include
<
stdint
.
h
>
#
include
"
libavutil
/
common
.
h
"
#
include
"
libavutil
/
intreadwrite
.
h
"
#
include
"
libavutil
/
avassert
.
h
"
#
include
"
defs
.
h
"
#
include
"
mathops
.
h
"
#
include
"
vlc
.
h
"
#
ifndef
UNCHECKED_BITSTREAM_READER
#
define
UNCHECKED_BITSTREAM_READER
!
CONFIG_SAFE_BITSTREAM_READER
#
endif
#
ifndef
CACHED_BITSTREAM_READER
#
define
CACHED_BITSTREAM_READER
0
#
endif
#
if
CACHED_BITSTREAM_READER
#
define
BITSTREAM_LE
#
ifndef
BITSTREAM_READER_LE
#
define
BITSTREAM_BE
#
define
BITSTREAM_DEFAULT_BE
#
endif
#
include
"
bitstream
.
h
"
#
undef
BITSTREAM_LE
#
undef
BITSTREAM_BE
#
undef
BITSTREAM_DEFAULT_BE
typedef
BitstreamContext
GetBitContext
;
#
define
get_bits_count
bits_tell
#
define
get_bits_left
bits_left
#
define
skip_bits_long
bits_skip
#
define
skip_bits
bits_skip
#
define
get_bits
bits_read_nz
#
define
get_bitsz
bits_read
#
define
get_bits_long
bits_read
#
define
get_bits1
bits_read_bit
#
define
get_bits64
bits_read_64
#
define
get_xbits
bits_read_xbits
#
define
get_sbits
bits_read_signed_nz
#
define
get_sbits_long
bits_read_signed
#
define
show_bits
bits_peek
#
define
show_bits_long
bits_peek
#
define
init_get_bits
bits_init
#
define
init_get_bits8
bits_init8
#
define
align_get_bits
bits_align
#
define
get_vlc2
bits_read_vlc
#
define
get_vlc_multi
bits_read_vlc_multi
#
define
get_leb
bits_read_leb
#
define
init_get_bits8_le
(
s
buffer
byte_size
)
bits_init8_le
(
(
BitstreamContextLE
*
)
s
buffer
byte_size
)
#
define
get_bits_le
(
s
n
)
bits_read_le
(
(
BitstreamContextLE
*
)
s
n
)
#
define
show_bits1
(
s
)
bits_peek
(
s
1
)
#
define
skip_bits1
(
s
)
bits_skip
(
s
1
)
#
define
skip_1stop_8data_bits
bits_skip_1stop_8data
#
else
typedef
struct
GetBitContext
{
const
uint8_t
*
buffer
*
buffer_end
;
int
index
;
int
size_in_bits
;
int
size_in_bits_plus8
;
}
GetBitContext
;
static
inline
unsigned
int
get_bits
(
GetBitContext
*
s
int
n
)
;
static
inline
void
skip_bits
(
GetBitContext
*
s
int
n
)
;
static
inline
unsigned
int
show_bits
(
GetBitContext
*
s
int
n
)
;
#
if
defined
LONG_BITSTREAM_READER
#
define
MIN_CACHE_BITS
32
#
else
#
define
MIN_CACHE_BITS
25
#
endif
#
define
OPEN_READER_NOSIZE
(
name
gb
)
\
unsigned
int
name
#
#
_index
=
(
gb
)
-
>
index
;
\
unsigned
int
av_unused
name
#
#
_cache
#
if
UNCHECKED_BITSTREAM_READER
#
define
OPEN_READER
(
name
gb
)
OPEN_READER_NOSIZE
(
name
gb
)
#
define
BITS_AVAILABLE
(
name
gb
)
1
#
else
#
define
OPEN_READER
(
name
gb
)
\
OPEN_READER_NOSIZE
(
name
gb
)
;
\
unsigned
int
name
#
#
_size_plus8
=
(
gb
)
-
>
size_in_bits_plus8
#
define
BITS_AVAILABLE
(
name
gb
)
name
#
#
_index
<
name
#
#
_size_plus8
#
endif
#
define
CLOSE_READER
(
name
gb
)
(
gb
)
-
>
index
=
name
#
#
_index
#
define
UPDATE_CACHE_BE_EXT
(
name
gb
bits
dst_bits
)
name
#
#
_cache
=
\
AV_RB
#
#
bits
(
(
gb
)
-
>
buffer
+
(
name
#
#
_index
>
>
3
)
)
<
<
(
name
#
#
_index
&
7
)
>
>
(
bits
-
dst_bits
)
#
define
UPDATE_CACHE_LE_EXT
(
name
gb
bits
dst_bits
)
name
#
#
_cache
=
\
(
uint
#
#
dst_bits
#
#
_t
)
(
AV_RL
#
#
bits
(
(
gb
)
-
>
buffer
+
(
name
#
#
_index
>
>
3
)
)
>
>
(
name
#
#
_index
&
7
)
)
#
define
UPDATE_CACHE_LE_32
(
name
gb
)
UPDATE_CACHE_LE_EXT
(
name
(
gb
)
64
32
)
#
define
UPDATE_CACHE_BE_32
(
name
gb
)
UPDATE_CACHE_BE_EXT
(
name
(
gb
)
64
32
)
#
ifdef
LONG_BITSTREAM_READER
#
define
UPDATE_CACHE_LE
(
name
gb
)
UPDATE_CACHE_LE_32
(
name
(
gb
)
)
#
define
UPDATE_CACHE_BE
(
name
gb
)
UPDATE_CACHE_BE_32
(
name
(
gb
)
)
#
else
#
define
UPDATE_CACHE_LE
(
name
gb
)
UPDATE_CACHE_LE_EXT
(
name
(
gb
)
32
32
)
#
define
UPDATE_CACHE_BE
(
name
gb
)
UPDATE_CACHE_BE_EXT
(
name
(
gb
)
32
32
)
#
endif
#
ifdef
BITSTREAM_READER_LE
#
define
UPDATE_CACHE
(
name
gb
)
UPDATE_CACHE_LE
(
name
gb
)
#
define
UPDATE_CACHE_32
(
name
gb
)
UPDATE_CACHE_LE_32
(
name
(
gb
)
)
#
define
SKIP_CACHE
(
name
gb
num
)
name
#
#
_cache
>
>
=
(
num
)
#
else
#
define
UPDATE_CACHE
(
name
gb
)
UPDATE_CACHE_BE
(
name
gb
)
#
define
UPDATE_CACHE_32
(
name
gb
)
UPDATE_CACHE_BE_32
(
name
(
gb
)
)
#
define
SKIP_CACHE
(
name
gb
num
)
name
#
#
_cache
<
<
=
(
num
)
#
endif
#
if
UNCHECKED_BITSTREAM_READER
#
define
SKIP_COUNTER
(
name
gb
num
)
name
#
#
_index
+
=
(
num
)
#
else
#
define
SKIP_COUNTER
(
name
gb
num
)
\
name
#
#
_index
=
FFMIN
(
name
#
#
_size_plus8
name
#
#
_index
+
(
num
)
)
#
endif
#
define
BITS_LEFT
(
name
gb
)
(
(
int
)
(
(
gb
)
-
>
size_in_bits
-
name
#
#
_index
)
)
#
define
SKIP_BITS
(
name
gb
num
)
\
do
{
\
SKIP_CACHE
(
name
gb
num
)
;
\
SKIP_COUNTER
(
name
gb
num
)
;
\
}
while
(
0
)
#
define
LAST_SKIP_BITS
(
name
gb
num
)
SKIP_COUNTER
(
name
gb
num
)
#
define
SHOW_UBITS_LE
(
name
gb
num
)
zero_extend
(
name
#
#
_cache
num
)
#
define
SHOW_SBITS_LE
(
name
gb
num
)
sign_extend
(
name
#
#
_cache
num
)
#
define
SHOW_UBITS_BE
(
name
gb
num
)
NEG_USR32
(
name
#
#
_cache
num
)
#
define
SHOW_SBITS_BE
(
name
gb
num
)
NEG_SSR32
(
name
#
#
_cache
num
)
#
ifdef
BITSTREAM_READER_LE
#
define
SHOW_UBITS
(
name
gb
num
)
SHOW_UBITS_LE
(
name
gb
num
)
#
define
SHOW_SBITS
(
name
gb
num
)
SHOW_SBITS_LE
(
name
gb
num
)
#
else
#
define
SHOW_UBITS
(
name
gb
num
)
SHOW_UBITS_BE
(
name
gb
num
)
#
define
SHOW_SBITS
(
name
gb
num
)
SHOW_SBITS_BE
(
name
gb
num
)
#
endif
#
define
GET_CACHE
(
name
gb
)
(
(
uint32_t
)
name
#
#
_cache
)
static
inline
int
get_bits_count
(
const
GetBitContext
*
s
)
{
return
s
-
>
index
;
}
static
inline
void
skip_bits_long
(
GetBitContext
*
s
int
n
)
{
#
if
UNCHECKED_BITSTREAM_READER
s
-
>
index
+
=
n
;
#
else
s
-
>
index
+
=
av_clip
(
n
-
s
-
>
index
s
-
>
size_in_bits_plus8
-
s
-
>
index
)
;
#
endif
}
static
inline
int
get_xbits
(
GetBitContext
*
s
int
n
)
{
register
int
sign
;
register
int32_t
cache
;
OPEN_READER
(
re
s
)
;
av_assert2
(
n
>
0
&
&
n
<
=
25
)
;
UPDATE_CACHE
(
re
s
)
;
cache
=
GET_CACHE
(
re
s
)
;
sign
=
~
cache
>
>
31
;
LAST_SKIP_BITS
(
re
s
n
)
;
CLOSE_READER
(
re
s
)
;
return
(
NEG_USR32
(
sign
^
cache
n
)
^
sign
)
-
sign
;
}
static
inline
int
get_xbits_le
(
GetBitContext
*
s
int
n
)
{
register
int
sign
;
register
int32_t
cache
;
OPEN_READER
(
re
s
)
;
av_assert2
(
n
>
0
&
&
n
<
=
25
)
;
UPDATE_CACHE_LE
(
re
s
)
;
cache
=
GET_CACHE
(
re
s
)
;
sign
=
sign_extend
(
~
cache
n
)
>
>
31
;
LAST_SKIP_BITS
(
re
s
n
)
;
CLOSE_READER
(
re
s
)
;
return
(
zero_extend
(
sign
^
cache
n
)
^
sign
)
-
sign
;
}
static
inline
int
get_sbits
(
GetBitContext
*
s
int
n
)
{
register
int
tmp
;
OPEN_READER
(
re
s
)
;
av_assert2
(
n
>
0
&
&
n
<
=
25
)
;
UPDATE_CACHE
(
re
s
)
;
tmp
=
SHOW_SBITS
(
re
s
n
)
;
LAST_SKIP_BITS
(
re
s
n
)
;
CLOSE_READER
(
re
s
)
;
return
tmp
;
}
static
inline
unsigned
int
get_bits
(
GetBitContext
*
s
int
n
)
{
register
unsigned
int
tmp
;
OPEN_READER
(
re
s
)
;
av_assert2
(
n
>
0
&
&
n
<
=
25
)
;
UPDATE_CACHE
(
re
s
)
;
tmp
=
SHOW_UBITS
(
re
s
n
)
;
LAST_SKIP_BITS
(
re
s
n
)
;
CLOSE_READER
(
re
s
)
;
av_assert2
(
tmp
<
UINT64_C
(
1
)
<
<
n
)
;
return
tmp
;
}
static
av_always_inline
int
get_bitsz
(
GetBitContext
*
s
int
n
)
{
return
n
?
get_bits
(
s
n
)
:
0
;
}
static
inline
unsigned
int
get_bits_le
(
GetBitContext
*
s
int
n
)
{
register
int
tmp
;
OPEN_READER
(
re
s
)
;
av_assert2
(
n
>
0
&
&
n
<
=
25
)
;
UPDATE_CACHE_LE
(
re
s
)
;
tmp
=
SHOW_UBITS_LE
(
re
s
n
)
;
LAST_SKIP_BITS
(
re
s
n
)
;
CLOSE_READER
(
re
s
)
;
return
tmp
;
}
static
inline
unsigned
int
show_bits
(
GetBitContext
*
s
int
n
)
{
register
unsigned
int
tmp
;
OPEN_READER_NOSIZE
(
re
s
)
;
av_assert2
(
n
>
0
&
&
n
<
=
25
)
;
UPDATE_CACHE
(
re
s
)
;
tmp
=
SHOW_UBITS
(
re
s
n
)
;
return
tmp
;
}
static
inline
void
skip_bits
(
GetBitContext
*
s
int
n
)
{
OPEN_READER
(
re
s
)
;
LAST_SKIP_BITS
(
re
s
n
)
;
CLOSE_READER
(
re
s
)
;
}
static
inline
unsigned
int
get_bits1
(
GetBitContext
*
s
)
{
unsigned
int
index
=
s
-
>
index
;
uint8_t
result
=
s
-
>
buffer
[
index
>
>
3
]
;
#
ifdef
BITSTREAM_READER_LE
result
>
>
=
index
&
7
;
result
&
=
1
;
#
else
result
<
<
=
index
&
7
;
result
>
>
=
8
-
1
;
#
endif
#
if
!
UNCHECKED_BITSTREAM_READER
if
(
s
-
>
index
<
s
-
>
size_in_bits_plus8
)
#
endif
index
+
+
;
s
-
>
index
=
index
;
return
result
;
}
static
inline
unsigned
int
show_bits1
(
GetBitContext
*
s
)
{
return
show_bits
(
s
1
)
;
}
static
inline
void
skip_bits1
(
GetBitContext
*
s
)
{
skip_bits
(
s
1
)
;
}
static
inline
unsigned
int
get_bits_long
(
GetBitContext
*
s
int
n
)
{
av_assert2
(
n
>
=
0
&
&
n
<
=
32
)
;
if
(
!
n
)
{
return
0
;
}
else
if
(
(
!
HAVE_FAST_64BIT
|
|
av_builtin_constant_p
(
n
<
=
MIN_CACHE_BITS
)
)
&
&
n
<
=
MIN_CACHE_BITS
)
{
return
get_bits
(
s
n
)
;
}
else
{
#
if
HAVE_FAST_64BIT
unsigned
tmp
;
OPEN_READER
(
re
s
)
;
UPDATE_CACHE_32
(
re
s
)
;
tmp
=
SHOW_UBITS
(
re
s
n
)
;
LAST_SKIP_BITS
(
re
s
n
)
;
CLOSE_READER
(
re
s
)
;
return
tmp
;
#
else
#
ifdef
BITSTREAM_READER_LE
unsigned
ret
=
get_bits
(
s
16
)
;
return
ret
|
(
get_bits
(
s
n
-
16
)
<
<
16
)
;
#
else
unsigned
ret
=
get_bits
(
s
16
)
<
<
(
n
-
16
)
;
return
ret
|
get_bits
(
s
n
-
16
)
;
#
endif
#
endif
}
}
static
inline
uint64_t
get_bits64
(
GetBitContext
*
s
int
n
)
{
if
(
n
<
=
32
)
{
return
get_bits_long
(
s
n
)
;
}
else
{
#
ifdef
BITSTREAM_READER_LE
uint64_t
ret
=
get_bits_long
(
s
32
)
;
return
ret
|
(
uint64_t
)
get_bits_long
(
s
n
-
32
)
<
<
32
;
#
else
uint64_t
ret
=
(
uint64_t
)
get_bits_long
(
s
n
-
32
)
<
<
32
;
return
ret
|
get_bits_long
(
s
32
)
;
#
endif
}
}
static
inline
int
get_sbits_long
(
GetBitContext
*
s
int
n
)
{
if
(
!
n
)
return
0
;
return
sign_extend
(
get_bits_long
(
s
n
)
n
)
;
}
static
inline
int64_t
get_sbits64
(
GetBitContext
*
s
int
n
)
{
if
(
!
n
)
return
0
;
return
sign_extend64
(
get_bits64
(
s
n
)
n
)
;
}
static
inline
unsigned
int
show_bits_long
(
GetBitContext
*
s
int
n
)
{
if
(
n
<
=
MIN_CACHE_BITS
)
{
return
show_bits
(
s
n
)
;
}
else
{
GetBitContext
gb
=
*
s
;
return
get_bits_long
(
&
gb
n
)
;
}
}
static
inline
int
init_get_bits
(
GetBitContext
*
s
const
uint8_t
*
buffer
int
bit_size
)
{
int
buffer_size
;
int
ret
=
0
;
if
(
bit_size
>
=
INT_MAX
-
FFMAX
(
7
AV_INPUT_BUFFER_PADDING_SIZE
*
8
)
|
|
bit_size
<
0
|
|
!
buffer
)
{
bit_size
=
0
;
buffer
=
NULL
;
ret
=
AVERROR_INVALIDDATA
;
}
buffer_size
=
(
bit_size
+
7
)
>
>
3
;
s
-
>
buffer
=
buffer
;
s
-
>
size_in_bits
=
bit_size
;
s
-
>
size_in_bits_plus8
=
bit_size
+
8
;
s
-
>
buffer_end
=
buffer
+
buffer_size
;
s
-
>
index
=
0
;
return
ret
;
}
static
inline
int
init_get_bits8
(
GetBitContext
*
s
const
uint8_t
*
buffer
int
byte_size
)
{
if
(
byte_size
>
INT_MAX
/
8
|
|
byte_size
<
0
)
byte_size
=
-
1
;
return
init_get_bits
(
s
buffer
byte_size
*
8
)
;
}
static
inline
int
init_get_bits8_le
(
GetBitContext
*
s
const
uint8_t
*
buffer
int
byte_size
)
{
if
(
byte_size
>
INT_MAX
/
8
|
|
byte_size
<
0
)
byte_size
=
-
1
;
return
init_get_bits
(
s
buffer
byte_size
*
8
)
;
}
static
inline
const
uint8_t
*
align_get_bits
(
GetBitContext
*
s
)
{
int
n
=
-
get_bits_count
(
s
)
&
7
;
if
(
n
)
skip_bits
(
s
n
)
;
return
s
-
>
buffer
+
(
s
-
>
index
>
>
3
)
;
}
#
define
GET_VLC
(
code
name
gb
table
bits
max_depth
)
\
do
{
\
int
n
nb_bits
;
\
unsigned
int
index
;
\
\
index
=
SHOW_UBITS
(
name
gb
bits
)
;
\
code
=
table
[
index
]
.
sym
;
\
n
=
table
[
index
]
.
len
;
\
\
if
(
max_depth
>
1
&
&
n
<
0
)
{
\
LAST_SKIP_BITS
(
name
gb
bits
)
;
\
UPDATE_CACHE
(
name
gb
)
;
\
\
nb_bits
=
-
n
;
\
\
index
=
SHOW_UBITS
(
name
gb
nb_bits
)
+
code
;
\
code
=
table
[
index
]
.
sym
;
\
n
=
table
[
index
]
.
len
;
\
if
(
max_depth
>
2
&
&
n
<
0
)
{
\
LAST_SKIP_BITS
(
name
gb
nb_bits
)
;
\
UPDATE_CACHE
(
name
gb
)
;
\
\
nb_bits
=
-
n
;
\
\
index
=
SHOW_UBITS
(
name
gb
nb_bits
)
+
code
;
\
code
=
table
[
index
]
.
sym
;
\
n
=
table
[
index
]
.
len
;
\
}
\
}
\
SKIP_BITS
(
name
gb
n
)
;
\
}
while
(
0
)
#
define
GET_RL_VLC
(
level
run
name
gb
table
bits
\
max_depth
need_update
)
\
do
{
\
int
n
nb_bits
;
\
unsigned
int
index
;
\
\
index
=
SHOW_UBITS
(
name
gb
bits
)
;
\
level
=
table
[
index
]
.
level
;
\
n
=
table
[
index
]
.
len
;
\
\
if
(
max_depth
>
1
&
&
n
<
0
)
{
\
SKIP_BITS
(
name
gb
bits
)
;
\
if
(
need_update
)
{
\
UPDATE_CACHE
(
name
gb
)
;
\
}
\
\
nb_bits
=
-
n
;
\
\
index
=
SHOW_UBITS
(
name
gb
nb_bits
)
+
level
;
\
level
=
table
[
index
]
.
level
;
\
n
=
table
[
index
]
.
len
;
\
if
(
max_depth
>
2
&
&
n
<
0
)
{
\
LAST_SKIP_BITS
(
name
gb
nb_bits
)
;
\
if
(
need_update
)
{
\
UPDATE_CACHE
(
name
gb
)
;
\
}
\
nb_bits
=
-
n
;
\
\
index
=
SHOW_UBITS
(
name
gb
nb_bits
)
+
level
;
\
level
=
table
[
index
]
.
level
;
\
n
=
table
[
index
]
.
len
;
\
}
\
}
\
run
=
table
[
index
]
.
run
;
\
SKIP_BITS
(
name
gb
n
)
;
\
}
while
(
0
)
static
av_always_inline
int
get_vlc2
(
GetBitContext
*
s
const
VLCElem
*
table
int
bits
int
max_depth
)
{
int
code
;
OPEN_READER
(
re
s
)
;
UPDATE_CACHE
(
re
s
)
;
GET_VLC
(
code
re
s
table
bits
max_depth
)
;
CLOSE_READER
(
re
s
)
;
return
code
;
}
static
inline
int
get_vlc_multi
(
GetBitContext
*
s
uint8_t
*
dst
const
VLC_MULTI_ELEM
*
const
Jtable
const
VLCElem
*
const
table
const
int
bits
const
int
max_depth
)
{
dst
[
0
]
=
get_vlc2
(
s
table
bits
max_depth
)
;
return
1
;
}
static
inline
int
decode012
(
GetBitContext
*
gb
)
{
int
n
;
n
=
get_bits1
(
gb
)
;
if
(
n
=
=
0
)
return
0
;
else
return
get_bits1
(
gb
)
+
1
;
}
static
inline
int
decode210
(
GetBitContext
*
gb
)
{
if
(
get_bits1
(
gb
)
)
return
0
;
else
return
2
-
get_bits1
(
gb
)
;
}
static
inline
int
get_bits_left
(
GetBitContext
*
gb
)
{
return
gb
-
>
size_in_bits
-
get_bits_count
(
gb
)
;
}
static
inline
int
skip_1stop_8data_bits
(
GetBitContext
*
gb
)
{
if
(
get_bits_left
(
gb
)
<
=
0
)
return
AVERROR_INVALIDDATA
;
while
(
get_bits1
(
gb
)
)
{
skip_bits
(
gb
8
)
;
if
(
get_bits_left
(
gb
)
<
=
0
)
return
AVERROR_INVALIDDATA
;
}
return
0
;
}
static
inline
unsigned
get_leb
(
GetBitContext
*
s
)
{
int
more
i
=
0
;
unsigned
leb
=
0
;
do
{
int
byte
=
get_bits
(
s
8
)
;
unsigned
bits
=
byte
&
0x7f
;
more
=
byte
&
0x80
;
if
(
i
<
=
4
)
leb
|
=
bits
<
<
(
i
*
7
)
;
if
(
+
+
i
=
=
8
)
break
;
}
while
(
more
)
;
return
leb
;
}
#
endif
#
endif
