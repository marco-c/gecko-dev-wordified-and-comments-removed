#
ifndef
AVCODEC_AVCODEC_H
#
define
AVCODEC_AVCODEC_H
#
include
<
errno
.
h
>
#
include
"
libavutil
/
samplefmt
.
h
"
#
include
"
libavutil
/
attributes
.
h
"
#
include
"
libavutil
/
avutil
.
h
"
#
include
"
libavutil
/
buffer
.
h
"
#
include
"
libavutil
/
cpu
.
h
"
#
include
"
libavutil
/
channel_layout
.
h
"
#
include
"
libavutil
/
dict
.
h
"
#
include
"
libavutil
/
frame
.
h
"
#
include
"
libavutil
/
log
.
h
"
#
include
"
libavutil
/
pixfmt
.
h
"
#
include
"
libavutil
/
rational
.
h
"
#
include
"
version
.
h
"
enum
AVCodecID
{
AV_CODEC_ID_NONE
AV_CODEC_ID_MPEG1VIDEO
AV_CODEC_ID_MPEG2VIDEO
#
if
FF_API_XVMC
AV_CODEC_ID_MPEG2VIDEO_XVMC
#
endif
AV_CODEC_ID_H261
AV_CODEC_ID_H263
AV_CODEC_ID_RV10
AV_CODEC_ID_RV20
AV_CODEC_ID_MJPEG
AV_CODEC_ID_MJPEGB
AV_CODEC_ID_LJPEG
AV_CODEC_ID_SP5X
AV_CODEC_ID_JPEGLS
AV_CODEC_ID_MPEG4
AV_CODEC_ID_RAWVIDEO
AV_CODEC_ID_MSMPEG4V1
AV_CODEC_ID_MSMPEG4V2
AV_CODEC_ID_MSMPEG4V3
AV_CODEC_ID_WMV1
AV_CODEC_ID_WMV2
AV_CODEC_ID_H263P
AV_CODEC_ID_H263I
AV_CODEC_ID_FLV1
AV_CODEC_ID_SVQ1
AV_CODEC_ID_SVQ3
AV_CODEC_ID_DVVIDEO
AV_CODEC_ID_HUFFYUV
AV_CODEC_ID_CYUV
AV_CODEC_ID_H264
AV_CODEC_ID_INDEO3
AV_CODEC_ID_VP3
AV_CODEC_ID_THEORA
AV_CODEC_ID_ASV1
AV_CODEC_ID_ASV2
AV_CODEC_ID_FFV1
AV_CODEC_ID_4XM
AV_CODEC_ID_VCR1
AV_CODEC_ID_CLJR
AV_CODEC_ID_MDEC
AV_CODEC_ID_ROQ
AV_CODEC_ID_INTERPLAY_VIDEO
AV_CODEC_ID_XAN_WC3
AV_CODEC_ID_XAN_WC4
AV_CODEC_ID_RPZA
AV_CODEC_ID_CINEPAK
AV_CODEC_ID_WS_VQA
AV_CODEC_ID_MSRLE
AV_CODEC_ID_MSVIDEO1
AV_CODEC_ID_IDCIN
AV_CODEC_ID_8BPS
AV_CODEC_ID_SMC
AV_CODEC_ID_FLIC
AV_CODEC_ID_TRUEMOTION1
AV_CODEC_ID_VMDVIDEO
AV_CODEC_ID_MSZH
AV_CODEC_ID_ZLIB
AV_CODEC_ID_QTRLE
AV_CODEC_ID_TSCC
AV_CODEC_ID_ULTI
AV_CODEC_ID_QDRAW
AV_CODEC_ID_VIXL
AV_CODEC_ID_QPEG
AV_CODEC_ID_PNG
AV_CODEC_ID_PPM
AV_CODEC_ID_PBM
AV_CODEC_ID_PGM
AV_CODEC_ID_PGMYUV
AV_CODEC_ID_PAM
AV_CODEC_ID_FFVHUFF
AV_CODEC_ID_RV30
AV_CODEC_ID_RV40
AV_CODEC_ID_VC1
AV_CODEC_ID_WMV3
AV_CODEC_ID_LOCO
AV_CODEC_ID_WNV1
AV_CODEC_ID_AASC
AV_CODEC_ID_INDEO2
AV_CODEC_ID_FRAPS
AV_CODEC_ID_TRUEMOTION2
AV_CODEC_ID_BMP
AV_CODEC_ID_CSCD
AV_CODEC_ID_MMVIDEO
AV_CODEC_ID_ZMBV
AV_CODEC_ID_AVS
AV_CODEC_ID_SMACKVIDEO
AV_CODEC_ID_NUV
AV_CODEC_ID_KMVC
AV_CODEC_ID_FLASHSV
AV_CODEC_ID_CAVS
AV_CODEC_ID_JPEG2000
AV_CODEC_ID_VMNC
AV_CODEC_ID_VP5
AV_CODEC_ID_VP6
AV_CODEC_ID_VP6F
AV_CODEC_ID_TARGA
AV_CODEC_ID_DSICINVIDEO
AV_CODEC_ID_TIERTEXSEQVIDEO
AV_CODEC_ID_TIFF
AV_CODEC_ID_GIF
AV_CODEC_ID_DXA
AV_CODEC_ID_DNXHD
AV_CODEC_ID_THP
AV_CODEC_ID_SGI
AV_CODEC_ID_C93
AV_CODEC_ID_BETHSOFTVID
AV_CODEC_ID_PTX
AV_CODEC_ID_TXD
AV_CODEC_ID_VP6A
AV_CODEC_ID_AMV
AV_CODEC_ID_VB
AV_CODEC_ID_PCX
AV_CODEC_ID_SUNRAST
AV_CODEC_ID_INDEO4
AV_CODEC_ID_INDEO5
AV_CODEC_ID_MIMIC
AV_CODEC_ID_RL2
AV_CODEC_ID_ESCAPE124
AV_CODEC_ID_DIRAC
AV_CODEC_ID_BFI
AV_CODEC_ID_CMV
AV_CODEC_ID_MOTIONPIXELS
AV_CODEC_ID_TGV
AV_CODEC_ID_TGQ
AV_CODEC_ID_TQI
AV_CODEC_ID_AURA
AV_CODEC_ID_AURA2
AV_CODEC_ID_V210X
AV_CODEC_ID_TMV
AV_CODEC_ID_V210
AV_CODEC_ID_DPX
AV_CODEC_ID_MAD
AV_CODEC_ID_FRWU
AV_CODEC_ID_FLASHSV2
AV_CODEC_ID_CDGRAPHICS
AV_CODEC_ID_R210
AV_CODEC_ID_ANM
AV_CODEC_ID_BINKVIDEO
AV_CODEC_ID_IFF_ILBM
#
define
AV_CODEC_ID_IFF_BYTERUN1
AV_CODEC_ID_IFF_ILBM
AV_CODEC_ID_KGV1
AV_CODEC_ID_YOP
AV_CODEC_ID_VP8
AV_CODEC_ID_PICTOR
AV_CODEC_ID_ANSI
AV_CODEC_ID_A64_MULTI
AV_CODEC_ID_A64_MULTI5
AV_CODEC_ID_R10K
AV_CODEC_ID_MXPEG
AV_CODEC_ID_LAGARITH
AV_CODEC_ID_PRORES
AV_CODEC_ID_JV
AV_CODEC_ID_DFA
AV_CODEC_ID_WMV3IMAGE
AV_CODEC_ID_VC1IMAGE
AV_CODEC_ID_UTVIDEO
AV_CODEC_ID_BMV_VIDEO
AV_CODEC_ID_VBLE
AV_CODEC_ID_DXTORY
AV_CODEC_ID_V410
AV_CODEC_ID_XWD
AV_CODEC_ID_CDXL
AV_CODEC_ID_XBM
AV_CODEC_ID_ZEROCODEC
AV_CODEC_ID_MSS1
AV_CODEC_ID_MSA1
AV_CODEC_ID_TSCC2
AV_CODEC_ID_MTS2
AV_CODEC_ID_CLLC
AV_CODEC_ID_MSS2
AV_CODEC_ID_VP9
AV_CODEC_ID_AIC
AV_CODEC_ID_ESCAPE130
AV_CODEC_ID_G2M
AV_CODEC_ID_WEBP
AV_CODEC_ID_HNM4_VIDEO
AV_CODEC_ID_HEVC
#
define
AV_CODEC_ID_H265
AV_CODEC_ID_HEVC
AV_CODEC_ID_FIC
AV_CODEC_ID_ALIAS_PIX
AV_CODEC_ID_BRENDER_PIX
AV_CODEC_ID_PAF_VIDEO
AV_CODEC_ID_EXR
AV_CODEC_ID_VP7
AV_CODEC_ID_SANM
AV_CODEC_ID_SGIRLE
AV_CODEC_ID_MVC1
AV_CODEC_ID_MVC2
AV_CODEC_ID_HQX
AV_CODEC_ID_TDSC
AV_CODEC_ID_HQ_HQA
AV_CODEC_ID_HAP
AV_CODEC_ID_DDS
AV_CODEC_ID_DXV
AV_CODEC_ID_SCREENPRESSO
AV_CODEC_ID_RSCC
AV_CODEC_ID_Y41P
=
0x8000
AV_CODEC_ID_AVRP
AV_CODEC_ID_012V
AV_CODEC_ID_AVUI
AV_CODEC_ID_AYUV
AV_CODEC_ID_TARGA_Y216
AV_CODEC_ID_V308
AV_CODEC_ID_V408
AV_CODEC_ID_YUV4
AV_CODEC_ID_AVRN
AV_CODEC_ID_CPIA
AV_CODEC_ID_XFACE
AV_CODEC_ID_SNOW
AV_CODEC_ID_SMVJPEG
AV_CODEC_ID_APNG
AV_CODEC_ID_DAALA
AV_CODEC_ID_CFHD
AV_CODEC_ID_FIRST_AUDIO
=
0x10000
AV_CODEC_ID_PCM_S16LE
=
0x10000
AV_CODEC_ID_PCM_S16BE
AV_CODEC_ID_PCM_U16LE
AV_CODEC_ID_PCM_U16BE
AV_CODEC_ID_PCM_S8
AV_CODEC_ID_PCM_U8
AV_CODEC_ID_PCM_MULAW
AV_CODEC_ID_PCM_ALAW
AV_CODEC_ID_PCM_S32LE
AV_CODEC_ID_PCM_S32BE
AV_CODEC_ID_PCM_U32LE
AV_CODEC_ID_PCM_U32BE
AV_CODEC_ID_PCM_S24LE
AV_CODEC_ID_PCM_S24BE
AV_CODEC_ID_PCM_U24LE
AV_CODEC_ID_PCM_U24BE
AV_CODEC_ID_PCM_S24DAUD
AV_CODEC_ID_PCM_ZORK
AV_CODEC_ID_PCM_S16LE_PLANAR
AV_CODEC_ID_PCM_DVD
AV_CODEC_ID_PCM_F32BE
AV_CODEC_ID_PCM_F32LE
AV_CODEC_ID_PCM_F64BE
AV_CODEC_ID_PCM_F64LE
AV_CODEC_ID_PCM_BLURAY
AV_CODEC_ID_PCM_LXF
AV_CODEC_ID_S302M
AV_CODEC_ID_PCM_S8_PLANAR
AV_CODEC_ID_PCM_S24LE_PLANAR
AV_CODEC_ID_PCM_S32LE_PLANAR
AV_CODEC_ID_PCM_S16BE_PLANAR
AV_CODEC_ID_ADPCM_IMA_QT
=
0x11000
AV_CODEC_ID_ADPCM_IMA_WAV
AV_CODEC_ID_ADPCM_IMA_DK3
AV_CODEC_ID_ADPCM_IMA_DK4
AV_CODEC_ID_ADPCM_IMA_WS
AV_CODEC_ID_ADPCM_IMA_SMJPEG
AV_CODEC_ID_ADPCM_MS
AV_CODEC_ID_ADPCM_4XM
AV_CODEC_ID_ADPCM_XA
AV_CODEC_ID_ADPCM_ADX
AV_CODEC_ID_ADPCM_EA
AV_CODEC_ID_ADPCM_G726
AV_CODEC_ID_ADPCM_CT
AV_CODEC_ID_ADPCM_SWF
AV_CODEC_ID_ADPCM_YAMAHA
AV_CODEC_ID_ADPCM_SBPRO_4
AV_CODEC_ID_ADPCM_SBPRO_3
AV_CODEC_ID_ADPCM_SBPRO_2
AV_CODEC_ID_ADPCM_THP
AV_CODEC_ID_ADPCM_IMA_AMV
AV_CODEC_ID_ADPCM_EA_R1
AV_CODEC_ID_ADPCM_EA_R3
AV_CODEC_ID_ADPCM_EA_R2
AV_CODEC_ID_ADPCM_IMA_EA_SEAD
AV_CODEC_ID_ADPCM_IMA_EA_EACS
AV_CODEC_ID_ADPCM_EA_XAS
AV_CODEC_ID_ADPCM_EA_MAXIS_XA
AV_CODEC_ID_ADPCM_IMA_ISS
AV_CODEC_ID_ADPCM_G722
AV_CODEC_ID_ADPCM_IMA_APC
AV_CODEC_ID_ADPCM_VIMA
#
if
FF_API_VIMA_DECODER
AV_CODEC_ID_VIMA
=
AV_CODEC_ID_ADPCM_VIMA
#
endif
AV_CODEC_ID_ADPCM_AFC
=
0x11800
AV_CODEC_ID_ADPCM_IMA_OKI
AV_CODEC_ID_ADPCM_DTK
AV_CODEC_ID_ADPCM_IMA_RAD
AV_CODEC_ID_ADPCM_G726LE
AV_CODEC_ID_ADPCM_THP_LE
AV_CODEC_ID_ADPCM_PSX
AV_CODEC_ID_ADPCM_AICA
AV_CODEC_ID_AMR_NB
=
0x12000
AV_CODEC_ID_AMR_WB
AV_CODEC_ID_RA_144
=
0x13000
AV_CODEC_ID_RA_288
AV_CODEC_ID_ROQ_DPCM
=
0x14000
AV_CODEC_ID_INTERPLAY_DPCM
AV_CODEC_ID_XAN_DPCM
AV_CODEC_ID_SOL_DPCM
AV_CODEC_ID_SDX2_DPCM
=
0x14800
AV_CODEC_ID_MP2
=
0x15000
AV_CODEC_ID_MP3
AV_CODEC_ID_AAC
AV_CODEC_ID_AC3
AV_CODEC_ID_DTS
AV_CODEC_ID_VORBIS
AV_CODEC_ID_DVAUDIO
AV_CODEC_ID_WMAV1
AV_CODEC_ID_WMAV2
AV_CODEC_ID_MACE3
AV_CODEC_ID_MACE6
AV_CODEC_ID_VMDAUDIO
AV_CODEC_ID_FLAC
AV_CODEC_ID_MP3ADU
AV_CODEC_ID_MP3ON4
AV_CODEC_ID_SHORTEN
AV_CODEC_ID_ALAC
AV_CODEC_ID_WESTWOOD_SND1
AV_CODEC_ID_GSM
AV_CODEC_ID_QDM2
AV_CODEC_ID_COOK
AV_CODEC_ID_TRUESPEECH
AV_CODEC_ID_TTA
AV_CODEC_ID_SMACKAUDIO
AV_CODEC_ID_QCELP
AV_CODEC_ID_WAVPACK
AV_CODEC_ID_DSICINAUDIO
AV_CODEC_ID_IMC
AV_CODEC_ID_MUSEPACK7
AV_CODEC_ID_MLP
AV_CODEC_ID_GSM_MS
AV_CODEC_ID_ATRAC3
#
if
FF_API_VOXWARE
AV_CODEC_ID_VOXWARE
#
endif
AV_CODEC_ID_APE
AV_CODEC_ID_NELLYMOSER
AV_CODEC_ID_MUSEPACK8
AV_CODEC_ID_SPEEX
AV_CODEC_ID_WMAVOICE
AV_CODEC_ID_WMAPRO
AV_CODEC_ID_WMALOSSLESS
AV_CODEC_ID_ATRAC3P
AV_CODEC_ID_EAC3
AV_CODEC_ID_SIPR
AV_CODEC_ID_MP1
AV_CODEC_ID_TWINVQ
AV_CODEC_ID_TRUEHD
AV_CODEC_ID_MP4ALS
AV_CODEC_ID_ATRAC1
AV_CODEC_ID_BINKAUDIO_RDFT
AV_CODEC_ID_BINKAUDIO_DCT
AV_CODEC_ID_AAC_LATM
AV_CODEC_ID_QDMC
AV_CODEC_ID_CELT
AV_CODEC_ID_G723_1
AV_CODEC_ID_G729
AV_CODEC_ID_8SVX_EXP
AV_CODEC_ID_8SVX_FIB
AV_CODEC_ID_BMV_AUDIO
AV_CODEC_ID_RALF
AV_CODEC_ID_IAC
AV_CODEC_ID_ILBC
AV_CODEC_ID_OPUS
AV_CODEC_ID_COMFORT_NOISE
AV_CODEC_ID_TAK
AV_CODEC_ID_METASOUND
AV_CODEC_ID_PAF_AUDIO
AV_CODEC_ID_ON2AVC
AV_CODEC_ID_DSS_SP
AV_CODEC_ID_FFWAVESYNTH
=
0x15800
AV_CODEC_ID_SONIC
AV_CODEC_ID_SONIC_LS
AV_CODEC_ID_EVRC
AV_CODEC_ID_SMV
AV_CODEC_ID_DSD_LSBF
AV_CODEC_ID_DSD_MSBF
AV_CODEC_ID_DSD_LSBF_PLANAR
AV_CODEC_ID_DSD_MSBF_PLANAR
AV_CODEC_ID_4GV
AV_CODEC_ID_INTERPLAY_ACM
AV_CODEC_ID_XMA1
AV_CODEC_ID_XMA2
AV_CODEC_ID_FIRST_SUBTITLE
=
0x17000
AV_CODEC_ID_DVD_SUBTITLE
=
0x17000
AV_CODEC_ID_DVB_SUBTITLE
AV_CODEC_ID_TEXT
AV_CODEC_ID_XSUB
AV_CODEC_ID_SSA
AV_CODEC_ID_MOV_TEXT
AV_CODEC_ID_HDMV_PGS_SUBTITLE
AV_CODEC_ID_DVB_TELETEXT
AV_CODEC_ID_SRT
AV_CODEC_ID_MICRODVD
=
0x17800
AV_CODEC_ID_EIA_608
AV_CODEC_ID_JACOSUB
AV_CODEC_ID_SAMI
AV_CODEC_ID_REALTEXT
AV_CODEC_ID_STL
AV_CODEC_ID_SUBVIEWER1
AV_CODEC_ID_SUBVIEWER
AV_CODEC_ID_SUBRIP
AV_CODEC_ID_WEBVTT
AV_CODEC_ID_MPL2
AV_CODEC_ID_VPLAYER
AV_CODEC_ID_PJS
AV_CODEC_ID_ASS
AV_CODEC_ID_HDMV_TEXT_SUBTITLE
AV_CODEC_ID_FIRST_UNKNOWN
=
0x18000
AV_CODEC_ID_TTF
=
0x18000
AV_CODEC_ID_BINTEXT
=
0x18800
AV_CODEC_ID_XBIN
AV_CODEC_ID_IDF
AV_CODEC_ID_OTF
AV_CODEC_ID_SMPTE_KLV
AV_CODEC_ID_DVD_NAV
AV_CODEC_ID_TIMED_ID3
AV_CODEC_ID_BIN_DATA
AV_CODEC_ID_PROBE
=
0x19000
AV_CODEC_ID_MPEG2TS
=
0x20000
AV_CODEC_ID_MPEG4SYSTEMS
=
0x20001
AV_CODEC_ID_FFMETADATA
=
0x21000
AV_CODEC_ID_WRAPPED_AVFRAME
=
0x21001
}
;
typedef
struct
AVCodecDescriptor
{
enum
AVCodecID
id
;
enum
AVMediaType
type
;
const
char
*
name
;
const
char
*
long_name
;
int
props
;
const
char
*
const
*
mime_types
;
const
struct
AVProfile
*
profiles
;
}
AVCodecDescriptor
;
#
define
AV_CODEC_PROP_INTRA_ONLY
(
1
<
<
0
)
#
define
AV_CODEC_PROP_LOSSY
(
1
<
<
1
)
#
define
AV_CODEC_PROP_LOSSLESS
(
1
<
<
2
)
#
define
AV_CODEC_PROP_REORDER
(
1
<
<
3
)
#
define
AV_CODEC_PROP_BITMAP_SUB
(
1
<
<
16
)
#
define
AV_CODEC_PROP_TEXT_SUB
(
1
<
<
17
)
#
define
AV_INPUT_BUFFER_PADDING_SIZE
32
#
define
AV_INPUT_BUFFER_MIN_SIZE
16384
#
if
FF_API_WITHOUT_PREFIX
#
define
FF_INPUT_BUFFER_PADDING_SIZE
32
#
define
FF_MIN_BUFFER_SIZE
16384
#
endif
#
if
FF_API_MOTION_EST
enum
Motion_Est_ID
{
ME_ZERO
=
1
ME_FULL
ME_LOG
ME_PHODS
ME_EPZS
ME_X1
ME_HEX
ME_UMH
ME_TESA
ME_ITER
=
50
}
;
#
endif
enum
AVDiscard
{
AVDISCARD_NONE
=
-
16
AVDISCARD_DEFAULT
=
0
AVDISCARD_NONREF
=
8
AVDISCARD_BIDIR
=
16
AVDISCARD_NONINTRA
=
24
AVDISCARD_NONKEY
=
32
AVDISCARD_ALL
=
48
}
;
enum
AVAudioServiceType
{
AV_AUDIO_SERVICE_TYPE_MAIN
=
0
AV_AUDIO_SERVICE_TYPE_EFFECTS
=
1
AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED
=
2
AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED
=
3
AV_AUDIO_SERVICE_TYPE_DIALOGUE
=
4
AV_AUDIO_SERVICE_TYPE_COMMENTARY
=
5
AV_AUDIO_SERVICE_TYPE_EMERGENCY
=
6
AV_AUDIO_SERVICE_TYPE_VOICE_OVER
=
7
AV_AUDIO_SERVICE_TYPE_KARAOKE
=
8
AV_AUDIO_SERVICE_TYPE_NB
}
;
typedef
struct
RcOverride
{
int
start_frame
;
int
end_frame
;
int
qscale
;
float
quality_factor
;
}
RcOverride
;
#
if
FF_API_MAX_BFRAMES
#
define
FF_MAX_B_FRAMES
16
#
endif
#
define
AV_CODEC_FLAG_UNALIGNED
(
1
<
<
0
)
#
define
AV_CODEC_FLAG_QSCALE
(
1
<
<
1
)
#
define
AV_CODEC_FLAG_4MV
(
1
<
<
2
)
#
define
AV_CODEC_FLAG_OUTPUT_CORRUPT
(
1
<
<
3
)
#
define
AV_CODEC_FLAG_QPEL
(
1
<
<
4
)
#
define
AV_CODEC_FLAG_PASS1
(
1
<
<
9
)
#
define
AV_CODEC_FLAG_PASS2
(
1
<
<
10
)
#
define
AV_CODEC_FLAG_LOOP_FILTER
(
1
<
<
11
)
#
define
AV_CODEC_FLAG_GRAY
(
1
<
<
13
)
#
define
AV_CODEC_FLAG_PSNR
(
1
<
<
15
)
#
define
AV_CODEC_FLAG_TRUNCATED
(
1
<
<
16
)
#
define
AV_CODEC_FLAG_INTERLACED_DCT
(
1
<
<
18
)
#
define
AV_CODEC_FLAG_LOW_DELAY
(
1
<
<
19
)
#
define
AV_CODEC_FLAG_GLOBAL_HEADER
(
1
<
<
22
)
#
define
AV_CODEC_FLAG_BITEXACT
(
1
<
<
23
)
#
define
AV_CODEC_FLAG_AC_PRED
(
1
<
<
24
)
#
define
AV_CODEC_FLAG_INTERLACED_ME
(
1
<
<
29
)
#
define
AV_CODEC_FLAG_CLOSED_GOP
(
1U
<
<
31
)
#
define
AV_CODEC_FLAG2_FAST
(
1
<
<
0
)
#
define
AV_CODEC_FLAG2_NO_OUTPUT
(
1
<
<
2
)
#
define
AV_CODEC_FLAG2_LOCAL_HEADER
(
1
<
<
3
)
#
define
AV_CODEC_FLAG2_DROP_FRAME_TIMECODE
(
1
<
<
13
)
#
define
AV_CODEC_FLAG2_CHUNKS
(
1
<
<
15
)
#
define
AV_CODEC_FLAG2_IGNORE_CROP
(
1
<
<
16
)
#
define
AV_CODEC_FLAG2_SHOW_ALL
(
1
<
<
22
)
#
define
AV_CODEC_FLAG2_EXPORT_MVS
(
1
<
<
28
)
#
define
AV_CODEC_FLAG2_SKIP_MANUAL
(
1
<
<
29
)
#
define
AV_CODEC_CAP_DRAW_HORIZ_BAND
(
1
<
<
0
)
#
define
AV_CODEC_CAP_DR1
(
1
<
<
1
)
#
define
AV_CODEC_CAP_TRUNCATED
(
1
<
<
3
)
#
define
AV_CODEC_CAP_DELAY
(
1
<
<
5
)
#
define
AV_CODEC_CAP_SMALL_LAST_FRAME
(
1
<
<
6
)
#
if
FF_API_CAP_VDPAU
#
define
AV_CODEC_CAP_HWACCEL_VDPAU
(
1
<
<
7
)
#
endif
#
define
AV_CODEC_CAP_SUBFRAMES
(
1
<
<
8
)
#
define
AV_CODEC_CAP_EXPERIMENTAL
(
1
<
<
9
)
#
define
AV_CODEC_CAP_CHANNEL_CONF
(
1
<
<
10
)
#
define
AV_CODEC_CAP_FRAME_THREADS
(
1
<
<
12
)
#
define
AV_CODEC_CAP_SLICE_THREADS
(
1
<
<
13
)
#
define
AV_CODEC_CAP_PARAM_CHANGE
(
1
<
<
14
)
#
define
AV_CODEC_CAP_AUTO_THREADS
(
1
<
<
15
)
#
define
AV_CODEC_CAP_VARIABLE_FRAME_SIZE
(
1
<
<
16
)
#
define
AV_CODEC_CAP_INTRA_ONLY
0x40000000
#
define
AV_CODEC_CAP_LOSSLESS
0x80000000
#
if
FF_API_WITHOUT_PREFIX
#
define
CODEC_FLAG_UNALIGNED
AV_CODEC_FLAG_UNALIGNED
#
define
CODEC_FLAG_QSCALE
AV_CODEC_FLAG_QSCALE
#
define
CODEC_FLAG_4MV
AV_CODEC_FLAG_4MV
#
define
CODEC_FLAG_OUTPUT_CORRUPT
AV_CODEC_FLAG_OUTPUT_CORRUPT
#
define
CODEC_FLAG_QPEL
AV_CODEC_FLAG_QPEL
#
if
FF_API_GMC
#
define
CODEC_FLAG_GMC
0x0020
/
/
/
<
Use
GMC
.
#
endif
#
if
FF_API_MV0
#
define
CODEC_FLAG_MV0
0x0040
#
endif
#
if
FF_API_INPUT_PRESERVED
#
define
CODEC_FLAG_INPUT_PRESERVED
0x0100
#
endif
#
define
CODEC_FLAG_PASS1
AV_CODEC_FLAG_PASS1
#
define
CODEC_FLAG_PASS2
AV_CODEC_FLAG_PASS2
#
define
CODEC_FLAG_GRAY
AV_CODEC_FLAG_GRAY
#
if
FF_API_EMU_EDGE
#
define
CODEC_FLAG_EMU_EDGE
0x4000
#
endif
#
define
CODEC_FLAG_PSNR
AV_CODEC_FLAG_PSNR
#
define
CODEC_FLAG_TRUNCATED
AV_CODEC_FLAG_TRUNCATED
#
if
FF_API_NORMALIZE_AQP
#
define
CODEC_FLAG_NORMALIZE_AQP
0x00020000
#
endif
#
define
CODEC_FLAG_INTERLACED_DCT
AV_CODEC_FLAG_INTERLACED_DCT
#
define
CODEC_FLAG_LOW_DELAY
AV_CODEC_FLAG_LOW_DELAY
#
define
CODEC_FLAG_GLOBAL_HEADER
AV_CODEC_FLAG_GLOBAL_HEADER
#
define
CODEC_FLAG_BITEXACT
AV_CODEC_FLAG_BITEXACT
#
define
CODEC_FLAG_AC_PRED
AV_CODEC_FLAG_AC_PRED
#
define
CODEC_FLAG_LOOP_FILTER
AV_CODEC_FLAG_LOOP_FILTER
#
define
CODEC_FLAG_INTERLACED_ME
AV_CODEC_FLAG_INTERLACED_ME
#
define
CODEC_FLAG_CLOSED_GOP
AV_CODEC_FLAG_CLOSED_GOP
#
define
CODEC_FLAG2_FAST
AV_CODEC_FLAG2_FAST
#
define
CODEC_FLAG2_NO_OUTPUT
AV_CODEC_FLAG2_NO_OUTPUT
#
define
CODEC_FLAG2_LOCAL_HEADER
AV_CODEC_FLAG2_LOCAL_HEADER
#
define
CODEC_FLAG2_DROP_FRAME_TIMECODE
AV_CODEC_FLAG2_DROP_FRAME_TIMECODE
#
define
CODEC_FLAG2_IGNORE_CROP
AV_CODEC_FLAG2_IGNORE_CROP
#
define
CODEC_FLAG2_CHUNKS
AV_CODEC_FLAG2_CHUNKS
#
define
CODEC_FLAG2_SHOW_ALL
AV_CODEC_FLAG2_SHOW_ALL
#
define
CODEC_FLAG2_EXPORT_MVS
AV_CODEC_FLAG2_EXPORT_MVS
#
define
CODEC_FLAG2_SKIP_MANUAL
AV_CODEC_FLAG2_SKIP_MANUAL
#
define
CODEC_CAP_DRAW_HORIZ_BAND
AV_CODEC_CAP_DRAW_HORIZ_BAND
/
/
/
<
Decoder
can
use
draw_horiz_band
callback
.
#
define
CODEC_CAP_DR1
AV_CODEC_CAP_DR1
#
define
CODEC_CAP_TRUNCATED
AV_CODEC_CAP_TRUNCATED
#
if
FF_API_XVMC
#
define
CODEC_CAP_HWACCEL
0x0010
#
endif
#
define
CODEC_CAP_DELAY
AV_CODEC_CAP_DELAY
#
define
CODEC_CAP_SMALL_LAST_FRAME
AV_CODEC_CAP_SMALL_LAST_FRAME
#
if
FF_API_CAP_VDPAU
#
define
CODEC_CAP_HWACCEL_VDPAU
AV_CODEC_CAP_HWACCEL_VDPAU
#
endif
#
define
CODEC_CAP_SUBFRAMES
AV_CODEC_CAP_SUBFRAMES
#
define
CODEC_CAP_EXPERIMENTAL
AV_CODEC_CAP_EXPERIMENTAL
#
define
CODEC_CAP_CHANNEL_CONF
AV_CODEC_CAP_CHANNEL_CONF
#
if
FF_API_NEG_LINESIZES
#
define
CODEC_CAP_NEG_LINESIZES
0x0800
#
endif
#
define
CODEC_CAP_FRAME_THREADS
AV_CODEC_CAP_FRAME_THREADS
#
define
CODEC_CAP_SLICE_THREADS
AV_CODEC_CAP_SLICE_THREADS
#
define
CODEC_CAP_PARAM_CHANGE
AV_CODEC_CAP_PARAM_CHANGE
#
define
CODEC_CAP_AUTO_THREADS
AV_CODEC_CAP_AUTO_THREADS
#
define
CODEC_CAP_VARIABLE_FRAME_SIZE
AV_CODEC_CAP_VARIABLE_FRAME_SIZE
#
define
CODEC_CAP_INTRA_ONLY
AV_CODEC_CAP_INTRA_ONLY
#
define
CODEC_CAP_LOSSLESS
AV_CODEC_CAP_LOSSLESS
#
define
HWACCEL_CODEC_CAP_EXPERIMENTAL
0x0200
#
endif
#
if
FF_API_MB_TYPE
#
define
MB_TYPE_INTRA4x4
0x0001
#
define
MB_TYPE_INTRA16x16
0x0002
/
/
FIXME
H
.
264
-
specific
#
define
MB_TYPE_INTRA_PCM
0x0004
/
/
FIXME
H
.
264
-
specific
#
define
MB_TYPE_16x16
0x0008
#
define
MB_TYPE_16x8
0x0010
#
define
MB_TYPE_8x16
0x0020
#
define
MB_TYPE_8x8
0x0040
#
define
MB_TYPE_INTERLACED
0x0080
#
define
MB_TYPE_DIRECT2
0x0100
/
/
FIXME
#
define
MB_TYPE_ACPRED
0x0200
#
define
MB_TYPE_GMC
0x0400
#
define
MB_TYPE_SKIP
0x0800
#
define
MB_TYPE_P0L0
0x1000
#
define
MB_TYPE_P1L0
0x2000
#
define
MB_TYPE_P0L1
0x4000
#
define
MB_TYPE_P1L1
0x8000
#
define
MB_TYPE_L0
(
MB_TYPE_P0L0
|
MB_TYPE_P1L0
)
#
define
MB_TYPE_L1
(
MB_TYPE_P0L1
|
MB_TYPE_P1L1
)
#
define
MB_TYPE_L0L1
(
MB_TYPE_L0
|
MB_TYPE_L1
)
#
define
MB_TYPE_QUANT
0x00010000
#
define
MB_TYPE_CBP
0x00020000
#
endif
typedef
struct
AVPanScan
{
int
id
;
int
width
;
int
height
;
int16_t
position
[
3
]
[
2
]
;
}
AVPanScan
;
typedef
struct
AVCPBProperties
{
int
max_bitrate
;
int
min_bitrate
;
int
avg_bitrate
;
int
buffer_size
;
uint64_t
vbv_delay
;
}
AVCPBProperties
;
#
if
FF_API_QSCALE_TYPE
#
define
FF_QSCALE_TYPE_MPEG1
0
#
define
FF_QSCALE_TYPE_MPEG2
1
#
define
FF_QSCALE_TYPE_H264
2
#
define
FF_QSCALE_TYPE_VP56
3
#
endif
#
define
AV_GET_BUFFER_FLAG_REF
(
1
<
<
0
)
enum
AVPacketSideDataType
{
AV_PKT_DATA_PALETTE
AV_PKT_DATA_NEW_EXTRADATA
AV_PKT_DATA_PARAM_CHANGE
AV_PKT_DATA_H263_MB_INFO
AV_PKT_DATA_REPLAYGAIN
AV_PKT_DATA_DISPLAYMATRIX
AV_PKT_DATA_STEREO3D
AV_PKT_DATA_AUDIO_SERVICE_TYPE
AV_PKT_DATA_QUALITY_STATS
AV_PKT_DATA_FALLBACK_TRACK
AV_PKT_DATA_CPB_PROPERTIES
AV_PKT_DATA_SKIP_SAMPLES
=
70
AV_PKT_DATA_JP_DUALMONO
AV_PKT_DATA_STRINGS_METADATA
AV_PKT_DATA_SUBTITLE_POSITION
AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL
AV_PKT_DATA_WEBVTT_IDENTIFIER
AV_PKT_DATA_WEBVTT_SETTINGS
AV_PKT_DATA_METADATA_UPDATE
}
;
#
define
AV_PKT_DATA_QUALITY_FACTOR
AV_PKT_DATA_QUALITY_STATS
/
/
DEPRECATED
typedef
struct
AVPacketSideData
{
uint8_t
*
data
;
int
size
;
enum
AVPacketSideDataType
type
;
}
AVPacketSideData
;
typedef
struct
AVPacket
{
AVBufferRef
*
buf
;
int64_t
pts
;
int64_t
dts
;
uint8_t
*
data
;
int
size
;
int
stream_index
;
int
flags
;
AVPacketSideData
*
side_data
;
int
side_data_elems
;
int64_t
duration
;
int64_t
pos
;
#
if
FF_API_CONVERGENCE_DURATION
attribute_deprecated
int64_t
convergence_duration
;
#
endif
}
AVPacket
;
#
define
AV_PKT_FLAG_KEY
0x0001
/
/
/
<
The
packet
contains
a
keyframe
#
define
AV_PKT_FLAG_CORRUPT
0x0002
/
/
/
<
The
packet
content
is
corrupted
enum
AVSideDataParamChangeFlags
{
AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT
=
0x0001
AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT
=
0x0002
AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE
=
0x0004
AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS
=
0x0008
}
;
struct
AVCodecInternal
;
enum
AVFieldOrder
{
AV_FIELD_UNKNOWN
AV_FIELD_PROGRESSIVE
AV_FIELD_TT
AV_FIELD_BB
AV_FIELD_TB
AV_FIELD_BT
}
;
typedef
struct
AVCodecContext
{
const
AVClass
*
av_class
;
int
log_level_offset
;
enum
AVMediaType
codec_type
;
const
struct
AVCodec
*
codec
;
#
if
FF_API_CODEC_NAME
attribute_deprecated
char
codec_name
[
32
]
;
#
endif
enum
AVCodecID
codec_id
;
unsigned
int
codec_tag
;
#
if
FF_API_STREAM_CODEC_TAG
attribute_deprecated
unsigned
int
stream_codec_tag
;
#
endif
void
*
priv_data
;
struct
AVCodecInternal
*
internal
;
void
*
opaque
;
int64_t
bit_rate
;
int
bit_rate_tolerance
;
int
global_quality
;
int
compression_level
;
#
define
FF_COMPRESSION_DEFAULT
-
1
int
flags
;
int
flags2
;
uint8_t
*
extradata
;
int
extradata_size
;
AVRational
time_base
;
int
ticks_per_frame
;
int
delay
;
int
width
height
;
int
coded_width
coded_height
;
#
if
FF_API_ASPECT_EXTENDED
#
define
FF_ASPECT_EXTENDED
15
#
endif
int
gop_size
;
enum
AVPixelFormat
pix_fmt
;
#
if
FF_API_MOTION_EST
attribute_deprecated
int
me_method
;
#
endif
void
(
*
draw_horiz_band
)
(
struct
AVCodecContext
*
s
const
AVFrame
*
src
int
offset
[
AV_NUM_DATA_POINTERS
]
int
y
int
type
int
height
)
;
enum
AVPixelFormat
(
*
get_format
)
(
struct
AVCodecContext
*
s
const
enum
AVPixelFormat
*
fmt
)
;
int
max_b_frames
;
float
b_quant_factor
;
#
if
FF_API_RC_STRATEGY
attribute_deprecated
int
rc_strategy
;
#
define
FF_RC_STRATEGY_XVID
1
#
endif
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
b_frame_strategy
;
#
endif
float
b_quant_offset
;
int
has_b_frames
;
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
mpeg_quant
;
#
endif
float
i_quant_factor
;
float
i_quant_offset
;
float
lumi_masking
;
float
temporal_cplx_masking
;
float
spatial_cplx_masking
;
float
p_masking
;
float
dark_masking
;
int
slice_count
;
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
prediction_method
;
#
define
FF_PRED_LEFT
0
#
define
FF_PRED_PLANE
1
#
define
FF_PRED_MEDIAN
2
#
endif
int
*
slice_offset
;
AVRational
sample_aspect_ratio
;
int
me_cmp
;
int
me_sub_cmp
;
int
mb_cmp
;
int
ildct_cmp
;
#
define
FF_CMP_SAD
0
#
define
FF_CMP_SSE
1
#
define
FF_CMP_SATD
2
#
define
FF_CMP_DCT
3
#
define
FF_CMP_PSNR
4
#
define
FF_CMP_BIT
5
#
define
FF_CMP_RD
6
#
define
FF_CMP_ZERO
7
#
define
FF_CMP_VSAD
8
#
define
FF_CMP_VSSE
9
#
define
FF_CMP_NSSE
10
#
define
FF_CMP_W53
11
#
define
FF_CMP_W97
12
#
define
FF_CMP_DCTMAX
13
#
define
FF_CMP_DCT264
14
#
define
FF_CMP_CHROMA
256
int
dia_size
;
int
last_predictor_count
;
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
pre_me
;
#
endif
int
me_pre_cmp
;
int
pre_dia_size
;
int
me_subpel_quality
;
#
if
FF_API_AFD
attribute_deprecated
int
dtg_active_format
;
#
define
FF_DTG_AFD_SAME
8
#
define
FF_DTG_AFD_4_3
9
#
define
FF_DTG_AFD_16_9
10
#
define
FF_DTG_AFD_14_9
11
#
define
FF_DTG_AFD_4_3_SP_14_9
13
#
define
FF_DTG_AFD_16_9_SP_14_9
14
#
define
FF_DTG_AFD_SP_4_3
15
#
endif
int
me_range
;
#
if
FF_API_QUANT_BIAS
attribute_deprecated
int
intra_quant_bias
;
#
define
FF_DEFAULT_QUANT_BIAS
999999
attribute_deprecated
int
inter_quant_bias
;
#
endif
int
slice_flags
;
#
define
SLICE_FLAG_CODED_ORDER
0x0001
/
/
/
<
draw_horiz_band
(
)
is
called
in
coded
order
instead
of
display
#
define
SLICE_FLAG_ALLOW_FIELD
0x0002
/
/
/
<
allow
draw_horiz_band
(
)
with
field
slices
(
MPEG2
field
pics
)
#
define
SLICE_FLAG_ALLOW_PLANE
0x0004
/
/
/
<
allow
draw_horiz_band
(
)
with
1
component
at
a
time
(
SVQ1
)
#
if
FF_API_XVMC
attribute_deprecated
int
xvmc_acceleration
;
#
endif
int
mb_decision
;
#
define
FF_MB_DECISION_SIMPLE
0
/
/
/
<
uses
mb_cmp
#
define
FF_MB_DECISION_BITS
1
/
/
/
<
chooses
the
one
which
needs
the
fewest
bits
#
define
FF_MB_DECISION_RD
2
/
/
/
<
rate
distortion
uint16_t
*
intra_matrix
;
uint16_t
*
inter_matrix
;
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
scenechange_threshold
;
attribute_deprecated
int
noise_reduction
;
#
endif
#
if
FF_API_MPV_OPT
attribute_deprecated
int
me_threshold
;
attribute_deprecated
int
mb_threshold
;
#
endif
int
intra_dc_precision
;
int
skip_top
;
int
skip_bottom
;
#
if
FF_API_MPV_OPT
attribute_deprecated
float
border_masking
;
#
endif
int
mb_lmin
;
int
mb_lmax
;
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
me_penalty_compensation
;
#
endif
int
bidir_refine
;
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
brd_scale
;
#
endif
int
keyint_min
;
int
refs
;
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
chromaoffset
;
#
endif
#
if
FF_API_UNUSED_MEMBERS
attribute_deprecated
int
scenechange_factor
;
#
endif
int
mv0_threshold
;
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
b_sensitivity
;
#
endif
enum
AVColorPrimaries
color_primaries
;
enum
AVColorTransferCharacteristic
color_trc
;
enum
AVColorSpace
colorspace
;
enum
AVColorRange
color_range
;
enum
AVChromaLocation
chroma_sample_location
;
int
slices
;
enum
AVFieldOrder
field_order
;
int
sample_rate
;
int
channels
;
enum
AVSampleFormat
sample_fmt
;
int
frame_size
;
int
frame_number
;
int
block_align
;
int
cutoff
;
uint64_t
channel_layout
;
uint64_t
request_channel_layout
;
enum
AVAudioServiceType
audio_service_type
;
enum
AVSampleFormat
request_sample_fmt
;
int
(
*
get_buffer2
)
(
struct
AVCodecContext
*
s
AVFrame
*
frame
int
flags
)
;
int
refcounted_frames
;
float
qcompress
;
float
qblur
;
int
qmin
;
int
qmax
;
int
max_qdiff
;
#
if
FF_API_MPV_OPT
attribute_deprecated
float
rc_qsquish
;
attribute_deprecated
float
rc_qmod_amp
;
attribute_deprecated
int
rc_qmod_freq
;
#
endif
int
rc_buffer_size
;
int
rc_override_count
;
RcOverride
*
rc_override
;
#
if
FF_API_MPV_OPT
attribute_deprecated
const
char
*
rc_eq
;
#
endif
int64_t
rc_max_rate
;
int64_t
rc_min_rate
;
#
if
FF_API_MPV_OPT
attribute_deprecated
float
rc_buffer_aggressivity
;
attribute_deprecated
float
rc_initial_cplx
;
#
endif
float
rc_max_available_vbv_use
;
float
rc_min_vbv_overflow_use
;
int
rc_initial_buffer_occupancy
;
#
if
FF_API_CODER_TYPE
#
define
FF_CODER_TYPE_VLC
0
#
define
FF_CODER_TYPE_AC
1
#
define
FF_CODER_TYPE_RAW
2
#
define
FF_CODER_TYPE_RLE
3
#
if
FF_API_UNUSED_MEMBERS
#
define
FF_CODER_TYPE_DEFLATE
4
#
endif
attribute_deprecated
int
coder_type
;
#
endif
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
context_model
;
#
endif
#
if
FF_API_MPV_OPT
attribute_deprecated
int
lmin
;
attribute_deprecated
int
lmax
;
#
endif
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
frame_skip_threshold
;
attribute_deprecated
int
frame_skip_factor
;
attribute_deprecated
int
frame_skip_exp
;
attribute_deprecated
int
frame_skip_cmp
;
#
endif
int
trellis
;
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
min_prediction_order
;
attribute_deprecated
int
max_prediction_order
;
attribute_deprecated
int64_t
timecode_frame_start
;
#
endif
#
if
FF_API_RTP_CALLBACK
attribute_deprecated
void
(
*
rtp_callback
)
(
struct
AVCodecContext
*
avctx
void
*
data
int
size
int
mb_nb
)
;
#
endif
#
if
FF_API_PRIVATE_OPT
attribute_deprecated
int
rtp_payload_size
;
#
endif
#
if
FF_API_STAT_BITS
attribute_deprecated
int
mv_bits
;
attribute_deprecated
int
header_bits
;
attribute_deprecated
int
i_tex_bits
;
attribute_deprecated
int
p_tex_bits
;
attribute_deprecated
int
i_count
;
attribute_deprecated
int
p_count
;
attribute_deprecated
int
skip_count
;
attribute_deprecated
int
misc_bits
;
attribute_deprecated
int
frame_bits
;
#
endif
char
*
stats_out
;
char
*
stats_in
;
int
workaround_bugs
;
#
define
FF_BUG_AUTODETECT
1
/
/
/
<
autodetection
#
if
FF_API_OLD_MSMPEG4
#
define
FF_BUG_OLD_MSMPEG4
2
#
endif
#
define
FF_BUG_XVID_ILACE
4
#
define
FF_BUG_UMP4
8
#
define
FF_BUG_NO_PADDING
16
#
define
FF_BUG_AMV
32
#
if
FF_API_AC_VLC
#
define
FF_BUG_AC_VLC
0
/
/
/
<
Will
be
removed
libavcodec
can
now
handle
these
non
-
compliant
files
by
default
.
#
endif
#
define
FF_BUG_QPEL_CHROMA
64
#
define
FF_BUG_STD_QPEL
128
#
define
FF_BUG_QPEL_CHROMA2
256
#
define
FF_BUG_DIRECT_BLOCKSIZE
512
#
define
FF_BUG_EDGE
1024
#
define
FF_BUG_HPEL_CHROMA
2048
#
define
FF_BUG_DC_CLIP
4096
#
define
FF_BUG_MS
8192
/
/
/
<
Work
around
various
bugs
in
Microsoft
'
s
broken
decoders
.
#
define
FF_BUG_TRUNCATED
16384
int
strict_std_compliance
;
#
define
FF_COMPLIANCE_VERY_STRICT
2
/
/
/
<
Strictly
conform
to
an
older
more
strict
version
of
the
spec
or
reference
software
.
#
define
FF_COMPLIANCE_STRICT
1
/
/
/
<
Strictly
conform
to
all
the
things
in
the
spec
no
matter
what
consequences
.
#
define
FF_COMPLIANCE_NORMAL
0
#
define
FF_COMPLIANCE_UNOFFICIAL
-
1
/
/
/
<
Allow
unofficial
extensions
#
define
FF_COMPLIANCE_EXPERIMENTAL
-
2
/
/
/
<
Allow
nonstandardized
experimental
things
.
int
error_concealment
;
#
define
FF_EC_GUESS_MVS
1
#
define
FF_EC_DEBLOCK
2
#
define
FF_EC_FAVOR_INTER
256
int
debug
;
#
define
FF_DEBUG_PICT_INFO
1
#
define
FF_DEBUG_RC
2
#
define
FF_DEBUG_BITSTREAM
4
#
define
FF_DEBUG_MB_TYPE
8
#
define
FF_DEBUG_QP
16
#
if
FF_API_DEBUG_MV
#
define
FF_DEBUG_MV
32
#
endif
#
define
FF_DEBUG_DCT_COEFF
0x00000040
#
define
FF_DEBUG_SKIP
0x00000080
#
define
FF_DEBUG_STARTCODE
0x00000100
#
if
FF_API_UNUSED_MEMBERS
#
define
FF_DEBUG_PTS
0x00000200
#
endif
#
define
FF_DEBUG_ER
0x00000400
#
define
FF_DEBUG_MMCO
0x00000800
#
define
FF_DEBUG_BUGS
0x00001000
#
if
FF_API_DEBUG_MV
#
define
FF_DEBUG_VIS_QP
0x00002000
/
/
/
<
only
access
through
AVOptions
from
outside
libavcodec
#
define
FF_DEBUG_VIS_MB_TYPE
0x00004000
/
/
/
<
only
access
through
AVOptions
from
outside
libavcodec
#
endif
#
define
FF_DEBUG_BUFFERS
0x00008000
#
define
FF_DEBUG_THREADS
0x00010000
#
define
FF_DEBUG_GREEN_MD
0x00800000
#
define
FF_DEBUG_NOMC
0x01000000
#
if
FF_API_DEBUG_MV
int
debug_mv
;
#
define
FF_DEBUG_VIS_MV_P_FOR
0x00000001
/
/
visualize
forward
predicted
MVs
of
P
frames
#
define
FF_DEBUG_VIS_MV_B_FOR
0x00000002
/
/
visualize
forward
predicted
MVs
of
B
frames
#
define
FF_DEBUG_VIS_MV_B_BACK
0x00000004
/
/
visualize
backward
predicted
MVs
of
B
frames
#
endif
int
err_recognition
;
#
define
AV_EF_CRCCHECK
(
1
<
<
0
)
#
define
AV_EF_BITSTREAM
(
1
<
<
1
)
/
/
/
<
detect
bitstream
specification
deviations
#
define
AV_EF_BUFFER
(
1
<
<
2
)
/
/
/
<
detect
improper
bitstream
length
#
define
AV_EF_EXPLODE
(
1
<
<
3
)
/
/
/
<
abort
decoding
on
minor
error
detection
#
define
AV_EF_IGNORE_ERR
(
1
<
<
15
)
/
/
/
<
ignore
errors
and
continue
#
define
AV_EF_CAREFUL
(
1
<
<
16
)
/
/
/
<
consider
things
that
violate
the
spec
are
fast
to
calculate
and
have
not
been
seen
in
the
wild
as
errors
#
define
AV_EF_COMPLIANT
(
1
<
<
17
)
/
/
/
<
consider
all
spec
non
compliances
as
errors
#
define
AV_EF_AGGRESSIVE
(
1
<
<
18
)
/
/
/
<
consider
things
that
a
sane
encoder
should
not
do
as
an
error
int64_t
reordered_opaque
;
struct
AVHWAccel
*
hwaccel
;
void
*
hwaccel_context
;
uint64_t
error
[
AV_NUM_DATA_POINTERS
]
;
int
dct_algo
;
#
define
FF_DCT_AUTO
0
#
define
FF_DCT_FASTINT
1
#
define
FF_DCT_INT
2
#
define
FF_DCT_MMX
3
#
define
FF_DCT_ALTIVEC
5
#
define
FF_DCT_FAAN
6
int
idct_algo
;
#
define
FF_IDCT_AUTO
0
#
define
FF_IDCT_INT
1
#
define
FF_IDCT_SIMPLE
2
#
define
FF_IDCT_SIMPLEMMX
3
#
define
FF_IDCT_ARM
7
#
define
FF_IDCT_ALTIVEC
8
#
if
FF_API_ARCH_SH4
#
define
FF_IDCT_SH4
9
#
endif
#
define
FF_IDCT_SIMPLEARM
10
#
if
FF_API_UNUSED_MEMBERS
#
define
FF_IDCT_IPP
13
#
endif
#
define
FF_IDCT_XVID
14
#
if
FF_API_IDCT_XVIDMMX
#
define
FF_IDCT_XVIDMMX
14
#
endif
#
define
FF_IDCT_SIMPLEARMV5TE
16
#
define
FF_IDCT_SIMPLEARMV6
17
#
if
FF_API_ARCH_SPARC
#
define
FF_IDCT_SIMPLEVIS
18
#
endif
#
define
FF_IDCT_FAAN
20
#
define
FF_IDCT_SIMPLENEON
22
#
if
FF_API_ARCH_ALPHA
#
define
FF_IDCT_SIMPLEALPHA
23
#
endif
#
define
FF_IDCT_SIMPLEAUTO
128
int
bits_per_coded_sample
;
int
bits_per_raw_sample
;
#
if
FF_API_LOWRES
int
lowres
;
#
endif
#
if
FF_API_CODED_FRAME
attribute_deprecated
AVFrame
*
coded_frame
;
#
endif
int
thread_count
;
int
thread_type
;
#
define
FF_THREAD_FRAME
1
/
/
/
<
Decode
more
than
one
frame
at
once
#
define
FF_THREAD_SLICE
2
/
/
/
<
Decode
more
than
one
part
of
a
single
frame
at
once
int
active_thread_type
;
int
thread_safe_callbacks
;
int
(
*
execute
)
(
struct
AVCodecContext
*
c
int
(
*
func
)
(
struct
AVCodecContext
*
c2
void
*
arg
)
void
*
arg2
int
*
ret
int
count
int
size
)
;
int
(
*
execute2
)
(
struct
AVCodecContext
*
c
int
(
*
func
)
(
struct
AVCodecContext
*
c2
void
*
arg
int
jobnr
int
threadnr
)
void
*
arg2
int
*
ret
int
count
)
;
int
nsse_weight
;
int
profile
;
#
define
FF_PROFILE_UNKNOWN
-
99
#
define
FF_PROFILE_RESERVED
-
100
#
define
FF_PROFILE_AAC_MAIN
0
#
define
FF_PROFILE_AAC_LOW
1
#
define
FF_PROFILE_AAC_SSR
2
#
define
FF_PROFILE_AAC_LTP
3
#
define
FF_PROFILE_AAC_HE
4
#
define
FF_PROFILE_AAC_HE_V2
28
#
define
FF_PROFILE_AAC_LD
22
#
define
FF_PROFILE_AAC_ELD
38
#
define
FF_PROFILE_MPEG2_AAC_LOW
128
#
define
FF_PROFILE_MPEG2_AAC_HE
131
#
define
FF_PROFILE_DTS
20
#
define
FF_PROFILE_DTS_ES
30
#
define
FF_PROFILE_DTS_96_24
40
#
define
FF_PROFILE_DTS_HD_HRA
50
#
define
FF_PROFILE_DTS_HD_MA
60
#
define
FF_PROFILE_DTS_EXPRESS
70
#
define
FF_PROFILE_MPEG2_422
0
#
define
FF_PROFILE_MPEG2_HIGH
1
#
define
FF_PROFILE_MPEG2_SS
2
#
define
FF_PROFILE_MPEG2_SNR_SCALABLE
3
#
define
FF_PROFILE_MPEG2_MAIN
4
#
define
FF_PROFILE_MPEG2_SIMPLE
5
#
define
FF_PROFILE_H264_CONSTRAINED
(
1
<
<
9
)
/
/
8
+
1
;
constraint_set1_flag
#
define
FF_PROFILE_H264_INTRA
(
1
<
<
11
)
/
/
8
+
3
;
constraint_set3_flag
#
define
FF_PROFILE_H264_BASELINE
66
#
define
FF_PROFILE_H264_CONSTRAINED_BASELINE
(
66
|
FF_PROFILE_H264_CONSTRAINED
)
#
define
FF_PROFILE_H264_MAIN
77
#
define
FF_PROFILE_H264_EXTENDED
88
#
define
FF_PROFILE_H264_HIGH
100
#
define
FF_PROFILE_H264_HIGH_10
110
#
define
FF_PROFILE_H264_HIGH_10_INTRA
(
110
|
FF_PROFILE_H264_INTRA
)
#
define
FF_PROFILE_H264_HIGH_422
122
#
define
FF_PROFILE_H264_HIGH_422_INTRA
(
122
|
FF_PROFILE_H264_INTRA
)
#
define
FF_PROFILE_H264_HIGH_444
144
#
define
FF_PROFILE_H264_HIGH_444_PREDICTIVE
244
#
define
FF_PROFILE_H264_HIGH_444_INTRA
(
244
|
FF_PROFILE_H264_INTRA
)
#
define
FF_PROFILE_H264_CAVLC_444
44
#
define
FF_PROFILE_VC1_SIMPLE
0
#
define
FF_PROFILE_VC1_MAIN
1
#
define
FF_PROFILE_VC1_COMPLEX
2
#
define
FF_PROFILE_VC1_ADVANCED
3
#
define
FF_PROFILE_MPEG4_SIMPLE
0
#
define
FF_PROFILE_MPEG4_SIMPLE_SCALABLE
1
#
define
FF_PROFILE_MPEG4_CORE
2
#
define
FF_PROFILE_MPEG4_MAIN
3
#
define
FF_PROFILE_MPEG4_N_BIT
4
#
define
FF_PROFILE_MPEG4_SCALABLE_TEXTURE
5
#
define
FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION
6
#
define
FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE
7
#
define
FF_PROFILE_MPEG4_HYBRID
8
#
define
FF_PROFILE_MPEG4_ADVANCED_REAL_TIME
9
#
define
FF_PROFILE_MPEG4_CORE_SCALABLE
10
#
define
FF_PROFILE_MPEG4_ADVANCED_CODING
11
#
define
FF_PROFILE_MPEG4_ADVANCED_CORE
12
#
define
FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE
13
#
define
FF_PROFILE_MPEG4_SIMPLE_STUDIO
14
#
define
FF_PROFILE_MPEG4_ADVANCED_SIMPLE
15
#
define
FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0
0
#
define
FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1
1
#
define
FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION
2
#
define
FF_PROFILE_JPEG2000_DCINEMA_2K
3
#
define
FF_PROFILE_JPEG2000_DCINEMA_4K
4
#
define
FF_PROFILE_VP9_0
0
#
define
FF_PROFILE_VP9_1
1
#
define
FF_PROFILE_VP9_2
2
#
define
FF_PROFILE_VP9_3
3
#
define
FF_PROFILE_HEVC_MAIN
1
#
define
FF_PROFILE_HEVC_MAIN_10
2
#
define
FF_PROFILE_HEVC_MAIN_STILL_PICTURE
3
#
define
FF_PROFILE_HEVC_REXT
4
int
level
;
#
define
FF_LEVEL_UNKNOWN
-
99
enum
AVDiscard
skip_loop_filter
;
enum
AVDiscard
skip_idct
;
enum
AVDiscard
skip_frame
;
uint8_t
*
subtitle_header
;
int
subtitle_header_size
;
#
if
FF_API_ERROR_RATE
attribute_deprecated
int
error_rate
;
#
endif
#
if
FF_API_VBV_DELAY
attribute_deprecated
uint64_t
vbv_delay
;
#
endif
#
if
FF_API_SIDEDATA_ONLY_PKT
attribute_deprecated
int
side_data_only_packets
;
#
endif
int
initial_padding
;
AVRational
framerate
;
enum
AVPixelFormat
sw_pix_fmt
;
AVRational
pkt_timebase
;
const
AVCodecDescriptor
*
codec_descriptor
;
#
if
!
FF_API_LOWRES
int
lowres
;
#
endif
int64_t
pts_correction_num_faulty_pts
;
int64_t
pts_correction_num_faulty_dts
;
int64_t
pts_correction_last_pts
;
int64_t
pts_correction_last_dts
;
char
*
sub_charenc
;
int
sub_charenc_mode
;
#
define
FF_SUB_CHARENC_MODE_DO_NOTHING
-
1
/
/
/
<
do
nothing
(
demuxer
outputs
a
stream
supposed
to
be
already
in
UTF
-
8
or
the
codec
is
bitmap
for
instance
)
#
define
FF_SUB_CHARENC_MODE_AUTOMATIC
0
/
/
/
<
libavcodec
will
select
the
mode
itself
#
define
FF_SUB_CHARENC_MODE_PRE_DECODER
1
/
/
/
<
the
AVPacket
data
needs
to
be
recoded
to
UTF
-
8
before
being
fed
to
the
decoder
requires
iconv
int
skip_alpha
;
int
seek_preroll
;
#
if
!
FF_API_DEBUG_MV
int
debug_mv
;
#
define
FF_DEBUG_VIS_MV_P_FOR
0x00000001
/
/
visualize
forward
predicted
MVs
of
P
frames
#
define
FF_DEBUG_VIS_MV_B_FOR
0x00000002
/
/
visualize
forward
predicted
MVs
of
B
frames
#
define
FF_DEBUG_VIS_MV_B_BACK
0x00000004
/
/
visualize
backward
predicted
MVs
of
B
frames
#
endif
uint16_t
*
chroma_intra_matrix
;
uint8_t
*
dump_separator
;
char
*
codec_whitelist
;
unsigned
properties
;
#
define
FF_CODEC_PROPERTY_LOSSLESS
0x00000001
#
define
FF_CODEC_PROPERTY_CLOSED_CAPTIONS
0x00000002
AVPacketSideData
*
coded_side_data
;
int
nb_coded_side_data
;
}
AVCodecContext
;
AVRational
av_codec_get_pkt_timebase
(
const
AVCodecContext
*
avctx
)
;
void
av_codec_set_pkt_timebase
(
AVCodecContext
*
avctx
AVRational
val
)
;
const
AVCodecDescriptor
*
av_codec_get_codec_descriptor
(
const
AVCodecContext
*
avctx
)
;
void
av_codec_set_codec_descriptor
(
AVCodecContext
*
avctx
const
AVCodecDescriptor
*
desc
)
;
unsigned
av_codec_get_codec_properties
(
const
AVCodecContext
*
avctx
)
;
int
av_codec_get_lowres
(
const
AVCodecContext
*
avctx
)
;
void
av_codec_set_lowres
(
AVCodecContext
*
avctx
int
val
)
;
int
av_codec_get_seek_preroll
(
const
AVCodecContext
*
avctx
)
;
void
av_codec_set_seek_preroll
(
AVCodecContext
*
avctx
int
val
)
;
uint16_t
*
av_codec_get_chroma_intra_matrix
(
const
AVCodecContext
*
avctx
)
;
void
av_codec_set_chroma_intra_matrix
(
AVCodecContext
*
avctx
uint16_t
*
val
)
;
typedef
struct
AVProfile
{
int
profile
;
const
char
*
name
;
}
AVProfile
;
typedef
struct
AVCodecDefault
AVCodecDefault
;
struct
AVSubtitle
;
typedef
struct
AVCodec
{
const
char
*
name
;
const
char
*
long_name
;
enum
AVMediaType
type
;
enum
AVCodecID
id
;
int
capabilities
;
const
AVRational
*
supported_framerates
;
const
enum
AVPixelFormat
*
pix_fmts
;
const
int
*
supported_samplerates
;
const
enum
AVSampleFormat
*
sample_fmts
;
const
uint64_t
*
channel_layouts
;
uint8_t
max_lowres
;
const
AVClass
*
priv_class
;
const
AVProfile
*
profiles
;
int
priv_data_size
;
struct
AVCodec
*
next
;
int
(
*
init_thread_copy
)
(
AVCodecContext
*
)
;
int
(
*
update_thread_context
)
(
AVCodecContext
*
dst
const
AVCodecContext
*
src
)
;
const
AVCodecDefault
*
defaults
;
void
(
*
init_static_data
)
(
struct
AVCodec
*
codec
)
;
int
(
*
init
)
(
AVCodecContext
*
)
;
int
(
*
encode_sub
)
(
AVCodecContext
*
uint8_t
*
buf
int
buf_size
const
struct
AVSubtitle
*
sub
)
;
int
(
*
encode2
)
(
AVCodecContext
*
avctx
AVPacket
*
avpkt
const
AVFrame
*
frame
int
*
got_packet_ptr
)
;
int
(
*
decode
)
(
AVCodecContext
*
void
*
outdata
int
*
outdata_size
AVPacket
*
avpkt
)
;
int
(
*
close
)
(
AVCodecContext
*
)
;
void
(
*
flush
)
(
AVCodecContext
*
)
;
int
caps_internal
;
}
AVCodec
;
int
av_codec_get_max_lowres
(
const
AVCodec
*
codec
)
;
struct
MpegEncContext
;
typedef
struct
AVHWAccel
{
const
char
*
name
;
enum
AVMediaType
type
;
enum
AVCodecID
id
;
enum
AVPixelFormat
pix_fmt
;
int
capabilities
;
struct
AVHWAccel
*
next
;
int
(
*
alloc_frame
)
(
AVCodecContext
*
avctx
AVFrame
*
frame
)
;
int
(
*
start_frame
)
(
AVCodecContext
*
avctx
const
uint8_t
*
buf
uint32_t
buf_size
)
;
int
(
*
decode_slice
)
(
AVCodecContext
*
avctx
const
uint8_t
*
buf
uint32_t
buf_size
)
;
int
(
*
end_frame
)
(
AVCodecContext
*
avctx
)
;
int
frame_priv_data_size
;
void
(
*
decode_mb
)
(
struct
MpegEncContext
*
s
)
;
int
(
*
init
)
(
AVCodecContext
*
avctx
)
;
int
(
*
uninit
)
(
AVCodecContext
*
avctx
)
;
int
priv_data_size
;
}
AVHWAccel
;
#
define
AV_HWACCEL_FLAG_IGNORE_LEVEL
(
1
<
<
0
)
#
define
AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH
(
1
<
<
1
)
#
if
FF_API_AVPICTURE
typedef
struct
AVPicture
{
attribute_deprecated
uint8_t
*
data
[
AV_NUM_DATA_POINTERS
]
;
attribute_deprecated
int
linesize
[
AV_NUM_DATA_POINTERS
]
;
}
AVPicture
;
#
endif
enum
AVSubtitleType
{
SUBTITLE_NONE
SUBTITLE_BITMAP
SUBTITLE_TEXT
SUBTITLE_ASS
}
;
#
define
AV_SUBTITLE_FLAG_FORCED
0x00000001
typedef
struct
AVSubtitleRect
{
int
x
;
int
y
;
int
w
;
int
h
;
int
nb_colors
;
#
if
FF_API_AVPICTURE
attribute_deprecated
AVPicture
pict
;
#
endif
uint8_t
*
data
[
4
]
;
int
linesize
[
4
]
;
enum
AVSubtitleType
type
;
char
*
text
;
char
*
ass
;
int
flags
;
}
AVSubtitleRect
;
typedef
struct
AVSubtitle
{
uint16_t
format
;
uint32_t
start_display_time
;
uint32_t
end_display_time
;
unsigned
num_rects
;
AVSubtitleRect
*
*
rects
;
int64_t
pts
;
}
AVSubtitle
;
AVCodec
*
av_codec_next
(
const
AVCodec
*
c
)
;
unsigned
avcodec_version
(
void
)
;
const
char
*
avcodec_configuration
(
void
)
;
const
char
*
avcodec_license
(
void
)
;
void
avcodec_register
(
AVCodec
*
codec
)
;
void
avcodec_register_all
(
void
)
;
AVCodecContext
*
avcodec_alloc_context3
(
const
AVCodec
*
codec
)
;
void
avcodec_free_context
(
AVCodecContext
*
*
avctx
)
;
int
avcodec_get_context_defaults3
(
AVCodecContext
*
s
const
AVCodec
*
codec
)
;
const
AVClass
*
avcodec_get_class
(
void
)
;
const
AVClass
*
avcodec_get_frame_class
(
void
)
;
const
AVClass
*
avcodec_get_subtitle_rect_class
(
void
)
;
int
avcodec_copy_context
(
AVCodecContext
*
dest
const
AVCodecContext
*
src
)
;
int
avcodec_open2
(
AVCodecContext
*
avctx
const
AVCodec
*
codec
AVDictionary
*
*
options
)
;
int
avcodec_close
(
AVCodecContext
*
avctx
)
;
void
avsubtitle_free
(
AVSubtitle
*
sub
)
;
AVPacket
*
av_packet_alloc
(
void
)
;
AVPacket
*
av_packet_clone
(
AVPacket
*
src
)
;
void
av_packet_free
(
AVPacket
*
*
pkt
)
;
void
av_init_packet
(
AVPacket
*
pkt
)
;
int
av_new_packet
(
AVPacket
*
pkt
int
size
)
;
void
av_shrink_packet
(
AVPacket
*
pkt
int
size
)
;
int
av_grow_packet
(
AVPacket
*
pkt
int
grow_by
)
;
int
av_packet_from_data
(
AVPacket
*
pkt
uint8_t
*
data
int
size
)
;
#
if
FF_API_AVPACKET_OLD_API
attribute_deprecated
int
av_dup_packet
(
AVPacket
*
pkt
)
;
int
av_copy_packet
(
AVPacket
*
dst
const
AVPacket
*
src
)
;
int
av_copy_packet_side_data
(
AVPacket
*
dst
const
AVPacket
*
src
)
;
attribute_deprecated
void
av_free_packet
(
AVPacket
*
pkt
)
;
#
endif
uint8_t
*
av_packet_new_side_data
(
AVPacket
*
pkt
enum
AVPacketSideDataType
type
int
size
)
;
int
av_packet_add_side_data
(
AVPacket
*
pkt
enum
AVPacketSideDataType
type
uint8_t
*
data
size_t
size
)
;
int
av_packet_shrink_side_data
(
AVPacket
*
pkt
enum
AVPacketSideDataType
type
int
size
)
;
uint8_t
*
av_packet_get_side_data
(
AVPacket
*
pkt
enum
AVPacketSideDataType
type
int
*
size
)
;
int
av_packet_merge_side_data
(
AVPacket
*
pkt
)
;
int
av_packet_split_side_data
(
AVPacket
*
pkt
)
;
const
char
*
av_packet_side_data_name
(
enum
AVPacketSideDataType
type
)
;
uint8_t
*
av_packet_pack_dictionary
(
AVDictionary
*
dict
int
*
size
)
;
int
av_packet_unpack_dictionary
(
const
uint8_t
*
data
int
size
AVDictionary
*
*
dict
)
;
void
av_packet_free_side_data
(
AVPacket
*
pkt
)
;
int
av_packet_ref
(
AVPacket
*
dst
const
AVPacket
*
src
)
;
void
av_packet_unref
(
AVPacket
*
pkt
)
;
void
av_packet_move_ref
(
AVPacket
*
dst
AVPacket
*
src
)
;
int
av_packet_copy_props
(
AVPacket
*
dst
const
AVPacket
*
src
)
;
void
av_packet_rescale_ts
(
AVPacket
*
pkt
AVRational
tb_src
AVRational
tb_dst
)
;
AVCodec
*
avcodec_find_decoder
(
enum
AVCodecID
id
)
;
AVCodec
*
avcodec_find_decoder_by_name
(
const
char
*
name
)
;
int
avcodec_default_get_buffer2
(
AVCodecContext
*
s
AVFrame
*
frame
int
flags
)
;
#
if
FF_API_EMU_EDGE
attribute_deprecated
unsigned
avcodec_get_edge_width
(
void
)
;
#
endif
void
avcodec_align_dimensions
(
AVCodecContext
*
s
int
*
width
int
*
height
)
;
void
avcodec_align_dimensions2
(
AVCodecContext
*
s
int
*
width
int
*
height
int
linesize_align
[
AV_NUM_DATA_POINTERS
]
)
;
int
avcodec_enum_to_chroma_pos
(
int
*
xpos
int
*
ypos
enum
AVChromaLocation
pos
)
;
enum
AVChromaLocation
avcodec_chroma_pos_to_enum
(
int
xpos
int
ypos
)
;
int
avcodec_decode_audio4
(
AVCodecContext
*
avctx
AVFrame
*
frame
int
*
got_frame_ptr
const
AVPacket
*
avpkt
)
;
int
avcodec_decode_video2
(
AVCodecContext
*
avctx
AVFrame
*
picture
int
*
got_picture_ptr
const
AVPacket
*
avpkt
)
;
int
avcodec_decode_subtitle2
(
AVCodecContext
*
avctx
AVSubtitle
*
sub
int
*
got_sub_ptr
AVPacket
*
avpkt
)
;
enum
AVPictureStructure
{
AV_PICTURE_STRUCTURE_UNKNOWN
AV_PICTURE_STRUCTURE_TOP_FIELD
AV_PICTURE_STRUCTURE_BOTTOM_FIELD
AV_PICTURE_STRUCTURE_FRAME
}
;
typedef
struct
AVCodecParserContext
{
void
*
priv_data
;
struct
AVCodecParser
*
parser
;
int64_t
frame_offset
;
int64_t
cur_offset
;
int64_t
next_frame_offset
;
int
pict_type
;
int
repeat_pict
;
int64_t
pts
;
int64_t
dts
;
int64_t
last_pts
;
int64_t
last_dts
;
int
fetch_timestamp
;
#
define
AV_PARSER_PTS_NB
4
int
cur_frame_start_index
;
int64_t
cur_frame_offset
[
AV_PARSER_PTS_NB
]
;
int64_t
cur_frame_pts
[
AV_PARSER_PTS_NB
]
;
int64_t
cur_frame_dts
[
AV_PARSER_PTS_NB
]
;
int
flags
;
#
define
PARSER_FLAG_COMPLETE_FRAMES
0x0001
#
define
PARSER_FLAG_ONCE
0x0002
#
define
PARSER_FLAG_FETCHED_OFFSET
0x0004
#
define
PARSER_FLAG_USE_CODEC_TS
0x1000
int64_t
offset
;
int64_t
cur_frame_end
[
AV_PARSER_PTS_NB
]
;
int
key_frame
;
#
if
FF_API_CONVERGENCE_DURATION
attribute_deprecated
int64_t
convergence_duration
;
#
endif
int
dts_sync_point
;
int
dts_ref_dts_delta
;
int
pts_dts_delta
;
int64_t
cur_frame_pos
[
AV_PARSER_PTS_NB
]
;
int64_t
pos
;
int64_t
last_pos
;
int
duration
;
enum
AVFieldOrder
field_order
;
enum
AVPictureStructure
picture_structure
;
int
output_picture_number
;
int
width
;
int
height
;
int
coded_width
;
int
coded_height
;
int
format
;
}
AVCodecParserContext
;
typedef
struct
AVCodecParser
{
int
codec_ids
[
5
]
;
int
priv_data_size
;
int
(
*
parser_init
)
(
AVCodecParserContext
*
s
)
;
int
(
*
parser_parse
)
(
AVCodecParserContext
*
s
AVCodecContext
*
avctx
const
uint8_t
*
*
poutbuf
int
*
poutbuf_size
const
uint8_t
*
buf
int
buf_size
)
;
void
(
*
parser_close
)
(
AVCodecParserContext
*
s
)
;
int
(
*
split
)
(
AVCodecContext
*
avctx
const
uint8_t
*
buf
int
buf_size
)
;
struct
AVCodecParser
*
next
;
}
AVCodecParser
;
AVCodecParser
*
av_parser_next
(
const
AVCodecParser
*
c
)
;
void
av_register_codec_parser
(
AVCodecParser
*
parser
)
;
AVCodecParserContext
*
av_parser_init
(
int
codec_id
)
;
int
av_parser_parse2
(
AVCodecParserContext
*
s
AVCodecContext
*
avctx
uint8_t
*
*
poutbuf
int
*
poutbuf_size
const
uint8_t
*
buf
int
buf_size
int64_t
pts
int64_t
dts
int64_t
pos
)
;
int
av_parser_change
(
AVCodecParserContext
*
s
AVCodecContext
*
avctx
uint8_t
*
*
poutbuf
int
*
poutbuf_size
const
uint8_t
*
buf
int
buf_size
int
keyframe
)
;
void
av_parser_close
(
AVCodecParserContext
*
s
)
;
AVCodec
*
avcodec_find_encoder
(
enum
AVCodecID
id
)
;
AVCodec
*
avcodec_find_encoder_by_name
(
const
char
*
name
)
;
int
avcodec_encode_audio2
(
AVCodecContext
*
avctx
AVPacket
*
avpkt
const
AVFrame
*
frame
int
*
got_packet_ptr
)
;
int
avcodec_encode_video2
(
AVCodecContext
*
avctx
AVPacket
*
avpkt
const
AVFrame
*
frame
int
*
got_packet_ptr
)
;
int
avcodec_encode_subtitle
(
AVCodecContext
*
avctx
uint8_t
*
buf
int
buf_size
const
AVSubtitle
*
sub
)
;
#
if
FF_API_AVCODEC_RESAMPLE
struct
ReSampleContext
;
struct
AVResampleContext
;
typedef
struct
ReSampleContext
ReSampleContext
;
attribute_deprecated
ReSampleContext
*
av_audio_resample_init
(
int
output_channels
int
input_channels
int
output_rate
int
input_rate
enum
AVSampleFormat
sample_fmt_out
enum
AVSampleFormat
sample_fmt_in
int
filter_length
int
log2_phase_count
int
linear
double
cutoff
)
;
attribute_deprecated
int
audio_resample
(
ReSampleContext
*
s
short
*
output
short
*
input
int
nb_samples
)
;
attribute_deprecated
void
audio_resample_close
(
ReSampleContext
*
s
)
;
attribute_deprecated
struct
AVResampleContext
*
av_resample_init
(
int
out_rate
int
in_rate
int
filter_length
int
log2_phase_count
int
linear
double
cutoff
)
;
attribute_deprecated
int
av_resample
(
struct
AVResampleContext
*
c
short
*
dst
short
*
src
int
*
consumed
int
src_size
int
dst_size
int
update_ctx
)
;
attribute_deprecated
void
av_resample_compensate
(
struct
AVResampleContext
*
c
int
sample_delta
int
compensation_distance
)
;
attribute_deprecated
void
av_resample_close
(
struct
AVResampleContext
*
c
)
;
#
endif
#
if
FF_API_AVPICTURE
attribute_deprecated
int
avpicture_alloc
(
AVPicture
*
picture
enum
AVPixelFormat
pix_fmt
int
width
int
height
)
;
attribute_deprecated
void
avpicture_free
(
AVPicture
*
picture
)
;
attribute_deprecated
int
avpicture_fill
(
AVPicture
*
picture
const
uint8_t
*
ptr
enum
AVPixelFormat
pix_fmt
int
width
int
height
)
;
attribute_deprecated
int
avpicture_layout
(
const
AVPicture
*
src
enum
AVPixelFormat
pix_fmt
int
width
int
height
unsigned
char
*
dest
int
dest_size
)
;
attribute_deprecated
int
avpicture_get_size
(
enum
AVPixelFormat
pix_fmt
int
width
int
height
)
;
attribute_deprecated
void
av_picture_copy
(
AVPicture
*
dst
const
AVPicture
*
src
enum
AVPixelFormat
pix_fmt
int
width
int
height
)
;
attribute_deprecated
int
av_picture_crop
(
AVPicture
*
dst
const
AVPicture
*
src
enum
AVPixelFormat
pix_fmt
int
top_band
int
left_band
)
;
attribute_deprecated
int
av_picture_pad
(
AVPicture
*
dst
const
AVPicture
*
src
int
height
int
width
enum
AVPixelFormat
pix_fmt
int
padtop
int
padbottom
int
padleft
int
padright
int
*
color
)
;
#
endif
void
avcodec_get_chroma_sub_sample
(
enum
AVPixelFormat
pix_fmt
int
*
h_shift
int
*
v_shift
)
;
unsigned
int
avcodec_pix_fmt_to_codec_tag
(
enum
AVPixelFormat
pix_fmt
)
;
int
avcodec_get_pix_fmt_loss
(
enum
AVPixelFormat
dst_pix_fmt
enum
AVPixelFormat
src_pix_fmt
int
has_alpha
)
;
enum
AVPixelFormat
avcodec_find_best_pix_fmt_of_list
(
const
enum
AVPixelFormat
*
pix_fmt_list
enum
AVPixelFormat
src_pix_fmt
int
has_alpha
int
*
loss_ptr
)
;
enum
AVPixelFormat
avcodec_find_best_pix_fmt_of_2
(
enum
AVPixelFormat
dst_pix_fmt1
enum
AVPixelFormat
dst_pix_fmt2
enum
AVPixelFormat
src_pix_fmt
int
has_alpha
int
*
loss_ptr
)
;
attribute_deprecated
#
if
AV_HAVE_INCOMPATIBLE_LIBAV_ABI
enum
AVPixelFormat
avcodec_find_best_pix_fmt2
(
const
enum
AVPixelFormat
*
pix_fmt_list
enum
AVPixelFormat
src_pix_fmt
int
has_alpha
int
*
loss_ptr
)
;
#
else
enum
AVPixelFormat
avcodec_find_best_pix_fmt2
(
enum
AVPixelFormat
dst_pix_fmt1
enum
AVPixelFormat
dst_pix_fmt2
enum
AVPixelFormat
src_pix_fmt
int
has_alpha
int
*
loss_ptr
)
;
#
endif
enum
AVPixelFormat
avcodec_default_get_format
(
struct
AVCodecContext
*
s
const
enum
AVPixelFormat
*
fmt
)
;
#
if
FF_API_SET_DIMENSIONS
attribute_deprecated
void
avcodec_set_dimensions
(
AVCodecContext
*
s
int
width
int
height
)
;
#
endif
size_t
av_get_codec_tag_string
(
char
*
buf
size_t
buf_size
unsigned
int
codec_tag
)
;
void
avcodec_string
(
char
*
buf
int
buf_size
AVCodecContext
*
enc
int
encode
)
;
const
char
*
av_get_profile_name
(
const
AVCodec
*
codec
int
profile
)
;
const
char
*
avcodec_profile_name
(
enum
AVCodecID
codec_id
int
profile
)
;
int
avcodec_default_execute
(
AVCodecContext
*
c
int
(
*
func
)
(
AVCodecContext
*
c2
void
*
arg2
)
void
*
arg
int
*
ret
int
count
int
size
)
;
int
avcodec_default_execute2
(
AVCodecContext
*
c
int
(
*
func
)
(
AVCodecContext
*
c2
void
*
arg2
int
int
)
void
*
arg
int
*
ret
int
count
)
;
int
avcodec_fill_audio_frame
(
AVFrame
*
frame
int
nb_channels
enum
AVSampleFormat
sample_fmt
const
uint8_t
*
buf
int
buf_size
int
align
)
;
void
avcodec_flush_buffers
(
AVCodecContext
*
avctx
)
;
int
av_get_bits_per_sample
(
enum
AVCodecID
codec_id
)
;
enum
AVCodecID
av_get_pcm_codec
(
enum
AVSampleFormat
fmt
int
be
)
;
int
av_get_exact_bits_per_sample
(
enum
AVCodecID
codec_id
)
;
int
av_get_audio_frame_duration
(
AVCodecContext
*
avctx
int
frame_bytes
)
;
typedef
struct
AVBitStreamFilterContext
{
void
*
priv_data
;
struct
AVBitStreamFilter
*
filter
;
AVCodecParserContext
*
parser
;
struct
AVBitStreamFilterContext
*
next
;
char
*
args
;
}
AVBitStreamFilterContext
;
typedef
struct
AVBitStreamFilter
{
const
char
*
name
;
int
priv_data_size
;
int
(
*
filter
)
(
AVBitStreamFilterContext
*
bsfc
AVCodecContext
*
avctx
const
char
*
args
uint8_t
*
*
poutbuf
int
*
poutbuf_size
const
uint8_t
*
buf
int
buf_size
int
keyframe
)
;
void
(
*
close
)
(
AVBitStreamFilterContext
*
bsfc
)
;
struct
AVBitStreamFilter
*
next
;
}
AVBitStreamFilter
;
void
av_register_bitstream_filter
(
AVBitStreamFilter
*
bsf
)
;
AVBitStreamFilterContext
*
av_bitstream_filter_init
(
const
char
*
name
)
;
int
av_bitstream_filter_filter
(
AVBitStreamFilterContext
*
bsfc
AVCodecContext
*
avctx
const
char
*
args
uint8_t
*
*
poutbuf
int
*
poutbuf_size
const
uint8_t
*
buf
int
buf_size
int
keyframe
)
;
void
av_bitstream_filter_close
(
AVBitStreamFilterContext
*
bsf
)
;
AVBitStreamFilter
*
av_bitstream_filter_next
(
const
AVBitStreamFilter
*
f
)
;
void
av_fast_padded_malloc
(
void
*
ptr
unsigned
int
*
size
size_t
min_size
)
;
void
av_fast_padded_mallocz
(
void
*
ptr
unsigned
int
*
size
size_t
min_size
)
;
unsigned
int
av_xiphlacing
(
unsigned
char
*
s
unsigned
int
v
)
;
#
if
FF_API_MISSING_SAMPLE
attribute_deprecated
void
av_log_missing_feature
(
void
*
avc
const
char
*
feature
int
want_sample
)
;
attribute_deprecated
void
av_log_ask_for_sample
(
void
*
avc
const
char
*
msg
.
.
.
)
av_printf_format
(
2
3
)
;
#
endif
void
av_register_hwaccel
(
AVHWAccel
*
hwaccel
)
;
AVHWAccel
*
av_hwaccel_next
(
const
AVHWAccel
*
hwaccel
)
;
enum
AVLockOp
{
AV_LOCK_CREATE
AV_LOCK_OBTAIN
AV_LOCK_RELEASE
AV_LOCK_DESTROY
}
;
int
av_lockmgr_register
(
int
(
*
cb
)
(
void
*
*
mutex
enum
AVLockOp
op
)
)
;
enum
AVMediaType
avcodec_get_type
(
enum
AVCodecID
codec_id
)
;
const
char
*
avcodec_get_name
(
enum
AVCodecID
id
)
;
int
avcodec_is_open
(
AVCodecContext
*
s
)
;
int
av_codec_is_encoder
(
const
AVCodec
*
codec
)
;
int
av_codec_is_decoder
(
const
AVCodec
*
codec
)
;
const
AVCodecDescriptor
*
avcodec_descriptor_get
(
enum
AVCodecID
id
)
;
const
AVCodecDescriptor
*
avcodec_descriptor_next
(
const
AVCodecDescriptor
*
prev
)
;
const
AVCodecDescriptor
*
avcodec_descriptor_get_by_name
(
const
char
*
name
)
;
AVCPBProperties
*
av_cpb_properties_alloc
(
size_t
*
size
)
;
#
endif
