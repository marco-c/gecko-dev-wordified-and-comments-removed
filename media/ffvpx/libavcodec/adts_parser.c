#
include
"
config
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
"
libavutil
/
error
.
h
"
#
include
"
libavutil
/
mem
.
h
"
#
include
"
adts_header
.
h
"
#
include
"
adts_parser
.
h
"
int
av_adts_header_parse
(
const
uint8_t
*
buf
uint32_t
*
samples
uint8_t
*
frames
)
{
#
if
CONFIG_ADTS_HEADER
uint8_t
tmpbuf
[
AV_AAC_ADTS_HEADER_SIZE
+
AV_INPUT_BUFFER_PADDING_SIZE
]
;
AACADTSHeaderInfo
hdr
;
int
err
;
if
(
!
buf
)
return
AVERROR
(
EINVAL
)
;
memcpy
(
tmpbuf
buf
AV_AAC_ADTS_HEADER_SIZE
)
;
err
=
ff_adts_header_parse_buf
(
tmpbuf
&
hdr
)
;
if
(
err
<
0
)
return
err
;
*
samples
=
hdr
.
samples
;
*
frames
=
hdr
.
num_aac_frames
;
return
0
;
#
else
return
AVERROR
(
ENOSYS
)
;
#
endif
}
int
avpriv_adts_header_parse
(
AACADTSHeaderInfo
*
*
phdr
const
uint8_t
*
buf
size_t
size
)
{
#
if
CONFIG_ADTS_HEADER
int
ret
=
0
;
int
allocated
=
0
;
if
(
!
phdr
|
|
!
buf
|
|
size
<
AV_AAC_ADTS_HEADER_SIZE
)
return
AVERROR_INVALIDDATA
;
if
(
!
*
phdr
)
{
allocated
=
1
;
*
phdr
=
av_mallocz
(
sizeof
(
AACADTSHeaderInfo
)
)
;
}
if
(
!
*
phdr
)
return
AVERROR
(
ENOMEM
)
;
ret
=
ff_adts_header_parse_buf
(
buf
*
phdr
)
;
if
(
ret
<
0
)
{
if
(
allocated
)
av_freep
(
phdr
)
;
return
ret
;
}
return
0
;
#
else
return
AVERROR
(
ENOSYS
)
;
#
endif
}
