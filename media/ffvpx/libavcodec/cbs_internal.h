#
ifndef
AVCODEC_CBS_INTERNAL_H
#
define
AVCODEC_CBS_INTERNAL_H
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
"
libavutil
/
log
.
h
"
#
include
"
cbs
.
h
"
#
include
"
codec_id
.
h
"
#
include
"
get_bits
.
h
"
#
include
"
put_bits
.
h
"
#
include
"
refstruct
.
h
"
enum
CBSContentType
{
CBS_CONTENT_TYPE_INTERNAL_REFS
CBS_CONTENT_TYPE_COMPLEX
}
;
enum
{
CBS_MAX_LIST_UNIT_TYPES
=
3
CBS_MAX_REF_OFFSETS
=
2
CBS_UNIT_TYPE_RANGE
=
-
1
}
;
typedef
const
struct
CodedBitstreamUnitTypeDescriptor
{
int
nb_unit_types
;
union
{
CodedBitstreamUnitType
list
[
CBS_MAX_LIST_UNIT_TYPES
]
;
struct
{
CodedBitstreamUnitType
start
;
CodedBitstreamUnitType
end
;
}
range
;
}
unit_type
;
enum
CBSContentType
content_type
;
size_t
content_size
;
union
{
struct
{
int
nb_offsets
;
size_t
offsets
[
CBS_MAX_REF_OFFSETS
]
;
}
ref
;
struct
{
void
(
*
content_free
)
(
FFRefStructOpaque
opaque
void
*
content
)
;
int
(
*
content_clone
)
(
void
*
*
new_content
CodedBitstreamUnit
*
unit
)
;
}
complex
;
}
type
;
}
CodedBitstreamUnitTypeDescriptor
;
typedef
struct
CodedBitstreamType
{
enum
AVCodecID
codec_id
;
const
AVClass
*
priv_class
;
size_t
priv_data_size
;
const
CodedBitstreamUnitTypeDescriptor
*
unit_types
;
int
(
*
split_fragment
)
(
CodedBitstreamContext
*
ctx
CodedBitstreamFragment
*
frag
int
header
)
;
int
(
*
read_unit
)
(
CodedBitstreamContext
*
ctx
CodedBitstreamUnit
*
unit
)
;
int
(
*
write_unit
)
(
CodedBitstreamContext
*
ctx
CodedBitstreamUnit
*
unit
PutBitContext
*
pbc
)
;
int
(
*
discarded_unit
)
(
CodedBitstreamContext
*
ctx
const
CodedBitstreamUnit
*
unit
enum
AVDiscard
skip
)
;
int
(
*
assemble_fragment
)
(
CodedBitstreamContext
*
ctx
CodedBitstreamFragment
*
frag
)
;
void
(
*
flush
)
(
CodedBitstreamContext
*
ctx
)
;
void
(
*
close
)
(
CodedBitstreamContext
*
ctx
)
;
}
CodedBitstreamType
;
void
ff_cbs_trace_header
(
CodedBitstreamContext
*
ctx
const
char
*
name
)
;
int
ff_cbs_read_unsigned
(
CodedBitstreamContext
*
ctx
GetBitContext
*
gbc
int
width
const
char
*
name
const
int
*
subscripts
uint32_t
*
write_to
uint32_t
range_min
uint32_t
range_max
)
;
int
ff_cbs_read_simple_unsigned
(
CodedBitstreamContext
*
ctx
GetBitContext
*
gbc
int
width
const
char
*
name
uint32_t
*
write_to
)
;
int
ff_cbs_write_unsigned
(
CodedBitstreamContext
*
ctx
PutBitContext
*
pbc
int
width
const
char
*
name
const
int
*
subscripts
uint32_t
value
uint32_t
range_min
uint32_t
range_max
)
;
int
ff_cbs_write_simple_unsigned
(
CodedBitstreamContext
*
ctx
PutBitContext
*
pbc
int
width
const
char
*
name
uint32_t
value
)
;
int
ff_cbs_read_signed
(
CodedBitstreamContext
*
ctx
GetBitContext
*
gbc
int
width
const
char
*
name
const
int
*
subscripts
int32_t
*
write_to
int32_t
range_min
int32_t
range_max
)
;
int
ff_cbs_write_signed
(
CodedBitstreamContext
*
ctx
PutBitContext
*
pbc
int
width
const
char
*
name
const
int
*
subscripts
int32_t
value
int32_t
range_min
int32_t
range_max
)
;
#
define
MAX_UINT_BITS
(
length
)
(
(
UINT64_C
(
1
)
<
<
(
length
)
)
-
1
)
#
define
MAX_INT_BITS
(
length
)
(
(
INT64_C
(
1
)
<
<
(
(
length
)
-
1
)
)
-
1
)
#
define
MIN_INT_BITS
(
length
)
(
-
(
INT64_C
(
1
)
<
<
(
(
length
)
-
1
)
)
)
#
define
CBS_TRACE_READ_START
(
)
\
GetBitContext
trace_start
;
\
do
{
\
if
(
ctx
-
>
trace_enable
)
\
trace_start
=
*
gbc
;
\
}
while
(
0
)
#
define
CBS_TRACE_READ_END
(
)
\
do
{
\
if
(
ctx
-
>
trace_enable
)
{
\
int
start_position
=
get_bits_count
(
&
trace_start
)
;
\
int
end_position
=
get_bits_count
(
gbc
)
;
\
av_assert0
(
start_position
<
=
end_position
)
;
\
ctx
-
>
trace_read_callback
(
ctx
-
>
trace_context
&
trace_start
\
end_position
-
start_position
\
name
subscripts
value
)
;
\
}
\
}
while
(
0
)
#
define
CBS_TRACE_READ_END_NO_SUBSCRIPTS
(
)
\
do
{
\
const
int
*
subscripts
=
NULL
;
\
CBS_TRACE_READ_END
(
)
;
\
}
while
(
0
)
#
define
CBS_TRACE_READ_END_VALUE_ONLY
(
)
\
do
{
\
if
(
ctx
-
>
trace_enable
)
{
\
ctx
-
>
trace_read_callback
(
ctx
-
>
trace_context
&
trace_start
0
\
name
subscripts
value
)
;
\
}
\
}
while
(
0
)
#
define
CBS_TRACE_WRITE_START
(
)
\
int
start_position
;
\
do
{
\
if
(
ctx
-
>
trace_enable
)
\
start_position
=
put_bits_count
(
pbc
)
;
;
\
}
while
(
0
)
#
define
CBS_TRACE_WRITE_END
(
)
\
do
{
\
if
(
ctx
-
>
trace_enable
)
{
\
int
end_position
=
put_bits_count
(
pbc
)
;
\
av_assert0
(
start_position
<
=
end_position
)
;
\
ctx
-
>
trace_write_callback
(
ctx
-
>
trace_context
pbc
\
end_position
-
start_position
\
name
subscripts
value
)
;
\
}
\
}
while
(
0
)
#
define
CBS_TRACE_WRITE_END_NO_SUBSCRIPTS
(
)
\
do
{
\
const
int
*
subscripts
=
NULL
;
\
CBS_TRACE_WRITE_END
(
)
;
\
}
while
(
0
)
#
define
CBS_TRACE_WRITE_END_VALUE_ONLY
(
)
\
do
{
\
if
(
ctx
-
>
trace_enable
)
{
\
PutBitContext
tmp
;
\
init_put_bits
(
&
tmp
pbc
-
>
buf
start_position
)
;
\
skip_put_bits
(
&
tmp
start_position
)
;
\
ctx
-
>
trace_write_callback
(
ctx
-
>
trace_context
&
tmp
0
\
name
subscripts
value
)
;
\
}
\
}
while
(
0
)
#
define
TYPE_LIST
(
.
.
.
)
{
__VA_ARGS__
}
#
define
CBS_UNIT_TYPE_POD
(
type_
structure
)
{
\
.
nb_unit_types
=
1
\
.
unit_type
.
list
=
{
type_
}
\
.
content_type
=
CBS_CONTENT_TYPE_INTERNAL_REFS
\
.
content_size
=
sizeof
(
structure
)
\
.
type
.
ref
=
{
.
nb_offsets
=
0
}
\
}
#
define
CBS_UNIT_RANGE_POD
(
range_start
range_end
structure
)
{
\
.
nb_unit_types
=
CBS_UNIT_TYPE_RANGE
\
.
unit_type
.
range
.
start
=
range_start
\
.
unit_type
.
range
.
end
=
range_end
\
.
content_type
=
CBS_CONTENT_TYPE_INTERNAL_REFS
\
.
content_size
=
sizeof
(
structure
)
\
.
type
.
ref
=
{
.
nb_offsets
=
0
}
\
}
#
define
CBS_UNIT_TYPES_INTERNAL_REF
(
types
structure
ref_field
)
{
\
.
nb_unit_types
=
FF_ARRAY_ELEMS
(
(
CodedBitstreamUnitType
[
]
)
TYPE_LIST
types
)
\
.
unit_type
.
list
=
TYPE_LIST
types
\
.
content_type
=
CBS_CONTENT_TYPE_INTERNAL_REFS
\
.
content_size
=
sizeof
(
structure
)
\
.
type
.
ref
=
{
.
nb_offsets
=
1
\
.
offsets
=
{
offsetof
(
structure
ref_field
)
}
}
\
}
#
define
CBS_UNIT_TYPE_INTERNAL_REF
(
type
structure
ref_field
)
\
CBS_UNIT_TYPES_INTERNAL_REF
(
(
type
)
structure
ref_field
)
#
define
CBS_UNIT_RANGE_INTERNAL_REF
(
range_start
range_end
structure
ref_field
)
{
\
.
nb_unit_types
=
CBS_UNIT_TYPE_RANGE
\
.
unit_type
.
range
.
start
=
range_start
\
.
unit_type
.
range
.
end
=
range_end
\
.
content_type
=
CBS_CONTENT_TYPE_INTERNAL_REFS
\
.
content_size
=
sizeof
(
structure
)
\
.
type
.
ref
=
{
.
nb_offsets
=
1
\
.
offsets
=
{
offsetof
(
structure
ref_field
)
}
}
\
}
#
define
CBS_UNIT_TYPES_COMPLEX
(
types
structure
free_func
)
{
\
.
nb_unit_types
=
FF_ARRAY_ELEMS
(
(
CodedBitstreamUnitType
[
]
)
TYPE_LIST
types
)
\
.
unit_type
.
list
=
TYPE_LIST
types
\
.
content_type
=
CBS_CONTENT_TYPE_COMPLEX
\
.
content_size
=
sizeof
(
structure
)
\
.
type
.
complex
=
{
.
content_free
=
free_func
}
\
}
#
define
CBS_UNIT_TYPE_COMPLEX
(
type
structure
free_func
)
\
CBS_UNIT_TYPES_COMPLEX
(
(
type
)
structure
free_func
)
#
define
CBS_UNIT_TYPE_END_OF_LIST
{
.
nb_unit_types
=
0
}
extern
const
CodedBitstreamType
ff_cbs_type_av1
;
extern
const
CodedBitstreamType
ff_cbs_type_h264
;
extern
const
CodedBitstreamType
ff_cbs_type_h265
;
extern
const
CodedBitstreamType
ff_cbs_type_h266
;
extern
const
CodedBitstreamType
ff_cbs_type_jpeg
;
extern
const
CodedBitstreamType
ff_cbs_type_mpeg2
;
extern
const
CodedBitstreamType
ff_cbs_type_vp8
;
extern
const
CodedBitstreamType
ff_cbs_type_vp9
;
#
endif
