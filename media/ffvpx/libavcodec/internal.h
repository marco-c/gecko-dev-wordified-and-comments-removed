#
ifndef
AVCODEC_INTERNAL_H
#
define
AVCODEC_INTERNAL_H
#
include
<
stdint
.
h
>
#
include
"
libavutil
/
buffer
.
h
"
#
include
"
libavutil
/
channel_layout
.
h
"
#
include
"
libavutil
/
mathematics
.
h
"
#
include
"
libavutil
/
pixfmt
.
h
"
#
include
"
avcodec
.
h
"
#
include
"
config
.
h
"
#
define
FF_SANE_NB_CHANNELS
512U
#
if
HAVE_SIMD_ALIGN_64
#
define
STRIDE_ALIGN
64
/
*
AVX
-
512
*
/
#
elif
HAVE_SIMD_ALIGN_32
#
define
STRIDE_ALIGN
32
#
elif
HAVE_SIMD_ALIGN_16
#
define
STRIDE_ALIGN
16
#
else
#
define
STRIDE_ALIGN
8
#
endif
typedef
struct
AVCodecInternal
{
int
is_copy
;
int
last_audio_frame
;
AVBufferRef
*
pool
;
void
*
thread_ctx
;
AVPacket
*
in_pkt
;
struct
AVBSFContext
*
bsf
;
AVPacket
*
last_pkt_props
;
struct
AVFifo
*
pkt_props
;
uint8_t
*
byte_buffer
;
unsigned
int
byte_buffer_size
;
int
intra_only_flag
;
void
*
frame_thread_encoder
;
AVFrame
*
in_frame
;
int
needs_close
;
int
skip_samples
;
void
*
hwaccel_priv_data
;
int
draining
;
AVPacket
*
buffer_pkt
;
AVFrame
*
buffer_frame
;
int
draining_done
;
int
showed_multi_packet_warning
;
int
skip_samples_multiplier
;
int
nb_draining_errors
;
int
changed_frames_dropped
;
int
initial_format
;
int
initial_width
initial_height
;
int
initial_sample_rate
;
#
if
FF_API_OLD_CHANNEL_LAYOUT
int
initial_channels
;
uint64_t
initial_channel_layout
;
#
endif
AVChannelLayout
initial_ch_layout
;
}
AVCodecInternal
;
int
ff_match_2uint16
(
const
uint16_t
(
*
tab
)
[
2
]
int
size
int
a
int
b
)
;
unsigned
int
ff_toupper4
(
unsigned
int
x
)
;
void
ff_color_frame
(
AVFrame
*
frame
const
int
color
[
4
]
)
;
#
define
FF_MAX_EXTRADATA_SIZE
(
(
1
<
<
28
)
-
AV_INPUT_BUFFER_PADDING_SIZE
)
static
av_always_inline
int64_t
ff_samples_to_time_base
(
AVCodecContext
*
avctx
int64_t
samples
)
{
if
(
samples
=
=
AV_NOPTS_VALUE
)
return
AV_NOPTS_VALUE
;
return
av_rescale_q
(
samples
(
AVRational
)
{
1
avctx
-
>
sample_rate
}
avctx
-
>
time_base
)
;
}
static
av_always_inline
float
ff_exp2fi
(
int
x
)
{
if
(
-
126
<
=
x
&
&
x
<
=
128
)
return
av_int2float
(
(
x
+
127
)
<
<
23
)
;
else
if
(
x
>
128
)
return
INFINITY
;
else
if
(
x
>
-
150
)
return
av_int2float
(
1
<
<
(
x
+
149
)
)
;
else
return
0
;
}
int
ff_get_buffer
(
AVCodecContext
*
avctx
AVFrame
*
frame
int
flags
)
;
#
define
FF_REGET_BUFFER_FLAG_READONLY
1
/
/
/
<
the
returned
buffer
does
not
need
to
be
writable
int
ff_reget_buffer
(
AVCodecContext
*
avctx
AVFrame
*
frame
int
flags
)
;
int
ff_thread_can_start_frame
(
AVCodecContext
*
avctx
)
;
int
avpriv_h264_has_num_reorder_frames
(
AVCodecContext
*
avctx
)
;
int
avpriv_codec_get_cap_skip_frame_fill_param
(
const
AVCodec
*
codec
)
;
int
ff_set_dimensions
(
AVCodecContext
*
s
int
width
int
height
)
;
int
ff_set_sar
(
AVCodecContext
*
avctx
AVRational
sar
)
;
int
ff_side_data_update_matrix_encoding
(
AVFrame
*
frame
enum
AVMatrixEncoding
matrix_encoding
)
;
int
ff_get_format
(
AVCodecContext
*
avctx
const
enum
AVPixelFormat
*
fmt
)
;
AVCPBProperties
*
ff_add_cpb_side_data
(
AVCodecContext
*
avctx
)
;
int
ff_alloc_timecode_sei
(
const
AVFrame
*
frame
AVRational
rate
size_t
prefix_len
void
*
*
data
size_t
*
sei_size
)
;
int64_t
ff_guess_coded_bitrate
(
AVCodecContext
*
avctx
)
;
int
ff_int_from_list_or_default
(
void
*
ctx
const
char
*
val_name
int
val
const
int
*
array_valid_values
int
default_value
)
;
void
ff_dvdsub_parse_palette
(
uint32_t
*
palette
const
char
*
p
)
;
#
endif
