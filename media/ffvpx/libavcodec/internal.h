#
ifndef
AVCODEC_INTERNAL_H
#
define
AVCODEC_INTERNAL_H
#
include
<
stdint
.
h
>
#
include
"
libavutil
/
buffer
.
h
"
#
include
"
libavutil
/
channel_layout
.
h
"
#
include
"
libavutil
/
fifo
.
h
"
#
include
"
libavutil
/
mathematics
.
h
"
#
include
"
libavutil
/
pixfmt
.
h
"
#
include
"
avcodec
.
h
"
#
include
"
config
.
h
"
#
define
FF_CODEC_CAP_INIT_THREADSAFE
(
1
<
<
0
)
#
define
FF_CODEC_CAP_INIT_CLEANUP
(
1
<
<
1
)
#
define
FF_CODEC_CAP_SETS_PKT_DTS
(
1
<
<
2
)
#
define
FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM
(
1
<
<
3
)
#
define
FF_CODEC_CAP_EXPORTS_CROPPING
(
1
<
<
4
)
#
define
FF_CODEC_CAP_SLICE_THREAD_HAS_MF
(
1
<
<
5
)
#
define
FF_CODEC_CAP_ALLOCATE_PROGRESS
(
1
<
<
6
)
#
define
FF_CODEC_CAP_AUTO_THREADS
(
1
<
<
7
)
#
define
FF_CODEC_CAP_SETS_FRAME_PROPS
(
1
<
<
8
)
#
define
FF_CODEC_TAGS_END
-
1
#
ifdef
TRACE
#
define
ff_tlog
(
ctx
.
.
.
)
av_log
(
ctx
AV_LOG_TRACE
__VA_ARGS__
)
#
else
#
define
ff_tlog
(
ctx
.
.
.
)
do
{
}
while
(
0
)
#
endif
#
define
FF_DEFAULT_QUANT_BIAS
999999
#
define
FF_QSCALE_TYPE_MPEG1
0
#
define
FF_QSCALE_TYPE_MPEG2
1
#
define
FF_QSCALE_TYPE_H264
2
#
define
FF_QSCALE_TYPE_VP56
3
#
define
FF_SANE_NB_CHANNELS
512U
#
define
FF_SIGNBIT
(
x
)
(
(
x
)
>
>
CHAR_BIT
*
sizeof
(
x
)
-
1
)
#
if
HAVE_SIMD_ALIGN_64
#
define
STRIDE_ALIGN
64
/
*
AVX
-
512
*
/
#
elif
HAVE_SIMD_ALIGN_32
#
define
STRIDE_ALIGN
32
#
elif
HAVE_SIMD_ALIGN_16
#
define
STRIDE_ALIGN
16
#
else
#
define
STRIDE_ALIGN
8
#
endif
typedef
struct
DecodeSimpleContext
{
AVPacket
*
in_pkt
;
}
DecodeSimpleContext
;
typedef
struct
EncodeSimpleContext
{
AVFrame
*
in_frame
;
}
EncodeSimpleContext
;
typedef
struct
AVCodecInternal
{
int
is_copy
;
int
last_audio_frame
;
#
if
FF_API_OLD_ENCDEC
AVFrame
*
to_free
;
#
endif
AVBufferRef
*
pool
;
void
*
thread_ctx
;
DecodeSimpleContext
ds
;
AVBSFContext
*
bsf
;
AVPacket
*
last_pkt_props
;
AVFifoBuffer
*
pkt_props
;
uint8_t
*
byte_buffer
;
unsigned
int
byte_buffer_size
;
void
*
frame_thread_encoder
;
EncodeSimpleContext
es
;
int
skip_samples
;
void
*
hwaccel_priv_data
;
int
draining
;
AVPacket
*
buffer_pkt
;
AVFrame
*
buffer_frame
;
int
draining_done
;
#
if
FF_API_OLD_ENCDEC
int
compat_decode_warned
;
size_t
compat_decode_consumed
;
size_t
compat_decode_partial_size
;
AVFrame
*
compat_decode_frame
;
AVPacket
*
compat_encode_packet
;
#
endif
int
showed_multi_packet_warning
;
int
skip_samples_multiplier
;
int
nb_draining_errors
;
int
changed_frames_dropped
;
int
initial_format
;
int
initial_width
initial_height
;
int
initial_sample_rate
;
int
initial_channels
;
uint64_t
initial_channel_layout
;
}
AVCodecInternal
;
struct
AVCodecDefault
{
const
uint8_t
*
key
;
const
uint8_t
*
value
;
}
;
extern
const
uint8_t
ff_log2_run
[
41
]
;
int
ff_match_2uint16
(
const
uint16_t
(
*
tab
)
[
2
]
int
size
int
a
int
b
)
;
unsigned
int
avpriv_toupper4
(
unsigned
int
x
)
;
void
ff_color_frame
(
AVFrame
*
frame
const
int
color
[
4
]
)
;
#
define
FF_MAX_EXTRADATA_SIZE
(
(
1
<
<
28
)
-
AV_INPUT_BUFFER_PADDING_SIZE
)
int
ff_alloc_packet2
(
AVCodecContext
*
avctx
AVPacket
*
avpkt
int64_t
size
int64_t
min_size
)
;
static
av_always_inline
int64_t
ff_samples_to_time_base
(
AVCodecContext
*
avctx
int64_t
samples
)
{
if
(
samples
=
=
AV_NOPTS_VALUE
)
return
AV_NOPTS_VALUE
;
return
av_rescale_q
(
samples
(
AVRational
)
{
1
avctx
-
>
sample_rate
}
avctx
-
>
time_base
)
;
}
static
av_always_inline
float
ff_exp2fi
(
int
x
)
{
if
(
-
126
<
=
x
&
&
x
<
=
128
)
return
av_int2float
(
(
x
+
127
)
<
<
23
)
;
else
if
(
x
>
128
)
return
INFINITY
;
else
if
(
x
>
-
150
)
return
av_int2float
(
1
<
<
(
x
+
149
)
)
;
else
return
0
;
}
int
ff_get_buffer
(
AVCodecContext
*
avctx
AVFrame
*
frame
int
flags
)
;
#
define
FF_REGET_BUFFER_FLAG_READONLY
1
/
/
/
<
the
returned
buffer
does
not
need
to
be
writable
int
ff_reget_buffer
(
AVCodecContext
*
avctx
AVFrame
*
frame
int
flags
)
;
int
ff_thread_can_start_frame
(
AVCodecContext
*
avctx
)
;
int
avpriv_h264_has_num_reorder_frames
(
AVCodecContext
*
avctx
)
;
const
uint8_t
*
avpriv_find_start_code
(
const
uint8_t
*
p
const
uint8_t
*
end
uint32_t
*
state
)
;
int
avpriv_codec_get_cap_skip_frame_fill_param
(
const
AVCodec
*
codec
)
;
int
ff_set_dimensions
(
AVCodecContext
*
s
int
width
int
height
)
;
int
ff_set_sar
(
AVCodecContext
*
avctx
AVRational
sar
)
;
int
ff_side_data_update_matrix_encoding
(
AVFrame
*
frame
enum
AVMatrixEncoding
matrix_encoding
)
;
int
ff_get_format
(
AVCodecContext
*
avctx
const
enum
AVPixelFormat
*
fmt
)
;
AVCPBProperties
*
ff_add_cpb_side_data
(
AVCodecContext
*
avctx
)
;
int
ff_alloc_timecode_sei
(
const
AVFrame
*
frame
AVRational
rate
size_t
prefix_len
void
*
*
data
size_t
*
sei_size
)
;
int64_t
ff_guess_coded_bitrate
(
AVCodecContext
*
avctx
)
;
int
ff_int_from_list_or_default
(
void
*
ctx
const
char
*
val_name
int
val
const
int
*
array_valid_values
int
default_value
)
;
void
ff_dvdsub_parse_palette
(
uint32_t
*
palette
const
char
*
p
)
;
#
if
defined
(
_WIN32
)
&
&
CONFIG_SHARED
&
&
!
defined
(
BUILDING_avcodec
)
#
define
av_export_avcodec
__declspec
(
dllimport
)
#
else
#
define
av_export_avcodec
#
endif
#
endif
