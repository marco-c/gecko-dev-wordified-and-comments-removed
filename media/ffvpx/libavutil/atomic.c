#
include
"
config
.
h
"
#
include
"
atomic
.
h
"
#
if
!
HAVE_ATOMICS_NATIVE
#
if
HAVE_PTHREADS
#
include
<
pthread
.
h
>
static
pthread_mutex_t
atomic_lock
=
PTHREAD_MUTEX_INITIALIZER
;
int
avpriv_atomic_int_get
(
volatile
int
*
ptr
)
{
int
res
;
pthread_mutex_lock
(
&
atomic_lock
)
;
res
=
*
ptr
;
pthread_mutex_unlock
(
&
atomic_lock
)
;
return
res
;
}
void
avpriv_atomic_int_set
(
volatile
int
*
ptr
int
val
)
{
pthread_mutex_lock
(
&
atomic_lock
)
;
*
ptr
=
val
;
pthread_mutex_unlock
(
&
atomic_lock
)
;
}
int
avpriv_atomic_int_add_and_fetch
(
volatile
int
*
ptr
int
inc
)
{
int
res
;
pthread_mutex_lock
(
&
atomic_lock
)
;
*
ptr
+
=
inc
;
res
=
*
ptr
;
pthread_mutex_unlock
(
&
atomic_lock
)
;
return
res
;
}
void
*
avpriv_atomic_ptr_cas
(
void
*
volatile
*
ptr
void
*
oldval
void
*
newval
)
{
void
*
ret
;
pthread_mutex_lock
(
&
atomic_lock
)
;
ret
=
*
ptr
;
if
(
ret
=
=
oldval
)
*
ptr
=
newval
;
pthread_mutex_unlock
(
&
atomic_lock
)
;
return
ret
;
}
#
elif
!
HAVE_THREADS
int
avpriv_atomic_int_get
(
volatile
int
*
ptr
)
{
return
*
ptr
;
}
void
avpriv_atomic_int_set
(
volatile
int
*
ptr
int
val
)
{
*
ptr
=
val
;
}
int
avpriv_atomic_int_add_and_fetch
(
volatile
int
*
ptr
int
inc
)
{
*
ptr
+
=
inc
;
return
*
ptr
;
}
void
*
avpriv_atomic_ptr_cas
(
void
*
volatile
*
ptr
void
*
oldval
void
*
newval
)
{
if
(
*
ptr
=
=
oldval
)
{
*
ptr
=
newval
;
return
oldval
;
}
return
*
ptr
;
}
#
else
#
error
"
Threading
is
enabled
but
there
is
no
implementation
of
atomic
operations
available
"
#
endif
#
endif
