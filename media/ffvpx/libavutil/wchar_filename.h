#
ifndef
AVUTIL_WCHAR_FILENAME_H
#
define
AVUTIL_WCHAR_FILENAME_H
#
ifdef
_WIN32
#
include
<
errno
.
h
>
#
include
<
stddef
.
h
>
#
include
<
windows
.
h
>
#
include
"
mem
.
h
"
av_warn_unused_result
static
inline
int
utf8towchar
(
const
char
*
filename_utf8
wchar_t
*
*
filename_w
)
{
int
num_chars
;
num_chars
=
MultiByteToWideChar
(
CP_UTF8
MB_ERR_INVALID_CHARS
filename_utf8
-
1
NULL
0
)
;
if
(
num_chars
<
=
0
)
{
*
filename_w
=
NULL
;
errno
=
EINVAL
;
return
-
1
;
}
*
filename_w
=
(
wchar_t
*
)
av_calloc
(
num_chars
sizeof
(
wchar_t
)
)
;
if
(
!
*
filename_w
)
{
errno
=
ENOMEM
;
return
-
1
;
}
MultiByteToWideChar
(
CP_UTF8
0
filename_utf8
-
1
*
filename_w
num_chars
)
;
return
0
;
}
av_warn_unused_result
static
inline
int
wchartocp
(
unsigned
int
code_page
const
wchar_t
*
filename_w
char
*
*
filename
)
{
DWORD
flags
=
code_page
=
=
CP_UTF8
?
WC_ERR_INVALID_CHARS
:
0
;
int
num_chars
=
WideCharToMultiByte
(
code_page
flags
filename_w
-
1
NULL
0
NULL
NULL
)
;
if
(
num_chars
<
=
0
)
{
*
filename
=
NULL
;
errno
=
EINVAL
;
return
-
1
;
}
*
filename
=
(
char
*
)
av_malloc_array
(
num_chars
sizeof
*
*
filename
)
;
if
(
!
*
filename
)
{
errno
=
ENOMEM
;
return
-
1
;
}
WideCharToMultiByte
(
code_page
flags
filename_w
-
1
*
filename
num_chars
NULL
NULL
)
;
return
0
;
}
av_warn_unused_result
static
inline
int
wchartoutf8
(
const
wchar_t
*
filename_w
char
*
*
filename
)
{
return
wchartocp
(
CP_UTF8
filename_w
filename
)
;
}
av_warn_unused_result
static
inline
int
wchartoansi
(
const
wchar_t
*
filename_w
char
*
*
filename
)
{
return
wchartocp
(
CP_ACP
filename_w
filename
)
;
}
av_warn_unused_result
static
inline
int
utf8toansi
(
const
char
*
filename_utf8
char
*
*
filename
)
{
wchar_t
*
filename_w
=
NULL
;
int
ret
=
-
1
;
if
(
utf8towchar
(
filename_utf8
&
filename_w
)
)
return
-
1
;
if
(
!
filename_w
)
{
*
filename
=
NULL
;
return
0
;
}
ret
=
wchartoansi
(
filename_w
filename
)
;
av_free
(
filename_w
)
;
return
ret
;
}
static
inline
int
path_is_extended
(
const
wchar_t
*
path
)
{
if
(
path
[
0
]
=
=
L
'
\
\
'
&
&
(
path
[
1
]
=
=
L
'
\
\
'
|
|
path
[
1
]
=
=
L
'
?
'
)
&
&
path
[
2
]
=
=
L
'
?
'
&
&
path
[
3
]
=
=
L
'
\
\
'
)
return
1
;
return
0
;
}
static
inline
int
path_is_device_path
(
const
wchar_t
*
path
)
{
if
(
path
[
0
]
=
=
L
'
\
\
'
&
&
path
[
1
]
=
=
L
'
\
\
'
&
&
path
[
2
]
=
=
L
'
.
'
&
&
path
[
3
]
=
=
L
'
\
\
'
)
return
1
;
return
0
;
}
static
inline
int
get_full_path_name
(
wchar_t
*
*
ppath_w
)
{
int
num_chars
;
wchar_t
*
temp_w
;
num_chars
=
GetFullPathNameW
(
*
ppath_w
0
NULL
NULL
)
;
if
(
num_chars
<
=
0
)
{
errno
=
EINVAL
;
return
-
1
;
}
temp_w
=
(
wchar_t
*
)
av_calloc
(
num_chars
sizeof
(
wchar_t
)
)
;
if
(
!
temp_w
)
{
errno
=
ENOMEM
;
return
-
1
;
}
num_chars
=
GetFullPathNameW
(
*
ppath_w
num_chars
temp_w
NULL
)
;
if
(
num_chars
<
=
0
)
{
av_free
(
temp_w
)
;
errno
=
EINVAL
;
return
-
1
;
}
av_freep
(
ppath_w
)
;
*
ppath_w
=
temp_w
;
return
0
;
}
static
inline
int
path_normalize
(
wchar_t
*
*
ppath_w
)
{
int
ret
;
if
(
(
ret
=
get_full_path_name
(
ppath_w
)
)
<
0
)
return
ret
;
return
0
;
}
static
inline
int
add_extended_prefix
(
wchar_t
*
*
ppath_w
)
{
const
wchar_t
*
unc_prefix
=
L
"
\
\
\
\
?
\
\
UNC
\
\
"
;
const
wchar_t
*
extended_path_prefix
=
L
"
\
\
\
\
?
\
\
"
;
const
wchar_t
*
path_w
=
*
ppath_w
;
const
size_t
len
=
wcslen
(
path_w
)
;
wchar_t
*
temp_w
;
if
(
len
<
2
|
|
path_is_extended
(
*
ppath_w
)
|
|
path_is_device_path
(
*
ppath_w
)
)
{
return
0
;
}
if
(
path_w
[
0
]
=
=
L
'
\
\
'
&
&
path_w
[
1
]
=
=
L
'
\
\
'
)
{
temp_w
=
(
wchar_t
*
)
av_calloc
(
len
-
2
+
8
+
1
sizeof
(
wchar_t
)
)
;
if
(
!
temp_w
)
{
errno
=
ENOMEM
;
return
-
1
;
}
wcscpy
(
temp_w
unc_prefix
)
;
wcscat
(
temp_w
path_w
+
2
)
;
}
else
{
temp_w
=
(
wchar_t
*
)
av_calloc
(
len
+
4
+
1
sizeof
(
wchar_t
)
)
;
if
(
!
temp_w
)
{
errno
=
ENOMEM
;
return
-
1
;
}
wcscpy
(
temp_w
extended_path_prefix
)
;
wcscat
(
temp_w
path_w
)
;
}
av_freep
(
ppath_w
)
;
*
ppath_w
=
temp_w
;
return
0
;
}
static
inline
int
get_extended_win32_path
(
const
char
*
path
wchar_t
*
*
ppath_w
)
{
int
ret
;
size_t
len
;
if
(
(
ret
=
utf8towchar
(
path
ppath_w
)
)
<
0
)
return
ret
;
if
(
path_is_extended
(
*
ppath_w
)
)
{
return
0
;
}
if
(
(
ret
=
path_normalize
(
ppath_w
)
)
<
0
)
{
av_freep
(
ppath_w
)
;
return
ret
;
}
len
=
wcslen
(
*
ppath_w
)
;
if
(
len
>
=
MAX_PATH
)
{
if
(
(
ret
=
add_extended_prefix
(
ppath_w
)
)
<
0
)
{
av_freep
(
ppath_w
)
;
return
ret
;
}
}
return
0
;
}
#
endif
#
endif
