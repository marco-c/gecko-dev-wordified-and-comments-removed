#
include
"
.
/
vpx_config
.
h
"
#
include
"
vpx_ports
/
arm
.
h
"
#
include
"
vpx_ports
/
arm_cpudetect
.
h
"
#
if
defined
(
__APPLE__
)
#
include
<
sys
/
sysctl
.
h
>
#
endif
#
if
!
CONFIG_RUNTIME_CPU_DETECT
|
|
defined
(
__OpenBSD__
)
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
return
flags
;
}
#
elif
defined
(
__APPLE__
)
static
INLINE
int64_t
have_feature
(
const
char
*
feature
)
{
int64_t
feature_present
=
0
;
size_t
size
=
sizeof
(
feature_present
)
;
if
(
sysctlbyname
(
feature
&
feature_present
&
size
NULL
0
)
!
=
0
)
{
return
0
;
}
return
feature_present
;
}
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
#
if
HAVE_NEON_DOTPROD
if
(
have_feature
(
"
hw
.
optional
.
arm
.
FEAT_DotProd
"
)
)
{
flags
|
=
HAS_NEON_DOTPROD
;
}
#
endif
#
if
HAVE_NEON_I8MM
if
(
have_feature
(
"
hw
.
optional
.
arm
.
FEAT_I8MM
"
)
)
{
flags
|
=
HAS_NEON_I8MM
;
}
#
endif
return
flags
;
}
#
elif
defined
(
_WIN32
)
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
#
if
HAVE_NEON_DOTPROD
#
if
defined
(
PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE
)
if
(
IsProcessorFeaturePresent
(
PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE
)
)
{
flags
|
=
HAS_NEON_DOTPROD
;
}
#
endif
#
endif
return
flags
;
}
#
elif
defined
(
VPX_USE_ANDROID_CPU_FEATURES
)
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
return
flags
;
}
#
elif
defined
(
__linux__
)
#
include
<
sys
/
auxv
.
h
>
#
define
VPX_AARCH64_HWCAP_ASIMDDP
(
1
<
<
20
)
#
define
VPX_AARCH64_HWCAP_SVE
(
1
<
<
22
)
#
define
VPX_AARCH64_HWCAP2_SVE2
(
1
<
<
1
)
#
define
VPX_AARCH64_HWCAP2_I8MM
(
1
<
<
13
)
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON_DOTPROD
|
|
HAVE_SVE
unsigned
long
hwcap
=
getauxval
(
AT_HWCAP
)
;
#
endif
#
if
HAVE_NEON_I8MM
|
|
HAVE_SVE2
unsigned
long
hwcap2
=
getauxval
(
AT_HWCAP2
)
;
#
endif
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
#
if
HAVE_NEON_DOTPROD
if
(
hwcap
&
VPX_AARCH64_HWCAP_ASIMDDP
)
{
flags
|
=
HAS_NEON_DOTPROD
;
}
#
endif
#
if
HAVE_NEON_I8MM
if
(
hwcap2
&
VPX_AARCH64_HWCAP2_I8MM
)
{
flags
|
=
HAS_NEON_I8MM
;
}
#
endif
#
if
HAVE_SVE
if
(
hwcap
&
VPX_AARCH64_HWCAP_SVE
)
{
flags
|
=
HAS_SVE
;
}
#
endif
#
if
HAVE_SVE2
if
(
hwcap2
&
VPX_AARCH64_HWCAP2_SVE2
)
{
flags
|
=
HAS_SVE2
;
}
#
endif
return
flags
;
}
#
elif
defined
(
__Fuchsia__
)
#
include
<
zircon
/
features
.
h
>
#
include
<
zircon
/
syscalls
.
h
>
#
ifndef
ZX_ARM64_FEATURE_ISA_I8MM
#
define
ZX_ARM64_FEATURE_ISA_I8MM
(
(
uint32_t
)
(
1u
<
<
19
)
)
#
endif
#
ifndef
ZX_ARM64_FEATURE_ISA_SVE
#
define
ZX_ARM64_FEATURE_ISA_SVE
(
(
uint32_t
)
(
1u
<
<
20
)
)
#
endif
static
int
arm_get_cpu_caps
(
void
)
{
int
flags
=
0
;
#
if
HAVE_NEON
flags
|
=
HAS_NEON
;
#
endif
uint32_t
features
;
zx_status_t
status
=
zx_system_get_features
(
ZX_FEATURE_KIND_CPU
&
features
)
;
if
(
status
!
=
ZX_OK
)
{
return
flags
;
}
#
if
HAVE_NEON_DOTPROD
if
(
features
&
ZX_ARM64_FEATURE_ISA_DP
)
{
flags
|
=
HAS_NEON_DOTPROD
;
}
#
endif
#
if
HAVE_NEON_I8MM
if
(
features
&
ZX_ARM64_FEATURE_ISA_I8MM
)
{
flags
|
=
HAS_NEON_I8MM
;
}
#
endif
#
if
HAVE_SVE
if
(
features
&
ZX_ARM64_FEATURE_ISA_SVE
)
{
flags
|
=
HAS_SVE
;
}
#
endif
return
flags
;
}
#
else
#
error
\
"
Runtime
CPU
detection
selected
but
no
CPU
detection
method
available
"
\
"
for
your
platform
.
Rerun
configure
with
-
-
disable
-
runtime
-
cpu
-
detect
.
"
#
endif
int
arm_cpu_caps
(
void
)
{
int
flags
=
0
;
if
(
!
arm_cpu_env_flags
(
&
flags
)
)
{
flags
=
arm_get_cpu_caps
(
)
&
arm_cpu_env_mask
(
)
;
}
if
(
!
(
flags
&
HAS_NEON_DOTPROD
)
)
{
flags
&
=
~
HAS_NEON_I8MM
;
}
if
(
!
(
flags
&
HAS_NEON_DOTPROD
)
)
{
flags
&
=
~
HAS_SVE
;
}
if
(
!
(
flags
&
HAS_NEON_I8MM
)
)
{
flags
&
=
~
HAS_SVE
;
}
if
(
!
(
flags
&
HAS_SVE
)
)
{
flags
&
=
~
HAS_SVE2
;
}
return
flags
;
}
