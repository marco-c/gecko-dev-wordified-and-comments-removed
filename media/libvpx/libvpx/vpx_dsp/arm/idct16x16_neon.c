#
include
"
.
/
vpx_dsp_rtcd
.
h
"
#
include
"
vpx_dsp
/
vpx_dsp_common
.
h
"
void
vpx_idct16x16_256_add_neon_pass1
(
const
int16_t
*
input
int16_t
*
output
)
;
void
vpx_idct16x16_256_add_neon_pass2
(
const
int16_t
*
src
int16_t
*
output
int16_t
*
pass1_output
int16_t
skip_adding
uint8_t
*
dest
int
stride
)
;
#
if
CONFIG_VP9_HIGHBITDEPTH
void
vpx_idct16x16_256_add_neon_pass1_tran_low
(
const
tran_low_t
*
input
int16_t
*
output
)
;
void
vpx_idct16x16_256_add_neon_pass2_tran_low
(
const
tran_low_t
*
src
int16_t
*
output
int16_t
*
pass1_output
int16_t
skip_adding
uint8_t
*
dest
int
stride
)
;
#
else
#
define
vpx_idct16x16_256_add_neon_pass1_tran_low
\
vpx_idct16x16_256_add_neon_pass1
#
define
vpx_idct16x16_256_add_neon_pass2_tran_low
\
vpx_idct16x16_256_add_neon_pass2
#
endif
void
vpx_idct16x16_10_add_neon_pass1
(
const
tran_low_t
*
input
int16_t
*
output
)
;
void
vpx_idct16x16_10_add_neon_pass2
(
const
tran_low_t
*
src
int16_t
*
output
int16_t
*
pass1_output
)
;
#
if
HAVE_NEON_ASM
extern
void
vpx_push_neon
(
int64_t
*
store
)
;
extern
void
vpx_pop_neon
(
int64_t
*
store
)
;
#
endif
void
vpx_idct16x16_256_add_neon
(
const
tran_low_t
*
input
uint8_t
*
dest
int
stride
)
{
#
if
HAVE_NEON_ASM
int64_t
store_reg
[
8
]
;
#
endif
int16_t
pass1_output
[
16
*
16
]
=
{
0
}
;
int16_t
row_idct_output
[
16
*
16
]
=
{
0
}
;
#
if
HAVE_NEON_ASM
vpx_push_neon
(
store_reg
)
;
#
endif
vpx_idct16x16_256_add_neon_pass1_tran_low
(
input
pass1_output
)
;
vpx_idct16x16_256_add_neon_pass2_tran_low
(
input
+
1
row_idct_output
pass1_output
0
dest
stride
)
;
vpx_idct16x16_256_add_neon_pass1_tran_low
(
input
+
8
*
16
pass1_output
)
;
vpx_idct16x16_256_add_neon_pass2_tran_low
(
input
+
8
*
16
+
1
row_idct_output
+
8
pass1_output
0
dest
stride
)
;
vpx_idct16x16_256_add_neon_pass1
(
row_idct_output
pass1_output
)
;
vpx_idct16x16_256_add_neon_pass2
(
row_idct_output
+
1
row_idct_output
pass1_output
1
dest
stride
)
;
vpx_idct16x16_256_add_neon_pass1
(
row_idct_output
+
8
*
16
pass1_output
)
;
vpx_idct16x16_256_add_neon_pass2
(
row_idct_output
+
8
*
16
+
1
row_idct_output
+
8
pass1_output
1
dest
+
8
stride
)
;
#
if
HAVE_NEON_ASM
vpx_pop_neon
(
store_reg
)
;
#
endif
}
void
vpx_idct16x16_10_add_neon
(
const
tran_low_t
*
input
uint8_t
*
dest
int
stride
)
{
#
if
HAVE_NEON_ASM
int64_t
store_reg
[
8
]
;
#
endif
int16_t
pass1_output
[
16
*
16
]
=
{
0
}
;
int16_t
row_idct_output
[
16
*
16
]
=
{
0
}
;
#
if
HAVE_NEON_ASM
vpx_push_neon
(
store_reg
)
;
#
endif
vpx_idct16x16_10_add_neon_pass1
(
input
pass1_output
)
;
vpx_idct16x16_10_add_neon_pass2
(
input
+
1
row_idct_output
pass1_output
)
;
vpx_idct16x16_256_add_neon_pass1
(
row_idct_output
pass1_output
)
;
vpx_idct16x16_256_add_neon_pass2
(
row_idct_output
+
1
row_idct_output
pass1_output
1
dest
stride
)
;
vpx_idct16x16_256_add_neon_pass1
(
row_idct_output
+
8
*
16
pass1_output
)
;
vpx_idct16x16_256_add_neon_pass2
(
row_idct_output
+
8
*
16
+
1
row_idct_output
+
8
pass1_output
1
dest
+
8
stride
)
;
#
if
HAVE_NEON_ASM
vpx_pop_neon
(
store_reg
)
;
#
endif
}
