#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
algorithm
>
#
include
<
memory
>
#
include
"
third_party
/
nalloc
/
nalloc
.
h
"
#
include
"
vpx
/
vp8dx
.
h
"
#
include
"
vpx
/
vpx_decoder
.
h
"
#
include
"
vpx_ports
/
mem_ops
.
h
"
#
define
IVF_FRAME_HDR_SZ
(
4
+
8
)
/
*
4
byte
size
+
8
byte
timestamp
*
/
#
define
IVF_FILE_HDR_SZ
32
#
define
VPXD_INTERFACE
(
name
)
VPXD_INTERFACE_
(
name
)
#
define
VPXD_INTERFACE_
(
name
)
vpx_codec_
#
#
name
#
#
_dx
(
)
extern
"
C
"
void
usage_exit
(
void
)
{
exit
(
EXIT_FAILURE
)
;
}
extern
"
C
"
int
LLVMFuzzerTestOneInput
(
const
uint8_t
*
data
size_t
size
)
{
if
(
size
<
=
IVF_FILE_HDR_SZ
)
{
return
0
;
}
nalloc_init
(
nullptr
)
;
vpx_codec_ctx_t
codec
;
const
unsigned
int
threads
=
(
data
[
IVF_FILE_HDR_SZ
]
&
0x3f
)
+
1
;
vpx_codec_dec_cfg_t
cfg
=
{
threads
0
0
}
;
vpx_codec_flags_t
flags
=
0
;
if
(
(
data
[
IVF_FILE_HDR_SZ
]
&
0x40
)
!
=
0
)
{
flags
|
=
VPX_CODEC_USE_POSTPROC
;
}
vpx_codec_err_t
err
=
vpx_codec_dec_init
(
&
codec
VPXD_INTERFACE
(
DECODER
)
&
cfg
flags
)
;
if
(
err
=
=
VPX_CODEC_INCAPABLE
)
{
flags
=
0
;
if
(
vpx_codec_dec_init
(
&
codec
VPXD_INTERFACE
(
DECODER
)
&
cfg
flags
)
)
{
return
0
;
}
}
else
if
(
err
!
=
0
)
{
return
0
;
}
nalloc_start
(
data
size
)
;
if
(
threads
>
1
)
{
const
int
enable
=
(
data
[
IVF_FILE_HDR_SZ
]
&
0xa0
)
!
=
0
;
err
=
vpx_codec_control
(
&
codec
VP9D_SET_LOOP_FILTER_OPT
enable
)
;
}
data
+
=
IVF_FILE_HDR_SZ
;
size
-
=
IVF_FILE_HDR_SZ
;
int
frame_cnt
=
0
;
while
(
size
>
IVF_FRAME_HDR_SZ
)
{
size_t
frame_size
=
mem_get_le32
(
data
)
;
size
-
=
IVF_FRAME_HDR_SZ
;
data
+
=
IVF_FRAME_HDR_SZ
;
frame_size
=
std
:
:
min
(
size
frame_size
)
;
vpx_codec_stream_info_t
stream_info
;
stream_info
.
sz
=
sizeof
(
stream_info
)
;
err
=
vpx_codec_peek_stream_info
(
VPXD_INTERFACE
(
DECODER
)
data
size
&
stream_info
)
;
+
+
frame_cnt
;
if
(
flags
&
VPX_CODEC_USE_POSTPROC
)
{
if
(
frame_cnt
%
16
=
=
4
)
{
vp8_postproc_cfg_t
pp
=
{
0
0
0
}
;
if
(
vpx_codec_control
(
&
codec
VP8_SET_POSTPROC
&
pp
)
)
goto
fail
;
}
else
if
(
frame_cnt
%
16
=
=
12
)
{
vp8_postproc_cfg_t
pp
=
{
VP8_DEBLOCK
|
VP8_DEMACROBLOCK
|
VP8_MFQE
4
0
}
;
if
(
vpx_codec_control
(
&
codec
VP8_SET_POSTPROC
&
pp
)
)
goto
fail
;
}
}
err
=
vpx_codec_decode
(
&
codec
data
frame_size
nullptr
0
)
;
static_cast
<
void
>
(
err
)
;
vpx_codec_iter_t
iter
=
nullptr
;
vpx_image_t
*
img
=
nullptr
;
while
(
(
img
=
vpx_codec_get_frame
(
&
codec
&
iter
)
)
!
=
nullptr
)
{
}
data
+
=
frame_size
;
size
-
=
frame_size
;
}
fail
:
vpx_codec_destroy
(
&
codec
)
;
nalloc_end
(
)
;
return
0
;
}
