#
ifndef
VPX_TEST_REGISTER_STATE_CHECK_H_
#
define
VPX_TEST_REGISTER_STATE_CHECK_H_
#
include
"
gtest
/
gtest
.
h
"
#
include
"
.
/
vpx_config
.
h
"
#
include
"
vpx
/
vpx_integer
.
h
"
#
if
defined
(
_WIN64
)
&
&
VPX_ARCH_X86_64
#
undef
NOMINMAX
#
define
NOMINMAX
#
ifndef
WIN32_LEAN_AND_MEAN
#
define
WIN32_LEAN_AND_MEAN
#
endif
#
include
<
intrin
.
h
>
#
include
<
windows
.
h
>
#
include
<
winnt
.
h
>
inline
bool
operator
=
=
(
const
M128A
&
lhs
const
M128A
&
rhs
)
{
return
(
lhs
.
Low
=
=
rhs
.
Low
&
&
lhs
.
High
=
=
rhs
.
High
)
;
}
namespace
libvpx_test
{
class
RegisterStateCheck
{
public
:
RegisterStateCheck
(
)
{
initialized_
=
StoreRegisters
(
&
pre_context_
)
;
}
~
RegisterStateCheck
(
)
{
Check
(
)
;
}
private
:
static
bool
StoreRegisters
(
CONTEXT
*
const
context
)
{
const
HANDLE
this_thread
=
GetCurrentThread
(
)
;
EXPECT_NE
(
this_thread
nullptr
)
;
context
-
>
ContextFlags
=
CONTEXT_FLOATING_POINT
;
const
bool
context_saved
=
GetThreadContext
(
this_thread
context
)
=
=
TRUE
;
EXPECT_TRUE
(
context_saved
)
<
<
"
GetLastError
:
"
<
<
GetLastError
(
)
;
return
context_saved
;
}
void
Check
(
)
const
{
ASSERT_TRUE
(
initialized_
)
;
CONTEXT
post_context
;
ASSERT_TRUE
(
StoreRegisters
(
&
post_context
)
)
;
const
M128A
*
xmm_pre
=
&
pre_context_
.
Xmm6
;
const
M128A
*
xmm_post
=
&
post_context
.
Xmm6
;
for
(
int
i
=
6
;
i
<
=
15
;
+
+
i
)
{
EXPECT_EQ
(
*
xmm_pre
*
xmm_post
)
<
<
"
xmm
"
<
<
i
<
<
"
has
been
modified
!
"
;
+
+
xmm_pre
;
+
+
xmm_post
;
}
}
bool
initialized_
;
CONTEXT
pre_context_
;
}
;
#
define
ASM_REGISTER_STATE_CHECK
(
statement
)
\
do
{
\
{
\
libvpx_test
:
:
RegisterStateCheck
reg_check
;
\
statement
;
\
}
\
_ReadWriteBarrier
(
)
;
\
}
while
(
false
)
}
#
elif
defined
(
CONFIG_SHARED
)
&
&
defined
(
HAVE_NEON_ASM
)
&
&
\
defined
(
CONFIG_VP9
)
&
&
!
CONFIG_SHARED
&
&
HAVE_NEON_ASM
&
&
CONFIG_VP9
extern
"
C
"
{
void
vpx_push_neon
(
int64_t
*
store
)
;
}
namespace
libvpx_test
{
class
RegisterStateCheck
{
public
:
RegisterStateCheck
(
)
{
vpx_push_neon
(
pre_store_
)
;
}
~
RegisterStateCheck
(
)
{
Check
(
)
;
}
private
:
void
Check
(
)
const
{
int64_t
post_store
[
8
]
;
vpx_push_neon
(
post_store
)
;
for
(
int
i
=
0
;
i
<
8
;
+
+
i
)
{
EXPECT_EQ
(
pre_store_
[
i
]
post_store
[
i
]
)
<
<
"
d
"
<
<
i
+
8
<
<
"
has
been
modified
"
;
}
}
int64_t
pre_store_
[
8
]
;
}
;
#
if
defined
(
__GNUC__
)
#
define
ASM_REGISTER_STATE_CHECK
(
statement
)
\
do
{
\
{
\
libvpx_test
:
:
RegisterStateCheck
reg_check
;
\
statement
;
\
}
\
__asm__
volatile
(
"
"
:
:
:
"
memory
"
)
;
\
}
while
(
false
)
#
else
#
define
ASM_REGISTER_STATE_CHECK
(
statement
)
\
do
{
\
libvpx_test
:
:
RegisterStateCheck
reg_check
;
\
statement
;
\
}
while
(
false
)
#
endif
}
#
else
namespace
libvpx_test
{
class
RegisterStateCheck
{
}
;
#
define
ASM_REGISTER_STATE_CHECK
(
statement
)
statement
}
#
endif
#
if
VPX_ARCH_X86
|
|
VPX_ARCH_X86_64
#
if
defined
(
__GNUC__
)
namespace
libvpx_test
{
class
RegisterStateCheckMMX
{
public
:
RegisterStateCheckMMX
(
)
{
__asm__
volatile
(
"
fstenv
%
0
"
:
"
=
rm
"
(
pre_fpu_env_
)
)
;
}
~
RegisterStateCheckMMX
(
)
{
Check
(
)
;
}
private
:
void
Check
(
)
const
{
EXPECT_EQ
(
0xffff
pre_fpu_env_
[
4
]
)
<
<
"
FPU
was
in
an
inconsistent
state
prior
to
call
"
;
uint16_t
post_fpu_env
[
14
]
;
__asm__
volatile
(
"
fstenv
%
0
"
:
"
=
rm
"
(
post_fpu_env
)
)
;
EXPECT_EQ
(
0xffff
post_fpu_env
[
4
]
)
<
<
"
FPU
was
left
in
an
inconsistent
state
after
call
"
;
}
uint16_t
pre_fpu_env_
[
14
]
;
}
;
#
define
API_REGISTER_STATE_CHECK
(
statement
)
\
do
{
\
{
\
libvpx_test
:
:
RegisterStateCheckMMX
reg_check_mmx
;
\
ASM_REGISTER_STATE_CHECK
(
statement
)
;
\
}
\
__asm__
volatile
(
"
"
:
:
:
"
memory
"
)
;
\
}
while
(
false
)
}
#
endif
#
endif
#
ifndef
API_REGISTER_STATE_CHECK
#
define
API_REGISTER_STATE_CHECK
ASM_REGISTER_STATE_CHECK
#
endif
#
endif
