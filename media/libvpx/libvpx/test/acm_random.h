#
ifndef
VPX_TEST_ACM_RANDOM_H_
#
define
VPX_TEST_ACM_RANDOM_H_
#
include
<
assert
.
h
>
#
include
<
limits
>
#
include
"
third_party
/
googletest
/
src
/
include
/
gtest
/
gtest
.
h
"
#
include
"
vpx
/
vpx_integer
.
h
"
namespace
libvpx_test
{
class
ACMRandom
{
public
:
ACMRandom
(
)
:
random_
(
DeterministicSeed
(
)
)
{
}
explicit
ACMRandom
(
int
seed
)
:
random_
(
seed
)
{
}
void
Reset
(
int
seed
)
{
random_
.
Reseed
(
seed
)
;
}
uint16_t
Rand16
(
)
{
const
uint32_t
value
=
random_
.
Generate
(
testing
:
:
internal
:
:
Random
:
:
kMaxRange
)
;
return
(
value
>
>
15
)
&
0xffff
;
}
int32_t
Rand20Signed
(
)
{
const
uint32_t
value
=
random_
.
Generate
(
1048576
)
;
return
static_cast
<
int32_t
>
(
value
)
-
524288
;
}
int16_t
Rand16Signed
(
)
{
return
static_cast
<
int16_t
>
(
random_
.
Generate
(
65536
)
)
;
}
int16_t
Rand13Signed
(
)
{
const
uint32_t
value
=
random_
.
Generate
(
8192
)
;
return
static_cast
<
int16_t
>
(
value
)
-
4096
;
}
int16_t
Rand9Signed
(
)
{
const
uint32_t
value
=
random_
.
Generate
(
512
)
;
return
static_cast
<
int16_t
>
(
value
)
-
256
;
}
uint8_t
Rand8
(
)
{
const
uint32_t
value
=
random_
.
Generate
(
testing
:
:
internal
:
:
Random
:
:
kMaxRange
)
;
return
(
value
>
>
23
)
&
0xff
;
}
uint8_t
Rand8Extremes
(
)
{
const
uint8_t
r
=
Rand8
(
)
;
return
static_cast
<
uint8_t
>
(
(
r
<
128
)
?
r
<
<
4
:
r
>
>
4
)
;
}
uint32_t
RandRange
(
const
uint32_t
range
)
{
assert
(
range
<
=
testing
:
:
internal
:
:
Random
:
:
kMaxRange
)
;
return
random_
.
Generate
(
range
)
;
}
int
PseudoUniform
(
int
range
)
{
return
random_
.
Generate
(
range
)
;
}
int
operator
(
)
(
int
n
)
{
return
PseudoUniform
(
n
)
;
}
static
int
DeterministicSeed
(
)
{
return
0xbaba
;
}
private
:
testing
:
:
internal
:
:
Random
random_
;
}
;
}
#
endif
