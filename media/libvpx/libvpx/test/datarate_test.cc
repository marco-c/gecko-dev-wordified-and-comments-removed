#
include
"
.
/
vpx_config
.
h
"
#
include
"
third_party
/
googletest
/
src
/
include
/
gtest
/
gtest
.
h
"
#
include
"
test
/
codec_factory
.
h
"
#
include
"
test
/
encode_test_driver
.
h
"
#
include
"
test
/
i420_video_source
.
h
"
#
include
"
test
/
util
.
h
"
#
include
"
test
/
y4m_video_source
.
h
"
#
include
"
vpx
/
vpx_codec
.
h
"
namespace
{
class
DatarateTestLarge
:
public
:
:
libvpx_test
:
:
EncoderTest
public
:
:
libvpx_test
:
:
CodecTestWithParam
<
libvpx_test
:
:
TestMode
>
{
public
:
DatarateTestLarge
(
)
:
EncoderTest
(
GET_PARAM
(
0
)
)
{
}
virtual
~
DatarateTestLarge
(
)
{
}
protected
:
virtual
void
SetUp
(
)
{
InitializeConfig
(
)
;
SetMode
(
GET_PARAM
(
1
)
)
;
ResetModel
(
)
;
}
virtual
void
ResetModel
(
)
{
last_pts_
=
0
;
bits_in_buffer_model_
=
cfg_
.
rc_target_bitrate
*
cfg_
.
rc_buf_initial_sz
;
frame_number_
=
0
;
first_drop_
=
0
;
bits_total_
=
0
;
duration_
=
0
.
0
;
denoiser_offon_test_
=
0
;
denoiser_offon_period_
=
-
1
;
}
virtual
void
PreEncodeFrameHook
(
:
:
libvpx_test
:
:
VideoSource
*
video
:
:
libvpx_test
:
:
Encoder
*
encoder
)
{
if
(
video
-
>
frame
(
)
=
=
0
)
encoder
-
>
Control
(
VP8E_SET_NOISE_SENSITIVITY
denoiser_on_
)
;
if
(
denoiser_offon_test_
)
{
ASSERT_GT
(
denoiser_offon_period_
0
)
<
<
"
denoiser_offon_period_
is
not
positive
.
"
;
if
(
(
video
-
>
frame
(
)
+
1
)
%
denoiser_offon_period_
=
=
0
)
{
denoiser_on_
^
=
1
;
}
encoder
-
>
Control
(
VP8E_SET_NOISE_SENSITIVITY
denoiser_on_
)
;
}
const
vpx_rational_t
tb
=
video
-
>
timebase
(
)
;
timebase_
=
static_cast
<
double
>
(
tb
.
num
)
/
tb
.
den
;
duration_
=
0
;
}
virtual
void
FramePktHook
(
const
vpx_codec_cx_pkt_t
*
pkt
)
{
vpx_codec_pts_t
duration
=
pkt
-
>
data
.
frame
.
pts
-
last_pts_
;
if
(
last_pts_
=
=
0
)
duration
=
1
;
bits_in_buffer_model_
+
=
static_cast
<
int64_t
>
(
duration
*
timebase_
*
cfg_
.
rc_target_bitrate
*
1000
)
;
const
bool
key_frame
=
(
pkt
-
>
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
?
true
:
false
;
if
(
!
key_frame
)
{
ASSERT_GE
(
bits_in_buffer_model_
0
)
<
<
"
Buffer
Underrun
at
frame
"
<
<
pkt
-
>
data
.
frame
.
pts
;
}
const
int64_t
frame_size_in_bits
=
pkt
-
>
data
.
frame
.
sz
*
8
;
bits_in_buffer_model_
-
=
frame_size_in_bits
;
bits_total_
+
=
frame_size_in_bits
;
if
(
!
first_drop_
&
&
duration
>
1
)
first_drop_
=
last_pts_
+
1
;
last_pts_
=
pkt
-
>
data
.
frame
.
pts
;
bits_in_last_frame_
=
frame_size_in_bits
;
+
+
frame_number_
;
}
virtual
void
EndPassHook
(
void
)
{
if
(
bits_total_
)
{
const
double
file_size_in_kb
=
bits_total_
/
1000
.
;
duration_
=
(
last_pts_
+
1
)
*
timebase_
;
effective_datarate_
=
(
bits_total_
-
bits_in_last_frame_
)
/
1000
.
0
/
(
cfg_
.
rc_buf_initial_sz
/
1000
.
0
+
duration_
)
;
file_datarate_
=
file_size_in_kb
/
duration_
;
}
}
vpx_codec_pts_t
last_pts_
;
int64_t
bits_in_buffer_model_
;
double
timebase_
;
int
frame_number_
;
vpx_codec_pts_t
first_drop_
;
int64_t
bits_total_
;
double
duration_
;
double
file_datarate_
;
double
effective_datarate_
;
int64_t
bits_in_last_frame_
;
int
denoiser_on_
;
int
denoiser_offon_test_
;
int
denoiser_offon_period_
;
}
;
#
if
CONFIG_TEMPORAL_DENOISING
TEST_P
(
DatarateTestLarge
DenoiserLevels
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_dropframe_thresh
=
1
;
cfg_
.
rc_max_quantizer
=
56
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
140
)
;
for
(
int
j
=
1
;
j
<
5
;
+
+
j
)
{
denoiser_on_
=
j
;
cfg_
.
rc_target_bitrate
=
300
;
ResetModel
(
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
cfg_
.
rc_target_bitrate
effective_datarate_
*
0
.
95
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
!
"
;
ASSERT_LE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
1
.
3
)
<
<
"
The
datarate
for
the
file
missed
the
target
!
"
;
}
}
TEST_P
(
DatarateTestLarge
DenoiserOffOn
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_dropframe_thresh
=
1
;
cfg_
.
rc_max_quantizer
=
56
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
299
)
;
cfg_
.
rc_target_bitrate
=
300
;
ResetModel
(
)
;
denoiser_on_
=
0
;
denoiser_offon_test_
=
1
;
denoiser_offon_period_
=
100
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
cfg_
.
rc_target_bitrate
effective_datarate_
*
0
.
95
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
!
"
;
ASSERT_LE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
1
.
3
)
<
<
"
The
datarate
for
the
file
missed
the
target
!
"
;
}
#
endif
TEST_P
(
DatarateTestLarge
BasicBufferModel
)
{
denoiser_on_
=
0
;
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_dropframe_thresh
=
1
;
cfg_
.
rc_max_quantizer
=
56
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
140
)
;
for
(
int
i
=
100
;
i
<
800
;
i
+
=
200
)
{
cfg_
.
rc_target_bitrate
=
i
;
ResetModel
(
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
cfg_
.
rc_target_bitrate
effective_datarate_
*
0
.
95
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
!
"
;
ASSERT_LE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
1
.
3
)
<
<
"
The
datarate
for
the
file
missed
the
target
!
"
;
}
}
TEST_P
(
DatarateTestLarge
ChangingDropFrameThresh
)
{
denoiser_on_
=
0
;
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_max_quantizer
=
36
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
rc_target_bitrate
=
200
;
cfg_
.
kf_mode
=
VPX_KF_DISABLED
;
const
int
frame_count
=
40
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
frame_count
)
;
const
int
kDropFrameThreshTestStep
=
30
;
vpx_codec_pts_t
last_drop
=
frame_count
;
for
(
int
i
=
1
;
i
<
91
;
i
+
=
kDropFrameThreshTestStep
)
{
cfg_
.
rc_dropframe_thresh
=
i
;
ResetModel
(
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_LE
(
first_drop_
last_drop
)
<
<
"
The
first
dropped
frame
for
drop_thresh
"
<
<
i
<
<
"
>
first
dropped
frame
for
drop_thresh
"
<
<
i
-
kDropFrameThreshTestStep
;
last_drop
=
first_drop_
;
}
}
class
DatarateTestVP9Large
:
public
:
:
libvpx_test
:
:
EncoderTest
public
:
:
libvpx_test
:
:
CodecTestWith2Params
<
libvpx_test
:
:
TestMode
int
>
{
public
:
DatarateTestVP9Large
(
)
:
EncoderTest
(
GET_PARAM
(
0
)
)
{
}
protected
:
virtual
~
DatarateTestVP9Large
(
)
{
}
virtual
void
SetUp
(
)
{
InitializeConfig
(
)
;
SetMode
(
GET_PARAM
(
1
)
)
;
set_cpu_used_
=
GET_PARAM
(
2
)
;
ResetModel
(
)
;
}
virtual
void
ResetModel
(
)
{
last_pts_
=
0
;
bits_in_buffer_model_
=
cfg_
.
rc_target_bitrate
*
cfg_
.
rc_buf_initial_sz
;
frame_number_
=
0
;
tot_frame_number_
=
0
;
first_drop_
=
0
;
num_drops_
=
0
;
denoiser_on_
=
0
;
for
(
int
i
=
0
;
i
<
3
;
+
+
i
)
{
bits_total_
[
i
]
=
0
;
}
denoiser_offon_test_
=
0
;
denoiser_offon_period_
=
-
1
;
}
int
SetFrameFlags
(
int
frame_num
int
num_temp_layers
)
{
int
frame_flags
=
0
;
if
(
num_temp_layers
=
=
2
)
{
if
(
frame_num
%
2
=
=
0
)
{
frame_flags
=
VP8_EFLAG_NO_REF_GF
|
VP8_EFLAG_NO_UPD_GF
|
VP8_EFLAG_NO_UPD_ARF
;
}
else
{
frame_flags
=
VP8_EFLAG_NO_UPD_ARF
|
VP8_EFLAG_NO_UPD_LAST
|
VP8_EFLAG_NO_UPD_ENTROPY
;
}
}
else
if
(
num_temp_layers
=
=
3
)
{
if
(
frame_num
%
4
=
=
0
)
{
frame_flags
=
VP8_EFLAG_NO_UPD_GF
|
VP8_EFLAG_NO_UPD_ARF
|
VP8_EFLAG_NO_REF_GF
;
}
else
if
(
(
frame_num
-
2
)
%
4
=
=
0
)
{
frame_flags
=
VP8_EFLAG_NO_UPD_ARF
|
VP8_EFLAG_NO_UPD_LAST
;
}
else
if
(
(
frame_num
-
1
)
%
2
=
=
0
)
{
frame_flags
=
VP8_EFLAG_NO_UPD_GF
|
VP8_EFLAG_NO_UPD_ARF
|
VP8_EFLAG_NO_UPD_LAST
;
}
}
return
frame_flags
;
}
int
SetLayerId
(
int
frame_num
int
num_temp_layers
)
{
int
layer_id
=
0
;
if
(
num_temp_layers
=
=
2
)
{
if
(
frame_num
%
2
=
=
0
)
{
layer_id
=
0
;
}
else
{
layer_id
=
1
;
}
}
else
if
(
num_temp_layers
=
=
3
)
{
if
(
frame_num
%
4
=
=
0
)
{
layer_id
=
0
;
}
else
if
(
(
frame_num
-
2
)
%
4
=
=
0
)
{
layer_id
=
1
;
}
else
if
(
(
frame_num
-
1
)
%
2
=
=
0
)
{
layer_id
=
2
;
}
}
return
layer_id
;
}
virtual
void
PreEncodeFrameHook
(
:
:
libvpx_test
:
:
VideoSource
*
video
:
:
libvpx_test
:
:
Encoder
*
encoder
)
{
if
(
video
-
>
frame
(
)
=
=
0
)
encoder
-
>
Control
(
VP8E_SET_CPUUSED
set_cpu_used_
)
;
if
(
denoiser_offon_test_
)
{
ASSERT_GT
(
denoiser_offon_period_
0
)
<
<
"
denoiser_offon_period_
is
not
positive
.
"
;
if
(
(
video
-
>
frame
(
)
+
1
)
%
denoiser_offon_period_
=
=
0
)
{
denoiser_on_
^
=
1
;
}
}
encoder
-
>
Control
(
VP9E_SET_NOISE_SENSITIVITY
denoiser_on_
)
;
if
(
cfg_
.
ts_number_layers
>
1
)
{
if
(
video
-
>
frame
(
)
=
=
0
)
{
encoder
-
>
Control
(
VP9E_SET_SVC
1
)
;
}
vpx_svc_layer_id_t
layer_id
;
layer_id
.
spatial_layer_id
=
0
;
frame_flags_
=
SetFrameFlags
(
video
-
>
frame
(
)
cfg_
.
ts_number_layers
)
;
layer_id
.
temporal_layer_id
=
SetLayerId
(
video
-
>
frame
(
)
cfg_
.
ts_number_layers
)
;
encoder
-
>
Control
(
VP9E_SET_SVC_LAYER_ID
&
layer_id
)
;
}
const
vpx_rational_t
tb
=
video
-
>
timebase
(
)
;
timebase_
=
static_cast
<
double
>
(
tb
.
num
)
/
tb
.
den
;
duration_
=
0
;
}
virtual
void
FramePktHook
(
const
vpx_codec_cx_pkt_t
*
pkt
)
{
vpx_codec_pts_t
duration
=
pkt
-
>
data
.
frame
.
pts
-
last_pts_
;
if
(
duration
>
1
)
{
if
(
!
first_drop_
)
first_drop_
=
last_pts_
+
1
;
num_drops_
+
=
static_cast
<
int
>
(
duration
-
1
)
;
tot_frame_number_
+
=
static_cast
<
int
>
(
duration
-
1
)
;
}
int
layer
=
SetLayerId
(
tot_frame_number_
cfg_
.
ts_number_layers
)
;
bits_in_buffer_model_
+
=
static_cast
<
int64_t
>
(
duration
*
timebase_
*
cfg_
.
rc_target_bitrate
*
1000
)
;
ASSERT_GE
(
bits_in_buffer_model_
0
)
<
<
"
Buffer
Underrun
at
frame
"
<
<
pkt
-
>
data
.
frame
.
pts
;
const
size_t
frame_size_in_bits
=
pkt
-
>
data
.
frame
.
sz
*
8
;
for
(
int
i
=
layer
;
i
<
static_cast
<
int
>
(
cfg_
.
ts_number_layers
)
;
+
+
i
)
{
bits_total_
[
i
]
+
=
frame_size_in_bits
;
}
last_pts_
=
pkt
-
>
data
.
frame
.
pts
;
+
+
frame_number_
;
+
+
tot_frame_number_
;
}
virtual
void
EndPassHook
(
void
)
{
for
(
int
layer
=
0
;
layer
<
static_cast
<
int
>
(
cfg_
.
ts_number_layers
)
;
+
+
layer
)
{
duration_
=
(
last_pts_
+
1
)
*
timebase_
;
if
(
bits_total_
[
layer
]
)
{
effective_datarate_
[
layer
]
=
(
bits_total_
[
layer
]
/
1000
.
0
)
/
duration_
;
}
}
}
vpx_codec_pts_t
last_pts_
;
double
timebase_
;
int
frame_number_
;
int
tot_frame_number_
;
int64_t
bits_total_
[
3
]
;
double
duration_
;
double
effective_datarate_
[
3
]
;
int
set_cpu_used_
;
int64_t
bits_in_buffer_model_
;
vpx_codec_pts_t
first_drop_
;
int
num_drops_
;
int
denoiser_on_
;
int
denoiser_offon_test_
;
int
denoiser_offon_period_
;
}
;
TEST_P
(
DatarateTestVP9Large
BasicRateTargetingVBR
)
{
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
g_error_resilient
=
0
;
cfg_
.
rc_end_usage
=
VPX_VBR
;
cfg_
.
g_lag_in_frames
=
0
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
300
)
;
for
(
int
i
=
400
;
i
<
=
800
;
i
+
=
400
)
{
cfg_
.
rc_target_bitrate
=
i
;
ResetModel
(
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
0
.
75
)
<
<
"
The
datarate
for
the
file
is
lower
than
target
by
too
much
!
"
;
ASSERT_LE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
1
.
25
)
<
<
"
The
datarate
for
the
file
is
greater
than
target
by
too
much
!
"
;
}
}
TEST_P
(
DatarateTestVP9Large
BasicRateTargeting
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_dropframe_thresh
=
1
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
140
)
;
for
(
int
i
=
150
;
i
<
800
;
i
+
=
200
)
{
cfg_
.
rc_target_bitrate
=
i
;
ResetModel
(
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
0
.
85
)
<
<
"
The
datarate
for
the
file
is
lower
than
target
by
too
much
!
"
;
ASSERT_LE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
1
.
15
)
<
<
"
The
datarate
for
the
file
is
greater
than
target
by
too
much
!
"
;
}
}
TEST_P
(
DatarateTestVP9Large
BasicRateTargeting444
)
{
:
:
libvpx_test
:
:
Y4mVideoSource
video
(
"
rush_hour_444
.
y4m
"
0
140
)
;
cfg_
.
g_profile
=
1
;
cfg_
.
g_timebase
=
video
.
timebase
(
)
;
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_dropframe_thresh
=
1
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
for
(
int
i
=
250
;
i
<
900
;
i
+
=
200
)
{
cfg_
.
rc_target_bitrate
=
i
;
ResetModel
(
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
static_cast
<
double
>
(
cfg_
.
rc_target_bitrate
)
effective_datarate_
[
0
]
*
0
.
85
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
by
too
much
!
"
;
ASSERT_LE
(
static_cast
<
double
>
(
cfg_
.
rc_target_bitrate
)
effective_datarate_
[
0
]
*
1
.
15
)
<
<
"
The
datarate
for
the
file
missed
the
target
!
"
<
<
cfg_
.
rc_target_bitrate
<
<
"
"
<
<
effective_datarate_
;
}
}
TEST_P
(
DatarateTestVP9Large
ChangingDropFrameThresh
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_undershoot_pct
=
20
;
cfg_
.
rc_undershoot_pct
=
20
;
cfg_
.
rc_dropframe_thresh
=
10
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
50
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
rc_target_bitrate
=
200
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
kf_max_dist
=
9999
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
140
)
;
const
int
kDropFrameThreshTestStep
=
30
;
vpx_codec_pts_t
last_drop
=
140
;
int
last_num_drops
=
0
;
for
(
int
i
=
10
;
i
<
100
;
i
+
=
kDropFrameThreshTestStep
)
{
cfg_
.
rc_dropframe_thresh
=
i
;
ResetModel
(
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
0
.
85
)
<
<
"
The
datarate
for
the
file
is
lower
than
target
by
too
much
!
"
;
ASSERT_LE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
1
.
15
)
<
<
"
The
datarate
for
the
file
is
greater
than
target
by
too
much
!
"
;
ASSERT_LE
(
first_drop_
last_drop
)
<
<
"
The
first
dropped
frame
for
drop_thresh
"
<
<
i
<
<
"
>
first
dropped
frame
for
drop_thresh
"
<
<
i
-
kDropFrameThreshTestStep
;
ASSERT_GE
(
num_drops_
last_num_drops
*
0
.
85
)
<
<
"
The
number
of
dropped
frames
for
drop_thresh
"
<
<
i
<
<
"
<
number
of
dropped
frames
for
drop_thresh
"
<
<
i
-
kDropFrameThreshTestStep
;
last_drop
=
first_drop_
;
last_num_drops
=
num_drops_
;
}
}
TEST_P
(
DatarateTestVP9Large
BasicRateTargeting2TemporalLayers
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_dropframe_thresh
=
1
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
ss_number_layers
=
1
;
cfg_
.
ts_number_layers
=
2
;
cfg_
.
ts_rate_decimator
[
0
]
=
2
;
cfg_
.
ts_rate_decimator
[
1
]
=
1
;
cfg_
.
temporal_layering_mode
=
VP9E_TEMPORAL_LAYERING_MODE_BYPASS
;
if
(
deadline_
=
=
VPX_DL_REALTIME
)
cfg_
.
g_error_resilient
=
1
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
200
)
;
for
(
int
i
=
200
;
i
<
=
800
;
i
+
=
200
)
{
cfg_
.
rc_target_bitrate
=
i
;
ResetModel
(
)
;
cfg_
.
layer_target_bitrate
[
0
]
=
60
*
cfg_
.
rc_target_bitrate
/
100
;
cfg_
.
layer_target_bitrate
[
1
]
=
cfg_
.
rc_target_bitrate
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
for
(
int
j
=
0
;
j
<
static_cast
<
int
>
(
cfg_
.
ts_number_layers
)
;
+
+
j
)
{
ASSERT_GE
(
effective_datarate_
[
j
]
cfg_
.
layer_target_bitrate
[
j
]
*
0
.
85
)
<
<
"
The
datarate
for
the
file
is
lower
than
target
by
too
much
"
"
for
layer
:
"
<
<
j
;
ASSERT_LE
(
effective_datarate_
[
j
]
cfg_
.
layer_target_bitrate
[
j
]
*
1
.
15
)
<
<
"
The
datarate
for
the
file
is
greater
than
target
by
too
much
"
"
for
layer
:
"
<
<
j
;
}
}
}
TEST_P
(
DatarateTestVP9Large
BasicRateTargeting3TemporalLayers
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_dropframe_thresh
=
1
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
ss_number_layers
=
1
;
cfg_
.
ts_number_layers
=
3
;
cfg_
.
ts_rate_decimator
[
0
]
=
4
;
cfg_
.
ts_rate_decimator
[
1
]
=
2
;
cfg_
.
ts_rate_decimator
[
2
]
=
1
;
cfg_
.
temporal_layering_mode
=
VP9E_TEMPORAL_LAYERING_MODE_BYPASS
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
200
)
;
for
(
int
i
=
200
;
i
<
=
800
;
i
+
=
200
)
{
cfg_
.
rc_target_bitrate
=
i
;
ResetModel
(
)
;
cfg_
.
layer_target_bitrate
[
0
]
=
40
*
cfg_
.
rc_target_bitrate
/
100
;
cfg_
.
layer_target_bitrate
[
1
]
=
60
*
cfg_
.
rc_target_bitrate
/
100
;
cfg_
.
layer_target_bitrate
[
2
]
=
cfg_
.
rc_target_bitrate
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
for
(
int
j
=
0
;
j
<
static_cast
<
int
>
(
cfg_
.
ts_number_layers
)
;
+
+
j
)
{
ASSERT_GE
(
effective_datarate_
[
j
]
cfg_
.
layer_target_bitrate
[
j
]
*
0
.
75
)
<
<
"
The
datarate
for
the
file
is
lower
than
target
by
too
much
"
"
for
layer
:
"
<
<
j
;
ASSERT_LE
(
effective_datarate_
[
j
]
cfg_
.
layer_target_bitrate
[
j
]
*
1
.
25
)
<
<
"
The
datarate
for
the
file
is
greater
than
target
by
too
much
"
"
for
layer
:
"
<
<
j
;
}
}
}
TEST_P
(
DatarateTestVP9Large
BasicRateTargeting3TemporalLayersFrameDropping
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_dropframe_thresh
=
20
;
cfg_
.
rc_max_quantizer
=
45
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
ss_number_layers
=
1
;
cfg_
.
ts_number_layers
=
3
;
cfg_
.
ts_rate_decimator
[
0
]
=
4
;
cfg_
.
ts_rate_decimator
[
1
]
=
2
;
cfg_
.
ts_rate_decimator
[
2
]
=
1
;
cfg_
.
temporal_layering_mode
=
VP9E_TEMPORAL_LAYERING_MODE_BYPASS
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
200
)
;
cfg_
.
rc_target_bitrate
=
200
;
ResetModel
(
)
;
cfg_
.
layer_target_bitrate
[
0
]
=
40
*
cfg_
.
rc_target_bitrate
/
100
;
cfg_
.
layer_target_bitrate
[
1
]
=
60
*
cfg_
.
rc_target_bitrate
/
100
;
cfg_
.
layer_target_bitrate
[
2
]
=
cfg_
.
rc_target_bitrate
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
for
(
int
j
=
0
;
j
<
static_cast
<
int
>
(
cfg_
.
ts_number_layers
)
;
+
+
j
)
{
ASSERT_GE
(
effective_datarate_
[
j
]
cfg_
.
layer_target_bitrate
[
j
]
*
0
.
85
)
<
<
"
The
datarate
for
the
file
is
lower
than
target
by
too
much
"
"
for
layer
:
"
<
<
j
;
ASSERT_LE
(
effective_datarate_
[
j
]
cfg_
.
layer_target_bitrate
[
j
]
*
1
.
15
)
<
<
"
The
datarate
for
the
file
is
greater
than
target
by
too
much
"
"
for
layer
:
"
<
<
j
;
ASSERT_GE
(
num_drops_
20
)
;
ASSERT_LE
(
num_drops_
130
)
;
}
}
#
if
CONFIG_VP9_TEMPORAL_DENOISING
TEST_P
(
DatarateTestVP9Large
DenoiserLevels
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_dropframe_thresh
=
1
;
cfg_
.
rc_min_quantizer
=
2
;
cfg_
.
rc_max_quantizer
=
56
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
140
)
;
cfg_
.
rc_target_bitrate
=
300
;
ResetModel
(
)
;
denoiser_on_
=
1
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
0
.
85
)
<
<
"
The
datarate
for
the
file
is
lower
than
target
by
too
much
!
"
;
ASSERT_LE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
1
.
15
)
<
<
"
The
datarate
for
the
file
is
greater
than
target
by
too
much
!
"
;
}
TEST_P
(
DatarateTestVP9Large
DenoiserOffOn
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_dropframe_thresh
=
1
;
cfg_
.
rc_min_quantizer
=
2
;
cfg_
.
rc_max_quantizer
=
56
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
299
)
;
cfg_
.
rc_target_bitrate
=
300
;
ResetModel
(
)
;
denoiser_on_
=
0
;
denoiser_offon_test_
=
1
;
denoiser_offon_period_
=
100
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
0
.
85
)
<
<
"
The
datarate
for
the
file
is
lower
than
target
by
too
much
!
"
;
ASSERT_LE
(
effective_datarate_
[
0
]
cfg_
.
rc_target_bitrate
*
1
.
15
)
<
<
"
The
datarate
for
the
file
is
greater
than
target
by
too
much
!
"
;
}
#
endif
class
DatarateOnePassCbrSvc
:
public
:
:
libvpx_test
:
:
EncoderTest
public
:
:
libvpx_test
:
:
CodecTestWith2Params
<
libvpx_test
:
:
TestMode
int
>
{
public
:
DatarateOnePassCbrSvc
(
)
:
EncoderTest
(
GET_PARAM
(
0
)
)
{
}
virtual
~
DatarateOnePassCbrSvc
(
)
{
}
protected
:
virtual
void
SetUp
(
)
{
InitializeConfig
(
)
;
SetMode
(
GET_PARAM
(
1
)
)
;
speed_setting_
=
GET_PARAM
(
2
)
;
ResetModel
(
)
;
}
virtual
void
ResetModel
(
)
{
last_pts_
=
0
;
bits_in_buffer_model_
=
cfg_
.
rc_target_bitrate
*
cfg_
.
rc_buf_initial_sz
;
frame_number_
=
0
;
first_drop_
=
0
;
bits_total_
=
0
;
duration_
=
0
.
0
;
mismatch_psnr_
=
0
.
0
;
mismatch_nframes_
=
0
;
}
virtual
void
BeginPassHook
(
unsigned
int
)
{
}
virtual
void
PreEncodeFrameHook
(
:
:
libvpx_test
:
:
VideoSource
*
video
:
:
libvpx_test
:
:
Encoder
*
encoder
)
{
if
(
video
-
>
frame
(
)
=
=
0
)
{
int
i
;
for
(
i
=
0
;
i
<
VPX_MAX_LAYERS
;
+
+
i
)
{
svc_params_
.
max_quantizers
[
i
]
=
63
;
svc_params_
.
min_quantizers
[
i
]
=
0
;
}
encoder
-
>
Control
(
VP9E_SET_SVC
1
)
;
encoder
-
>
Control
(
VP9E_SET_SVC_PARAMETERS
&
svc_params_
)
;
encoder
-
>
Control
(
VP8E_SET_CPUUSED
speed_setting_
)
;
encoder
-
>
Control
(
VP9E_SET_TILE_COLUMNS
0
)
;
encoder
-
>
Control
(
VP8E_SET_MAX_INTRA_BITRATE_PCT
300
)
;
encoder
-
>
Control
(
VP9E_SET_TILE_COLUMNS
(
cfg_
.
g_threads
>
>
1
)
)
;
}
const
vpx_rational_t
tb
=
video
-
>
timebase
(
)
;
timebase_
=
static_cast
<
double
>
(
tb
.
num
)
/
tb
.
den
;
duration_
=
0
;
}
virtual
void
FramePktHook
(
const
vpx_codec_cx_pkt_t
*
pkt
)
{
vpx_codec_pts_t
duration
=
pkt
-
>
data
.
frame
.
pts
-
last_pts_
;
if
(
last_pts_
=
=
0
)
duration
=
1
;
bits_in_buffer_model_
+
=
static_cast
<
int64_t
>
(
duration
*
timebase_
*
cfg_
.
rc_target_bitrate
*
1000
)
;
const
bool
key_frame
=
(
pkt
-
>
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
?
true
:
false
;
if
(
!
key_frame
)
{
ASSERT_GE
(
bits_in_buffer_model_
0
)
<
<
"
Buffer
Underrun
at
frame
"
<
<
pkt
-
>
data
.
frame
.
pts
;
}
const
size_t
frame_size_in_bits
=
pkt
-
>
data
.
frame
.
sz
*
8
;
bits_in_buffer_model_
-
=
frame_size_in_bits
;
bits_total_
+
=
frame_size_in_bits
;
if
(
!
first_drop_
&
&
duration
>
1
)
first_drop_
=
last_pts_
+
1
;
last_pts_
=
pkt
-
>
data
.
frame
.
pts
;
bits_in_last_frame_
=
frame_size_in_bits
;
+
+
frame_number_
;
}
virtual
void
EndPassHook
(
void
)
{
if
(
bits_total_
)
{
const
double
file_size_in_kb
=
bits_total_
/
1000
.
;
duration_
=
(
last_pts_
+
1
)
*
timebase_
;
file_datarate_
=
file_size_in_kb
/
duration_
;
}
}
virtual
void
MismatchHook
(
const
vpx_image_t
*
img1
const
vpx_image_t
*
img2
)
{
double
mismatch_psnr
=
compute_psnr
(
img1
img2
)
;
mismatch_psnr_
+
=
mismatch_psnr
;
+
+
mismatch_nframes_
;
}
unsigned
int
GetMismatchFrames
(
)
{
return
mismatch_nframes_
;
}
vpx_codec_pts_t
last_pts_
;
int64_t
bits_in_buffer_model_
;
double
timebase_
;
int
frame_number_
;
vpx_codec_pts_t
first_drop_
;
int64_t
bits_total_
;
double
duration_
;
double
file_datarate_
;
size_t
bits_in_last_frame_
;
vpx_svc_extra_cfg_t
svc_params_
;
int
speed_setting_
;
double
mismatch_psnr_
;
int
mismatch_nframes_
;
}
;
static
void
assign_layer_bitrates
(
vpx_codec_enc_cfg_t
*
const
enc_cfg
const
vpx_svc_extra_cfg_t
*
svc_params
int
spatial_layers
int
temporal_layers
int
temporal_layering_mode
)
{
int
sl
spatial_layer_target
;
float
total
=
0
;
float
alloc_ratio
[
VPX_MAX_LAYERS
]
=
{
0
}
;
for
(
sl
=
0
;
sl
<
spatial_layers
;
+
+
sl
)
{
if
(
svc_params
-
>
scaling_factor_den
[
sl
]
>
0
)
{
alloc_ratio
[
sl
]
=
(
float
)
(
svc_params
-
>
scaling_factor_num
[
sl
]
*
1
.
0
/
svc_params
-
>
scaling_factor_den
[
sl
]
)
;
total
+
=
alloc_ratio
[
sl
]
;
}
}
for
(
sl
=
0
;
sl
<
spatial_layers
;
+
+
sl
)
{
enc_cfg
-
>
ss_target_bitrate
[
sl
]
=
spatial_layer_target
=
(
unsigned
int
)
(
enc_cfg
-
>
rc_target_bitrate
*
alloc_ratio
[
sl
]
/
total
)
;
const
int
index
=
sl
*
temporal_layers
;
if
(
temporal_layering_mode
=
=
3
)
{
enc_cfg
-
>
layer_target_bitrate
[
index
]
=
spatial_layer_target
>
>
1
;
enc_cfg
-
>
layer_target_bitrate
[
index
+
1
]
=
(
spatial_layer_target
>
>
1
)
+
(
spatial_layer_target
>
>
2
)
;
enc_cfg
-
>
layer_target_bitrate
[
index
+
2
]
=
spatial_layer_target
;
}
else
if
(
temporal_layering_mode
=
=
2
)
{
enc_cfg
-
>
layer_target_bitrate
[
index
]
=
spatial_layer_target
*
2
/
3
;
enc_cfg
-
>
layer_target_bitrate
[
index
+
1
]
=
spatial_layer_target
;
}
}
}
TEST_P
(
DatarateOnePassCbrSvc
OnePassCbrSvc2SpatialLayers
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
ss_number_layers
=
2
;
cfg_
.
ts_number_layers
=
3
;
cfg_
.
ts_rate_decimator
[
0
]
=
4
;
cfg_
.
ts_rate_decimator
[
1
]
=
2
;
cfg_
.
ts_rate_decimator
[
2
]
=
1
;
cfg_
.
g_error_resilient
=
1
;
cfg_
.
g_threads
=
1
;
cfg_
.
temporal_layering_mode
=
3
;
svc_params_
.
scaling_factor_num
[
0
]
=
144
;
svc_params_
.
scaling_factor_den
[
0
]
=
288
;
svc_params_
.
scaling_factor_num
[
1
]
=
288
;
svc_params_
.
scaling_factor_den
[
1
]
=
288
;
cfg_
.
rc_dropframe_thresh
=
10
;
cfg_
.
kf_max_dist
=
9999
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
200
)
;
for
(
int
i
=
200
;
i
<
=
800
;
i
+
=
200
)
{
cfg_
.
rc_target_bitrate
=
i
;
ResetModel
(
)
;
assign_layer_bitrates
(
&
cfg_
&
svc_params_
cfg_
.
ss_number_layers
cfg_
.
ts_number_layers
cfg_
.
temporal_layering_mode
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
0
.
85
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
by
too
much
!
"
;
ASSERT_LE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
1
.
15
)
<
<
"
The
datarate
for
the
file
is
lower
than
the
target
by
too
much
!
"
;
EXPECT_EQ
(
static_cast
<
unsigned
int
>
(
0
)
GetMismatchFrames
(
)
)
;
}
}
TEST_P
(
DatarateOnePassCbrSvc
OnePassCbrSvc2SpatialLayersSmallKf
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
ss_number_layers
=
2
;
cfg_
.
ts_number_layers
=
3
;
cfg_
.
ts_rate_decimator
[
0
]
=
4
;
cfg_
.
ts_rate_decimator
[
1
]
=
2
;
cfg_
.
ts_rate_decimator
[
2
]
=
1
;
cfg_
.
g_error_resilient
=
1
;
cfg_
.
g_threads
=
1
;
cfg_
.
temporal_layering_mode
=
3
;
svc_params_
.
scaling_factor_num
[
0
]
=
144
;
svc_params_
.
scaling_factor_den
[
0
]
=
288
;
svc_params_
.
scaling_factor_num
[
1
]
=
288
;
svc_params_
.
scaling_factor_den
[
1
]
=
288
;
cfg_
.
rc_dropframe_thresh
=
10
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
200
)
;
cfg_
.
rc_target_bitrate
=
400
;
for
(
int
j
=
64
;
j
<
=
67
;
j
+
+
)
{
cfg_
.
kf_max_dist
=
j
;
ResetModel
(
)
;
assign_layer_bitrates
(
&
cfg_
&
svc_params_
cfg_
.
ss_number_layers
cfg_
.
ts_number_layers
cfg_
.
temporal_layering_mode
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
0
.
85
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
by
too
much
!
"
;
ASSERT_LE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
1
.
15
)
<
<
"
The
datarate
for
the
file
is
lower
than
the
target
by
too
much
!
"
;
EXPECT_EQ
(
static_cast
<
unsigned
int
>
(
0
)
GetMismatchFrames
(
)
)
;
}
}
TEST_P
(
DatarateOnePassCbrSvc
OnePassCbrSvc2SpatialLayers4threads
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
ss_number_layers
=
2
;
cfg_
.
ts_number_layers
=
3
;
cfg_
.
ts_rate_decimator
[
0
]
=
4
;
cfg_
.
ts_rate_decimator
[
1
]
=
2
;
cfg_
.
ts_rate_decimator
[
2
]
=
1
;
cfg_
.
g_error_resilient
=
1
;
cfg_
.
g_threads
=
4
;
cfg_
.
temporal_layering_mode
=
3
;
svc_params_
.
scaling_factor_num
[
0
]
=
144
;
svc_params_
.
scaling_factor_den
[
0
]
=
288
;
svc_params_
.
scaling_factor_num
[
1
]
=
288
;
svc_params_
.
scaling_factor_den
[
1
]
=
288
;
cfg_
.
rc_dropframe_thresh
=
10
;
cfg_
.
kf_max_dist
=
9999
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
niklas_1280_720_30
.
y4m
"
1280
720
30
1
0
300
)
;
cfg_
.
rc_target_bitrate
=
800
;
ResetModel
(
)
;
assign_layer_bitrates
(
&
cfg_
&
svc_params_
cfg_
.
ss_number_layers
cfg_
.
ts_number_layers
cfg_
.
temporal_layering_mode
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
0
.
85
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
by
too
much
!
"
;
ASSERT_LE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
1
.
15
)
<
<
"
The
datarate
for
the
file
is
lower
than
the
target
by
too
much
!
"
;
EXPECT_EQ
(
static_cast
<
unsigned
int
>
(
0
)
GetMismatchFrames
(
)
)
;
}
TEST_P
(
DatarateOnePassCbrSvc
OnePassCbrSvc3SpatialLayers
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
ss_number_layers
=
3
;
cfg_
.
ts_number_layers
=
3
;
cfg_
.
ts_rate_decimator
[
0
]
=
4
;
cfg_
.
ts_rate_decimator
[
1
]
=
2
;
cfg_
.
ts_rate_decimator
[
2
]
=
1
;
cfg_
.
g_error_resilient
=
1
;
cfg_
.
g_threads
=
1
;
cfg_
.
temporal_layering_mode
=
3
;
svc_params_
.
scaling_factor_num
[
0
]
=
72
;
svc_params_
.
scaling_factor_den
[
0
]
=
288
;
svc_params_
.
scaling_factor_num
[
1
]
=
144
;
svc_params_
.
scaling_factor_den
[
1
]
=
288
;
svc_params_
.
scaling_factor_num
[
2
]
=
288
;
svc_params_
.
scaling_factor_den
[
2
]
=
288
;
cfg_
.
rc_dropframe_thresh
=
10
;
cfg_
.
kf_max_dist
=
9999
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
niklas_1280_720_30
.
y4m
"
1280
720
30
1
0
300
)
;
cfg_
.
rc_target_bitrate
=
800
;
ResetModel
(
)
;
assign_layer_bitrates
(
&
cfg_
&
svc_params_
cfg_
.
ss_number_layers
cfg_
.
ts_number_layers
cfg_
.
temporal_layering_mode
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
0
.
85
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
by
too
much
!
"
;
ASSERT_LE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
1
.
22
)
<
<
"
The
datarate
for
the
file
is
lower
than
the
target
by
too
much
!
"
;
EXPECT_EQ
(
static_cast
<
unsigned
int
>
(
0
)
GetMismatchFrames
(
)
)
;
}
TEST_P
(
DatarateOnePassCbrSvc
OnePassCbrSvc3SpatialLayersSmallKf
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
ss_number_layers
=
3
;
cfg_
.
ts_number_layers
=
3
;
cfg_
.
ts_rate_decimator
[
0
]
=
4
;
cfg_
.
ts_rate_decimator
[
1
]
=
2
;
cfg_
.
ts_rate_decimator
[
2
]
=
1
;
cfg_
.
g_error_resilient
=
1
;
cfg_
.
g_threads
=
1
;
cfg_
.
temporal_layering_mode
=
3
;
svc_params_
.
scaling_factor_num
[
0
]
=
72
;
svc_params_
.
scaling_factor_den
[
0
]
=
288
;
svc_params_
.
scaling_factor_num
[
1
]
=
144
;
svc_params_
.
scaling_factor_den
[
1
]
=
288
;
svc_params_
.
scaling_factor_num
[
2
]
=
288
;
svc_params_
.
scaling_factor_den
[
2
]
=
288
;
cfg_
.
rc_dropframe_thresh
=
10
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
niklas_1280_720_30
.
y4m
"
1280
720
30
1
0
300
)
;
cfg_
.
rc_target_bitrate
=
800
;
for
(
int
j
=
32
;
j
<
=
35
;
j
+
+
)
{
cfg_
.
kf_max_dist
=
j
;
ResetModel
(
)
;
assign_layer_bitrates
(
&
cfg_
&
svc_params_
cfg_
.
ss_number_layers
cfg_
.
ts_number_layers
cfg_
.
temporal_layering_mode
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
0
.
85
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
by
too
much
!
"
;
ASSERT_LE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
1
.
30
)
<
<
"
The
datarate
for
the
file
is
lower
than
the
target
by
too
much
!
"
;
EXPECT_EQ
(
static_cast
<
unsigned
int
>
(
0
)
GetMismatchFrames
(
)
)
;
}
}
TEST_P
(
DatarateOnePassCbrSvc
OnePassCbrSvc3SpatialLayers4threads
)
{
cfg_
.
rc_buf_initial_sz
=
500
;
cfg_
.
rc_buf_optimal_sz
=
500
;
cfg_
.
rc_buf_sz
=
1000
;
cfg_
.
rc_min_quantizer
=
0
;
cfg_
.
rc_max_quantizer
=
63
;
cfg_
.
rc_end_usage
=
VPX_CBR
;
cfg_
.
g_lag_in_frames
=
0
;
cfg_
.
ss_number_layers
=
3
;
cfg_
.
ts_number_layers
=
3
;
cfg_
.
ts_rate_decimator
[
0
]
=
4
;
cfg_
.
ts_rate_decimator
[
1
]
=
2
;
cfg_
.
ts_rate_decimator
[
2
]
=
1
;
cfg_
.
g_error_resilient
=
1
;
cfg_
.
g_threads
=
4
;
cfg_
.
temporal_layering_mode
=
3
;
svc_params_
.
scaling_factor_num
[
0
]
=
72
;
svc_params_
.
scaling_factor_den
[
0
]
=
288
;
svc_params_
.
scaling_factor_num
[
1
]
=
144
;
svc_params_
.
scaling_factor_den
[
1
]
=
288
;
svc_params_
.
scaling_factor_num
[
2
]
=
288
;
svc_params_
.
scaling_factor_den
[
2
]
=
288
;
cfg_
.
rc_dropframe_thresh
=
10
;
cfg_
.
kf_max_dist
=
9999
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
niklas_1280_720_30
.
y4m
"
1280
720
30
1
0
300
)
;
cfg_
.
rc_target_bitrate
=
800
;
ResetModel
(
)
;
assign_layer_bitrates
(
&
cfg_
&
svc_params_
cfg_
.
ss_number_layers
cfg_
.
ts_number_layers
cfg_
.
temporal_layering_mode
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
ASSERT_GE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
0
.
85
)
<
<
"
The
datarate
for
the
file
exceeds
the
target
by
too
much
!
"
;
ASSERT_LE
(
cfg_
.
rc_target_bitrate
file_datarate_
*
1
.
22
)
<
<
"
The
datarate
for
the
file
is
lower
than
the
target
by
too
much
!
"
;
EXPECT_EQ
(
static_cast
<
unsigned
int
>
(
0
)
GetMismatchFrames
(
)
)
;
}
VP8_INSTANTIATE_TEST_CASE
(
DatarateTestLarge
ALL_TEST_MODES
)
;
VP9_INSTANTIATE_TEST_CASE
(
DatarateTestVP9Large
:
:
testing
:
:
Values
(
:
:
libvpx_test
:
:
kOnePassGood
:
:
libvpx_test
:
:
kRealTime
)
:
:
testing
:
:
Range
(
2
9
)
)
;
VP9_INSTANTIATE_TEST_CASE
(
DatarateOnePassCbrSvc
:
:
testing
:
:
Values
(
:
:
libvpx_test
:
:
kRealTime
)
:
:
testing
:
:
Range
(
5
9
)
)
;
}
