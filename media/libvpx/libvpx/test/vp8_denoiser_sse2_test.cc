#
include
<
math
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
third_party
/
googletest
/
src
/
include
/
gtest
/
gtest
.
h
"
#
include
"
test
/
acm_random
.
h
"
#
include
"
test
/
clear_system_state
.
h
"
#
include
"
test
/
register_state_check
.
h
"
#
include
"
test
/
util
.
h
"
#
include
"
vp8
/
encoder
/
denoising
.
h
"
#
include
"
vp8
/
common
/
reconinter
.
h
"
#
include
"
vpx
/
vpx_integer
.
h
"
#
include
"
vpx_mem
/
vpx_mem
.
h
"
using
libvpx_test
:
:
ACMRandom
;
namespace
{
const
int
kNumPixels
=
16
*
16
;
class
VP8DenoiserTest
:
public
:
:
testing
:
:
TestWithParam
<
int
>
{
public
:
virtual
~
VP8DenoiserTest
(
)
{
}
virtual
void
SetUp
(
)
{
increase_denoising_
=
GetParam
(
)
;
}
virtual
void
TearDown
(
)
{
libvpx_test
:
:
ClearSystemState
(
)
;
}
protected
:
int
increase_denoising_
;
}
;
#
if
defined
(
__GNUC__
)
&
&
__GNUC__
>
=
8
TEST_P
(
VP8DenoiserTest
DISABLED_BitexactCheck
)
{
#
else
TEST_P
(
VP8DenoiserTest
BitexactCheck
)
{
#
endif
ACMRandom
rnd
(
ACMRandom
:
:
DeterministicSeed
(
)
)
;
const
int
count_test_block
=
4000
;
const
int
stride
=
16
;
DECLARE_ALIGNED
(
16
uint8_t
sig_block_c
[
kNumPixels
]
)
;
DECLARE_ALIGNED
(
16
uint8_t
sig_block_sse2
[
kNumPixels
]
)
;
DECLARE_ALIGNED
(
16
uint8_t
mc_avg_block
[
kNumPixels
]
)
;
DECLARE_ALIGNED
(
16
uint8_t
avg_block_c
[
kNumPixels
]
)
;
DECLARE_ALIGNED
(
16
uint8_t
avg_block_sse2
[
kNumPixels
]
)
;
for
(
int
i
=
0
;
i
<
count_test_block
;
+
+
i
)
{
const
int
motion_magnitude_ran
=
rnd
.
Rand8
(
)
%
static_cast
<
int
>
(
MOTION_MAGNITUDE_THRESHOLD
*
1
.
2
)
;
for
(
int
j
=
0
;
j
<
kNumPixels
;
+
+
j
)
{
int
temp
=
0
;
sig_block_sse2
[
j
]
=
sig_block_c
[
j
]
=
rnd
.
Rand8
(
)
;
temp
=
sig_block_c
[
j
]
+
(
rnd
.
Rand8
(
)
%
2
=
=
0
?
-
1
:
1
)
*
(
rnd
.
Rand8
(
)
%
20
)
;
mc_avg_block
[
j
]
=
(
temp
<
0
)
?
0
:
(
(
temp
>
255
)
?
255
:
temp
)
;
}
ASM_REGISTER_STATE_CHECK
(
vp8_denoiser_filter_c
(
mc_avg_block
stride
avg_block_c
stride
sig_block_c
stride
motion_magnitude_ran
increase_denoising_
)
)
;
ASM_REGISTER_STATE_CHECK
(
vp8_denoiser_filter_sse2
(
mc_avg_block
stride
avg_block_sse2
stride
sig_block_sse2
stride
motion_magnitude_ran
increase_denoising_
)
)
;
for
(
int
h
=
0
;
h
<
16
;
+
+
h
)
{
for
(
int
w
=
0
;
w
<
16
;
+
+
w
)
{
ASSERT_EQ
(
avg_block_c
[
h
*
stride
+
w
]
avg_block_sse2
[
h
*
stride
+
w
]
)
;
}
}
ASM_REGISTER_STATE_CHECK
(
vp8_denoiser_filter_uv_c
(
mc_avg_block
stride
avg_block_c
stride
sig_block_c
stride
motion_magnitude_ran
increase_denoising_
)
)
;
ASM_REGISTER_STATE_CHECK
(
vp8_denoiser_filter_uv_sse2
(
mc_avg_block
stride
avg_block_sse2
stride
sig_block_sse2
stride
motion_magnitude_ran
increase_denoising_
)
)
;
for
(
int
h
=
0
;
h
<
16
;
+
+
h
)
{
for
(
int
w
=
0
;
w
<
16
;
+
+
w
)
{
ASSERT_EQ
(
avg_block_c
[
h
*
stride
+
w
]
avg_block_sse2
[
h
*
stride
+
w
]
)
;
}
}
}
}
INSTANTIATE_TEST_SUITE_P
(
SSE2
VP8DenoiserTest
:
:
testing
:
:
Values
(
0
1
)
)
;
}
