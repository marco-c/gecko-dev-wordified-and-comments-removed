#
include
<
climits
>
#
include
<
vector
>
#
include
"
third_party
/
googletest
/
src
/
include
/
gtest
/
gtest
.
h
"
#
include
"
test
/
codec_factory
.
h
"
#
include
"
test
/
encode_test_driver
.
h
"
#
include
"
test
/
i420_video_source
.
h
"
#
include
"
test
/
util
.
h
"
namespace
{
class
KeyframeTest
:
public
:
:
libvpx_test
:
:
EncoderTest
public
:
:
libvpx_test
:
:
CodecTestWithParam
<
libvpx_test
:
:
TestMode
>
{
protected
:
KeyframeTest
(
)
:
EncoderTest
(
GET_PARAM
(
0
)
)
{
}
virtual
~
KeyframeTest
(
)
{
}
virtual
void
SetUp
(
)
{
InitializeConfig
(
)
;
SetMode
(
GET_PARAM
(
1
)
)
;
kf_count_
=
0
;
kf_count_max_
=
INT_MAX
;
kf_do_force_kf_
=
false
;
set_cpu_used_
=
0
;
}
virtual
void
PreEncodeFrameHook
(
:
:
libvpx_test
:
:
VideoSource
*
video
:
:
libvpx_test
:
:
Encoder
*
encoder
)
{
if
(
kf_do_force_kf_
)
{
frame_flags_
=
(
video
-
>
frame
(
)
%
3
)
?
0
:
VPX_EFLAG_FORCE_KF
;
}
if
(
set_cpu_used_
&
&
video
-
>
frame
(
)
=
=
0
)
{
encoder
-
>
Control
(
VP8E_SET_CPUUSED
set_cpu_used_
)
;
}
}
virtual
void
FramePktHook
(
const
vpx_codec_cx_pkt_t
*
pkt
)
{
if
(
pkt
-
>
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
{
kf_pts_list_
.
push_back
(
pkt
-
>
data
.
frame
.
pts
)
;
kf_count_
+
+
;
abort_
|
=
kf_count_
>
kf_count_max_
;
}
}
bool
kf_do_force_kf_
;
int
kf_count_
;
int
kf_count_max_
;
std
:
:
vector
<
vpx_codec_pts_t
>
kf_pts_list_
;
int
set_cpu_used_
;
}
;
TEST_P
(
KeyframeTest
TestRandomVideoSource
)
{
kf_count_max_
=
2
;
:
:
libvpx_test
:
:
RandomVideoSource
video
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
if
(
GET_PARAM
(
1
)
>
0
)
{
EXPECT_GT
(
kf_count_
1
)
;
}
}
TEST_P
(
KeyframeTest
TestDisableKeyframes
)
{
cfg_
.
kf_mode
=
VPX_KF_DISABLED
;
kf_count_max_
=
1
;
:
:
libvpx_test
:
:
RandomVideoSource
video
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
EXPECT_EQ
(
1
kf_count_
)
;
}
TEST_P
(
KeyframeTest
TestForceKeyframe
)
{
cfg_
.
kf_mode
=
VPX_KF_DISABLED
;
kf_do_force_kf_
=
true
;
:
:
libvpx_test
:
:
DummyVideoSource
video
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
for
(
std
:
:
vector
<
vpx_codec_pts_t
>
:
:
const_iterator
iter
=
kf_pts_list_
.
begin
(
)
;
iter
!
=
kf_pts_list_
.
end
(
)
;
+
+
iter
)
{
ASSERT_EQ
(
0
*
iter
%
3
)
<
<
"
Unexpected
keyframe
at
frame
"
<
<
*
iter
;
}
}
TEST_P
(
KeyframeTest
TestKeyframeMaxDistance
)
{
cfg_
.
kf_max_dist
=
25
;
:
:
libvpx_test
:
:
DummyVideoSource
video
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
for
(
std
:
:
vector
<
vpx_codec_pts_t
>
:
:
const_iterator
iter
=
kf_pts_list_
.
begin
(
)
;
iter
!
=
kf_pts_list_
.
end
(
)
;
+
+
iter
)
{
ASSERT_EQ
(
0
*
iter
%
25
)
<
<
"
Unexpected
keyframe
at
frame
"
<
<
*
iter
;
}
}
TEST_P
(
KeyframeTest
TestAutoKeyframe
)
{
cfg_
.
kf_mode
=
VPX_KF_AUTO
;
kf_do_force_kf_
=
false
;
if
(
deadline_
=
=
VPX_DL_REALTIME
)
set_cpu_used_
=
-
11
;
:
:
libvpx_test
:
:
I420VideoSource
video
(
"
hantro_collage_w352h288
.
yuv
"
352
288
30
1
0
40
)
;
ASSERT_NO_FATAL_FAILURE
(
RunLoop
(
&
video
)
)
;
if
(
GET_PARAM
(
1
)
>
0
)
{
EXPECT_EQ
(
2u
kf_pts_list_
.
size
(
)
)
<
<
"
Not
the
right
number
of
keyframes
"
;
}
for
(
std
:
:
vector
<
vpx_codec_pts_t
>
:
:
const_iterator
iter
=
kf_pts_list_
.
begin
(
)
;
iter
!
=
kf_pts_list_
.
end
(
)
;
+
+
iter
)
{
if
(
deadline_
=
=
VPX_DL_REALTIME
&
&
*
iter
>
0
)
EXPECT_EQ
(
0
(
*
iter
-
1
)
%
30
)
<
<
"
Unexpected
keyframe
at
frame
"
<
<
*
iter
;
else
EXPECT_EQ
(
0
*
iter
%
30
)
<
<
"
Unexpected
keyframe
at
frame
"
<
<
*
iter
;
}
}
VP8_INSTANTIATE_TEST_CASE
(
KeyframeTest
ALL_TEST_MODES
)
;
}
