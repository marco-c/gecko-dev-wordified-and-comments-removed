#
include
<
climits
>
#
include
<
cstdint
>
#
include
"
vpx
/
vpx_image
.
h
"
#
include
"
third_party
/
googletest
/
src
/
include
/
gtest
/
gtest
.
h
"
TEST
(
VpxImageTest
VpxImgWrapInvalidAlign
)
{
const
int
kWidth
=
128
;
const
int
kHeight
=
128
;
unsigned
char
buf
[
kWidth
*
kHeight
*
3
]
;
vpx_image_t
img
;
unsigned
char
empty
[
]
=
"
"
;
img
.
img_data
=
empty
;
img
.
img_data_owner
=
1
;
vpx_img_fmt_t
format
=
VPX_IMG_FMT_I444
;
unsigned
int
align
=
31
;
EXPECT_EQ
(
vpx_img_wrap
(
&
img
format
kWidth
kHeight
align
buf
)
nullptr
)
;
}
TEST
(
VpxImageTest
VpxImgSetRectOverflow
)
{
const
int
kWidth
=
128
;
const
int
kHeight
=
128
;
unsigned
char
buf
[
kWidth
*
kHeight
*
3
]
;
vpx_image_t
img
;
vpx_img_fmt_t
format
=
VPX_IMG_FMT_I444
;
unsigned
int
align
=
32
;
EXPECT_EQ
(
vpx_img_wrap
(
&
img
format
kWidth
kHeight
align
buf
)
&
img
)
;
EXPECT_EQ
(
vpx_img_set_rect
(
&
img
0
0
kWidth
kHeight
)
0
)
;
EXPECT_NE
(
vpx_img_set_rect
(
&
img
static_cast
<
unsigned
int
>
(
-
1
)
static_cast
<
unsigned
int
>
(
-
1
)
kWidth
kHeight
)
0
)
;
}
TEST
(
VpxImageTest
VpxImgAllocNone
)
{
const
int
kWidth
=
128
;
const
int
kHeight
=
128
;
vpx_image_t
img
;
vpx_img_fmt_t
format
=
VPX_IMG_FMT_NONE
;
unsigned
int
align
=
32
;
ASSERT_EQ
(
vpx_img_alloc
(
&
img
format
kWidth
kHeight
align
)
nullptr
)
;
}
TEST
(
VpxImageTest
VpxImgAllocNv12
)
{
const
int
kWidth
=
128
;
const
int
kHeight
=
128
;
vpx_image_t
img
;
vpx_img_fmt_t
format
=
VPX_IMG_FMT_NV12
;
unsigned
int
align
=
32
;
EXPECT_EQ
(
vpx_img_alloc
(
&
img
format
kWidth
kHeight
align
)
&
img
)
;
EXPECT_EQ
(
img
.
stride
[
VPX_PLANE_U
]
img
.
stride
[
VPX_PLANE_Y
]
)
;
EXPECT_EQ
(
img
.
stride
[
VPX_PLANE_V
]
img
.
stride
[
VPX_PLANE_U
]
)
;
EXPECT_EQ
(
img
.
planes
[
VPX_PLANE_V
]
img
.
planes
[
VPX_PLANE_U
]
+
1
)
;
vpx_img_free
(
&
img
)
;
}
TEST
(
VpxImageTest
VpxImgAllocHugeWidth
)
{
vpx_image_t
*
image
=
vpx_img_alloc
(
nullptr
VPX_IMG_FMT_I42016
0x80000000
1
1
)
;
ASSERT_EQ
(
image
nullptr
)
;
image
=
vpx_img_alloc
(
nullptr
VPX_IMG_FMT_I420
0x80000000
1
1
)
;
ASSERT_EQ
(
image
nullptr
)
;
image
=
vpx_img_alloc
(
nullptr
VPX_IMG_FMT_I420
UINT_MAX
1
1
)
;
ASSERT_EQ
(
image
nullptr
)
;
image
=
vpx_img_alloc
(
nullptr
VPX_IMG_FMT_I420
0x7ffffffe
1
1
)
;
if
(
image
)
{
vpx_img_free
(
image
)
;
}
image
=
vpx_img_alloc
(
nullptr
VPX_IMG_FMT_I420
285245883
64
1
)
;
if
(
image
)
{
vpx_img_free
(
image
)
;
}
image
=
vpx_img_alloc
(
nullptr
VPX_IMG_FMT_NV12
285245883
64
1
)
;
if
(
image
)
{
vpx_img_free
(
image
)
;
}
image
=
vpx_img_alloc
(
nullptr
VPX_IMG_FMT_YV12
285245883
64
1
)
;
if
(
image
)
{
vpx_img_free
(
image
)
;
}
image
=
vpx_img_alloc
(
nullptr
VPX_IMG_FMT_I42016
65536
2
1
)
;
if
(
image
)
{
uint16_t
*
y_plane
=
reinterpret_cast
<
uint16_t
*
>
(
image
-
>
planes
[
VPX_PLANE_Y
]
)
;
y_plane
[
0
]
=
0
;
y_plane
[
image
-
>
d_w
-
1
]
=
0
;
vpx_img_free
(
image
)
;
}
image
=
vpx_img_alloc
(
nullptr
VPX_IMG_FMT_I42016
285245883
2
1
)
;
if
(
image
)
{
uint16_t
*
y_plane
=
reinterpret_cast
<
uint16_t
*
>
(
image
-
>
planes
[
VPX_PLANE_Y
]
)
;
y_plane
[
0
]
=
0
;
y_plane
[
image
-
>
d_w
-
1
]
=
0
;
vpx_img_free
(
image
)
;
}
}
