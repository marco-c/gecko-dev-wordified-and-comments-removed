#
ifndef
GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
#
define
GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
#
include
<
functional
>
#
include
<
ostream
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
gtest
/
internal
/
gtest
-
internal
.
h
"
#
include
"
gtest
/
internal
/
gtest
-
port
.
h
"
#
if
GTEST_HAS_ABSL
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
absl
/
types
/
optional
.
h
"
#
include
"
absl
/
types
/
variant
.
h
"
#
endif
namespace
testing
{
namespace
internal2
{
GTEST_API_
void
PrintBytesInObjectTo
(
const
unsigned
char
*
obj_bytes
size_t
count
:
:
std
:
:
ostream
*
os
)
;
enum
TypeKind
{
kProtobuf
kConvertibleToInteger
#
if
GTEST_INTERNAL_HAS_STRING_VIEW
kConvertibleToStringView
#
endif
kOtherType
}
;
template
<
typename
T
TypeKind
kTypeKind
>
class
TypeWithoutFormatter
{
public
:
static
void
PrintValue
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
PrintBytesInObjectTo
(
static_cast
<
const
unsigned
char
*
>
(
reinterpret_cast
<
const
void
*
>
(
std
:
:
addressof
(
value
)
)
)
sizeof
(
value
)
os
)
;
}
}
;
const
size_t
kProtobufOneLinerMaxLength
=
50
;
template
<
typename
T
>
class
TypeWithoutFormatter
<
T
kProtobuf
>
{
public
:
static
void
PrintValue
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
std
:
:
string
pretty_str
=
value
.
ShortDebugString
(
)
;
if
(
pretty_str
.
length
(
)
>
kProtobufOneLinerMaxLength
)
{
pretty_str
=
"
\
n
"
+
value
.
DebugString
(
)
;
}
*
os
<
<
(
"
<
"
+
pretty_str
+
"
>
"
)
;
}
}
;
template
<
typename
T
>
class
TypeWithoutFormatter
<
T
kConvertibleToInteger
>
{
public
:
static
void
PrintValue
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
const
internal
:
:
BiggestInt
kBigInt
=
value
;
*
os
<
<
kBigInt
;
}
}
;
#
if
GTEST_INTERNAL_HAS_STRING_VIEW
template
<
typename
T
>
class
TypeWithoutFormatter
<
T
kConvertibleToStringView
>
{
public
:
static
void
PrintValue
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
;
}
;
#
endif
template
<
typename
Char
typename
CharTraits
typename
T
>
:
:
std
:
:
basic_ostream
<
Char
CharTraits
>
&
operator
<
<
(
:
:
std
:
:
basic_ostream
<
Char
CharTraits
>
&
os
const
T
&
x
)
{
TypeWithoutFormatter
<
T
(
internal
:
:
IsAProtocolMessage
<
T
>
:
:
value
?
kProtobuf
:
std
:
:
is_convertible
<
const
T
&
internal
:
:
BiggestInt
>
:
:
value
?
kConvertibleToInteger
:
#
if
GTEST_INTERNAL_HAS_STRING_VIEW
std
:
:
is_convertible
<
const
T
&
internal
:
:
StringView
>
:
:
value
?
kConvertibleToStringView
:
#
endif
kOtherType
)
>
:
:
PrintValue
(
x
&
os
)
;
return
os
;
}
}
}
namespace
testing_internal
{
template
<
typename
T
>
void
DefaultPrintNonContainerTo
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
using
:
:
testing
:
:
internal2
:
:
operator
<
<
;
*
os
<
<
value
;
}
}
namespace
testing
{
namespace
internal
{
template
<
typename
ToPrint
typename
OtherOperand
>
class
FormatForComparison
{
public
:
static
:
:
std
:
:
string
Format
(
const
ToPrint
&
value
)
{
return
:
:
testing
:
:
PrintToString
(
value
)
;
}
}
;
template
<
typename
ToPrint
size_t
N
typename
OtherOperand
>
class
FormatForComparison
<
ToPrint
[
N
]
OtherOperand
>
{
public
:
static
:
:
std
:
:
string
Format
(
const
ToPrint
*
value
)
{
return
FormatForComparison
<
const
ToPrint
*
OtherOperand
>
:
:
Format
(
value
)
;
}
}
;
#
define
GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_
(
CharType
)
\
template
<
typename
OtherOperand
>
\
class
FormatForComparison
<
CharType
*
OtherOperand
>
{
\
public
:
\
static
:
:
std
:
:
string
Format
(
CharType
*
value
)
{
\
return
:
:
testing
:
:
PrintToString
(
static_cast
<
const
void
*
>
(
value
)
)
;
\
}
\
}
GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_
(
char
)
;
GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_
(
const
char
)
;
GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_
(
wchar_t
)
;
GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_
(
const
wchar_t
)
;
#
undef
GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_
#
define
GTEST_IMPL_FORMAT_C_STRING_AS_STRING_
(
CharType
OtherStringType
)
\
template
<
>
\
class
FormatForComparison
<
CharType
*
OtherStringType
>
{
\
public
:
\
static
:
:
std
:
:
string
Format
(
CharType
*
value
)
{
\
return
:
:
testing
:
:
PrintToString
(
value
)
;
\
}
\
}
GTEST_IMPL_FORMAT_C_STRING_AS_STRING_
(
char
:
:
std
:
:
string
)
;
GTEST_IMPL_FORMAT_C_STRING_AS_STRING_
(
const
char
:
:
std
:
:
string
)
;
#
if
GTEST_HAS_STD_WSTRING
GTEST_IMPL_FORMAT_C_STRING_AS_STRING_
(
wchar_t
:
:
std
:
:
wstring
)
;
GTEST_IMPL_FORMAT_C_STRING_AS_STRING_
(
const
wchar_t
:
:
std
:
:
wstring
)
;
#
endif
#
undef
GTEST_IMPL_FORMAT_C_STRING_AS_STRING_
template
<
typename
T1
typename
T2
>
std
:
:
string
FormatForComparisonFailureMessage
(
const
T1
&
value
const
T2
&
)
{
return
FormatForComparison
<
T1
T2
>
:
:
Format
(
value
)
;
}
template
<
typename
T
>
class
UniversalPrinter
;
template
<
typename
T
>
void
UniversalPrint
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
;
enum
DefaultPrinterType
{
kPrintContainer
kPrintPointer
kPrintFunctionPointer
kPrintOther
}
;
template
<
DefaultPrinterType
type
>
struct
WrapPrinterType
{
}
;
template
<
typename
C
>
void
DefaultPrintTo
(
WrapPrinterType
<
kPrintContainer
>
const
C
&
container
:
:
std
:
:
ostream
*
os
)
{
const
size_t
kMaxCount
=
32
;
*
os
<
<
'
{
'
;
size_t
count
=
0
;
for
(
typename
C
:
:
const_iterator
it
=
container
.
begin
(
)
;
it
!
=
container
.
end
(
)
;
+
+
it
+
+
count
)
{
if
(
count
>
0
)
{
*
os
<
<
'
'
;
if
(
count
=
=
kMaxCount
)
{
*
os
<
<
"
.
.
.
"
;
break
;
}
}
*
os
<
<
'
'
;
internal
:
:
UniversalPrint
(
*
it
os
)
;
}
if
(
count
>
0
)
{
*
os
<
<
'
'
;
}
*
os
<
<
'
}
'
;
}
template
<
typename
T
>
void
DefaultPrintTo
(
WrapPrinterType
<
kPrintPointer
>
T
*
p
:
:
std
:
:
ostream
*
os
)
{
if
(
p
=
=
nullptr
)
{
*
os
<
<
"
NULL
"
;
}
else
{
*
os
<
<
p
;
}
}
template
<
typename
T
>
void
DefaultPrintTo
(
WrapPrinterType
<
kPrintFunctionPointer
>
T
*
p
:
:
std
:
:
ostream
*
os
)
{
if
(
p
=
=
nullptr
)
{
*
os
<
<
"
NULL
"
;
}
else
{
*
os
<
<
reinterpret_cast
<
const
void
*
>
(
p
)
;
}
}
template
<
typename
T
>
void
DefaultPrintTo
(
WrapPrinterType
<
kPrintOther
>
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
:
:
testing_internal
:
:
DefaultPrintNonContainerTo
(
value
os
)
;
}
template
<
typename
T
>
void
PrintTo
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
DefaultPrintTo
(
WrapPrinterType
<
(
sizeof
(
IsContainerTest
<
T
>
(
0
)
)
=
=
sizeof
(
IsContainer
)
)
&
&
!
IsRecursiveContainer
<
T
>
:
:
value
?
kPrintContainer
:
!
std
:
:
is_pointer
<
T
>
:
:
value
?
kPrintOther
:
std
:
:
is_function
<
typename
std
:
:
remove_pointer
<
T
>
:
:
type
>
:
:
value
?
kPrintFunctionPointer
:
kPrintPointer
>
(
)
value
os
)
;
}
GTEST_API_
void
PrintTo
(
unsigned
char
c
:
:
std
:
:
ostream
*
os
)
;
GTEST_API_
void
PrintTo
(
signed
char
c
:
:
std
:
:
ostream
*
os
)
;
inline
void
PrintTo
(
char
c
:
:
std
:
:
ostream
*
os
)
{
PrintTo
(
static_cast
<
unsigned
char
>
(
c
)
os
)
;
}
inline
void
PrintTo
(
bool
x
:
:
std
:
:
ostream
*
os
)
{
*
os
<
<
(
x
?
"
true
"
:
"
false
"
)
;
}
GTEST_API_
void
PrintTo
(
wchar_t
wc
:
:
std
:
:
ostream
*
os
)
;
GTEST_API_
void
PrintTo
(
const
char
*
s
:
:
std
:
:
ostream
*
os
)
;
inline
void
PrintTo
(
char
*
s
:
:
std
:
:
ostream
*
os
)
{
PrintTo
(
ImplicitCast_
<
const
char
*
>
(
s
)
os
)
;
}
inline
void
PrintTo
(
const
signed
char
*
s
:
:
std
:
:
ostream
*
os
)
{
PrintTo
(
ImplicitCast_
<
const
void
*
>
(
s
)
os
)
;
}
inline
void
PrintTo
(
signed
char
*
s
:
:
std
:
:
ostream
*
os
)
{
PrintTo
(
ImplicitCast_
<
const
void
*
>
(
s
)
os
)
;
}
inline
void
PrintTo
(
const
unsigned
char
*
s
:
:
std
:
:
ostream
*
os
)
{
PrintTo
(
ImplicitCast_
<
const
void
*
>
(
s
)
os
)
;
}
inline
void
PrintTo
(
unsigned
char
*
s
:
:
std
:
:
ostream
*
os
)
{
PrintTo
(
ImplicitCast_
<
const
void
*
>
(
s
)
os
)
;
}
#
if
!
defined
(
_MSC_VER
)
|
|
defined
(
_NATIVE_WCHAR_T_DEFINED
)
GTEST_API_
void
PrintTo
(
const
wchar_t
*
s
:
:
std
:
:
ostream
*
os
)
;
inline
void
PrintTo
(
wchar_t
*
s
:
:
std
:
:
ostream
*
os
)
{
PrintTo
(
ImplicitCast_
<
const
wchar_t
*
>
(
s
)
os
)
;
}
#
endif
template
<
typename
T
>
void
PrintRawArrayTo
(
const
T
a
[
]
size_t
count
:
:
std
:
:
ostream
*
os
)
{
UniversalPrint
(
a
[
0
]
os
)
;
for
(
size_t
i
=
1
;
i
!
=
count
;
i
+
+
)
{
*
os
<
<
"
"
;
UniversalPrint
(
a
[
i
]
os
)
;
}
}
GTEST_API_
void
PrintStringTo
(
const
:
:
std
:
:
string
&
s
:
:
std
:
:
ostream
*
os
)
;
inline
void
PrintTo
(
const
:
:
std
:
:
string
&
s
:
:
std
:
:
ostream
*
os
)
{
PrintStringTo
(
s
os
)
;
}
#
if
GTEST_HAS_STD_WSTRING
GTEST_API_
void
PrintWideStringTo
(
const
:
:
std
:
:
wstring
&
s
:
:
std
:
:
ostream
*
os
)
;
inline
void
PrintTo
(
const
:
:
std
:
:
wstring
&
s
:
:
std
:
:
ostream
*
os
)
{
PrintWideStringTo
(
s
os
)
;
}
#
endif
#
if
GTEST_INTERNAL_HAS_STRING_VIEW
inline
void
PrintTo
(
internal
:
:
StringView
sp
:
:
std
:
:
ostream
*
os
)
{
PrintTo
(
:
:
std
:
:
string
(
sp
)
os
)
;
}
#
endif
inline
void
PrintTo
(
std
:
:
nullptr_t
:
:
std
:
:
ostream
*
os
)
{
*
os
<
<
"
(
nullptr
)
"
;
}
template
<
typename
T
>
void
PrintTo
(
std
:
:
reference_wrapper
<
T
>
ref
:
:
std
:
:
ostream
*
os
)
{
UniversalPrinter
<
T
&
>
:
:
Print
(
ref
.
get
(
)
os
)
;
}
template
<
typename
T
>
void
PrintTupleTo
(
const
T
&
std
:
:
integral_constant
<
size_t
0
>
:
:
std
:
:
ostream
*
)
{
}
template
<
typename
T
size_t
I
>
void
PrintTupleTo
(
const
T
&
t
std
:
:
integral_constant
<
size_t
I
>
:
:
std
:
:
ostream
*
os
)
{
PrintTupleTo
(
t
std
:
:
integral_constant
<
size_t
I
-
1
>
(
)
os
)
;
GTEST_INTENTIONAL_CONST_COND_PUSH_
(
)
if
(
I
>
1
)
{
GTEST_INTENTIONAL_CONST_COND_POP_
(
)
*
os
<
<
"
"
;
}
UniversalPrinter
<
typename
std
:
:
tuple_element
<
I
-
1
T
>
:
:
type
>
:
:
Print
(
std
:
:
get
<
I
-
1
>
(
t
)
os
)
;
}
template
<
typename
.
.
.
Types
>
void
PrintTo
(
const
:
:
std
:
:
tuple
<
Types
.
.
.
>
&
t
:
:
std
:
:
ostream
*
os
)
{
*
os
<
<
"
(
"
;
PrintTupleTo
(
t
std
:
:
integral_constant
<
size_t
sizeof
.
.
.
(
Types
)
>
(
)
os
)
;
*
os
<
<
"
)
"
;
}
template
<
typename
T1
typename
T2
>
void
PrintTo
(
const
:
:
std
:
:
pair
<
T1
T2
>
&
value
:
:
std
:
:
ostream
*
os
)
{
*
os
<
<
'
(
'
;
UniversalPrinter
<
T1
>
:
:
Print
(
value
.
first
os
)
;
*
os
<
<
"
"
;
UniversalPrinter
<
T2
>
:
:
Print
(
value
.
second
os
)
;
*
os
<
<
'
)
'
;
}
template
<
typename
T
>
class
UniversalPrinter
{
public
:
GTEST_DISABLE_MSC_WARNINGS_PUSH_
(
4180
)
static
void
Print
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
PrintTo
(
value
os
)
;
}
GTEST_DISABLE_MSC_WARNINGS_POP_
(
)
}
;
#
if
GTEST_HAS_ABSL
template
<
typename
T
>
class
UniversalPrinter
<
:
:
absl
:
:
optional
<
T
>
>
{
public
:
static
void
Print
(
const
:
:
absl
:
:
optional
<
T
>
&
value
:
:
std
:
:
ostream
*
os
)
{
*
os
<
<
'
(
'
;
if
(
!
value
)
{
*
os
<
<
"
nullopt
"
;
}
else
{
UniversalPrint
(
*
value
os
)
;
}
*
os
<
<
'
)
'
;
}
}
;
template
<
typename
.
.
.
T
>
class
UniversalPrinter
<
:
:
absl
:
:
variant
<
T
.
.
.
>
>
{
public
:
static
void
Print
(
const
:
:
absl
:
:
variant
<
T
.
.
.
>
&
value
:
:
std
:
:
ostream
*
os
)
{
*
os
<
<
'
(
'
;
absl
:
:
visit
(
Visitor
{
os
}
value
)
;
*
os
<
<
'
)
'
;
}
private
:
struct
Visitor
{
template
<
typename
U
>
void
operator
(
)
(
const
U
&
u
)
const
{
*
os
<
<
"
'
"
<
<
GetTypeName
<
U
>
(
)
<
<
"
'
with
value
"
;
UniversalPrint
(
u
os
)
;
}
:
:
std
:
:
ostream
*
os
;
}
;
}
;
#
endif
template
<
typename
T
>
void
UniversalPrintArray
(
const
T
*
begin
size_t
len
:
:
std
:
:
ostream
*
os
)
{
if
(
len
=
=
0
)
{
*
os
<
<
"
{
}
"
;
}
else
{
*
os
<
<
"
{
"
;
const
size_t
kThreshold
=
18
;
const
size_t
kChunkSize
=
8
;
if
(
len
<
=
kThreshold
)
{
PrintRawArrayTo
(
begin
len
os
)
;
}
else
{
PrintRawArrayTo
(
begin
kChunkSize
os
)
;
*
os
<
<
"
.
.
.
"
;
PrintRawArrayTo
(
begin
+
len
-
kChunkSize
kChunkSize
os
)
;
}
*
os
<
<
"
}
"
;
}
}
GTEST_API_
void
UniversalPrintArray
(
const
char
*
begin
size_t
len
:
:
std
:
:
ostream
*
os
)
;
GTEST_API_
void
UniversalPrintArray
(
const
wchar_t
*
begin
size_t
len
:
:
std
:
:
ostream
*
os
)
;
template
<
typename
T
size_t
N
>
class
UniversalPrinter
<
T
[
N
]
>
{
public
:
static
void
Print
(
const
T
(
&
a
)
[
N
]
:
:
std
:
:
ostream
*
os
)
{
UniversalPrintArray
(
a
N
os
)
;
}
}
;
template
<
typename
T
>
class
UniversalPrinter
<
T
&
>
{
public
:
GTEST_DISABLE_MSC_WARNINGS_PUSH_
(
4180
)
static
void
Print
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
*
os
<
<
"
"
<
<
reinterpret_cast
<
const
void
*
>
(
&
value
)
<
<
"
"
;
UniversalPrint
(
value
os
)
;
}
GTEST_DISABLE_MSC_WARNINGS_POP_
(
)
}
;
template
<
typename
T
>
class
UniversalTersePrinter
{
public
:
static
void
Print
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
UniversalPrint
(
value
os
)
;
}
}
;
template
<
typename
T
>
class
UniversalTersePrinter
<
T
&
>
{
public
:
static
void
Print
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
UniversalPrint
(
value
os
)
;
}
}
;
template
<
typename
T
size_t
N
>
class
UniversalTersePrinter
<
T
[
N
]
>
{
public
:
static
void
Print
(
const
T
(
&
value
)
[
N
]
:
:
std
:
:
ostream
*
os
)
{
UniversalPrinter
<
T
[
N
]
>
:
:
Print
(
value
os
)
;
}
}
;
template
<
>
class
UniversalTersePrinter
<
const
char
*
>
{
public
:
static
void
Print
(
const
char
*
str
:
:
std
:
:
ostream
*
os
)
{
if
(
str
=
=
nullptr
)
{
*
os
<
<
"
NULL
"
;
}
else
{
UniversalPrint
(
std
:
:
string
(
str
)
os
)
;
}
}
}
;
template
<
>
class
UniversalTersePrinter
<
char
*
>
{
public
:
static
void
Print
(
char
*
str
:
:
std
:
:
ostream
*
os
)
{
UniversalTersePrinter
<
const
char
*
>
:
:
Print
(
str
os
)
;
}
}
;
#
if
GTEST_HAS_STD_WSTRING
template
<
>
class
UniversalTersePrinter
<
const
wchar_t
*
>
{
public
:
static
void
Print
(
const
wchar_t
*
str
:
:
std
:
:
ostream
*
os
)
{
if
(
str
=
=
nullptr
)
{
*
os
<
<
"
NULL
"
;
}
else
{
UniversalPrint
(
:
:
std
:
:
wstring
(
str
)
os
)
;
}
}
}
;
#
endif
template
<
>
class
UniversalTersePrinter
<
wchar_t
*
>
{
public
:
static
void
Print
(
wchar_t
*
str
:
:
std
:
:
ostream
*
os
)
{
UniversalTersePrinter
<
const
wchar_t
*
>
:
:
Print
(
str
os
)
;
}
}
;
template
<
typename
T
>
void
UniversalTersePrint
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
UniversalTersePrinter
<
T
>
:
:
Print
(
value
os
)
;
}
template
<
typename
T
>
void
UniversalPrint
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
typedef
T
T1
;
UniversalPrinter
<
T1
>
:
:
Print
(
value
os
)
;
}
typedef
:
:
std
:
:
vector
<
:
:
std
:
:
string
>
Strings
;
template
<
typename
Tuple
>
void
TersePrintPrefixToStrings
(
const
Tuple
&
std
:
:
integral_constant
<
size_t
0
>
Strings
*
)
{
}
template
<
typename
Tuple
size_t
I
>
void
TersePrintPrefixToStrings
(
const
Tuple
&
t
std
:
:
integral_constant
<
size_t
I
>
Strings
*
strings
)
{
TersePrintPrefixToStrings
(
t
std
:
:
integral_constant
<
size_t
I
-
1
>
(
)
strings
)
;
:
:
std
:
:
stringstream
ss
;
UniversalTersePrint
(
std
:
:
get
<
I
-
1
>
(
t
)
&
ss
)
;
strings
-
>
push_back
(
ss
.
str
(
)
)
;
}
template
<
typename
Tuple
>
Strings
UniversalTersePrintTupleFieldsToStrings
(
const
Tuple
&
value
)
{
Strings
result
;
TersePrintPrefixToStrings
(
value
std
:
:
integral_constant
<
size_t
std
:
:
tuple_size
<
Tuple
>
:
:
value
>
(
)
&
result
)
;
return
result
;
}
}
#
if
GTEST_INTERNAL_HAS_STRING_VIEW
namespace
internal2
{
template
<
typename
T
>
void
TypeWithoutFormatter
<
T
kConvertibleToStringView
>
:
:
PrintValue
(
const
T
&
value
:
:
std
:
:
ostream
*
os
)
{
internal
:
:
PrintTo
(
internal
:
:
StringView
(
value
)
os
)
;
}
}
#
endif
template
<
typename
T
>
:
:
std
:
:
string
PrintToString
(
const
T
&
value
)
{
:
:
std
:
:
stringstream
ss
;
internal
:
:
UniversalTersePrinter
<
T
>
:
:
Print
(
value
&
ss
)
;
return
ss
.
str
(
)
;
}
}
#
include
"
gtest
/
internal
/
custom
/
gtest
-
printers
.
h
"
#
endif
