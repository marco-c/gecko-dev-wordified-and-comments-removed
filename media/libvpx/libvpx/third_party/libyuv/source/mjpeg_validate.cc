#
include
"
libyuv
/
mjpeg_decoder
.
h
"
#
include
<
string
.
h
>
#
ifdef
__cplusplus
namespace
libyuv
{
extern
"
C
"
{
#
endif
#
ifdef
ENABLE_SCASB
__declspec
(
naked
)
__declspec
(
align
(
16
)
)
const
uint8
*
ScanRow_ERMS
(
const
uint8
*
src
uint32
val
int
count
)
{
__asm
{
mov
edx
edi
mov
edi
[
esp
+
4
]
mov
eax
[
esp
+
8
]
mov
ecx
[
esp
+
12
]
repne
scasb
jne
sr99
mov
eax
edi
sub
eax
1
mov
edi
edx
ret
sr99
:
mov
eax
0
mov
edi
edx
ret
}
}
#
endif
static
LIBYUV_BOOL
ScanEOI
(
const
uint8
*
sample
size_t
sample_size
)
{
const
uint8
*
end
=
sample
+
sample_size
-
1
;
const
uint8
*
it
=
sample
;
for
(
;
;
)
{
#
ifdef
ENABLE_SCASB
it
=
ScanRow_ERMS
(
it
0xff
end
-
it
)
;
#
else
it
=
static_cast
<
const
uint8
*
>
(
memchr
(
it
0xff
end
-
it
)
)
;
#
endif
if
(
it
=
=
NULL
)
{
break
;
}
if
(
it
[
1
]
=
=
0xd9
)
{
return
LIBYUV_TRUE
;
}
+
+
it
;
}
return
LIBYUV_FALSE
;
}
LIBYUV_BOOL
ValidateJpeg
(
const
uint8
*
sample
size_t
sample_size
)
{
const
size_t
kBackSearchSize
=
1024
;
if
(
sample_size
<
64
)
{
return
LIBYUV_FALSE
;
}
if
(
sample
[
0
]
!
=
0xff
|
|
sample
[
1
]
!
=
0xd8
)
{
return
LIBYUV_FALSE
;
}
sample
+
=
2
;
sample_size
-
=
2
;
if
(
sample_size
>
kBackSearchSize
)
{
if
(
ScanEOI
(
sample
+
sample_size
-
kBackSearchSize
kBackSearchSize
)
)
{
return
LIBYUV_TRUE
;
}
sample_size
=
sample_size
-
kBackSearchSize
+
1
;
}
return
ScanEOI
(
sample
sample_size
)
;
}
#
ifdef
__cplusplus
}
}
#
endif
