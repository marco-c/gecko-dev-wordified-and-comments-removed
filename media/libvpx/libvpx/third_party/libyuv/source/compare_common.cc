#
include
"
libyuv
/
basic_types
.
h
"
#
include
"
libyuv
/
compare_row
.
h
"
#
ifdef
__cplusplus
namespace
libyuv
{
extern
"
C
"
{
#
endif
#
if
ORIGINAL_OPT
uint32_t
HammingDistance_C1
(
const
uint8_t
*
src_a
const
uint8_t
*
src_b
int
count
)
{
uint32_t
diff
=
0u
;
int
i
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
int
x
=
src_a
[
i
]
^
src_b
[
i
]
;
if
(
x
&
1
)
+
+
diff
;
if
(
x
&
2
)
+
+
diff
;
if
(
x
&
4
)
+
+
diff
;
if
(
x
&
8
)
+
+
diff
;
if
(
x
&
16
)
+
+
diff
;
if
(
x
&
32
)
+
+
diff
;
if
(
x
&
64
)
+
+
diff
;
if
(
x
&
128
)
+
+
diff
;
}
return
diff
;
}
#
endif
uint32_t
HammingDistance_C
(
const
uint8_t
*
src_a
const
uint8_t
*
src_b
int
count
)
{
uint32_t
diff
=
0u
;
int
i
;
for
(
i
=
0
;
i
<
count
-
3
;
i
+
=
4
)
{
uint32_t
x
=
*
(
(
const
uint32_t
*
)
src_a
)
^
*
(
(
const
uint32_t
*
)
src_b
)
;
uint32_t
u
=
x
-
(
(
x
>
>
1
)
&
0x55555555
)
;
u
=
(
(
u
>
>
2
)
&
0x33333333
)
+
(
u
&
0x33333333
)
;
diff
+
=
(
(
(
(
u
+
(
u
>
>
4
)
)
&
0x0f0f0f0f
)
*
0x01010101
)
>
>
24
)
;
src_a
+
=
4
;
src_b
+
=
4
;
}
for
(
;
i
<
count
;
+
+
i
)
{
uint32_t
x
=
*
src_a
^
*
src_b
;
uint32_t
u
=
x
-
(
(
x
>
>
1
)
&
0x55
)
;
u
=
(
(
u
>
>
2
)
&
0x33
)
+
(
u
&
0x33
)
;
diff
+
=
(
u
+
(
u
>
>
4
)
)
&
0x0f
;
src_a
+
=
1
;
src_b
+
=
1
;
}
return
diff
;
}
uint32_t
SumSquareError_C
(
const
uint8_t
*
src_a
const
uint8_t
*
src_b
int
count
)
{
uint32_t
sse
=
0u
;
int
i
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
int
diff
=
src_a
[
i
]
-
src_b
[
i
]
;
sse
+
=
(
uint32_t
)
(
diff
*
diff
)
;
}
return
sse
;
}
uint32_t
HashDjb2_C
(
const
uint8_t
*
src
int
count
uint32_t
seed
)
{
uint32_t
hash
=
seed
;
int
i
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
hash
+
=
(
hash
<
<
5
)
+
src
[
i
]
;
}
return
hash
;
}
#
ifdef
__cplusplus
}
}
#
endif
