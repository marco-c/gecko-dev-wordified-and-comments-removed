#
include
<
assert
.
h
>
#
include
<
errno
.
h
>
#
include
<
math
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
vpx
/
vpx_codec
.
h
"
#
include
"
vpx
/
vpx_integer
.
h
"
#
include
"
.
/
y4minput
.
h
"
#
include
"
vpx_dsp
/
ssim
.
h
"
#
include
"
vpx_ports
/
mem
.
h
"
static
const
int64_t
cc1
=
26634
;
static
const
int64_t
cc2
=
239708
;
static
const
int64_t
cc1_10
=
428658
;
static
const
int64_t
cc2_10
=
3857925
;
static
const
int64_t
cc1_12
=
6868593
;
static
const
int64_t
cc2_12
=
61817334
;
#
if
CONFIG_VP9_HIGHBITDEPTH
static
uint64_t
calc_plane_error16
(
uint16_t
*
orig
int
orig_stride
uint16_t
*
recon
int
recon_stride
unsigned
int
cols
unsigned
int
rows
)
{
unsigned
int
row
col
;
uint64_t
total_sse
=
0
;
int
diff
;
for
(
row
=
0
;
row
<
rows
;
row
+
+
)
{
for
(
col
=
0
;
col
<
cols
;
col
+
+
)
{
diff
=
orig
[
col
]
-
recon
[
col
]
;
total_sse
+
=
diff
*
diff
;
}
orig
+
=
orig_stride
;
recon
+
=
recon_stride
;
}
return
total_sse
;
}
#
endif
static
uint64_t
calc_plane_error
(
uint8_t
*
orig
int
orig_stride
uint8_t
*
recon
int
recon_stride
unsigned
int
cols
unsigned
int
rows
)
{
unsigned
int
row
col
;
uint64_t
total_sse
=
0
;
int
diff
;
for
(
row
=
0
;
row
<
rows
;
row
+
+
)
{
for
(
col
=
0
;
col
<
cols
;
col
+
+
)
{
diff
=
orig
[
col
]
-
recon
[
col
]
;
total_sse
+
=
diff
*
diff
;
}
orig
+
=
orig_stride
;
recon
+
=
recon_stride
;
}
return
total_sse
;
}
#
define
MAX_PSNR
100
static
double
mse2psnr
(
double
samples
double
peak
double
mse
)
{
double
psnr
;
if
(
mse
>
0
.
0
)
psnr
=
10
.
0
*
log10
(
peak
*
peak
*
samples
/
mse
)
;
else
psnr
=
MAX_PSNR
;
if
(
psnr
>
MAX_PSNR
)
psnr
=
MAX_PSNR
;
return
psnr
;
}
typedef
enum
{
RAW_YUV
Y4M
}
input_file_type
;
typedef
struct
input_file
{
FILE
*
file
;
input_file_type
type
;
unsigned
char
*
buf
;
y4m_input
y4m
;
vpx_image_t
img
;
int
w
;
int
h
;
int
bit_depth
;
}
input_file_t
;
static
int
open_input_file
(
const
char
*
file_name
input_file_t
*
input
int
w
int
h
int
bit_depth
)
{
char
y4m_buf
[
4
]
;
size_t
r1
;
input
-
>
type
=
RAW_YUV
;
input
-
>
buf
=
NULL
;
input
-
>
file
=
strcmp
(
file_name
"
-
"
)
?
fopen
(
file_name
"
rb
"
)
:
stdin
;
if
(
input
-
>
file
=
=
NULL
)
return
-
1
;
r1
=
fread
(
y4m_buf
1
4
input
-
>
file
)
;
if
(
r1
=
=
4
)
{
if
(
memcmp
(
y4m_buf
"
YUV4
"
4
)
=
=
0
)
input
-
>
type
=
Y4M
;
switch
(
input
-
>
type
)
{
case
Y4M
:
y4m_input_open
(
&
input
-
>
y4m
input
-
>
file
y4m_buf
4
0
)
;
input
-
>
w
=
input
-
>
y4m
.
pic_w
;
input
-
>
h
=
input
-
>
y4m
.
pic_h
;
input
-
>
bit_depth
=
input
-
>
y4m
.
bit_depth
;
memset
(
&
input
-
>
img
0
sizeof
(
input
-
>
img
)
)
;
break
;
case
RAW_YUV
:
fseek
(
input
-
>
file
0
SEEK_SET
)
;
input
-
>
w
=
w
;
input
-
>
h
=
h
;
if
(
bit_depth
<
9
)
input
-
>
buf
=
malloc
(
w
*
h
*
3
/
2
)
;
else
input
-
>
buf
=
malloc
(
w
*
h
*
3
)
;
break
;
}
}
return
0
;
}
static
void
close_input_file
(
input_file_t
*
in
)
{
if
(
in
-
>
file
)
fclose
(
in
-
>
file
)
;
if
(
in
-
>
type
=
=
Y4M
)
{
vpx_img_free
(
&
in
-
>
img
)
;
}
else
{
free
(
in
-
>
buf
)
;
}
}
static
size_t
read_input_file
(
input_file_t
*
in
unsigned
char
*
*
y
unsigned
char
*
*
u
unsigned
char
*
*
v
int
bd
)
{
size_t
r1
=
0
;
switch
(
in
-
>
type
)
{
case
Y4M
:
r1
=
y4m_input_fetch_frame
(
&
in
-
>
y4m
in
-
>
file
&
in
-
>
img
)
;
*
y
=
in
-
>
img
.
planes
[
0
]
;
*
u
=
in
-
>
img
.
planes
[
1
]
;
*
v
=
in
-
>
img
.
planes
[
2
]
;
break
;
case
RAW_YUV
:
if
(
bd
<
9
)
{
r1
=
fread
(
in
-
>
buf
in
-
>
w
*
in
-
>
h
*
3
/
2
1
in
-
>
file
)
;
*
y
=
in
-
>
buf
;
*
u
=
in
-
>
buf
+
in
-
>
w
*
in
-
>
h
;
*
v
=
in
-
>
buf
+
5
*
in
-
>
w
*
in
-
>
h
/
4
;
}
else
{
r1
=
fread
(
in
-
>
buf
in
-
>
w
*
in
-
>
h
*
3
1
in
-
>
file
)
;
*
y
=
in
-
>
buf
;
*
u
=
in
-
>
buf
+
in
-
>
w
*
in
-
>
h
/
2
;
*
v
=
*
u
+
in
-
>
w
*
in
-
>
h
/
2
;
}
break
;
}
return
r1
;
}
void
ssim_parms_16x16
(
const
uint8_t
*
s
int
sp
const
uint8_t
*
r
int
rp
uint32_t
*
sum_s
uint32_t
*
sum_r
uint32_t
*
sum_sq_s
uint32_t
*
sum_sq_r
uint32_t
*
sum_sxr
)
{
int
i
j
;
for
(
i
=
0
;
i
<
16
;
i
+
+
s
+
=
sp
r
+
=
rp
)
{
for
(
j
=
0
;
j
<
16
;
j
+
+
)
{
*
sum_s
+
=
s
[
j
]
;
*
sum_r
+
=
r
[
j
]
;
*
sum_sq_s
+
=
s
[
j
]
*
s
[
j
]
;
*
sum_sq_r
+
=
r
[
j
]
*
r
[
j
]
;
*
sum_sxr
+
=
s
[
j
]
*
r
[
j
]
;
}
}
}
void
ssim_parms_8x8
(
const
uint8_t
*
s
int
sp
const
uint8_t
*
r
int
rp
uint32_t
*
sum_s
uint32_t
*
sum_r
uint32_t
*
sum_sq_s
uint32_t
*
sum_sq_r
uint32_t
*
sum_sxr
)
{
int
i
j
;
for
(
i
=
0
;
i
<
8
;
i
+
+
s
+
=
sp
r
+
=
rp
)
{
for
(
j
=
0
;
j
<
8
;
j
+
+
)
{
*
sum_s
+
=
s
[
j
]
;
*
sum_r
+
=
r
[
j
]
;
*
sum_sq_s
+
=
s
[
j
]
*
s
[
j
]
;
*
sum_sq_r
+
=
r
[
j
]
*
r
[
j
]
;
*
sum_sxr
+
=
s
[
j
]
*
r
[
j
]
;
}
}
}
void
highbd_ssim_parms_8x8
(
const
uint16_t
*
s
int
sp
const
uint16_t
*
r
int
rp
uint32_t
*
sum_s
uint32_t
*
sum_r
uint32_t
*
sum_sq_s
uint32_t
*
sum_sq_r
uint32_t
*
sum_sxr
)
{
int
i
j
;
for
(
i
=
0
;
i
<
8
;
i
+
+
s
+
=
sp
r
+
=
rp
)
{
for
(
j
=
0
;
j
<
8
;
j
+
+
)
{
*
sum_s
+
=
s
[
j
]
;
*
sum_r
+
=
r
[
j
]
;
*
sum_sq_s
+
=
s
[
j
]
*
s
[
j
]
;
*
sum_sq_r
+
=
r
[
j
]
*
r
[
j
]
;
*
sum_sxr
+
=
s
[
j
]
*
r
[
j
]
;
}
}
}
static
double
similarity
(
uint32_t
sum_s
uint32_t
sum_r
uint32_t
sum_sq_s
uint32_t
sum_sq_r
uint32_t
sum_sxr
int
count
uint32_t
bd
)
{
int64_t
ssim_n
ssim_d
;
int64_t
c1
=
0
c2
=
0
;
if
(
bd
=
=
8
)
{
c1
=
(
cc1
*
count
*
count
)
>
>
12
;
c2
=
(
cc2
*
count
*
count
)
>
>
12
;
}
else
if
(
bd
=
=
10
)
{
c1
=
(
cc1_10
*
count
*
count
)
>
>
12
;
c2
=
(
cc2_10
*
count
*
count
)
>
>
12
;
}
else
if
(
bd
=
=
12
)
{
c1
=
(
cc1_12
*
count
*
count
)
>
>
12
;
c2
=
(
cc2_12
*
count
*
count
)
>
>
12
;
}
else
{
assert
(
0
)
;
}
ssim_n
=
(
2
*
sum_s
*
sum_r
+
c1
)
*
(
(
int64_t
)
2
*
count
*
sum_sxr
-
(
int64_t
)
2
*
sum_s
*
sum_r
+
c2
)
;
ssim_d
=
(
sum_s
*
sum_s
+
sum_r
*
sum_r
+
c1
)
*
(
(
int64_t
)
count
*
sum_sq_s
-
(
int64_t
)
sum_s
*
sum_s
+
(
int64_t
)
count
*
sum_sq_r
-
(
int64_t
)
sum_r
*
sum_r
+
c2
)
;
return
ssim_n
*
1
.
0
/
ssim_d
;
}
static
double
ssim_8x8
(
const
uint8_t
*
s
int
sp
const
uint8_t
*
r
int
rp
)
{
uint32_t
sum_s
=
0
sum_r
=
0
sum_sq_s
=
0
sum_sq_r
=
0
sum_sxr
=
0
;
ssim_parms_8x8
(
s
sp
r
rp
&
sum_s
&
sum_r
&
sum_sq_s
&
sum_sq_r
&
sum_sxr
)
;
return
similarity
(
sum_s
sum_r
sum_sq_s
sum_sq_r
sum_sxr
64
8
)
;
}
static
double
highbd_ssim_8x8
(
const
uint16_t
*
s
int
sp
const
uint16_t
*
r
int
rp
uint32_t
bd
uint32_t
shift
)
{
uint32_t
sum_s
=
0
sum_r
=
0
sum_sq_s
=
0
sum_sq_r
=
0
sum_sxr
=
0
;
highbd_ssim_parms_8x8
(
s
sp
r
rp
&
sum_s
&
sum_r
&
sum_sq_s
&
sum_sq_r
&
sum_sxr
)
;
return
similarity
(
sum_s
>
>
shift
sum_r
>
>
shift
sum_sq_s
>
>
(
2
*
shift
)
sum_sq_r
>
>
(
2
*
shift
)
sum_sxr
>
>
(
2
*
shift
)
64
bd
)
;
}
static
double
ssim2
(
const
uint8_t
*
img1
const
uint8_t
*
img2
int
stride_img1
int
stride_img2
int
width
int
height
)
{
int
i
j
;
int
samples
=
0
;
double
ssim_total
=
0
;
for
(
i
=
0
;
i
<
=
height
-
8
;
i
+
=
4
img1
+
=
stride_img1
*
4
img2
+
=
stride_img2
*
4
)
{
for
(
j
=
0
;
j
<
=
width
-
8
;
j
+
=
4
)
{
double
v
=
ssim_8x8
(
img1
+
j
stride_img1
img2
+
j
stride_img2
)
;
ssim_total
+
=
v
;
samples
+
+
;
}
}
ssim_total
/
=
samples
;
return
ssim_total
;
}
static
double
highbd_ssim2
(
const
uint8_t
*
img1
const
uint8_t
*
img2
int
stride_img1
int
stride_img2
int
width
int
height
uint32_t
bd
uint32_t
shift
)
{
int
i
j
;
int
samples
=
0
;
double
ssim_total
=
0
;
for
(
i
=
0
;
i
<
=
height
-
8
;
i
+
=
4
img1
+
=
stride_img1
*
4
img2
+
=
stride_img2
*
4
)
{
for
(
j
=
0
;
j
<
=
width
-
8
;
j
+
=
4
)
{
double
v
=
highbd_ssim_8x8
(
CONVERT_TO_SHORTPTR
(
img1
+
j
)
stride_img1
CONVERT_TO_SHORTPTR
(
img2
+
j
)
stride_img2
bd
shift
)
;
ssim_total
+
=
v
;
samples
+
+
;
}
}
ssim_total
/
=
samples
;
return
ssim_total
;
}
static
double
ssimv_similarity
(
const
Ssimv
*
sv
int64_t
n
)
{
const
int64_t
c1
=
(
cc1
*
n
*
n
)
>
>
12
;
const
int64_t
c2
=
(
cc2
*
n
*
n
)
>
>
12
;
const
double
l
=
1
.
0
*
(
2
*
sv
-
>
sum_s
*
sv
-
>
sum_r
+
c1
)
/
(
sv
-
>
sum_s
*
sv
-
>
sum_s
+
sv
-
>
sum_r
*
sv
-
>
sum_r
+
c1
)
;
const
double
v
=
(
2
.
0
*
n
*
sv
-
>
sum_sxr
-
2
*
sv
-
>
sum_s
*
sv
-
>
sum_r
+
c2
)
/
(
n
*
sv
-
>
sum_sq_s
-
sv
-
>
sum_s
*
sv
-
>
sum_s
+
n
*
sv
-
>
sum_sq_r
-
sv
-
>
sum_r
*
sv
-
>
sum_r
+
c2
)
;
return
l
*
v
;
}
static
double
ssimv_similarity2
(
const
Ssimv
*
sv
int64_t
n
)
{
const
int64_t
c1
=
(
cc1
*
n
*
n
)
>
>
12
;
const
int64_t
c2
=
(
cc2
*
n
*
n
)
>
>
12
;
const
double
mean_diff
=
(
1
.
0
*
sv
-
>
sum_s
-
sv
-
>
sum_r
)
/
n
;
const
double
l
=
(
255
*
255
-
mean_diff
*
mean_diff
+
c1
)
/
(
255
*
255
+
c1
)
;
const
double
v
=
(
2
.
0
*
n
*
sv
-
>
sum_sxr
-
2
*
sv
-
>
sum_s
*
sv
-
>
sum_r
+
c2
)
/
(
n
*
sv
-
>
sum_sq_s
-
sv
-
>
sum_s
*
sv
-
>
sum_s
+
n
*
sv
-
>
sum_sq_r
-
sv
-
>
sum_r
*
sv
-
>
sum_r
+
c2
)
;
return
l
*
v
;
}
static
void
ssimv_parms
(
uint8_t
*
img1
int
img1_pitch
uint8_t
*
img2
int
img2_pitch
Ssimv
*
sv
)
{
ssim_parms_8x8
(
img1
img1_pitch
img2
img2_pitch
&
sv
-
>
sum_s
&
sv
-
>
sum_r
&
sv
-
>
sum_sq_s
&
sv
-
>
sum_sq_r
&
sv
-
>
sum_sxr
)
;
}
double
get_ssim_metrics
(
uint8_t
*
img1
int
img1_pitch
uint8_t
*
img2
int
img2_pitch
int
width
int
height
Ssimv
*
sv2
Metrics
*
m
int
do_inconsistency
)
{
double
dssim_total
=
0
;
double
ssim_total
=
0
;
double
ssim2_total
=
0
;
double
inconsistency_total
=
0
;
int
i
j
;
int
c
=
0
;
double
norm
;
double
old_ssim_total
=
0
;
for
(
i
=
0
;
i
<
height
;
i
+
=
4
img1
+
=
img1_pitch
*
4
img2
+
=
img2_pitch
*
4
)
{
for
(
j
=
0
;
j
<
width
;
j
+
=
4
+
+
c
)
{
Ssimv
sv
=
{
0
0
0
0
0
0
}
;
double
ssim
;
double
ssim2
;
double
dssim
;
uint32_t
var_new
;
uint32_t
var_old
;
uint32_t
mean_new
;
uint32_t
mean_old
;
double
ssim_new
;
double
ssim_old
;
if
(
j
+
8
<
=
width
&
&
i
+
8
<
=
height
)
{
ssimv_parms
(
img1
+
j
img1_pitch
img2
+
j
img2_pitch
&
sv
)
;
}
ssim
=
ssimv_similarity
(
&
sv
64
)
;
ssim2
=
ssimv_similarity2
(
&
sv
64
)
;
sv
.
ssim
=
ssim2
;
dssim
=
255
*
255
*
(
1
-
ssim2
)
/
2
;
var_new
=
sv
.
sum_sq_s
-
sv
.
sum_s
*
sv
.
sum_s
/
64
;
var_old
=
sv2
[
c
]
.
sum_sq_s
-
sv2
[
c
]
.
sum_s
*
sv2
[
c
]
.
sum_s
/
64
;
mean_new
=
sv
.
sum_s
;
mean_old
=
sv2
[
c
]
.
sum_s
;
ssim_new
=
sv
.
ssim
;
ssim_old
=
sv2
[
c
]
.
ssim
;
if
(
do_inconsistency
)
{
static
const
double
kScaling
=
4
.
*
4
*
255
*
255
;
static
const
double
c1
=
1
c2
=
1
c3
=
1
;
const
double
variance_term
=
(
2
.
0
*
var_old
*
var_new
+
c1
)
/
(
1
.
0
*
var_old
*
var_old
+
1
.
0
*
var_new
*
var_new
+
c1
)
;
const
double
mean_term
=
(
2
.
0
*
mean_old
*
mean_new
+
c2
)
/
(
1
.
0
*
mean_old
*
mean_old
+
1
.
0
*
mean_new
*
mean_new
+
c2
)
;
double
ssim_term
=
pow
(
(
2
.
0
*
ssim_old
*
ssim_new
+
c3
)
/
(
ssim_old
*
ssim_old
+
ssim_new
*
ssim_new
+
c3
)
5
)
;
double
this_inconsistency
;
if
(
ssim_term
>
1
)
ssim_term
=
1
;
this_inconsistency
=
(
1
-
ssim_term
)
*
variance_term
*
mean_term
;
this_inconsistency
*
=
kScaling
;
inconsistency_total
+
=
this_inconsistency
;
}
sv2
[
c
]
=
sv
;
ssim_total
+
=
ssim
;
ssim2_total
+
=
ssim2
;
dssim_total
+
=
dssim
;
old_ssim_total
+
=
ssim_old
;
}
old_ssim_total
+
=
0
;
}
norm
=
1
.
/
(
width
/
4
)
/
(
height
/
4
)
;
ssim_total
*
=
norm
;
ssim2_total
*
=
norm
;
m
-
>
ssim2
=
ssim2_total
;
m
-
>
ssim
=
ssim_total
;
if
(
old_ssim_total
=
=
0
)
inconsistency_total
=
0
;
m
-
>
ssimc
=
inconsistency_total
;
m
-
>
dssim
=
dssim_total
;
return
inconsistency_total
;
}
double
highbd_calc_ssim
(
const
YV12_BUFFER_CONFIG
*
source
const
YV12_BUFFER_CONFIG
*
dest
double
*
weight
uint32_t
bd
uint32_t
in_bd
)
{
double
a
b
c
;
double
ssimv
;
uint32_t
shift
=
0
;
assert
(
bd
>
=
in_bd
)
;
shift
=
bd
-
in_bd
;
a
=
highbd_ssim2
(
source
-
>
y_buffer
dest
-
>
y_buffer
source
-
>
y_stride
dest
-
>
y_stride
source
-
>
y_crop_width
source
-
>
y_crop_height
in_bd
shift
)
;
b
=
highbd_ssim2
(
source
-
>
u_buffer
dest
-
>
u_buffer
source
-
>
uv_stride
dest
-
>
uv_stride
source
-
>
uv_crop_width
source
-
>
uv_crop_height
in_bd
shift
)
;
c
=
highbd_ssim2
(
source
-
>
v_buffer
dest
-
>
v_buffer
source
-
>
uv_stride
dest
-
>
uv_stride
source
-
>
uv_crop_width
source
-
>
uv_crop_height
in_bd
shift
)
;
ssimv
=
a
*
.
8
+
.
1
*
(
b
+
c
)
;
*
weight
=
1
;
return
ssimv
;
}
int
main
(
int
argc
char
*
argv
[
]
)
{
FILE
*
framestats
=
NULL
;
int
bit_depth
=
8
;
int
w
=
0
h
=
0
tl_skip
=
0
tl_skips_remaining
=
0
;
double
ssimavg
=
0
ssimyavg
=
0
ssimuavg
=
0
ssimvavg
=
0
;
double
psnrglb
=
0
psnryglb
=
0
psnruglb
=
0
psnrvglb
=
0
;
double
psnravg
=
0
psnryavg
=
0
psnruavg
=
0
psnrvavg
=
0
;
double
*
ssimy
=
NULL
*
ssimu
=
NULL
*
ssimv
=
NULL
;
uint64_t
*
psnry
=
NULL
*
psnru
=
NULL
*
psnrv
=
NULL
;
size_t
i
n_frames
=
0
allocated_frames
=
0
;
int
return_value
=
0
;
input_file_t
in
[
2
]
;
double
peak
=
255
.
0
;
if
(
argc
<
2
)
{
fprintf
(
stderr
"
Usage
:
%
s
file1
.
{
yuv
|
y4m
}
file2
.
{
yuv
|
y4m
}
"
"
[
WxH
tl_skip
=
{
0
1
3
}
frame_stats_file
bits
]
\
n
"
argv
[
0
]
)
;
return_value
=
1
;
goto
clean_up
;
}
if
(
argc
>
3
)
{
sscanf
(
argv
[
3
]
"
%
dx
%
d
"
&
w
&
h
)
;
}
if
(
argc
>
6
)
{
sscanf
(
argv
[
6
]
"
%
d
"
&
bit_depth
)
;
}
if
(
open_input_file
(
argv
[
1
]
&
in
[
0
]
w
h
bit_depth
)
<
0
)
{
fprintf
(
stderr
"
File
%
s
can
'
t
be
opened
or
parsed
!
\
n
"
argv
[
2
]
)
;
goto
clean_up
;
}
if
(
w
=
=
0
&
&
h
=
=
0
)
{
w
=
in
[
0
]
.
w
;
h
=
in
[
0
]
.
h
;
bit_depth
=
in
[
0
]
.
bit_depth
;
}
if
(
bit_depth
=
=
10
)
peak
=
1023
.
0
;
if
(
bit_depth
=
=
12
)
peak
=
4095
;
if
(
open_input_file
(
argv
[
2
]
&
in
[
1
]
w
h
bit_depth
)
<
0
)
{
fprintf
(
stderr
"
File
%
s
can
'
t
be
opened
or
parsed
!
\
n
"
argv
[
2
]
)
;
goto
clean_up
;
}
if
(
in
[
0
]
.
w
!
=
in
[
1
]
.
w
|
|
in
[
0
]
.
h
!
=
in
[
1
]
.
h
|
|
in
[
0
]
.
w
!
=
w
|
|
in
[
0
]
.
h
!
=
h
|
|
w
=
=
0
|
|
h
=
=
0
)
{
fprintf
(
stderr
"
Failing
:
Image
dimensions
don
'
t
match
or
are
unspecified
!
\
n
"
)
;
return_value
=
1
;
goto
clean_up
;
}
if
(
argc
>
4
)
{
sscanf
(
argv
[
4
]
"
%
d
"
&
tl_skip
)
;
if
(
argc
>
5
)
{
framestats
=
fopen
(
argv
[
5
]
"
w
"
)
;
if
(
!
framestats
)
{
fprintf
(
stderr
"
Could
not
open
\
"
%
s
\
"
for
writing
:
%
s
\
n
"
argv
[
5
]
strerror
(
errno
)
)
;
return_value
=
1
;
goto
clean_up
;
}
}
}
if
(
w
&
1
|
|
h
&
1
)
{
fprintf
(
stderr
"
Invalid
size
%
dx
%
d
\
n
"
w
h
)
;
return_value
=
1
;
goto
clean_up
;
}
while
(
1
)
{
size_t
r1
r2
;
unsigned
char
*
y
[
2
]
*
u
[
2
]
*
v
[
2
]
;
r1
=
read_input_file
(
&
in
[
0
]
&
y
[
0
]
&
u
[
0
]
&
v
[
0
]
bit_depth
)
;
if
(
r1
)
{
if
(
tl_skips_remaining
>
0
)
{
-
-
tl_skips_remaining
;
continue
;
}
tl_skips_remaining
=
tl_skip
;
}
r2
=
read_input_file
(
&
in
[
1
]
&
y
[
1
]
&
u
[
1
]
&
v
[
1
]
bit_depth
)
;
if
(
r1
&
&
r2
&
&
r1
!
=
r2
)
{
fprintf
(
stderr
"
Failed
to
read
data
:
%
s
[
%
d
/
%
d
]
\
n
"
strerror
(
errno
)
(
int
)
r1
(
int
)
r2
)
;
return_value
=
1
;
goto
clean_up
;
}
else
if
(
r1
=
=
0
|
|
r2
=
=
0
)
{
break
;
}
#
if
CONFIG_VP9_HIGHBITDEPTH
#
define
psnr_and_ssim
(
ssim
psnr
buf0
buf1
w
h
)
\
if
(
bit_depth
<
9
)
{
\
ssim
=
ssim2
(
buf0
buf1
w
w
w
h
)
;
\
psnr
=
calc_plane_error
(
buf0
w
buf1
w
w
h
)
;
\
}
else
{
\
ssim
=
highbd_ssim2
(
CONVERT_TO_BYTEPTR
(
buf0
)
CONVERT_TO_BYTEPTR
(
buf1
)
w
\
w
w
h
bit_depth
bit_depth
-
8
)
;
\
psnr
=
calc_plane_error16
(
CAST_TO_SHORTPTR
(
buf0
)
w
\
CAST_TO_SHORTPTR
(
buf1
)
w
w
h
)
;
\
}
#
else
#
define
psnr_and_ssim
(
ssim
psnr
buf0
buf1
w
h
)
\
ssim
=
ssim2
(
buf0
buf1
w
w
w
h
)
;
\
psnr
=
calc_plane_error
(
buf0
w
buf1
w
w
h
)
;
#
endif
if
(
n_frames
=
=
allocated_frames
)
{
allocated_frames
=
allocated_frames
=
=
0
?
1024
:
allocated_frames
*
2
;
ssimy
=
realloc
(
ssimy
allocated_frames
*
sizeof
(
*
ssimy
)
)
;
ssimu
=
realloc
(
ssimu
allocated_frames
*
sizeof
(
*
ssimu
)
)
;
ssimv
=
realloc
(
ssimv
allocated_frames
*
sizeof
(
*
ssimv
)
)
;
psnry
=
realloc
(
psnry
allocated_frames
*
sizeof
(
*
psnry
)
)
;
psnru
=
realloc
(
psnru
allocated_frames
*
sizeof
(
*
psnru
)
)
;
psnrv
=
realloc
(
psnrv
allocated_frames
*
sizeof
(
*
psnrv
)
)
;
}
psnr_and_ssim
(
ssimy
[
n_frames
]
psnry
[
n_frames
]
y
[
0
]
y
[
1
]
w
h
)
;
psnr_and_ssim
(
ssimu
[
n_frames
]
psnru
[
n_frames
]
u
[
0
]
u
[
1
]
w
/
2
h
/
2
)
;
psnr_and_ssim
(
ssimv
[
n_frames
]
psnrv
[
n_frames
]
v
[
0
]
v
[
1
]
w
/
2
h
/
2
)
;
n_frames
+
+
;
}
if
(
framestats
)
{
fprintf
(
framestats
"
ssim
ssim
-
y
ssim
-
u
ssim
-
v
psnr
psnr
-
y
psnr
-
u
psnr
-
v
\
n
"
)
;
}
for
(
i
=
0
;
i
<
n_frames
;
+
+
i
)
{
double
frame_ssim
;
double
frame_psnr
frame_psnry
frame_psnru
frame_psnrv
;
frame_ssim
=
0
.
8
*
ssimy
[
i
]
+
0
.
1
*
(
ssimu
[
i
]
+
ssimv
[
i
]
)
;
ssimavg
+
=
frame_ssim
;
ssimyavg
+
=
ssimy
[
i
]
;
ssimuavg
+
=
ssimu
[
i
]
;
ssimvavg
+
=
ssimv
[
i
]
;
frame_psnr
=
mse2psnr
(
w
*
h
*
6
/
4
peak
(
double
)
psnry
[
i
]
+
psnru
[
i
]
+
psnrv
[
i
]
)
;
frame_psnry
=
mse2psnr
(
w
*
h
*
4
/
4
peak
(
double
)
psnry
[
i
]
)
;
frame_psnru
=
mse2psnr
(
w
*
h
*
1
/
4
peak
(
double
)
psnru
[
i
]
)
;
frame_psnrv
=
mse2psnr
(
w
*
h
*
1
/
4
peak
(
double
)
psnrv
[
i
]
)
;
psnravg
+
=
frame_psnr
;
psnryavg
+
=
frame_psnry
;
psnruavg
+
=
frame_psnru
;
psnrvavg
+
=
frame_psnrv
;
psnryglb
+
=
psnry
[
i
]
;
psnruglb
+
=
psnru
[
i
]
;
psnrvglb
+
=
psnrv
[
i
]
;
if
(
framestats
)
{
fprintf
(
framestats
"
%
lf
%
lf
%
lf
%
lf
%
lf
%
lf
%
lf
%
lf
\
n
"
frame_ssim
ssimy
[
i
]
ssimu
[
i
]
ssimv
[
i
]
frame_psnr
frame_psnry
frame_psnru
frame_psnrv
)
;
}
}
ssimavg
/
=
n_frames
;
ssimyavg
/
=
n_frames
;
ssimuavg
/
=
n_frames
;
ssimvavg
/
=
n_frames
;
printf
(
"
VpxSSIM
:
%
lf
\
n
"
100
*
pow
(
ssimavg
8
.
0
)
)
;
printf
(
"
SSIM
:
%
lf
\
n
"
ssimavg
)
;
printf
(
"
SSIM
-
Y
:
%
lf
\
n
"
ssimyavg
)
;
printf
(
"
SSIM
-
U
:
%
lf
\
n
"
ssimuavg
)
;
printf
(
"
SSIM
-
V
:
%
lf
\
n
"
ssimvavg
)
;
puts
(
"
"
)
;
psnravg
/
=
n_frames
;
psnryavg
/
=
n_frames
;
psnruavg
/
=
n_frames
;
psnrvavg
/
=
n_frames
;
printf
(
"
AvgPSNR
:
%
lf
\
n
"
psnravg
)
;
printf
(
"
AvgPSNR
-
Y
:
%
lf
\
n
"
psnryavg
)
;
printf
(
"
AvgPSNR
-
U
:
%
lf
\
n
"
psnruavg
)
;
printf
(
"
AvgPSNR
-
V
:
%
lf
\
n
"
psnrvavg
)
;
puts
(
"
"
)
;
psnrglb
=
psnryglb
+
psnruglb
+
psnrvglb
;
psnrglb
=
mse2psnr
(
(
double
)
n_frames
*
w
*
h
*
6
/
4
peak
psnrglb
)
;
psnryglb
=
mse2psnr
(
(
double
)
n_frames
*
w
*
h
*
4
/
4
peak
psnryglb
)
;
psnruglb
=
mse2psnr
(
(
double
)
n_frames
*
w
*
h
*
1
/
4
peak
psnruglb
)
;
psnrvglb
=
mse2psnr
(
(
double
)
n_frames
*
w
*
h
*
1
/
4
peak
psnrvglb
)
;
printf
(
"
GlbPSNR
:
%
lf
\
n
"
psnrglb
)
;
printf
(
"
GlbPSNR
-
Y
:
%
lf
\
n
"
psnryglb
)
;
printf
(
"
GlbPSNR
-
U
:
%
lf
\
n
"
psnruglb
)
;
printf
(
"
GlbPSNR
-
V
:
%
lf
\
n
"
psnrvglb
)
;
puts
(
"
"
)
;
printf
(
"
Nframes
:
%
d
\
n
"
(
int
)
n_frames
)
;
clean_up
:
close_input_file
(
&
in
[
0
]
)
;
close_input_file
(
&
in
[
1
]
)
;
if
(
framestats
)
fclose
(
framestats
)
;
free
(
ssimy
)
;
free
(
ssimu
)
;
free
(
ssimv
)
;
free
(
psnry
)
;
free
(
psnru
)
;
free
(
psnrv
)
;
return
return_value
;
}
