#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
<
stdlib
.
h
>
#
include
<
limits
.
h
>
#
include
<
string
.
h
>
#
include
<
ogg
/
ogg
.
h
>
int
ogg_page_version
(
const
ogg_page
*
og
)
{
return
(
(
int
)
(
og
-
>
header
[
4
]
)
)
;
}
int
ogg_page_continued
(
const
ogg_page
*
og
)
{
return
(
(
int
)
(
og
-
>
header
[
5
]
&
0x01
)
)
;
}
int
ogg_page_bos
(
const
ogg_page
*
og
)
{
return
(
(
int
)
(
og
-
>
header
[
5
]
&
0x02
)
)
;
}
int
ogg_page_eos
(
const
ogg_page
*
og
)
{
return
(
(
int
)
(
og
-
>
header
[
5
]
&
0x04
)
)
;
}
ogg_int64_t
ogg_page_granulepos
(
const
ogg_page
*
og
)
{
unsigned
char
*
page
=
og
-
>
header
;
ogg_uint64_t
granulepos
=
page
[
13
]
&
(
0xff
)
;
granulepos
=
(
granulepos
<
<
8
)
|
(
page
[
12
]
&
0xff
)
;
granulepos
=
(
granulepos
<
<
8
)
|
(
page
[
11
]
&
0xff
)
;
granulepos
=
(
granulepos
<
<
8
)
|
(
page
[
10
]
&
0xff
)
;
granulepos
=
(
granulepos
<
<
8
)
|
(
page
[
9
]
&
0xff
)
;
granulepos
=
(
granulepos
<
<
8
)
|
(
page
[
8
]
&
0xff
)
;
granulepos
=
(
granulepos
<
<
8
)
|
(
page
[
7
]
&
0xff
)
;
granulepos
=
(
granulepos
<
<
8
)
|
(
page
[
6
]
&
0xff
)
;
return
(
(
ogg_int64_t
)
granulepos
)
;
}
int
ogg_page_serialno
(
const
ogg_page
*
og
)
{
return
(
(
int
)
(
(
ogg_uint32_t
)
og
-
>
header
[
14
]
)
|
(
(
ogg_uint32_t
)
og
-
>
header
[
15
]
<
<
8
)
|
(
(
ogg_uint32_t
)
og
-
>
header
[
16
]
<
<
16
)
|
(
(
ogg_uint32_t
)
og
-
>
header
[
17
]
<
<
24
)
)
;
}
long
ogg_page_pageno
(
const
ogg_page
*
og
)
{
return
(
(
long
)
(
(
ogg_uint32_t
)
og
-
>
header
[
18
]
)
|
(
(
ogg_uint32_t
)
og
-
>
header
[
19
]
<
<
8
)
|
(
(
ogg_uint32_t
)
og
-
>
header
[
20
]
<
<
16
)
|
(
(
ogg_uint32_t
)
og
-
>
header
[
21
]
<
<
24
)
)
;
}
int
ogg_page_packets
(
const
ogg_page
*
og
)
{
int
i
n
=
og
-
>
header
[
26
]
count
=
0
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
if
(
og
-
>
header
[
27
+
i
]
<
255
)
count
+
+
;
return
(
count
)
;
}
#
if
0
static
void
_ogg_crc_init
(
)
{
int
i
j
;
ogg_uint32_t
polynomial
crc
;
polynomial
=
0x04c11db7
;
for
(
i
=
0
;
i
<
=
0xFF
;
i
+
+
)
{
crc
=
i
<
<
24
;
for
(
j
=
0
;
j
<
8
;
j
+
+
)
crc
=
(
crc
<
<
1
)
^
(
crc
&
(
1
<
<
31
)
?
polynomial
:
0
)
;
crc_lookup
[
0
]
[
i
]
=
crc
;
}
for
(
i
=
0
;
i
<
=
0xFF
;
i
+
+
)
for
(
j
=
1
;
j
<
8
;
j
+
+
)
crc_lookup
[
j
]
[
i
]
=
crc_lookup
[
0
]
[
(
crc_lookup
[
j
-
1
]
[
i
]
>
>
24
)
&
0xFF
]
^
(
crc_lookup
[
j
-
1
]
[
i
]
<
<
8
)
;
}
#
endif
#
include
"
crctable
.
h
"
int
ogg_stream_init
(
ogg_stream_state
*
os
int
serialno
)
{
if
(
os
)
{
memset
(
os
0
sizeof
(
*
os
)
)
;
os
-
>
body_storage
=
16
*
1024
;
os
-
>
lacing_storage
=
1024
;
os
-
>
body_data
=
_ogg_malloc
(
os
-
>
body_storage
*
sizeof
(
*
os
-
>
body_data
)
)
;
os
-
>
lacing_vals
=
_ogg_malloc
(
os
-
>
lacing_storage
*
sizeof
(
*
os
-
>
lacing_vals
)
)
;
os
-
>
granule_vals
=
_ogg_malloc
(
os
-
>
lacing_storage
*
sizeof
(
*
os
-
>
granule_vals
)
)
;
if
(
!
os
-
>
body_data
|
|
!
os
-
>
lacing_vals
|
|
!
os
-
>
granule_vals
)
{
ogg_stream_clear
(
os
)
;
return
-
1
;
}
os
-
>
serialno
=
serialno
;
return
(
0
)
;
}
return
(
-
1
)
;
}
int
ogg_stream_check
(
ogg_stream_state
*
os
)
{
if
(
!
os
|
|
!
os
-
>
body_data
)
return
-
1
;
return
0
;
}
int
ogg_stream_clear
(
ogg_stream_state
*
os
)
{
if
(
os
)
{
if
(
os
-
>
body_data
)
_ogg_free
(
os
-
>
body_data
)
;
if
(
os
-
>
lacing_vals
)
_ogg_free
(
os
-
>
lacing_vals
)
;
if
(
os
-
>
granule_vals
)
_ogg_free
(
os
-
>
granule_vals
)
;
memset
(
os
0
sizeof
(
*
os
)
)
;
}
return
(
0
)
;
}
int
ogg_stream_destroy
(
ogg_stream_state
*
os
)
{
if
(
os
)
{
ogg_stream_clear
(
os
)
;
_ogg_free
(
os
)
;
}
return
(
0
)
;
}
static
int
_os_body_expand
(
ogg_stream_state
*
os
long
needed
)
{
if
(
os
-
>
body_storage
-
needed
<
=
os
-
>
body_fill
)
{
long
body_storage
;
void
*
ret
;
if
(
os
-
>
body_storage
>
LONG_MAX
-
needed
)
{
ogg_stream_clear
(
os
)
;
return
-
1
;
}
body_storage
=
os
-
>
body_storage
+
needed
;
if
(
body_storage
<
LONG_MAX
-
1024
)
body_storage
+
=
1024
;
ret
=
_ogg_realloc
(
os
-
>
body_data
body_storage
*
sizeof
(
*
os
-
>
body_data
)
)
;
if
(
!
ret
)
{
ogg_stream_clear
(
os
)
;
return
-
1
;
}
os
-
>
body_storage
=
body_storage
;
os
-
>
body_data
=
ret
;
}
return
0
;
}
static
int
_os_lacing_expand
(
ogg_stream_state
*
os
long
needed
)
{
if
(
os
-
>
lacing_storage
-
needed
<
=
os
-
>
lacing_fill
)
{
long
lacing_storage
;
void
*
ret
;
if
(
os
-
>
lacing_storage
>
LONG_MAX
-
needed
)
{
ogg_stream_clear
(
os
)
;
return
-
1
;
}
lacing_storage
=
os
-
>
lacing_storage
+
needed
;
if
(
lacing_storage
<
LONG_MAX
-
32
)
lacing_storage
+
=
32
;
ret
=
_ogg_realloc
(
os
-
>
lacing_vals
lacing_storage
*
sizeof
(
*
os
-
>
lacing_vals
)
)
;
if
(
!
ret
)
{
ogg_stream_clear
(
os
)
;
return
-
1
;
}
os
-
>
lacing_vals
=
ret
;
ret
=
_ogg_realloc
(
os
-
>
granule_vals
lacing_storage
*
sizeof
(
*
os
-
>
granule_vals
)
)
;
if
(
!
ret
)
{
ogg_stream_clear
(
os
)
;
return
-
1
;
}
os
-
>
granule_vals
=
ret
;
os
-
>
lacing_storage
=
lacing_storage
;
}
return
0
;
}
static
ogg_uint32_t
_os_update_crc
(
ogg_uint32_t
crc
unsigned
char
*
buffer
int
size
)
{
while
(
size
>
=
8
)
{
crc
^
=
(
(
ogg_uint32_t
)
buffer
[
0
]
<
<
24
)
|
(
(
ogg_uint32_t
)
buffer
[
1
]
<
<
16
)
|
(
(
ogg_uint32_t
)
buffer
[
2
]
<
<
8
)
|
(
(
ogg_uint32_t
)
buffer
[
3
]
)
;
crc
=
crc_lookup
[
7
]
[
crc
>
>
24
]
^
crc_lookup
[
6
]
[
(
crc
>
>
16
)
&
0xFF
]
^
crc_lookup
[
5
]
[
(
crc
>
>
8
)
&
0xFF
]
^
crc_lookup
[
4
]
[
crc
&
0xFF
]
^
crc_lookup
[
3
]
[
buffer
[
4
]
]
^
crc_lookup
[
2
]
[
buffer
[
5
]
]
^
crc_lookup
[
1
]
[
buffer
[
6
]
]
^
crc_lookup
[
0
]
[
buffer
[
7
]
]
;
buffer
+
=
8
;
size
-
=
8
;
}
while
(
size
-
-
)
crc
=
(
crc
<
<
8
)
^
crc_lookup
[
0
]
[
(
(
crc
>
>
24
)
&
0xff
)
^
*
buffer
+
+
]
;
return
crc
;
}
void
ogg_page_checksum_set
(
ogg_page
*
og
)
{
if
(
og
)
{
ogg_uint32_t
crc_reg
=
0
;
og
-
>
header
[
22
]
=
0
;
og
-
>
header
[
23
]
=
0
;
og
-
>
header
[
24
]
=
0
;
og
-
>
header
[
25
]
=
0
;
crc_reg
=
_os_update_crc
(
crc_reg
og
-
>
header
og
-
>
header_len
)
;
crc_reg
=
_os_update_crc
(
crc_reg
og
-
>
body
og
-
>
body_len
)
;
og
-
>
header
[
22
]
=
(
unsigned
char
)
(
crc_reg
&
0xff
)
;
og
-
>
header
[
23
]
=
(
unsigned
char
)
(
(
crc_reg
>
>
8
)
&
0xff
)
;
og
-
>
header
[
24
]
=
(
unsigned
char
)
(
(
crc_reg
>
>
16
)
&
0xff
)
;
og
-
>
header
[
25
]
=
(
unsigned
char
)
(
(
crc_reg
>
>
24
)
&
0xff
)
;
}
}
int
ogg_stream_iovecin
(
ogg_stream_state
*
os
ogg_iovec_t
*
iov
int
count
long
e_o_s
ogg_int64_t
granulepos
)
{
long
bytes
=
0
lacing_vals
;
int
i
;
if
(
ogg_stream_check
(
os
)
)
return
-
1
;
if
(
!
iov
)
return
0
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
iov
[
i
]
.
iov_len
>
LONG_MAX
)
return
-
1
;
if
(
bytes
>
LONG_MAX
-
(
long
)
iov
[
i
]
.
iov_len
)
return
-
1
;
bytes
+
=
(
long
)
iov
[
i
]
.
iov_len
;
}
lacing_vals
=
bytes
/
255
+
1
;
if
(
os
-
>
body_returned
)
{
os
-
>
body_fill
-
=
os
-
>
body_returned
;
if
(
os
-
>
body_fill
)
memmove
(
os
-
>
body_data
os
-
>
body_data
+
os
-
>
body_returned
os
-
>
body_fill
)
;
os
-
>
body_returned
=
0
;
}
if
(
_os_body_expand
(
os
bytes
)
|
|
_os_lacing_expand
(
os
lacing_vals
)
)
return
-
1
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
memcpy
(
os
-
>
body_data
+
os
-
>
body_fill
iov
[
i
]
.
iov_base
iov
[
i
]
.
iov_len
)
;
os
-
>
body_fill
+
=
(
int
)
iov
[
i
]
.
iov_len
;
}
for
(
i
=
0
;
i
<
lacing_vals
-
1
;
i
+
+
)
{
os
-
>
lacing_vals
[
os
-
>
lacing_fill
+
i
]
=
255
;
os
-
>
granule_vals
[
os
-
>
lacing_fill
+
i
]
=
os
-
>
granulepos
;
}
os
-
>
lacing_vals
[
os
-
>
lacing_fill
+
i
]
=
bytes
%
255
;
os
-
>
granulepos
=
os
-
>
granule_vals
[
os
-
>
lacing_fill
+
i
]
=
granulepos
;
os
-
>
lacing_vals
[
os
-
>
lacing_fill
]
|
=
0x100
;
os
-
>
lacing_fill
+
=
lacing_vals
;
os
-
>
packetno
+
+
;
if
(
e_o_s
)
os
-
>
e_o_s
=
1
;
return
(
0
)
;
}
int
ogg_stream_packetin
(
ogg_stream_state
*
os
ogg_packet
*
op
)
{
ogg_iovec_t
iov
;
iov
.
iov_base
=
op
-
>
packet
;
iov
.
iov_len
=
op
-
>
bytes
;
return
ogg_stream_iovecin
(
os
&
iov
1
op
-
>
e_o_s
op
-
>
granulepos
)
;
}
static
int
ogg_stream_flush_i
(
ogg_stream_state
*
os
ogg_page
*
og
int
force
int
nfill
)
{
int
i
;
int
vals
=
0
;
int
maxvals
;
int
bytes
=
0
;
long
acc
=
0
;
ogg_int64_t
granule_pos
=
-
1
;
if
(
ogg_stream_check
(
os
)
)
return
(
0
)
;
maxvals
=
(
os
-
>
lacing_fill
>
255
?
255
:
os
-
>
lacing_fill
)
;
if
(
maxvals
=
=
0
)
return
(
0
)
;
if
(
os
-
>
b_o_s
=
=
0
)
{
granule_pos
=
0
;
for
(
vals
=
0
;
vals
<
maxvals
;
vals
+
+
)
{
if
(
(
os
-
>
lacing_vals
[
vals
]
&
0x0ff
)
<
255
)
{
vals
+
+
;
break
;
}
}
}
else
{
int
packets_done
=
0
;
int
packet_just_done
=
0
;
for
(
vals
=
0
;
vals
<
maxvals
;
vals
+
+
)
{
if
(
acc
>
nfill
&
&
packet_just_done
>
=
4
)
{
force
=
1
;
break
;
}
acc
+
=
os
-
>
lacing_vals
[
vals
]
&
0x0ff
;
if
(
(
os
-
>
lacing_vals
[
vals
]
&
0xff
)
<
255
)
{
granule_pos
=
os
-
>
granule_vals
[
vals
]
;
packet_just_done
=
+
+
packets_done
;
}
else
packet_just_done
=
0
;
}
if
(
vals
=
=
255
)
force
=
1
;
}
if
(
!
force
)
return
(
0
)
;
memcpy
(
os
-
>
header
"
OggS
"
4
)
;
os
-
>
header
[
4
]
=
0x00
;
os
-
>
header
[
5
]
=
0x00
;
if
(
(
os
-
>
lacing_vals
[
0
]
&
0x100
)
=
=
0
)
os
-
>
header
[
5
]
|
=
0x01
;
if
(
os
-
>
b_o_s
=
=
0
)
os
-
>
header
[
5
]
|
=
0x02
;
if
(
os
-
>
e_o_s
&
&
os
-
>
lacing_fill
=
=
vals
)
os
-
>
header
[
5
]
|
=
0x04
;
os
-
>
b_o_s
=
1
;
for
(
i
=
6
;
i
<
14
;
i
+
+
)
{
os
-
>
header
[
i
]
=
(
unsigned
char
)
(
granule_pos
&
0xff
)
;
granule_pos
>
>
=
8
;
}
{
long
serialno
=
os
-
>
serialno
;
for
(
i
=
14
;
i
<
18
;
i
+
+
)
{
os
-
>
header
[
i
]
=
(
unsigned
char
)
(
serialno
&
0xff
)
;
serialno
>
>
=
8
;
}
}
if
(
os
-
>
pageno
=
=
-
1
)
os
-
>
pageno
=
0
;
{
long
pageno
=
os
-
>
pageno
+
+
;
for
(
i
=
18
;
i
<
22
;
i
+
+
)
{
os
-
>
header
[
i
]
=
(
unsigned
char
)
(
pageno
&
0xff
)
;
pageno
>
>
=
8
;
}
}
os
-
>
header
[
22
]
=
0
;
os
-
>
header
[
23
]
=
0
;
os
-
>
header
[
24
]
=
0
;
os
-
>
header
[
25
]
=
0
;
os
-
>
header
[
26
]
=
(
unsigned
char
)
(
vals
&
0xff
)
;
for
(
i
=
0
;
i
<
vals
;
i
+
+
)
bytes
+
=
os
-
>
header
[
i
+
27
]
=
(
unsigned
char
)
(
os
-
>
lacing_vals
[
i
]
&
0xff
)
;
og
-
>
header
=
os
-
>
header
;
og
-
>
header_len
=
os
-
>
header_fill
=
vals
+
27
;
og
-
>
body
=
os
-
>
body_data
+
os
-
>
body_returned
;
og
-
>
body_len
=
bytes
;
os
-
>
lacing_fill
-
=
vals
;
memmove
(
os
-
>
lacing_vals
os
-
>
lacing_vals
+
vals
os
-
>
lacing_fill
*
sizeof
(
*
os
-
>
lacing_vals
)
)
;
memmove
(
os
-
>
granule_vals
os
-
>
granule_vals
+
vals
os
-
>
lacing_fill
*
sizeof
(
*
os
-
>
granule_vals
)
)
;
os
-
>
body_returned
+
=
bytes
;
ogg_page_checksum_set
(
og
)
;
return
(
1
)
;
}
int
ogg_stream_flush
(
ogg_stream_state
*
os
ogg_page
*
og
)
{
return
ogg_stream_flush_i
(
os
og
1
4096
)
;
}
int
ogg_stream_flush_fill
(
ogg_stream_state
*
os
ogg_page
*
og
int
nfill
)
{
return
ogg_stream_flush_i
(
os
og
1
nfill
)
;
}
int
ogg_stream_pageout
(
ogg_stream_state
*
os
ogg_page
*
og
)
{
int
force
=
0
;
if
(
ogg_stream_check
(
os
)
)
return
0
;
if
(
(
os
-
>
e_o_s
&
&
os
-
>
lacing_fill
)
|
|
(
os
-
>
lacing_fill
&
&
!
os
-
>
b_o_s
)
)
force
=
1
;
return
(
ogg_stream_flush_i
(
os
og
force
4096
)
)
;
}
int
ogg_stream_pageout_fill
(
ogg_stream_state
*
os
ogg_page
*
og
int
nfill
)
{
int
force
=
0
;
if
(
ogg_stream_check
(
os
)
)
return
0
;
if
(
(
os
-
>
e_o_s
&
&
os
-
>
lacing_fill
)
|
|
(
os
-
>
lacing_fill
&
&
!
os
-
>
b_o_s
)
)
force
=
1
;
return
(
ogg_stream_flush_i
(
os
og
force
nfill
)
)
;
}
int
ogg_stream_eos
(
ogg_stream_state
*
os
)
{
if
(
ogg_stream_check
(
os
)
)
return
1
;
return
os
-
>
e_o_s
;
}
int
ogg_sync_init
(
ogg_sync_state
*
oy
)
{
if
(
oy
)
{
oy
-
>
storage
=
-
1
;
memset
(
oy
0
sizeof
(
*
oy
)
)
;
}
return
(
0
)
;
}
int
ogg_sync_clear
(
ogg_sync_state
*
oy
)
{
if
(
oy
)
{
if
(
oy
-
>
data
)
_ogg_free
(
oy
-
>
data
)
;
memset
(
oy
0
sizeof
(
*
oy
)
)
;
}
return
(
0
)
;
}
int
ogg_sync_destroy
(
ogg_sync_state
*
oy
)
{
if
(
oy
)
{
ogg_sync_clear
(
oy
)
;
_ogg_free
(
oy
)
;
}
return
(
0
)
;
}
int
ogg_sync_check
(
ogg_sync_state
*
oy
)
{
if
(
oy
-
>
storage
<
0
)
return
-
1
;
return
0
;
}
char
*
ogg_sync_buffer
(
ogg_sync_state
*
oy
long
size
)
{
if
(
ogg_sync_check
(
oy
)
)
return
NULL
;
if
(
oy
-
>
returned
)
{
oy
-
>
fill
-
=
oy
-
>
returned
;
if
(
oy
-
>
fill
>
0
)
memmove
(
oy
-
>
data
oy
-
>
data
+
oy
-
>
returned
oy
-
>
fill
)
;
oy
-
>
returned
=
0
;
}
if
(
size
>
oy
-
>
storage
-
oy
-
>
fill
)
{
long
newsize
;
void
*
ret
;
if
(
size
>
INT_MAX
-
4096
-
oy
-
>
fill
)
{
ogg_sync_clear
(
oy
)
;
return
NULL
;
}
newsize
=
size
+
oy
-
>
fill
+
4096
;
if
(
oy
-
>
data
)
ret
=
_ogg_realloc
(
oy
-
>
data
newsize
)
;
else
ret
=
_ogg_malloc
(
newsize
)
;
if
(
!
ret
)
{
ogg_sync_clear
(
oy
)
;
return
NULL
;
}
oy
-
>
data
=
ret
;
oy
-
>
storage
=
newsize
;
}
return
(
(
char
*
)
oy
-
>
data
+
oy
-
>
fill
)
;
}
int
ogg_sync_wrote
(
ogg_sync_state
*
oy
long
bytes
)
{
if
(
ogg_sync_check
(
oy
)
)
return
-
1
;
if
(
oy
-
>
fill
+
bytes
>
oy
-
>
storage
)
return
-
1
;
oy
-
>
fill
+
=
bytes
;
return
(
0
)
;
}
long
ogg_sync_pageseek
(
ogg_sync_state
*
oy
ogg_page
*
og
)
{
unsigned
char
*
page
;
unsigned
char
*
next
;
long
bytes
;
if
(
ogg_sync_check
(
oy
)
)
return
0
;
page
=
oy
-
>
data
+
oy
-
>
returned
;
bytes
=
oy
-
>
fill
-
oy
-
>
returned
;
if
(
oy
-
>
headerbytes
=
=
0
)
{
int
headerbytes
i
;
if
(
bytes
<
27
)
return
(
0
)
;
if
(
memcmp
(
page
"
OggS
"
4
)
)
goto
sync_fail
;
headerbytes
=
page
[
26
]
+
27
;
if
(
bytes
<
headerbytes
)
return
(
0
)
;
for
(
i
=
0
;
i
<
page
[
26
]
;
i
+
+
)
oy
-
>
bodybytes
+
=
page
[
27
+
i
]
;
oy
-
>
headerbytes
=
headerbytes
;
}
if
(
oy
-
>
bodybytes
+
oy
-
>
headerbytes
>
bytes
)
return
(
0
)
;
{
char
chksum
[
4
]
;
ogg_page
log
;
memcpy
(
chksum
page
+
22
4
)
;
memset
(
page
+
22
0
4
)
;
log
.
header
=
page
;
log
.
header_len
=
oy
-
>
headerbytes
;
log
.
body
=
page
+
oy
-
>
headerbytes
;
log
.
body_len
=
oy
-
>
bodybytes
;
ogg_page_checksum_set
(
&
log
)
;
if
(
memcmp
(
chksum
page
+
22
4
)
)
{
memcpy
(
page
+
22
chksum
4
)
;
#
ifndef
DISABLE_CRC
goto
sync_fail
;
#
endif
}
}
{
if
(
og
)
{
og
-
>
header
=
page
;
og
-
>
header_len
=
oy
-
>
headerbytes
;
og
-
>
body
=
page
+
oy
-
>
headerbytes
;
og
-
>
body_len
=
oy
-
>
bodybytes
;
}
oy
-
>
unsynced
=
0
;
oy
-
>
returned
+
=
(
bytes
=
oy
-
>
headerbytes
+
oy
-
>
bodybytes
)
;
oy
-
>
headerbytes
=
0
;
oy
-
>
bodybytes
=
0
;
return
(
bytes
)
;
}
sync_fail
:
oy
-
>
headerbytes
=
0
;
oy
-
>
bodybytes
=
0
;
next
=
memchr
(
page
+
1
'
O
'
bytes
-
1
)
;
if
(
!
next
)
next
=
oy
-
>
data
+
oy
-
>
fill
;
oy
-
>
returned
=
(
int
)
(
next
-
oy
-
>
data
)
;
return
(
(
long
)
-
(
next
-
page
)
)
;
}
int
ogg_sync_pageout
(
ogg_sync_state
*
oy
ogg_page
*
og
)
{
if
(
ogg_sync_check
(
oy
)
)
return
0
;
for
(
;
;
)
{
long
ret
=
ogg_sync_pageseek
(
oy
og
)
;
if
(
ret
>
0
)
{
return
(
1
)
;
}
if
(
ret
=
=
0
)
{
return
(
0
)
;
}
if
(
!
oy
-
>
unsynced
)
{
oy
-
>
unsynced
=
1
;
return
(
-
1
)
;
}
}
}
int
ogg_stream_pagein
(
ogg_stream_state
*
os
ogg_page
*
og
)
{
unsigned
char
*
header
=
og
-
>
header
;
unsigned
char
*
body
=
og
-
>
body
;
long
bodysize
=
og
-
>
body_len
;
int
segptr
=
0
;
int
version
=
ogg_page_version
(
og
)
;
int
continued
=
ogg_page_continued
(
og
)
;
int
bos
=
ogg_page_bos
(
og
)
;
int
eos
=
ogg_page_eos
(
og
)
;
ogg_int64_t
granulepos
=
ogg_page_granulepos
(
og
)
;
int
serialno
=
ogg_page_serialno
(
og
)
;
long
pageno
=
ogg_page_pageno
(
og
)
;
int
segments
=
header
[
26
]
;
if
(
ogg_stream_check
(
os
)
)
return
-
1
;
{
long
lr
=
os
-
>
lacing_returned
;
long
br
=
os
-
>
body_returned
;
if
(
br
)
{
os
-
>
body_fill
-
=
br
;
if
(
os
-
>
body_fill
)
memmove
(
os
-
>
body_data
os
-
>
body_data
+
br
os
-
>
body_fill
)
;
os
-
>
body_returned
=
0
;
}
if
(
lr
)
{
if
(
os
-
>
lacing_fill
-
lr
)
{
memmove
(
os
-
>
lacing_vals
os
-
>
lacing_vals
+
lr
(
os
-
>
lacing_fill
-
lr
)
*
sizeof
(
*
os
-
>
lacing_vals
)
)
;
memmove
(
os
-
>
granule_vals
os
-
>
granule_vals
+
lr
(
os
-
>
lacing_fill
-
lr
)
*
sizeof
(
*
os
-
>
granule_vals
)
)
;
}
os
-
>
lacing_fill
-
=
lr
;
os
-
>
lacing_packet
-
=
lr
;
os
-
>
lacing_returned
=
0
;
}
}
if
(
serialno
!
=
os
-
>
serialno
)
return
(
-
1
)
;
if
(
version
>
0
)
return
(
-
1
)
;
if
(
_os_lacing_expand
(
os
segments
+
1
)
)
return
-
1
;
if
(
pageno
!
=
os
-
>
pageno
)
{
int
i
;
for
(
i
=
os
-
>
lacing_packet
;
i
<
os
-
>
lacing_fill
;
i
+
+
)
os
-
>
body_fill
-
=
os
-
>
lacing_vals
[
i
]
&
0xff
;
os
-
>
lacing_fill
=
os
-
>
lacing_packet
;
if
(
os
-
>
pageno
!
=
-
1
)
{
os
-
>
lacing_vals
[
os
-
>
lacing_fill
+
+
]
=
0x400
;
os
-
>
lacing_packet
+
+
;
}
}
if
(
continued
)
{
if
(
os
-
>
lacing_fill
<
1
|
|
(
os
-
>
lacing_vals
[
os
-
>
lacing_fill
-
1
]
&
0xff
)
<
255
|
|
os
-
>
lacing_vals
[
os
-
>
lacing_fill
-
1
]
=
=
0x400
)
{
bos
=
0
;
for
(
;
segptr
<
segments
;
segptr
+
+
)
{
int
val
=
header
[
27
+
segptr
]
;
body
+
=
val
;
bodysize
-
=
val
;
if
(
val
<
255
)
{
segptr
+
+
;
break
;
}
}
}
}
if
(
bodysize
)
{
if
(
_os_body_expand
(
os
bodysize
)
)
return
-
1
;
memcpy
(
os
-
>
body_data
+
os
-
>
body_fill
body
bodysize
)
;
os
-
>
body_fill
+
=
bodysize
;
}
{
int
saved
=
-
1
;
while
(
segptr
<
segments
)
{
int
val
=
header
[
27
+
segptr
]
;
os
-
>
lacing_vals
[
os
-
>
lacing_fill
]
=
val
;
os
-
>
granule_vals
[
os
-
>
lacing_fill
]
=
-
1
;
if
(
bos
)
{
os
-
>
lacing_vals
[
os
-
>
lacing_fill
]
|
=
0x100
;
bos
=
0
;
}
if
(
val
<
255
)
saved
=
os
-
>
lacing_fill
;
os
-
>
lacing_fill
+
+
;
segptr
+
+
;
if
(
val
<
255
)
os
-
>
lacing_packet
=
os
-
>
lacing_fill
;
}
if
(
saved
!
=
-
1
)
{
os
-
>
granule_vals
[
saved
]
=
granulepos
;
}
}
if
(
eos
)
{
os
-
>
e_o_s
=
1
;
if
(
os
-
>
lacing_fill
>
0
)
os
-
>
lacing_vals
[
os
-
>
lacing_fill
-
1
]
|
=
0x200
;
}
os
-
>
pageno
=
pageno
+
1
;
return
(
0
)
;
}
int
ogg_sync_reset
(
ogg_sync_state
*
oy
)
{
if
(
ogg_sync_check
(
oy
)
)
return
-
1
;
oy
-
>
fill
=
0
;
oy
-
>
returned
=
0
;
oy
-
>
unsynced
=
0
;
oy
-
>
headerbytes
=
0
;
oy
-
>
bodybytes
=
0
;
return
(
0
)
;
}
int
ogg_stream_reset
(
ogg_stream_state
*
os
)
{
if
(
ogg_stream_check
(
os
)
)
return
-
1
;
os
-
>
body_fill
=
0
;
os
-
>
body_returned
=
0
;
os
-
>
lacing_fill
=
0
;
os
-
>
lacing_packet
=
0
;
os
-
>
lacing_returned
=
0
;
os
-
>
header_fill
=
0
;
os
-
>
e_o_s
=
0
;
os
-
>
b_o_s
=
0
;
os
-
>
pageno
=
-
1
;
os
-
>
packetno
=
0
;
os
-
>
granulepos
=
0
;
return
(
0
)
;
}
int
ogg_stream_reset_serialno
(
ogg_stream_state
*
os
int
serialno
)
{
if
(
ogg_stream_check
(
os
)
)
return
-
1
;
ogg_stream_reset
(
os
)
;
os
-
>
serialno
=
serialno
;
return
(
0
)
;
}
static
int
_packetout
(
ogg_stream_state
*
os
ogg_packet
*
op
int
adv
)
{
int
ptr
=
os
-
>
lacing_returned
;
if
(
os
-
>
lacing_packet
<
=
ptr
)
return
(
0
)
;
if
(
os
-
>
lacing_vals
[
ptr
]
&
0x400
)
{
os
-
>
lacing_returned
+
+
;
os
-
>
packetno
+
+
;
return
(
-
1
)
;
}
if
(
!
op
&
&
!
adv
)
return
(
1
)
;
{
int
size
=
os
-
>
lacing_vals
[
ptr
]
&
0xff
;
long
bytes
=
size
;
int
eos
=
os
-
>
lacing_vals
[
ptr
]
&
0x200
;
int
bos
=
os
-
>
lacing_vals
[
ptr
]
&
0x100
;
while
(
size
=
=
255
)
{
int
val
=
os
-
>
lacing_vals
[
+
+
ptr
]
;
size
=
val
&
0xff
;
if
(
val
&
0x200
)
eos
=
0x200
;
bytes
+
=
size
;
}
if
(
op
)
{
op
-
>
e_o_s
=
eos
;
op
-
>
b_o_s
=
bos
;
op
-
>
packet
=
os
-
>
body_data
+
os
-
>
body_returned
;
op
-
>
packetno
=
os
-
>
packetno
;
op
-
>
granulepos
=
os
-
>
granule_vals
[
ptr
]
;
op
-
>
bytes
=
bytes
;
}
if
(
adv
)
{
os
-
>
body_returned
+
=
bytes
;
os
-
>
lacing_returned
=
ptr
+
1
;
os
-
>
packetno
+
+
;
}
}
return
(
1
)
;
}
int
ogg_stream_packetout
(
ogg_stream_state
*
os
ogg_packet
*
op
)
{
if
(
ogg_stream_check
(
os
)
)
return
0
;
return
_packetout
(
os
op
1
)
;
}
int
ogg_stream_packetpeek
(
ogg_stream_state
*
os
ogg_packet
*
op
)
{
if
(
ogg_stream_check
(
os
)
)
return
0
;
return
_packetout
(
os
op
0
)
;
}
void
ogg_packet_clear
(
ogg_packet
*
op
)
{
_ogg_free
(
op
-
>
packet
)
;
memset
(
op
0
sizeof
(
*
op
)
)
;
}
#
ifdef
_V_SELFTEST
#
include
<
stdio
.
h
>
ogg_stream_state
os_en
os_de
;
ogg_sync_state
oy
;
void
checkpacket
(
ogg_packet
*
op
long
len
int
no
long
pos
)
{
long
j
;
static
int
sequence
=
0
;
static
int
lastno
=
0
;
if
(
op
-
>
bytes
!
=
len
)
{
fprintf
(
stderr
"
incorrect
packet
length
(
%
ld
!
=
%
ld
)
!
\
n
"
op
-
>
bytes
len
)
;
exit
(
1
)
;
}
if
(
op
-
>
granulepos
!
=
pos
)
{
fprintf
(
stderr
"
incorrect
packet
granpos
(
%
ld
!
=
%
ld
)
!
\
n
"
(
long
)
op
-
>
granulepos
pos
)
;
exit
(
1
)
;
}
if
(
no
=
=
0
)
{
sequence
=
0
;
}
else
{
sequence
+
+
;
if
(
no
>
lastno
+
1
)
sequence
+
+
;
}
lastno
=
no
;
if
(
op
-
>
packetno
!
=
sequence
)
{
fprintf
(
stderr
"
incorrect
packet
sequence
%
ld
!
=
%
d
\
n
"
(
long
)
(
op
-
>
packetno
)
sequence
)
;
exit
(
1
)
;
}
for
(
j
=
0
;
j
<
op
-
>
bytes
;
j
+
+
)
if
(
op
-
>
packet
[
j
]
!
=
(
(
j
+
no
)
&
0xff
)
)
{
fprintf
(
stderr
"
body
data
mismatch
(
1
)
at
pos
%
ld
:
%
x
!
=
%
lx
!
\
n
\
n
"
j
op
-
>
packet
[
j
]
(
j
+
no
)
&
0xff
)
;
exit
(
1
)
;
}
}
void
check_page
(
unsigned
char
*
data
const
int
*
header
ogg_page
*
og
)
{
long
j
;
for
(
j
=
0
;
j
<
og
-
>
body_len
;
j
+
+
)
if
(
og
-
>
body
[
j
]
!
=
data
[
j
]
)
{
fprintf
(
stderr
"
body
data
mismatch
(
2
)
at
pos
%
ld
:
%
x
!
=
%
x
!
\
n
\
n
"
j
data
[
j
]
og
-
>
body
[
j
]
)
;
exit
(
1
)
;
}
for
(
j
=
0
;
j
<
og
-
>
header_len
;
j
+
+
)
{
if
(
og
-
>
header
[
j
]
!
=
header
[
j
]
)
{
fprintf
(
stderr
"
header
content
mismatch
at
pos
%
ld
:
\
n
"
j
)
;
for
(
j
=
0
;
j
<
header
[
26
]
+
27
;
j
+
+
)
fprintf
(
stderr
"
(
%
ld
)
%
02x
:
%
02x
"
j
header
[
j
]
og
-
>
header
[
j
]
)
;
fprintf
(
stderr
"
\
n
"
)
;
exit
(
1
)
;
}
}
if
(
og
-
>
header_len
!
=
header
[
26
]
+
27
)
{
fprintf
(
stderr
"
header
length
incorrect
!
(
%
ld
!
=
%
d
)
\
n
"
og
-
>
header_len
header
[
26
]
+
27
)
;
exit
(
1
)
;
}
}
void
print_header
(
ogg_page
*
og
)
{
int
j
;
fprintf
(
stderr
"
\
nHEADER
:
\
n
"
)
;
fprintf
(
stderr
"
capture
:
%
c
%
c
%
c
%
c
version
:
%
d
flags
:
%
x
\
n
"
og
-
>
header
[
0
]
og
-
>
header
[
1
]
og
-
>
header
[
2
]
og
-
>
header
[
3
]
(
int
)
og
-
>
header
[
4
]
(
int
)
og
-
>
header
[
5
]
)
;
fprintf
(
stderr
"
granulepos
:
%
d
serialno
:
%
d
pageno
:
%
ld
\
n
"
(
(
unsigned
)
og
-
>
header
[
9
]
<
<
24
)
|
(
og
-
>
header
[
8
]
<
<
16
)
|
(
og
-
>
header
[
7
]
<
<
8
)
|
og
-
>
header
[
6
]
(
(
unsigned
)
og
-
>
header
[
17
]
<
<
24
)
|
(
og
-
>
header
[
16
]
<
<
16
)
|
(
og
-
>
header
[
15
]
<
<
8
)
|
og
-
>
header
[
14
]
(
(
long
)
(
(
unsigned
)
og
-
>
header
[
21
]
)
<
<
24
)
|
(
og
-
>
header
[
20
]
<
<
16
)
|
(
og
-
>
header
[
19
]
<
<
8
)
|
og
-
>
header
[
18
]
)
;
fprintf
(
stderr
"
checksum
:
%
02x
:
%
02x
:
%
02x
:
%
02x
\
n
segments
:
%
d
(
"
(
int
)
og
-
>
header
[
22
]
(
int
)
og
-
>
header
[
23
]
(
int
)
og
-
>
header
[
24
]
(
int
)
og
-
>
header
[
25
]
(
int
)
og
-
>
header
[
26
]
)
;
for
(
j
=
27
;
j
<
og
-
>
header_len
;
j
+
+
)
fprintf
(
stderr
"
%
d
"
(
int
)
og
-
>
header
[
j
]
)
;
fprintf
(
stderr
"
)
\
n
\
n
"
)
;
}
static
int
copy_page
(
ogg_page
*
og
)
{
unsigned
char
*
temp
=
_ogg_malloc
(
og
-
>
header_len
)
;
if
(
!
temp
)
return
-
1
;
memcpy
(
temp
og
-
>
header
og
-
>
header_len
)
;
og
-
>
header
=
temp
;
temp
=
_ogg_malloc
(
og
-
>
body_len
)
;
if
(
!
temp
)
return
-
1
;
memcpy
(
temp
og
-
>
body
og
-
>
body_len
)
;
og
-
>
body
=
temp
;
return
0
;
}
static
void
free_page
(
ogg_page
*
og
)
{
_ogg_free
(
og
-
>
header
)
;
og
-
>
header
=
NULL
;
_ogg_free
(
og
-
>
body
)
;
og
-
>
body
=
NULL
;
}
void
error
(
void
)
{
fprintf
(
stderr
"
error
!
\
n
"
)
;
exit
(
1
)
;
}
const
int
head1_0
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x06
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0
0
0
0
0x15
0xed
0xec
0x91
1
17
}
;
const
int
head1_1
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x02
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0
0
0
0
0x59
0x10
0x6c
0x2c
1
17
}
;
const
int
head2_1
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x04
0x07
0x18
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
1
0
0
0
0x89
0x33
0x85
0xce
13
254
255
0
255
1
255
245
255
255
0
255
255
90
}
;
const
int
head1_2
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x02
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0
0
0
0
0xff
0x7b
0x23
0x17
1
0
}
;
const
int
head2_2
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x04
0x07
0x28
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
1
0
0
0
0x5c
0x3f
0x66
0xcb
17
17
254
255
0
0
255
1
0
255
245
255
255
0
255
255
90
0
}
;
const
int
head1_3
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x02
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0
0
0
0
0x01
0x27
0x31
0xaa
18
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
10
}
;
const
int
head2_3
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x04
0x07
0x08
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
1
0
0
0
0x7f
0x4e
0x8a
0xd2
4
255
4
255
0
}
;
const
int
head1_4
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x02
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0
0
0
0
0xff
0x7b
0x23
0x17
1
0
}
;
const
int
head2_4
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x00
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0x01
0x02
0x03
0x04
1
0
0
0
0xf8
0x3c
0x19
0x79
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
}
;
const
int
head3_4
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x05
0x07
0x0c
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
2
0
0
0
0x38
0xe6
0xb6
0x28
6
255
220
255
4
255
0
}
;
const
int
head1_4b
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x02
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0
0
0
0
0xff
0x7b
0x23
0x17
1
0
}
;
const
int
head2_4b
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x00
0x07
0x10
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
1
0
0
0
0xce
0x8f
0x17
0x1a
23
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
10
255
4
255
0
0
}
;
const
int
head3_4b
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x04
0x07
0x14
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
2
0
0
0
0x9b
0xb2
0x50
0xa1
1
0
}
;
const
int
head1_5
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x02
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0
0
0
0
0xff
0x7b
0x23
0x17
1
0
}
;
const
int
head2_5
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x00
0x07
0xfc
0x03
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
1
0
0
0
0xed
0x2a
0x2e
0xa7
255
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
}
;
const
int
head3_5
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x04
0x07
0x00
0x04
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
2
0
0
0
0x6c
0x3b
0x82
0x3d
1
50
}
;
const
int
head1_6
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x02
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0
0
0
0
0xff
0x7b
0x23
0x17
1
0
}
;
const
int
head2_6
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x00
0x07
0x04
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
1
0
0
0
0x68
0x22
0x7c
0x3d
255
100
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
}
;
const
int
head3_6
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x01
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0x01
0x02
0x03
0x04
2
0
0
0
0xf4
0x87
0xba
0xf3
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
}
;
const
int
head4_6
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x05
0x07
0x10
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
3
0
0
0
0xf7
0x2f
0x6c
0x60
5
254
255
4
255
0
}
;
const
int
head1_7
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x02
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
0
0
0
0
0xff
0x7b
0x23
0x17
1
0
}
;
const
int
head2_7
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x00
0x07
0x04
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
1
0
0
0
0x68
0x22
0x7c
0x3d
255
100
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
255
}
;
const
int
head3_7
[
]
=
{
0x4f
0x67
0x67
0x53
0
0x05
0x07
0x08
0x00
0x00
0x00
0x00
0x00
0x00
0x01
0x02
0x03
0x04
2
0
0
0
0xd4
0xe0
0x60
0xe5
1
0
}
;
int
compare_packet
(
const
ogg_packet
*
op1
const
ogg_packet
*
op2
)
{
if
(
op1
-
>
packet
!
=
op2
-
>
packet
)
{
fprintf
(
stderr
"
op1
-
>
packet
!
=
op2
-
>
packet
\
n
"
)
;
return
(
1
)
;
}
if
(
op1
-
>
bytes
!
=
op2
-
>
bytes
)
{
fprintf
(
stderr
"
op1
-
>
bytes
!
=
op2
-
>
bytes
\
n
"
)
;
return
(
1
)
;
}
if
(
op1
-
>
b_o_s
!
=
op2
-
>
b_o_s
)
{
fprintf
(
stderr
"
op1
-
>
b_o_s
!
=
op2
-
>
b_o_s
\
n
"
)
;
return
(
1
)
;
}
if
(
op1
-
>
e_o_s
!
=
op2
-
>
e_o_s
)
{
fprintf
(
stderr
"
op1
-
>
e_o_s
!
=
op2
-
>
e_o_s
\
n
"
)
;
return
(
1
)
;
}
if
(
op1
-
>
granulepos
!
=
op2
-
>
granulepos
)
{
fprintf
(
stderr
"
op1
-
>
granulepos
!
=
op2
-
>
granulepos
\
n
"
)
;
return
(
1
)
;
}
if
(
op1
-
>
packetno
!
=
op2
-
>
packetno
)
{
fprintf
(
stderr
"
op1
-
>
packetno
!
=
op2
-
>
packetno
\
n
"
)
;
return
(
1
)
;
}
return
(
0
)
;
}
void
test_pack
(
const
int
*
pl
const
int
*
*
headers
int
byteskip
int
pageskip
int
packetskip
)
{
unsigned
char
*
data
=
_ogg_malloc
(
1024
*
1024
)
;
long
inptr
=
0
;
long
outptr
=
0
;
long
deptr
=
0
;
long
depacket
=
0
;
long
granule_pos
=
7
pageno
=
0
;
int
i
j
packets
pageout
=
pageskip
;
int
eosflag
=
0
;
int
bosflag
=
0
;
int
byteskipcount
=
0
;
if
(
!
data
)
{
fprintf
(
stderr
"
unable
to
allocate
requried
data
buffer
!
\
n
"
)
;
exit
(
1
)
;
}
ogg_stream_reset
(
&
os_en
)
;
ogg_stream_reset
(
&
os_de
)
;
ogg_sync_reset
(
&
oy
)
;
for
(
packets
=
0
;
packets
<
packetskip
;
packets
+
+
)
depacket
+
=
pl
[
packets
]
;
for
(
packets
=
0
;
;
packets
+
+
)
if
(
pl
[
packets
]
=
=
-
1
)
break
;
for
(
i
=
0
;
i
<
packets
;
i
+
+
)
{
ogg_packet
op
;
int
len
=
pl
[
i
]
;
op
.
packet
=
data
+
inptr
;
op
.
bytes
=
len
;
op
.
e_o_s
=
(
pl
[
i
+
1
]
<
0
?
1
:
0
)
;
op
.
granulepos
=
granule_pos
;
granule_pos
+
=
1024
;
for
(
j
=
0
;
j
<
len
;
j
+
+
)
data
[
inptr
+
+
]
=
i
+
j
;
ogg_stream_packetin
(
&
os_en
&
op
)
;
{
ogg_page
og
;
while
(
ogg_stream_pageout
(
&
os_en
&
og
)
)
{
fprintf
(
stderr
"
%
ld
"
pageno
)
;
if
(
headers
[
pageno
]
=
=
NULL
)
{
fprintf
(
stderr
"
coded
too
many
pages
!
\
n
"
)
;
exit
(
1
)
;
}
check_page
(
data
+
outptr
headers
[
pageno
]
&
og
)
;
outptr
+
=
og
.
body_len
;
pageno
+
+
;
if
(
pageskip
)
{
bosflag
=
1
;
pageskip
-
-
;
deptr
+
=
og
.
body_len
;
}
{
ogg_page
og_de
;
ogg_packet
op_de
op_de2
;
char
*
buf
=
ogg_sync_buffer
(
&
oy
og
.
header_len
+
og
.
body_len
)
;
char
*
next
=
buf
;
byteskipcount
+
=
og
.
header_len
;
if
(
byteskipcount
>
byteskip
)
{
memcpy
(
next
og
.
header
byteskipcount
-
byteskip
)
;
next
+
=
byteskipcount
-
byteskip
;
byteskipcount
=
byteskip
;
}
byteskipcount
+
=
og
.
body_len
;
if
(
byteskipcount
>
byteskip
)
{
memcpy
(
next
og
.
body
byteskipcount
-
byteskip
)
;
next
+
=
byteskipcount
-
byteskip
;
byteskipcount
=
byteskip
;
}
ogg_sync_wrote
(
&
oy
(
long
)
(
next
-
buf
)
)
;
while
(
1
)
{
int
ret
=
ogg_sync_pageout
(
&
oy
&
og_de
)
;
if
(
ret
=
=
0
)
break
;
if
(
ret
<
0
)
continue
;
fprintf
(
stderr
"
(
%
d
)
"
pageout
)
;
check_page
(
data
+
deptr
headers
[
pageout
]
&
og_de
)
;
deptr
+
=
og_de
.
body_len
;
pageout
+
+
;
ogg_stream_pagein
(
&
os_de
&
og_de
)
;
while
(
ogg_stream_packetpeek
(
&
os_de
&
op_de2
)
>
0
)
{
ogg_stream_packetpeek
(
&
os_de
NULL
)
;
ogg_stream_packetout
(
&
os_de
&
op_de
)
;
if
(
compare_packet
(
&
op_de
&
op_de2
)
)
{
fprintf
(
stderr
"
packetout
!
=
packetpeek
!
pos
=
%
ld
\
n
"
depacket
)
;
exit
(
1
)
;
}
if
(
memcmp
(
data
+
depacket
op_de
.
packet
op_de
.
bytes
)
)
{
fprintf
(
stderr
"
packet
data
mismatch
in
decode
!
pos
=
%
ld
\
n
"
depacket
)
;
exit
(
1
)
;
}
if
(
bosflag
=
=
0
&
&
op_de
.
b_o_s
=
=
0
)
{
fprintf
(
stderr
"
b_o_s
flag
not
set
on
packet
!
\
n
"
)
;
exit
(
1
)
;
}
if
(
bosflag
&
&
op_de
.
b_o_s
)
{
fprintf
(
stderr
"
b_o_s
flag
incorrectly
set
on
packet
!
\
n
"
)
;
exit
(
1
)
;
}
bosflag
=
1
;
depacket
+
=
op_de
.
bytes
;
if
(
eosflag
)
{
fprintf
(
stderr
"
Multiple
decoded
packets
with
eos
flag
!
\
n
"
)
;
exit
(
1
)
;
}
if
(
op_de
.
e_o_s
)
eosflag
=
1
;
if
(
op_de
.
granulepos
!
=
-
1
)
{
fprintf
(
stderr
"
granule
:
%
ld
"
(
long
)
op_de
.
granulepos
)
;
}
}
}
}
}
}
}
_ogg_free
(
data
)
;
if
(
headers
[
pageno
]
!
=
NULL
)
{
fprintf
(
stderr
"
did
not
write
last
page
!
\
n
"
)
;
exit
(
1
)
;
}
if
(
headers
[
pageout
]
!
=
NULL
)
{
fprintf
(
stderr
"
did
not
decode
last
page
!
\
n
"
)
;
exit
(
1
)
;
}
if
(
inptr
!
=
outptr
)
{
fprintf
(
stderr
"
encoded
page
data
incomplete
!
\
n
"
)
;
exit
(
1
)
;
}
if
(
inptr
!
=
deptr
)
{
fprintf
(
stderr
"
decoded
page
data
incomplete
!
\
n
"
)
;
exit
(
1
)
;
}
if
(
inptr
!
=
depacket
)
{
fprintf
(
stderr
"
decoded
packet
data
incomplete
!
\
n
"
)
;
exit
(
1
)
;
}
if
(
!
eosflag
)
{
fprintf
(
stderr
"
Never
got
a
packet
with
EOS
set
!
\
n
"
)
;
exit
(
1
)
;
}
fprintf
(
stderr
"
ok
.
\
n
"
)
;
}
int
main
(
void
)
{
ogg_stream_init
(
&
os_en
0x04030201
)
;
ogg_stream_init
(
&
os_de
0x04030201
)
;
ogg_sync_init
(
&
oy
)
;
{
const
int
packets
[
]
=
{
17
-
1
}
;
const
int
*
headret
[
]
=
{
head1_0
NULL
}
;
fprintf
(
stderr
"
testing
single
page
encoding
.
.
.
"
)
;
test_pack
(
packets
headret
0
0
0
)
;
}
{
const
int
packets
[
]
=
{
17
254
255
256
500
510
600
-
1
}
;
const
int
*
headret
[
]
=
{
head1_1
head2_1
NULL
}
;
fprintf
(
stderr
"
testing
basic
page
encoding
.
.
.
"
)
;
test_pack
(
packets
headret
0
0
0
)
;
}
{
const
int
packets
[
]
=
{
0
17
254
255
0
256
0
500
510
600
0
-
1
}
;
const
int
*
headret
[
]
=
{
head1_2
head2_2
NULL
}
;
fprintf
(
stderr
"
testing
basic
nil
packets
.
.
.
"
)
;
test_pack
(
packets
headret
0
0
0
)
;
}
{
const
int
packets
[
]
=
{
4345
259
255
-
1
}
;
const
int
*
headret
[
]
=
{
head1_3
head2_3
NULL
}
;
fprintf
(
stderr
"
testing
initial
-
packet
lacing
>
4k
.
.
.
"
)
;
test_pack
(
packets
headret
0
0
0
)
;
}
{
const
int
packets
[
]
=
{
0
65500
259
255
-
1
}
;
const
int
*
headret
[
]
=
{
head1_4
head2_4
head3_4
NULL
}
;
fprintf
(
stderr
"
testing
single
packet
page
span
.
.
.
"
)
;
test_pack
(
packets
headret
0
0
0
)
;
}
{
const
int
packets
[
]
=
{
0
4345
259
255
0
0
-
1
}
;
const
int
*
headret
[
]
=
{
head1_4b
head2_4b
head3_4b
NULL
}
;
fprintf
(
stderr
"
testing
page
spill
expansion
.
.
.
"
)
;
test_pack
(
packets
headret
0
0
0
)
;
}
{
const
int
packets
[
]
=
{
0
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
50
-
1
}
;
const
int
*
headret
[
]
=
{
head1_5
head2_5
head3_5
NULL
}
;
fprintf
(
stderr
"
testing
max
packet
segments
.
.
.
"
)
;
test_pack
(
packets
headret
0
0
0
)
;
}
{
const
int
packets
[
]
=
{
0
100
130049
259
255
-
1
}
;
const
int
*
headret
[
]
=
{
head1_6
head2_6
head3_6
head4_6
NULL
}
;
fprintf
(
stderr
"
testing
very
large
packets
.
.
.
"
)
;
test_pack
(
packets
headret
0
0
0
)
;
}
#
ifndef
DISABLE_CRC
{
const
int
packets
[
]
=
{
0
100
130049
259
255
-
1
}
;
const
int
*
headret
[
]
=
{
head1_6
head2_6
head3_6
head4_6
NULL
}
;
fprintf
(
stderr
"
testing
continuation
resync
in
very
large
packets
.
.
.
"
)
;
test_pack
(
packets
headret
100
2
3
)
;
}
#
else
fprintf
(
stderr
"
Skipping
continuation
resync
test
due
to
-
-
disable
-
crc
\
n
"
)
;
#
endif
{
const
int
packets
[
]
=
{
0
100
64770
-
1
}
;
const
int
*
headret
[
]
=
{
head1_7
head2_7
head3_7
NULL
}
;
fprintf
(
stderr
"
testing
zero
data
page
(
1
nil
packet
)
.
.
.
"
)
;
test_pack
(
packets
headret
0
0
0
)
;
}
{
unsigned
char
*
data
=
_ogg_malloc
(
1024
*
1024
)
;
int
pl
[
]
=
{
0
1
1
98
4079
1
1
2954
2057
76
34
912
0
234
1000
1000
1000
300
-
1
}
;
int
inptr
=
0
i
j
;
ogg_page
og
[
5
]
;
if
(
!
data
)
{
fprintf
(
stderr
"
unable
to
allocate
requried
packet
data
buffer
!
\
n
"
)
;
exit
(
1
)
;
}
ogg_stream_reset
(
&
os_en
)
;
for
(
i
=
0
;
pl
[
i
]
!
=
-
1
;
i
+
+
)
{
ogg_packet
op
;
int
len
=
pl
[
i
]
;
op
.
packet
=
data
+
inptr
;
op
.
bytes
=
len
;
op
.
e_o_s
=
(
pl
[
i
+
1
]
<
0
?
1
:
0
)
;
op
.
granulepos
=
(
i
+
1
)
*
1000
;
for
(
j
=
0
;
j
<
len
;
j
+
+
)
data
[
inptr
+
+
]
=
i
+
j
;
ogg_stream_packetin
(
&
os_en
&
op
)
;
}
_ogg_free
(
data
)
;
for
(
i
=
0
;
i
<
5
;
i
+
+
)
{
if
(
ogg_stream_pageout
(
&
os_en
&
og
[
i
]
)
=
=
0
)
{
fprintf
(
stderr
"
Too
few
pages
output
building
sync
tests
!
\
n
"
)
;
exit
(
1
)
;
}
if
(
-
1
=
=
copy_page
(
&
og
[
i
]
)
)
{
fprintf
(
stderr
"
unable
to
copy
page
building
sync
tests
!
\
n
"
)
;
exit
(
1
)
;
}
}
{
ogg_page
temp
;
ogg_packet
test
;
fprintf
(
stderr
"
Testing
loss
of
pages
.
.
.
"
)
;
ogg_sync_reset
(
&
oy
)
;
ogg_stream_reset
(
&
os_de
)
;
for
(
i
=
0
;
i
<
5
;
i
+
+
)
{
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
i
]
.
header_len
)
og
[
i
]
.
header
og
[
i
]
.
header_len
)
;
ogg_sync_wrote
(
&
oy
og
[
i
]
.
header_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
i
]
.
body_len
)
og
[
i
]
.
body
og
[
i
]
.
body_len
)
;
ogg_sync_wrote
(
&
oy
og
[
i
]
.
body_len
)
;
}
ogg_sync_pageout
(
&
oy
&
temp
)
;
ogg_stream_pagein
(
&
os_de
&
temp
)
;
ogg_sync_pageout
(
&
oy
&
temp
)
;
ogg_stream_pagein
(
&
os_de
&
temp
)
;
ogg_sync_pageout
(
&
oy
&
temp
)
;
ogg_sync_pageout
(
&
oy
&
temp
)
;
ogg_stream_pagein
(
&
os_de
&
temp
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
0
0
0
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
1
1
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
1
2
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
98
3
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
4079
4
5000
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
-
1
)
{
fprintf
(
stderr
"
Error
:
loss
of
page
did
not
return
error
\
n
"
)
;
exit
(
1
)
;
}
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
76
9
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
34
10
-
1
)
;
fprintf
(
stderr
"
ok
.
\
n
"
)
;
}
{
ogg_page
temp
;
ogg_packet
test
;
fprintf
(
stderr
"
Testing
loss
of
pages
(
rollback
required
)
.
.
.
"
)
;
ogg_sync_reset
(
&
oy
)
;
ogg_stream_reset
(
&
os_de
)
;
for
(
i
=
0
;
i
<
5
;
i
+
+
)
{
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
i
]
.
header_len
)
og
[
i
]
.
header
og
[
i
]
.
header_len
)
;
ogg_sync_wrote
(
&
oy
og
[
i
]
.
header_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
i
]
.
body_len
)
og
[
i
]
.
body
og
[
i
]
.
body_len
)
;
ogg_sync_wrote
(
&
oy
og
[
i
]
.
body_len
)
;
}
ogg_sync_pageout
(
&
oy
&
temp
)
;
ogg_stream_pagein
(
&
os_de
&
temp
)
;
ogg_sync_pageout
(
&
oy
&
temp
)
;
ogg_stream_pagein
(
&
os_de
&
temp
)
;
ogg_sync_pageout
(
&
oy
&
temp
)
;
ogg_stream_pagein
(
&
os_de
&
temp
)
;
ogg_sync_pageout
(
&
oy
&
temp
)
;
ogg_sync_pageout
(
&
oy
&
temp
)
;
ogg_stream_pagein
(
&
os_de
&
temp
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
0
0
0
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
1
1
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
1
2
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
98
3
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
4079
4
5000
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
1
5
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
1
6
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
2954
7
-
1
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
2057
8
9000
)
;
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
-
1
)
{
fprintf
(
stderr
"
Error
:
loss
of
page
did
not
return
error
\
n
"
)
;
exit
(
1
)
;
}
if
(
ogg_stream_packetout
(
&
os_de
&
test
)
!
=
1
)
error
(
)
;
checkpacket
(
&
test
300
17
18000
)
;
fprintf
(
stderr
"
ok
.
\
n
"
)
;
}
{
ogg_page
og_de
;
fprintf
(
stderr
"
Testing
sync
on
partial
inputs
.
.
.
"
)
;
ogg_sync_reset
(
&
oy
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
header_len
)
og
[
1
]
.
header
3
)
;
ogg_sync_wrote
(
&
oy
3
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
>
0
)
error
(
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
header_len
)
og
[
1
]
.
header
+
3
20
)
;
ogg_sync_wrote
(
&
oy
20
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
>
0
)
error
(
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
header_len
)
og
[
1
]
.
header
+
23
5
)
;
ogg_sync_wrote
(
&
oy
5
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
>
0
)
error
(
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
header_len
)
og
[
1
]
.
header
+
28
og
[
1
]
.
header_len
-
28
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
header_len
-
28
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
>
0
)
error
(
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
body_len
)
og
[
1
]
.
body
1000
)
;
ogg_sync_wrote
(
&
oy
1000
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
>
0
)
error
(
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
body_len
)
og
[
1
]
.
body
+
1000
og
[
1
]
.
body_len
-
1000
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
body_len
-
1000
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
<
=
0
)
error
(
)
;
fprintf
(
stderr
"
ok
.
\
n
"
)
;
}
{
ogg_page
og_de
;
fprintf
(
stderr
"
Testing
sync
on
1
+
partial
inputs
.
.
.
"
)
;
ogg_sync_reset
(
&
oy
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
header_len
)
og
[
1
]
.
header
og
[
1
]
.
header_len
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
header_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
body_len
)
og
[
1
]
.
body
og
[
1
]
.
body_len
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
body_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
header_len
)
og
[
1
]
.
header
20
)
;
ogg_sync_wrote
(
&
oy
20
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
<
=
0
)
error
(
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
>
0
)
error
(
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
header_len
)
og
[
1
]
.
header
+
20
og
[
1
]
.
header_len
-
20
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
header_len
-
20
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
body_len
)
og
[
1
]
.
body
og
[
1
]
.
body_len
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
body_len
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
<
=
0
)
error
(
)
;
fprintf
(
stderr
"
ok
.
\
n
"
)
;
}
{
ogg_page
og_de
;
fprintf
(
stderr
"
Testing
search
for
capture
.
.
.
"
)
;
ogg_sync_reset
(
&
oy
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
body_len
)
og
[
1
]
.
body
og
[
1
]
.
body_len
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
body_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
header_len
)
og
[
1
]
.
header
og
[
1
]
.
header_len
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
header_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
body_len
)
og
[
1
]
.
body
og
[
1
]
.
body_len
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
body_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
2
]
.
header_len
)
og
[
2
]
.
header
20
)
;
ogg_sync_wrote
(
&
oy
20
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
>
0
)
error
(
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
<
=
0
)
error
(
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
>
0
)
error
(
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
2
]
.
header_len
)
og
[
2
]
.
header
+
20
og
[
2
]
.
header_len
-
20
)
;
ogg_sync_wrote
(
&
oy
og
[
2
]
.
header_len
-
20
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
2
]
.
body_len
)
og
[
2
]
.
body
og
[
2
]
.
body_len
)
;
ogg_sync_wrote
(
&
oy
og
[
2
]
.
body_len
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
<
=
0
)
error
(
)
;
fprintf
(
stderr
"
ok
.
\
n
"
)
;
}
#
ifndef
DISABLE_CRC
{
ogg_page
og_de
;
fprintf
(
stderr
"
Testing
recapture
.
.
.
"
)
;
ogg_sync_reset
(
&
oy
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
header_len
)
og
[
1
]
.
header
og
[
1
]
.
header_len
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
header_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
1
]
.
body_len
)
og
[
1
]
.
body
og
[
1
]
.
body_len
)
;
ogg_sync_wrote
(
&
oy
og
[
1
]
.
body_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
2
]
.
header_len
)
og
[
2
]
.
header
og
[
2
]
.
header_len
)
;
ogg_sync_wrote
(
&
oy
og
[
2
]
.
header_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
2
]
.
header_len
)
og
[
2
]
.
header
og
[
2
]
.
header_len
)
;
ogg_sync_wrote
(
&
oy
og
[
2
]
.
header_len
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
<
=
0
)
error
(
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
2
]
.
body_len
)
og
[
2
]
.
body
og
[
2
]
.
body_len
-
5
)
;
ogg_sync_wrote
(
&
oy
og
[
2
]
.
body_len
-
5
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
3
]
.
header_len
)
og
[
3
]
.
header
og
[
3
]
.
header_len
)
;
ogg_sync_wrote
(
&
oy
og
[
3
]
.
header_len
)
;
memcpy
(
ogg_sync_buffer
(
&
oy
og
[
3
]
.
body_len
)
og
[
3
]
.
body
og
[
3
]
.
body_len
)
;
ogg_sync_wrote
(
&
oy
og
[
3
]
.
body_len
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
>
0
)
error
(
)
;
if
(
ogg_sync_pageout
(
&
oy
&
og_de
)
<
=
0
)
error
(
)
;
fprintf
(
stderr
"
ok
.
\
n
"
)
;
}
#
else
fprintf
(
stderr
"
Skipping
recapture
test
due
to
-
-
disable
-
crc
\
n
"
)
;
#
endif
{
for
(
i
=
0
;
i
<
5
;
i
+
+
)
{
free_page
(
&
og
[
i
]
)
;
}
}
}
ogg_sync_clear
(
&
oy
)
;
ogg_stream_clear
(
&
os_en
)
;
ogg_stream_clear
(
&
os_de
)
;
return
(
0
)
;
}
#
endif
