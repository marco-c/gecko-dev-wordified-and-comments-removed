#
include
<
string
.
h
>
#
include
<
Types
.
h
>
#
include
<
Files
.
h
>
#
include
<
Devices
.
h
>
#
include
<
Folders
.
h
>
#
include
<
Errors
.
h
>
#
include
<
Resources
.
h
>
#
include
<
Processes
.
h
>
#
include
<
TextUtils
.
h
>
#
include
<
fcntl
.
h
>
#
include
"
FullPath
.
h
"
#
include
"
primpl
.
h
"
#
include
"
MacErrorHandling
.
h
"
#
include
"
mdmac
.
h
"
#
include
"
macio
.
h
"
extern
unsigned
long
gJanuaryFirst1970Seconds
;
extern
void
WaitOnThisThread
(
PRThread
*
thread
PRIntervalTime
timeout
)
;
extern
void
DoneWaitingOnThisThread
(
PRThread
*
thread
)
;
extern
void
AsyncNotify
(
PRThread
*
thread
)
;
struct
ExtendedParamBlock
{
ParamBlockRec
pb
;
PRThread
*
thread
;
}
;
typedef
struct
ExtendedParamBlock
ExtendedParamBlock
;
static
void
AsyncIOCompletion
(
ExtendedParamBlock
*
pbAsyncPtr
)
{
_PRCPU
*
cpu
=
_PR_MD_CURRENT_CPU
(
)
;
PRThread
*
thread
=
pbAsyncPtr
-
>
thread
;
PRIntn
is
;
if
(
_PR_MD_GET_INTSOFF
(
)
)
{
thread
-
>
md
.
missedIONotify
=
PR_TRUE
;
cpu
-
>
u
.
missed
[
cpu
-
>
where
]
|
=
_PR_MISSED_IO
;
}
else
{
_PR_INTSOFF
(
is
)
;
thread
-
>
md
.
osErrCode
=
noErr
;
DoneWaitingOnThisThread
(
thread
)
;
_PR_FAST_INTSON
(
is
)
;
}
SignalIdleSemaphore
(
)
;
}
void
_MD_SetError
(
OSErr
oserror
)
{
PRErrorCode
code
;
switch
(
oserror
)
{
case
memFullErr
:
code
=
PR_OUT_OF_MEMORY_ERROR
;
break
;
case
fnfErr
:
code
=
PR_FILE_NOT_FOUND_ERROR
;
break
;
case
dupFNErr
:
code
=
PR_FILE_EXISTS_ERROR
;
break
;
case
ioErr
:
code
=
PR_IO_ERROR
;
break
;
case
nsvErr
:
case
wrgVolTypErr
:
code
=
PR_INVALID_DEVICE_STATE_ERROR
;
break
;
case
bdNamErr
:
case
fsRnErr
:
code
=
PR_NAME_TOO_LONG_ERROR
;
break
;
case
tmfoErr
:
code
=
PR_INSUFFICIENT_RESOURCES_ERROR
;
break
;
case
opWrErr
:
case
wrPermErr
:
case
permErr
:
case
afpAccessDenied
:
code
=
PR_NO_ACCESS_RIGHTS_ERROR
;
break
;
case
afpObjectTypeErr
:
code
=
PR_DIRECTORY_LOOKUP_ERROR
;
break
;
case
wPrErr
:
case
vLckdErr
:
code
=
PR_DEVICE_IS_LOCKED_ERROR
;
break
;
case
fLckdErr
:
code
=
PR_FILE_IS_LOCKED_ERROR
;
break
;
case
dirNFErr
:
code
=
PR_NOT_DIRECTORY_ERROR
;
break
;
case
dirFulErr
:
code
=
PR_MAX_DIRECTORY_ENTRIES_ERROR
;
break
;
case
dskFulErr
:
code
=
PR_NO_DEVICE_SPACE_ERROR
;
break
;
case
rfNumErr
:
case
fnOpnErr
:
code
=
PR_BAD_DESCRIPTOR_ERROR
;
break
;
case
eofErr
:
code
=
PR_END_OF_FILE_ERROR
;
break
;
case
posErr
:
case
gfpErr
:
code
=
PR_FILE_SEEK_ERROR
;
break
;
case
fBsyErr
:
code
=
PR_FILE_IS_BUSY_ERROR
;
break
;
case
extFSErr
:
code
=
PR_REMOTE_FILE_ERROR
;
break
;
case
abortErr
:
code
=
PR_PENDING_INTERRUPT_ERROR
;
break
;
case
paramErr
:
code
=
PR_INVALID_ARGUMENT_ERROR
;
break
;
case
unimpErr
:
code
=
PR_NOT_IMPLEMENTED_ERROR
;
break
;
}
PR_SetError
(
code
oserror
)
;
}
void
_MD_IOInterrupt
(
void
)
{
PRCList
*
qp
;
PRThread
*
thread
*
me
=
_PR_MD_CURRENT_THREAD
(
)
;
PR_ASSERT
(
_PR_MD_GET_INTSOFF
(
)
!
=
0
)
;
_PR_SLEEPQ_LOCK
(
me
-
>
cpu
)
;
qp
=
_PR_PAUSEQ
(
me
-
>
cpu
)
.
next
;
while
(
qp
!
=
&
_PR_PAUSEQ
(
me
-
>
cpu
)
)
{
thread
=
_PR_THREAD_PTR
(
qp
)
;
PR_ASSERT
(
thread
-
>
flags
&
_PR_ON_PAUSEQ
)
;
qp
=
qp
-
>
next
;
if
(
thread
-
>
md
.
missedIONotify
)
{
thread
-
>
md
.
missedIONotify
=
PR_FALSE
;
DoneWaitingOnThisThread
(
thread
)
;
}
if
(
thread
-
>
md
.
missedAsyncNotify
)
{
thread
-
>
md
.
missedAsyncNotify
=
PR_FALSE
;
AsyncNotify
(
thread
)
;
}
}
qp
=
_PR_SLEEPQ
(
me
-
>
cpu
)
.
next
;
while
(
qp
!
=
&
_PR_SLEEPQ
(
me
-
>
cpu
)
)
{
thread
=
_PR_THREAD_PTR
(
qp
)
;
PR_ASSERT
(
thread
-
>
flags
&
_PR_ON_SLEEPQ
)
;
qp
=
qp
-
>
next
;
if
(
thread
-
>
md
.
missedIONotify
)
{
thread
-
>
md
.
missedIONotify
=
PR_FALSE
;
DoneWaitingOnThisThread
(
thread
)
;
}
if
(
thread
-
>
md
.
missedAsyncNotify
)
{
thread
-
>
md
.
missedAsyncNotify
=
PR_FALSE
;
AsyncNotify
(
thread
)
;
}
}
_PR_SLEEPQ_UNLOCK
(
thread
-
>
cpu
)
;
}
PRInt32
ReadWriteProc
(
PRFileDesc
*
fd
void
*
buf
PRUint32
bytes
IOOperation
op
)
{
PRInt32
refNum
=
fd
-
>
secret
-
>
md
.
osfd
;
OSErr
err
;
ExtendedParamBlock
pbAsync
;
PRThread
*
me
=
_PR_MD_CURRENT_THREAD
(
)
;
_PRCPU
*
cpu
=
_PR_MD_CURRENT_CPU
(
)
;
if
(
refNum
>
=
0
&
&
refNum
<
3
)
{
switch
(
refNum
)
{
case
0
:
err
=
paramErr
;
goto
ErrorExit
;
break
;
case
1
:
case
2
:
puts
(
buf
)
;
break
;
}
return
(
bytes
)
;
}
else
{
static
IOCompletionUPP
sCompletionUPP
=
NULL
;
PRBool
doingAsync
=
PR_FALSE
;
if
(
!
sCompletionUPP
)
sCompletionUPP
=
NewIOCompletionUPP
(
(
IOCompletionProcPtr
)
&
AsyncIOCompletion
)
;
pbAsync
.
thread
=
me
;
pbAsync
.
pb
.
ioParam
.
ioCompletion
=
sCompletionUPP
;
pbAsync
.
pb
.
ioParam
.
ioResult
=
noErr
;
pbAsync
.
pb
.
ioParam
.
ioRefNum
=
refNum
;
pbAsync
.
pb
.
ioParam
.
ioBuffer
=
buf
;
pbAsync
.
pb
.
ioParam
.
ioReqCount
=
bytes
;
pbAsync
.
pb
.
ioParam
.
ioPosMode
=
fsAtMark
;
pbAsync
.
pb
.
ioParam
.
ioPosOffset
=
0
;
me
-
>
io_fd
=
refNum
;
me
-
>
md
.
osErrCode
=
noErr
;
if
(
op
=
=
READ_ASYNC
)
{
if
(
bytes
>
20480L
)
{
doingAsync
=
PR_TRUE
;
me
-
>
io_pending
=
PR_TRUE
;
(
void
)
PBReadAsync
(
&
pbAsync
.
pb
)
;
}
else
{
pbAsync
.
pb
.
ioParam
.
ioCompletion
=
NULL
;
me
-
>
io_pending
=
PR_FALSE
;
err
=
PBReadSync
(
&
pbAsync
.
pb
)
;
if
(
err
!
=
noErr
&
&
err
!
=
eofErr
)
goto
ErrorExit
;
}
}
else
{
doingAsync
=
PR_TRUE
;
me
-
>
io_pending
=
PR_TRUE
;
(
void
)
PBWriteAsync
(
&
pbAsync
.
pb
)
;
}
if
(
doingAsync
)
{
WaitOnThisThread
(
me
PR_INTERVAL_NO_TIMEOUT
)
;
}
}
err
=
me
-
>
md
.
osErrCode
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
err
=
pbAsync
.
pb
.
ioParam
.
ioResult
;
if
(
err
!
=
noErr
&
&
err
!
=
eofErr
)
goto
ErrorExit
;
return
pbAsync
.
pb
.
ioParam
.
ioActCount
;
ErrorExit
:
me
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
PRInt32
WriteSyncProc
(
PRFileDesc
*
fd
void
*
buf
PRUint32
bytes
)
{
PRInt32
refNum
=
fd
-
>
secret
-
>
md
.
osfd
;
OSErr
err
;
ParamBlockRec
pb
;
PRThread
*
me
=
_PR_MD_CURRENT_THREAD
(
)
;
if
(
refNum
>
=
0
&
&
refNum
<
3
)
{
PR_ASSERT
(
FALSE
)
;
err
=
paramErr
;
goto
ErrorExit
;
}
pb
.
ioParam
.
ioCompletion
=
NULL
;
pb
.
ioParam
.
ioResult
=
noErr
;
pb
.
ioParam
.
ioRefNum
=
refNum
;
pb
.
ioParam
.
ioBuffer
=
buf
;
pb
.
ioParam
.
ioReqCount
=
bytes
;
pb
.
ioParam
.
ioPosMode
=
fsAtMark
;
pb
.
ioParam
.
ioPosOffset
=
0
;
err
=
PBWriteSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
else
return
pb
.
ioParam
.
ioActCount
;
ErrorExit
:
me
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
PRInt32
_MD_Open
(
const
char
*
path
PRIntn
flags
int
mode
)
{
#
pragma
unused
(
mode
)
OSErr
err
;
HParamBlockRec
hpb
;
ParamBlockRec
pb
;
char
*
macFileName
=
NULL
;
Str255
pascalName
;
PRInt8
perm
;
err
=
ConvertUnixPathToMacPath
(
path
&
macFileName
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
hpb
.
ioParam
.
ioCompletion
=
NULL
;
PStrFromCStr
(
macFileName
pascalName
)
;
PR_DELETE
(
macFileName
)
;
hpb
.
ioParam
.
ioNamePtr
=
pascalName
;
hpb
.
ioParam
.
ioVRefNum
=
0
;
hpb
.
ioParam
.
ioVersNum
=
0
;
hpb
.
fileParam
.
ioDirID
=
0
;
if
(
flags
&
PR_RDWR
)
perm
=
fsRdWrPerm
;
else
if
(
flags
&
PR_WRONLY
)
perm
=
fsWrPerm
;
else
perm
=
fsRdPerm
;
hpb
.
ioParam
.
ioPermssn
=
perm
;
if
(
flags
&
PR_CREATE_FILE
)
{
err
=
PBHCreateSync
(
&
hpb
)
;
if
(
(
flags
&
PR_EXCL
)
&
&
(
err
=
=
dupFNErr
)
)
{
err
=
PR_FILE_EXISTS_ERROR
;
goto
ErrorExit
;
}
if
(
(
err
!
=
noErr
)
&
&
(
err
!
=
dupFNErr
)
)
goto
ErrorExit
;
}
err
=
PBHOpenDFSync
(
&
hpb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
if
(
flags
&
PR_TRUNCATE
)
{
pb
.
ioParam
.
ioCompletion
=
NULL
;
pb
.
ioParam
.
ioRefNum
=
hpb
.
ioParam
.
ioRefNum
;
pb
.
ioParam
.
ioMisc
=
NULL
;
err
=
PBSetEOFSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
}
else
if
(
flags
&
PR_APPEND
)
{
pb
.
ioParam
.
ioCompletion
=
NULL
;
pb
.
ioParam
.
ioRefNum
=
hpb
.
ioParam
.
ioRefNum
;
pb
.
ioParam
.
ioPosMode
=
fsFromLEOF
;
pb
.
ioParam
.
ioPosOffset
=
0
;
err
=
PBSetFPosSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
}
return
hpb
.
ioParam
.
ioRefNum
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
PROffset32
_MD_LSeek
(
PRFileDesc
*
fd
PROffset32
offset
PRSeekWhence
how
)
{
PRInt32
refNum
=
fd
-
>
secret
-
>
md
.
osfd
;
OSErr
err
=
noErr
;
long
curPos
endPos
;
switch
(
how
)
{
case
PR_SEEK_SET
:
endPos
=
offset
;
break
;
case
PR_SEEK_CUR
:
err
=
GetFPos
(
refNum
&
curPos
)
;
endPos
=
curPos
+
offset
;
break
;
case
PR_SEEK_END
:
err
=
GetEOF
(
refNum
&
curPos
)
;
endPos
=
curPos
+
offset
;
break
;
default
:
err
=
paramErr
;
break
;
}
if
(
err
=
=
noErr
)
{
err
=
SetFPos
(
refNum
fsFromStart
endPos
)
;
if
(
err
=
=
eofErr
)
{
err
=
SetEOF
(
refNum
endPos
)
;
if
(
err
=
=
noErr
)
{
err
=
SetFPos
(
refNum
fsFromStart
endPos
)
;
}
}
}
if
(
err
=
=
noErr
)
{
return
endPos
;
}
else
{
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
}
PRInt32
_MD_FSync
(
PRFileDesc
*
fd
)
{
PRInt32
refNum
=
fd
-
>
secret
-
>
md
.
osfd
;
OSErr
err
;
ParamBlockRec
pb
;
pb
.
ioParam
.
ioCompletion
=
NULL
;
pb
.
ioParam
.
ioRefNum
=
refNum
;
err
=
PBFlushFileSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
return
0
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
#
include
"
plstr
.
h
"
PRStatus
_MD_OpenDir
(
_MDDir
*
mdDir
const
char
*
name
)
{
OSErr
err
;
CInfoPBRec
pb
;
char
*
macDirName
=
NULL
;
char
*
position
=
NULL
;
char
volumeName
[
32
]
;
Str255
pascalName
;
err
=
ConvertUnixPathToMacPath
(
name
&
macDirName
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
position
=
PL_strchr
(
macDirName
PR_PATH_SEPARATOR
)
;
if
(
(
position
=
=
macDirName
)
|
|
(
position
=
=
NULL
)
)
mdDir
-
>
ioVRefNum
=
0
;
else
{
memset
(
volumeName
0
sizeof
(
volumeName
)
)
;
strncpy
(
volumeName
macDirName
position
-
macDirName
)
;
mdDir
-
>
ioVRefNum
=
GetVolumeRefNumFromName
(
volumeName
)
;
}
PStrFromCStr
(
macDirName
pascalName
)
;
PR_DELETE
(
macDirName
)
;
pb
.
dirInfo
.
ioNamePtr
=
pascalName
;
pb
.
dirInfo
.
ioVRefNum
=
mdDir
-
>
ioVRefNum
;
pb
.
dirInfo
.
ioDrDirID
=
0
;
pb
.
dirInfo
.
ioFDirIndex
=
0
;
err
=
PBGetCatInfoSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
if
(
(
pb
.
dirInfo
.
ioFlAttrib
&
ioDirMask
)
=
=
0
)
{
err
=
dirNFErr
;
goto
ErrorExit
;
}
mdDir
-
>
ioDirID
=
pb
.
dirInfo
.
ioDrDirID
;
mdDir
-
>
currentEntryName
=
NULL
;
mdDir
-
>
ioFDirIndex
=
1
;
return
PR_SUCCESS
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
PR_FAILURE
;
}
char
*
_MD_ReadDir
(
_MDDir
*
mdDir
PRIntn
flags
)
{
OSErr
err
;
CInfoPBRec
pb
;
char
*
returnedCStr
;
Str255
pascalName
=
"
\
p
"
;
PRBool
foundEntry
;
PR_ASSERT
(
mdDir
!
=
NULL
)
;
do
{
PR_DELETE
(
mdDir
-
>
currentEntryName
)
;
mdDir
-
>
currentEntryName
=
NULL
;
pb
.
hFileInfo
.
ioNamePtr
=
pascalName
;
pb
.
hFileInfo
.
ioVRefNum
=
mdDir
-
>
ioVRefNum
;
pb
.
hFileInfo
.
ioFDirIndex
=
mdDir
-
>
ioFDirIndex
;
pb
.
hFileInfo
.
ioDirID
=
mdDir
-
>
ioDirID
;
err
=
PBGetCatInfoSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
CStrFromPStr
(
pascalName
&
returnedCStr
)
;
mdDir
-
>
currentEntryName
=
returnedCStr
;
mdDir
-
>
ioFDirIndex
+
+
;
if
(
(
flags
&
PR_SKIP_HIDDEN
)
&
&
(
pb
.
hFileInfo
.
ioFlFndrInfo
.
fdFlags
&
fInvisible
)
)
foundEntry
=
PR_FALSE
;
else
foundEntry
=
PR_TRUE
;
}
while
(
!
foundEntry
)
;
return
(
mdDir
-
>
currentEntryName
)
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
NULL
;
}
void
_MD_CloseDir
(
_MDDir
*
mdDir
)
{
PR_DELETE
(
mdDir
-
>
currentEntryName
)
;
}
PRInt32
_MD_MkDir
(
char
*
unixPath
PRIntn
mode
)
{
HFileParam
fpb
;
Str255
pascalName
=
"
\
p
"
;
char
*
cMacPath
=
NULL
;
OSErr
err
;
#
pragma
unused
(
mode
)
/
/
Mode
is
ignored
on
the
Mac
if
(
unixPath
)
{
err
=
ConvertUnixPathToMacPath
(
unixPath
&
cMacPath
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
PStrFromCStr
(
cMacPath
pascalName
)
;
PR_DELETE
(
cMacPath
)
;
fpb
.
ioNamePtr
=
pascalName
;
fpb
.
ioVRefNum
=
0
;
fpb
.
ioDirID
=
0L
;
err
=
PBDirCreateSync
(
(
HParmBlkPtr
)
&
fpb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
}
return
0
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
PRInt32
_MD_Delete
(
char
*
unixPath
)
{
HFileParam
fpb
;
Str255
pascalName
=
"
\
p
"
;
char
*
cMacPath
=
NULL
;
OSErr
err
;
if
(
unixPath
)
{
err
=
ConvertUnixPathToMacPath
(
unixPath
&
cMacPath
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
PStrFromCStr
(
cMacPath
pascalName
)
;
PR_DELETE
(
cMacPath
)
;
fpb
.
ioNamePtr
=
pascalName
;
fpb
.
ioVRefNum
=
0
;
fpb
.
ioDirID
=
0L
;
err
=
PBHDeleteSync
(
(
HParmBlkPtr
)
&
fpb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
}
return
0
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
PRInt32
_MD_Rename
(
char
*
fromUnixPath
char
*
toUnixPath
)
{
OSErr
err
;
FSSpec
fromSpec
;
FSSpec
toSpec
;
FSSpec
destDirSpec
;
FSSpec
beforeRenameSpec
;
if
(
fromUnixPath
&
&
toUnixPath
)
{
err
=
ConvertUnixPathToFSSpec
(
fromUnixPath
&
fromSpec
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
err
=
ConvertUnixPathToFSSpec
(
toUnixPath
&
toSpec
)
;
if
(
err
!
=
noErr
&
&
err
!
=
fnfErr
)
goto
ErrorExit
;
err
=
FSMakeFSSpec
(
toSpec
.
vRefNum
toSpec
.
parID
nil
&
destDirSpec
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
err
=
FSpCatMove
(
&
fromSpec
&
destDirSpec
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
err
=
FSMakeFSSpec
(
toSpec
.
vRefNum
toSpec
.
parID
fromSpec
.
name
&
beforeRenameSpec
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
err
=
FSpRename
(
&
beforeRenameSpec
toSpec
.
name
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
}
else
{
err
=
paramErr
;
goto
ErrorExit
;
}
return
0
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
#
define
kWriteAccessAllowed
(
0x100
)
PRInt32
_MD_Access
(
char
*
unixPath
int
amode
)
{
OSErr
err
;
CInfoPBRec
pb
;
FCBPBRec
fcbpb
;
char
*
cMacPath
=
NULL
;
Str255
pascalMacPath
;
struct
stat
info
;
err
=
ConvertUnixPathToMacPath
(
unixPath
&
cMacPath
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
err
=
stat
(
cMacPath
&
info
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
if
(
(
amode
=
=
PR_ACCESS_EXISTS
)
|
|
(
amode
=
=
PR_ACCESS_READ_OK
)
)
{
goto
success
;
}
PStrFromCStr
(
cMacPath
pascalMacPath
)
;
pb
.
hFileInfo
.
ioNamePtr
=
pascalMacPath
;
pb
.
hFileInfo
.
ioVRefNum
=
info
.
st_dev
;
pb
.
hFileInfo
.
ioDirID
=
0
;
pb
.
hFileInfo
.
ioFDirIndex
=
0
;
err
=
PBGetCatInfoSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
if
(
amode
=
=
PR_ACCESS_WRITE_OK
)
{
fcbpb
.
ioNamePtr
=
NULL
;
fcbpb
.
ioVRefNum
=
pb
.
hFileInfo
.
ioVRefNum
;
fcbpb
.
ioRefNum
=
pb
.
hFileInfo
.
ioFRefNum
;
fcbpb
.
ioFCBIndx
=
0
;
err
=
PBGetFCBInfoSync
(
&
fcbpb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
if
(
(
fcbpb
.
ioFCBFlags
&
kWriteAccessAllowed
)
=
=
0
)
{
err
=
permErr
;
goto
ErrorExit
;
}
}
success
:
PR_DELETE
(
cMacPath
)
;
return
0
;
ErrorExit
:
if
(
cMacPath
!
=
NULL
)
PR_DELETE
(
cMacPath
)
;
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
PRInt32
_MD_GetFileInfo
(
char
*
unixPath
PRFileInfo
*
info
)
{
CInfoPBRec
pb
;
OSErr
err
;
char
*
cMacPath
=
NULL
;
Str255
pascalMacPath
;
PRTime
oneMillion
dateInMicroSeconds
;
err
=
ConvertUnixPathToMacPath
(
unixPath
&
cMacPath
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
PStrFromCStr
(
cMacPath
pascalMacPath
)
;
PR_DELETE
(
cMacPath
)
;
pb
.
hFileInfo
.
ioNamePtr
=
pascalMacPath
;
pb
.
hFileInfo
.
ioVRefNum
=
0
;
pb
.
hFileInfo
.
ioDirID
=
0
;
pb
.
hFileInfo
.
ioFDirIndex
=
0
;
err
=
PBGetCatInfoSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
if
(
pb
.
hFileInfo
.
ioFlAttrib
&
ioDirMask
)
{
info
-
>
type
=
PR_FILE_DIRECTORY
;
info
-
>
size
=
0
;
}
else
{
info
-
>
type
=
PR_FILE_FILE
;
info
-
>
size
=
pb
.
hFileInfo
.
ioFlLgLen
+
pb
.
hFileInfo
.
ioFlRLgLen
;
}
pb
.
hFileInfo
.
ioFlCrDat
-
=
gJanuaryFirst1970Seconds
;
LL_I2L
(
dateInMicroSeconds
pb
.
hFileInfo
.
ioFlCrDat
)
;
LL_I2L
(
oneMillion
PR_USEC_PER_SEC
)
;
LL_MUL
(
info
-
>
creationTime
oneMillion
dateInMicroSeconds
)
;
pb
.
hFileInfo
.
ioFlMdDat
-
=
gJanuaryFirst1970Seconds
;
LL_I2L
(
dateInMicroSeconds
pb
.
hFileInfo
.
ioFlMdDat
)
;
LL_MUL
(
info
-
>
modifyTime
oneMillion
dateInMicroSeconds
)
;
return
0
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
PRInt32
_MD_GetOpenFileInfo
(
const
PRFileDesc
*
fd
PRFileInfo
*
info
)
{
OSErr
err
;
FCBPBRec
fcbpb
;
CInfoPBRec
pb
;
Str255
pascalMacPath
;
PRTime
oneMillion
dateInMicroSeconds
;
fcbpb
.
ioNamePtr
=
pascalMacPath
;
fcbpb
.
ioVRefNum
=
0
;
fcbpb
.
ioRefNum
=
fd
-
>
secret
-
>
md
.
osfd
;
fcbpb
.
ioFCBIndx
=
0
;
err
=
PBGetFCBInfoSync
(
&
fcbpb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
info
-
>
type
=
PR_FILE_FILE
;
info
-
>
size
=
fcbpb
.
ioFCBEOF
;
pb
.
hFileInfo
.
ioNamePtr
=
pascalMacPath
;
pb
.
hFileInfo
.
ioVRefNum
=
fcbpb
.
ioFCBVRefNum
;
pb
.
hFileInfo
.
ioDirID
=
fcbpb
.
ioFCBParID
;
pb
.
hFileInfo
.
ioFDirIndex
=
0
;
err
=
PBGetCatInfoSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
pb
.
hFileInfo
.
ioFlCrDat
-
=
gJanuaryFirst1970Seconds
;
LL_I2L
(
dateInMicroSeconds
pb
.
hFileInfo
.
ioFlCrDat
)
;
LL_I2L
(
oneMillion
PR_USEC_PER_SEC
)
;
LL_MUL
(
info
-
>
creationTime
oneMillion
dateInMicroSeconds
)
;
pb
.
hFileInfo
.
ioFlMdDat
-
=
gJanuaryFirst1970Seconds
;
LL_I2L
(
dateInMicroSeconds
pb
.
hFileInfo
.
ioFlMdDat
)
;
LL_MUL
(
info
-
>
modifyTime
oneMillion
dateInMicroSeconds
)
;
return
0
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
PRInt32
_MD_Stat
(
const
char
*
path
struct
stat
*
buf
)
{
OSErr
err
;
char
*
macFileName
=
NULL
;
err
=
ConvertUnixPathToMacPath
(
path
&
macFileName
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
err
=
stat
(
macFileName
buf
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
PR_DELETE
(
macFileName
)
;
return
0
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
-
1
;
}
PRStatus
_MD_LockFile
(
PRInt32
fd
)
{
OSErr
err
;
FCBPBRec
fcbpb
;
HFileParam
fpb
;
Str255
pascalName
;
fcbpb
.
ioNamePtr
=
pascalName
;
fcbpb
.
ioVRefNum
=
0
;
fcbpb
.
ioRefNum
=
fd
;
fcbpb
.
ioFCBIndx
=
0
;
err
=
PBGetFCBInfoSync
(
&
fcbpb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
fpb
.
ioCompletion
=
NULL
;
fpb
.
ioNamePtr
=
pascalName
;
fpb
.
ioVRefNum
=
fcbpb
.
ioFCBVRefNum
;
fpb
.
ioDirID
=
fcbpb
.
ioFCBParID
;
err
=
PBHSetFLockSync
(
(
HParmBlkPtr
)
&
fpb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
return
PR_SUCCESS
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
PR_FAILURE
;
}
PRStatus
_MD_TLockFile
(
PRInt32
fd
)
{
return
(
_MD_LockFile
(
fd
)
)
;
}
PRStatus
_MD_UnlockFile
(
PRInt32
fd
)
{
OSErr
err
;
FCBPBRec
fcbpb
;
HFileParam
fpb
;
Str255
pascalName
;
fcbpb
.
ioNamePtr
=
pascalName
;
fcbpb
.
ioVRefNum
=
0
;
fcbpb
.
ioRefNum
=
fd
;
fcbpb
.
ioFCBIndx
=
0
;
err
=
PBGetFCBInfoSync
(
&
fcbpb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
fpb
.
ioCompletion
=
NULL
;
fpb
.
ioNamePtr
=
pascalName
;
fpb
.
ioVRefNum
=
fcbpb
.
ioFCBVRefNum
;
fpb
.
ioDirID
=
fcbpb
.
ioFCBParID
;
err
=
PBHRstFLockSync
(
(
HParmBlkPtr
)
&
fpb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
return
PR_SUCCESS
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
PR_FAILURE
;
}
void
SetLogFileTypeCreator
(
const
char
*
logFile
)
{
HParamBlockRec
pb
;
OSErr
err
;
Str31
pName
;
PStrFromCStr
(
logFile
pName
)
;
pb
.
fileParam
.
ioCompletion
=
nil
;
pb
.
fileParam
.
ioNamePtr
=
pName
;
pb
.
fileParam
.
ioVRefNum
=
0
;
pb
.
fileParam
.
ioFDirIndex
=
0
;
pb
.
fileParam
.
ioDirID
=
0
;
err
=
PBHGetFInfoSync
(
&
pb
)
;
PR_ASSERT
(
err
=
=
noErr
)
;
pb
.
fileParam
.
ioDirID
=
0
;
pb
.
fileParam
.
ioFlFndrInfo
.
fdType
=
'
TEXT
'
;
pb
.
fileParam
.
ioFlFndrInfo
.
fdCreator
=
'
ttxt
'
;
err
=
PBHSetFInfoSync
(
&
pb
)
;
PR_ASSERT
(
err
=
=
noErr
)
;
}
#
if
DEVELOPER_DEBUG
PR_IMPLEMENT
(
void
)
SetupMacPrintfLog
(
char
*
logFile
)
{
#
ifdef
PR_INTERNAL_LOGGING
_PR_InitLog
(
)
;
_MD_PutEnv
(
"
NSPR_LOG_MODULES
=
clock
:
0
cmon
:
0
io
:
0
mon
:
0
linker
:
0
cvar
:
0
sched
:
0
thread
:
0
"
)
;
_PR_InitLog
(
)
;
#
endif
PR_ASSERT
(
PR_SetLogFile
(
logFile
)
=
=
PR_TRUE
)
;
SetLogFileTypeCreator
(
logFile
)
;
}
#
endif
#
if
!
defined
(
MAC_NSPR_STANDALONE
)
short
GetVolumeRefNumFromName
(
const
char
*
cTgtVolName
)
{
OSErr
err
;
Str32
pVolName
;
char
*
cVolName
=
NULL
;
HParamBlockRec
hPB
;
short
refNum
=
0
;
hPB
.
volumeParam
.
ioVolIndex
=
0
;
hPB
.
volumeParam
.
ioNamePtr
=
pVolName
;
do
{
hPB
.
volumeParam
.
ioVolIndex
+
+
;
err
=
PBHGetVInfoSync
(
&
hPB
)
;
CStrFromPStr
(
pVolName
&
cVolName
)
;
if
(
strcmp
(
cTgtVolName
cVolName
)
=
=
0
)
{
refNum
=
hPB
.
volumeParam
.
ioVRefNum
;
PR_DELETE
(
cVolName
)
;
break
;
}
PR_DELETE
(
cVolName
)
;
}
while
(
err
=
=
noErr
)
;
return
refNum
;
}
static
OSErr
CreateMacPathFromUnixPath
(
const
char
*
unixPath
char
*
*
macPath
)
{
const
char
*
src
;
char
*
tgt
;
OSErr
err
=
noErr
;
PR_ASSERT
(
unixPath
!
=
nil
)
;
if
(
nil
=
=
unixPath
)
{
err
=
paramErr
;
goto
exit
;
}
*
macPath
=
malloc
(
strlen
(
unixPath
)
+
2
)
;
require_action
(
*
macPath
!
=
NULL
exit
err
=
memFullErr
;
)
;
src
=
unixPath
;
tgt
=
*
macPath
;
if
(
PL_strchr
(
src
PR_DIRECTORY_SEPARATOR
)
=
=
src
)
src
+
+
;
else
*
(
tgt
+
+
)
=
PR_PATH_SEPARATOR
;
if
(
PL_strstr
(
src
UNIX_THIS_DIRECTORY_STR
)
=
=
src
)
src
+
=
2
;
while
(
*
src
)
{
if
(
PL_strstr
(
src
UNIX_PARENT_DIRECTORY_STR
)
=
=
src
)
{
*
(
tgt
+
+
)
=
PR_PATH_SEPARATOR
;
src
+
=
3
;
}
else
if
(
*
src
=
=
PR_DIRECTORY_SEPARATOR
)
{
*
(
tgt
+
+
)
=
PR_PATH_SEPARATOR
;
src
+
+
;
}
else
*
(
tgt
+
+
)
=
*
(
src
+
+
)
;
}
*
tgt
=
NULL
;
exit
:
return
err
;
}
static
ProcessInfoRec
gNavigatorProcInfo
;
static
FSSpec
gGutsFolder
;
static
FSSpec
gNetscapeFolder
;
static
OSErr
SetupRequiredFSSpecs
(
void
)
{
OSErr
err
;
CInfoPBRec
pb
;
ProcessSerialNumber
curPSN
=
{
0
kCurrentProcess
}
;
gNavigatorProcInfo
.
processInfoLength
=
sizeof
(
ProcessInfoRec
)
;
gNavigatorProcInfo
.
processName
=
NULL
;
gNavigatorProcInfo
.
processAppSpec
=
&
gNetscapeFolder
;
err
=
GetProcessInformation
(
&
curPSN
&
gNavigatorProcInfo
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
gGutsFolder
=
gNetscapeFolder
;
GetIndString
(
gGutsFolder
.
name
300
34
)
;
pb
.
dirInfo
.
ioCompletion
=
NULL
;
pb
.
dirInfo
.
ioNamePtr
=
gNetscapeFolder
.
name
;
pb
.
dirInfo
.
ioVRefNum
=
gNetscapeFolder
.
vRefNum
;
pb
.
dirInfo
.
ioFDirIndex
=
-
1
;
pb
.
dirInfo
.
ioDrDirID
=
gNetscapeFolder
.
parID
;
err
=
PBGetCatInfoSync
(
&
pb
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
gNetscapeFolder
.
parID
=
pb
.
dirInfo
.
ioDrParID
;
return
noErr
;
ErrorExit
:
return
err
;
}
static
OSErr
FindGutsFolder
(
FSSpec
*
foundSpec
)
{
OSErr
err
;
if
(
gNavigatorProcInfo
.
processInfoLength
=
=
0
)
{
err
=
SetupRequiredFSSpecs
(
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
}
*
foundSpec
=
gGutsFolder
;
return
noErr
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
return
err
;
}
static
OSErr
FindNetscapeFolder
(
FSSpec
*
foundSpec
)
{
OSErr
err
;
if
(
gNavigatorProcInfo
.
processInfoLength
=
=
0
)
{
err
=
SetupRequiredFSSpecs
(
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
}
*
foundSpec
=
gNetscapeFolder
;
return
noErr
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
return
err
;
}
PR_IMPLEMENT
(
OSErr
)
ConvertUnixPathToMacPath
(
const
char
*
unixPath
char
*
*
macPath
)
{
OSErr
err
=
noErr
;
if
(
!
strcmp
(
unixPath
"
.
"
)
)
{
*
macPath
=
malloc
(
sizeof
(
"
:
"
)
)
;
if
(
*
macPath
=
=
NULL
)
err
=
memFullErr
;
(
*
macPath
)
[
0
]
=
'
:
'
;
(
*
macPath
)
[
1
]
=
'
\
0
'
;
}
else
if
(
*
unixPath
!
=
PR_DIRECTORY_SEPARATOR
)
{
err
=
CreateMacPathFromUnixPath
(
unixPath
macPath
)
;
}
else
{
FSSpec
foundSpec
;
short
pathBufferSize
;
#
if
DEBUG
char
*
temp
;
#
endif
int
tempLen
;
if
(
(
strncmp
(
unixPath
"
/
usr
/
tmp
"
strlen
(
"
/
usr
/
tmp
"
)
)
=
=
0
)
|
|
(
(
strncmp
(
unixPath
"
/
tmp
"
strlen
(
"
/
tmp
"
)
)
=
=
0
)
)
)
{
CInfoPBRec
pb
;
unixPath
=
PL_strchr
(
unixPath
PR_DIRECTORY_SEPARATOR
)
;
if
(
strncmp
(
unixPath
"
/
tmp
"
strlen
(
"
/
tmp
"
)
)
=
=
0
)
unixPath
+
=
5
;
else
unixPath
+
=
9
;
err
=
FindFolder
(
kOnSystemDisk
kTemporaryFolderType
kCreateFolder
&
foundSpec
.
vRefNum
&
foundSpec
.
parID
)
;
if
(
err
=
=
noErr
)
{
pb
.
dirInfo
.
ioCompletion
=
NULL
;
pb
.
dirInfo
.
ioNamePtr
=
foundSpec
.
name
;
pb
.
dirInfo
.
ioVRefNum
=
foundSpec
.
vRefNum
;
pb
.
dirInfo
.
ioFDirIndex
=
-
1
;
pb
.
dirInfo
.
ioDrDirID
=
foundSpec
.
parID
;
err
=
PBGetCatInfoSync
(
&
pb
)
;
foundSpec
.
parID
=
pb
.
dirInfo
.
ioDrParID
;
}
}
else
if
(
!
strncmp
(
unixPath
"
/
usr
/
local
/
netscape
/
"
(
tempLen
=
strlen
(
"
/
usr
/
local
/
netscape
/
"
)
)
)
)
{
unixPath
+
=
tempLen
;
if
(
!
strncmp
(
unixPath
"
RequiredGuts
/
"
(
tempLen
=
strlen
(
"
RequiredGuts
/
"
)
)
)
)
{
unixPath
+
=
tempLen
;
err
=
FindGutsFolder
(
&
foundSpec
)
;
}
else
if
(
!
strncmp
(
unixPath
"
bin
/
"
(
tempLen
=
strlen
(
"
bin
/
"
)
)
)
)
{
unixPath
+
=
tempLen
;
err
=
FindNetscapeFolder
(
&
foundSpec
)
;
}
else
if
(
*
unixPath
=
=
'
\
0
'
)
{
err
=
FindGutsFolder
(
&
foundSpec
)
;
}
}
else
{
err
=
CreateMacPathFromUnixPath
(
unixPath
macPath
)
;
goto
Exit_ConvertUnixPathToMacPath
;
}
if
(
err
=
=
noErr
)
{
Handle
hPathStr
;
err
=
FSpGetFullPath
(
&
foundSpec
&
pathBufferSize
&
hPathStr
)
;
if
(
noErr
=
=
err
)
{
pathBufferSize
+
+
;
*
macPath
=
(
char
*
)
malloc
(
sizeof
(
char
)
*
pathBufferSize
)
;
(
*
macPath
)
[
pathBufferSize
-
1
]
=
'
\
0
'
;
BlockMoveData
(
*
hPathStr
*
macPath
pathBufferSize
-
1
)
;
DisposeHandle
(
hPathStr
)
;
}
}
if
(
err
=
=
noErr
)
{
UInt32
unixPathLeft
;
UInt32
macPathLen
;
unixPathLeft
=
strlen
(
unixPath
)
;
macPathLen
=
strlen
(
*
macPath
)
;
if
(
pathBufferSize
-
1
<
macPathLen
+
unixPathLeft
)
{
*
macPath
=
realloc
(
*
macPath
macPathLen
+
unixPathLeft
+
1
)
;
err
=
(
*
macPath
=
=
NULL
?
memFullErr
:
noErr
)
;
}
if
(
err
=
=
noErr
)
{
char
*
dp
;
const
char
*
sp
;
sp
=
unixPath
;
dp
=
*
macPath
+
macPathLen
;
for
(
;
*
sp
!
=
'
\
0
'
;
sp
+
+
dp
+
+
)
{
if
(
*
sp
=
=
PR_DIRECTORY_SEPARATOR
)
{
if
(
sp
>
unixPath
)
{
if
(
sp
[
-
1
]
=
=
'
\
\
'
)
{
continue
;
}
else
{
*
dp
=
PR_PATH_SEPARATOR
;
}
}
else
*
dp
=
PR_PATH_SEPARATOR
;
}
else
{
*
dp
=
*
sp
;
}
}
*
dp
=
'
\
0
'
;
}
#
if
DEBUG
for
(
temp
=
*
macPath
+
strlen
(
*
macPath
)
-
strlen
(
unixPath
)
;
*
temp
!
=
'
\
0
'
;
temp
+
+
)
{
if
(
*
temp
=
=
PR_DIRECTORY_SEPARATOR
)
{
DebugStr
(
"
\
pFound
a
slash
"
)
;
*
temp
=
PR_PATH_SEPARATOR
;
}
}
#
endif
}
}
Exit_ConvertUnixPathToMacPath
:
return
err
;
}
PR_IMPLEMENT
(
OSErr
)
ConvertMacPathToUnixPath
(
const
char
*
macPath
char
*
*
unixPath
)
{
char
*
unixPathPtr
;
*
unixPath
=
malloc
(
strlen
(
macPath
)
+
2
)
;
if
(
*
unixPath
=
=
NULL
)
return
(
memFullErr
)
;
unixPathPtr
=
*
unixPath
;
*
unixPathPtr
+
+
=
PR_DIRECTORY_SEPARATOR
;
do
{
if
(
*
macPath
=
=
PR_PATH_SEPARATOR
)
*
unixPathPtr
=
PR_DIRECTORY_SEPARATOR
;
else
*
unixPathPtr
=
*
macPath
;
unixPathPtr
+
+
;
macPath
+
+
;
}
while
(
*
macPath
!
=
NULL
)
;
*
unixPathPtr
=
'
\
0
'
;
return
(
noErr
)
;
}
OSErr
ConvertUnixPathToFSSpec
(
const
char
*
unixPath
FSSpec
*
fileSpec
)
{
char
*
macPath
;
OSErr
convertError
;
int
len
;
convertError
=
ConvertUnixPathToMacPath
(
unixPath
&
macPath
)
;
if
(
convertError
!
=
noErr
)
return
convertError
;
len
=
strlen
(
macPath
)
;
if
(
*
macPath
=
=
PR_PATH_SEPARATOR
)
{
if
(
len
<
sizeof
(
Str255
)
)
{
short
vRefNum
;
long
dirID
;
Str255
pascalMacPath
;
convertError
=
HGetVol
(
NULL
&
vRefNum
&
dirID
)
;
if
(
convertError
=
=
noErr
)
{
PStrFromCStr
(
macPath
pascalMacPath
)
;
convertError
=
FSMakeFSSpec
(
vRefNum
dirID
pascalMacPath
fileSpec
)
;
}
}
else
convertError
=
paramErr
;
}
else
{
convertError
=
FSpLocationFromFullPath
(
len
macPath
fileSpec
)
;
if
(
convertError
=
=
fnfErr
)
{
CInfoPBRec
pb
;
Str255
pascalMacPath
;
OSErr
err
;
PStrFromCStr
(
macPath
pascalMacPath
)
;
pb
.
hFileInfo
.
ioNamePtr
=
pascalMacPath
;
pb
.
hFileInfo
.
ioVRefNum
=
0
;
pb
.
hFileInfo
.
ioDirID
=
0
;
pb
.
hFileInfo
.
ioFDirIndex
=
0
;
err
=
PBGetCatInfoSync
(
&
pb
)
;
if
(
err
=
=
noErr
)
convertError
=
noErr
;
}
}
free
(
macPath
)
;
return
(
convertError
)
;
}
FILE
*
_OS_FOPEN
(
const
char
*
filename
const
char
*
mode
)
{
OSErr
err
=
noErr
;
char
*
macFileName
=
NULL
;
FILE
*
result
;
err
=
ConvertUnixPathToMacPath
(
filename
&
macFileName
)
;
if
(
err
!
=
noErr
)
goto
ErrorExit
;
result
=
fopen
(
macFileName
mode
)
;
PR_DELETE
(
macFileName
)
;
return
result
;
ErrorExit
:
_PR_MD_CURRENT_THREAD
(
)
-
>
md
.
osErrCode
=
err
;
_MD_SetError
(
err
)
;
return
NULL
;
}
#
else
short
GetVolumeRefNumFromName
(
const
char
*
cTgtVolName
)
{
OSErr
err
;
Str32
pVolName
;
char
*
cVolName
=
NULL
;
HParamBlockRec
hPB
;
short
refNum
=
0
;
hPB
.
volumeParam
.
ioVolIndex
=
0
;
hPB
.
volumeParam
.
ioNamePtr
=
pVolName
;
do
{
hPB
.
volumeParam
.
ioVolIndex
+
+
;
err
=
PBHGetVInfoSync
(
&
hPB
)
;
CStrFromPStr
(
pVolName
&
cVolName
)
;
if
(
strcmp
(
cTgtVolName
cVolName
)
=
=
0
)
{
refNum
=
hPB
.
volumeParam
.
ioVRefNum
;
PR_DELETE
(
cVolName
)
;
break
;
}
PR_DELETE
(
cVolName
)
;
}
while
(
err
=
=
noErr
)
;
return
refNum
;
}
static
OSErr
GetFullPath
(
short
vRefNum
long
dirID
char
*
*
fullPath
int
*
strSize
)
{
Str255
pascalDirName
;
char
cDirName
[
256
]
;
char
*
tmpPath
=
NULL
;
CInfoPBRec
myPB
;
OSErr
err
=
noErr
;
*
strSize
=
256
;
*
fullPath
=
NULL
;
*
fullPath
=
malloc
(
*
strSize
)
;
require_action
(
*
fullPath
!
=
NULL
errorExit
err
=
memFullErr
;
)
;
tmpPath
=
malloc
(
*
strSize
)
;
require_action
(
tmpPath
!
=
NULL
errorExit
err
=
memFullErr
;
)
;
strcpy
(
*
fullPath
"
"
)
;
strcpy
(
tmpPath
"
"
)
;
pascalDirName
[
0
]
=
0
;
myPB
.
dirInfo
.
ioNamePtr
=
&
pascalDirName
[
0
]
;
myPB
.
dirInfo
.
ioVRefNum
=
vRefNum
;
myPB
.
dirInfo
.
ioDrParID
=
dirID
;
myPB
.
dirInfo
.
ioFDirIndex
=
-
1
;
do
{
myPB
.
dirInfo
.
ioDrDirID
=
myPB
.
dirInfo
.
ioDrParID
;
err
=
PBGetCatInfoSync
(
&
myPB
)
;
require
(
err
=
=
noErr
errorExit
)
;
memcpy
(
&
cDirName
&
pascalDirName
256
)
;
p2cstr
(
(
unsigned
char
*
)
&
cDirName
)
;
if
(
(
strlen
(
cDirName
)
+
strlen
(
*
fullPath
)
)
>
*
strSize
)
{
(
*
strSize
)
+
=
256
;
*
fullPath
=
PR_REALLOC
(
*
fullPath
*
strSize
)
;
require_action
(
*
fullPath
!
=
NULL
errorExit
err
=
memFullErr
;
)
;
tmpPath
=
PR_REALLOC
(
tmpPath
*
strSize
)
;
require_action
(
tmpPath
!
=
NULL
errorExit
err
=
memFullErr
;
)
;
}
sprintf
(
tmpPath
"
%
s
:
%
s
"
cDirName
*
fullPath
)
;
strcpy
(
*
fullPath
tmpPath
)
;
}
while
(
myPB
.
dirInfo
.
ioDrDirID
!
=
fsRtDirID
)
;
PR_DELETE
(
tmpPath
)
;
return
noErr
;
errorExit
:
PR_DELETE
(
*
fullPath
)
;
PR_DELETE
(
tmpPath
)
;
return
err
;
}
static
OSErr
CreateMacPathFromUnixPath
(
const
char
*
unixPath
char
*
*
macPath
)
{
const
char
*
src
;
char
*
tgt
;
OSErr
err
=
noErr
;
PR_ASSERT
(
unixPath
!
=
nil
)
;
if
(
nil
=
=
unixPath
)
{
err
=
paramErr
;
goto
exit
;
}
*
macPath
=
malloc
(
strlen
(
unixPath
)
+
2
)
;
require_action
(
*
macPath
!
=
NULL
exit
err
=
memFullErr
;
)
;
src
=
unixPath
;
tgt
=
*
macPath
;
if
(
PL_strchr
(
src
PR_DIRECTORY_SEPARATOR
)
=
=
src
)
src
+
+
;
else
*
(
tgt
+
+
)
=
PR_PATH_SEPARATOR
;
if
(
PL_strstr
(
src
UNIX_THIS_DIRECTORY_STR
)
=
=
src
)
src
+
=
2
;
while
(
*
src
)
{
if
(
PL_strstr
(
src
UNIX_PARENT_DIRECTORY_STR
)
=
=
src
)
{
*
(
tgt
+
+
)
=
PR_PATH_SEPARATOR
;
src
+
=
3
;
}
else
if
(
*
src
=
=
PR_DIRECTORY_SEPARATOR
)
{
*
(
tgt
+
+
)
=
PR_PATH_SEPARATOR
;
src
+
+
;
}
else
*
(
tgt
+
+
)
=
*
(
src
+
+
)
;
}
*
tgt
=
NULL
;
exit
:
return
err
;
}
static
OSErr
ConvertUnixPathToMacPath
(
const
char
*
unixPath
char
*
*
macPath
)
{
OSErr
err
=
noErr
;
if
(
*
unixPath
!
=
PR_DIRECTORY_SEPARATOR
)
{
err
=
CreateMacPathFromUnixPath
(
unixPath
macPath
)
;
}
else
{
short
foundVRefNum
;
long
foundDirID
;
int
pathBufferSize
;
char
*
temp
;
char
isNetscapeDir
=
false
;
if
(
strncmp
(
unixPath
"
/
usr
/
tmp
"
strlen
(
"
/
usr
/
tmp
"
)
)
=
=
0
)
{
unixPath
+
=
8
;
if
(
*
unixPath
=
=
PR_DIRECTORY_SEPARATOR
)
unixPath
+
+
;
err
=
FindFolder
(
kOnSystemDisk
kTemporaryFolderType
kCreateFolder
&
foundVRefNum
&
foundDirID
)
;
}
if
(
strncmp
(
unixPath
"
/
tmp
"
strlen
(
"
/
tmp
"
)
)
=
=
0
)
{
unixPath
+
=
4
;
if
(
*
unixPath
=
=
PR_DIRECTORY_SEPARATOR
)
unixPath
+
+
;
err
=
FindFolder
(
kOnSystemDisk
kTemporaryFolderType
kCreateFolder
&
foundVRefNum
&
foundDirID
)
;
}
else
if
(
strncmp
(
unixPath
"
/
usr
"
strlen
(
"
/
usr
"
)
)
=
=
0
)
{
int
usrNetscapePathLen
;
usrNetscapePathLen
=
strlen
(
"
/
usr
/
local
/
netscape
/
"
)
;
if
(
strncmp
(
unixPath
"
/
usr
/
local
/
netscape
/
"
usrNetscapePathLen
)
=
=
0
)
{
unixPath
+
=
usrNetscapePathLen
;
err
=
paramErr
;
isNetscapeDir
=
true
;
}
else
{
dprintf
(
"
Unable
to
translate
Unix
file
path
%
s
to
Mac
path
\
n
"
unixPath
)
;
err
=
-
1
;
goto
Exit_ConvertUnixPathToMacPath
;
}
}
else
{
err
=
CreateMacPathFromUnixPath
(
unixPath
macPath
)
;
goto
Exit_ConvertUnixPathToMacPath
;
}
if
(
err
=
=
noErr
)
err
=
GetFullPath
(
foundVRefNum
foundDirID
macPath
&
pathBufferSize
)
;
if
(
err
=
=
noErr
)
{
if
(
pathBufferSize
<
(
strlen
(
*
macPath
)
+
strlen
(
unixPath
)
)
)
{
*
macPath
=
PR_REALLOC
(
*
macPath
(
strlen
(
*
macPath
)
+
strlen
(
unixPath
)
+
(
isNetscapeDir
?
strlen
(
"
Netscape
:
"
)
:
0
)
)
)
;
err
=
(
*
macPath
=
=
NULL
?
memFullErr
:
noErr
)
;
}
if
(
isNetscapeDir
)
strcat
(
*
macPath
"
Netscape
:
"
)
;
if
(
err
=
=
noErr
)
strcat
(
*
macPath
unixPath
)
;
for
(
temp
=
*
macPath
+
strlen
(
*
macPath
)
-
strlen
(
unixPath
)
;
*
temp
!
=
'
\
0
'
;
temp
+
+
)
{
if
(
*
temp
=
=
PR_DIRECTORY_SEPARATOR
)
*
temp
=
PR_PATH_SEPARATOR
;
}
}
}
Exit_ConvertUnixPathToMacPath
:
return
err
;
}
OSErr
ConvertUnixPathToFSSpec
(
const
char
*
unixPath
FSSpec
*
fileSpec
)
{
char
*
macPath
;
OSErr
convertError
;
int
len
;
convertError
=
ConvertUnixPathToMacPath
(
unixPath
&
macPath
)
;
if
(
convertError
!
=
noErr
)
return
convertError
;
len
=
strlen
(
macPath
)
;
if
(
*
macPath
=
=
PR_PATH_SEPARATOR
)
{
if
(
len
<
sizeof
(
Str255
)
)
{
short
vRefNum
;
long
dirID
;
Str255
pascalMacPath
;
convertError
=
HGetVol
(
NULL
&
vRefNum
&
dirID
)
;
if
(
convertError
=
=
noErr
)
{
PStrFromCStr
(
macPath
pascalMacPath
)
;
convertError
=
FSMakeFSSpec
(
vRefNum
dirID
pascalMacPath
fileSpec
)
;
}
}
else
convertError
=
paramErr
;
}
else
{
convertError
=
FSpLocationFromFullPath
(
len
macPath
fileSpec
)
;
}
free
(
macPath
)
;
return
(
convertError
)
;
}
#
endif
PRStatus
_MD_CreateFileMap
(
PRFileMap
*
fmap
PRInt64
size
)
{
#
pragma
unused
(
fmap
size
)
PR_SetError
(
PR_NOT_IMPLEMENTED_ERROR
0
)
;
return
PR_FAILURE
;
}
PRInt32
_MD_GetMemMapAlignment
(
void
)
{
PR_SetError
(
PR_NOT_IMPLEMENTED_ERROR
0
)
;
return
-
1
;
}
void
*
_MD_MemMap
(
PRFileMap
*
fmap
PROffset64
offset
PRUint32
len
)
{
#
pragma
unused
(
fmap
offset
len
)
PR_SetError
(
PR_NOT_IMPLEMENTED_ERROR
0
)
;
return
NULL
;
}
PRStatus
_MD_MemUnmap
(
void
*
addr
PRUint32
len
)
{
#
pragma
unused
(
addr
len
)
PR_SetError
(
PR_NOT_IMPLEMENTED_ERROR
0
)
;
return
PR_FAILURE
;
}
PRStatus
_MD_CloseFileMap
(
PRFileMap
*
fmap
)
{
#
pragma
unused
(
fmap
)
PR_SetError
(
PR_NOT_IMPLEMENTED_ERROR
0
)
;
return
PR_FAILURE
;
}
