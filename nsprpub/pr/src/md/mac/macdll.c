#
include
<
string
.
h
>
#
include
<
Files
.
h
>
#
include
<
Errors
.
h
>
#
include
<
Folders
.
h
>
#
include
<
CodeFragments
.
h
>
#
include
<
Aliases
.
h
>
#
include
<
Resources
.
h
>
#
include
"
IterateDirectory
.
h
"
#
include
"
MacErrorHandling
.
h
"
#
include
"
macdll
.
h
"
#
include
"
mdmac
.
h
"
#
include
"
macio
.
h
"
#
include
"
primpl
.
h
"
#
include
"
plstr
.
h
"
struct
GetSharedLibraryFilterProcData
{
Boolean
inRecursive
;
StringPtr
inName
;
Boolean
outFound
;
CFragConnectionID
outID
;
Ptr
outAddress
;
OSErr
outError
;
}
;
typedef
struct
GetSharedLibraryFilterProcData
GetSharedLibraryFilterProcData
;
static
pascal
void
GetSharedLibraryFilterProc
(
const
CInfoPBRec
*
const
inCpb
Boolean
*
inWantQuit
void
*
inFilterData
)
;
OSErr
NSGetSharedLibrary
(
Str255
inLibName
CFragConnectionID
*
outID
Ptr
*
outMainAddr
)
{
char
*
curLibPath
;
char
*
freeCurLibPath
;
OSErr
tempErr
;
Boolean
recursive
;
FSSpec
curFolder
;
GetSharedLibraryFilterProcData
filterData
;
char
*
endCurLibPath
;
Boolean
done
;
filterData
.
outFound
=
false
;
filterData
.
outID
=
(
CFragConnectionID
)
(
-
1
)
;
filterData
.
outAddress
=
NULL
;
filterData
.
inName
=
inLibName
;
freeCurLibPath
=
curLibPath
=
PR_GetLibraryPath
(
)
;
if
(
curLibPath
=
=
NULL
)
return
(
cfragNoLibraryErr
)
;
tempErr
=
cfragNoLibraryErr
;
do
{
endCurLibPath
=
PL_strchr
(
curLibPath
PR_PATH_SEPARATOR
)
;
done
=
(
endCurLibPath
=
=
NULL
)
;
#
if
0
if
(
*
curLibPath
=
=
'
:
'
)
{
curLibPath
+
+
;
recursive
=
true
;
}
else
#
endif
{
recursive
=
false
;
}
if
(
!
done
)
*
endCurLibPath
=
'
\
0
'
;
tempErr
=
ConvertUnixPathToFSSpec
(
curLibPath
&
curFolder
)
;
if
(
noErr
=
=
tempErr
)
{
filterData
.
inRecursive
=
recursive
;
FSpIterateDirectory
(
&
curFolder
recursive
?
0
:
1
&
GetSharedLibraryFilterProc
&
filterData
)
;
if
(
filterData
.
outFound
)
{
*
outID
=
filterData
.
outID
;
*
outMainAddr
=
filterData
.
outAddress
;
tempErr
=
noErr
;
break
;
}
else
{
tempErr
=
cfragNoLibraryErr
;
}
}
curLibPath
=
endCurLibPath
+
1
;
}
while
(
!
done
)
;
free
(
freeCurLibPath
)
;
return
(
tempErr
)
;
}
static
Boolean
LibInPefContainer
(
const
FSSpec
*
inSpec
StringPtr
inName
UInt32
*
outCodeOffset
UInt32
*
outCodeLength
)
;
static
pascal
void
GetSharedLibraryFilterProc
(
const
CInfoPBRec
*
const
inCpb
Boolean
*
inWantQuit
void
*
inFilterData
)
{
GetSharedLibraryFilterProcData
*
pFilterData
=
(
GetSharedLibraryFilterProcData
*
)
inFilterData
;
if
(
(
inCpb
-
>
hFileInfo
.
ioFlAttrib
&
(
1
<
<
ioDirFlg
)
)
=
=
0
)
{
FSSpec
fragSpec
;
OSErr
tempErr
;
Str255
errName
;
Boolean
crap
;
UInt32
codeOffset
;
UInt32
codeLength
;
switch
(
inCpb
-
>
hFileInfo
.
ioFlFndrInfo
.
fdType
)
{
case
kCFragLibraryFileType
:
case
'
APPL
'
:
tempErr
=
FSMakeFSSpec
(
inCpb
-
>
hFileInfo
.
ioVRefNum
inCpb
-
>
hFileInfo
.
ioFlParID
inCpb
-
>
hFileInfo
.
ioNamePtr
&
fragSpec
)
;
if
(
noErr
!
=
tempErr
)
{
return
;
}
tempErr
=
ResolveAliasFile
(
&
fragSpec
true
&
crap
&
crap
)
;
if
(
noErr
!
=
tempErr
)
{
return
;
}
break
;
default
:
return
;
}
if
(
LibInPefContainer
(
&
fragSpec
pFilterData
-
>
inName
&
codeOffset
&
codeLength
)
)
tempErr
=
GetDiskFragment
(
&
fragSpec
codeOffset
codeLength
fragSpec
.
name
kLoadCFrag
&
pFilterData
-
>
outID
&
pFilterData
-
>
outAddress
errName
)
;
else
return
;
if
(
noErr
=
=
tempErr
)
{
*
inWantQuit
=
true
;
pFilterData
-
>
outFound
=
true
;
pFilterData
-
>
outError
=
tempErr
;
}
}
}
static
Boolean
LibInPefContainer
(
const
FSSpec
*
inSpec
StringPtr
inName
UInt32
*
outCodeOffset
UInt32
*
outCodeLength
)
{
short
refNum
;
CFragResourceHandle
hCfrg
;
CFragResourceMember
*
pCurItem
;
UInt32
curLibIndex
;
Boolean
found
;
found
=
false
;
refNum
=
FSpOpenResFile
(
inSpec
fsRdPerm
)
;
require
(
-
1
!
=
refNum
Exit
)
;
hCfrg
=
(
CFragResourceHandle
)
Get1Resource
(
kCFragResourceType
kCFragResourceID
)
;
require
(
NULL
!
=
hCfrg
CloseResourceAndExit
)
;
HLock
(
(
Handle
)
hCfrg
)
;
pCurItem
=
&
(
*
hCfrg
)
-
>
firstMember
;
for
(
curLibIndex
=
0
;
curLibIndex
<
(
*
hCfrg
)
-
>
memberCount
;
curLibIndex
+
+
)
{
if
(
(
pCurItem
-
>
name
[
0
]
=
=
inName
[
0
]
)
&
&
(
strncmp
(
(
char
*
)
inName
+
1
(
char
*
)
pCurItem
-
>
name
+
1
PR_MIN
(
pCurItem
-
>
name
[
0
]
inName
[
0
]
)
)
=
=
0
)
)
{
*
outCodeOffset
=
pCurItem
-
>
offset
;
*
outCodeLength
=
pCurItem
-
>
length
;
found
=
true
;
}
pCurItem
=
(
CFragResourceMember
*
)
(
(
char
*
)
pCurItem
+
pCurItem
-
>
memberSize
)
;
}
HUnlock
(
(
Handle
)
hCfrg
)
;
CloseResourceAndExit
:
CloseResFile
(
refNum
)
;
Exit
:
return
(
found
)
;
}
OSErr
NSFindSymbol
(
CFragConnectionID
inID
Str255
inSymName
Ptr
*
outMainAddr
CFragSymbolClass
*
outSymClass
)
{
OSErr
err
;
if
(
inSymName
[
0
]
>
63
)
{
long
symbolCount
;
Str255
curSymName
;
long
curIndex
;
Boolean
found
;
found
=
false
;
err
=
CountSymbols
(
inID
&
symbolCount
)
;
if
(
noErr
=
=
err
)
{
for
(
curIndex
=
0
;
(
curIndex
<
=
symbolCount
-
1
&
&
!
found
)
;
curIndex
+
+
)
{
err
=
GetIndSymbol
(
inID
curIndex
curSymName
outMainAddr
outSymClass
)
;
if
(
noErr
=
=
err
&
&
curSymName
[
0
]
=
=
inSymName
[
0
]
&
&
!
strncmp
(
(
char
*
)
curSymName
+
1
(
char
*
)
inSymName
+
1
curSymName
[
0
]
)
)
{
found
=
true
;
}
}
if
(
!
found
)
err
=
cfragNoSymbolErr
;
}
}
else
{
err
=
FindSymbol
(
inID
inSymName
outMainAddr
outSymClass
)
;
}
return
(
err
)
;
}
#
pragma
mark
-
OSErr
GetNamedFragmentOffsets
(
const
FSSpec
*
fileSpec
const
char
*
fragmentName
UInt32
*
outOffset
UInt32
*
outLength
)
{
CFragResourceHandle
cFragHandle
;
short
fileRefNum
;
OSErr
err
=
noErr
;
fileRefNum
=
FSpOpenResFile
(
fileSpec
fsRdPerm
)
;
err
=
ResError
(
)
;
if
(
err
!
=
noErr
)
return
err
;
cFragHandle
=
(
CFragResourceHandle
)
Get1Resource
(
kCFragResourceType
kCFragResourceID
)
;
if
(
!
cFragHandle
)
{
err
=
resNotFound
;
goto
done
;
}
err
=
cfragNoLibraryErr
;
*
outOffset
=
0
;
*
outLength
=
0
;
if
(
(
*
*
cFragHandle
)
.
memberCount
>
0
)
{
CFragResourceMemberPtr
memberPtr
;
UInt16
i
;
for
(
i
=
0
memberPtr
=
&
(
*
*
cFragHandle
)
.
firstMember
;
i
<
(
*
*
cFragHandle
)
.
memberCount
;
i
+
+
memberPtr
=
(
CFragResourceMemberPtr
)
(
(
char
*
)
memberPtr
+
memberPtr
-
>
memberSize
)
)
{
char
memberName
[
256
]
;
UInt16
nameLen
=
PR_MIN
(
memberPtr
-
>
name
[
0
]
255
)
;
strncpy
(
memberName
(
char
*
)
&
memberPtr
-
>
name
[
1
]
nameLen
)
;
memberName
[
nameLen
]
=
'
\
0
'
;
if
(
PL_strcasecmp
(
memberName
fragmentName
)
=
=
0
)
{
*
outOffset
=
memberPtr
-
>
offset
;
*
outLength
=
memberPtr
-
>
length
;
err
=
noErr
;
break
;
}
}
}
done
:
CloseResFile
(
fileRefNum
)
;
return
err
;
}
OSErr
GetIndexedFragmentOffsets
(
const
FSSpec
*
fileSpec
UInt32
fragmentIndex
UInt32
*
outOffset
UInt32
*
outLength
char
*
*
outFragmentName
)
{
CFragResourceHandle
cFragHandle
;
short
fileRefNum
;
OSErr
err
=
noErr
;
fileRefNum
=
FSpOpenResFile
(
fileSpec
fsRdPerm
)
;
err
=
ResError
(
)
;
if
(
err
!
=
noErr
)
return
err
;
cFragHandle
=
(
CFragResourceHandle
)
Get1Resource
(
kCFragResourceType
kCFragResourceID
)
;
if
(
!
cFragHandle
)
{
err
=
resNotFound
;
goto
done
;
}
err
=
cfragNoLibraryErr
;
*
outOffset
=
0
;
*
outLength
=
0
;
*
outFragmentName
=
NULL
;
HLock
(
(
Handle
)
cFragHandle
)
;
if
(
(
*
*
cFragHandle
)
.
memberCount
>
0
)
{
CFragResourceMemberPtr
memberPtr
;
UInt16
i
;
for
(
i
=
0
memberPtr
=
&
(
*
*
cFragHandle
)
.
firstMember
;
i
<
(
*
*
cFragHandle
)
.
memberCount
;
i
+
+
memberPtr
=
(
CFragResourceMemberPtr
)
(
(
char
*
)
memberPtr
+
memberPtr
-
>
memberSize
)
)
{
if
(
i
=
=
fragmentIndex
)
{
char
*
fragmentStr
;
CStrFromPStr
(
memberPtr
-
>
name
&
fragmentStr
)
;
if
(
!
fragmentStr
)
{
err
=
memFullErr
;
break
;
}
*
outFragmentName
=
fragmentStr
;
*
outOffset
=
memberPtr
-
>
offset
;
*
outLength
=
memberPtr
-
>
length
;
err
=
noErr
;
break
;
}
}
}
HUnlock
(
(
Handle
)
cFragHandle
)
;
done
:
CloseResFile
(
fileRefNum
)
;
return
err
;
}
OSErr
NSLoadNamedFragment
(
const
FSSpec
*
fileSpec
const
char
*
fragmentName
CFragConnectionID
*
outConnectionID
)
{
UInt32
fragOffset
fragLength
;
short
fragNameLength
;
Ptr
main
;
Str255
fragName
;
Str255
errName
;
OSErr
err
;
err
=
GetNamedFragmentOffsets
(
fileSpec
fragmentName
&
fragOffset
&
fragLength
)
;
if
(
err
!
=
noErr
)
return
err
;
fragNameLength
=
strlen
(
fragmentName
)
;
if
(
fragNameLength
>
255
)
fragNameLength
=
255
;
BlockMoveData
(
fragmentName
&
fragName
[
1
]
fragNameLength
)
;
fragName
[
0
]
=
fragNameLength
;
err
=
GetDiskFragment
(
fileSpec
fragOffset
fragLength
fragName
kLoadCFrag
outConnectionID
&
main
errName
)
;
return
err
;
}
OSErr
NSLoadIndexedFragment
(
const
FSSpec
*
fileSpec
PRUint32
fragmentIndex
char
*
*
outFragName
CFragConnectionID
*
outConnectionID
)
{
UInt32
fragOffset
fragLength
;
char
*
fragNameBlock
=
NULL
;
Ptr
main
;
Str255
fragName
=
"
\
p
"
;
Str255
errName
;
OSErr
err
;
*
outFragName
=
NULL
;
err
=
GetIndexedFragmentOffsets
(
fileSpec
fragmentIndex
&
fragOffset
&
fragLength
&
fragNameBlock
)
;
if
(
err
!
=
noErr
)
return
err
;
if
(
fragNameBlock
)
{
UInt32
nameLen
=
strlen
(
fragNameBlock
)
;
if
(
nameLen
>
63
)
nameLen
=
63
;
BlockMoveData
(
fragNameBlock
&
fragName
[
1
]
nameLen
)
;
fragName
[
0
]
=
nameLen
;
}
err
=
GetDiskFragment
(
fileSpec
fragOffset
fragLength
fragName
kLoadCFrag
outConnectionID
&
main
errName
)
;
if
(
err
!
=
noErr
)
{
free
(
fragNameBlock
)
;
return
err
;
}
*
outFragName
=
fragNameBlock
;
return
noErr
;
}
