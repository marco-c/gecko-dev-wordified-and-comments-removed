"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TabManager
"
"
TabObserver
"
"
WindowObserver
"
]
;
const
{
DOMContentLoadedPromise
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Sync
.
jsm
"
)
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
class
WindowObserver
{
constructor
(
{
registerExisting
=
false
}
=
{
}
)
{
this
.
registerExisting
=
registerExisting
;
EventEmitter
.
decorate
(
this
)
;
}
async
start
(
)
{
if
(
this
.
registerExisting
)
{
for
(
const
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
await
this
.
onOpenWindow
(
window
)
;
}
}
Services
.
wm
.
addListener
(
this
)
;
}
stop
(
)
{
Services
.
wm
.
removeListener
(
this
)
;
}
async
onOpenWindow
(
xulWindow
)
{
const
window
=
xulWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
await
new
DOMContentLoadedPromise
(
window
)
;
this
.
emit
(
"
open
"
window
)
;
}
onCloseWindow
(
xulWindow
)
{
const
window
=
xulWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
this
.
emit
(
"
close
"
window
)
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWindowMediatorListener
]
)
;
}
}
class
TabObserver
{
constructor
(
{
registerExisting
=
false
}
=
{
}
)
{
this
.
windows
=
new
WindowObserver
(
{
registerExisting
}
)
;
EventEmitter
.
decorate
(
this
)
;
}
async
start
(
)
{
this
.
windows
.
on
(
"
open
"
this
.
onWindowOpen
.
bind
(
this
)
)
;
this
.
windows
.
on
(
"
close
"
this
.
onWindowClose
.
bind
(
this
)
)
;
await
this
.
windows
.
start
(
)
;
}
stop
(
)
{
this
.
windows
.
off
(
"
open
"
)
;
this
.
windows
.
off
(
"
close
"
)
;
this
.
windows
.
stop
(
)
;
}
onTabOpen
(
tab
)
{
this
.
emit
(
"
open
"
tab
)
;
}
onTabClose
(
tab
)
{
this
.
emit
(
"
close
"
tab
)
;
}
async
onWindowOpen
(
eventName
window
)
{
if
(
!
window
.
gBrowser
)
{
return
;
}
for
(
const
tab
of
window
.
gBrowser
.
tabs
)
{
if
(
!
tab
.
linkedBrowser
)
{
continue
;
}
this
.
onTabOpen
(
tab
)
;
}
window
.
addEventListener
(
"
TabOpen
"
(
{
target
}
)
=
>
this
.
onTabOpen
(
target
)
)
;
window
.
addEventListener
(
"
TabClose
"
(
{
target
}
)
=
>
this
.
onTabClose
(
target
)
)
;
}
onWindowClose
(
window
)
{
}
}
var
TabManager
=
{
addTab
(
{
userContextId
}
)
{
const
window
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
const
{
gBrowser
}
=
window
;
const
tab
=
gBrowser
.
addTab
(
"
about
:
blank
"
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
userContextId
}
)
;
gBrowser
.
selectedTab
=
tab
;
return
tab
;
}
}
;
