"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserObserver
"
"
TabObserver
"
"
WindowObserver
"
"
WindowManager
"
]
;
const
{
DOMContentLoadedPromise
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Sync
.
jsm
"
)
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
EventEmitter
.
jsm
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Log
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
Log
.
get
)
;
class
WindowObserver
{
constructor
(
{
registerExisting
=
false
}
=
{
}
)
{
this
.
registerExisting
=
registerExisting
;
EventEmitter
.
decorate
(
this
)
;
}
async
start
(
)
{
if
(
this
.
registerExisting
)
{
for
(
const
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
await
this
.
onOpenWindow
(
window
)
;
}
}
Services
.
wm
.
addListener
(
this
)
;
}
stop
(
)
{
Services
.
wm
.
removeListener
(
this
)
;
}
async
onOpenWindow
(
xulWindow
)
{
const
window
=
xulWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
await
new
DOMContentLoadedPromise
(
window
)
;
this
.
emit
(
"
open
"
window
)
;
}
onCloseWindow
(
xulWindow
)
{
const
window
=
xulWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
this
.
emit
(
"
close
"
window
)
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWindowMediatorListener
]
)
;
}
}
;
class
TabObserver
{
constructor
(
{
registerExisting
=
false
}
=
{
}
)
{
this
.
windows
=
new
WindowObserver
(
{
registerExisting
}
)
;
EventEmitter
.
decorate
(
this
)
;
}
async
start
(
)
{
this
.
windows
.
on
(
"
open
"
this
.
onWindowOpen
.
bind
(
this
)
)
;
this
.
windows
.
on
(
"
close
"
this
.
onWindowClose
.
bind
(
this
)
)
;
await
this
.
windows
.
start
(
)
;
}
stop
(
)
{
this
.
windows
.
off
(
"
open
"
)
;
this
.
windows
.
off
(
"
close
"
)
;
this
.
windows
.
stop
(
)
;
}
onTabOpen
(
tab
)
{
this
.
emit
(
"
open
"
tab
)
;
}
onTabClose
(
tab
)
{
this
.
emit
(
"
close
"
tab
)
;
}
async
onWindowOpen
(
window
)
{
if
(
!
window
.
gBrowser
)
{
return
;
}
for
(
const
tab
of
window
.
gBrowser
.
tabs
)
{
this
.
onTabOpen
(
tab
)
;
}
window
.
addEventListener
(
"
TabOpen
"
(
{
target
}
)
=
>
this
.
onTabOpen
(
target
)
)
;
window
.
addEventListener
(
"
TabClose
"
(
{
target
}
)
=
>
this
.
onTabClose
(
target
)
)
;
}
onWindowClose
(
window
)
{
}
}
;
class
BrowserObserver
{
constructor
(
)
{
EventEmitter
.
decorate
(
this
)
;
}
start
(
)
{
Services
.
mm
.
addMessageListener
(
"
Browser
:
Init
"
this
)
;
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
}
stop
(
)
{
Services
.
mm
.
removeMessageListener
(
"
Browser
:
Init
"
this
)
;
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
disconnect
"
)
;
}
onBrowserInit
(
browser
)
{
this
.
emit
(
"
connected
"
browser
)
;
}
onMessageManagerDisconnect
(
browser
)
{
if
(
!
browser
.
isConnected
)
{
this
.
emit
(
"
disconnected
"
browser
)
;
}
}
receiveMessage
(
{
name
target
}
)
{
switch
(
name
)
{
case
"
Browser
:
Init
"
:
this
.
onBrowserInit
(
target
)
;
break
;
default
:
log
.
warn
(
"
Unknown
IPC
message
form
browser
:
"
+
name
)
;
break
;
}
}
observe
(
subject
topic
)
{
switch
(
topic
)
{
case
"
message
-
manager
-
disconnect
"
:
this
.
onMessageManagerDisconnect
(
subject
)
;
break
;
default
:
log
.
warn
(
"
Unknown
system
observer
notification
:
"
+
topic
)
;
}
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
Ci
.
nsIMessageListener
Ci
.
nsIObserver
]
)
;
}
}
;
function
isWindowIncluded
(
boundary
target
)
{
if
(
target
=
=
=
boundary
)
{
return
true
;
}
const
{
parent
}
=
target
;
if
(
!
parent
|
|
parent
=
=
=
boundary
)
{
return
false
;
}
return
isWindowIncluded
(
boundary
parent
)
;
}
var
WindowManager
=
{
isWindowIncluded
}
;
