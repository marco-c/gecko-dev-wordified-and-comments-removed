"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
StreamRegistry
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
UnsupportedError
:
"
chrome
:
/
/
remote
/
content
/
cdp
/
Error
.
jsm
"
}
)
;
class
StreamRegistry
{
constructor
(
)
{
this
.
streams
=
new
Map
(
)
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
Remote
Agent
:
Clean
-
up
of
open
streams
"
async
(
)
=
>
{
await
this
.
destructor
(
)
;
}
)
;
}
async
destructor
(
)
{
for
(
const
stream
of
this
.
streams
.
values
(
)
)
{
await
this
.
_discard
(
stream
)
;
}
this
.
streams
.
clear
(
)
;
}
async
_discard
(
stream
)
{
if
(
stream
instanceof
OS
.
File
)
{
let
fileInfo
;
try
{
fileInfo
=
await
stream
.
stat
(
)
;
stream
.
close
(
)
;
await
OS
.
File
.
remove
(
fileInfo
.
path
{
ignoreAbsent
:
true
}
)
;
}
catch
(
e
)
{
console
.
error
(
Failed
to
remove
{
fileInfo
?
.
path
}
:
{
e
.
message
}
)
;
}
}
}
add
(
stream
)
{
let
handle
;
if
(
stream
instanceof
OS
.
File
)
{
handle
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
}
else
{
throw
new
UnsupportedError
(
Unknown
stream
type
for
{
stream
}
)
;
}
this
.
streams
.
set
(
handle
stream
)
;
return
handle
;
}
get
(
handle
)
{
const
stream
=
this
.
streams
.
get
(
handle
)
;
if
(
!
stream
)
{
throw
new
TypeError
(
Invalid
stream
handle
)
;
}
return
stream
;
}
async
remove
(
handle
)
{
const
stream
=
this
.
get
(
handle
)
;
await
this
.
_discard
(
stream
)
;
return
this
.
streams
.
delete
(
handle
)
;
}
}
