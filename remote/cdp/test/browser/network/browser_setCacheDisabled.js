"
use
strict
"
;
const
{
INHIBIT_CACHING
LOAD_BYPASS_CACHE
LOAD_NORMAL
}
=
Ci
.
nsIRequest
;
const
TEST_PAGE
=
"
https
:
/
/
example
.
com
/
browser
/
remote
/
cdp
/
test
/
browser
/
network
/
doc_empty
.
html
"
;
add_task
(
async
function
cacheEnabledAfterDisabled
(
{
client
}
)
{
const
{
Network
}
=
client
;
await
Network
.
setCacheDisabled
(
{
cacheDisabled
:
true
}
)
;
await
Network
.
setCacheDisabled
(
{
cacheDisabled
:
false
}
)
;
await
watchLoadFlags
(
LOAD_NORMAL
TEST_PAGE
)
;
await
loadURL
(
TEST_PAGE
)
;
await
waitForLoadFlags
(
)
;
}
)
;
add_task
(
async
function
cacheEnabledByDefault
(
)
{
await
watchLoadFlags
(
LOAD_NORMAL
TEST_PAGE
)
;
await
loadURL
(
TEST_PAGE
)
;
await
waitForLoadFlags
(
)
;
}
)
;
add_task
(
async
function
cacheDisabled
(
{
client
}
)
{
const
{
Network
}
=
client
;
await
Network
.
setCacheDisabled
(
{
cacheDisabled
:
true
}
)
;
await
watchLoadFlags
(
LOAD_BYPASS_CACHE
|
INHIBIT_CACHING
TEST_PAGE
)
;
await
loadURL
(
TEST_PAGE
)
;
await
waitForLoadFlags
(
)
;
}
)
;
function
watchLoadFlags
(
flags
url
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
flags
url
}
]
async
(
options
=
{
}
)
=
>
{
const
{
flags
url
}
=
options
;
var
RequestWatcher
=
{
init
(
docShell
expectedLoadFlags
url
callback
)
{
this
.
callback
=
callback
;
this
.
docShell
=
docShell
;
this
.
expectedLoadFlags
=
expectedLoadFlags
;
this
.
url
=
url
;
this
.
requestCount
=
0
;
const
{
NOTIFY_STATE_DOCUMENT
NOTIFY_STATE_REQUEST
}
=
Ci
.
nsIWebProgress
;
this
.
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
.
addProgressListener
(
this
NOTIFY_STATE_DOCUMENT
|
NOTIFY_STATE_REQUEST
)
;
}
onStateChange
(
webProgress
request
flags
)
{
if
(
!
request
)
{
return
;
}
if
(
request
.
name
.
startsWith
(
"
about
:
"
)
|
|
request
.
name
.
startsWith
(
"
resource
:
"
)
|
|
request
.
name
.
startsWith
(
"
chrome
:
"
)
)
{
return
;
}
is
(
request
.
loadFlags
&
this
.
expectedLoadFlags
this
.
expectedLoadFlags
"
request
"
+
request
.
name
+
"
has
the
expected
flags
"
)
;
this
.
requestCount
+
=
1
;
var
stopFlags
=
Ci
.
nsIWebProgressListener
.
STATE_STOP
|
Ci
.
nsIWebProgressListener
.
STATE_IS_DOCUMENT
;
if
(
request
.
name
=
=
this
.
url
&
&
(
flags
&
stopFlags
)
=
=
stopFlags
)
{
this
.
docShell
.
removeProgressListener
(
this
)
;
Assert
.
greater
(
this
.
requestCount
1
this
.
url
+
"
saw
"
+
this
.
requestCount
+
"
requests
"
)
;
this
.
callback
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
}
;
content
.
resolveCheckLoadFlags
=
new
Promise
(
resolve
=
>
{
RequestWatcher
.
init
(
docShell
flags
url
resolve
)
;
}
)
;
}
)
;
}
function
waitForLoadFlags
(
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
async
(
)
=
>
{
await
content
.
resolveCheckLoadFlags
;
delete
content
.
resolveCheckLoadFlags
;
}
)
;
}
