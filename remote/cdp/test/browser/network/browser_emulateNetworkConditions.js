"
use
strict
"
;
const
pageEmptyURL
=
"
https
:
/
/
example
.
com
/
browser
/
remote
/
cdp
/
test
/
browser
/
page
/
doc_empty
.
html
"
;
Services
.
prefs
.
setBoolPref
(
"
network
.
disable
-
localhost
-
when
-
offline
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
network
.
disable
-
localhost
-
when
-
offline
"
)
;
}
)
;
function
add_networking_task
(
taskFn
)
{
add_task
(
async
client
=
>
{
try
{
await
taskFn
(
client
)
;
}
finally
{
Services
.
io
.
offline
=
false
;
}
}
)
;
}
add_networking_task
(
async
function
offlineWithoutArguments
(
{
client
}
)
{
const
{
Network
}
=
client
;
let
errorThrown
=
"
"
;
try
{
await
Network
.
emulateNetworkConditions
(
)
;
}
catch
(
e
)
{
errorThrown
=
e
.
message
;
}
ok
(
errorThrown
.
match
(
/
offline
:
boolean
value
expected
/
)
"
Fails
without
any
arguments
"
)
;
}
)
;
add_networking_task
(
async
function
offlineWithEmptyArguments
(
{
client
}
)
{
const
{
Network
}
=
client
;
let
errorThrown
=
"
"
;
try
{
await
Network
.
emulateNetworkConditions
(
{
}
)
;
}
catch
(
e
)
{
errorThrown
=
e
.
message
;
}
ok
(
errorThrown
.
match
(
/
offline
:
boolean
value
expected
/
)
"
Fails
with
only
empty
arguments
"
)
;
}
)
;
add_networking_task
(
async
function
offlineWithInvalidArguments
(
{
client
}
)
{
const
{
Network
}
=
client
;
const
testTable
=
[
null
undefined
1
"
foo
"
[
]
{
}
]
;
for
(
const
testCase
of
testTable
)
{
let
errorThrown
=
"
"
;
try
{
await
Network
.
emulateNetworkConditions
(
{
offline
:
testCase
}
)
;
}
catch
(
e
)
{
errorThrown
=
e
.
message
;
}
const
testType
=
typeof
testCase
;
ok
(
errorThrown
.
match
(
/
offline
:
boolean
value
expected
/
)
Fails
with
{
testType
}
-
type
argument
for
offline
)
;
}
}
)
;
add_networking_task
(
async
function
offlineWithUnsupportedArguments
(
{
client
}
)
{
const
{
Network
}
=
client
;
const
args
=
{
offline
:
true
latency
:
500
downloadThroughput
:
500
uploadThroughput
:
500
connectionType
:
"
cellular2g
"
someFutureArg
:
false
}
;
await
Network
.
emulateNetworkConditions
(
args
)
;
ok
(
true
"
No
errors
should
be
thrown
due
to
non
-
implemented
arguments
"
)
;
}
)
;
add_networking_task
(
async
function
emulateOfflineWhileOnline
(
{
client
}
)
{
const
{
Network
}
=
client
;
await
assertOfflineStatus
(
false
)
;
await
Network
.
emulateNetworkConditions
(
{
offline
:
true
}
)
;
await
assertOfflineStatus
(
true
)
;
await
assertOfflineNavigationFails
(
)
;
}
)
;
add_networking_task
(
async
function
emulateOfflineWhileOffline
(
{
client
}
)
{
const
{
Network
}
=
client
;
await
assertOfflineStatus
(
false
)
;
await
Network
.
emulateNetworkConditions
(
{
offline
:
true
}
)
;
await
assertOfflineStatus
(
true
)
;
await
Network
.
emulateNetworkConditions
(
{
offline
:
true
}
)
;
await
assertOfflineStatus
(
true
)
;
await
assertOfflineNavigationFails
(
)
;
}
)
;
add_networking_task
(
async
function
emulateOnlineWhileOnline
(
{
client
}
)
{
const
{
Network
}
=
client
;
await
assertOfflineStatus
(
false
)
;
await
Network
.
emulateNetworkConditions
(
{
offline
:
false
}
)
;
await
assertOfflineStatus
(
false
)
;
}
)
;
add_networking_task
(
async
function
emulateOnlineWhileOffline
(
{
client
}
)
{
const
{
Network
}
=
client
;
await
assertOfflineStatus
(
false
)
;
const
offlineChanged
=
Promise
.
race
(
[
BrowserTestUtils
.
waitForContentEvent
(
gBrowser
.
selectedBrowser
"
online
"
true
)
BrowserTestUtils
.
waitForContentEvent
(
gBrowser
.
selectedBrowser
"
offline
"
true
)
]
)
;
await
Network
.
emulateNetworkConditions
(
{
offline
:
true
}
)
;
info
(
"
Waiting
for
offline
event
on
window
"
)
;
is
(
await
offlineChanged
"
offline
"
"
Only
the
offline
-
event
should
fire
"
)
;
await
assertOfflineStatus
(
true
)
;
const
offlineChangedBack
=
Promise
.
race
(
[
BrowserTestUtils
.
waitForContentEvent
(
gBrowser
.
selectedBrowser
"
online
"
true
)
BrowserTestUtils
.
waitForContentEvent
(
gBrowser
.
selectedBrowser
"
offline
"
true
)
]
)
;
await
Network
.
emulateNetworkConditions
(
{
offline
:
false
}
)
;
info
(
"
Waiting
for
online
event
on
window
"
)
;
is
(
await
offlineChangedBack
"
online
"
"
Only
the
online
-
event
should
fire
"
)
;
await
assertOfflineStatus
(
false
)
;
}
)
;
async
function
assertOfflineNavigationFails
(
)
{
const
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
let
netErrorLoaded
=
BrowserTestUtils
.
waitForErrorPage
(
browser
)
;
BrowserTestUtils
.
loadURI
(
browser
pageEmptyURL
)
;
await
netErrorLoaded
;
}
function
assertOfflineStatus
(
offline
)
{
is
(
Services
.
io
.
offline
offline
"
Services
.
io
.
offline
should
be
"
+
(
offline
?
"
true
"
:
"
false
"
)
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
offline
]
offline
=
>
{
is
(
content
.
navigator
.
onLine
!
offline
"
Page
should
be
"
+
(
offline
?
"
offline
"
:
"
online
"
)
)
;
}
)
;
}
