"
use
strict
"
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
RemoteAgent
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
components
/
RemoteAgent
.
jsm
"
)
;
const
{
RemoteAgentError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
cdp
/
Error
.
jsm
"
)
;
const
{
TabManager
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
)
;
const
TIMEOUT_MULTIPLIER
=
SpecialPowers
.
isDebugBuild
?
4
:
1
;
const
TIMEOUT_EVENTS
=
1000
*
TIMEOUT_MULTIPLIER
;
const
add_plain_task
=
add_task
.
bind
(
this
)
;
this
.
add_task
=
function
(
taskFn
opts
=
{
}
)
{
const
{
createTab
=
true
}
=
opts
;
const
fn
=
async
function
(
)
{
let
client
tab
target
;
try
{
const
CDP
=
await
getCDP
(
)
;
if
(
createTab
)
{
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
const
tabId
=
TabManager
.
getIdForBrowser
(
tab
.
linkedBrowser
)
;
const
targets
=
await
CDP
.
List
(
)
;
target
=
targets
.
find
(
target
=
>
target
.
id
=
=
=
tabId
)
;
}
client
=
await
CDP
(
{
target
}
)
;
info
(
"
CDP
client
instantiated
"
)
;
await
getDiscoveredTargets
(
client
.
Target
)
;
await
taskFn
(
{
client
CDP
tab
}
)
;
if
(
createTab
)
{
await
TestUtils
.
waitForTick
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
}
catch
(
e
)
{
if
(
e
.
response
)
{
throw
RemoteAgentError
.
fromJSON
(
e
.
response
)
;
}
else
{
throw
e
;
}
}
finally
{
if
(
client
)
{
await
client
.
close
(
)
;
info
(
"
CDP
client
closed
"
)
;
}
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
}
;
Object
.
defineProperty
(
fn
"
name
"
{
value
:
taskFn
.
name
writable
:
false
}
)
;
add_plain_task
(
fn
)
;
}
;
function
createTestDocument
(
)
{
const
browser
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
registerCleanupFunction
(
(
)
=
>
browser
.
close
(
)
)
;
const
webNavigation
=
browser
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
const
system
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
webNavigation
.
createAboutBlankContentViewer
(
system
system
)
;
return
webNavigation
.
document
;
}
async
function
getCDP
(
)
{
const
document
=
createTestDocument
(
)
;
const
window
=
document
.
defaultView
.
wrappedJSObject
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
remote
/
cdp
/
test
/
browser
/
chrome
-
remote
-
interface
.
js
"
window
)
;
window
.
criRequest
=
(
options
callback
)
=
>
{
const
{
path
}
=
options
;
const
url
=
http
:
/
/
{
RemoteAgent
.
host
}
:
{
RemoteAgent
.
port
}
{
path
}
;
const
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
url
true
)
;
xhr
.
overrideMimeType
(
"
text
/
plain
"
)
;
xhr
.
send
(
null
)
;
xhr
.
onload
=
(
)
=
>
callback
(
null
xhr
.
responseText
)
;
xhr
.
onerror
=
e
=
>
callback
(
e
null
)
;
}
;
return
window
.
CDP
;
}
async
function
getScrollbarSize
(
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
(
)
=
>
{
const
scrollbarHeight
=
{
}
;
const
scrollbarWidth
=
{
}
;
content
.
windowUtils
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
return
{
width
:
scrollbarWidth
.
value
height
:
scrollbarHeight
.
value
}
;
}
)
;
}
function
getTargets
(
CDP
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
CDP
.
List
(
null
(
err
targets
)
=
>
{
if
(
err
)
{
reject
(
err
)
;
return
;
}
resolve
(
targets
)
;
}
)
;
}
)
;
}
async
function
getDiscoveredTargets
(
Target
)
{
return
new
Promise
(
resolve
=
>
{
const
targets
=
[
]
;
const
unsubscribe
=
Target
.
targetCreated
(
target
=
>
{
targets
.
push
(
target
)
;
if
(
targets
.
length
>
=
gBrowser
.
tabs
.
length
+
1
)
{
unsubscribe
(
)
;
resolve
(
targets
)
;
}
}
)
;
Target
.
setDiscoverTargets
(
{
discover
:
true
}
)
;
}
)
;
}
async
function
openTab
(
Target
options
=
{
}
)
{
const
{
activate
=
false
}
=
options
;
info
(
"
Create
a
new
tab
and
wait
for
the
target
to
be
created
"
)
;
const
targetCreated
=
Target
.
targetCreated
(
)
;
const
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
const
{
targetInfo
}
=
await
targetCreated
;
is
(
targetInfo
.
type
"
page
"
)
;
if
(
activate
)
{
await
Target
.
activateTarget
(
{
targetId
:
targetInfo
.
targetId
}
)
;
info
(
New
tab
with
target
id
{
targetInfo
.
targetId
}
created
and
activated
)
;
}
else
{
info
(
New
tab
with
target
id
{
targetInfo
.
targetId
}
created
)
;
}
return
{
targetInfo
newTab
}
;
}
async
function
openWindow
(
Target
options
=
{
}
)
{
const
{
activate
=
false
}
=
options
;
info
(
"
Create
a
new
window
and
wait
for
the
target
to
be
created
"
)
;
const
targetCreated
=
Target
.
targetCreated
(
)
;
const
newWindow
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
const
newTab
=
newWindow
.
gBrowser
.
selectedTab
;
const
{
targetInfo
}
=
await
targetCreated
;
is
(
targetInfo
.
type
"
page
"
)
;
if
(
activate
)
{
await
Target
.
activateTarget
(
{
targetId
:
targetInfo
.
targetId
}
)
;
info
(
New
window
with
target
id
{
targetInfo
.
targetId
}
created
and
activated
)
;
}
else
{
info
(
New
window
with
target
id
{
targetInfo
.
targetId
}
created
)
;
}
return
{
targetInfo
newWindow
newTab
}
;
}
function
toDataURL
(
src
doctype
=
"
html
"
)
{
let
doc
mime
;
switch
(
doctype
)
{
case
"
html
"
:
mime
=
"
text
/
html
;
charset
=
utf
-
8
"
;
doc
=
<
!
doctype
html
>
\
n
<
meta
charset
=
utf
-
8
>
\
n
{
src
}
;
break
;
default
:
throw
new
Error
(
"
Unexpected
doctype
:
"
+
doctype
)
;
}
return
data
:
{
mime
}
{
encodeURIComponent
(
doc
)
}
;
}
function
convertArgument
(
arg
)
{
if
(
typeof
arg
=
=
=
"
bigint
"
)
{
return
{
unserializableValue
:
{
arg
.
toString
(
)
}
n
}
;
}
if
(
Object
.
is
(
arg
-
0
)
)
{
return
{
unserializableValue
:
"
-
0
"
}
;
}
if
(
Object
.
is
(
arg
Infinity
)
)
{
return
{
unserializableValue
:
"
Infinity
"
}
;
}
if
(
Object
.
is
(
arg
-
Infinity
)
)
{
return
{
unserializableValue
:
"
-
Infinity
"
}
;
}
if
(
Object
.
is
(
arg
NaN
)
)
{
return
{
unserializableValue
:
"
NaN
"
}
;
}
return
{
value
:
arg
}
;
}
async
function
evaluate
(
client
contextId
pageFunction
.
.
.
args
)
{
const
{
Runtime
}
=
client
;
if
(
typeof
pageFunction
=
=
=
"
string
"
)
{
return
Runtime
.
evaluate
(
{
expression
:
pageFunction
contextId
returnByValue
:
true
awaitPromise
:
true
}
)
;
}
else
if
(
typeof
pageFunction
=
=
=
"
function
"
)
{
return
Runtime
.
callFunctionOn
(
{
functionDeclaration
:
pageFunction
.
toString
(
)
executionContextId
:
contextId
arguments
:
args
.
map
(
convertArgument
)
returnByValue
:
true
awaitPromise
:
true
}
)
;
}
throw
new
Error
(
"
pageFunction
:
expected
'
string
'
or
'
function
'
"
)
;
}
async
function
loadURL
(
url
expectedURL
=
undefined
)
{
expectedURL
=
expectedURL
|
|
url
;
const
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
const
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
true
expectedURL
)
;
BrowserTestUtils
.
loadURI
(
browser
url
)
;
await
loaded
;
}
async
function
enableRuntime
(
client
)
{
const
{
Runtime
}
=
client
;
await
Runtime
.
enable
(
)
;
info
(
"
Runtime
domain
has
been
enabled
"
)
;
const
{
context
}
=
await
Runtime
.
executionContextCreated
(
)
;
ok
(
!
!
context
.
id
"
The
execution
context
has
an
id
"
)
;
ok
(
context
.
auxData
.
isDefault
"
The
execution
context
is
the
default
one
"
)
;
ok
(
!
!
context
.
auxData
.
frameId
"
The
execution
context
has
a
frame
id
set
"
)
;
return
context
;
}
function
getContentProperty
(
prop
)
{
info
(
Retrieve
{
prop
}
on
the
content
window
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
prop
]
_prop
=
>
content
[
_prop
]
)
;
}
async
function
getFlattenedFrameTree
(
client
)
{
const
{
Page
}
=
client
;
function
flatten
(
frames
)
{
return
frames
.
reduce
(
(
result
current
)
=
>
{
result
.
set
(
current
.
frame
.
id
current
.
frame
)
;
if
(
current
.
childFrames
)
{
const
frames
=
flatten
(
current
.
childFrames
)
;
result
=
new
Map
(
[
.
.
.
result
.
.
.
frames
]
)
;
}
return
result
;
}
new
Map
(
)
)
;
}
const
{
frameTree
}
=
await
Page
.
getFrameTree
(
)
;
return
flatten
(
Array
(
frameTree
)
)
;
}
function
timeoutPromise
(
ms
)
{
return
new
Promise
(
resolve
=
>
{
window
.
setTimeout
(
resolve
ms
)
;
}
)
;
}
function
fail
(
message
)
{
ok
(
false
message
)
;
}
async
function
createFile
(
contents
options
=
{
}
)
{
let
{
path
=
null
remove
=
true
}
=
options
;
if
(
!
path
)
{
const
basePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
tmpDir
"
remote
-
agent
.
txt
"
)
;
const
{
file
path
:
tmpPath
}
=
await
OS
.
File
.
openUnique
(
basePath
{
humanReadable
:
true
}
)
;
await
file
.
close
(
)
;
path
=
tmpPath
;
}
let
encoder
=
new
TextEncoder
(
)
;
let
array
=
encoder
.
encode
(
contents
)
;
const
count
=
await
OS
.
File
.
writeAtomic
(
path
array
{
encoding
:
"
utf
-
8
"
tmpPath
:
path
+
"
.
tmp
"
}
)
;
is
(
count
contents
.
length
"
All
data
has
been
written
to
file
"
)
;
const
file
=
await
OS
.
File
.
open
(
path
)
;
if
(
remove
)
{
registerCleanupFunction
(
async
(
)
=
>
{
await
file
.
close
(
)
;
await
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
}
)
;
}
return
{
file
path
}
;
}
async
function
throwScriptError
(
options
=
{
}
)
{
const
{
inContent
=
true
}
=
options
;
const
addScriptErrorInternal
=
(
{
options
}
)
=
>
{
const
{
flag
=
Ci
.
nsIScriptError
.
errorFlag
innerWindowId
=
content
.
windowGlobalChild
.
innerWindowId
}
=
options
;
const
scriptError
=
Cc
[
"
mozilla
.
org
/
scripterror
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptError
)
;
scriptError
.
initWithWindowID
(
options
.
text
options
.
sourceName
|
|
"
sourceName
"
null
options
.
lineNumber
|
|
0
options
.
columnNumber
|
|
0
flag
options
.
category
|
|
"
javascript
"
innerWindowId
)
;
Services
.
console
.
logMessage
(
scriptError
)
;
}
;
if
(
inContent
)
{
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
options
}
addScriptErrorInternal
)
;
}
else
{
options
.
innerWindowId
=
window
.
windowGlobalChild
.
innerWindowId
;
addScriptErrorInternal
(
{
options
}
)
;
}
}
class
RecordEvents
{
constructor
(
total
)
{
this
.
events
=
[
]
;
this
.
promises
=
new
Set
(
)
;
this
.
subscriptions
=
new
Set
(
)
;
this
.
total
=
total
;
}
addRecorder
(
options
=
{
}
)
{
const
{
event
eventName
messageFn
=
(
)
=
>
Recorded
{
eventName
}
callback
}
=
options
;
const
promise
=
new
Promise
(
resolve
=
>
{
const
unsubscribe
=
event
(
payload
=
>
{
info
(
messageFn
(
payload
)
)
;
this
.
events
.
push
(
{
eventName
payload
index
:
this
.
events
.
length
}
)
;
callback
?
.
(
{
eventName
payload
index
:
this
.
events
.
length
-
1
}
)
;
if
(
this
.
events
.
length
>
this
.
total
)
{
this
.
subscriptions
.
delete
(
unsubscribe
)
;
unsubscribe
(
)
;
resolve
(
this
.
events
)
;
}
}
)
;
this
.
subscriptions
.
add
(
unsubscribe
)
;
}
)
;
this
.
promises
.
add
(
promise
)
;
}
addPromise
(
step
)
{
let
callback
;
const
promise
=
new
Promise
(
resolve
=
>
{
callback
=
value
=
>
{
resolve
(
)
;
info
(
Recorded
{
step
}
)
;
this
.
events
.
push
(
{
eventName
:
step
payload
:
value
index
:
this
.
events
.
length
}
)
;
return
value
;
}
;
}
)
;
this
.
promises
.
add
(
promise
)
;
return
callback
;
}
async
record
(
timeout
=
TIMEOUT_EVENTS
)
{
await
Promise
.
race
(
[
Promise
.
all
(
this
.
promises
)
timeoutPromise
(
timeout
)
]
)
;
for
(
const
unsubscribe
of
this
.
subscriptions
)
{
unsubscribe
(
)
;
}
return
this
.
events
;
}
filter
(
predicate
)
{
return
this
.
events
.
filter
(
predicate
)
;
}
findEvent
(
eventName
)
{
const
event
=
this
.
events
.
find
(
el
=
>
el
.
eventName
=
=
eventName
)
;
if
(
event
)
{
return
event
;
}
return
{
}
;
}
findEvents
(
eventName
)
{
return
this
.
events
.
filter
(
event
=
>
event
.
eventName
=
=
eventName
)
;
}
indexOf
(
eventName
)
{
const
event
=
this
.
events
.
find
(
el
=
>
el
.
eventName
=
=
eventName
)
;
if
(
event
)
{
return
event
.
index
;
}
return
-
1
;
}
}
