"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ContentProcessSession
"
]
;
const
{
ContentProcessDomains
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
cdp
/
domains
/
ContentProcessDomains
.
jsm
"
)
;
const
{
DomainCache
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
cdp
/
domains
/
DomainCache
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ContextObserver
"
"
chrome
:
/
/
remote
/
content
/
cdp
/
observers
/
ContextObserver
.
jsm
"
)
;
class
ContentProcessSession
{
constructor
(
messageManager
browsingContext
content
docShell
)
{
this
.
messageManager
=
messageManager
;
this
.
browsingContext
=
browsingContext
;
this
.
content
=
content
;
this
.
docShell
=
docShell
;
this
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
this
.
domains
=
new
DomainCache
(
this
ContentProcessDomains
)
;
this
.
messageManager
.
addMessageListener
(
"
remote
:
request
"
this
)
;
this
.
messageManager
.
addMessageListener
(
"
remote
:
destroy
"
this
)
;
}
destructor
(
)
{
this
.
_contextObserver
?
.
destructor
(
)
;
this
.
messageManager
.
removeMessageListener
(
"
remote
:
request
"
this
)
;
this
.
messageManager
.
removeMessageListener
(
"
remote
:
destroy
"
this
)
;
this
.
domains
.
clear
(
)
;
}
get
contextObserver
(
)
{
if
(
!
this
.
_contextObserver
)
{
this
.
_contextObserver
=
new
ContextObserver
(
this
.
docShell
.
chromeEventHandler
)
;
}
return
this
.
_contextObserver
;
}
onEvent
(
eventName
params
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
remote
:
event
"
{
browsingContextId
:
this
.
browsingContext
.
id
event
:
{
eventName
params
}
}
)
;
}
async
receiveMessage
(
{
name
data
}
)
{
const
{
browsingContextId
}
=
data
;
if
(
browsingContextId
!
=
this
.
browsingContext
.
id
)
{
return
;
}
switch
(
name
)
{
case
"
remote
:
request
"
:
try
{
const
{
id
domain
command
params
}
=
data
.
request
;
const
result
=
await
this
.
domains
.
execute
(
domain
command
params
)
;
this
.
messageManager
.
sendAsyncMessage
(
"
remote
:
result
"
{
browsingContextId
id
result
}
)
;
}
catch
(
e
)
{
this
.
messageManager
.
sendAsyncMessage
(
"
remote
:
error
"
{
browsingContextId
id
:
data
.
request
.
id
error
:
{
name
:
e
.
name
|
|
"
exception
"
message
:
e
.
message
|
|
String
(
e
)
stack
:
e
.
stack
}
}
)
;
}
break
;
case
"
remote
:
destroy
"
:
this
.
destructor
(
)
;
break
;
}
}
}
