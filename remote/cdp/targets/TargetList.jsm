"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TargetList
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
EventEmitter
:
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
MainProcessTarget
:
"
chrome
:
/
/
remote
/
content
/
cdp
/
targets
/
MainProcessTarget
.
jsm
"
TabObserver
:
"
chrome
:
/
/
remote
/
content
/
cdp
/
observers
/
TargetObserver
.
jsm
"
TabTarget
:
"
chrome
:
/
/
remote
/
content
/
cdp
/
targets
/
TabTarget
.
jsm
"
}
)
;
class
TargetList
{
constructor
(
)
{
this
.
_targets
=
new
Map
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
async
watchForTargets
(
)
{
await
this
.
watchForTabs
(
)
;
}
unwatchForTargets
(
)
{
this
.
unwatchForTabs
(
)
;
}
async
watchForTabs
(
)
{
if
(
this
.
tabObserver
)
{
throw
new
Error
(
"
Targets
is
already
watching
for
new
tabs
"
)
;
}
this
.
tabObserver
=
new
TabObserver
(
{
registerExisting
:
true
}
)
;
this
.
tabObserver
.
on
(
"
open
"
async
(
eventName
tab
)
=
>
{
const
target
=
new
TabTarget
(
this
tab
.
linkedBrowser
)
;
this
.
registerTarget
(
target
)
;
}
)
;
this
.
tabObserver
.
on
(
"
close
"
(
eventName
tab
)
=
>
{
const
browser
=
tab
.
linkedBrowser
;
if
(
!
browser
.
browsingContext
)
{
return
;
}
const
target
=
this
.
getByBrowsingContext
(
browser
.
browsingContext
.
id
)
;
if
(
target
)
{
this
.
destroyTarget
(
target
)
;
}
}
)
;
await
this
.
tabObserver
.
start
(
)
;
}
unwatchForTabs
(
)
{
if
(
this
.
tabObserver
)
{
this
.
tabObserver
.
stop
(
)
;
this
.
tabObserver
=
null
;
}
}
registerTarget
(
target
)
{
this
.
_targets
.
set
(
target
.
id
target
)
;
this
.
emit
(
"
target
-
created
"
target
)
;
}
destroyTarget
(
target
)
{
target
.
destructor
(
)
;
this
.
_targets
.
delete
(
target
.
id
)
;
this
.
emit
(
"
target
-
destroyed
"
target
)
;
}
destructor
(
)
{
for
(
const
target
of
this
)
{
this
.
destroyTarget
(
target
)
;
}
this
.
_targets
.
clear
(
)
;
if
(
this
.
mainProcessTarget
)
{
this
.
mainProcessTarget
=
null
;
}
this
.
unwatchForTargets
(
)
;
}
get
size
(
)
{
return
this
.
_targets
.
size
;
}
getById
(
id
)
{
return
this
.
_targets
.
get
(
id
)
;
}
getByBrowsingContext
(
id
)
{
let
rv
;
for
(
const
target
of
this
.
_targets
.
values
(
)
)
{
if
(
target
.
browsingContext
&
&
target
.
browsingContext
.
id
=
=
=
id
)
{
rv
=
target
;
break
;
}
}
return
rv
;
}
getMainProcessTarget
(
)
{
if
(
!
this
.
mainProcessTarget
)
{
this
.
mainProcessTarget
=
new
MainProcessTarget
(
this
)
;
this
.
registerTarget
(
this
.
mainProcessTarget
)
;
}
return
this
.
mainProcessTarget
;
}
*
[
Symbol
.
iterator
]
(
)
{
for
(
const
target
of
this
.
_targets
.
values
(
)
)
{
yield
target
;
}
}
toJSON
(
)
{
return
[
.
.
.
this
]
;
}
toString
(
)
{
return
[
object
TargetList
{
this
.
size
}
]
;
}
}
