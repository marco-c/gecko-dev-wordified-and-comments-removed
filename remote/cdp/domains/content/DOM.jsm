"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DOM
"
]
;
const
{
ContentProcessDomain
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
cdp
/
domains
/
ContentProcessDomain
.
jsm
"
)
;
class
DOM
extends
ContentProcessDomain
{
constructor
(
session
)
{
super
(
session
)
;
this
.
enabled
=
false
;
}
destructor
(
)
{
this
.
disable
(
)
;
}
async
enable
(
)
{
if
(
!
this
.
enabled
)
{
this
.
enabled
=
true
;
}
}
describeNode
(
options
=
{
}
)
{
const
{
objectId
}
=
options
;
if
(
!
[
"
string
"
]
.
includes
(
typeof
objectId
)
)
{
throw
new
TypeError
(
"
objectId
:
string
value
expected
"
)
;
}
const
Runtime
=
this
.
session
.
domains
.
get
(
"
Runtime
"
)
;
const
debuggerObj
=
Runtime
.
_getRemoteObject
(
objectId
)
;
if
(
!
debuggerObj
)
{
throw
new
Error
(
"
Could
not
find
object
with
given
id
"
)
;
}
if
(
typeof
debuggerObj
.
nodeId
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Object
id
doesn
'
t
reference
a
Node
"
)
;
}
const
unsafeObj
=
debuggerObj
.
unsafeDereference
(
)
;
const
attributes
=
[
]
;
if
(
unsafeObj
.
attributes
)
{
for
(
const
attribute
of
unsafeObj
.
attributes
)
{
attributes
.
push
(
attribute
.
name
attribute
.
value
)
;
}
}
let
context
=
this
.
docShell
.
browsingContext
;
if
(
HTMLIFrameElement
.
isInstance
(
unsafeObj
)
)
{
context
=
unsafeObj
.
contentWindow
.
docShell
.
browsingContext
;
}
const
node
=
{
nodeId
:
debuggerObj
.
nodeId
backendNodeId
:
debuggerObj
.
nodeId
nodeType
:
unsafeObj
.
nodeType
nodeName
:
unsafeObj
.
nodeName
localName
:
unsafeObj
.
localName
nodeValue
:
unsafeObj
.
nodeValue
?
unsafeObj
.
nodeValue
.
toString
(
)
:
"
"
childNodeCount
:
unsafeObj
.
childElementCount
attributes
:
attributes
.
length
?
attributes
:
undefined
frameId
:
context
.
id
.
toString
(
)
}
;
return
{
node
}
;
}
disable
(
)
{
if
(
this
.
enabled
)
{
this
.
enabled
=
false
;
}
}
getContentQuads
(
options
=
{
}
)
{
const
{
objectId
}
=
options
;
const
Runtime
=
this
.
session
.
domains
.
get
(
"
Runtime
"
)
;
const
debuggerObj
=
Runtime
.
_getRemoteObject
(
objectId
)
;
if
(
!
debuggerObj
)
{
throw
new
Error
(
Cannot
find
object
with
id
:
{
objectId
}
)
;
}
const
unsafeObject
=
debuggerObj
.
unsafeDereference
(
)
;
if
(
!
unsafeObject
.
getBoxQuads
)
{
throw
new
Error
(
"
RemoteObject
is
not
a
node
"
)
;
}
let
quads
=
unsafeObject
.
getBoxQuads
(
{
relativeTo
:
this
.
content
.
document
}
)
;
quads
=
quads
.
map
(
quad
=
>
{
return
[
quad
.
p1
.
x
quad
.
p1
.
y
quad
.
p2
.
x
quad
.
p2
.
y
quad
.
p3
.
x
quad
.
p3
.
y
quad
.
p4
.
x
quad
.
p4
.
y
]
.
map
(
Math
.
round
)
;
}
)
;
return
{
quads
}
;
}
getBoxModel
(
options
=
{
}
)
{
const
{
objectId
}
=
options
;
const
Runtime
=
this
.
session
.
domains
.
get
(
"
Runtime
"
)
;
const
debuggerObj
=
Runtime
.
_getRemoteObject
(
objectId
)
;
if
(
!
debuggerObj
)
{
throw
new
Error
(
Cannot
find
object
with
id
:
{
objectId
}
)
;
}
const
unsafeObject
=
debuggerObj
.
unsafeDereference
(
)
;
const
bounding
=
unsafeObject
.
getBoundingClientRect
(
)
;
const
model
=
{
width
:
Math
.
round
(
bounding
.
width
)
height
:
Math
.
round
(
bounding
.
height
)
}
;
for
(
const
box
of
[
"
content
"
"
padding
"
"
border
"
"
margin
"
]
)
{
const
quads
=
unsafeObject
.
getBoxQuads
(
{
box
relativeTo
:
this
.
content
.
document
}
)
;
let
bounding
=
{
p1
:
{
x
:
Infinity
y
:
Infinity
}
p2
:
{
x
:
-
Infinity
y
:
Infinity
}
p3
:
{
x
:
-
Infinity
y
:
-
Infinity
}
p4
:
{
x
:
Infinity
y
:
-
Infinity
}
}
;
quads
.
forEach
(
quad
=
>
{
bounding
=
{
p1
:
{
x
:
Math
.
min
(
bounding
.
p1
.
x
quad
.
p1
.
x
)
y
:
Math
.
min
(
bounding
.
p1
.
y
quad
.
p1
.
y
)
}
p2
:
{
x
:
Math
.
max
(
bounding
.
p2
.
x
quad
.
p2
.
x
)
y
:
Math
.
min
(
bounding
.
p2
.
y
quad
.
p2
.
y
)
}
p3
:
{
x
:
Math
.
max
(
bounding
.
p3
.
x
quad
.
p3
.
x
)
y
:
Math
.
max
(
bounding
.
p3
.
y
quad
.
p3
.
y
)
}
p4
:
{
x
:
Math
.
min
(
bounding
.
p4
.
x
quad
.
p4
.
x
)
y
:
Math
.
max
(
bounding
.
p4
.
y
quad
.
p4
.
y
)
}
}
;
}
)
;
model
[
box
]
=
[
bounding
.
p1
.
x
bounding
.
p1
.
y
bounding
.
p2
.
x
bounding
.
p2
.
y
bounding
.
p3
.
x
bounding
.
p3
.
y
bounding
.
p4
.
x
bounding
.
p4
.
y
]
.
map
(
Math
.
round
)
;
}
return
{
model
}
;
}
resolveNode
(
options
=
{
}
)
{
const
{
backendNodeId
executionContextId
}
=
options
;
if
(
!
[
"
string
"
]
.
includes
(
typeof
backendNodeId
)
)
{
throw
new
TypeError
(
"
backendNodeId
:
string
value
expected
"
)
;
}
if
(
!
[
"
undefined
"
"
number
"
]
.
includes
(
typeof
executionContextId
)
)
{
throw
new
TypeError
(
"
executionContextId
:
integer
value
expected
"
)
;
}
const
Runtime
=
this
.
session
.
domains
.
get
(
"
Runtime
"
)
;
const
debuggerObj
=
Runtime
.
_getRemoteObjectByNodeId
(
backendNodeId
)
;
if
(
!
debuggerObj
)
{
throw
new
Error
(
No
node
with
given
id
found
)
;
}
let
context
;
if
(
typeof
executionContextId
!
=
"
undefined
"
)
{
context
=
Runtime
.
contexts
.
get
(
executionContextId
)
;
if
(
!
context
)
{
throw
new
Error
(
Node
with
given
id
does
not
belong
to
the
document
)
;
}
}
else
{
context
=
Runtime
.
_getDefaultContextForWindow
(
)
;
}
Runtime
.
_setRemoteObject
(
debuggerObj
context
)
;
return
{
object
:
Runtime
.
_serializeRemoteObject
(
debuggerObj
context
.
id
)
}
;
}
}
