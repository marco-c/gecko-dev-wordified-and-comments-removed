"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExecutionContext
"
]
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
UUIDGen
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
const
TYPED_ARRAY_CLASSES
=
[
"
Uint8Array
"
"
Uint8ClampedArray
"
"
Uint16Array
"
"
Uint32Array
"
"
Int8Array
"
"
Int16Array
"
"
Int32Array
"
"
Float32Array
"
"
Float64Array
"
]
;
function
uuid
(
)
{
return
UUIDGen
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
}
class
ExecutionContext
{
constructor
(
dbg
debuggee
id
isDefault
)
{
this
.
_debugger
=
dbg
;
this
.
_debuggee
=
this
.
_debugger
.
addDebuggee
(
debuggee
)
;
this
.
window
=
debuggee
;
this
.
windowId
=
this
.
window
.
windowGlobalChild
.
innerWindowId
;
this
.
id
=
id
;
this
.
frameId
=
this
.
window
.
browsingContext
.
id
.
toString
(
)
;
this
.
isDefault
=
isDefault
;
this
.
_remoteObjects
=
new
Map
(
)
;
}
destructor
(
)
{
this
.
_debugger
.
removeDebuggee
(
this
.
_debuggee
)
;
}
get
browsingContext
(
)
{
return
this
.
window
.
browsingContext
;
}
hasRemoteObject
(
objectId
)
{
return
this
.
_remoteObjects
.
has
(
objectId
)
;
}
getRemoteObject
(
objectId
)
{
return
this
.
_remoteObjects
.
get
(
objectId
)
;
}
getRemoteObjectByNodeId
(
nodeId
)
{
for
(
const
value
of
this
.
_remoteObjects
.
values
(
)
)
{
if
(
value
.
nodeId
=
=
nodeId
)
{
return
value
;
}
}
return
null
;
}
releaseObject
(
objectId
)
{
return
this
.
_remoteObjects
.
delete
(
objectId
)
;
}
setRemoteObject
(
debuggerObj
)
{
const
objectId
=
uuid
(
)
;
if
(
typeof
debuggerObj
=
=
"
object
"
)
{
debuggerObj
.
objectId
=
objectId
;
}
if
(
debuggerObj
instanceof
Debugger
.
Object
&
&
Node
.
isInstance
(
debuggerObj
.
unsafeDereference
(
)
)
)
{
debuggerObj
.
nodeId
=
uuid
(
)
;
debuggerObj
.
backendNodeId
=
debuggerObj
.
nodeId
;
}
this
.
_remoteObjects
.
set
(
objectId
debuggerObj
)
;
return
objectId
;
}
async
evaluate
(
expression
awaitPromise
returnByValue
)
{
let
rv
=
this
.
_debuggee
.
executeInGlobal
(
expression
)
;
if
(
!
rv
)
{
return
{
exceptionDetails
:
{
text
:
"
Evaluation
terminated
!
"
}
}
;
}
if
(
rv
.
throw
)
{
return
this
.
_returnError
(
rv
.
throw
)
;
}
let
result
=
rv
.
return
;
if
(
result
&
&
result
.
isPromise
&
&
awaitPromise
)
{
if
(
result
.
promiseState
=
=
=
"
fulfilled
"
)
{
result
=
result
.
promiseValue
;
}
else
if
(
result
.
promiseState
=
=
=
"
rejected
"
)
{
return
this
.
_returnError
(
result
.
promiseReason
)
;
}
else
{
try
{
const
promiseResult
=
await
result
.
unsafeDereference
(
)
;
result
=
this
.
_debuggee
.
makeDebuggeeValue
(
promiseResult
)
;
}
catch
(
e
)
{
return
this
.
_returnError
(
e
)
;
}
}
}
if
(
returnByValue
)
{
result
=
this
.
_toRemoteObjectByValue
(
result
)
;
}
else
{
result
=
this
.
_toRemoteObject
(
result
)
;
}
return
{
result
}
;
}
_returnError
(
exception
)
{
if
(
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
exception
instanceof
Error
"
{
exception
}
)
.
return
)
{
const
text
=
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
exception
.
message
"
{
exception
}
)
.
return
;
return
{
exceptionDetails
:
{
text
}
}
;
}
return
{
exceptionDetails
:
{
exception
:
this
.
_toRemoteObject
(
exception
)
}
}
;
}
async
callFunctionOn
(
functionDeclaration
callArguments
=
[
]
returnByValue
=
false
awaitPromise
=
false
objectId
=
null
)
{
let
thisArg
=
null
;
if
(
objectId
)
{
thisArg
=
this
.
getRemoteObject
(
objectId
)
;
if
(
!
thisArg
)
{
throw
new
Error
(
Unable
to
get
target
object
with
id
:
{
objectId
}
)
;
}
}
const
fun
=
this
.
_debuggee
.
executeInGlobal
(
"
(
"
+
functionDeclaration
+
"
)
"
)
;
if
(
!
fun
)
{
return
{
exceptionDetails
:
{
text
:
"
Evaluation
terminated
!
"
}
}
;
}
if
(
fun
.
throw
)
{
return
this
.
_returnError
(
fun
.
throw
)
;
}
const
args
=
callArguments
.
map
(
arg
=
>
this
.
_fromCallArgument
(
arg
)
)
;
const
rv
=
fun
.
return
.
apply
(
thisArg
args
)
;
if
(
rv
.
throw
)
{
return
this
.
_returnError
(
rv
.
throw
)
;
}
let
result
=
rv
.
return
;
if
(
result
&
&
result
.
isPromise
&
&
awaitPromise
)
{
if
(
result
.
promiseState
=
=
=
"
fulfilled
"
)
{
result
=
result
.
promiseValue
;
}
else
if
(
result
.
promiseState
=
=
=
"
rejected
"
)
{
return
this
.
_returnError
(
result
.
promiseReason
)
;
}
else
{
try
{
const
promiseResult
=
await
result
.
unsafeDereference
(
)
;
result
=
this
.
_debuggee
.
makeDebuggeeValue
(
promiseResult
)
;
}
catch
(
e
)
{
return
this
.
_returnError
(
e
)
;
}
}
}
if
(
returnByValue
)
{
result
=
this
.
_toRemoteObjectByValue
(
result
)
;
}
else
{
result
=
this
.
_toRemoteObject
(
result
)
;
}
return
{
result
}
;
}
getProperties
(
{
objectId
ownProperties
}
)
{
let
debuggerObj
=
this
.
getRemoteObject
(
objectId
)
;
if
(
!
debuggerObj
)
{
throw
new
Error
(
"
Could
not
find
object
with
given
id
"
)
;
}
const
result
=
[
]
;
const
serializeObject
=
(
debuggerObj
isOwn
)
=
>
{
for
(
const
propertyName
of
debuggerObj
.
getOwnPropertyNames
(
)
)
{
const
descriptor
=
debuggerObj
.
getOwnPropertyDescriptor
(
propertyName
)
;
result
.
push
(
{
name
:
propertyName
configurable
:
descriptor
.
configurable
enumerable
:
descriptor
.
enumerable
writable
:
descriptor
.
writable
value
:
this
.
_toRemoteObject
(
descriptor
.
value
)
get
:
descriptor
.
get
?
this
.
_toRemoteObject
(
descriptor
.
get
)
:
undefined
set
:
descriptor
.
set
?
this
.
_toRemoteObject
(
descriptor
.
set
)
:
undefined
isOwn
}
)
;
}
}
;
serializeObject
(
debuggerObj
true
)
;
if
(
!
ownProperties
)
{
while
(
true
)
{
debuggerObj
=
debuggerObj
.
proto
;
if
(
!
debuggerObj
)
{
break
;
}
serializeObject
(
debuggerObj
false
)
;
}
}
return
{
result
}
;
}
_fromCallArgument
(
arg
)
{
if
(
arg
.
objectId
)
{
if
(
!
this
.
hasRemoteObject
(
arg
.
objectId
)
)
{
throw
new
Error
(
"
Could
not
find
object
with
given
id
"
)
;
}
return
this
.
getRemoteObject
(
arg
.
objectId
)
;
}
if
(
arg
.
unserializableValue
)
{
switch
(
arg
.
unserializableValue
)
{
case
"
-
0
"
:
return
-
0
;
case
"
Infinity
"
:
return
Infinity
;
case
"
-
Infinity
"
:
return
-
Infinity
;
case
"
NaN
"
:
return
NaN
;
default
:
if
(
/
^
\
d
+
n
/
.
test
(
arg
.
unserializableValue
)
)
{
return
BigInt
(
arg
.
unserializableValue
.
slice
(
0
-
1
)
)
;
}
throw
new
Error
(
"
Couldn
'
t
parse
value
object
in
call
argument
"
)
;
}
}
return
this
.
_deserialize
(
arg
.
value
)
;
}
_deserialize
(
obj
)
{
if
(
typeof
obj
!
=
=
"
object
"
)
{
return
obj
;
}
const
result
=
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
JSON
.
parse
(
obj
)
"
{
obj
:
JSON
.
stringify
(
obj
)
}
)
;
if
(
result
.
throw
)
{
throw
new
Error
(
"
Unable
to
deserialize
object
"
)
;
}
return
result
.
return
;
}
_toRemoteObject
(
debuggerObj
)
{
const
result
=
{
}
;
if
(
debuggerObj
instanceof
Debugger
.
Object
)
{
const
rawObj
=
debuggerObj
.
unsafeDereference
(
)
;
result
.
objectId
=
this
.
setRemoteObject
(
debuggerObj
)
;
result
.
type
=
typeof
rawObj
;
const
cls
=
debuggerObj
.
class
;
if
(
debuggerObj
.
isProxy
)
{
result
.
subtype
=
"
proxy
"
;
}
else
if
(
cls
=
=
"
Array
"
)
{
result
.
subtype
=
"
array
"
;
}
else
if
(
cls
=
=
"
RegExp
"
)
{
result
.
subtype
=
"
regexp
"
;
}
else
if
(
cls
=
=
"
Date
"
)
{
result
.
subtype
=
"
date
"
;
}
else
if
(
cls
=
=
"
Map
"
)
{
result
.
subtype
=
"
map
"
;
}
else
if
(
cls
=
=
"
Set
"
)
{
result
.
subtype
=
"
set
"
;
}
else
if
(
cls
=
=
"
WeakMap
"
)
{
result
.
subtype
=
"
weakmap
"
;
}
else
if
(
cls
=
=
"
WeakSet
"
)
{
result
.
subtype
=
"
weakset
"
;
}
else
if
(
cls
=
=
"
Error
"
)
{
result
.
subtype
=
"
error
"
;
}
else
if
(
cls
=
=
"
Promise
"
)
{
result
.
subtype
=
"
promise
"
;
}
else
if
(
TYPED_ARRAY_CLASSES
.
includes
(
cls
)
)
{
result
.
subtype
=
"
typedarray
"
;
}
else
if
(
Node
.
isInstance
(
rawObj
)
)
{
result
.
subtype
=
"
node
"
;
result
.
className
=
ChromeUtils
.
getClassName
(
rawObj
)
;
result
.
description
=
rawObj
.
localName
|
|
rawObj
.
nodeName
;
if
(
rawObj
.
id
)
{
result
.
description
+
=
#
{
rawObj
.
id
}
;
}
}
return
result
;
}
result
.
type
=
typeof
debuggerObj
;
if
(
result
.
type
=
=
"
symbol
"
)
{
result
.
description
=
debuggerObj
.
toString
(
)
;
result
.
objectId
=
this
.
setRemoteObject
(
debuggerObj
)
;
return
result
;
}
if
(
Object
.
is
(
debuggerObj
NaN
)
)
{
result
.
unserializableValue
=
"
NaN
"
;
}
else
if
(
Object
.
is
(
debuggerObj
-
0
)
)
{
result
.
unserializableValue
=
"
-
0
"
;
}
else
if
(
Object
.
is
(
debuggerObj
Infinity
)
)
{
result
.
unserializableValue
=
"
Infinity
"
;
}
else
if
(
Object
.
is
(
debuggerObj
-
Infinity
)
)
{
result
.
unserializableValue
=
"
-
Infinity
"
;
}
else
if
(
result
.
type
=
=
"
bigint
"
)
{
result
.
unserializableValue
=
{
debuggerObj
}
n
;
}
if
(
result
.
unserializableValue
)
{
result
.
description
=
result
.
unserializableValue
;
return
result
;
}
result
.
value
=
debuggerObj
;
if
(
debuggerObj
=
=
=
null
)
{
result
.
subtype
=
"
null
"
;
}
return
result
;
}
_toRemoteObjectByValue
(
debuggerObj
)
{
const
type
=
typeof
debuggerObj
;
if
(
type
=
=
"
undefined
"
)
{
return
{
type
}
;
}
let
unserializableValue
;
if
(
Object
.
is
(
debuggerObj
-
0
)
)
{
unserializableValue
=
"
-
0
"
;
}
else
if
(
Object
.
is
(
debuggerObj
NaN
)
)
{
unserializableValue
=
"
NaN
"
;
}
else
if
(
Object
.
is
(
debuggerObj
Infinity
)
)
{
unserializableValue
=
"
Infinity
"
;
}
else
if
(
Object
.
is
(
debuggerObj
-
Infinity
)
)
{
unserializableValue
=
"
-
Infinity
"
;
}
else
if
(
typeof
debuggerObj
=
=
"
bigint
"
)
{
unserializableValue
=
{
debuggerObj
}
n
;
}
if
(
unserializableValue
)
{
return
{
type
unserializableValue
description
:
unserializableValue
}
;
}
const
value
=
this
.
_serialize
(
debuggerObj
)
;
return
{
type
:
typeof
value
value
description
:
value
!
=
null
?
value
.
toString
(
)
:
value
}
;
}
_serialize
(
debuggerObj
)
{
const
result
=
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
JSON
.
stringify
(
e
)
"
{
e
:
debuggerObj
}
)
;
if
(
result
.
throw
)
{
throw
new
Error
(
"
Object
is
not
serializable
"
)
;
}
return
JSON
.
parse
(
result
.
return
)
;
}
}
