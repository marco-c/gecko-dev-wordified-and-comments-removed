"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DomainCache
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
Domain
:
"
chrome
:
/
/
remote
/
content
/
cdp
/
domains
/
Domain
.
jsm
"
UnknownMethodError
:
"
chrome
:
/
/
remote
/
content
/
cdp
/
Error
.
jsm
"
}
)
;
class
DomainCache
{
constructor
(
session
modules
)
{
this
.
session
=
session
;
this
.
modules
=
modules
;
this
.
instances
=
new
Map
(
)
;
}
domainSupportsMethod
(
name
method
)
{
const
domain
=
this
.
modules
[
name
]
;
if
(
domain
)
{
return
domain
.
implements
(
method
)
;
}
return
false
;
}
get
(
name
)
{
let
inst
=
this
.
instances
.
get
(
name
)
;
if
(
!
inst
)
{
const
Cls
=
this
.
modules
[
name
]
;
if
(
!
Cls
)
{
throw
new
lazy
.
UnknownMethodError
(
name
)
;
}
if
(
!
isConstructor
(
Cls
)
)
{
throw
new
TypeError
(
"
Domain
cannot
be
constructed
"
)
;
}
inst
=
new
Cls
(
this
.
session
)
;
if
(
!
(
inst
instanceof
lazy
.
Domain
)
)
{
throw
new
TypeError
(
"
Instance
not
a
domain
"
)
;
}
inst
.
addEventListener
(
this
.
session
)
;
this
.
instances
.
set
(
name
inst
)
;
}
return
inst
;
}
has
(
name
)
{
return
name
in
this
.
modules
;
}
get
size
(
)
{
return
this
.
instances
.
size
;
}
execute
(
domain
command
params
)
{
if
(
!
this
.
domainSupportsMethod
(
domain
command
)
)
{
throw
new
lazy
.
UnknownMethodError
(
domain
command
)
;
}
const
inst
=
this
.
get
(
domain
)
;
return
inst
[
command
]
(
params
)
;
}
clear
(
)
{
for
(
const
inst
of
this
.
instances
.
values
(
)
)
{
inst
.
destructor
(
)
;
}
this
.
instances
.
clear
(
)
;
}
toString
(
)
{
return
[
object
DomainCache
{
this
.
size
}
]
;
}
}
function
isConstructor
(
obj
)
{
return
!
!
obj
.
prototype
&
&
!
!
obj
.
prototype
.
constructor
.
name
;
}
