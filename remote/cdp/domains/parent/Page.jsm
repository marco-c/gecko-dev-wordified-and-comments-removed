"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Page
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Domain
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
cdp
/
domains
/
Domain
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
clearInterval
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
SessionStore
:
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
setInterval
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
DialogHandler
:
"
chrome
:
/
/
remote
/
content
/
cdp
/
domains
/
parent
/
page
/
DialogHandler
.
jsm
"
PollPromise
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Sync
.
jsm
"
streamRegistry
:
"
chrome
:
/
/
remote
/
content
/
cdp
/
domains
/
parent
/
IO
.
jsm
"
TabManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
UnsupportedError
:
"
chrome
:
/
/
remote
/
content
/
cdp
/
Error
.
jsm
"
windowManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
WindowManager
.
jsm
"
}
)
;
const
MAX_CANVAS_DIMENSION
=
32767
;
const
MAX_CANVAS_AREA
=
472907776
;
const
PRINT_MAX_SCALE_VALUE
=
2
.
0
;
const
PRINT_MIN_SCALE_VALUE
=
0
.
1
;
const
PDF_TRANSFER_MODES
=
{
base64
:
"
ReturnAsBase64
"
stream
:
"
ReturnAsStream
"
}
;
const
TIMEOUT_SET_HISTORY_INDEX
=
1000
;
class
Page
extends
Domain
{
constructor
(
session
)
{
super
(
session
)
;
this
.
_onDialogLoaded
=
this
.
_onDialogLoaded
.
bind
(
this
)
;
this
.
_onRequest
=
this
.
_onRequest
.
bind
(
this
)
;
this
.
enabled
=
false
;
this
.
session
.
networkObserver
.
startTrackingBrowserNetwork
(
this
.
session
.
target
.
browser
)
;
this
.
session
.
networkObserver
.
on
(
"
request
"
this
.
_onRequest
)
;
}
destructor
(
)
{
this
.
_isDestroyed
=
false
;
this
.
disable
(
)
;
this
.
session
.
networkObserver
.
off
(
"
request
"
this
.
_onRequest
)
;
this
.
session
.
networkObserver
.
stopTrackingBrowserNetwork
(
this
.
session
.
target
.
browser
)
;
super
.
destructor
(
)
;
}
async
navigate
(
options
=
{
}
)
{
const
{
url
frameId
referrer
transitionType
}
=
options
;
if
(
typeof
url
!
=
"
string
"
)
{
throw
new
TypeError
(
"
url
:
string
value
expected
"
)
;
}
let
validURL
;
try
{
validURL
=
Services
.
io
.
newURI
(
url
)
;
}
catch
(
e
)
{
throw
new
Error
(
"
Error
:
Cannot
navigate
to
invalid
URL
"
)
;
}
const
topFrameId
=
this
.
session
.
browsingContext
.
id
.
toString
(
)
;
if
(
frameId
&
&
frameId
!
=
topFrameId
)
{
throw
new
lazy
.
UnsupportedError
(
"
frameId
not
supported
"
)
;
}
const
hitsNetwork
=
[
"
https
"
"
http
"
]
.
includes
(
validURL
.
scheme
)
;
let
networkLessLoaderId
;
if
(
!
hitsNetwork
)
{
const
uuid
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
;
networkLessLoaderId
=
uuid
.
substring
(
1
uuid
.
length
-
1
)
;
await
this
.
executeInChild
(
"
_updateLoaderId
"
{
frameId
:
this
.
session
.
browsingContext
.
id
loaderId
:
networkLessLoaderId
}
)
;
}
const
currentURI
=
this
.
session
.
browsingContext
.
currentURI
;
const
isSameDocumentNavigation
=
hitsNetwork
&
&
[
"
https
"
"
http
"
]
.
includes
(
currentURI
.
scheme
)
&
&
currentURI
.
host
=
=
=
validURL
.
host
&
&
currentURI
.
query
=
=
=
validURL
.
query
&
&
!
!
validURL
.
ref
;
const
requestDone
=
new
Promise
(
resolve
=
>
{
if
(
isSameDocumentNavigation
)
{
resolve
(
{
}
)
;
return
;
}
if
(
!
hitsNetwork
)
{
resolve
(
{
navigationRequestId
:
networkLessLoaderId
}
)
;
return
;
}
let
navigationRequestId
redirectedRequestId
;
const
_onNavigationRequest
=
function
(
_type
_ch
data
)
{
const
{
url
:
requestURL
requestId
redirectedFrom
=
null
isNavigationRequest
}
=
data
;
if
(
!
isNavigationRequest
)
{
return
;
}
if
(
validURL
.
spec
=
=
=
requestURL
)
{
navigationRequestId
=
redirectedRequestId
=
requestId
;
}
else
if
(
redirectedFrom
=
=
=
redirectedRequestId
)
{
redirectedRequestId
=
requestId
;
}
}
;
const
_onRequestFinished
=
function
(
_type
_ch
data
)
{
const
{
requestId
errorCode
}
=
data
;
if
(
redirectedRequestId
!
=
=
requestId
|
|
errorCode
=
=
"
NS_BINDING_REDIRECTED
"
)
{
return
;
}
this
.
session
.
networkObserver
.
off
(
"
request
"
_onNavigationRequest
)
;
this
.
session
.
networkObserver
.
off
(
"
requestfinished
"
_onRequestFinished
)
;
resolve
(
{
errorCode
navigationRequestId
}
)
;
}
.
bind
(
this
)
;
this
.
session
.
networkObserver
.
on
(
"
request
"
_onNavigationRequest
)
;
this
.
session
.
networkObserver
.
on
(
"
requestfinished
"
_onRequestFinished
)
;
}
)
;
const
opts
=
{
loadFlags
:
transitionToLoadFlag
(
transitionType
)
referrerURI
:
referrer
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
;
this
.
session
.
browsingContext
.
loadURI
(
url
opts
)
;
const
{
navigationRequestId
:
loaderId
errorCode
}
=
await
requestDone
;
const
result
=
{
frameId
:
topFrameId
loaderId
}
;
if
(
errorCode
)
{
result
.
errorText
=
errorCode
;
}
return
result
;
}
async
captureScreenshot
(
options
=
{
}
)
{
const
{
clip
format
=
"
png
"
quality
=
80
}
=
options
;
if
(
options
.
fromSurface
)
{
throw
new
lazy
.
UnsupportedError
(
"
fromSurface
not
supported
"
)
;
}
let
rect
;
let
scale
=
await
this
.
executeInChild
(
"
_devicePixelRatio
"
)
;
if
(
clip
)
{
for
(
const
prop
of
[
"
x
"
"
y
"
"
width
"
"
height
"
"
scale
"
]
)
{
if
(
clip
[
prop
]
=
=
undefined
)
{
throw
new
TypeError
(
clip
.
{
prop
}
:
double
value
expected
)
;
}
}
const
contentRect
=
await
this
.
executeInChild
(
"
_contentRect
"
)
;
if
(
clip
.
scale
<
=
0
)
{
Object
.
assign
(
clip
{
x
:
0
y
:
0
width
:
contentRect
.
width
height
:
contentRect
.
height
scale
:
1
}
)
;
}
else
{
if
(
clip
.
x
<
0
|
|
clip
.
x
>
contentRect
.
width
-
1
)
{
clip
.
x
=
0
;
}
if
(
clip
.
y
<
0
|
|
clip
.
y
>
contentRect
.
height
-
1
)
{
clip
.
y
=
0
;
}
if
(
clip
.
width
<
=
0
)
{
clip
.
width
=
contentRect
.
width
;
}
if
(
clip
.
height
<
=
0
)
{
clip
.
height
=
contentRect
.
height
;
}
}
rect
=
new
DOMRect
(
clip
.
x
clip
.
y
clip
.
width
clip
.
height
)
;
scale
*
=
clip
.
scale
;
}
else
{
const
{
pageX
pageY
clientWidth
clientHeight
}
=
await
this
.
executeInChild
(
"
_layoutViewport
"
)
;
rect
=
new
DOMRect
(
pageX
pageY
clientWidth
clientHeight
)
;
}
let
canvasWidth
=
rect
.
width
*
scale
;
let
canvasHeight
=
rect
.
height
*
scale
;
if
(
canvasWidth
>
MAX_CANVAS_DIMENSION
)
{
rect
.
width
=
Math
.
floor
(
MAX_CANVAS_DIMENSION
/
scale
)
;
canvasWidth
=
rect
.
width
*
scale
;
}
if
(
canvasHeight
>
MAX_CANVAS_DIMENSION
)
{
rect
.
height
=
Math
.
floor
(
MAX_CANVAS_DIMENSION
/
scale
)
;
canvasHeight
=
rect
.
height
*
scale
;
}
if
(
canvasWidth
*
canvasHeight
>
MAX_CANVAS_AREA
)
{
rect
.
height
=
Math
.
floor
(
MAX_CANVAS_AREA
/
(
canvasWidth
*
scale
)
)
;
canvasHeight
=
rect
.
height
*
scale
;
}
const
{
browsingContext
window
}
=
this
.
session
.
target
;
const
snapshot
=
await
browsingContext
.
currentWindowGlobal
.
drawSnapshot
(
rect
scale
"
rgb
(
255
255
255
)
"
)
;
const
canvas
=
window
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
canvasWidth
;
canvas
.
height
=
canvasHeight
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
snapshot
0
0
)
;
snapshot
.
close
(
)
;
const
url
=
canvas
.
toDataURL
(
image
/
{
format
}
quality
/
100
)
;
if
(
!
url
.
startsWith
(
data
:
image
/
{
format
}
)
)
{
throw
new
lazy
.
UnsupportedError
(
Unsupported
MIME
type
:
image
/
{
format
}
)
;
}
const
data
=
url
.
substring
(
url
.
indexOf
(
"
"
)
+
1
)
;
return
{
data
}
;
}
async
enable
(
)
{
if
(
this
.
enabled
)
{
return
;
}
this
.
enabled
=
true
;
const
{
browser
}
=
this
.
session
.
target
;
this
.
_dialogHandler
=
new
lazy
.
DialogHandler
(
browser
)
;
this
.
_dialogHandler
.
on
(
"
dialog
-
loaded
"
this
.
_onDialogLoaded
)
;
await
this
.
executeInChild
(
"
enable
"
)
;
}
async
disable
(
)
{
if
(
!
this
.
enabled
)
{
return
;
}
this
.
_dialogHandler
.
destructor
(
)
;
this
.
_dialogHandler
=
null
;
this
.
enabled
=
false
;
if
(
!
this
.
_isDestroyed
)
{
await
this
.
executeInChild
(
"
disable
"
)
;
}
}
async
bringToFront
(
)
{
const
{
tab
window
}
=
this
.
session
.
target
;
await
lazy
.
windowManager
.
focusWindow
(
window
)
;
await
lazy
.
TabManager
.
selectTab
(
tab
)
;
}
async
getLayoutMetrics
(
)
{
return
{
layoutViewport
:
await
this
.
executeInChild
(
"
_layoutViewport
"
)
contentSize
:
await
this
.
executeInChild
(
"
_contentRect
"
)
}
;
}
async
getNavigationHistory
(
)
{
const
{
window
}
=
this
.
session
.
target
;
return
new
Promise
(
resolve
=
>
{
function
updateSessionHistory
(
sessionHistory
)
{
const
entries
=
sessionHistory
.
entries
.
map
(
entry
=
>
{
return
{
id
:
entry
.
ID
url
:
entry
.
url
userTypedURL
:
entry
.
originalURI
|
|
entry
.
url
title
:
entry
.
title
transitionType
:
null
}
;
}
)
;
resolve
(
{
currentIndex
:
sessionHistory
.
index
entries
}
)
;
}
lazy
.
SessionStore
.
getSessionHistory
(
window
.
gBrowser
.
selectedTab
updateSessionHistory
)
;
}
)
;
}
async
handleJavaScriptDialog
(
options
=
{
}
)
{
const
{
accept
promptText
}
=
options
;
if
(
!
this
.
enabled
)
{
throw
new
Error
(
"
Page
domain
is
not
enabled
"
)
;
}
await
this
.
_dialogHandler
.
handleJavaScriptDialog
(
{
accept
promptText
}
)
;
}
async
navigateToHistoryEntry
(
options
=
{
}
)
{
const
{
entryId
}
=
options
;
const
index
=
await
this
.
_getIndexForHistoryEntryId
(
entryId
)
;
if
(
index
=
=
null
)
{
throw
new
Error
(
"
No
entry
with
passed
id
"
)
;
}
const
{
window
}
=
this
.
session
.
target
;
window
.
gBrowser
.
gotoIndex
(
index
)
;
await
lazy
.
PollPromise
(
async
(
resolve
reject
)
=
>
{
const
currentIndex
=
await
this
.
_getCurrentHistoryIndex
(
)
;
if
(
currentIndex
=
=
index
)
{
resolve
(
)
;
}
else
{
reject
(
)
;
}
}
{
timeout
:
TIMEOUT_SET_HISTORY_INDEX
}
)
;
}
async
printToPDF
(
options
=
{
}
)
{
const
{
displayHeaderFooter
=
false
landscape
=
false
marginBottom
=
0
.
39
marginLeft
=
0
.
39
marginRight
=
0
.
39
marginTop
=
0
.
39
paperHeight
=
11
.
0
paperWidth
=
8
.
5
preferCSSPageSize
=
false
printBackground
=
false
scale
=
1
.
0
transferMode
=
PDF_TRANSFER_MODES
.
base64
}
=
options
;
if
(
marginBottom
<
0
)
{
throw
new
TypeError
(
"
marginBottom
is
negative
"
)
;
}
if
(
marginLeft
<
0
)
{
throw
new
TypeError
(
"
marginLeft
is
negative
"
)
;
}
if
(
marginRight
<
0
)
{
throw
new
TypeError
(
"
marginRight
is
negative
"
)
;
}
if
(
marginTop
<
0
)
{
throw
new
TypeError
(
"
marginTop
is
negative
"
)
;
}
if
(
scale
<
PRINT_MIN_SCALE_VALUE
|
|
scale
>
PRINT_MAX_SCALE_VALUE
)
{
throw
new
TypeError
(
"
scale
is
outside
[
0
.
1
-
2
]
range
"
)
;
}
if
(
paperHeight
<
=
0
)
{
throw
new
TypeError
(
"
paperHeight
is
zero
or
negative
"
)
;
}
if
(
paperWidth
<
=
0
)
{
throw
new
TypeError
(
"
paperWidth
is
zero
or
negative
"
)
;
}
const
basePath
=
lazy
.
OS
.
Path
.
join
(
lazy
.
OS
.
Constants
.
Path
.
tmpDir
"
remote
-
agent
.
pdf
"
)
;
const
{
file
path
:
filePath
}
=
await
lazy
.
OS
.
File
.
openUnique
(
basePath
)
;
await
file
.
close
(
)
;
const
psService
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
const
printSettings
=
psService
.
createNewPrintSettings
(
)
;
printSettings
.
isInitializedFromPrinter
=
true
;
printSettings
.
isInitializedFromPrefs
=
true
;
printSettings
.
outputFormat
=
Ci
.
nsIPrintSettings
.
kOutputFormatPDF
;
printSettings
.
printerName
=
"
"
;
printSettings
.
printSilent
=
true
;
printSettings
.
outputDestination
=
Ci
.
nsIPrintSettings
.
kOutputDestinationFile
;
printSettings
.
toFileName
=
filePath
;
printSettings
.
paperSizeUnit
=
Ci
.
nsIPrintSettings
.
kPaperSizeInches
;
printSettings
.
paperWidth
=
paperWidth
;
printSettings
.
paperHeight
=
paperHeight
;
printSettings
.
marginBottom
=
marginBottom
;
printSettings
.
marginLeft
=
marginLeft
;
printSettings
.
marginRight
=
marginRight
;
printSettings
.
marginTop
=
marginTop
;
printSettings
.
printBGColors
=
printBackground
;
printSettings
.
printBGImages
=
printBackground
;
printSettings
.
scaling
=
scale
;
printSettings
.
shrinkToFit
=
preferCSSPageSize
;
if
(
!
displayHeaderFooter
)
{
printSettings
.
headerStrCenter
=
"
"
;
printSettings
.
headerStrLeft
=
"
"
;
printSettings
.
headerStrRight
=
"
"
;
printSettings
.
footerStrCenter
=
"
"
;
printSettings
.
footerStrLeft
=
"
"
;
printSettings
.
footerStrRight
=
"
"
;
}
if
(
landscape
)
{
printSettings
.
orientation
=
Ci
.
nsIPrintSettings
.
kLandscapeOrientation
;
}
const
{
linkedBrowser
}
=
this
.
session
.
target
.
tab
;
await
linkedBrowser
.
browsingContext
.
print
(
printSettings
)
;
await
new
Promise
(
resolve
=
>
{
const
DELAY_CHECK_FILE_COMPLETELY_WRITTEN
=
100
;
let
lastSize
=
0
;
const
timerId
=
lazy
.
setInterval
(
async
(
)
=
>
{
const
fileInfo
=
await
lazy
.
OS
.
File
.
stat
(
filePath
)
;
if
(
lastSize
>
0
&
&
fileInfo
.
size
=
=
lastSize
)
{
lazy
.
clearInterval
(
timerId
)
;
resolve
(
)
;
}
lastSize
=
fileInfo
.
size
;
}
DELAY_CHECK_FILE_COMPLETELY_WRITTEN
)
;
}
)
;
const
fp
=
await
lazy
.
OS
.
File
.
open
(
filePath
)
;
const
retval
=
{
data
:
null
stream
:
null
}
;
if
(
transferMode
=
=
PDF_TRANSFER_MODES
.
stream
)
{
retval
.
stream
=
lazy
.
streamRegistry
.
add
(
fp
)
;
}
else
{
let
bytes
;
try
{
bytes
=
await
fp
.
read
(
)
;
}
finally
{
fp
.
close
(
)
;
await
lazy
.
OS
.
File
.
remove
(
filePath
)
;
}
retval
.
data
=
btoa
(
String
.
fromCharCode
.
apply
(
null
bytes
)
)
;
}
return
retval
;
}
setInterceptFileChooserDialog
(
options
=
{
}
)
{
}
_getCurrentHistoryIndex
(
)
{
const
{
window
}
=
this
.
session
.
target
;
return
new
Promise
(
resolve
=
>
{
lazy
.
SessionStore
.
getSessionHistory
(
window
.
gBrowser
.
selectedTab
history
=
>
{
resolve
(
history
.
index
)
;
}
)
;
}
)
;
}
_getIndexForHistoryEntryId
(
id
)
{
const
{
window
}
=
this
.
session
.
target
;
return
new
Promise
(
resolve
=
>
{
function
updateSessionHistory
(
sessionHistory
)
{
sessionHistory
.
entries
.
forEach
(
(
entry
index
)
=
>
{
if
(
entry
.
ID
=
=
id
)
{
resolve
(
index
)
;
}
}
)
;
resolve
(
null
)
;
}
lazy
.
SessionStore
.
getSessionHistory
(
window
.
gBrowser
.
selectedTab
updateSessionHistory
)
;
}
)
;
}
_onDialogLoaded
(
e
data
)
{
const
{
message
type
}
=
data
;
this
.
emit
(
"
Page
.
javascriptDialogOpening
"
{
message
type
}
)
;
}
_onRequest
(
_type
_ch
data
)
{
if
(
!
data
.
loaderId
)
{
return
;
}
this
.
executeInChild
(
"
_updateLoaderId
"
{
loaderId
:
data
.
loaderId
frameId
:
data
.
frameId
}
)
;
}
}
function
transitionToLoadFlag
(
transitionType
)
{
switch
(
transitionType
)
{
case
"
reload
"
:
return
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_IS_REFRESH
;
case
"
link
"
:
default
:
return
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_IS_LINK
;
}
}
