"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TabObserver
"
]
;
const
{
DOMContentLoadedPromise
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Sync
.
jsm
"
)
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
class
WindowObserver
{
constructor
(
{
registerExisting
=
false
}
=
{
}
)
{
this
.
registerExisting
=
registerExisting
;
EventEmitter
.
decorate
(
this
)
;
}
async
start
(
)
{
if
(
this
.
registerExisting
)
{
for
(
const
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
await
this
.
onOpenDOMWindow
(
window
)
;
}
}
Services
.
wm
.
addListener
(
this
)
;
}
stop
(
)
{
Services
.
wm
.
removeListener
(
this
)
;
}
async
onOpenDOMWindow
(
window
)
{
await
new
DOMContentLoadedPromise
(
window
)
;
this
.
emit
(
"
open
"
window
)
;
}
async
onOpenWindow
(
xulWindow
)
{
await
this
.
onOpenDOMWindow
(
xulWindow
.
docShell
.
domWindow
)
;
}
onCloseWindow
(
xulWindow
)
{
this
.
emit
(
"
close
"
xulWindow
.
docShell
.
domWindow
)
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWindowMediatorListener
]
)
;
}
}
class
TabObserver
{
constructor
(
{
registerExisting
=
false
}
=
{
}
)
{
this
.
windows
=
new
WindowObserver
(
{
registerExisting
}
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
onWindowOpen
=
this
.
onWindowOpen
.
bind
(
this
)
;
this
.
onWindowClose
=
this
.
onWindowClose
.
bind
(
this
)
;
this
.
onTabOpen
=
this
.
onTabOpen
.
bind
(
this
)
;
this
.
onTabClose
=
this
.
onTabClose
.
bind
(
this
)
;
}
async
start
(
)
{
this
.
windows
.
on
(
"
open
"
this
.
onWindowOpen
)
;
this
.
windows
.
on
(
"
close
"
this
.
onWindowClose
)
;
await
this
.
windows
.
start
(
)
;
}
stop
(
)
{
this
.
windows
.
off
(
"
open
"
this
.
onWindowOpen
)
;
this
.
windows
.
off
(
"
close
"
this
.
onWindowClose
)
;
this
.
windows
.
stop
(
)
;
for
(
const
window
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
this
.
onWindowClose
(
"
close
"
window
)
;
}
}
onTabOpen
(
{
target
}
)
{
this
.
emit
(
"
open
"
target
)
;
}
onTabClose
(
{
target
}
)
{
this
.
emit
(
"
close
"
target
)
;
}
async
onWindowOpen
(
eventName
window
)
{
if
(
!
window
.
gBrowser
)
{
return
;
}
for
(
const
tab
of
window
.
gBrowser
.
tabs
)
{
if
(
!
tab
.
linkedBrowser
)
{
continue
;
}
this
.
onTabOpen
(
{
target
:
tab
}
)
;
}
window
.
addEventListener
(
"
TabOpen
"
this
.
onTabOpen
)
;
window
.
addEventListener
(
"
TabClose
"
this
.
onTabClose
)
;
}
onWindowClose
(
eventName
window
)
{
if
(
!
window
.
gBrowser
)
{
return
;
}
for
(
const
tab
of
window
.
gBrowser
.
tabs
)
{
if
(
!
tab
.
linkedBrowser
)
{
continue
;
}
this
.
onTabClose
(
{
target
:
tab
}
)
;
}
window
.
removeEventListener
(
"
TabOpen
"
this
.
onTabOpen
)
;
window
.
removeEventListener
(
"
TabClose
"
this
.
onTabClose
)
;
}
}
