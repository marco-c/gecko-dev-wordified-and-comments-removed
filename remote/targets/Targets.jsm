"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Targets
"
]
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
)
;
const
{
MessagePromise
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Sync
.
jsm
"
)
;
const
{
TabTarget
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
targets
/
TabTarget
.
jsm
"
)
;
const
{
MainProcessTarget
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
targets
/
MainProcessTarget
.
jsm
"
)
;
const
{
TabObserver
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
targets
/
TabObserver
.
jsm
"
)
;
class
Targets
{
constructor
(
)
{
this
.
_targets
=
new
Map
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
async
watchForTargets
(
)
{
await
this
.
watchForTabs
(
)
;
}
unwatchForTargets
(
)
{
this
.
unwatchForTabs
(
)
;
}
async
watchForTabs
(
)
{
if
(
this
.
tabObserver
)
{
throw
new
Error
(
"
Targets
is
already
watching
for
new
tabs
"
)
;
}
this
.
tabObserver
=
new
TabObserver
(
{
registerExisting
:
true
}
)
;
this
.
tabObserver
.
on
(
"
open
"
async
(
eventName
tab
)
=
>
{
const
browser
=
tab
.
linkedBrowser
;
if
(
!
browser
.
browsingContext
)
{
await
new
MessagePromise
(
browser
.
messageManager
"
Browser
:
Init
"
)
;
}
const
target
=
new
TabTarget
(
this
browser
)
;
this
.
registerTarget
(
target
)
;
}
)
;
this
.
tabObserver
.
on
(
"
close
"
(
eventName
tab
)
=
>
{
const
browser
=
tab
.
linkedBrowser
;
if
(
!
browser
.
browsingContext
)
{
return
;
}
const
target
=
this
.
getById
(
browser
.
browsingContext
.
id
)
;
if
(
target
)
{
this
.
destroyTarget
(
target
)
;
}
}
)
;
await
this
.
tabObserver
.
start
(
)
;
}
unwatchForTabs
(
)
{
if
(
this
.
tabObserver
)
{
this
.
tabObserver
.
stop
(
)
;
this
.
tabObserver
=
null
;
}
}
registerTarget
(
target
)
{
this
.
_targets
.
set
(
target
.
id
target
)
;
this
.
emit
(
"
target
-
created
"
target
)
;
}
destroyTarget
(
target
)
{
target
.
destructor
(
)
;
this
.
_targets
.
delete
(
target
.
id
)
;
this
.
emit
(
"
target
-
destroyed
"
target
)
;
}
destructor
(
)
{
for
(
const
target
of
this
)
{
this
.
destroyTarget
(
target
)
;
}
this
.
_targets
.
clear
(
)
;
if
(
this
.
mainProcessTarget
)
{
this
.
mainProcessTarget
=
null
;
}
this
.
unwatchForTargets
(
)
;
}
get
size
(
)
{
return
this
.
_targets
.
size
;
}
getById
(
id
)
{
return
this
.
_targets
.
get
(
id
)
;
}
getMainProcessTarget
(
)
{
if
(
!
this
.
mainProcessTarget
)
{
this
.
mainProcessTarget
=
new
MainProcessTarget
(
this
)
;
this
.
registerTarget
(
this
.
mainProcessTarget
)
;
}
return
this
.
mainProcessTarget
;
}
*
[
Symbol
.
iterator
]
(
)
{
for
(
const
target
of
this
.
_targets
.
values
(
)
)
{
yield
target
;
}
}
toJSON
(
)
{
return
[
.
.
.
this
]
;
}
toString
(
)
{
return
[
object
Targets
{
this
.
size
}
]
;
}
}
