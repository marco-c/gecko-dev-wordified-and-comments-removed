"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
MainProcessTarget
"
]
;
const
{
Connection
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Connection
.
jsm
"
)
;
const
{
Session
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
sessions
/
Session
.
jsm
"
)
;
const
{
WebSocketDebuggerTransport
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
server
/
WebSocketTransport
.
jsm
"
)
;
const
{
WebSocketServer
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
server
/
WebSocket
.
jsm
"
)
;
class
MainProcessTarget
{
constructor
(
targets
)
{
this
.
targets
=
targets
;
this
.
sessions
=
new
Map
(
)
;
this
.
type
=
"
main
-
process
"
;
}
get
wsDebuggerURL
(
)
{
const
RemoteAgent
=
Cc
[
"
mozilla
.
org
/
remote
/
agent
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
const
{
host
port
}
=
RemoteAgent
;
return
ws
:
/
/
{
host
}
:
{
port
}
/
devtools
/
page
/
{
this
.
id
}
;
}
toString
(
)
{
return
[
object
MainProcessTarget
]
;
}
toJSON
(
)
{
return
{
description
:
"
Main
process
target
"
devtoolsFrontendUrl
:
"
"
faviconUrl
:
"
"
id
:
"
main
-
process
"
title
:
"
Main
process
target
"
type
:
this
.
type
url
:
"
"
webSocketDebuggerUrl
:
this
.
wsDebuggerURL
}
;
}
async
handle
(
request
response
)
{
const
so
=
await
WebSocketServer
.
upgrade
(
request
response
)
;
const
transport
=
new
WebSocketDebuggerTransport
(
so
)
;
const
conn
=
new
Connection
(
transport
)
;
this
.
sessions
.
set
(
conn
new
Session
(
conn
this
)
)
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
Ci
.
nsIHttpRequestHandler
]
)
;
}
}
