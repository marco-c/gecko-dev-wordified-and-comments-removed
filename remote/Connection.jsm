"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Connection
"
]
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Log
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
UnknownMethodError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Error
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
Log
.
get
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
UUIDGen
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
class
Connection
{
constructor
(
transport
httpdConnection
)
{
this
.
id
=
UUIDGen
.
generateUUID
(
)
.
toString
(
)
;
this
.
transport
=
transport
;
this
.
httpdConnection
=
httpdConnection
;
this
.
transport
.
hooks
=
this
;
this
.
transport
.
ready
(
)
;
this
.
defaultSession
=
null
;
this
.
sessions
=
new
Map
(
)
;
}
registerSession
(
session
)
{
if
(
!
session
.
id
)
{
if
(
this
.
defaultSession
)
{
throw
new
Error
(
"
Default
session
is
already
set
on
Connection
"
+
"
can
'
t
register
another
one
.
"
)
;
}
this
.
defaultSession
=
session
;
}
this
.
sessions
.
set
(
session
.
id
session
)
;
}
send
(
message
)
{
log
.
trace
(
<
-
(
connection
{
this
.
id
}
)
{
JSON
.
stringify
(
message
)
}
)
;
this
.
transport
.
send
(
message
)
;
}
onError
(
id
e
sessionId
)
{
const
error
=
{
message
:
e
.
message
data
:
e
.
stack
}
;
this
.
send
(
{
id
sessionId
error
}
)
;
}
onResult
(
id
result
sessionId
)
{
this
.
sendResult
(
id
result
sessionId
)
;
if
(
sessionId
)
{
}
}
sendResult
(
id
result
sessionId
)
{
this
.
send
(
{
sessionId
id
result
}
)
;
}
onEvent
(
method
params
sessionId
)
{
this
.
sendEvent
(
method
params
sessionId
)
;
if
(
sessionId
)
{
}
}
sendEvent
(
method
params
sessionId
)
{
this
.
send
(
{
sessionId
method
params
}
)
;
}
async
onPacket
(
packet
)
{
log
.
trace
(
(
connection
{
this
.
id
}
)
-
>
{
JSON
.
stringify
(
packet
)
}
)
;
try
{
const
{
id
method
params
sessionId
}
=
packet
;
if
(
typeof
id
=
=
"
undefined
"
)
{
throw
new
TypeError
(
"
Message
missing
'
id
'
field
"
)
;
}
if
(
typeof
method
=
=
"
undefined
"
)
{
throw
new
TypeError
(
"
Message
missing
'
method
'
field
"
)
;
}
const
{
domain
command
}
=
Connection
.
splitMethod
(
method
)
;
let
session
;
if
(
!
sessionId
)
{
if
(
!
this
.
defaultSession
)
{
throw
new
Error
(
Connection
is
missing
a
default
Session
.
)
;
}
session
=
this
.
defaultSession
;
}
else
{
session
=
this
.
sessions
.
get
(
sessionId
)
;
if
(
!
session
)
{
throw
new
Error
(
Session
'
{
sessionId
}
'
doesn
'
t
exists
.
)
;
}
}
if
(
command
.
startsWith
(
"
_
"
)
)
{
throw
new
UnknownMethodError
(
command
)
;
}
const
result
=
await
session
.
execute
(
id
domain
command
params
)
;
this
.
onResult
(
id
result
sessionId
)
;
}
catch
(
e
)
{
log
.
warn
(
e
)
;
this
.
onError
(
packet
.
id
e
packet
.
sessionId
)
;
}
}
sendMessageToTarget
(
sessionId
message
)
{
const
session
=
this
.
sessions
.
get
(
sessionId
)
;
if
(
!
session
)
{
throw
new
Error
(
Session
'
{
sessionId
}
'
doesn
'
t
exists
.
)
;
}
const
packet
=
JSON
.
parse
(
message
)
;
packet
.
sessionId
=
sessionId
;
this
.
onPacket
(
packet
)
;
}
close
(
)
{
this
.
transport
.
close
(
)
;
this
.
httpdConnection
.
close
(
)
;
}
onClosed
(
status
)
{
for
(
const
session
of
this
.
sessions
.
values
(
)
)
{
session
.
destructor
(
)
;
}
this
.
sessions
.
clear
(
)
;
}
static
splitMethod
(
s
)
{
const
ss
=
s
.
split
(
"
.
"
)
;
if
(
ss
.
length
!
=
2
|
|
ss
[
0
]
.
length
=
=
0
|
|
ss
[
1
]
.
length
=
=
0
)
{
throw
new
TypeError
(
Invalid
method
format
:
"
{
s
}
"
)
;
}
return
{
domain
:
ss
[
0
]
command
:
ss
[
1
]
}
;
}
toString
(
)
{
return
[
object
Connection
{
this
.
id
}
]
;
}
}
