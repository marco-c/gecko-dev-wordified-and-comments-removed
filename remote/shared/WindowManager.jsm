"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
windowManager
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AppInfo
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
appinfo
.
js
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
TabManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
TimedPromise
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
sync
.
js
"
EventPromise
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Sync
.
jsm
"
waitForObserverTopic
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
sync
.
js
"
}
)
;
class
WindowManager
{
constructor
(
)
{
this
.
_chromeWindowHandles
=
new
WeakMap
(
)
;
}
get
chromeWindowHandles
(
)
{
const
chromeWindowHandles
=
[
]
;
for
(
const
win
of
this
.
windows
)
{
chromeWindowHandles
.
push
(
this
.
getIdForWindow
(
win
)
)
;
}
return
chromeWindowHandles
;
}
get
windows
(
)
{
return
Services
.
wm
.
getEnumerator
(
null
)
;
}
findWindowByHandle
(
handle
)
{
for
(
const
win
of
this
.
windows
)
{
const
chromeWindowId
=
this
.
getIdForWindow
(
win
)
;
if
(
chromeWindowId
=
=
handle
)
{
return
this
.
getWindowProperties
(
win
)
;
}
const
tabBrowser
=
lazy
.
TabManager
.
getTabBrowser
(
win
)
;
if
(
tabBrowser
&
&
tabBrowser
.
tabs
)
{
for
(
let
i
=
0
;
i
<
tabBrowser
.
tabs
.
length
;
+
+
i
)
{
let
contentBrowser
=
lazy
.
TabManager
.
getBrowserForTab
(
tabBrowser
.
tabs
[
i
]
)
;
let
contentWindowId
=
lazy
.
TabManager
.
getIdForBrowser
(
contentBrowser
)
;
if
(
contentWindowId
=
=
handle
)
{
return
this
.
getWindowProperties
(
win
{
tabIndex
:
i
}
)
;
}
}
}
}
return
null
;
}
getWindowProperties
(
win
options
=
{
}
)
{
if
(
!
Window
.
isInstance
(
win
)
)
{
throw
new
TypeError
(
"
Invalid
argument
expected
a
Window
object
"
)
;
}
return
{
win
id
:
this
.
getIdForWindow
(
win
)
hasTabBrowser
:
!
!
lazy
.
TabManager
.
getTabBrowser
(
win
)
tabIndex
:
options
.
tabIndex
}
;
}
getIdForWindow
(
win
)
{
if
(
!
this
.
_chromeWindowHandles
.
has
(
win
)
)
{
const
uuid
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
;
this
.
_chromeWindowHandles
.
set
(
win
uuid
.
substring
(
1
uuid
.
length
-
1
)
)
;
}
return
this
.
_chromeWindowHandles
.
get
(
win
)
;
}
async
closeWindow
(
win
)
{
const
destroyed
=
lazy
.
waitForObserverTopic
(
"
xul
-
window
-
destroyed
"
{
checkFn
:
(
)
=
>
win
&
&
win
.
closed
}
)
;
win
.
close
(
)
;
return
destroyed
;
}
async
focusWindow
(
win
)
{
if
(
Services
.
focus
.
activeWindow
!
=
win
)
{
let
activated
=
new
lazy
.
EventPromise
(
win
"
activate
"
)
;
let
focused
=
new
lazy
.
EventPromise
(
win
"
focus
"
{
capture
:
true
}
)
;
win
.
focus
(
)
;
await
Promise
.
all
(
[
activated
focused
]
)
;
}
}
async
openBrowserWindow
(
options
=
{
}
)
{
let
{
focus
=
false
isPrivate
=
false
openerWindow
=
null
}
=
options
;
switch
(
lazy
.
AppInfo
.
name
)
{
case
"
Firefox
"
:
if
(
openerWindow
=
=
=
null
)
{
openerWindow
=
Services
.
wm
.
getMostRecentBrowserWindow
(
)
;
}
if
(
!
openerWindow
)
{
throw
new
lazy
.
error
.
UnsupportedOperationError
(
openWindow
(
)
could
not
find
a
valid
opener
window
)
;
}
const
win
=
openerWindow
.
OpenBrowserWindow
(
{
private
:
isPrivate
}
)
;
const
activated
=
new
lazy
.
EventPromise
(
win
"
activate
"
)
;
const
focused
=
new
lazy
.
EventPromise
(
win
"
focus
"
{
capture
:
true
}
)
;
const
startup
=
lazy
.
waitForObserverTopic
(
"
browser
-
delayed
-
startup
-
finished
"
{
checkFn
:
subject
=
>
subject
=
=
win
}
)
;
win
.
focus
(
)
;
await
Promise
.
all
(
[
activated
focused
startup
]
)
;
if
(
!
focus
)
{
await
this
.
focusWindow
(
openerWindow
)
;
}
return
win
;
default
:
throw
new
lazy
.
error
.
UnsupportedOperationError
(
openWindow
(
)
not
supported
in
{
lazy
.
AppInfo
.
name
}
)
;
}
}
waitForInitialApplicationWindowLoaded
(
)
{
return
new
lazy
.
TimedPromise
(
async
resolve
=
>
{
const
windowReadyTopic
=
lazy
.
AppInfo
.
isThunderbird
?
"
mail
-
delayed
-
startup
-
finished
"
:
"
browser
-
delayed
-
startup
-
finished
"
;
const
win
=
Services
.
wm
.
getMostRecentBrowserWindow
(
)
;
const
windowLoaded
=
lazy
.
waitForObserverTopic
(
windowReadyTopic
{
checkFn
:
subject
=
>
(
win
!
=
=
null
?
subject
=
=
win
:
true
)
}
)
;
if
(
win
&
&
win
.
document
.
readyState
=
=
"
complete
"
)
{
resolve
(
win
)
;
return
;
}
const
{
subject
}
=
await
windowLoaded
;
resolve
(
subject
)
;
}
{
errorMessage
:
"
No
applicable
application
window
found
"
}
)
;
}
}
const
windowManager
=
new
WindowManager
(
)
;
