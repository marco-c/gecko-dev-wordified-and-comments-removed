"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TabManager
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AppInfo
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
appinfo
.
js
"
EventPromise
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Sync
.
jsm
"
MobileTabBrowser
:
"
chrome
:
/
/
remote
/
content
/
shared
/
MobileTabBrowser
.
jsm
"
}
)
;
const
browserUniqueIds
=
new
WeakMap
(
)
;
var
TabManager
=
{
get
browsers
(
)
{
const
browsers
=
[
]
;
for
(
const
win
of
this
.
windows
)
{
const
tabBrowser
=
this
.
getTabBrowser
(
win
)
;
if
(
tabBrowser
&
&
tabBrowser
.
tabs
)
{
const
contentBrowsers
=
tabBrowser
.
tabs
.
map
(
tab
=
>
{
return
this
.
getBrowserForTab
(
tab
)
;
}
)
;
browsers
.
push
(
.
.
.
contentBrowsers
)
;
}
}
return
browsers
;
}
get
windows
(
)
{
return
Services
.
wm
.
getEnumerator
(
null
)
;
}
get
allBrowserUniqueIds
(
)
{
const
browserIds
=
[
]
;
for
(
const
win
of
this
.
windows
)
{
const
tabBrowser
=
this
.
getTabBrowser
(
win
)
;
if
(
tabBrowser
&
&
tabBrowser
.
tabs
)
{
for
(
const
tab
of
tabBrowser
.
tabs
)
{
const
contentBrowser
=
this
.
getBrowserForTab
(
tab
)
;
const
winId
=
this
.
getIdForBrowser
(
contentBrowser
)
;
if
(
winId
!
=
=
null
)
{
browserIds
.
push
(
winId
)
;
}
}
}
}
return
browserIds
;
}
getBrowserForTab
(
tab
)
{
if
(
tab
&
&
"
linkedBrowser
"
in
tab
)
{
return
tab
.
linkedBrowser
;
}
return
null
;
}
getTabBrowser
(
win
)
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
Android
"
)
{
return
new
lazy
.
MobileTabBrowser
(
win
)
;
}
else
if
(
"
gBrowser
"
in
win
)
{
return
win
.
gBrowser
;
}
else
if
(
win
.
document
.
getElementById
(
"
tabmail
"
)
)
{
return
win
.
document
.
getElementById
(
"
tabmail
"
)
;
}
return
null
;
}
async
addTab
(
options
=
{
}
)
{
const
{
focus
=
false
userContextId
window
=
Services
.
wm
.
getMostRecentWindow
(
null
)
}
=
options
;
const
tabBrowser
=
this
.
getTabBrowser
(
window
)
;
const
tab
=
tabBrowser
.
addTab
(
"
about
:
blank
"
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
userContextId
}
)
;
if
(
focus
)
{
await
this
.
selectTab
(
tab
)
;
}
return
tab
;
}
getBrowserById
(
id
)
{
for
(
const
win
of
this
.
windows
)
{
const
tabBrowser
=
this
.
getTabBrowser
(
win
)
;
if
(
tabBrowser
&
&
tabBrowser
.
tabs
)
{
for
(
let
i
=
0
;
i
<
tabBrowser
.
tabs
.
length
;
+
+
i
)
{
const
contentBrowser
=
this
.
getBrowserForTab
(
tabBrowser
.
tabs
[
i
]
)
;
if
(
this
.
getIdForBrowser
(
contentBrowser
)
=
=
id
)
{
return
contentBrowser
;
}
}
}
}
return
null
;
}
getBrowsingContextById
(
id
)
{
const
browser
=
this
.
getBrowserById
(
id
)
;
if
(
browser
)
{
return
browser
.
browsingContext
;
}
return
BrowsingContext
.
get
(
id
)
;
}
getIdForBrowser
(
browserElement
)
{
if
(
browserElement
=
=
=
null
)
{
return
null
;
}
const
key
=
browserElement
.
permanentKey
;
if
(
!
browserUniqueIds
.
has
(
key
)
)
{
const
uuid
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
;
browserUniqueIds
.
set
(
key
uuid
.
substring
(
1
uuid
.
length
-
1
)
)
;
}
return
browserUniqueIds
.
get
(
key
)
;
}
getIdForBrowsingContext
(
browsingContext
)
{
if
(
!
browsingContext
)
{
return
null
;
}
if
(
!
browsingContext
.
parent
)
{
return
this
.
getIdForBrowser
(
browsingContext
.
embedderElement
)
;
}
return
browsingContext
.
id
.
toString
(
)
;
}
getTabCount
(
)
{
let
count
=
0
;
for
(
const
win
of
this
.
windows
)
{
const
tabbrowser
=
this
.
getTabBrowser
(
win
)
;
if
(
tabbrowser
?
.
tabs
)
{
count
+
=
tabbrowser
.
tabs
.
length
;
}
else
{
count
+
=
1
;
}
}
return
count
;
}
removeTab
(
tab
)
{
const
ownerWindow
=
this
.
_getWindowForTab
(
tab
)
;
const
tabBrowser
=
this
.
getTabBrowser
(
ownerWindow
)
;
tabBrowser
.
removeTab
(
tab
)
;
}
selectTab
(
tab
)
{
const
ownerWindow
=
this
.
_getWindowForTab
(
tab
)
;
const
tabBrowser
=
this
.
getTabBrowser
(
ownerWindow
)
;
if
(
tab
=
=
=
tabBrowser
.
selectedTab
)
{
return
Promise
.
resolve
(
)
;
}
const
selected
=
new
lazy
.
EventPromise
(
ownerWindow
"
TabSelect
"
)
;
tabBrowser
.
selectedTab
=
tab
;
return
selected
;
}
supportsTabs
(
)
{
return
lazy
.
AppInfo
.
name
=
=
=
"
Firefox
"
;
}
_getWindowForTab
(
tab
)
{
return
tab
.
linkedBrowser
.
ownerGlobal
;
}
}
;
