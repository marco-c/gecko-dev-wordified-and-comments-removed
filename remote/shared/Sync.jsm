"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
AnimationFramePromise
"
"
Deferred
"
"
EventPromise
"
"
executeSoon
"
"
PollPromise
"
]
;
var
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
{
TYPE_REPEATING_SLACK
}
=
Ci
.
nsITimer
;
function
AnimationFramePromise
(
win
)
{
const
animationFramePromise
=
new
Promise
(
resolve
=
>
{
win
.
requestAnimationFrame
(
resolve
)
;
}
)
;
const
windowClosedPromise
=
new
PollPromise
(
resolve
=
>
{
if
(
win
.
closed
)
{
resolve
(
)
;
}
}
)
;
return
Promise
.
race
(
[
animationFramePromise
windowClosedPromise
]
)
;
}
function
Deferred
(
)
{
const
deferred
=
{
}
;
deferred
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
deferred
.
resolve
=
resolve
;
deferred
.
reject
=
reject
;
}
)
;
return
deferred
;
}
function
EventPromise
(
listener
type
options
=
{
capture
:
false
wantsUntrusted
:
false
mozSystemGroup
:
false
}
)
{
if
(
!
listener
|
|
!
(
"
addEventListener
"
in
listener
)
)
{
throw
new
TypeError
(
)
;
}
if
(
typeof
type
!
=
"
string
"
)
{
throw
new
TypeError
(
)
;
}
if
(
(
"
capture
"
in
options
&
&
typeof
options
.
capture
!
=
"
boolean
"
)
|
|
(
"
wantsUntrusted
"
in
options
&
&
typeof
options
.
wantsUntrusted
!
=
"
boolean
"
)
|
|
(
"
mozSystemGroup
"
in
options
&
&
typeof
options
.
mozSystemGroup
!
=
"
boolean
"
)
)
{
throw
new
TypeError
(
)
;
}
options
.
once
=
true
;
return
new
Promise
(
resolve
=
>
{
listener
.
addEventListener
(
type
event
=
>
{
executeSoon
(
(
)
=
>
resolve
(
event
)
)
;
}
options
)
;
}
)
;
}
function
executeSoon
(
fn
)
{
if
(
typeof
fn
!
=
"
function
"
)
{
throw
new
TypeError
(
)
;
}
Services
.
tm
.
dispatchToMainThread
(
fn
)
;
}
function
PollPromise
(
func
{
timeout
=
null
interval
=
10
}
=
{
}
)
{
const
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
if
(
typeof
func
!
=
"
function
"
)
{
throw
new
TypeError
(
)
;
}
if
(
timeout
!
=
null
&
&
typeof
timeout
!
=
"
number
"
)
{
throw
new
TypeError
(
)
;
}
if
(
typeof
interval
!
=
"
number
"
)
{
throw
new
TypeError
(
)
;
}
if
(
(
timeout
&
&
(
!
Number
.
isInteger
(
timeout
)
|
|
timeout
<
0
)
)
|
|
!
Number
.
isInteger
(
interval
)
|
|
interval
<
0
)
{
throw
new
RangeError
(
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
start
end
;
if
(
Number
.
isInteger
(
timeout
)
)
{
start
=
new
Date
(
)
.
getTime
(
)
;
end
=
start
+
timeout
;
}
let
evalFn
=
(
)
=
>
{
new
Promise
(
func
)
.
then
(
resolve
rejected
=
>
{
if
(
typeof
rejected
!
=
"
undefined
"
)
{
throw
rejected
;
}
if
(
typeof
end
!
=
"
undefined
"
&
&
(
start
=
=
end
|
|
new
Date
(
)
.
getTime
(
)
>
=
end
)
)
{
resolve
(
rejected
)
;
}
}
)
.
catch
(
reject
)
;
}
;
evalFn
(
)
;
timer
.
init
(
evalFn
interval
TYPE_REPEATING_SLACK
)
;
}
)
.
then
(
res
=
>
{
timer
.
cancel
(
)
;
return
res
;
}
err
=
>
{
timer
.
cancel
(
)
;
throw
err
;
}
)
;
}
