"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ProgressListener
"
"
waitForInitialNavigationCompleted
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
Deferred
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Sync
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
truncate
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
REMOTE_AGENT
)
)
;
const
webProgressListeners
=
new
Set
(
)
;
async
function
waitForInitialNavigationCompleted
(
webProgress
options
=
{
}
)
{
const
{
resolveWhenStarted
=
false
}
=
options
;
const
browsingContext
=
webProgress
.
browsingContext
;
const
listener
=
new
ProgressListener
(
webProgress
{
resolveWhenStarted
}
)
;
const
navigated
=
listener
.
start
(
)
;
let
isInitial
=
true
;
if
(
browsingContext
.
currentWindowGlobal
)
{
isInitial
=
browsingContext
.
currentWindowGlobal
.
isInitialDocument
;
}
if
(
!
isInitial
&
&
!
listener
.
isLoadingDocument
)
{
logger
.
trace
(
truncate
[
{
browsingContext
.
id
}
]
Document
already
finished
loading
:
{
browsingContext
.
currentURI
?
.
spec
}
)
;
listener
.
stop
(
)
;
}
await
navigated
;
return
{
currentURI
:
listener
.
currentURI
targetURI
:
listener
.
targetURI
}
;
}
class
ProgressListener
{
#
expectNavigation
;
#
resolveWhenStarted
;
#
unloadTimeout
;
#
waitForExplicitStart
;
#
webProgress
;
#
deferredNavigation
;
#
seenStartFlag
;
#
targetURI
;
#
unloadTimerId
;
constructor
(
webProgress
options
=
{
}
)
{
const
{
expectNavigation
=
false
resolveWhenStarted
=
false
unloadTimeout
=
200
waitForExplicitStart
=
false
}
=
options
;
this
.
#
expectNavigation
=
expectNavigation
;
this
.
#
resolveWhenStarted
=
resolveWhenStarted
;
this
.
#
unloadTimeout
=
unloadTimeout
;
this
.
#
waitForExplicitStart
=
waitForExplicitStart
;
this
.
#
webProgress
=
webProgress
;
this
.
#
deferredNavigation
=
null
;
this
.
#
seenStartFlag
=
false
;
this
.
#
targetURI
=
null
;
this
.
#
unloadTimerId
=
null
;
}
get
browsingContext
(
)
{
return
this
.
#
webProgress
.
browsingContext
;
}
get
currentURI
(
)
{
return
this
.
#
webProgress
.
browsingContext
.
currentURI
;
}
get
isLoadingDocument
(
)
{
return
this
.
#
webProgress
.
isLoadingDocument
;
}
get
isStarted
(
)
{
return
!
!
this
.
#
deferredNavigation
;
}
get
targetURI
(
)
{
return
this
.
#
targetURI
;
}
#
checkLoadingState
(
request
options
=
{
}
)
{
const
{
isStart
=
false
isStop
=
false
status
=
0
}
=
options
;
const
messagePrefix
=
[
{
this
.
browsingContext
.
id
}
]
{
this
.
constructor
.
name
}
;
if
(
isStart
&
&
!
this
.
#
seenStartFlag
)
{
this
.
#
seenStartFlag
=
true
;
this
.
#
targetURI
=
this
.
#
getTargetURI
(
request
)
;
logger
.
trace
(
truncate
{
messagePrefix
}
state
=
start
:
{
this
.
targetURI
?
.
spec
}
)
;
if
(
this
.
#
unloadTimerId
!
=
=
null
)
{
clearTimeout
(
this
.
#
unloadTimerId
)
;
this
.
#
unloadTimerId
=
null
;
}
if
(
this
.
#
resolveWhenStarted
)
{
this
.
stop
(
)
;
return
;
}
}
if
(
isStop
&
&
this
.
#
seenStartFlag
)
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
if
(
status
=
=
Cr
.
NS_BINDING_ABORTED
&
&
this
.
browsingContext
.
currentWindowGlobal
.
isInitialDocument
)
{
return
;
}
const
errorName
=
ChromeUtils
.
getXPCOMErrorName
(
status
)
;
logger
.
trace
(
truncate
{
messagePrefix
}
state
=
stop
:
error
=
0x
{
status
.
toString
(
16
)
}
(
{
errorName
}
)
)
;
this
.
stop
(
{
error
:
new
Error
(
errorName
)
}
)
;
return
;
}
logger
.
trace
(
truncate
{
messagePrefix
}
state
=
stop
:
{
this
.
currentURI
.
spec
}
)
;
if
(
!
this
.
browsingContext
.
currentWindowGlobal
.
isInitialDocument
)
{
this
.
stop
(
)
;
return
;
}
logger
.
trace
(
{
messagePrefix
}
Initial
document
loaded
.
Wait
for
a
potential
further
navigation
.
)
;
this
.
#
seenStartFlag
=
false
;
this
.
#
setUnloadTimer
(
)
;
}
}
#
getTargetURI
(
request
)
{
try
{
return
request
.
QueryInterface
(
Ci
.
nsIChannel
)
.
originalURI
;
}
catch
(
e
)
{
}
return
null
;
}
#
setUnloadTimer
(
)
{
if
(
!
this
.
#
expectNavigation
)
{
this
.
#
unloadTimerId
=
setTimeout
(
(
)
=
>
{
logger
.
trace
(
truncate
[
{
this
.
browsingContext
.
id
}
]
No
navigation
detected
:
{
this
.
currentURI
?
.
spec
}
)
;
this
.
#
targetURI
=
this
.
currentURI
;
this
.
stop
(
)
;
}
this
.
#
unloadTimeout
)
;
}
}
onStateChange
(
progress
request
flag
status
)
{
this
.
#
checkLoadingState
(
request
{
isStart
:
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
isStop
:
flag
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
status
}
)
;
}
onLocationChange
(
progress
request
location
flag
)
{
const
messagePrefix
=
[
{
this
.
browsingContext
.
id
}
]
{
this
.
constructor
.
name
}
;
if
(
flag
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
{
logger
.
trace
(
truncate
{
messagePrefix
}
location
=
errorPage
:
{
location
.
spec
}
)
;
this
.
stop
(
{
error
:
new
Error
(
"
Address
restricted
"
)
}
)
;
return
;
}
if
(
flag
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
{
this
.
#
targetURI
=
location
;
logger
.
trace
(
truncate
{
messagePrefix
}
location
=
sameDocument
:
{
this
.
targetURI
?
.
spec
}
)
;
this
.
stop
(
)
;
}
}
start
(
)
{
if
(
this
.
#
deferredNavigation
)
{
throw
new
Error
(
Progress
listener
already
started
)
;
}
if
(
this
.
#
webProgress
.
isLoadingDocument
)
{
this
.
#
targetURI
=
this
.
#
getTargetURI
(
this
.
#
webProgress
.
documentRequest
)
;
if
(
this
.
#
resolveWhenStarted
)
{
return
Promise
.
resolve
(
)
;
}
}
this
.
#
deferredNavigation
=
new
Deferred
(
)
;
this
.
#
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
)
;
webProgressListeners
.
add
(
this
)
;
if
(
this
.
#
webProgress
.
isLoadingDocument
&
&
!
this
.
#
waitForExplicitStart
)
{
this
.
#
checkLoadingState
(
this
.
#
webProgress
.
documentRequest
{
isStart
:
true
}
)
;
}
else
{
this
.
#
setUnloadTimer
(
)
;
}
return
this
.
#
deferredNavigation
.
promise
;
}
stop
(
options
=
{
}
)
{
const
{
error
}
=
options
;
if
(
!
this
.
#
deferredNavigation
)
{
throw
new
Error
(
Progress
listener
not
yet
started
)
;
}
clearTimeout
(
this
.
#
unloadTimerId
)
;
this
.
#
unloadTimerId
=
null
;
this
.
#
webProgress
.
removeProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
)
;
webProgressListeners
.
delete
(
this
)
;
if
(
!
this
.
#
targetURI
)
{
this
.
#
targetURI
=
this
.
browsingContext
.
currentURI
;
}
if
(
error
)
{
this
.
#
deferredNavigation
.
reject
(
error
)
;
}
else
{
this
.
#
deferredNavigation
.
resolve
(
)
;
}
this
.
#
deferredNavigation
=
null
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
]
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
;
}
}
