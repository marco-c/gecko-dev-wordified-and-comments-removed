"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
waitForInitialNavigationCompleted
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
REMOTE_AGENT
)
)
;
const
webProgressListeners
=
new
Set
(
)
;
function
waitForInitialNavigationCompleted
(
browsingContext
)
{
const
webProgress
=
browsingContext
.
webProgress
;
let
listener
;
return
new
Promise
(
resolve
=
>
{
listener
=
new
ProgressListener
(
resolve
)
;
webProgressListeners
.
add
(
listener
)
;
webProgress
.
addProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
const
isInitial
=
!
browsingContext
.
currentWindowGlobal
;
if
(
!
webProgress
.
isLoadingDocument
&
&
!
isInitial
)
{
logger
.
trace
(
"
Initial
navigation
already
completed
"
)
;
resolve
(
)
;
}
}
)
.
finally
(
(
)
=
>
{
webProgress
.
removeProgressListener
(
listener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
webProgressListeners
.
delete
(
listener
)
;
}
)
;
}
class
ProgressListener
{
constructor
(
resolve
)
{
this
.
resolve
=
resolve
;
}
onStateChange
(
progress
request
flag
status
)
{
const
isStop
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
if
(
isStop
)
{
this
.
resolve
(
)
;
}
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
;
}
}
