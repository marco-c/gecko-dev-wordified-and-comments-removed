"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
waitForInitialNavigationCompleted
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
truncate
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
REMOTE_AGENT
)
)
;
const
webProgressListeners
=
new
Set
(
)
;
function
waitForInitialNavigationCompleted
(
browsingContext
)
{
const
listener
=
new
ProgressListener
(
browsingContext
.
webProgress
)
;
const
navigated
=
listener
.
start
(
)
;
let
isInitial
=
true
;
if
(
browsingContext
.
currentWindowGlobal
)
{
isInitial
=
browsingContext
.
currentWindowGlobal
.
isInitialDocument
;
}
if
(
!
isInitial
&
&
!
listener
.
isLoadingDocument
)
{
logger
.
trace
(
truncate
[
{
browsingContext
.
id
}
]
Document
already
finished
loading
:
{
browsingContext
.
currentURI
?
.
spec
}
)
;
listener
.
stop
(
)
;
return
Promise
.
resolve
(
)
;
}
return
navigated
;
}
class
ProgressListener
{
#
resolve
;
#
unloadTimeout
;
#
unloadTimer
;
#
webProgress
;
constructor
(
webProgress
options
=
{
}
)
{
const
{
unloadTimeout
=
200
}
=
options
;
this
.
#
resolve
=
null
;
this
.
#
unloadTimeout
=
unloadTimeout
;
this
.
#
unloadTimer
=
null
;
this
.
#
webProgress
=
webProgress
;
}
get
browsingContext
(
)
{
return
this
.
#
webProgress
.
browsingContext
;
}
get
currentURI
(
)
{
return
this
.
#
webProgress
.
browsingContext
.
currentURI
;
}
get
isLoadingDocument
(
)
{
return
this
.
#
webProgress
.
isLoadingDocument
;
}
onStateChange
(
progress
request
flag
status
)
{
const
isStart
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
;
const
isStop
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
if
(
isStart
)
{
this
.
#
unloadTimer
?
.
cancel
(
)
;
logger
.
trace
(
truncate
[
{
this
.
browsingContext
.
id
}
]
Web
progress
state
=
start
:
{
this
.
currentURI
?
.
spec
}
)
;
}
if
(
isStop
)
{
logger
.
trace
(
truncate
this
.
browsingContext
.
id
}
]
Web
progress
state
=
stop
:
{
this
.
currentURI
?
.
spec
}
)
;
this
.
#
resolve
(
)
;
this
.
stop
(
)
;
}
}
start
(
)
{
if
(
this
.
#
resolve
)
{
throw
new
Error
(
Progress
listener
already
started
)
;
}
const
promise
=
new
Promise
(
resolve
=
>
(
this
.
#
resolve
=
resolve
)
)
;
this
.
#
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
webProgressListeners
.
add
(
this
)
;
if
(
!
this
.
#
webProgress
.
isLoadingDocument
)
{
this
.
#
unloadTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
#
unloadTimer
.
initWithCallback
(
(
)
=
>
{
logger
.
trace
(
truncate
[
{
this
.
browsingContext
.
id
}
]
No
navigation
detected
:
{
this
.
currentURI
?
.
spec
}
)
;
this
.
#
resolve
(
)
;
this
.
stop
(
)
;
}
this
.
#
unloadTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
return
promise
;
}
stop
(
)
{
if
(
!
this
.
#
resolve
)
{
throw
new
Error
(
Progress
listener
not
yet
started
)
;
}
this
.
#
unloadTimer
?
.
cancel
(
)
;
this
.
#
unloadTimer
=
null
;
this
.
#
resolve
=
null
;
this
.
#
webProgress
.
removeProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_DOCUMENT
)
;
webProgressListeners
.
delete
(
this
)
;
}
get
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
]
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
;
}
}
