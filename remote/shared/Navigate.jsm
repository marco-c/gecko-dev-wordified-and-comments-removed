"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ProgressListener
"
"
waitForInitialNavigationCompleted
"
]
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
Deferred
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Sync
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
truncate
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
lazy
.
Log
.
TYPES
.
REMOTE_AGENT
)
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
UNLOAD_TIMEOUT_MULTIPLIER
"
(
)
=
>
{
if
(
AppConstants
.
MOZ_CODE_COVERAGE
)
{
return
16
;
}
if
(
AppConstants
.
ASAN
|
|
AppConstants
.
DEBUG
|
|
AppConstants
.
TSAN
)
{
return
8
;
}
return
1
;
}
)
;
const
webProgressListeners
=
new
Set
(
)
;
async
function
waitForInitialNavigationCompleted
(
webProgress
options
=
{
}
)
{
const
{
resolveWhenStarted
=
false
}
=
options
;
const
browsingContext
=
webProgress
.
browsingContext
;
const
listener
=
new
ProgressListener
(
webProgress
{
resolveWhenStarted
}
)
;
const
navigated
=
listener
.
start
(
)
;
let
isInitial
=
true
;
if
(
browsingContext
.
currentWindowGlobal
)
{
isInitial
=
browsingContext
.
currentWindowGlobal
.
isInitialDocument
;
}
if
(
!
isInitial
&
&
!
listener
.
isLoadingDocument
)
{
lazy
.
logger
.
trace
(
lazy
.
truncate
[
{
browsingContext
.
id
}
]
Document
already
finished
loading
:
{
browsingContext
.
currentURI
?
.
spec
}
)
;
listener
.
stop
(
)
;
}
await
navigated
;
return
{
currentURI
:
listener
.
currentURI
targetURI
:
listener
.
targetURI
}
;
}
class
ProgressListener
{
#
expectNavigation
;
#
resolveWhenStarted
;
#
unloadTimeout
;
#
waitForExplicitStart
;
#
webProgress
;
#
deferredNavigation
;
#
seenStartFlag
;
#
targetURI
;
#
unloadTimerId
;
constructor
(
webProgress
options
=
{
}
)
{
const
{
expectNavigation
=
false
resolveWhenStarted
=
false
unloadTimeout
=
200
waitForExplicitStart
=
false
}
=
options
;
this
.
#
expectNavigation
=
expectNavigation
;
this
.
#
resolveWhenStarted
=
resolveWhenStarted
;
this
.
#
unloadTimeout
=
unloadTimeout
*
lazy
.
UNLOAD_TIMEOUT_MULTIPLIER
;
this
.
#
waitForExplicitStart
=
waitForExplicitStart
;
this
.
#
webProgress
=
webProgress
;
this
.
#
deferredNavigation
=
null
;
this
.
#
seenStartFlag
=
false
;
this
.
#
targetURI
=
null
;
this
.
#
unloadTimerId
=
null
;
}
get
#
messagePrefix
(
)
{
return
[
{
this
.
browsingContext
.
id
}
]
{
this
.
constructor
.
name
}
;
}
get
browsingContext
(
)
{
return
this
.
#
webProgress
.
browsingContext
;
}
get
currentURI
(
)
{
return
this
.
#
webProgress
.
browsingContext
.
currentURI
;
}
get
isLoadingDocument
(
)
{
return
this
.
#
webProgress
.
isLoadingDocument
;
}
get
isStarted
(
)
{
return
!
!
this
.
#
deferredNavigation
;
}
get
targetURI
(
)
{
return
this
.
#
targetURI
;
}
#
checkLoadingState
(
request
options
=
{
}
)
{
const
{
isStart
=
false
isStop
=
false
status
=
0
}
=
options
;
this
.
#
trace
(
Check
loading
state
:
isStart
=
{
isStart
}
isStop
=
{
isStop
}
)
;
if
(
isStart
&
&
!
this
.
#
seenStartFlag
)
{
this
.
#
seenStartFlag
=
true
;
this
.
#
targetURI
=
this
.
#
getTargetURI
(
request
)
;
this
.
#
trace
(
state
=
start
:
{
this
.
targetURI
?
.
spec
}
)
;
if
(
this
.
#
unloadTimerId
!
=
=
null
)
{
lazy
.
clearTimeout
(
this
.
#
unloadTimerId
)
;
this
.
#
unloadTimerId
=
null
;
}
if
(
this
.
#
resolveWhenStarted
)
{
this
.
stop
(
)
;
return
;
}
}
if
(
isStop
&
&
this
.
#
seenStartFlag
)
{
if
(
!
Components
.
isSuccessCode
(
status
)
&
&
status
!
=
Cr
.
NS_ERROR_PARSED_DATA_CACHED
)
{
if
(
status
=
=
Cr
.
NS_BINDING_ABORTED
&
&
this
.
browsingContext
.
currentWindowGlobal
.
isInitialDocument
)
{
this
.
#
trace
(
Ignore
aborted
navigation
error
to
the
initial
document
real
document
will
be
loaded
.
)
;
return
;
}
const
errorName
=
ChromeUtils
.
getXPCOMErrorName
(
status
)
;
this
.
#
trace
(
state
=
stop
:
error
=
0x
{
status
.
toString
(
16
)
}
(
{
errorName
}
)
)
;
this
.
stop
(
{
error
:
new
Error
(
errorName
)
}
)
;
return
;
}
this
.
#
trace
(
state
=
stop
:
{
this
.
currentURI
.
spec
}
)
;
if
(
!
this
.
browsingContext
.
currentWindowGlobal
.
isInitialDocument
)
{
this
.
stop
(
)
;
return
;
}
this
.
#
trace
(
Initial
document
loaded
.
Wait
for
a
potential
further
navigation
.
)
;
this
.
#
seenStartFlag
=
false
;
this
.
#
setUnloadTimer
(
)
;
}
}
#
getTargetURI
(
request
)
{
try
{
return
request
.
QueryInterface
(
Ci
.
nsIChannel
)
.
originalURI
;
}
catch
(
e
)
{
}
return
null
;
}
#
setUnloadTimer
(
)
{
if
(
!
this
.
#
expectNavigation
)
{
this
.
#
trace
(
Setting
unload
timer
(
{
this
.
#
unloadTimeout
}
ms
)
)
;
this
.
#
unloadTimerId
=
lazy
.
setTimeout
(
(
)
=
>
{
this
.
#
trace
(
No
navigation
detected
:
{
this
.
currentURI
?
.
spec
}
)
;
this
.
#
targetURI
=
this
.
currentURI
;
this
.
stop
(
)
;
}
this
.
#
unloadTimeout
)
;
}
}
#
trace
(
message
)
{
lazy
.
logger
.
trace
(
lazy
.
truncate
{
this
.
#
messagePrefix
}
{
message
}
)
;
}
onStateChange
(
progress
request
flag
status
)
{
this
.
#
checkLoadingState
(
request
{
isStart
:
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
isStop
:
flag
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
status
}
)
;
}
onLocationChange
(
progress
request
location
flag
)
{
/
/
If
an
error
page
has
been
loaded
abort
the
navigation
.
if
(
flag
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_ERROR_PAGE
)
{
this
.
#
trace
(
location
=
errorPage
:
{
location
.
spec
}
)
;
this
.
stop
(
{
error
:
new
Error
(
"
Address
restricted
"
)
}
)
;
return
;
}
/
/
If
location
has
changed
in
the
same
document
the
navigation
is
done
.
if
(
flag
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
{
this
.
#
targetURI
=
location
;
this
.
#
trace
(
location
=
sameDocument
:
{
this
.
targetURI
?
.
spec
}
)
;
this
.
stop
(
)
;
}
}
/
*
*
*
Start
observing
web
progress
changes
.
*
*
returns
{
Promise
}
*
A
promise
that
will
resolve
when
the
navigation
has
been
finished
.
*
/
start
(
)
{
if
(
this
.
#
deferredNavigation
)
{
throw
new
Error
(
Progress
listener
already
started
)
;
}
if
(
this
.
#
webProgress
.
isLoadingDocument
)
{
this
.
#
targetURI
=
this
.
#
getTargetURI
(
this
.
#
webProgress
.
documentRequest
)
;
if
(
this
.
#
resolveWhenStarted
&
&
!
this
.
#
waitForExplicitStart
)
{
/
/
Resolve
immediately
when
the
page
is
already
loading
and
there
/
/
is
no
requirement
to
wait
for
it
to
finish
.
this
.
#
trace
(
Document
already
loading
{
this
.
#
targetURI
}
)
;
return
Promise
.
resolve
(
)
;
}
}
this
.
#
deferredNavigation
=
new
lazy
.
Deferred
(
)
;
this
.
#
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
)
;
webProgressListeners
.
add
(
this
)
;
if
(
this
.
#
webProgress
.
isLoadingDocument
&
&
!
this
.
#
waitForExplicitStart
)
{
this
.
#
checkLoadingState
(
this
.
#
webProgress
.
documentRequest
{
isStart
:
true
}
)
;
}
else
{
this
.
#
setUnloadTimer
(
)
;
}
return
this
.
#
deferredNavigation
.
promise
;
}
stop
(
options
=
{
}
)
{
const
{
error
}
=
options
;
if
(
!
this
.
#
deferredNavigation
)
{
throw
new
Error
(
Progress
listener
not
yet
started
)
;
}
lazy
.
clearTimeout
(
this
.
#
unloadTimerId
)
;
this
.
#
unloadTimerId
=
null
;
this
.
#
webProgress
.
removeProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
)
;
webProgressListeners
.
delete
(
this
)
;
if
(
!
this
.
#
targetURI
)
{
this
.
#
targetURI
=
this
.
browsingContext
.
currentURI
;
}
if
(
error
)
{
this
.
#
deferredNavigation
.
reject
(
error
)
;
}
else
{
this
.
#
deferredNavigation
.
resolve
(
)
;
}
this
.
#
deferredNavigation
=
null
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
]
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
;
}
}
