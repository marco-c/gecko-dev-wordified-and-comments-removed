"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ProgressListener
"
"
waitForInitialNavigationCompleted
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
clearTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
truncate
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
REMOTE_AGENT
)
)
;
const
webProgressListeners
=
new
Set
(
)
;
async
function
waitForInitialNavigationCompleted
(
webProgress
options
=
{
}
)
{
const
{
resolveWhenStarted
=
false
}
=
options
;
const
browsingContext
=
webProgress
.
browsingContext
;
const
listener
=
new
ProgressListener
(
webProgress
{
resolveWhenStarted
}
)
;
const
navigated
=
listener
.
start
(
)
;
let
isInitial
=
true
;
if
(
browsingContext
.
currentWindowGlobal
)
{
isInitial
=
browsingContext
.
currentWindowGlobal
.
isInitialDocument
;
}
if
(
!
isInitial
&
&
!
listener
.
isLoadingDocument
)
{
logger
.
trace
(
truncate
[
{
browsingContext
.
id
}
]
Document
already
finished
loading
:
{
browsingContext
.
currentURI
?
.
spec
}
)
;
listener
.
stop
(
)
;
}
await
navigated
;
return
{
currentURI
:
listener
.
currentURI
targetURI
:
listener
.
targetURI
}
;
}
class
ProgressListener
{
#
resolveWhenStarted
;
#
unloadTimeout
;
#
waitForExplicitStart
;
#
webProgress
;
#
resolve
;
#
seenStartFlag
;
#
targetURI
;
#
unloadTimerId
;
constructor
(
webProgress
options
=
{
}
)
{
const
{
resolveWhenStarted
=
false
unloadTimeout
=
200
waitForExplicitStart
=
false
}
=
options
;
this
.
#
resolveWhenStarted
=
resolveWhenStarted
;
this
.
#
unloadTimeout
=
unloadTimeout
;
this
.
#
waitForExplicitStart
=
waitForExplicitStart
;
this
.
#
webProgress
=
webProgress
;
this
.
#
resolve
=
null
;
this
.
#
seenStartFlag
=
false
;
this
.
#
targetURI
=
null
;
this
.
#
unloadTimerId
=
null
;
}
get
browsingContext
(
)
{
return
this
.
#
webProgress
.
browsingContext
;
}
get
currentURI
(
)
{
return
this
.
#
webProgress
.
browsingContext
.
currentURI
;
}
get
isLoadingDocument
(
)
{
return
this
.
#
webProgress
.
isLoadingDocument
;
}
get
isStarted
(
)
{
return
this
.
#
resolve
!
=
=
null
;
}
get
targetURI
(
)
{
return
this
.
#
targetURI
;
}
#
checkLoadingState
(
request
options
=
{
}
)
{
const
{
isStart
=
false
isStop
=
false
}
=
options
;
const
messagePrefix
=
[
{
this
.
browsingContext
.
id
}
]
{
this
.
constructor
.
name
}
;
if
(
isStart
&
&
!
this
.
#
seenStartFlag
)
{
this
.
#
seenStartFlag
=
true
;
this
.
#
targetURI
=
this
.
#
getTargetURI
(
request
)
;
logger
.
trace
(
truncate
{
messagePrefix
}
state
=
start
:
{
this
.
targetURI
?
.
spec
}
)
;
if
(
this
.
#
unloadTimerId
!
=
=
null
)
{
clearTimeout
(
this
.
#
unloadTimerId
)
;
this
.
#
unloadTimerId
=
null
;
}
if
(
this
.
#
resolveWhenStarted
)
{
this
.
stop
(
)
;
return
;
}
}
if
(
isStop
&
&
this
.
#
seenStartFlag
)
{
logger
.
trace
(
truncate
{
messagePrefix
}
state
=
stop
:
{
this
.
currentURI
.
spec
}
)
;
if
(
!
this
.
browsingContext
.
currentWindowGlobal
.
isInitialDocument
)
{
this
.
stop
(
)
;
return
;
}
logger
.
trace
(
{
messagePrefix
}
Initial
document
loaded
.
Wait
for
a
potential
further
navigation
.
)
;
this
.
#
seenStartFlag
=
false
;
this
.
#
setUnloadTimer
(
)
;
}
}
#
getTargetURI
(
request
)
{
try
{
return
request
.
QueryInterface
(
Ci
.
nsIChannel
)
.
originalURI
;
}
catch
(
e
)
{
}
return
null
;
}
#
setUnloadTimer
(
)
{
this
.
#
unloadTimerId
=
setTimeout
(
(
)
=
>
{
logger
.
trace
(
truncate
[
{
this
.
browsingContext
.
id
}
]
No
navigation
detected
:
{
this
.
currentURI
?
.
spec
}
)
;
this
.
#
targetURI
=
this
.
currentURI
;
this
.
stop
(
)
;
}
this
.
#
unloadTimeout
)
;
}
onStateChange
(
progress
request
flag
status
)
{
this
.
#
checkLoadingState
(
request
{
isStart
:
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
isStop
:
flag
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
}
)
;
}
start
(
)
{
if
(
this
.
#
resolve
)
{
throw
new
Error
(
Progress
listener
already
started
)
;
}
if
(
this
.
#
webProgress
.
isLoadingDocument
)
{
this
.
#
targetURI
=
this
.
#
getTargetURI
(
this
.
#
webProgress
.
documentRequest
)
;
if
(
this
.
#
resolveWhenStarted
)
{
return
Promise
.
resolve
(
)
;
}
}
const
promise
=
new
Promise
(
resolve
=
>
(
this
.
#
resolve
=
resolve
)
)
;
this
.
#
webProgress
.
addProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
)
;
webProgressListeners
.
add
(
this
)
;
if
(
this
.
#
webProgress
.
isLoadingDocument
&
&
!
this
.
#
waitForExplicitStart
)
{
this
.
#
checkLoadingState
(
this
.
#
webProgress
.
documentRequest
{
isStart
:
true
}
)
;
}
else
{
this
.
#
setUnloadTimer
(
)
;
}
return
promise
;
}
stop
(
)
{
if
(
!
this
.
#
resolve
)
{
throw
new
Error
(
Progress
listener
not
yet
started
)
;
}
clearTimeout
(
this
.
#
unloadTimerId
)
;
this
.
#
unloadTimerId
=
null
;
this
.
#
webProgress
.
removeProgressListener
(
this
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
)
;
webProgressListeners
.
delete
(
this
)
;
if
(
!
this
.
#
targetURI
)
{
this
.
#
targetURI
=
this
.
browsingContext
.
currentURI
;
}
this
.
#
resolve
(
)
;
this
.
#
resolve
=
null
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
]
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsIWebProgressListener
"
"
nsISupportsWeakReference
"
]
)
;
}
}
