"
use
strict
"
;
const
{
isInitialDocument
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
transports
/
BrowsingContextUtils
.
sys
.
mjs
"
)
;
const
{
RootMessageHandler
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
RootMessageHandler
.
sys
.
mjs
"
)
;
const
{
PromiseTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
sys
.
mjs
"
)
;
PromiseTestUtils
.
allowMatchingRejectionsGlobally
(
/
Actor
'
MessageHandlerFrame
'
destroyed
before
query
'
MessageHandlerFrameParent
:
sendCommand
'
was
resolved
/
)
;
add_task
(
async
function
test_default_retry
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
https
:
/
/
example
.
com
/
document
-
builder
.
sjs
?
html
=
tab
"
)
;
let
rootMessageHandler
=
createRootMessageHandler
(
"
session
-
id
-
retry
"
)
;
try
{
const
initialBrowsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
ok
(
isInitialDocument
(
initialBrowsingContext
)
"
Module
method
needs
to
run
in
the
initial
document
"
)
;
info
(
"
Call
a
module
method
which
will
throw
"
)
;
const
onBlockedOneTime
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedOneTime
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
initialBrowsingContext
.
id
}
}
)
;
await
onBlockedOneTime
;
ok
(
!
isInitialDocument
(
tab
.
linkedBrowser
.
browsingContext
)
"
module
method
to
be
successful
"
)
;
}
finally
{
await
cleanup
(
rootMessageHandler
tab
false
)
;
}
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
https
:
/
/
example
.
com
/
document
-
builder
.
sjs
?
html
=
tab
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
try
{
rootMessageHandler
=
createRootMessageHandler
(
"
session
-
id
-
no
-
retry
"
)
;
const
browsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
info
(
"
Call
a
module
method
which
will
throw
"
)
;
const
onBlockedOneTime
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedOneTime
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
}
)
;
await
BrowserTestUtils
.
reloadTab
(
tab
)
;
await
onBlockedOneTime
;
}
finally
{
await
cleanup
(
rootMessageHandler
tab
)
;
}
}
)
;
add_task
(
async
function
test_forced_no_retry
(
)
{
const
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
https
:
/
/
example
.
com
/
document
-
builder
.
sjs
?
html
=
tab
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
const
browsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
const
rootMessageHandler
=
createRootMessageHandler
(
"
session
-
id
-
no
-
retry
"
)
;
try
{
info
(
"
Call
a
module
method
which
will
throw
"
)
;
const
onBlockedOneTime
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedOneTime
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
retryOnAbort
:
false
}
)
;
await
BrowserTestUtils
.
reloadTab
(
tab
)
;
await
Assert
.
rejects
(
onBlockedOneTime
e
=
>
e
.
name
=
=
"
DiscardedBrowsingContextError
"
"
Caught
the
expected
error
when
reloading
"
)
;
}
finally
{
await
cleanup
(
rootMessageHandler
tab
)
;
}
}
)
;
add_task
(
async
function
test_forced_no_retry_cross_group
(
)
{
const
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
https
:
/
/
example
.
com
/
document
-
builder
.
sjs
?
html
=
COM
"
+
"
<
script
type
=
'
text
/
javascript
'
>
window
.
onunload
=
function
(
)
{
}
;
<
/
script
>
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
const
browsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
const
rootMessageHandler
=
createRootMessageHandler
(
"
session
-
id
-
no
-
retry
"
)
;
try
{
const
onBlockedOneTime
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedOneTime
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
retryOnAbort
:
false
}
)
;
const
onDiscarded
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
waitForDiscardedBrowsingContext
"
destination
:
{
type
:
RootMessageHandler
.
type
}
params
:
{
browsingContext
retryOnAbort
:
false
}
}
)
;
ok
(
!
(
await
hasPromiseResolved
(
onBlockedOneTime
)
)
"
blockedOneTime
should
not
have
resolved
yet
"
)
;
info
(
"
Navigate
to
example
.
net
with
COOP
headers
to
destroy
browsing
context
"
)
;
await
loadURL
(
tab
.
linkedBrowser
"
https
:
/
/
example
.
net
/
document
-
builder
.
sjs
?
headers
=
Cross
-
Origin
-
Opener
-
Policy
:
same
-
origin
&
html
=
NET
"
)
;
await
Assert
.
rejects
(
onBlockedOneTime
e
=
>
e
.
name
=
=
"
DiscardedBrowsingContextError
"
"
Caught
the
expected
error
when
navigating
"
)
;
await
Assert
.
rejects
(
onDiscarded
e
=
>
e
.
name
=
=
"
DiscardedBrowsingContextError
"
"
Caught
the
expected
error
when
navigating
"
)
;
}
finally
{
await
cleanup
(
rootMessageHandler
tab
)
;
}
}
)
;
add_task
(
async
function
test_forced_retry
(
)
{
const
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
https
:
/
/
example
.
com
/
document
-
builder
.
sjs
?
html
=
tab
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
const
browsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
const
rootMessageHandler
=
createRootMessageHandler
(
"
session
-
id
-
retry
"
)
;
try
{
const
onBlockedOneTime
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedOneTime
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
params
:
{
foo
:
"
bar
"
}
retryOnAbort
:
true
}
)
;
const
onBlockedTenTimes
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedTenTimes
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
params
:
{
foo
:
"
baz
"
}
retryOnAbort
:
true
}
)
;
const
onBlockedElevenTimes
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedElevenTimes
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
retryOnAbort
:
true
}
)
;
info
(
"
Reload
one
time
"
)
;
await
BrowserTestUtils
.
reloadTab
(
tab
)
;
info
(
"
blockedOneTime
should
resolve
on
the
first
retry
"
)
;
let
{
callsToCommand
foo
}
=
await
onBlockedOneTime
;
is
(
callsToCommand
2
"
The
command
was
called
twice
(
initial
call
+
1
retry
)
"
)
;
is
(
foo
"
bar
"
"
The
parameter
was
sent
when
the
command
was
retried
"
)
;
for
(
let
i
=
2
;
i
<
11
;
i
+
+
)
{
info
(
"
blockedTenTimes
/
blockedElevenTimes
should
not
have
resolved
yet
"
)
;
ok
(
!
(
await
hasPromiseResolved
(
onBlockedTenTimes
)
)
)
;
ok
(
!
(
await
hasPromiseResolved
(
onBlockedElevenTimes
)
)
)
;
info
(
Reload
the
tab
(
time
:
{
i
}
)
)
;
await
BrowserTestUtils
.
reloadTab
(
tab
)
;
}
info
(
"
blockedTenTimes
should
resolve
on
the
10th
reload
"
)
;
(
{
callsToCommand
foo
}
=
await
onBlockedTenTimes
)
;
is
(
callsToCommand
11
"
The
command
was
called
11
times
(
initial
call
+
10
retry
)
"
)
;
is
(
foo
"
baz
"
"
The
parameter
was
sent
when
the
command
was
retried
"
)
;
info
(
"
Reload
one
more
time
"
)
;
await
BrowserTestUtils
.
reloadTab
(
tab
)
;
info
(
"
The
call
to
blockedElevenTimes
now
exceeds
the
maximum
attempts
allowed
"
)
;
await
Assert
.
rejects
(
onBlockedElevenTimes
e
=
>
e
.
name
=
=
"
DiscardedBrowsingContextError
"
"
Caught
the
expected
error
when
reloading
"
)
;
}
finally
{
await
cleanup
(
rootMessageHandler
tab
)
;
}
}
)
;
add_task
(
async
function
test_retry_cross_group
(
)
{
const
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
https
:
/
/
example
.
com
/
document
-
builder
.
sjs
?
html
=
COM
"
+
"
<
script
type
=
'
text
/
javascript
'
>
window
.
onunload
=
function
(
)
{
}
;
<
/
script
>
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
const
browsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
const
rootMessageHandler
=
createRootMessageHandler
(
"
session
-
id
-
retry
-
cross
-
group
"
)
;
try
{
const
onBlockedOnNetDomain
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedOnNetDomain
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
params
:
{
foo
:
"
bar
"
}
retryOnAbort
:
true
}
)
;
const
onDiscarded
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
waitForDiscardedBrowsingContext
"
destination
:
{
type
:
RootMessageHandler
.
type
}
params
:
{
browsingContext
retryOnAbort
:
true
}
}
)
;
info
(
"
Reload
one
time
"
)
;
await
BrowserTestUtils
.
reloadTab
(
tab
)
;
info
(
"
blockedOnNetDomain
should
not
have
resolved
yet
"
)
;
ok
(
!
(
await
hasPromiseResolved
(
onBlockedOnNetDomain
)
)
)
;
info
(
"
waitForDiscardedBrowsingContext
should
not
have
resolved
yet
"
)
;
ok
(
!
(
await
hasPromiseResolved
(
onDiscarded
)
)
)
;
info
(
"
Navigate
to
example
.
net
with
COOP
headers
to
destroy
browsing
context
"
)
;
await
loadURL
(
tab
.
linkedBrowser
"
https
:
/
/
example
.
net
/
document
-
builder
.
sjs
?
headers
=
Cross
-
Origin
-
Opener
-
Policy
:
same
-
origin
&
html
=
NET
"
)
;
info
(
"
blockedOnNetDomain
should
resolve
now
"
)
;
let
{
foo
}
=
await
onBlockedOnNetDomain
;
is
(
foo
"
bar
"
"
The
parameter
was
sent
when
the
command
was
retried
"
)
;
info
(
"
waitForDiscardedBrowsingContext
should
resolve
now
"
)
;
await
onDiscarded
;
}
finally
{
await
cleanup
(
rootMessageHandler
tab
)
;
}
}
)
;
async
function
cleanup
(
rootMessageHandler
tab
)
{
const
browsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
await
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
cleanup
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
}
)
;
rootMessageHandler
.
destroy
(
)
;
gBrowser
.
removeTab
(
tab
)
;
}
