"
use
strict
"
;
var
{
ContextDescriptorType
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
sys
.
mjs
"
)
;
var
{
WindowGlobalMessageHandler
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
WindowGlobalMessageHandler
.
sys
.
mjs
"
)
;
var
contextDescriptorAll
=
{
type
:
ContextDescriptorType
.
All
}
;
function
createRootMessageHandler
(
sessionId
)
{
const
{
RootMessageHandlerRegistry
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
RootMessageHandlerRegistry
.
sys
.
mjs
"
)
;
return
RootMessageHandlerRegistry
.
getOrCreateMessageHandler
(
sessionId
)
;
}
async
function
loadURL
(
browser
url
)
{
const
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
)
;
BrowserTestUtils
.
startLoadingURIString
(
browser
url
)
;
return
loaded
;
}
async
function
addTab
(
url
)
{
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
registerCleanupFunction
(
(
)
=
>
{
gBrowser
.
removeTab
(
tab
)
;
}
)
;
return
tab
;
}
function
createFrame
(
domain
)
{
return
createFrameForUri
(
https
:
/
/
{
domain
}
/
document
-
builder
.
sjs
?
html
=
frame
-
{
domain
}
)
;
}
function
createFrameForUri
(
uri
)
{
return
<
iframe
src
=
"
{
encodeURI
(
uri
)
}
"
>
<
/
iframe
>
;
}
function
createParentBrowserElement
(
tab
type
)
{
const
parentBrowser
=
gBrowser
.
ownerDocument
.
createXULElement
(
"
browser
"
)
;
parentBrowser
.
setAttribute
(
"
type
"
type
)
;
const
container
=
gBrowser
.
getBrowserContainer
(
tab
.
linkedBrowser
)
;
container
.
appendChild
(
parentBrowser
)
;
return
parentBrowser
;
}
function
createTestMarkupWithFrames
(
)
{
const
NESTED_FRAME_MARKUP
=
createFrameForUri
(
https
:
/
/
example
.
org
/
document
-
builder
.
sjs
?
html
=
{
createFrame
(
"
example
.
net
"
)
}
)
;
const
TEST_URI_MARKUP
=
{
NESTED_FRAME_MARKUP
}
{
createFrame
(
"
example
.
com
"
)
}
;
return
https
:
/
/
example
.
org
/
document
-
builder
.
sjs
?
html
=
{
encodeURI
(
TEST_URI_MARKUP
)
}
;
}
const
hasPromiseResolved
=
async
function
(
promise
)
{
let
resolved
=
false
;
promise
.
finally
(
(
)
=
>
(
resolved
=
true
)
)
;
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
return
resolved
;
}
;
async
function
installSidebarExtension
(
)
{
info
(
"
Load
the
test
extension
"
)
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
sidebar_action
:
{
default_panel
:
"
sidebar
.
html
"
}
}
useAddonManager
:
"
temporary
"
files
:
{
"
sidebar
.
html
"
:
<
!
DOCTYPE
html
>
<
html
>
Test
extension
<
script
src
=
"
sidebar
.
js
"
>
<
/
script
>
<
/
html
>
"
sidebar
.
js
"
:
function
(
)
{
const
{
browser
}
=
this
;
browser
.
test
.
sendMessage
(
"
sidebar
-
loaded
"
{
bcId
:
SpecialPowers
.
wrap
(
window
)
.
browsingContext
.
id
}
)
;
}
"
tab
.
html
"
:
<
!
DOCTYPE
html
>
<
html
>
Test
extension
(
tab
)
<
script
src
=
"
tab
.
js
"
>
<
/
script
>
<
/
html
>
"
tab
.
js
"
:
function
(
)
{
const
{
browser
}
=
this
;
browser
.
test
.
sendMessage
(
"
tab
-
loaded
"
{
bcId
:
SpecialPowers
.
wrap
(
window
)
.
browsingContext
.
id
}
)
;
}
}
}
)
;
info
(
"
Wait
for
the
extension
to
start
"
)
;
await
extension
.
startup
(
)
;
info
(
"
Wait
for
the
extension
browsing
context
"
)
;
const
{
bcId
}
=
await
extension
.
awaitMessage
(
"
sidebar
-
loaded
"
)
;
const
sidebarBrowser
=
BrowsingContext
.
get
(
bcId
)
.
top
.
embedderElement
;
ok
(
sidebarBrowser
"
Got
a
browser
element
for
the
extension
sidebar
"
)
;
return
{
extension
sidebarBrowser
}
;
}
const
SessionDataUpdateHelpers
=
{
getUpdates
(
rootMessageHandler
browsingContext
)
{
return
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
sessiondataupdate
"
commandName
:
"
getSessionDataUpdates
"
destination
:
{
id
:
browsingContext
.
id
type
:
WindowGlobalMessageHandler
.
type
}
}
)
;
}
createSessionDataUpdate
(
values
method
category
descriptor
=
{
type
:
ContextDescriptorType
.
All
}
)
{
return
{
method
values
moduleName
:
"
sessiondataupdate
"
category
contextDescriptor
:
descriptor
}
;
}
assertUpdate
(
update
expectedValues
expectedCategory
)
{
is
(
update
.
length
expectedValues
.
length
"
Update
has
the
expected
number
of
values
"
)
;
for
(
const
item
of
update
)
{
info
(
Check
session
data
update
item
'
{
item
.
value
}
'
)
;
is
(
item
.
category
expectedCategory
"
Item
has
the
expected
category
"
)
;
is
(
expectedValues
[
update
.
indexOf
(
item
)
]
item
.
value
"
Item
has
the
expected
value
"
)
;
}
}
}
;
