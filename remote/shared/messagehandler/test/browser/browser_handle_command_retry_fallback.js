"
use
strict
"
;
const
{
isInitialDocument
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
transports
/
BrowsingContextUtils
.
sys
.
mjs
"
)
;
const
{
PromiseTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
sys
.
mjs
"
)
;
PromiseTestUtils
.
allowMatchingRejectionsGlobally
(
/
Actor
'
MessageHandlerFrame
'
destroyed
before
query
'
MessageHandlerFrameParent
:
sendCommand
'
was
resolved
/
)
;
add_task
(
async
function
test_default_fallback_retry_initial_document_only
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
https
:
/
/
example
.
com
/
document
-
builder
.
sjs
?
html
=
tab
"
)
;
let
rootMessageHandler
=
createRootMessageHandler
(
"
session
-
id
-
retry
-
initial
-
document
"
)
;
try
{
const
initialBrowsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
ok
(
isInitialDocument
(
initialBrowsingContext
)
"
Module
method
needs
to
run
in
the
initial
document
"
)
;
info
(
"
Call
a
module
method
which
will
throw
"
)
;
const
onBlockedOneTime
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedOneTime
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
initialBrowsingContext
.
id
}
}
)
;
await
onBlockedOneTime
;
ok
(
!
isInitialDocument
(
tab
.
linkedBrowser
.
browsingContext
)
"
module
method
to
be
successful
"
)
;
}
finally
{
await
cleanup
(
rootMessageHandler
tab
false
)
;
}
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
https
:
/
/
example
.
com
/
document
-
builder
.
sjs
?
html
=
tab
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
try
{
rootMessageHandler
=
createRootMessageHandler
(
"
session
-
id
-
no
-
retry
"
)
;
const
browsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
info
(
"
Call
a
module
method
which
will
throw
"
)
;
const
onBlockedOneTime
=
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
blockedOneTime
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
}
)
;
await
BrowserTestUtils
.
reloadTab
(
tab
)
;
await
Assert
.
rejects
(
onBlockedOneTime
e
=
>
e
.
name
=
=
"
AbortError
"
"
Caught
the
expected
abort
error
when
reloading
"
)
;
}
finally
{
await
cleanup
(
rootMessageHandler
tab
)
;
}
}
)
;
async
function
cleanup
(
rootMessageHandler
tab
)
{
const
browsingContext
=
tab
.
linkedBrowser
.
browsingContext
;
await
rootMessageHandler
.
handleCommand
(
{
moduleName
:
"
retry
"
commandName
:
"
cleanup
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
browsingContext
.
id
}
}
)
;
rootMessageHandler
.
destroy
(
)
;
gBrowser
.
removeTab
(
tab
)
;
}
