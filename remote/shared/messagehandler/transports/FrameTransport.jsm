"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
FrameTransport
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ContextDescriptorType
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
isBrowsingContextCompatible
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
transports
/
FrameContextUtils
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
MessageHandlerFrameActor
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
transports
/
js
-
window
-
actors
/
MessageHandlerFrameActor
.
jsm
"
TabManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
)
)
;
const
MAX_RETRY_ATTEMPTS
=
10
;
class
FrameTransport
{
constructor
(
messageHandler
)
{
this
.
_messageHandler
=
messageHandler
;
lazy
.
MessageHandlerFrameActor
.
register
(
)
;
}
forwardCommand
(
command
)
{
if
(
command
.
destination
.
id
&
&
command
.
destination
.
contextDescriptor
)
{
throw
new
Error
(
"
Invalid
command
destination
with
both
'
id
'
and
'
contextDescriptor
'
properties
"
)
;
}
if
(
command
.
destination
.
id
)
{
const
browsingContext
=
BrowsingContext
.
get
(
command
.
destination
.
id
)
;
if
(
!
browsingContext
)
{
throw
new
Error
(
"
Unable
to
find
a
BrowsingContext
for
id
"
+
command
.
destination
.
id
)
;
}
return
this
.
_sendCommandToBrowsingContext
(
command
browsingContext
)
;
}
if
(
command
.
destination
.
contextDescriptor
)
{
return
this
.
_broadcastCommand
(
command
)
;
}
throw
new
Error
(
"
Unrecognized
command
destination
missing
'
id
'
or
'
contextDescriptor
'
properties
"
)
;
}
_broadcastCommand
(
command
)
{
const
{
contextDescriptor
}
=
command
.
destination
;
const
browsingContexts
=
this
.
_getBrowsingContextsForDescriptor
(
contextDescriptor
)
;
return
Promise
.
all
(
browsingContexts
.
map
(
async
browsingContext
=
>
{
try
{
return
await
this
.
_sendCommandToBrowsingContext
(
command
browsingContext
)
;
}
catch
(
e
)
{
console
.
error
(
Failed
to
broadcast
a
command
to
browsingContext
{
browsingContext
.
id
}
e
)
;
return
null
;
}
}
)
)
;
}
async
_sendCommandToBrowsingContext
(
command
browsingContext
)
{
const
name
=
{
command
.
moduleName
}
.
{
command
.
commandName
}
;
const
webProgress
=
browsingContext
.
webProgress
;
const
{
retryOnAbort
=
false
}
=
command
;
let
attempts
=
0
;
while
(
true
)
{
try
{
return
await
webProgress
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
MessageHandlerFrame
"
)
.
sendCommand
(
command
this
.
_messageHandler
.
sessionId
)
;
}
catch
(
e
)
{
if
(
!
retryOnAbort
|
|
e
.
name
!
=
"
AbortError
"
)
{
throw
e
;
}
if
(
+
+
attempts
>
MAX_RETRY_ATTEMPTS
)
{
lazy
.
logger
.
trace
(
FrameTransport
reached
the
limit
of
retry
attempts
(
{
MAX_RETRY_ATTEMPTS
}
)
+
for
command
{
name
}
and
browsing
context
{
webProgress
.
browsingContext
.
id
}
.
)
;
throw
e
;
}
lazy
.
logger
.
trace
(
FrameTransport
retrying
command
{
name
}
for
+
browsing
context
{
webProgress
.
browsingContext
.
id
}
attempt
:
{
attempts
}
.
)
;
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
}
}
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
{
this
.
_messageHandler
.
name
}
]
;
}
_getBrowsingContextsForDescriptor
(
contextDescriptor
)
{
const
{
id
type
}
=
contextDescriptor
;
if
(
type
=
=
=
lazy
.
ContextDescriptorType
.
All
)
{
return
this
.
_getBrowsingContexts
(
)
;
}
if
(
type
=
=
=
lazy
.
ContextDescriptorType
.
TopBrowsingContext
)
{
return
this
.
_getBrowsingContexts
(
{
browserId
:
id
}
)
;
}
throw
new
Error
(
Unsupported
contextDescriptor
type
for
broadcasting
:
{
type
}
)
;
}
_getBrowsingContexts
(
options
=
{
}
)
{
const
{
browserId
}
=
options
;
let
browsingContexts
=
[
]
;
for
(
const
{
browsingContext
}
of
lazy
.
TabManager
.
browsers
)
{
if
(
lazy
.
isBrowsingContextCompatible
(
browsingContext
{
browserId
}
)
)
{
browsingContexts
=
browsingContexts
.
concat
(
browsingContext
.
getAllBrowsingContextsInSubtree
(
)
)
;
}
}
return
browsingContexts
;
}
}
