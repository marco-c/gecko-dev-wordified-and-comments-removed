"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
FrameTransport
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
CONTEXT_DESCRIPTOR_TYPES
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
MessageHandlerFrameActor
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
transports
/
js
-
window
-
actors
/
MessageHandlerFrameActor
.
jsm
"
}
)
;
class
FrameTransport
{
constructor
(
messageHandler
)
{
this
.
_messageHandler
=
messageHandler
;
MessageHandlerFrameActor
.
register
(
)
;
}
forwardCommand
(
command
)
{
if
(
command
.
destination
.
id
&
&
command
.
destination
.
contextDescriptor
)
{
throw
new
Error
(
"
Invalid
command
destination
with
both
'
id
'
and
'
contextDescriptor
'
properties
"
)
;
}
if
(
command
.
destination
.
id
)
{
const
browsingContext
=
BrowsingContext
.
get
(
command
.
destination
.
id
)
;
if
(
!
browsingContext
)
{
throw
new
Error
(
"
Unable
to
find
a
BrowsingContext
for
id
"
+
command
.
destination
.
id
)
;
}
return
this
.
_sendCommandToBrowsingContext
(
command
browsingContext
)
;
}
if
(
command
.
destination
.
contextDescriptor
)
{
return
this
.
_broadcastCommand
(
command
)
;
}
throw
new
Error
(
"
Unrecognized
command
destination
missing
'
id
'
or
'
contextDescriptor
'
properties
"
)
;
}
_broadcastCommand
(
command
)
{
const
{
contextDescriptor
}
=
command
.
destination
;
const
browsingContexts
=
this
.
_getBrowsingContextsForDescriptor
(
contextDescriptor
)
;
return
Promise
.
all
(
browsingContexts
.
map
(
async
browsingContext
=
>
{
try
{
return
await
this
.
_sendCommandToBrowsingContext
(
command
browsingContext
)
;
}
catch
(
e
)
{
console
.
error
(
Failed
to
broadcast
a
command
to
browsingContext
{
browsingContext
.
id
}
e
)
;
return
null
;
}
}
)
)
;
}
_sendCommandToBrowsingContext
(
command
browsingContext
)
{
return
browsingContext
.
currentWindowGlobal
.
getActor
(
"
MessageHandlerFrame
"
)
.
sendCommand
(
command
this
.
_messageHandler
.
sessionId
)
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
{
this
.
_messageHandler
.
name
}
]
;
}
_getBrowsingContextsForDescriptor
(
contextDescriptor
)
{
const
{
id
type
}
=
contextDescriptor
;
if
(
type
=
=
=
CONTEXT_DESCRIPTOR_TYPES
.
ALL
)
{
return
this
.
_getBrowsingContexts
(
)
;
}
if
(
type
=
=
=
CONTEXT_DESCRIPTOR_TYPES
.
TOP_BROWSING_CONTEXT
)
{
return
this
.
_getBrowsingContexts
(
{
browserId
:
id
}
)
;
}
throw
new
Error
(
Unsupported
contextDescriptor
type
for
broadcasting
:
{
type
}
)
;
}
_getBrowsingContexts
(
options
=
{
}
)
{
const
{
browserId
}
=
options
;
let
browsingContexts
=
[
]
;
for
(
const
win
of
Services
.
ww
.
getWindowEnumerator
(
"
navigator
:
browser
"
)
)
{
if
(
!
win
.
gBrowser
)
{
continue
;
}
for
(
const
{
browsingContext
}
of
win
.
gBrowser
.
browsers
)
{
const
isChrome
=
browsingContext
.
currentWindowGlobal
.
osPid
=
=
=
-
1
;
const
isInitialDocument
=
browsingContext
.
currentWindowGlobal
.
isInitialDocument
;
if
(
isChrome
|
|
isInitialDocument
)
{
continue
;
}
if
(
typeof
browserId
!
=
=
"
undefined
"
&
&
browsingContext
.
browserId
!
=
=
browserId
)
{
continue
;
}
browsingContexts
=
browsingContexts
.
concat
(
browsingContext
.
getAllBrowsingContextsInSubtree
(
)
)
;
}
}
return
browsingContexts
;
}
}
