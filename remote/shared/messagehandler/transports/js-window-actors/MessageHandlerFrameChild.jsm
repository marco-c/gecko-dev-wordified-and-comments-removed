"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
MessageHandlerFrameChild
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Errors
.
jsm
"
isBrowsingContextCompatible
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
transports
/
FrameContextUtils
.
jsm
"
MessageHandlerRegistry
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandlerRegistry
.
jsm
"
WindowGlobalMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
WindowGlobalMessageHandler
.
jsm
"
}
)
;
class
MessageHandlerFrameChild
extends
JSWindowActorChild
{
actorCreated
(
)
{
this
.
type
=
WindowGlobalMessageHandler
.
type
;
this
.
context
=
this
.
manager
.
browsingContext
;
this
.
_registry
=
new
MessageHandlerRegistry
(
this
.
type
this
.
context
)
;
this
.
_onRegistryEvent
=
this
.
_onRegistryEvent
.
bind
(
this
)
;
this
.
_registry
.
on
(
"
message
-
handler
-
registry
-
event
"
this
.
_onRegistryEvent
)
;
}
handleEvent
(
{
type
}
)
{
if
(
type
=
=
"
DOMWindowCreated
"
)
{
if
(
isBrowsingContextCompatible
(
this
.
manager
.
browsingContext
)
)
{
this
.
_registry
.
createAllMessageHandlers
(
)
;
}
}
}
async
receiveMessage
(
message
)
{
if
(
message
.
name
=
=
=
"
MessageHandlerFrameParent
:
sendCommand
"
)
{
const
{
sessionId
command
}
=
message
.
data
;
const
messageHandler
=
this
.
_registry
.
getOrCreateMessageHandler
(
sessionId
)
;
try
{
return
await
messageHandler
.
handleCommand
(
command
)
;
}
catch
(
e
)
{
if
(
e
instanceof
error
.
MessageHandlerError
)
{
return
{
error
:
e
.
toJSON
(
)
}
;
}
throw
e
;
}
}
return
null
;
}
_onRegistryEvent
(
eventName
wrappedEvent
)
{
this
.
sendAsyncMessage
(
"
MessageHandlerFrameChild
:
messageHandlerEvent
"
wrappedEvent
)
;
}
didDestroy
(
)
{
this
.
_registry
.
off
(
"
message
-
handler
-
registry
-
event
"
this
.
_onRegistryEvent
)
;
this
.
_registry
.
destroy
(
)
;
}
}
