"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
RootMessageHandler
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
ContextDescriptorType
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
FrameTransport
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
transports
/
FrameTransport
.
jsm
"
MessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
SessionData
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
sessiondata
/
SessionData
.
jsm
"
WindowGlobalMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
WindowGlobalMessageHandler
.
jsm
"
}
)
;
class
RootMessageHandler
extends
MessageHandler
{
static
get
modulePath
(
)
{
return
"
root
"
;
}
static
get
type
(
)
{
return
"
ROOT
"
;
}
static
getIdFromContext
(
context
)
{
return
RootMessageHandler
.
type
;
}
constructor
(
sessionId
)
{
super
(
sessionId
null
)
;
this
.
_frameTransport
=
new
FrameTransport
(
this
)
;
this
.
_sessionData
=
new
SessionData
(
this
)
;
}
get
sessionData
(
)
{
return
this
.
_sessionData
;
}
destroy
(
)
{
this
.
_sessionData
.
destroy
(
)
;
super
.
destroy
(
)
;
}
addSessionData
(
sessionData
=
{
}
)
{
return
this
.
_updateSessionData
(
sessionData
{
mode
:
"
add
"
}
)
;
}
forwardCommand
(
command
)
{
switch
(
command
.
destination
.
type
)
{
case
WindowGlobalMessageHandler
.
type
:
return
this
.
_frameTransport
.
forwardCommand
(
command
)
;
default
:
throw
new
Error
(
Cannot
forward
command
to
"
{
command
.
destination
.
type
}
"
from
"
{
this
.
constructor
.
type
}
"
.
)
;
}
}
removeSessionData
(
sessionData
=
{
}
)
{
return
this
.
_updateSessionData
(
sessionData
{
mode
:
"
remove
"
}
)
;
}
_updateSessionData
(
sessionData
options
=
{
}
)
{
const
{
mode
}
=
options
;
if
(
mode
!
=
"
add
"
&
&
mode
!
=
"
remove
"
)
{
throw
new
Error
(
Unsupported
mode
for
_updateSessionData
{
mode
}
)
;
}
const
{
moduleName
category
contextDescriptor
values
}
=
sessionData
;
const
isAdding
=
mode
=
=
=
"
add
"
;
const
updateMethod
=
isAdding
?
"
addSessionData
"
:
"
removeSessionData
"
;
const
updatedValues
=
this
.
_sessionData
[
updateMethod
]
(
moduleName
category
contextDescriptor
values
)
;
if
(
updatedValues
.
length
=
=
0
)
{
return
[
]
;
}
const
destination
=
{
type
:
WindowGlobalMessageHandler
.
type
contextDescriptor
:
{
type
:
ContextDescriptorType
.
All
}
}
;
if
(
!
this
.
_moduleCache
.
hasModule
(
moduleName
destination
)
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
handleCommand
(
{
moduleName
commandName
:
"
_applySessionData
"
params
:
{
[
isAdding
?
"
added
"
:
"
removed
"
]
:
updatedValues
category
}
destination
}
)
;
}
}
