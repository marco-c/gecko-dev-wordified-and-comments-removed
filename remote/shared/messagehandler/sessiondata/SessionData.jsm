"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
SESSION_DATA_SHARED_DATA_KEY
"
"
SessionData
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
ContextDescriptorType
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
RootMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
RootMessageHandler
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
)
)
;
const
SESSION_DATA_SHARED_DATA_KEY
=
"
MessageHandlerSessionData
"
;
const
sessionDataMap
=
new
Map
(
)
;
class
SessionData
{
constructor
(
messageHandler
)
{
if
(
messageHandler
.
constructor
.
type
!
=
RootMessageHandler
.
type
)
{
throw
new
Error
(
"
SessionData
should
only
be
used
from
a
ROOT
MessageHandler
"
)
;
}
this
.
_messageHandler
=
messageHandler
;
this
.
_data
=
[
]
;
}
addSessionData
(
moduleName
category
contextDescriptor
values
)
{
const
addedValues
=
[
]
;
for
(
const
value
of
values
)
{
const
item
=
{
moduleName
category
contextDescriptor
value
}
;
const
hasItem
=
this
.
_data
.
some
(
_item
=
>
this
.
_isSameItem
(
item
_item
)
)
;
if
(
!
hasItem
)
{
this
.
_data
.
push
(
item
)
;
addedValues
.
push
(
value
)
;
}
else
{
logger
.
warn
(
Duplicated
session
data
item
was
not
added
:
{
JSON
.
stringify
(
item
)
}
)
;
}
}
this
.
_persist
(
)
;
return
addedValues
;
}
destroy
(
)
{
sessionDataMap
.
delete
(
this
.
_messageHandler
.
sessionId
)
;
Services
.
ppmm
.
sharedData
.
set
(
SESSION_DATA_SHARED_DATA_KEY
sessionDataMap
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
}
getSessionData
(
moduleName
category
contextDescriptor
)
{
return
this
.
_data
.
filter
(
item
=
>
item
.
moduleName
=
=
=
moduleName
&
&
item
.
category
=
=
=
category
&
&
(
!
contextDescriptor
|
|
this
.
_isSameContextDescriptor
(
item
.
contextDescriptor
contextDescriptor
)
)
)
;
}
removeSessionData
(
moduleName
category
contextDescriptor
values
)
{
const
removedValues
=
[
]
;
for
(
const
value
of
values
)
{
const
item
=
{
moduleName
category
contextDescriptor
value
}
;
const
itemIndex
=
this
.
_data
.
findIndex
(
_item
=
>
this
.
_isSameItem
(
item
_item
)
)
;
if
(
itemIndex
!
=
-
1
)
{
this
.
_data
.
splice
(
itemIndex
1
)
;
removedValues
.
push
(
value
)
;
}
else
{
logger
.
warn
(
Missing
session
data
item
was
not
removed
:
{
JSON
.
stringify
(
item
)
}
)
;
}
}
this
.
_persist
(
)
;
return
removedValues
;
}
updateSessionData
(
moduleName
category
contextDescriptor
added
removed
)
{
this
.
addSessionData
(
moduleName
category
contextDescriptor
added
)
;
this
.
removeSessionData
(
moduleName
category
contextDescriptor
removed
)
;
}
_isSameItem
(
item1
item2
)
{
const
descriptor1
=
item1
.
contextDescriptor
;
const
descriptor2
=
item2
.
contextDescriptor
;
return
(
item1
.
moduleName
=
=
=
item2
.
moduleName
&
&
item1
.
category
=
=
=
item2
.
category
&
&
this
.
_isSameContextDescriptor
(
descriptor1
descriptor2
)
&
&
item1
.
value
=
=
=
item2
.
value
)
;
}
_isSameContextDescriptor
(
contextDescriptor1
contextDescriptor2
)
{
if
(
contextDescriptor1
.
type
=
=
=
ContextDescriptorType
.
All
)
{
return
contextDescriptor1
.
type
=
=
=
contextDescriptor2
.
type
;
}
return
(
contextDescriptor1
.
type
=
=
=
contextDescriptor2
.
type
&
&
contextDescriptor1
.
id
=
=
=
contextDescriptor2
.
id
)
;
}
_persist
(
)
{
sessionDataMap
.
set
(
this
.
_messageHandler
.
sessionId
this
.
_data
)
;
Services
.
ppmm
.
sharedData
.
set
(
SESSION_DATA_SHARED_DATA_KEY
sessionDataMap
)
;
Services
.
ppmm
.
sharedData
.
flush
(
)
;
}
}
