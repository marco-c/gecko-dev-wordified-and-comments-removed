"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ContextDescriptorType
"
"
MessageHandler
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
EventEmitter
:
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Errors
.
jsm
"
EventsDispatcher
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
EventsDispatcher
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
ModuleCache
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
ModuleCache
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
)
)
;
const
ContextDescriptorType
=
{
All
:
"
All
"
TopBrowsingContext
:
"
TopBrowsingContext
"
}
;
class
MessageHandler
extends
EventEmitter
{
constructor
(
sessionId
context
)
{
super
(
)
;
this
.
_moduleCache
=
new
ModuleCache
(
this
)
;
this
.
_sessionId
=
sessionId
;
this
.
_context
=
context
;
this
.
_contextId
=
this
.
constructor
.
getIdFromContext
(
context
)
;
this
.
_eventsDispatcher
=
new
EventsDispatcher
(
this
)
;
}
get
contextId
(
)
{
return
this
.
_contextId
;
}
get
eventsDispatcher
(
)
{
return
this
.
_eventsDispatcher
;
}
get
name
(
)
{
return
[
this
.
sessionId
this
.
constructor
.
type
this
.
contextId
]
.
join
(
"
-
"
)
;
}
get
sessionId
(
)
{
return
this
.
_sessionId
;
}
destroy
(
)
{
logger
.
trace
(
MessageHandler
{
this
.
constructor
.
type
}
for
session
{
this
.
sessionId
}
is
being
destroyed
)
;
this
.
_eventsDispatcher
.
destroy
(
)
;
this
.
_moduleCache
.
destroy
(
)
;
this
.
emit
(
"
message
-
handler
-
destroyed
"
this
)
;
}
emitEvent
(
name
data
options
=
{
}
)
{
const
{
isProtocolEvent
=
false
}
=
options
;
this
.
emit
(
"
message
-
handler
-
event
"
{
name
data
isProtocolEvent
sessionId
:
this
.
sessionId
}
)
;
if
(
!
isProtocolEvent
)
{
this
.
emit
(
name
data
)
;
}
}
getAllModuleClasses
(
moduleName
destination
)
{
return
this
.
_moduleCache
.
getAllModuleClasses
(
moduleName
destination
)
;
}
handleCommand
(
command
)
{
const
{
moduleName
commandName
params
destination
}
=
command
;
logger
.
trace
(
Received
command
{
moduleName
}
.
{
commandName
}
for
destination
{
destination
.
type
}
)
;
if
(
!
this
.
supportsCommand
(
moduleName
commandName
destination
)
)
{
throw
new
error
.
UnsupportedCommandError
(
{
moduleName
}
.
{
commandName
}
not
supported
for
destination
{
destination
?
.
type
}
)
;
}
const
module
=
this
.
_moduleCache
.
getModuleInstance
(
moduleName
destination
)
;
if
(
module
&
&
module
.
supportsMethod
(
commandName
)
)
{
return
module
[
commandName
]
(
params
destination
)
;
}
return
this
.
forwardCommand
(
command
)
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
{
this
.
name
}
]
;
}
async
applyInitialSessionDataItems
(
sessionDataItems
)
{
}
static
get
modulePath
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
static
get
type
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
static
getIdFromContext
(
context
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
forwardCommand
(
command
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
supportsCommand
(
moduleName
commandName
destination
)
{
return
this
.
getAllModuleClasses
(
moduleName
destination
)
.
some
(
cls
=
>
cls
.
supportsMethod
(
commandName
)
)
;
}
}
