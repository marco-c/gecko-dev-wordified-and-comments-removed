"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
MessageHandler
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
EventEmitter
:
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
ModuleCache
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
ModuleCache
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
)
)
;
class
MessageHandler
extends
EventEmitter
{
constructor
(
sessionId
context
)
{
super
(
)
;
this
.
_moduleCache
=
new
ModuleCache
(
this
)
;
this
.
_sessionId
=
sessionId
;
this
.
_context
=
context
;
this
.
_contextId
=
this
.
constructor
.
getIdFromContext
(
context
)
;
}
get
contextId
(
)
{
return
this
.
_contextId
;
}
get
name
(
)
{
return
[
this
.
sessionId
this
.
constructor
.
type
this
.
contextId
]
.
join
(
"
-
"
)
;
}
get
sessionId
(
)
{
return
this
.
_sessionId
;
}
checkCommand
(
command
)
{
const
{
commandName
destination
moduleName
}
=
command
;
const
moduleClasses
=
this
.
_moduleCache
.
getAllModuleClasses
(
moduleName
destination
)
;
if
(
!
moduleClasses
.
some
(
cls
=
>
cls
.
supportsMethod
(
commandName
)
)
)
{
throw
new
error
.
UnsupportedCommandError
(
{
moduleName
}
.
{
commandName
}
not
supported
for
destination
{
destination
?
.
type
}
)
;
}
}
destroy
(
)
{
logger
.
trace
(
MessageHandler
{
this
.
constructor
.
type
}
for
session
{
this
.
sessionId
}
is
being
destroyed
)
;
this
.
_moduleCache
.
destroy
(
)
;
this
.
emit
(
"
message
-
handler
-
destroyed
"
this
)
;
}
emitMessageHandlerEvent
(
method
params
)
{
this
.
emit
(
"
message
-
handler
-
event
"
{
method
params
sessionId
:
this
.
sessionId
}
)
;
}
handleCommand
(
command
)
{
const
{
moduleName
commandName
params
destination
}
=
command
;
logger
.
trace
(
Received
command
{
moduleName
}
.
{
commandName
}
for
destination
{
destination
.
type
}
)
;
this
.
checkCommand
(
command
)
;
const
module
=
this
.
_moduleCache
.
getModuleInstance
(
moduleName
destination
)
;
if
(
module
&
&
module
.
supportsMethod
(
commandName
)
)
{
return
module
[
commandName
]
(
params
destination
)
;
}
return
this
.
forwardCommand
(
command
)
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
{
this
.
name
}
]
;
}
static
get
modulePath
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
static
get
type
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
static
getIdFromContext
(
context
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
forwardCommand
(
command
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
}
