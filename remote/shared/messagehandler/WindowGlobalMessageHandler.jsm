"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
WindowGlobalMessageHandler
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
CONTEXT_DESCRIPTOR_TYPES
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
MessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
}
)
;
class
WindowGlobalMessageHandler
extends
MessageHandler
{
constructor
(
)
{
super
(
.
.
.
arguments
)
;
this
.
_innerWindowId
=
this
.
_context
.
window
.
windowGlobalChild
.
innerWindowId
;
}
static
get
modulePath
(
)
{
return
"
windowglobal
"
;
}
static
get
type
(
)
{
return
"
WINDOW_GLOBAL
"
;
}
static
getIdFromContext
(
context
)
{
return
context
.
id
;
}
get
innerWindowId
(
)
{
return
this
.
_innerWindowId
;
}
async
applyInitialSessionDataItems
(
sessionDataItems
)
{
if
(
!
Array
.
isArray
(
sessionDataItems
)
)
{
return
;
}
const
destination
=
{
type
:
WindowGlobalMessageHandler
.
type
}
;
for
(
const
sessionDataItem
of
sessionDataItems
)
{
const
{
moduleName
category
contextDescriptor
value
}
=
sessionDataItem
;
if
(
this
.
_isRelevantContext
(
contextDescriptor
)
)
{
if
(
!
this
.
_moduleCache
.
hasModule
(
moduleName
destination
)
)
{
continue
;
}
await
this
.
handleCommand
(
{
moduleName
commandName
:
"
_applySessionData
"
params
:
{
category
added
:
[
value
]
}
destination
}
)
;
}
}
this
.
emitEvent
(
"
window
-
global
-
handler
-
created
"
{
contextId
:
this
.
_contextId
innerWindowId
:
this
.
_innerWindowId
}
)
;
}
forwardCommand
(
command
)
{
throw
new
Error
(
Cannot
forward
commands
from
a
"
WINDOW_GLOBAL
"
MessageHandler
)
;
}
_isRelevantContext
(
contextDescriptor
)
{
return
contextDescriptor
.
type
=
=
=
CONTEXT_DESCRIPTOR_TYPES
.
ALL
;
}
}
