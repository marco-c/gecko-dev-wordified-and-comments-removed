"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
getMessageHandlerClass
"
"
MessageHandlerRegistry
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
MessageHandlerInfo
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandlerInfo
.
jsm
"
RootMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
RootMessageHandler
.
jsm
"
WindowGlobalMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
WindowGlobalMessageHandler
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
MessageHandlerClasses
"
(
)
=
>
new
Map
(
[
[
RootMessageHandler
.
type
RootMessageHandler
]
[
WindowGlobalMessageHandler
.
type
WindowGlobalMessageHandler
]
]
)
)
;
function
getMessageHandlerClass
(
type
)
{
if
(
!
MessageHandlerClasses
.
has
(
type
)
)
{
throw
new
Error
(
No
MessageHandler
class
available
for
type
"
{
type
}
"
)
;
}
return
MessageHandlerClasses
.
get
(
type
)
;
}
class
MessageHandlerRegistryClass
{
constructor
(
)
{
this
.
_messageHandlersMap
=
new
Map
(
)
;
this
.
_onMessageHandlerDestroyed
=
this
.
_onMessageHandlerDestroyed
.
bind
(
this
)
;
}
getExistingMessageHandler
(
sessionId
type
context
)
{
const
messageHandlerInfo
=
new
MessageHandlerInfo
(
sessionId
type
getMessageHandlerClass
(
type
)
.
getIdFromContext
(
context
)
)
;
return
this
.
_messageHandlersMap
.
get
(
messageHandlerInfo
.
key
)
;
}
contextDestroyed
(
context
type
)
{
const
MessageHandlerClass
=
getMessageHandlerClass
(
type
)
;
const
contextId
=
MessageHandlerClass
.
getIdFromContext
(
context
)
;
return
this
.
_messageHandlersMap
.
forEach
(
messageHandler
=
>
{
if
(
messageHandler
.
constructor
.
type
=
=
=
type
&
&
messageHandler
.
contextId
=
=
=
contextId
)
{
messageHandler
.
destroy
(
)
;
}
}
)
;
}
getOrCreateMessageHandler
(
sessionId
type
context
)
{
let
messageHandler
=
this
.
getExistingMessageHandler
(
sessionId
type
context
)
;
if
(
!
messageHandler
)
{
messageHandler
=
this
.
_createMessageHandler
(
sessionId
type
context
)
;
}
return
messageHandler
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
]
;
}
_createMessageHandler
(
sessionId
type
context
)
{
const
messageHandlerClass
=
getMessageHandlerClass
(
type
)
;
const
messageHandler
=
new
messageHandlerClass
(
sessionId
context
)
;
this
.
_registerMessageHandler
(
messageHandler
)
;
logger
.
trace
(
Created
MessageHandler
{
type
}
for
session
{
sessionId
}
)
;
messageHandler
.
on
(
"
message
-
handler
-
destroyed
"
this
.
_onMessageHandlerDestroyed
)
;
return
messageHandler
;
}
_registerMessageHandler
(
messageHandler
)
{
this
.
_messageHandlersMap
.
set
(
messageHandler
.
key
messageHandler
)
;
}
_unregisterMessageHandler
(
messageHandler
)
{
this
.
_messageHandlersMap
.
delete
(
messageHandler
.
key
)
;
logger
.
trace
(
Unregistered
MessageHandler
{
messageHandler
.
type
}
for
session
{
messageHandler
.
sessionId
}
)
;
}
_onMessageHandlerDestroyed
(
evt
messageHandler
)
{
messageHandler
.
off
(
"
message
-
handler
-
destroyed
"
this
.
_onMessageHandlerDestroyed
)
;
this
.
_unregisterMessageHandler
(
messageHandler
)
;
}
}
const
MessageHandlerRegistry
=
new
MessageHandlerRegistryClass
(
)
;
