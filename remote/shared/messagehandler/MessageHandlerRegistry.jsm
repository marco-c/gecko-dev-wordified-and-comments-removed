"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
getMessageHandlerClass
"
"
MessageHandlerRegistry
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
readSessionData
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
sessiondata
/
SessionDataReader
.
jsm
"
RootMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
RootMessageHandler
.
jsm
"
WindowGlobalMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
WindowGlobalMessageHandler
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
)
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
MessageHandlerClasses
"
(
)
=
>
new
Map
(
[
[
lazy
.
RootMessageHandler
.
type
lazy
.
RootMessageHandler
]
[
lazy
.
WindowGlobalMessageHandler
.
type
lazy
.
WindowGlobalMessageHandler
]
]
)
)
;
function
getMessageHandlerClass
(
type
)
{
if
(
!
lazy
.
MessageHandlerClasses
.
has
(
type
)
)
{
throw
new
Error
(
No
MessageHandler
class
available
for
type
"
{
type
}
"
)
;
}
return
lazy
.
MessageHandlerClasses
.
get
(
type
)
;
}
class
MessageHandlerRegistry
extends
EventEmitter
{
constructor
(
type
context
)
{
super
(
)
;
this
.
_messageHandlerClass
=
getMessageHandlerClass
(
type
)
;
this
.
_context
=
context
;
this
.
_type
=
type
;
this
.
_messageHandlersMap
=
new
Map
(
)
;
this
.
_onMessageHandlerDestroyed
=
this
.
_onMessageHandlerDestroyed
.
bind
(
this
)
;
this
.
_onMessageHandlerEvent
=
this
.
_onMessageHandlerEvent
.
bind
(
this
)
;
}
createAllMessageHandlers
(
)
{
const
data
=
lazy
.
readSessionData
(
)
;
for
(
const
[
sessionId
sessionDataItems
]
of
data
)
{
this
.
_createMessageHandler
(
sessionId
sessionDataItems
)
;
}
}
destroy
(
)
{
this
.
_messageHandlersMap
.
forEach
(
messageHandler
=
>
{
messageHandler
.
destroy
(
)
;
}
)
;
}
getAllMessageHandlers
(
)
{
return
this
.
_messageHandlersMap
.
values
(
)
;
}
getExistingMessageHandler
(
sessionId
)
{
return
this
.
_messageHandlersMap
.
get
(
sessionId
)
;
}
getOrCreateMessageHandler
(
sessionId
)
{
let
messageHandler
=
this
.
getExistingMessageHandler
(
sessionId
)
;
if
(
!
messageHandler
)
{
messageHandler
=
this
.
_createMessageHandler
(
sessionId
)
;
}
return
messageHandler
;
}
getRootMessageHandler
(
sessionId
)
{
const
rootMessageHandler
=
this
.
getExistingMessageHandler
(
sessionId
lazy
.
RootMessageHandler
.
type
)
;
if
(
!
rootMessageHandler
)
{
throw
new
Error
(
Unable
to
find
a
root
MessageHandler
for
session
id
{
sessionId
}
)
;
}
return
rootMessageHandler
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
]
;
}
_createMessageHandler
(
sessionId
sessionDataItems
)
{
const
messageHandler
=
new
this
.
_messageHandlerClass
(
sessionId
this
.
_context
)
;
messageHandler
.
on
(
"
message
-
handler
-
destroyed
"
this
.
_onMessageHandlerDestroyed
)
;
messageHandler
.
on
(
"
message
-
handler
-
event
"
this
.
_onMessageHandlerEvent
)
;
messageHandler
.
applyInitialSessionDataItems
(
sessionDataItems
)
;
this
.
_messageHandlersMap
.
set
(
sessionId
messageHandler
)
;
lazy
.
logger
.
trace
(
Created
MessageHandler
{
this
.
_type
}
for
session
{
sessionId
}
)
;
return
messageHandler
;
}
_onMessageHandlerDestroyed
(
eventName
messageHandler
)
{
messageHandler
.
off
(
"
message
-
handler
-
destroyed
"
this
.
_onMessageHandlerDestroyed
)
;
messageHandler
.
off
(
"
message
-
handler
-
event
"
this
.
_onMessageHandlerEvent
)
;
this
.
_messageHandlersMap
.
delete
(
messageHandler
.
sessionId
)
;
lazy
.
logger
.
trace
(
Unregistered
MessageHandler
{
messageHandler
.
constructor
.
type
}
for
session
{
messageHandler
.
sessionId
}
)
;
}
_onMessageHandlerEvent
(
eventName
messageHandlerEvent
)
{
this
.
emit
(
"
message
-
handler
-
registry
-
event
"
messageHandlerEvent
)
;
}
}
