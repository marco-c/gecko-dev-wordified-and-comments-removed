"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
Module
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ContextDescriptorType
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
disabledExperimentalAPI
"
(
)
=
>
{
return
!
Services
.
prefs
.
getBoolPref
(
"
remote
.
experimental
.
enabled
"
)
;
}
)
;
class
Module
{
#
messageHandler
;
constructor
(
messageHandler
)
{
this
.
#
messageHandler
=
messageHandler
;
}
addEventSessionData
(
moduleName
event
)
{
return
this
.
messageHandler
.
addSessionData
(
{
moduleName
category
:
"
event
"
contextDescriptor
:
{
type
:
lazy
.
ContextDescriptorType
.
All
}
values
:
[
event
]
}
)
;
}
destroy
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
emitEvent
(
name
data
)
{
this
.
messageHandler
.
emitEvent
(
name
data
)
;
}
interceptEvent
(
name
payload
)
{
throw
new
Error
(
Could
not
intercept
event
{
name
}
interceptEvent
is
not
implemented
in
windowglobal
-
in
-
root
module
)
;
}
assertExperimentalCommandsEnabled
(
methodName
)
{
if
(
lazy
.
disabledExperimentalAPI
)
{
throw
new
lazy
.
error
.
UnknownCommandError
(
methodName
)
;
}
}
assertExperimentalEventsEnabled
(
moduleName
event
)
{
if
(
lazy
.
disabledExperimentalAPI
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Module
{
moduleName
}
does
not
support
event
{
event
}
)
;
}
}
removeEventSessionData
(
moduleName
event
)
{
return
this
.
messageHandler
.
removeSessionData
(
{
moduleName
category
:
"
event
"
contextDescriptor
:
{
type
:
lazy
.
ContextDescriptorType
.
All
}
values
:
[
event
]
}
)
;
}
supportsMethod
(
methodName
)
{
return
this
.
constructor
.
supportsMethod
(
methodName
)
;
}
get
messageHandler
(
)
{
return
this
.
#
messageHandler
;
}
static
get
supportedEvents
(
)
{
return
[
]
;
}
static
supportsEvent
(
event
)
{
return
(
this
.
supportsMethod
(
"
_subscribeEvent
"
)
&
&
this
.
supportedEvents
.
includes
(
event
)
)
;
}
static
supportsMethod
(
methodName
)
{
return
typeof
this
.
prototype
[
methodName
]
=
=
=
"
function
"
;
}
}
