"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ModuleCache
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
modules
/
ModuleRegistry
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
getMessageHandlerClass
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandlerRegistry
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
)
)
;
const
MODULES_FOLDER
=
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
modules
"
;
const
TEST_MODULES_FOLDER
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
remote
/
shared
/
messagehandler
/
test
/
browser
/
resources
/
modules
"
;
class
ModuleCache
{
constructor
(
messageHandler
)
{
this
.
messageHandler
=
messageHandler
;
this
.
_messageHandlerPath
=
messageHandler
.
constructor
.
modulePath
;
this
.
_modulesRootFolder
=
MODULES_FOLDER
;
if
(
Services
.
prefs
.
getBoolPref
(
"
remote
.
messagehandler
.
modulecache
.
useBrowserTestRoot
"
false
)
)
{
this
.
_modulesRootFolder
=
TEST_MODULES_FOLDER
;
}
this
.
_modules
=
new
Map
(
)
;
}
destroy
(
)
{
this
.
_modules
.
forEach
(
module
=
>
module
?
.
destroy
(
)
)
;
}
getModuleInstance
(
moduleName
destination
)
{
const
moduleFullPath
=
this
.
_getModuleFullPath
(
moduleName
destination
)
;
if
(
!
this
.
_modules
.
has
(
moduleFullPath
)
)
{
try
{
const
ModuleClass
=
ChromeUtils
.
import
(
moduleFullPath
)
[
moduleName
]
;
this
.
_modules
.
set
(
moduleFullPath
new
ModuleClass
(
this
.
messageHandler
)
)
;
logger
.
trace
(
Module
{
moduleName
}
created
for
{
moduleFullPath
}
)
;
}
catch
(
e
)
{
this
.
_modules
.
set
(
moduleFullPath
null
)
;
logger
.
trace
(
No
module
{
moduleName
}
found
for
{
moduleFullPath
}
)
;
}
}
return
this
.
_modules
.
get
(
moduleFullPath
)
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
{
this
.
messageHandler
.
name
}
]
;
}
_getModuleFullPath
(
moduleName
destination
)
{
let
moduleFolder
;
if
(
this
.
messageHandler
.
constructor
.
type
=
=
=
destination
.
type
)
{
moduleFolder
=
this
.
_messageHandlerPath
;
}
else
{
const
MessageHandlerClass
=
getMessageHandlerClass
(
destination
.
type
)
;
const
destinationPath
=
MessageHandlerClass
.
modulePath
;
moduleFolder
=
{
destinationPath
}
-
in
-
{
this
.
_messageHandlerPath
}
;
}
return
{
this
.
_modulesRootFolder
}
/
{
moduleFolder
}
/
{
moduleName
}
.
jsm
;
}
}
