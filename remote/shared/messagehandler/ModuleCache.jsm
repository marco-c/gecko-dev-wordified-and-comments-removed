"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ModuleCache
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
getMessageHandlerClass
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandlerRegistry
.
jsm
"
}
)
;
const
MODULES_FOLDER
=
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
modules
"
;
class
ModuleCache
{
constructor
(
messageHandler
)
{
this
.
messageHandler
=
messageHandler
;
this
.
_messageHandlerPath
=
messageHandler
.
constructor
.
modulePath
;
this
.
_modules
=
new
Map
(
)
;
}
destroy
(
)
{
this
.
_modules
.
forEach
(
module
=
>
module
?
.
destroy
(
)
)
;
}
getModuleInstance
(
moduleName
destination
)
{
const
moduleFullPath
=
this
.
_getModuleFullPath
(
moduleName
destination
)
;
if
(
!
this
.
_modules
.
has
(
moduleFullPath
)
)
{
try
{
const
ModuleClass
=
ChromeUtils
.
import
(
moduleFullPath
)
[
moduleName
]
;
this
.
_modules
.
set
(
moduleFullPath
new
ModuleClass
(
this
.
messageHandler
)
)
;
}
catch
(
e
)
{
this
.
_modules
.
set
(
moduleFullPath
null
)
;
}
}
return
this
.
_modules
.
get
(
moduleFullPath
)
;
}
_getModuleFullPath
(
moduleName
destination
)
{
let
moduleFolder
;
if
(
this
.
messageHandler
.
constructor
.
type
=
=
=
destination
.
type
)
{
moduleFolder
=
this
.
_messageHandlerPath
;
}
else
{
const
MessageHandlerClass
=
getMessageHandlerClass
(
destination
.
type
)
;
const
destinationPath
=
MessageHandlerClass
.
modulePath
;
moduleFolder
=
{
destinationPath
}
-
in
-
{
this
.
_messageHandlerPath
}
;
}
return
{
MODULES_FOLDER
}
/
{
moduleFolder
}
/
{
moduleName
}
.
jsm
;
}
}
