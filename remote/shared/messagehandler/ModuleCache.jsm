"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
ModuleCache
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
getMessageHandlerClass
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandlerRegistry
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
}
)
;
const
protocols
=
{
bidi
:
{
}
test
:
{
}
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
protocols
.
bidi
{
getModuleClass
:
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
modules
/
ModuleRegistry
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
protocols
.
test
{
getModuleClass
:
"
chrome
:
/
/
mochitests
/
content
/
browser
/
remote
/
shared
/
messagehandler
/
test
/
browser
/
resources
/
modules
/
ModuleRegistry
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
)
)
;
class
ModuleCache
{
constructor
(
messageHandler
)
{
this
.
messageHandler
=
messageHandler
;
this
.
_messageHandlerType
=
messageHandler
.
constructor
.
type
;
this
.
_protocol
=
Services
.
prefs
.
getBoolPref
(
"
remote
.
messagehandler
.
modulecache
.
useBrowserTestRoot
"
false
)
?
protocols
.
test
:
protocols
.
bidi
;
this
.
_modules
=
new
Map
(
)
;
}
destroy
(
)
{
this
.
_modules
.
forEach
(
module
=
>
module
?
.
destroy
(
)
)
;
}
getAllModuleClasses
(
moduleName
destination
)
{
const
destinationType
=
destination
.
type
;
const
folders
=
[
this
.
_getModuleFolder
(
this
.
_messageHandlerType
destinationType
)
]
;
if
(
destinationType
!
=
=
this
.
_messageHandlerType
)
{
folders
.
push
(
this
.
_getModuleFolder
(
destinationType
destinationType
)
)
;
}
return
folders
.
map
(
folder
=
>
this
.
_protocol
.
getModuleClass
(
moduleName
folder
)
)
.
filter
(
cls
=
>
!
!
cls
)
;
}
getModuleInstance
(
moduleName
destination
)
{
const
key
=
{
moduleName
}
-
{
destination
.
type
}
;
if
(
this
.
_modules
.
has
(
key
)
)
{
return
this
.
_modules
.
get
(
key
)
;
}
const
moduleFolder
=
this
.
_getModuleFolder
(
this
.
_messageHandlerType
destination
.
type
)
;
const
ModuleClass
=
this
.
_protocol
.
getModuleClass
(
moduleName
moduleFolder
)
;
let
module
=
null
;
if
(
ModuleClass
)
{
module
=
new
ModuleClass
(
this
.
messageHandler
)
;
lazy
.
logger
.
trace
(
Module
{
moduleFolder
}
/
{
moduleName
}
.
jsm
found
for
{
destination
.
type
}
)
;
}
else
{
lazy
.
logger
.
trace
(
Module
{
moduleFolder
}
/
{
moduleName
}
.
jsm
not
found
for
{
destination
.
type
}
)
;
}
this
.
_modules
.
set
(
key
module
)
;
return
module
;
}
hasModule
(
moduleName
destination
)
{
const
classes
=
this
.
getAllModuleClasses
(
moduleName
destination
)
;
return
classes
.
length
!
=
0
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
{
this
.
messageHandler
.
name
}
]
;
}
_getModuleFolder
(
originType
destinationType
)
{
const
originPath
=
lazy
.
getMessageHandlerClass
(
originType
)
.
modulePath
;
if
(
originType
=
=
=
destinationType
)
{
return
originPath
;
}
const
destinationPath
=
lazy
.
getMessageHandlerClass
(
destinationType
)
.
modulePath
;
return
{
destinationPath
}
-
in
-
{
originPath
}
;
}
}
