"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
WebDriverSession
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
accessibility
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
accessibility
.
js
"
allowAllCerts
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
cert
.
js
"
Capabilities
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Capabilities
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
RootMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
RootMessageHandler
.
jsm
"
RootMessageHandlerRegistry
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
RootMessageHandlerRegistry
.
jsm
"
WebDriverBiDiConnection
:
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
WebDriverBiDiConnection
.
jsm
"
WebSocketHandshake
:
"
chrome
:
/
/
remote
/
content
/
server
/
WebSocketHandshake
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
)
)
;
class
WebDriverSession
{
constructor
(
capabilities
connection
)
{
this
.
_connections
=
new
Set
(
)
;
this
.
id
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
this
.
path
=
/
session
/
{
this
.
id
}
;
try
{
this
.
capabilities
=
Capabilities
.
fromJSON
(
capabilities
this
.
path
)
;
}
catch
(
e
)
{
throw
new
error
.
SessionNotCreatedError
(
e
)
;
}
if
(
this
.
capabilities
.
get
(
"
acceptInsecureCerts
"
)
)
{
logger
.
warn
(
"
TLS
certificate
errors
will
be
ignored
for
this
session
"
)
;
allowAllCerts
.
enable
(
)
;
}
if
(
this
.
proxy
.
init
(
)
)
{
logger
.
info
(
Proxy
settings
initialised
:
{
JSON
.
stringify
(
this
.
proxy
)
}
)
;
}
if
(
this
.
a11yChecks
&
&
accessibility
.
service
)
{
logger
.
info
(
"
Preemptively
starting
accessibility
service
in
Chrome
"
)
;
}
if
(
connection
)
{
connection
.
registerSession
(
this
)
;
this
.
_connections
.
add
(
connection
)
;
}
}
destroy
(
)
{
allowAllCerts
.
disable
(
)
;
this
.
_connections
.
forEach
(
connection
=
>
connection
.
close
(
)
)
;
if
(
this
.
_connections
.
size
>
0
)
{
logger
.
warn
(
Failed
to
close
{
this
.
_connections
.
size
}
WebSocket
connections
)
;
}
if
(
this
.
_messageHandler
)
{
this
.
_messageHandler
.
off
(
"
message
-
handler
-
event
"
this
.
_onMessageHandlerEvent
)
;
this
.
_messageHandler
.
destroy
(
)
;
}
}
async
execute
(
module
command
params
)
{
const
destination
=
{
type
:
RootMessageHandler
.
type
}
;
if
(
!
this
.
messageHandler
.
supportsCommand
(
module
command
destination
)
)
{
throw
new
error
.
UnknownCommandError
(
{
module
}
.
{
command
}
)
;
}
return
this
.
messageHandler
.
handleCommand
(
{
moduleName
:
module
commandName
:
command
params
destination
}
)
;
}
get
a11yChecks
(
)
{
return
this
.
capabilities
.
get
(
"
moz
:
accessibilityChecks
"
)
;
}
get
messageHandler
(
)
{
if
(
!
this
.
_messageHandler
)
{
this
.
_messageHandler
=
RootMessageHandlerRegistry
.
getOrCreateMessageHandler
(
this
.
id
)
;
this
.
_onMessageHandlerEvent
=
this
.
_onMessageHandlerEvent
.
bind
(
this
)
;
this
.
_messageHandler
.
on
(
"
message
-
handler
-
event
"
this
.
_onMessageHandlerEvent
)
;
}
return
this
.
_messageHandler
;
}
get
pageLoadStrategy
(
)
{
return
this
.
capabilities
.
get
(
"
pageLoadStrategy
"
)
;
}
get
proxy
(
)
{
return
this
.
capabilities
.
get
(
"
proxy
"
)
;
}
get
strictFileInteractability
(
)
{
return
this
.
capabilities
.
get
(
"
strictFileInteractability
"
)
;
}
get
timeouts
(
)
{
return
this
.
capabilities
.
get
(
"
timeouts
"
)
;
}
set
timeouts
(
timeouts
)
{
this
.
capabilities
.
set
(
"
timeouts
"
timeouts
)
;
}
get
unhandledPromptBehavior
(
)
{
return
this
.
capabilities
.
get
(
"
unhandledPromptBehavior
"
)
;
}
removeConnection
(
connection
)
{
if
(
this
.
_connections
.
has
(
connection
)
)
{
this
.
_connections
.
delete
(
connection
)
;
}
else
{
logger
.
warn
(
"
Trying
to
remove
a
connection
that
doesn
'
t
exist
.
"
)
;
}
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
{
this
.
id
}
]
;
}
async
handle
(
request
response
)
{
const
webSocket
=
await
WebSocketHandshake
.
upgrade
(
request
response
)
;
const
conn
=
new
WebDriverBiDiConnection
(
webSocket
response
.
_connection
)
;
conn
.
registerSession
(
this
)
;
this
.
_connections
.
add
(
conn
)
;
}
_onMessageHandlerEvent
(
eventName
messageHandlerEvent
)
{
const
{
name
data
isProtocolEvent
}
=
messageHandlerEvent
;
if
(
!
isProtocolEvent
)
{
return
;
}
this
.
_connections
.
forEach
(
connection
=
>
connection
.
sendEvent
(
name
data
)
)
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsIHttpRequestHandler
"
]
)
;
}
}
