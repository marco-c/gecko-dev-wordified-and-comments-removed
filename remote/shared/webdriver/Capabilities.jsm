"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
Capabilities
"
"
PageLoadStrategy
"
"
Proxy
"
"
Timeouts
"
"
UnhandledPromptBehavior
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
Preferences
:
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
AppInfo
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
appinfo
.
js
"
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
pprint
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
RemoteAgent
:
"
chrome
:
/
/
remote
/
content
/
components
/
RemoteAgent
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
remoteAgent
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
remote
/
agent
;
1
"
]
.
createInstance
(
Ci
.
nsIRemoteAgent
)
;
}
)
;
class
Timeouts
{
constructor
(
)
{
this
.
implicit
=
0
;
this
.
pageLoad
=
300000
;
this
.
script
=
30000
;
}
toString
(
)
{
return
"
[
object
Timeouts
]
"
;
}
toJSON
(
)
{
return
{
implicit
:
this
.
implicit
pageLoad
:
this
.
pageLoad
script
:
this
.
script
}
;
}
static
fromJSON
(
json
)
{
lazy
.
assert
.
object
(
json
lazy
.
pprint
Expected
"
timeouts
"
to
be
an
object
got
{
json
}
)
;
let
t
=
new
Timeouts
(
)
;
for
(
let
[
type
ms
]
of
Object
.
entries
(
json
)
)
{
switch
(
type
)
{
case
"
implicit
"
:
t
.
implicit
=
lazy
.
assert
.
positiveInteger
(
ms
lazy
.
pprint
Expected
{
type
}
to
be
a
positive
integer
got
{
ms
}
)
;
break
;
case
"
script
"
:
if
(
ms
!
=
=
null
)
{
lazy
.
assert
.
positiveInteger
(
ms
lazy
.
pprint
Expected
{
type
}
to
be
a
positive
integer
got
{
ms
}
)
;
}
t
.
script
=
ms
;
break
;
case
"
pageLoad
"
:
t
.
pageLoad
=
lazy
.
assert
.
positiveInteger
(
ms
lazy
.
pprint
Expected
{
type
}
to
be
a
positive
integer
got
{
ms
}
)
;
break
;
default
:
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
Unrecognised
timeout
:
"
+
type
)
;
}
}
return
t
;
}
}
const
PageLoadStrategy
=
{
None
:
"
none
"
Eager
:
"
eager
"
Normal
:
"
normal
"
}
;
class
Proxy
{
constructor
(
)
{
this
.
proxyType
=
null
;
this
.
httpProxy
=
null
;
this
.
httpProxyPort
=
null
;
this
.
noProxy
=
null
;
this
.
sslProxy
=
null
;
this
.
sslProxyPort
=
null
;
this
.
socksProxy
=
null
;
this
.
socksProxyPort
=
null
;
this
.
socksVersion
=
null
;
this
.
proxyAutoconfigUrl
=
null
;
}
init
(
)
{
switch
(
this
.
proxyType
)
{
case
"
autodetect
"
:
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
type
"
4
)
;
return
true
;
case
"
direct
"
:
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
type
"
0
)
;
return
true
;
case
"
manual
"
:
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
type
"
1
)
;
if
(
this
.
httpProxy
)
{
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
http
"
this
.
httpProxy
)
;
if
(
Number
.
isInteger
(
this
.
httpProxyPort
)
)
{
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
http_port
"
this
.
httpProxyPort
)
;
}
}
if
(
this
.
sslProxy
)
{
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
ssl
"
this
.
sslProxy
)
;
if
(
Number
.
isInteger
(
this
.
sslProxyPort
)
)
{
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
ssl_port
"
this
.
sslProxyPort
)
;
}
}
if
(
this
.
socksProxy
)
{
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
socks
"
this
.
socksProxy
)
;
if
(
Number
.
isInteger
(
this
.
socksProxyPort
)
)
{
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
socks_port
"
this
.
socksProxyPort
)
;
}
if
(
this
.
socksVersion
)
{
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
socks_version
"
this
.
socksVersion
)
;
}
}
if
(
this
.
noProxy
)
{
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
no_proxies_on
"
this
.
noProxy
.
join
(
"
"
)
)
;
}
return
true
;
case
"
pac
"
:
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
type
"
2
)
;
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
autoconfig_url
"
this
.
proxyAutoconfigUrl
)
;
return
true
;
case
"
system
"
:
lazy
.
Preferences
.
set
(
"
network
.
proxy
.
type
"
5
)
;
return
true
;
default
:
return
false
;
}
}
static
fromJSON
(
json
)
{
function
stripBracketsFromIpv6Hostname
(
hostname
)
{
return
hostname
.
includes
(
"
:
"
)
?
hostname
.
replace
(
/
[
\
[
\
]
]
/
g
"
"
)
:
hostname
;
}
function
fromHost
(
scheme
host
)
{
lazy
.
assert
.
string
(
host
lazy
.
pprint
Expected
proxy
"
host
"
to
be
a
string
got
{
host
}
)
;
if
(
host
.
includes
(
"
:
/
/
"
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
{
host
}
contains
a
scheme
)
;
}
let
url
;
try
{
url
=
new
URL
(
"
http
:
/
/
"
+
host
)
;
if
(
url
.
port
=
=
"
"
)
{
url
=
new
URL
(
"
https
:
/
/
"
+
host
)
;
}
}
catch
(
e
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
e
.
message
)
;
}
let
hostname
=
stripBracketsFromIpv6Hostname
(
url
.
hostname
)
;
let
port
=
parseInt
(
url
.
port
)
;
if
(
!
Number
.
isInteger
(
port
)
)
{
if
(
scheme
=
=
=
"
socks
"
)
{
port
=
null
;
}
else
{
port
=
Services
.
io
.
getProtocolHandler
(
scheme
)
.
defaultPort
;
}
}
if
(
url
.
username
!
=
"
"
|
|
url
.
password
!
=
"
"
|
|
url
.
pathname
!
=
"
/
"
|
|
url
.
search
!
=
"
"
|
|
url
.
hash
!
=
"
"
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
{
host
}
was
not
of
the
form
host
[
:
port
]
)
;
}
return
[
hostname
port
]
;
}
let
p
=
new
Proxy
(
)
;
if
(
typeof
json
=
=
"
undefined
"
|
|
json
=
=
=
null
)
{
return
p
;
}
lazy
.
assert
.
object
(
json
lazy
.
pprint
Expected
"
proxy
"
to
be
an
object
got
{
json
}
)
;
lazy
.
assert
.
in
(
"
proxyType
"
json
lazy
.
pprint
Expected
"
proxyType
"
in
"
proxy
"
object
got
{
json
}
)
;
p
.
proxyType
=
lazy
.
assert
.
string
(
json
.
proxyType
lazy
.
pprint
Expected
"
proxyType
"
to
be
a
string
got
{
json
.
proxyType
}
)
;
switch
(
p
.
proxyType
)
{
case
"
autodetect
"
:
case
"
direct
"
:
case
"
system
"
:
break
;
case
"
pac
"
:
p
.
proxyAutoconfigUrl
=
lazy
.
assert
.
string
(
json
.
proxyAutoconfigUrl
Expected
"
proxyAutoconfigUrl
"
to
be
a
string
+
lazy
.
pprint
got
{
json
.
proxyAutoconfigUrl
}
)
;
break
;
case
"
manual
"
:
if
(
typeof
json
.
ftpProxy
!
=
"
undefined
"
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
Since
Firefox
90
'
ftpProxy
'
is
no
longer
supported
"
)
;
}
if
(
typeof
json
.
httpProxy
!
=
"
undefined
"
)
{
[
p
.
httpProxy
p
.
httpProxyPort
]
=
fromHost
(
"
http
"
json
.
httpProxy
)
;
}
if
(
typeof
json
.
sslProxy
!
=
"
undefined
"
)
{
[
p
.
sslProxy
p
.
sslProxyPort
]
=
fromHost
(
"
https
"
json
.
sslProxy
)
;
}
if
(
typeof
json
.
socksProxy
!
=
"
undefined
"
)
{
[
p
.
socksProxy
p
.
socksProxyPort
]
=
fromHost
(
"
socks
"
json
.
socksProxy
)
;
p
.
socksVersion
=
lazy
.
assert
.
positiveInteger
(
json
.
socksVersion
lazy
.
pprint
Expected
"
socksVersion
"
to
be
a
positive
integer
got
{
json
.
socksVersion
}
)
;
}
if
(
typeof
json
.
noProxy
!
=
"
undefined
"
)
{
let
entries
=
lazy
.
assert
.
array
(
json
.
noProxy
lazy
.
pprint
Expected
"
noProxy
"
to
be
an
array
got
{
json
.
noProxy
}
)
;
p
.
noProxy
=
entries
.
map
(
entry
=
>
{
lazy
.
assert
.
string
(
entry
lazy
.
pprint
Expected
"
noProxy
"
entry
to
be
a
string
got
{
entry
}
)
;
return
stripBracketsFromIpv6Hostname
(
entry
)
;
}
)
;
}
break
;
default
:
throw
new
lazy
.
error
.
InvalidArgumentError
(
Invalid
type
of
proxy
:
{
p
.
proxyType
}
)
;
}
return
p
;
}
toJSON
(
)
{
function
addBracketsToIpv6Hostname
(
hostname
)
{
return
hostname
.
includes
(
"
:
"
)
?
[
{
hostname
}
]
:
hostname
;
}
function
toHost
(
hostname
port
)
{
if
(
!
hostname
)
{
return
null
;
}
hostname
=
addBracketsToIpv6Hostname
(
hostname
)
;
if
(
port
!
=
null
)
{
return
{
hostname
}
:
{
port
}
;
}
return
hostname
;
}
let
excludes
=
this
.
noProxy
;
if
(
excludes
)
{
excludes
=
excludes
.
map
(
addBracketsToIpv6Hostname
)
;
}
return
marshal
(
{
proxyType
:
this
.
proxyType
httpProxy
:
toHost
(
this
.
httpProxy
this
.
httpProxyPort
)
noProxy
:
excludes
sslProxy
:
toHost
(
this
.
sslProxy
this
.
sslProxyPort
)
socksProxy
:
toHost
(
this
.
socksProxy
this
.
socksProxyPort
)
socksVersion
:
this
.
socksVersion
proxyAutoconfigUrl
:
this
.
proxyAutoconfigUrl
}
)
;
}
toString
(
)
{
return
"
[
object
Proxy
]
"
;
}
}
const
UnhandledPromptBehavior
=
{
Accept
:
"
accept
"
AcceptAndNotify
:
"
accept
and
notify
"
Dismiss
:
"
dismiss
"
DismissAndNotify
:
"
dismiss
and
notify
"
Ignore
:
"
ignore
"
}
;
class
Capabilities
extends
Map
{
constructor
(
)
{
super
(
[
[
"
browserName
"
getWebDriverBrowserName
(
)
]
[
"
browserVersion
"
lazy
.
AppInfo
.
version
]
[
"
platformName
"
getWebDriverPlatformName
(
)
]
[
"
acceptInsecureCerts
"
false
]
[
"
pageLoadStrategy
"
PageLoadStrategy
.
Normal
]
[
"
proxy
"
new
Proxy
(
)
]
[
"
setWindowRect
"
!
lazy
.
AppInfo
.
isAndroid
]
[
"
timeouts
"
new
Timeouts
(
)
]
[
"
strictFileInteractability
"
false
]
[
"
unhandledPromptBehavior
"
UnhandledPromptBehavior
.
DismissAndNotify
]
[
"
webSocketUrl
"
null
]
[
"
moz
:
accessibilityChecks
"
false
]
[
"
moz
:
buildID
"
lazy
.
AppInfo
.
appBuildID
]
[
"
moz
:
debuggerAddress
"
lazy
.
RemoteAgent
.
running
&
&
lazy
.
RemoteAgent
.
cdp
?
lazy
.
remoteAgent
.
debuggerAddress
:
null
]
[
"
moz
:
headless
"
Cc
[
"
mozilla
.
org
/
gfx
/
info
;
1
"
]
.
getService
(
Ci
.
nsIGfxInfo
)
.
isHeadless
]
[
"
moz
:
platformVersion
"
Services
.
sysinfo
.
getProperty
(
"
version
"
)
]
[
"
moz
:
processID
"
lazy
.
AppInfo
.
processID
]
[
"
moz
:
profile
"
maybeProfile
(
)
]
[
"
moz
:
shutdownTimeout
"
Services
.
prefs
.
getIntPref
(
"
toolkit
.
asyncshutdown
.
crash_timeout
"
)
]
[
"
moz
:
useNonSpecCompliantPointerOrigin
"
false
]
[
"
moz
:
webdriverClick
"
true
]
[
"
moz
:
windowless
"
false
]
]
)
;
}
set
(
key
value
)
{
if
(
key
=
=
=
"
timeouts
"
&
&
!
(
value
instanceof
Timeouts
)
)
{
throw
new
TypeError
(
)
;
}
else
if
(
key
=
=
=
"
proxy
"
&
&
!
(
value
instanceof
Proxy
)
)
{
throw
new
TypeError
(
)
;
}
return
super
.
set
(
key
value
)
;
}
toString
(
)
{
return
"
[
object
Capabilities
]
"
;
}
toJSON
(
)
{
let
marshalled
=
marshal
(
this
)
;
if
(
!
(
"
proxy
"
in
marshalled
)
)
{
marshalled
.
proxy
=
{
}
;
}
marshalled
.
timeouts
=
super
.
get
(
"
timeouts
"
)
;
return
marshalled
;
}
static
fromJSON
(
json
)
{
if
(
typeof
json
=
=
"
undefined
"
|
|
json
=
=
=
null
)
{
json
=
{
}
;
}
lazy
.
assert
.
object
(
json
lazy
.
pprint
Expected
"
capabilities
"
to
be
an
object
got
{
json
}
"
)
;
return
Capabilities
.
match_
(
json
)
;
}
static
match_
(
json
=
{
}
)
{
let
matched
=
new
Capabilities
(
)
;
for
(
let
[
k
v
]
of
Object
.
entries
(
json
)
)
{
switch
(
k
)
{
case
"
acceptInsecureCerts
"
:
lazy
.
assert
.
boolean
(
v
lazy
.
pprint
Expected
{
k
}
to
be
a
boolean
got
{
v
}
)
;
break
;
case
"
pageLoadStrategy
"
:
lazy
.
assert
.
string
(
v
lazy
.
pprint
Expected
{
k
}
to
be
a
string
got
{
v
}
)
;
if
(
!
Object
.
values
(
PageLoadStrategy
)
.
includes
(
v
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
Unknown
page
load
strategy
:
"
+
v
)
;
}
break
;
case
"
proxy
"
:
v
=
Proxy
.
fromJSON
(
v
)
;
break
;
case
"
setWindowRect
"
:
lazy
.
assert
.
boolean
(
v
lazy
.
pprint
Expected
{
k
}
to
be
boolean
got
{
v
}
)
;
if
(
!
lazy
.
AppInfo
.
isAndroid
&
&
!
v
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
setWindowRect
cannot
be
disabled
"
)
;
}
else
if
(
lazy
.
AppInfo
.
isAndroid
&
&
v
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
setWindowRect
is
only
supported
on
desktop
"
)
;
}
break
;
case
"
timeouts
"
:
v
=
Timeouts
.
fromJSON
(
v
)
;
break
;
case
"
strictFileInteractability
"
:
v
=
lazy
.
assert
.
boolean
(
v
)
;
break
;
case
"
unhandledPromptBehavior
"
:
lazy
.
assert
.
string
(
v
lazy
.
pprint
Expected
{
k
}
to
be
a
string
got
{
v
}
)
;
if
(
!
Object
.
values
(
UnhandledPromptBehavior
)
.
includes
(
v
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Unknown
unhandled
prompt
behavior
:
{
v
}
)
;
}
break
;
case
"
webSocketUrl
"
:
lazy
.
assert
.
boolean
(
v
lazy
.
pprint
Expected
{
k
}
to
be
boolean
got
{
v
}
)
;
if
(
!
v
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
lazy
.
pprint
Expected
{
k
}
to
be
true
got
{
v
}
)
;
}
break
;
case
"
moz
:
accessibilityChecks
"
:
lazy
.
assert
.
boolean
(
v
lazy
.
pprint
Expected
{
k
}
to
be
boolean
got
{
v
}
)
;
break
;
case
"
moz
:
debuggerAddress
"
:
continue
;
case
"
moz
:
useNonSpecCompliantPointerOrigin
"
:
lazy
.
assert
.
boolean
(
v
lazy
.
pprint
Expected
{
k
}
to
be
boolean
got
{
v
}
)
;
break
;
case
"
moz
:
webdriverClick
"
:
lazy
.
assert
.
boolean
(
v
lazy
.
pprint
Expected
{
k
}
to
be
boolean
got
{
v
}
)
;
break
;
case
"
moz
:
windowless
"
:
lazy
.
assert
.
boolean
(
v
lazy
.
pprint
Expected
{
k
}
to
be
boolean
got
{
v
}
)
;
if
(
v
&
&
!
lazy
.
AppInfo
.
isMac
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
moz
:
windowless
only
supported
on
MacOS
"
)
;
}
break
;
}
matched
.
set
(
k
v
)
;
}
return
matched
;
}
}
function
getWebDriverBrowserName
(
)
{
if
(
lazy
.
AppInfo
.
isAndroid
)
{
return
"
firefox
"
;
}
return
lazy
.
AppInfo
.
name
?
.
toLowerCase
(
)
;
}
function
getWebDriverPlatformName
(
)
{
let
name
=
Services
.
sysinfo
.
getProperty
(
"
name
"
)
;
if
(
lazy
.
AppInfo
.
isAndroid
)
{
return
"
android
"
;
}
switch
(
name
)
{
case
"
Windows_NT
"
:
return
"
windows
"
;
case
"
Darwin
"
:
return
"
mac
"
;
default
:
return
name
.
toLowerCase
(
)
;
}
}
function
marshal
(
obj
)
{
let
rv
=
Object
.
create
(
null
)
;
function
*
iter
(
mapOrObject
)
{
if
(
mapOrObject
instanceof
Map
)
{
for
(
const
[
k
v
]
of
mapOrObject
)
{
yield
[
k
v
]
;
}
}
else
{
for
(
const
k
of
Object
.
keys
(
mapOrObject
)
)
{
yield
[
k
mapOrObject
[
k
]
]
;
}
}
}
for
(
let
[
k
v
]
of
iter
(
obj
)
)
{
if
(
typeof
v
=
=
"
undefined
"
|
|
v
=
=
=
null
)
{
continue
;
}
if
(
typeof
v
.
toJSON
=
=
"
function
"
)
{
v
=
marshal
(
v
.
toJSON
(
)
)
;
}
else
if
(
isObject
(
v
)
)
{
v
=
marshal
(
v
)
;
}
if
(
!
isObjectEmpty
(
v
)
)
{
rv
[
k
]
=
v
;
}
}
return
rv
;
}
function
isObject
(
obj
)
{
return
Object
.
prototype
.
toString
.
call
(
obj
)
=
=
"
[
object
Object
]
"
;
}
function
isObjectEmpty
(
obj
)
{
return
isObject
(
obj
)
&
&
Object
.
keys
(
obj
)
.
length
=
=
=
0
;
}
function
maybeProfile
(
)
{
try
{
return
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
.
path
;
}
catch
(
e
)
{
return
"
<
protected
>
"
;
}
}
