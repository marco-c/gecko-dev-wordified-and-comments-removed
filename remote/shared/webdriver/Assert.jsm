"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
assert
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AppInfo
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
appinfo
.
js
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
pprint
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
}
)
;
const
assert
=
{
}
;
assert
.
session
=
function
(
session
msg
=
"
"
)
{
msg
=
msg
|
|
"
WebDriver
session
does
not
exist
or
is
not
active
"
;
assert
.
that
(
session
=
>
session
&
&
typeof
session
.
id
=
=
"
string
"
msg
lazy
.
error
.
InvalidSessionIDError
)
(
session
)
;
}
;
assert
.
firefox
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
Firefox
"
;
assert
.
that
(
isFirefox
=
>
isFirefox
msg
lazy
.
error
.
UnsupportedOperationError
)
(
lazy
.
AppInfo
.
isFirefox
)
;
}
;
assert
.
desktop
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
desktop
applications
"
;
assert
.
that
(
isDesktop
=
>
isDesktop
msg
lazy
.
error
.
UnsupportedOperationError
)
(
!
lazy
.
AppInfo
.
isAndroid
)
;
}
;
assert
.
mobile
=
function
(
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
on
Android
"
;
assert
.
that
(
isAndroid
=
>
isAndroid
msg
lazy
.
error
.
UnsupportedOperationError
)
(
lazy
.
AppInfo
.
isAndroid
)
;
}
;
assert
.
content
=
function
(
context
msg
=
"
"
)
{
msg
=
msg
|
|
"
Only
supported
in
content
context
"
;
assert
.
that
(
c
=
>
c
.
toString
(
)
=
=
"
content
"
msg
lazy
.
error
.
UnsupportedOperationError
)
(
context
)
;
}
;
assert
.
open
=
function
(
browsingContext
msg
=
"
"
)
{
msg
=
msg
|
|
"
Browsing
context
has
been
discarded
"
;
return
assert
.
that
(
browsingContext
=
>
{
if
(
!
browsingContext
?
.
currentWindowGlobal
)
{
return
false
;
}
if
(
browsingContext
.
isContent
&
&
!
browsingContext
.
top
.
embedderElement
)
{
return
false
;
}
return
true
;
}
msg
lazy
.
error
.
NoSuchWindowError
)
(
browsingContext
)
;
}
;
assert
.
noUserPrompt
=
function
(
dialog
msg
=
"
"
)
{
assert
.
that
(
d
=
>
d
=
=
=
null
|
|
typeof
d
=
=
"
undefined
"
msg
lazy
.
error
.
UnexpectedAlertOpenError
)
(
dialog
)
;
}
;
assert
.
defined
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
defined
;
return
assert
.
that
(
o
=
>
typeof
o
!
=
"
undefined
"
msg
)
(
obj
)
;
}
;
assert
.
number
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
finite
number
;
return
assert
.
that
(
Number
.
isFinite
msg
)
(
obj
)
;
}
;
assert
.
positiveNumber
=
function
(
obj
msg
=
"
"
)
{
assert
.
number
(
obj
msg
)
;
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
>
=
0
;
return
assert
.
that
(
n
=
>
n
>
=
0
msg
)
(
obj
)
;
}
;
assert
.
numberInRange
=
function
(
obj
range
msg
=
"
"
)
{
const
[
lower
upper
]
=
range
;
assert
.
number
(
obj
msg
)
;
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
>
=
{
lower
}
and
<
=
{
upper
}
;
return
assert
.
that
(
n
=
>
n
>
=
lower
&
&
n
<
=
upper
msg
)
(
obj
)
;
}
;
assert
.
callable
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
lazy
.
pprint
{
obj
}
is
not
callable
;
return
assert
.
that
(
o
=
>
typeof
o
=
=
"
function
"
msg
)
(
obj
)
;
}
;
assert
.
unsignedShort
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
>
=
0
and
<
65536
;
return
assert
.
that
(
n
=
>
n
>
=
0
&
&
n
<
65536
msg
)
(
obj
)
;
}
;
assert
.
integer
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
an
integer
;
return
assert
.
that
(
Number
.
isSafeInteger
msg
)
(
obj
)
;
}
;
assert
.
positiveInteger
=
function
(
obj
msg
=
"
"
)
{
assert
.
integer
(
obj
msg
)
;
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
>
=
0
;
return
assert
.
that
(
n
=
>
n
>
=
0
msg
)
(
obj
)
;
}
;
assert
.
integerInRange
=
function
(
obj
range
msg
=
"
"
)
{
const
[
lower
upper
]
=
range
;
assert
.
integer
(
obj
msg
)
;
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
>
=
{
lower
}
and
<
=
{
upper
}
;
return
assert
.
that
(
n
=
>
n
>
=
lower
&
&
n
<
=
upper
msg
)
(
obj
)
;
}
;
assert
.
boolean
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
boolean
;
return
assert
.
that
(
b
=
>
typeof
b
=
=
"
boolean
"
msg
)
(
obj
)
;
}
;
assert
.
string
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
a
string
;
return
assert
.
that
(
s
=
>
typeof
s
=
=
"
string
"
msg
)
(
obj
)
;
}
;
assert
.
object
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
an
object
;
return
assert
.
that
(
o
=
>
{
let
s
=
Object
.
prototype
.
toString
.
call
(
o
)
;
return
s
=
=
"
[
object
Object
]
"
|
|
s
=
=
"
[
object
nsJSIID
]
"
;
}
msg
)
(
obj
)
;
}
;
assert
.
in
=
function
(
prop
obj
msg
=
"
"
)
{
if
(
Array
.
isArray
(
obj
)
)
{
assert
.
that
(
p
=
>
obj
.
includes
(
p
)
msg
)
(
prop
)
;
return
prop
;
}
assert
.
object
(
obj
msg
)
;
msg
=
msg
|
|
lazy
.
pprint
Expected
{
prop
}
in
{
obj
}
;
assert
.
that
(
p
=
>
obj
.
hasOwnProperty
(
p
)
msg
)
(
prop
)
;
return
obj
[
prop
]
;
}
;
assert
.
array
=
function
(
obj
msg
=
"
"
)
{
msg
=
msg
|
|
lazy
.
pprint
Expected
{
obj
}
to
be
an
Array
;
return
assert
.
that
(
Array
.
isArray
msg
)
(
obj
)
;
}
;
assert
.
that
=
function
(
predicate
message
=
"
"
err
=
lazy
.
error
.
InvalidArgumentError
)
{
return
obj
=
>
{
if
(
!
predicate
(
obj
)
)
{
throw
new
err
(
message
)
;
}
return
obj
;
}
;
}
;
