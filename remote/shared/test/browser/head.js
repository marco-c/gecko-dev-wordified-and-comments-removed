"
use
strict
"
;
const
{
NavigationManager
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
remote
/
content
/
shared
/
NavigationManager
.
sys
.
mjs
"
)
;
const
numberRegex
=
/
[
0
-
9
]
+
/
i
;
const
uuidRegex
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
4
[
0
-
9a
-
f
]
{
3
}
-
[
89ab
]
[
0
-
9a
-
f
]
{
3
}
-
[
0
-
9a
-
f
]
{
12
}
/
i
;
function
addTab
(
browser
url
options
)
{
info
(
"
Add
a
new
tab
for
url
:
"
+
url
)
;
const
tab
=
BrowserTestUtils
.
addTab
(
browser
url
options
)
;
registerCleanupFunction
(
(
)
=
>
browser
.
removeTab
(
tab
)
)
;
return
tab
;
}
async
function
addTabAndWaitForNavigated
(
browser
url
options
)
{
const
{
promise
:
waitForNavigation
resolve
}
=
Promise
.
withResolvers
(
)
;
const
onNavigationStopped
=
(
name
data
)
=
>
{
if
(
data
?
.
url
=
=
=
url
)
{
resolve
(
)
;
}
}
;
const
navigationManager
=
new
NavigationManager
(
)
;
navigationManager
.
on
(
"
navigation
-
stopped
"
onNavigationStopped
)
;
navigationManager
.
startMonitoring
(
)
;
const
tab
=
addTab
(
browser
url
options
)
;
info
(
"
Wait
for
BrowserTestUtils
.
browserLoaded
for
url
:
"
+
url
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
url
)
;
info
(
"
Wait
for
navigation
-
stopped
for
url
:
"
+
url
)
;
await
waitForNavigation
;
await
TestUtils
.
waitForTick
(
)
;
navigationManager
.
stopMonitoring
(
)
;
navigationManager
.
off
(
"
navigation
-
stopped
"
onNavigationStopped
)
;
navigationManager
.
destroy
(
)
;
return
tab
;
}
function
assertNavigation
(
navigation
expectedUrl
)
{
ok
(
!
!
navigation
"
Retrieved
a
navigation
"
)
;
is
(
navigation
.
url
expectedUrl
"
Navigation
has
the
expected
URL
"
)
;
is
(
typeof
navigation
.
navigationId
"
string
"
"
Navigation
has
a
string
navigationId
"
)
;
}
function
assertNavigationEvents
(
events
url
navigationId
navigableId
isSameDocument
)
{
const
expectedEvents
=
isSameDocument
?
1
:
2
;
const
navigationEvents
=
events
.
filter
(
e
=
>
e
.
data
.
navigationId
=
=
navigationId
)
;
is
(
navigationEvents
.
length
expectedEvents
Found
{
expectedEvents
}
events
for
navigationId
{
navigationId
}
)
;
const
sameDocumentEvents
=
[
"
fragment
-
navigated
"
"
same
-
document
-
changed
"
]
;
if
(
isSameDocument
)
{
ok
(
!
navigationEvents
.
some
(
e
=
>
e
.
name
=
=
=
"
navigation
-
started
"
)
)
;
ok
(
!
navigationEvents
.
some
(
e
=
>
e
.
name
=
=
=
"
navigation
-
stopped
"
)
)
;
const
locationChanged
=
navigationEvents
.
find
(
e
=
>
sameDocumentEvents
.
includes
(
e
.
name
)
)
;
ok
(
sameDocumentEvents
.
includes
(
locationChanged
.
name
)
"
event
has
the
expected
name
"
)
;
is
(
locationChanged
.
data
.
url
url
"
event
has
the
expected
url
"
)
;
is
(
locationChanged
.
data
.
navigableId
navigableId
"
event
has
the
expected
navigable
"
)
;
}
else
{
ok
(
!
navigationEvents
.
some
(
e
=
>
sameDocumentEvents
.
includes
(
e
.
name
)
)
)
;
const
started
=
navigationEvents
.
find
(
e
=
>
e
.
name
=
=
=
"
navigation
-
started
"
)
;
const
stopped
=
navigationEvents
.
find
(
e
=
>
e
.
name
=
=
=
"
navigation
-
stopped
"
)
;
is
(
started
.
name
"
navigation
-
started
"
"
event
has
the
expected
name
"
)
;
is
(
started
.
data
.
url
url
"
event
has
the
expected
url
"
)
;
is
(
started
.
data
.
navigableId
navigableId
"
event
has
the
expected
navigable
"
)
;
is
(
stopped
.
name
"
navigation
-
stopped
"
"
event
has
the
expected
name
"
)
;
is
(
stopped
.
data
.
url
url
"
event
has
the
expected
url
"
)
;
is
(
stopped
.
data
.
navigableId
navigableId
"
event
has
the
expected
navigable
"
)
;
}
}
function
assertUniqueNavigationIds
(
.
.
.
navigations
)
{
const
ids
=
navigations
.
map
(
navigation
=
>
navigation
.
navigationId
)
;
is
(
new
Set
(
ids
)
.
size
ids
.
length
"
Navigation
ids
are
all
different
"
)
;
}
function
createFrame
(
domain
)
{
return
createFrameForUri
(
https
:
/
/
{
domain
}
/
document
-
builder
.
sjs
?
html
=
frame
-
{
domain
}
)
;
}
function
createFrameForUri
(
uri
)
{
return
<
iframe
src
=
"
{
encodeURI
(
uri
)
}
"
>
<
/
iframe
>
;
}
function
createTestPageWithFrames
(
)
{
const
NESTED_FRAME_MARKUP
=
createFrameForUri
(
https
:
/
/
example
.
org
/
document
-
builder
.
sjs
?
html
=
{
createFrame
(
"
example
.
net
"
)
}
)
;
const
TEST_URI_MARKUP
=
{
NESTED_FRAME_MARKUP
}
{
createFrame
(
"
example
.
com
"
)
}
;
return
https
:
/
/
example
.
org
/
document
-
builder
.
sjs
?
html
=
{
encodeURI
(
TEST_URI_MARKUP
)
}
;
}
async
function
loadURL
(
browser
url
options
=
{
}
)
{
const
{
includeSubFrames
=
false
maybeErrorPage
=
false
}
=
options
;
const
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
includeSubFrames
url
maybeErrorPage
)
;
BrowserTestUtils
.
startLoadingURIString
(
browser
url
)
;
return
loaded
;
}
function
getSupportFilePath
(
path
)
{
let
absolutePath
=
getChromeDir
(
getResolvedURI
(
gTestPath
)
)
;
for
(
const
part
of
path
.
split
(
"
/
"
)
)
{
if
(
part
=
=
=
"
.
.
"
)
{
absolutePath
=
absolutePath
.
parent
;
}
else
{
absolutePath
.
append
(
part
)
;
}
}
if
(
!
absolutePath
.
exists
(
)
)
{
throw
new
Error
(
{
absolutePath
.
path
}
does
not
exist
)
;
}
return
absolutePath
.
path
;
}
async
function
readFileAsBase64
(
path
)
{
const
file
=
new
FileUtils
.
File
(
path
)
;
const
contents
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
NetUtil
.
asyncFetch
(
{
uri
:
file
loadUsingSystemPrincipal
:
true
}
(
inputStream
status
)
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
reject
(
new
Error
(
"
Failed
to
read
file
;
status
=
"
+
status
)
)
;
return
;
}
const
fileContents
=
NetUtil
.
readInputStreamToString
(
inputStream
inputStream
.
available
(
)
)
;
inputStream
.
close
(
)
;
resolve
(
fileContents
)
;
}
)
;
}
)
;
return
btoa
(
contents
)
;
}
