"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
WebSocketHandshake
"
]
;
const
CC
=
Components
.
Constructor
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
executeSoon
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Sync
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
RemoteAgent
:
"
chrome
:
/
/
remote
/
content
/
components
/
RemoteAgent
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
)
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
CryptoHash
"
(
)
=
>
{
return
CC
(
"
mozilla
.
org
/
security
/
hash
;
1
"
"
nsICryptoHash
"
"
initWithString
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
threadManager
"
(
)
=
>
{
return
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
allowedOrigins
"
(
)
=
>
lazy
.
RemoteAgent
.
allowOrigins
!
=
=
null
?
lazy
.
RemoteAgent
.
allowOrigins
:
[
]
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
allowedOriginURIs
"
(
)
=
>
{
return
lazy
.
allowedOrigins
.
map
(
origin
=
>
{
try
{
const
originURI
=
Services
.
io
.
newURI
(
origin
)
;
return
{
host
:
originURI
.
host
port
:
originURI
.
port
scheme
:
originURI
.
scheme
}
;
}
catch
(
e
)
{
return
null
;
}
}
)
.
filter
(
uri
=
>
uri
!
=
=
null
)
;
}
)
;
function
writeString
(
output
data
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
wait
=
(
)
=
>
{
if
(
data
.
length
=
=
=
0
)
{
resolve
(
)
;
return
;
}
output
.
asyncWait
(
stream
=
>
{
try
{
const
written
=
output
.
write
(
data
data
.
length
)
;
data
=
data
.
slice
(
written
)
;
wait
(
)
;
}
catch
(
ex
)
{
reject
(
ex
)
;
}
}
0
0
lazy
.
threadManager
.
currentThread
)
;
}
;
wait
(
)
;
}
)
;
}
function
writeHttpResponse
(
output
headers
body
=
"
"
)
{
headers
.
push
(
Content
-
Length
:
{
body
.
length
}
)
;
const
s
=
headers
.
join
(
"
\
r
\
n
"
)
+
\
r
\
n
\
r
\
n
{
body
}
;
return
writeString
(
output
s
)
;
}
function
isIPAddress
(
uri
)
{
try
{
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
}
catch
(
e
)
{
return
e
.
result
=
=
Cr
.
NS_ERROR_HOST_IS_IP_ADDRESS
;
}
return
false
;
}
function
isHostValid
(
hostHeader
)
{
try
{
const
hostUri
=
Services
.
io
.
newURI
(
https
:
/
/
{
hostHeader
}
)
;
const
{
host
port
}
=
hostUri
;
const
isHostnameValid
=
isIPAddress
(
hostUri
)
|
|
lazy
.
RemoteAgent
.
allowHosts
.
includes
(
host
)
;
const
isPortValid
=
[
-
1
lazy
.
RemoteAgent
.
port
]
.
includes
(
port
)
;
return
isHostnameValid
&
&
isPortValid
;
}
catch
(
e
)
{
return
false
;
}
}
function
isOriginValid
(
originHeader
)
{
if
(
originHeader
=
=
=
undefined
)
{
return
true
;
}
if
(
originHeader
=
=
=
"
null
"
)
{
return
lazy
.
allowedOrigins
.
includes
(
"
null
"
)
;
}
try
{
const
{
host
port
scheme
}
=
Services
.
io
.
newURI
(
originHeader
)
;
return
lazy
.
allowedOriginURIs
.
some
(
uri
=
>
uri
.
host
=
=
=
host
&
&
uri
.
port
=
=
=
port
&
&
uri
.
scheme
=
=
=
scheme
)
;
}
catch
(
e
)
{
return
false
;
}
}
function
processRequest
(
{
requestLine
headers
}
)
{
if
(
!
isOriginValid
(
headers
.
get
(
"
origin
"
)
)
)
{
lazy
.
logger
.
debug
(
Incorrect
Origin
header
allowed
origins
:
[
{
lazy
.
allowedOrigins
}
]
)
;
throw
new
Error
(
The
handshake
request
has
incorrect
Origin
header
{
headers
.
get
(
"
origin
"
)
}
)
;
}
if
(
!
isHostValid
(
headers
.
get
(
"
host
"
)
)
)
{
lazy
.
logger
.
debug
(
Incorrect
Host
header
allowed
hosts
:
[
{
lazy
.
RemoteAgent
.
allowHosts
}
]
)
;
throw
new
Error
(
The
handshake
request
has
incorrect
Host
header
{
headers
.
get
(
"
host
"
)
}
)
;
}
const
method
=
requestLine
.
split
(
"
"
)
[
0
]
;
if
(
method
!
=
=
"
GET
"
)
{
throw
new
Error
(
"
The
handshake
request
must
use
GET
method
"
)
;
}
const
upgrade
=
headers
.
get
(
"
upgrade
"
)
;
if
(
!
upgrade
|
|
upgrade
.
toLowerCase
(
)
!
=
=
"
websocket
"
)
{
throw
new
Error
(
The
handshake
request
has
incorrect
Upgrade
header
:
{
upgrade
}
)
;
}
const
connection
=
headers
.
get
(
"
connection
"
)
;
if
(
!
connection
|
|
!
connection
.
split
(
"
"
)
.
map
(
t
=
>
t
.
trim
(
)
.
toLowerCase
(
)
)
.
includes
(
"
upgrade
"
)
)
{
throw
new
Error
(
"
The
handshake
request
has
incorrect
Connection
header
"
)
;
}
const
version
=
headers
.
get
(
"
sec
-
websocket
-
version
"
)
;
if
(
!
version
|
|
version
!
=
=
"
13
"
)
{
throw
new
Error
(
"
The
handshake
request
must
have
Sec
-
WebSocket
-
Version
:
13
"
)
;
}
const
key
=
headers
.
get
(
"
sec
-
websocket
-
key
"
)
;
if
(
!
key
)
{
throw
new
Error
(
"
The
handshake
request
must
have
a
Sec
-
WebSocket
-
Key
header
"
)
;
}
return
{
acceptKey
:
computeKey
(
key
)
}
;
}
function
computeKey
(
key
)
{
const
str
=
{
key
}
258EAFA5
-
E914
-
47DA
-
95CA
-
C5AB0DC85B11
;
const
data
=
Array
.
from
(
str
ch
=
>
ch
.
charCodeAt
(
0
)
)
;
const
hash
=
new
lazy
.
CryptoHash
(
"
sha1
"
)
;
hash
.
update
(
data
data
.
length
)
;
return
hash
.
finish
(
true
)
;
}
async
function
serverHandshake
(
request
output
)
{
try
{
const
{
acceptKey
}
=
processRequest
(
request
)
;
await
writeHttpResponse
(
output
[
"
HTTP
/
1
.
1
101
Switching
Protocols
"
"
Server
:
httpd
.
js
"
"
Upgrade
:
websocket
"
"
Connection
:
Upgrade
"
Sec
-
WebSocket
-
Accept
:
{
acceptKey
}
]
)
;
}
catch
(
error
)
{
await
writeHttpResponse
(
output
[
"
HTTP
/
1
.
1
400
Bad
Request
"
"
Server
:
httpd
.
js
"
"
Content
-
Type
:
text
/
plain
"
]
error
.
message
)
;
throw
error
;
}
}
async
function
createWebSocket
(
transport
input
output
)
{
const
transportProvider
=
{
setListener
(
upgradeListener
)
{
lazy
.
executeSoon
(
(
)
=
>
{
upgradeListener
.
onTransportAvailable
(
transport
input
output
)
;
}
)
;
}
}
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
socket
=
WebSocket
.
createServerWebSocket
(
null
[
]
transportProvider
"
"
)
;
socket
.
addEventListener
(
"
close
"
(
)
=
>
{
input
.
close
(
)
;
output
.
close
(
)
;
}
)
;
socket
.
onopen
=
(
)
=
>
resolve
(
socket
)
;
socket
.
onerror
=
err
=
>
reject
(
err
)
;
}
)
;
}
async
function
upgrade
(
request
response
)
{
response
.
_powerSeized
=
true
;
const
{
transport
input
output
}
=
response
.
_connection
;
lazy
.
logger
.
info
(
Perform
WebSocket
upgrade
for
incoming
connection
from
{
transport
.
host
}
:
{
transport
.
port
}
)
;
const
headers
=
new
Map
(
)
;
for
(
let
[
key
values
]
of
Object
.
entries
(
request
.
_headers
.
_headers
)
)
{
headers
.
set
(
key
values
.
join
(
"
\
n
"
)
)
;
}
const
convertedRequest
=
{
requestLine
:
{
request
.
method
}
{
request
.
path
}
headers
}
;
await
serverHandshake
(
convertedRequest
output
)
;
return
createWebSocket
(
transport
input
output
)
;
}
const
WebSocketHandshake
=
{
upgrade
}
;
