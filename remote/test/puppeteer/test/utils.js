const
fs
=
require
(
'
fs
'
)
;
const
path
=
require
(
'
path
'
)
;
const
expect
=
require
(
'
expect
'
)
;
const
GoldenUtils
=
require
(
'
.
/
golden
-
utils
'
)
;
const
PROJECT_ROOT
=
fs
.
existsSync
(
path
.
join
(
__dirname
'
.
.
'
'
package
.
json
'
)
)
?
path
.
join
(
__dirname
'
.
.
'
)
:
path
.
join
(
__dirname
'
.
.
'
'
.
.
'
)
;
const
utils
=
(
module
.
exports
=
{
extendExpectWithToBeGolden
:
function
(
goldenDir
outputDir
)
{
expect
.
extend
(
{
toBeGolden
:
(
testScreenshot
goldenFilePath
)
=
>
{
const
result
=
GoldenUtils
.
compare
(
goldenDir
outputDir
testScreenshot
goldenFilePath
)
;
return
{
message
:
(
)
=
>
result
.
message
pass
:
result
.
pass
}
;
}
}
)
;
}
projectRoot
:
function
(
)
{
return
PROJECT_ROOT
;
}
attachFrame
:
async
function
(
page
frameId
url
)
{
const
handle
=
await
page
.
evaluateHandle
(
attachFrame
frameId
url
)
;
return
await
handle
.
asElement
(
)
.
contentFrame
(
)
;
async
function
attachFrame
(
frameId
url
)
{
const
frame
=
document
.
createElement
(
'
iframe
'
)
;
frame
.
src
=
url
;
frame
.
id
=
frameId
;
document
.
body
.
appendChild
(
frame
)
;
await
new
Promise
(
(
x
)
=
>
(
frame
.
onload
=
x
)
)
;
return
frame
;
}
}
isFavicon
:
function
(
request
)
{
return
request
.
url
(
)
.
includes
(
'
favicon
.
ico
'
)
;
}
detachFrame
:
async
function
(
page
frameId
)
{
await
page
.
evaluate
(
detachFrame
frameId
)
;
function
detachFrame
(
frameId
)
{
const
frame
=
document
.
getElementById
(
frameId
)
;
frame
.
remove
(
)
;
}
}
navigateFrame
:
async
function
(
page
frameId
url
)
{
await
page
.
evaluate
(
navigateFrame
frameId
url
)
;
function
navigateFrame
(
frameId
url
)
{
const
frame
=
document
.
getElementById
(
frameId
)
;
frame
.
src
=
url
;
return
new
Promise
(
(
x
)
=
>
(
frame
.
onload
=
x
)
)
;
}
}
dumpFrames
:
function
(
frame
indentation
)
{
indentation
=
indentation
|
|
'
'
;
let
description
=
frame
.
url
(
)
.
replace
(
/
:
\
d
{
4
}
\
/
/
'
:
<
PORT
>
/
'
)
;
if
(
frame
.
name
(
)
)
description
+
=
'
(
'
+
frame
.
name
(
)
+
'
)
'
;
const
result
=
[
indentation
+
description
]
;
for
(
const
child
of
frame
.
childFrames
(
)
)
result
.
push
(
.
.
.
utils
.
dumpFrames
(
child
'
'
+
indentation
)
)
;
return
result
;
}
waitEvent
:
function
(
emitter
eventName
predicate
=
(
)
=
>
true
)
{
return
new
Promise
(
(
fulfill
)
=
>
{
emitter
.
on
(
eventName
function
listener
(
event
)
{
if
(
!
predicate
(
event
)
)
return
;
emitter
.
removeListener
(
eventName
listener
)
;
fulfill
(
event
)
;
}
)
;
}
)
;
}
}
)
;
