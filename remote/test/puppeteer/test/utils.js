const
fs
=
require
(
'
fs
'
)
;
const
path
=
require
(
'
path
'
)
;
const
{
FlakinessDashboard
}
=
require
(
'
.
.
/
utils
/
flakiness
-
dashboard
'
)
;
const
PROJECT_ROOT
=
fs
.
existsSync
(
path
.
join
(
__dirname
'
.
.
'
'
package
.
json
'
)
)
?
path
.
join
(
__dirname
'
.
.
'
)
:
path
.
join
(
__dirname
'
.
.
'
'
.
.
'
)
;
const
COVERAGE_TESTSUITE_NAME
=
'
*
*
API
COVERAGE
*
*
'
;
function
traceAPICoverage
(
apiCoverage
events
className
classType
)
{
className
=
className
.
substring
(
0
1
)
.
toLowerCase
(
)
+
className
.
substring
(
1
)
;
for
(
const
methodName
of
Reflect
.
ownKeys
(
classType
.
prototype
)
)
{
const
method
=
Reflect
.
get
(
classType
.
prototype
methodName
)
;
if
(
methodName
=
=
=
'
constructor
'
|
|
typeof
methodName
!
=
=
'
string
'
|
|
methodName
.
startsWith
(
'
_
'
)
|
|
typeof
method
!
=
=
'
function
'
)
continue
;
apiCoverage
.
set
(
{
className
}
.
{
methodName
}
false
)
;
Reflect
.
set
(
classType
.
prototype
methodName
function
(
.
.
.
args
)
{
apiCoverage
.
set
(
{
className
}
.
{
methodName
}
true
)
;
return
method
.
call
(
this
.
.
.
args
)
;
}
)
;
}
if
(
events
[
classType
.
name
]
)
{
for
(
const
event
of
Object
.
values
(
events
[
classType
.
name
]
)
)
{
if
(
typeof
event
!
=
=
'
symbol
'
)
apiCoverage
.
set
(
{
className
}
.
emit
(
{
JSON
.
stringify
(
event
)
}
)
false
)
;
}
const
method
=
Reflect
.
get
(
classType
.
prototype
'
emit
'
)
;
Reflect
.
set
(
classType
.
prototype
'
emit
'
function
(
event
.
.
.
args
)
{
if
(
typeof
event
!
=
=
'
symbol
'
&
&
this
.
listenerCount
(
event
)
)
apiCoverage
.
set
(
{
className
}
.
emit
(
{
JSON
.
stringify
(
event
)
}
)
true
)
;
return
method
.
call
(
this
event
.
.
.
args
)
;
}
)
;
}
}
const
utils
=
module
.
exports
=
{
recordAPICoverage
:
function
(
testRunner
api
events
disabled
)
{
const
coverage
=
new
Map
(
)
;
for
(
const
[
className
classType
]
of
Object
.
entries
(
api
)
)
traceAPICoverage
(
coverage
events
className
classType
)
;
testRunner
.
describe
(
COVERAGE_TESTSUITE_NAME
(
)
=
>
{
testRunner
.
it
(
'
should
call
all
API
methods
'
(
)
=
>
{
const
missingMethods
=
[
]
;
for
(
const
method
of
coverage
.
keys
(
)
)
{
if
(
!
coverage
.
get
(
method
)
&
&
!
disabled
.
has
(
method
)
)
missingMethods
.
push
(
method
)
;
}
if
(
missingMethods
.
length
)
throw
new
Error
(
'
Certain
API
Methods
are
not
called
:
'
+
missingMethods
.
join
(
'
'
)
)
;
}
)
;
}
)
;
}
projectRoot
:
function
(
)
{
return
PROJECT_ROOT
;
}
attachFrame
:
async
function
(
page
frameId
url
)
{
const
handle
=
await
page
.
evaluateHandle
(
attachFrame
frameId
url
)
;
return
await
handle
.
asElement
(
)
.
contentFrame
(
)
;
async
function
attachFrame
(
frameId
url
)
{
const
frame
=
document
.
createElement
(
'
iframe
'
)
;
frame
.
src
=
url
;
frame
.
id
=
frameId
;
document
.
body
.
appendChild
(
frame
)
;
await
new
Promise
(
x
=
>
frame
.
onload
=
x
)
;
return
frame
;
}
}
isFavicon
:
function
(
request
)
{
return
request
.
url
(
)
.
includes
(
'
favicon
.
ico
'
)
;
}
detachFrame
:
async
function
(
page
frameId
)
{
await
page
.
evaluate
(
detachFrame
frameId
)
;
function
detachFrame
(
frameId
)
{
const
frame
=
document
.
getElementById
(
frameId
)
;
frame
.
remove
(
)
;
}
}
navigateFrame
:
async
function
(
page
frameId
url
)
{
await
page
.
evaluate
(
navigateFrame
frameId
url
)
;
function
navigateFrame
(
frameId
url
)
{
const
frame
=
document
.
getElementById
(
frameId
)
;
frame
.
src
=
url
;
return
new
Promise
(
x
=
>
frame
.
onload
=
x
)
;
}
}
dumpFrames
:
function
(
frame
indentation
)
{
indentation
=
indentation
|
|
'
'
;
let
description
=
frame
.
url
(
)
.
replace
(
/
:
\
d
{
4
}
\
/
/
'
:
<
PORT
>
/
'
)
;
if
(
frame
.
name
(
)
)
description
+
=
'
(
'
+
frame
.
name
(
)
+
'
)
'
;
const
result
=
[
indentation
+
description
]
;
for
(
const
child
of
frame
.
childFrames
(
)
)
result
.
push
(
.
.
.
utils
.
dumpFrames
(
child
'
'
+
indentation
)
)
;
return
result
;
}
waitEvent
:
function
(
emitter
eventName
predicate
=
(
)
=
>
true
)
{
return
new
Promise
(
fulfill
=
>
{
emitter
.
on
(
eventName
function
listener
(
event
)
{
if
(
!
predicate
(
event
)
)
return
;
emitter
.
removeListener
(
eventName
listener
)
;
fulfill
(
event
)
;
}
)
;
}
)
;
}
initializeFlakinessDashboardIfNeeded
:
async
function
(
testRunner
)
{
if
(
process
.
env
.
CI
)
generateTestIDs
(
testRunner
)
;
if
(
!
process
.
env
.
FLAKINESS_DASHBOARD_PASSWORD
|
|
process
.
env
.
CIRRUS_BASE_SHA
)
return
;
const
{
sha
timestamp
}
=
await
FlakinessDashboard
.
getCommitDetails
(
__dirname
'
HEAD
'
)
;
const
dashboard
=
new
FlakinessDashboard
(
{
commit
:
{
sha
timestamp
url
:
https
:
/
/
github
.
com
/
puppeteer
/
puppeteer
/
commit
/
{
sha
}
}
build
:
{
url
:
process
.
env
.
FLAKINESS_DASHBOARD_BUILD_URL
}
dashboardRepo
:
{
url
:
'
https
:
/
/
github
.
com
/
aslushnikov
/
puppeteer
-
flakiness
-
dashboard
.
git
'
username
:
'
puppeteer
-
flakiness
'
email
:
'
aslushnikov
+
puppeteerflakiness
gmail
.
com
'
password
:
process
.
env
.
FLAKINESS_DASHBOARD_PASSWORD
branch
:
process
.
env
.
FLAKINESS_DASHBOARD_NAME
}
}
)
;
testRunner
.
on
(
'
testfinished
'
test
=
>
{
if
(
test
.
fullName
.
includes
(
COVERAGE_TESTSUITE_NAME
)
)
return
;
const
testpath
=
test
.
location
.
filePath
.
substring
(
utils
.
projectRoot
(
)
.
length
)
;
const
url
=
https
:
/
/
github
.
com
/
puppeteer
/
puppeteer
/
blob
/
{
sha
}
/
{
testpath
}
#
L
{
test
.
location
.
lineNumber
}
;
dashboard
.
reportTestResult
(
{
testId
:
test
.
testId
name
:
test
.
location
.
fileName
+
'
:
'
+
test
.
location
.
lineNumber
description
:
test
.
fullName
url
result
:
test
.
result
}
)
;
}
)
;
testRunner
.
on
(
'
finished
'
async
(
{
result
}
)
=
>
{
dashboard
.
setBuildResult
(
result
)
;
await
dashboard
.
uploadAndCleanup
(
)
;
}
)
;
function
generateTestIDs
(
testRunner
)
{
const
testIds
=
new
Map
(
)
;
for
(
const
test
of
testRunner
.
tests
(
)
)
{
const
testIdComponents
=
[
test
.
name
]
;
for
(
let
suite
=
test
.
suite
;
!
!
suite
.
parentSuite
;
suite
=
suite
.
parentSuite
)
testIdComponents
.
push
(
suite
.
name
)
;
testIdComponents
.
reverse
(
)
;
const
testId
=
testIdComponents
.
join
(
'
>
'
)
;
const
clashingTest
=
testIds
.
get
(
testId
)
;
if
(
clashingTest
)
throw
new
Error
(
Two
tests
with
clashing
IDs
:
{
test
.
location
.
fileName
}
:
{
test
.
location
.
lineNumber
}
and
{
clashingTest
.
location
.
fileName
}
:
{
clashingTest
.
location
.
lineNumber
}
)
;
testIds
.
set
(
testId
test
)
;
test
.
testId
=
testId
;
}
}
}
}
;
