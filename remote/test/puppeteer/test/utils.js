const
fs
=
require
(
'
fs
'
)
;
const
path
=
require
(
'
path
'
)
;
const
PROJECT_ROOT
=
fs
.
existsSync
(
path
.
join
(
__dirname
'
.
.
'
'
package
.
json
'
)
)
?
path
.
join
(
__dirname
'
.
.
'
)
:
path
.
join
(
__dirname
'
.
.
'
'
.
.
'
)
;
function
traceAPICoverage
(
apiCoverage
className
classType
)
{
className
=
className
.
substring
(
0
1
)
.
toLowerCase
(
)
+
className
.
substring
(
1
)
;
for
(
const
methodName
of
Reflect
.
ownKeys
(
classType
.
prototype
)
)
{
const
method
=
Reflect
.
get
(
classType
.
prototype
methodName
)
;
if
(
methodName
=
=
=
'
constructor
'
|
|
typeof
methodName
!
=
=
'
string
'
|
|
methodName
.
startsWith
(
'
_
'
)
|
|
typeof
method
!
=
=
'
function
'
)
continue
;
apiCoverage
.
set
(
{
className
}
.
{
methodName
}
false
)
;
Reflect
.
set
(
classType
.
prototype
methodName
function
(
.
.
.
args
)
{
apiCoverage
.
set
(
{
className
}
.
{
methodName
}
true
)
;
return
method
.
call
(
this
.
.
.
args
)
;
}
)
;
}
if
(
classType
.
Events
)
{
for
(
const
event
of
Object
.
values
(
classType
.
Events
)
)
apiCoverage
.
set
(
{
className
}
.
emit
(
{
JSON
.
stringify
(
event
)
}
)
false
)
;
const
method
=
Reflect
.
get
(
classType
.
prototype
'
emit
'
)
;
Reflect
.
set
(
classType
.
prototype
'
emit
'
function
(
event
.
.
.
args
)
{
if
(
this
.
listenerCount
(
event
)
)
apiCoverage
.
set
(
{
className
}
.
emit
(
{
JSON
.
stringify
(
event
)
}
)
true
)
;
return
method
.
call
(
this
event
.
.
.
args
)
;
}
)
;
}
}
const
utils
=
module
.
exports
=
{
recordAPICoverage
:
function
(
testRunner
api
disabled
)
{
const
coverage
=
new
Map
(
)
;
for
(
const
[
className
classType
]
of
Object
.
entries
(
api
)
)
traceAPICoverage
(
coverage
className
classType
)
;
testRunner
.
describe
(
'
COVERAGE
'
(
)
=
>
{
for
(
const
method
of
coverage
.
keys
(
)
)
{
(
disabled
.
has
(
method
)
?
testRunner
.
xit
:
testRunner
.
it
)
(
public
api
'
{
method
}
'
should
be
called
async
(
{
page
server
}
)
=
>
{
if
(
!
coverage
.
get
(
method
)
)
throw
new
Error
(
'
NOT
CALLED
!
'
)
;
}
)
;
}
}
)
;
}
projectRoot
:
function
(
)
{
return
PROJECT_ROOT
;
}
attachFrame
:
async
function
(
page
frameId
url
)
{
const
handle
=
await
page
.
evaluateHandle
(
attachFrame
frameId
url
)
;
return
await
handle
.
asElement
(
)
.
contentFrame
(
)
;
async
function
attachFrame
(
frameId
url
)
{
const
frame
=
document
.
createElement
(
'
iframe
'
)
;
frame
.
src
=
url
;
frame
.
id
=
frameId
;
document
.
body
.
appendChild
(
frame
)
;
await
new
Promise
(
x
=
>
frame
.
onload
=
x
)
;
return
frame
;
}
}
isFavicon
:
function
(
request
)
{
return
request
.
url
(
)
.
includes
(
'
favicon
.
ico
'
)
;
}
detachFrame
:
async
function
(
page
frameId
)
{
await
page
.
evaluate
(
detachFrame
frameId
)
;
function
detachFrame
(
frameId
)
{
const
frame
=
document
.
getElementById
(
frameId
)
;
frame
.
remove
(
)
;
}
}
navigateFrame
:
async
function
(
page
frameId
url
)
{
await
page
.
evaluate
(
navigateFrame
frameId
url
)
;
function
navigateFrame
(
frameId
url
)
{
const
frame
=
document
.
getElementById
(
frameId
)
;
frame
.
src
=
url
;
return
new
Promise
(
x
=
>
frame
.
onload
=
x
)
;
}
}
dumpFrames
:
function
(
frame
indentation
)
{
indentation
=
indentation
|
|
'
'
;
let
description
=
frame
.
url
(
)
.
replace
(
/
:
\
d
{
4
}
\
/
/
'
:
<
PORT
>
/
'
)
;
if
(
frame
.
name
(
)
)
description
+
=
'
(
'
+
frame
.
name
(
)
+
'
)
'
;
const
result
=
[
indentation
+
description
]
;
for
(
const
child
of
frame
.
childFrames
(
)
)
result
.
push
(
.
.
.
utils
.
dumpFrames
(
child
'
'
+
indentation
)
)
;
return
result
;
}
waitEvent
:
function
(
emitter
eventName
predicate
=
(
)
=
>
true
)
{
return
new
Promise
(
fulfill
=
>
{
emitter
.
on
(
eventName
function
listener
(
event
)
{
if
(
!
predicate
(
event
)
)
return
;
emitter
.
removeListener
(
eventName
listener
)
;
fulfill
(
event
)
;
}
)
;
}
)
;
}
}
;
