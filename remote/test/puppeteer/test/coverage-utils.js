const
path
=
require
(
'
path
'
)
;
const
fs
=
require
(
'
fs
'
)
;
const
MODULES_TO_CHECK_FOR_COVERAGE
=
{
Accessibility
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Accessibility
'
Browser
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Browser
'
BrowserContext
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Browser
'
BrowserFetcher
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
node
/
BrowserFetcher
'
CDPSession
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Connection
'
ConsoleMessage
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
ConsoleMessage
'
Coverage
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Coverage
'
Dialog
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Dialog
'
ElementHandle
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
JSHandle
'
ExecutionContext
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
ExecutionContext
'
EventEmitter
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
EventEmitter
'
FileChooser
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
FileChooser
'
Frame
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
FrameManager
'
JSHandle
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
JSHandle
'
Keyboard
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Input
'
Mouse
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Input
'
Page
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Page
'
Puppeteer
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Puppeteer
'
PuppeteerNode
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
node
/
Puppeteer
'
HTTPRequest
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
HTTPRequest
'
HTTPResponse
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
HTTPResponse
'
SecurityDetails
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
SecurityDetails
'
Target
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Target
'
TimeoutError
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Errors
'
Touchscreen
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Input
'
Tracing
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
Tracing
'
WebWorker
:
'
.
.
/
lib
/
cjs
/
puppeteer
/
common
/
WebWorker
'
}
;
function
traceAPICoverage
(
apiCoverage
className
modulePath
)
{
const
loadedModule
=
require
(
modulePath
)
;
const
classType
=
loadedModule
[
className
]
;
if
(
!
classType
|
|
!
classType
.
prototype
)
{
console
.
error
(
Coverage
error
:
could
not
find
class
for
{
className
}
.
Is
src
/
api
.
ts
up
to
date
?
)
;
process
.
exit
(
1
)
;
}
for
(
const
methodName
of
Reflect
.
ownKeys
(
classType
.
prototype
)
)
{
const
method
=
Reflect
.
get
(
classType
.
prototype
methodName
)
;
if
(
methodName
=
=
=
'
constructor
'
|
|
typeof
methodName
!
=
=
'
string
'
|
|
methodName
.
startsWith
(
'
_
'
)
|
|
typeof
method
!
=
=
'
function
'
)
continue
;
apiCoverage
.
set
(
{
className
}
.
{
methodName
}
false
)
;
Reflect
.
set
(
classType
.
prototype
methodName
function
(
.
.
.
args
)
{
apiCoverage
.
set
(
{
className
}
.
{
methodName
}
true
)
;
return
method
.
call
(
this
.
.
.
args
)
;
}
)
;
}
const
eventsName
=
{
className
}
EmittedEvents
;
if
(
loadedModule
[
eventsName
]
)
{
for
(
const
event
of
Object
.
values
(
loadedModule
[
eventsName
]
)
)
{
if
(
typeof
event
!
=
=
'
symbol
'
)
apiCoverage
.
set
(
{
className
}
.
emit
(
{
JSON
.
stringify
(
event
)
}
)
false
)
;
}
const
method
=
Reflect
.
get
(
classType
.
prototype
'
emit
'
)
;
Reflect
.
set
(
classType
.
prototype
'
emit
'
function
(
event
.
.
.
args
)
{
if
(
typeof
event
!
=
=
'
symbol
'
&
&
this
.
listenerCount
(
event
)
)
apiCoverage
.
set
(
{
className
}
.
emit
(
{
JSON
.
stringify
(
event
)
}
)
true
)
;
return
method
.
call
(
this
event
.
.
.
args
)
;
}
)
;
}
}
const
coverageLocation
=
path
.
join
(
__dirname
'
coverage
.
json
'
)
;
const
clearOldCoverage
=
(
)
=
>
{
try
{
fs
.
unlinkSync
(
coverageLocation
)
;
}
catch
(
error
)
{
}
}
;
const
writeCoverage
=
(
coverage
)
=
>
{
fs
.
writeFileSync
(
coverageLocation
JSON
.
stringify
(
[
.
.
.
coverage
.
entries
(
)
]
)
)
;
}
;
const
getCoverageResults
=
(
)
=
>
{
let
contents
;
try
{
contents
=
fs
.
readFileSync
(
coverageLocation
{
encoding
:
'
utf8
'
}
)
;
}
catch
(
error
)
{
console
.
error
(
'
Warning
:
coverage
file
does
not
exist
or
is
not
readable
.
'
)
;
}
const
coverageMap
=
new
Map
(
JSON
.
parse
(
contents
)
)
;
return
coverageMap
;
}
;
const
trackCoverage
=
(
)
=
>
{
clearOldCoverage
(
)
;
const
coverageMap
=
new
Map
(
)
;
return
{
beforeAll
:
(
)
=
>
{
for
(
const
[
className
moduleFilePath
]
of
Object
.
entries
(
MODULES_TO_CHECK_FOR_COVERAGE
)
)
{
traceAPICoverage
(
coverageMap
className
moduleFilePath
)
;
}
}
afterAll
:
(
)
=
>
{
writeCoverage
(
coverageMap
)
;
}
}
;
}
;
module
.
exports
=
{
trackCoverage
getCoverageResults
MODULES_TO_CHECK_FOR_COVERAGE
}
;
