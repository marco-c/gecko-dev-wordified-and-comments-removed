module
.
exports
.
addTests
=
function
(
{
testRunner
expect
defaultBrowserOptions
puppeteer
}
)
{
const
{
describe
xdescribe
fdescribe
}
=
testRunner
;
const
{
it
fit
xit
}
=
testRunner
;
const
{
beforeAll
beforeEach
afterAll
afterEach
}
=
testRunner
;
describe
(
'
OOPIF
'
function
(
)
{
beforeAll
(
async
function
(
state
)
{
state
.
browser
=
await
puppeteer
.
launch
(
Object
.
assign
(
{
}
defaultBrowserOptions
{
args
:
(
defaultBrowserOptions
.
args
|
|
[
]
)
.
concat
(
[
'
-
-
site
-
per
-
process
'
]
)
}
)
)
;
}
)
;
beforeEach
(
async
function
(
state
)
{
state
.
context
=
await
state
.
browser
.
createIncognitoBrowserContext
(
)
;
state
.
page
=
await
state
.
context
.
newPage
(
)
;
}
)
;
afterEach
(
async
function
(
state
)
{
await
state
.
context
.
close
(
)
;
state
.
page
=
null
;
state
.
context
=
null
;
}
)
;
afterAll
(
async
function
(
state
)
{
await
state
.
browser
.
close
(
)
;
state
.
browser
=
null
;
}
)
;
xit
(
'
should
report
oopif
frames
'
async
function
(
{
page
server
context
}
)
{
await
page
.
goto
(
server
.
PREFIX
+
'
/
dynamic
-
oopif
.
html
'
)
;
expect
(
oopifs
(
context
)
.
length
)
.
toBe
(
1
)
;
expect
(
page
.
frames
(
)
.
length
)
.
toBe
(
2
)
;
}
)
;
it
(
'
should
load
oopif
iframes
with
subresources
and
request
interception
'
async
function
(
{
page
server
context
}
)
{
await
page
.
setRequestInterception
(
true
)
;
page
.
on
(
'
request
'
request
=
>
request
.
continue
(
)
)
;
await
page
.
goto
(
server
.
PREFIX
+
'
/
dynamic
-
oopif
.
html
'
)
;
expect
(
oopifs
(
context
)
.
length
)
.
toBe
(
1
)
;
}
)
;
}
)
;
}
;
function
oopifs
(
context
)
{
return
context
.
targets
(
)
.
filter
(
target
=
>
target
.
_targetInfo
.
type
=
=
=
'
iframe
'
)
;
}
