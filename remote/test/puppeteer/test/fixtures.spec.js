const
expect
=
require
(
'
expect
'
)
;
const
{
getTestState
}
=
require
(
'
.
/
mocha
-
utils
'
)
;
const
path
=
require
(
'
path
'
)
;
describe
(
'
Fixtures
'
function
(
)
{
itChromeOnly
(
'
dumpio
option
should
work
with
pipe
option
'
async
(
)
=
>
{
const
{
defaultBrowserOptions
puppeteerPath
}
=
getTestState
(
)
;
let
dumpioData
=
'
'
;
const
{
spawn
}
=
require
(
'
child_process
'
)
;
const
options
=
Object
.
assign
(
{
}
defaultBrowserOptions
{
pipe
:
true
dumpio
:
true
}
)
;
const
res
=
spawn
(
'
node
'
[
path
.
join
(
__dirname
'
fixtures
'
'
dumpio
.
js
'
)
puppeteerPath
JSON
.
stringify
(
options
)
]
)
;
res
.
stderr
.
on
(
'
data
'
(
data
)
=
>
(
dumpioData
+
=
data
.
toString
(
'
utf8
'
)
)
)
;
await
new
Promise
(
(
resolve
)
=
>
res
.
on
(
'
close
'
resolve
)
)
;
expect
(
dumpioData
)
.
toContain
(
'
message
from
dumpio
'
)
;
}
)
;
it
(
'
should
dump
browser
process
stderr
'
async
(
)
=
>
{
const
{
defaultBrowserOptions
puppeteerPath
}
=
getTestState
(
)
;
let
dumpioData
=
'
'
;
const
{
spawn
}
=
require
(
'
child_process
'
)
;
const
options
=
Object
.
assign
(
{
}
defaultBrowserOptions
{
dumpio
:
true
}
)
;
const
res
=
spawn
(
'
node
'
[
path
.
join
(
__dirname
'
fixtures
'
'
dumpio
.
js
'
)
puppeteerPath
JSON
.
stringify
(
options
)
]
)
;
res
.
stderr
.
on
(
'
data
'
(
data
)
=
>
(
dumpioData
+
=
data
.
toString
(
'
utf8
'
)
)
)
;
await
new
Promise
(
(
resolve
)
=
>
res
.
on
(
'
close
'
resolve
)
)
;
expect
(
dumpioData
)
.
toContain
(
'
DevTools
listening
on
ws
:
/
/
'
)
;
}
)
;
it
(
'
should
close
the
browser
when
the
node
process
closes
'
async
(
)
=
>
{
const
{
defaultBrowserOptions
puppeteerPath
puppeteer
}
=
getTestState
(
)
;
const
{
spawn
execSync
}
=
require
(
'
child_process
'
)
;
const
options
=
Object
.
assign
(
{
}
defaultBrowserOptions
{
dumpio
:
false
}
)
;
const
res
=
spawn
(
'
node
'
[
path
.
join
(
__dirname
'
fixtures
'
'
closeme
.
js
'
)
puppeteerPath
JSON
.
stringify
(
options
)
]
)
;
let
wsEndPointCallback
;
const
wsEndPointPromise
=
new
Promise
(
(
x
)
=
>
(
wsEndPointCallback
=
x
)
)
;
let
output
=
'
'
;
res
.
stdout
.
on
(
'
data
'
(
data
)
=
>
{
output
+
=
data
;
if
(
output
.
indexOf
(
'
\
n
'
)
)
wsEndPointCallback
(
output
.
substring
(
0
output
.
indexOf
(
'
\
n
'
)
)
)
;
}
)
;
const
browser
=
await
puppeteer
.
connect
(
{
browserWSEndpoint
:
await
wsEndPointPromise
}
)
;
const
promises
=
[
new
Promise
(
(
resolve
)
=
>
browser
.
once
(
'
disconnected
'
resolve
)
)
new
Promise
(
(
resolve
)
=
>
res
.
on
(
'
close
'
resolve
)
)
]
;
if
(
process
.
platform
=
=
=
'
win32
'
)
execSync
(
taskkill
/
pid
{
res
.
pid
}
/
T
/
F
)
;
else
process
.
kill
(
res
.
pid
)
;
await
Promise
.
all
(
promises
)
;
}
)
;
}
)
;
