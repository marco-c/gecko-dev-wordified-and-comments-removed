import
assert
from
'
assert
'
;
import
{
existsSync
}
from
'
fs
'
;
import
{
mkdir
unlink
}
from
'
fs
/
promises
'
;
import
os
from
'
os
'
;
import
path
from
'
path
'
;
import
{
Browser
BrowserPlatform
downloadUrls
}
from
'
.
/
browser
-
data
/
browser
-
data
.
js
'
;
import
{
Cache
InstalledBrowser
}
from
'
.
/
Cache
.
js
'
;
import
{
debug
}
from
'
.
/
debug
.
js
'
;
import
{
detectBrowserPlatform
}
from
'
.
/
detectPlatform
.
js
'
;
import
{
unpackArchive
}
from
'
.
/
fileUtil
.
js
'
;
import
{
downloadFile
headHttpRequest
}
from
'
.
/
httpUtil
.
js
'
;
const
debugInstall
=
debug
(
'
puppeteer
:
browsers
:
install
'
)
;
const
times
=
new
Map
<
string
[
number
number
]
>
(
)
;
function
debugTime
(
label
:
string
)
{
times
.
set
(
label
process
.
hrtime
(
)
)
;
}
function
debugTimeEnd
(
label
:
string
)
{
const
end
=
process
.
hrtime
(
)
;
const
start
=
times
.
get
(
label
)
;
if
(
!
start
)
{
return
;
}
const
duration
=
end
[
0
]
*
1000
+
end
[
1
]
/
1e6
-
(
start
[
0
]
*
1000
+
start
[
1
]
/
1e6
)
;
debugInstall
(
Duration
for
{
label
}
:
{
duration
}
ms
)
;
}
export
interface
InstallOptions
{
cacheDir
:
string
;
platform
?
:
BrowserPlatform
;
browser
:
Browser
;
buildId
:
string
;
downloadProgressCallback
?
:
(
downloadedBytes
:
number
totalBytes
:
number
)
=
>
void
;
baseUrl
?
:
string
;
unpack
?
:
boolean
;
}
export
async
function
install
(
options
:
InstallOptions
)
:
Promise
<
InstalledBrowser
>
{
options
.
platform
?
?
=
detectBrowserPlatform
(
)
;
options
.
unpack
?
?
=
true
;
if
(
!
options
.
platform
)
{
throw
new
Error
(
Cannot
download
a
binary
for
the
provided
platform
:
{
os
.
platform
(
)
}
(
{
os
.
arch
(
)
}
)
)
;
}
const
url
=
getDownloadUrl
(
options
.
browser
options
.
platform
options
.
buildId
options
.
baseUrl
)
;
const
fileName
=
url
.
toString
(
)
.
split
(
'
/
'
)
.
pop
(
)
;
assert
(
fileName
A
malformed
download
URL
was
found
:
{
url
}
.
)
;
const
structure
=
new
Cache
(
options
.
cacheDir
)
;
const
browserRoot
=
structure
.
browserRoot
(
options
.
browser
)
;
const
archivePath
=
path
.
join
(
browserRoot
fileName
)
;
if
(
!
existsSync
(
browserRoot
)
)
{
await
mkdir
(
browserRoot
{
recursive
:
true
}
)
;
}
if
(
!
options
.
unpack
)
{
if
(
existsSync
(
archivePath
)
)
{
return
{
path
:
archivePath
browser
:
options
.
browser
platform
:
options
.
platform
buildId
:
options
.
buildId
}
;
}
debugInstall
(
Downloading
binary
from
{
url
}
)
;
debugTime
(
'
download
'
)
;
await
downloadFile
(
url
archivePath
options
.
downloadProgressCallback
)
;
debugTimeEnd
(
'
download
'
)
;
return
{
path
:
archivePath
browser
:
options
.
browser
platform
:
options
.
platform
buildId
:
options
.
buildId
}
;
}
const
outputPath
=
structure
.
installationDir
(
options
.
browser
options
.
platform
options
.
buildId
)
;
if
(
existsSync
(
outputPath
)
)
{
return
{
path
:
outputPath
browser
:
options
.
browser
platform
:
options
.
platform
buildId
:
options
.
buildId
}
;
}
try
{
debugInstall
(
Downloading
binary
from
{
url
}
)
;
try
{
debugTime
(
'
download
'
)
;
await
downloadFile
(
url
archivePath
options
.
downloadProgressCallback
)
;
}
finally
{
debugTimeEnd
(
'
download
'
)
;
}
debugInstall
(
Installing
{
archivePath
}
to
{
outputPath
}
)
;
try
{
debugTime
(
'
extract
'
)
;
await
unpackArchive
(
archivePath
outputPath
)
;
}
finally
{
debugTimeEnd
(
'
extract
'
)
;
}
}
finally
{
if
(
existsSync
(
archivePath
)
)
{
await
unlink
(
archivePath
)
;
}
}
return
{
path
:
outputPath
browser
:
options
.
browser
platform
:
options
.
platform
buildId
:
options
.
buildId
}
;
}
export
async
function
canDownload
(
options
:
InstallOptions
)
:
Promise
<
boolean
>
{
options
.
platform
?
?
=
detectBrowserPlatform
(
)
;
if
(
!
options
.
platform
)
{
throw
new
Error
(
Cannot
download
a
binary
for
the
provided
platform
:
{
os
.
platform
(
)
}
(
{
os
.
arch
(
)
}
)
)
;
}
return
await
headHttpRequest
(
getDownloadUrl
(
options
.
browser
options
.
platform
options
.
buildId
options
.
baseUrl
)
)
;
}
function
getDownloadUrl
(
browser
:
Browser
platform
:
BrowserPlatform
buildId
:
string
baseUrl
?
:
string
)
:
URL
{
return
new
URL
(
downloadUrls
[
browser
]
(
platform
buildId
baseUrl
)
)
;
}
