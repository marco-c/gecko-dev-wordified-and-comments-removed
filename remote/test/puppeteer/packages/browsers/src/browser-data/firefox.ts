import
fs
from
'
node
:
fs
'
;
import
path
from
'
node
:
path
'
;
import
{
getJSON
}
from
'
.
.
/
httpUtil
.
js
'
;
import
{
BrowserPlatform
type
ProfileOptions
}
from
'
.
/
types
.
js
'
;
function
getFormat
(
buildId
:
string
)
:
string
{
const
majorVersion
=
Number
(
buildId
.
split
(
'
.
'
)
.
shift
(
)
!
)
;
return
majorVersion
>
=
135
?
'
xz
'
:
'
bz2
'
;
}
function
archiveNightly
(
platform
:
BrowserPlatform
buildId
:
string
)
:
string
{
switch
(
platform
)
{
case
BrowserPlatform
.
LINUX
:
return
firefox
-
{
buildId
}
.
en
-
US
.
linux
-
x86_64
.
tar
.
{
getFormat
(
buildId
)
}
;
case
BrowserPlatform
.
LINUX_ARM
:
return
firefox
-
{
buildId
}
.
en
-
US
.
linux
-
aarch64
.
tar
.
{
getFormat
(
buildId
)
}
;
case
BrowserPlatform
.
MAC_ARM
:
case
BrowserPlatform
.
MAC
:
return
firefox
-
{
buildId
}
.
en
-
US
.
mac
.
dmg
;
case
BrowserPlatform
.
WIN32
:
case
BrowserPlatform
.
WIN64
:
return
firefox
-
{
buildId
}
.
en
-
US
.
{
platform
}
.
zip
;
}
}
function
archive
(
platform
:
BrowserPlatform
buildId
:
string
)
:
string
{
switch
(
platform
)
{
case
BrowserPlatform
.
LINUX_ARM
:
case
BrowserPlatform
.
LINUX
:
return
firefox
-
{
buildId
}
.
tar
.
{
getFormat
(
buildId
)
}
;
case
BrowserPlatform
.
MAC_ARM
:
case
BrowserPlatform
.
MAC
:
return
Firefox
{
buildId
}
.
dmg
;
case
BrowserPlatform
.
WIN32
:
case
BrowserPlatform
.
WIN64
:
return
Firefox
Setup
{
buildId
}
.
exe
;
}
}
function
platformName
(
platform
:
BrowserPlatform
)
:
string
{
switch
(
platform
)
{
case
BrowserPlatform
.
LINUX
:
return
linux
-
x86_64
;
case
BrowserPlatform
.
LINUX_ARM
:
return
linux
-
aarch64
;
case
BrowserPlatform
.
MAC_ARM
:
case
BrowserPlatform
.
MAC
:
return
mac
;
case
BrowserPlatform
.
WIN32
:
case
BrowserPlatform
.
WIN64
:
return
platform
;
}
}
function
parseBuildId
(
buildId
:
string
)
:
[
FirefoxChannel
string
]
{
for
(
const
value
of
Object
.
values
(
FirefoxChannel
)
)
{
if
(
buildId
.
startsWith
(
value
+
'
_
'
)
)
{
buildId
=
buildId
.
substring
(
value
.
length
+
1
)
;
return
[
value
buildId
]
;
}
}
return
[
FirefoxChannel
.
NIGHTLY
buildId
]
;
}
export
function
resolveDownloadUrl
(
platform
:
BrowserPlatform
buildId
:
string
baseUrl
?
:
string
)
:
string
{
const
[
channel
]
=
parseBuildId
(
buildId
)
;
switch
(
channel
)
{
case
FirefoxChannel
.
NIGHTLY
:
baseUrl
?
?
=
'
https
:
/
/
archive
.
mozilla
.
org
/
pub
/
firefox
/
nightly
/
latest
-
mozilla
-
central
'
;
break
;
case
FirefoxChannel
.
DEVEDITION
:
baseUrl
?
?
=
'
https
:
/
/
archive
.
mozilla
.
org
/
pub
/
devedition
/
releases
'
;
break
;
case
FirefoxChannel
.
BETA
:
case
FirefoxChannel
.
STABLE
:
case
FirefoxChannel
.
ESR
:
baseUrl
?
?
=
'
https
:
/
/
archive
.
mozilla
.
org
/
pub
/
firefox
/
releases
'
;
break
;
}
return
{
baseUrl
}
/
{
resolveDownloadPath
(
platform
buildId
)
.
join
(
'
/
'
)
}
;
}
export
function
resolveDownloadPath
(
platform
:
BrowserPlatform
buildId
:
string
)
:
string
[
]
{
const
[
channel
resolvedBuildId
]
=
parseBuildId
(
buildId
)
;
switch
(
channel
)
{
case
FirefoxChannel
.
NIGHTLY
:
return
[
archiveNightly
(
platform
resolvedBuildId
)
]
;
case
FirefoxChannel
.
DEVEDITION
:
case
FirefoxChannel
.
BETA
:
case
FirefoxChannel
.
STABLE
:
case
FirefoxChannel
.
ESR
:
return
[
resolvedBuildId
platformName
(
platform
)
'
en
-
US
'
archive
(
platform
resolvedBuildId
)
]
;
}
}
export
function
relativeExecutablePath
(
platform
:
BrowserPlatform
buildId
:
string
)
:
string
{
const
[
channel
]
=
parseBuildId
(
buildId
)
;
switch
(
channel
)
{
case
FirefoxChannel
.
NIGHTLY
:
switch
(
platform
)
{
case
BrowserPlatform
.
MAC_ARM
:
case
BrowserPlatform
.
MAC
:
return
path
.
join
(
'
Firefox
Nightly
.
app
'
'
Contents
'
'
MacOS
'
'
firefox
'
)
;
case
BrowserPlatform
.
LINUX_ARM
:
case
BrowserPlatform
.
LINUX
:
return
path
.
join
(
'
firefox
'
'
firefox
'
)
;
case
BrowserPlatform
.
WIN32
:
case
BrowserPlatform
.
WIN64
:
return
path
.
join
(
'
firefox
'
'
firefox
.
exe
'
)
;
}
case
FirefoxChannel
.
BETA
:
case
FirefoxChannel
.
DEVEDITION
:
case
FirefoxChannel
.
ESR
:
case
FirefoxChannel
.
STABLE
:
switch
(
platform
)
{
case
BrowserPlatform
.
MAC_ARM
:
case
BrowserPlatform
.
MAC
:
return
path
.
join
(
'
Firefox
.
app
'
'
Contents
'
'
MacOS
'
'
firefox
'
)
;
case
BrowserPlatform
.
LINUX_ARM
:
case
BrowserPlatform
.
LINUX
:
return
path
.
join
(
'
firefox
'
'
firefox
'
)
;
case
BrowserPlatform
.
WIN32
:
case
BrowserPlatform
.
WIN64
:
return
path
.
join
(
'
core
'
'
firefox
.
exe
'
)
;
}
}
}
export
enum
FirefoxChannel
{
STABLE
=
'
stable
'
ESR
=
'
esr
'
DEVEDITION
=
'
devedition
'
BETA
=
'
beta
'
NIGHTLY
=
'
nightly
'
}
export
async
function
resolveBuildId
(
channel
:
FirefoxChannel
=
FirefoxChannel
.
NIGHTLY
)
:
Promise
<
string
>
{
const
channelToVersionKey
=
{
[
FirefoxChannel
.
ESR
]
:
'
FIREFOX_ESR
'
[
FirefoxChannel
.
STABLE
]
:
'
LATEST_FIREFOX_VERSION
'
[
FirefoxChannel
.
DEVEDITION
]
:
'
FIREFOX_DEVEDITION
'
[
FirefoxChannel
.
BETA
]
:
'
FIREFOX_DEVEDITION
'
[
FirefoxChannel
.
NIGHTLY
]
:
'
FIREFOX_NIGHTLY
'
}
;
const
versions
=
(
await
getJSON
(
new
URL
(
'
https
:
/
/
product
-
details
.
mozilla
.
org
/
1
.
0
/
firefox_versions
.
json
'
)
)
)
as
Record
<
string
string
>
;
const
version
=
versions
[
channelToVersionKey
[
channel
]
]
;
if
(
!
version
)
{
throw
new
Error
(
Channel
{
channel
}
is
not
found
.
)
;
}
return
channel
+
'
_
'
+
version
;
}
export
async
function
createProfile
(
options
:
ProfileOptions
)
:
Promise
<
void
>
{
if
(
!
fs
.
existsSync
(
options
.
path
)
)
{
await
fs
.
promises
.
mkdir
(
options
.
path
{
recursive
:
true
}
)
;
}
await
syncPreferences
(
{
preferences
:
{
.
.
.
defaultProfilePreferences
(
options
.
preferences
)
.
.
.
options
.
preferences
}
path
:
options
.
path
}
)
;
}
function
defaultProfilePreferences
(
extraPrefs
:
Record
<
string
unknown
>
)
:
Record
<
string
unknown
>
{
const
server
=
'
dummy
.
test
'
;
const
defaultPrefs
=
{
'
app
.
normandy
.
api_url
'
:
'
'
'
app
.
update
.
checkInstallTime
'
:
false
'
app
.
update
.
disabledForTesting
'
:
true
'
apz
.
content_response_timeout
'
:
60000
'
browser
.
contentblocking
.
features
.
standard
'
:
'
-
tp
tpPrivate
cookieBehavior0
-
cryptoTP
-
fp
'
'
browser
.
dom
.
window
.
dump
.
enabled
'
:
true
'
browser
.
newtabpage
.
activity
-
stream
.
feeds
.
system
.
topstories
'
:
false
'
browser
.
newtabpage
.
enabled
'
:
false
'
browser
.
pagethumbnails
.
capturing_disabled
'
:
true
'
browser
.
safebrowsing
.
blockedURIs
.
enabled
'
:
false
'
browser
.
safebrowsing
.
downloads
.
enabled
'
:
false
'
browser
.
safebrowsing
.
malware
.
enabled
'
:
false
'
browser
.
safebrowsing
.
phishing
.
enabled
'
:
false
'
browser
.
search
.
update
'
:
false
'
browser
.
sessionstore
.
resume_from_crash
'
:
false
'
browser
.
shell
.
checkDefaultBrowser
'
:
false
'
browser
.
startup
.
homepage
'
:
'
about
:
blank
'
'
browser
.
startup
.
homepage_override
.
mstone
'
:
'
ignore
'
'
browser
.
startup
.
page
'
:
0
'
browser
.
tabs
.
disableBackgroundZombification
'
:
false
'
browser
.
tabs
.
warnOnCloseOtherTabs
'
:
false
'
browser
.
tabs
.
warnOnOpen
'
:
false
'
browser
.
translations
.
automaticallyPopup
'
:
false
'
browser
.
uitour
.
enabled
'
:
false
'
browser
.
urlbar
.
suggest
.
searches
'
:
false
'
browser
.
usedOnWindows10
.
introURL
'
:
'
'
'
browser
.
warnOnQuit
'
:
false
'
datareporting
.
healthreport
.
documentServerURI
'
:
http
:
/
/
{
server
}
/
dummy
/
healthreport
/
'
datareporting
.
healthreport
.
logging
.
consoleEnabled
'
:
false
'
datareporting
.
healthreport
.
service
.
enabled
'
:
false
'
datareporting
.
healthreport
.
service
.
firstRun
'
:
false
'
datareporting
.
healthreport
.
uploadEnabled
'
:
false
'
datareporting
.
policy
.
dataSubmissionEnabled
'
:
false
'
datareporting
.
policy
.
dataSubmissionPolicyBypassNotification
'
:
true
'
devtools
.
jsonview
.
enabled
'
:
false
'
dom
.
disable_open_during_load
'
:
false
'
dom
.
file
.
createInChild
'
:
true
'
dom
.
ipc
.
reportProcessHangs
'
:
false
'
dom
.
max_chrome_script_run_time
'
:
0
'
dom
.
max_script_run_time
'
:
0
'
extensions
.
autoDisableScopes
'
:
0
'
extensions
.
enabledScopes
'
:
5
'
extensions
.
getAddons
.
cache
.
enabled
'
:
false
'
extensions
.
installDistroAddons
'
:
false
'
extensions
.
update
.
enabled
'
:
false
'
extensions
.
update
.
notifyUser
'
:
false
'
extensions
.
webservice
.
discoverURL
'
:
http
:
/
/
{
server
}
/
dummy
/
discoveryURL
'
focusmanager
.
testmode
'
:
true
'
general
.
useragent
.
updates
.
enabled
'
:
false
'
geo
.
provider
.
testing
'
:
true
'
geo
.
wifi
.
scan
'
:
false
'
hangmonitor
.
timeout
'
:
0
'
javascript
.
options
.
showInConsole
'
:
true
'
media
.
gmp
-
manager
.
updateEnabled
'
:
false
'
media
.
sanity
-
test
.
disabled
'
:
true
'
network
.
cookie
.
sameSite
.
laxByDefault
'
:
false
'
network
.
http
.
prompt
-
temp
-
redirect
'
:
false
'
network
.
http
.
speculative
-
parallel
-
limit
'
:
0
'
network
.
manage
-
offline
-
status
'
:
false
'
network
.
sntp
.
pools
'
:
server
'
plugin
.
state
.
flash
'
:
0
'
privacy
.
trackingprotection
.
enabled
'
:
false
'
remote
.
enabled
'
:
true
'
screenshots
.
browser
.
component
.
enabled
'
:
false
'
security
.
certerrors
.
mitm
.
priming
.
enabled
'
:
false
'
security
.
fileuri
.
strict_origin_policy
'
:
false
'
security
.
notification_enable_delay
'
:
0
'
services
.
settings
.
server
'
:
http
:
/
/
{
server
}
/
dummy
/
blocklist
/
'
signon
.
autofillForms
'
:
false
'
signon
.
rememberSignons
'
:
false
'
startup
.
homepage_welcome_url
'
:
'
about
:
blank
'
'
startup
.
homepage_welcome_url
.
additional
'
:
'
'
'
toolkit
.
cosmeticAnimations
.
enabled
'
:
false
'
toolkit
.
startup
.
max_resumed_crashes
'
:
-
1
}
;
return
Object
.
assign
(
defaultPrefs
extraPrefs
)
;
}
async
function
backupFile
(
input
:
string
)
:
Promise
<
void
>
{
if
(
!
fs
.
existsSync
(
input
)
)
{
return
;
}
await
fs
.
promises
.
copyFile
(
input
input
+
'
.
puppeteer
'
)
;
}
async
function
syncPreferences
(
options
:
ProfileOptions
)
:
Promise
<
void
>
{
const
prefsPath
=
path
.
join
(
options
.
path
'
prefs
.
js
'
)
;
const
userPath
=
path
.
join
(
options
.
path
'
user
.
js
'
)
;
const
lines
=
Object
.
entries
(
options
.
preferences
)
.
map
(
(
[
key
value
]
)
=
>
{
return
user_pref
(
{
JSON
.
stringify
(
key
)
}
{
JSON
.
stringify
(
value
)
}
)
;
;
}
)
;
const
result
=
await
Promise
.
allSettled
(
[
backupFile
(
userPath
)
.
then
(
async
(
)
=
>
{
await
fs
.
promises
.
writeFile
(
userPath
lines
.
join
(
'
\
n
'
)
)
;
}
)
backupFile
(
prefsPath
)
]
)
;
for
(
const
command
of
result
)
{
if
(
command
.
status
=
=
=
'
rejected
'
)
{
throw
command
.
reason
;
}
}
}
export
function
compareVersions
(
a
:
string
b
:
string
)
:
number
{
return
parseInt
(
a
.
replace
(
'
.
'
'
'
)
16
)
-
parseInt
(
b
.
replace
(
'
.
'
'
'
)
16
)
;
}
