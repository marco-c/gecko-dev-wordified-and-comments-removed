import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
MAIN_WORLD
PUPPETEER_WORLD
}
from
'
.
/
IsolatedWorlds
.
js
'
;
async
function
queryAXTree
(
client
element
accessibleName
role
)
{
const
{
nodes
}
=
await
client
.
send
(
'
Accessibility
.
queryAXTree
'
{
objectId
:
element
.
remoteObject
(
)
.
objectId
accessibleName
role
}
)
;
const
filteredNodes
=
nodes
.
filter
(
(
node
)
=
>
{
return
!
node
.
role
|
|
node
.
role
.
value
!
=
=
'
StaticText
'
;
}
)
;
return
filteredNodes
;
}
const
normalizeValue
=
(
value
)
=
>
{
return
value
.
replace
(
/
+
/
g
'
'
)
.
trim
(
)
;
}
;
const
knownAttributes
=
new
Set
(
[
'
name
'
'
role
'
]
)
;
const
attributeRegexp
=
/
\
[
\
s
*
(
?
<
attribute
>
\
w
+
)
\
s
*
=
\
s
*
(
?
<
quote
>
"
|
'
)
(
?
<
value
>
\
\
.
|
.
*
?
(
?
=
\
k
<
quote
>
)
)
\
k
<
quote
>
\
s
*
\
]
/
g
;
function
isKnownAttribute
(
attribute
)
{
return
knownAttributes
.
has
(
attribute
)
;
}
function
parseAriaSelector
(
selector
)
{
const
queryOptions
=
{
}
;
const
defaultName
=
selector
.
replace
(
attributeRegexp
(
_
attribute
_quote
value
)
=
>
{
attribute
=
attribute
.
trim
(
)
;
assert
(
isKnownAttribute
(
attribute
)
Unknown
aria
attribute
"
{
attribute
}
"
in
selector
)
;
queryOptions
[
attribute
]
=
normalizeValue
(
value
)
;
return
'
'
;
}
)
;
if
(
defaultName
&
&
!
queryOptions
.
name
)
{
queryOptions
.
name
=
normalizeValue
(
defaultName
)
;
}
return
queryOptions
;
}
const
queryOneId
=
async
(
element
selector
)
=
>
{
const
{
name
role
}
=
parseAriaSelector
(
selector
)
;
const
res
=
await
queryAXTree
(
element
.
client
element
name
role
)
;
if
(
!
res
[
0
]
|
|
!
res
[
0
]
.
backendDOMNodeId
)
{
return
null
;
}
return
res
[
0
]
.
backendDOMNodeId
;
}
;
const
queryOne
=
async
(
element
selector
)
=
>
{
const
id
=
await
queryOneId
(
element
selector
)
;
if
(
!
id
)
{
return
null
;
}
return
(
await
element
.
frame
.
worlds
[
MAIN_WORLD
]
.
adoptBackendNode
(
id
)
)
;
}
;
const
waitFor
=
async
(
elementOrFrame
selector
options
)
=
>
{
let
frame
;
let
element
;
if
(
'
isOOPFrame
'
in
elementOrFrame
)
{
frame
=
elementOrFrame
;
}
else
{
frame
=
elementOrFrame
.
frame
;
element
=
await
frame
.
worlds
[
PUPPETEER_WORLD
]
.
adoptHandle
(
elementOrFrame
)
;
}
const
ariaQuerySelector
=
async
(
selector
)
=
>
{
const
id
=
await
queryOneId
(
element
|
|
(
await
frame
.
worlds
[
PUPPETEER_WORLD
]
.
document
(
)
)
selector
)
;
if
(
!
id
)
{
return
null
;
}
return
(
await
frame
.
worlds
[
PUPPETEER_WORLD
]
.
adoptBackendNode
(
id
)
)
;
}
;
const
result
=
await
frame
.
worlds
[
PUPPETEER_WORLD
]
.
_waitForSelectorInPage
(
(
_
selector
)
=
>
{
return
globalThis
.
ariaQuerySelector
(
selector
)
;
}
element
selector
options
new
Map
(
[
[
'
ariaQuerySelector
'
ariaQuerySelector
]
]
)
)
;
if
(
element
)
{
await
element
.
dispose
(
)
;
}
const
handle
=
result
=
=
=
null
|
|
result
=
=
=
void
0
?
void
0
:
result
.
asElement
(
)
;
if
(
!
handle
)
{
await
(
result
=
=
=
null
|
|
result
=
=
=
void
0
?
void
0
:
result
.
dispose
(
)
)
;
return
null
;
}
return
handle
.
frame
.
worlds
[
MAIN_WORLD
]
.
transferHandle
(
handle
)
;
}
;
const
queryAll
=
async
(
element
selector
)
=
>
{
const
exeCtx
=
element
.
executionContext
(
)
;
const
{
name
role
}
=
parseAriaSelector
(
selector
)
;
const
res
=
await
queryAXTree
(
exeCtx
.
_client
element
name
role
)
;
const
world
=
exeCtx
.
_world
;
return
Promise
.
all
(
res
.
map
(
axNode
=
>
{
return
world
.
adoptBackendNode
(
axNode
.
backendDOMNodeId
)
;
}
)
)
;
}
;
export
const
ariaHandler
=
{
queryOne
waitFor
queryAll
}
;
