"
use
strict
"
;
var
__classPrivateFieldGet
=
(
this
&
&
this
.
__classPrivateFieldGet
)
|
|
function
(
receiver
state
kind
f
)
{
if
(
kind
=
=
=
"
a
"
&
&
!
f
)
throw
new
TypeError
(
"
Private
accessor
was
defined
without
a
getter
"
)
;
if
(
typeof
state
=
=
=
"
function
"
?
receiver
!
=
=
state
|
|
!
f
:
!
state
.
has
(
receiver
)
)
throw
new
TypeError
(
"
Cannot
read
private
member
from
an
object
whose
class
did
not
declare
it
"
)
;
return
kind
=
=
=
"
m
"
?
f
:
kind
=
=
=
"
a
"
?
f
.
call
(
receiver
)
:
f
?
f
.
value
:
state
.
get
(
receiver
)
;
}
;
var
_ExecutionContext_instances
_ExecutionContext_evaluate
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
ExecutionContext
=
exports
.
EVALUATION_SCRIPT_URL
=
void
0
;
const
JSHandle_js_1
=
require
(
"
.
/
JSHandle
.
js
"
)
;
const
LazyArg_js_1
=
require
(
"
.
/
LazyArg
.
js
"
)
;
const
util_js_1
=
require
(
"
.
/
util
.
js
"
)
;
exports
.
EVALUATION_SCRIPT_URL
=
'
pptr
:
/
/
__puppeteer_evaluation_script__
'
;
const
SOURCE_URL_REGEX
=
/
^
[
\
040
\
t
]
*
\
/
\
/
[
#
]
sourceURL
=
\
s
*
(
\
S
*
?
)
\
s
*
/
m
;
class
ExecutionContext
{
constructor
(
client
contextPayload
world
)
{
_ExecutionContext_instances
.
add
(
this
)
;
this
.
_client
=
client
;
this
.
_world
=
world
;
this
.
_contextId
=
contextPayload
.
id
;
this
.
_contextName
=
contextPayload
.
name
;
}
async
evaluate
(
pageFunction
.
.
.
args
)
{
return
await
__classPrivateFieldGet
(
this
_ExecutionContext_instances
"
m
"
_ExecutionContext_evaluate
)
.
call
(
this
true
pageFunction
.
.
.
args
)
;
}
async
evaluateHandle
(
pageFunction
.
.
.
args
)
{
return
__classPrivateFieldGet
(
this
_ExecutionContext_instances
"
m
"
_ExecutionContext_evaluate
)
.
call
(
this
false
pageFunction
.
.
.
args
)
;
}
}
exports
.
ExecutionContext
=
ExecutionContext
;
_ExecutionContext_instances
=
new
WeakSet
(
)
_ExecutionContext_evaluate
=
async
function
_ExecutionContext_evaluate
(
returnByValue
pageFunction
.
.
.
args
)
{
const
suffix
=
/
/
#
sourceURL
=
{
exports
.
EVALUATION_SCRIPT_URL
}
;
if
(
(
0
util_js_1
.
isString
)
(
pageFunction
)
)
{
const
contextId
=
this
.
_contextId
;
const
expression
=
pageFunction
;
const
expressionWithSourceUrl
=
SOURCE_URL_REGEX
.
test
(
expression
)
?
expression
:
expression
+
'
\
n
'
+
suffix
;
const
{
exceptionDetails
result
:
remoteObject
}
=
await
this
.
_client
.
send
(
'
Runtime
.
evaluate
'
{
expression
:
expressionWithSourceUrl
contextId
returnByValue
awaitPromise
:
true
userGesture
:
true
}
)
.
catch
(
rewriteError
)
;
if
(
exceptionDetails
)
{
throw
new
Error
(
'
Evaluation
failed
:
'
+
(
0
util_js_1
.
getExceptionMessage
)
(
exceptionDetails
)
)
;
}
return
returnByValue
?
(
0
util_js_1
.
valueFromRemoteObject
)
(
remoteObject
)
:
(
0
util_js_1
.
createJSHandle
)
(
this
remoteObject
)
;
}
let
functionText
=
pageFunction
.
toString
(
)
;
try
{
new
Function
(
'
(
'
+
functionText
+
'
)
'
)
;
}
catch
(
error
)
{
if
(
functionText
.
startsWith
(
'
async
'
)
)
{
functionText
=
'
async
function
'
+
functionText
.
substring
(
'
async
'
.
length
)
;
}
else
{
functionText
=
'
function
'
+
functionText
;
}
try
{
new
Function
(
'
(
'
+
functionText
+
'
)
'
)
;
}
catch
(
error
)
{
throw
new
Error
(
'
Passed
function
is
not
well
-
serializable
!
'
)
;
}
}
let
callFunctionOnPromise
;
try
{
callFunctionOnPromise
=
this
.
_client
.
send
(
'
Runtime
.
callFunctionOn
'
{
functionDeclaration
:
functionText
+
'
\
n
'
+
suffix
+
'
\
n
'
executionContextId
:
this
.
_contextId
arguments
:
await
Promise
.
all
(
args
.
map
(
convertArgument
.
bind
(
this
)
)
)
returnByValue
awaitPromise
:
true
userGesture
:
true
}
)
;
}
catch
(
error
)
{
if
(
error
instanceof
TypeError
&
&
error
.
message
.
startsWith
(
'
Converting
circular
structure
to
JSON
'
)
)
{
error
.
message
+
=
'
Recursive
objects
are
not
allowed
.
'
;
}
throw
error
;
}
const
{
exceptionDetails
result
:
remoteObject
}
=
await
callFunctionOnPromise
.
catch
(
rewriteError
)
;
if
(
exceptionDetails
)
{
throw
new
Error
(
'
Evaluation
failed
:
'
+
(
0
util_js_1
.
getExceptionMessage
)
(
exceptionDetails
)
)
;
}
return
returnByValue
?
(
0
util_js_1
.
valueFromRemoteObject
)
(
remoteObject
)
:
(
0
util_js_1
.
createJSHandle
)
(
this
remoteObject
)
;
async
function
convertArgument
(
arg
)
{
if
(
arg
instanceof
LazyArg_js_1
.
LazyArg
)
{
arg
=
await
arg
.
get
(
)
;
}
if
(
typeof
arg
=
=
=
'
bigint
'
)
{
return
{
unserializableValue
:
{
arg
.
toString
(
)
}
n
}
;
}
if
(
Object
.
is
(
arg
-
0
)
)
{
return
{
unserializableValue
:
'
-
0
'
}
;
}
if
(
Object
.
is
(
arg
Infinity
)
)
{
return
{
unserializableValue
:
'
Infinity
'
}
;
}
if
(
Object
.
is
(
arg
-
Infinity
)
)
{
return
{
unserializableValue
:
'
-
Infinity
'
}
;
}
if
(
Object
.
is
(
arg
NaN
)
)
{
return
{
unserializableValue
:
'
NaN
'
}
;
}
const
objectHandle
=
arg
&
&
arg
instanceof
JSHandle_js_1
.
JSHandle
?
arg
:
null
;
if
(
objectHandle
)
{
if
(
objectHandle
.
executionContext
(
)
!
=
=
this
)
{
throw
new
Error
(
'
JSHandles
can
be
evaluated
only
in
the
context
they
were
created
!
'
)
;
}
if
(
objectHandle
.
disposed
)
{
throw
new
Error
(
'
JSHandle
is
disposed
!
'
)
;
}
if
(
objectHandle
.
remoteObject
(
)
.
unserializableValue
)
{
return
{
unserializableValue
:
objectHandle
.
remoteObject
(
)
.
unserializableValue
}
;
}
if
(
!
objectHandle
.
remoteObject
(
)
.
objectId
)
{
return
{
value
:
objectHandle
.
remoteObject
(
)
.
value
}
;
}
return
{
objectId
:
objectHandle
.
remoteObject
(
)
.
objectId
}
;
}
return
{
value
:
arg
}
;
}
}
;
const
rewriteError
=
(
error
)
=
>
{
if
(
error
.
message
.
includes
(
'
Object
reference
chain
is
too
long
'
)
)
{
return
{
result
:
{
type
:
'
undefined
'
}
}
;
}
if
(
error
.
message
.
includes
(
"
Object
couldn
'
t
be
returned
by
value
"
)
)
{
return
{
result
:
{
type
:
'
undefined
'
}
}
;
}
if
(
error
.
message
.
endsWith
(
'
Cannot
find
context
with
specified
id
'
)
|
|
error
.
message
.
endsWith
(
'
Inspected
target
navigated
or
closed
'
)
)
{
throw
new
Error
(
'
Execution
context
was
destroyed
most
likely
because
of
a
navigation
.
'
)
;
}
throw
error
;
}
;
