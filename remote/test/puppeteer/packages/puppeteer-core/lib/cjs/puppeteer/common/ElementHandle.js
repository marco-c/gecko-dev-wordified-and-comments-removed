"
use
strict
"
;
var
__createBinding
=
(
this
&
&
this
.
__createBinding
)
|
|
(
Object
.
create
?
(
function
(
o
m
k
k2
)
{
if
(
k2
=
=
=
undefined
)
k2
=
k
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
m
k
)
;
if
(
!
desc
|
|
(
"
get
"
in
desc
?
!
m
.
__esModule
:
desc
.
writable
|
|
desc
.
configurable
)
)
{
desc
=
{
enumerable
:
true
get
:
function
(
)
{
return
m
[
k
]
;
}
}
;
}
Object
.
defineProperty
(
o
k2
desc
)
;
}
)
:
(
function
(
o
m
k
k2
)
{
if
(
k2
=
=
=
undefined
)
k2
=
k
;
o
[
k2
]
=
m
[
k
]
;
}
)
)
;
var
__setModuleDefault
=
(
this
&
&
this
.
__setModuleDefault
)
|
|
(
Object
.
create
?
(
function
(
o
v
)
{
Object
.
defineProperty
(
o
"
default
"
{
enumerable
:
true
value
:
v
}
)
;
}
)
:
function
(
o
v
)
{
o
[
"
default
"
]
=
v
;
}
)
;
var
__importStar
=
(
this
&
&
this
.
__importStar
)
|
|
function
(
mod
)
{
if
(
mod
&
&
mod
.
__esModule
)
return
mod
;
var
result
=
{
}
;
if
(
mod
!
=
null
)
for
(
var
k
in
mod
)
if
(
k
!
=
=
"
default
"
&
&
Object
.
prototype
.
hasOwnProperty
.
call
(
mod
k
)
)
__createBinding
(
result
mod
k
)
;
__setModuleDefault
(
result
mod
)
;
return
result
;
}
;
var
__classPrivateFieldSet
=
(
this
&
&
this
.
__classPrivateFieldSet
)
|
|
function
(
receiver
state
value
kind
f
)
{
if
(
kind
=
=
=
"
m
"
)
throw
new
TypeError
(
"
Private
method
is
not
writable
"
)
;
if
(
kind
=
=
=
"
a
"
&
&
!
f
)
throw
new
TypeError
(
"
Private
accessor
was
defined
without
a
setter
"
)
;
if
(
typeof
state
=
=
=
"
function
"
?
receiver
!
=
=
state
|
|
!
f
:
!
state
.
has
(
receiver
)
)
throw
new
TypeError
(
"
Cannot
write
private
member
to
an
object
whose
class
did
not
declare
it
"
)
;
return
(
kind
=
=
=
"
a
"
?
f
.
call
(
receiver
value
)
:
f
?
f
.
value
=
value
:
state
.
set
(
receiver
value
)
)
value
;
}
;
var
__classPrivateFieldGet
=
(
this
&
&
this
.
__classPrivateFieldGet
)
|
|
function
(
receiver
state
kind
f
)
{
if
(
kind
=
=
=
"
a
"
&
&
!
f
)
throw
new
TypeError
(
"
Private
accessor
was
defined
without
a
getter
"
)
;
if
(
typeof
state
=
=
=
"
function
"
?
receiver
!
=
=
state
|
|
!
f
:
!
state
.
has
(
receiver
)
)
throw
new
TypeError
(
"
Cannot
read
private
member
from
an
object
whose
class
did
not
declare
it
"
)
;
return
kind
=
=
=
"
m
"
?
f
:
kind
=
=
=
"
a
"
?
f
.
call
(
receiver
)
:
f
?
f
.
value
:
state
.
get
(
receiver
)
;
}
;
var
_ElementHandle_instances
_ElementHandle_frame
_ElementHandle_frameManager_get
_ElementHandle_page_get
_ElementHandle_scrollIntoViewIfNeeded
_ElementHandle_getOOPIFOffsets
_ElementHandle_getBoxModel
_ElementHandle_fromProtocolQuad
_ElementHandle_intersectQuadWithViewport
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
ElementHandle
=
void
0
;
const
assert_js_1
=
require
(
"
.
.
/
util
/
assert
.
js
"
)
;
const
JSHandle_js_1
=
require
(
"
.
/
JSHandle
.
js
"
)
;
const
QueryHandler_js_1
=
require
(
"
.
/
QueryHandler
.
js
"
)
;
const
util_js_1
=
require
(
"
.
/
util
.
js
"
)
;
const
applyOffsetsToQuad
=
(
quad
offsetX
offsetY
)
=
>
{
return
quad
.
map
(
part
=
>
{
return
{
x
:
part
.
x
+
offsetX
y
:
part
.
y
+
offsetY
}
;
}
)
;
}
;
class
ElementHandle
extends
JSHandle_js_1
.
JSHandle
{
constructor
(
context
remoteObject
frame
)
{
super
(
context
remoteObject
)
;
_ElementHandle_instances
.
add
(
this
)
;
_ElementHandle_frame
.
set
(
this
void
0
)
;
__classPrivateFieldSet
(
this
_ElementHandle_frame
frame
"
f
"
)
;
}
get
frame
(
)
{
return
__classPrivateFieldGet
(
this
_ElementHandle_frame
"
f
"
)
;
}
async
(
selector
)
{
const
{
updatedSelector
queryHandler
}
=
(
0
QueryHandler_js_1
.
getQueryHandlerAndSelector
)
(
selector
)
;
(
0
assert_js_1
.
assert
)
(
queryHandler
.
queryOne
'
Cannot
handle
queries
for
a
single
element
with
the
given
selector
'
)
;
return
(
await
queryHandler
.
queryOne
(
this
updatedSelector
)
)
;
}
async
(
selector
)
{
const
{
updatedSelector
queryHandler
}
=
(
0
QueryHandler_js_1
.
getQueryHandlerAndSelector
)
(
selector
)
;
(
0
assert_js_1
.
assert
)
(
queryHandler
.
queryAll
'
Cannot
handle
queries
for
a
multiple
element
with
the
given
selector
'
)
;
return
(
await
queryHandler
.
queryAll
(
this
updatedSelector
)
)
;
}
async
eval
(
selector
pageFunction
.
.
.
args
)
{
const
elementHandle
=
await
this
.
(
selector
)
;
if
(
!
elementHandle
)
{
throw
new
Error
(
Error
:
failed
to
find
element
matching
selector
"
{
selector
}
"
)
;
}
const
result
=
await
elementHandle
.
evaluate
(
pageFunction
.
.
.
args
)
;
await
elementHandle
.
dispose
(
)
;
return
result
;
}
async
eval
(
selector
pageFunction
.
.
.
args
)
{
const
{
updatedSelector
queryHandler
}
=
(
0
QueryHandler_js_1
.
getQueryHandlerAndSelector
)
(
selector
)
;
(
0
assert_js_1
.
assert
)
(
queryHandler
.
queryAll
'
Cannot
handle
queries
for
a
multiple
element
with
the
given
selector
'
)
;
const
handles
=
(
await
queryHandler
.
queryAll
(
this
updatedSelector
)
)
;
const
elements
=
(
await
this
.
evaluateHandle
(
(
_
.
.
.
elements
)
=
>
{
return
elements
;
}
.
.
.
handles
)
)
;
const
[
result
]
=
await
Promise
.
all
(
[
elements
.
evaluate
(
pageFunction
.
.
.
args
)
.
.
.
handles
.
map
(
handle
=
>
{
return
handle
.
dispose
(
)
;
}
)
]
)
;
await
elements
.
dispose
(
)
;
return
result
;
}
async
x
(
expression
)
{
if
(
expression
.
startsWith
(
'
/
/
'
)
)
{
expression
=
.
{
expression
}
;
}
return
this
.
(
xpath
/
{
expression
}
)
;
}
async
waitForSelector
(
selector
options
=
{
}
)
{
const
{
updatedSelector
queryHandler
}
=
(
0
QueryHandler_js_1
.
getQueryHandlerAndSelector
)
(
selector
)
;
(
0
assert_js_1
.
assert
)
(
queryHandler
.
waitFor
'
Query
handler
does
not
support
waiting
'
)
;
return
(
await
queryHandler
.
waitFor
(
this
updatedSelector
options
)
)
;
}
async
waitForXPath
(
xpath
options
=
{
}
)
{
if
(
xpath
.
startsWith
(
'
/
/
'
)
)
{
xpath
=
.
{
xpath
}
;
}
return
this
.
waitForSelector
(
xpath
/
{
xpath
}
options
)
;
}
async
toElement
(
tagName
)
{
const
isMatchingTagName
=
await
this
.
evaluate
(
(
node
tagName
)
=
>
{
return
node
.
nodeName
=
=
=
tagName
.
toUpperCase
(
)
;
}
tagName
)
;
if
(
!
isMatchingTagName
)
{
throw
new
Error
(
Element
is
not
a
(
n
)
\
{
tagName
}
\
element
)
;
}
return
this
;
}
asElement
(
)
{
return
this
;
}
async
contentFrame
(
)
{
const
nodeInfo
=
await
this
.
client
.
send
(
'
DOM
.
describeNode
'
{
objectId
:
this
.
remoteObject
(
)
.
objectId
}
)
;
if
(
typeof
nodeInfo
.
node
.
frameId
!
=
=
'
string
'
)
{
return
null
;
}
return
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_frameManager_get
)
.
frame
(
nodeInfo
.
node
.
frameId
)
;
}
async
clickablePoint
(
offset
)
{
const
[
result
layoutMetrics
]
=
await
Promise
.
all
(
[
this
.
client
.
send
(
'
DOM
.
getContentQuads
'
{
objectId
:
this
.
remoteObject
(
)
.
objectId
}
)
.
catch
(
util_js_1
.
debugError
)
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
_client
(
)
.
send
(
'
Page
.
getLayoutMetrics
'
)
]
)
;
if
(
!
result
|
|
!
result
.
quads
.
length
)
{
throw
new
Error
(
'
Node
is
either
not
clickable
or
not
an
HTMLElement
'
)
;
}
const
{
clientWidth
clientHeight
}
=
layoutMetrics
.
cssLayoutViewport
|
|
layoutMetrics
.
layoutViewport
;
const
{
offsetX
offsetY
}
=
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_getOOPIFOffsets
)
.
call
(
this
__classPrivateFieldGet
(
this
_ElementHandle_frame
"
f
"
)
)
;
const
quads
=
result
.
quads
.
map
(
quad
=
>
{
return
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_fromProtocolQuad
)
.
call
(
this
quad
)
;
}
)
.
map
(
quad
=
>
{
return
applyOffsetsToQuad
(
quad
offsetX
offsetY
)
;
}
)
.
map
(
quad
=
>
{
return
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_intersectQuadWithViewport
)
.
call
(
this
quad
clientWidth
clientHeight
)
;
}
)
.
filter
(
quad
=
>
{
return
computeQuadArea
(
quad
)
>
1
;
}
)
;
if
(
!
quads
.
length
)
{
throw
new
Error
(
'
Node
is
either
not
clickable
or
not
an
HTMLElement
'
)
;
}
const
quad
=
quads
[
0
]
;
if
(
offset
)
{
let
minX
=
Number
.
MAX_SAFE_INTEGER
;
let
minY
=
Number
.
MAX_SAFE_INTEGER
;
for
(
const
point
of
quad
)
{
if
(
point
.
x
<
minX
)
{
minX
=
point
.
x
;
}
if
(
point
.
y
<
minY
)
{
minY
=
point
.
y
;
}
}
if
(
minX
!
=
=
Number
.
MAX_SAFE_INTEGER
&
&
minY
!
=
=
Number
.
MAX_SAFE_INTEGER
)
{
return
{
x
:
minX
+
offset
.
x
y
:
minY
+
offset
.
y
}
;
}
}
let
x
=
0
;
let
y
=
0
;
for
(
const
point
of
quad
)
{
x
+
=
point
.
x
;
y
+
=
point
.
y
;
}
return
{
x
:
x
/
4
y
:
y
/
4
}
;
}
async
hover
(
)
{
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_scrollIntoViewIfNeeded
)
.
call
(
this
)
;
const
{
x
y
}
=
await
this
.
clickablePoint
(
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
mouse
.
move
(
x
y
)
;
}
async
click
(
options
=
{
}
)
{
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_scrollIntoViewIfNeeded
)
.
call
(
this
)
;
const
{
x
y
}
=
await
this
.
clickablePoint
(
options
.
offset
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
mouse
.
click
(
x
y
options
)
;
}
async
drag
(
target
)
{
(
0
assert_js_1
.
assert
)
(
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
isDragInterceptionEnabled
(
)
'
Drag
Interception
is
not
enabled
!
'
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_scrollIntoViewIfNeeded
)
.
call
(
this
)
;
const
start
=
await
this
.
clickablePoint
(
)
;
return
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
mouse
.
drag
(
start
target
)
;
}
async
dragEnter
(
data
=
{
items
:
[
]
dragOperationsMask
:
1
}
)
{
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_scrollIntoViewIfNeeded
)
.
call
(
this
)
;
const
target
=
await
this
.
clickablePoint
(
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
mouse
.
dragEnter
(
target
data
)
;
}
async
dragOver
(
data
=
{
items
:
[
]
dragOperationsMask
:
1
}
)
{
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_scrollIntoViewIfNeeded
)
.
call
(
this
)
;
const
target
=
await
this
.
clickablePoint
(
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
mouse
.
dragOver
(
target
data
)
;
}
async
drop
(
data
=
{
items
:
[
]
dragOperationsMask
:
1
}
)
{
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_scrollIntoViewIfNeeded
)
.
call
(
this
)
;
const
destination
=
await
this
.
clickablePoint
(
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
mouse
.
drop
(
destination
data
)
;
}
async
dragAndDrop
(
target
options
)
{
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_scrollIntoViewIfNeeded
)
.
call
(
this
)
;
const
startPoint
=
await
this
.
clickablePoint
(
)
;
const
targetPoint
=
await
target
.
clickablePoint
(
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
mouse
.
dragAndDrop
(
startPoint
targetPoint
options
)
;
}
async
select
(
.
.
.
values
)
{
for
(
const
value
of
values
)
{
(
0
assert_js_1
.
assert
)
(
(
0
util_js_1
.
isString
)
(
value
)
'
Values
must
be
strings
.
Found
value
"
'
+
value
+
'
"
of
type
"
'
+
typeof
value
+
'
"
'
)
;
}
return
this
.
evaluate
(
(
element
vals
)
=
>
{
const
values
=
new
Set
(
vals
)
;
if
(
!
(
element
instanceof
HTMLSelectElement
)
)
{
throw
new
Error
(
'
Element
is
not
a
<
select
>
element
.
'
)
;
}
const
selectedValues
=
new
Set
(
)
;
if
(
!
element
.
multiple
)
{
for
(
const
option
of
element
.
options
)
{
option
.
selected
=
false
;
}
for
(
const
option
of
element
.
options
)
{
if
(
values
.
has
(
option
.
value
)
)
{
option
.
selected
=
true
;
selectedValues
.
add
(
option
.
value
)
;
break
;
}
}
}
else
{
for
(
const
option
of
element
.
options
)
{
option
.
selected
=
values
.
has
(
option
.
value
)
;
if
(
option
.
selected
)
{
selectedValues
.
add
(
option
.
value
)
;
}
}
}
element
.
dispatchEvent
(
new
Event
(
'
input
'
{
bubbles
:
true
}
)
)
;
element
.
dispatchEvent
(
new
Event
(
'
change
'
{
bubbles
:
true
}
)
)
;
return
[
.
.
.
selectedValues
.
values
(
)
]
;
}
values
)
;
}
async
uploadFile
(
.
.
.
filePaths
)
{
const
isMultiple
=
await
this
.
evaluate
(
element
=
>
{
return
element
.
multiple
;
}
)
;
(
0
assert_js_1
.
assert
)
(
filePaths
.
length
<
=
1
|
|
isMultiple
'
Multiple
file
uploads
only
work
with
<
input
type
=
file
multiple
>
'
)
;
let
path
;
try
{
path
=
await
Promise
.
resolve
(
)
.
then
(
(
)
=
>
__importStar
(
require
(
'
path
'
)
)
)
;
}
catch
(
error
)
{
if
(
error
instanceof
TypeError
)
{
throw
new
Error
(
JSHandle
#
uploadFile
can
only
be
used
in
Node
-
like
environments
.
)
;
}
throw
error
;
}
const
files
=
filePaths
.
map
(
filePath
=
>
{
if
(
path
.
win32
.
isAbsolute
(
filePath
)
|
|
path
.
posix
.
isAbsolute
(
filePath
)
)
{
return
filePath
;
}
else
{
return
path
.
resolve
(
filePath
)
;
}
}
)
;
const
{
objectId
}
=
this
.
remoteObject
(
)
;
const
{
node
}
=
await
this
.
client
.
send
(
'
DOM
.
describeNode
'
{
objectId
}
)
;
const
{
backendNodeId
}
=
node
;
if
(
files
.
length
=
=
=
0
)
{
await
this
.
evaluate
(
element
=
>
{
element
.
files
=
new
DataTransfer
(
)
.
files
;
element
.
dispatchEvent
(
new
Event
(
'
input
'
{
bubbles
:
true
}
)
)
;
element
.
dispatchEvent
(
new
Event
(
'
change
'
{
bubbles
:
true
}
)
)
;
}
)
;
}
else
{
await
this
.
client
.
send
(
'
DOM
.
setFileInputFiles
'
{
objectId
files
backendNodeId
}
)
;
}
}
async
tap
(
)
{
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_scrollIntoViewIfNeeded
)
.
call
(
this
)
;
const
{
x
y
}
=
await
this
.
clickablePoint
(
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
touchscreen
.
tap
(
x
y
)
;
}
async
focus
(
)
{
await
this
.
evaluate
(
element
=
>
{
if
(
!
(
element
instanceof
HTMLElement
)
)
{
throw
new
Error
(
'
Cannot
focus
non
-
HTMLElement
'
)
;
}
return
element
.
focus
(
)
;
}
)
;
}
async
type
(
text
options
)
{
await
this
.
focus
(
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
keyboard
.
type
(
text
options
)
;
}
async
press
(
key
options
)
{
await
this
.
focus
(
)
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
keyboard
.
press
(
key
options
)
;
}
async
boundingBox
(
)
{
const
result
=
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_getBoxModel
)
.
call
(
this
)
;
if
(
!
result
)
{
return
null
;
}
const
{
offsetX
offsetY
}
=
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_getOOPIFOffsets
)
.
call
(
this
__classPrivateFieldGet
(
this
_ElementHandle_frame
"
f
"
)
)
;
const
quad
=
result
.
model
.
border
;
const
x
=
Math
.
min
(
quad
[
0
]
quad
[
2
]
quad
[
4
]
quad
[
6
]
)
;
const
y
=
Math
.
min
(
quad
[
1
]
quad
[
3
]
quad
[
5
]
quad
[
7
]
)
;
const
width
=
Math
.
max
(
quad
[
0
]
quad
[
2
]
quad
[
4
]
quad
[
6
]
)
-
x
;
const
height
=
Math
.
max
(
quad
[
1
]
quad
[
3
]
quad
[
5
]
quad
[
7
]
)
-
y
;
return
{
x
:
x
+
offsetX
y
:
y
+
offsetY
width
height
}
;
}
async
boxModel
(
)
{
const
result
=
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_getBoxModel
)
.
call
(
this
)
;
if
(
!
result
)
{
return
null
;
}
const
{
offsetX
offsetY
}
=
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_getOOPIFOffsets
)
.
call
(
this
__classPrivateFieldGet
(
this
_ElementHandle_frame
"
f
"
)
)
;
const
{
content
padding
border
margin
width
height
}
=
result
.
model
;
return
{
content
:
applyOffsetsToQuad
(
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_fromProtocolQuad
)
.
call
(
this
content
)
offsetX
offsetY
)
padding
:
applyOffsetsToQuad
(
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_fromProtocolQuad
)
.
call
(
this
padding
)
offsetX
offsetY
)
border
:
applyOffsetsToQuad
(
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_fromProtocolQuad
)
.
call
(
this
border
)
offsetX
offsetY
)
margin
:
applyOffsetsToQuad
(
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_fromProtocolQuad
)
.
call
(
this
margin
)
offsetX
offsetY
)
width
height
}
;
}
async
screenshot
(
options
=
{
}
)
{
let
needsViewportReset
=
false
;
let
boundingBox
=
await
this
.
boundingBox
(
)
;
(
0
assert_js_1
.
assert
)
(
boundingBox
'
Node
is
either
not
visible
or
not
an
HTMLElement
'
)
;
const
viewport
=
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
viewport
(
)
;
if
(
viewport
&
&
(
boundingBox
.
width
>
viewport
.
width
|
|
boundingBox
.
height
>
viewport
.
height
)
)
{
const
newViewport
=
{
width
:
Math
.
max
(
viewport
.
width
Math
.
ceil
(
boundingBox
.
width
)
)
height
:
Math
.
max
(
viewport
.
height
Math
.
ceil
(
boundingBox
.
height
)
)
}
;
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
setViewport
(
Object
.
assign
(
{
}
viewport
newViewport
)
)
;
needsViewportReset
=
true
;
}
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_scrollIntoViewIfNeeded
)
.
call
(
this
)
;
boundingBox
=
await
this
.
boundingBox
(
)
;
(
0
assert_js_1
.
assert
)
(
boundingBox
'
Node
is
either
not
visible
or
not
an
HTMLElement
'
)
;
(
0
assert_js_1
.
assert
)
(
boundingBox
.
width
!
=
=
0
'
Node
has
0
width
.
'
)
;
(
0
assert_js_1
.
assert
)
(
boundingBox
.
height
!
=
=
0
'
Node
has
0
height
.
'
)
;
const
layoutMetrics
=
await
this
.
client
.
send
(
'
Page
.
getLayoutMetrics
'
)
;
const
{
pageX
pageY
}
=
layoutMetrics
.
cssVisualViewport
|
|
layoutMetrics
.
layoutViewport
;
const
clip
=
Object
.
assign
(
{
}
boundingBox
)
;
clip
.
x
+
=
pageX
;
clip
.
y
+
=
pageY
;
const
imageData
=
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
screenshot
(
Object
.
assign
(
{
}
{
clip
}
options
)
)
;
if
(
needsViewportReset
&
&
viewport
)
{
await
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
setViewport
(
viewport
)
;
}
return
imageData
;
}
async
isIntersectingViewport
(
options
)
{
const
{
threshold
=
0
}
=
options
!
=
=
null
&
&
options
!
=
=
void
0
?
options
:
{
}
;
return
await
this
.
evaluate
(
async
(
element
threshold
)
=
>
{
const
visibleRatio
=
await
new
Promise
(
resolve
=
>
{
const
observer
=
new
IntersectionObserver
(
entries
=
>
{
resolve
(
entries
[
0
]
.
intersectionRatio
)
;
observer
.
disconnect
(
)
;
}
)
;
observer
.
observe
(
element
)
;
}
)
;
return
threshold
=
=
=
1
?
visibleRatio
=
=
=
1
:
visibleRatio
>
threshold
;
}
threshold
)
;
}
}
exports
.
ElementHandle
=
ElementHandle
;
_ElementHandle_frame
=
new
WeakMap
(
)
_ElementHandle_instances
=
new
WeakSet
(
)
_ElementHandle_frameManager_get
=
function
_ElementHandle_frameManager_get
(
)
{
return
__classPrivateFieldGet
(
this
_ElementHandle_frame
"
f
"
)
.
_frameManager
;
}
_ElementHandle_page_get
=
function
_ElementHandle_page_get
(
)
{
return
__classPrivateFieldGet
(
this
_ElementHandle_frame
"
f
"
)
.
page
(
)
;
}
_ElementHandle_scrollIntoViewIfNeeded
=
async
function
_ElementHandle_scrollIntoViewIfNeeded
(
)
{
const
error
=
await
this
.
evaluate
(
async
(
element
)
=
>
{
if
(
!
element
.
isConnected
)
{
return
'
Node
is
detached
from
document
'
;
}
if
(
element
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
'
Node
is
not
of
type
HTMLElement
'
;
}
return
;
}
)
;
if
(
error
)
{
throw
new
Error
(
error
)
;
}
try
{
await
this
.
client
.
send
(
'
DOM
.
scrollIntoViewIfNeeded
'
{
objectId
:
this
.
remoteObject
(
)
.
objectId
}
)
;
}
catch
(
_err
)
{
await
this
.
evaluate
(
async
(
element
pageJavascriptEnabled
)
=
>
{
const
visibleRatio
=
async
(
)
=
>
{
return
await
new
Promise
(
resolve
=
>
{
const
observer
=
new
IntersectionObserver
(
entries
=
>
{
resolve
(
entries
[
0
]
.
intersectionRatio
)
;
observer
.
disconnect
(
)
;
}
)
;
observer
.
observe
(
element
)
;
}
)
;
}
;
if
(
!
pageJavascriptEnabled
|
|
(
await
visibleRatio
(
)
)
!
=
=
1
.
0
)
{
element
.
scrollIntoView
(
{
block
:
'
center
'
inline
:
'
center
'
behavior
:
'
instant
'
}
)
;
}
}
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
a
"
_ElementHandle_page_get
)
.
isJavaScriptEnabled
(
)
)
;
}
}
_ElementHandle_getOOPIFOffsets
=
async
function
_ElementHandle_getOOPIFOffsets
(
frame
)
{
let
offsetX
=
0
;
let
offsetY
=
0
;
let
currentFrame
=
frame
;
while
(
currentFrame
&
&
currentFrame
.
parentFrame
(
)
)
{
const
parent
=
currentFrame
.
parentFrame
(
)
;
if
(
!
currentFrame
.
isOOPFrame
(
)
|
|
!
parent
)
{
currentFrame
=
parent
;
continue
;
}
const
{
backendNodeId
}
=
await
parent
.
_client
(
)
.
send
(
'
DOM
.
getFrameOwner
'
{
frameId
:
currentFrame
.
_id
}
)
;
const
result
=
await
parent
.
_client
(
)
.
send
(
'
DOM
.
getBoxModel
'
{
backendNodeId
:
backendNodeId
}
)
;
if
(
!
result
)
{
break
;
}
const
contentBoxQuad
=
result
.
model
.
content
;
const
topLeftCorner
=
__classPrivateFieldGet
(
this
_ElementHandle_instances
"
m
"
_ElementHandle_fromProtocolQuad
)
.
call
(
this
contentBoxQuad
)
[
0
]
;
offsetX
+
=
topLeftCorner
.
x
;
offsetY
+
=
topLeftCorner
.
y
;
currentFrame
=
parent
;
}
return
{
offsetX
offsetY
}
;
}
_ElementHandle_getBoxModel
=
function
_ElementHandle_getBoxModel
(
)
{
const
params
=
{
objectId
:
this
.
remoteObject
(
)
.
objectId
}
;
return
this
.
client
.
send
(
'
DOM
.
getBoxModel
'
params
)
.
catch
(
error
=
>
{
return
(
0
util_js_1
.
debugError
)
(
error
)
;
}
)
;
}
_ElementHandle_fromProtocolQuad
=
function
_ElementHandle_fromProtocolQuad
(
quad
)
{
return
[
{
x
:
quad
[
0
]
y
:
quad
[
1
]
}
{
x
:
quad
[
2
]
y
:
quad
[
3
]
}
{
x
:
quad
[
4
]
y
:
quad
[
5
]
}
{
x
:
quad
[
6
]
y
:
quad
[
7
]
}
]
;
}
_ElementHandle_intersectQuadWithViewport
=
function
_ElementHandle_intersectQuadWithViewport
(
quad
width
height
)
{
return
quad
.
map
(
point
=
>
{
return
{
x
:
Math
.
min
(
Math
.
max
(
point
.
x
0
)
width
)
y
:
Math
.
min
(
Math
.
max
(
point
.
y
0
)
height
)
}
;
}
)
;
}
;
function
computeQuadArea
(
quad
)
{
let
area
=
0
;
for
(
let
i
=
0
;
i
<
quad
.
length
;
+
+
i
)
{
const
p1
=
quad
[
i
]
;
const
p2
=
quad
[
(
i
+
1
)
%
quad
.
length
]
;
area
+
=
(
p1
.
x
*
p2
.
y
-
p2
.
x
*
p1
.
y
)
/
2
;
}
return
Math
.
abs
(
area
)
;
}
