"
use
strict
"
;
var
__createBinding
=
(
this
&
&
this
.
__createBinding
)
|
|
(
Object
.
create
?
(
function
(
o
m
k
k2
)
{
if
(
k2
=
=
=
undefined
)
k2
=
k
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
m
k
)
;
if
(
!
desc
|
|
(
"
get
"
in
desc
?
!
m
.
__esModule
:
desc
.
writable
|
|
desc
.
configurable
)
)
{
desc
=
{
enumerable
:
true
get
:
function
(
)
{
return
m
[
k
]
;
}
}
;
}
Object
.
defineProperty
(
o
k2
desc
)
;
}
)
:
(
function
(
o
m
k
k2
)
{
if
(
k2
=
=
=
undefined
)
k2
=
k
;
o
[
k2
]
=
m
[
k
]
;
}
)
)
;
var
__setModuleDefault
=
(
this
&
&
this
.
__setModuleDefault
)
|
|
(
Object
.
create
?
(
function
(
o
v
)
{
Object
.
defineProperty
(
o
"
default
"
{
enumerable
:
true
value
:
v
}
)
;
}
)
:
function
(
o
v
)
{
o
[
"
default
"
]
=
v
;
}
)
;
var
__importStar
=
(
this
&
&
this
.
__importStar
)
|
|
function
(
mod
)
{
if
(
mod
&
&
mod
.
__esModule
)
return
mod
;
var
result
=
{
}
;
if
(
mod
!
=
null
)
for
(
var
k
in
mod
)
if
(
k
!
=
=
"
default
"
&
&
Object
.
prototype
.
hasOwnProperty
.
call
(
mod
k
)
)
__createBinding
(
result
mod
k
)
;
__setModuleDefault
(
result
mod
)
;
return
result
;
}
;
var
__classPrivateFieldSet
=
(
this
&
&
this
.
__classPrivateFieldSet
)
|
|
function
(
receiver
state
value
kind
f
)
{
if
(
kind
=
=
=
"
m
"
)
throw
new
TypeError
(
"
Private
method
is
not
writable
"
)
;
if
(
kind
=
=
=
"
a
"
&
&
!
f
)
throw
new
TypeError
(
"
Private
accessor
was
defined
without
a
setter
"
)
;
if
(
typeof
state
=
=
=
"
function
"
?
receiver
!
=
=
state
|
|
!
f
:
!
state
.
has
(
receiver
)
)
throw
new
TypeError
(
"
Cannot
write
private
member
to
an
object
whose
class
did
not
declare
it
"
)
;
return
(
kind
=
=
=
"
a
"
?
f
.
call
(
receiver
value
)
:
f
?
f
.
value
=
value
:
state
.
set
(
receiver
value
)
)
value
;
}
;
var
__classPrivateFieldGet
=
(
this
&
&
this
.
__classPrivateFieldGet
)
|
|
function
(
receiver
state
kind
f
)
{
if
(
kind
=
=
=
"
a
"
&
&
!
f
)
throw
new
TypeError
(
"
Private
accessor
was
defined
without
a
getter
"
)
;
if
(
typeof
state
=
=
=
"
function
"
?
receiver
!
=
=
state
|
|
!
f
:
!
state
.
has
(
receiver
)
)
throw
new
TypeError
(
"
Cannot
read
private
member
from
an
object
whose
class
did
not
declare
it
"
)
;
return
kind
=
=
=
"
m
"
?
f
:
kind
=
=
=
"
a
"
?
f
.
call
(
receiver
)
:
f
?
f
.
value
:
state
.
get
(
receiver
)
;
}
;
var
_Frame_url
_Frame_detached
_Frame_client
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
Frame
=
void
0
;
const
assert_js_1
=
require
(
"
.
.
/
util
/
assert
.
js
"
)
;
const
ErrorLike_js_1
=
require
(
"
.
.
/
util
/
ErrorLike
.
js
"
)
;
const
IsolatedWorld_js_1
=
require
(
"
.
/
IsolatedWorld
.
js
"
)
;
const
IsolatedWorlds_js_1
=
require
(
"
.
/
IsolatedWorlds
.
js
"
)
;
const
LifecycleWatcher_js_1
=
require
(
"
.
/
LifecycleWatcher
.
js
"
)
;
const
QueryHandler_js_1
=
require
(
"
.
/
QueryHandler
.
js
"
)
;
const
util_js_1
=
require
(
"
.
/
util
.
js
"
)
;
class
Frame
{
constructor
(
frameManager
frameId
parentFrameId
client
)
{
_Frame_url
.
set
(
this
'
'
)
;
_Frame_detached
.
set
(
this
false
)
;
_Frame_client
.
set
(
this
void
0
)
;
this
.
_loaderId
=
'
'
;
this
.
_hasStartedLoading
=
false
;
this
.
_lifecycleEvents
=
new
Set
(
)
;
this
.
_frameManager
=
frameManager
;
__classPrivateFieldSet
(
this
_Frame_url
'
'
"
f
"
)
;
this
.
_id
=
frameId
;
this
.
_parentId
=
parentFrameId
;
__classPrivateFieldSet
(
this
_Frame_detached
false
"
f
"
)
;
this
.
_loaderId
=
'
'
;
this
.
updateClient
(
client
)
;
}
updateClient
(
client
)
{
__classPrivateFieldSet
(
this
_Frame_client
client
"
f
"
)
;
this
.
worlds
=
{
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
:
new
IsolatedWorld_js_1
.
IsolatedWorld
(
this
)
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
:
new
IsolatedWorld_js_1
.
IsolatedWorld
(
this
)
}
;
}
page
(
)
{
return
this
.
_frameManager
.
page
(
)
;
}
isOOPFrame
(
)
{
return
__classPrivateFieldGet
(
this
_Frame_client
"
f
"
)
!
=
=
this
.
_frameManager
.
client
;
}
async
goto
(
url
options
=
{
}
)
{
const
{
referer
=
this
.
_frameManager
.
networkManager
.
extraHTTPHeaders
(
)
[
'
referer
'
]
referrerPolicy
=
this
.
_frameManager
.
networkManager
.
extraHTTPHeaders
(
)
[
'
referer
-
policy
'
]
waitUntil
=
[
'
load
'
]
timeout
=
this
.
_frameManager
.
timeoutSettings
.
navigationTimeout
(
)
}
=
options
;
let
ensureNewDocumentNavigation
=
false
;
const
watcher
=
new
LifecycleWatcher_js_1
.
LifecycleWatcher
(
this
.
_frameManager
this
waitUntil
timeout
)
;
let
error
=
await
Promise
.
race
(
[
navigate
(
__classPrivateFieldGet
(
this
_Frame_client
"
f
"
)
url
referer
referrerPolicy
this
.
_id
)
watcher
.
timeoutOrTerminationPromise
(
)
]
)
;
if
(
!
error
)
{
error
=
await
Promise
.
race
(
[
watcher
.
timeoutOrTerminationPromise
(
)
ensureNewDocumentNavigation
?
watcher
.
newDocumentNavigationPromise
(
)
:
watcher
.
sameDocumentNavigationPromise
(
)
]
)
;
}
try
{
if
(
error
)
{
throw
error
;
}
return
await
watcher
.
navigationResponse
(
)
;
}
finally
{
watcher
.
dispose
(
)
;
}
async
function
navigate
(
client
url
referrer
referrerPolicy
frameId
)
{
try
{
const
response
=
await
client
.
send
(
'
Page
.
navigate
'
{
url
referrer
frameId
referrerPolicy
}
)
;
ensureNewDocumentNavigation
=
!
!
response
.
loaderId
;
return
response
.
errorText
?
new
Error
(
{
response
.
errorText
}
at
{
url
}
)
:
null
;
}
catch
(
error
)
{
if
(
(
0
ErrorLike_js_1
.
isErrorLike
)
(
error
)
)
{
return
error
;
}
throw
error
;
}
}
}
async
waitForNavigation
(
options
=
{
}
)
{
const
{
waitUntil
=
[
'
load
'
]
timeout
=
this
.
_frameManager
.
timeoutSettings
.
navigationTimeout
(
)
}
=
options
;
const
watcher
=
new
LifecycleWatcher_js_1
.
LifecycleWatcher
(
this
.
_frameManager
this
waitUntil
timeout
)
;
const
error
=
await
Promise
.
race
(
[
watcher
.
timeoutOrTerminationPromise
(
)
watcher
.
sameDocumentNavigationPromise
(
)
watcher
.
newDocumentNavigationPromise
(
)
]
)
;
try
{
if
(
error
)
{
throw
error
;
}
return
await
watcher
.
navigationResponse
(
)
;
}
finally
{
watcher
.
dispose
(
)
;
}
}
_client
(
)
{
return
__classPrivateFieldGet
(
this
_Frame_client
"
f
"
)
;
}
executionContext
(
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
executionContext
(
)
;
}
async
evaluateHandle
(
pageFunction
.
.
.
args
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
evaluateHandle
(
pageFunction
.
.
.
args
)
;
}
async
evaluate
(
pageFunction
.
.
.
args
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
evaluate
(
pageFunction
.
.
.
args
)
;
}
async
(
selector
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
(
selector
)
;
}
async
(
selector
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
(
selector
)
;
}
async
eval
(
selector
pageFunction
.
.
.
args
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
eval
(
selector
pageFunction
.
.
.
args
)
;
}
async
eval
(
selector
pageFunction
.
.
.
args
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
eval
(
selector
pageFunction
.
.
.
args
)
;
}
async
x
(
expression
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
x
(
expression
)
;
}
async
waitForSelector
(
selector
options
=
{
}
)
{
const
{
updatedSelector
queryHandler
}
=
(
0
QueryHandler_js_1
.
getQueryHandlerAndSelector
)
(
selector
)
;
(
0
assert_js_1
.
assert
)
(
queryHandler
.
waitFor
'
Query
handler
does
not
support
waiting
'
)
;
return
(
await
queryHandler
.
waitFor
(
this
updatedSelector
options
)
)
;
}
async
waitForXPath
(
xpath
options
=
{
}
)
{
if
(
xpath
.
startsWith
(
'
/
/
'
)
)
{
xpath
=
.
{
xpath
}
;
}
return
this
.
waitForSelector
(
xpath
/
{
xpath
}
options
)
;
}
waitForFunction
(
pageFunction
options
=
{
}
.
.
.
args
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
waitForFunction
(
pageFunction
options
.
.
.
args
)
;
}
async
content
(
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
content
(
)
;
}
async
setContent
(
html
options
=
{
}
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
setContent
(
html
options
)
;
}
name
(
)
{
return
this
.
_name
|
|
'
'
;
}
url
(
)
{
return
__classPrivateFieldGet
(
this
_Frame_url
"
f
"
)
;
}
parentFrame
(
)
{
return
this
.
_frameManager
.
_frameTree
.
parentFrame
(
this
.
_id
)
|
|
null
;
}
childFrames
(
)
{
return
this
.
_frameManager
.
_frameTree
.
childFrames
(
this
.
_id
)
;
}
isDetached
(
)
{
return
__classPrivateFieldGet
(
this
_Frame_detached
"
f
"
)
;
}
async
addScriptTag
(
options
)
{
let
{
content
=
'
'
type
}
=
options
;
const
{
path
}
=
options
;
if
(
+
!
!
options
.
url
+
+
!
!
path
+
+
!
!
content
!
=
=
1
)
{
throw
new
Error
(
'
Exactly
one
of
url
path
or
content
must
be
specified
.
'
)
;
}
if
(
path
)
{
let
fs
;
try
{
fs
=
(
await
Promise
.
resolve
(
)
.
then
(
(
)
=
>
__importStar
(
require
(
'
fs
'
)
)
)
)
.
promises
;
}
catch
(
error
)
{
if
(
error
instanceof
TypeError
)
{
throw
new
Error
(
'
Can
only
pass
a
file
path
in
a
Node
-
like
environment
.
'
)
;
}
throw
error
;
}
content
=
await
fs
.
readFile
(
path
'
utf8
'
)
;
content
+
=
/
/
#
sourceURL
=
{
path
.
replace
(
/
\
n
/
g
'
'
)
}
;
}
type
=
type
!
=
=
null
&
&
type
!
=
=
void
0
?
type
:
'
text
/
javascript
'
;
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
transferHandle
(
await
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
evaluateHandle
(
async
(
{
createDeferredPromise
}
{
url
id
type
content
}
)
=
>
{
const
promise
=
createDeferredPromise
(
)
;
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
type
=
type
;
script
.
text
=
content
;
if
(
url
)
{
script
.
src
=
url
;
script
.
addEventListener
(
'
load
'
(
)
=
>
{
return
promise
.
resolve
(
)
;
}
{
once
:
true
}
)
;
script
.
addEventListener
(
'
error
'
event
=
>
{
var
_a
;
promise
.
reject
(
new
Error
(
(
_a
=
event
.
message
)
!
=
=
null
&
&
_a
!
=
=
void
0
?
_a
:
'
Could
not
load
script
'
)
)
;
}
{
once
:
true
}
)
;
}
else
{
promise
.
resolve
(
)
;
}
if
(
id
)
{
script
.
id
=
id
;
}
document
.
head
.
appendChild
(
script
)
;
await
promise
;
return
script
;
}
await
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
puppeteerUtil
{
.
.
.
options
type
content
}
)
)
;
}
async
addStyleTag
(
options
)
{
let
{
content
=
'
'
}
=
options
;
const
{
path
}
=
options
;
if
(
+
!
!
options
.
url
+
+
!
!
path
+
+
!
!
content
!
=
=
1
)
{
throw
new
Error
(
'
Exactly
one
of
url
path
or
content
must
be
specified
.
'
)
;
}
if
(
path
)
{
let
fs
;
try
{
fs
=
(
await
(
0
util_js_1
.
importFS
)
(
)
)
.
promises
;
}
catch
(
error
)
{
if
(
error
instanceof
TypeError
)
{
throw
new
Error
(
'
Can
only
pass
a
file
path
in
a
Node
-
like
environment
.
'
)
;
}
throw
error
;
}
content
=
await
fs
.
readFile
(
path
'
utf8
'
)
;
content
+
=
'
/
*
#
sourceURL
=
'
+
path
.
replace
(
/
\
n
/
g
'
'
)
+
'
*
/
'
;
options
.
content
=
content
;
}
return
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
transferHandle
(
await
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
evaluateHandle
(
async
(
{
createDeferredPromise
}
{
url
content
}
)
=
>
{
const
promise
=
createDeferredPromise
(
)
;
let
element
;
if
(
!
url
)
{
element
=
document
.
createElement
(
'
style
'
)
;
element
.
appendChild
(
document
.
createTextNode
(
content
)
)
;
}
else
{
const
link
=
document
.
createElement
(
'
link
'
)
;
link
.
rel
=
'
stylesheet
'
;
link
.
href
=
url
;
element
=
link
;
}
element
.
addEventListener
(
'
load
'
(
)
=
>
{
promise
.
resolve
(
)
;
}
{
once
:
true
}
)
;
element
.
addEventListener
(
'
error
'
event
=
>
{
var
_a
;
promise
.
reject
(
new
Error
(
(
_a
=
event
.
message
)
!
=
=
null
&
&
_a
!
=
=
void
0
?
_a
:
'
Could
not
load
style
'
)
)
;
}
{
once
:
true
}
)
;
document
.
head
.
appendChild
(
element
)
;
await
promise
;
return
element
;
}
await
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
puppeteerUtil
options
)
)
;
}
async
click
(
selector
options
=
{
}
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
click
(
selector
options
)
;
}
async
focus
(
selector
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
focus
(
selector
)
;
}
async
hover
(
selector
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
hover
(
selector
)
;
}
select
(
selector
.
.
.
values
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
select
(
selector
.
.
.
values
)
;
}
async
tap
(
selector
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
tap
(
selector
)
;
}
async
type
(
selector
text
options
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
type
(
selector
text
options
)
;
}
waitForTimeout
(
milliseconds
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
milliseconds
)
;
}
)
;
}
async
title
(
)
{
return
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
title
(
)
;
}
_navigated
(
framePayload
)
{
this
.
_name
=
framePayload
.
name
;
__classPrivateFieldSet
(
this
_Frame_url
{
framePayload
.
url
}
{
framePayload
.
urlFragment
|
|
'
'
}
"
f
"
)
;
}
_navigatedWithinDocument
(
url
)
{
__classPrivateFieldSet
(
this
_Frame_url
url
"
f
"
)
;
}
_onLifecycleEvent
(
loaderId
name
)
{
if
(
name
=
=
=
'
init
'
)
{
this
.
_loaderId
=
loaderId
;
this
.
_lifecycleEvents
.
clear
(
)
;
}
this
.
_lifecycleEvents
.
add
(
name
)
;
}
_onLoadingStopped
(
)
{
this
.
_lifecycleEvents
.
add
(
'
DOMContentLoaded
'
)
;
this
.
_lifecycleEvents
.
add
(
'
load
'
)
;
}
_onLoadingStarted
(
)
{
this
.
_hasStartedLoading
=
true
;
}
_detach
(
)
{
__classPrivateFieldSet
(
this
_Frame_detached
true
"
f
"
)
;
this
.
worlds
[
IsolatedWorlds_js_1
.
MAIN_WORLD
]
.
_detach
(
)
;
this
.
worlds
[
IsolatedWorlds_js_1
.
PUPPETEER_WORLD
]
.
_detach
(
)
;
}
}
exports
.
Frame
=
Frame
;
_Frame_url
=
new
WeakMap
(
)
_Frame_detached
=
new
WeakMap
(
)
_Frame_client
=
new
WeakMap
(
)
;
