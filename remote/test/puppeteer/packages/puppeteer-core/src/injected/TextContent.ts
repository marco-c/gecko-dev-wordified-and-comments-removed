interface
NonTrivialValueNode
extends
Node
{
value
:
string
;
}
const
TRIVIAL_VALUE_INPUT_TYPES
=
new
Set
(
[
'
checkbox
'
'
image
'
'
radio
'
]
)
;
const
isNonTrivialValueNode
=
(
node
:
Node
)
:
node
is
NonTrivialValueNode
=
>
{
if
(
node
instanceof
HTMLSelectElement
)
{
return
true
;
}
if
(
node
instanceof
HTMLTextAreaElement
)
{
return
true
;
}
if
(
node
instanceof
HTMLInputElement
&
&
!
TRIVIAL_VALUE_INPUT_TYPES
.
has
(
node
.
type
)
)
{
return
true
;
}
return
false
;
}
;
const
UNSUITABLE_NODE_NAMES
=
new
Set
(
[
'
SCRIPT
'
'
STYLE
'
]
)
;
export
const
isSuitableNodeForTextMatching
=
(
node
:
Node
)
:
boolean
=
>
{
return
(
!
UNSUITABLE_NODE_NAMES
.
has
(
node
.
nodeName
)
&
&
!
document
.
head
?
.
contains
(
node
)
)
;
}
;
export
interface
TextContent
{
full
:
string
;
immediate
:
string
[
]
;
}
const
textContentCache
=
new
WeakMap
<
Node
TextContent
>
(
)
;
const
eraseFromCache
=
(
node
:
Node
|
null
)
=
>
{
while
(
node
)
{
textContentCache
.
delete
(
node
)
;
if
(
node
instanceof
ShadowRoot
)
{
node
=
node
.
host
;
}
else
{
node
=
node
.
parentNode
;
}
}
}
;
const
observedNodes
=
new
WeakSet
<
Node
>
(
)
;
const
textChangeObserver
=
new
MutationObserver
(
mutations
=
>
{
for
(
const
mutation
of
mutations
)
{
eraseFromCache
(
mutation
.
target
)
;
}
}
)
;
export
const
createTextContent
=
(
root
:
Node
)
:
TextContent
=
>
{
let
value
=
textContentCache
.
get
(
root
)
;
if
(
value
)
{
return
value
;
}
value
=
{
full
:
'
'
immediate
:
[
]
}
;
if
(
!
isSuitableNodeForTextMatching
(
root
)
)
{
return
value
;
}
let
currentImmediate
=
'
'
;
if
(
isNonTrivialValueNode
(
root
)
)
{
value
.
full
=
root
.
value
;
value
.
immediate
.
push
(
root
.
value
)
;
root
.
addEventListener
(
'
input
'
event
=
>
{
eraseFromCache
(
event
.
target
as
HTMLInputElement
)
;
}
{
once
:
true
capture
:
true
}
)
;
}
else
{
for
(
let
child
=
root
.
firstChild
;
child
;
child
=
child
.
nextSibling
)
{
if
(
child
.
nodeType
=
=
=
Node
.
TEXT_NODE
)
{
value
.
full
+
=
child
.
nodeValue
?
?
'
'
;
currentImmediate
+
=
child
.
nodeValue
?
?
'
'
;
continue
;
}
if
(
currentImmediate
)
{
value
.
immediate
.
push
(
currentImmediate
)
;
}
currentImmediate
=
'
'
;
if
(
child
.
nodeType
=
=
=
Node
.
ELEMENT_NODE
)
{
value
.
full
+
=
createTextContent
(
child
)
.
full
;
}
}
if
(
currentImmediate
)
{
value
.
immediate
.
push
(
currentImmediate
)
;
}
if
(
root
instanceof
Element
&
&
root
.
shadowRoot
)
{
value
.
full
+
=
createTextContent
(
root
.
shadowRoot
)
.
full
;
}
if
(
!
observedNodes
.
has
(
root
)
)
{
textChangeObserver
.
observe
(
root
{
childList
:
true
characterData
:
true
subtree
:
true
}
)
;
observedNodes
.
add
(
root
)
;
}
}
textContentCache
.
set
(
root
value
)
;
return
value
;
}
;
