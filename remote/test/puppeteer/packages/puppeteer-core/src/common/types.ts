import
type
{
ElementHandle
}
from
'
.
.
/
api
/
ElementHandle
.
js
'
;
import
type
{
JSHandle
}
from
'
.
.
/
api
/
JSHandle
.
js
'
;
import
type
{
LazyArg
}
from
'
.
/
LazyArg
.
js
'
;
export
type
BindingPayload
=
{
type
:
string
;
name
:
string
;
seq
:
number
;
args
:
unknown
[
]
;
isTrivial
:
boolean
;
}
;
export
type
AwaitableIterator
<
T
>
=
Iterator
<
T
>
|
AsyncIterator
<
T
>
;
export
type
AwaitableIterable
<
T
>
=
Iterable
<
T
>
|
AsyncIterable
<
T
>
;
export
type
Awaitable
<
T
>
=
T
|
PromiseLike
<
T
>
;
export
type
HandleFor
<
T
>
=
T
extends
Node
?
ElementHandle
<
T
>
:
JSHandle
<
T
>
;
export
type
HandleOr
<
T
>
=
HandleFor
<
T
>
|
JSHandle
<
T
>
|
T
;
export
type
FlattenHandle
<
T
>
=
T
extends
HandleOr
<
infer
U
>
?
U
:
never
;
export
type
FlattenLazyArg
<
T
>
=
T
extends
LazyArg
<
infer
U
>
?
U
:
T
;
export
type
InnerLazyParams
<
T
extends
unknown
[
]
>
=
{
[
K
in
keyof
T
]
:
FlattenLazyArg
<
T
[
K
]
>
;
}
;
export
type
InnerParams
<
T
extends
unknown
[
]
>
=
{
[
K
in
keyof
T
]
:
FlattenHandle
<
T
[
K
]
>
;
}
;
export
type
ElementFor
<
TagName
extends
keyof
HTMLElementTagNameMap
|
keyof
SVGElementTagNameMap
>
=
TagName
extends
keyof
HTMLElementTagNameMap
?
HTMLElementTagNameMap
[
TagName
]
:
TagName
extends
keyof
SVGElementTagNameMap
?
SVGElementTagNameMap
[
TagName
]
:
never
;
export
type
EvaluateFunc
<
T
extends
unknown
[
]
>
=
(
.
.
.
params
:
InnerParams
<
T
>
)
=
>
Awaitable
<
unknown
>
;
export
type
EvaluateFuncWith
<
V
T
extends
unknown
[
]
>
=
(
.
.
.
params
:
[
V
.
.
.
InnerParams
<
T
>
]
)
=
>
Awaitable
<
unknown
>
;
export
type
NodeFor
<
ComplexSelector
extends
string
>
=
TypeSelectorOfComplexSelector
<
ComplexSelector
>
extends
infer
TypeSelector
?
TypeSelector
extends
|
keyof
HTMLElementTagNameMap
|
keyof
SVGElementTagNameMap
?
ElementFor
<
TypeSelector
>
:
Element
:
never
;
type
TypeSelectorOfComplexSelector
<
ComplexSelector
extends
string
>
=
CompoundSelectorsOfComplexSelector
<
ComplexSelector
>
extends
infer
CompoundSelectors
?
CompoundSelectors
extends
NonEmptyReadonlyArray
<
string
>
?
Last
<
CompoundSelectors
>
extends
infer
LastCompoundSelector
?
LastCompoundSelector
extends
string
?
TypeSelectorOfCompoundSelector
<
LastCompoundSelector
>
:
never
:
never
:
unknown
:
never
;
type
TypeSelectorOfCompoundSelector
<
CompoundSelector
extends
string
>
=
SplitWithDelemiters
<
CompoundSelector
BeginSubclassSelectorTokens
>
extends
infer
CompoundSelectorTokens
?
CompoundSelectorTokens
extends
[
infer
TypeSelector
.
.
.
any
[
]
]
?
TypeSelector
extends
'
'
?
unknown
:
TypeSelector
:
never
:
never
;
type
Last
<
Arr
extends
NonEmptyReadonlyArray
<
unknown
>
>
=
Arr
extends
[
infer
Head
.
.
.
infer
Tail
]
?
Tail
extends
NonEmptyReadonlyArray
<
unknown
>
?
Last
<
Tail
>
:
Head
:
never
;
type
NonEmptyReadonlyArray
<
T
>
=
[
T
.
.
.
(
readonly
T
[
]
)
]
;
type
CompoundSelectorsOfComplexSelector
<
ComplexSelector
extends
string
>
=
SplitWithDelemiters
<
ComplexSelector
CombinatorTokens
>
extends
infer
IntermediateTokens
?
IntermediateTokens
extends
readonly
string
[
]
?
Drop
<
IntermediateTokens
'
'
>
:
never
:
never
;
type
SplitWithDelemiters
<
Input
extends
string
Delemiters
extends
readonly
string
[
]
>
=
Delemiters
extends
[
infer
FirstDelemiter
.
.
.
infer
RestDelemiters
]
?
FirstDelemiter
extends
string
?
RestDelemiters
extends
readonly
string
[
]
?
FlatmapSplitWithDelemiters
<
Split
<
Input
FirstDelemiter
>
RestDelemiters
>
:
never
:
never
:
[
Input
]
;
type
BeginSubclassSelectorTokens
=
[
'
.
'
'
#
'
'
[
'
'
:
'
]
;
type
CombinatorTokens
=
[
'
'
'
>
'
'
+
'
'
~
'
'
|
'
'
|
'
]
;
type
Drop
<
Arr
extends
readonly
unknown
[
]
Remove
Acc
extends
unknown
[
]
=
[
]
>
=
Arr
extends
[
infer
Head
.
.
.
infer
Tail
]
?
Head
extends
Remove
?
Drop
<
Tail
Remove
>
:
Drop
<
Tail
Remove
[
.
.
.
Acc
Head
]
>
:
Acc
;
type
FlatmapSplitWithDelemiters
<
Inputs
extends
readonly
string
[
]
Delemiters
extends
readonly
string
[
]
Acc
extends
string
[
]
=
[
]
>
=
Inputs
extends
[
infer
FirstInput
.
.
.
infer
RestInputs
]
?
FirstInput
extends
string
?
RestInputs
extends
readonly
string
[
]
?
FlatmapSplitWithDelemiters
<
RestInputs
Delemiters
[
.
.
.
Acc
.
.
.
SplitWithDelemiters
<
FirstInput
Delemiters
>
]
>
:
Acc
:
Acc
:
Acc
;
type
Split
<
Input
extends
string
Delimiter
extends
string
Acc
extends
string
[
]
=
[
]
>
=
Input
extends
{
infer
Prefix
}
{
Delimiter
}
{
infer
Suffix
}
?
Split
<
Suffix
Delimiter
[
.
.
.
Acc
Prefix
]
>
:
[
.
.
.
Acc
Input
]
;
