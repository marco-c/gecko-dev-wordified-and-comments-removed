import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
ProtocolMapping
}
from
'
devtools
-
protocol
/
types
/
protocol
-
mapping
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
createDeferredPromise
}
from
'
.
.
/
util
/
util
.
js
'
;
import
{
ConnectionTransport
}
from
'
.
/
ConnectionTransport
.
js
'
;
import
{
debug
}
from
'
.
/
Debug
.
js
'
;
import
{
ProtocolError
}
from
'
.
/
Errors
.
js
'
;
import
{
EventEmitter
}
from
'
.
/
EventEmitter
.
js
'
;
const
debugProtocolSend
=
debug
(
'
puppeteer
:
protocol
:
SEND
'
)
;
const
debugProtocolReceive
=
debug
(
'
puppeteer
:
protocol
:
RECV
'
)
;
export
{
ConnectionTransport
ProtocolMapping
}
;
export
const
ConnectionEmittedEvents
=
{
Disconnected
:
Symbol
(
'
Connection
.
Disconnected
'
)
}
as
const
;
type
GetIdFn
=
(
)
=
>
number
;
function
createIncrementalIdGenerator
(
)
:
GetIdFn
{
let
id
=
0
;
return
(
)
:
number
=
>
{
return
+
+
id
;
}
;
}
class
Callback
{
#
id
:
number
;
#
error
=
new
ProtocolError
(
)
;
#
promise
=
createDeferredPromise
<
unknown
>
(
)
;
#
timer
?
:
ReturnType
<
typeof
setTimeout
>
;
#
label
:
string
;
constructor
(
id
:
number
label
:
string
timeout
?
:
number
)
{
this
.
#
id
=
id
;
this
.
#
label
=
label
;
if
(
timeout
)
{
this
.
#
timer
=
setTimeout
(
(
)
=
>
{
this
.
#
promise
.
reject
(
rewriteError
(
this
.
#
error
{
label
}
timed
out
.
Increase
the
'
protocolTimeout
'
setting
in
launch
/
connect
calls
for
a
higher
timeout
if
needed
.
)
)
;
}
timeout
)
;
}
}
resolve
(
value
:
unknown
)
:
void
{
clearTimeout
(
this
.
#
timer
)
;
this
.
#
promise
.
resolve
(
value
)
;
}
reject
(
error
:
Error
)
:
void
{
clearTimeout
(
this
.
#
timer
)
;
this
.
#
promise
.
reject
(
error
)
;
}
get
id
(
)
:
number
{
return
this
.
#
id
;
}
get
promise
(
)
:
Promise
<
unknown
>
{
return
this
.
#
promise
;
}
get
error
(
)
:
ProtocolError
{
return
this
.
#
error
;
}
get
label
(
)
:
string
{
return
this
.
#
label
;
}
}
export
class
CallbackRegistry
{
#
callbacks
:
Map
<
number
Callback
>
=
new
Map
(
)
;
#
idGenerator
=
createIncrementalIdGenerator
(
)
;
create
(
label
:
string
timeout
:
number
|
undefined
request
:
(
id
:
number
)
=
>
void
)
:
Promise
<
unknown
>
{
const
callback
=
new
Callback
(
this
.
#
idGenerator
(
)
label
timeout
)
;
this
.
#
callbacks
.
set
(
callback
.
id
callback
)
;
try
{
request
(
callback
.
id
)
;
}
catch
(
error
)
{
callback
.
promise
.
catch
(
(
)
=
>
{
this
.
#
callbacks
.
delete
(
callback
.
id
)
;
}
)
;
callback
.
reject
(
error
as
Error
)
;
throw
error
;
}
return
callback
.
promise
.
finally
(
(
)
=
>
{
this
.
#
callbacks
.
delete
(
callback
.
id
)
;
}
)
;
}
reject
(
id
:
number
message
:
string
originalMessage
?
:
string
)
:
void
{
const
callback
=
this
.
#
callbacks
.
get
(
id
)
;
if
(
!
callback
)
{
return
;
}
this
.
_reject
(
callback
message
originalMessage
)
;
}
_reject
(
callback
:
Callback
message
:
string
originalMessage
?
:
string
)
:
void
{
callback
.
reject
(
rewriteError
(
callback
.
error
Protocol
error
(
{
callback
.
label
}
)
:
{
message
}
originalMessage
)
)
;
}
resolve
(
id
:
number
value
:
unknown
)
:
void
{
const
callback
=
this
.
#
callbacks
.
get
(
id
)
;
if
(
!
callback
)
{
return
;
}
callback
.
resolve
(
value
)
;
}
clear
(
)
:
void
{
for
(
const
callback
of
this
.
#
callbacks
.
values
(
)
)
{
this
.
_reject
(
callback
'
Target
closed
'
)
;
}
this
.
#
callbacks
.
clear
(
)
;
}
}
export
class
Connection
extends
EventEmitter
{
#
url
:
string
;
#
transport
:
ConnectionTransport
;
#
delay
:
number
;
#
timeout
:
number
;
#
sessions
:
Map
<
string
CDPSessionImpl
>
=
new
Map
(
)
;
#
closed
=
false
;
#
manuallyAttached
=
new
Set
<
string
>
(
)
;
#
callbacks
=
new
CallbackRegistry
(
)
;
constructor
(
url
:
string
transport
:
ConnectionTransport
delay
=
0
timeout
?
:
number
)
{
super
(
)
;
this
.
#
url
=
url
;
this
.
#
delay
=
delay
;
this
.
#
timeout
=
timeout
?
?
180_000
;
this
.
#
transport
=
transport
;
this
.
#
transport
.
onmessage
=
this
.
onMessage
.
bind
(
this
)
;
this
.
#
transport
.
onclose
=
this
.
#
onClose
.
bind
(
this
)
;
}
static
fromSession
(
session
:
CDPSession
)
:
Connection
|
undefined
{
return
session
.
connection
(
)
;
}
get
timeout
(
)
:
number
{
return
this
.
#
timeout
;
}
get
_closed
(
)
:
boolean
{
return
this
.
#
closed
;
}
get
_sessions
(
)
:
Map
<
string
CDPSession
>
{
return
this
.
#
sessions
;
}
session
(
sessionId
:
string
)
:
CDPSession
|
null
{
return
this
.
#
sessions
.
get
(
sessionId
)
|
|
null
;
}
url
(
)
:
string
{
return
this
.
#
url
;
}
send
<
T
extends
keyof
ProtocolMapping
.
Commands
>
(
method
:
T
.
.
.
paramArgs
:
ProtocolMapping
.
Commands
[
T
]
[
'
paramsType
'
]
)
:
Promise
<
ProtocolMapping
.
Commands
[
T
]
[
'
returnType
'
]
>
{
const
params
=
paramArgs
.
length
?
paramArgs
[
0
]
:
undefined
;
return
this
.
_rawSend
(
this
.
#
callbacks
method
params
)
;
}
_rawSend
<
T
extends
keyof
ProtocolMapping
.
Commands
>
(
callbacks
:
CallbackRegistry
method
:
T
params
:
ProtocolMapping
.
Commands
[
T
]
[
'
paramsType
'
]
[
0
]
sessionId
?
:
string
)
:
Promise
<
ProtocolMapping
.
Commands
[
T
]
[
'
returnType
'
]
>
{
return
callbacks
.
create
(
method
this
.
#
timeout
id
=
>
{
const
stringifiedMessage
=
JSON
.
stringify
(
{
method
params
id
sessionId
}
)
;
debugProtocolSend
(
stringifiedMessage
)
;
this
.
#
transport
.
send
(
stringifiedMessage
)
;
}
)
as
Promise
<
ProtocolMapping
.
Commands
[
T
]
[
'
returnType
'
]
>
;
}
async
closeBrowser
(
)
:
Promise
<
void
>
{
await
this
.
send
(
'
Browser
.
close
'
)
;
}
protected
async
onMessage
(
message
:
string
)
:
Promise
<
void
>
{
if
(
this
.
#
delay
)
{
await
new
Promise
(
f
=
>
{
return
setTimeout
(
f
this
.
#
delay
)
;
}
)
;
}
debugProtocolReceive
(
message
)
;
const
object
=
JSON
.
parse
(
message
)
;
if
(
object
.
method
=
=
=
'
Target
.
attachedToTarget
'
)
{
const
sessionId
=
object
.
params
.
sessionId
;
const
session
=
new
CDPSessionImpl
(
this
object
.
params
.
targetInfo
.
type
sessionId
)
;
this
.
#
sessions
.
set
(
sessionId
session
)
;
this
.
emit
(
'
sessionattached
'
session
)
;
const
parentSession
=
this
.
#
sessions
.
get
(
object
.
sessionId
)
;
if
(
parentSession
)
{
parentSession
.
emit
(
'
sessionattached
'
session
)
;
}
}
else
if
(
object
.
method
=
=
=
'
Target
.
detachedFromTarget
'
)
{
const
session
=
this
.
#
sessions
.
get
(
object
.
params
.
sessionId
)
;
if
(
session
)
{
session
.
_onClosed
(
)
;
this
.
#
sessions
.
delete
(
object
.
params
.
sessionId
)
;
this
.
emit
(
'
sessiondetached
'
session
)
;
const
parentSession
=
this
.
#
sessions
.
get
(
object
.
sessionId
)
;
if
(
parentSession
)
{
parentSession
.
emit
(
'
sessiondetached
'
session
)
;
}
}
}
if
(
object
.
sessionId
)
{
const
session
=
this
.
#
sessions
.
get
(
object
.
sessionId
)
;
if
(
session
)
{
session
.
_onMessage
(
object
)
;
}
}
else
if
(
object
.
id
)
{
if
(
object
.
error
)
{
this
.
#
callbacks
.
reject
(
object
.
id
createProtocolErrorMessage
(
object
)
object
.
error
.
message
)
;
}
else
{
this
.
#
callbacks
.
resolve
(
object
.
id
object
.
result
)
;
}
}
else
{
this
.
emit
(
object
.
method
object
.
params
)
;
}
}
#
onClose
(
)
:
void
{
if
(
this
.
#
closed
)
{
return
;
}
this
.
#
closed
=
true
;
this
.
#
transport
.
onmessage
=
undefined
;
this
.
#
transport
.
onclose
=
undefined
;
this
.
#
callbacks
.
clear
(
)
;
for
(
const
session
of
this
.
#
sessions
.
values
(
)
)
{
session
.
_onClosed
(
)
;
}
this
.
#
sessions
.
clear
(
)
;
this
.
emit
(
ConnectionEmittedEvents
.
Disconnected
)
;
}
dispose
(
)
:
void
{
this
.
#
onClose
(
)
;
this
.
#
transport
.
close
(
)
;
}
isAutoAttached
(
targetId
:
string
)
:
boolean
{
return
!
this
.
#
manuallyAttached
.
has
(
targetId
)
;
}
async
_createSession
(
targetInfo
:
Protocol
.
Target
.
TargetInfo
isAutoAttachEmulated
=
true
)
:
Promise
<
CDPSession
>
{
if
(
!
isAutoAttachEmulated
)
{
this
.
#
manuallyAttached
.
add
(
targetInfo
.
targetId
)
;
}
const
{
sessionId
}
=
await
this
.
send
(
'
Target
.
attachToTarget
'
{
targetId
:
targetInfo
.
targetId
flatten
:
true
}
)
;
this
.
#
manuallyAttached
.
delete
(
targetInfo
.
targetId
)
;
const
session
=
this
.
#
sessions
.
get
(
sessionId
)
;
if
(
!
session
)
{
throw
new
Error
(
'
CDPSession
creation
failed
.
'
)
;
}
return
session
;
}
async
createSession
(
targetInfo
:
Protocol
.
Target
.
TargetInfo
)
:
Promise
<
CDPSession
>
{
return
await
this
.
_createSession
(
targetInfo
false
)
;
}
}
export
interface
CDPSessionOnMessageObject
{
id
?
:
number
;
method
:
string
;
params
:
Record
<
string
unknown
>
;
error
:
{
message
:
string
;
data
:
any
;
code
:
number
}
;
result
?
:
any
;
}
export
const
CDPSessionEmittedEvents
=
{
Disconnected
:
Symbol
(
'
CDPSession
.
Disconnected
'
)
}
as
const
;
export
class
CDPSession
extends
EventEmitter
{
constructor
(
)
{
super
(
)
;
}
connection
(
)
:
Connection
|
undefined
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
send
<
T
extends
keyof
ProtocolMapping
.
Commands
>
(
method
:
T
.
.
.
paramArgs
:
ProtocolMapping
.
Commands
[
T
]
[
'
paramsType
'
]
)
:
Promise
<
ProtocolMapping
.
Commands
[
T
]
[
'
returnType
'
]
>
;
send
<
T
extends
keyof
ProtocolMapping
.
Commands
>
(
)
:
Promise
<
ProtocolMapping
.
Commands
[
T
]
[
'
returnType
'
]
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
detach
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
id
(
)
:
string
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
}
export
class
CDPSessionImpl
extends
CDPSession
{
#
sessionId
:
string
;
#
targetType
:
string
;
#
callbacks
=
new
CallbackRegistry
(
)
;
#
connection
?
:
Connection
;
constructor
(
connection
:
Connection
targetType
:
string
sessionId
:
string
)
{
super
(
)
;
this
.
#
connection
=
connection
;
this
.
#
targetType
=
targetType
;
this
.
#
sessionId
=
sessionId
;
}
override
connection
(
)
:
Connection
|
undefined
{
return
this
.
#
connection
;
}
override
send
<
T
extends
keyof
ProtocolMapping
.
Commands
>
(
method
:
T
.
.
.
paramArgs
:
ProtocolMapping
.
Commands
[
T
]
[
'
paramsType
'
]
)
:
Promise
<
ProtocolMapping
.
Commands
[
T
]
[
'
returnType
'
]
>
{
if
(
!
this
.
#
connection
)
{
return
Promise
.
reject
(
new
Error
(
Protocol
error
(
{
method
}
)
:
Session
closed
.
Most
likely
the
{
this
.
#
targetType
}
has
been
closed
.
)
)
;
}
const
params
=
paramArgs
.
length
?
paramArgs
[
0
]
:
undefined
;
return
this
.
#
connection
.
_rawSend
(
this
.
#
callbacks
method
params
this
.
#
sessionId
)
;
}
_onMessage
(
object
:
CDPSessionOnMessageObject
)
:
void
{
if
(
object
.
id
)
{
if
(
object
.
error
)
{
this
.
#
callbacks
.
reject
(
object
.
id
createProtocolErrorMessage
(
object
)
object
.
error
.
message
)
;
}
else
{
this
.
#
callbacks
.
resolve
(
object
.
id
object
.
result
)
;
}
}
else
{
assert
(
!
object
.
id
)
;
this
.
emit
(
object
.
method
object
.
params
)
;
}
}
override
async
detach
(
)
:
Promise
<
void
>
{
if
(
!
this
.
#
connection
)
{
throw
new
Error
(
Session
already
detached
.
Most
likely
the
{
this
.
#
targetType
}
has
been
closed
.
)
;
}
await
this
.
#
connection
.
send
(
'
Target
.
detachFromTarget
'
{
sessionId
:
this
.
#
sessionId
}
)
;
}
_onClosed
(
)
:
void
{
this
.
#
callbacks
.
clear
(
)
;
this
.
#
connection
=
undefined
;
this
.
emit
(
CDPSessionEmittedEvents
.
Disconnected
)
;
}
override
id
(
)
:
string
{
return
this
.
#
sessionId
;
}
}
function
createProtocolErrorMessage
(
object
:
{
error
:
{
message
:
string
;
data
:
any
;
code
:
number
}
;
}
)
:
string
{
let
message
=
{
object
.
error
.
message
}
;
if
(
'
data
'
in
object
.
error
)
{
message
+
=
{
object
.
error
.
data
}
;
}
return
message
;
}
function
rewriteError
(
error
:
ProtocolError
message
:
string
originalMessage
?
:
string
)
:
Error
{
error
.
message
=
message
;
error
.
originalMessage
=
originalMessage
?
?
error
.
originalMessage
;
return
error
;
}
export
function
isTargetClosedError
(
err
:
Error
)
:
boolean
{
return
(
err
.
message
.
includes
(
'
Target
closed
'
)
|
|
err
.
message
.
includes
(
'
Session
closed
'
)
)
;
}
