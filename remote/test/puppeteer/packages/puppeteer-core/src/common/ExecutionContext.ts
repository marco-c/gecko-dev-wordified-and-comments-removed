import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
type
{
ElementHandle
}
from
'
.
.
/
api
/
ElementHandle
.
js
'
;
import
{
JSHandle
}
from
'
.
.
/
api
/
JSHandle
.
js
'
;
import
type
PuppeteerUtil
from
'
.
.
/
injected
/
injected
.
js
'
;
import
{
AsyncIterableUtil
}
from
'
.
.
/
util
/
AsyncIterableUtil
.
js
'
;
import
{
stringifyFunction
}
from
'
.
.
/
util
/
Function
.
js
'
;
import
{
ARIAQueryHandler
}
from
'
.
/
AriaQueryHandler
.
js
'
;
import
{
Binding
}
from
'
.
/
Binding
.
js
'
;
import
{
CDPSession
}
from
'
.
/
Connection
.
js
'
;
import
{
CDPElementHandle
}
from
'
.
/
ElementHandle
.
js
'
;
import
{
IsolatedWorld
}
from
'
.
/
IsolatedWorld
.
js
'
;
import
{
CDPJSHandle
}
from
'
.
/
JSHandle
.
js
'
;
import
{
LazyArg
}
from
'
.
/
LazyArg
.
js
'
;
import
{
scriptInjector
}
from
'
.
/
ScriptInjector
.
js
'
;
import
{
EvaluateFunc
HandleFor
}
from
'
.
/
types
.
js
'
;
import
{
createJSHandle
getExceptionMessage
isString
valueFromRemoteObject
}
from
'
.
/
util
.
js
'
;
export
const
EVALUATION_SCRIPT_URL
=
'
pptr
:
/
/
__puppeteer_evaluation_script__
'
;
const
SOURCE_URL_REGEX
=
/
^
[
\
040
\
t
]
*
\
/
\
/
[
#
]
sourceURL
=
\
s
*
(
\
S
*
?
)
\
s
*
/
m
;
export
class
ExecutionContext
{
_client
:
CDPSession
;
_world
?
:
IsolatedWorld
;
_contextId
:
number
;
_contextName
?
:
string
;
constructor
(
client
:
CDPSession
contextPayload
:
Protocol
.
Runtime
.
ExecutionContextDescription
world
?
:
IsolatedWorld
)
{
this
.
_client
=
client
;
this
.
_world
=
world
;
this
.
_contextId
=
contextPayload
.
id
;
if
(
contextPayload
.
name
)
{
this
.
_contextName
=
contextPayload
.
name
;
}
}
#
bindingsInstalled
=
false
;
#
puppeteerUtil
?
:
Promise
<
JSHandle
<
PuppeteerUtil
>
>
;
get
puppeteerUtil
(
)
:
Promise
<
JSHandle
<
PuppeteerUtil
>
>
{
let
promise
=
Promise
.
resolve
(
)
as
Promise
<
unknown
>
;
if
(
!
this
.
#
bindingsInstalled
)
{
promise
=
Promise
.
all
(
[
this
.
#
installGlobalBinding
(
new
Binding
(
'
__ariaQuerySelector
'
ARIAQueryHandler
.
queryOne
as
(
.
.
.
args
:
unknown
[
]
)
=
>
unknown
)
)
this
.
#
installGlobalBinding
(
new
Binding
(
'
__ariaQuerySelectorAll
'
(
async
(
element
:
ElementHandle
<
Node
>
selector
:
string
)
:
Promise
<
JSHandle
<
Node
[
]
>
>
=
>
{
const
results
=
ARIAQueryHandler
.
queryAll
(
element
selector
)
;
return
element
.
executionContext
(
)
.
evaluateHandle
(
(
.
.
.
elements
)
=
>
{
return
elements
;
}
.
.
.
(
await
AsyncIterableUtil
.
collect
(
results
)
)
)
;
}
)
as
(
.
.
.
args
:
unknown
[
]
)
=
>
unknown
)
)
]
)
;
this
.
#
bindingsInstalled
=
true
;
}
scriptInjector
.
inject
(
script
=
>
{
if
(
this
.
#
puppeteerUtil
)
{
void
this
.
#
puppeteerUtil
.
then
(
handle
=
>
{
void
handle
.
dispose
(
)
;
}
)
;
}
this
.
#
puppeteerUtil
=
promise
.
then
(
(
)
=
>
{
return
this
.
evaluateHandle
(
script
)
as
Promise
<
JSHandle
<
PuppeteerUtil
>
>
;
}
)
;
}
!
this
.
#
puppeteerUtil
)
;
return
this
.
#
puppeteerUtil
as
Promise
<
JSHandle
<
PuppeteerUtil
>
>
;
}
async
#
installGlobalBinding
(
binding
:
Binding
)
{
try
{
if
(
this
.
_world
)
{
this
.
_world
.
_bindings
.
set
(
binding
.
name
binding
)
;
await
this
.
_world
.
_addBindingToContext
(
this
binding
.
name
)
;
}
}
catch
{
}
}
async
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
return
await
this
.
#
evaluate
(
true
pageFunction
.
.
.
args
)
;
}
async
evaluateHandle
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
return
this
.
#
evaluate
(
false
pageFunction
.
.
.
args
)
;
}
async
#
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
returnByValue
:
true
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
;
async
#
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
returnByValue
:
false
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
;
async
#
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
returnByValue
:
boolean
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
|
Awaited
<
ReturnType
<
Func
>
>
>
{
const
suffix
=
/
/
#
sourceURL
=
{
EVALUATION_SCRIPT_URL
}
;
if
(
isString
(
pageFunction
)
)
{
const
contextId
=
this
.
_contextId
;
const
expression
=
pageFunction
;
const
expressionWithSourceUrl
=
SOURCE_URL_REGEX
.
test
(
expression
)
?
expression
:
expression
+
'
\
n
'
+
suffix
;
const
{
exceptionDetails
result
:
remoteObject
}
=
await
this
.
_client
.
send
(
'
Runtime
.
evaluate
'
{
expression
:
expressionWithSourceUrl
contextId
returnByValue
awaitPromise
:
true
userGesture
:
true
}
)
.
catch
(
rewriteError
)
;
if
(
exceptionDetails
)
{
throw
new
Error
(
'
Evaluation
failed
:
'
+
getExceptionMessage
(
exceptionDetails
)
)
;
}
return
returnByValue
?
valueFromRemoteObject
(
remoteObject
)
:
createJSHandle
(
this
remoteObject
)
;
}
let
callFunctionOnPromise
;
try
{
callFunctionOnPromise
=
this
.
_client
.
send
(
'
Runtime
.
callFunctionOn
'
{
functionDeclaration
:
{
stringifyFunction
(
pageFunction
)
}
\
n
{
suffix
}
\
n
executionContextId
:
this
.
_contextId
arguments
:
await
Promise
.
all
(
args
.
map
(
convertArgument
.
bind
(
this
)
)
)
returnByValue
awaitPromise
:
true
userGesture
:
true
}
)
;
}
catch
(
error
)
{
if
(
error
instanceof
TypeError
&
&
error
.
message
.
startsWith
(
'
Converting
circular
structure
to
JSON
'
)
)
{
error
.
message
+
=
'
Recursive
objects
are
not
allowed
.
'
;
}
throw
error
;
}
const
{
exceptionDetails
result
:
remoteObject
}
=
await
callFunctionOnPromise
.
catch
(
rewriteError
)
;
if
(
exceptionDetails
)
{
throw
new
Error
(
'
Evaluation
failed
:
'
+
getExceptionMessage
(
exceptionDetails
)
)
;
}
return
returnByValue
?
valueFromRemoteObject
(
remoteObject
)
:
createJSHandle
(
this
remoteObject
)
;
async
function
convertArgument
(
this
:
ExecutionContext
arg
:
unknown
)
:
Promise
<
Protocol
.
Runtime
.
CallArgument
>
{
if
(
arg
instanceof
LazyArg
)
{
arg
=
await
arg
.
get
(
this
)
;
}
if
(
typeof
arg
=
=
=
'
bigint
'
)
{
return
{
unserializableValue
:
{
arg
.
toString
(
)
}
n
}
;
}
if
(
Object
.
is
(
arg
-
0
)
)
{
return
{
unserializableValue
:
'
-
0
'
}
;
}
if
(
Object
.
is
(
arg
Infinity
)
)
{
return
{
unserializableValue
:
'
Infinity
'
}
;
}
if
(
Object
.
is
(
arg
-
Infinity
)
)
{
return
{
unserializableValue
:
'
-
Infinity
'
}
;
}
if
(
Object
.
is
(
arg
NaN
)
)
{
return
{
unserializableValue
:
'
NaN
'
}
;
}
const
objectHandle
=
arg
&
&
(
arg
instanceof
CDPJSHandle
|
|
arg
instanceof
CDPElementHandle
)
?
arg
:
null
;
if
(
objectHandle
)
{
if
(
objectHandle
.
executionContext
(
)
!
=
=
this
)
{
throw
new
Error
(
'
JSHandles
can
be
evaluated
only
in
the
context
they
were
created
!
'
)
;
}
if
(
objectHandle
.
disposed
)
{
throw
new
Error
(
'
JSHandle
is
disposed
!
'
)
;
}
if
(
objectHandle
.
remoteObject
(
)
.
unserializableValue
)
{
return
{
unserializableValue
:
objectHandle
.
remoteObject
(
)
.
unserializableValue
}
;
}
if
(
!
objectHandle
.
remoteObject
(
)
.
objectId
)
{
return
{
value
:
objectHandle
.
remoteObject
(
)
.
value
}
;
}
return
{
objectId
:
objectHandle
.
remoteObject
(
)
.
objectId
}
;
}
return
{
value
:
arg
}
;
}
}
}
const
rewriteError
=
(
error
:
Error
)
:
Protocol
.
Runtime
.
EvaluateResponse
=
>
{
if
(
error
.
message
.
includes
(
'
Object
reference
chain
is
too
long
'
)
)
{
return
{
result
:
{
type
:
'
undefined
'
}
}
;
}
if
(
error
.
message
.
includes
(
"
Object
couldn
'
t
be
returned
by
value
"
)
)
{
return
{
result
:
{
type
:
'
undefined
'
}
}
;
}
if
(
error
.
message
.
endsWith
(
'
Cannot
find
context
with
specified
id
'
)
|
|
error
.
message
.
endsWith
(
'
Inspected
target
navigated
or
closed
'
)
)
{
throw
new
Error
(
'
Execution
context
was
destroyed
most
likely
because
of
a
navigation
.
'
)
;
}
throw
error
;
}
;
