import
type
{
Readable
}
from
'
stream
'
;
import
type
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
map
NEVER
Observable
timer
}
from
'
.
.
/
.
.
/
third_party
/
rxjs
/
rxjs
.
js
'
;
import
type
{
ElementHandle
}
from
'
.
.
/
api
/
ElementHandle
.
js
'
;
import
type
{
JSHandle
}
from
'
.
.
/
api
/
JSHandle
.
js
'
;
import
{
Page
}
from
'
.
.
/
api
/
Page
.
js
'
;
import
{
isNode
}
from
'
.
.
/
environment
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
Deferred
}
from
'
.
.
/
util
/
Deferred
.
js
'
;
import
{
isErrorLike
}
from
'
.
.
/
util
/
ErrorLike
.
js
'
;
import
type
{
CDPSession
}
from
'
.
/
Connection
.
js
'
;
import
{
debug
}
from
'
.
/
Debug
.
js
'
;
import
{
CDPElementHandle
}
from
'
.
/
ElementHandle
.
js
'
;
import
{
TimeoutError
}
from
'
.
/
Errors
.
js
'
;
import
type
{
CommonEventEmitter
}
from
'
.
/
EventEmitter
.
js
'
;
import
{
IsolatedWorld
}
from
'
.
/
IsolatedWorld
.
js
'
;
import
{
CDPJSHandle
}
from
'
.
/
JSHandle
.
js
'
;
import
{
Awaitable
}
from
'
.
/
types
.
js
'
;
export
const
debugError
=
debug
(
'
puppeteer
:
error
'
)
;
export
function
createEvaluationError
(
details
:
Protocol
.
Runtime
.
ExceptionDetails
)
:
unknown
{
let
name
:
string
;
let
message
:
string
;
if
(
!
details
.
exception
)
{
name
=
'
Error
'
;
message
=
details
.
text
;
}
else
if
(
(
details
.
exception
.
type
!
=
=
'
object
'
|
|
details
.
exception
.
subtype
!
=
=
'
error
'
)
&
&
!
details
.
exception
.
objectId
)
{
return
valueFromRemoteObject
(
details
.
exception
)
;
}
else
{
const
detail
=
getErrorDetails
(
details
)
;
name
=
detail
.
name
;
message
=
detail
.
message
;
}
const
messageHeight
=
message
.
split
(
'
\
n
'
)
.
length
;
const
error
=
new
Error
(
message
)
;
error
.
name
=
name
;
const
stackLines
=
error
.
stack
!
.
split
(
'
\
n
'
)
;
const
messageLines
=
stackLines
.
splice
(
0
messageHeight
)
;
stackLines
.
shift
(
)
;
if
(
details
.
stackTrace
&
&
stackLines
.
length
<
Error
.
stackTraceLimit
)
{
for
(
const
frame
of
details
.
stackTrace
.
callFrames
.
reverse
(
)
)
{
if
(
PuppeteerURL
.
isPuppeteerURL
(
frame
.
url
)
&
&
frame
.
url
!
=
=
PuppeteerURL
.
INTERNAL_URL
)
{
const
url
=
PuppeteerURL
.
parse
(
frame
.
url
)
;
stackLines
.
unshift
(
at
{
frame
.
functionName
|
|
url
.
functionName
}
(
{
url
.
functionName
}
at
{
url
.
siteString
}
<
anonymous
>
:
{
frame
.
lineNumber
}
:
{
frame
.
columnNumber
}
)
)
;
}
else
{
stackLines
.
push
(
at
{
frame
.
functionName
|
|
'
<
anonymous
>
'
}
(
{
frame
.
url
}
:
{
frame
.
lineNumber
}
:
{
frame
.
columnNumber
}
)
)
;
}
if
(
stackLines
.
length
>
=
Error
.
stackTraceLimit
)
{
break
;
}
}
}
error
.
stack
=
[
.
.
.
messageLines
.
.
.
stackLines
]
.
join
(
'
\
n
'
)
;
return
error
;
}
export
function
createClientError
(
details
:
Protocol
.
Runtime
.
ExceptionDetails
)
:
unknown
{
let
name
:
string
;
let
message
:
string
;
if
(
!
details
.
exception
)
{
name
=
'
Error
'
;
message
=
details
.
text
;
}
else
if
(
(
details
.
exception
.
type
!
=
=
'
object
'
|
|
details
.
exception
.
subtype
!
=
=
'
error
'
)
&
&
!
details
.
exception
.
objectId
)
{
return
valueFromRemoteObject
(
details
.
exception
)
;
}
else
{
const
detail
=
getErrorDetails
(
details
)
;
name
=
detail
.
name
;
message
=
detail
.
message
;
}
const
messageHeight
=
message
.
split
(
'
\
n
'
)
.
length
;
const
error
=
new
Error
(
message
)
;
error
.
name
=
name
;
const
stackLines
=
[
]
;
const
messageLines
=
error
.
stack
!
.
split
(
'
\
n
'
)
.
splice
(
0
messageHeight
)
;
if
(
details
.
stackTrace
&
&
stackLines
.
length
<
Error
.
stackTraceLimit
)
{
for
(
const
frame
of
details
.
stackTrace
.
callFrames
.
reverse
(
)
)
{
stackLines
.
push
(
at
{
frame
.
functionName
|
|
'
<
anonymous
>
'
}
(
{
frame
.
url
}
:
{
frame
.
lineNumber
}
:
{
frame
.
columnNumber
}
)
)
;
if
(
stackLines
.
length
>
=
Error
.
stackTraceLimit
)
{
break
;
}
}
}
error
.
stack
=
[
.
.
.
messageLines
.
.
.
stackLines
]
.
join
(
'
\
n
'
)
;
return
error
;
}
const
getErrorDetails
=
(
details
:
Protocol
.
Runtime
.
ExceptionDetails
)
=
>
{
let
name
=
'
'
;
let
message
:
string
;
const
lines
=
details
.
exception
?
.
description
?
.
split
(
'
\
n
at
'
)
?
?
[
]
;
const
size
=
Math
.
min
(
details
.
stackTrace
?
.
callFrames
.
length
?
?
0
lines
.
length
-
1
)
;
lines
.
splice
(
-
size
size
)
;
if
(
details
.
exception
?
.
className
)
{
name
=
details
.
exception
.
className
;
}
message
=
lines
.
join
(
'
\
n
'
)
;
if
(
name
&
&
message
.
startsWith
(
{
name
}
:
)
)
{
message
=
message
.
slice
(
name
.
length
+
2
)
;
}
return
{
message
name
}
;
}
;
const
SOURCE_URL
=
Symbol
(
'
Source
URL
for
Puppeteer
evaluation
scripts
'
)
;
export
class
PuppeteerURL
{
static
INTERNAL_URL
=
'
pptr
:
internal
'
;
static
fromCallSite
(
functionName
:
string
site
:
NodeJS
.
CallSite
)
:
PuppeteerURL
{
const
url
=
new
PuppeteerURL
(
)
;
url
.
#
functionName
=
functionName
;
url
.
#
siteString
=
site
.
toString
(
)
;
return
url
;
}
static
parse
=
(
url
:
string
)
:
PuppeteerURL
=
>
{
url
=
url
.
slice
(
'
pptr
:
'
.
length
)
;
const
[
functionName
=
'
'
siteString
=
'
'
]
=
url
.
split
(
'
;
'
)
;
const
puppeteerUrl
=
new
PuppeteerURL
(
)
;
puppeteerUrl
.
#
functionName
=
functionName
;
puppeteerUrl
.
#
siteString
=
decodeURIComponent
(
siteString
)
;
return
puppeteerUrl
;
}
;
static
isPuppeteerURL
=
(
url
:
string
)
:
boolean
=
>
{
return
url
.
startsWith
(
'
pptr
:
'
)
;
}
;
#
functionName
!
:
string
;
#
siteString
!
:
string
;
get
functionName
(
)
:
string
{
return
this
.
#
functionName
;
}
get
siteString
(
)
:
string
{
return
this
.
#
siteString
;
}
toString
(
)
:
string
{
return
pptr
:
{
[
this
.
#
functionName
encodeURIComponent
(
this
.
#
siteString
)
]
.
join
(
'
;
'
)
}
;
}
}
export
const
withSourcePuppeteerURLIfNone
=
<
T
extends
NonNullable
<
unknown
>
>
(
functionName
:
string
object
:
T
)
:
T
=
>
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
object
SOURCE_URL
)
)
{
return
object
;
}
const
original
=
Error
.
prepareStackTrace
;
Error
.
prepareStackTrace
=
(
_
stack
)
=
>
{
return
stack
[
2
]
;
}
;
const
site
=
new
Error
(
)
.
stack
as
unknown
as
NodeJS
.
CallSite
;
Error
.
prepareStackTrace
=
original
;
return
Object
.
assign
(
object
{
[
SOURCE_URL
]
:
PuppeteerURL
.
fromCallSite
(
functionName
site
)
}
)
;
}
;
export
const
getSourcePuppeteerURLIfAvailable
=
<
T
extends
NonNullable
<
unknown
>
>
(
object
:
T
)
:
PuppeteerURL
|
undefined
=
>
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
object
SOURCE_URL
)
)
{
return
object
[
SOURCE_URL
as
keyof
T
]
as
PuppeteerURL
;
}
return
undefined
;
}
;
export
function
valueFromRemoteObject
(
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
)
:
any
{
assert
(
!
remoteObject
.
objectId
'
Cannot
extract
value
when
objectId
is
given
'
)
;
if
(
remoteObject
.
unserializableValue
)
{
if
(
remoteObject
.
type
=
=
=
'
bigint
'
)
{
return
BigInt
(
remoteObject
.
unserializableValue
.
replace
(
'
n
'
'
'
)
)
;
}
switch
(
remoteObject
.
unserializableValue
)
{
case
'
-
0
'
:
return
-
0
;
case
'
NaN
'
:
return
NaN
;
case
'
Infinity
'
:
return
Infinity
;
case
'
-
Infinity
'
:
return
-
Infinity
;
default
:
throw
new
Error
(
'
Unsupported
unserializable
value
:
'
+
remoteObject
.
unserializableValue
)
;
}
}
return
remoteObject
.
value
;
}
export
async
function
releaseObject
(
client
:
CDPSession
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
)
:
Promise
<
void
>
{
if
(
!
remoteObject
.
objectId
)
{
return
;
}
await
client
.
send
(
'
Runtime
.
releaseObject
'
{
objectId
:
remoteObject
.
objectId
}
)
.
catch
(
error
=
>
{
debugError
(
error
)
;
}
)
;
}
export
interface
PuppeteerEventListener
{
emitter
:
CommonEventEmitter
;
eventName
:
string
|
symbol
;
handler
:
(
.
.
.
args
:
any
[
]
)
=
>
void
;
}
export
function
addEventListener
(
emitter
:
CommonEventEmitter
eventName
:
string
|
symbol
handler
:
(
.
.
.
args
:
any
[
]
)
=
>
void
)
:
PuppeteerEventListener
{
emitter
.
on
(
eventName
handler
)
;
return
{
emitter
eventName
handler
}
;
}
export
function
removeEventListeners
(
listeners
:
Array
<
{
emitter
:
CommonEventEmitter
;
eventName
:
string
|
symbol
;
handler
:
(
.
.
.
args
:
any
[
]
)
=
>
void
;
}
>
)
:
void
{
for
(
const
listener
of
listeners
)
{
listener
.
emitter
.
removeListener
(
listener
.
eventName
listener
.
handler
)
;
}
listeners
.
length
=
0
;
}
export
const
isString
=
(
obj
:
unknown
)
:
obj
is
string
=
>
{
return
typeof
obj
=
=
=
'
string
'
|
|
obj
instanceof
String
;
}
;
export
const
isNumber
=
(
obj
:
unknown
)
:
obj
is
number
=
>
{
return
typeof
obj
=
=
=
'
number
'
|
|
obj
instanceof
Number
;
}
;
export
const
isPlainObject
=
(
obj
:
unknown
)
:
obj
is
Record
<
any
unknown
>
=
>
{
return
typeof
obj
=
=
=
'
object
'
&
&
obj
?
.
constructor
=
=
=
Object
;
}
;
export
const
isRegExp
=
(
obj
:
unknown
)
:
obj
is
RegExp
=
>
{
return
typeof
obj
=
=
=
'
object
'
&
&
obj
?
.
constructor
=
=
=
RegExp
;
}
;
export
const
isDate
=
(
obj
:
unknown
)
:
obj
is
Date
=
>
{
return
typeof
obj
=
=
=
'
object
'
&
&
obj
?
.
constructor
=
=
=
Date
;
}
;
export
async
function
waitForEvent
<
T
>
(
emitter
:
CommonEventEmitter
eventName
:
string
|
symbol
predicate
:
(
event
:
T
)
=
>
Awaitable
<
boolean
>
timeout
:
number
abortPromise
:
Promise
<
Error
>
|
Deferred
<
Error
>
)
:
Promise
<
T
>
{
const
deferred
=
Deferred
.
create
<
T
>
(
{
message
:
Timeout
exceeded
while
waiting
for
event
{
String
(
eventName
)
}
timeout
}
)
;
const
listener
=
addEventListener
(
emitter
eventName
async
event
=
>
{
if
(
await
predicate
(
event
)
)
{
deferred
.
resolve
(
event
)
;
}
}
)
;
try
{
const
response
=
await
Deferred
.
race
<
T
|
Error
>
(
[
deferred
abortPromise
]
)
;
if
(
isErrorLike
(
response
)
)
{
throw
response
;
}
return
response
;
}
catch
(
error
)
{
throw
error
;
}
finally
{
removeEventListeners
(
[
listener
]
)
;
}
}
export
function
createCdpHandle
(
realm
:
IsolatedWorld
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
)
:
JSHandle
|
ElementHandle
<
Node
>
{
if
(
remoteObject
.
subtype
=
=
=
'
node
'
)
{
return
new
CDPElementHandle
(
realm
remoteObject
)
;
}
return
new
CDPJSHandle
(
realm
remoteObject
)
;
}
export
function
evaluationString
(
fun
:
Function
|
string
.
.
.
args
:
unknown
[
]
)
:
string
{
if
(
isString
(
fun
)
)
{
assert
(
args
.
length
=
=
=
0
'
Cannot
evaluate
a
string
with
arguments
'
)
;
return
fun
;
}
function
serializeArgument
(
arg
:
unknown
)
:
string
{
if
(
Object
.
is
(
arg
undefined
)
)
{
return
'
undefined
'
;
}
return
JSON
.
stringify
(
arg
)
;
}
return
(
{
fun
}
)
(
{
args
.
map
(
serializeArgument
)
.
join
(
'
'
)
}
)
;
}
export
function
addPageBinding
(
type
:
string
name
:
string
)
:
void
{
const
callCDP
=
globalThis
[
name
]
;
Object
.
assign
(
globalThis
{
[
name
]
(
.
.
.
args
:
unknown
[
]
)
:
Promise
<
unknown
>
{
const
callPuppeteer
=
globalThis
[
name
]
;
callPuppeteer
.
args
?
?
=
new
Map
(
)
;
callPuppeteer
.
callbacks
?
?
=
new
Map
(
)
;
const
seq
=
(
callPuppeteer
.
lastSeq
?
?
0
)
+
1
;
callPuppeteer
.
lastSeq
=
seq
;
callPuppeteer
.
args
.
set
(
seq
args
)
;
callCDP
(
JSON
.
stringify
(
{
type
name
seq
args
isTrivial
:
!
args
.
some
(
value
=
>
{
return
value
instanceof
Node
;
}
)
}
)
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
callPuppeteer
.
callbacks
.
set
(
seq
{
resolve
(
value
:
unknown
)
{
callPuppeteer
.
args
.
delete
(
seq
)
;
resolve
(
value
)
;
}
reject
(
value
?
:
unknown
)
{
callPuppeteer
.
args
.
delete
(
seq
)
;
reject
(
value
)
;
}
}
)
;
}
)
;
}
}
)
;
}
export
function
pageBindingInitString
(
type
:
string
name
:
string
)
:
string
{
return
evaluationString
(
addPageBinding
type
name
)
;
}
export
async
function
waitWithTimeout
<
T
>
(
promise
:
Promise
<
T
>
taskName
:
string
timeout
:
number
)
:
Promise
<
T
>
{
const
deferred
=
Deferred
.
create
<
never
>
(
{
message
:
waiting
for
{
taskName
}
failed
:
timeout
{
timeout
}
ms
exceeded
timeout
}
)
;
return
await
Deferred
.
race
(
[
promise
deferred
]
)
;
}
let
fs
:
typeof
import
(
'
fs
/
promises
'
)
|
null
=
null
;
export
async
function
importFSPromises
(
)
:
Promise
<
typeof
import
(
'
fs
/
promises
'
)
>
{
if
(
!
fs
)
{
try
{
fs
=
await
import
(
'
fs
/
promises
'
)
;
}
catch
(
error
)
{
if
(
error
instanceof
TypeError
)
{
throw
new
Error
(
'
Cannot
write
to
a
path
outside
of
a
Node
-
like
environment
.
'
)
;
}
throw
error
;
}
}
return
fs
;
}
export
async
function
getReadableAsBuffer
(
readable
:
Readable
path
?
:
string
)
:
Promise
<
Buffer
|
null
>
{
const
buffers
=
[
]
;
if
(
path
)
{
const
fs
=
await
importFSPromises
(
)
;
const
fileHandle
=
await
fs
.
open
(
path
'
w
+
'
)
;
try
{
for
await
(
const
chunk
of
readable
)
{
buffers
.
push
(
chunk
)
;
await
fileHandle
.
writeFile
(
chunk
)
;
}
}
finally
{
await
fileHandle
.
close
(
)
;
}
}
else
{
for
await
(
const
chunk
of
readable
)
{
buffers
.
push
(
chunk
)
;
}
}
try
{
return
Buffer
.
concat
(
buffers
)
;
}
catch
(
error
)
{
return
null
;
}
}
export
async
function
getReadableFromProtocolStream
(
client
:
CDPSession
handle
:
string
)
:
Promise
<
Readable
>
{
if
(
!
isNode
)
{
throw
new
Error
(
'
Cannot
create
a
stream
outside
of
Node
.
js
environment
.
'
)
;
}
const
{
Readable
}
=
await
import
(
'
stream
'
)
;
let
eof
=
false
;
return
new
Readable
(
{
async
read
(
size
:
number
)
{
if
(
eof
)
{
return
;
}
try
{
const
response
=
await
client
.
send
(
'
IO
.
read
'
{
handle
size
}
)
;
this
.
push
(
response
.
data
response
.
base64Encoded
?
'
base64
'
:
undefined
)
;
if
(
response
.
eof
)
{
eof
=
true
;
await
client
.
send
(
'
IO
.
close
'
{
handle
}
)
;
this
.
push
(
null
)
;
}
}
catch
(
error
)
{
if
(
isErrorLike
(
error
)
)
{
this
.
destroy
(
error
)
;
return
;
}
throw
error
;
}
}
}
)
;
}
export
async
function
setPageContent
(
page
:
Pick
<
Page
'
evaluate
'
>
content
:
string
)
:
Promise
<
void
>
{
return
await
page
.
evaluate
(
html
=
>
{
document
.
open
(
)
;
document
.
write
(
html
)
;
document
.
close
(
)
;
}
content
)
;
}
export
function
getPageContent
(
)
:
string
{
let
content
=
'
'
;
for
(
const
node
of
document
.
childNodes
)
{
switch
(
node
)
{
case
document
.
documentElement
:
content
+
=
document
.
documentElement
.
outerHTML
;
break
;
default
:
content
+
=
new
XMLSerializer
(
)
.
serializeToString
(
node
)
;
break
;
}
}
return
content
;
}
export
function
validateDialogType
(
type
:
string
)
:
'
alert
'
|
'
confirm
'
|
'
prompt
'
|
'
beforeunload
'
{
let
dialogType
=
null
;
const
validDialogTypes
=
new
Set
(
[
'
alert
'
'
confirm
'
'
prompt
'
'
beforeunload
'
]
)
;
if
(
validDialogTypes
.
has
(
type
)
)
{
dialogType
=
type
;
}
assert
(
dialogType
Unknown
javascript
dialog
type
:
{
type
}
)
;
return
dialogType
as
'
alert
'
|
'
confirm
'
|
'
prompt
'
|
'
beforeunload
'
;
}
export
class
Mutex
{
static
Guard
=
class
Guard
{
#
mutex
:
Mutex
;
constructor
(
mutex
:
Mutex
)
{
this
.
#
mutex
=
mutex
;
}
[
Symbol
.
dispose
]
(
)
:
void
{
return
this
.
#
mutex
.
release
(
)
;
}
}
;
#
locked
=
false
;
#
acquirers
:
Array
<
(
)
=
>
void
>
=
[
]
;
async
acquire
(
)
:
Promise
<
InstanceType
<
typeof
Mutex
.
Guard
>
>
{
if
(
!
this
.
#
locked
)
{
this
.
#
locked
=
true
;
return
new
Mutex
.
Guard
(
this
)
;
}
const
deferred
=
Deferred
.
create
<
void
>
(
)
;
this
.
#
acquirers
.
push
(
deferred
.
resolve
.
bind
(
deferred
)
)
;
await
deferred
.
valueOrThrow
(
)
;
return
new
Mutex
.
Guard
(
this
)
;
}
release
(
)
:
void
{
const
resolve
=
this
.
#
acquirers
.
shift
(
)
;
if
(
!
resolve
)
{
this
.
#
locked
=
false
;
return
;
}
resolve
(
)
;
}
}
export
function
timeout
(
ms
:
number
)
:
Observable
<
never
>
{
return
ms
=
=
=
0
?
NEVER
:
timer
(
ms
)
.
pipe
(
map
(
(
)
=
>
{
throw
new
TimeoutError
(
Timed
out
after
waiting
{
ms
}
ms
)
;
}
)
)
;
}
