import
type
{
Readable
}
from
'
stream
'
;
import
type
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
type
{
ElementHandle
}
from
'
.
.
/
api
/
ElementHandle
.
js
'
;
import
type
{
JSHandle
}
from
'
.
.
/
api
/
JSHandle
.
js
'
;
import
{
isNode
}
from
'
.
.
/
environment
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
isErrorLike
}
from
'
.
.
/
util
/
ErrorLike
.
js
'
;
import
type
{
CDPSession
}
from
'
.
/
Connection
.
js
'
;
import
{
debug
}
from
'
.
/
Debug
.
js
'
;
import
{
CDPElementHandle
}
from
'
.
/
ElementHandle
.
js
'
;
import
{
TimeoutError
}
from
'
.
/
Errors
.
js
'
;
import
type
{
CommonEventEmitter
}
from
'
.
/
EventEmitter
.
js
'
;
import
type
{
ExecutionContext
}
from
'
.
/
ExecutionContext
.
js
'
;
import
{
CDPJSHandle
}
from
'
.
/
JSHandle
.
js
'
;
export
const
debugError
=
debug
(
'
puppeteer
:
error
'
)
;
export
function
getExceptionMessage
(
exceptionDetails
:
Protocol
.
Runtime
.
ExceptionDetails
)
:
string
{
if
(
exceptionDetails
.
exception
)
{
return
(
exceptionDetails
.
exception
.
description
|
|
exceptionDetails
.
exception
.
value
)
;
}
let
message
=
exceptionDetails
.
text
;
if
(
exceptionDetails
.
stackTrace
)
{
for
(
const
callframe
of
exceptionDetails
.
stackTrace
.
callFrames
)
{
const
location
=
callframe
.
url
+
'
:
'
+
callframe
.
lineNumber
+
'
:
'
+
callframe
.
columnNumber
;
const
functionName
=
callframe
.
functionName
|
|
'
<
anonymous
>
'
;
message
+
=
\
n
at
{
functionName
}
(
{
location
}
)
;
}
}
return
message
;
}
export
function
valueFromRemoteObject
(
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
)
:
any
{
assert
(
!
remoteObject
.
objectId
'
Cannot
extract
value
when
objectId
is
given
'
)
;
if
(
remoteObject
.
unserializableValue
)
{
if
(
remoteObject
.
type
=
=
=
'
bigint
'
&
&
typeof
BigInt
!
=
=
'
undefined
'
)
{
return
BigInt
(
remoteObject
.
unserializableValue
.
replace
(
'
n
'
'
'
)
)
;
}
switch
(
remoteObject
.
unserializableValue
)
{
case
'
-
0
'
:
return
-
0
;
case
'
NaN
'
:
return
NaN
;
case
'
Infinity
'
:
return
Infinity
;
case
'
-
Infinity
'
:
return
-
Infinity
;
default
:
throw
new
Error
(
'
Unsupported
unserializable
value
:
'
+
remoteObject
.
unserializableValue
)
;
}
}
return
remoteObject
.
value
;
}
export
async
function
releaseObject
(
client
:
CDPSession
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
)
:
Promise
<
void
>
{
if
(
!
remoteObject
.
objectId
)
{
return
;
}
await
client
.
send
(
'
Runtime
.
releaseObject
'
{
objectId
:
remoteObject
.
objectId
}
)
.
catch
(
error
=
>
{
debugError
(
error
)
;
}
)
;
}
export
interface
PuppeteerEventListener
{
emitter
:
CommonEventEmitter
;
eventName
:
string
|
symbol
;
handler
:
(
.
.
.
args
:
any
[
]
)
=
>
void
;
}
export
function
addEventListener
(
emitter
:
CommonEventEmitter
eventName
:
string
|
symbol
handler
:
(
.
.
.
args
:
any
[
]
)
=
>
void
)
:
PuppeteerEventListener
{
emitter
.
on
(
eventName
handler
)
;
return
{
emitter
eventName
handler
}
;
}
export
function
removeEventListeners
(
listeners
:
Array
<
{
emitter
:
CommonEventEmitter
;
eventName
:
string
|
symbol
;
handler
:
(
.
.
.
args
:
any
[
]
)
=
>
void
;
}
>
)
:
void
{
for
(
const
listener
of
listeners
)
{
listener
.
emitter
.
removeListener
(
listener
.
eventName
listener
.
handler
)
;
}
listeners
.
length
=
0
;
}
export
const
isString
=
(
obj
:
unknown
)
:
obj
is
string
=
>
{
return
typeof
obj
=
=
=
'
string
'
|
|
obj
instanceof
String
;
}
;
export
const
isNumber
=
(
obj
:
unknown
)
:
obj
is
number
=
>
{
return
typeof
obj
=
=
=
'
number
'
|
|
obj
instanceof
Number
;
}
;
export
const
isPlainObject
=
(
obj
:
unknown
)
:
obj
is
Record
<
any
unknown
>
=
>
{
return
typeof
obj
=
=
=
'
object
'
&
&
obj
?
.
constructor
=
=
=
Object
;
}
;
export
const
isRegExp
=
(
obj
:
unknown
)
:
obj
is
RegExp
=
>
{
return
typeof
obj
=
=
=
'
object
'
&
&
obj
?
.
constructor
=
=
=
RegExp
;
}
;
export
const
isDate
=
(
obj
:
unknown
)
:
obj
is
Date
=
>
{
return
typeof
obj
=
=
=
'
object
'
&
&
obj
?
.
constructor
=
=
=
Date
;
}
;
export
async
function
waitForEvent
<
T
>
(
emitter
:
CommonEventEmitter
eventName
:
string
|
symbol
predicate
:
(
event
:
T
)
=
>
Promise
<
boolean
>
|
boolean
timeout
:
number
abortPromise
:
Promise
<
Error
>
)
:
Promise
<
T
>
{
let
eventTimeout
:
NodeJS
.
Timeout
;
let
resolveCallback
:
(
value
:
T
|
PromiseLike
<
T
>
)
=
>
void
;
let
rejectCallback
:
(
value
:
Error
)
=
>
void
;
const
promise
=
new
Promise
<
T
>
(
(
resolve
reject
)
=
>
{
resolveCallback
=
resolve
;
rejectCallback
=
reject
;
}
)
;
const
listener
=
addEventListener
(
emitter
eventName
async
event
=
>
{
if
(
!
(
await
predicate
(
event
)
)
)
{
return
;
}
resolveCallback
(
event
)
;
}
)
;
if
(
timeout
)
{
eventTimeout
=
setTimeout
(
(
)
=
>
{
rejectCallback
(
new
TimeoutError
(
'
Timeout
exceeded
while
waiting
for
event
'
)
)
;
}
timeout
)
;
}
function
cleanup
(
)
:
void
{
removeEventListeners
(
[
listener
]
)
;
clearTimeout
(
eventTimeout
)
;
}
const
result
=
await
Promise
.
race
(
[
promise
abortPromise
]
)
.
then
(
r
=
>
{
cleanup
(
)
;
return
r
;
}
error
=
>
{
cleanup
(
)
;
throw
error
;
}
)
;
if
(
isErrorLike
(
result
)
)
{
throw
result
;
}
return
result
;
}
export
function
createJSHandle
(
context
:
ExecutionContext
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
)
:
JSHandle
|
ElementHandle
<
Node
>
{
if
(
remoteObject
.
subtype
=
=
=
'
node
'
&
&
context
.
_world
)
{
return
new
CDPElementHandle
(
context
remoteObject
context
.
_world
.
frame
(
)
)
;
}
return
new
CDPJSHandle
(
context
remoteObject
)
;
}
export
function
evaluationString
(
fun
:
Function
|
string
.
.
.
args
:
unknown
[
]
)
:
string
{
if
(
isString
(
fun
)
)
{
assert
(
args
.
length
=
=
=
0
'
Cannot
evaluate
a
string
with
arguments
'
)
;
return
fun
;
}
function
serializeArgument
(
arg
:
unknown
)
:
string
{
if
(
Object
.
is
(
arg
undefined
)
)
{
return
'
undefined
'
;
}
return
JSON
.
stringify
(
arg
)
;
}
return
(
{
fun
}
)
(
{
args
.
map
(
serializeArgument
)
.
join
(
'
'
)
}
)
;
}
export
function
addPageBinding
(
type
:
string
name
:
string
)
:
void
{
const
callCDP
=
globalThis
[
name
]
;
Object
.
assign
(
globalThis
{
[
name
]
(
.
.
.
args
:
unknown
[
]
)
:
Promise
<
unknown
>
{
const
callPuppeteer
=
globalThis
[
name
]
;
callPuppeteer
.
args
?
?
=
new
Map
(
)
;
callPuppeteer
.
callbacks
?
?
=
new
Map
(
)
;
const
seq
=
(
callPuppeteer
.
lastSeq
?
?
0
)
+
1
;
callPuppeteer
.
lastSeq
=
seq
;
callPuppeteer
.
args
.
set
(
seq
args
)
;
callCDP
(
JSON
.
stringify
(
{
type
name
seq
args
isTrivial
:
!
args
.
some
(
value
=
>
{
return
value
instanceof
Node
;
}
)
}
)
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
callPuppeteer
.
callbacks
.
set
(
seq
{
resolve
(
value
:
unknown
)
{
callPuppeteer
.
args
.
delete
(
seq
)
;
resolve
(
value
)
;
}
reject
(
value
?
:
unknown
)
{
callPuppeteer
.
args
.
delete
(
seq
)
;
reject
(
value
)
;
}
}
)
;
}
)
;
}
}
)
;
}
export
function
pageBindingInitString
(
type
:
string
name
:
string
)
:
string
{
return
evaluationString
(
addPageBinding
type
name
)
;
}
export
async
function
waitWithTimeout
<
T
>
(
promise
:
Promise
<
T
>
taskName
:
string
timeout
:
number
)
:
Promise
<
T
>
{
let
reject
:
(
reason
?
:
Error
)
=
>
void
;
const
timeoutError
=
new
TimeoutError
(
waiting
for
{
taskName
}
failed
:
timeout
{
timeout
}
ms
exceeded
)
;
const
timeoutPromise
=
new
Promise
<
T
>
(
(
_res
rej
)
=
>
{
return
(
reject
=
rej
)
;
}
)
;
let
timeoutTimer
=
null
;
if
(
timeout
)
{
timeoutTimer
=
setTimeout
(
(
)
=
>
{
return
reject
(
timeoutError
)
;
}
timeout
)
;
}
try
{
return
await
Promise
.
race
(
[
promise
timeoutPromise
]
)
;
}
finally
{
if
(
timeoutTimer
)
{
clearTimeout
(
timeoutTimer
)
;
}
}
}
let
fs
:
typeof
import
(
'
fs
'
)
|
null
=
null
;
export
async
function
importFS
(
)
:
Promise
<
typeof
import
(
'
fs
'
)
>
{
if
(
!
fs
)
{
fs
=
await
import
(
'
fs
'
)
;
}
return
fs
;
}
export
async
function
getReadableAsBuffer
(
readable
:
Readable
path
?
:
string
)
:
Promise
<
Buffer
|
null
>
{
const
buffers
=
[
]
;
if
(
path
)
{
let
fs
:
typeof
import
(
'
fs
'
)
.
promises
;
try
{
fs
=
(
await
importFS
(
)
)
.
promises
;
}
catch
(
error
)
{
if
(
error
instanceof
TypeError
)
{
throw
new
Error
(
'
Cannot
write
to
a
path
outside
of
a
Node
-
like
environment
.
'
)
;
}
throw
error
;
}
const
fileHandle
=
await
fs
.
open
(
path
'
w
+
'
)
;
for
await
(
const
chunk
of
readable
)
{
buffers
.
push
(
chunk
)
;
await
fileHandle
.
writeFile
(
chunk
)
;
}
await
fileHandle
.
close
(
)
;
}
else
{
for
await
(
const
chunk
of
readable
)
{
buffers
.
push
(
chunk
)
;
}
}
try
{
return
Buffer
.
concat
(
buffers
)
;
}
catch
(
error
)
{
return
null
;
}
}
export
async
function
getReadableFromProtocolStream
(
client
:
CDPSession
handle
:
string
)
:
Promise
<
Readable
>
{
if
(
!
isNode
)
{
throw
new
Error
(
'
Cannot
create
a
stream
outside
of
Node
.
js
environment
.
'
)
;
}
const
{
Readable
}
=
await
import
(
'
stream
'
)
;
let
eof
=
false
;
return
new
Readable
(
{
async
read
(
size
:
number
)
{
if
(
eof
)
{
return
;
}
const
response
=
await
client
.
send
(
'
IO
.
read
'
{
handle
size
}
)
;
this
.
push
(
response
.
data
response
.
base64Encoded
?
'
base64
'
:
undefined
)
;
if
(
response
.
eof
)
{
eof
=
true
;
await
client
.
send
(
'
IO
.
close
'
{
handle
}
)
;
this
.
push
(
null
)
;
}
}
}
)
;
}
