import
{
JSHandle
}
from
'
.
.
/
.
.
/
api
/
JSHandle
.
js
'
;
import
{
Realm
}
from
'
.
.
/
.
.
/
api
/
Realm
.
js
'
;
import
{
TimeoutSettings
}
from
'
.
.
/
TimeoutSettings
.
js
'
;
import
{
EvaluateFunc
HandleFor
}
from
'
.
.
/
types
.
js
'
;
import
{
withSourcePuppeteerURLIfNone
}
from
'
.
.
/
util
.
js
'
;
import
{
BrowsingContext
}
from
'
.
/
BrowsingContext
.
js
'
;
import
{
BidiFrame
}
from
'
.
/
Frame
.
js
'
;
import
{
Realm
as
BidiRealm
}
from
'
.
/
Realm
.
js
'
;
export
const
MAIN_SANDBOX
=
Symbol
(
'
mainSandbox
'
)
;
export
const
PUPPETEER_SANDBOX
=
Symbol
(
'
puppeteerSandbox
'
)
;
export
interface
SandboxChart
{
[
key
:
string
]
:
Sandbox
;
[
MAIN_SANDBOX
]
:
Sandbox
;
[
PUPPETEER_SANDBOX
]
:
Sandbox
;
}
export
class
Sandbox
extends
Realm
{
readonly
name
:
string
|
undefined
;
readonly
realm
:
BidiRealm
;
#
frame
:
BidiFrame
;
constructor
(
name
:
string
|
undefined
frame
:
BidiFrame
realm
:
BidiRealm
|
BrowsingContext
timeoutSettings
:
TimeoutSettings
)
{
super
(
timeoutSettings
)
;
this
.
name
=
name
;
this
.
realm
=
realm
;
this
.
#
frame
=
frame
;
this
.
realm
.
setSandbox
(
this
)
;
}
override
get
environment
(
)
:
BidiFrame
{
return
this
.
#
frame
;
}
async
evaluateHandle
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluateHandle
.
name
pageFunction
)
;
return
await
this
.
realm
.
evaluateHandle
(
pageFunction
.
.
.
args
)
;
}
async
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluate
.
name
pageFunction
)
;
return
await
this
.
realm
.
evaluate
(
pageFunction
.
.
.
args
)
;
}
async
adoptHandle
<
T
extends
JSHandle
<
Node
>
>
(
handle
:
T
)
:
Promise
<
T
>
{
return
(
await
this
.
evaluateHandle
(
node
=
>
{
return
node
;
}
handle
)
)
as
unknown
as
T
;
}
async
transferHandle
<
T
extends
JSHandle
<
Node
>
>
(
handle
:
T
)
:
Promise
<
T
>
{
if
(
handle
.
realm
=
=
=
this
)
{
return
handle
;
}
const
transferredHandle
=
await
this
.
evaluateHandle
(
node
=
>
{
return
node
;
}
handle
)
;
await
handle
.
dispose
(
)
;
return
transferredHandle
as
unknown
as
T
;
}
}
