import
mitt
{
type
Emitter
}
from
'
.
.
/
.
.
/
third_party
/
mitt
/
mitt
.
js
'
;
import
{
disposeSymbol
}
from
'
.
.
/
util
/
disposable
.
js
'
;
export
type
EventType
=
string
|
symbol
;
export
type
Handler
<
T
=
unknown
>
=
(
event
:
T
)
=
>
void
;
export
interface
CommonEventEmitter
<
Events
extends
Record
<
EventType
unknown
>
>
{
on
<
Key
extends
keyof
Events
>
(
type
:
Key
handler
:
Handler
<
Events
[
Key
]
>
)
:
this
;
off
<
Key
extends
keyof
Events
>
(
type
:
Key
handler
?
:
Handler
<
Events
[
Key
]
>
)
:
this
;
emit
<
Key
extends
keyof
Events
>
(
type
:
Key
event
:
Events
[
Key
]
)
:
boolean
;
addListener
<
Key
extends
keyof
Events
>
(
type
:
Key
handler
:
Handler
<
Events
[
Key
]
>
)
:
this
;
removeListener
<
Key
extends
keyof
Events
>
(
type
:
Key
handler
:
Handler
<
Events
[
Key
]
>
)
:
this
;
once
<
Key
extends
keyof
Events
>
(
type
:
Key
handler
:
Handler
<
Events
[
Key
]
>
)
:
this
;
listenerCount
(
event
:
keyof
Events
)
:
number
;
removeAllListeners
(
event
?
:
keyof
Events
)
:
this
;
}
export
type
EventsWithWildcard
<
Events
extends
Record
<
EventType
unknown
>
>
=
Events
&
{
'
*
'
:
Events
[
keyof
Events
]
;
}
;
export
class
EventEmitter
<
Events
extends
Record
<
EventType
unknown
>
>
implements
CommonEventEmitter
<
EventsWithWildcard
<
Events
>
>
{
#
emitter
:
Emitter
<
EventsWithWildcard
<
Events
>
>
|
EventEmitter
<
Events
>
;
#
handlers
=
new
Map
<
keyof
Events
|
'
*
'
Array
<
Handler
<
any
>
>
>
(
)
;
constructor
(
emitter
:
Emitter
<
EventsWithWildcard
<
Events
>
>
|
EventEmitter
<
Events
>
=
mitt
(
new
Map
(
)
)
)
{
this
.
#
emitter
=
emitter
;
}
on
<
Key
extends
keyof
EventsWithWildcard
<
Events
>
>
(
type
:
Key
handler
:
Handler
<
EventsWithWildcard
<
Events
>
[
Key
]
>
)
:
this
{
const
handlers
=
this
.
#
handlers
.
get
(
type
)
;
if
(
handlers
=
=
=
undefined
)
{
this
.
#
handlers
.
set
(
type
[
handler
]
)
;
}
else
{
handlers
.
push
(
handler
)
;
}
this
.
#
emitter
.
on
(
type
handler
)
;
return
this
;
}
off
<
Key
extends
keyof
EventsWithWildcard
<
Events
>
>
(
type
:
Key
handler
?
:
Handler
<
EventsWithWildcard
<
Events
>
[
Key
]
>
)
:
this
{
const
handlers
=
this
.
#
handlers
.
get
(
type
)
?
?
[
]
;
if
(
handler
=
=
=
undefined
)
{
for
(
const
handler
of
handlers
)
{
this
.
#
emitter
.
off
(
type
handler
)
;
}
this
.
#
handlers
.
delete
(
type
)
;
return
this
;
}
const
index
=
handlers
.
lastIndexOf
(
handler
)
;
if
(
index
>
-
1
)
{
this
.
#
emitter
.
off
(
type
.
.
.
handlers
.
splice
(
index
1
)
)
;
}
return
this
;
}
emit
<
Key
extends
keyof
EventsWithWildcard
<
Events
>
>
(
type
:
Key
event
:
EventsWithWildcard
<
Events
>
[
Key
]
)
:
boolean
{
this
.
#
emitter
.
emit
(
type
event
)
;
return
this
.
listenerCount
(
type
)
>
0
;
}
removeListener
<
Key
extends
keyof
EventsWithWildcard
<
Events
>
>
(
type
:
Key
handler
:
Handler
<
EventsWithWildcard
<
Events
>
[
Key
]
>
)
:
this
{
return
this
.
off
(
type
handler
)
;
}
addListener
<
Key
extends
keyof
EventsWithWildcard
<
Events
>
>
(
type
:
Key
handler
:
Handler
<
EventsWithWildcard
<
Events
>
[
Key
]
>
)
:
this
{
return
this
.
on
(
type
handler
)
;
}
once
<
Key
extends
keyof
EventsWithWildcard
<
Events
>
>
(
type
:
Key
handler
:
Handler
<
EventsWithWildcard
<
Events
>
[
Key
]
>
)
:
this
{
const
onceHandler
:
Handler
<
EventsWithWildcard
<
Events
>
[
Key
]
>
=
eventData
=
>
{
handler
(
eventData
)
;
this
.
off
(
type
onceHandler
)
;
}
;
return
this
.
on
(
type
onceHandler
)
;
}
listenerCount
(
type
:
keyof
EventsWithWildcard
<
Events
>
)
:
number
{
return
this
.
#
handlers
.
get
(
type
)
?
.
length
|
|
0
;
}
removeAllListeners
(
type
?
:
keyof
EventsWithWildcard
<
Events
>
)
:
this
{
if
(
type
!
=
=
undefined
)
{
return
this
.
off
(
type
)
;
}
this
[
disposeSymbol
]
(
)
;
return
this
;
}
[
disposeSymbol
]
(
)
:
void
{
for
(
const
[
type
handlers
]
of
this
.
#
handlers
)
{
for
(
const
handler
of
handlers
)
{
this
.
#
emitter
.
off
(
type
handler
)
;
}
}
this
.
#
handlers
.
clear
(
)
;
}
}
export
class
EventSubscription
<
Target
extends
CommonEventEmitter
<
Record
<
Type
Event
>
>
Type
extends
EventType
=
EventType
Event
=
unknown
>
{
#
target
:
Target
;
#
type
:
Type
;
#
handler
:
Handler
<
Event
>
;
constructor
(
target
:
Target
type
:
Type
handler
:
Handler
<
Event
>
)
{
this
.
#
target
=
target
;
this
.
#
type
=
type
;
this
.
#
handler
=
handler
;
this
.
#
target
.
on
(
this
.
#
type
this
.
#
handler
)
;
}
[
disposeSymbol
]
(
)
:
void
{
this
.
#
target
.
off
(
this
.
#
type
this
.
#
handler
)
;
}
}
