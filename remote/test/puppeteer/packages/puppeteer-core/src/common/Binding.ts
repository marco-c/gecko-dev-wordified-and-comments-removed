import
{
JSHandle
}
from
'
.
.
/
api
/
JSHandle
.
js
'
;
import
{
isErrorLike
}
from
'
.
.
/
util
/
ErrorLike
.
js
'
;
import
{
ExecutionContext
}
from
'
.
/
ExecutionContext
.
js
'
;
import
{
debugError
}
from
'
.
/
util
.
js
'
;
export
class
Binding
{
#
name
:
string
;
#
fn
:
(
.
.
.
args
:
unknown
[
]
)
=
>
unknown
;
constructor
(
name
:
string
fn
:
(
.
.
.
args
:
unknown
[
]
)
=
>
unknown
)
{
this
.
#
name
=
name
;
this
.
#
fn
=
fn
;
}
get
name
(
)
:
string
{
return
this
.
#
name
;
}
async
run
(
context
:
ExecutionContext
id
:
number
args
:
unknown
[
]
isTrivial
:
boolean
)
:
Promise
<
void
>
{
const
garbage
=
[
]
;
try
{
if
(
!
isTrivial
)
{
const
handles
=
await
context
.
evaluateHandle
(
(
name
seq
)
=
>
{
return
globalThis
[
name
]
.
args
.
get
(
seq
)
;
}
this
.
#
name
id
)
;
try
{
const
properties
=
await
handles
.
getProperties
(
)
;
for
(
const
[
index
handle
]
of
properties
)
{
if
(
index
in
args
)
{
switch
(
handle
.
remoteObject
(
)
.
subtype
)
{
case
'
node
'
:
args
[
+
index
]
=
handle
;
break
;
default
:
garbage
.
push
(
handle
.
dispose
(
)
)
;
}
}
else
{
garbage
.
push
(
handle
.
dispose
(
)
)
;
}
}
}
finally
{
await
handles
.
dispose
(
)
;
}
}
await
context
.
evaluate
(
(
name
seq
result
)
=
>
{
const
callbacks
=
globalThis
[
name
]
.
callbacks
;
callbacks
.
get
(
seq
)
.
resolve
(
result
)
;
callbacks
.
delete
(
seq
)
;
}
this
.
#
name
id
await
this
.
#
fn
(
.
.
.
args
)
)
;
for
(
const
arg
of
args
)
{
if
(
arg
instanceof
JSHandle
)
{
garbage
.
push
(
arg
.
dispose
(
)
)
;
}
}
}
catch
(
error
)
{
if
(
isErrorLike
(
error
)
)
{
await
context
.
evaluate
(
(
name
seq
message
stack
)
=
>
{
const
error
=
new
Error
(
message
)
;
error
.
stack
=
stack
;
const
callbacks
=
globalThis
[
name
]
.
callbacks
;
callbacks
.
get
(
seq
)
.
reject
(
error
)
;
callbacks
.
delete
(
seq
)
;
}
this
.
#
name
id
error
.
message
error
.
stack
)
.
catch
(
debugError
)
;
}
else
{
await
context
.
evaluate
(
(
name
seq
error
)
=
>
{
const
callbacks
=
globalThis
[
name
]
.
callbacks
;
callbacks
.
get
(
seq
)
.
reject
(
error
)
;
callbacks
.
delete
(
seq
)
;
}
this
.
#
name
id
error
)
.
catch
(
debugError
)
;
}
}
finally
{
await
Promise
.
all
(
garbage
)
;
}
}
}
