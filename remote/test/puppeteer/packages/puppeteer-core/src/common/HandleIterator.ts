import
{
JSHandle
}
from
'
.
.
/
api
/
JSHandle
.
js
'
;
import
{
AwaitableIterable
HandleFor
}
from
'
.
/
types
.
js
'
;
const
DEFAULT_BATCH_SIZE
=
20
;
async
function
*
fastTransposeIteratorHandle
<
T
>
(
iterator
:
JSHandle
<
AwaitableIterator
<
T
>
>
size
:
number
)
{
using
array
=
await
iterator
.
evaluateHandle
(
async
(
iterator
size
)
=
>
{
const
results
=
[
]
;
while
(
results
.
length
<
size
)
{
const
result
=
await
iterator
.
next
(
)
;
if
(
result
.
done
)
{
break
;
}
results
.
push
(
result
.
value
)
;
}
return
results
;
}
size
)
;
const
properties
=
(
await
array
.
getProperties
(
)
)
as
Map
<
string
HandleFor
<
T
>
>
;
const
handles
=
properties
.
values
(
)
;
using
stack
=
new
DisposableStack
(
)
;
stack
.
defer
(
(
)
=
>
{
for
(
using
handle
of
handles
)
{
handle
[
Symbol
.
dispose
]
(
)
;
}
}
)
;
yield
*
handles
;
return
properties
.
size
=
=
=
0
;
}
async
function
*
transposeIteratorHandle
<
T
>
(
iterator
:
JSHandle
<
AwaitableIterator
<
T
>
>
)
{
let
size
=
DEFAULT_BATCH_SIZE
;
while
(
!
(
yield
*
fastTransposeIteratorHandle
(
iterator
size
)
)
)
{
size
<
<
=
1
;
}
}
type
AwaitableIterator
<
T
>
=
Iterator
<
T
>
|
AsyncIterator
<
T
>
;
export
async
function
*
transposeIterableHandle
<
T
>
(
handle
:
JSHandle
<
AwaitableIterable
<
T
>
>
)
:
AsyncIterableIterator
<
HandleFor
<
T
>
>
{
using
generatorHandle
=
await
handle
.
evaluateHandle
(
iterable
=
>
{
return
(
async
function
*
(
)
{
yield
*
iterable
;
}
)
(
)
;
}
)
;
yield
*
transposeIteratorHandle
(
generatorHandle
)
;
}
