import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
TargetFilterCallback
}
from
'
.
.
/
api
/
Browser
.
js
'
;
import
{
TargetType
}
from
'
.
.
/
api
/
Target
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
Deferred
}
from
'
.
.
/
util
/
Deferred
.
js
'
;
import
{
CDPSession
CDPSessionEmittedEvents
Connection
}
from
'
.
/
Connection
.
js
'
;
import
{
EventEmitter
}
from
'
.
/
EventEmitter
.
js
'
;
import
{
InitializationStatus
CDPTarget
}
from
'
.
/
Target
.
js
'
;
import
{
TargetFactory
TargetManager
TargetManagerEmittedEvents
}
from
'
.
/
TargetManager
.
js
'
;
import
{
debugError
}
from
'
.
/
util
.
js
'
;
function
isTargetExposed
(
target
:
CDPTarget
)
:
boolean
{
return
target
.
type
(
)
!
=
=
TargetType
.
TAB
&
&
!
target
.
_subtype
(
)
;
}
function
isPageTargetBecomingPrimary
(
target
:
CDPTarget
newTargetInfo
:
Protocol
.
Target
.
TargetInfo
)
:
boolean
{
return
Boolean
(
target
.
_subtype
(
)
)
&
&
!
newTargetInfo
.
subtype
;
}
export
class
ChromeTargetManager
extends
EventEmitter
implements
TargetManager
{
#
connection
:
Connection
;
#
discoveredTargetsByTargetId
=
new
Map
<
string
Protocol
.
Target
.
TargetInfo
>
(
)
;
#
attachedTargetsByTargetId
=
new
Map
<
string
CDPTarget
>
(
)
;
#
attachedTargetsBySessionId
=
new
Map
<
string
CDPTarget
>
(
)
;
#
ignoredTargets
=
new
Set
<
string
>
(
)
;
#
targetFilterCallback
:
TargetFilterCallback
|
undefined
;
#
targetFactory
:
TargetFactory
;
#
attachedToTargetListenersBySession
=
new
WeakMap
<
CDPSession
|
Connection
(
event
:
Protocol
.
Target
.
AttachedToTargetEvent
)
=
>
Promise
<
void
>
>
(
)
;
#
detachedFromTargetListenersBySession
=
new
WeakMap
<
CDPSession
|
Connection
(
event
:
Protocol
.
Target
.
DetachedFromTargetEvent
)
=
>
void
>
(
)
;
#
initializeDeferred
=
Deferred
.
create
<
void
>
(
)
;
#
targetsIdsForInit
=
new
Set
<
string
>
(
)
;
#
waitForInitiallyDiscoveredTargets
=
true
;
#
tabMode
:
boolean
;
#
discoveryFilter
:
Protocol
.
Target
.
FilterEntry
[
]
;
constructor
(
connection
:
Connection
targetFactory
:
TargetFactory
targetFilterCallback
?
:
TargetFilterCallback
waitForInitiallyDiscoveredTargets
=
true
useTabTarget
=
false
)
{
super
(
)
;
this
.
#
tabMode
=
useTabTarget
;
this
.
#
discoveryFilter
=
this
.
#
tabMode
?
[
{
}
]
:
[
{
type
:
'
tab
'
exclude
:
true
}
{
}
]
;
this
.
#
connection
=
connection
;
this
.
#
targetFilterCallback
=
targetFilterCallback
;
this
.
#
targetFactory
=
targetFactory
;
this
.
#
waitForInitiallyDiscoveredTargets
=
waitForInitiallyDiscoveredTargets
;
this
.
#
connection
.
on
(
'
Target
.
targetCreated
'
this
.
#
onTargetCreated
)
;
this
.
#
connection
.
on
(
'
Target
.
targetDestroyed
'
this
.
#
onTargetDestroyed
)
;
this
.
#
connection
.
on
(
'
Target
.
targetInfoChanged
'
this
.
#
onTargetInfoChanged
)
;
this
.
#
connection
.
on
(
'
sessiondetached
'
this
.
#
onSessionDetached
)
;
this
.
#
setupAttachmentListeners
(
this
.
#
connection
)
;
this
.
#
connection
.
send
(
'
Target
.
setDiscoverTargets
'
{
discover
:
true
filter
:
this
.
#
discoveryFilter
}
)
.
then
(
this
.
#
storeExistingTargetsForInit
)
.
catch
(
debugError
)
;
}
#
storeExistingTargetsForInit
=
(
)
=
>
{
if
(
!
this
.
#
waitForInitiallyDiscoveredTargets
)
{
return
;
}
for
(
const
[
targetId
targetInfo
]
of
this
.
#
discoveredTargetsByTargetId
.
entries
(
)
)
{
const
targetForFilter
=
new
CDPTarget
(
targetInfo
undefined
undefined
this
undefined
)
;
if
(
(
!
this
.
#
targetFilterCallback
|
|
this
.
#
targetFilterCallback
(
targetForFilter
)
)
&
&
targetInfo
.
type
!
=
=
'
browser
'
)
{
this
.
#
targetsIdsForInit
.
add
(
targetId
)
;
}
}
}
;
async
initialize
(
)
:
Promise
<
void
>
{
await
this
.
#
connection
.
send
(
'
Target
.
setAutoAttach
'
{
waitForDebuggerOnStart
:
true
flatten
:
true
autoAttach
:
true
filter
:
this
.
#
tabMode
?
[
{
type
:
'
page
'
exclude
:
true
}
.
.
.
this
.
#
discoveryFilter
]
:
this
.
#
discoveryFilter
}
)
;
this
.
#
finishInitializationIfReady
(
)
;
await
this
.
#
initializeDeferred
.
valueOrThrow
(
)
;
}
dispose
(
)
:
void
{
this
.
#
connection
.
off
(
'
Target
.
targetCreated
'
this
.
#
onTargetCreated
)
;
this
.
#
connection
.
off
(
'
Target
.
targetDestroyed
'
this
.
#
onTargetDestroyed
)
;
this
.
#
connection
.
off
(
'
Target
.
targetInfoChanged
'
this
.
#
onTargetInfoChanged
)
;
this
.
#
connection
.
off
(
'
sessiondetached
'
this
.
#
onSessionDetached
)
;
this
.
#
removeAttachmentListeners
(
this
.
#
connection
)
;
}
getAvailableTargets
(
)
:
Map
<
string
CDPTarget
>
{
const
result
=
new
Map
<
string
CDPTarget
>
(
)
;
for
(
const
[
id
target
]
of
this
.
#
attachedTargetsByTargetId
.
entries
(
)
)
{
if
(
isTargetExposed
(
target
)
)
{
result
.
set
(
id
target
)
;
}
}
return
result
;
}
#
setupAttachmentListeners
(
session
:
CDPSession
|
Connection
)
:
void
{
const
listener
=
(
event
:
Protocol
.
Target
.
AttachedToTargetEvent
)
=
>
{
return
this
.
#
onAttachedToTarget
(
session
event
)
;
}
;
assert
(
!
this
.
#
attachedToTargetListenersBySession
.
has
(
session
)
)
;
this
.
#
attachedToTargetListenersBySession
.
set
(
session
listener
)
;
session
.
on
(
'
Target
.
attachedToTarget
'
listener
)
;
const
detachedListener
=
(
event
:
Protocol
.
Target
.
DetachedFromTargetEvent
)
=
>
{
return
this
.
#
onDetachedFromTarget
(
session
event
)
;
}
;
assert
(
!
this
.
#
detachedFromTargetListenersBySession
.
has
(
session
)
)
;
this
.
#
detachedFromTargetListenersBySession
.
set
(
session
detachedListener
)
;
session
.
on
(
'
Target
.
detachedFromTarget
'
detachedListener
)
;
}
#
removeAttachmentListeners
(
session
:
CDPSession
|
Connection
)
:
void
{
if
(
this
.
#
attachedToTargetListenersBySession
.
has
(
session
)
)
{
session
.
off
(
'
Target
.
attachedToTarget
'
this
.
#
attachedToTargetListenersBySession
.
get
(
session
)
!
)
;
this
.
#
attachedToTargetListenersBySession
.
delete
(
session
)
;
}
if
(
this
.
#
detachedFromTargetListenersBySession
.
has
(
session
)
)
{
session
.
off
(
'
Target
.
detachedFromTarget
'
this
.
#
detachedFromTargetListenersBySession
.
get
(
session
)
!
)
;
this
.
#
detachedFromTargetListenersBySession
.
delete
(
session
)
;
}
}
#
onSessionDetached
=
(
session
:
CDPSession
)
=
>
{
this
.
#
removeAttachmentListeners
(
session
)
;
}
;
#
onTargetCreated
=
async
(
event
:
Protocol
.
Target
.
TargetCreatedEvent
)
=
>
{
this
.
#
discoveredTargetsByTargetId
.
set
(
event
.
targetInfo
.
targetId
event
.
targetInfo
)
;
this
.
emit
(
TargetManagerEmittedEvents
.
TargetDiscovered
event
.
targetInfo
)
;
if
(
event
.
targetInfo
.
type
=
=
=
'
browser
'
&
&
event
.
targetInfo
.
attached
)
{
if
(
this
.
#
attachedTargetsByTargetId
.
has
(
event
.
targetInfo
.
targetId
)
)
{
return
;
}
const
target
=
this
.
#
targetFactory
(
event
.
targetInfo
undefined
)
;
target
.
_initialize
(
)
;
this
.
#
attachedTargetsByTargetId
.
set
(
event
.
targetInfo
.
targetId
target
)
;
}
}
;
#
onTargetDestroyed
=
(
event
:
Protocol
.
Target
.
TargetDestroyedEvent
)
=
>
{
const
targetInfo
=
this
.
#
discoveredTargetsByTargetId
.
get
(
event
.
targetId
)
;
this
.
#
discoveredTargetsByTargetId
.
delete
(
event
.
targetId
)
;
this
.
#
finishInitializationIfReady
(
event
.
targetId
)
;
if
(
targetInfo
?
.
type
=
=
=
'
service_worker
'
&
&
this
.
#
attachedTargetsByTargetId
.
has
(
event
.
targetId
)
)
{
const
target
=
this
.
#
attachedTargetsByTargetId
.
get
(
event
.
targetId
)
;
this
.
emit
(
TargetManagerEmittedEvents
.
TargetGone
target
)
;
this
.
#
attachedTargetsByTargetId
.
delete
(
event
.
targetId
)
;
}
}
;
#
onTargetInfoChanged
=
(
event
:
Protocol
.
Target
.
TargetInfoChangedEvent
)
=
>
{
this
.
#
discoveredTargetsByTargetId
.
set
(
event
.
targetInfo
.
targetId
event
.
targetInfo
)
;
if
(
this
.
#
ignoredTargets
.
has
(
event
.
targetInfo
.
targetId
)
|
|
!
this
.
#
attachedTargetsByTargetId
.
has
(
event
.
targetInfo
.
targetId
)
|
|
!
event
.
targetInfo
.
attached
)
{
return
;
}
const
target
=
this
.
#
attachedTargetsByTargetId
.
get
(
event
.
targetInfo
.
targetId
)
;
if
(
!
target
)
{
return
;
}
const
previousURL
=
target
.
url
(
)
;
const
wasInitialized
=
target
.
_initializedDeferred
.
value
(
)
=
=
=
InitializationStatus
.
SUCCESS
;
if
(
isPageTargetBecomingPrimary
(
target
event
.
targetInfo
)
)
{
const
target
=
this
.
#
attachedTargetsByTargetId
.
get
(
event
.
targetInfo
.
targetId
)
;
const
session
=
target
?
.
_session
(
)
;
assert
(
session
'
Target
that
is
being
activated
is
missing
a
CDPSession
.
'
)
;
session
.
parentSession
(
)
?
.
emit
(
CDPSessionEmittedEvents
.
Swapped
session
)
;
}
target
.
_targetInfoChanged
(
event
.
targetInfo
)
;
if
(
wasInitialized
&
&
previousURL
!
=
=
target
.
url
(
)
)
{
this
.
emit
(
TargetManagerEmittedEvents
.
TargetChanged
{
target
:
target
wasInitialized
previousURL
}
)
;
}
}
;
#
onAttachedToTarget
=
async
(
parentSession
:
Connection
|
CDPSession
event
:
Protocol
.
Target
.
AttachedToTargetEvent
)
=
>
{
const
targetInfo
=
event
.
targetInfo
;
const
session
=
this
.
#
connection
.
session
(
event
.
sessionId
)
;
if
(
!
session
)
{
throw
new
Error
(
Session
{
event
.
sessionId
}
was
not
created
.
)
;
}
const
silentDetach
=
async
(
)
=
>
{
await
session
.
send
(
'
Runtime
.
runIfWaitingForDebugger
'
)
.
catch
(
debugError
)
;
await
parentSession
.
send
(
'
Target
.
detachFromTarget
'
{
sessionId
:
session
.
id
(
)
}
)
.
catch
(
debugError
)
;
}
;
if
(
!
this
.
#
connection
.
isAutoAttached
(
targetInfo
.
targetId
)
)
{
return
;
}
if
(
targetInfo
.
type
=
=
=
'
service_worker
'
&
&
this
.
#
connection
.
isAutoAttached
(
targetInfo
.
targetId
)
)
{
this
.
#
finishInitializationIfReady
(
targetInfo
.
targetId
)
;
await
silentDetach
(
)
;
if
(
this
.
#
attachedTargetsByTargetId
.
has
(
targetInfo
.
targetId
)
)
{
return
;
}
const
target
=
this
.
#
targetFactory
(
targetInfo
)
;
target
.
_initialize
(
)
;
this
.
#
attachedTargetsByTargetId
.
set
(
targetInfo
.
targetId
target
)
;
this
.
emit
(
TargetManagerEmittedEvents
.
TargetAvailable
target
)
;
return
;
}
const
isExistingTarget
=
this
.
#
attachedTargetsByTargetId
.
has
(
targetInfo
.
targetId
)
;
const
target
=
isExistingTarget
?
this
.
#
attachedTargetsByTargetId
.
get
(
targetInfo
.
targetId
)
!
:
this
.
#
targetFactory
(
targetInfo
session
parentSession
instanceof
CDPSession
?
parentSession
:
undefined
)
;
if
(
this
.
#
targetFilterCallback
&
&
!
this
.
#
targetFilterCallback
(
target
)
)
{
this
.
#
ignoredTargets
.
add
(
targetInfo
.
targetId
)
;
this
.
#
finishInitializationIfReady
(
targetInfo
.
targetId
)
;
await
silentDetach
(
)
;
return
;
}
if
(
!
isExistingTarget
)
{
target
.
_initialize
(
)
;
}
this
.
#
setupAttachmentListeners
(
session
)
;
if
(
isExistingTarget
)
{
this
.
#
attachedTargetsBySessionId
.
set
(
session
.
id
(
)
this
.
#
attachedTargetsByTargetId
.
get
(
targetInfo
.
targetId
)
!
)
;
}
else
{
this
.
#
attachedTargetsByTargetId
.
set
(
targetInfo
.
targetId
target
)
;
this
.
#
attachedTargetsBySessionId
.
set
(
session
.
id
(
)
target
)
;
}
parentSession
.
emit
(
CDPSessionEmittedEvents
.
Ready
session
)
;
this
.
#
targetsIdsForInit
.
delete
(
target
.
_targetId
)
;
if
(
!
isExistingTarget
&
&
isTargetExposed
(
target
)
)
{
this
.
emit
(
TargetManagerEmittedEvents
.
TargetAvailable
target
)
;
}
this
.
#
finishInitializationIfReady
(
)
;
await
Promise
.
all
(
[
session
.
send
(
'
Target
.
setAutoAttach
'
{
waitForDebuggerOnStart
:
true
flatten
:
true
autoAttach
:
true
filter
:
this
.
#
discoveryFilter
}
)
session
.
send
(
'
Runtime
.
runIfWaitingForDebugger
'
)
]
)
.
catch
(
debugError
)
;
}
;
#
finishInitializationIfReady
(
targetId
?
:
string
)
:
void
{
targetId
!
=
=
undefined
&
&
this
.
#
targetsIdsForInit
.
delete
(
targetId
)
;
if
(
this
.
#
targetsIdsForInit
.
size
=
=
=
0
)
{
this
.
#
initializeDeferred
.
resolve
(
)
;
}
}
#
onDetachedFromTarget
=
(
_parentSession
:
Connection
|
CDPSession
event
:
Protocol
.
Target
.
DetachedFromTargetEvent
)
=
>
{
const
target
=
this
.
#
attachedTargetsBySessionId
.
get
(
event
.
sessionId
)
;
this
.
#
attachedTargetsBySessionId
.
delete
(
event
.
sessionId
)
;
if
(
!
target
)
{
return
;
}
this
.
#
attachedTargetsByTargetId
.
delete
(
target
.
_targetId
)
;
if
(
isTargetExposed
(
target
)
)
{
this
.
emit
(
TargetManagerEmittedEvents
.
TargetGone
target
)
;
}
}
;
}
