import
{
ChildProcess
}
from
'
child_process
'
;
import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
Browser
as
BrowserBase
BrowserCloseCallback
TargetFilterCallback
IsPageTargetCallback
BrowserEmittedEvents
BrowserContextEmittedEvents
BrowserContextOptions
WEB_PERMISSION_TO_PROTOCOL_PERMISSION
Permission
}
from
'
.
.
/
api
/
Browser
.
js
'
;
import
{
BrowserContext
}
from
'
.
.
/
api
/
BrowserContext
.
js
'
;
import
{
Page
}
from
'
.
.
/
api
/
Page
.
js
'
;
import
{
Target
}
from
'
.
.
/
api
/
Target
.
js
'
;
import
{
USE_TAB_TARGET
}
from
'
.
.
/
environment
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
ChromeTargetManager
}
from
'
.
/
ChromeTargetManager
.
js
'
;
import
{
CDPSession
Connection
ConnectionEmittedEvents
}
from
'
.
/
Connection
.
js
'
;
import
{
FirefoxTargetManager
}
from
'
.
/
FirefoxTargetManager
.
js
'
;
import
{
Viewport
}
from
'
.
/
PuppeteerViewport
.
js
'
;
import
{
InitializationStatus
OtherTarget
PageTarget
CDPTarget
WorkerTarget
DevToolsTarget
}
from
'
.
/
Target
.
js
'
;
import
{
TargetManager
TargetManagerEmittedEvents
}
from
'
.
/
TargetManager
.
js
'
;
import
{
TaskQueue
}
from
'
.
/
TaskQueue
.
js
'
;
export
class
CDPBrowser
extends
BrowserBase
{
static
async
_create
(
product
:
'
firefox
'
|
'
chrome
'
|
undefined
connection
:
Connection
contextIds
:
string
[
]
ignoreHTTPSErrors
:
boolean
defaultViewport
?
:
Viewport
|
null
process
?
:
ChildProcess
closeCallback
?
:
BrowserCloseCallback
targetFilterCallback
?
:
TargetFilterCallback
isPageTargetCallback
?
:
IsPageTargetCallback
waitForInitiallyDiscoveredTargets
=
true
useTabTarget
=
USE_TAB_TARGET
)
:
Promise
<
CDPBrowser
>
{
const
browser
=
new
CDPBrowser
(
product
connection
contextIds
ignoreHTTPSErrors
defaultViewport
process
closeCallback
targetFilterCallback
isPageTargetCallback
waitForInitiallyDiscoveredTargets
useTabTarget
)
;
await
browser
.
_attach
(
)
;
return
browser
;
}
#
ignoreHTTPSErrors
:
boolean
;
#
defaultViewport
?
:
Viewport
|
null
;
#
process
?
:
ChildProcess
;
#
connection
:
Connection
;
#
closeCallback
:
BrowserCloseCallback
;
#
targetFilterCallback
:
TargetFilterCallback
;
#
isPageTargetCallback
!
:
IsPageTargetCallback
;
#
defaultContext
:
CDPBrowserContext
;
#
contexts
=
new
Map
<
string
CDPBrowserContext
>
(
)
;
#
screenshotTaskQueue
:
TaskQueue
;
#
targetManager
:
TargetManager
;
override
get
_targets
(
)
:
Map
<
string
CDPTarget
>
{
return
this
.
#
targetManager
.
getAvailableTargets
(
)
;
}
constructor
(
product
:
'
chrome
'
|
'
firefox
'
|
undefined
connection
:
Connection
contextIds
:
string
[
]
ignoreHTTPSErrors
:
boolean
defaultViewport
?
:
Viewport
|
null
process
?
:
ChildProcess
closeCallback
?
:
BrowserCloseCallback
targetFilterCallback
?
:
TargetFilterCallback
isPageTargetCallback
?
:
IsPageTargetCallback
waitForInitiallyDiscoveredTargets
=
true
useTabTarget
=
USE_TAB_TARGET
)
{
super
(
)
;
product
=
product
|
|
'
chrome
'
;
this
.
#
ignoreHTTPSErrors
=
ignoreHTTPSErrors
;
this
.
#
defaultViewport
=
defaultViewport
;
this
.
#
process
=
process
;
this
.
#
screenshotTaskQueue
=
new
TaskQueue
(
)
;
this
.
#
connection
=
connection
;
this
.
#
closeCallback
=
closeCallback
|
|
function
(
)
:
void
{
}
;
this
.
#
targetFilterCallback
=
targetFilterCallback
|
|
(
(
)
:
boolean
=
>
{
return
true
;
}
)
;
this
.
#
setIsPageTargetCallback
(
isPageTargetCallback
)
;
if
(
product
=
=
=
'
firefox
'
)
{
this
.
#
targetManager
=
new
FirefoxTargetManager
(
connection
this
.
#
createTarget
this
.
#
targetFilterCallback
)
;
}
else
{
this
.
#
targetManager
=
new
ChromeTargetManager
(
connection
this
.
#
createTarget
this
.
#
targetFilterCallback
waitForInitiallyDiscoveredTargets
useTabTarget
)
;
}
this
.
#
defaultContext
=
new
CDPBrowserContext
(
this
.
#
connection
this
)
;
for
(
const
contextId
of
contextIds
)
{
this
.
#
contexts
.
set
(
contextId
new
CDPBrowserContext
(
this
.
#
connection
this
contextId
)
)
;
}
}
#
emitDisconnected
=
(
)
=
>
{
this
.
emit
(
BrowserEmittedEvents
.
Disconnected
)
;
}
;
override
async
_attach
(
)
:
Promise
<
void
>
{
this
.
#
connection
.
on
(
ConnectionEmittedEvents
.
Disconnected
this
.
#
emitDisconnected
)
;
this
.
#
targetManager
.
on
(
TargetManagerEmittedEvents
.
TargetAvailable
this
.
#
onAttachedToTarget
)
;
this
.
#
targetManager
.
on
(
TargetManagerEmittedEvents
.
TargetGone
this
.
#
onDetachedFromTarget
)
;
this
.
#
targetManager
.
on
(
TargetManagerEmittedEvents
.
TargetChanged
this
.
#
onTargetChanged
)
;
this
.
#
targetManager
.
on
(
TargetManagerEmittedEvents
.
TargetDiscovered
this
.
#
onTargetDiscovered
)
;
await
this
.
#
targetManager
.
initialize
(
)
;
}
override
_detach
(
)
:
void
{
this
.
#
connection
.
off
(
ConnectionEmittedEvents
.
Disconnected
this
.
#
emitDisconnected
)
;
this
.
#
targetManager
.
off
(
TargetManagerEmittedEvents
.
TargetAvailable
this
.
#
onAttachedToTarget
)
;
this
.
#
targetManager
.
off
(
TargetManagerEmittedEvents
.
TargetGone
this
.
#
onDetachedFromTarget
)
;
this
.
#
targetManager
.
off
(
TargetManagerEmittedEvents
.
TargetChanged
this
.
#
onTargetChanged
)
;
this
.
#
targetManager
.
off
(
TargetManagerEmittedEvents
.
TargetDiscovered
this
.
#
onTargetDiscovered
)
;
}
override
process
(
)
:
ChildProcess
|
null
{
return
this
.
#
process
?
?
null
;
}
_targetManager
(
)
:
TargetManager
{
return
this
.
#
targetManager
;
}
#
setIsPageTargetCallback
(
isPageTargetCallback
?
:
IsPageTargetCallback
)
:
void
{
this
.
#
isPageTargetCallback
=
isPageTargetCallback
|
|
(
(
target
:
Target
)
:
boolean
=
>
{
return
(
target
.
type
(
)
=
=
=
'
page
'
|
|
target
.
type
(
)
=
=
=
'
background_page
'
|
|
target
.
type
(
)
=
=
=
'
webview
'
)
;
}
)
;
}
override
_getIsPageTargetCallback
(
)
:
IsPageTargetCallback
|
undefined
{
return
this
.
#
isPageTargetCallback
;
}
override
async
createIncognitoBrowserContext
(
options
:
BrowserContextOptions
=
{
}
)
:
Promise
<
CDPBrowserContext
>
{
const
{
proxyServer
proxyBypassList
}
=
options
;
const
{
browserContextId
}
=
await
this
.
#
connection
.
send
(
'
Target
.
createBrowserContext
'
{
proxyServer
proxyBypassList
:
proxyBypassList
&
&
proxyBypassList
.
join
(
'
'
)
}
)
;
const
context
=
new
CDPBrowserContext
(
this
.
#
connection
this
browserContextId
)
;
this
.
#
contexts
.
set
(
browserContextId
context
)
;
return
context
;
}
override
browserContexts
(
)
:
CDPBrowserContext
[
]
{
return
[
this
.
#
defaultContext
.
.
.
Array
.
from
(
this
.
#
contexts
.
values
(
)
)
]
;
}
override
defaultBrowserContext
(
)
:
CDPBrowserContext
{
return
this
.
#
defaultContext
;
}
override
async
_disposeContext
(
contextId
?
:
string
)
:
Promise
<
void
>
{
if
(
!
contextId
)
{
return
;
}
await
this
.
#
connection
.
send
(
'
Target
.
disposeBrowserContext
'
{
browserContextId
:
contextId
}
)
;
this
.
#
contexts
.
delete
(
contextId
)
;
}
#
createTarget
=
(
targetInfo
:
Protocol
.
Target
.
TargetInfo
session
?
:
CDPSession
)
=
>
{
const
{
browserContextId
}
=
targetInfo
;
const
context
=
browserContextId
&
&
this
.
#
contexts
.
has
(
browserContextId
)
?
this
.
#
contexts
.
get
(
browserContextId
)
:
this
.
#
defaultContext
;
if
(
!
context
)
{
throw
new
Error
(
'
Missing
browser
context
'
)
;
}
const
createSession
=
(
isAutoAttachEmulated
:
boolean
)
=
>
{
return
this
.
#
connection
.
_createSession
(
targetInfo
isAutoAttachEmulated
)
;
}
;
const
targetForFilter
=
new
OtherTarget
(
targetInfo
session
context
this
.
#
targetManager
createSession
)
;
if
(
targetInfo
.
url
?
.
startsWith
(
'
devtools
:
/
/
'
)
)
{
return
new
DevToolsTarget
(
targetInfo
session
context
this
.
#
targetManager
createSession
this
.
#
ignoreHTTPSErrors
this
.
#
defaultViewport
?
?
null
this
.
#
screenshotTaskQueue
)
;
}
if
(
this
.
#
isPageTargetCallback
(
targetForFilter
)
)
{
return
new
PageTarget
(
targetInfo
session
context
this
.
#
targetManager
createSession
this
.
#
ignoreHTTPSErrors
this
.
#
defaultViewport
?
?
null
this
.
#
screenshotTaskQueue
)
;
}
if
(
targetInfo
.
type
=
=
=
'
service_worker
'
|
|
targetInfo
.
type
=
=
=
'
shared_worker
'
)
{
return
new
WorkerTarget
(
targetInfo
session
context
this
.
#
targetManager
createSession
)
;
}
return
new
OtherTarget
(
targetInfo
session
context
this
.
#
targetManager
createSession
)
;
}
;
#
onAttachedToTarget
=
async
(
target
:
CDPTarget
)
=
>
{
if
(
(
await
target
.
_initializedDeferred
.
valueOrThrow
(
)
)
=
=
=
InitializationStatus
.
SUCCESS
)
{
this
.
emit
(
BrowserEmittedEvents
.
TargetCreated
target
)
;
target
.
browserContext
(
)
.
emit
(
BrowserContextEmittedEvents
.
TargetCreated
target
)
;
}
}
;
#
onDetachedFromTarget
=
async
(
target
:
CDPTarget
)
:
Promise
<
void
>
=
>
{
target
.
_initializedDeferred
.
resolve
(
InitializationStatus
.
ABORTED
)
;
target
.
_isClosedDeferred
.
resolve
(
)
;
if
(
(
await
target
.
_initializedDeferred
.
valueOrThrow
(
)
)
=
=
=
InitializationStatus
.
SUCCESS
)
{
this
.
emit
(
BrowserEmittedEvents
.
TargetDestroyed
target
)
;
target
.
browserContext
(
)
.
emit
(
BrowserContextEmittedEvents
.
TargetDestroyed
target
)
;
}
}
;
#
onTargetChanged
=
(
{
target
}
:
{
target
:
CDPTarget
}
)
:
void
=
>
{
this
.
emit
(
BrowserEmittedEvents
.
TargetChanged
target
)
;
target
.
browserContext
(
)
.
emit
(
BrowserContextEmittedEvents
.
TargetChanged
target
)
;
}
;
#
onTargetDiscovered
=
(
targetInfo
:
Protocol
.
Target
.
TargetInfo
)
:
void
=
>
{
this
.
emit
(
'
targetdiscovered
'
targetInfo
)
;
}
;
override
wsEndpoint
(
)
:
string
{
return
this
.
#
connection
.
url
(
)
;
}
override
async
newPage
(
)
:
Promise
<
Page
>
{
return
await
this
.
#
defaultContext
.
newPage
(
)
;
}
override
async
_createPageInContext
(
contextId
?
:
string
)
:
Promise
<
Page
>
{
const
{
targetId
}
=
await
this
.
#
connection
.
send
(
'
Target
.
createTarget
'
{
url
:
'
about
:
blank
'
browserContextId
:
contextId
|
|
undefined
}
)
;
const
target
=
(
await
this
.
waitForTarget
(
t
=
>
{
return
(
t
as
CDPTarget
)
.
_targetId
=
=
=
targetId
;
}
)
)
as
CDPTarget
;
if
(
!
target
)
{
throw
new
Error
(
Missing
target
for
page
(
id
=
{
targetId
}
)
)
;
}
const
initialized
=
(
await
target
.
_initializedDeferred
.
valueOrThrow
(
)
)
=
=
=
InitializationStatus
.
SUCCESS
;
if
(
!
initialized
)
{
throw
new
Error
(
Failed
to
create
target
for
page
(
id
=
{
targetId
}
)
)
;
}
const
page
=
await
target
.
page
(
)
;
if
(
!
page
)
{
throw
new
Error
(
Failed
to
create
a
page
for
context
(
id
=
{
contextId
}
)
)
;
}
return
page
;
}
override
targets
(
)
:
CDPTarget
[
]
{
return
Array
.
from
(
this
.
#
targetManager
.
getAvailableTargets
(
)
.
values
(
)
)
.
filter
(
target
=
>
{
return
(
target
.
_initializedDeferred
.
value
(
)
=
=
=
InitializationStatus
.
SUCCESS
)
;
}
)
;
}
override
target
(
)
:
CDPTarget
{
const
browserTarget
=
this
.
targets
(
)
.
find
(
target
=
>
{
return
target
.
type
(
)
=
=
=
'
browser
'
;
}
)
;
if
(
!
browserTarget
)
{
throw
new
Error
(
'
Browser
target
is
not
found
'
)
;
}
return
browserTarget
;
}
override
async
version
(
)
:
Promise
<
string
>
{
const
version
=
await
this
.
#
getVersion
(
)
;
return
version
.
product
;
}
override
async
userAgent
(
)
:
Promise
<
string
>
{
const
version
=
await
this
.
#
getVersion
(
)
;
return
version
.
userAgent
;
}
override
async
close
(
)
:
Promise
<
void
>
{
await
this
.
#
closeCallback
.
call
(
null
)
;
this
.
disconnect
(
)
;
}
override
disconnect
(
)
:
void
{
this
.
#
targetManager
.
dispose
(
)
;
this
.
#
connection
.
dispose
(
)
;
this
.
_detach
(
)
;
}
override
isConnected
(
)
:
boolean
{
return
!
this
.
#
connection
.
_closed
;
}
#
getVersion
(
)
:
Promise
<
Protocol
.
Browser
.
GetVersionResponse
>
{
return
this
.
#
connection
.
send
(
'
Browser
.
getVersion
'
)
;
}
}
export
class
CDPBrowserContext
extends
BrowserContext
{
#
connection
:
Connection
;
#
browser
:
CDPBrowser
;
#
id
?
:
string
;
constructor
(
connection
:
Connection
browser
:
CDPBrowser
contextId
?
:
string
)
{
super
(
)
;
this
.
#
connection
=
connection
;
this
.
#
browser
=
browser
;
this
.
#
id
=
contextId
;
}
override
get
id
(
)
:
string
|
undefined
{
return
this
.
#
id
;
}
override
targets
(
)
:
CDPTarget
[
]
{
return
this
.
#
browser
.
targets
(
)
.
filter
(
target
=
>
{
return
target
.
browserContext
(
)
=
=
=
this
;
}
)
;
}
override
waitForTarget
(
predicate
:
(
x
:
Target
)
=
>
boolean
|
Promise
<
boolean
>
options
:
{
timeout
?
:
number
}
=
{
}
)
:
Promise
<
Target
>
{
return
this
.
#
browser
.
waitForTarget
(
target
=
>
{
return
target
.
browserContext
(
)
=
=
=
this
&
&
predicate
(
target
)
;
}
options
)
;
}
override
async
pages
(
)
:
Promise
<
Page
[
]
>
{
const
pages
=
await
Promise
.
all
(
this
.
targets
(
)
.
filter
(
target
=
>
{
return
(
target
.
type
(
)
=
=
=
'
page
'
|
|
(
target
.
type
(
)
=
=
=
'
other
'
&
&
this
.
#
browser
.
_getIsPageTargetCallback
(
)
?
.
(
target
)
)
)
;
}
)
.
map
(
target
=
>
{
return
target
.
page
(
)
;
}
)
)
;
return
pages
.
filter
(
(
page
)
:
page
is
Page
=
>
{
return
!
!
page
;
}
)
;
}
override
isIncognito
(
)
:
boolean
{
return
!
!
this
.
#
id
;
}
override
async
overridePermissions
(
origin
:
string
permissions
:
Permission
[
]
)
:
Promise
<
void
>
{
const
protocolPermissions
=
permissions
.
map
(
permission
=
>
{
const
protocolPermission
=
WEB_PERMISSION_TO_PROTOCOL_PERMISSION
.
get
(
permission
)
;
if
(
!
protocolPermission
)
{
throw
new
Error
(
'
Unknown
permission
:
'
+
permission
)
;
}
return
protocolPermission
;
}
)
;
await
this
.
#
connection
.
send
(
'
Browser
.
grantPermissions
'
{
origin
browserContextId
:
this
.
#
id
|
|
undefined
permissions
:
protocolPermissions
}
)
;
}
override
async
clearPermissionOverrides
(
)
:
Promise
<
void
>
{
await
this
.
#
connection
.
send
(
'
Browser
.
resetPermissions
'
{
browserContextId
:
this
.
#
id
|
|
undefined
}
)
;
}
override
newPage
(
)
:
Promise
<
Page
>
{
return
this
.
#
browser
.
_createPageInContext
(
this
.
#
id
)
;
}
override
browser
(
)
:
CDPBrowser
{
return
this
.
#
browser
;
}
override
async
close
(
)
:
Promise
<
void
>
{
assert
(
this
.
#
id
'
Non
-
incognito
profiles
cannot
be
closed
!
'
)
;
await
this
.
#
browser
.
_disposeContext
(
this
.
#
id
)
;
}
}
