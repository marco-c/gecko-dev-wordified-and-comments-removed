import
type
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
TouchError
}
from
'
.
.
/
common
/
Errors
.
js
'
;
import
type
{
KeyInput
}
from
'
.
.
/
common
/
USKeyboardLayout
.
js
'
;
import
{
createIncrementalIdGenerator
}
from
'
.
.
/
util
/
incremental
-
id
-
generator
.
js
'
;
import
type
{
Point
}
from
'
.
/
ElementHandle
.
js
'
;
export
interface
KeyDownOptions
{
text
?
:
string
;
commands
?
:
string
[
]
;
}
export
interface
KeyboardTypeOptions
{
delay
?
:
number
;
}
export
type
KeyPressOptions
=
KeyDownOptions
&
KeyboardTypeOptions
;
export
abstract
class
Keyboard
{
constructor
(
)
{
}
abstract
down
(
key
:
KeyInput
options
?
:
Readonly
<
KeyDownOptions
>
)
:
Promise
<
void
>
;
abstract
up
(
key
:
KeyInput
)
:
Promise
<
void
>
;
abstract
sendCharacter
(
char
:
string
)
:
Promise
<
void
>
;
abstract
type
(
text
:
string
options
?
:
Readonly
<
KeyboardTypeOptions
>
)
:
Promise
<
void
>
;
abstract
press
(
key
:
KeyInput
options
?
:
Readonly
<
KeyPressOptions
>
)
:
Promise
<
void
>
;
}
export
interface
MouseOptions
{
button
?
:
MouseButton
;
clickCount
?
:
number
;
}
export
interface
MouseClickOptions
extends
MouseOptions
{
delay
?
:
number
;
count
?
:
number
;
}
export
interface
MouseWheelOptions
{
deltaX
?
:
number
;
deltaY
?
:
number
;
}
export
interface
MouseMoveOptions
{
steps
?
:
number
;
}
export
const
MouseButton
=
Object
.
freeze
(
{
Left
:
'
left
'
Right
:
'
right
'
Middle
:
'
middle
'
Back
:
'
back
'
Forward
:
'
forward
'
}
)
satisfies
Record
<
string
Protocol
.
Input
.
MouseButton
>
;
export
type
MouseButton
=
(
typeof
MouseButton
)
[
keyof
typeof
MouseButton
]
;
export
abstract
class
Mouse
{
constructor
(
)
{
}
abstract
reset
(
)
:
Promise
<
void
>
;
abstract
move
(
x
:
number
y
:
number
options
?
:
Readonly
<
MouseMoveOptions
>
)
:
Promise
<
void
>
;
abstract
down
(
options
?
:
Readonly
<
MouseOptions
>
)
:
Promise
<
void
>
;
abstract
up
(
options
?
:
Readonly
<
MouseOptions
>
)
:
Promise
<
void
>
;
abstract
click
(
x
:
number
y
:
number
options
?
:
Readonly
<
MouseClickOptions
>
)
:
Promise
<
void
>
;
abstract
wheel
(
options
?
:
Readonly
<
MouseWheelOptions
>
)
:
Promise
<
void
>
;
abstract
drag
(
start
:
Point
target
:
Point
)
:
Promise
<
Protocol
.
Input
.
DragData
>
;
abstract
dragEnter
(
target
:
Point
data
:
Protocol
.
Input
.
DragData
)
:
Promise
<
void
>
;
abstract
dragOver
(
target
:
Point
data
:
Protocol
.
Input
.
DragData
)
:
Promise
<
void
>
;
abstract
drop
(
target
:
Point
data
:
Protocol
.
Input
.
DragData
)
:
Promise
<
void
>
;
abstract
dragAndDrop
(
start
:
Point
target
:
Point
options
?
:
{
delay
?
:
number
}
)
:
Promise
<
void
>
;
}
export
interface
TouchHandle
{
move
(
x
:
number
y
:
number
)
:
Promise
<
void
>
;
end
(
)
:
Promise
<
void
>
;
}
export
abstract
class
Touchscreen
{
idGenerator
=
createIncrementalIdGenerator
(
)
;
touches
:
TouchHandle
[
]
=
[
]
;
constructor
(
)
{
}
removeHandle
(
handle
:
TouchHandle
)
:
void
{
const
index
=
this
.
touches
.
indexOf
(
handle
)
;
if
(
index
=
=
=
-
1
)
{
return
;
}
this
.
touches
.
splice
(
index
1
)
;
}
async
tap
(
x
:
number
y
:
number
)
:
Promise
<
void
>
{
const
touch
=
await
this
.
touchStart
(
x
y
)
;
await
touch
.
end
(
)
;
}
abstract
touchStart
(
x
:
number
y
:
number
)
:
Promise
<
TouchHandle
>
;
async
touchMove
(
x
:
number
y
:
number
)
:
Promise
<
void
>
{
const
touch
=
this
.
touches
[
0
]
;
if
(
!
touch
)
{
throw
new
TouchError
(
'
Must
start
a
new
Touch
first
'
)
;
}
return
await
touch
.
move
(
x
y
)
;
}
async
touchEnd
(
)
:
Promise
<
void
>
{
const
touch
=
this
.
touches
.
shift
(
)
;
if
(
!
touch
)
{
throw
new
TouchError
(
'
Must
start
a
new
Touch
first
'
)
;
}
await
touch
.
end
(
)
;
}
}
