import
type
Protocol
from
'
devtools
-
protocol
'
;
import
type
{
ClickOptions
ElementHandle
}
from
'
.
.
/
api
/
ElementHandle
.
js
'
;
import
type
{
HTTPResponse
}
from
'
.
.
/
api
/
HTTPResponse
.
js
'
;
import
type
{
Page
QueryOptions
WaitForSelectorOptions
WaitTimeoutOptions
}
from
'
.
.
/
api
/
Page
.
js
'
;
import
type
{
Accessibility
}
from
'
.
.
/
cdp
/
Accessibility
.
js
'
;
import
type
{
DeviceRequestPrompt
}
from
'
.
.
/
cdp
/
DeviceRequestPrompt
.
js
'
;
import
type
{
PuppeteerLifeCycleEvent
}
from
'
.
.
/
cdp
/
LifecycleWatcher
.
js
'
;
import
{
EventEmitter
type
EventType
}
from
'
.
.
/
common
/
EventEmitter
.
js
'
;
import
{
getQueryHandlerAndSelector
}
from
'
.
.
/
common
/
GetQueryHandler
.
js
'
;
import
{
transposeIterableHandle
}
from
'
.
.
/
common
/
HandleIterator
.
js
'
;
import
type
{
Awaitable
EvaluateFunc
EvaluateFuncWith
HandleFor
NodeFor
}
from
'
.
.
/
common
/
types
.
js
'
;
import
{
withSourcePuppeteerURLIfNone
}
from
'
.
.
/
common
/
util
.
js
'
;
import
{
environment
}
from
'
.
.
/
environment
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
throwIfDisposed
}
from
'
.
.
/
util
/
decorators
.
js
'
;
import
type
{
CDPSession
}
from
'
.
/
CDPSession
.
js
'
;
import
type
{
KeyboardTypeOptions
}
from
'
.
/
Input
.
js
'
;
import
{
FunctionLocator
NodeLocator
type
Locator
}
from
'
.
/
locators
/
locators
.
js
'
;
import
type
{
Realm
}
from
'
.
/
Realm
.
js
'
;
export
interface
WaitForOptions
{
timeout
?
:
number
;
waitUntil
?
:
PuppeteerLifeCycleEvent
|
PuppeteerLifeCycleEvent
[
]
;
ignoreSameDocumentNavigation
?
:
boolean
;
signal
?
:
AbortSignal
;
}
export
interface
GoToOptions
extends
WaitForOptions
{
referer
?
:
string
;
referrerPolicy
?
:
string
;
}
export
interface
FrameWaitForFunctionOptions
{
polling
?
:
'
raf
'
|
'
mutation
'
|
number
;
timeout
?
:
number
;
signal
?
:
AbortSignal
;
}
export
interface
FrameAddScriptTagOptions
{
url
?
:
string
;
path
?
:
string
;
content
?
:
string
;
type
?
:
string
;
id
?
:
string
;
}
export
interface
FrameAddStyleTagOptions
{
url
?
:
string
;
path
?
:
string
;
content
?
:
string
;
}
export
interface
FrameEvents
extends
Record
<
EventType
unknown
>
{
[
FrameEvent
.
FrameNavigated
]
:
Protocol
.
Page
.
NavigationType
;
[
FrameEvent
.
FrameSwapped
]
:
undefined
;
[
FrameEvent
.
LifecycleEvent
]
:
undefined
;
[
FrameEvent
.
FrameNavigatedWithinDocument
]
:
undefined
;
[
FrameEvent
.
FrameDetached
]
:
Frame
;
[
FrameEvent
.
FrameSwappedByActivation
]
:
undefined
;
}
export
namespace
FrameEvent
{
export
const
FrameNavigated
=
Symbol
(
'
Frame
.
FrameNavigated
'
)
;
export
const
FrameSwapped
=
Symbol
(
'
Frame
.
FrameSwapped
'
)
;
export
const
LifecycleEvent
=
Symbol
(
'
Frame
.
LifecycleEvent
'
)
;
export
const
FrameNavigatedWithinDocument
=
Symbol
(
'
Frame
.
FrameNavigatedWithinDocument
'
)
;
export
const
FrameDetached
=
Symbol
(
'
Frame
.
FrameDetached
'
)
;
export
const
FrameSwappedByActivation
=
Symbol
(
'
Frame
.
FrameSwappedByActivation
'
)
;
}
export
const
throwIfDetached
=
throwIfDisposed
<
Frame
>
(
frame
=
>
{
return
Attempted
to
use
detached
Frame
'
{
frame
.
_id
}
'
.
;
}
)
;
export
abstract
class
Frame
extends
EventEmitter
<
FrameEvents
>
{
_id
!
:
string
;
_parentId
?
:
string
;
_name
?
:
string
;
_hasStartedLoading
=
false
;
constructor
(
)
{
super
(
)
;
}
abstract
page
(
)
:
Page
;
abstract
goto
(
url
:
string
options
?
:
GoToOptions
)
:
Promise
<
HTTPResponse
|
null
>
;
abstract
waitForNavigation
(
options
?
:
WaitForOptions
)
:
Promise
<
HTTPResponse
|
null
>
;
abstract
get
client
(
)
:
CDPSession
;
abstract
get
accessibility
(
)
:
Accessibility
;
abstract
mainRealm
(
)
:
Realm
;
abstract
isolatedRealm
(
)
:
Realm
;
#
_document
:
Promise
<
ElementHandle
<
Document
>
>
|
undefined
;
#
document
(
)
:
Promise
<
ElementHandle
<
Document
>
>
{
if
(
!
this
.
#
_document
)
{
this
.
#
_document
=
this
.
mainRealm
(
)
.
evaluateHandle
(
(
)
=
>
{
return
document
;
}
)
;
}
return
this
.
#
_document
;
}
clearDocumentHandle
(
)
:
void
{
this
.
#
_document
=
undefined
;
}
throwIfDetached
async
frameElement
(
)
:
Promise
<
HandleFor
<
HTMLIFrameElement
>
|
null
>
{
const
parentFrame
=
this
.
parentFrame
(
)
;
if
(
!
parentFrame
)
{
return
null
;
}
using
list
=
await
parentFrame
.
isolatedRealm
(
)
.
evaluateHandle
(
(
)
=
>
{
return
document
.
querySelectorAll
(
'
iframe
frame
'
)
;
}
)
;
for
await
(
using
iframe
of
transposeIterableHandle
(
list
)
)
{
const
frame
=
await
iframe
.
contentFrame
(
)
;
if
(
frame
?
.
_id
=
=
=
this
.
_id
)
{
return
(
iframe
as
HandleFor
<
HTMLIFrameElement
>
)
.
move
(
)
;
}
}
return
null
;
}
throwIfDetached
async
evaluateHandle
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluateHandle
.
name
pageFunction
)
;
return
await
this
.
mainRealm
(
)
.
evaluateHandle
(
pageFunction
.
.
.
args
)
;
}
throwIfDetached
async
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluate
.
name
pageFunction
)
;
return
await
this
.
mainRealm
(
)
.
evaluate
(
pageFunction
.
.
.
args
)
;
}
locator
<
Selector
extends
string
>
(
selector
:
Selector
)
:
Locator
<
NodeFor
<
Selector
>
>
;
locator
<
Ret
>
(
func
:
(
)
=
>
Awaitable
<
Ret
>
)
:
Locator
<
Ret
>
;
throwIfDetached
locator
<
Selector
extends
string
Ret
>
(
selectorOrFunc
:
Selector
|
(
(
)
=
>
Awaitable
<
Ret
>
)
)
:
Locator
<
NodeFor
<
Selector
>
>
|
Locator
<
Ret
>
{
if
(
typeof
selectorOrFunc
=
=
=
'
string
'
)
{
return
NodeLocator
.
create
(
this
selectorOrFunc
)
;
}
else
{
return
FunctionLocator
.
create
(
this
selectorOrFunc
)
;
}
}
throwIfDetached
async
<
Selector
extends
string
>
(
selector
:
Selector
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
{
const
document
=
await
this
.
#
document
(
)
;
return
await
document
.
(
selector
)
;
}
throwIfDetached
async
<
Selector
extends
string
>
(
selector
:
Selector
options
?
:
QueryOptions
)
:
Promise
<
Array
<
ElementHandle
<
NodeFor
<
Selector
>
>
>
>
{
const
document
=
await
this
.
#
document
(
)
;
return
await
document
.
(
selector
options
)
;
}
throwIfDetached
async
eval
<
Selector
extends
string
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
NodeFor
<
Selector
>
Params
>
=
EvaluateFuncWith
<
NodeFor
<
Selector
>
Params
>
>
(
selector
:
Selector
pageFunction
:
string
|
Func
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
eval
.
name
pageFunction
)
;
const
document
=
await
this
.
#
document
(
)
;
return
await
document
.
eval
(
selector
pageFunction
.
.
.
args
)
;
}
throwIfDetached
async
eval
<
Selector
extends
string
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
Array
<
NodeFor
<
Selector
>
>
Params
>
=
EvaluateFuncWith
<
Array
<
NodeFor
<
Selector
>
>
Params
>
>
(
selector
:
Selector
pageFunction
:
string
|
Func
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
eval
.
name
pageFunction
)
;
const
document
=
await
this
.
#
document
(
)
;
return
await
document
.
eval
(
selector
pageFunction
.
.
.
args
)
;
}
throwIfDetached
async
waitForSelector
<
Selector
extends
string
>
(
selector
:
Selector
options
:
WaitForSelectorOptions
=
{
}
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
{
const
{
updatedSelector
QueryHandler
polling
}
=
getQueryHandlerAndSelector
(
selector
)
;
return
(
await
QueryHandler
.
waitFor
(
this
updatedSelector
{
polling
.
.
.
options
}
)
)
as
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
;
}
throwIfDetached
async
waitForFunction
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
options
:
FrameWaitForFunctionOptions
=
{
}
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
return
await
(
this
.
mainRealm
(
)
.
waitForFunction
(
pageFunction
options
.
.
.
args
)
as
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
)
;
}
throwIfDetached
async
content
(
)
:
Promise
<
string
>
{
return
await
this
.
evaluate
(
(
)
=
>
{
let
content
=
'
'
;
for
(
const
node
of
document
.
childNodes
)
{
switch
(
node
)
{
case
document
.
documentElement
:
content
+
=
document
.
documentElement
.
outerHTML
;
break
;
default
:
content
+
=
new
XMLSerializer
(
)
.
serializeToString
(
node
)
;
break
;
}
}
return
content
;
}
)
;
}
abstract
setContent
(
html
:
string
options
?
:
WaitForOptions
)
:
Promise
<
void
>
;
async
setFrameContent
(
content
:
string
)
:
Promise
<
void
>
{
return
await
this
.
evaluate
(
html
=
>
{
document
.
open
(
)
;
document
.
write
(
html
)
;
document
.
close
(
)
;
}
content
)
;
}
name
(
)
:
string
{
return
this
.
_name
|
|
'
'
;
}
abstract
url
(
)
:
string
;
abstract
parentFrame
(
)
:
Frame
|
null
;
abstract
childFrames
(
)
:
Frame
[
]
;
abstract
get
detached
(
)
:
boolean
;
isDetached
(
)
:
boolean
{
return
this
.
detached
;
}
get
disposed
(
)
:
boolean
{
return
this
.
detached
;
}
throwIfDetached
async
addScriptTag
(
options
:
FrameAddScriptTagOptions
)
:
Promise
<
ElementHandle
<
HTMLScriptElement
>
>
{
let
{
content
=
'
'
type
}
=
options
;
const
{
path
}
=
options
;
if
(
+
!
!
options
.
url
+
+
!
!
path
+
+
!
!
content
!
=
=
1
)
{
throw
new
Error
(
'
Exactly
one
of
url
path
or
content
must
be
specified
.
'
)
;
}
if
(
path
)
{
content
=
await
environment
.
value
.
fs
.
promises
.
readFile
(
path
'
utf8
'
)
;
content
+
=
/
/
#
sourceURL
=
{
path
.
replace
(
/
\
n
/
g
'
'
)
}
;
}
type
=
type
?
?
'
text
/
javascript
'
;
return
await
this
.
mainRealm
(
)
.
transferHandle
(
await
this
.
isolatedRealm
(
)
.
evaluateHandle
(
async
(
{
url
id
type
content
}
)
=
>
{
return
await
new
Promise
<
HTMLScriptElement
>
(
(
resolve
reject
)
=
>
{
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
type
=
type
;
script
.
text
=
content
;
script
.
addEventListener
(
'
error
'
event
=
>
{
reject
(
new
Error
(
event
.
message
?
?
'
Could
not
load
script
'
)
)
;
}
{
once
:
true
}
)
;
if
(
id
)
{
script
.
id
=
id
;
}
if
(
url
)
{
script
.
src
=
url
;
script
.
addEventListener
(
'
load
'
(
)
=
>
{
resolve
(
script
)
;
}
{
once
:
true
}
)
;
document
.
head
.
appendChild
(
script
)
;
}
else
{
document
.
head
.
appendChild
(
script
)
;
resolve
(
script
)
;
}
}
)
;
}
{
.
.
.
options
type
content
}
)
)
;
}
async
addStyleTag
(
options
:
Omit
<
FrameAddStyleTagOptions
'
url
'
>
)
:
Promise
<
ElementHandle
<
HTMLStyleElement
>
>
;
async
addStyleTag
(
options
:
FrameAddStyleTagOptions
)
:
Promise
<
ElementHandle
<
HTMLLinkElement
>
>
;
throwIfDetached
async
addStyleTag
(
options
:
FrameAddStyleTagOptions
)
:
Promise
<
ElementHandle
<
HTMLStyleElement
|
HTMLLinkElement
>
>
{
let
{
content
=
'
'
}
=
options
;
const
{
path
}
=
options
;
if
(
+
!
!
options
.
url
+
+
!
!
path
+
+
!
!
content
!
=
=
1
)
{
throw
new
Error
(
'
Exactly
one
of
url
path
or
content
must
be
specified
.
'
)
;
}
if
(
path
)
{
content
=
await
environment
.
value
.
fs
.
promises
.
readFile
(
path
'
utf8
'
)
;
content
+
=
'
/
*
#
sourceURL
=
'
+
path
.
replace
(
/
\
n
/
g
'
'
)
+
'
*
/
'
;
options
.
content
=
content
;
}
return
await
this
.
mainRealm
(
)
.
transferHandle
(
await
this
.
isolatedRealm
(
)
.
evaluateHandle
(
async
(
{
url
content
}
)
=
>
{
return
await
new
Promise
<
HTMLStyleElement
|
HTMLLinkElement
>
(
(
resolve
reject
)
=
>
{
let
element
:
HTMLStyleElement
|
HTMLLinkElement
;
if
(
!
url
)
{
element
=
document
.
createElement
(
'
style
'
)
;
element
.
appendChild
(
document
.
createTextNode
(
content
!
)
)
;
}
else
{
const
link
=
document
.
createElement
(
'
link
'
)
;
link
.
rel
=
'
stylesheet
'
;
link
.
href
=
url
;
element
=
link
;
}
element
.
addEventListener
(
'
load
'
(
)
=
>
{
resolve
(
element
)
;
}
{
once
:
true
}
)
;
element
.
addEventListener
(
'
error
'
event
=
>
{
reject
(
new
Error
(
(
event
as
ErrorEvent
)
.
message
?
?
'
Could
not
load
style
'
)
)
;
}
{
once
:
true
}
)
;
document
.
head
.
appendChild
(
element
)
;
return
element
;
}
)
;
}
options
)
)
;
}
throwIfDetached
async
click
(
selector
:
string
options
:
Readonly
<
ClickOptions
>
=
{
}
)
:
Promise
<
void
>
{
using
handle
=
await
this
.
(
selector
)
;
assert
(
handle
No
element
found
for
selector
:
{
selector
}
)
;
await
handle
.
click
(
options
)
;
await
handle
.
dispose
(
)
;
}
throwIfDetached
async
focus
(
selector
:
string
)
:
Promise
<
void
>
{
using
handle
=
await
this
.
(
selector
)
;
assert
(
handle
No
element
found
for
selector
:
{
selector
}
)
;
await
handle
.
focus
(
)
;
}
throwIfDetached
async
hover
(
selector
:
string
)
:
Promise
<
void
>
{
using
handle
=
await
this
.
(
selector
)
;
assert
(
handle
No
element
found
for
selector
:
{
selector
}
)
;
await
handle
.
hover
(
)
;
}
throwIfDetached
async
select
(
selector
:
string
.
.
.
values
:
string
[
]
)
:
Promise
<
string
[
]
>
{
using
handle
=
await
this
.
(
selector
)
;
assert
(
handle
No
element
found
for
selector
:
{
selector
}
)
;
return
await
handle
.
select
(
.
.
.
values
)
;
}
throwIfDetached
async
tap
(
selector
:
string
)
:
Promise
<
void
>
{
using
handle
=
await
this
.
(
selector
)
;
assert
(
handle
No
element
found
for
selector
:
{
selector
}
)
;
await
handle
.
tap
(
)
;
}
throwIfDetached
async
type
(
selector
:
string
text
:
string
options
?
:
Readonly
<
KeyboardTypeOptions
>
)
:
Promise
<
void
>
{
using
handle
=
await
this
.
(
selector
)
;
assert
(
handle
No
element
found
for
selector
:
{
selector
}
)
;
await
handle
.
type
(
text
options
)
;
}
throwIfDetached
async
title
(
)
:
Promise
<
string
>
{
return
await
this
.
isolatedRealm
(
)
.
evaluate
(
(
)
=
>
{
return
document
.
title
;
}
)
;
}
abstract
waitForDevicePrompt
(
options
?
:
WaitTimeoutOptions
)
:
Promise
<
DeviceRequestPrompt
>
;
}
