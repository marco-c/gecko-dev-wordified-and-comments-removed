import
{
EMPTY
Observable
OperatorFunction
catchError
defaultIfEmpty
defer
filter
first
firstValueFrom
from
fromEvent
identity
ignoreElements
map
merge
mergeMap
noop
pipe
raceWith
retry
tap
}
from
'
.
.
/
.
.
/
.
.
/
third_party
/
rxjs
/
rxjs
.
js
'
;
import
{
EventEmitter
}
from
'
.
.
/
.
.
/
common
/
EventEmitter
.
js
'
;
import
{
HandleFor
}
from
'
.
.
/
.
.
/
common
/
types
.
js
'
;
import
{
debugError
timeout
}
from
'
.
.
/
.
.
/
common
/
util
.
js
'
;
import
{
BoundingBox
ClickOptions
ElementHandle
}
from
'
.
.
/
ElementHandle
.
js
'
;
import
{
Action
AwaitedLocator
FilteredLocator
HandleMapper
MappedLocator
Mapper
Predicate
RaceLocator
}
from
'
.
/
locators
.
js
'
;
export
const
RETRY_DELAY
=
100
;
export
type
VisibilityOption
=
'
hidden
'
|
'
visible
'
|
null
;
export
interface
LocatorOptions
{
visibility
:
VisibilityOption
;
timeout
:
number
;
ensureElementIsInTheViewport
:
boolean
;
waitForEnabled
:
boolean
;
waitForStableBoundingBox
:
boolean
;
}
export
interface
ActionOptions
{
signal
?
:
AbortSignal
;
}
export
type
LocatorClickOptions
=
ClickOptions
&
ActionOptions
;
export
interface
LocatorScrollOptions
extends
ActionOptions
{
scrollTop
?
:
number
;
scrollLeft
?
:
number
;
}
export
enum
LocatorEmittedEvents
{
Action
=
'
action
'
}
export
interface
LocatorEventObject
{
[
LocatorEmittedEvents
.
Action
]
:
never
;
}
export
abstract
class
Locator
<
T
>
extends
EventEmitter
{
static
race
<
Locators
extends
readonly
unknown
[
]
|
[
]
>
(
locators
:
Locators
)
:
Locator
<
AwaitedLocator
<
Locators
[
number
]
>
>
{
return
RaceLocator
.
create
(
locators
)
;
}
declare
_
?
:
T
;
protected
visibility
:
VisibilityOption
=
null
;
protected
_timeout
=
30_000
;
#
ensureElementIsInTheViewport
=
true
;
#
waitForEnabled
=
true
;
#
waitForStableBoundingBox
=
true
;
protected
operators
=
{
conditions
:
(
conditions
:
Array
<
Action
<
T
never
>
>
signal
?
:
AbortSignal
)
:
OperatorFunction
<
HandleFor
<
T
>
HandleFor
<
T
>
>
=
>
{
return
mergeMap
(
(
handle
:
HandleFor
<
T
>
)
=
>
{
return
merge
(
.
.
.
conditions
.
map
(
condition
=
>
{
return
condition
(
handle
signal
)
;
}
)
)
.
pipe
(
defaultIfEmpty
(
handle
)
)
;
}
)
;
}
retryAndRaceWithSignalAndTimer
:
<
T
>
(
signal
?
:
AbortSignal
)
:
OperatorFunction
<
T
T
>
=
>
{
const
candidates
=
[
]
;
if
(
signal
)
{
candidates
.
push
(
fromEvent
(
signal
'
abort
'
)
.
pipe
(
map
(
(
)
=
>
{
throw
signal
.
reason
;
}
)
)
)
;
}
candidates
.
push
(
timeout
(
this
.
_timeout
)
)
;
return
pipe
(
retry
(
{
delay
:
RETRY_DELAY
}
)
raceWith
<
T
never
[
]
>
(
.
.
.
candidates
)
)
;
}
}
;
get
timeout
(
)
:
number
{
return
this
.
_timeout
;
}
override
on
<
K
extends
keyof
LocatorEventObject
>
(
eventName
:
K
handler
:
(
event
:
LocatorEventObject
[
K
]
)
=
>
void
)
:
this
{
return
super
.
on
(
eventName
handler
)
;
}
override
once
<
K
extends
keyof
LocatorEventObject
>
(
eventName
:
K
handler
:
(
event
:
LocatorEventObject
[
K
]
)
=
>
void
)
:
this
{
return
super
.
once
(
eventName
handler
)
;
}
override
off
<
K
extends
keyof
LocatorEventObject
>
(
eventName
:
K
handler
:
(
event
:
LocatorEventObject
[
K
]
)
=
>
void
)
:
this
{
return
super
.
off
(
eventName
handler
)
;
}
setTimeout
(
timeout
:
number
)
:
Locator
<
T
>
{
const
locator
=
this
.
_clone
(
)
;
locator
.
_timeout
=
timeout
;
return
locator
;
}
setVisibility
<
NodeType
extends
Node
>
(
this
:
Locator
<
NodeType
>
visibility
:
VisibilityOption
)
:
Locator
<
NodeType
>
{
const
locator
=
this
.
_clone
(
)
;
locator
.
visibility
=
visibility
;
return
locator
;
}
setWaitForEnabled
<
NodeType
extends
Node
>
(
this
:
Locator
<
NodeType
>
value
:
boolean
)
:
Locator
<
NodeType
>
{
const
locator
=
this
.
_clone
(
)
;
locator
.
#
waitForEnabled
=
value
;
return
locator
;
}
setEnsureElementIsInTheViewport
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
value
:
boolean
)
:
Locator
<
ElementType
>
{
const
locator
=
this
.
_clone
(
)
;
locator
.
#
ensureElementIsInTheViewport
=
value
;
return
locator
;
}
setWaitForStableBoundingBox
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
value
:
boolean
)
:
Locator
<
ElementType
>
{
const
locator
=
this
.
_clone
(
)
;
locator
.
#
waitForStableBoundingBox
=
value
;
return
locator
;
}
copyOptions
<
T
>
(
locator
:
Locator
<
T
>
)
:
this
{
this
.
_timeout
=
locator
.
_timeout
;
this
.
visibility
=
locator
.
visibility
;
this
.
#
waitForEnabled
=
locator
.
#
waitForEnabled
;
this
.
#
ensureElementIsInTheViewport
=
locator
.
#
ensureElementIsInTheViewport
;
this
.
#
waitForStableBoundingBox
=
locator
.
#
waitForStableBoundingBox
;
return
this
;
}
#
waitForEnabledIfNeeded
=
<
ElementType
extends
Node
>
(
handle
:
HandleFor
<
ElementType
>
signal
?
:
AbortSignal
)
:
Observable
<
never
>
=
>
{
if
(
!
this
.
#
waitForEnabled
)
{
return
EMPTY
;
}
return
from
(
handle
.
frame
.
waitForFunction
(
element
=
>
{
if
(
!
(
element
instanceof
HTMLElement
)
)
{
return
true
;
}
const
isNativeFormControl
=
[
'
BUTTON
'
'
INPUT
'
'
SELECT
'
'
TEXTAREA
'
'
OPTION
'
'
OPTGROUP
'
]
.
includes
(
element
.
nodeName
)
;
return
!
isNativeFormControl
|
|
!
element
.
hasAttribute
(
'
disabled
'
)
;
}
{
timeout
:
this
.
_timeout
signal
}
handle
)
)
.
pipe
(
ignoreElements
(
)
)
;
}
;
#
waitForStableBoundingBoxIfNeeded
=
<
ElementType
extends
Element
>
(
handle
:
HandleFor
<
ElementType
>
)
:
Observable
<
never
>
=
>
{
if
(
!
this
.
#
waitForStableBoundingBox
)
{
return
EMPTY
;
}
return
defer
(
(
)
=
>
{
return
from
(
handle
.
evaluate
(
element
=
>
{
return
new
Promise
<
[
BoundingBox
BoundingBox
]
>
(
resolve
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
const
rect1
=
element
.
getBoundingClientRect
(
)
;
window
.
requestAnimationFrame
(
(
)
=
>
{
const
rect2
=
element
.
getBoundingClientRect
(
)
;
resolve
(
[
{
x
:
rect1
.
x
y
:
rect1
.
y
width
:
rect1
.
width
height
:
rect1
.
height
}
{
x
:
rect2
.
x
y
:
rect2
.
y
width
:
rect2
.
width
height
:
rect2
.
height
}
]
)
;
}
)
;
}
)
;
}
)
;
}
)
)
;
}
)
.
pipe
(
first
(
(
[
rect1
rect2
]
)
=
>
{
return
(
rect1
.
x
=
=
=
rect2
.
x
&
&
rect1
.
y
=
=
=
rect2
.
y
&
&
rect1
.
width
=
=
=
rect2
.
width
&
&
rect1
.
height
=
=
=
rect2
.
height
)
;
}
)
retry
(
{
delay
:
RETRY_DELAY
}
)
ignoreElements
(
)
)
;
}
;
#
ensureElementIsInTheViewportIfNeeded
=
<
ElementType
extends
Element
>
(
handle
:
HandleFor
<
ElementType
>
)
:
Observable
<
never
>
=
>
{
if
(
!
this
.
#
ensureElementIsInTheViewport
)
{
return
EMPTY
;
}
return
from
(
handle
.
isIntersectingViewport
(
{
threshold
:
0
}
)
)
.
pipe
(
filter
(
isIntersectingViewport
=
>
{
return
!
isIntersectingViewport
;
}
)
mergeMap
(
(
)
=
>
{
return
from
(
handle
.
scrollIntoView
(
)
)
;
}
)
mergeMap
(
(
)
=
>
{
return
defer
(
(
)
=
>
{
return
from
(
handle
.
isIntersectingViewport
(
{
threshold
:
0
}
)
)
;
}
)
.
pipe
(
first
(
identity
)
retry
(
{
delay
:
RETRY_DELAY
}
)
ignoreElements
(
)
)
;
}
)
)
;
}
;
#
click
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
options
?
:
Readonly
<
LocatorClickOptions
>
)
:
Observable
<
void
>
{
const
signal
=
options
?
.
signal
;
return
this
.
_wait
(
options
)
.
pipe
(
this
.
operators
.
conditions
(
[
this
.
#
ensureElementIsInTheViewportIfNeeded
this
.
#
waitForStableBoundingBoxIfNeeded
this
.
#
waitForEnabledIfNeeded
]
signal
)
tap
(
(
)
=
>
{
return
this
.
emit
(
LocatorEmittedEvents
.
Action
)
;
}
)
mergeMap
(
handle
=
>
{
return
from
(
handle
.
click
(
options
)
)
.
pipe
(
catchError
(
err
=
>
{
void
handle
.
dispose
(
)
.
catch
(
debugError
)
;
throw
err
;
}
)
)
;
}
)
this
.
operators
.
retryAndRaceWithSignalAndTimer
(
signal
)
)
;
}
#
fill
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
value
:
string
options
?
:
Readonly
<
ActionOptions
>
)
:
Observable
<
void
>
{
const
signal
=
options
?
.
signal
;
return
this
.
_wait
(
options
)
.
pipe
(
this
.
operators
.
conditions
(
[
this
.
#
ensureElementIsInTheViewportIfNeeded
this
.
#
waitForStableBoundingBoxIfNeeded
this
.
#
waitForEnabledIfNeeded
]
signal
)
tap
(
(
)
=
>
{
return
this
.
emit
(
LocatorEmittedEvents
.
Action
)
;
}
)
mergeMap
(
handle
=
>
{
return
from
(
(
handle
as
unknown
as
ElementHandle
<
HTMLElement
>
)
.
evaluate
(
el
=
>
{
if
(
el
instanceof
HTMLSelectElement
)
{
return
'
select
'
;
}
if
(
el
instanceof
HTMLTextAreaElement
)
{
return
'
typeable
-
input
'
;
}
if
(
el
instanceof
HTMLInputElement
)
{
if
(
new
Set
(
[
'
textarea
'
'
text
'
'
url
'
'
tel
'
'
search
'
'
password
'
'
number
'
'
email
'
]
)
.
has
(
el
.
type
)
)
{
return
'
typeable
-
input
'
;
}
else
{
return
'
other
-
input
'
;
}
}
if
(
el
.
isContentEditable
)
{
return
'
contenteditable
'
;
}
return
'
unknown
'
;
}
)
)
.
pipe
(
mergeMap
(
inputType
=
>
{
switch
(
inputType
)
{
case
'
select
'
:
return
from
(
handle
.
select
(
value
)
.
then
(
noop
)
)
;
case
'
contenteditable
'
:
case
'
typeable
-
input
'
:
return
from
(
(
handle
as
unknown
as
ElementHandle
<
HTMLInputElement
>
)
.
evaluate
(
(
input
newValue
)
=
>
{
const
currentValue
=
input
.
isContentEditable
?
input
.
innerText
:
input
.
value
;
if
(
newValue
.
length
<
=
currentValue
.
length
|
|
!
newValue
.
startsWith
(
input
.
value
)
)
{
if
(
input
.
isContentEditable
)
{
input
.
innerText
=
'
'
;
}
else
{
input
.
value
=
'
'
;
}
return
newValue
;
}
const
originalValue
=
input
.
isContentEditable
?
input
.
innerText
:
input
.
value
;
if
(
input
.
isContentEditable
)
{
input
.
innerText
=
'
'
;
input
.
innerText
=
originalValue
;
}
else
{
input
.
value
=
'
'
;
input
.
value
=
originalValue
;
}
return
newValue
.
substring
(
originalValue
.
length
)
;
}
value
)
)
.
pipe
(
mergeMap
(
textToType
=
>
{
return
from
(
handle
.
type
(
textToType
)
)
;
}
)
)
;
case
'
other
-
input
'
:
return
from
(
handle
.
focus
(
)
)
.
pipe
(
mergeMap
(
(
)
=
>
{
return
from
(
handle
.
evaluate
(
(
input
value
)
=
>
{
(
input
as
HTMLInputElement
)
.
value
=
value
;
input
.
dispatchEvent
(
new
Event
(
'
input
'
{
bubbles
:
true
}
)
)
;
input
.
dispatchEvent
(
new
Event
(
'
change
'
{
bubbles
:
true
}
)
)
;
}
value
)
)
;
}
)
)
;
case
'
unknown
'
:
throw
new
Error
(
Element
cannot
be
filled
out
.
)
;
}
}
)
)
.
pipe
(
catchError
(
err
=
>
{
void
handle
.
dispose
(
)
.
catch
(
debugError
)
;
throw
err
;
}
)
)
;
}
)
this
.
operators
.
retryAndRaceWithSignalAndTimer
(
signal
)
)
;
}
#
hover
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
options
?
:
Readonly
<
ActionOptions
>
)
:
Observable
<
void
>
{
const
signal
=
options
?
.
signal
;
return
this
.
_wait
(
options
)
.
pipe
(
this
.
operators
.
conditions
(
[
this
.
#
ensureElementIsInTheViewportIfNeeded
this
.
#
waitForStableBoundingBoxIfNeeded
]
signal
)
tap
(
(
)
=
>
{
return
this
.
emit
(
LocatorEmittedEvents
.
Action
)
;
}
)
mergeMap
(
handle
=
>
{
return
from
(
handle
.
hover
(
)
)
.
pipe
(
catchError
(
err
=
>
{
void
handle
.
dispose
(
)
.
catch
(
debugError
)
;
throw
err
;
}
)
)
;
}
)
this
.
operators
.
retryAndRaceWithSignalAndTimer
(
signal
)
)
;
}
#
scroll
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
options
?
:
Readonly
<
LocatorScrollOptions
>
)
:
Observable
<
void
>
{
const
signal
=
options
?
.
signal
;
return
this
.
_wait
(
options
)
.
pipe
(
this
.
operators
.
conditions
(
[
this
.
#
ensureElementIsInTheViewportIfNeeded
this
.
#
waitForStableBoundingBoxIfNeeded
]
signal
)
tap
(
(
)
=
>
{
return
this
.
emit
(
LocatorEmittedEvents
.
Action
)
;
}
)
mergeMap
(
handle
=
>
{
return
from
(
handle
.
evaluate
(
(
el
scrollTop
scrollLeft
)
=
>
{
if
(
scrollTop
!
=
=
undefined
)
{
el
.
scrollTop
=
scrollTop
;
}
if
(
scrollLeft
!
=
=
undefined
)
{
el
.
scrollLeft
=
scrollLeft
;
}
}
options
?
.
scrollTop
options
?
.
scrollLeft
)
)
.
pipe
(
catchError
(
err
=
>
{
void
handle
.
dispose
(
)
.
catch
(
debugError
)
;
throw
err
;
}
)
)
;
}
)
this
.
operators
.
retryAndRaceWithSignalAndTimer
(
signal
)
)
;
}
abstract
_clone
(
)
:
Locator
<
T
>
;
abstract
_wait
(
options
?
:
Readonly
<
ActionOptions
>
)
:
Observable
<
HandleFor
<
T
>
>
;
clone
(
)
:
Locator
<
T
>
{
return
this
.
_clone
(
)
;
}
async
waitHandle
(
options
?
:
Readonly
<
ActionOptions
>
)
:
Promise
<
HandleFor
<
T
>
>
{
return
await
firstValueFrom
(
this
.
_wait
(
options
)
.
pipe
(
this
.
operators
.
retryAndRaceWithSignalAndTimer
(
options
?
.
signal
)
)
)
;
}
async
wait
(
options
?
:
Readonly
<
ActionOptions
>
)
:
Promise
<
T
>
{
using
handle
=
await
this
.
waitHandle
(
options
)
;
return
await
handle
.
jsonValue
(
)
;
}
map
<
To
>
(
mapper
:
Mapper
<
T
To
>
)
:
Locator
<
To
>
{
return
new
MappedLocator
(
this
.
_clone
(
)
handle
=
>
{
return
(
handle
as
any
)
.
evaluateHandle
(
mapper
)
;
}
)
;
}
filter
<
S
extends
T
>
(
predicate
:
Predicate
<
T
S
>
)
:
Locator
<
S
>
{
return
new
FilteredLocator
(
this
.
_clone
(
)
async
(
handle
signal
)
=
>
{
await
(
handle
as
ElementHandle
<
Node
>
)
.
frame
.
waitForFunction
(
predicate
{
signal
timeout
:
this
.
_timeout
}
handle
)
;
return
true
;
}
)
;
}
filterHandle
<
S
extends
T
>
(
predicate
:
Predicate
<
HandleFor
<
T
>
HandleFor
<
S
>
>
)
:
Locator
<
S
>
{
return
new
FilteredLocator
(
this
.
_clone
(
)
predicate
)
;
}
mapHandle
<
To
>
(
mapper
:
HandleMapper
<
T
To
>
)
:
Locator
<
To
>
{
return
new
MappedLocator
(
this
.
_clone
(
)
mapper
)
;
}
click
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
options
?
:
Readonly
<
LocatorClickOptions
>
)
:
Promise
<
void
>
{
return
firstValueFrom
(
this
.
#
click
(
options
)
)
;
}
fill
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
value
:
string
options
?
:
Readonly
<
ActionOptions
>
)
:
Promise
<
void
>
{
return
firstValueFrom
(
this
.
#
fill
(
value
options
)
)
;
}
hover
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
options
?
:
Readonly
<
ActionOptions
>
)
:
Promise
<
void
>
{
return
firstValueFrom
(
this
.
#
hover
(
options
)
)
;
}
scroll
<
ElementType
extends
Element
>
(
this
:
Locator
<
ElementType
>
options
?
:
Readonly
<
LocatorScrollOptions
>
)
:
Promise
<
void
>
{
return
firstValueFrom
(
this
.
#
scroll
(
options
)
)
;
}
}
