import
{
Observable
filter
from
map
mergeMap
throwIfEmpty
}
from
'
.
.
/
.
.
/
.
.
/
third_party
/
rxjs
/
rxjs
.
js
'
;
import
{
Awaitable
HandleFor
}
from
'
.
.
/
.
.
/
common
/
common
.
js
'
;
import
{
DelegatedLocator
}
from
'
.
/
DelegatedLocator
.
js
'
;
import
{
ActionOptions
Locator
}
from
'
.
/
locators
.
js
'
;
export
type
Predicate
<
From
To
extends
From
=
From
>
=
|
(
(
value
:
From
)
=
>
value
is
To
)
|
(
(
value
:
From
)
=
>
Awaitable
<
boolean
>
)
;
export
type
HandlePredicate
<
From
To
extends
From
=
From
>
=
|
(
(
value
:
HandleFor
<
From
>
signal
?
:
AbortSignal
)
=
>
value
is
HandleFor
<
To
>
)
|
(
(
value
:
HandleFor
<
From
>
signal
?
:
AbortSignal
)
=
>
Awaitable
<
boolean
>
)
;
export
class
FilteredLocator
<
From
To
extends
From
>
extends
DelegatedLocator
<
From
To
>
{
#
predicate
:
HandlePredicate
<
From
To
>
;
constructor
(
base
:
Locator
<
From
>
predicate
:
HandlePredicate
<
From
To
>
)
{
super
(
base
)
;
this
.
#
predicate
=
predicate
;
}
override
_clone
(
)
:
FilteredLocator
<
From
To
>
{
return
new
FilteredLocator
(
this
.
delegate
.
clone
(
)
this
.
#
predicate
)
.
copyOptions
(
this
)
;
}
override
_wait
(
options
?
:
Readonly
<
ActionOptions
>
)
:
Observable
<
HandleFor
<
To
>
>
{
return
this
.
delegate
.
_wait
(
options
)
.
pipe
(
mergeMap
(
handle
=
>
{
return
from
(
Promise
.
resolve
(
this
.
#
predicate
(
handle
options
?
.
signal
)
)
)
.
pipe
(
filter
(
value
=
>
{
return
value
;
}
)
map
(
(
)
=
>
{
return
handle
as
HandleFor
<
To
>
;
}
)
)
;
}
)
throwIfEmpty
(
)
)
;
}
}
