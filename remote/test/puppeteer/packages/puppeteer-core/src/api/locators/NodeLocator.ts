import
{
EMPTY
Observable
defer
filter
first
from
identity
ignoreElements
retry
throwIfEmpty
}
from
'
.
.
/
.
.
/
.
.
/
third_party
/
rxjs
/
rxjs
.
js
'
;
import
{
HandleFor
NodeFor
}
from
'
.
.
/
.
.
/
common
/
types
.
js
'
;
import
{
Frame
}
from
'
.
.
/
Frame
.
js
'
;
import
{
Page
}
from
'
.
.
/
Page
.
js
'
;
import
{
ActionOptions
Locator
RETRY_DELAY
}
from
'
.
/
locators
.
js
'
;
export
type
Action
<
T
U
>
=
(
element
:
HandleFor
<
T
>
signal
?
:
AbortSignal
)
=
>
Observable
<
U
>
;
export
class
NodeLocator
<
T
extends
Node
>
extends
Locator
<
T
>
{
static
create
<
Selector
extends
string
>
(
pageOrFrame
:
Page
|
Frame
selector
:
Selector
)
:
Locator
<
NodeFor
<
Selector
>
>
{
return
new
NodeLocator
<
NodeFor
<
Selector
>
>
(
pageOrFrame
selector
)
.
setTimeout
(
'
getDefaultTimeout
'
in
pageOrFrame
?
pageOrFrame
.
getDefaultTimeout
(
)
:
pageOrFrame
.
page
(
)
.
getDefaultTimeout
(
)
)
;
}
#
pageOrFrame
:
Page
|
Frame
;
#
selector
:
string
;
private
constructor
(
pageOrFrame
:
Page
|
Frame
selector
:
string
)
{
super
(
)
;
this
.
#
pageOrFrame
=
pageOrFrame
;
this
.
#
selector
=
selector
;
}
#
waitForVisibilityIfNeeded
=
(
handle
:
HandleFor
<
T
>
)
:
Observable
<
never
>
=
>
{
if
(
!
this
.
visibility
)
{
return
EMPTY
;
}
return
(
(
)
=
>
{
switch
(
this
.
visibility
)
{
case
'
hidden
'
:
return
defer
(
(
)
=
>
{
return
from
(
handle
.
isHidden
(
)
)
;
}
)
;
case
'
visible
'
:
return
defer
(
(
)
=
>
{
return
from
(
handle
.
isVisible
(
)
)
;
}
)
;
}
}
)
(
)
.
pipe
(
first
(
identity
)
retry
(
{
delay
:
RETRY_DELAY
}
)
ignoreElements
(
)
)
;
}
;
override
_clone
(
)
:
NodeLocator
<
T
>
{
return
new
NodeLocator
<
T
>
(
this
.
#
pageOrFrame
this
.
#
selector
)
.
copyOptions
(
this
)
;
}
override
_wait
(
options
?
:
Readonly
<
ActionOptions
>
)
:
Observable
<
HandleFor
<
T
>
>
{
const
signal
=
options
?
.
signal
;
return
defer
(
(
)
=
>
{
return
from
(
this
.
#
pageOrFrame
.
waitForSelector
(
this
.
#
selector
{
visible
:
false
timeout
:
this
.
_timeout
signal
}
)
as
Promise
<
HandleFor
<
T
>
|
null
>
)
;
}
)
.
pipe
(
filter
(
(
value
)
:
value
is
NonNullable
<
typeof
value
>
=
>
{
return
value
!
=
=
null
;
}
)
throwIfEmpty
(
)
this
.
operators
.
conditions
(
[
this
.
#
waitForVisibilityIfNeeded
]
signal
)
)
;
}
}
