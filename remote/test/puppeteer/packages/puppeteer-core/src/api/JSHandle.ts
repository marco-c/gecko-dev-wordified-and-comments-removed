import
Protocol
from
'
devtools
-
protocol
'
;
import
{
Symbol
}
from
'
.
.
/
.
.
/
third_party
/
disposablestack
/
disposablestack
.
js
'
;
import
{
EvaluateFuncWith
HandleFor
HandleOr
Moveable
}
from
'
.
.
/
common
/
types
.
js
'
;
import
{
debugError
withSourcePuppeteerURLIfNone
}
from
'
.
.
/
common
/
util
.
js
'
;
import
{
moveable
}
from
'
.
.
/
util
/
decorators
.
js
'
;
import
{
ElementHandle
}
from
'
.
/
ElementHandle
.
js
'
;
import
{
Realm
}
from
'
.
/
Realm
.
js
'
;
moveable
export
abstract
class
JSHandle
<
T
=
unknown
>
implements
Disposable
AsyncDisposable
Moveable
{
declare
move
:
(
)
=
>
this
;
declare
_
?
:
T
;
constructor
(
)
{
}
abstract
get
realm
(
)
:
Realm
;
get
disposed
(
)
:
boolean
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
T
Params
>
=
EvaluateFuncWith
<
T
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluate
.
name
pageFunction
)
;
return
await
this
.
realm
.
evaluate
(
pageFunction
this
.
.
.
args
)
;
}
async
evaluateHandle
<
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
T
Params
>
=
EvaluateFuncWith
<
T
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluateHandle
.
name
pageFunction
)
;
return
await
this
.
realm
.
evaluateHandle
(
pageFunction
this
.
.
.
args
)
;
}
getProperty
<
K
extends
keyof
T
>
(
propertyName
:
HandleOr
<
K
>
)
:
Promise
<
HandleFor
<
T
[
K
]
>
>
;
getProperty
(
propertyName
:
string
)
:
Promise
<
JSHandle
<
unknown
>
>
;
async
getProperty
<
K
extends
keyof
T
>
(
propertyName
:
HandleOr
<
K
>
)
:
Promise
<
HandleFor
<
T
[
K
]
>
>
{
return
await
this
.
evaluateHandle
(
(
object
propertyName
)
=
>
{
return
object
[
propertyName
as
K
]
;
}
propertyName
)
;
}
async
getProperties
(
)
:
Promise
<
Map
<
string
JSHandle
>
>
{
const
propertyNames
=
await
this
.
evaluate
(
object
=
>
{
const
enumerableProperties
=
[
]
;
const
descriptors
=
Object
.
getOwnPropertyDescriptors
(
object
)
;
for
(
const
propertyName
in
descriptors
)
{
if
(
descriptors
[
propertyName
]
?
.
enumerable
)
{
enumerableProperties
.
push
(
propertyName
)
;
}
}
return
enumerableProperties
;
}
)
;
const
map
=
new
Map
<
string
JSHandle
>
(
)
;
const
results
=
await
Promise
.
all
(
propertyNames
.
map
(
key
=
>
{
return
this
.
getProperty
(
key
)
;
}
)
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
propertyNames
)
)
{
using
handle
=
results
[
key
as
any
]
;
if
(
handle
)
{
map
.
set
(
value
handle
.
move
(
)
)
;
}
}
return
map
;
}
abstract
jsonValue
(
)
:
Promise
<
T
>
;
abstract
asElement
(
)
:
ElementHandle
<
Node
>
|
null
;
abstract
dispose
(
)
:
Promise
<
void
>
;
abstract
toString
(
)
:
string
;
abstract
get
id
(
)
:
string
|
undefined
;
abstract
remoteObject
(
)
:
Protocol
.
Runtime
.
RemoteObject
;
[
Symbol
.
dispose
]
(
)
:
void
{
return
void
this
.
dispose
(
)
.
catch
(
debugError
)
;
}
[
Symbol
.
asyncDispose
]
(
)
:
Promise
<
void
>
{
return
this
.
dispose
(
)
;
}
}
