import
type
{
Readable
}
from
'
stream
'
;
import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
filterAsync
first
firstValueFrom
from
fromEvent
map
merge
Observable
raceWith
delay
filter
of
switchMap
startWith
}
from
'
.
.
/
.
.
/
third_party
/
rxjs
/
rxjs
.
js
'
;
import
type
{
HTTPRequest
}
from
'
.
.
/
api
/
HTTPRequest
.
js
'
;
import
type
{
HTTPResponse
}
from
'
.
.
/
api
/
HTTPResponse
.
js
'
;
import
type
{
Accessibility
}
from
'
.
.
/
common
/
Accessibility
.
js
'
;
import
type
{
CDPSession
}
from
'
.
.
/
common
/
Connection
.
js
'
;
import
type
{
ConsoleMessage
}
from
'
.
.
/
common
/
ConsoleMessage
.
js
'
;
import
type
{
Coverage
}
from
'
.
.
/
common
/
Coverage
.
js
'
;
import
{
Device
}
from
'
.
.
/
common
/
Device
.
js
'
;
import
{
DeviceRequestPrompt
}
from
'
.
.
/
common
/
DeviceRequestPrompt
.
js
'
;
import
{
TargetCloseError
}
from
'
.
.
/
common
/
Errors
.
js
'
;
import
{
EventEmitter
Handler
}
from
'
.
.
/
common
/
EventEmitter
.
js
'
;
import
type
{
FileChooser
}
from
'
.
.
/
common
/
FileChooser
.
js
'
;
import
type
{
WaitForSelectorOptions
}
from
'
.
.
/
common
/
IsolatedWorld
.
js
'
;
import
type
{
PuppeteerLifeCycleEvent
}
from
'
.
.
/
common
/
LifecycleWatcher
.
js
'
;
import
{
Credentials
NetworkConditions
NetworkManagerEmittedEvents
}
from
'
.
.
/
common
/
NetworkManager
.
js
'
;
import
{
LowerCasePaperFormat
paperFormats
ParsedPDFOptions
PDFOptions
}
from
'
.
.
/
common
/
PDFOptions
.
js
'
;
import
type
{
Viewport
}
from
'
.
.
/
common
/
PuppeteerViewport
.
js
'
;
import
type
{
Tracing
}
from
'
.
.
/
common
/
Tracing
.
js
'
;
import
type
{
Awaitable
EvaluateFunc
EvaluateFuncWith
HandleFor
NodeFor
}
from
'
.
.
/
common
/
types
.
js
'
;
import
{
debugError
importFSPromises
isNumber
isString
timeout
withSourcePuppeteerURLIfNone
}
from
'
.
.
/
common
/
util
.
js
'
;
import
type
{
WebWorker
}
from
'
.
.
/
common
/
WebWorker
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
Deferred
}
from
'
.
.
/
util
/
Deferred
.
js
'
;
import
type
{
Browser
}
from
'
.
/
Browser
.
js
'
;
import
type
{
BrowserContext
}
from
'
.
/
BrowserContext
.
js
'
;
import
type
{
Dialog
}
from
'
.
/
Dialog
.
js
'
;
import
type
{
ClickOptions
ElementHandle
}
from
'
.
/
ElementHandle
.
js
'
;
import
type
{
Frame
FrameAddScriptTagOptions
FrameAddStyleTagOptions
FrameWaitForFunctionOptions
}
from
'
.
/
Frame
.
js
'
;
import
{
Keyboard
KeyboardTypeOptions
Mouse
Touchscreen
}
from
'
.
/
Input
.
js
'
;
import
type
{
JSHandle
}
from
'
.
/
JSHandle
.
js
'
;
import
{
AwaitedLocator
FunctionLocator
Locator
NodeLocator
}
from
'
.
/
locators
/
locators
.
js
'
;
import
type
{
Target
}
from
'
.
/
Target
.
js
'
;
export
interface
Metrics
{
Timestamp
?
:
number
;
Documents
?
:
number
;
Frames
?
:
number
;
JSEventListeners
?
:
number
;
Nodes
?
:
number
;
LayoutCount
?
:
number
;
RecalcStyleCount
?
:
number
;
LayoutDuration
?
:
number
;
RecalcStyleDuration
?
:
number
;
ScriptDuration
?
:
number
;
TaskDuration
?
:
number
;
JSHeapUsedSize
?
:
number
;
JSHeapTotalSize
?
:
number
;
}
export
interface
WaitTimeoutOptions
{
timeout
?
:
number
;
}
export
interface
WaitForOptions
{
timeout
?
:
number
;
waitUntil
?
:
PuppeteerLifeCycleEvent
|
PuppeteerLifeCycleEvent
[
]
;
}
export
interface
GeolocationOptions
{
longitude
:
number
;
latitude
:
number
;
accuracy
?
:
number
;
}
export
interface
MediaFeature
{
name
:
string
;
value
:
string
;
}
export
interface
ScreenshotClip
{
x
:
number
;
y
:
number
;
width
:
number
;
height
:
number
;
scale
?
:
number
;
}
export
interface
ScreenshotOptions
{
optimizeForSpeed
?
:
boolean
;
type
?
:
'
png
'
|
'
jpeg
'
|
'
webp
'
;
path
?
:
string
;
fullPage
?
:
boolean
;
clip
?
:
ScreenshotClip
;
quality
?
:
number
;
omitBackground
?
:
boolean
;
encoding
?
:
'
base64
'
|
'
binary
'
;
captureBeyondViewport
?
:
boolean
;
fromSurface
?
:
boolean
;
}
export
const
enum
PageEmittedEvents
{
Close
=
'
close
'
Console
=
'
console
'
Dialog
=
'
dialog
'
DOMContentLoaded
=
'
domcontentloaded
'
Error
=
'
error
'
FrameAttached
=
'
frameattached
'
FrameDetached
=
'
framedetached
'
FrameNavigated
=
'
framenavigated
'
Load
=
'
load
'
Metrics
=
'
metrics
'
PageError
=
'
pageerror
'
Popup
=
'
popup
'
Request
=
'
request
'
RequestServedFromCache
=
'
requestservedfromcache
'
RequestFailed
=
'
requestfailed
'
RequestFinished
=
'
requestfinished
'
Response
=
'
response
'
WorkerCreated
=
'
workercreated
'
WorkerDestroyed
=
'
workerdestroyed
'
}
export
interface
PageEventObject
{
close
:
never
;
console
:
ConsoleMessage
;
dialog
:
Dialog
;
domcontentloaded
:
never
;
error
:
Error
;
frameattached
:
Frame
;
framedetached
:
Frame
;
framenavigated
:
Frame
;
load
:
never
;
metrics
:
{
title
:
string
;
metrics
:
Metrics
}
;
pageerror
:
Error
;
popup
:
Page
;
request
:
HTTPRequest
;
response
:
HTTPResponse
;
requestfailed
:
HTTPRequest
;
requestfinished
:
HTTPRequest
;
requestservedfromcache
:
HTTPRequest
;
workercreated
:
WebWorker
;
workerdestroyed
:
WebWorker
;
}
export
interface
NewDocumentScriptEvaluation
{
identifier
:
string
;
}
export
abstract
class
Page
extends
EventEmitter
implements
AsyncDisposable
Disposable
{
#
handlerMap
=
new
WeakMap
<
Handler
<
any
>
Handler
<
any
>
>
(
)
;
constructor
(
)
{
super
(
)
;
}
isServiceWorkerBypassed
(
)
:
boolean
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
isDragInterceptionEnabled
(
)
:
boolean
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
isJavaScriptEnabled
(
)
:
boolean
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
override
on
<
K
extends
keyof
PageEventObject
>
(
eventName
:
K
handler
:
(
event
:
PageEventObject
[
K
]
)
=
>
void
)
:
this
{
if
(
eventName
=
=
=
'
request
'
)
{
const
wrap
=
this
.
#
handlerMap
.
get
(
handler
)
|
|
(
(
event
:
HTTPRequest
)
=
>
{
event
.
enqueueInterceptAction
(
(
)
=
>
{
return
handler
(
event
as
PageEventObject
[
K
]
)
;
}
)
;
}
)
;
this
.
#
handlerMap
.
set
(
handler
wrap
)
;
return
super
.
on
(
eventName
wrap
)
;
}
return
super
.
on
(
eventName
handler
)
;
}
override
once
<
K
extends
keyof
PageEventObject
>
(
eventName
:
K
handler
:
(
event
:
PageEventObject
[
K
]
)
=
>
void
)
:
this
{
return
super
.
once
(
eventName
handler
)
;
}
override
off
<
K
extends
keyof
PageEventObject
>
(
eventName
:
K
handler
:
(
event
:
PageEventObject
[
K
]
)
=
>
void
)
:
this
{
if
(
eventName
=
=
=
'
request
'
)
{
handler
=
this
.
#
handlerMap
.
get
(
handler
)
|
|
handler
;
}
return
super
.
off
(
eventName
handler
)
;
}
waitForFileChooser
(
options
?
:
WaitTimeoutOptions
)
:
Promise
<
FileChooser
>
;
waitForFileChooser
(
)
:
Promise
<
FileChooser
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setGeolocation
(
options
:
GeolocationOptions
)
:
Promise
<
void
>
;
async
setGeolocation
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
target
(
)
:
Target
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
browser
(
)
:
Browser
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
browserContext
(
)
:
BrowserContext
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
mainFrame
(
)
:
Frame
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
createCDPSession
(
)
:
Promise
<
CDPSession
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
get
keyboard
(
)
:
Keyboard
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
get
touchscreen
(
)
:
Touchscreen
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
get
coverage
(
)
:
Coverage
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
get
tracing
(
)
:
Tracing
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
get
accessibility
(
)
:
Accessibility
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
frames
(
)
:
Frame
[
]
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
workers
(
)
:
WebWorker
[
]
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setRequestInterception
(
value
:
boolean
)
:
Promise
<
void
>
;
async
setRequestInterception
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setBypassServiceWorker
(
bypass
:
boolean
)
:
Promise
<
void
>
;
async
setBypassServiceWorker
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setDragInterception
(
enabled
:
boolean
)
:
Promise
<
void
>
;
async
setDragInterception
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
setOfflineMode
(
enabled
:
boolean
)
:
Promise
<
void
>
;
setOfflineMode
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
emulateNetworkConditions
(
networkConditions
:
NetworkConditions
|
null
)
:
Promise
<
void
>
;
emulateNetworkConditions
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
setDefaultNavigationTimeout
(
timeout
:
number
)
:
void
;
setDefaultNavigationTimeout
(
)
:
void
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
setDefaultTimeout
(
timeout
:
number
)
:
void
;
setDefaultTimeout
(
)
:
void
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
getDefaultTimeout
(
)
:
number
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
locator
<
Selector
extends
string
>
(
selector
:
Selector
)
:
Locator
<
NodeFor
<
Selector
>
>
;
locator
<
Ret
>
(
func
:
(
)
=
>
Awaitable
<
Ret
>
)
:
Locator
<
Ret
>
;
locator
<
Selector
extends
string
Ret
>
(
selectorOrFunc
:
Selector
|
(
(
)
=
>
Awaitable
<
Ret
>
)
)
:
Locator
<
NodeFor
<
Selector
>
>
|
Locator
<
Ret
>
{
if
(
typeof
selectorOrFunc
=
=
=
'
string
'
)
{
return
NodeLocator
.
create
(
this
selectorOrFunc
)
;
}
else
{
return
FunctionLocator
.
create
(
this
selectorOrFunc
)
;
}
}
locatorRace
<
Locators
extends
readonly
unknown
[
]
|
[
]
>
(
locators
:
Locators
)
:
Locator
<
AwaitedLocator
<
Locators
[
number
]
>
>
{
return
Locator
.
race
(
locators
)
;
}
async
<
Selector
extends
string
>
(
selector
:
Selector
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
{
return
await
this
.
mainFrame
(
)
.
(
selector
)
;
}
async
<
Selector
extends
string
>
(
selector
:
Selector
)
:
Promise
<
Array
<
ElementHandle
<
NodeFor
<
Selector
>
>
>
>
{
return
await
this
.
mainFrame
(
)
.
(
selector
)
;
}
async
evaluateHandle
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluateHandle
.
name
pageFunction
)
;
return
await
this
.
mainFrame
(
)
.
evaluateHandle
(
pageFunction
.
.
.
args
)
;
}
async
queryObjects
<
Prototype
>
(
prototypeHandle
:
JSHandle
<
Prototype
>
)
:
Promise
<
JSHandle
<
Prototype
[
]
>
>
;
async
queryObjects
<
Prototype
>
(
)
:
Promise
<
JSHandle
<
Prototype
[
]
>
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
eval
<
Selector
extends
string
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
NodeFor
<
Selector
>
Params
>
=
EvaluateFuncWith
<
NodeFor
<
Selector
>
Params
>
>
(
selector
:
Selector
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
eval
.
name
pageFunction
)
;
return
await
this
.
mainFrame
(
)
.
eval
(
selector
pageFunction
.
.
.
args
)
;
}
async
eval
<
Selector
extends
string
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
Array
<
NodeFor
<
Selector
>
>
Params
>
=
EvaluateFuncWith
<
Array
<
NodeFor
<
Selector
>
>
Params
>
>
(
selector
:
Selector
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
eval
.
name
pageFunction
)
;
return
await
this
.
mainFrame
(
)
.
eval
(
selector
pageFunction
.
.
.
args
)
;
}
async
x
(
expression
:
string
)
:
Promise
<
Array
<
ElementHandle
<
Node
>
>
>
{
return
await
this
.
mainFrame
(
)
.
x
(
expression
)
;
}
async
cookies
(
.
.
.
urls
:
string
[
]
)
:
Promise
<
Protocol
.
Network
.
Cookie
[
]
>
;
async
cookies
(
)
:
Promise
<
Protocol
.
Network
.
Cookie
[
]
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
deleteCookie
(
.
.
.
cookies
:
Protocol
.
Network
.
DeleteCookiesRequest
[
]
)
:
Promise
<
void
>
;
async
deleteCookie
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setCookie
(
.
.
.
cookies
:
Protocol
.
Network
.
CookieParam
[
]
)
:
Promise
<
void
>
;
async
setCookie
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
addScriptTag
(
options
:
FrameAddScriptTagOptions
)
:
Promise
<
ElementHandle
<
HTMLScriptElement
>
>
{
return
await
this
.
mainFrame
(
)
.
addScriptTag
(
options
)
;
}
async
addStyleTag
(
options
:
Omit
<
FrameAddStyleTagOptions
'
url
'
>
)
:
Promise
<
ElementHandle
<
HTMLStyleElement
>
>
;
async
addStyleTag
(
options
:
FrameAddStyleTagOptions
)
:
Promise
<
ElementHandle
<
HTMLLinkElement
>
>
;
async
addStyleTag
(
options
:
FrameAddStyleTagOptions
)
:
Promise
<
ElementHandle
<
HTMLStyleElement
|
HTMLLinkElement
>
>
{
return
await
this
.
mainFrame
(
)
.
addStyleTag
(
options
)
;
}
abstract
exposeFunction
(
name
:
string
pptrFunction
:
Function
|
{
default
:
Function
}
)
:
Promise
<
void
>
;
async
removeExposedFunction
(
name
:
string
)
:
Promise
<
void
>
;
async
removeExposedFunction
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
authenticate
(
credentials
:
Credentials
)
:
Promise
<
void
>
;
async
authenticate
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setExtraHTTPHeaders
(
headers
:
Record
<
string
string
>
)
:
Promise
<
void
>
;
async
setExtraHTTPHeaders
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setUserAgent
(
userAgent
:
string
userAgentMetadata
?
:
Protocol
.
Emulation
.
UserAgentMetadata
)
:
Promise
<
void
>
;
async
setUserAgent
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
metrics
(
)
:
Promise
<
Metrics
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
url
(
)
:
string
{
return
this
.
mainFrame
(
)
.
url
(
)
;
}
async
content
(
)
:
Promise
<
string
>
{
return
await
this
.
mainFrame
(
)
.
content
(
)
;
}
async
setContent
(
html
:
string
options
?
:
WaitForOptions
)
:
Promise
<
void
>
{
await
this
.
mainFrame
(
)
.
setContent
(
html
options
)
;
}
async
goto
(
url
:
string
options
?
:
WaitForOptions
&
{
referer
?
:
string
;
referrerPolicy
?
:
string
}
)
:
Promise
<
HTTPResponse
|
null
>
{
return
await
this
.
mainFrame
(
)
.
goto
(
url
options
)
;
}
async
reload
(
options
?
:
WaitForOptions
)
:
Promise
<
HTTPResponse
|
null
>
;
async
reload
(
)
:
Promise
<
HTTPResponse
|
null
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
waitForNavigation
(
options
:
WaitForOptions
=
{
}
)
:
Promise
<
HTTPResponse
|
null
>
{
return
await
this
.
mainFrame
(
)
.
waitForNavigation
(
options
)
;
}
async
waitForRequest
(
urlOrPredicate
:
string
|
(
(
req
:
HTTPRequest
)
=
>
boolean
|
Promise
<
boolean
>
)
options
?
:
{
timeout
?
:
number
}
)
:
Promise
<
HTTPRequest
>
;
async
waitForRequest
(
)
:
Promise
<
HTTPRequest
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
waitForResponse
(
urlOrPredicate
:
|
string
|
(
(
res
:
HTTPResponse
)
=
>
boolean
|
Promise
<
boolean
>
)
options
?
:
{
timeout
?
:
number
}
)
:
Promise
<
HTTPResponse
>
;
async
waitForResponse
(
)
:
Promise
<
HTTPResponse
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
waitForNetworkIdle
(
options
?
:
{
idleTime
?
:
number
;
timeout
?
:
number
;
}
)
:
Promise
<
void
>
;
async
waitForNetworkIdle
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
protected
async
_waitForNetworkIdle
(
networkManager
:
EventEmitter
&
{
inFlightRequestsCount
:
(
)
=
>
number
;
}
idleTime
:
number
ms
:
number
closedDeferred
:
Deferred
<
TargetCloseError
>
)
:
Promise
<
void
>
{
await
firstValueFrom
(
merge
(
fromEvent
(
networkManager
NetworkManagerEmittedEvents
.
Request
as
unknown
as
string
)
fromEvent
(
networkManager
NetworkManagerEmittedEvents
.
Response
as
unknown
as
string
)
fromEvent
(
networkManager
NetworkManagerEmittedEvents
.
RequestFailed
as
unknown
as
string
)
)
.
pipe
(
startWith
(
null
)
filter
(
(
)
=
>
{
return
networkManager
.
inFlightRequestsCount
(
)
=
=
=
0
;
}
)
switchMap
(
v
=
>
{
return
of
(
v
)
.
pipe
(
delay
(
idleTime
)
)
;
}
)
raceWith
(
timeout
(
ms
)
from
(
closedDeferred
.
valueOrThrow
(
)
)
)
)
)
;
}
async
waitForFrame
(
urlOrPredicate
:
string
|
(
(
frame
:
Frame
)
=
>
Awaitable
<
boolean
>
)
options
:
WaitTimeoutOptions
=
{
}
)
:
Promise
<
Frame
>
{
const
{
timeout
:
ms
=
this
.
getDefaultTimeout
(
)
}
=
options
;
if
(
isString
(
urlOrPredicate
)
)
{
urlOrPredicate
=
(
frame
:
Frame
)
=
>
{
return
urlOrPredicate
=
=
=
frame
.
url
(
)
;
}
;
}
return
await
firstValueFrom
(
merge
(
fromEvent
(
this
PageEmittedEvents
.
FrameAttached
)
as
Observable
<
Frame
>
fromEvent
(
this
PageEmittedEvents
.
FrameNavigated
)
as
Observable
<
Frame
>
from
(
this
.
frames
(
)
)
)
.
pipe
(
filterAsync
(
urlOrPredicate
)
first
(
)
raceWith
(
timeout
(
ms
)
fromEvent
(
this
PageEmittedEvents
.
Close
)
.
pipe
(
map
(
(
)
=
>
{
throw
new
TargetCloseError
(
'
Page
closed
.
'
)
;
}
)
)
)
)
)
;
}
async
goBack
(
options
?
:
WaitForOptions
)
:
Promise
<
HTTPResponse
|
null
>
;
async
goBack
(
)
:
Promise
<
HTTPResponse
|
null
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
goForward
(
options
?
:
WaitForOptions
)
:
Promise
<
HTTPResponse
|
null
>
;
async
goForward
(
)
:
Promise
<
HTTPResponse
|
null
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
bringToFront
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
emulate
(
device
:
Device
)
:
Promise
<
void
>
{
await
Promise
.
all
(
[
this
.
setUserAgent
(
device
.
userAgent
)
this
.
setViewport
(
device
.
viewport
)
]
)
;
}
async
setJavaScriptEnabled
(
enabled
:
boolean
)
:
Promise
<
void
>
;
async
setJavaScriptEnabled
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setBypassCSP
(
enabled
:
boolean
)
:
Promise
<
void
>
;
async
setBypassCSP
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
emulateMediaType
(
type
?
:
string
)
:
Promise
<
void
>
;
async
emulateMediaType
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
emulateCPUThrottling
(
factor
:
number
|
null
)
:
Promise
<
void
>
;
async
emulateCPUThrottling
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
emulateMediaFeatures
(
features
?
:
MediaFeature
[
]
)
:
Promise
<
void
>
;
async
emulateMediaFeatures
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
emulateTimezone
(
timezoneId
?
:
string
)
:
Promise
<
void
>
;
async
emulateTimezone
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
emulateIdleState
(
overrides
?
:
{
isUserActive
:
boolean
;
isScreenUnlocked
:
boolean
;
}
)
:
Promise
<
void
>
;
async
emulateIdleState
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
emulateVisionDeficiency
(
type
?
:
Protocol
.
Emulation
.
SetEmulatedVisionDeficiencyRequest
[
'
type
'
]
)
:
Promise
<
void
>
;
async
emulateVisionDeficiency
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setViewport
(
viewport
:
Viewport
)
:
Promise
<
void
>
;
async
setViewport
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
viewport
(
)
:
Viewport
|
null
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluate
.
name
pageFunction
)
;
return
await
this
.
mainFrame
(
)
.
evaluate
(
pageFunction
.
.
.
args
)
;
}
async
evaluateOnNewDocument
<
Params
extends
unknown
[
]
Func
extends
(
.
.
.
args
:
Params
)
=
>
unknown
=
(
.
.
.
args
:
Params
)
=
>
unknown
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
NewDocumentScriptEvaluation
>
;
async
evaluateOnNewDocument
(
)
:
Promise
<
NewDocumentScriptEvaluation
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
removeScriptToEvaluateOnNewDocument
(
identifier
:
string
)
:
Promise
<
void
>
;
async
removeScriptToEvaluateOnNewDocument
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
setCacheEnabled
(
enabled
?
:
boolean
)
:
Promise
<
void
>
;
async
setCacheEnabled
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
_maybeWriteBufferToFile
(
path
:
string
|
undefined
buffer
:
Buffer
)
:
Promise
<
void
>
{
if
(
!
path
)
{
return
;
}
const
fs
=
await
importFSPromises
(
)
;
await
fs
.
writeFile
(
path
buffer
)
;
}
screenshot
(
options
:
ScreenshotOptions
&
{
encoding
:
'
base64
'
}
)
:
Promise
<
string
>
;
screenshot
(
options
?
:
ScreenshotOptions
&
{
encoding
?
:
'
binary
'
}
)
:
Promise
<
Buffer
>
;
async
screenshot
(
options
?
:
ScreenshotOptions
)
:
Promise
<
Buffer
|
string
>
;
async
screenshot
(
)
:
Promise
<
Buffer
|
string
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
_getPDFOptions
(
options
:
PDFOptions
=
{
}
lengthUnit
:
'
in
'
|
'
cm
'
=
'
in
'
)
:
ParsedPDFOptions
{
const
defaults
=
{
scale
:
1
displayHeaderFooter
:
false
headerTemplate
:
'
'
footerTemplate
:
'
'
printBackground
:
false
landscape
:
false
pageRanges
:
'
'
preferCSSPageSize
:
false
omitBackground
:
false
timeout
:
30000
}
;
let
width
=
8
.
5
;
let
height
=
11
;
if
(
options
.
format
)
{
const
format
=
paperFormats
[
options
.
format
.
toLowerCase
(
)
as
LowerCasePaperFormat
]
;
assert
(
format
'
Unknown
paper
format
:
'
+
options
.
format
)
;
width
=
format
.
width
;
height
=
format
.
height
;
}
else
{
width
=
convertPrintParameterToInches
(
options
.
width
lengthUnit
)
?
?
width
;
height
=
convertPrintParameterToInches
(
options
.
height
lengthUnit
)
?
?
height
;
}
const
margin
=
{
top
:
convertPrintParameterToInches
(
options
.
margin
?
.
top
lengthUnit
)
|
|
0
left
:
convertPrintParameterToInches
(
options
.
margin
?
.
left
lengthUnit
)
|
|
0
bottom
:
convertPrintParameterToInches
(
options
.
margin
?
.
bottom
lengthUnit
)
|
|
0
right
:
convertPrintParameterToInches
(
options
.
margin
?
.
right
lengthUnit
)
|
|
0
}
;
const
output
=
{
.
.
.
defaults
.
.
.
options
width
height
margin
}
;
return
output
;
}
async
createPDFStream
(
options
?
:
PDFOptions
)
:
Promise
<
Readable
>
;
async
createPDFStream
(
)
:
Promise
<
Readable
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
pdf
(
options
?
:
PDFOptions
)
:
Promise
<
Buffer
>
;
async
pdf
(
)
:
Promise
<
Buffer
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
title
(
)
:
Promise
<
string
>
{
return
await
this
.
mainFrame
(
)
.
title
(
)
;
}
async
close
(
options
?
:
{
runBeforeUnload
?
:
boolean
}
)
:
Promise
<
void
>
;
async
close
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
isClosed
(
)
:
boolean
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
get
mouse
(
)
:
Mouse
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
click
(
selector
:
string
options
?
:
Readonly
<
ClickOptions
>
)
:
Promise
<
void
>
{
return
this
.
mainFrame
(
)
.
click
(
selector
options
)
;
}
focus
(
selector
:
string
)
:
Promise
<
void
>
{
return
this
.
mainFrame
(
)
.
focus
(
selector
)
;
}
hover
(
selector
:
string
)
:
Promise
<
void
>
{
return
this
.
mainFrame
(
)
.
hover
(
selector
)
;
}
select
(
selector
:
string
.
.
.
values
:
string
[
]
)
:
Promise
<
string
[
]
>
{
return
this
.
mainFrame
(
)
.
select
(
selector
.
.
.
values
)
;
}
tap
(
selector
:
string
)
:
Promise
<
void
>
{
return
this
.
mainFrame
(
)
.
tap
(
selector
)
;
}
type
(
selector
:
string
text
:
string
options
?
:
Readonly
<
KeyboardTypeOptions
>
)
:
Promise
<
void
>
{
return
this
.
mainFrame
(
)
.
type
(
selector
text
options
)
;
}
waitForTimeout
(
milliseconds
:
number
)
:
Promise
<
void
>
{
return
this
.
mainFrame
(
)
.
waitForTimeout
(
milliseconds
)
;
}
async
waitForSelector
<
Selector
extends
string
>
(
selector
:
Selector
options
:
WaitForSelectorOptions
=
{
}
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
{
return
await
this
.
mainFrame
(
)
.
waitForSelector
(
selector
options
)
;
}
waitForXPath
(
xpath
:
string
options
?
:
WaitForSelectorOptions
)
:
Promise
<
ElementHandle
<
Node
>
|
null
>
{
return
this
.
mainFrame
(
)
.
waitForXPath
(
xpath
options
)
;
}
waitForFunction
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
options
?
:
FrameWaitForFunctionOptions
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
return
this
.
mainFrame
(
)
.
waitForFunction
(
pageFunction
options
.
.
.
args
)
;
}
waitForDevicePrompt
(
options
?
:
WaitTimeoutOptions
)
:
Promise
<
DeviceRequestPrompt
>
;
waitForDevicePrompt
(
)
:
Promise
<
DeviceRequestPrompt
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
[
Symbol
.
dispose
]
(
)
:
void
{
return
void
this
.
close
(
)
.
catch
(
debugError
)
;
}
[
Symbol
.
asyncDispose
]
(
)
:
Promise
<
void
>
{
return
this
.
close
(
)
;
}
}
export
const
supportedMetrics
=
new
Set
<
string
>
(
[
'
Timestamp
'
'
Documents
'
'
Frames
'
'
JSEventListeners
'
'
Nodes
'
'
LayoutCount
'
'
RecalcStyleCount
'
'
LayoutDuration
'
'
RecalcStyleDuration
'
'
ScriptDuration
'
'
TaskDuration
'
'
JSHeapUsedSize
'
'
JSHeapTotalSize
'
]
)
;
export
const
unitToPixels
=
{
px
:
1
in
:
96
cm
:
37
.
8
mm
:
3
.
78
}
;
function
convertPrintParameterToInches
(
parameter
?
:
string
|
number
lengthUnit
:
'
in
'
|
'
cm
'
=
'
in
'
)
:
number
|
undefined
{
if
(
typeof
parameter
=
=
=
'
undefined
'
)
{
return
undefined
;
}
let
pixels
;
if
(
isNumber
(
parameter
)
)
{
pixels
=
parameter
;
}
else
if
(
isString
(
parameter
)
)
{
const
text
=
parameter
;
let
unit
=
text
.
substring
(
text
.
length
-
2
)
.
toLowerCase
(
)
;
let
valueText
=
'
'
;
if
(
unit
in
unitToPixels
)
{
valueText
=
text
.
substring
(
0
text
.
length
-
2
)
;
}
else
{
unit
=
'
px
'
;
valueText
=
text
;
}
const
value
=
Number
(
valueText
)
;
assert
(
!
isNaN
(
value
)
'
Failed
to
parse
parameter
value
:
'
+
text
)
;
pixels
=
value
*
unitToPixels
[
unit
as
keyof
typeof
unitToPixels
]
;
}
else
{
throw
new
Error
(
'
page
.
pdf
(
)
Cannot
handle
parameter
type
:
'
+
typeof
parameter
)
;
}
return
pixels
/
unitToPixels
[
lengthUnit
]
;
}
