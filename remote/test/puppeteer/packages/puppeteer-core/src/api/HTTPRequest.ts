import
type
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
type
{
ProtocolError
}
from
'
.
.
/
common
/
Errors
.
js
'
;
import
{
debugError
isString
}
from
'
.
.
/
common
/
util
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
type
{
CDPSession
}
from
'
.
/
CDPSession
.
js
'
;
import
type
{
Frame
}
from
'
.
/
Frame
.
js
'
;
import
type
{
HTTPResponse
}
from
'
.
/
HTTPResponse
.
js
'
;
export
interface
ContinueRequestOverrides
{
url
?
:
string
;
method
?
:
string
;
postData
?
:
string
;
headers
?
:
Record
<
string
string
>
;
}
export
interface
InterceptResolutionState
{
action
:
InterceptResolutionAction
;
priority
?
:
number
;
}
export
interface
ResponseForRequest
{
status
:
number
;
headers
:
Record
<
string
unknown
>
;
contentType
:
string
;
body
:
string
|
Uint8Array
;
}
export
type
ResourceType
=
Lowercase
<
Protocol
.
Network
.
ResourceType
>
;
export
const
DEFAULT_INTERCEPT_RESOLUTION_PRIORITY
=
0
;
export
abstract
class
HTTPRequest
{
abstract
get
id
(
)
:
string
;
_interceptionId
:
string
|
undefined
;
_failureText
:
string
|
null
=
null
;
_response
:
HTTPResponse
|
null
=
null
;
_fromMemoryCache
=
false
;
_redirectChain
:
HTTPRequest
[
]
=
[
]
;
protected
interception
:
{
enabled
:
boolean
;
handled
:
boolean
;
handlers
:
Array
<
(
)
=
>
void
|
PromiseLike
<
any
>
>
;
resolutionState
:
InterceptResolutionState
;
requestOverrides
:
ContinueRequestOverrides
;
response
:
Partial
<
ResponseForRequest
>
|
null
;
abortReason
:
Protocol
.
Network
.
ErrorReason
|
null
;
}
=
{
enabled
:
false
handled
:
false
handlers
:
[
]
resolutionState
:
{
action
:
InterceptResolutionAction
.
None
}
requestOverrides
:
{
}
response
:
null
abortReason
:
null
}
;
abstract
get
client
(
)
:
CDPSession
;
constructor
(
)
{
}
abstract
url
(
)
:
string
;
continueRequestOverrides
(
)
:
ContinueRequestOverrides
{
assert
(
this
.
interception
.
enabled
'
Request
Interception
is
not
enabled
!
'
)
;
return
this
.
interception
.
requestOverrides
;
}
responseForRequest
(
)
:
Partial
<
ResponseForRequest
>
|
null
{
assert
(
this
.
interception
.
enabled
'
Request
Interception
is
not
enabled
!
'
)
;
return
this
.
interception
.
response
;
}
abortErrorReason
(
)
:
Protocol
.
Network
.
ErrorReason
|
null
{
assert
(
this
.
interception
.
enabled
'
Request
Interception
is
not
enabled
!
'
)
;
return
this
.
interception
.
abortReason
;
}
interceptResolutionState
(
)
:
InterceptResolutionState
{
if
(
!
this
.
interception
.
enabled
)
{
return
{
action
:
InterceptResolutionAction
.
Disabled
}
;
}
if
(
this
.
interception
.
handled
)
{
return
{
action
:
InterceptResolutionAction
.
AlreadyHandled
}
;
}
return
{
.
.
.
this
.
interception
.
resolutionState
}
;
}
isInterceptResolutionHandled
(
)
:
boolean
{
return
this
.
interception
.
handled
;
}
enqueueInterceptAction
(
pendingHandler
:
(
)
=
>
void
|
PromiseLike
<
unknown
>
)
:
void
{
this
.
interception
.
handlers
.
push
(
pendingHandler
)
;
}
abstract
_abort
(
errorReason
:
Protocol
.
Network
.
ErrorReason
|
null
)
:
Promise
<
void
>
;
abstract
_respond
(
response
:
Partial
<
ResponseForRequest
>
)
:
Promise
<
void
>
;
abstract
_continue
(
overrides
:
ContinueRequestOverrides
)
:
Promise
<
void
>
;
async
finalizeInterceptions
(
)
:
Promise
<
void
>
{
await
this
.
interception
.
handlers
.
reduce
(
(
promiseChain
interceptAction
)
=
>
{
return
promiseChain
.
then
(
interceptAction
)
;
}
Promise
.
resolve
(
)
)
;
this
.
interception
.
handlers
=
[
]
;
const
{
action
}
=
this
.
interceptResolutionState
(
)
;
switch
(
action
)
{
case
'
abort
'
:
return
await
this
.
_abort
(
this
.
interception
.
abortReason
)
;
case
'
respond
'
:
if
(
this
.
interception
.
response
=
=
=
null
)
{
throw
new
Error
(
'
Response
is
missing
for
the
interception
'
)
;
}
return
await
this
.
_respond
(
this
.
interception
.
response
)
;
case
'
continue
'
:
return
await
this
.
_continue
(
this
.
interception
.
requestOverrides
)
;
}
}
abstract
resourceType
(
)
:
ResourceType
;
abstract
method
(
)
:
string
;
abstract
postData
(
)
:
string
|
undefined
;
abstract
hasPostData
(
)
:
boolean
;
abstract
fetchPostData
(
)
:
Promise
<
string
|
undefined
>
;
abstract
headers
(
)
:
Record
<
string
string
>
;
abstract
response
(
)
:
HTTPResponse
|
null
;
abstract
frame
(
)
:
Frame
|
null
;
abstract
isNavigationRequest
(
)
:
boolean
;
abstract
initiator
(
)
:
Protocol
.
Network
.
Initiator
|
undefined
;
abstract
redirectChain
(
)
:
HTTPRequest
[
]
;
abstract
failure
(
)
:
{
errorText
:
string
}
|
null
;
async
continue
(
overrides
:
ContinueRequestOverrides
=
{
}
priority
?
:
number
)
:
Promise
<
void
>
{
if
(
this
.
url
(
)
.
startsWith
(
'
data
:
'
)
)
{
return
;
}
assert
(
this
.
interception
.
enabled
'
Request
Interception
is
not
enabled
!
'
)
;
assert
(
!
this
.
interception
.
handled
'
Request
is
already
handled
!
'
)
;
if
(
priority
=
=
=
undefined
)
{
return
await
this
.
_continue
(
overrides
)
;
}
this
.
interception
.
requestOverrides
=
overrides
;
if
(
this
.
interception
.
resolutionState
.
priority
=
=
=
undefined
|
|
priority
>
this
.
interception
.
resolutionState
.
priority
)
{
this
.
interception
.
resolutionState
=
{
action
:
InterceptResolutionAction
.
Continue
priority
}
;
return
;
}
if
(
priority
=
=
=
this
.
interception
.
resolutionState
.
priority
)
{
if
(
this
.
interception
.
resolutionState
.
action
=
=
=
'
abort
'
|
|
this
.
interception
.
resolutionState
.
action
=
=
=
'
respond
'
)
{
return
;
}
this
.
interception
.
resolutionState
.
action
=
InterceptResolutionAction
.
Continue
;
}
return
;
}
async
respond
(
response
:
Partial
<
ResponseForRequest
>
priority
?
:
number
)
:
Promise
<
void
>
{
if
(
this
.
url
(
)
.
startsWith
(
'
data
:
'
)
)
{
return
;
}
assert
(
this
.
interception
.
enabled
'
Request
Interception
is
not
enabled
!
'
)
;
assert
(
!
this
.
interception
.
handled
'
Request
is
already
handled
!
'
)
;
if
(
priority
=
=
=
undefined
)
{
return
await
this
.
_respond
(
response
)
;
}
this
.
interception
.
response
=
response
;
if
(
this
.
interception
.
resolutionState
.
priority
=
=
=
undefined
|
|
priority
>
this
.
interception
.
resolutionState
.
priority
)
{
this
.
interception
.
resolutionState
=
{
action
:
InterceptResolutionAction
.
Respond
priority
}
;
return
;
}
if
(
priority
=
=
=
this
.
interception
.
resolutionState
.
priority
)
{
if
(
this
.
interception
.
resolutionState
.
action
=
=
=
'
abort
'
)
{
return
;
}
this
.
interception
.
resolutionState
.
action
=
InterceptResolutionAction
.
Respond
;
}
}
async
abort
(
errorCode
:
ErrorCode
=
'
failed
'
priority
?
:
number
)
:
Promise
<
void
>
{
if
(
this
.
url
(
)
.
startsWith
(
'
data
:
'
)
)
{
return
;
}
const
errorReason
=
errorReasons
[
errorCode
]
;
assert
(
errorReason
'
Unknown
error
code
:
'
+
errorCode
)
;
assert
(
this
.
interception
.
enabled
'
Request
Interception
is
not
enabled
!
'
)
;
assert
(
!
this
.
interception
.
handled
'
Request
is
already
handled
!
'
)
;
if
(
priority
=
=
=
undefined
)
{
return
await
this
.
_abort
(
errorReason
)
;
}
this
.
interception
.
abortReason
=
errorReason
;
if
(
this
.
interception
.
resolutionState
.
priority
=
=
=
undefined
|
|
priority
>
=
this
.
interception
.
resolutionState
.
priority
)
{
this
.
interception
.
resolutionState
=
{
action
:
InterceptResolutionAction
.
Abort
priority
}
;
return
;
}
}
static
getResponse
(
body
:
string
|
Uint8Array
)
:
{
contentLength
:
number
;
base64
:
string
;
}
{
const
byteBody
:
Uint8Array
=
isString
(
body
)
?
new
TextEncoder
(
)
.
encode
(
body
)
:
body
;
const
bytes
=
[
]
;
for
(
const
byte
of
byteBody
)
{
bytes
.
push
(
String
.
fromCharCode
(
byte
)
)
;
}
return
{
contentLength
:
byteBody
.
byteLength
base64
:
btoa
(
bytes
.
join
(
'
'
)
)
}
;
}
}
export
enum
InterceptResolutionAction
{
Abort
=
'
abort
'
Respond
=
'
respond
'
Continue
=
'
continue
'
Disabled
=
'
disabled
'
None
=
'
none
'
AlreadyHandled
=
'
already
-
handled
'
}
export
type
ErrorCode
=
|
'
aborted
'
|
'
accessdenied
'
|
'
addressunreachable
'
|
'
blockedbyclient
'
|
'
blockedbyresponse
'
|
'
connectionaborted
'
|
'
connectionclosed
'
|
'
connectionfailed
'
|
'
connectionrefused
'
|
'
connectionreset
'
|
'
internetdisconnected
'
|
'
namenotresolved
'
|
'
timedout
'
|
'
failed
'
;
export
type
ActionResult
=
'
continue
'
|
'
abort
'
|
'
respond
'
;
export
function
headersArray
(
headers
:
Record
<
string
string
|
string
[
]
>
)
:
Array
<
{
name
:
string
;
value
:
string
}
>
{
const
result
=
[
]
;
for
(
const
name
in
headers
)
{
const
value
=
headers
[
name
]
;
if
(
!
Object
.
is
(
value
undefined
)
)
{
const
values
=
Array
.
isArray
(
value
)
?
value
:
[
value
]
;
result
.
push
(
.
.
.
values
.
map
(
value
=
>
{
return
{
name
value
:
value
+
'
'
}
;
}
)
)
;
}
}
return
result
;
}
export
const
STATUS_TEXTS
:
Record
<
string
string
>
=
{
'
100
'
:
'
Continue
'
'
101
'
:
'
Switching
Protocols
'
'
102
'
:
'
Processing
'
'
103
'
:
'
Early
Hints
'
'
200
'
:
'
OK
'
'
201
'
:
'
Created
'
'
202
'
:
'
Accepted
'
'
203
'
:
'
Non
-
Authoritative
Information
'
'
204
'
:
'
No
Content
'
'
205
'
:
'
Reset
Content
'
'
206
'
:
'
Partial
Content
'
'
207
'
:
'
Multi
-
Status
'
'
208
'
:
'
Already
Reported
'
'
226
'
:
'
IM
Used
'
'
300
'
:
'
Multiple
Choices
'
'
301
'
:
'
Moved
Permanently
'
'
302
'
:
'
Found
'
'
303
'
:
'
See
Other
'
'
304
'
:
'
Not
Modified
'
'
305
'
:
'
Use
Proxy
'
'
306
'
:
'
Switch
Proxy
'
'
307
'
:
'
Temporary
Redirect
'
'
308
'
:
'
Permanent
Redirect
'
'
400
'
:
'
Bad
Request
'
'
401
'
:
'
Unauthorized
'
'
402
'
:
'
Payment
Required
'
'
403
'
:
'
Forbidden
'
'
404
'
:
'
Not
Found
'
'
405
'
:
'
Method
Not
Allowed
'
'
406
'
:
'
Not
Acceptable
'
'
407
'
:
'
Proxy
Authentication
Required
'
'
408
'
:
'
Request
Timeout
'
'
409
'
:
'
Conflict
'
'
410
'
:
'
Gone
'
'
411
'
:
'
Length
Required
'
'
412
'
:
'
Precondition
Failed
'
'
413
'
:
'
Payload
Too
Large
'
'
414
'
:
'
URI
Too
Long
'
'
415
'
:
'
Unsupported
Media
Type
'
'
416
'
:
'
Range
Not
Satisfiable
'
'
417
'
:
'
Expectation
Failed
'
'
418
'
:
"
I
'
m
a
teapot
"
'
421
'
:
'
Misdirected
Request
'
'
422
'
:
'
Unprocessable
Entity
'
'
423
'
:
'
Locked
'
'
424
'
:
'
Failed
Dependency
'
'
425
'
:
'
Too
Early
'
'
426
'
:
'
Upgrade
Required
'
'
428
'
:
'
Precondition
Required
'
'
429
'
:
'
Too
Many
Requests
'
'
431
'
:
'
Request
Header
Fields
Too
Large
'
'
451
'
:
'
Unavailable
For
Legal
Reasons
'
'
500
'
:
'
Internal
Server
Error
'
'
501
'
:
'
Not
Implemented
'
'
502
'
:
'
Bad
Gateway
'
'
503
'
:
'
Service
Unavailable
'
'
504
'
:
'
Gateway
Timeout
'
'
505
'
:
'
HTTP
Version
Not
Supported
'
'
506
'
:
'
Variant
Also
Negotiates
'
'
507
'
:
'
Insufficient
Storage
'
'
508
'
:
'
Loop
Detected
'
'
510
'
:
'
Not
Extended
'
'
511
'
:
'
Network
Authentication
Required
'
}
as
const
;
const
errorReasons
:
Record
<
ErrorCode
Protocol
.
Network
.
ErrorReason
>
=
{
aborted
:
'
Aborted
'
accessdenied
:
'
AccessDenied
'
addressunreachable
:
'
AddressUnreachable
'
blockedbyclient
:
'
BlockedByClient
'
blockedbyresponse
:
'
BlockedByResponse
'
connectionaborted
:
'
ConnectionAborted
'
connectionclosed
:
'
ConnectionClosed
'
connectionfailed
:
'
ConnectionFailed
'
connectionrefused
:
'
ConnectionRefused
'
connectionreset
:
'
ConnectionReset
'
internetdisconnected
:
'
InternetDisconnected
'
namenotresolved
:
'
NameNotResolved
'
timedout
:
'
TimedOut
'
failed
:
'
Failed
'
}
as
const
;
export
function
handleError
(
error
:
ProtocolError
)
:
void
{
if
(
error
.
originalMessage
.
includes
(
'
Invalid
header
'
)
|
|
error
.
originalMessage
.
includes
(
'
Expected
"
header
"
'
)
|
|
error
.
originalMessage
.
includes
(
'
invalid
argument
'
)
)
{
throw
error
;
}
debugError
(
error
)
;
}
