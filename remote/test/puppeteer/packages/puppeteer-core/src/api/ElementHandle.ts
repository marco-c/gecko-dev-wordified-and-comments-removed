import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
CDPSession
}
from
'
.
.
/
common
/
Connection
.
js
'
;
import
{
ExecutionContext
}
from
'
.
.
/
common
/
ExecutionContext
.
js
'
;
import
{
Frame
}
from
'
.
.
/
common
/
Frame
.
js
'
;
import
{
MouseClickOptions
}
from
'
.
.
/
common
/
Input
.
js
'
;
import
{
WaitForSelectorOptions
}
from
'
.
.
/
common
/
IsolatedWorld
.
js
'
;
import
{
ElementFor
EvaluateFuncWith
HandleFor
HandleOr
NodeFor
}
from
'
.
.
/
common
/
types
.
js
'
;
import
{
KeyInput
}
from
'
.
.
/
common
/
USKeyboardLayout
.
js
'
;
import
{
JSHandle
}
from
'
.
/
JSHandle
.
js
'
;
import
{
ScreenshotOptions
}
from
'
.
/
Page
.
js
'
;
export
interface
BoxModel
{
content
:
Point
[
]
;
padding
:
Point
[
]
;
border
:
Point
[
]
;
margin
:
Point
[
]
;
width
:
number
;
height
:
number
;
}
export
interface
BoundingBox
extends
Point
{
width
:
number
;
height
:
number
;
}
export
interface
Offset
{
x
:
number
;
y
:
number
;
}
export
interface
ClickOptions
extends
MouseClickOptions
{
offset
?
:
Offset
;
}
export
interface
PressOptions
{
delay
?
:
number
;
text
?
:
string
;
}
export
interface
Point
{
x
:
number
;
y
:
number
;
}
export
class
ElementHandle
<
ElementType
extends
Node
=
Element
>
extends
JSHandle
<
ElementType
>
{
protected
handle
;
constructor
(
handle
:
JSHandle
<
ElementType
>
)
{
super
(
)
;
this
.
handle
=
handle
;
}
override
get
id
(
)
:
string
|
undefined
{
return
this
.
handle
.
id
;
}
override
get
disposed
(
)
:
boolean
{
return
this
.
handle
.
disposed
;
}
override
async
getProperty
<
K
extends
keyof
ElementType
>
(
propertyName
:
HandleOr
<
K
>
)
:
Promise
<
HandleFor
<
ElementType
[
K
]
>
>
;
override
async
getProperty
(
propertyName
:
string
)
:
Promise
<
JSHandle
<
unknown
>
>
;
override
async
getProperty
<
K
extends
keyof
ElementType
>
(
propertyName
:
HandleOr
<
K
>
)
:
Promise
<
HandleFor
<
ElementType
[
K
]
>
>
{
return
this
.
handle
.
getProperty
(
propertyName
)
;
}
override
async
getProperties
(
)
:
Promise
<
Map
<
string
JSHandle
>
>
{
return
this
.
handle
.
getProperties
(
)
;
}
override
async
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
ElementType
Params
>
=
EvaluateFuncWith
<
ElementType
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
return
this
.
handle
.
evaluate
(
pageFunction
.
.
.
args
)
;
}
override
evaluateHandle
<
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
ElementType
Params
>
=
EvaluateFuncWith
<
ElementType
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
return
this
.
handle
.
evaluateHandle
(
pageFunction
.
.
.
args
)
;
}
override
async
jsonValue
(
)
:
Promise
<
ElementType
>
{
return
this
.
handle
.
jsonValue
(
)
;
}
override
toString
(
)
:
string
{
return
this
.
handle
.
toString
(
)
;
}
override
async
dispose
(
)
:
Promise
<
void
>
{
return
await
this
.
handle
.
dispose
(
)
;
}
override
asElement
(
)
:
ElementHandle
<
ElementType
>
{
return
this
;
}
override
executionContext
(
)
:
ExecutionContext
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
override
get
client
(
)
:
CDPSession
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
get
frame
(
)
:
Frame
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
<
Selector
extends
string
>
(
selector
:
Selector
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
;
async
<
Selector
extends
string
>
(
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
<
Selector
extends
string
>
(
selector
:
Selector
)
:
Promise
<
Array
<
ElementHandle
<
NodeFor
<
Selector
>
>
>
>
;
async
<
Selector
extends
string
>
(
)
:
Promise
<
Array
<
ElementHandle
<
NodeFor
<
Selector
>
>
>
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
eval
<
Selector
extends
string
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
NodeFor
<
Selector
>
Params
>
=
EvaluateFuncWith
<
NodeFor
<
Selector
>
Params
>
>
(
selector
:
Selector
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
;
async
eval
(
)
:
Promise
<
unknown
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
eval
<
Selector
extends
string
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
Array
<
NodeFor
<
Selector
>
>
Params
>
=
EvaluateFuncWith
<
Array
<
NodeFor
<
Selector
>
>
Params
>
>
(
selector
:
Selector
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
;
async
eval
(
)
:
Promise
<
unknown
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
x
(
expression
:
string
)
:
Promise
<
Array
<
ElementHandle
<
Node
>
>
>
;
async
x
(
)
:
Promise
<
Array
<
ElementHandle
<
Node
>
>
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
waitForSelector
<
Selector
extends
string
>
(
selector
:
Selector
options
?
:
WaitForSelectorOptions
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
;
async
waitForSelector
<
Selector
extends
string
>
(
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
isVisible
(
)
:
Promise
<
boolean
>
{
throw
new
Error
(
'
Not
implemented
.
'
)
;
}
async
isHidden
(
)
:
Promise
<
boolean
>
{
throw
new
Error
(
'
Not
implemented
.
'
)
;
}
async
waitForXPath
(
xpath
:
string
options
?
:
{
visible
?
:
boolean
;
hidden
?
:
boolean
;
timeout
?
:
number
;
}
)
:
Promise
<
ElementHandle
<
Node
>
|
null
>
;
async
waitForXPath
(
)
:
Promise
<
ElementHandle
<
Node
>
|
null
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
toElement
<
K
extends
keyof
HTMLElementTagNameMap
|
keyof
SVGElementTagNameMap
>
(
tagName
:
K
)
:
Promise
<
HandleFor
<
ElementFor
<
K
>
>
>
;
async
toElement
<
K
extends
keyof
HTMLElementTagNameMap
|
keyof
SVGElementTagNameMap
>
(
)
:
Promise
<
HandleFor
<
ElementFor
<
K
>
>
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
contentFrame
(
)
:
Promise
<
Frame
|
null
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
clickablePoint
(
offset
?
:
Offset
)
:
Promise
<
Point
>
;
async
clickablePoint
(
)
:
Promise
<
Point
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
hover
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
click
(
this
:
ElementHandle
<
Element
>
options
?
:
ClickOptions
)
:
Promise
<
void
>
;
async
click
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
drag
(
this
:
ElementHandle
<
Element
>
target
:
Point
)
:
Promise
<
Protocol
.
Input
.
DragData
>
;
async
drag
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
Protocol
.
Input
.
DragData
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
dragEnter
(
this
:
ElementHandle
<
Element
>
data
?
:
Protocol
.
Input
.
DragData
)
:
Promise
<
void
>
;
async
dragEnter
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
dragOver
(
this
:
ElementHandle
<
Element
>
data
?
:
Protocol
.
Input
.
DragData
)
:
Promise
<
void
>
;
async
dragOver
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
drop
(
this
:
ElementHandle
<
Element
>
data
?
:
Protocol
.
Input
.
DragData
)
:
Promise
<
void
>
;
async
drop
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
dragAndDrop
(
this
:
ElementHandle
<
Element
>
target
:
ElementHandle
<
Node
>
options
?
:
{
delay
:
number
}
)
:
Promise
<
void
>
;
async
dragAndDrop
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
select
(
.
.
.
values
:
string
[
]
)
:
Promise
<
string
[
]
>
;
async
select
(
)
:
Promise
<
string
[
]
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
uploadFile
(
this
:
ElementHandle
<
HTMLInputElement
>
.
.
.
paths
:
string
[
]
)
:
Promise
<
void
>
;
async
uploadFile
(
this
:
ElementHandle
<
HTMLInputElement
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
tap
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
touchStart
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
touchMove
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
touchEnd
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
focus
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
type
(
text
:
string
options
?
:
{
delay
:
number
}
)
:
Promise
<
void
>
;
async
type
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
press
(
key
:
KeyInput
options
?
:
PressOptions
)
:
Promise
<
void
>
;
async
press
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
boundingBox
(
)
:
Promise
<
BoundingBox
|
null
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
boxModel
(
)
:
Promise
<
BoxModel
|
null
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
screenshot
(
this
:
ElementHandle
<
Element
>
options
?
:
ScreenshotOptions
)
:
Promise
<
string
|
Buffer
>
;
async
screenshot
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
string
|
Buffer
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
protected
async
assertConnectedElement
(
)
:
Promise
<
void
>
{
const
error
=
await
this
.
evaluate
(
async
(
element
)
:
Promise
<
string
|
undefined
>
=
>
{
if
(
!
element
.
isConnected
)
{
return
'
Node
is
detached
from
document
'
;
}
if
(
element
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
'
Node
is
not
of
type
HTMLElement
'
;
}
return
;
}
)
;
if
(
error
)
{
throw
new
Error
(
error
)
;
}
}
async
isIntersectingViewport
(
this
:
ElementHandle
<
Element
>
options
?
:
{
threshold
?
:
number
;
}
)
:
Promise
<
boolean
>
{
await
this
.
assertConnectedElement
(
)
;
const
{
threshold
=
0
}
=
options
?
?
{
}
;
const
svgHandle
=
await
this
.
#
asSVGElementHandle
(
this
)
;
const
intersectionTarget
:
ElementHandle
<
Element
>
=
svgHandle
?
await
this
.
#
getOwnerSVGElement
(
svgHandle
)
:
this
;
try
{
return
await
intersectionTarget
.
evaluate
(
async
(
element
threshold
)
=
>
{
const
visibleRatio
=
await
new
Promise
<
number
>
(
resolve
=
>
{
const
observer
=
new
IntersectionObserver
(
entries
=
>
{
resolve
(
entries
[
0
]
!
.
intersectionRatio
)
;
observer
.
disconnect
(
)
;
}
)
;
observer
.
observe
(
element
)
;
}
)
;
return
threshold
=
=
=
1
?
visibleRatio
=
=
=
1
:
visibleRatio
>
threshold
;
}
threshold
)
;
}
finally
{
if
(
intersectionTarget
!
=
=
this
)
{
await
intersectionTarget
.
dispose
(
)
;
}
}
}
async
scrollIntoView
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
#
asSVGElementHandle
(
handle
:
ElementHandle
<
Element
>
)
:
Promise
<
ElementHandle
<
SVGElement
>
|
null
>
{
if
(
await
handle
.
evaluate
(
element
=
>
{
return
element
instanceof
SVGElement
;
}
)
)
{
return
handle
as
ElementHandle
<
SVGElement
>
;
}
else
{
return
null
;
}
}
async
#
getOwnerSVGElement
(
handle
:
ElementHandle
<
SVGElement
>
)
:
Promise
<
ElementHandle
<
SVGSVGElement
>
>
{
return
await
handle
.
evaluateHandle
(
element
=
>
{
if
(
element
instanceof
SVGSVGElement
)
{
return
element
;
}
return
element
.
ownerSVGElement
!
;
}
)
;
}
}
