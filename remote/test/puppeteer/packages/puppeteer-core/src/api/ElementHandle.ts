import
type
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
type
{
Frame
}
from
'
.
.
/
api
/
Frame
.
js
'
;
import
{
getQueryHandlerAndSelector
}
from
'
.
.
/
common
/
GetQueryHandler
.
js
'
;
import
{
LazyArg
}
from
'
.
.
/
common
/
LazyArg
.
js
'
;
import
type
{
ElementFor
EvaluateFuncWith
HandleFor
HandleOr
NodeFor
}
from
'
.
.
/
common
/
types
.
js
'
;
import
type
{
KeyInput
}
from
'
.
.
/
common
/
USKeyboardLayout
.
js
'
;
import
{
isString
withSourcePuppeteerURLIfNone
}
from
'
.
.
/
common
/
util
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
AsyncIterableUtil
}
from
'
.
.
/
util
/
AsyncIterableUtil
.
js
'
;
import
{
throwIfDisposed
}
from
'
.
.
/
util
/
decorators
.
js
'
;
import
{
_isElementHandle
}
from
'
.
/
ElementHandleSymbol
.
js
'
;
import
type
{
KeyboardTypeOptions
KeyPressOptions
MouseClickOptions
}
from
'
.
/
Input
.
js
'
;
import
{
JSHandle
}
from
'
.
/
JSHandle
.
js
'
;
import
type
{
ScreenshotOptions
WaitForSelectorOptions
}
from
'
.
/
Page
.
js
'
;
export
type
Quad
=
[
Point
Point
Point
Point
]
;
export
interface
BoxModel
{
content
:
Quad
;
padding
:
Quad
;
border
:
Quad
;
margin
:
Quad
;
width
:
number
;
height
:
number
;
}
export
interface
BoundingBox
extends
Point
{
width
:
number
;
height
:
number
;
}
export
interface
Offset
{
x
:
number
;
y
:
number
;
}
export
interface
ClickOptions
extends
MouseClickOptions
{
offset
?
:
Offset
;
}
export
interface
Point
{
x
:
number
;
y
:
number
;
}
export
interface
ElementScreenshotOptions
extends
ScreenshotOptions
{
scrollIntoView
?
:
boolean
;
}
export
abstract
class
ElementHandle
<
ElementType
extends
Node
=
Element
>
extends
JSHandle
<
ElementType
>
{
declare
[
_isElementHandle
]
:
boolean
;
static
bindIsolatedHandle
<
This
extends
ElementHandle
<
Node
>
>
(
target
:
(
this
:
This
.
.
.
args
:
any
[
]
)
=
>
Promise
<
any
>
_
:
unknown
)
:
typeof
target
{
return
async
function
(
.
.
.
args
)
{
if
(
this
.
realm
=
=
=
this
.
frame
.
isolatedRealm
(
)
)
{
return
await
target
.
call
(
this
.
.
.
args
)
;
}
using
adoptedThis
=
await
this
.
frame
.
isolatedRealm
(
)
.
adoptHandle
(
this
)
;
const
result
=
await
target
.
call
(
adoptedThis
.
.
.
args
)
;
if
(
result
=
=
=
adoptedThis
)
{
return
this
;
}
if
(
result
instanceof
JSHandle
)
{
return
await
this
.
realm
.
transferHandle
(
result
)
;
}
if
(
Array
.
isArray
(
result
)
)
{
await
Promise
.
all
(
result
.
map
(
async
(
item
index
result
)
=
>
{
if
(
item
instanceof
JSHandle
)
{
result
[
index
]
=
await
this
.
realm
.
transferHandle
(
item
)
;
}
}
)
)
;
}
if
(
result
instanceof
Map
)
{
await
Promise
.
all
(
[
.
.
.
result
.
entries
(
)
]
.
map
(
async
(
[
key
value
]
)
=
>
{
if
(
value
instanceof
JSHandle
)
{
result
.
set
(
key
await
this
.
realm
.
transferHandle
(
value
)
)
;
}
}
)
)
;
}
return
result
;
}
;
}
protected
readonly
handle
;
constructor
(
handle
:
JSHandle
<
ElementType
>
)
{
super
(
)
;
this
.
handle
=
handle
;
this
[
_isElementHandle
]
=
true
;
}
override
get
id
(
)
:
string
|
undefined
{
return
this
.
handle
.
id
;
}
override
get
disposed
(
)
:
boolean
{
return
this
.
handle
.
disposed
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
override
async
getProperty
<
K
extends
keyof
ElementType
>
(
propertyName
:
HandleOr
<
K
>
)
:
Promise
<
HandleFor
<
ElementType
[
K
]
>
>
{
return
await
this
.
handle
.
getProperty
(
propertyName
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
override
async
getProperties
(
)
:
Promise
<
Map
<
string
JSHandle
>
>
{
return
await
this
.
handle
.
getProperties
(
)
;
}
override
async
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
ElementType
Params
>
=
EvaluateFuncWith
<
ElementType
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluate
.
name
pageFunction
)
;
return
await
this
.
handle
.
evaluate
(
pageFunction
.
.
.
args
)
;
}
override
async
evaluateHandle
<
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
ElementType
Params
>
=
EvaluateFuncWith
<
ElementType
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
evaluateHandle
.
name
pageFunction
)
;
return
await
this
.
handle
.
evaluateHandle
(
pageFunction
.
.
.
args
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
override
async
jsonValue
(
)
:
Promise
<
ElementType
>
{
return
await
this
.
handle
.
jsonValue
(
)
;
}
override
toString
(
)
:
string
{
return
this
.
handle
.
toString
(
)
;
}
override
remoteObject
(
)
:
Protocol
.
Runtime
.
RemoteObject
{
return
this
.
handle
.
remoteObject
(
)
;
}
override
dispose
(
)
:
Promise
<
void
>
{
return
this
.
handle
.
dispose
(
)
;
}
override
asElement
(
)
:
ElementHandle
<
ElementType
>
{
return
this
;
}
abstract
get
frame
(
)
:
Frame
;
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
<
Selector
extends
string
>
(
selector
:
Selector
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
{
const
{
updatedSelector
QueryHandler
}
=
getQueryHandlerAndSelector
(
selector
)
;
return
(
await
QueryHandler
.
queryOne
(
this
updatedSelector
)
)
as
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
<
Selector
extends
string
>
(
selector
:
Selector
)
:
Promise
<
Array
<
ElementHandle
<
NodeFor
<
Selector
>
>
>
>
{
const
{
updatedSelector
QueryHandler
}
=
getQueryHandlerAndSelector
(
selector
)
;
return
await
(
AsyncIterableUtil
.
collect
(
QueryHandler
.
queryAll
(
this
updatedSelector
)
)
as
Promise
<
Array
<
ElementHandle
<
NodeFor
<
Selector
>
>
>
>
)
;
}
async
eval
<
Selector
extends
string
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
NodeFor
<
Selector
>
Params
>
=
EvaluateFuncWith
<
NodeFor
<
Selector
>
Params
>
>
(
selector
:
Selector
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
eval
.
name
pageFunction
)
;
using
elementHandle
=
await
this
.
(
selector
)
;
if
(
!
elementHandle
)
{
throw
new
Error
(
Error
:
failed
to
find
element
matching
selector
"
{
selector
}
"
)
;
}
return
await
elementHandle
.
evaluate
(
pageFunction
.
.
.
args
)
;
}
async
eval
<
Selector
extends
string
Params
extends
unknown
[
]
Func
extends
EvaluateFuncWith
<
Array
<
NodeFor
<
Selector
>
>
Params
>
=
EvaluateFuncWith
<
Array
<
NodeFor
<
Selector
>
>
Params
>
>
(
selector
:
Selector
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
pageFunction
=
withSourcePuppeteerURLIfNone
(
this
.
eval
.
name
pageFunction
)
;
const
results
=
await
this
.
(
selector
)
;
using
elements
=
await
this
.
evaluateHandle
(
(
_
.
.
.
elements
)
=
>
{
return
elements
;
}
.
.
.
results
)
;
const
[
result
]
=
await
Promise
.
all
(
[
elements
.
evaluate
(
pageFunction
.
.
.
args
)
.
.
.
results
.
map
(
results
=
>
{
return
results
.
dispose
(
)
;
}
)
]
)
;
return
result
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
waitForSelector
<
Selector
extends
string
>
(
selector
:
Selector
options
:
WaitForSelectorOptions
=
{
}
)
:
Promise
<
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
>
{
const
{
updatedSelector
QueryHandler
}
=
getQueryHandlerAndSelector
(
selector
)
;
return
(
await
QueryHandler
.
waitFor
(
this
updatedSelector
options
)
)
as
ElementHandle
<
NodeFor
<
Selector
>
>
|
null
;
}
async
#
checkVisibility
(
visibility
:
boolean
)
:
Promise
<
boolean
>
{
return
await
this
.
evaluate
(
async
(
element
PuppeteerUtil
visibility
)
=
>
{
return
Boolean
(
PuppeteerUtil
.
checkVisibility
(
element
visibility
)
)
;
}
LazyArg
.
create
(
context
=
>
{
return
context
.
puppeteerUtil
;
}
)
visibility
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
isVisible
(
)
:
Promise
<
boolean
>
{
return
await
this
.
#
checkVisibility
(
true
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
isHidden
(
)
:
Promise
<
boolean
>
{
return
await
this
.
#
checkVisibility
(
false
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
toElement
<
K
extends
keyof
HTMLElementTagNameMap
|
keyof
SVGElementTagNameMap
>
(
tagName
:
K
)
:
Promise
<
HandleFor
<
ElementFor
<
K
>
>
>
{
const
isMatchingTagName
=
await
this
.
evaluate
(
(
node
tagName
)
=
>
{
return
node
.
nodeName
=
=
=
tagName
.
toUpperCase
(
)
;
}
tagName
)
;
if
(
!
isMatchingTagName
)
{
throw
new
Error
(
Element
is
not
a
(
n
)
\
{
tagName
}
\
element
)
;
}
return
this
as
unknown
as
HandleFor
<
ElementFor
<
K
>
>
;
}
abstract
contentFrame
(
this
:
ElementHandle
<
HTMLIFrameElement
>
)
:
Promise
<
Frame
>
;
abstract
contentFrame
(
)
:
Promise
<
Frame
|
null
>
;
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
clickablePoint
(
offset
?
:
Offset
)
:
Promise
<
Point
>
{
const
box
=
await
this
.
#
clickableBox
(
)
;
if
(
!
box
)
{
throw
new
Error
(
'
Node
is
either
not
clickable
or
not
an
Element
'
)
;
}
if
(
offset
!
=
=
undefined
)
{
return
{
x
:
box
.
x
+
offset
.
x
y
:
box
.
y
+
offset
.
y
}
;
}
return
{
x
:
box
.
x
+
box
.
width
/
2
y
:
box
.
y
+
box
.
height
/
2
}
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
hover
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
{
x
y
}
=
await
this
.
clickablePoint
(
)
;
await
this
.
frame
.
page
(
)
.
mouse
.
move
(
x
y
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
click
(
this
:
ElementHandle
<
Element
>
options
:
Readonly
<
ClickOptions
>
=
{
}
)
:
Promise
<
void
>
{
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
{
x
y
}
=
await
this
.
clickablePoint
(
options
.
offset
)
;
await
this
.
frame
.
page
(
)
.
mouse
.
click
(
x
y
options
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
drag
(
this
:
ElementHandle
<
Element
>
target
:
Point
|
ElementHandle
<
Element
>
)
:
Promise
<
Protocol
.
Input
.
DragData
|
void
>
{
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
page
=
this
.
frame
.
page
(
)
;
if
(
page
.
isDragInterceptionEnabled
(
)
)
{
const
source
=
await
this
.
clickablePoint
(
)
;
if
(
target
instanceof
ElementHandle
)
{
target
=
await
target
.
clickablePoint
(
)
;
}
return
await
page
.
mouse
.
drag
(
source
target
)
;
}
try
{
if
(
!
page
.
_isDragging
)
{
page
.
_isDragging
=
true
;
await
this
.
hover
(
)
;
await
page
.
mouse
.
down
(
)
;
}
if
(
target
instanceof
ElementHandle
)
{
await
target
.
hover
(
)
;
}
else
{
await
page
.
mouse
.
move
(
target
.
x
target
.
y
)
;
}
}
catch
(
error
)
{
page
.
_isDragging
=
false
;
throw
error
;
}
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
dragEnter
(
this
:
ElementHandle
<
Element
>
data
:
Protocol
.
Input
.
DragData
=
{
items
:
[
]
dragOperationsMask
:
1
}
)
:
Promise
<
void
>
{
const
page
=
this
.
frame
.
page
(
)
;
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
target
=
await
this
.
clickablePoint
(
)
;
await
page
.
mouse
.
dragEnter
(
target
data
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
dragOver
(
this
:
ElementHandle
<
Element
>
data
:
Protocol
.
Input
.
DragData
=
{
items
:
[
]
dragOperationsMask
:
1
}
)
:
Promise
<
void
>
{
const
page
=
this
.
frame
.
page
(
)
;
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
target
=
await
this
.
clickablePoint
(
)
;
await
page
.
mouse
.
dragOver
(
target
data
)
;
}
async
drop
(
this
:
ElementHandle
<
Element
>
element
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
;
async
drop
(
this
:
ElementHandle
<
Element
>
data
?
:
Protocol
.
Input
.
DragData
)
:
Promise
<
void
>
;
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
drop
(
this
:
ElementHandle
<
Element
>
dataOrElement
:
ElementHandle
<
Element
>
|
Protocol
.
Input
.
DragData
=
{
items
:
[
]
dragOperationsMask
:
1
}
)
:
Promise
<
void
>
{
const
page
=
this
.
frame
.
page
(
)
;
if
(
'
items
'
in
dataOrElement
)
{
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
destination
=
await
this
.
clickablePoint
(
)
;
await
page
.
mouse
.
drop
(
destination
dataOrElement
)
;
}
else
{
await
dataOrElement
.
drag
(
this
)
;
page
.
_isDragging
=
false
;
await
page
.
mouse
.
up
(
)
;
}
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
dragAndDrop
(
this
:
ElementHandle
<
Element
>
target
:
ElementHandle
<
Node
>
options
?
:
{
delay
:
number
}
)
:
Promise
<
void
>
{
const
page
=
this
.
frame
.
page
(
)
;
assert
(
page
.
isDragInterceptionEnabled
(
)
'
Drag
Interception
is
not
enabled
!
'
)
;
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
startPoint
=
await
this
.
clickablePoint
(
)
;
const
targetPoint
=
await
target
.
clickablePoint
(
)
;
await
page
.
mouse
.
dragAndDrop
(
startPoint
targetPoint
options
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
select
(
.
.
.
values
:
string
[
]
)
:
Promise
<
string
[
]
>
{
for
(
const
value
of
values
)
{
assert
(
isString
(
value
)
'
Values
must
be
strings
.
Found
value
"
'
+
value
+
'
"
of
type
"
'
+
typeof
value
+
'
"
'
)
;
}
return
await
this
.
evaluate
(
(
element
vals
)
:
string
[
]
=
>
{
const
values
=
new
Set
(
vals
)
;
if
(
!
(
element
instanceof
HTMLSelectElement
)
)
{
throw
new
Error
(
'
Element
is
not
a
<
select
>
element
.
'
)
;
}
const
selectedValues
=
new
Set
<
string
>
(
)
;
if
(
!
element
.
multiple
)
{
for
(
const
option
of
element
.
options
)
{
option
.
selected
=
false
;
}
for
(
const
option
of
element
.
options
)
{
if
(
values
.
has
(
option
.
value
)
)
{
option
.
selected
=
true
;
selectedValues
.
add
(
option
.
value
)
;
break
;
}
}
}
else
{
for
(
const
option
of
element
.
options
)
{
option
.
selected
=
values
.
has
(
option
.
value
)
;
if
(
option
.
selected
)
{
selectedValues
.
add
(
option
.
value
)
;
}
}
}
element
.
dispatchEvent
(
new
Event
(
'
input
'
{
bubbles
:
true
}
)
)
;
element
.
dispatchEvent
(
new
Event
(
'
change
'
{
bubbles
:
true
}
)
)
;
return
[
.
.
.
selectedValues
.
values
(
)
]
;
}
values
)
;
}
abstract
uploadFile
(
this
:
ElementHandle
<
HTMLInputElement
>
.
.
.
paths
:
string
[
]
)
:
Promise
<
void
>
;
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
tap
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
{
x
y
}
=
await
this
.
clickablePoint
(
)
;
await
this
.
frame
.
page
(
)
.
touchscreen
.
tap
(
x
y
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
touchStart
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
{
x
y
}
=
await
this
.
clickablePoint
(
)
;
await
this
.
frame
.
page
(
)
.
touchscreen
.
touchStart
(
x
y
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
touchMove
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
await
this
.
scrollIntoViewIfNeeded
(
)
;
const
{
x
y
}
=
await
this
.
clickablePoint
(
)
;
await
this
.
frame
.
page
(
)
.
touchscreen
.
touchMove
(
x
y
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
touchEnd
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
await
this
.
scrollIntoViewIfNeeded
(
)
;
await
this
.
frame
.
page
(
)
.
touchscreen
.
touchEnd
(
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
focus
(
)
:
Promise
<
void
>
{
await
this
.
evaluate
(
element
=
>
{
if
(
!
(
element
instanceof
HTMLElement
)
)
{
throw
new
Error
(
'
Cannot
focus
non
-
HTMLElement
'
)
;
}
return
element
.
focus
(
)
;
}
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
type
(
text
:
string
options
?
:
Readonly
<
KeyboardTypeOptions
>
)
:
Promise
<
void
>
{
await
this
.
focus
(
)
;
await
this
.
frame
.
page
(
)
.
keyboard
.
type
(
text
options
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
press
(
key
:
KeyInput
options
?
:
Readonly
<
KeyPressOptions
>
)
:
Promise
<
void
>
{
await
this
.
focus
(
)
;
await
this
.
frame
.
page
(
)
.
keyboard
.
press
(
key
options
)
;
}
async
#
clickableBox
(
)
:
Promise
<
BoundingBox
|
null
>
{
const
boxes
=
await
this
.
evaluate
(
element
=
>
{
if
(
!
(
element
instanceof
Element
)
)
{
return
null
;
}
return
[
.
.
.
element
.
getClientRects
(
)
]
.
map
(
rect
=
>
{
return
{
x
:
rect
.
x
y
:
rect
.
y
width
:
rect
.
width
height
:
rect
.
height
}
;
}
)
;
}
)
;
if
(
!
boxes
?
.
length
)
{
return
null
;
}
await
this
.
#
intersectBoundingBoxesWithFrame
(
boxes
)
;
let
frame
=
this
.
frame
;
let
parentFrame
:
Frame
|
null
|
undefined
;
while
(
(
parentFrame
=
frame
?
.
parentFrame
(
)
)
)
{
using
handle
=
await
frame
.
frameElement
(
)
;
if
(
!
handle
)
{
throw
new
Error
(
'
Unsupported
frame
type
'
)
;
}
const
parentBox
=
await
handle
.
evaluate
(
element
=
>
{
if
(
element
.
getClientRects
(
)
.
length
=
=
=
0
)
{
return
null
;
}
const
rect
=
element
.
getBoundingClientRect
(
)
;
const
style
=
window
.
getComputedStyle
(
element
)
;
return
{
left
:
rect
.
left
+
parseInt
(
style
.
paddingLeft
10
)
+
parseInt
(
style
.
borderLeftWidth
10
)
top
:
rect
.
top
+
parseInt
(
style
.
paddingTop
10
)
+
parseInt
(
style
.
borderTopWidth
10
)
}
;
}
)
;
if
(
!
parentBox
)
{
return
null
;
}
for
(
const
box
of
boxes
)
{
box
.
x
+
=
parentBox
.
left
;
box
.
y
+
=
parentBox
.
top
;
}
await
handle
.
#
intersectBoundingBoxesWithFrame
(
boxes
)
;
frame
=
parentFrame
;
}
const
box
=
boxes
.
find
(
box
=
>
{
return
box
.
width
>
=
1
&
&
box
.
height
>
=
1
;
}
)
;
if
(
!
box
)
{
return
null
;
}
return
{
x
:
box
.
x
y
:
box
.
y
height
:
box
.
height
width
:
box
.
width
}
;
}
async
#
intersectBoundingBoxesWithFrame
(
boxes
:
BoundingBox
[
]
)
{
const
{
documentWidth
documentHeight
}
=
await
this
.
frame
.
isolatedRealm
(
)
.
evaluate
(
(
)
=
>
{
return
{
documentWidth
:
document
.
documentElement
.
clientWidth
documentHeight
:
document
.
documentElement
.
clientHeight
}
;
}
)
;
for
(
const
box
of
boxes
)
{
intersectBoundingBox
(
box
documentWidth
documentHeight
)
;
}
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
boundingBox
(
)
:
Promise
<
BoundingBox
|
null
>
{
const
box
=
await
this
.
evaluate
(
element
=
>
{
if
(
!
(
element
instanceof
Element
)
)
{
return
null
;
}
if
(
element
.
getClientRects
(
)
.
length
=
=
=
0
)
{
return
null
;
}
const
rect
=
element
.
getBoundingClientRect
(
)
;
return
{
x
:
rect
.
x
y
:
rect
.
y
width
:
rect
.
width
height
:
rect
.
height
}
;
}
)
;
if
(
!
box
)
{
return
null
;
}
const
offset
=
await
this
.
#
getTopLeftCornerOfFrame
(
)
;
if
(
!
offset
)
{
return
null
;
}
return
{
x
:
box
.
x
+
offset
.
x
y
:
box
.
y
+
offset
.
y
height
:
box
.
height
width
:
box
.
width
}
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
boxModel
(
)
:
Promise
<
BoxModel
|
null
>
{
const
model
=
await
this
.
evaluate
(
element
=
>
{
if
(
!
(
element
instanceof
Element
)
)
{
return
null
;
}
if
(
element
.
getClientRects
(
)
.
length
=
=
=
0
)
{
return
null
;
}
const
rect
=
element
.
getBoundingClientRect
(
)
;
const
style
=
window
.
getComputedStyle
(
element
)
;
const
offsets
=
{
padding
:
{
left
:
parseInt
(
style
.
paddingLeft
10
)
top
:
parseInt
(
style
.
paddingTop
10
)
right
:
parseInt
(
style
.
paddingRight
10
)
bottom
:
parseInt
(
style
.
paddingBottom
10
)
}
margin
:
{
left
:
-
parseInt
(
style
.
marginLeft
10
)
top
:
-
parseInt
(
style
.
marginTop
10
)
right
:
-
parseInt
(
style
.
marginRight
10
)
bottom
:
-
parseInt
(
style
.
marginBottom
10
)
}
border
:
{
left
:
parseInt
(
style
.
borderLeft
10
)
top
:
parseInt
(
style
.
borderTop
10
)
right
:
parseInt
(
style
.
borderRight
10
)
bottom
:
parseInt
(
style
.
borderBottom
10
)
}
}
;
const
border
:
Quad
=
[
{
x
:
rect
.
left
y
:
rect
.
top
}
{
x
:
rect
.
left
+
rect
.
width
y
:
rect
.
top
}
{
x
:
rect
.
left
+
rect
.
width
y
:
rect
.
top
+
rect
.
bottom
}
{
x
:
rect
.
left
y
:
rect
.
top
+
rect
.
bottom
}
]
;
const
padding
=
transformQuadWithOffsets
(
border
offsets
.
border
)
;
const
content
=
transformQuadWithOffsets
(
padding
offsets
.
padding
)
;
const
margin
=
transformQuadWithOffsets
(
border
offsets
.
margin
)
;
return
{
content
padding
border
margin
width
:
rect
.
width
height
:
rect
.
height
}
;
function
transformQuadWithOffsets
(
quad
:
Quad
offsets
:
{
top
:
number
;
left
:
number
;
right
:
number
;
bottom
:
number
}
)
:
Quad
{
return
[
{
x
:
quad
[
0
]
.
x
+
offsets
.
left
y
:
quad
[
0
]
.
y
+
offsets
.
top
}
{
x
:
quad
[
1
]
.
x
-
offsets
.
right
y
:
quad
[
1
]
.
y
+
offsets
.
top
}
{
x
:
quad
[
2
]
.
x
-
offsets
.
right
y
:
quad
[
2
]
.
y
-
offsets
.
bottom
}
{
x
:
quad
[
3
]
.
x
+
offsets
.
left
y
:
quad
[
3
]
.
y
-
offsets
.
bottom
}
]
;
}
}
)
;
if
(
!
model
)
{
return
null
;
}
const
offset
=
await
this
.
#
getTopLeftCornerOfFrame
(
)
;
if
(
!
offset
)
{
return
null
;
}
for
(
const
attribute
of
[
'
content
'
'
padding
'
'
border
'
'
margin
'
]
as
const
)
{
for
(
const
point
of
model
[
attribute
]
)
{
point
.
x
+
=
offset
.
x
;
point
.
y
+
=
offset
.
y
;
}
}
return
model
;
}
async
#
getTopLeftCornerOfFrame
(
)
{
const
point
=
{
x
:
0
y
:
0
}
;
let
frame
=
this
.
frame
;
let
parentFrame
:
Frame
|
null
|
undefined
;
while
(
(
parentFrame
=
frame
?
.
parentFrame
(
)
)
)
{
using
handle
=
await
frame
.
frameElement
(
)
;
if
(
!
handle
)
{
throw
new
Error
(
'
Unsupported
frame
type
'
)
;
}
const
parentBox
=
await
handle
.
evaluate
(
element
=
>
{
if
(
element
.
getClientRects
(
)
.
length
=
=
=
0
)
{
return
null
;
}
const
rect
=
element
.
getBoundingClientRect
(
)
;
const
style
=
window
.
getComputedStyle
(
element
)
;
return
{
left
:
rect
.
left
+
parseInt
(
style
.
paddingLeft
10
)
+
parseInt
(
style
.
borderLeftWidth
10
)
top
:
rect
.
top
+
parseInt
(
style
.
paddingTop
10
)
+
parseInt
(
style
.
borderTopWidth
10
)
}
;
}
)
;
if
(
!
parentBox
)
{
return
null
;
}
point
.
x
+
=
parentBox
.
left
;
point
.
y
+
=
parentBox
.
top
;
frame
=
parentFrame
;
}
return
point
;
}
async
screenshot
(
options
:
Readonly
<
ScreenshotOptions
>
&
{
encoding
:
'
base64
'
}
)
:
Promise
<
string
>
;
async
screenshot
(
options
?
:
Readonly
<
ScreenshotOptions
>
)
:
Promise
<
Buffer
>
;
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
screenshot
(
this
:
ElementHandle
<
Element
>
options
:
Readonly
<
ElementScreenshotOptions
>
=
{
}
)
:
Promise
<
string
|
Buffer
>
{
const
{
scrollIntoView
=
true
clip
}
=
options
;
let
elementClip
=
await
this
.
#
nonEmptyVisibleBoundingBox
(
)
;
const
page
=
this
.
frame
.
page
(
)
;
if
(
scrollIntoView
)
{
await
this
.
scrollIntoViewIfNeeded
(
)
;
elementClip
=
await
this
.
#
nonEmptyVisibleBoundingBox
(
)
;
}
const
[
pageLeft
pageTop
]
=
await
this
.
evaluate
(
(
)
=
>
{
if
(
!
window
.
visualViewport
)
{
throw
new
Error
(
'
window
.
visualViewport
is
not
supported
.
'
)
;
}
return
[
window
.
visualViewport
.
pageLeft
window
.
visualViewport
.
pageTop
]
as
const
;
}
)
;
elementClip
.
x
+
=
pageLeft
;
elementClip
.
y
+
=
pageTop
;
if
(
clip
)
{
elementClip
.
x
+
=
clip
.
x
;
elementClip
.
y
+
=
clip
.
y
;
elementClip
.
height
=
clip
.
height
;
elementClip
.
width
=
clip
.
width
;
}
return
await
page
.
screenshot
(
{
.
.
.
options
clip
:
elementClip
}
)
;
}
async
#
nonEmptyVisibleBoundingBox
(
)
{
const
box
=
await
this
.
boundingBox
(
)
;
assert
(
box
'
Node
is
either
not
visible
or
not
an
HTMLElement
'
)
;
assert
(
box
.
width
!
=
=
0
'
Node
has
0
width
.
'
)
;
assert
(
box
.
height
!
=
=
0
'
Node
has
0
height
.
'
)
;
return
box
;
}
protected
async
assertConnectedElement
(
)
:
Promise
<
void
>
{
const
error
=
await
this
.
evaluate
(
async
element
=
>
{
if
(
!
element
.
isConnected
)
{
return
'
Node
is
detached
from
document
'
;
}
if
(
element
.
nodeType
!
=
=
Node
.
ELEMENT_NODE
)
{
return
'
Node
is
not
of
type
HTMLElement
'
;
}
return
;
}
)
;
if
(
error
)
{
throw
new
Error
(
error
)
;
}
}
protected
async
scrollIntoViewIfNeeded
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
if
(
await
this
.
isIntersectingViewport
(
{
threshold
:
1
}
)
)
{
return
;
}
await
this
.
scrollIntoView
(
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
isIntersectingViewport
(
this
:
ElementHandle
<
Element
>
options
:
{
threshold
?
:
number
;
}
=
{
}
)
:
Promise
<
boolean
>
{
await
this
.
assertConnectedElement
(
)
;
const
handle
=
await
this
.
#
asSVGElementHandle
(
)
;
using
target
=
handle
&
&
(
await
handle
.
#
getOwnerSVGElement
(
)
)
;
return
await
(
(
target
?
?
this
)
as
ElementHandle
<
Element
>
)
.
evaluate
(
async
(
element
threshold
)
=
>
{
const
visibleRatio
=
await
new
Promise
<
number
>
(
resolve
=
>
{
const
observer
=
new
IntersectionObserver
(
entries
=
>
{
resolve
(
entries
[
0
]
!
.
intersectionRatio
)
;
observer
.
disconnect
(
)
;
}
)
;
observer
.
observe
(
element
)
;
}
)
;
return
threshold
=
=
=
1
?
visibleRatio
=
=
=
1
:
visibleRatio
>
threshold
;
}
options
.
threshold
?
?
0
)
;
}
throwIfDisposed
(
)
ElementHandle
.
bindIsolatedHandle
async
scrollIntoView
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
void
>
{
await
this
.
assertConnectedElement
(
)
;
await
this
.
evaluate
(
async
(
element
)
:
Promise
<
void
>
=
>
{
element
.
scrollIntoView
(
{
block
:
'
center
'
inline
:
'
center
'
behavior
:
'
instant
'
}
)
;
}
)
;
}
async
#
asSVGElementHandle
(
this
:
ElementHandle
<
Element
>
)
:
Promise
<
ElementHandle
<
SVGElement
>
|
null
>
{
if
(
await
this
.
evaluate
(
element
=
>
{
return
element
instanceof
SVGElement
;
}
)
)
{
return
this
as
ElementHandle
<
SVGElement
>
;
}
else
{
return
null
;
}
}
async
#
getOwnerSVGElement
(
this
:
ElementHandle
<
SVGElement
>
)
:
Promise
<
ElementHandle
<
SVGSVGElement
>
>
{
return
await
this
.
evaluateHandle
(
element
=
>
{
if
(
element
instanceof
SVGSVGElement
)
{
return
element
;
}
return
element
.
ownerSVGElement
!
;
}
)
;
}
abstract
autofill
(
data
:
AutofillData
)
:
Promise
<
void
>
;
}
export
interface
AutofillData
{
creditCard
:
{
number
:
string
;
name
:
string
;
expiryMonth
:
string
;
expiryYear
:
string
;
cvc
:
string
;
}
;
}
function
intersectBoundingBox
(
box
:
BoundingBox
width
:
number
height
:
number
)
:
void
{
box
.
width
=
Math
.
max
(
box
.
x
>
=
0
?
Math
.
min
(
width
-
box
.
x
box
.
width
)
:
Math
.
min
(
width
box
.
width
+
box
.
x
)
0
)
;
box
.
height
=
Math
.
max
(
box
.
y
>
=
0
?
Math
.
min
(
height
-
box
.
y
box
.
height
)
:
Math
.
min
(
height
box
.
height
+
box
.
y
)
0
)
;
}
