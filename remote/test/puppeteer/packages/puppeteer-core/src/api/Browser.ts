import
{
ChildProcess
}
from
'
child_process
'
;
import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
Symbol
}
from
'
.
.
/
.
.
/
third_party
/
disposablestack
/
disposablestack
.
js
'
;
import
{
EventEmitter
}
from
'
.
.
/
common
/
EventEmitter
.
js
'
;
import
{
debugError
waitWithTimeout
}
from
'
.
.
/
common
/
util
.
js
'
;
import
{
Deferred
}
from
'
.
.
/
util
/
Deferred
.
js
'
;
import
type
{
BrowserContext
}
from
'
.
/
BrowserContext
.
js
'
;
import
type
{
Page
}
from
'
.
/
Page
.
js
'
;
import
type
{
Target
}
from
'
.
/
Target
.
js
'
;
export
interface
BrowserContextOptions
{
proxyServer
?
:
string
;
proxyBypassList
?
:
string
[
]
;
}
export
type
BrowserCloseCallback
=
(
)
=
>
Promise
<
void
>
|
void
;
export
type
TargetFilterCallback
=
(
target
:
Target
)
=
>
boolean
;
export
type
IsPageTargetCallback
=
(
target
:
Target
)
=
>
boolean
;
export
const
WEB_PERMISSION_TO_PROTOCOL_PERMISSION
=
new
Map
<
Permission
Protocol
.
Browser
.
PermissionType
>
(
[
[
'
geolocation
'
'
geolocation
'
]
[
'
midi
'
'
midi
'
]
[
'
notifications
'
'
notifications
'
]
[
'
camera
'
'
videoCapture
'
]
[
'
microphone
'
'
audioCapture
'
]
[
'
background
-
sync
'
'
backgroundSync
'
]
[
'
ambient
-
light
-
sensor
'
'
sensors
'
]
[
'
accelerometer
'
'
sensors
'
]
[
'
gyroscope
'
'
sensors
'
]
[
'
magnetometer
'
'
sensors
'
]
[
'
accessibility
-
events
'
'
accessibilityEvents
'
]
[
'
clipboard
-
read
'
'
clipboardReadWrite
'
]
[
'
clipboard
-
write
'
'
clipboardReadWrite
'
]
[
'
clipboard
-
sanitized
-
write
'
'
clipboardSanitizedWrite
'
]
[
'
payment
-
handler
'
'
paymentHandler
'
]
[
'
persistent
-
storage
'
'
durableStorage
'
]
[
'
idle
-
detection
'
'
idleDetection
'
]
[
'
midi
-
sysex
'
'
midiSysex
'
]
]
)
;
export
type
Permission
=
|
'
geolocation
'
|
'
midi
'
|
'
notifications
'
|
'
camera
'
|
'
microphone
'
|
'
background
-
sync
'
|
'
ambient
-
light
-
sensor
'
|
'
accelerometer
'
|
'
gyroscope
'
|
'
magnetometer
'
|
'
accessibility
-
events
'
|
'
clipboard
-
read
'
|
'
clipboard
-
write
'
|
'
clipboard
-
sanitized
-
write
'
|
'
payment
-
handler
'
|
'
persistent
-
storage
'
|
'
idle
-
detection
'
|
'
midi
-
sysex
'
;
export
interface
WaitForTargetOptions
{
timeout
?
:
number
;
}
export
const
enum
BrowserEmittedEvents
{
Disconnected
=
'
disconnected
'
TargetChanged
=
'
targetchanged
'
TargetCreated
=
'
targetcreated
'
TargetDestroyed
=
'
targetdestroyed
'
}
export
class
Browser
extends
EventEmitter
implements
AsyncDisposable
Disposable
{
constructor
(
)
{
super
(
)
;
}
_attach
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
_detach
(
)
:
void
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
get
_targets
(
)
:
Map
<
string
Target
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
process
(
)
:
ChildProcess
|
null
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
_getIsPageTargetCallback
(
)
:
IsPageTargetCallback
|
undefined
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
createIncognitoBrowserContext
(
options
?
:
BrowserContextOptions
)
:
Promise
<
BrowserContext
>
;
createIncognitoBrowserContext
(
)
:
Promise
<
BrowserContext
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
browserContexts
(
)
:
BrowserContext
[
]
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
defaultBrowserContext
(
)
:
BrowserContext
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
_disposeContext
(
contextId
?
:
string
)
:
Promise
<
void
>
;
_disposeContext
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
wsEndpoint
(
)
:
string
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
newPage
(
)
:
Promise
<
Page
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
_createPageInContext
(
contextId
?
:
string
)
:
Promise
<
Page
>
;
_createPageInContext
(
)
:
Promise
<
Page
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
targets
(
)
:
Target
[
]
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
target
(
)
:
Target
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
async
waitForTarget
(
predicate
:
(
x
:
Target
)
=
>
boolean
|
Promise
<
boolean
>
options
:
WaitForTargetOptions
=
{
}
)
:
Promise
<
Target
>
{
const
{
timeout
=
30000
}
=
options
;
const
targetDeferred
=
Deferred
.
create
<
Target
|
PromiseLike
<
Target
>
>
(
)
;
this
.
on
(
BrowserEmittedEvents
.
TargetCreated
check
)
;
this
.
on
(
BrowserEmittedEvents
.
TargetChanged
check
)
;
try
{
this
.
targets
(
)
.
forEach
(
check
)
;
if
(
!
timeout
)
{
return
await
targetDeferred
.
valueOrThrow
(
)
;
}
return
await
waitWithTimeout
(
targetDeferred
.
valueOrThrow
(
)
'
target
'
timeout
)
;
}
finally
{
this
.
off
(
BrowserEmittedEvents
.
TargetCreated
check
)
;
this
.
off
(
BrowserEmittedEvents
.
TargetChanged
check
)
;
}
async
function
check
(
target
:
Target
)
:
Promise
<
void
>
{
if
(
(
await
predicate
(
target
)
)
&
&
!
targetDeferred
.
resolved
(
)
)
{
targetDeferred
.
resolve
(
target
)
;
}
}
}
async
pages
(
)
:
Promise
<
Page
[
]
>
{
const
contextPages
=
await
Promise
.
all
(
this
.
browserContexts
(
)
.
map
(
context
=
>
{
return
context
.
pages
(
)
;
}
)
)
;
return
contextPages
.
reduce
(
(
acc
x
)
=
>
{
return
acc
.
concat
(
x
)
;
}
[
]
)
;
}
version
(
)
:
Promise
<
string
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
userAgent
(
)
:
Promise
<
string
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
close
(
)
:
Promise
<
void
>
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
disconnect
(
)
:
void
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
isConnected
(
)
:
boolean
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
[
Symbol
.
dispose
]
(
)
:
void
{
return
void
this
.
close
(
)
.
catch
(
debugError
)
;
}
[
Symbol
.
asyncDispose
]
(
)
:
Promise
<
void
>
{
return
this
.
close
(
)
;
}
}
export
const
enum
BrowserContextEmittedEvents
{
TargetChanged
=
'
targetchanged
'
TargetCreated
=
'
targetcreated
'
TargetDestroyed
=
'
targetdestroyed
'
}
