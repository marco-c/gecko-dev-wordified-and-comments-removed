import
{
firstValueFrom
from
merge
raceWith
}
from
'
.
.
/
.
.
/
third_party
/
rxjs
/
rxjs
.
js
'
;
import
{
EventEmitter
type
EventType
}
from
'
.
.
/
common
/
EventEmitter
.
js
'
;
import
{
debugError
fromEmitterEvent
filterAsync
timeout
}
from
'
.
.
/
common
/
util
.
js
'
;
import
{
asyncDisposeSymbol
disposeSymbol
}
from
'
.
.
/
util
/
disposable
.
js
'
;
import
{
Mutex
}
from
'
.
.
/
util
/
Mutex
.
js
'
;
import
type
{
Browser
Permission
WaitForTargetOptions
}
from
'
.
/
Browser
.
js
'
;
import
type
{
Page
}
from
'
.
/
Page
.
js
'
;
import
type
{
Target
}
from
'
.
/
Target
.
js
'
;
export
const
enum
BrowserContextEvent
{
TargetChanged
=
'
targetchanged
'
TargetCreated
=
'
targetcreated
'
TargetDestroyed
=
'
targetdestroyed
'
}
export
interface
BrowserContextEvents
extends
Record
<
EventType
unknown
>
{
[
BrowserContextEvent
.
TargetChanged
]
:
Target
;
[
BrowserContextEvent
.
TargetCreated
]
:
Target
;
[
BrowserContextEvent
.
TargetDestroyed
]
:
Target
;
}
export
abstract
class
BrowserContext
extends
EventEmitter
<
BrowserContextEvents
>
{
constructor
(
)
{
super
(
)
;
}
abstract
targets
(
)
:
Target
[
]
;
#
pageScreenshotMutex
?
:
Mutex
;
#
screenshotOperationsCount
=
0
;
startScreenshot
(
)
:
Promise
<
InstanceType
<
typeof
Mutex
.
Guard
>
>
{
const
mutex
=
this
.
#
pageScreenshotMutex
|
|
new
Mutex
(
)
;
this
.
#
pageScreenshotMutex
=
mutex
;
this
.
#
screenshotOperationsCount
+
+
;
return
mutex
.
acquire
(
(
)
=
>
{
this
.
#
screenshotOperationsCount
-
-
;
if
(
this
.
#
screenshotOperationsCount
=
=
=
0
)
{
this
.
#
pageScreenshotMutex
=
undefined
;
}
}
)
;
}
waitForScreenshotOperations
(
)
:
|
Promise
<
InstanceType
<
typeof
Mutex
.
Guard
>
>
|
undefined
{
return
this
.
#
pageScreenshotMutex
?
.
acquire
(
)
;
}
async
waitForTarget
(
predicate
:
(
x
:
Target
)
=
>
boolean
|
Promise
<
boolean
>
options
:
WaitForTargetOptions
=
{
}
)
:
Promise
<
Target
>
{
const
{
timeout
:
ms
=
30000
}
=
options
;
return
await
firstValueFrom
(
merge
(
fromEmitterEvent
(
this
BrowserContextEvent
.
TargetCreated
)
fromEmitterEvent
(
this
BrowserContextEvent
.
TargetChanged
)
from
(
this
.
targets
(
)
)
)
.
pipe
(
filterAsync
(
predicate
)
raceWith
(
timeout
(
ms
)
)
)
)
;
}
abstract
pages
(
)
:
Promise
<
Page
[
]
>
;
abstract
overridePermissions
(
origin
:
string
permissions
:
Permission
[
]
)
:
Promise
<
void
>
;
abstract
clearPermissionOverrides
(
)
:
Promise
<
void
>
;
abstract
newPage
(
)
:
Promise
<
Page
>
;
abstract
browser
(
)
:
Browser
;
abstract
close
(
)
:
Promise
<
void
>
;
get
closed
(
)
:
boolean
{
return
!
this
.
browser
(
)
.
browserContexts
(
)
.
includes
(
this
)
;
}
get
id
(
)
:
string
|
undefined
{
return
undefined
;
}
[
disposeSymbol
]
(
)
:
void
{
return
void
this
.
close
(
)
.
catch
(
debugError
)
;
}
[
asyncDisposeSymbol
]
(
)
:
Promise
<
void
>
{
return
this
.
close
(
)
;
}
}
