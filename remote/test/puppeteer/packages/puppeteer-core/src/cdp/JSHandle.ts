import
type
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
type
{
CDPSession
}
from
'
.
.
/
api
/
CDPSession
.
js
'
;
import
{
JSHandle
}
from
'
.
.
/
api
/
JSHandle
.
js
'
;
import
{
debugError
valueFromRemoteObject
}
from
'
.
.
/
common
/
util
.
js
'
;
import
type
{
CdpElementHandle
}
from
'
.
/
ElementHandle
.
js
'
;
import
type
{
IsolatedWorld
}
from
'
.
/
IsolatedWorld
.
js
'
;
export
class
CdpJSHandle
<
T
=
unknown
>
extends
JSHandle
<
T
>
{
#
disposed
=
false
;
readonly
#
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
;
readonly
#
world
:
IsolatedWorld
;
constructor
(
world
:
IsolatedWorld
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
)
{
super
(
)
;
this
.
#
world
=
world
;
this
.
#
remoteObject
=
remoteObject
;
}
override
get
disposed
(
)
:
boolean
{
return
this
.
#
disposed
;
}
override
get
realm
(
)
:
IsolatedWorld
{
return
this
.
#
world
;
}
get
client
(
)
:
CDPSession
{
return
this
.
realm
.
environment
.
client
;
}
override
async
jsonValue
(
)
:
Promise
<
T
>
{
if
(
!
this
.
#
remoteObject
.
objectId
)
{
return
valueFromRemoteObject
(
this
.
#
remoteObject
)
;
}
const
value
=
await
this
.
evaluate
(
object
=
>
{
return
object
;
}
)
;
if
(
value
=
=
=
undefined
)
{
throw
new
Error
(
'
Could
not
serialize
referenced
object
'
)
;
}
return
value
;
}
override
asElement
(
)
:
CdpElementHandle
<
Node
>
|
null
{
return
null
;
}
override
async
dispose
(
)
:
Promise
<
void
>
{
if
(
this
.
#
disposed
)
{
return
;
}
this
.
#
disposed
=
true
;
await
releaseObject
(
this
.
client
this
.
#
remoteObject
)
;
}
override
toString
(
)
:
string
{
if
(
!
this
.
#
remoteObject
.
objectId
)
{
return
'
JSHandle
:
'
+
valueFromRemoteObject
(
this
.
#
remoteObject
)
;
}
const
type
=
this
.
#
remoteObject
.
subtype
|
|
this
.
#
remoteObject
.
type
;
return
'
JSHandle
'
+
type
;
}
override
get
id
(
)
:
string
|
undefined
{
return
this
.
#
remoteObject
.
objectId
;
}
override
remoteObject
(
)
:
Protocol
.
Runtime
.
RemoteObject
{
return
this
.
#
remoteObject
;
}
}
export
async
function
releaseObject
(
client
:
CDPSession
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
)
:
Promise
<
void
>
{
if
(
!
remoteObject
.
objectId
)
{
return
;
}
await
client
.
send
(
'
Runtime
.
releaseObject
'
{
objectId
:
remoteObject
.
objectId
}
)
.
catch
(
error
=
>
{
debugError
(
error
)
;
}
)
;
}
