import
type
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
type
{
CDPSession
}
from
'
.
.
/
api
/
CDPSession
.
js
'
;
import
type
{
ElementHandle
}
from
'
.
.
/
api
/
ElementHandle
.
js
'
;
import
{
QueryHandler
type
QuerySelector
}
from
'
.
.
/
common
/
QueryHandler
.
js
'
;
import
type
{
AwaitableIterable
}
from
'
.
.
/
common
/
types
.
js
'
;
import
{
assert
}
from
'
.
.
/
util
/
assert
.
js
'
;
import
{
AsyncIterableUtil
}
from
'
.
.
/
util
/
AsyncIterableUtil
.
js
'
;
const
NON_ELEMENT_NODE_ROLES
=
new
Set
(
[
'
StaticText
'
'
InlineTextBox
'
]
)
;
const
queryAXTree
=
async
(
client
:
CDPSession
element
:
ElementHandle
<
Node
>
accessibleName
?
:
string
role
?
:
string
)
:
Promise
<
Protocol
.
Accessibility
.
AXNode
[
]
>
=
>
{
const
{
nodes
}
=
await
client
.
send
(
'
Accessibility
.
queryAXTree
'
{
objectId
:
element
.
id
accessibleName
role
}
)
;
return
nodes
.
filter
(
(
node
:
Protocol
.
Accessibility
.
AXNode
)
=
>
{
return
!
node
.
role
|
|
!
NON_ELEMENT_NODE_ROLES
.
has
(
node
.
role
.
value
)
;
}
)
;
}
;
interface
ARIASelector
{
name
?
:
string
;
role
?
:
string
;
}
const
isKnownAttribute
=
(
attribute
:
string
)
:
attribute
is
keyof
ARIASelector
=
>
{
return
[
'
name
'
'
role
'
]
.
includes
(
attribute
)
;
}
;
const
normalizeValue
=
(
value
:
string
)
:
string
=
>
{
return
value
.
replace
(
/
+
/
g
'
'
)
.
trim
(
)
;
}
;
const
ATTRIBUTE_REGEXP
=
/
\
[
\
s
*
(
?
<
attribute
>
\
w
+
)
\
s
*
=
\
s
*
(
?
<
quote
>
"
|
'
)
(
?
<
value
>
\
\
.
|
.
*
?
(
?
=
\
k
<
quote
>
)
)
\
k
<
quote
>
\
s
*
\
]
/
g
;
const
parseARIASelector
=
(
selector
:
string
)
:
ARIASelector
=
>
{
const
queryOptions
:
ARIASelector
=
{
}
;
const
defaultName
=
selector
.
replace
(
ATTRIBUTE_REGEXP
(
_
attribute
__
value
)
=
>
{
attribute
=
attribute
.
trim
(
)
;
assert
(
isKnownAttribute
(
attribute
)
Unknown
aria
attribute
"
{
attribute
}
"
in
selector
)
;
queryOptions
[
attribute
]
=
normalizeValue
(
value
)
;
return
'
'
;
}
)
;
if
(
defaultName
&
&
!
queryOptions
.
name
)
{
queryOptions
.
name
=
normalizeValue
(
defaultName
)
;
}
return
queryOptions
;
}
;
export
class
ARIAQueryHandler
extends
QueryHandler
{
static
override
querySelector
:
QuerySelector
=
async
(
node
selector
{
ariaQuerySelector
}
)
=
>
{
return
await
ariaQuerySelector
(
node
selector
)
;
}
;
static
override
async
*
queryAll
(
element
:
ElementHandle
<
Node
>
selector
:
string
)
:
AwaitableIterable
<
ElementHandle
<
Node
>
>
{
const
{
name
role
}
=
parseARIASelector
(
selector
)
;
const
results
=
await
queryAXTree
(
element
.
realm
.
environment
.
client
element
name
role
)
;
yield
*
AsyncIterableUtil
.
map
(
results
node
=
>
{
return
element
.
realm
.
adoptBackendNode
(
node
.
backendDOMNodeId
)
as
Promise
<
ElementHandle
<
Node
>
>
;
}
)
;
}
static
override
queryOne
=
async
(
element
:
ElementHandle
<
Node
>
selector
:
string
)
:
Promise
<
ElementHandle
<
Node
>
|
null
>
=
>
{
return
(
(
await
AsyncIterableUtil
.
first
(
this
.
queryAll
(
element
selector
)
)
)
?
?
null
)
;
}
;
}
