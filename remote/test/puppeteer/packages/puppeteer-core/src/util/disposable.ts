declare
global
{
interface
SymbolConstructor
{
readonly
dispose
:
unique
symbol
;
readonly
asyncDispose
:
unique
symbol
;
}
interface
Disposable
{
[
Symbol
.
dispose
]
(
)
:
void
;
}
interface
AsyncDisposable
{
[
Symbol
.
asyncDispose
]
(
)
:
PromiseLike
<
void
>
;
}
}
(
Symbol
as
any
)
.
dispose
?
?
=
Symbol
(
'
dispose
'
)
;
(
Symbol
as
any
)
.
asyncDispose
?
?
=
Symbol
(
'
asyncDispose
'
)
;
export
const
disposeSymbol
:
typeof
Symbol
.
dispose
=
Symbol
.
dispose
;
export
const
asyncDisposeSymbol
:
typeof
Symbol
.
asyncDispose
=
Symbol
.
asyncDispose
;
export
class
DisposableStack
{
#
disposed
=
false
;
#
stack
:
Disposable
[
]
=
[
]
;
get
disposed
(
)
:
boolean
{
return
this
.
#
disposed
;
}
dispose
(
)
:
void
{
if
(
this
.
#
disposed
)
{
return
;
}
this
.
#
disposed
=
true
;
for
(
const
resource
of
this
.
#
stack
.
reverse
(
)
)
{
resource
[
disposeSymbol
]
(
)
;
}
}
use
<
T
extends
Disposable
|
null
|
undefined
>
(
value
:
T
)
:
T
{
if
(
value
)
{
this
.
#
stack
.
push
(
value
)
;
}
return
value
;
}
adopt
<
T
>
(
value
:
T
onDispose
:
(
value
:
T
)
=
>
void
)
:
T
{
this
.
#
stack
.
push
(
{
[
disposeSymbol
]
(
)
{
onDispose
(
value
)
;
}
}
)
;
return
value
;
}
defer
(
onDispose
:
(
)
=
>
void
)
:
void
{
this
.
#
stack
.
push
(
{
[
disposeSymbol
]
(
)
{
onDispose
(
)
;
}
}
)
;
}
move
(
)
:
DisposableStack
{
if
(
this
.
#
disposed
)
{
throw
new
ReferenceError
(
'
a
disposed
stack
can
not
use
anything
new
'
)
;
}
const
stack
=
new
DisposableStack
(
)
;
stack
.
#
stack
=
this
.
#
stack
;
this
.
#
disposed
=
true
;
return
stack
;
}
[
disposeSymbol
]
=
this
.
dispose
;
readonly
[
Symbol
.
toStringTag
]
=
'
DisposableStack
'
;
}
export
class
AsyncDisposableStack
{
#
disposed
=
false
;
#
stack
:
AsyncDisposable
[
]
=
[
]
;
get
disposed
(
)
:
boolean
{
return
this
.
#
disposed
;
}
async
dispose
(
)
:
Promise
<
void
>
{
if
(
this
.
#
disposed
)
{
return
;
}
this
.
#
disposed
=
true
;
for
(
const
resource
of
this
.
#
stack
.
reverse
(
)
)
{
await
resource
[
asyncDisposeSymbol
]
(
)
;
}
}
use
<
T
extends
AsyncDisposable
|
null
|
undefined
>
(
value
:
T
)
:
T
{
if
(
value
)
{
this
.
#
stack
.
push
(
value
)
;
}
return
value
;
}
adopt
<
T
>
(
value
:
T
onDispose
:
(
value
:
T
)
=
>
Promise
<
void
>
)
:
T
{
this
.
#
stack
.
push
(
{
[
asyncDisposeSymbol
]
(
)
{
return
onDispose
(
value
)
;
}
}
)
;
return
value
;
}
defer
(
onDispose
:
(
)
=
>
Promise
<
void
>
)
:
void
{
this
.
#
stack
.
push
(
{
[
asyncDisposeSymbol
]
(
)
{
return
onDispose
(
)
;
}
}
)
;
}
move
(
)
:
AsyncDisposableStack
{
if
(
this
.
#
disposed
)
{
throw
new
ReferenceError
(
'
a
disposed
stack
can
not
use
anything
new
'
)
;
}
const
stack
=
new
AsyncDisposableStack
(
)
;
stack
.
#
stack
=
this
.
#
stack
;
this
.
#
disposed
=
true
;
return
stack
;
}
[
asyncDisposeSymbol
]
=
this
.
dispose
;
readonly
[
Symbol
.
toStringTag
]
=
'
AsyncDisposableStack
'
;
}
