declare
global
{
interface
SymbolConstructor
{
readonly
dispose
:
unique
symbol
;
readonly
asyncDispose
:
unique
symbol
;
}
interface
Disposable
{
[
Symbol
.
dispose
]
(
)
:
void
;
}
interface
AsyncDisposable
{
[
Symbol
.
asyncDispose
]
(
)
:
PromiseLike
<
void
>
;
}
}
(
Symbol
as
any
)
.
dispose
?
?
=
Symbol
(
'
dispose
'
)
;
(
Symbol
as
any
)
.
asyncDispose
?
?
=
Symbol
(
'
asyncDispose
'
)
;
export
const
disposeSymbol
:
typeof
Symbol
.
dispose
=
Symbol
.
dispose
;
export
const
asyncDisposeSymbol
:
typeof
Symbol
.
asyncDispose
=
Symbol
.
asyncDispose
;
export
class
DisposableStack
{
#
disposed
=
false
;
#
stack
:
Disposable
[
]
=
[
]
;
get
disposed
(
)
:
boolean
{
return
this
.
#
disposed
;
}
dispose
(
)
:
void
{
this
[
disposeSymbol
]
(
)
;
}
use
<
T
extends
Disposable
|
null
|
undefined
>
(
value
:
T
)
:
T
{
if
(
value
&
&
typeof
value
[
disposeSymbol
]
=
=
=
'
function
'
)
{
this
.
#
stack
.
push
(
value
)
;
}
return
value
;
}
adopt
<
T
>
(
value
:
T
onDispose
:
(
value
:
T
)
=
>
void
)
:
T
{
this
.
#
stack
.
push
(
{
[
disposeSymbol
]
(
)
{
onDispose
(
value
)
;
}
}
)
;
return
value
;
}
defer
(
onDispose
:
(
)
=
>
void
)
:
void
{
this
.
#
stack
.
push
(
{
[
disposeSymbol
]
(
)
{
onDispose
(
)
;
}
}
)
;
}
move
(
)
:
DisposableStack
{
if
(
this
.
#
disposed
)
{
throw
new
ReferenceError
(
'
A
disposed
stack
can
not
use
anything
new
'
)
;
}
const
stack
=
new
DisposableStack
(
)
;
stack
.
#
stack
=
this
.
#
stack
;
this
.
#
stack
=
[
]
;
this
.
#
disposed
=
true
;
return
stack
;
}
[
disposeSymbol
]
(
)
:
void
{
if
(
this
.
#
disposed
)
{
return
;
}
this
.
#
disposed
=
true
;
const
errors
:
unknown
[
]
=
[
]
;
for
(
const
resource
of
this
.
#
stack
.
reverse
(
)
)
{
try
{
resource
[
disposeSymbol
]
(
)
;
}
catch
(
e
)
{
errors
.
push
(
e
)
;
}
}
if
(
errors
.
length
=
=
=
1
)
{
throw
errors
[
0
]
;
}
else
if
(
errors
.
length
>
1
)
{
let
suppressed
=
null
;
for
(
const
error
of
errors
.
reverse
(
)
)
{
if
(
suppressed
=
=
=
null
)
{
suppressed
=
error
;
}
else
{
suppressed
=
new
SuppressedError
(
error
suppressed
)
;
}
}
throw
suppressed
;
}
}
readonly
[
Symbol
.
toStringTag
]
=
'
DisposableStack
'
;
}
export
class
AsyncDisposableStack
{
#
disposed
=
false
;
#
stack
:
AsyncDisposable
[
]
=
[
]
;
get
disposed
(
)
:
boolean
{
return
this
.
#
disposed
;
}
async
dispose
(
)
:
Promise
<
void
>
{
await
this
[
asyncDisposeSymbol
]
(
)
;
}
use
<
T
extends
AsyncDisposable
|
Disposable
|
null
|
undefined
>
(
value
:
T
)
:
T
{
if
(
value
)
{
const
asyncDispose
=
(
value
as
AsyncDisposable
)
[
asyncDisposeSymbol
]
;
const
dispose
=
(
value
as
Disposable
)
[
disposeSymbol
]
;
if
(
typeof
asyncDispose
=
=
=
'
function
'
)
{
this
.
#
stack
.
push
(
value
as
AsyncDisposable
)
;
}
else
if
(
typeof
dispose
=
=
=
'
function
'
)
{
this
.
#
stack
.
push
(
{
[
asyncDisposeSymbol
]
:
async
(
)
=
>
{
(
value
as
Disposable
)
[
disposeSymbol
]
(
)
;
}
}
)
;
}
}
return
value
;
}
adopt
<
T
>
(
value
:
T
onDispose
:
(
value
:
T
)
=
>
Promise
<
void
>
)
:
T
{
this
.
#
stack
.
push
(
{
[
asyncDisposeSymbol
]
(
)
{
return
onDispose
(
value
)
;
}
}
)
;
return
value
;
}
defer
(
onDispose
:
(
)
=
>
Promise
<
void
>
)
:
void
{
this
.
#
stack
.
push
(
{
[
asyncDisposeSymbol
]
(
)
{
return
onDispose
(
)
;
}
}
)
;
}
move
(
)
:
AsyncDisposableStack
{
if
(
this
.
#
disposed
)
{
throw
new
ReferenceError
(
'
A
disposed
stack
can
not
use
anything
new
'
)
;
}
const
stack
=
new
AsyncDisposableStack
(
)
;
stack
.
#
stack
=
this
.
#
stack
;
this
.
#
stack
=
[
]
;
this
.
#
disposed
=
true
;
return
stack
;
}
async
[
asyncDisposeSymbol
]
(
)
:
Promise
<
void
>
{
if
(
this
.
#
disposed
)
{
return
;
}
this
.
#
disposed
=
true
;
const
errors
:
unknown
[
]
=
[
]
;
for
(
const
resource
of
this
.
#
stack
.
reverse
(
)
)
{
try
{
await
resource
[
asyncDisposeSymbol
]
(
)
;
}
catch
(
e
)
{
errors
.
push
(
e
)
;
}
}
if
(
errors
.
length
=
=
=
1
)
{
throw
errors
[
0
]
;
}
else
if
(
errors
.
length
>
1
)
{
let
suppressed
=
null
;
for
(
const
error
of
errors
.
reverse
(
)
)
{
if
(
suppressed
=
=
=
null
)
{
suppressed
=
error
;
}
else
{
suppressed
=
new
SuppressedError
(
error
suppressed
)
;
}
}
throw
suppressed
;
}
}
readonly
[
Symbol
.
toStringTag
]
=
'
AsyncDisposableStack
'
;
}
export
class
SuppressedError
extends
Error
{
#
error
:
unknown
;
#
suppressed
:
unknown
;
constructor
(
error
:
unknown
suppressed
:
unknown
message
=
'
An
error
was
suppressed
during
disposal
'
)
{
super
(
message
)
;
this
.
name
=
'
SuppressedError
'
;
this
.
#
error
=
error
;
this
.
#
suppressed
=
suppressed
;
}
get
error
(
)
:
unknown
{
return
this
.
#
error
;
}
get
suppressed
(
)
:
unknown
{
return
this
.
#
suppressed
;
}
}
