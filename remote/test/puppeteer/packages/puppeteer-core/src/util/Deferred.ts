import
{
TimeoutError
}
from
'
.
.
/
common
/
Errors
.
js
'
;
export
interface
DeferredOptions
{
message
:
string
;
timeout
:
number
;
}
export
class
Deferred
<
T
>
{
#
isResolved
=
false
;
#
isRejected
=
false
;
#
value
:
T
|
Error
|
undefined
;
#
resolver
:
(
value
:
void
)
=
>
void
=
(
)
=
>
{
}
;
#
taskPromise
=
new
Promise
<
void
>
(
resolve
=
>
{
this
.
#
resolver
=
resolve
;
}
)
;
#
timeoutId
:
ReturnType
<
typeof
setTimeout
>
|
undefined
;
constructor
(
opts
?
:
DeferredOptions
)
{
this
.
#
timeoutId
=
opts
&
&
opts
.
timeout
>
0
?
setTimeout
(
(
)
=
>
{
this
.
reject
(
new
TimeoutError
(
opts
.
message
)
)
;
}
opts
.
timeout
)
:
undefined
;
}
#
finish
(
value
:
T
|
Error
)
{
clearTimeout
(
this
.
#
timeoutId
)
;
this
.
#
value
=
value
;
this
.
#
resolver
(
)
;
}
resolve
(
value
:
T
)
:
void
{
if
(
this
.
#
isRejected
|
|
this
.
#
isResolved
)
{
return
;
}
this
.
#
isResolved
=
true
;
this
.
#
finish
(
value
)
;
}
reject
(
error
:
Error
)
:
void
{
if
(
this
.
#
isRejected
|
|
this
.
#
isResolved
)
{
return
;
}
this
.
#
isRejected
=
true
;
this
.
#
finish
(
error
)
;
}
resolved
(
)
:
boolean
{
return
this
.
#
isResolved
;
}
finished
(
)
:
boolean
{
return
this
.
#
isResolved
|
|
this
.
#
isRejected
;
}
value
(
)
:
T
|
Error
|
undefined
{
return
this
.
#
value
;
}
async
valueOrThrow
(
)
:
Promise
<
T
>
{
await
this
.
#
taskPromise
;
if
(
this
.
#
isRejected
)
{
throw
this
.
#
value
;
}
return
this
.
#
value
as
T
;
}
static
create
<
R
>
(
opts
?
:
DeferredOptions
)
:
Deferred
<
R
>
{
return
new
Deferred
<
R
>
(
opts
)
;
}
static
async
race
<
R
>
(
awaitables
:
Array
<
Promise
<
R
>
|
Deferred
<
R
>
>
)
:
Promise
<
R
>
{
const
deferredWithTimeout
=
new
Set
<
Deferred
<
R
>
>
(
)
;
try
{
const
promises
=
awaitables
.
map
(
value
=
>
{
if
(
value
instanceof
Deferred
)
{
if
(
value
.
#
timeoutId
)
{
deferredWithTimeout
.
add
(
value
)
;
}
return
value
.
valueOrThrow
(
)
;
}
return
value
;
}
)
;
return
await
Promise
.
race
(
promises
)
;
}
finally
{
for
(
const
deferred
of
deferredWithTimeout
)
{
deferred
.
reject
(
new
Error
(
'
Timeout
cleared
'
)
)
;
}
}
}
}
