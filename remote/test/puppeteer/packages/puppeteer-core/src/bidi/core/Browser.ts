import
type
*
as
Bidi
from
'
chromium
-
bidi
/
lib
/
cjs
/
protocol
/
protocol
.
js
'
;
import
{
EventEmitter
}
from
'
.
.
/
.
.
/
common
/
EventEmitter
.
js
'
;
import
{
inertIfDisposed
throwIfDisposed
}
from
'
.
.
/
.
.
/
util
/
decorators
.
js
'
;
import
{
DisposableStack
disposeSymbol
}
from
'
.
.
/
.
.
/
util
/
disposable
.
js
'
;
import
type
{
BrowsingContext
}
from
'
.
/
BrowsingContext
.
js
'
;
import
type
{
SharedWorkerRealm
}
from
'
.
/
Realm
.
js
'
;
import
type
{
Session
}
from
'
.
/
Session
.
js
'
;
import
{
UserContext
}
from
'
.
/
UserContext
.
js
'
;
export
type
AddPreloadScriptOptions
=
Omit
<
Bidi
.
Script
.
AddPreloadScriptParameters
'
functionDeclaration
'
|
'
contexts
'
>
&
{
contexts
?
:
[
BrowsingContext
.
.
.
BrowsingContext
[
]
]
;
}
;
export
class
Browser
extends
EventEmitter
<
{
closed
:
{
reason
:
string
;
}
;
disconnected
:
{
reason
:
string
;
}
;
sharedworker
:
{
realm
:
SharedWorkerRealm
;
}
;
}
>
{
static
async
from
(
session
:
Session
)
:
Promise
<
Browser
>
{
const
browser
=
new
Browser
(
session
)
;
await
browser
.
#
initialize
(
)
;
return
browser
;
}
#
closed
=
false
;
#
reason
:
string
|
undefined
;
readonly
#
disposables
=
new
DisposableStack
(
)
;
readonly
#
userContexts
=
new
Map
<
string
UserContext
>
(
)
;
readonly
session
:
Session
;
private
constructor
(
session
:
Session
)
{
super
(
)
;
this
.
session
=
session
;
this
.
#
userContexts
.
set
(
UserContext
.
DEFAULT
UserContext
.
create
(
this
UserContext
.
DEFAULT
)
)
;
}
async
#
initialize
(
)
{
const
sessionEmitter
=
this
.
#
disposables
.
use
(
new
EventEmitter
(
this
.
session
)
)
;
sessionEmitter
.
once
(
'
ended
'
(
{
reason
}
)
=
>
{
this
.
dispose
(
reason
)
;
}
)
;
sessionEmitter
.
on
(
'
script
.
realmCreated
'
info
=
>
{
if
(
info
.
type
=
=
=
'
shared
-
worker
'
)
{
}
}
)
;
await
this
.
#
syncBrowsingContexts
(
)
;
}
async
#
syncBrowsingContexts
(
)
{
const
contextIds
=
new
Set
<
string
>
(
)
;
let
contexts
:
Bidi
.
BrowsingContext
.
Info
[
]
;
{
using
sessionEmitter
=
new
EventEmitter
(
this
.
session
)
;
sessionEmitter
.
on
(
'
browsingContext
.
contextCreated
'
info
=
>
{
contextIds
.
add
(
info
.
context
)
;
}
)
;
sessionEmitter
.
on
(
'
browsingContext
.
contextDestroyed
'
info
=
>
{
contextIds
.
delete
(
info
.
context
)
;
}
)
;
const
{
result
}
=
await
this
.
session
.
send
(
'
browsingContext
.
getTree
'
{
}
)
;
contexts
=
result
.
contexts
;
}
for
(
const
info
of
contexts
)
{
if
(
contextIds
.
has
(
info
.
context
)
)
{
this
.
session
.
emit
(
'
browsingContext
.
contextCreated
'
info
)
;
}
if
(
info
.
children
)
{
contexts
.
push
(
.
.
.
info
.
children
)
;
}
}
}
get
closed
(
)
:
boolean
{
return
this
.
#
closed
;
}
get
defaultUserContext
(
)
:
UserContext
{
return
this
.
#
userContexts
.
get
(
UserContext
.
DEFAULT
)
!
;
}
get
disconnected
(
)
:
boolean
{
return
this
.
#
reason
!
=
=
undefined
;
}
get
disposed
(
)
:
boolean
{
return
this
.
disconnected
;
}
get
userContexts
(
)
:
Iterable
<
UserContext
>
{
return
this
.
#
userContexts
.
values
(
)
;
}
inertIfDisposed
dispose
(
reason
?
:
string
closed
=
false
)
:
void
{
this
.
#
closed
=
closed
;
this
.
#
reason
=
reason
;
this
[
disposeSymbol
]
(
)
;
}
throwIfDisposed
<
Browser
>
(
browser
=
>
{
return
browser
.
#
reason
!
;
}
)
async
close
(
)
:
Promise
<
void
>
{
try
{
await
this
.
session
.
send
(
'
browser
.
close
'
{
}
)
;
}
finally
{
this
.
dispose
(
'
Browser
already
closed
.
'
true
)
;
}
}
throwIfDisposed
<
Browser
>
(
browser
=
>
{
return
browser
.
#
reason
!
;
}
)
async
addPreloadScript
(
functionDeclaration
:
string
options
:
AddPreloadScriptOptions
=
{
}
)
:
Promise
<
string
>
{
const
{
result
:
{
script
}
}
=
await
this
.
session
.
send
(
'
script
.
addPreloadScript
'
{
functionDeclaration
.
.
.
options
contexts
:
options
.
contexts
?
.
map
(
context
=
>
{
return
context
.
id
;
}
)
as
[
string
.
.
.
string
[
]
]
}
)
;
return
script
;
}
throwIfDisposed
<
Browser
>
(
browser
=
>
{
return
browser
.
#
reason
!
;
}
)
async
removePreloadScript
(
script
:
string
)
:
Promise
<
void
>
{
await
this
.
session
.
send
(
'
script
.
removePreloadScript
'
{
script
}
)
;
}
static
userContextId
=
0
;
throwIfDisposed
<
Browser
>
(
browser
=
>
{
return
browser
.
#
reason
!
;
}
)
async
createUserContext
(
)
:
Promise
<
UserContext
>
{
const
context
=
{
+
+
Browser
.
userContextId
}
;
const
userContext
=
UserContext
.
create
(
this
context
)
;
this
.
#
userContexts
.
set
(
userContext
.
id
userContext
)
;
const
userContextEmitter
=
this
.
#
disposables
.
use
(
new
EventEmitter
(
userContext
)
)
;
userContextEmitter
.
once
(
'
closed
'
(
)
=
>
{
userContextEmitter
.
removeAllListeners
(
)
;
this
.
#
userContexts
.
delete
(
context
)
;
}
)
;
return
userContext
;
}
[
disposeSymbol
]
(
)
:
void
{
this
.
#
reason
?
?
=
'
Browser
was
disconnected
probably
because
the
session
ended
.
'
;
if
(
this
.
closed
)
{
this
.
emit
(
'
closed
'
{
reason
:
this
.
#
reason
}
)
;
}
this
.
emit
(
'
disconnected
'
{
reason
:
this
.
#
reason
}
)
;
this
.
#
disposables
.
dispose
(
)
;
super
[
disposeSymbol
]
(
)
;
}
}
