import
type
*
as
Bidi
from
'
chromium
-
bidi
/
lib
/
cjs
/
protocol
/
protocol
.
js
'
;
import
{
EventEmitter
}
from
'
.
.
/
.
.
/
common
/
EventEmitter
.
js
'
;
import
{
assert
}
from
'
.
.
/
.
.
/
util
/
assert
.
js
'
;
import
{
inertIfDisposed
throwIfDisposed
}
from
'
.
.
/
.
.
/
util
/
decorators
.
js
'
;
import
{
DisposableStack
disposeSymbol
}
from
'
.
.
/
.
.
/
util
/
disposable
.
js
'
;
import
type
{
Browser
}
from
'
.
/
Browser
.
js
'
;
import
{
BrowsingContext
}
from
'
.
/
BrowsingContext
.
js
'
;
export
type
CreateBrowsingContextOptions
=
Omit
<
Bidi
.
BrowsingContext
.
CreateParameters
'
type
'
|
'
referenceContext
'
>
&
{
referenceContext
?
:
BrowsingContext
;
}
;
export
class
UserContext
extends
EventEmitter
<
{
browsingcontext
:
{
browsingContext
:
BrowsingContext
;
}
;
closed
:
{
reason
:
string
;
}
;
}
>
{
static
DEFAULT
=
'
default
'
;
static
create
(
browser
:
Browser
id
:
string
)
:
UserContext
{
const
context
=
new
UserContext
(
browser
id
)
;
context
.
#
initialize
(
)
;
return
context
;
}
#
reason
?
:
string
;
readonly
#
browsingContexts
=
new
Map
<
string
BrowsingContext
>
(
)
;
readonly
#
disposables
=
new
DisposableStack
(
)
;
readonly
#
id
:
string
;
readonly
browser
:
Browser
;
private
constructor
(
browser
:
Browser
id
:
string
)
{
super
(
)
;
this
.
#
id
=
id
;
this
.
browser
=
browser
;
}
#
initialize
(
)
{
const
browserEmitter
=
this
.
#
disposables
.
use
(
new
EventEmitter
(
this
.
browser
)
)
;
browserEmitter
.
once
(
'
closed
'
(
{
reason
}
)
=
>
{
this
.
dispose
(
User
context
already
closed
:
{
reason
}
)
;
}
)
;
const
sessionEmitter
=
this
.
#
disposables
.
use
(
new
EventEmitter
(
this
.
#
session
)
)
;
sessionEmitter
.
on
(
'
browsingContext
.
contextCreated
'
info
=
>
{
if
(
info
.
parent
)
{
return
;
}
const
browsingContext
=
BrowsingContext
.
from
(
this
undefined
info
.
context
info
.
url
)
;
this
.
#
browsingContexts
.
set
(
browsingContext
.
id
browsingContext
)
;
const
browsingContextEmitter
=
this
.
#
disposables
.
use
(
new
EventEmitter
(
browsingContext
)
)
;
browsingContextEmitter
.
on
(
'
closed
'
(
)
=
>
{
browsingContextEmitter
.
removeAllListeners
(
)
;
this
.
#
browsingContexts
.
delete
(
browsingContext
.
id
)
;
}
)
;
this
.
emit
(
'
browsingcontext
'
{
browsingContext
}
)
;
}
)
;
}
get
#
session
(
)
{
return
this
.
browser
.
session
;
}
get
browsingContexts
(
)
:
Iterable
<
BrowsingContext
>
{
return
this
.
#
browsingContexts
.
values
(
)
;
}
get
closed
(
)
:
boolean
{
return
this
.
#
reason
!
=
=
undefined
;
}
get
disposed
(
)
:
boolean
{
return
this
.
closed
;
}
get
id
(
)
:
string
{
return
this
.
#
id
;
}
inertIfDisposed
private
dispose
(
reason
?
:
string
)
:
void
{
this
.
#
reason
=
reason
;
this
[
disposeSymbol
]
(
)
;
}
throwIfDisposed
<
UserContext
>
(
context
=
>
{
return
context
.
#
reason
!
;
}
)
async
createBrowsingContext
(
type
:
Bidi
.
BrowsingContext
.
CreateType
options
:
CreateBrowsingContextOptions
=
{
}
)
:
Promise
<
BrowsingContext
>
{
const
{
result
:
{
context
:
contextId
}
}
=
await
this
.
#
session
.
send
(
'
browsingContext
.
create
'
{
type
.
.
.
options
referenceContext
:
options
.
referenceContext
?
.
id
}
)
;
const
browsingContext
=
this
.
#
browsingContexts
.
get
(
contextId
)
;
assert
(
browsingContext
'
The
WebDriver
BiDi
implementation
is
failing
to
create
a
browsing
context
correctly
.
'
)
;
return
browsingContext
;
}
throwIfDisposed
<
UserContext
>
(
context
=
>
{
return
context
.
#
reason
!
;
}
)
async
remove
(
)
:
Promise
<
void
>
{
try
{
}
finally
{
this
.
dispose
(
'
User
context
already
closed
.
'
)
;
}
}
[
disposeSymbol
]
(
)
:
void
{
this
.
#
reason
?
?
=
'
User
context
already
closed
probably
because
the
browser
disconnected
/
closed
.
'
;
this
.
emit
(
'
closed
'
{
reason
:
this
.
#
reason
}
)
;
this
.
#
disposables
.
dispose
(
)
;
super
[
disposeSymbol
]
(
)
;
}
}
