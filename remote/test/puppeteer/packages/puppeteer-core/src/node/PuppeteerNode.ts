import
{
Browser
as
browsers_SupportedBrowser
resolveBuildId
detectBrowserPlatform
getInstalledBrowsers
uninstall
}
from
'
puppeteer
/
browsers
'
;
import
type
{
Browser
}
from
'
.
.
/
api
/
Browser
.
js
'
;
import
type
{
Configuration
}
from
'
.
.
/
common
/
Configuration
.
js
'
;
import
type
{
ConnectOptions
}
from
'
.
.
/
common
/
ConnectOptions
.
js
'
;
import
{
type
CommonPuppeteerSettings
Puppeteer
}
from
'
.
.
/
common
/
Puppeteer
.
js
'
;
import
type
{
SupportedBrowser
}
from
'
.
.
/
common
/
SupportedBrowser
.
js
'
;
import
{
PUPPETEER_REVISIONS
}
from
'
.
.
/
revisions
.
js
'
;
import
type
{
BrowserLauncher
}
from
'
.
/
BrowserLauncher
.
js
'
;
import
{
ChromeLauncher
}
from
'
.
/
ChromeLauncher
.
js
'
;
import
{
FirefoxLauncher
}
from
'
.
/
FirefoxLauncher
.
js
'
;
import
type
{
ChromeReleaseChannel
LaunchOptions
}
from
'
.
/
LaunchOptions
.
js
'
;
export
class
PuppeteerNode
extends
Puppeteer
{
#
launcher
?
:
BrowserLauncher
;
#
lastLaunchedBrowser
?
:
SupportedBrowser
;
defaultBrowserRevision
:
string
;
configuration
:
Configuration
=
{
}
;
constructor
(
settings
:
{
configuration
?
:
Configuration
;
}
&
CommonPuppeteerSettings
)
{
const
{
configuration
.
.
.
commonSettings
}
=
settings
;
super
(
commonSettings
)
;
if
(
configuration
)
{
this
.
configuration
=
configuration
;
}
switch
(
this
.
configuration
.
defaultBrowser
)
{
case
'
firefox
'
:
this
.
defaultBrowserRevision
=
PUPPETEER_REVISIONS
.
firefox
;
break
;
default
:
this
.
configuration
.
defaultBrowser
=
'
chrome
'
;
this
.
defaultBrowserRevision
=
PUPPETEER_REVISIONS
.
chrome
;
break
;
}
this
.
connect
=
this
.
connect
.
bind
(
this
)
;
this
.
launch
=
this
.
launch
.
bind
(
this
)
;
this
.
executablePath
=
this
.
executablePath
.
bind
(
this
)
;
this
.
defaultArgs
=
this
.
defaultArgs
.
bind
(
this
)
;
this
.
trimCache
=
this
.
trimCache
.
bind
(
this
)
;
}
override
connect
(
options
:
ConnectOptions
)
:
Promise
<
Browser
>
{
return
super
.
connect
(
options
)
;
}
launch
(
options
:
LaunchOptions
=
{
}
)
:
Promise
<
Browser
>
{
const
{
browser
=
this
.
defaultBrowser
}
=
options
;
this
.
#
lastLaunchedBrowser
=
browser
;
switch
(
browser
)
{
case
'
chrome
'
:
this
.
defaultBrowserRevision
=
PUPPETEER_REVISIONS
.
chrome
;
break
;
case
'
firefox
'
:
this
.
defaultBrowserRevision
=
PUPPETEER_REVISIONS
.
firefox
;
break
;
default
:
throw
new
Error
(
Unknown
product
:
{
browser
}
)
;
}
this
.
#
launcher
=
this
.
#
getLauncher
(
browser
)
;
return
this
.
#
launcher
.
launch
(
options
)
;
}
#
getLauncher
(
browser
:
SupportedBrowser
)
:
BrowserLauncher
{
if
(
this
.
#
launcher
&
&
this
.
#
launcher
.
browser
=
=
=
browser
)
{
return
this
.
#
launcher
;
}
switch
(
browser
)
{
case
'
chrome
'
:
return
new
ChromeLauncher
(
this
)
;
case
'
firefox
'
:
return
new
FirefoxLauncher
(
this
)
;
default
:
throw
new
Error
(
Unknown
product
:
{
browser
}
)
;
}
}
executablePath
(
channel
:
ChromeReleaseChannel
)
:
string
;
executablePath
(
options
:
LaunchOptions
)
:
string
;
executablePath
(
)
:
string
;
executablePath
(
optsOrChannel
?
:
ChromeReleaseChannel
|
LaunchOptions
)
:
string
{
if
(
optsOrChannel
=
=
=
undefined
)
{
return
this
.
#
getLauncher
(
this
.
lastLaunchedBrowser
)
.
executablePath
(
undefined
false
)
;
}
if
(
typeof
optsOrChannel
=
=
=
'
string
'
)
{
return
this
.
#
getLauncher
(
'
chrome
'
)
.
executablePath
(
optsOrChannel
false
)
;
}
return
this
.
#
getLauncher
(
optsOrChannel
.
browser
?
?
this
.
lastLaunchedBrowser
)
.
resolveExecutablePath
(
optsOrChannel
.
headless
false
)
;
}
get
browserVersion
(
)
:
string
{
return
(
this
.
configuration
?
.
[
this
.
lastLaunchedBrowser
]
?
.
version
?
?
this
.
defaultBrowserRevision
!
)
;
}
get
defaultDownloadPath
(
)
:
string
|
undefined
{
return
this
.
configuration
.
cacheDirectory
;
}
get
lastLaunchedBrowser
(
)
:
SupportedBrowser
{
return
this
.
#
lastLaunchedBrowser
?
?
this
.
defaultBrowser
;
}
get
defaultBrowser
(
)
:
SupportedBrowser
{
return
this
.
configuration
.
defaultBrowser
?
?
'
chrome
'
;
}
get
product
(
)
:
string
{
return
this
.
lastLaunchedBrowser
;
}
defaultArgs
(
options
:
LaunchOptions
=
{
}
)
:
string
[
]
{
return
this
.
#
getLauncher
(
options
.
browser
?
?
this
.
lastLaunchedBrowser
)
.
defaultArgs
(
options
)
;
}
async
trimCache
(
)
:
Promise
<
void
>
{
const
platform
=
detectBrowserPlatform
(
)
;
if
(
!
platform
)
{
throw
new
Error
(
'
The
current
platform
is
not
supported
.
'
)
;
}
const
cacheDir
=
this
.
configuration
.
cacheDirectory
!
;
const
installedBrowsers
=
await
getInstalledBrowsers
(
{
cacheDir
}
)
;
const
puppeteerBrowsers
:
Array
<
{
product
:
SupportedBrowser
;
browser
:
browsers_SupportedBrowser
;
currentBuildId
:
string
;
}
>
=
[
{
product
:
'
chrome
'
browser
:
browsers_SupportedBrowser
.
CHROME
currentBuildId
:
'
'
}
{
product
:
'
firefox
'
browser
:
browsers_SupportedBrowser
.
FIREFOX
currentBuildId
:
'
'
}
]
;
for
(
const
item
of
puppeteerBrowsers
)
{
const
tag
=
this
.
configuration
?
.
[
item
.
product
]
?
.
version
?
?
PUPPETEER_REVISIONS
[
item
.
product
]
;
item
.
currentBuildId
=
await
resolveBuildId
(
item
.
browser
platform
tag
)
;
}
const
currentBrowserBuilds
=
new
Set
(
puppeteerBrowsers
.
map
(
browser
=
>
{
return
{
browser
.
browser
}
_
{
browser
.
currentBuildId
}
;
}
)
)
;
const
currentBrowsers
=
new
Set
(
puppeteerBrowsers
.
map
(
browser
=
>
{
return
browser
.
browser
;
}
)
)
;
for
(
const
installedBrowser
of
installedBrowsers
)
{
if
(
!
currentBrowsers
.
has
(
installedBrowser
.
browser
)
)
{
continue
;
}
if
(
currentBrowserBuilds
.
has
(
{
installedBrowser
.
browser
}
_
{
installedBrowser
.
buildId
}
)
)
{
continue
;
}
await
uninstall
(
{
browser
:
installedBrowser
.
browser
platform
cacheDir
buildId
:
installedBrowser
.
buildId
}
)
;
}
}
}
