import
type
{
ChildProcessWithoutNullStreams
}
from
'
child_process
'
;
import
{
spawn
spawnSync
}
from
'
child_process
'
;
import
{
PassThrough
}
from
'
stream
'
;
import
debug
from
'
debug
'
;
import
type
Protocol
from
'
devtools
-
protocol
'
;
import
type
{
Observable
OperatorFunction
}
from
'
.
.
/
.
.
/
third_party
/
rxjs
/
rxjs
.
js
'
;
import
{
bufferCount
concatMap
filter
from
fromEvent
lastValueFrom
map
takeUntil
tap
}
from
'
.
.
/
.
.
/
third_party
/
rxjs
/
rxjs
.
js
'
;
import
{
CDPSessionEvent
}
from
'
.
.
/
api
/
CDPSession
.
js
'
;
import
type
{
BoundingBox
}
from
'
.
.
/
api
/
ElementHandle
.
js
'
;
import
type
{
Page
}
from
'
.
.
/
api
/
Page
.
js
'
;
import
{
debugError
}
from
'
.
.
/
common
/
util
.
js
'
;
import
{
guarded
}
from
'
.
.
/
util
/
decorators
.
js
'
;
import
{
asyncDisposeSymbol
}
from
'
.
.
/
util
/
disposable
.
js
'
;
const
CRF_VALUE
=
30
;
const
DEFAULT_FPS
=
30
;
const
debugFfmpeg
=
debug
(
'
puppeteer
:
ffmpeg
'
)
;
export
interface
ScreenRecorderOptions
{
speed
?
:
number
;
crop
?
:
BoundingBox
;
format
?
:
'
gif
'
|
'
webm
'
;
scale
?
:
number
;
path
?
:
string
;
}
export
class
ScreenRecorder
extends
PassThrough
{
#
page
:
Page
;
#
process
:
ChildProcessWithoutNullStreams
;
#
controller
=
new
AbortController
(
)
;
#
lastFrame
:
Promise
<
readonly
[
Buffer
number
]
>
;
constructor
(
page
:
Page
width
:
number
height
:
number
{
speed
scale
crop
format
path
}
:
ScreenRecorderOptions
=
{
}
)
{
super
(
{
allowHalfOpen
:
false
}
)
;
path
?
?
=
'
ffmpeg
'
;
const
{
error
}
=
spawnSync
(
path
)
;
if
(
error
)
{
throw
error
;
}
this
.
#
process
=
spawn
(
path
[
[
'
-
loglevel
'
'
error
'
]
[
'
-
avioflags
'
'
direct
'
]
[
'
-
fpsprobesize
'
{
0
}
'
-
probesize
'
{
32
}
'
-
analyzeduration
'
{
0
}
'
-
fflags
'
'
nobuffer
'
]
[
'
-
f
'
'
image2pipe
'
'
-
c
:
v
'
'
png
'
'
-
i
'
'
pipe
:
0
'
]
[
'
-
y
'
'
-
an
'
]
[
'
-
threads
'
'
1
'
]
[
'
-
framerate
'
{
DEFAULT_FPS
}
]
this
.
#
getFormatArgs
(
format
?
?
'
webm
'
)
[
'
-
b
:
v
'
{
0
}
]
[
'
-
vf
'
{
speed
?
setpts
=
{
1
/
speed
}
*
PTS
:
'
'
}
crop
=
'
min
(
{
width
}
iw
)
:
min
(
{
height
}
ih
)
:
{
0
}
:
{
0
}
'
pad
=
{
width
}
:
{
height
}
:
{
0
}
:
{
0
}
{
crop
?
crop
=
{
crop
.
width
}
:
{
crop
.
height
}
:
{
crop
.
x
}
:
{
crop
.
y
}
:
'
'
}
{
scale
?
scale
=
iw
*
{
scale
}
:
-
1
:
'
'
}
]
'
pipe
:
1
'
]
.
flat
(
)
{
stdio
:
[
'
pipe
'
'
pipe
'
'
pipe
'
]
}
)
;
this
.
#
process
.
stdout
.
pipe
(
this
)
;
this
.
#
process
.
stderr
.
on
(
'
data
'
(
data
:
Buffer
)
=
>
{
debugFfmpeg
(
data
.
toString
(
'
utf8
'
)
)
;
}
)
;
this
.
#
page
=
page
;
const
{
client
}
=
this
.
#
page
.
mainFrame
(
)
;
client
.
once
(
CDPSessionEvent
.
Disconnected
(
)
=
>
{
void
this
.
stop
(
)
.
catch
(
debugError
)
;
}
)
;
this
.
#
lastFrame
=
lastValueFrom
(
(
fromEvent
(
client
'
Page
.
screencastFrame
'
)
as
Observable
<
Protocol
.
Page
.
ScreencastFrameEvent
>
)
.
pipe
(
tap
(
event
=
>
{
void
client
.
send
(
'
Page
.
screencastFrameAck
'
{
sessionId
:
event
.
sessionId
}
)
;
}
)
filter
(
event
=
>
{
return
event
.
metadata
.
timestamp
!
=
=
undefined
;
}
)
map
(
event
=
>
{
return
{
buffer
:
Buffer
.
from
(
event
.
data
'
base64
'
)
timestamp
:
event
.
metadata
.
timestamp
!
}
;
}
)
bufferCount
(
2
1
)
as
OperatorFunction
<
{
buffer
:
Buffer
;
timestamp
:
number
}
[
{
buffer
:
Buffer
;
timestamp
:
number
}
{
buffer
:
Buffer
;
timestamp
:
number
}
]
>
concatMap
(
(
[
{
timestamp
:
previousTimestamp
buffer
}
{
timestamp
}
]
)
=
>
{
return
from
(
Array
<
Buffer
>
(
Math
.
round
(
DEFAULT_FPS
*
Math
.
max
(
timestamp
-
previousTimestamp
0
)
)
)
.
fill
(
buffer
)
)
;
}
)
map
(
buffer
=
>
{
void
this
.
#
writeFrame
(
buffer
)
;
return
[
buffer
performance
.
now
(
)
]
as
const
;
}
)
takeUntil
(
fromEvent
(
this
.
#
controller
.
signal
'
abort
'
)
)
)
{
defaultValue
:
[
Buffer
.
from
(
[
]
)
performance
.
now
(
)
]
as
const
}
)
;
}
#
getFormatArgs
(
format
:
'
webm
'
|
'
gif
'
)
{
switch
(
format
)
{
case
'
webm
'
:
return
[
[
'
-
c
:
v
'
'
vp9
'
]
[
'
-
f
'
'
webm
'
]
[
'
-
crf
'
{
CRF_VALUE
}
]
[
'
-
deadline
'
'
realtime
'
'
-
cpu
-
used
'
{
8
}
]
]
.
flat
(
)
;
case
'
gif
'
:
return
[
[
'
-
vf
'
'
fps
=
5
split
[
s0
]
[
s1
]
;
[
s0
]
palettegen
=
stats_mode
=
diff
[
p
]
;
[
s1
]
[
p
]
paletteuse
'
]
[
'
-
f
'
'
gif
'
]
]
.
flat
(
)
;
}
}
guarded
(
)
async
#
writeFrame
(
buffer
:
Buffer
)
{
const
error
=
await
new
Promise
<
Error
|
null
|
undefined
>
(
resolve
=
>
{
this
.
#
process
.
stdin
.
write
(
buffer
resolve
)
;
}
)
;
if
(
error
)
{
console
.
log
(
ffmpeg
failed
to
write
:
{
error
.
message
}
.
)
;
}
}
guarded
(
)
async
stop
(
)
:
Promise
<
void
>
{
if
(
this
.
#
controller
.
signal
.
aborted
)
{
return
;
}
await
this
.
#
page
.
_stopScreencast
(
)
.
catch
(
debugError
)
;
this
.
#
controller
.
abort
(
)
;
const
[
buffer
timestamp
]
=
await
this
.
#
lastFrame
;
await
Promise
.
all
(
Array
<
Buffer
>
(
Math
.
max
(
1
Math
.
round
(
(
DEFAULT_FPS
*
(
performance
.
now
(
)
-
timestamp
)
)
/
1000
)
)
)
.
fill
(
buffer
)
.
map
(
this
.
#
writeFrame
.
bind
(
this
)
)
)
;
this
.
#
process
.
stdin
.
end
(
)
;
await
new
Promise
(
resolve
=
>
{
this
.
#
process
.
once
(
'
close
'
resolve
)
;
}
)
;
}
async
[
asyncDisposeSymbol
]
(
)
:
Promise
<
void
>
{
await
this
.
stop
(
)
;
}
}
