import
{
debugError
isErrorLike
}
from
'
.
/
util
.
js
'
;
import
{
isNode
}
from
'
.
.
/
environment
.
js
'
;
import
{
assert
}
from
'
.
/
assert
.
js
'
;
import
{
Browser
IsPageTargetCallback
TargetFilterCallback
}
from
'
.
/
Browser
.
js
'
;
import
{
Connection
}
from
'
.
/
Connection
.
js
'
;
import
{
ConnectionTransport
}
from
'
.
/
ConnectionTransport
.
js
'
;
import
{
getFetch
}
from
'
.
/
fetch
.
js
'
;
import
{
Viewport
}
from
'
.
/
PuppeteerViewport
.
js
'
;
export
interface
BrowserConnectOptions
{
ignoreHTTPSErrors
?
:
boolean
;
defaultViewport
?
:
Viewport
|
null
;
slowMo
?
:
number
;
targetFilter
?
:
TargetFilterCallback
;
_isPageTarget
?
:
IsPageTargetCallback
;
}
const
getWebSocketTransportClass
=
async
(
)
=
>
{
return
isNode
?
(
await
import
(
'
.
.
/
node
/
NodeWebSocketTransport
.
js
'
)
)
.
NodeWebSocketTransport
:
(
await
import
(
'
.
/
BrowserWebSocketTransport
.
js
'
)
)
.
BrowserWebSocketTransport
;
}
;
export
async
function
_connectToBrowser
(
options
:
BrowserConnectOptions
&
{
browserWSEndpoint
?
:
string
;
browserURL
?
:
string
;
transport
?
:
ConnectionTransport
;
}
)
:
Promise
<
Browser
>
{
const
{
browserWSEndpoint
browserURL
ignoreHTTPSErrors
=
false
defaultViewport
=
{
width
:
800
height
:
600
}
transport
slowMo
=
0
targetFilter
_isPageTarget
:
isPageTarget
}
=
options
;
assert
(
Number
(
!
!
browserWSEndpoint
)
+
Number
(
!
!
browserURL
)
+
Number
(
!
!
transport
)
=
=
=
1
'
Exactly
one
of
browserWSEndpoint
browserURL
or
transport
must
be
passed
to
puppeteer
.
connect
'
)
;
let
connection
!
:
Connection
;
if
(
transport
)
{
connection
=
new
Connection
(
'
'
transport
slowMo
)
;
}
else
if
(
browserWSEndpoint
)
{
const
WebSocketClass
=
await
getWebSocketTransportClass
(
)
;
const
connectionTransport
:
ConnectionTransport
=
await
WebSocketClass
.
create
(
browserWSEndpoint
)
;
connection
=
new
Connection
(
browserWSEndpoint
connectionTransport
slowMo
)
;
}
else
if
(
browserURL
)
{
const
connectionURL
=
await
getWSEndpoint
(
browserURL
)
;
const
WebSocketClass
=
await
getWebSocketTransportClass
(
)
;
const
connectionTransport
:
ConnectionTransport
=
await
WebSocketClass
.
create
(
connectionURL
)
;
connection
=
new
Connection
(
connectionURL
connectionTransport
slowMo
)
;
}
const
version
=
await
connection
.
send
(
'
Browser
.
getVersion
'
)
;
const
product
=
version
.
product
.
toLowerCase
(
)
.
includes
(
'
firefox
'
)
?
'
firefox
'
:
'
chrome
'
;
const
{
browserContextIds
}
=
await
connection
.
send
(
'
Target
.
getBrowserContexts
'
)
;
const
browser
=
await
Browser
.
_create
(
product
|
|
'
chrome
'
connection
browserContextIds
ignoreHTTPSErrors
defaultViewport
undefined
(
)
=
>
{
return
connection
.
send
(
'
Browser
.
close
'
)
.
catch
(
debugError
)
;
}
targetFilter
isPageTarget
)
;
await
browser
.
pages
(
)
;
return
browser
;
}
async
function
getWSEndpoint
(
browserURL
:
string
)
:
Promise
<
string
>
{
const
endpointURL
=
new
URL
(
'
/
json
/
version
'
browserURL
)
;
const
fetch
=
await
getFetch
(
)
;
try
{
const
result
=
await
fetch
(
endpointURL
.
toString
(
)
{
method
:
'
GET
'
}
)
;
if
(
!
result
.
ok
)
{
throw
new
Error
(
HTTP
{
result
.
statusText
}
)
;
}
const
data
=
await
result
.
json
(
)
;
return
data
.
webSocketDebuggerUrl
;
}
catch
(
error
)
{
if
(
isErrorLike
(
error
)
)
{
error
.
message
=
Failed
to
fetch
browser
webSocket
URL
from
{
endpointURL
}
:
+
error
.
message
;
}
throw
error
;
}
}
