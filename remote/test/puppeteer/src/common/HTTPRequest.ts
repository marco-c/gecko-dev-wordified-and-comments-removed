import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
ProtocolMapping
}
from
'
devtools
-
protocol
/
types
/
protocol
-
mapping
.
js
'
;
import
{
assert
}
from
'
.
/
assert
.
js
'
;
import
{
ProtocolError
}
from
'
.
/
Errors
.
js
'
;
import
{
EventEmitter
}
from
'
.
/
EventEmitter
.
js
'
;
import
{
Frame
}
from
'
.
/
FrameManager
.
js
'
;
import
{
debugError
isString
}
from
'
.
/
util
.
js
'
;
import
{
HTTPResponse
}
from
'
.
/
HTTPResponse
.
js
'
;
export
interface
ContinueRequestOverrides
{
url
?
:
string
;
method
?
:
string
;
postData
?
:
string
;
headers
?
:
Record
<
string
string
>
;
}
export
interface
InterceptResolutionState
{
action
:
InterceptResolutionAction
;
priority
?
:
number
;
}
export
interface
ResponseForRequest
{
status
:
number
;
headers
:
Record
<
string
unknown
>
;
contentType
:
string
;
body
:
string
|
Buffer
;
}
export
type
ResourceType
=
Lowercase
<
Protocol
.
Network
.
ResourceType
>
;
export
const
DEFAULT_INTERCEPT_RESOLUTION_PRIORITY
=
0
;
interface
CDPSession
extends
EventEmitter
{
send
<
T
extends
keyof
ProtocolMapping
.
Commands
>
(
method
:
T
.
.
.
paramArgs
:
ProtocolMapping
.
Commands
[
T
]
[
'
paramsType
'
]
)
:
Promise
<
ProtocolMapping
.
Commands
[
T
]
[
'
returnType
'
]
>
;
}
export
class
HTTPRequest
{
_requestId
:
string
;
_interceptionId
:
string
|
undefined
;
_failureText
:
string
|
null
=
null
;
_response
:
HTTPResponse
|
null
=
null
;
_fromMemoryCache
=
false
;
_redirectChain
:
HTTPRequest
[
]
;
#
client
:
CDPSession
;
#
isNavigationRequest
:
boolean
;
#
allowInterception
:
boolean
;
#
interceptionHandled
=
false
;
#
url
:
string
;
#
resourceType
:
ResourceType
;
#
method
:
string
;
#
postData
?
:
string
;
#
headers
:
Record
<
string
string
>
=
{
}
;
#
frame
:
Frame
|
null
;
#
continueRequestOverrides
:
ContinueRequestOverrides
;
#
responseForRequest
:
Partial
<
ResponseForRequest
>
|
null
=
null
;
#
abortErrorReason
:
Protocol
.
Network
.
ErrorReason
|
null
=
null
;
#
interceptResolutionState
:
InterceptResolutionState
=
{
action
:
InterceptResolutionAction
.
None
}
;
#
interceptHandlers
:
Array
<
(
)
=
>
void
|
PromiseLike
<
any
>
>
;
#
initiator
:
Protocol
.
Network
.
Initiator
;
get
client
(
)
:
CDPSession
{
return
this
.
#
client
;
}
constructor
(
client
:
CDPSession
frame
:
Frame
|
null
interceptionId
:
string
|
undefined
allowInterception
:
boolean
event
:
Protocol
.
Network
.
RequestWillBeSentEvent
redirectChain
:
HTTPRequest
[
]
)
{
this
.
#
client
=
client
;
this
.
_requestId
=
event
.
requestId
;
this
.
#
isNavigationRequest
=
event
.
requestId
=
=
=
event
.
loaderId
&
&
event
.
type
=
=
=
'
Document
'
;
this
.
_interceptionId
=
interceptionId
;
this
.
#
allowInterception
=
allowInterception
;
this
.
#
url
=
event
.
request
.
url
;
this
.
#
resourceType
=
(
event
.
type
|
|
'
other
'
)
.
toLowerCase
(
)
as
ResourceType
;
this
.
#
method
=
event
.
request
.
method
;
this
.
#
postData
=
event
.
request
.
postData
;
this
.
#
frame
=
frame
;
this
.
_redirectChain
=
redirectChain
;
this
.
#
continueRequestOverrides
=
{
}
;
this
.
#
interceptHandlers
=
[
]
;
this
.
#
initiator
=
event
.
initiator
;
for
(
const
[
key
value
]
of
Object
.
entries
(
event
.
request
.
headers
)
)
{
this
.
#
headers
[
key
.
toLowerCase
(
)
]
=
value
;
}
}
url
(
)
:
string
{
return
this
.
#
url
;
}
continueRequestOverrides
(
)
:
ContinueRequestOverrides
{
assert
(
this
.
#
allowInterception
'
Request
Interception
is
not
enabled
!
'
)
;
return
this
.
#
continueRequestOverrides
;
}
responseForRequest
(
)
:
Partial
<
ResponseForRequest
>
|
null
{
assert
(
this
.
#
allowInterception
'
Request
Interception
is
not
enabled
!
'
)
;
return
this
.
#
responseForRequest
;
}
abortErrorReason
(
)
:
Protocol
.
Network
.
ErrorReason
|
null
{
assert
(
this
.
#
allowInterception
'
Request
Interception
is
not
enabled
!
'
)
;
return
this
.
#
abortErrorReason
;
}
interceptResolutionState
(
)
:
InterceptResolutionState
{
if
(
!
this
.
#
allowInterception
)
{
return
{
action
:
InterceptResolutionAction
.
Disabled
}
;
}
if
(
this
.
#
interceptionHandled
)
{
return
{
action
:
InterceptResolutionAction
.
AlreadyHandled
}
;
}
return
{
.
.
.
this
.
#
interceptResolutionState
}
;
}
isInterceptResolutionHandled
(
)
:
boolean
{
return
this
.
#
interceptionHandled
;
}
enqueueInterceptAction
(
pendingHandler
:
(
)
=
>
void
|
PromiseLike
<
unknown
>
)
:
void
{
this
.
#
interceptHandlers
.
push
(
pendingHandler
)
;
}
async
finalizeInterceptions
(
)
:
Promise
<
void
>
{
await
this
.
#
interceptHandlers
.
reduce
(
(
promiseChain
interceptAction
)
=
>
{
return
promiseChain
.
then
(
interceptAction
)
;
}
Promise
.
resolve
(
)
)
;
const
{
action
}
=
this
.
interceptResolutionState
(
)
;
switch
(
action
)
{
case
'
abort
'
:
return
this
.
#
abort
(
this
.
#
abortErrorReason
)
;
case
'
respond
'
:
if
(
this
.
#
responseForRequest
=
=
=
null
)
{
throw
new
Error
(
'
Response
is
missing
for
the
interception
'
)
;
}
return
this
.
#
respond
(
this
.
#
responseForRequest
)
;
case
'
continue
'
:
return
this
.
#
continue
(
this
.
#
continueRequestOverrides
)
;
}
}
resourceType
(
)
:
ResourceType
{
return
this
.
#
resourceType
;
}
method
(
)
:
string
{
return
this
.
#
method
;
}
postData
(
)
:
string
|
undefined
{
return
this
.
#
postData
;
}
headers
(
)
:
Record
<
string
string
>
{
return
this
.
#
headers
;
}
response
(
)
:
HTTPResponse
|
null
{
return
this
.
_response
;
}
frame
(
)
:
Frame
|
null
{
return
this
.
#
frame
;
}
isNavigationRequest
(
)
:
boolean
{
return
this
.
#
isNavigationRequest
;
}
initiator
(
)
:
Protocol
.
Network
.
Initiator
{
return
this
.
#
initiator
;
}
redirectChain
(
)
:
HTTPRequest
[
]
{
return
this
.
_redirectChain
.
slice
(
)
;
}
failure
(
)
:
{
errorText
:
string
}
|
null
{
if
(
!
this
.
_failureText
)
{
return
null
;
}
return
{
errorText
:
this
.
_failureText
}
;
}
async
continue
(
overrides
:
ContinueRequestOverrides
=
{
}
priority
?
:
number
)
:
Promise
<
void
>
{
if
(
this
.
#
url
.
startsWith
(
'
data
:
'
)
)
{
return
;
}
assert
(
this
.
#
allowInterception
'
Request
Interception
is
not
enabled
!
'
)
;
assert
(
!
this
.
#
interceptionHandled
'
Request
is
already
handled
!
'
)
;
if
(
priority
=
=
=
undefined
)
{
return
this
.
#
continue
(
overrides
)
;
}
this
.
#
continueRequestOverrides
=
overrides
;
if
(
this
.
#
interceptResolutionState
.
priority
=
=
=
undefined
|
|
priority
>
this
.
#
interceptResolutionState
.
priority
)
{
this
.
#
interceptResolutionState
=
{
action
:
InterceptResolutionAction
.
Continue
priority
}
;
return
;
}
if
(
priority
=
=
=
this
.
#
interceptResolutionState
.
priority
)
{
if
(
this
.
#
interceptResolutionState
.
action
=
=
=
'
abort
'
|
|
this
.
#
interceptResolutionState
.
action
=
=
=
'
respond
'
)
{
return
;
}
this
.
#
interceptResolutionState
.
action
=
InterceptResolutionAction
.
Continue
;
}
return
;
}
async
#
continue
(
overrides
:
ContinueRequestOverrides
=
{
}
)
:
Promise
<
void
>
{
const
{
url
method
postData
headers
}
=
overrides
;
this
.
#
interceptionHandled
=
true
;
const
postDataBinaryBase64
=
postData
?
Buffer
.
from
(
postData
)
.
toString
(
'
base64
'
)
:
undefined
;
if
(
this
.
_interceptionId
=
=
=
undefined
)
{
throw
new
Error
(
'
HTTPRequest
is
missing
_interceptionId
needed
for
Fetch
.
continueRequest
'
)
;
}
await
this
.
#
client
.
send
(
'
Fetch
.
continueRequest
'
{
requestId
:
this
.
_interceptionId
url
method
postData
:
postDataBinaryBase64
headers
:
headers
?
headersArray
(
headers
)
:
undefined
}
)
.
catch
(
error
=
>
{
this
.
#
interceptionHandled
=
false
;
return
handleError
(
error
)
;
}
)
;
}
async
respond
(
response
:
Partial
<
ResponseForRequest
>
priority
?
:
number
)
:
Promise
<
void
>
{
if
(
this
.
#
url
.
startsWith
(
'
data
:
'
)
)
{
return
;
}
assert
(
this
.
#
allowInterception
'
Request
Interception
is
not
enabled
!
'
)
;
assert
(
!
this
.
#
interceptionHandled
'
Request
is
already
handled
!
'
)
;
if
(
priority
=
=
=
undefined
)
{
return
this
.
#
respond
(
response
)
;
}
this
.
#
responseForRequest
=
response
;
if
(
this
.
#
interceptResolutionState
.
priority
=
=
=
undefined
|
|
priority
>
this
.
#
interceptResolutionState
.
priority
)
{
this
.
#
interceptResolutionState
=
{
action
:
InterceptResolutionAction
.
Respond
priority
}
;
return
;
}
if
(
priority
=
=
=
this
.
#
interceptResolutionState
.
priority
)
{
if
(
this
.
#
interceptResolutionState
.
action
=
=
=
'
abort
'
)
{
return
;
}
this
.
#
interceptResolutionState
.
action
=
InterceptResolutionAction
.
Respond
;
}
}
async
#
respond
(
response
:
Partial
<
ResponseForRequest
>
)
:
Promise
<
void
>
{
this
.
#
interceptionHandled
=
true
;
const
responseBody
:
Buffer
|
null
=
response
.
body
&
&
isString
(
response
.
body
)
?
Buffer
.
from
(
response
.
body
)
:
(
response
.
body
as
Buffer
)
|
|
null
;
const
responseHeaders
:
Record
<
string
string
|
string
[
]
>
=
{
}
;
if
(
response
.
headers
)
{
for
(
const
header
of
Object
.
keys
(
response
.
headers
)
)
{
const
value
=
response
.
headers
[
header
]
;
responseHeaders
[
header
.
toLowerCase
(
)
]
=
Array
.
isArray
(
value
)
?
value
.
map
(
item
=
>
{
return
String
(
item
)
;
}
)
:
String
(
value
)
;
}
}
if
(
response
.
contentType
)
{
responseHeaders
[
'
content
-
type
'
]
=
response
.
contentType
;
}
if
(
responseBody
&
&
!
(
'
content
-
length
'
in
responseHeaders
)
)
{
responseHeaders
[
'
content
-
length
'
]
=
String
(
Buffer
.
byteLength
(
responseBody
)
)
;
}
const
status
=
response
.
status
|
|
200
;
if
(
this
.
_interceptionId
=
=
=
undefined
)
{
throw
new
Error
(
'
HTTPRequest
is
missing
_interceptionId
needed
for
Fetch
.
fulfillRequest
'
)
;
}
await
this
.
#
client
.
send
(
'
Fetch
.
fulfillRequest
'
{
requestId
:
this
.
_interceptionId
responseCode
:
status
responsePhrase
:
STATUS_TEXTS
[
status
]
responseHeaders
:
headersArray
(
responseHeaders
)
body
:
responseBody
?
responseBody
.
toString
(
'
base64
'
)
:
undefined
}
)
.
catch
(
error
=
>
{
this
.
#
interceptionHandled
=
false
;
return
handleError
(
error
)
;
}
)
;
}
async
abort
(
errorCode
:
ErrorCode
=
'
failed
'
priority
?
:
number
)
:
Promise
<
void
>
{
if
(
this
.
#
url
.
startsWith
(
'
data
:
'
)
)
{
return
;
}
const
errorReason
=
errorReasons
[
errorCode
]
;
assert
(
errorReason
'
Unknown
error
code
:
'
+
errorCode
)
;
assert
(
this
.
#
allowInterception
'
Request
Interception
is
not
enabled
!
'
)
;
assert
(
!
this
.
#
interceptionHandled
'
Request
is
already
handled
!
'
)
;
if
(
priority
=
=
=
undefined
)
{
return
this
.
#
abort
(
errorReason
)
;
}
this
.
#
abortErrorReason
=
errorReason
;
if
(
this
.
#
interceptResolutionState
.
priority
=
=
=
undefined
|
|
priority
>
=
this
.
#
interceptResolutionState
.
priority
)
{
this
.
#
interceptResolutionState
=
{
action
:
InterceptResolutionAction
.
Abort
priority
}
;
return
;
}
}
async
#
abort
(
errorReason
:
Protocol
.
Network
.
ErrorReason
|
null
)
:
Promise
<
void
>
{
this
.
#
interceptionHandled
=
true
;
if
(
this
.
_interceptionId
=
=
=
undefined
)
{
throw
new
Error
(
'
HTTPRequest
is
missing
_interceptionId
needed
for
Fetch
.
failRequest
'
)
;
}
await
this
.
#
client
.
send
(
'
Fetch
.
failRequest
'
{
requestId
:
this
.
_interceptionId
errorReason
:
errorReason
|
|
'
Failed
'
}
)
.
catch
(
handleError
)
;
}
}
export
enum
InterceptResolutionAction
{
Abort
=
'
abort
'
Respond
=
'
respond
'
Continue
=
'
continue
'
Disabled
=
'
disabled
'
None
=
'
none
'
AlreadyHandled
=
'
already
-
handled
'
}
export
type
InterceptResolutionStrategy
=
InterceptResolutionAction
;
export
type
ErrorCode
=
|
'
aborted
'
|
'
accessdenied
'
|
'
addressunreachable
'
|
'
blockedbyclient
'
|
'
blockedbyresponse
'
|
'
connectionaborted
'
|
'
connectionclosed
'
|
'
connectionfailed
'
|
'
connectionrefused
'
|
'
connectionreset
'
|
'
internetdisconnected
'
|
'
namenotresolved
'
|
'
timedout
'
|
'
failed
'
;
const
errorReasons
:
Record
<
ErrorCode
Protocol
.
Network
.
ErrorReason
>
=
{
aborted
:
'
Aborted
'
accessdenied
:
'
AccessDenied
'
addressunreachable
:
'
AddressUnreachable
'
blockedbyclient
:
'
BlockedByClient
'
blockedbyresponse
:
'
BlockedByResponse
'
connectionaborted
:
'
ConnectionAborted
'
connectionclosed
:
'
ConnectionClosed
'
connectionfailed
:
'
ConnectionFailed
'
connectionrefused
:
'
ConnectionRefused
'
connectionreset
:
'
ConnectionReset
'
internetdisconnected
:
'
InternetDisconnected
'
namenotresolved
:
'
NameNotResolved
'
timedout
:
'
TimedOut
'
failed
:
'
Failed
'
}
as
const
;
export
type
ActionResult
=
'
continue
'
|
'
abort
'
|
'
respond
'
;
function
headersArray
(
headers
:
Record
<
string
string
|
string
[
]
>
)
:
Array
<
{
name
:
string
;
value
:
string
}
>
{
const
result
=
[
]
;
for
(
const
name
in
headers
)
{
const
value
=
headers
[
name
]
;
if
(
!
Object
.
is
(
value
undefined
)
)
{
const
values
=
Array
.
isArray
(
value
)
?
value
:
[
value
]
;
result
.
push
(
.
.
.
values
.
map
(
value
=
>
{
return
{
name
value
:
value
+
'
'
}
;
}
)
)
;
}
}
return
result
;
}
async
function
handleError
(
error
:
ProtocolError
)
{
if
(
[
'
Invalid
header
'
]
.
includes
(
error
.
originalMessage
)
)
{
throw
error
;
}
debugError
(
error
)
;
}
const
STATUS_TEXTS
:
{
[
key
:
string
]
:
string
|
undefined
}
=
{
'
100
'
:
'
Continue
'
'
101
'
:
'
Switching
Protocols
'
'
102
'
:
'
Processing
'
'
103
'
:
'
Early
Hints
'
'
200
'
:
'
OK
'
'
201
'
:
'
Created
'
'
202
'
:
'
Accepted
'
'
203
'
:
'
Non
-
Authoritative
Information
'
'
204
'
:
'
No
Content
'
'
205
'
:
'
Reset
Content
'
'
206
'
:
'
Partial
Content
'
'
207
'
:
'
Multi
-
Status
'
'
208
'
:
'
Already
Reported
'
'
226
'
:
'
IM
Used
'
'
300
'
:
'
Multiple
Choices
'
'
301
'
:
'
Moved
Permanently
'
'
302
'
:
'
Found
'
'
303
'
:
'
See
Other
'
'
304
'
:
'
Not
Modified
'
'
305
'
:
'
Use
Proxy
'
'
306
'
:
'
Switch
Proxy
'
'
307
'
:
'
Temporary
Redirect
'
'
308
'
:
'
Permanent
Redirect
'
'
400
'
:
'
Bad
Request
'
'
401
'
:
'
Unauthorized
'
'
402
'
:
'
Payment
Required
'
'
403
'
:
'
Forbidden
'
'
404
'
:
'
Not
Found
'
'
405
'
:
'
Method
Not
Allowed
'
'
406
'
:
'
Not
Acceptable
'
'
407
'
:
'
Proxy
Authentication
Required
'
'
408
'
:
'
Request
Timeout
'
'
409
'
:
'
Conflict
'
'
410
'
:
'
Gone
'
'
411
'
:
'
Length
Required
'
'
412
'
:
'
Precondition
Failed
'
'
413
'
:
'
Payload
Too
Large
'
'
414
'
:
'
URI
Too
Long
'
'
415
'
:
'
Unsupported
Media
Type
'
'
416
'
:
'
Range
Not
Satisfiable
'
'
417
'
:
'
Expectation
Failed
'
'
418
'
:
"
I
'
m
a
teapot
"
'
421
'
:
'
Misdirected
Request
'
'
422
'
:
'
Unprocessable
Entity
'
'
423
'
:
'
Locked
'
'
424
'
:
'
Failed
Dependency
'
'
425
'
:
'
Too
Early
'
'
426
'
:
'
Upgrade
Required
'
'
428
'
:
'
Precondition
Required
'
'
429
'
:
'
Too
Many
Requests
'
'
431
'
:
'
Request
Header
Fields
Too
Large
'
'
451
'
:
'
Unavailable
For
Legal
Reasons
'
'
500
'
:
'
Internal
Server
Error
'
'
501
'
:
'
Not
Implemented
'
'
502
'
:
'
Bad
Gateway
'
'
503
'
:
'
Service
Unavailable
'
'
504
'
:
'
Gateway
Timeout
'
'
505
'
:
'
HTTP
Version
Not
Supported
'
'
506
'
:
'
Variant
Also
Negotiates
'
'
507
'
:
'
Insufficient
Storage
'
'
508
'
:
'
Loop
Detected
'
'
510
'
:
'
Not
Extended
'
'
511
'
:
'
Network
Authentication
Required
'
}
as
const
;
