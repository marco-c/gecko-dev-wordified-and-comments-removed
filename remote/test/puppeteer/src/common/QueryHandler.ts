import
{
ariaHandler
}
from
'
.
/
AriaQueryHandler
.
js
'
;
import
{
IsolatedWorld
WaitForSelectorOptions
}
from
'
.
/
IsolatedWorld
.
js
'
;
import
{
ElementHandle
}
from
'
.
/
ElementHandle
.
js
'
;
import
{
JSHandle
}
from
'
.
/
JSHandle
.
js
'
;
export
interface
CustomQueryHandler
{
queryOne
?
:
(
node
:
Node
selector
:
string
)
=
>
Node
|
null
;
queryAll
?
:
(
node
:
Node
selector
:
string
)
=
>
Node
[
]
;
}
export
interface
InternalQueryHandler
{
queryOne
?
:
(
element
:
ElementHandle
<
Node
>
selector
:
string
)
=
>
Promise
<
ElementHandle
<
Node
>
|
null
>
;
queryAll
?
:
(
element
:
ElementHandle
<
Node
>
selector
:
string
)
=
>
Promise
<
Array
<
ElementHandle
<
Node
>
>
>
;
queryAllArray
?
:
(
element
:
ElementHandle
<
Node
>
selector
:
string
)
=
>
Promise
<
JSHandle
<
Node
[
]
>
>
;
waitFor
?
:
(
isolatedWorld
:
IsolatedWorld
selector
:
string
options
:
WaitForSelectorOptions
)
=
>
Promise
<
ElementHandle
<
Node
>
|
null
>
;
}
function
internalizeCustomQueryHandler
(
handler
:
CustomQueryHandler
)
:
InternalQueryHandler
{
const
internalHandler
:
InternalQueryHandler
=
{
}
;
if
(
handler
.
queryOne
)
{
const
queryOne
=
handler
.
queryOne
;
internalHandler
.
queryOne
=
async
(
element
selector
)
=
>
{
const
jsHandle
=
await
element
.
evaluateHandle
(
queryOne
selector
)
;
const
elementHandle
=
jsHandle
.
asElement
(
)
;
if
(
elementHandle
)
{
return
elementHandle
;
}
await
jsHandle
.
dispose
(
)
;
return
null
;
}
;
internalHandler
.
waitFor
=
(
domWorld
:
IsolatedWorld
selector
:
string
options
:
WaitForSelectorOptions
)
=
>
{
return
domWorld
.
_waitForSelectorInPage
(
queryOne
selector
options
)
;
}
;
}
if
(
handler
.
queryAll
)
{
const
queryAll
=
handler
.
queryAll
;
internalHandler
.
queryAll
=
async
(
element
selector
)
=
>
{
const
jsHandle
=
await
element
.
evaluateHandle
(
queryAll
selector
)
;
const
properties
=
await
jsHandle
.
getProperties
(
)
;
await
jsHandle
.
dispose
(
)
;
const
result
=
[
]
;
for
(
const
property
of
properties
.
values
(
)
)
{
const
elementHandle
=
property
.
asElement
(
)
;
if
(
elementHandle
)
{
result
.
push
(
elementHandle
)
;
}
}
return
result
;
}
;
internalHandler
.
queryAllArray
=
async
(
element
selector
)
=
>
{
const
resultHandle
=
(
await
element
.
evaluateHandle
(
queryAll
selector
)
)
as
JSHandle
<
Element
[
]
|
NodeListOf
<
Element
>
>
;
const
arrayHandle
=
await
resultHandle
.
evaluateHandle
(
res
=
>
{
return
Array
.
from
(
res
)
;
}
)
;
return
arrayHandle
;
}
;
}
return
internalHandler
;
}
const
defaultHandler
=
internalizeCustomQueryHandler
(
{
queryOne
:
(
element
selector
)
=
>
{
if
(
!
(
'
querySelector
'
in
element
)
)
{
throw
new
Error
(
Could
not
invoke
\
querySelector
\
on
node
of
type
{
element
.
nodeName
}
.
)
;
}
return
(
element
as
unknown
as
{
querySelector
(
selector
:
string
)
:
Element
}
)
.
querySelector
(
selector
)
;
}
queryAll
:
(
element
selector
)
=
>
{
if
(
!
(
'
querySelectorAll
'
in
element
)
)
{
throw
new
Error
(
Could
not
invoke
\
querySelectorAll
\
on
node
of
type
{
element
.
nodeName
}
.
)
;
}
return
[
.
.
.
(
element
as
unknown
as
{
querySelectorAll
(
selector
:
string
)
:
NodeList
;
}
)
.
querySelectorAll
(
selector
)
]
;
}
}
)
;
const
pierceHandler
=
internalizeCustomQueryHandler
(
{
queryOne
:
(
element
selector
)
=
>
{
let
found
:
Node
|
null
=
null
;
const
search
=
(
root
:
Node
)
=
>
{
const
iter
=
document
.
createTreeWalker
(
root
NodeFilter
.
SHOW_ELEMENT
)
;
do
{
const
currentNode
=
iter
.
currentNode
as
HTMLElement
;
if
(
currentNode
.
shadowRoot
)
{
search
(
currentNode
.
shadowRoot
)
;
}
if
(
currentNode
instanceof
ShadowRoot
)
{
continue
;
}
if
(
currentNode
!
=
=
root
&
&
!
found
&
&
currentNode
.
matches
(
selector
)
)
{
found
=
currentNode
;
}
}
while
(
!
found
&
&
iter
.
nextNode
(
)
)
;
}
;
if
(
element
instanceof
Document
)
{
element
=
element
.
documentElement
;
}
search
(
element
)
;
return
found
;
}
queryAll
:
(
element
selector
)
=
>
{
const
result
:
Node
[
]
=
[
]
;
const
collect
=
(
root
:
Node
)
=
>
{
const
iter
=
document
.
createTreeWalker
(
root
NodeFilter
.
SHOW_ELEMENT
)
;
do
{
const
currentNode
=
iter
.
currentNode
as
HTMLElement
;
if
(
currentNode
.
shadowRoot
)
{
collect
(
currentNode
.
shadowRoot
)
;
}
if
(
currentNode
instanceof
ShadowRoot
)
{
continue
;
}
if
(
currentNode
!
=
=
root
&
&
currentNode
.
matches
(
selector
)
)
{
result
.
push
(
currentNode
)
;
}
}
while
(
iter
.
nextNode
(
)
)
;
}
;
if
(
element
instanceof
Document
)
{
element
=
element
.
documentElement
;
}
collect
(
element
)
;
return
result
;
}
}
)
;
const
xpathHandler
=
internalizeCustomQueryHandler
(
{
queryOne
:
(
element
selector
)
=
>
{
const
doc
=
element
.
ownerDocument
|
|
document
;
const
result
=
doc
.
evaluate
(
selector
element
null
XPathResult
.
FIRST_ORDERED_NODE_TYPE
)
;
return
result
.
singleNodeValue
;
}
queryAll
:
(
element
selector
)
=
>
{
const
doc
=
element
.
ownerDocument
|
|
document
;
const
iterator
=
doc
.
evaluate
(
selector
element
null
XPathResult
.
ORDERED_NODE_ITERATOR_TYPE
)
;
const
array
:
Node
[
]
=
[
]
;
let
item
;
while
(
(
item
=
iterator
.
iterateNext
(
)
)
)
{
array
.
push
(
item
)
;
}
return
array
;
}
}
)
;
interface
RegisteredQueryHandler
{
handler
:
InternalQueryHandler
;
transformSelector
?
:
(
selector
:
string
)
=
>
string
;
}
const
INTERNAL_QUERY_HANDLERS
=
new
Map
<
string
RegisteredQueryHandler
>
(
[
[
'
aria
'
{
handler
:
ariaHandler
}
]
[
'
pierce
'
{
handler
:
pierceHandler
}
]
[
'
xpath
'
{
handler
:
xpathHandler
}
]
]
)
;
const
QUERY_HANDLERS
=
new
Map
<
string
RegisteredQueryHandler
>
(
)
;
export
function
registerCustomQueryHandler
(
name
:
string
handler
:
CustomQueryHandler
)
:
void
{
if
(
INTERNAL_QUERY_HANDLERS
.
has
(
name
)
)
{
throw
new
Error
(
A
query
handler
named
"
{
name
}
"
already
exists
)
;
}
if
(
QUERY_HANDLERS
.
has
(
name
)
)
{
throw
new
Error
(
A
custom
query
handler
named
"
{
name
}
"
already
exists
)
;
}
const
isValidName
=
/
^
[
a
-
zA
-
Z
]
+
/
.
test
(
name
)
;
if
(
!
isValidName
)
{
throw
new
Error
(
Custom
query
handler
names
may
only
contain
[
a
-
zA
-
Z
]
)
;
}
QUERY_HANDLERS
.
set
(
name
{
handler
:
internalizeCustomQueryHandler
(
handler
)
}
)
;
}
export
function
unregisterCustomQueryHandler
(
name
:
string
)
:
void
{
QUERY_HANDLERS
.
delete
(
name
)
;
}
export
function
customQueryHandlerNames
(
)
:
string
[
]
{
return
[
.
.
.
QUERY_HANDLERS
.
keys
(
)
]
;
}
export
function
clearCustomQueryHandlers
(
)
:
void
{
QUERY_HANDLERS
.
clear
(
)
;
}
const
CUSTOM_QUERY_SEPARATORS
=
[
'
=
'
'
/
'
]
;
export
function
getQueryHandlerAndSelector
(
selector
:
string
)
:
{
updatedSelector
:
string
;
queryHandler
:
InternalQueryHandler
;
}
{
for
(
const
handlerMap
of
[
QUERY_HANDLERS
INTERNAL_QUERY_HANDLERS
]
)
{
for
(
const
[
name
{
handler
:
queryHandler
transformSelector
}
]
of
handlerMap
)
{
for
(
const
separator
of
CUSTOM_QUERY_SEPARATORS
)
{
const
prefix
=
{
name
}
{
separator
}
;
if
(
selector
.
startsWith
(
prefix
)
)
{
selector
=
selector
.
slice
(
prefix
.
length
)
;
if
(
transformSelector
)
{
selector
=
transformSelector
(
selector
)
;
}
return
{
updatedSelector
:
selector
queryHandler
}
;
}
}
}
}
return
{
updatedSelector
:
selector
queryHandler
:
defaultHandler
}
;
}
