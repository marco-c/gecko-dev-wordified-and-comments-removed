import
PuppeteerUtil
from
'
.
.
/
injected
/
injected
.
js
'
;
import
{
ariaHandler
}
from
'
.
/
AriaQueryHandler
.
js
'
;
import
{
ElementHandle
}
from
'
.
/
ElementHandle
.
js
'
;
import
{
Frame
}
from
'
.
/
Frame
.
js
'
;
import
{
MAIN_WORLD
PUPPETEER_WORLD
WaitForSelectorOptions
}
from
'
.
/
IsolatedWorld
.
js
'
;
export
interface
CustomQueryHandler
{
queryOne
?
:
(
node
:
Node
selector
:
string
)
=
>
Node
|
null
;
queryAll
?
:
(
node
:
Node
selector
:
string
)
=
>
Node
[
]
;
}
export
interface
InternalQueryHandler
{
queryOne
?
:
(
node
:
Node
selector
:
string
PuppeteerUtil
:
PuppeteerUtil
)
=
>
Node
|
null
;
queryAll
?
:
(
node
:
Node
selector
:
string
PuppeteerUtil
:
PuppeteerUtil
)
=
>
Node
[
]
;
}
export
interface
PuppeteerQueryHandler
{
queryOne
?
:
(
element
:
ElementHandle
<
Node
>
selector
:
string
)
=
>
Promise
<
ElementHandle
<
Node
>
|
null
>
;
queryAll
?
:
(
element
:
ElementHandle
<
Node
>
selector
:
string
)
=
>
Promise
<
Array
<
ElementHandle
<
Node
>
>
>
;
waitFor
?
:
(
elementOrFrame
:
ElementHandle
<
Node
>
|
Frame
selector
:
string
options
:
WaitForSelectorOptions
)
=
>
Promise
<
ElementHandle
<
Node
>
|
null
>
;
}
function
createPuppeteerQueryHandler
(
handler
:
InternalQueryHandler
)
:
PuppeteerQueryHandler
{
const
internalHandler
:
PuppeteerQueryHandler
=
{
}
;
if
(
handler
.
queryOne
)
{
const
queryOne
=
handler
.
queryOne
;
internalHandler
.
queryOne
=
async
(
element
selector
)
=
>
{
const
jsHandle
=
await
element
.
evaluateHandle
(
queryOne
selector
await
element
.
executionContext
(
)
.
_world
!
.
puppeteerUtil
)
;
const
elementHandle
=
jsHandle
.
asElement
(
)
;
if
(
elementHandle
)
{
return
elementHandle
;
}
await
jsHandle
.
dispose
(
)
;
return
null
;
}
;
internalHandler
.
waitFor
=
async
(
elementOrFrame
selector
options
)
=
>
{
let
frame
:
Frame
;
let
element
:
ElementHandle
<
Node
>
|
undefined
;
if
(
elementOrFrame
instanceof
Frame
)
{
frame
=
elementOrFrame
;
}
else
{
frame
=
elementOrFrame
.
frame
;
element
=
await
frame
.
worlds
[
PUPPETEER_WORLD
]
.
adoptHandle
(
elementOrFrame
)
;
}
const
result
=
await
frame
.
worlds
[
PUPPETEER_WORLD
]
.
_waitForSelectorInPage
(
queryOne
element
selector
options
)
;
if
(
element
)
{
await
element
.
dispose
(
)
;
}
if
(
!
result
)
{
return
null
;
}
if
(
!
(
result
instanceof
ElementHandle
)
)
{
await
result
.
dispose
(
)
;
return
null
;
}
return
frame
.
worlds
[
MAIN_WORLD
]
.
transferHandle
(
result
)
;
}
;
}
if
(
handler
.
queryAll
)
{
const
queryAll
=
handler
.
queryAll
;
internalHandler
.
queryAll
=
async
(
element
selector
)
=
>
{
const
jsHandle
=
await
element
.
evaluateHandle
(
queryAll
selector
await
element
.
executionContext
(
)
.
_world
!
.
puppeteerUtil
)
;
const
properties
=
await
jsHandle
.
getProperties
(
)
;
await
jsHandle
.
dispose
(
)
;
const
result
=
[
]
;
for
(
const
property
of
properties
.
values
(
)
)
{
const
elementHandle
=
property
.
asElement
(
)
;
if
(
elementHandle
)
{
result
.
push
(
elementHandle
)
;
}
}
return
result
;
}
;
}
return
internalHandler
;
}
const
defaultHandler
=
createPuppeteerQueryHandler
(
{
queryOne
:
(
element
selector
)
=
>
{
if
(
!
(
'
querySelector
'
in
element
)
)
{
throw
new
Error
(
Could
not
invoke
\
querySelector
\
on
node
of
type
{
element
.
nodeName
}
.
)
;
}
return
(
element
as
unknown
as
{
querySelector
(
selector
:
string
)
:
Element
}
)
.
querySelector
(
selector
)
;
}
queryAll
:
(
element
selector
)
=
>
{
if
(
!
(
'
querySelectorAll
'
in
element
)
)
{
throw
new
Error
(
Could
not
invoke
\
querySelectorAll
\
on
node
of
type
{
element
.
nodeName
}
.
)
;
}
return
[
.
.
.
(
element
as
unknown
as
{
querySelectorAll
(
selector
:
string
)
:
NodeList
;
}
)
.
querySelectorAll
(
selector
)
]
;
}
}
)
;
const
pierceHandler
=
createPuppeteerQueryHandler
(
{
queryOne
:
(
element
selector
{
pierceQuerySelector
}
)
=
>
{
return
pierceQuerySelector
(
element
selector
)
;
}
queryAll
:
(
element
selector
{
pierceQuerySelectorAll
}
)
=
>
{
return
pierceQuerySelectorAll
(
element
selector
)
;
}
}
)
;
const
xpathHandler
=
createPuppeteerQueryHandler
(
{
queryOne
:
(
element
selector
{
xpathQuerySelector
}
)
=
>
{
return
xpathQuerySelector
(
element
selector
)
;
}
queryAll
:
(
element
selector
{
xpathQuerySelectorAll
}
)
=
>
{
return
xpathQuerySelectorAll
(
element
selector
)
;
}
}
)
;
const
textQueryHandler
=
createPuppeteerQueryHandler
(
{
queryOne
:
(
element
selector
{
textQuerySelector
}
)
=
>
{
return
textQuerySelector
(
element
selector
)
;
}
queryAll
:
(
element
selector
{
textQuerySelectorAll
}
)
=
>
{
return
textQuerySelectorAll
(
element
selector
)
;
}
}
)
;
interface
RegisteredQueryHandler
{
handler
:
PuppeteerQueryHandler
;
transformSelector
?
:
(
selector
:
string
)
=
>
string
;
}
const
INTERNAL_QUERY_HANDLERS
=
new
Map
<
string
RegisteredQueryHandler
>
(
[
[
'
aria
'
{
handler
:
ariaHandler
}
]
[
'
pierce
'
{
handler
:
pierceHandler
}
]
[
'
xpath
'
{
handler
:
xpathHandler
}
]
[
'
text
'
{
handler
:
textQueryHandler
}
]
]
)
;
const
QUERY_HANDLERS
=
new
Map
<
string
RegisteredQueryHandler
>
(
)
;
export
function
registerCustomQueryHandler
(
name
:
string
handler
:
CustomQueryHandler
)
:
void
{
if
(
INTERNAL_QUERY_HANDLERS
.
has
(
name
)
)
{
throw
new
Error
(
A
query
handler
named
"
{
name
}
"
already
exists
)
;
}
if
(
QUERY_HANDLERS
.
has
(
name
)
)
{
throw
new
Error
(
A
custom
query
handler
named
"
{
name
}
"
already
exists
)
;
}
const
isValidName
=
/
^
[
a
-
zA
-
Z
]
+
/
.
test
(
name
)
;
if
(
!
isValidName
)
{
throw
new
Error
(
Custom
query
handler
names
may
only
contain
[
a
-
zA
-
Z
]
)
;
}
QUERY_HANDLERS
.
set
(
name
{
handler
:
createPuppeteerQueryHandler
(
handler
)
}
)
;
}
export
function
unregisterCustomQueryHandler
(
name
:
string
)
:
void
{
QUERY_HANDLERS
.
delete
(
name
)
;
}
export
function
customQueryHandlerNames
(
)
:
string
[
]
{
return
[
.
.
.
QUERY_HANDLERS
.
keys
(
)
]
;
}
export
function
clearCustomQueryHandlers
(
)
:
void
{
QUERY_HANDLERS
.
clear
(
)
;
}
const
CUSTOM_QUERY_SEPARATORS
=
[
'
=
'
'
/
'
]
;
export
function
getQueryHandlerAndSelector
(
selector
:
string
)
:
{
updatedSelector
:
string
;
queryHandler
:
PuppeteerQueryHandler
;
}
{
for
(
const
handlerMap
of
[
QUERY_HANDLERS
INTERNAL_QUERY_HANDLERS
]
)
{
for
(
const
[
name
{
handler
:
queryHandler
transformSelector
}
]
of
handlerMap
)
{
for
(
const
separator
of
CUSTOM_QUERY_SEPARATORS
)
{
const
prefix
=
{
name
}
{
separator
}
;
if
(
selector
.
startsWith
(
prefix
)
)
{
selector
=
selector
.
slice
(
prefix
.
length
)
;
if
(
transformSelector
)
{
selector
=
transformSelector
(
selector
)
;
}
return
{
updatedSelector
:
selector
queryHandler
}
;
}
}
}
}
return
{
updatedSelector
:
selector
queryHandler
:
defaultHandler
}
;
}
