import
{
WaitForSelectorOptions
DOMWorld
}
from
'
.
/
DOMWorld
.
js
'
;
import
{
ElementHandle
JSHandle
}
from
'
.
/
JSHandle
.
js
'
;
import
{
ariaHandler
}
from
'
.
/
AriaQueryHandler
.
js
'
;
export
interface
InternalQueryHandler
{
queryOne
?
:
(
element
:
ElementHandle
selector
:
string
)
=
>
Promise
<
ElementHandle
|
null
>
;
waitFor
?
:
(
domWorld
:
DOMWorld
selector
:
string
options
:
WaitForSelectorOptions
)
=
>
Promise
<
ElementHandle
|
null
>
;
queryAll
?
:
(
element
:
ElementHandle
selector
:
string
)
=
>
Promise
<
ElementHandle
[
]
>
;
queryAllArray
?
:
(
element
:
ElementHandle
selector
:
string
)
=
>
Promise
<
JSHandle
>
;
}
export
interface
CustomQueryHandler
{
queryOne
?
:
(
element
:
Element
|
Document
selector
:
string
)
=
>
Element
|
null
;
queryAll
?
:
(
element
:
Element
|
Document
selector
:
string
)
=
>
Element
[
]
|
NodeListOf
<
Element
>
;
}
function
makeQueryHandler
(
handler
:
CustomQueryHandler
)
:
InternalQueryHandler
{
const
internalHandler
:
InternalQueryHandler
=
{
}
;
if
(
handler
.
queryOne
)
{
internalHandler
.
queryOne
=
async
(
element
selector
)
=
>
{
const
jsHandle
=
await
element
.
evaluateHandle
(
handler
.
queryOne
selector
)
;
const
elementHandle
=
jsHandle
.
asElement
(
)
;
if
(
elementHandle
)
return
elementHandle
;
await
jsHandle
.
dispose
(
)
;
return
null
;
}
;
internalHandler
.
waitFor
=
(
domWorld
:
DOMWorld
selector
:
string
options
:
WaitForSelectorOptions
)
=
>
domWorld
.
waitForSelectorInPage
(
handler
.
queryOne
selector
options
)
;
}
if
(
handler
.
queryAll
)
{
internalHandler
.
queryAll
=
async
(
element
selector
)
=
>
{
const
jsHandle
=
await
element
.
evaluateHandle
(
handler
.
queryAll
selector
)
;
const
properties
=
await
jsHandle
.
getProperties
(
)
;
await
jsHandle
.
dispose
(
)
;
const
result
=
[
]
;
for
(
const
property
of
properties
.
values
(
)
)
{
const
elementHandle
=
property
.
asElement
(
)
;
if
(
elementHandle
)
result
.
push
(
elementHandle
)
;
}
return
result
;
}
;
internalHandler
.
queryAllArray
=
async
(
element
selector
)
=
>
{
const
resultHandle
=
await
element
.
evaluateHandle
(
handler
.
queryAll
selector
)
;
const
arrayHandle
=
await
resultHandle
.
evaluateHandle
(
(
res
:
Element
[
]
|
NodeListOf
<
Element
>
)
=
>
Array
.
from
(
res
)
)
;
return
arrayHandle
;
}
;
}
return
internalHandler
;
}
const
_defaultHandler
=
makeQueryHandler
(
{
queryOne
:
(
element
:
Element
selector
:
string
)
=
>
element
.
querySelector
(
selector
)
queryAll
:
(
element
:
Element
selector
:
string
)
=
>
element
.
querySelectorAll
(
selector
)
}
)
;
const
pierceHandler
=
makeQueryHandler
(
{
queryOne
:
(
element
selector
)
=
>
{
let
found
:
Element
|
null
=
null
;
const
search
=
(
root
:
Element
|
ShadowRoot
)
=
>
{
const
iter
=
document
.
createTreeWalker
(
root
NodeFilter
.
SHOW_ELEMENT
)
;
do
{
const
currentNode
=
iter
.
currentNode
as
HTMLElement
;
if
(
currentNode
.
shadowRoot
)
{
search
(
currentNode
.
shadowRoot
)
;
}
if
(
currentNode
instanceof
ShadowRoot
)
{
continue
;
}
if
(
!
found
&
&
currentNode
.
matches
(
selector
)
)
{
found
=
currentNode
;
}
}
while
(
!
found
&
&
iter
.
nextNode
(
)
)
;
}
;
if
(
element
instanceof
Document
)
{
element
=
element
.
documentElement
;
}
search
(
element
)
;
return
found
;
}
queryAll
:
(
element
selector
)
=
>
{
const
result
:
Element
[
]
=
[
]
;
const
collect
=
(
root
:
Element
|
ShadowRoot
)
=
>
{
const
iter
=
document
.
createTreeWalker
(
root
NodeFilter
.
SHOW_ELEMENT
)
;
do
{
const
currentNode
=
iter
.
currentNode
as
HTMLElement
;
if
(
currentNode
.
shadowRoot
)
{
collect
(
currentNode
.
shadowRoot
)
;
}
if
(
currentNode
instanceof
ShadowRoot
)
{
continue
;
}
if
(
currentNode
.
matches
(
selector
)
)
{
result
.
push
(
currentNode
)
;
}
}
while
(
iter
.
nextNode
(
)
)
;
}
;
if
(
element
instanceof
Document
)
{
element
=
element
.
documentElement
;
}
collect
(
element
)
;
return
result
;
}
}
)
;
const
_builtInHandlers
=
new
Map
(
[
[
'
aria
'
ariaHandler
]
[
'
pierce
'
pierceHandler
]
]
)
;
const
_queryHandlers
=
new
Map
(
_builtInHandlers
)
;
export
function
registerCustomQueryHandler
(
name
:
string
handler
:
CustomQueryHandler
)
:
void
{
if
(
_queryHandlers
.
get
(
name
)
)
throw
new
Error
(
A
custom
query
handler
named
"
{
name
}
"
already
exists
)
;
const
isValidName
=
/
^
[
a
-
zA
-
Z
]
+
/
.
test
(
name
)
;
if
(
!
isValidName
)
throw
new
Error
(
Custom
query
handler
names
may
only
contain
[
a
-
zA
-
Z
]
)
;
const
internalHandler
=
makeQueryHandler
(
handler
)
;
_queryHandlers
.
set
(
name
internalHandler
)
;
}
export
function
unregisterCustomQueryHandler
(
name
:
string
)
:
void
{
if
(
_queryHandlers
.
has
(
name
)
&
&
!
_builtInHandlers
.
has
(
name
)
)
{
_queryHandlers
.
delete
(
name
)
;
}
}
export
function
customQueryHandlerNames
(
)
:
string
[
]
{
return
[
.
.
.
_queryHandlers
.
keys
(
)
]
.
filter
(
(
name
)
=
>
!
_builtInHandlers
.
has
(
name
)
)
;
}
export
function
clearCustomQueryHandlers
(
)
:
void
{
customQueryHandlerNames
(
)
.
forEach
(
unregisterCustomQueryHandler
)
;
}
export
function
getQueryHandlerAndSelector
(
selector
:
string
)
:
{
updatedSelector
:
string
;
queryHandler
:
InternalQueryHandler
;
}
{
const
hasCustomQueryHandler
=
/
^
[
a
-
zA
-
Z
]
+
\
/
/
.
test
(
selector
)
;
if
(
!
hasCustomQueryHandler
)
return
{
updatedSelector
:
selector
queryHandler
:
_defaultHandler
}
;
const
index
=
selector
.
indexOf
(
'
/
'
)
;
const
name
=
selector
.
slice
(
0
index
)
;
const
updatedSelector
=
selector
.
slice
(
index
+
1
)
;
const
queryHandler
=
_queryHandlers
.
get
(
name
)
;
if
(
!
queryHandler
)
throw
new
Error
(
Query
set
to
use
"
{
name
}
"
but
no
query
handler
of
that
name
was
found
)
;
return
{
updatedSelector
queryHandler
}
;
}
