import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
assert
}
from
'
.
/
assert
.
js
'
;
import
{
CDPSession
}
from
'
.
/
Connection
.
js
'
;
import
type
{
ElementHandle
}
from
'
.
/
ElementHandle
.
js
'
;
import
{
ExecutionContext
}
from
'
.
/
ExecutionContext
.
js
'
;
import
{
MouseButton
}
from
'
.
/
Input
.
js
'
;
import
{
EvaluateFunc
HandleFor
HandleOr
}
from
'
.
/
types
.
js
'
;
import
{
createJSHandle
releaseObject
valueFromRemoteObject
}
from
'
.
/
util
.
js
'
;
declare
const
__JSHandleSymbol
:
unique
symbol
;
export
interface
BoxModel
{
content
:
Point
[
]
;
padding
:
Point
[
]
;
border
:
Point
[
]
;
margin
:
Point
[
]
;
width
:
number
;
height
:
number
;
}
export
interface
BoundingBox
extends
Point
{
width
:
number
;
height
:
number
;
}
export
class
JSHandle
<
T
=
unknown
>
{
[
__JSHandleSymbol
]
?
:
T
;
#
client
:
CDPSession
;
#
disposed
=
false
;
#
context
:
ExecutionContext
;
#
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
;
get
client
(
)
:
CDPSession
{
return
this
.
#
client
;
}
get
disposed
(
)
:
boolean
{
return
this
.
#
disposed
;
}
constructor
(
context
:
ExecutionContext
client
:
CDPSession
remoteObject
:
Protocol
.
Runtime
.
RemoteObject
)
{
this
.
#
context
=
context
;
this
.
#
client
=
client
;
this
.
#
remoteObject
=
remoteObject
;
}
executionContext
(
)
:
ExecutionContext
{
return
this
.
#
context
;
}
async
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
[
this
.
.
.
Params
]
>
=
EvaluateFunc
<
[
this
.
.
.
Params
]
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
return
await
this
.
executionContext
(
)
.
evaluate
(
pageFunction
this
.
.
.
args
)
;
}
async
evaluateHandle
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
[
this
.
.
.
Params
]
>
=
EvaluateFunc
<
[
this
.
.
.
Params
]
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
return
await
this
.
executionContext
(
)
.
evaluateHandle
(
pageFunction
this
.
.
.
args
)
;
}
async
getProperty
<
K
extends
keyof
T
>
(
propertyName
:
HandleOr
<
K
>
)
:
Promise
<
HandleFor
<
T
[
K
]
>
>
;
async
getProperty
(
propertyName
:
string
)
:
Promise
<
JSHandle
<
unknown
>
>
;
async
getProperty
<
K
extends
keyof
T
>
(
propertyName
:
HandleOr
<
K
>
)
:
Promise
<
HandleFor
<
T
[
K
]
>
>
{
return
this
.
evaluateHandle
(
(
object
propertyName
)
=
>
{
return
object
[
propertyName
]
;
}
propertyName
)
;
}
async
getProperties
(
)
:
Promise
<
Map
<
string
JSHandle
>
>
{
assert
(
this
.
#
remoteObject
.
objectId
)
;
const
response
=
await
this
.
#
client
.
send
(
'
Runtime
.
getProperties
'
{
objectId
:
this
.
#
remoteObject
.
objectId
ownProperties
:
true
}
)
;
const
result
=
new
Map
<
string
JSHandle
>
(
)
;
for
(
const
property
of
response
.
result
)
{
if
(
!
property
.
enumerable
|
|
!
property
.
value
)
{
continue
;
}
result
.
set
(
property
.
name
createJSHandle
(
this
.
#
context
property
.
value
)
)
;
}
return
result
;
}
async
jsonValue
(
)
:
Promise
<
T
>
{
if
(
!
this
.
#
remoteObject
.
objectId
)
{
return
valueFromRemoteObject
(
this
.
#
remoteObject
)
;
}
const
value
=
await
this
.
evaluate
(
object
=
>
{
return
object
;
}
)
;
if
(
value
=
=
=
undefined
)
{
throw
new
Error
(
'
Could
not
serialize
referenced
object
'
)
;
}
return
value
;
}
asElement
(
)
:
ElementHandle
<
Node
>
|
null
{
return
null
;
}
async
dispose
(
)
:
Promise
<
void
>
{
if
(
this
.
#
disposed
)
{
return
;
}
this
.
#
disposed
=
true
;
await
releaseObject
(
this
.
#
client
this
.
#
remoteObject
)
;
}
toString
(
)
:
string
{
if
(
!
this
.
#
remoteObject
.
objectId
)
{
return
'
JSHandle
:
'
+
valueFromRemoteObject
(
this
.
#
remoteObject
)
;
}
const
type
=
this
.
#
remoteObject
.
subtype
|
|
this
.
#
remoteObject
.
type
;
return
'
JSHandle
'
+
type
;
}
remoteObject
(
)
:
Protocol
.
Runtime
.
RemoteObject
{
return
this
.
#
remoteObject
;
}
}
export
interface
Offset
{
x
:
number
;
y
:
number
;
}
export
interface
ClickOptions
{
delay
?
:
number
;
button
?
:
MouseButton
;
clickCount
?
:
number
;
offset
?
:
Offset
;
}
export
interface
PressOptions
{
delay
?
:
number
;
text
?
:
string
;
}
export
interface
Point
{
x
:
number
;
y
:
number
;
}
