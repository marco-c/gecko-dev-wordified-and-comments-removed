import
{
ProtocolMapping
}
from
'
devtools
-
protocol
/
types
/
protocol
-
mapping
.
js
'
;
import
{
EventEmitter
}
from
'
.
/
EventEmitter
.
js
'
;
import
{
Frame
}
from
'
.
/
FrameManager
.
js
'
;
import
{
HTTPRequest
}
from
'
.
/
HTTPRequest
.
js
'
;
import
{
SecurityDetails
}
from
'
.
/
SecurityDetails
.
js
'
;
import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
ProtocolError
}
from
'
.
/
Errors
.
js
'
;
export
interface
RemoteAddress
{
ip
:
string
;
port
:
number
;
}
interface
CDPSession
extends
EventEmitter
{
send
<
T
extends
keyof
ProtocolMapping
.
Commands
>
(
method
:
T
.
.
.
paramArgs
:
ProtocolMapping
.
Commands
[
T
]
[
'
paramsType
'
]
)
:
Promise
<
ProtocolMapping
.
Commands
[
T
]
[
'
returnType
'
]
>
;
}
export
class
HTTPResponse
{
private
_client
:
CDPSession
;
private
_request
:
HTTPRequest
;
private
_contentPromise
:
Promise
<
Buffer
>
|
null
=
null
;
private
_bodyLoadedPromise
:
Promise
<
Error
|
void
>
;
private
_bodyLoadedPromiseFulfill
:
(
err
:
Error
|
void
)
=
>
void
;
private
_remoteAddress
:
RemoteAddress
;
private
_status
:
number
;
private
_statusText
:
string
;
private
_url
:
string
;
private
_fromDiskCache
:
boolean
;
private
_fromServiceWorker
:
boolean
;
private
_headers
:
Record
<
string
string
>
=
{
}
;
private
_securityDetails
:
SecurityDetails
|
null
;
constructor
(
client
:
CDPSession
request
:
HTTPRequest
responsePayload
:
Protocol
.
Network
.
Response
extraInfo
:
Protocol
.
Network
.
ResponseReceivedExtraInfoEvent
|
null
)
{
this
.
_client
=
client
;
this
.
_request
=
request
;
this
.
_bodyLoadedPromise
=
new
Promise
(
(
fulfill
)
=
>
{
this
.
_bodyLoadedPromiseFulfill
=
fulfill
;
}
)
;
this
.
_remoteAddress
=
{
ip
:
responsePayload
.
remoteIPAddress
port
:
responsePayload
.
remotePort
}
;
this
.
_statusText
=
this
.
_parseStatusTextFromExtrInfo
(
extraInfo
)
|
|
responsePayload
.
statusText
;
this
.
_url
=
request
.
url
(
)
;
this
.
_fromDiskCache
=
!
!
responsePayload
.
fromDiskCache
;
this
.
_fromServiceWorker
=
!
!
responsePayload
.
fromServiceWorker
;
this
.
_status
=
extraInfo
?
extraInfo
.
statusCode
:
responsePayload
.
status
;
const
headers
=
extraInfo
?
extraInfo
.
headers
:
responsePayload
.
headers
;
for
(
const
key
of
Object
.
keys
(
headers
)
)
this
.
_headers
[
key
.
toLowerCase
(
)
]
=
headers
[
key
]
;
this
.
_securityDetails
=
responsePayload
.
securityDetails
?
new
SecurityDetails
(
responsePayload
.
securityDetails
)
:
null
;
}
_parseStatusTextFromExtrInfo
(
extraInfo
:
Protocol
.
Network
.
ResponseReceivedExtraInfoEvent
|
null
)
:
string
|
undefined
{
if
(
!
extraInfo
|
|
!
extraInfo
.
headersText
)
return
;
const
firstLine
=
extraInfo
.
headersText
.
split
(
'
\
r
'
1
)
[
0
]
;
if
(
!
firstLine
)
return
;
const
match
=
firstLine
.
match
(
/
[
^
]
*
[
^
]
*
(
.
*
)
/
)
;
if
(
!
match
)
return
;
const
statusText
=
match
[
1
]
;
if
(
!
statusText
)
return
;
return
statusText
;
}
_resolveBody
(
err
:
Error
|
null
)
:
void
{
return
this
.
_bodyLoadedPromiseFulfill
(
err
)
;
}
remoteAddress
(
)
:
RemoteAddress
{
return
this
.
_remoteAddress
;
}
url
(
)
:
string
{
return
this
.
_url
;
}
ok
(
)
:
boolean
{
return
this
.
_status
=
=
=
0
|
|
(
this
.
_status
>
=
200
&
&
this
.
_status
<
=
299
)
;
}
status
(
)
:
number
{
return
this
.
_status
;
}
statusText
(
)
:
string
{
return
this
.
_statusText
;
}
headers
(
)
:
Record
<
string
string
>
{
return
this
.
_headers
;
}
securityDetails
(
)
:
SecurityDetails
|
null
{
return
this
.
_securityDetails
;
}
buffer
(
)
:
Promise
<
Buffer
>
{
if
(
!
this
.
_contentPromise
)
{
this
.
_contentPromise
=
this
.
_bodyLoadedPromise
.
then
(
async
(
error
)
=
>
{
if
(
error
)
throw
error
;
try
{
const
response
=
await
this
.
_client
.
send
(
'
Network
.
getResponseBody
'
{
requestId
:
this
.
_request
.
_requestId
}
)
;
return
Buffer
.
from
(
response
.
body
response
.
base64Encoded
?
'
base64
'
:
'
utf8
'
)
;
}
catch
(
error
)
{
if
(
error
instanceof
ProtocolError
&
&
error
.
originalMessage
=
=
=
'
No
resource
with
given
identifier
found
'
)
{
throw
new
ProtocolError
(
'
Could
not
load
body
for
this
request
.
This
might
happen
if
the
request
is
a
preflight
request
.
'
)
;
}
throw
error
;
}
}
)
;
}
return
this
.
_contentPromise
;
}
async
text
(
)
:
Promise
<
string
>
{
const
content
=
await
this
.
buffer
(
)
;
return
content
.
toString
(
'
utf8
'
)
;
}
async
json
(
)
:
Promise
<
any
>
{
const
content
=
await
this
.
text
(
)
;
return
JSON
.
parse
(
content
)
;
}
request
(
)
:
HTTPRequest
{
return
this
.
_request
;
}
fromCache
(
)
:
boolean
{
return
this
.
_fromDiskCache
|
|
this
.
_request
.
_fromMemoryCache
;
}
fromServiceWorker
(
)
:
boolean
{
return
this
.
_fromServiceWorker
;
}
frame
(
)
:
Frame
|
null
{
return
this
.
_request
.
frame
(
)
;
}
}
