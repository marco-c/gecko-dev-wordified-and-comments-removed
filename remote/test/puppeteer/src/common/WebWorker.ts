import
{
EventEmitter
}
from
'
.
/
EventEmitter
.
js
'
;
import
{
debugError
}
from
'
.
/
helper
.
js
'
;
import
{
ExecutionContext
}
from
'
.
/
ExecutionContext
.
js
'
;
import
{
JSHandle
}
from
'
.
/
JSHandle
.
js
'
;
import
{
CDPSession
}
from
'
.
/
Connection
.
js
'
;
import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
EvaluateHandleFn
SerializableOrJSHandle
}
from
'
.
/
EvalTypes
.
js
'
;
type
ConsoleAPICalledCallback
=
(
eventType
:
string
handles
:
JSHandle
[
]
trace
:
Protocol
.
Runtime
.
StackTrace
)
=
>
void
;
type
ExceptionThrownCallback
=
(
details
:
Protocol
.
Runtime
.
ExceptionDetails
)
=
>
void
;
type
JSHandleFactory
=
(
obj
:
Protocol
.
Runtime
.
RemoteObject
)
=
>
JSHandle
;
export
class
WebWorker
extends
EventEmitter
{
_client
:
CDPSession
;
_url
:
string
;
_executionContextPromise
:
Promise
<
ExecutionContext
>
;
_executionContextCallback
:
(
value
:
ExecutionContext
)
=
>
void
;
constructor
(
client
:
CDPSession
url
:
string
consoleAPICalled
:
ConsoleAPICalledCallback
exceptionThrown
:
ExceptionThrownCallback
)
{
super
(
)
;
this
.
_client
=
client
;
this
.
_url
=
url
;
this
.
_executionContextPromise
=
new
Promise
<
ExecutionContext
>
(
(
x
)
=
>
(
this
.
_executionContextCallback
=
x
)
)
;
let
jsHandleFactory
:
JSHandleFactory
;
this
.
_client
.
once
(
'
Runtime
.
executionContextCreated
'
async
(
event
)
=
>
{
jsHandleFactory
=
(
remoteObject
)
=
>
new
JSHandle
(
executionContext
client
remoteObject
)
;
const
executionContext
=
new
ExecutionContext
(
client
event
.
context
null
)
;
this
.
_executionContextCallback
(
executionContext
)
;
}
)
;
this
.
_client
.
send
(
'
Runtime
.
enable
'
)
.
catch
(
debugError
)
;
this
.
_client
.
on
(
'
Runtime
.
consoleAPICalled
'
(
event
)
=
>
consoleAPICalled
(
event
.
type
event
.
args
.
map
(
jsHandleFactory
)
event
.
stackTrace
)
)
;
this
.
_client
.
on
(
'
Runtime
.
exceptionThrown
'
(
exception
)
=
>
exceptionThrown
(
exception
.
exceptionDetails
)
)
;
}
url
(
)
:
string
{
return
this
.
_url
;
}
async
executionContext
(
)
:
Promise
<
ExecutionContext
>
{
return
this
.
_executionContextPromise
;
}
async
evaluate
<
ReturnType
extends
any
>
(
pageFunction
:
Function
|
string
.
.
.
args
:
any
[
]
)
:
Promise
<
ReturnType
>
{
return
(
await
this
.
_executionContextPromise
)
.
evaluate
<
ReturnType
>
(
pageFunction
.
.
.
args
)
;
}
async
evaluateHandle
<
HandlerType
extends
JSHandle
=
JSHandle
>
(
pageFunction
:
EvaluateHandleFn
.
.
.
args
:
SerializableOrJSHandle
[
]
)
:
Promise
<
JSHandle
>
{
return
(
await
this
.
_executionContextPromise
)
.
evaluateHandle
<
HandlerType
>
(
pageFunction
.
.
.
args
)
;
}
}
