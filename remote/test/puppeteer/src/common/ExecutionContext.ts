import
{
assert
}
from
'
.
/
assert
.
js
'
;
import
{
helper
}
from
'
.
/
helper
.
js
'
;
import
{
createJSHandle
JSHandle
ElementHandle
}
from
'
.
/
JSHandle
.
js
'
;
import
{
CDPSession
}
from
'
.
/
Connection
.
js
'
;
import
{
DOMWorld
}
from
'
.
/
DOMWorld
.
js
'
;
import
{
Frame
}
from
'
.
/
FrameManager
.
js
'
;
import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
EvaluateHandleFn
SerializableOrJSHandle
}
from
'
.
/
EvalTypes
.
js
'
;
export
const
EVALUATION_SCRIPT_URL
=
'
__puppeteer_evaluation_script__
'
;
const
SOURCE_URL_REGEX
=
/
^
[
\
040
\
t
]
*
\
/
\
/
[
#
]
sourceURL
=
\
s
*
(
\
S
*
?
)
\
s
*
/
m
;
export
class
ExecutionContext
{
_client
:
CDPSession
;
_world
:
DOMWorld
;
_contextId
:
number
;
constructor
(
client
:
CDPSession
contextPayload
:
Protocol
.
Runtime
.
ExecutionContextDescription
world
:
DOMWorld
)
{
this
.
_client
=
client
;
this
.
_world
=
world
;
this
.
_contextId
=
contextPayload
.
id
;
}
frame
(
)
:
Frame
|
null
{
return
this
.
_world
?
this
.
_world
.
frame
(
)
:
null
;
}
async
evaluate
<
ReturnType
extends
any
>
(
pageFunction
:
Function
|
string
.
.
.
args
:
unknown
[
]
)
:
Promise
<
ReturnType
>
{
return
await
this
.
_evaluateInternal
<
ReturnType
>
(
true
pageFunction
.
.
.
args
)
;
}
async
evaluateHandle
<
HandleType
extends
JSHandle
|
ElementHandle
=
JSHandle
>
(
pageFunction
:
EvaluateHandleFn
.
.
.
args
:
SerializableOrJSHandle
[
]
)
:
Promise
<
HandleType
>
{
return
this
.
_evaluateInternal
<
HandleType
>
(
false
pageFunction
.
.
.
args
)
;
}
private
async
_evaluateInternal
<
ReturnType
>
(
returnByValue
:
boolean
pageFunction
:
Function
|
string
.
.
.
args
:
unknown
[
]
)
:
Promise
<
ReturnType
>
{
const
suffix
=
/
/
#
sourceURL
=
{
EVALUATION_SCRIPT_URL
}
;
if
(
helper
.
isString
(
pageFunction
)
)
{
const
contextId
=
this
.
_contextId
;
const
expression
=
pageFunction
;
const
expressionWithSourceUrl
=
SOURCE_URL_REGEX
.
test
(
expression
)
?
expression
:
expression
+
'
\
n
'
+
suffix
;
const
{
exceptionDetails
result
:
remoteObject
}
=
await
this
.
_client
.
send
(
'
Runtime
.
evaluate
'
{
expression
:
expressionWithSourceUrl
contextId
returnByValue
awaitPromise
:
true
userGesture
:
true
}
)
.
catch
(
rewriteError
)
;
if
(
exceptionDetails
)
throw
new
Error
(
'
Evaluation
failed
:
'
+
helper
.
getExceptionMessage
(
exceptionDetails
)
)
;
return
returnByValue
?
helper
.
valueFromRemoteObject
(
remoteObject
)
:
createJSHandle
(
this
remoteObject
)
;
}
if
(
typeof
pageFunction
!
=
=
'
function
'
)
throw
new
Error
(
Expected
to
get
|
string
|
or
|
function
|
as
the
first
argument
but
got
"
{
pageFunction
}
"
instead
.
)
;
let
functionText
=
pageFunction
.
toString
(
)
;
try
{
new
Function
(
'
(
'
+
functionText
+
'
)
'
)
;
}
catch
(
error
)
{
if
(
functionText
.
startsWith
(
'
async
'
)
)
functionText
=
'
async
function
'
+
functionText
.
substring
(
'
async
'
.
length
)
;
else
functionText
=
'
function
'
+
functionText
;
try
{
new
Function
(
'
(
'
+
functionText
+
'
)
'
)
;
}
catch
(
error
)
{
throw
new
Error
(
'
Passed
function
is
not
well
-
serializable
!
'
)
;
}
}
let
callFunctionOnPromise
;
try
{
callFunctionOnPromise
=
this
.
_client
.
send
(
'
Runtime
.
callFunctionOn
'
{
functionDeclaration
:
functionText
+
'
\
n
'
+
suffix
+
'
\
n
'
executionContextId
:
this
.
_contextId
arguments
:
args
.
map
(
convertArgument
.
bind
(
this
)
)
returnByValue
awaitPromise
:
true
userGesture
:
true
}
)
;
}
catch
(
error
)
{
if
(
error
instanceof
TypeError
&
&
error
.
message
.
startsWith
(
'
Converting
circular
structure
to
JSON
'
)
)
error
.
message
+
=
'
Are
you
passing
a
nested
JSHandle
?
'
;
throw
error
;
}
const
{
exceptionDetails
result
:
remoteObject
}
=
await
callFunctionOnPromise
.
catch
(
rewriteError
)
;
if
(
exceptionDetails
)
throw
new
Error
(
'
Evaluation
failed
:
'
+
helper
.
getExceptionMessage
(
exceptionDetails
)
)
;
return
returnByValue
?
helper
.
valueFromRemoteObject
(
remoteObject
)
:
createJSHandle
(
this
remoteObject
)
;
function
convertArgument
(
this
:
ExecutionContext
arg
:
unknown
)
:
unknown
{
if
(
typeof
arg
=
=
=
'
bigint
'
)
return
{
unserializableValue
:
{
arg
.
toString
(
)
}
n
}
;
if
(
Object
.
is
(
arg
-
0
)
)
return
{
unserializableValue
:
'
-
0
'
}
;
if
(
Object
.
is
(
arg
Infinity
)
)
return
{
unserializableValue
:
'
Infinity
'
}
;
if
(
Object
.
is
(
arg
-
Infinity
)
)
return
{
unserializableValue
:
'
-
Infinity
'
}
;
if
(
Object
.
is
(
arg
NaN
)
)
return
{
unserializableValue
:
'
NaN
'
}
;
const
objectHandle
=
arg
&
&
arg
instanceof
JSHandle
?
arg
:
null
;
if
(
objectHandle
)
{
if
(
objectHandle
.
_context
!
=
=
this
)
throw
new
Error
(
'
JSHandles
can
be
evaluated
only
in
the
context
they
were
created
!
'
)
;
if
(
objectHandle
.
_disposed
)
throw
new
Error
(
'
JSHandle
is
disposed
!
'
)
;
if
(
objectHandle
.
_remoteObject
.
unserializableValue
)
return
{
unserializableValue
:
objectHandle
.
_remoteObject
.
unserializableValue
}
;
if
(
!
objectHandle
.
_remoteObject
.
objectId
)
return
{
value
:
objectHandle
.
_remoteObject
.
value
}
;
return
{
objectId
:
objectHandle
.
_remoteObject
.
objectId
}
;
}
return
{
value
:
arg
}
;
}
function
rewriteError
(
error
:
Error
)
:
Protocol
.
Runtime
.
EvaluateResponse
{
if
(
error
.
message
.
includes
(
'
Object
reference
chain
is
too
long
'
)
)
return
{
result
:
{
type
:
'
undefined
'
}
}
;
if
(
error
.
message
.
includes
(
"
Object
couldn
'
t
be
returned
by
value
"
)
)
return
{
result
:
{
type
:
'
undefined
'
}
}
;
if
(
error
.
message
.
endsWith
(
'
Cannot
find
context
with
specified
id
'
)
|
|
error
.
message
.
endsWith
(
'
Inspected
target
navigated
or
closed
'
)
)
throw
new
Error
(
'
Execution
context
was
destroyed
most
likely
because
of
a
navigation
.
'
)
;
throw
error
;
}
}
async
queryObjects
(
prototypeHandle
:
JSHandle
)
:
Promise
<
JSHandle
>
{
assert
(
!
prototypeHandle
.
_disposed
'
Prototype
JSHandle
is
disposed
!
'
)
;
assert
(
prototypeHandle
.
_remoteObject
.
objectId
'
Prototype
JSHandle
must
not
be
referencing
primitive
value
'
)
;
const
response
=
await
this
.
_client
.
send
(
'
Runtime
.
queryObjects
'
{
prototypeObjectId
:
prototypeHandle
.
_remoteObject
.
objectId
}
)
;
return
createJSHandle
(
this
response
.
objects
)
;
}
async
_adoptBackendNodeId
(
backendNodeId
:
Protocol
.
DOM
.
BackendNodeId
)
:
Promise
<
ElementHandle
>
{
const
{
object
}
=
await
this
.
_client
.
send
(
'
DOM
.
resolveNode
'
{
backendNodeId
:
backendNodeId
executionContextId
:
this
.
_contextId
}
)
;
return
createJSHandle
(
this
object
)
as
ElementHandle
;
}
async
_adoptElementHandle
(
elementHandle
:
ElementHandle
)
:
Promise
<
ElementHandle
>
{
assert
(
elementHandle
.
executionContext
(
)
!
=
=
this
'
Cannot
adopt
handle
that
already
belongs
to
this
execution
context
'
)
;
assert
(
this
.
_world
'
Cannot
adopt
handle
without
DOMWorld
'
)
;
const
nodeInfo
=
await
this
.
_client
.
send
(
'
DOM
.
describeNode
'
{
objectId
:
elementHandle
.
_remoteObject
.
objectId
}
)
;
return
this
.
_adoptBackendNodeId
(
nodeInfo
.
node
.
backendNodeId
)
;
}
}
