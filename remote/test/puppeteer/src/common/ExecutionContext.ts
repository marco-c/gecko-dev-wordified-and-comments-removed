import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
assert
}
from
'
.
/
assert
.
js
'
;
import
{
CDPSession
}
from
'
.
/
Connection
.
js
'
;
import
{
Frame
}
from
'
.
/
FrameManager
.
js
'
;
import
{
IsolatedWorld
}
from
'
.
/
IsolatedWorld
.
js
'
;
import
{
JSHandle
}
from
'
.
/
JSHandle
.
js
'
;
import
{
EvaluateFunc
HandleFor
}
from
'
.
/
types
.
js
'
;
import
{
createJSHandle
getExceptionMessage
isString
valueFromRemoteObject
}
from
'
.
/
util
.
js
'
;
export
const
EVALUATION_SCRIPT_URL
=
'
pptr
:
/
/
__puppeteer_evaluation_script__
'
;
const
SOURCE_URL_REGEX
=
/
^
[
\
040
\
t
]
*
\
/
\
/
[
#
]
sourceURL
=
\
s
*
(
\
S
*
?
)
\
s
*
/
m
;
export
class
ExecutionContext
{
_client
:
CDPSession
;
_world
?
:
IsolatedWorld
;
_contextId
:
number
;
_contextName
:
string
;
constructor
(
client
:
CDPSession
contextPayload
:
Protocol
.
Runtime
.
ExecutionContextDescription
world
?
:
IsolatedWorld
)
{
this
.
_client
=
client
;
this
.
_world
=
world
;
this
.
_contextId
=
contextPayload
.
id
;
this
.
_contextName
=
contextPayload
.
name
;
}
frame
(
)
:
Frame
|
null
{
return
this
.
_world
?
this
.
_world
.
frame
(
)
:
null
;
}
async
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
{
return
await
this
.
#
evaluate
(
true
pageFunction
.
.
.
args
)
;
}
async
evaluateHandle
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
{
return
this
.
#
evaluate
(
false
pageFunction
.
.
.
args
)
;
}
async
#
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
returnByValue
:
true
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
Awaited
<
ReturnType
<
Func
>
>
>
;
async
#
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
returnByValue
:
false
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
>
;
async
#
evaluate
<
Params
extends
unknown
[
]
Func
extends
EvaluateFunc
<
Params
>
=
EvaluateFunc
<
Params
>
>
(
returnByValue
:
boolean
pageFunction
:
Func
|
string
.
.
.
args
:
Params
)
:
Promise
<
HandleFor
<
Awaited
<
ReturnType
<
Func
>
>
>
|
Awaited
<
ReturnType
<
Func
>
>
>
{
const
suffix
=
/
/
#
sourceURL
=
{
EVALUATION_SCRIPT_URL
}
;
if
(
isString
(
pageFunction
)
)
{
const
contextId
=
this
.
_contextId
;
const
expression
=
pageFunction
;
const
expressionWithSourceUrl
=
SOURCE_URL_REGEX
.
test
(
expression
)
?
expression
:
expression
+
'
\
n
'
+
suffix
;
const
{
exceptionDetails
result
:
remoteObject
}
=
await
this
.
_client
.
send
(
'
Runtime
.
evaluate
'
{
expression
:
expressionWithSourceUrl
contextId
returnByValue
awaitPromise
:
true
userGesture
:
true
}
)
.
catch
(
rewriteError
)
;
if
(
exceptionDetails
)
{
throw
new
Error
(
'
Evaluation
failed
:
'
+
getExceptionMessage
(
exceptionDetails
)
)
;
}
return
returnByValue
?
valueFromRemoteObject
(
remoteObject
)
:
createJSHandle
(
this
remoteObject
)
;
}
let
functionText
=
pageFunction
.
toString
(
)
;
try
{
new
Function
(
'
(
'
+
functionText
+
'
)
'
)
;
}
catch
(
error
)
{
if
(
functionText
.
startsWith
(
'
async
'
)
)
{
functionText
=
'
async
function
'
+
functionText
.
substring
(
'
async
'
.
length
)
;
}
else
{
functionText
=
'
function
'
+
functionText
;
}
try
{
new
Function
(
'
(
'
+
functionText
+
'
)
'
)
;
}
catch
(
error
)
{
throw
new
Error
(
'
Passed
function
is
not
well
-
serializable
!
'
)
;
}
}
let
callFunctionOnPromise
;
try
{
callFunctionOnPromise
=
this
.
_client
.
send
(
'
Runtime
.
callFunctionOn
'
{
functionDeclaration
:
functionText
+
'
\
n
'
+
suffix
+
'
\
n
'
executionContextId
:
this
.
_contextId
arguments
:
args
.
map
(
convertArgument
.
bind
(
this
)
)
returnByValue
awaitPromise
:
true
userGesture
:
true
}
)
;
}
catch
(
error
)
{
if
(
error
instanceof
TypeError
&
&
error
.
message
.
startsWith
(
'
Converting
circular
structure
to
JSON
'
)
)
{
error
.
message
+
=
'
Recursive
objects
are
not
allowed
.
'
;
}
throw
error
;
}
const
{
exceptionDetails
result
:
remoteObject
}
=
await
callFunctionOnPromise
.
catch
(
rewriteError
)
;
if
(
exceptionDetails
)
{
throw
new
Error
(
'
Evaluation
failed
:
'
+
getExceptionMessage
(
exceptionDetails
)
)
;
}
return
returnByValue
?
valueFromRemoteObject
(
remoteObject
)
:
createJSHandle
(
this
remoteObject
)
;
function
convertArgument
(
this
:
ExecutionContext
arg
:
unknown
)
:
Protocol
.
Runtime
.
CallArgument
{
if
(
typeof
arg
=
=
=
'
bigint
'
)
{
return
{
unserializableValue
:
{
arg
.
toString
(
)
}
n
}
;
}
if
(
Object
.
is
(
arg
-
0
)
)
{
return
{
unserializableValue
:
'
-
0
'
}
;
}
if
(
Object
.
is
(
arg
Infinity
)
)
{
return
{
unserializableValue
:
'
Infinity
'
}
;
}
if
(
Object
.
is
(
arg
-
Infinity
)
)
{
return
{
unserializableValue
:
'
-
Infinity
'
}
;
}
if
(
Object
.
is
(
arg
NaN
)
)
{
return
{
unserializableValue
:
'
NaN
'
}
;
}
const
objectHandle
=
arg
&
&
arg
instanceof
JSHandle
?
arg
:
null
;
if
(
objectHandle
)
{
if
(
objectHandle
.
executionContext
(
)
!
=
=
this
)
{
throw
new
Error
(
'
JSHandles
can
be
evaluated
only
in
the
context
they
were
created
!
'
)
;
}
if
(
objectHandle
.
disposed
)
{
throw
new
Error
(
'
JSHandle
is
disposed
!
'
)
;
}
if
(
objectHandle
.
remoteObject
(
)
.
unserializableValue
)
{
return
{
unserializableValue
:
objectHandle
.
remoteObject
(
)
.
unserializableValue
}
;
}
if
(
!
objectHandle
.
remoteObject
(
)
.
objectId
)
{
return
{
value
:
objectHandle
.
remoteObject
(
)
.
value
}
;
}
return
{
objectId
:
objectHandle
.
remoteObject
(
)
.
objectId
}
;
}
return
{
value
:
arg
}
;
}
function
rewriteError
(
error
:
Error
)
:
Protocol
.
Runtime
.
EvaluateResponse
{
if
(
error
.
message
.
includes
(
'
Object
reference
chain
is
too
long
'
)
)
{
return
{
result
:
{
type
:
'
undefined
'
}
}
;
}
if
(
error
.
message
.
includes
(
"
Object
couldn
'
t
be
returned
by
value
"
)
)
{
return
{
result
:
{
type
:
'
undefined
'
}
}
;
}
if
(
error
.
message
.
endsWith
(
'
Cannot
find
context
with
specified
id
'
)
|
|
error
.
message
.
endsWith
(
'
Inspected
target
navigated
or
closed
'
)
)
{
throw
new
Error
(
'
Execution
context
was
destroyed
most
likely
because
of
a
navigation
.
'
)
;
}
throw
error
;
}
}
async
queryObjects
<
Prototype
>
(
prototypeHandle
:
JSHandle
<
Prototype
>
)
:
Promise
<
HandleFor
<
Prototype
[
]
>
>
{
assert
(
!
prototypeHandle
.
disposed
'
Prototype
JSHandle
is
disposed
!
'
)
;
const
remoteObject
=
prototypeHandle
.
remoteObject
(
)
;
assert
(
remoteObject
.
objectId
'
Prototype
JSHandle
must
not
be
referencing
primitive
value
'
)
;
const
response
=
await
this
.
_client
.
send
(
'
Runtime
.
queryObjects
'
{
prototypeObjectId
:
remoteObject
.
objectId
}
)
;
return
createJSHandle
(
this
response
.
objects
)
as
HandleFor
<
Prototype
[
]
>
;
}
}
