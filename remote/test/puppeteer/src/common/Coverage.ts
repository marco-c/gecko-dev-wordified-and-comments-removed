import
{
assert
}
from
'
.
/
assert
.
js
'
;
import
{
addEventListener
debugError
PuppeteerEventListener
}
from
'
.
/
util
.
js
'
;
import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
CDPSession
}
from
'
.
/
Connection
.
js
'
;
import
{
EVALUATION_SCRIPT_URL
}
from
'
.
/
ExecutionContext
.
js
'
;
import
{
removeEventListeners
}
from
'
.
/
util
.
js
'
;
export
{
PuppeteerEventListener
}
;
export
interface
CoverageEntry
{
url
:
string
;
text
:
string
;
ranges
:
Array
<
{
start
:
number
;
end
:
number
}
>
;
}
export
interface
JSCoverageEntry
extends
CoverageEntry
{
rawScriptCoverage
?
:
Protocol
.
Profiler
.
ScriptCoverage
;
}
export
interface
JSCoverageOptions
{
resetOnNavigation
?
:
boolean
;
reportAnonymousScripts
?
:
boolean
;
includeRawScriptCoverage
?
:
boolean
;
}
export
interface
CSSCoverageOptions
{
resetOnNavigation
?
:
boolean
;
}
export
class
Coverage
{
#
jsCoverage
:
JSCoverage
;
#
cssCoverage
:
CSSCoverage
;
constructor
(
client
:
CDPSession
)
{
this
.
#
jsCoverage
=
new
JSCoverage
(
client
)
;
this
.
#
cssCoverage
=
new
CSSCoverage
(
client
)
;
}
async
startJSCoverage
(
options
:
JSCoverageOptions
=
{
}
)
:
Promise
<
void
>
{
return
await
this
.
#
jsCoverage
.
start
(
options
)
;
}
async
stopJSCoverage
(
)
:
Promise
<
JSCoverageEntry
[
]
>
{
return
await
this
.
#
jsCoverage
.
stop
(
)
;
}
async
startCSSCoverage
(
options
:
CSSCoverageOptions
=
{
}
)
:
Promise
<
void
>
{
return
await
this
.
#
cssCoverage
.
start
(
options
)
;
}
async
stopCSSCoverage
(
)
:
Promise
<
CoverageEntry
[
]
>
{
return
await
this
.
#
cssCoverage
.
stop
(
)
;
}
}
export
class
JSCoverage
{
#
client
:
CDPSession
;
#
enabled
=
false
;
#
scriptURLs
=
new
Map
<
string
string
>
(
)
;
#
scriptSources
=
new
Map
<
string
string
>
(
)
;
#
eventListeners
:
PuppeteerEventListener
[
]
=
[
]
;
#
resetOnNavigation
=
false
;
#
reportAnonymousScripts
=
false
;
#
includeRawScriptCoverage
=
false
;
constructor
(
client
:
CDPSession
)
{
this
.
#
client
=
client
;
}
async
start
(
options
:
{
resetOnNavigation
?
:
boolean
;
reportAnonymousScripts
?
:
boolean
;
includeRawScriptCoverage
?
:
boolean
;
}
=
{
}
)
:
Promise
<
void
>
{
assert
(
!
this
.
#
enabled
'
JSCoverage
is
already
enabled
'
)
;
const
{
resetOnNavigation
=
true
reportAnonymousScripts
=
false
includeRawScriptCoverage
=
false
}
=
options
;
this
.
#
resetOnNavigation
=
resetOnNavigation
;
this
.
#
reportAnonymousScripts
=
reportAnonymousScripts
;
this
.
#
includeRawScriptCoverage
=
includeRawScriptCoverage
;
this
.
#
enabled
=
true
;
this
.
#
scriptURLs
.
clear
(
)
;
this
.
#
scriptSources
.
clear
(
)
;
this
.
#
eventListeners
=
[
addEventListener
(
this
.
#
client
'
Debugger
.
scriptParsed
'
this
.
#
onScriptParsed
.
bind
(
this
)
)
addEventListener
(
this
.
#
client
'
Runtime
.
executionContextsCleared
'
this
.
#
onExecutionContextsCleared
.
bind
(
this
)
)
]
;
await
Promise
.
all
(
[
this
.
#
client
.
send
(
'
Profiler
.
enable
'
)
this
.
#
client
.
send
(
'
Profiler
.
startPreciseCoverage
'
{
callCount
:
this
.
#
includeRawScriptCoverage
detailed
:
true
}
)
this
.
#
client
.
send
(
'
Debugger
.
enable
'
)
this
.
#
client
.
send
(
'
Debugger
.
setSkipAllPauses
'
{
skip
:
true
}
)
]
)
;
}
#
onExecutionContextsCleared
(
)
:
void
{
if
(
!
this
.
#
resetOnNavigation
)
{
return
;
}
this
.
#
scriptURLs
.
clear
(
)
;
this
.
#
scriptSources
.
clear
(
)
;
}
async
#
onScriptParsed
(
event
:
Protocol
.
Debugger
.
ScriptParsedEvent
)
:
Promise
<
void
>
{
if
(
event
.
url
=
=
=
EVALUATION_SCRIPT_URL
)
{
return
;
}
if
(
!
event
.
url
&
&
!
this
.
#
reportAnonymousScripts
)
{
return
;
}
try
{
const
response
=
await
this
.
#
client
.
send
(
'
Debugger
.
getScriptSource
'
{
scriptId
:
event
.
scriptId
}
)
;
this
.
#
scriptURLs
.
set
(
event
.
scriptId
event
.
url
)
;
this
.
#
scriptSources
.
set
(
event
.
scriptId
response
.
scriptSource
)
;
}
catch
(
error
)
{
debugError
(
error
)
;
}
}
async
stop
(
)
:
Promise
<
JSCoverageEntry
[
]
>
{
assert
(
this
.
#
enabled
'
JSCoverage
is
not
enabled
'
)
;
this
.
#
enabled
=
false
;
const
result
=
await
Promise
.
all
(
[
this
.
#
client
.
send
(
'
Profiler
.
takePreciseCoverage
'
)
this
.
#
client
.
send
(
'
Profiler
.
stopPreciseCoverage
'
)
this
.
#
client
.
send
(
'
Profiler
.
disable
'
)
this
.
#
client
.
send
(
'
Debugger
.
disable
'
)
]
)
;
removeEventListeners
(
this
.
#
eventListeners
)
;
const
coverage
=
[
]
;
const
profileResponse
=
result
[
0
]
;
for
(
const
entry
of
profileResponse
.
result
)
{
let
url
=
this
.
#
scriptURLs
.
get
(
entry
.
scriptId
)
;
if
(
!
url
&
&
this
.
#
reportAnonymousScripts
)
{
url
=
'
debugger
:
/
/
VM
'
+
entry
.
scriptId
;
}
const
text
=
this
.
#
scriptSources
.
get
(
entry
.
scriptId
)
;
if
(
text
=
=
=
undefined
|
|
url
=
=
=
undefined
)
{
continue
;
}
const
flattenRanges
=
[
]
;
for
(
const
func
of
entry
.
functions
)
{
flattenRanges
.
push
(
.
.
.
func
.
ranges
)
;
}
const
ranges
=
convertToDisjointRanges
(
flattenRanges
)
;
if
(
!
this
.
#
includeRawScriptCoverage
)
{
coverage
.
push
(
{
url
ranges
text
}
)
;
}
else
{
coverage
.
push
(
{
url
ranges
text
rawScriptCoverage
:
entry
}
)
;
}
}
return
coverage
;
}
}
export
class
CSSCoverage
{
#
client
:
CDPSession
;
#
enabled
=
false
;
#
stylesheetURLs
=
new
Map
<
string
string
>
(
)
;
#
stylesheetSources
=
new
Map
<
string
string
>
(
)
;
#
eventListeners
:
PuppeteerEventListener
[
]
=
[
]
;
#
resetOnNavigation
=
false
;
constructor
(
client
:
CDPSession
)
{
this
.
#
client
=
client
;
}
async
start
(
options
:
{
resetOnNavigation
?
:
boolean
}
=
{
}
)
:
Promise
<
void
>
{
assert
(
!
this
.
#
enabled
'
CSSCoverage
is
already
enabled
'
)
;
const
{
resetOnNavigation
=
true
}
=
options
;
this
.
#
resetOnNavigation
=
resetOnNavigation
;
this
.
#
enabled
=
true
;
this
.
#
stylesheetURLs
.
clear
(
)
;
this
.
#
stylesheetSources
.
clear
(
)
;
this
.
#
eventListeners
=
[
addEventListener
(
this
.
#
client
'
CSS
.
styleSheetAdded
'
this
.
#
onStyleSheet
.
bind
(
this
)
)
addEventListener
(
this
.
#
client
'
Runtime
.
executionContextsCleared
'
this
.
#
onExecutionContextsCleared
.
bind
(
this
)
)
]
;
await
Promise
.
all
(
[
this
.
#
client
.
send
(
'
DOM
.
enable
'
)
this
.
#
client
.
send
(
'
CSS
.
enable
'
)
this
.
#
client
.
send
(
'
CSS
.
startRuleUsageTracking
'
)
]
)
;
}
#
onExecutionContextsCleared
(
)
:
void
{
if
(
!
this
.
#
resetOnNavigation
)
{
return
;
}
this
.
#
stylesheetURLs
.
clear
(
)
;
this
.
#
stylesheetSources
.
clear
(
)
;
}
async
#
onStyleSheet
(
event
:
Protocol
.
CSS
.
StyleSheetAddedEvent
)
:
Promise
<
void
>
{
const
header
=
event
.
header
;
if
(
!
header
.
sourceURL
)
{
return
;
}
try
{
const
response
=
await
this
.
#
client
.
send
(
'
CSS
.
getStyleSheetText
'
{
styleSheetId
:
header
.
styleSheetId
}
)
;
this
.
#
stylesheetURLs
.
set
(
header
.
styleSheetId
header
.
sourceURL
)
;
this
.
#
stylesheetSources
.
set
(
header
.
styleSheetId
response
.
text
)
;
}
catch
(
error
)
{
debugError
(
error
)
;
}
}
async
stop
(
)
:
Promise
<
CoverageEntry
[
]
>
{
assert
(
this
.
#
enabled
'
CSSCoverage
is
not
enabled
'
)
;
this
.
#
enabled
=
false
;
const
ruleTrackingResponse
=
await
this
.
#
client
.
send
(
'
CSS
.
stopRuleUsageTracking
'
)
;
await
Promise
.
all
(
[
this
.
#
client
.
send
(
'
CSS
.
disable
'
)
this
.
#
client
.
send
(
'
DOM
.
disable
'
)
]
)
;
removeEventListeners
(
this
.
#
eventListeners
)
;
const
styleSheetIdToCoverage
=
new
Map
(
)
;
for
(
const
entry
of
ruleTrackingResponse
.
ruleUsage
)
{
let
ranges
=
styleSheetIdToCoverage
.
get
(
entry
.
styleSheetId
)
;
if
(
!
ranges
)
{
ranges
=
[
]
;
styleSheetIdToCoverage
.
set
(
entry
.
styleSheetId
ranges
)
;
}
ranges
.
push
(
{
startOffset
:
entry
.
startOffset
endOffset
:
entry
.
endOffset
count
:
entry
.
used
?
1
:
0
}
)
;
}
const
coverage
:
CoverageEntry
[
]
=
[
]
;
for
(
const
styleSheetId
of
this
.
#
stylesheetURLs
.
keys
(
)
)
{
const
url
=
this
.
#
stylesheetURLs
.
get
(
styleSheetId
)
;
assert
(
typeof
url
!
=
=
'
undefined
'
Stylesheet
URL
is
undefined
(
styleSheetId
=
{
styleSheetId
}
)
)
;
const
text
=
this
.
#
stylesheetSources
.
get
(
styleSheetId
)
;
assert
(
typeof
text
!
=
=
'
undefined
'
Stylesheet
text
is
undefined
(
styleSheetId
=
{
styleSheetId
}
)
)
;
const
ranges
=
convertToDisjointRanges
(
styleSheetIdToCoverage
.
get
(
styleSheetId
)
|
|
[
]
)
;
coverage
.
push
(
{
url
ranges
text
}
)
;
}
return
coverage
;
}
}
function
convertToDisjointRanges
(
nestedRanges
:
Array
<
{
startOffset
:
number
;
endOffset
:
number
;
count
:
number
}
>
)
:
Array
<
{
start
:
number
;
end
:
number
}
>
{
const
points
=
[
]
;
for
(
const
range
of
nestedRanges
)
{
points
.
push
(
{
offset
:
range
.
startOffset
type
:
0
range
}
)
;
points
.
push
(
{
offset
:
range
.
endOffset
type
:
1
range
}
)
;
}
points
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
offset
!
=
=
b
.
offset
)
{
return
a
.
offset
-
b
.
offset
;
}
if
(
a
.
type
!
=
=
b
.
type
)
{
return
b
.
type
-
a
.
type
;
}
const
aLength
=
a
.
range
.
endOffset
-
a
.
range
.
startOffset
;
const
bLength
=
b
.
range
.
endOffset
-
b
.
range
.
startOffset
;
if
(
a
.
type
=
=
=
0
)
{
return
bLength
-
aLength
;
}
return
aLength
-
bLength
;
}
)
;
const
hitCountStack
=
[
]
;
const
results
:
Array
<
{
start
:
number
;
end
:
number
;
}
>
=
[
]
;
let
lastOffset
=
0
;
for
(
const
point
of
points
)
{
if
(
hitCountStack
.
length
&
&
lastOffset
<
point
.
offset
&
&
hitCountStack
[
hitCountStack
.
length
-
1
]
!
>
0
)
{
const
lastResult
=
results
[
results
.
length
-
1
]
;
if
(
lastResult
&
&
lastResult
.
end
=
=
=
lastOffset
)
{
lastResult
.
end
=
point
.
offset
;
}
else
{
results
.
push
(
{
start
:
lastOffset
end
:
point
.
offset
}
)
;
}
}
lastOffset
=
point
.
offset
;
if
(
point
.
type
=
=
=
0
)
{
hitCountStack
.
push
(
point
.
range
.
count
)
;
}
else
{
hitCountStack
.
pop
(
)
;
}
}
return
results
.
filter
(
range
=
>
{
return
range
.
end
-
range
.
start
>
1
;
}
)
;
}
