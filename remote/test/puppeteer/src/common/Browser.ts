import
{
assert
}
from
'
.
/
assert
.
js
'
;
import
{
helper
}
from
'
.
/
helper
.
js
'
;
import
{
Target
}
from
'
.
/
Target
.
js
'
;
import
{
EventEmitter
}
from
'
.
/
EventEmitter
.
js
'
;
import
{
Connection
ConnectionEmittedEvents
}
from
'
.
/
Connection
.
js
'
;
import
{
Protocol
}
from
'
devtools
-
protocol
'
;
import
{
Page
}
from
'
.
/
Page
.
js
'
;
import
{
ChildProcess
}
from
'
child_process
'
;
import
{
Viewport
}
from
'
.
/
PuppeteerViewport
.
js
'
;
export
type
BrowserCloseCallback
=
(
)
=
>
Promise
<
void
>
|
void
;
export
type
TargetFilterCallback
=
(
target
:
Protocol
.
Target
.
TargetInfo
)
=
>
boolean
;
const
WEB_PERMISSION_TO_PROTOCOL_PERMISSION
=
new
Map
<
Permission
Protocol
.
Browser
.
PermissionType
>
(
[
[
'
geolocation
'
'
geolocation
'
]
[
'
midi
'
'
midi
'
]
[
'
notifications
'
'
notifications
'
]
[
'
camera
'
'
videoCapture
'
]
[
'
microphone
'
'
audioCapture
'
]
[
'
background
-
sync
'
'
backgroundSync
'
]
[
'
ambient
-
light
-
sensor
'
'
sensors
'
]
[
'
accelerometer
'
'
sensors
'
]
[
'
gyroscope
'
'
sensors
'
]
[
'
magnetometer
'
'
sensors
'
]
[
'
accessibility
-
events
'
'
accessibilityEvents
'
]
[
'
clipboard
-
read
'
'
clipboardReadWrite
'
]
[
'
clipboard
-
write
'
'
clipboardReadWrite
'
]
[
'
payment
-
handler
'
'
paymentHandler
'
]
[
'
idle
-
detection
'
'
idleDetection
'
]
[
'
midi
-
sysex
'
'
midiSysex
'
]
]
)
;
export
type
Permission
=
|
'
geolocation
'
|
'
midi
'
|
'
notifications
'
|
'
camera
'
|
'
microphone
'
|
'
background
-
sync
'
|
'
ambient
-
light
-
sensor
'
|
'
accelerometer
'
|
'
gyroscope
'
|
'
magnetometer
'
|
'
accessibility
-
events
'
|
'
clipboard
-
read
'
|
'
clipboard
-
write
'
|
'
payment
-
handler
'
|
'
idle
-
detection
'
|
'
midi
-
sysex
'
;
export
interface
WaitForTargetOptions
{
timeout
?
:
number
;
}
export
const
enum
BrowserEmittedEvents
{
Disconnected
=
'
disconnected
'
TargetChanged
=
'
targetchanged
'
TargetCreated
=
'
targetcreated
'
TargetDestroyed
=
'
targetdestroyed
'
}
export
class
Browser
extends
EventEmitter
{
static
async
create
(
connection
:
Connection
contextIds
:
string
[
]
ignoreHTTPSErrors
:
boolean
defaultViewport
?
:
Viewport
|
null
process
?
:
ChildProcess
closeCallback
?
:
BrowserCloseCallback
targetFilterCallback
?
:
TargetFilterCallback
)
:
Promise
<
Browser
>
{
const
browser
=
new
Browser
(
connection
contextIds
ignoreHTTPSErrors
defaultViewport
process
closeCallback
targetFilterCallback
)
;
await
connection
.
send
(
'
Target
.
setDiscoverTargets
'
{
discover
:
true
}
)
;
return
browser
;
}
private
_ignoreHTTPSErrors
:
boolean
;
private
_defaultViewport
?
:
Viewport
|
null
;
private
_process
?
:
ChildProcess
;
private
_connection
:
Connection
;
private
_closeCallback
:
BrowserCloseCallback
;
private
_targetFilterCallback
:
TargetFilterCallback
;
private
_defaultContext
:
BrowserContext
;
private
_contexts
:
Map
<
string
BrowserContext
>
;
_targets
:
Map
<
string
Target
>
;
constructor
(
connection
:
Connection
contextIds
:
string
[
]
ignoreHTTPSErrors
:
boolean
defaultViewport
?
:
Viewport
|
null
process
?
:
ChildProcess
closeCallback
?
:
BrowserCloseCallback
targetFilterCallback
?
:
TargetFilterCallback
)
{
super
(
)
;
this
.
_ignoreHTTPSErrors
=
ignoreHTTPSErrors
;
this
.
_defaultViewport
=
defaultViewport
;
this
.
_process
=
process
;
this
.
_connection
=
connection
;
this
.
_closeCallback
=
closeCallback
|
|
function
(
)
:
void
{
}
;
this
.
_targetFilterCallback
=
targetFilterCallback
|
|
(
(
)
:
boolean
=
>
true
)
;
this
.
_defaultContext
=
new
BrowserContext
(
this
.
_connection
this
null
)
;
this
.
_contexts
=
new
Map
(
)
;
for
(
const
contextId
of
contextIds
)
this
.
_contexts
.
set
(
contextId
new
BrowserContext
(
this
.
_connection
this
contextId
)
)
;
this
.
_targets
=
new
Map
(
)
;
this
.
_connection
.
on
(
ConnectionEmittedEvents
.
Disconnected
(
)
=
>
this
.
emit
(
BrowserEmittedEvents
.
Disconnected
)
)
;
this
.
_connection
.
on
(
'
Target
.
targetCreated
'
this
.
_targetCreated
.
bind
(
this
)
)
;
this
.
_connection
.
on
(
'
Target
.
targetDestroyed
'
this
.
_targetDestroyed
.
bind
(
this
)
)
;
this
.
_connection
.
on
(
'
Target
.
targetInfoChanged
'
this
.
_targetInfoChanged
.
bind
(
this
)
)
;
}
process
(
)
:
ChildProcess
|
null
{
return
this
.
_process
;
}
async
createIncognitoBrowserContext
(
)
:
Promise
<
BrowserContext
>
{
const
{
browserContextId
}
=
await
this
.
_connection
.
send
(
'
Target
.
createBrowserContext
'
)
;
const
context
=
new
BrowserContext
(
this
.
_connection
this
browserContextId
)
;
this
.
_contexts
.
set
(
browserContextId
context
)
;
return
context
;
}
browserContexts
(
)
:
BrowserContext
[
]
{
return
[
this
.
_defaultContext
.
.
.
Array
.
from
(
this
.
_contexts
.
values
(
)
)
]
;
}
defaultBrowserContext
(
)
:
BrowserContext
{
return
this
.
_defaultContext
;
}
async
_disposeContext
(
contextId
?
:
string
)
:
Promise
<
void
>
{
await
this
.
_connection
.
send
(
'
Target
.
disposeBrowserContext
'
{
browserContextId
:
contextId
|
|
undefined
}
)
;
this
.
_contexts
.
delete
(
contextId
)
;
}
private
async
_targetCreated
(
event
:
Protocol
.
Target
.
TargetCreatedEvent
)
:
Promise
<
void
>
{
const
targetInfo
=
event
.
targetInfo
;
const
{
browserContextId
}
=
targetInfo
;
const
context
=
browserContextId
&
&
this
.
_contexts
.
has
(
browserContextId
)
?
this
.
_contexts
.
get
(
browserContextId
)
:
this
.
_defaultContext
;
const
shouldAttachToTarget
=
this
.
_targetFilterCallback
(
targetInfo
)
;
if
(
!
shouldAttachToTarget
)
{
return
;
}
const
target
=
new
Target
(
targetInfo
context
(
)
=
>
this
.
_connection
.
createSession
(
targetInfo
)
this
.
_ignoreHTTPSErrors
this
.
_defaultViewport
)
;
assert
(
!
this
.
_targets
.
has
(
event
.
targetInfo
.
targetId
)
'
Target
should
not
exist
before
targetCreated
'
)
;
this
.
_targets
.
set
(
event
.
targetInfo
.
targetId
target
)
;
if
(
await
target
.
_initializedPromise
)
{
this
.
emit
(
BrowserEmittedEvents
.
TargetCreated
target
)
;
context
.
emit
(
BrowserContextEmittedEvents
.
TargetCreated
target
)
;
}
}
private
async
_targetDestroyed
(
event
:
{
targetId
:
string
}
)
:
Promise
<
void
>
{
const
target
=
this
.
_targets
.
get
(
event
.
targetId
)
;
target
.
_initializedCallback
(
false
)
;
this
.
_targets
.
delete
(
event
.
targetId
)
;
target
.
_closedCallback
(
)
;
if
(
await
target
.
_initializedPromise
)
{
this
.
emit
(
BrowserEmittedEvents
.
TargetDestroyed
target
)
;
target
.
browserContext
(
)
.
emit
(
BrowserContextEmittedEvents
.
TargetDestroyed
target
)
;
}
}
private
_targetInfoChanged
(
event
:
Protocol
.
Target
.
TargetInfoChangedEvent
)
:
void
{
const
target
=
this
.
_targets
.
get
(
event
.
targetInfo
.
targetId
)
;
assert
(
target
'
target
should
exist
before
targetInfoChanged
'
)
;
const
previousURL
=
target
.
url
(
)
;
const
wasInitialized
=
target
.
_isInitialized
;
target
.
_targetInfoChanged
(
event
.
targetInfo
)
;
if
(
wasInitialized
&
&
previousURL
!
=
=
target
.
url
(
)
)
{
this
.
emit
(
BrowserEmittedEvents
.
TargetChanged
target
)
;
target
.
browserContext
(
)
.
emit
(
BrowserContextEmittedEvents
.
TargetChanged
target
)
;
}
}
wsEndpoint
(
)
:
string
{
return
this
.
_connection
.
url
(
)
;
}
async
newPage
(
)
:
Promise
<
Page
>
{
return
this
.
_defaultContext
.
newPage
(
)
;
}
async
_createPageInContext
(
contextId
?
:
string
)
:
Promise
<
Page
>
{
const
{
targetId
}
=
await
this
.
_connection
.
send
(
'
Target
.
createTarget
'
{
url
:
'
about
:
blank
'
browserContextId
:
contextId
|
|
undefined
}
)
;
const
target
=
await
this
.
_targets
.
get
(
targetId
)
;
assert
(
await
target
.
_initializedPromise
'
Failed
to
create
target
for
page
'
)
;
const
page
=
await
target
.
page
(
)
;
return
page
;
}
targets
(
)
:
Target
[
]
{
return
Array
.
from
(
this
.
_targets
.
values
(
)
)
.
filter
(
(
target
)
=
>
target
.
_isInitialized
)
;
}
target
(
)
:
Target
{
return
this
.
targets
(
)
.
find
(
(
target
)
=
>
target
.
type
(
)
=
=
=
'
browser
'
)
;
}
async
waitForTarget
(
predicate
:
(
x
:
Target
)
=
>
boolean
options
:
WaitForTargetOptions
=
{
}
)
:
Promise
<
Target
>
{
const
{
timeout
=
30000
}
=
options
;
const
existingTarget
=
this
.
targets
(
)
.
find
(
predicate
)
;
if
(
existingTarget
)
return
existingTarget
;
let
resolve
;
const
targetPromise
=
new
Promise
<
Target
>
(
(
x
)
=
>
(
resolve
=
x
)
)
;
this
.
on
(
BrowserEmittedEvents
.
TargetCreated
check
)
;
this
.
on
(
BrowserEmittedEvents
.
TargetChanged
check
)
;
try
{
if
(
!
timeout
)
return
await
targetPromise
;
return
await
helper
.
waitWithTimeout
<
Target
>
(
targetPromise
'
target
'
timeout
)
;
}
finally
{
this
.
removeListener
(
BrowserEmittedEvents
.
TargetCreated
check
)
;
this
.
removeListener
(
BrowserEmittedEvents
.
TargetChanged
check
)
;
}
function
check
(
target
:
Target
)
:
void
{
if
(
predicate
(
target
)
)
resolve
(
target
)
;
}
}
async
pages
(
)
:
Promise
<
Page
[
]
>
{
const
contextPages
=
await
Promise
.
all
(
this
.
browserContexts
(
)
.
map
(
(
context
)
=
>
context
.
pages
(
)
)
)
;
return
contextPages
.
reduce
(
(
acc
x
)
=
>
acc
.
concat
(
x
)
[
]
)
;
}
async
version
(
)
:
Promise
<
string
>
{
const
version
=
await
this
.
_getVersion
(
)
;
return
version
.
product
;
}
async
userAgent
(
)
:
Promise
<
string
>
{
const
version
=
await
this
.
_getVersion
(
)
;
return
version
.
userAgent
;
}
async
close
(
)
:
Promise
<
void
>
{
await
this
.
_closeCallback
.
call
(
null
)
;
this
.
disconnect
(
)
;
}
disconnect
(
)
:
void
{
this
.
_connection
.
dispose
(
)
;
}
isConnected
(
)
:
boolean
{
return
!
this
.
_connection
.
_closed
;
}
private
_getVersion
(
)
:
Promise
<
Protocol
.
Browser
.
GetVersionResponse
>
{
return
this
.
_connection
.
send
(
'
Browser
.
getVersion
'
)
;
}
}
export
const
enum
BrowserContextEmittedEvents
{
TargetChanged
=
'
targetchanged
'
TargetCreated
=
'
targetcreated
'
TargetDestroyed
=
'
targetdestroyed
'
}
export
class
BrowserContext
extends
EventEmitter
{
private
_connection
:
Connection
;
private
_browser
:
Browser
;
private
_id
?
:
string
;
constructor
(
connection
:
Connection
browser
:
Browser
contextId
?
:
string
)
{
super
(
)
;
this
.
_connection
=
connection
;
this
.
_browser
=
browser
;
this
.
_id
=
contextId
;
}
targets
(
)
:
Target
[
]
{
return
this
.
_browser
.
targets
(
)
.
filter
(
(
target
)
=
>
target
.
browserContext
(
)
=
=
=
this
)
;
}
waitForTarget
(
predicate
:
(
x
:
Target
)
=
>
boolean
options
:
{
timeout
?
:
number
}
=
{
}
)
:
Promise
<
Target
>
{
return
this
.
_browser
.
waitForTarget
(
(
target
)
=
>
target
.
browserContext
(
)
=
=
=
this
&
&
predicate
(
target
)
options
)
;
}
async
pages
(
)
:
Promise
<
Page
[
]
>
{
const
pages
=
await
Promise
.
all
(
this
.
targets
(
)
.
filter
(
(
target
)
=
>
target
.
type
(
)
=
=
=
'
page
'
)
.
map
(
(
target
)
=
>
target
.
page
(
)
)
)
;
return
pages
.
filter
(
(
page
)
=
>
!
!
page
)
;
}
isIncognito
(
)
:
boolean
{
return
!
!
this
.
_id
;
}
async
overridePermissions
(
origin
:
string
permissions
:
Permission
[
]
)
:
Promise
<
void
>
{
const
protocolPermissions
=
permissions
.
map
(
(
permission
)
=
>
{
const
protocolPermission
=
WEB_PERMISSION_TO_PROTOCOL_PERMISSION
.
get
(
permission
)
;
if
(
!
protocolPermission
)
throw
new
Error
(
'
Unknown
permission
:
'
+
permission
)
;
return
protocolPermission
;
}
)
;
await
this
.
_connection
.
send
(
'
Browser
.
grantPermissions
'
{
origin
browserContextId
:
this
.
_id
|
|
undefined
permissions
:
protocolPermissions
}
)
;
}
async
clearPermissionOverrides
(
)
:
Promise
<
void
>
{
await
this
.
_connection
.
send
(
'
Browser
.
resetPermissions
'
{
browserContextId
:
this
.
_id
|
|
undefined
}
)
;
}
newPage
(
)
:
Promise
<
Page
>
{
return
this
.
_browser
.
_createPageInContext
(
this
.
_id
)
;
}
browser
(
)
:
Browser
{
return
this
.
_browser
;
}
async
close
(
)
:
Promise
<
void
>
{
assert
(
this
.
_id
'
Non
-
incognito
profiles
cannot
be
closed
!
'
)
;
await
this
.
_browser
.
_disposeContext
(
this
.
_id
)
;
}
}
