import
NodeWebSocket
from
'
ws
'
;
import
{
ConnectionTransport
}
from
'
.
.
/
common
/
ConnectionTransport
.
js
'
;
import
{
packageVersion
}
from
'
.
.
/
generated
/
version
.
js
'
;
import
{
promises
as
dns
}
from
'
dns
'
;
import
{
URL
}
from
'
url
'
;
export
class
NodeWebSocketTransport
implements
ConnectionTransport
{
static
async
create
(
urlString
:
string
)
:
Promise
<
NodeWebSocketTransport
>
{
const
url
=
new
URL
(
urlString
)
;
if
(
url
.
hostname
=
=
=
'
localhost
'
)
{
const
{
address
}
=
await
dns
.
lookup
(
url
.
hostname
{
verbatim
:
false
}
)
;
url
.
hostname
=
address
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
ws
=
new
NodeWebSocket
(
url
[
]
{
followRedirects
:
true
perMessageDeflate
:
false
maxPayload
:
256
*
1024
*
1024
headers
:
{
'
User
-
Agent
'
:
Puppeteer
{
packageVersion
}
}
}
)
;
ws
.
addEventListener
(
'
open
'
(
)
=
>
{
return
resolve
(
new
NodeWebSocketTransport
(
ws
)
)
;
}
)
;
ws
.
addEventListener
(
'
error
'
reject
)
;
}
)
;
}
#
ws
:
NodeWebSocket
;
onmessage
?
:
(
message
:
NodeWebSocket
.
Data
)
=
>
void
;
onclose
?
:
(
)
=
>
void
;
constructor
(
ws
:
NodeWebSocket
)
{
this
.
#
ws
=
ws
;
this
.
#
ws
.
addEventListener
(
'
message
'
event
=
>
{
if
(
this
.
onmessage
)
{
this
.
onmessage
.
call
(
null
event
.
data
)
;
}
}
)
;
this
.
#
ws
.
addEventListener
(
'
close
'
(
)
=
>
{
if
(
this
.
onclose
)
{
this
.
onclose
.
call
(
null
)
;
}
}
)
;
this
.
#
ws
.
addEventListener
(
'
error
'
(
)
=
>
{
}
)
;
}
send
(
message
:
string
)
:
void
{
this
.
#
ws
.
send
(
message
)
;
}
close
(
)
:
void
{
this
.
#
ws
.
close
(
)
;
}
}
