import
{
debug
}
from
'
.
.
/
common
/
Debug
'
;
import
removeFolder
from
'
rimraf
'
;
import
*
as
childProcess
from
'
child_process
'
;
import
{
assert
}
from
'
.
.
/
common
/
assert
'
;
import
{
helper
debugError
}
from
'
.
.
/
common
/
helper
'
;
import
{
LaunchOptions
}
from
'
.
/
LaunchOptions
'
;
import
{
Connection
}
from
'
.
.
/
common
/
Connection
'
;
import
{
WebSocketTransport
}
from
'
.
.
/
common
/
WebSocketTransport
'
;
import
{
PipeTransport
}
from
'
.
/
PipeTransport
'
;
import
*
as
readline
from
'
readline
'
;
import
{
TimeoutError
}
from
'
.
.
/
common
/
Errors
'
;
const
removeFolderAsync
=
helper
.
promisify
(
removeFolder
)
;
const
debugLauncher
=
debug
(
'
puppeteer
:
launcher
'
)
;
const
PROCESS_ERROR_EXPLANATION
=
Puppeteer
was
unable
to
kill
the
process
which
ran
the
browser
binary
.
This
means
that
on
future
Puppeteer
launches
Puppeteer
might
not
be
able
to
launch
the
browser
.
Please
check
your
open
processes
and
ensure
that
the
browser
processes
that
Puppeteer
launched
have
been
killed
.
If
you
think
this
is
a
bug
please
report
it
on
the
Puppeteer
issue
tracker
.
;
export
class
BrowserRunner
{
private
_executablePath
:
string
;
private
_processArguments
:
string
[
]
;
private
_tempDirectory
?
:
string
;
proc
=
null
;
connection
=
null
;
private
_closed
=
true
;
private
_listeners
=
[
]
;
private
_processClosing
:
Promise
<
void
>
;
constructor
(
executablePath
:
string
processArguments
:
string
[
]
tempDirectory
?
:
string
)
{
this
.
_executablePath
=
executablePath
;
this
.
_processArguments
=
processArguments
;
this
.
_tempDirectory
=
tempDirectory
;
}
start
(
options
:
LaunchOptions
)
:
void
{
const
{
handleSIGINT
handleSIGTERM
handleSIGHUP
dumpio
env
pipe
}
=
options
;
let
stdio
:
Array
<
'
ignore
'
|
'
pipe
'
>
=
[
'
pipe
'
'
pipe
'
'
pipe
'
]
;
if
(
pipe
)
{
if
(
dumpio
)
stdio
=
[
'
ignore
'
'
pipe
'
'
pipe
'
'
pipe
'
'
pipe
'
]
;
else
stdio
=
[
'
ignore
'
'
ignore
'
'
ignore
'
'
pipe
'
'
pipe
'
]
;
}
assert
(
!
this
.
proc
'
This
process
has
previously
been
started
.
'
)
;
debugLauncher
(
Calling
{
this
.
_executablePath
}
{
this
.
_processArguments
.
join
(
'
'
)
}
)
;
this
.
proc
=
childProcess
.
spawn
(
this
.
_executablePath
this
.
_processArguments
{
detached
:
process
.
platform
!
=
=
'
win32
'
env
stdio
}
)
;
if
(
dumpio
)
{
this
.
proc
.
stderr
.
pipe
(
process
.
stderr
)
;
this
.
proc
.
stdout
.
pipe
(
process
.
stdout
)
;
}
this
.
_closed
=
false
;
this
.
_processClosing
=
new
Promise
(
(
fulfill
)
=
>
{
this
.
proc
.
once
(
'
exit
'
(
)
=
>
{
this
.
_closed
=
true
;
if
(
this
.
_tempDirectory
)
{
removeFolderAsync
(
this
.
_tempDirectory
)
.
then
(
(
)
=
>
fulfill
(
)
)
.
catch
(
(
error
)
=
>
console
.
error
(
error
)
)
;
}
else
{
fulfill
(
)
;
}
}
)
;
}
)
;
this
.
_listeners
=
[
helper
.
addEventListener
(
process
'
exit
'
this
.
kill
.
bind
(
this
)
)
]
;
if
(
handleSIGINT
)
this
.
_listeners
.
push
(
helper
.
addEventListener
(
process
'
SIGINT
'
(
)
=
>
{
this
.
kill
(
)
;
process
.
exit
(
130
)
;
}
)
)
;
if
(
handleSIGTERM
)
this
.
_listeners
.
push
(
helper
.
addEventListener
(
process
'
SIGTERM
'
this
.
close
.
bind
(
this
)
)
)
;
if
(
handleSIGHUP
)
this
.
_listeners
.
push
(
helper
.
addEventListener
(
process
'
SIGHUP
'
this
.
close
.
bind
(
this
)
)
)
;
}
close
(
)
:
Promise
<
void
>
{
if
(
this
.
_closed
)
return
Promise
.
resolve
(
)
;
if
(
this
.
_tempDirectory
)
{
this
.
kill
(
)
;
}
else
if
(
this
.
connection
)
{
this
.
connection
.
send
(
'
Browser
.
close
'
)
.
catch
(
(
error
)
=
>
{
debugError
(
error
)
;
this
.
kill
(
)
;
}
)
;
}
helper
.
removeEventListeners
(
this
.
_listeners
)
;
return
this
.
_processClosing
;
}
kill
(
)
:
void
{
try
{
removeFolder
.
sync
(
this
.
_tempDirectory
)
;
}
catch
(
error
)
{
}
if
(
this
.
proc
&
&
this
.
proc
.
pid
&
&
!
this
.
proc
.
killed
)
{
try
{
this
.
proc
.
kill
(
'
SIGKILL
'
)
;
}
catch
(
error
)
{
throw
new
Error
(
{
PROCESS_ERROR_EXPLANATION
}
\
nError
cause
:
{
error
.
stack
}
)
;
}
}
helper
.
removeEventListeners
(
this
.
_listeners
)
;
}
async
setupConnection
(
options
:
{
usePipe
?
:
boolean
;
timeout
:
number
;
slowMo
:
number
;
preferredRevision
:
string
;
}
)
:
Promise
<
Connection
>
{
const
{
usePipe
timeout
slowMo
preferredRevision
}
=
options
;
if
(
!
usePipe
)
{
const
browserWSEndpoint
=
await
waitForWSEndpoint
(
this
.
proc
timeout
preferredRevision
)
;
const
transport
=
await
WebSocketTransport
.
create
(
browserWSEndpoint
)
;
this
.
connection
=
new
Connection
(
browserWSEndpoint
transport
slowMo
)
;
}
else
{
const
{
3
:
pipeWrite
4
:
pipeRead
}
=
this
.
proc
.
stdio
;
const
transport
=
new
PipeTransport
(
pipeWrite
as
NodeJS
.
WritableStream
pipeRead
as
NodeJS
.
ReadableStream
)
;
this
.
connection
=
new
Connection
(
'
'
transport
slowMo
)
;
}
return
this
.
connection
;
}
}
function
waitForWSEndpoint
(
browserProcess
:
childProcess
.
ChildProcess
timeout
:
number
preferredRevision
:
string
)
:
Promise
<
string
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
rl
=
readline
.
createInterface
(
{
input
:
browserProcess
.
stderr
}
)
;
let
stderr
=
'
'
;
const
listeners
=
[
helper
.
addEventListener
(
rl
'
line
'
onLine
)
helper
.
addEventListener
(
rl
'
close
'
(
)
=
>
onClose
(
)
)
helper
.
addEventListener
(
browserProcess
'
exit
'
(
)
=
>
onClose
(
)
)
helper
.
addEventListener
(
browserProcess
'
error
'
(
error
)
=
>
onClose
(
error
)
)
]
;
const
timeoutId
=
timeout
?
setTimeout
(
onTimeout
timeout
)
:
0
;
function
onClose
(
error
?
:
Error
)
:
void
{
cleanup
(
)
;
reject
(
new
Error
(
[
'
Failed
to
launch
the
browser
process
!
'
+
(
error
?
'
'
+
error
.
message
:
'
'
)
stderr
'
'
'
TROUBLESHOOTING
:
https
:
/
/
github
.
com
/
puppeteer
/
puppeteer
/
blob
/
main
/
docs
/
troubleshooting
.
md
'
'
'
]
.
join
(
'
\
n
'
)
)
)
;
}
function
onTimeout
(
)
:
void
{
cleanup
(
)
;
reject
(
new
TimeoutError
(
Timed
out
after
{
timeout
}
ms
while
trying
to
connect
to
the
browser
!
Only
Chrome
at
revision
r
{
preferredRevision
}
is
guaranteed
to
work
.
)
)
;
}
function
onLine
(
line
:
string
)
:
void
{
stderr
+
=
line
+
'
\
n
'
;
const
match
=
line
.
match
(
/
^
DevTools
listening
on
(
ws
:
\
/
\
/
.
*
)
/
)
;
if
(
!
match
)
return
;
cleanup
(
)
;
resolve
(
match
[
1
]
)
;
}
function
cleanup
(
)
:
void
{
if
(
timeoutId
)
clearTimeout
(
timeoutId
)
;
helper
.
removeEventListeners
(
listeners
)
;
}
}
)
;
}
