import
*
as
childProcess
from
'
child_process
'
;
import
*
as
fs
from
'
fs
'
;
import
*
as
path
from
'
path
'
;
import
*
as
readline
from
'
readline
'
;
import
removeFolder
from
'
rimraf
'
;
import
{
promisify
}
from
'
util
'
;
import
{
assert
}
from
'
.
.
/
common
/
assert
.
js
'
;
import
{
Connection
}
from
'
.
.
/
common
/
Connection
.
js
'
;
import
{
debug
}
from
'
.
.
/
common
/
Debug
.
js
'
;
import
{
TimeoutError
}
from
'
.
.
/
common
/
Errors
.
js
'
;
import
{
debugError
addEventListener
isErrnoException
isErrorLike
PuppeteerEventListener
removeEventListeners
}
from
'
.
.
/
common
/
util
.
js
'
;
import
{
Product
}
from
'
.
.
/
common
/
Product
.
js
'
;
import
{
NodeWebSocketTransport
as
WebSocketTransport
}
from
'
.
.
/
node
/
NodeWebSocketTransport
.
js
'
;
import
{
LaunchOptions
}
from
'
.
/
LaunchOptions
.
js
'
;
import
{
PipeTransport
}
from
'
.
/
PipeTransport
.
js
'
;
const
removeFolderAsync
=
promisify
(
removeFolder
)
;
const
renameAsync
=
promisify
(
fs
.
rename
)
;
const
unlinkAsync
=
promisify
(
fs
.
unlink
)
;
const
debugLauncher
=
debug
(
'
puppeteer
:
launcher
'
)
;
const
PROCESS_ERROR_EXPLANATION
=
Puppeteer
was
unable
to
kill
the
process
which
ran
the
browser
binary
.
This
means
that
on
future
Puppeteer
launches
Puppeteer
might
not
be
able
to
launch
the
browser
.
Please
check
your
open
processes
and
ensure
that
the
browser
processes
that
Puppeteer
launched
have
been
killed
.
If
you
think
this
is
a
bug
please
report
it
on
the
Puppeteer
issue
tracker
.
;
export
class
BrowserRunner
{
#
product
:
Product
;
#
executablePath
:
string
;
#
processArguments
:
string
[
]
;
#
userDataDir
:
string
;
#
isTempUserDataDir
?
:
boolean
;
#
closed
=
true
;
#
listeners
:
PuppeteerEventListener
[
]
=
[
]
;
#
processClosing
!
:
Promise
<
void
>
;
proc
?
:
childProcess
.
ChildProcess
;
connection
?
:
Connection
;
constructor
(
product
:
Product
executablePath
:
string
processArguments
:
string
[
]
userDataDir
:
string
isTempUserDataDir
?
:
boolean
)
{
this
.
#
product
=
product
;
this
.
#
executablePath
=
executablePath
;
this
.
#
processArguments
=
processArguments
;
this
.
#
userDataDir
=
userDataDir
;
this
.
#
isTempUserDataDir
=
isTempUserDataDir
;
}
start
(
options
:
LaunchOptions
)
:
void
{
const
{
handleSIGINT
handleSIGTERM
handleSIGHUP
dumpio
env
pipe
}
=
options
;
let
stdio
:
Array
<
'
ignore
'
|
'
pipe
'
>
;
if
(
pipe
)
{
if
(
dumpio
)
{
stdio
=
[
'
ignore
'
'
pipe
'
'
pipe
'
'
pipe
'
'
pipe
'
]
;
}
else
{
stdio
=
[
'
ignore
'
'
ignore
'
'
ignore
'
'
pipe
'
'
pipe
'
]
;
}
}
else
{
if
(
dumpio
)
{
stdio
=
[
'
pipe
'
'
pipe
'
'
pipe
'
]
;
}
else
{
stdio
=
[
'
pipe
'
'
ignore
'
'
pipe
'
]
;
}
}
assert
(
!
this
.
proc
'
This
process
has
previously
been
started
.
'
)
;
debugLauncher
(
Calling
{
this
.
#
executablePath
}
{
this
.
#
processArguments
.
join
(
'
'
)
}
)
;
this
.
proc
=
childProcess
.
spawn
(
this
.
#
executablePath
this
.
#
processArguments
{
detached
:
process
.
platform
!
=
=
'
win32
'
env
stdio
}
)
;
if
(
dumpio
)
{
this
.
proc
.
stderr
?
.
pipe
(
process
.
stderr
)
;
this
.
proc
.
stdout
?
.
pipe
(
process
.
stdout
)
;
}
this
.
#
closed
=
false
;
this
.
#
processClosing
=
new
Promise
(
(
fulfill
reject
)
=
>
{
this
.
proc
!
.
once
(
'
exit
'
async
(
)
=
>
{
this
.
#
closed
=
true
;
if
(
this
.
#
isTempUserDataDir
)
{
try
{
await
removeFolderAsync
(
this
.
#
userDataDir
)
;
fulfill
(
)
;
}
catch
(
error
)
{
debugError
(
error
)
;
reject
(
error
)
;
}
}
else
{
if
(
this
.
#
product
=
=
=
'
firefox
'
)
{
try
{
await
unlinkAsync
(
path
.
join
(
this
.
#
userDataDir
'
user
.
js
'
)
)
;
const
prefsBackupPath
=
path
.
join
(
this
.
#
userDataDir
'
prefs
.
js
.
puppeteer
'
)
;
if
(
fs
.
existsSync
(
prefsBackupPath
)
)
{
const
prefsPath
=
path
.
join
(
this
.
#
userDataDir
'
prefs
.
js
'
)
;
await
unlinkAsync
(
prefsPath
)
;
await
renameAsync
(
prefsBackupPath
prefsPath
)
;
}
}
catch
(
error
)
{
debugError
(
error
)
;
reject
(
error
)
;
}
}
fulfill
(
)
;
}
}
)
;
}
)
;
this
.
#
listeners
=
[
addEventListener
(
process
'
exit
'
this
.
kill
.
bind
(
this
)
)
]
;
if
(
handleSIGINT
)
{
this
.
#
listeners
.
push
(
addEventListener
(
process
'
SIGINT
'
(
)
=
>
{
this
.
kill
(
)
;
process
.
exit
(
130
)
;
}
)
)
;
}
if
(
handleSIGTERM
)
{
this
.
#
listeners
.
push
(
addEventListener
(
process
'
SIGTERM
'
this
.
close
.
bind
(
this
)
)
)
;
}
if
(
handleSIGHUP
)
{
this
.
#
listeners
.
push
(
addEventListener
(
process
'
SIGHUP
'
this
.
close
.
bind
(
this
)
)
)
;
}
}
close
(
)
:
Promise
<
void
>
{
if
(
this
.
#
closed
)
{
return
Promise
.
resolve
(
)
;
}
if
(
this
.
#
isTempUserDataDir
)
{
this
.
kill
(
)
;
}
else
if
(
this
.
connection
)
{
this
.
connection
.
send
(
'
Browser
.
close
'
)
.
catch
(
error
=
>
{
debugError
(
error
)
;
this
.
kill
(
)
;
}
)
;
}
removeEventListeners
(
this
.
#
listeners
)
;
return
this
.
#
processClosing
;
}
kill
(
)
:
void
{
if
(
this
.
proc
&
&
this
.
proc
.
pid
&
&
pidExists
(
this
.
proc
.
pid
)
)
{
const
proc
=
this
.
proc
;
try
{
if
(
process
.
platform
=
=
=
'
win32
'
)
{
childProcess
.
exec
(
taskkill
/
pid
{
this
.
proc
.
pid
}
/
T
/
F
error
=
>
{
if
(
error
)
{
proc
.
kill
(
)
;
}
}
)
;
}
else
{
const
processGroupId
=
-
this
.
proc
.
pid
;
try
{
process
.
kill
(
processGroupId
'
SIGKILL
'
)
;
}
catch
(
error
)
{
proc
.
kill
(
'
SIGKILL
'
)
;
}
}
}
catch
(
error
)
{
throw
new
Error
(
{
PROCESS_ERROR_EXPLANATION
}
\
nError
cause
:
{
isErrorLike
(
error
)
?
error
.
stack
:
error
}
)
;
}
}
try
{
if
(
this
.
#
isTempUserDataDir
)
{
removeFolder
.
sync
(
this
.
#
userDataDir
)
;
}
}
catch
(
error
)
{
}
removeEventListeners
(
this
.
#
listeners
)
;
}
async
setupConnection
(
options
:
{
usePipe
?
:
boolean
;
timeout
:
number
;
slowMo
:
number
;
preferredRevision
:
string
;
}
)
:
Promise
<
Connection
>
{
assert
(
this
.
proc
'
BrowserRunner
not
started
.
'
)
;
const
{
usePipe
timeout
slowMo
preferredRevision
}
=
options
;
if
(
!
usePipe
)
{
const
browserWSEndpoint
=
await
waitForWSEndpoint
(
this
.
proc
timeout
preferredRevision
)
;
const
transport
=
await
WebSocketTransport
.
create
(
browserWSEndpoint
)
;
this
.
connection
=
new
Connection
(
browserWSEndpoint
transport
slowMo
)
;
}
else
{
const
{
3
:
pipeWrite
4
:
pipeRead
}
=
this
.
proc
.
stdio
;
const
transport
=
new
PipeTransport
(
pipeWrite
as
NodeJS
.
WritableStream
pipeRead
as
NodeJS
.
ReadableStream
)
;
this
.
connection
=
new
Connection
(
'
'
transport
slowMo
)
;
}
return
this
.
connection
;
}
}
function
waitForWSEndpoint
(
browserProcess
:
childProcess
.
ChildProcess
timeout
:
number
preferredRevision
:
string
)
:
Promise
<
string
>
{
assert
(
browserProcess
.
stderr
'
browserProcess
does
not
have
stderr
.
'
)
;
const
rl
=
readline
.
createInterface
(
browserProcess
.
stderr
)
;
let
stderr
=
'
'
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
listeners
=
[
addEventListener
(
rl
'
line
'
onLine
)
addEventListener
(
rl
'
close
'
(
)
=
>
{
return
onClose
(
)
;
}
)
addEventListener
(
browserProcess
'
exit
'
(
)
=
>
{
return
onClose
(
)
;
}
)
addEventListener
(
browserProcess
'
error
'
error
=
>
{
return
onClose
(
error
)
;
}
)
]
;
const
timeoutId
=
timeout
?
setTimeout
(
onTimeout
timeout
)
:
0
;
function
onClose
(
error
?
:
Error
)
:
void
{
cleanup
(
)
;
reject
(
new
Error
(
[
'
Failed
to
launch
the
browser
process
!
'
+
(
error
?
'
'
+
error
.
message
:
'
'
)
stderr
'
'
'
TROUBLESHOOTING
:
https
:
/
/
github
.
com
/
puppeteer
/
puppeteer
/
blob
/
main
/
docs
/
troubleshooting
.
md
'
'
'
]
.
join
(
'
\
n
'
)
)
)
;
}
function
onTimeout
(
)
:
void
{
cleanup
(
)
;
reject
(
new
TimeoutError
(
Timed
out
after
{
timeout
}
ms
while
trying
to
connect
to
the
browser
!
Only
Chrome
at
revision
r
{
preferredRevision
}
is
guaranteed
to
work
.
)
)
;
}
function
onLine
(
line
:
string
)
:
void
{
stderr
+
=
line
+
'
\
n
'
;
const
match
=
line
.
match
(
/
^
DevTools
listening
on
(
ws
:
\
/
\
/
.
*
)
/
)
;
if
(
!
match
)
{
return
;
}
cleanup
(
)
;
resolve
(
match
[
1
]
!
)
;
}
function
cleanup
(
)
:
void
{
if
(
timeoutId
)
{
clearTimeout
(
timeoutId
)
;
}
removeEventListeners
(
listeners
)
;
}
}
)
;
}
function
pidExists
(
pid
:
number
)
:
boolean
{
try
{
return
process
.
kill
(
pid
0
)
;
}
catch
(
error
)
{
if
(
isErrnoException
(
error
)
)
{
if
(
error
.
code
&
&
error
.
code
=
=
=
'
ESRCH
'
)
{
return
false
;
}
}
throw
error
;
}
}
