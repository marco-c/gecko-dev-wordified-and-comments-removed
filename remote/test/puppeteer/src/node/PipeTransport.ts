import
{
assert
}
from
'
.
.
/
common
/
assert
.
js
'
;
import
{
ConnectionTransport
}
from
'
.
.
/
common
/
ConnectionTransport
.
js
'
;
import
{
addEventListener
debugError
PuppeteerEventListener
removeEventListeners
}
from
'
.
.
/
common
/
util
.
js
'
;
export
class
PipeTransport
implements
ConnectionTransport
{
#
pipeWrite
:
NodeJS
.
WritableStream
;
#
eventListeners
:
PuppeteerEventListener
[
]
;
#
isClosed
=
false
;
#
pendingMessage
=
'
'
;
onclose
?
:
(
)
=
>
void
;
onmessage
?
:
(
value
:
string
)
=
>
void
;
constructor
(
pipeWrite
:
NodeJS
.
WritableStream
pipeRead
:
NodeJS
.
ReadableStream
)
{
this
.
#
pipeWrite
=
pipeWrite
;
this
.
#
eventListeners
=
[
addEventListener
(
pipeRead
'
data
'
buffer
=
>
{
return
this
.
#
dispatch
(
buffer
)
;
}
)
addEventListener
(
pipeRead
'
close
'
(
)
=
>
{
if
(
this
.
onclose
)
{
this
.
onclose
.
call
(
null
)
;
}
}
)
addEventListener
(
pipeRead
'
error
'
debugError
)
addEventListener
(
pipeWrite
'
error
'
debugError
)
]
;
}
send
(
message
:
string
)
:
void
{
assert
(
!
this
.
#
isClosed
'
PipeTransport
is
closed
.
'
)
;
this
.
#
pipeWrite
.
write
(
message
)
;
this
.
#
pipeWrite
.
write
(
'
\
0
'
)
;
}
#
dispatch
(
buffer
:
Buffer
)
:
void
{
assert
(
!
this
.
#
isClosed
'
PipeTransport
is
closed
.
'
)
;
let
end
=
buffer
.
indexOf
(
'
\
0
'
)
;
if
(
end
=
=
=
-
1
)
{
this
.
#
pendingMessage
+
=
buffer
.
toString
(
)
;
return
;
}
const
message
=
this
.
#
pendingMessage
+
buffer
.
toString
(
undefined
0
end
)
;
if
(
this
.
onmessage
)
{
this
.
onmessage
.
call
(
null
message
)
;
}
let
start
=
end
+
1
;
end
=
buffer
.
indexOf
(
'
\
0
'
start
)
;
while
(
end
!
=
=
-
1
)
{
if
(
this
.
onmessage
)
{
this
.
onmessage
.
call
(
null
buffer
.
toString
(
undefined
start
end
)
)
;
}
start
=
end
+
1
;
end
=
buffer
.
indexOf
(
'
\
0
'
start
)
;
}
this
.
#
pendingMessage
=
buffer
.
toString
(
undefined
start
)
;
}
close
(
)
:
void
{
this
.
#
isClosed
=
true
;
removeEventListeners
(
this
.
#
eventListeners
)
;
}
}
