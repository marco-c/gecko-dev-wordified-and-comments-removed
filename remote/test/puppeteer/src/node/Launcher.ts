import
*
as
os
from
'
os
'
;
import
*
as
path
from
'
path
'
;
import
*
as
http
from
'
http
'
;
import
*
as
https
from
'
https
'
;
import
*
as
URL
from
'
url
'
;
import
*
as
fs
from
'
fs
'
;
import
{
BrowserFetcher
}
from
'
.
/
BrowserFetcher
'
;
import
{
Connection
}
from
'
.
.
/
common
/
Connection
'
;
import
{
Browser
}
from
'
.
.
/
common
/
Browser
'
;
import
{
assert
}
from
'
.
.
/
common
/
assert
'
;
import
{
debugError
}
from
'
.
.
/
common
/
helper
'
;
import
{
ConnectionTransport
}
from
'
.
.
/
common
/
ConnectionTransport
'
;
import
{
WebSocketTransport
}
from
'
.
.
/
common
/
WebSocketTransport
'
;
import
{
BrowserRunner
}
from
'
.
/
BrowserRunner
'
;
import
{
promisify
}
from
'
util
'
;
const
mkdtempAsync
=
promisify
(
fs
.
mkdtemp
)
;
const
writeFileAsync
=
promisify
(
fs
.
writeFile
)
;
import
{
ChromeArgOptions
LaunchOptions
BrowserOptions
}
from
'
.
/
LaunchOptions
'
;
export
interface
ProductLauncher
{
launch
(
object
)
;
connect
(
object
)
;
executablePath
:
(
)
=
>
string
;
defaultArgs
(
object
)
;
product
:
string
;
}
class
ChromeLauncher
implements
ProductLauncher
{
_projectRoot
:
string
;
_preferredRevision
:
string
;
_isPuppeteerCore
:
boolean
;
constructor
(
projectRoot
:
string
preferredRevision
:
string
isPuppeteerCore
:
boolean
)
{
this
.
_projectRoot
=
projectRoot
;
this
.
_preferredRevision
=
preferredRevision
;
this
.
_isPuppeteerCore
=
isPuppeteerCore
;
}
async
launch
(
options
:
LaunchOptions
&
ChromeArgOptions
&
BrowserOptions
=
{
}
)
:
Promise
<
Browser
>
{
const
{
ignoreDefaultArgs
=
false
args
=
[
]
dumpio
=
false
executablePath
=
null
pipe
=
false
env
=
process
.
env
handleSIGINT
=
true
handleSIGTERM
=
true
handleSIGHUP
=
true
ignoreHTTPSErrors
=
false
defaultViewport
=
{
width
:
800
height
:
600
}
slowMo
=
0
timeout
=
30000
}
=
options
;
const
profilePath
=
path
.
join
(
os
.
tmpdir
(
)
'
puppeteer_dev_chrome_profile
-
'
)
;
const
chromeArguments
=
[
]
;
if
(
!
ignoreDefaultArgs
)
chromeArguments
.
push
(
.
.
.
this
.
defaultArgs
(
options
)
)
;
else
if
(
Array
.
isArray
(
ignoreDefaultArgs
)
)
chromeArguments
.
push
(
.
.
.
this
.
defaultArgs
(
options
)
.
filter
(
(
arg
)
=
>
!
ignoreDefaultArgs
.
includes
(
arg
)
)
)
;
else
chromeArguments
.
push
(
.
.
.
args
)
;
let
temporaryUserDataDir
=
null
;
if
(
!
chromeArguments
.
some
(
(
argument
)
=
>
argument
.
startsWith
(
'
-
-
remote
-
debugging
-
'
)
)
)
chromeArguments
.
push
(
pipe
?
'
-
-
remote
-
debugging
-
pipe
'
:
'
-
-
remote
-
debugging
-
port
=
0
'
)
;
if
(
!
chromeArguments
.
some
(
(
arg
)
=
>
arg
.
startsWith
(
'
-
-
user
-
data
-
dir
'
)
)
)
{
temporaryUserDataDir
=
await
mkdtempAsync
(
profilePath
)
;
chromeArguments
.
push
(
-
-
user
-
data
-
dir
=
{
temporaryUserDataDir
}
)
;
}
let
chromeExecutable
=
executablePath
;
if
(
os
.
arch
(
)
=
=
=
'
arm64
'
)
{
chromeExecutable
=
'
/
usr
/
bin
/
chromium
-
browser
'
;
}
else
if
(
!
executablePath
)
{
const
{
missingText
executablePath
}
=
resolveExecutablePath
(
this
)
;
if
(
missingText
)
throw
new
Error
(
missingText
)
;
chromeExecutable
=
executablePath
;
}
const
usePipe
=
chromeArguments
.
includes
(
'
-
-
remote
-
debugging
-
pipe
'
)
;
const
runner
=
new
BrowserRunner
(
chromeExecutable
chromeArguments
temporaryUserDataDir
)
;
runner
.
start
(
{
handleSIGHUP
handleSIGTERM
handleSIGINT
dumpio
env
pipe
:
usePipe
}
)
;
try
{
const
connection
=
await
runner
.
setupConnection
(
{
usePipe
timeout
slowMo
preferredRevision
:
this
.
_preferredRevision
}
)
;
const
browser
=
await
Browser
.
create
(
connection
[
]
ignoreHTTPSErrors
defaultViewport
runner
.
proc
runner
.
close
.
bind
(
runner
)
)
;
await
browser
.
waitForTarget
(
(
t
)
=
>
t
.
type
(
)
=
=
=
'
page
'
)
;
return
browser
;
}
catch
(
error
)
{
runner
.
kill
(
)
;
throw
error
;
}
}
defaultArgs
(
options
:
ChromeArgOptions
=
{
}
)
:
string
[
]
{
const
chromeArguments
=
[
'
-
-
disable
-
background
-
networking
'
'
-
-
enable
-
features
=
NetworkService
NetworkServiceInProcess
'
'
-
-
disable
-
background
-
timer
-
throttling
'
'
-
-
disable
-
backgrounding
-
occluded
-
windows
'
'
-
-
disable
-
breakpad
'
'
-
-
disable
-
client
-
side
-
phishing
-
detection
'
'
-
-
disable
-
component
-
extensions
-
with
-
background
-
pages
'
'
-
-
disable
-
default
-
apps
'
'
-
-
disable
-
dev
-
shm
-
usage
'
'
-
-
disable
-
extensions
'
'
-
-
disable
-
features
=
TranslateUI
'
'
-
-
disable
-
hang
-
monitor
'
'
-
-
disable
-
ipc
-
flooding
-
protection
'
'
-
-
disable
-
popup
-
blocking
'
'
-
-
disable
-
prompt
-
on
-
repost
'
'
-
-
disable
-
renderer
-
backgrounding
'
'
-
-
disable
-
sync
'
'
-
-
force
-
color
-
profile
=
srgb
'
'
-
-
metrics
-
recording
-
only
'
'
-
-
no
-
first
-
run
'
'
-
-
enable
-
automation
'
'
-
-
password
-
store
=
basic
'
'
-
-
use
-
mock
-
keychain
'
]
;
const
{
devtools
=
false
headless
=
!
devtools
args
=
[
]
userDataDir
=
null
}
=
options
;
if
(
userDataDir
)
chromeArguments
.
push
(
-
-
user
-
data
-
dir
=
{
userDataDir
}
)
;
if
(
devtools
)
chromeArguments
.
push
(
'
-
-
auto
-
open
-
devtools
-
for
-
tabs
'
)
;
if
(
headless
)
{
chromeArguments
.
push
(
'
-
-
headless
'
'
-
-
hide
-
scrollbars
'
'
-
-
mute
-
audio
'
)
;
}
if
(
args
.
every
(
(
arg
)
=
>
arg
.
startsWith
(
'
-
'
)
)
)
chromeArguments
.
push
(
'
about
:
blank
'
)
;
chromeArguments
.
push
(
.
.
.
args
)
;
return
chromeArguments
;
}
executablePath
(
)
:
string
{
return
resolveExecutablePath
(
this
)
.
executablePath
;
}
get
product
(
)
:
string
{
return
'
chrome
'
;
}
async
connect
(
options
:
BrowserOptions
&
{
browserWSEndpoint
?
:
string
;
browserURL
?
:
string
;
transport
?
:
ConnectionTransport
;
}
)
:
Promise
<
Browser
>
{
const
{
browserWSEndpoint
browserURL
ignoreHTTPSErrors
=
false
defaultViewport
=
{
width
:
800
height
:
600
}
transport
slowMo
=
0
}
=
options
;
assert
(
Number
(
!
!
browserWSEndpoint
)
+
Number
(
!
!
browserURL
)
+
Number
(
!
!
transport
)
=
=
=
1
'
Exactly
one
of
browserWSEndpoint
browserURL
or
transport
must
be
passed
to
puppeteer
.
connect
'
)
;
let
connection
=
null
;
if
(
transport
)
{
connection
=
new
Connection
(
'
'
transport
slowMo
)
;
}
else
if
(
browserWSEndpoint
)
{
const
connectionTransport
=
await
WebSocketTransport
.
create
(
browserWSEndpoint
)
;
connection
=
new
Connection
(
browserWSEndpoint
connectionTransport
slowMo
)
;
}
else
if
(
browserURL
)
{
const
connectionURL
=
await
getWSEndpoint
(
browserURL
)
;
const
connectionTransport
=
await
WebSocketTransport
.
create
(
connectionURL
)
;
connection
=
new
Connection
(
connectionURL
connectionTransport
slowMo
)
;
}
const
{
browserContextIds
}
=
await
connection
.
send
(
'
Target
.
getBrowserContexts
'
)
;
return
Browser
.
create
(
connection
browserContextIds
ignoreHTTPSErrors
defaultViewport
null
(
)
=
>
connection
.
send
(
'
Browser
.
close
'
)
.
catch
(
debugError
)
)
;
}
}
class
FirefoxLauncher
implements
ProductLauncher
{
_projectRoot
:
string
;
_preferredRevision
:
string
;
_isPuppeteerCore
:
boolean
;
constructor
(
projectRoot
:
string
preferredRevision
:
string
isPuppeteerCore
:
boolean
)
{
this
.
_projectRoot
=
projectRoot
;
this
.
_preferredRevision
=
preferredRevision
;
this
.
_isPuppeteerCore
=
isPuppeteerCore
;
}
async
launch
(
options
:
LaunchOptions
&
ChromeArgOptions
&
BrowserOptions
&
{
extraPrefsFirefox
?
:
{
[
x
:
string
]
:
unknown
}
;
}
=
{
}
)
:
Promise
<
Browser
>
{
const
{
ignoreDefaultArgs
=
false
args
=
[
]
dumpio
=
false
executablePath
=
null
pipe
=
false
env
=
process
.
env
handleSIGINT
=
true
handleSIGTERM
=
true
handleSIGHUP
=
true
ignoreHTTPSErrors
=
false
defaultViewport
=
{
width
:
800
height
:
600
}
slowMo
=
0
timeout
=
30000
extraPrefsFirefox
=
{
}
}
=
options
;
const
firefoxArguments
=
[
]
;
if
(
!
ignoreDefaultArgs
)
firefoxArguments
.
push
(
.
.
.
this
.
defaultArgs
(
options
)
)
;
else
if
(
Array
.
isArray
(
ignoreDefaultArgs
)
)
firefoxArguments
.
push
(
.
.
.
this
.
defaultArgs
(
options
)
.
filter
(
(
arg
)
=
>
!
ignoreDefaultArgs
.
includes
(
arg
)
)
)
;
else
firefoxArguments
.
push
(
.
.
.
args
)
;
if
(
!
firefoxArguments
.
some
(
(
argument
)
=
>
argument
.
startsWith
(
'
-
-
remote
-
debugging
-
'
)
)
)
firefoxArguments
.
push
(
'
-
-
remote
-
debugging
-
port
=
0
'
)
;
let
temporaryUserDataDir
=
null
;
if
(
!
firefoxArguments
.
includes
(
'
-
profile
'
)
&
&
!
firefoxArguments
.
includes
(
'
-
-
profile
'
)
)
{
temporaryUserDataDir
=
await
this
.
_createProfile
(
extraPrefsFirefox
)
;
firefoxArguments
.
push
(
'
-
-
profile
'
)
;
firefoxArguments
.
push
(
temporaryUserDataDir
)
;
}
await
this
.
_updateRevision
(
)
;
let
firefoxExecutable
=
executablePath
;
if
(
!
executablePath
)
{
const
{
missingText
executablePath
}
=
resolveExecutablePath
(
this
)
;
if
(
missingText
)
throw
new
Error
(
missingText
)
;
firefoxExecutable
=
executablePath
;
}
const
runner
=
new
BrowserRunner
(
firefoxExecutable
firefoxArguments
temporaryUserDataDir
)
;
runner
.
start
(
{
handleSIGHUP
handleSIGTERM
handleSIGINT
dumpio
env
pipe
}
)
;
try
{
const
connection
=
await
runner
.
setupConnection
(
{
usePipe
:
pipe
timeout
slowMo
preferredRevision
:
this
.
_preferredRevision
}
)
;
const
browser
=
await
Browser
.
create
(
connection
[
]
ignoreHTTPSErrors
defaultViewport
runner
.
proc
runner
.
close
.
bind
(
runner
)
)
;
await
browser
.
waitForTarget
(
(
t
)
=
>
t
.
type
(
)
=
=
=
'
page
'
)
;
return
browser
;
}
catch
(
error
)
{
runner
.
kill
(
)
;
throw
error
;
}
}
async
connect
(
options
:
BrowserOptions
&
{
browserWSEndpoint
?
:
string
;
browserURL
?
:
string
;
transport
?
:
ConnectionTransport
;
}
)
:
Promise
<
Browser
>
{
const
{
browserWSEndpoint
browserURL
ignoreHTTPSErrors
=
false
defaultViewport
=
{
width
:
800
height
:
600
}
transport
slowMo
=
0
}
=
options
;
assert
(
Number
(
!
!
browserWSEndpoint
)
+
Number
(
!
!
browserURL
)
+
Number
(
!
!
transport
)
=
=
=
1
'
Exactly
one
of
browserWSEndpoint
browserURL
or
transport
must
be
passed
to
puppeteer
.
connect
'
)
;
let
connection
=
null
;
if
(
transport
)
{
connection
=
new
Connection
(
'
'
transport
slowMo
)
;
}
else
if
(
browserWSEndpoint
)
{
const
connectionTransport
=
await
WebSocketTransport
.
create
(
browserWSEndpoint
)
;
connection
=
new
Connection
(
browserWSEndpoint
connectionTransport
slowMo
)
;
}
else
if
(
browserURL
)
{
const
connectionURL
=
await
getWSEndpoint
(
browserURL
)
;
const
connectionTransport
=
await
WebSocketTransport
.
create
(
connectionURL
)
;
connection
=
new
Connection
(
connectionURL
connectionTransport
slowMo
)
;
}
const
{
browserContextIds
}
=
await
connection
.
send
(
'
Target
.
getBrowserContexts
'
)
;
return
Browser
.
create
(
connection
browserContextIds
ignoreHTTPSErrors
defaultViewport
null
(
)
=
>
connection
.
send
(
'
Browser
.
close
'
)
.
catch
(
debugError
)
)
;
}
executablePath
(
)
:
string
{
return
resolveExecutablePath
(
this
)
.
executablePath
;
}
async
_updateRevision
(
)
:
Promise
<
void
>
{
if
(
this
.
_preferredRevision
=
=
=
'
latest
'
)
{
const
browserFetcher
=
new
BrowserFetcher
(
this
.
_projectRoot
{
product
:
this
.
product
}
)
;
const
localRevisions
=
await
browserFetcher
.
localRevisions
(
)
;
if
(
localRevisions
[
0
]
)
this
.
_preferredRevision
=
localRevisions
[
0
]
;
}
}
get
product
(
)
:
string
{
return
'
firefox
'
;
}
defaultArgs
(
options
:
ChromeArgOptions
=
{
}
)
:
string
[
]
{
const
firefoxArguments
=
[
'
-
-
no
-
remote
'
'
-
-
foreground
'
]
;
const
{
devtools
=
false
headless
=
!
devtools
args
=
[
]
userDataDir
=
null
}
=
options
;
if
(
userDataDir
)
{
firefoxArguments
.
push
(
'
-
-
profile
'
)
;
firefoxArguments
.
push
(
userDataDir
)
;
}
if
(
headless
)
firefoxArguments
.
push
(
'
-
-
headless
'
)
;
if
(
devtools
)
firefoxArguments
.
push
(
'
-
-
devtools
'
)
;
if
(
args
.
every
(
(
arg
)
=
>
arg
.
startsWith
(
'
-
'
)
)
)
firefoxArguments
.
push
(
'
about
:
blank
'
)
;
firefoxArguments
.
push
(
.
.
.
args
)
;
return
firefoxArguments
;
}
async
_createProfile
(
extraPrefs
:
{
[
x
:
string
]
:
unknown
}
)
:
Promise
<
string
>
{
const
profilePath
=
await
mkdtempAsync
(
path
.
join
(
os
.
tmpdir
(
)
'
puppeteer_dev_firefox_profile
-
'
)
)
;
const
prefsJS
=
[
]
;
const
userJS
=
[
]
;
const
server
=
'
dummy
.
test
'
;
const
defaultPreferences
=
{
'
app
.
normandy
.
api_url
'
:
'
'
'
app
.
update
.
checkInstallTime
'
:
false
'
app
.
update
.
disabledForTesting
'
:
true
'
apz
.
content_response_timeout
'
:
60000
'
browser
.
contentblocking
.
features
.
standard
'
:
'
-
tp
tpPrivate
cookieBehavior0
-
cm
-
fp
'
'
browser
.
dom
.
window
.
dump
.
enabled
'
:
true
'
browser
.
newtabpage
.
activity
-
stream
.
feeds
.
system
.
topstories
'
:
false
'
browser
.
newtabpage
.
enabled
'
:
false
'
browser
.
pagethumbnails
.
capturing_disabled
'
:
true
'
browser
.
safebrowsing
.
blockedURIs
.
enabled
'
:
false
'
browser
.
safebrowsing
.
downloads
.
enabled
'
:
false
'
browser
.
safebrowsing
.
malware
.
enabled
'
:
false
'
browser
.
safebrowsing
.
passwords
.
enabled
'
:
false
'
browser
.
safebrowsing
.
phishing
.
enabled
'
:
false
'
browser
.
search
.
update
'
:
false
'
browser
.
sessionstore
.
resume_from_crash
'
:
false
'
browser
.
shell
.
checkDefaultBrowser
'
:
false
'
browser
.
startup
.
homepage
'
:
'
about
:
blank
'
'
browser
.
startup
.
homepage_override
.
mstone
'
:
'
ignore
'
'
browser
.
startup
.
page
'
:
0
'
browser
.
tabs
.
disableBackgroundZombification
'
:
false
'
browser
.
tabs
.
warnOnCloseOtherTabs
'
:
false
'
browser
.
tabs
.
warnOnOpen
'
:
false
'
browser
.
uitour
.
enabled
'
:
false
'
browser
.
urlbar
.
suggest
.
searches
'
:
false
'
browser
.
usedOnWindows10
.
introURL
'
:
'
'
'
browser
.
warnOnQuit
'
:
false
'
datareporting
.
healthreport
.
about
.
reportUrl
'
:
http
:
/
/
{
server
}
/
dummy
/
abouthealthreport
/
'
datareporting
.
healthreport
.
documentServerURI
'
:
http
:
/
/
{
server
}
/
dummy
/
healthreport
/
'
datareporting
.
healthreport
.
logging
.
consoleEnabled
'
:
false
'
datareporting
.
healthreport
.
service
.
enabled
'
:
false
'
datareporting
.
healthreport
.
service
.
firstRun
'
:
false
'
datareporting
.
healthreport
.
uploadEnabled
'
:
false
'
datareporting
.
policy
.
dataSubmissionEnabled
'
:
false
'
datareporting
.
policy
.
dataSubmissionPolicyBypassNotification
'
:
true
'
devtools
.
jsonview
.
enabled
'
:
false
'
dom
.
disable_open_during_load
'
:
false
'
dom
.
file
.
createInChild
'
:
true
'
dom
.
ipc
.
reportProcessHangs
'
:
false
'
dom
.
max_chrome_script_run_time
'
:
0
'
dom
.
max_script_run_time
'
:
0
'
extensions
.
autoDisableScopes
'
:
0
'
extensions
.
enabledScopes
'
:
5
'
extensions
.
getAddons
.
cache
.
enabled
'
:
false
'
extensions
.
installDistroAddons
'
:
false
'
extensions
.
screenshots
.
disabled
'
:
true
'
extensions
.
update
.
enabled
'
:
false
'
extensions
.
update
.
notifyUser
'
:
false
'
extensions
.
webservice
.
discoverURL
'
:
http
:
/
/
{
server
}
/
dummy
/
discoveryURL
'
focusmanager
.
testmode
'
:
true
'
general
.
useragent
.
updates
.
enabled
'
:
false
'
geo
.
provider
.
testing
'
:
true
'
geo
.
wifi
.
scan
'
:
false
'
hangmonitor
.
timeout
'
:
0
'
javascript
.
options
.
showInConsole
'
:
true
'
media
.
gmp
-
manager
.
updateEnabled
'
:
false
'
network
.
cookie
.
cookieBehavior
'
:
0
'
network
.
http
.
prompt
-
temp
-
redirect
'
:
false
'
network
.
http
.
speculative
-
parallel
-
limit
'
:
0
'
network
.
manage
-
offline
-
status
'
:
false
'
network
.
sntp
.
pools
'
:
server
'
plugin
.
state
.
flash
'
:
0
'
privacy
.
trackingprotection
.
enabled
'
:
false
'
remote
.
enabled
'
:
true
'
security
.
certerrors
.
mitm
.
priming
.
enabled
'
:
false
'
security
.
fileuri
.
strict_origin_policy
'
:
false
'
security
.
notification_enable_delay
'
:
0
'
services
.
settings
.
server
'
:
http
:
/
/
{
server
}
/
dummy
/
blocklist
/
'
signon
.
autofillForms
'
:
false
'
signon
.
rememberSignons
'
:
false
'
startup
.
homepage_welcome_url
'
:
'
about
:
blank
'
'
startup
.
homepage_welcome_url
.
additional
'
:
'
'
'
toolkit
.
cosmeticAnimations
.
enabled
'
:
false
'
toolkit
.
startup
.
max_resumed_crashes
'
:
-
1
}
;
Object
.
assign
(
defaultPreferences
extraPrefs
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
defaultPreferences
)
)
userJS
.
push
(
user_pref
(
{
JSON
.
stringify
(
key
)
}
{
JSON
.
stringify
(
value
)
}
)
;
)
;
await
writeFileAsync
(
path
.
join
(
profilePath
'
user
.
js
'
)
userJS
.
join
(
'
\
n
'
)
)
;
await
writeFileAsync
(
path
.
join
(
profilePath
'
prefs
.
js
'
)
prefsJS
.
join
(
'
\
n
'
)
)
;
return
profilePath
;
}
}
function
getWSEndpoint
(
browserURL
:
string
)
:
Promise
<
string
>
{
let
resolve
reject
;
const
promise
=
new
Promise
<
string
>
(
(
res
rej
)
=
>
{
resolve
=
res
;
reject
=
rej
;
}
)
;
const
endpointURL
=
URL
.
resolve
(
browserURL
'
/
json
/
version
'
)
;
const
protocol
=
endpointURL
.
startsWith
(
'
https
'
)
?
https
:
http
;
const
requestOptions
=
Object
.
assign
(
URL
.
parse
(
endpointURL
)
{
method
:
'
GET
'
}
)
;
const
request
=
protocol
.
request
(
requestOptions
(
res
)
=
>
{
let
data
=
'
'
;
if
(
res
.
statusCode
!
=
=
200
)
{
res
.
resume
(
)
;
reject
(
new
Error
(
'
HTTP
'
+
res
.
statusCode
)
)
;
return
;
}
res
.
setEncoding
(
'
utf8
'
)
;
res
.
on
(
'
data
'
(
chunk
)
=
>
(
data
+
=
chunk
)
)
;
res
.
on
(
'
end
'
(
)
=
>
resolve
(
JSON
.
parse
(
data
)
.
webSocketDebuggerUrl
)
)
;
}
)
;
request
.
on
(
'
error
'
reject
)
;
request
.
end
(
)
;
return
promise
.
catch
(
(
error
)
=
>
{
error
.
message
=
Failed
to
fetch
browser
webSocket
url
from
{
endpointURL
}
:
+
error
.
message
;
throw
error
;
}
)
;
}
function
resolveExecutablePath
(
launcher
:
ChromeLauncher
|
FirefoxLauncher
)
:
{
executablePath
:
string
;
missingText
?
:
string
}
{
if
(
!
launcher
.
_isPuppeteerCore
)
{
const
executablePath
=
process
.
env
.
PUPPETEER_EXECUTABLE_PATH
|
|
process
.
env
.
npm_config_puppeteer_executable_path
|
|
process
.
env
.
npm_package_config_puppeteer_executable_path
;
if
(
executablePath
)
{
const
missingText
=
!
fs
.
existsSync
(
executablePath
)
?
'
Tried
to
use
PUPPETEER_EXECUTABLE_PATH
env
variable
to
launch
browser
but
did
not
find
any
executable
at
:
'
+
executablePath
:
null
;
return
{
executablePath
missingText
}
;
}
}
const
browserFetcher
=
new
BrowserFetcher
(
launcher
.
_projectRoot
{
product
:
launcher
.
product
}
)
;
if
(
!
launcher
.
_isPuppeteerCore
&
&
launcher
.
product
=
=
=
'
chrome
'
)
{
const
revision
=
process
.
env
[
'
PUPPETEER_CHROMIUM_REVISION
'
]
;
if
(
revision
)
{
const
revisionInfo
=
browserFetcher
.
revisionInfo
(
revision
)
;
const
missingText
=
!
revisionInfo
.
local
?
'
Tried
to
use
PUPPETEER_CHROMIUM_REVISION
env
variable
to
launch
browser
but
did
not
find
executable
at
:
'
+
revisionInfo
.
executablePath
:
null
;
return
{
executablePath
:
revisionInfo
.
executablePath
missingText
}
;
}
}
const
revisionInfo
=
browserFetcher
.
revisionInfo
(
launcher
.
_preferredRevision
)
;
const
missingText
=
!
revisionInfo
.
local
?
Could
not
find
browser
revision
{
launcher
.
_preferredRevision
}
.
Run
"
npm
install
"
or
"
yarn
install
"
to
download
a
browser
binary
.
:
null
;
return
{
executablePath
:
revisionInfo
.
executablePath
missingText
}
;
}
export
default
function
Launcher
(
projectRoot
:
string
preferredRevision
:
string
isPuppeteerCore
:
boolean
product
?
:
string
)
:
ProductLauncher
{
if
(
!
product
&
&
!
isPuppeteerCore
)
product
=
process
.
env
.
PUPPETEER_PRODUCT
|
|
process
.
env
.
npm_config_puppeteer_product
|
|
process
.
env
.
npm_package_config_puppeteer_product
;
switch
(
product
)
{
case
'
firefox
'
:
return
new
FirefoxLauncher
(
projectRoot
preferredRevision
isPuppeteerCore
)
;
case
'
chrome
'
:
default
:
if
(
typeof
product
!
=
=
'
undefined
'
&
&
product
!
=
=
'
chrome
'
)
{
console
.
warn
(
Warning
:
unknown
product
name
{
product
}
.
Falling
back
to
chrome
.
)
;
}
return
new
ChromeLauncher
(
projectRoot
preferredRevision
isPuppeteerCore
)
;
}
}
