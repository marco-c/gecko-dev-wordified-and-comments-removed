import
{
createTextContent
isSuitableNodeForTextMatching
}
from
'
.
/
TextContent
.
js
'
;
export
const
textQuerySelector
=
(
root
:
Node
selector
:
string
)
:
Element
|
null
=
>
{
for
(
const
node
of
root
.
childNodes
)
{
if
(
node
instanceof
Element
&
&
isSuitableNodeForTextMatching
(
node
)
)
{
let
matchedNode
:
Element
|
null
;
if
(
node
.
shadowRoot
)
{
matchedNode
=
textQuerySelector
(
node
.
shadowRoot
selector
)
;
}
else
{
matchedNode
=
textQuerySelector
(
node
selector
)
;
}
if
(
matchedNode
)
{
return
matchedNode
;
}
}
}
if
(
root
instanceof
Element
)
{
const
textContent
=
createTextContent
(
root
)
;
if
(
textContent
.
full
.
includes
(
selector
)
)
{
return
root
;
}
}
return
null
;
}
;
export
const
textQuerySelectorAll
=
(
root
:
Node
selector
:
string
)
:
Element
[
]
=
>
{
let
results
:
Element
[
]
=
[
]
;
for
(
const
node
of
root
.
childNodes
)
{
if
(
node
instanceof
Element
)
{
let
matchedNodes
:
Element
[
]
;
if
(
node
.
shadowRoot
)
{
matchedNodes
=
textQuerySelectorAll
(
node
.
shadowRoot
selector
)
;
}
else
{
matchedNodes
=
textQuerySelectorAll
(
node
selector
)
;
}
results
=
results
.
concat
(
matchedNodes
)
;
}
}
if
(
results
.
length
>
0
)
{
return
results
;
}
if
(
root
instanceof
Element
)
{
const
textContent
=
createTextContent
(
root
)
;
if
(
textContent
.
full
.
includes
(
selector
)
)
{
return
[
root
]
;
}
}
return
[
]
;
}
;
