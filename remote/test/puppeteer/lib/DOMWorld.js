const
fs
=
require
(
'
fs
'
)
;
const
{
helper
assert
}
=
require
(
'
.
/
helper
'
)
;
const
{
LifecycleWatcher
}
=
require
(
'
.
/
LifecycleWatcher
'
)
;
const
{
TimeoutError
}
=
require
(
'
.
/
Errors
'
)
;
const
readFileAsync
=
helper
.
promisify
(
fs
.
readFile
)
;
class
DOMWorld
{
constructor
(
frameManager
frame
timeoutSettings
)
{
this
.
_frameManager
=
frameManager
;
this
.
_frame
=
frame
;
this
.
_timeoutSettings
=
timeoutSettings
;
this
.
_documentPromise
=
null
;
this
.
_contextPromise
;
this
.
_contextResolveCallback
=
null
;
this
.
_setContext
(
null
)
;
this
.
_waitTasks
=
new
Set
(
)
;
this
.
_detached
=
false
;
}
frame
(
)
{
return
this
.
_frame
;
}
_setContext
(
context
)
{
if
(
context
)
{
this
.
_contextResolveCallback
.
call
(
null
context
)
;
this
.
_contextResolveCallback
=
null
;
for
(
const
waitTask
of
this
.
_waitTasks
)
waitTask
.
rerun
(
)
;
}
else
{
this
.
_documentPromise
=
null
;
this
.
_contextPromise
=
new
Promise
(
fulfill
=
>
{
this
.
_contextResolveCallback
=
fulfill
;
}
)
;
}
}
_hasContext
(
)
{
return
!
this
.
_contextResolveCallback
;
}
_detach
(
)
{
this
.
_detached
=
true
;
for
(
const
waitTask
of
this
.
_waitTasks
)
waitTask
.
terminate
(
new
Error
(
'
waitForFunction
failed
:
frame
got
detached
.
'
)
)
;
}
executionContext
(
)
{
if
(
this
.
_detached
)
throw
new
Error
(
Execution
Context
is
not
available
in
detached
frame
"
{
this
.
_frame
.
url
(
)
}
"
(
are
you
trying
to
evaluate
?
)
)
;
return
this
.
_contextPromise
;
}
async
evaluateHandle
(
pageFunction
.
.
.
args
)
{
const
context
=
await
this
.
executionContext
(
)
;
return
context
.
evaluateHandle
(
pageFunction
.
.
.
args
)
;
}
async
evaluate
(
pageFunction
.
.
.
args
)
{
const
context
=
await
this
.
executionContext
(
)
;
return
context
.
evaluate
(
pageFunction
.
.
.
args
)
;
}
async
(
selector
)
{
const
document
=
await
this
.
_document
(
)
;
const
value
=
await
document
.
(
selector
)
;
return
value
;
}
async
_document
(
)
{
if
(
this
.
_documentPromise
)
return
this
.
_documentPromise
;
this
.
_documentPromise
=
this
.
executionContext
(
)
.
then
(
async
context
=
>
{
const
document
=
await
context
.
evaluateHandle
(
'
document
'
)
;
return
document
.
asElement
(
)
;
}
)
;
return
this
.
_documentPromise
;
}
async
x
(
expression
)
{
const
document
=
await
this
.
_document
(
)
;
const
value
=
await
document
.
x
(
expression
)
;
return
value
;
}
async
eval
(
selector
pageFunction
.
.
.
args
)
{
const
document
=
await
this
.
_document
(
)
;
return
document
.
eval
(
selector
pageFunction
.
.
.
args
)
;
}
async
eval
(
selector
pageFunction
.
.
.
args
)
{
const
document
=
await
this
.
_document
(
)
;
const
value
=
await
document
.
eval
(
selector
pageFunction
.
.
.
args
)
;
return
value
;
}
async
(
selector
)
{
const
document
=
await
this
.
_document
(
)
;
const
value
=
await
document
.
(
selector
)
;
return
value
;
}
async
content
(
)
{
return
await
this
.
evaluate
(
(
)
=
>
{
let
retVal
=
'
'
;
if
(
document
.
doctype
)
retVal
=
new
XMLSerializer
(
)
.
serializeToString
(
document
.
doctype
)
;
if
(
document
.
documentElement
)
retVal
+
=
document
.
documentElement
.
outerHTML
;
return
retVal
;
}
)
;
}
async
setContent
(
html
options
=
{
}
)
{
const
{
waitUntil
=
[
'
load
'
]
timeout
=
this
.
_timeoutSettings
.
navigationTimeout
(
)
}
=
options
;
await
this
.
evaluate
(
html
=
>
{
document
.
open
(
)
;
document
.
write
(
html
)
;
document
.
close
(
)
;
}
html
)
;
const
watcher
=
new
LifecycleWatcher
(
this
.
_frameManager
this
.
_frame
waitUntil
timeout
)
;
const
error
=
await
Promise
.
race
(
[
watcher
.
timeoutOrTerminationPromise
(
)
watcher
.
lifecyclePromise
(
)
]
)
;
watcher
.
dispose
(
)
;
if
(
error
)
throw
error
;
}
async
addScriptTag
(
options
)
{
const
{
url
=
null
path
=
null
content
=
null
type
=
'
'
}
=
options
;
if
(
url
!
=
=
null
)
{
try
{
const
context
=
await
this
.
executionContext
(
)
;
return
(
await
context
.
evaluateHandle
(
addScriptUrl
url
type
)
)
.
asElement
(
)
;
}
catch
(
error
)
{
throw
new
Error
(
Loading
script
from
{
url
}
failed
)
;
}
}
if
(
path
!
=
=
null
)
{
let
contents
=
await
readFileAsync
(
path
'
utf8
'
)
;
contents
+
=
'
/
/
#
sourceURL
=
'
+
path
.
replace
(
/
\
n
/
g
'
'
)
;
const
context
=
await
this
.
executionContext
(
)
;
return
(
await
context
.
evaluateHandle
(
addScriptContent
contents
type
)
)
.
asElement
(
)
;
}
if
(
content
!
=
=
null
)
{
const
context
=
await
this
.
executionContext
(
)
;
return
(
await
context
.
evaluateHandle
(
addScriptContent
content
type
)
)
.
asElement
(
)
;
}
throw
new
Error
(
'
Provide
an
object
with
a
url
path
or
content
property
'
)
;
async
function
addScriptUrl
(
url
type
)
{
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
src
=
url
;
if
(
type
)
script
.
type
=
type
;
const
promise
=
new
Promise
(
(
res
rej
)
=
>
{
script
.
onload
=
res
;
script
.
onerror
=
rej
;
}
)
;
document
.
head
.
appendChild
(
script
)
;
await
promise
;
return
script
;
}
function
addScriptContent
(
content
type
=
'
text
/
javascript
'
)
{
const
script
=
document
.
createElement
(
'
script
'
)
;
script
.
type
=
type
;
script
.
text
=
content
;
let
error
=
null
;
script
.
onerror
=
e
=
>
error
=
e
;
document
.
head
.
appendChild
(
script
)
;
if
(
error
)
throw
error
;
return
script
;
}
}
async
addStyleTag
(
options
)
{
const
{
url
=
null
path
=
null
content
=
null
}
=
options
;
if
(
url
!
=
=
null
)
{
try
{
const
context
=
await
this
.
executionContext
(
)
;
return
(
await
context
.
evaluateHandle
(
addStyleUrl
url
)
)
.
asElement
(
)
;
}
catch
(
error
)
{
throw
new
Error
(
Loading
style
from
{
url
}
failed
)
;
}
}
if
(
path
!
=
=
null
)
{
let
contents
=
await
readFileAsync
(
path
'
utf8
'
)
;
contents
+
=
'
/
*
#
sourceURL
=
'
+
path
.
replace
(
/
\
n
/
g
'
'
)
+
'
*
/
'
;
const
context
=
await
this
.
executionContext
(
)
;
return
(
await
context
.
evaluateHandle
(
addStyleContent
contents
)
)
.
asElement
(
)
;
}
if
(
content
!
=
=
null
)
{
const
context
=
await
this
.
executionContext
(
)
;
return
(
await
context
.
evaluateHandle
(
addStyleContent
content
)
)
.
asElement
(
)
;
}
throw
new
Error
(
'
Provide
an
object
with
a
url
path
or
content
property
'
)
;
async
function
addStyleUrl
(
url
)
{
const
link
=
document
.
createElement
(
'
link
'
)
;
link
.
rel
=
'
stylesheet
'
;
link
.
href
=
url
;
const
promise
=
new
Promise
(
(
res
rej
)
=
>
{
link
.
onload
=
res
;
link
.
onerror
=
rej
;
}
)
;
document
.
head
.
appendChild
(
link
)
;
await
promise
;
return
link
;
}
async
function
addStyleContent
(
content
)
{
const
style
=
document
.
createElement
(
'
style
'
)
;
style
.
type
=
'
text
/
css
'
;
style
.
appendChild
(
document
.
createTextNode
(
content
)
)
;
const
promise
=
new
Promise
(
(
res
rej
)
=
>
{
style
.
onload
=
res
;
style
.
onerror
=
rej
;
}
)
;
document
.
head
.
appendChild
(
style
)
;
await
promise
;
return
style
;
}
}
async
click
(
selector
options
)
{
const
handle
=
await
this
.
(
selector
)
;
assert
(
handle
'
No
node
found
for
selector
:
'
+
selector
)
;
await
handle
.
click
(
options
)
;
await
handle
.
dispose
(
)
;
}
async
focus
(
selector
)
{
const
handle
=
await
this
.
(
selector
)
;
assert
(
handle
'
No
node
found
for
selector
:
'
+
selector
)
;
await
handle
.
focus
(
)
;
await
handle
.
dispose
(
)
;
}
async
hover
(
selector
)
{
const
handle
=
await
this
.
(
selector
)
;
assert
(
handle
'
No
node
found
for
selector
:
'
+
selector
)
;
await
handle
.
hover
(
)
;
await
handle
.
dispose
(
)
;
}
select
(
selector
.
.
.
values
)
{
for
(
const
value
of
values
)
assert
(
helper
.
isString
(
value
)
'
Values
must
be
strings
.
Found
value
"
'
+
value
+
'
"
of
type
"
'
+
(
typeof
value
)
+
'
"
'
)
;
return
this
.
eval
(
selector
(
element
values
)
=
>
{
if
(
element
.
nodeName
.
toLowerCase
(
)
!
=
=
'
select
'
)
throw
new
Error
(
'
Element
is
not
a
<
select
>
element
.
'
)
;
const
options
=
Array
.
from
(
element
.
options
)
;
element
.
value
=
undefined
;
for
(
const
option
of
options
)
{
option
.
selected
=
values
.
includes
(
option
.
value
)
;
if
(
option
.
selected
&
&
!
element
.
multiple
)
break
;
}
element
.
dispatchEvent
(
new
Event
(
'
input
'
{
'
bubbles
'
:
true
}
)
)
;
element
.
dispatchEvent
(
new
Event
(
'
change
'
{
'
bubbles
'
:
true
}
)
)
;
return
options
.
filter
(
option
=
>
option
.
selected
)
.
map
(
option
=
>
option
.
value
)
;
}
values
)
;
}
async
tap
(
selector
)
{
const
handle
=
await
this
.
(
selector
)
;
assert
(
handle
'
No
node
found
for
selector
:
'
+
selector
)
;
await
handle
.
tap
(
)
;
await
handle
.
dispose
(
)
;
}
async
type
(
selector
text
options
)
{
const
handle
=
await
this
.
(
selector
)
;
assert
(
handle
'
No
node
found
for
selector
:
'
+
selector
)
;
await
handle
.
type
(
text
options
)
;
await
handle
.
dispose
(
)
;
}
waitForSelector
(
selector
options
)
{
return
this
.
_waitForSelectorOrXPath
(
selector
false
options
)
;
}
waitForXPath
(
xpath
options
)
{
return
this
.
_waitForSelectorOrXPath
(
xpath
true
options
)
;
}
waitForFunction
(
pageFunction
options
=
{
}
.
.
.
args
)
{
const
{
polling
=
'
raf
'
timeout
=
this
.
_timeoutSettings
.
timeout
(
)
}
=
options
;
return
new
WaitTask
(
this
pageFunction
'
function
'
polling
timeout
.
.
.
args
)
.
promise
;
}
async
title
(
)
{
return
this
.
evaluate
(
(
)
=
>
document
.
title
)
;
}
async
_waitForSelectorOrXPath
(
selectorOrXPath
isXPath
options
=
{
}
)
{
const
{
visible
:
waitForVisible
=
false
hidden
:
waitForHidden
=
false
timeout
=
this
.
_timeoutSettings
.
timeout
(
)
}
=
options
;
const
polling
=
waitForVisible
|
|
waitForHidden
?
'
raf
'
:
'
mutation
'
;
const
title
=
{
isXPath
?
'
XPath
'
:
'
selector
'
}
"
{
selectorOrXPath
}
"
{
waitForHidden
?
'
to
be
hidden
'
:
'
'
}
;
const
waitTask
=
new
WaitTask
(
this
predicate
title
polling
timeout
selectorOrXPath
isXPath
waitForVisible
waitForHidden
)
;
const
handle
=
await
waitTask
.
promise
;
if
(
!
handle
.
asElement
(
)
)
{
await
handle
.
dispose
(
)
;
return
null
;
}
return
handle
.
asElement
(
)
;
function
predicate
(
selectorOrXPath
isXPath
waitForVisible
waitForHidden
)
{
const
node
=
isXPath
?
document
.
evaluate
(
selectorOrXPath
document
null
XPathResult
.
FIRST_ORDERED_NODE_TYPE
null
)
.
singleNodeValue
:
document
.
querySelector
(
selectorOrXPath
)
;
if
(
!
node
)
return
waitForHidden
;
if
(
!
waitForVisible
&
&
!
waitForHidden
)
return
node
;
const
element
=
(
node
.
nodeType
=
=
=
Node
.
TEXT_NODE
?
node
.
parentElement
:
node
)
;
const
style
=
window
.
getComputedStyle
(
element
)
;
const
isVisible
=
style
&
&
style
.
visibility
!
=
=
'
hidden
'
&
&
hasVisibleBoundingBox
(
)
;
const
success
=
(
waitForVisible
=
=
=
isVisible
|
|
waitForHidden
=
=
=
!
isVisible
)
;
return
success
?
node
:
null
;
function
hasVisibleBoundingBox
(
)
{
const
rect
=
element
.
getBoundingClientRect
(
)
;
return
!
!
(
rect
.
top
|
|
rect
.
bottom
|
|
rect
.
width
|
|
rect
.
height
)
;
}
}
}
}
class
WaitTask
{
constructor
(
domWorld
predicateBody
title
polling
timeout
.
.
.
args
)
{
if
(
helper
.
isString
(
polling
)
)
assert
(
polling
=
=
=
'
raf
'
|
|
polling
=
=
=
'
mutation
'
'
Unknown
polling
option
:
'
+
polling
)
;
else
if
(
helper
.
isNumber
(
polling
)
)
assert
(
polling
>
0
'
Cannot
poll
with
non
-
positive
interval
:
'
+
polling
)
;
else
throw
new
Error
(
'
Unknown
polling
options
:
'
+
polling
)
;
this
.
_domWorld
=
domWorld
;
this
.
_polling
=
polling
;
this
.
_timeout
=
timeout
;
this
.
_predicateBody
=
helper
.
isString
(
predicateBody
)
?
'
return
(
'
+
predicateBody
+
'
)
'
:
'
return
(
'
+
predicateBody
+
'
)
(
.
.
.
args
)
'
;
this
.
_args
=
args
;
this
.
_runCount
=
0
;
domWorld
.
_waitTasks
.
add
(
this
)
;
this
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_resolve
=
resolve
;
this
.
_reject
=
reject
;
}
)
;
if
(
timeout
)
{
const
timeoutError
=
new
TimeoutError
(
waiting
for
{
title
}
failed
:
timeout
{
timeout
}
ms
exceeded
)
;
this
.
_timeoutTimer
=
setTimeout
(
(
)
=
>
this
.
terminate
(
timeoutError
)
timeout
)
;
}
this
.
rerun
(
)
;
}
terminate
(
error
)
{
this
.
_terminated
=
true
;
this
.
_reject
(
error
)
;
this
.
_cleanup
(
)
;
}
async
rerun
(
)
{
const
runCount
=
+
+
this
.
_runCount
;
let
success
=
null
;
let
error
=
null
;
try
{
success
=
await
(
await
this
.
_domWorld
.
executionContext
(
)
)
.
evaluateHandle
(
waitForPredicatePageFunction
this
.
_predicateBody
this
.
_polling
this
.
_timeout
.
.
.
this
.
_args
)
;
}
catch
(
e
)
{
error
=
e
;
}
if
(
this
.
_terminated
|
|
runCount
!
=
=
this
.
_runCount
)
{
if
(
success
)
await
success
.
dispose
(
)
;
return
;
}
if
(
!
error
&
&
await
this
.
_domWorld
.
evaluate
(
s
=
>
!
s
success
)
.
catch
(
e
=
>
true
)
)
{
await
success
.
dispose
(
)
;
return
;
}
if
(
error
&
&
error
.
message
.
includes
(
'
Execution
context
was
destroyed
'
)
)
return
;
if
(
error
&
&
error
.
message
.
includes
(
'
Cannot
find
context
with
specified
id
'
)
)
return
;
if
(
error
)
this
.
_reject
(
error
)
;
else
this
.
_resolve
(
success
)
;
this
.
_cleanup
(
)
;
}
_cleanup
(
)
{
clearTimeout
(
this
.
_timeoutTimer
)
;
this
.
_domWorld
.
_waitTasks
.
delete
(
this
)
;
this
.
_runningTask
=
null
;
}
}
async
function
waitForPredicatePageFunction
(
predicateBody
polling
timeout
.
.
.
args
)
{
const
predicate
=
new
Function
(
'
.
.
.
args
'
predicateBody
)
;
let
timedOut
=
false
;
if
(
timeout
)
setTimeout
(
(
)
=
>
timedOut
=
true
timeout
)
;
if
(
polling
=
=
=
'
raf
'
)
return
await
pollRaf
(
)
;
if
(
polling
=
=
=
'
mutation
'
)
return
await
pollMutation
(
)
;
if
(
typeof
polling
=
=
=
'
number
'
)
return
await
pollInterval
(
polling
)
;
function
pollMutation
(
)
{
const
success
=
predicate
.
apply
(
null
args
)
;
if
(
success
)
return
Promise
.
resolve
(
success
)
;
let
fulfill
;
const
result
=
new
Promise
(
x
=
>
fulfill
=
x
)
;
const
observer
=
new
MutationObserver
(
mutations
=
>
{
if
(
timedOut
)
{
observer
.
disconnect
(
)
;
fulfill
(
)
;
}
const
success
=
predicate
.
apply
(
null
args
)
;
if
(
success
)
{
observer
.
disconnect
(
)
;
fulfill
(
success
)
;
}
}
)
;
observer
.
observe
(
document
{
childList
:
true
subtree
:
true
attributes
:
true
}
)
;
return
result
;
}
function
pollRaf
(
)
{
let
fulfill
;
const
result
=
new
Promise
(
x
=
>
fulfill
=
x
)
;
onRaf
(
)
;
return
result
;
function
onRaf
(
)
{
if
(
timedOut
)
{
fulfill
(
)
;
return
;
}
const
success
=
predicate
.
apply
(
null
args
)
;
if
(
success
)
fulfill
(
success
)
;
else
requestAnimationFrame
(
onRaf
)
;
}
}
function
pollInterval
(
pollInterval
)
{
let
fulfill
;
const
result
=
new
Promise
(
x
=
>
fulfill
=
x
)
;
onTimeout
(
)
;
return
result
;
function
onTimeout
(
)
{
if
(
timedOut
)
{
fulfill
(
)
;
return
;
}
const
success
=
predicate
.
apply
(
null
args
)
;
if
(
success
)
fulfill
(
success
)
;
else
setTimeout
(
onTimeout
pollInterval
)
;
}
}
}
module
.
exports
=
{
DOMWorld
}
;
