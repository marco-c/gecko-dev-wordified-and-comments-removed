const
{
TimeoutError
}
=
require
(
'
.
/
Errors
'
)
;
const
debugError
=
require
(
'
debug
'
)
(
puppeteer
:
error
)
;
class
Helper
{
static
evaluationString
(
fun
.
.
.
args
)
{
if
(
Helper
.
isString
(
fun
)
)
{
assert
(
args
.
length
=
=
=
0
'
Cannot
evaluate
a
string
with
arguments
'
)
;
return
(
fun
)
;
}
return
(
{
fun
}
)
(
{
args
.
map
(
serializeArgument
)
.
join
(
'
'
)
}
)
;
function
serializeArgument
(
arg
)
{
if
(
Object
.
is
(
arg
undefined
)
)
return
'
undefined
'
;
return
JSON
.
stringify
(
arg
)
;
}
}
static
getExceptionMessage
(
exceptionDetails
)
{
if
(
exceptionDetails
.
exception
)
return
exceptionDetails
.
exception
.
description
|
|
exceptionDetails
.
exception
.
value
;
let
message
=
exceptionDetails
.
text
;
if
(
exceptionDetails
.
stackTrace
)
{
for
(
const
callframe
of
exceptionDetails
.
stackTrace
.
callFrames
)
{
const
location
=
callframe
.
url
+
'
:
'
+
callframe
.
lineNumber
+
'
:
'
+
callframe
.
columnNumber
;
const
functionName
=
callframe
.
functionName
|
|
'
<
anonymous
>
'
;
message
+
=
\
n
at
{
functionName
}
(
{
location
}
)
;
}
}
return
message
;
}
static
valueFromRemoteObject
(
remoteObject
)
{
assert
(
!
remoteObject
.
objectId
'
Cannot
extract
value
when
objectId
is
given
'
)
;
if
(
remoteObject
.
unserializableValue
)
{
if
(
remoteObject
.
type
=
=
=
'
bigint
'
&
&
typeof
BigInt
!
=
=
'
undefined
'
)
return
BigInt
(
remoteObject
.
unserializableValue
.
replace
(
'
n
'
'
'
)
)
;
switch
(
remoteObject
.
unserializableValue
)
{
case
'
-
0
'
:
return
-
0
;
case
'
NaN
'
:
return
NaN
;
case
'
Infinity
'
:
return
Infinity
;
case
'
-
Infinity
'
:
return
-
Infinity
;
default
:
throw
new
Error
(
'
Unsupported
unserializable
value
:
'
+
remoteObject
.
unserializableValue
)
;
}
}
return
remoteObject
.
value
;
}
static
async
releaseObject
(
client
remoteObject
)
{
if
(
!
remoteObject
.
objectId
)
return
;
await
client
.
send
(
'
Runtime
.
releaseObject
'
{
objectId
:
remoteObject
.
objectId
}
)
.
catch
(
error
=
>
{
debugError
(
error
)
;
}
)
;
}
static
installAsyncStackHooks
(
classType
)
{
for
(
const
methodName
of
Reflect
.
ownKeys
(
classType
.
prototype
)
)
{
const
method
=
Reflect
.
get
(
classType
.
prototype
methodName
)
;
if
(
methodName
=
=
=
'
constructor
'
|
|
typeof
methodName
!
=
=
'
string
'
|
|
methodName
.
startsWith
(
'
_
'
)
|
|
typeof
method
!
=
=
'
function
'
|
|
method
.
constructor
.
name
!
=
=
'
AsyncFunction
'
)
continue
;
Reflect
.
set
(
classType
.
prototype
methodName
function
(
.
.
.
args
)
{
const
syncStack
=
new
Error
(
)
;
return
method
.
call
(
this
.
.
.
args
)
.
catch
(
e
=
>
{
const
stack
=
syncStack
.
stack
.
substring
(
syncStack
.
stack
.
indexOf
(
'
\
n
'
)
+
1
)
;
const
clientStack
=
stack
.
substring
(
stack
.
indexOf
(
'
\
n
'
)
)
;
if
(
e
instanceof
Error
&
&
e
.
stack
&
&
!
e
.
stack
.
includes
(
clientStack
)
)
e
.
stack
+
=
'
\
n
-
-
ASYNC
-
-
\
n
'
+
stack
;
throw
e
;
}
)
;
}
)
;
}
}
static
addEventListener
(
emitter
eventName
handler
)
{
emitter
.
on
(
eventName
handler
)
;
return
{
emitter
eventName
handler
}
;
}
static
removeEventListeners
(
listeners
)
{
for
(
const
listener
of
listeners
)
listener
.
emitter
.
removeListener
(
listener
.
eventName
listener
.
handler
)
;
listeners
.
splice
(
0
listeners
.
length
)
;
}
static
isString
(
obj
)
{
return
typeof
obj
=
=
=
'
string
'
|
|
obj
instanceof
String
;
}
static
isNumber
(
obj
)
{
return
typeof
obj
=
=
=
'
number
'
|
|
obj
instanceof
Number
;
}
static
promisify
(
nodeFunction
)
{
function
promisified
(
.
.
.
args
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
callback
(
err
.
.
.
result
)
{
if
(
err
)
return
reject
(
err
)
;
if
(
result
.
length
=
=
=
1
)
return
resolve
(
result
[
0
]
)
;
return
resolve
(
result
)
;
}
nodeFunction
.
call
(
null
.
.
.
args
callback
)
;
}
)
;
}
return
promisified
;
}
static
waitForEvent
(
emitter
eventName
predicate
timeout
)
{
let
eventTimeout
resolveCallback
rejectCallback
;
const
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
resolveCallback
=
resolve
;
rejectCallback
=
reject
;
}
)
;
const
listener
=
Helper
.
addEventListener
(
emitter
eventName
event
=
>
{
if
(
!
predicate
(
event
)
)
return
;
cleanup
(
)
;
resolveCallback
(
event
)
;
}
)
;
if
(
timeout
)
{
eventTimeout
=
setTimeout
(
(
)
=
>
{
cleanup
(
)
;
rejectCallback
(
new
TimeoutError
(
'
Timeout
exceeded
while
waiting
for
event
'
)
)
;
}
timeout
)
;
}
function
cleanup
(
)
{
Helper
.
removeEventListeners
(
[
listener
]
)
;
clearTimeout
(
eventTimeout
)
;
}
return
promise
;
}
static
async
waitWithTimeout
(
promise
taskName
timeout
)
{
let
reject
;
const
timeoutError
=
new
TimeoutError
(
waiting
for
{
taskName
}
failed
:
timeout
{
timeout
}
ms
exceeded
)
;
const
timeoutPromise
=
new
Promise
(
(
resolve
x
)
=
>
reject
=
x
)
;
const
timeoutTimer
=
setTimeout
(
(
)
=
>
reject
(
timeoutError
)
timeout
)
;
try
{
return
await
Promise
.
race
(
[
promise
timeoutPromise
]
)
;
}
finally
{
clearTimeout
(
timeoutTimer
)
;
}
}
}
function
assert
(
value
message
)
{
if
(
!
value
)
throw
new
Error
(
message
)
;
}
module
.
exports
=
{
helper
:
Helper
assert
debugError
}
;
