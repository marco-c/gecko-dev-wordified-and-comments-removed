const
EventEmitter
=
require
(
'
events
'
)
;
const
{
debugError
}
=
require
(
'
.
/
helper
'
)
;
const
{
ExecutionContext
}
=
require
(
'
.
/
ExecutionContext
'
)
;
const
{
JSHandle
}
=
require
(
'
.
/
JSHandle
'
)
;
class
Worker
extends
EventEmitter
{
constructor
(
client
url
consoleAPICalled
exceptionThrown
)
{
super
(
)
;
this
.
_client
=
client
;
this
.
_url
=
url
;
this
.
_executionContextPromise
=
new
Promise
(
x
=
>
this
.
_executionContextCallback
=
x
)
;
let
jsHandleFactory
;
this
.
_client
.
once
(
'
Runtime
.
executionContextCreated
'
async
event
=
>
{
jsHandleFactory
=
remoteObject
=
>
new
JSHandle
(
executionContext
client
remoteObject
)
;
const
executionContext
=
new
ExecutionContext
(
client
event
.
context
null
)
;
this
.
_executionContextCallback
(
executionContext
)
;
}
)
;
this
.
_client
.
send
(
'
Runtime
.
enable
'
{
}
)
.
catch
(
debugError
)
;
this
.
_client
.
on
(
'
Runtime
.
consoleAPICalled
'
event
=
>
consoleAPICalled
(
event
.
type
event
.
args
.
map
(
jsHandleFactory
)
event
.
stackTrace
)
)
;
this
.
_client
.
on
(
'
Runtime
.
exceptionThrown
'
exception
=
>
exceptionThrown
(
exception
.
exceptionDetails
)
)
;
}
url
(
)
{
return
this
.
_url
;
}
async
executionContext
(
)
{
return
this
.
_executionContextPromise
;
}
async
evaluate
(
pageFunction
.
.
.
args
)
{
return
(
await
this
.
_executionContextPromise
)
.
evaluate
(
pageFunction
.
.
.
args
)
;
}
async
evaluateHandle
(
pageFunction
.
.
.
args
)
{
return
(
await
this
.
_executionContextPromise
)
.
evaluateHandle
(
pageFunction
.
.
.
args
)
;
}
}
module
.
exports
=
{
Worker
}
;
