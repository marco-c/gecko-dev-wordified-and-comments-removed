const
{
helper
assert
}
=
require
(
'
.
/
helper
'
)
;
const
fs
=
require
(
'
fs
'
)
;
const
openAsync
=
helper
.
promisify
(
fs
.
open
)
;
const
writeAsync
=
helper
.
promisify
(
fs
.
write
)
;
const
closeAsync
=
helper
.
promisify
(
fs
.
close
)
;
class
Tracing
{
constructor
(
client
)
{
this
.
_client
=
client
;
this
.
_recording
=
false
;
this
.
_path
=
'
'
;
}
async
start
(
options
=
{
}
)
{
assert
(
!
this
.
_recording
'
Cannot
start
recording
trace
while
already
recording
trace
.
'
)
;
const
defaultCategories
=
[
'
-
*
'
'
devtools
.
timeline
'
'
v8
.
execute
'
'
disabled
-
by
-
default
-
devtools
.
timeline
'
'
disabled
-
by
-
default
-
devtools
.
timeline
.
frame
'
'
toplevel
'
'
blink
.
console
'
'
blink
.
user_timing
'
'
latencyInfo
'
'
disabled
-
by
-
default
-
devtools
.
timeline
.
stack
'
'
disabled
-
by
-
default
-
v8
.
cpu_profiler
'
'
disabled
-
by
-
default
-
v8
.
cpu_profiler
.
hires
'
]
;
const
{
path
=
null
screenshots
=
false
categories
=
defaultCategories
}
=
options
;
if
(
screenshots
)
categories
.
push
(
'
disabled
-
by
-
default
-
devtools
.
screenshot
'
)
;
this
.
_path
=
path
;
this
.
_recording
=
true
;
await
this
.
_client
.
send
(
'
Tracing
.
start
'
{
transferMode
:
'
ReturnAsStream
'
categories
:
categories
.
join
(
'
'
)
}
)
;
}
async
stop
(
)
{
let
fulfill
;
const
contentPromise
=
new
Promise
(
x
=
>
fulfill
=
x
)
;
this
.
_client
.
once
(
'
Tracing
.
tracingComplete
'
event
=
>
{
this
.
_readStream
(
event
.
stream
this
.
_path
)
.
then
(
fulfill
)
;
}
)
;
await
this
.
_client
.
send
(
'
Tracing
.
end
'
)
;
this
.
_recording
=
false
;
return
contentPromise
;
}
async
_readStream
(
handle
path
)
{
let
eof
=
false
;
let
file
;
if
(
path
)
file
=
await
openAsync
(
path
'
w
'
)
;
const
bufs
=
[
]
;
while
(
!
eof
)
{
const
response
=
await
this
.
_client
.
send
(
'
IO
.
read
'
{
handle
}
)
;
eof
=
response
.
eof
;
bufs
.
push
(
Buffer
.
from
(
response
.
data
)
)
;
if
(
path
)
await
writeAsync
(
file
response
.
data
)
;
}
if
(
path
)
await
closeAsync
(
file
)
;
await
this
.
_client
.
send
(
'
IO
.
close
'
{
handle
}
)
;
let
resultBuffer
=
null
;
try
{
resultBuffer
=
Buffer
.
concat
(
bufs
)
;
}
finally
{
return
resultBuffer
;
}
}
}
module
.
exports
=
Tracing
;
