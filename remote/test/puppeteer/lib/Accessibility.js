class
Accessibility
{
constructor
(
client
)
{
this
.
_client
=
client
;
}
async
snapshot
(
options
=
{
}
)
{
const
{
interestingOnly
=
true
root
=
null
}
=
options
;
const
{
nodes
}
=
await
this
.
_client
.
send
(
'
Accessibility
.
getFullAXTree
'
)
;
let
backendNodeId
=
null
;
if
(
root
)
{
const
{
node
}
=
await
this
.
_client
.
send
(
'
DOM
.
describeNode
'
{
objectId
:
root
.
_remoteObject
.
objectId
}
)
;
backendNodeId
=
node
.
backendNodeId
;
}
const
defaultRoot
=
AXNode
.
createTree
(
nodes
)
;
let
needle
=
defaultRoot
;
if
(
backendNodeId
)
{
needle
=
defaultRoot
.
find
(
node
=
>
node
.
_payload
.
backendDOMNodeId
=
=
=
backendNodeId
)
;
if
(
!
needle
)
return
null
;
}
if
(
!
interestingOnly
)
return
serializeTree
(
needle
)
[
0
]
;
const
interestingNodes
=
new
Set
(
)
;
collectInterestingNodes
(
interestingNodes
defaultRoot
false
)
;
if
(
!
interestingNodes
.
has
(
needle
)
)
return
null
;
return
serializeTree
(
needle
interestingNodes
)
[
0
]
;
}
}
function
collectInterestingNodes
(
collection
node
insideControl
)
{
if
(
node
.
isInteresting
(
insideControl
)
)
collection
.
add
(
node
)
;
if
(
node
.
isLeafNode
(
)
)
return
;
insideControl
=
insideControl
|
|
node
.
isControl
(
)
;
for
(
const
child
of
node
.
_children
)
collectInterestingNodes
(
collection
child
insideControl
)
;
}
function
serializeTree
(
node
whitelistedNodes
)
{
const
children
=
[
]
;
for
(
const
child
of
node
.
_children
)
children
.
push
(
.
.
.
serializeTree
(
child
whitelistedNodes
)
)
;
if
(
whitelistedNodes
&
&
!
whitelistedNodes
.
has
(
node
)
)
return
children
;
const
serializedNode
=
node
.
serialize
(
)
;
if
(
children
.
length
)
serializedNode
.
children
=
children
;
return
[
serializedNode
]
;
}
class
AXNode
{
constructor
(
payload
)
{
this
.
_payload
=
payload
;
this
.
_children
=
[
]
;
this
.
_richlyEditable
=
false
;
this
.
_editable
=
false
;
this
.
_focusable
=
false
;
this
.
_expanded
=
false
;
this
.
_hidden
=
false
;
this
.
_name
=
this
.
_payload
.
name
?
this
.
_payload
.
name
.
value
:
'
'
;
this
.
_role
=
this
.
_payload
.
role
?
this
.
_payload
.
role
.
value
:
'
Unknown
'
;
this
.
_cachedHasFocusableChild
;
for
(
const
property
of
this
.
_payload
.
properties
|
|
[
]
)
{
if
(
property
.
name
=
=
=
'
editable
'
)
{
this
.
_richlyEditable
=
property
.
value
.
value
=
=
=
'
richtext
'
;
this
.
_editable
=
true
;
}
if
(
property
.
name
=
=
=
'
focusable
'
)
this
.
_focusable
=
property
.
value
.
value
;
if
(
property
.
name
=
=
=
'
expanded
'
)
this
.
_expanded
=
property
.
value
.
value
;
if
(
property
.
name
=
=
=
'
hidden
'
)
this
.
_hidden
=
property
.
value
.
value
;
}
}
_isPlainTextField
(
)
{
if
(
this
.
_richlyEditable
)
return
false
;
if
(
this
.
_editable
)
return
true
;
return
this
.
_role
=
=
=
'
textbox
'
|
|
this
.
_role
=
=
=
'
ComboBox
'
|
|
this
.
_role
=
=
=
'
searchbox
'
;
}
_isTextOnlyObject
(
)
{
const
role
=
this
.
_role
;
return
(
role
=
=
=
'
LineBreak
'
|
|
role
=
=
=
'
text
'
|
|
role
=
=
=
'
InlineTextBox
'
)
;
}
_hasFocusableChild
(
)
{
if
(
this
.
_cachedHasFocusableChild
=
=
=
undefined
)
{
this
.
_cachedHasFocusableChild
=
false
;
for
(
const
child
of
this
.
_children
)
{
if
(
child
.
_focusable
|
|
child
.
_hasFocusableChild
(
)
)
{
this
.
_cachedHasFocusableChild
=
true
;
break
;
}
}
}
return
this
.
_cachedHasFocusableChild
;
}
find
(
predicate
)
{
if
(
predicate
(
this
)
)
return
this
;
for
(
const
child
of
this
.
_children
)
{
const
result
=
child
.
find
(
predicate
)
;
if
(
result
)
return
result
;
}
return
null
;
}
isLeafNode
(
)
{
if
(
!
this
.
_children
.
length
)
return
true
;
if
(
this
.
_isPlainTextField
(
)
|
|
this
.
_isTextOnlyObject
(
)
)
return
true
;
switch
(
this
.
_role
)
{
case
'
doc
-
cover
'
:
case
'
graphics
-
symbol
'
:
case
'
img
'
:
case
'
Meter
'
:
case
'
scrollbar
'
:
case
'
slider
'
:
case
'
separator
'
:
case
'
progressbar
'
:
return
true
;
default
:
break
;
}
if
(
this
.
_hasFocusableChild
(
)
)
return
false
;
if
(
this
.
_focusable
&
&
this
.
_name
)
return
true
;
if
(
this
.
_role
=
=
=
'
heading
'
&
&
this
.
_name
)
return
true
;
return
false
;
}
isControl
(
)
{
switch
(
this
.
_role
)
{
case
'
button
'
:
case
'
checkbox
'
:
case
'
ColorWell
'
:
case
'
combobox
'
:
case
'
DisclosureTriangle
'
:
case
'
listbox
'
:
case
'
menu
'
:
case
'
menubar
'
:
case
'
menuitem
'
:
case
'
menuitemcheckbox
'
:
case
'
menuitemradio
'
:
case
'
radio
'
:
case
'
scrollbar
'
:
case
'
searchbox
'
:
case
'
slider
'
:
case
'
spinbutton
'
:
case
'
switch
'
:
case
'
tab
'
:
case
'
textbox
'
:
case
'
tree
'
:
return
true
;
default
:
return
false
;
}
}
isInteresting
(
insideControl
)
{
const
role
=
this
.
_role
;
if
(
role
=
=
=
'
Ignored
'
|
|
this
.
_hidden
)
return
false
;
if
(
this
.
_focusable
|
|
this
.
_richlyEditable
)
return
true
;
if
(
this
.
isControl
(
)
)
return
true
;
if
(
insideControl
)
return
false
;
return
this
.
isLeafNode
(
)
&
&
!
!
this
.
_name
;
}
serialize
(
)
{
const
properties
=
new
Map
(
)
;
for
(
const
property
of
this
.
_payload
.
properties
|
|
[
]
)
properties
.
set
(
property
.
name
.
toLowerCase
(
)
property
.
value
.
value
)
;
if
(
this
.
_payload
.
name
)
properties
.
set
(
'
name
'
this
.
_payload
.
name
.
value
)
;
if
(
this
.
_payload
.
value
)
properties
.
set
(
'
value
'
this
.
_payload
.
value
.
value
)
;
if
(
this
.
_payload
.
description
)
properties
.
set
(
'
description
'
this
.
_payload
.
description
.
value
)
;
const
node
=
{
role
:
this
.
_role
}
;
const
userStringProperties
=
[
'
name
'
'
value
'
'
description
'
'
keyshortcuts
'
'
roledescription
'
'
valuetext
'
]
;
for
(
const
userStringProperty
of
userStringProperties
)
{
if
(
!
properties
.
has
(
userStringProperty
)
)
continue
;
node
[
userStringProperty
]
=
properties
.
get
(
userStringProperty
)
;
}
const
booleanProperties
=
[
'
disabled
'
'
expanded
'
'
focused
'
'
modal
'
'
multiline
'
'
multiselectable
'
'
readonly
'
'
required
'
'
selected
'
]
;
for
(
const
booleanProperty
of
booleanProperties
)
{
if
(
booleanProperty
=
=
=
'
focused
'
&
&
this
.
_role
=
=
=
'
WebArea
'
)
continue
;
const
value
=
properties
.
get
(
booleanProperty
)
;
if
(
!
value
)
continue
;
node
[
booleanProperty
]
=
value
;
}
const
tristateProperties
=
[
'
checked
'
'
pressed
'
]
;
for
(
const
tristateProperty
of
tristateProperties
)
{
if
(
!
properties
.
has
(
tristateProperty
)
)
continue
;
const
value
=
properties
.
get
(
tristateProperty
)
;
node
[
tristateProperty
]
=
value
=
=
=
'
mixed
'
?
'
mixed
'
:
value
=
=
=
'
true
'
?
true
:
false
;
}
const
numericalProperties
=
[
'
level
'
'
valuemax
'
'
valuemin
'
]
;
for
(
const
numericalProperty
of
numericalProperties
)
{
if
(
!
properties
.
has
(
numericalProperty
)
)
continue
;
node
[
numericalProperty
]
=
properties
.
get
(
numericalProperty
)
;
}
const
tokenProperties
=
[
'
autocomplete
'
'
haspopup
'
'
invalid
'
'
orientation
'
]
;
for
(
const
tokenProperty
of
tokenProperties
)
{
const
value
=
properties
.
get
(
tokenProperty
)
;
if
(
!
value
|
|
value
=
=
=
'
false
'
)
continue
;
node
[
tokenProperty
]
=
value
;
}
return
node
;
}
static
createTree
(
payloads
)
{
const
nodeById
=
new
Map
(
)
;
for
(
const
payload
of
payloads
)
nodeById
.
set
(
payload
.
nodeId
new
AXNode
(
payload
)
)
;
for
(
const
node
of
nodeById
.
values
(
)
)
{
for
(
const
childId
of
node
.
_payload
.
childIds
|
|
[
]
)
node
.
_children
.
push
(
nodeById
.
get
(
childId
)
)
;
}
return
nodeById
.
values
(
)
.
next
(
)
.
value
;
}
}
module
.
exports
=
{
Accessibility
}
;
