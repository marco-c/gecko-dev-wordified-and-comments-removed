const
os
=
require
(
'
os
'
)
;
const
fs
=
require
(
'
fs
'
)
;
const
path
=
require
(
'
path
'
)
;
const
util
=
require
(
'
util
'
)
;
const
extract
=
require
(
'
extract
-
zip
'
)
;
const
URL
=
require
(
'
url
'
)
;
const
{
helper
assert
}
=
require
(
'
.
/
helper
'
)
;
const
removeRecursive
=
require
(
'
rimraf
'
)
;
const
ProxyAgent
=
require
(
'
https
-
proxy
-
agent
'
)
;
const
getProxyForUrl
=
require
(
'
proxy
-
from
-
env
'
)
.
getProxyForUrl
;
const
DEFAULT_DOWNLOAD_HOST
=
'
https
:
/
/
storage
.
googleapis
.
com
'
;
const
supportedPlatforms
=
[
'
mac
'
'
linux
'
'
win32
'
'
win64
'
]
;
const
downloadURLs
=
{
linux
:
'
%
s
/
chromium
-
browser
-
snapshots
/
Linux_x64
/
%
d
/
%
s
.
zip
'
mac
:
'
%
s
/
chromium
-
browser
-
snapshots
/
Mac
/
%
d
/
%
s
.
zip
'
win32
:
'
%
s
/
chromium
-
browser
-
snapshots
/
Win
/
%
d
/
%
s
.
zip
'
win64
:
'
%
s
/
chromium
-
browser
-
snapshots
/
Win_x64
/
%
d
/
%
s
.
zip
'
}
;
function
archiveName
(
platform
revision
)
{
if
(
platform
=
=
=
'
linux
'
)
return
'
chrome
-
linux
'
;
if
(
platform
=
=
=
'
mac
'
)
return
'
chrome
-
mac
'
;
if
(
platform
=
=
=
'
win32
'
|
|
platform
=
=
=
'
win64
'
)
{
return
parseInt
(
revision
10
)
>
591479
?
'
chrome
-
win
'
:
'
chrome
-
win32
'
;
}
return
null
;
}
function
downloadURL
(
platform
host
revision
)
{
return
util
.
format
(
downloadURLs
[
platform
]
host
revision
archiveName
(
platform
revision
)
)
;
}
const
readdirAsync
=
helper
.
promisify
(
fs
.
readdir
.
bind
(
fs
)
)
;
const
mkdirAsync
=
helper
.
promisify
(
fs
.
mkdir
.
bind
(
fs
)
)
;
const
unlinkAsync
=
helper
.
promisify
(
fs
.
unlink
.
bind
(
fs
)
)
;
const
chmodAsync
=
helper
.
promisify
(
fs
.
chmod
.
bind
(
fs
)
)
;
function
existsAsync
(
filePath
)
{
let
fulfill
=
null
;
const
promise
=
new
Promise
(
x
=
>
fulfill
=
x
)
;
fs
.
access
(
filePath
err
=
>
fulfill
(
!
err
)
)
;
return
promise
;
}
class
BrowserFetcher
{
constructor
(
projectRoot
options
=
{
}
)
{
this
.
_downloadsFolder
=
options
.
path
|
|
path
.
join
(
projectRoot
'
.
local
-
chromium
'
)
;
this
.
_downloadHost
=
options
.
host
|
|
DEFAULT_DOWNLOAD_HOST
;
this
.
_platform
=
options
.
platform
|
|
'
'
;
if
(
!
this
.
_platform
)
{
const
platform
=
os
.
platform
(
)
;
if
(
platform
=
=
=
'
darwin
'
)
this
.
_platform
=
'
mac
'
;
else
if
(
platform
=
=
=
'
linux
'
)
this
.
_platform
=
'
linux
'
;
else
if
(
platform
=
=
=
'
win32
'
)
this
.
_platform
=
os
.
arch
(
)
=
=
=
'
x64
'
?
'
win64
'
:
'
win32
'
;
assert
(
this
.
_platform
'
Unsupported
platform
:
'
+
os
.
platform
(
)
)
;
}
assert
(
supportedPlatforms
.
includes
(
this
.
_platform
)
'
Unsupported
platform
:
'
+
this
.
_platform
)
;
}
platform
(
)
{
return
this
.
_platform
;
}
canDownload
(
revision
)
{
const
url
=
downloadURL
(
this
.
_platform
this
.
_downloadHost
revision
)
;
let
resolve
;
const
promise
=
new
Promise
(
x
=
>
resolve
=
x
)
;
const
request
=
httpRequest
(
url
'
HEAD
'
response
=
>
{
resolve
(
response
.
statusCode
=
=
=
200
)
;
}
)
;
request
.
on
(
'
error
'
error
=
>
{
console
.
error
(
error
)
;
resolve
(
false
)
;
}
)
;
return
promise
;
}
async
download
(
revision
progressCallback
)
{
const
url
=
downloadURL
(
this
.
_platform
this
.
_downloadHost
revision
)
;
const
zipPath
=
path
.
join
(
this
.
_downloadsFolder
download
-
{
this
.
_platform
}
-
{
revision
}
.
zip
)
;
const
folderPath
=
this
.
_getFolderPath
(
revision
)
;
if
(
await
existsAsync
(
folderPath
)
)
return
this
.
revisionInfo
(
revision
)
;
if
(
!
(
await
existsAsync
(
this
.
_downloadsFolder
)
)
)
await
mkdirAsync
(
this
.
_downloadsFolder
)
;
try
{
await
downloadFile
(
url
zipPath
progressCallback
)
;
await
extractZip
(
zipPath
folderPath
)
;
}
finally
{
if
(
await
existsAsync
(
zipPath
)
)
await
unlinkAsync
(
zipPath
)
;
}
const
revisionInfo
=
this
.
revisionInfo
(
revision
)
;
if
(
revisionInfo
)
await
chmodAsync
(
revisionInfo
.
executablePath
0o755
)
;
return
revisionInfo
;
}
async
localRevisions
(
)
{
if
(
!
await
existsAsync
(
this
.
_downloadsFolder
)
)
return
[
]
;
const
fileNames
=
await
readdirAsync
(
this
.
_downloadsFolder
)
;
return
fileNames
.
map
(
fileName
=
>
parseFolderPath
(
fileName
)
)
.
filter
(
entry
=
>
entry
&
&
entry
.
platform
=
=
=
this
.
_platform
)
.
map
(
entry
=
>
entry
.
revision
)
;
}
async
remove
(
revision
)
{
const
folderPath
=
this
.
_getFolderPath
(
revision
)
;
assert
(
await
existsAsync
(
folderPath
)
Failed
to
remove
:
revision
{
revision
}
is
not
downloaded
)
;
await
new
Promise
(
fulfill
=
>
removeRecursive
(
folderPath
fulfill
)
)
;
}
revisionInfo
(
revision
)
{
const
folderPath
=
this
.
_getFolderPath
(
revision
)
;
let
executablePath
=
'
'
;
if
(
this
.
_platform
=
=
=
'
mac
'
)
executablePath
=
path
.
join
(
folderPath
archiveName
(
this
.
_platform
revision
)
'
Chromium
.
app
'
'
Contents
'
'
MacOS
'
'
Chromium
'
)
;
else
if
(
this
.
_platform
=
=
=
'
linux
'
)
executablePath
=
path
.
join
(
folderPath
archiveName
(
this
.
_platform
revision
)
'
chrome
'
)
;
else
if
(
this
.
_platform
=
=
=
'
win32
'
|
|
this
.
_platform
=
=
=
'
win64
'
)
executablePath
=
path
.
join
(
folderPath
archiveName
(
this
.
_platform
revision
)
'
chrome
.
exe
'
)
;
else
throw
new
Error
(
'
Unsupported
platform
:
'
+
this
.
_platform
)
;
const
url
=
downloadURL
(
this
.
_platform
this
.
_downloadHost
revision
)
;
const
local
=
fs
.
existsSync
(
folderPath
)
;
return
{
revision
executablePath
folderPath
local
url
}
;
}
_getFolderPath
(
revision
)
{
return
path
.
join
(
this
.
_downloadsFolder
this
.
_platform
+
'
-
'
+
revision
)
;
}
}
module
.
exports
=
BrowserFetcher
;
function
parseFolderPath
(
folderPath
)
{
const
name
=
path
.
basename
(
folderPath
)
;
const
splits
=
name
.
split
(
'
-
'
)
;
if
(
splits
.
length
!
=
=
2
)
return
null
;
const
[
platform
revision
]
=
splits
;
if
(
!
supportedPlatforms
.
includes
(
platform
)
)
return
null
;
return
{
platform
revision
}
;
}
function
downloadFile
(
url
destinationPath
progressCallback
)
{
let
fulfill
reject
;
let
downloadedBytes
=
0
;
let
totalBytes
=
0
;
const
promise
=
new
Promise
(
(
x
y
)
=
>
{
fulfill
=
x
;
reject
=
y
;
}
)
;
const
request
=
httpRequest
(
url
'
GET
'
response
=
>
{
if
(
response
.
statusCode
!
=
=
200
)
{
const
error
=
new
Error
(
Download
failed
:
server
returned
code
{
response
.
statusCode
}
.
URL
:
{
url
}
)
;
response
.
resume
(
)
;
reject
(
error
)
;
return
;
}
const
file
=
fs
.
createWriteStream
(
destinationPath
)
;
file
.
on
(
'
finish
'
(
)
=
>
fulfill
(
)
)
;
file
.
on
(
'
error
'
error
=
>
reject
(
error
)
)
;
response
.
pipe
(
file
)
;
totalBytes
=
parseInt
(
(
response
.
headers
[
'
content
-
length
'
]
)
10
)
;
if
(
progressCallback
)
response
.
on
(
'
data
'
onData
)
;
}
)
;
request
.
on
(
'
error
'
error
=
>
reject
(
error
)
)
;
return
promise
;
function
onData
(
chunk
)
{
downloadedBytes
+
=
chunk
.
length
;
progressCallback
(
downloadedBytes
totalBytes
)
;
}
}
function
extractZip
(
zipPath
folderPath
)
{
return
new
Promise
(
(
fulfill
reject
)
=
>
extract
(
zipPath
{
dir
:
folderPath
}
err
=
>
{
if
(
err
)
reject
(
err
)
;
else
fulfill
(
)
;
}
)
)
;
}
function
httpRequest
(
url
method
response
)
{
let
options
=
URL
.
parse
(
url
)
;
options
.
method
=
method
;
const
proxyURL
=
getProxyForUrl
(
url
)
;
if
(
proxyURL
)
{
if
(
url
.
startsWith
(
'
http
:
'
)
)
{
const
proxy
=
URL
.
parse
(
proxyURL
)
;
options
=
{
path
:
options
.
href
host
:
proxy
.
hostname
port
:
proxy
.
port
}
;
}
else
{
const
parsedProxyURL
=
URL
.
parse
(
proxyURL
)
;
parsedProxyURL
.
secureProxy
=
parsedProxyURL
.
protocol
=
=
=
'
https
:
'
;
options
.
agent
=
new
ProxyAgent
(
parsedProxyURL
)
;
options
.
rejectUnauthorized
=
false
;
}
}
const
requestCallback
=
res
=
>
{
if
(
res
.
statusCode
>
=
300
&
&
res
.
statusCode
<
400
&
&
res
.
headers
.
location
)
httpRequest
(
res
.
headers
.
location
method
response
)
;
else
response
(
res
)
;
}
;
const
request
=
options
.
protocol
=
=
=
'
https
:
'
?
require
(
'
https
'
)
.
request
(
options
requestCallback
)
:
require
(
'
http
'
)
.
request
(
options
requestCallback
)
;
request
.
end
(
)
;
return
request
;
}
