const
{
helper
assert
}
=
require
(
'
.
/
helper
'
)
;
const
{
Events
}
=
require
(
'
.
/
Events
'
)
;
const
{
TimeoutError
}
=
require
(
'
.
/
Errors
'
)
;
class
LifecycleWatcher
{
constructor
(
frameManager
frame
waitUntil
timeout
)
{
if
(
Array
.
isArray
(
waitUntil
)
)
waitUntil
=
waitUntil
.
slice
(
)
;
else
if
(
typeof
waitUntil
=
=
=
'
string
'
)
waitUntil
=
[
waitUntil
]
;
this
.
_expectedLifecycle
=
waitUntil
.
map
(
value
=
>
{
const
protocolEvent
=
puppeteerToProtocolLifecycle
.
get
(
value
)
;
assert
(
protocolEvent
'
Unknown
value
for
options
.
waitUntil
:
'
+
value
)
;
return
protocolEvent
;
}
)
;
this
.
_frameManager
=
frameManager
;
this
.
_frame
=
frame
;
this
.
_initialLoaderId
=
frame
.
_loaderId
;
this
.
_timeout
=
timeout
;
this
.
_navigationRequest
=
null
;
this
.
_eventListeners
=
[
helper
.
addEventListener
(
frameManager
.
_client
Events
.
CDPSession
.
Disconnected
(
)
=
>
this
.
_terminate
(
new
Error
(
'
Navigation
failed
because
browser
has
disconnected
!
'
)
)
)
helper
.
addEventListener
(
this
.
_frameManager
Events
.
FrameManager
.
LifecycleEvent
this
.
_checkLifecycleComplete
.
bind
(
this
)
)
helper
.
addEventListener
(
this
.
_frameManager
Events
.
FrameManager
.
FrameNavigatedWithinDocument
this
.
_navigatedWithinDocument
.
bind
(
this
)
)
helper
.
addEventListener
(
this
.
_frameManager
Events
.
FrameManager
.
FrameDetached
this
.
_onFrameDetached
.
bind
(
this
)
)
helper
.
addEventListener
(
this
.
_frameManager
.
networkManager
(
)
Events
.
NetworkManager
.
Request
this
.
_onRequest
.
bind
(
this
)
)
]
;
this
.
_sameDocumentNavigationPromise
=
new
Promise
(
fulfill
=
>
{
this
.
_sameDocumentNavigationCompleteCallback
=
fulfill
;
}
)
;
this
.
_lifecyclePromise
=
new
Promise
(
fulfill
=
>
{
this
.
_lifecycleCallback
=
fulfill
;
}
)
;
this
.
_newDocumentNavigationPromise
=
new
Promise
(
fulfill
=
>
{
this
.
_newDocumentNavigationCompleteCallback
=
fulfill
;
}
)
;
this
.
_timeoutPromise
=
this
.
_createTimeoutPromise
(
)
;
this
.
_terminationPromise
=
new
Promise
(
fulfill
=
>
{
this
.
_terminationCallback
=
fulfill
;
}
)
;
this
.
_checkLifecycleComplete
(
)
;
}
_onRequest
(
request
)
{
if
(
request
.
frame
(
)
!
=
=
this
.
_frame
|
|
!
request
.
isNavigationRequest
(
)
)
return
;
this
.
_navigationRequest
=
request
;
}
_onFrameDetached
(
frame
)
{
if
(
this
.
_frame
=
=
=
frame
)
{
this
.
_terminationCallback
.
call
(
null
new
Error
(
'
Navigating
frame
was
detached
'
)
)
;
return
;
}
this
.
_checkLifecycleComplete
(
)
;
}
navigationResponse
(
)
{
return
this
.
_navigationRequest
?
this
.
_navigationRequest
.
response
(
)
:
null
;
}
_terminate
(
error
)
{
this
.
_terminationCallback
.
call
(
null
error
)
;
}
sameDocumentNavigationPromise
(
)
{
return
this
.
_sameDocumentNavigationPromise
;
}
newDocumentNavigationPromise
(
)
{
return
this
.
_newDocumentNavigationPromise
;
}
lifecyclePromise
(
)
{
return
this
.
_lifecyclePromise
;
}
timeoutOrTerminationPromise
(
)
{
return
Promise
.
race
(
[
this
.
_timeoutPromise
this
.
_terminationPromise
]
)
;
}
_createTimeoutPromise
(
)
{
if
(
!
this
.
_timeout
)
return
new
Promise
(
(
)
=
>
{
}
)
;
const
errorMessage
=
'
Navigation
timeout
of
'
+
this
.
_timeout
+
'
ms
exceeded
'
;
return
new
Promise
(
fulfill
=
>
this
.
_maximumTimer
=
setTimeout
(
fulfill
this
.
_timeout
)
)
.
then
(
(
)
=
>
new
TimeoutError
(
errorMessage
)
)
;
}
_navigatedWithinDocument
(
frame
)
{
if
(
frame
!
=
=
this
.
_frame
)
return
;
this
.
_hasSameDocumentNavigation
=
true
;
this
.
_checkLifecycleComplete
(
)
;
}
_checkLifecycleComplete
(
)
{
if
(
!
checkLifecycle
(
this
.
_frame
this
.
_expectedLifecycle
)
)
return
;
this
.
_lifecycleCallback
(
)
;
if
(
this
.
_frame
.
_loaderId
=
=
=
this
.
_initialLoaderId
&
&
!
this
.
_hasSameDocumentNavigation
)
return
;
if
(
this
.
_hasSameDocumentNavigation
)
this
.
_sameDocumentNavigationCompleteCallback
(
)
;
if
(
this
.
_frame
.
_loaderId
!
=
=
this
.
_initialLoaderId
)
this
.
_newDocumentNavigationCompleteCallback
(
)
;
function
checkLifecycle
(
frame
expectedLifecycle
)
{
for
(
const
event
of
expectedLifecycle
)
{
if
(
!
frame
.
_lifecycleEvents
.
has
(
event
)
)
return
false
;
}
for
(
const
child
of
frame
.
childFrames
(
)
)
{
if
(
!
checkLifecycle
(
child
expectedLifecycle
)
)
return
false
;
}
return
true
;
}
}
dispose
(
)
{
helper
.
removeEventListeners
(
this
.
_eventListeners
)
;
clearTimeout
(
this
.
_maximumTimer
)
;
}
}
const
puppeteerToProtocolLifecycle
=
new
Map
(
[
[
'
load
'
'
load
'
]
[
'
domcontentloaded
'
'
DOMContentLoaded
'
]
[
'
networkidle0
'
'
networkIdle
'
]
[
'
networkidle2
'
'
networkAlmostIdle
'
]
]
)
;
module
.
exports
=
{
LifecycleWatcher
}
;
