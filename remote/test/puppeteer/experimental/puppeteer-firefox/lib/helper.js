const
{
TimeoutError
}
=
require
(
'
.
/
Errors
'
)
;
class
Helper
{
static
installAsyncStackHooks
(
classType
)
{
for
(
const
methodName
of
Reflect
.
ownKeys
(
classType
.
prototype
)
)
{
const
method
=
Reflect
.
get
(
classType
.
prototype
methodName
)
;
if
(
methodName
=
=
=
'
constructor
'
|
|
typeof
methodName
!
=
=
'
string
'
|
|
methodName
.
startsWith
(
'
_
'
)
|
|
typeof
method
!
=
=
'
function
'
|
|
method
.
constructor
.
name
!
=
=
'
AsyncFunction
'
)
continue
;
Reflect
.
set
(
classType
.
prototype
methodName
function
(
.
.
.
args
)
{
const
syncStack
=
{
}
;
Error
.
captureStackTrace
(
syncStack
)
;
return
method
.
call
(
this
.
.
.
args
)
.
catch
(
e
=
>
{
const
stack
=
syncStack
.
stack
.
substring
(
syncStack
.
stack
.
indexOf
(
'
\
n
'
)
+
1
)
;
const
clientStack
=
stack
.
substring
(
stack
.
indexOf
(
'
\
n
'
)
)
;
if
(
e
instanceof
Error
&
&
e
.
stack
&
&
!
e
.
stack
.
includes
(
clientStack
)
)
e
.
stack
+
=
'
\
n
-
-
ASYNC
-
-
\
n
'
+
stack
;
throw
e
;
}
)
;
}
)
;
}
}
static
evaluationString
(
fun
.
.
.
args
)
{
if
(
Helper
.
isString
(
fun
)
)
{
if
(
args
.
length
!
=
=
0
)
throw
new
Error
(
'
Cannot
evaluate
a
string
with
arguments
'
)
;
return
(
fun
)
;
}
return
(
{
fun
}
)
(
{
args
.
map
(
serializeArgument
)
.
join
(
'
'
)
}
)
;
function
serializeArgument
(
arg
)
{
if
(
Object
.
is
(
arg
undefined
)
)
return
'
undefined
'
;
return
JSON
.
stringify
(
arg
)
;
}
}
static
promisify
(
nodeFunction
)
{
function
promisified
(
.
.
.
args
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
callback
(
err
.
.
.
result
)
{
if
(
err
)
return
reject
(
err
)
;
if
(
result
.
length
=
=
=
1
)
return
resolve
(
result
[
0
]
)
;
return
resolve
(
result
)
;
}
nodeFunction
.
call
(
null
.
.
.
args
callback
)
;
}
)
;
}
return
promisified
;
}
static
isNumber
(
obj
)
{
return
typeof
obj
=
=
=
'
number
'
|
|
obj
instanceof
Number
;
}
static
isString
(
obj
)
{
return
typeof
obj
=
=
=
'
string
'
|
|
obj
instanceof
String
;
}
static
addEventListener
(
emitter
eventName
handler
)
{
emitter
.
on
(
eventName
handler
)
;
return
{
emitter
eventName
handler
}
;
}
static
removeEventListeners
(
listeners
)
{
for
(
const
listener
of
listeners
)
listener
.
emitter
.
removeListener
(
listener
.
eventName
listener
.
handler
)
;
listeners
.
splice
(
0
listeners
.
length
)
;
}
static
async
waitForEvent
(
emitter
eventName
predicate
timeout
abortPromise
)
{
let
eventTimeout
resolveCallback
rejectCallback
;
const
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
resolveCallback
=
resolve
;
rejectCallback
=
reject
;
}
)
;
const
listener
=
Helper
.
addEventListener
(
emitter
eventName
event
=
>
{
if
(
!
predicate
(
event
)
)
return
;
resolveCallback
(
event
)
;
}
)
;
if
(
timeout
)
{
eventTimeout
=
setTimeout
(
(
)
=
>
{
rejectCallback
(
new
TimeoutError
(
'
Timeout
exceeded
while
waiting
for
event
'
)
)
;
}
timeout
)
;
}
function
cleanup
(
)
{
Helper
.
removeEventListeners
(
[
listener
]
)
;
clearTimeout
(
eventTimeout
)
;
}
const
result
=
await
Promise
.
race
(
[
promise
abortPromise
]
)
.
then
(
r
=
>
{
cleanup
(
)
;
return
r
;
}
e
=
>
{
cleanup
(
)
;
throw
e
;
}
)
;
if
(
result
instanceof
Error
)
throw
result
;
return
result
;
}
static
async
waitWithTimeout
(
promise
taskName
timeout
)
{
let
reject
;
const
timeoutError
=
new
TimeoutError
(
waiting
for
{
taskName
}
failed
:
timeout
{
timeout
}
ms
exceeded
)
;
const
timeoutPromise
=
new
Promise
(
(
resolve
x
)
=
>
reject
=
x
)
;
const
timeoutTimer
=
setTimeout
(
(
)
=
>
reject
(
timeoutError
)
timeout
)
;
try
{
return
await
Promise
.
race
(
[
promise
timeoutPromise
]
)
;
}
finally
{
clearTimeout
(
timeoutTimer
)
;
}
}
}
function
assert
(
condition
errorText
)
{
if
(
!
condition
)
throw
new
Error
(
errorText
)
;
}
module
.
exports
=
{
helper
:
Helper
debugError
:
require
(
'
debug
'
)
(
puppeteer
:
error
)
assert
}
;
