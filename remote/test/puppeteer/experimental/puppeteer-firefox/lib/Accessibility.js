class
Accessibility
{
constructor
(
session
)
{
this
.
_session
=
session
;
}
async
snapshot
(
options
=
{
}
)
{
const
{
interestingOnly
=
true
}
=
options
;
const
{
tree
}
=
await
this
.
_session
.
send
(
'
Accessibility
.
getFullAXTree
'
)
;
const
root
=
new
AXNode
(
tree
)
;
if
(
!
interestingOnly
)
return
serializeTree
(
root
)
[
0
]
;
const
interestingNodes
=
new
Set
(
)
;
collectInterestingNodes
(
interestingNodes
root
false
)
;
return
serializeTree
(
root
interestingNodes
)
[
0
]
;
}
}
function
collectInterestingNodes
(
collection
node
insideControl
)
{
if
(
node
.
isInteresting
(
insideControl
)
)
collection
.
add
(
node
)
;
if
(
node
.
isLeafNode
(
)
)
return
;
insideControl
=
insideControl
|
|
node
.
isControl
(
)
;
for
(
const
child
of
node
.
_children
)
collectInterestingNodes
(
collection
child
insideControl
)
;
}
function
serializeTree
(
node
whitelistedNodes
)
{
const
children
=
[
]
;
for
(
const
child
of
node
.
_children
)
children
.
push
(
.
.
.
serializeTree
(
child
whitelistedNodes
)
)
;
if
(
whitelistedNodes
&
&
!
whitelistedNodes
.
has
(
node
)
)
return
children
;
const
serializedNode
=
node
.
serialize
(
)
;
if
(
children
.
length
)
serializedNode
.
children
=
children
;
return
[
serializedNode
]
;
}
class
AXNode
{
constructor
(
payload
)
{
this
.
_payload
=
payload
;
this
.
_children
=
(
payload
.
children
|
|
[
]
)
.
map
(
x
=
>
new
AXNode
(
x
)
)
;
this
.
_editable
=
payload
.
editable
;
this
.
_richlyEditable
=
this
.
_editable
&
&
(
payload
.
tag
!
=
=
'
textarea
'
&
&
payload
.
tag
!
=
=
'
input
'
)
;
this
.
_focusable
=
payload
.
focusable
;
this
.
_expanded
=
payload
.
expanded
;
this
.
_name
=
this
.
_payload
.
name
;
this
.
_role
=
this
.
_payload
.
role
;
this
.
_cachedHasFocusableChild
;
}
_isPlainTextField
(
)
{
if
(
this
.
_richlyEditable
)
return
false
;
if
(
this
.
_editable
)
return
true
;
return
this
.
_role
=
=
=
'
entry
'
;
}
_isTextOnlyObject
(
)
{
const
role
=
this
.
_role
;
return
(
role
=
=
=
'
text
leaf
'
|
|
role
=
=
=
'
text
'
|
|
role
=
=
=
'
statictext
'
)
;
}
_hasFocusableChild
(
)
{
if
(
this
.
_cachedHasFocusableChild
=
=
=
undefined
)
{
this
.
_cachedHasFocusableChild
=
false
;
for
(
const
child
of
this
.
_children
)
{
if
(
child
.
_focusable
|
|
child
.
_hasFocusableChild
(
)
)
{
this
.
_cachedHasFocusableChild
=
true
;
break
;
}
}
}
return
this
.
_cachedHasFocusableChild
;
}
isLeafNode
(
)
{
if
(
!
this
.
_children
.
length
)
return
true
;
if
(
this
.
_isPlainTextField
(
)
|
|
this
.
_isTextOnlyObject
(
)
)
return
true
;
switch
(
this
.
_role
)
{
case
'
graphic
'
:
case
'
scrollbar
'
:
case
'
slider
'
:
case
'
separator
'
:
case
'
progressbar
'
:
return
true
;
default
:
break
;
}
if
(
this
.
_hasFocusableChild
(
)
)
return
false
;
if
(
this
.
_focusable
&
&
this
.
_name
)
return
true
;
if
(
this
.
_role
=
=
=
'
heading
'
&
&
this
.
_name
)
return
true
;
return
false
;
}
isControl
(
)
{
switch
(
this
.
_role
)
{
case
'
checkbutton
'
:
case
'
check
menu
item
'
:
case
'
check
rich
option
'
:
case
'
combobox
'
:
case
'
combobox
option
'
:
case
'
color
chooser
'
:
case
'
listbox
'
:
case
'
listbox
option
'
:
case
'
listbox
rich
option
'
:
case
'
popup
menu
'
:
case
'
menupopup
'
:
case
'
menuitem
'
:
case
'
menubar
'
:
case
'
button
'
:
case
'
pushbutton
'
:
case
'
radiobutton
'
:
case
'
radio
menuitem
'
:
case
'
scrollbar
'
:
case
'
slider
'
:
case
'
spinbutton
'
:
case
'
switch
'
:
case
'
pagetab
'
:
case
'
entry
'
:
case
'
tree
table
'
:
return
true
;
default
:
return
false
;
}
}
isInteresting
(
insideControl
)
{
if
(
this
.
_focusable
|
|
this
.
_richlyEditable
)
return
true
;
if
(
this
.
isControl
(
)
)
return
true
;
if
(
insideControl
)
return
false
;
return
this
.
isLeafNode
(
)
&
&
!
!
this
.
_name
.
trim
(
)
;
}
serialize
(
)
{
const
node
=
{
role
:
this
.
_role
}
;
const
userStringProperties
=
[
'
name
'
'
value
'
'
description
'
'
roledescription
'
'
valuetext
'
'
keyshortcuts
'
]
;
for
(
const
userStringProperty
of
userStringProperties
)
{
if
(
!
(
userStringProperty
in
this
.
_payload
)
)
continue
;
node
[
userStringProperty
]
=
this
.
_payload
[
userStringProperty
]
;
}
const
booleanProperties
=
[
'
disabled
'
'
expanded
'
'
focused
'
'
modal
'
'
multiline
'
'
multiselectable
'
'
readonly
'
'
required
'
'
selected
'
]
;
for
(
const
booleanProperty
of
booleanProperties
)
{
if
(
this
.
_role
=
=
=
'
document
'
&
&
booleanProperty
=
=
=
'
focused
'
)
continue
;
const
value
=
this
.
_payload
[
booleanProperty
]
;
if
(
!
value
)
continue
;
node
[
booleanProperty
]
=
value
;
}
const
tristateProperties
=
[
'
checked
'
'
pressed
'
]
;
for
(
const
tristateProperty
of
tristateProperties
)
{
if
(
!
(
tristateProperty
in
this
.
_payload
)
)
continue
;
const
value
=
this
.
_payload
[
tristateProperty
]
;
node
[
tristateProperty
]
=
value
;
}
const
numericalProperties
=
[
'
level
'
'
valuemax
'
'
valuemin
'
]
;
for
(
const
numericalProperty
of
numericalProperties
)
{
if
(
!
(
numericalProperty
in
this
.
_payload
)
)
continue
;
node
[
numericalProperty
]
=
this
.
_payload
[
numericalProperty
]
;
}
const
tokenProperties
=
[
'
autocomplete
'
'
haspopup
'
'
invalid
'
'
orientation
'
]
;
for
(
const
tokenProperty
of
tokenProperties
)
{
const
value
=
this
.
_payload
[
tokenProperty
]
;
if
(
!
value
|
|
value
=
=
=
'
false
'
)
continue
;
node
[
tokenProperty
]
=
value
;
}
return
node
;
}
}
module
.
exports
=
{
Accessibility
}
;
