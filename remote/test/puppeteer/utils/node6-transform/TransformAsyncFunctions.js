const
esprima
=
require
(
'
esprima
'
)
;
const
ESTreeWalker
=
require
(
'
.
.
/
ESTreeWalker
'
)
;
const
asyncToGenerator
=
fn
=
>
{
const
gen
=
fn
.
call
(
this
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
step
(
key
arg
)
{
let
info
value
;
try
{
info
=
gen
[
key
]
(
arg
)
;
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
value
=
>
{
step
(
'
next
'
value
)
;
}
err
=
>
{
step
(
'
throw
'
err
)
;
}
)
;
}
}
return
step
(
'
next
'
)
;
}
)
;
}
;
function
transformAsyncFunctions
(
text
)
{
const
edits
=
[
]
;
const
ast
=
esprima
.
parseScript
(
text
{
range
:
true
tolerant
:
true
}
)
;
const
walker
=
new
ESTreeWalker
(
node
=
>
{
if
(
node
.
type
=
=
=
'
FunctionExpression
'
|
|
node
.
type
=
=
=
'
FunctionDeclaration
'
|
|
node
.
type
=
=
=
'
ArrowFunctionExpression
'
)
onBeforeFunction
(
node
)
;
else
if
(
node
.
type
=
=
=
'
AwaitExpression
'
)
onBeforeAwait
(
node
)
;
}
node
=
>
{
if
(
node
.
type
=
=
=
'
FunctionExpression
'
|
|
node
.
type
=
=
=
'
FunctionDeclaration
'
|
|
node
.
type
=
=
=
'
ArrowFunctionExpression
'
)
onAfterFunction
(
node
)
;
else
if
(
node
.
type
=
=
=
'
AwaitExpression
'
)
onAfterAwait
(
node
)
;
}
)
;
walker
.
walk
(
ast
)
;
edits
.
reverse
(
)
;
for
(
const
{
replacement
from
to
}
of
edits
)
text
=
text
.
substring
(
0
from
)
+
replacement
+
text
.
substring
(
to
)
;
return
text
;
function
onBeforeFunction
(
node
)
{
if
(
!
node
.
async
)
return
;
let
range
;
if
(
node
.
parent
.
type
=
=
=
'
MethodDefinition
'
)
range
=
node
.
parent
.
range
;
else
range
=
node
.
range
;
const
index
=
text
.
substring
(
range
[
0
]
range
[
1
]
)
.
indexOf
(
'
async
'
)
+
range
[
0
]
;
insertText
(
index
index
+
'
async
'
.
length
'
/
*
async
*
/
'
)
;
let
before
=
{
return
(
{
asyncToGenerator
.
toString
(
)
}
)
(
function
*
(
)
;
if
(
node
.
body
.
type
!
=
=
'
BlockStatement
'
)
{
before
+
=
{
return
;
const
beforeBody
=
text
.
substring
(
node
.
range
[
0
]
node
.
body
.
range
[
0
]
)
;
if
(
/
\
(
\
s
*
/
.
test
(
beforeBody
)
)
{
const
openParen
=
node
.
range
[
0
]
+
beforeBody
.
lastIndexOf
(
'
(
'
)
;
insertText
(
openParen
openParen
+
1
'
'
)
;
}
}
insertText
(
node
.
body
.
range
[
0
]
node
.
body
.
range
[
0
]
before
)
;
}
function
onAfterFunction
(
node
)
{
if
(
!
node
.
async
)
return
;
let
after
=
)
;
}
;
if
(
node
.
body
.
type
!
=
=
'
BlockStatement
'
)
after
=
;
}
+
after
;
insertText
(
node
.
body
.
range
[
1
]
node
.
body
.
range
[
1
]
after
)
;
if
(
node
.
body
.
type
!
=
=
'
BlockStatement
'
)
{
const
beforeBody
=
text
.
substring
(
node
.
range
[
0
]
node
.
body
.
range
[
0
]
)
;
if
(
/
\
(
\
s
*
/
.
test
(
beforeBody
)
)
{
const
afterBody
=
text
.
substring
(
node
.
body
.
range
[
1
]
node
.
range
[
1
]
)
;
const
closeParen
=
node
.
body
.
range
[
1
]
+
afterBody
.
indexOf
(
'
)
'
)
;
insertText
(
closeParen
closeParen
+
1
'
'
)
;
}
}
}
function
onBeforeAwait
(
node
)
{
const
index
=
text
.
substring
(
node
.
range
[
0
]
node
.
range
[
1
]
)
.
indexOf
(
'
await
'
)
+
node
.
range
[
0
]
;
insertText
(
index
index
+
'
await
'
.
length
'
(
yield
'
)
;
}
function
onAfterAwait
(
node
)
{
insertText
(
node
.
range
[
1
]
node
.
range
[
1
]
'
)
'
)
;
}
function
insertText
(
from
to
replacement
)
{
edits
.
push
(
{
from
to
replacement
}
)
;
}
}
module
.
exports
=
transformAsyncFunctions
;
