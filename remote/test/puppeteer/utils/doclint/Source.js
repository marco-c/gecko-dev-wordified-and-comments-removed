const
path
=
require
(
'
path
'
)
;
const
fs
=
require
(
'
fs
'
)
;
const
readFileAsync
=
promisify
(
fs
.
readFile
)
;
const
readdirAsync
=
promisify
(
fs
.
readdir
)
;
const
writeFileAsync
=
promisify
(
fs
.
writeFile
)
;
const
PROJECT_DIR
=
path
.
join
(
__dirname
'
.
.
'
'
.
.
'
)
;
class
Source
{
constructor
(
filePath
text
)
{
this
.
_filePath
=
filePath
;
this
.
_projectPath
=
path
.
relative
(
PROJECT_DIR
filePath
)
;
this
.
_name
=
path
.
basename
(
filePath
)
;
this
.
_text
=
text
;
this
.
_hasUpdatedText
=
false
;
}
filePath
(
)
{
return
this
.
_filePath
;
}
projectPath
(
)
{
return
this
.
_projectPath
;
}
name
(
)
{
return
this
.
_name
;
}
setText
(
text
)
{
if
(
text
=
=
=
this
.
_text
)
return
false
;
this
.
_hasUpdatedText
=
true
;
this
.
_text
=
text
;
return
true
;
}
text
(
)
{
return
this
.
_text
;
}
hasUpdatedText
(
)
{
return
this
.
_hasUpdatedText
;
}
async
save
(
)
{
await
writeFileAsync
(
this
.
filePath
(
)
this
.
text
(
)
)
;
}
static
async
readFile
(
filePath
)
{
filePath
=
path
.
resolve
(
filePath
)
;
const
text
=
await
readFileAsync
(
filePath
{
encoding
:
'
utf8
'
}
)
;
return
new
Source
(
filePath
text
)
;
}
static
async
readdir
(
dirPath
extension
=
'
'
)
{
const
fileNames
=
await
readdirAsync
(
dirPath
)
;
const
filePaths
=
fileNames
.
filter
(
fileName
=
>
fileName
.
endsWith
(
extension
)
)
.
map
(
fileName
=
>
path
.
join
(
dirPath
fileName
)
)
;
return
Promise
.
all
(
filePaths
.
map
(
filePath
=
>
Source
.
readFile
(
filePath
)
)
)
;
}
}
module
.
exports
=
Source
;
function
promisify
(
nodeFunction
)
{
return
function
(
.
.
.
options
)
{
return
new
Promise
(
function
(
fulfill
reject
)
{
options
.
push
(
callback
)
;
nodeFunction
.
call
(
null
.
.
.
options
)
;
function
callback
(
err
result
)
{
if
(
err
)
reject
(
err
)
;
else
fulfill
(
result
)
;
}
}
)
;
}
;
}
