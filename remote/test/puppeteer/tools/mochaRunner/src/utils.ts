import
fs
from
'
fs
'
;
import
path
from
'
path
'
;
import
{
MochaTestResult
TestExpectation
MochaResults
TestResult
}
from
'
.
/
types
.
js
'
;
export
function
extendProcessEnv
(
envs
:
object
[
]
)
:
NodeJS
.
ProcessEnv
{
return
envs
.
reduce
(
(
acc
:
object
item
:
object
)
=
>
{
Object
.
assign
(
acc
item
)
;
return
acc
;
}
{
.
.
.
process
.
env
}
)
as
NodeJS
.
ProcessEnv
;
}
export
function
getFilename
(
file
:
string
)
:
string
{
return
path
.
basename
(
file
)
.
replace
(
path
.
extname
(
file
)
'
'
)
;
}
export
function
readJSON
(
path
:
string
)
:
unknown
{
return
JSON
.
parse
(
fs
.
readFileSync
(
path
'
utf
-
8
'
)
)
;
}
export
function
writeJSON
(
path
:
string
json
:
unknown
)
:
unknown
{
return
fs
.
writeFileSync
(
path
JSON
.
stringify
(
json
null
2
)
)
;
}
export
function
filterByPlatform
<
T
extends
{
platforms
:
NodeJS
.
Platform
[
]
}
>
(
items
:
T
[
]
platform
:
NodeJS
.
Platform
)
:
T
[
]
{
return
items
.
filter
(
item
=
>
{
return
item
.
platforms
.
includes
(
platform
)
;
}
)
;
}
export
function
prettyPrintJSON
(
json
:
unknown
)
:
void
{
console
.
log
(
JSON
.
stringify
(
json
null
2
)
)
;
}
export
function
printSuggestions
(
recommendations
:
RecommendedExpectation
[
]
action
:
RecommendedExpectation
[
'
action
'
]
message
:
string
)
:
void
{
const
toPrint
=
recommendations
.
filter
(
item
=
>
{
return
item
.
action
=
=
=
action
;
}
)
;
if
(
toPrint
.
length
)
{
console
.
log
(
message
)
;
prettyPrintJSON
(
toPrint
.
map
(
item
=
>
{
return
item
.
expectation
;
}
)
)
;
console
.
log
(
'
The
recommendations
are
based
on
the
following
applied
expectaions
:
'
)
;
prettyPrintJSON
(
toPrint
.
map
(
item
=
>
{
return
item
.
basedOn
;
}
)
)
;
}
}
export
function
filterByParameters
(
expectations
:
TestExpectation
[
]
parameters
:
string
[
]
)
:
TestExpectation
[
]
{
const
querySet
=
new
Set
(
parameters
)
;
return
expectations
.
filter
(
ex
=
>
{
return
ex
.
parameters
.
every
(
param
=
>
{
return
querySet
.
has
(
param
)
;
}
)
;
}
)
;
}
export
function
findEffectiveExpectationForTest
(
expectations
:
TestExpectation
[
]
result
:
MochaTestResult
)
:
TestExpectation
|
undefined
{
return
expectations
.
find
(
expectation
=
>
{
return
testIdMatchesExpectationPattern
(
result
expectation
.
testIdPattern
)
;
}
)
;
}
export
type
RecommendedExpectation
=
{
expectation
:
TestExpectation
;
action
:
'
remove
'
|
'
add
'
|
'
update
'
;
basedOn
?
:
TestExpectation
;
}
;
export
function
isWildCardPattern
(
testIdPattern
:
string
)
:
boolean
{
return
testIdPattern
.
includes
(
'
*
'
)
;
}
export
function
getExpectationUpdates
(
results
:
MochaResults
expectations
:
TestExpectation
[
]
context
:
{
platforms
:
NodeJS
.
Platform
[
]
;
parameters
:
string
[
]
;
}
)
:
RecommendedExpectation
[
]
{
const
output
:
Map
<
string
RecommendedExpectation
>
=
new
Map
(
)
;
for
(
const
pass
of
results
.
passes
)
{
if
(
!
pass
.
file
)
{
continue
;
}
const
expectationEntry
=
findEffectiveExpectationForTest
(
expectations
pass
)
;
if
(
expectationEntry
&
&
!
expectationEntry
.
expectations
.
includes
(
'
PASS
'
)
)
{
if
(
isWildCardPattern
(
expectationEntry
.
testIdPattern
)
)
{
addEntry
(
{
expectation
:
{
testIdPattern
:
getTestId
(
pass
.
file
pass
.
fullTitle
)
platforms
:
context
.
platforms
parameters
:
context
.
parameters
expectations
:
[
'
PASS
'
]
}
action
:
'
add
'
basedOn
:
expectationEntry
}
)
;
}
else
{
addEntry
(
{
expectation
:
expectationEntry
action
:
'
remove
'
basedOn
:
expectationEntry
}
)
;
}
}
}
for
(
const
failure
of
results
.
failures
)
{
if
(
!
failure
.
file
)
{
continue
;
}
const
expectationEntry
=
findEffectiveExpectationForTest
(
expectations
failure
)
;
if
(
expectationEntry
&
&
!
expectationEntry
.
expectations
.
includes
(
'
SKIP
'
)
)
{
if
(
!
expectationEntry
.
expectations
.
includes
(
getTestResultForFailure
(
failure
)
)
)
{
if
(
isWildCardPattern
(
expectationEntry
.
testIdPattern
)
)
{
addEntry
(
{
expectation
:
{
testIdPattern
:
getTestId
(
failure
.
file
failure
.
fullTitle
)
platforms
:
context
.
platforms
parameters
:
context
.
parameters
expectations
:
[
getTestResultForFailure
(
failure
)
]
}
action
:
'
add
'
basedOn
:
expectationEntry
}
)
;
}
else
{
addEntry
(
{
expectation
:
{
.
.
.
expectationEntry
expectations
:
[
.
.
.
expectationEntry
.
expectations
getTestResultForFailure
(
failure
)
]
}
action
:
'
update
'
basedOn
:
expectationEntry
}
)
;
}
}
}
else
if
(
!
expectationEntry
)
{
addEntry
(
{
expectation
:
{
testIdPattern
:
getTestId
(
failure
.
file
failure
.
fullTitle
)
platforms
:
context
.
platforms
parameters
:
context
.
parameters
expectations
:
[
getTestResultForFailure
(
failure
)
]
}
action
:
'
add
'
}
)
;
}
}
function
addEntry
(
value
:
RecommendedExpectation
)
{
const
key
=
JSON
.
stringify
(
value
)
;
if
(
!
output
.
has
(
key
)
)
{
output
.
set
(
key
value
)
;
}
}
return
[
.
.
.
output
.
values
(
)
]
;
}
export
function
getTestResultForFailure
(
test
:
Pick
<
MochaTestResult
'
err
'
>
)
:
TestResult
{
return
test
.
err
?
.
code
=
=
=
'
ERR_MOCHA_TIMEOUT
'
?
'
TIMEOUT
'
:
'
FAIL
'
;
}
export
function
getTestId
(
file
:
string
fullTitle
?
:
string
)
:
string
{
return
fullTitle
?
[
{
getFilename
(
file
)
}
]
{
fullTitle
}
:
[
{
getFilename
(
file
)
}
]
;
}
export
function
testIdMatchesExpectationPattern
(
test
:
MochaTestResult
|
Mocha
.
Test
pattern
:
string
)
:
boolean
{
const
patternRegExString
=
pattern
.
replace
(
/
\
*
/
g
'
-
-
STAR
-
-
'
)
.
replace
(
/
[
.
*
+
?
^
{
}
(
)
|
[
\
]
\
\
]
/
g
'
\
\
&
'
)
.
replace
(
/
-
-
STAR
-
-
/
g
'
(
.
*
)
?
'
)
;
const
patternRegEx
=
new
RegExp
(
^
{
patternRegExString
}
)
;
const
fullTitle
=
typeof
test
.
fullTitle
=
=
=
'
string
'
?
test
.
fullTitle
:
test
.
fullTitle
(
)
;
return
patternRegEx
.
test
(
getTestId
(
test
.
file
?
?
'
'
fullTitle
)
)
;
}
