"
use
strict
"
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
RemoteAgentError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Error
.
jsm
"
)
;
const
{
RemoteAgent
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
RemoteAgent
.
jsm
"
)
;
const
add_plain_task
=
add_task
.
bind
(
this
)
;
this
.
add_task
=
function
(
taskFn
opts
=
{
}
)
{
const
{
createTab
=
true
}
=
opts
;
const
fn
=
async
function
(
)
{
let
client
tab
target
;
await
RemoteAgent
.
listen
(
Services
.
io
.
newURI
(
"
http
:
/
/
localhost
:
9222
"
)
)
;
info
(
"
CDP
server
started
"
)
;
try
{
const
CDP
=
await
getCDP
(
)
;
if
(
createTab
)
{
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
const
browsingContextId
=
tab
.
linkedBrowser
.
browsingContext
.
id
;
const
targets
=
await
CDP
.
List
(
)
;
target
=
targets
.
find
(
target
=
>
target
.
id
=
=
=
browsingContextId
)
;
}
client
=
await
CDP
(
{
target
}
)
;
info
(
"
CDP
client
instantiated
"
)
;
await
getDiscoveredTargets
(
client
.
Target
)
;
await
taskFn
(
{
client
CDP
tab
}
)
;
if
(
createTab
)
{
await
TestUtils
.
waitForTick
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
}
catch
(
e
)
{
if
(
e
.
response
)
{
throw
RemoteAgentError
.
fromJSON
(
e
.
response
)
;
}
else
{
throw
e
;
}
}
finally
{
if
(
client
)
{
await
client
.
close
(
)
;
info
(
"
CDP
client
closed
"
)
;
}
await
RemoteAgent
.
close
(
)
;
info
(
"
CDP
server
stopped
"
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
}
;
Object
.
defineProperty
(
fn
"
name
"
{
value
:
taskFn
.
name
writable
:
false
}
)
;
add_plain_task
(
fn
)
;
}
;
function
createTestDocument
(
)
{
const
browser
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
registerCleanupFunction
(
(
)
=
>
browser
.
close
(
)
)
;
const
webNavigation
=
browser
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
const
system
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
webNavigation
.
createAboutBlankContentViewer
(
system
system
)
;
return
webNavigation
.
document
;
}
async
function
getCDP
(
)
{
const
document
=
createTestDocument
(
)
;
const
window
=
document
.
defaultView
.
wrappedJSObject
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
remote
/
test
/
browser
/
chrome
-
remote
-
interface
.
js
"
window
)
;
window
.
criRequest
=
(
options
callback
)
=
>
{
const
{
host
port
path
}
=
options
;
const
url
=
http
:
/
/
{
host
}
:
{
port
}
{
path
}
;
const
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
url
true
)
;
xhr
.
overrideMimeType
(
"
text
/
plain
"
)
;
xhr
.
send
(
null
)
;
xhr
.
onload
=
(
)
=
>
callback
(
null
xhr
.
responseText
)
;
xhr
.
onerror
=
e
=
>
callback
(
e
null
)
;
}
;
return
window
.
CDP
;
}
async
function
getScrollbarSize
(
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
(
)
=
>
{
const
scrollbarHeight
=
{
}
;
const
scrollbarWidth
=
{
}
;
content
.
windowUtils
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
return
{
width
:
scrollbarWidth
.
value
height
:
scrollbarHeight
.
value
}
;
}
)
;
}
function
getTargets
(
CDP
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
CDP
.
List
(
null
(
err
targets
)
=
>
{
if
(
err
)
{
reject
(
err
)
;
return
;
}
resolve
(
targets
)
;
}
)
;
}
)
;
}
async
function
getDiscoveredTargets
(
Target
)
{
return
new
Promise
(
resolve
=
>
{
const
targets
=
[
]
;
const
unsubscribe
=
Target
.
targetCreated
(
target
=
>
{
targets
.
push
(
target
)
;
if
(
targets
.
length
>
=
gBrowser
.
tabs
.
length
+
1
)
{
unsubscribe
(
)
;
resolve
(
targets
)
;
}
}
)
;
Target
.
setDiscoverTargets
(
{
discover
:
true
}
)
;
}
)
;
}
async
function
openTab
(
Target
options
=
{
}
)
{
const
{
activate
=
false
}
=
options
;
info
(
"
Create
a
new
tab
and
wait
for
the
target
to
be
created
"
)
;
const
targetCreated
=
Target
.
targetCreated
(
)
;
const
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
const
{
targetInfo
}
=
await
targetCreated
;
is
(
targetInfo
.
type
"
page
"
)
;
if
(
activate
)
{
await
Target
.
activateTarget
(
{
targetId
:
targetInfo
.
targetId
}
)
;
info
(
New
tab
with
target
id
{
targetInfo
.
targetId
}
created
and
activated
)
;
}
else
{
info
(
New
tab
with
target
id
{
targetInfo
.
targetId
}
created
)
;
}
return
{
targetInfo
newTab
}
;
}
async
function
openWindow
(
Target
options
=
{
}
)
{
const
{
activate
=
false
}
=
options
;
info
(
"
Create
a
new
window
and
wait
for
the
target
to
be
created
"
)
;
const
targetCreated
=
Target
.
targetCreated
(
)
;
const
newWindow
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
const
newTab
=
newWindow
.
gBrowser
.
selectedTab
;
const
{
targetInfo
}
=
await
targetCreated
;
is
(
targetInfo
.
type
"
page
"
)
;
if
(
activate
)
{
await
Target
.
activateTarget
(
{
targetId
:
targetInfo
.
targetId
}
)
;
info
(
New
window
with
target
id
{
targetInfo
.
targetId
}
created
and
activated
)
;
}
else
{
info
(
New
window
with
target
id
{
targetInfo
.
targetId
}
created
)
;
}
return
{
targetInfo
newWindow
newTab
}
;
}
function
toDataURL
(
src
doctype
=
"
html
"
)
{
let
doc
mime
;
switch
(
doctype
)
{
case
"
html
"
:
mime
=
"
text
/
html
;
charset
=
utf
-
8
"
;
doc
=
<
!
doctype
html
>
\
n
<
meta
charset
=
utf
-
8
>
\
n
{
src
}
;
break
;
default
:
throw
new
Error
(
"
Unexpected
doctype
:
"
+
doctype
)
;
}
return
data
:
{
mime
}
{
encodeURIComponent
(
doc
)
}
;
}
async
function
loadURL
(
url
expectedURL
=
undefined
)
{
expectedURL
=
expectedURL
|
|
url
;
const
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
const
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
expectedURL
)
;
BrowserTestUtils
.
loadURI
(
browser
url
)
;
await
loaded
;
}
function
getContentProperty
(
prop
)
{
info
(
Retrieve
{
prop
}
on
the
content
window
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
prop
]
_prop
=
>
content
[
_prop
]
)
;
}
function
timeoutPromise
(
ms
)
{
return
new
Promise
(
resolve
=
>
{
window
.
setTimeout
(
resolve
ms
)
;
}
)
;
}
function
fail
(
message
)
{
ok
(
false
message
)
;
}
async
function
createFile
(
contents
options
=
{
}
)
{
let
{
path
=
null
remove
=
true
}
=
options
;
if
(
!
path
)
{
const
basePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
tmpDir
"
remote
-
agent
.
txt
"
)
;
const
{
file
path
:
tmpPath
}
=
await
OS
.
File
.
openUnique
(
basePath
{
humanReadable
:
true
}
)
;
await
file
.
close
(
)
;
path
=
tmpPath
;
}
let
encoder
=
new
TextEncoder
(
)
;
let
array
=
encoder
.
encode
(
contents
)
;
const
count
=
await
OS
.
File
.
writeAtomic
(
path
array
{
encoding
:
"
utf
-
8
"
tmpPath
:
path
+
"
.
tmp
"
}
)
;
is
(
count
contents
.
length
"
All
data
has
been
written
to
file
"
)
;
const
file
=
await
OS
.
File
.
open
(
path
)
;
if
(
remove
)
{
registerCleanupFunction
(
async
(
)
=
>
{
await
file
.
close
(
)
;
await
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
}
)
;
}
return
{
file
path
}
;
}
class
RecordEvents
{
constructor
(
total
)
{
this
.
events
=
[
]
;
this
.
promises
=
new
Set
(
)
;
this
.
subscriptions
=
new
Set
(
)
;
this
.
total
=
total
;
}
addRecorder
(
options
=
{
}
)
{
const
{
event
eventName
messageFn
=
(
)
=
>
Received
{
eventName
}
}
=
options
;
const
promise
=
new
Promise
(
resolve
=
>
{
const
unsubscribe
=
event
(
payload
=
>
{
info
(
messageFn
(
payload
)
)
;
this
.
events
.
push
(
{
eventName
payload
}
)
;
if
(
this
.
events
.
length
>
this
.
total
)
{
this
.
subscriptions
.
delete
(
unsubscribe
)
;
unsubscribe
(
)
;
resolve
(
this
.
events
)
;
}
}
)
;
this
.
subscriptions
.
add
(
unsubscribe
)
;
}
)
;
this
.
promises
.
add
(
promise
)
;
}
async
record
(
timeout
=
1000
)
{
await
Promise
.
race
(
[
Promise
.
all
(
this
.
promises
)
timeoutPromise
(
timeout
)
]
)
;
for
(
const
unsubscribe
of
this
.
subscriptions
)
{
unsubscribe
(
)
;
}
return
this
.
events
;
}
findEvent
(
eventName
)
{
const
event
=
this
.
events
.
find
(
el
=
>
el
.
eventName
=
=
eventName
)
;
if
(
event
)
{
return
event
.
payload
;
}
return
{
}
;
}
}
