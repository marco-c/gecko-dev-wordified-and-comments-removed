"
use
strict
"
;
const
{
RemoteAgentError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Error
.
jsm
"
)
;
const
{
RemoteAgent
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
RemoteAgent
.
jsm
"
)
;
const
add_plain_task
=
add_task
.
bind
(
this
)
;
this
.
add_task
=
function
(
taskFn
opts
=
{
}
)
{
const
{
createTab
=
true
}
=
opts
;
add_plain_task
(
async
function
(
)
{
let
client
;
await
RemoteAgent
.
listen
(
Services
.
io
.
newURI
(
"
http
:
/
/
localhost
:
9222
"
)
)
;
info
(
"
CDP
server
started
"
)
;
try
{
const
CDP
=
await
getCDP
(
)
;
if
(
createTab
)
{
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
)
;
const
browsingContextId
=
tab
.
linkedBrowser
.
browsingContext
.
id
;
client
=
await
CDP
(
{
target
(
list
)
{
return
list
.
find
(
target
=
>
target
.
id
=
=
=
browsingContextId
)
;
}
}
)
;
info
(
"
CDP
client
instantiated
"
)
;
await
taskFn
(
client
CDP
tab
)
;
await
TestUtils
.
waitForTick
(
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
else
{
client
=
await
CDP
(
{
}
)
;
info
(
"
CDP
client
instantiated
"
)
;
await
taskFn
(
client
CDP
)
;
}
}
catch
(
e
)
{
if
(
e
.
response
)
{
throw
RemoteAgentError
.
fromJSON
(
e
.
response
)
;
}
else
{
throw
e
;
}
}
finally
{
if
(
client
)
{
await
client
.
close
(
)
;
info
(
"
CDP
client
closed
"
)
;
}
await
RemoteAgent
.
close
(
)
;
info
(
"
CDP
server
stopped
"
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
}
)
;
}
;
function
createTestDocument
(
)
{
const
browser
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
registerCleanupFunction
(
(
)
=
>
browser
.
close
(
)
)
;
const
webNavigation
=
browser
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
const
system
=
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
;
webNavigation
.
createAboutBlankContentViewer
(
system
system
)
;
return
webNavigation
.
document
;
}
async
function
getCDP
(
)
{
const
document
=
createTestDocument
(
)
;
const
window
=
document
.
defaultView
.
wrappedJSObject
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
remote
/
test
/
browser
/
chrome
-
remote
-
interface
.
js
"
window
)
;
window
.
criRequest
=
(
options
callback
)
=
>
{
const
{
host
port
path
}
=
options
;
const
url
=
http
:
/
/
{
host
}
:
{
port
}
{
path
}
;
const
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
url
true
)
;
xhr
.
overrideMimeType
(
"
text
/
plain
"
)
;
xhr
.
send
(
null
)
;
xhr
.
onload
=
(
)
=
>
callback
(
null
xhr
.
responseText
)
;
xhr
.
onerror
=
e
=
>
callback
(
e
null
)
;
}
;
return
window
.
CDP
;
}
function
getTargets
(
CDP
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
CDP
.
List
(
null
(
err
targets
)
=
>
{
if
(
err
)
{
reject
(
err
)
;
return
;
}
resolve
(
targets
)
;
}
)
;
}
)
;
}
function
toDataURL
(
src
doctype
=
"
html
"
)
{
let
doc
mime
;
switch
(
doctype
)
{
case
"
html
"
:
mime
=
"
text
/
html
;
charset
=
utf
-
8
"
;
doc
=
<
!
doctype
html
>
\
n
<
meta
charset
=
utf
-
8
>
\
n
{
src
}
;
break
;
default
:
throw
new
Error
(
"
Unexpected
doctype
:
"
+
doctype
)
;
}
return
data
:
{
mime
}
{
encodeURIComponent
(
doc
)
}
;
}
async
function
loadURL
(
url
)
{
const
browser
=
gBrowser
.
selectedTab
.
linkedBrowser
;
const
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
url
)
;
BrowserTestUtils
.
loadURI
(
browser
url
)
;
await
loaded
;
}
function
getContentProperty
(
prop
)
{
info
(
Retrieve
{
prop
}
on
the
content
window
)
;
return
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
prop
_prop
=
>
content
[
_prop
]
)
;
}
function
timeoutPromise
(
ms
)
{
return
new
Promise
(
resolve
=
>
{
window
.
setTimeout
(
resolve
ms
)
;
}
)
;
}
