"
use
strict
"
;
add_task
(
async
function
(
)
{
const
{
client
}
=
await
setupTestForUri
(
toDataURL
(
"
"
)
)
;
const
firstContext
=
await
testRuntimeEnable
(
client
)
;
const
contextId
=
firstContext
.
id
;
await
testObjectRelease
(
client
contextId
)
;
await
client
.
close
(
)
;
ok
(
true
"
The
client
is
closed
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
await
RemoteAgent
.
close
(
)
;
}
)
;
async
function
testRuntimeEnable
(
{
Runtime
}
)
{
await
Runtime
.
enable
(
)
;
ok
(
true
"
Runtime
domain
has
been
enabled
"
)
;
const
{
context
}
=
await
Runtime
.
executionContextCreated
(
)
;
ok
(
!
!
context
.
id
"
The
execution
context
has
an
id
"
)
;
ok
(
context
.
auxData
.
isDefault
"
The
execution
context
is
the
default
one
"
)
;
ok
(
!
!
context
.
auxData
.
frameId
"
The
execution
context
has
a
frame
id
set
"
)
;
return
context
;
}
async
function
testObjectRelease
(
{
Runtime
}
contextId
)
{
const
{
result
}
=
await
Runtime
.
evaluate
(
{
contextId
expression
:
"
(
{
foo
:
42
}
)
"
}
)
;
is
(
result
.
subtype
null
"
JS
Object
have
no
subtype
"
)
;
is
(
result
.
type
"
object
"
"
The
type
is
correct
"
)
;
ok
(
!
!
result
.
objectId
"
Got
an
object
id
"
)
;
const
{
result
:
result2
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
:
contextId
functionDeclaration
:
"
obj
=
>
JSON
.
stringify
(
obj
)
"
arguments
:
[
{
objectId
:
result
.
objectId
}
]
}
)
;
is
(
result2
.
type
"
string
"
"
The
type
is
correct
"
)
;
is
(
result2
.
value
JSON
.
stringify
(
{
foo
:
42
}
)
"
Got
the
object
'
s
JSON
"
)
;
const
{
result
:
result3
}
=
await
Runtime
.
callFunctionOn
(
{
objectId
:
result
.
objectId
functionDeclaration
:
"
function
(
)
{
return
this
.
foo
;
}
"
}
)
;
is
(
result3
.
type
"
number
"
"
The
type
is
correct
"
)
;
is
(
result3
.
value
42
"
Got
the
object
'
s
foo
attribute
"
)
;
await
Runtime
.
releaseObject
(
{
objectId
:
result
.
objectId
}
)
;
ok
(
true
"
Object
is
released
"
)
;
try
{
await
Runtime
.
callFunctionOn
(
{
executionContextId
:
contextId
functionDeclaration
:
"
(
)
=
>
{
}
"
arguments
:
[
{
objectId
:
result
.
objectId
}
]
}
)
;
ok
(
false
"
callFunctionOn
with
a
released
object
as
argument
should
throw
"
)
;
}
catch
(
e
)
{
ok
(
e
.
message
.
includes
(
"
Cannot
find
object
with
ID
:
"
)
"
callFunctionOn
throws
on
released
argument
"
)
;
}
try
{
await
Runtime
.
callFunctionOn
(
{
objectId
:
result
.
objectId
functionDeclaration
:
"
(
)
=
>
{
}
"
}
)
;
ok
(
false
"
callFunctionOn
with
a
released
object
as
target
should
throw
"
)
;
}
catch
(
e
)
{
ok
(
e
.
message
.
includes
(
"
Unable
to
get
the
context
for
object
with
id
"
)
"
callFunctionOn
throws
on
released
target
"
)
;
}
}
