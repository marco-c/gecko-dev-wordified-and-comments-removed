"
use
strict
"
;
add_task
(
async
function
(
{
client
}
)
{
const
firstContext
=
await
testRuntimeEnable
(
client
)
;
const
contextId
=
firstContext
.
id
;
await
testObjectReferences
(
client
contextId
)
;
await
testExceptions
(
client
contextId
)
;
await
testReturnByValue
(
client
contextId
)
;
await
testAwaitPromise
(
client
contextId
)
;
await
testObjectId
(
client
contextId
)
;
}
)
;
async
function
testRuntimeEnable
(
{
Runtime
}
)
{
await
Runtime
.
enable
(
)
;
info
(
"
Runtime
domain
has
been
enabled
"
)
;
const
{
context
}
=
await
Runtime
.
executionContextCreated
(
)
;
ok
(
!
!
context
.
id
"
The
execution
context
has
an
id
"
)
;
ok
(
context
.
auxData
.
isDefault
"
The
execution
context
is
the
default
one
"
)
;
ok
(
!
!
context
.
auxData
.
frameId
"
The
execution
context
has
a
frame
id
set
"
)
;
return
context
;
}
async
function
testObjectReferences
(
{
Runtime
}
contextId
)
{
const
{
result
}
=
await
Runtime
.
evaluate
(
{
contextId
expression
:
"
(
{
foo
:
1
}
)
"
}
)
;
is
(
result
.
type
"
object
"
"
The
type
is
correct
"
)
;
is
(
result
.
subtype
null
"
The
subtype
is
null
for
objects
"
)
;
ok
(
!
!
result
.
objectId
"
Got
an
object
id
"
)
;
const
{
result
:
result2
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
:
contextId
functionDeclaration
:
"
arg
=
>
+
+
arg
.
foo
"
arguments
:
[
{
objectId
:
result
.
objectId
}
]
}
)
;
is
(
result2
.
type
"
number
"
"
The
type
is
correct
"
)
;
is
(
result2
.
subtype
null
"
The
subtype
is
null
for
numbers
"
)
;
is
(
result2
.
value
2
"
Updated
the
existing
object
and
returned
the
incremented
value
"
)
;
const
{
result
:
result3
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
:
contextId
functionDeclaration
:
"
arg
=
>
{
arg
.
foo
+
+
;
return
arg
;
}
"
arguments
:
[
{
objectId
:
result
.
objectId
}
]
}
)
;
is
(
result3
.
type
"
object
"
"
The
type
is
correct
"
)
;
is
(
result3
.
subtype
null
"
The
subtype
is
null
for
objects
"
)
;
ok
(
!
!
result3
.
objectId
"
Got
an
object
id
"
)
;
isnot
(
result3
.
objectId
result
.
objectId
"
The
object
id
is
stable
"
)
;
const
{
result
:
result4
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
:
contextId
functionDeclaration
:
"
arg
=
>
arg
.
foo
"
arguments
:
[
{
objectId
:
result3
.
objectId
}
]
}
)
;
is
(
result4
.
type
"
number
"
"
The
type
is
correct
"
)
;
is
(
result4
.
subtype
null
"
The
subtype
is
null
for
numbers
"
)
;
is
(
result4
.
value
3
"
Updated
the
existing
object
and
returned
the
incremented
value
"
)
;
}
async
function
testExceptions
(
{
Runtime
}
executionContextId
)
{
let
{
exceptionDetails
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
doesNotExists
(
)
"
}
)
;
is
(
exceptionDetails
.
text
"
doesNotExists
is
not
defined
"
"
Exception
message
is
passed
to
the
client
"
)
;
(
{
exceptionDetails
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
(
)
=
>
doesNotExists
(
)
"
}
)
)
;
is
(
exceptionDetails
.
text
"
doesNotExists
is
not
defined
"
"
Exception
message
is
passed
to
the
client
"
)
;
}
async
function
testReturnByValue
(
{
Runtime
}
executionContextId
)
{
const
values
=
[
42
"
42
"
42
.
0
true
false
null
{
foo
:
true
}
{
foo
:
{
bar
:
42
str
:
"
str
"
array
:
[
1
2
3
]
}
}
[
42
"
42
"
true
]
[
{
foo
:
true
}
]
]
;
for
(
const
value
of
values
)
{
const
{
result
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
(
)
=
>
(
"
+
JSON
.
stringify
(
value
)
+
"
)
"
returnByValue
:
true
}
)
;
Assert
.
deepEqual
(
result
.
value
value
"
The
returned
value
is
the
same
than
the
input
value
"
)
;
}
const
nonSerializableNumbers
=
[
"
-
0
"
"
NaN
"
"
Infinity
"
"
-
Infinity
"
]
;
for
(
const
unserializableValue
of
nonSerializableNumbers
)
{
const
{
result
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
a
=
>
a
"
arguments
:
[
{
unserializableValue
}
]
returnByValue
:
true
}
)
;
Assert
.
deepEqual
(
result
{
type
:
"
number
"
unserializableValue
description
:
unserializableValue
}
"
The
returned
value
is
the
same
than
the
input
value
"
)
;
}
const
{
result
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
(
)
=
>
{
}
"
returnByValue
:
true
}
)
;
is
(
result
.
type
"
undefined
"
"
The
returned
value
is
undefined
"
)
;
}
async
function
testAwaitPromise
(
{
Runtime
}
executionContextId
)
{
let
{
result
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
(
)
=
>
Promise
.
resolve
(
42
)
"
awaitPromise
:
true
}
)
;
is
(
result
.
type
"
number
"
"
The
type
is
correct
"
)
;
is
(
result
.
subtype
null
"
The
subtype
is
null
for
numbers
"
)
;
is
(
result
.
value
42
"
The
result
is
the
promise
'
s
resolution
"
)
;
let
{
exceptionDetails
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
(
)
=
>
Promise
.
reject
(
42
)
"
awaitPromise
:
true
}
)
;
is
(
exceptionDetails
.
exception
.
value
42
"
The
result
is
the
promise
'
s
rejection
"
)
;
(
{
result
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
(
)
=
>
new
Promise
(
r
=
>
setTimeout
(
(
)
=
>
r
(
42
)
0
)
)
"
awaitPromise
:
true
}
)
)
;
is
(
result
.
type
"
number
"
"
The
type
is
correct
"
)
;
is
(
result
.
subtype
null
"
The
subtype
is
null
for
numbers
"
)
;
is
(
result
.
value
42
"
The
result
is
the
promise
'
s
resolution
"
)
;
(
{
exceptionDetails
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
(
)
=
>
new
Promise
(
(
_
r
)
=
>
setTimeout
(
(
)
=
>
r
(
42
)
0
)
)
"
awaitPromise
:
true
}
)
)
;
is
(
exceptionDetails
.
exception
.
value
42
"
The
result
is
the
promise
'
s
rejection
"
)
;
(
{
result
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
(
)
=
>
Promise
.
resolve
(
42
)
"
awaitPromise
:
false
}
)
)
;
is
(
result
.
type
"
object
"
"
The
type
is
correct
"
)
;
is
(
result
.
subtype
"
promise
"
"
The
subtype
is
promise
"
)
;
ok
(
!
!
result
.
objectId
"
We
got
the
object
id
for
the
promise
"
)
;
ok
(
!
result
.
value
"
We
do
not
receive
any
value
"
)
;
(
{
result
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
functionDeclaration
:
"
(
)
=
>
Promise
.
reject
(
42
)
"
awaitPromise
:
false
}
)
)
;
is
(
result
.
type
"
object
"
"
The
type
is
correct
"
)
;
is
(
result
.
subtype
"
promise
"
"
The
subtype
is
promise
"
)
;
ok
(
!
!
result
.
objectId
"
We
got
the
object
id
for
the
promise
"
)
;
ok
(
!
result
.
exceptionDetails
"
We
do
not
receive
any
exception
"
)
;
}
async
function
testObjectId
(
{
Runtime
}
contextId
)
{
const
{
result
}
=
await
Runtime
.
evaluate
(
{
contextId
expression
:
"
(
{
foo
:
42
}
)
"
}
)
;
is
(
result
.
type
"
object
"
"
The
type
is
correct
"
)
;
is
(
result
.
subtype
null
"
The
subtype
is
null
for
objects
"
)
;
ok
(
!
!
result
.
objectId
"
Got
an
object
id
"
)
;
const
{
result
:
result2
}
=
await
Runtime
.
callFunctionOn
(
{
executionContextId
:
contextId
functionDeclaration
:
"
function
(
)
{
return
this
.
foo
;
}
"
objectId
:
result
.
objectId
}
)
;
is
(
result2
.
type
"
number
"
"
The
type
is
correct
"
)
;
is
(
result2
.
subtype
null
"
The
subtype
is
null
for
numbers
"
)
;
is
(
result2
.
value
42
"
We
have
a
good
proof
that
the
function
was
ran
against
the
target
object
"
)
;
}
