"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
RemoteAgent
"
"
RemoteAgentFactory
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
FatalError
:
"
chrome
:
/
/
remote
/
content
/
Error
.
jsm
"
HttpServer
:
"
chrome
:
/
/
remote
/
content
/
server
/
HTTPD
.
jsm
"
JSONHandler
:
"
chrome
:
/
/
remote
/
content
/
JSONHandler
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
Log
.
jsm
"
NetUtil
:
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
Observer
:
"
chrome
:
/
/
remote
/
content
/
Observer
.
jsm
"
Preferences
:
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
RecommendedPreferences
:
"
chrome
:
/
/
remote
/
content
/
RecommendedPreferences
.
jsm
"
Targets
:
"
chrome
:
/
/
remote
/
content
/
targets
/
Targets
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
Log
.
get
)
;
const
ENABLED
=
"
remote
.
enabled
"
;
const
FORCE_LOCAL
=
"
remote
.
force
-
local
"
;
const
DEFAULT_HOST
=
"
localhost
"
;
const
DEFAULT_PORT
=
9222
;
const
LOOPBACKS
=
[
"
localhost
"
"
127
.
0
.
0
.
1
"
"
[
:
:
1
]
"
]
;
class
RemoteAgentClass
{
get
listening
(
)
{
return
!
!
this
.
server
&
&
!
this
.
server
.
isStopped
(
)
;
}
async
listen
(
url
)
{
if
(
!
Preferences
.
get
(
ENABLED
false
)
)
{
throw
new
Error
(
"
Remote
agent
is
disabled
by
preference
"
)
;
}
if
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
{
throw
new
Error
(
"
Remote
agent
can
only
be
instantiated
from
the
parent
process
"
)
;
}
if
(
!
(
url
instanceof
Ci
.
nsIURI
)
)
{
url
=
Services
.
io
.
newURI
(
url
)
;
}
let
{
host
port
}
=
url
;
if
(
Preferences
.
get
(
FORCE_LOCAL
)
&
&
!
LOOPBACKS
.
includes
(
host
)
)
{
throw
new
Error
(
"
Restricted
to
loopback
devices
"
)
;
}
if
(
port
=
=
=
0
)
{
port
=
-
1
;
}
if
(
this
.
listening
)
{
return
;
}
Preferences
.
set
(
RecommendedPreferences
)
;
this
.
server
=
new
HttpServer
(
)
;
this
.
server
.
registerPrefixHandler
(
"
/
json
/
"
new
JSONHandler
(
this
)
)
;
this
.
targets
=
new
Targets
(
)
;
this
.
targets
.
on
(
"
target
-
created
"
(
eventName
target
)
=
>
{
if
(
!
target
.
path
)
{
throw
new
Error
(
Target
is
missing
'
path
'
attribute
:
{
target
}
)
;
}
this
.
server
.
registerPathHandler
(
target
.
path
target
)
;
}
)
;
this
.
targets
.
on
(
"
target
-
destroyed
"
(
eventName
target
)
=
>
{
delete
this
.
server
.
_handler
.
_overridePaths
[
target
.
path
]
;
}
)
;
try
{
await
this
.
targets
.
watchForTargets
(
)
;
const
mainTarget
=
this
.
targets
.
getMainProcessTarget
(
)
;
this
.
server
.
_start
(
port
host
)
;
dump
(
DevTools
listening
on
{
mainTarget
.
wsDebuggerURL
}
\
n
)
;
Services
.
obs
.
notifyObservers
(
null
"
remote
-
listening
"
mainTarget
.
wsDebuggerURL
)
;
}
catch
(
e
)
{
await
this
.
close
(
)
;
throw
new
Error
(
Unable
to
start
remote
agent
:
{
e
.
message
}
e
)
;
}
}
async
close
(
)
{
try
{
Preferences
.
reset
(
Object
.
keys
(
RecommendedPreferences
)
)
;
if
(
this
.
targets
)
{
this
.
targets
.
destructor
(
)
;
}
if
(
this
.
listening
)
{
await
this
.
server
.
stop
(
)
;
}
}
catch
(
e
)
{
log
.
error
(
"
unable
to
stop
listener
"
e
)
;
}
finally
{
this
.
server
=
null
;
this
.
targets
=
null
;
}
}
get
scheme
(
)
{
if
(
!
this
.
server
)
{
return
null
;
}
return
this
.
server
.
identity
.
primaryScheme
;
}
get
host
(
)
{
if
(
!
this
.
server
)
{
return
null
;
}
return
this
.
server
.
identity
.
primaryHost
;
}
get
port
(
)
{
if
(
!
this
.
server
)
{
return
null
;
}
return
this
.
server
.
identity
.
primaryPort
;
}
async
handle
(
cmdLine
)
{
function
flag
(
name
)
{
const
caseSensitive
=
true
;
try
{
return
cmdLine
.
handleFlagWithParam
(
name
caseSensitive
)
;
}
catch
(
e
)
{
return
cmdLine
.
handleFlag
(
name
caseSensitive
)
;
}
}
const
remoteDebugger
=
flag
(
"
remote
-
debugger
"
)
;
const
remoteDebuggingPort
=
flag
(
"
remote
-
debugging
-
port
"
)
;
if
(
remoteDebugger
&
&
remoteDebuggingPort
)
{
log
.
fatal
(
"
Conflicting
flags
-
-
remote
-
debugger
and
-
-
remote
-
debugging
-
port
"
)
;
cmdLine
.
preventDefault
=
true
;
return
;
}
if
(
!
remoteDebugger
&
&
!
remoteDebuggingPort
)
{
return
;
}
let
host
port
;
if
(
typeof
remoteDebugger
=
=
"
string
"
)
{
[
host
port
]
=
remoteDebugger
.
split
(
"
:
"
)
;
}
else
if
(
typeof
remoteDebuggingPort
=
=
"
string
"
)
{
port
=
remoteDebuggingPort
;
}
let
addr
;
try
{
addr
=
NetUtil
.
newURI
(
http
:
/
/
{
host
|
|
DEFAULT_HOST
}
:
{
port
|
|
DEFAULT_PORT
}
/
)
;
}
catch
(
e
)
{
log
.
fatal
(
Expected
address
syntax
[
<
host
>
]
:
<
port
>
:
{
remoteDebugger
|
|
remoteDebuggingPort
}
)
;
cmdLine
.
preventDefault
=
true
;
return
;
}
await
Observer
.
once
(
"
sessionstore
-
windows
-
restored
"
)
;
try
{
this
.
listen
(
addr
)
;
}
catch
(
e
)
{
this
.
close
(
)
;
throw
new
FatalError
(
Unable
to
start
remote
agent
on
{
addr
.
spec
}
:
{
e
.
message
}
e
)
;
}
}
get
helpInfo
(
)
{
return
(
"
-
-
remote
-
debugger
[
<
host
>
]
[
:
<
port
>
]
\
n
"
+
"
-
-
remote
-
debugging
-
port
<
port
>
Start
the
Firefox
remote
agent
which
is
\
n
"
+
"
a
low
-
level
debugging
interface
based
on
the
CDP
protocol
.
\
n
"
+
"
Defaults
to
listen
on
localhost
:
9222
.
\
n
"
)
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
Ci
.
nsICommandLineHandler
]
)
;
}
}
var
RemoteAgent
=
new
RemoteAgentClass
(
)
;
var
RemoteAgentFactory
=
function
(
)
{
return
RemoteAgent
;
}
;
