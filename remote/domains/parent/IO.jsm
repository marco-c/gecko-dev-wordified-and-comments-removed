"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
IO
"
"
streamRegistry
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
}
)
;
const
{
Domain
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
Domain
.
jsm
"
)
;
const
{
StreamRegistry
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
StreamRegistry
.
jsm
"
)
;
const
DEFAULT_CHUNK_SIZE
=
10
*
1024
*
1024
;
const
streamRegistry
=
new
StreamRegistry
(
)
;
class
IO
extends
Domain
{
async
close
(
options
)
{
const
{
handle
}
=
options
;
if
(
typeof
handle
!
=
"
string
"
)
{
throw
new
TypeError
(
handle
:
string
value
expected
)
;
}
await
streamRegistry
.
remove
(
handle
)
;
}
async
read
(
options
=
{
}
)
{
const
{
handle
offset
size
}
=
options
;
if
(
typeof
handle
!
=
"
string
"
)
{
throw
new
TypeError
(
handle
:
string
value
expected
)
;
}
const
stream
=
streamRegistry
.
get
(
handle
)
;
const
fileInfo
=
await
stream
.
stat
(
)
;
if
(
typeof
offset
!
=
"
undefined
"
)
{
if
(
typeof
offset
!
=
"
number
"
)
{
throw
new
TypeError
(
offset
:
integer
value
expected
)
;
}
const
seekTo
=
Math
.
max
(
0
Math
.
min
(
offset
fileInfo
.
size
)
)
;
await
stream
.
setPosition
(
seekTo
OS
.
File
.
POS_START
)
;
}
const
curPos
=
await
stream
.
getPosition
(
)
;
const
remainingBytes
=
fileInfo
.
size
-
curPos
;
let
chunkSize
;
if
(
typeof
size
!
=
"
undefined
"
)
{
if
(
typeof
size
!
=
"
number
"
)
{
throw
new
TypeError
(
size
:
integer
value
expected
)
;
}
chunkSize
=
Math
.
max
(
0
Math
.
min
(
size
remainingBytes
)
)
;
}
else
{
chunkSize
=
Math
.
min
(
DEFAULT_CHUNK_SIZE
remainingBytes
)
;
}
const
bytes
=
await
stream
.
read
(
chunkSize
)
;
const
data
=
btoa
(
String
.
fromCharCode
.
apply
(
null
bytes
)
)
;
return
{
data
base64Encoded
:
true
eof
:
remainingBytes
-
bytes
.
length
=
=
0
}
;
}
}
