"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Page
"
]
;
const
{
DialogHandler
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
parent
/
page
/
DialogHandler
.
jsm
"
)
;
const
{
Domain
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
Domain
.
jsm
"
)
;
const
{
UnsupportedError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Error
.
jsm
"
)
;
const
{
TabManager
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
TabManager
.
jsm
"
)
;
const
{
WindowManager
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
WindowManager
.
jsm
"
)
;
class
Page
extends
Domain
{
constructor
(
session
)
{
super
(
session
)
;
this
.
_onDialogLoaded
=
this
.
_onDialogLoaded
.
bind
(
this
)
;
this
.
enabled
=
false
;
}
destructor
(
)
{
this
.
_isDestroyed
=
false
;
this
.
disable
(
)
;
super
.
destructor
(
)
;
}
async
captureScreenshot
(
options
=
{
}
)
{
const
{
format
=
"
png
"
}
=
options
;
if
(
options
.
clip
)
{
throw
new
UnsupportedError
(
"
clip
not
supported
"
)
;
}
if
(
options
.
fromSurface
)
{
throw
new
UnsupportedError
(
"
fromSurface
not
supported
"
)
;
}
if
(
options
.
quality
)
{
throw
new
UnsupportedError
(
"
quality
not
supported
"
)
;
}
const
MAX_CANVAS_DIMENSION
=
32767
;
const
MAX_CANVAS_AREA
=
472907776
;
const
{
browsingContext
window
}
=
this
.
session
.
target
;
const
scale
=
window
.
devicePixelRatio
;
const
rect
=
await
this
.
executeInChild
(
"
_viewportRect
"
)
;
let
canvasWidth
=
rect
.
width
*
scale
;
let
canvasHeight
=
rect
.
height
*
scale
;
if
(
canvasWidth
>
MAX_CANVAS_DIMENSION
)
{
rect
.
width
=
Math
.
floor
(
MAX_CANVAS_DIMENSION
/
scale
)
;
canvasWidth
=
rect
.
width
*
scale
;
}
if
(
canvasHeight
>
MAX_CANVAS_DIMENSION
)
{
rect
.
height
=
Math
.
floor
(
MAX_CANVAS_DIMENSION
/
scale
)
;
canvasHeight
=
rect
.
height
*
scale
;
}
if
(
canvasWidth
*
canvasHeight
>
MAX_CANVAS_AREA
)
{
rect
.
height
=
Math
.
floor
(
MAX_CANVAS_AREA
/
(
canvasWidth
*
scale
)
)
;
canvasHeight
=
rect
.
height
*
scale
;
}
const
snapshot
=
await
browsingContext
.
currentWindowGlobal
.
drawSnapshot
(
rect
scale
"
rgb
(
255
255
255
)
"
)
;
const
canvas
=
window
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
canvasWidth
;
canvas
.
height
=
canvasHeight
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
snapshot
0
0
)
;
snapshot
.
close
(
)
;
const
url
=
canvas
.
toDataURL
(
image
/
{
format
}
)
;
if
(
!
url
.
startsWith
(
data
:
image
/
{
format
}
)
)
{
throw
new
UnsupportedError
(
Unsupported
MIME
type
:
image
/
{
format
}
)
;
}
const
data
=
url
.
substring
(
url
.
indexOf
(
"
"
)
+
1
)
;
return
{
data
}
;
}
async
enable
(
)
{
if
(
this
.
enabled
)
{
return
;
}
this
.
enabled
=
true
;
const
{
browser
}
=
this
.
session
.
target
;
this
.
_dialogHandler
=
new
DialogHandler
(
browser
)
;
this
.
_dialogHandler
.
on
(
"
dialog
-
loaded
"
this
.
_onDialogLoaded
)
;
await
this
.
executeInChild
(
"
enable
"
)
;
}
async
disable
(
)
{
if
(
!
this
.
enabled
)
{
return
;
}
this
.
_dialogHandler
.
destructor
(
)
;
this
.
_dialogHandler
=
null
;
this
.
enabled
=
false
;
if
(
!
this
.
_isDestroyed
)
{
await
this
.
executeInChild
(
"
disable
"
)
;
}
}
async
bringToFront
(
)
{
const
{
tab
window
}
=
this
.
session
.
target
;
await
WindowManager
.
focus
(
window
)
;
TabManager
.
selectTab
(
tab
)
;
}
async
handleJavaScriptDialog
(
{
accept
promptText
}
)
{
if
(
!
this
.
enabled
)
{
throw
new
Error
(
"
Page
domain
is
not
enabled
"
)
;
}
await
this
.
_dialogHandler
.
handleJavaScriptDialog
(
{
accept
promptText
}
)
;
}
_onDialogLoaded
(
e
data
)
{
const
{
message
type
}
=
data
;
this
.
emit
(
"
Page
.
javascriptDialogOpening
"
{
message
type
}
)
;
}
}
