"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Page
"
]
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
clearInterval
setInterval
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
{
DialogHandler
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
parent
/
page
/
DialogHandler
.
jsm
"
)
;
const
{
Domain
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
Domain
.
jsm
"
)
;
const
{
UnsupportedError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Error
.
jsm
"
)
;
const
{
streamRegistry
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
parent
/
IO
.
jsm
"
)
;
const
{
TabManager
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
TabManager
.
jsm
"
)
;
const
{
WindowManager
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
WindowManager
.
jsm
"
)
;
const
PRINT_MAX_SCALE_VALUE
=
2
.
0
;
const
PRINT_MIN_SCALE_VALUE
=
0
.
1
;
const
PDF_TRANSFER_MODES
=
{
base64
:
"
ReturnAsBase64
"
stream
:
"
ReturnAsStream
"
}
;
class
Page
extends
Domain
{
constructor
(
session
)
{
super
(
session
)
;
this
.
_onDialogLoaded
=
this
.
_onDialogLoaded
.
bind
(
this
)
;
this
.
enabled
=
false
;
}
destructor
(
)
{
this
.
_isDestroyed
=
false
;
this
.
disable
(
)
;
super
.
destructor
(
)
;
}
async
captureScreenshot
(
options
=
{
}
)
{
const
{
format
=
"
png
"
quality
=
80
}
=
options
;
if
(
options
.
clip
)
{
throw
new
UnsupportedError
(
"
clip
not
supported
"
)
;
}
if
(
options
.
fromSurface
)
{
throw
new
UnsupportedError
(
"
fromSurface
not
supported
"
)
;
}
const
MAX_CANVAS_DIMENSION
=
32767
;
const
MAX_CANVAS_AREA
=
472907776
;
const
{
browsingContext
window
}
=
this
.
session
.
target
;
const
scale
=
window
.
devicePixelRatio
;
const
rect
=
await
this
.
executeInChild
(
"
_layoutViewport
"
)
;
let
canvasWidth
=
rect
.
clientWidth
*
scale
;
let
canvasHeight
=
rect
.
clientHeight
*
scale
;
if
(
canvasWidth
>
MAX_CANVAS_DIMENSION
)
{
rect
.
clientWidth
=
Math
.
floor
(
MAX_CANVAS_DIMENSION
/
scale
)
;
canvasWidth
=
rect
.
clientWidth
*
scale
;
}
if
(
canvasHeight
>
MAX_CANVAS_DIMENSION
)
{
rect
.
clientHeight
=
Math
.
floor
(
MAX_CANVAS_DIMENSION
/
scale
)
;
canvasHeight
=
rect
.
clientHeight
*
scale
;
}
if
(
canvasWidth
*
canvasHeight
>
MAX_CANVAS_AREA
)
{
rect
.
clientHeight
=
Math
.
floor
(
MAX_CANVAS_AREA
/
(
canvasWidth
*
scale
)
)
;
canvasHeight
=
rect
.
clientHeight
*
scale
;
}
const
captureRect
=
new
DOMRect
(
rect
.
pageX
rect
.
pageY
rect
.
clientWidth
rect
.
clientHeight
)
;
const
snapshot
=
await
browsingContext
.
currentWindowGlobal
.
drawSnapshot
(
captureRect
scale
"
rgb
(
255
255
255
)
"
)
;
const
canvas
=
window
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
canvas
.
width
=
canvasWidth
;
canvas
.
height
=
canvasHeight
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
drawImage
(
snapshot
0
0
)
;
snapshot
.
close
(
)
;
const
url
=
canvas
.
toDataURL
(
image
/
{
format
}
quality
/
100
)
;
if
(
!
url
.
startsWith
(
data
:
image
/
{
format
}
)
)
{
throw
new
UnsupportedError
(
Unsupported
MIME
type
:
image
/
{
format
}
)
;
}
const
data
=
url
.
substring
(
url
.
indexOf
(
"
"
)
+
1
)
;
return
{
data
}
;
}
async
enable
(
)
{
if
(
this
.
enabled
)
{
return
;
}
this
.
enabled
=
true
;
const
{
browser
}
=
this
.
session
.
target
;
this
.
_dialogHandler
=
new
DialogHandler
(
browser
)
;
this
.
_dialogHandler
.
on
(
"
dialog
-
loaded
"
this
.
_onDialogLoaded
)
;
await
this
.
executeInChild
(
"
enable
"
)
;
}
async
disable
(
)
{
if
(
!
this
.
enabled
)
{
return
;
}
this
.
_dialogHandler
.
destructor
(
)
;
this
.
_dialogHandler
=
null
;
this
.
enabled
=
false
;
if
(
!
this
.
_isDestroyed
)
{
await
this
.
executeInChild
(
"
disable
"
)
;
}
}
async
bringToFront
(
)
{
const
{
tab
window
}
=
this
.
session
.
target
;
await
WindowManager
.
focus
(
window
)
;
TabManager
.
selectTab
(
tab
)
;
}
async
getLayoutMetrics
(
)
{
return
{
layoutViewport
:
await
this
.
executeInChild
(
"
_layoutViewport
"
)
contentSize
:
await
this
.
executeInChild
(
"
_contentSize
"
)
}
;
}
async
handleJavaScriptDialog
(
{
accept
promptText
}
)
{
if
(
!
this
.
enabled
)
{
throw
new
Error
(
"
Page
domain
is
not
enabled
"
)
;
}
await
this
.
_dialogHandler
.
handleJavaScriptDialog
(
{
accept
promptText
}
)
;
}
async
printToPDF
(
options
)
{
const
{
displayHeaderFooter
=
false
landscape
=
false
marginBottom
=
0
.
39
marginLeft
=
0
.
39
marginRight
=
0
.
39
marginTop
=
0
.
39
paperHeight
=
11
.
0
paperWidth
=
8
.
5
preferCSSPageSize
=
false
printBackground
=
false
scale
=
1
.
0
transferMode
=
PDF_TRANSFER_MODES
.
base64
}
=
options
;
if
(
marginBottom
<
0
)
{
throw
new
TypeError
(
"
marginBottom
is
negative
"
)
;
}
if
(
marginLeft
<
0
)
{
throw
new
TypeError
(
"
marginLeft
is
negative
"
)
;
}
if
(
marginRight
<
0
)
{
throw
new
TypeError
(
"
marginRight
is
negative
"
)
;
}
if
(
marginTop
<
0
)
{
throw
new
TypeError
(
"
marginTop
is
negative
"
)
;
}
if
(
scale
<
PRINT_MIN_SCALE_VALUE
|
|
scale
>
PRINT_MAX_SCALE_VALUE
)
{
throw
new
TypeError
(
"
scale
is
outside
[
0
.
1
-
2
]
range
"
)
;
}
if
(
paperHeight
<
=
0
)
{
throw
new
TypeError
(
"
paperHeight
is
zero
or
negative
"
)
;
}
if
(
paperWidth
<
=
0
)
{
throw
new
TypeError
(
"
paperWidth
is
zero
or
negative
"
)
;
}
const
basePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
tmpDir
"
remote
-
agent
.
pdf
"
)
;
const
{
file
path
:
filePath
}
=
await
OS
.
File
.
openUnique
(
basePath
)
;
await
file
.
close
(
)
;
const
psService
=
Cc
[
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
const
printSettings
=
psService
.
newPrintSettings
;
printSettings
.
isInitializedFromPrinter
=
true
;
printSettings
.
isInitializedFromPrefs
=
true
;
printSettings
.
outputFormat
=
Ci
.
nsIPrintSettings
.
kOutputFormatPDF
;
printSettings
.
printerName
=
"
"
;
printSettings
.
printSilent
=
true
;
printSettings
.
printToFile
=
true
;
printSettings
.
showPrintProgress
=
false
;
printSettings
.
toFileName
=
filePath
;
printSettings
.
paperSizeUnit
=
Ci
.
nsIPrintSettings
.
kPaperSizeInches
;
printSettings
.
paperWidth
=
paperWidth
;
printSettings
.
paperHeight
=
paperHeight
;
printSettings
.
marginBottom
=
marginBottom
;
printSettings
.
marginLeft
=
marginLeft
;
printSettings
.
marginRight
=
marginRight
;
printSettings
.
marginTop
=
marginTop
;
printSettings
.
printBGColors
=
printBackground
;
printSettings
.
printBGImages
=
printBackground
;
printSettings
.
scaling
=
scale
;
printSettings
.
shrinkToFit
=
preferCSSPageSize
;
if
(
!
displayHeaderFooter
)
{
printSettings
.
headerStrCenter
=
"
"
;
printSettings
.
headerStrLeft
=
"
"
;
printSettings
.
headerStrRight
=
"
"
;
printSettings
.
footerStrCenter
=
"
"
;
printSettings
.
footerStrLeft
=
"
"
;
printSettings
.
footerStrRight
=
"
"
;
}
if
(
landscape
)
{
printSettings
.
orientation
=
Ci
.
nsIPrintSettings
.
kLandscapeOrientation
;
}
await
new
Promise
(
resolve
=
>
{
const
waitForFileWritten
=
(
)
=
>
{
const
DELAY_CHECK_FILE_COMPLETELY_WRITTEN
=
100
;
let
lastSize
=
0
;
const
timerId
=
setInterval
(
async
(
)
=
>
{
const
fileInfo
=
await
OS
.
File
.
stat
(
filePath
)
;
if
(
lastSize
>
0
&
&
fileInfo
.
size
=
=
lastSize
)
{
clearInterval
(
timerId
)
;
resolve
(
)
;
}
lastSize
=
fileInfo
.
size
;
}
DELAY_CHECK_FILE_COMPLETELY_WRITTEN
)
;
}
;
const
printProgressListener
=
{
onStateChange
(
webProgress
request
flags
status
)
{
if
(
flags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
flags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
)
{
waitForFileWritten
(
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
]
)
}
;
const
{
tab
}
=
this
.
session
.
target
;
tab
.
linkedBrowser
.
print
(
tab
.
linkedBrowser
.
outerWindowID
printSettings
printProgressListener
)
;
}
)
;
const
fp
=
await
OS
.
File
.
open
(
filePath
)
;
const
retval
=
{
data
:
null
stream
:
null
}
;
if
(
transferMode
=
=
PDF_TRANSFER_MODES
.
stream
)
{
retval
.
stream
=
streamRegistry
.
add
(
fp
)
;
}
else
{
let
bytes
;
try
{
bytes
=
await
fp
.
read
(
)
;
}
finally
{
fp
.
close
(
)
;
await
OS
.
File
.
remove
(
filePath
)
;
}
retval
.
data
=
btoa
(
String
.
fromCharCode
.
apply
(
null
bytes
)
)
;
}
return
retval
;
}
_onDialogLoaded
(
e
data
)
{
const
{
message
type
}
=
data
;
this
.
emit
(
"
Page
.
javascriptDialogOpening
"
{
message
type
}
)
;
}
}
