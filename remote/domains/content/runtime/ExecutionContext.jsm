"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExecutionContext
"
]
;
const
uuidGen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
TYPED_ARRAY_CLASSES
=
[
"
Uint8Array
"
"
Uint8ClampedArray
"
"
Uint16Array
"
"
Uint32Array
"
"
Int8Array
"
"
Int16Array
"
"
Int32Array
"
"
Float32Array
"
"
Float64Array
"
]
;
function
uuid
(
)
{
return
uuidGen
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
}
class
ExecutionContext
{
constructor
(
dbg
debuggee
)
{
this
.
_debugger
=
dbg
;
this
.
_debuggee
=
this
.
_debugger
.
addDebuggee
(
debuggee
)
;
this
.
_remoteObjects
=
new
Map
(
)
;
}
destructor
(
)
{
this
.
_debugger
.
removeDebuggee
(
this
.
_debuggee
)
;
}
evaluate
(
expression
)
{
let
rv
=
this
.
_debuggee
.
executeInGlobal
(
expression
)
;
if
(
!
rv
)
{
return
{
exceptionDetails
:
{
text
:
"
Evaluation
terminated
!
"
}
}
;
}
if
(
rv
.
throw
)
{
return
this
.
_returnError
(
rv
.
throw
)
;
}
return
{
result
:
this
.
_createRemoteObject
(
rv
.
return
)
}
;
}
_returnError
(
exception
)
{
if
(
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
exception
instanceof
Error
"
{
exception
}
)
.
return
)
{
const
text
=
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
exception
.
message
"
{
exception
}
)
.
return
;
return
{
exceptionDetails
:
{
text
}
}
;
}
return
{
exceptionDetails
:
{
exception
:
this
.
_toRemoteObject
(
exception
)
}
}
;
}
_serialize
(
obj
)
{
const
result
=
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
JSON
.
stringify
(
e
)
"
{
e
:
obj
}
)
;
if
(
result
.
throw
)
{
throw
new
Error
(
"
Object
is
not
serializable
"
)
;
}
return
JSON
.
parse
(
result
.
return
)
;
}
_createRemoteObject
(
debuggerObj
)
{
if
(
debuggerObj
instanceof
Debugger
.
Object
)
{
const
objectId
=
uuid
(
)
;
this
.
_remoteObjects
.
set
(
objectId
debuggerObj
)
;
const
rawObj
=
debuggerObj
.
unsafeDereference
(
)
;
const
cls
=
debuggerObj
.
class
;
let
subtype
;
if
(
debuggerObj
.
isProxy
)
{
subtype
=
"
proxy
"
;
}
else
if
(
cls
=
=
"
Array
"
)
{
subtype
=
"
array
"
;
}
else
if
(
cls
=
=
"
RegExp
"
)
{
subtype
=
"
regexp
"
;
}
else
if
(
cls
=
=
"
Date
"
)
{
subtype
=
"
date
"
;
}
else
if
(
cls
=
=
"
Map
"
)
{
subtype
=
"
map
"
;
}
else
if
(
cls
=
=
"
Set
"
)
{
subtype
=
"
set
"
;
}
else
if
(
cls
=
=
"
WeakMap
"
)
{
subtype
=
"
weakmap
"
;
}
else
if
(
cls
=
=
"
WeakSet
"
)
{
subtype
=
"
weakset
"
;
}
else
if
(
cls
=
=
"
Error
"
)
{
subtype
=
"
error
"
;
}
else
if
(
cls
=
=
"
Promise
"
)
{
subtype
=
"
promise
"
;
}
else
if
(
TYPED_ARRAY_CLASSES
.
includes
(
cls
)
)
{
subtype
=
"
typedarray
"
;
}
else
if
(
cls
=
=
"
Object
"
&
&
Node
.
isInstance
(
rawObj
)
)
{
subtype
=
"
node
"
;
}
const
type
=
typeof
rawObj
;
return
{
objectId
type
subtype
}
;
}
const
type
=
typeof
debuggerObj
;
if
(
type
=
=
"
symbol
"
|
|
type
=
=
"
bigint
"
)
{
const
objectId
=
uuid
(
)
;
this
.
_remoteObjects
.
set
(
objectId
debuggerObj
)
;
return
{
objectId
type
}
;
}
let
unserializableValue
=
undefined
;
if
(
Object
.
is
(
debuggerObj
NaN
)
)
unserializableValue
=
"
NaN
"
;
else
if
(
Object
.
is
(
debuggerObj
-
0
)
)
unserializableValue
=
"
-
0
"
;
else
if
(
Object
.
is
(
debuggerObj
Infinity
)
)
unserializableValue
=
"
Infinity
"
;
else
if
(
Object
.
is
(
debuggerObj
-
Infinity
)
)
unserializableValue
=
"
-
Infinity
"
;
if
(
unserializableValue
)
{
return
{
unserializableValue
}
;
}
let
subtype
;
if
(
debuggerObj
=
=
=
null
)
{
subtype
=
"
null
"
;
}
return
{
type
subtype
value
:
debuggerObj
}
;
}
}
