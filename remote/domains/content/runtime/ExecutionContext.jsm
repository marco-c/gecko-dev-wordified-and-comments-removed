"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExecutionContext
"
]
;
const
uuidGen
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
TYPED_ARRAY_CLASSES
=
[
"
Uint8Array
"
"
Uint8ClampedArray
"
"
Uint16Array
"
"
Uint32Array
"
"
Int8Array
"
"
Int16Array
"
"
Int32Array
"
"
Float32Array
"
"
Float64Array
"
]
;
function
uuid
(
)
{
return
uuidGen
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
}
class
ExecutionContext
{
constructor
(
dbg
debuggee
)
{
this
.
_debugger
=
dbg
;
this
.
_debuggee
=
this
.
_debugger
.
addDebuggee
(
debuggee
)
;
const
{
windowUtils
}
=
debuggee
;
this
.
id
=
windowUtils
.
currentInnerWindowID
;
this
.
frameId
=
windowUtils
.
outerWindowID
;
this
.
_remoteObjects
=
new
Map
(
)
;
}
destructor
(
)
{
this
.
_debugger
.
removeDebuggee
(
this
.
_debuggee
)
;
}
hasRemoteObject
(
id
)
{
return
this
.
_remoteObjects
.
has
(
id
)
;
}
getRemoteObject
(
id
)
{
return
this
.
_remoteObjects
.
get
(
id
)
;
}
releaseObject
(
id
)
{
return
this
.
_remoteObjects
.
delete
(
id
)
;
}
evaluate
(
expression
)
{
let
rv
=
this
.
_debuggee
.
executeInGlobal
(
expression
)
;
if
(
!
rv
)
{
return
{
exceptionDetails
:
{
text
:
"
Evaluation
terminated
!
"
}
}
;
}
if
(
rv
.
throw
)
{
return
this
.
_returnError
(
rv
.
throw
)
;
}
return
{
result
:
this
.
_toRemoteObject
(
rv
.
return
)
}
;
}
_returnError
(
exception
)
{
if
(
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
exception
instanceof
Error
"
{
exception
}
)
.
return
)
{
const
text
=
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
exception
.
message
"
{
exception
}
)
.
return
;
return
{
exceptionDetails
:
{
text
}
}
;
}
return
{
exceptionDetails
:
{
exception
:
this
.
_toRemoteObject
(
exception
)
}
}
;
}
async
callFunctionOn
(
functionDeclaration
callArguments
=
[
]
returnByValue
=
false
awaitPromise
=
false
objectId
=
null
)
{
let
thisArg
=
null
;
if
(
objectId
)
{
thisArg
=
this
.
_remoteObjects
.
get
(
objectId
)
;
if
(
!
thisArg
)
{
throw
new
Error
(
Unable
to
get
target
object
with
id
:
{
objectId
}
)
;
}
}
const
fun
=
this
.
_debuggee
.
executeInGlobal
(
"
(
"
+
functionDeclaration
+
"
)
"
)
;
if
(
!
fun
)
{
return
{
exceptionDetails
:
{
text
:
"
Evaluation
terminated
!
"
}
}
;
}
if
(
fun
.
throw
)
{
return
this
.
_returnError
(
fun
.
throw
)
;
}
const
args
=
callArguments
.
map
(
arg
=
>
this
.
_fromCallArgument
(
arg
)
)
;
const
rv
=
fun
.
return
.
apply
(
thisArg
args
)
;
if
(
rv
.
throw
)
{
return
this
.
_returnError
(
rv
.
throw
)
;
}
let
result
=
rv
.
return
;
if
(
result
&
&
result
.
isPromise
&
&
awaitPromise
)
{
if
(
result
.
promiseState
=
=
=
"
fulfilled
"
)
{
result
=
result
.
promiseValue
;
}
else
if
(
result
.
promiseState
=
=
=
"
rejected
"
)
{
return
this
.
_returnError
(
result
.
promiseReason
)
;
}
else
{
try
{
const
promiseResult
=
await
result
.
unsafeDereference
(
)
;
result
=
this
.
_debuggee
.
makeDebuggeeValue
(
promiseResult
)
;
}
catch
(
e
)
{
return
this
.
_returnError
(
e
)
;
}
}
}
if
(
returnByValue
)
{
return
{
result
:
{
value
:
this
.
_serialize
(
result
)
}
}
;
}
return
{
result
:
this
.
_toRemoteObject
(
result
)
}
;
}
getProperties
(
{
objectId
ownProperties
}
)
{
let
obj
=
this
.
getRemoteObject
(
objectId
)
;
if
(
!
obj
)
{
throw
new
Error
(
"
Cannot
find
object
with
id
=
"
+
objectId
)
;
}
const
result
=
[
]
;
const
serializeObject
=
(
obj
isOwn
)
=
>
{
for
(
const
propertyName
of
obj
.
getOwnPropertyNames
(
)
)
{
const
descriptor
=
obj
.
getOwnPropertyDescriptor
(
propertyName
)
;
result
.
push
(
{
name
:
propertyName
configurable
:
descriptor
.
configurable
enumerable
:
descriptor
.
enumerable
writable
:
descriptor
.
writable
value
:
this
.
_toRemoteObject
(
descriptor
.
value
)
get
:
descriptor
.
get
?
this
.
_toRemoteObject
(
descriptor
.
get
)
:
undefined
set
:
descriptor
.
set
?
this
.
_toRemoteObject
(
descriptor
.
set
)
:
undefined
isOwn
}
)
;
}
}
;
serializeObject
(
obj
true
)
;
if
(
!
ownProperties
)
{
while
(
true
)
{
obj
=
obj
.
proto
;
if
(
!
obj
)
{
break
;
}
serializeObject
(
obj
false
)
;
}
}
return
{
result
}
;
}
_serialize
(
obj
)
{
if
(
typeof
(
obj
)
=
=
"
undefined
"
)
{
return
undefined
;
}
const
result
=
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
JSON
.
stringify
(
e
)
"
{
e
:
obj
}
)
;
if
(
result
.
throw
)
{
throw
new
Error
(
"
Object
is
not
serializable
"
)
;
}
return
JSON
.
parse
(
result
.
return
)
;
}
_fromCallArgument
(
arg
)
{
if
(
arg
.
objectId
)
{
if
(
!
this
.
_remoteObjects
.
has
(
arg
.
objectId
)
)
{
throw
new
Error
(
Cannot
find
object
with
ID
:
{
arg
.
objectId
}
)
;
}
return
this
.
_remoteObjects
.
get
(
arg
.
objectId
)
;
}
if
(
arg
.
unserializableValue
)
{
switch
(
arg
.
unserializableValue
)
{
case
"
Infinity
"
:
return
Infinity
;
case
"
-
Infinity
"
:
return
-
Infinity
;
case
"
-
0
"
:
return
-
0
;
case
"
NaN
"
:
return
NaN
;
}
}
return
this
.
_deserialize
(
arg
.
value
)
;
}
_deserialize
(
obj
)
{
if
(
typeof
obj
!
=
=
"
object
"
)
{
return
obj
;
}
const
result
=
this
.
_debuggee
.
executeInGlobalWithBindings
(
"
JSON
.
parse
(
obj
)
"
{
obj
:
JSON
.
stringify
(
obj
)
}
)
;
if
(
result
.
throw
)
{
throw
new
Error
(
"
Unable
to
deserialize
object
"
)
;
}
return
result
.
return
;
}
_toRemoteObject
(
debuggerObj
)
{
if
(
debuggerObj
instanceof
Debugger
.
Object
)
{
const
objectId
=
uuid
(
)
;
this
.
_remoteObjects
.
set
(
objectId
debuggerObj
)
;
const
rawObj
=
debuggerObj
.
unsafeDereference
(
)
;
const
cls
=
debuggerObj
.
class
;
let
subtype
;
if
(
debuggerObj
.
isProxy
)
{
subtype
=
"
proxy
"
;
}
else
if
(
cls
=
=
"
Array
"
)
{
subtype
=
"
array
"
;
}
else
if
(
cls
=
=
"
RegExp
"
)
{
subtype
=
"
regexp
"
;
}
else
if
(
cls
=
=
"
Date
"
)
{
subtype
=
"
date
"
;
}
else
if
(
cls
=
=
"
Map
"
)
{
subtype
=
"
map
"
;
}
else
if
(
cls
=
=
"
Set
"
)
{
subtype
=
"
set
"
;
}
else
if
(
cls
=
=
"
WeakMap
"
)
{
subtype
=
"
weakmap
"
;
}
else
if
(
cls
=
=
"
WeakSet
"
)
{
subtype
=
"
weakset
"
;
}
else
if
(
cls
=
=
"
Error
"
)
{
subtype
=
"
error
"
;
}
else
if
(
cls
=
=
"
Promise
"
)
{
subtype
=
"
promise
"
;
}
else
if
(
TYPED_ARRAY_CLASSES
.
includes
(
cls
)
)
{
subtype
=
"
typedarray
"
;
}
else
if
(
Node
.
isInstance
(
rawObj
)
)
{
subtype
=
"
node
"
;
}
const
type
=
typeof
rawObj
;
return
{
objectId
type
subtype
}
;
}
const
type
=
typeof
debuggerObj
;
if
(
type
=
=
"
symbol
"
|
|
type
=
=
"
bigint
"
)
{
const
objectId
=
uuid
(
)
;
this
.
_remoteObjects
.
set
(
objectId
debuggerObj
)
;
return
{
objectId
type
}
;
}
let
unserializableValue
=
undefined
;
if
(
Object
.
is
(
debuggerObj
NaN
)
)
unserializableValue
=
"
NaN
"
;
else
if
(
Object
.
is
(
debuggerObj
-
0
)
)
unserializableValue
=
"
-
0
"
;
else
if
(
Object
.
is
(
debuggerObj
Infinity
)
)
unserializableValue
=
"
Infinity
"
;
else
if
(
Object
.
is
(
debuggerObj
-
Infinity
)
)
unserializableValue
=
"
-
Infinity
"
;
if
(
unserializableValue
)
{
return
{
unserializableValue
}
;
}
let
subtype
;
if
(
debuggerObj
=
=
=
null
)
{
subtype
=
"
null
"
;
}
return
{
type
subtype
value
:
debuggerObj
}
;
}
}
