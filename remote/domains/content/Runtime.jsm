"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Runtime
"
]
;
const
{
ContentProcessDomain
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
ContentProcessDomain
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
ExecutionContext
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
content
/
runtime
/
ExecutionContext
.
jsm
"
)
;
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
{
}
)
;
addDebuggerToGlobal
(
Cu
.
getGlobalForObject
(
this
)
)
;
class
Runtime
extends
ContentProcessDomain
{
constructor
(
session
)
{
super
(
session
)
;
this
.
enabled
=
false
;
this
.
contexts
=
new
Map
(
)
;
this
.
onContextCreated
=
this
.
onContextCreated
.
bind
(
this
)
;
this
.
onContextDestroyed
=
this
.
onContextDestroyed
.
bind
(
this
)
;
}
destructor
(
)
{
this
.
disable
(
)
;
super
.
destructor
(
)
;
}
async
enable
(
)
{
if
(
!
this
.
enabled
)
{
this
.
enabled
=
true
;
this
.
contextObserver
.
on
(
"
context
-
created
"
this
.
onContextCreated
)
;
this
.
contextObserver
.
on
(
"
context
-
destroyed
"
this
.
onContextDestroyed
)
;
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
this
.
onContextCreated
(
"
context
-
created
"
{
id
:
this
.
content
.
windowUtils
.
currentInnerWindowID
window
:
this
.
content
}
)
;
}
)
;
}
}
disable
(
)
{
if
(
this
.
enabled
)
{
this
.
enabled
=
false
;
this
.
contextObserver
.
off
(
"
context
-
created
"
this
.
onContextCreated
)
;
this
.
contextObserver
.
off
(
"
context
-
destroyed
"
this
.
onContextDestroyed
)
;
}
}
evaluate
(
{
expression
contextId
=
null
}
=
{
}
)
{
let
context
;
if
(
contextId
)
{
context
=
this
.
contexts
.
get
(
contextId
)
;
if
(
!
context
)
{
throw
new
Error
(
Unable
to
find
execution
context
with
id
:
{
contextId
}
)
;
}
}
else
{
context
=
this
.
getCurrentContext
(
)
;
}
if
(
typeof
expression
!
=
"
string
"
)
{
throw
new
Error
(
Expecting
'
expression
'
attribute
to
be
a
string
.
+
But
was
:
{
typeof
expression
}
)
;
}
return
context
.
evaluate
(
expression
)
;
}
getRemoteObject
(
objectId
)
{
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
const
obj
=
ctx
.
getRemoteObject
(
objectId
)
;
if
(
typeof
obj
!
=
"
undefined
"
)
{
return
obj
;
}
}
return
null
;
}
releaseObject
(
{
objectId
}
)
{
let
context
=
null
;
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
if
(
ctx
.
hasRemoteObject
(
objectId
)
)
{
context
=
ctx
;
break
;
}
}
if
(
!
context
)
{
throw
new
Error
(
Unable
to
get
execution
context
by
ID
:
{
objectId
}
)
;
}
context
.
releaseObject
(
objectId
)
;
}
callFunctionOn
(
request
)
{
let
context
=
null
;
if
(
request
.
objectId
)
{
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
if
(
ctx
.
hasRemoteObject
(
request
.
objectId
)
)
{
context
=
ctx
;
break
;
}
}
if
(
!
context
)
{
throw
new
Error
(
Unable
to
get
the
context
for
object
with
id
:
{
request
.
objectId
}
)
;
}
}
else
{
context
=
this
.
contexts
.
get
(
request
.
executionContextId
)
;
if
(
!
context
)
{
throw
new
Error
(
Unable
to
find
execution
context
with
id
:
{
request
.
executionContextId
}
)
;
}
}
if
(
typeof
request
.
functionDeclaration
!
=
"
string
"
)
{
throw
new
Error
(
"
Expect
'
functionDeclaration
'
attribute
to
be
passed
and
be
a
string
"
)
;
}
if
(
request
.
arguments
&
&
!
Array
.
isArray
(
request
.
arguments
)
)
{
throw
new
Error
(
"
Expect
'
arguments
'
to
be
an
array
"
)
;
}
if
(
request
.
returnByValue
&
&
typeof
request
.
returnByValue
!
=
"
boolean
"
)
{
throw
new
Error
(
"
Expect
'
returnByValue
'
to
be
a
boolean
"
)
;
}
if
(
request
.
awaitPromise
&
&
typeof
request
.
awaitPromise
!
=
"
boolean
"
)
{
throw
new
Error
(
"
Expect
'
awaitPromise
'
to
be
a
boolean
"
)
;
}
return
context
.
callFunctionOn
(
request
.
functionDeclaration
request
.
arguments
request
.
returnByValue
request
.
awaitPromise
request
.
objectId
)
;
}
getProperties
(
{
objectId
ownProperties
}
)
{
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
const
obj
=
ctx
.
getRemoteObject
(
objectId
)
;
if
(
typeof
obj
!
=
"
undefined
"
)
{
return
ctx
.
getProperties
(
{
objectId
ownProperties
}
)
;
}
}
return
null
;
}
get
_debugger
(
)
{
if
(
this
.
__debugger
)
{
return
this
.
__debugger
;
}
this
.
__debugger
=
new
Debugger
(
)
;
return
this
.
__debugger
;
}
getCurrentContext
(
)
{
const
{
windowUtils
}
=
this
.
content
;
return
this
.
contexts
.
get
(
windowUtils
.
currentInnerWindowID
)
;
}
getContextByFrameId
(
frameId
)
{
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
if
(
ctx
.
frameId
=
=
frameId
)
{
return
ctx
;
}
}
return
null
;
}
onContextCreated
(
name
{
id
window
}
)
{
if
(
this
.
contexts
.
has
(
id
)
)
{
return
;
}
const
context
=
new
ExecutionContext
(
this
.
_debugger
window
)
;
this
.
contexts
.
set
(
id
context
)
;
this
.
emit
(
"
Runtime
.
executionContextCreated
"
{
context
:
{
id
auxData
:
{
isDefault
:
window
=
=
this
.
content
frameId
:
context
.
frameId
}
}
}
)
;
}
onContextDestroyed
(
name
{
id
frameId
}
)
{
let
context
;
if
(
id
&
&
frameId
)
{
throw
new
Error
(
"
Expects
only
id
*
or
*
frameId
argument
to
be
passed
"
)
;
}
if
(
id
)
{
context
=
this
.
contexts
.
get
(
id
)
;
}
else
{
context
=
this
.
getContextByFrameId
(
frameId
)
;
}
if
(
context
)
{
context
.
destructor
(
)
;
this
.
contexts
.
delete
(
context
.
id
)
;
this
.
emit
(
"
Runtime
.
executionContextDestroyed
"
{
executionContextId
:
context
.
id
}
)
;
}
}
}
