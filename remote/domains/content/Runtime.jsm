"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Runtime
"
]
;
const
{
addDebuggerToGlobal
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
{
}
)
;
const
{
ContentProcessDomain
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
ContentProcessDomain
.
jsm
"
)
;
const
{
ExecutionContext
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
content
/
runtime
/
ExecutionContext
.
jsm
"
)
;
const
{
executeSoon
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Sync
.
jsm
"
)
;
addDebuggerToGlobal
(
Cu
.
getGlobalForObject
(
this
)
)
;
class
SetMap
extends
Map
{
constructor
(
)
{
super
(
)
;
this
.
_count
=
1
;
}
set
(
key
value
)
{
const
innerSet
=
this
.
get
(
key
)
;
if
(
innerSet
)
{
innerSet
.
add
(
value
)
;
}
else
{
super
.
set
(
key
new
Set
(
[
value
]
)
)
;
}
this
.
_count
+
+
;
return
this
;
}
get
count
(
)
{
return
this
.
_count
;
}
}
class
Runtime
extends
ContentProcessDomain
{
constructor
(
session
)
{
super
(
session
)
;
this
.
enabled
=
false
;
this
.
contexts
=
new
Map
(
)
;
this
.
contextsByWindow
=
new
SetMap
(
)
;
this
.
_onContextCreated
=
this
.
_onContextCreated
.
bind
(
this
)
;
this
.
_onContextDestroyed
=
this
.
_onContextDestroyed
.
bind
(
this
)
;
this
.
contextObserver
.
on
(
"
context
-
created
"
this
.
_onContextCreated
)
;
this
.
contextObserver
.
on
(
"
context
-
destroyed
"
this
.
_onContextDestroyed
)
;
}
destructor
(
)
{
this
.
disable
(
)
;
this
.
contextObserver
.
off
(
"
context
-
created
"
this
.
_onContextCreated
)
;
this
.
contextObserver
.
off
(
"
context
-
destroyed
"
this
.
_onContextDestroyed
)
;
super
.
destructor
(
)
;
}
async
enable
(
)
{
if
(
!
this
.
enabled
)
{
this
.
enabled
=
true
;
executeSoon
(
(
)
=
>
{
this
.
_onContextCreated
(
"
context
-
created
"
{
windowId
:
this
.
content
.
windowUtils
.
currentInnerWindowID
window
:
this
.
content
isDefault
:
true
}
)
;
}
)
;
}
}
disable
(
)
{
if
(
this
.
enabled
)
{
this
.
enabled
=
false
;
}
}
releaseObject
(
{
objectId
}
)
{
let
context
=
null
;
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
if
(
ctx
.
hasRemoteObject
(
objectId
)
)
{
context
=
ctx
;
break
;
}
}
if
(
!
context
)
{
throw
new
Error
(
Unable
to
get
execution
context
by
object
ID
:
{
objectId
}
)
;
}
context
.
releaseObject
(
objectId
)
;
}
callFunctionOn
(
options
=
{
}
)
{
if
(
typeof
options
.
functionDeclaration
!
=
"
string
"
)
{
throw
new
TypeError
(
"
functionDeclaration
:
string
value
expected
"
)
;
}
if
(
typeof
options
.
arguments
!
=
"
undefined
"
&
&
!
Array
.
isArray
(
options
.
arguments
)
)
{
throw
new
TypeError
(
"
arguments
:
array
value
expected
"
)
;
}
if
(
!
[
"
undefined
"
"
boolean
"
]
.
includes
(
typeof
options
.
awaitPromise
)
)
{
throw
new
TypeError
(
"
awaitPromise
:
boolean
value
expected
"
)
;
}
if
(
!
[
"
undefined
"
"
number
"
]
.
includes
(
typeof
options
.
executionContextId
)
)
{
throw
new
TypeError
(
"
executionContextId
:
number
value
expected
"
)
;
}
if
(
!
[
"
undefined
"
"
string
"
]
.
includes
(
typeof
options
.
objectId
)
)
{
throw
new
TypeError
(
"
objectId
:
string
value
expected
"
)
;
}
if
(
!
[
"
undefined
"
"
boolean
"
]
.
includes
(
typeof
options
.
returnByValue
)
)
{
throw
new
TypeError
(
"
returnByValue
:
boolean
value
expected
"
)
;
}
if
(
typeof
options
.
executionContextId
=
=
"
undefined
"
&
&
typeof
options
.
objectId
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Either
objectId
or
executionContextId
must
be
specified
"
)
;
}
let
context
=
null
;
if
(
options
.
objectId
)
{
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
if
(
ctx
.
hasRemoteObject
(
options
.
objectId
)
)
{
context
=
ctx
;
break
;
}
}
if
(
!
context
)
{
throw
new
Error
(
Unable
to
get
the
context
for
object
with
id
:
{
options
.
objectId
}
)
;
}
}
else
{
context
=
this
.
contexts
.
get
(
options
.
executionContextId
)
;
if
(
!
context
)
{
throw
new
Error
(
"
Cannot
find
context
with
specified
id
"
)
;
}
}
return
context
.
callFunctionOn
(
options
.
functionDeclaration
options
.
arguments
options
.
returnByValue
options
.
awaitPromise
options
.
objectId
)
;
}
evaluate
(
options
=
{
}
)
{
const
{
expression
awaitPromise
=
false
contextId
returnByValue
=
false
}
=
options
;
if
(
typeof
expression
!
=
"
string
"
)
{
throw
new
Error
(
"
expression
:
string
value
expected
"
)
;
}
if
(
!
[
"
undefined
"
"
boolean
"
]
.
includes
(
typeof
options
.
awaitPromise
)
)
{
throw
new
TypeError
(
"
awaitPromise
:
boolean
value
expected
"
)
;
}
if
(
typeof
returnByValue
!
=
"
boolean
"
)
{
throw
new
Error
(
"
returnByValue
:
boolean
value
expected
"
)
;
}
let
context
;
if
(
typeof
contextId
!
=
"
undefined
"
)
{
context
=
this
.
contexts
.
get
(
contextId
)
;
if
(
!
context
)
{
throw
new
Error
(
"
Cannot
find
context
with
specified
id
"
)
;
}
}
else
{
context
=
this
.
_getDefaultContextForWindow
(
)
;
}
return
context
.
evaluate
(
expression
awaitPromise
returnByValue
)
;
}
getProperties
(
{
objectId
ownProperties
}
)
{
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
const
debuggerObj
=
ctx
.
getRemoteObject
(
objectId
)
;
if
(
debuggerObj
)
{
return
ctx
.
getProperties
(
{
objectId
ownProperties
}
)
;
}
}
return
null
;
}
get
_debugger
(
)
{
if
(
this
.
__debugger
)
{
return
this
.
__debugger
;
}
this
.
__debugger
=
new
Debugger
(
)
;
return
this
.
__debugger
;
}
_getRemoteObject
(
objectId
)
{
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
const
debuggerObj
=
ctx
.
getRemoteObject
(
objectId
)
;
if
(
debuggerObj
)
{
return
debuggerObj
;
}
}
return
null
;
}
_serializeRemoteObject
(
debuggerObj
executionContextId
)
{
const
ctx
=
this
.
contexts
.
get
(
executionContextId
)
;
return
ctx
.
_toRemoteObject
(
debuggerObj
)
;
}
_getRemoteObjectByNodeId
(
nodeId
executionContextId
)
{
let
debuggerObj
=
null
;
if
(
typeof
executionContextId
!
=
"
undefined
"
)
{
const
ctx
=
this
.
contexts
.
get
(
executionContextId
)
;
debuggerObj
=
ctx
.
getRemoteObjectByNodeId
(
nodeId
)
;
}
else
{
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
const
obj
=
ctx
.
getRemoteObjectByNodeId
(
nodeId
)
;
if
(
obj
)
{
debuggerObj
=
obj
;
break
;
}
}
}
return
debuggerObj
;
}
_setRemoteObject
(
debuggerObj
context
)
{
return
context
.
setRemoteObject
(
debuggerObj
)
;
}
_getDefaultContextForWindow
(
innerWindowId
)
{
if
(
!
innerWindowId
)
{
const
{
windowUtils
}
=
this
.
content
;
innerWindowId
=
windowUtils
.
currentInnerWindowID
;
}
const
curContexts
=
this
.
contextsByWindow
.
get
(
innerWindowId
)
;
if
(
curContexts
)
{
for
(
const
ctx
of
curContexts
)
{
if
(
ctx
.
isDefault
)
{
return
ctx
;
}
}
}
return
null
;
}
_getContextsForFrame
(
frameId
)
{
const
frameContexts
=
[
]
;
for
(
const
ctx
of
this
.
contexts
.
values
(
)
)
{
if
(
ctx
.
frameId
=
=
frameId
)
{
frameContexts
.
push
(
ctx
)
;
}
}
return
frameContexts
;
}
_onContextCreated
(
name
options
=
{
}
)
{
const
{
windowId
window
contextName
=
"
"
isDefault
=
options
.
window
=
=
this
.
content
contextType
=
options
.
contextType
|
|
(
options
.
window
=
=
this
.
content
?
"
default
"
:
"
"
)
}
=
options
;
if
(
windowId
=
=
=
undefined
)
{
throw
new
Error
(
"
windowId
is
required
"
)
;
}
if
(
isDefault
&
&
this
.
contextsByWindow
.
has
(
windowId
)
)
{
for
(
const
ctx
of
this
.
contextsByWindow
.
get
(
windowId
)
)
{
if
(
ctx
.
isDefault
)
{
return
null
;
}
}
}
const
context
=
new
ExecutionContext
(
this
.
_debugger
window
this
.
contextsByWindow
.
count
isDefault
)
;
this
.
contexts
.
set
(
context
.
id
context
)
;
this
.
contextsByWindow
.
set
(
windowId
context
)
;
if
(
this
.
enabled
)
{
this
.
emit
(
"
Runtime
.
executionContextCreated
"
{
context
:
{
id
:
context
.
id
origin
:
window
.
location
.
href
name
:
contextName
auxData
:
{
isDefault
frameId
:
context
.
frameId
type
:
contextType
}
}
}
)
;
}
return
context
.
id
;
}
_onContextDestroyed
(
name
{
id
frameId
windowId
}
)
{
let
contexts
;
if
(
[
id
frameId
windowId
]
.
filter
(
id
=
>
!
!
id
)
.
length
>
1
)
{
throw
new
Error
(
"
Expects
only
*
one
*
of
id
frameId
windowId
"
)
;
}
if
(
id
)
{
contexts
=
[
this
.
contexts
.
get
(
id
)
]
;
}
else
if
(
frameId
)
{
contexts
=
this
.
_getContextsForFrame
(
frameId
)
;
}
else
{
contexts
=
this
.
contextsByWindow
.
get
(
windowId
)
|
|
[
]
;
}
for
(
const
ctx
of
contexts
)
{
ctx
.
destructor
(
)
;
this
.
contexts
.
delete
(
ctx
.
id
)
;
this
.
contextsByWindow
.
get
(
ctx
.
windowId
)
.
delete
(
ctx
)
;
if
(
this
.
enabled
)
{
this
.
emit
(
"
Runtime
.
executionContextDestroyed
"
{
executionContextId
:
ctx
.
id
}
)
;
}
if
(
this
.
contextsByWindow
.
get
(
ctx
.
windowId
)
.
size
=
=
0
)
{
this
.
contextsByWindow
.
delete
(
ctx
.
windowId
)
;
this
.
emit
(
"
Runtime
.
executionContextsCleared
"
)
;
}
}
}
}
