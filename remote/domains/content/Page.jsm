"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Page
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
ContentProcessDomain
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
ContentProcessDomain
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
uuidGen
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
const
{
LOAD_FLAGS_BYPASS_CACHE
LOAD_FLAGS_BYPASS_PROXY
LOAD_FLAGS_NONE
}
=
Ci
.
nsIWebNavigation
;
class
Page
extends
ContentProcessDomain
{
constructor
(
session
)
{
super
(
session
)
;
this
.
enabled
=
false
;
this
.
lifecycleEnabled
=
false
;
this
.
scriptsToEvaluateOnLoad
=
new
Map
(
)
;
this
.
worldsToEvaluateOnLoad
=
new
Set
(
)
;
this
.
_onFrameAttached
=
this
.
_onFrameAttached
.
bind
(
this
)
;
this
.
_onFrameDetached
=
this
.
_onFrameDetached
.
bind
(
this
)
;
this
.
_onFrameNavigated
=
this
.
_onFrameNavigated
.
bind
(
this
)
;
this
.
_onScriptLoaded
=
this
.
_onScriptLoaded
.
bind
(
this
)
;
this
.
session
.
contextObserver
.
on
(
"
script
-
loaded
"
this
.
_onScriptLoaded
)
;
}
destructor
(
)
{
this
.
setLifecycleEventsEnabled
(
{
enabled
:
false
}
)
;
this
.
session
.
contextObserver
.
off
(
"
script
-
loaded
"
this
.
_onScriptLoaded
)
;
this
.
disable
(
)
;
super
.
destructor
(
)
;
}
async
enable
(
)
{
if
(
!
this
.
enabled
)
{
this
.
session
.
contextObserver
.
on
(
"
frame
-
attached
"
this
.
_onFrameAttached
)
;
this
.
session
.
contextObserver
.
on
(
"
frame
-
detached
"
this
.
_onFrameDetached
)
;
this
.
session
.
contextObserver
.
on
(
"
frame
-
navigated
"
this
.
_onFrameNavigated
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
readystatechange
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
unload
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
DOMContentLoaded
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
load
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
pageshow
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
enabled
=
true
;
}
}
disable
(
)
{
if
(
this
.
enabled
)
{
this
.
session
.
contextObserver
.
off
(
"
frame
-
attached
"
this
.
_onFrameAttached
)
;
this
.
session
.
contextObserver
.
off
(
"
frame
-
detached
"
this
.
_onFrameDetached
)
;
this
.
session
.
contextObserver
.
off
(
"
frame
-
navigated
"
this
.
_onFrameNavigated
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
readystatechange
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
unload
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
DOMContentLoaded
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
load
"
this
{
mozSystemGroup
:
true
capture
:
true
}
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
pageshow
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
enabled
=
false
;
}
}
async
reload
(
{
ignoreCache
}
)
{
let
flags
=
LOAD_FLAGS_NONE
;
if
(
ignoreCache
)
{
flags
|
=
LOAD_FLAGS_BYPASS_CACHE
;
flags
|
=
LOAD_FLAGS_BYPASS_PROXY
;
}
this
.
docShell
.
reload
(
flags
)
;
}
getFrameTree
(
)
{
const
getFrames
=
context
=
>
{
const
frameTree
=
{
frame
:
this
.
_getFrameDetails
(
context
)
}
;
if
(
context
.
children
.
length
>
0
)
{
const
frames
=
[
]
;
for
(
const
childContext
of
context
.
children
)
{
frames
.
push
(
getFrames
(
childContext
)
)
;
}
frameTree
.
childFrames
=
frames
;
}
return
frameTree
;
}
;
return
{
frameTree
:
getFrames
(
this
.
docShell
.
browsingContext
)
}
;
}
addScriptToEvaluateOnNewDocument
(
options
=
{
}
)
{
const
{
source
worldName
}
=
options
;
if
(
worldName
)
{
this
.
worldsToEvaluateOnLoad
.
add
(
worldName
)
;
}
const
identifier
=
uuidGen
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
this
.
scriptsToEvaluateOnLoad
.
set
(
identifier
{
worldName
source
}
)
;
return
{
identifier
}
;
}
createIsolatedWorld
(
options
=
{
}
)
{
const
{
frameId
worldName
}
=
options
;
if
(
typeof
frameId
!
=
"
string
"
)
{
throw
new
TypeError
(
"
frameId
:
string
value
expected
"
)
;
}
if
(
!
[
"
undefined
"
"
string
"
]
.
includes
(
typeof
worldName
)
)
{
throw
new
TypeError
(
"
worldName
:
string
value
expected
"
)
;
}
const
Runtime
=
this
.
session
.
domains
.
get
(
"
Runtime
"
)
;
const
contexts
=
Runtime
.
_getContextsForFrame
(
frameId
)
;
if
(
contexts
.
length
=
=
0
)
{
throw
new
Error
(
"
No
frame
for
given
id
found
"
)
;
}
const
defaultContext
=
Runtime
.
_getDefaultContextForWindow
(
contexts
[
0
]
.
windowId
)
;
const
window
=
defaultContext
.
window
;
const
executionContextId
=
Runtime
.
_onContextCreated
(
"
context
-
created
"
{
windowId
:
window
.
windowUtils
.
currentInnerWindowID
window
isDefault
:
false
contextName
:
worldName
contextType
:
"
isolated
"
}
)
;
return
{
executionContextId
}
;
}
setLifecycleEventsEnabled
(
options
=
{
}
)
{
const
{
enabled
}
=
options
;
this
.
lifecycleEnabled
=
enabled
;
}
url
(
)
{
return
this
.
content
.
location
.
href
;
}
_onFrameAttached
(
name
{
frameId
parentFrameId
}
)
{
this
.
emit
(
"
Page
.
frameAttached
"
{
frameId
parentFrameId
stack
:
null
}
)
;
}
_onFrameDetached
(
name
{
frameId
}
)
{
this
.
emit
(
"
Page
.
frameDetached
"
{
frameId
}
)
;
}
_onFrameNavigated
(
name
{
frameId
window
}
)
{
const
url
=
window
.
location
.
href
;
this
.
emit
(
"
Page
.
frameNavigated
"
{
frame
:
{
id
:
frameId
parentId
:
null
url
}
}
)
;
}
_onScriptLoaded
(
name
options
=
{
}
)
{
const
{
windowId
window
}
=
options
;
const
Runtime
=
this
.
session
.
domains
.
get
(
"
Runtime
"
)
;
for
(
const
world
of
this
.
worldsToEvaluateOnLoad
)
{
Runtime
.
_onContextCreated
(
"
context
-
created
"
{
windowId
window
isDefault
:
false
contextName
:
world
contextType
:
"
isolated
"
}
)
;
}
}
emitLifecycleEvent
(
frameId
loaderId
name
timestamp
)
{
if
(
this
.
lifecycleEnabled
)
{
this
.
emit
(
"
Page
.
lifecycleEvent
"
{
frameId
loaderId
name
timestamp
}
)
;
}
}
handleEvent
(
{
type
target
}
)
{
if
(
target
.
defaultView
!
=
this
.
content
)
{
return
;
}
const
timestamp
=
Date
.
now
(
)
/
1000
;
const
frameId
=
target
.
defaultView
.
docShell
.
browsingContext
.
id
.
toString
(
)
;
const
url
=
target
.
location
.
href
;
const
loaderId
=
this
.
_lastRequest
?
.
frameId
=
=
frameId
?
this
.
_lastRequest
?
.
loaderId
:
null
;
switch
(
type
)
{
case
"
DOMContentLoaded
"
:
this
.
emit
(
"
Page
.
domContentEventFired
"
{
timestamp
}
)
;
this
.
emitLifecycleEvent
(
frameId
loaderId
"
DOMContentLoaded
"
timestamp
)
;
break
;
case
"
pagehide
"
:
this
.
emit
(
"
Page
.
frameStartedLoading
"
{
frameId
}
)
;
this
.
emitLifecycleEvent
(
frameId
loaderId
"
init
"
timestamp
)
;
break
;
case
"
load
"
:
this
.
emit
(
"
Page
.
loadEventFired
"
{
timestamp
}
)
;
this
.
emitLifecycleEvent
(
frameId
loaderId
"
load
"
timestamp
)
;
this
.
emit
(
"
Page
.
navigatedWithinDocument
"
{
frameId
url
}
)
;
this
.
emit
(
"
Page
.
frameStoppedLoading
"
{
frameId
}
)
;
break
;
case
"
readystatechange
"
:
if
(
this
.
content
.
document
.
readState
=
=
=
"
loading
"
)
{
this
.
emitLifecycleEvent
(
frameId
loaderId
"
init
"
timestamp
)
;
}
}
}
_updateLoaderId
(
data
)
{
this
.
_lastRequest
=
data
;
}
_contentRect
(
)
{
const
docEl
=
this
.
content
.
document
.
documentElement
;
return
{
x
:
0
y
:
0
width
:
docEl
.
scrollWidth
height
:
docEl
.
scrollHeight
}
;
}
_devicePixelRatio
(
)
{
return
this
.
content
.
devicePixelRatio
;
}
_getFrameDetails
(
context
)
{
const
frame
=
{
id
:
context
.
id
.
toString
(
)
loaderId
:
null
name
:
null
url
:
context
.
docShell
.
domWindow
.
location
.
href
securityOrigin
:
null
mimeType
:
null
}
;
if
(
context
.
parent
)
{
frame
.
parentId
=
context
.
parent
.
id
.
toString
(
)
;
}
return
frame
;
}
_getScrollbarSize
(
)
{
const
scrollbarHeight
=
{
}
;
const
scrollbarWidth
=
{
}
;
this
.
content
.
windowUtils
.
getScrollbarSize
(
false
scrollbarWidth
scrollbarHeight
)
;
return
{
width
:
scrollbarWidth
.
value
height
:
scrollbarHeight
.
value
}
;
}
_layoutViewport
(
)
{
const
scrollbarSize
=
this
.
_getScrollbarSize
(
)
;
return
{
pageX
:
this
.
content
.
pageXOffset
pageY
:
this
.
content
.
pageYOffset
clientWidth
:
this
.
content
.
innerWidth
-
scrollbarSize
.
width
clientHeight
:
this
.
content
.
innerHeight
-
scrollbarSize
.
height
}
;
}
}
