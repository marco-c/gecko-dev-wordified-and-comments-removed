"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
deserialize
"
"
serialize
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
InvalidArgumentError
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
lazy
.
Log
.
TYPES
.
WEBDRIVER_BIDI
)
)
;
function
deserialize
(
serializedValue
)
{
const
{
objectId
type
value
}
=
serializedValue
;
if
(
type
!
=
=
undefined
)
{
lazy
.
assert
.
string
(
type
Expected
"
type
"
to
be
a
string
got
{
type
}
)
;
}
if
(
objectId
!
=
=
undefined
)
{
lazy
.
assert
.
string
(
objectId
Expected
"
objectId
"
to
be
a
string
got
{
objectId
}
)
;
lazy
.
logger
.
warn
(
Unsupported
type
remote
reference
with
objectId
{
objectId
}
)
;
return
undefined
;
}
switch
(
type
)
{
case
"
undefined
"
:
return
undefined
;
case
"
null
"
:
return
null
;
case
"
string
"
:
lazy
.
assert
.
string
(
value
Expected
"
value
"
to
be
a
string
got
{
value
}
)
;
return
value
;
case
"
number
"
:
if
(
typeof
value
=
=
=
"
number
"
)
{
return
value
;
}
lazy
.
assert
.
in
(
value
[
"
NaN
"
"
-
0
"
"
+
Infinity
"
"
-
Infinity
"
]
)
;
return
Number
(
value
)
;
case
"
boolean
"
:
lazy
.
assert
.
boolean
(
value
Expected
"
value
"
to
be
a
boolean
got
{
value
}
)
;
return
value
;
case
"
bigint
"
:
lazy
.
assert
.
string
(
value
Expected
"
value
"
to
be
a
string
got
{
value
}
)
;
try
{
return
BigInt
(
value
)
;
}
catch
(
e
)
{
throw
new
lazy
.
InvalidArgumentError
(
Failed
to
deserialize
value
as
BigInt
:
{
value
}
)
;
}
}
lazy
.
logger
.
warn
(
Unsupported
type
for
local
value
{
type
}
)
;
return
undefined
;
}
function
serializeList
(
iterable
maxDepth
)
{
const
serialized
=
[
]
;
const
childDepth
=
maxDepth
!
=
=
null
?
maxDepth
-
1
:
null
;
for
(
const
item
of
iterable
)
{
serialized
.
push
(
serialize
(
item
childDepth
)
)
;
}
return
serialized
;
}
function
serializeMapping
(
iterable
maxDepth
)
{
const
serialized
=
[
]
;
const
childDepth
=
maxDepth
!
=
=
null
?
maxDepth
-
1
:
null
;
for
(
const
[
key
item
]
of
iterable
)
{
const
serializedKey
=
typeof
key
=
=
"
string
"
?
key
:
serialize
(
key
childDepth
)
;
const
serializedValue
=
serialize
(
item
childDepth
)
;
serialized
.
push
(
[
serializedKey
serializedValue
]
)
;
}
return
serialized
;
}
function
serialize
(
value
maxDepth
)
{
const
type
=
typeof
value
;
if
(
type
=
=
"
undefined
"
)
{
return
{
type
}
;
}
else
if
(
Object
.
is
(
value
null
)
)
{
return
{
type
:
"
null
"
}
;
}
else
if
(
Object
.
is
(
value
NaN
)
)
{
return
{
type
:
"
number
"
value
:
"
NaN
"
}
;
}
else
if
(
Object
.
is
(
value
-
0
)
)
{
return
{
type
:
"
number
"
value
:
"
-
0
"
}
;
}
else
if
(
Object
.
is
(
value
Infinity
)
)
{
return
{
type
:
"
number
"
value
:
"
+
Infinity
"
}
;
}
else
if
(
Object
.
is
(
value
-
Infinity
)
)
{
return
{
type
:
"
number
"
value
:
"
-
Infinity
"
}
;
}
else
if
(
type
=
=
"
bigint
"
)
{
return
{
type
value
:
value
.
toString
(
)
}
;
}
else
if
(
[
"
boolean
"
"
number
"
"
string
"
]
.
includes
(
type
)
)
{
return
{
type
value
}
;
}
const
className
=
ChromeUtils
.
getClassName
(
value
)
;
if
(
className
=
=
"
Array
"
)
{
const
remoteValue
=
{
type
:
"
array
"
}
;
if
(
maxDepth
!
=
=
null
&
&
maxDepth
>
0
)
{
remoteValue
.
value
=
serializeList
(
value
maxDepth
)
;
}
return
remoteValue
;
}
else
if
(
className
=
=
"
RegExp
"
)
{
return
{
type
:
"
regexp
"
value
:
{
pattern
:
value
.
source
flags
:
value
.
flags
}
}
;
}
else
if
(
className
=
=
"
Date
"
)
{
return
{
type
:
"
date
"
value
:
value
.
toISOString
(
)
}
;
}
else
if
(
className
=
=
"
Map
"
)
{
const
remoteValue
=
{
type
:
"
map
"
}
;
if
(
maxDepth
!
=
=
null
&
&
maxDepth
>
0
)
{
remoteValue
.
value
=
serializeMapping
(
value
.
entries
(
)
maxDepth
)
;
}
return
remoteValue
;
}
else
if
(
className
=
=
"
Set
"
)
{
const
remoteValue
=
{
type
:
"
set
"
}
;
if
(
maxDepth
!
=
=
null
&
&
maxDepth
>
0
)
{
remoteValue
.
value
=
serializeList
(
value
.
values
(
)
maxDepth
)
;
}
return
remoteValue
;
}
lazy
.
logger
.
warn
(
Unsupported
type
:
{
type
}
for
remote
value
:
{
value
.
toString
(
)
}
)
;
return
undefined
;
}
