"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
deserialize
"
"
OwnershipModel
"
"
serialize
"
"
stringify
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
sys
.
mjs
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
sys
.
mjs
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
lazy
.
Log
.
TYPES
.
WEBDRIVER_BIDI
)
)
;
const
OwnershipModel
=
{
None
:
"
none
"
Root
:
"
root
"
}
;
function
getUUID
(
)
{
return
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
}
const
TYPED_ARRAY_CLASSES
=
[
"
Uint8Array
"
"
Uint8ClampedArray
"
"
Uint16Array
"
"
Uint32Array
"
"
Int8Array
"
"
Int16Array
"
"
Int32Array
"
"
Float32Array
"
"
Float64Array
"
"
BigInt64Array
"
"
BigUint64Array
"
]
;
function
buildSerialized
(
type
handle
=
null
)
{
const
serialized
=
{
type
}
;
if
(
handle
!
=
=
null
)
{
serialized
.
handle
=
handle
;
}
return
serialized
;
}
function
checkDateTimeString
(
dateString
)
{
const
expandedYear
=
"
[
+
-
]
\
\
d
{
6
}
"
;
const
year
=
"
\
\
d
{
4
}
"
;
const
YYYY
=
{
expandedYear
}
|
{
year
}
;
const
MM
=
"
\
\
d
{
2
}
"
;
const
DD
=
"
\
\
d
{
2
}
"
;
const
date
=
{
YYYY
}
(
?
:
-
{
MM
}
)
?
(
?
:
-
{
DD
}
)
?
;
const
HH_mm
=
"
\
\
d
{
2
}
:
\
\
d
{
2
}
"
;
const
SS
=
"
\
\
d
{
2
}
"
;
const
sss
=
"
\
\
d
{
3
}
"
;
const
TZ
=
Z
|
[
+
-
]
{
HH_mm
}
;
const
time
=
T
{
HH_mm
}
(
?
:
:
{
SS
}
(
?
:
\
\
.
{
sss
}
)
?
(
?
:
{
TZ
}
)
?
)
?
;
const
iso8601Format
=
new
RegExp
(
^
{
date
}
(
?
:
{
time
}
)
?
)
;
if
(
Number
.
isNaN
(
Date
.
parse
(
dateString
)
)
|
|
!
iso8601Format
.
test
(
dateString
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
"
value
"
for
Date
to
be
a
Date
Time
string
got
{
dateString
}
)
;
}
}
function
deserializeValueList
(
realm
serializedValueList
)
{
lazy
.
assert
.
array
(
serializedValueList
Expected
"
serializedValueList
"
to
be
an
array
got
{
serializedValueList
}
)
;
const
deserializedValues
=
[
]
;
for
(
const
item
of
serializedValueList
)
{
deserializedValues
.
push
(
deserialize
(
realm
item
)
)
;
}
return
deserializedValues
;
}
function
deserializeKeyValueList
(
realm
serializedKeyValueList
)
{
lazy
.
assert
.
array
(
serializedKeyValueList
Expected
"
serializedKeyValueList
"
to
be
an
array
got
{
serializedKeyValueList
}
)
;
const
deserializedKeyValueList
=
[
]
;
for
(
const
serializedKeyValue
of
serializedKeyValueList
)
{
if
(
!
Array
.
isArray
(
serializedKeyValue
)
|
|
serializedKeyValue
.
length
!
=
2
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
key
-
value
pair
to
be
an
array
with
2
elements
got
{
serializedKeyValue
}
)
;
}
const
[
serializedKey
serializedValue
]
=
serializedKeyValue
;
const
deserializedKey
=
typeof
serializedKey
=
=
"
string
"
?
serializedKey
:
deserialize
(
realm
serializedKey
)
;
const
deserializedValue
=
deserialize
(
realm
serializedValue
)
;
deserializedKeyValueList
.
push
(
[
deserializedKey
deserializedValue
]
)
;
}
return
deserializedKeyValueList
;
}
function
deserialize
(
realm
serializedValue
)
{
const
{
handle
type
value
}
=
serializedValue
;
if
(
handle
!
=
=
undefined
)
{
lazy
.
assert
.
string
(
handle
Expected
"
handle
"
to
be
a
string
got
{
handle
}
)
;
const
object
=
realm
.
getObjectForHandle
(
handle
)
;
if
(
!
object
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Unable
to
find
an
object
reference
for
"
handle
"
{
handle
}
)
;
}
return
object
;
}
lazy
.
assert
.
string
(
type
Expected
"
type
"
to
be
a
string
got
{
type
}
)
;
switch
(
type
)
{
case
"
undefined
"
:
return
undefined
;
case
"
null
"
:
return
null
;
case
"
string
"
:
lazy
.
assert
.
string
(
value
Expected
"
value
"
to
be
a
string
got
{
value
}
)
;
return
value
;
case
"
number
"
:
if
(
typeof
value
=
=
=
"
number
"
)
{
return
value
;
}
lazy
.
assert
.
in
(
value
[
"
NaN
"
"
-
0
"
"
Infinity
"
"
-
Infinity
"
]
Expected
"
value
"
to
be
one
of
"
NaN
"
"
-
0
"
"
Infinity
"
"
-
Infinity
"
got
{
value
}
)
;
return
Number
(
value
)
;
case
"
boolean
"
:
lazy
.
assert
.
boolean
(
value
Expected
"
value
"
to
be
a
boolean
got
{
value
}
)
;
return
value
;
case
"
bigint
"
:
lazy
.
assert
.
string
(
value
Expected
"
value
"
to
be
a
string
got
{
value
}
)
;
try
{
return
BigInt
(
value
)
;
}
catch
(
e
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Failed
to
deserialize
value
as
BigInt
:
{
value
}
)
;
}
case
"
array
"
:
const
array
=
realm
.
cloneIntoRealm
(
[
]
)
;
deserializeValueList
(
realm
value
)
.
forEach
(
v
=
>
array
.
push
(
v
)
)
;
return
array
;
case
"
date
"
:
checkDateTimeString
(
value
)
;
return
realm
.
cloneIntoRealm
(
new
Date
(
value
)
)
;
case
"
map
"
:
const
map
=
realm
.
cloneIntoRealm
(
new
Map
(
)
)
;
deserializeKeyValueList
(
realm
value
)
.
forEach
(
(
[
k
v
]
)
=
>
map
.
set
(
k
v
)
)
;
return
map
;
case
"
object
"
:
const
object
=
realm
.
cloneIntoRealm
(
{
}
)
;
deserializeKeyValueList
(
realm
value
)
.
forEach
(
(
[
k
v
]
)
=
>
(
object
[
k
]
=
v
)
)
;
return
object
;
case
"
regexp
"
:
lazy
.
assert
.
object
(
value
Expected
"
value
"
for
RegExp
to
be
an
object
got
{
value
}
)
;
const
{
pattern
flags
}
=
value
;
lazy
.
assert
.
string
(
pattern
Expected
"
pattern
"
for
RegExp
to
be
a
string
got
{
pattern
}
)
;
if
(
flags
!
=
=
undefined
)
{
lazy
.
assert
.
string
(
flags
Expected
"
flags
"
for
RegExp
to
be
a
string
got
{
flags
}
)
;
}
try
{
return
realm
.
cloneIntoRealm
(
new
RegExp
(
pattern
flags
)
)
;
}
catch
(
e
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Failed
to
deserialize
value
as
RegExp
:
{
value
}
)
;
}
case
"
set
"
:
const
set
=
realm
.
cloneIntoRealm
(
new
Set
(
)
)
;
deserializeValueList
(
realm
value
)
.
forEach
(
v
=
>
set
.
add
(
v
)
)
;
return
set
;
}
lazy
.
logger
.
warn
(
Unsupported
type
for
local
value
{
type
}
)
;
return
undefined
;
}
function
getHandleForObject
(
realm
ownershipType
object
)
{
if
(
ownershipType
=
=
=
OwnershipModel
.
None
)
{
return
null
;
}
return
realm
.
getHandleForObject
(
object
)
;
}
function
serializeList
(
iterable
maxDepth
childOwnership
serializationInternalMap
realm
)
{
const
serialized
=
[
]
;
const
childDepth
=
maxDepth
!
=
=
null
?
maxDepth
-
1
:
null
;
for
(
const
item
of
iterable
)
{
serialized
.
push
(
serialize
(
item
childDepth
childOwnership
serializationInternalMap
realm
)
)
;
}
return
serialized
;
}
function
serializeMapping
(
iterable
maxDepth
childOwnership
serializationInternalMap
realm
)
{
const
serialized
=
[
]
;
const
childDepth
=
maxDepth
!
=
=
null
?
maxDepth
-
1
:
null
;
for
(
const
[
key
item
]
of
iterable
)
{
const
serializedKey
=
typeof
key
=
=
"
string
"
?
key
:
serialize
(
key
childDepth
childOwnership
serializationInternalMap
realm
)
;
const
serializedValue
=
serialize
(
item
childDepth
childOwnership
serializationInternalMap
realm
)
;
serialized
.
push
(
[
serializedKey
serializedValue
]
)
;
}
return
serialized
;
}
function
serialize
(
value
maxDepth
ownershipType
serializationInternalMap
realm
)
{
const
type
=
typeof
value
;
if
(
type
=
=
"
undefined
"
)
{
return
{
type
}
;
}
else
if
(
Object
.
is
(
value
null
)
)
{
return
{
type
:
"
null
"
}
;
}
else
if
(
Object
.
is
(
value
NaN
)
)
{
return
{
type
:
"
number
"
value
:
"
NaN
"
}
;
}
else
if
(
Object
.
is
(
value
-
0
)
)
{
return
{
type
:
"
number
"
value
:
"
-
0
"
}
;
}
else
if
(
Object
.
is
(
value
Infinity
)
)
{
return
{
type
:
"
number
"
value
:
"
Infinity
"
}
;
}
else
if
(
Object
.
is
(
value
-
Infinity
)
)
{
return
{
type
:
"
number
"
value
:
"
-
Infinity
"
}
;
}
else
if
(
type
=
=
"
bigint
"
)
{
return
{
type
value
:
value
.
toString
(
)
}
;
}
else
if
(
[
"
boolean
"
"
number
"
"
string
"
]
.
includes
(
type
)
)
{
return
{
type
value
}
;
}
const
handleId
=
getHandleForObject
(
realm
ownershipType
value
)
;
const
knownObject
=
serializationInternalMap
.
has
(
value
)
;
const
childOwnership
=
OwnershipModel
.
None
;
if
(
type
=
=
"
symbol
"
)
{
return
buildSerialized
(
"
symbol
"
handleId
)
;
}
const
className
=
ChromeUtils
.
getClassName
(
value
)
;
if
(
className
=
=
"
Array
"
)
{
const
serialized
=
buildSerialized
(
"
array
"
handleId
)
;
setInternalIdsIfNeeded
(
serializationInternalMap
serialized
value
)
;
if
(
!
knownObject
&
&
maxDepth
!
=
=
null
&
&
maxDepth
>
0
)
{
serialized
.
value
=
serializeList
(
value
maxDepth
childOwnership
serializationInternalMap
realm
)
;
}
return
serialized
;
}
else
if
(
className
=
=
"
RegExp
"
)
{
const
serialized
=
buildSerialized
(
"
regexp
"
handleId
)
;
serialized
.
value
=
{
pattern
:
value
.
source
flags
:
value
.
flags
}
;
return
serialized
;
}
else
if
(
className
=
=
"
Date
"
)
{
const
serialized
=
buildSerialized
(
"
date
"
handleId
)
;
serialized
.
value
=
value
.
toISOString
(
)
;
return
serialized
;
}
else
if
(
className
=
=
"
Map
"
)
{
const
serialized
=
buildSerialized
(
"
map
"
handleId
)
;
setInternalIdsIfNeeded
(
serializationInternalMap
serialized
value
)
;
if
(
!
knownObject
&
&
maxDepth
!
=
=
null
&
&
maxDepth
>
0
)
{
serialized
.
value
=
serializeMapping
(
value
.
entries
(
)
maxDepth
childOwnership
serializationInternalMap
realm
)
;
}
return
serialized
;
}
else
if
(
className
=
=
"
Set
"
)
{
const
serialized
=
buildSerialized
(
"
set
"
handleId
)
;
setInternalIdsIfNeeded
(
serializationInternalMap
serialized
value
)
;
if
(
!
knownObject
&
&
maxDepth
!
=
=
null
&
&
maxDepth
>
0
)
{
serialized
.
value
=
serializeList
(
value
.
values
(
)
maxDepth
childOwnership
serializationInternalMap
realm
)
;
}
return
serialized
;
}
else
if
(
[
"
ArrayBuffer
"
"
Function
"
"
Promise
"
"
WeakMap
"
"
WeakSet
"
"
Window
"
]
.
includes
(
className
)
)
{
return
buildSerialized
(
className
.
toLowerCase
(
)
handleId
)
;
}
else
if
(
lazy
.
error
.
isError
(
value
)
)
{
return
buildSerialized
(
"
error
"
handleId
)
;
}
else
if
(
TYPED_ARRAY_CLASSES
.
includes
(
className
)
)
{
return
buildSerialized
(
"
typedarray
"
handleId
)
;
}
else
if
(
className
=
=
"
Object
"
)
{
const
serialized
=
buildSerialized
(
"
object
"
handleId
)
;
setInternalIdsIfNeeded
(
serializationInternalMap
serialized
value
)
;
if
(
!
knownObject
&
&
maxDepth
!
=
=
null
&
&
maxDepth
>
0
)
{
serialized
.
value
=
serializeMapping
(
Object
.
entries
(
value
)
maxDepth
childOwnership
serializationInternalMap
realm
)
;
}
return
serialized
;
}
lazy
.
logger
.
warn
(
Unsupported
type
:
{
type
}
for
remote
value
:
{
stringify
(
value
)
}
)
;
return
undefined
;
}
function
setInternalIdsIfNeeded
(
serializationInternalMap
remoteValue
object
)
{
if
(
!
serializationInternalMap
.
has
(
object
)
)
{
serializationInternalMap
.
set
(
object
remoteValue
)
;
}
else
{
const
previousRemoteValue
=
serializationInternalMap
.
get
(
object
)
;
if
(
!
previousRemoteValue
.
internalId
)
{
previousRemoteValue
.
internalId
=
getUUID
(
)
;
}
remoteValue
.
internalId
=
previousRemoteValue
.
internalId
;
}
}
function
stringify
(
obj
)
{
let
text
;
try
{
text
=
obj
!
=
=
null
&
&
typeof
obj
=
=
=
"
object
"
?
obj
.
toString
(
)
:
String
(
obj
)
;
}
catch
(
e
)
{
}
finally
{
if
(
typeof
text
!
=
"
string
"
)
{
text
=
Object
.
prototype
.
toString
.
apply
(
obj
)
;
}
}
return
text
;
}
