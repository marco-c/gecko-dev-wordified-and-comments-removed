"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Realm
"
"
RealmType
"
"
WindowRealm
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
addDebuggerToGlobal
:
"
resource
:
/
/
gre
/
modules
/
jsdebugger
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
dbg
"
(
)
=
>
{
lazy
.
addDebuggerToGlobal
(
globalThis
)
;
return
new
Debugger
(
)
;
}
)
;
const
RealmType
=
{
AudioWorklet
:
"
audio
-
worklet
"
DedicatedWorker
:
"
dedicated
-
worker
"
PaintWorklet
:
"
paint
-
worklet
"
ServiceWorker
:
"
service
-
worker
"
SharedWorker
:
"
shared
-
worker
"
Window
:
"
window
"
Worker
:
"
worker
"
Worklet
:
"
worklet
"
}
;
function
getUUID
(
)
{
return
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
}
class
Realm
{
#
handleObjectMap
;
#
id
;
constructor
(
)
{
this
.
#
id
=
getUUID
(
)
;
this
.
#
handleObjectMap
=
new
Map
(
)
;
}
destroy
(
)
{
this
.
#
handleObjectMap
=
null
;
}
get
id
(
)
{
return
this
.
#
id
;
}
get
origin
(
)
{
throw
new
Error
(
"
Not
implemented
"
)
;
}
cloneIntoRealm
(
obj
)
{
return
obj
;
}
removeObjectHandle
(
handle
)
{
this
.
#
handleObjectMap
.
delete
(
handle
)
;
}
getHandleForObject
(
object
)
{
const
handle
=
getUUID
(
)
;
this
.
#
handleObjectMap
.
set
(
handle
object
)
;
return
handle
;
}
getInfo
(
)
{
return
{
realm
:
this
.
#
id
origin
:
this
.
origin
}
;
}
getObjectForHandle
(
handle
)
{
return
this
.
#
handleObjectMap
.
get
(
handle
)
;
}
}
class
WindowRealm
extends
Realm
{
#
globalObject
;
#
globalObjectReference
;
#
sandboxName
;
#
window
;
static
type
=
RealmType
.
Window
;
constructor
(
window
options
=
{
}
)
{
const
{
sandboxName
=
null
}
=
options
;
super
(
)
;
this
.
#
sandboxName
=
sandboxName
;
this
.
#
window
=
window
;
this
.
#
globalObject
=
sandboxName
=
=
=
null
?
this
.
#
window
:
this
.
#
createSandbox
(
)
;
this
.
#
globalObjectReference
=
lazy
.
dbg
.
makeGlobalObjectReference
(
this
.
#
globalObject
)
;
lazy
.
dbg
.
enableAsyncStack
(
this
.
#
globalObject
)
;
}
destroy
(
)
{
lazy
.
dbg
.
disableAsyncStack
(
this
.
#
globalObject
)
;
this
.
#
globalObjectReference
=
null
;
this
.
#
globalObject
=
null
;
this
.
#
window
=
null
;
super
.
destroy
(
)
;
}
get
globalObjectReference
(
)
{
return
this
.
#
globalObjectReference
;
}
get
origin
(
)
{
return
this
.
#
window
.
origin
;
}
#
createDebuggerObject
(
obj
)
{
return
this
.
#
globalObjectReference
.
makeDebuggeeValue
(
obj
)
;
}
#
createSandbox
(
)
{
const
win
=
this
.
#
window
;
const
opts
=
{
sameZoneAs
:
win
sandboxPrototype
:
win
wantComponents
:
false
wantXrays
:
true
}
;
return
new
Cu
.
Sandbox
(
win
opts
)
;
}
cloneIntoRealm
(
obj
)
{
return
Cu
.
cloneInto
(
obj
this
.
#
globalObject
)
;
}
executeInGlobal
(
expression
)
{
return
this
.
#
globalObjectReference
.
executeInGlobal
(
expression
{
url
:
this
.
#
window
.
document
.
baseURI
}
)
;
}
executeInGlobalWithBindings
(
functionDeclaration
functionArguments
thisParameter
)
{
const
expression
=
(
{
functionDeclaration
}
)
.
apply
(
__bidi_this
__bidi_args
)
;
const
args
=
this
.
cloneIntoRealm
(
[
]
)
;
for
(
const
arg
of
functionArguments
)
{
args
.
push
(
arg
)
;
}
return
this
.
#
globalObjectReference
.
executeInGlobalWithBindings
(
expression
{
__bidi_args
:
this
.
#
createDebuggerObject
(
args
)
__bidi_this
:
this
.
#
createDebuggerObject
(
thisParameter
)
}
{
url
:
this
.
#
window
.
document
.
baseURI
}
)
;
}
getInfo
(
)
{
const
baseInfo
=
super
.
getInfo
(
)
;
return
{
.
.
.
baseInfo
context
:
this
.
#
window
.
browsingContext
sandbox
:
this
.
#
sandboxName
type
:
WindowRealm
.
type
}
;
}
}
