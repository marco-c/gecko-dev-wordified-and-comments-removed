"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
script
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
Module
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Module
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
ContextDescriptorType
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
OwnershipModel
:
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
RemoteValue
.
jsm
"
RealmType
:
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
Realm
.
jsm
"
TabManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
WindowGlobalMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
WindowGlobalMessageHandler
.
jsm
"
}
)
;
class
ScriptModule
extends
Module
{
destroy
(
)
{
}
async
callFunction
(
options
=
{
}
)
{
const
{
arguments
:
commandArguments
=
null
awaitPromise
functionDeclaration
resultOwnership
=
lazy
.
OwnershipModel
.
None
target
=
{
}
this
:
thisParameter
=
null
}
=
options
;
lazy
.
assert
.
string
(
functionDeclaration
Expected
"
functionDeclaration
"
to
be
a
string
got
{
functionDeclaration
}
)
;
lazy
.
assert
.
boolean
(
awaitPromise
Expected
"
awaitPromise
"
to
be
a
boolean
got
{
awaitPromise
}
)
;
this
.
#
assertResultOwnership
(
resultOwnership
)
;
if
(
commandArguments
!
=
null
)
{
lazy
.
assert
.
array
(
commandArguments
Expected
"
arguments
"
to
be
an
array
got
{
commandArguments
}
)
;
}
const
{
contextId
realmId
sandbox
}
=
this
.
#
assertTarget
(
target
)
;
const
context
=
await
this
.
#
getContextFromTarget
(
{
contextId
realmId
}
)
;
const
evaluationResult
=
await
this
.
messageHandler
.
forwardCommand
(
{
moduleName
:
"
script
"
commandName
:
"
callFunctionDeclaration
"
destination
:
{
type
:
lazy
.
WindowGlobalMessageHandler
.
type
id
:
context
.
id
}
params
:
{
awaitPromise
commandArguments
functionDeclaration
realmId
resultOwnership
sandbox
thisParameter
}
}
)
;
return
this
.
#
buildReturnValue
(
evaluationResult
)
;
}
async
disown
(
options
=
{
}
)
{
const
{
handles
target
=
{
}
}
=
options
;
lazy
.
assert
.
array
(
handles
Expected
"
handles
"
to
be
an
array
got
{
handles
}
)
;
handles
.
forEach
(
handle
=
>
{
lazy
.
assert
.
string
(
handle
Expected
"
handles
"
to
be
an
array
of
strings
got
{
handle
}
)
;
}
)
;
const
{
contextId
realmId
sandbox
}
=
this
.
#
assertTarget
(
target
)
;
const
context
=
await
this
.
#
getContextFromTarget
(
{
contextId
realmId
}
)
;
await
this
.
messageHandler
.
forwardCommand
(
{
moduleName
:
"
script
"
commandName
:
"
disownHandles
"
destination
:
{
type
:
lazy
.
WindowGlobalMessageHandler
.
type
id
:
context
.
id
}
params
:
{
handles
realmId
sandbox
}
}
)
;
}
async
evaluate
(
options
=
{
}
)
{
const
{
awaitPromise
expression
:
source
resultOwnership
=
lazy
.
OwnershipModel
.
None
target
=
{
}
}
=
options
;
lazy
.
assert
.
string
(
source
Expected
"
expression
"
to
be
a
string
got
{
source
}
)
;
lazy
.
assert
.
boolean
(
awaitPromise
Expected
"
awaitPromise
"
to
be
a
boolean
got
{
awaitPromise
}
)
;
this
.
#
assertResultOwnership
(
resultOwnership
)
;
const
{
contextId
realmId
sandbox
}
=
this
.
#
assertTarget
(
target
)
;
const
context
=
await
this
.
#
getContextFromTarget
(
{
contextId
realmId
}
)
;
const
evaluationResult
=
await
this
.
messageHandler
.
forwardCommand
(
{
moduleName
:
"
script
"
commandName
:
"
evaluateExpression
"
destination
:
{
type
:
lazy
.
WindowGlobalMessageHandler
.
type
id
:
context
.
id
}
params
:
{
awaitPromise
expression
:
source
realmId
resultOwnership
sandbox
}
}
)
;
return
this
.
#
buildReturnValue
(
evaluationResult
)
;
}
async
getRealms
(
options
=
{
}
)
{
const
{
context
:
contextId
=
null
type
=
null
}
=
options
;
const
destination
=
{
}
;
if
(
contextId
!
=
=
null
)
{
lazy
.
assert
.
string
(
contextId
Expected
"
context
"
to
be
a
string
got
{
contextId
}
)
;
destination
.
id
=
this
.
#
getBrowsingContext
(
contextId
)
.
id
;
}
else
{
destination
.
contextDescriptor
=
{
type
:
lazy
.
ContextDescriptorType
.
All
}
;
}
if
(
type
!
=
=
null
)
{
const
supportedRealmTypes
=
Object
.
values
(
lazy
.
RealmType
)
;
if
(
!
supportedRealmTypes
.
includes
(
type
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
"
type
"
to
be
one
of
{
supportedRealmTypes
}
got
{
type
}
)
;
}
if
(
type
!
=
=
lazy
.
RealmType
.
Window
)
{
throw
new
lazy
.
error
.
UnsupportedOperationError
(
Unsupported
"
type
"
:
{
type
}
.
Only
"
type
"
{
lazy
.
RealmType
.
Window
}
is
currently
supported
.
)
;
}
}
return
{
realms
:
await
this
.
#
getRealmInfos
(
destination
)
}
;
}
#
assertResultOwnership
(
resultOwnership
)
{
if
(
!
[
lazy
.
OwnershipModel
.
None
lazy
.
OwnershipModel
.
Root
]
.
includes
(
resultOwnership
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
"
resultOwnership
"
to
be
one
of
{
Object
.
values
(
lazy
.
OwnershipModel
)
}
got
{
resultOwnership
}
)
;
}
}
#
assertTarget
(
target
)
{
lazy
.
assert
.
object
(
target
Expected
"
target
"
to
be
an
object
got
{
target
}
)
;
const
{
context
:
contextId
=
null
realm
:
realmId
=
null
sandbox
=
null
}
=
target
;
if
(
realmId
!
=
null
&
&
(
contextId
!
=
null
|
|
sandbox
!
=
null
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
A
context
and
a
realm
reference
are
mutually
exclusive
)
;
}
if
(
contextId
!
=
null
)
{
lazy
.
assert
.
string
(
contextId
Expected
"
context
"
to
be
a
string
got
{
contextId
}
)
;
if
(
sandbox
!
=
null
)
{
lazy
.
assert
.
string
(
sandbox
Expected
"
sandbox
"
to
be
a
string
got
{
sandbox
}
)
;
}
}
else
if
(
realmId
!
=
null
)
{
lazy
.
assert
.
string
(
realmId
Expected
"
realm
"
to
be
a
string
got
{
realmId
}
)
;
}
else
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
No
context
or
realm
provided
)
;
}
return
{
contextId
realmId
sandbox
}
;
}
#
buildReturnValue
(
evaluationResult
)
{
const
rv
=
{
realm
:
evaluationResult
.
realmId
}
;
switch
(
evaluationResult
.
evaluationStatus
)
{
case
"
normal
"
:
rv
.
result
=
evaluationResult
.
result
;
break
;
case
"
throw
"
:
rv
.
exceptionDetails
=
evaluationResult
.
exceptionDetails
;
break
;
default
:
throw
new
lazy
.
error
.
UnsupportedOperationError
(
Unsupported
evaluation
status
{
evaluationResult
.
evaluationStatus
}
)
;
}
return
rv
;
}
#
getBrowsingContext
(
contextId
)
{
const
context
=
lazy
.
TabManager
.
getBrowsingContextById
(
contextId
)
;
if
(
context
=
=
=
null
)
{
throw
new
lazy
.
error
.
NoSuchFrameError
(
Browsing
Context
with
id
{
contextId
}
not
found
)
;
}
if
(
!
context
.
currentWindowGlobal
)
{
throw
new
lazy
.
error
.
NoSuchFrameError
(
No
window
found
for
BrowsingContext
with
id
{
contextId
}
)
;
}
return
context
;
}
async
#
getContextFromTarget
(
{
contextId
realmId
}
)
{
if
(
contextId
!
=
=
null
)
{
return
this
.
#
getBrowsingContext
(
contextId
)
;
}
const
destination
=
{
contextDescriptor
:
{
type
:
lazy
.
ContextDescriptorType
.
All
}
}
;
const
realms
=
await
this
.
#
getRealmInfos
(
destination
)
;
const
realm
=
realms
.
find
(
realm
=
>
realm
.
realm
=
=
realmId
)
;
if
(
realm
&
&
realm
.
context
!
=
=
null
)
{
return
this
.
#
getBrowsingContext
(
realm
.
context
)
;
}
throw
new
lazy
.
error
.
NoSuchFrameError
(
Realm
with
id
{
realmId
}
not
found
)
;
}
async
#
getRealmInfos
(
destination
)
{
let
realms
=
await
this
.
messageHandler
.
forwardCommand
(
{
moduleName
:
"
script
"
commandName
:
"
getWindowRealms
"
destination
:
{
type
:
lazy
.
WindowGlobalMessageHandler
.
type
.
.
.
destination
}
}
)
;
const
isBroadcast
=
!
!
destination
.
contextDescriptor
;
if
(
!
isBroadcast
)
{
realms
=
[
realms
]
;
}
return
realms
.
flat
(
)
.
map
(
realm
=
>
{
realm
.
context
=
lazy
.
TabManager
.
getIdForBrowsingContext
(
realm
.
context
)
;
return
realm
;
}
)
.
filter
(
realm
=
>
realm
.
context
!
=
=
null
)
;
}
static
get
supportedEvents
(
)
{
return
[
]
;
}
}
const
script
=
ScriptModule
;
