"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
script
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
Module
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Module
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
TabManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
WindowGlobalMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
WindowGlobalMessageHandler
.
jsm
"
}
)
;
const
OwnershipModel
=
{
None
:
"
none
"
Root
:
"
root
"
}
;
const
RealmType
=
{
AudioWorklet
:
"
audio
-
worklet
"
DedicatedWorker
:
"
dedicated
-
worker
"
PaintWorklet
:
"
paint
-
worklet
"
ServiceWorker
:
"
service
-
worker
"
SharedWorker
:
"
shared
-
worker
"
Window
:
"
window
"
Worker
:
"
worker
"
Worklet
:
"
worklet
"
}
;
class
ScriptModule
extends
Module
{
destroy
(
)
{
}
async
callFunction
(
options
=
{
}
)
{
this
.
assertExperimentalCommandsEnabled
(
"
script
.
callFunction
"
)
;
const
{
arguments
:
commandArguments
=
null
awaitPromise
functionDeclaration
resultOwnership
=
OwnershipModel
.
None
target
=
{
}
this
:
thisParameter
=
null
}
=
options
;
lazy
.
assert
.
string
(
functionDeclaration
Expected
"
functionDeclaration
"
to
be
a
string
got
{
functionDeclaration
}
)
;
lazy
.
assert
.
boolean
(
awaitPromise
Expected
"
awaitPromise
"
to
be
a
boolean
got
{
awaitPromise
}
)
;
this
.
#
assertResultOwnership
(
resultOwnership
)
;
if
(
commandArguments
!
=
null
)
{
lazy
.
assert
.
array
(
commandArguments
Expected
"
arguments
"
to
be
an
array
got
{
commandArguments
}
)
;
}
const
{
contextId
realmId
sandbox
}
=
this
.
#
assertTarget
(
target
)
;
const
realm
=
this
.
#
getRealmInfoFromTarget
(
{
contextId
realmId
sandbox
}
)
;
const
evaluationResult
=
await
this
.
messageHandler
.
forwardCommand
(
{
moduleName
:
"
script
"
commandName
:
"
callFunctionDeclaration
"
destination
:
{
type
:
lazy
.
WindowGlobalMessageHandler
.
type
id
:
realm
.
context
.
id
}
params
:
{
awaitPromise
commandArguments
functionDeclaration
thisParameter
}
}
)
;
return
this
.
#
buildReturnValue
(
evaluationResult
realm
)
;
}
async
evaluate
(
options
=
{
}
)
{
this
.
assertExperimentalCommandsEnabled
(
"
script
.
evaluate
"
)
;
const
{
awaitPromise
expression
:
source
resultOwnership
=
OwnershipModel
.
None
target
=
{
}
}
=
options
;
lazy
.
assert
.
string
(
source
Expected
"
expression
"
to
be
a
string
got
{
source
}
)
;
lazy
.
assert
.
boolean
(
awaitPromise
Expected
"
awaitPromise
"
to
be
a
boolean
got
{
awaitPromise
}
)
;
this
.
#
assertResultOwnership
(
resultOwnership
)
;
const
{
contextId
realmId
sandbox
}
=
this
.
#
assertTarget
(
target
)
;
const
realm
=
this
.
#
getRealmInfoFromTarget
(
{
contextId
realmId
sandbox
}
)
;
const
evaluationResult
=
await
this
.
messageHandler
.
forwardCommand
(
{
moduleName
:
"
script
"
commandName
:
"
evaluateExpression
"
destination
:
{
type
:
lazy
.
WindowGlobalMessageHandler
.
type
id
:
realm
.
context
.
id
}
params
:
{
awaitPromise
expression
:
source
}
}
)
;
return
this
.
#
buildReturnValue
(
evaluationResult
realm
)
;
}
#
assertResultOwnership
(
resultOwnership
)
{
if
(
!
[
OwnershipModel
.
None
OwnershipModel
.
Root
]
.
includes
(
resultOwnership
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
"
resultOwnership
"
to
be
one
of
{
Object
.
values
(
OwnershipModel
)
}
got
{
resultOwnership
}
)
;
}
}
#
assertTarget
(
target
)
{
lazy
.
assert
.
object
(
target
Expected
"
target
"
to
be
an
object
got
{
target
}
)
;
const
{
context
:
contextId
=
null
realm
:
realmId
=
null
sandbox
=
null
}
=
target
;
if
(
contextId
!
=
null
)
{
lazy
.
assert
.
string
(
contextId
Expected
"
context
"
to
be
a
string
got
{
contextId
}
)
;
if
(
sandbox
!
=
null
)
{
lazy
.
assert
.
string
(
sandbox
Expected
"
sandbox
"
to
be
a
string
got
{
sandbox
}
)
;
throw
new
lazy
.
error
.
UnsupportedOperationError
(
sandbox
is
not
supported
yet
)
;
}
}
else
if
(
realmId
!
=
null
)
{
lazy
.
assert
.
string
(
realmId
Expected
"
realm
"
to
be
a
string
got
{
realmId
}
)
;
throw
new
lazy
.
error
.
UnsupportedOperationError
(
realm
is
not
supported
yet
)
;
}
else
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
No
context
or
realm
provided
)
;
}
return
{
contextId
realmId
sandbox
}
;
}
#
buildReturnValue
(
evaluationResult
realm
)
{
const
rv
=
{
realm
:
realm
.
realm
}
;
switch
(
evaluationResult
.
evaluationStatus
)
{
case
"
normal
"
:
rv
.
result
=
evaluationResult
.
result
;
break
;
case
"
throw
"
:
rv
.
exceptionDetails
=
evaluationResult
.
exceptionDetails
;
break
;
default
:
throw
new
lazy
.
error
.
UnsupportedOperationError
(
Unsupported
evaluation
status
{
evaluationResult
.
evaluationStatus
}
)
;
}
return
rv
;
}
#
getRealmInfoFromTarget
(
{
contextId
realmId
sandbox
}
)
{
if
(
contextId
!
=
null
)
{
const
context
=
lazy
.
TabManager
.
getBrowsingContextById
(
contextId
)
;
if
(
context
=
=
=
null
)
{
throw
new
lazy
.
error
.
NoSuchFrameError
(
Browsing
Context
with
id
{
contextId
}
not
found
)
;
}
if
(
!
context
.
currentWindowGlobal
)
{
throw
new
lazy
.
error
.
NoSuchFrameError
(
No
window
found
for
BrowsingContext
with
id
{
contextId
}
)
;
}
return
{
realm
:
String
(
context
.
currentWindowGlobal
.
innerWindowId
)
origin
:
null
type
:
RealmType
.
Window
context
}
;
}
throw
new
lazy
.
error
.
NoSuchFrameError
(
No
realm
matching
context
:
{
contextId
}
realm
:
{
realmId
}
sandbox
:
{
sandbox
}
)
;
}
static
get
supportedEvents
(
)
{
return
[
]
;
}
}
const
script
=
ScriptModule
;
