"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
browsingContext
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
Module
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Module
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AppInfo
:
"
chrome
:
/
/
remote
/
content
/
shared
/
AppInfo
.
jsm
"
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
BrowsingContextListener
:
"
chrome
:
/
/
remote
/
content
/
shared
/
listeners
/
BrowsingContextListener
.
jsm
"
ContextDescriptorType
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
ProgressListener
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Navigate
.
jsm
"
TabManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
waitForInitialNavigationCompleted
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Navigate
.
jsm
"
WindowGlobalMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
WindowGlobalMessageHandler
.
jsm
"
windowManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
WindowManager
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
lazy
.
Log
.
TYPES
.
WEBDRIVER_BIDI
)
)
;
const
CreateType
=
{
tab
:
"
tab
"
window
:
"
window
"
}
;
const
WaitCondition
=
{
None
:
"
none
"
Interactive
:
"
interactive
"
Complete
:
"
complete
"
}
;
class
BrowsingContextModule
extends
Module
{
#
contextListener
;
constructor
(
messageHandler
)
{
super
(
messageHandler
)
;
this
.
#
contextListener
=
new
lazy
.
BrowsingContextListener
(
)
;
this
.
#
contextListener
.
on
(
"
attached
"
this
.
#
onContextAttached
)
;
}
destroy
(
)
{
this
.
#
contextListener
.
off
(
"
attached
"
this
.
#
onContextAttached
)
;
this
.
#
contextListener
.
destroy
(
)
;
}
async
close
(
options
=
{
}
)
{
const
{
context
:
contextId
}
=
options
;
lazy
.
assert
.
string
(
contextId
Expected
"
context
"
to
be
a
string
got
{
contextId
}
)
;
const
context
=
lazy
.
TabManager
.
getBrowsingContextById
(
contextId
)
;
if
(
!
context
)
{
throw
new
lazy
.
error
.
NoSuchFrameError
(
Browsing
Context
with
id
{
contextId
}
not
found
)
;
}
if
(
context
.
parent
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Browsing
Context
with
id
{
contextId
}
is
not
top
-
level
)
;
}
if
(
lazy
.
TabManager
.
getTabCount
(
)
=
=
=
1
)
{
lazy
.
logger
.
warn
(
Closing
the
last
open
tab
(
Browsing
Context
id
{
contextId
}
)
expect
inconsistent
behavior
across
platforms
)
;
}
const
browser
=
context
.
embedderElement
;
const
tabBrowser
=
lazy
.
TabManager
.
getTabBrowser
(
browser
.
ownerGlobal
)
;
const
tab
=
tabBrowser
.
getTabForBrowser
(
browser
)
;
await
lazy
.
TabManager
.
removeTab
(
tab
)
;
}
async
create
(
options
=
{
}
)
{
const
{
type
}
=
options
;
if
(
type
!
=
=
CreateType
.
tab
&
&
type
!
=
=
CreateType
.
window
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
"
type
"
to
be
one
of
{
Object
.
values
(
CreateType
)
}
got
{
type
}
)
;
}
let
browser
;
switch
(
type
)
{
case
"
window
"
:
let
newWindow
=
await
lazy
.
windowManager
.
openBrowserWindow
(
)
;
browser
=
lazy
.
TabManager
.
getTabBrowser
(
newWindow
)
.
selectedBrowser
;
break
;
case
"
tab
"
:
if
(
!
lazy
.
TabManager
.
supportsTabs
(
)
)
{
throw
new
lazy
.
error
.
UnsupportedOperationError
(
browsingContext
.
create
with
type
"
tab
"
not
supported
in
{
lazy
.
AppInfo
.
name
}
)
;
}
let
tab
=
await
lazy
.
TabManager
.
addTab
(
{
focus
:
false
}
)
;
browser
=
lazy
.
TabManager
.
getBrowserForTab
(
tab
)
;
}
await
lazy
.
waitForInitialNavigationCompleted
(
browser
.
browsingContext
.
webProgress
)
;
return
{
context
:
lazy
.
TabManager
.
getIdForBrowser
(
browser
)
}
;
}
getTree
(
options
=
{
}
)
{
const
{
maxDepth
=
null
root
:
rootId
=
null
}
=
options
;
if
(
maxDepth
!
=
=
null
)
{
lazy
.
assert
.
positiveInteger
(
maxDepth
Expected
"
maxDepth
"
to
be
a
positive
integer
got
{
maxDepth
}
)
;
}
let
contexts
;
if
(
rootId
!
=
=
null
)
{
lazy
.
assert
.
string
(
rootId
Expected
"
root
"
to
be
a
string
got
{
rootId
}
)
;
contexts
=
[
this
.
#
getBrowsingContext
(
rootId
)
]
;
}
else
{
contexts
=
lazy
.
TabManager
.
browsers
.
map
(
browser
=
>
browser
.
browsingContext
)
;
}
const
contextsInfo
=
contexts
.
map
(
context
=
>
{
return
this
.
#
getBrowsingContextInfo
(
context
{
maxDepth
}
)
;
}
)
;
return
{
contexts
:
contextsInfo
}
;
}
async
navigate
(
options
=
{
}
)
{
const
{
context
:
contextId
url
wait
=
WaitCondition
.
None
}
=
options
;
lazy
.
assert
.
string
(
contextId
Expected
"
context
"
to
be
a
string
got
{
contextId
}
)
;
lazy
.
assert
.
string
(
url
Expected
"
url
"
to
be
string
got
{
url
}
)
;
const
waitConditions
=
Object
.
values
(
WaitCondition
)
;
if
(
!
waitConditions
.
includes
(
wait
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
"
wait
"
to
be
one
of
{
waitConditions
}
got
{
wait
}
)
;
}
const
context
=
this
.
#
getBrowsingContext
(
contextId
)
;
const
webProgress
=
context
.
webProgress
;
const
base
=
await
this
.
messageHandler
.
handleCommand
(
{
moduleName
:
"
browsingContext
"
commandName
:
"
_getBaseURL
"
destination
:
{
type
:
lazy
.
WindowGlobalMessageHandler
.
type
id
:
context
.
id
}
retryOnAbort
:
true
}
)
;
let
targetURI
;
try
{
const
baseURI
=
Services
.
io
.
newURI
(
base
)
;
targetURI
=
Services
.
io
.
newURI
(
url
null
baseURI
)
;
}
catch
(
e
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
"
url
"
to
be
a
valid
URL
(
{
e
.
message
}
)
)
;
}
return
this
.
#
awaitNavigation
(
webProgress
targetURI
{
wait
}
)
;
}
async
#
awaitNavigation
(
webProgress
targetURI
options
)
{
const
{
wait
}
=
options
;
const
context
=
webProgress
.
browsingContext
;
const
browserId
=
context
.
browserId
;
const
resolveWhenStarted
=
wait
=
=
=
WaitCondition
.
None
;
const
listener
=
new
lazy
.
ProgressListener
(
webProgress
{
expectNavigation
:
true
resolveWhenStarted
waitForExplicitStart
:
true
}
)
;
const
onDOMContentLoadedEvent
=
(
evtName
wrappedEvt
)
=
>
{
if
(
webProgress
.
browsingContext
.
id
!
=
=
wrappedEvt
.
contextId
)
{
return
;
}
if
(
wrappedEvt
.
readyState
=
=
=
"
interactive
"
)
{
listener
.
stop
(
)
;
}
}
;
const
contextDescriptor
=
{
type
:
lazy
.
ContextDescriptorType
.
TopBrowsingContext
id
:
browserId
}
;
if
(
wait
=
=
=
WaitCondition
.
Interactive
)
{
await
this
.
messageHandler
.
eventsDispatcher
.
on
(
"
browsingContext
.
DOMContentLoaded
"
contextDescriptor
onDOMContentLoadedEvent
)
;
}
const
navigated
=
listener
.
start
(
)
;
navigated
.
finally
(
async
(
)
=
>
{
if
(
listener
.
isStarted
)
{
listener
.
stop
(
)
;
}
if
(
wait
=
=
=
WaitCondition
.
Interactive
)
{
await
this
.
messageHandler
.
eventsDispatcher
.
off
(
"
browsingContext
.
DOMContentLoaded
"
contextDescriptor
onDOMContentLoadedEvent
)
;
}
}
)
;
context
.
loadURI
(
targetURI
.
spec
{
loadFlags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_IS_LINK
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
hasValidUserGestureActivation
:
true
}
)
;
await
navigated
;
let
url
;
if
(
wait
=
=
=
WaitCondition
.
None
)
{
url
=
listener
.
targetURI
.
spec
;
}
else
{
url
=
listener
.
currentURI
.
spec
;
}
return
{
navigation
:
null
url
}
;
}
#
getBrowsingContext
(
contextId
)
{
if
(
contextId
=
=
=
null
)
{
return
null
;
}
const
context
=
lazy
.
TabManager
.
getBrowsingContextById
(
contextId
)
;
if
(
context
=
=
=
null
)
{
throw
new
lazy
.
error
.
NoSuchFrameError
(
Browsing
Context
with
id
{
contextId
}
not
found
)
;
}
return
context
;
}
#
getBrowsingContextInfo
(
context
options
=
{
}
)
{
const
{
isRoot
=
true
maxDepth
=
null
}
=
options
;
let
children
=
null
;
if
(
maxDepth
=
=
=
null
|
|
maxDepth
>
0
)
{
children
=
context
.
children
.
map
(
context
=
>
this
.
#
getBrowsingContextInfo
(
context
{
maxDepth
:
maxDepth
=
=
=
null
?
maxDepth
:
maxDepth
-
1
isRoot
:
false
}
)
)
;
}
const
contextInfo
=
{
context
:
lazy
.
TabManager
.
getIdForBrowsingContext
(
context
)
url
:
context
.
currentURI
.
spec
children
}
;
if
(
isRoot
)
{
const
parentId
=
lazy
.
TabManager
.
getIdForBrowsingContext
(
context
.
parent
)
;
contextInfo
.
parent
=
parentId
;
}
return
contextInfo
;
}
#
onContextAttached
=
async
(
eventName
data
=
{
}
)
=
>
{
const
{
browsingContext
why
}
=
data
;
if
(
why
=
=
=
"
replace
"
)
{
return
;
}
if
(
!
browsingContext
.
webProgress
)
{
return
;
}
const
browsingContextInfo
=
this
.
#
getBrowsingContextInfo
(
browsingContext
{
maxDepth
:
0
}
)
;
const
contextInfo
=
{
contextId
:
browsingContext
.
id
type
:
lazy
.
WindowGlobalMessageHandler
.
type
}
;
this
.
emitEvent
(
"
browsingContext
.
contextCreated
"
browsingContextInfo
contextInfo
)
;
}
;
#
subscribeEvent
(
event
)
{
if
(
event
=
=
=
"
browsingContext
.
contextCreated
"
)
{
this
.
#
contextListener
.
startListening
(
)
;
}
}
#
unsubscribeEvent
(
event
)
{
if
(
event
=
=
=
"
browsingContext
.
contextCreated
"
)
{
this
.
#
contextListener
.
stopListening
(
)
;
}
}
_applySessionData
(
params
)
{
const
{
category
added
=
[
]
removed
=
[
]
}
=
params
;
if
(
category
=
=
=
"
event
"
)
{
for
(
const
event
of
added
)
{
this
.
#
subscribeEvent
(
event
)
;
}
for
(
const
event
of
removed
)
{
this
.
#
unsubscribeEvent
(
event
)
;
}
}
}
static
get
supportedEvents
(
)
{
return
[
"
browsingContext
.
contextCreated
"
"
browsingContext
.
load
"
]
;
}
}
const
browsingContext
=
BrowsingContextModule
;
