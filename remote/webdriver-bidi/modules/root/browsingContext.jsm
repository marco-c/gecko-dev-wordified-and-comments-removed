"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
browsingContext
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowsingContextListener
:
"
chrome
:
/
/
remote
/
content
/
shared
/
listeners
/
BrowsingContextListener
.
jsm
"
ContextDescriptorType
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
Module
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Module
.
jsm
"
TabManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
waitForInitialNavigationCompleted
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Navigate
.
jsm
"
}
)
;
class
BrowsingContext
extends
Module
{
#
contextListener
;
constructor
(
messageHandler
)
{
super
(
messageHandler
)
;
this
.
#
contextListener
=
new
BrowsingContextListener
(
)
;
this
.
#
contextListener
.
on
(
"
attached
"
this
.
#
onContextAttached
)
;
}
destroy
(
)
{
this
.
#
contextListener
.
off
(
"
attached
"
this
.
#
onContextAttached
)
;
this
.
#
contextListener
.
destroy
(
)
;
}
#
getBrowsingContextInfo
(
browsingContext
options
=
{
}
)
{
const
{
depth
}
=
options
;
const
contextInfo
=
{
context
:
TabManager
.
getIdForBrowsingContext
(
browsingContext
)
url
:
browsingContext
.
currentURI
.
spec
children
:
null
}
;
if
(
depth
=
=
0
)
{
const
parentId
=
TabManager
.
getIdForBrowsingContext
(
browsingContext
.
parent
)
;
contextInfo
.
parent
=
parentId
;
}
return
contextInfo
;
}
#
onContextAttached
=
async
(
eventName
data
=
{
}
)
=
>
{
const
{
browsingContext
why
}
=
data
;
if
(
why
=
=
=
"
replace
"
)
{
return
;
}
if
(
!
browsingContext
.
webProgress
)
{
return
;
}
await
waitForInitialNavigationCompleted
(
browsingContext
.
webProgress
{
resolveWhenStarted
:
true
}
)
;
const
contextInfo
=
this
.
#
getBrowsingContextInfo
(
browsingContext
{
depth
:
0
maxDepth
:
1
}
)
;
this
.
emitProtocolEvent
(
"
browsingContext
.
contextCreated
"
contextInfo
)
;
}
;
_subscribeEvent
(
params
)
{
switch
(
params
.
event
)
{
case
"
browsingContext
.
contextCreated
"
:
this
.
#
contextListener
.
startListening
(
)
;
return
this
.
messageHandler
.
addSessionData
(
{
moduleName
:
"
browsingContext
"
category
:
"
event
"
contextDescriptor
:
{
type
:
ContextDescriptorType
.
All
}
values
:
[
params
.
event
]
}
)
;
default
:
throw
new
Error
(
Unsupported
event
for
browsingContext
module
{
params
.
event
}
)
;
}
}
_unsubscribeEvent
(
params
)
{
switch
(
params
.
event
)
{
case
"
browsingContext
.
contextCreated
"
:
this
.
#
contextListener
.
stopListening
(
)
;
return
this
.
messageHandler
.
removeSessionData
(
{
moduleName
:
"
browsingContext
"
category
:
"
event
"
contextDescriptor
:
{
type
:
ContextDescriptorType
.
All
}
values
:
[
params
.
event
]
}
)
;
default
:
throw
new
Error
(
Unsupported
event
for
browsingContext
module
{
params
.
event
}
)
;
}
}
static
get
supportedEvents
(
)
{
return
[
"
browsingContext
.
contextCreated
"
]
;
}
}
const
browsingContext
=
BrowsingContext
;
