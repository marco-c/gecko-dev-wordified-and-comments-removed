"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
browsingContext
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
BrowsingContextListener
:
"
chrome
:
/
/
remote
/
content
/
shared
/
listeners
/
BrowsingContextListener
.
jsm
"
ContextDescriptorType
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
Module
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Module
.
jsm
"
ProgressListener
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Navigate
.
jsm
"
TabManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
waitForInitialNavigationCompleted
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Navigate
.
jsm
"
WindowGlobalMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
WindowGlobalMessageHandler
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
WEBDRIVER_BIDI
)
)
;
const
WaitCondition
=
{
None
:
"
none
"
Interactive
:
"
interactive
"
Complete
:
"
complete
"
}
;
class
BrowsingContextModule
extends
Module
{
#
contextListener
;
constructor
(
messageHandler
)
{
super
(
messageHandler
)
;
this
.
#
contextListener
=
new
BrowsingContextListener
(
)
;
this
.
#
contextListener
.
on
(
"
attached
"
this
.
#
onContextAttached
)
;
}
destroy
(
)
{
this
.
#
contextListener
.
off
(
"
attached
"
this
.
#
onContextAttached
)
;
this
.
#
contextListener
.
destroy
(
)
;
}
close
(
options
=
{
}
)
{
const
{
context
:
contextId
}
=
options
;
assert
.
string
(
contextId
Expected
"
context
"
to
be
a
string
got
{
contextId
}
)
;
const
context
=
TabManager
.
getBrowsingContextById
(
contextId
)
;
if
(
!
context
)
{
throw
new
error
.
NoSuchFrameError
(
Browsing
Context
with
id
{
contextId
}
not
found
)
;
}
if
(
context
.
parent
)
{
throw
new
error
.
InvalidArgumentError
(
Browsing
Context
with
id
{
contextId
}
is
not
top
-
level
)
;
}
if
(
TabManager
.
getTabCount
(
)
=
=
=
1
)
{
logger
.
warn
(
Closing
the
last
open
tab
(
Browsing
Context
id
{
contextId
}
)
expect
inconsistent
behavior
across
platforms
)
;
}
const
browser
=
context
.
embedderElement
;
const
tabBrowser
=
TabManager
.
getTabBrowser
(
browser
.
ownerGlobal
)
;
const
tab
=
tabBrowser
.
getTabForBrowser
(
browser
)
;
TabManager
.
removeTab
(
tab
)
;
}
getTree
(
options
=
{
}
)
{
const
{
maxDepth
=
null
parent
:
parentId
=
null
}
=
options
;
if
(
maxDepth
!
=
=
null
)
{
assert
.
positiveInteger
(
maxDepth
Expected
"
maxDepth
"
to
be
a
positive
integer
got
{
maxDepth
}
)
;
}
let
contexts
;
if
(
parentId
!
=
=
null
)
{
assert
.
string
(
parentId
Expected
"
parent
"
to
be
a
string
got
{
parentId
}
)
;
contexts
=
[
this
.
#
getBrowsingContext
(
parentId
)
]
;
}
else
{
contexts
=
TabManager
.
browsers
.
map
(
browser
=
>
browser
.
browsingContext
)
;
}
const
contextsInfo
=
contexts
.
map
(
context
=
>
{
return
this
.
#
getBrowsingContextInfo
(
context
{
maxDepth
}
)
;
}
)
;
return
{
contexts
:
contextsInfo
}
;
}
async
navigate
(
options
=
{
}
)
{
const
{
context
:
contextId
url
wait
=
WaitCondition
.
None
}
=
options
;
assert
.
string
(
contextId
Expected
"
context
"
to
be
a
string
got
{
contextId
}
)
;
assert
.
string
(
url
Expected
"
url
"
to
be
string
got
{
url
}
)
;
const
waitConditions
=
Object
.
values
(
WaitCondition
)
;
if
(
!
waitConditions
.
includes
(
wait
)
)
{
throw
new
error
.
InvalidArgumentError
(
Expected
"
wait
"
to
be
one
of
{
waitConditions
}
got
{
wait
}
)
;
}
const
context
=
this
.
#
getBrowsingContext
(
contextId
)
;
const
webProgress
=
context
.
webProgress
;
const
base
=
await
this
.
messageHandler
.
handleCommand
(
{
moduleName
:
"
browsingContext
"
commandName
:
"
_getBaseURL
"
destination
:
{
type
:
WindowGlobalMessageHandler
.
type
id
:
context
.
id
}
}
)
;
let
targetURI
;
try
{
const
baseURI
=
Services
.
io
.
newURI
(
base
)
;
targetURI
=
Services
.
io
.
newURI
(
url
null
baseURI
)
;
}
catch
(
e
)
{
throw
new
error
.
InvalidArgumentError
(
Expected
"
url
"
to
be
a
valid
URL
(
{
e
.
message
}
)
)
;
}
return
this
.
#
awaitNavigation
(
webProgress
targetURI
{
wait
}
)
;
}
async
#
awaitNavigation
(
webProgress
targetURI
options
)
{
const
{
wait
}
=
options
;
const
context
=
webProgress
.
browsingContext
;
const
browserId
=
context
.
browserId
;
const
resolveWhenStarted
=
wait
=
=
=
WaitCondition
.
None
;
const
listener
=
new
ProgressListener
(
webProgress
{
resolveWhenStarted
waitForExplicitStart
:
true
}
)
;
const
onDOMContentLoadedEvent
=
(
evtName
wrappedEvt
)
=
>
{
if
(
webProgress
.
browsingContext
.
id
!
=
=
wrappedEvt
.
contextId
)
{
return
;
}
if
(
wrappedEvt
.
readyState
=
=
=
"
interactive
"
)
{
listener
.
stop
(
)
;
}
}
;
const
contextDescriptor
=
{
type
:
ContextDescriptorType
.
TopBrowsingContext
id
:
browserId
}
;
if
(
wait
=
=
=
WaitCondition
.
Interactive
)
{
await
this
.
messageHandler
.
eventsDispatcher
.
on
(
"
browsingContext
.
DOMContentLoaded
"
contextDescriptor
onDOMContentLoadedEvent
)
;
}
const
navigated
=
listener
.
start
(
)
;
navigated
.
finally
(
async
(
)
=
>
{
if
(
listener
.
isStarted
)
{
listener
.
stop
(
)
;
}
if
(
wait
=
=
=
WaitCondition
.
Interactive
)
{
await
this
.
messageHandler
.
eventsDispatcher
.
off
(
"
browsingContext
.
DOMContentLoaded
"
contextDescriptor
onDOMContentLoadedEvent
)
;
}
}
)
;
context
.
loadURI
(
targetURI
.
spec
{
loadFlags
:
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_IS_LINK
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
hasValidUserGestureActivation
:
true
}
)
;
await
navigated
;
let
url
;
if
(
wait
=
=
=
WaitCondition
.
None
)
{
url
=
listener
.
targetURI
.
spec
;
}
else
{
url
=
listener
.
currentURI
.
spec
;
}
return
{
navigation
:
null
url
}
;
}
#
getBrowsingContext
(
contextId
)
{
if
(
contextId
=
=
=
null
)
{
return
null
;
}
const
context
=
TabManager
.
getBrowsingContextById
(
contextId
)
;
if
(
context
=
=
=
null
)
{
throw
new
error
.
NoSuchFrameError
(
Browsing
Context
with
id
{
contextId
}
not
found
)
;
}
return
context
;
}
#
getBrowsingContextInfo
(
context
options
=
{
}
)
{
const
{
isRoot
=
true
maxDepth
=
null
}
=
options
;
let
children
=
null
;
if
(
maxDepth
=
=
=
null
|
|
maxDepth
>
0
)
{
children
=
context
.
children
.
map
(
context
=
>
this
.
#
getBrowsingContextInfo
(
context
{
maxDepth
:
maxDepth
=
=
=
null
?
maxDepth
:
maxDepth
-
1
isRoot
:
false
}
)
)
;
}
const
contextInfo
=
{
context
:
TabManager
.
getIdForBrowsingContext
(
context
)
url
:
context
.
currentURI
.
spec
children
}
;
if
(
isRoot
)
{
const
parentId
=
TabManager
.
getIdForBrowsingContext
(
context
.
parent
)
;
contextInfo
.
parent
=
parentId
;
}
return
contextInfo
;
}
#
onContextAttached
=
async
(
eventName
data
=
{
}
)
=
>
{
const
{
browsingContext
why
}
=
data
;
if
(
why
=
=
=
"
replace
"
)
{
return
;
}
if
(
!
browsingContext
.
webProgress
)
{
return
;
}
await
waitForInitialNavigationCompleted
(
browsingContext
.
webProgress
{
resolveWhenStarted
:
true
}
)
;
const
contextInfo
=
this
.
#
getBrowsingContextInfo
(
browsingContext
{
maxDepth
:
0
}
)
;
this
.
emitProtocolEvent
(
"
browsingContext
.
contextCreated
"
contextInfo
)
;
}
;
_subscribeEvent
(
params
)
{
switch
(
params
.
event
)
{
case
"
browsingContext
.
contextCreated
"
:
this
.
#
contextListener
.
startListening
(
)
;
return
this
.
messageHandler
.
addSessionData
(
{
moduleName
:
"
browsingContext
"
category
:
"
event
"
contextDescriptor
:
{
type
:
ContextDescriptorType
.
All
}
values
:
[
params
.
event
]
}
)
;
default
:
throw
new
Error
(
Unsupported
event
for
browsingContext
module
{
params
.
event
}
)
;
}
}
_unsubscribeEvent
(
params
)
{
switch
(
params
.
event
)
{
case
"
browsingContext
.
contextCreated
"
:
this
.
#
contextListener
.
stopListening
(
)
;
return
this
.
messageHandler
.
removeSessionData
(
{
moduleName
:
"
browsingContext
"
category
:
"
event
"
contextDescriptor
:
{
type
:
ContextDescriptorType
.
All
}
values
:
[
params
.
event
]
}
)
;
default
:
throw
new
Error
(
Unsupported
event
for
browsingContext
module
{
params
.
event
}
)
;
}
}
static
get
supportedEvents
(
)
{
return
[
"
browsingContext
.
contextCreated
"
]
;
}
}
const
browsingContext
=
BrowsingContextModule
;
