"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
browsingContext
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
BrowsingContextListener
:
"
chrome
:
/
/
remote
/
content
/
shared
/
listeners
/
BrowsingContextListener
.
jsm
"
ContextDescriptorType
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
MessageHandler
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
Module
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Module
.
jsm
"
TabManager
:
"
chrome
:
/
/
remote
/
content
/
shared
/
TabManager
.
jsm
"
waitForInitialNavigationCompleted
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Navigate
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
WEBDRIVER_BIDI
)
)
;
class
BrowsingContextModule
extends
Module
{
#
contextListener
;
constructor
(
messageHandler
)
{
super
(
messageHandler
)
;
this
.
#
contextListener
=
new
BrowsingContextListener
(
)
;
this
.
#
contextListener
.
on
(
"
attached
"
this
.
#
onContextAttached
)
;
}
destroy
(
)
{
this
.
#
contextListener
.
off
(
"
attached
"
this
.
#
onContextAttached
)
;
this
.
#
contextListener
.
destroy
(
)
;
}
close
(
options
=
{
}
)
{
const
{
context
:
contextId
}
=
options
;
assert
.
string
(
contextId
Expected
"
context
"
to
be
a
string
got
{
contextId
}
)
;
const
context
=
TabManager
.
getBrowsingContextById
(
contextId
)
;
if
(
!
context
)
{
throw
new
error
.
NoSuchFrameError
(
Browsing
Context
with
id
{
contextId
}
not
found
)
;
}
if
(
context
.
parent
)
{
throw
new
error
.
InvalidArgumentError
(
Browsing
Context
with
id
{
contextId
}
is
not
top
-
level
)
;
}
if
(
TabManager
.
getTabCount
(
)
=
=
=
1
)
{
logger
.
warn
(
Closing
the
last
open
tab
(
Browsing
Context
id
{
contextId
}
)
expect
inconsistent
behavior
across
platforms
)
;
}
const
browser
=
context
.
embedderElement
;
const
tabBrowser
=
TabManager
.
getTabBrowser
(
browser
.
ownerGlobal
)
;
const
tab
=
tabBrowser
.
getTabForBrowser
(
browser
)
;
TabManager
.
removeTab
(
tab
)
;
}
getTree
(
options
=
{
}
)
{
const
{
maxDepth
=
null
parent
:
parentId
=
null
}
=
options
;
if
(
maxDepth
!
=
=
null
)
{
assert
.
positiveInteger
(
maxDepth
Expected
"
maxDepth
"
to
be
a
positive
integer
got
{
maxDepth
}
)
;
}
let
contexts
;
if
(
parentId
!
=
=
null
)
{
assert
.
string
(
parentId
Expected
"
parent
"
to
be
a
string
got
{
parentId
}
)
;
contexts
=
[
this
.
#
getBrowsingContext
(
parentId
)
]
;
}
else
{
contexts
=
TabManager
.
browsers
.
map
(
browser
=
>
browser
.
browsingContext
)
;
}
const
contextsInfo
=
contexts
.
map
(
context
=
>
{
return
this
.
#
getBrowsingContextInfo
(
context
{
maxDepth
}
)
;
}
)
;
return
{
contexts
:
contextsInfo
}
;
}
#
getBrowsingContext
(
contextId
)
{
if
(
contextId
=
=
=
null
)
{
return
null
;
}
const
context
=
TabManager
.
getBrowsingContextById
(
contextId
)
;
if
(
context
=
=
=
null
)
{
throw
new
error
.
NoSuchFrameError
(
Browsing
Context
with
id
{
contextId
}
not
found
)
;
}
return
context
;
}
#
getBrowsingContextInfo
(
context
options
=
{
}
)
{
const
{
isRoot
=
true
maxDepth
=
null
}
=
options
;
let
children
=
null
;
if
(
maxDepth
=
=
=
null
|
|
maxDepth
>
0
)
{
children
=
context
.
children
.
map
(
context
=
>
this
.
#
getBrowsingContextInfo
(
context
{
maxDepth
:
maxDepth
=
=
=
null
?
maxDepth
:
maxDepth
-
1
isRoot
:
false
}
)
)
;
}
const
contextInfo
=
{
context
:
TabManager
.
getIdForBrowsingContext
(
context
)
url
:
context
.
currentURI
.
spec
children
}
;
if
(
isRoot
)
{
const
parentId
=
TabManager
.
getIdForBrowsingContext
(
context
.
parent
)
;
contextInfo
.
parent
=
parentId
;
}
return
contextInfo
;
}
#
onContextAttached
=
async
(
eventName
data
=
{
}
)
=
>
{
const
{
browsingContext
why
}
=
data
;
if
(
why
=
=
=
"
replace
"
)
{
return
;
}
if
(
!
browsingContext
.
webProgress
)
{
return
;
}
await
waitForInitialNavigationCompleted
(
browsingContext
.
webProgress
{
resolveWhenStarted
:
true
}
)
;
const
contextInfo
=
this
.
#
getBrowsingContextInfo
(
browsingContext
{
maxDepth
:
0
}
)
;
this
.
emitProtocolEvent
(
"
browsingContext
.
contextCreated
"
contextInfo
)
;
}
;
_subscribeEvent
(
params
)
{
switch
(
params
.
event
)
{
case
"
browsingContext
.
contextCreated
"
:
this
.
#
contextListener
.
startListening
(
)
;
return
this
.
messageHandler
.
addSessionData
(
{
moduleName
:
"
browsingContext
"
category
:
"
event
"
contextDescriptor
:
{
type
:
ContextDescriptorType
.
All
}
values
:
[
params
.
event
]
}
)
;
default
:
throw
new
Error
(
Unsupported
event
for
browsingContext
module
{
params
.
event
}
)
;
}
}
_unsubscribeEvent
(
params
)
{
switch
(
params
.
event
)
{
case
"
browsingContext
.
contextCreated
"
:
this
.
#
contextListener
.
stopListening
(
)
;
return
this
.
messageHandler
.
removeSessionData
(
{
moduleName
:
"
browsingContext
"
category
:
"
event
"
contextDescriptor
:
{
type
:
ContextDescriptorType
.
All
}
values
:
[
params
.
event
]
}
)
;
default
:
throw
new
Error
(
Unsupported
event
for
browsingContext
module
{
params
.
event
}
)
;
}
}
static
get
supportedEvents
(
)
{
return
[
"
browsingContext
.
contextCreated
"
]
;
}
}
const
browsingContext
=
BrowsingContextModule
;
