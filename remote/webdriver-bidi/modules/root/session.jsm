"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
session
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Module
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Module
.
jsm
"
RootMessageHandler
:
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
RootMessageHandler
.
jsm
"
}
)
;
class
SessionModule
extends
Module
{
destroy
(
)
{
}
async
subscribe
(
params
=
{
}
)
{
const
{
events
contexts
=
[
]
}
=
params
;
assert
.
array
(
events
"
events
:
array
value
expected
"
)
;
events
.
forEach
(
name
=
>
{
assert
.
string
(
name
{
name
}
:
string
value
expected
)
;
}
)
;
assert
.
array
(
contexts
"
contexts
:
array
value
expected
"
)
;
contexts
.
forEach
(
context
=
>
{
assert
.
string
(
context
{
context
}
:
string
value
expected
)
;
}
)
;
const
allEvents
=
events
.
map
(
event
=
>
Array
.
from
(
this
.
#
obtainEvents
(
event
)
)
)
.
flat
(
)
;
await
Promise
.
allSettled
(
allEvents
.
map
(
event
=
>
{
const
[
moduleName
]
=
event
.
split
(
"
.
"
)
;
this
.
#
assertModuleSupportsEvent
(
moduleName
event
)
;
return
this
.
messageHandler
.
handleCommand
(
{
moduleName
commandName
:
"
_subscribeEvent
"
params
:
{
event
}
destination
:
{
type
:
RootMessageHandler
.
type
}
}
)
;
}
)
)
;
}
async
unsubscribe
(
params
=
{
}
)
{
const
{
events
contexts
=
[
]
}
=
params
;
assert
.
array
(
events
"
events
:
array
value
expected
"
)
;
events
.
forEach
(
name
=
>
{
assert
.
string
(
name
{
name
}
:
string
value
expected
)
;
}
)
;
assert
.
array
(
contexts
"
contexts
:
array
value
expected
"
)
;
contexts
.
forEach
(
context
=
>
{
assert
.
string
(
context
{
context
}
:
string
value
expected
)
;
}
)
;
const
allEvents
=
events
.
map
(
event
=
>
Array
.
from
(
this
.
#
obtainEvents
(
event
)
)
)
.
flat
(
)
;
await
Promise
.
allSettled
(
allEvents
.
map
(
event
=
>
{
const
[
moduleName
]
=
event
.
split
(
"
.
"
)
;
this
.
#
assertModuleSupportsEvent
(
moduleName
event
)
;
return
this
.
messageHandler
.
handleCommand
(
{
moduleName
commandName
:
"
_unsubscribeEvent
"
params
:
{
event
}
destination
:
{
type
:
RootMessageHandler
.
type
}
}
)
;
}
)
)
;
}
#
assertModuleSupportsEventSubscription
(
moduleName
)
{
const
rootModuleClass
=
this
.
#
getRootModuleClass
(
moduleName
)
;
const
supportsEvents
=
rootModuleClass
?
.
supportsCommand
(
"
_subscribeEvent
"
)
;
if
(
!
supportsEvents
)
{
throw
new
error
.
InvalidArgumentError
(
Module
{
moduleName
}
does
not
support
event
subscriptions
)
;
}
}
#
assertModuleSupportsEvent
(
moduleName
event
)
{
const
rootModuleClass
=
this
.
#
getRootModuleClass
(
moduleName
)
;
const
supportsEvent
=
rootModuleClass
?
.
supportsEvent
(
event
)
;
if
(
!
supportsEvent
)
{
throw
new
error
.
InvalidArgumentError
(
Module
{
moduleName
}
does
not
support
event
{
event
}
)
;
}
}
#
getRootModuleClass
(
moduleName
)
{
const
rootDestination
=
{
type
:
RootMessageHandler
.
type
}
;
const
moduleClasses
=
this
.
messageHandler
.
getAllModuleClasses
(
moduleName
rootDestination
)
;
return
moduleClasses
[
0
]
;
}
#
obtainEvents
(
event
)
{
const
events
=
new
Set
(
)
;
const
index
=
event
.
indexOf
(
"
.
"
)
;
if
(
index
>
=
0
)
{
events
.
add
(
event
)
;
}
else
{
this
.
#
assertModuleSupportsEventSubscription
(
event
)
;
}
return
events
;
}
}
const
session
=
SessionModule
;
