"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
script
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
Module
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
shared
/
messagehandler
/
Module
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
deserialize
:
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
RemoteValue
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
getFramesFromStack
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Stack
.
jsm
"
isChromeFrame
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Stack
.
jsm
"
serialize
:
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
RemoteValue
.
jsm
"
stringify
:
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
RemoteValue
.
jsm
"
WindowRealm
:
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
Realm
.
jsm
"
}
)
;
const
EvaluationStatus
=
{
Normal
:
"
normal
"
Throw
:
"
throw
"
}
;
class
ScriptModule
extends
Module
{
#
defaultRealm
;
#
realms
;
constructor
(
messageHandler
)
{
super
(
messageHandler
)
;
this
.
#
defaultRealm
=
new
lazy
.
WindowRealm
(
this
.
messageHandler
.
window
)
;
this
.
#
realms
=
new
Map
(
)
;
}
destroy
(
)
{
this
.
#
defaultRealm
.
destroy
(
)
;
for
(
const
realm
of
this
.
#
realms
.
values
(
)
)
{
realm
.
destroy
(
)
;
}
this
.
#
realms
=
null
;
}
#
buildExceptionDetails
(
exception
stack
realm
resultOwnership
)
{
exception
=
this
.
#
toRawObject
(
exception
)
;
const
frames
=
lazy
.
getFramesFromStack
(
stack
)
|
|
[
]
;
const
callFrames
=
frames
.
filter
(
frame
=
>
!
lazy
.
isChromeFrame
(
frame
)
)
.
map
(
frame
=
>
{
return
{
columnNumber
:
frame
.
columnNumber
functionName
:
frame
.
functionName
lineNumber
:
frame
.
lineNumber
-
1
url
:
frame
.
filename
}
;
}
)
;
return
{
columnNumber
:
stack
.
column
exception
:
lazy
.
serialize
(
exception
1
resultOwnership
new
Map
(
)
realm
)
lineNumber
:
stack
.
line
-
1
stackTrace
:
{
callFrames
}
text
:
lazy
.
stringify
(
exception
)
}
;
}
async
#
buildReturnValue
(
rv
realm
awaitPromise
resultOwnership
)
{
let
evaluationStatus
exception
result
stack
;
if
(
"
return
"
in
rv
)
{
evaluationStatus
=
EvaluationStatus
.
Normal
;
if
(
awaitPromise
&
&
rv
.
return
instanceof
Debugger
.
Object
&
&
rv
.
return
.
isPromise
)
{
try
{
const
asyncResult
=
await
rv
.
return
.
unsafeDereference
(
)
;
result
=
realm
.
globalObjectReference
.
makeDebuggeeValue
(
asyncResult
)
;
}
catch
(
asyncException
)
{
evaluationStatus
=
EvaluationStatus
.
Throw
;
exception
=
realm
.
globalObjectReference
.
makeDebuggeeValue
(
asyncException
)
;
stack
=
rv
.
return
.
promiseResolutionSite
;
}
}
else
{
result
=
rv
.
return
;
}
}
else
if
(
"
throw
"
in
rv
)
{
evaluationStatus
=
EvaluationStatus
.
Throw
;
exception
=
rv
.
throw
;
stack
=
rv
.
stack
;
}
switch
(
evaluationStatus
)
{
case
EvaluationStatus
.
Normal
:
return
{
evaluationStatus
result
:
lazy
.
serialize
(
this
.
#
toRawObject
(
result
)
1
resultOwnership
new
Map
(
)
realm
)
realmId
:
realm
.
id
}
;
case
EvaluationStatus
.
Throw
:
return
{
evaluationStatus
exceptionDetails
:
this
.
#
buildExceptionDetails
(
exception
stack
realm
resultOwnership
)
realmId
:
realm
.
id
}
;
default
:
throw
new
lazy
.
error
.
UnsupportedOperationError
(
Unsupported
completion
value
for
expression
evaluation
)
;
}
}
#
getRealm
(
realmId
sandboxName
)
{
if
(
realmId
=
=
=
null
)
{
return
this
.
#
getRealmFromSandboxName
(
sandboxName
)
;
}
if
(
this
.
#
defaultRealm
.
id
=
=
realmId
)
{
return
this
.
#
defaultRealm
;
}
const
sandboxRealm
=
Array
.
from
(
this
.
#
realms
.
values
(
)
)
.
find
(
realm
=
>
realm
.
id
=
=
=
realmId
)
;
if
(
sandboxRealm
)
{
return
sandboxRealm
;
}
throw
new
lazy
.
error
.
NoSuchFrameError
(
Realm
with
id
{
realmId
}
not
found
)
;
}
#
getRealmFromSandboxName
(
sandboxName
)
{
if
(
sandboxName
=
=
=
null
)
{
return
this
.
#
defaultRealm
;
}
if
(
this
.
#
realms
.
has
(
sandboxName
)
)
{
return
this
.
#
realms
.
get
(
sandboxName
)
;
}
const
realm
=
new
lazy
.
WindowRealm
(
this
.
messageHandler
.
window
{
sandboxName
}
)
;
this
.
#
realms
.
set
(
sandboxName
realm
)
;
return
realm
;
}
#
toRawObject
(
maybeDebuggerObject
)
{
if
(
maybeDebuggerObject
instanceof
Debugger
.
Object
)
{
const
rawObject
=
maybeDebuggerObject
.
unsafeDereference
(
)
;
return
Cu
.
waiveXrays
(
rawObject
)
;
}
return
maybeDebuggerObject
;
}
async
callFunctionDeclaration
(
options
)
{
const
{
awaitPromise
commandArguments
=
null
functionDeclaration
realmId
=
null
resultOwnership
sandbox
:
sandboxName
=
null
thisParameter
=
null
}
=
options
;
const
realm
=
this
.
#
getRealm
(
realmId
sandboxName
)
;
const
deserializedArguments
=
commandArguments
!
=
=
null
?
commandArguments
.
map
(
arg
=
>
lazy
.
deserialize
(
realm
arg
)
)
:
[
]
;
const
deserializedThis
=
thisParameter
!
=
=
null
?
lazy
.
deserialize
(
realm
thisParameter
)
:
null
;
const
rv
=
realm
.
executeInGlobalWithBindings
(
functionDeclaration
deserializedArguments
deserializedThis
)
;
return
this
.
#
buildReturnValue
(
rv
realm
awaitPromise
resultOwnership
)
;
}
disownHandles
(
options
)
{
const
{
handles
realmId
=
null
sandbox
:
sandboxName
=
null
}
=
options
;
const
realm
=
this
.
#
getRealm
(
realmId
sandboxName
)
;
for
(
const
handle
of
handles
)
{
realm
.
removeObjectHandle
(
handle
)
;
}
}
async
evaluateExpression
(
options
)
{
const
{
awaitPromise
expression
realmId
=
null
resultOwnership
sandbox
:
sandboxName
=
null
}
=
options
;
const
realm
=
this
.
#
getRealm
(
realmId
sandboxName
)
;
const
rv
=
realm
.
executeInGlobal
(
expression
)
;
return
this
.
#
buildReturnValue
(
rv
realm
awaitPromise
resultOwnership
)
;
}
getWindowRealms
(
)
{
return
[
this
.
#
defaultRealm
.
.
.
this
.
#
realms
.
values
(
)
]
.
map
(
realm
=
>
realm
.
getInfo
(
)
)
;
}
}
const
script
=
ScriptModule
;
