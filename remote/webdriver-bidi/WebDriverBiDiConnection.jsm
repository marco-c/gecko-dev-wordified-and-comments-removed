"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
splitMethod
"
"
WebDriverBiDiConnection
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
RemoteAgent
:
"
chrome
:
/
/
remote
/
content
/
components
/
RemoteAgent
.
jsm
"
truncate
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
WebSocketConnection
:
"
chrome
:
/
/
remote
/
content
/
shared
/
WebSocketConnection
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
WEBDRIVER_BIDI
)
)
;
class
WebDriverBiDiConnection
extends
WebSocketConnection
{
constructor
(
webSocket
httpdConnection
)
{
super
(
webSocket
httpdConnection
)
;
this
.
session
=
null
;
}
registerSession
(
session
)
{
if
(
this
.
session
)
{
throw
new
error
.
UnknownError
(
"
A
WebDriver
session
has
already
been
set
"
)
;
}
this
.
session
=
session
;
logger
.
debug
(
Connection
{
this
.
id
}
attached
to
session
{
session
.
id
}
)
;
}
unregisterSession
(
)
{
if
(
!
this
.
session
)
{
return
;
}
this
.
session
.
removeConnection
(
this
)
;
this
.
session
=
null
;
}
send
(
data
)
{
const
payload
=
JSON
.
stringify
(
data
null
Log
.
verbose
?
"
\
t
"
:
null
)
;
logger
.
debug
(
truncate
{
this
.
session
?
.
id
|
|
"
no
session
"
}
<
-
{
payload
}
)
;
super
.
send
(
data
)
;
}
sendError
(
id
err
)
{
const
webDriverError
=
error
.
wrap
(
err
)
;
this
.
send
(
{
id
error
:
webDriverError
.
status
message
:
webDriverError
.
message
stacktrace
:
webDriverError
.
stack
}
)
;
}
sendEvent
(
method
params
)
{
this
.
send
(
{
method
params
}
)
;
}
sendResult
(
id
result
)
{
result
=
typeof
result
!
=
=
"
undefined
"
?
result
:
{
}
;
this
.
send
(
{
id
result
}
)
;
}
onClosed
(
)
{
this
.
unregisterSession
(
)
;
super
.
onClosed
(
)
;
}
async
onPacket
(
packet
)
{
const
payload
=
JSON
.
stringify
(
packet
null
Log
.
verbose
?
"
\
t
"
:
null
)
;
logger
.
debug
(
truncate
{
this
.
session
?
.
id
|
|
"
no
session
"
}
-
>
{
payload
}
)
;
const
{
id
method
params
}
=
packet
;
try
{
assert
.
positiveInteger
(
id
"
id
:
unsigned
integer
value
expected
"
)
;
assert
.
string
(
method
"
method
:
string
value
expected
"
)
;
assert
.
object
(
params
"
params
:
object
value
expected
"
)
;
const
{
module
command
}
=
splitMethod
(
method
)
;
let
result
;
if
(
module
=
=
=
"
session
"
&
&
command
=
=
=
"
new
"
)
{
result
=
RemoteAgent
.
webDriverBiDi
.
createSession
(
params
this
)
;
}
else
if
(
module
=
=
=
"
session
"
&
&
command
=
=
=
"
status
"
)
{
result
=
RemoteAgent
.
webDriverBiDi
.
getSessionReadinessStatus
(
)
;
}
else
{
assert
.
session
(
this
.
session
)
;
if
(
command
.
startsWith
(
"
_
"
)
)
{
throw
new
error
.
UnknownCommandError
(
method
)
;
}
result
=
await
this
.
session
.
execute
(
module
command
params
)
;
}
this
.
sendResult
(
id
result
)
;
}
catch
(
e
)
{
this
.
sendError
(
packet
.
id
e
)
;
}
}
}
function
splitMethod
(
method
)
{
const
parts
=
method
.
split
(
"
.
"
)
;
if
(
parts
.
length
!
=
2
|
|
parts
[
0
]
.
length
=
=
0
|
|
parts
[
1
]
.
length
=
=
0
)
{
throw
new
TypeError
(
Invalid
method
format
:
'
{
method
}
'
)
;
}
return
{
module
:
parts
[
0
]
command
:
parts
[
1
]
}
;
}
