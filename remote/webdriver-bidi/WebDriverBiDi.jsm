"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
WebDriverBiDi
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
WebDriverSession
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Session
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
WEBDRIVER_BIDI
)
)
;
class
WebDriverBiDi
{
constructor
(
agent
)
{
this
.
agent
=
agent
;
this
.
_running
=
false
;
this
.
_session
=
null
;
}
get
address
(
)
{
return
ws
:
/
/
{
this
.
agent
.
host
}
:
{
this
.
agent
.
port
}
;
}
get
session
(
)
{
return
this
.
_session
;
}
createSession
(
capabilities
)
{
if
(
this
.
session
)
{
throw
new
error
.
SessionNotCreatedError
(
"
Maximum
number
of
active
sessions
"
)
;
}
this
.
_session
=
new
WebDriverSession
(
capabilities
)
;
if
(
this
.
agent
.
listening
)
{
this
.
agent
.
server
.
registerPathHandler
(
this
.
session
.
path
this
.
session
)
;
logger
.
debug
(
Registered
session
handler
:
{
this
.
session
.
path
}
)
;
}
return
{
sessionId
:
this
.
session
.
id
capabilities
:
this
.
session
.
capabilities
}
;
}
deleteSession
(
)
{
if
(
!
this
.
session
)
{
return
;
}
if
(
this
.
agent
.
listening
)
{
this
.
agent
.
server
.
registerPathHandler
(
this
.
session
.
path
null
)
;
logger
.
debug
(
Unregistered
session
handler
:
{
this
.
session
.
path
}
)
;
}
this
.
session
.
destroy
(
)
;
this
.
_session
=
null
;
}
start
(
)
{
if
(
this
.
_running
)
{
return
;
}
this
.
_running
=
true
;
Services
.
obs
.
notifyObservers
(
null
"
remote
-
listening
"
WebDriver
BiDi
listening
on
{
this
.
address
}
)
;
}
stop
(
)
{
if
(
!
this
.
_running
)
{
return
;
}
try
{
this
.
deleteSession
(
)
;
}
finally
{
this
.
_running
=
false
;
}
}
}
