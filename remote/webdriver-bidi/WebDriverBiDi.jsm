"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
WebDriverBiDi
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
WebDriverNewSessionHandler
:
"
chrome
:
/
/
remote
/
content
/
webdriver
-
bidi
/
NewSessionHandler
.
jsm
"
WebDriverSession
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Session
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
WEBDRIVER_BIDI
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
textEncoder
"
(
)
=
>
new
TextEncoder
(
)
)
;
class
WebDriverBiDi
{
constructor
(
agent
)
{
this
.
agent
=
agent
;
this
.
_running
=
false
;
this
.
_session
=
null
;
this
.
_sessionlessConnections
=
new
Set
(
)
;
}
get
address
(
)
{
return
ws
:
/
/
{
this
.
agent
.
host
}
:
{
this
.
agent
.
port
}
;
}
get
session
(
)
{
return
this
.
_session
;
}
addSessionlessConnection
(
connection
)
{
this
.
_sessionlessConnections
.
add
(
connection
)
;
}
createSession
(
capabilities
sessionlessConnection
)
{
if
(
this
.
session
)
{
throw
new
error
.
SessionNotCreatedError
(
"
Maximum
number
of
active
sessions
"
)
;
}
this
.
_session
=
new
WebDriverSession
(
capabilities
sessionlessConnection
)
;
let
webSocketUrl
=
null
;
if
(
this
.
agent
.
listening
&
&
(
this
.
session
.
capabilities
.
get
(
"
webSocketUrl
"
)
|
|
sessionlessConnection
)
)
{
this
.
agent
.
server
.
registerPathHandler
(
this
.
session
.
path
this
.
session
)
;
webSocketUrl
=
{
this
.
address
}
{
this
.
session
.
path
}
;
logger
.
debug
(
Registered
session
handler
:
{
this
.
session
.
path
}
)
;
if
(
sessionlessConnection
)
{
this
.
_sessionlessConnections
.
delete
(
sessionlessConnection
)
;
}
}
this
.
session
.
capabilities
.
set
(
"
webSocketUrl
"
webSocketUrl
)
;
return
{
sessionId
:
this
.
session
.
id
capabilities
:
this
.
session
.
capabilities
}
;
}
deleteSession
(
)
{
if
(
!
this
.
session
)
{
return
;
}
if
(
this
.
agent
.
listening
&
&
this
.
session
.
capabilities
.
get
(
"
webSocketUrl
"
)
)
{
this
.
agent
.
server
.
registerPathHandler
(
this
.
session
.
path
null
)
;
logger
.
debug
(
Unregistered
session
handler
:
{
this
.
session
.
path
}
)
;
}
this
.
session
.
destroy
(
)
;
this
.
_session
=
null
;
}
getSessionReadinessStatus
(
)
{
if
(
this
.
session
)
{
return
{
ready
:
false
message
:
"
Session
already
started
"
}
;
}
return
{
ready
:
true
message
:
"
"
}
;
}
async
start
(
)
{
if
(
this
.
_running
)
{
return
;
}
this
.
_running
=
true
;
this
.
agent
.
server
.
registerPathHandler
(
"
/
session
"
new
WebDriverNewSessionHandler
(
this
)
)
;
Cu
.
printStderr
(
WebDriver
BiDi
listening
on
{
this
.
address
}
\
n
)
;
this
.
_activePortPath
=
PathUtils
.
join
(
PathUtils
.
profileDir
"
WebDriverBiDiActivePort
"
)
;
const
data
=
{
this
.
agent
.
port
}
;
try
{
await
IOUtils
.
write
(
this
.
_activePortPath
textEncoder
.
encode
(
data
)
)
;
}
catch
(
e
)
{
logger
.
warn
(
Failed
to
create
{
this
.
_activePortPath
}
(
{
e
.
message
}
)
)
;
}
}
async
stop
(
)
{
if
(
!
this
.
_running
)
{
return
;
}
try
{
try
{
await
IOUtils
.
remove
(
this
.
_activePortPath
)
;
}
catch
(
e
)
{
logger
.
warn
(
Failed
to
remove
{
this
.
_activePortPath
}
(
{
e
.
message
}
)
)
;
}
this
.
deleteSession
(
)
;
this
.
agent
.
server
.
registerPathHandler
(
"
/
session
"
null
)
;
this
.
_sessionlessConnections
.
forEach
(
connection
=
>
connection
.
close
(
)
)
;
this
.
_sessionlessConnections
.
clear
(
)
;
}
finally
{
this
.
_running
=
false
;
}
}
}
