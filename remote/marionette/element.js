"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
element
"
"
ShadowRoot
"
"
WebElement
"
"
WebFrame
"
"
WebReference
"
"
WebWindow
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
ContentDOMReference
:
"
resource
:
/
/
gre
/
modules
/
ContentDOMReference
.
jsm
"
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
atom
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
atom
.
js
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
PollPromise
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
sync
.
js
"
pprint
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
}
)
;
const
ORDERED_NODE_ITERATOR_TYPE
=
5
;
const
FIRST_ORDERED_NODE_TYPE
=
9
;
const
ELEMENT_NODE
=
1
;
const
DOCUMENT_NODE
=
9
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
XUL_CHECKED_ELS
=
new
Set
(
[
"
button
"
"
checkbox
"
"
toolbarbutton
"
]
)
;
const
XUL_SELECTED_ELS
=
new
Set
(
[
"
menu
"
"
menuitem
"
"
menuseparator
"
"
radio
"
"
richlistitem
"
"
tab
"
]
)
;
const
element
=
{
}
;
element
.
Strategy
=
{
ClassName
:
"
class
name
"
Selector
:
"
css
selector
"
ID
:
"
id
"
Name
:
"
name
"
LinkText
:
"
link
text
"
PartialLinkText
:
"
partial
link
text
"
TagName
:
"
tag
name
"
XPath
:
"
xpath
"
}
;
element
.
ReferenceStore
=
class
{
constructor
(
)
{
this
.
refs
=
new
Map
(
)
;
this
.
domRefs
=
new
Map
(
)
;
}
clear
(
browsingContext
)
{
if
(
!
browsingContext
)
{
this
.
refs
.
clear
(
)
;
this
.
domRefs
.
clear
(
)
;
return
;
}
for
(
const
context
of
browsingContext
.
getAllBrowsingContextsInSubtree
(
)
)
{
for
(
const
[
uuid
elId
]
of
this
.
refs
)
{
if
(
elId
.
browsingContextId
=
=
context
.
id
)
{
this
.
refs
.
delete
(
uuid
)
;
this
.
domRefs
.
delete
(
elId
.
id
)
;
}
}
}
}
addAll
(
elIds
)
{
return
[
.
.
.
elIds
]
.
map
(
elId
=
>
this
.
add
(
elId
)
)
;
}
add
(
elId
)
{
if
(
!
elId
.
id
|
|
!
elId
.
browsingContextId
)
{
throw
new
TypeError
(
lazy
.
pprint
Expected
ElementIdentifier
got
:
{
elId
}
)
;
}
if
(
this
.
domRefs
.
has
(
elId
.
id
)
)
{
return
WebReference
.
fromJSON
(
this
.
domRefs
.
get
(
elId
.
id
)
)
;
}
const
webEl
=
WebReference
.
fromJSON
(
elId
.
webElRef
)
;
this
.
refs
.
set
(
webEl
.
uuid
elId
)
;
this
.
domRefs
.
set
(
elId
.
id
elId
.
webElRef
)
;
return
webEl
;
}
has
(
webEl
)
{
if
(
!
(
webEl
instanceof
WebReference
)
)
{
throw
new
TypeError
(
lazy
.
pprint
Expected
web
element
got
:
{
webEl
}
)
;
}
return
this
.
refs
.
has
(
webEl
.
uuid
)
;
}
get
(
webEl
)
{
if
(
!
(
webEl
instanceof
WebReference
)
)
{
throw
new
TypeError
(
lazy
.
pprint
Expected
web
element
got
:
{
webEl
}
)
;
}
const
elId
=
this
.
refs
.
get
(
webEl
.
uuid
)
;
if
(
!
elId
)
{
throw
new
lazy
.
error
.
NoSuchElementError
(
"
Web
element
reference
not
seen
before
:
"
+
webEl
.
uuid
)
;
}
return
elId
;
}
}
;
element
.
find
=
function
(
container
strategy
selector
options
=
{
}
)
{
const
{
all
=
false
startNode
timeout
=
0
}
=
options
;
let
searchFn
;
if
(
all
)
{
searchFn
=
findElements
.
bind
(
this
)
;
}
else
{
searchFn
=
findElement
.
bind
(
this
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
findElements
=
new
lazy
.
PollPromise
(
(
resolve
reject
)
=
>
{
let
res
=
find_
(
container
strategy
selector
searchFn
{
all
startNode
}
)
;
if
(
res
.
length
)
{
resolve
(
Array
.
from
(
res
)
)
;
}
else
{
reject
(
[
]
)
;
}
}
{
timeout
}
)
;
findElements
.
then
(
foundEls
=
>
{
if
(
!
all
&
&
(
!
foundEls
|
|
!
foundEls
.
length
)
)
{
let
msg
=
Unable
to
locate
element
:
{
selector
}
;
reject
(
new
lazy
.
error
.
NoSuchElementError
(
msg
)
)
;
}
if
(
all
)
{
resolve
(
foundEls
)
;
}
resolve
(
foundEls
[
0
]
)
;
}
reject
)
;
}
)
;
}
;
function
find_
(
container
strategy
selector
searchFn
{
startNode
=
null
all
=
false
}
=
{
}
)
{
let
rootNode
=
container
.
frame
.
document
;
if
(
!
startNode
)
{
startNode
=
rootNode
;
}
let
res
;
try
{
res
=
searchFn
(
strategy
selector
rootNode
startNode
)
;
}
catch
(
e
)
{
throw
new
lazy
.
error
.
InvalidSelectorError
(
Given
{
strategy
}
expression
"
{
selector
}
"
is
invalid
:
{
e
}
)
;
}
if
(
res
)
{
if
(
all
)
{
return
res
;
}
return
[
res
]
;
}
return
[
]
;
}
element
.
findByXPath
=
function
(
document
startNode
expression
)
{
let
iter
=
document
.
evaluate
(
expression
startNode
null
FIRST_ORDERED_NODE_TYPE
null
)
;
return
iter
.
singleNodeValue
;
}
;
element
.
findByXPathAll
=
function
*
(
document
startNode
expression
)
{
let
iter
=
document
.
evaluate
(
expression
startNode
null
ORDERED_NODE_ITERATOR_TYPE
null
)
;
let
el
=
iter
.
iterateNext
(
)
;
while
(
el
)
{
yield
el
;
el
=
iter
.
iterateNext
(
)
;
}
}
;
element
.
findByLinkText
=
function
(
startNode
linkText
)
{
return
filterLinks
(
startNode
link
=
>
lazy
.
atom
.
getElementText
(
link
)
.
trim
(
)
=
=
=
linkText
)
;
}
;
element
.
findByPartialLinkText
=
function
(
startNode
linkText
)
{
return
filterLinks
(
startNode
link
=
>
lazy
.
atom
.
getElementText
(
link
)
.
includes
(
linkText
)
)
;
}
;
function
*
filterLinks
(
startNode
predicate
)
{
for
(
let
link
of
startNode
.
getElementsByTagName
(
"
a
"
)
)
{
if
(
predicate
(
link
)
)
{
yield
link
;
}
}
}
function
findElement
(
strategy
selector
document
startNode
=
undefined
)
{
switch
(
strategy
)
{
case
element
.
Strategy
.
ID
:
{
if
(
startNode
.
getElementById
)
{
return
startNode
.
getElementById
(
selector
)
;
}
let
expr
=
.
/
/
*
[
id
=
"
{
selector
}
"
]
;
return
element
.
findByXPath
(
document
startNode
expr
)
;
}
case
element
.
Strategy
.
Name
:
{
if
(
startNode
.
getElementsByName
)
{
return
startNode
.
getElementsByName
(
selector
)
[
0
]
;
}
let
expr
=
.
/
/
*
[
name
=
"
{
selector
}
"
]
;
return
element
.
findByXPath
(
document
startNode
expr
)
;
}
case
element
.
Strategy
.
ClassName
:
return
startNode
.
getElementsByClassName
(
selector
)
[
0
]
;
case
element
.
Strategy
.
TagName
:
return
startNode
.
getElementsByTagName
(
selector
)
[
0
]
;
case
element
.
Strategy
.
XPath
:
return
element
.
findByXPath
(
document
startNode
selector
)
;
case
element
.
Strategy
.
LinkText
:
for
(
let
link
of
startNode
.
getElementsByTagName
(
"
a
"
)
)
{
if
(
lazy
.
atom
.
getElementText
(
link
)
.
trim
(
)
=
=
=
selector
)
{
return
link
;
}
}
return
undefined
;
case
element
.
Strategy
.
PartialLinkText
:
for
(
let
link
of
startNode
.
getElementsByTagName
(
"
a
"
)
)
{
if
(
lazy
.
atom
.
getElementText
(
link
)
.
includes
(
selector
)
)
{
return
link
;
}
}
return
undefined
;
case
element
.
Strategy
.
Selector
:
try
{
return
startNode
.
querySelector
(
selector
)
;
}
catch
(
e
)
{
throw
new
lazy
.
error
.
InvalidSelectorError
(
{
e
.
message
}
:
"
{
selector
}
"
)
;
}
}
throw
new
lazy
.
error
.
InvalidSelectorError
(
No
such
strategy
:
{
strategy
}
)
;
}
function
findElements
(
strategy
selector
document
startNode
=
undefined
)
{
switch
(
strategy
)
{
case
element
.
Strategy
.
ID
:
selector
=
.
/
/
*
[
id
=
"
{
selector
}
"
]
;
case
element
.
Strategy
.
XPath
:
return
[
.
.
.
element
.
findByXPathAll
(
document
startNode
selector
)
]
;
case
element
.
Strategy
.
Name
:
if
(
startNode
.
getElementsByName
)
{
return
startNode
.
getElementsByName
(
selector
)
;
}
return
[
.
.
.
element
.
findByXPathAll
(
document
startNode
.
/
/
*
[
name
=
"
{
selector
}
"
]
)
]
;
case
element
.
Strategy
.
ClassName
:
return
startNode
.
getElementsByClassName
(
selector
)
;
case
element
.
Strategy
.
TagName
:
return
startNode
.
getElementsByTagName
(
selector
)
;
case
element
.
Strategy
.
LinkText
:
return
[
.
.
.
element
.
findByLinkText
(
startNode
selector
)
]
;
case
element
.
Strategy
.
PartialLinkText
:
return
[
.
.
.
element
.
findByPartialLinkText
(
startNode
selector
)
]
;
case
element
.
Strategy
.
Selector
:
return
startNode
.
querySelectorAll
(
selector
)
;
default
:
throw
new
lazy
.
error
.
InvalidSelectorError
(
No
such
strategy
:
{
strategy
}
)
;
}
}
element
.
findClosest
=
function
(
startNode
selector
)
{
let
node
=
startNode
;
while
(
node
.
parentNode
&
&
node
.
parentNode
.
nodeType
=
=
ELEMENT_NODE
)
{
node
=
node
.
parentNode
;
if
(
node
.
matches
(
selector
)
)
{
return
node
;
}
}
return
null
;
}
;
element
.
getElementId
=
function
(
el
)
{
if
(
element
.
isStale
(
el
)
)
{
throw
new
lazy
.
error
.
StaleElementReferenceError
(
lazy
.
pprint
The
element
reference
of
{
el
}
+
"
is
stale
;
either
the
element
is
no
longer
attached
to
the
DOM
"
+
"
it
is
not
in
the
current
frame
context
"
+
"
or
the
document
has
been
refreshed
"
)
;
}
const
webEl
=
WebReference
.
from
(
el
)
;
const
id
=
lazy
.
ContentDOMReference
.
get
(
el
)
;
const
browsingContext
=
BrowsingContext
.
get
(
id
.
browsingContextId
)
;
id
.
webElRef
=
webEl
.
toJSON
(
)
;
id
.
browserId
=
browsingContext
.
browserId
;
id
.
isTopLevel
=
!
browsingContext
.
parent
;
return
id
;
}
;
element
.
resolveElement
=
function
(
id
win
)
{
let
sameBrowsingContext
;
if
(
id
.
isTopLevel
)
{
sameBrowsingContext
=
id
.
browserId
=
=
win
?
.
browsingContext
.
browserId
;
}
else
{
sameBrowsingContext
=
id
.
browsingContextId
=
=
win
?
.
browsingContext
.
id
;
}
if
(
!
sameBrowsingContext
)
{
throw
new
lazy
.
error
.
NoSuchElementError
(
Web
element
reference
not
seen
before
:
{
JSON
.
stringify
(
id
.
webElRef
)
}
)
;
}
const
el
=
lazy
.
ContentDOMReference
.
resolve
(
id
)
;
if
(
element
.
isStale
(
el
win
)
)
{
throw
new
lazy
.
error
.
StaleElementReferenceError
(
lazy
.
pprint
The
element
reference
of
{
el
|
|
JSON
.
stringify
(
id
.
webElRef
)
}
+
"
is
stale
;
either
the
element
is
no
longer
attached
to
the
DOM
"
+
"
it
is
not
in
the
current
frame
context
"
+
"
or
the
document
has
been
refreshed
"
)
;
}
return
el
;
}
;
element
.
isCollection
=
function
(
seq
)
{
switch
(
Object
.
prototype
.
toString
.
call
(
seq
)
)
{
case
"
[
object
Arguments
]
"
:
case
"
[
object
Array
]
"
:
case
"
[
object
FileList
]
"
:
case
"
[
object
HTMLAllCollection
]
"
:
case
"
[
object
HTMLCollection
]
"
:
case
"
[
object
HTMLFormControlsCollection
]
"
:
case
"
[
object
HTMLOptionsCollection
]
"
:
case
"
[
object
NodeList
]
"
:
return
true
;
default
:
return
false
;
}
}
;
element
.
isStale
=
function
(
el
win
=
undefined
)
{
if
(
typeof
win
=
=
"
undefined
"
)
{
win
=
el
.
ownerGlobal
;
}
if
(
el
=
=
=
null
|
|
!
el
.
ownerGlobal
|
|
el
.
ownerDocument
!
=
=
win
.
document
)
{
return
true
;
}
return
!
el
.
isConnected
;
}
;
element
.
isSelected
=
function
(
el
)
{
if
(
!
el
)
{
return
false
;
}
if
(
element
.
isXULElement
(
el
)
)
{
if
(
XUL_CHECKED_ELS
.
has
(
el
.
tagName
)
)
{
return
el
.
checked
;
}
else
if
(
XUL_SELECTED_ELS
.
has
(
el
.
tagName
)
)
{
return
el
.
selected
;
}
}
else
if
(
element
.
isDOMElement
(
el
)
)
{
if
(
el
.
localName
=
=
"
input
"
&
&
[
"
checkbox
"
"
radio
"
]
.
includes
(
el
.
type
)
)
{
return
el
.
checked
;
}
else
if
(
el
.
localName
=
=
"
option
"
)
{
return
el
.
selected
;
}
}
return
false
;
}
;
element
.
isReadOnly
=
function
(
el
)
{
return
(
element
.
isDOMElement
(
el
)
&
&
[
"
input
"
"
textarea
"
]
.
includes
(
el
.
localName
)
&
&
el
.
readOnly
)
;
}
;
element
.
isDisabled
=
function
(
el
)
{
if
(
!
element
.
isDOMElement
(
el
)
)
{
return
false
;
}
switch
(
el
.
localName
)
{
case
"
option
"
:
case
"
optgroup
"
:
if
(
el
.
disabled
)
{
return
true
;
}
let
parent
=
element
.
findClosest
(
el
"
optgroup
select
"
)
;
return
element
.
isDisabled
(
parent
)
;
case
"
button
"
:
case
"
input
"
:
case
"
select
"
:
case
"
textarea
"
:
return
el
.
disabled
;
default
:
return
false
;
}
}
;
element
.
isMutableFormControl
=
function
(
el
)
{
if
(
!
element
.
isDOMElement
(
el
)
)
{
return
false
;
}
if
(
element
.
isReadOnly
(
el
)
|
|
element
.
isDisabled
(
el
)
)
{
return
false
;
}
if
(
el
.
localName
=
=
"
textarea
"
)
{
return
true
;
}
if
(
el
.
localName
!
=
"
input
"
)
{
return
false
;
}
switch
(
el
.
type
)
{
case
"
color
"
:
case
"
date
"
:
case
"
datetime
-
local
"
:
case
"
email
"
:
case
"
file
"
:
case
"
month
"
:
case
"
number
"
:
case
"
password
"
:
case
"
range
"
:
case
"
search
"
:
case
"
tel
"
:
case
"
text
"
:
case
"
time
"
:
case
"
url
"
:
case
"
week
"
:
return
true
;
default
:
return
false
;
}
}
;
element
.
isEditingHost
=
function
(
el
)
{
return
(
element
.
isDOMElement
(
el
)
&
&
(
el
.
isContentEditable
|
|
el
.
ownerDocument
.
designMode
=
=
"
on
"
)
)
;
}
;
element
.
isEditable
=
function
(
el
)
{
if
(
!
element
.
isDOMElement
(
el
)
)
{
return
false
;
}
if
(
element
.
isReadOnly
(
el
)
|
|
element
.
isDisabled
(
el
)
)
{
return
false
;
}
return
element
.
isMutableFormControl
(
el
)
|
|
element
.
isEditingHost
(
el
)
;
}
;
element
.
coordinates
=
function
(
node
xOffset
=
undefined
yOffset
=
undefined
)
{
let
box
=
node
.
getBoundingClientRect
(
)
;
if
(
typeof
xOffset
=
=
"
undefined
"
|
|
xOffset
=
=
=
null
)
{
xOffset
=
box
.
width
/
2
.
0
;
}
if
(
typeof
yOffset
=
=
"
undefined
"
|
|
yOffset
=
=
=
null
)
{
yOffset
=
box
.
height
/
2
.
0
;
}
if
(
typeof
yOffset
!
=
"
number
"
|
|
typeof
xOffset
!
=
"
number
"
)
{
throw
new
TypeError
(
"
Offset
must
be
a
number
"
)
;
}
return
{
x
:
box
.
left
+
xOffset
y
:
box
.
top
+
yOffset
}
;
}
;
element
.
inViewport
=
function
(
el
x
=
undefined
y
=
undefined
)
{
let
win
=
el
.
ownerGlobal
;
let
c
=
element
.
coordinates
(
el
x
y
)
;
let
vp
=
{
top
:
win
.
pageYOffset
left
:
win
.
pageXOffset
bottom
:
win
.
pageYOffset
+
win
.
innerHeight
right
:
win
.
pageXOffset
+
win
.
innerWidth
}
;
return
(
vp
.
left
<
=
c
.
x
+
win
.
pageXOffset
&
&
c
.
x
+
win
.
pageXOffset
<
=
vp
.
right
&
&
vp
.
top
<
=
c
.
y
+
win
.
pageYOffset
&
&
c
.
y
+
win
.
pageYOffset
<
=
vp
.
bottom
)
;
}
;
element
.
getContainer
=
function
(
el
)
{
if
(
[
"
option
"
"
optgroup
"
]
.
includes
(
el
.
localName
)
)
{
return
element
.
findClosest
(
el
"
datalist
select
"
)
|
|
el
;
}
return
el
;
}
;
element
.
isInView
=
function
(
el
)
{
let
originalPointerEvents
=
el
.
style
.
pointerEvents
;
try
{
el
.
style
.
pointerEvents
=
"
auto
"
;
const
tree
=
element
.
getPointerInteractablePaintTree
(
el
)
;
if
(
el
.
localName
=
=
=
"
tr
"
&
&
el
.
cells
&
&
el
.
cells
.
length
)
{
return
tree
.
includes
(
el
.
cells
[
0
]
)
;
}
return
tree
.
includes
(
el
)
;
}
finally
{
el
.
style
.
pointerEvents
=
originalPointerEvents
;
}
}
;
element
.
isVisible
=
function
(
el
x
=
undefined
y
=
undefined
)
{
let
win
=
el
.
ownerGlobal
;
if
(
!
lazy
.
atom
.
isElementDisplayed
(
el
win
)
)
{
return
false
;
}
if
(
el
.
tagName
.
toLowerCase
(
)
=
=
"
body
"
)
{
return
true
;
}
if
(
!
element
.
inViewport
(
el
x
y
)
)
{
element
.
scrollIntoView
(
el
)
;
if
(
!
element
.
inViewport
(
el
)
)
{
return
false
;
}
}
return
true
;
}
;
element
.
isObscured
=
function
(
el
)
{
let
tree
=
element
.
getPointerInteractablePaintTree
(
el
)
;
return
!
el
.
contains
(
tree
[
0
]
)
;
}
;
element
.
getInViewCentrePoint
=
function
(
rect
win
)
{
const
{
floor
max
min
}
=
Math
;
let
visible
=
{
left
:
max
(
0
min
(
rect
.
x
rect
.
x
+
rect
.
width
)
)
right
:
min
(
win
.
innerWidth
max
(
rect
.
x
rect
.
x
+
rect
.
width
)
)
top
:
max
(
0
min
(
rect
.
y
rect
.
y
+
rect
.
height
)
)
bottom
:
min
(
win
.
innerHeight
max
(
rect
.
y
rect
.
y
+
rect
.
height
)
)
}
;
let
x
=
(
visible
.
left
+
visible
.
right
)
/
2
.
0
;
let
y
=
(
visible
.
top
+
visible
.
bottom
)
/
2
.
0
;
x
=
floor
(
x
)
;
y
=
floor
(
y
)
;
return
{
x
y
}
;
}
;
element
.
getPointerInteractablePaintTree
=
function
(
el
)
{
const
doc
=
el
.
ownerDocument
;
const
win
=
doc
.
defaultView
;
const
rootNode
=
el
.
getRootNode
(
)
;
if
(
!
el
.
isConnected
)
{
return
[
]
;
}
let
rects
=
el
.
getClientRects
(
)
;
if
(
!
rects
.
length
)
{
return
[
]
;
}
let
centre
=
element
.
getInViewCentrePoint
(
rects
[
0
]
win
)
;
return
rootNode
.
elementsFromPoint
(
centre
.
x
centre
.
y
)
;
}
;
element
.
isKeyboardInteractable
=
(
)
=
>
true
;
element
.
scrollIntoView
=
function
(
el
)
{
if
(
el
.
scrollIntoView
)
{
el
.
scrollIntoView
(
{
block
:
"
end
"
inline
:
"
nearest
"
}
)
;
}
}
;
element
.
isElement
=
function
(
obj
)
{
return
element
.
isDOMElement
(
obj
)
|
|
element
.
isXULElement
(
obj
)
;
}
;
element
.
getShadowRoot
=
function
(
el
)
{
const
shadowRoot
=
el
.
openOrClosedShadowRoot
;
if
(
!
shadowRoot
)
{
throw
new
lazy
.
error
.
NoSuchShadowRootError
(
)
;
}
return
shadowRoot
;
}
;
element
.
isShadowRoot
=
function
(
obj
)
{
return
(
obj
!
=
=
null
&
&
typeof
obj
=
=
"
object
"
&
&
obj
.
containingShadowRoot
=
=
obj
)
;
}
;
element
.
isDOMElement
=
function
(
obj
)
{
return
(
typeof
obj
=
=
"
object
"
&
&
obj
!
=
=
null
&
&
"
nodeType
"
in
obj
&
&
[
ELEMENT_NODE
DOCUMENT_NODE
]
.
includes
(
obj
.
nodeType
)
&
&
!
element
.
isXULElement
(
obj
)
)
;
}
;
element
.
isXULElement
=
function
(
obj
)
{
return
(
typeof
obj
=
=
"
object
"
&
&
obj
!
=
=
null
&
&
"
nodeType
"
in
obj
&
&
obj
.
nodeType
=
=
=
obj
.
ELEMENT_NODE
&
&
obj
.
namespaceURI
=
=
=
XUL_NS
)
;
}
;
element
.
isInPrivilegedDocument
=
function
(
node
)
{
return
!
!
node
?
.
nodePrincipal
?
.
isSystemPrincipal
;
}
;
element
.
isDOMWindow
=
function
(
obj
)
{
return
(
typeof
obj
=
=
"
object
"
&
&
obj
!
=
=
null
&
&
typeof
obj
.
toString
=
=
"
function
"
&
&
obj
.
toString
(
)
=
=
"
[
object
Window
]
"
&
&
obj
.
self
=
=
=
obj
)
;
}
;
const
boolEls
=
{
audio
:
[
"
autoplay
"
"
controls
"
"
loop
"
"
muted
"
]
button
:
[
"
autofocus
"
"
disabled
"
"
formnovalidate
"
]
details
:
[
"
open
"
]
dialog
:
[
"
open
"
]
fieldset
:
[
"
disabled
"
]
form
:
[
"
novalidate
"
]
iframe
:
[
"
allowfullscreen
"
]
img
:
[
"
ismap
"
]
input
:
[
"
autofocus
"
"
checked
"
"
disabled
"
"
formnovalidate
"
"
multiple
"
"
readonly
"
"
required
"
]
keygen
:
[
"
autofocus
"
"
disabled
"
]
menuitem
:
[
"
checked
"
"
default
"
"
disabled
"
]
ol
:
[
"
reversed
"
]
optgroup
:
[
"
disabled
"
]
option
:
[
"
disabled
"
"
selected
"
]
script
:
[
"
async
"
"
defer
"
]
select
:
[
"
autofocus
"
"
disabled
"
"
multiple
"
"
required
"
]
textarea
:
[
"
autofocus
"
"
disabled
"
"
readonly
"
"
required
"
]
track
:
[
"
default
"
]
video
:
[
"
autoplay
"
"
controls
"
"
loop
"
"
muted
"
]
}
;
element
.
isBooleanAttribute
=
function
(
el
attr
)
{
if
(
!
element
.
isDOMElement
(
el
)
)
{
return
false
;
}
const
customElement
=
!
el
.
localName
.
includes
(
"
-
"
)
;
if
(
(
attr
=
=
"
hidden
"
|
|
attr
=
=
"
itemscope
"
)
&
&
customElement
)
{
return
true
;
}
if
(
!
boolEls
.
hasOwnProperty
(
el
.
localName
)
)
{
return
false
;
}
return
boolEls
[
el
.
localName
]
.
includes
(
attr
)
;
}
;
class
WebReference
{
constructor
(
uuid
)
{
this
.
uuid
=
lazy
.
assert
.
string
(
uuid
)
;
}
is
(
other
)
{
return
other
instanceof
WebReference
&
&
this
.
uuid
=
=
=
other
.
uuid
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
uuid
=
{
this
.
uuid
}
]
;
}
static
from
(
node
)
{
const
uuid
=
WebReference
.
generateUUID
(
)
;
if
(
element
.
isShadowRoot
(
node
)
&
&
!
element
.
isInPrivilegedDocument
(
node
)
)
{
return
new
ShadowRoot
(
uuid
)
;
}
else
if
(
element
.
isElement
(
node
)
)
{
return
new
WebElement
(
uuid
)
;
}
else
if
(
element
.
isDOMWindow
(
node
)
)
{
if
(
node
.
parent
=
=
=
node
)
{
return
new
WebWindow
(
uuid
)
;
}
return
new
WebFrame
(
uuid
)
;
}
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
Expected
DOM
window
/
element
"
+
lazy
.
pprint
or
XUL
element
got
:
{
node
}
)
;
}
static
fromJSON
(
json
)
{
lazy
.
assert
.
object
(
json
)
;
if
(
json
instanceof
WebReference
)
{
return
json
;
}
let
keys
=
Object
.
keys
(
json
)
;
for
(
let
key
of
keys
)
{
switch
(
key
)
{
case
ShadowRoot
.
Identifier
:
return
ShadowRoot
.
fromJSON
(
json
)
;
case
WebElement
.
Identifier
:
return
WebElement
.
fromJSON
(
json
)
;
case
WebFrame
.
Identifier
:
return
WebFrame
.
fromJSON
(
json
)
;
case
WebWindow
.
Identifier
:
return
WebWindow
.
fromJSON
(
json
)
;
}
}
throw
new
lazy
.
error
.
InvalidArgumentError
(
lazy
.
pprint
Expected
web
reference
got
:
{
json
}
)
;
}
static
fromUUID
(
uuid
)
{
lazy
.
assert
.
string
(
uuid
)
;
return
new
WebElement
(
uuid
)
;
}
static
isReference
(
obj
)
{
if
(
Object
.
prototype
.
toString
.
call
(
obj
)
!
=
"
[
object
Object
]
"
)
{
return
false
;
}
if
(
ShadowRoot
.
Identifier
in
obj
|
|
WebElement
.
Identifier
in
obj
|
|
WebFrame
.
Identifier
in
obj
|
|
WebWindow
.
Identifier
in
obj
)
{
return
true
;
}
return
false
;
}
static
generateUUID
(
)
{
let
uuid
=
Services
.
uuid
.
generateUUID
(
)
.
toString
(
)
;
return
uuid
.
substring
(
1
uuid
.
length
-
1
)
;
}
}
class
WebElement
extends
WebReference
{
toJSON
(
)
{
return
{
[
WebElement
.
Identifier
]
:
this
.
uuid
}
;
}
static
fromJSON
(
json
)
{
const
{
Identifier
}
=
WebElement
;
if
(
!
(
Identifier
in
json
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
lazy
.
pprint
Expected
web
element
reference
got
:
{
json
}
)
;
}
let
uuid
=
json
[
Identifier
]
;
return
new
WebElement
(
uuid
)
;
}
}
WebElement
.
Identifier
=
"
element
-
6066
-
11e4
-
a52e
-
4f735466cecf
"
;
class
ShadowRoot
extends
WebReference
{
toJSON
(
)
{
return
{
[
ShadowRoot
.
Identifier
]
:
this
.
uuid
}
;
}
static
fromJSON
(
json
)
{
const
{
Identifier
}
=
ShadowRoot
;
if
(
!
(
Identifier
in
json
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
lazy
.
pprint
Expected
shadow
root
reference
got
:
{
json
}
)
;
}
let
uuid
=
json
[
Identifier
]
;
return
new
ShadowRoot
(
uuid
)
;
}
}
ShadowRoot
.
Identifier
=
"
shadow
-
6066
-
11e4
-
a52e
-
4f735466cecf
"
;
class
WebWindow
extends
WebReference
{
toJSON
(
)
{
return
{
[
WebWindow
.
Identifier
]
:
this
.
uuid
}
;
}
static
fromJSON
(
json
)
{
if
(
!
(
WebWindow
.
Identifier
in
json
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
lazy
.
pprint
Expected
web
window
reference
got
:
{
json
}
)
;
}
let
uuid
=
json
[
WebWindow
.
Identifier
]
;
return
new
WebWindow
(
uuid
)
;
}
}
WebWindow
.
Identifier
=
"
window
-
fcc6
-
11e5
-
b4f8
-
330a88ab9d7f
"
;
class
WebFrame
extends
WebReference
{
toJSON
(
)
{
return
{
[
WebFrame
.
Identifier
]
:
this
.
uuid
}
;
}
static
fromJSON
(
json
)
{
if
(
!
(
WebFrame
.
Identifier
in
json
)
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
lazy
.
pprint
Expected
web
frame
reference
got
:
{
json
}
)
;
}
let
uuid
=
json
[
WebFrame
.
Identifier
]
;
return
new
WebFrame
(
uuid
)
;
}
}
WebFrame
.
Identifier
=
"
frame
-
075b
-
4da1
-
b6ba
-
e579c2d3230a
"
;
