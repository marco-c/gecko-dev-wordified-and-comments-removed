"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
evaluate
"
"
sandbox
"
"
Sandboxes
"
]
;
const
{
clearTimeout
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
element
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
element
.
js
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
WebReference
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
element
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
lazy
.
Log
.
TYPES
.
MARIONETTE
)
)
;
const
ARGUMENTS
=
"
__webDriverArguments
"
;
const
CALLBACK
=
"
__webDriverCallback
"
;
const
COMPLETE
=
"
__webDriverComplete
"
;
const
DEFAULT_TIMEOUT
=
10000
;
const
FINISH
=
"
finish
"
;
const
evaluate
=
{
}
;
evaluate
.
assertAcyclic
=
function
(
obj
msg
=
"
"
err
=
lazy
.
error
.
JavaScriptError
)
{
if
(
evaluate
.
isCyclic
(
obj
)
)
{
throw
new
err
(
msg
|
|
"
Cyclic
object
value
"
)
;
}
}
;
evaluate
.
sandbox
=
function
(
sb
script
args
=
[
]
{
async
=
false
file
=
"
dummy
file
"
line
=
0
timeout
=
DEFAULT_TIMEOUT
}
=
{
}
)
{
let
unloadHandler
;
let
marionetteSandbox
=
sandbox
.
create
(
sb
.
window
)
;
let
scriptTimeoutID
timeoutPromise
;
if
(
timeout
!
=
=
null
)
{
timeoutPromise
=
new
Promise
(
(
resolve
reject
)
=
>
{
scriptTimeoutID
=
setTimeout
(
(
)
=
>
{
reject
(
new
lazy
.
error
.
ScriptTimeoutError
(
Timed
out
after
{
timeout
}
ms
)
)
;
}
timeout
)
;
}
)
;
}
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
let
src
=
"
"
;
sb
[
COMPLETE
]
=
resolve
;
sb
[
ARGUMENTS
]
=
sandbox
.
cloneInto
(
args
sb
)
;
if
(
async
)
{
sb
[
CALLBACK
]
=
sb
[
COMPLETE
]
;
src
+
=
{
ARGUMENTS
}
.
push
(
rv
=
>
{
CALLBACK
}
(
rv
)
)
;
;
}
src
+
=
(
function
(
)
{
{
script
}
}
)
.
apply
(
null
{
ARGUMENTS
}
)
;
unloadHandler
=
sandbox
.
cloneInto
(
(
)
=
>
reject
(
new
lazy
.
error
.
JavaScriptError
(
"
Document
was
unloaded
"
)
)
marionetteSandbox
)
;
marionetteSandbox
.
window
.
addEventListener
(
"
unload
"
unloadHandler
)
;
let
promises
=
[
Cu
.
evalInSandbox
(
src
sb
"
1
.
8
"
file
line
false
)
timeoutPromise
]
;
Promise
.
race
(
promises
)
.
then
(
value
=
>
{
if
(
!
async
)
{
resolve
(
value
)
;
}
}
err
=
>
{
reject
(
err
)
;
}
)
;
}
)
;
return
Promise
.
race
(
[
promise
timeoutPromise
]
)
.
catch
(
err
=
>
{
if
(
err
instanceof
lazy
.
error
.
ScriptTimeoutError
)
{
throw
err
;
}
throw
new
lazy
.
error
.
JavaScriptError
(
err
)
;
}
)
.
finally
(
(
)
=
>
{
clearTimeout
(
scriptTimeoutID
)
;
marionetteSandbox
.
window
.
removeEventListener
(
"
unload
"
unloadHandler
)
;
}
)
;
}
;
evaluate
.
fromJSON
=
function
(
options
=
{
}
)
{
const
{
obj
seenEls
win
}
=
options
;
switch
(
typeof
obj
)
{
case
"
boolean
"
:
case
"
number
"
:
case
"
string
"
:
default
:
return
obj
;
case
"
object
"
:
if
(
obj
=
=
=
null
)
{
return
obj
;
}
else
if
(
Array
.
isArray
(
obj
)
)
{
return
obj
.
map
(
e
=
>
evaluate
.
fromJSON
(
{
obj
:
e
seenEls
win
}
)
)
;
}
else
if
(
lazy
.
WebReference
.
isReference
(
obj
.
webElRef
)
)
{
if
(
seenEls
instanceof
lazy
.
element
.
ReferenceStore
)
{
return
seenEls
.
add
(
obj
)
;
}
else
if
(
!
seenEls
)
{
return
lazy
.
element
.
resolveElement
(
obj
win
)
;
}
throw
new
TypeError
(
"
seenEls
is
not
an
instance
of
ReferenceStore
"
)
;
}
let
rv
=
{
}
;
for
(
let
prop
in
obj
)
{
rv
[
prop
]
=
evaluate
.
fromJSON
(
{
obj
:
obj
[
prop
]
seenEls
win
}
)
;
}
return
rv
;
}
}
;
evaluate
.
toJSON
=
function
(
obj
seenEls
)
{
const
t
=
Object
.
prototype
.
toString
.
call
(
obj
)
;
if
(
t
=
=
"
[
object
Undefined
]
"
|
|
t
=
=
"
[
object
Null
]
"
)
{
return
null
;
}
else
if
(
t
=
=
"
[
object
Boolean
]
"
|
|
t
=
=
"
[
object
Number
]
"
|
|
t
=
=
"
[
object
String
]
"
)
{
return
obj
;
}
else
if
(
lazy
.
element
.
isCollection
(
obj
)
)
{
evaluate
.
assertAcyclic
(
obj
)
;
return
[
.
.
.
obj
]
.
map
(
el
=
>
evaluate
.
toJSON
(
el
seenEls
)
)
;
}
else
if
(
lazy
.
WebReference
.
isReference
(
obj
)
)
{
return
seenEls
.
get
(
lazy
.
WebReference
.
fromJSON
(
obj
)
)
;
}
else
if
(
lazy
.
WebReference
.
isReference
(
obj
.
webElRef
)
)
{
return
obj
;
}
else
if
(
lazy
.
element
.
isElement
(
obj
)
|
|
lazy
.
element
.
isShadowRoot
(
obj
)
)
{
if
(
seenEls
instanceof
lazy
.
element
.
ReferenceStore
)
{
throw
new
TypeError
(
ReferenceStore
can
'
t
be
used
with
Element
)
;
}
return
lazy
.
element
.
getElementId
(
Cu
.
unwaiveXrays
(
obj
)
)
;
}
else
if
(
typeof
obj
.
toJSON
=
=
"
function
"
)
{
let
unsafeJSON
=
obj
.
toJSON
(
)
;
return
evaluate
.
toJSON
(
unsafeJSON
seenEls
)
;
}
let
rv
=
{
}
;
for
(
let
prop
in
obj
)
{
evaluate
.
assertAcyclic
(
obj
[
prop
]
)
;
try
{
rv
[
prop
]
=
evaluate
.
toJSON
(
obj
[
prop
]
seenEls
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
{
lazy
.
logger
.
debug
(
Skipping
{
prop
}
:
{
e
.
message
}
)
;
}
else
{
throw
e
;
}
}
}
return
rv
;
}
;
evaluate
.
isCyclic
=
function
(
value
stack
=
[
]
)
{
let
t
=
Object
.
prototype
.
toString
.
call
(
value
)
;
if
(
t
=
=
"
[
object
Undefined
]
"
|
|
t
=
=
"
[
object
Null
]
"
)
{
return
false
;
}
else
if
(
t
=
=
"
[
object
Boolean
]
"
|
|
t
=
=
"
[
object
Number
]
"
|
|
t
=
=
"
[
object
String
]
"
)
{
return
false
;
}
else
if
(
lazy
.
element
.
isElement
(
value
)
)
{
return
false
;
}
else
if
(
lazy
.
element
.
isCollection
(
value
)
)
{
if
(
stack
.
includes
(
value
)
)
{
return
true
;
}
stack
.
push
(
value
)
;
for
(
let
i
=
0
;
i
<
value
.
length
;
i
+
+
)
{
if
(
evaluate
.
isCyclic
(
value
[
i
]
stack
)
)
{
return
true
;
}
}
stack
.
pop
(
)
;
return
false
;
}
if
(
stack
.
includes
(
value
)
)
{
return
true
;
}
stack
.
push
(
value
)
;
for
(
let
prop
in
value
)
{
if
(
evaluate
.
isCyclic
(
value
[
prop
]
stack
)
)
{
return
true
;
}
}
stack
.
pop
(
)
;
return
false
;
}
;
evaluate
.
isDead
=
function
(
obj
prop
)
{
try
{
obj
[
prop
]
;
}
catch
(
e
)
{
if
(
e
.
message
.
includes
(
"
dead
object
"
)
)
{
return
true
;
}
throw
e
;
}
return
false
;
}
;
const
sandbox
=
{
}
;
sandbox
.
cloneInto
=
function
(
obj
sb
)
{
return
Cu
.
cloneInto
(
obj
sb
{
cloneFunctions
:
true
wrapReflectors
:
true
}
)
;
}
;
sandbox
.
augment
=
function
(
sb
adapter
)
{
function
*
entries
(
obj
)
{
for
(
let
key
of
Object
.
keys
(
obj
)
)
{
yield
[
key
obj
[
key
]
]
;
}
}
let
funcs
=
adapter
.
exports
|
|
entries
(
adapter
)
;
for
(
let
[
name
func
]
of
funcs
)
{
sb
[
name
]
=
func
;
}
return
sb
;
}
;
sandbox
.
create
=
function
(
win
principal
=
null
opts
=
{
}
)
{
let
p
=
principal
|
|
win
;
opts
=
Object
.
assign
(
{
sameZoneAs
:
win
sandboxPrototype
:
win
wantComponents
:
true
wantXrays
:
true
wantGlobalProperties
:
[
"
ChromeUtils
"
]
}
opts
)
;
return
new
Cu
.
Sandbox
(
p
opts
)
;
}
;
sandbox
.
createMutable
=
function
(
win
)
{
let
opts
=
{
wantComponents
:
false
wantXrays
:
false
}
;
return
Cu
.
waiveXrays
(
sandbox
.
create
(
win
null
opts
)
)
;
}
;
sandbox
.
createSystemPrincipal
=
function
(
win
)
{
let
principal
=
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
;
return
sandbox
.
create
(
win
principal
)
;
}
;
sandbox
.
createSimpleTest
=
function
(
win
harness
)
{
let
sb
=
sandbox
.
create
(
win
)
;
sb
=
sandbox
.
augment
(
sb
harness
)
;
sb
[
FINISH
]
=
(
)
=
>
sb
[
COMPLETE
]
(
harness
.
generate_results
(
)
)
;
return
sb
;
}
;
class
Sandboxes
{
constructor
(
windowFn
)
{
this
.
windowFn_
=
windowFn
;
this
.
boxes_
=
new
Map
(
)
;
}
get
window_
(
)
{
return
this
.
windowFn_
(
)
;
}
get
(
name
=
"
default
"
fresh
=
false
)
{
let
sb
=
this
.
boxes_
.
get
(
name
)
;
if
(
sb
)
{
if
(
fresh
|
|
evaluate
.
isDead
(
sb
"
window
"
)
|
|
sb
.
window
!
=
this
.
window_
)
{
this
.
boxes_
.
delete
(
name
)
;
return
this
.
get
(
name
false
)
;
}
}
else
{
if
(
name
=
=
"
system
"
)
{
sb
=
sandbox
.
createSystemPrincipal
(
this
.
window_
)
;
}
else
{
sb
=
sandbox
.
create
(
this
.
window_
)
;
}
this
.
boxes_
.
set
(
name
sb
)
;
}
return
sb
;
}
clear
(
)
{
this
.
boxes_
.
clear
(
)
;
}
}
