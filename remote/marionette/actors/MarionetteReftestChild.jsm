"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
MarionetteReftestChild
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
MARIONETTE
)
)
;
class
MarionetteReftestChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_loadedURLPromise
=
new
Promise
(
r
=
>
(
this
.
_resolveLoadedURLPromise
=
r
)
)
;
}
handleEvent
(
event
)
{
if
(
event
.
type
=
=
"
load
"
)
{
const
url
=
event
.
target
.
location
.
href
;
logger
.
debug
(
Handle
load
event
with
URL
{
url
}
)
;
this
.
_resolveLoadedURLPromise
(
url
)
;
}
}
actorCreated
(
)
{
logger
.
trace
(
[
{
this
.
browsingContext
.
id
}
]
Reftest
actor
created
+
for
window
id
{
this
.
manager
.
innerWindowId
}
)
;
}
async
receiveMessage
(
msg
)
{
const
{
name
data
}
=
msg
;
let
result
;
switch
(
name
)
{
case
"
MarionetteReftestParent
:
flushRendering
"
:
result
=
await
this
.
flushRendering
(
data
)
;
break
;
case
"
MarionetteReftestParent
:
reftestWait
"
:
result
=
await
this
.
reftestWait
(
data
)
;
break
;
}
return
result
;
}
async
reftestWait
(
options
=
{
}
)
{
const
{
url
useRemote
}
=
options
;
const
loadedURL
=
await
this
.
_loadedURLPromise
;
if
(
loadedURL
!
=
=
url
)
{
logger
.
debug
(
Window
URL
does
not
match
the
expected
URL
"
{
loadedURL
}
"
!
=
=
"
{
url
}
"
)
;
return
false
;
}
const
documentElement
=
this
.
document
.
documentElement
;
const
hasReftestWait
=
documentElement
.
classList
.
contains
(
"
reftest
-
wait
"
)
;
logger
.
debug
(
"
Waiting
for
event
loop
to
spin
"
)
;
await
new
Promise
(
resolve
=
>
this
.
document
.
defaultView
.
setTimeout
(
resolve
0
)
)
;
await
this
.
paintComplete
(
{
useRemote
ignoreThrottledAnimations
:
true
}
)
;
if
(
hasReftestWait
)
{
const
event
=
new
this
.
document
.
defaultView
.
Event
(
"
TestRendered
"
{
bubbles
:
true
}
)
;
documentElement
.
dispatchEvent
(
event
)
;
logger
.
info
(
"
Emitted
TestRendered
event
"
)
;
await
this
.
reftestWaitRemoved
(
)
;
await
this
.
paintComplete
(
{
useRemote
ignoreThrottledAnimations
:
false
}
)
;
}
if
(
this
.
document
.
defaultView
.
innerWidth
<
documentElement
.
scrollWidth
|
|
this
.
document
.
defaultView
.
innerHeight
<
documentElement
.
scrollHeight
)
{
logger
.
warn
(
{
url
}
overflows
viewport
(
width
:
{
documentElement
.
scrollWidth
}
height
:
{
documentElement
.
scrollHeight
}
)
)
;
}
return
true
;
}
paintComplete
(
{
useRemote
ignoreThrottledAnimations
}
)
{
logger
.
debug
(
"
Waiting
for
rendering
"
)
;
let
windowUtils
=
this
.
document
.
defaultView
.
windowUtils
;
return
new
Promise
(
resolve
=
>
{
let
maybeResolve
=
(
)
=
>
{
this
.
flushRendering
(
{
ignoreThrottledAnimations
}
)
;
if
(
useRemote
)
{
logger
.
debug
(
"
Force
update
of
layer
tree
"
)
;
windowUtils
.
updateLayerTree
(
)
;
}
if
(
windowUtils
.
isMozAfterPaintPending
)
{
logger
.
debug
(
"
isMozAfterPaintPending
:
true
"
)
;
this
.
document
.
defaultView
.
addEventListener
(
"
MozAfterPaint
"
maybeResolve
{
once
:
true
}
)
;
}
else
{
logger
.
debug
(
"
isMozAfterPaintPending
:
false
"
)
;
this
.
document
.
defaultView
.
requestAnimationFrame
(
(
)
=
>
{
this
.
document
.
defaultView
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
}
;
maybeResolve
(
)
;
}
)
;
}
reftestWaitRemoved
(
)
{
logger
.
debug
(
"
Waiting
for
reftest
-
wait
removal
"
)
;
return
new
Promise
(
resolve
=
>
{
const
documentElement
=
this
.
document
.
documentElement
;
let
observer
=
new
this
.
document
.
defaultView
.
MutationObserver
(
(
)
=
>
{
if
(
!
documentElement
.
classList
.
contains
(
"
reftest
-
wait
"
)
)
{
observer
.
disconnect
(
)
;
logger
.
debug
(
"
reftest
-
wait
removed
"
)
;
this
.
document
.
defaultView
.
setTimeout
(
resolve
0
)
;
}
}
)
;
if
(
documentElement
.
classList
.
contains
(
"
reftest
-
wait
"
)
)
{
observer
.
observe
(
documentElement
{
attributes
:
true
}
)
;
}
else
{
this
.
document
.
defaultView
.
setTimeout
(
resolve
0
)
;
}
}
)
;
}
flushRendering
(
options
=
{
}
)
{
let
{
ignoreThrottledAnimations
}
=
options
;
logger
.
debug
(
flushRendering
ignoreThrottledAnimations
:
{
ignoreThrottledAnimations
}
)
;
let
anyPendingPaintsGeneratedInDescendants
=
false
;
let
windowUtils
=
this
.
document
.
defaultView
.
windowUtils
;
function
flushWindow
(
win
)
{
let
utils
=
win
.
windowUtils
;
let
afterPaintWasPending
=
utils
.
isMozAfterPaintPending
;
let
root
=
win
.
document
.
documentElement
;
if
(
root
)
{
try
{
if
(
ignoreThrottledAnimations
)
{
utils
.
flushLayoutWithoutThrottledAnimations
(
)
;
}
else
{
root
.
getBoundingClientRect
(
)
;
}
}
catch
(
e
)
{
logger
.
error
(
"
flushWindow
failed
"
e
)
;
}
}
if
(
!
afterPaintWasPending
&
&
utils
.
isMozAfterPaintPending
)
{
anyPendingPaintsGeneratedInDescendants
=
true
;
}
for
(
let
i
=
0
;
i
<
win
.
frames
.
length
;
+
+
i
)
{
if
(
!
Cu
.
isRemoteProxy
(
win
.
frames
[
i
]
)
)
{
flushWindow
(
win
.
frames
[
i
]
)
;
}
}
}
flushWindow
(
this
.
document
.
defaultView
)
;
if
(
anyPendingPaintsGeneratedInDescendants
&
&
!
windowUtils
.
isMozAfterPaintPending
)
{
logger
.
error
(
"
Descendant
frame
generated
a
MozAfterPaint
event
"
+
"
but
the
root
document
doesn
'
t
have
one
!
"
)
;
}
}
}
