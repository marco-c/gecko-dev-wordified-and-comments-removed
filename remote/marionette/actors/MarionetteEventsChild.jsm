"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
MarionetteEventsChild
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
event
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
event
.
js
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
MARIONETTE
)
)
;
class
MarionetteEventsChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
_unregistering
=
false
;
}
get
innerWindowId
(
)
{
return
this
.
manager
.
innerWindowId
;
}
actorCreated
(
)
{
if
(
Log
.
isTraceLevel
)
{
logger
.
trace
(
[
{
this
.
browsingContext
.
id
}
]
MarionetteEvents
actor
created
+
for
window
id
{
this
.
innerWindowId
}
)
;
}
}
handleEvent
(
{
target
type
}
)
{
if
(
this
.
_unregistering
)
{
return
;
}
if
(
(
type
=
=
=
"
DOMContentLoaded
"
&
&
target
.
readyState
!
=
"
interactive
"
)
|
|
(
type
=
=
=
"
pageshow
"
&
&
target
.
readyState
!
=
"
complete
"
)
)
{
logger
.
warn
(
Ignoring
event
'
{
type
}
'
because
document
has
an
invalid
+
readyState
of
'
{
target
.
readyState
}
'
.
)
;
return
;
}
switch
(
type
)
{
case
"
beforeunload
"
:
case
"
DOMContentLoaded
"
:
case
"
hashchange
"
:
case
"
pagehide
"
:
case
"
pageshow
"
:
case
"
popstate
"
:
this
.
sendAsyncMessage
(
"
MarionetteEventsChild
:
PageLoadEvent
"
{
browsingContext
:
this
.
browsingContext
documentURI
:
target
.
documentURI
readyState
:
target
.
readyState
type
windowId
:
this
.
innerWindowId
}
)
;
break
;
case
"
click
"
:
event
.
DoubleClickTracker
.
setClick
(
)
;
break
;
case
"
dblclick
"
:
case
"
unload
"
:
event
.
DoubleClickTracker
.
resetClick
(
)
;
break
;
}
}
async
receiveMessage
(
msg
)
{
const
{
name
}
=
msg
;
switch
(
name
)
{
case
"
MarionetteEventsParent
:
beforeUnregisterActor
"
:
this
.
_unregistering
=
true
;
break
;
}
}
}
