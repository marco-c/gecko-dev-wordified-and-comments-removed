"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
MarionetteCommandsChild
"
"
clearActionInputState
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
action
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
action
.
js
"
atom
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
atom
.
js
"
element
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
element
.
js
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
evaluate
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
evaluate
.
js
"
event
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
event
.
js
"
interaction
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
interaction
.
js
"
legacyaction
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
legacyaction
.
js
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
sandbox
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
evaluate
.
js
"
Sandboxes
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
evaluate
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
MARIONETTE
)
)
;
let
inputStateIsDirty
=
false
;
class
MarionetteCommandsChild
extends
JSWindowActorChild
{
constructor
(
)
{
super
(
)
;
this
.
sandboxes
=
new
Sandboxes
(
(
)
=
>
this
.
document
.
defaultView
)
;
}
get
innerWindowId
(
)
{
return
this
.
manager
.
innerWindowId
;
}
get
legacyactions
(
)
{
if
(
!
this
.
_legacyactions
)
{
this
.
_legacyactions
=
new
legacyaction
.
Chain
(
)
;
}
return
this
.
_legacyactions
;
}
actorCreated
(
)
{
logger
.
trace
(
[
{
this
.
browsingContext
.
id
}
]
MarionetteCommands
actor
created
+
for
window
id
{
this
.
innerWindowId
}
)
;
clearActionInputState
(
)
;
}
async
receiveMessage
(
msg
)
{
if
(
!
this
.
contentWindow
)
{
throw
new
DOMException
(
"
Actor
is
no
longer
active
"
"
InactiveActor
"
)
;
}
try
{
let
result
;
let
waitForNextTick
=
false
;
const
{
name
data
:
serializedData
}
=
msg
;
const
data
=
evaluate
.
fromJSON
(
{
obj
:
serializedData
seenEls
:
null
win
:
this
.
document
.
defaultView
}
)
;
switch
(
name
)
{
case
"
MarionetteCommandsParent
:
clearElement
"
:
this
.
clearElement
(
data
)
;
waitForNextTick
=
true
;
break
;
case
"
MarionetteCommandsParent
:
clickElement
"
:
result
=
await
this
.
clickElement
(
data
)
;
waitForNextTick
=
true
;
break
;
case
"
MarionetteCommandsParent
:
executeScript
"
:
result
=
await
this
.
executeScript
(
data
)
;
waitForNextTick
=
true
;
break
;
case
"
MarionetteCommandsParent
:
findElement
"
:
result
=
await
this
.
findElement
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
findElements
"
:
result
=
await
this
.
findElements
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
getActiveElement
"
:
result
=
await
this
.
getActiveElement
(
)
;
break
;
case
"
MarionetteCommandsParent
:
getElementAttribute
"
:
result
=
await
this
.
getElementAttribute
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
getElementProperty
"
:
result
=
await
this
.
getElementProperty
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
getElementRect
"
:
result
=
await
this
.
getElementRect
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
getElementTagName
"
:
result
=
await
this
.
getElementTagName
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
getElementText
"
:
result
=
await
this
.
getElementText
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
getElementValueOfCssProperty
"
:
result
=
await
this
.
getElementValueOfCssProperty
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
getPageSource
"
:
result
=
await
this
.
getPageSource
(
)
;
break
;
case
"
MarionetteCommandsParent
:
getScreenshotRect
"
:
result
=
await
this
.
getScreenshotRect
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
isElementDisplayed
"
:
result
=
await
this
.
isElementDisplayed
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
isElementEnabled
"
:
result
=
await
this
.
isElementEnabled
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
isElementSelected
"
:
result
=
await
this
.
isElementSelected
(
data
)
;
break
;
case
"
MarionetteCommandsParent
:
performActions
"
:
result
=
await
this
.
performActions
(
data
)
;
waitForNextTick
=
true
;
break
;
case
"
MarionetteCommandsParent
:
releaseActions
"
:
result
=
await
this
.
releaseActions
(
)
;
break
;
case
"
MarionetteCommandsParent
:
sendKeysToElement
"
:
result
=
await
this
.
sendKeysToElement
(
data
)
;
waitForNextTick
=
true
;
break
;
case
"
MarionetteCommandsParent
:
singleTap
"
:
result
=
await
this
.
singleTap
(
data
)
;
waitForNextTick
=
true
;
break
;
case
"
MarionetteCommandsParent
:
switchToFrame
"
:
result
=
await
this
.
switchToFrame
(
data
)
;
waitForNextTick
=
true
;
break
;
case
"
MarionetteCommandsParent
:
switchToParentFrame
"
:
result
=
await
this
.
switchToParentFrame
(
)
;
waitForNextTick
=
true
;
break
;
}
if
(
waitForNextTick
)
{
await
new
Promise
(
resolve
=
>
Services
.
tm
.
dispatchToMainThread
(
resolve
)
)
;
}
return
{
data
:
evaluate
.
toJSON
(
result
)
}
;
}
catch
(
e
)
{
return
{
error
:
error
.
wrap
(
e
)
.
toJSON
(
)
}
;
}
}
clearElement
(
options
=
{
}
)
{
const
{
elem
}
=
options
;
interaction
.
clearElement
(
elem
)
;
}
async
clickElement
(
options
=
{
}
)
{
const
{
capabilities
elem
}
=
options
;
return
interaction
.
clickElement
(
elem
capabilities
[
"
moz
:
accessibilityChecks
"
]
capabilities
[
"
moz
:
webdriverClick
"
]
)
;
}
async
executeScript
(
options
=
{
}
)
{
const
{
args
opts
=
{
}
script
}
=
options
;
let
sb
;
if
(
opts
.
sandboxName
)
{
sb
=
this
.
sandboxes
.
get
(
opts
.
sandboxName
opts
.
newSandbox
)
;
}
else
{
sb
=
sandbox
.
createMutable
(
this
.
document
.
defaultView
)
;
}
return
evaluate
.
sandbox
(
sb
script
args
opts
)
;
}
async
findElement
(
options
=
{
}
)
{
const
{
strategy
selector
opts
}
=
options
;
opts
.
all
=
false
;
const
container
=
{
frame
:
this
.
document
.
defaultView
}
;
return
element
.
find
(
container
strategy
selector
opts
)
;
}
async
findElements
(
options
=
{
}
)
{
const
{
strategy
selector
opts
}
=
options
;
opts
.
all
=
true
;
const
container
=
{
frame
:
this
.
document
.
defaultView
}
;
return
element
.
find
(
container
strategy
selector
opts
)
;
}
async
getActiveElement
(
)
{
let
elem
=
this
.
document
.
activeElement
;
if
(
!
elem
)
{
throw
new
error
.
NoSuchElementError
(
)
;
}
return
elem
;
}
async
getElementAttribute
(
options
=
{
}
)
{
const
{
name
elem
}
=
options
;
if
(
element
.
isBooleanAttribute
(
elem
name
)
)
{
if
(
elem
.
hasAttribute
(
name
)
)
{
return
"
true
"
;
}
return
null
;
}
return
elem
.
getAttribute
(
name
)
;
}
async
getElementProperty
(
options
=
{
}
)
{
const
{
name
elem
}
=
options
;
return
typeof
elem
[
name
]
!
=
"
undefined
"
?
elem
[
name
]
:
null
;
}
async
getElementRect
(
options
=
{
}
)
{
const
{
elem
}
=
options
;
const
rect
=
elem
.
getBoundingClientRect
(
)
;
return
{
x
:
rect
.
x
+
this
.
document
.
defaultView
.
pageXOffset
y
:
rect
.
y
+
this
.
document
.
defaultView
.
pageYOffset
width
:
rect
.
width
height
:
rect
.
height
}
;
}
async
getElementTagName
(
options
=
{
}
)
{
const
{
elem
}
=
options
;
return
elem
.
tagName
.
toLowerCase
(
)
;
}
async
getElementText
(
options
=
{
}
)
{
const
{
elem
}
=
options
;
return
atom
.
getElementText
(
elem
this
.
document
.
defaultView
)
;
}
async
getElementValueOfCssProperty
(
options
=
{
}
)
{
const
{
name
elem
}
=
options
;
const
style
=
this
.
document
.
defaultView
.
getComputedStyle
(
elem
)
;
return
style
.
getPropertyValue
(
name
)
;
}
async
getPageSource
(
)
{
return
this
.
document
.
documentElement
.
outerHTML
;
}
async
getScreenshotRect
(
options
=
{
}
)
{
const
{
elem
full
=
true
scroll
=
true
}
=
options
;
const
win
=
elem
?
this
.
document
.
defaultView
:
this
.
browsingContext
.
top
.
window
;
let
rect
;
if
(
elem
)
{
if
(
scroll
)
{
element
.
scrollIntoView
(
elem
)
;
}
rect
=
this
.
getElementRect
(
{
elem
}
)
;
}
else
if
(
full
)
{
const
docEl
=
win
.
document
.
documentElement
;
rect
=
new
DOMRect
(
0
0
docEl
.
scrollWidth
docEl
.
scrollHeight
)
;
}
else
{
rect
=
new
DOMRect
(
win
.
pageXOffset
win
.
pageYOffset
win
.
innerWidth
win
.
innerHeight
)
;
}
return
rect
;
}
async
isElementDisplayed
(
options
=
{
}
)
{
const
{
capabilities
elem
}
=
options
;
return
interaction
.
isElementDisplayed
(
elem
capabilities
[
"
moz
:
accessibilityChecks
"
]
)
;
}
async
isElementEnabled
(
options
=
{
}
)
{
const
{
capabilities
elem
}
=
options
;
return
interaction
.
isElementEnabled
(
elem
capabilities
[
"
moz
:
accessibilityChecks
"
]
)
;
}
async
isElementSelected
(
options
=
{
}
)
{
const
{
capabilities
elem
}
=
options
;
return
interaction
.
isElementSelected
(
elem
capabilities
[
"
moz
:
accessibilityChecks
"
]
)
;
}
async
performActions
(
options
=
{
}
)
{
const
{
actions
capabilities
}
=
options
;
await
action
.
dispatch
(
action
.
Chain
.
fromJSON
(
actions
)
this
.
document
.
defaultView
!
capabilities
[
"
moz
:
useNonSpecCompliantPointerOrigin
"
]
)
;
inputStateIsDirty
=
action
.
inputsToCancel
.
length
|
|
action
.
inputStateMap
.
size
;
}
async
releaseActions
(
)
{
await
action
.
dispatchTickActions
(
action
.
inputsToCancel
.
reverse
(
)
0
this
.
document
.
defaultView
)
;
clearActionInputState
(
)
;
event
.
DoubleClickTracker
.
resetClick
(
)
;
}
async
sendKeysToElement
(
options
=
{
}
)
{
const
{
capabilities
elem
text
}
=
options
;
const
opts
=
{
strictFileInteractability
:
capabilities
.
strictFileInteractability
accessibilityChecks
:
capabilities
[
"
moz
:
accessibilityChecks
"
]
webdriverClick
:
capabilities
[
"
moz
:
webdriverClick
"
]
}
;
return
interaction
.
sendKeysToElement
(
elem
text
opts
)
;
}
async
singleTap
(
options
=
{
}
)
{
const
{
capabilities
elem
x
y
}
=
options
;
return
this
.
legacyactions
.
singleTap
(
elem
x
y
capabilities
)
;
}
async
switchToFrame
(
options
=
{
}
)
{
const
{
id
}
=
options
;
const
childContexts
=
this
.
browsingContext
.
children
;
let
browsingContext
;
if
(
id
=
=
null
)
{
browsingContext
=
this
.
browsingContext
.
top
;
}
else
if
(
typeof
id
=
=
"
number
"
)
{
if
(
id
<
0
|
|
id
>
=
childContexts
.
length
)
{
throw
new
error
.
NoSuchFrameError
(
Unable
to
locate
frame
with
index
:
{
id
}
)
;
}
browsingContext
=
childContexts
[
id
]
;
}
else
{
const
context
=
childContexts
.
find
(
context
=
>
{
return
context
.
embedderElement
=
=
=
id
;
}
)
;
if
(
!
context
)
{
throw
new
error
.
NoSuchFrameError
(
Unable
to
locate
frame
for
element
:
{
id
}
)
;
}
browsingContext
=
context
;
}
browsingContext
.
window
;
return
{
browsingContextId
:
browsingContext
.
id
}
;
}
async
switchToParentFrame
(
)
{
const
browsingContext
=
this
.
browsingContext
.
parent
|
|
this
.
browsingContext
;
return
{
browsingContextId
:
browsingContext
.
id
}
;
}
}
function
clearActionInputState
(
)
{
if
(
inputStateIsDirty
)
{
action
.
inputStateMap
.
clear
(
)
;
action
.
inputsToCancel
.
length
=
0
;
inputStateIsDirty
=
false
;
}
}
