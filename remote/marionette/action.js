"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
action
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AppInfo
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
appinfo
.
js
"
assert
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Assert
.
jsm
"
element
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
element
.
js
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
event
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
event
.
js
"
keyData
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
KeyData
.
jsm
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
pprint
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
Sleep
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
sync
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
lazy
.
Log
.
TYPES
.
MARIONETTE
)
)
;
this
.
action
=
{
}
;
const
MODIFIER_NAME_LOOKUP
=
{
Alt
:
"
alt
"
Shift
:
"
shift
"
Control
:
"
ctrl
"
Meta
:
"
meta
"
}
;
action
.
State
=
class
{
constructor
(
options
=
{
}
)
{
const
{
specCompatPointerOrigin
=
true
}
=
options
;
this
.
specCompatPointerOrigin
=
specCompatPointerOrigin
;
this
.
inputStateMap
=
new
Map
(
)
;
this
.
inputsToCancel
=
new
TickActions
(
)
;
this
.
pointerIdMap
=
new
Map
(
)
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
{
JSON
.
stringify
(
this
)
}
]
;
}
getInputSource
(
id
)
{
return
this
.
inputStateMap
.
get
(
id
)
;
}
getOrAddInputSource
(
id
newInputSource
)
{
let
inputSource
=
this
.
getInputSource
(
id
)
;
if
(
inputSource
=
=
=
undefined
)
{
this
.
inputStateMap
.
set
(
id
newInputSource
)
;
inputSource
=
newInputSource
;
}
return
inputSource
;
}
*
inputSourcesByType
(
type
)
{
for
(
const
[
id
inputSource
]
of
this
.
inputStateMap
)
{
if
(
inputSource
.
type
=
=
=
type
)
{
yield
[
id
inputSource
]
;
}
}
}
getPointerId
(
id
type
)
{
let
pointerId
=
this
.
pointerIdMap
.
get
(
id
)
;
if
(
pointerId
=
=
=
undefined
)
{
const
idValues
=
Array
.
from
(
this
.
pointerIdMap
.
values
(
)
)
;
if
(
type
=
=
=
"
mouse
"
)
{
for
(
const
mouseId
of
[
0
1
]
)
{
if
(
!
idValues
.
includes
(
mouseId
)
)
{
pointerId
=
mouseId
;
break
;
}
}
}
if
(
pointerId
=
=
=
undefined
)
{
pointerId
=
Math
.
max
(
1
.
.
.
idValues
)
+
1
;
}
this
.
pointerIdMap
.
set
(
id
pointerId
)
;
}
return
pointerId
;
}
}
;
class
InputSource
{
#
id
;
static
type
=
null
;
constructor
(
id
)
{
this
.
#
id
=
id
;
this
.
type
=
this
.
constructor
.
type
;
}
toString
(
)
{
return
[
object
{
this
.
constructor
.
name
}
id
:
{
this
.
#
id
}
type
:
{
this
.
type
}
]
;
}
static
fromJSON
(
state
actionSequence
)
{
const
{
id
type
}
=
actionSequence
;
lazy
.
assert
.
string
(
id
lazy
.
pprint
Expected
'
id
'
to
be
a
string
got
{
id
}
)
;
const
cls
=
inputSourceTypes
.
get
(
type
)
;
if
(
cls
=
=
=
undefined
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
lazy
.
pprint
Unknown
action
type
:
{
type
}
)
;
}
const
sequenceInputSource
=
cls
.
fromJSON
(
state
actionSequence
)
;
const
inputSource
=
state
.
getOrAddInputSource
(
id
sequenceInputSource
)
;
if
(
inputSource
.
type
!
=
=
type
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
input
source
{
id
}
to
be
type
{
inputSource
.
type
}
+
got
{
type
}
)
;
}
}
}
class
NullInputSource
extends
InputSource
{
static
type
=
"
none
"
;
static
fromJSON
(
state
actionSequence
)
{
const
{
id
}
=
actionSequence
;
return
new
this
(
id
)
;
}
}
class
KeyInputSource
extends
InputSource
{
static
type
=
"
key
"
;
constructor
(
id
)
{
super
(
id
)
;
this
.
pressed
=
new
Set
(
)
;
this
.
alt
=
false
;
this
.
shift
=
false
;
this
.
ctrl
=
false
;
this
.
meta
=
false
;
}
static
fromJSON
(
state
actionSequence
)
{
const
{
id
}
=
actionSequence
;
return
new
this
(
id
)
;
}
setModState
(
key
value
)
{
if
(
key
in
MODIFIER_NAME_LOOKUP
)
{
this
[
MODIFIER_NAME_LOOKUP
[
key
]
]
=
value
;
}
else
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
Expected
'
key
'
to
be
one
of
"
+
Object
.
keys
(
MODIFIER_NAME_LOOKUP
)
+
lazy
.
pprint
got
{
key
}
)
;
}
}
isPressed
(
key
)
{
return
this
.
pressed
.
has
(
key
)
;
}
press
(
key
)
{
return
this
.
pressed
.
add
(
key
)
;
}
release
(
key
)
{
return
this
.
pressed
.
delete
(
key
)
;
}
}
class
PointerInputSource
extends
InputSource
{
static
type
=
"
pointer
"
;
constructor
(
id
pointer
)
{
super
(
id
)
;
this
.
pointer
=
pointer
;
this
.
x
=
0
;
this
.
y
=
0
;
this
.
pressed
=
new
Set
(
)
;
}
isPressed
(
button
)
{
lazy
.
assert
.
positiveInteger
(
button
)
;
return
this
.
pressed
.
has
(
button
)
;
}
press
(
button
)
{
lazy
.
assert
.
positiveInteger
(
button
)
;
this
.
pressed
.
add
(
button
)
;
}
release
(
button
)
{
lazy
.
assert
.
positiveInteger
(
button
)
;
return
this
.
pressed
.
delete
(
button
)
;
}
static
fromJSON
(
state
actionSequence
)
{
const
{
id
parameters
}
=
actionSequence
;
const
pointerType
=
parameters
?
.
pointerType
?
?
"
mouse
"
;
const
pointerId
=
state
.
getPointerId
(
id
pointerType
)
;
const
pointer
=
Pointer
.
fromJSON
(
pointerId
pointerType
)
;
return
new
this
(
id
pointer
)
;
}
}
const
inputSourceTypes
=
new
Map
(
)
;
for
(
let
cls
of
[
NullInputSource
KeyInputSource
PointerInputSource
]
)
{
inputSourceTypes
.
set
(
cls
.
type
cls
)
;
}
class
Origin
{
getOriginCoordinates
(
state
inputSource
win
)
{
throw
new
Error
(
originCoordinates
not
defined
for
{
this
.
constructor
.
name
}
)
;
}
getTargetCoordinates
(
state
inputSource
coords
win
)
{
const
[
x
y
]
=
coords
;
const
origin
=
this
.
getOriginCoordinates
(
state
inputSource
win
)
;
return
[
origin
.
x
+
x
origin
.
y
+
y
]
;
}
static
fromJSON
(
origin
)
{
if
(
origin
=
=
=
undefined
|
|
origin
=
=
=
"
viewport
"
)
{
return
new
ViewportOrigin
(
)
;
}
if
(
origin
=
=
=
"
pointer
"
)
{
return
new
PointerOrigin
(
)
;
}
if
(
lazy
.
element
.
isElement
(
origin
)
)
{
return
new
ElementOrigin
(
origin
)
;
}
throw
new
lazy
.
error
.
InvalidArgumentError
(
Expected
'
origin
'
to
be
undefined
"
viewport
"
"
pointer
"
+
lazy
.
pprint
or
an
element
got
:
{
origin
}
)
;
}
}
class
ViewportOrigin
extends
Origin
{
getOriginCoordinates
(
state
inputSource
win
)
{
return
{
x
:
0
y
:
0
}
;
}
}
class
PointerOrigin
extends
Origin
{
getOriginCoordinates
(
state
inputSource
win
)
{
return
{
x
:
inputSource
.
x
y
:
inputSource
.
y
}
;
}
}
class
ElementOrigin
extends
Origin
{
constructor
(
element
)
{
super
(
)
;
this
.
element
=
element
;
}
getOriginCoordinates
(
state
inputSource
win
)
{
if
(
state
.
specCompatPointerOrigin
)
{
const
clientRects
=
this
.
element
.
getClientRects
(
)
;
if
(
!
clientRects
.
length
)
{
throw
new
lazy
.
error
.
MoveTargetOutOfBoundsError
(
Origin
element
is
not
displayed
)
;
}
return
lazy
.
element
.
getInViewCentrePoint
(
clientRects
[
0
]
win
)
;
}
return
lazy
.
element
.
coordinates
(
this
.
element
)
;
}
}
class
Action
{
static
type
=
null
;
static
subtype
=
null
;
affectsWallClockTime
=
false
;
constructor
(
id
)
{
this
.
id
=
id
;
this
.
type
=
this
.
constructor
.
type
;
this
.
subtype
=
this
.
constructor
.
subtype
;
}
toString
(
)
{
return
[
{
this
.
constructor
.
name
}
{
this
.
type
}
:
{
this
.
subtype
}
]
;
}
dispatch
(
state
inputSource
tickDuration
win
)
{
throw
new
Error
(
Action
subclass
{
this
.
constructor
.
name
}
must
override
dispatch
(
)
)
;
}
static
fromJSON
(
type
id
actionItem
)
{
const
subtype
=
actionItem
.
type
;
const
subtypeMap
=
actionTypes
.
get
(
type
)
;
if
(
subtypeMap
=
=
=
undefined
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Unknown
action
type
:
{
type
}
)
;
}
let
cls
=
subtypeMap
.
get
(
subtype
)
;
if
(
cls
=
=
=
undefined
)
{
cls
=
actionTypes
.
get
(
"
none
"
)
.
get
(
subtype
)
;
}
if
(
cls
=
=
=
undefined
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Unknown
subtype
{
subtype
}
for
type
{
type
}
)
;
}
return
cls
.
fromJSON
(
id
actionItem
)
;
}
}
class
NullAction
extends
Action
{
static
type
=
"
none
"
;
}
class
PauseAction
extends
NullAction
{
static
subtype
=
"
pause
"
;
affectsWallClockTime
=
true
;
constructor
(
id
options
)
{
super
(
id
)
;
const
{
duration
}
=
options
;
this
.
duration
=
duration
;
}
dispatch
(
state
inputSource
tickDuration
win
)
{
const
ms
=
this
.
duration
?
?
tickDuration
;
lazy
.
logger
.
trace
(
Dispatch
{
this
.
constructor
.
name
}
with
{
this
.
id
}
{
ms
}
)
;
return
lazy
.
Sleep
(
ms
)
;
}
static
fromJSON
(
id
actionItem
)
{
const
{
duration
}
=
actionItem
;
if
(
duration
!
=
=
undefined
)
{
lazy
.
assert
.
positiveInteger
(
duration
lazy
.
pprint
Expected
'
duration
'
(
{
duration
}
)
to
be
>
=
0
)
;
}
return
new
this
(
id
{
duration
}
)
;
}
}
class
KeyAction
extends
Action
{
static
type
=
"
key
"
;
constructor
(
id
options
)
{
super
(
id
)
;
const
{
value
}
=
options
;
this
.
value
=
value
;
}
getEventData
(
inputSource
)
{
let
value
=
this
.
value
;
if
(
inputSource
.
shift
)
{
value
=
lazy
.
keyData
.
getShiftedKey
(
value
)
;
}
return
new
KeyEventData
(
value
)
;
}
static
fromJSON
(
id
actionItem
)
{
const
value
=
actionItem
.
value
;
lazy
.
assert
.
string
(
value
"
Expected
'
value
'
to
be
a
string
that
represents
single
code
point
"
+
lazy
.
pprint
or
grapheme
cluster
got
{
value
}
)
;
return
new
this
(
id
{
value
}
)
;
}
}
class
KeyDownAction
extends
KeyAction
{
static
subtype
=
"
keyDown
"
;
dispatch
(
state
inputSource
tickDuration
win
)
{
lazy
.
logger
.
trace
(
Dispatch
{
this
.
constructor
.
name
}
with
{
this
.
id
}
{
this
.
value
}
)
;
return
new
Promise
(
resolve
=
>
{
const
keyEvent
=
this
.
getEventData
(
inputSource
)
;
keyEvent
.
repeat
=
inputSource
.
isPressed
(
keyEvent
.
key
)
;
inputSource
.
press
(
keyEvent
.
key
)
;
if
(
keyEvent
.
key
in
MODIFIER_NAME_LOOKUP
)
{
inputSource
.
setModState
(
keyEvent
.
key
true
)
;
}
state
.
inputsToCancel
.
push
(
new
KeyUpAction
(
this
.
id
this
)
)
;
keyEvent
.
update
(
state
inputSource
)
;
lazy
.
event
.
sendKeyDown
(
keyEvent
win
)
;
resolve
(
)
;
}
)
;
}
}
class
KeyUpAction
extends
KeyAction
{
static
subtype
=
"
keyUp
"
;
dispatch
(
state
inputSource
tickDuration
win
)
{
lazy
.
logger
.
trace
(
Dispatch
{
this
.
constructor
.
name
}
with
{
this
.
id
}
{
this
.
value
}
)
;
return
new
Promise
(
resolve
=
>
{
const
keyEvent
=
this
.
getEventData
(
inputSource
)
;
if
(
!
inputSource
.
isPressed
(
keyEvent
.
key
)
)
{
resolve
(
)
;
return
;
}
if
(
keyEvent
.
key
in
MODIFIER_NAME_LOOKUP
)
{
inputSource
.
setModState
(
keyEvent
.
key
false
)
;
}
inputSource
.
release
(
keyEvent
.
key
)
;
keyEvent
.
update
(
state
inputSource
)
;
lazy
.
event
.
sendKeyUp
(
keyEvent
win
)
;
resolve
(
)
;
}
)
;
}
}
class
PointerAction
extends
Action
{
static
type
=
"
pointer
"
;
constructor
(
id
options
)
{
super
(
id
)
;
const
{
width
height
pressure
tangentialPressure
tiltX
tiltY
twist
altitudeAngle
azimuthAngle
}
=
options
;
this
.
width
=
width
;
this
.
height
=
height
;
this
.
pressure
=
pressure
;
this
.
tangentialPressure
=
tangentialPressure
;
this
.
tiltX
=
tiltX
;
this
.
tiltY
=
tiltY
;
this
.
twist
=
twist
;
this
.
altitudeAngle
=
altitudeAngle
;
this
.
azimuthAngle
=
azimuthAngle
;
}
static
validateCommon
(
actionItem
)
{
const
{
width
height
pressure
tangentialPressure
tiltX
tiltY
twist
altitudeAngle
azimuthAngle
}
=
actionItem
;
if
(
width
!
=
=
undefined
)
{
lazy
.
assert
.
positiveInteger
(
width
lazy
.
pprint
Expected
'
width
'
(
{
width
}
)
to
be
>
=
0
)
;
}
if
(
height
!
=
=
undefined
)
{
lazy
.
assert
.
positiveInteger
(
height
lazy
.
pprint
Expected
'
height
'
(
{
height
}
)
to
be
>
=
0
)
;
}
if
(
pressure
!
=
=
undefined
)
{
lazy
.
assert
.
numberInRange
(
pressure
[
0
1
]
lazy
.
pprint
Expected
'
pressure
'
(
{
pressure
}
)
to
be
in
range
0
to
1
)
;
}
if
(
tangentialPressure
!
=
=
undefined
)
{
lazy
.
assert
.
numberInRange
(
tangentialPressure
[
-
1
1
]
lazy
.
pprint
Expected
'
tangentialPressure
'
(
{
tangentialPressure
}
)
to
be
in
range
-
1
to
1
)
;
}
if
(
tiltX
!
=
=
undefined
)
{
lazy
.
assert
.
integerInRange
(
tiltX
[
-
90
90
]
lazy
.
pprint
Expected
'
tiltX
'
(
{
tiltX
}
)
to
be
in
range
-
90
to
90
)
;
}
if
(
tiltY
!
=
=
undefined
)
{
lazy
.
assert
.
integerInRange
(
tiltY
[
-
90
90
]
lazy
.
pprint
Expected
'
tiltY
'
(
{
tiltY
}
)
to
be
in
range
-
90
to
90
)
;
}
if
(
twist
!
=
=
undefined
)
{
lazy
.
assert
.
integerInRange
(
twist
[
0
359
]
lazy
.
pprint
Expected
'
twist
'
(
{
twist
}
)
to
be
in
range
0
to
359
)
;
}
if
(
altitudeAngle
!
=
=
undefined
)
{
lazy
.
assert
.
numberInRange
(
altitudeAngle
[
0
Math
.
PI
/
2
]
lazy
.
pprint
Expected
'
altitudeAngle
'
(
{
altitudeAngle
}
)
to
be
in
range
0
to
{
Math
.
PI
/
2
}
)
;
}
if
(
azimuthAngle
!
=
=
undefined
)
{
lazy
.
assert
.
numberInRange
(
azimuthAngle
[
0
2
*
Math
.
PI
]
lazy
.
pprint
Expected
'
azimuthAngle
'
(
{
azimuthAngle
}
)
to
be
in
range
0
to
{
2
*
Math
.
PI
}
)
;
}
return
{
width
height
pressure
tangentialPressure
tiltX
tiltY
twist
altitudeAngle
azimuthAngle
}
;
}
}
class
PointerDownAction
extends
PointerAction
{
static
subtype
=
"
pointerDown
"
;
constructor
(
id
options
)
{
super
(
id
options
)
;
const
{
button
}
=
options
;
this
.
button
=
button
;
}
dispatch
(
state
inputSource
tickDuration
win
)
{
lazy
.
logger
.
trace
(
Dispatch
{
this
.
constructor
.
name
}
{
inputSource
.
pointer
.
type
}
with
id
:
{
this
.
id
}
button
:
{
this
.
button
}
)
;
return
new
Promise
(
resolve
=
>
{
if
(
inputSource
.
isPressed
(
this
.
button
)
)
{
resolve
(
)
;
return
;
}
inputSource
.
press
(
this
.
button
)
;
state
.
inputsToCancel
.
push
(
new
PointerUpAction
(
this
.
id
this
)
)
;
inputSource
.
pointer
.
pointerDown
(
state
inputSource
this
win
)
;
resolve
(
)
;
}
)
;
}
static
fromJSON
(
id
actionItem
)
{
const
props
=
PointerAction
.
validateCommon
(
actionItem
)
;
const
{
button
}
=
actionItem
;
lazy
.
assert
.
positiveInteger
(
button
lazy
.
pprint
Expected
'
button
'
(
{
button
}
)
to
be
>
=
0
)
;
props
.
button
=
button
;
return
new
this
(
id
props
)
;
}
}
class
PointerUpAction
extends
PointerAction
{
static
subtype
=
"
pointerUp
"
;
constructor
(
id
options
)
{
super
(
id
options
)
;
const
{
button
}
=
options
;
this
.
button
=
button
;
}
dispatch
(
state
inputSource
tickDuration
win
)
{
lazy
.
logger
.
trace
(
Dispatch
{
this
.
constructor
.
name
}
{
inputSource
.
pointer
.
type
}
with
id
:
{
this
.
id
}
button
:
{
this
.
button
}
)
;
return
new
Promise
(
resolve
=
>
{
if
(
!
inputSource
.
isPressed
(
this
.
button
)
)
{
resolve
(
)
;
return
;
}
inputSource
.
release
(
this
.
button
)
;
inputSource
.
pointer
.
pointerUp
(
state
inputSource
this
win
)
;
resolve
(
)
;
}
)
;
}
static
fromJSON
(
id
actionItem
)
{
const
props
=
PointerAction
.
validateCommon
(
actionItem
)
;
const
{
button
}
=
actionItem
;
lazy
.
assert
.
positiveInteger
(
button
lazy
.
pprint
Expected
'
button
'
(
{
button
}
)
to
be
>
=
0
)
;
props
.
button
=
button
;
return
new
this
(
id
props
)
;
}
}
class
PointerMoveAction
extends
PointerAction
{
static
subtype
=
"
pointerMove
"
;
affectsWallClockTime
=
true
;
constructor
(
id
options
)
{
super
(
id
options
)
;
const
{
duration
origin
x
y
}
=
options
;
this
.
duration
=
duration
;
this
.
origin
=
origin
;
this
.
x
=
x
;
this
.
y
=
y
;
}
dispatch
(
state
inputSource
tickDuration
win
)
{
lazy
.
logger
.
trace
(
Dispatch
{
this
.
constructor
.
name
}
{
inputSource
.
pointer
.
type
}
with
id
:
{
this
.
id
}
x
:
{
this
.
x
}
y
:
{
this
.
y
}
)
;
const
target
=
this
.
origin
.
getTargetCoordinates
(
state
inputSource
[
this
.
x
this
.
y
]
win
)
;
assertInViewPort
(
target
win
)
;
return
moveOverTime
(
[
[
inputSource
.
x
inputSource
.
y
]
]
[
target
]
this
.
duration
?
?
tickDuration
target
=
>
this
.
performPointerMoveStep
(
state
inputSource
target
win
)
)
;
}
performPointerMoveStep
(
state
inputSource
targets
win
)
{
if
(
targets
.
length
!
=
=
1
)
{
throw
new
Error
(
"
PointerMoveAction
.
performPointerMoveStep
requires
a
single
target
"
)
;
}
const
target
=
targets
[
0
]
;
lazy
.
logger
.
trace
(
PointerMoveAction
.
performPointerMoveStep
{
JSON
.
stringify
(
target
)
}
)
;
if
(
target
[
0
]
=
=
inputSource
.
x
&
&
target
[
1
]
=
=
inputSource
.
y
)
{
return
;
}
inputSource
.
pointer
.
pointerMove
(
state
inputSource
this
target
[
0
]
target
[
1
]
win
)
;
inputSource
.
x
=
target
[
0
]
;
inputSource
.
y
=
target
[
1
]
;
}
static
fromJSON
(
id
actionItem
)
{
const
props
=
PointerAction
.
validateCommon
(
actionItem
)
;
const
{
duration
origin
x
y
}
=
actionItem
;
if
(
duration
!
=
=
undefined
)
{
lazy
.
assert
.
positiveInteger
(
duration
lazy
.
pprint
Expected
'
duration
'
(
{
duration
}
)
to
be
>
=
0
)
;
}
const
originObject
=
Origin
.
fromJSON
(
origin
)
;
if
(
x
!
=
=
undefined
)
{
lazy
.
assert
.
integer
(
x
lazy
.
pprint
Expected
'
x
'
(
{
x
}
)
to
be
an
Integer
)
;
}
if
(
y
!
=
=
undefined
)
{
lazy
.
assert
.
integer
(
y
lazy
.
pprint
Expected
'
y
'
(
{
y
}
)
to
be
an
Integer
)
;
}
props
.
duration
=
duration
;
props
.
origin
=
originObject
;
props
.
x
=
x
;
props
.
y
=
y
;
return
new
this
(
id
props
)
;
}
}
class
TouchActionGroup
{
static
type
=
null
;
constructor
(
)
{
this
.
type
=
this
.
constructor
.
type
;
this
.
actions
=
new
Map
(
)
;
}
static
forType
(
type
)
{
const
cls
=
touchActionGroupTypes
.
get
(
type
)
;
return
new
cls
(
)
;
}
addPointer
(
inputSource
action
)
{
if
(
action
.
subtype
!
=
=
this
.
type
)
{
throw
new
Error
(
Added
action
of
unexpected
type
got
{
action
.
subtype
}
expected
{
this
.
type
}
)
;
}
this
.
actions
.
set
(
action
.
id
[
inputSource
action
]
)
;
}
dispatch
(
state
inputSource
tickDuration
win
)
{
throw
new
Error
(
"
TouchActionGroup
subclass
missing
dispatch
implementation
"
)
;
}
}
class
PointerDownTouchActionGroup
extends
TouchActionGroup
{
static
type
=
"
pointerDown
"
;
dispatch
(
state
inputSource
tickDuration
win
)
{
lazy
.
logger
.
trace
(
Dispatch
{
this
.
constructor
.
name
}
with
{
Array
.
from
(
this
.
actions
.
values
(
)
)
.
map
(
x
=
>
x
[
1
]
.
id
)
}
)
;
return
new
Promise
(
resolve
=
>
{
if
(
inputSource
!
=
=
null
)
{
throw
new
Error
(
"
Expected
null
inputSource
for
PointerDownTouchActionGroup
.
dispatch
"
)
;
}
const
actions
=
Array
.
from
(
this
.
actions
.
values
(
)
)
.
filter
(
(
[
actionInputSource
action
]
)
=
>
!
actionInputSource
.
isPressed
(
action
.
button
)
)
;
if
(
actions
.
length
)
{
const
eventData
=
new
MultiTouchEventData
(
"
touchstart
"
)
;
for
(
const
[
actionInputSource
action
]
of
actions
)
{
eventData
.
addPointerEventData
(
actionInputSource
action
)
;
actionInputSource
.
press
(
action
.
button
)
;
state
.
inputsToCancel
.
push
(
new
PointerUpAction
(
action
.
id
action
)
)
;
eventData
.
update
(
state
actionInputSource
)
;
}
for
(
const
[
id
pointerInputSource
]
of
state
.
inputSourcesByType
(
"
pointer
"
)
)
{
if
(
pointerInputSource
.
pointer
.
type
=
=
=
"
touch
"
&
&
!
this
.
actions
.
has
(
id
)
&
&
pointerInputSource
.
isPressed
(
0
)
)
{
eventData
.
addPointerEventData
(
pointerInputSource
{
}
)
;
eventData
.
update
(
state
pointerInputSource
)
;
}
}
lazy
.
event
.
synthesizeMultiTouch
(
eventData
win
)
;
}
resolve
(
)
;
}
)
;
}
}
class
PointerUpTouchActionGroup
extends
TouchActionGroup
{
static
type
=
"
pointerUp
"
;
dispatch
(
state
inputSource
tickDuration
win
)
{
lazy
.
logger
.
trace
(
Dispatch
{
this
.
constructor
.
name
}
with
{
Array
.
from
(
this
.
actions
.
values
(
)
)
.
map
(
x
=
>
x
[
1
]
.
id
)
}
)
;
return
new
Promise
(
resolve
=
>
{
if
(
inputSource
!
=
=
null
)
{
throw
new
Error
(
"
Expected
null
inputSource
for
PointerUpTouchActionGroup
.
dispatch
"
)
;
}
const
actions
=
Array
.
from
(
this
.
actions
.
values
(
)
)
.
filter
(
(
[
actionInputSource
action
]
)
=
>
actionInputSource
.
isPressed
(
action
.
button
)
)
;
if
(
actions
.
length
)
{
const
eventData
=
new
MultiTouchEventData
(
"
touchend
"
)
;
for
(
const
[
actionInputSource
action
]
of
actions
)
{
eventData
.
addPointerEventData
(
actionInputSource
action
)
;
actionInputSource
.
release
(
action
.
button
)
;
eventData
.
update
(
state
actionInputSource
)
;
}
lazy
.
event
.
synthesizeMultiTouch
(
eventData
win
)
;
}
resolve
(
)
;
}
)
;
}
}
class
PointerMoveTouchActionGroup
extends
TouchActionGroup
{
static
type
=
"
pointerMove
"
;
dispatch
(
state
inputSource
tickDuration
win
)
{
lazy
.
logger
.
trace
(
Dispatch
{
this
.
constructor
.
name
}
with
{
Array
.
from
(
this
.
actions
)
.
map
(
x
=
>
x
[
1
]
.
id
)
}
)
;
if
(
inputSource
!
=
=
null
)
{
throw
new
Error
(
"
Expected
null
inputSource
for
PointerMoveTouchActionGroup
.
dispatch
"
)
;
}
let
startCoords
=
[
]
;
let
targetCoords
=
[
]
;
for
(
const
[
actionInputSource
action
]
of
this
.
actions
.
values
(
)
)
{
const
target
=
action
.
origin
.
getTargetCoordinates
(
state
actionInputSource
[
action
.
x
action
.
y
]
win
)
;
assertInViewPort
(
target
win
)
;
startCoords
.
push
(
[
actionInputSource
.
x
actionInputSource
.
y
]
)
;
targetCoords
.
push
(
target
)
;
}
const
staticTouchPointers
=
[
]
;
for
(
const
[
id
pointerInputSource
]
of
state
.
inputSourcesByType
(
"
pointer
"
)
)
{
if
(
pointerInputSource
.
pointer
.
type
=
=
=
"
touch
"
&
&
!
this
.
actions
.
has
(
id
)
&
&
pointerInputSource
.
isPressed
(
0
)
)
{
staticTouchPointers
.
push
(
pointerInputSource
)
;
}
}
return
moveOverTime
(
startCoords
targetCoords
this
.
duration
?
?
tickDuration
currentTargetCoords
=
>
this
.
performPointerMoveStep
(
state
staticTouchPointers
currentTargetCoords
win
)
)
;
}
performPointerMoveStep
(
state
staticTouchPointers
targetCoords
win
)
{
if
(
targetCoords
.
length
!
=
=
this
.
actions
.
size
)
{
throw
new
Error
(
"
Expected
one
target
per
pointer
"
)
;
}
const
perPointerData
=
Array
.
from
(
this
.
actions
.
values
(
)
)
.
map
(
(
[
inputSource
action
]
i
)
=
>
{
const
target
=
targetCoords
[
i
]
;
return
[
inputSource
action
target
]
;
}
)
;
const
reachedTarget
=
perPointerData
.
every
(
(
[
inputSource
action
target
]
)
=
>
target
[
0
]
=
=
=
inputSource
.
x
&
&
target
[
1
]
=
=
=
inputSource
.
y
)
;
if
(
reachedTarget
)
{
return
;
}
const
eventData
=
new
MultiTouchEventData
(
"
touchmove
"
)
;
for
(
const
[
inputSource
action
target
]
of
perPointerData
)
{
inputSource
.
x
=
target
[
0
]
;
inputSource
.
y
=
target
[
1
]
;
eventData
.
addPointerEventData
(
inputSource
action
)
;
eventData
.
update
(
state
inputSource
)
;
}
for
(
const
inputSource
of
staticTouchPointers
)
{
eventData
.
addPointerEventData
(
inputSource
{
}
)
;
eventData
.
update
(
state
inputSource
)
;
}
lazy
.
event
.
synthesizeMultiTouch
(
eventData
win
)
;
}
}
const
touchActionGroupTypes
=
new
Map
(
)
;
for
(
const
cls
of
[
PointerDownTouchActionGroup
PointerUpTouchActionGroup
PointerMoveTouchActionGroup
]
)
{
touchActionGroupTypes
.
set
(
cls
.
type
cls
)
;
}
async
function
moveOverTime
(
startCoords
targetCoords
duration
callback
)
{
lazy
.
logger
.
trace
(
moveOverTime
start
:
{
startCoords
}
target
:
{
targetCoords
}
duration
:
{
duration
}
)
;
if
(
startCoords
.
length
!
=
=
targetCoords
.
length
)
{
throw
new
Error
(
"
Expected
equal
number
of
start
coordinates
and
target
coordinates
"
)
;
}
if
(
!
startCoords
.
every
(
item
=
>
item
.
length
=
=
2
)
|
|
!
targetCoords
.
every
(
item
=
>
item
.
length
=
=
2
)
)
{
throw
new
Error
(
"
Expected
start
coordinates
target
coordinates
to
be
Array
of
multiple
[
x
y
]
coordinates
.
"
)
;
}
if
(
duration
=
=
=
0
)
{
callback
(
targetCoords
)
;
return
;
}
const
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
const
fps60
=
17
;
const
distances
=
targetCoords
.
map
(
(
targetCoord
i
)
=
>
{
const
startCoord
=
startCoords
[
i
]
;
return
[
targetCoord
[
0
]
-
startCoord
[
0
]
targetCoord
[
1
]
-
startCoord
[
1
]
]
;
}
)
;
const
ONE_SHOT
=
Ci
.
nsITimer
.
TYPE_ONE_SHOT
;
const
startTime
=
Date
.
now
(
)
;
const
intermediatePointerEvents
=
(
async
(
)
=
>
{
await
new
Promise
(
resolveTimer
=
>
timer
.
initWithCallback
(
resolveTimer
fps60
ONE_SHOT
)
)
;
let
durationRatio
=
Math
.
floor
(
Date
.
now
(
)
-
startTime
)
/
duration
;
const
epsilon
=
fps60
/
duration
/
10
;
while
(
1
-
durationRatio
>
epsilon
)
{
const
intermediateTargets
=
startCoords
.
map
(
(
startCoord
i
)
=
>
{
let
distance
=
distances
[
i
]
;
return
[
Math
.
floor
(
durationRatio
*
distance
[
0
]
+
startCoord
[
0
]
)
Math
.
floor
(
durationRatio
*
distance
[
1
]
+
startCoord
[
1
]
)
]
;
}
)
;
callback
(
intermediateTargets
)
;
await
new
Promise
(
resolveTimer
=
>
timer
.
initWithCallback
(
resolveTimer
fps60
ONE_SHOT
)
)
;
durationRatio
=
Math
.
floor
(
Date
.
now
(
)
-
startTime
)
/
duration
;
}
}
)
(
)
;
await
intermediatePointerEvents
;
callback
(
targetCoords
)
;
}
const
actionTypes
=
new
Map
(
)
;
for
(
const
cls
of
[
KeyDownAction
KeyUpAction
PauseAction
PointerDownAction
PointerUpAction
PointerMoveAction
]
)
{
if
(
!
actionTypes
.
has
(
cls
.
type
)
)
{
actionTypes
.
set
(
cls
.
type
new
Map
(
)
)
;
}
actionTypes
.
get
(
cls
.
type
)
.
set
(
cls
.
subtype
cls
)
;
}
class
Pointer
{
static
type
=
null
;
constructor
(
id
)
{
this
.
id
=
id
;
this
.
type
=
this
.
constructor
.
type
;
}
pointerDown
(
state
inputSource
action
win
)
{
throw
new
Error
(
Unimplemented
pointerDown
for
pointerType
{
this
.
type
}
)
;
}
pointerUp
(
state
inputSource
action
win
)
{
throw
new
Error
(
Unimplemented
pointerUp
for
pointerType
{
this
.
type
}
)
;
}
pointerMove
(
state
inputSource
targetX
targetY
win
)
{
throw
new
Error
(
Unimplemented
pointerMove
for
pointerType
{
this
.
type
}
)
;
}
static
fromJSON
(
pointerId
pointerType
)
{
const
cls
=
pointerTypes
.
get
(
pointerType
)
;
if
(
cls
=
=
=
undefined
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
Unknown
pointerType
:
{
pointerType
}
)
;
}
return
new
cls
(
pointerId
)
;
}
}
class
MousePointer
extends
Pointer
{
static
type
=
"
mouse
"
;
pointerDown
(
state
inputSource
action
win
)
{
const
mouseEvent
=
new
MouseEventData
(
"
mousedown
"
{
button
:
action
.
button
}
)
;
mouseEvent
.
update
(
state
inputSource
)
;
if
(
mouseEvent
.
ctrlKey
)
{
if
(
lazy
.
AppInfo
.
isMac
)
{
mouseEvent
.
button
=
2
;
lazy
.
event
.
DoubleClickTracker
.
resetClick
(
)
;
}
}
else
if
(
lazy
.
event
.
DoubleClickTracker
.
isClicked
(
)
)
{
mouseEvent
.
clickCount
=
2
;
}
lazy
.
event
.
synthesizeMouseAtPoint
(
inputSource
.
x
inputSource
.
y
mouseEvent
win
)
;
if
(
lazy
.
event
.
MouseButton
.
isSecondary
(
mouseEvent
.
button
)
|
|
(
mouseEvent
.
ctrlKey
&
&
lazy
.
AppInfo
.
isMac
)
)
{
const
contextMenuEvent
=
{
.
.
.
mouseEvent
type
:
"
contextmenu
"
}
;
lazy
.
event
.
synthesizeMouseAtPoint
(
inputSource
.
x
inputSource
.
y
contextMenuEvent
win
)
;
}
}
pointerUp
(
state
inputSource
action
win
)
{
const
mouseEvent
=
new
MouseEventData
(
"
mouseup
"
{
button
:
action
.
button
}
)
;
mouseEvent
.
update
(
state
inputSource
)
;
if
(
lazy
.
event
.
DoubleClickTracker
.
isClicked
(
)
)
{
mouseEvent
.
clickCount
=
2
;
}
lazy
.
event
.
synthesizeMouseAtPoint
(
inputSource
.
x
inputSource
.
y
mouseEvent
win
)
;
}
pointerMove
(
state
inputSource
action
targetX
targetY
win
)
{
const
mouseEvent
=
new
MouseEventData
(
"
mousemove
"
)
;
mouseEvent
.
update
(
state
inputSource
)
;
lazy
.
event
.
synthesizeMouseAtPoint
(
targetX
targetY
mouseEvent
win
)
;
}
}
class
TouchPointer
extends
Pointer
{
static
type
=
"
touch
"
;
}
class
PenPointer
extends
Pointer
{
static
type
=
"
pen
"
;
}
const
pointerTypes
=
new
Map
(
)
;
for
(
const
cls
of
[
MousePointer
TouchPointer
PenPointer
]
)
{
pointerTypes
.
set
(
cls
.
type
cls
)
;
}
action
.
Chain
=
class
extends
Array
{
toString
(
)
{
return
[
chain
{
super
.
toString
(
)
}
]
;
}
dispatch
(
state
win
)
{
let
i
=
1
;
const
chainEvents
=
(
async
(
)
=
>
{
for
(
const
tickActions
of
this
)
{
lazy
.
logger
.
trace
(
Dispatching
tick
{
i
+
+
}
/
{
this
.
length
}
)
;
await
tickActions
.
dispatch
(
state
win
)
;
}
}
)
(
)
;
return
chainEvents
;
}
static
fromJSON
(
state
actions
)
{
lazy
.
assert
.
array
(
actions
lazy
.
pprint
Expected
'
actions
'
to
be
an
array
got
{
actions
}
)
;
const
actionsByTick
=
new
this
(
)
;
for
(
const
actionSequence
of
actions
)
{
const
inputSourceActions
=
Sequence
.
fromJSON
(
state
actionSequence
)
;
for
(
let
i
=
0
;
i
<
inputSourceActions
.
length
;
i
+
+
)
{
if
(
actionsByTick
.
length
<
i
+
1
)
{
actionsByTick
.
push
(
new
TickActions
(
)
)
;
}
actionsByTick
[
i
]
.
push
(
inputSourceActions
[
i
]
)
;
}
}
return
actionsByTick
;
}
}
;
class
TickActions
extends
Array
{
getDuration
(
)
{
let
max
=
0
;
for
(
const
action
of
this
)
{
if
(
action
.
affectsWallClockTime
&
&
action
.
duration
)
{
max
=
Math
.
max
(
action
.
duration
max
)
;
}
}
return
max
;
}
dispatch
(
state
win
)
{
const
tickDuration
=
this
.
getDuration
(
)
;
const
tickActions
=
this
.
groupTickActions
(
state
)
;
const
pendingEvents
=
tickActions
.
map
(
(
[
inputSource
action
]
)
=
>
action
.
dispatch
(
state
inputSource
tickDuration
win
)
)
;
return
Promise
.
all
(
pendingEvents
)
;
}
groupTickActions
(
state
)
{
const
touchActions
=
new
Map
(
)
;
const
actions
=
[
]
;
for
(
const
action
of
this
)
{
const
inputSource
=
state
.
getInputSource
(
action
.
id
)
;
if
(
action
.
type
=
=
"
pointer
"
&
&
inputSource
.
pointer
.
type
=
=
=
"
touch
"
)
{
lazy
.
logger
.
debug
(
Grouping
action
{
action
.
type
}
{
action
.
id
}
{
action
.
subtype
}
)
;
let
group
=
touchActions
.
get
(
action
.
subtype
)
;
if
(
group
=
=
=
undefined
)
{
group
=
TouchActionGroup
.
forType
(
action
.
subtype
)
;
touchActions
.
set
(
action
.
subtype
group
)
;
actions
.
push
(
[
null
group
]
)
;
}
group
.
addPointer
(
inputSource
action
)
;
}
else
{
actions
.
push
(
[
inputSource
action
]
)
;
}
}
return
actions
;
}
}
class
Sequence
extends
Array
{
toString
(
)
{
return
[
sequence
{
super
.
toString
(
)
}
]
;
}
static
fromJSON
(
state
actionSequence
)
{
const
{
id
type
actions
}
=
actionSequence
;
lazy
.
assert
.
array
(
actions
"
Expected
'
actionSequence
.
actions
'
to
be
an
array
"
+
lazy
.
pprint
got
{
actionSequence
.
actions
}
)
;
InputSource
.
fromJSON
(
state
actionSequence
)
;
const
sequence
=
new
this
(
)
;
for
(
const
actionItem
of
actions
)
{
sequence
.
push
(
Action
.
fromJSON
(
type
id
actionItem
)
)
;
}
return
sequence
;
}
}
class
InputEventData
{
constructor
(
)
{
this
.
altKey
=
false
;
this
.
shiftKey
=
false
;
this
.
ctrlKey
=
false
;
this
.
metaKey
=
false
;
}
update
(
state
inputSource
)
{
}
toString
(
)
{
return
{
this
.
constructor
.
name
}
{
JSON
.
stringify
(
this
)
}
;
}
}
class
KeyEventData
extends
InputEventData
{
constructor
(
rawKey
)
{
super
(
)
;
const
{
key
code
location
printable
}
=
lazy
.
keyData
.
getData
(
rawKey
)
;
this
.
key
=
key
;
this
.
code
=
code
;
this
.
location
=
location
;
this
.
printable
=
printable
;
this
.
repeat
=
false
;
}
update
(
state
inputSource
)
{
this
.
altKey
=
inputSource
.
alt
;
this
.
shiftKey
=
inputSource
.
shift
;
this
.
ctrlKey
=
inputSource
.
ctrl
;
this
.
metaKey
=
inputSource
.
meta
;
}
}
class
PointerEventData
extends
InputEventData
{
constructor
(
type
)
{
super
(
)
;
this
.
type
=
type
;
this
.
buttons
=
0
;
}
update
(
state
inputSource
)
{
for
(
const
[
otherInputSource
]
of
state
.
inputSourcesByType
(
"
key
"
)
)
{
this
.
altKey
=
otherInputSource
.
alt
|
|
this
.
altKey
;
this
.
ctrlKey
=
otherInputSource
.
ctrl
|
|
this
.
ctrlKey
;
this
.
metaKey
=
otherInputSource
.
meta
|
|
this
.
metaKey
;
this
.
shiftKey
=
otherInputSource
.
shift
|
|
this
.
shiftKey
;
}
let
allButtons
=
Array
.
from
(
inputSource
.
pressed
)
;
this
.
buttons
=
allButtons
.
reduce
(
(
a
i
)
=
>
a
+
Math
.
pow
(
2
i
)
0
)
;
}
}
class
MouseEventData
extends
PointerEventData
{
constructor
(
type
options
=
{
}
)
{
super
(
type
)
;
const
{
button
=
0
}
=
options
;
lazy
.
assert
.
positiveInteger
(
button
)
;
this
.
button
=
button
;
this
.
buttons
=
0
;
}
update
(
state
inputSource
)
{
super
.
update
(
state
inputSource
)
;
this
.
id
=
inputSource
.
pointer
.
id
;
}
}
class
MultiTouchEventData
extends
PointerEventData
{
#
setGlobalState
;
constructor
(
type
)
{
super
(
type
)
;
this
.
id
=
[
]
;
this
.
x
=
[
]
;
this
.
y
=
[
]
;
this
.
rx
=
[
]
;
this
.
ry
=
[
]
;
this
.
angle
=
[
]
;
this
.
force
=
[
]
;
this
.
#
setGlobalState
=
false
;
}
addPointerEventData
(
inputSource
action
)
{
this
.
x
.
push
(
inputSource
.
x
)
;
this
.
y
.
push
(
inputSource
.
y
)
;
this
.
id
.
push
(
inputSource
.
pointer
.
id
)
;
this
.
rx
.
push
(
action
.
width
|
|
1
)
;
this
.
ry
.
push
(
action
.
height
|
|
1
)
;
this
.
angle
.
push
(
0
)
;
this
.
force
.
push
(
action
.
pressure
|
|
(
this
.
type
=
=
=
"
touchend
"
?
0
:
1
)
)
;
}
update
(
state
inputSource
)
{
if
(
!
this
.
#
setGlobalState
)
{
for
(
const
[
otherInputSource
]
of
state
.
inputSourcesByType
(
"
key
"
)
)
{
this
.
altKey
=
otherInputSource
.
alt
|
|
this
.
altKey
;
this
.
ctrlKey
=
otherInputSource
.
ctrl
|
|
this
.
ctrlKey
;
this
.
metaKey
=
otherInputSource
.
meta
|
|
this
.
metaKey
;
this
.
shiftKey
=
otherInputSource
.
shift
|
|
this
.
shiftKey
;
}
this
.
#
setGlobalState
=
true
;
}
const
allButtons
=
Array
.
from
(
inputSource
.
pressed
)
;
this
.
buttons
=
this
.
buttons
|
allButtons
.
reduce
(
(
a
i
)
=
>
a
+
Math
.
pow
(
2
i
)
0
)
;
}
}
function
assertInViewPort
(
target
win
)
{
const
[
x
y
]
=
target
;
lazy
.
assert
.
number
(
x
Expected
x
to
be
finite
number
)
;
lazy
.
assert
.
number
(
y
Expected
y
to
be
finite
number
)
;
if
(
x
<
0
|
|
y
<
0
|
|
x
>
win
.
innerWidth
|
|
y
>
win
.
innerHeight
)
{
throw
new
lazy
.
error
.
MoveTargetOutOfBoundsError
(
(
{
x
}
{
y
}
)
is
out
of
bounds
of
viewport
+
width
(
{
win
.
innerWidth
}
)
+
and
height
(
{
win
.
innerHeight
}
)
)
;
}
}
