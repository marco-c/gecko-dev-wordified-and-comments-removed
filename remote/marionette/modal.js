"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
modal
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
AppInfo
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
appinfo
.
js
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
lazy
.
Log
.
TYPES
.
MARIONETTE
)
)
;
const
COMMON_DIALOG
=
"
chrome
:
/
/
global
/
content
/
commonDialog
.
xhtml
"
;
const
modal
=
{
ACTION_CLOSED
:
"
closed
"
ACTION_OPENED
:
"
opened
"
}
;
modal
.
findModalDialogs
=
function
(
context
)
{
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
if
(
win
.
document
.
documentURI
=
=
=
COMMON_DIALOG
&
&
win
.
opener
&
&
win
.
opener
=
=
=
context
.
window
)
{
lazy
.
logger
.
trace
(
"
Found
open
window
modal
prompt
"
)
;
return
new
modal
.
Dialog
(
(
)
=
>
context
win
)
;
}
}
if
(
lazy
.
AppInfo
.
isAndroid
)
{
const
geckoViewPrompts
=
context
.
window
.
prompts
(
)
;
if
(
geckoViewPrompts
.
length
)
{
lazy
.
logger
.
trace
(
"
Found
open
GeckoView
prompt
"
)
;
const
prompt
=
geckoViewPrompts
[
0
]
;
return
new
modal
.
Dialog
(
(
)
=
>
context
prompt
)
;
}
}
const
contentBrowser
=
context
.
contentBrowser
;
if
(
contentBrowser
?
.
tabDialogBox
)
{
let
dialogs
=
contentBrowser
.
tabDialogBox
.
getTabDialogManager
(
)
.
dialogs
;
if
(
dialogs
.
length
)
{
lazy
.
logger
.
trace
(
"
Found
open
tab
modal
prompt
"
)
;
return
new
modal
.
Dialog
(
(
)
=
>
context
dialogs
[
0
]
.
frameContentWindow
)
;
}
dialogs
=
contentBrowser
.
tabDialogBox
.
getContentDialogManager
(
)
.
dialogs
;
if
(
dialogs
.
length
&
&
dialogs
[
0
]
.
frameContentWindow
.
Dialog
)
{
lazy
.
logger
.
trace
(
"
Found
open
content
prompt
"
)
;
return
new
modal
.
Dialog
(
(
)
=
>
context
dialogs
[
0
]
.
frameContentWindow
)
;
}
}
if
(
contentBrowser
?
.
tabModalPromptBox
)
{
const
prompts
=
contentBrowser
.
tabModalPromptBox
.
listPrompts
(
)
;
if
(
prompts
.
length
)
{
lazy
.
logger
.
trace
(
"
Found
open
old
-
style
content
prompt
"
)
;
return
new
modal
.
Dialog
(
(
)
=
>
context
null
)
;
}
}
return
null
;
}
;
modal
.
DialogObserver
=
class
{
constructor
(
curBrowserFn
)
{
this
.
_curBrowserFn
=
curBrowserFn
;
this
.
callbacks
=
new
Set
(
)
;
this
.
register
(
)
;
}
register
(
)
{
Services
.
obs
.
addObserver
(
this
"
common
-
dialog
-
loaded
"
)
;
Services
.
obs
.
addObserver
(
this
"
domwindowopened
"
)
;
Services
.
obs
.
addObserver
(
this
"
geckoview
-
prompt
-
show
"
)
;
Services
.
obs
.
addObserver
(
this
"
tabmodal
-
dialog
-
loaded
"
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
win
.
addEventListener
(
"
DOMModalDialogClosed
"
this
)
;
}
}
unregister
(
)
{
Services
.
obs
.
removeObserver
(
this
"
common
-
dialog
-
loaded
"
)
;
Services
.
obs
.
removeObserver
(
this
"
domwindowopened
"
)
;
Services
.
obs
.
removeObserver
(
this
"
geckoview
-
prompt
-
show
"
)
;
Services
.
obs
.
removeObserver
(
this
"
tabmodal
-
dialog
-
loaded
"
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
win
.
removeEventListener
(
"
DOMModalDialogClosed
"
this
)
;
}
}
cleanup
(
)
{
this
.
callbacks
.
clear
(
)
;
this
.
unregister
(
)
;
}
handleEvent
(
event
)
{
lazy
.
logger
.
trace
(
Received
event
{
event
.
type
}
)
;
const
chromeWin
=
event
.
target
.
opener
?
event
.
target
.
opener
.
ownerGlobal
:
event
.
target
.
ownerGlobal
;
if
(
chromeWin
!
=
this
.
_curBrowserFn
(
)
.
window
)
{
return
;
}
this
.
callbacks
.
forEach
(
callback
=
>
{
callback
(
modal
.
ACTION_CLOSED
event
.
target
)
;
}
)
;
}
observe
(
subject
topic
)
{
lazy
.
logger
.
trace
(
Received
observer
notification
{
topic
}
)
;
const
curBrowser
=
this
.
_curBrowserFn
(
)
;
switch
(
topic
)
{
case
"
tabmodal
-
dialog
-
loaded
"
:
const
container
=
curBrowser
.
contentBrowser
.
closest
(
"
.
browserSidebarContainer
"
)
;
if
(
!
container
.
contains
(
subject
)
)
{
return
;
}
this
.
callbacks
.
forEach
(
callback
=
>
callback
(
modal
.
ACTION_OPENED
subject
)
)
;
break
;
case
"
common
-
dialog
-
loaded
"
:
const
modalType
=
subject
.
Dialog
.
args
.
modalType
;
if
(
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_TAB
|
|
modalType
=
=
=
Services
.
prompt
.
MODAL_TYPE_CONTENT
)
{
const
container
=
curBrowser
.
contentBrowser
.
closest
(
"
.
browserSidebarContainer
"
)
;
if
(
!
container
.
contains
(
subject
.
docShell
.
chromeEventHandler
)
)
{
return
;
}
}
else
if
(
subject
.
ownerGlobal
!
=
curBrowser
.
window
&
&
subject
.
opener
?
.
ownerGlobal
!
=
curBrowser
.
window
)
{
return
;
}
this
.
callbacks
.
forEach
(
callback
=
>
callback
(
modal
.
ACTION_OPENED
subject
)
)
;
break
;
case
"
domwindowopened
"
:
subject
.
addEventListener
(
"
DOMModalDialogClosed
"
this
)
;
break
;
case
"
geckoview
-
prompt
-
show
"
:
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
null
)
)
{
const
prompt
=
win
.
prompts
(
)
.
find
(
item
=
>
item
.
id
=
=
subject
.
id
)
;
if
(
prompt
)
{
this
.
callbacks
.
forEach
(
callback
=
>
callback
(
modal
.
ACTION_OPENED
prompt
)
)
;
return
;
}
}
break
;
}
}
add
(
callback
)
{
if
(
this
.
callbacks
.
has
(
callback
)
)
{
return
;
}
this
.
callbacks
.
add
(
callback
)
;
}
remove
(
callback
)
{
if
(
!
this
.
callbacks
.
has
(
callback
)
)
{
return
;
}
this
.
callbacks
.
delete
(
callback
)
;
}
async
dialogClosed
(
)
{
return
new
Promise
(
resolve
=
>
{
const
dialogClosed
=
(
action
dialog
)
=
>
{
if
(
action
=
=
modal
.
ACTION_CLOSED
)
{
this
.
remove
(
dialogClosed
)
;
resolve
(
)
;
}
}
;
this
.
add
(
dialogClosed
)
;
}
)
;
}
}
;
modal
.
Dialog
=
class
{
constructor
(
curBrowserFn
dialog
)
{
this
.
curBrowserFn_
=
curBrowserFn
;
this
.
win_
=
Cu
.
getWeakReference
(
dialog
)
;
}
get
args
(
)
{
if
(
lazy
.
AppInfo
.
isAndroid
)
{
return
this
.
window
.
args
;
}
let
tm
=
this
.
tabModal
;
return
tm
?
tm
.
args
:
null
;
}
get
curBrowser_
(
)
{
return
this
.
curBrowserFn_
(
)
;
}
get
isOpen
(
)
{
if
(
lazy
.
AppInfo
.
isAndroid
)
{
return
this
.
window
!
=
=
null
;
}
if
(
!
this
.
ui
)
{
return
false
;
}
return
true
;
}
get
isWindowModal
(
)
{
return
[
Services
.
prompt
.
MODAL_TYPE_WINDOW
Services
.
prompt
.
MODAL_TYPE_INTERNAL_WINDOW
]
.
includes
(
this
.
args
.
modalType
)
;
}
get
tabModal
(
)
{
let
win
=
this
.
window
;
if
(
win
)
{
return
win
.
Dialog
;
}
return
this
.
curBrowser_
.
getTabModal
(
)
;
}
get
text
(
)
{
if
(
lazy
.
AppInfo
.
isAndroid
)
{
return
this
.
window
.
getPromptText
(
)
;
}
return
this
.
ui
.
infoBody
.
textContent
;
}
get
ui
(
)
{
let
tm
=
this
.
tabModal
;
return
tm
?
tm
.
ui
:
null
;
}
get
window
(
)
{
if
(
this
.
win_
)
{
let
win
=
this
.
win_
.
get
(
)
;
if
(
win
&
&
(
lazy
.
AppInfo
.
isAndroid
|
|
win
.
parent
)
)
{
return
win
;
}
}
return
null
;
}
set
text
(
inputText
)
{
if
(
lazy
.
AppInfo
.
isAndroid
)
{
this
.
window
.
setInputText
(
inputText
)
;
}
else
{
let
{
loginTextbox
}
=
this
.
ui
;
loginTextbox
.
value
=
inputText
;
}
}
accept
(
)
{
if
(
lazy
.
AppInfo
.
isAndroid
)
{
this
.
window
.
acceptPrompt
(
)
;
}
else
{
const
{
button0
}
=
this
.
ui
;
button0
.
click
(
)
;
}
}
dismiss
(
)
{
if
(
lazy
.
AppInfo
.
isAndroid
)
{
this
.
window
.
dismissPrompt
(
)
;
}
else
{
const
{
button0
button1
}
=
this
.
ui
;
(
button1
?
button1
:
button0
)
.
click
(
)
;
}
}
}
;
