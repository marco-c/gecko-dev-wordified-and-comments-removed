"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
interaction
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
accessibility
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
accessibility
.
js
"
atom
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
atom
.
js
"
element
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
element
.
js
"
error
:
"
chrome
:
/
/
remote
/
content
/
shared
/
webdriver
/
Errors
.
jsm
"
event
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
event
.
js
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
pprint
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Format
.
jsm
"
TimedPromise
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
sync
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
logger
"
(
)
=
>
lazy
.
Log
.
get
(
lazy
.
Log
.
TYPES
.
MARIONETTE
)
)
;
const
DISABLED_ATTRIBUTE_SUPPORTED_XUL
=
new
Set
(
[
"
ARROWSCROLLBOX
"
"
BUTTON
"
"
CHECKBOX
"
"
COMMAND
"
"
DESCRIPTION
"
"
KEY
"
"
KEYSET
"
"
LABEL
"
"
MENU
"
"
MENUITEM
"
"
MENULIST
"
"
MENUSEPARATOR
"
"
RADIO
"
"
RADIOGROUP
"
"
RICHLISTBOX
"
"
RICHLISTITEM
"
"
TAB
"
"
TABS
"
"
TOOLBARBUTTON
"
"
TREE
"
]
)
;
const
COMMON_FORM_CONTROLS
=
new
Set
(
[
"
input
"
"
textarea
"
"
select
"
]
)
;
const
INPUT_TYPES_NO_EVENT
=
new
Set
(
[
"
checkbox
"
"
radio
"
"
file
"
"
hidden
"
"
image
"
"
reset
"
"
button
"
"
submit
"
]
)
;
const
interaction
=
{
}
;
interaction
.
clickElement
=
async
function
(
el
strict
=
false
specCompat
=
false
)
{
const
a11y
=
lazy
.
accessibility
.
get
(
strict
)
;
if
(
lazy
.
element
.
isXULElement
(
el
)
)
{
await
chromeClick
(
el
a11y
)
;
}
else
if
(
specCompat
)
{
await
webdriverClickElement
(
el
a11y
)
;
}
else
{
lazy
.
logger
.
trace
(
Using
non
spec
-
compatible
element
click
)
;
await
seleniumClickElement
(
el
a11y
)
;
}
}
;
async
function
webdriverClickElement
(
el
a11y
)
{
const
win
=
getWindow
(
el
)
;
if
(
el
.
localName
=
=
"
input
"
&
&
el
.
type
=
=
"
file
"
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
Cannot
click
<
input
type
=
file
>
elements
"
)
;
}
let
containerEl
=
lazy
.
element
.
getContainer
(
el
)
;
if
(
!
lazy
.
element
.
isInView
(
containerEl
)
)
{
lazy
.
element
.
scrollIntoView
(
containerEl
)
;
}
if
(
!
lazy
.
element
.
isInView
(
containerEl
)
)
{
throw
new
lazy
.
error
.
ElementNotInteractableError
(
lazy
.
pprint
Element
{
el
}
could
not
be
scrolled
into
view
)
;
}
let
rects
=
containerEl
.
getClientRects
(
)
;
let
clickPoint
=
lazy
.
element
.
getInViewCentrePoint
(
rects
[
0
]
win
)
;
if
(
lazy
.
element
.
isObscured
(
containerEl
)
)
{
throw
new
lazy
.
error
.
ElementClickInterceptedError
(
containerEl
clickPoint
)
;
}
let
acc
=
await
a11y
.
getAccessible
(
el
true
)
;
a11y
.
assertVisible
(
acc
el
true
)
;
a11y
.
assertEnabled
(
acc
el
true
)
;
a11y
.
assertActionable
(
acc
el
)
;
if
(
el
.
localName
=
=
"
option
"
)
{
interaction
.
selectOption
(
el
)
;
}
else
{
let
clicked
=
interaction
.
flushEventLoop
(
containerEl
)
;
lazy
.
event
.
synthesizeMouseAtPoint
(
clickPoint
.
x
clickPoint
.
y
{
type
:
"
mousemove
"
}
win
)
;
lazy
.
event
.
synthesizeMouseAtPoint
(
clickPoint
.
x
clickPoint
.
y
{
}
win
)
;
await
clicked
;
}
}
async
function
chromeClick
(
el
a11y
)
{
if
(
!
lazy
.
atom
.
isElementEnabled
(
el
)
)
{
throw
new
lazy
.
error
.
InvalidElementStateError
(
"
Element
is
not
enabled
"
)
;
}
let
acc
=
await
a11y
.
getAccessible
(
el
true
)
;
a11y
.
assertVisible
(
acc
el
true
)
;
a11y
.
assertEnabled
(
acc
el
true
)
;
a11y
.
assertActionable
(
acc
el
)
;
if
(
el
.
localName
=
=
"
option
"
)
{
interaction
.
selectOption
(
el
)
;
}
else
{
el
.
click
(
)
;
}
}
async
function
seleniumClickElement
(
el
a11y
)
{
let
win
=
getWindow
(
el
)
;
let
visibilityCheckEl
=
el
;
if
(
el
.
localName
=
=
"
option
"
)
{
visibilityCheckEl
=
lazy
.
element
.
getContainer
(
el
)
;
}
if
(
!
lazy
.
element
.
isVisible
(
visibilityCheckEl
)
)
{
throw
new
lazy
.
error
.
ElementNotInteractableError
(
)
;
}
if
(
!
lazy
.
atom
.
isElementEnabled
(
el
)
)
{
throw
new
lazy
.
error
.
InvalidElementStateError
(
"
Element
is
not
enabled
"
)
;
}
let
acc
=
await
a11y
.
getAccessible
(
el
true
)
;
a11y
.
assertVisible
(
acc
el
true
)
;
a11y
.
assertEnabled
(
acc
el
true
)
;
a11y
.
assertActionable
(
acc
el
)
;
if
(
el
.
localName
=
=
"
option
"
)
{
interaction
.
selectOption
(
el
)
;
}
else
{
let
rects
=
el
.
getClientRects
(
)
;
let
centre
=
lazy
.
element
.
getInViewCentrePoint
(
rects
[
0
]
win
)
;
let
opts
=
{
}
;
lazy
.
event
.
synthesizeMouseAtPoint
(
centre
.
x
centre
.
y
opts
win
)
;
}
}
interaction
.
selectOption
=
function
(
el
)
{
if
(
lazy
.
element
.
isXULElement
(
el
)
)
{
throw
new
TypeError
(
"
XUL
dropdowns
not
supported
"
)
;
}
if
(
el
.
localName
!
=
"
option
"
)
{
throw
new
TypeError
(
lazy
.
pprint
Expected
<
option
>
element
got
{
el
}
)
;
}
let
containerEl
=
lazy
.
element
.
getContainer
(
el
)
;
lazy
.
event
.
mouseover
(
containerEl
)
;
lazy
.
event
.
mousemove
(
containerEl
)
;
lazy
.
event
.
mousedown
(
containerEl
)
;
containerEl
.
focus
(
)
;
if
(
!
el
.
disabled
)
{
if
(
containerEl
.
multiple
)
{
el
.
selected
=
!
el
.
selected
;
}
else
if
(
!
el
.
selected
)
{
el
.
selected
=
true
;
}
lazy
.
event
.
input
(
containerEl
)
;
lazy
.
event
.
change
(
containerEl
)
;
}
lazy
.
event
.
mouseup
(
containerEl
)
;
lazy
.
event
.
click
(
containerEl
)
;
containerEl
.
blur
(
)
;
}
;
interaction
.
clearElement
=
function
(
el
)
{
if
(
lazy
.
element
.
isDisabled
(
el
)
)
{
throw
new
lazy
.
error
.
InvalidElementStateError
(
lazy
.
pprint
Element
is
disabled
:
{
el
}
)
;
}
if
(
lazy
.
element
.
isReadOnly
(
el
)
)
{
throw
new
lazy
.
error
.
InvalidElementStateError
(
lazy
.
pprint
Element
is
read
-
only
:
{
el
}
)
;
}
if
(
!
lazy
.
element
.
isEditable
(
el
)
)
{
throw
new
lazy
.
error
.
InvalidElementStateError
(
lazy
.
pprint
Unable
to
clear
element
that
cannot
be
edited
:
{
el
}
)
;
}
if
(
!
lazy
.
element
.
isInView
(
el
)
)
{
lazy
.
element
.
scrollIntoView
(
el
)
;
}
if
(
!
lazy
.
element
.
isInView
(
el
)
)
{
throw
new
lazy
.
error
.
ElementNotInteractableError
(
lazy
.
pprint
Element
{
el
}
could
not
be
scrolled
into
view
)
;
}
if
(
lazy
.
element
.
isEditingHost
(
el
)
)
{
clearContentEditableElement
(
el
)
;
}
else
{
clearResettableElement
(
el
)
;
}
}
;
function
clearContentEditableElement
(
el
)
{
if
(
el
.
innerHTML
=
=
=
"
"
)
{
return
;
}
el
.
focus
(
)
;
el
.
innerHTML
=
"
"
;
lazy
.
event
.
change
(
el
)
;
el
.
blur
(
)
;
}
function
clearResettableElement
(
el
)
{
if
(
!
lazy
.
element
.
isMutableFormControl
(
el
)
)
{
throw
new
lazy
.
error
.
InvalidElementStateError
(
lazy
.
pprint
Not
an
editable
form
control
:
{
el
}
)
;
}
let
isEmpty
;
switch
(
el
.
type
)
{
case
"
file
"
:
isEmpty
=
!
el
.
files
.
length
;
break
;
default
:
isEmpty
=
el
.
value
=
=
=
"
"
;
break
;
}
if
(
el
.
validity
.
valid
&
&
isEmpty
)
{
return
;
}
el
.
focus
(
)
;
el
.
value
=
"
"
;
lazy
.
event
.
change
(
el
)
;
el
.
blur
(
)
;
}
interaction
.
flushEventLoop
=
async
function
(
el
)
{
const
win
=
el
.
ownerGlobal
;
let
unloadEv
clickEv
;
let
spinEventLoop
=
resolve
=
>
{
unloadEv
=
resolve
;
clickEv
=
event
=
>
{
lazy
.
logger
.
trace
(
Received
DOM
event
click
for
{
event
.
target
}
)
;
if
(
win
.
closed
)
{
resolve
(
)
;
}
else
{
win
.
setTimeout
(
resolve
0
)
;
}
}
;
win
.
addEventListener
(
"
unload
"
unloadEv
{
mozSystemGroup
:
true
}
)
;
el
.
addEventListener
(
"
click
"
clickEv
{
mozSystemGroup
:
true
}
)
;
}
;
let
removeListeners
=
(
)
=
>
{
win
.
removeEventListener
(
"
unload
"
unloadEv
)
;
el
.
removeEventListener
(
"
click
"
clickEv
)
;
}
;
return
new
lazy
.
TimedPromise
(
spinEventLoop
{
timeout
:
500
throws
:
null
}
)
.
then
(
removeListeners
)
;
}
;
interaction
.
moveCaretToEnd
=
function
(
el
)
{
if
(
!
lazy
.
element
.
isDOMElement
(
el
)
)
{
return
;
}
let
isTextarea
=
el
.
localName
=
=
"
textarea
"
;
let
isInputText
=
el
.
localName
=
=
"
input
"
&
&
el
.
type
=
=
"
text
"
;
if
(
isTextarea
|
|
isInputText
)
{
if
(
el
.
selectionEnd
=
=
0
)
{
let
len
=
el
.
value
.
length
;
el
.
setSelectionRange
(
len
len
)
;
}
}
}
;
interaction
.
isKeyboardInteractable
=
function
(
el
)
{
const
win
=
getWindow
(
el
)
;
if
(
el
.
localName
=
=
=
"
body
"
|
|
el
=
=
=
win
.
document
.
documentElement
)
{
return
true
;
}
const
menuPopup
=
el
.
closest
(
"
menupopup
"
)
;
if
(
menuPopup
)
{
if
(
menuPopup
.
state
!
=
=
"
open
"
)
{
return
false
;
}
const
menuItem
=
el
.
closest
(
"
menuitem
"
)
;
if
(
menuItem
)
{
return
!
menuItem
.
disabled
&
&
!
menuItem
.
hidden
;
}
return
true
;
}
el
.
focus
(
)
;
return
el
=
=
=
win
.
document
.
activeElement
;
}
;
interaction
.
uploadFiles
=
async
function
(
el
paths
)
{
let
files
=
[
]
;
if
(
el
.
hasAttribute
(
"
multiple
"
)
)
{
files
=
Array
.
prototype
.
slice
.
call
(
el
.
files
)
;
}
else
if
(
paths
.
length
>
1
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
lazy
.
pprint
Element
{
el
}
doesn
'
t
accept
multiple
files
)
;
}
for
(
let
path
of
paths
)
{
let
file
;
try
{
file
=
await
File
.
createFromFileName
(
path
)
;
}
catch
(
e
)
{
throw
new
lazy
.
error
.
InvalidArgumentError
(
"
File
not
found
:
"
+
path
)
;
}
files
.
push
(
file
)
;
}
el
.
mozSetFileArray
(
files
)
;
}
;
interaction
.
setFormControlValue
=
function
(
el
value
)
{
if
(
!
COMMON_FORM_CONTROLS
.
has
(
el
.
localName
)
)
{
throw
new
TypeError
(
"
This
function
is
for
form
elements
only
"
)
;
}
el
.
value
=
value
;
if
(
INPUT_TYPES_NO_EVENT
.
has
(
el
.
type
)
)
{
return
;
}
lazy
.
event
.
input
(
el
)
;
lazy
.
event
.
change
(
el
)
;
}
;
interaction
.
sendKeysToElement
=
async
function
(
el
value
{
strictFileInteractability
=
false
accessibilityChecks
=
false
webdriverClick
=
false
}
=
{
}
)
{
const
a11y
=
lazy
.
accessibility
.
get
(
accessibilityChecks
)
;
if
(
webdriverClick
)
{
await
webdriverSendKeysToElement
(
el
value
a11y
strictFileInteractability
)
;
}
else
{
await
legacySendKeysToElement
(
el
value
a11y
)
;
}
}
;
async
function
webdriverSendKeysToElement
(
el
value
a11y
strictFileInteractability
)
{
const
win
=
getWindow
(
el
)
;
if
(
el
.
type
!
=
"
file
"
|
|
strictFileInteractability
)
{
let
containerEl
=
lazy
.
element
.
getContainer
(
el
)
;
if
(
!
interaction
.
isKeyboardInteractable
(
containerEl
)
)
{
throw
new
lazy
.
error
.
ElementNotInteractableError
(
lazy
.
pprint
Element
{
el
}
is
not
reachable
by
keyboard
)
;
}
}
let
acc
=
await
a11y
.
getAccessible
(
el
true
)
;
a11y
.
assertActionable
(
acc
el
)
;
el
.
focus
(
)
;
interaction
.
moveCaretToEnd
(
el
)
;
if
(
el
.
type
=
=
"
file
"
)
{
let
paths
=
value
.
split
(
"
\
n
"
)
;
await
interaction
.
uploadFiles
(
el
paths
)
;
lazy
.
event
.
input
(
el
)
;
lazy
.
event
.
change
(
el
)
;
}
else
if
(
el
.
type
=
=
"
date
"
|
|
el
.
type
=
=
"
time
"
)
{
interaction
.
setFormControlValue
(
el
value
)
;
}
else
{
lazy
.
event
.
sendKeys
(
value
win
)
;
}
}
async
function
legacySendKeysToElement
(
el
value
a11y
)
{
const
win
=
getWindow
(
el
)
;
if
(
el
.
type
=
=
"
file
"
)
{
el
.
focus
(
)
;
await
interaction
.
uploadFiles
(
el
[
value
]
)
;
lazy
.
event
.
input
(
el
)
;
lazy
.
event
.
change
(
el
)
;
}
else
if
(
el
.
type
=
=
"
date
"
|
|
el
.
type
=
=
"
time
"
)
{
interaction
.
setFormControlValue
(
el
value
)
;
}
else
{
let
visibilityCheckEl
=
el
;
if
(
el
.
localName
=
=
"
option
"
)
{
visibilityCheckEl
=
lazy
.
element
.
getContainer
(
el
)
;
}
if
(
!
lazy
.
element
.
isVisible
(
visibilityCheckEl
)
)
{
throw
new
lazy
.
error
.
ElementNotInteractableError
(
"
Element
is
not
visible
"
)
;
}
let
acc
=
await
a11y
.
getAccessible
(
el
true
)
;
a11y
.
assertActionable
(
acc
el
)
;
interaction
.
moveCaretToEnd
(
el
)
;
el
.
focus
(
)
;
lazy
.
event
.
sendKeys
(
value
win
)
;
}
}
interaction
.
isElementDisplayed
=
function
(
el
strict
=
false
)
{
let
win
=
getWindow
(
el
)
;
let
displayed
=
lazy
.
atom
.
isElementDisplayed
(
el
win
)
;
let
a11y
=
lazy
.
accessibility
.
get
(
strict
)
;
return
a11y
.
getAccessible
(
el
)
.
then
(
acc
=
>
{
a11y
.
assertVisible
(
acc
el
displayed
)
;
return
displayed
;
}
)
;
}
;
interaction
.
isElementEnabled
=
function
(
el
strict
=
false
)
{
let
enabled
=
true
;
let
win
=
getWindow
(
el
)
;
if
(
lazy
.
element
.
isXULElement
(
el
)
)
{
if
(
DISABLED_ATTRIBUTE_SUPPORTED_XUL
.
has
(
el
.
tagName
.
toUpperCase
(
)
)
)
{
if
(
el
.
hasAttribute
(
"
disabled
"
)
&
&
el
.
getAttribute
(
"
disabled
"
)
=
=
=
"
true
"
)
{
enabled
=
false
;
}
}
}
else
if
(
[
"
application
/
xml
"
"
text
/
xml
"
]
.
includes
(
win
.
document
.
contentType
)
)
{
enabled
=
false
;
}
else
{
enabled
=
lazy
.
atom
.
isElementEnabled
(
el
{
frame
:
win
}
)
;
}
let
a11y
=
lazy
.
accessibility
.
get
(
strict
)
;
return
a11y
.
getAccessible
(
el
)
.
then
(
acc
=
>
{
a11y
.
assertEnabled
(
acc
el
enabled
)
;
return
enabled
;
}
)
;
}
;
interaction
.
isElementSelected
=
function
(
el
strict
=
false
)
{
let
selected
=
lazy
.
element
.
isSelected
(
el
)
;
let
a11y
=
lazy
.
accessibility
.
get
(
strict
)
;
return
a11y
.
getAccessible
(
el
)
.
then
(
acc
=
>
{
a11y
.
assertSelected
(
acc
el
selected
)
;
return
selected
;
}
)
;
}
;
function
getWindow
(
el
)
{
return
el
.
ownerDocument
.
defaultView
;
}
