"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Marionette
"
"
MarionetteFactory
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Deferred
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Sync
.
jsm
"
EnvironmentPrefs
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
prefs
.
js
"
Log
:
"
chrome
:
/
/
remote
/
content
/
shared
/
Log
.
jsm
"
MarionettePrefs
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
prefs
.
js
"
Preferences
:
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
RecommendedPreferences
:
"
chrome
:
/
/
remote
/
content
/
shared
/
RecommendedPreferences
.
jsm
"
TCPListener
:
"
chrome
:
/
/
remote
/
content
/
marionette
/
server
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
logger
"
(
)
=
>
Log
.
get
(
Log
.
TYPES
.
MARIONETTE
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
textEncoder
"
(
)
=
>
new
TextEncoder
(
)
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
env
"
"
mozilla
.
org
/
process
/
environment
;
1
"
"
nsIEnvironment
"
)
;
const
NOTIFY_LISTENING
=
"
marionette
-
listening
"
;
const
ENV_ENABLED
=
"
MOZ_MARIONETTE
"
;
const
ENV_PRESERVE_PREFS
=
"
MOZ_MARIONETTE_PREF_STATE_ACROSS_RESTARTS
"
;
const
RECOMMENDED_PREFS
=
new
Map
(
[
[
"
dom
.
disable_beforeunload
"
true
]
]
)
;
const
isRemote
=
Services
.
appinfo
.
processType
=
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
;
class
MarionetteParentProcess
{
#
browserStartupFinished
;
constructor
(
)
{
this
.
server
=
null
;
this
.
_activePortPath
;
this
.
classID
=
Components
.
ID
(
"
{
786a1369
-
dca5
-
4adc
-
8486
-
33d23c88010a
}
"
)
;
this
.
helpInfo
=
"
-
-
marionette
Enable
remote
control
server
.
\
n
"
;
this
.
enabled
=
env
.
exists
(
ENV_ENABLED
)
;
Services
.
ppmm
.
addMessageListener
(
"
Marionette
:
IsRunning
"
this
)
;
this
.
#
browserStartupFinished
=
Deferred
(
)
;
}
get
browserStartupFinished
(
)
{
return
this
.
#
browserStartupFinished
.
promise
;
}
get
enabled
(
)
{
return
this
.
_enabled
;
}
set
enabled
(
value
)
{
if
(
this
.
_enabled
|
|
!
value
)
{
return
;
}
this
.
_enabled
=
value
;
logger
.
info
(
Marionette
enabled
)
;
}
get
running
(
)
{
return
!
!
this
.
server
&
&
this
.
server
.
alive
;
}
receiveMessage
(
{
name
}
)
{
switch
(
name
)
{
case
"
Marionette
:
IsRunning
"
:
return
this
.
running
;
default
:
logger
.
warn
(
"
Unknown
IPC
message
to
parent
process
:
"
+
name
)
;
return
null
;
}
}
handle
(
cmdLine
)
{
cmdLine
.
handleFlag
(
"
marionette
"
false
)
;
}
async
observe
(
subject
topic
)
{
if
(
this
.
enabled
)
{
logger
.
trace
(
Received
observer
notification
{
topic
}
)
;
}
switch
(
topic
)
{
case
"
profile
-
after
-
change
"
:
Services
.
obs
.
addObserver
(
this
"
command
-
line
-
startup
"
)
;
break
;
case
"
command
-
line
-
startup
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
this
.
enabled
=
subject
.
handleFlag
(
"
marionette
"
false
)
;
if
(
this
.
enabled
)
{
Services
.
obs
.
addObserver
(
this
"
final
-
ui
-
startup
"
)
;
if
(
Services
.
appinfo
.
inSafeMode
)
{
Services
.
obs
.
addObserver
(
this
"
domwindowopened
"
)
;
}
RecommendedPreferences
.
applyPreferences
(
RECOMMENDED_PREFS
)
;
for
(
let
[
pref
value
]
of
EnvironmentPrefs
.
from
(
ENV_PRESERVE_PREFS
)
)
{
Preferences
.
set
(
pref
value
)
;
}
}
break
;
case
"
domwindowopened
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
this
.
suppressSafeModeDialog
(
subject
)
;
break
;
case
"
final
-
ui
-
startup
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
Services
.
obs
.
addObserver
(
this
"
browser
-
idle
-
startup
-
tasks
-
finished
"
)
;
Services
.
obs
.
addObserver
(
this
"
mail
-
idle
-
startup
-
tasks
-
finished
"
)
;
Services
.
obs
.
addObserver
(
this
"
quit
-
application
"
)
;
await
this
.
init
(
)
;
break
;
case
"
browser
-
idle
-
startup
-
tasks
-
finished
"
:
case
"
mail
-
idle
-
startup
-
tasks
-
finished
"
:
Services
.
obs
.
removeObserver
(
this
"
browser
-
idle
-
startup
-
tasks
-
finished
"
)
;
Services
.
obs
.
removeObserver
(
this
"
mail
-
idle
-
startup
-
tasks
-
finished
"
)
;
this
.
#
browserStartupFinished
.
resolve
(
)
;
break
;
case
"
quit
-
application
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
await
this
.
uninit
(
)
;
break
;
}
}
suppressSafeModeDialog
(
win
)
{
win
.
addEventListener
(
"
load
"
(
)
=
>
{
let
dialog
=
win
.
document
.
getElementById
(
"
safeModeDialog
"
)
;
if
(
dialog
)
{
logger
.
trace
(
"
Safe
mode
detected
supressing
dialog
"
)
;
win
.
setTimeout
(
(
)
=
>
{
dialog
.
getButton
(
"
accept
"
)
.
click
(
)
;
}
)
;
}
}
{
once
:
true
}
)
;
}
async
init
(
)
{
if
(
!
this
.
enabled
|
|
this
.
running
)
{
logger
.
debug
(
Init
aborted
(
enabled
=
{
this
.
enabled
}
running
=
{
this
.
running
}
)
)
;
return
;
}
try
{
this
.
server
=
new
TCPListener
(
MarionettePrefs
.
port
)
;
this
.
server
.
start
(
)
;
}
catch
(
e
)
{
logger
.
fatal
(
"
Marionette
server
failed
to
start
"
e
)
;
await
this
.
uninit
(
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eForceQuit
)
;
return
;
}
env
.
set
(
ENV_ENABLED
"
1
"
)
;
Services
.
obs
.
notifyObservers
(
this
NOTIFY_LISTENING
true
)
;
logger
.
debug
(
"
Marionette
is
listening
"
)
;
this
.
_activePortPath
=
PathUtils
.
join
(
PathUtils
.
profileDir
"
MarionetteActivePort
"
)
;
const
data
=
{
this
.
server
.
port
}
;
try
{
await
IOUtils
.
write
(
this
.
_activePortPath
textEncoder
.
encode
(
data
)
)
;
}
catch
(
e
)
{
logger
.
warn
(
Failed
to
create
{
this
.
_activePortPath
}
(
{
e
.
message
}
)
)
;
}
}
async
uninit
(
)
{
if
(
this
.
running
)
{
this
.
server
.
stop
(
)
;
Services
.
obs
.
notifyObservers
(
this
NOTIFY_LISTENING
)
;
logger
.
debug
(
"
Marionette
stopped
listening
"
)
;
try
{
await
IOUtils
.
remove
(
this
.
_activePortPath
)
;
}
catch
(
e
)
{
logger
.
warn
(
Failed
to
remove
{
this
.
_activePortPath
}
(
{
e
.
message
}
)
)
;
}
}
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsICommandLineHandler
"
"
nsIMarionette
"
"
nsIObserver
"
]
)
;
}
}
class
MarionetteContentProcess
{
constructor
(
)
{
this
.
classID
=
Components
.
ID
(
"
{
786a1369
-
dca5
-
4adc
-
8486
-
33d23c88010a
}
"
)
;
}
get
running
(
)
{
let
reply
=
Services
.
cpmm
.
sendSyncMessage
(
"
Marionette
:
IsRunning
"
)
;
if
(
reply
.
length
=
=
0
)
{
logger
.
warn
(
"
No
reply
from
parent
process
"
)
;
return
false
;
}
return
reply
[
0
]
;
}
get
QueryInterface
(
)
{
return
ChromeUtils
.
generateQI
(
[
"
nsIMarionette
"
]
)
;
}
}
var
Marionette
;
if
(
isRemote
)
{
Marionette
=
new
MarionetteContentProcess
(
)
;
}
else
{
Marionette
=
new
MarionetteParentProcess
(
)
;
}
const
MarionetteFactory
=
function
(
)
{
return
Marionette
;
}
;
