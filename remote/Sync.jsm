"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
DOMContentLoadedPromise
"
"
EventPromise
"
"
MessagePromise
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
function
EventPromise
(
listener
type
options
=
{
capture
:
false
wantsUntrusted
:
false
mozSystemGroup
:
false
}
)
{
if
(
!
listener
|
|
!
(
"
addEventListener
"
in
listener
)
)
{
throw
new
TypeError
(
)
;
}
if
(
typeof
type
!
=
"
string
"
)
{
throw
new
TypeError
(
)
;
}
if
(
(
"
capture
"
in
options
&
&
typeof
options
.
capture
!
=
"
boolean
"
)
|
|
(
"
wantsUntrusted
"
in
options
&
&
typeof
options
.
wantsUntrusted
!
=
"
boolean
"
)
|
|
(
"
mozSystemGroup
"
in
options
&
&
typeof
options
.
mozSystemGroup
!
=
"
boolean
"
)
)
{
throw
new
TypeError
(
)
;
}
options
.
once
=
true
;
return
new
Promise
(
resolve
=
>
{
listener
.
addEventListener
(
type
event
=
>
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
resolve
(
event
)
)
;
}
options
)
;
}
)
;
}
function
DOMContentLoadedPromise
(
window
options
=
{
mozSystemGroup
:
true
}
)
{
if
(
window
.
document
.
readyState
=
=
"
complete
"
|
|
window
.
document
.
readyState
=
=
"
interactive
"
)
{
return
Promise
.
resolve
(
)
;
}
return
new
EventPromise
(
window
"
DOMContentLoaded
"
options
)
;
}
function
MessagePromise
(
target
name
)
{
if
(
!
(
target
instanceof
Ci
.
nsIMessageSender
)
)
{
throw
new
TypeError
(
)
;
}
return
new
Promise
(
resolve
=
>
{
const
onMessage
=
(
.
.
.
args
)
=
>
{
target
.
removeMessageListener
(
name
onMessage
)
;
resolve
(
.
.
.
args
)
;
}
;
target
.
addMessageListener
(
name
onMessage
)
;
}
)
;
}
