#
ifndef
mozilla_StyleSheet_h
#
define
mozilla_StyleSheet_h
#
include
"
mozilla
/
css
/
SheetParsingMode
.
h
"
#
include
"
mozilla
/
dom
/
CSSStyleSheetBinding
.
h
"
#
include
"
mozilla
/
dom
/
SRIMetadata
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
StyleSheetInfo
.
h
"
#
include
"
mozilla
/
URLExtraData
.
h
"
#
include
"
nsICSSLoaderObserver
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsStringFwd
.
h
"
class
nsINode
;
class
nsIPrincipal
;
struct
nsLayoutStylesheetCacheShm
;
struct
RawServoSharedMemoryBuilder
;
class
nsIReferrerInfo
;
namespace
mozilla
{
class
ServoCSSRuleList
;
class
ServoStyleSet
;
typedef
MozPromise
<
bool
bool
true
>
StyleSheetParsePromise
;
namespace
css
{
class
GroupRule
;
class
Loader
;
class
LoaderReusableStyleSheets
;
class
Rule
;
class
SheetLoadData
;
}
namespace
dom
{
class
CSSImportRule
;
class
CSSRuleList
;
class
DocumentOrShadowRoot
;
class
MediaList
;
class
ShadowRoot
;
class
SRIMetadata
;
}
enum
class
StyleSheetState
:
uint8_t
{
Disabled
=
1
<
<
0
Complete
=
1
<
<
1
ForcedUniqueInner
=
1
<
<
2
ModifiedRules
=
1
<
<
3
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
StyleSheetState
)
class
StyleSheet
final
:
public
nsICSSLoaderObserver
public
nsWrapperCache
{
StyleSheet
(
const
StyleSheet
&
aCopy
StyleSheet
*
aParentToUse
dom
:
:
CSSImportRule
*
aOwnerRuleToUse
dom
:
:
DocumentOrShadowRoot
*
aDocOrShadowRootToUse
nsINode
*
aOwningNodeToUse
)
;
virtual
~
StyleSheet
(
)
;
using
State
=
StyleSheetState
;
public
:
StyleSheet
(
css
:
:
SheetParsingMode
aParsingMode
CORSMode
aCORSMode
const
dom
:
:
SRIMetadata
&
aIntegrity
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
StyleSheet
)
already_AddRefed
<
StyleSheet
>
CreateEmptyChildSheet
(
already_AddRefed
<
dom
:
:
MediaList
>
aMediaList
)
const
;
bool
HasRules
(
)
const
;
RefPtr
<
StyleSheetParsePromise
>
ParseSheet
(
css
:
:
Loader
&
const
nsACString
&
aBytes
css
:
:
SheetLoadData
&
)
;
void
FinishAsyncParse
(
already_AddRefed
<
RawServoStyleSheetContents
>
aSheetContents
)
;
void
ParseSheetSync
(
css
:
:
Loader
*
aLoader
const
nsACString
&
aBytes
css
:
:
SheetLoadData
*
aLoadData
uint32_t
aLineNumber
css
:
:
LoaderReusableStyleSheets
*
aReusableSheets
=
nullptr
)
;
nsresult
ReparseSheet
(
const
nsAString
&
aInput
)
;
const
RawServoStyleSheetContents
*
RawContents
(
)
const
{
return
Inner
(
)
.
mContents
;
}
void
SetContentsForImport
(
const
RawServoStyleSheetContents
*
aContents
)
{
MOZ_ASSERT
(
!
Inner
(
)
.
mContents
)
;
Inner
(
)
.
mContents
=
aContents
;
}
URLExtraData
*
URLData
(
)
const
{
return
Inner
(
)
.
mURLData
;
}
NS_IMETHOD
StyleSheetLoaded
(
StyleSheet
*
aSheet
bool
aWasDeferred
nsresult
aStatus
)
final
;
ServoCSSRuleList
*
GetCssRulesInternal
(
)
;
mozilla
:
:
StyleOrigin
GetOrigin
(
)
const
;
enum
class
ChangeType
{
Added
Removed
ApplicableStateChanged
RuleAdded
RuleRemoved
RuleChanged
}
;
void
SetOwningNode
(
nsINode
*
aOwningNode
)
{
mOwningNode
=
aOwningNode
;
}
css
:
:
SheetParsingMode
ParsingMode
(
)
const
{
return
mParsingMode
;
}
mozilla
:
:
dom
:
:
CSSStyleSheetParsingMode
ParsingModeDOM
(
)
;
bool
IsComplete
(
)
const
{
return
bool
(
mState
&
State
:
:
Complete
)
;
}
void
SetComplete
(
)
;
void
SetEnabled
(
bool
aEnabled
)
{
SetDisabled
(
!
aEnabled
)
;
}
bool
IsInline
(
)
const
{
return
!
GetOriginalURI
(
)
;
}
nsIURI
*
GetSheetURI
(
)
const
{
return
Inner
(
)
.
mSheetURI
;
}
nsIURI
*
GetOriginalURI
(
)
const
{
return
Inner
(
)
.
mOriginalSheetURI
;
}
nsIURI
*
GetBaseURI
(
)
const
{
return
Inner
(
)
.
mBaseURI
;
}
inline
void
SetURIs
(
nsIURI
*
aSheetURI
nsIURI
*
aOriginalSheetURI
nsIURI
*
aBaseURI
)
;
bool
IsApplicable
(
)
const
{
return
!
Disabled
(
)
&
&
IsComplete
(
)
;
}
already_AddRefed
<
StyleSheet
>
Clone
(
StyleSheet
*
aCloneParent
dom
:
:
CSSImportRule
*
aCloneOwnerRule
dom
:
:
DocumentOrShadowRoot
*
aCloneDocumentOrShadowRoot
nsINode
*
aCloneOwningNode
)
const
;
bool
HasForcedUniqueInner
(
)
const
{
return
bool
(
mState
&
State
:
:
ForcedUniqueInner
)
;
}
bool
HasModifiedRules
(
)
const
{
return
bool
(
mState
&
State
:
:
ModifiedRules
)
;
}
void
ClearModifiedRules
(
)
{
mState
&
=
~
State
:
:
ModifiedRules
;
}
bool
HasUniqueInner
(
)
const
{
return
Inner
(
)
.
mSheets
.
Length
(
)
=
=
1
;
}
void
AssertHasUniqueInner
(
)
const
{
MOZ_ASSERT
(
HasUniqueInner
(
)
)
;
}
void
EnsureUniqueInner
(
)
;
void
AppendAllChildSheets
(
nsTArray
<
StyleSheet
*
>
&
aArray
)
;
enum
AssociationMode
:
uint8_t
{
OwnedByDocumentOrShadowRoot
NotOwnedByDocumentOrShadowRoot
}
;
dom
:
:
DocumentOrShadowRoot
*
GetAssociatedDocumentOrShadowRoot
(
)
const
{
return
mDocumentOrShadowRoot
;
}
bool
IsKeptAliveByDocument
(
)
const
;
dom
:
:
Document
*
GetComposedDoc
(
)
const
;
dom
:
:
Document
*
GetAssociatedDocument
(
)
const
;
void
SetAssociatedDocumentOrShadowRoot
(
dom
:
:
DocumentOrShadowRoot
*
AssociationMode
)
;
void
ClearAssociatedDocumentOrShadowRoot
(
)
{
SetAssociatedDocumentOrShadowRoot
(
nullptr
NotOwnedByDocumentOrShadowRoot
)
;
}
nsINode
*
GetOwnerNode
(
)
const
{
return
mOwningNode
;
}
StyleSheet
*
GetParentSheet
(
)
const
{
return
mParent
;
}
void
SetOwnerRule
(
dom
:
:
CSSImportRule
*
aOwnerRule
)
{
mOwnerRule
=
aOwnerRule
;
}
dom
:
:
CSSImportRule
*
GetOwnerRule
(
)
const
{
return
mOwnerRule
;
}
void
PrependStyleSheet
(
StyleSheet
*
aSheet
)
;
void
PrependStyleSheetSilently
(
StyleSheet
*
aSheet
)
;
StyleSheet
*
GetFirstChild
(
)
const
;
StyleSheet
*
GetMostRecentlyAddedChildSheet
(
)
const
{
return
GetFirstChild
(
)
;
}
nsIPrincipal
*
Principal
(
)
const
{
return
Inner
(
)
.
mPrincipal
;
}
void
SetPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
StyleSheetInfo
&
info
=
Inner
(
)
;
MOZ_ASSERT
(
!
info
.
mPrincipalSet
"
Should
only
set
principal
once
"
)
;
if
(
aPrincipal
)
{
info
.
mPrincipal
=
aPrincipal
;
#
ifdef
DEBUG
info
.
mPrincipalSet
=
true
;
#
endif
}
}
void
SetTitle
(
const
nsAString
&
aTitle
)
{
mTitle
=
aTitle
;
}
void
SetMedia
(
dom
:
:
MediaList
*
aMedia
)
;
CORSMode
GetCORSMode
(
)
const
{
return
Inner
(
)
.
mCORSMode
;
}
nsIReferrerInfo
*
GetReferrerInfo
(
)
const
{
return
Inner
(
)
.
mReferrerInfo
;
}
void
SetReferrerInfo
(
nsIReferrerInfo
*
aReferrerInfo
)
{
Inner
(
)
.
mReferrerInfo
=
aReferrerInfo
;
}
void
GetIntegrity
(
dom
:
:
SRIMetadata
&
aResult
)
const
{
aResult
=
Inner
(
)
.
mIntegrity
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
#
ifdef
DEBUG
void
List
(
FILE
*
aOut
=
stdout
int32_t
aIndex
=
0
)
const
;
#
endif
void
GetType
(
nsAString
&
aType
)
;
void
GetHref
(
nsAString
&
aHref
ErrorResult
&
aRv
)
;
StyleSheet
*
GetParentStyleSheet
(
)
const
{
return
GetParentSheet
(
)
;
}
void
GetTitle
(
nsAString
&
aTitle
)
;
dom
:
:
MediaList
*
Media
(
)
;
bool
Disabled
(
)
const
{
return
bool
(
mState
&
State
:
:
Disabled
)
;
}
void
SetDisabled
(
bool
aDisabled
)
;
void
GetSourceMapURL
(
nsAString
&
aTitle
)
;
void
SetSourceMapURL
(
const
nsAString
&
aSourceMapURL
)
;
void
SetSourceMapURLFromComment
(
const
nsAString
&
aSourceMapURLFromComment
)
;
void
GetSourceURL
(
nsAString
&
aSourceURL
)
;
void
SetSourceURL
(
const
nsAString
&
aSourceURL
)
;
css
:
:
Rule
*
GetDOMOwnerRule
(
)
const
;
dom
:
:
CSSRuleList
*
GetCssRules
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
)
;
uint32_t
InsertRule
(
const
nsAString
&
aRule
uint32_t
aIndex
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
void
DeleteRule
(
uint32_t
aIndex
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
int32_t
AddRule
(
const
nsAString
&
aSelector
const
nsAString
&
aBlock
const
dom
:
:
Optional
<
uint32_t
>
&
aIndex
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
inline
dom
:
:
ParentObject
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
final
;
void
WillDirty
(
)
;
void
RuleChanged
(
css
:
:
Rule
*
)
;
void
AddStyleSet
(
ServoStyleSet
*
aStyleSet
)
;
void
DropStyleSet
(
ServoStyleSet
*
aStyleSet
)
;
nsresult
DeleteRuleFromGroup
(
css
:
:
GroupRule
*
aGroup
uint32_t
aIndex
)
;
nsresult
InsertRuleIntoGroup
(
const
nsAString
&
aRule
css
:
:
GroupRule
*
aGroup
uint32_t
aIndex
)
;
uint64_t
FindOwningWindowInnerID
(
)
const
;
template
<
typename
Func
>
void
EnumerateChildSheets
(
Func
aCallback
)
{
for
(
StyleSheet
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
mNext
)
{
aCallback
(
child
)
;
}
}
const
ServoCssRules
*
ToShared
(
RawServoSharedMemoryBuilder
*
aBuilder
)
;
void
SetSharedContents
(
nsLayoutStylesheetCacheShm
*
aSharedMemory
const
ServoCssRules
*
aSharedRules
)
;
bool
IsReadOnly
(
)
const
;
private
:
dom
:
:
ShadowRoot
*
GetContainingShadow
(
)
const
;
StyleSheetInfo
&
Inner
(
)
{
MOZ_ASSERT
(
mInner
)
;
return
*
mInner
;
}
const
StyleSheetInfo
&
Inner
(
)
const
{
MOZ_ASSERT
(
mInner
)
;
return
*
mInner
;
}
bool
AreRulesAvailable
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
void
SetURLExtraData
(
)
;
protected
:
uint32_t
InsertRuleInternal
(
const
nsAString
&
aRule
uint32_t
aIndex
ErrorResult
&
)
;
void
DeleteRuleInternal
(
uint32_t
aIndex
ErrorResult
&
)
;
nsresult
InsertRuleIntoGroupInternal
(
const
nsAString
&
aRule
css
:
:
GroupRule
*
aGroup
uint32_t
aIndex
)
;
void
FinishParse
(
)
;
void
BuildChildListAfterInnerClone
(
)
;
void
DropRuleList
(
)
;
void
RuleAdded
(
css
:
:
Rule
&
)
;
void
RuleRemoved
(
css
:
:
Rule
&
)
;
void
StyleSheetCloned
(
StyleSheet
&
)
;
void
ApplicableStateChanged
(
bool
aApplicable
)
;
struct
ChildSheetListBuilder
{
RefPtr
<
StyleSheet
>
*
sheetSlot
;
StyleSheet
*
parent
;
void
SetParentLinks
(
StyleSheet
*
aSheet
)
;
static
void
ReparentChildList
(
StyleSheet
*
aPrimarySheet
StyleSheet
*
aFirstChild
)
;
}
;
void
UnparentChildren
(
)
;
void
LastRelease
(
)
;
void
SubjectSubsumesInnerPrincipal
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
void
DropMedia
(
)
;
void
UnlinkInner
(
)
;
void
TraverseInner
(
nsCycleCollectionTraversalCallback
&
)
;
static
bool
RuleHasPendingChildSheet
(
css
:
:
Rule
*
aRule
)
;
StyleSheet
*
mParent
;
nsString
mTitle
;
dom
:
:
DocumentOrShadowRoot
*
mDocumentOrShadowRoot
;
nsINode
*
mOwningNode
;
dom
:
:
CSSImportRule
*
mOwnerRule
;
RefPtr
<
dom
:
:
MediaList
>
mMedia
;
RefPtr
<
StyleSheet
>
mNext
;
css
:
:
SheetParsingMode
mParsingMode
;
State
mState
;
AssociationMode
mAssociationMode
;
StyleSheetInfo
*
mInner
;
nsTArray
<
ServoStyleSet
*
>
mStyleSets
;
RefPtr
<
ServoCSSRuleList
>
mRuleList
;
MozPromiseHolder
<
StyleSheetParsePromise
>
mParsePromise
;
friend
struct
mozilla
:
:
StyleSheetInfo
;
}
;
}
#
endif
