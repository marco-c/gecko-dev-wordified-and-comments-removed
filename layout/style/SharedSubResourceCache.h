#
ifndef
mozilla_SharedSubResourceCache_h__
#
define
mozilla_SharedSubResourceCache_h__
#
include
"
mozilla
/
PrincipalHashKey
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
{
enum
class
CachedSubResourceState
{
Miss
Loading
Pending
Complete
}
;
template
<
typename
Derived
>
struct
SharedSubResourceCacheLoadingValueBase
{
RefPtr
<
Derived
>
mNext
;
bool
mIsLoading
=
false
;
bool
mIsCancelled
=
false
;
~
SharedSubResourceCacheLoadingValueBase
(
)
{
RefPtr
<
Derived
>
next
=
std
:
:
move
(
mNext
)
;
while
(
next
)
{
next
=
std
:
:
move
(
next
-
>
mNext
)
;
}
}
}
;
template
<
typename
Traits
typename
Derived
>
class
SharedSubResourceCache
{
private
:
using
Loader
=
typename
Traits
:
:
Loader
;
using
Key
=
typename
Traits
:
:
Key
;
using
Value
=
typename
Traits
:
:
Value
;
using
LoadingValue
=
typename
Traits
:
:
LoadingValue
;
static
Key
KeyFromLoadingValue
(
const
LoadingValue
&
aValue
)
{
return
Traits
:
:
KeyFromLoadingValue
(
aValue
)
;
}
const
Derived
&
AsDerived
(
)
const
{
return
*
static_cast
<
const
Derived
*
>
(
this
)
;
}
Derived
&
AsDerived
(
)
{
return
*
static_cast
<
Derived
*
>
(
this
)
;
}
public
:
SharedSubResourceCache
(
const
SharedSubResourceCache
&
)
=
delete
;
SharedSubResourceCache
(
SharedSubResourceCache
&
&
)
=
delete
;
SharedSubResourceCache
(
)
=
default
;
static
already_AddRefed
<
Derived
>
Get
(
)
{
static_assert
(
std
:
:
is_base_of_v
<
SharedSubResourceCacheLoadingValueBase
<
LoadingValue
>
LoadingValue
>
)
;
if
(
sInstance
)
{
return
do_AddRef
(
sInstance
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
sInstance
)
;
RefPtr
<
Derived
>
cache
=
new
Derived
(
)
;
cache
-
>
Init
(
)
;
sInstance
=
cache
.
get
(
)
;
return
cache
.
forget
(
)
;
}
public
:
struct
Result
{
Value
*
mCompleteValue
=
nullptr
;
LoadingValue
*
mLoadingOrPendingValue
=
nullptr
;
CachedSubResourceState
mState
=
CachedSubResourceState
:
:
Miss
;
}
;
Result
Lookup
(
Loader
&
const
Key
&
bool
aSyncLoad
)
;
[
[
nodiscard
]
]
bool
CoalesceLoad
(
const
Key
&
LoadingValue
&
aNewLoad
CachedSubResourceState
aExistingLoadState
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
)
const
;
void
LoadStarted
(
const
Key
&
LoadingValue
&
)
;
void
LoadCompleted
(
LoadingValue
&
)
;
void
Insert
(
LoadingValue
&
)
;
void
DeferLoad
(
const
Key
&
LoadingValue
&
)
;
template
<
typename
Callback
>
void
StartPendingLoadsForLoader
(
Loader
&
const
Callback
&
aShouldStartLoad
)
;
void
CancelLoadsForLoader
(
Loader
&
)
;
void
RegisterLoader
(
Loader
&
)
;
void
UnregisterLoader
(
Loader
&
)
;
void
ClearInProcess
(
nsIPrincipal
*
aForPrincipal
=
nullptr
const
nsACString
*
aBaseDomain
=
nullptr
)
;
protected
:
void
CancelPendingLoadsForLoader
(
Loader
&
)
;
~
SharedSubResourceCache
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sInstance
=
=
this
)
;
sInstance
=
nullptr
;
}
struct
CompleteSubResource
{
uint32_t
mExpirationTime
=
0
;
RefPtr
<
Value
>
mResource
;
inline
bool
Expired
(
)
const
;
}
;
void
WillStartPendingLoad
(
LoadingValue
&
)
;
nsTHashMap
<
Key
CompleteSubResource
>
mComplete
;
nsRefPtrHashtable
<
Key
LoadingValue
>
mPending
;
nsTHashMap
<
Key
WeakPtr
<
LoadingValue
>
>
mLoading
;
nsTHashMap
<
PrincipalHashKey
uint32_t
>
mLoaderPrincipalRefCnt
;
protected
:
inline
static
Derived
*
sInstance
;
}
;
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
ClearInProcess
(
nsIPrincipal
*
aForPrincipal
const
nsACString
*
aBaseDomain
)
{
if
(
!
aForPrincipal
&
&
!
aBaseDomain
)
{
mComplete
.
Clear
(
)
;
return
;
}
for
(
auto
iter
=
mComplete
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
bool
shouldRemove
=
[
&
]
{
if
(
aForPrincipal
&
&
iter
.
Key
(
)
.
Principal
(
)
-
>
Equals
(
aForPrincipal
)
)
{
return
true
;
}
if
(
!
aBaseDomain
)
{
return
false
;
}
nsIPrincipal
*
partitionPrincipal
=
iter
.
Key
(
)
.
PartitionPrincipal
(
)
;
nsAutoCString
principalBaseDomain
;
nsresult
rv
=
partitionPrincipal
-
>
GetBaseDomain
(
principalBaseDomain
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
principalBaseDomain
.
Equals
(
*
aBaseDomain
)
)
{
return
true
;
}
return
StoragePrincipalHelper
:
:
PartitionKeyHasBaseDomain
(
partitionPrincipal
-
>
OriginAttributesRef
(
)
.
mPartitionKey
*
aBaseDomain
)
;
}
(
)
;
if
(
shouldRemove
)
{
iter
.
Remove
(
)
;
}
}
}
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
RegisterLoader
(
Loader
&
aLoader
)
{
mLoaderPrincipalRefCnt
.
LookupOrInsert
(
aLoader
.
LoaderPrincipal
(
)
0
)
+
=
1
;
}
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
UnregisterLoader
(
Loader
&
aLoader
)
{
nsIPrincipal
*
prin
=
aLoader
.
LoaderPrincipal
(
)
;
auto
lookup
=
mLoaderPrincipalRefCnt
.
Lookup
(
prin
)
;
MOZ_RELEASE_ASSERT
(
lookup
)
;
MOZ_RELEASE_ASSERT
(
lookup
.
Data
(
)
)
;
if
(
!
-
-
lookup
.
Data
(
)
)
{
lookup
.
Remove
(
)
;
for
(
auto
iter
=
mComplete
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
Key
(
)
.
LoaderPrincipal
(
)
-
>
Equals
(
prin
)
)
{
iter
.
Remove
(
)
;
}
}
}
}
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
CancelPendingLoadsForLoader
(
Loader
&
aLoader
)
{
AutoTArray
<
RefPtr
<
LoadingValue
>
10
>
arr
;
for
(
auto
iter
=
mPending
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
LoadingValue
>
&
first
=
iter
.
Data
(
)
;
LoadingValue
*
prev
=
nullptr
;
LoadingValue
*
current
=
iter
.
Data
(
)
;
do
{
if
(
&
current
-
>
Loader
(
)
!
=
&
aLoader
)
{
prev
=
current
;
current
=
current
-
>
mNext
;
continue
;
}
RefPtr
<
LoadingValue
>
strong
=
prev
?
std
:
:
move
(
prev
-
>
mNext
)
:
std
:
:
move
(
first
)
;
MOZ_ASSERT
(
strong
=
=
current
)
;
if
(
prev
)
{
prev
-
>
mNext
=
std
:
:
move
(
strong
-
>
mNext
)
;
current
=
prev
-
>
mNext
;
}
else
{
first
=
std
:
:
move
(
strong
-
>
mNext
)
;
current
=
first
;
}
arr
.
AppendElement
(
std
:
:
move
(
strong
)
)
;
}
while
(
current
)
;
if
(
!
first
)
{
iter
.
Remove
(
)
;
}
}
for
(
auto
&
loading
:
arr
)
{
loading
-
>
DidCancelLoad
(
)
;
}
}
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
WillStartPendingLoad
(
LoadingValue
&
aData
)
{
LoadingValue
*
curr
=
&
aData
;
do
{
curr
-
>
Loader
(
)
.
WillStartPendingLoad
(
)
;
}
while
(
(
curr
=
curr
-
>
mNext
)
)
;
}
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
CancelLoadsForLoader
(
Loader
&
aLoader
)
{
CancelPendingLoadsForLoader
(
aLoader
)
;
for
(
LoadingValue
*
data
:
mLoading
.
Values
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
data
"
We
weren
'
t
properly
notified
and
the
load
was
"
"
incorrectly
dropped
on
the
floor
"
)
;
for
(
;
data
;
data
=
data
-
>
mNext
)
{
if
(
&
data
-
>
Loader
(
)
=
=
&
aLoader
)
{
data
-
>
mIsCancelled
=
true
;
}
}
}
}
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
DeferLoad
(
const
Key
&
aKey
LoadingValue
&
aValue
)
{
MOZ_ASSERT
(
KeyFromLoadingValue
(
aValue
)
.
KeyEquals
(
aKey
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aValue
.
mNext
"
Should
only
defer
loads
once
"
)
;
mPending
.
InsertOrUpdate
(
aKey
RefPtr
{
&
aValue
}
)
;
}
template
<
typename
Traits
typename
Derived
>
template
<
typename
Callback
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
StartPendingLoadsForLoader
(
Loader
&
aLoader
const
Callback
&
aShouldStartLoad
)
{
AutoTArray
<
RefPtr
<
LoadingValue
>
10
>
arr
;
for
(
auto
iter
=
mPending
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
bool
startIt
=
false
;
{
LoadingValue
*
data
=
iter
.
Data
(
)
;
do
{
if
(
&
data
-
>
Loader
(
)
=
=
&
aLoader
)
{
if
(
aShouldStartLoad
(
*
data
)
)
{
startIt
=
true
;
break
;
}
}
}
while
(
(
data
=
data
-
>
mNext
)
)
;
}
if
(
startIt
)
{
arr
.
AppendElement
(
std
:
:
move
(
iter
.
Data
(
)
)
)
;
iter
.
Remove
(
)
;
}
}
for
(
auto
&
data
:
arr
)
{
WillStartPendingLoad
(
*
data
)
;
data
-
>
StartPendingLoad
(
)
;
}
}
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
Insert
(
LoadingValue
&
aValue
)
{
auto
key
=
KeyFromLoadingValue
(
aValue
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
for
(
const
auto
&
entry
:
mComplete
)
{
if
(
key
.
KeyEquals
(
entry
.
GetKey
(
)
)
)
{
MOZ_ASSERT
(
entry
.
GetData
(
)
.
Expired
(
)
|
|
aValue
.
Loader
(
)
.
ShouldBypassCache
(
)
"
Overriding
existing
complete
entry
?
"
)
;
}
}
#
endif
mComplete
.
InsertOrUpdate
(
key
CompleteSubResource
{
aValue
.
ExpirationTime
(
)
aValue
.
ValueForCache
(
)
}
)
;
}
template
<
typename
Traits
typename
Derived
>
bool
SharedSubResourceCache
<
Traits
Derived
>
:
:
CoalesceLoad
(
const
Key
&
aKey
LoadingValue
&
aNewLoad
CachedSubResourceState
aExistingLoadState
)
{
MOZ_ASSERT
(
KeyFromLoadingValue
(
aNewLoad
)
.
KeyEquals
(
aKey
)
)
;
LoadingValue
*
existingLoad
=
nullptr
;
if
(
aExistingLoadState
=
=
CachedSubResourceState
:
:
Loading
)
{
existingLoad
=
mLoading
.
Get
(
aKey
)
;
MOZ_ASSERT
(
existingLoad
"
Caller
lied
about
the
state
"
)
;
}
else
if
(
aExistingLoadState
=
=
CachedSubResourceState
:
:
Pending
)
{
existingLoad
=
mPending
.
GetWeak
(
aKey
)
;
MOZ_ASSERT
(
existingLoad
"
Caller
lied
about
the
state
"
)
;
}
if
(
!
existingLoad
)
{
return
false
;
}
if
(
aExistingLoadState
=
=
CachedSubResourceState
:
:
Pending
&
&
!
aNewLoad
.
ShouldDefer
(
)
)
{
RefPtr
<
LoadingValue
>
removedLoad
;
mPending
.
Remove
(
aKey
getter_AddRefs
(
removedLoad
)
)
;
MOZ_ASSERT
(
removedLoad
=
=
existingLoad
"
Bad
loading
table
"
)
;
WillStartPendingLoad
(
*
removedLoad
)
;
aNewLoad
.
mNext
=
std
:
:
move
(
removedLoad
)
;
return
false
;
}
LoadingValue
*
data
=
existingLoad
;
while
(
data
-
>
mNext
)
{
data
=
data
-
>
mNext
;
}
data
-
>
mNext
=
&
aNewLoad
;
return
true
;
}
template
<
typename
Traits
typename
Derived
>
auto
SharedSubResourceCache
<
Traits
Derived
>
:
:
Lookup
(
Loader
&
aLoader
const
Key
&
aKey
bool
aSyncLoad
)
-
>
Result
{
if
(
auto
lookup
=
mComplete
.
Lookup
(
aKey
)
)
{
const
CompleteSubResource
&
completeSubResource
=
lookup
.
Data
(
)
;
if
(
(
!
aLoader
.
ShouldBypassCache
(
)
&
&
!
completeSubResource
.
Expired
(
)
)
|
|
aLoader
.
HasLoaded
(
aKey
)
)
{
return
{
completeSubResource
.
mResource
.
get
(
)
nullptr
CachedSubResourceState
:
:
Complete
}
;
}
}
if
(
aSyncLoad
)
{
return
{
}
;
}
if
(
LoadingValue
*
data
=
mLoading
.
Get
(
aKey
)
)
{
return
{
nullptr
data
CachedSubResourceState
:
:
Loading
}
;
}
if
(
LoadingValue
*
data
=
mPending
.
GetWeak
(
aKey
)
)
{
return
{
nullptr
data
CachedSubResourceState
:
:
Pending
}
;
}
return
{
}
;
}
template
<
typename
Traits
typename
Derived
>
size_t
SharedSubResourceCache
<
Traits
Derived
>
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
&
AsDerived
(
)
)
;
n
+
=
mComplete
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
data
:
mComplete
.
Values
(
)
)
{
n
+
=
data
.
mResource
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
LoadStarted
(
const
Key
&
aKey
LoadingValue
&
aValue
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aValue
.
mIsLoading
"
Already
loading
?
How
?
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
KeyFromLoadingValue
(
aValue
)
.
KeyEquals
(
aKey
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mLoading
.
Contains
(
aKey
)
"
Load
not
coalesced
?
"
)
;
aValue
.
mIsLoading
=
true
;
mLoading
.
InsertOrUpdate
(
aKey
&
aValue
)
;
}
template
<
typename
Traits
typename
Derived
>
bool
SharedSubResourceCache
<
Traits
Derived
>
:
:
CompleteSubResource
:
:
Expired
(
)
const
{
return
mExpirationTime
&
&
mExpirationTime
<
=
nsContentUtils
:
:
SecondsFromPRTime
(
PR_Now
(
)
)
;
}
template
<
typename
Traits
typename
Derived
>
void
SharedSubResourceCache
<
Traits
Derived
>
:
:
LoadCompleted
(
LoadingValue
&
aValue
)
{
if
(
!
aValue
.
mIsLoading
)
{
return
;
}
auto
key
=
KeyFromLoadingValue
(
aValue
)
;
Maybe
<
LoadingValue
*
>
value
=
mLoading
.
Extract
(
key
)
;
MOZ_DIAGNOSTIC_ASSERT
(
value
)
;
MOZ_DIAGNOSTIC_ASSERT
(
value
.
value
(
)
=
=
&
aValue
)
;
Unused
<
<
value
;
aValue
.
mIsLoading
=
false
;
}
}
#
endif
