#
include
"
PreferenceSheet
.
h
"
#
include
"
ServoCSSParser
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_devtools
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsContentUtils
.
h
"
#
define
AVG2
(
a
b
)
(
(
(
a
)
+
(
b
)
+
1
)
>
>
1
)
namespace
mozilla
{
using
dom
:
:
Document
;
bool
PreferenceSheet
:
:
sInitialized
;
PreferenceSheet
:
:
Prefs
PreferenceSheet
:
:
sContentPrefs
;
PreferenceSheet
:
:
Prefs
PreferenceSheet
:
:
sChromePrefs
;
PreferenceSheet
:
:
Prefs
PreferenceSheet
:
:
sPrintPrefs
;
static
void
GetColor
(
const
char
*
aPrefName
ColorScheme
aColorScheme
nscolor
&
aColor
)
{
nsAutoCString
darkPrefName
;
if
(
aColorScheme
=
=
ColorScheme
:
:
Dark
)
{
darkPrefName
.
Append
(
aPrefName
)
;
darkPrefName
.
AppendLiteral
(
"
.
dark
"
)
;
aPrefName
=
darkPrefName
.
get
(
)
;
}
nsAutoCString
value
;
Preferences
:
:
GetCString
(
aPrefName
value
)
;
if
(
value
.
IsEmpty
(
)
|
|
Encoding
:
:
UTF8ValidUpTo
(
value
)
!
=
value
.
Length
(
)
)
{
return
;
}
nscolor
result
;
if
(
!
ServoCSSParser
:
:
ComputeColor
(
nullptr
NS_RGB
(
0
0
0
)
value
&
result
)
)
{
return
;
}
aColor
=
result
;
}
auto
PreferenceSheet
:
:
PrefsKindFor
(
const
Document
&
aDoc
)
-
>
PrefsKind
{
if
(
aDoc
.
IsInChromeDocShell
(
)
)
{
return
PrefsKind
:
:
Chrome
;
}
if
(
aDoc
.
IsBeingUsedAsImage
(
)
&
&
aDoc
.
ChromeRulesEnabled
(
)
)
{
return
PrefsKind
:
:
Chrome
;
}
if
(
aDoc
.
IsStaticDocument
(
)
)
{
return
PrefsKind
:
:
Print
;
}
return
PrefsKind
:
:
Content
;
}
static
bool
UseDocumentColors
(
bool
aUseAcccessibilityTheme
)
{
switch
(
StaticPrefs
:
:
browser_display_document_color_use
(
)
)
{
case
1
:
return
true
;
case
2
:
return
false
;
default
:
return
!
aUseAcccessibilityTheme
;
}
}
static
bool
UseStandinsForNativeColors
(
)
{
return
nsContentUtils
:
:
ShouldResistFingerprinting
(
"
we
want
to
have
consistent
colors
across
the
browser
if
RFP
is
"
"
enabled
so
we
check
the
global
preference
"
"
not
excluding
chrome
browsers
or
webpages
so
we
call
the
legacy
"
"
RFP
function
to
prevent
that
"
RFPTarget
:
:
UseStandinsForNativeColors
)
|
|
StaticPrefs
:
:
ui_use_standins_for_native_colors
(
)
;
}
void
PreferenceSheet
:
:
Prefs
:
:
LoadColors
(
bool
aIsLight
)
{
auto
&
colors
=
aIsLight
?
mLightColors
:
mDarkColors
;
if
(
!
aIsLight
)
{
std
:
:
swap
(
colors
.
mDefault
colors
.
mDefaultBackground
)
;
}
const
auto
scheme
=
aIsLight
?
ColorScheme
:
:
Light
:
ColorScheme
:
:
Dark
;
GetColor
(
"
browser
.
anchor_color
"
scheme
colors
.
mLink
)
;
GetColor
(
"
browser
.
active_color
"
scheme
colors
.
mActiveLink
)
;
GetColor
(
"
browser
.
visited_color
"
scheme
colors
.
mVisitedLink
)
;
if
(
mUsePrefColors
&
&
!
mUseStandins
)
{
GetColor
(
"
browser
.
display
.
background_color
"
scheme
colors
.
mDefaultBackground
)
;
GetColor
(
"
browser
.
display
.
foreground_color
"
scheme
colors
.
mDefault
)
;
}
else
{
using
ColorID
=
LookAndFeel
:
:
ColorID
;
const
auto
standins
=
LookAndFeel
:
:
UseStandins
(
mUseStandins
)
;
colors
.
mDefault
=
LookAndFeel
:
:
Color
(
ColorID
:
:
Windowtext
scheme
standins
colors
.
mDefault
)
;
colors
.
mDefaultBackground
=
LookAndFeel
:
:
Color
(
ColorID
:
:
Window
scheme
standins
colors
.
mDefaultBackground
)
;
colors
.
mLink
=
LookAndFeel
:
:
Color
(
ColorID
:
:
MozNativehyperlinktext
scheme
standins
colors
.
mLink
)
;
if
(
auto
color
=
LookAndFeel
:
:
GetColor
(
ColorID
:
:
MozNativevisitedhyperlinktext
scheme
standins
)
)
{
colors
.
mVisitedLink
=
*
color
;
}
else
if
(
mUseAccessibilityTheme
)
{
colors
.
mVisitedLink
=
NS_RGB
(
AVG2
(
NS_GET_R
(
colors
.
mDefault
)
NS_GET_R
(
colors
.
mDefaultBackground
)
)
NS_GET_G
(
colors
.
mDefault
)
AVG2
(
NS_GET_B
(
colors
.
mDefault
)
NS_GET_B
(
colors
.
mDefaultBackground
)
)
)
;
}
else
{
}
if
(
mUseAccessibilityTheme
)
{
colors
.
mActiveLink
=
colors
.
mLink
;
}
}
colors
.
mDefaultBackground
=
NS_ComposeColors
(
NS_RGB
(
0xFF
0xFF
0xFF
)
colors
.
mDefaultBackground
)
;
}
bool
PreferenceSheet
:
:
Prefs
:
:
NonNativeThemeShouldBeHighContrast
(
)
const
{
return
StaticPrefs
:
:
widget_non_native_theme_always_high_contrast
(
)
|
|
!
mUseDocumentColors
;
}
auto
PreferenceSheet
:
:
ColorSchemeSettingForChrome
(
)
-
>
ChromeColorSchemeSetting
{
switch
(
StaticPrefs
:
:
browser_theme_toolbar_theme
(
)
)
{
case
0
:
return
ChromeColorSchemeSetting
:
:
Dark
;
case
1
:
return
ChromeColorSchemeSetting
:
:
Light
;
default
:
return
ChromeColorSchemeSetting
:
:
System
;
}
}
ColorScheme
PreferenceSheet
:
:
ThemeDerivedColorSchemeForContent
(
)
{
switch
(
StaticPrefs
:
:
browser_theme_content_theme
(
)
)
{
case
0
:
return
ColorScheme
:
:
Dark
;
case
1
:
return
ColorScheme
:
:
Light
;
default
:
return
LookAndFeel
:
:
SystemColorScheme
(
)
;
}
}
void
PreferenceSheet
:
:
Prefs
:
:
Load
(
bool
aIsChrome
)
{
*
this
=
{
}
;
mIsChrome
=
aIsChrome
;
mUseAccessibilityTheme
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
UseAccessibilityTheme
)
;
if
(
!
aIsChrome
)
{
mUseDocumentColors
=
UseDocumentColors
(
mUseAccessibilityTheme
)
;
mUsePrefColors
=
!
StaticPrefs
:
:
browser_display_use_system_colors
(
)
;
mUseStandins
=
UseStandinsForNativeColors
(
)
;
}
LoadColors
(
true
)
;
LoadColors
(
false
)
;
mMustUseLightColorSet
=
mUsePrefColors
&
&
!
mUseDocumentColors
;
#
ifdef
XP_WIN
if
(
mUseAccessibilityTheme
&
&
!
mUseDocumentColors
)
{
mMustUseLightSystemColors
=
mMustUseLightColorSet
=
true
;
}
#
endif
mColorScheme
=
[
&
]
{
if
(
aIsChrome
)
{
switch
(
ColorSchemeSettingForChrome
(
)
)
{
case
ChromeColorSchemeSetting
:
:
Light
:
return
ColorScheme
:
:
Light
;
case
ChromeColorSchemeSetting
:
:
Dark
:
return
ColorScheme
:
:
Dark
;
case
ChromeColorSchemeSetting
:
:
System
:
break
;
}
return
LookAndFeel
:
:
SystemColorScheme
(
)
;
}
if
(
mMustUseLightColorSet
)
{
return
LookAndFeel
:
:
IsDarkColor
(
mLightColors
.
mDefaultBackground
)
?
ColorScheme
:
:
Dark
:
ColorScheme
:
:
Light
;
}
switch
(
StaticPrefs
:
:
layout_css_prefers_color_scheme_content_override
(
)
)
{
case
0
:
return
ColorScheme
:
:
Dark
;
case
1
:
return
ColorScheme
:
:
Light
;
default
:
return
ThemeDerivedColorSchemeForContent
(
)
;
}
}
(
)
;
}
void
PreferenceSheet
:
:
Initialize
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sInitialized
)
;
sInitialized
=
true
;
sContentPrefs
.
Load
(
false
)
;
sChromePrefs
.
Load
(
true
)
;
sPrintPrefs
=
sContentPrefs
;
{
sPrintPrefs
.
mColorScheme
=
ColorScheme
:
:
Light
;
if
(
!
sPrintPrefs
.
mUseDocumentColors
)
{
sPrintPrefs
.
mLightColors
=
Prefs
(
)
.
mLightColors
;
sPrintPrefs
.
mUseStandins
=
true
;
}
}
nsAutoString
useDocumentColorPref
;
switch
(
StaticPrefs
:
:
browser_display_document_color_use
(
)
)
{
case
1
:
useDocumentColorPref
.
AssignLiteral
(
"
always
"
)
;
break
;
case
2
:
useDocumentColorPref
.
AssignLiteral
(
"
never
"
)
;
break
;
default
:
useDocumentColorPref
.
AssignLiteral
(
"
default
"
)
;
break
;
}
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
A11Y_THEME
useDocumentColorPref
sContentPrefs
.
mUseAccessibilityTheme
)
;
if
(
!
sContentPrefs
.
mUseDocumentColors
)
{
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
A11Y_HCM_FOREGROUND
sContentPrefs
.
mLightColors
.
mDefault
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
A11Y_HCM_BACKGROUND
sContentPrefs
.
mLightColors
.
mDefaultBackground
)
;
}
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
A11Y_BACKPLATE
StaticPrefs
:
:
browser_display_permit_backplate
(
)
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
A11Y_USE_SYSTEM_COLORS
StaticPrefs
:
:
browser_display_use_system_colors
(
)
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
A11Y_ALWAYS_UNDERLINE_LINKS
StaticPrefs
:
:
layout_css_always_underline_links
(
)
)
;
}
bool
PreferenceSheet
:
:
AffectedByPref
(
const
nsACString
&
aPref
)
{
const
char
*
prefNames
[
]
=
{
StaticPrefs
:
:
GetPrefName_privacy_resistFingerprinting
(
)
StaticPrefs
:
:
GetPrefName_ui_use_standins_for_native_colors
(
)
"
browser
.
anchor_color
"
"
browser
.
active_color
"
"
browser
.
visited_color
"
}
;
if
(
StringBeginsWith
(
aPref
"
browser
.
display
.
"
_ns
)
)
{
return
true
;
}
for
(
const
char
*
pref
:
prefNames
)
{
if
(
aPref
.
Equals
(
pref
)
)
{
return
true
;
}
}
return
false
;
}
}
#
undef
AVG2
