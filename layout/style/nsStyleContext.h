#
ifndef
_nsStyleContext_h_
#
define
_nsStyleContext_h_
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RestyleLogging
.
h
"
#
include
"
mozilla
/
StyleContextSource
.
h
"
#
include
"
nsStyleSet
.
h
"
class
nsIAtom
;
class
nsPresContext
;
namespace
mozilla
{
enum
class
CSSPseudoElementType
:
uint8_t
;
}
class
nsStyleContext
final
{
public
:
nsStyleContext
(
nsStyleContext
*
aParent
nsIAtom
*
aPseudoTag
mozilla
:
:
CSSPseudoElementType
aPseudoType
already_AddRefed
<
nsRuleNode
>
aRuleNode
bool
aSkipParentDisplayBasedStyleFixup
)
;
nsStyleContext
(
nsStyleContext
*
aParent
nsPresContext
*
aPresContext
nsIAtom
*
aPseudoTag
mozilla
:
:
CSSPseudoElementType
aPseudoType
already_AddRefed
<
ServoComputedValues
>
aComputedValues
bool
aSkipParentDisplayBasedStyleFixup
)
;
void
*
operator
new
(
size_t
sz
nsPresContext
*
aPresContext
)
CPP_THROW_NEW
;
void
Destroy
(
)
;
static
mozilla
:
:
ArenaObjectID
ArenaObjectID
(
)
{
return
mozilla
:
:
eArenaObjectID_nsStyleContext
;
}
nsIPresShell
*
Arena
(
)
;
#
ifdef
DEBUG
static
void
Initialize
(
)
;
#
endif
nsrefcnt
AddRef
(
)
{
if
(
mRefCnt
=
=
UINT32_MAX
)
{
NS_WARNING
(
"
refcount
overflow
leaking
object
"
)
;
return
mRefCnt
;
}
+
+
mRefCnt
;
NS_LOG_ADDREF
(
this
mRefCnt
"
nsStyleContext
"
sizeof
(
nsStyleContext
)
)
;
return
mRefCnt
;
}
nsrefcnt
Release
(
)
{
if
(
mRefCnt
=
=
UINT32_MAX
)
{
NS_WARNING
(
"
refcount
overflow
leaking
object
"
)
;
return
mRefCnt
;
}
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
mRefCnt
"
nsStyleContext
"
)
;
if
(
mRefCnt
=
=
0
)
{
Destroy
(
)
;
return
0
;
}
return
mRefCnt
;
}
#
ifdef
DEBUG
void
FrameAddRef
(
)
{
+
+
mFrameRefCnt
;
}
void
FrameRelease
(
)
{
-
-
mFrameRefCnt
;
}
uint32_t
FrameRefCnt
(
)
const
{
return
mFrameRefCnt
;
}
#
endif
bool
HasSingleReference
(
)
const
{
NS_ASSERTION
(
mRefCnt
!
=
0
"
do
not
call
HasSingleReference
on
a
newly
created
"
"
nsStyleContext
with
no
references
yet
"
)
;
return
mRefCnt
=
=
1
;
}
nsPresContext
*
PresContext
(
)
const
{
#
ifdef
MOZ_STYLO
return
mPresContext
;
#
else
return
mSource
.
AsGeckoRuleNode
(
)
-
>
PresContext
(
)
;
#
endif
}
nsStyleContext
*
GetParent
(
)
const
{
return
mParent
;
}
nsIAtom
*
GetPseudo
(
)
const
{
return
mPseudoTag
;
}
mozilla
:
:
CSSPseudoElementType
GetPseudoType
(
)
const
{
return
static_cast
<
mozilla
:
:
CSSPseudoElementType
>
(
mBits
>
>
NS_STYLE_CONTEXT_TYPE_SHIFT
)
;
}
already_AddRefed
<
nsStyleContext
>
FindChildWithRules
(
const
nsIAtom
*
aPseudoTag
mozilla
:
:
NonOwningStyleContextSource
aSource
mozilla
:
:
NonOwningStyleContextSource
aSourceIfVisited
bool
aRelevantLinkVisited
)
;
nsCSSProperty
GetTextFillColorProp
(
)
{
return
StyleText
(
)
-
>
mWebkitTextFillColorForeground
?
eCSSProperty_color
:
eCSSProperty__webkit_text_fill_color
;
}
nscolor
GetTextFillColor
(
)
{
return
(
GetTextFillColorProp
(
)
=
=
eCSSProperty_color
)
?
StyleColor
(
)
-
>
mColor
:
StyleText
(
)
-
>
mWebkitTextFillColor
;
}
nscolor
GetTextStrokeColor
(
)
{
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
return
textStyle
-
>
mWebkitTextStrokeColorForeground
?
StyleColor
(
)
-
>
mColor
:
textStyle
-
>
mWebkitTextStrokeColor
;
}
bool
HasTextDecorationLines
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_HAS_TEXT_DECORATION_LINES
)
;
}
bool
ShouldSuppressLineBreak
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_SUPPRESS_LINEBREAK
)
;
}
bool
IsInDisplayNoneSubtree
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
)
;
}
bool
IsTextCombined
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IS_TEXT_COMBINED
)
;
}
bool
HasPseudoElementData
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
)
;
}
bool
HasChildThatUsesResetStyle
(
)
const
{
return
mBits
&
NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE
;
}
bool
RelevantLinkVisited
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_RELEVANT_LINK_VISITED
)
;
}
bool
IsLinkContext
(
)
const
{
return
GetStyleIfVisited
(
)
&
&
GetStyleIfVisited
(
)
-
>
GetParent
(
)
=
=
GetParent
(
)
;
}
bool
IsStyleIfVisited
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IS_STYLE_IF_VISITED
)
;
}
void
SetIsStyleIfVisited
(
)
{
mBits
|
=
NS_STYLE_IS_STYLE_IF_VISITED
;
}
nsStyleContext
*
GetStyleIfVisited
(
)
const
{
return
mStyleIfVisited
;
}
void
SetStyleIfVisited
(
already_AddRefed
<
nsStyleContext
>
aStyleIfVisited
)
{
MOZ_ASSERT
(
!
IsStyleIfVisited
(
)
"
this
context
is
not
visited
data
"
)
;
NS_ASSERTION
(
!
mStyleIfVisited
"
should
only
be
set
once
"
)
;
mStyleIfVisited
=
aStyleIfVisited
;
MOZ_ASSERT
(
mStyleIfVisited
-
>
IsStyleIfVisited
(
)
"
other
context
is
visited
data
"
)
;
MOZ_ASSERT
(
!
mStyleIfVisited
-
>
GetStyleIfVisited
(
)
"
other
context
does
not
have
visited
data
"
)
;
NS_ASSERTION
(
GetStyleIfVisited
(
)
-
>
GetPseudo
(
)
=
=
GetPseudo
(
)
"
pseudo
tag
mismatch
"
)
;
if
(
GetParent
(
)
&
&
GetParent
(
)
-
>
GetStyleIfVisited
(
)
)
{
NS_ASSERTION
(
GetStyleIfVisited
(
)
-
>
GetParent
(
)
=
=
GetParent
(
)
-
>
GetStyleIfVisited
(
)
|
|
GetStyleIfVisited
(
)
-
>
GetParent
(
)
=
=
GetParent
(
)
"
parent
mismatch
"
)
;
}
else
{
NS_ASSERTION
(
GetStyleIfVisited
(
)
-
>
GetParent
(
)
=
=
GetParent
(
)
"
parent
mismatch
"
)
;
}
}
bool
HasChildThatUsesGrandancestorStyle
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE
)
;
}
bool
IsShared
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IS_SHARED
)
;
}
void
SetStyle
(
nsStyleStructID
aSID
void
*
aStruct
)
;
bool
HasCachedDependentStyleData
(
nsStyleStructID
aSID
)
{
return
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
;
}
nsRuleNode
*
RuleNode
(
)
{
MOZ_RELEASE_ASSERT
(
mSource
.
IsGeckoRuleNode
(
)
)
;
return
mSource
.
AsGeckoRuleNode
(
)
;
}
void
AddStyleBit
(
const
uint64_t
&
aBit
)
{
mBits
|
=
aBit
;
}
const
void
*
NS_FASTCALL
StyleData
(
nsStyleStructID
aSID
)
;
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
const
nsStyle
#
#
name_
*
Style
#
#
name_
(
)
{
\
return
DoGetStyle
#
#
name_
<
true
>
(
)
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
const
nsStyle
#
#
name_
*
PeekStyle
#
#
name_
(
)
{
\
return
DoGetStyle
#
#
name_
<
false
>
(
)
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
nsChangeHint
CalcStyleDifference
(
nsStyleContext
*
aNewContext
nsChangeHint
aParentHintsNotHandledForDescendants
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
;
#
ifdef
MOZ_STYLO
nsChangeHint
CalcStyleDifference
(
ServoComputedValues
*
aNewComputedValues
nsChangeHint
aParentHintsNotHandledForDescendants
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
;
#
endif
private
:
template
<
class
StyleContextLike
>
nsChangeHint
CalcStyleDifferenceInternal
(
StyleContextLike
*
aNewContext
nsChangeHint
aParentHintsNotHandledForDescendants
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
;
public
:
nscolor
GetVisitedDependentColor
(
nsCSSProperty
aProperty
)
;
static
nscolor
CombineVisitedColors
(
nscolor
*
aColors
bool
aLinkIsVisited
)
;
void
StartBackgroundImageLoads
(
)
{
StyleBackground
(
)
;
}
void
MoveTo
(
nsStyleContext
*
aNewParent
)
;
void
SwapStyleData
(
nsStyleContext
*
aNewContext
uint32_t
aStructs
)
;
void
ClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
;
void
SetIneligibleForSharing
(
)
;
#
ifdef
DEBUG
void
List
(
FILE
*
out
int32_t
aIndent
bool
aListDescendants
=
true
)
;
static
void
AssertStyleStructMaxDifferenceValid
(
)
;
static
const
char
*
StructName
(
nsStyleStructID
aSID
)
;
static
bool
LookupStruct
(
const
nsACString
&
aName
nsStyleStructID
&
aResult
)
;
#
endif
#
ifdef
RESTYLE_LOGGING
nsCString
GetCachedStyleDataAsString
(
uint32_t
aStructs
)
;
void
LogStyleContextTree
(
int32_t
aLoggingDepth
uint32_t
aStructs
)
;
int32_t
&
LoggingDepth
(
)
;
#
endif
const
void
*
GetCachedStyleData
(
nsStyleStructID
aSID
)
{
const
void
*
cachedData
;
if
(
nsCachedStyleData
:
:
IsReset
(
aSID
)
)
{
if
(
mCachedResetData
)
{
cachedData
=
mCachedResetData
-
>
mStyleStructs
[
aSID
]
;
}
else
{
cachedData
=
nullptr
;
}
}
else
{
cachedData
=
mCachedInheritedData
.
mStyleStructs
[
aSID
]
;
}
return
cachedData
;
}
mozilla
:
:
NonOwningStyleContextSource
StyleSource
(
)
const
{
return
mSource
.
AsRaw
(
)
;
}
#
ifdef
MOZ_STYLO
void
StoreChangeHint
(
nsChangeHint
aHint
)
{
MOZ_ASSERT
(
!
mHasStoredChangeHint
)
;
MOZ_ASSERT
(
!
IsShared
(
)
)
;
mStoredChangeHint
=
aHint
;
#
ifdef
DEBUG
mHasStoredChangeHint
=
true
;
#
endif
}
nsChangeHint
ConsumeStoredChangeHint
(
)
{
MOZ_ASSERT
(
mHasStoredChangeHint
)
;
nsChangeHint
result
=
mStoredChangeHint
;
mStoredChangeHint
=
nsChangeHint
(
0
)
;
#
ifdef
DEBUG
mHasStoredChangeHint
=
false
;
#
endif
return
result
;
}
#
endif
private
:
~
nsStyleContext
(
)
;
nsStyleContext
(
nsStyleContext
*
aParent
mozilla
:
:
OwningStyleContextSource
&
&
aSource
nsIAtom
*
aPseudoTag
mozilla
:
:
CSSPseudoElementType
aPseudoType
)
;
void
FinishConstruction
(
bool
aSkipParentDisplayBasedStyleFixup
)
;
void
AddChild
(
nsStyleContext
*
aChild
)
;
void
RemoveChild
(
nsStyleContext
*
aChild
)
;
void
*
GetUniqueStyleData
(
const
nsStyleStructID
&
aSID
)
;
void
*
CreateEmptyStyleData
(
const
nsStyleStructID
&
aSID
)
;
void
SetStyleBits
(
)
;
void
ApplyStyleFixups
(
bool
aSkipParentDisplayBasedStyleFixup
)
;
const
void
*
StyleStructFromServoComputedValues
(
nsStyleStructID
aSID
)
{
switch
(
aSID
)
{
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
case
eStyleStruct_
#
#
name_
:
\
return
Servo_GetStyle
#
#
name_
(
mSource
.
AsServoComputedValues
(
)
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
nsStyleStructID
value
"
)
;
return
nullptr
;
}
}
#
ifdef
DEBUG
struct
AutoCheckDependency
{
nsStyleContext
*
mStyleContext
;
nsStyleStructID
mOuterSID
;
AutoCheckDependency
(
nsStyleContext
*
aContext
nsStyleStructID
aInnerSID
)
:
mStyleContext
(
aContext
)
{
mOuterSID
=
aContext
-
>
mComputingStruct
;
MOZ_ASSERT
(
mOuterSID
=
=
nsStyleStructID_None
|
|
DependencyAllowed
(
mOuterSID
aInnerSID
)
"
Undeclared
dependency
see
generate
-
stylestructlist
.
py
"
)
;
aContext
-
>
mComputingStruct
=
aInnerSID
;
}
~
AutoCheckDependency
(
)
{
mStyleContext
-
>
mComputingStruct
=
mOuterSID
;
}
}
;
#
define
AUTO_CHECK_DEPENDENCY
(
sid_
)
\
AutoCheckDependency
checkNesting_
(
this
sid_
)
#
else
#
define
AUTO_CHECK_DEPENDENCY
(
sid_
)
#
endif
#
define
STYLE_STRUCT_INHERITED
(
name_
checkdata_cb_
)
\
template
<
bool
aComputeData
>
\
const
nsStyle
#
#
name_
*
DoGetStyle
#
#
name_
(
)
{
\
const
nsStyle
#
#
name_
*
cachedData
=
\
static_cast
<
nsStyle
#
#
name_
*
>
(
\
mCachedInheritedData
.
mStyleStructs
[
eStyleStruct_
#
#
name_
]
)
;
\
if
(
cachedData
)
/
*
Have
it
cached
already
yay
*
/
\
return
cachedData
;
\
if
(
!
aComputeData
)
{
\
/
*
We
always
cache
inherited
structs
on
the
context
when
we
*
/
\
/
*
compute
them
.
*
/
\
return
nullptr
;
\
}
\
/
*
Have
the
rulenode
deal
*
/
\
AUTO_CHECK_DEPENDENCY
(
eStyleStruct_
#
#
name_
)
;
\
const
nsStyle
#
#
name_
*
newData
;
\
if
(
mSource
.
IsGeckoRuleNode
(
)
)
{
\
newData
=
mSource
.
AsGeckoRuleNode
(
)
-
>
\
GetStyle
#
#
name_
<
aComputeData
>
(
this
mBits
)
;
\
}
else
{
\
newData
=
\
Servo_GetStyle
#
#
name_
(
mSource
.
AsServoComputedValues
(
)
)
;
\
/
*
the
Servo
-
backed
StyleContextSource
owns
the
struct
*
/
\
AddStyleBit
(
NS_STYLE_INHERIT_BIT
(
name_
)
)
;
\
}
\
/
*
always
cache
inherited
data
on
the
style
context
;
the
rule
*
/
\
/
*
node
set
the
bit
in
mBits
for
us
if
needed
.
*
/
\
mCachedInheritedData
.
mStyleStructs
[
eStyleStruct_
#
#
name_
]
=
\
const_cast
<
nsStyle
#
#
name_
*
>
(
newData
)
;
\
return
newData
;
\
}
#
define
STYLE_STRUCT_RESET
(
name_
checkdata_cb_
)
\
template
<
bool
aComputeData
>
\
const
nsStyle
#
#
name_
*
DoGetStyle
#
#
name_
(
)
{
\
if
(
mCachedResetData
)
{
\
const
nsStyle
#
#
name_
*
cachedData
=
\
static_cast
<
nsStyle
#
#
name_
*
>
(
\
mCachedResetData
-
>
mStyleStructs
[
eStyleStruct_
#
#
name_
]
)
;
\
if
(
cachedData
)
/
*
Have
it
cached
already
yay
*
/
\
return
cachedData
;
\
}
\
/
*
Have
the
rulenode
deal
*
/
\
AUTO_CHECK_DEPENDENCY
(
eStyleStruct_
#
#
name_
)
;
\
const
nsStyle
#
#
name_
*
newData
;
\
if
(
mSource
.
IsGeckoRuleNode
(
)
)
{
\
newData
=
mSource
.
AsGeckoRuleNode
(
)
-
>
\
GetStyle
#
#
name_
<
aComputeData
>
(
this
)
;
\
}
else
{
\
newData
=
\
Servo_GetStyle
#
#
name_
(
mSource
.
AsServoComputedValues
(
)
)
;
\
/
*
The
Servo
-
backed
StyleContextSource
owns
the
struct
.
\
*
\
*
XXXbholley
:
Unconditionally
caching
reset
structs
here
\
*
defeats
the
memory
optimization
where
we
lazily
allocate
\
*
mCachedResetData
so
that
we
can
avoid
performing
an
FFI
\
*
call
each
time
we
want
to
get
the
style
structs
.
We
should
\
*
measure
the
tradeoffs
at
some
point
.
If
the
FFI
overhead
is
\
*
low
and
the
memory
win
significant
we
should
consider
\
*
_always_
grabbing
the
struct
over
FFI
and
potentially
\
*
giving
mCachedInheritedData
the
same
treatment
.
\
*
\
*
Note
that
there
is
a
similar
comment
in
StyleData
(
)
.
\
*
/
\
AddStyleBit
(
NS_STYLE_INHERIT_BIT
(
name_
)
)
;
\
SetStyle
(
eStyleStruct_
#
#
name_
\
const_cast
<
nsStyle
#
#
name_
*
>
(
newData
)
)
;
\
}
\
return
newData
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT_RESET
#
undef
STYLE_STRUCT_INHERITED
void
DoClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
;
#
ifdef
DEBUG
void
AssertStructsNotUsedElsewhere
(
nsStyleContext
*
aDestroyingContext
int32_t
aLevels
)
const
;
#
endif
#
ifdef
RESTYLE_LOGGING
void
LogStyleContextTree
(
bool
aFirst
uint32_t
aStructs
)
;
bool
ShouldLogRestyle
(
)
{
return
true
;
}
#
endif
RefPtr
<
nsStyleContext
>
mParent
;
nsStyleContext
*
mChild
;
nsStyleContext
*
mEmptyChild
;
nsStyleContext
*
mPrevSibling
;
nsStyleContext
*
mNextSibling
;
RefPtr
<
nsStyleContext
>
mStyleIfVisited
;
nsCOMPtr
<
nsIAtom
>
mPseudoTag
;
const
mozilla
:
:
OwningStyleContextSource
mSource
;
#
ifdef
MOZ_STYLO
nsPresContext
*
mPresContext
;
#
endif
nsResetStyleData
*
mCachedResetData
;
nsInheritedStyleData
mCachedInheritedData
;
uint64_t
mBits
;
uint32_t
mRefCnt
;
#
ifdef
MOZ_STYLO
nsChangeHint
mStoredChangeHint
;
#
ifdef
DEBUG
bool
mHasStoredChangeHint
;
#
endif
#
endif
#
ifdef
DEBUG
uint32_t
mFrameRefCnt
;
nsStyleStructID
mComputingStruct
;
static
bool
DependencyAllowed
(
nsStyleStructID
aOuterSID
nsStyleStructID
aInnerSID
)
{
return
!
!
(
sDependencyTable
[
aOuterSID
]
&
nsCachedStyleData
:
:
GetBitForSID
(
aInnerSID
)
)
;
}
static
const
uint32_t
sDependencyTable
[
]
;
#
endif
}
;
already_AddRefed
<
nsStyleContext
>
NS_NewStyleContext
(
nsStyleContext
*
aParentContext
nsIAtom
*
aPseudoTag
mozilla
:
:
CSSPseudoElementType
aPseudoType
nsRuleNode
*
aRuleNode
bool
aSkipParentDisplayBasedStyleFixup
)
;
already_AddRefed
<
nsStyleContext
>
NS_NewStyleContext
(
nsStyleContext
*
aParentContext
nsPresContext
*
aPresContext
nsIAtom
*
aPseudoTag
mozilla
:
:
CSSPseudoElementType
aPseudoType
already_AddRefed
<
ServoComputedValues
>
aComputedValues
bool
aSkipParentDisplayBasedStyleFixup
)
;
#
endif
