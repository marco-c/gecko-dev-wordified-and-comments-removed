#
ifndef
_nsStyleContext_h_
#
define
_nsStyleContext_h_
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RestyleLogging
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
StyleComplexColor
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsStyleSet
.
h
"
class
nsIAtom
;
class
nsPresContext
;
namespace
mozilla
{
enum
class
CSSPseudoElementType
:
uint8_t
;
class
GeckoStyleContext
;
class
ServoStyleContext
;
}
extern
"
C
"
{
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
struct
nsStyle
#
#
name_
;
\
const
nsStyle
#
#
name_
*
Servo_GetStyle
#
#
name_
(
\
ServoComputedValuesBorrowedOrNull
computed_values
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
}
class
nsStyleContext
{
public
:
#
ifdef
MOZ_STYLO
bool
IsGecko
(
)
const
{
return
!
IsServo
(
)
;
}
bool
IsServo
(
)
const
{
return
(
mBits
&
NS_STYLE_CONTEXT_IS_GECKO
)
=
=
0
;
}
#
else
bool
IsGecko
(
)
const
{
return
true
;
}
bool
IsServo
(
)
const
{
return
false
;
}
#
endif
MOZ_DECL_STYLO_CONVERT_METHODS
(
mozilla
:
:
GeckoStyleContext
mozilla
:
:
ServoStyleContext
)
;
void
Destroy
(
)
;
static
mozilla
:
:
ArenaObjectID
ArenaObjectID
(
)
{
return
mozilla
:
:
eArenaObjectID_GeckoStyleContext
;
}
nsIPresShell
*
Arena
(
)
;
#
ifdef
DEBUG
static
void
Initialize
(
)
;
#
endif
nsrefcnt
AddRef
(
)
{
if
(
mRefCnt
=
=
UINT32_MAX
)
{
NS_WARNING
(
"
refcount
overflow
leaking
object
"
)
;
return
mRefCnt
;
}
+
+
mRefCnt
;
NS_LOG_ADDREF
(
this
mRefCnt
"
nsStyleContext
"
sizeof
(
nsStyleContext
)
)
;
return
mRefCnt
;
}
nsrefcnt
Release
(
)
{
if
(
mRefCnt
=
=
UINT32_MAX
)
{
NS_WARNING
(
"
refcount
overflow
leaking
object
"
)
;
return
mRefCnt
;
}
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
mRefCnt
"
nsStyleContext
"
)
;
if
(
mRefCnt
=
=
0
)
{
Destroy
(
)
;
return
0
;
}
return
mRefCnt
;
}
#
ifdef
DEBUG
void
FrameAddRef
(
)
{
+
+
mFrameRefCnt
;
}
void
FrameRelease
(
)
{
-
-
mFrameRefCnt
;
}
uint32_t
FrameRefCnt
(
)
const
{
return
mFrameRefCnt
;
}
#
endif
bool
HasSingleReference
(
)
const
{
NS_ASSERTION
(
mRefCnt
!
=
0
"
do
not
call
HasSingleReference
on
a
newly
created
"
"
nsStyleContext
with
no
references
yet
"
)
;
return
mRefCnt
=
=
1
;
}
inline
nsPresContext
*
PresContext
(
)
const
;
inline
mozilla
:
:
GeckoStyleContext
*
GetParent
(
)
const
;
nsStyleContext
*
GetParentAllowServo
(
)
const
{
return
mParent
;
}
nsIAtom
*
GetPseudo
(
)
const
{
return
mPseudoTag
;
}
mozilla
:
:
CSSPseudoElementType
GetPseudoType
(
)
const
{
return
static_cast
<
mozilla
:
:
CSSPseudoElementType
>
(
mBits
>
>
NS_STYLE_CONTEXT_TYPE_SHIFT
)
;
}
bool
IsAnonBox
(
)
const
{
return
GetPseudoType
(
)
=
=
mozilla
:
:
CSSPseudoElementType
:
:
InheritingAnonBox
|
|
GetPseudoType
(
)
=
=
mozilla
:
:
CSSPseudoElementType
:
:
NonInheritingAnonBox
;
}
bool
IsPseudoElement
(
)
const
{
return
mPseudoTag
&
&
!
IsAnonBox
(
)
;
}
bool
HasTextDecorationLines
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_HAS_TEXT_DECORATION_LINES
)
;
}
bool
ShouldSuppressLineBreak
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_SUPPRESS_LINEBREAK
)
;
}
bool
IsInDisplayNoneSubtree
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
)
;
}
bool
IsTextCombined
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IS_TEXT_COMBINED
)
;
}
bool
HasPseudoElementData
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
)
;
}
bool
HasChildThatUsesResetStyle
(
)
const
{
return
mBits
&
NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE
;
}
bool
RelevantLinkVisited
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_RELEVANT_LINK_VISITED
)
;
}
inline
bool
IsLinkContext
(
)
const
;
bool
IsStyleIfVisited
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IS_STYLE_IF_VISITED
)
;
}
void
SetIsStyleIfVisited
(
)
{
mBits
|
=
NS_STYLE_IS_STYLE_IF_VISITED
;
}
nsStyleContext
*
GetStyleIfVisited
(
)
const
{
return
mStyleIfVisited
;
}
void
SetStyleIfVisited
(
already_AddRefed
<
nsStyleContext
>
aStyleIfVisited
)
{
MOZ_ASSERT
(
!
IsStyleIfVisited
(
)
"
this
context
is
not
visited
data
"
)
;
NS_ASSERTION
(
!
mStyleIfVisited
"
should
only
be
set
once
"
)
;
mStyleIfVisited
=
aStyleIfVisited
;
MOZ_ASSERT
(
mStyleIfVisited
-
>
IsStyleIfVisited
(
)
"
other
context
is
visited
data
"
)
;
MOZ_ASSERT
(
!
mStyleIfVisited
-
>
GetStyleIfVisited
(
)
"
other
context
does
not
have
visited
data
"
)
;
NS_ASSERTION
(
GetStyleIfVisited
(
)
-
>
GetPseudo
(
)
=
=
GetPseudo
(
)
"
pseudo
tag
mismatch
"
)
;
if
(
GetParentAllowServo
(
)
&
&
GetParentAllowServo
(
)
-
>
GetStyleIfVisited
(
)
)
{
NS_ASSERTION
(
GetStyleIfVisited
(
)
-
>
GetParentAllowServo
(
)
=
=
GetParentAllowServo
(
)
-
>
GetStyleIfVisited
(
)
|
|
GetStyleIfVisited
(
)
-
>
GetParentAllowServo
(
)
=
=
GetParentAllowServo
(
)
"
parent
mismatch
"
)
;
}
else
{
NS_ASSERTION
(
GetStyleIfVisited
(
)
-
>
GetParentAllowServo
(
)
=
=
GetParentAllowServo
(
)
"
parent
mismatch
"
)
;
}
}
bool
HasChildThatUsesGrandancestorStyle
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE
)
;
}
bool
IsShared
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IS_SHARED
)
;
}
bool
HasCachedDependentStyleData
(
nsStyleStructID
aSID
)
{
return
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
;
}
inline
nsRuleNode
*
RuleNode
(
)
;
inline
ServoComputedValues
*
ComputedValues
(
)
;
void
AddStyleBit
(
const
uint64_t
&
aBit
)
{
mBits
|
=
aBit
;
}
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
inline
const
nsStyle
#
#
name_
*
Style
#
#
name_
(
)
MOZ_NONNULL_RETURN
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
inline
const
nsStyle
#
#
name_
*
ThreadsafeStyle
#
#
name_
(
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
inline
const
nsStyle
#
#
name_
*
PeekStyle
#
#
name_
(
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
nsChangeHint
CalcStyleDifference
(
nsStyleContext
*
aNewContext
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
;
nsChangeHint
CalcStyleDifference
(
const
ServoComputedValues
*
aNewComputedValues
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
;
private
:
template
<
class
StyleContextLike
>
nsChangeHint
CalcStyleDifferenceInternal
(
StyleContextLike
*
aNewContext
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
;
public
:
void
EnsureSameStructsCached
(
nsStyleContext
*
aOldContext
)
;
template
<
typename
T
typename
S
>
nscolor
GetVisitedDependentColor
(
T
S
:
:
*
aField
)
;
static
nscolor
CombineVisitedColors
(
nscolor
*
aColors
bool
aLinkIsVisited
)
;
inline
void
StartBackgroundImageLoads
(
)
;
void
MoveTo
(
nsStyleContext
*
aNewParent
)
;
void
SwapStyleData
(
nsStyleContext
*
aNewContext
uint32_t
aStructs
)
;
#
ifdef
DEBUG
void
List
(
FILE
*
out
int32_t
aIndent
bool
aListDescendants
=
true
)
;
static
const
char
*
StructName
(
nsStyleStructID
aSID
)
;
static
bool
LookupStruct
(
const
nsACString
&
aName
nsStyleStructID
&
aResult
)
;
#
endif
#
ifdef
RESTYLE_LOGGING
nsCString
GetCachedStyleDataAsString
(
uint32_t
aStructs
)
;
void
LogStyleContextTree
(
int32_t
aLoggingDepth
uint32_t
aStructs
)
;
int32_t
&
LoggingDepth
(
)
;
#
endif
const
void
*
GetCachedStyleData
(
nsStyleStructID
aSID
)
{
const
void
*
cachedData
;
if
(
nsCachedStyleData
:
:
IsReset
(
aSID
)
)
{
if
(
mCachedResetData
)
{
cachedData
=
mCachedResetData
-
>
mStyleStructs
[
aSID
]
;
}
else
{
cachedData
=
nullptr
;
}
}
else
{
cachedData
=
mCachedInheritedData
.
mStyleStructs
[
aSID
]
;
}
return
cachedData
;
}
protected
:
~
nsStyleContext
(
)
{
}
void
Destructor
(
)
;
nsStyleContext
(
nsStyleContext
*
aParent
nsIAtom
*
aPseudoTag
mozilla
:
:
CSSPseudoElementType
aPseudoType
)
;
void
FinishConstruction
(
)
;
void
AddChild
(
nsStyleContext
*
aChild
)
;
void
RemoveChild
(
nsStyleContext
*
aChild
)
;
void
SetStyleBits
(
)
;
const
void
*
StyleStructFromServoComputedValues
(
nsStyleStructID
aSID
)
{
switch
(
aSID
)
{
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
case
eStyleStruct_
#
#
name_
:
\
return
Servo_GetStyle
#
#
name_
(
ComputedValues
(
)
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
nsStyleStructID
value
"
)
;
return
nullptr
;
}
}
#
ifdef
DEBUG
struct
AutoCheckDependency
{
nsStyleContext
*
mStyleContext
;
nsStyleStructID
mOuterSID
;
AutoCheckDependency
(
nsStyleContext
*
aContext
nsStyleStructID
aInnerSID
)
:
mStyleContext
(
aContext
)
{
mOuterSID
=
aContext
-
>
mComputingStruct
;
MOZ_ASSERT
(
mOuterSID
=
=
nsStyleStructID_None
|
|
DependencyAllowed
(
mOuterSID
aInnerSID
)
"
Undeclared
dependency
see
generate
-
stylestructlist
.
py
"
)
;
aContext
-
>
mComputingStruct
=
aInnerSID
;
}
~
AutoCheckDependency
(
)
{
mStyleContext
-
>
mComputingStruct
=
mOuterSID
;
}
}
;
#
define
AUTO_CHECK_DEPENDENCY
(
sid_
)
\
AutoCheckDependency
checkNesting_
(
this
sid_
)
#
else
#
define
AUTO_CHECK_DEPENDENCY
(
sid_
)
#
endif
#
define
STYLE_STRUCT_INHERITED
(
name_
checkdata_cb_
)
\
template
<
bool
aComputeData
>
\
const
nsStyle
#
#
name_
*
DoGetStyle
#
#
name_
(
)
;
#
define
STYLE_STRUCT_RESET
(
name_
checkdata_cb_
)
\
template
<
bool
aComputeData
>
\
const
nsStyle
#
#
name_
*
DoGetStyle
#
#
name_
(
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT_RESET
#
undef
STYLE_STRUCT_INHERITED
#
ifdef
DEBUG
void
AssertStructsNotUsedElsewhere
(
nsStyleContext
*
aDestroyingContext
int32_t
aLevels
)
const
;
#
endif
#
ifdef
RESTYLE_LOGGING
void
LogStyleContextTree
(
bool
aFirst
uint32_t
aStructs
)
;
bool
ShouldLogRestyle
(
)
{
return
true
;
}
#
endif
RefPtr
<
nsStyleContext
>
mParent
;
RefPtr
<
nsStyleContext
>
mStyleIfVisited
;
nsCOMPtr
<
nsIAtom
>
mPseudoTag
;
nsResetStyleData
*
mCachedResetData
;
nsInheritedStyleData
mCachedInheritedData
;
uint64_t
mBits
;
uint32_t
mRefCnt
;
#
ifdef
DEBUG
uint32_t
mFrameRefCnt
;
nsStyleStructID
mComputingStruct
;
static
bool
DependencyAllowed
(
nsStyleStructID
aOuterSID
nsStyleStructID
aInnerSID
)
{
return
!
!
(
sDependencyTable
[
aOuterSID
]
&
nsCachedStyleData
:
:
GetBitForSID
(
aInnerSID
)
)
;
}
static
const
uint32_t
sDependencyTable
[
]
;
#
endif
}
;
already_AddRefed
<
nsStyleContext
>
NS_NewStyleContext
(
nsStyleContext
*
aParentContext
nsIAtom
*
aPseudoTag
mozilla
:
:
CSSPseudoElementType
aPseudoType
nsRuleNode
*
aRuleNode
bool
aSkipParentDisplayBasedStyleFixup
)
;
already_AddRefed
<
nsStyleContext
>
NS_NewStyleContext
(
nsStyleContext
*
aParentContext
nsPresContext
*
aPresContext
nsIAtom
*
aPseudoTag
mozilla
:
:
CSSPseudoElementType
aPseudoType
already_AddRefed
<
ServoComputedValues
>
aComputedValues
)
;
#
endif
