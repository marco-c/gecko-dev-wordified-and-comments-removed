#
include
"
nsStyleTransformMatrix
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
nsCSSKeywords
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxQuaternion
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
namespace
nsStyleTransformMatrix
{
void
TransformReferenceBox
:
:
EnsureDimensionsAreCached
(
)
{
if
(
mIsCached
)
{
return
;
}
MOZ_ASSERT
(
mFrame
)
;
mIsCached
=
true
;
if
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
{
if
(
!
nsLayoutUtils
:
:
SVGTransformBoxEnabled
(
)
)
{
mX
=
-
mFrame
-
>
GetPosition
(
)
.
x
;
mY
=
-
mFrame
-
>
GetPosition
(
)
.
y
;
Size
contextSize
=
nsSVGUtils
:
:
GetContextSize
(
mFrame
)
;
mWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
width
)
;
mHeight
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
height
)
;
}
else
if
(
mFrame
-
>
StyleDisplay
(
)
-
>
mTransformBox
=
=
StyleGeometryBox
:
:
FillBox
)
{
nsRect
bboxInAppUnits
=
nsLayoutUtils
:
:
ComputeGeometryBox
(
const_cast
<
nsIFrame
*
>
(
mFrame
)
StyleGeometryBox
:
:
FillBox
)
;
mX
=
bboxInAppUnits
.
x
-
mFrame
-
>
GetPosition
(
)
.
x
;
mY
=
bboxInAppUnits
.
y
-
mFrame
-
>
GetPosition
(
)
.
y
;
mWidth
=
bboxInAppUnits
.
width
;
mHeight
=
bboxInAppUnits
.
height
;
}
else
{
MOZ_ASSERT
(
mFrame
-
>
StyleDisplay
(
)
-
>
mTransformBox
=
=
StyleGeometryBox
:
:
ViewBox
|
|
mFrame
-
>
StyleDisplay
(
)
-
>
mTransformBox
=
=
StyleGeometryBox
:
:
BorderBox
"
Unexpected
value
for
'
transform
-
box
'
"
)
;
mX
=
-
mFrame
-
>
GetPosition
(
)
.
x
;
mY
=
-
mFrame
-
>
GetPosition
(
)
.
y
;
Size
contextSize
=
nsSVGUtils
:
:
GetContextSize
(
mFrame
)
;
mWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
width
)
;
mHeight
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
height
)
;
}
return
;
}
nsRect
rect
;
#
ifndef
UNIFIED_CONTINUATIONS
rect
=
mFrame
-
>
GetRect
(
)
;
#
else
for
(
const
nsIFrame
*
currFrame
=
mFrame
-
>
FirstContinuation
(
)
;
currFrame
!
=
nullptr
;
currFrame
=
currFrame
-
>
GetNextContinuation
(
)
)
{
rect
.
UnionRect
(
result
nsRect
(
currFrame
-
>
GetOffsetTo
(
mFrame
)
currFrame
-
>
GetSize
(
)
)
)
;
}
#
endif
mX
=
0
;
mY
=
0
;
mWidth
=
rect
.
Width
(
)
;
mHeight
=
rect
.
Height
(
)
;
}
void
TransformReferenceBox
:
:
Init
(
const
nsSize
&
aDimensions
)
{
MOZ_ASSERT
(
!
mFrame
&
&
!
mIsCached
)
;
mX
=
0
;
mY
=
0
;
mWidth
=
aDimensions
.
width
;
mHeight
=
aDimensions
.
height
;
mIsCached
=
true
;
}
float
ProcessTranslatePart
(
const
nsCSSValue
&
aValue
TransformReferenceBox
*
aRefBox
TransformReferenceBox
:
:
DimensionGetter
aDimensionGetter
)
{
nscoord
offset
=
0
;
float
percent
=
0
.
0f
;
if
(
aValue
.
GetUnit
(
)
=
=
eCSSUnit_Percent
)
{
percent
=
aValue
.
GetPercentValue
(
)
;
}
else
if
(
aValue
.
GetUnit
(
)
=
=
eCSSUnit_Pixel
|
|
aValue
.
GetUnit
(
)
=
=
eCSSUnit_Number
)
{
return
aValue
.
GetFloatValue
(
)
;
}
else
if
(
aValue
.
IsCalcUnit
(
)
)
{
nsStyleCoord
:
:
CalcValue
calc
=
aValue
.
GetCalcValue
(
)
;
percent
=
calc
.
mPercent
;
offset
=
calc
.
mLength
;
}
else
{
MOZ_CRASH
(
"
unexpected
unit
in
ProcessTranslatePart
"
)
;
}
float
translation
=
NSAppUnitsToFloatPixels
(
offset
AppUnitsPerCSSPixel
(
)
)
;
if
(
percent
!
=
0
.
0f
&
&
aRefBox
&
&
!
aRefBox
-
>
IsEmpty
(
)
)
{
translation
+
=
percent
*
NSAppUnitsToFloatPixels
(
(
aRefBox
-
>
*
aDimensionGetter
)
(
)
AppUnitsPerCSSPixel
(
)
)
;
}
return
translation
;
}
static
void
ProcessMatrix
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
7
"
Invalid
array
!
"
)
;
gfxMatrix
result
;
result
.
_11
=
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
result
.
_12
=
aData
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
result
.
_21
=
aData
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
result
.
_22
=
aData
-
>
Item
(
4
)
.
GetFloatValue
(
)
;
result
.
_31
=
ProcessTranslatePart
(
aData
-
>
Item
(
5
)
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
result
.
_32
=
ProcessTranslatePart
(
aData
-
>
Item
(
6
)
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
aMatrix
=
result
*
aMatrix
;
}
static
void
ProcessMatrix3D
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
17
"
Invalid
array
!
"
)
;
Matrix4x4
temp
;
temp
.
_11
=
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
temp
.
_12
=
aData
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
temp
.
_13
=
aData
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
temp
.
_14
=
aData
-
>
Item
(
4
)
.
GetFloatValue
(
)
;
temp
.
_21
=
aData
-
>
Item
(
5
)
.
GetFloatValue
(
)
;
temp
.
_22
=
aData
-
>
Item
(
6
)
.
GetFloatValue
(
)
;
temp
.
_23
=
aData
-
>
Item
(
7
)
.
GetFloatValue
(
)
;
temp
.
_24
=
aData
-
>
Item
(
8
)
.
GetFloatValue
(
)
;
temp
.
_31
=
aData
-
>
Item
(
9
)
.
GetFloatValue
(
)
;
temp
.
_32
=
aData
-
>
Item
(
10
)
.
GetFloatValue
(
)
;
temp
.
_33
=
aData
-
>
Item
(
11
)
.
GetFloatValue
(
)
;
temp
.
_34
=
aData
-
>
Item
(
12
)
.
GetFloatValue
(
)
;
temp
.
_44
=
aData
-
>
Item
(
16
)
.
GetFloatValue
(
)
;
temp
.
_41
=
ProcessTranslatePart
(
aData
-
>
Item
(
13
)
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
temp
.
_42
=
ProcessTranslatePart
(
aData
-
>
Item
(
14
)
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
temp
.
_43
=
ProcessTranslatePart
(
aData
-
>
Item
(
15
)
nullptr
)
;
aMatrix
=
temp
*
aMatrix
;
}
class
Accumulate
{
public
:
template
<
typename
T
>
static
T
operate
(
const
T
&
aOne
const
T
&
aTwo
double
aCoeff
)
{
return
aOne
+
aTwo
*
aCoeff
;
}
static
Point4D
operateForPerspective
(
const
Point4D
&
aOne
const
Point4D
&
aTwo
double
aCoeff
)
{
return
(
aOne
-
Point4D
(
0
0
0
1
)
)
+
(
aTwo
-
Point4D
(
0
0
0
1
)
)
*
aCoeff
+
Point4D
(
0
0
0
1
)
;
}
static
Point3D
operateForScale
(
const
Point3D
&
aOne
const
Point3D
&
aTwo
double
aCoeff
)
{
return
(
aOne
-
Point3D
(
1
1
1
)
)
+
(
aTwo
-
Point3D
(
1
1
1
)
)
*
aCoeff
+
Point3D
(
1
1
1
)
;
}
static
Matrix4x4
operateForRotate
(
const
gfxQuaternion
&
aOne
const
gfxQuaternion
&
aTwo
double
aCoeff
)
{
if
(
aCoeff
=
=
0
.
0
)
{
return
aOne
.
ToMatrix
(
)
;
}
double
theta
=
acos
(
mozilla
:
:
clamped
(
aTwo
.
w
-
1
.
0
1
.
0
)
)
;
double
scale
=
(
theta
!
=
0
.
0
)
?
1
.
0
/
sin
(
theta
)
:
0
.
0
;
theta
*
=
aCoeff
;
scale
*
=
sin
(
theta
)
;
gfxQuaternion
result
=
gfxQuaternion
(
scale
*
aTwo
.
x
scale
*
aTwo
.
y
scale
*
aTwo
.
z
cos
(
theta
)
)
*
aOne
;
return
result
.
ToMatrix
(
)
;
}
static
Matrix4x4
operateForFallback
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aProgress
)
{
return
aMatrix1
;
}
static
Matrix4x4
operateByServo
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aCount
)
{
Matrix4x4
result
;
Servo_MatrixTransform_Operate
(
MatrixTransformOperator
:
:
Accumulate
&
aMatrix1
.
components
&
aMatrix2
.
components
aCount
&
result
.
components
)
;
return
result
;
}
}
;
class
Interpolate
{
public
:
template
<
typename
T
>
static
T
operate
(
const
T
&
aOne
const
T
&
aTwo
double
aCoeff
)
{
return
aOne
+
(
aTwo
-
aOne
)
*
aCoeff
;
}
static
Point4D
operateForPerspective
(
const
Point4D
&
aOne
const
Point4D
&
aTwo
double
aCoeff
)
{
return
aOne
+
(
aTwo
-
aOne
)
*
aCoeff
;
}
static
Point3D
operateForScale
(
const
Point3D
&
aOne
const
Point3D
&
aTwo
double
aCoeff
)
{
return
aOne
+
(
aTwo
-
aOne
)
*
aCoeff
;
}
static
Matrix4x4
operateForRotate
(
const
gfxQuaternion
&
aOne
const
gfxQuaternion
&
aTwo
double
aCoeff
)
{
return
aOne
.
Slerp
(
aTwo
aCoeff
)
.
ToMatrix
(
)
;
}
static
Matrix4x4
operateForFallback
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aProgress
)
{
return
aProgress
<
0
.
5
?
aMatrix1
:
aMatrix2
;
}
static
Matrix4x4
operateByServo
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aProgress
)
{
Matrix4x4
result
;
Servo_MatrixTransform_Operate
(
MatrixTransformOperator
:
:
Interpolate
&
aMatrix1
.
components
&
aMatrix2
.
components
aProgress
&
result
.
components
)
;
return
result
;
}
}
;
template
<
typename
Operator
>
static
Matrix4x4
OperateTransformMatrix
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aProgress
)
{
Point3D
scale1
(
1
1
1
)
translate1
;
Point4D
perspective1
(
0
0
0
1
)
;
gfxQuaternion
rotate1
;
nsStyleTransformMatrix
:
:
ShearArray
shear1
{
0
.
0f
0
.
0f
0
.
0f
}
;
Point3D
scale2
(
1
1
1
)
translate2
;
Point4D
perspective2
(
0
0
0
1
)
;
gfxQuaternion
rotate2
;
nsStyleTransformMatrix
:
:
ShearArray
shear2
{
0
.
0f
0
.
0f
0
.
0f
}
;
bool
wasDecomposed
;
Matrix
matrix2d1
matrix2d2
;
if
(
aMatrix1
.
Is2D
(
&
matrix2d1
)
&
&
aMatrix2
.
Is2D
(
&
matrix2d2
)
)
{
wasDecomposed
=
Decompose2DMatrix
(
matrix2d1
scale1
shear1
rotate1
translate1
)
&
&
Decompose2DMatrix
(
matrix2d2
scale2
shear2
rotate2
translate2
)
;
}
else
{
wasDecomposed
=
Decompose3DMatrix
(
aMatrix1
scale1
shear1
rotate1
translate1
perspective1
)
&
&
Decompose3DMatrix
(
aMatrix2
scale2
shear2
rotate2
translate2
perspective2
)
;
}
if
(
!
wasDecomposed
)
{
return
Operator
:
:
operateForFallback
(
aMatrix1
aMatrix2
aProgress
)
;
}
Matrix4x4
result
;
Point4D
perspective
=
Operator
:
:
operateForPerspective
(
perspective1
perspective2
aProgress
)
;
result
.
SetTransposedVector
(
3
perspective
)
;
Point3D
translate
=
Operator
:
:
operate
(
translate1
translate2
aProgress
)
;
result
.
PreTranslate
(
translate
.
x
translate
.
y
translate
.
z
)
;
Matrix4x4
rotate
=
Operator
:
:
operateForRotate
(
rotate1
rotate2
aProgress
)
;
if
(
!
rotate
.
IsIdentity
(
)
)
{
result
=
rotate
*
result
;
}
float
yzshear
=
Operator
:
:
operate
(
shear1
[
ShearType
:
:
YZSHEAR
]
shear2
[
ShearType
:
:
YZSHEAR
]
aProgress
)
;
if
(
yzshear
!
=
0
.
0
)
{
result
.
SkewYZ
(
yzshear
)
;
}
float
xzshear
=
Operator
:
:
operate
(
shear1
[
ShearType
:
:
XZSHEAR
]
shear2
[
ShearType
:
:
XZSHEAR
]
aProgress
)
;
if
(
xzshear
!
=
0
.
0
)
{
result
.
SkewXZ
(
xzshear
)
;
}
float
xyshear
=
Operator
:
:
operate
(
shear1
[
ShearType
:
:
XYSHEAR
]
shear2
[
ShearType
:
:
XYSHEAR
]
aProgress
)
;
if
(
xyshear
!
=
0
.
0
)
{
result
.
SkewXY
(
xyshear
)
;
}
Point3D
scale
=
Operator
:
:
operateForScale
(
scale1
scale2
aProgress
)
;
if
(
scale
!
=
Point3D
(
1
.
0
1
.
0
1
.
0
)
)
{
result
.
PreScale
(
scale
.
x
scale
.
y
scale
.
z
)
;
}
return
result
;
}
template
<
typename
Operator
>
static
Matrix4x4
OperateTransformMatrixByServo
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aProgress
)
{
return
Operator
:
:
operateByServo
(
aMatrix1
aMatrix2
aProgress
)
;
}
template
<
typename
Operator
>
static
void
ProcessMatrixOperator
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
4
"
Invalid
array
!
"
)
;
auto
readTransform
=
[
&
]
(
const
nsCSSValue
&
aValue
)
-
>
Matrix4x4
{
const
nsCSSValueList
*
list
=
nullptr
;
switch
(
aValue
.
GetUnit
(
)
)
{
case
eCSSUnit_List
:
list
=
aValue
.
GetListValue
(
)
;
break
;
case
eCSSUnit_SharedList
:
list
=
aValue
.
GetSharedListValue
(
)
-
>
mHead
;
break
;
default
:
list
=
nullptr
;
}
Matrix4x4
matrix
;
if
(
!
list
)
{
return
matrix
;
}
float
appUnitPerCSSPixel
=
AppUnitsPerCSSPixel
(
)
;
matrix
=
nsStyleTransformMatrix
:
:
ReadTransforms
(
list
aRefBox
appUnitPerCSSPixel
)
;
return
matrix
;
}
;
Matrix4x4
matrix1
=
readTransform
(
aData
-
>
Item
(
1
)
)
;
Matrix4x4
matrix2
=
readTransform
(
aData
-
>
Item
(
2
)
)
;
double
progress
=
aData
-
>
Item
(
3
)
.
GetPercentValue
(
)
;
if
(
aData
-
>
Item
(
1
)
.
GetUnit
(
)
=
=
eCSSUnit_SharedList
)
{
aMatrix
=
OperateTransformMatrixByServo
<
Operator
>
(
matrix1
matrix2
progress
)
*
aMatrix
;
return
;
}
aMatrix
=
OperateTransformMatrix
<
Operator
>
(
matrix1
matrix2
progress
)
*
aMatrix
;
}
void
ProcessInterpolateMatrix
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
ProcessMatrixOperator
<
Interpolate
>
(
aMatrix
aData
aRefBox
)
;
}
void
ProcessAccumulateMatrix
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
ProcessMatrixOperator
<
Accumulate
>
(
aMatrix
aData
aRefBox
)
;
}
static
void
ProcessTranslateX
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
x
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslateY
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
y
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslateZ
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
z
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
nullptr
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslate
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
|
|
aData
-
>
Count
(
)
=
=
3
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
x
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
if
(
aData
-
>
Count
(
)
=
=
3
)
{
temp
.
y
=
ProcessTranslatePart
(
aData
-
>
Item
(
2
)
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
}
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslate3D
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
4
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
x
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
temp
.
y
=
ProcessTranslatePart
(
aData
-
>
Item
(
2
)
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
temp
.
z
=
ProcessTranslatePart
(
aData
-
>
Item
(
3
)
nullptr
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessScaleHelper
(
Matrix4x4
&
aMatrix
float
aXScale
float
aYScale
float
aZScale
)
{
aMatrix
.
PreScale
(
aXScale
aYScale
aZScale
)
;
}
static
void
ProcessScaleX
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessScaleHelper
(
aMatrix
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
1
.
0f
1
.
0f
)
;
}
static
void
ProcessScaleY
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessScaleHelper
(
aMatrix
1
.
0f
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
1
.
0f
)
;
}
static
void
ProcessScaleZ
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessScaleHelper
(
aMatrix
1
.
0f
1
.
0f
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
)
;
}
static
void
ProcessScale3D
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
4
"
Bad
array
!
"
)
;
ProcessScaleHelper
(
aMatrix
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
aData
-
>
Item
(
2
)
.
GetFloatValue
(
)
aData
-
>
Item
(
3
)
.
GetFloatValue
(
)
)
;
}
static
void
ProcessScale
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
|
|
aData
-
>
Count
(
)
=
=
3
"
Bad
array
!
"
)
;
const
nsCSSValue
&
scaleX
=
aData
-
>
Item
(
1
)
;
const
nsCSSValue
&
scaleY
=
(
aData
-
>
Count
(
)
=
=
2
?
scaleX
:
aData
-
>
Item
(
2
)
)
;
ProcessScaleHelper
(
aMatrix
scaleX
.
GetFloatValue
(
)
scaleY
.
GetFloatValue
(
)
1
.
0f
)
;
}
static
void
ProcessSkewHelper
(
Matrix4x4
&
aMatrix
double
aXAngle
double
aYAngle
)
{
aMatrix
.
SkewXY
(
aXAngle
aYAngle
)
;
}
static
void
ProcessSkewX
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_ASSERTION
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessSkewHelper
(
aMatrix
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
0
.
0
)
;
}
static
void
ProcessSkewY
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_ASSERTION
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessSkewHelper
(
aMatrix
0
.
0
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
)
;
}
static
void
ProcessSkew
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_ASSERTION
(
aData
-
>
Count
(
)
=
=
2
|
|
aData
-
>
Count
(
)
=
=
3
"
Bad
array
!
"
)
;
double
xSkew
=
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
;
double
ySkew
=
(
aData
-
>
Count
(
)
=
=
2
?
0
.
0
:
aData
-
>
Item
(
2
)
.
GetAngleValueInRadians
(
)
)
;
ProcessSkewHelper
(
aMatrix
xSkew
ySkew
)
;
}
static
void
ProcessRotateZ
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
double
theta
=
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
;
aMatrix
.
RotateZ
(
theta
)
;
}
static
void
ProcessRotateX
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
double
theta
=
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
;
aMatrix
.
RotateX
(
theta
)
;
}
static
void
ProcessRotateY
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
double
theta
=
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
;
aMatrix
.
RotateY
(
theta
)
;
}
static
void
ProcessRotate3D
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
5
"
Invalid
array
!
"
)
;
double
theta
=
aData
-
>
Item
(
4
)
.
GetAngleValueInRadians
(
)
;
float
x
=
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
float
y
=
aData
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
float
z
=
aData
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
Matrix4x4
temp
;
temp
.
SetRotateAxisAngle
(
x
y
z
theta
)
;
aMatrix
=
temp
*
aMatrix
;
}
static
void
ProcessPerspective
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
float
depth
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
nullptr
)
;
ApplyPerspectiveToMatrix
(
aMatrix
depth
)
;
}
static
void
MatrixForTransformFunction
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aData
"
Why
did
you
want
to
get
data
from
a
null
array
?
"
)
;
switch
(
TransformFunctionOf
(
aData
)
)
{
case
eCSSKeyword_translatex
:
ProcessTranslateX
(
aMatrix
aData
aRefBox
)
;
break
;
case
eCSSKeyword_translatey
:
ProcessTranslateY
(
aMatrix
aData
aRefBox
)
;
break
;
case
eCSSKeyword_translatez
:
ProcessTranslateZ
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_translate
:
ProcessTranslate
(
aMatrix
aData
aRefBox
)
;
break
;
case
eCSSKeyword_translate3d
:
ProcessTranslate3D
(
aMatrix
aData
aRefBox
)
;
break
;
case
eCSSKeyword_scalex
:
ProcessScaleX
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_scaley
:
ProcessScaleY
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_scalez
:
ProcessScaleZ
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_scale
:
ProcessScale
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_scale3d
:
ProcessScale3D
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_skewx
:
ProcessSkewX
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_skewy
:
ProcessSkewY
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_skew
:
ProcessSkew
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_rotatex
:
ProcessRotateX
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_rotatey
:
ProcessRotateY
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_rotatez
:
MOZ_FALLTHROUGH
;
case
eCSSKeyword_rotate
:
ProcessRotateZ
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_rotate3d
:
ProcessRotate3D
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_matrix
:
ProcessMatrix
(
aMatrix
aData
aRefBox
)
;
break
;
case
eCSSKeyword_matrix3d
:
ProcessMatrix3D
(
aMatrix
aData
aRefBox
)
;
break
;
case
eCSSKeyword_interpolatematrix
:
ProcessMatrixOperator
<
Interpolate
>
(
aMatrix
aData
aRefBox
)
;
break
;
case
eCSSKeyword_accumulatematrix
:
ProcessMatrixOperator
<
Accumulate
>
(
aMatrix
aData
aRefBox
)
;
break
;
case
eCSSKeyword_perspective
:
ProcessPerspective
(
aMatrix
aData
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
transform
function
!
"
)
;
}
}
nsCSSKeyword
TransformFunctionOf
(
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Item
(
0
)
.
GetUnit
(
)
=
=
eCSSUnit_Enumerated
)
;
return
aData
-
>
Item
(
0
)
.
GetKeywordValue
(
)
;
}
void
SetIdentityMatrix
(
nsCSSValue
:
:
Array
*
aMatrix
)
{
MOZ_ASSERT
(
aMatrix
"
aMatrix
should
be
non
-
null
"
)
;
nsCSSKeyword
tfunc
=
TransformFunctionOf
(
aMatrix
)
;
MOZ_ASSERT
(
tfunc
=
=
eCSSKeyword_matrix
|
|
tfunc
=
=
eCSSKeyword_matrix3d
"
Only
accept
matrix
and
matrix3d
"
)
;
if
(
tfunc
=
=
eCSSKeyword_matrix
)
{
MOZ_ASSERT
(
aMatrix
-
>
Count
(
)
=
=
7
"
Invalid
matrix
"
)
;
Matrix
m
;
for
(
size_t
i
=
0
;
i
<
6
;
+
+
i
)
{
aMatrix
-
>
Item
(
i
+
1
)
.
SetFloatValue
(
m
.
components
[
i
]
eCSSUnit_Number
)
;
}
return
;
}
MOZ_ASSERT
(
aMatrix
-
>
Count
(
)
=
=
17
"
Invalid
matrix3d
"
)
;
Matrix4x4
m
;
for
(
size_t
i
=
0
;
i
<
16
;
+
+
i
)
{
aMatrix
-
>
Item
(
i
+
1
)
.
SetFloatValue
(
m
.
components
[
i
]
eCSSUnit_Number
)
;
}
}
static
void
ReadTransformsImpl
(
Matrix4x4
&
aMatrix
const
nsCSSValueList
*
aList
TransformReferenceBox
&
aRefBox
)
{
for
(
const
nsCSSValueList
*
curr
=
aList
;
curr
!
=
nullptr
;
curr
=
curr
-
>
mNext
)
{
const
nsCSSValue
&
currElem
=
curr
-
>
mValue
;
if
(
currElem
.
GetUnit
(
)
!
=
eCSSUnit_Function
)
{
NS_ASSERTION
(
currElem
.
GetUnit
(
)
=
=
eCSSUnit_None
&
&
!
aList
-
>
mNext
"
stream
should
either
be
a
list
of
functions
or
a
"
"
lone
None
"
)
;
continue
;
}
NS_ASSERTION
(
currElem
.
GetArrayValue
(
)
-
>
Count
(
)
>
=
1
"
Incoming
function
is
too
short
!
"
)
;
MatrixForTransformFunction
(
aMatrix
currElem
.
GetArrayValue
(
)
aRefBox
)
;
}
}
Matrix4x4
ReadTransforms
(
const
nsCSSValueList
*
aList
TransformReferenceBox
&
aRefBox
float
aAppUnitsPerMatrixUnit
)
{
Matrix4x4
result
;
ReadTransformsImpl
(
result
aList
aRefBox
)
;
float
scale
=
float
(
AppUnitsPerCSSPixel
(
)
)
/
aAppUnitsPerMatrixUnit
;
result
.
PreScale
(
1
/
scale
1
/
scale
1
/
scale
)
;
result
.
PostScale
(
scale
scale
scale
)
;
return
result
;
}
Matrix4x4
ReadTransforms
(
const
nsCSSValueList
*
aIndividualTransforms
const
Maybe
<
MotionPathData
>
&
aMotion
const
nsCSSValueList
*
aTransform
TransformReferenceBox
&
aRefBox
float
aAppUnitsPerMatrixUnit
)
{
Matrix4x4
result
;
if
(
aIndividualTransforms
)
{
ReadTransformsImpl
(
result
aIndividualTransforms
aRefBox
)
;
}
if
(
aMotion
.
isSome
(
)
)
{
result
.
PreTranslate
(
aMotion
-
>
mTranslate
.
x
aMotion
-
>
mTranslate
.
y
0
.
0
)
;
if
(
aMotion
-
>
mRotate
!
=
0
.
0
)
{
result
.
RotateZ
(
aMotion
-
>
mRotate
)
;
}
}
if
(
aTransform
)
{
ReadTransformsImpl
(
result
aTransform
aRefBox
)
;
}
float
scale
=
float
(
AppUnitsPerCSSPixel
(
)
)
/
aAppUnitsPerMatrixUnit
;
result
.
PreScale
(
1
/
scale
1
/
scale
1
/
scale
)
;
result
.
PostScale
(
scale
scale
scale
)
;
return
result
;
}
CSSPoint
Convert2DPosition
(
const
LengthPercentage
&
aX
const
LengthPercentage
&
aY
TransformReferenceBox
&
aRefBox
)
{
return
{
aX
.
ResolveToCSSPixelsWith
(
[
&
]
{
return
CSSPixel
:
:
FromAppUnits
(
aRefBox
.
Width
(
)
)
;
}
)
aY
.
ResolveToCSSPixelsWith
(
[
&
]
{
return
CSSPixel
:
:
FromAppUnits
(
aRefBox
.
Height
(
)
)
;
}
)
}
;
}
Point
Convert2DPosition
(
const
LengthPercentage
&
aX
const
LengthPercentage
&
aY
TransformReferenceBox
&
aRefBox
int32_t
aAppUnitsPerPixel
)
{
float
scale
=
mozilla
:
:
AppUnitsPerCSSPixel
(
)
/
float
(
aAppUnitsPerPixel
)
;
CSSPoint
p
=
Convert2DPosition
(
aX
aY
aRefBox
)
;
return
{
p
.
x
*
scale
p
.
y
*
scale
}
;
}
bool
Decompose2DMatrix
(
const
Matrix
&
aMatrix
Point3D
&
aScale
ShearArray
&
aShear
gfxQuaternion
&
aRotate
Point3D
&
aTranslate
)
{
float
A
=
aMatrix
.
_11
B
=
aMatrix
.
_12
C
=
aMatrix
.
_21
D
=
aMatrix
.
_22
;
if
(
A
*
D
=
=
B
*
C
)
{
return
false
;
}
float
scaleX
=
sqrt
(
A
*
A
+
B
*
B
)
;
A
/
=
scaleX
;
B
/
=
scaleX
;
float
XYshear
=
A
*
C
+
B
*
D
;
C
-
=
A
*
XYshear
;
D
-
=
B
*
XYshear
;
float
scaleY
=
sqrt
(
C
*
C
+
D
*
D
)
;
C
/
=
scaleY
;
D
/
=
scaleY
;
XYshear
/
=
scaleY
;
float
determinant
=
A
*
D
-
B
*
C
;
if
(
0
.
99
>
Abs
(
determinant
)
|
|
Abs
(
determinant
)
>
1
.
01
)
{
return
false
;
}
if
(
determinant
<
0
)
{
A
=
-
A
;
B
=
-
B
;
C
=
-
C
;
D
=
-
D
;
XYshear
=
-
XYshear
;
scaleX
=
-
scaleX
;
}
float
rotate
=
atan2f
(
B
A
)
;
aRotate
=
gfxQuaternion
(
0
0
sin
(
rotate
/
2
)
cos
(
rotate
/
2
)
)
;
aShear
[
ShearType
:
:
XYSHEAR
]
=
XYshear
;
aScale
.
x
=
scaleX
;
aScale
.
y
=
scaleY
;
aTranslate
.
x
=
aMatrix
.
_31
;
aTranslate
.
y
=
aMatrix
.
_32
;
return
true
;
}
bool
Decompose3DMatrix
(
const
Matrix4x4
&
aMatrix
Point3D
&
aScale
ShearArray
&
aShear
gfxQuaternion
&
aRotate
Point3D
&
aTranslate
Point4D
&
aPerspective
)
{
Matrix4x4
local
=
aMatrix
;
if
(
local
[
3
]
[
3
]
=
=
0
)
{
return
false
;
}
local
.
Normalize
(
)
;
Matrix4x4
perspective
=
local
;
Point4D
empty
(
0
0
0
1
)
;
perspective
.
SetTransposedVector
(
3
empty
)
;
if
(
perspective
.
Determinant
(
)
=
=
0
.
0
)
{
return
false
;
}
if
(
local
[
0
]
[
3
]
!
=
0
|
|
local
[
1
]
[
3
]
!
=
0
|
|
local
[
2
]
[
3
]
!
=
0
)
{
aPerspective
=
local
.
TransposedVector
(
3
)
;
perspective
.
Invert
(
)
;
aPerspective
=
perspective
.
TransposeTransform4D
(
aPerspective
)
;
local
.
SetTransposedVector
(
3
empty
)
;
}
else
{
aPerspective
=
Point4D
(
0
0
0
1
)
;
}
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
aTranslate
[
i
]
=
local
[
3
]
[
i
]
;
local
[
3
]
[
i
]
=
0
;
}
aScale
.
x
=
local
[
0
]
.
Length
(
)
;
local
[
0
]
/
=
aScale
.
x
;
aShear
[
ShearType
:
:
XYSHEAR
]
=
local
[
0
]
.
DotProduct
(
local
[
1
]
)
;
local
[
1
]
-
=
local
[
0
]
*
aShear
[
ShearType
:
:
XYSHEAR
]
;
aScale
.
y
=
local
[
1
]
.
Length
(
)
;
local
[
1
]
/
=
aScale
.
y
;
aShear
[
ShearType
:
:
XYSHEAR
]
/
=
aScale
.
y
;
aShear
[
ShearType
:
:
XZSHEAR
]
=
local
[
0
]
.
DotProduct
(
local
[
2
]
)
;
local
[
2
]
-
=
local
[
0
]
*
aShear
[
ShearType
:
:
XZSHEAR
]
;
aShear
[
ShearType
:
:
YZSHEAR
]
=
local
[
1
]
.
DotProduct
(
local
[
2
]
)
;
local
[
2
]
-
=
local
[
1
]
*
aShear
[
ShearType
:
:
YZSHEAR
]
;
aScale
.
z
=
local
[
2
]
.
Length
(
)
;
local
[
2
]
/
=
aScale
.
z
;
aShear
[
ShearType
:
:
XZSHEAR
]
/
=
aScale
.
z
;
aShear
[
ShearType
:
:
YZSHEAR
]
/
=
aScale
.
z
;
if
(
local
[
0
]
.
DotProduct
(
local
[
1
]
.
CrossProduct
(
local
[
2
]
)
)
<
0
)
{
aScale
*
=
-
1
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
local
[
i
]
*
=
-
1
;
}
}
aRotate
=
gfxQuaternion
(
local
)
;
return
true
;
}
Matrix
CSSValueArrayTo2DMatrix
(
nsCSSValue
:
:
Array
*
aArray
)
{
MOZ_ASSERT
(
aArray
&
&
TransformFunctionOf
(
aArray
)
=
=
eCSSKeyword_matrix
&
&
aArray
-
>
Count
(
)
=
=
7
)
;
Matrix
m
(
aArray
-
>
Item
(
1
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
2
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
3
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
4
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
5
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
6
)
.
GetFloatValue
(
)
)
;
return
m
;
}
Matrix4x4
CSSValueArrayTo3DMatrix
(
nsCSSValue
:
:
Array
*
aArray
)
{
MOZ_ASSERT
(
aArray
&
&
TransformFunctionOf
(
aArray
)
=
=
eCSSKeyword_matrix3d
&
&
aArray
-
>
Count
(
)
=
=
17
)
;
gfx
:
:
Float
array
[
16
]
;
for
(
size_t
i
=
0
;
i
<
16
;
+
+
i
)
{
array
[
i
]
=
aArray
-
>
Item
(
i
+
1
)
.
GetFloatValue
(
)
;
}
Matrix4x4
m
(
array
)
;
return
m
;
}
Size
GetScaleValue
(
const
nsCSSValueSharedList
*
aList
const
nsIFrame
*
aForFrame
)
{
MOZ_ASSERT
(
aList
&
&
aList
-
>
mHead
)
;
MOZ_ASSERT
(
aForFrame
)
;
TransformReferenceBox
refBox
(
aForFrame
)
;
Matrix4x4
transform
=
ReadTransforms
(
aList
-
>
mHead
refBox
aForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
Matrix
transform2d
;
bool
canDraw2D
=
transform
.
CanDraw2D
(
&
transform2d
)
;
if
(
!
canDraw2D
)
{
return
Size
(
)
;
}
return
transform2d
.
ScaleFactors
(
true
)
;
}
}
