#
include
"
nsStyleTransformMatrix
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
MotionPathUtils
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxQuaternion
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
namespace
nsStyleTransformMatrix
{
void
TransformReferenceBox
:
:
EnsureDimensionsAreCached
(
)
{
if
(
mIsCached
)
{
return
;
}
MOZ_ASSERT
(
mFrame
)
;
const
auto
box
=
mFrame
-
>
StyleDisplay
(
)
-
>
mTransformBox
;
if
(
box
=
=
StyleTransformBox
:
:
ContentBox
|
|
box
=
=
StyleTransformBox
:
:
StrokeBox
)
{
return
;
}
mIsCached
=
true
;
if
(
mFrame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
if
(
box
=
=
StyleTransformBox
:
:
FillBox
)
{
nsRect
bboxInAppUnits
=
nsLayoutUtils
:
:
ComputeGeometryBox
(
const_cast
<
nsIFrame
*
>
(
mFrame
)
StyleGeometryBox
:
:
FillBox
)
;
mX
=
bboxInAppUnits
.
x
-
mFrame
-
>
GetPosition
(
)
.
x
;
mY
=
bboxInAppUnits
.
y
-
mFrame
-
>
GetPosition
(
)
.
y
;
mWidth
=
bboxInAppUnits
.
width
;
mHeight
=
bboxInAppUnits
.
height
;
}
else
{
MOZ_ASSERT
(
box
=
=
StyleTransformBox
:
:
ViewBox
|
|
box
=
=
StyleTransformBox
:
:
BorderBox
"
Unexpected
value
for
'
transform
-
box
'
"
)
;
mX
=
-
mFrame
-
>
GetPosition
(
)
.
x
;
mY
=
-
mFrame
-
>
GetPosition
(
)
.
y
;
Size
contextSize
=
SVGUtils
:
:
GetContextSize
(
mFrame
)
;
mWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
width
)
;
mHeight
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
height
)
;
}
return
;
}
nsRect
rect
;
#
ifndef
UNIFIED_CONTINUATIONS
rect
=
mFrame
-
>
GetRect
(
)
;
#
else
for
(
const
nsIFrame
*
currFrame
=
mFrame
-
>
FirstContinuation
(
)
;
currFrame
!
=
nullptr
;
currFrame
=
currFrame
-
>
GetNextContinuation
(
)
)
{
rect
.
UnionRect
(
result
nsRect
(
currFrame
-
>
GetOffsetTo
(
mFrame
)
currFrame
-
>
GetSize
(
)
)
)
;
}
#
endif
mX
=
0
;
mY
=
0
;
mWidth
=
rect
.
Width
(
)
;
mHeight
=
rect
.
Height
(
)
;
}
void
TransformReferenceBox
:
:
Init
(
const
nsRect
&
aDimensions
)
{
MOZ_ASSERT
(
!
mFrame
&
&
!
mIsCached
)
;
mX
=
aDimensions
.
x
;
mY
=
aDimensions
.
y
;
mWidth
=
aDimensions
.
width
;
mHeight
=
aDimensions
.
height
;
mIsCached
=
true
;
}
float
ProcessTranslatePart
(
const
LengthPercentage
&
aValue
TransformReferenceBox
*
aRefBox
TransformReferenceBox
:
:
DimensionGetter
aDimensionGetter
)
{
return
aValue
.
ResolveToCSSPixelsWith
(
[
&
]
{
return
aRefBox
&
&
!
aRefBox
-
>
IsEmpty
(
)
?
CSSPixel
:
:
FromAppUnits
(
(
aRefBox
-
>
*
aDimensionGetter
)
(
)
)
:
CSSCoord
(
0
)
;
}
)
;
}
static
void
ProcessMatrix
(
Matrix4x4
&
aMatrix
const
StyleTransformOperation
&
aOp
)
{
const
auto
&
matrix
=
aOp
.
AsMatrix
(
)
;
gfxMatrix
result
;
result
.
_11
=
matrix
.
a
;
result
.
_12
=
matrix
.
b
;
result
.
_21
=
matrix
.
c
;
result
.
_22
=
matrix
.
d
;
result
.
_31
=
matrix
.
e
;
result
.
_32
=
matrix
.
f
;
aMatrix
=
result
*
aMatrix
;
}
static
void
ProcessMatrix3D
(
Matrix4x4
&
aMatrix
const
StyleTransformOperation
&
aOp
)
{
Matrix4x4
temp
;
const
auto
&
matrix
=
aOp
.
AsMatrix3D
(
)
;
temp
.
_11
=
matrix
.
m11
;
temp
.
_12
=
matrix
.
m12
;
temp
.
_13
=
matrix
.
m13
;
temp
.
_14
=
matrix
.
m14
;
temp
.
_21
=
matrix
.
m21
;
temp
.
_22
=
matrix
.
m22
;
temp
.
_23
=
matrix
.
m23
;
temp
.
_24
=
matrix
.
m24
;
temp
.
_31
=
matrix
.
m31
;
temp
.
_32
=
matrix
.
m32
;
temp
.
_33
=
matrix
.
m33
;
temp
.
_34
=
matrix
.
m34
;
temp
.
_41
=
matrix
.
m41
;
temp
.
_42
=
matrix
.
m42
;
temp
.
_43
=
matrix
.
m43
;
temp
.
_44
=
matrix
.
m44
;
aMatrix
=
temp
*
aMatrix
;
}
class
Accumulate
{
public
:
template
<
typename
T
>
static
T
operate
(
const
T
&
aOne
const
T
&
aTwo
double
aCoeff
)
{
return
aOne
+
aTwo
*
aCoeff
;
}
static
Point4D
operateForPerspective
(
const
Point4D
&
aOne
const
Point4D
&
aTwo
double
aCoeff
)
{
return
(
aOne
-
Point4D
(
0
0
0
1
)
)
+
(
aTwo
-
Point4D
(
0
0
0
1
)
)
*
aCoeff
+
Point4D
(
0
0
0
1
)
;
}
static
Point3D
operateForScale
(
const
Point3D
&
aOne
const
Point3D
&
aTwo
double
aCoeff
)
{
return
(
aOne
-
Point3D
(
1
1
1
)
)
+
(
aTwo
-
Point3D
(
1
1
1
)
)
*
aCoeff
+
Point3D
(
1
1
1
)
;
}
static
Matrix4x4
operateForRotate
(
const
gfxQuaternion
&
aOne
const
gfxQuaternion
&
aTwo
double
aCoeff
)
{
if
(
aCoeff
=
=
0
.
0
)
{
return
aOne
.
ToMatrix
(
)
;
}
double
theta
=
acos
(
mozilla
:
:
clamped
(
aTwo
.
w
-
1
.
0
1
.
0
)
)
;
double
scale
=
(
theta
!
=
0
.
0
)
?
1
.
0
/
sin
(
theta
)
:
0
.
0
;
theta
*
=
aCoeff
;
scale
*
=
sin
(
theta
)
;
gfxQuaternion
result
=
gfxQuaternion
(
scale
*
aTwo
.
x
scale
*
aTwo
.
y
scale
*
aTwo
.
z
cos
(
theta
)
)
*
aOne
;
return
result
.
ToMatrix
(
)
;
}
static
Matrix4x4
operateForFallback
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aProgress
)
{
return
aMatrix1
;
}
static
Matrix4x4
operateByServo
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aCount
)
{
Matrix4x4
result
;
Servo_MatrixTransform_Operate
(
MatrixTransformOperator
:
:
Accumulate
&
aMatrix1
.
components
&
aMatrix2
.
components
aCount
&
result
.
components
)
;
return
result
;
}
}
;
class
Interpolate
{
public
:
template
<
typename
T
>
static
T
operate
(
const
T
&
aOne
const
T
&
aTwo
double
aCoeff
)
{
return
aOne
+
(
aTwo
-
aOne
)
*
aCoeff
;
}
static
Point4D
operateForPerspective
(
const
Point4D
&
aOne
const
Point4D
&
aTwo
double
aCoeff
)
{
return
aOne
+
(
aTwo
-
aOne
)
*
aCoeff
;
}
static
Point3D
operateForScale
(
const
Point3D
&
aOne
const
Point3D
&
aTwo
double
aCoeff
)
{
return
aOne
+
(
aTwo
-
aOne
)
*
aCoeff
;
}
static
Matrix4x4
operateForRotate
(
const
gfxQuaternion
&
aOne
const
gfxQuaternion
&
aTwo
double
aCoeff
)
{
return
aOne
.
Slerp
(
aTwo
aCoeff
)
.
ToMatrix
(
)
;
}
static
Matrix4x4
operateForFallback
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aProgress
)
{
return
aProgress
<
0
.
5
?
aMatrix1
:
aMatrix2
;
}
static
Matrix4x4
operateByServo
(
const
Matrix4x4
&
aMatrix1
const
Matrix4x4
&
aMatrix2
double
aProgress
)
{
Matrix4x4
result
;
Servo_MatrixTransform_Operate
(
MatrixTransformOperator
:
:
Interpolate
&
aMatrix1
.
components
&
aMatrix2
.
components
aProgress
&
result
.
components
)
;
return
result
;
}
}
;
template
<
typename
Operator
>
static
void
ProcessMatrixOperator
(
Matrix4x4
&
aMatrix
const
StyleTransform
&
aFrom
const
StyleTransform
&
aTo
float
aProgress
TransformReferenceBox
&
aRefBox
)
{
float
appUnitPerCSSPixel
=
AppUnitsPerCSSPixel
(
)
;
Matrix4x4
matrix1
=
ReadTransforms
(
aFrom
aRefBox
appUnitPerCSSPixel
)
;
Matrix4x4
matrix2
=
ReadTransforms
(
aTo
aRefBox
appUnitPerCSSPixel
)
;
aMatrix
=
Operator
:
:
operateByServo
(
matrix1
matrix2
aProgress
)
*
aMatrix
;
}
void
ProcessInterpolateMatrix
(
Matrix4x4
&
aMatrix
const
StyleTransformOperation
&
aOp
TransformReferenceBox
&
aRefBox
)
{
const
auto
&
args
=
aOp
.
AsInterpolateMatrix
(
)
;
ProcessMatrixOperator
<
Interpolate
>
(
aMatrix
args
.
from_list
args
.
to_list
args
.
progress
.
_0
aRefBox
)
;
}
void
ProcessAccumulateMatrix
(
Matrix4x4
&
aMatrix
const
StyleTransformOperation
&
aOp
TransformReferenceBox
&
aRefBox
)
{
const
auto
&
args
=
aOp
.
AsAccumulateMatrix
(
)
;
ProcessMatrixOperator
<
Accumulate
>
(
aMatrix
args
.
from_list
args
.
to_list
args
.
count
aRefBox
)
;
}
static
void
ProcessTranslateX
(
Matrix4x4
&
aMatrix
const
LengthPercentage
&
aLength
TransformReferenceBox
&
aRefBox
)
{
Point3D
temp
;
temp
.
x
=
ProcessTranslatePart
(
aLength
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslateY
(
Matrix4x4
&
aMatrix
const
LengthPercentage
&
aLength
TransformReferenceBox
&
aRefBox
)
{
Point3D
temp
;
temp
.
y
=
ProcessTranslatePart
(
aLength
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslateZ
(
Matrix4x4
&
aMatrix
const
Length
&
aLength
)
{
Point3D
temp
;
temp
.
z
=
aLength
.
ToCSSPixels
(
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslate
(
Matrix4x4
&
aMatrix
const
LengthPercentage
&
aX
const
LengthPercentage
&
aY
TransformReferenceBox
&
aRefBox
)
{
Point3D
temp
;
temp
.
x
=
ProcessTranslatePart
(
aX
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
temp
.
y
=
ProcessTranslatePart
(
aY
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslate3D
(
Matrix4x4
&
aMatrix
const
LengthPercentage
&
aX
const
LengthPercentage
&
aY
const
Length
&
aZ
TransformReferenceBox
&
aRefBox
)
{
Point3D
temp
;
temp
.
x
=
ProcessTranslatePart
(
aX
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
temp
.
y
=
ProcessTranslatePart
(
aY
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
temp
.
z
=
aZ
.
ToCSSPixels
(
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessScaleHelper
(
Matrix4x4
&
aMatrix
float
aXScale
float
aYScale
float
aZScale
)
{
aMatrix
.
PreScale
(
aXScale
aYScale
aZScale
)
;
}
static
void
ProcessScale3D
(
Matrix4x4
&
aMatrix
const
StyleTransformOperation
&
aOp
)
{
const
auto
&
scale
=
aOp
.
AsScale3D
(
)
;
ProcessScaleHelper
(
aMatrix
scale
.
_0
scale
.
_1
scale
.
_2
)
;
}
static
void
ProcessSkewHelper
(
Matrix4x4
&
aMatrix
const
StyleAngle
&
aXAngle
const
StyleAngle
&
aYAngle
)
{
aMatrix
.
SkewXY
(
aXAngle
.
ToRadians
(
)
aYAngle
.
ToRadians
(
)
)
;
}
static
void
ProcessRotate3D
(
Matrix4x4
&
aMatrix
float
aX
float
aY
float
aZ
const
StyleAngle
&
aAngle
)
{
Matrix4x4
temp
;
temp
.
SetRotateAxisAngle
(
aX
aY
aZ
aAngle
.
ToRadians
(
)
)
;
aMatrix
=
temp
*
aMatrix
;
}
static
void
ProcessPerspective
(
Matrix4x4
&
aMatrix
const
StyleGenericPerspectiveFunction
<
Length
>
&
aPerspective
)
{
if
(
aPerspective
.
IsNone
(
)
)
{
return
;
}
float
p
=
aPerspective
.
AsLength
(
)
.
ToCSSPixels
(
)
;
if
(
!
std
:
:
isinf
(
p
)
)
{
aMatrix
.
Perspective
(
std
:
:
max
(
p
1
.
0f
)
)
;
}
}
static
void
MatrixForTransformFunction
(
Matrix4x4
&
aMatrix
const
StyleTransformOperation
&
aOp
TransformReferenceBox
&
aRefBox
)
{
switch
(
aOp
.
tag
)
{
case
StyleTransformOperation
:
:
Tag
:
:
TranslateX
:
ProcessTranslateX
(
aMatrix
aOp
.
AsTranslateX
(
)
aRefBox
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
TranslateY
:
ProcessTranslateY
(
aMatrix
aOp
.
AsTranslateY
(
)
aRefBox
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
TranslateZ
:
ProcessTranslateZ
(
aMatrix
aOp
.
AsTranslateZ
(
)
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Translate
:
ProcessTranslate
(
aMatrix
aOp
.
AsTranslate
(
)
.
_0
aOp
.
AsTranslate
(
)
.
_1
aRefBox
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Translate3D
:
return
ProcessTranslate3D
(
aMatrix
aOp
.
AsTranslate3D
(
)
.
_0
aOp
.
AsTranslate3D
(
)
.
_1
aOp
.
AsTranslate3D
(
)
.
_2
aRefBox
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
ScaleX
:
ProcessScaleHelper
(
aMatrix
aOp
.
AsScaleX
(
)
1
.
0f
1
.
0f
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
ScaleY
:
ProcessScaleHelper
(
aMatrix
1
.
0f
aOp
.
AsScaleY
(
)
1
.
0f
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
ScaleZ
:
ProcessScaleHelper
(
aMatrix
1
.
0f
1
.
0f
aOp
.
AsScaleZ
(
)
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Scale
:
ProcessScaleHelper
(
aMatrix
aOp
.
AsScale
(
)
.
_0
aOp
.
AsScale
(
)
.
_1
1
.
0f
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Scale3D
:
ProcessScale3D
(
aMatrix
aOp
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
SkewX
:
ProcessSkewHelper
(
aMatrix
aOp
.
AsSkewX
(
)
StyleAngle
:
:
Zero
(
)
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
SkewY
:
ProcessSkewHelper
(
aMatrix
StyleAngle
:
:
Zero
(
)
aOp
.
AsSkewY
(
)
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Skew
:
ProcessSkewHelper
(
aMatrix
aOp
.
AsSkew
(
)
.
_0
aOp
.
AsSkew
(
)
.
_1
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
RotateX
:
aMatrix
.
RotateX
(
aOp
.
AsRotateX
(
)
.
ToRadians
(
)
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
RotateY
:
aMatrix
.
RotateY
(
aOp
.
AsRotateY
(
)
.
ToRadians
(
)
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
RotateZ
:
aMatrix
.
RotateZ
(
aOp
.
AsRotateZ
(
)
.
ToRadians
(
)
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Rotate
:
aMatrix
.
RotateZ
(
aOp
.
AsRotate
(
)
.
ToRadians
(
)
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Rotate3D
:
ProcessRotate3D
(
aMatrix
aOp
.
AsRotate3D
(
)
.
_0
aOp
.
AsRotate3D
(
)
.
_1
aOp
.
AsRotate3D
(
)
.
_2
aOp
.
AsRotate3D
(
)
.
_3
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Matrix
:
ProcessMatrix
(
aMatrix
aOp
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Matrix3D
:
ProcessMatrix3D
(
aMatrix
aOp
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
InterpolateMatrix
:
ProcessInterpolateMatrix
(
aMatrix
aOp
aRefBox
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
AccumulateMatrix
:
ProcessAccumulateMatrix
(
aMatrix
aOp
aRefBox
)
;
break
;
case
StyleTransformOperation
:
:
Tag
:
:
Perspective
:
ProcessPerspective
(
aMatrix
aOp
.
AsPerspective
(
)
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
transform
function
!
"
)
;
}
}
Matrix4x4
ReadTransforms
(
const
StyleTransform
&
aTransform
TransformReferenceBox
&
aRefBox
float
aAppUnitsPerMatrixUnit
)
{
Matrix4x4
result
;
for
(
const
StyleTransformOperation
&
op
:
aTransform
.
Operations
(
)
)
{
MatrixForTransformFunction
(
result
op
aRefBox
)
;
}
float
scale
=
float
(
AppUnitsPerCSSPixel
(
)
)
/
aAppUnitsPerMatrixUnit
;
result
.
PreScale
(
1
/
scale
1
/
scale
1
/
scale
)
;
result
.
PostScale
(
scale
scale
scale
)
;
return
result
;
}
static
void
ProcessTranslate
(
Matrix4x4
&
aMatrix
const
StyleTranslate
&
aTranslate
TransformReferenceBox
&
aRefBox
)
{
switch
(
aTranslate
.
tag
)
{
case
StyleTranslate
:
:
Tag
:
:
None
:
return
;
case
StyleTranslate
:
:
Tag
:
:
Translate
:
return
ProcessTranslate3D
(
aMatrix
aTranslate
.
AsTranslate
(
)
.
_0
aTranslate
.
AsTranslate
(
)
.
_1
aTranslate
.
AsTranslate
(
)
.
_2
aRefBox
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Huh
?
"
)
;
}
}
static
void
ProcessRotate
(
Matrix4x4
&
aMatrix
const
StyleRotate
&
aRotate
)
{
switch
(
aRotate
.
tag
)
{
case
StyleRotate
:
:
Tag
:
:
None
:
return
;
case
StyleRotate
:
:
Tag
:
:
Rotate
:
aMatrix
.
RotateZ
(
aRotate
.
AsRotate
(
)
.
ToRadians
(
)
)
;
return
;
case
StyleRotate
:
:
Tag
:
:
Rotate3D
:
return
ProcessRotate3D
(
aMatrix
aRotate
.
AsRotate3D
(
)
.
_0
aRotate
.
AsRotate3D
(
)
.
_1
aRotate
.
AsRotate3D
(
)
.
_2
aRotate
.
AsRotate3D
(
)
.
_3
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Huh
?
"
)
;
}
}
static
void
ProcessScale
(
Matrix4x4
&
aMatrix
const
StyleScale
&
aScale
)
{
switch
(
aScale
.
tag
)
{
case
StyleScale
:
:
Tag
:
:
None
:
return
;
case
StyleScale
:
:
Tag
:
:
Scale
:
return
ProcessScaleHelper
(
aMatrix
aScale
.
AsScale
(
)
.
_0
aScale
.
AsScale
(
)
.
_1
aScale
.
AsScale
(
)
.
_2
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Huh
?
"
)
;
}
}
Matrix4x4
ReadTransforms
(
const
StyleTranslate
&
aTranslate
const
StyleRotate
&
aRotate
const
StyleScale
&
aScale
const
ResolvedMotionPathData
*
aMotion
const
StyleTransform
&
aTransform
TransformReferenceBox
&
aRefBox
float
aAppUnitsPerMatrixUnit
)
{
Matrix4x4
result
;
ProcessTranslate
(
result
aTranslate
aRefBox
)
;
ProcessRotate
(
result
aRotate
)
;
ProcessScale
(
result
aScale
)
;
if
(
aMotion
)
{
result
.
PreTranslate
(
aMotion
-
>
mTranslate
.
x
+
aMotion
-
>
mShift
.
x
aMotion
-
>
mTranslate
.
y
+
aMotion
-
>
mShift
.
y
0
.
0
)
;
if
(
aMotion
-
>
mRotate
!
=
0
.
0
)
{
result
.
RotateZ
(
aMotion
-
>
mRotate
)
;
}
result
.
PreTranslate
(
-
aMotion
-
>
mShift
.
x
-
aMotion
-
>
mShift
.
y
0
.
0
)
;
}
for
(
const
StyleTransformOperation
&
op
:
aTransform
.
Operations
(
)
)
{
MatrixForTransformFunction
(
result
op
aRefBox
)
;
}
float
scale
=
float
(
AppUnitsPerCSSPixel
(
)
)
/
aAppUnitsPerMatrixUnit
;
result
.
PreScale
(
1
/
scale
1
/
scale
1
/
scale
)
;
result
.
PostScale
(
scale
scale
scale
)
;
return
result
;
}
mozilla
:
:
CSSPoint
Convert2DPosition
(
const
mozilla
:
:
LengthPercentage
&
aX
const
mozilla
:
:
LengthPercentage
&
aY
const
CSSSize
&
aSize
)
{
return
{
aX
.
ResolveToCSSPixels
(
aSize
.
width
)
aY
.
ResolveToCSSPixels
(
aSize
.
height
)
}
;
}
CSSPoint
Convert2DPosition
(
const
LengthPercentage
&
aX
const
LengthPercentage
&
aY
TransformReferenceBox
&
aRefBox
)
{
return
{
aX
.
ResolveToCSSPixelsWith
(
[
&
]
{
return
CSSPixel
:
:
FromAppUnits
(
aRefBox
.
Width
(
)
)
;
}
)
aY
.
ResolveToCSSPixelsWith
(
[
&
]
{
return
CSSPixel
:
:
FromAppUnits
(
aRefBox
.
Height
(
)
)
;
}
)
}
;
}
Point
Convert2DPosition
(
const
LengthPercentage
&
aX
const
LengthPercentage
&
aY
TransformReferenceBox
&
aRefBox
int32_t
aAppUnitsPerPixel
)
{
float
scale
=
mozilla
:
:
AppUnitsPerCSSPixel
(
)
/
float
(
aAppUnitsPerPixel
)
;
CSSPoint
p
=
Convert2DPosition
(
aX
aY
aRefBox
)
;
return
{
p
.
x
*
scale
p
.
y
*
scale
}
;
}
bool
Decompose2DMatrix
(
const
Matrix
&
aMatrix
Point3D
&
aScale
ShearArray
&
aShear
gfxQuaternion
&
aRotate
Point3D
&
aTranslate
)
{
float
A
=
aMatrix
.
_11
B
=
aMatrix
.
_12
C
=
aMatrix
.
_21
D
=
aMatrix
.
_22
;
if
(
A
*
D
=
=
B
*
C
)
{
return
false
;
}
float
scaleX
=
sqrt
(
A
*
A
+
B
*
B
)
;
A
/
=
scaleX
;
B
/
=
scaleX
;
float
XYshear
=
A
*
C
+
B
*
D
;
C
-
=
A
*
XYshear
;
D
-
=
B
*
XYshear
;
float
scaleY
=
sqrt
(
C
*
C
+
D
*
D
)
;
C
/
=
scaleY
;
D
/
=
scaleY
;
XYshear
/
=
scaleY
;
float
determinant
=
A
*
D
-
B
*
C
;
if
(
0
.
99
>
Abs
(
determinant
)
|
|
Abs
(
determinant
)
>
1
.
01
)
{
return
false
;
}
if
(
determinant
<
0
)
{
A
=
-
A
;
B
=
-
B
;
C
=
-
C
;
D
=
-
D
;
XYshear
=
-
XYshear
;
scaleX
=
-
scaleX
;
}
float
rotate
=
atan2f
(
B
A
)
;
aRotate
=
gfxQuaternion
(
0
0
sin
(
rotate
/
2
)
cos
(
rotate
/
2
)
)
;
aShear
[
ShearType
:
:
XY
]
=
XYshear
;
aScale
.
x
=
scaleX
;
aScale
.
y
=
scaleY
;
aTranslate
.
x
=
aMatrix
.
_31
;
aTranslate
.
y
=
aMatrix
.
_32
;
return
true
;
}
bool
Decompose3DMatrix
(
const
Matrix4x4
&
aMatrix
Point3D
&
aScale
ShearArray
&
aShear
gfxQuaternion
&
aRotate
Point3D
&
aTranslate
Point4D
&
aPerspective
)
{
Matrix4x4
local
=
aMatrix
;
if
(
local
[
3
]
[
3
]
=
=
0
)
{
return
false
;
}
local
.
Normalize
(
)
;
Matrix4x4
perspective
=
local
;
Point4D
empty
(
0
0
0
1
)
;
perspective
.
SetTransposedVector
(
3
empty
)
;
if
(
perspective
.
Determinant
(
)
=
=
0
.
0
)
{
return
false
;
}
if
(
local
[
0
]
[
3
]
!
=
0
|
|
local
[
1
]
[
3
]
!
=
0
|
|
local
[
2
]
[
3
]
!
=
0
)
{
aPerspective
=
local
.
TransposedVector
(
3
)
;
perspective
.
Invert
(
)
;
aPerspective
=
perspective
.
TransposeTransform4D
(
aPerspective
)
;
local
.
SetTransposedVector
(
3
empty
)
;
}
else
{
aPerspective
=
Point4D
(
0
0
0
1
)
;
}
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
aTranslate
[
i
]
=
local
[
3
]
[
i
]
;
local
[
3
]
[
i
]
=
0
;
}
aScale
.
x
=
local
[
0
]
.
Length
(
)
;
local
[
0
]
/
=
aScale
.
x
;
aShear
[
ShearType
:
:
XY
]
=
local
[
0
]
.
DotProduct
(
local
[
1
]
)
;
local
[
1
]
-
=
local
[
0
]
*
aShear
[
ShearType
:
:
XY
]
;
aScale
.
y
=
local
[
1
]
.
Length
(
)
;
local
[
1
]
/
=
aScale
.
y
;
aShear
[
ShearType
:
:
XY
]
/
=
aScale
.
y
;
aShear
[
ShearType
:
:
XZ
]
=
local
[
0
]
.
DotProduct
(
local
[
2
]
)
;
local
[
2
]
-
=
local
[
0
]
*
aShear
[
ShearType
:
:
XZ
]
;
aShear
[
ShearType
:
:
YZ
]
=
local
[
1
]
.
DotProduct
(
local
[
2
]
)
;
local
[
2
]
-
=
local
[
1
]
*
aShear
[
ShearType
:
:
YZ
]
;
aScale
.
z
=
local
[
2
]
.
Length
(
)
;
local
[
2
]
/
=
aScale
.
z
;
aShear
[
ShearType
:
:
XZ
]
/
=
aScale
.
z
;
aShear
[
ShearType
:
:
YZ
]
/
=
aScale
.
z
;
if
(
local
[
0
]
.
DotProduct
(
local
[
1
]
.
CrossProduct
(
local
[
2
]
)
)
<
0
)
{
aScale
*
=
-
1
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
local
[
i
]
*
=
-
1
;
}
}
aRotate
=
gfxQuaternion
(
local
)
;
return
true
;
}
}
