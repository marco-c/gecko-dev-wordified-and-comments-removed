#
include
"
nsStyleTransformMatrix
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRuleNode
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
nsCSSKeywords
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxQuaternion
.
h
"
#
include
<
limits
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
namespace
nsStyleTransformMatrix
{
void
TransformReferenceBox
:
:
EnsureDimensionsAreCached
(
)
{
if
(
mIsCached
)
{
return
;
}
MOZ_ASSERT
(
mFrame
)
;
mIsCached
=
true
;
if
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
{
if
(
!
nsLayoutUtils
:
:
SVGTransformBoxEnabled
(
)
)
{
mX
=
-
mFrame
-
>
GetPosition
(
)
.
x
;
mY
=
-
mFrame
-
>
GetPosition
(
)
.
y
;
Size
contextSize
=
nsSVGUtils
:
:
GetContextSize
(
mFrame
)
;
mWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
width
)
;
mHeight
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
height
)
;
}
else
if
(
mFrame
-
>
StyleDisplay
(
)
-
>
mTransformBox
=
=
NS_STYLE_TRANSFORM_BOX_FILL_BOX
)
{
gfxRect
bbox
=
nsSVGUtils
:
:
GetBBox
(
const_cast
<
nsIFrame
*
>
(
mFrame
)
)
;
nsRect
bboxInAppUnits
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
bbox
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
)
;
mX
=
bboxInAppUnits
.
x
-
mFrame
-
>
GetPosition
(
)
.
x
;
mY
=
bboxInAppUnits
.
y
-
mFrame
-
>
GetPosition
(
)
.
y
;
mWidth
=
bboxInAppUnits
.
width
;
mHeight
=
bboxInAppUnits
.
height
;
}
else
{
MOZ_ASSERT
(
mFrame
-
>
StyleDisplay
(
)
-
>
mTransformBox
=
=
NS_STYLE_TRANSFORM_BOX_VIEW_BOX
|
|
mFrame
-
>
StyleDisplay
(
)
-
>
mTransformBox
=
=
NS_STYLE_TRANSFORM_BOX_BORDER_BOX
"
Unexpected
value
for
'
transform
-
box
'
"
)
;
mX
=
-
mFrame
-
>
GetPosition
(
)
.
x
;
mY
=
-
mFrame
-
>
GetPosition
(
)
.
y
;
Size
contextSize
=
nsSVGUtils
:
:
GetContextSize
(
mFrame
)
;
mWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
width
)
;
mHeight
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
contextSize
.
height
)
;
}
return
;
}
nsRect
rect
;
#
ifndef
UNIFIED_CONTINUATIONS
rect
=
mFrame
-
>
GetRect
(
)
;
#
else
for
(
const
nsIFrame
*
currFrame
=
mFrame
-
>
FirstContinuation
(
)
;
currFrame
!
=
nullptr
;
currFrame
=
currFrame
-
>
GetNextContinuation
(
)
)
{
rect
.
UnionRect
(
result
nsRect
(
currFrame
-
>
GetOffsetTo
(
mFrame
)
currFrame
-
>
GetSize
(
)
)
)
;
}
#
endif
mX
=
0
;
mY
=
0
;
mWidth
=
rect
.
Width
(
)
;
mHeight
=
rect
.
Height
(
)
;
}
void
TransformReferenceBox
:
:
Init
(
const
nsSize
&
aDimensions
)
{
MOZ_ASSERT
(
!
mFrame
&
&
!
mIsCached
)
;
mX
=
0
;
mY
=
0
;
mWidth
=
aDimensions
.
width
;
mHeight
=
aDimensions
.
height
;
mIsCached
=
true
;
}
float
ProcessTranslatePart
(
const
nsCSSValue
&
aValue
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
*
aRefBox
TransformReferenceBox
:
:
DimensionGetter
aDimensionGetter
)
{
nscoord
offset
=
0
;
float
percent
=
0
.
0f
;
if
(
aValue
.
GetUnit
(
)
=
=
eCSSUnit_Percent
)
{
percent
=
aValue
.
GetPercentValue
(
)
;
}
else
if
(
aValue
.
GetUnit
(
)
=
=
eCSSUnit_Pixel
|
|
aValue
.
GetUnit
(
)
=
=
eCSSUnit_Number
)
{
return
aValue
.
GetFloatValue
(
)
;
}
else
if
(
aValue
.
IsCalcUnit
(
)
)
{
nsRuleNode
:
:
ComputedCalc
result
=
nsRuleNode
:
:
SpecifiedCalcToComputedCalc
(
aValue
aContext
aPresContext
aConditions
)
;
percent
=
result
.
mPercent
;
offset
=
result
.
mLength
;
}
else
{
offset
=
nsRuleNode
:
:
CalcLength
(
aValue
aContext
aPresContext
aConditions
)
;
}
float
translation
=
NSAppUnitsToFloatPixels
(
offset
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
;
if
(
percent
!
=
0
.
0f
&
&
aRefBox
)
{
translation
+
=
percent
*
NSAppUnitsToFloatPixels
(
(
aRefBox
-
>
*
aDimensionGetter
)
(
)
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
;
}
return
translation
;
}
static
void
ProcessMatrix
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
&
aRefBox
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
7
"
Invalid
array
!
"
)
;
gfxMatrix
result
;
result
.
_11
=
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
result
.
_12
=
aData
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
result
.
_21
=
aData
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
result
.
_22
=
aData
-
>
Item
(
4
)
.
GetFloatValue
(
)
;
result
.
_31
=
ProcessTranslatePart
(
aData
-
>
Item
(
5
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
result
.
_32
=
ProcessTranslatePart
(
aData
-
>
Item
(
6
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
aMatrix
=
result
*
aMatrix
;
}
static
void
ProcessMatrix3D
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
&
aRefBox
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
17
"
Invalid
array
!
"
)
;
Matrix4x4
temp
;
temp
.
_11
=
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
temp
.
_12
=
aData
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
temp
.
_13
=
aData
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
temp
.
_14
=
aData
-
>
Item
(
4
)
.
GetFloatValue
(
)
;
temp
.
_21
=
aData
-
>
Item
(
5
)
.
GetFloatValue
(
)
;
temp
.
_22
=
aData
-
>
Item
(
6
)
.
GetFloatValue
(
)
;
temp
.
_23
=
aData
-
>
Item
(
7
)
.
GetFloatValue
(
)
;
temp
.
_24
=
aData
-
>
Item
(
8
)
.
GetFloatValue
(
)
;
temp
.
_31
=
aData
-
>
Item
(
9
)
.
GetFloatValue
(
)
;
temp
.
_32
=
aData
-
>
Item
(
10
)
.
GetFloatValue
(
)
;
temp
.
_33
=
aData
-
>
Item
(
11
)
.
GetFloatValue
(
)
;
temp
.
_34
=
aData
-
>
Item
(
12
)
.
GetFloatValue
(
)
;
temp
.
_44
=
aData
-
>
Item
(
16
)
.
GetFloatValue
(
)
;
temp
.
_41
=
ProcessTranslatePart
(
aData
-
>
Item
(
13
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
temp
.
_42
=
ProcessTranslatePart
(
aData
-
>
Item
(
14
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
temp
.
_43
=
ProcessTranslatePart
(
aData
-
>
Item
(
15
)
aContext
aPresContext
aConditions
nullptr
)
;
aMatrix
=
temp
*
aMatrix
;
}
void
ProcessInterpolateMatrix
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
&
aRefBox
bool
*
aContains3dTransform
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
4
"
Invalid
array
!
"
)
;
Matrix4x4
matrix1
matrix2
;
if
(
aData
-
>
Item
(
1
)
.
GetUnit
(
)
=
=
eCSSUnit_List
)
{
matrix1
=
nsStyleTransformMatrix
:
:
ReadTransforms
(
aData
-
>
Item
(
1
)
.
GetListValue
(
)
aContext
aPresContext
aConditions
aRefBox
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
aContains3dTransform
)
;
}
if
(
aData
-
>
Item
(
2
)
.
GetUnit
(
)
=
=
eCSSUnit_List
)
{
matrix2
=
ReadTransforms
(
aData
-
>
Item
(
2
)
.
GetListValue
(
)
aContext
aPresContext
aConditions
aRefBox
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
aContains3dTransform
)
;
}
double
progress
=
aData
-
>
Item
(
3
)
.
GetPercentValue
(
)
;
aMatrix
=
StyleAnimationValue
:
:
InterpolateTransformMatrix
(
matrix1
matrix2
progress
)
*
aMatrix
;
}
static
void
ProcessTranslateX
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
&
aRefBox
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
x
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslateY
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
&
aRefBox
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
y
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslateZ
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
z
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
aContext
aPresContext
aConditions
nullptr
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslate
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
&
aRefBox
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
|
|
aData
-
>
Count
(
)
=
=
3
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
x
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
if
(
aData
-
>
Count
(
)
=
=
3
)
{
temp
.
y
=
ProcessTranslatePart
(
aData
-
>
Item
(
2
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
}
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessTranslate3D
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
&
aRefBox
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
4
"
Invalid
array
!
"
)
;
Point3D
temp
;
temp
.
x
=
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
temp
.
y
=
ProcessTranslatePart
(
aData
-
>
Item
(
2
)
aContext
aPresContext
aConditions
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
temp
.
z
=
ProcessTranslatePart
(
aData
-
>
Item
(
3
)
aContext
aPresContext
aConditions
nullptr
)
;
aMatrix
.
PreTranslate
(
temp
)
;
}
static
void
ProcessScaleHelper
(
Matrix4x4
&
aMatrix
float
aXScale
float
aYScale
float
aZScale
)
{
aMatrix
.
PreScale
(
aXScale
aYScale
aZScale
)
;
}
static
void
ProcessScaleX
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessScaleHelper
(
aMatrix
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
1
.
0f
1
.
0f
)
;
}
static
void
ProcessScaleY
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessScaleHelper
(
aMatrix
1
.
0f
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
1
.
0f
)
;
}
static
void
ProcessScaleZ
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessScaleHelper
(
aMatrix
1
.
0f
1
.
0f
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
)
;
}
static
void
ProcessScale3D
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
4
"
Bad
array
!
"
)
;
ProcessScaleHelper
(
aMatrix
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
aData
-
>
Item
(
2
)
.
GetFloatValue
(
)
aData
-
>
Item
(
3
)
.
GetFloatValue
(
)
)
;
}
static
void
ProcessScale
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
|
|
aData
-
>
Count
(
)
=
=
3
"
Bad
array
!
"
)
;
const
nsCSSValue
&
scaleX
=
aData
-
>
Item
(
1
)
;
const
nsCSSValue
&
scaleY
=
(
aData
-
>
Count
(
)
=
=
2
?
scaleX
:
aData
-
>
Item
(
2
)
)
;
ProcessScaleHelper
(
aMatrix
scaleX
.
GetFloatValue
(
)
scaleY
.
GetFloatValue
(
)
1
.
0f
)
;
}
static
void
ProcessSkewHelper
(
Matrix4x4
&
aMatrix
double
aXAngle
double
aYAngle
)
{
aMatrix
.
SkewXY
(
aXAngle
aYAngle
)
;
}
static
void
ProcessSkewX
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_ASSERTION
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessSkewHelper
(
aMatrix
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
0
.
0
)
;
}
static
void
ProcessSkewY
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_ASSERTION
(
aData
-
>
Count
(
)
=
=
2
"
Bad
array
!
"
)
;
ProcessSkewHelper
(
aMatrix
0
.
0
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
)
;
}
static
void
ProcessSkew
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_ASSERTION
(
aData
-
>
Count
(
)
=
=
2
|
|
aData
-
>
Count
(
)
=
=
3
"
Bad
array
!
"
)
;
double
xSkew
=
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
;
double
ySkew
=
(
aData
-
>
Count
(
)
=
=
2
?
0
.
0
:
aData
-
>
Item
(
2
)
.
GetAngleValueInRadians
(
)
)
;
ProcessSkewHelper
(
aMatrix
xSkew
ySkew
)
;
}
static
void
ProcessRotateZ
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
double
theta
=
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
;
aMatrix
.
RotateZ
(
theta
)
;
}
static
void
ProcessRotateX
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
double
theta
=
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
;
aMatrix
.
RotateX
(
theta
)
;
}
static
void
ProcessRotateY
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
double
theta
=
aData
-
>
Item
(
1
)
.
GetAngleValueInRadians
(
)
;
aMatrix
.
RotateY
(
theta
)
;
}
static
void
ProcessRotate3D
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
5
"
Invalid
array
!
"
)
;
double
theta
=
aData
-
>
Item
(
4
)
.
GetAngleValueInRadians
(
)
;
float
x
=
aData
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
float
y
=
aData
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
float
z
=
aData
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
Matrix4x4
temp
;
temp
.
SetRotateAxisAngle
(
x
y
z
theta
)
;
aMatrix
=
temp
*
aMatrix
;
}
static
void
ProcessPerspective
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
)
{
NS_PRECONDITION
(
aData
-
>
Count
(
)
=
=
2
"
Invalid
array
!
"
)
;
float
depth
=
std
:
:
max
(
ProcessTranslatePart
(
aData
-
>
Item
(
1
)
aContext
aPresContext
aConditions
nullptr
)
std
:
:
numeric_limits
<
float
>
:
:
epsilon
(
)
)
;
aMatrix
.
Perspective
(
depth
)
;
}
static
void
MatrixForTransformFunction
(
Matrix4x4
&
aMatrix
const
nsCSSValue
:
:
Array
*
aData
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
&
aRefBox
bool
*
aContains3dTransform
)
{
MOZ_ASSERT
(
aContains3dTransform
)
;
NS_PRECONDITION
(
aData
"
Why
did
you
want
to
get
data
from
a
null
array
?
"
)
;
switch
(
TransformFunctionOf
(
aData
)
)
{
case
eCSSKeyword_translatex
:
ProcessTranslateX
(
aMatrix
aData
aContext
aPresContext
aConditions
aRefBox
)
;
break
;
case
eCSSKeyword_translatey
:
ProcessTranslateY
(
aMatrix
aData
aContext
aPresContext
aConditions
aRefBox
)
;
break
;
case
eCSSKeyword_translatez
:
*
aContains3dTransform
=
true
;
ProcessTranslateZ
(
aMatrix
aData
aContext
aPresContext
aConditions
)
;
break
;
case
eCSSKeyword_translate
:
ProcessTranslate
(
aMatrix
aData
aContext
aPresContext
aConditions
aRefBox
)
;
break
;
case
eCSSKeyword_translate3d
:
*
aContains3dTransform
=
true
;
ProcessTranslate3D
(
aMatrix
aData
aContext
aPresContext
aConditions
aRefBox
)
;
break
;
case
eCSSKeyword_scalex
:
ProcessScaleX
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_scaley
:
ProcessScaleY
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_scalez
:
*
aContains3dTransform
=
true
;
ProcessScaleZ
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_scale
:
ProcessScale
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_scale3d
:
*
aContains3dTransform
=
true
;
ProcessScale3D
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_skewx
:
ProcessSkewX
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_skewy
:
ProcessSkewY
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_skew
:
ProcessSkew
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_rotatex
:
*
aContains3dTransform
=
true
;
ProcessRotateX
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_rotatey
:
*
aContains3dTransform
=
true
;
ProcessRotateY
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_rotatez
:
*
aContains3dTransform
=
true
;
MOZ_FALLTHROUGH
;
case
eCSSKeyword_rotate
:
ProcessRotateZ
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_rotate3d
:
*
aContains3dTransform
=
true
;
ProcessRotate3D
(
aMatrix
aData
)
;
break
;
case
eCSSKeyword_matrix
:
ProcessMatrix
(
aMatrix
aData
aContext
aPresContext
aConditions
aRefBox
)
;
break
;
case
eCSSKeyword_matrix3d
:
*
aContains3dTransform
=
true
;
ProcessMatrix3D
(
aMatrix
aData
aContext
aPresContext
aConditions
aRefBox
)
;
break
;
case
eCSSKeyword_interpolatematrix
:
ProcessInterpolateMatrix
(
aMatrix
aData
aContext
aPresContext
aConditions
aRefBox
aContains3dTransform
)
;
break
;
case
eCSSKeyword_perspective
:
*
aContains3dTransform
=
true
;
ProcessPerspective
(
aMatrix
aData
aContext
aPresContext
aConditions
)
;
break
;
default
:
NS_NOTREACHED
(
"
Unknown
transform
function
!
"
)
;
}
}
nsCSSKeyword
TransformFunctionOf
(
const
nsCSSValue
:
:
Array
*
aData
)
{
MOZ_ASSERT
(
aData
-
>
Item
(
0
)
.
GetUnit
(
)
=
=
eCSSUnit_Enumerated
)
;
return
aData
-
>
Item
(
0
)
.
GetKeywordValue
(
)
;
}
void
SetIdentityMatrix
(
nsCSSValue
:
:
Array
*
aMatrix
)
{
MOZ_ASSERT
(
aMatrix
"
aMatrix
should
be
non
-
null
"
)
;
nsCSSKeyword
tfunc
=
TransformFunctionOf
(
aMatrix
)
;
MOZ_ASSERT
(
tfunc
=
=
eCSSKeyword_matrix
|
|
tfunc
=
=
eCSSKeyword_matrix3d
"
Only
accept
matrix
and
matrix3d
"
)
;
if
(
tfunc
=
=
eCSSKeyword_matrix
)
{
MOZ_ASSERT
(
aMatrix
-
>
Count
(
)
=
=
7
"
Invalid
matrix
"
)
;
Matrix
m
;
for
(
size_t
i
=
0
;
i
<
6
;
+
+
i
)
{
aMatrix
-
>
Item
(
i
+
1
)
.
SetFloatValue
(
m
.
components
[
i
]
eCSSUnit_Number
)
;
}
return
;
}
MOZ_ASSERT
(
aMatrix
-
>
Count
(
)
=
=
17
"
Invalid
matrix3d
"
)
;
Matrix4x4
m
;
for
(
size_t
i
=
0
;
i
<
16
;
+
+
i
)
{
aMatrix
-
>
Item
(
i
+
1
)
.
SetFloatValue
(
m
.
components
[
i
]
eCSSUnit_Number
)
;
}
}
Matrix4x4
ReadTransforms
(
const
nsCSSValueList
*
aList
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
RuleNodeCacheConditions
&
aConditions
TransformReferenceBox
&
aRefBox
float
aAppUnitsPerMatrixUnit
bool
*
aContains3dTransform
)
{
Matrix4x4
result
;
for
(
const
nsCSSValueList
*
curr
=
aList
;
curr
!
=
nullptr
;
curr
=
curr
-
>
mNext
)
{
const
nsCSSValue
&
currElem
=
curr
-
>
mValue
;
if
(
currElem
.
GetUnit
(
)
!
=
eCSSUnit_Function
)
{
NS_ASSERTION
(
currElem
.
GetUnit
(
)
=
=
eCSSUnit_None
&
&
!
aList
-
>
mNext
"
stream
should
either
be
a
list
of
functions
or
a
"
"
lone
None
"
)
;
continue
;
}
NS_ASSERTION
(
currElem
.
GetArrayValue
(
)
-
>
Count
(
)
>
=
1
"
Incoming
function
is
too
short
!
"
)
;
MatrixForTransformFunction
(
result
currElem
.
GetArrayValue
(
)
aContext
aPresContext
aConditions
aRefBox
aContains3dTransform
)
;
}
float
scale
=
float
(
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
/
aAppUnitsPerMatrixUnit
;
result
.
PreScale
(
1
/
scale
1
/
scale
1
/
scale
)
;
result
.
PostScale
(
scale
scale
scale
)
;
return
result
;
}
bool
Decompose2DMatrix
(
const
Matrix
&
aMatrix
Point3D
&
aScale
ShearArray
&
aShear
gfxQuaternion
&
aRotate
Point3D
&
aTranslate
)
{
float
A
=
aMatrix
.
_11
B
=
aMatrix
.
_12
C
=
aMatrix
.
_21
D
=
aMatrix
.
_22
;
if
(
A
*
D
=
=
B
*
C
)
{
return
false
;
}
float
scaleX
=
sqrt
(
A
*
A
+
B
*
B
)
;
A
/
=
scaleX
;
B
/
=
scaleX
;
float
XYshear
=
A
*
C
+
B
*
D
;
C
-
=
A
*
XYshear
;
D
-
=
B
*
XYshear
;
float
scaleY
=
sqrt
(
C
*
C
+
D
*
D
)
;
C
/
=
scaleY
;
D
/
=
scaleY
;
XYshear
/
=
scaleY
;
NS_ASSERTION
(
0
.
99
<
Abs
(
A
*
D
-
B
*
C
)
&
&
Abs
(
A
*
D
-
B
*
C
)
<
1
.
01
"
determinant
should
now
be
1
or
-
1
"
)
;
if
(
A
*
D
<
B
*
C
)
{
A
=
-
A
;
B
=
-
B
;
C
=
-
C
;
D
=
-
D
;
XYshear
=
-
XYshear
;
scaleX
=
-
scaleX
;
}
float
rotate
=
atan2f
(
B
A
)
;
aRotate
=
gfxQuaternion
(
0
0
sin
(
rotate
/
2
)
cos
(
rotate
/
2
)
)
;
aShear
[
ShearType
:
:
XYSHEAR
]
=
XYshear
;
aScale
.
x
=
scaleX
;
aScale
.
y
=
scaleY
;
aTranslate
.
x
=
aMatrix
.
_31
;
aTranslate
.
y
=
aMatrix
.
_32
;
return
true
;
}
bool
Decompose3DMatrix
(
const
Matrix4x4
&
aMatrix
Point3D
&
aScale
ShearArray
&
aShear
gfxQuaternion
&
aRotate
Point3D
&
aTranslate
Point4D
&
aPerspective
)
{
Matrix4x4
local
=
aMatrix
;
if
(
local
[
3
]
[
3
]
=
=
0
)
{
return
false
;
}
local
.
Normalize
(
)
;
Matrix4x4
perspective
=
local
;
Point4D
empty
(
0
0
0
1
)
;
perspective
.
SetTransposedVector
(
3
empty
)
;
if
(
perspective
.
Determinant
(
)
=
=
0
.
0
)
{
return
false
;
}
if
(
local
[
0
]
[
3
]
!
=
0
|
|
local
[
1
]
[
3
]
!
=
0
|
|
local
[
2
]
[
3
]
!
=
0
)
{
aPerspective
=
local
.
TransposedVector
(
3
)
;
perspective
.
Invert
(
)
;
aPerspective
=
perspective
.
TransposeTransform4D
(
aPerspective
)
;
local
.
SetTransposedVector
(
3
empty
)
;
}
else
{
aPerspective
=
Point4D
(
0
0
0
1
)
;
}
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
aTranslate
[
i
]
=
local
[
3
]
[
i
]
;
local
[
3
]
[
i
]
=
0
;
}
aScale
.
x
=
local
[
0
]
.
Length
(
)
;
local
[
0
]
/
=
aScale
.
x
;
aShear
[
ShearType
:
:
XYSHEAR
]
=
local
[
0
]
.
DotProduct
(
local
[
1
]
)
;
local
[
1
]
-
=
local
[
0
]
*
aShear
[
ShearType
:
:
XYSHEAR
]
;
aScale
.
y
=
local
[
1
]
.
Length
(
)
;
local
[
1
]
/
=
aScale
.
y
;
aShear
[
ShearType
:
:
XYSHEAR
]
/
=
aScale
.
y
;
aShear
[
ShearType
:
:
XZSHEAR
]
=
local
[
0
]
.
DotProduct
(
local
[
2
]
)
;
local
[
2
]
-
=
local
[
0
]
*
aShear
[
ShearType
:
:
XZSHEAR
]
;
aShear
[
ShearType
:
:
YZSHEAR
]
=
local
[
1
]
.
DotProduct
(
local
[
2
]
)
;
local
[
2
]
-
=
local
[
1
]
*
aShear
[
ShearType
:
:
YZSHEAR
]
;
aScale
.
z
=
local
[
2
]
.
Length
(
)
;
local
[
2
]
/
=
aScale
.
z
;
aShear
[
ShearType
:
:
XZSHEAR
]
/
=
aScale
.
z
;
aShear
[
ShearType
:
:
YZSHEAR
]
/
=
aScale
.
z
;
if
(
local
[
0
]
.
DotProduct
(
local
[
1
]
.
CrossProduct
(
local
[
2
]
)
)
<
0
)
{
aScale
*
=
-
1
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
local
[
i
]
*
=
-
1
;
}
}
aRotate
=
gfxQuaternion
(
local
)
;
return
true
;
}
Matrix
CSSValueArrayTo2DMatrix
(
nsCSSValue
:
:
Array
*
aArray
)
{
MOZ_ASSERT
(
aArray
&
&
TransformFunctionOf
(
aArray
)
=
=
eCSSKeyword_matrix
&
&
aArray
-
>
Count
(
)
=
=
7
)
;
Matrix
m
(
aArray
-
>
Item
(
1
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
2
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
3
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
4
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
5
)
.
GetFloatValue
(
)
aArray
-
>
Item
(
6
)
.
GetFloatValue
(
)
)
;
return
m
;
}
Matrix4x4
CSSValueArrayTo3DMatrix
(
nsCSSValue
:
:
Array
*
aArray
)
{
MOZ_ASSERT
(
aArray
&
&
TransformFunctionOf
(
aArray
)
=
=
eCSSKeyword_matrix3d
&
&
aArray
-
>
Count
(
)
=
=
17
)
;
gfx
:
:
Float
array
[
16
]
;
for
(
size_t
i
=
0
;
i
<
16
;
+
+
i
)
{
array
[
i
]
=
aArray
-
>
Item
(
i
+
1
)
.
GetFloatValue
(
)
;
}
Matrix4x4
m
(
array
)
;
return
m
;
}
}
