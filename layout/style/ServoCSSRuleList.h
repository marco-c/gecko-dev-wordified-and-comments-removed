#
ifndef
mozilla_ServoCSSRuleList_h
#
define
mozilla_ServoCSSRuleList_h
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
dom
/
CSSRuleList
.
h
"
namespace
mozilla
{
namespace
dom
{
class
CSSStyleRule
;
}
class
StyleSheet
;
namespace
css
{
class
GroupRule
;
class
Rule
;
}
class
ServoCSSRuleList
final
:
public
dom
:
:
CSSRuleList
{
public
:
ServoCSSRuleList
(
already_AddRefed
<
ServoCssRules
>
aRawRules
StyleSheet
*
aSheet
css
:
:
GroupRule
*
aParentRule
)
;
css
:
:
GroupRule
*
GetParentRule
(
)
const
{
return
mParentRule
;
}
void
DropSheetReference
(
)
;
void
DropParentRuleReference
(
)
;
void
DropReferences
(
)
{
DropSheetReference
(
)
;
DropParentRuleReference
(
)
;
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
ServoCSSRuleList
dom
:
:
CSSRuleList
)
StyleSheet
*
GetParentObject
(
)
final
{
return
mStyleSheet
;
}
css
:
:
Rule
*
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
final
;
uint32_t
Length
(
)
final
{
return
mRules
.
Length
(
)
;
}
css
:
:
Rule
*
GetRule
(
uint32_t
aIndex
)
;
nsresult
InsertRule
(
const
nsACString
&
aRule
uint32_t
aIndex
)
;
nsresult
DeleteRule
(
uint32_t
aIndex
)
;
uint16_t
GetDOMCSSRuleType
(
uint32_t
aIndex
)
const
;
private
:
virtual
~
ServoCSSRuleList
(
)
;
static
const
uintptr_t
kMaxRuleType
=
UINT8_MAX
;
static
uintptr_t
CastToUint
(
css
:
:
Rule
*
aPtr
)
{
return
reinterpret_cast
<
uintptr_t
>
(
aPtr
)
;
}
static
css
:
:
Rule
*
CastToPtr
(
uintptr_t
aInt
)
{
MOZ_ASSERT
(
aInt
>
kMaxRuleType
)
;
return
reinterpret_cast
<
css
:
:
Rule
*
>
(
aInt
)
;
}
template
<
typename
Func
>
void
EnumerateInstantiatedRules
(
Func
aCallback
)
;
void
DropAllRules
(
)
;
bool
IsReadOnly
(
)
const
;
StyleSheet
*
mStyleSheet
=
nullptr
;
css
:
:
GroupRule
*
mParentRule
=
nullptr
;
RefPtr
<
ServoCssRules
>
mRawRules
;
nsTArray
<
uintptr_t
>
mRules
;
}
;
}
#
endif
