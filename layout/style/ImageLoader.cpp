#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
Image
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderUserData
.
h
"
namespace
mozilla
{
namespace
css
{
void
ImageLoader
:
:
Init
(
)
{
sImages
=
new
nsClassHashtable
<
nsUint64HashKey
ImageTableEntry
>
(
)
;
}
void
ImageLoader
:
:
Shutdown
(
)
{
delete
sImages
;
sImages
=
nullptr
;
}
void
ImageLoader
:
:
DropDocumentReference
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ClearFrames
(
GetPresContext
(
)
)
;
for
(
auto
it
=
mRegisteredImages
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
if
(
imgRequestProxy
*
request
=
it
.
Data
(
)
)
{
request
-
>
CancelAndForgetObserver
(
NS_BINDING_ABORTED
)
;
}
uint64_t
imageLoadID
=
it
.
Key
(
)
;
if
(
auto
entry
=
sImages
-
>
Lookup
(
imageLoadID
)
)
{
entry
.
Data
(
)
-
>
mImageLoaders
.
RemoveEntry
(
this
)
;
}
}
mRegisteredImages
.
Clear
(
)
;
mDocument
=
nullptr
;
}
template
<
typename
Elem
typename
Item
typename
Comparator
=
nsDefaultComparator
<
Elem
Item
>
>
static
size_t
GetMaybeSortedIndex
(
const
nsTArray
<
Elem
>
&
aArray
const
Item
&
aItem
bool
*
aFound
Comparator
aComparator
=
Comparator
(
)
)
{
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
size_t
index
=
aArray
.
IndexOf
(
aItem
0
aComparator
)
;
*
aFound
=
index
!
=
nsTArray
<
Elem
>
:
:
NoIndex
;
return
*
aFound
?
index
+
1
:
aArray
.
Length
(
)
;
}
size_t
index
=
aArray
.
IndexOfFirstElementGt
(
aItem
aComparator
)
;
*
aFound
=
index
>
0
&
&
aComparator
.
Equals
(
aItem
aArray
.
ElementAt
(
index
-
1
)
)
;
return
index
;
}
void
ImageLoader
:
:
AssociateRequestToFrame
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
FrameFlags
aFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
imgINotificationObserver
>
observer
;
aRequest
-
>
GetNotificationObserver
(
getter_AddRefs
(
observer
)
)
;
if
(
!
observer
)
{
return
;
}
MOZ_ASSERT
(
observer
=
=
this
)
;
FrameSet
*
frameSet
=
mRequestToFrameMap
.
LookupForAdd
(
aRequest
)
.
OrInsert
(
[
=
]
(
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
nsLayoutUtils
:
:
RegisterImageRequestIfAnimated
(
presContext
aRequest
nullptr
)
;
}
return
new
FrameSet
(
)
;
}
)
;
RequestSet
*
requestSet
=
mFrameToRequestMap
.
LookupForAdd
(
aFrame
)
.
OrInsert
(
[
=
]
(
)
{
aFrame
-
>
SetHasImageRequest
(
true
)
;
return
new
RequestSet
(
)
;
}
)
;
FrameWithFlags
fwf
(
aFrame
)
;
FrameWithFlags
*
fwfToModify
(
&
fwf
)
;
bool
found
;
uint32_t
i
=
GetMaybeSortedIndex
(
*
frameSet
fwf
&
found
FrameOnlyComparator
(
)
)
;
if
(
found
)
{
fwfToModify
=
&
frameSet
-
>
ElementAt
(
i
-
1
)
;
}
if
(
aFlags
&
REQUEST_REQUIRES_REFLOW
)
{
fwfToModify
-
>
mFlags
|
=
REQUEST_REQUIRES_REFLOW
;
if
(
(
fwfToModify
-
>
mFlags
&
REQUEST_HAS_BLOCKED_ONLOAD
)
=
=
0
)
{
uint32_t
status
=
0
;
if
(
NS_SUCCEEDED
(
aRequest
-
>
GetImageStatus
(
&
status
)
)
&
&
!
(
status
&
imgIRequest
:
:
STATUS_ERROR
)
)
{
fwfToModify
-
>
mFlags
|
=
REQUEST_HAS_BLOCKED_ONLOAD
;
mDocument
-
>
BlockOnload
(
)
;
if
(
status
&
imgIRequest
:
:
STATUS_FRAME_COMPLETE
)
{
RequestReflowOnFrame
(
fwfToModify
aRequest
)
;
}
else
{
nsCOMPtr
<
imgIContainer
>
imgContainer
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
imgContainer
)
)
;
if
(
imgContainer
)
{
imgContainer
-
>
RequestDecodeForSize
(
gfx
:
:
IntSize
(
0
0
)
imgIContainer
:
:
DECODE_FLAGS_DEFAULT
)
;
}
else
{
aRequest
-
>
StartDecoding
(
imgIContainer
:
:
FLAG_NONE
)
;
}
}
}
}
}
DebugOnly
<
bool
>
didAddToFrameSet
(
false
)
;
DebugOnly
<
bool
>
didAddToRequestSet
(
false
)
;
if
(
!
found
)
{
frameSet
-
>
InsertElementAt
(
i
fwf
)
;
didAddToFrameSet
=
true
;
}
i
=
GetMaybeSortedIndex
(
*
requestSet
aRequest
&
found
)
;
if
(
!
found
)
{
requestSet
-
>
InsertElementAt
(
i
aRequest
)
;
didAddToRequestSet
=
true
;
}
MOZ_ASSERT
(
didAddToFrameSet
=
=
didAddToRequestSet
"
We
should
only
add
to
one
map
iff
we
also
add
to
the
other
map
.
"
)
;
}
imgRequestProxy
*
ImageLoader
:
:
RegisterCSSImage
(
URLValue
*
aImage
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aImage
)
;
if
(
aImage
-
>
LoadID
(
)
=
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Image
should
have
a
valid
LoadID
"
)
;
return
nullptr
;
}
if
(
imgRequestProxy
*
request
=
mRegisteredImages
.
GetWeak
(
aImage
-
>
LoadID
(
)
)
)
{
return
request
;
}
imgRequestProxy
*
canonicalRequest
=
nullptr
;
{
auto
entry
=
sImages
-
>
Lookup
(
aImage
-
>
LoadID
(
)
)
;
if
(
entry
)
{
canonicalRequest
=
entry
.
Data
(
)
-
>
mCanonicalRequest
;
}
if
(
!
canonicalRequest
)
{
return
nullptr
;
}
entry
.
Data
(
)
-
>
mImageLoaders
.
PutEntry
(
this
)
;
}
RefPtr
<
imgRequestProxy
>
request
;
mInClone
=
true
;
canonicalRequest
-
>
SyncClone
(
this
mDocument
getter_AddRefs
(
request
)
)
;
mInClone
=
false
;
MOZ_ASSERT
(
!
mRegisteredImages
.
Contains
(
aImage
-
>
LoadID
(
)
)
)
;
imgRequestProxy
*
requestWeak
=
request
;
mRegisteredImages
.
Put
(
aImage
-
>
LoadID
(
)
request
.
forget
(
)
)
;
return
requestWeak
;
}
void
ImageLoader
:
:
DeregisterCSSImageFromAllLoaders
(
URLValue
*
aImage
)
{
MOZ_ASSERT
(
aImage
)
;
uint64_t
loadID
=
aImage
-
>
LoadID
(
)
;
if
(
loadID
=
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Image
should
have
a
valid
LoadID
"
)
;
return
;
}
if
(
NS_IsMainThread
(
)
)
{
DeregisterCSSImageFromAllLoaders
(
loadID
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
css
:
:
ImageLoader
:
:
DeregisterCSSImageFromAllLoaders
"
[
loadID
]
{
DeregisterCSSImageFromAllLoaders
(
loadID
)
;
}
)
)
;
}
}
void
ImageLoader
:
:
DeregisterCSSImageFromAllLoaders
(
uint64_t
aImageLoadID
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aImageLoadID
!
=
0
)
;
if
(
auto
e
=
sImages
-
>
Lookup
(
aImageLoadID
)
)
{
ImageTableEntry
*
tableEntry
=
e
.
Data
(
)
;
if
(
imgRequestProxy
*
request
=
tableEntry
-
>
mCanonicalRequest
)
{
request
-
>
CancelAndForgetObserver
(
NS_BINDING_ABORTED
)
;
}
for
(
auto
iter
=
tableEntry
-
>
mImageLoaders
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ImageLoader
*
loader
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
auto
e
=
loader
-
>
mRegisteredImages
.
Lookup
(
aImageLoadID
)
)
{
if
(
imgRequestProxy
*
request
=
e
.
Data
(
)
)
{
request
-
>
CancelAndForgetObserver
(
NS_BINDING_ABORTED
)
;
}
e
.
Remove
(
)
;
}
}
e
.
Remove
(
)
;
}
}
void
ImageLoader
:
:
RemoveRequestToFrameMapping
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
)
{
#
ifdef
DEBUG
{
nsCOMPtr
<
imgINotificationObserver
>
observer
;
aRequest
-
>
GetNotificationObserver
(
getter_AddRefs
(
observer
)
)
;
MOZ_ASSERT
(
!
observer
|
|
observer
=
=
this
)
;
}
#
endif
if
(
auto
entry
=
mRequestToFrameMap
.
Lookup
(
aRequest
)
)
{
FrameSet
*
frameSet
=
entry
.
Data
(
)
;
MOZ_ASSERT
(
frameSet
"
This
should
never
be
null
"
)
;
bool
found
;
uint32_t
i
=
GetMaybeSortedIndex
(
*
frameSet
FrameWithFlags
(
aFrame
)
&
found
FrameOnlyComparator
(
)
)
;
if
(
found
)
{
FrameWithFlags
&
fwf
=
frameSet
-
>
ElementAt
(
i
-
1
)
;
if
(
fwf
.
mFlags
&
REQUEST_HAS_BLOCKED_ONLOAD
)
{
mDocument
-
>
UnblockOnload
(
false
)
;
}
frameSet
-
>
RemoveElementAt
(
i
-
1
)
;
}
if
(
frameSet
-
>
IsEmpty
(
)
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
nsLayoutUtils
:
:
DeregisterImageRequest
(
presContext
aRequest
nullptr
)
;
}
entry
.
Remove
(
)
;
}
}
}
void
ImageLoader
:
:
RemoveFrameToRequestMapping
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
)
{
if
(
auto
entry
=
mFrameToRequestMap
.
Lookup
(
aFrame
)
)
{
RequestSet
*
requestSet
=
entry
.
Data
(
)
;
MOZ_ASSERT
(
requestSet
"
This
should
never
be
null
"
)
;
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
requestSet
-
>
RemoveElement
(
aRequest
)
;
}
else
{
requestSet
-
>
RemoveElementSorted
(
aRequest
)
;
}
if
(
requestSet
-
>
IsEmpty
(
)
)
{
aFrame
-
>
SetHasImageRequest
(
false
)
;
entry
.
Remove
(
)
;
}
}
}
void
ImageLoader
:
:
DisassociateRequestFromFrame
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aFrame
-
>
HasImageRequest
(
)
"
why
call
me
?
"
)
;
RemoveRequestToFrameMapping
(
aRequest
aFrame
)
;
RemoveFrameToRequestMapping
(
aRequest
aFrame
)
;
}
void
ImageLoader
:
:
DropRequestsForFrame
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aFrame
-
>
HasImageRequest
(
)
"
why
call
me
?
"
)
;
nsAutoPtr
<
RequestSet
>
requestSet
;
mFrameToRequestMap
.
Remove
(
aFrame
&
requestSet
)
;
aFrame
-
>
SetHasImageRequest
(
false
)
;
if
(
MOZ_UNLIKELY
(
!
requestSet
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
HasImageRequest
was
lying
"
)
;
return
;
}
for
(
imgIRequest
*
request
:
*
requestSet
)
{
RemoveRequestToFrameMapping
(
request
aFrame
)
;
}
}
void
ImageLoader
:
:
SetAnimationMode
(
uint16_t
aMode
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ASSERTION
(
aMode
=
=
imgIContainer
:
:
kNormalAnimMode
|
|
aMode
=
=
imgIContainer
:
:
kDontAnimMode
|
|
aMode
=
=
imgIContainer
:
:
kLoopOnceAnimMode
"
Wrong
Animation
Mode
is
being
set
!
"
)
;
for
(
auto
iter
=
mRequestToFrameMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
request
=
static_cast
<
imgIRequest
*
>
(
iter
.
Key
(
)
)
;
#
ifdef
DEBUG
{
nsCOMPtr
<
imgIRequest
>
debugRequest
=
request
;
NS_ASSERTION
(
debugRequest
=
=
request
"
This
is
bad
"
)
;
}
#
endif
nsCOMPtr
<
imgIContainer
>
container
;
request
-
>
GetImage
(
getter_AddRefs
(
container
)
)
;
if
(
!
container
)
{
continue
;
}
container
-
>
SetAnimationMode
(
aMode
)
;
}
}
void
ImageLoader
:
:
ClearFrames
(
nsPresContext
*
aPresContext
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
auto
iter
=
mRequestToFrameMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
request
=
static_cast
<
imgIRequest
*
>
(
iter
.
Key
(
)
)
;
#
ifdef
DEBUG
{
nsCOMPtr
<
imgIRequest
>
debugRequest
=
request
;
NS_ASSERTION
(
debugRequest
=
=
request
"
This
is
bad
"
)
;
}
#
endif
if
(
aPresContext
)
{
nsLayoutUtils
:
:
DeregisterImageRequest
(
aPresContext
request
nullptr
)
;
}
}
mRequestToFrameMap
.
Clear
(
)
;
mFrameToRequestMap
.
Clear
(
)
;
}
void
ImageLoader
:
:
LoadImage
(
URLValue
*
aImage
Document
*
aLoadingDoc
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aLoadingDoc
)
;
MOZ_ASSERT
(
aImage
)
;
MOZ_ASSERT
(
aImage
-
>
LoadID
(
)
!
=
0
)
;
if
(
aImage
-
>
LoadID
(
)
=
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Image
should
have
a
valid
LoadID
"
)
;
return
;
}
ImageTableEntry
*
entry
;
{
auto
lookup
=
sImages
-
>
LookupForAdd
(
aImage
-
>
LoadID
(
)
)
;
if
(
lookup
)
{
return
;
}
entry
=
lookup
.
OrInsert
(
[
]
(
)
{
return
new
ImageTableEntry
(
)
;
}
)
;
}
nsIURI
*
uri
=
aImage
-
>
GetURI
(
)
;
if
(
!
uri
)
{
return
;
}
int32_t
loadFlags
=
nsIRequest
:
:
LOAD_NORMAL
|
nsContentUtils
:
:
CORSModeToLoadImageFlags
(
aImage
-
>
CorsMode
(
)
)
;
URLExtraData
*
data
=
aImage
-
>
ExtraData
(
)
;
RefPtr
<
imgRequestProxy
>
request
;
nsresult
rv
=
nsContentUtils
:
:
LoadImage
(
uri
aLoadingDoc
aLoadingDoc
data
-
>
Principal
(
)
0
data
-
>
GetReferrer
(
)
data
-
>
GetReferrerPolicy
(
)
nullptr
loadFlags
NS_LITERAL_STRING
(
"
css
"
)
getter_AddRefs
(
request
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
request
)
{
return
;
}
entry
-
>
mCanonicalRequest
=
std
:
:
move
(
request
)
;
}
nsPresContext
*
ImageLoader
:
:
GetPresContext
(
)
{
if
(
!
mDocument
)
{
return
nullptr
;
}
return
mDocument
-
>
GetPresContext
(
)
;
}
static
bool
IsRenderNoImages
(
uint32_t
aDisplayItemKey
)
{
DisplayItemType
type
=
GetDisplayItemTypeFromKey
(
aDisplayItemKey
)
;
uint8_t
flags
=
GetDisplayItemFlagsForType
(
type
)
;
return
flags
&
TYPE_RENDERS_NO_IMAGES
;
}
static
void
InvalidateImages
(
nsIFrame
*
aFrame
imgIRequest
*
aRequest
)
{
bool
invalidateFrame
=
false
;
const
SmallPointerArray
<
DisplayItemData
>
&
array
=
aFrame
-
>
DisplayItemData
(
)
;
for
(
uint32_t
i
=
0
;
i
<
array
.
Length
(
)
;
i
+
+
)
{
DisplayItemData
*
data
=
DisplayItemData
:
:
AssertDisplayItemData
(
array
.
ElementAt
(
i
)
)
;
uint32_t
displayItemKey
=
data
-
>
GetDisplayItemKey
(
)
;
if
(
displayItemKey
!
=
0
&
&
!
IsRenderNoImages
(
displayItemKey
)
)
{
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
DisplayItemType
type
=
GetDisplayItemTypeFromKey
(
displayItemKey
)
;
printf_stderr
(
"
Invalidating
display
item
(
type
=
%
d
)
based
on
frame
%
p
\
because
it
might
contain
an
invalidated
image
\
n
"
static_cast
<
uint32_t
>
(
type
)
aFrame
)
;
}
data
-
>
Invalidate
(
)
;
invalidateFrame
=
true
;
}
}
if
(
auto
userDataTable
=
aFrame
-
>
GetProperty
(
layers
:
:
WebRenderUserDataProperty
:
:
Key
(
)
)
)
{
for
(
auto
iter
=
userDataTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
layers
:
:
WebRenderUserData
>
data
=
iter
.
UserData
(
)
;
switch
(
data
-
>
GetType
(
)
)
{
case
layers
:
:
WebRenderUserData
:
:
UserDataType
:
:
eFallback
:
if
(
!
IsRenderNoImages
(
data
-
>
GetDisplayItemKey
(
)
)
)
{
static_cast
<
layers
:
:
WebRenderFallbackData
*
>
(
data
.
get
(
)
)
-
>
SetInvalid
(
true
)
;
}
invalidateFrame
=
true
;
break
;
case
layers
:
:
WebRenderUserData
:
:
UserDataType
:
:
eImage
:
if
(
static_cast
<
layers
:
:
WebRenderImageData
*
>
(
data
.
get
(
)
)
-
>
UsingSharedSurface
(
aRequest
-
>
GetProducerId
(
)
)
)
{
break
;
}
MOZ_FALLTHROUGH
;
default
:
invalidateFrame
=
true
;
break
;
}
}
}
if
(
invalidateFrame
)
{
aFrame
-
>
SchedulePaint
(
)
;
}
}
void
ImageLoader
:
:
RequestPaintIfNeeded
(
FrameSet
*
aFrameSet
imgIRequest
*
aRequest
bool
aForcePaint
)
{
NS_ASSERTION
(
aFrameSet
"
Must
have
a
frame
set
"
)
;
NS_ASSERTION
(
mDocument
"
Should
have
returned
earlier
!
"
)
;
for
(
FrameWithFlags
&
fwf
:
*
aFrameSet
)
{
nsIFrame
*
frame
=
fwf
.
mFrame
;
if
(
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
if
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
)
{
frame
-
>
InvalidateFrame
(
)
;
}
else
{
InvalidateImages
(
frame
aRequest
)
;
nsIFrame
*
f
=
frame
;
while
(
f
&
&
!
f
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
f
)
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
;
}
if
(
aForcePaint
)
{
frame
-
>
SchedulePaint
(
)
;
}
}
}
}
}
void
ImageLoader
:
:
UnblockOnloadIfNeeded
(
nsIFrame
*
aFrame
imgIRequest
*
aRequest
)
{
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
aRequest
)
;
FrameSet
*
frameSet
=
mRequestToFrameMap
.
Get
(
aRequest
)
;
if
(
!
frameSet
)
{
return
;
}
size_t
i
=
frameSet
-
>
BinaryIndexOf
(
FrameWithFlags
(
aFrame
)
FrameOnlyComparator
(
)
)
;
if
(
i
!
=
FrameSet
:
:
NoIndex
)
{
FrameWithFlags
&
fwf
=
frameSet
-
>
ElementAt
(
i
)
;
if
(
fwf
.
mFlags
&
REQUEST_HAS_BLOCKED_ONLOAD
)
{
mDocument
-
>
UnblockOnload
(
false
)
;
fwf
.
mFlags
&
=
~
REQUEST_HAS_BLOCKED_ONLOAD
;
}
}
}
void
ImageLoader
:
:
RequestReflowIfNeeded
(
FrameSet
*
aFrameSet
imgIRequest
*
aRequest
)
{
MOZ_ASSERT
(
aFrameSet
)
;
for
(
FrameWithFlags
&
fwf
:
*
aFrameSet
)
{
if
(
fwf
.
mFlags
&
REQUEST_REQUIRES_REFLOW
)
{
RequestReflowOnFrame
(
&
fwf
aRequest
)
;
}
}
}
void
ImageLoader
:
:
RequestReflowOnFrame
(
FrameWithFlags
*
aFwf
imgIRequest
*
aRequest
)
{
nsIFrame
*
frame
=
aFwf
-
>
mFrame
;
nsIFrame
*
parent
=
frame
-
>
GetInFlowParent
(
)
;
parent
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
parent
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
ImageReflowCallback
*
unblocker
=
new
ImageReflowCallback
(
this
frame
aRequest
)
;
parent
-
>
PresShell
(
)
-
>
PostReflowCallback
(
unblocker
)
;
}
NS_IMPL_ADDREF
(
ImageLoader
)
NS_IMPL_RELEASE
(
ImageLoader
)
NS_INTERFACE_MAP_BEGIN
(
ImageLoader
)
NS_INTERFACE_MAP_ENTRY
(
imgINotificationObserver
)
NS_INTERFACE_MAP_END
NS_IMETHODIMP
ImageLoader
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
{
#
ifdef
MOZ_GECKO_PROFILER
nsCString
uriString
;
if
(
profiler_is_active
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
aRequest
-
>
GetFinalURI
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
uri
-
>
GetSpec
(
uriString
)
;
}
}
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
"
ImageLoader
:
:
Notify
"
OTHER
uriString
)
;
#
endif
if
(
aType
=
=
imgINotificationObserver
:
:
SIZE_AVAILABLE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
return
OnSizeAvailable
(
aRequest
image
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
IS_ANIMATED
)
{
return
OnImageIsAnimated
(
aRequest
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
FRAME_COMPLETE
)
{
return
OnFrameComplete
(
aRequest
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
FRAME_UPDATE
)
{
return
OnFrameUpdate
(
aRequest
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
DECODE_COMPLETE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
if
(
image
&
&
mDocument
)
{
image
-
>
PropagateUseCounters
(
mDocument
)
;
}
}
if
(
aType
=
=
imgINotificationObserver
:
:
LOAD_COMPLETE
)
{
return
OnLoadComplete
(
aRequest
)
;
}
return
NS_OK
;
}
nsresult
ImageLoader
:
:
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
NS_OK
;
}
aImage
-
>
SetAnimationMode
(
presContext
-
>
ImageAnimationMode
(
)
)
;
FrameSet
*
frameSet
=
mRequestToFrameMap
.
Get
(
aRequest
)
;
if
(
!
frameSet
)
{
return
NS_OK
;
}
for
(
FrameWithFlags
&
fwf
:
*
frameSet
)
{
nsIFrame
*
frame
=
fwf
.
mFrame
;
if
(
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
frame
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
}
return
NS_OK
;
}
nsresult
ImageLoader
:
:
OnImageIsAnimated
(
imgIRequest
*
aRequest
)
{
if
(
!
mDocument
)
{
return
NS_OK
;
}
FrameSet
*
frameSet
=
mRequestToFrameMap
.
Get
(
aRequest
)
;
if
(
!
frameSet
)
{
return
NS_OK
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
nsLayoutUtils
:
:
RegisterImageRequest
(
presContext
aRequest
nullptr
)
;
}
return
NS_OK
;
}
nsresult
ImageLoader
:
:
OnFrameComplete
(
imgIRequest
*
aRequest
)
{
if
(
!
mDocument
|
|
mInClone
)
{
return
NS_OK
;
}
FrameSet
*
frameSet
=
mRequestToFrameMap
.
Get
(
aRequest
)
;
if
(
!
frameSet
)
{
return
NS_OK
;
}
RequestReflowIfNeeded
(
frameSet
aRequest
)
;
RequestPaintIfNeeded
(
frameSet
aRequest
true
)
;
return
NS_OK
;
}
nsresult
ImageLoader
:
:
OnFrameUpdate
(
imgIRequest
*
aRequest
)
{
if
(
!
mDocument
|
|
mInClone
)
{
return
NS_OK
;
}
FrameSet
*
frameSet
=
mRequestToFrameMap
.
Get
(
aRequest
)
;
if
(
!
frameSet
)
{
return
NS_OK
;
}
RequestPaintIfNeeded
(
frameSet
aRequest
false
)
;
return
NS_OK
;
}
nsresult
ImageLoader
:
:
OnLoadComplete
(
imgIRequest
*
aRequest
)
{
if
(
!
mDocument
|
|
mInClone
)
{
return
NS_OK
;
}
FrameSet
*
frameSet
=
mRequestToFrameMap
.
Get
(
aRequest
)
;
if
(
!
frameSet
)
{
return
NS_OK
;
}
uint32_t
status
=
0
;
if
(
NS_SUCCEEDED
(
aRequest
-
>
GetImageStatus
(
&
status
)
)
&
&
status
&
imgIRequest
:
:
STATUS_ERROR
)
{
for
(
FrameWithFlags
&
fwf
:
*
frameSet
)
{
if
(
fwf
.
mFlags
&
REQUEST_HAS_BLOCKED_ONLOAD
)
{
mDocument
-
>
UnblockOnload
(
false
)
;
fwf
.
mFlags
&
=
~
REQUEST_HAS_BLOCKED_ONLOAD
;
}
}
}
return
NS_OK
;
}
void
ImageLoader
:
:
FlushUseCounters
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
auto
iter
=
mRegisteredImages
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
imgRequestProxy
*
request
=
iter
.
Data
(
)
)
{
nsCOMPtr
<
imgIContainer
>
container
;
request
-
>
GetImage
(
getter_AddRefs
(
container
)
)
;
if
(
container
)
{
static_cast
<
image
:
:
Image
*
>
(
container
.
get
(
)
)
-
>
ReportUseCounters
(
)
;
}
}
}
}
bool
ImageLoader
:
:
ImageReflowCallback
:
:
ReflowFinished
(
)
{
if
(
mFrame
.
IsAlive
(
)
)
{
mLoader
-
>
UnblockOnloadIfNeeded
(
mFrame
mRequest
)
;
}
delete
this
;
return
false
;
}
void
ImageLoader
:
:
ImageReflowCallback
:
:
ReflowCallbackCanceled
(
)
{
if
(
mFrame
.
IsAlive
(
)
)
{
mLoader
-
>
UnblockOnloadIfNeeded
(
mFrame
mRequest
)
;
}
delete
this
;
}
nsClassHashtable
<
nsUint64HashKey
ImageLoader
:
:
ImageTableEntry
>
*
ImageLoader
:
:
sImages
=
nullptr
;
}
}
