#
include
"
nsStyleUtil
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsROCSSPrimitiveValue
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
<
cctype
>
using
namespace
mozilla
;
bool
nsStyleUtil
:
:
DashMatchCompare
(
const
nsAString
&
aAttributeValue
const
nsAString
&
aSelectorValue
const
nsStringComparator
&
aComparator
)
{
bool
result
;
uint32_t
selectorLen
=
aSelectorValue
.
Length
(
)
;
uint32_t
attributeLen
=
aAttributeValue
.
Length
(
)
;
if
(
selectorLen
>
attributeLen
)
{
result
=
false
;
}
else
{
nsAString
:
:
const_iterator
iter
;
if
(
selectorLen
!
=
attributeLen
&
&
*
aAttributeValue
.
BeginReading
(
iter
)
.
advance
(
selectorLen
)
!
=
char16_t
(
'
-
'
)
)
{
result
=
false
;
}
else
{
result
=
StringBeginsWith
(
aAttributeValue
aSelectorValue
aComparator
)
;
}
}
return
result
;
}
bool
nsStyleUtil
:
:
ValueIncludes
(
const
nsAString
&
aValueList
const
nsAString
&
aValue
const
nsStringComparator
&
aComparator
)
{
const
char16_t
*
p
=
aValueList
.
BeginReading
(
)
*
p_end
=
aValueList
.
EndReading
(
)
;
while
(
p
<
p_end
)
{
while
(
p
!
=
p_end
&
&
nsContentUtils
:
:
IsHTMLWhitespace
(
*
p
)
)
+
+
p
;
const
char16_t
*
val_start
=
p
;
while
(
p
!
=
p_end
&
&
!
nsContentUtils
:
:
IsHTMLWhitespace
(
*
p
)
)
+
+
p
;
const
char16_t
*
val_end
=
p
;
if
(
val_start
<
val_end
&
&
aValue
.
Equals
(
Substring
(
val_start
val_end
)
aComparator
)
)
return
true
;
+
+
p
;
}
return
false
;
}
void
nsStyleUtil
:
:
AppendEscapedCSSString
(
const
nsAString
&
aString
nsAString
&
aReturn
char16_t
quoteChar
)
{
MOZ_ASSERT
(
quoteChar
=
=
'
\
'
'
|
|
quoteChar
=
=
'
"
'
"
CSS
strings
must
be
quoted
with
'
or
\
"
"
)
;
aReturn
.
Append
(
quoteChar
)
;
const
char16_t
*
in
=
aString
.
BeginReading
(
)
;
const
char16_t
*
const
end
=
aString
.
EndReading
(
)
;
for
(
;
in
!
=
end
;
in
+
+
)
{
if
(
*
in
<
0x20
|
|
*
in
=
=
0x7F
)
{
aReturn
.
AppendPrintf
(
"
\
\
%
x
"
*
in
)
;
}
else
{
if
(
*
in
=
=
'
"
'
|
|
*
in
=
=
'
\
'
'
|
|
*
in
=
=
'
\
\
'
)
{
aReturn
.
Append
(
char16_t
(
'
\
\
'
)
)
;
}
aReturn
.
Append
(
*
in
)
;
}
}
aReturn
.
Append
(
quoteChar
)
;
}
void
nsStyleUtil
:
:
AppendEscapedCSSIdent
(
const
nsAString
&
aIdent
nsAString
&
aReturn
)
{
const
char16_t
*
in
=
aIdent
.
BeginReading
(
)
;
const
char16_t
*
const
end
=
aIdent
.
EndReading
(
)
;
if
(
in
=
=
end
)
return
;
if
(
*
in
=
=
'
-
'
)
{
if
(
in
+
1
=
=
end
)
{
aReturn
.
Append
(
char16_t
(
'
\
\
'
)
)
;
aReturn
.
Append
(
char16_t
(
'
-
'
)
)
;
return
;
}
aReturn
.
Append
(
char16_t
(
'
-
'
)
)
;
+
+
in
;
}
if
(
in
!
=
end
&
&
(
'
0
'
<
=
*
in
&
&
*
in
<
=
'
9
'
)
)
{
aReturn
.
AppendPrintf
(
"
\
\
%
x
"
*
in
)
;
+
+
in
;
}
for
(
;
in
!
=
end
;
+
+
in
)
{
char16_t
ch
=
*
in
;
if
(
ch
=
=
0x00
)
{
aReturn
.
Append
(
char16_t
(
0xFFFD
)
)
;
}
else
if
(
ch
<
0x20
|
|
0x7F
=
=
ch
)
{
aReturn
.
AppendPrintf
(
"
\
\
%
x
"
*
in
)
;
}
else
{
if
(
ch
<
0x7F
&
&
ch
!
=
'
_
'
&
&
ch
!
=
'
-
'
&
&
(
ch
<
'
0
'
|
|
'
9
'
<
ch
)
&
&
(
ch
<
'
A
'
|
|
'
Z
'
<
ch
)
&
&
(
ch
<
'
a
'
|
|
'
z
'
<
ch
)
)
{
aReturn
.
Append
(
char16_t
(
'
\
\
'
)
)
;
}
aReturn
.
Append
(
ch
)
;
}
}
}
void
nsStyleUtil
:
:
AppendBitmaskCSSValue
(
const
nsCSSKTableEntry
aTable
[
]
int32_t
aMaskedValue
int32_t
aFirstMask
int32_t
aLastMask
nsAString
&
aResult
)
{
for
(
int32_t
mask
=
aFirstMask
;
mask
<
=
aLastMask
;
mask
<
<
=
1
)
{
if
(
mask
&
aMaskedValue
)
{
AppendASCIItoUTF16
(
nsCSSProps
:
:
ValueToKeyword
(
mask
aTable
)
aResult
)
;
aMaskedValue
&
=
~
mask
;
if
(
aMaskedValue
)
{
aResult
.
Append
(
char16_t
(
'
'
)
)
;
}
}
}
MOZ_ASSERT
(
aMaskedValue
=
=
0
"
unexpected
bit
remaining
in
bitfield
"
)
;
}
void
nsStyleUtil
:
:
AppendAngleValue
(
const
nsStyleCoord
&
aAngle
nsAString
&
aResult
)
{
MOZ_ASSERT
(
aAngle
.
IsAngleValue
(
)
"
Should
have
angle
value
"
)
;
AppendCSSNumber
(
aAngle
.
GetAngleValue
(
)
aResult
)
;
switch
(
aAngle
.
GetUnit
(
)
)
{
case
eStyleUnit_Degree
:
aResult
.
AppendLiteral
(
"
deg
"
)
;
break
;
case
eStyleUnit_Grad
:
aResult
.
AppendLiteral
(
"
grad
"
)
;
break
;
case
eStyleUnit_Radian
:
aResult
.
AppendLiteral
(
"
rad
"
)
;
break
;
case
eStyleUnit_Turn
:
aResult
.
AppendLiteral
(
"
turn
"
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unrecognized
angle
unit
"
)
;
}
}
void
nsStyleUtil
:
:
AppendPaintOrderValue
(
uint8_t
aValue
nsAString
&
aResult
)
{
static_assert
(
NS_STYLE_PAINT_ORDER_BITWIDTH
*
NS_STYLE_PAINT_ORDER_LAST_VALUE
<
=
8
"
SVGStyleStruct
:
:
mPaintOrder
and
local
variables
not
big
enough
"
)
;
if
(
aValue
=
=
NS_STYLE_PAINT_ORDER_NORMAL
)
{
aResult
.
AppendLiteral
(
"
normal
"
)
;
return
;
}
static_assert
(
NS_STYLE_PAINT_ORDER_LAST_VALUE
=
=
3
"
paint
-
order
values
added
;
check
serialization
"
)
;
const
uint8_t
MASK
=
(
1
<
<
NS_STYLE_PAINT_ORDER_BITWIDTH
)
-
1
;
uint32_t
lastPositionToSerialize
=
0
;
for
(
uint32_t
position
=
NS_STYLE_PAINT_ORDER_LAST_VALUE
-
1
;
position
>
0
;
position
-
-
)
{
uint8_t
component
=
(
aValue
>
>
(
position
*
NS_STYLE_PAINT_ORDER_BITWIDTH
)
)
&
MASK
;
uint8_t
earlierComponent
=
(
aValue
>
>
(
(
position
-
1
)
*
NS_STYLE_PAINT_ORDER_BITWIDTH
)
)
&
MASK
;
if
(
component
<
earlierComponent
)
{
lastPositionToSerialize
=
position
-
1
;
break
;
}
}
for
(
uint32_t
position
=
0
;
position
<
=
lastPositionToSerialize
;
position
+
+
)
{
if
(
position
>
0
)
{
aResult
.
Append
(
'
'
)
;
}
uint8_t
component
=
aValue
&
MASK
;
switch
(
component
)
{
case
NS_STYLE_PAINT_ORDER_FILL
:
aResult
.
AppendLiteral
(
"
fill
"
)
;
break
;
case
NS_STYLE_PAINT_ORDER_STROKE
:
aResult
.
AppendLiteral
(
"
stroke
"
)
;
break
;
case
NS_STYLE_PAINT_ORDER_MARKERS
:
aResult
.
AppendLiteral
(
"
markers
"
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
paint
-
order
component
value
"
)
;
}
aValue
>
>
=
NS_STYLE_PAINT_ORDER_BITWIDTH
;
}
}
void
nsStyleUtil
:
:
AppendStepsTimingFunction
(
nsTimingFunction
:
:
Type
aType
uint32_t
aSteps
nsAString
&
aResult
)
{
MOZ_ASSERT
(
aType
=
=
nsTimingFunction
:
:
Type
:
:
StepStart
|
|
aType
=
=
nsTimingFunction
:
:
Type
:
:
StepEnd
)
;
aResult
.
AppendLiteral
(
"
steps
(
"
)
;
aResult
.
AppendInt
(
aSteps
)
;
if
(
aType
=
=
nsTimingFunction
:
:
Type
:
:
StepStart
)
{
aResult
.
AppendLiteral
(
"
start
)
"
)
;
}
else
{
aResult
.
AppendLiteral
(
"
)
"
)
;
}
}
void
nsStyleUtil
:
:
AppendFramesTimingFunction
(
uint32_t
aFrames
nsAString
&
aResult
)
{
aResult
.
AppendLiteral
(
"
frames
(
"
)
;
aResult
.
AppendInt
(
aFrames
)
;
aResult
.
AppendLiteral
(
"
)
"
)
;
}
void
nsStyleUtil
:
:
AppendCubicBezierTimingFunction
(
float
aX1
float
aY1
float
aX2
float
aY2
nsAString
&
aResult
)
{
aResult
.
AppendLiteral
(
"
cubic
-
bezier
(
"
)
;
aResult
.
AppendFloat
(
aX1
)
;
aResult
.
AppendLiteral
(
"
"
)
;
aResult
.
AppendFloat
(
aY1
)
;
aResult
.
AppendLiteral
(
"
"
)
;
aResult
.
AppendFloat
(
aX2
)
;
aResult
.
AppendLiteral
(
"
"
)
;
aResult
.
AppendFloat
(
aY2
)
;
aResult
.
Append
(
'
)
'
)
;
}
void
nsStyleUtil
:
:
AppendCubicBezierKeywordTimingFunction
(
nsTimingFunction
:
:
Type
aType
nsAString
&
aResult
)
{
switch
(
aType
)
{
case
nsTimingFunction
:
:
Type
:
:
Ease
:
case
nsTimingFunction
:
:
Type
:
:
Linear
:
case
nsTimingFunction
:
:
Type
:
:
EaseIn
:
case
nsTimingFunction
:
:
Type
:
:
EaseOut
:
case
nsTimingFunction
:
:
Type
:
:
EaseInOut
:
{
nsCSSKeyword
keyword
=
nsCSSProps
:
:
ValueToKeywordEnum
(
static_cast
<
int32_t
>
(
aType
)
nsCSSProps
:
:
kTransitionTimingFunctionKTable
)
;
AppendASCIItoUTF16
(
nsCSSKeywords
:
:
GetStringValue
(
keyword
)
aResult
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
aType
"
)
;
break
;
}
}
float
nsStyleUtil
:
:
ColorComponentToFloat
(
uint8_t
aAlpha
)
{
float
rounded
=
NS_roundf
(
float
(
aAlpha
)
*
100
.
0f
/
255
.
0f
)
/
100
.
0f
;
if
(
FloatToColorComponent
(
rounded
)
!
=
aAlpha
)
{
rounded
=
NS_roundf
(
float
(
aAlpha
)
*
1000
.
0f
/
255
.
0f
)
/
1000
.
0f
;
}
return
rounded
;
}
bool
nsStyleUtil
:
:
IsSignificantChild
(
nsIContent
*
aChild
bool
aWhitespaceIsSignificant
)
{
bool
isText
=
aChild
-
>
IsText
(
)
;
if
(
!
isText
&
&
!
aChild
-
>
IsComment
(
)
&
&
!
aChild
-
>
IsProcessingInstruction
(
)
)
{
return
true
;
}
return
isText
&
&
aChild
-
>
TextLength
(
)
!
=
0
&
&
(
aWhitespaceIsSignificant
|
|
!
aChild
-
>
TextIsOnlyWhitespace
(
)
)
;
}
bool
nsStyleUtil
:
:
ThreadSafeIsSignificantChild
(
const
nsIContent
*
aChild
bool
aWhitespaceIsSignificant
)
{
bool
isText
=
aChild
-
>
IsText
(
)
;
if
(
!
isText
&
&
!
aChild
-
>
IsComment
(
)
&
&
!
aChild
-
>
IsProcessingInstruction
(
)
)
{
return
true
;
}
return
isText
&
&
aChild
-
>
TextLength
(
)
!
=
0
&
&
(
aWhitespaceIsSignificant
|
|
!
aChild
-
>
ThreadSafeTextIsOnlyWhitespace
(
)
)
;
}
static
bool
ObjectPositionCoordMightCauseOverflow
(
const
Position
:
:
Coord
&
aCoord
)
{
if
(
aCoord
.
mLength
!
=
0
)
{
return
true
;
}
if
(
aCoord
.
mHasPercent
&
&
(
aCoord
.
mPercent
<
0
.
0f
|
|
aCoord
.
mPercent
>
1
.
0f
)
)
{
return
true
;
}
return
false
;
}
bool
nsStyleUtil
:
:
ObjectPropsMightCauseOverflow
(
const
nsStylePosition
*
aStylePos
)
{
auto
objectFit
=
aStylePos
-
>
mObjectFit
;
if
(
objectFit
=
=
NS_STYLE_OBJECT_FIT_COVER
|
|
objectFit
=
=
NS_STYLE_OBJECT_FIT_NONE
)
{
return
true
;
}
const
Position
&
objectPosistion
=
aStylePos
-
>
mObjectPosition
;
if
(
ObjectPositionCoordMightCauseOverflow
(
objectPosistion
.
mXPosition
)
|
|
ObjectPositionCoordMightCauseOverflow
(
objectPosistion
.
mYPosition
)
)
{
return
true
;
}
return
false
;
}
bool
nsStyleUtil
:
:
CSPAllowsInlineStyle
(
Element
*
aElement
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aTriggeringPrincipal
nsIURI
*
aSourceURI
uint32_t
aLineNumber
uint32_t
aColumnNumber
const
nsAString
&
aStyleText
nsresult
*
aRv
)
{
nsresult
rv
;
if
(
aRv
)
{
*
aRv
=
NS_OK
;
}
nsIPrincipal
*
principal
=
aPrincipal
;
if
(
aTriggeringPrincipal
&
&
BasePrincipal
:
:
Cast
(
aTriggeringPrincipal
)
-
>
OverridesCSP
(
aPrincipal
)
)
{
principal
=
aTriggeringPrincipal
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
rv
=
principal
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
aRv
)
*
aRv
=
rv
;
return
false
;
}
if
(
!
csp
)
{
return
true
;
}
nsAutoString
nonce
;
if
(
aElement
&
&
aElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
style
)
{
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
nonce
nonce
)
;
}
bool
allowInlineStyle
=
true
;
rv
=
csp
-
>
GetAllowsInline
(
nsIContentPolicy
:
:
TYPE_STYLESHEET
nonce
false
aElement
aStyleText
aLineNumber
aColumnNumber
&
allowInlineStyle
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
allowInlineStyle
;
}
void
nsStyleUtil
:
:
AppendFontSlantStyle
(
const
FontSlantStyle
&
aStyle
nsAString
&
aOut
)
{
if
(
aStyle
.
IsNormal
(
)
)
{
aOut
.
AppendLiteral
(
"
normal
"
)
;
}
else
if
(
aStyle
.
IsItalic
(
)
)
{
aOut
.
AppendLiteral
(
"
italic
"
)
;
}
else
{
aOut
.
AppendLiteral
(
"
oblique
"
)
;
auto
angle
=
aStyle
.
ObliqueAngle
(
)
;
if
(
angle
!
=
FontSlantStyle
:
:
kDefaultAngle
)
{
aOut
.
AppendLiteral
(
"
"
)
;
AppendAngleValue
(
nsStyleCoord
(
angle
eStyleUnit_Degree
)
aOut
)
;
}
}
}
