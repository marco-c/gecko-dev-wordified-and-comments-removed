#
include
"
mozilla
/
css
/
GroupRule
.
h
"
#
include
"
mozilla
/
dom
/
CSSRuleList
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
namespace
css
{
GroupRule
:
:
GroupRule
(
already_AddRefed
<
ServoCssRules
>
aRules
uint32_t
aLineNumber
uint32_t
aColumnNumber
)
:
Rule
(
aLineNumber
aColumnNumber
)
mRuleList
(
new
ServoCSSRuleList
(
std
:
:
move
(
aRules
)
nullptr
)
)
{
mRuleList
-
>
SetParentRule
(
this
)
;
}
GroupRule
:
:
~
GroupRule
(
)
{
MOZ_ASSERT
(
!
mSheet
"
SetStyleSheet
should
have
been
called
"
)
;
if
(
mRuleList
)
{
mRuleList
-
>
DropReference
(
)
;
}
}
NS_IMPL_ADDREF_INHERITED
(
GroupRule
Rule
)
NS_IMPL_RELEASE_INHERITED
(
GroupRule
Rule
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
GroupRule
)
NS_INTERFACE_MAP_END_INHERITING
(
Rule
)
bool
GroupRule
:
:
IsCCLeaf
(
)
const
{
return
false
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
GroupRule
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
GroupRule
Rule
)
if
(
tmp
-
>
mRuleList
)
{
tmp
-
>
mRuleList
-
>
SetParentRule
(
nullptr
)
;
if
(
tmp
-
>
GetStyleSheet
(
)
)
{
tmp
-
>
mRuleList
-
>
SetStyleSheet
(
nullptr
)
;
}
tmp
-
>
mRuleList
-
>
DropReference
(
)
;
tmp
-
>
mRuleList
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
GroupRule
Rule
)
ImplCycleCollectionTraverse
(
cb
tmp
-
>
mRuleList
"
mRuleList
"
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
#
ifdef
DEBUG
void
GroupRule
:
:
List
(
FILE
*
out
int32_t
aIndent
)
const
{
}
#
endif
void
GroupRule
:
:
SetStyleSheet
(
StyleSheet
*
aSheet
)
{
if
(
aSheet
!
=
GetStyleSheet
(
)
)
{
if
(
mRuleList
)
{
mRuleList
-
>
SetStyleSheet
(
aSheet
)
;
}
Rule
:
:
SetStyleSheet
(
aSheet
)
;
}
}
uint32_t
GroupRule
:
:
InsertRule
(
const
nsAString
&
aRule
uint32_t
aIndex
ErrorResult
&
aRv
)
{
StyleSheet
*
sheet
=
GetStyleSheet
(
)
;
if
(
NS_WARN_IF
(
!
sheet
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
0
;
}
uint32_t
count
=
StyleRuleCount
(
)
;
if
(
aIndex
>
count
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
0
;
}
NS_ASSERTION
(
count
<
=
INT32_MAX
"
Too
many
style
rules
!
"
)
;
nsresult
rv
=
sheet
-
>
InsertRuleIntoGroup
(
aRule
this
aIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
0
;
}
return
aIndex
;
}
void
GroupRule
:
:
DeleteRule
(
uint32_t
aIndex
ErrorResult
&
aRv
)
{
StyleSheet
*
sheet
=
GetStyleSheet
(
)
;
if
(
NS_WARN_IF
(
!
sheet
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
uint32_t
count
=
StyleRuleCount
(
)
;
if
(
aIndex
>
=
count
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
NS_ASSERTION
(
count
<
=
INT32_MAX
"
Too
many
style
rules
!
"
)
;
nsresult
rv
=
sheet
-
>
DeleteRuleFromGroup
(
this
aIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
size_t
GroupRule
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
}
}
