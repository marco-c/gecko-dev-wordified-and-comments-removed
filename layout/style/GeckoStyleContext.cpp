#
include
"
mozilla
/
GeckoStyleContext
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRuleNode
.
h
"
#
include
"
nsStyleContextInlines
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
RubyUtils
.
h
"
using
namespace
mozilla
;
GeckoStyleContext
:
:
GeckoStyleContext
(
nsStyleContext
*
aParent
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
already_AddRefed
<
nsRuleNode
>
aRuleNode
bool
aSkipParentDisplayBasedStyleFixup
)
:
nsStyleContext
(
aParent
OwningStyleContextSource
(
Move
(
aRuleNode
)
)
aPseudoTag
aPseudoType
)
mChild
(
nullptr
)
mEmptyChild
(
nullptr
)
{
mBits
|
=
NS_STYLE_CONTEXT_IS_GECKO
;
if
(
aParent
)
{
#
ifdef
DEBUG
nsRuleNode
*
r1
=
mParent
-
>
RuleNode
(
)
*
r2
=
mSource
.
AsGeckoRuleNode
(
)
;
while
(
r1
-
>
GetParent
(
)
)
r1
=
r1
-
>
GetParent
(
)
;
while
(
r2
-
>
GetParent
(
)
)
r2
=
r2
-
>
GetParent
(
)
;
NS_ASSERTION
(
r1
=
=
r2
"
must
be
in
the
same
rule
tree
as
parent
"
)
;
#
endif
}
else
{
PresContext
(
)
-
>
PresShell
(
)
-
>
StyleSet
(
)
-
>
RootStyleContextAdded
(
)
;
}
mSource
.
AsGeckoRuleNode
(
)
-
>
SetUsedDirectly
(
)
;
mNextSibling
=
this
;
mPrevSibling
=
this
;
FinishConstruction
(
)
;
ApplyStyleFixups
(
aSkipParentDisplayBasedStyleFixup
)
;
}
void
*
GeckoStyleContext
:
:
operator
new
(
size_t
sz
nsPresContext
*
aPresContext
)
{
MOZ_ASSERT
(
sz
=
=
sizeof
(
GeckoStyleContext
)
)
;
return
aPresContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
eArenaObjectID_GeckoStyleContext
sz
)
;
}
void
GeckoStyleContext
:
:
AddChild
(
GeckoStyleContext
*
aChild
)
{
NS_ASSERTION
(
aChild
-
>
mPrevSibling
=
=
aChild
&
&
aChild
-
>
mNextSibling
=
=
aChild
"
child
already
in
a
child
list
"
)
;
GeckoStyleContext
*
*
listPtr
=
aChild
-
>
mSource
.
MatchesNoRules
(
)
?
&
mEmptyChild
:
&
mChild
;
GeckoStyleContext
*
list
=
*
listPtr
;
if
(
list
)
{
aChild
-
>
mNextSibling
=
list
;
aChild
-
>
mPrevSibling
=
list
-
>
mPrevSibling
;
list
-
>
mPrevSibling
-
>
mNextSibling
=
aChild
;
list
-
>
mPrevSibling
=
aChild
;
}
(
*
listPtr
)
=
aChild
;
}
void
GeckoStyleContext
:
:
RemoveChild
(
GeckoStyleContext
*
aChild
)
{
NS_PRECONDITION
(
nullptr
!
=
aChild
&
&
this
=
=
aChild
-
>
mParent
"
bad
argument
"
)
;
GeckoStyleContext
*
*
list
=
aChild
-
>
mSource
.
MatchesNoRules
(
)
?
&
mEmptyChild
:
&
mChild
;
if
(
aChild
-
>
mPrevSibling
!
=
aChild
)
{
if
(
(
*
list
)
=
=
aChild
)
{
(
*
list
)
=
(
*
list
)
-
>
mNextSibling
;
}
}
else
{
NS_ASSERTION
(
(
*
list
)
=
=
aChild
"
bad
sibling
pointers
"
)
;
(
*
list
)
=
nullptr
;
}
aChild
-
>
mPrevSibling
-
>
mNextSibling
=
aChild
-
>
mNextSibling
;
aChild
-
>
mNextSibling
-
>
mPrevSibling
=
aChild
-
>
mPrevSibling
;
aChild
-
>
mNextSibling
=
aChild
;
aChild
-
>
mPrevSibling
=
aChild
;
}
#
ifdef
DEBUG
void
GeckoStyleContext
:
:
ListDescendants
(
FILE
*
out
int32_t
aIndent
)
{
if
(
nullptr
!
=
mChild
)
{
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
List
(
out
aIndent
+
1
true
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
nullptr
!
=
mEmptyChild
)
{
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
List
(
out
aIndent
+
1
true
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
#
endif
void
GeckoStyleContext
:
:
ClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
{
if
(
mChild
)
{
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
DoClearCachedInheritedStyleDataOnDescendants
(
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
mEmptyChild
)
{
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
DoClearCachedInheritedStyleDataOnDescendants
(
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
void
GeckoStyleContext
:
:
DoClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
{
NS_ASSERTION
(
mFrameRefCnt
=
=
0
"
frame
still
referencing
style
context
"
)
;
for
(
nsStyleStructID
i
=
nsStyleStructID_Inherited_Start
;
i
<
nsStyleStructID_Inherited_Start
+
nsStyleStructID_Inherited_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
aStructs
&
bit
)
{
if
(
!
(
mBits
&
bit
)
&
&
mCachedInheritedData
.
mStyleStructs
[
i
]
)
{
aStructs
&
=
~
bit
;
}
else
{
mCachedInheritedData
.
mStyleStructs
[
i
]
=
nullptr
;
}
}
}
if
(
mCachedResetData
)
{
for
(
nsStyleStructID
i
=
nsStyleStructID_Reset_Start
;
i
<
nsStyleStructID_Reset_Start
+
nsStyleStructID_Reset_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
aStructs
&
bit
)
{
if
(
!
(
mBits
&
bit
)
&
&
mCachedResetData
-
>
mStyleStructs
[
i
]
)
{
aStructs
&
=
~
bit
;
}
else
{
mCachedResetData
-
>
mStyleStructs
[
i
]
=
nullptr
;
}
}
}
}
if
(
aStructs
=
=
0
)
{
return
;
}
ClearCachedInheritedStyleDataOnDescendants
(
aStructs
)
;
}
already_AddRefed
<
GeckoStyleContext
>
GeckoStyleContext
:
:
FindChildWithRules
(
const
nsIAtom
*
aPseudoTag
NonOwningStyleContextSource
aSource
NonOwningStyleContextSource
aSourceIfVisited
bool
aRelevantLinkVisited
)
{
uint32_t
threshold
=
10
;
RefPtr
<
GeckoStyleContext
>
result
;
GeckoStyleContext
*
list
=
aSource
.
MatchesNoRules
(
)
?
mEmptyChild
:
mChild
;
if
(
list
)
{
GeckoStyleContext
*
child
=
list
;
do
{
if
(
child
-
>
mSource
.
AsRaw
(
)
=
=
aSource
&
&
child
-
>
mPseudoTag
=
=
aPseudoTag
&
&
!
child
-
>
IsStyleIfVisited
(
)
&
&
child
-
>
RelevantLinkVisited
(
)
=
=
aRelevantLinkVisited
)
{
bool
match
=
false
;
if
(
!
aSourceIfVisited
.
IsNull
(
)
)
{
match
=
child
-
>
GetStyleIfVisited
(
)
&
&
child
-
>
GetStyleIfVisited
(
)
-
>
AsGecko
(
)
-
>
mSource
.
AsRaw
(
)
=
=
aSourceIfVisited
;
}
else
{
match
=
!
child
-
>
GetStyleIfVisited
(
)
;
}
if
(
match
&
&
!
(
child
-
>
mBits
&
NS_STYLE_INELIGIBLE_FOR_SHARING
)
)
{
result
=
child
;
break
;
}
}
child
=
child
-
>
mNextSibling
;
threshold
-
-
;
if
(
threshold
=
=
0
)
break
;
}
while
(
child
!
=
list
)
;
}
if
(
result
)
{
if
(
result
!
=
list
)
{
RemoveChild
(
result
)
;
AddChild
(
result
)
;
}
result
-
>
mBits
|
=
NS_STYLE_IS_SHARED
;
}
return
result
.
forget
(
)
;
}
void
*
GeckoStyleContext
:
:
GetUniqueStyleData
(
const
nsStyleStructID
&
aSID
)
{
const
void
*
current
=
StyleData
(
aSID
)
;
if
(
!
mChild
&
&
!
mEmptyChild
&
&
!
(
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
&
&
GetCachedStyleData
(
aSID
)
)
return
const_cast
<
void
*
>
(
current
)
;
void
*
result
;
nsPresContext
*
presContext
=
PresContext
(
)
;
switch
(
aSID
)
{
#
define
UNIQUE_CASE
(
c_
)
\
case
eStyleStruct_
#
#
c_
:
\
result
=
new
(
presContext
)
nsStyle
#
#
c_
(
\
*
static_cast
<
const
nsStyle
#
#
c_
*
>
(
current
)
)
;
\
break
;
UNIQUE_CASE
(
Font
)
UNIQUE_CASE
(
Display
)
UNIQUE_CASE
(
Text
)
UNIQUE_CASE
(
TextReset
)
UNIQUE_CASE
(
Visibility
)
#
undef
UNIQUE_CASE
default
:
NS_ERROR
(
"
Struct
type
not
supported
.
Please
find
another
way
to
do
this
if
you
can
!
"
)
;
return
nullptr
;
}
SetStyle
(
aSID
result
)
;
mBits
&
=
~
static_cast
<
uint64_t
>
(
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
;
return
result
;
}
void
*
GeckoStyleContext
:
:
CreateEmptyStyleData
(
const
nsStyleStructID
&
aSID
)
{
MOZ_ASSERT
(
!
mChild
&
&
!
mEmptyChild
&
&
!
(
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
&
&
!
GetCachedStyleData
(
aSID
)
"
This
style
should
not
have
been
computed
"
)
;
void
*
result
;
nsPresContext
*
presContext
=
PresContext
(
)
;
switch
(
aSID
)
{
#
define
UNIQUE_CASE
(
c_
)
\
case
eStyleStruct_
#
#
c_
:
\
result
=
new
(
presContext
)
nsStyle
#
#
c_
(
presContext
)
;
\
break
;
UNIQUE_CASE
(
Border
)
UNIQUE_CASE
(
Padding
)
#
undef
UNIQUE_CASE
default
:
NS_ERROR
(
"
Struct
type
not
supported
.
"
)
;
return
nullptr
;
}
SetStyle
(
aSID
result
)
;
return
result
;
}
void
GeckoStyleContext
:
:
SetIneligibleForSharing
(
)
{
if
(
mBits
&
NS_STYLE_INELIGIBLE_FOR_SHARING
)
{
return
;
}
mBits
|
=
NS_STYLE_INELIGIBLE_FOR_SHARING
;
if
(
mChild
)
{
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
SetIneligibleForSharing
(
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
mEmptyChild
)
{
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
SetIneligibleForSharing
(
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
void
GeckoStyleContext
:
:
LogChildStyleContextTree
(
uint32_t
aStructs
)
const
{
if
(
nullptr
!
=
mChild
)
{
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
LogStyleContextTree
(
false
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
nullptr
!
=
mEmptyChild
)
{
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
LogStyleContextTree
(
false
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
static
bool
ShouldSuppressLineBreak
(
const
nsStyleContext
*
aContext
const
nsStyleDisplay
*
aDisplay
const
nsStyleContext
*
aParentContext
const
nsStyleDisplay
*
aParentDisplay
)
{
if
(
aDisplay
-
>
IsOutOfFlowStyle
(
)
)
{
return
false
;
}
if
(
(
aContext
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
InheritingAnonBox
|
|
aContext
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
NonInheritingAnonBox
)
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
aContext
-
>
GetPseudo
(
)
)
&
&
!
RubyUtils
:
:
IsRubyPseudo
(
aContext
-
>
GetPseudo
(
)
)
)
{
return
false
;
}
if
(
aParentContext
-
>
ShouldSuppressLineBreak
(
)
)
{
if
(
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Inline
|
|
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
|
|
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Ruby
|
|
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
)
{
return
true
;
}
}
if
(
(
aParentDisplay
-
>
IsRubyDisplayType
(
)
&
&
aDisplay
-
>
mDisplay
!
=
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
&
&
aDisplay
-
>
mDisplay
!
=
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
)
|
|
aDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyBase
|
|
aDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyText
)
{
return
true
;
}
return
false
;
}
void
nsStyleContext
:
:
SetStyleBits
(
)
{
if
(
mParent
&
&
mParent
-
>
HasTextDecorationLines
(
)
)
{
AddStyleBit
(
NS_STYLE_HAS_TEXT_DECORATION_LINES
)
;
}
else
{
if
(
StyleTextReset
(
)
-
>
HasTextDecorationLines
(
)
)
{
AddStyleBit
(
NS_STYLE_HAS_TEXT_DECORATION_LINES
)
;
}
}
if
(
(
mParent
&
&
mParent
-
>
HasPseudoElementData
(
)
)
|
|
IsPseudoElement
(
)
)
{
AddStyleBit
(
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
)
;
}
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
(
mParent
&
&
mParent
-
>
IsInDisplayNoneSubtree
(
)
)
|
|
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
None
)
{
AddStyleBit
(
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
)
;
}
if
(
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
mozText
&
&
mParent
&
&
mParent
-
>
StyleVisibility
(
)
-
>
mWritingMode
!
=
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
&
&
mParent
-
>
StyleText
(
)
-
>
mTextCombineUpright
=
=
NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL
)
{
AddStyleBit
(
NS_STYLE_IS_TEXT_COMBINED
)
;
}
}
static
bool
ShouldBlockifyChildren
(
const
nsStyleDisplay
*
aStyleDisp
)
{
auto
displayVal
=
aStyleDisp
-
>
mDisplay
;
return
mozilla
:
:
StyleDisplay
:
:
Flex
=
=
displayVal
|
|
mozilla
:
:
StyleDisplay
:
:
InlineFlex
=
=
displayVal
|
|
mozilla
:
:
StyleDisplay
:
:
Grid
=
=
displayVal
|
|
mozilla
:
:
StyleDisplay
:
:
InlineGrid
=
=
displayVal
;
}
#
ifdef
DEBUG
void
GeckoStyleContext
:
:
AssertChildStructsNotUsedElsewhere
(
nsStyleContext
*
aDestroyingContext
int32_t
aLevels
)
const
{
if
(
mChild
)
{
const
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
AssertStructsNotUsedElsewhere
(
aDestroyingContext
aLevels
-
1
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
child
!
=
mChild
)
;
}
if
(
mEmptyChild
)
{
const
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
AssertStructsNotUsedElsewhere
(
aDestroyingContext
aLevels
-
1
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
child
!
=
mEmptyChild
)
;
}
}
#
endif
void
GeckoStyleContext
:
:
ApplyStyleFixups
(
bool
aSkipParentDisplayBasedStyleFixup
)
{
MOZ_ASSERT
(
!
mSource
.
IsServoComputedValues
(
)
"
Can
'
t
do
Gecko
style
fixups
on
Servo
values
"
)
;
#
define
GET_UNIQUE_STYLE_DATA
(
name_
)
\
static_cast
<
nsStyle
#
#
name_
*
>
(
GetUniqueStyleData
(
eStyleStruct_
#
#
name_
)
)
if
(
mPseudoTag
=
=
nsCSSPseudoElements
:
:
firstLetter
)
{
const
nsStyleTextReset
*
textReset
=
StyleTextReset
(
)
;
if
(
textReset
-
>
mInitialLetterSize
!
=
0
.
0f
)
{
nsStyleContext
*
containerSC
=
mParent
;
const
nsStyleDisplay
*
containerDisp
=
containerSC
-
>
StyleDisplay
(
)
;
while
(
containerDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
if
(
!
containerSC
-
>
GetParent
(
)
)
{
break
;
}
containerSC
=
containerSC
-
>
GetParent
(
)
;
containerDisp
=
containerSC
-
>
StyleDisplay
(
)
;
}
nscoord
containerLH
=
ReflowInput
:
:
CalcLineHeight
(
nullptr
containerSC
NS_AUTOHEIGHT
1
.
0f
)
;
RefPtr
<
nsFontMetrics
>
containerFM
=
nsLayoutUtils
:
:
GetFontMetricsForStyleContext
(
containerSC
)
;
MOZ_ASSERT
(
containerFM
"
Should
have
fontMetrics
!
!
"
)
;
nscoord
containerCH
=
containerFM
-
>
CapHeight
(
)
;
RefPtr
<
nsFontMetrics
>
firstLetterFM
=
nsLayoutUtils
:
:
GetFontMetricsForStyleContext
(
this
)
;
MOZ_ASSERT
(
firstLetterFM
"
Should
have
fontMetrics
!
!
"
)
;
nscoord
firstLetterCH
=
firstLetterFM
-
>
CapHeight
(
)
;
nsStyleFont
*
mutableStyleFont
=
GET_UNIQUE_STYLE_DATA
(
Font
)
;
float
invCapHeightRatio
=
mutableStyleFont
-
>
mFont
.
size
/
NSCoordToFloat
(
firstLetterCH
)
;
mutableStyleFont
-
>
mFont
.
size
=
NSToCoordRound
(
(
(
textReset
-
>
mInitialLetterSize
-
1
)
*
containerLH
+
containerCH
)
*
invCapHeightRatio
)
;
}
}
if
(
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
mozText
&
&
mParent
&
&
mParent
-
>
StyleVisibility
(
)
-
>
mWritingMode
!
=
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
&
&
mParent
-
>
StyleText
(
)
-
>
mTextCombineUpright
=
=
NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL
)
{
MOZ_ASSERT
(
!
PeekStyleVisibility
(
)
"
If
StyleVisibility
was
already
"
"
computed
some
properties
may
have
been
computed
"
"
incorrectly
based
on
the
old
writing
mode
value
"
)
;
nsStyleVisibility
*
mutableVis
=
GET_UNIQUE_STYLE_DATA
(
Visibility
)
;
mutableVis
-
>
mWritingMode
=
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
;
}
if
(
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
viewport
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
mozilla
:
:
dom
:
:
Element
*
docElement
=
presContext
-
>
Document
(
)
-
>
GetRootElement
(
)
;
if
(
docElement
)
{
RefPtr
<
nsStyleContext
>
rootStyle
=
presContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleFor
(
docElement
nullptr
)
;
auto
dir
=
rootStyle
-
>
StyleVisibility
(
)
-
>
mDirection
;
if
(
dir
!
=
StyleVisibility
(
)
-
>
mDirection
)
{
nsStyleVisibility
*
uniqueVisibility
=
GET_UNIQUE_STYLE_DATA
(
Visibility
)
;
uniqueVisibility
-
>
mDirection
=
dir
;
}
}
}
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Table
)
{
const
nsStyleText
*
text
=
StyleText
(
)
;
if
(
text
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_LEFT
|
|
text
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_CENTER
|
|
text
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_RIGHT
)
{
nsStyleText
*
uniqueText
=
GET_UNIQUE_STYLE_DATA
(
Text
)
;
uniqueText
-
>
mTextAlign
=
NS_STYLE_TEXT_ALIGN_START
;
}
}
if
(
!
mParent
&
&
(
!
mPseudoTag
|
|
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
viewport
|
|
mPseudoTag
=
=
nsCSSPseudoElements
:
:
backdrop
)
)
{
auto
displayVal
=
disp
-
>
mDisplay
;
if
(
displayVal
!
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
nsRuleNode
:
:
EnsureBlockDisplay
(
displayVal
true
)
;
}
else
{
displayVal
=
mozilla
:
:
StyleDisplay
:
:
Block
;
}
if
(
displayVal
!
=
disp
-
>
mDisplay
)
{
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mOriginalDisplay
=
mutable_display
-
>
mDisplay
=
displayVal
;
}
}
if
(
!
aSkipParentDisplayBasedStyleFixup
&
&
mParent
)
{
nsStyleContext
*
containerContext
=
mParent
;
const
nsStyleDisplay
*
containerDisp
=
containerContext
-
>
StyleDisplay
(
)
;
while
(
containerDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
if
(
!
containerContext
-
>
GetParent
(
)
)
{
break
;
}
containerContext
=
containerContext
-
>
GetParent
(
)
;
containerDisp
=
containerContext
-
>
StyleDisplay
(
)
;
}
if
(
ShouldBlockifyChildren
(
containerDisp
)
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
GetPseudo
(
)
)
)
{
auto
displayVal
=
disp
-
>
mDisplay
;
nsRuleNode
:
:
EnsureBlockDisplay
(
displayVal
)
;
if
(
displayVal
!
=
disp
-
>
mDisplay
)
{
NS_ASSERTION
(
!
disp
-
>
IsAbsolutelyPositionedStyle
(
)
"
We
shouldn
'
t
be
changing
the
display
value
of
"
"
positioned
content
(
and
we
should
have
already
"
"
converted
its
display
value
to
be
block
-
level
.
.
.
)
"
)
;
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mDisplay
=
displayVal
;
}
}
}
if
(
mParent
&
&
:
:
ShouldSuppressLineBreak
(
this
disp
mParent
mParent
-
>
StyleDisplay
(
)
)
)
{
mBits
|
=
NS_STYLE_SUPPRESS_LINEBREAK
;
auto
displayVal
=
disp
-
>
mDisplay
;
nsRuleNode
:
:
EnsureInlineDisplay
(
displayVal
)
;
if
(
displayVal
!
=
disp
-
>
mDisplay
)
{
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mDisplay
=
displayVal
;
}
}
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
|
|
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
)
{
CreateEmptyStyleData
(
eStyleStruct_Border
)
;
CreateEmptyStyleData
(
eStyleStruct_Padding
)
;
}
if
(
disp
-
>
IsRubyDisplayType
(
)
)
{
const
nsStyleTextReset
*
textReset
=
StyleTextReset
(
)
;
uint8_t
unicodeBidi
=
textReset
-
>
mUnicodeBidi
;
if
(
unicodeBidi
=
=
NS_STYLE_UNICODE_BIDI_NORMAL
|
|
unicodeBidi
=
=
NS_STYLE_UNICODE_BIDI_EMBED
)
{
unicodeBidi
=
NS_STYLE_UNICODE_BIDI_ISOLATE
;
}
else
if
(
unicodeBidi
=
=
NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE
)
{
unicodeBidi
=
NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE
;
}
if
(
unicodeBidi
!
=
textReset
-
>
mUnicodeBidi
)
{
nsStyleTextReset
*
mutableTextReset
=
GET_UNIQUE_STYLE_DATA
(
TextReset
)
;
mutableTextReset
-
>
mUnicodeBidi
=
unicodeBidi
;
}
}
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Inline
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
mPseudoTag
)
&
&
mParent
)
{
auto
cbContext
=
mParent
;
while
(
cbContext
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
cbContext
=
cbContext
-
>
mParent
;
}
MOZ_ASSERT
(
cbContext
"
the
root
context
can
'
t
have
display
:
contents
"
)
;
if
(
StyleVisibility
(
)
-
>
mWritingMode
!
=
cbContext
-
>
StyleVisibility
(
)
-
>
mWritingMode
)
{
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mOriginalDisplay
=
mutable_display
-
>
mDisplay
=
mozilla
:
:
StyleDisplay
:
:
InlineBlock
;
}
}
StyleUserInterface
(
)
;
#
undef
GET_UNIQUE_STYLE_DATA
}
bool
GeckoStyleContext
:
:
HasNoChildren
(
)
const
{
return
(
nullptr
=
=
mChild
)
&
&
(
nullptr
=
=
mEmptyChild
)
;
}
