#
include
"
mozilla
/
GeckoStyleContext
.
h
"
#
include
"
CSSVariableImageTable
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRuleNode
.
h
"
#
include
"
nsStyleContextInlines
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
mozilla
/
StyleSetHandleInlines
.
h
"
#
include
"
RubyUtils
.
h
"
using
namespace
mozilla
;
#
ifdef
DEBUG
static
bool
sExpensiveStyleStructAssertionsEnabled
;
void
GeckoStyleContext
:
:
Initialize
(
)
{
Preferences
:
:
AddBoolVarCache
(
&
sExpensiveStyleStructAssertionsEnabled
"
layout
.
css
.
expensive
-
style
-
struct
-
assertions
.
enabled
"
)
;
}
#
endif
GeckoStyleContext
:
:
GeckoStyleContext
(
GeckoStyleContext
*
aParent
nsAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
already_AddRefed
<
nsRuleNode
>
aRuleNode
bool
aSkipParentDisplayBasedStyleFixup
)
:
nsStyleContext
(
aPseudoTag
aPseudoType
)
mCachedResetData
(
nullptr
)
mRefCnt
(
0
)
mChild
(
nullptr
)
mEmptyChild
(
nullptr
)
mRuleNode
(
Move
(
aRuleNode
)
)
mParent
(
aParent
)
#
ifdef
DEBUG
mComputingStruct
(
nsStyleStructID_None
)
mFrameRefCnt
(
0
)
#
endif
{
mBits
|
=
NS_STYLE_CONTEXT_IS_GECKO
;
if
(
aParent
)
{
#
ifdef
DEBUG
nsRuleNode
*
r1
=
mParent
-
>
RuleNode
(
)
*
r2
=
mRuleNode
;
while
(
r1
-
>
GetParent
(
)
)
r1
=
r1
-
>
GetParent
(
)
;
while
(
r2
-
>
GetParent
(
)
)
r2
=
r2
-
>
GetParent
(
)
;
NS_ASSERTION
(
r1
=
=
r2
"
must
be
in
the
same
rule
tree
as
parent
"
)
;
#
endif
}
else
{
PresContext
(
)
-
>
PresShell
(
)
-
>
StyleSet
(
)
-
>
RootStyleContextAdded
(
)
;
}
mRuleNode
-
>
SetUsedDirectly
(
)
;
mNextSibling
=
this
;
mPrevSibling
=
this
;
FinishConstruction
(
)
;
ApplyStyleFixups
(
aSkipParentDisplayBasedStyleFixup
)
;
}
void
*
GeckoStyleContext
:
:
operator
new
(
size_t
sz
nsPresContext
*
aPresContext
)
{
MOZ_ASSERT
(
sz
=
=
sizeof
(
GeckoStyleContext
)
)
;
return
aPresContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
eArenaObjectID_GeckoStyleContext
sz
)
;
}
void
GeckoStyleContext
:
:
Destroy
(
)
{
RefPtr
<
nsPresContext
>
presContext
=
PresContext
(
)
;
this
-
>
~
GeckoStyleContext
(
)
;
presContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
eArenaObjectID_GeckoStyleContext
this
)
;
}
GeckoStyleContext
:
:
~
GeckoStyleContext
(
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
#
ifdef
DEBUG
NS_ASSERTION
(
HasNoChildren
(
)
"
destructing
context
with
children
"
)
;
if
(
sExpensiveStyleStructAssertionsEnabled
)
{
GeckoStyleContext
*
root
=
this
;
while
(
root
-
>
GetParent
(
)
)
{
root
=
root
-
>
GetParent
(
)
;
}
root
-
>
AssertStructsNotUsedElsewhere
(
this
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
}
else
{
this
-
>
AssertStructsNotUsedElsewhere
(
this
2
)
;
}
nsStyleSet
*
geckoStyleSet
=
presContext
-
>
PresShell
(
)
-
>
StyleSet
(
)
-
>
GetAsGecko
(
)
;
NS_ASSERTION
(
!
geckoStyleSet
|
|
geckoStyleSet
-
>
GetRuleTree
(
)
=
=
AsGecko
(
)
-
>
RuleNode
(
)
-
>
RuleTree
(
)
|
|
geckoStyleSet
-
>
IsInRuleTreeReconstruct
(
)
"
destroying
style
context
from
old
rule
tree
too
late
"
)
;
#
endif
if
(
mParent
)
{
mParent
-
>
AsGecko
(
)
-
>
RemoveChild
(
this
)
;
}
else
{
presContext
-
>
StyleSet
(
)
-
>
RootStyleContextRemoved
(
)
;
}
DestroyCachedStructs
(
presContext
)
;
CSSVariableImageTable
:
:
RemoveAll
(
this
)
;
}
void
GeckoStyleContext
:
:
AddChild
(
GeckoStyleContext
*
aChild
)
{
NS_ASSERTION
(
aChild
-
>
mPrevSibling
=
=
aChild
&
&
aChild
-
>
mNextSibling
=
=
aChild
"
child
already
in
a
child
list
"
)
;
GeckoStyleContext
*
*
listPtr
=
aChild
-
>
mRuleNode
-
>
IsRoot
(
)
?
&
mEmptyChild
:
&
mChild
;
if
(
const
nsRuleNode
*
source
=
aChild
-
>
mRuleNode
)
{
if
(
source
-
>
IsRoot
(
)
)
{
listPtr
=
&
mEmptyChild
;
}
}
GeckoStyleContext
*
list
=
*
listPtr
;
if
(
list
)
{
aChild
-
>
mNextSibling
=
list
;
aChild
-
>
mPrevSibling
=
list
-
>
mPrevSibling
;
list
-
>
mPrevSibling
-
>
mNextSibling
=
aChild
;
list
-
>
mPrevSibling
=
aChild
;
}
(
*
listPtr
)
=
aChild
;
}
void
GeckoStyleContext
:
:
MoveTo
(
GeckoStyleContext
*
aNewParent
)
{
MOZ_ASSERT
(
aNewParent
!
=
mParent
)
;
#
define
CHECK_FLAG
(
bit_
)
\
MOZ_ASSERT
(
(
mParent
-
>
AsGecko
(
)
-
>
mBits
&
(
bit_
)
)
=
=
\
(
aNewParent
-
>
mBits
&
(
bit_
)
)
|
|
(
mBits
&
(
bit_
)
)
\
"
MoveTo
cannot
be
called
if
"
#
bit_
"
value
on
old
and
new
"
\
"
style
context
parents
do
not
match
unless
the
flag
is
set
"
\
"
on
this
style
context
"
)
;
CHECK_FLAG
(
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
)
CHECK_FLAG
(
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
)
CHECK_FLAG
(
NS_STYLE_HAS_TEXT_DECORATION_LINES
)
CHECK_FLAG
(
NS_STYLE_RELEVANT_LINK_VISITED
)
#
undef
CHECK_FLAG
MOZ_ASSERT
(
!
IsStyleIfVisited
(
)
)
;
MOZ_ASSERT
(
!
mParent
-
>
IsStyleIfVisited
(
)
)
;
MOZ_ASSERT
(
!
aNewParent
-
>
IsStyleIfVisited
(
)
)
;
auto
*
styleIfVisited
=
GetStyleIfVisited
(
)
;
MOZ_ASSERT
(
!
styleIfVisited
|
|
styleIfVisited
-
>
mParent
=
=
mParent
)
;
if
(
mParent
-
>
HasChildThatUsesResetStyle
(
)
)
{
aNewParent
-
>
AddStyleBit
(
NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE
)
;
}
mParent
-
>
RemoveChild
(
this
)
;
mParent
=
aNewParent
;
mParent
-
>
AddChild
(
this
)
;
if
(
styleIfVisited
)
{
styleIfVisited
-
>
mParent
-
>
RemoveChild
(
styleIfVisited
)
;
styleIfVisited
-
>
mParent
=
aNewParent
;
styleIfVisited
-
>
mParent
-
>
AddChild
(
styleIfVisited
)
;
}
}
void
GeckoStyleContext
:
:
RemoveChild
(
GeckoStyleContext
*
aChild
)
{
NS_PRECONDITION
(
nullptr
!
=
aChild
&
&
this
=
=
aChild
-
>
mParent
"
bad
argument
"
)
;
MOZ_ASSERT
(
aChild
-
>
mRuleNode
"
child
context
should
have
rule
node
"
)
;
GeckoStyleContext
*
*
list
=
aChild
-
>
mRuleNode
-
>
IsRoot
(
)
?
&
mEmptyChild
:
&
mChild
;
if
(
aChild
-
>
mPrevSibling
!
=
aChild
)
{
if
(
(
*
list
)
=
=
aChild
)
{
(
*
list
)
=
(
*
list
)
-
>
mNextSibling
;
}
}
else
{
NS_ASSERTION
(
(
*
list
)
=
=
aChild
"
bad
sibling
pointers
"
)
;
(
*
list
)
=
nullptr
;
}
aChild
-
>
mPrevSibling
-
>
mNextSibling
=
aChild
-
>
mNextSibling
;
aChild
-
>
mNextSibling
-
>
mPrevSibling
=
aChild
-
>
mPrevSibling
;
aChild
-
>
mNextSibling
=
aChild
;
aChild
-
>
mPrevSibling
=
aChild
;
}
#
ifdef
DEBUG
void
GeckoStyleContext
:
:
ListDescendants
(
FILE
*
out
int32_t
aIndent
)
{
if
(
nullptr
!
=
mChild
)
{
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
List
(
out
aIndent
+
1
true
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
nullptr
!
=
mEmptyChild
)
{
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
List
(
out
aIndent
+
1
true
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
#
endif
void
GeckoStyleContext
:
:
ClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
{
if
(
mChild
)
{
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
DoClearCachedInheritedStyleDataOnDescendants
(
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
mEmptyChild
)
{
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
DoClearCachedInheritedStyleDataOnDescendants
(
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
void
GeckoStyleContext
:
:
DoClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
{
NS_ASSERTION
(
mFrameRefCnt
=
=
0
"
frame
still
referencing
style
context
"
)
;
for
(
nsStyleStructID
i
=
nsStyleStructID_Inherited_Start
;
i
<
nsStyleStructID_Inherited_Start
+
nsStyleStructID_Inherited_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
aStructs
&
bit
)
{
if
(
!
(
mBits
&
bit
)
&
&
mCachedInheritedData
.
mStyleStructs
[
i
]
)
{
aStructs
&
=
~
bit
;
}
else
{
mCachedInheritedData
.
mStyleStructs
[
i
]
=
nullptr
;
}
}
}
if
(
mCachedResetData
)
{
for
(
nsStyleStructID
i
=
nsStyleStructID_Reset_Start
;
i
<
nsStyleStructID_Reset_Start
+
nsStyleStructID_Reset_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
aStructs
&
bit
)
{
if
(
!
(
mBits
&
bit
)
&
&
mCachedResetData
-
>
mStyleStructs
[
i
]
)
{
aStructs
&
=
~
bit
;
}
else
{
mCachedResetData
-
>
mStyleStructs
[
i
]
=
nullptr
;
}
}
}
}
if
(
aStructs
=
=
0
)
{
return
;
}
ClearCachedInheritedStyleDataOnDescendants
(
aStructs
)
;
}
already_AddRefed
<
GeckoStyleContext
>
GeckoStyleContext
:
:
FindChildWithRules
(
const
nsAtom
*
aPseudoTag
nsRuleNode
*
aSource
nsRuleNode
*
aSourceIfVisited
bool
aRelevantLinkVisited
)
{
uint32_t
threshold
=
10
;
RefPtr
<
GeckoStyleContext
>
result
;
MOZ_ASSERT
(
aSource
)
;
GeckoStyleContext
*
list
=
aSource
-
>
IsRoot
(
)
?
mEmptyChild
:
mChild
;
if
(
list
)
{
GeckoStyleContext
*
child
=
list
;
do
{
if
(
child
-
>
RuleNode
(
)
=
=
aSource
&
&
child
-
>
mPseudoTag
=
=
aPseudoTag
&
&
!
child
-
>
IsStyleIfVisited
(
)
&
&
child
-
>
RelevantLinkVisited
(
)
=
=
aRelevantLinkVisited
)
{
bool
match
=
false
;
if
(
aSourceIfVisited
)
{
match
=
child
-
>
GetStyleIfVisited
(
)
&
&
child
-
>
GetStyleIfVisited
(
)
-
>
RuleNode
(
)
=
=
aSourceIfVisited
;
}
else
{
match
=
!
child
-
>
GetStyleIfVisited
(
)
;
}
if
(
match
&
&
!
(
child
-
>
mBits
&
NS_STYLE_INELIGIBLE_FOR_SHARING
)
)
{
result
=
child
;
break
;
}
}
child
=
child
-
>
mNextSibling
;
threshold
-
-
;
if
(
threshold
=
=
0
)
break
;
}
while
(
child
!
=
list
)
;
}
if
(
result
)
{
if
(
result
!
=
list
)
{
RemoveChild
(
result
)
;
AddChild
(
result
)
;
}
result
-
>
mBits
|
=
NS_STYLE_IS_SHARED
;
}
return
result
.
forget
(
)
;
}
void
*
GeckoStyleContext
:
:
GetUniqueStyleData
(
const
nsStyleStructID
&
aSID
)
{
const
void
*
current
=
StyleData
(
aSID
)
;
if
(
!
mChild
&
&
!
mEmptyChild
&
&
!
(
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
&
&
GetCachedStyleData
(
aSID
)
)
return
const_cast
<
void
*
>
(
current
)
;
void
*
result
;
nsPresContext
*
presContext
=
PresContext
(
)
;
switch
(
aSID
)
{
#
define
UNIQUE_CASE
(
c_
)
\
case
eStyleStruct_
#
#
c_
:
\
result
=
new
(
presContext
)
nsStyle
#
#
c_
(
\
*
static_cast
<
const
nsStyle
#
#
c_
*
>
(
current
)
)
;
\
break
;
UNIQUE_CASE
(
Font
)
UNIQUE_CASE
(
Display
)
UNIQUE_CASE
(
Position
)
UNIQUE_CASE
(
Text
)
UNIQUE_CASE
(
TextReset
)
UNIQUE_CASE
(
Visibility
)
#
undef
UNIQUE_CASE
default
:
NS_ERROR
(
"
Struct
type
not
supported
.
Please
find
another
way
to
do
this
if
you
can
!
"
)
;
return
nullptr
;
}
SetStyle
(
aSID
result
)
;
mBits
&
=
~
static_cast
<
uint64_t
>
(
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
;
return
result
;
}
void
*
GeckoStyleContext
:
:
CreateEmptyStyleData
(
const
nsStyleStructID
&
aSID
)
{
MOZ_ASSERT
(
!
mChild
&
&
!
mEmptyChild
&
&
!
(
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
&
&
!
GetCachedStyleData
(
aSID
)
"
This
style
should
not
have
been
computed
"
)
;
void
*
result
;
nsPresContext
*
presContext
=
PresContext
(
)
;
switch
(
aSID
)
{
#
define
UNIQUE_CASE
(
c_
)
\
case
eStyleStruct_
#
#
c_
:
\
result
=
new
(
presContext
)
nsStyle
#
#
c_
(
presContext
)
;
\
break
;
UNIQUE_CASE
(
Border
)
UNIQUE_CASE
(
Padding
)
#
undef
UNIQUE_CASE
default
:
NS_ERROR
(
"
Struct
type
not
supported
.
"
)
;
return
nullptr
;
}
SetStyle
(
aSID
result
)
;
return
result
;
}
void
GeckoStyleContext
:
:
SetIneligibleForSharing
(
)
{
if
(
mBits
&
NS_STYLE_INELIGIBLE_FOR_SHARING
)
{
return
;
}
mBits
|
=
NS_STYLE_INELIGIBLE_FOR_SHARING
;
if
(
mChild
)
{
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
SetIneligibleForSharing
(
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
mEmptyChild
)
{
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
SetIneligibleForSharing
(
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
#
ifdef
RESTYLE_LOGGING
nsCString
GeckoStyleContext
:
:
GetCachedStyleDataAsString
(
uint32_t
aStructs
)
{
nsCString
structs
;
for
(
nsStyleStructID
i
=
nsStyleStructID
(
0
)
;
i
<
nsStyleStructID_Length
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
if
(
aStructs
&
nsCachedStyleData
:
:
GetBitForSID
(
i
)
)
{
const
void
*
data
=
GetCachedStyleData
(
i
)
;
if
(
!
structs
.
IsEmpty
(
)
)
{
structs
.
Append
(
'
'
)
;
}
structs
.
AppendPrintf
(
"
%
s
=
%
p
"
StructName
(
i
)
data
)
;
if
(
HasCachedDependentStyleData
(
i
)
)
{
structs
.
AppendLiteral
(
"
(
dependent
)
"
)
;
}
else
{
structs
.
AppendLiteral
(
"
(
owned
)
"
)
;
}
}
}
return
structs
;
}
int32_t
&
GeckoStyleContext
:
:
LoggingDepth
(
)
{
static
int32_t
depth
=
0
;
return
depth
;
}
void
GeckoStyleContext
:
:
LogStyleContextTree
(
int32_t
aLoggingDepth
uint32_t
aStructs
)
{
LoggingDepth
(
)
=
aLoggingDepth
;
LogStyleContextTree
(
true
aStructs
)
;
}
void
GeckoStyleContext
:
:
LogStyleContextTree
(
bool
aFirst
uint32_t
aStructs
)
{
nsCString
structs
=
GetCachedStyleDataAsString
(
aStructs
)
;
if
(
!
structs
.
IsEmpty
(
)
)
{
structs
.
Append
(
'
'
)
;
}
nsCString
pseudo
;
if
(
mPseudoTag
)
{
nsAutoString
pseudoTag
;
mPseudoTag
-
>
ToString
(
pseudoTag
)
;
AppendUTF16toUTF8
(
pseudoTag
pseudo
)
;
pseudo
.
Append
(
'
'
)
;
}
nsCString
flags
;
if
(
IsStyleIfVisited
(
)
)
{
flags
.
AppendLiteral
(
"
IS_STYLE_IF_VISITED
"
)
;
}
if
(
HasChildThatUsesGrandancestorStyle
(
)
)
{
flags
.
AppendLiteral
(
"
CHILD_USES_GRANDANCESTOR_STYLE
"
)
;
}
if
(
IsShared
(
)
)
{
flags
.
AppendLiteral
(
"
IS_SHARED
"
)
;
}
nsCString
parent
;
if
(
aFirst
)
{
parent
.
AppendPrintf
(
"
parent
=
%
p
"
mParent
.
get
(
)
)
;
}
LOG_RESTYLE
(
"
%
p
(
%
d
)
%
s
%
s
%
s
%
s
"
this
mRefCnt
structs
.
get
(
)
pseudo
.
get
(
)
flags
.
get
(
)
parent
.
get
(
)
)
;
LOG_RESTYLE_INDENT
(
)
;
if
(
nullptr
!
=
mChild
)
{
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
LogStyleContextTree
(
false
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
nullptr
!
=
mEmptyChild
)
{
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
LogStyleContextTree
(
false
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
#
endif
static
bool
ShouldSuppressLineBreak
(
const
nsStyleContext
*
aContext
const
nsStyleDisplay
*
aDisplay
const
nsStyleContext
*
aParentContext
const
nsStyleDisplay
*
aParentDisplay
)
{
if
(
aDisplay
-
>
IsOutOfFlowStyle
(
)
)
{
return
false
;
}
if
(
(
aContext
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
InheritingAnonBox
|
|
aContext
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
NonInheritingAnonBox
)
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
aContext
-
>
GetPseudo
(
)
)
&
&
!
RubyUtils
:
:
IsRubyPseudo
(
aContext
-
>
GetPseudo
(
)
)
)
{
return
false
;
}
if
(
aParentContext
-
>
ShouldSuppressLineBreak
(
)
)
{
if
(
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Inline
|
|
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
|
|
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Ruby
|
|
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
)
{
return
true
;
}
}
if
(
(
aParentDisplay
-
>
IsRubyDisplayType
(
)
&
&
aDisplay
-
>
mDisplay
!
=
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
&
&
aDisplay
-
>
mDisplay
!
=
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
)
|
|
aDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyBase
|
|
aDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyText
)
{
return
true
;
}
return
false
;
}
void
GeckoStyleContext
:
:
FinishConstruction
(
)
{
MOZ_ASSERT
(
RuleNode
(
)
)
;
if
(
mParent
)
{
mParent
-
>
AddChild
(
this
)
;
}
SetStyleBits
(
)
;
}
void
GeckoStyleContext
:
:
SetStyleBits
(
)
{
if
(
(
mParent
&
&
mParent
-
>
HasPseudoElementData
(
)
)
|
|
IsPseudoElement
(
)
)
{
AddStyleBit
(
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
)
;
}
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
(
mParent
&
&
mParent
-
>
IsInDisplayNoneSubtree
(
)
)
|
|
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
None
)
{
AddStyleBit
(
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
)
;
}
if
(
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
mozText
&
&
mParent
&
&
mParent
-
>
StyleVisibility
(
)
-
>
mWritingMode
!
=
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
&
&
mParent
-
>
StyleText
(
)
-
>
mTextCombineUpright
=
=
NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL
)
{
AddStyleBit
(
NS_STYLE_IS_TEXT_COMBINED
)
;
}
}
static
bool
ShouldBlockifyChildren
(
const
nsStyleDisplay
*
aStyleDisp
)
{
auto
displayVal
=
aStyleDisp
-
>
mDisplay
;
return
mozilla
:
:
StyleDisplay
:
:
Flex
=
=
displayVal
|
|
mozilla
:
:
StyleDisplay
:
:
InlineFlex
=
=
displayVal
|
|
mozilla
:
:
StyleDisplay
:
:
Grid
=
=
displayVal
|
|
mozilla
:
:
StyleDisplay
:
:
InlineGrid
=
=
displayVal
;
}
#
ifdef
DEBUG
void
GeckoStyleContext
:
:
AssertStructsNotUsedElsewhere
(
GeckoStyleContext
*
aDestroyingContext
int32_t
aLevels
)
const
{
if
(
aLevels
=
=
0
)
{
return
;
}
void
*
data
;
if
(
mBits
&
NS_STYLE_IS_GOING_AWAY
)
{
return
;
}
if
(
this
!
=
aDestroyingContext
)
{
nsInheritedStyleData
&
destroyingInheritedData
=
aDestroyingContext
-
>
mCachedInheritedData
;
#
define
STYLE_STRUCT_INHERITED
(
name_
checkdata_cb
)
\
data
=
destroyingInheritedData
.
mStyleStructs
[
eStyleStruct_
#
#
name_
]
;
\
if
(
data
&
&
\
!
(
aDestroyingContext
-
>
mBits
&
NS_STYLE_INHERIT_BIT
(
name_
)
)
&
&
\
(
mCachedInheritedData
.
mStyleStructs
[
eStyleStruct_
#
#
name_
]
=
=
data
)
)
{
\
printf_stderr
(
"
style
struct
%
p
found
on
style
context
%
p
\
n
"
data
this
)
;
\
nsString
url
;
\
nsresult
rv
=
PresContext
(
)
-
>
Document
(
)
-
>
GetURL
(
url
)
;
\
if
(
NS_SUCCEEDED
(
rv
)
)
{
\
printf_stderr
(
"
in
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
url
)
.
get
(
)
)
;
\
}
\
MOZ_ASSERT
(
false
"
destroying
"
#
name_
"
style
struct
still
present
"
\
"
in
style
context
tree
"
)
;
\
}
#
define
STYLE_STRUCT_RESET
(
name_
checkdata_cb
)
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT_INHERITED
#
undef
STYLE_STRUCT_RESET
if
(
mCachedResetData
)
{
nsResetStyleData
*
destroyingResetData
=
aDestroyingContext
-
>
mCachedResetData
;
if
(
destroyingResetData
)
{
#
define
STYLE_STRUCT_INHERITED
(
name_
checkdata_cb_
)
#
define
STYLE_STRUCT_RESET
(
name_
checkdata_cb
)
\
data
=
destroyingResetData
-
>
mStyleStructs
[
eStyleStruct_
#
#
name_
]
;
\
if
(
data
&
&
\
!
(
aDestroyingContext
-
>
mBits
&
NS_STYLE_INHERIT_BIT
(
name_
)
)
&
&
\
(
mCachedResetData
-
>
mStyleStructs
[
eStyleStruct_
#
#
name_
]
=
=
data
)
)
{
\
printf_stderr
(
"
style
struct
%
p
found
on
style
context
%
p
\
n
"
data
\
this
)
;
\
nsString
url
;
\
nsresult
rv
=
PresContext
(
)
-
>
Document
(
)
-
>
GetURL
(
url
)
;
\
if
(
NS_SUCCEEDED
(
rv
)
)
{
\
printf_stderr
(
"
in
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
url
)
.
get
(
)
)
;
\
}
\
MOZ_ASSERT
(
false
"
destroying
"
#
name_
"
style
struct
still
present
"
\
"
in
style
context
tree
"
)
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT_INHERITED
#
undef
STYLE_STRUCT_RESET
}
}
}
if
(
mChild
)
{
const
GeckoStyleContext
*
child
=
mChild
;
do
{
child
-
>
AssertStructsNotUsedElsewhere
(
aDestroyingContext
aLevels
-
1
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
child
!
=
mChild
)
;
}
if
(
mEmptyChild
)
{
const
GeckoStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
AssertStructsNotUsedElsewhere
(
aDestroyingContext
aLevels
-
1
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
child
!
=
mEmptyChild
)
;
}
}
#
endif
void
GeckoStyleContext
:
:
ApplyStyleFixups
(
bool
aSkipParentDisplayBasedStyleFixup
)
{
#
define
GET_UNIQUE_STYLE_DATA
(
name_
)
\
static_cast
<
nsStyle
#
#
name_
*
>
(
GetUniqueStyleData
(
eStyleStruct_
#
#
name_
)
)
if
(
mPseudoTag
=
=
nsCSSPseudoElements
:
:
firstLetter
)
{
const
nsStyleTextReset
*
textReset
=
StyleTextReset
(
)
;
if
(
textReset
-
>
mInitialLetterSize
!
=
0
.
0f
)
{
GeckoStyleContext
*
containerSC
=
GetParent
(
)
;
const
nsStyleDisplay
*
containerDisp
=
containerSC
-
>
StyleDisplay
(
)
;
while
(
containerDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
if
(
!
containerSC
-
>
GetParent
(
)
)
{
break
;
}
containerSC
=
containerSC
-
>
GetParent
(
)
;
containerDisp
=
containerSC
-
>
StyleDisplay
(
)
;
}
nscoord
containerLH
=
ReflowInput
:
:
CalcLineHeight
(
nullptr
containerSC
NS_AUTOHEIGHT
1
.
0f
)
;
RefPtr
<
nsFontMetrics
>
containerFM
=
nsLayoutUtils
:
:
GetFontMetricsForStyleContext
(
containerSC
)
;
MOZ_ASSERT
(
containerFM
"
Should
have
fontMetrics
!
!
"
)
;
nscoord
containerCH
=
containerFM
-
>
CapHeight
(
)
;
RefPtr
<
nsFontMetrics
>
firstLetterFM
=
nsLayoutUtils
:
:
GetFontMetricsForStyleContext
(
this
)
;
MOZ_ASSERT
(
firstLetterFM
"
Should
have
fontMetrics
!
!
"
)
;
nscoord
firstLetterCH
=
firstLetterFM
-
>
CapHeight
(
)
;
nsStyleFont
*
mutableStyleFont
=
GET_UNIQUE_STYLE_DATA
(
Font
)
;
float
invCapHeightRatio
=
mutableStyleFont
-
>
mFont
.
size
/
NSCoordToFloat
(
firstLetterCH
)
;
mutableStyleFont
-
>
mFont
.
size
=
NSToCoordRound
(
(
(
textReset
-
>
mInitialLetterSize
-
1
)
*
containerLH
+
containerCH
)
*
invCapHeightRatio
)
;
}
}
if
(
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
mozText
&
&
mParent
&
&
mParent
-
>
StyleVisibility
(
)
-
>
mWritingMode
!
=
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
&
&
mParent
-
>
StyleText
(
)
-
>
mTextCombineUpright
=
=
NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL
)
{
MOZ_ASSERT
(
!
PeekStyleVisibility
(
)
"
If
StyleVisibility
was
already
"
"
computed
some
properties
may
have
been
computed
"
"
incorrectly
based
on
the
old
writing
mode
value
"
)
;
nsStyleVisibility
*
mutableVis
=
GET_UNIQUE_STYLE_DATA
(
Visibility
)
;
mutableVis
-
>
mWritingMode
=
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
;
}
if
(
mParent
&
&
mParent
-
>
HasTextDecorationLines
(
)
)
{
AddStyleBit
(
NS_STYLE_HAS_TEXT_DECORATION_LINES
)
;
}
else
{
if
(
StyleTextReset
(
)
-
>
HasTextDecorationLines
(
)
)
{
AddStyleBit
(
NS_STYLE_HAS_TEXT_DECORATION_LINES
)
;
}
}
if
(
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
viewport
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
mozilla
:
:
dom
:
:
Element
*
docElement
=
presContext
-
>
Document
(
)
-
>
GetRootElement
(
)
;
if
(
docElement
)
{
RefPtr
<
nsStyleContext
>
rootStyle
=
presContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleFor
(
docElement
nullptr
)
;
auto
dir
=
rootStyle
-
>
StyleVisibility
(
)
-
>
mDirection
;
if
(
dir
!
=
StyleVisibility
(
)
-
>
mDirection
)
{
nsStyleVisibility
*
uniqueVisibility
=
GET_UNIQUE_STYLE_DATA
(
Visibility
)
;
uniqueVisibility
-
>
mDirection
=
dir
;
}
}
}
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Table
)
{
const
nsStyleText
*
text
=
StyleText
(
)
;
if
(
text
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_LEFT
|
|
text
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_CENTER
|
|
text
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_RIGHT
)
{
nsStyleText
*
uniqueText
=
GET_UNIQUE_STYLE_DATA
(
Text
)
;
uniqueText
-
>
mTextAlign
=
NS_STYLE_TEXT_ALIGN_START
;
}
}
if
(
mParent
&
&
mParent
-
>
StylePosition
(
)
-
>
mJustifyItems
&
NS_STYLE_JUSTIFY_LEGACY
&
&
StylePosition
(
)
-
>
mSpecifiedJustifyItems
=
=
NS_STYLE_JUSTIFY_AUTO
&
&
StylePosition
(
)
-
>
mJustifyItems
!
=
mParent
-
>
StylePosition
(
)
-
>
mJustifyItems
)
{
nsStylePosition
*
uniquePosition
=
GET_UNIQUE_STYLE_DATA
(
Position
)
;
uniquePosition
-
>
mJustifyItems
=
mParent
-
>
StylePosition
(
)
-
>
mJustifyItems
;
}
if
(
!
mParent
&
&
(
!
mPseudoTag
|
|
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
viewport
|
|
mPseudoTag
=
=
nsCSSPseudoElements
:
:
backdrop
)
)
{
auto
displayVal
=
disp
-
>
mDisplay
;
if
(
displayVal
!
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
nsRuleNode
:
:
EnsureBlockDisplay
(
displayVal
true
)
;
}
else
{
displayVal
=
mozilla
:
:
StyleDisplay
:
:
Block
;
}
if
(
displayVal
!
=
disp
-
>
mDisplay
)
{
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mOriginalDisplay
=
mutable_display
-
>
mDisplay
=
displayVal
;
}
}
if
(
!
aSkipParentDisplayBasedStyleFixup
&
&
mParent
)
{
GeckoStyleContext
*
containerContext
=
GetParent
(
)
;
const
nsStyleDisplay
*
containerDisp
=
containerContext
-
>
StyleDisplay
(
)
;
while
(
containerDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
if
(
!
containerContext
-
>
GetParent
(
)
)
{
break
;
}
containerContext
=
containerContext
-
>
GetParent
(
)
;
containerDisp
=
containerContext
-
>
StyleDisplay
(
)
;
}
if
(
ShouldBlockifyChildren
(
containerDisp
)
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
GetPseudo
(
)
)
)
{
auto
displayVal
=
disp
-
>
mDisplay
;
nsRuleNode
:
:
EnsureBlockDisplay
(
displayVal
)
;
if
(
displayVal
!
=
disp
-
>
mDisplay
)
{
NS_ASSERTION
(
!
disp
-
>
IsAbsolutelyPositionedStyle
(
)
"
We
shouldn
'
t
be
changing
the
display
value
of
"
"
positioned
content
(
and
we
should
have
already
"
"
converted
its
display
value
to
be
block
-
level
.
.
.
)
"
)
;
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mDisplay
=
displayVal
;
}
}
}
if
(
mParent
&
&
:
:
ShouldSuppressLineBreak
(
this
disp
mParent
mParent
-
>
StyleDisplay
(
)
)
)
{
mBits
|
=
NS_STYLE_SUPPRESS_LINEBREAK
;
auto
displayVal
=
disp
-
>
mDisplay
;
nsRuleNode
:
:
EnsureInlineDisplay
(
displayVal
)
;
if
(
displayVal
!
=
disp
-
>
mDisplay
)
{
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mDisplay
=
displayVal
;
}
}
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
|
|
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
)
{
CreateEmptyStyleData
(
eStyleStruct_Border
)
;
CreateEmptyStyleData
(
eStyleStruct_Padding
)
;
}
if
(
disp
-
>
IsRubyDisplayType
(
)
)
{
const
nsStyleTextReset
*
textReset
=
StyleTextReset
(
)
;
uint8_t
unicodeBidi
=
textReset
-
>
mUnicodeBidi
;
if
(
unicodeBidi
=
=
NS_STYLE_UNICODE_BIDI_NORMAL
|
|
unicodeBidi
=
=
NS_STYLE_UNICODE_BIDI_EMBED
)
{
unicodeBidi
=
NS_STYLE_UNICODE_BIDI_ISOLATE
;
}
else
if
(
unicodeBidi
=
=
NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE
)
{
unicodeBidi
=
NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE
;
}
if
(
unicodeBidi
!
=
textReset
-
>
mUnicodeBidi
)
{
nsStyleTextReset
*
mutableTextReset
=
GET_UNIQUE_STYLE_DATA
(
TextReset
)
;
mutableTextReset
-
>
mUnicodeBidi
=
unicodeBidi
;
}
}
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Inline
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
mPseudoTag
)
&
&
mParent
)
{
auto
cbContext
=
GetParent
(
)
;
while
(
cbContext
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
cbContext
=
cbContext
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
cbContext
"
the
root
context
can
'
t
have
display
:
contents
"
)
;
if
(
StyleVisibility
(
)
-
>
mWritingMode
!
=
cbContext
-
>
StyleVisibility
(
)
-
>
mWritingMode
)
{
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mOriginalDisplay
=
mutable_display
-
>
mDisplay
=
mozilla
:
:
StyleDisplay
:
:
InlineBlock
;
}
}
StyleUserInterface
(
)
;
#
undef
GET_UNIQUE_STYLE_DATA
}
bool
GeckoStyleContext
:
:
HasNoChildren
(
)
const
{
return
(
nullptr
=
=
mChild
)
&
&
(
nullptr
=
=
mEmptyChild
)
;
}
void
GeckoStyleContext
:
:
SetStyle
(
nsStyleStructID
aSID
void
*
aStruct
)
{
NS_ASSERTION
(
aSID
>
=
0
&
&
aSID
<
nsStyleStructID_Length
"
out
of
bounds
"
)
;
void
*
*
dataSlot
;
if
(
nsCachedStyleData
:
:
IsReset
(
aSID
)
)
{
if
(
!
mCachedResetData
)
{
mCachedResetData
=
new
(
PresContext
(
)
)
nsResetStyleData
;
}
dataSlot
=
&
mCachedResetData
-
>
mStyleStructs
[
aSID
]
;
}
else
{
dataSlot
=
&
mCachedInheritedData
.
mStyleStructs
[
aSID
]
;
}
NS_ASSERTION
(
!
*
dataSlot
|
|
(
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
"
Going
to
leak
style
data
"
)
;
*
dataSlot
=
aStruct
;
}
const
void
*
GeckoStyleContext
:
:
StyleData
(
nsStyleStructID
aSID
)
{
const
void
*
cachedData
=
GetCachedStyleData
(
aSID
)
;
if
(
cachedData
)
return
cachedData
;
const
void
*
newData
=
AsGecko
(
)
-
>
RuleNode
(
)
-
>
GetStyleData
(
aSID
this
-
>
AsGecko
(
)
true
)
;
if
(
!
nsCachedStyleData
:
:
IsReset
(
aSID
)
)
{
mCachedInheritedData
.
mStyleStructs
[
aSID
]
=
const_cast
<
void
*
>
(
newData
)
;
}
return
newData
;
}
void
GeckoStyleContext
:
:
DestroyCachedStructs
(
nsPresContext
*
aPresContext
)
{
mCachedInheritedData
.
DestroyStructs
(
mBits
aPresContext
)
;
if
(
mCachedResetData
)
{
mCachedResetData
-
>
Destroy
(
mBits
aPresContext
)
;
}
}
void
GeckoStyleContext
:
:
SwapStyleData
(
GeckoStyleContext
*
aNewContext
uint32_t
aStructs
)
{
static_assert
(
nsStyleStructID_Length
<
=
32
"
aStructs
is
not
big
enough
"
)
;
for
(
nsStyleStructID
i
=
nsStyleStructID_Inherited_Start
;
i
<
nsStyleStructID_Inherited_Start
+
nsStyleStructID_Inherited_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
!
(
aStructs
&
bit
)
)
{
continue
;
}
void
*
&
thisData
=
mCachedInheritedData
.
mStyleStructs
[
i
]
;
void
*
&
otherData
=
aNewContext
-
>
mCachedInheritedData
.
mStyleStructs
[
i
]
;
if
(
mBits
&
bit
)
{
if
(
thisData
=
=
otherData
)
{
thisData
=
nullptr
;
}
}
else
if
(
!
(
aNewContext
-
>
mBits
&
bit
)
&
&
thisData
&
&
otherData
)
{
std
:
:
swap
(
thisData
otherData
)
;
}
}
for
(
nsStyleStructID
i
=
nsStyleStructID_Reset_Start
;
i
<
nsStyleStructID_Reset_Start
+
nsStyleStructID_Reset_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
!
(
aStructs
&
bit
)
)
{
continue
;
}
if
(
!
mCachedResetData
)
{
mCachedResetData
=
new
(
PresContext
(
)
)
nsResetStyleData
;
}
if
(
!
aNewContext
-
>
mCachedResetData
)
{
aNewContext
-
>
mCachedResetData
=
new
(
PresContext
(
)
)
nsResetStyleData
;
}
void
*
&
thisData
=
mCachedResetData
-
>
mStyleStructs
[
i
]
;
void
*
&
otherData
=
aNewContext
-
>
mCachedResetData
-
>
mStyleStructs
[
i
]
;
if
(
mBits
&
bit
)
{
if
(
thisData
=
=
otherData
)
{
thisData
=
nullptr
;
}
}
else
if
(
!
(
aNewContext
-
>
mBits
&
bit
)
&
&
thisData
&
&
otherData
)
{
std
:
:
swap
(
thisData
otherData
)
;
}
}
}
void
GeckoStyleContext
:
:
SetStyleIfVisited
(
already_AddRefed
<
GeckoStyleContext
>
aStyleIfVisited
)
{
MOZ_ASSERT
(
!
IsStyleIfVisited
(
)
"
this
context
is
not
visited
data
"
)
;
NS_ASSERTION
(
!
mStyleIfVisited
"
should
only
be
set
once
"
)
;
mStyleIfVisited
=
aStyleIfVisited
;
MOZ_ASSERT
(
mStyleIfVisited
-
>
IsStyleIfVisited
(
)
"
other
context
is
visited
data
"
)
;
MOZ_ASSERT
(
!
mStyleIfVisited
-
>
GetStyleIfVisited
(
)
"
other
context
does
not
have
visited
data
"
)
;
NS_ASSERTION
(
GetStyleIfVisited
(
)
-
>
GetPseudo
(
)
=
=
GetPseudo
(
)
"
pseudo
tag
mismatch
"
)
;
if
(
GetParent
(
)
&
&
GetParent
(
)
-
>
GetStyleIfVisited
(
)
)
{
MOZ_ASSERT
(
GetStyleIfVisited
(
)
-
>
GetParent
(
)
=
=
GetParent
(
)
-
>
GetStyleIfVisited
(
)
|
|
GetStyleIfVisited
(
)
-
>
GetParent
(
)
=
=
GetParent
(
)
"
parent
mismatch
"
)
;
}
else
{
MOZ_ASSERT
(
GetStyleIfVisited
(
)
-
>
GetParent
(
)
=
=
GetParent
(
)
"
parent
mismatch
"
)
;
}
}
