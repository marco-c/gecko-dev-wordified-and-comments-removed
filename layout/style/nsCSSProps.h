#
ifndef
nsCSSProps_h___
#
define
nsCSSProps_h___
#
include
<
limits
>
#
include
<
ostream
>
#
include
<
type_traits
>
#
include
"
nsString
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsStyleStructFwd
.
h
"
#
include
"
nsCSSKeywords
.
h
"
#
include
"
mozilla
/
CSSEnabledState
.
h
"
#
include
"
mozilla
/
CSSPropFlags
.
h
"
#
include
"
mozilla
/
UseCounter
.
h
"
#
include
"
mozilla
/
EnumTypeTraits
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
define
CSS_CUSTOM_NAME_PREFIX_LENGTH
2
namespace
mozilla
{
class
ComputedStyle
;
}
extern
"
C
"
{
nsCSSPropertyID
Servo_ResolveLogicalProperty
(
nsCSSPropertyID
const
mozilla
:
:
ComputedStyle
*
)
;
nsCSSPropertyID
Servo_Property_LookupEnabledForAllContent
(
const
nsACString
*
)
;
const
uint8_t
*
Servo_Property_GetName
(
nsCSSPropertyID
uint32_t
*
aLength
)
;
}
struct
nsCSSKTableEntry
{
static
constexpr
uint16_t
SENTINEL_VALUE
=
uint16_t
(
-
1
)
;
constexpr
nsCSSKTableEntry
(
nsCSSKeyword
aKeyword
uint16_t
aValue
)
:
mKeyword
(
aKeyword
)
mValue
(
aValue
)
{
}
template
<
typename
T
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_enum
<
T
>
:
:
value
>
:
:
type
>
constexpr
nsCSSKTableEntry
(
nsCSSKeyword
aKeyword
T
aValue
)
:
mKeyword
(
aKeyword
)
mValue
(
static_cast
<
uint16_t
>
(
aValue
)
)
{
static_assert
(
mozilla
:
:
EnumTypeFitsWithin
<
T
uint16_t
>
:
:
value
"
aValue
must
be
an
enum
that
fits
within
mValue
"
)
;
MOZ_ASSERT
(
static_cast
<
uint16_t
>
(
aValue
)
!
=
SENTINEL_VALUE
)
;
}
bool
IsSentinel
(
)
const
{
return
mKeyword
=
=
eCSSKeyword_UNKNOWN
&
&
mValue
=
=
SENTINEL_VALUE
;
}
nsCSSKeyword
mKeyword
;
uint16_t
mValue
;
}
;
class
nsCSSProps
{
public
:
typedef
mozilla
:
:
CSSEnabledState
EnabledState
;
typedef
mozilla
:
:
CSSPropFlags
Flags
;
typedef
nsCSSKTableEntry
KTableEntry
;
static
void
AddRefTable
(
void
)
;
static
void
ReleaseTable
(
void
)
;
static
nsCSSPropertyID
LookupProperty
(
const
nsACString
&
aProperty
)
{
return
Servo_Property_LookupEnabledForAllContent
(
&
aProperty
)
;
}
static
nsCSSPropertyID
LookupProperty
(
const
nsAString
&
aProperty
)
{
NS_ConvertUTF16toUTF8
utf8
(
aProperty
)
;
return
LookupProperty
(
utf8
)
;
}
static
nsCSSPropertyID
LookupPropertyByIDLName
(
const
nsAString
&
aPropertyIDLName
EnabledState
aEnabled
)
;
static
nsCSSPropertyID
LookupPropertyByIDLName
(
const
nsACString
&
aPropertyIDLName
EnabledState
aEnabled
)
;
static
bool
IsCustomPropertyName
(
const
nsAString
&
aProperty
)
;
static
bool
IsShorthand
(
nsCSSPropertyID
aProperty
)
{
MOZ_ASSERT
(
0
<
=
aProperty
&
&
aProperty
<
eCSSProperty_COUNT
"
out
of
range
"
)
;
return
(
aProperty
>
=
eCSSProperty_COUNT_no_shorthands
)
;
}
static
nsCSSFontDesc
LookupFontDesc
(
const
nsAString
&
aProperty
)
;
static
const
nsDependentCSubstring
GetStringValue
(
nsCSSPropertyID
aProperty
)
{
uint32_t
len
;
const
uint8_t
*
chars
=
Servo_Property_GetName
(
aProperty
&
len
)
;
return
nsDependentCSubstring
(
reinterpret_cast
<
const
char
*
>
(
chars
)
len
)
;
}
static
const
nsCString
&
GetStringValue
(
nsCSSFontDesc
aFontDesc
)
;
static
const
nsCString
&
GetStringValue
(
nsCSSCounterDesc
aCounterDesc
)
;
static
int32_t
FindIndexOfKeyword
(
nsCSSKeyword
aKeyword
const
KTableEntry
aTable
[
]
)
;
static
bool
FindKeyword
(
nsCSSKeyword
aKeyword
const
KTableEntry
aTable
[
]
int32_t
&
aValue
)
;
static
nsCSSKeyword
ValueToKeywordEnum
(
int32_t
aValue
const
KTableEntry
aTable
[
]
)
;
template
<
typename
T
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_enum
<
T
>
:
:
value
>
:
:
type
>
static
nsCSSKeyword
ValueToKeywordEnum
(
T
aValue
const
KTableEntry
aTable
[
]
)
{
static_assert
(
mozilla
:
:
EnumTypeFitsWithin
<
T
uint16_t
>
:
:
value
"
aValue
must
be
an
enum
that
fits
within
KTableEntry
:
:
mValue
"
)
;
return
ValueToKeywordEnum
(
static_cast
<
uint16_t
>
(
aValue
)
aTable
)
;
}
static
const
nsCString
&
ValueToKeyword
(
int32_t
aValue
const
KTableEntry
aTable
[
]
)
;
template
<
typename
T
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_enum
<
T
>
:
:
value
>
:
:
type
>
static
const
nsCString
&
ValueToKeyword
(
T
aValue
const
KTableEntry
aTable
[
]
)
{
static_assert
(
mozilla
:
:
EnumTypeFitsWithin
<
T
uint16_t
>
:
:
value
"
aValue
must
be
an
enum
that
fits
within
KTableEntry
:
:
mValue
"
)
;
return
ValueToKeyword
(
static_cast
<
uint16_t
>
(
aValue
)
aTable
)
;
}
private
:
static
const
Flags
kFlagsTable
[
eCSSProperty_COUNT
]
;
public
:
static
bool
PropHasFlags
(
nsCSSPropertyID
aProperty
Flags
aFlags
)
{
MOZ_ASSERT
(
0
<
=
aProperty
&
&
aProperty
<
eCSSProperty_COUNT
"
out
of
range
"
)
;
return
(
nsCSSProps
:
:
kFlagsTable
[
aProperty
]
&
aFlags
)
=
=
aFlags
;
}
static
nsCSSPropertyID
Physicalize
(
nsCSSPropertyID
aProperty
const
mozilla
:
:
ComputedStyle
&
aStyle
)
{
MOZ_ASSERT
(
!
IsShorthand
(
aProperty
)
)
;
if
(
PropHasFlags
(
aProperty
Flags
:
:
IsLogical
)
)
{
return
Servo_ResolveLogicalProperty
(
aProperty
&
aStyle
)
;
}
return
aProperty
;
}
private
:
static
const
nsCSSPropertyID
*
const
kSubpropertyTable
[
eCSSProperty_COUNT
-
eCSSProperty_COUNT_no_shorthands
]
;
public
:
static
const
nsCSSPropertyID
*
SubpropertyEntryFor
(
nsCSSPropertyID
aProperty
)
{
MOZ_ASSERT
(
eCSSProperty_COUNT_no_shorthands
<
=
aProperty
&
&
aProperty
<
eCSSProperty_COUNT
"
out
of
range
"
)
;
return
nsCSSProps
:
:
kSubpropertyTable
[
aProperty
-
eCSSProperty_COUNT_no_shorthands
]
;
}
private
:
static
bool
gPropertyEnabled
[
eCSSProperty_COUNT_with_aliases
]
;
private
:
static
const
char
*
const
kIDLNameTable
[
eCSSProperty_COUNT
]
;
public
:
static
const
char
*
PropertyIDLName
(
nsCSSPropertyID
aProperty
)
{
MOZ_ASSERT
(
0
<
=
aProperty
&
&
aProperty
<
eCSSProperty_COUNT
"
out
of
range
"
)
;
return
kIDLNameTable
[
aProperty
]
;
}
private
:
static
const
int32_t
kIDLNameSortPositionTable
[
eCSSProperty_COUNT
]
;
public
:
static
int32_t
PropertyIDLNameSortPosition
(
nsCSSPropertyID
aProperty
)
{
MOZ_ASSERT
(
0
<
=
aProperty
&
&
aProperty
<
eCSSProperty_COUNT
"
out
of
range
"
)
;
return
kIDLNameSortPositionTable
[
aProperty
]
;
}
static
bool
IsEnabled
(
nsCSSPropertyID
aProperty
)
{
MOZ_ASSERT
(
0
<
=
aProperty
&
&
aProperty
<
eCSSProperty_COUNT_with_aliases
"
out
of
range
"
)
;
MOZ_ASSERT_IF
(
!
XRE_IsParentProcess
(
)
mozilla
:
:
Preferences
:
:
ArePrefsInitedInContentProcess
(
)
)
;
return
gPropertyEnabled
[
aProperty
]
;
}
static
const
mozilla
:
:
UseCounter
gPropertyUseCounter
[
eCSSProperty_COUNT_no_shorthands
]
;
public
:
static
mozilla
:
:
UseCounter
UseCounterFor
(
nsCSSPropertyID
aProperty
)
{
MOZ_ASSERT
(
0
<
=
aProperty
&
&
aProperty
<
eCSSProperty_COUNT_no_shorthands
"
out
of
range
"
)
;
return
gPropertyUseCounter
[
aProperty
]
;
}
static
bool
IsEnabled
(
nsCSSPropertyID
aProperty
EnabledState
aEnabled
)
{
if
(
IsEnabled
(
aProperty
)
)
{
return
true
;
}
if
(
aEnabled
=
=
EnabledState
:
:
IgnoreEnabledState
)
{
return
true
;
}
if
(
(
aEnabled
&
EnabledState
:
:
InUASheets
)
&
&
PropHasFlags
(
aProperty
Flags
:
:
EnabledInUASheets
)
)
{
return
true
;
}
if
(
(
aEnabled
&
EnabledState
:
:
InChrome
)
&
&
PropHasFlags
(
aProperty
Flags
:
:
EnabledInChrome
)
)
{
return
true
;
}
return
false
;
}
public
:
struct
PropertyPref
{
nsCSSPropertyID
mPropID
;
const
char
*
mPref
;
}
;
static
const
PropertyPref
kPropertyPrefTable
[
]
;
#
define
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
it_
prop_
enabledstate_
)
\
for
(
const
nsCSSPropertyID
*
\
it_
=
nsCSSProps
:
:
SubpropertyEntryFor
(
prop_
)
\
es_
=
(
nsCSSPropertyID
)
(
(
enabledstate_
)
|
CSSEnabledState
(
0
)
)
;
\
*
it_
!
=
eCSSProperty_UNKNOWN
;
+
+
it_
)
\
if
(
nsCSSProps
:
:
IsEnabled
(
*
it_
(
mozilla
:
:
CSSEnabledState
)
es_
)
)
static
const
KTableEntry
kCursorKTable
[
]
;
static
const
KTableEntry
kFontSmoothingKTable
[
]
;
static
const
KTableEntry
kTextAlignKTable
[
]
;
static
const
KTableEntry
kTextDecorationStyleKTable
[
]
;
}
;
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aOut
nsCSSPropertyID
aProperty
)
{
return
aOut
<
<
nsCSSProps
:
:
GetStringValue
(
aProperty
)
;
}
#
endif
