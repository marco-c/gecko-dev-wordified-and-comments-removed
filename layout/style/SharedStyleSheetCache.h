#
ifndef
mozilla_SharedStyleSheetCache_h__
#
define
mozilla_SharedStyleSheetCache_h__
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
SharedSubResourceCache
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
namespace
mozilla
{
class
StyleSheet
;
class
SheetLoadDataHashKey
;
namespace
css
{
class
SheetLoadData
;
class
Loader
;
}
struct
SharedStyleSheetCacheTraits
{
using
Loader
=
css
:
:
Loader
;
using
Key
=
SheetLoadDataHashKey
;
using
Value
=
StyleSheet
;
using
LoadingValue
=
css
:
:
SheetLoadData
;
static
SheetLoadDataHashKey
KeyFromLoadingValue
(
const
LoadingValue
&
aValue
)
{
return
SheetLoadDataHashKey
(
aValue
)
;
}
}
;
class
SharedStyleSheetCache
final
:
public
SharedSubResourceCache
<
SharedStyleSheetCacheTraits
SharedStyleSheetCache
>
public
nsIMemoryReporter
{
public
:
using
Base
=
SharedSubResourceCache
<
SharedStyleSheetCacheTraits
SharedStyleSheetCache
>
;
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
SharedStyleSheetCache
(
)
;
void
Init
(
)
;
static
void
LoadCompleted
(
SharedStyleSheetCache
*
css
:
:
SheetLoadData
&
nsresult
)
;
using
Base
:
:
LoadCompleted
;
static
void
LoadCompletedInternal
(
SharedStyleSheetCache
*
css
:
:
SheetLoadData
&
nsTArray
<
RefPtr
<
css
:
:
SheetLoadData
>
>
&
)
;
static
void
Clear
(
const
Maybe
<
bool
>
&
aChrome
=
Nothing
(
)
const
Maybe
<
nsCOMPtr
<
nsIPrincipal
>
>
&
aPrincipal
=
Nothing
(
)
const
Maybe
<
nsCString
>
&
aSchemelessSite
=
Nothing
(
)
const
Maybe
<
OriginAttributesPattern
>
&
aPattern
=
Nothing
(
)
const
Maybe
<
nsCString
>
&
aURL
=
Nothing
(
)
)
;
void
EvictPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
Base
:
:
EvictPrincipal
(
aPrincipal
)
;
mInlineSheets
.
Remove
(
aPrincipal
)
;
}
void
ClearInProcess
(
const
Maybe
<
bool
>
&
aChrome
const
Maybe
<
nsCOMPtr
<
nsIPrincipal
>
>
&
aPrincipal
const
Maybe
<
nsCString
>
&
aSchemelessSite
const
Maybe
<
OriginAttributesPattern
>
&
aPattern
const
Maybe
<
nsCString
>
&
aURL
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
)
const
;
auto
LookupInline
(
nsIPrincipal
*
aPrincipal
const
nsAString
&
aBuffer
)
{
auto
&
principalMap
=
mInlineSheets
.
LookupOrInsert
(
aPrincipal
)
;
return
principalMap
.
Lookup
(
aBuffer
)
;
}
struct
InlineSheetEntry
{
RefPtr
<
StyleSheet
>
mSheet
;
bool
mWasLoadedAsImage
=
false
;
}
;
using
InlineSheetCandidates
=
nsTArray
<
InlineSheetEntry
>
;
void
InsertInline
(
nsIPrincipal
*
aPrincipal
const
nsAString
&
aBuffer
InlineSheetEntry
&
&
aEntry
)
{
auto
&
principalMap
=
mInlineSheets
.
LookupOrInsert
(
aPrincipal
)
;
principalMap
.
LookupOrInsertWith
(
aBuffer
[
]
{
return
InlineSheetCandidates
(
)
;
}
)
.
AppendElement
(
std
:
:
move
(
aEntry
)
)
;
}
protected
:
void
InsertIfNeeded
(
css
:
:
SheetLoadData
&
)
;
nsTHashMap
<
PrincipalHashKey
nsTHashMap
<
nsStringHashKey
InlineSheetCandidates
>
>
mInlineSheets
;
~
SharedStyleSheetCache
(
)
;
}
;
}
#
endif
