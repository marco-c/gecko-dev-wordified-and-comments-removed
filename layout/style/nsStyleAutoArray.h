#
ifndef
nsStyleAutoArray_h_
#
define
nsStyleAutoArray_h_
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
template
<
typename
T
>
class
nsStyleAutoArray
{
public
:
enum
WithSingleInitialElement
{
WITH_SINGLE_INITIAL_ELEMENT
}
;
explicit
nsStyleAutoArray
(
WithSingleInitialElement
)
{
}
nsStyleAutoArray
(
const
nsStyleAutoArray
&
aOther
)
{
*
this
=
aOther
;
}
nsStyleAutoArray
&
operator
=
(
const
nsStyleAutoArray
&
aOther
)
{
mFirstElement
=
aOther
.
mFirstElement
;
mOtherElements
=
aOther
.
mOtherElements
.
Clone
(
)
;
return
*
this
;
}
bool
operator
=
=
(
const
nsStyleAutoArray
&
aOther
)
const
{
return
Length
(
)
=
=
aOther
.
Length
(
)
&
&
mFirstElement
=
=
aOther
.
mFirstElement
&
&
mOtherElements
=
=
aOther
.
mOtherElements
;
}
bool
operator
!
=
(
const
nsStyleAutoArray
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsStyleAutoArray
(
nsStyleAutoArray
&
&
aOther
)
=
default
;
nsStyleAutoArray
&
operator
=
(
nsStyleAutoArray
&
&
aOther
)
=
default
;
size_t
Length
(
)
const
{
return
mOtherElements
.
Length
(
)
+
1
;
}
const
T
&
operator
[
]
(
size_t
aIndex
)
const
{
return
aIndex
=
=
0
?
mFirstElement
:
mOtherElements
[
aIndex
-
1
]
;
}
T
&
operator
[
]
(
size_t
aIndex
)
{
return
aIndex
=
=
0
?
mFirstElement
:
mOtherElements
[
aIndex
-
1
]
;
}
void
EnsureLengthAtLeast
(
size_t
aMinLen
)
{
if
(
aMinLen
>
0
)
{
mOtherElements
.
EnsureLengthAtLeast
(
aMinLen
-
1
)
;
}
}
void
SetLengthNonZero
(
size_t
aNewLen
)
{
MOZ_ASSERT
(
aNewLen
>
0
)
;
mOtherElements
.
SetLength
(
aNewLen
-
1
)
;
}
void
TruncateLengthNonZero
(
size_t
aNewLen
)
{
MOZ_ASSERT
(
aNewLen
>
0
)
;
MOZ_ASSERT
(
aNewLen
<
=
Length
(
)
)
;
mOtherElements
.
TruncateLength
(
aNewLen
-
1
)
;
}
private
:
T
mFirstElement
;
nsTArray
<
T
>
mOtherElements
;
}
;
#
endif
