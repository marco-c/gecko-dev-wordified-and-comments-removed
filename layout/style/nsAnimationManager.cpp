#
include
"
nsAnimationManager
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
mozilla
/
dom
/
CSSAnimationBinding
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectReadOnly
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSRules
.
h
"
#
include
"
mozilla
/
GeckoRestyleManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
#
include
"
nsRFPService
.
h
"
#
include
<
algorithm
>
#
include
<
math
.
h
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
mozilla
:
:
dom
:
:
Animation
;
using
mozilla
:
:
dom
:
:
AnimationEffectReadOnly
;
using
mozilla
:
:
dom
:
:
AnimationPlayState
;
using
mozilla
:
:
dom
:
:
KeyframeEffectReadOnly
;
using
mozilla
:
:
dom
:
:
CSSAnimation
;
typedef
mozilla
:
:
ComputedTiming
:
:
AnimationPhase
AnimationPhase
;
JSObject
*
CSSAnimation
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
CSSAnimationBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
mozilla
:
:
dom
:
:
Promise
*
CSSAnimation
:
:
GetReady
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
return
Animation
:
:
GetReady
(
aRv
)
;
}
void
CSSAnimation
:
:
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
{
mPauseShouldStick
=
false
;
Animation
:
:
Play
(
aRv
aLimitBehavior
)
;
}
void
CSSAnimation
:
:
Pause
(
ErrorResult
&
aRv
)
{
mPauseShouldStick
=
true
;
Animation
:
:
Pause
(
aRv
)
;
}
AnimationPlayState
CSSAnimation
:
:
PlayStateFromJS
(
)
const
{
FlushStyle
(
)
;
return
Animation
:
:
PlayStateFromJS
(
)
;
}
bool
CSSAnimation
:
:
PendingFromJS
(
)
const
{
FlushStyle
(
)
;
return
Animation
:
:
PendingFromJS
(
)
;
}
void
CSSAnimation
:
:
PlayFromJS
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
Animation
:
:
PlayFromJS
(
aRv
)
;
}
void
CSSAnimation
:
:
PlayFromStyle
(
)
{
mIsStylePaused
=
false
;
if
(
!
mPauseShouldStick
)
{
ErrorResult
rv
;
PlayNoUpdate
(
rv
Animation
:
:
LimitBehavior
:
:
Continue
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Unexpected
exception
playing
animation
"
)
;
}
}
void
CSSAnimation
:
:
PauseFromStyle
(
)
{
if
(
mIsStylePaused
)
{
return
;
}
mIsStylePaused
=
true
;
ErrorResult
rv
;
PauseNoUpdate
(
rv
)
;
if
(
rv
.
Failed
(
)
)
{
NS_WARNING
(
"
Unexpected
exception
pausing
animation
-
silently
failing
"
)
;
}
}
void
CSSAnimation
:
:
Tick
(
)
{
Animation
:
:
Tick
(
)
;
QueueEvents
(
)
;
}
bool
CSSAnimation
:
:
HasLowerCompositeOrderThan
(
const
CSSAnimation
&
aOther
)
const
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
&
&
aOther
.
IsTiedToMarkup
(
)
"
Should
only
be
called
for
CSS
animations
that
are
sorted
"
"
as
CSS
animations
(
i
.
e
.
tied
to
CSS
markup
)
"
)
;
if
(
&
aOther
=
=
this
)
{
return
false
;
}
if
(
!
mOwningElement
.
Equals
(
aOther
.
mOwningElement
)
)
{
return
mOwningElement
.
LessThan
(
aOther
.
mOwningElement
)
;
}
return
mAnimationIndex
<
aOther
.
mAnimationIndex
;
}
void
CSSAnimation
:
:
QueueEvents
(
const
StickyTimeDuration
&
aActiveTime
)
{
if
(
mPendingState
!
=
PendingState
:
:
NotPending
)
{
return
;
}
if
(
!
mOwningElement
.
IsSet
(
)
)
{
return
;
}
nsPresContext
*
presContext
=
mOwningElement
.
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
static
constexpr
StickyTimeDuration
zeroDuration
=
StickyTimeDuration
(
)
;
uint64_t
currentIteration
=
0
;
ComputedTiming
:
:
AnimationPhase
currentPhase
;
StickyTimeDuration
intervalStartTime
;
StickyTimeDuration
intervalEndTime
;
StickyTimeDuration
iterationStartTime
;
if
(
!
mEffect
)
{
currentPhase
=
GetAnimationPhaseWithoutEffect
<
ComputedTiming
:
:
AnimationPhase
>
(
*
this
)
;
}
else
{
ComputedTiming
computedTiming
=
mEffect
-
>
GetComputedTiming
(
)
;
currentPhase
=
computedTiming
.
mPhase
;
currentIteration
=
computedTiming
.
mCurrentIteration
;
if
(
currentPhase
=
=
mPreviousPhase
&
&
currentIteration
=
=
mPreviousIteration
)
{
return
;
}
intervalStartTime
=
std
:
:
max
(
std
:
:
min
(
StickyTimeDuration
(
-
mEffect
-
>
SpecifiedTiming
(
)
.
Delay
(
)
)
computedTiming
.
mActiveDuration
)
zeroDuration
)
;
intervalEndTime
=
std
:
:
max
(
std
:
:
min
(
(
EffectEnd
(
)
-
mEffect
-
>
SpecifiedTiming
(
)
.
Delay
(
)
)
computedTiming
.
mActiveDuration
)
zeroDuration
)
;
uint64_t
iterationBoundary
=
mPreviousIteration
>
currentIteration
?
currentIteration
+
1
:
currentIteration
;
iterationStartTime
=
computedTiming
.
mDuration
.
MultDouble
(
(
iterationBoundary
-
computedTiming
.
mIterationStart
)
)
;
}
TimeStamp
startTimeStamp
=
ElapsedTimeToTimeStamp
(
intervalStartTime
)
;
TimeStamp
endTimeStamp
=
ElapsedTimeToTimeStamp
(
intervalEndTime
)
;
TimeStamp
iterationTimeStamp
=
ElapsedTimeToTimeStamp
(
iterationStartTime
)
;
AutoTArray
<
AnimationEventInfo
2
>
events
;
auto
appendAnimationEvent
=
[
&
]
(
EventMessage
aMessage
const
StickyTimeDuration
&
aElapsedTime
const
TimeStamp
&
aTimeStamp
)
{
double
elapsedTime
=
aElapsedTime
.
ToSeconds
(
)
;
if
(
aMessage
=
=
eAnimationCancel
)
{
elapsedTime
=
nsRFPService
:
:
ReduceTimePrecisionAsSecs
(
elapsedTime
)
;
}
events
.
AppendElement
(
AnimationEventInfo
(
mOwningElement
.
Target
(
)
aMessage
mAnimationName
elapsedTime
aTimeStamp
this
)
)
;
}
;
if
(
(
mPreviousPhase
!
=
AnimationPhase
:
:
Idle
&
&
mPreviousPhase
!
=
AnimationPhase
:
:
After
)
&
&
currentPhase
=
=
AnimationPhase
:
:
Idle
)
{
TimeStamp
activeTimeStamp
=
ElapsedTimeToTimeStamp
(
aActiveTime
)
;
appendAnimationEvent
(
eAnimationCancel
aActiveTime
activeTimeStamp
)
;
}
switch
(
mPreviousPhase
)
{
case
AnimationPhase
:
:
Idle
:
case
AnimationPhase
:
:
Before
:
if
(
currentPhase
=
=
AnimationPhase
:
:
Active
)
{
appendAnimationEvent
(
eAnimationStart
intervalStartTime
startTimeStamp
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
After
)
{
appendAnimationEvent
(
eAnimationStart
intervalStartTime
startTimeStamp
)
;
appendAnimationEvent
(
eAnimationEnd
intervalEndTime
endTimeStamp
)
;
}
break
;
case
AnimationPhase
:
:
Active
:
if
(
currentPhase
=
=
AnimationPhase
:
:
Before
)
{
appendAnimationEvent
(
eAnimationEnd
intervalStartTime
startTimeStamp
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
Active
)
{
MOZ_ASSERT
(
currentIteration
!
=
mPreviousIteration
)
;
appendAnimationEvent
(
eAnimationIteration
iterationStartTime
iterationTimeStamp
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
After
)
{
appendAnimationEvent
(
eAnimationEnd
intervalEndTime
endTimeStamp
)
;
}
break
;
case
AnimationPhase
:
:
After
:
if
(
currentPhase
=
=
AnimationPhase
:
:
Before
)
{
appendAnimationEvent
(
eAnimationStart
intervalEndTime
startTimeStamp
)
;
appendAnimationEvent
(
eAnimationEnd
intervalStartTime
endTimeStamp
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
Active
)
{
appendAnimationEvent
(
eAnimationStart
intervalEndTime
endTimeStamp
)
;
}
break
;
}
mPreviousPhase
=
currentPhase
;
mPreviousIteration
=
currentIteration
;
if
(
!
events
.
IsEmpty
(
)
)
{
presContext
-
>
AnimationManager
(
)
-
>
QueueEvents
(
Move
(
events
)
)
;
}
}
void
CSSAnimation
:
:
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
if
(
mNeedsNewAnimationIndexWhenRun
&
&
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
false
;
}
Animation
:
:
UpdateTiming
(
aSeekFlag
aSyncNotifyFlag
)
;
}
NS_IMPL_CYCLE_COLLECTION
(
nsAnimationManager
mEventDispatcher
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
nsAnimationManager
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
nsAnimationManager
Release
)
static
already_AddRefed
<
CSSAnimation
>
PopExistingAnimation
(
const
nsAtom
*
aName
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
if
(
!
aCollection
)
{
return
nullptr
;
}
for
(
size_t
idx
=
0
length
=
aCollection
-
>
mAnimations
.
Length
(
)
;
idx
!
=
length
;
+
+
idx
)
{
CSSAnimation
*
cssAnim
=
aCollection
-
>
mAnimations
[
idx
]
;
if
(
cssAnim
-
>
AnimationName
(
)
=
=
aName
)
{
RefPtr
<
CSSAnimation
>
match
=
cssAnim
;
aCollection
-
>
mAnimations
.
RemoveElementAt
(
idx
)
;
return
match
.
forget
(
)
;
}
}
return
nullptr
;
}
class
ResolvedStyleCache
{
public
:
ResolvedStyleCache
(
)
:
mCache
(
)
{
}
GeckoStyleContext
*
Get
(
nsPresContext
*
aPresContext
GeckoStyleContext
*
aParentStyleContext
Declaration
*
aKeyframeDeclaration
)
;
private
:
nsRefPtrHashtable
<
nsPtrHashKey
<
Declaration
>
GeckoStyleContext
>
mCache
;
}
;
GeckoStyleContext
*
ResolvedStyleCache
:
:
Get
(
nsPresContext
*
aPresContext
GeckoStyleContext
*
aParentStyleContext
Declaration
*
aKeyframeDeclaration
)
{
GeckoStyleContext
*
result
=
mCache
.
GetWeak
(
aKeyframeDeclaration
)
;
if
(
!
result
)
{
aKeyframeDeclaration
-
>
SetImmutable
(
)
;
MOZ_ASSERT
(
!
aKeyframeDeclaration
-
>
HasImportantData
(
)
"
Keyframe
rule
has
!
important
data
"
)
;
nsCOMArray
<
nsIStyleRule
>
rules
;
rules
.
AppendObject
(
aKeyframeDeclaration
)
;
MOZ_ASSERT
(
aPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
RefPtr
<
GeckoStyleContext
>
resultStrong
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleByAddingRules
(
aParentStyleContext
rules
)
;
mCache
.
Put
(
aKeyframeDeclaration
resultStrong
)
;
result
=
resultStrong
;
}
return
result
;
}
class
MOZ_STACK_CLASS
ServoCSSAnimationBuilder
final
{
public
:
explicit
ServoCSSAnimationBuilder
(
const
ServoStyleContext
*
aStyleContext
)
:
mStyleContext
(
aStyleContext
)
{
MOZ_ASSERT
(
aStyleContext
)
;
}
bool
BuildKeyframes
(
nsPresContext
*
aPresContext
nsAtom
*
aName
const
nsTimingFunction
&
aTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
ServoStyleSet
*
styleSet
=
aPresContext
-
>
StyleSet
(
)
-
>
AsServo
(
)
;
MOZ_ASSERT
(
styleSet
)
;
return
styleSet
-
>
GetKeyframesForName
(
aName
aTimingFunction
aKeyframes
)
;
}
void
SetKeyframes
(
KeyframeEffectReadOnly
&
aEffect
nsTArray
<
Keyframe
>
&
&
aKeyframes
)
{
aEffect
.
SetKeyframes
(
Move
(
aKeyframes
)
mStyleContext
)
;
}
void
NotifyNewOrRemovedAnimation
(
const
Animation
&
aAnimation
)
{
AnimationEffectReadOnly
*
effect
=
aAnimation
.
GetEffect
(
)
;
if
(
!
effect
)
{
return
;
}
KeyframeEffectReadOnly
*
keyframeEffect
=
effect
-
>
AsKeyframeEffect
(
)
;
if
(
!
keyframeEffect
)
{
return
;
}
keyframeEffect
-
>
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Standard
)
;
}
private
:
const
ServoStyleContext
*
mStyleContext
;
}
;
class
MOZ_STACK_CLASS
GeckoCSSAnimationBuilder
final
{
public
:
GeckoCSSAnimationBuilder
(
GeckoStyleContext
*
aStyleContext
const
NonOwningAnimationTarget
&
aTarget
)
:
mStyleContext
(
aStyleContext
)
mTarget
(
aTarget
)
{
MOZ_ASSERT
(
aStyleContext
)
;
MOZ_ASSERT
(
aTarget
.
mElement
)
;
}
bool
BuildKeyframes
(
nsPresContext
*
aPresContext
nsAtom
*
aName
const
nsTimingFunction
&
aTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframs
)
;
void
SetKeyframes
(
KeyframeEffectReadOnly
&
aEffect
nsTArray
<
Keyframe
>
&
&
aKeyframes
)
{
aEffect
.
SetKeyframes
(
Move
(
aKeyframes
)
mStyleContext
)
;
}
void
NotifyNewOrRemovedAnimation
(
const
Animation
&
)
{
}
private
:
nsTArray
<
Keyframe
>
BuildAnimationFrames
(
nsPresContext
*
aPresContext
const
nsTimingFunction
&
aTimingFunction
const
nsCSSKeyframesRule
*
aRule
)
;
Maybe
<
ComputedTimingFunction
>
GetKeyframeTimingFunction
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
)
;
nsTArray
<
PropertyValuePair
>
GetKeyframePropertyValues
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
nsCSSPropertyIDSet
&
aAnimatedProperties
)
;
void
FillInMissingKeyframeValues
(
nsCSSPropertyIDSet
aAnimatedProperties
nsCSSPropertyIDSet
aPropertiesSetAtStart
nsCSSPropertyIDSet
aPropertiesSetAtEnd
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
;
RefPtr
<
GeckoStyleContext
>
mStyleContext
;
NonOwningAnimationTarget
mTarget
;
ResolvedStyleCache
mResolvedStyles
;
}
;
static
Maybe
<
ComputedTimingFunction
>
ConvertTimingFunction
(
const
nsTimingFunction
&
aTimingFunction
)
;
template
<
class
BuilderType
>
static
void
UpdateOldAnimationPropertiesWithNew
(
CSSAnimation
&
aOld
TimingParams
&
aNewTiming
nsTArray
<
Keyframe
>
&
&
aNewKeyframes
bool
aNewIsStylePaused
BuilderType
&
aBuilder
)
{
bool
animationChanged
=
false
;
if
(
aOld
.
GetEffect
(
)
)
{
dom
:
:
AnimationEffectReadOnly
*
oldEffect
=
aOld
.
GetEffect
(
)
;
animationChanged
=
oldEffect
-
>
SpecifiedTiming
(
)
!
=
aNewTiming
;
oldEffect
-
>
SetSpecifiedTiming
(
aNewTiming
)
;
KeyframeEffectReadOnly
*
oldKeyframeEffect
=
oldEffect
-
>
AsKeyframeEffect
(
)
;
if
(
oldKeyframeEffect
)
{
aBuilder
.
SetKeyframes
(
*
oldKeyframeEffect
Move
(
aNewKeyframes
)
)
;
}
}
if
(
aOld
.
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
if
(
!
aOld
.
IsStylePaused
(
)
&
&
aNewIsStylePaused
)
{
aOld
.
PauseFromStyle
(
)
;
animationChanged
=
true
;
}
else
if
(
aOld
.
IsStylePaused
(
)
&
&
!
aNewIsStylePaused
)
{
aOld
.
PlayFromStyle
(
)
;
animationChanged
=
true
;
}
}
if
(
animationChanged
&
&
aOld
.
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
&
aOld
)
;
}
}
template
<
class
BuilderType
>
static
already_AddRefed
<
CSSAnimation
>
BuildAnimation
(
nsPresContext
*
aPresContext
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleDisplay
&
aStyleDisplay
uint32_t
animIdx
BuilderType
&
aBuilder
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
MOZ_ASSERT
(
aPresContext
)
;
nsAtom
*
animationName
=
aStyleDisplay
.
GetAnimationName
(
animIdx
)
;
nsTArray
<
Keyframe
>
keyframes
;
if
(
!
aBuilder
.
BuildKeyframes
(
aPresContext
animationName
aStyleDisplay
.
GetAnimationTimingFunction
(
animIdx
)
keyframes
)
)
{
return
nullptr
;
}
TimingParams
timing
=
TimingParamsFromCSSParams
(
aStyleDisplay
.
GetAnimationDuration
(
animIdx
)
aStyleDisplay
.
GetAnimationDelay
(
animIdx
)
aStyleDisplay
.
GetAnimationIterationCount
(
animIdx
)
aStyleDisplay
.
GetAnimationDirection
(
animIdx
)
aStyleDisplay
.
GetAnimationFillMode
(
animIdx
)
)
;
bool
isStylePaused
=
aStyleDisplay
.
GetAnimationPlayState
(
animIdx
)
=
=
NS_STYLE_ANIMATION_PLAY_STATE_PAUSED
;
RefPtr
<
CSSAnimation
>
oldAnim
=
PopExistingAnimation
(
animationName
aCollection
)
;
if
(
oldAnim
)
{
UpdateOldAnimationPropertiesWithNew
(
*
oldAnim
timing
Move
(
keyframes
)
isStylePaused
aBuilder
)
;
return
oldAnim
.
forget
(
)
;
}
Maybe
<
OwningAnimationTarget
>
target
;
target
.
emplace
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
;
KeyframeEffectParams
effectOptions
;
RefPtr
<
KeyframeEffectReadOnly
>
effect
=
new
KeyframeEffectReadOnly
(
aPresContext
-
>
Document
(
)
target
timing
effectOptions
)
;
aBuilder
.
SetKeyframes
(
*
effect
Move
(
keyframes
)
)
;
RefPtr
<
CSSAnimation
>
animation
=
new
CSSAnimation
(
aPresContext
-
>
Document
(
)
-
>
GetScopeObject
(
)
animationName
)
;
animation
-
>
SetOwningElement
(
OwningElementRef
(
*
aTarget
.
mElement
aTarget
.
mPseudoType
)
)
;
animation
-
>
SetTimelineNoUpdate
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
)
;
animation
-
>
SetEffectNoUpdate
(
effect
)
;
if
(
isStylePaused
)
{
animation
-
>
PauseFromStyle
(
)
;
}
else
{
animation
-
>
PlayFromStyle
(
)
;
}
aBuilder
.
NotifyNewOrRemovedAnimation
(
*
animation
)
;
return
animation
.
forget
(
)
;
}
bool
GeckoCSSAnimationBuilder
:
:
BuildKeyframes
(
nsPresContext
*
aPresContext
nsAtom
*
aName
const
nsTimingFunction
&
aTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
MOZ_ASSERT
(
aPresContext
)
;
MOZ_ASSERT
(
aPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
)
;
nsCSSKeyframesRule
*
rule
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
KeyframesRuleForName
(
aName
)
;
if
(
!
rule
)
{
return
false
;
}
aKeyframes
=
BuildAnimationFrames
(
aPresContext
aTimingFunction
rule
)
;
return
true
;
}
nsTArray
<
Keyframe
>
GeckoCSSAnimationBuilder
:
:
BuildAnimationFrames
(
nsPresContext
*
aPresContext
const
nsTimingFunction
&
aTimingFunction
const
nsCSSKeyframesRule
*
aRule
)
{
Maybe
<
ComputedTimingFunction
>
inheritedTimingFunction
=
ConvertTimingFunction
(
aTimingFunction
)
;
nsTArray
<
Keyframe
>
keyframes
;
nsCSSPropertyIDSet
animatedProperties
;
for
(
auto
ruleIdx
=
0
ruleEnd
=
aRule
-
>
StyleRuleCount
(
)
;
ruleIdx
!
=
ruleEnd
;
+
+
ruleIdx
)
{
css
:
:
Rule
*
cssRule
=
aRule
-
>
GetStyleRuleAt
(
ruleIdx
)
;
MOZ_ASSERT
(
cssRule
"
must
have
rule
"
)
;
MOZ_ASSERT
(
cssRule
-
>
GetType
(
)
=
=
css
:
:
Rule
:
:
KEYFRAME_RULE
"
must
be
keyframe
rule
"
)
;
nsCSSKeyframeRule
*
keyframeRule
=
static_cast
<
nsCSSKeyframeRule
*
>
(
cssRule
)
;
const
nsTArray
<
float
>
&
keys
=
keyframeRule
-
>
GetKeys
(
)
;
for
(
float
key
:
keys
)
{
if
(
key
<
0
.
0f
|
|
key
>
1
.
0f
)
{
continue
;
}
Keyframe
keyframe
;
keyframe
.
mOffset
.
emplace
(
key
)
;
keyframe
.
mTimingFunction
=
GetKeyframeTimingFunction
(
aPresContext
keyframeRule
inheritedTimingFunction
)
;
keyframe
.
mPropertyValues
=
GetKeyframePropertyValues
(
aPresContext
keyframeRule
animatedProperties
)
;
keyframes
.
AppendElement
(
Move
(
keyframe
)
)
;
}
}
std
:
:
stable_sort
(
keyframes
.
begin
(
)
keyframes
.
end
(
)
[
]
(
const
Keyframe
&
a
const
Keyframe
&
b
)
{
return
a
.
mOffset
<
b
.
mOffset
;
}
)
;
nsCSSPropertyIDSet
propertiesSetAtCurrentOffset
;
nsCSSPropertyIDSet
propertiesSetAtStart
;
nsCSSPropertyIDSet
propertiesSetAtEnd
;
double
currentOffset
=
-
1
.
0
;
for
(
size_t
keyframeIdx
=
keyframes
.
Length
(
)
;
keyframeIdx
>
0
;
-
-
keyframeIdx
)
{
Keyframe
&
keyframe
=
keyframes
[
keyframeIdx
-
1
]
;
MOZ_ASSERT
(
keyframe
.
mOffset
"
Should
have
filled
in
the
offset
"
)
;
if
(
keyframe
.
mOffset
.
value
(
)
!
=
currentOffset
)
{
propertiesSetAtCurrentOffset
.
Empty
(
)
;
currentOffset
=
keyframe
.
mOffset
.
value
(
)
;
}
nsTArray
<
PropertyValuePair
>
uniquePropertyValues
;
uniquePropertyValues
.
SetCapacity
(
keyframe
.
mPropertyValues
.
Length
(
)
)
;
for
(
const
PropertyValuePair
&
pair
:
keyframe
.
mPropertyValues
)
{
if
(
!
propertiesSetAtCurrentOffset
.
HasProperty
(
pair
.
mProperty
)
)
{
uniquePropertyValues
.
AppendElement
(
pair
)
;
propertiesSetAtCurrentOffset
.
AddProperty
(
pair
.
mProperty
)
;
if
(
currentOffset
=
=
0
.
0
)
{
propertiesSetAtStart
.
AddProperty
(
pair
.
mProperty
)
;
}
else
if
(
currentOffset
=
=
1
.
0
)
{
propertiesSetAtEnd
.
AddProperty
(
pair
.
mProperty
)
;
}
}
}
Keyframe
*
existingKeyframe
=
nullptr
;
if
(
!
uniquePropertyValues
.
IsEmpty
(
)
)
{
for
(
size_t
i
=
keyframeIdx
;
i
<
keyframes
.
Length
(
)
;
i
+
+
)
{
Keyframe
&
kf
=
keyframes
[
i
]
;
if
(
kf
.
mOffset
.
value
(
)
!
=
currentOffset
)
{
break
;
}
if
(
kf
.
mTimingFunction
=
=
keyframe
.
mTimingFunction
)
{
existingKeyframe
=
&
kf
;
break
;
}
}
}
if
(
existingKeyframe
)
{
existingKeyframe
-
>
mPropertyValues
.
AppendElements
(
Move
(
uniquePropertyValues
)
)
;
keyframe
.
mPropertyValues
.
Clear
(
)
;
}
else
{
keyframe
.
mPropertyValues
.
SwapElements
(
uniquePropertyValues
)
;
}
if
(
keyframe
.
mPropertyValues
.
IsEmpty
(
)
)
{
keyframes
.
RemoveElementAt
(
keyframeIdx
-
1
)
;
}
}
FillInMissingKeyframeValues
(
animatedProperties
propertiesSetAtStart
propertiesSetAtEnd
inheritedTimingFunction
keyframes
)
;
return
keyframes
;
}
Maybe
<
ComputedTimingFunction
>
GeckoCSSAnimationBuilder
:
:
GetKeyframeTimingFunction
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
)
{
Maybe
<
ComputedTimingFunction
>
result
;
if
(
aKeyframeRule
-
>
Declaration
(
)
&
&
aKeyframeRule
-
>
Declaration
(
)
-
>
HasProperty
(
eCSSProperty_animation_timing_function
)
)
{
RefPtr
<
nsStyleContext
>
keyframeRuleContext
=
mResolvedStyles
.
Get
(
aPresContext
mStyleContext
aKeyframeRule
-
>
Declaration
(
)
)
;
const
nsTimingFunction
&
tf
=
keyframeRuleContext
-
>
StyleDisplay
(
)
-
>
mAnimations
[
0
]
.
GetTimingFunction
(
)
;
result
=
ConvertTimingFunction
(
tf
)
;
}
else
{
result
=
aInheritedTimingFunction
;
}
return
result
;
}
static
Maybe
<
ComputedTimingFunction
>
ConvertTimingFunction
(
const
nsTimingFunction
&
aTimingFunction
)
{
Maybe
<
ComputedTimingFunction
>
result
;
if
(
aTimingFunction
.
mType
!
=
nsTimingFunction
:
:
Type
:
:
Linear
)
{
result
.
emplace
(
)
;
result
-
>
Init
(
aTimingFunction
)
;
}
return
result
;
}
nsTArray
<
PropertyValuePair
>
GeckoCSSAnimationBuilder
:
:
GetKeyframePropertyValues
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
nsCSSPropertyIDSet
&
aAnimatedProperties
)
{
nsTArray
<
PropertyValuePair
>
result
;
RefPtr
<
GeckoStyleContext
>
styleContext
=
mResolvedStyles
.
Get
(
aPresContext
mStyleContext
aKeyframeRule
-
>
Declaration
(
)
)
;
for
(
nsCSSPropertyID
prop
=
nsCSSPropertyID
(
0
)
;
prop
<
eCSSProperty_COUNT_no_shorthands
;
prop
=
nsCSSPropertyID
(
prop
+
1
)
)
{
if
(
nsCSSProps
:
:
kAnimTypeTable
[
prop
]
=
=
eStyleAnimType_None
|
|
!
aKeyframeRule
-
>
Declaration
(
)
-
>
HasNonImportantValueFor
(
prop
)
)
{
continue
;
}
StyleAnimationValue
computedValue
;
if
(
!
StyleAnimationValue
:
:
ExtractComputedValue
(
prop
styleContext
computedValue
)
)
{
continue
;
}
nsCSSValue
propertyValue
;
DebugOnly
<
bool
>
uncomputeResult
=
StyleAnimationValue
:
:
UncomputeValue
(
prop
Move
(
computedValue
)
propertyValue
)
;
MOZ_ASSERT
(
uncomputeResult
"
Unable
to
get
specified
value
from
computed
value
"
)
;
MOZ_ASSERT
(
propertyValue
.
GetUnit
(
)
!
=
eCSSUnit_Null
"
Not
expecting
to
read
invalid
properties
"
)
;
result
.
AppendElement
(
Move
(
PropertyValuePair
(
prop
Move
(
propertyValue
)
)
)
)
;
aAnimatedProperties
.
AddProperty
(
prop
)
;
}
return
result
;
}
void
GeckoCSSAnimationBuilder
:
:
FillInMissingKeyframeValues
(
nsCSSPropertyIDSet
aAnimatedProperties
nsCSSPropertyIDSet
aPropertiesSetAtStart
nsCSSPropertyIDSet
aPropertiesSetAtEnd
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
static
const
size_t
kNotSet
=
static_cast
<
size_t
>
(
-
1
)
;
size_t
startKeyframeIndex
=
kNotSet
;
if
(
!
aAnimatedProperties
.
Equals
(
aPropertiesSetAtStart
)
&
&
!
nsAnimationManager
:
:
FindMatchingKeyframe
(
aKeyframes
0
.
0
aInheritedTimingFunction
startKeyframeIndex
)
)
{
Keyframe
newKeyframe
;
newKeyframe
.
mOffset
.
emplace
(
0
.
0
)
;
newKeyframe
.
mTimingFunction
=
aInheritedTimingFunction
;
aKeyframes
.
InsertElementAt
(
startKeyframeIndex
Move
(
newKeyframe
)
)
;
}
size_t
endKeyframeIndex
=
kNotSet
;
if
(
!
aAnimatedProperties
.
Equals
(
aPropertiesSetAtEnd
)
)
{
if
(
!
nsAnimationManager
:
:
FindMatchingKeyframe
(
Reversed
(
aKeyframes
)
1
.
0
aInheritedTimingFunction
endKeyframeIndex
)
)
{
Keyframe
newKeyframe
;
newKeyframe
.
mOffset
.
emplace
(
1
.
0
)
;
newKeyframe
.
mTimingFunction
=
aInheritedTimingFunction
;
aKeyframes
.
AppendElement
(
Move
(
newKeyframe
)
)
;
endKeyframeIndex
=
aKeyframes
.
Length
(
)
-
1
;
}
else
{
endKeyframeIndex
=
aKeyframes
.
Length
(
)
-
1
-
endKeyframeIndex
;
}
}
if
(
startKeyframeIndex
=
=
kNotSet
&
&
endKeyframeIndex
=
=
kNotSet
)
{
return
;
}
Keyframe
*
startKeyframe
=
startKeyframeIndex
=
=
kNotSet
?
nullptr
:
&
aKeyframes
[
startKeyframeIndex
]
;
Keyframe
*
endKeyframe
=
endKeyframeIndex
=
=
kNotSet
?
nullptr
:
&
aKeyframes
[
endKeyframeIndex
]
;
for
(
nsCSSPropertyID
prop
=
nsCSSPropertyID
(
0
)
;
prop
<
eCSSProperty_COUNT_no_shorthands
;
prop
=
nsCSSPropertyID
(
prop
+
1
)
)
{
if
(
!
aAnimatedProperties
.
HasProperty
(
prop
)
)
{
continue
;
}
if
(
startKeyframe
&
&
!
aPropertiesSetAtStart
.
HasProperty
(
prop
)
)
{
PropertyValuePair
propertyValue
(
prop
Move
(
nsCSSValue
(
)
)
)
;
startKeyframe
-
>
mPropertyValues
.
AppendElement
(
Move
(
propertyValue
)
)
;
}
if
(
endKeyframe
&
&
!
aPropertiesSetAtEnd
.
HasProperty
(
prop
)
)
{
PropertyValuePair
propertyValue
(
prop
Move
(
nsCSSValue
(
)
)
)
;
endKeyframe
-
>
mPropertyValues
.
AppendElement
(
Move
(
propertyValue
)
)
;
}
}
}
template
<
class
BuilderType
>
static
nsAnimationManager
:
:
OwningCSSAnimationPtrArray
BuildAnimations
(
nsPresContext
*
aPresContext
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleDisplay
&
aStyleDisplay
BuilderType
&
aBuilder
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
nsAnimationManager
:
:
OwningCSSAnimationPtrArray
result
;
for
(
size_t
animIdx
=
aStyleDisplay
.
mAnimationNameCount
;
animIdx
-
-
!
=
0
;
)
{
if
(
aStyleDisplay
.
GetAnimationName
(
animIdx
)
=
=
nsGkAtoms
:
:
_empty
)
{
continue
;
}
RefPtr
<
CSSAnimation
>
dest
=
BuildAnimation
(
aPresContext
aTarget
aStyleDisplay
animIdx
aBuilder
aCollection
)
;
if
(
!
dest
)
{
continue
;
}
dest
-
>
SetAnimationIndex
(
static_cast
<
uint64_t
>
(
animIdx
)
)
;
result
.
AppendElement
(
dest
)
;
}
return
result
;
}
void
nsAnimationManager
:
:
UpdateAnimations
(
GeckoStyleContext
*
aStyleContext
mozilla
:
:
dom
:
:
Element
*
aElement
)
{
MOZ_ASSERT
(
mPresContext
-
>
IsDynamic
(
)
"
Should
not
update
animations
for
print
or
print
preview
"
)
;
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
"
Should
not
update
animations
that
are
not
attached
to
the
"
"
document
tree
"
)
;
if
(
aStyleContext
-
>
IsInDisplayNoneSubtree
(
)
)
{
StopAnimationsForElement
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
)
;
return
;
}
NonOwningAnimationTarget
target
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
)
;
GeckoCSSAnimationBuilder
builder
(
aStyleContext
target
)
;
const
nsStyleDisplay
*
disp
=
aStyleContext
-
>
StyleDisplay
(
)
;
DoUpdateAnimations
(
target
*
disp
builder
)
;
}
void
nsAnimationManager
:
:
UpdateAnimations
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
const
ServoStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
mPresContext
-
>
IsDynamic
(
)
"
Should
not
update
animations
for
print
or
print
preview
"
)
;
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
"
Should
not
update
animations
that
are
not
attached
to
the
"
"
document
tree
"
)
;
const
nsStyleDisplay
*
disp
=
aStyleContext
?
aStyleContext
-
>
ComputedData
(
)
-
>
GetStyleDisplay
(
)
:
nullptr
;
if
(
!
disp
|
|
disp
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
{
StopAnimationsForElement
(
aElement
aPseudoType
)
;
return
;
}
NonOwningAnimationTarget
target
(
aElement
aPseudoType
)
;
ServoCSSAnimationBuilder
builder
(
aStyleContext
)
;
DoUpdateAnimations
(
target
*
disp
builder
)
;
}
template
<
class
BuilderType
>
void
nsAnimationManager
:
:
DoUpdateAnimations
(
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleDisplay
&
aStyleDisplay
BuilderType
&
aBuilder
)
{
CSSAnimationCollection
*
collection
=
CSSAnimationCollection
:
:
GetAnimationCollection
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
;
if
(
!
collection
&
&
aStyleDisplay
.
mAnimationNameCount
=
=
1
&
&
aStyleDisplay
.
mAnimations
[
0
]
.
GetName
(
)
=
=
nsGkAtoms
:
:
_empty
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
)
;
OwningCSSAnimationPtrArray
newAnimations
;
newAnimations
=
BuildAnimations
(
mPresContext
aTarget
aStyleDisplay
aBuilder
collection
)
;
if
(
newAnimations
.
IsEmpty
(
)
)
{
if
(
collection
)
{
collection
-
>
Destroy
(
)
;
}
return
;
}
if
(
!
collection
)
{
bool
createdCollection
=
false
;
collection
=
CSSAnimationCollection
:
:
GetOrCreateAnimationCollection
(
aTarget
.
mElement
aTarget
.
mPseudoType
&
createdCollection
)
;
if
(
!
collection
)
{
MOZ_ASSERT
(
!
createdCollection
"
outparam
should
agree
with
return
value
"
)
;
NS_WARNING
(
"
allocating
collection
failed
"
)
;
return
;
}
if
(
createdCollection
)
{
AddElementCollection
(
collection
)
;
}
}
collection
-
>
mAnimations
.
SwapElements
(
newAnimations
)
;
for
(
size_t
newAnimIdx
=
newAnimations
.
Length
(
)
;
newAnimIdx
-
-
!
=
0
;
)
{
aBuilder
.
NotifyNewOrRemovedAnimation
(
*
newAnimations
[
newAnimIdx
]
)
;
newAnimations
[
newAnimIdx
]
-
>
CancelFromStyle
(
)
;
}
}
