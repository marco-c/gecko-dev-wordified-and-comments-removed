#
include
"
nsAnimationManager
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
mozilla
/
dom
/
CSSAnimationBinding
.
h
"
#
include
"
mozilla
/
AnimationEventDispatcher
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectReadOnly
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
#
include
"
nsRFPService
.
h
"
#
include
<
algorithm
>
#
include
<
math
.
h
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
mozilla
:
:
dom
:
:
Animation
;
using
mozilla
:
:
dom
:
:
AnimationEffectReadOnly
;
using
mozilla
:
:
dom
:
:
AnimationPlayState
;
using
mozilla
:
:
dom
:
:
KeyframeEffectReadOnly
;
using
mozilla
:
:
dom
:
:
CSSAnimation
;
typedef
mozilla
:
:
ComputedTiming
:
:
AnimationPhase
AnimationPhase
;
JSObject
*
CSSAnimation
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
CSSAnimationBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
mozilla
:
:
dom
:
:
Promise
*
CSSAnimation
:
:
GetReady
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
return
Animation
:
:
GetReady
(
aRv
)
;
}
void
CSSAnimation
:
:
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
{
mPauseShouldStick
=
false
;
Animation
:
:
Play
(
aRv
aLimitBehavior
)
;
}
void
CSSAnimation
:
:
Pause
(
ErrorResult
&
aRv
)
{
mPauseShouldStick
=
true
;
Animation
:
:
Pause
(
aRv
)
;
}
AnimationPlayState
CSSAnimation
:
:
PlayStateFromJS
(
)
const
{
FlushStyle
(
)
;
return
Animation
:
:
PlayStateFromJS
(
)
;
}
bool
CSSAnimation
:
:
PendingFromJS
(
)
const
{
FlushStyle
(
)
;
return
Animation
:
:
PendingFromJS
(
)
;
}
void
CSSAnimation
:
:
PlayFromJS
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
Animation
:
:
PlayFromJS
(
aRv
)
;
}
void
CSSAnimation
:
:
PlayFromStyle
(
)
{
mIsStylePaused
=
false
;
if
(
!
mPauseShouldStick
)
{
ErrorResult
rv
;
Animation
:
:
Play
(
rv
Animation
:
:
LimitBehavior
:
:
Continue
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Unexpected
exception
playing
animation
"
)
;
}
}
void
CSSAnimation
:
:
PauseFromStyle
(
)
{
if
(
mIsStylePaused
)
{
return
;
}
mIsStylePaused
=
true
;
ErrorResult
rv
;
Animation
:
:
Pause
(
rv
)
;
if
(
rv
.
Failed
(
)
)
{
NS_WARNING
(
"
Unexpected
exception
pausing
animation
-
silently
failing
"
)
;
}
}
void
CSSAnimation
:
:
Tick
(
)
{
Animation
:
:
Tick
(
)
;
QueueEvents
(
)
;
}
bool
CSSAnimation
:
:
HasLowerCompositeOrderThan
(
const
CSSAnimation
&
aOther
)
const
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
&
&
aOther
.
IsTiedToMarkup
(
)
"
Should
only
be
called
for
CSS
animations
that
are
sorted
"
"
as
CSS
animations
(
i
.
e
.
tied
to
CSS
markup
)
"
)
;
if
(
&
aOther
=
=
this
)
{
return
false
;
}
if
(
!
mOwningElement
.
Equals
(
aOther
.
mOwningElement
)
)
{
return
mOwningElement
.
LessThan
(
aOther
.
mOwningElement
)
;
}
return
mAnimationIndex
<
aOther
.
mAnimationIndex
;
}
void
CSSAnimation
:
:
QueueEvents
(
const
StickyTimeDuration
&
aActiveTime
)
{
if
(
mPendingState
!
=
PendingState
:
:
NotPending
)
{
return
;
}
if
(
!
mOwningElement
.
IsSet
(
)
)
{
return
;
}
nsPresContext
*
presContext
=
mOwningElement
.
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
static
constexpr
StickyTimeDuration
zeroDuration
=
StickyTimeDuration
(
)
;
uint64_t
currentIteration
=
0
;
ComputedTiming
:
:
AnimationPhase
currentPhase
;
StickyTimeDuration
intervalStartTime
;
StickyTimeDuration
intervalEndTime
;
StickyTimeDuration
iterationStartTime
;
if
(
!
mEffect
)
{
currentPhase
=
GetAnimationPhaseWithoutEffect
<
ComputedTiming
:
:
AnimationPhase
>
(
*
this
)
;
}
else
{
ComputedTiming
computedTiming
=
mEffect
-
>
GetComputedTiming
(
)
;
currentPhase
=
computedTiming
.
mPhase
;
currentIteration
=
computedTiming
.
mCurrentIteration
;
if
(
currentPhase
=
=
mPreviousPhase
&
&
currentIteration
=
=
mPreviousIteration
)
{
return
;
}
intervalStartTime
=
std
:
:
max
(
std
:
:
min
(
StickyTimeDuration
(
-
mEffect
-
>
SpecifiedTiming
(
)
.
Delay
(
)
)
computedTiming
.
mActiveDuration
)
zeroDuration
)
;
intervalEndTime
=
std
:
:
max
(
std
:
:
min
(
(
EffectEnd
(
)
-
mEffect
-
>
SpecifiedTiming
(
)
.
Delay
(
)
)
computedTiming
.
mActiveDuration
)
zeroDuration
)
;
uint64_t
iterationBoundary
=
mPreviousIteration
>
currentIteration
?
currentIteration
+
1
:
currentIteration
;
iterationStartTime
=
computedTiming
.
mDuration
.
MultDouble
(
(
iterationBoundary
-
computedTiming
.
mIterationStart
)
)
;
}
TimeStamp
startTimeStamp
=
ElapsedTimeToTimeStamp
(
intervalStartTime
)
;
TimeStamp
endTimeStamp
=
ElapsedTimeToTimeStamp
(
intervalEndTime
)
;
TimeStamp
iterationTimeStamp
=
ElapsedTimeToTimeStamp
(
iterationStartTime
)
;
AutoTArray
<
AnimationEventInfo
2
>
events
;
auto
appendAnimationEvent
=
[
&
]
(
EventMessage
aMessage
const
StickyTimeDuration
&
aElapsedTime
const
TimeStamp
&
aTimeStamp
)
{
double
elapsedTime
=
aElapsedTime
.
ToSeconds
(
)
;
if
(
aMessage
=
=
eAnimationCancel
)
{
elapsedTime
=
nsRFPService
:
:
ReduceTimePrecisionAsSecs
(
elapsedTime
0
TimerPrecisionType
:
:
RFPOnly
)
;
}
events
.
AppendElement
(
AnimationEventInfo
(
mAnimationName
mOwningElement
.
Target
(
)
aMessage
elapsedTime
aTimeStamp
this
)
)
;
}
;
if
(
(
mPreviousPhase
!
=
AnimationPhase
:
:
Idle
&
&
mPreviousPhase
!
=
AnimationPhase
:
:
After
)
&
&
currentPhase
=
=
AnimationPhase
:
:
Idle
)
{
TimeStamp
activeTimeStamp
=
ElapsedTimeToTimeStamp
(
aActiveTime
)
;
appendAnimationEvent
(
eAnimationCancel
aActiveTime
activeTimeStamp
)
;
}
switch
(
mPreviousPhase
)
{
case
AnimationPhase
:
:
Idle
:
case
AnimationPhase
:
:
Before
:
if
(
currentPhase
=
=
AnimationPhase
:
:
Active
)
{
appendAnimationEvent
(
eAnimationStart
intervalStartTime
startTimeStamp
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
After
)
{
appendAnimationEvent
(
eAnimationStart
intervalStartTime
startTimeStamp
)
;
appendAnimationEvent
(
eAnimationEnd
intervalEndTime
endTimeStamp
)
;
}
break
;
case
AnimationPhase
:
:
Active
:
if
(
currentPhase
=
=
AnimationPhase
:
:
Before
)
{
appendAnimationEvent
(
eAnimationEnd
intervalStartTime
startTimeStamp
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
Active
)
{
MOZ_ASSERT
(
currentIteration
!
=
mPreviousIteration
)
;
appendAnimationEvent
(
eAnimationIteration
iterationStartTime
iterationTimeStamp
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
After
)
{
appendAnimationEvent
(
eAnimationEnd
intervalEndTime
endTimeStamp
)
;
}
break
;
case
AnimationPhase
:
:
After
:
if
(
currentPhase
=
=
AnimationPhase
:
:
Before
)
{
appendAnimationEvent
(
eAnimationStart
intervalEndTime
startTimeStamp
)
;
appendAnimationEvent
(
eAnimationEnd
intervalStartTime
endTimeStamp
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
Active
)
{
appendAnimationEvent
(
eAnimationStart
intervalEndTime
endTimeStamp
)
;
}
break
;
}
mPreviousPhase
=
currentPhase
;
mPreviousIteration
=
currentIteration
;
if
(
!
events
.
IsEmpty
(
)
)
{
presContext
-
>
AnimationEventDispatcher
(
)
-
>
QueueEvents
(
Move
(
events
)
)
;
}
}
void
CSSAnimation
:
:
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
if
(
mNeedsNewAnimationIndexWhenRun
&
&
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
false
;
}
Animation
:
:
UpdateTiming
(
aSeekFlag
aSyncNotifyFlag
)
;
}
static
already_AddRefed
<
CSSAnimation
>
PopExistingAnimation
(
const
nsAtom
*
aName
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
if
(
!
aCollection
)
{
return
nullptr
;
}
for
(
size_t
idx
=
0
length
=
aCollection
-
>
mAnimations
.
Length
(
)
;
idx
!
=
length
;
+
+
idx
)
{
CSSAnimation
*
cssAnim
=
aCollection
-
>
mAnimations
[
idx
]
;
if
(
cssAnim
-
>
AnimationName
(
)
=
=
aName
)
{
RefPtr
<
CSSAnimation
>
match
=
cssAnim
;
aCollection
-
>
mAnimations
.
RemoveElementAt
(
idx
)
;
return
match
.
forget
(
)
;
}
}
return
nullptr
;
}
class
MOZ_STACK_CLASS
ServoCSSAnimationBuilder
final
{
public
:
explicit
ServoCSSAnimationBuilder
(
const
ComputedStyle
*
aComputedStyle
)
:
mComputedStyle
(
aComputedStyle
)
{
MOZ_ASSERT
(
aComputedStyle
)
;
}
bool
BuildKeyframes
(
nsPresContext
*
aPresContext
nsAtom
*
aName
const
nsTimingFunction
&
aTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
ServoStyleSet
*
styleSet
=
aPresContext
-
>
StyleSet
(
)
;
MOZ_ASSERT
(
styleSet
)
;
return
styleSet
-
>
GetKeyframesForName
(
aName
aTimingFunction
aKeyframes
)
;
}
void
SetKeyframes
(
KeyframeEffectReadOnly
&
aEffect
nsTArray
<
Keyframe
>
&
&
aKeyframes
)
{
aEffect
.
SetKeyframes
(
Move
(
aKeyframes
)
mComputedStyle
)
;
}
void
NotifyNewOrRemovedAnimation
(
const
Animation
&
aAnimation
)
{
dom
:
:
AnimationEffectReadOnly
*
effect
=
aAnimation
.
GetEffect
(
)
;
if
(
!
effect
)
{
return
;
}
KeyframeEffectReadOnly
*
keyframeEffect
=
effect
-
>
AsKeyframeEffect
(
)
;
if
(
!
keyframeEffect
)
{
return
;
}
keyframeEffect
-
>
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Standard
)
;
}
private
:
const
ComputedStyle
*
mComputedStyle
;
}
;
template
<
class
BuilderType
>
static
void
UpdateOldAnimationPropertiesWithNew
(
CSSAnimation
&
aOld
TimingParams
&
aNewTiming
nsTArray
<
Keyframe
>
&
&
aNewKeyframes
bool
aNewIsStylePaused
BuilderType
&
aBuilder
)
{
bool
animationChanged
=
false
;
if
(
aOld
.
GetEffect
(
)
)
{
dom
:
:
AnimationEffectReadOnly
*
oldEffect
=
aOld
.
GetEffect
(
)
;
animationChanged
=
oldEffect
-
>
SpecifiedTiming
(
)
!
=
aNewTiming
;
oldEffect
-
>
SetSpecifiedTiming
(
aNewTiming
)
;
KeyframeEffectReadOnly
*
oldKeyframeEffect
=
oldEffect
-
>
AsKeyframeEffect
(
)
;
if
(
oldKeyframeEffect
)
{
aBuilder
.
SetKeyframes
(
*
oldKeyframeEffect
Move
(
aNewKeyframes
)
)
;
}
}
if
(
aOld
.
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
if
(
!
aOld
.
IsStylePaused
(
)
&
&
aNewIsStylePaused
)
{
aOld
.
PauseFromStyle
(
)
;
animationChanged
=
true
;
}
else
if
(
aOld
.
IsStylePaused
(
)
&
&
!
aNewIsStylePaused
)
{
aOld
.
PlayFromStyle
(
)
;
animationChanged
=
true
;
}
}
if
(
animationChanged
&
&
aOld
.
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
&
aOld
)
;
}
}
template
<
class
BuilderType
>
static
already_AddRefed
<
CSSAnimation
>
BuildAnimation
(
nsPresContext
*
aPresContext
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleDisplay
&
aStyleDisplay
uint32_t
animIdx
BuilderType
&
aBuilder
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
MOZ_ASSERT
(
aPresContext
)
;
nsAtom
*
animationName
=
aStyleDisplay
.
GetAnimationName
(
animIdx
)
;
nsTArray
<
Keyframe
>
keyframes
;
if
(
!
aBuilder
.
BuildKeyframes
(
aPresContext
animationName
aStyleDisplay
.
GetAnimationTimingFunction
(
animIdx
)
keyframes
)
)
{
return
nullptr
;
}
TimingParams
timing
=
TimingParamsFromCSSParams
(
aStyleDisplay
.
GetAnimationDuration
(
animIdx
)
aStyleDisplay
.
GetAnimationDelay
(
animIdx
)
aStyleDisplay
.
GetAnimationIterationCount
(
animIdx
)
aStyleDisplay
.
GetAnimationDirection
(
animIdx
)
aStyleDisplay
.
GetAnimationFillMode
(
animIdx
)
)
;
bool
isStylePaused
=
aStyleDisplay
.
GetAnimationPlayState
(
animIdx
)
=
=
NS_STYLE_ANIMATION_PLAY_STATE_PAUSED
;
RefPtr
<
CSSAnimation
>
oldAnim
=
PopExistingAnimation
(
animationName
aCollection
)
;
if
(
oldAnim
)
{
UpdateOldAnimationPropertiesWithNew
(
*
oldAnim
timing
Move
(
keyframes
)
isStylePaused
aBuilder
)
;
return
oldAnim
.
forget
(
)
;
}
Maybe
<
OwningAnimationTarget
>
target
;
target
.
emplace
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
;
KeyframeEffectParams
effectOptions
;
RefPtr
<
KeyframeEffectReadOnly
>
effect
=
new
KeyframeEffectReadOnly
(
aPresContext
-
>
Document
(
)
target
timing
effectOptions
)
;
aBuilder
.
SetKeyframes
(
*
effect
Move
(
keyframes
)
)
;
RefPtr
<
CSSAnimation
>
animation
=
new
CSSAnimation
(
aPresContext
-
>
Document
(
)
-
>
GetScopeObject
(
)
animationName
)
;
animation
-
>
SetOwningElement
(
OwningElementRef
(
*
aTarget
.
mElement
aTarget
.
mPseudoType
)
)
;
animation
-
>
SetTimelineNoUpdate
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
)
;
animation
-
>
SetEffectNoUpdate
(
effect
)
;
if
(
isStylePaused
)
{
animation
-
>
PauseFromStyle
(
)
;
}
else
{
animation
-
>
PlayFromStyle
(
)
;
}
aBuilder
.
NotifyNewOrRemovedAnimation
(
*
animation
)
;
return
animation
.
forget
(
)
;
}
template
<
class
BuilderType
>
static
nsAnimationManager
:
:
OwningCSSAnimationPtrArray
BuildAnimations
(
nsPresContext
*
aPresContext
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleDisplay
&
aStyleDisplay
BuilderType
&
aBuilder
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
nsTHashtable
<
nsRefPtrHashKey
<
nsAtom
>
>
&
aReferencedAnimations
)
{
nsAnimationManager
:
:
OwningCSSAnimationPtrArray
result
;
for
(
size_t
animIdx
=
aStyleDisplay
.
mAnimationNameCount
;
animIdx
-
-
!
=
0
;
)
{
nsAtom
*
name
=
aStyleDisplay
.
GetAnimationName
(
animIdx
)
;
if
(
name
=
=
nsGkAtoms
:
:
_empty
)
{
continue
;
}
aReferencedAnimations
.
PutEntry
(
name
)
;
RefPtr
<
CSSAnimation
>
dest
=
BuildAnimation
(
aPresContext
aTarget
aStyleDisplay
animIdx
aBuilder
aCollection
)
;
if
(
!
dest
)
{
continue
;
}
dest
-
>
SetAnimationIndex
(
static_cast
<
uint64_t
>
(
animIdx
)
)
;
result
.
AppendElement
(
dest
)
;
}
return
result
;
}
void
nsAnimationManager
:
:
UpdateAnimations
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
const
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
mPresContext
-
>
IsDynamic
(
)
"
Should
not
update
animations
for
print
or
print
preview
"
)
;
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
"
Should
not
update
animations
that
are
not
attached
to
the
"
"
document
tree
"
)
;
const
nsStyleDisplay
*
disp
=
aComputedStyle
?
aComputedStyle
-
>
ComputedData
(
)
-
>
GetStyleDisplay
(
)
:
nullptr
;
if
(
!
disp
|
|
disp
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
{
StopAnimationsForElement
(
aElement
aPseudoType
)
;
return
;
}
NonOwningAnimationTarget
target
(
aElement
aPseudoType
)
;
ServoCSSAnimationBuilder
builder
(
aComputedStyle
)
;
DoUpdateAnimations
(
target
*
disp
builder
)
;
}
template
<
class
BuilderType
>
void
nsAnimationManager
:
:
DoUpdateAnimations
(
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleDisplay
&
aStyleDisplay
BuilderType
&
aBuilder
)
{
CSSAnimationCollection
*
collection
=
CSSAnimationCollection
:
:
GetAnimationCollection
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
;
if
(
!
collection
&
&
aStyleDisplay
.
mAnimationNameCount
=
=
1
&
&
aStyleDisplay
.
mAnimations
[
0
]
.
GetName
(
)
=
=
nsGkAtoms
:
:
_empty
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
)
;
OwningCSSAnimationPtrArray
newAnimations
;
newAnimations
=
BuildAnimations
(
mPresContext
aTarget
aStyleDisplay
aBuilder
collection
mMaybeReferencedAnimations
)
;
if
(
newAnimations
.
IsEmpty
(
)
)
{
if
(
collection
)
{
collection
-
>
Destroy
(
)
;
}
return
;
}
if
(
!
collection
)
{
bool
createdCollection
=
false
;
collection
=
CSSAnimationCollection
:
:
GetOrCreateAnimationCollection
(
aTarget
.
mElement
aTarget
.
mPseudoType
&
createdCollection
)
;
if
(
!
collection
)
{
MOZ_ASSERT
(
!
createdCollection
"
outparam
should
agree
with
return
value
"
)
;
NS_WARNING
(
"
allocating
collection
failed
"
)
;
return
;
}
if
(
createdCollection
)
{
AddElementCollection
(
collection
)
;
}
}
collection
-
>
mAnimations
.
SwapElements
(
newAnimations
)
;
for
(
size_t
newAnimIdx
=
newAnimations
.
Length
(
)
;
newAnimIdx
-
-
!
=
0
;
)
{
aBuilder
.
NotifyNewOrRemovedAnimation
(
*
newAnimations
[
newAnimIdx
]
)
;
newAnimations
[
newAnimIdx
]
-
>
CancelFromStyle
(
)
;
}
}
