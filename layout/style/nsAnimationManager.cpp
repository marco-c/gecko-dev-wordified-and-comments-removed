#
include
"
nsAnimationManager
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
mozilla
/
dom
/
CSSAnimationBinding
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsCSSRules
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
<
math
.
h
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
mozilla
:
:
dom
:
:
Animation
;
using
mozilla
:
:
dom
:
:
AnimationPlayState
;
using
mozilla
:
:
dom
:
:
KeyframeEffectReadOnly
;
using
mozilla
:
:
dom
:
:
CSSAnimation
;
JSObject
*
CSSAnimation
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
CSSAnimationBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
mozilla
:
:
dom
:
:
Promise
*
CSSAnimation
:
:
GetReady
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
return
Animation
:
:
GetReady
(
aRv
)
;
}
void
CSSAnimation
:
:
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
{
mPauseShouldStick
=
false
;
Animation
:
:
Play
(
aRv
aLimitBehavior
)
;
}
void
CSSAnimation
:
:
Pause
(
ErrorResult
&
aRv
)
{
mPauseShouldStick
=
true
;
Animation
:
:
Pause
(
aRv
)
;
}
AnimationPlayState
CSSAnimation
:
:
PlayStateFromJS
(
)
const
{
FlushStyle
(
)
;
return
Animation
:
:
PlayStateFromJS
(
)
;
}
void
CSSAnimation
:
:
PlayFromJS
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
Animation
:
:
PlayFromJS
(
aRv
)
;
}
void
CSSAnimation
:
:
PlayFromStyle
(
)
{
mIsStylePaused
=
false
;
if
(
!
mPauseShouldStick
)
{
ErrorResult
rv
;
DoPlay
(
rv
Animation
:
:
LimitBehavior
:
:
Continue
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Unexpected
exception
playing
animation
"
)
;
}
}
void
CSSAnimation
:
:
PauseFromStyle
(
)
{
if
(
mIsStylePaused
)
{
return
;
}
mIsStylePaused
=
true
;
ErrorResult
rv
;
DoPause
(
rv
)
;
if
(
rv
.
Failed
(
)
)
{
NS_WARNING
(
"
Unexpected
exception
pausing
animation
-
silently
failing
"
)
;
}
}
void
CSSAnimation
:
:
Tick
(
)
{
Animation
:
:
Tick
(
)
;
QueueEvents
(
)
;
}
bool
CSSAnimation
:
:
HasLowerCompositeOrderThan
(
const
CSSAnimation
&
aOther
)
const
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
&
&
aOther
.
IsTiedToMarkup
(
)
"
Should
only
be
called
for
CSS
animations
that
are
sorted
"
"
as
CSS
animations
(
i
.
e
.
tied
to
CSS
markup
)
"
)
;
if
(
&
aOther
=
=
this
)
{
return
false
;
}
if
(
!
mOwningElement
.
Equals
(
aOther
.
mOwningElement
)
)
{
return
mOwningElement
.
LessThan
(
aOther
.
mOwningElement
)
;
}
return
mAnimationIndex
<
aOther
.
mAnimationIndex
;
}
void
CSSAnimation
:
:
QueueEvents
(
)
{
if
(
!
mEffect
)
{
return
;
}
if
(
!
mOwningElement
.
IsSet
(
)
)
{
return
;
}
dom
:
:
Element
*
owningElement
;
CSSPseudoElementType
owningPseudoType
;
mOwningElement
.
GetElement
(
owningElement
owningPseudoType
)
;
MOZ_ASSERT
(
owningElement
"
Owning
element
should
be
set
"
)
;
nsPresContext
*
presContext
=
mOwningElement
.
GetRenderedPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
nsAnimationManager
*
manager
=
presContext
-
>
AnimationManager
(
)
;
ComputedTiming
computedTiming
=
mEffect
-
>
GetComputedTiming
(
)
;
if
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Null
)
{
return
;
}
bool
wasActive
=
mPreviousPhaseOrIteration
!
=
PREVIOUS_PHASE_BEFORE
&
&
mPreviousPhaseOrIteration
!
=
PREVIOUS_PHASE_AFTER
;
bool
isActive
=
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
;
bool
isSameIteration
=
computedTiming
.
mCurrentIteration
=
=
mPreviousPhaseOrIteration
;
bool
skippedActivePhase
=
(
mPreviousPhaseOrIteration
=
=
PREVIOUS_PHASE_BEFORE
&
&
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
)
|
|
(
mPreviousPhaseOrIteration
=
=
PREVIOUS_PHASE_AFTER
&
&
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
)
;
MOZ_ASSERT
(
!
skippedActivePhase
|
|
(
!
isActive
&
&
!
wasActive
)
"
skippedActivePhase
only
makes
sense
if
we
were
&
are
inactive
"
)
;
if
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
)
{
mPreviousPhaseOrIteration
=
PREVIOUS_PHASE_BEFORE
;
}
else
if
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
)
{
mPreviousPhaseOrIteration
=
computedTiming
.
mCurrentIteration
;
}
else
if
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
)
{
mPreviousPhaseOrIteration
=
PREVIOUS_PHASE_AFTER
;
}
EventMessage
message
;
if
(
!
wasActive
&
&
isActive
)
{
message
=
eAnimationStart
;
}
else
if
(
wasActive
&
&
!
isActive
)
{
message
=
eAnimationEnd
;
}
else
if
(
wasActive
&
&
isActive
&
&
!
isSameIteration
)
{
message
=
eAnimationIteration
;
}
else
if
(
skippedActivePhase
)
{
StickyTimeDuration
elapsedTime
=
std
:
:
min
(
StickyTimeDuration
(
InitialAdvance
(
)
)
computedTiming
.
mActiveDuration
)
;
manager
-
>
QueueEvent
(
AnimationEventInfo
(
owningElement
owningPseudoType
eAnimationStart
mAnimationName
elapsedTime
ElapsedTimeToTimeStamp
(
elapsedTime
)
this
)
)
;
message
=
eAnimationEnd
;
}
else
{
return
;
}
StickyTimeDuration
elapsedTime
;
if
(
message
=
=
eAnimationStart
|
|
message
=
=
eAnimationIteration
)
{
StickyTimeDuration
iterationStart
=
computedTiming
.
mDuration
*
computedTiming
.
mCurrentIteration
;
elapsedTime
=
std
:
:
max
(
iterationStart
StickyTimeDuration
(
InitialAdvance
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
message
=
=
eAnimationEnd
)
;
elapsedTime
=
computedTiming
.
mActiveDuration
;
}
manager
-
>
QueueEvent
(
AnimationEventInfo
(
owningElement
owningPseudoType
message
mAnimationName
elapsedTime
ElapsedTimeToTimeStamp
(
elapsedTime
)
this
)
)
;
}
void
CSSAnimation
:
:
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
if
(
mNeedsNewAnimationIndexWhenRun
&
&
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
false
;
}
Animation
:
:
UpdateTiming
(
aSeekFlag
aSyncNotifyFlag
)
;
}
TimeStamp
CSSAnimation
:
:
ElapsedTimeToTimeStamp
(
const
StickyTimeDuration
&
aElapsedTime
)
const
{
TimeStamp
result
;
if
(
!
mEffect
|
|
mStartTime
.
IsNull
(
)
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
result
=
presContext
-
>
RefreshDriver
(
)
-
>
MostRecentRefresh
(
)
;
}
return
result
;
}
result
=
AnimationTimeToTimeStamp
(
aElapsedTime
+
mEffect
-
>
SpecifiedTiming
(
)
.
mDelay
)
;
return
result
;
}
NS_IMPL_CYCLE_COLLECTION
(
nsAnimationManager
mEventDispatcher
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
nsAnimationManager
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
nsAnimationManager
Release
)
static
already_AddRefed
<
CSSAnimation
>
PopExistingAnimation
(
const
nsAString
&
aName
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
if
(
!
aCollection
)
{
return
nullptr
;
}
for
(
size_t
idx
=
0
length
=
aCollection
-
>
mAnimations
.
Length
(
)
;
idx
!
=
length
;
+
+
idx
)
{
CSSAnimation
*
cssAnim
=
aCollection
-
>
mAnimations
[
idx
]
;
if
(
cssAnim
-
>
AnimationName
(
)
=
=
aName
)
{
RefPtr
<
CSSAnimation
>
match
=
cssAnim
;
aCollection
-
>
mAnimations
.
RemoveElementAt
(
idx
)
;
return
match
.
forget
(
)
;
}
}
return
nullptr
;
}
static
void
UpdateOldAnimationPropertiesWithNew
(
CSSAnimation
&
aOld
TimingParams
&
aNewTiming
InfallibleTArray
<
AnimationProperty
>
&
aNewProperties
bool
aNewIsStylePaused
)
{
bool
animationChanged
=
false
;
if
(
aOld
.
GetEffect
(
)
)
{
KeyframeEffectReadOnly
*
oldEffect
=
aOld
.
GetEffect
(
)
;
animationChanged
=
oldEffect
-
>
SpecifiedTiming
(
)
!
=
aNewTiming
;
oldEffect
-
>
SetSpecifiedTiming
(
aNewTiming
)
;
animationChanged
|
=
oldEffect
-
>
UpdateProperties
(
aNewProperties
)
;
}
if
(
aOld
.
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
if
(
!
aOld
.
IsStylePaused
(
)
&
&
aNewIsStylePaused
)
{
aOld
.
PauseFromStyle
(
)
;
animationChanged
=
true
;
}
else
if
(
aOld
.
IsStylePaused
(
)
&
&
!
aNewIsStylePaused
)
{
aOld
.
PlayFromStyle
(
)
;
animationChanged
=
true
;
}
}
if
(
animationChanged
&
&
aOld
.
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
&
aOld
)
;
}
}
void
nsAnimationManager
:
:
UpdateAnimations
(
nsStyleContext
*
aStyleContext
mozilla
:
:
dom
:
:
Element
*
aElement
)
{
MOZ_ASSERT
(
mPresContext
-
>
IsDynamic
(
)
"
Should
not
update
animations
for
print
or
print
preview
"
)
;
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
"
Should
not
update
animations
that
are
not
attached
to
the
"
"
document
tree
"
)
;
const
nsStyleDisplay
*
disp
=
aStyleContext
-
>
StyleDisplay
(
)
;
CSSAnimationCollection
*
collection
=
CSSAnimationCollection
:
:
GetAnimationCollection
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
false
)
;
if
(
!
collection
&
&
disp
-
>
mAnimationNameCount
=
=
1
&
&
disp
-
>
mAnimations
[
0
]
.
GetName
(
)
.
IsEmpty
(
)
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aElement
-
>
OwnerDoc
(
)
)
;
OwningCSSAnimationPtrArray
newAnimations
;
if
(
!
aStyleContext
-
>
IsInDisplayNoneSubtree
(
)
)
{
BuildAnimations
(
aStyleContext
aElement
collection
newAnimations
)
;
}
if
(
newAnimations
.
IsEmpty
(
)
)
{
if
(
collection
)
{
collection
-
>
Destroy
(
)
;
}
return
;
}
if
(
collection
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
)
;
if
(
effectSet
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
}
else
{
bool
createdCollection
=
false
;
collection
=
CSSAnimationCollection
:
:
GetAnimationCollection
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
true
&
createdCollection
)
;
if
(
!
collection
)
{
MOZ_ASSERT
(
!
createdCollection
"
outparam
should
agree
with
return
value
"
)
;
NS_WARNING
(
"
allocating
collection
failed
"
)
;
return
;
}
if
(
createdCollection
)
{
AddElementCollection
(
collection
)
;
}
}
collection
-
>
mAnimations
.
SwapElements
(
newAnimations
)
;
for
(
size_t
newAnimIdx
=
newAnimations
.
Length
(
)
;
newAnimIdx
-
-
!
=
0
;
)
{
newAnimations
[
newAnimIdx
]
-
>
CancelFromStyle
(
)
;
}
EffectCompositor
:
:
UpdateCascadeResults
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
aStyleContext
)
;
mPresContext
-
>
EffectCompositor
(
)
-
>
MaybeUpdateAnimationRule
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
EffectCompositor
:
:
CascadeLevel
:
:
Animations
)
;
if
(
mEventDispatcher
.
HasQueuedEvents
(
)
)
{
mPresContext
-
>
Document
(
)
-
>
SetNeedStyleFlush
(
)
;
}
}
void
nsAnimationManager
:
:
StopAnimationsForElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
CSSPseudoElementType
aPseudoType
)
{
MOZ_ASSERT
(
aElement
)
;
CSSAnimationCollection
*
collection
=
CSSAnimationCollection
:
:
GetAnimationCollection
(
aElement
aPseudoType
false
)
;
if
(
!
collection
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aElement
-
>
OwnerDoc
(
)
)
;
collection
-
>
Destroy
(
)
;
}
struct
KeyframeData
{
float
mKey
;
uint32_t
mIndex
;
nsCSSKeyframeRule
*
mRule
;
}
;
struct
KeyframeDataComparator
{
bool
Equals
(
const
KeyframeData
&
A
const
KeyframeData
&
B
)
const
{
return
A
.
mKey
=
=
B
.
mKey
&
&
A
.
mIndex
=
=
B
.
mIndex
;
}
bool
LessThan
(
const
KeyframeData
&
A
const
KeyframeData
&
B
)
const
{
return
A
.
mKey
<
B
.
mKey
|
|
(
A
.
mKey
=
=
B
.
mKey
&
&
A
.
mIndex
<
B
.
mIndex
)
;
}
}
;
class
ResolvedStyleCache
{
public
:
ResolvedStyleCache
(
)
:
mCache
(
)
{
}
nsStyleContext
*
Get
(
nsPresContext
*
aPresContext
nsStyleContext
*
aParentStyleContext
Declaration
*
aKeyframeDeclaration
)
;
private
:
nsRefPtrHashtable
<
nsPtrHashKey
<
Declaration
>
nsStyleContext
>
mCache
;
}
;
nsStyleContext
*
ResolvedStyleCache
:
:
Get
(
nsPresContext
*
aPresContext
nsStyleContext
*
aParentStyleContext
Declaration
*
aKeyframeDeclaration
)
{
nsStyleContext
*
result
=
mCache
.
GetWeak
(
aKeyframeDeclaration
)
;
if
(
!
result
)
{
aKeyframeDeclaration
-
>
SetImmutable
(
)
;
MOZ_ASSERT
(
!
aKeyframeDeclaration
-
>
HasImportantData
(
)
"
Keyframe
rule
has
!
important
data
"
)
;
nsCOMArray
<
nsIStyleRule
>
rules
;
rules
.
AppendObject
(
aKeyframeDeclaration
)
;
MOZ_ASSERT
(
aPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
RefPtr
<
nsStyleContext
>
resultStrong
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleByAddingRules
(
aParentStyleContext
rules
)
;
mCache
.
Put
(
aKeyframeDeclaration
resultStrong
)
;
result
=
resultStrong
;
}
return
result
;
}
class
MOZ_STACK_CLASS
CSSAnimationBuilder
final
{
public
:
CSSAnimationBuilder
(
nsStyleContext
*
aStyleContext
dom
:
:
Element
*
aTarget
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
:
mStyleContext
(
aStyleContext
)
mTarget
(
aTarget
)
mCollection
(
aCollection
)
{
MOZ_ASSERT
(
aStyleContext
)
;
MOZ_ASSERT
(
aTarget
)
;
mTimeline
=
mTarget
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
;
}
already_AddRefed
<
CSSAnimation
>
Build
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
)
;
private
:
void
BuildAnimationProperties
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
InfallibleTArray
<
AnimationProperty
>
&
aResult
)
;
bool
BuildSegment
(
InfallibleTArray
<
mozilla
:
:
AnimationPropertySegment
>
&
aSegments
nsCSSProperty
aProperty
const
mozilla
:
:
StyleAnimation
&
aAnimation
float
aFromKey
nsStyleContext
*
aFromContext
mozilla
:
:
css
:
:
Declaration
*
aFromDeclaration
float
aToKey
nsStyleContext
*
aToContext
)
;
static
TimingParams
TimingParamsFrom
(
const
StyleAnimation
&
aStyleAnimation
)
{
TimingParams
timing
;
timing
.
mDuration
.
SetAsUnrestrictedDouble
(
)
=
aStyleAnimation
.
GetDuration
(
)
;
timing
.
mDelay
=
TimeDuration
:
:
FromMilliseconds
(
aStyleAnimation
.
GetDelay
(
)
)
;
timing
.
mIterations
=
aStyleAnimation
.
GetIterationCount
(
)
;
timing
.
mDirection
=
aStyleAnimation
.
GetDirection
(
)
;
timing
.
mFill
=
aStyleAnimation
.
GetFillMode
(
)
;
return
timing
;
}
RefPtr
<
nsStyleContext
>
mStyleContext
;
RefPtr
<
dom
:
:
Element
>
mTarget
;
RefPtr
<
dom
:
:
DocumentTimeline
>
mTimeline
;
ResolvedStyleCache
mResolvedStyles
;
RefPtr
<
nsStyleContext
>
mStyleWithoutAnimation
;
nsAnimationManager
:
:
CSSAnimationCollection
*
mCollection
;
}
;
already_AddRefed
<
CSSAnimation
>
CSSAnimationBuilder
:
:
Build
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
)
{
MOZ_ASSERT
(
aPresContext
)
;
MOZ_ASSERT
(
aRule
)
;
TimingParams
timing
=
TimingParamsFrom
(
aSrc
)
;
InfallibleTArray
<
AnimationProperty
>
animationProperties
;
BuildAnimationProperties
(
aPresContext
aSrc
aRule
animationProperties
)
;
bool
isStylePaused
=
aSrc
.
GetPlayState
(
)
=
=
NS_STYLE_ANIMATION_PLAY_STATE_PAUSED
;
RefPtr
<
CSSAnimation
>
oldAnim
=
PopExistingAnimation
(
aSrc
.
GetName
(
)
mCollection
)
;
if
(
oldAnim
)
{
UpdateOldAnimationPropertiesWithNew
(
*
oldAnim
timing
animationProperties
isStylePaused
)
;
return
oldAnim
.
forget
(
)
;
}
RefPtr
<
KeyframeEffectReadOnly
>
effect
=
new
KeyframeEffectReadOnly
(
aPresContext
-
>
Document
(
)
mTarget
mStyleContext
-
>
GetPseudoType
(
)
timing
)
;
effect
-
>
Properties
(
)
=
Move
(
animationProperties
)
;
RefPtr
<
CSSAnimation
>
animation
=
new
CSSAnimation
(
aPresContext
-
>
Document
(
)
-
>
GetScopeObject
(
)
aSrc
.
GetName
(
)
)
;
animation
-
>
SetOwningElement
(
OwningElementRef
(
*
mTarget
mStyleContext
-
>
GetPseudoType
(
)
)
)
;
animation
-
>
SetTimeline
(
mTimeline
)
;
animation
-
>
SetEffect
(
effect
)
;
if
(
isStylePaused
)
{
animation
-
>
PauseFromStyle
(
)
;
}
else
{
animation
-
>
PlayFromStyle
(
)
;
}
animation
-
>
QueueEvents
(
)
;
return
animation
.
forget
(
)
;
}
void
CSSAnimationBuilder
:
:
BuildAnimationProperties
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
InfallibleTArray
<
AnimationProperty
>
&
aResult
)
{
AutoTArray
<
KeyframeData
16
>
sortedKeyframes
;
for
(
uint32_t
ruleIdx
=
0
ruleEnd
=
aRule
-
>
StyleRuleCount
(
)
;
ruleIdx
!
=
ruleEnd
;
+
+
ruleIdx
)
{
css
:
:
Rule
*
cssRule
=
aRule
-
>
GetStyleRuleAt
(
ruleIdx
)
;
MOZ_ASSERT
(
cssRule
"
must
have
rule
"
)
;
MOZ_ASSERT
(
cssRule
-
>
GetType
(
)
=
=
css
:
:
Rule
:
:
KEYFRAME_RULE
"
must
be
keyframe
rule
"
)
;
nsCSSKeyframeRule
*
kfRule
=
static_cast
<
nsCSSKeyframeRule
*
>
(
cssRule
)
;
const
nsTArray
<
float
>
&
keys
=
kfRule
-
>
GetKeys
(
)
;
for
(
uint32_t
keyIdx
=
0
keyEnd
=
keys
.
Length
(
)
;
keyIdx
!
=
keyEnd
;
+
+
keyIdx
)
{
float
key
=
keys
[
keyIdx
]
;
if
(
0
.
0f
<
=
key
&
&
key
<
=
1
.
0f
)
{
KeyframeData
*
data
=
sortedKeyframes
.
AppendElement
(
)
;
data
-
>
mKey
=
key
;
data
-
>
mIndex
=
ruleIdx
;
data
-
>
mRule
=
kfRule
;
}
}
}
sortedKeyframes
.
Sort
(
KeyframeDataComparator
(
)
)
;
if
(
sortedKeyframes
.
Length
(
)
=
=
0
)
{
return
;
}
nsCSSPropertySet
properties
;
for
(
uint32_t
kfIdx
=
0
kfEnd
=
sortedKeyframes
.
Length
(
)
;
kfIdx
!
=
kfEnd
;
+
+
kfIdx
)
{
css
:
:
Declaration
*
decl
=
sortedKeyframes
[
kfIdx
]
.
mRule
-
>
Declaration
(
)
;
for
(
uint32_t
propIdx
=
0
propEnd
=
decl
-
>
Count
(
)
;
propIdx
!
=
propEnd
;
+
+
propIdx
)
{
nsCSSProperty
prop
=
decl
-
>
GetPropertyAt
(
propIdx
)
;
if
(
prop
!
=
eCSSPropertyExtra_variable
)
{
properties
.
AddProperty
(
prop
)
;
}
}
}
for
(
nsCSSProperty
prop
=
nsCSSProperty
(
0
)
;
prop
<
eCSSProperty_COUNT_no_shorthands
;
prop
=
nsCSSProperty
(
prop
+
1
)
)
{
if
(
!
properties
.
HasProperty
(
prop
)
|
|
nsCSSProps
:
:
kAnimTypeTable
[
prop
]
=
=
eStyleAnimType_None
)
{
continue
;
}
AutoTArray
<
uint32_t
16
>
keyframesWithProperty
;
float
lastKey
=
100
.
0f
;
for
(
uint32_t
kfIdx
=
0
kfEnd
=
sortedKeyframes
.
Length
(
)
;
kfIdx
!
=
kfEnd
;
+
+
kfIdx
)
{
KeyframeData
&
kf
=
sortedKeyframes
[
kfIdx
]
;
if
(
!
kf
.
mRule
-
>
Declaration
(
)
-
>
HasProperty
(
prop
)
)
{
continue
;
}
if
(
kf
.
mKey
=
=
lastKey
)
{
keyframesWithProperty
[
keyframesWithProperty
.
Length
(
)
-
1
]
=
kfIdx
;
}
else
{
keyframesWithProperty
.
AppendElement
(
kfIdx
)
;
}
lastKey
=
kf
.
mKey
;
}
AnimationProperty
&
propData
=
*
aResult
.
AppendElement
(
)
;
propData
.
mProperty
=
prop
;
KeyframeData
*
fromKeyframe
=
nullptr
;
RefPtr
<
nsStyleContext
>
fromContext
;
bool
interpolated
=
true
;
for
(
uint32_t
wpIdx
=
0
wpEnd
=
keyframesWithProperty
.
Length
(
)
;
wpIdx
!
=
wpEnd
;
+
+
wpIdx
)
{
uint32_t
kfIdx
=
keyframesWithProperty
[
wpIdx
]
;
KeyframeData
&
toKeyframe
=
sortedKeyframes
[
kfIdx
]
;
RefPtr
<
nsStyleContext
>
toContext
=
mResolvedStyles
.
Get
(
aPresContext
mStyleContext
toKeyframe
.
mRule
-
>
Declaration
(
)
)
;
if
(
fromKeyframe
)
{
interpolated
=
interpolated
&
&
BuildSegment
(
propData
.
mSegments
prop
aSrc
fromKeyframe
-
>
mKey
fromContext
fromKeyframe
-
>
mRule
-
>
Declaration
(
)
toKeyframe
.
mKey
toContext
)
;
}
else
{
if
(
toKeyframe
.
mKey
!
=
0
.
0f
)
{
if
(
!
mStyleWithoutAnimation
)
{
MOZ_ASSERT
(
aPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
mStyleWithoutAnimation
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleWithoutAnimation
(
mTarget
mStyleContext
eRestyle_AllHintsWithAnimations
)
;
}
interpolated
=
interpolated
&
&
BuildSegment
(
propData
.
mSegments
prop
aSrc
0
.
0f
mStyleWithoutAnimation
nullptr
toKeyframe
.
mKey
toContext
)
;
}
}
fromContext
=
toContext
;
fromKeyframe
=
&
toKeyframe
;
}
if
(
fromKeyframe
-
>
mKey
!
=
1
.
0f
)
{
if
(
!
mStyleWithoutAnimation
)
{
MOZ_ASSERT
(
aPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
mStyleWithoutAnimation
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleWithoutAnimation
(
mTarget
mStyleContext
eRestyle_AllHintsWithAnimations
)
;
}
interpolated
=
interpolated
&
&
BuildSegment
(
propData
.
mSegments
prop
aSrc
fromKeyframe
-
>
mKey
fromContext
fromKeyframe
-
>
mRule
-
>
Declaration
(
)
1
.
0f
mStyleWithoutAnimation
)
;
}
if
(
!
interpolated
)
{
aResult
.
RemoveElementAt
(
aResult
.
Length
(
)
-
1
)
;
}
}
}
bool
CSSAnimationBuilder
:
:
BuildSegment
(
InfallibleTArray
<
AnimationPropertySegment
>
&
aSegments
nsCSSProperty
aProperty
const
StyleAnimation
&
aAnimation
float
aFromKey
nsStyleContext
*
aFromContext
mozilla
:
:
css
:
:
Declaration
*
aFromDeclaration
float
aToKey
nsStyleContext
*
aToContext
)
{
StyleAnimationValue
fromValue
toValue
dummyValue
;
if
(
!
CommonAnimationManager
<
CSSAnimation
>
:
:
ExtractComputedValueForTransition
(
aProperty
aFromContext
fromValue
)
|
|
!
CommonAnimationManager
<
CSSAnimation
>
:
:
ExtractComputedValueForTransition
(
aProperty
aToContext
toValue
)
|
|
!
StyleAnimationValue
:
:
Interpolate
(
aProperty
fromValue
toValue
0
.
5
dummyValue
)
)
{
return
false
;
}
AnimationPropertySegment
&
segment
=
*
aSegments
.
AppendElement
(
)
;
segment
.
mFromValue
=
fromValue
;
segment
.
mToValue
=
toValue
;
segment
.
mFromKey
=
aFromKey
;
segment
.
mToKey
=
aToKey
;
const
nsTimingFunction
*
tf
;
if
(
aFromDeclaration
&
&
aFromDeclaration
-
>
HasProperty
(
eCSSProperty_animation_timing_function
)
)
{
tf
=
&
aFromContext
-
>
StyleDisplay
(
)
-
>
mAnimations
[
0
]
.
GetTimingFunction
(
)
;
}
else
{
tf
=
&
aAnimation
.
GetTimingFunction
(
)
;
}
if
(
tf
-
>
mType
!
=
nsTimingFunction
:
:
Type
:
:
Linear
)
{
ComputedTimingFunction
computedTimingFunction
;
computedTimingFunction
.
Init
(
*
tf
)
;
segment
.
mTimingFunction
=
Some
(
computedTimingFunction
)
;
}
return
true
;
}
void
nsAnimationManager
:
:
BuildAnimations
(
nsStyleContext
*
aStyleContext
dom
:
:
Element
*
aTarget
CSSAnimationCollection
*
aCollection
OwningCSSAnimationPtrArray
&
aAnimations
)
{
MOZ_ASSERT
(
aAnimations
.
IsEmpty
(
)
"
expect
empty
array
"
)
;
const
nsStyleDisplay
*
disp
=
aStyleContext
-
>
StyleDisplay
(
)
;
CSSAnimationBuilder
builder
(
aStyleContext
aTarget
aCollection
)
;
for
(
size_t
animIdx
=
disp
-
>
mAnimationNameCount
;
animIdx
-
-
!
=
0
;
)
{
const
StyleAnimation
&
src
=
disp
-
>
mAnimations
[
animIdx
]
;
MOZ_ASSERT
(
mPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
nsCSSKeyframesRule
*
rule
=
src
.
GetName
(
)
.
IsEmpty
(
)
?
nullptr
:
mPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
KeyframesRuleForName
(
src
.
GetName
(
)
)
;
if
(
!
rule
)
{
continue
;
}
RefPtr
<
CSSAnimation
>
dest
=
builder
.
Build
(
mPresContext
src
rule
)
;
dest
-
>
SetAnimationIndex
(
static_cast
<
uint64_t
>
(
animIdx
)
)
;
aAnimations
.
AppendElement
(
dest
)
;
}
}
