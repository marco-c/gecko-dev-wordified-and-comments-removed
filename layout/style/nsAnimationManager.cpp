#
include
"
nsAnimationManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
mozilla
/
AnimationEventDispatcher
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
ElementAnimationData
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
TimelineCollection
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffect
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
#
include
"
mozilla
/
dom
/
ScrollTimeline
.
h
"
#
include
"
mozilla
/
dom
/
ViewTimeline
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsRFPService
.
h
"
#
include
<
algorithm
>
#
include
<
math
.
h
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
mozilla
:
:
dom
:
:
Animation
;
using
mozilla
:
:
dom
:
:
AnimationPlayState
;
using
mozilla
:
:
dom
:
:
CSSAnimation
;
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
KeyframeEffect
;
using
mozilla
:
:
dom
:
:
MutationObservers
;
using
mozilla
:
:
dom
:
:
ScrollTimeline
;
using
mozilla
:
:
dom
:
:
ViewTimeline
;
static
already_AddRefed
<
CSSAnimation
>
PopExistingAnimation
(
const
nsAtom
*
aName
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
if
(
!
aCollection
)
{
return
nullptr
;
}
for
(
size_t
idx
=
0
length
=
aCollection
-
>
mAnimations
.
Length
(
)
;
idx
!
=
length
;
+
+
idx
)
{
CSSAnimation
*
cssAnim
=
aCollection
-
>
mAnimations
[
idx
]
;
if
(
cssAnim
-
>
AnimationName
(
)
=
=
aName
)
{
RefPtr
<
CSSAnimation
>
match
=
cssAnim
;
aCollection
-
>
mAnimations
.
RemoveElementAt
(
idx
)
;
return
match
.
forget
(
)
;
}
}
return
nullptr
;
}
class
MOZ_STACK_CLASS
ServoCSSAnimationBuilder
final
{
public
:
explicit
ServoCSSAnimationBuilder
(
const
ComputedStyle
*
aComputedStyle
)
:
mComputedStyle
(
aComputedStyle
)
{
MOZ_ASSERT
(
aComputedStyle
)
;
}
bool
BuildKeyframes
(
const
Element
&
aElement
nsPresContext
*
aPresContext
nsAtom
*
aName
const
StyleComputedTimingFunction
&
aTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
return
aPresContext
-
>
StyleSet
(
)
-
>
GetKeyframesForName
(
aElement
*
mComputedStyle
aName
aTimingFunction
aKeyframes
)
;
}
void
SetKeyframes
(
KeyframeEffect
&
aEffect
nsTArray
<
Keyframe
>
&
&
aKeyframes
const
dom
:
:
AnimationTimeline
*
aTimeline
)
{
aEffect
.
SetKeyframes
(
std
:
:
move
(
aKeyframes
)
mComputedStyle
aTimeline
)
;
}
void
NotifyNewOrRemovedAnimation
(
const
Animation
&
aAnimation
)
{
dom
:
:
AnimationEffect
*
effect
=
aAnimation
.
GetEffect
(
)
;
if
(
!
effect
)
{
return
;
}
KeyframeEffect
*
keyframeEffect
=
effect
-
>
AsKeyframeEffect
(
)
;
if
(
!
keyframeEffect
)
{
return
;
}
keyframeEffect
-
>
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Standard
)
;
}
private
:
const
ComputedStyle
*
mComputedStyle
;
}
;
static
void
UpdateOldAnimationPropertiesWithNew
(
CSSAnimation
&
aOld
TimingParams
&
&
aNewTiming
nsTArray
<
Keyframe
>
&
&
aNewKeyframes
bool
aNewIsStylePaused
CSSAnimationProperties
aOverriddenProperties
ServoCSSAnimationBuilder
&
aBuilder
dom
:
:
AnimationTimeline
*
aTimeline
dom
:
:
CompositeOperation
aNewComposite
)
{
bool
animationChanged
=
false
;
if
(
aOld
.
GetEffect
(
)
)
{
dom
:
:
AnimationEffect
*
oldEffect
=
aOld
.
GetEffect
(
)
;
TimingParams
updatedTiming
=
oldEffect
-
>
SpecifiedTiming
(
)
;
if
(
~
aOverriddenProperties
&
CSSAnimationProperties
:
:
Duration
)
{
updatedTiming
.
SetDuration
(
aNewTiming
.
Duration
(
)
)
;
}
if
(
~
aOverriddenProperties
&
CSSAnimationProperties
:
:
IterationCount
)
{
updatedTiming
.
SetIterations
(
aNewTiming
.
Iterations
(
)
)
;
}
if
(
~
aOverriddenProperties
&
CSSAnimationProperties
:
:
Direction
)
{
updatedTiming
.
SetDirection
(
aNewTiming
.
Direction
(
)
)
;
}
if
(
~
aOverriddenProperties
&
CSSAnimationProperties
:
:
Delay
)
{
updatedTiming
.
SetDelay
(
aNewTiming
.
Delay
(
)
)
;
}
if
(
~
aOverriddenProperties
&
CSSAnimationProperties
:
:
FillMode
)
{
updatedTiming
.
SetFill
(
aNewTiming
.
Fill
(
)
)
;
}
animationChanged
=
oldEffect
-
>
SpecifiedTiming
(
)
!
=
updatedTiming
;
oldEffect
-
>
SetSpecifiedTiming
(
std
:
:
move
(
updatedTiming
)
)
;
if
(
KeyframeEffect
*
oldKeyframeEffect
=
oldEffect
-
>
AsKeyframeEffect
(
)
)
{
if
(
~
aOverriddenProperties
&
CSSAnimationProperties
:
:
Keyframes
)
{
aBuilder
.
SetKeyframes
(
*
oldKeyframeEffect
std
:
:
move
(
aNewKeyframes
)
aTimeline
)
;
}
if
(
~
aOverriddenProperties
&
CSSAnimationProperties
:
:
Composition
)
{
animationChanged
=
oldKeyframeEffect
-
>
Composite
(
)
!
=
aNewComposite
;
oldKeyframeEffect
-
>
SetCompositeFromStyle
(
aNewComposite
)
;
}
}
}
if
(
aOld
.
GetTimeline
(
)
!
=
aTimeline
)
{
aOld
.
SetTimeline
(
aTimeline
)
;
animationChanged
=
true
;
}
if
(
aOld
.
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
&
&
~
aOverriddenProperties
&
CSSAnimationProperties
:
:
PlayState
)
{
bool
wasPaused
=
aOld
.
PlayState
(
)
=
=
AnimationPlayState
:
:
Paused
;
if
(
!
wasPaused
&
&
aNewIsStylePaused
)
{
aOld
.
PauseFromStyle
(
)
;
animationChanged
=
true
;
}
else
if
(
wasPaused
&
&
!
aNewIsStylePaused
)
{
aOld
.
PlayFromStyle
(
)
;
animationChanged
=
true
;
}
}
if
(
animationChanged
&
&
aOld
.
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
&
aOld
)
;
}
}
static
already_AddRefed
<
dom
:
:
AnimationTimeline
>
GetNamedProgressTimeline
(
dom
:
:
Document
*
aDocument
const
NonOwningAnimationTarget
&
aTarget
const
nsAtom
*
aName
)
{
for
(
Element
*
curr
=
AnimationUtils
:
:
GetElementForRestyle
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
;
curr
;
curr
=
curr
-
>
GetParentElement
(
)
)
{
for
(
Element
*
e
=
curr
;
e
;
e
=
e
-
>
GetPreviousElementSibling
(
)
)
{
const
auto
[
element
pseudoType
]
=
AnimationUtils
:
:
GetElementPseudoPair
(
e
)
;
if
(
auto
*
collection
=
TimelineCollection
<
ScrollTimeline
>
:
:
Get
(
element
pseudoType
)
)
{
if
(
RefPtr
<
ScrollTimeline
>
timeline
=
collection
-
>
Lookup
(
aName
)
)
{
return
timeline
.
forget
(
)
;
}
}
if
(
auto
*
collection
=
TimelineCollection
<
ViewTimeline
>
:
:
Get
(
element
pseudoType
)
)
{
if
(
RefPtr
<
ViewTimeline
>
timeline
=
collection
-
>
Lookup
(
aName
)
)
{
return
timeline
.
forget
(
)
;
}
}
}
}
return
nullptr
;
}
static
already_AddRefed
<
dom
:
:
AnimationTimeline
>
GetTimeline
(
const
StyleAnimationTimeline
&
aStyleTimeline
nsPresContext
*
aPresContext
const
NonOwningAnimationTarget
&
aTarget
)
{
switch
(
aStyleTimeline
.
tag
)
{
case
StyleAnimationTimeline
:
:
Tag
:
:
Timeline
:
{
const
nsAtom
*
name
=
aStyleTimeline
.
AsTimeline
(
)
.
AsAtom
(
)
;
return
name
!
=
nsGkAtoms
:
:
_empty
?
GetNamedProgressTimeline
(
aPresContext
-
>
Document
(
)
aTarget
name
)
:
nullptr
;
}
case
StyleAnimationTimeline
:
:
Tag
:
:
Scroll
:
{
const
auto
&
scroll
=
aStyleTimeline
.
AsScroll
(
)
;
return
ScrollTimeline
:
:
MakeAnonymous
(
aPresContext
-
>
Document
(
)
aTarget
scroll
.
axis
scroll
.
scroller
)
;
}
case
StyleAnimationTimeline
:
:
Tag
:
:
View
:
{
const
auto
&
view
=
aStyleTimeline
.
AsView
(
)
;
return
ViewTimeline
:
:
MakeAnonymous
(
aPresContext
-
>
Document
(
)
aTarget
view
.
axis
view
.
inset
)
;
}
case
StyleAnimationTimeline
:
:
Tag
:
:
Auto
:
return
do_AddRef
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
animation
-
timeline
value
?
"
)
;
return
nullptr
;
}
static
already_AddRefed
<
CSSAnimation
>
BuildAnimation
(
nsPresContext
*
aPresContext
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleUIReset
&
aStyle
uint32_t
animIdx
ServoCSSAnimationBuilder
&
aBuilder
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
MOZ_ASSERT
(
aPresContext
)
;
nsAtom
*
animationName
=
aStyle
.
GetAnimationName
(
animIdx
)
;
nsTArray
<
Keyframe
>
keyframes
;
if
(
!
aBuilder
.
BuildKeyframes
(
*
aTarget
.
mElement
aPresContext
animationName
aStyle
.
GetAnimationTimingFunction
(
animIdx
)
keyframes
)
)
{
return
nullptr
;
}
TimingParams
timing
=
TimingParamsFromCSSParams
(
aStyle
.
GetAnimationDuration
(
animIdx
)
.
ToMilliseconds
(
)
aStyle
.
GetAnimationDelay
(
animIdx
)
.
ToMilliseconds
(
)
aStyle
.
GetAnimationIterationCount
(
animIdx
)
aStyle
.
GetAnimationDirection
(
animIdx
)
aStyle
.
GetAnimationFillMode
(
animIdx
)
)
;
bool
isStylePaused
=
aStyle
.
GetAnimationPlayState
(
animIdx
)
=
=
StyleAnimationPlayState
:
:
Paused
;
RefPtr
<
dom
:
:
AnimationTimeline
>
timeline
=
GetTimeline
(
aStyle
.
GetTimeline
(
animIdx
)
aPresContext
aTarget
)
;
RefPtr
<
CSSAnimation
>
oldAnim
=
PopExistingAnimation
(
animationName
aCollection
)
;
if
(
oldAnim
)
{
UpdateOldAnimationPropertiesWithNew
(
*
oldAnim
std
:
:
move
(
timing
)
std
:
:
move
(
keyframes
)
isStylePaused
oldAnim
-
>
GetOverriddenProperties
(
)
aBuilder
timeline
aStyle
.
GetAnimationComposition
(
animIdx
)
)
;
return
oldAnim
.
forget
(
)
;
}
KeyframeEffectParams
effectOptions
(
aStyle
.
GetAnimationComposition
(
animIdx
)
)
;
RefPtr
<
KeyframeEffect
>
effect
=
new
dom
:
:
CSSAnimationKeyframeEffect
(
aPresContext
-
>
Document
(
)
OwningAnimationTarget
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
std
:
:
move
(
timing
)
effectOptions
)
;
aBuilder
.
SetKeyframes
(
*
effect
std
:
:
move
(
keyframes
)
timeline
)
;
RefPtr
<
CSSAnimation
>
animation
=
new
CSSAnimation
(
aPresContext
-
>
Document
(
)
-
>
GetScopeObject
(
)
animationName
)
;
animation
-
>
SetOwningElement
(
OwningElementRef
(
*
aTarget
.
mElement
aTarget
.
mPseudoType
)
)
;
animation
-
>
SetTimelineNoUpdate
(
timeline
)
;
animation
-
>
SetEffectNoUpdate
(
effect
)
;
if
(
isStylePaused
)
{
animation
-
>
PauseFromStyle
(
)
;
}
else
{
animation
-
>
PlayFromStyle
(
)
;
}
aBuilder
.
NotifyNewOrRemovedAnimation
(
*
animation
)
;
return
animation
.
forget
(
)
;
}
static
nsAnimationManager
:
:
OwningCSSAnimationPtrArray
BuildAnimations
(
nsPresContext
*
aPresContext
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleUIReset
&
aStyle
ServoCSSAnimationBuilder
&
aBuilder
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
nsTHashSet
<
RefPtr
<
nsAtom
>
>
&
aReferencedAnimations
)
{
nsAnimationManager
:
:
OwningCSSAnimationPtrArray
result
;
for
(
size_t
animIdx
=
aStyle
.
mAnimationNameCount
;
animIdx
-
-
!
=
0
;
)
{
nsAtom
*
name
=
aStyle
.
GetAnimationName
(
animIdx
)
;
if
(
name
=
=
nsGkAtoms
:
:
_empty
)
{
continue
;
}
aReferencedAnimations
.
Insert
(
name
)
;
RefPtr
<
CSSAnimation
>
dest
=
BuildAnimation
(
aPresContext
aTarget
aStyle
animIdx
aBuilder
aCollection
)
;
if
(
!
dest
)
{
continue
;
}
dest
-
>
SetAnimationIndex
(
static_cast
<
uint64_t
>
(
animIdx
)
)
;
result
.
AppendElement
(
dest
)
;
}
return
result
;
}
void
nsAnimationManager
:
:
UpdateAnimations
(
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
const
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
mPresContext
-
>
IsDynamic
(
)
"
Should
not
update
animations
for
print
or
print
preview
"
)
;
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
"
Should
not
update
animations
that
are
not
attached
to
the
"
"
document
tree
"
)
;
if
(
!
aComputedStyle
|
|
aComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
{
StopAnimationsForElement
(
aElement
aPseudoType
)
;
return
;
}
NonOwningAnimationTarget
target
(
aElement
aPseudoType
)
;
ServoCSSAnimationBuilder
builder
(
aComputedStyle
)
;
DoUpdateAnimations
(
target
*
aComputedStyle
-
>
StyleUIReset
(
)
builder
)
;
}
void
nsAnimationManager
:
:
DoUpdateAnimations
(
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleUIReset
&
aStyle
ServoCSSAnimationBuilder
&
aBuilder
)
{
auto
*
collection
=
CSSAnimationCollection
:
:
Get
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
;
if
(
!
collection
&
&
aStyle
.
mAnimationNameCount
=
=
1
&
&
aStyle
.
mAnimations
[
0
]
.
GetName
(
)
=
=
nsGkAtoms
:
:
_empty
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
)
;
OwningCSSAnimationPtrArray
newAnimations
=
BuildAnimations
(
mPresContext
aTarget
aStyle
aBuilder
collection
mMaybeReferencedAnimations
)
;
if
(
newAnimations
.
IsEmpty
(
)
)
{
if
(
collection
)
{
collection
-
>
Destroy
(
)
;
}
return
;
}
if
(
!
collection
)
{
collection
=
&
aTarget
.
mElement
-
>
EnsureAnimationData
(
)
.
EnsureAnimationCollection
(
*
aTarget
.
mElement
aTarget
.
mPseudoType
)
;
if
(
!
collection
-
>
isInList
(
)
)
{
AddElementCollection
(
collection
)
;
}
}
collection
-
>
mAnimations
.
SwapElements
(
newAnimations
)
;
for
(
size_t
newAnimIdx
=
newAnimations
.
Length
(
)
;
newAnimIdx
-
-
!
=
0
;
)
{
aBuilder
.
NotifyNewOrRemovedAnimation
(
*
newAnimations
[
newAnimIdx
]
)
;
newAnimations
[
newAnimIdx
]
-
>
CancelFromStyle
(
PostRestyleMode
:
:
IfNeeded
)
;
}
}
