#
include
"
nsAnimationManager
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
mozilla
/
dom
/
CSSAnimationBinding
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectReadOnly
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSRules
.
h
"
#
include
"
mozilla
/
GeckoRestyleManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
#
include
<
algorithm
>
#
include
<
math
.
h
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
mozilla
:
:
dom
:
:
Animation
;
using
mozilla
:
:
dom
:
:
AnimationPlayState
;
using
mozilla
:
:
dom
:
:
KeyframeEffectReadOnly
;
using
mozilla
:
:
dom
:
:
CSSAnimation
;
typedef
mozilla
:
:
ComputedTiming
:
:
AnimationPhase
AnimationPhase
;
namespace
{
struct
AnimationEventParams
{
EventMessage
mMessage
;
StickyTimeDuration
mElapsedTime
;
TimeStamp
mTimeStamp
;
}
;
}
JSObject
*
CSSAnimation
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
CSSAnimationBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
mozilla
:
:
dom
:
:
Promise
*
CSSAnimation
:
:
GetReady
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
return
Animation
:
:
GetReady
(
aRv
)
;
}
void
CSSAnimation
:
:
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
{
mPauseShouldStick
=
false
;
Animation
:
:
Play
(
aRv
aLimitBehavior
)
;
}
void
CSSAnimation
:
:
Pause
(
ErrorResult
&
aRv
)
{
mPauseShouldStick
=
true
;
Animation
:
:
Pause
(
aRv
)
;
}
AnimationPlayState
CSSAnimation
:
:
PlayStateFromJS
(
)
const
{
FlushStyle
(
)
;
return
Animation
:
:
PlayStateFromJS
(
)
;
}
void
CSSAnimation
:
:
PlayFromJS
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
Animation
:
:
PlayFromJS
(
aRv
)
;
}
void
CSSAnimation
:
:
PlayFromStyle
(
)
{
mIsStylePaused
=
false
;
if
(
!
mPauseShouldStick
)
{
ErrorResult
rv
;
PlayNoUpdate
(
rv
Animation
:
:
LimitBehavior
:
:
Continue
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Unexpected
exception
playing
animation
"
)
;
}
}
void
CSSAnimation
:
:
PauseFromStyle
(
)
{
if
(
mIsStylePaused
)
{
return
;
}
mIsStylePaused
=
true
;
ErrorResult
rv
;
PauseNoUpdate
(
rv
)
;
if
(
rv
.
Failed
(
)
)
{
NS_WARNING
(
"
Unexpected
exception
pausing
animation
-
silently
failing
"
)
;
}
}
void
CSSAnimation
:
:
Tick
(
)
{
Animation
:
:
Tick
(
)
;
QueueEvents
(
)
;
}
bool
CSSAnimation
:
:
HasLowerCompositeOrderThan
(
const
CSSAnimation
&
aOther
)
const
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
&
&
aOther
.
IsTiedToMarkup
(
)
"
Should
only
be
called
for
CSS
animations
that
are
sorted
"
"
as
CSS
animations
(
i
.
e
.
tied
to
CSS
markup
)
"
)
;
if
(
&
aOther
=
=
this
)
{
return
false
;
}
if
(
!
mOwningElement
.
Equals
(
aOther
.
mOwningElement
)
)
{
return
mOwningElement
.
LessThan
(
aOther
.
mOwningElement
)
;
}
return
mAnimationIndex
<
aOther
.
mAnimationIndex
;
}
void
CSSAnimation
:
:
QueueEvents
(
StickyTimeDuration
aActiveTime
)
{
if
(
mPendingState
!
=
PendingState
:
:
NotPending
)
{
return
;
}
if
(
!
mOwningElement
.
IsSet
(
)
)
{
return
;
}
dom
:
:
Element
*
owningElement
;
CSSPseudoElementType
owningPseudoType
;
mOwningElement
.
GetElement
(
owningElement
owningPseudoType
)
;
MOZ_ASSERT
(
owningElement
"
Owning
element
should
be
set
"
)
;
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
owningElement
)
;
if
(
!
presContext
)
{
return
;
}
nsAnimationManager
*
manager
=
presContext
-
>
AnimationManager
(
)
;
const
StickyTimeDuration
zeroDuration
;
uint64_t
currentIteration
=
0
;
ComputedTiming
:
:
AnimationPhase
currentPhase
;
StickyTimeDuration
intervalStartTime
;
StickyTimeDuration
intervalEndTime
;
StickyTimeDuration
iterationStartTime
;
if
(
!
mEffect
)
{
currentPhase
=
GetAnimationPhaseWithoutEffect
<
ComputedTiming
:
:
AnimationPhase
>
(
*
this
)
;
}
else
{
ComputedTiming
computedTiming
=
mEffect
-
>
GetComputedTiming
(
)
;
currentPhase
=
computedTiming
.
mPhase
;
currentIteration
=
computedTiming
.
mCurrentIteration
;
if
(
currentPhase
=
=
mPreviousPhase
&
&
currentIteration
=
=
mPreviousIteration
)
{
return
;
}
intervalStartTime
=
std
:
:
max
(
std
:
:
min
(
StickyTimeDuration
(
-
mEffect
-
>
SpecifiedTiming
(
)
.
mDelay
)
computedTiming
.
mActiveDuration
)
zeroDuration
)
;
intervalEndTime
=
std
:
:
max
(
std
:
:
min
(
(
EffectEnd
(
)
-
mEffect
-
>
SpecifiedTiming
(
)
.
mDelay
)
computedTiming
.
mActiveDuration
)
zeroDuration
)
;
uint64_t
iterationBoundary
=
mPreviousIteration
>
currentIteration
?
currentIteration
+
1
:
currentIteration
;
iterationStartTime
=
computedTiming
.
mDuration
.
MultDouble
(
(
iterationBoundary
-
computedTiming
.
mIterationStart
)
)
;
}
TimeStamp
startTimeStamp
=
ElapsedTimeToTimeStamp
(
intervalStartTime
)
;
TimeStamp
endTimeStamp
=
ElapsedTimeToTimeStamp
(
intervalEndTime
)
;
TimeStamp
iterationTimeStamp
=
ElapsedTimeToTimeStamp
(
iterationStartTime
)
;
AutoTArray
<
AnimationEventParams
2
>
events
;
if
(
(
mPreviousPhase
!
=
AnimationPhase
:
:
Idle
&
&
mPreviousPhase
!
=
AnimationPhase
:
:
After
)
&
&
currentPhase
=
=
AnimationPhase
:
:
Idle
)
{
TimeStamp
activeTimeStamp
=
ElapsedTimeToTimeStamp
(
aActiveTime
)
;
events
.
AppendElement
(
AnimationEventParams
{
eAnimationCancel
aActiveTime
activeTimeStamp
}
)
;
}
switch
(
mPreviousPhase
)
{
case
AnimationPhase
:
:
Idle
:
case
AnimationPhase
:
:
Before
:
if
(
currentPhase
=
=
AnimationPhase
:
:
Active
)
{
events
.
AppendElement
(
AnimationEventParams
{
eAnimationStart
intervalStartTime
startTimeStamp
}
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
After
)
{
events
.
AppendElement
(
AnimationEventParams
{
eAnimationStart
intervalStartTime
startTimeStamp
}
)
;
events
.
AppendElement
(
AnimationEventParams
{
eAnimationEnd
intervalEndTime
endTimeStamp
}
)
;
}
break
;
case
AnimationPhase
:
:
Active
:
if
(
currentPhase
=
=
AnimationPhase
:
:
Before
)
{
events
.
AppendElement
(
AnimationEventParams
{
eAnimationEnd
intervalStartTime
startTimeStamp
}
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
Active
)
{
MOZ_ASSERT
(
currentIteration
!
=
mPreviousIteration
)
;
events
.
AppendElement
(
AnimationEventParams
{
eAnimationIteration
iterationStartTime
iterationTimeStamp
}
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
After
)
{
events
.
AppendElement
(
AnimationEventParams
{
eAnimationEnd
intervalEndTime
endTimeStamp
}
)
;
}
break
;
case
AnimationPhase
:
:
After
:
if
(
currentPhase
=
=
AnimationPhase
:
:
Before
)
{
events
.
AppendElement
(
AnimationEventParams
{
eAnimationStart
intervalEndTime
startTimeStamp
}
)
;
events
.
AppendElement
(
AnimationEventParams
{
eAnimationEnd
intervalStartTime
endTimeStamp
}
)
;
}
else
if
(
currentPhase
=
=
AnimationPhase
:
:
Active
)
{
events
.
AppendElement
(
AnimationEventParams
{
eAnimationStart
intervalEndTime
endTimeStamp
}
)
;
}
break
;
}
mPreviousPhase
=
currentPhase
;
mPreviousIteration
=
currentIteration
;
for
(
const
AnimationEventParams
&
event
:
events
)
{
manager
-
>
QueueEvent
(
AnimationEventInfo
(
owningElement
owningPseudoType
event
.
mMessage
mAnimationName
event
.
mElapsedTime
event
.
mTimeStamp
this
)
)
;
}
}
void
CSSAnimation
:
:
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
if
(
mNeedsNewAnimationIndexWhenRun
&
&
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
false
;
}
Animation
:
:
UpdateTiming
(
aSeekFlag
aSyncNotifyFlag
)
;
}
NS_IMPL_CYCLE_COLLECTION
(
nsAnimationManager
mEventDispatcher
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
nsAnimationManager
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
nsAnimationManager
Release
)
static
already_AddRefed
<
CSSAnimation
>
PopExistingAnimation
(
const
nsAString
&
aName
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
if
(
!
aCollection
)
{
return
nullptr
;
}
for
(
size_t
idx
=
0
length
=
aCollection
-
>
mAnimations
.
Length
(
)
;
idx
!
=
length
;
+
+
idx
)
{
CSSAnimation
*
cssAnim
=
aCollection
-
>
mAnimations
[
idx
]
;
if
(
cssAnim
-
>
AnimationName
(
)
=
=
aName
)
{
RefPtr
<
CSSAnimation
>
match
=
cssAnim
;
aCollection
-
>
mAnimations
.
RemoveElementAt
(
idx
)
;
return
match
.
forget
(
)
;
}
}
return
nullptr
;
}
void
nsAnimationManager
:
:
StopAnimationsForElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
CSSPseudoElementType
aPseudoType
)
{
MOZ_ASSERT
(
aElement
)
;
CSSAnimationCollection
*
collection
=
CSSAnimationCollection
:
:
GetAnimationCollection
(
aElement
aPseudoType
)
;
if
(
!
collection
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aElement
-
>
OwnerDoc
(
)
)
;
collection
-
>
Destroy
(
)
;
}
class
ResolvedStyleCache
{
public
:
ResolvedStyleCache
(
)
:
mCache
(
)
{
}
nsStyleContext
*
Get
(
nsPresContext
*
aPresContext
nsStyleContext
*
aParentStyleContext
Declaration
*
aKeyframeDeclaration
)
;
private
:
nsRefPtrHashtable
<
nsPtrHashKey
<
Declaration
>
nsStyleContext
>
mCache
;
}
;
nsStyleContext
*
ResolvedStyleCache
:
:
Get
(
nsPresContext
*
aPresContext
nsStyleContext
*
aParentStyleContext
Declaration
*
aKeyframeDeclaration
)
{
nsStyleContext
*
result
=
mCache
.
GetWeak
(
aKeyframeDeclaration
)
;
if
(
!
result
)
{
aKeyframeDeclaration
-
>
SetImmutable
(
)
;
MOZ_ASSERT
(
!
aKeyframeDeclaration
-
>
HasImportantData
(
)
"
Keyframe
rule
has
!
important
data
"
)
;
nsCOMArray
<
nsIStyleRule
>
rules
;
rules
.
AppendObject
(
aKeyframeDeclaration
)
;
MOZ_ASSERT
(
aPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
RefPtr
<
nsStyleContext
>
resultStrong
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleByAddingRules
(
aParentStyleContext
rules
)
;
mCache
.
Put
(
aKeyframeDeclaration
resultStrong
)
;
result
=
resultStrong
;
}
return
result
;
}
class
MOZ_STACK_CLASS
ServoCSSAnimationBuilder
final
{
public
:
ServoCSSAnimationBuilder
(
const
ServoComputedValues
*
aComputedValues
const
ServoComputedValues
*
aParentComputedValues
)
:
mComputedValues
(
aComputedValues
)
mParentComputedValues
(
aParentComputedValues
)
{
MOZ_ASSERT
(
aComputedValues
)
;
}
bool
BuildKeyframes
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
ServoStyleSet
*
styleSet
=
aPresContext
-
>
StyleSet
(
)
-
>
AsServo
(
)
;
MOZ_ASSERT
(
styleSet
)
;
const
nsTimingFunction
&
timingFunction
=
aSrc
.
GetTimingFunction
(
)
;
return
styleSet
-
>
FillKeyframesForName
(
aSrc
.
GetName
(
)
timingFunction
mComputedValues
aKeyframes
)
;
}
void
SetKeyframes
(
KeyframeEffectReadOnly
&
aEffect
nsTArray
<
Keyframe
>
&
&
aKeyframes
)
{
aEffect
.
SetKeyframes
(
Move
(
aKeyframes
)
{
mComputedValues
mParentComputedValues
}
)
;
}
private
:
const
ServoComputedValues
*
mComputedValues
;
const
ServoComputedValues
*
mParentComputedValues
;
}
;
class
MOZ_STACK_CLASS
GeckoCSSAnimationBuilder
final
{
public
:
GeckoCSSAnimationBuilder
(
nsStyleContext
*
aStyleContext
const
NonOwningAnimationTarget
&
aTarget
)
:
mStyleContext
(
aStyleContext
)
mTarget
(
aTarget
)
{
MOZ_ASSERT
(
aStyleContext
)
;
MOZ_ASSERT
(
aTarget
.
mElement
)
;
}
bool
BuildKeyframes
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
nsTArray
<
Keyframe
>
&
aKeyframs
)
;
void
SetKeyframes
(
KeyframeEffectReadOnly
&
aEffect
nsTArray
<
Keyframe
>
&
&
aKeyframes
)
{
aEffect
.
SetKeyframes
(
Move
(
aKeyframes
)
mStyleContext
)
;
}
private
:
nsTArray
<
Keyframe
>
BuildAnimationFrames
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
)
;
Maybe
<
ComputedTimingFunction
>
GetKeyframeTimingFunction
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
)
;
nsTArray
<
PropertyValuePair
>
GetKeyframePropertyValues
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
nsCSSPropertyIDSet
&
aAnimatedProperties
)
;
void
FillInMissingKeyframeValues
(
nsPresContext
*
aPresContext
nsCSSPropertyIDSet
aAnimatedProperties
nsCSSPropertyIDSet
aPropertiesSetAtStart
nsCSSPropertyIDSet
aPropertiesSetAtEnd
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
;
void
AppendProperty
(
nsPresContext
*
aPresContext
nsCSSPropertyID
aProperty
nsTArray
<
PropertyValuePair
>
&
aPropertyValues
)
;
nsCSSValue
GetComputedValue
(
nsPresContext
*
aPresContext
nsCSSPropertyID
aProperty
)
;
RefPtr
<
nsStyleContext
>
mStyleContext
;
NonOwningAnimationTarget
mTarget
;
ResolvedStyleCache
mResolvedStyles
;
RefPtr
<
nsStyleContext
>
mStyleWithoutAnimation
;
}
;
static
Maybe
<
ComputedTimingFunction
>
ConvertTimingFunction
(
const
nsTimingFunction
&
aTimingFunction
)
;
template
<
class
BuilderType
>
static
void
UpdateOldAnimationPropertiesWithNew
(
CSSAnimation
&
aOld
TimingParams
&
aNewTiming
nsTArray
<
Keyframe
>
&
&
aNewKeyframes
bool
aNewIsStylePaused
BuilderType
&
aBuilder
)
{
bool
animationChanged
=
false
;
if
(
aOld
.
GetEffect
(
)
)
{
dom
:
:
AnimationEffectReadOnly
*
oldEffect
=
aOld
.
GetEffect
(
)
;
animationChanged
=
oldEffect
-
>
SpecifiedTiming
(
)
!
=
aNewTiming
;
oldEffect
-
>
SetSpecifiedTiming
(
aNewTiming
)
;
KeyframeEffectReadOnly
*
oldKeyframeEffect
=
oldEffect
-
>
AsKeyframeEffect
(
)
;
if
(
oldKeyframeEffect
)
{
aBuilder
.
SetKeyframes
(
*
oldKeyframeEffect
Move
(
aNewKeyframes
)
)
;
}
}
if
(
aOld
.
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
if
(
!
aOld
.
IsStylePaused
(
)
&
&
aNewIsStylePaused
)
{
aOld
.
PauseFromStyle
(
)
;
animationChanged
=
true
;
}
else
if
(
aOld
.
IsStylePaused
(
)
&
&
!
aNewIsStylePaused
)
{
aOld
.
PlayFromStyle
(
)
;
animationChanged
=
true
;
}
}
if
(
animationChanged
&
&
aOld
.
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
&
aOld
)
;
}
}
template
<
class
BuilderType
>
static
already_AddRefed
<
CSSAnimation
>
BuildAnimation
(
nsPresContext
*
aPresContext
const
NonOwningAnimationTarget
&
aTarget
const
StyleAnimation
&
aSrc
BuilderType
&
aBuilder
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
MOZ_ASSERT
(
aPresContext
)
;
nsTArray
<
Keyframe
>
keyframes
;
if
(
!
aBuilder
.
BuildKeyframes
(
aPresContext
aSrc
keyframes
)
)
{
return
nullptr
;
}
TimingParams
timing
=
TimingParamsFromCSSParams
(
aSrc
.
GetDuration
(
)
aSrc
.
GetDelay
(
)
aSrc
.
GetIterationCount
(
)
aSrc
.
GetDirection
(
)
aSrc
.
GetFillMode
(
)
)
;
bool
isStylePaused
=
aSrc
.
GetPlayState
(
)
=
=
NS_STYLE_ANIMATION_PLAY_STATE_PAUSED
;
RefPtr
<
CSSAnimation
>
oldAnim
=
PopExistingAnimation
(
aSrc
.
GetName
(
)
aCollection
)
;
if
(
oldAnim
)
{
UpdateOldAnimationPropertiesWithNew
(
*
oldAnim
timing
Move
(
keyframes
)
isStylePaused
aBuilder
)
;
return
oldAnim
.
forget
(
)
;
}
Maybe
<
OwningAnimationTarget
>
target
;
target
.
emplace
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
;
KeyframeEffectParams
effectOptions
;
RefPtr
<
KeyframeEffectReadOnly
>
effect
=
new
KeyframeEffectReadOnly
(
aPresContext
-
>
Document
(
)
target
timing
effectOptions
)
;
aBuilder
.
SetKeyframes
(
*
effect
Move
(
keyframes
)
)
;
RefPtr
<
CSSAnimation
>
animation
=
new
CSSAnimation
(
aPresContext
-
>
Document
(
)
-
>
GetScopeObject
(
)
aSrc
.
GetName
(
)
)
;
animation
-
>
SetOwningElement
(
OwningElementRef
(
*
aTarget
.
mElement
aTarget
.
mPseudoType
)
)
;
animation
-
>
SetTimelineNoUpdate
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
)
;
animation
-
>
SetEffectNoUpdate
(
effect
)
;
if
(
isStylePaused
)
{
animation
-
>
PauseFromStyle
(
)
;
}
else
{
animation
-
>
PlayFromStyle
(
)
;
}
return
animation
.
forget
(
)
;
}
bool
GeckoCSSAnimationBuilder
:
:
BuildKeyframes
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
MOZ_ASSERT
(
aPresContext
)
;
if
(
aPresContext
-
>
StyleSet
(
)
-
>
IsServo
(
)
)
{
ServoStyleSet
*
styleSet
=
aPresContext
-
>
StyleSet
(
)
-
>
AsServo
(
)
;
MOZ_ASSERT
(
styleSet
)
;
const
ServoComputedValues
*
computedValues
=
mStyleContext
-
>
StyleSource
(
)
.
AsServoComputedValues
(
)
;
const
nsTimingFunction
&
timingFunction
=
aSrc
.
GetTimingFunction
(
)
;
if
(
!
styleSet
-
>
FillKeyframesForName
(
aSrc
.
GetName
(
)
timingFunction
computedValues
aKeyframes
)
)
{
return
false
;
}
}
else
{
nsCSSKeyframesRule
*
rule
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
KeyframesRuleForName
(
aSrc
.
GetName
(
)
)
;
if
(
!
rule
)
{
return
false
;
}
aKeyframes
=
BuildAnimationFrames
(
aPresContext
aSrc
rule
)
;
}
return
true
;
}
nsTArray
<
Keyframe
>
GeckoCSSAnimationBuilder
:
:
BuildAnimationFrames
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
)
{
Maybe
<
ComputedTimingFunction
>
inheritedTimingFunction
=
ConvertTimingFunction
(
aSrc
.
GetTimingFunction
(
)
)
;
nsTArray
<
Keyframe
>
keyframes
;
nsCSSPropertyIDSet
animatedProperties
;
for
(
auto
ruleIdx
=
0
ruleEnd
=
aRule
-
>
StyleRuleCount
(
)
;
ruleIdx
!
=
ruleEnd
;
+
+
ruleIdx
)
{
css
:
:
Rule
*
cssRule
=
aRule
-
>
GetStyleRuleAt
(
ruleIdx
)
;
MOZ_ASSERT
(
cssRule
"
must
have
rule
"
)
;
MOZ_ASSERT
(
cssRule
-
>
GetType
(
)
=
=
css
:
:
Rule
:
:
KEYFRAME_RULE
"
must
be
keyframe
rule
"
)
;
nsCSSKeyframeRule
*
keyframeRule
=
static_cast
<
nsCSSKeyframeRule
*
>
(
cssRule
)
;
const
nsTArray
<
float
>
&
keys
=
keyframeRule
-
>
GetKeys
(
)
;
for
(
float
key
:
keys
)
{
if
(
key
<
0
.
0f
|
|
key
>
1
.
0f
)
{
continue
;
}
Keyframe
keyframe
;
keyframe
.
mOffset
.
emplace
(
key
)
;
keyframe
.
mTimingFunction
=
GetKeyframeTimingFunction
(
aPresContext
keyframeRule
inheritedTimingFunction
)
;
keyframe
.
mPropertyValues
=
GetKeyframePropertyValues
(
aPresContext
keyframeRule
animatedProperties
)
;
keyframes
.
AppendElement
(
Move
(
keyframe
)
)
;
}
}
std
:
:
stable_sort
(
keyframes
.
begin
(
)
keyframes
.
end
(
)
[
]
(
const
Keyframe
&
a
const
Keyframe
&
b
)
{
return
a
.
mOffset
<
b
.
mOffset
;
}
)
;
nsCSSPropertyIDSet
propertiesSetAtCurrentOffset
;
nsCSSPropertyIDSet
propertiesSetAtStart
;
nsCSSPropertyIDSet
propertiesSetAtEnd
;
double
currentOffset
=
-
1
.
0
;
for
(
size_t
keyframeIdx
=
keyframes
.
Length
(
)
;
keyframeIdx
>
0
;
-
-
keyframeIdx
)
{
Keyframe
&
keyframe
=
keyframes
[
keyframeIdx
-
1
]
;
MOZ_ASSERT
(
keyframe
.
mOffset
"
Should
have
filled
in
the
offset
"
)
;
if
(
keyframe
.
mOffset
.
value
(
)
!
=
currentOffset
)
{
propertiesSetAtCurrentOffset
.
Empty
(
)
;
currentOffset
=
keyframe
.
mOffset
.
value
(
)
;
}
nsTArray
<
PropertyValuePair
>
uniquePropertyValues
;
uniquePropertyValues
.
SetCapacity
(
keyframe
.
mPropertyValues
.
Length
(
)
)
;
for
(
const
PropertyValuePair
&
pair
:
keyframe
.
mPropertyValues
)
{
if
(
!
propertiesSetAtCurrentOffset
.
HasProperty
(
pair
.
mProperty
)
)
{
uniquePropertyValues
.
AppendElement
(
pair
)
;
propertiesSetAtCurrentOffset
.
AddProperty
(
pair
.
mProperty
)
;
if
(
currentOffset
=
=
0
.
0
)
{
propertiesSetAtStart
.
AddProperty
(
pair
.
mProperty
)
;
}
else
if
(
currentOffset
=
=
1
.
0
)
{
propertiesSetAtEnd
.
AddProperty
(
pair
.
mProperty
)
;
}
}
}
Keyframe
*
existingKeyframe
=
nullptr
;
if
(
!
uniquePropertyValues
.
IsEmpty
(
)
)
{
for
(
size_t
i
=
keyframeIdx
;
i
<
keyframes
.
Length
(
)
;
i
+
+
)
{
Keyframe
&
kf
=
keyframes
[
i
]
;
if
(
kf
.
mOffset
.
value
(
)
!
=
currentOffset
)
{
break
;
}
if
(
kf
.
mTimingFunction
=
=
keyframe
.
mTimingFunction
)
{
existingKeyframe
=
&
kf
;
break
;
}
}
}
if
(
existingKeyframe
)
{
existingKeyframe
-
>
mPropertyValues
.
AppendElements
(
Move
(
uniquePropertyValues
)
)
;
keyframe
.
mPropertyValues
.
Clear
(
)
;
}
else
{
keyframe
.
mPropertyValues
.
SwapElements
(
uniquePropertyValues
)
;
}
if
(
keyframe
.
mPropertyValues
.
IsEmpty
(
)
)
{
keyframes
.
RemoveElementAt
(
keyframeIdx
-
1
)
;
}
}
FillInMissingKeyframeValues
(
aPresContext
animatedProperties
propertiesSetAtStart
propertiesSetAtEnd
inheritedTimingFunction
keyframes
)
;
return
keyframes
;
}
Maybe
<
ComputedTimingFunction
>
GeckoCSSAnimationBuilder
:
:
GetKeyframeTimingFunction
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
)
{
Maybe
<
ComputedTimingFunction
>
result
;
if
(
aKeyframeRule
-
>
Declaration
(
)
&
&
aKeyframeRule
-
>
Declaration
(
)
-
>
HasProperty
(
eCSSProperty_animation_timing_function
)
)
{
RefPtr
<
nsStyleContext
>
keyframeRuleContext
=
mResolvedStyles
.
Get
(
aPresContext
mStyleContext
aKeyframeRule
-
>
Declaration
(
)
)
;
const
nsTimingFunction
&
tf
=
keyframeRuleContext
-
>
StyleDisplay
(
)
-
>
mAnimations
[
0
]
.
GetTimingFunction
(
)
;
result
=
ConvertTimingFunction
(
tf
)
;
}
else
{
result
=
aInheritedTimingFunction
;
}
return
result
;
}
static
Maybe
<
ComputedTimingFunction
>
ConvertTimingFunction
(
const
nsTimingFunction
&
aTimingFunction
)
{
Maybe
<
ComputedTimingFunction
>
result
;
if
(
aTimingFunction
.
mType
!
=
nsTimingFunction
:
:
Type
:
:
Linear
)
{
result
.
emplace
(
)
;
result
-
>
Init
(
aTimingFunction
)
;
}
return
result
;
}
nsTArray
<
PropertyValuePair
>
GeckoCSSAnimationBuilder
:
:
GetKeyframePropertyValues
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
nsCSSPropertyIDSet
&
aAnimatedProperties
)
{
nsTArray
<
PropertyValuePair
>
result
;
RefPtr
<
nsStyleContext
>
styleContext
=
mResolvedStyles
.
Get
(
aPresContext
mStyleContext
aKeyframeRule
-
>
Declaration
(
)
)
;
for
(
nsCSSPropertyID
prop
=
nsCSSPropertyID
(
0
)
;
prop
<
eCSSProperty_COUNT_no_shorthands
;
prop
=
nsCSSPropertyID
(
prop
+
1
)
)
{
if
(
nsCSSProps
:
:
kAnimTypeTable
[
prop
]
=
=
eStyleAnimType_None
|
|
!
aKeyframeRule
-
>
Declaration
(
)
-
>
HasNonImportantValueFor
(
prop
)
)
{
continue
;
}
PropertyValuePair
pair
;
pair
.
mProperty
=
prop
;
StyleAnimationValue
computedValue
;
if
(
!
StyleAnimationValue
:
:
ExtractComputedValue
(
prop
styleContext
computedValue
)
)
{
continue
;
}
DebugOnly
<
bool
>
uncomputeResult
=
StyleAnimationValue
:
:
UncomputeValue
(
prop
Move
(
computedValue
)
pair
.
mValue
)
;
MOZ_ASSERT
(
uncomputeResult
"
Unable
to
get
specified
value
from
computed
value
"
)
;
MOZ_ASSERT
(
pair
.
mValue
.
GetUnit
(
)
!
=
eCSSUnit_Null
"
Not
expecting
to
read
invalid
properties
"
)
;
result
.
AppendElement
(
Move
(
pair
)
)
;
aAnimatedProperties
.
AddProperty
(
prop
)
;
}
return
result
;
}
template
<
class
IterType
>
static
bool
FindMatchingKeyframe
(
IterType
&
&
aIter
double
aOffset
const
Maybe
<
ComputedTimingFunction
>
&
aTimingFunctionToMatch
size_t
&
aIndex
)
{
aIndex
=
0
;
for
(
Keyframe
&
keyframe
:
aIter
)
{
if
(
keyframe
.
mOffset
.
value
(
)
!
=
aOffset
)
{
break
;
}
if
(
keyframe
.
mTimingFunction
=
=
aTimingFunctionToMatch
)
{
return
true
;
}
+
+
aIndex
;
}
return
false
;
}
void
GeckoCSSAnimationBuilder
:
:
FillInMissingKeyframeValues
(
nsPresContext
*
aPresContext
nsCSSPropertyIDSet
aAnimatedProperties
nsCSSPropertyIDSet
aPropertiesSetAtStart
nsCSSPropertyIDSet
aPropertiesSetAtEnd
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
static
const
size_t
kNotSet
=
static_cast
<
size_t
>
(
-
1
)
;
size_t
startKeyframeIndex
=
kNotSet
;
if
(
!
aAnimatedProperties
.
Equals
(
aPropertiesSetAtStart
)
&
&
!
FindMatchingKeyframe
(
aKeyframes
0
.
0
aInheritedTimingFunction
startKeyframeIndex
)
)
{
Keyframe
newKeyframe
;
newKeyframe
.
mOffset
.
emplace
(
0
.
0
)
;
newKeyframe
.
mTimingFunction
=
aInheritedTimingFunction
;
aKeyframes
.
InsertElementAt
(
startKeyframeIndex
Move
(
newKeyframe
)
)
;
}
size_t
endKeyframeIndex
=
kNotSet
;
if
(
!
aAnimatedProperties
.
Equals
(
aPropertiesSetAtEnd
)
)
{
if
(
!
FindMatchingKeyframe
(
Reversed
(
aKeyframes
)
1
.
0
aInheritedTimingFunction
endKeyframeIndex
)
)
{
Keyframe
newKeyframe
;
newKeyframe
.
mOffset
.
emplace
(
1
.
0
)
;
newKeyframe
.
mTimingFunction
=
aInheritedTimingFunction
;
aKeyframes
.
AppendElement
(
Move
(
newKeyframe
)
)
;
endKeyframeIndex
=
aKeyframes
.
Length
(
)
-
1
;
}
else
{
endKeyframeIndex
=
aKeyframes
.
Length
(
)
-
1
-
endKeyframeIndex
;
}
}
if
(
startKeyframeIndex
=
=
kNotSet
&
&
endKeyframeIndex
=
=
kNotSet
)
{
return
;
}
Keyframe
*
startKeyframe
=
startKeyframeIndex
=
=
kNotSet
?
nullptr
:
&
aKeyframes
[
startKeyframeIndex
]
;
Keyframe
*
endKeyframe
=
endKeyframeIndex
=
=
kNotSet
?
nullptr
:
&
aKeyframes
[
endKeyframeIndex
]
;
for
(
nsCSSPropertyID
prop
=
nsCSSPropertyID
(
0
)
;
prop
<
eCSSProperty_COUNT_no_shorthands
;
prop
=
nsCSSPropertyID
(
prop
+
1
)
)
{
if
(
!
aAnimatedProperties
.
HasProperty
(
prop
)
)
{
continue
;
}
if
(
startKeyframe
&
&
!
aPropertiesSetAtStart
.
HasProperty
(
prop
)
)
{
AppendProperty
(
aPresContext
prop
startKeyframe
-
>
mPropertyValues
)
;
}
if
(
endKeyframe
&
&
!
aPropertiesSetAtEnd
.
HasProperty
(
prop
)
)
{
AppendProperty
(
aPresContext
prop
endKeyframe
-
>
mPropertyValues
)
;
}
}
}
void
GeckoCSSAnimationBuilder
:
:
AppendProperty
(
nsPresContext
*
aPresContext
nsCSSPropertyID
aProperty
nsTArray
<
PropertyValuePair
>
&
aPropertyValues
)
{
PropertyValuePair
propertyValue
;
propertyValue
.
mProperty
=
aProperty
;
propertyValue
.
mValue
=
GetComputedValue
(
aPresContext
aProperty
)
;
aPropertyValues
.
AppendElement
(
Move
(
propertyValue
)
)
;
}
nsCSSValue
GeckoCSSAnimationBuilder
:
:
GetComputedValue
(
nsPresContext
*
aPresContext
nsCSSPropertyID
aProperty
)
{
nsCSSValue
result
;
StyleAnimationValue
computedValue
;
if
(
!
mStyleWithoutAnimation
)
{
MOZ_ASSERT
(
aPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
mStyleWithoutAnimation
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleByRemovingAnimation
(
mTarget
.
mElement
mStyleContext
eRestyle_AllHintsWithAnimations
)
;
}
if
(
StyleAnimationValue
:
:
ExtractComputedValue
(
aProperty
mStyleWithoutAnimation
computedValue
)
)
{
DebugOnly
<
bool
>
uncomputeResult
=
StyleAnimationValue
:
:
UncomputeValue
(
aProperty
Move
(
computedValue
)
result
)
;
MOZ_ASSERT
(
uncomputeResult
"
Unable
to
get
specified
value
from
computed
value
"
)
;
}
MOZ_ASSERT
(
result
.
GetUnit
(
)
!
=
eCSSUnit_Null
"
Got
null
computed
value
"
)
;
return
result
;
}
template
<
class
BuilderType
>
static
nsAnimationManager
:
:
OwningCSSAnimationPtrArray
BuildAnimations
(
nsPresContext
*
aPresContext
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleAutoArray
<
StyleAnimation
>
&
aStyleAnimations
uint32_t
aStyleAnimationNameCount
BuilderType
&
aBuilder
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
nsAnimationManager
:
:
OwningCSSAnimationPtrArray
result
;
for
(
size_t
animIdx
=
aStyleAnimationNameCount
;
animIdx
-
-
!
=
0
;
)
{
const
StyleAnimation
&
src
=
aStyleAnimations
[
animIdx
]
;
if
(
src
.
GetName
(
)
.
IsEmpty
(
)
)
{
continue
;
}
RefPtr
<
CSSAnimation
>
dest
=
BuildAnimation
(
aPresContext
aTarget
src
aBuilder
aCollection
)
;
if
(
!
dest
)
{
continue
;
}
dest
-
>
SetAnimationIndex
(
static_cast
<
uint64_t
>
(
animIdx
)
)
;
result
.
AppendElement
(
dest
)
;
}
return
result
;
}
void
nsAnimationManager
:
:
UpdateAnimations
(
nsStyleContext
*
aStyleContext
mozilla
:
:
dom
:
:
Element
*
aElement
)
{
MOZ_ASSERT
(
mPresContext
-
>
IsDynamic
(
)
"
Should
not
update
animations
for
print
or
print
preview
"
)
;
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
"
Should
not
update
animations
that
are
not
attached
to
the
"
"
document
tree
"
)
;
if
(
aStyleContext
-
>
IsInDisplayNoneSubtree
(
)
)
{
StopAnimationsForElement
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
)
;
return
;
}
NonOwningAnimationTarget
target
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
)
;
GeckoCSSAnimationBuilder
builder
(
aStyleContext
target
)
;
const
nsStyleDisplay
*
disp
=
aStyleContext
-
>
StyleDisplay
(
)
;
DoUpdateAnimations
(
target
*
disp
builder
)
;
}
void
nsAnimationManager
:
:
UpdateAnimations
(
dom
:
:
Element
*
aElement
nsIAtom
*
aPseudoTagOrNull
const
ServoComputedValues
*
aComputedValues
const
ServoComputedValues
*
aParentComputedValues
)
{
MOZ_ASSERT
(
mPresContext
-
>
IsDynamic
(
)
"
Should
not
update
animations
for
print
or
print
preview
"
)
;
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
"
Should
not
update
animations
that
are
not
attached
to
the
"
"
document
tree
"
)
;
CSSPseudoElementType
pseudoType
=
nsCSSPseudoElements
:
:
GetPseudoType
(
aPseudoTagOrNull
CSSEnabledState
:
:
eForAllContent
)
;
NonOwningAnimationTarget
target
(
aElement
pseudoType
)
;
ServoCSSAnimationBuilder
builder
(
aComputedValues
aParentComputedValues
)
;
const
nsStyleDisplay
*
disp
=
Servo_GetStyleDisplay
(
aComputedValues
)
;
DoUpdateAnimations
(
target
*
disp
builder
)
;
}
template
<
class
BuilderType
>
void
nsAnimationManager
:
:
DoUpdateAnimations
(
const
NonOwningAnimationTarget
&
aTarget
const
nsStyleDisplay
&
aStyleDisplay
BuilderType
&
aBuilder
)
{
CSSAnimationCollection
*
collection
=
CSSAnimationCollection
:
:
GetAnimationCollection
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
;
if
(
!
collection
&
&
aStyleDisplay
.
mAnimationNameCount
=
=
1
&
&
aStyleDisplay
.
mAnimations
[
0
]
.
GetName
(
)
.
IsEmpty
(
)
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
)
;
OwningCSSAnimationPtrArray
newAnimations
;
newAnimations
=
BuildAnimations
(
mPresContext
aTarget
aStyleDisplay
.
mAnimations
aStyleDisplay
.
mAnimationNameCount
aBuilder
collection
)
;
if
(
newAnimations
.
IsEmpty
(
)
)
{
if
(
collection
)
{
collection
-
>
Destroy
(
)
;
}
return
;
}
if
(
!
collection
)
{
bool
createdCollection
=
false
;
collection
=
CSSAnimationCollection
:
:
GetOrCreateAnimationCollection
(
aTarget
.
mElement
aTarget
.
mPseudoType
&
createdCollection
)
;
if
(
!
collection
)
{
MOZ_ASSERT
(
!
createdCollection
"
outparam
should
agree
with
return
value
"
)
;
NS_WARNING
(
"
allocating
collection
failed
"
)
;
return
;
}
if
(
createdCollection
)
{
AddElementCollection
(
collection
)
;
}
}
collection
-
>
mAnimations
.
SwapElements
(
newAnimations
)
;
for
(
size_t
newAnimIdx
=
newAnimations
.
Length
(
)
;
newAnimIdx
-
-
!
=
0
;
)
{
newAnimations
[
newAnimIdx
]
-
>
CancelFromStyle
(
)
;
}
}
