#
include
"
nsAnimationManager
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
mozilla
/
dom
/
CSSAnimationBinding
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsCSSRules
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
<
algorithm
>
#
include
<
math
.
h
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
mozilla
:
:
dom
:
:
Animation
;
using
mozilla
:
:
dom
:
:
AnimationPlayState
;
using
mozilla
:
:
dom
:
:
KeyframeEffectReadOnly
;
using
mozilla
:
:
dom
:
:
CSSAnimation
;
namespace
{
typedef
Pair
<
EventMessage
StickyTimeDuration
>
EventPair
;
}
JSObject
*
CSSAnimation
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
CSSAnimationBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
mozilla
:
:
dom
:
:
Promise
*
CSSAnimation
:
:
GetReady
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
return
Animation
:
:
GetReady
(
aRv
)
;
}
void
CSSAnimation
:
:
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
{
mPauseShouldStick
=
false
;
Animation
:
:
Play
(
aRv
aLimitBehavior
)
;
}
void
CSSAnimation
:
:
Pause
(
ErrorResult
&
aRv
)
{
mPauseShouldStick
=
true
;
Animation
:
:
Pause
(
aRv
)
;
}
AnimationPlayState
CSSAnimation
:
:
PlayStateFromJS
(
)
const
{
FlushStyle
(
)
;
return
Animation
:
:
PlayStateFromJS
(
)
;
}
void
CSSAnimation
:
:
PlayFromJS
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
Animation
:
:
PlayFromJS
(
aRv
)
;
}
void
CSSAnimation
:
:
PlayFromStyle
(
)
{
mIsStylePaused
=
false
;
if
(
!
mPauseShouldStick
)
{
ErrorResult
rv
;
DoPlay
(
rv
Animation
:
:
LimitBehavior
:
:
Continue
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Unexpected
exception
playing
animation
"
)
;
}
}
void
CSSAnimation
:
:
PauseFromStyle
(
)
{
if
(
mIsStylePaused
)
{
return
;
}
mIsStylePaused
=
true
;
ErrorResult
rv
;
DoPause
(
rv
)
;
if
(
rv
.
Failed
(
)
)
{
NS_WARNING
(
"
Unexpected
exception
pausing
animation
-
silently
failing
"
)
;
}
}
void
CSSAnimation
:
:
Tick
(
)
{
Animation
:
:
Tick
(
)
;
QueueEvents
(
)
;
}
bool
CSSAnimation
:
:
HasLowerCompositeOrderThan
(
const
CSSAnimation
&
aOther
)
const
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
&
&
aOther
.
IsTiedToMarkup
(
)
"
Should
only
be
called
for
CSS
animations
that
are
sorted
"
"
as
CSS
animations
(
i
.
e
.
tied
to
CSS
markup
)
"
)
;
if
(
&
aOther
=
=
this
)
{
return
false
;
}
if
(
!
mOwningElement
.
Equals
(
aOther
.
mOwningElement
)
)
{
return
mOwningElement
.
LessThan
(
aOther
.
mOwningElement
)
;
}
return
mAnimationIndex
<
aOther
.
mAnimationIndex
;
}
void
CSSAnimation
:
:
QueueEvents
(
)
{
if
(
!
mEffect
)
{
return
;
}
if
(
mPendingState
!
=
PendingState
:
:
NotPending
)
{
return
;
}
if
(
!
mOwningElement
.
IsSet
(
)
)
{
return
;
}
dom
:
:
Element
*
owningElement
;
CSSPseudoElementType
owningPseudoType
;
mOwningElement
.
GetElement
(
owningElement
owningPseudoType
)
;
MOZ_ASSERT
(
owningElement
"
Owning
element
should
be
set
"
)
;
nsPresContext
*
presContext
=
mOwningElement
.
GetRenderedPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
nsAnimationManager
*
manager
=
presContext
-
>
AnimationManager
(
)
;
ComputedTiming
computedTiming
=
mEffect
-
>
GetComputedTiming
(
)
;
if
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Null
)
{
return
;
}
bool
wasActive
=
mPreviousPhaseOrIteration
!
=
PREVIOUS_PHASE_BEFORE
&
&
mPreviousPhaseOrIteration
!
=
PREVIOUS_PHASE_AFTER
;
bool
isActive
=
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
;
bool
isSameIteration
=
computedTiming
.
mCurrentIteration
=
=
mPreviousPhaseOrIteration
;
bool
skippedActivePhase
=
(
mPreviousPhaseOrIteration
=
=
PREVIOUS_PHASE_BEFORE
&
&
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
)
|
|
(
mPreviousPhaseOrIteration
=
=
PREVIOUS_PHASE_AFTER
&
&
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
)
;
bool
skippedFirstIteration
=
isActive
&
&
mPreviousPhaseOrIteration
=
=
PREVIOUS_PHASE_BEFORE
&
&
computedTiming
.
mCurrentIteration
>
0
;
MOZ_ASSERT
(
!
skippedActivePhase
|
|
(
!
isActive
&
&
!
wasActive
)
"
skippedActivePhase
only
makes
sense
if
we
were
&
are
inactive
"
)
;
if
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
)
{
mPreviousPhaseOrIteration
=
PREVIOUS_PHASE_BEFORE
;
}
else
if
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
)
{
mPreviousPhaseOrIteration
=
computedTiming
.
mCurrentIteration
;
}
else
if
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
)
{
mPreviousPhaseOrIteration
=
PREVIOUS_PHASE_AFTER
;
}
AutoTArray
<
EventPair
2
>
events
;
StickyTimeDuration
initialAdvance
=
StickyTimeDuration
(
InitialAdvance
(
)
)
;
StickyTimeDuration
iterationStart
=
computedTiming
.
mDuration
*
computedTiming
.
mCurrentIteration
;
const
StickyTimeDuration
&
activeDuration
=
computedTiming
.
mActiveDuration
;
if
(
skippedFirstIteration
)
{
events
.
AppendElement
(
EventPair
(
eAnimationStart
initialAdvance
)
)
;
events
.
AppendElement
(
EventPair
(
eAnimationIteration
std
:
:
max
(
iterationStart
initialAdvance
)
)
)
;
}
else
if
(
!
wasActive
&
&
isActive
)
{
events
.
AppendElement
(
EventPair
(
eAnimationStart
initialAdvance
)
)
;
}
else
if
(
wasActive
&
&
!
isActive
)
{
events
.
AppendElement
(
EventPair
(
eAnimationEnd
activeDuration
)
)
;
}
else
if
(
wasActive
&
&
isActive
&
&
!
isSameIteration
)
{
events
.
AppendElement
(
EventPair
(
eAnimationIteration
iterationStart
)
)
;
}
else
if
(
skippedActivePhase
)
{
events
.
AppendElement
(
EventPair
(
eAnimationStart
std
:
:
min
(
initialAdvance
activeDuration
)
)
)
;
events
.
AppendElement
(
EventPair
(
eAnimationEnd
activeDuration
)
)
;
}
else
{
return
;
}
for
(
const
EventPair
&
pair
:
events
)
{
manager
-
>
QueueEvent
(
AnimationEventInfo
(
owningElement
owningPseudoType
pair
.
first
(
)
mAnimationName
pair
.
second
(
)
ElapsedTimeToTimeStamp
(
pair
.
second
(
)
)
this
)
)
;
}
}
void
CSSAnimation
:
:
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
if
(
mNeedsNewAnimationIndexWhenRun
&
&
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
false
;
}
Animation
:
:
UpdateTiming
(
aSeekFlag
aSyncNotifyFlag
)
;
}
TimeStamp
CSSAnimation
:
:
ElapsedTimeToTimeStamp
(
const
StickyTimeDuration
&
aElapsedTime
)
const
{
return
AnimationTimeToTimeStamp
(
aElapsedTime
+
mEffect
-
>
SpecifiedTiming
(
)
.
mDelay
)
;
}
NS_IMPL_CYCLE_COLLECTION
(
nsAnimationManager
mEventDispatcher
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
nsAnimationManager
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
nsAnimationManager
Release
)
static
already_AddRefed
<
CSSAnimation
>
PopExistingAnimation
(
const
nsAString
&
aName
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
{
if
(
!
aCollection
)
{
return
nullptr
;
}
for
(
size_t
idx
=
0
length
=
aCollection
-
>
mAnimations
.
Length
(
)
;
idx
!
=
length
;
+
+
idx
)
{
CSSAnimation
*
cssAnim
=
aCollection
-
>
mAnimations
[
idx
]
;
if
(
cssAnim
-
>
AnimationName
(
)
=
=
aName
)
{
RefPtr
<
CSSAnimation
>
match
=
cssAnim
;
aCollection
-
>
mAnimations
.
RemoveElementAt
(
idx
)
;
return
match
.
forget
(
)
;
}
}
return
nullptr
;
}
static
void
UpdateOldAnimationPropertiesWithNew
(
CSSAnimation
&
aOld
TimingParams
&
aNewTiming
nsTArray
<
Keyframe
>
&
aNewKeyframes
bool
aNewIsStylePaused
nsStyleContext
*
aStyleContext
)
{
bool
animationChanged
=
false
;
if
(
aOld
.
GetEffect
(
)
)
{
KeyframeEffectReadOnly
*
oldEffect
=
aOld
.
GetEffect
(
)
;
animationChanged
=
oldEffect
-
>
SpecifiedTiming
(
)
!
=
aNewTiming
;
oldEffect
-
>
SetSpecifiedTiming
(
aNewTiming
)
;
oldEffect
-
>
SetKeyframes
(
Move
(
aNewKeyframes
)
aStyleContext
)
;
}
if
(
aOld
.
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
if
(
!
aOld
.
IsStylePaused
(
)
&
&
aNewIsStylePaused
)
{
aOld
.
PauseFromStyle
(
)
;
animationChanged
=
true
;
}
else
if
(
aOld
.
IsStylePaused
(
)
&
&
!
aNewIsStylePaused
)
{
aOld
.
PlayFromStyle
(
)
;
animationChanged
=
true
;
}
}
if
(
animationChanged
&
&
aOld
.
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
&
aOld
)
;
}
}
void
nsAnimationManager
:
:
UpdateAnimations
(
nsStyleContext
*
aStyleContext
mozilla
:
:
dom
:
:
Element
*
aElement
)
{
MOZ_ASSERT
(
mPresContext
-
>
IsDynamic
(
)
"
Should
not
update
animations
for
print
or
print
preview
"
)
;
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
"
Should
not
update
animations
that
are
not
attached
to
the
"
"
document
tree
"
)
;
const
nsStyleDisplay
*
disp
=
aStyleContext
-
>
StyleDisplay
(
)
;
CSSAnimationCollection
*
collection
=
CSSAnimationCollection
:
:
GetAnimationCollection
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
)
;
if
(
!
collection
&
&
disp
-
>
mAnimationNameCount
=
=
1
&
&
disp
-
>
mAnimations
[
0
]
.
GetName
(
)
.
IsEmpty
(
)
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aElement
-
>
OwnerDoc
(
)
)
;
OwningCSSAnimationPtrArray
newAnimations
;
if
(
!
aStyleContext
-
>
IsInDisplayNoneSubtree
(
)
)
{
BuildAnimations
(
aStyleContext
aElement
collection
newAnimations
)
;
}
if
(
newAnimations
.
IsEmpty
(
)
)
{
if
(
collection
)
{
collection
-
>
Destroy
(
)
;
}
return
;
}
if
(
collection
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
)
;
if
(
effectSet
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
}
else
{
bool
createdCollection
=
false
;
collection
=
CSSAnimationCollection
:
:
GetOrCreateAnimationCollection
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
&
createdCollection
)
;
if
(
!
collection
)
{
MOZ_ASSERT
(
!
createdCollection
"
outparam
should
agree
with
return
value
"
)
;
NS_WARNING
(
"
allocating
collection
failed
"
)
;
return
;
}
if
(
createdCollection
)
{
AddElementCollection
(
collection
)
;
}
}
collection
-
>
mAnimations
.
SwapElements
(
newAnimations
)
;
for
(
size_t
newAnimIdx
=
newAnimations
.
Length
(
)
;
newAnimIdx
-
-
!
=
0
;
)
{
newAnimations
[
newAnimIdx
]
-
>
CancelFromStyle
(
)
;
}
EffectCompositor
:
:
UpdateCascadeResults
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
aStyleContext
)
;
mPresContext
-
>
EffectCompositor
(
)
-
>
MaybeUpdateAnimationRule
(
aElement
aStyleContext
-
>
GetPseudoType
(
)
EffectCompositor
:
:
CascadeLevel
:
:
Animations
)
;
if
(
mEventDispatcher
.
HasQueuedEvents
(
)
)
{
mPresContext
-
>
Document
(
)
-
>
SetNeedStyleFlush
(
)
;
}
}
void
nsAnimationManager
:
:
StopAnimationsForElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
CSSPseudoElementType
aPseudoType
)
{
MOZ_ASSERT
(
aElement
)
;
CSSAnimationCollection
*
collection
=
CSSAnimationCollection
:
:
GetAnimationCollection
(
aElement
aPseudoType
)
;
if
(
!
collection
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aElement
-
>
OwnerDoc
(
)
)
;
collection
-
>
Destroy
(
)
;
}
class
ResolvedStyleCache
{
public
:
ResolvedStyleCache
(
)
:
mCache
(
)
{
}
nsStyleContext
*
Get
(
nsPresContext
*
aPresContext
nsStyleContext
*
aParentStyleContext
Declaration
*
aKeyframeDeclaration
)
;
private
:
nsRefPtrHashtable
<
nsPtrHashKey
<
Declaration
>
nsStyleContext
>
mCache
;
}
;
nsStyleContext
*
ResolvedStyleCache
:
:
Get
(
nsPresContext
*
aPresContext
nsStyleContext
*
aParentStyleContext
Declaration
*
aKeyframeDeclaration
)
{
nsStyleContext
*
result
=
mCache
.
GetWeak
(
aKeyframeDeclaration
)
;
if
(
!
result
)
{
aKeyframeDeclaration
-
>
SetImmutable
(
)
;
MOZ_ASSERT
(
!
aKeyframeDeclaration
-
>
HasImportantData
(
)
"
Keyframe
rule
has
!
important
data
"
)
;
nsCOMArray
<
nsIStyleRule
>
rules
;
rules
.
AppendObject
(
aKeyframeDeclaration
)
;
MOZ_ASSERT
(
aPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
RefPtr
<
nsStyleContext
>
resultStrong
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleByAddingRules
(
aParentStyleContext
rules
)
;
mCache
.
Put
(
aKeyframeDeclaration
resultStrong
)
;
result
=
resultStrong
;
}
return
result
;
}
class
MOZ_STACK_CLASS
CSSAnimationBuilder
final
{
public
:
CSSAnimationBuilder
(
nsStyleContext
*
aStyleContext
dom
:
:
Element
*
aTarget
nsAnimationManager
:
:
CSSAnimationCollection
*
aCollection
)
:
mStyleContext
(
aStyleContext
)
mTarget
(
aTarget
)
mCollection
(
aCollection
)
{
MOZ_ASSERT
(
aStyleContext
)
;
MOZ_ASSERT
(
aTarget
)
;
mTimeline
=
mTarget
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
;
}
already_AddRefed
<
CSSAnimation
>
Build
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
)
;
private
:
nsTArray
<
Keyframe
>
BuildAnimationFrames
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
)
;
Maybe
<
ComputedTimingFunction
>
GetKeyframeTimingFunction
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
)
;
nsTArray
<
PropertyValuePair
>
GetKeyframePropertyValues
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
nsCSSPropertySet
&
aAnimatedProperties
)
;
void
FillInMissingKeyframeValues
(
nsPresContext
*
aPresContext
nsCSSPropertySet
aAnimatedProperties
nsCSSPropertySet
aPropertiesSetAtStart
nsCSSPropertySet
aPropertiesSetAtEnd
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
;
void
AppendProperty
(
nsPresContext
*
aPresContext
nsCSSProperty
aProperty
nsTArray
<
PropertyValuePair
>
&
aPropertyValues
)
;
nsCSSValue
GetComputedValue
(
nsPresContext
*
aPresContext
nsCSSProperty
aProperty
)
;
static
TimingParams
TimingParamsFrom
(
const
StyleAnimation
&
aStyleAnimation
)
{
TimingParams
timing
;
timing
.
mDuration
.
emplace
(
StickyTimeDuration
:
:
FromMilliseconds
(
aStyleAnimation
.
GetDuration
(
)
)
)
;
timing
.
mDelay
=
TimeDuration
:
:
FromMilliseconds
(
aStyleAnimation
.
GetDelay
(
)
)
;
timing
.
mIterations
=
aStyleAnimation
.
GetIterationCount
(
)
;
MOZ_ASSERT
(
timing
.
mIterations
>
=
0
.
0
&
&
!
IsNaN
(
timing
.
mIterations
)
"
mIterations
should
be
nonnegative
&
finite
as
ensured
by
"
"
CSSParser
"
)
;
timing
.
mDirection
=
aStyleAnimation
.
GetDirection
(
)
;
timing
.
mFill
=
aStyleAnimation
.
GetFillMode
(
)
;
return
timing
;
}
RefPtr
<
nsStyleContext
>
mStyleContext
;
RefPtr
<
dom
:
:
Element
>
mTarget
;
RefPtr
<
dom
:
:
DocumentTimeline
>
mTimeline
;
ResolvedStyleCache
mResolvedStyles
;
RefPtr
<
nsStyleContext
>
mStyleWithoutAnimation
;
nsAnimationManager
:
:
CSSAnimationCollection
*
mCollection
;
}
;
static
Maybe
<
ComputedTimingFunction
>
ConvertTimingFunction
(
const
nsTimingFunction
&
aTimingFunction
)
;
already_AddRefed
<
CSSAnimation
>
CSSAnimationBuilder
:
:
Build
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
)
{
MOZ_ASSERT
(
aPresContext
)
;
MOZ_ASSERT
(
aRule
)
;
TimingParams
timing
=
TimingParamsFrom
(
aSrc
)
;
nsTArray
<
Keyframe
>
keyframes
=
BuildAnimationFrames
(
aPresContext
aSrc
aRule
)
;
bool
isStylePaused
=
aSrc
.
GetPlayState
(
)
=
=
NS_STYLE_ANIMATION_PLAY_STATE_PAUSED
;
RefPtr
<
CSSAnimation
>
oldAnim
=
PopExistingAnimation
(
aSrc
.
GetName
(
)
mCollection
)
;
if
(
oldAnim
)
{
UpdateOldAnimationPropertiesWithNew
(
*
oldAnim
timing
keyframes
isStylePaused
mStyleContext
)
;
return
oldAnim
.
forget
(
)
;
}
Maybe
<
OwningAnimationTarget
>
target
;
target
.
emplace
(
mTarget
mStyleContext
-
>
GetPseudoType
(
)
)
;
RefPtr
<
KeyframeEffectReadOnly
>
effect
=
new
KeyframeEffectReadOnly
(
aPresContext
-
>
Document
(
)
target
timing
)
;
effect
-
>
SetKeyframes
(
Move
(
keyframes
)
mStyleContext
)
;
RefPtr
<
CSSAnimation
>
animation
=
new
CSSAnimation
(
aPresContext
-
>
Document
(
)
-
>
GetScopeObject
(
)
aSrc
.
GetName
(
)
)
;
animation
-
>
SetOwningElement
(
OwningElementRef
(
*
mTarget
mStyleContext
-
>
GetPseudoType
(
)
)
)
;
animation
-
>
SetTimeline
(
mTimeline
)
;
animation
-
>
SetEffect
(
effect
)
;
if
(
isStylePaused
)
{
animation
-
>
PauseFromStyle
(
)
;
}
else
{
animation
-
>
PlayFromStyle
(
)
;
}
return
animation
.
forget
(
)
;
}
nsTArray
<
Keyframe
>
CSSAnimationBuilder
:
:
BuildAnimationFrames
(
nsPresContext
*
aPresContext
const
StyleAnimation
&
aSrc
const
nsCSSKeyframesRule
*
aRule
)
{
Maybe
<
ComputedTimingFunction
>
inheritedTimingFunction
=
ConvertTimingFunction
(
aSrc
.
GetTimingFunction
(
)
)
;
nsTArray
<
Keyframe
>
keyframes
;
nsCSSPropertySet
animatedProperties
;
for
(
auto
ruleIdx
=
0
ruleEnd
=
aRule
-
>
StyleRuleCount
(
)
;
ruleIdx
!
=
ruleEnd
;
+
+
ruleIdx
)
{
css
:
:
Rule
*
cssRule
=
aRule
-
>
GetStyleRuleAt
(
ruleIdx
)
;
MOZ_ASSERT
(
cssRule
"
must
have
rule
"
)
;
MOZ_ASSERT
(
cssRule
-
>
GetType
(
)
=
=
css
:
:
Rule
:
:
KEYFRAME_RULE
"
must
be
keyframe
rule
"
)
;
nsCSSKeyframeRule
*
keyframeRule
=
static_cast
<
nsCSSKeyframeRule
*
>
(
cssRule
)
;
const
nsTArray
<
float
>
&
keys
=
keyframeRule
-
>
GetKeys
(
)
;
for
(
float
key
:
keys
)
{
if
(
key
<
0
.
0f
|
|
key
>
1
.
0f
)
{
continue
;
}
Keyframe
keyframe
;
keyframe
.
mOffset
.
emplace
(
key
)
;
keyframe
.
mTimingFunction
=
GetKeyframeTimingFunction
(
aPresContext
keyframeRule
inheritedTimingFunction
)
;
keyframe
.
mPropertyValues
=
GetKeyframePropertyValues
(
aPresContext
keyframeRule
animatedProperties
)
;
keyframes
.
AppendElement
(
Move
(
keyframe
)
)
;
}
}
std
:
:
stable_sort
(
keyframes
.
begin
(
)
keyframes
.
end
(
)
[
]
(
const
Keyframe
&
a
const
Keyframe
&
b
)
{
return
a
.
mOffset
<
b
.
mOffset
;
}
)
;
nsCSSPropertySet
propertiesSetAtCurrentOffset
;
nsCSSPropertySet
propertiesSetAtStart
;
nsCSSPropertySet
propertiesSetAtEnd
;
double
currentOffset
=
-
1
.
0
;
for
(
size_t
keyframeIdx
=
keyframes
.
Length
(
)
;
keyframeIdx
>
0
;
-
-
keyframeIdx
)
{
Keyframe
&
keyframe
=
keyframes
[
keyframeIdx
-
1
]
;
MOZ_ASSERT
(
keyframe
.
mOffset
"
Should
have
filled
in
the
offset
"
)
;
if
(
keyframe
.
mOffset
.
value
(
)
!
=
currentOffset
)
{
propertiesSetAtCurrentOffset
.
Empty
(
)
;
currentOffset
=
keyframe
.
mOffset
.
value
(
)
;
}
nsTArray
<
PropertyValuePair
>
uniquePropertyValues
;
uniquePropertyValues
.
SetCapacity
(
keyframe
.
mPropertyValues
.
Length
(
)
)
;
for
(
const
PropertyValuePair
&
pair
:
keyframe
.
mPropertyValues
)
{
if
(
!
propertiesSetAtCurrentOffset
.
HasProperty
(
pair
.
mProperty
)
)
{
uniquePropertyValues
.
AppendElement
(
pair
)
;
propertiesSetAtCurrentOffset
.
AddProperty
(
pair
.
mProperty
)
;
if
(
currentOffset
=
=
0
.
0
)
{
propertiesSetAtStart
.
AddProperty
(
pair
.
mProperty
)
;
}
else
if
(
currentOffset
=
=
1
.
0
)
{
propertiesSetAtEnd
.
AddProperty
(
pair
.
mProperty
)
;
}
}
}
Keyframe
*
existingKeyframe
=
nullptr
;
if
(
!
uniquePropertyValues
.
IsEmpty
(
)
)
{
for
(
size_t
i
=
keyframeIdx
;
i
<
keyframes
.
Length
(
)
;
i
+
+
)
{
Keyframe
&
kf
=
keyframes
[
i
]
;
if
(
kf
.
mOffset
.
value
(
)
!
=
currentOffset
)
{
break
;
}
if
(
kf
.
mTimingFunction
=
=
keyframe
.
mTimingFunction
)
{
existingKeyframe
=
&
kf
;
break
;
}
}
}
if
(
existingKeyframe
)
{
existingKeyframe
-
>
mPropertyValues
.
AppendElements
(
Move
(
uniquePropertyValues
)
)
;
keyframe
.
mPropertyValues
.
Clear
(
)
;
}
else
{
keyframe
.
mPropertyValues
.
SwapElements
(
uniquePropertyValues
)
;
}
if
(
keyframe
.
mPropertyValues
.
IsEmpty
(
)
)
{
keyframes
.
RemoveElementAt
(
keyframeIdx
-
1
)
;
}
}
FillInMissingKeyframeValues
(
aPresContext
animatedProperties
propertiesSetAtStart
propertiesSetAtEnd
inheritedTimingFunction
keyframes
)
;
return
keyframes
;
}
Maybe
<
ComputedTimingFunction
>
CSSAnimationBuilder
:
:
GetKeyframeTimingFunction
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
)
{
Maybe
<
ComputedTimingFunction
>
result
;
if
(
aKeyframeRule
-
>
Declaration
(
)
&
&
aKeyframeRule
-
>
Declaration
(
)
-
>
HasProperty
(
eCSSProperty_animation_timing_function
)
)
{
RefPtr
<
nsStyleContext
>
keyframeRuleContext
=
mResolvedStyles
.
Get
(
aPresContext
mStyleContext
aKeyframeRule
-
>
Declaration
(
)
)
;
const
nsTimingFunction
&
tf
=
keyframeRuleContext
-
>
StyleDisplay
(
)
-
>
mAnimations
[
0
]
.
GetTimingFunction
(
)
;
result
=
ConvertTimingFunction
(
tf
)
;
}
else
{
result
=
aInheritedTimingFunction
;
}
return
result
;
}
static
Maybe
<
ComputedTimingFunction
>
ConvertTimingFunction
(
const
nsTimingFunction
&
aTimingFunction
)
{
Maybe
<
ComputedTimingFunction
>
result
;
if
(
aTimingFunction
.
mType
!
=
nsTimingFunction
:
:
Type
:
:
Linear
)
{
result
.
emplace
(
)
;
result
-
>
Init
(
aTimingFunction
)
;
}
return
result
;
}
nsTArray
<
PropertyValuePair
>
CSSAnimationBuilder
:
:
GetKeyframePropertyValues
(
nsPresContext
*
aPresContext
nsCSSKeyframeRule
*
aKeyframeRule
nsCSSPropertySet
&
aAnimatedProperties
)
{
nsTArray
<
PropertyValuePair
>
result
;
RefPtr
<
nsStyleContext
>
styleContext
=
mResolvedStyles
.
Get
(
aPresContext
mStyleContext
aKeyframeRule
-
>
Declaration
(
)
)
;
for
(
nsCSSProperty
prop
=
nsCSSProperty
(
0
)
;
prop
<
eCSSProperty_COUNT_no_shorthands
;
prop
=
nsCSSProperty
(
prop
+
1
)
)
{
if
(
nsCSSProps
:
:
kAnimTypeTable
[
prop
]
=
=
eStyleAnimType_None
|
|
!
aKeyframeRule
-
>
Declaration
(
)
-
>
HasNonImportantValueFor
(
prop
)
)
{
continue
;
}
PropertyValuePair
pair
;
pair
.
mProperty
=
prop
;
StyleAnimationValue
computedValue
;
if
(
!
StyleAnimationValue
:
:
ExtractComputedValue
(
prop
styleContext
computedValue
)
)
{
continue
;
}
DebugOnly
<
bool
>
uncomputeResult
=
StyleAnimationValue
:
:
UncomputeValue
(
prop
Move
(
computedValue
)
pair
.
mValue
)
;
MOZ_ASSERT
(
uncomputeResult
"
Unable
to
get
specified
value
from
computed
value
"
)
;
MOZ_ASSERT
(
pair
.
mValue
.
GetUnit
(
)
!
=
eCSSUnit_Null
"
Not
expecting
to
read
invalid
properties
"
)
;
result
.
AppendElement
(
Move
(
pair
)
)
;
aAnimatedProperties
.
AddProperty
(
prop
)
;
}
return
result
;
}
template
<
class
IterType
>
static
bool
FindMatchingKeyframe
(
IterType
&
&
aIter
double
aOffset
const
Maybe
<
ComputedTimingFunction
>
&
aTimingFunctionToMatch
size_t
&
aIndex
)
{
aIndex
=
0
;
for
(
Keyframe
&
keyframe
:
aIter
)
{
if
(
keyframe
.
mOffset
.
value
(
)
!
=
aOffset
)
{
break
;
}
if
(
keyframe
.
mTimingFunction
=
=
aTimingFunctionToMatch
)
{
return
true
;
}
+
+
aIndex
;
}
return
false
;
}
void
CSSAnimationBuilder
:
:
FillInMissingKeyframeValues
(
nsPresContext
*
aPresContext
nsCSSPropertySet
aAnimatedProperties
nsCSSPropertySet
aPropertiesSetAtStart
nsCSSPropertySet
aPropertiesSetAtEnd
const
Maybe
<
ComputedTimingFunction
>
&
aInheritedTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
static
const
size_t
kNotSet
=
static_cast
<
size_t
>
(
-
1
)
;
size_t
startKeyframeIndex
=
kNotSet
;
if
(
!
aAnimatedProperties
.
Equals
(
aPropertiesSetAtStart
)
&
&
!
FindMatchingKeyframe
(
aKeyframes
0
.
0
aInheritedTimingFunction
startKeyframeIndex
)
)
{
Keyframe
newKeyframe
;
newKeyframe
.
mOffset
.
emplace
(
0
.
0
)
;
newKeyframe
.
mTimingFunction
=
aInheritedTimingFunction
;
aKeyframes
.
InsertElementAt
(
startKeyframeIndex
Move
(
newKeyframe
)
)
;
}
size_t
endKeyframeIndex
=
kNotSet
;
if
(
!
aAnimatedProperties
.
Equals
(
aPropertiesSetAtEnd
)
)
{
if
(
!
FindMatchingKeyframe
(
Reversed
(
aKeyframes
)
1
.
0
aInheritedTimingFunction
endKeyframeIndex
)
)
{
Keyframe
newKeyframe
;
newKeyframe
.
mOffset
.
emplace
(
1
.
0
)
;
newKeyframe
.
mTimingFunction
=
aInheritedTimingFunction
;
aKeyframes
.
AppendElement
(
Move
(
newKeyframe
)
)
;
endKeyframeIndex
=
aKeyframes
.
Length
(
)
-
1
;
}
else
{
endKeyframeIndex
=
aKeyframes
.
Length
(
)
-
1
-
endKeyframeIndex
;
}
}
if
(
startKeyframeIndex
=
=
kNotSet
&
&
endKeyframeIndex
=
=
kNotSet
)
{
return
;
}
Keyframe
*
startKeyframe
=
startKeyframeIndex
=
=
kNotSet
?
nullptr
:
&
aKeyframes
[
startKeyframeIndex
]
;
Keyframe
*
endKeyframe
=
endKeyframeIndex
=
=
kNotSet
?
nullptr
:
&
aKeyframes
[
endKeyframeIndex
]
;
for
(
nsCSSProperty
prop
=
nsCSSProperty
(
0
)
;
prop
<
eCSSProperty_COUNT_no_shorthands
;
prop
=
nsCSSProperty
(
prop
+
1
)
)
{
if
(
!
aAnimatedProperties
.
HasProperty
(
prop
)
)
{
continue
;
}
if
(
startKeyframe
&
&
!
aPropertiesSetAtStart
.
HasProperty
(
prop
)
)
{
AppendProperty
(
aPresContext
prop
startKeyframe
-
>
mPropertyValues
)
;
}
if
(
endKeyframe
&
&
!
aPropertiesSetAtEnd
.
HasProperty
(
prop
)
)
{
AppendProperty
(
aPresContext
prop
endKeyframe
-
>
mPropertyValues
)
;
}
}
}
void
CSSAnimationBuilder
:
:
AppendProperty
(
nsPresContext
*
aPresContext
nsCSSProperty
aProperty
nsTArray
<
PropertyValuePair
>
&
aPropertyValues
)
{
PropertyValuePair
propertyValue
;
propertyValue
.
mProperty
=
aProperty
;
propertyValue
.
mValue
=
GetComputedValue
(
aPresContext
aProperty
)
;
aPropertyValues
.
AppendElement
(
Move
(
propertyValue
)
)
;
}
nsCSSValue
CSSAnimationBuilder
:
:
GetComputedValue
(
nsPresContext
*
aPresContext
nsCSSProperty
aProperty
)
{
nsCSSValue
result
;
StyleAnimationValue
computedValue
;
if
(
!
mStyleWithoutAnimation
)
{
MOZ_ASSERT
(
aPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
mStyleWithoutAnimation
=
aPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleWithoutAnimation
(
mTarget
mStyleContext
eRestyle_AllHintsWithAnimations
)
;
}
if
(
StyleAnimationValue
:
:
ExtractComputedValue
(
aProperty
mStyleWithoutAnimation
computedValue
)
)
{
StyleAnimationValue
:
:
UncomputeValue
(
aProperty
Move
(
computedValue
)
result
)
;
}
MOZ_ASSERT
(
result
.
GetUnit
(
)
!
=
eCSSUnit_Null
"
Got
null
computed
value
"
)
;
return
result
;
}
void
nsAnimationManager
:
:
BuildAnimations
(
nsStyleContext
*
aStyleContext
dom
:
:
Element
*
aTarget
CSSAnimationCollection
*
aCollection
OwningCSSAnimationPtrArray
&
aAnimations
)
{
MOZ_ASSERT
(
aAnimations
.
IsEmpty
(
)
"
expect
empty
array
"
)
;
const
nsStyleDisplay
*
disp
=
aStyleContext
-
>
StyleDisplay
(
)
;
CSSAnimationBuilder
builder
(
aStyleContext
aTarget
aCollection
)
;
for
(
size_t
animIdx
=
disp
-
>
mAnimationNameCount
;
animIdx
-
-
!
=
0
;
)
{
const
StyleAnimation
&
src
=
disp
-
>
mAnimations
[
animIdx
]
;
MOZ_ASSERT
(
mPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSet
should
not
use
nsAnimationManager
for
"
"
animations
"
)
;
nsCSSKeyframesRule
*
rule
=
src
.
GetName
(
)
.
IsEmpty
(
)
?
nullptr
:
mPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
KeyframesRuleForName
(
src
.
GetName
(
)
)
;
if
(
!
rule
)
{
continue
;
}
RefPtr
<
CSSAnimation
>
dest
=
builder
.
Build
(
mPresContext
src
rule
)
;
dest
-
>
SetAnimationIndex
(
static_cast
<
uint64_t
>
(
animIdx
)
)
;
aAnimations
.
AppendElement
(
dest
)
;
}
}
