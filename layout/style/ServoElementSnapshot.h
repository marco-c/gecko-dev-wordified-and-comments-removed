#
ifndef
mozilla_ServoElementSnapshot_h
#
define
mozilla_ServoElementSnapshot_h
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsIAtom
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Element
;
}
struct
ServoAttrSnapshot
{
nsAttrName
mName
;
nsAttrValue
mValue
;
ServoAttrSnapshot
(
const
nsAttrName
&
aName
const
nsAttrValue
&
aValue
)
:
mName
(
aName
)
mValue
(
aValue
)
{
}
}
;
enum
class
ServoElementSnapshotFlags
:
uint8_t
{
State
=
1
<
<
0
Attributes
=
1
<
<
1
HTMLElementInHTMLDocument
=
1
<
<
2
All
=
State
|
Attributes
|
HTMLElementInHTMLDocument
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
ServoElementSnapshotFlags
)
class
ServoElementSnapshot
{
typedef
dom
:
:
Element
Element
;
typedef
EventStates
:
:
ServoType
ServoStateType
;
public
:
typedef
ServoElementSnapshotFlags
Flags
;
ServoElementSnapshot
(
)
:
mContains
(
Flags
(
0
)
)
mState
(
0
)
mExplicitRestyleHint
(
nsRestyleHint
(
0
)
)
mExplicitChangeHint
(
nsChangeHint
(
0
)
)
mIsHTMLElementInHTMLDocument
(
false
)
{
}
bool
HasAttrs
(
)
{
return
HasAny
(
Flags
:
:
Attributes
)
;
}
bool
HasState
(
)
{
return
HasAny
(
Flags
:
:
State
)
;
}
void
AddState
(
EventStates
aState
)
{
if
(
!
HasAny
(
Flags
:
:
State
)
)
{
mState
=
aState
.
ServoValue
(
)
;
mContains
|
=
Flags
:
:
State
;
}
}
void
AddAttrs
(
Element
*
aElement
)
;
void
AddExplicitChangeHint
(
nsChangeHint
aMinChangeHint
)
{
mExplicitChangeHint
|
=
aMinChangeHint
;
}
void
AddExplicitRestyleHint
(
nsRestyleHint
aRestyleHint
)
{
mExplicitRestyleHint
|
=
aRestyleHint
;
}
nsRestyleHint
ExplicitRestyleHint
(
)
{
return
mExplicitRestyleHint
;
}
nsChangeHint
ExplicitChangeHint
(
)
{
return
mExplicitChangeHint
;
}
const
nsAttrName
*
GetAttrNameAt
(
uint32_t
aIndex
)
const
{
if
(
aIndex
>
=
mAttrs
.
Length
(
)
)
{
return
nullptr
;
}
return
&
mAttrs
[
aIndex
]
.
mName
;
}
const
nsAttrValue
*
GetParsedAttr
(
nsIAtom
*
aLocalName
)
const
{
return
GetParsedAttr
(
aLocalName
kNameSpaceID_None
)
;
}
const
nsAttrValue
*
GetParsedAttr
(
nsIAtom
*
aLocalName
int32_t
aNamespaceID
)
const
{
uint32_t
i
len
=
mAttrs
.
Length
(
)
;
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
for
(
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
mAttrs
[
i
]
.
mName
.
Equals
(
aLocalName
)
)
{
return
&
mAttrs
[
i
]
.
mValue
;
}
}
return
nullptr
;
}
for
(
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
mAttrs
[
i
]
.
mName
.
Equals
(
aLocalName
aNamespaceID
)
)
{
return
&
mAttrs
[
i
]
.
mValue
;
}
}
return
nullptr
;
}
void
SetIsHTMLElementInHTMLDocument
(
bool
aIs
)
{
MOZ_ASSERT
(
!
HasAny
(
Flags
:
:
HTMLElementInHTMLDocument
)
"
Only
expected
to
be
set
once
!
"
)
;
mContains
|
=
Flags
:
:
HTMLElementInHTMLDocument
;
mIsHTMLElementInHTMLDocument
=
aIs
;
}
bool
HasAny
(
Flags
aFlags
)
{
return
bool
(
mContains
&
aFlags
)
;
}
private
:
Flags
mContains
;
nsTArray
<
ServoAttrSnapshot
>
mAttrs
;
ServoStateType
mState
;
nsRestyleHint
mExplicitRestyleHint
;
nsChangeHint
mExplicitChangeHint
;
bool
mIsHTMLElementInHTMLDocument
;
}
;
}
#
endif
