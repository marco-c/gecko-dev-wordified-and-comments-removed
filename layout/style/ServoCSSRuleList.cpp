#
include
"
mozilla
/
ServoCSSRuleList
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleRule
.
h
"
namespace
mozilla
{
ServoCSSRuleList
:
:
ServoCSSRuleList
(
ServoStyleSheet
*
aStyleSheet
already_AddRefed
<
ServoCssRules
>
aRawRules
)
:
mStyleSheet
(
aStyleSheet
)
mRawRules
(
aRawRules
)
{
Servo_CssRules_ListTypes
(
mRawRules
&
mRules
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
ServoCSSRuleList
)
NS_INTERFACE_MAP_END_INHERITING
(
dom
:
:
CSSRuleList
)
NS_IMPL_ADDREF_INHERITED
(
ServoCSSRuleList
dom
:
:
CSSRuleList
)
NS_IMPL_RELEASE_INHERITED
(
ServoCSSRuleList
dom
:
:
CSSRuleList
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ServoCSSRuleList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ServoCSSRuleList
)
for
(
uintptr_t
&
rule
:
tmp
-
>
mRules
)
{
if
(
rule
>
kMaxRuleType
)
{
CastToPtr
(
rule
)
-
>
Release
(
)
;
rule
=
0
;
}
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END_INHERITED
(
dom
:
:
CSSRuleList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ServoCSSRuleList
dom
:
:
CSSRuleList
)
tmp
-
>
EnumerateInstantiatedRules
(
[
&
]
(
css
:
:
Rule
*
aRule
)
{
if
(
!
aRule
-
>
IsCCLeaf
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mRules
[
i
]
"
)
;
cb
.
NoteXPCOMChild
(
aRule
)
;
}
}
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
css
:
:
Rule
*
ServoCSSRuleList
:
:
GetRule
(
uint32_t
aIndex
)
{
uintptr_t
rule
=
mRules
[
aIndex
]
;
if
(
rule
<
=
kMaxRuleType
)
{
RefPtr
<
css
:
:
Rule
>
ruleObj
=
nullptr
;
switch
(
rule
)
{
case
nsIDOMCSSRule
:
:
STYLE_RULE
:
{
ruleObj
=
new
ServoStyleRule
(
Servo_CssRules_GetStyleRuleAt
(
mRawRules
aIndex
)
.
Consume
(
)
)
;
break
;
}
case
nsIDOMCSSRule
:
:
MEDIA_RULE
:
case
nsIDOMCSSRule
:
:
FONT_FACE_RULE
:
case
nsIDOMCSSRule
:
:
KEYFRAMES_RULE
:
case
nsIDOMCSSRule
:
:
NAMESPACE_RULE
:
default
:
NS_WARNING
(
"
stylo
:
not
implemented
yet
"
)
;
return
nullptr
;
}
ruleObj
-
>
SetStyleSheet
(
mStyleSheet
)
;
rule
=
CastToUint
(
ruleObj
.
forget
(
)
.
take
(
)
)
;
mRules
[
aIndex
]
=
rule
;
}
return
CastToPtr
(
rule
)
;
}
css
:
:
Rule
*
ServoCSSRuleList
:
:
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
{
if
(
aIndex
>
=
mRules
.
Length
(
)
)
{
aFound
=
false
;
return
nullptr
;
}
aFound
=
true
;
return
GetRule
(
aIndex
)
;
}
template
<
typename
Func
>
void
ServoCSSRuleList
:
:
EnumerateInstantiatedRules
(
Func
aCallback
)
{
for
(
uintptr_t
rule
:
mRules
)
{
if
(
rule
>
kMaxRuleType
)
{
aCallback
(
CastToPtr
(
rule
)
)
;
}
}
}
void
ServoCSSRuleList
:
:
DropReference
(
)
{
mStyleSheet
=
nullptr
;
EnumerateInstantiatedRules
(
[
]
(
css
:
:
Rule
*
rule
)
{
rule
-
>
SetStyleSheet
(
nullptr
)
;
}
)
;
}
nsresult
ServoCSSRuleList
:
:
InsertRule
(
const
nsAString
&
aRule
uint32_t
aIndex
)
{
NS_ConvertUTF16toUTF8
rule
(
aRule
)
;
bool
nested
=
false
;
uint16_t
type
;
nsresult
rv
=
Servo_CssRules_InsertRule
(
mRawRules
mStyleSheet
-
>
RawSheet
(
)
&
rule
aIndex
nested
&
type
)
;
if
(
!
NS_FAILED
(
rv
)
)
{
mRules
.
InsertElementAt
(
aIndex
type
)
;
}
return
rv
;
}
nsresult
ServoCSSRuleList
:
:
DeleteRule
(
uint32_t
aIndex
)
{
nsresult
rv
=
Servo_CssRules_DeleteRule
(
mRawRules
aIndex
)
;
if
(
!
NS_FAILED
(
rv
)
)
{
uintptr_t
rule
=
mRules
[
aIndex
]
;
if
(
rule
>
kMaxRuleType
)
{
CastToPtr
(
rule
)
-
>
Release
(
)
;
}
mRules
.
RemoveElementAt
(
aIndex
)
;
}
return
rv
;
}
ServoCSSRuleList
:
:
~
ServoCSSRuleList
(
)
{
EnumerateInstantiatedRules
(
[
]
(
css
:
:
Rule
*
rule
)
{
rule
-
>
Release
(
)
;
}
)
;
}
}
