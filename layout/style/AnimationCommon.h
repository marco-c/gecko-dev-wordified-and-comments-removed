#
ifndef
mozilla_css_AnimationCommon_h
#
define
mozilla_css_AnimationCommon_h
#
include
<
algorithm
>
#
include
"
mozilla
/
AnimationCollection
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSProperty
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
class
nsIFrame
;
class
nsPresContext
;
namespace
mozilla
{
namespace
dom
{
class
Element
;
}
template
<
class
AnimationType
>
class
CommonAnimationManager
{
public
:
explicit
CommonAnimationManager
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
{
}
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
void
Disconnect
(
)
{
RemoveAllElementCollections
(
)
;
mPresContext
=
nullptr
;
}
static
bool
ExtractComputedValueForTransition
(
nsCSSProperty
aProperty
nsStyleContext
*
aStyleContext
StyleAnimationValue
&
aComputedValue
)
;
protected
:
virtual
~
CommonAnimationManager
(
)
{
MOZ_ASSERT
(
!
mPresContext
"
Disconnect
should
have
been
called
"
)
;
}
void
AddElementCollection
(
AnimationCollection
<
AnimationType
>
*
aCollection
)
{
mElementCollections
.
insertBack
(
aCollection
)
;
}
void
RemoveAllElementCollections
(
)
{
while
(
AnimationCollection
<
AnimationType
>
*
head
=
mElementCollections
.
getFirst
(
)
)
{
head
-
>
Destroy
(
)
;
}
}
virtual
nsIAtom
*
GetAnimationsAtom
(
)
=
0
;
virtual
nsIAtom
*
GetAnimationsBeforeAtom
(
)
=
0
;
virtual
nsIAtom
*
GetAnimationsAfterAtom
(
)
=
0
;
public
:
AnimationCollection
<
AnimationType
>
*
GetAnimationCollection
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
bool
aCreateIfNeeded
)
;
AnimationCollection
<
AnimationType
>
*
GetAnimationCollection
(
const
nsIFrame
*
aFrame
)
;
protected
:
LinkedList
<
AnimationCollection
<
AnimationType
>
>
mElementCollections
;
nsPresContext
*
mPresContext
;
}
;
template
<
class
AnimationType
>
AnimationCollection
<
AnimationType
>
*
CommonAnimationManager
<
AnimationType
>
:
:
GetAnimationCollection
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
bool
aCreateIfNeeded
)
{
if
(
!
aCreateIfNeeded
&
&
!
aElement
-
>
MayHaveAnimations
(
)
)
{
return
nullptr
;
}
nsIAtom
*
propName
;
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
propName
=
GetAnimationsAtom
(
)
;
}
else
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
propName
=
GetAnimationsBeforeAtom
(
)
;
}
else
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
propName
=
GetAnimationsAfterAtom
(
)
;
}
else
{
NS_ASSERTION
(
!
aCreateIfNeeded
"
should
never
try
to
create
transitions
for
pseudo
"
"
other
than
:
before
or
:
after
"
)
;
return
nullptr
;
}
AnimationCollection
<
AnimationType
>
*
collection
=
static_cast
<
AnimationCollection
<
AnimationType
>
*
>
(
aElement
-
>
GetProperty
(
propName
)
)
;
if
(
!
collection
&
&
aCreateIfNeeded
)
{
collection
=
new
AnimationCollection
<
AnimationType
>
(
aElement
propName
)
;
nsresult
rv
=
aElement
-
>
SetProperty
(
propName
collection
&
AnimationCollection
<
AnimationType
>
:
:
PropertyDtor
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SetProperty
failed
"
)
;
AnimationCollection
<
AnimationType
>
:
:
PropertyDtor
(
aElement
propName
collection
nullptr
)
;
return
nullptr
;
}
aElement
-
>
SetMayHaveAnimations
(
)
;
AddElementCollection
(
collection
)
;
}
return
collection
;
}
template
<
class
AnimationType
>
AnimationCollection
<
AnimationType
>
*
CommonAnimationManager
<
AnimationType
>
:
:
GetAnimationCollection
(
const
nsIFrame
*
aFrame
)
{
Maybe
<
Pair
<
dom
:
:
Element
*
CSSPseudoElementType
>
>
pseudoElement
=
EffectCompositor
:
:
GetAnimationElementAndPseudoForFrame
(
aFrame
)
;
if
(
!
pseudoElement
)
{
return
nullptr
;
}
if
(
!
pseudoElement
-
>
first
(
)
-
>
MayHaveAnimations
(
)
)
{
return
nullptr
;
}
return
GetAnimationCollection
(
pseudoElement
-
>
first
(
)
pseudoElement
-
>
second
(
)
false
)
;
}
template
<
class
AnimationType
>
bool
CommonAnimationManager
<
AnimationType
>
:
:
ExtractComputedValueForTransition
(
nsCSSProperty
aProperty
nsStyleContext
*
aStyleContext
StyleAnimationValue
&
aComputedValue
)
{
bool
result
=
StyleAnimationValue
:
:
ExtractComputedValue
(
aProperty
aStyleContext
aComputedValue
)
;
if
(
aProperty
=
=
eCSSProperty_visibility
)
{
MOZ_ASSERT
(
aComputedValue
.
GetUnit
(
)
=
=
StyleAnimationValue
:
:
eUnit_Enumerated
"
unexpected
unit
"
)
;
aComputedValue
.
SetIntValue
(
aComputedValue
.
GetIntValue
(
)
StyleAnimationValue
:
:
eUnit_Visibility
)
;
}
return
result
;
}
class
OwningElementRef
final
{
public
:
OwningElementRef
(
)
:
mElement
(
nullptr
)
mPseudoType
(
CSSPseudoElementType
:
:
NotPseudo
)
{
}
OwningElementRef
(
dom
:
:
Element
&
aElement
CSSPseudoElementType
aPseudoType
)
:
mElement
(
&
aElement
)
mPseudoType
(
aPseudoType
)
{
}
bool
Equals
(
const
OwningElementRef
&
aOther
)
const
{
return
mElement
=
=
aOther
.
mElement
&
&
mPseudoType
=
=
aOther
.
mPseudoType
;
}
bool
LessThan
(
const
OwningElementRef
&
aOther
)
const
{
MOZ_ASSERT
(
mElement
&
&
aOther
.
mElement
"
Elements
to
compare
should
not
be
null
"
)
;
if
(
mElement
!
=
aOther
.
mElement
)
{
return
nsContentUtils
:
:
PositionIsBefore
(
mElement
aOther
.
mElement
)
;
}
return
mPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
|
|
(
mPseudoType
=
=
CSSPseudoElementType
:
:
before
&
&
aOther
.
mPseudoType
=
=
CSSPseudoElementType
:
:
after
)
;
}
bool
IsSet
(
)
const
{
return
!
!
mElement
;
}
void
GetElement
(
dom
:
:
Element
*
&
aElement
CSSPseudoElementType
&
aPseudoType
)
const
{
aElement
=
mElement
;
aPseudoType
=
mPseudoType
;
}
nsPresContext
*
GetRenderedPresContext
(
)
const
;
private
:
dom
:
:
Element
*
MOZ_NON_OWNING_REF
mElement
;
CSSPseudoElementType
mPseudoType
;
}
;
template
<
class
EventInfo
>
class
DelayedEventDispatcher
{
public
:
DelayedEventDispatcher
(
)
:
mIsSorted
(
true
)
{
}
void
QueueEvent
(
EventInfo
&
&
aEventInfo
)
{
mPendingEvents
.
AppendElement
(
Forward
<
EventInfo
>
(
aEventInfo
)
)
;
mIsSorted
=
false
;
}
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
std
:
:
stable_sort
(
mPendingEvents
.
begin
(
)
mPendingEvents
.
end
(
)
EventInfoLessThan
(
)
)
;
mIsSorted
=
true
;
}
void
DispatchEvents
(
nsPresContext
*
const
&
aPresContext
)
{
if
(
!
aPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
;
mPendingEvents
.
SwapElements
(
events
)
;
for
(
EventInfo
&
info
:
events
)
{
EventDispatcher
:
:
Dispatch
(
info
.
mElement
aPresContext
&
info
.
mEvent
)
;
if
(
!
aPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
const
char
*
aName
)
{
for
(
EventInfo
&
info
:
mPendingEvents
)
{
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mElement
aName
)
;
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mAnimation
aName
)
;
}
}
void
Unlink
(
)
{
ClearEventQueue
(
)
;
}
protected
:
class
EventInfoLessThan
{
public
:
bool
operator
(
)
(
const
EventInfo
&
a
const
EventInfo
&
b
)
const
{
if
(
a
.
mTimeStamp
!
=
b
.
mTimeStamp
)
{
if
(
a
.
mTimeStamp
.
IsNull
(
)
|
|
b
.
mTimeStamp
.
IsNull
(
)
)
{
return
a
.
mTimeStamp
.
IsNull
(
)
;
}
else
{
return
a
.
mTimeStamp
<
b
.
mTimeStamp
;
}
}
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
comparator
;
return
comparator
.
LessThan
(
a
.
mAnimation
b
.
mAnimation
)
;
}
}
;
typedef
nsTArray
<
EventInfo
>
EventArray
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
}
;
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionUnlink
(
DelayedEventDispatcher
<
EventInfo
>
&
aField
)
{
aField
.
Unlink
(
)
;
}
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
DelayedEventDispatcher
<
EventInfo
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aField
.
Traverse
(
&
aCallback
aName
)
;
}
}
#
endif
