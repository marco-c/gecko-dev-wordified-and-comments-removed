#
ifndef
mozilla_css_AnimationCommon_h
#
define
mozilla_css_AnimationCommon_h
#
include
"
mozilla
/
AnimationCollection
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
nsContentUtils
.
h
"
class
nsPresContext
;
namespace
mozilla
{
enum
class
PseudoStyleType
:
uint8_t
;
namespace
dom
{
class
Element
;
}
template
<
class
AnimationType
>
class
CommonAnimationManager
{
public
:
explicit
CommonAnimationManager
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
{
}
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
void
Disconnect
(
)
{
RemoveAllElementCollections
(
)
;
mPresContext
=
nullptr
;
}
void
StopAnimationsForElement
(
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
MOZ_ASSERT
(
aElement
)
;
AnimationCollection
<
AnimationType
>
*
collection
=
AnimationCollection
<
AnimationType
>
:
:
GetAnimationCollection
(
aElement
aPseudoType
)
;
if
(
!
collection
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aElement
-
>
OwnerDoc
(
)
)
;
collection
-
>
Destroy
(
)
;
}
protected
:
virtual
~
CommonAnimationManager
(
)
{
MOZ_ASSERT
(
!
mPresContext
"
Disconnect
should
have
been
called
"
)
;
}
void
AddElementCollection
(
AnimationCollection
<
AnimationType
>
*
aCollection
)
{
mElementCollections
.
insertBack
(
aCollection
)
;
}
void
RemoveAllElementCollections
(
)
{
while
(
AnimationCollection
<
AnimationType
>
*
head
=
mElementCollections
.
getFirst
(
)
)
{
head
-
>
Destroy
(
)
;
}
}
LinkedList
<
AnimationCollection
<
AnimationType
>
>
mElementCollections
;
nsPresContext
*
mPresContext
;
}
;
class
OwningElementRef
final
{
public
:
OwningElementRef
(
)
=
default
;
explicit
OwningElementRef
(
const
NonOwningAnimationTarget
&
aTarget
)
:
mTarget
(
aTarget
)
{
}
OwningElementRef
(
dom
:
:
Element
&
aElement
PseudoStyleType
aPseudoType
)
:
mTarget
(
&
aElement
aPseudoType
)
{
}
bool
Equals
(
const
OwningElementRef
&
aOther
)
const
{
return
mTarget
=
=
aOther
.
mTarget
;
}
bool
LessThan
(
int32_t
&
aChildIndex
const
OwningElementRef
&
aOther
int32_t
&
aOtherChildIndex
)
const
{
MOZ_ASSERT
(
mTarget
.
mElement
&
&
aOther
.
mTarget
.
mElement
"
Elements
to
compare
should
not
be
null
"
)
;
if
(
mTarget
.
mElement
!
=
aOther
.
mTarget
.
mElement
)
{
return
nsContentUtils
:
:
PositionIsBefore
(
mTarget
.
mElement
aOther
.
mTarget
.
mElement
&
aChildIndex
&
aOtherChildIndex
)
;
}
return
mTarget
.
mPseudoType
=
=
PseudoStyleType
:
:
NotPseudo
|
|
(
mTarget
.
mPseudoType
=
=
PseudoStyleType
:
:
before
&
&
aOther
.
mTarget
.
mPseudoType
=
=
PseudoStyleType
:
:
after
)
;
}
bool
IsSet
(
)
const
{
return
!
!
mTarget
.
mElement
;
}
void
GetElement
(
dom
:
:
Element
*
&
aElement
PseudoStyleType
&
aPseudoType
)
const
{
aElement
=
mTarget
.
mElement
;
aPseudoType
=
mTarget
.
mPseudoType
;
}
const
NonOwningAnimationTarget
&
Target
(
)
const
{
return
mTarget
;
}
nsPresContext
*
GetPresContext
(
)
const
{
return
nsContentUtils
:
:
GetContextForContent
(
mTarget
.
mElement
)
;
}
private
:
NonOwningAnimationTarget
mTarget
;
}
;
template
<
typename
PhaseType
>
PhaseType
GetAnimationPhaseWithoutEffect
(
const
dom
:
:
Animation
&
aAnimation
)
{
MOZ_ASSERT
(
!
aAnimation
.
GetEffect
(
)
"
Should
only
be
called
when
we
do
not
have
an
effect
"
)
;
dom
:
:
Nullable
<
TimeDuration
>
currentTime
=
aAnimation
.
GetCurrentTimeAsDuration
(
)
;
if
(
currentTime
.
IsNull
(
)
)
{
return
PhaseType
:
:
Idle
;
}
return
currentTime
.
Value
(
)
<
TimeDuration
(
)
?
PhaseType
:
:
Before
:
PhaseType
:
:
After
;
}
;
inline
TimingParams
TimingParamsFromCSSParams
(
float
aDuration
float
aDelay
float
aIterationCount
dom
:
:
PlaybackDirection
aDirection
dom
:
:
FillMode
aFillMode
)
{
MOZ_ASSERT
(
aIterationCount
>
=
0
.
0
&
&
!
IsNaN
(
aIterationCount
)
"
aIterations
should
be
nonnegative
&
finite
as
ensured
by
"
"
CSSParser
"
)
;
return
TimingParams
{
aDuration
aDelay
aIterationCount
aDirection
aFillMode
}
;
}
}
#
endif
