#
ifndef
mozilla_css_AnimationCommon_h
#
define
mozilla_css_AnimationCommon_h
#
include
<
algorithm
>
#
include
"
mozilla
/
AnimationCollection
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
class
nsIFrame
;
class
nsPresContext
;
namespace
mozilla
{
enum
class
CSSPseudoElementType
:
uint8_t
;
template
<
class
EventInfo
>
class
AnimationEventDispatcher
;
namespace
dom
{
class
Element
;
}
template
<
class
AnimationType
class
AnimationEventType
>
class
CommonAnimationManager
{
public
:
explicit
CommonAnimationManager
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
{
}
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
void
Disconnect
(
)
{
RemoveAllElementCollections
(
)
;
mPresContext
=
nullptr
;
}
void
StopAnimationsForElement
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
{
MOZ_ASSERT
(
aElement
)
;
AnimationCollection
<
AnimationType
>
*
collection
=
AnimationCollection
<
AnimationType
>
:
:
GetAnimationCollection
(
aElement
aPseudoType
)
;
if
(
!
collection
)
{
return
;
}
nsAutoAnimationMutationBatch
mb
(
aElement
-
>
OwnerDoc
(
)
)
;
collection
-
>
Destroy
(
)
;
}
void
QueueEvents
(
nsTArray
<
AnimationEventType
>
&
&
aEvents
)
{
mEventDispatcher
.
QueueEvents
(
mozilla
:
:
Forward
<
nsTArray
<
AnimationEventType
>
>
(
aEvents
)
)
;
}
void
SortEvents
(
)
{
mEventDispatcher
.
SortEvents
(
)
;
}
void
ClearEventQueue
(
)
{
mEventDispatcher
.
ClearEventQueue
(
)
;
}
protected
:
virtual
~
CommonAnimationManager
(
)
{
MOZ_ASSERT
(
!
mPresContext
"
Disconnect
should
have
been
called
"
)
;
}
void
AddElementCollection
(
AnimationCollection
<
AnimationType
>
*
aCollection
)
{
mElementCollections
.
insertBack
(
aCollection
)
;
}
void
RemoveAllElementCollections
(
)
{
while
(
AnimationCollection
<
AnimationType
>
*
head
=
mElementCollections
.
getFirst
(
)
)
{
head
-
>
Destroy
(
)
;
}
}
LinkedList
<
AnimationCollection
<
AnimationType
>
>
mElementCollections
;
nsPresContext
*
mPresContext
;
mozilla
:
:
AnimationEventDispatcher
<
AnimationEventType
>
mEventDispatcher
;
}
;
class
OwningElementRef
final
{
public
:
OwningElementRef
(
)
=
default
;
explicit
OwningElementRef
(
const
NonOwningAnimationTarget
&
aTarget
)
:
mTarget
(
aTarget
)
{
}
OwningElementRef
(
dom
:
:
Element
&
aElement
CSSPseudoElementType
aPseudoType
)
:
mTarget
(
&
aElement
aPseudoType
)
{
}
bool
Equals
(
const
OwningElementRef
&
aOther
)
const
{
return
mTarget
=
=
aOther
.
mTarget
;
}
bool
LessThan
(
const
OwningElementRef
&
aOther
)
const
{
MOZ_ASSERT
(
mTarget
.
mElement
&
&
aOther
.
mTarget
.
mElement
"
Elements
to
compare
should
not
be
null
"
)
;
if
(
mTarget
.
mElement
!
=
aOther
.
mTarget
.
mElement
)
{
return
nsContentUtils
:
:
PositionIsBefore
(
mTarget
.
mElement
aOther
.
mTarget
.
mElement
)
;
}
return
mTarget
.
mPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
|
|
(
mTarget
.
mPseudoType
=
=
CSSPseudoElementType
:
:
before
&
&
aOther
.
mTarget
.
mPseudoType
=
=
CSSPseudoElementType
:
:
after
)
;
}
bool
IsSet
(
)
const
{
return
!
!
mTarget
.
mElement
;
}
void
GetElement
(
dom
:
:
Element
*
&
aElement
CSSPseudoElementType
&
aPseudoType
)
const
{
aElement
=
mTarget
.
mElement
;
aPseudoType
=
mTarget
.
mPseudoType
;
}
const
NonOwningAnimationTarget
&
Target
(
)
const
{
return
mTarget
;
}
nsPresContext
*
GetPresContext
(
)
const
{
return
nsContentUtils
:
:
GetContextForContent
(
mTarget
.
mElement
)
;
}
private
:
NonOwningAnimationTarget
mTarget
;
}
;
template
<
class
EventInfo
>
class
AnimationEventDispatcher
{
public
:
AnimationEventDispatcher
(
)
:
mIsSorted
(
true
)
{
}
void
QueueEvents
(
nsTArray
<
EventInfo
>
&
&
aEvents
)
{
mPendingEvents
.
AppendElements
(
Forward
<
nsTArray
<
EventInfo
>
>
(
aEvents
)
)
;
mIsSorted
=
false
;
}
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
std
:
:
stable_sort
(
mPendingEvents
.
begin
(
)
mPendingEvents
.
end
(
)
EventInfoLessThan
(
)
)
;
mIsSorted
=
true
;
}
void
DispatchEvents
(
nsPresContext
*
const
&
aPresContext
)
{
if
(
!
aPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
;
mPendingEvents
.
SwapElements
(
events
)
;
for
(
EventInfo
&
info
:
events
)
{
EventDispatcher
:
:
Dispatch
(
info
.
mElement
aPresContext
&
info
.
mEvent
)
;
if
(
!
aPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
const
char
*
aName
)
{
for
(
EventInfo
&
info
:
mPendingEvents
)
{
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mElement
aName
)
;
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mAnimation
aName
)
;
}
}
void
Unlink
(
)
{
ClearEventQueue
(
)
;
}
protected
:
class
EventInfoLessThan
{
public
:
bool
operator
(
)
(
const
EventInfo
&
a
const
EventInfo
&
b
)
const
{
if
(
a
.
mTimeStamp
!
=
b
.
mTimeStamp
)
{
if
(
a
.
mTimeStamp
.
IsNull
(
)
|
|
b
.
mTimeStamp
.
IsNull
(
)
)
{
return
a
.
mTimeStamp
.
IsNull
(
)
;
}
else
{
return
a
.
mTimeStamp
<
b
.
mTimeStamp
;
}
}
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
comparator
;
return
comparator
.
LessThan
(
a
.
mAnimation
b
.
mAnimation
)
;
}
}
;
typedef
nsTArray
<
EventInfo
>
EventArray
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
}
;
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionUnlink
(
AnimationEventDispatcher
<
EventInfo
>
&
aField
)
{
aField
.
Unlink
(
)
;
}
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
AnimationEventDispatcher
<
EventInfo
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aField
.
Traverse
(
&
aCallback
aName
)
;
}
template
<
typename
PhaseType
>
PhaseType
GetAnimationPhaseWithoutEffect
(
const
dom
:
:
Animation
&
aAnimation
)
{
MOZ_ASSERT
(
!
aAnimation
.
GetEffect
(
)
"
Should
only
be
called
when
we
do
not
have
an
effect
"
)
;
Nullable
<
TimeDuration
>
currentTime
=
aAnimation
.
GetCurrentTime
(
)
;
if
(
currentTime
.
IsNull
(
)
)
{
return
PhaseType
:
:
Idle
;
}
return
currentTime
.
Value
(
)
<
TimeDuration
(
)
?
PhaseType
:
:
Before
:
PhaseType
:
:
After
;
}
;
inline
TimingParams
TimingParamsFromCSSParams
(
float
aDuration
float
aDelay
float
aIterationCount
dom
:
:
PlaybackDirection
aDirection
dom
:
:
FillMode
aFillMode
)
{
MOZ_ASSERT
(
aIterationCount
>
=
0
.
0
&
&
!
IsNaN
(
aIterationCount
)
"
aIterations
should
be
nonnegative
&
finite
as
ensured
by
"
"
CSSParser
"
)
;
return
TimingParams
{
aDuration
aDelay
aIterationCount
aDirection
aFillMode
}
;
}
}
#
endif
