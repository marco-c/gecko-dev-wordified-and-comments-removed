#
ifndef
mozilla_css_AnimationCommon_h
#
define
mozilla_css_AnimationCommon_h
#
include
<
algorithm
>
#
include
"
nsIStyleRuleProcessor
.
h
"
#
include
"
nsIStyleRule
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsCSSProperty
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCSSPropertySet
.
h
"
class
nsIFrame
;
class
nsPresContext
;
namespace
mozilla
{
class
RestyleTracker
;
struct
AnimationCollection
;
bool
IsGeometricProperty
(
nsCSSProperty
aProperty
)
;
class
CommonAnimationManager
:
public
nsIStyleRuleProcessor
public
nsARefreshObserver
{
public
:
explicit
CommonAnimationManager
(
nsPresContext
*
aPresContext
)
;
virtual
nsRestyleHint
HasStateDependentStyle
(
StateRuleProcessorData
*
aData
)
override
;
virtual
nsRestyleHint
HasStateDependentStyle
(
PseudoElementStateRuleProcessorData
*
aData
)
override
;
virtual
bool
HasDocumentStateDependentStyle
(
StateRuleProcessorData
*
aData
)
override
;
virtual
nsRestyleHint
HasAttributeDependentStyle
(
AttributeRuleProcessorData
*
aData
RestyleHintData
&
aRestyleHintDataResult
)
override
;
virtual
bool
MediumFeaturesChanged
(
nsPresContext
*
aPresContext
)
override
;
virtual
void
RulesMatching
(
ElementRuleProcessorData
*
aData
)
override
;
virtual
void
RulesMatching
(
PseudoElementRuleProcessorData
*
aData
)
override
;
virtual
void
RulesMatching
(
AnonBoxRuleProcessorData
*
aData
)
override
;
#
ifdef
MOZ_XUL
virtual
void
RulesMatching
(
XULTreeRuleProcessorData
*
aData
)
override
;
#
endif
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
MOZ_MUST_OVERRIDE
override
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
MOZ_MUST_OVERRIDE
override
;
void
WillRefresh
(
TimeStamp
aTime
)
override
;
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
void
Disconnect
(
)
;
void
AddStyleUpdatesTo
(
RestyleTracker
&
aTracker
)
;
AnimationCollection
*
GetAnimations
(
dom
:
:
Element
*
aElement
nsCSSPseudoElements
:
:
Type
aPseudoType
bool
aCreateIfNeeded
)
;
static
bool
ContentOrAncestorHasAnimation
(
nsIContent
*
aContent
)
{
do
{
if
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
animationsProperty
)
|
|
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
transitionsProperty
)
)
{
return
true
;
}
}
while
(
(
aContent
=
aContent
-
>
GetParent
(
)
)
)
;
return
false
;
}
void
FlushAnimations
(
)
;
nsIStyleRule
*
GetAnimationRule
(
dom
:
:
Element
*
aElement
nsCSSPseudoElements
:
:
Type
aPseudoType
)
;
static
bool
ExtractComputedValueForTransition
(
nsCSSProperty
aProperty
nsStyleContext
*
aStyleContext
StyleAnimationValue
&
aComputedValue
)
;
struct
LayerAnimationRecord
{
nsCSSProperty
mProperty
;
nsDisplayItem
:
:
Type
mLayerType
;
nsChangeHint
mChangeHint
;
}
;
protected
:
virtual
~
CommonAnimationManager
(
)
;
friend
struct
AnimationCollection
;
void
AddElementCollection
(
AnimationCollection
*
aCollection
)
;
void
ElementCollectionRemoved
(
)
{
MaybeStartOrStopObservingRefreshDriver
(
)
;
}
void
RemoveAllElementCollections
(
)
;
void
MaybeStartObservingRefreshDriver
(
)
;
void
MaybeStartOrStopObservingRefreshDriver
(
)
;
bool
NeedsRefresh
(
)
const
;
virtual
nsIAtom
*
GetAnimationsAtom
(
)
=
0
;
virtual
nsIAtom
*
GetAnimationsBeforeAtom
(
)
=
0
;
virtual
nsIAtom
*
GetAnimationsAfterAtom
(
)
=
0
;
virtual
bool
IsAnimationManager
(
)
{
return
false
;
}
public
:
AnimationCollection
*
GetAnimationsForCompositor
(
const
nsIFrame
*
aFrame
nsCSSProperty
aProperty
)
;
AnimationCollection
*
GetAnimationCollection
(
const
nsIFrame
*
aFrame
)
;
protected
:
LinkedList
<
AnimationCollection
>
mElementCollections
;
nsPresContext
*
mPresContext
;
bool
mIsObservingRefreshDriver
;
}
;
class
AnimValuesStyleRule
final
:
public
nsIStyleRule
{
public
:
NS_DECL_ISUPPORTS
virtual
void
MapRuleInfoInto
(
nsRuleData
*
aRuleData
)
override
;
#
ifdef
DEBUG
virtual
void
List
(
FILE
*
out
=
stdout
int32_t
aIndent
=
0
)
const
override
;
#
endif
void
AddValue
(
nsCSSProperty
aProperty
StyleAnimationValue
&
aStartValue
)
{
PropertyValuePair
v
=
{
aProperty
aStartValue
}
;
mPropertyValuePairs
.
AppendElement
(
v
)
;
}
StyleAnimationValue
*
AddEmptyValue
(
nsCSSProperty
aProperty
)
{
PropertyValuePair
*
p
=
mPropertyValuePairs
.
AppendElement
(
)
;
p
-
>
mProperty
=
aProperty
;
return
&
p
-
>
mValue
;
}
struct
PropertyValuePair
{
nsCSSProperty
mProperty
;
StyleAnimationValue
mValue
;
}
;
void
AddPropertiesToSet
(
nsCSSPropertySet
&
aSet
)
const
{
for
(
size_t
i
=
0
i_end
=
mPropertyValuePairs
.
Length
(
)
;
i
<
i_end
;
+
+
i
)
{
const
PropertyValuePair
&
cv
=
mPropertyValuePairs
[
i
]
;
aSet
.
AddProperty
(
cv
.
mProperty
)
;
}
}
private
:
~
AnimValuesStyleRule
(
)
{
}
InfallibleTArray
<
PropertyValuePair
>
mPropertyValuePairs
;
}
;
typedef
InfallibleTArray
<
nsRefPtr
<
dom
:
:
Animation
>
>
AnimationPtrArray
;
struct
AnimationCollection
:
public
LinkedListElement
<
AnimationCollection
>
{
AnimationCollection
(
dom
:
:
Element
*
aElement
nsIAtom
*
aElementProperty
CommonAnimationManager
*
aManager
)
:
mElement
(
aElement
)
mElementProperty
(
aElementProperty
)
mManager
(
aManager
)
mAnimationGeneration
(
0
)
mCheckGeneration
(
0
)
mNeedsRefreshes
(
true
)
mHasPendingAnimationRestyle
(
false
)
#
ifdef
DEBUG
mCalledPropertyDtor
(
false
)
#
endif
{
MOZ_COUNT_CTOR
(
AnimationCollection
)
;
}
~
AnimationCollection
(
)
{
MOZ_ASSERT
(
mCalledPropertyDtor
"
must
call
destructor
through
element
property
dtor
"
)
;
MOZ_COUNT_DTOR
(
AnimationCollection
)
;
remove
(
)
;
mManager
-
>
ElementCollectionRemoved
(
)
;
}
void
Destroy
(
)
{
mElement
-
>
DeleteProperty
(
mElementProperty
)
;
}
static
void
PropertyDtor
(
void
*
aObject
nsIAtom
*
aPropertyName
void
*
aPropertyValue
void
*
aData
)
;
void
Tick
(
)
;
void
EnsureStyleRuleFor
(
TimeStamp
aRefreshTime
)
;
enum
CanAnimateFlags
{
CanAnimate_HasGeometricProperty
=
1
CanAnimate_AllowPartial
=
2
}
;
enum
class
RestyleType
{
Throttled
Standard
Layer
}
;
void
RequestRestyle
(
RestyleType
aRestyleType
)
;
private
:
static
bool
CanAnimatePropertyOnCompositor
(
const
dom
:
:
Element
*
aElement
nsCSSProperty
aProperty
CanAnimateFlags
aFlags
)
;
bool
CanThrottleAnimation
(
TimeStamp
aTime
)
;
bool
CanThrottleTransformChanges
(
TimeStamp
aTime
)
;
public
:
static
bool
IsCompositorAnimationDisabledForFrame
(
nsIFrame
*
aFrame
)
;
bool
CanPerformOnCompositorThread
(
CanAnimateFlags
aFlags
)
const
;
bool
HasCurrentAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
;
bool
IsForElement
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
animationsProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsProperty
;
}
bool
IsForBeforePseudo
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
animationsOfBeforeProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsOfBeforeProperty
;
}
bool
IsForAfterPseudo
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
animationsOfAfterProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsOfAfterProperty
;
}
bool
IsForTransitions
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
transitionsProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsOfBeforeProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsOfAfterProperty
;
}
bool
IsForAnimations
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
animationsProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
animationsOfBeforeProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
animationsOfAfterProperty
;
}
nsCSSPseudoElements
:
:
Type
PseudoElementType
(
)
const
{
if
(
IsForElement
(
)
)
{
return
nsCSSPseudoElements
:
:
ePseudo_NotPseudoElement
;
}
if
(
IsForBeforePseudo
(
)
)
{
return
nsCSSPseudoElements
:
:
ePseudo_before
;
}
MOZ_ASSERT
(
IsForAfterPseudo
(
)
"
:
:
before
&
:
:
after
should
be
the
only
pseudo
-
elements
here
"
)
;
return
nsCSSPseudoElements
:
:
ePseudo_after
;
}
static
nsString
PseudoTypeAsString
(
nsCSSPseudoElements
:
:
Type
aPseudoType
)
;
dom
:
:
Element
*
GetElementToRestyle
(
)
const
;
void
PostRestyleForAnimation
(
nsPresContext
*
aPresContext
)
{
dom
:
:
Element
*
element
=
GetElementToRestyle
(
)
;
if
(
element
)
{
nsRestyleHint
hint
=
IsForTransitions
(
)
?
eRestyle_CSSTransitions
:
eRestyle_CSSAnimations
;
aPresContext
-
>
PresShell
(
)
-
>
RestyleForAnimation
(
element
hint
)
;
}
}
static
void
LogAsyncAnimationFailure
(
nsCString
&
aMessage
const
nsIContent
*
aContent
=
nullptr
)
;
dom
:
:
Element
*
mElement
;
nsIAtom
*
mElementProperty
;
CommonAnimationManager
*
mManager
;
AnimationPtrArray
mAnimations
;
nsRefPtr
<
AnimValuesStyleRule
>
mStyleRule
;
uint64_t
mAnimationGeneration
;
void
UpdateAnimationGeneration
(
nsPresContext
*
aPresContext
)
;
uint64_t
mCheckGeneration
;
void
UpdateCheckGeneration
(
nsPresContext
*
aPresContext
)
;
bool
HasCurrentAnimations
(
)
const
;
bool
HasCurrentAnimationsForProperties
(
const
nsCSSProperty
*
aProperties
size_t
aPropertyCount
)
const
;
TimeStamp
mStyleRuleRefreshTime
;
bool
mNeedsRefreshes
;
private
:
bool
mHasPendingAnimationRestyle
;
#
ifdef
DEBUG
bool
mCalledPropertyDtor
;
#
endif
}
;
class
OwningElementRef
final
{
public
:
OwningElementRef
(
)
:
mElement
(
nullptr
)
mPseudoType
(
nsCSSPseudoElements
:
:
ePseudo_NotPseudoElement
)
{
}
OwningElementRef
(
dom
:
:
Element
&
aElement
nsCSSPseudoElements
:
:
Type
aPseudoType
)
:
mElement
(
&
aElement
)
mPseudoType
(
aPseudoType
)
{
}
bool
Equals
(
const
OwningElementRef
&
aOther
)
const
{
return
mElement
=
=
aOther
.
mElement
&
&
mPseudoType
=
=
aOther
.
mPseudoType
;
}
bool
LessThan
(
const
OwningElementRef
&
aOther
)
const
{
MOZ_ASSERT
(
mElement
&
&
aOther
.
mElement
"
Elements
to
compare
should
not
be
null
"
)
;
if
(
mElement
!
=
aOther
.
mElement
)
{
return
nsContentUtils
:
:
PositionIsBefore
(
mElement
aOther
.
mElement
)
;
}
return
mPseudoType
=
=
nsCSSPseudoElements
:
:
ePseudo_NotPseudoElement
|
|
(
mPseudoType
=
=
nsCSSPseudoElements
:
:
ePseudo_before
&
&
aOther
.
mPseudoType
=
=
nsCSSPseudoElements
:
:
ePseudo_after
)
;
}
bool
IsSet
(
)
const
{
return
!
!
mElement
;
}
void
GetElement
(
dom
:
:
Element
*
&
aElement
nsCSSPseudoElements
:
:
Type
&
aPseudoType
)
const
{
aElement
=
mElement
;
aPseudoType
=
mPseudoType
;
}
nsPresContext
*
GetRenderedPresContext
(
)
const
;
private
:
dom
:
:
Element
*
MOZ_NON_OWNING_REF
mElement
;
nsCSSPseudoElements
:
:
Type
mPseudoType
;
}
;
template
<
class
EventInfo
>
class
DelayedEventDispatcher
{
public
:
DelayedEventDispatcher
(
)
:
mIsSorted
(
true
)
{
}
void
QueueEvent
(
EventInfo
&
&
aEventInfo
)
{
mPendingEvents
.
AppendElement
(
Forward
<
EventInfo
>
(
aEventInfo
)
)
;
mIsSorted
=
false
;
}
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
std
:
:
stable_sort
(
mPendingEvents
.
begin
(
)
mPendingEvents
.
end
(
)
EventInfoLessThan
(
)
)
;
mIsSorted
=
true
;
}
void
DispatchEvents
(
nsPresContext
*
const
&
aPresContext
)
{
if
(
!
aPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
;
mPendingEvents
.
SwapElements
(
events
)
;
for
(
EventInfo
&
info
:
events
)
{
EventDispatcher
:
:
Dispatch
(
info
.
mElement
aPresContext
&
info
.
mEvent
)
;
if
(
!
aPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
const
char
*
aName
)
{
for
(
EventInfo
&
info
:
mPendingEvents
)
{
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mElement
aName
)
;
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mAnimation
aName
)
;
}
}
void
Unlink
(
)
{
ClearEventQueue
(
)
;
}
protected
:
class
EventInfoLessThan
{
public
:
bool
operator
(
)
(
const
EventInfo
&
a
const
EventInfo
&
b
)
const
{
if
(
a
.
mTimeStamp
!
=
b
.
mTimeStamp
)
{
if
(
a
.
mTimeStamp
.
IsNull
(
)
|
|
b
.
mTimeStamp
.
IsNull
(
)
)
{
return
a
.
mTimeStamp
.
IsNull
(
)
;
}
else
{
return
a
.
mTimeStamp
<
b
.
mTimeStamp
;
}
}
AnimationPtrComparator
<
nsRefPtr
<
dom
:
:
Animation
>
>
comparator
;
return
comparator
.
LessThan
(
a
.
mAnimation
b
.
mAnimation
)
;
}
}
;
typedef
nsTArray
<
EventInfo
>
EventArray
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
}
;
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionUnlink
(
DelayedEventDispatcher
<
EventInfo
>
&
aField
)
{
aField
.
Unlink
(
)
;
}
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
DelayedEventDispatcher
<
EventInfo
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aField
.
Traverse
(
&
aCallback
aName
)
;
}
}
#
endif
