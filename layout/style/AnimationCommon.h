#
ifndef
mozilla_css_AnimationCommon_h
#
define
mozilla_css_AnimationCommon_h
#
include
<
algorithm
>
#
include
"
nsChangeHint
.
h
"
#
include
"
nsCSSProperty
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
class
nsIFrame
;
class
nsPresContext
;
namespace
mozilla
{
struct
AnimationCollection
;
class
CommonAnimationManager
{
public
:
explicit
CommonAnimationManager
(
nsPresContext
*
aPresContext
)
;
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
void
Disconnect
(
)
;
static
bool
ContentOrAncestorHasAnimation
(
nsIContent
*
aContent
)
{
do
{
if
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
animationsProperty
)
|
|
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
transitionsProperty
)
)
{
return
true
;
}
}
while
(
(
aContent
=
aContent
-
>
GetParent
(
)
)
)
;
return
false
;
}
static
bool
ExtractComputedValueForTransition
(
nsCSSProperty
aProperty
nsStyleContext
*
aStyleContext
StyleAnimationValue
&
aComputedValue
)
;
virtual
bool
IsAnimationManager
(
)
{
return
false
;
}
protected
:
virtual
~
CommonAnimationManager
(
)
;
void
AddElementCollection
(
AnimationCollection
*
aCollection
)
;
void
RemoveAllElementCollections
(
)
;
bool
NeedsRefresh
(
)
const
;
virtual
nsIAtom
*
GetAnimationsAtom
(
)
=
0
;
virtual
nsIAtom
*
GetAnimationsBeforeAtom
(
)
=
0
;
virtual
nsIAtom
*
GetAnimationsAfterAtom
(
)
=
0
;
public
:
AnimationCollection
*
GetAnimationCollection
(
dom
:
:
Element
*
aElement
nsCSSPseudoElements
:
:
Type
aPseudoType
bool
aCreateIfNeeded
)
;
AnimationCollection
*
GetAnimationCollection
(
const
nsIFrame
*
aFrame
)
;
protected
:
LinkedList
<
AnimationCollection
>
mElementCollections
;
nsPresContext
*
mPresContext
;
}
;
typedef
InfallibleTArray
<
RefPtr
<
dom
:
:
Animation
>
>
AnimationPtrArray
;
struct
AnimationCollection
:
public
LinkedListElement
<
AnimationCollection
>
{
AnimationCollection
(
dom
:
:
Element
*
aElement
nsIAtom
*
aElementProperty
CommonAnimationManager
*
aManager
)
:
mElement
(
aElement
)
mElementProperty
(
aElementProperty
)
mManager
(
aManager
)
mCheckGeneration
(
0
)
#
ifdef
DEBUG
mCalledPropertyDtor
(
false
)
#
endif
{
MOZ_COUNT_CTOR
(
AnimationCollection
)
;
}
~
AnimationCollection
(
)
{
MOZ_ASSERT
(
mCalledPropertyDtor
"
must
call
destructor
through
element
property
dtor
"
)
;
MOZ_COUNT_DTOR
(
AnimationCollection
)
;
remove
(
)
;
}
void
Destroy
(
)
{
mElement
-
>
DeleteProperty
(
mElementProperty
)
;
}
static
void
PropertyDtor
(
void
*
aObject
nsIAtom
*
aPropertyName
void
*
aPropertyValue
void
*
aData
)
;
void
Tick
(
)
;
public
:
bool
CanPerformOnCompositorThread
(
const
nsIFrame
*
aFrame
)
const
;
bool
HasCurrentAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
;
bool
IsForElement
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
animationsProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsProperty
;
}
bool
IsForBeforePseudo
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
animationsOfBeforeProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsOfBeforeProperty
;
}
bool
IsForAfterPseudo
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
animationsOfAfterProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsOfAfterProperty
;
}
bool
IsForTransitions
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
transitionsProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsOfBeforeProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
transitionsOfAfterProperty
;
}
bool
IsForAnimations
(
)
const
{
return
mElementProperty
=
=
nsGkAtoms
:
:
animationsProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
animationsOfBeforeProperty
|
|
mElementProperty
=
=
nsGkAtoms
:
:
animationsOfAfterProperty
;
}
nsCSSPseudoElements
:
:
Type
PseudoElementType
(
)
const
{
if
(
IsForElement
(
)
)
{
return
CSSPseudoElementType
:
:
NotPseudo
;
}
if
(
IsForBeforePseudo
(
)
)
{
return
CSSPseudoElementType
:
:
before
;
}
MOZ_ASSERT
(
IsForAfterPseudo
(
)
"
:
:
before
&
:
:
after
should
be
the
only
pseudo
-
elements
here
"
)
;
return
CSSPseudoElementType
:
:
after
;
}
static
nsString
PseudoTypeAsString
(
nsCSSPseudoElements
:
:
Type
aPseudoType
)
;
dom
:
:
Element
*
GetElementToRestyle
(
)
const
;
dom
:
:
Element
*
mElement
;
nsIAtom
*
mElementProperty
;
CommonAnimationManager
*
mManager
;
AnimationPtrArray
mAnimations
;
uint64_t
mCheckGeneration
;
void
UpdateCheckGeneration
(
nsPresContext
*
aPresContext
)
;
private
:
#
ifdef
DEBUG
bool
mCalledPropertyDtor
;
#
endif
}
;
class
OwningElementRef
final
{
public
:
OwningElementRef
(
)
:
mElement
(
nullptr
)
mPseudoType
(
CSSPseudoElementType
:
:
NotPseudo
)
{
}
OwningElementRef
(
dom
:
:
Element
&
aElement
nsCSSPseudoElements
:
:
Type
aPseudoType
)
:
mElement
(
&
aElement
)
mPseudoType
(
aPseudoType
)
{
}
bool
Equals
(
const
OwningElementRef
&
aOther
)
const
{
return
mElement
=
=
aOther
.
mElement
&
&
mPseudoType
=
=
aOther
.
mPseudoType
;
}
bool
LessThan
(
const
OwningElementRef
&
aOther
)
const
{
MOZ_ASSERT
(
mElement
&
&
aOther
.
mElement
"
Elements
to
compare
should
not
be
null
"
)
;
if
(
mElement
!
=
aOther
.
mElement
)
{
return
nsContentUtils
:
:
PositionIsBefore
(
mElement
aOther
.
mElement
)
;
}
return
mPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
|
|
(
mPseudoType
=
=
CSSPseudoElementType
:
:
before
&
&
aOther
.
mPseudoType
=
=
CSSPseudoElementType
:
:
after
)
;
}
bool
IsSet
(
)
const
{
return
!
!
mElement
;
}
void
GetElement
(
dom
:
:
Element
*
&
aElement
nsCSSPseudoElements
:
:
Type
&
aPseudoType
)
const
{
aElement
=
mElement
;
aPseudoType
=
mPseudoType
;
}
nsPresContext
*
GetRenderedPresContext
(
)
const
;
private
:
dom
:
:
Element
*
MOZ_NON_OWNING_REF
mElement
;
nsCSSPseudoElements
:
:
Type
mPseudoType
;
}
;
template
<
class
EventInfo
>
class
DelayedEventDispatcher
{
public
:
DelayedEventDispatcher
(
)
:
mIsSorted
(
true
)
{
}
void
QueueEvent
(
EventInfo
&
&
aEventInfo
)
{
mPendingEvents
.
AppendElement
(
Forward
<
EventInfo
>
(
aEventInfo
)
)
;
mIsSorted
=
false
;
}
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
std
:
:
stable_sort
(
mPendingEvents
.
begin
(
)
mPendingEvents
.
end
(
)
EventInfoLessThan
(
)
)
;
mIsSorted
=
true
;
}
void
DispatchEvents
(
nsPresContext
*
const
&
aPresContext
)
{
if
(
!
aPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
;
mPendingEvents
.
SwapElements
(
events
)
;
for
(
EventInfo
&
info
:
events
)
{
EventDispatcher
:
:
Dispatch
(
info
.
mElement
aPresContext
&
info
.
mEvent
)
;
if
(
!
aPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
const
char
*
aName
)
{
for
(
EventInfo
&
info
:
mPendingEvents
)
{
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mElement
aName
)
;
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mAnimation
aName
)
;
}
}
void
Unlink
(
)
{
ClearEventQueue
(
)
;
}
protected
:
class
EventInfoLessThan
{
public
:
bool
operator
(
)
(
const
EventInfo
&
a
const
EventInfo
&
b
)
const
{
if
(
a
.
mTimeStamp
!
=
b
.
mTimeStamp
)
{
if
(
a
.
mTimeStamp
.
IsNull
(
)
|
|
b
.
mTimeStamp
.
IsNull
(
)
)
{
return
a
.
mTimeStamp
.
IsNull
(
)
;
}
else
{
return
a
.
mTimeStamp
<
b
.
mTimeStamp
;
}
}
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
comparator
;
return
comparator
.
LessThan
(
a
.
mAnimation
b
.
mAnimation
)
;
}
}
;
typedef
nsTArray
<
EventInfo
>
EventArray
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
}
;
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionUnlink
(
DelayedEventDispatcher
<
EventInfo
>
&
aField
)
{
aField
.
Unlink
(
)
;
}
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
DelayedEventDispatcher
<
EventInfo
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aField
.
Traverse
(
&
aCallback
aName
)
;
}
}
#
endif
