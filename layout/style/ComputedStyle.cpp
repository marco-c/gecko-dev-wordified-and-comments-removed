#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
namespace
mozilla
{
ComputedStyle
:
:
ComputedStyle
(
PseudoStyleType
aPseudoType
ServoComputedDataForgotten
aComputedValues
)
:
mSource
(
aComputedValues
)
mPseudoType
(
aPseudoType
)
{
}
nsChangeHint
ComputedStyle
:
:
CalcStyleDifference
(
const
ComputedStyle
&
aNewStyle
uint32_t
*
aEqualStructs
)
const
{
AUTO_PROFILER_LABEL
(
"
ComputedStyle
:
:
CalcStyleDifference
"
LAYOUT
)
;
static_assert
(
StyleStructConstants
:
:
kStyleStructCount
<
=
32
"
aEqualStructs
is
not
big
enough
"
)
;
*
aEqualStructs
=
0
;
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
DebugOnly
<
uint32_t
>
structsFound
=
0
;
DebugOnly
<
int
>
styleStructCount
=
0
;
#
define
STYLE_STRUCT_BIT
(
name_
)
\
StyleStructConstants
:
:
BitFor
(
StyleStructID
:
:
name_
)
#
define
EXPAND
(
.
.
.
)
__VA_ARGS__
#
define
DO_STRUCT_DIFFERENCE_WITH_ARGS
(
struct_
extra_args_
)
\
PR_BEGIN_MACRO
\
const
nsStyle
#
#
struct_
*
this
#
#
struct_
=
Style
#
#
struct_
(
)
;
\
structsFound
|
=
STYLE_STRUCT_BIT
(
struct_
)
;
\
\
const
nsStyle
#
#
struct_
*
other
#
#
struct_
=
aNewStyle
.
Style
#
#
struct_
(
)
;
\
if
(
this
#
#
struct_
=
=
other
#
#
struct_
)
{
\
/
*
The
very
same
struct
so
we
know
that
there
will
be
no
*
/
\
/
*
differences
.
*
/
\
*
aEqualStructs
|
=
STYLE_STRUCT_BIT
(
struct_
)
;
\
}
else
{
\
nsChangeHint
difference
=
\
this
#
#
struct_
-
>
CalcDifference
(
*
other
#
#
struct_
EXPAND
extra_args_
)
;
\
hint
|
=
difference
;
\
if
(
!
difference
)
{
\
*
aEqualStructs
|
=
STYLE_STRUCT_BIT
(
struct_
)
;
\
}
\
}
\
styleStructCount
+
+
;
\
PR_END_MACRO
#
define
DO_STRUCT_DIFFERENCE
(
struct_
)
\
DO_STRUCT_DIFFERENCE_WITH_ARGS
(
struct_
(
)
)
DO_STRUCT_DIFFERENCE
(
Display
)
;
DO_STRUCT_DIFFERENCE
(
XUL
)
;
DO_STRUCT_DIFFERENCE
(
Column
)
;
DO_STRUCT_DIFFERENCE
(
Content
)
;
DO_STRUCT_DIFFERENCE
(
UI
)
;
DO_STRUCT_DIFFERENCE
(
Visibility
)
;
DO_STRUCT_DIFFERENCE
(
Outline
)
;
DO_STRUCT_DIFFERENCE
(
TableBorder
)
;
DO_STRUCT_DIFFERENCE
(
Table
)
;
DO_STRUCT_DIFFERENCE
(
UIReset
)
;
DO_STRUCT_DIFFERENCE
(
Text
)
;
DO_STRUCT_DIFFERENCE_WITH_ARGS
(
List
(
*
StyleDisplay
(
)
)
)
;
DO_STRUCT_DIFFERENCE
(
SVGReset
)
;
DO_STRUCT_DIFFERENCE
(
SVG
)
;
DO_STRUCT_DIFFERENCE_WITH_ARGS
(
Position
(
*
StyleVisibility
(
)
)
)
;
DO_STRUCT_DIFFERENCE
(
Font
)
;
DO_STRUCT_DIFFERENCE
(
Margin
)
;
DO_STRUCT_DIFFERENCE
(
Padding
)
;
DO_STRUCT_DIFFERENCE
(
Border
)
;
DO_STRUCT_DIFFERENCE
(
TextReset
)
;
DO_STRUCT_DIFFERENCE
(
Effects
)
;
DO_STRUCT_DIFFERENCE
(
Background
)
;
DO_STRUCT_DIFFERENCE
(
Color
)
;
#
undef
DO_STRUCT_DIFFERENCE
#
undef
DO_STRUCT_DIFFERENCE_WITH_ARGS
#
undef
EXPAND
MOZ_ASSERT
(
styleStructCount
=
=
StyleStructConstants
:
:
kStyleStructCount
"
missing
a
call
to
DO_STRUCT_DIFFERENCE
"
)
;
const
ComputedStyle
*
thisVis
=
GetStyleIfVisited
(
)
;
const
ComputedStyle
*
otherVis
=
aNewStyle
.
GetStyleIfVisited
(
)
;
if
(
!
thisVis
!
=
!
otherVis
)
{
#
define
STYLE_STRUCT
(
name_
fields_
)
*
aEqualStructs
&
=
~
STYLE_STRUCT_BIT
(
name_
)
;
#
include
"
nsCSSVisitedDependentPropList
.
h
"
#
undef
STYLE_STRUCT
hint
|
=
nsChangeHint_RepaintFrame
;
}
else
if
(
thisVis
)
{
bool
change
=
false
;
#
define
STYLE_FIELD
(
name_
)
thisVisStruct
-
>
name_
!
=
otherVisStruct
-
>
name_
#
define
STYLE_STRUCT
(
name_
fields_
)
\
{
\
const
nsStyle
#
#
name_
*
thisVisStruct
=
thisVis
-
>
Style
#
#
name_
(
)
;
\
const
nsStyle
#
#
name_
*
otherVisStruct
=
otherVis
-
>
Style
#
#
name_
(
)
;
\
if
(
MOZ_FOR_EACH_SEPARATED
(
STYLE_FIELD
(
|
|
)
(
)
fields_
)
)
{
\
*
aEqualStructs
&
=
~
STYLE_STRUCT_BIT
(
name_
)
;
\
change
=
true
;
\
}
\
}
#
include
"
nsCSSVisitedDependentPropList
.
h
"
#
undef
STYLE_STRUCT
#
undef
STYLE_FIELD
#
undef
STYLE_STRUCT_BIT
if
(
change
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
}
if
(
hint
&
nsChangeHint_UpdateContainingBlock
)
{
const
nsStyleDisplay
*
oldDisp
=
StyleDisplay
(
)
;
const
nsStyleDisplay
*
newDisp
=
aNewStyle
.
StyleDisplay
(
)
;
bool
isFixedCB
;
if
(
oldDisp
-
>
IsAbsPosContainingBlockForNonSVGTextFrames
(
)
=
=
newDisp
-
>
IsAbsPosContainingBlockForNonSVGTextFrames
(
)
&
&
(
isFixedCB
=
oldDisp
-
>
IsFixedPosContainingBlockForNonSVGTextFrames
(
*
this
)
)
=
=
newDisp
-
>
IsFixedPosContainingBlockForNonSVGTextFrames
(
aNewStyle
)
&
&
(
isFixedCB
|
|
oldDisp
-
>
IsFixedPosContainingBlockForTransformSupportingFrames
(
)
=
=
newDisp
-
>
IsFixedPosContainingBlockForTransformSupportingFrames
(
)
)
&
&
(
isFixedCB
|
|
oldDisp
-
>
IsFixedPosContainingBlockForContainLayoutAndPaintSupportingFrames
(
)
=
=
newDisp
-
>
IsFixedPosContainingBlockForContainLayoutAndPaintSupportingFrames
(
)
)
)
{
hint
&
=
~
nsChangeHint_UpdateContainingBlock
;
}
}
MOZ_ASSERT
(
NS_IsHintSubset
(
hint
nsChangeHint_AllHints
)
"
Added
a
new
hint
without
bumping
AllHints
?
"
)
;
return
hint
&
~
nsChangeHint_NeutralChange
;
}
#
ifdef
DEBUG
void
ComputedStyle
:
:
List
(
FILE
*
out
int32_t
aIndent
)
{
nsAutoCString
str
;
int32_t
ix
;
for
(
ix
=
aIndent
;
-
-
ix
>
=
0
;
)
{
str
.
AppendLiteral
(
"
"
)
;
}
str
.
Append
(
nsPrintfCString
(
"
%
p
(
%
d
)
parent
=
%
p
"
(
void
*
)
this
0
nullptr
)
)
;
if
(
mPseudoType
!
=
PseudoStyleType
:
:
NotPseudo
)
{
str
.
Append
(
nsPrintfCString
(
"
%
s
"
ToString
(
mPseudoType
)
.
c_str
(
)
)
)
;
}
fprintf_stderr
(
out
"
%
s
{
ServoComputedData
}
\
n
"
str
.
get
(
)
)
;
}
#
endif
template
<
typename
Func
>
static
nscolor
GetVisitedDependentColorInternal
(
ComputedStyle
*
aSc
Func
aColorFunc
)
{
nscolor
colors
[
2
]
;
colors
[
0
]
=
aColorFunc
(
aSc
)
;
if
(
ComputedStyle
*
visitedStyle
=
aSc
-
>
GetStyleIfVisited
(
)
)
{
colors
[
1
]
=
aColorFunc
(
visitedStyle
)
;
return
ComputedStyle
:
:
CombineVisitedColors
(
colors
aSc
-
>
RelevantLinkVisited
(
)
)
;
}
return
colors
[
0
]
;
}
static
nscolor
ExtractColor
(
ComputedStyle
*
aStyle
const
nscolor
&
aColor
)
{
return
aColor
;
}
static
nscolor
ExtractColor
(
ComputedStyle
*
aStyle
const
StyleComplexColor
&
aColor
)
{
return
aColor
.
CalcColor
(
aStyle
)
;
}
static
nscolor
ExtractColor
(
ComputedStyle
*
aStyle
const
nsStyleSVGPaint
&
aPaintServer
)
{
return
aPaintServer
.
Type
(
)
=
=
eStyleSVGPaintType_Color
?
aPaintServer
.
GetColor
(
aStyle
)
:
NS_RGBA
(
0
0
0
0
)
;
}
#
define
STYLE_FIELD
(
struct_
field_
)
aField
=
=
&
struct_
:
:
field_
|
|
#
define
STYLE_STRUCT
(
name_
fields_
)
\
template
<
>
\
nscolor
ComputedStyle
:
:
GetVisitedDependentColor
(
\
decltype
(
nsStyle
#
#
name_
:
:
MOZ_ARG_1
fields_
)
nsStyle
#
#
name_
:
:
*
aField
)
{
\
MOZ_ASSERT
(
MOZ_FOR_EACH
(
STYLE_FIELD
(
nsStyle
#
#
name_
)
fields_
)
false
\
"
Getting
visited
-
dependent
color
for
a
field
in
nsStyle
"
#
name_
\
"
which
is
not
listed
in
nsCSSVisitedDependentPropList
.
h
"
)
;
\
return
GetVisitedDependentColorInternal
(
\
this
[
aField
]
(
ComputedStyle
*
sc
)
{
\
return
ExtractColor
(
sc
sc
-
>
Style
#
#
name_
(
)
-
>
*
aField
)
;
\
}
)
;
\
}
#
include
"
nsCSSVisitedDependentPropList
.
h
"
#
undef
STYLE_STRUCT
#
undef
STYLE_FIELD
struct
ColorIndexSet
{
uint8_t
colorIndex
alphaIndex
;
}
;
static
const
ColorIndexSet
gVisitedIndices
[
2
]
=
{
{
0
0
}
{
1
0
}
}
;
nscolor
ComputedStyle
:
:
CombineVisitedColors
(
nscolor
*
aColors
bool
aLinkIsVisited
)
{
if
(
NS_GET_A
(
aColors
[
1
]
)
=
=
0
)
{
aLinkIsVisited
=
false
;
}
const
ColorIndexSet
&
set
=
gVisitedIndices
[
aLinkIsVisited
?
1
:
0
]
;
nscolor
colorColor
=
aColors
[
set
.
colorIndex
]
;
nscolor
alphaColor
=
aColors
[
set
.
alphaIndex
]
;
return
NS_RGBA
(
NS_GET_R
(
colorColor
)
NS_GET_G
(
colorColor
)
NS_GET_B
(
colorColor
)
NS_GET_A
(
alphaColor
)
)
;
}
#
ifdef
DEBUG
const
char
*
ComputedStyle
:
:
StructName
(
StyleStructID
aSID
)
{
switch
(
aSID
)
{
#
define
STYLE_STRUCT
(
name_
)
\
case
StyleStructID
:
:
name_
:
\
return
#
name_
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
default
:
return
"
Unknown
"
;
}
}
Maybe
<
StyleStructID
>
ComputedStyle
:
:
LookupStruct
(
const
nsACString
&
aName
)
{
#
define
STYLE_STRUCT
(
name_
)
\
if
(
aName
.
EqualsLiteral
(
#
name_
)
)
return
Some
(
StyleStructID
:
:
name_
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
return
Nothing
(
)
;
}
#
endif
ComputedStyle
*
ComputedStyle
:
:
GetCachedLazyPseudoStyle
(
PseudoStyleType
aPseudo
)
const
{
MOZ_ASSERT
(
PseudoStyle
:
:
IsPseudoElement
(
aPseudo
)
)
;
MOZ_ASSERT
(
!
IsLazilyCascadedPseudoElement
(
)
"
Lazy
pseudos
can
'
t
inherit
lazy
pseudos
"
)
;
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
aPseudo
)
)
{
return
nullptr
;
}
return
mCachedInheritingStyles
.
Lookup
(
aPseudo
)
;
}
MOZ_DEFINE_MALLOC_ENCLOSING_SIZE_OF
(
ServoComputedValuesMallocEnclosingSizeOf
)
void
ComputedStyle
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aCVsSize
)
const
{
*
aCVsSize
+
=
ServoComputedValuesMallocEnclosingSizeOf
(
this
)
;
mSource
.
AddSizeOfExcludingThis
(
aSizes
)
;
mCachedInheritingStyles
.
AddSizeOfIncludingThis
(
aSizes
aCVsSize
)
;
}
}
