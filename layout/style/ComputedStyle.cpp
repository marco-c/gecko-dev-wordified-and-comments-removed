#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
mozilla
/
ArenaObjectID
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
namespace
mozilla
{
#
ifdef
DEBUG
enum
DebugStyleStruct
{
#
define
STYLE_STRUCT
(
name
)
eDebugStyleStruct_
#
#
name
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
}
;
#
define
STYLE_STRUCT
(
name
)
\
static_assert
(
static_cast
<
int
>
(
eDebugStyleStruct_
#
#
name
)
=
=
\
static_cast
<
int
>
(
eStyleStruct_
#
#
name
)
\
"
Style
struct
IDs
are
not
declared
in
order
?
"
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
#
endif
ComputedStyle
:
:
ComputedStyle
(
nsPresContext
*
aPresContext
nsAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
ServoComputedDataForgotten
aComputedValues
)
:
mPresContext
(
aPresContext
)
mSource
(
aComputedValues
)
mPseudoTag
(
aPseudoTag
)
mBits
(
(
(
uint64_t
)
aPseudoType
)
<
<
NS_STYLE_CONTEXT_TYPE_SHIFT
)
{
AddStyleBit
(
Servo_ComputedValues_GetStyleBits
(
this
)
)
;
MOZ_ASSERT
(
ComputedData
(
)
)
;
static_assert
(
(
UINT64_MAX
>
>
NS_STYLE_CONTEXT_TYPE_SHIFT
)
>
=
static_cast
<
CSSPseudoElementTypeBase
>
(
CSSPseudoElementType
:
:
MAX
)
"
pseudo
element
bits
no
longer
fit
in
a
uint64_t
"
)
;
#
define
eStyleStruct_LastItem
(
nsStyleStructID_Length
-
1
)
static_assert
(
NS_STYLE_INHERIT_MASK
&
NS_STYLE_INHERIT_BIT
(
LastItem
)
"
NS_STYLE_INHERIT_MASK
must
be
bigger
and
other
bits
shifted
"
)
;
#
undef
eStyleStruct_LastItem
}
nsChangeHint
ComputedStyle
:
:
CalcStyleDifference
(
ComputedStyle
*
aNewContext
uint32_t
*
aEqualStructs
)
{
MOZ_ASSERT
(
aNewContext
)
;
AUTO_PROFILER_LABEL
(
"
ComputedStyle
:
:
CalcStyleDifference
"
CSS
)
;
static_assert
(
nsStyleStructID_Length
<
=
32
"
aEqualStructs
is
not
big
enough
"
)
;
*
aEqualStructs
=
0
;
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
DebugOnly
<
uint32_t
>
structsFound
=
0
;
DebugOnly
<
int
>
styleStructCount
=
0
;
#
define
PEEK
(
struct_
)
\
ComputedData
(
)
-
>
GetStyle
#
#
struct_
(
)
#
define
EXPAND
(
.
.
.
)
__VA_ARGS__
#
define
DO_STRUCT_DIFFERENCE_WITH_ARGS
(
struct_
extra_args_
)
\
PR_BEGIN_MACRO
\
const
nsStyle
#
#
struct_
*
this
#
#
struct_
=
PEEK
(
struct_
)
;
\
if
(
this
#
#
struct_
)
{
\
structsFound
|
=
NS_STYLE_INHERIT_BIT
(
struct_
)
;
\
\
const
nsStyle
#
#
struct_
*
other
#
#
struct_
=
\
aNewContext
-
>
ThreadsafeStyle
#
#
struct_
(
)
;
\
if
(
this
#
#
struct_
=
=
other
#
#
struct_
)
{
\
/
*
The
very
same
struct
so
we
know
that
there
will
be
no
*
/
\
/
*
differences
.
*
/
\
*
aEqualStructs
|
=
NS_STYLE_INHERIT_BIT
(
struct_
)
;
\
}
else
{
\
nsChangeHint
difference
=
\
this
#
#
struct_
-
>
CalcDifference
(
*
other
#
#
struct_
EXPAND
extra_args_
)
;
\
hint
|
=
difference
;
\
if
(
!
difference
)
{
\
*
aEqualStructs
|
=
NS_STYLE_INHERIT_BIT
(
struct_
)
;
\
}
\
}
\
}
else
{
\
*
aEqualStructs
|
=
NS_STYLE_INHERIT_BIT
(
struct_
)
;
\
}
\
styleStructCount
+
+
;
\
PR_END_MACRO
#
define
DO_STRUCT_DIFFERENCE
(
struct_
)
\
DO_STRUCT_DIFFERENCE_WITH_ARGS
(
struct_
(
)
)
DO_STRUCT_DIFFERENCE
(
Display
)
;
DO_STRUCT_DIFFERENCE
(
XUL
)
;
DO_STRUCT_DIFFERENCE
(
Column
)
;
DO_STRUCT_DIFFERENCE
(
Content
)
;
DO_STRUCT_DIFFERENCE
(
UserInterface
)
;
DO_STRUCT_DIFFERENCE
(
Visibility
)
;
DO_STRUCT_DIFFERENCE
(
Outline
)
;
DO_STRUCT_DIFFERENCE
(
TableBorder
)
;
DO_STRUCT_DIFFERENCE
(
Table
)
;
DO_STRUCT_DIFFERENCE
(
UIReset
)
;
DO_STRUCT_DIFFERENCE
(
Text
)
;
DO_STRUCT_DIFFERENCE_WITH_ARGS
(
List
(
PEEK
(
Display
)
)
)
;
DO_STRUCT_DIFFERENCE
(
SVGReset
)
;
DO_STRUCT_DIFFERENCE
(
SVG
)
;
DO_STRUCT_DIFFERENCE_WITH_ARGS
(
Position
(
PEEK
(
Visibility
)
)
)
;
DO_STRUCT_DIFFERENCE
(
Font
)
;
DO_STRUCT_DIFFERENCE
(
Margin
)
;
DO_STRUCT_DIFFERENCE
(
Padding
)
;
DO_STRUCT_DIFFERENCE
(
Border
)
;
DO_STRUCT_DIFFERENCE
(
TextReset
)
;
DO_STRUCT_DIFFERENCE
(
Effects
)
;
DO_STRUCT_DIFFERENCE
(
Background
)
;
DO_STRUCT_DIFFERENCE
(
Color
)
;
#
undef
DO_STRUCT_DIFFERENCE
#
undef
DO_STRUCT_DIFFERENCE_WITH_ARGS
#
undef
EXPAND
MOZ_ASSERT
(
styleStructCount
=
=
nsStyleStructID_Length
"
missing
a
call
to
DO_STRUCT_DIFFERENCE
"
)
;
#
ifdef
DEBUG
#
define
STYLE_STRUCT
(
name_
)
\
MOZ_ASSERT
(
!
!
(
structsFound
&
NS_STYLE_INHERIT_BIT
(
name_
)
)
=
=
\
(
PEEK
(
name_
)
!
=
nullptr
)
\
"
PeekStyleData
results
must
not
change
in
the
middle
of
"
\
"
difference
calculation
.
"
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
#
endif
ComputedStyle
*
thisVis
=
GetStyleIfVisited
(
)
;
ComputedStyle
*
otherVis
=
aNewContext
-
>
GetStyleIfVisited
(
)
;
if
(
!
thisVis
!
=
!
otherVis
)
{
#
define
STYLE_STRUCT
(
name_
fields_
)
\
*
aEqualStructs
&
=
~
NS_STYLE_INHERIT_BIT
(
name_
)
;
#
include
"
nsCSSVisitedDependentPropList
.
h
"
#
undef
STYLE_STRUCT
hint
|
=
nsChangeHint_RepaintFrame
;
}
else
if
(
thisVis
)
{
bool
change
=
false
;
#
define
STYLE_FIELD
(
name_
)
thisVisStruct
-
>
name_
!
=
otherVisStruct
-
>
name_
#
define
STYLE_STRUCT
(
name_
fields_
)
\
if
(
PEEK
(
name_
)
)
{
\
const
nsStyle
#
#
name_
*
thisVisStruct
=
\
thisVis
-
>
ThreadsafeStyle
#
#
name_
(
)
;
\
const
nsStyle
#
#
name_
*
otherVisStruct
=
\
otherVis
-
>
ThreadsafeStyle
#
#
name_
(
)
;
\
if
(
MOZ_FOR_EACH_SEPARATED
(
STYLE_FIELD
(
|
|
)
(
)
fields_
)
)
{
\
*
aEqualStructs
&
=
~
NS_STYLE_INHERIT_BIT
(
name_
)
;
\
change
=
true
;
\
}
\
}
#
include
"
nsCSSVisitedDependentPropList
.
h
"
#
undef
STYLE_STRUCT
#
undef
STYLE_FIELD
if
(
change
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
}
if
(
hint
&
nsChangeHint_UpdateContainingBlock
)
{
if
(
ThreadsafeStyleDisplay
(
)
-
>
IsAbsPosContainingBlockForAppropriateFrame
(
*
this
)
=
=
aNewContext
-
>
ThreadsafeStyleDisplay
(
)
-
>
IsAbsPosContainingBlockForAppropriateFrame
(
*
aNewContext
)
&
&
ThreadsafeStyleDisplay
(
)
-
>
IsFixedPosContainingBlockForAppropriateFrame
(
*
this
)
=
=
aNewContext
-
>
ThreadsafeStyleDisplay
(
)
-
>
IsFixedPosContainingBlockForAppropriateFrame
(
*
aNewContext
)
)
{
hint
&
=
~
nsChangeHint_UpdateContainingBlock
;
}
}
MOZ_ASSERT
(
NS_IsHintSubset
(
hint
nsChangeHint_AllHints
)
"
Added
a
new
hint
without
bumping
AllHints
?
"
)
;
return
hint
&
~
nsChangeHint_NeutralChange
;
}
#
ifdef
DEBUG
void
ComputedStyle
:
:
List
(
FILE
*
out
int32_t
aIndent
)
{
nsAutoCString
str
;
int32_t
ix
;
for
(
ix
=
aIndent
;
-
-
ix
>
=
0
;
)
{
str
.
AppendLiteral
(
"
"
)
;
}
str
.
Append
(
nsPrintfCString
(
"
%
p
(
%
d
)
parent
=
%
p
"
(
void
*
)
this
0
nullptr
)
)
;
if
(
mPseudoTag
)
{
nsAutoString
buffer
;
mPseudoTag
-
>
ToString
(
buffer
)
;
AppendUTF16toUTF8
(
buffer
str
)
;
str
.
Append
(
'
'
)
;
}
fprintf_stderr
(
out
"
%
s
{
ServoComputedData
}
\
n
"
str
.
get
(
)
)
;
}
#
endif
nsIPresShell
*
ComputedStyle
:
:
Arena
(
)
{
return
mPresContext
-
>
PresShell
(
)
;
}
template
<
typename
Func
>
static
nscolor
GetVisitedDependentColorInternal
(
ComputedStyle
*
aSc
Func
aColorFunc
)
{
nscolor
colors
[
2
]
;
colors
[
0
]
=
aColorFunc
(
aSc
)
;
if
(
ComputedStyle
*
visitedStyle
=
aSc
-
>
GetStyleIfVisited
(
)
)
{
colors
[
1
]
=
aColorFunc
(
visitedStyle
)
;
return
ComputedStyle
:
:
CombineVisitedColors
(
colors
aSc
-
>
RelevantLinkVisited
(
)
)
;
}
return
colors
[
0
]
;
}
static
nscolor
ExtractColor
(
ComputedStyle
*
aStyle
const
nscolor
&
aColor
)
{
return
aColor
;
}
static
nscolor
ExtractColor
(
ComputedStyle
*
aStyle
const
StyleComplexColor
&
aColor
)
{
return
aColor
.
CalcColor
(
aStyle
)
;
}
static
nscolor
ExtractColor
(
ComputedStyle
*
aStyle
const
nsStyleSVGPaint
&
aPaintServer
)
{
return
aPaintServer
.
Type
(
)
=
=
eStyleSVGPaintType_Color
?
aPaintServer
.
GetColor
(
)
:
NS_RGBA
(
0
0
0
0
)
;
}
#
define
STYLE_FIELD
(
struct_
field_
)
aField
=
=
&
struct_
:
:
field_
|
|
#
define
STYLE_STRUCT
(
name_
fields_
)
\
template
<
>
nscolor
\
ComputedStyle
:
:
GetVisitedDependentColor
(
\
decltype
(
nsStyle
#
#
name_
:
:
MOZ_ARG_1
fields_
)
nsStyle
#
#
name_
:
:
*
aField
)
\
{
\
MOZ_ASSERT
(
MOZ_FOR_EACH
(
STYLE_FIELD
(
nsStyle
#
#
name_
)
fields_
)
false
\
"
Getting
visited
-
dependent
color
for
a
field
in
nsStyle
"
#
name_
\
"
which
is
not
listed
in
nsCSSVisitedDependentPropList
.
h
"
)
;
\
return
GetVisitedDependentColorInternal
(
this
\
[
aField
]
(
ComputedStyle
*
sc
)
{
\
return
ExtractColor
(
sc
sc
-
>
Style
#
#
name_
(
)
-
>
*
aField
)
;
\
}
)
;
\
}
#
include
"
nsCSSVisitedDependentPropList
.
h
"
#
undef
STYLE_STRUCT
#
undef
STYLE_FIELD
struct
ColorIndexSet
{
uint8_t
colorIndex
alphaIndex
;
}
;
static
const
ColorIndexSet
gVisitedIndices
[
2
]
=
{
{
0
0
}
{
1
0
}
}
;
nscolor
ComputedStyle
:
:
CombineVisitedColors
(
nscolor
*
aColors
bool
aLinkIsVisited
)
{
if
(
NS_GET_A
(
aColors
[
1
]
)
=
=
0
)
{
aLinkIsVisited
=
false
;
}
const
ColorIndexSet
&
set
=
gVisitedIndices
[
aLinkIsVisited
?
1
:
0
]
;
nscolor
colorColor
=
aColors
[
set
.
colorIndex
]
;
nscolor
alphaColor
=
aColors
[
set
.
alphaIndex
]
;
return
NS_RGBA
(
NS_GET_R
(
colorColor
)
NS_GET_G
(
colorColor
)
NS_GET_B
(
colorColor
)
NS_GET_A
(
alphaColor
)
)
;
}
#
ifdef
DEBUG
const
char
*
ComputedStyle
:
:
StructName
(
nsStyleStructID
aSID
)
{
switch
(
aSID
)
{
#
define
STYLE_STRUCT
(
name_
)
\
case
eStyleStruct_
#
#
name_
:
\
return
#
name_
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
default
:
return
"
Unknown
"
;
}
}
bool
ComputedStyle
:
:
LookupStruct
(
const
nsACString
&
aName
nsStyleStructID
&
aResult
)
{
if
(
false
)
;
#
define
STYLE_STRUCT
(
name_
)
\
else
if
(
aName
.
EqualsLiteral
(
#
name_
)
)
\
aResult
=
eStyleStruct_
#
#
name_
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
else
return
false
;
return
true
;
}
#
endif
ComputedStyle
*
ComputedStyle
:
:
GetCachedLazyPseudoStyle
(
CSSPseudoElementType
aPseudo
)
const
{
MOZ_ASSERT
(
aPseudo
!
=
CSSPseudoElementType
:
:
NotPseudo
&
&
aPseudo
!
=
CSSPseudoElementType
:
:
InheritingAnonBox
&
&
aPseudo
!
=
CSSPseudoElementType
:
:
NonInheritingAnonBox
)
;
MOZ_ASSERT
(
!
IsLazilyCascadedPseudoElement
(
)
"
Lazy
pseudos
can
'
t
inherit
lazy
pseudos
"
)
;
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
aPseudo
)
)
{
return
nullptr
;
}
return
mCachedInheritingStyles
.
Lookup
(
nsCSSPseudoElements
:
:
GetPseudoAtom
(
aPseudo
)
)
;
}
MOZ_DEFINE_MALLOC_ENCLOSING_SIZE_OF
(
ServoComputedValuesMallocEnclosingSizeOf
)
void
ComputedStyle
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aCVsSize
)
const
{
*
aCVsSize
+
=
ServoComputedValuesMallocEnclosingSizeOf
(
this
)
;
mSource
.
AddSizeOfExcludingThis
(
aSizes
)
;
mCachedInheritingStyles
.
AddSizeOfIncludingThis
(
aSizes
aCVsSize
)
;
}
}
