#
include
"
nsHTMLStyleSheet
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
ifdef
MOZ_OLD_STYLE
#
include
"
nsRuleWalker
.
h
"
#
include
"
nsRuleData
.
h
"
#
endif
#
include
"
nsError
.
h
"
#
ifdef
MOZ_OLD_STYLE
#
include
"
nsRuleProcessorData
.
h
"
#
include
"
nsCSSRuleProcessor
.
h
"
#
endif
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
RestyleManagerInlines
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
ifdef
MOZ_OLD_STYLE
NS_IMPL_ISUPPORTS
(
nsHTMLStyleSheet
:
:
HTMLColorRule
nsIStyleRule
)
void
nsHTMLStyleSheet
:
:
HTMLColorRule
:
:
MapRuleInfoInto
(
nsRuleData
*
aRuleData
)
{
if
(
aRuleData
-
>
mSIDs
&
NS_STYLE_INHERIT_BIT
(
Color
)
)
{
nsCSSValue
*
color
=
aRuleData
-
>
ValueForColor
(
)
;
if
(
color
-
>
GetUnit
(
)
=
=
eCSSUnit_Null
&
&
aRuleData
-
>
mPresContext
-
>
UseDocumentColors
(
)
)
color
-
>
SetColorValue
(
mColor
)
;
}
}
bool
nsHTMLStyleSheet
:
:
HTMLColorRule
:
:
MightMapInheritedStyleData
(
)
{
return
true
;
}
bool
nsHTMLStyleSheet
:
:
HTMLColorRule
:
:
GetDiscretelyAnimatedCSSValue
(
nsCSSPropertyID
aProperty
nsCSSValue
*
aValue
)
{
MOZ_ASSERT
(
false
"
GetDiscretelyAnimatedCSSValue
is
not
implemented
yet
"
)
;
return
false
;
}
#
ifdef
DEBUG
void
nsHTMLStyleSheet
:
:
HTMLColorRule
:
:
List
(
FILE
*
out
int32_t
aIndent
)
const
{
nsAutoCString
indentStr
;
for
(
int32_t
index
=
aIndent
;
-
-
index
>
=
0
;
)
{
indentStr
.
AppendLiteral
(
"
"
)
;
}
fprintf_stderr
(
out
"
%
s
[
html
color
rule
]
{
}
\
n
"
indentStr
.
get
(
)
)
;
}
#
endif
NS_IMPL_ISUPPORTS
(
nsHTMLStyleSheet
:
:
GenericTableRule
nsIStyleRule
)
#
ifdef
DEBUG
void
nsHTMLStyleSheet
:
:
GenericTableRule
:
:
List
(
FILE
*
out
int32_t
aIndent
)
const
{
nsAutoCString
indentStr
;
for
(
int32_t
index
=
aIndent
;
-
-
index
>
=
0
;
)
{
indentStr
.
AppendLiteral
(
"
"
)
;
}
fprintf_stderr
(
out
"
%
s
[
generic
table
rule
]
{
}
\
n
"
indentStr
.
get
(
)
)
;
}
#
endif
void
nsHTMLStyleSheet
:
:
TableTHRule
:
:
MapRuleInfoInto
(
nsRuleData
*
aRuleData
)
{
if
(
aRuleData
-
>
mSIDs
&
NS_STYLE_INHERIT_BIT
(
Text
)
)
{
nsCSSValue
*
textAlign
=
aRuleData
-
>
ValueForTextAlign
(
)
;
if
(
textAlign
-
>
GetUnit
(
)
=
=
eCSSUnit_Null
)
{
textAlign
-
>
SetIntValue
(
NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT
eCSSUnit_Enumerated
)
;
}
}
}
bool
nsHTMLStyleSheet
:
:
TableTHRule
:
:
MightMapInheritedStyleData
(
)
{
return
true
;
}
bool
nsHTMLStyleSheet
:
:
TableTHRule
:
:
GetDiscretelyAnimatedCSSValue
(
nsCSSPropertyID
aProperty
nsCSSValue
*
aValue
)
{
MOZ_ASSERT
(
false
"
GetDiscretelyAnimatedCSSValue
is
not
implemented
yet
"
)
;
return
false
;
}
void
nsHTMLStyleSheet
:
:
TableQuirkColorRule
:
:
MapRuleInfoInto
(
nsRuleData
*
aRuleData
)
{
if
(
aRuleData
-
>
mSIDs
&
NS_STYLE_INHERIT_BIT
(
Color
)
)
{
nsCSSValue
*
color
=
aRuleData
-
>
ValueForColor
(
)
;
if
(
color
-
>
GetUnit
(
)
=
=
eCSSUnit_Null
)
color
-
>
SetIntValue
(
NS_STYLE_COLOR_INHERIT_FROM_BODY
eCSSUnit_Enumerated
)
;
}
}
bool
nsHTMLStyleSheet
:
:
TableQuirkColorRule
:
:
MightMapInheritedStyleData
(
)
{
return
true
;
}
bool
nsHTMLStyleSheet
:
:
TableQuirkColorRule
:
:
GetDiscretelyAnimatedCSSValue
(
nsCSSPropertyID
aProperty
nsCSSValue
*
aValue
)
{
MOZ_ASSERT
(
false
"
GetDiscretelyAnimatedCSSValue
is
not
implemented
yet
"
)
;
return
false
;
}
NS_IMPL_ISUPPORTS
(
nsHTMLStyleSheet
:
:
LangRule
nsIStyleRule
)
void
nsHTMLStyleSheet
:
:
LangRule
:
:
MapRuleInfoInto
(
nsRuleData
*
aRuleData
)
{
if
(
aRuleData
-
>
mSIDs
&
NS_STYLE_INHERIT_BIT
(
Font
)
)
{
nsCSSValue
*
lang
=
aRuleData
-
>
ValueForLang
(
)
;
if
(
lang
-
>
GetUnit
(
)
=
=
eCSSUnit_Null
)
{
RefPtr
<
nsAtom
>
langAtom
=
mLang
;
lang
-
>
SetAtomIdentValue
(
langAtom
.
forget
(
)
)
;
}
}
}
bool
nsHTMLStyleSheet
:
:
LangRule
:
:
MightMapInheritedStyleData
(
)
{
return
true
;
}
bool
nsHTMLStyleSheet
:
:
LangRule
:
:
GetDiscretelyAnimatedCSSValue
(
nsCSSPropertyID
aProperty
nsCSSValue
*
aValue
)
{
MOZ_ASSERT
(
false
"
GetDiscretelyAnimatedCSSValue
is
not
implemented
yet
"
)
;
return
false
;
}
#
ifdef
DEBUG
void
nsHTMLStyleSheet
:
:
LangRule
:
:
List
(
FILE
*
out
int32_t
aIndent
)
const
{
nsAutoCString
str
;
for
(
int32_t
index
=
aIndent
;
-
-
index
>
=
0
;
)
{
str
.
AppendLiteral
(
"
"
)
;
}
str
.
AppendLiteral
(
"
[
lang
rule
]
{
language
:
\
"
"
)
;
AppendUTF16toUTF8
(
nsDependentAtomString
(
mLang
)
str
)
;
str
.
AppendLiteral
(
"
\
"
}
\
n
"
)
;
fprintf_stderr
(
out
"
%
s
"
str
.
get
(
)
)
;
}
#
endif
#
endif
struct
MappedAttrTableEntry
:
public
PLDHashEntryHdr
{
nsMappedAttributes
*
mAttributes
;
}
;
static
PLDHashNumber
MappedAttrTable_HashKey
(
const
void
*
key
)
{
nsMappedAttributes
*
attributes
=
static_cast
<
nsMappedAttributes
*
>
(
const_cast
<
void
*
>
(
key
)
)
;
return
attributes
-
>
HashValue
(
)
;
}
static
void
MappedAttrTable_ClearEntry
(
PLDHashTable
*
table
PLDHashEntryHdr
*
hdr
)
{
MappedAttrTableEntry
*
entry
=
static_cast
<
MappedAttrTableEntry
*
>
(
hdr
)
;
entry
-
>
mAttributes
-
>
DropStyleSheetReference
(
)
;
memset
(
entry
0
sizeof
(
MappedAttrTableEntry
)
)
;
}
static
bool
MappedAttrTable_MatchEntry
(
const
PLDHashEntryHdr
*
hdr
const
void
*
key
)
{
nsMappedAttributes
*
attributes
=
static_cast
<
nsMappedAttributes
*
>
(
const_cast
<
void
*
>
(
key
)
)
;
const
MappedAttrTableEntry
*
entry
=
static_cast
<
const
MappedAttrTableEntry
*
>
(
hdr
)
;
return
attributes
-
>
Equals
(
entry
-
>
mAttributes
)
;
}
static
const
PLDHashTableOps
MappedAttrTable_Ops
=
{
MappedAttrTable_HashKey
MappedAttrTable_MatchEntry
PLDHashTable
:
:
MoveEntryStub
MappedAttrTable_ClearEntry
nullptr
}
;
#
ifdef
MOZ_OLD_STYLE
struct
LangRuleTableEntry
:
public
PLDHashEntryHdr
{
RefPtr
<
nsHTMLStyleSheet
:
:
LangRule
>
mRule
;
}
;
static
PLDHashNumber
LangRuleTable_HashKey
(
const
void
*
key
)
{
auto
*
lang
=
static_cast
<
const
nsAtom
*
>
(
key
)
;
return
lang
-
>
hash
(
)
;
}
static
void
LangRuleTable_ClearEntry
(
PLDHashTable
*
table
PLDHashEntryHdr
*
hdr
)
{
LangRuleTableEntry
*
entry
=
static_cast
<
LangRuleTableEntry
*
>
(
hdr
)
;
entry
-
>
~
LangRuleTableEntry
(
)
;
memset
(
entry
0
sizeof
(
LangRuleTableEntry
)
)
;
}
static
bool
LangRuleTable_MatchEntry
(
const
PLDHashEntryHdr
*
hdr
const
void
*
key
)
{
auto
*
lang
=
static_cast
<
const
nsAtom
*
>
(
key
)
;
const
LangRuleTableEntry
*
entry
=
static_cast
<
const
LangRuleTableEntry
*
>
(
hdr
)
;
return
entry
-
>
mRule
-
>
mLang
=
=
lang
;
}
static
void
LangRuleTable_InitEntry
(
PLDHashEntryHdr
*
hdr
const
void
*
key
)
{
auto
*
lang
=
static_cast
<
const
nsAtom
*
>
(
key
)
;
LangRuleTableEntry
*
entry
=
new
(
KnownNotNull
hdr
)
LangRuleTableEntry
(
)
;
entry
-
>
mRule
=
new
nsHTMLStyleSheet
:
:
LangRule
(
const_cast
<
nsAtom
*
>
(
lang
)
)
;
}
static
const
PLDHashTableOps
LangRuleTable_Ops
=
{
LangRuleTable_HashKey
LangRuleTable_MatchEntry
PLDHashTable
:
:
MoveEntryStub
LangRuleTable_ClearEntry
LangRuleTable_InitEntry
}
;
#
endif
nsHTMLStyleSheet
:
:
nsHTMLStyleSheet
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
#
ifdef
MOZ_OLD_STYLE
mTableQuirkColorRule
(
new
TableQuirkColorRule
(
)
)
mTableTHRule
(
new
TableTHRule
(
)
)
#
endif
mMappedAttrTable
(
&
MappedAttrTable_Ops
sizeof
(
MappedAttrTableEntry
)
)
mMappedAttrsDirty
(
false
)
#
ifdef
MOZ_OLD_STYLE
mLangRuleTable
(
&
LangRuleTable_Ops
sizeof
(
LangRuleTableEntry
)
)
#
endif
{
MOZ_ASSERT
(
aDocument
)
;
}
#
ifdef
MOZ_OLD_STYLE
NS_IMPL_ISUPPORTS
(
nsHTMLStyleSheet
nsIStyleRuleProcessor
)
void
nsHTMLStyleSheet
:
:
RulesMatching
(
ElementRuleProcessorData
*
aData
)
{
nsRuleWalker
*
ruleWalker
=
aData
-
>
mRuleWalker
;
if
(
!
ruleWalker
-
>
AuthorStyleDisabled
(
)
)
{
if
(
aData
-
>
mElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
if
(
mLinkRule
|
|
mVisitedRule
|
|
mActiveRule
)
{
EventStates
state
=
nsCSSRuleProcessor
:
:
GetContentStateForVisitedHandling
(
aData
-
>
mElement
aData
-
>
mTreeMatchContext
.
VisitedHandling
(
)
nsCSSRuleProcessor
:
:
IsLink
(
aData
-
>
mElement
)
)
;
if
(
mLinkRule
&
&
state
.
HasState
(
NS_EVENT_STATE_UNVISITED
)
)
{
ruleWalker
-
>
Forward
(
mLinkRule
)
;
aData
-
>
mTreeMatchContext
.
SetHaveRelevantLink
(
)
;
}
else
if
(
mVisitedRule
&
&
state
.
HasState
(
NS_EVENT_STATE_VISITED
)
)
{
ruleWalker
-
>
Forward
(
mVisitedRule
)
;
aData
-
>
mTreeMatchContext
.
SetHaveRelevantLink
(
)
;
}
if
(
mActiveRule
&
&
nsCSSRuleProcessor
:
:
IsLink
(
aData
-
>
mElement
)
&
&
state
.
HasState
(
NS_EVENT_STATE_ACTIVE
)
)
{
ruleWalker
-
>
Forward
(
mActiveRule
)
;
}
}
}
else
if
(
aData
-
>
mElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
th
)
)
{
ruleWalker
-
>
Forward
(
mTableTHRule
)
;
}
else
if
(
aData
-
>
mElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
if
(
aData
-
>
mTreeMatchContext
.
mCompatMode
=
=
eCompatibility_NavQuirks
)
{
ruleWalker
-
>
Forward
(
mTableQuirkColorRule
)
;
}
}
}
if
(
!
ruleWalker
-
>
AuthorStyleDisabled
(
)
|
|
aData
-
>
mElement
-
>
IsSVGElement
(
)
)
{
aData
-
>
mElement
-
>
WalkContentStyleRules
(
ruleWalker
)
;
}
const
nsAttrValue
*
langAttr
=
aData
-
>
mElement
-
>
GetParsedAttr
(
nsGkAtoms
:
:
lang
kNameSpaceID_XML
)
;
if
(
langAttr
)
{
MOZ_ASSERT
(
langAttr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
)
;
ruleWalker
-
>
Forward
(
LangRuleFor
(
langAttr
-
>
GetAtomValue
(
)
)
)
;
}
if
(
aData
-
>
mElement
-
>
IsMathMLElement
(
nsGkAtoms
:
:
math
)
)
{
ruleWalker
-
>
Forward
(
LangRuleFor
(
nsGkAtoms
:
:
x_math
)
)
;
}
}
nsRestyleHint
nsHTMLStyleSheet
:
:
HasStateDependentStyle
(
StateRuleProcessorData
*
aData
)
{
if
(
aData
-
>
mElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
&
&
nsCSSRuleProcessor
:
:
IsLink
(
aData
-
>
mElement
)
&
&
(
(
mActiveRule
&
&
aData
-
>
mStateMask
.
HasState
(
NS_EVENT_STATE_ACTIVE
)
)
|
|
(
mLinkRule
&
&
aData
-
>
mStateMask
.
HasState
(
NS_EVENT_STATE_VISITED
)
)
|
|
(
mVisitedRule
&
&
aData
-
>
mStateMask
.
HasState
(
NS_EVENT_STATE_VISITED
)
)
)
)
{
return
eRestyle_Self
;
}
return
nsRestyleHint
(
0
)
;
}
nsRestyleHint
nsHTMLStyleSheet
:
:
HasStateDependentStyle
(
PseudoElementStateRuleProcessorData
*
aData
)
{
return
nsRestyleHint
(
0
)
;
}
bool
nsHTMLStyleSheet
:
:
HasDocumentStateDependentStyle
(
StateRuleProcessorData
*
aData
)
{
return
false
;
}
nsRestyleHint
nsHTMLStyleSheet
:
:
HasAttributeDependentStyle
(
AttributeRuleProcessorData
*
aData
RestyleHintData
&
aRestyleHintDataResult
)
{
if
(
!
aData
-
>
mAttrHasChanged
)
{
return
nsRestyleHint
(
0
)
;
}
Element
*
element
=
aData
-
>
mElement
;
if
(
aData
-
>
mAttribute
=
=
nsGkAtoms
:
:
href
&
&
(
mLinkRule
|
|
mVisitedRule
|
|
mActiveRule
)
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
return
eRestyle_Self
;
}
if
(
element
-
>
IsAttributeMapped
(
aData
-
>
mAttribute
)
)
{
if
(
aData
-
>
mAttribute
=
=
nsGkAtoms
:
:
cellpadding
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
eRestyle_Subtree
;
}
return
eRestyle_Self
;
}
return
nsRestyleHint
(
0
)
;
}
bool
nsHTMLStyleSheet
:
:
MediumFeaturesChanged
(
nsPresContext
*
aPresContext
)
{
return
false
;
}
size_t
nsHTMLStyleSheet
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
size_t
nsHTMLStyleSheet
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
void
nsHTMLStyleSheet
:
:
RulesMatching
(
PseudoElementRuleProcessorData
*
aData
)
{
}
void
nsHTMLStyleSheet
:
:
RulesMatching
(
AnonBoxRuleProcessorData
*
aData
)
{
}
#
ifdef
MOZ_XUL
void
nsHTMLStyleSheet
:
:
RulesMatching
(
XULTreeRuleProcessorData
*
aData
)
{
}
#
endif
#
endif
void
nsHTMLStyleSheet
:
:
SetOwningDocument
(
nsIDocument
*
aDocument
)
{
mDocument
=
aDocument
;
}
void
nsHTMLStyleSheet
:
:
Reset
(
)
{
#
ifdef
MOZ_OLD_STYLE
mLinkRule
=
nullptr
;
mVisitedRule
=
nullptr
;
mActiveRule
=
nullptr
;
#
endif
mServoUnvisitedLinkDecl
=
nullptr
;
mServoVisitedLinkDecl
=
nullptr
;
mServoActiveLinkDecl
=
nullptr
;
#
ifdef
MOZ_OLD_STYLE
mLangRuleTable
.
Clear
(
)
;
#
endif
mMappedAttrTable
.
Clear
(
)
;
mMappedAttrsDirty
=
false
;
}
nsresult
nsHTMLStyleSheet
:
:
ImplLinkColorSetter
(
#
ifdef
MOZ_OLD_STYLE
RefPtr
<
HTMLColorRule
>
&
aRule
#
endif
RefPtr
<
RawServoDeclarationBlock
>
&
aDecl
nscolor
aColor
)
{
if
(
!
mDocument
|
|
!
mDocument
-
>
GetShell
(
)
)
{
return
NS_OK
;
}
RestyleManager
*
restyle
=
mDocument
-
>
GetShell
(
)
-
>
GetPresContext
(
)
-
>
RestyleManager
(
)
;
if
(
restyle
-
>
IsServo
(
)
)
{
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
aDecl
=
Servo_DeclarationBlock_CreateEmpty
(
)
.
Consume
(
)
;
Servo_DeclarationBlock_SetColorValue
(
aDecl
.
get
(
)
eCSSProperty_color
aColor
)
;
}
else
{
#
ifdef
MOZ_OLD_STYLE
if
(
aRule
&
&
aRule
-
>
mColor
=
=
aColor
)
{
return
NS_OK
;
}
aRule
=
new
HTMLColorRule
(
aColor
)
;
if
(
!
aRule
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
root
)
{
restyle
-
>
PostRestyleEvent
(
root
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
}
return
NS_OK
;
}
nsresult
nsHTMLStyleSheet
:
:
SetLinkColor
(
nscolor
aColor
)
{
return
ImplLinkColorSetter
(
#
ifdef
MOZ_OLD_STYLE
mLinkRule
#
endif
mServoUnvisitedLinkDecl
aColor
)
;
}
nsresult
nsHTMLStyleSheet
:
:
SetActiveLinkColor
(
nscolor
aColor
)
{
return
ImplLinkColorSetter
(
#
ifdef
MOZ_OLD_STYLE
mActiveRule
#
endif
mServoActiveLinkDecl
aColor
)
;
}
nsresult
nsHTMLStyleSheet
:
:
SetVisitedLinkColor
(
nscolor
aColor
)
{
return
ImplLinkColorSetter
(
#
ifdef
MOZ_OLD_STYLE
mVisitedRule
#
endif
mServoVisitedLinkDecl
aColor
)
;
}
already_AddRefed
<
nsMappedAttributes
>
nsHTMLStyleSheet
:
:
UniqueMappedAttributes
(
nsMappedAttributes
*
aMapped
)
{
mMappedAttrsDirty
=
true
;
auto
entry
=
static_cast
<
MappedAttrTableEntry
*
>
(
mMappedAttrTable
.
Add
(
aMapped
fallible
)
)
;
if
(
!
entry
)
return
nullptr
;
if
(
!
entry
-
>
mAttributes
)
{
entry
-
>
mAttributes
=
aMapped
;
}
RefPtr
<
nsMappedAttributes
>
ret
=
entry
-
>
mAttributes
;
return
ret
.
forget
(
)
;
}
void
nsHTMLStyleSheet
:
:
DropMappedAttributes
(
nsMappedAttributes
*
aMapped
)
{
NS_ENSURE_TRUE_VOID
(
aMapped
)
;
#
ifdef
DEBUG
uint32_t
entryCount
=
mMappedAttrTable
.
EntryCount
(
)
-
1
;
#
endif
mMappedAttrTable
.
Remove
(
aMapped
)
;
NS_ASSERTION
(
entryCount
=
=
mMappedAttrTable
.
EntryCount
(
)
"
not
removed
"
)
;
}
void
nsHTMLStyleSheet
:
:
CalculateMappedServoDeclarations
(
)
{
for
(
auto
iter
=
mMappedAttrTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
MappedAttrTableEntry
*
attr
=
static_cast
<
MappedAttrTableEntry
*
>
(
iter
.
Get
(
)
)
;
if
(
attr
-
>
mAttributes
-
>
GetServoStyle
(
)
)
{
continue
;
}
attr
-
>
mAttributes
-
>
LazilyResolveServoDeclaration
(
mDocument
)
;
}
}
#
ifdef
MOZ_OLD_STYLE
nsIStyleRule
*
nsHTMLStyleSheet
:
:
LangRuleFor
(
const
nsAtom
*
aLanguage
)
{
auto
entry
=
static_cast
<
LangRuleTableEntry
*
>
(
mLangRuleTable
.
Add
(
aLanguage
fallible
)
)
;
if
(
!
entry
)
{
NS_ASSERTION
(
false
"
out
of
memory
"
)
;
return
nullptr
;
}
return
entry
-
>
mRule
;
}
#
endif
size_t
nsHTMLStyleSheet
:
:
DOMSizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mMappedAttrTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mMappedAttrTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
MappedAttrTableEntry
*
>
(
iter
.
Get
(
)
)
;
n
+
=
entry
-
>
mAttributes
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
