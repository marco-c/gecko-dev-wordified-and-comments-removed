#
ifndef
nsCSSPropertyIDSet_h__
#
define
nsCSSPropertyIDSet_h__
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
<
limits
.
h
>
#
include
<
initializer_list
>
#
include
"
mozilla
/
CompositorAnimatableProperties
.
h
"
class
nsCSSPropertyIDSet
{
public
:
nsCSSPropertyIDSet
(
)
{
Empty
(
)
;
}
explicit
constexpr
nsCSSPropertyIDSet
(
std
:
:
initializer_list
<
nsCSSPropertyID
>
aProperties
)
:
mProperties
{
0
}
{
for
(
auto
property
:
aProperties
)
{
size_t
p
=
property
;
mProperties
[
p
/
kBitsInChunk
]
|
=
property_set_type
(
1
)
<
<
(
p
%
kBitsInChunk
)
;
}
}
void
AssertInSetRange
(
nsCSSPropertyID
aProperty
)
const
{
NS_ASSERTION
(
0
<
=
aProperty
&
&
aProperty
<
eCSSProperty_COUNT_no_shorthands
"
out
of
bounds
"
)
;
}
void
AddProperty
(
nsCSSPropertyID
aProperty
)
{
AssertInSetRange
(
aProperty
)
;
size_t
p
=
aProperty
;
mProperties
[
p
/
kBitsInChunk
]
|
=
property_set_type
(
1
)
<
<
(
p
%
kBitsInChunk
)
;
}
void
RemoveProperty
(
nsCSSPropertyID
aProperty
)
{
AssertInSetRange
(
aProperty
)
;
size_t
p
=
aProperty
;
mProperties
[
p
/
kBitsInChunk
]
&
=
~
(
property_set_type
(
1
)
<
<
(
p
%
kBitsInChunk
)
)
;
}
bool
HasProperty
(
nsCSSPropertyID
aProperty
)
const
{
AssertInSetRange
(
aProperty
)
;
size_t
p
=
aProperty
;
return
(
mProperties
[
p
/
kBitsInChunk
]
&
(
property_set_type
(
1
)
<
<
(
p
%
kBitsInChunk
)
)
)
!
=
0
;
}
static
constexpr
nsCSSPropertyIDSet
CompositorAnimatables
(
)
{
return
nsCSSPropertyIDSet
(
COMPOSITOR_ANIMATABLE_PROPERTY_LIST
)
;
}
static
constexpr
size_t
CompositorAnimatableCount
(
)
{
auto
list
=
COMPOSITOR_ANIMATABLE_PROPERTY_LIST
;
return
list
.
size
(
)
;
}
bool
Intersects
(
const
nsCSSPropertyIDSet
&
aOther
)
const
{
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mProperties
)
;
+
+
i
)
{
if
(
mProperties
[
i
]
&
aOther
.
mProperties
[
i
]
)
{
return
true
;
}
}
return
false
;
}
void
Empty
(
)
{
memset
(
mProperties
0
sizeof
(
mProperties
)
)
;
}
void
AssertIsEmpty
(
const
char
*
aText
)
const
{
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mProperties
)
;
+
+
i
)
{
NS_ASSERTION
(
mProperties
[
i
]
=
=
0
aText
)
;
}
}
bool
Equals
(
const
nsCSSPropertyIDSet
&
aOther
)
const
{
return
mozilla
:
:
ArrayEqual
(
mProperties
aOther
.
mProperties
)
;
}
bool
IsEmpty
(
)
const
{
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mProperties
)
;
+
+
i
)
{
if
(
mProperties
[
i
]
!
=
0
)
{
return
false
;
}
}
return
true
;
}
nsCSSPropertyIDSet
Inverse
(
)
const
{
nsCSSPropertyIDSet
result
;
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mProperties
)
;
+
+
i
)
{
result
.
mProperties
[
i
]
=
~
mProperties
[
i
]
;
}
return
result
;
}
nsCSSPropertyIDSet
Intersect
(
const
nsCSSPropertyIDSet
&
aOther
)
const
{
nsCSSPropertyIDSet
result
;
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mProperties
)
;
+
+
i
)
{
result
.
mProperties
[
i
]
=
mProperties
[
i
]
&
aOther
.
mProperties
[
i
]
;
}
return
result
;
}
nsCSSPropertyIDSet
Xor
(
const
nsCSSPropertyIDSet
&
aOther
)
const
{
nsCSSPropertyIDSet
result
;
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
mProperties
)
;
+
+
i
)
{
result
.
mProperties
[
i
]
=
mProperties
[
i
]
^
aOther
.
mProperties
[
i
]
;
}
return
result
;
}
private
:
typedef
unsigned
long
property_set_type
;
public
:
static
const
size_t
kBitsInChunk
=
sizeof
(
property_set_type
)
*
CHAR_BIT
;
static
const
size_t
kChunkCount
=
(
eCSSProperty_COUNT_no_shorthands
+
kBitsInChunk
-
1
)
/
kBitsInChunk
;
bool
HasPropertyInChunk
(
size_t
aChunk
)
const
{
return
mProperties
[
aChunk
]
!
=
0
;
}
bool
HasPropertyAt
(
size_t
aChunk
size_t
aBit
)
const
{
return
(
mProperties
[
aChunk
]
&
(
property_set_type
(
1
)
<
<
aBit
)
)
!
=
0
;
}
static
nsCSSPropertyID
CSSPropertyAt
(
size_t
aChunk
size_t
aBit
)
{
return
nsCSSPropertyID
(
aChunk
*
kBitsInChunk
+
aBit
)
;
}
private
:
property_set_type
mProperties
[
kChunkCount
]
;
}
;
#
endif
