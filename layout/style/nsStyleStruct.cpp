#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIAppShellService
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
CounterStyleManager
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
ImageTracker
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
PreferenceSheet
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
<
algorithm
>
#
include
"
ImageLoader
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
const
nscoord
kMediumBorderWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
3
)
;
static
constexpr
size_t
kStyleStructSizeLimit
=
504
;
template
<
typename
Struct
size_t
Actual
size_t
Limit
>
struct
AssertSizeIsLessThan
{
static_assert
(
Actual
=
=
sizeof
(
Struct
)
"
Bogus
invocation
"
)
;
static_assert
(
Actual
<
=
Limit
"
Style
struct
became
larger
than
the
size
limit
"
)
;
static
constexpr
bool
instantiate
=
true
;
}
;
#
define
STYLE_STRUCT
(
name_
)
\
static_assert
(
AssertSizeIsLessThan
<
nsStyle
#
#
name_
sizeof
(
nsStyle
#
#
name_
)
\
kStyleStructSizeLimit
>
:
:
instantiate
\
"
"
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
static
bool
DefinitelyEqualImages
(
const
nsStyleImageRequest
*
aRequest1
const
nsStyleImageRequest
*
aRequest2
)
{
if
(
aRequest1
=
=
aRequest2
)
{
return
true
;
}
if
(
!
aRequest1
|
|
!
aRequest2
)
{
return
false
;
}
return
aRequest1
-
>
DefinitelyEquals
(
*
aRequest2
)
;
}
bool
StyleCssUrlData
:
:
operator
=
=
(
const
StyleCssUrlData
&
aOther
)
const
{
const
auto
&
extra
=
extra_data
.
get
(
)
;
const
auto
&
otherExtra
=
aOther
.
extra_data
.
get
(
)
;
if
(
extra
.
BaseURI
(
)
!
=
otherExtra
.
BaseURI
(
)
|
|
extra
.
Principal
(
)
!
=
otherExtra
.
Principal
(
)
|
|
cors_mode
!
=
aOther
.
cors_mode
)
{
return
false
;
}
return
serialization
=
=
aOther
.
serialization
;
}
StyleLoadData
:
:
~
StyleLoadData
(
)
{
if
(
load_id
!
=
0
)
{
css
:
:
ImageLoader
:
:
DeregisterCSSImageFromAllLoaders
(
*
this
)
;
}
}
already_AddRefed
<
nsIURI
>
StyleComputedUrl
:
:
ResolveLocalRef
(
nsIURI
*
aURI
)
const
{
nsCOMPtr
<
nsIURI
>
result
=
GetURI
(
)
;
if
(
result
&
&
IsLocalRef
(
)
)
{
nsCString
ref
;
result
-
>
GetRef
(
ref
)
;
nsresult
rv
=
NS_MutateURI
(
aURI
)
.
SetRef
(
ref
)
.
Finalize
(
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
result
=
aURI
;
}
}
return
result
.
forget
(
)
;
}
already_AddRefed
<
nsIURI
>
StyleComputedUrl
:
:
ResolveLocalRef
(
const
nsIContent
*
aContent
)
const
{
return
ResolveLocalRef
(
aContent
-
>
GetBaseURI
(
)
)
;
}
imgRequestProxy
*
StyleComputedUrl
:
:
LoadImage
(
Document
&
aDocument
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
static
uint64_t
sNextLoadID
=
1
;
StyleLoadData
&
data
=
LoadData
(
)
;
if
(
data
.
load_id
=
=
0
)
{
data
.
load_id
=
sNextLoadID
+
+
;
}
Document
*
loadingDoc
=
aDocument
.
GetOriginalDocument
(
)
;
if
(
!
loadingDoc
)
{
loadingDoc
=
&
aDocument
;
}
css
:
:
ImageLoader
:
:
LoadImage
(
*
this
*
loadingDoc
)
;
return
aDocument
.
StyleImageLoader
(
)
-
>
RegisterCSSImage
(
data
)
;
}
nsStyleFont
:
:
nsStyleFont
(
const
nsStyleFont
&
aSrc
)
:
mFont
(
aSrc
.
mFont
)
mSize
(
aSrc
.
mSize
)
mFontSizeFactor
(
aSrc
.
mFontSizeFactor
)
mFontSizeOffset
(
aSrc
.
mFontSizeOffset
)
mFontSizeKeyword
(
aSrc
.
mFontSizeKeyword
)
mGenericID
(
aSrc
.
mGenericID
)
mScriptLevel
(
aSrc
.
mScriptLevel
)
mMathVariant
(
aSrc
.
mMathVariant
)
mMathDisplay
(
aSrc
.
mMathDisplay
)
mMinFontSizeRatio
(
aSrc
.
mMinFontSizeRatio
)
mExplicitLanguage
(
aSrc
.
mExplicitLanguage
)
mAllowZoom
(
aSrc
.
mAllowZoom
)
mScriptUnconstrainedSize
(
aSrc
.
mScriptUnconstrainedSize
)
mScriptMinSize
(
aSrc
.
mScriptMinSize
)
mScriptSizeMultiplier
(
aSrc
.
mScriptSizeMultiplier
)
mLanguage
(
aSrc
.
mLanguage
)
{
MOZ_COUNT_CTOR
(
nsStyleFont
)
;
}
nsStyleFont
:
:
nsStyleFont
(
const
Document
&
aDocument
)
:
mFont
(
*
aDocument
.
GetFontPrefsForLang
(
nullptr
)
-
>
GetDefaultFont
(
StyleGenericFontFamily
:
:
None
)
)
mSize
(
ZoomText
(
aDocument
mFont
.
size
)
)
mFontSizeFactor
(
1
.
0
)
mFontSizeOffset
(
0
)
mFontSizeKeyword
(
NS_STYLE_FONT_SIZE_MEDIUM
)
mGenericID
(
StyleGenericFontFamily
:
:
None
)
mScriptLevel
(
0
)
mMathVariant
(
NS_MATHML_MATHVARIANT_NONE
)
mMathDisplay
(
NS_MATHML_DISPLAYSTYLE_INLINE
)
mMinFontSizeRatio
(
100
)
mExplicitLanguage
(
false
)
mAllowZoom
(
true
)
mScriptUnconstrainedSize
(
mSize
)
mScriptMinSize
(
nsPresContext
:
:
CSSTwipsToAppUnits
(
NS_POINTS_TO_TWIPS
(
NS_MATHML_DEFAULT_SCRIPT_MIN_SIZE_PT
)
)
)
mScriptSizeMultiplier
(
NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER
)
mLanguage
(
aDocument
.
GetLanguageForStyle
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleFont
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mFont
.
size
=
mSize
;
if
(
!
nsContentUtils
:
:
IsChromeDoc
(
&
aDocument
)
)
{
nscoord
minimumFontSize
=
aDocument
.
GetFontPrefsForLang
(
mLanguage
)
-
>
mMinimumFontSize
;
mFont
.
size
=
std
:
:
max
(
mSize
minimumFontSize
)
;
}
}
nsChangeHint
nsStyleFont
:
:
CalcDifference
(
const
nsStyleFont
&
aNewData
)
const
{
MOZ_ASSERT
(
mAllowZoom
=
=
aNewData
.
mAllowZoom
"
expected
mAllowZoom
to
be
the
same
on
both
nsStyleFonts
"
)
;
if
(
mSize
!
=
aNewData
.
mSize
|
|
mLanguage
!
=
aNewData
.
mLanguage
|
|
mExplicitLanguage
!
=
aNewData
.
mExplicitLanguage
|
|
mMathVariant
!
=
aNewData
.
mMathVariant
|
|
mMathDisplay
!
=
aNewData
.
mMathDisplay
|
|
mMinFontSizeRatio
!
=
aNewData
.
mMinFontSizeRatio
)
{
return
NS_STYLE_HINT_REFLOW
;
}
switch
(
mFont
.
CalcDifference
(
aNewData
.
mFont
)
)
{
case
nsFont
:
:
MaxDifference
:
:
eLayoutAffecting
:
return
NS_STYLE_HINT_REFLOW
;
case
nsFont
:
:
MaxDifference
:
:
eVisual
:
return
NS_STYLE_HINT_VISUAL
;
case
nsFont
:
:
MaxDifference
:
:
eNone
:
break
;
}
if
(
mGenericID
!
=
aNewData
.
mGenericID
|
|
mScriptLevel
!
=
aNewData
.
mScriptLevel
|
|
mScriptUnconstrainedSize
!
=
aNewData
.
mScriptUnconstrainedSize
|
|
mScriptMinSize
!
=
aNewData
.
mScriptMinSize
|
|
mScriptSizeMultiplier
!
=
aNewData
.
mScriptSizeMultiplier
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
nscoord
nsStyleFont
:
:
ZoomText
(
const
Document
&
aDocument
nscoord
aSize
)
{
float
textZoom
=
1
.
0
;
if
(
auto
*
pc
=
aDocument
.
GetPresContext
(
)
)
{
textZoom
=
pc
-
>
EffectiveTextZoom
(
)
;
}
return
NSToCoordTruncClamped
(
float
(
aSize
)
*
textZoom
)
;
}
template
<
typename
T
>
static
StyleRect
<
T
>
StyleRectWithAllSides
(
const
T
&
aSide
)
{
return
{
aSide
aSide
aSide
aSide
}
;
}
nsStyleMargin
:
:
nsStyleMargin
(
const
Document
&
aDocument
)
:
mMargin
(
StyleRectWithAllSides
(
LengthPercentageOrAuto
:
:
LengthPercentage
(
LengthPercentage
:
:
Zero
(
)
)
)
)
mScrollMargin
(
StyleRectWithAllSides
(
StyleLength
{
0
.
}
)
)
{
MOZ_COUNT_CTOR
(
nsStyleMargin
)
;
}
nsStyleMargin
:
:
nsStyleMargin
(
const
nsStyleMargin
&
aSrc
)
:
mMargin
(
aSrc
.
mMargin
)
mScrollMargin
(
aSrc
.
mScrollMargin
)
{
MOZ_COUNT_CTOR
(
nsStyleMargin
)
;
}
nsChangeHint
nsStyleMargin
:
:
CalcDifference
(
const
nsStyleMargin
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mMargin
!
=
aNewData
.
mMargin
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_ReflowChangesSizeOrPosition
|
nsChangeHint_ClearAncestorIntrinsics
;
}
if
(
mScrollMargin
!
=
aNewData
.
mScrollMargin
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
nsStylePadding
:
:
nsStylePadding
(
const
Document
&
aDocument
)
:
mPadding
(
StyleRectWithAllSides
(
LengthPercentage
:
:
Zero
(
)
)
)
mScrollPadding
(
StyleRectWithAllSides
(
LengthPercentageOrAuto
:
:
Auto
(
)
)
)
{
MOZ_COUNT_CTOR
(
nsStylePadding
)
;
}
nsStylePadding
:
:
nsStylePadding
(
const
nsStylePadding
&
aSrc
)
:
mPadding
(
aSrc
.
mPadding
)
mScrollPadding
(
aSrc
.
mScrollPadding
)
{
MOZ_COUNT_CTOR
(
nsStylePadding
)
;
}
nsChangeHint
nsStylePadding
:
:
CalcDifference
(
const
nsStylePadding
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mPadding
!
=
aNewData
.
mPadding
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
&
~
nsChangeHint_ClearDescendantIntrinsics
;
}
if
(
mScrollPadding
!
=
aNewData
.
mScrollPadding
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
static
nscoord
TwipsPerPixel
(
const
Document
&
aDocument
)
{
auto
*
pc
=
aDocument
.
GetPresContext
(
)
;
return
pc
?
pc
-
>
AppUnitsPerDevPixel
(
)
:
mozilla
:
:
AppUnitsPerCSSPixel
(
)
;
}
static
inline
BorderRadius
ZeroBorderRadius
(
)
{
auto
zero
=
LengthPercentage
:
:
Zero
(
)
;
return
{
{
{
zero
zero
}
}
{
{
zero
zero
}
}
{
{
zero
zero
}
}
{
{
zero
zero
}
}
}
;
}
nsStyleBorder
:
:
nsStyleBorder
(
const
Document
&
aDocument
)
:
mBorderRadius
(
ZeroBorderRadius
(
)
)
mBorderImageWidth
(
StyleRectWithAllSides
(
StyleBorderImageSideWidth
:
:
Number
(
1
.
)
)
)
mBorderImageOutset
(
StyleRectWithAllSides
(
StyleNonNegativeLengthOrNumber
:
:
Number
(
0
.
)
)
)
mBorderImageSlice
(
{
StyleRectWithAllSides
(
StyleNumberOrPercentage
:
:
Percentage
(
{
1
.
}
)
)
false
}
)
mBorderImageRepeatH
(
StyleBorderImageRepeat
:
:
Stretch
)
mBorderImageRepeatV
(
StyleBorderImageRepeat
:
:
Stretch
)
mFloatEdge
(
StyleFloatEdge
:
:
ContentBox
)
mBoxDecorationBreak
(
StyleBoxDecorationBreak
:
:
Slice
)
mBorderTopColor
(
StyleColor
:
:
CurrentColor
(
)
)
mBorderRightColor
(
StyleColor
:
:
CurrentColor
(
)
)
mBorderBottomColor
(
StyleColor
:
:
CurrentColor
(
)
)
mBorderLeftColor
(
StyleColor
:
:
CurrentColor
(
)
)
mComputedBorder
(
0
0
0
0
)
mTwipsPerPixel
(
TwipsPerPixel
(
aDocument
)
)
{
MOZ_COUNT_CTOR
(
nsStyleBorder
)
;
nscoord
medium
=
kMediumBorderWidth
;
NS_FOR_CSS_SIDES
(
side
)
{
mBorder
.
Side
(
side
)
=
medium
;
mBorderStyle
[
side
]
=
StyleBorderStyle
:
:
None
;
}
}
nsStyleBorder
:
:
nsStyleBorder
(
const
nsStyleBorder
&
aSrc
)
:
mBorderRadius
(
aSrc
.
mBorderRadius
)
mBorderImageSource
(
aSrc
.
mBorderImageSource
)
mBorderImageWidth
(
aSrc
.
mBorderImageWidth
)
mBorderImageOutset
(
aSrc
.
mBorderImageOutset
)
mBorderImageSlice
(
aSrc
.
mBorderImageSlice
)
mBorderImageRepeatH
(
aSrc
.
mBorderImageRepeatH
)
mBorderImageRepeatV
(
aSrc
.
mBorderImageRepeatV
)
mFloatEdge
(
aSrc
.
mFloatEdge
)
mBoxDecorationBreak
(
aSrc
.
mBoxDecorationBreak
)
mBorderTopColor
(
aSrc
.
mBorderTopColor
)
mBorderRightColor
(
aSrc
.
mBorderRightColor
)
mBorderBottomColor
(
aSrc
.
mBorderBottomColor
)
mBorderLeftColor
(
aSrc
.
mBorderLeftColor
)
mComputedBorder
(
aSrc
.
mComputedBorder
)
mBorder
(
aSrc
.
mBorder
)
mTwipsPerPixel
(
aSrc
.
mTwipsPerPixel
)
{
MOZ_COUNT_CTOR
(
nsStyleBorder
)
;
NS_FOR_CSS_SIDES
(
side
)
{
mBorderStyle
[
side
]
=
aSrc
.
mBorderStyle
[
side
]
;
}
}
nsStyleBorder
:
:
~
nsStyleBorder
(
)
{
MOZ_COUNT_DTOR
(
nsStyleBorder
)
;
}
void
nsStyleBorder
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleBorder
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mBorderImageSource
.
ResolveImage
(
aDocument
aOldStyle
?
&
aOldStyle
-
>
mBorderImageSource
:
nullptr
)
;
}
nsMargin
nsStyleBorder
:
:
GetImageOutset
(
)
const
{
nsMargin
outset
;
NS_FOR_CSS_SIDES
(
s
)
{
const
auto
&
coord
=
mBorderImageOutset
.
Get
(
s
)
;
nscoord
value
;
if
(
coord
.
IsLength
(
)
)
{
value
=
coord
.
AsLength
(
)
.
ToAppUnits
(
)
;
}
else
{
MOZ_ASSERT
(
coord
.
IsNumber
(
)
)
;
value
=
coord
.
AsNumber
(
)
*
mComputedBorder
.
Side
(
s
)
;
}
outset
.
Side
(
s
)
=
value
;
}
return
outset
;
}
nsChangeHint
nsStyleBorder
:
:
CalcDifference
(
const
nsStyleBorder
&
aNewData
)
const
{
if
(
mTwipsPerPixel
!
=
aNewData
.
mTwipsPerPixel
|
|
GetComputedBorder
(
)
!
=
aNewData
.
GetComputedBorder
(
)
|
|
mFloatEdge
!
=
aNewData
.
mFloatEdge
|
|
mBorderImageOutset
!
=
aNewData
.
mBorderImageOutset
|
|
mBoxDecorationBreak
!
=
aNewData
.
mBoxDecorationBreak
)
{
return
NS_STYLE_HINT_REFLOW
;
}
NS_FOR_CSS_SIDES
(
ix
)
{
if
(
HasVisibleStyle
(
ix
)
!
=
aNewData
.
HasVisibleStyle
(
ix
)
)
{
return
nsChangeHint_RepaintFrame
|
nsChangeHint_BorderStyleNoneChange
;
}
}
NS_FOR_CSS_SIDES
(
ix
)
{
if
(
mBorderStyle
[
ix
]
!
=
aNewData
.
mBorderStyle
[
ix
]
|
|
BorderColorFor
(
ix
)
!
=
aNewData
.
BorderColorFor
(
ix
)
)
{
return
nsChangeHint_RepaintFrame
;
}
}
if
(
mBorderRadius
!
=
aNewData
.
mBorderRadius
)
{
return
nsChangeHint_RepaintFrame
;
}
if
(
!
mBorderImageSource
.
IsEmpty
(
)
|
|
!
aNewData
.
mBorderImageSource
.
IsEmpty
(
)
)
{
if
(
mBorderImageSource
!
=
aNewData
.
mBorderImageSource
|
|
mBorderImageRepeatH
!
=
aNewData
.
mBorderImageRepeatH
|
|
mBorderImageRepeatV
!
=
aNewData
.
mBorderImageRepeatV
|
|
mBorderImageSlice
!
=
aNewData
.
mBorderImageSlice
|
|
mBorderImageWidth
!
=
aNewData
.
mBorderImageWidth
)
{
return
nsChangeHint_RepaintFrame
;
}
}
if
(
mBorder
!
=
aNewData
.
mBorder
)
{
return
nsChangeHint_NeutralChange
;
}
if
(
mBorderImageSource
!
=
aNewData
.
mBorderImageSource
|
|
mBorderImageRepeatH
!
=
aNewData
.
mBorderImageRepeatH
|
|
mBorderImageRepeatV
!
=
aNewData
.
mBorderImageRepeatV
|
|
mBorderImageSlice
!
=
aNewData
.
mBorderImageSlice
|
|
mBorderImageWidth
!
=
aNewData
.
mBorderImageWidth
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
nsStyleOutline
:
:
nsStyleOutline
(
const
Document
&
aDocument
)
:
mOutlineRadius
(
ZeroBorderRadius
(
)
)
mOutlineWidth
(
kMediumBorderWidth
)
mOutlineOffset
(
{
0
.
0f
}
)
mOutlineColor
(
StyleColor
:
:
CurrentColor
(
)
)
mOutlineStyle
(
StyleOutlineStyle
:
:
BorderStyle
(
StyleBorderStyle
:
:
None
)
)
mActualOutlineWidth
(
0
)
mTwipsPerPixel
(
TwipsPerPixel
(
aDocument
)
)
{
MOZ_COUNT_CTOR
(
nsStyleOutline
)
;
}
nsStyleOutline
:
:
nsStyleOutline
(
const
nsStyleOutline
&
aSrc
)
:
mOutlineRadius
(
aSrc
.
mOutlineRadius
)
mOutlineWidth
(
aSrc
.
mOutlineWidth
)
mOutlineOffset
(
aSrc
.
mOutlineOffset
)
mOutlineColor
(
aSrc
.
mOutlineColor
)
mOutlineStyle
(
aSrc
.
mOutlineStyle
)
mActualOutlineWidth
(
aSrc
.
mActualOutlineWidth
)
mTwipsPerPixel
(
aSrc
.
mTwipsPerPixel
)
{
MOZ_COUNT_CTOR
(
nsStyleOutline
)
;
}
nsChangeHint
nsStyleOutline
:
:
CalcDifference
(
const
nsStyleOutline
&
aNewData
)
const
{
if
(
mActualOutlineWidth
!
=
aNewData
.
mActualOutlineWidth
|
|
(
mActualOutlineWidth
>
0
&
&
mOutlineOffset
!
=
aNewData
.
mOutlineOffset
)
)
{
return
nsChangeHint_UpdateOverflow
|
nsChangeHint_SchedulePaint
|
nsChangeHint_RepaintFrame
;
}
if
(
mOutlineStyle
!
=
aNewData
.
mOutlineStyle
|
|
mOutlineColor
!
=
aNewData
.
mOutlineColor
|
|
mOutlineRadius
!
=
aNewData
.
mOutlineRadius
)
{
if
(
mActualOutlineWidth
>
0
)
{
return
nsChangeHint_RepaintFrame
;
}
return
nsChangeHint_NeutralChange
;
}
if
(
mOutlineWidth
!
=
aNewData
.
mOutlineWidth
|
|
mOutlineOffset
!
=
aNewData
.
mOutlineOffset
|
|
mTwipsPerPixel
!
=
aNewData
.
mTwipsPerPixel
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
nsStyleList
:
:
nsStyleList
(
const
Document
&
aDocument
)
:
mListStylePosition
(
NS_STYLE_LIST_STYLE_POSITION_OUTSIDE
)
mQuotes
(
StyleQuotes
:
:
Auto
(
)
)
mImageRegion
(
StyleClipRectOrAuto
:
:
Auto
(
)
)
mMozListReversed
(
StyleMozListReversed
:
:
False
)
{
MOZ_COUNT_CTOR
(
nsStyleList
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCounterStyle
=
nsGkAtoms
:
:
disc
;
}
nsStyleList
:
:
~
nsStyleList
(
)
{
MOZ_COUNT_DTOR
(
nsStyleList
)
;
}
nsStyleList
:
:
nsStyleList
(
const
nsStyleList
&
aSource
)
:
mListStylePosition
(
aSource
.
mListStylePosition
)
mListStyleImage
(
aSource
.
mListStyleImage
)
mCounterStyle
(
aSource
.
mCounterStyle
)
mQuotes
(
aSource
.
mQuotes
)
mImageRegion
(
aSource
.
mImageRegion
)
mMozListReversed
(
aSource
.
mMozListReversed
)
{
MOZ_COUNT_CTOR
(
nsStyleList
)
;
}
void
nsStyleList
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleList
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mListStyleImage
&
&
!
mListStyleImage
-
>
IsResolved
(
)
)
{
mListStyleImage
-
>
Resolve
(
aDocument
aOldStyle
?
aOldStyle
-
>
mListStyleImage
.
get
(
)
:
nullptr
)
;
}
}
nsChangeHint
nsStyleList
:
:
CalcDifference
(
const
nsStyleList
&
aNewData
const
nsStyleDisplay
&
aOldDisplay
)
const
{
if
(
mQuotes
!
=
aNewData
.
mQuotes
)
{
return
nsChangeHint_ReconstructFrame
;
}
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
aOldDisplay
.
IsListItem
(
)
)
{
if
(
mListStylePosition
!
=
aNewData
.
mListStylePosition
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
mCounterStyle
!
=
aNewData
.
mCounterStyle
)
{
return
NS_STYLE_HINT_REFLOW
;
}
}
else
if
(
mListStylePosition
!
=
aNewData
.
mListStylePosition
|
|
mCounterStyle
!
=
aNewData
.
mCounterStyle
)
{
hint
=
nsChangeHint_NeutralChange
;
}
if
(
mMozListReversed
!
=
aNewData
.
mMozListReversed
)
{
return
NS_STYLE_HINT_REFLOW
;
}
if
(
!
DefinitelyEqualImages
(
mListStyleImage
aNewData
.
mListStyleImage
)
)
{
return
NS_STYLE_HINT_REFLOW
;
}
if
(
mImageRegion
!
=
aNewData
.
mImageRegion
)
{
nsRect
region
=
GetImageRegion
(
)
;
nsRect
newRegion
=
aNewData
.
GetImageRegion
(
)
;
if
(
region
.
width
!
=
newRegion
.
width
|
|
region
.
height
!
=
newRegion
.
height
)
{
return
NS_STYLE_HINT_REFLOW
;
}
return
NS_STYLE_HINT_VISUAL
;
}
return
hint
;
}
already_AddRefed
<
nsIURI
>
nsStyleList
:
:
GetListStyleImageURI
(
)
const
{
if
(
!
mListStyleImage
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
=
mListStyleImage
-
>
GetImageURI
(
)
;
return
uri
.
forget
(
)
;
}
nsStyleXUL
:
:
nsStyleXUL
(
const
Document
&
aDocument
)
:
mBoxFlex
(
0
.
0f
)
mBoxOrdinal
(
1
)
mBoxAlign
(
StyleBoxAlign
:
:
Stretch
)
mBoxDirection
(
StyleBoxDirection
:
:
Normal
)
mBoxOrient
(
StyleBoxOrient
:
:
Horizontal
)
mBoxPack
(
StyleBoxPack
:
:
Start
)
mStackSizing
(
StyleStackSizing
:
:
StretchToFit
)
{
MOZ_COUNT_CTOR
(
nsStyleXUL
)
;
}
nsStyleXUL
:
:
~
nsStyleXUL
(
)
{
MOZ_COUNT_DTOR
(
nsStyleXUL
)
;
}
nsStyleXUL
:
:
nsStyleXUL
(
const
nsStyleXUL
&
aSource
)
:
mBoxFlex
(
aSource
.
mBoxFlex
)
mBoxOrdinal
(
aSource
.
mBoxOrdinal
)
mBoxAlign
(
aSource
.
mBoxAlign
)
mBoxDirection
(
aSource
.
mBoxDirection
)
mBoxOrient
(
aSource
.
mBoxOrient
)
mBoxPack
(
aSource
.
mBoxPack
)
mStackSizing
(
aSource
.
mStackSizing
)
{
MOZ_COUNT_CTOR
(
nsStyleXUL
)
;
}
nsChangeHint
nsStyleXUL
:
:
CalcDifference
(
const
nsStyleXUL
&
aNewData
)
const
{
if
(
mBoxAlign
=
=
aNewData
.
mBoxAlign
&
&
mBoxDirection
=
=
aNewData
.
mBoxDirection
&
&
mBoxFlex
=
=
aNewData
.
mBoxFlex
&
&
mBoxOrient
=
=
aNewData
.
mBoxOrient
&
&
mBoxPack
=
=
aNewData
.
mBoxPack
&
&
mBoxOrdinal
=
=
aNewData
.
mBoxOrdinal
&
&
mStackSizing
=
=
aNewData
.
mStackSizing
)
{
return
nsChangeHint
(
0
)
;
}
if
(
mBoxOrdinal
!
=
aNewData
.
mBoxOrdinal
)
{
return
nsChangeHint_ReconstructFrame
;
}
return
NS_STYLE_HINT_REFLOW
;
}
const
uint32_t
nsStyleColumn
:
:
kMaxColumnCount
;
const
uint32_t
nsStyleColumn
:
:
kColumnCountAuto
;
nsStyleColumn
:
:
nsStyleColumn
(
const
Document
&
aDocument
)
:
mColumnWidth
(
LengthOrAuto
:
:
Auto
(
)
)
mColumnRuleColor
(
StyleColor
:
:
CurrentColor
(
)
)
mColumnRuleStyle
(
StyleBorderStyle
:
:
None
)
mColumnRuleWidth
(
kMediumBorderWidth
)
mTwipsPerPixel
(
TwipsPerPixel
(
aDocument
)
)
{
MOZ_COUNT_CTOR
(
nsStyleColumn
)
;
}
nsStyleColumn
:
:
~
nsStyleColumn
(
)
{
MOZ_COUNT_DTOR
(
nsStyleColumn
)
;
}
nsStyleColumn
:
:
nsStyleColumn
(
const
nsStyleColumn
&
aSource
)
:
mColumnCount
(
aSource
.
mColumnCount
)
mColumnWidth
(
aSource
.
mColumnWidth
)
mColumnRuleColor
(
aSource
.
mColumnRuleColor
)
mColumnRuleStyle
(
aSource
.
mColumnRuleStyle
)
mColumnFill
(
aSource
.
mColumnFill
)
mColumnSpan
(
aSource
.
mColumnSpan
)
mColumnRuleWidth
(
aSource
.
mColumnRuleWidth
)
mTwipsPerPixel
(
aSource
.
mTwipsPerPixel
)
{
MOZ_COUNT_CTOR
(
nsStyleColumn
)
;
}
nsChangeHint
nsStyleColumn
:
:
CalcDifference
(
const
nsStyleColumn
&
aNewData
)
const
{
if
(
mColumnWidth
.
IsAuto
(
)
!
=
aNewData
.
mColumnWidth
.
IsAuto
(
)
|
|
mColumnCount
!
=
aNewData
.
mColumnCount
|
|
mColumnSpan
!
=
aNewData
.
mColumnSpan
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
mColumnWidth
!
=
aNewData
.
mColumnWidth
|
|
mColumnFill
!
=
aNewData
.
mColumnFill
)
{
return
NS_STYLE_HINT_REFLOW
;
}
if
(
GetComputedColumnRuleWidth
(
)
!
=
aNewData
.
GetComputedColumnRuleWidth
(
)
|
|
mColumnRuleStyle
!
=
aNewData
.
mColumnRuleStyle
|
|
mColumnRuleColor
!
=
aNewData
.
mColumnRuleColor
)
{
return
NS_STYLE_HINT_VISUAL
;
}
if
(
mColumnRuleWidth
!
=
aNewData
.
mColumnRuleWidth
|
|
mTwipsPerPixel
!
=
aNewData
.
mTwipsPerPixel
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
using
SVGPaintFallback
=
StyleGenericSVGPaintFallback
<
StyleColor
>
;
nsStyleSVG
:
:
nsStyleSVG
(
const
Document
&
aDocument
)
:
mFill
{
StyleSVGPaintKind
:
:
Color
(
StyleColor
:
:
Black
(
)
)
SVGPaintFallback
:
:
Unset
(
)
}
mStroke
{
StyleSVGPaintKind
:
:
None
(
)
SVGPaintFallback
:
:
Unset
(
)
}
mMarkerEnd
(
StyleUrlOrNone
:
:
None
(
)
)
mMarkerMid
(
StyleUrlOrNone
:
:
None
(
)
)
mMarkerStart
(
StyleUrlOrNone
:
:
None
(
)
)
mMozContextProperties
{
{
}
{
0
}
}
mStrokeDashoffset
(
LengthPercentage
:
:
Zero
(
)
)
mStrokeWidth
(
LengthPercentage
:
:
FromPixels
(
1
.
0f
)
)
mFillOpacity
(
1
.
0f
)
mStrokeMiterlimit
(
4
.
0f
)
mStrokeOpacity
(
1
.
0f
)
mClipRule
(
StyleFillRule
:
:
Nonzero
)
mColorInterpolation
(
NS_STYLE_COLOR_INTERPOLATION_SRGB
)
mColorInterpolationFilters
(
NS_STYLE_COLOR_INTERPOLATION_LINEARRGB
)
mFillRule
(
StyleFillRule
:
:
Nonzero
)
mPaintOrder
(
0
)
mShapeRendering
(
NS_STYLE_SHAPE_RENDERING_AUTO
)
mStrokeLinecap
(
NS_STYLE_STROKE_LINECAP_BUTT
)
mStrokeLinejoin
(
NS_STYLE_STROKE_LINEJOIN_MITER
)
mDominantBaseline
(
NS_STYLE_DOMINANT_BASELINE_AUTO
)
mTextAnchor
(
NS_STYLE_TEXT_ANCHOR_START
)
mContextFlags
(
(
eStyleSVGOpacitySource_Normal
<
<
FILL_OPACITY_SOURCE_SHIFT
)
|
(
eStyleSVGOpacitySource_Normal
<
<
STROKE_OPACITY_SOURCE_SHIFT
)
)
{
MOZ_COUNT_CTOR
(
nsStyleSVG
)
;
}
nsStyleSVG
:
:
~
nsStyleSVG
(
)
{
MOZ_COUNT_DTOR
(
nsStyleSVG
)
;
}
nsStyleSVG
:
:
nsStyleSVG
(
const
nsStyleSVG
&
aSource
)
:
mFill
(
aSource
.
mFill
)
mStroke
(
aSource
.
mStroke
)
mMarkerEnd
(
aSource
.
mMarkerEnd
)
mMarkerMid
(
aSource
.
mMarkerMid
)
mMarkerStart
(
aSource
.
mMarkerStart
)
mStrokeDasharray
(
aSource
.
mStrokeDasharray
)
mMozContextProperties
(
aSource
.
mMozContextProperties
)
mStrokeDashoffset
(
aSource
.
mStrokeDashoffset
)
mStrokeWidth
(
aSource
.
mStrokeWidth
)
mFillOpacity
(
aSource
.
mFillOpacity
)
mStrokeMiterlimit
(
aSource
.
mStrokeMiterlimit
)
mStrokeOpacity
(
aSource
.
mStrokeOpacity
)
mClipRule
(
aSource
.
mClipRule
)
mColorInterpolation
(
aSource
.
mColorInterpolation
)
mColorInterpolationFilters
(
aSource
.
mColorInterpolationFilters
)
mFillRule
(
aSource
.
mFillRule
)
mPaintOrder
(
aSource
.
mPaintOrder
)
mShapeRendering
(
aSource
.
mShapeRendering
)
mStrokeLinecap
(
aSource
.
mStrokeLinecap
)
mStrokeLinejoin
(
aSource
.
mStrokeLinejoin
)
mDominantBaseline
(
aSource
.
mDominantBaseline
)
mTextAnchor
(
aSource
.
mTextAnchor
)
mContextFlags
(
aSource
.
mContextFlags
)
{
MOZ_COUNT_CTOR
(
nsStyleSVG
)
;
}
static
bool
PaintURIChanged
(
const
StyleSVGPaint
&
aPaint1
const
StyleSVGPaint
&
aPaint2
)
{
if
(
aPaint1
.
kind
.
IsPaintServer
(
)
!
=
aPaint2
.
kind
.
IsPaintServer
(
)
)
{
return
true
;
}
return
aPaint1
.
kind
.
IsPaintServer
(
)
&
&
aPaint1
.
kind
.
AsPaintServer
(
)
!
=
aPaint2
.
kind
.
AsPaintServer
(
)
;
}
nsChangeHint
nsStyleSVG
:
:
CalcDifference
(
const
nsStyleSVG
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mMarkerEnd
!
=
aNewData
.
mMarkerEnd
|
|
mMarkerMid
!
=
aNewData
.
mMarkerMid
|
|
mMarkerStart
!
=
aNewData
.
mMarkerStart
)
{
return
nsChangeHint_UpdateEffects
|
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
|
nsChangeHint_RepaintFrame
;
}
if
(
mFill
!
=
aNewData
.
mFill
|
|
mStroke
!
=
aNewData
.
mStroke
|
|
mFillOpacity
!
=
aNewData
.
mFillOpacity
|
|
mStrokeOpacity
!
=
aNewData
.
mStrokeOpacity
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
if
(
HasStroke
(
)
!
=
aNewData
.
HasStroke
(
)
|
|
(
!
HasStroke
(
)
&
&
HasFill
(
)
!
=
aNewData
.
HasFill
(
)
)
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
;
}
if
(
PaintURIChanged
(
mFill
aNewData
.
mFill
)
|
|
PaintURIChanged
(
mStroke
aNewData
.
mStroke
)
)
{
hint
|
=
nsChangeHint_UpdateEffects
;
}
}
if
(
mStrokeWidth
!
=
aNewData
.
mStrokeWidth
|
|
mStrokeMiterlimit
!
=
aNewData
.
mStrokeMiterlimit
|
|
mStrokeLinecap
!
=
aNewData
.
mStrokeLinecap
|
|
mStrokeLinejoin
!
=
aNewData
.
mStrokeLinejoin
|
|
mDominantBaseline
!
=
aNewData
.
mDominantBaseline
|
|
mTextAnchor
!
=
aNewData
.
mTextAnchor
)
{
return
hint
|
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
|
nsChangeHint_RepaintFrame
;
}
if
(
hint
&
nsChangeHint_RepaintFrame
)
{
return
hint
;
}
if
(
mStrokeDashoffset
!
=
aNewData
.
mStrokeDashoffset
|
|
mClipRule
!
=
aNewData
.
mClipRule
|
|
mColorInterpolation
!
=
aNewData
.
mColorInterpolation
|
|
mColorInterpolationFilters
!
=
aNewData
.
mColorInterpolationFilters
|
|
mFillRule
!
=
aNewData
.
mFillRule
|
|
mPaintOrder
!
=
aNewData
.
mPaintOrder
|
|
mShapeRendering
!
=
aNewData
.
mShapeRendering
|
|
mStrokeDasharray
!
=
aNewData
.
mStrokeDasharray
|
|
mContextFlags
!
=
aNewData
.
mContextFlags
|
|
mMozContextProperties
.
bits
!
=
aNewData
.
mMozContextProperties
.
bits
)
{
return
hint
|
nsChangeHint_RepaintFrame
;
}
if
(
!
hint
)
{
if
(
mMozContextProperties
.
idents
!
=
aNewData
.
mMozContextProperties
.
idents
)
{
hint
=
nsChangeHint_NeutralChange
;
}
}
return
hint
;
}
StyleShapeSource
:
:
StyleShapeSource
(
)
:
mBasicShape
(
)
{
}
StyleShapeSource
:
:
StyleShapeSource
(
const
StyleShapeSource
&
aSource
)
{
DoCopy
(
aSource
)
;
}
StyleShapeSource
:
:
~
StyleShapeSource
(
)
{
DoDestroy
(
)
;
}
StyleShapeSource
&
StyleShapeSource
:
:
operator
=
(
const
StyleShapeSource
&
aOther
)
{
if
(
this
!
=
&
aOther
)
{
DoCopy
(
aOther
)
;
}
return
*
this
;
}
bool
StyleShapeSource
:
:
operator
=
=
(
const
StyleShapeSource
&
aOther
)
const
{
if
(
mType
!
=
aOther
.
mType
)
{
return
false
;
}
switch
(
mType
)
{
case
StyleShapeSourceType
:
:
None
:
return
true
;
case
StyleShapeSourceType
:
:
Image
:
return
*
mShapeImage
=
=
*
aOther
.
mShapeImage
;
case
StyleShapeSourceType
:
:
Shape
:
return
*
mBasicShape
=
=
*
aOther
.
mBasicShape
&
&
mReferenceBox
=
=
aOther
.
mReferenceBox
;
case
StyleShapeSourceType
:
:
Box
:
return
mReferenceBox
=
=
aOther
.
mReferenceBox
;
case
StyleShapeSourceType
:
:
Path
:
return
*
mSVGPath
=
=
*
aOther
.
mSVGPath
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
shape
source
type
!
"
)
;
return
true
;
}
void
StyleShapeSource
:
:
SetShapeImage
(
UniquePtr
<
nsStyleImage
>
aShapeImage
)
{
MOZ_ASSERT
(
aShapeImage
)
;
DoDestroy
(
)
;
new
(
&
mShapeImage
)
UniquePtr
<
nsStyleImage
>
(
std
:
:
move
(
aShapeImage
)
)
;
mType
=
StyleShapeSourceType
:
:
Image
;
}
imgIRequest
*
StyleShapeSource
:
:
GetShapeImageData
(
)
const
{
if
(
mType
!
=
StyleShapeSourceType
:
:
Image
)
{
return
nullptr
;
}
if
(
mShapeImage
-
>
GetType
(
)
!
=
eStyleImageType_Image
)
{
return
nullptr
;
}
return
mShapeImage
-
>
GetImageData
(
)
;
}
void
StyleShapeSource
:
:
SetBasicShape
(
UniquePtr
<
StyleBasicShape
>
aBasicShape
StyleGeometryBox
aReferenceBox
)
{
MOZ_ASSERT
(
aBasicShape
)
;
DoDestroy
(
)
;
new
(
&
mBasicShape
)
UniquePtr
<
StyleBasicShape
>
(
std
:
:
move
(
aBasicShape
)
)
;
mReferenceBox
=
aReferenceBox
;
mType
=
StyleShapeSourceType
:
:
Shape
;
}
void
StyleShapeSource
:
:
SetPath
(
UniquePtr
<
StyleSVGPath
>
aPath
)
{
MOZ_ASSERT
(
aPath
)
;
DoDestroy
(
)
;
new
(
&
mSVGPath
)
UniquePtr
<
StyleSVGPath
>
(
std
:
:
move
(
aPath
)
)
;
mType
=
StyleShapeSourceType
:
:
Path
;
}
void
StyleShapeSource
:
:
TriggerImageLoads
(
Document
&
aDocument
const
StyleShapeSource
*
aOldShapeSource
)
{
if
(
GetType
(
)
!
=
StyleShapeSourceType
:
:
Image
)
{
return
;
}
auto
*
oldShapeImage
=
(
aOldShapeSource
&
&
aOldShapeSource
-
>
GetType
(
)
=
=
StyleShapeSourceType
:
:
Image
)
?
&
aOldShapeSource
-
>
ShapeImage
(
)
:
nullptr
;
mShapeImage
-
>
ResolveImage
(
aDocument
oldShapeImage
)
;
}
void
StyleShapeSource
:
:
SetReferenceBox
(
StyleGeometryBox
aReferenceBox
)
{
DoDestroy
(
)
;
mReferenceBox
=
aReferenceBox
;
mType
=
StyleShapeSourceType
:
:
Box
;
}
void
StyleShapeSource
:
:
DoCopy
(
const
StyleShapeSource
&
aOther
)
{
switch
(
aOther
.
mType
)
{
case
StyleShapeSourceType
:
:
None
:
mReferenceBox
=
StyleGeometryBox
:
:
NoBox
;
mType
=
StyleShapeSourceType
:
:
None
;
break
;
case
StyleShapeSourceType
:
:
Image
:
SetShapeImage
(
MakeUnique
<
nsStyleImage
>
(
aOther
.
ShapeImage
(
)
)
)
;
break
;
case
StyleShapeSourceType
:
:
Shape
:
{
UniquePtr
<
StyleBasicShape
>
shape
(
Servo_CloneBasicShape
(
&
aOther
.
BasicShape
(
)
)
)
;
SetBasicShape
(
std
:
:
move
(
shape
)
aOther
.
GetReferenceBox
(
)
)
;
break
;
}
case
StyleShapeSourceType
:
:
Box
:
SetReferenceBox
(
aOther
.
GetReferenceBox
(
)
)
;
break
;
case
StyleShapeSourceType
:
:
Path
:
SetPath
(
MakeUnique
<
StyleSVGPath
>
(
aOther
.
Path
(
)
)
)
;
break
;
}
}
void
StyleShapeSource
:
:
DoDestroy
(
)
{
switch
(
mType
)
{
case
StyleShapeSourceType
:
:
Shape
:
mBasicShape
.
~
UniquePtr
<
StyleBasicShape
>
(
)
;
break
;
case
StyleShapeSourceType
:
:
Image
:
mShapeImage
.
~
UniquePtr
<
nsStyleImage
>
(
)
;
break
;
case
StyleShapeSourceType
:
:
Path
:
mSVGPath
.
~
UniquePtr
<
StyleSVGPath
>
(
)
;
break
;
case
StyleShapeSourceType
:
:
None
:
case
StyleShapeSourceType
:
:
Box
:
break
;
}
mType
=
StyleShapeSourceType
:
:
None
;
}
nsStyleSVGReset
:
:
nsStyleSVGReset
(
const
Document
&
aDocument
)
:
mX
(
LengthPercentage
:
:
Zero
(
)
)
mY
(
LengthPercentage
:
:
Zero
(
)
)
mCx
(
LengthPercentage
:
:
Zero
(
)
)
mCy
(
LengthPercentage
:
:
Zero
(
)
)
mRx
(
NonNegativeLengthPercentageOrAuto
:
:
Auto
(
)
)
mRy
(
NonNegativeLengthPercentageOrAuto
:
:
Auto
(
)
)
mR
(
NonNegativeLengthPercentage
:
:
Zero
(
)
)
mMask
(
nsStyleImageLayers
:
:
LayerType
:
:
Mask
)
mStopColor
(
StyleColor
:
:
Black
(
)
)
mFloodColor
(
StyleColor
:
:
Black
(
)
)
mLightingColor
(
StyleColor
:
:
White
(
)
)
mStopOpacity
(
1
.
0f
)
mFloodOpacity
(
1
.
0f
)
mVectorEffect
(
NS_STYLE_VECTOR_EFFECT_NONE
)
mMaskType
(
NS_STYLE_MASK_TYPE_LUMINANCE
)
{
MOZ_COUNT_CTOR
(
nsStyleSVGReset
)
;
}
nsStyleSVGReset
:
:
~
nsStyleSVGReset
(
)
{
MOZ_COUNT_DTOR
(
nsStyleSVGReset
)
;
}
nsStyleSVGReset
:
:
nsStyleSVGReset
(
const
nsStyleSVGReset
&
aSource
)
:
mX
(
aSource
.
mX
)
mY
(
aSource
.
mY
)
mCx
(
aSource
.
mCx
)
mCy
(
aSource
.
mCy
)
mRx
(
aSource
.
mRx
)
mRy
(
aSource
.
mRy
)
mR
(
aSource
.
mR
)
mMask
(
aSource
.
mMask
)
mClipPath
(
aSource
.
mClipPath
)
mStopColor
(
aSource
.
mStopColor
)
mFloodColor
(
aSource
.
mFloodColor
)
mLightingColor
(
aSource
.
mLightingColor
)
mStopOpacity
(
aSource
.
mStopOpacity
)
mFloodOpacity
(
aSource
.
mFloodOpacity
)
mVectorEffect
(
aSource
.
mVectorEffect
)
mMaskType
(
aSource
.
mMaskType
)
{
MOZ_COUNT_CTOR
(
nsStyleSVGReset
)
;
}
void
nsStyleSVGReset
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleSVGReset
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
mMask
)
{
nsStyleImage
&
image
=
mMask
.
mLayers
[
i
]
.
mImage
;
if
(
image
.
GetType
(
)
=
=
eStyleImageType_Image
)
{
const
auto
*
url
=
image
.
GetURLValue
(
)
;
if
(
url
-
>
IsLocalRef
(
)
)
{
continue
;
}
#
if
0
nsIURI
*
docURI
=
aPresContext
-
>
Document
(
)
-
>
GetDocumentURI
(
)
;
if
(
url
-
>
EqualsExceptRef
(
docURI
)
)
{
continue
;
}
#
endif
const
nsStyleImage
*
oldImage
=
(
aOldStyle
&
&
aOldStyle
-
>
mMask
.
mLayers
.
Length
(
)
>
i
)
?
&
aOldStyle
-
>
mMask
.
mLayers
[
i
]
.
mImage
:
nullptr
;
image
.
ResolveImage
(
aDocument
oldImage
)
;
}
}
}
nsChangeHint
nsStyleSVGReset
:
:
CalcDifference
(
const
nsStyleSVGReset
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mX
!
=
aNewData
.
mX
|
|
mY
!
=
aNewData
.
mY
|
|
mCx
!
=
aNewData
.
mCx
|
|
mCy
!
=
aNewData
.
mCy
|
|
mR
!
=
aNewData
.
mR
|
|
mRx
!
=
aNewData
.
mRx
|
|
mRy
!
=
aNewData
.
mRy
)
{
hint
|
=
nsChangeHint_InvalidateRenderingObservers
|
nsChangeHint_NeedReflow
;
}
if
(
mClipPath
!
=
aNewData
.
mClipPath
)
{
hint
|
=
nsChangeHint_UpdateEffects
|
nsChangeHint_RepaintFrame
;
}
if
(
mVectorEffect
!
=
aNewData
.
mVectorEffect
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
|
nsChangeHint_RepaintFrame
;
}
else
if
(
mStopColor
!
=
aNewData
.
mStopColor
|
|
mFloodColor
!
=
aNewData
.
mFloodColor
|
|
mLightingColor
!
=
aNewData
.
mLightingColor
|
|
mStopOpacity
!
=
aNewData
.
mStopOpacity
|
|
mFloodOpacity
!
=
aNewData
.
mFloodOpacity
|
|
mMaskType
!
=
aNewData
.
mMaskType
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
hint
|
=
mMask
.
CalcDifference
(
aNewData
.
mMask
nsStyleImageLayers
:
:
LayerType
:
:
Mask
)
;
return
hint
;
}
bool
nsStyleSVGReset
:
:
HasMask
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mMask
.
mImageCount
;
i
+
+
)
{
if
(
!
mMask
.
mLayers
[
i
]
.
mImage
.
IsEmpty
(
)
)
{
return
true
;
}
}
return
false
;
}
nsStylePosition
:
:
nsStylePosition
(
const
Document
&
aDocument
)
:
mObjectPosition
(
Position
:
:
FromPercentage
(
0
.
5f
)
)
mOffset
(
StyleRectWithAllSides
(
LengthPercentageOrAuto
:
:
Auto
(
)
)
)
mWidth
(
StyleSize
:
:
Auto
(
)
)
mMinWidth
(
StyleSize
:
:
Auto
(
)
)
mMaxWidth
(
StyleMaxSize
:
:
None
(
)
)
mHeight
(
StyleSize
:
:
Auto
(
)
)
mMinHeight
(
StyleSize
:
:
Auto
(
)
)
mMaxHeight
(
StyleMaxSize
:
:
None
(
)
)
mFlexBasis
(
StyleFlexBasis
:
:
Size
(
StyleSize
:
:
Auto
(
)
)
)
mAspectRatio
(
0
.
0f
)
mGridAutoFlow
(
NS_STYLE_GRID_AUTO_FLOW_ROW
)
mBoxSizing
(
StyleBoxSizing
:
:
Content
)
mAlignContent
(
NS_STYLE_ALIGN_NORMAL
)
mAlignItems
(
NS_STYLE_ALIGN_NORMAL
)
mAlignSelf
(
NS_STYLE_ALIGN_AUTO
)
mJustifyContent
(
NS_STYLE_JUSTIFY_NORMAL
)
mSpecifiedJustifyItems
(
NS_STYLE_JUSTIFY_LEGACY
)
mJustifyItems
(
NS_STYLE_JUSTIFY_NORMAL
)
mJustifySelf
(
NS_STYLE_JUSTIFY_AUTO
)
mFlexDirection
(
StyleFlexDirection
:
:
Row
)
mFlexWrap
(
StyleFlexWrap
:
:
Nowrap
)
mObjectFit
(
NS_STYLE_OBJECT_FIT_FILL
)
mOrder
(
NS_STYLE_ORDER_INITIAL
)
mFlexGrow
(
0
.
0f
)
mFlexShrink
(
1
.
0f
)
mZIndex
(
StyleZIndex
:
:
Auto
(
)
)
mGridTemplateColumns
(
StyleGridTemplateComponent
:
:
None
(
)
)
mGridTemplateRows
(
StyleGridTemplateComponent
:
:
None
(
)
)
mGridTemplateAreas
(
StyleGridTemplateAreas
:
:
None
(
)
)
mColumnGap
(
NonNegativeLengthPercentageOrNormal
:
:
Normal
(
)
)
mRowGap
(
NonNegativeLengthPercentageOrNormal
:
:
Normal
(
)
)
{
MOZ_COUNT_CTOR
(
nsStylePosition
)
;
}
nsStylePosition
:
:
~
nsStylePosition
(
)
{
MOZ_COUNT_DTOR
(
nsStylePosition
)
;
}
nsStylePosition
:
:
nsStylePosition
(
const
nsStylePosition
&
aSource
)
:
mObjectPosition
(
aSource
.
mObjectPosition
)
mOffset
(
aSource
.
mOffset
)
mWidth
(
aSource
.
mWidth
)
mMinWidth
(
aSource
.
mMinWidth
)
mMaxWidth
(
aSource
.
mMaxWidth
)
mHeight
(
aSource
.
mHeight
)
mMinHeight
(
aSource
.
mMinHeight
)
mMaxHeight
(
aSource
.
mMaxHeight
)
mFlexBasis
(
aSource
.
mFlexBasis
)
mGridAutoColumns
(
aSource
.
mGridAutoColumns
)
mGridAutoRows
(
aSource
.
mGridAutoRows
)
mAspectRatio
(
aSource
.
mAspectRatio
)
mGridAutoFlow
(
aSource
.
mGridAutoFlow
)
mBoxSizing
(
aSource
.
mBoxSizing
)
mAlignContent
(
aSource
.
mAlignContent
)
mAlignItems
(
aSource
.
mAlignItems
)
mAlignSelf
(
aSource
.
mAlignSelf
)
mJustifyContent
(
aSource
.
mJustifyContent
)
mSpecifiedJustifyItems
(
aSource
.
mSpecifiedJustifyItems
)
mJustifyItems
(
aSource
.
mJustifyItems
)
mJustifySelf
(
aSource
.
mJustifySelf
)
mFlexDirection
(
aSource
.
mFlexDirection
)
mFlexWrap
(
aSource
.
mFlexWrap
)
mObjectFit
(
aSource
.
mObjectFit
)
mOrder
(
aSource
.
mOrder
)
mFlexGrow
(
aSource
.
mFlexGrow
)
mFlexShrink
(
aSource
.
mFlexShrink
)
mZIndex
(
aSource
.
mZIndex
)
mGridTemplateColumns
(
aSource
.
mGridTemplateColumns
)
mGridTemplateRows
(
aSource
.
mGridTemplateRows
)
mGridTemplateAreas
(
aSource
.
mGridTemplateAreas
)
mGridColumnStart
(
aSource
.
mGridColumnStart
)
mGridColumnEnd
(
aSource
.
mGridColumnEnd
)
mGridRowStart
(
aSource
.
mGridRowStart
)
mGridRowEnd
(
aSource
.
mGridRowEnd
)
mColumnGap
(
aSource
.
mColumnGap
)
mRowGap
(
aSource
.
mRowGap
)
{
MOZ_COUNT_CTOR
(
nsStylePosition
)
;
}
static
bool
IsAutonessEqual
(
const
StyleRect
<
LengthPercentageOrAuto
>
&
aSides1
const
StyleRect
<
LengthPercentageOrAuto
>
&
aSides2
)
{
NS_FOR_CSS_SIDES
(
side
)
{
if
(
aSides1
.
Get
(
side
)
.
IsAuto
(
)
!
=
aSides2
.
Get
(
side
)
.
IsAuto
(
)
)
{
return
false
;
}
}
return
true
;
}
nsChangeHint
nsStylePosition
:
:
CalcDifference
(
const
nsStylePosition
&
aNewData
const
nsStyleVisibility
&
aOldStyleVisibility
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mZIndex
!
=
aNewData
.
mZIndex
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mObjectFit
!
=
aNewData
.
mObjectFit
|
|
mObjectPosition
!
=
aNewData
.
mObjectPosition
)
{
hint
|
=
nsChangeHint_RepaintFrame
|
nsChangeHint_NeedReflow
;
}
if
(
mOrder
!
=
aNewData
.
mOrder
)
{
return
hint
|
nsChangeHint_RepaintFrame
|
nsChangeHint_AllReflowHints
;
}
if
(
mBoxSizing
!
=
aNewData
.
mBoxSizing
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mAlignSelf
!
=
aNewData
.
mAlignSelf
|
|
mFlexBasis
!
=
aNewData
.
mFlexBasis
|
|
mFlexGrow
!
=
aNewData
.
mFlexGrow
|
|
mFlexShrink
!
=
aNewData
.
mFlexShrink
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mAlignItems
!
=
aNewData
.
mAlignItems
|
|
mFlexDirection
!
=
aNewData
.
mFlexDirection
|
|
mFlexWrap
!
=
aNewData
.
mFlexWrap
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mGridTemplateColumns
!
=
aNewData
.
mGridTemplateColumns
|
|
mGridTemplateRows
!
=
aNewData
.
mGridTemplateRows
|
|
mGridTemplateAreas
!
=
aNewData
.
mGridTemplateAreas
|
|
mGridAutoColumns
!
=
aNewData
.
mGridAutoColumns
|
|
mGridAutoRows
!
=
aNewData
.
mGridAutoRows
|
|
mGridAutoFlow
!
=
aNewData
.
mGridAutoFlow
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mGridColumnStart
!
=
aNewData
.
mGridColumnStart
|
|
mGridColumnEnd
!
=
aNewData
.
mGridColumnEnd
|
|
mGridRowStart
!
=
aNewData
.
mGridRowStart
|
|
mGridRowEnd
!
=
aNewData
.
mGridRowEnd
|
|
mColumnGap
!
=
aNewData
.
mColumnGap
|
|
mRowGap
!
=
aNewData
.
mRowGap
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mJustifyContent
!
=
aNewData
.
mJustifyContent
|
|
mJustifyItems
!
=
aNewData
.
mJustifyItems
|
|
mJustifySelf
!
=
aNewData
.
mJustifySelf
)
{
hint
|
=
nsChangeHint_NeedReflow
;
}
if
(
mSpecifiedJustifyItems
!
=
aNewData
.
mSpecifiedJustifyItems
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
if
(
mAlignContent
!
=
aNewData
.
mAlignContent
)
{
hint
|
=
nsChangeHint_NeedReflow
;
}
bool
widthChanged
=
mWidth
!
=
aNewData
.
mWidth
|
|
mMinWidth
!
=
aNewData
.
mMinWidth
|
|
mMaxWidth
!
=
aNewData
.
mMaxWidth
;
bool
heightChanged
=
mHeight
!
=
aNewData
.
mHeight
|
|
mMinHeight
!
=
aNewData
.
mMinHeight
|
|
mMaxHeight
!
=
aNewData
.
mMaxHeight
;
bool
isVertical
=
aOldStyleVisibility
.
mWritingMode
!
=
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
;
if
(
isVertical
?
widthChanged
:
heightChanged
)
{
hint
|
=
nsChangeHint_ReflowHintsForBSizeChange
;
}
if
(
isVertical
?
heightChanged
:
widthChanged
)
{
hint
|
=
nsChangeHint_ReflowHintsForISizeChange
;
}
if
(
mAspectRatio
!
=
aNewData
.
mAspectRatio
)
{
hint
|
=
nsChangeHint_ReflowHintsForISizeChange
|
nsChangeHint_ReflowHintsForBSizeChange
;
}
if
(
mOffset
!
=
aNewData
.
mOffset
)
{
if
(
IsAutonessEqual
(
mOffset
aNewData
.
mOffset
)
)
{
hint
|
=
nsChangeHint_RecomputePosition
|
nsChangeHint_UpdateParentOverflow
;
}
else
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_ReflowChangesSizeOrPosition
;
}
}
return
hint
;
}
uint8_t
nsStylePosition
:
:
UsedAlignSelf
(
ComputedStyle
*
aParent
)
const
{
if
(
mAlignSelf
!
=
NS_STYLE_ALIGN_AUTO
)
{
return
mAlignSelf
;
}
if
(
MOZ_LIKELY
(
aParent
)
)
{
auto
parentAlignItems
=
aParent
-
>
StylePosition
(
)
-
>
mAlignItems
;
MOZ_ASSERT
(
!
(
parentAlignItems
&
NS_STYLE_ALIGN_LEGACY
)
"
align
-
items
can
'
t
have
'
legacy
'
"
)
;
return
parentAlignItems
;
}
return
NS_STYLE_ALIGN_NORMAL
;
}
uint8_t
nsStylePosition
:
:
UsedJustifySelf
(
ComputedStyle
*
aParent
)
const
{
if
(
mJustifySelf
!
=
NS_STYLE_JUSTIFY_AUTO
)
{
return
mJustifySelf
;
}
if
(
MOZ_LIKELY
(
aParent
)
)
{
auto
inheritedJustifyItems
=
aParent
-
>
StylePosition
(
)
-
>
mJustifyItems
;
return
inheritedJustifyItems
&
~
NS_STYLE_JUSTIFY_LEGACY
;
}
return
NS_STYLE_JUSTIFY_NORMAL
;
}
nsStyleTable
:
:
nsStyleTable
(
const
Document
&
aDocument
)
:
mLayoutStrategy
(
NS_STYLE_TABLE_LAYOUT_AUTO
)
mXSpan
(
1
)
{
MOZ_COUNT_CTOR
(
nsStyleTable
)
;
}
nsStyleTable
:
:
~
nsStyleTable
(
)
{
MOZ_COUNT_DTOR
(
nsStyleTable
)
;
}
nsStyleTable
:
:
nsStyleTable
(
const
nsStyleTable
&
aSource
)
:
mLayoutStrategy
(
aSource
.
mLayoutStrategy
)
mXSpan
(
aSource
.
mXSpan
)
{
MOZ_COUNT_CTOR
(
nsStyleTable
)
;
}
nsChangeHint
nsStyleTable
:
:
CalcDifference
(
const
nsStyleTable
&
aNewData
)
const
{
if
(
mXSpan
!
=
aNewData
.
mXSpan
|
|
mLayoutStrategy
!
=
aNewData
.
mLayoutStrategy
)
{
return
nsChangeHint_ReconstructFrame
;
}
return
nsChangeHint
(
0
)
;
}
nsStyleTableBorder
:
:
nsStyleTableBorder
(
const
Document
&
aDocument
)
:
mBorderSpacingCol
(
0
)
mBorderSpacingRow
(
0
)
mBorderCollapse
(
StyleBorderCollapse
:
:
Separate
)
mCaptionSide
(
NS_STYLE_CAPTION_SIDE_TOP
)
mEmptyCells
(
NS_STYLE_TABLE_EMPTY_CELLS_SHOW
)
{
MOZ_COUNT_CTOR
(
nsStyleTableBorder
)
;
}
nsStyleTableBorder
:
:
~
nsStyleTableBorder
(
)
{
MOZ_COUNT_DTOR
(
nsStyleTableBorder
)
;
}
nsStyleTableBorder
:
:
nsStyleTableBorder
(
const
nsStyleTableBorder
&
aSource
)
:
mBorderSpacingCol
(
aSource
.
mBorderSpacingCol
)
mBorderSpacingRow
(
aSource
.
mBorderSpacingRow
)
mBorderCollapse
(
aSource
.
mBorderCollapse
)
mCaptionSide
(
aSource
.
mCaptionSide
)
mEmptyCells
(
aSource
.
mEmptyCells
)
{
MOZ_COUNT_CTOR
(
nsStyleTableBorder
)
;
}
nsChangeHint
nsStyleTableBorder
:
:
CalcDifference
(
const
nsStyleTableBorder
&
aNewData
)
const
{
if
(
mBorderCollapse
!
=
aNewData
.
mBorderCollapse
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
(
mCaptionSide
=
=
aNewData
.
mCaptionSide
)
&
&
(
mBorderSpacingCol
=
=
aNewData
.
mBorderSpacingCol
)
&
&
(
mBorderSpacingRow
=
=
aNewData
.
mBorderSpacingRow
)
)
{
if
(
mEmptyCells
=
=
aNewData
.
mEmptyCells
)
{
return
nsChangeHint
(
0
)
;
}
return
NS_STYLE_HINT_VISUAL
;
}
else
{
return
NS_STYLE_HINT_REFLOW
;
}
}
template
<
>
bool
StyleGradient
:
:
IsOpaque
(
)
const
{
for
(
auto
&
stop
:
items
.
AsSpan
(
)
)
{
if
(
stop
.
IsInterpolationHint
(
)
)
{
continue
;
}
auto
&
color
=
stop
.
IsSimpleColorStop
(
)
?
stop
.
AsSimpleColorStop
(
)
:
stop
.
AsComplexColorStop
(
)
.
color
;
if
(
color
.
MaybeTransparent
(
)
)
{
return
false
;
}
}
return
true
;
}
class
StyleImageRequestCleanupTask
:
public
mozilla
:
:
Runnable
{
public
:
typedef
nsStyleImageRequest
:
:
Mode
Mode
;
StyleImageRequestCleanupTask
(
Mode
aModeFlags
already_AddRefed
<
imgRequestProxy
>
aRequestProxy
already_AddRefed
<
ImageTracker
>
aImageTracker
)
:
mozilla
:
:
Runnable
(
"
StyleImageRequestCleanupTask
"
)
mModeFlags
(
aModeFlags
)
mRequestProxy
(
aRequestProxy
)
mImageTracker
(
aImageTracker
)
{
}
NS_IMETHOD
Run
(
)
final
{
MOZ_ASSERT
(
!
mRequestProxy
|
|
NS_IsMainThread
(
)
"
If
mRequestProxy
is
non
-
null
we
need
to
run
on
main
thread
!
"
)
;
if
(
!
mRequestProxy
)
{
return
NS_OK
;
}
if
(
mModeFlags
&
Mode
:
:
Track
)
{
MOZ_ASSERT
(
mImageTracker
)
;
mImageTracker
-
>
Remove
(
mRequestProxy
)
;
}
else
{
mRequestProxy
-
>
UnlockImage
(
)
;
}
if
(
mModeFlags
&
Mode
:
:
Discard
)
{
mRequestProxy
-
>
RequestDiscard
(
)
;
}
return
NS_OK
;
}
protected
:
virtual
~
StyleImageRequestCleanupTask
(
)
{
MOZ_ASSERT
(
(
!
mRequestProxy
&
&
!
mImageTracker
)
|
|
NS_IsMainThread
(
)
"
mRequestProxy
and
mImageTracker
'
s
destructor
need
to
run
"
"
on
the
main
thread
!
"
)
;
}
private
:
Mode
mModeFlags
;
RefPtr
<
imgRequestProxy
>
mRequestProxy
;
RefPtr
<
ImageTracker
>
mImageTracker
;
}
;
nsStyleImageRequest
:
:
nsStyleImageRequest
(
Mode
aModeFlags
const
StyleComputedImageUrl
&
aImageURL
)
:
mImageURL
(
aImageURL
)
mModeFlags
(
aModeFlags
)
mResolved
(
false
)
{
}
nsStyleImageRequest
:
:
~
nsStyleImageRequest
(
)
{
{
RefPtr
<
StyleImageRequestCleanupTask
>
task
=
new
StyleImageRequestCleanupTask
(
mModeFlags
mRequestProxy
.
forget
(
)
mImageTracker
.
forget
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
task
-
>
Run
(
)
;
}
else
{
if
(
mDocGroup
)
{
mDocGroup
-
>
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
else
{
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
}
}
MOZ_ASSERT
(
!
mRequestProxy
)
;
MOZ_ASSERT
(
!
mImageTracker
)
;
}
bool
nsStyleImageRequest
:
:
Resolve
(
Document
&
aDocument
const
nsStyleImageRequest
*
aOldImageRequest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
IsResolved
(
)
"
already
resolved
"
)
;
mResolved
=
true
;
nsIURI
*
docURI
=
aDocument
.
GetDocumentURI
(
)
;
if
(
GetImageValue
(
)
.
HasRef
(
)
)
{
bool
isEqualExceptRef
=
false
;
RefPtr
<
nsIURI
>
imageURI
=
GetImageURI
(
)
;
if
(
!
imageURI
)
{
return
false
;
}
if
(
NS_SUCCEEDED
(
imageURI
-
>
EqualsExceptRef
(
docURI
&
isEqualExceptRef
)
)
&
&
isEqualExceptRef
)
{
return
true
;
}
}
if
(
nsContentUtils
:
:
IsChromeDoc
(
&
aDocument
)
&
&
aOldImageRequest
&
&
aOldImageRequest
-
>
IsResolved
(
)
&
&
DefinitelyEquals
(
*
aOldImageRequest
)
)
{
MOZ_ASSERT
(
aOldImageRequest
-
>
mDocGroup
=
=
aDocument
.
GetDocGroup
(
)
)
;
MOZ_ASSERT
(
mModeFlags
=
=
aOldImageRequest
-
>
mModeFlags
)
;
mDocGroup
=
aOldImageRequest
-
>
mDocGroup
;
mImageURL
=
aOldImageRequest
-
>
mImageURL
;
mRequestProxy
=
aOldImageRequest
-
>
mRequestProxy
;
}
else
{
mDocGroup
=
aDocument
.
GetDocGroup
(
)
;
imgRequestProxy
*
request
=
mImageURL
.
LoadImage
(
aDocument
)
;
bool
isPrint
=
!
!
aDocument
.
GetOriginalDocument
(
)
;
if
(
!
isPrint
)
{
mRequestProxy
=
request
;
}
else
if
(
request
)
{
request
-
>
GetStaticRequest
(
&
aDocument
getter_AddRefs
(
mRequestProxy
)
)
;
}
}
if
(
!
mRequestProxy
)
{
return
false
;
}
mRequestProxy
-
>
BoostPriority
(
imgIRequest
:
:
CATEGORY_FRAME_STYLE
)
;
if
(
mModeFlags
&
Mode
:
:
Track
)
{
mImageTracker
=
aDocument
.
ImageTracker
(
)
;
}
MaybeTrackAndLock
(
)
;
return
true
;
}
void
nsStyleImageRequest
:
:
MaybeTrackAndLock
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsResolved
(
)
)
;
MOZ_ASSERT
(
mRequestProxy
)
;
if
(
mModeFlags
&
Mode
:
:
Track
)
{
MOZ_ASSERT
(
mImageTracker
)
;
mImageTracker
-
>
Add
(
mRequestProxy
)
;
}
else
{
MOZ_ASSERT
(
!
mImageTracker
)
;
mRequestProxy
-
>
LockImage
(
)
;
}
}
bool
nsStyleImageRequest
:
:
DefinitelyEquals
(
const
nsStyleImageRequest
&
aOther
)
const
{
return
mImageURL
=
=
aOther
.
mImageURL
;
}
void
CachedBorderImageData
:
:
SetCachedSVGViewportSize
(
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
)
{
mCachedSVGViewportSize
=
aSVGViewportSize
;
}
const
mozilla
:
:
Maybe
<
nsSize
>
&
CachedBorderImageData
:
:
GetCachedSVGViewportSize
(
)
{
return
mCachedSVGViewportSize
;
}
struct
PurgeCachedImagesTask
:
mozilla
:
:
Runnable
{
PurgeCachedImagesTask
(
)
:
mozilla
:
:
Runnable
(
"
PurgeCachedImagesTask
"
)
{
}
NS_IMETHOD
Run
(
)
final
{
mSubImages
.
Clear
(
)
;
return
NS_OK
;
}
nsCOMArray
<
imgIContainer
>
mSubImages
;
}
;
void
CachedBorderImageData
:
:
PurgeCachedImages
(
)
{
if
(
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
{
RefPtr
<
PurgeCachedImagesTask
>
task
=
new
PurgeCachedImagesTask
(
)
;
task
-
>
mSubImages
.
SwapElements
(
mSubImages
)
;
NS_DispatchToMainThread
(
task
.
forget
(
)
)
;
}
else
{
mSubImages
.
Clear
(
)
;
}
}
void
CachedBorderImageData
:
:
SetSubImage
(
uint8_t
aIndex
imgIContainer
*
aSubImage
)
{
mSubImages
.
ReplaceObjectAt
(
aSubImage
aIndex
)
;
}
imgIContainer
*
CachedBorderImageData
:
:
GetSubImage
(
uint8_t
aIndex
)
{
imgIContainer
*
subImage
=
nullptr
;
if
(
aIndex
<
mSubImages
.
Count
(
)
)
subImage
=
mSubImages
[
aIndex
]
;
return
subImage
;
}
nsStyleImage
:
:
nsStyleImage
(
)
:
mType
(
eStyleImageType_Null
)
mImage
(
nullptr
)
mCropRect
(
nullptr
)
{
MOZ_COUNT_CTOR
(
nsStyleImage
)
;
}
nsStyleImage
:
:
~
nsStyleImage
(
)
{
MOZ_COUNT_DTOR
(
nsStyleImage
)
;
if
(
mType
!
=
eStyleImageType_Null
)
{
SetNull
(
)
;
}
}
nsStyleImage
:
:
nsStyleImage
(
const
nsStyleImage
&
aOther
)
:
mType
(
eStyleImageType_Null
)
mCropRect
(
nullptr
)
{
MOZ_COUNT_CTOR
(
nsStyleImage
)
;
DoCopy
(
aOther
)
;
}
nsStyleImage
&
nsStyleImage
:
:
operator
=
(
const
nsStyleImage
&
aOther
)
{
if
(
this
!
=
&
aOther
)
{
DoCopy
(
aOther
)
;
}
return
*
this
;
}
void
nsStyleImage
:
:
DoCopy
(
const
nsStyleImage
&
aOther
)
{
SetNull
(
)
;
if
(
aOther
.
mType
=
=
eStyleImageType_Image
)
{
SetImageRequest
(
do_AddRef
(
aOther
.
mImage
)
)
;
}
else
if
(
aOther
.
mType
=
=
eStyleImageType_Gradient
)
{
SetGradientData
(
MakeUnique
<
StyleGradient
>
(
*
aOther
.
mGradient
)
)
;
}
else
if
(
aOther
.
mType
=
=
eStyleImageType_Element
)
{
SetElementId
(
do_AddRef
(
aOther
.
mElementId
)
)
;
}
UniquePtr
<
CropRect
>
cropRectCopy
;
if
(
aOther
.
mCropRect
)
{
cropRectCopy
=
MakeUnique
<
CropRect
>
(
*
aOther
.
mCropRect
.
get
(
)
)
;
}
SetCropRect
(
std
:
:
move
(
cropRectCopy
)
)
;
}
void
nsStyleImage
:
:
SetNull
(
)
{
if
(
mType
=
=
eStyleImageType_Gradient
)
{
delete
mGradient
;
mGradient
=
nullptr
;
}
else
if
(
mType
=
=
eStyleImageType_Image
)
{
NS_RELEASE
(
mImage
)
;
}
else
if
(
mType
=
=
eStyleImageType_Element
)
{
NS_RELEASE
(
mElementId
)
;
}
mType
=
eStyleImageType_Null
;
mCropRect
=
nullptr
;
}
void
nsStyleImage
:
:
SetImageRequest
(
already_AddRefed
<
nsStyleImageRequest
>
aImage
)
{
RefPtr
<
nsStyleImageRequest
>
image
=
aImage
;
if
(
mType
!
=
eStyleImageType_Null
)
{
SetNull
(
)
;
}
if
(
image
)
{
mImage
=
image
.
forget
(
)
.
take
(
)
;
mType
=
eStyleImageType_Image
;
}
if
(
mCachedBIData
)
{
mCachedBIData
-
>
PurgeCachedImages
(
)
;
}
}
void
nsStyleImage
:
:
SetGradientData
(
UniquePtr
<
StyleGradient
>
aGradient
)
{
MOZ_ASSERT
(
aGradient
)
;
if
(
mType
!
=
eStyleImageType_Null
)
{
SetNull
(
)
;
}
mGradient
=
aGradient
.
release
(
)
;
mType
=
eStyleImageType_Gradient
;
}
void
nsStyleImage
:
:
SetElementId
(
already_AddRefed
<
nsAtom
>
aElementId
)
{
if
(
mType
!
=
eStyleImageType_Null
)
{
SetNull
(
)
;
}
if
(
RefPtr
<
nsAtom
>
atom
=
aElementId
)
{
mElementId
=
atom
.
forget
(
)
.
take
(
)
;
mType
=
eStyleImageType_Element
;
}
}
void
nsStyleImage
:
:
SetCropRect
(
UniquePtr
<
CropRect
>
aCropRect
)
{
mCropRect
=
std
:
:
move
(
aCropRect
)
;
}
static
int32_t
ConvertToPixelCoord
(
const
StyleNumberOrPercentage
&
aCoord
int32_t
aPercentScale
)
{
double
pixelValue
;
if
(
aCoord
.
IsNumber
(
)
)
{
pixelValue
=
aCoord
.
AsNumber
(
)
;
}
else
{
MOZ_ASSERT
(
aCoord
.
IsPercentage
(
)
)
;
pixelValue
=
aCoord
.
AsPercentage
(
)
.
_0
*
aPercentScale
;
}
MOZ_ASSERT
(
pixelValue
>
=
0
"
we
ensured
non
-
negative
while
parsing
"
)
;
pixelValue
=
std
:
:
min
(
pixelValue
double
(
INT32_MAX
)
)
;
return
NS_lround
(
pixelValue
)
;
}
already_AddRefed
<
nsIURI
>
nsStyleImageRequest
:
:
GetImageURI
(
)
const
{
nsCOMPtr
<
nsIURI
>
uri
;
if
(
mRequestProxy
)
{
mRequestProxy
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
return
uri
.
forget
(
)
;
}
}
uri
=
mImageURL
.
GetURI
(
)
;
return
uri
.
forget
(
)
;
}
bool
nsStyleImage
:
:
ComputeActualCropRect
(
nsIntRect
&
aActualCropRect
bool
*
aIsEntireImage
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleImageType_Image
"
This
function
is
designed
to
be
used
only
when
mType
"
"
is
eStyleImageType_Image
.
"
)
;
imgRequestProxy
*
req
=
GetImageData
(
)
;
if
(
!
req
)
{
return
false
;
}
nsCOMPtr
<
imgIContainer
>
imageContainer
;
req
-
>
GetImage
(
getter_AddRefs
(
imageContainer
)
)
;
if
(
!
imageContainer
)
{
return
false
;
}
nsIntSize
imageSize
;
imageContainer
-
>
GetWidth
(
&
imageSize
.
width
)
;
imageContainer
-
>
GetHeight
(
&
imageSize
.
height
)
;
if
(
imageSize
.
width
<
=
0
|
|
imageSize
.
height
<
=
0
)
{
return
false
;
}
int32_t
left
=
ConvertToPixelCoord
(
mCropRect
-
>
Get
(
eSideLeft
)
imageSize
.
width
)
;
int32_t
top
=
ConvertToPixelCoord
(
mCropRect
-
>
Get
(
eSideTop
)
imageSize
.
height
)
;
int32_t
right
=
ConvertToPixelCoord
(
mCropRect
-
>
Get
(
eSideRight
)
imageSize
.
width
)
;
int32_t
bottom
=
ConvertToPixelCoord
(
mCropRect
-
>
Get
(
eSideBottom
)
imageSize
.
height
)
;
nsIntRect
cropRect
(
left
top
right
-
left
bottom
-
top
)
;
nsIntRect
imageRect
(
nsIntPoint
(
0
0
)
imageSize
)
;
aActualCropRect
.
IntersectRect
(
imageRect
cropRect
)
;
if
(
aIsEntireImage
)
{
*
aIsEntireImage
=
aActualCropRect
.
IsEqualInterior
(
imageRect
)
;
}
return
true
;
}
bool
nsStyleImage
:
:
StartDecoding
(
)
const
{
if
(
mType
=
=
eStyleImageType_Image
)
{
imgRequestProxy
*
req
=
GetImageData
(
)
;
if
(
!
req
)
{
return
false
;
}
return
req
-
>
StartDecodingWithResult
(
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
)
;
}
return
mType
!
=
eStyleImageType_Null
?
true
:
false
;
}
bool
nsStyleImage
:
:
IsOpaque
(
)
const
{
if
(
!
IsComplete
(
)
)
{
return
false
;
}
if
(
mType
=
=
eStyleImageType_Gradient
)
{
return
mGradient
-
>
IsOpaque
(
)
;
}
if
(
mType
=
=
eStyleImageType_Element
)
{
return
false
;
}
MOZ_ASSERT
(
mType
=
=
eStyleImageType_Image
"
unexpected
image
type
"
)
;
MOZ_ASSERT
(
GetImageData
(
)
"
should
'
ve
returned
earlier
above
"
)
;
nsCOMPtr
<
imgIContainer
>
imageContainer
;
GetImageData
(
)
-
>
GetImage
(
getter_AddRefs
(
imageContainer
)
)
;
MOZ_ASSERT
(
imageContainer
"
IsComplete
(
)
said
image
container
is
ready
"
)
;
if
(
imageContainer
-
>
WillDrawOpaqueNow
(
)
)
{
if
(
!
mCropRect
)
{
return
true
;
}
nsIntRect
actualCropRect
;
return
ComputeActualCropRect
(
actualCropRect
)
&
&
!
actualCropRect
.
IsEmpty
(
)
;
}
return
false
;
}
bool
nsStyleImage
:
:
IsComplete
(
)
const
{
switch
(
mType
)
{
case
eStyleImageType_Null
:
return
false
;
case
eStyleImageType_Gradient
:
case
eStyleImageType_Element
:
return
true
;
case
eStyleImageType_Image
:
{
if
(
!
IsResolved
(
)
)
{
return
false
;
}
imgRequestProxy
*
req
=
GetImageData
(
)
;
if
(
!
req
)
{
return
false
;
}
uint32_t
status
=
imgIRequest
:
:
STATUS_ERROR
;
return
NS_SUCCEEDED
(
req
-
>
GetImageStatus
(
&
status
)
)
&
&
(
status
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
&
&
(
status
&
imgIRequest
:
:
STATUS_FRAME_COMPLETE
)
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
image
type
"
)
;
return
false
;
}
}
bool
nsStyleImage
:
:
IsSizeAvailable
(
)
const
{
switch
(
mType
)
{
case
eStyleImageType_Null
:
return
false
;
case
eStyleImageType_Gradient
:
case
eStyleImageType_Element
:
return
true
;
case
eStyleImageType_Image
:
{
imgRequestProxy
*
req
=
GetImageData
(
)
;
if
(
!
req
)
{
return
false
;
}
uint32_t
status
=
imgIRequest
:
:
STATUS_ERROR
;
return
NS_SUCCEEDED
(
req
-
>
GetImageStatus
(
&
status
)
)
&
&
!
(
status
&
imgIRequest
:
:
STATUS_ERROR
)
&
&
(
status
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
image
type
"
)
;
return
false
;
}
}
static
inline
bool
EqualRects
(
const
nsStyleImage
:
:
CropRect
*
aRect1
const
nsStyleImage
:
:
CropRect
*
aRect2
)
{
return
aRect1
=
=
aRect2
|
|
(
aRect1
&
&
aRect2
&
&
*
aRect1
=
=
*
aRect2
)
;
}
bool
nsStyleImage
:
:
operator
=
=
(
const
nsStyleImage
&
aOther
)
const
{
if
(
mType
!
=
aOther
.
mType
)
{
return
false
;
}
if
(
!
EqualRects
(
mCropRect
.
get
(
)
aOther
.
mCropRect
.
get
(
)
)
)
{
return
false
;
}
if
(
mType
=
=
eStyleImageType_Image
)
{
return
DefinitelyEqualImages
(
mImage
aOther
.
mImage
)
;
}
if
(
mType
=
=
eStyleImageType_Gradient
)
{
return
*
mGradient
=
=
*
aOther
.
mGradient
;
}
if
(
mType
=
=
eStyleImageType_Element
)
{
return
mElementId
=
=
aOther
.
mElementId
;
}
return
true
;
}
void
nsStyleImage
:
:
PurgeCacheForViewportChange
(
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasIntrinsicRatio
)
const
{
EnsureCachedBIData
(
)
;
if
(
aSVGViewportSize
!
=
mCachedBIData
-
>
GetCachedSVGViewportSize
(
)
&
&
!
aHasIntrinsicRatio
)
{
mCachedBIData
-
>
PurgeCachedImages
(
)
;
mCachedBIData
-
>
SetCachedSVGViewportSize
(
aSVGViewportSize
)
;
}
}
already_AddRefed
<
nsIURI
>
nsStyleImage
:
:
GetImageURI
(
)
const
{
if
(
mType
!
=
eStyleImageType_Image
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
=
mImage
-
>
GetImageURI
(
)
;
return
uri
.
forget
(
)
;
}
const
StyleComputedImageUrl
*
nsStyleImage
:
:
GetURLValue
(
)
const
{
return
mType
=
=
eStyleImageType_Image
?
&
mImage
-
>
GetImageValue
(
)
:
nullptr
;
}
const
nsCSSPropertyID
nsStyleImageLayers
:
:
kBackgroundLayerTable
[
]
=
{
eCSSProperty_background
eCSSProperty_background_color
eCSSProperty_background_image
eCSSProperty_background_repeat
eCSSProperty_background_position_x
eCSSProperty_background_position_y
eCSSProperty_background_clip
eCSSProperty_background_origin
eCSSProperty_background_size
eCSSProperty_background_attachment
eCSSProperty_UNKNOWN
eCSSProperty_UNKNOWN
}
;
const
nsCSSPropertyID
nsStyleImageLayers
:
:
kMaskLayerTable
[
]
=
{
eCSSProperty_mask
eCSSProperty_UNKNOWN
eCSSProperty_mask_image
eCSSProperty_mask_repeat
eCSSProperty_mask_position_x
eCSSProperty_mask_position_y
eCSSProperty_mask_clip
eCSSProperty_mask_origin
eCSSProperty_mask_size
eCSSProperty_UNKNOWN
eCSSProperty_mask_mode
eCSSProperty_mask_composite
}
;
nsStyleImageLayers
:
:
nsStyleImageLayers
(
nsStyleImageLayers
:
:
LayerType
aType
)
:
mAttachmentCount
(
1
)
mClipCount
(
1
)
mOriginCount
(
1
)
mRepeatCount
(
1
)
mPositionXCount
(
1
)
mPositionYCount
(
1
)
mImageCount
(
1
)
mSizeCount
(
1
)
mMaskModeCount
(
1
)
mBlendModeCount
(
1
)
mCompositeCount
(
1
)
mLayers
(
nsStyleAutoArray
<
Layer
>
:
:
WITH_SINGLE_INITIAL_ELEMENT
)
{
MOZ_COUNT_CTOR
(
nsStyleImageLayers
)
;
mLayers
[
0
]
.
Initialize
(
aType
)
;
}
nsStyleImageLayers
:
:
nsStyleImageLayers
(
const
nsStyleImageLayers
&
aSource
)
:
mAttachmentCount
(
aSource
.
mAttachmentCount
)
mClipCount
(
aSource
.
mClipCount
)
mOriginCount
(
aSource
.
mOriginCount
)
mRepeatCount
(
aSource
.
mRepeatCount
)
mPositionXCount
(
aSource
.
mPositionXCount
)
mPositionYCount
(
aSource
.
mPositionYCount
)
mImageCount
(
aSource
.
mImageCount
)
mSizeCount
(
aSource
.
mSizeCount
)
mMaskModeCount
(
aSource
.
mMaskModeCount
)
mBlendModeCount
(
aSource
.
mBlendModeCount
)
mCompositeCount
(
aSource
.
mCompositeCount
)
mLayers
(
aSource
.
mLayers
)
{
MOZ_COUNT_CTOR
(
nsStyleImageLayers
)
;
uint32_t
count
=
mLayers
.
Length
(
)
;
if
(
count
!
=
aSource
.
mLayers
.
Length
(
)
)
{
NS_WARNING
(
"
truncating
counts
due
to
out
-
of
-
memory
"
)
;
mAttachmentCount
=
std
:
:
max
(
mAttachmentCount
count
)
;
mClipCount
=
std
:
:
max
(
mClipCount
count
)
;
mOriginCount
=
std
:
:
max
(
mOriginCount
count
)
;
mRepeatCount
=
std
:
:
max
(
mRepeatCount
count
)
;
mPositionXCount
=
std
:
:
max
(
mPositionXCount
count
)
;
mPositionYCount
=
std
:
:
max
(
mPositionYCount
count
)
;
mImageCount
=
std
:
:
max
(
mImageCount
count
)
;
mSizeCount
=
std
:
:
max
(
mSizeCount
count
)
;
mMaskModeCount
=
std
:
:
max
(
mMaskModeCount
count
)
;
mBlendModeCount
=
std
:
:
max
(
mBlendModeCount
count
)
;
mCompositeCount
=
std
:
:
max
(
mCompositeCount
count
)
;
}
}
static
bool
IsElementImage
(
const
nsStyleImageLayers
:
:
Layer
&
aLayer
)
{
return
aLayer
.
mImage
.
GetType
(
)
=
=
eStyleImageType_Element
;
}
static
bool
AnyLayerIsElementImage
(
const
nsStyleImageLayers
&
aLayers
)
{
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
aLayers
)
{
if
(
IsElementImage
(
aLayers
.
mLayers
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
nsChangeHint
nsStyleImageLayers
:
:
CalcDifference
(
const
nsStyleImageLayers
&
aNewLayers
LayerType
aType
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mImageCount
!
=
aNewLayers
.
mImageCount
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
if
(
aType
=
=
nsStyleImageLayers
:
:
LayerType
:
:
Mask
|
|
AnyLayerIsElementImage
(
*
this
)
|
|
AnyLayerIsElementImage
(
aNewLayers
)
)
{
hint
|
=
nsChangeHint_UpdateEffects
;
}
return
hint
;
}
const
nsStyleImageLayers
&
moreLayers
=
mLayers
.
Length
(
)
>
aNewLayers
.
mLayers
.
Length
(
)
?
*
this
:
aNewLayers
;
const
nsStyleImageLayers
&
lessLayers
=
mLayers
.
Length
(
)
>
aNewLayers
.
mLayers
.
Length
(
)
?
aNewLayers
:
*
this
;
for
(
size_t
i
=
0
;
i
<
moreLayers
.
mLayers
.
Length
(
)
;
+
+
i
)
{
const
Layer
&
moreLayersLayer
=
moreLayers
.
mLayers
[
i
]
;
if
(
i
<
moreLayers
.
mImageCount
)
{
const
Layer
&
lessLayersLayer
=
lessLayers
.
mLayers
[
i
]
;
nsChangeHint
layerDifference
=
moreLayersLayer
.
CalcDifference
(
lessLayersLayer
)
;
if
(
layerDifference
&
&
(
IsElementImage
(
moreLayersLayer
)
|
|
IsElementImage
(
lessLayersLayer
)
)
)
{
layerDifference
|
=
nsChangeHint_UpdateEffects
|
nsChangeHint_RepaintFrame
;
}
hint
|
=
layerDifference
;
continue
;
}
if
(
hint
)
{
return
hint
;
}
if
(
i
>
=
lessLayers
.
mLayers
.
Length
(
)
)
{
return
nsChangeHint_NeutralChange
;
}
const
Layer
&
lessLayersLayer
=
lessLayers
.
mLayers
[
i
]
;
MOZ_ASSERT
(
moreLayersLayer
.
mImage
.
GetType
(
)
=
=
eStyleImageType_Null
)
;
MOZ_ASSERT
(
lessLayersLayer
.
mImage
.
GetType
(
)
=
=
eStyleImageType_Null
)
;
if
(
moreLayersLayer
.
CalcDifference
(
lessLayersLayer
)
)
{
return
nsChangeHint_NeutralChange
;
}
}
if
(
hint
)
{
return
hint
;
}
if
(
mAttachmentCount
!
=
aNewLayers
.
mAttachmentCount
|
|
mBlendModeCount
!
=
aNewLayers
.
mBlendModeCount
|
|
mClipCount
!
=
aNewLayers
.
mClipCount
|
|
mCompositeCount
!
=
aNewLayers
.
mCompositeCount
|
|
mMaskModeCount
!
=
aNewLayers
.
mMaskModeCount
|
|
mOriginCount
!
=
aNewLayers
.
mOriginCount
|
|
mRepeatCount
!
=
aNewLayers
.
mRepeatCount
|
|
mPositionXCount
!
=
aNewLayers
.
mPositionXCount
|
|
mPositionYCount
!
=
aNewLayers
.
mPositionYCount
|
|
mSizeCount
!
=
aNewLayers
.
mSizeCount
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
nsStyleImageLayers
&
nsStyleImageLayers
:
:
operator
=
(
const
nsStyleImageLayers
&
aOther
)
{
mAttachmentCount
=
aOther
.
mAttachmentCount
;
mClipCount
=
aOther
.
mClipCount
;
mOriginCount
=
aOther
.
mOriginCount
;
mRepeatCount
=
aOther
.
mRepeatCount
;
mPositionXCount
=
aOther
.
mPositionXCount
;
mPositionYCount
=
aOther
.
mPositionYCount
;
mImageCount
=
aOther
.
mImageCount
;
mSizeCount
=
aOther
.
mSizeCount
;
mMaskModeCount
=
aOther
.
mMaskModeCount
;
mBlendModeCount
=
aOther
.
mBlendModeCount
;
mCompositeCount
=
aOther
.
mCompositeCount
;
mLayers
=
aOther
.
mLayers
;
uint32_t
count
=
mLayers
.
Length
(
)
;
if
(
count
!
=
aOther
.
mLayers
.
Length
(
)
)
{
NS_WARNING
(
"
truncating
counts
due
to
out
-
of
-
memory
"
)
;
mAttachmentCount
=
std
:
:
max
(
mAttachmentCount
count
)
;
mClipCount
=
std
:
:
max
(
mClipCount
count
)
;
mOriginCount
=
std
:
:
max
(
mOriginCount
count
)
;
mRepeatCount
=
std
:
:
max
(
mRepeatCount
count
)
;
mPositionXCount
=
std
:
:
max
(
mPositionXCount
count
)
;
mPositionYCount
=
std
:
:
max
(
mPositionYCount
count
)
;
mImageCount
=
std
:
:
max
(
mImageCount
count
)
;
mSizeCount
=
std
:
:
max
(
mSizeCount
count
)
;
mMaskModeCount
=
std
:
:
max
(
mMaskModeCount
count
)
;
mBlendModeCount
=
std
:
:
max
(
mBlendModeCount
count
)
;
mCompositeCount
=
std
:
:
max
(
mCompositeCount
count
)
;
}
return
*
this
;
}
nsStyleImageLayers
&
nsStyleImageLayers
:
:
operator
=
(
nsStyleImageLayers
&
&
aOther
)
{
mAttachmentCount
=
aOther
.
mAttachmentCount
;
mClipCount
=
aOther
.
mClipCount
;
mOriginCount
=
aOther
.
mOriginCount
;
mRepeatCount
=
aOther
.
mRepeatCount
;
mPositionXCount
=
aOther
.
mPositionXCount
;
mPositionYCount
=
aOther
.
mPositionYCount
;
mImageCount
=
aOther
.
mImageCount
;
mSizeCount
=
aOther
.
mSizeCount
;
mMaskModeCount
=
aOther
.
mMaskModeCount
;
mBlendModeCount
=
aOther
.
mBlendModeCount
;
mCompositeCount
=
aOther
.
mCompositeCount
;
mLayers
=
std
:
:
move
(
aOther
.
mLayers
)
;
uint32_t
count
=
mLayers
.
Length
(
)
;
if
(
count
!
=
aOther
.
mLayers
.
Length
(
)
)
{
NS_WARNING
(
"
truncating
counts
due
to
out
-
of
-
memory
"
)
;
mAttachmentCount
=
std
:
:
max
(
mAttachmentCount
count
)
;
mClipCount
=
std
:
:
max
(
mClipCount
count
)
;
mOriginCount
=
std
:
:
max
(
mOriginCount
count
)
;
mRepeatCount
=
std
:
:
max
(
mRepeatCount
count
)
;
mPositionXCount
=
std
:
:
max
(
mPositionXCount
count
)
;
mPositionYCount
=
std
:
:
max
(
mPositionYCount
count
)
;
mImageCount
=
std
:
:
max
(
mImageCount
count
)
;
mSizeCount
=
std
:
:
max
(
mSizeCount
count
)
;
mMaskModeCount
=
std
:
:
max
(
mMaskModeCount
count
)
;
mBlendModeCount
=
std
:
:
max
(
mBlendModeCount
count
)
;
mCompositeCount
=
std
:
:
max
(
mCompositeCount
count
)
;
}
return
*
this
;
}
bool
nsStyleImageLayers
:
:
operator
=
=
(
const
nsStyleImageLayers
&
aOther
)
const
{
if
(
mAttachmentCount
!
=
aOther
.
mAttachmentCount
|
|
mClipCount
!
=
aOther
.
mClipCount
|
|
mOriginCount
!
=
aOther
.
mOriginCount
|
|
mRepeatCount
!
=
aOther
.
mRepeatCount
|
|
mPositionXCount
!
=
aOther
.
mPositionXCount
|
|
mPositionYCount
!
=
aOther
.
mPositionYCount
|
|
mImageCount
!
=
aOther
.
mImageCount
|
|
mSizeCount
!
=
aOther
.
mSizeCount
|
|
mMaskModeCount
!
=
aOther
.
mMaskModeCount
|
|
mBlendModeCount
!
=
aOther
.
mBlendModeCount
)
{
return
false
;
}
if
(
mLayers
.
Length
(
)
!
=
aOther
.
mLayers
.
Length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
mLayers
.
Length
(
)
;
i
+
+
)
{
if
(
mLayers
[
i
]
.
mPosition
!
=
aOther
.
mLayers
[
i
]
.
mPosition
|
|
mLayers
[
i
]
.
mImage
!
=
aOther
.
mLayers
[
i
]
.
mImage
|
|
mLayers
[
i
]
.
mSize
!
=
aOther
.
mLayers
[
i
]
.
mSize
|
|
mLayers
[
i
]
.
mClip
!
=
aOther
.
mLayers
[
i
]
.
mClip
|
|
mLayers
[
i
]
.
mOrigin
!
=
aOther
.
mLayers
[
i
]
.
mOrigin
|
|
mLayers
[
i
]
.
mAttachment
!
=
aOther
.
mLayers
[
i
]
.
mAttachment
|
|
mLayers
[
i
]
.
mBlendMode
!
=
aOther
.
mLayers
[
i
]
.
mBlendMode
|
|
mLayers
[
i
]
.
mComposite
!
=
aOther
.
mLayers
[
i
]
.
mComposite
|
|
mLayers
[
i
]
.
mMaskMode
!
=
aOther
.
mLayers
[
i
]
.
mMaskMode
|
|
mLayers
[
i
]
.
mRepeat
!
=
aOther
.
mLayers
[
i
]
.
mRepeat
)
{
return
false
;
}
}
return
true
;
}
bool
nsStyleImageLayers
:
:
IsInitialPositionForLayerType
(
Position
aPosition
LayerType
aType
)
{
return
aPosition
=
=
Position
:
:
FromPercentage
(
0
.
)
;
}
static
bool
SizeDependsOnPositioningAreaSize
(
const
StyleBackgroundSize
&
aSize
const
nsStyleImage
&
aImage
)
{
MOZ_ASSERT
(
aImage
.
GetType
(
)
!
=
eStyleImageType_Null
"
caller
should
have
handled
this
"
)
;
if
(
aSize
.
IsCover
(
)
|
|
aSize
.
IsContain
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
aSize
.
IsExplicitSize
(
)
)
;
auto
&
size
=
aSize
.
explicit_size
;
if
(
size
.
width
.
HasPercent
(
)
|
|
size
.
height
.
HasPercent
(
)
)
{
return
true
;
}
if
(
!
size
.
width
.
IsAuto
(
)
&
&
!
size
.
height
.
IsAuto
(
)
)
{
return
false
;
}
nsStyleImageType
type
=
aImage
.
GetType
(
)
;
if
(
type
=
=
eStyleImageType_Gradient
)
{
return
true
;
}
if
(
type
=
=
eStyleImageType_Element
)
{
return
true
;
}
if
(
type
=
=
eStyleImageType_Image
)
{
nsCOMPtr
<
imgIContainer
>
imgContainer
;
if
(
imgRequestProxy
*
req
=
aImage
.
GetImageData
(
)
)
{
req
-
>
GetImage
(
getter_AddRefs
(
imgContainer
)
)
;
}
if
(
imgContainer
)
{
CSSIntSize
imageSize
;
AspectRatio
imageRatio
;
bool
hasWidth
hasHeight
;
nsLayoutUtils
:
:
ComputeSizeForDrawing
(
imgContainer
imageSize
imageRatio
hasWidth
hasHeight
)
;
if
(
hasWidth
&
&
hasHeight
)
{
return
false
;
}
if
(
imageRatio
)
{
return
size
.
width
.
IsAuto
(
)
=
=
size
.
height
.
IsAuto
(
)
;
}
return
!
(
hasWidth
&
&
size
.
width
.
IsLengthPercentage
(
)
)
&
&
!
(
hasHeight
&
&
size
.
height
.
IsLengthPercentage
(
)
)
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
missed
an
enum
value
"
)
;
}
return
false
;
}
nsStyleImageLayers
:
:
Layer
:
:
Layer
(
)
:
mSize
(
StyleBackgroundSize
:
:
ExplicitSize
(
LengthPercentageOrAuto
:
:
Auto
(
)
LengthPercentageOrAuto
:
:
Auto
(
)
)
)
mClip
(
StyleGeometryBox
:
:
BorderBox
)
mAttachment
(
StyleImageLayerAttachment
:
:
Scroll
)
mBlendMode
(
NS_STYLE_BLEND_NORMAL
)
mComposite
(
NS_STYLE_MASK_COMPOSITE_ADD
)
mMaskMode
(
StyleMaskMode
:
:
MatchSource
)
{
mImage
.
SetNull
(
)
;
}
nsStyleImageLayers
:
:
Layer
:
:
~
Layer
(
)
{
}
void
nsStyleImageLayers
:
:
Layer
:
:
Initialize
(
nsStyleImageLayers
:
:
LayerType
aType
)
{
mRepeat
.
SetInitialValues
(
)
;
mPosition
=
Position
:
:
FromPercentage
(
0
.
)
;
if
(
aType
=
=
LayerType
:
:
Background
)
{
mOrigin
=
StyleGeometryBox
:
:
PaddingBox
;
}
else
{
MOZ_ASSERT
(
aType
=
=
LayerType
:
:
Mask
"
unsupported
layer
type
.
"
)
;
mOrigin
=
StyleGeometryBox
:
:
BorderBox
;
}
}
bool
nsStyleImageLayers
:
:
Layer
:
:
RenderingMightDependOnPositioningAreaSizeChange
(
)
const
{
if
(
mImage
.
IsEmpty
(
)
)
{
return
false
;
}
return
mPosition
.
DependsOnPositioningAreaSize
(
)
|
|
SizeDependsOnPositioningAreaSize
(
mSize
mImage
)
|
|
mRepeat
.
DependsOnPositioningAreaSize
(
)
;
}
bool
nsStyleImageLayers
:
:
Layer
:
:
operator
=
=
(
const
Layer
&
aOther
)
const
{
return
mAttachment
=
=
aOther
.
mAttachment
&
&
mClip
=
=
aOther
.
mClip
&
&
mOrigin
=
=
aOther
.
mOrigin
&
&
mRepeat
=
=
aOther
.
mRepeat
&
&
mBlendMode
=
=
aOther
.
mBlendMode
&
&
mPosition
=
=
aOther
.
mPosition
&
&
mSize
=
=
aOther
.
mSize
&
&
mImage
=
=
aOther
.
mImage
&
&
mMaskMode
=
=
aOther
.
mMaskMode
&
&
mComposite
=
=
aOther
.
mComposite
;
}
template
<
class
ComputedValueItem
>
static
void
FillImageLayerList
(
nsStyleAutoArray
<
nsStyleImageLayers
:
:
Layer
>
&
aLayers
ComputedValueItem
nsStyleImageLayers
:
:
Layer
:
:
*
aResultLocation
uint32_t
aItemCount
uint32_t
aFillCount
)
{
MOZ_ASSERT
(
aFillCount
<
=
aLayers
.
Length
(
)
"
unexpected
array
length
"
)
;
for
(
uint32_t
sourceLayer
=
0
destLayer
=
aItemCount
;
destLayer
<
aFillCount
;
+
+
sourceLayer
+
+
destLayer
)
{
aLayers
[
destLayer
]
.
*
aResultLocation
=
aLayers
[
sourceLayer
]
.
*
aResultLocation
;
}
}
static
void
FillImageLayerPositionCoordList
(
nsStyleAutoArray
<
nsStyleImageLayers
:
:
Layer
>
&
aLayers
LengthPercentage
Position
:
:
*
aResultLocation
uint32_t
aItemCount
uint32_t
aFillCount
)
{
MOZ_ASSERT
(
aFillCount
<
=
aLayers
.
Length
(
)
"
unexpected
array
length
"
)
;
for
(
uint32_t
sourceLayer
=
0
destLayer
=
aItemCount
;
destLayer
<
aFillCount
;
+
+
sourceLayer
+
+
destLayer
)
{
aLayers
[
destLayer
]
.
mPosition
.
*
aResultLocation
=
aLayers
[
sourceLayer
]
.
mPosition
.
*
aResultLocation
;
}
}
void
nsStyleImageLayers
:
:
FillAllLayers
(
uint32_t
aMaxItemCount
)
{
mLayers
.
TruncateLengthNonZero
(
aMaxItemCount
)
;
uint32_t
fillCount
=
mImageCount
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mImage
mImageCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mRepeat
mRepeatCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mAttachment
mAttachmentCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mClip
mClipCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mBlendMode
mBlendModeCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mOrigin
mOriginCount
fillCount
)
;
FillImageLayerPositionCoordList
(
mLayers
&
Position
:
:
horizontal
mPositionXCount
fillCount
)
;
FillImageLayerPositionCoordList
(
mLayers
&
Position
:
:
vertical
mPositionYCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mSize
mSizeCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mMaskMode
mMaskModeCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mComposite
mCompositeCount
fillCount
)
;
}
static
bool
UrlValuesEqual
(
const
nsStyleImage
&
aImage
const
nsStyleImage
&
aOtherImage
)
{
auto
*
url
=
aImage
.
GetURLValue
(
)
;
auto
*
other
=
aOtherImage
.
GetURLValue
(
)
;
return
url
=
=
other
|
|
(
url
&
&
other
&
&
*
url
=
=
*
other
)
;
}
nsChangeHint
nsStyleImageLayers
:
:
Layer
:
:
CalcDifference
(
const
nsStyleImageLayers
:
:
Layer
&
aNewLayer
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
!
UrlValuesEqual
(
mImage
aNewLayer
.
mImage
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateEffects
;
}
else
if
(
mAttachment
!
=
aNewLayer
.
mAttachment
|
|
mClip
!
=
aNewLayer
.
mClip
|
|
mOrigin
!
=
aNewLayer
.
mOrigin
|
|
mRepeat
!
=
aNewLayer
.
mRepeat
|
|
mBlendMode
!
=
aNewLayer
.
mBlendMode
|
|
mSize
!
=
aNewLayer
.
mSize
|
|
mImage
!
=
aNewLayer
.
mImage
|
|
mMaskMode
!
=
aNewLayer
.
mMaskMode
|
|
mComposite
!
=
aNewLayer
.
mComposite
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mPosition
!
=
aNewLayer
.
mPosition
)
{
hint
|
=
nsChangeHint_UpdateBackgroundPosition
;
}
return
hint
;
}
nsStyleBackground
:
:
nsStyleBackground
(
const
Document
&
aDocument
)
:
mImage
(
nsStyleImageLayers
:
:
LayerType
:
:
Background
)
mBackgroundColor
(
StyleColor
:
:
Transparent
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleBackground
)
;
}
nsStyleBackground
:
:
nsStyleBackground
(
const
nsStyleBackground
&
aSource
)
:
mImage
(
aSource
.
mImage
)
mBackgroundColor
(
aSource
.
mBackgroundColor
)
{
MOZ_COUNT_CTOR
(
nsStyleBackground
)
;
}
nsStyleBackground
:
:
~
nsStyleBackground
(
)
{
MOZ_COUNT_DTOR
(
nsStyleBackground
)
;
}
void
nsStyleBackground
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleBackground
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mImage
.
ResolveImages
(
aDocument
aOldStyle
?
&
aOldStyle
-
>
mImage
:
nullptr
)
;
}
nsChangeHint
nsStyleBackground
:
:
CalcDifference
(
const
nsStyleBackground
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mBackgroundColor
!
=
aNewData
.
mBackgroundColor
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
hint
|
=
mImage
.
CalcDifference
(
aNewData
.
mImage
nsStyleImageLayers
:
:
LayerType
:
:
Background
)
;
return
hint
;
}
bool
nsStyleBackground
:
:
HasFixedBackground
(
nsIFrame
*
aFrame
)
const
{
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
mImage
)
{
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mImage
.
mLayers
[
i
]
;
if
(
layer
.
mAttachment
=
=
StyleImageLayerAttachment
:
:
Fixed
&
&
!
layer
.
mImage
.
IsEmpty
(
)
&
&
!
nsLayoutUtils
:
:
IsTransformed
(
aFrame
)
)
{
return
true
;
}
}
return
false
;
}
nscolor
nsStyleBackground
:
:
BackgroundColor
(
const
nsIFrame
*
aFrame
)
const
{
return
mBackgroundColor
.
CalcColor
(
aFrame
)
;
}
nscolor
nsStyleBackground
:
:
BackgroundColor
(
ComputedStyle
*
aStyle
)
const
{
return
mBackgroundColor
.
CalcColor
(
*
aStyle
)
;
}
bool
nsStyleBackground
:
:
IsTransparent
(
const
nsIFrame
*
aFrame
)
const
{
return
IsTransparent
(
aFrame
-
>
Style
(
)
)
;
}
bool
nsStyleBackground
:
:
IsTransparent
(
mozilla
:
:
ComputedStyle
*
aStyle
)
const
{
return
BottomLayer
(
)
.
mImage
.
IsEmpty
(
)
&
&
mImage
.
mImageCount
=
=
1
&
&
NS_GET_A
(
BackgroundColor
(
aStyle
)
)
=
=
0
;
}
StyleTransition
:
:
StyleTransition
(
const
StyleTransition
&
aCopy
)
:
mTimingFunction
(
aCopy
.
mTimingFunction
)
mDuration
(
aCopy
.
mDuration
)
mDelay
(
aCopy
.
mDelay
)
mProperty
(
aCopy
.
mProperty
)
mUnknownProperty
(
aCopy
.
mUnknownProperty
)
{
}
void
StyleTransition
:
:
SetInitialValues
(
)
{
mTimingFunction
=
nsTimingFunction
(
StyleTimingKeyword
:
:
Ease
)
;
mDuration
=
0
.
0
;
mDelay
=
0
.
0
;
mProperty
=
eCSSPropertyExtra_all_properties
;
}
bool
StyleTransition
:
:
operator
=
=
(
const
StyleTransition
&
aOther
)
const
{
return
mTimingFunction
=
=
aOther
.
mTimingFunction
&
&
mDuration
=
=
aOther
.
mDuration
&
&
mDelay
=
=
aOther
.
mDelay
&
&
mProperty
=
=
aOther
.
mProperty
&
&
(
mProperty
!
=
eCSSProperty_UNKNOWN
|
|
mUnknownProperty
=
=
aOther
.
mUnknownProperty
)
;
}
StyleAnimation
:
:
StyleAnimation
(
const
StyleAnimation
&
aCopy
)
:
mTimingFunction
(
aCopy
.
mTimingFunction
)
mDuration
(
aCopy
.
mDuration
)
mDelay
(
aCopy
.
mDelay
)
mName
(
aCopy
.
mName
)
mDirection
(
aCopy
.
mDirection
)
mFillMode
(
aCopy
.
mFillMode
)
mPlayState
(
aCopy
.
mPlayState
)
mIterationCount
(
aCopy
.
mIterationCount
)
{
}
void
StyleAnimation
:
:
SetInitialValues
(
)
{
mTimingFunction
=
nsTimingFunction
(
StyleTimingKeyword
:
:
Ease
)
;
mDuration
=
0
.
0
;
mDelay
=
0
.
0
;
mName
=
nsGkAtoms
:
:
_empty
;
mDirection
=
dom
:
:
PlaybackDirection
:
:
Normal
;
mFillMode
=
dom
:
:
FillMode
:
:
None
;
mPlayState
=
StyleAnimationPlayState
:
:
Running
;
mIterationCount
=
1
.
0f
;
}
bool
StyleAnimation
:
:
operator
=
=
(
const
StyleAnimation
&
aOther
)
const
{
return
mTimingFunction
=
=
aOther
.
mTimingFunction
&
&
mDuration
=
=
aOther
.
mDuration
&
&
mDelay
=
=
aOther
.
mDelay
&
&
mName
=
=
aOther
.
mName
&
&
mDirection
=
=
aOther
.
mDirection
&
&
mFillMode
=
=
aOther
.
mFillMode
&
&
mPlayState
=
=
aOther
.
mPlayState
&
&
mIterationCount
=
=
aOther
.
mIterationCount
;
}
nsStyleDisplay
:
:
nsStyleDisplay
(
const
Document
&
aDocument
)
:
mTransitions
(
nsStyleAutoArray
<
StyleTransition
>
:
:
WITH_SINGLE_INITIAL_ELEMENT
)
mTransitionTimingFunctionCount
(
1
)
mTransitionDurationCount
(
1
)
mTransitionDelayCount
(
1
)
mTransitionPropertyCount
(
1
)
mAnimations
(
nsStyleAutoArray
<
StyleAnimation
>
:
:
WITH_SINGLE_INITIAL_ELEMENT
)
mAnimationTimingFunctionCount
(
1
)
mAnimationDurationCount
(
1
)
mAnimationDelayCount
(
1
)
mAnimationNameCount
(
1
)
mAnimationDirectionCount
(
1
)
mAnimationFillModeCount
(
1
)
mAnimationPlayStateCount
(
1
)
mAnimationIterationCountCount
(
1
)
mWillChange
{
{
}
{
0
}
}
mDisplay
(
StyleDisplay
:
:
Inline
)
mOriginalDisplay
(
StyleDisplay
:
:
Inline
)
mContain
(
StyleContain_NONE
)
mAppearance
(
StyleAppearance
:
:
None
)
mPosition
(
NS_STYLE_POSITION_STATIC
)
mFloat
(
StyleFloat
:
:
None
)
mBreakType
(
StyleClear
:
:
None
)
mBreakInside
(
StyleBreakWithin
:
:
Auto
)
mBreakBefore
(
StyleBreakBetween
:
:
Auto
)
mBreakAfter
(
StyleBreakBetween
:
:
Auto
)
mOverflowX
(
StyleOverflow
:
:
Visible
)
mOverflowY
(
StyleOverflow
:
:
Visible
)
mOverflowClipBoxBlock
(
StyleOverflowClipBox
:
:
PaddingBox
)
mOverflowClipBoxInline
(
StyleOverflowClipBox
:
:
PaddingBox
)
mResize
(
StyleResize
:
:
None
)
mOrient
(
StyleOrient
:
:
Inline
)
mIsolation
(
NS_STYLE_ISOLATION_AUTO
)
mTopLayer
(
NS_STYLE_TOP_LAYER_NONE
)
mTouchAction
(
StyleTouchAction_AUTO
)
mScrollBehavior
(
NS_STYLE_SCROLL_BEHAVIOR_AUTO
)
mOverscrollBehaviorX
(
StyleOverscrollBehavior
:
:
Auto
)
mOverscrollBehaviorY
(
StyleOverscrollBehavior
:
:
Auto
)
mOverflowAnchor
(
StyleOverflowAnchor
:
:
Auto
)
mScrollSnapAlign
{
StyleScrollSnapAlignKeyword
:
:
None
StyleScrollSnapAlignKeyword
:
:
None
}
mScrollSnapType
{
StyleScrollSnapAxis
:
:
Both
StyleScrollSnapStrictness
:
:
None
}
mLineClamp
(
0
)
mRotate
(
StyleRotate
:
:
None
(
)
)
mTranslate
(
StyleTranslate
:
:
None
(
)
)
mScale
(
StyleScale
:
:
None
(
)
)
mBackfaceVisibility
(
NS_STYLE_BACKFACE_VISIBILITY_VISIBLE
)
mTransformStyle
(
NS_STYLE_TRANSFORM_STYLE_FLAT
)
mTransformBox
(
StyleGeometryBox
:
:
BorderBox
)
mOffsetPath
(
StyleOffsetPath
:
:
None
(
)
)
mOffsetDistance
(
LengthPercentage
:
:
Zero
(
)
)
mOffsetRotate
{
true
StyleAngle
{
0
.
0
}
}
mOffsetAnchor
(
StylePositionOrAuto
:
:
Auto
(
)
)
mTransformOrigin
{
LengthPercentage
:
:
FromPercentage
(
0
.
5
)
LengthPercentage
:
:
FromPercentage
(
0
.
5
)
{
0
.
}
}
mChildPerspective
(
StylePerspective
:
:
None
(
)
)
mPerspectiveOrigin
(
Position
:
:
FromPercentage
(
0
.
5f
)
)
mVerticalAlign
(
StyleVerticalAlign
:
:
Keyword
(
StyleVerticalAlignKeyword
:
:
Baseline
)
)
mShapeMargin
(
LengthPercentage
:
:
Zero
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleDisplay
)
;
mTransitions
[
0
]
.
SetInitialValues
(
)
;
mAnimations
[
0
]
.
SetInitialValues
(
)
;
}
nsStyleDisplay
:
:
nsStyleDisplay
(
const
nsStyleDisplay
&
aSource
)
:
mTransitions
(
aSource
.
mTransitions
)
mTransitionTimingFunctionCount
(
aSource
.
mTransitionTimingFunctionCount
)
mTransitionDurationCount
(
aSource
.
mTransitionDurationCount
)
mTransitionDelayCount
(
aSource
.
mTransitionDelayCount
)
mTransitionPropertyCount
(
aSource
.
mTransitionPropertyCount
)
mAnimations
(
aSource
.
mAnimations
)
mAnimationTimingFunctionCount
(
aSource
.
mAnimationTimingFunctionCount
)
mAnimationDurationCount
(
aSource
.
mAnimationDurationCount
)
mAnimationDelayCount
(
aSource
.
mAnimationDelayCount
)
mAnimationNameCount
(
aSource
.
mAnimationNameCount
)
mAnimationDirectionCount
(
aSource
.
mAnimationDirectionCount
)
mAnimationFillModeCount
(
aSource
.
mAnimationFillModeCount
)
mAnimationPlayStateCount
(
aSource
.
mAnimationPlayStateCount
)
mAnimationIterationCountCount
(
aSource
.
mAnimationIterationCountCount
)
mWillChange
(
aSource
.
mWillChange
)
mDisplay
(
aSource
.
mDisplay
)
mOriginalDisplay
(
aSource
.
mOriginalDisplay
)
mContain
(
aSource
.
mContain
)
mAppearance
(
aSource
.
mAppearance
)
mPosition
(
aSource
.
mPosition
)
mFloat
(
aSource
.
mFloat
)
mBreakType
(
aSource
.
mBreakType
)
mBreakInside
(
aSource
.
mBreakInside
)
mBreakBefore
(
aSource
.
mBreakBefore
)
mBreakAfter
(
aSource
.
mBreakAfter
)
mOverflowX
(
aSource
.
mOverflowX
)
mOverflowY
(
aSource
.
mOverflowY
)
mOverflowClipBoxBlock
(
aSource
.
mOverflowClipBoxBlock
)
mOverflowClipBoxInline
(
aSource
.
mOverflowClipBoxInline
)
mResize
(
aSource
.
mResize
)
mOrient
(
aSource
.
mOrient
)
mIsolation
(
aSource
.
mIsolation
)
mTopLayer
(
aSource
.
mTopLayer
)
mTouchAction
(
aSource
.
mTouchAction
)
mScrollBehavior
(
aSource
.
mScrollBehavior
)
mOverscrollBehaviorX
(
aSource
.
mOverscrollBehaviorX
)
mOverscrollBehaviorY
(
aSource
.
mOverscrollBehaviorY
)
mOverflowAnchor
(
aSource
.
mOverflowAnchor
)
mScrollSnapAlign
(
aSource
.
mScrollSnapAlign
)
mScrollSnapType
(
aSource
.
mScrollSnapType
)
mLineClamp
(
aSource
.
mLineClamp
)
mTransform
(
aSource
.
mTransform
)
mRotate
(
aSource
.
mRotate
)
mTranslate
(
aSource
.
mTranslate
)
mScale
(
aSource
.
mScale
)
mBackfaceVisibility
(
aSource
.
mBackfaceVisibility
)
mTransformStyle
(
aSource
.
mTransformStyle
)
mTransformBox
(
aSource
.
mTransformBox
)
mOffsetPath
(
aSource
.
mOffsetPath
)
mOffsetDistance
(
aSource
.
mOffsetDistance
)
mOffsetRotate
(
aSource
.
mOffsetRotate
)
mOffsetAnchor
(
aSource
.
mOffsetAnchor
)
mTransformOrigin
(
aSource
.
mTransformOrigin
)
mChildPerspective
(
aSource
.
mChildPerspective
)
mPerspectiveOrigin
(
aSource
.
mPerspectiveOrigin
)
mVerticalAlign
(
aSource
.
mVerticalAlign
)
mShapeImageThreshold
(
aSource
.
mShapeImageThreshold
)
mShapeMargin
(
aSource
.
mShapeMargin
)
mShapeOutside
(
aSource
.
mShapeOutside
)
{
MOZ_COUNT_CTOR
(
nsStyleDisplay
)
;
}
nsStyleDisplay
:
:
~
nsStyleDisplay
(
)
{
MOZ_COUNT_DTOR
(
nsStyleDisplay
)
;
}
void
nsStyleDisplay
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleDisplay
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mShapeOutside
.
TriggerImageLoads
(
aDocument
aOldStyle
?
&
aOldStyle
-
>
mShapeOutside
:
nullptr
)
;
}
template
<
typename
TransformLike
>
static
inline
nsChangeHint
CompareTransformValues
(
const
TransformLike
&
aOldTransform
const
TransformLike
&
aNewTransform
)
{
nsChangeHint
result
=
nsChangeHint
(
0
)
;
if
(
aOldTransform
!
=
aNewTransform
)
{
result
|
=
nsChangeHint_UpdateTransformLayer
;
if
(
!
aOldTransform
.
IsNone
(
)
&
&
!
aNewTransform
.
IsNone
(
)
)
{
result
|
=
nsChangeHint_UpdatePostTransformOverflow
;
}
else
{
result
|
=
nsChangeHint_UpdateOverflow
;
}
}
return
result
;
}
static
inline
nsChangeHint
CompareMotionValues
(
const
nsStyleDisplay
&
aDisplay
const
nsStyleDisplay
&
aNewDisplay
)
{
if
(
aDisplay
.
mOffsetPath
=
=
aNewDisplay
.
mOffsetPath
)
{
if
(
aDisplay
.
mOffsetDistance
=
=
aNewDisplay
.
mOffsetDistance
&
&
aDisplay
.
mOffsetRotate
=
=
aNewDisplay
.
mOffsetRotate
&
&
aDisplay
.
mOffsetAnchor
=
=
aNewDisplay
.
mOffsetAnchor
)
{
return
nsChangeHint
(
0
)
;
}
if
(
aDisplay
.
mOffsetPath
.
IsNone
(
)
)
{
return
nsChangeHint_NeutralChange
;
}
}
nsChangeHint
result
=
nsChangeHint_UpdateTransformLayer
;
if
(
!
aDisplay
.
mOffsetPath
.
IsNone
(
)
&
&
!
aNewDisplay
.
mOffsetPath
.
IsNone
(
)
)
{
result
|
=
nsChangeHint_UpdatePostTransformOverflow
;
}
else
{
result
|
=
nsChangeHint_UpdateOverflow
;
}
return
result
;
}
static
bool
ScrollbarGenerationChanged
(
const
nsStyleDisplay
&
aOld
const
nsStyleDisplay
&
aNew
)
{
auto
changed
=
[
]
(
StyleOverflow
aOld
StyleOverflow
aNew
)
{
return
aOld
!
=
aNew
&
&
(
aOld
=
=
StyleOverflow
:
:
Hidden
|
|
aNew
=
=
StyleOverflow
:
:
Hidden
)
;
}
;
return
changed
(
aOld
.
mOverflowX
aNew
.
mOverflowX
)
|
|
changed
(
aOld
.
mOverflowY
aNew
.
mOverflowY
)
;
}
nsChangeHint
nsStyleDisplay
:
:
CalcDifference
(
const
nsStyleDisplay
&
aNewData
const
nsStylePosition
&
aOldPosition
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mPosition
!
=
aNewData
.
mPosition
|
|
mDisplay
!
=
aNewData
.
mDisplay
|
|
mContain
!
=
aNewData
.
mContain
|
|
(
mFloat
=
=
StyleFloat
:
:
None
)
!
=
(
aNewData
.
mFloat
=
=
StyleFloat
:
:
None
)
|
|
mScrollBehavior
!
=
aNewData
.
mScrollBehavior
|
|
mScrollSnapType
!
=
aNewData
.
mScrollSnapType
|
|
mTopLayer
!
=
aNewData
.
mTopLayer
|
|
mResize
!
=
aNewData
.
mResize
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
(
mAppearance
=
=
StyleAppearance
:
:
Textfield
&
&
aNewData
.
mAppearance
!
=
StyleAppearance
:
:
Textfield
)
|
|
(
mAppearance
!
=
StyleAppearance
:
:
Textfield
&
&
aNewData
.
mAppearance
=
=
StyleAppearance
:
:
Textfield
)
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
mScrollSnapAlign
!
=
aNewData
.
mScrollSnapAlign
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
if
(
mOverflowX
!
=
aNewData
.
mOverflowX
|
|
mOverflowY
!
=
aNewData
.
mOverflowY
)
{
const
bool
isScrollable
=
IsScrollableOverflow
(
)
;
if
(
isScrollable
!
=
aNewData
.
IsScrollableOverflow
(
)
)
{
hint
|
=
nsChangeHint_ScrollbarChange
;
}
else
if
(
isScrollable
)
{
if
(
ScrollbarGenerationChanged
(
*
this
aNewData
)
)
{
hint
|
=
nsChangeHint_ScrollbarChange
;
}
else
{
hint
|
=
nsChangeHint_ReflowHintsForScrollbarChange
;
}
}
else
{
hint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_RepaintFrame
;
}
}
if
(
mFloat
!
=
aNewData
.
mFloat
)
{
hint
|
=
nsChangeHint_ReflowHintsForFloatAreaChange
;
}
if
(
mShapeOutside
!
=
aNewData
.
mShapeOutside
|
|
mShapeMargin
!
=
aNewData
.
mShapeMargin
|
|
mShapeImageThreshold
!
=
aNewData
.
mShapeImageThreshold
)
{
if
(
aNewData
.
mFloat
!
=
StyleFloat
:
:
None
)
{
hint
|
=
nsChangeHint_ReflowHintsForFloatAreaChange
;
}
else
{
hint
|
=
nsChangeHint_NeutralChange
;
}
}
if
(
mLineClamp
!
=
aNewData
.
mLineClamp
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
if
(
mVerticalAlign
!
=
aNewData
.
mVerticalAlign
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
if
(
mBreakType
!
=
aNewData
.
mBreakType
|
|
mBreakInside
!
=
aNewData
.
mBreakInside
|
|
mBreakBefore
!
=
aNewData
.
mBreakBefore
|
|
mBreakAfter
!
=
aNewData
.
mBreakAfter
|
|
mAppearance
!
=
aNewData
.
mAppearance
|
|
mOrient
!
=
aNewData
.
mOrient
|
|
mOverflowClipBoxBlock
!
=
aNewData
.
mOverflowClipBoxBlock
|
|
mOverflowClipBoxInline
!
=
aNewData
.
mOverflowClipBoxInline
)
{
hint
|
=
nsChangeHint_AllReflowHints
|
nsChangeHint_RepaintFrame
;
}
if
(
mIsolation
!
=
aNewData
.
mIsolation
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
HasTransformStyle
(
)
!
=
aNewData
.
HasTransformStyle
(
)
)
{
hint
|
=
nsChangeHint_ComprehensiveAddOrRemoveTransform
;
}
else
{
nsChangeHint
transformHint
=
nsChangeHint
(
0
)
;
transformHint
|
=
CompareTransformValues
(
mTransform
aNewData
.
mTransform
)
;
transformHint
|
=
CompareTransformValues
(
mRotate
aNewData
.
mRotate
)
;
transformHint
|
=
CompareTransformValues
(
mTranslate
aNewData
.
mTranslate
)
;
transformHint
|
=
CompareTransformValues
(
mScale
aNewData
.
mScale
)
;
transformHint
|
=
CompareMotionValues
(
*
this
aNewData
)
;
if
(
mTransformOrigin
!
=
aNewData
.
mTransformOrigin
)
{
transformHint
|
=
nsChangeHint_UpdateTransformLayer
|
nsChangeHint_UpdatePostTransformOverflow
;
}
if
(
mPerspectiveOrigin
!
=
aNewData
.
mPerspectiveOrigin
|
|
mTransformStyle
!
=
aNewData
.
mTransformStyle
|
|
mTransformBox
!
=
aNewData
.
mTransformBox
)
{
transformHint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_RepaintFrame
;
}
if
(
mBackfaceVisibility
!
=
aNewData
.
mBackfaceVisibility
)
{
transformHint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
transformHint
)
{
if
(
HasTransformStyle
(
)
)
{
hint
|
=
transformHint
;
}
else
{
hint
|
=
nsChangeHint_NeutralChange
;
}
}
}
if
(
HasPerspectiveStyle
(
)
!
=
aNewData
.
HasPerspectiveStyle
(
)
)
{
hint
|
=
nsChangeHint_UpdateContainingBlock
|
nsChangeHint_UpdateOverflow
|
nsChangeHint_RepaintFrame
;
}
else
if
(
mChildPerspective
!
=
aNewData
.
mChildPerspective
)
{
hint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_RepaintFrame
;
}
auto
willChangeBitsChanged
=
StyleWillChangeBits
{
static_cast
<
decltype
(
StyleWillChangeBits
:
:
bits
)
>
(
mWillChange
.
bits
.
bits
^
aNewData
.
mWillChange
.
bits
.
bits
)
}
;
if
(
willChangeBitsChanged
&
(
StyleWillChangeBits_STACKING_CONTEXT
|
StyleWillChangeBits_SCROLL
|
StyleWillChangeBits_OPACITY
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
willChangeBitsChanged
&
(
StyleWillChangeBits_FIXPOS_CB
|
StyleWillChangeBits_ABSPOS_CB
)
)
{
hint
|
=
nsChangeHint_UpdateContainingBlock
;
}
if
(
mTouchAction
!
=
aNewData
.
mTouchAction
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mOverscrollBehaviorX
!
=
aNewData
.
mOverscrollBehaviorX
|
|
mOverscrollBehaviorY
!
=
aNewData
.
mOverscrollBehaviorY
)
{
hint
|
=
nsChangeHint_SchedulePaint
;
}
if
(
mOriginalDisplay
!
=
aNewData
.
mOriginalDisplay
)
{
if
(
IsAbsolutelyPositionedStyle
(
)
&
&
aOldPosition
.
NeedsHypotheticalPositionIfAbsPos
(
)
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_ReflowChangesSizeOrPosition
;
}
else
{
hint
|
=
nsChangeHint_NeutralChange
;
}
}
if
(
!
hint
&
&
(
mTransitions
!
=
aNewData
.
mTransitions
|
|
mTransitionTimingFunctionCount
!
=
aNewData
.
mTransitionTimingFunctionCount
|
|
mTransitionDurationCount
!
=
aNewData
.
mTransitionDurationCount
|
|
mTransitionDelayCount
!
=
aNewData
.
mTransitionDelayCount
|
|
mTransitionPropertyCount
!
=
aNewData
.
mTransitionPropertyCount
|
|
mAnimations
!
=
aNewData
.
mAnimations
|
|
mAnimationTimingFunctionCount
!
=
aNewData
.
mAnimationTimingFunctionCount
|
|
mAnimationDurationCount
!
=
aNewData
.
mAnimationDurationCount
|
|
mAnimationDelayCount
!
=
aNewData
.
mAnimationDelayCount
|
|
mAnimationNameCount
!
=
aNewData
.
mAnimationNameCount
|
|
mAnimationDirectionCount
!
=
aNewData
.
mAnimationDirectionCount
|
|
mAnimationFillModeCount
!
=
aNewData
.
mAnimationFillModeCount
|
|
mAnimationPlayStateCount
!
=
aNewData
.
mAnimationPlayStateCount
|
|
mAnimationIterationCountCount
!
=
aNewData
.
mAnimationIterationCountCount
|
|
mWillChange
!
=
aNewData
.
mWillChange
|
|
mOverflowAnchor
!
=
aNewData
.
mOverflowAnchor
)
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
nsStyleVisibility
:
:
nsStyleVisibility
(
const
Document
&
aDocument
)
:
mDirection
(
aDocument
.
GetBidiOptions
(
)
=
=
IBMBIDI_TEXTDIRECTION_RTL
?
NS_STYLE_DIRECTION_RTL
:
NS_STYLE_DIRECTION_LTR
)
mVisible
(
NS_STYLE_VISIBILITY_VISIBLE
)
mImageRendering
(
NS_STYLE_IMAGE_RENDERING_AUTO
)
mWritingMode
(
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
)
mTextOrientation
(
NS_STYLE_TEXT_ORIENTATION_MIXED
)
mColorAdjust
(
StyleColorAdjust
:
:
Economy
)
{
MOZ_COUNT_CTOR
(
nsStyleVisibility
)
;
}
nsStyleVisibility
:
:
nsStyleVisibility
(
const
nsStyleVisibility
&
aSource
)
:
mImageOrientation
(
aSource
.
mImageOrientation
)
mDirection
(
aSource
.
mDirection
)
mVisible
(
aSource
.
mVisible
)
mImageRendering
(
aSource
.
mImageRendering
)
mWritingMode
(
aSource
.
mWritingMode
)
mTextOrientation
(
aSource
.
mTextOrientation
)
mColorAdjust
(
aSource
.
mColorAdjust
)
{
MOZ_COUNT_CTOR
(
nsStyleVisibility
)
;
}
nsChangeHint
nsStyleVisibility
:
:
CalcDifference
(
const
nsStyleVisibility
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mDirection
!
=
aNewData
.
mDirection
|
|
mWritingMode
!
=
aNewData
.
mWritingMode
)
{
hint
|
=
nsChangeHint_ReconstructFrame
;
}
else
{
if
(
(
mImageOrientation
!
=
aNewData
.
mImageOrientation
)
)
{
hint
|
=
nsChangeHint_AllReflowHints
|
nsChangeHint_RepaintFrame
;
}
if
(
mVisible
!
=
aNewData
.
mVisible
)
{
if
(
mVisible
=
=
NS_STYLE_VISIBILITY_VISIBLE
|
|
aNewData
.
mVisible
=
=
NS_STYLE_VISIBILITY_VISIBLE
)
{
hint
|
=
nsChangeHint_VisibilityChange
;
}
if
(
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
mVisible
)
|
|
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
aNewData
.
mVisible
)
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
else
{
hint
|
=
NS_STYLE_HINT_VISUAL
;
}
}
if
(
mTextOrientation
!
=
aNewData
.
mTextOrientation
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
if
(
mImageRendering
!
=
aNewData
.
mImageRendering
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mColorAdjust
!
=
aNewData
.
mColorAdjust
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
}
return
hint
;
}
nsStyleContentData
:
:
~
nsStyleContentData
(
)
{
MOZ_COUNT_DTOR
(
nsStyleContentData
)
;
if
(
mType
=
=
StyleContentType
:
:
Image
)
{
NS_ReleaseOnMainThreadSystemGroup
(
"
nsStyleContentData
:
:
mContent
.
mImage
"
dont_AddRef
(
mContent
.
mImage
)
)
;
mContent
.
mImage
=
nullptr
;
}
else
if
(
mType
=
=
StyleContentType
:
:
Counter
|
|
mType
=
=
StyleContentType
:
:
Counters
)
{
mContent
.
mCounters
-
>
Release
(
)
;
}
else
if
(
mType
=
=
StyleContentType
:
:
String
)
{
free
(
mContent
.
mString
)
;
}
else
if
(
mType
=
=
StyleContentType
:
:
Attr
)
{
delete
mContent
.
mAttr
;
}
else
{
MOZ_ASSERT
(
mContent
.
mString
=
=
nullptr
"
Leaking
due
to
missing
case
"
)
;
}
}
nsStyleContentData
:
:
nsStyleContentData
(
const
nsStyleContentData
&
aOther
)
:
mType
(
aOther
.
mType
)
{
MOZ_COUNT_CTOR
(
nsStyleContentData
)
;
switch
(
mType
)
{
case
StyleContentType
:
:
Image
:
mContent
.
mImage
=
aOther
.
mContent
.
mImage
;
mContent
.
mImage
-
>
AddRef
(
)
;
break
;
case
StyleContentType
:
:
Counter
:
case
StyleContentType
:
:
Counters
:
mContent
.
mCounters
=
aOther
.
mContent
.
mCounters
;
mContent
.
mCounters
-
>
AddRef
(
)
;
break
;
case
StyleContentType
:
:
Attr
:
mContent
.
mAttr
=
new
nsStyleContentAttr
(
*
aOther
.
mContent
.
mAttr
)
;
break
;
case
StyleContentType
:
:
String
:
mContent
.
mString
=
NS_xstrdup
(
aOther
.
mContent
.
mString
)
;
break
;
default
:
MOZ_ASSERT
(
!
aOther
.
mContent
.
mString
)
;
mContent
.
mString
=
nullptr
;
}
}
bool
nsStyleContentData
:
:
CounterFunction
:
:
operator
=
=
(
const
CounterFunction
&
aOther
)
const
{
return
mIdent
=
=
aOther
.
mIdent
&
&
mSeparator
=
=
aOther
.
mSeparator
&
&
mCounterStyle
=
=
aOther
.
mCounterStyle
;
}
nsStyleContentData
&
nsStyleContentData
:
:
operator
=
(
const
nsStyleContentData
&
aOther
)
{
if
(
this
=
=
&
aOther
)
{
return
*
this
;
}
this
-
>
~
nsStyleContentData
(
)
;
new
(
this
)
nsStyleContentData
(
aOther
)
;
return
*
this
;
}
bool
nsStyleContentData
:
:
operator
=
=
(
const
nsStyleContentData
&
aOther
)
const
{
if
(
mType
!
=
aOther
.
mType
)
{
return
false
;
}
if
(
mType
=
=
StyleContentType
:
:
Image
)
{
return
DefinitelyEqualImages
(
mContent
.
mImage
aOther
.
mContent
.
mImage
)
;
}
if
(
mType
=
=
StyleContentType
:
:
Attr
)
{
return
*
mContent
.
mAttr
=
=
*
aOther
.
mContent
.
mAttr
;
}
if
(
mType
=
=
StyleContentType
:
:
Counter
|
|
mType
=
=
StyleContentType
:
:
Counters
)
{
return
*
mContent
.
mCounters
=
=
*
aOther
.
mContent
.
mCounters
;
}
if
(
mType
=
=
StyleContentType
:
:
String
)
{
return
NS_strcmp
(
mContent
.
mString
aOther
.
mContent
.
mString
)
=
=
0
;
}
MOZ_ASSERT
(
!
mContent
.
mString
&
&
!
aOther
.
mContent
.
mString
)
;
return
true
;
}
void
nsStyleContentData
:
:
Resolve
(
Document
&
aDocument
const
nsStyleContentData
*
aOldStyle
)
{
if
(
mType
!
=
StyleContentType
:
:
Image
)
{
return
;
}
if
(
!
mContent
.
mImage
-
>
IsResolved
(
)
)
{
const
nsStyleImageRequest
*
oldRequest
=
(
aOldStyle
&
&
aOldStyle
-
>
mType
=
=
StyleContentType
:
:
Image
)
?
aOldStyle
-
>
mContent
.
mImage
:
nullptr
;
mContent
.
mImage
-
>
Resolve
(
aDocument
oldRequest
)
;
}
}
nsStyleContent
:
:
nsStyleContent
(
const
Document
&
aDocument
)
{
MOZ_COUNT_CTOR
(
nsStyleContent
)
;
}
nsStyleContent
:
:
~
nsStyleContent
(
)
{
MOZ_COUNT_DTOR
(
nsStyleContent
)
;
}
void
nsStyleContent
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleContent
*
aOldStyle
)
{
for
(
size_t
i
=
0
;
i
<
mContents
.
Length
(
)
;
+
+
i
)
{
const
nsStyleContentData
*
oldData
=
(
aOldStyle
&
&
aOldStyle
-
>
mContents
.
Length
(
)
>
i
)
?
&
aOldStyle
-
>
mContents
[
i
]
:
nullptr
;
mContents
[
i
]
.
Resolve
(
aDocument
oldData
)
;
}
}
nsStyleContent
:
:
nsStyleContent
(
const
nsStyleContent
&
aSource
)
:
mContents
(
aSource
.
mContents
)
mCounterIncrement
(
aSource
.
mCounterIncrement
)
mCounterReset
(
aSource
.
mCounterReset
)
mCounterSet
(
aSource
.
mCounterSet
)
{
MOZ_COUNT_CTOR
(
nsStyleContent
)
;
}
nsChangeHint
nsStyleContent
:
:
CalcDifference
(
const
nsStyleContent
&
aNewData
)
const
{
if
(
mContents
!
=
aNewData
.
mContents
|
|
mCounterIncrement
!
=
aNewData
.
mCounterIncrement
|
|
mCounterReset
!
=
aNewData
.
mCounterReset
|
|
mCounterSet
!
=
aNewData
.
mCounterSet
)
{
return
nsChangeHint_ReconstructFrame
;
}
return
nsChangeHint
(
0
)
;
}
nsStyleTextReset
:
:
nsStyleTextReset
(
const
Document
&
aDocument
)
:
mTextOverflow
(
)
mTextDecorationLine
(
StyleTextDecorationLine_NONE
)
mTextDecorationStyle
(
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
)
mUnicodeBidi
(
NS_STYLE_UNICODE_BIDI_NORMAL
)
mInitialLetterSink
(
0
)
mInitialLetterSize
(
0
.
0f
)
mTextDecorationColor
(
StyleColor
:
:
CurrentColor
(
)
)
mTextDecorationThickness
(
StyleTextDecorationLength
:
:
Auto
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleTextReset
)
;
}
nsStyleTextReset
:
:
nsStyleTextReset
(
const
nsStyleTextReset
&
aSource
)
:
mTextOverflow
(
aSource
.
mTextOverflow
)
mTextDecorationLine
(
aSource
.
mTextDecorationLine
)
mTextDecorationStyle
(
aSource
.
mTextDecorationStyle
)
mUnicodeBidi
(
aSource
.
mUnicodeBidi
)
mInitialLetterSink
(
aSource
.
mInitialLetterSink
)
mInitialLetterSize
(
aSource
.
mInitialLetterSize
)
mTextDecorationColor
(
aSource
.
mTextDecorationColor
)
mTextDecorationThickness
(
aSource
.
mTextDecorationThickness
)
{
MOZ_COUNT_CTOR
(
nsStyleTextReset
)
;
}
nsStyleTextReset
:
:
~
nsStyleTextReset
(
)
{
MOZ_COUNT_DTOR
(
nsStyleTextReset
)
;
}
nsChangeHint
nsStyleTextReset
:
:
CalcDifference
(
const
nsStyleTextReset
&
aNewData
)
const
{
if
(
mUnicodeBidi
!
=
aNewData
.
mUnicodeBidi
|
|
mInitialLetterSink
!
=
aNewData
.
mInitialLetterSink
|
|
mInitialLetterSize
!
=
aNewData
.
mInitialLetterSize
)
{
return
NS_STYLE_HINT_REFLOW
;
}
if
(
mTextDecorationLine
!
=
aNewData
.
mTextDecorationLine
|
|
mTextDecorationStyle
!
=
aNewData
.
mTextDecorationStyle
|
|
mTextDecorationThickness
!
=
aNewData
.
mTextDecorationThickness
)
{
return
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateSubtreeOverflow
|
nsChangeHint_SchedulePaint
;
}
if
(
mTextDecorationColor
!
=
aNewData
.
mTextDecorationColor
)
{
return
nsChangeHint_RepaintFrame
;
}
if
(
mTextOverflow
!
=
aNewData
.
mTextOverflow
)
{
return
nsChangeHint_RepaintFrame
;
}
return
nsChangeHint
(
0
)
;
}
static
StyleRGBA
DefaultColor
(
const
Document
&
aDocument
)
{
return
StyleRGBA
:
:
FromColor
(
PreferenceSheet
:
:
PrefsFor
(
aDocument
)
.
mDefaultColor
)
;
}
nsStyleText
:
:
nsStyleText
(
const
Document
&
aDocument
)
:
mColor
(
DefaultColor
(
aDocument
)
)
mTextTransform
(
StyleTextTransform
:
:
None
(
)
)
mTextAlign
(
NS_STYLE_TEXT_ALIGN_START
)
mTextAlignLast
(
NS_STYLE_TEXT_ALIGN_AUTO
)
mTextJustify
(
StyleTextJustify
:
:
Auto
)
mWhiteSpace
(
StyleWhiteSpace
:
:
Normal
)
mHyphens
(
StyleHyphens
:
:
Manual
)
mRubyAlign
(
NS_STYLE_RUBY_ALIGN_SPACE_AROUND
)
mRubyPosition
(
NS_STYLE_RUBY_POSITION_OVER
)
mTextSizeAdjust
(
NS_STYLE_TEXT_SIZE_ADJUST_AUTO
)
mTextCombineUpright
(
NS_STYLE_TEXT_COMBINE_UPRIGHT_NONE
)
mControlCharacterVisibility
(
nsLayoutUtils
:
:
ControlCharVisibilityDefault
(
)
)
mTextRendering
(
StyleTextRendering
:
:
Auto
)
mTextEmphasisColor
(
StyleColor
:
:
CurrentColor
(
)
)
mWebkitTextFillColor
(
StyleColor
:
:
CurrentColor
(
)
)
mWebkitTextStrokeColor
(
StyleColor
:
:
CurrentColor
(
)
)
mMozTabSize
(
StyleNonNegativeLengthOrNumber
:
:
Number
(
NS_STYLE_TABSIZE_INITIAL
)
)
mWordSpacing
(
LengthPercentage
:
:
Zero
(
)
)
mLetterSpacing
(
{
0
.
}
)
mLineHeight
(
StyleLineHeight
:
:
Normal
(
)
)
mTextIndent
(
LengthPercentage
:
:
Zero
(
)
)
mTextUnderlineOffset
(
StyleTextDecorationLength
:
:
Auto
(
)
)
mTextDecorationSkipInk
(
StyleTextDecorationSkipInk
:
:
Auto
)
mWebkitTextStrokeWidth
(
0
)
mTextEmphasisStyle
(
StyleTextEmphasisStyle
:
:
None
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleText
)
;
RefPtr
<
nsAtom
>
language
=
aDocument
.
GetContentLanguageAsAtomForStyle
(
)
;
mTextEmphasisPosition
=
language
&
&
nsStyleUtil
:
:
MatchesLanguagePrefix
(
language
u
"
zh
"
)
?
NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT_ZH
:
NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT
;
}
nsStyleText
:
:
nsStyleText
(
const
nsStyleText
&
aSource
)
:
mColor
(
aSource
.
mColor
)
mTextTransform
(
aSource
.
mTextTransform
)
mTextAlign
(
aSource
.
mTextAlign
)
mTextAlignLast
(
aSource
.
mTextAlignLast
)
mTextJustify
(
aSource
.
mTextJustify
)
mWhiteSpace
(
aSource
.
mWhiteSpace
)
mLineBreak
(
aSource
.
mLineBreak
)
mWordBreak
(
aSource
.
mWordBreak
)
mOverflowWrap
(
aSource
.
mOverflowWrap
)
mHyphens
(
aSource
.
mHyphens
)
mRubyAlign
(
aSource
.
mRubyAlign
)
mRubyPosition
(
aSource
.
mRubyPosition
)
mTextSizeAdjust
(
aSource
.
mTextSizeAdjust
)
mTextCombineUpright
(
aSource
.
mTextCombineUpright
)
mControlCharacterVisibility
(
aSource
.
mControlCharacterVisibility
)
mTextEmphasisPosition
(
aSource
.
mTextEmphasisPosition
)
mTextRendering
(
aSource
.
mTextRendering
)
mTextEmphasisColor
(
aSource
.
mTextEmphasisColor
)
mWebkitTextFillColor
(
aSource
.
mWebkitTextFillColor
)
mWebkitTextStrokeColor
(
aSource
.
mWebkitTextStrokeColor
)
mMozTabSize
(
aSource
.
mMozTabSize
)
mWordSpacing
(
aSource
.
mWordSpacing
)
mLetterSpacing
(
aSource
.
mLetterSpacing
)
mLineHeight
(
aSource
.
mLineHeight
)
mTextIndent
(
aSource
.
mTextIndent
)
mTextUnderlineOffset
(
aSource
.
mTextUnderlineOffset
)
mTextDecorationSkipInk
(
aSource
.
mTextDecorationSkipInk
)
mWebkitTextStrokeWidth
(
aSource
.
mWebkitTextStrokeWidth
)
mTextShadow
(
aSource
.
mTextShadow
)
mTextEmphasisStyle
(
aSource
.
mTextEmphasisStyle
)
{
MOZ_COUNT_CTOR
(
nsStyleText
)
;
}
nsStyleText
:
:
~
nsStyleText
(
)
{
MOZ_COUNT_DTOR
(
nsStyleText
)
;
}
nsChangeHint
nsStyleText
:
:
CalcDifference
(
const
nsStyleText
&
aNewData
)
const
{
if
(
WhiteSpaceOrNewlineIsSignificant
(
)
!
=
aNewData
.
WhiteSpaceOrNewlineIsSignificant
(
)
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
mTextCombineUpright
!
=
aNewData
.
mTextCombineUpright
|
|
mControlCharacterVisibility
!
=
aNewData
.
mControlCharacterVisibility
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
(
mTextAlign
!
=
aNewData
.
mTextAlign
)
|
|
(
mTextAlignLast
!
=
aNewData
.
mTextAlignLast
)
|
|
(
mTextTransform
!
=
aNewData
.
mTextTransform
)
|
|
(
mWhiteSpace
!
=
aNewData
.
mWhiteSpace
)
|
|
(
mLineBreak
!
=
aNewData
.
mLineBreak
)
|
|
(
mWordBreak
!
=
aNewData
.
mWordBreak
)
|
|
(
mOverflowWrap
!
=
aNewData
.
mOverflowWrap
)
|
|
(
mHyphens
!
=
aNewData
.
mHyphens
)
|
|
(
mRubyAlign
!
=
aNewData
.
mRubyAlign
)
|
|
(
mRubyPosition
!
=
aNewData
.
mRubyPosition
)
|
|
(
mTextSizeAdjust
!
=
aNewData
.
mTextSizeAdjust
)
|
|
(
mLetterSpacing
!
=
aNewData
.
mLetterSpacing
)
|
|
(
mLineHeight
!
=
aNewData
.
mLineHeight
)
|
|
(
mTextIndent
!
=
aNewData
.
mTextIndent
)
|
|
(
mTextUnderlineOffset
!
=
aNewData
.
mTextUnderlineOffset
)
|
|
(
mTextDecorationSkipInk
!
=
aNewData
.
mTextDecorationSkipInk
)
|
|
(
mTextJustify
!
=
aNewData
.
mTextJustify
)
|
|
(
mWordSpacing
!
=
aNewData
.
mWordSpacing
)
|
|
(
mMozTabSize
!
=
aNewData
.
mMozTabSize
)
)
{
return
NS_STYLE_HINT_REFLOW
;
}
if
(
HasEffectiveTextEmphasis
(
)
!
=
aNewData
.
HasEffectiveTextEmphasis
(
)
|
|
(
HasEffectiveTextEmphasis
(
)
&
&
mTextEmphasisPosition
!
=
aNewData
.
mTextEmphasisPosition
)
)
{
return
nsChangeHint_AllReflowHints
|
nsChangeHint_RepaintFrame
;
}
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mTextRendering
!
=
aNewData
.
mTextRendering
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
|
nsChangeHint_RepaintFrame
;
}
if
(
mTextShadow
!
=
aNewData
.
mTextShadow
|
|
mTextEmphasisStyle
!
=
aNewData
.
mTextEmphasisStyle
|
|
mWebkitTextStrokeWidth
!
=
aNewData
.
mWebkitTextStrokeWidth
)
{
hint
|
=
nsChangeHint_UpdateSubtreeOverflow
|
nsChangeHint_SchedulePaint
|
nsChangeHint_RepaintFrame
;
return
hint
;
}
if
(
mColor
!
=
aNewData
.
mColor
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mTextEmphasisColor
!
=
aNewData
.
mTextEmphasisColor
|
|
mWebkitTextFillColor
!
=
aNewData
.
mWebkitTextFillColor
|
|
mWebkitTextStrokeColor
!
=
aNewData
.
mWebkitTextStrokeColor
)
{
hint
|
=
nsChangeHint_SchedulePaint
|
nsChangeHint_RepaintFrame
;
}
if
(
hint
)
{
return
hint
;
}
if
(
mTextEmphasisPosition
!
=
aNewData
.
mTextEmphasisPosition
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
LogicalSide
nsStyleText
:
:
TextEmphasisSide
(
WritingMode
aWM
)
const
{
MOZ_ASSERT
(
(
!
(
mTextEmphasisPosition
&
NS_STYLE_TEXT_EMPHASIS_POSITION_LEFT
)
!
=
!
(
mTextEmphasisPosition
&
NS_STYLE_TEXT_EMPHASIS_POSITION_RIGHT
)
)
&
&
(
!
(
mTextEmphasisPosition
&
NS_STYLE_TEXT_EMPHASIS_POSITION_OVER
)
!
=
!
(
mTextEmphasisPosition
&
NS_STYLE_TEXT_EMPHASIS_POSITION_UNDER
)
)
)
;
mozilla
:
:
Side
side
=
aWM
.
IsVertical
(
)
?
(
mTextEmphasisPosition
&
NS_STYLE_TEXT_EMPHASIS_POSITION_LEFT
?
eSideLeft
:
eSideRight
)
:
(
mTextEmphasisPosition
&
NS_STYLE_TEXT_EMPHASIS_POSITION_OVER
?
eSideTop
:
eSideBottom
)
;
LogicalSide
result
=
aWM
.
LogicalSideForPhysicalSide
(
side
)
;
MOZ_ASSERT
(
IsBlock
(
result
)
)
;
return
result
;
}
nsCursorImage
:
:
nsCursorImage
(
)
:
mHaveHotspot
(
false
)
mHotspotX
(
0
.
0f
)
mHotspotY
(
0
.
0f
)
{
}
nsCursorImage
:
:
nsCursorImage
(
const
nsCursorImage
&
aOther
)
:
mHaveHotspot
(
aOther
.
mHaveHotspot
)
mHotspotX
(
aOther
.
mHotspotX
)
mHotspotY
(
aOther
.
mHotspotY
)
mImage
(
aOther
.
mImage
)
{
}
nsCursorImage
&
nsCursorImage
:
:
operator
=
(
const
nsCursorImage
&
aOther
)
{
if
(
this
!
=
&
aOther
)
{
mHaveHotspot
=
aOther
.
mHaveHotspot
;
mHotspotX
=
aOther
.
mHotspotX
;
mHotspotY
=
aOther
.
mHotspotY
;
mImage
=
aOther
.
mImage
;
}
return
*
this
;
}
bool
nsCursorImage
:
:
operator
=
=
(
const
nsCursorImage
&
aOther
)
const
{
NS_ASSERTION
(
mHaveHotspot
|
|
(
mHotspotX
=
=
0
&
&
mHotspotY
=
=
0
)
"
expected
mHotspot
{
X
Y
}
to
be
0
when
mHaveHotspot
is
false
"
)
;
NS_ASSERTION
(
aOther
.
mHaveHotspot
|
|
(
aOther
.
mHotspotX
=
=
0
&
&
aOther
.
mHotspotY
=
=
0
)
"
expected
mHotspot
{
X
Y
}
to
be
0
when
mHaveHotspot
is
false
"
)
;
return
mHaveHotspot
=
=
aOther
.
mHaveHotspot
&
&
mHotspotX
=
=
aOther
.
mHotspotX
&
&
mHotspotY
=
=
aOther
.
mHotspotY
&
&
DefinitelyEqualImages
(
mImage
aOther
.
mImage
)
;
}
nsStyleUI
:
:
nsStyleUI
(
const
Document
&
aDocument
)
:
mUserInput
(
StyleUserInput
:
:
Auto
)
mUserModify
(
StyleUserModify
:
:
ReadOnly
)
mUserFocus
(
StyleUserFocus
:
:
None
)
mPointerEvents
(
NS_STYLE_POINTER_EVENTS_AUTO
)
mCursor
(
StyleCursorKind
:
:
Auto
)
mCaretColor
(
StyleColorOrAuto
:
:
Auto
(
)
)
mScrollbarColor
(
StyleScrollbarColor
:
:
Auto
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleUI
)
;
}
nsStyleUI
:
:
nsStyleUI
(
const
nsStyleUI
&
aSource
)
:
mUserInput
(
aSource
.
mUserInput
)
mUserModify
(
aSource
.
mUserModify
)
mUserFocus
(
aSource
.
mUserFocus
)
mPointerEvents
(
aSource
.
mPointerEvents
)
mCursor
(
aSource
.
mCursor
)
mCursorImages
(
aSource
.
mCursorImages
)
mCaretColor
(
aSource
.
mCaretColor
)
mScrollbarColor
(
aSource
.
mScrollbarColor
)
{
MOZ_COUNT_CTOR
(
nsStyleUI
)
;
}
nsStyleUI
:
:
~
nsStyleUI
(
)
{
MOZ_COUNT_DTOR
(
nsStyleUI
)
;
}
void
nsStyleUI
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleUI
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mCursorImages
.
Length
(
)
;
+
+
i
)
{
nsCursorImage
&
cursor
=
mCursorImages
[
i
]
;
if
(
cursor
.
mImage
&
&
!
cursor
.
mImage
-
>
IsResolved
(
)
)
{
const
nsCursorImage
*
oldCursor
=
(
aOldStyle
&
&
aOldStyle
-
>
mCursorImages
.
Length
(
)
>
i
)
?
&
aOldStyle
-
>
mCursorImages
[
i
]
:
nullptr
;
cursor
.
mImage
-
>
Resolve
(
aDocument
oldCursor
?
oldCursor
-
>
mImage
.
get
(
)
:
nullptr
)
;
}
}
}
nsChangeHint
nsStyleUI
:
:
CalcDifference
(
const
nsStyleUI
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mCursor
!
=
aNewData
.
mCursor
)
{
hint
|
=
nsChangeHint_UpdateCursor
;
}
if
(
mCursorImages
!
=
aNewData
.
mCursorImages
)
{
hint
|
=
nsChangeHint_UpdateCursor
;
}
if
(
mPointerEvents
!
=
aNewData
.
mPointerEvents
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
;
}
if
(
mUserModify
!
=
aNewData
.
mUserModify
)
{
hint
|
=
NS_STYLE_HINT_VISUAL
;
}
if
(
mUserInput
!
=
aNewData
.
mUserInput
)
{
if
(
StyleUserInput
:
:
None
=
=
mUserInput
|
|
StyleUserInput
:
:
None
=
=
aNewData
.
mUserInput
)
{
hint
|
=
nsChangeHint_ReconstructFrame
;
}
else
{
hint
|
=
nsChangeHint_NeutralChange
;
}
}
if
(
mUserFocus
!
=
aNewData
.
mUserFocus
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
if
(
mCaretColor
!
=
aNewData
.
mCaretColor
|
|
mScrollbarColor
!
=
aNewData
.
mScrollbarColor
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
return
hint
;
}
nsStyleUIReset
:
:
nsStyleUIReset
(
const
Document
&
aDocument
)
:
mUserSelect
(
StyleUserSelect
:
:
Auto
)
mScrollbarWidth
(
StyleScrollbarWidth
:
:
Auto
)
mForceBrokenImageIcon
(
0
)
mIMEMode
(
NS_STYLE_IME_MODE_AUTO
)
mWindowDragging
(
StyleWindowDragging
:
:
Default
)
mWindowShadow
(
NS_STYLE_WINDOW_SHADOW_DEFAULT
)
mWindowOpacity
(
1
.
0
)
mWindowTransformOrigin
{
LengthPercentage
:
:
FromPercentage
(
0
.
5
)
LengthPercentage
:
:
FromPercentage
(
0
.
5
)
{
0
.
}
}
{
MOZ_COUNT_CTOR
(
nsStyleUIReset
)
;
}
nsStyleUIReset
:
:
nsStyleUIReset
(
const
nsStyleUIReset
&
aSource
)
:
mUserSelect
(
aSource
.
mUserSelect
)
mScrollbarWidth
(
aSource
.
mScrollbarWidth
)
mForceBrokenImageIcon
(
aSource
.
mForceBrokenImageIcon
)
mIMEMode
(
aSource
.
mIMEMode
)
mWindowDragging
(
aSource
.
mWindowDragging
)
mWindowShadow
(
aSource
.
mWindowShadow
)
mWindowOpacity
(
aSource
.
mWindowOpacity
)
mMozWindowTransform
(
aSource
.
mMozWindowTransform
)
mWindowTransformOrigin
(
aSource
.
mWindowTransformOrigin
)
{
MOZ_COUNT_CTOR
(
nsStyleUIReset
)
;
}
nsStyleUIReset
:
:
~
nsStyleUIReset
(
)
{
MOZ_COUNT_DTOR
(
nsStyleUIReset
)
;
}
nsChangeHint
nsStyleUIReset
:
:
CalcDifference
(
const
nsStyleUIReset
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mForceBrokenImageIcon
!
=
aNewData
.
mForceBrokenImageIcon
)
{
hint
|
=
nsChangeHint_ReconstructFrame
;
}
if
(
mScrollbarWidth
!
=
aNewData
.
mScrollbarWidth
)
{
hint
|
=
nsChangeHint_ScrollbarChange
;
}
if
(
mWindowShadow
!
=
aNewData
.
mWindowShadow
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
if
(
mUserSelect
!
=
aNewData
.
mUserSelect
)
{
hint
|
=
NS_STYLE_HINT_VISUAL
;
}
if
(
mWindowDragging
!
=
aNewData
.
mWindowDragging
)
{
hint
|
=
nsChangeHint_SchedulePaint
;
}
if
(
mWindowOpacity
!
=
aNewData
.
mWindowOpacity
|
|
mMozWindowTransform
!
=
aNewData
.
mMozWindowTransform
)
{
hint
|
=
nsChangeHint_UpdateWidgetProperties
;
}
if
(
!
hint
&
&
mIMEMode
!
=
aNewData
.
mIMEMode
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
nsStyleEffects
:
:
nsStyleEffects
(
const
Document
&
)
:
mClip
(
StyleClipRectOrAuto
:
:
Auto
(
)
)
mOpacity
(
1
.
0f
)
mMixBlendMode
(
NS_STYLE_BLEND_NORMAL
)
{
MOZ_COUNT_CTOR
(
nsStyleEffects
)
;
}
nsStyleEffects
:
:
nsStyleEffects
(
const
nsStyleEffects
&
aSource
)
:
mFilters
(
aSource
.
mFilters
)
mBoxShadow
(
aSource
.
mBoxShadow
)
mBackdropFilters
(
aSource
.
mBackdropFilters
)
mClip
(
aSource
.
mClip
)
mOpacity
(
aSource
.
mOpacity
)
mMixBlendMode
(
aSource
.
mMixBlendMode
)
{
MOZ_COUNT_CTOR
(
nsStyleEffects
)
;
}
nsStyleEffects
:
:
~
nsStyleEffects
(
)
{
MOZ_COUNT_DTOR
(
nsStyleEffects
)
;
}
static
bool
AnyAutonessChanged
(
const
StyleClipRectOrAuto
&
aOld
const
StyleClipRectOrAuto
&
aNew
)
{
if
(
aOld
.
IsAuto
(
)
!
=
aNew
.
IsAuto
(
)
)
{
return
true
;
}
if
(
aOld
.
IsAuto
(
)
)
{
return
false
;
}
auto
&
oldRect
=
aOld
.
AsRect
(
)
;
auto
&
newRect
=
aNew
.
AsRect
(
)
;
return
oldRect
.
top
.
IsAuto
(
)
!
=
newRect
.
top
.
IsAuto
(
)
|
|
oldRect
.
right
.
IsAuto
(
)
!
=
newRect
.
right
.
IsAuto
(
)
|
|
oldRect
.
bottom
.
IsAuto
(
)
!
=
newRect
.
bottom
.
IsAuto
(
)
|
|
oldRect
.
left
.
IsAuto
(
)
!
=
newRect
.
left
.
IsAuto
(
)
;
}
nsChangeHint
nsStyleEffects
:
:
CalcDifference
(
const
nsStyleEffects
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mBoxShadow
!
=
aNewData
.
mBoxShadow
)
{
hint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_SchedulePaint
|
nsChangeHint_RepaintFrame
;
}
if
(
AnyAutonessChanged
(
mClip
aNewData
.
mClip
)
)
{
hint
|
=
nsChangeHint_AllReflowHints
|
nsChangeHint_RepaintFrame
;
}
else
if
(
mClip
!
=
aNewData
.
mClip
)
{
hint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_SchedulePaint
;
}
if
(
mOpacity
!
=
aNewData
.
mOpacity
)
{
if
(
(
mOpacity
>
=
0
.
99f
&
&
mOpacity
<
1
.
0f
&
&
aNewData
.
mOpacity
=
=
1
.
0f
)
|
|
(
aNewData
.
mOpacity
>
=
0
.
99f
&
&
aNewData
.
mOpacity
<
1
.
0f
&
&
mOpacity
=
=
1
.
0f
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
else
{
hint
|
=
nsChangeHint_UpdateOpacityLayer
;
if
(
(
mOpacity
=
=
1
.
0f
)
!
=
(
aNewData
.
mOpacity
=
=
1
.
0f
)
)
{
hint
|
=
nsChangeHint_UpdateUsesOpacity
;
}
}
}
if
(
HasFilters
(
)
!
=
aNewData
.
HasFilters
(
)
)
{
hint
|
=
nsChangeHint_UpdateContainingBlock
;
}
if
(
mFilters
!
=
aNewData
.
mFilters
)
{
hint
|
=
nsChangeHint_UpdateEffects
|
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateOverflow
;
}
if
(
mMixBlendMode
!
=
aNewData
.
mMixBlendMode
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
HasBackdropFilters
(
)
!
=
aNewData
.
HasBackdropFilters
(
)
)
{
hint
|
=
nsChangeHint_UpdateContainingBlock
;
}
if
(
mBackdropFilters
!
=
aNewData
.
mBackdropFilters
)
{
hint
|
=
nsChangeHint_UpdateEffects
|
nsChangeHint_RepaintFrame
;
}
return
hint
;
}
static
bool
TransformOperationHasPercent
(
const
StyleTransformOperation
&
aOp
)
{
switch
(
aOp
.
tag
)
{
case
StyleTransformOperation
:
:
Tag
:
:
TranslateX
:
return
aOp
.
AsTranslateX
(
)
.
HasPercent
(
)
;
case
StyleTransformOperation
:
:
Tag
:
:
TranslateY
:
return
aOp
.
AsTranslateY
(
)
.
HasPercent
(
)
;
case
StyleTransformOperation
:
:
Tag
:
:
TranslateZ
:
return
false
;
case
StyleTransformOperation
:
:
Tag
:
:
Translate3D
:
{
auto
&
translate
=
aOp
.
AsTranslate3D
(
)
;
return
translate
.
_0
.
HasPercent
(
)
|
|
translate
.
_1
.
HasPercent
(
)
;
}
case
StyleTransformOperation
:
:
Tag
:
:
Translate
:
{
auto
&
translate
=
aOp
.
AsTranslate
(
)
;
return
translate
.
_0
.
HasPercent
(
)
|
|
translate
.
_1
.
HasPercent
(
)
;
}
case
StyleTransformOperation
:
:
Tag
:
:
AccumulateMatrix
:
{
auto
&
accum
=
aOp
.
AsAccumulateMatrix
(
)
;
return
accum
.
from_list
.
HasPercent
(
)
|
|
accum
.
to_list
.
HasPercent
(
)
;
}
case
StyleTransformOperation
:
:
Tag
:
:
InterpolateMatrix
:
{
auto
&
interpolate
=
aOp
.
AsInterpolateMatrix
(
)
;
return
interpolate
.
from_list
.
HasPercent
(
)
|
|
interpolate
.
to_list
.
HasPercent
(
)
;
}
case
StyleTransformOperation
:
:
Tag
:
:
Perspective
:
case
StyleTransformOperation
:
:
Tag
:
:
RotateX
:
case
StyleTransformOperation
:
:
Tag
:
:
RotateY
:
case
StyleTransformOperation
:
:
Tag
:
:
RotateZ
:
case
StyleTransformOperation
:
:
Tag
:
:
Rotate
:
case
StyleTransformOperation
:
:
Tag
:
:
Rotate3D
:
case
StyleTransformOperation
:
:
Tag
:
:
SkewX
:
case
StyleTransformOperation
:
:
Tag
:
:
SkewY
:
case
StyleTransformOperation
:
:
Tag
:
:
Skew
:
case
StyleTransformOperation
:
:
Tag
:
:
ScaleX
:
case
StyleTransformOperation
:
:
Tag
:
:
ScaleY
:
case
StyleTransformOperation
:
:
Tag
:
:
ScaleZ
:
case
StyleTransformOperation
:
:
Tag
:
:
Scale
:
case
StyleTransformOperation
:
:
Tag
:
:
Scale3D
:
case
StyleTransformOperation
:
:
Tag
:
:
Matrix
:
case
StyleTransformOperation
:
:
Tag
:
:
Matrix3D
:
return
false
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
transform
operation
"
)
;
return
false
;
}
}
template
<
>
bool
StyleTransform
:
:
HasPercent
(
)
const
{
for
(
const
auto
&
op
:
Operations
(
)
)
{
if
(
TransformOperationHasPercent
(
op
)
)
{
return
true
;
}
}
return
false
;
}
