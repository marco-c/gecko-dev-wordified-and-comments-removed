#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
CounterStyleManager
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
BaseKeyframeTypesBinding
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
ImageTracker
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
GeckoBindings
.
h
"
#
include
"
mozilla
/
PreferenceSheet
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
StaticPresData
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
<
algorithm
>
#
include
"
ImageLoader
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
const
nscoord
kMediumBorderWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
3
)
;
static
constexpr
size_t
kStyleStructSizeLimit
=
504
;
template
<
typename
Struct
size_t
Actual
size_t
Limit
>
struct
AssertSizeIsLessThan
{
static_assert
(
Actual
=
=
sizeof
(
Struct
)
"
Bogus
invocation
"
)
;
static_assert
(
Actual
<
=
Limit
"
Style
struct
became
larger
than
the
size
limit
"
)
;
static
constexpr
bool
instantiate
=
true
;
}
;
#
define
STYLE_STRUCT
(
name_
)
\
static_assert
(
AssertSizeIsLessThan
<
nsStyle
#
#
name_
sizeof
(
nsStyle
#
#
name_
)
\
kStyleStructSizeLimit
>
:
:
instantiate
\
"
"
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
bool
StyleCssUrlData
:
:
operator
=
=
(
const
StyleCssUrlData
&
aOther
)
const
{
const
auto
&
extra
=
extra_data
.
get
(
)
;
const
auto
&
otherExtra
=
aOther
.
extra_data
.
get
(
)
;
if
(
extra
.
BaseURI
(
)
!
=
otherExtra
.
BaseURI
(
)
|
|
extra
.
Principal
(
)
!
=
otherExtra
.
Principal
(
)
|
|
cors_mode
!
=
aOther
.
cors_mode
)
{
return
false
;
}
return
serialization
=
=
aOther
.
serialization
;
}
StyleLoadData
:
:
~
StyleLoadData
(
)
{
Gecko_LoadData_Drop
(
this
)
;
}
already_AddRefed
<
nsIURI
>
StyleComputedUrl
:
:
ResolveLocalRef
(
nsIURI
*
aURI
)
const
{
nsCOMPtr
<
nsIURI
>
result
=
GetURI
(
)
;
if
(
result
&
&
IsLocalRef
(
)
)
{
nsCString
ref
;
result
-
>
GetRef
(
ref
)
;
nsresult
rv
=
NS_MutateURI
(
aURI
)
.
SetRef
(
ref
)
.
Finalize
(
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
result
=
aURI
;
}
}
return
result
.
forget
(
)
;
}
already_AddRefed
<
nsIURI
>
StyleComputedUrl
:
:
ResolveLocalRef
(
const
nsIContent
*
aContent
)
const
{
return
ResolveLocalRef
(
aContent
-
>
GetBaseURI
(
)
)
;
}
void
StyleComputedUrl
:
:
ResolveImage
(
Document
&
aDocument
const
StyleComputedUrl
*
aOldImage
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
StyleLoadData
&
data
=
LoadData
(
)
;
MOZ_ASSERT
(
!
(
data
.
flags
&
StyleLoadDataFlags
:
:
TRIED_TO_RESOLVE_IMAGE
)
)
;
data
.
flags
|
=
StyleLoadDataFlags
:
:
TRIED_TO_RESOLVE_IMAGE
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
bool
reuseProxy
=
nsContentUtils
:
:
IsChromeDoc
(
&
aDocument
)
&
&
aOldImage
&
&
aOldImage
-
>
IsImageResolved
(
)
&
&
*
this
=
=
*
aOldImage
;
RefPtr
<
imgRequestProxy
>
request
;
if
(
reuseProxy
)
{
request
=
aOldImage
-
>
LoadData
(
)
.
resolved_image
;
if
(
request
)
{
css
:
:
ImageLoader
:
:
NoteSharedLoad
(
request
)
;
}
}
else
{
request
=
css
:
:
ImageLoader
:
:
LoadImage
(
*
this
aDocument
)
;
}
if
(
!
request
)
{
return
;
}
data
.
resolved_image
=
request
.
forget
(
)
.
take
(
)
;
data
.
resolved_image
-
>
BoostPriority
(
imgIRequest
:
:
CATEGORY_FRAME_STYLE
)
;
}
class
StyleImageRequestCleanupTask
final
:
public
mozilla
:
:
Runnable
{
public
:
explicit
StyleImageRequestCleanupTask
(
StyleLoadData
&
aData
)
:
mozilla
:
:
Runnable
(
"
StyleImageRequestCleanupTask
"
)
mRequestProxy
(
dont_AddRef
(
aData
.
resolved_image
)
)
{
MOZ_ASSERT
(
mRequestProxy
)
;
aData
.
resolved_image
=
nullptr
;
}
NS_IMETHOD
Run
(
)
final
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
css
:
:
ImageLoader
:
:
UnloadImage
(
mRequestProxy
)
;
return
NS_OK
;
}
protected
:
virtual
~
StyleImageRequestCleanupTask
(
)
{
MOZ_ASSERT
(
!
mRequestProxy
|
|
NS_IsMainThread
(
)
"
mRequestProxy
destructor
need
to
run
on
the
main
thread
!
"
)
;
}
private
:
RefPtr
<
imgRequestProxy
>
mRequestProxy
;
}
;
void
Gecko_LoadData_Drop
(
StyleLoadData
*
aData
)
{
if
(
aData
-
>
resolved_image
)
{
auto
task
=
MakeRefPtr
<
StyleImageRequestCleanupTask
>
(
*
aData
)
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
NS_IF_RELEASE
(
aData
-
>
resolved_uri
)
;
}
nsStyleFont
:
:
nsStyleFont
(
const
nsStyleFont
&
aSrc
)
:
mFont
(
aSrc
.
mFont
)
mSize
(
aSrc
.
mSize
)
mFontSizeFactor
(
aSrc
.
mFontSizeFactor
)
mFontSizeOffset
(
aSrc
.
mFontSizeOffset
)
mFontSizeKeyword
(
aSrc
.
mFontSizeKeyword
)
mFontPalette
(
aSrc
.
mFontPalette
)
mMathDepth
(
aSrc
.
mMathDepth
)
mMathVariant
(
aSrc
.
mMathVariant
)
mMathStyle
(
aSrc
.
mMathStyle
)
mMinFontSizeRatio
(
aSrc
.
mMinFontSizeRatio
)
mExplicitLanguage
(
aSrc
.
mExplicitLanguage
)
mAllowZoomAndMinSize
(
aSrc
.
mAllowZoomAndMinSize
)
mScriptUnconstrainedSize
(
aSrc
.
mScriptUnconstrainedSize
)
mScriptMinSize
(
aSrc
.
mScriptMinSize
)
mScriptSizeMultiplier
(
aSrc
.
mScriptSizeMultiplier
)
mLanguage
(
aSrc
.
mLanguage
)
{
MOZ_COUNT_CTOR
(
nsStyleFont
)
;
}
nsStyleFont
:
:
nsStyleFont
(
const
Document
&
aDocument
)
:
mFont
(
*
aDocument
.
GetFontPrefsForLang
(
nullptr
)
-
>
GetDefaultFont
(
StyleGenericFontFamily
:
:
None
)
)
mSize
(
ZoomText
(
aDocument
mFont
.
size
)
)
mFontSizeFactor
(
1
.
0
)
mFontSizeOffset
{
0
}
mFontSizeKeyword
(
StyleFontSizeKeyword
:
:
Medium
)
mFontPalette
(
StyleFontPalette
:
:
Normal
(
)
)
mMathDepth
(
0
)
mMathVariant
(
StyleMathVariant
:
:
None
)
mMathStyle
(
StyleMathStyle
:
:
Normal
)
mMinFontSizeRatio
(
100
)
mExplicitLanguage
(
false
)
mAllowZoomAndMinSize
(
true
)
mScriptUnconstrainedSize
(
mSize
)
mScriptMinSize
(
Length
:
:
FromPixels
(
CSSPixel
:
:
FromPoints
(
kMathMLDefaultScriptMinSizePt
)
)
)
mScriptSizeMultiplier
(
kMathMLDefaultScriptSizeMultiplier
)
mLanguage
(
aDocument
.
GetLanguageForStyle
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleFont
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mFont
.
family
.
is_initial
=
true
;
mFont
.
size
=
mSize
;
if
(
!
nsContentUtils
:
:
IsChromeDoc
(
&
aDocument
)
)
{
Length
minimumFontSize
=
aDocument
.
GetFontPrefsForLang
(
mLanguage
)
-
>
mMinimumFontSize
;
mFont
.
size
=
Length
:
:
FromPixels
(
std
:
:
max
(
mSize
.
ToCSSPixels
(
)
minimumFontSize
.
ToCSSPixels
(
)
)
)
;
}
}
nsChangeHint
nsStyleFont
:
:
CalcDifference
(
const
nsStyleFont
&
aNewData
)
const
{
MOZ_ASSERT
(
mAllowZoomAndMinSize
=
=
aNewData
.
mAllowZoomAndMinSize
"
expected
mAllowZoomAndMinSize
to
be
the
same
on
both
nsStyleFonts
"
)
;
if
(
mSize
!
=
aNewData
.
mSize
|
|
mLanguage
!
=
aNewData
.
mLanguage
|
|
mExplicitLanguage
!
=
aNewData
.
mExplicitLanguage
|
|
mMathVariant
!
=
aNewData
.
mMathVariant
|
|
mMathStyle
!
=
aNewData
.
mMathStyle
|
|
mMinFontSizeRatio
!
=
aNewData
.
mMinFontSizeRatio
)
{
return
NS_STYLE_HINT_REFLOW
;
}
switch
(
mFont
.
CalcDifference
(
aNewData
.
mFont
)
)
{
case
nsFont
:
:
MaxDifference
:
:
eLayoutAffecting
:
return
NS_STYLE_HINT_REFLOW
;
case
nsFont
:
:
MaxDifference
:
:
eVisual
:
return
NS_STYLE_HINT_VISUAL
;
case
nsFont
:
:
MaxDifference
:
:
eNone
:
break
;
}
if
(
mFontPalette
!
=
aNewData
.
mFontPalette
)
{
return
NS_STYLE_HINT_VISUAL
;
}
if
(
mMathDepth
!
=
aNewData
.
mMathDepth
|
|
mScriptUnconstrainedSize
!
=
aNewData
.
mScriptUnconstrainedSize
|
|
mScriptMinSize
!
=
aNewData
.
mScriptMinSize
|
|
mScriptSizeMultiplier
!
=
aNewData
.
mScriptSizeMultiplier
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
Length
nsStyleFont
:
:
ZoomText
(
const
Document
&
aDocument
Length
aSize
)
{
if
(
auto
*
pc
=
aDocument
.
GetPresContext
(
)
)
{
aSize
.
ScaleBy
(
pc
-
>
EffectiveTextZoom
(
)
)
;
}
return
aSize
;
}
template
<
typename
T
>
static
StyleRect
<
T
>
StyleRectWithAllSides
(
const
T
&
aSide
)
{
return
{
aSide
aSide
aSide
aSide
}
;
}
nsStyleMargin
:
:
nsStyleMargin
(
const
Document
&
aDocument
)
:
mMargin
(
StyleRectWithAllSides
(
LengthPercentageOrAuto
:
:
LengthPercentage
(
LengthPercentage
:
:
Zero
(
)
)
)
)
mScrollMargin
(
StyleRectWithAllSides
(
StyleLength
{
0
.
}
)
)
mOverflowClipMargin
(
StyleLength
:
:
Zero
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleMargin
)
;
}
nsStyleMargin
:
:
nsStyleMargin
(
const
nsStyleMargin
&
aSrc
)
:
mMargin
(
aSrc
.
mMargin
)
mScrollMargin
(
aSrc
.
mScrollMargin
)
mOverflowClipMargin
(
aSrc
.
mOverflowClipMargin
)
{
MOZ_COUNT_CTOR
(
nsStyleMargin
)
;
}
nsChangeHint
nsStyleMargin
:
:
CalcDifference
(
const
nsStyleMargin
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mMargin
!
=
aNewData
.
mMargin
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_ReflowChangesSizeOrPosition
|
nsChangeHint_ClearAncestorIntrinsics
;
}
if
(
mScrollMargin
!
=
aNewData
.
mScrollMargin
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
if
(
mOverflowClipMargin
!
=
aNewData
.
mOverflowClipMargin
)
{
hint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_RepaintFrame
;
}
return
hint
;
}
nsStylePadding
:
:
nsStylePadding
(
const
Document
&
aDocument
)
:
mPadding
(
StyleRectWithAllSides
(
LengthPercentage
:
:
Zero
(
)
)
)
mScrollPadding
(
StyleRectWithAllSides
(
LengthPercentageOrAuto
:
:
Auto
(
)
)
)
{
MOZ_COUNT_CTOR
(
nsStylePadding
)
;
}
nsStylePadding
:
:
nsStylePadding
(
const
nsStylePadding
&
aSrc
)
:
mPadding
(
aSrc
.
mPadding
)
mScrollPadding
(
aSrc
.
mScrollPadding
)
{
MOZ_COUNT_CTOR
(
nsStylePadding
)
;
}
nsChangeHint
nsStylePadding
:
:
CalcDifference
(
const
nsStylePadding
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mPadding
!
=
aNewData
.
mPadding
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
&
~
nsChangeHint_ClearDescendantIntrinsics
;
}
if
(
mScrollPadding
!
=
aNewData
.
mScrollPadding
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
static
nscoord
TwipsPerPixel
(
const
Document
&
aDocument
)
{
auto
*
pc
=
aDocument
.
GetPresContext
(
)
;
return
pc
?
pc
-
>
AppUnitsPerDevPixel
(
)
:
mozilla
:
:
AppUnitsPerCSSPixel
(
)
;
}
static
inline
BorderRadius
ZeroBorderRadius
(
)
{
auto
zero
=
LengthPercentage
:
:
Zero
(
)
;
return
{
{
{
zero
zero
}
}
{
{
zero
zero
}
}
{
{
zero
zero
}
}
{
{
zero
zero
}
}
}
;
}
nsStyleBorder
:
:
nsStyleBorder
(
const
Document
&
aDocument
)
:
mBorderRadius
(
ZeroBorderRadius
(
)
)
mBorderImageSource
(
StyleImage
:
:
None
(
)
)
mBorderImageWidth
(
StyleRectWithAllSides
(
StyleBorderImageSideWidth
:
:
Number
(
1
.
)
)
)
mBorderImageOutset
(
StyleRectWithAllSides
(
StyleNonNegativeLengthOrNumber
:
:
Number
(
0
.
)
)
)
mBorderImageSlice
(
{
StyleRectWithAllSides
(
StyleNumberOrPercentage
:
:
Percentage
(
{
1
.
}
)
)
false
}
)
mBorderImageRepeatH
(
StyleBorderImageRepeat
:
:
Stretch
)
mBorderImageRepeatV
(
StyleBorderImageRepeat
:
:
Stretch
)
mFloatEdge
(
StyleFloatEdge
:
:
ContentBox
)
mBoxDecorationBreak
(
StyleBoxDecorationBreak
:
:
Slice
)
mBorderTopColor
(
StyleColor
:
:
CurrentColor
(
)
)
mBorderRightColor
(
StyleColor
:
:
CurrentColor
(
)
)
mBorderBottomColor
(
StyleColor
:
:
CurrentColor
(
)
)
mBorderLeftColor
(
StyleColor
:
:
CurrentColor
(
)
)
mComputedBorder
(
0
0
0
0
)
mTwipsPerPixel
(
TwipsPerPixel
(
aDocument
)
)
{
MOZ_COUNT_CTOR
(
nsStyleBorder
)
;
nscoord
medium
=
kMediumBorderWidth
;
for
(
const
auto
side
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
mBorder
.
Side
(
side
)
=
medium
;
mBorderStyle
[
side
]
=
StyleBorderStyle
:
:
None
;
}
}
nsStyleBorder
:
:
nsStyleBorder
(
const
nsStyleBorder
&
aSrc
)
:
mBorderRadius
(
aSrc
.
mBorderRadius
)
mBorderImageSource
(
aSrc
.
mBorderImageSource
)
mBorderImageWidth
(
aSrc
.
mBorderImageWidth
)
mBorderImageOutset
(
aSrc
.
mBorderImageOutset
)
mBorderImageSlice
(
aSrc
.
mBorderImageSlice
)
mBorderImageRepeatH
(
aSrc
.
mBorderImageRepeatH
)
mBorderImageRepeatV
(
aSrc
.
mBorderImageRepeatV
)
mFloatEdge
(
aSrc
.
mFloatEdge
)
mBoxDecorationBreak
(
aSrc
.
mBoxDecorationBreak
)
mBorderTopColor
(
aSrc
.
mBorderTopColor
)
mBorderRightColor
(
aSrc
.
mBorderRightColor
)
mBorderBottomColor
(
aSrc
.
mBorderBottomColor
)
mBorderLeftColor
(
aSrc
.
mBorderLeftColor
)
mComputedBorder
(
aSrc
.
mComputedBorder
)
mBorder
(
aSrc
.
mBorder
)
mTwipsPerPixel
(
aSrc
.
mTwipsPerPixel
)
{
MOZ_COUNT_CTOR
(
nsStyleBorder
)
;
for
(
const
auto
side
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
mBorderStyle
[
side
]
=
aSrc
.
mBorderStyle
[
side
]
;
}
}
nsStyleBorder
:
:
~
nsStyleBorder
(
)
{
MOZ_COUNT_DTOR
(
nsStyleBorder
)
;
}
void
nsStyleBorder
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleBorder
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mBorderImageSource
.
ResolveImage
(
aDocument
aOldStyle
?
&
aOldStyle
-
>
mBorderImageSource
:
nullptr
)
;
}
nsMargin
nsStyleBorder
:
:
GetImageOutset
(
)
const
{
nsMargin
outset
;
for
(
const
auto
s
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
const
auto
&
coord
=
mBorderImageOutset
.
Get
(
s
)
;
nscoord
value
;
if
(
coord
.
IsLength
(
)
)
{
value
=
coord
.
AsLength
(
)
.
ToAppUnits
(
)
;
}
else
{
MOZ_ASSERT
(
coord
.
IsNumber
(
)
)
;
value
=
coord
.
AsNumber
(
)
*
mComputedBorder
.
Side
(
s
)
;
}
outset
.
Side
(
s
)
=
value
;
}
return
outset
;
}
nsChangeHint
nsStyleBorder
:
:
CalcDifference
(
const
nsStyleBorder
&
aNewData
)
const
{
if
(
mTwipsPerPixel
!
=
aNewData
.
mTwipsPerPixel
|
|
GetComputedBorder
(
)
!
=
aNewData
.
GetComputedBorder
(
)
|
|
mFloatEdge
!
=
aNewData
.
mFloatEdge
|
|
mBorderImageOutset
!
=
aNewData
.
mBorderImageOutset
|
|
mBoxDecorationBreak
!
=
aNewData
.
mBoxDecorationBreak
)
{
return
NS_STYLE_HINT_REFLOW
;
}
for
(
const
auto
ix
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
if
(
HasVisibleStyle
(
ix
)
!
=
aNewData
.
HasVisibleStyle
(
ix
)
)
{
return
nsChangeHint_RepaintFrame
|
nsChangeHint_BorderStyleNoneChange
;
}
}
for
(
const
auto
ix
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
if
(
mBorderStyle
[
ix
]
!
=
aNewData
.
mBorderStyle
[
ix
]
|
|
BorderColorFor
(
ix
)
!
=
aNewData
.
BorderColorFor
(
ix
)
)
{
return
nsChangeHint_RepaintFrame
;
}
}
if
(
mBorderRadius
!
=
aNewData
.
mBorderRadius
)
{
return
nsChangeHint_RepaintFrame
;
}
if
(
!
mBorderImageSource
.
IsNone
(
)
|
|
!
aNewData
.
mBorderImageSource
.
IsNone
(
)
)
{
if
(
mBorderImageSource
!
=
aNewData
.
mBorderImageSource
|
|
mBorderImageRepeatH
!
=
aNewData
.
mBorderImageRepeatH
|
|
mBorderImageRepeatV
!
=
aNewData
.
mBorderImageRepeatV
|
|
mBorderImageSlice
!
=
aNewData
.
mBorderImageSlice
|
|
mBorderImageWidth
!
=
aNewData
.
mBorderImageWidth
)
{
return
nsChangeHint_RepaintFrame
;
}
}
if
(
mBorder
!
=
aNewData
.
mBorder
)
{
return
nsChangeHint_NeutralChange
;
}
if
(
mBorderImageSource
!
=
aNewData
.
mBorderImageSource
|
|
mBorderImageRepeatH
!
=
aNewData
.
mBorderImageRepeatH
|
|
mBorderImageRepeatV
!
=
aNewData
.
mBorderImageRepeatV
|
|
mBorderImageSlice
!
=
aNewData
.
mBorderImageSlice
|
|
mBorderImageWidth
!
=
aNewData
.
mBorderImageWidth
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
nsStyleOutline
:
:
nsStyleOutline
(
const
Document
&
aDocument
)
:
mOutlineWidth
(
kMediumBorderWidth
)
mOutlineOffset
(
{
0
.
0f
}
)
mOutlineColor
(
StyleColor
:
:
CurrentColor
(
)
)
mOutlineStyle
(
StyleOutlineStyle
:
:
BorderStyle
(
StyleBorderStyle
:
:
None
)
)
mActualOutlineWidth
(
0
)
mTwipsPerPixel
(
TwipsPerPixel
(
aDocument
)
)
{
MOZ_COUNT_CTOR
(
nsStyleOutline
)
;
}
nsStyleOutline
:
:
nsStyleOutline
(
const
nsStyleOutline
&
aSrc
)
:
mOutlineWidth
(
aSrc
.
mOutlineWidth
)
mOutlineOffset
(
aSrc
.
mOutlineOffset
)
mOutlineColor
(
aSrc
.
mOutlineColor
)
mOutlineStyle
(
aSrc
.
mOutlineStyle
)
mActualOutlineWidth
(
aSrc
.
mActualOutlineWidth
)
mTwipsPerPixel
(
aSrc
.
mTwipsPerPixel
)
{
MOZ_COUNT_CTOR
(
nsStyleOutline
)
;
}
nsChangeHint
nsStyleOutline
:
:
CalcDifference
(
const
nsStyleOutline
&
aNewData
)
const
{
const
bool
shouldPaintOutline
=
ShouldPaintOutline
(
)
;
if
(
shouldPaintOutline
!
=
aNewData
.
ShouldPaintOutline
(
)
|
|
mActualOutlineWidth
!
=
aNewData
.
mActualOutlineWidth
|
|
mOutlineStyle
.
IsAuto
(
)
!
=
aNewData
.
mOutlineStyle
.
IsAuto
(
)
|
|
(
shouldPaintOutline
&
&
mOutlineOffset
!
=
aNewData
.
mOutlineOffset
)
)
{
return
nsChangeHint_UpdateOverflow
|
nsChangeHint_SchedulePaint
|
nsChangeHint_RepaintFrame
;
}
if
(
mOutlineStyle
!
=
aNewData
.
mOutlineStyle
|
|
mOutlineColor
!
=
aNewData
.
mOutlineColor
)
{
return
shouldPaintOutline
?
nsChangeHint_RepaintFrame
:
nsChangeHint_NeutralChange
;
}
if
(
mOutlineWidth
!
=
aNewData
.
mOutlineWidth
|
|
mOutlineOffset
!
=
aNewData
.
mOutlineOffset
|
|
mTwipsPerPixel
!
=
aNewData
.
mTwipsPerPixel
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
nsStyleList
:
:
nsStyleList
(
const
Document
&
aDocument
)
:
mListStylePosition
(
StyleListStylePosition
:
:
Outside
)
mQuotes
(
StyleQuotes
:
:
Auto
(
)
)
mListStyleImage
(
StyleImage
:
:
None
(
)
)
mImageRegion
(
StyleClipRectOrAuto
:
:
Auto
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleList
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCounterStyle
=
nsGkAtoms
:
:
disc
;
}
nsStyleList
:
:
~
nsStyleList
(
)
{
MOZ_COUNT_DTOR
(
nsStyleList
)
;
}
nsStyleList
:
:
nsStyleList
(
const
nsStyleList
&
aSource
)
:
mListStylePosition
(
aSource
.
mListStylePosition
)
mCounterStyle
(
aSource
.
mCounterStyle
)
mQuotes
(
aSource
.
mQuotes
)
mListStyleImage
(
aSource
.
mListStyleImage
)
mImageRegion
(
aSource
.
mImageRegion
)
{
MOZ_COUNT_CTOR
(
nsStyleList
)
;
}
void
nsStyleList
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleList
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mListStyleImage
.
ResolveImage
(
aDocument
aOldStyle
?
&
aOldStyle
-
>
mListStyleImage
:
nullptr
)
;
}
nsChangeHint
nsStyleList
:
:
CalcDifference
(
const
nsStyleList
&
aNewData
const
nsStyleDisplay
&
aOldDisplay
)
const
{
if
(
mQuotes
!
=
aNewData
.
mQuotes
)
{
return
nsChangeHint_ReconstructFrame
;
}
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
aOldDisplay
.
IsListItem
(
)
)
{
if
(
mListStylePosition
!
=
aNewData
.
mListStylePosition
|
|
mCounterStyle
!
=
aNewData
.
mCounterStyle
|
|
mListStyleImage
!
=
aNewData
.
mListStyleImage
)
{
return
nsChangeHint_ReconstructFrame
;
}
}
else
if
(
mListStylePosition
!
=
aNewData
.
mListStylePosition
|
|
mCounterStyle
!
=
aNewData
.
mCounterStyle
)
{
hint
=
nsChangeHint_NeutralChange
;
}
if
(
mListStyleImage
!
=
aNewData
.
mListStyleImage
)
{
return
NS_STYLE_HINT_REFLOW
;
}
if
(
mImageRegion
!
=
aNewData
.
mImageRegion
)
{
nsRect
region
=
GetImageRegion
(
)
;
nsRect
newRegion
=
aNewData
.
GetImageRegion
(
)
;
if
(
region
.
width
!
=
newRegion
.
width
|
|
region
.
height
!
=
newRegion
.
height
)
{
return
NS_STYLE_HINT_REFLOW
;
}
return
NS_STYLE_HINT_VISUAL
;
}
return
hint
;
}
already_AddRefed
<
nsIURI
>
nsStyleList
:
:
GetListStyleImageURI
(
)
const
{
if
(
!
mListStyleImage
.
IsUrl
(
)
)
{
return
nullptr
;
}
return
do_AddRef
(
mListStyleImage
.
AsUrl
(
)
.
GetURI
(
)
)
;
}
nsStyleXUL
:
:
nsStyleXUL
(
const
Document
&
aDocument
)
:
mBoxFlex
(
0
.
0f
)
mBoxOrdinal
(
1
)
mBoxAlign
(
StyleBoxAlign
:
:
Stretch
)
mBoxDirection
(
StyleBoxDirection
:
:
Normal
)
mBoxOrient
(
StyleBoxOrient
:
:
Horizontal
)
mBoxPack
(
StyleBoxPack
:
:
Start
)
{
MOZ_COUNT_CTOR
(
nsStyleXUL
)
;
}
nsStyleXUL
:
:
~
nsStyleXUL
(
)
{
MOZ_COUNT_DTOR
(
nsStyleXUL
)
;
}
nsStyleXUL
:
:
nsStyleXUL
(
const
nsStyleXUL
&
aSource
)
:
mBoxFlex
(
aSource
.
mBoxFlex
)
mBoxOrdinal
(
aSource
.
mBoxOrdinal
)
mBoxAlign
(
aSource
.
mBoxAlign
)
mBoxDirection
(
aSource
.
mBoxDirection
)
mBoxOrient
(
aSource
.
mBoxOrient
)
mBoxPack
(
aSource
.
mBoxPack
)
{
MOZ_COUNT_CTOR
(
nsStyleXUL
)
;
}
nsChangeHint
nsStyleXUL
:
:
CalcDifference
(
const
nsStyleXUL
&
aNewData
)
const
{
if
(
mBoxAlign
=
=
aNewData
.
mBoxAlign
&
&
mBoxDirection
=
=
aNewData
.
mBoxDirection
&
&
mBoxFlex
=
=
aNewData
.
mBoxFlex
&
&
mBoxOrient
=
=
aNewData
.
mBoxOrient
&
&
mBoxPack
=
=
aNewData
.
mBoxPack
&
&
mBoxOrdinal
=
=
aNewData
.
mBoxOrdinal
)
{
return
nsChangeHint
(
0
)
;
}
if
(
mBoxOrdinal
!
=
aNewData
.
mBoxOrdinal
)
{
return
nsChangeHint_ReconstructFrame
;
}
return
NS_STYLE_HINT_REFLOW
;
}
const
uint32_t
nsStyleColumn
:
:
kMaxColumnCount
;
const
uint32_t
nsStyleColumn
:
:
kColumnCountAuto
;
nsStyleColumn
:
:
nsStyleColumn
(
const
Document
&
aDocument
)
:
mColumnWidth
(
LengthOrAuto
:
:
Auto
(
)
)
mColumnRuleColor
(
StyleColor
:
:
CurrentColor
(
)
)
mColumnRuleStyle
(
StyleBorderStyle
:
:
None
)
mColumnRuleWidth
(
kMediumBorderWidth
)
mActualColumnRuleWidth
(
0
)
mTwipsPerPixel
(
TwipsPerPixel
(
aDocument
)
)
{
MOZ_COUNT_CTOR
(
nsStyleColumn
)
;
}
nsStyleColumn
:
:
~
nsStyleColumn
(
)
{
MOZ_COUNT_DTOR
(
nsStyleColumn
)
;
}
nsStyleColumn
:
:
nsStyleColumn
(
const
nsStyleColumn
&
aSource
)
:
mColumnCount
(
aSource
.
mColumnCount
)
mColumnWidth
(
aSource
.
mColumnWidth
)
mColumnRuleColor
(
aSource
.
mColumnRuleColor
)
mColumnRuleStyle
(
aSource
.
mColumnRuleStyle
)
mColumnFill
(
aSource
.
mColumnFill
)
mColumnSpan
(
aSource
.
mColumnSpan
)
mColumnRuleWidth
(
aSource
.
mColumnRuleWidth
)
mActualColumnRuleWidth
(
aSource
.
mActualColumnRuleWidth
)
mTwipsPerPixel
(
aSource
.
mTwipsPerPixel
)
{
MOZ_COUNT_CTOR
(
nsStyleColumn
)
;
}
nsChangeHint
nsStyleColumn
:
:
CalcDifference
(
const
nsStyleColumn
&
aNewData
)
const
{
if
(
mColumnWidth
.
IsAuto
(
)
!
=
aNewData
.
mColumnWidth
.
IsAuto
(
)
|
|
mColumnCount
!
=
aNewData
.
mColumnCount
|
|
mColumnSpan
!
=
aNewData
.
mColumnSpan
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
mColumnWidth
!
=
aNewData
.
mColumnWidth
|
|
mColumnFill
!
=
aNewData
.
mColumnFill
)
{
return
NS_STYLE_HINT_REFLOW
;
}
if
(
mActualColumnRuleWidth
!
=
aNewData
.
mActualColumnRuleWidth
|
|
mColumnRuleStyle
!
=
aNewData
.
mColumnRuleStyle
|
|
mColumnRuleColor
!
=
aNewData
.
mColumnRuleColor
)
{
return
NS_STYLE_HINT_VISUAL
;
}
if
(
mColumnRuleWidth
!
=
aNewData
.
mColumnRuleWidth
|
|
mTwipsPerPixel
!
=
aNewData
.
mTwipsPerPixel
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
using
SVGPaintFallback
=
StyleGenericSVGPaintFallback
<
StyleColor
>
;
nsStyleSVG
:
:
nsStyleSVG
(
const
Document
&
aDocument
)
:
mFill
{
StyleSVGPaintKind
:
:
Color
(
StyleColor
:
:
Black
(
)
)
SVGPaintFallback
:
:
Unset
(
)
}
mStroke
{
StyleSVGPaintKind
:
:
None
(
)
SVGPaintFallback
:
:
Unset
(
)
}
mMarkerEnd
(
StyleUrlOrNone
:
:
None
(
)
)
mMarkerMid
(
StyleUrlOrNone
:
:
None
(
)
)
mMarkerStart
(
StyleUrlOrNone
:
:
None
(
)
)
mMozContextProperties
{
{
}
{
0
}
}
mStrokeDasharray
(
StyleSVGStrokeDashArray
:
:
Values
(
{
}
)
)
mStrokeDashoffset
(
StyleSVGLength
:
:
LengthPercentage
(
LengthPercentage
:
:
Zero
(
)
)
)
mStrokeWidth
(
StyleSVGWidth
:
:
LengthPercentage
(
LengthPercentage
:
:
FromPixels
(
1
.
0f
)
)
)
mFillOpacity
(
StyleSVGOpacity
:
:
Opacity
(
1
.
0f
)
)
mStrokeMiterlimit
(
4
.
0f
)
mStrokeOpacity
(
StyleSVGOpacity
:
:
Opacity
(
1
.
0f
)
)
mClipRule
(
StyleFillRule
:
:
Nonzero
)
mColorInterpolation
(
StyleColorInterpolation
:
:
Srgb
)
mColorInterpolationFilters
(
StyleColorInterpolation
:
:
Linearrgb
)
mFillRule
(
StyleFillRule
:
:
Nonzero
)
mPaintOrder
(
0
)
mShapeRendering
(
StyleShapeRendering
:
:
Auto
)
mStrokeLinecap
(
StyleStrokeLinecap
:
:
Butt
)
mStrokeLinejoin
(
StyleStrokeLinejoin
:
:
Miter
)
mDominantBaseline
(
StyleDominantBaseline
:
:
Auto
)
mTextAnchor
(
StyleTextAnchor
:
:
Start
)
{
MOZ_COUNT_CTOR
(
nsStyleSVG
)
;
}
nsStyleSVG
:
:
~
nsStyleSVG
(
)
{
MOZ_COUNT_DTOR
(
nsStyleSVG
)
;
}
nsStyleSVG
:
:
nsStyleSVG
(
const
nsStyleSVG
&
aSource
)
:
mFill
(
aSource
.
mFill
)
mStroke
(
aSource
.
mStroke
)
mMarkerEnd
(
aSource
.
mMarkerEnd
)
mMarkerMid
(
aSource
.
mMarkerMid
)
mMarkerStart
(
aSource
.
mMarkerStart
)
mMozContextProperties
(
aSource
.
mMozContextProperties
)
mStrokeDasharray
(
aSource
.
mStrokeDasharray
)
mStrokeDashoffset
(
aSource
.
mStrokeDashoffset
)
mStrokeWidth
(
aSource
.
mStrokeWidth
)
mFillOpacity
(
aSource
.
mFillOpacity
)
mStrokeMiterlimit
(
aSource
.
mStrokeMiterlimit
)
mStrokeOpacity
(
aSource
.
mStrokeOpacity
)
mClipRule
(
aSource
.
mClipRule
)
mColorInterpolation
(
aSource
.
mColorInterpolation
)
mColorInterpolationFilters
(
aSource
.
mColorInterpolationFilters
)
mFillRule
(
aSource
.
mFillRule
)
mPaintOrder
(
aSource
.
mPaintOrder
)
mShapeRendering
(
aSource
.
mShapeRendering
)
mStrokeLinecap
(
aSource
.
mStrokeLinecap
)
mStrokeLinejoin
(
aSource
.
mStrokeLinejoin
)
mDominantBaseline
(
aSource
.
mDominantBaseline
)
mTextAnchor
(
aSource
.
mTextAnchor
)
{
MOZ_COUNT_CTOR
(
nsStyleSVG
)
;
}
static
bool
PaintURIChanged
(
const
StyleSVGPaint
&
aPaint1
const
StyleSVGPaint
&
aPaint2
)
{
if
(
aPaint1
.
kind
.
IsPaintServer
(
)
!
=
aPaint2
.
kind
.
IsPaintServer
(
)
)
{
return
true
;
}
return
aPaint1
.
kind
.
IsPaintServer
(
)
&
&
aPaint1
.
kind
.
AsPaintServer
(
)
!
=
aPaint2
.
kind
.
AsPaintServer
(
)
;
}
nsChangeHint
nsStyleSVG
:
:
CalcDifference
(
const
nsStyleSVG
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mMarkerEnd
!
=
aNewData
.
mMarkerEnd
|
|
mMarkerMid
!
=
aNewData
.
mMarkerMid
|
|
mMarkerStart
!
=
aNewData
.
mMarkerStart
)
{
return
nsChangeHint_UpdateEffects
|
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
|
nsChangeHint_RepaintFrame
;
}
if
(
mFill
!
=
aNewData
.
mFill
|
|
mStroke
!
=
aNewData
.
mStroke
|
|
mFillOpacity
!
=
aNewData
.
mFillOpacity
|
|
mStrokeOpacity
!
=
aNewData
.
mStrokeOpacity
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
if
(
HasStroke
(
)
!
=
aNewData
.
HasStroke
(
)
|
|
(
!
HasStroke
(
)
&
&
HasFill
(
)
!
=
aNewData
.
HasFill
(
)
)
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
;
}
if
(
PaintURIChanged
(
mFill
aNewData
.
mFill
)
|
|
PaintURIChanged
(
mStroke
aNewData
.
mStroke
)
)
{
hint
|
=
nsChangeHint_UpdateEffects
;
}
}
if
(
mStrokeWidth
!
=
aNewData
.
mStrokeWidth
|
|
mStrokeMiterlimit
!
=
aNewData
.
mStrokeMiterlimit
|
|
mStrokeLinecap
!
=
aNewData
.
mStrokeLinecap
|
|
mStrokeLinejoin
!
=
aNewData
.
mStrokeLinejoin
|
|
mDominantBaseline
!
=
aNewData
.
mDominantBaseline
|
|
mTextAnchor
!
=
aNewData
.
mTextAnchor
)
{
return
hint
|
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
|
nsChangeHint_RepaintFrame
;
}
if
(
hint
&
nsChangeHint_RepaintFrame
)
{
return
hint
;
}
if
(
mStrokeDashoffset
!
=
aNewData
.
mStrokeDashoffset
|
|
mClipRule
!
=
aNewData
.
mClipRule
|
|
mColorInterpolation
!
=
aNewData
.
mColorInterpolation
|
|
mColorInterpolationFilters
!
=
aNewData
.
mColorInterpolationFilters
|
|
mFillRule
!
=
aNewData
.
mFillRule
|
|
mPaintOrder
!
=
aNewData
.
mPaintOrder
|
|
mShapeRendering
!
=
aNewData
.
mShapeRendering
|
|
mStrokeDasharray
!
=
aNewData
.
mStrokeDasharray
|
|
mMozContextProperties
.
bits
!
=
aNewData
.
mMozContextProperties
.
bits
)
{
return
hint
|
nsChangeHint_RepaintFrame
;
}
if
(
!
hint
)
{
if
(
mMozContextProperties
.
idents
!
=
aNewData
.
mMozContextProperties
.
idents
)
{
hint
=
nsChangeHint_NeutralChange
;
}
}
return
hint
;
}
nsStyleSVGReset
:
:
nsStyleSVGReset
(
const
Document
&
aDocument
)
:
mX
(
LengthPercentage
:
:
Zero
(
)
)
mY
(
LengthPercentage
:
:
Zero
(
)
)
mCx
(
LengthPercentage
:
:
Zero
(
)
)
mCy
(
LengthPercentage
:
:
Zero
(
)
)
mRx
(
NonNegativeLengthPercentageOrAuto
:
:
Auto
(
)
)
mRy
(
NonNegativeLengthPercentageOrAuto
:
:
Auto
(
)
)
mR
(
NonNegativeLengthPercentage
:
:
Zero
(
)
)
mMask
(
nsStyleImageLayers
:
:
LayerType
:
:
Mask
)
mClipPath
(
StyleClipPath
:
:
None
(
)
)
mStopColor
(
StyleColor
:
:
Black
(
)
)
mFloodColor
(
StyleColor
:
:
Black
(
)
)
mLightingColor
(
StyleColor
:
:
White
(
)
)
mStopOpacity
(
1
.
0f
)
mFloodOpacity
(
1
.
0f
)
mVectorEffect
(
StyleVectorEffect
:
:
None
)
mMaskType
(
StyleMaskType
:
:
Luminance
)
mD
(
StyleDProperty
:
:
None
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleSVGReset
)
;
}
nsStyleSVGReset
:
:
~
nsStyleSVGReset
(
)
{
MOZ_COUNT_DTOR
(
nsStyleSVGReset
)
;
}
nsStyleSVGReset
:
:
nsStyleSVGReset
(
const
nsStyleSVGReset
&
aSource
)
:
mX
(
aSource
.
mX
)
mY
(
aSource
.
mY
)
mCx
(
aSource
.
mCx
)
mCy
(
aSource
.
mCy
)
mRx
(
aSource
.
mRx
)
mRy
(
aSource
.
mRy
)
mR
(
aSource
.
mR
)
mMask
(
aSource
.
mMask
)
mClipPath
(
aSource
.
mClipPath
)
mStopColor
(
aSource
.
mStopColor
)
mFloodColor
(
aSource
.
mFloodColor
)
mLightingColor
(
aSource
.
mLightingColor
)
mStopOpacity
(
aSource
.
mStopOpacity
)
mFloodOpacity
(
aSource
.
mFloodOpacity
)
mVectorEffect
(
aSource
.
mVectorEffect
)
mMaskType
(
aSource
.
mMaskType
)
mD
(
aSource
.
mD
)
{
MOZ_COUNT_CTOR
(
nsStyleSVGReset
)
;
}
void
nsStyleSVGReset
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleSVGReset
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
mMask
)
{
auto
&
image
=
mMask
.
mLayers
[
i
]
.
mImage
;
if
(
!
image
.
IsImageRequestType
(
)
)
{
continue
;
}
const
auto
*
url
=
image
.
GetImageRequestURLValue
(
)
;
if
(
url
-
>
IsLocalRef
(
)
)
{
continue
;
}
#
if
0
nsIURI
*
docURI
=
aPresContext
-
>
Document
(
)
-
>
GetDocumentURI
(
)
;
if
(
url
-
>
EqualsExceptRef
(
docURI
)
)
{
continue
;
}
#
endif
const
auto
*
oldImage
=
(
aOldStyle
&
&
aOldStyle
-
>
mMask
.
mLayers
.
Length
(
)
>
i
)
?
&
aOldStyle
-
>
mMask
.
mLayers
[
i
]
.
mImage
:
nullptr
;
image
.
ResolveImage
(
aDocument
oldImage
)
;
}
}
nsChangeHint
nsStyleSVGReset
:
:
CalcDifference
(
const
nsStyleSVGReset
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mX
!
=
aNewData
.
mX
|
|
mY
!
=
aNewData
.
mY
|
|
mCx
!
=
aNewData
.
mCx
|
|
mCy
!
=
aNewData
.
mCy
|
|
mR
!
=
aNewData
.
mR
|
|
mRx
!
=
aNewData
.
mRx
|
|
mRy
!
=
aNewData
.
mRy
|
|
mD
!
=
aNewData
.
mD
)
{
hint
|
=
nsChangeHint_InvalidateRenderingObservers
|
nsChangeHint_NeedReflow
;
}
if
(
mClipPath
!
=
aNewData
.
mClipPath
)
{
hint
|
=
nsChangeHint_UpdateEffects
|
nsChangeHint_RepaintFrame
;
}
if
(
mVectorEffect
!
=
aNewData
.
mVectorEffect
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
|
nsChangeHint_RepaintFrame
;
}
else
if
(
mStopColor
!
=
aNewData
.
mStopColor
|
|
mFloodColor
!
=
aNewData
.
mFloodColor
|
|
mLightingColor
!
=
aNewData
.
mLightingColor
|
|
mStopOpacity
!
=
aNewData
.
mStopOpacity
|
|
mFloodOpacity
!
=
aNewData
.
mFloodOpacity
|
|
mMaskType
!
=
aNewData
.
mMaskType
|
|
mD
!
=
aNewData
.
mD
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
hint
|
=
mMask
.
CalcDifference
(
aNewData
.
mMask
nsStyleImageLayers
:
:
LayerType
:
:
Mask
)
;
return
hint
;
}
bool
nsStyleSVGReset
:
:
HasMask
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mMask
.
mImageCount
;
i
+
+
)
{
if
(
!
mMask
.
mLayers
[
i
]
.
mImage
.
IsNone
(
)
)
{
return
true
;
}
}
return
false
;
}
nsChangeHint
nsStylePage
:
:
CalcDifference
(
const
nsStylePage
&
aNewData
)
const
{
if
(
aNewData
.
mSize
!
=
mSize
|
|
aNewData
.
mPage
!
=
mPage
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint_Empty
;
}
nsStylePosition
:
:
nsStylePosition
(
const
Document
&
aDocument
)
:
mObjectPosition
(
Position
:
:
FromPercentage
(
0
.
5f
)
)
mOffset
(
StyleRectWithAllSides
(
LengthPercentageOrAuto
:
:
Auto
(
)
)
)
mWidth
(
StyleSize
:
:
Auto
(
)
)
mMinWidth
(
StyleSize
:
:
Auto
(
)
)
mMaxWidth
(
StyleMaxSize
:
:
None
(
)
)
mHeight
(
StyleSize
:
:
Auto
(
)
)
mMinHeight
(
StyleSize
:
:
Auto
(
)
)
mMaxHeight
(
StyleMaxSize
:
:
None
(
)
)
mFlexBasis
(
StyleFlexBasis
:
:
Size
(
StyleSize
:
:
Auto
(
)
)
)
mAspectRatio
(
StyleAspectRatio
:
:
Auto
(
)
)
mGridAutoFlow
(
StyleGridAutoFlow
:
:
ROW
)
mMasonryAutoFlow
(
{
StyleMasonryPlacement
:
:
Pack
StyleMasonryItemOrder
:
:
DefiniteFirst
}
)
mAlignContent
(
{
StyleAlignFlags
:
:
NORMAL
}
)
mAlignItems
(
{
StyleAlignFlags
:
:
NORMAL
}
)
mAlignSelf
(
{
StyleAlignFlags
:
:
AUTO
}
)
mJustifyContent
(
{
StyleAlignFlags
:
:
NORMAL
}
)
mJustifyItems
(
{
{
StyleAlignFlags
:
:
LEGACY
}
{
StyleAlignFlags
:
:
NORMAL
}
}
)
mJustifySelf
(
{
StyleAlignFlags
:
:
AUTO
}
)
mFlexDirection
(
StyleFlexDirection
:
:
Row
)
mFlexWrap
(
StyleFlexWrap
:
:
Nowrap
)
mObjectFit
(
StyleObjectFit
:
:
Fill
)
mBoxSizing
(
StyleBoxSizing
:
:
Content
)
mOrder
(
0
)
mFlexGrow
(
0
.
0f
)
mFlexShrink
(
1
.
0f
)
mZIndex
(
StyleZIndex
:
:
Auto
(
)
)
mGridTemplateColumns
(
StyleGridTemplateComponent
:
:
None
(
)
)
mGridTemplateRows
(
StyleGridTemplateComponent
:
:
None
(
)
)
mGridTemplateAreas
(
StyleGridTemplateAreas
:
:
None
(
)
)
mColumnGap
(
NonNegativeLengthPercentageOrNormal
:
:
Normal
(
)
)
mRowGap
(
NonNegativeLengthPercentageOrNormal
:
:
Normal
(
)
)
mContainIntrinsicWidth
(
StyleContainIntrinsicSize
:
:
None
(
)
)
mContainIntrinsicHeight
(
StyleContainIntrinsicSize
:
:
None
(
)
)
{
MOZ_COUNT_CTOR
(
nsStylePosition
)
;
}
nsStylePosition
:
:
~
nsStylePosition
(
)
{
MOZ_COUNT_DTOR
(
nsStylePosition
)
;
}
nsStylePosition
:
:
nsStylePosition
(
const
nsStylePosition
&
aSource
)
:
mAlignTracks
(
aSource
.
mAlignTracks
)
mJustifyTracks
(
aSource
.
mJustifyTracks
)
mObjectPosition
(
aSource
.
mObjectPosition
)
mOffset
(
aSource
.
mOffset
)
mWidth
(
aSource
.
mWidth
)
mMinWidth
(
aSource
.
mMinWidth
)
mMaxWidth
(
aSource
.
mMaxWidth
)
mHeight
(
aSource
.
mHeight
)
mMinHeight
(
aSource
.
mMinHeight
)
mMaxHeight
(
aSource
.
mMaxHeight
)
mFlexBasis
(
aSource
.
mFlexBasis
)
mGridAutoColumns
(
aSource
.
mGridAutoColumns
)
mGridAutoRows
(
aSource
.
mGridAutoRows
)
mAspectRatio
(
aSource
.
mAspectRatio
)
mGridAutoFlow
(
aSource
.
mGridAutoFlow
)
mMasonryAutoFlow
(
aSource
.
mMasonryAutoFlow
)
mAlignContent
(
aSource
.
mAlignContent
)
mAlignItems
(
aSource
.
mAlignItems
)
mAlignSelf
(
aSource
.
mAlignSelf
)
mJustifyContent
(
aSource
.
mJustifyContent
)
mJustifyItems
(
aSource
.
mJustifyItems
)
mJustifySelf
(
aSource
.
mJustifySelf
)
mFlexDirection
(
aSource
.
mFlexDirection
)
mFlexWrap
(
aSource
.
mFlexWrap
)
mObjectFit
(
aSource
.
mObjectFit
)
mBoxSizing
(
aSource
.
mBoxSizing
)
mOrder
(
aSource
.
mOrder
)
mFlexGrow
(
aSource
.
mFlexGrow
)
mFlexShrink
(
aSource
.
mFlexShrink
)
mZIndex
(
aSource
.
mZIndex
)
mGridTemplateColumns
(
aSource
.
mGridTemplateColumns
)
mGridTemplateRows
(
aSource
.
mGridTemplateRows
)
mGridTemplateAreas
(
aSource
.
mGridTemplateAreas
)
mGridColumnStart
(
aSource
.
mGridColumnStart
)
mGridColumnEnd
(
aSource
.
mGridColumnEnd
)
mGridRowStart
(
aSource
.
mGridRowStart
)
mGridRowEnd
(
aSource
.
mGridRowEnd
)
mColumnGap
(
aSource
.
mColumnGap
)
mRowGap
(
aSource
.
mRowGap
)
mContainIntrinsicWidth
(
aSource
.
mContainIntrinsicWidth
)
mContainIntrinsicHeight
(
aSource
.
mContainIntrinsicHeight
)
{
MOZ_COUNT_CTOR
(
nsStylePosition
)
;
}
static
bool
IsAutonessEqual
(
const
StyleRect
<
LengthPercentageOrAuto
>
&
aSides1
const
StyleRect
<
LengthPercentageOrAuto
>
&
aSides2
)
{
for
(
const
auto
side
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
if
(
aSides1
.
Get
(
side
)
.
IsAuto
(
)
!
=
aSides2
.
Get
(
side
)
.
IsAuto
(
)
)
{
return
false
;
}
}
return
true
;
}
nsChangeHint
nsStylePosition
:
:
CalcDifference
(
const
nsStylePosition
&
aNewData
const
nsStyleVisibility
&
aOldStyleVisibility
)
const
{
if
(
mGridTemplateColumns
.
IsMasonry
(
)
!
=
aNewData
.
mGridTemplateColumns
.
IsMasonry
(
)
|
|
mGridTemplateRows
.
IsMasonry
(
)
!
=
aNewData
.
mGridTemplateRows
.
IsMasonry
(
)
)
{
return
nsChangeHint_ReconstructFrame
;
}
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mZIndex
!
=
aNewData
.
mZIndex
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mObjectFit
!
=
aNewData
.
mObjectFit
|
|
mObjectPosition
!
=
aNewData
.
mObjectPosition
)
{
hint
|
=
nsChangeHint_RepaintFrame
|
nsChangeHint_NeedReflow
;
}
if
(
mContainIntrinsicWidth
!
=
aNewData
.
mContainIntrinsicWidth
|
|
mContainIntrinsicHeight
!
=
aNewData
.
mContainIntrinsicHeight
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
if
(
mOrder
!
=
aNewData
.
mOrder
)
{
return
hint
|
nsChangeHint_RepaintFrame
|
nsChangeHint_AllReflowHints
;
}
if
(
mBoxSizing
!
=
aNewData
.
mBoxSizing
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mAlignItems
!
=
aNewData
.
mAlignItems
|
|
mAlignSelf
!
=
aNewData
.
mAlignSelf
|
|
mJustifyTracks
!
=
aNewData
.
mJustifyTracks
|
|
mAlignTracks
!
=
aNewData
.
mAlignTracks
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mFlexBasis
!
=
aNewData
.
mFlexBasis
|
|
mFlexGrow
!
=
aNewData
.
mFlexGrow
|
|
mFlexShrink
!
=
aNewData
.
mFlexShrink
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mFlexDirection
!
=
aNewData
.
mFlexDirection
|
|
mFlexWrap
!
=
aNewData
.
mFlexWrap
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mGridTemplateColumns
!
=
aNewData
.
mGridTemplateColumns
|
|
mGridTemplateRows
!
=
aNewData
.
mGridTemplateRows
|
|
mGridTemplateAreas
!
=
aNewData
.
mGridTemplateAreas
|
|
mGridAutoColumns
!
=
aNewData
.
mGridAutoColumns
|
|
mGridAutoRows
!
=
aNewData
.
mGridAutoRows
|
|
mGridAutoFlow
!
=
aNewData
.
mGridAutoFlow
|
|
mMasonryAutoFlow
!
=
aNewData
.
mMasonryAutoFlow
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mGridColumnStart
!
=
aNewData
.
mGridColumnStart
|
|
mGridColumnEnd
!
=
aNewData
.
mGridColumnEnd
|
|
mGridRowStart
!
=
aNewData
.
mGridRowStart
|
|
mGridRowEnd
!
=
aNewData
.
mGridRowEnd
|
|
mColumnGap
!
=
aNewData
.
mColumnGap
|
|
mRowGap
!
=
aNewData
.
mRowGap
)
{
return
hint
|
nsChangeHint_AllReflowHints
;
}
if
(
mJustifyContent
!
=
aNewData
.
mJustifyContent
|
|
mJustifyItems
.
computed
!
=
aNewData
.
mJustifyItems
.
computed
|
|
mJustifySelf
!
=
aNewData
.
mJustifySelf
)
{
hint
|
=
nsChangeHint_NeedReflow
;
}
if
(
mJustifyItems
.
specified
!
=
aNewData
.
mJustifyItems
.
specified
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
if
(
mAlignContent
!
=
aNewData
.
mAlignContent
)
{
hint
|
=
nsChangeHint_NeedReflow
;
}
bool
widthChanged
=
mWidth
!
=
aNewData
.
mWidth
|
|
mMinWidth
!
=
aNewData
.
mMinWidth
|
|
mMaxWidth
!
=
aNewData
.
mMaxWidth
;
bool
heightChanged
=
mHeight
!
=
aNewData
.
mHeight
|
|
mMinHeight
!
=
aNewData
.
mMinHeight
|
|
mMaxHeight
!
=
aNewData
.
mMaxHeight
;
bool
isVertical
=
aOldStyleVisibility
.
mWritingMode
!
=
StyleWritingModeProperty
:
:
HorizontalTb
;
if
(
isVertical
?
widthChanged
:
heightChanged
)
{
hint
|
=
nsChangeHint_ReflowHintsForBSizeChange
;
}
if
(
isVertical
?
heightChanged
:
widthChanged
)
{
hint
|
=
nsChangeHint_ReflowHintsForISizeChange
;
}
if
(
mAspectRatio
!
=
aNewData
.
mAspectRatio
)
{
hint
|
=
nsChangeHint_ReflowHintsForISizeChange
|
nsChangeHint_ReflowHintsForBSizeChange
;
}
if
(
mOffset
!
=
aNewData
.
mOffset
)
{
if
(
IsAutonessEqual
(
mOffset
aNewData
.
mOffset
)
)
{
hint
|
=
nsChangeHint_RecomputePosition
|
nsChangeHint_UpdateParentOverflow
;
}
else
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_ReflowChangesSizeOrPosition
;
}
}
return
hint
;
}
const
StyleContainIntrinsicSize
&
nsStylePosition
:
:
ContainIntrinsicBSize
(
const
WritingMode
&
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
mContainIntrinsicWidth
:
mContainIntrinsicHeight
;
}
const
StyleContainIntrinsicSize
&
nsStylePosition
:
:
ContainIntrinsicISize
(
const
WritingMode
&
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
mContainIntrinsicHeight
:
mContainIntrinsicWidth
;
}
StyleAlignSelf
nsStylePosition
:
:
UsedAlignSelf
(
const
ComputedStyle
*
aParent
)
const
{
if
(
mAlignSelf
.
_0
!
=
StyleAlignFlags
:
:
AUTO
)
{
return
mAlignSelf
;
}
if
(
MOZ_LIKELY
(
aParent
)
)
{
auto
parentAlignItems
=
aParent
-
>
StylePosition
(
)
-
>
mAlignItems
;
MOZ_ASSERT
(
!
(
parentAlignItems
.
_0
&
StyleAlignFlags
:
:
LEGACY
)
"
align
-
items
can
'
t
have
'
legacy
'
"
)
;
return
{
parentAlignItems
.
_0
}
;
}
return
{
StyleAlignFlags
:
:
NORMAL
}
;
}
StyleJustifySelf
nsStylePosition
:
:
UsedJustifySelf
(
const
ComputedStyle
*
aParent
)
const
{
if
(
mJustifySelf
.
_0
!
=
StyleAlignFlags
:
:
AUTO
)
{
return
mJustifySelf
;
}
if
(
MOZ_LIKELY
(
aParent
)
)
{
const
auto
&
inheritedJustifyItems
=
aParent
-
>
StylePosition
(
)
-
>
mJustifyItems
.
computed
;
return
{
inheritedJustifyItems
.
_0
&
~
StyleAlignFlags
:
:
LEGACY
}
;
}
return
{
StyleAlignFlags
:
:
NORMAL
}
;
}
nsStyleTable
:
:
nsStyleTable
(
const
Document
&
aDocument
)
:
mLayoutStrategy
(
StyleTableLayout
:
:
Auto
)
mXSpan
(
1
)
{
MOZ_COUNT_CTOR
(
nsStyleTable
)
;
}
nsStyleTable
:
:
~
nsStyleTable
(
)
{
MOZ_COUNT_DTOR
(
nsStyleTable
)
;
}
nsStyleTable
:
:
nsStyleTable
(
const
nsStyleTable
&
aSource
)
:
mLayoutStrategy
(
aSource
.
mLayoutStrategy
)
mXSpan
(
aSource
.
mXSpan
)
{
MOZ_COUNT_CTOR
(
nsStyleTable
)
;
}
nsChangeHint
nsStyleTable
:
:
CalcDifference
(
const
nsStyleTable
&
aNewData
)
const
{
if
(
mXSpan
!
=
aNewData
.
mXSpan
|
|
mLayoutStrategy
!
=
aNewData
.
mLayoutStrategy
)
{
return
nsChangeHint_ReconstructFrame
;
}
return
nsChangeHint
(
0
)
;
}
nsStyleTableBorder
:
:
nsStyleTableBorder
(
const
Document
&
aDocument
)
:
mBorderSpacingCol
(
0
)
mBorderSpacingRow
(
0
)
mBorderCollapse
(
StyleBorderCollapse
:
:
Separate
)
mCaptionSide
(
StyleCaptionSide
:
:
Top
)
mEmptyCells
(
StyleEmptyCells
:
:
Show
)
{
MOZ_COUNT_CTOR
(
nsStyleTableBorder
)
;
}
nsStyleTableBorder
:
:
~
nsStyleTableBorder
(
)
{
MOZ_COUNT_DTOR
(
nsStyleTableBorder
)
;
}
nsStyleTableBorder
:
:
nsStyleTableBorder
(
const
nsStyleTableBorder
&
aSource
)
:
mBorderSpacingCol
(
aSource
.
mBorderSpacingCol
)
mBorderSpacingRow
(
aSource
.
mBorderSpacingRow
)
mBorderCollapse
(
aSource
.
mBorderCollapse
)
mCaptionSide
(
aSource
.
mCaptionSide
)
mEmptyCells
(
aSource
.
mEmptyCells
)
{
MOZ_COUNT_CTOR
(
nsStyleTableBorder
)
;
}
nsChangeHint
nsStyleTableBorder
:
:
CalcDifference
(
const
nsStyleTableBorder
&
aNewData
)
const
{
if
(
mBorderCollapse
!
=
aNewData
.
mBorderCollapse
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
(
mCaptionSide
=
=
aNewData
.
mCaptionSide
)
&
&
(
mBorderSpacingCol
=
=
aNewData
.
mBorderSpacingCol
)
&
&
(
mBorderSpacingRow
=
=
aNewData
.
mBorderSpacingRow
)
)
{
if
(
mEmptyCells
=
=
aNewData
.
mEmptyCells
)
{
return
nsChangeHint
(
0
)
;
}
return
NS_STYLE_HINT_VISUAL
;
}
else
{
return
NS_STYLE_HINT_REFLOW
;
}
}
template
<
typename
T
>
static
bool
GradientItemsAreOpaque
(
Span
<
const
StyleGenericGradientItem
<
StyleColor
T
>
>
aItems
)
{
for
(
auto
&
stop
:
aItems
)
{
if
(
stop
.
IsInterpolationHint
(
)
)
{
continue
;
}
auto
&
color
=
stop
.
IsSimpleColorStop
(
)
?
stop
.
AsSimpleColorStop
(
)
:
stop
.
AsComplexColorStop
(
)
.
color
;
if
(
color
.
MaybeTransparent
(
)
)
{
return
false
;
}
}
return
true
;
}
template
<
>
bool
StyleGradient
:
:
IsOpaque
(
)
const
{
if
(
IsLinear
(
)
)
{
return
GradientItemsAreOpaque
(
AsLinear
(
)
.
items
.
AsSpan
(
)
)
;
}
if
(
IsRadial
(
)
)
{
return
GradientItemsAreOpaque
(
AsRadial
(
)
.
items
.
AsSpan
(
)
)
;
}
return
GradientItemsAreOpaque
(
AsConic
(
)
.
items
.
AsSpan
(
)
)
;
}
void
CachedBorderImageData
:
:
PurgeCachedImages
(
)
{
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSubImages
.
Clear
(
)
;
}
void
CachedBorderImageData
:
:
PurgeCacheForViewportChange
(
const
Maybe
<
nsSize
>
&
aSize
const
bool
aHasIntrinsicRatio
)
{
if
(
aSize
!
=
mCachedSVGViewportSize
&
&
!
aHasIntrinsicRatio
)
{
PurgeCachedImages
(
)
;
SetCachedSVGViewportSize
(
aSize
)
;
}
}
static
int32_t
ConvertToPixelCoord
(
const
StyleNumberOrPercentage
&
aCoord
int32_t
aPercentScale
)
{
double
pixelValue
;
if
(
aCoord
.
IsNumber
(
)
)
{
pixelValue
=
aCoord
.
AsNumber
(
)
;
}
else
{
MOZ_ASSERT
(
aCoord
.
IsPercentage
(
)
)
;
pixelValue
=
aCoord
.
AsPercentage
(
)
.
_0
*
aPercentScale
;
}
MOZ_ASSERT
(
pixelValue
>
=
0
"
we
ensured
non
-
negative
while
parsing
"
)
;
pixelValue
=
std
:
:
min
(
pixelValue
double
(
INT32_MAX
)
)
;
return
NS_lround
(
pixelValue
)
;
}
template
<
>
Maybe
<
StyleImage
:
:
ActualCropRect
>
StyleImage
:
:
ComputeActualCropRect
(
)
const
{
MOZ_ASSERT
(
IsRect
(
)
"
This
function
is
designed
to
be
used
only
image
-
rect
images
"
)
;
imgRequestProxy
*
req
=
GetImageRequest
(
)
;
if
(
!
req
)
{
return
Nothing
(
)
;
}
nsCOMPtr
<
imgIContainer
>
imageContainer
;
req
-
>
GetImage
(
getter_AddRefs
(
imageContainer
)
)
;
if
(
!
imageContainer
)
{
return
Nothing
(
)
;
}
nsIntSize
imageSize
;
imageContainer
-
>
GetWidth
(
&
imageSize
.
width
)
;
imageContainer
-
>
GetHeight
(
&
imageSize
.
height
)
;
if
(
imageSize
.
width
<
=
0
|
|
imageSize
.
height
<
=
0
)
{
return
Nothing
(
)
;
}
auto
&
rect
=
AsRect
(
)
;
int32_t
left
=
ConvertToPixelCoord
(
rect
-
>
left
imageSize
.
width
)
;
int32_t
top
=
ConvertToPixelCoord
(
rect
-
>
top
imageSize
.
height
)
;
int32_t
right
=
ConvertToPixelCoord
(
rect
-
>
right
imageSize
.
width
)
;
int32_t
bottom
=
ConvertToPixelCoord
(
rect
-
>
bottom
imageSize
.
height
)
;
nsIntRect
cropRect
(
left
top
right
-
left
bottom
-
top
)
;
nsIntRect
imageRect
(
nsIntPoint
(
0
0
)
imageSize
)
;
auto
finalRect
=
imageRect
.
Intersect
(
cropRect
)
;
bool
isEntireImage
=
finalRect
.
IsEqualInterior
(
imageRect
)
;
return
Some
(
ActualCropRect
{
finalRect
isEntireImage
}
)
;
}
template
<
>
bool
StyleImage
:
:
IsOpaque
(
)
const
{
if
(
IsImageSet
(
)
)
{
return
FinalImage
(
)
.
IsOpaque
(
)
;
}
if
(
!
IsComplete
(
)
)
{
return
false
;
}
if
(
IsGradient
(
)
)
{
return
AsGradient
(
)
-
>
IsOpaque
(
)
;
}
if
(
IsElement
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsImageRequestType
(
)
"
unexpected
image
type
"
)
;
MOZ_ASSERT
(
GetImageRequest
(
)
"
should
'
ve
returned
earlier
above
"
)
;
nsCOMPtr
<
imgIContainer
>
imageContainer
;
GetImageRequest
(
)
-
>
GetImage
(
getter_AddRefs
(
imageContainer
)
)
;
MOZ_ASSERT
(
imageContainer
"
IsComplete
(
)
said
image
container
is
ready
"
)
;
if
(
imageContainer
-
>
WillDrawOpaqueNow
(
)
)
{
if
(
!
IsRect
(
)
)
{
return
true
;
}
auto
croprect
=
ComputeActualCropRect
(
)
;
return
croprect
&
&
!
croprect
-
>
mRect
.
IsEmpty
(
)
;
}
return
false
;
}
template
<
>
bool
StyleImage
:
:
IsComplete
(
)
const
{
switch
(
tag
)
{
case
Tag
:
:
None
:
return
false
;
case
Tag
:
:
Gradient
:
case
Tag
:
:
Element
:
return
true
;
case
Tag
:
:
Url
:
case
Tag
:
:
Rect
:
{
if
(
!
IsResolved
(
)
)
{
return
false
;
}
imgRequestProxy
*
req
=
GetImageRequest
(
)
;
if
(
!
req
)
{
return
false
;
}
uint32_t
status
=
imgIRequest
:
:
STATUS_ERROR
;
return
NS_SUCCEEDED
(
req
-
>
GetImageStatus
(
&
status
)
)
&
&
(
status
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
&
&
(
status
&
imgIRequest
:
:
STATUS_FRAME_COMPLETE
)
;
}
case
Tag
:
:
ImageSet
:
return
FinalImage
(
)
.
IsComplete
(
)
;
case
Tag
:
:
CrossFade
:
return
true
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
image
type
"
)
;
return
false
;
}
template
<
>
bool
StyleImage
:
:
IsSizeAvailable
(
)
const
{
switch
(
tag
)
{
case
Tag
:
:
None
:
return
false
;
case
Tag
:
:
Gradient
:
case
Tag
:
:
Element
:
return
true
;
case
Tag
:
:
Url
:
case
Tag
:
:
Rect
:
{
imgRequestProxy
*
req
=
GetImageRequest
(
)
;
if
(
!
req
)
{
return
false
;
}
uint32_t
status
=
imgIRequest
:
:
STATUS_ERROR
;
return
NS_SUCCEEDED
(
req
-
>
GetImageStatus
(
&
status
)
)
&
&
!
(
status
&
imgIRequest
:
:
STATUS_ERROR
)
&
&
(
status
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
;
}
case
Tag
:
:
ImageSet
:
return
FinalImage
(
)
.
IsSizeAvailable
(
)
;
case
Tag
:
:
CrossFade
:
return
true
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
image
type
"
)
;
return
false
;
}
template
<
>
void
StyleImage
:
:
ResolveImage
(
Document
&
aDoc
const
StyleImage
*
aOld
)
{
if
(
IsResolved
(
)
)
{
return
;
}
auto
*
old
=
aOld
?
aOld
-
>
GetImageRequestURLValue
(
)
:
nullptr
;
auto
*
url
=
GetImageRequestURLValue
(
)
;
const_cast
<
StyleComputedImageUrl
*
>
(
url
)
-
>
ResolveImage
(
aDoc
old
)
;
}
template
<
>
ImageResolution
StyleImage
:
:
GetResolution
(
)
const
{
ImageResolution
resolution
;
if
(
imgRequestProxy
*
request
=
GetImageRequest
(
)
)
{
RefPtr
<
imgIContainer
>
image
;
request
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
if
(
image
)
{
resolution
=
image
-
>
GetResolution
(
)
;
}
}
if
(
IsImageSet
(
)
)
{
auto
&
set
=
AsImageSet
(
)
;
float
r
=
set
-
>
items
.
AsSpan
(
)
[
set
-
>
selected_index
]
.
resolution
.
_0
;
resolution
.
ScaleBy
(
r
)
;
}
return
resolution
;
}
template
<
>
Maybe
<
CSSIntSize
>
StyleImage
:
:
GetIntrinsicSize
(
)
const
{
imgRequestProxy
*
request
=
GetImageRequest
(
)
;
if
(
!
request
)
{
return
Nothing
(
)
;
}
RefPtr
<
imgIContainer
>
image
;
request
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
if
(
!
image
)
{
return
Nothing
(
)
;
}
int32_t
w
=
0
h
=
0
;
image
-
>
GetWidth
(
&
w
)
;
image
-
>
GetHeight
(
&
h
)
;
GetResolution
(
)
.
ApplyTo
(
w
h
)
;
return
Some
(
CSSIntSize
{
w
h
}
)
;
}
const
nsCSSPropertyID
nsStyleImageLayers
:
:
kBackgroundLayerTable
[
]
=
{
eCSSProperty_background
eCSSProperty_background_color
eCSSProperty_background_image
eCSSProperty_background_repeat
eCSSProperty_background_position_x
eCSSProperty_background_position_y
eCSSProperty_background_clip
eCSSProperty_background_origin
eCSSProperty_background_size
eCSSProperty_background_attachment
eCSSProperty_UNKNOWN
eCSSProperty_UNKNOWN
}
;
const
nsCSSPropertyID
nsStyleImageLayers
:
:
kMaskLayerTable
[
]
=
{
eCSSProperty_mask
eCSSProperty_UNKNOWN
eCSSProperty_mask_image
eCSSProperty_mask_repeat
eCSSProperty_mask_position_x
eCSSProperty_mask_position_y
eCSSProperty_mask_clip
eCSSProperty_mask_origin
eCSSProperty_mask_size
eCSSProperty_UNKNOWN
eCSSProperty_mask_mode
eCSSProperty_mask_composite
}
;
nsStyleImageLayers
:
:
nsStyleImageLayers
(
nsStyleImageLayers
:
:
LayerType
aType
)
:
mAttachmentCount
(
1
)
mClipCount
(
1
)
mOriginCount
(
1
)
mRepeatCount
(
1
)
mPositionXCount
(
1
)
mPositionYCount
(
1
)
mImageCount
(
1
)
mSizeCount
(
1
)
mMaskModeCount
(
1
)
mBlendModeCount
(
1
)
mCompositeCount
(
1
)
mLayers
(
nsStyleAutoArray
<
Layer
>
:
:
WITH_SINGLE_INITIAL_ELEMENT
)
{
MOZ_COUNT_CTOR
(
nsStyleImageLayers
)
;
mLayers
[
0
]
.
Initialize
(
aType
)
;
}
nsStyleImageLayers
:
:
nsStyleImageLayers
(
const
nsStyleImageLayers
&
aSource
)
:
mAttachmentCount
(
aSource
.
mAttachmentCount
)
mClipCount
(
aSource
.
mClipCount
)
mOriginCount
(
aSource
.
mOriginCount
)
mRepeatCount
(
aSource
.
mRepeatCount
)
mPositionXCount
(
aSource
.
mPositionXCount
)
mPositionYCount
(
aSource
.
mPositionYCount
)
mImageCount
(
aSource
.
mImageCount
)
mSizeCount
(
aSource
.
mSizeCount
)
mMaskModeCount
(
aSource
.
mMaskModeCount
)
mBlendModeCount
(
aSource
.
mBlendModeCount
)
mCompositeCount
(
aSource
.
mCompositeCount
)
mLayers
(
aSource
.
mLayers
.
Clone
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleImageLayers
)
;
}
static
bool
AnyLayerIsElementImage
(
const
nsStyleImageLayers
&
aLayers
)
{
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
aLayers
)
{
if
(
aLayers
.
mLayers
[
i
]
.
mImage
.
FinalImage
(
)
.
IsElement
(
)
)
{
return
true
;
}
}
return
false
;
}
nsChangeHint
nsStyleImageLayers
:
:
CalcDifference
(
const
nsStyleImageLayers
&
aNewLayers
LayerType
aType
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mImageCount
!
=
aNewLayers
.
mImageCount
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
if
(
aType
=
=
nsStyleImageLayers
:
:
LayerType
:
:
Mask
|
|
AnyLayerIsElementImage
(
*
this
)
|
|
AnyLayerIsElementImage
(
aNewLayers
)
)
{
hint
|
=
nsChangeHint_UpdateEffects
;
}
return
hint
;
}
const
nsStyleImageLayers
&
moreLayers
=
mLayers
.
Length
(
)
>
aNewLayers
.
mLayers
.
Length
(
)
?
*
this
:
aNewLayers
;
const
nsStyleImageLayers
&
lessLayers
=
mLayers
.
Length
(
)
>
aNewLayers
.
mLayers
.
Length
(
)
?
aNewLayers
:
*
this
;
for
(
size_t
i
=
0
;
i
<
moreLayers
.
mLayers
.
Length
(
)
;
+
+
i
)
{
const
Layer
&
moreLayersLayer
=
moreLayers
.
mLayers
[
i
]
;
if
(
i
<
moreLayers
.
mImageCount
)
{
const
Layer
&
lessLayersLayer
=
lessLayers
.
mLayers
[
i
]
;
nsChangeHint
layerDifference
=
moreLayersLayer
.
CalcDifference
(
lessLayersLayer
)
;
if
(
layerDifference
&
&
(
moreLayersLayer
.
mImage
.
FinalImage
(
)
.
IsElement
(
)
|
|
lessLayersLayer
.
mImage
.
FinalImage
(
)
.
IsElement
(
)
)
)
{
layerDifference
|
=
nsChangeHint_UpdateEffects
|
nsChangeHint_RepaintFrame
;
}
hint
|
=
layerDifference
;
continue
;
}
if
(
hint
)
{
return
hint
;
}
if
(
i
>
=
lessLayers
.
mLayers
.
Length
(
)
)
{
return
nsChangeHint_NeutralChange
;
}
const
Layer
&
lessLayersLayer
=
lessLayers
.
mLayers
[
i
]
;
MOZ_ASSERT
(
moreLayersLayer
.
mImage
.
IsNone
(
)
)
;
MOZ_ASSERT
(
lessLayersLayer
.
mImage
.
IsNone
(
)
)
;
if
(
moreLayersLayer
.
CalcDifference
(
lessLayersLayer
)
)
{
return
nsChangeHint_NeutralChange
;
}
}
if
(
hint
)
{
return
hint
;
}
if
(
mAttachmentCount
!
=
aNewLayers
.
mAttachmentCount
|
|
mBlendModeCount
!
=
aNewLayers
.
mBlendModeCount
|
|
mClipCount
!
=
aNewLayers
.
mClipCount
|
|
mCompositeCount
!
=
aNewLayers
.
mCompositeCount
|
|
mMaskModeCount
!
=
aNewLayers
.
mMaskModeCount
|
|
mOriginCount
!
=
aNewLayers
.
mOriginCount
|
|
mRepeatCount
!
=
aNewLayers
.
mRepeatCount
|
|
mPositionXCount
!
=
aNewLayers
.
mPositionXCount
|
|
mPositionYCount
!
=
aNewLayers
.
mPositionYCount
|
|
mSizeCount
!
=
aNewLayers
.
mSizeCount
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
nsStyleImageLayers
&
nsStyleImageLayers
:
:
operator
=
(
const
nsStyleImageLayers
&
aOther
)
{
mAttachmentCount
=
aOther
.
mAttachmentCount
;
mClipCount
=
aOther
.
mClipCount
;
mOriginCount
=
aOther
.
mOriginCount
;
mRepeatCount
=
aOther
.
mRepeatCount
;
mPositionXCount
=
aOther
.
mPositionXCount
;
mPositionYCount
=
aOther
.
mPositionYCount
;
mImageCount
=
aOther
.
mImageCount
;
mSizeCount
=
aOther
.
mSizeCount
;
mMaskModeCount
=
aOther
.
mMaskModeCount
;
mBlendModeCount
=
aOther
.
mBlendModeCount
;
mCompositeCount
=
aOther
.
mCompositeCount
;
mLayers
=
aOther
.
mLayers
.
Clone
(
)
;
return
*
this
;
}
bool
nsStyleImageLayers
:
:
operator
=
=
(
const
nsStyleImageLayers
&
aOther
)
const
{
if
(
mAttachmentCount
!
=
aOther
.
mAttachmentCount
|
|
mClipCount
!
=
aOther
.
mClipCount
|
|
mOriginCount
!
=
aOther
.
mOriginCount
|
|
mRepeatCount
!
=
aOther
.
mRepeatCount
|
|
mPositionXCount
!
=
aOther
.
mPositionXCount
|
|
mPositionYCount
!
=
aOther
.
mPositionYCount
|
|
mImageCount
!
=
aOther
.
mImageCount
|
|
mSizeCount
!
=
aOther
.
mSizeCount
|
|
mMaskModeCount
!
=
aOther
.
mMaskModeCount
|
|
mBlendModeCount
!
=
aOther
.
mBlendModeCount
)
{
return
false
;
}
if
(
mLayers
.
Length
(
)
!
=
aOther
.
mLayers
.
Length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
mLayers
.
Length
(
)
;
i
+
+
)
{
if
(
mLayers
[
i
]
.
mPosition
!
=
aOther
.
mLayers
[
i
]
.
mPosition
|
|
mLayers
[
i
]
.
mImage
!
=
aOther
.
mLayers
[
i
]
.
mImage
|
|
mLayers
[
i
]
.
mSize
!
=
aOther
.
mLayers
[
i
]
.
mSize
|
|
mLayers
[
i
]
.
mClip
!
=
aOther
.
mLayers
[
i
]
.
mClip
|
|
mLayers
[
i
]
.
mOrigin
!
=
aOther
.
mLayers
[
i
]
.
mOrigin
|
|
mLayers
[
i
]
.
mAttachment
!
=
aOther
.
mLayers
[
i
]
.
mAttachment
|
|
mLayers
[
i
]
.
mBlendMode
!
=
aOther
.
mLayers
[
i
]
.
mBlendMode
|
|
mLayers
[
i
]
.
mComposite
!
=
aOther
.
mLayers
[
i
]
.
mComposite
|
|
mLayers
[
i
]
.
mMaskMode
!
=
aOther
.
mLayers
[
i
]
.
mMaskMode
|
|
mLayers
[
i
]
.
mRepeat
!
=
aOther
.
mLayers
[
i
]
.
mRepeat
)
{
return
false
;
}
}
return
true
;
}
static
bool
SizeDependsOnPositioningAreaSize
(
const
StyleBackgroundSize
&
aSize
const
StyleImage
&
aImage
)
{
MOZ_ASSERT
(
!
aImage
.
IsNone
(
)
"
caller
should
have
handled
this
"
)
;
MOZ_ASSERT
(
!
aImage
.
IsImageSet
(
)
"
caller
should
have
handled
this
"
)
;
if
(
aSize
.
IsCover
(
)
|
|
aSize
.
IsContain
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
aSize
.
IsExplicitSize
(
)
)
;
auto
&
size
=
aSize
.
explicit_size
;
if
(
size
.
width
.
HasPercent
(
)
|
|
size
.
height
.
HasPercent
(
)
)
{
return
true
;
}
if
(
!
size
.
width
.
IsAuto
(
)
&
&
!
size
.
height
.
IsAuto
(
)
)
{
return
false
;
}
if
(
aImage
.
IsGradient
(
)
)
{
return
true
;
}
if
(
aImage
.
IsElement
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
aImage
.
IsImageRequestType
(
)
"
Missed
some
image
"
)
;
if
(
auto
*
request
=
aImage
.
GetImageRequest
(
)
)
{
nsCOMPtr
<
imgIContainer
>
imgContainer
;
request
-
>
GetImage
(
getter_AddRefs
(
imgContainer
)
)
;
if
(
imgContainer
)
{
CSSIntSize
imageSize
;
AspectRatio
imageRatio
;
bool
hasWidth
hasHeight
;
nsLayoutUtils
:
:
ComputeSizeForDrawing
(
imgContainer
ImageResolution
(
)
imageSize
imageRatio
hasWidth
hasHeight
)
;
if
(
hasWidth
&
&
hasHeight
)
{
return
false
;
}
if
(
imageRatio
)
{
return
size
.
width
.
IsAuto
(
)
=
=
size
.
height
.
IsAuto
(
)
;
}
return
!
(
hasWidth
&
&
size
.
width
.
IsLengthPercentage
(
)
)
&
&
!
(
hasHeight
&
&
size
.
height
.
IsLengthPercentage
(
)
)
;
}
}
return
false
;
}
nsStyleImageLayers
:
:
Layer
:
:
Layer
(
)
:
mImage
(
StyleImage
:
:
None
(
)
)
mSize
(
StyleBackgroundSize
:
:
ExplicitSize
(
LengthPercentageOrAuto
:
:
Auto
(
)
LengthPercentageOrAuto
:
:
Auto
(
)
)
)
mClip
(
StyleGeometryBox
:
:
BorderBox
)
mAttachment
(
StyleImageLayerAttachment
:
:
Scroll
)
mBlendMode
(
StyleBlend
:
:
Normal
)
mComposite
(
StyleMaskComposite
:
:
Add
)
mMaskMode
(
StyleMaskMode
:
:
MatchSource
)
{
}
nsStyleImageLayers
:
:
Layer
:
:
~
Layer
(
)
=
default
;
void
nsStyleImageLayers
:
:
Layer
:
:
Initialize
(
nsStyleImageLayers
:
:
LayerType
aType
)
{
mRepeat
.
SetInitialValues
(
)
;
mPosition
=
Position
:
:
FromPercentage
(
0
.
)
;
if
(
aType
=
=
LayerType
:
:
Background
)
{
mOrigin
=
StyleGeometryBox
:
:
PaddingBox
;
}
else
{
MOZ_ASSERT
(
aType
=
=
LayerType
:
:
Mask
"
unsupported
layer
type
.
"
)
;
mOrigin
=
StyleGeometryBox
:
:
BorderBox
;
}
}
bool
nsStyleImageLayers
:
:
Layer
:
:
RenderingMightDependOnPositioningAreaSizeChange
(
)
const
{
if
(
mImage
.
IsNone
(
)
)
{
return
false
;
}
return
mPosition
.
DependsOnPositioningAreaSize
(
)
|
|
SizeDependsOnPositioningAreaSize
(
mSize
mImage
.
FinalImage
(
)
)
|
|
mRepeat
.
DependsOnPositioningAreaSize
(
)
;
}
bool
nsStyleImageLayers
:
:
Layer
:
:
operator
=
=
(
const
Layer
&
aOther
)
const
{
return
mAttachment
=
=
aOther
.
mAttachment
&
&
mClip
=
=
aOther
.
mClip
&
&
mOrigin
=
=
aOther
.
mOrigin
&
&
mRepeat
=
=
aOther
.
mRepeat
&
&
mBlendMode
=
=
aOther
.
mBlendMode
&
&
mPosition
=
=
aOther
.
mPosition
&
&
mSize
=
=
aOther
.
mSize
&
&
mImage
=
=
aOther
.
mImage
&
&
mMaskMode
=
=
aOther
.
mMaskMode
&
&
mComposite
=
=
aOther
.
mComposite
;
}
template
<
class
ComputedValueItem
>
static
void
FillImageLayerList
(
nsStyleAutoArray
<
nsStyleImageLayers
:
:
Layer
>
&
aLayers
ComputedValueItem
nsStyleImageLayers
:
:
Layer
:
:
*
aResultLocation
uint32_t
aItemCount
uint32_t
aFillCount
)
{
MOZ_ASSERT
(
aFillCount
<
=
aLayers
.
Length
(
)
"
unexpected
array
length
"
)
;
for
(
uint32_t
sourceLayer
=
0
destLayer
=
aItemCount
;
destLayer
<
aFillCount
;
+
+
sourceLayer
+
+
destLayer
)
{
aLayers
[
destLayer
]
.
*
aResultLocation
=
aLayers
[
sourceLayer
]
.
*
aResultLocation
;
}
}
static
void
FillImageLayerPositionCoordList
(
nsStyleAutoArray
<
nsStyleImageLayers
:
:
Layer
>
&
aLayers
LengthPercentage
Position
:
:
*
aResultLocation
uint32_t
aItemCount
uint32_t
aFillCount
)
{
MOZ_ASSERT
(
aFillCount
<
=
aLayers
.
Length
(
)
"
unexpected
array
length
"
)
;
for
(
uint32_t
sourceLayer
=
0
destLayer
=
aItemCount
;
destLayer
<
aFillCount
;
+
+
sourceLayer
+
+
destLayer
)
{
aLayers
[
destLayer
]
.
mPosition
.
*
aResultLocation
=
aLayers
[
sourceLayer
]
.
mPosition
.
*
aResultLocation
;
}
}
void
nsStyleImageLayers
:
:
FillAllLayers
(
uint32_t
aMaxItemCount
)
{
mLayers
.
TruncateLengthNonZero
(
aMaxItemCount
)
;
uint32_t
fillCount
=
mImageCount
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mImage
mImageCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mRepeat
mRepeatCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mAttachment
mAttachmentCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mClip
mClipCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mBlendMode
mBlendModeCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mOrigin
mOriginCount
fillCount
)
;
FillImageLayerPositionCoordList
(
mLayers
&
Position
:
:
horizontal
mPositionXCount
fillCount
)
;
FillImageLayerPositionCoordList
(
mLayers
&
Position
:
:
vertical
mPositionYCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mSize
mSizeCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mMaskMode
mMaskModeCount
fillCount
)
;
FillImageLayerList
(
mLayers
&
Layer
:
:
mComposite
mCompositeCount
fillCount
)
;
}
static
bool
UrlValuesEqual
(
const
StyleImage
&
aImage
const
StyleImage
&
aOtherImage
)
{
auto
*
url
=
aImage
.
GetImageRequestURLValue
(
)
;
auto
*
other
=
aOtherImage
.
GetImageRequestURLValue
(
)
;
return
url
=
=
other
|
|
(
url
&
&
other
&
&
*
url
=
=
*
other
)
;
}
nsChangeHint
nsStyleImageLayers
:
:
Layer
:
:
CalcDifference
(
const
nsStyleImageLayers
:
:
Layer
&
aNewLayer
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
!
UrlValuesEqual
(
mImage
aNewLayer
.
mImage
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateEffects
;
}
else
if
(
mAttachment
!
=
aNewLayer
.
mAttachment
|
|
mClip
!
=
aNewLayer
.
mClip
|
|
mOrigin
!
=
aNewLayer
.
mOrigin
|
|
mRepeat
!
=
aNewLayer
.
mRepeat
|
|
mBlendMode
!
=
aNewLayer
.
mBlendMode
|
|
mSize
!
=
aNewLayer
.
mSize
|
|
mImage
!
=
aNewLayer
.
mImage
|
|
mMaskMode
!
=
aNewLayer
.
mMaskMode
|
|
mComposite
!
=
aNewLayer
.
mComposite
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mPosition
!
=
aNewLayer
.
mPosition
)
{
hint
|
=
nsChangeHint_UpdateBackgroundPosition
;
}
return
hint
;
}
nsStyleBackground
:
:
nsStyleBackground
(
const
Document
&
aDocument
)
:
mImage
(
nsStyleImageLayers
:
:
LayerType
:
:
Background
)
mBackgroundColor
(
StyleColor
:
:
Transparent
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleBackground
)
;
}
nsStyleBackground
:
:
nsStyleBackground
(
const
nsStyleBackground
&
aSource
)
:
mImage
(
aSource
.
mImage
)
mBackgroundColor
(
aSource
.
mBackgroundColor
)
{
MOZ_COUNT_CTOR
(
nsStyleBackground
)
;
}
nsStyleBackground
:
:
~
nsStyleBackground
(
)
{
MOZ_COUNT_DTOR
(
nsStyleBackground
)
;
}
void
nsStyleBackground
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleBackground
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mImage
.
ResolveImages
(
aDocument
aOldStyle
?
&
aOldStyle
-
>
mImage
:
nullptr
)
;
}
nsChangeHint
nsStyleBackground
:
:
CalcDifference
(
const
nsStyleBackground
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mBackgroundColor
!
=
aNewData
.
mBackgroundColor
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
hint
|
=
mImage
.
CalcDifference
(
aNewData
.
mImage
nsStyleImageLayers
:
:
LayerType
:
:
Background
)
;
return
hint
;
}
bool
nsStyleBackground
:
:
HasFixedBackground
(
nsIFrame
*
aFrame
)
const
{
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
mImage
)
{
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mImage
.
mLayers
[
i
]
;
if
(
layer
.
mAttachment
=
=
StyleImageLayerAttachment
:
:
Fixed
&
&
!
layer
.
mImage
.
IsNone
(
)
&
&
!
nsLayoutUtils
:
:
IsTransformed
(
aFrame
)
)
{
return
true
;
}
}
return
false
;
}
nscolor
nsStyleBackground
:
:
BackgroundColor
(
const
nsIFrame
*
aFrame
)
const
{
return
mBackgroundColor
.
CalcColor
(
aFrame
)
;
}
nscolor
nsStyleBackground
:
:
BackgroundColor
(
const
ComputedStyle
*
aStyle
)
const
{
return
mBackgroundColor
.
CalcColor
(
*
aStyle
)
;
}
bool
nsStyleBackground
:
:
IsTransparent
(
const
nsIFrame
*
aFrame
)
const
{
return
IsTransparent
(
aFrame
-
>
Style
(
)
)
;
}
bool
nsStyleBackground
:
:
IsTransparent
(
const
ComputedStyle
*
aStyle
)
const
{
return
BottomLayer
(
)
.
mImage
.
IsNone
(
)
&
&
mImage
.
mImageCount
=
=
1
&
&
NS_GET_A
(
BackgroundColor
(
aStyle
)
)
=
=
0
;
}
StyleTransition
:
:
StyleTransition
(
const
StyleTransition
&
aCopy
)
=
default
;
void
StyleTransition
:
:
SetInitialValues
(
)
{
mTimingFunction
=
StyleComputedTimingFunction
:
:
Keyword
(
StyleTimingKeyword
:
:
Ease
)
;
mDuration
=
0
.
0
;
mDelay
=
0
.
0
;
mProperty
=
eCSSPropertyExtra_all_properties
;
}
bool
StyleTransition
:
:
operator
=
=
(
const
StyleTransition
&
aOther
)
const
{
return
mTimingFunction
=
=
aOther
.
mTimingFunction
&
&
mDuration
=
=
aOther
.
mDuration
&
&
mDelay
=
=
aOther
.
mDelay
&
&
mProperty
=
=
aOther
.
mProperty
&
&
(
mProperty
!
=
eCSSProperty_UNKNOWN
|
|
mUnknownProperty
=
=
aOther
.
mUnknownProperty
)
;
}
StyleAnimation
:
:
StyleAnimation
(
const
StyleAnimation
&
aCopy
)
=
default
;
void
StyleAnimation
:
:
SetInitialValues
(
)
{
mTimingFunction
=
StyleComputedTimingFunction
:
:
Keyword
(
StyleTimingKeyword
:
:
Ease
)
;
mDuration
=
0
.
0
;
mDelay
=
0
.
0
;
mName
=
nsGkAtoms
:
:
_empty
;
mDirection
=
dom
:
:
PlaybackDirection
:
:
Normal
;
mFillMode
=
dom
:
:
FillMode
:
:
None
;
mPlayState
=
StyleAnimationPlayState
:
:
Running
;
mIterationCount
=
1
.
0f
;
mComposition
=
dom
:
:
CompositeOperation
:
:
Replace
;
mTimeline
=
StyleAnimationTimeline
:
:
Auto
(
)
;
}
bool
StyleAnimation
:
:
operator
=
=
(
const
StyleAnimation
&
aOther
)
const
{
return
mTimingFunction
=
=
aOther
.
mTimingFunction
&
&
mDuration
=
=
aOther
.
mDuration
&
&
mDelay
=
=
aOther
.
mDelay
&
&
mName
=
=
aOther
.
mName
&
&
mDirection
=
=
aOther
.
mDirection
&
&
mFillMode
=
=
aOther
.
mFillMode
&
&
mPlayState
=
=
aOther
.
mPlayState
&
&
mIterationCount
=
=
aOther
.
mIterationCount
&
&
mComposition
=
=
aOther
.
mComposition
&
&
mTimeline
=
=
aOther
.
mTimeline
;
}
nsStyleDisplay
:
:
nsStyleDisplay
(
const
Document
&
aDocument
)
:
mDisplay
(
StyleDisplay
:
:
Inline
)
mOriginalDisplay
(
StyleDisplay
:
:
Inline
)
mContentVisibility
(
StyleContentVisibility
:
:
Visible
)
mContainerType
(
StyleContainerType
:
:
Normal
)
mAppearance
(
StyleAppearance
:
:
None
)
mContain
(
StyleContain
:
:
NONE
)
mEffectiveContainment
(
StyleContain
:
:
NONE
)
mDefaultAppearance
(
StyleAppearance
:
:
None
)
mPosition
(
StylePositionProperty
:
:
Static
)
mFloat
(
StyleFloat
:
:
None
)
mClear
(
StyleClear
:
:
None
)
mBreakInside
(
StyleBreakWithin
:
:
Auto
)
mBreakBefore
(
StyleBreakBetween
:
:
Auto
)
mBreakAfter
(
StyleBreakBetween
:
:
Auto
)
mOverflowX
(
StyleOverflow
:
:
Visible
)
mOverflowY
(
StyleOverflow
:
:
Visible
)
mOverflowClipBoxBlock
(
StyleOverflowClipBox
:
:
PaddingBox
)
mOverflowClipBoxInline
(
StyleOverflowClipBox
:
:
PaddingBox
)
mScrollbarGutter
(
StyleScrollbarGutter
:
:
AUTO
)
mResize
(
StyleResize
:
:
None
)
mOrient
(
StyleOrient
:
:
Inline
)
mIsolation
(
StyleIsolation
:
:
Auto
)
mTopLayer
(
StyleTopLayer
:
:
None
)
mTouchAction
(
StyleTouchAction
:
:
AUTO
)
mScrollBehavior
(
StyleScrollBehavior
:
:
Auto
)
mOverscrollBehaviorX
(
StyleOverscrollBehavior
:
:
Auto
)
mOverscrollBehaviorY
(
StyleOverscrollBehavior
:
:
Auto
)
mOverflowAnchor
(
StyleOverflowAnchor
:
:
Auto
)
mScrollSnapAlign
{
StyleScrollSnapAlignKeyword
:
:
None
StyleScrollSnapAlignKeyword
:
:
None
}
mScrollSnapType
{
StyleScrollSnapAxis
:
:
Both
StyleScrollSnapStrictness
:
:
None
}
mBackfaceVisibility
(
StyleBackfaceVisibility
:
:
Visible
)
mTransformStyle
(
StyleTransformStyle
:
:
Flat
)
mTransformBox
(
StyleGeometryBox
:
:
BorderBox
)
mRotate
(
StyleRotate
:
:
None
(
)
)
mTranslate
(
StyleTranslate
:
:
None
(
)
)
mScale
(
StyleScale
:
:
None
(
)
)
mWillChange
{
{
}
{
0
}
}
mOffsetPath
(
StyleOffsetPath
:
:
None
(
)
)
mOffsetDistance
(
LengthPercentage
:
:
Zero
(
)
)
mOffsetRotate
{
true
StyleAngle
{
0
.
0
}
}
mOffsetAnchor
(
StylePositionOrAuto
:
:
Auto
(
)
)
mTransformOrigin
{
LengthPercentage
:
:
FromPercentage
(
0
.
5
)
LengthPercentage
:
:
FromPercentage
(
0
.
5
)
{
0
.
}
}
mChildPerspective
(
StylePerspective
:
:
None
(
)
)
mPerspectiveOrigin
(
Position
:
:
FromPercentage
(
0
.
5f
)
)
mVerticalAlign
(
StyleVerticalAlign
:
:
Keyword
(
StyleVerticalAlignKeyword
:
:
Baseline
)
)
mWebkitLineClamp
(
0
)
mShapeMargin
(
LengthPercentage
:
:
Zero
(
)
)
mShapeOutside
(
StyleShapeOutside
:
:
None
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleDisplay
)
;
}
nsStyleDisplay
:
:
nsStyleDisplay
(
const
nsStyleDisplay
&
aSource
)
:
mDisplay
(
aSource
.
mDisplay
)
mOriginalDisplay
(
aSource
.
mOriginalDisplay
)
mContentVisibility
(
aSource
.
mContentVisibility
)
mContainerType
(
aSource
.
mContainerType
)
mAppearance
(
aSource
.
mAppearance
)
mContain
(
aSource
.
mContain
)
mEffectiveContainment
(
aSource
.
mEffectiveContainment
)
mDefaultAppearance
(
aSource
.
mDefaultAppearance
)
mPosition
(
aSource
.
mPosition
)
mFloat
(
aSource
.
mFloat
)
mClear
(
aSource
.
mClear
)
mBreakInside
(
aSource
.
mBreakInside
)
mBreakBefore
(
aSource
.
mBreakBefore
)
mBreakAfter
(
aSource
.
mBreakAfter
)
mOverflowX
(
aSource
.
mOverflowX
)
mOverflowY
(
aSource
.
mOverflowY
)
mOverflowClipBoxBlock
(
aSource
.
mOverflowClipBoxBlock
)
mOverflowClipBoxInline
(
aSource
.
mOverflowClipBoxInline
)
mScrollbarGutter
(
aSource
.
mScrollbarGutter
)
mResize
(
aSource
.
mResize
)
mOrient
(
aSource
.
mOrient
)
mIsolation
(
aSource
.
mIsolation
)
mTopLayer
(
aSource
.
mTopLayer
)
mTouchAction
(
aSource
.
mTouchAction
)
mScrollBehavior
(
aSource
.
mScrollBehavior
)
mOverscrollBehaviorX
(
aSource
.
mOverscrollBehaviorX
)
mOverscrollBehaviorY
(
aSource
.
mOverscrollBehaviorY
)
mOverflowAnchor
(
aSource
.
mOverflowAnchor
)
mScrollSnapAlign
(
aSource
.
mScrollSnapAlign
)
mScrollSnapType
(
aSource
.
mScrollSnapType
)
mBackfaceVisibility
(
aSource
.
mBackfaceVisibility
)
mTransformStyle
(
aSource
.
mTransformStyle
)
mTransformBox
(
aSource
.
mTransformBox
)
mTransform
(
aSource
.
mTransform
)
mRotate
(
aSource
.
mRotate
)
mTranslate
(
aSource
.
mTranslate
)
mScale
(
aSource
.
mScale
)
mContainerName
(
aSource
.
mContainerName
)
mWillChange
(
aSource
.
mWillChange
)
mOffsetPath
(
aSource
.
mOffsetPath
)
mOffsetDistance
(
aSource
.
mOffsetDistance
)
mOffsetRotate
(
aSource
.
mOffsetRotate
)
mOffsetAnchor
(
aSource
.
mOffsetAnchor
)
mTransformOrigin
(
aSource
.
mTransformOrigin
)
mChildPerspective
(
aSource
.
mChildPerspective
)
mPerspectiveOrigin
(
aSource
.
mPerspectiveOrigin
)
mVerticalAlign
(
aSource
.
mVerticalAlign
)
mWebkitLineClamp
(
aSource
.
mWebkitLineClamp
)
mShapeImageThreshold
(
aSource
.
mShapeImageThreshold
)
mShapeMargin
(
aSource
.
mShapeMargin
)
mShapeOutside
(
aSource
.
mShapeOutside
)
{
MOZ_COUNT_CTOR
(
nsStyleDisplay
)
;
}
nsStyleDisplay
:
:
~
nsStyleDisplay
(
)
{
MOZ_COUNT_DTOR
(
nsStyleDisplay
)
;
}
void
nsStyleDisplay
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleDisplay
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mShapeOutside
.
IsImage
(
)
)
{
auto
*
old
=
aOldStyle
&
&
aOldStyle
-
>
mShapeOutside
.
IsImage
(
)
?
&
aOldStyle
-
>
mShapeOutside
.
AsImage
(
)
:
nullptr
;
const_cast
<
StyleImage
&
>
(
mShapeOutside
.
AsImage
(
)
)
.
ResolveImage
(
aDocument
old
)
;
}
}
template
<
typename
TransformLike
>
static
inline
nsChangeHint
CompareTransformValues
(
const
TransformLike
&
aOldTransform
const
TransformLike
&
aNewTransform
)
{
nsChangeHint
result
=
nsChangeHint
(
0
)
;
if
(
aOldTransform
!
=
aNewTransform
)
{
result
|
=
nsChangeHint_UpdateTransformLayer
;
if
(
!
aOldTransform
.
IsNone
(
)
&
&
!
aNewTransform
.
IsNone
(
)
)
{
result
|
=
nsChangeHint_UpdatePostTransformOverflow
;
}
else
{
result
|
=
nsChangeHint_UpdateOverflow
;
}
}
return
result
;
}
static
inline
nsChangeHint
CompareMotionValues
(
const
nsStyleDisplay
&
aDisplay
const
nsStyleDisplay
&
aNewDisplay
)
{
if
(
aDisplay
.
mOffsetPath
=
=
aNewDisplay
.
mOffsetPath
)
{
if
(
aDisplay
.
mOffsetDistance
=
=
aNewDisplay
.
mOffsetDistance
&
&
aDisplay
.
mOffsetRotate
=
=
aNewDisplay
.
mOffsetRotate
&
&
aDisplay
.
mOffsetAnchor
=
=
aNewDisplay
.
mOffsetAnchor
)
{
return
nsChangeHint
(
0
)
;
}
if
(
aDisplay
.
mOffsetPath
.
IsNone
(
)
)
{
return
nsChangeHint_NeutralChange
;
}
}
nsChangeHint
result
=
nsChangeHint_UpdateTransformLayer
;
if
(
!
aDisplay
.
mOffsetPath
.
IsNone
(
)
&
&
!
aNewDisplay
.
mOffsetPath
.
IsNone
(
)
)
{
result
|
=
nsChangeHint_UpdatePostTransformOverflow
;
}
else
{
result
|
=
nsChangeHint_UpdateOverflow
;
}
return
result
;
}
static
bool
ScrollbarGenerationChanged
(
const
nsStyleDisplay
&
aOld
const
nsStyleDisplay
&
aNew
)
{
auto
changed
=
[
]
(
StyleOverflow
aOld
StyleOverflow
aNew
)
{
return
aOld
!
=
aNew
&
&
(
aOld
=
=
StyleOverflow
:
:
Hidden
|
|
aNew
=
=
StyleOverflow
:
:
Hidden
)
;
}
;
return
changed
(
aOld
.
mOverflowX
aNew
.
mOverflowX
)
|
|
changed
(
aOld
.
mOverflowY
aNew
.
mOverflowY
)
;
}
static
bool
AppearanceValueAffectsFrames
(
StyleAppearance
aAppearance
StyleAppearance
aDefaultAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Textfield
:
return
aDefaultAppearance
=
=
StyleAppearance
:
:
NumberInput
|
|
aDefaultAppearance
=
=
StyleAppearance
:
:
Searchfield
;
case
StyleAppearance
:
:
Menulist
:
return
aDefaultAppearance
=
=
StyleAppearance
:
:
Menulist
;
default
:
return
false
;
}
}
nsChangeHint
nsStyleDisplay
:
:
CalcDifference
(
const
nsStyleDisplay
&
aNewData
const
nsStylePosition
&
aOldPosition
)
const
{
if
(
mDisplay
!
=
aNewData
.
mDisplay
|
|
mContain
!
=
aNewData
.
mContain
|
|
(
mFloat
=
=
StyleFloat
:
:
None
)
!
=
(
aNewData
.
mFloat
=
=
StyleFloat
:
:
None
)
|
|
mTopLayer
!
=
aNewData
.
mTopLayer
|
|
mResize
!
=
aNewData
.
mResize
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
mContentVisibility
!
=
aNewData
.
mContentVisibility
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
mContainerType
!
=
aNewData
.
mContainerType
)
{
return
nsChangeHint_ReconstructFrame
;
}
auto
oldAppearance
=
EffectiveAppearance
(
)
;
auto
newAppearance
=
aNewData
.
EffectiveAppearance
(
)
;
if
(
oldAppearance
!
=
newAppearance
)
{
if
(
AppearanceValueAffectsFrames
(
oldAppearance
mDefaultAppearance
)
|
|
AppearanceValueAffectsFrames
(
newAppearance
mDefaultAppearance
)
)
{
return
nsChangeHint_ReconstructFrame
;
}
}
auto
hint
=
nsChangeHint
(
0
)
;
if
(
mPosition
!
=
aNewData
.
mPosition
)
{
if
(
IsAbsolutelyPositionedStyle
(
)
|
|
aNewData
.
IsAbsolutelyPositionedStyle
(
)
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
IsRelativelyOrStickyPositionedStyle
(
)
!
=
aNewData
.
IsRelativelyOrStickyPositionedStyle
(
)
)
{
hint
|
=
nsChangeHint_UpdateContainingBlock
|
nsChangeHint_RepaintFrame
;
}
if
(
IsPositionForcingStackingContext
(
)
!
=
aNewData
.
IsPositionForcingStackingContext
(
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_ReflowChangesSizeOrPosition
;
}
if
(
mScrollSnapAlign
!
=
aNewData
.
mScrollSnapAlign
|
|
mScrollSnapType
!
=
aNewData
.
mScrollSnapType
|
|
mScrollSnapStop
!
=
aNewData
.
mScrollSnapStop
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mScrollBehavior
!
=
aNewData
.
mScrollBehavior
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
if
(
mOverflowX
!
=
aNewData
.
mOverflowX
|
|
mOverflowY
!
=
aNewData
.
mOverflowY
)
{
const
bool
isScrollable
=
IsScrollableOverflow
(
)
;
if
(
isScrollable
!
=
aNewData
.
IsScrollableOverflow
(
)
)
{
hint
|
=
nsChangeHint_ScrollbarChange
;
}
else
if
(
isScrollable
)
{
if
(
ScrollbarGenerationChanged
(
*
this
aNewData
)
)
{
hint
|
=
nsChangeHint_ScrollbarChange
;
}
else
{
hint
|
=
nsChangeHint_ReflowHintsForScrollbarChange
;
}
}
else
{
hint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_RepaintFrame
;
}
}
if
(
mScrollbarGutter
!
=
aNewData
.
mScrollbarGutter
)
{
if
(
IsScrollableOverflow
(
)
)
{
hint
|
=
nsChangeHint_ReflowHintsForScrollbarChange
;
}
else
{
hint
|
=
nsChangeHint_NeutralChange
;
}
}
if
(
mFloat
!
=
aNewData
.
mFloat
)
{
hint
|
=
nsChangeHint_ReflowHintsForFloatAreaChange
;
}
if
(
mShapeOutside
!
=
aNewData
.
mShapeOutside
|
|
mShapeMargin
!
=
aNewData
.
mShapeMargin
|
|
mShapeImageThreshold
!
=
aNewData
.
mShapeImageThreshold
)
{
if
(
aNewData
.
mFloat
!
=
StyleFloat
:
:
None
)
{
hint
|
=
nsChangeHint_ReflowHintsForFloatAreaChange
;
}
else
{
hint
|
=
nsChangeHint_NeutralChange
;
}
}
if
(
mWebkitLineClamp
!
=
aNewData
.
mWebkitLineClamp
|
|
mVerticalAlign
!
=
aNewData
.
mVerticalAlign
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
if
(
mClear
!
=
aNewData
.
mClear
|
|
mBreakInside
!
=
aNewData
.
mBreakInside
|
|
mBreakBefore
!
=
aNewData
.
mBreakBefore
|
|
mBreakAfter
!
=
aNewData
.
mBreakAfter
|
|
mAppearance
!
=
aNewData
.
mAppearance
|
|
mDefaultAppearance
!
=
aNewData
.
mDefaultAppearance
|
|
mOrient
!
=
aNewData
.
mOrient
|
|
mOverflowClipBoxBlock
!
=
aNewData
.
mOverflowClipBoxBlock
|
|
mOverflowClipBoxInline
!
=
aNewData
.
mOverflowClipBoxInline
)
{
hint
|
=
nsChangeHint_AllReflowHints
|
nsChangeHint_RepaintFrame
;
}
if
(
mIsolation
!
=
aNewData
.
mIsolation
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
HasTransformStyle
(
)
!
=
aNewData
.
HasTransformStyle
(
)
)
{
hint
|
=
nsChangeHint_ComprehensiveAddOrRemoveTransform
;
}
else
{
nsChangeHint
transformHint
=
CalcTransformPropertyDifference
(
aNewData
)
;
if
(
transformHint
)
{
if
(
HasTransformStyle
(
)
)
{
hint
|
=
transformHint
;
}
else
{
hint
|
=
nsChangeHint_NeutralChange
;
}
}
}
if
(
HasPerspectiveStyle
(
)
!
=
aNewData
.
HasPerspectiveStyle
(
)
)
{
hint
|
=
nsChangeHint_UpdateContainingBlock
|
nsChangeHint_UpdateOverflow
|
nsChangeHint_RepaintFrame
;
}
else
if
(
mChildPerspective
!
=
aNewData
.
mChildPerspective
)
{
hint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_RepaintFrame
;
}
auto
willChangeBitsChanged
=
mWillChange
.
bits
^
aNewData
.
mWillChange
.
bits
;
if
(
willChangeBitsChanged
&
(
StyleWillChangeBits
:
:
STACKING_CONTEXT_UNCONDITIONAL
|
StyleWillChangeBits
:
:
SCROLL
|
StyleWillChangeBits
:
:
OPACITY
|
StyleWillChangeBits
:
:
PERSPECTIVE
|
StyleWillChangeBits
:
:
TRANSFORM
|
StyleWillChangeBits
:
:
Z_INDEX
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
willChangeBitsChanged
&
(
StyleWillChangeBits
:
:
FIXPOS_CB_NON_SVG
|
StyleWillChangeBits
:
:
TRANSFORM
|
StyleWillChangeBits
:
:
PERSPECTIVE
|
StyleWillChangeBits
:
:
POSITION
|
StyleWillChangeBits
:
:
CONTAIN
)
)
{
hint
|
=
nsChangeHint_UpdateContainingBlock
;
}
if
(
mTouchAction
!
=
aNewData
.
mTouchAction
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mOverscrollBehaviorX
!
=
aNewData
.
mOverscrollBehaviorX
|
|
mOverscrollBehaviorY
!
=
aNewData
.
mOverscrollBehaviorY
)
{
hint
|
=
nsChangeHint_SchedulePaint
;
}
if
(
mOriginalDisplay
!
=
aNewData
.
mOriginalDisplay
)
{
if
(
IsAbsolutelyPositionedStyle
(
)
&
&
aOldPosition
.
NeedsHypotheticalPositionIfAbsPos
(
)
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_ReflowChangesSizeOrPosition
;
}
else
{
hint
|
=
nsChangeHint_NeutralChange
;
}
}
if
(
!
hint
&
&
(
mWillChange
!
=
aNewData
.
mWillChange
|
|
mOverflowAnchor
!
=
aNewData
.
mOverflowAnchor
|
|
mContainerName
!
=
aNewData
.
mContainerName
)
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
nsChangeHint
nsStyleDisplay
:
:
CalcTransformPropertyDifference
(
const
nsStyleDisplay
&
aNewData
)
const
{
nsChangeHint
transformHint
=
nsChangeHint
(
0
)
;
transformHint
|
=
CompareTransformValues
(
mTransform
aNewData
.
mTransform
)
;
transformHint
|
=
CompareTransformValues
(
mRotate
aNewData
.
mRotate
)
;
transformHint
|
=
CompareTransformValues
(
mTranslate
aNewData
.
mTranslate
)
;
transformHint
|
=
CompareTransformValues
(
mScale
aNewData
.
mScale
)
;
transformHint
|
=
CompareMotionValues
(
*
this
aNewData
)
;
if
(
mTransformOrigin
!
=
aNewData
.
mTransformOrigin
)
{
transformHint
|
=
nsChangeHint_UpdateTransformLayer
|
nsChangeHint_UpdatePostTransformOverflow
;
}
if
(
mPerspectiveOrigin
!
=
aNewData
.
mPerspectiveOrigin
|
|
mTransformStyle
!
=
aNewData
.
mTransformStyle
|
|
mTransformBox
!
=
aNewData
.
mTransformBox
)
{
transformHint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_RepaintFrame
;
}
if
(
mBackfaceVisibility
!
=
aNewData
.
mBackfaceVisibility
)
{
transformHint
|
=
nsChangeHint_RepaintFrame
;
}
return
transformHint
;
}
nsStyleVisibility
:
:
nsStyleVisibility
(
const
Document
&
aDocument
)
:
mDirection
(
aDocument
.
GetBidiOptions
(
)
=
=
IBMBIDI_TEXTDIRECTION_RTL
?
StyleDirection
:
:
Rtl
:
StyleDirection
:
:
Ltr
)
mVisible
(
StyleVisibility
:
:
Visible
)
mImageRendering
(
StyleImageRendering
:
:
Auto
)
mWritingMode
(
StyleWritingModeProperty
:
:
HorizontalTb
)
mTextOrientation
(
StyleTextOrientation
:
:
Mixed
)
mMozBoxLayout
(
StyleMozBoxLayout
:
:
Legacy
)
mPrintColorAdjust
(
StylePrintColorAdjust
:
:
Economy
)
mImageOrientation
(
StyleImageOrientation
:
:
FromImage
)
{
MOZ_COUNT_CTOR
(
nsStyleVisibility
)
;
}
nsStyleVisibility
:
:
nsStyleVisibility
(
const
nsStyleVisibility
&
aSource
)
:
mDirection
(
aSource
.
mDirection
)
mVisible
(
aSource
.
mVisible
)
mImageRendering
(
aSource
.
mImageRendering
)
mWritingMode
(
aSource
.
mWritingMode
)
mTextOrientation
(
aSource
.
mTextOrientation
)
mMozBoxLayout
(
aSource
.
mMozBoxLayout
)
mPrintColorAdjust
(
aSource
.
mPrintColorAdjust
)
mImageOrientation
(
aSource
.
mImageOrientation
)
{
MOZ_COUNT_CTOR
(
nsStyleVisibility
)
;
}
nsChangeHint
nsStyleVisibility
:
:
CalcDifference
(
const
nsStyleVisibility
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mDirection
!
=
aNewData
.
mDirection
|
|
mWritingMode
!
=
aNewData
.
mWritingMode
|
|
mMozBoxLayout
!
=
aNewData
.
mMozBoxLayout
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
mImageOrientation
!
=
aNewData
.
mImageOrientation
)
{
hint
|
=
nsChangeHint_AllReflowHints
|
nsChangeHint_RepaintFrame
;
}
if
(
mVisible
!
=
aNewData
.
mVisible
)
{
if
(
mVisible
=
=
StyleVisibility
:
:
Visible
|
|
aNewData
.
mVisible
=
=
StyleVisibility
:
:
Visible
)
{
hint
|
=
nsChangeHint_VisibilityChange
;
}
if
(
StyleVisibility
:
:
Collapse
=
=
mVisible
|
|
StyleVisibility
:
:
Collapse
=
=
aNewData
.
mVisible
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
else
{
hint
|
=
NS_STYLE_HINT_VISUAL
;
}
}
if
(
mTextOrientation
!
=
aNewData
.
mTextOrientation
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
if
(
mImageRendering
!
=
aNewData
.
mImageRendering
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mPrintColorAdjust
!
=
aNewData
.
mPrintColorAdjust
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
StyleImageOrientation
nsStyleVisibility
:
:
UsedImageOrientation
(
imgIRequest
*
aRequest
StyleImageOrientation
aOrientation
)
{
if
(
aOrientation
=
=
StyleImageOrientation
:
:
FromImage
|
|
!
aRequest
)
{
return
aOrientation
;
}
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aRequest
-
>
GetTriggeringPrincipal
(
)
;
nsCOMPtr
<
nsIURI
>
uri
=
aRequest
-
>
GetURI
(
)
;
if
(
!
triggeringPrincipal
)
{
return
aOrientation
;
}
if
(
!
triggeringPrincipal
-
>
IsSameOrigin
(
uri
)
)
{
return
StyleImageOrientation
:
:
FromImage
;
}
return
aOrientation
;
}
nsStyleContent
:
:
nsStyleContent
(
const
Document
&
aDocument
)
:
mContent
(
StyleContent
:
:
Normal
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleContent
)
;
}
nsStyleContent
:
:
~
nsStyleContent
(
)
{
MOZ_COUNT_DTOR
(
nsStyleContent
)
;
}
nsStyleContent
:
:
nsStyleContent
(
const
nsStyleContent
&
aSource
)
:
mContent
(
aSource
.
mContent
)
mCounterIncrement
(
aSource
.
mCounterIncrement
)
mCounterReset
(
aSource
.
mCounterReset
)
mCounterSet
(
aSource
.
mCounterSet
)
{
MOZ_COUNT_CTOR
(
nsStyleContent
)
;
}
nsChangeHint
nsStyleContent
:
:
CalcDifference
(
const
nsStyleContent
&
aNewData
)
const
{
if
(
mContent
!
=
aNewData
.
mContent
|
|
mCounterIncrement
!
=
aNewData
.
mCounterIncrement
|
|
mCounterReset
!
=
aNewData
.
mCounterReset
|
|
mCounterSet
!
=
aNewData
.
mCounterSet
)
{
return
nsChangeHint_ReconstructFrame
;
}
return
nsChangeHint
(
0
)
;
}
void
nsStyleContent
:
:
TriggerImageLoads
(
Document
&
aDoc
const
nsStyleContent
*
aOld
)
{
if
(
!
mContent
.
IsItems
(
)
)
{
return
;
}
Span
<
const
StyleContentItem
>
oldItems
;
if
(
aOld
&
&
aOld
-
>
mContent
.
IsItems
(
)
)
{
oldItems
=
aOld
-
>
mContent
.
AsItems
(
)
.
AsSpan
(
)
;
}
auto
items
=
mContent
.
AsItems
(
)
.
AsSpan
(
)
;
for
(
size_t
i
=
0
;
i
<
items
.
Length
(
)
;
+
+
i
)
{
auto
&
item
=
items
[
i
]
;
if
(
!
item
.
IsImage
(
)
)
{
continue
;
}
auto
&
image
=
item
.
AsImage
(
)
;
auto
*
oldImage
=
i
<
oldItems
.
Length
(
)
&
&
oldItems
[
i
]
.
IsImage
(
)
?
&
oldItems
[
i
]
.
AsImage
(
)
:
nullptr
;
const_cast
<
StyleImage
&
>
(
image
)
.
ResolveImage
(
aDoc
oldImage
)
;
}
}
nsStyleTextReset
:
:
nsStyleTextReset
(
const
Document
&
aDocument
)
:
mTextOverflow
(
)
mTextDecorationLine
(
StyleTextDecorationLine
:
:
NONE
)
mTextDecorationStyle
(
StyleTextDecorationStyle
:
:
Solid
)
mUnicodeBidi
(
StyleUnicodeBidi
:
:
Normal
)
mInitialLetterSink
(
0
)
mInitialLetterSize
(
0
.
0f
)
mTextDecorationColor
(
StyleColor
:
:
CurrentColor
(
)
)
mTextDecorationThickness
(
StyleTextDecorationLength
:
:
Auto
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleTextReset
)
;
}
nsStyleTextReset
:
:
nsStyleTextReset
(
const
nsStyleTextReset
&
aSource
)
:
mTextOverflow
(
aSource
.
mTextOverflow
)
mTextDecorationLine
(
aSource
.
mTextDecorationLine
)
mTextDecorationStyle
(
aSource
.
mTextDecorationStyle
)
mUnicodeBidi
(
aSource
.
mUnicodeBidi
)
mInitialLetterSink
(
aSource
.
mInitialLetterSink
)
mInitialLetterSize
(
aSource
.
mInitialLetterSize
)
mTextDecorationColor
(
aSource
.
mTextDecorationColor
)
mTextDecorationThickness
(
aSource
.
mTextDecorationThickness
)
{
MOZ_COUNT_CTOR
(
nsStyleTextReset
)
;
}
nsStyleTextReset
:
:
~
nsStyleTextReset
(
)
{
MOZ_COUNT_DTOR
(
nsStyleTextReset
)
;
}
nsChangeHint
nsStyleTextReset
:
:
CalcDifference
(
const
nsStyleTextReset
&
aNewData
)
const
{
if
(
mUnicodeBidi
!
=
aNewData
.
mUnicodeBidi
|
|
mInitialLetterSink
!
=
aNewData
.
mInitialLetterSink
|
|
mInitialLetterSize
!
=
aNewData
.
mInitialLetterSize
)
{
return
NS_STYLE_HINT_REFLOW
;
}
if
(
mTextDecorationLine
!
=
aNewData
.
mTextDecorationLine
|
|
mTextDecorationStyle
!
=
aNewData
.
mTextDecorationStyle
|
|
mTextDecorationThickness
!
=
aNewData
.
mTextDecorationThickness
)
{
return
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateSubtreeOverflow
|
nsChangeHint_SchedulePaint
;
}
if
(
mTextDecorationColor
!
=
aNewData
.
mTextDecorationColor
)
{
return
nsChangeHint_RepaintFrame
;
}
if
(
mTextOverflow
!
=
aNewData
.
mTextOverflow
)
{
return
nsChangeHint_RepaintFrame
;
}
return
nsChangeHint
(
0
)
;
}
static
StyleRGBA
DefaultColor
(
const
Document
&
aDocument
)
{
return
StyleRGBA
:
:
FromColor
(
PreferenceSheet
:
:
PrefsFor
(
aDocument
)
.
ColorsFor
(
aDocument
.
DefaultColorScheme
(
)
)
.
mDefault
)
;
}
nsStyleText
:
:
nsStyleText
(
const
Document
&
aDocument
)
:
mColor
(
DefaultColor
(
aDocument
)
)
mTextTransform
(
StyleTextTransform
:
:
None
(
)
)
mTextAlign
(
StyleTextAlign
:
:
Start
)
mTextAlignLast
(
StyleTextAlignLast
:
:
Auto
)
mTextJustify
(
StyleTextJustify
:
:
Auto
)
mWhiteSpace
(
StyleWhiteSpace
:
:
Normal
)
mHyphens
(
StyleHyphens
:
:
Manual
)
mRubyAlign
(
StyleRubyAlign
:
:
SpaceAround
)
mRubyPosition
(
StyleRubyPosition
:
:
AlternateOver
)
mTextSizeAdjust
(
StyleTextSizeAdjust
:
:
Auto
)
mTextCombineUpright
(
StyleTextCombineUpright
:
:
None
)
mMozControlCharacterVisibility
(
StaticPrefs
:
:
layout_css_control_characters_visible
(
)
?
StyleMozControlCharacterVisibility
:
:
Visible
:
StyleMozControlCharacterVisibility
:
:
Hidden
)
mTextRendering
(
StyleTextRendering
:
:
Auto
)
mTextEmphasisColor
(
StyleColor
:
:
CurrentColor
(
)
)
mWebkitTextFillColor
(
StyleColor
:
:
CurrentColor
(
)
)
mWebkitTextStrokeColor
(
StyleColor
:
:
CurrentColor
(
)
)
mTabSize
(
StyleNonNegativeLengthOrNumber
:
:
Number
(
8
.
f
)
)
mWordSpacing
(
LengthPercentage
:
:
Zero
(
)
)
mLetterSpacing
(
{
0
.
}
)
mLineHeight
(
StyleLineHeight
:
:
Normal
(
)
)
mTextIndent
(
LengthPercentage
:
:
Zero
(
)
)
mTextUnderlineOffset
(
LengthPercentageOrAuto
:
:
Auto
(
)
)
mTextDecorationSkipInk
(
StyleTextDecorationSkipInk
:
:
Auto
)
mTextUnderlinePosition
(
StyleTextUnderlinePosition
:
:
AUTO
)
mWebkitTextStrokeWidth
(
0
)
mTextEmphasisStyle
(
StyleTextEmphasisStyle
:
:
None
(
)
)
{
MOZ_COUNT_CTOR
(
nsStyleText
)
;
RefPtr
<
nsAtom
>
language
=
aDocument
.
GetContentLanguageAsAtomForStyle
(
)
;
mTextEmphasisPosition
=
language
&
&
nsStyleUtil
:
:
MatchesLanguagePrefix
(
language
u
"
zh
"
)
?
StyleTextEmphasisPosition
:
:
UNDER
:
StyleTextEmphasisPosition
:
:
OVER
;
}
nsStyleText
:
:
nsStyleText
(
const
nsStyleText
&
aSource
)
:
mColor
(
aSource
.
mColor
)
mTextTransform
(
aSource
.
mTextTransform
)
mTextAlign
(
aSource
.
mTextAlign
)
mTextAlignLast
(
aSource
.
mTextAlignLast
)
mTextJustify
(
aSource
.
mTextJustify
)
mWhiteSpace
(
aSource
.
mWhiteSpace
)
mLineBreak
(
aSource
.
mLineBreak
)
mWordBreak
(
aSource
.
mWordBreak
)
mOverflowWrap
(
aSource
.
mOverflowWrap
)
mHyphens
(
aSource
.
mHyphens
)
mRubyAlign
(
aSource
.
mRubyAlign
)
mRubyPosition
(
aSource
.
mRubyPosition
)
mTextSizeAdjust
(
aSource
.
mTextSizeAdjust
)
mTextCombineUpright
(
aSource
.
mTextCombineUpright
)
mMozControlCharacterVisibility
(
aSource
.
mMozControlCharacterVisibility
)
mTextEmphasisPosition
(
aSource
.
mTextEmphasisPosition
)
mTextRendering
(
aSource
.
mTextRendering
)
mTextEmphasisColor
(
aSource
.
mTextEmphasisColor
)
mWebkitTextFillColor
(
aSource
.
mWebkitTextFillColor
)
mWebkitTextStrokeColor
(
aSource
.
mWebkitTextStrokeColor
)
mTabSize
(
aSource
.
mTabSize
)
mWordSpacing
(
aSource
.
mWordSpacing
)
mLetterSpacing
(
aSource
.
mLetterSpacing
)
mLineHeight
(
aSource
.
mLineHeight
)
mTextIndent
(
aSource
.
mTextIndent
)
mTextUnderlineOffset
(
aSource
.
mTextUnderlineOffset
)
mTextDecorationSkipInk
(
aSource
.
mTextDecorationSkipInk
)
mTextUnderlinePosition
(
aSource
.
mTextUnderlinePosition
)
mWebkitTextStrokeWidth
(
aSource
.
mWebkitTextStrokeWidth
)
mTextShadow
(
aSource
.
mTextShadow
)
mTextEmphasisStyle
(
aSource
.
mTextEmphasisStyle
)
mHyphenateCharacter
(
aSource
.
mHyphenateCharacter
)
{
MOZ_COUNT_CTOR
(
nsStyleText
)
;
}
nsStyleText
:
:
~
nsStyleText
(
)
{
MOZ_COUNT_DTOR
(
nsStyleText
)
;
}
nsChangeHint
nsStyleText
:
:
CalcDifference
(
const
nsStyleText
&
aNewData
)
const
{
if
(
WhiteSpaceOrNewlineIsSignificant
(
)
!
=
aNewData
.
WhiteSpaceOrNewlineIsSignificant
(
)
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
mTextCombineUpright
!
=
aNewData
.
mTextCombineUpright
|
|
mMozControlCharacterVisibility
!
=
aNewData
.
mMozControlCharacterVisibility
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
(
mTextAlign
!
=
aNewData
.
mTextAlign
)
|
|
(
mTextAlignLast
!
=
aNewData
.
mTextAlignLast
)
|
|
(
mTextTransform
!
=
aNewData
.
mTextTransform
)
|
|
(
mWhiteSpace
!
=
aNewData
.
mWhiteSpace
)
|
|
(
mLineBreak
!
=
aNewData
.
mLineBreak
)
|
|
(
mWordBreak
!
=
aNewData
.
mWordBreak
)
|
|
(
mOverflowWrap
!
=
aNewData
.
mOverflowWrap
)
|
|
(
mHyphens
!
=
aNewData
.
mHyphens
)
|
|
(
mRubyAlign
!
=
aNewData
.
mRubyAlign
)
|
|
(
mRubyPosition
!
=
aNewData
.
mRubyPosition
)
|
|
(
mTextSizeAdjust
!
=
aNewData
.
mTextSizeAdjust
)
|
|
(
mLetterSpacing
!
=
aNewData
.
mLetterSpacing
)
|
|
(
mLineHeight
!
=
aNewData
.
mLineHeight
)
|
|
(
mTextIndent
!
=
aNewData
.
mTextIndent
)
|
|
(
mTextJustify
!
=
aNewData
.
mTextJustify
)
|
|
(
mWordSpacing
!
=
aNewData
.
mWordSpacing
)
|
|
(
mTabSize
!
=
aNewData
.
mTabSize
)
|
|
(
mHyphenateCharacter
!
=
aNewData
.
mHyphenateCharacter
)
)
{
return
NS_STYLE_HINT_REFLOW
;
}
if
(
HasEffectiveTextEmphasis
(
)
!
=
aNewData
.
HasEffectiveTextEmphasis
(
)
|
|
(
HasEffectiveTextEmphasis
(
)
&
&
mTextEmphasisPosition
!
=
aNewData
.
mTextEmphasisPosition
)
)
{
return
nsChangeHint_AllReflowHints
|
nsChangeHint_RepaintFrame
;
}
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mTextRendering
!
=
aNewData
.
mTextRendering
)
{
hint
|
=
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
|
nsChangeHint_RepaintFrame
;
}
if
(
mTextShadow
!
=
aNewData
.
mTextShadow
|
|
mTextEmphasisStyle
!
=
aNewData
.
mTextEmphasisStyle
|
|
mWebkitTextStrokeWidth
!
=
aNewData
.
mWebkitTextStrokeWidth
|
|
mTextUnderlineOffset
!
=
aNewData
.
mTextUnderlineOffset
|
|
mTextDecorationSkipInk
!
=
aNewData
.
mTextDecorationSkipInk
|
|
mTextUnderlinePosition
!
=
aNewData
.
mTextUnderlinePosition
)
{
hint
|
=
nsChangeHint_UpdateSubtreeOverflow
|
nsChangeHint_SchedulePaint
|
nsChangeHint_RepaintFrame
;
return
hint
;
}
if
(
mColor
!
=
aNewData
.
mColor
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mTextEmphasisColor
!
=
aNewData
.
mTextEmphasisColor
|
|
mWebkitTextFillColor
!
=
aNewData
.
mWebkitTextFillColor
|
|
mWebkitTextStrokeColor
!
=
aNewData
.
mWebkitTextStrokeColor
)
{
hint
|
=
nsChangeHint_SchedulePaint
|
nsChangeHint_RepaintFrame
;
}
if
(
hint
)
{
return
hint
;
}
if
(
mTextEmphasisPosition
!
=
aNewData
.
mTextEmphasisPosition
)
{
return
nsChangeHint_NeutralChange
;
}
return
nsChangeHint
(
0
)
;
}
LogicalSide
nsStyleText
:
:
TextEmphasisSide
(
WritingMode
aWM
)
const
{
bool
noLeftBit
=
!
(
mTextEmphasisPosition
&
StyleTextEmphasisPosition
:
:
LEFT
)
;
DebugOnly
<
bool
>
noRightBit
=
!
(
mTextEmphasisPosition
&
StyleTextEmphasisPosition
:
:
RIGHT
)
;
bool
noOverBit
=
!
(
mTextEmphasisPosition
&
StyleTextEmphasisPosition
:
:
OVER
)
;
DebugOnly
<
bool
>
noUnderBit
=
!
(
mTextEmphasisPosition
&
StyleTextEmphasisPosition
:
:
UNDER
)
;
MOZ_ASSERT
(
(
noOverBit
!
=
noUnderBit
)
&
&
(
(
noLeftBit
!
=
noRightBit
)
|
|
noRightBit
)
)
;
mozilla
:
:
Side
side
=
aWM
.
IsVertical
(
)
?
(
noLeftBit
?
eSideRight
:
eSideLeft
)
:
(
noOverBit
?
eSideBottom
:
eSideTop
)
;
LogicalSide
result
=
aWM
.
LogicalSideForPhysicalSide
(
side
)
;
MOZ_ASSERT
(
IsBlock
(
result
)
)
;
return
result
;
}
nsStyleUI
:
:
nsStyleUI
(
const
Document
&
aDocument
)
:
mInert
(
StyleInert
:
:
None
)
mUserInput
(
StyleUserInput
:
:
Auto
)
mUserModify
(
StyleUserModify
:
:
ReadOnly
)
mUserFocus
(
StyleUserFocus
:
:
None
)
mPointerEvents
(
StylePointerEvents
:
:
Auto
)
mCursor
{
{
}
StyleCursorKind
:
:
Auto
}
mAccentColor
(
StyleColorOrAuto
:
:
Auto
(
)
)
mCaretColor
(
StyleColorOrAuto
:
:
Auto
(
)
)
mScrollbarColor
(
StyleScrollbarColor
:
:
Auto
(
)
)
mColorScheme
(
StyleColorScheme
{
{
}
{
}
}
)
{
MOZ_COUNT_CTOR
(
nsStyleUI
)
;
}
nsStyleUI
:
:
nsStyleUI
(
const
nsStyleUI
&
aSource
)
:
mInert
(
aSource
.
mInert
)
mUserInput
(
aSource
.
mUserInput
)
mUserModify
(
aSource
.
mUserModify
)
mUserFocus
(
aSource
.
mUserFocus
)
mPointerEvents
(
aSource
.
mPointerEvents
)
mCursor
(
aSource
.
mCursor
)
mAccentColor
(
aSource
.
mAccentColor
)
mCaretColor
(
aSource
.
mCaretColor
)
mScrollbarColor
(
aSource
.
mScrollbarColor
)
mColorScheme
(
aSource
.
mColorScheme
)
{
MOZ_COUNT_CTOR
(
nsStyleUI
)
;
}
nsStyleUI
:
:
~
nsStyleUI
(
)
{
MOZ_COUNT_DTOR
(
nsStyleUI
)
;
}
void
nsStyleUI
:
:
TriggerImageLoads
(
Document
&
aDocument
const
nsStyleUI
*
aOldStyle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
cursorImages
=
mCursor
.
images
.
AsSpan
(
)
;
auto
oldCursorImages
=
aOldStyle
?
aOldStyle
-
>
mCursor
.
images
.
AsSpan
(
)
:
Span
<
const
StyleCursorImage
>
(
)
;
for
(
size_t
i
=
0
;
i
<
cursorImages
.
Length
(
)
;
+
+
i
)
{
auto
&
cursor
=
cursorImages
[
i
]
;
const
auto
*
oldCursorImage
=
oldCursorImages
.
Length
(
)
>
i
?
&
oldCursorImages
[
i
]
.
image
:
nullptr
;
const_cast
<
StyleCursorImage
&
>
(
cursor
)
.
image
.
ResolveImage
(
aDocument
oldCursorImage
)
;
}
}
nsChangeHint
nsStyleUI
:
:
CalcDifference
(
const
nsStyleUI
&
aNewData
)
const
{
const
auto
kPointerEventsHint
=
nsChangeHint_NeedReflow
|
nsChangeHint_NeedDirtyReflow
|
nsChangeHint_SchedulePaint
;
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mCursor
!
=
aNewData
.
mCursor
)
{
hint
|
=
nsChangeHint_UpdateCursor
;
}
if
(
mPointerEvents
!
=
aNewData
.
mPointerEvents
)
{
hint
|
=
kPointerEventsHint
;
}
if
(
mUserModify
!
=
aNewData
.
mUserModify
)
{
hint
|
=
NS_STYLE_HINT_VISUAL
;
}
if
(
mInert
!
=
aNewData
.
mInert
)
{
hint
|
=
NS_STYLE_HINT_VISUAL
|
kPointerEventsHint
;
}
if
(
mUserFocus
!
=
aNewData
.
mUserFocus
|
|
mUserInput
!
=
aNewData
.
mUserInput
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
if
(
mCaretColor
!
=
aNewData
.
mCaretColor
|
|
mAccentColor
!
=
aNewData
.
mAccentColor
|
|
mScrollbarColor
!
=
aNewData
.
mScrollbarColor
|
|
mColorScheme
!
=
aNewData
.
mColorScheme
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
return
hint
;
}
nsStyleUIReset
:
:
nsStyleUIReset
(
const
Document
&
aDocument
)
:
mUserSelect
(
StyleUserSelect
:
:
Auto
)
mScrollbarWidth
(
StyleScrollbarWidth
:
:
Auto
)
mMozForceBrokenImageIcon
(
false
)
mMozSubtreeHiddenOnlyVisually
(
false
)
mIMEMode
(
StyleImeMode
:
:
Auto
)
mWindowDragging
(
StyleWindowDragging
:
:
Default
)
mWindowShadow
(
StyleWindowShadow
:
:
Default
)
mWindowOpacity
(
1
.
0
)
mMozWindowInputRegionMargin
(
StyleLength
:
:
Zero
(
)
)
mWindowTransformOrigin
{
LengthPercentage
:
:
FromPercentage
(
0
.
5
)
LengthPercentage
:
:
FromPercentage
(
0
.
5
)
{
0
.
}
}
mTransitions
(
nsStyleAutoArray
<
StyleTransition
>
:
:
WITH_SINGLE_INITIAL_ELEMENT
)
mTransitionTimingFunctionCount
(
1
)
mTransitionDurationCount
(
1
)
mTransitionDelayCount
(
1
)
mTransitionPropertyCount
(
1
)
mAnimations
(
nsStyleAutoArray
<
StyleAnimation
>
:
:
WITH_SINGLE_INITIAL_ELEMENT
)
mAnimationTimingFunctionCount
(
1
)
mAnimationDurationCount
(
1
)
mAnimationDelayCount
(
1
)
mAnimationNameCount
(
1
)
mAnimationDirectionCount
(
1
)
mAnimationFillModeCount
(
1
)
mAnimationPlayStateCount
(
1
)
mAnimationIterationCountCount
(
1
)
mAnimationCompositionCount
(
1
)
mAnimationTimelineCount
(
1
)
mScrollTimelineAxis
(
StyleScrollAxis
:
:
Block
)
{
MOZ_COUNT_CTOR
(
nsStyleUIReset
)
;
mTransitions
[
0
]
.
SetInitialValues
(
)
;
mAnimations
[
0
]
.
SetInitialValues
(
)
;
}
nsStyleUIReset
:
:
nsStyleUIReset
(
const
nsStyleUIReset
&
aSource
)
:
mUserSelect
(
aSource
.
mUserSelect
)
mScrollbarWidth
(
aSource
.
mScrollbarWidth
)
mMozForceBrokenImageIcon
(
aSource
.
mMozForceBrokenImageIcon
)
mMozSubtreeHiddenOnlyVisually
(
aSource
.
mMozSubtreeHiddenOnlyVisually
)
mIMEMode
(
aSource
.
mIMEMode
)
mWindowDragging
(
aSource
.
mWindowDragging
)
mWindowShadow
(
aSource
.
mWindowShadow
)
mWindowOpacity
(
aSource
.
mWindowOpacity
)
mMozWindowInputRegionMargin
(
aSource
.
mMozWindowInputRegionMargin
)
mMozWindowTransform
(
aSource
.
mMozWindowTransform
)
mWindowTransformOrigin
(
aSource
.
mWindowTransformOrigin
)
mTransitions
(
aSource
.
mTransitions
.
Clone
(
)
)
mTransitionTimingFunctionCount
(
aSource
.
mTransitionTimingFunctionCount
)
mTransitionDurationCount
(
aSource
.
mTransitionDurationCount
)
mTransitionDelayCount
(
aSource
.
mTransitionDelayCount
)
mTransitionPropertyCount
(
aSource
.
mTransitionPropertyCount
)
mAnimations
(
aSource
.
mAnimations
.
Clone
(
)
)
mAnimationTimingFunctionCount
(
aSource
.
mAnimationTimingFunctionCount
)
mAnimationDurationCount
(
aSource
.
mAnimationDurationCount
)
mAnimationDelayCount
(
aSource
.
mAnimationDelayCount
)
mAnimationNameCount
(
aSource
.
mAnimationNameCount
)
mAnimationDirectionCount
(
aSource
.
mAnimationDirectionCount
)
mAnimationFillModeCount
(
aSource
.
mAnimationFillModeCount
)
mAnimationPlayStateCount
(
aSource
.
mAnimationPlayStateCount
)
mAnimationIterationCountCount
(
aSource
.
mAnimationIterationCountCount
)
mAnimationCompositionCount
(
aSource
.
mAnimationCompositionCount
)
mAnimationTimelineCount
(
aSource
.
mAnimationTimelineCount
)
mScrollTimelineName
(
aSource
.
mScrollTimelineName
)
mScrollTimelineAxis
(
aSource
.
mScrollTimelineAxis
)
{
MOZ_COUNT_CTOR
(
nsStyleUIReset
)
;
}
nsStyleUIReset
:
:
~
nsStyleUIReset
(
)
{
MOZ_COUNT_DTOR
(
nsStyleUIReset
)
;
}
nsChangeHint
nsStyleUIReset
:
:
CalcDifference
(
const
nsStyleUIReset
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mMozForceBrokenImageIcon
!
=
aNewData
.
mMozForceBrokenImageIcon
)
{
hint
|
=
nsChangeHint_ReconstructFrame
;
}
if
(
mMozSubtreeHiddenOnlyVisually
!
=
aNewData
.
mMozSubtreeHiddenOnlyVisually
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
mScrollbarWidth
!
=
aNewData
.
mScrollbarWidth
)
{
hint
|
=
nsChangeHint_ScrollbarChange
;
}
if
(
mWindowShadow
!
=
aNewData
.
mWindowShadow
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
if
(
mUserSelect
!
=
aNewData
.
mUserSelect
)
{
hint
|
=
NS_STYLE_HINT_VISUAL
;
}
if
(
mWindowDragging
!
=
aNewData
.
mWindowDragging
)
{
hint
|
=
nsChangeHint_SchedulePaint
;
}
if
(
!
hint
&
&
(
mTransitions
!
=
aNewData
.
mTransitions
|
|
mTransitionTimingFunctionCount
!
=
aNewData
.
mTransitionTimingFunctionCount
|
|
mTransitionDurationCount
!
=
aNewData
.
mTransitionDurationCount
|
|
mTransitionDelayCount
!
=
aNewData
.
mTransitionDelayCount
|
|
mTransitionPropertyCount
!
=
aNewData
.
mTransitionPropertyCount
|
|
mAnimations
!
=
aNewData
.
mAnimations
|
|
mAnimationTimingFunctionCount
!
=
aNewData
.
mAnimationTimingFunctionCount
|
|
mAnimationDurationCount
!
=
aNewData
.
mAnimationDurationCount
|
|
mAnimationDelayCount
!
=
aNewData
.
mAnimationDelayCount
|
|
mAnimationNameCount
!
=
aNewData
.
mAnimationNameCount
|
|
mAnimationDirectionCount
!
=
aNewData
.
mAnimationDirectionCount
|
|
mAnimationFillModeCount
!
=
aNewData
.
mAnimationFillModeCount
|
|
mAnimationPlayStateCount
!
=
aNewData
.
mAnimationPlayStateCount
|
|
mAnimationIterationCountCount
!
=
aNewData
.
mAnimationIterationCountCount
|
|
mAnimationCompositionCount
!
=
aNewData
.
mAnimationCompositionCount
|
|
mAnimationTimelineCount
!
=
aNewData
.
mAnimationTimelineCount
|
|
mIMEMode
!
=
aNewData
.
mIMEMode
|
|
mWindowOpacity
!
=
aNewData
.
mWindowOpacity
|
|
mMozWindowInputRegionMargin
!
=
aNewData
.
mMozWindowInputRegionMargin
|
|
mMozWindowTransform
!
=
aNewData
.
mMozWindowTransform
|
|
mScrollTimelineName
!
=
aNewData
.
mScrollTimelineName
|
|
mScrollTimelineAxis
!
=
aNewData
.
mScrollTimelineAxis
)
)
{
hint
|
=
nsChangeHint_NeutralChange
;
}
return
hint
;
}
StyleScrollbarWidth
nsStyleUIReset
:
:
ScrollbarWidth
(
)
const
{
if
(
MOZ_UNLIKELY
(
StaticPrefs
:
:
layout_css_scrollbar_width_thin_disabled
(
)
)
)
{
if
(
mScrollbarWidth
=
=
StyleScrollbarWidth
:
:
Thin
)
{
return
StyleScrollbarWidth
:
:
Auto
;
}
}
return
mScrollbarWidth
;
}
nsStyleEffects
:
:
nsStyleEffects
(
const
Document
&
)
:
mClip
(
StyleClipRectOrAuto
:
:
Auto
(
)
)
mOpacity
(
1
.
0f
)
mMixBlendMode
(
StyleBlend
:
:
Normal
)
{
MOZ_COUNT_CTOR
(
nsStyleEffects
)
;
}
nsStyleEffects
:
:
nsStyleEffects
(
const
nsStyleEffects
&
aSource
)
:
mFilters
(
aSource
.
mFilters
)
mBoxShadow
(
aSource
.
mBoxShadow
)
mBackdropFilters
(
aSource
.
mBackdropFilters
)
mClip
(
aSource
.
mClip
)
mOpacity
(
aSource
.
mOpacity
)
mMixBlendMode
(
aSource
.
mMixBlendMode
)
{
MOZ_COUNT_CTOR
(
nsStyleEffects
)
;
}
nsStyleEffects
:
:
~
nsStyleEffects
(
)
{
MOZ_COUNT_DTOR
(
nsStyleEffects
)
;
}
static
bool
AnyAutonessChanged
(
const
StyleClipRectOrAuto
&
aOld
const
StyleClipRectOrAuto
&
aNew
)
{
if
(
aOld
.
IsAuto
(
)
!
=
aNew
.
IsAuto
(
)
)
{
return
true
;
}
if
(
aOld
.
IsAuto
(
)
)
{
return
false
;
}
auto
&
oldRect
=
aOld
.
AsRect
(
)
;
auto
&
newRect
=
aNew
.
AsRect
(
)
;
return
oldRect
.
top
.
IsAuto
(
)
!
=
newRect
.
top
.
IsAuto
(
)
|
|
oldRect
.
right
.
IsAuto
(
)
!
=
newRect
.
right
.
IsAuto
(
)
|
|
oldRect
.
bottom
.
IsAuto
(
)
!
=
newRect
.
bottom
.
IsAuto
(
)
|
|
oldRect
.
left
.
IsAuto
(
)
!
=
newRect
.
left
.
IsAuto
(
)
;
}
nsChangeHint
nsStyleEffects
:
:
CalcDifference
(
const
nsStyleEffects
&
aNewData
)
const
{
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mBoxShadow
!
=
aNewData
.
mBoxShadow
)
{
hint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_SchedulePaint
|
nsChangeHint_RepaintFrame
;
}
if
(
AnyAutonessChanged
(
mClip
aNewData
.
mClip
)
)
{
hint
|
=
nsChangeHint_AllReflowHints
|
nsChangeHint_RepaintFrame
;
}
else
if
(
mClip
!
=
aNewData
.
mClip
)
{
hint
|
=
nsChangeHint_UpdateOverflow
|
nsChangeHint_SchedulePaint
;
}
if
(
mOpacity
!
=
aNewData
.
mOpacity
)
{
hint
|
=
nsChangeHint_UpdateOpacityLayer
;
if
(
(
mOpacity
>
=
0
.
99f
&
&
mOpacity
<
1
.
0f
&
&
aNewData
.
mOpacity
=
=
1
.
0f
)
|
|
(
aNewData
.
mOpacity
>
=
0
.
99f
&
&
aNewData
.
mOpacity
<
1
.
0f
&
&
mOpacity
=
=
1
.
0f
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
else
{
if
(
(
mOpacity
=
=
1
.
0f
)
!
=
(
aNewData
.
mOpacity
=
=
1
.
0f
)
)
{
hint
|
=
nsChangeHint_UpdateUsesOpacity
;
}
}
}
if
(
HasFilters
(
)
!
=
aNewData
.
HasFilters
(
)
)
{
hint
|
=
nsChangeHint_UpdateContainingBlock
;
}
if
(
mFilters
!
=
aNewData
.
mFilters
)
{
hint
|
=
nsChangeHint_UpdateEffects
|
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateOverflow
;
}
if
(
mMixBlendMode
!
=
aNewData
.
mMixBlendMode
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
HasBackdropFilters
(
)
!
=
aNewData
.
HasBackdropFilters
(
)
)
{
hint
|
=
nsChangeHint_UpdateContainingBlock
;
}
if
(
mBackdropFilters
!
=
aNewData
.
mBackdropFilters
)
{
hint
|
=
nsChangeHint_UpdateEffects
|
nsChangeHint_RepaintFrame
;
}
return
hint
;
}
static
bool
TransformOperationHasPercent
(
const
StyleTransformOperation
&
aOp
)
{
switch
(
aOp
.
tag
)
{
case
StyleTransformOperation
:
:
Tag
:
:
TranslateX
:
return
aOp
.
AsTranslateX
(
)
.
HasPercent
(
)
;
case
StyleTransformOperation
:
:
Tag
:
:
TranslateY
:
return
aOp
.
AsTranslateY
(
)
.
HasPercent
(
)
;
case
StyleTransformOperation
:
:
Tag
:
:
TranslateZ
:
return
false
;
case
StyleTransformOperation
:
:
Tag
:
:
Translate3D
:
{
auto
&
translate
=
aOp
.
AsTranslate3D
(
)
;
return
translate
.
_0
.
HasPercent
(
)
|
|
translate
.
_1
.
HasPercent
(
)
;
}
case
StyleTransformOperation
:
:
Tag
:
:
Translate
:
{
auto
&
translate
=
aOp
.
AsTranslate
(
)
;
return
translate
.
_0
.
HasPercent
(
)
|
|
translate
.
_1
.
HasPercent
(
)
;
}
case
StyleTransformOperation
:
:
Tag
:
:
AccumulateMatrix
:
{
auto
&
accum
=
aOp
.
AsAccumulateMatrix
(
)
;
return
accum
.
from_list
.
HasPercent
(
)
|
|
accum
.
to_list
.
HasPercent
(
)
;
}
case
StyleTransformOperation
:
:
Tag
:
:
InterpolateMatrix
:
{
auto
&
interpolate
=
aOp
.
AsInterpolateMatrix
(
)
;
return
interpolate
.
from_list
.
HasPercent
(
)
|
|
interpolate
.
to_list
.
HasPercent
(
)
;
}
case
StyleTransformOperation
:
:
Tag
:
:
Perspective
:
case
StyleTransformOperation
:
:
Tag
:
:
RotateX
:
case
StyleTransformOperation
:
:
Tag
:
:
RotateY
:
case
StyleTransformOperation
:
:
Tag
:
:
RotateZ
:
case
StyleTransformOperation
:
:
Tag
:
:
Rotate
:
case
StyleTransformOperation
:
:
Tag
:
:
Rotate3D
:
case
StyleTransformOperation
:
:
Tag
:
:
SkewX
:
case
StyleTransformOperation
:
:
Tag
:
:
SkewY
:
case
StyleTransformOperation
:
:
Tag
:
:
Skew
:
case
StyleTransformOperation
:
:
Tag
:
:
ScaleX
:
case
StyleTransformOperation
:
:
Tag
:
:
ScaleY
:
case
StyleTransformOperation
:
:
Tag
:
:
ScaleZ
:
case
StyleTransformOperation
:
:
Tag
:
:
Scale
:
case
StyleTransformOperation
:
:
Tag
:
:
Scale3D
:
case
StyleTransformOperation
:
:
Tag
:
:
Matrix
:
case
StyleTransformOperation
:
:
Tag
:
:
Matrix3D
:
return
false
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
transform
operation
"
)
;
return
false
;
}
}
template
<
>
bool
StyleTransform
:
:
HasPercent
(
)
const
{
for
(
const
auto
&
op
:
Operations
(
)
)
{
if
(
TransformOperationHasPercent
(
op
)
)
{
return
true
;
}
}
return
false
;
}
template
<
>
void
StyleCalcNode
:
:
ScaleLengthsBy
(
float
aScale
)
{
auto
ScaleNode
=
[
aScale
]
(
const
StyleCalcNode
&
aNode
)
{
const_cast
<
StyleCalcNode
&
>
(
aNode
)
.
ScaleLengthsBy
(
aScale
)
;
}
;
switch
(
tag
)
{
case
Tag
:
:
Leaf
:
{
auto
&
leaf
=
AsLeaf
(
)
;
if
(
leaf
.
IsLength
(
)
)
{
const_cast
<
Length
&
>
(
leaf
.
AsLength
(
)
)
.
ScaleBy
(
aScale
)
;
}
break
;
}
case
Tag
:
:
Clamp
:
{
auto
&
clamp
=
AsClamp
(
)
;
ScaleNode
(
*
clamp
.
min
)
;
ScaleNode
(
*
clamp
.
center
)
;
ScaleNode
(
*
clamp
.
max
)
;
break
;
}
case
Tag
:
:
Round
:
{
const
auto
&
round
=
AsRound
(
)
;
ScaleNode
(
*
round
.
value
)
;
ScaleNode
(
*
round
.
step
)
;
break
;
}
case
Tag
:
:
ModRem
:
{
const
auto
&
mod_rem
=
AsModRem
(
)
;
ScaleNode
(
*
mod_rem
.
dividend
)
;
ScaleNode
(
*
mod_rem
.
divisor
)
;
break
;
}
case
Tag
:
:
MinMax
:
{
for
(
auto
&
child
:
AsMinMax
(
)
.
_0
.
AsSpan
(
)
)
{
ScaleNode
(
child
)
;
}
break
;
}
case
Tag
:
:
Sum
:
{
for
(
auto
&
child
:
AsSum
(
)
.
AsSpan
(
)
)
{
ScaleNode
(
child
)
;
}
break
;
}
}
}
template
<
>
template
<
typename
ResultT
typename
PercentageConverter
>
ResultT
StyleCalcNode
:
:
ResolveInternal
(
ResultT
aPercentageBasis
PercentageConverter
aConverter
)
const
{
static_assert
(
std
:
:
is_same_v
<
decltype
(
aConverter
(
1
.
0f
)
)
ResultT
>
)
;
static_assert
(
std
:
:
is_same_v
<
ResultT
nscoord
>
|
|
std
:
:
is_same_v
<
ResultT
CSSCoord
>
)
;
switch
(
tag
)
{
case
Tag
:
:
Leaf
:
{
auto
&
leaf
=
AsLeaf
(
)
;
if
(
leaf
.
IsPercentage
(
)
)
{
return
aConverter
(
leaf
.
AsPercentage
(
)
.
_0
*
aPercentageBasis
)
;
}
if
constexpr
(
std
:
:
is_same_v
<
ResultT
nscoord
>
)
{
return
leaf
.
AsLength
(
)
.
ToAppUnits
(
)
;
}
else
{
return
leaf
.
AsLength
(
)
.
ToCSSPixels
(
)
;
}
}
case
Tag
:
:
Clamp
:
{
auto
&
clamp
=
AsClamp
(
)
;
auto
min
=
clamp
.
min
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
;
auto
center
=
clamp
.
center
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
;
auto
max
=
clamp
.
max
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
;
return
std
:
:
max
(
min
std
:
:
min
(
center
max
)
)
;
}
case
Tag
:
:
Round
:
{
const
auto
&
round
=
AsRound
(
)
;
CSSCoord
step
value
;
if
constexpr
(
std
:
:
is_same_v
<
ResultT
CSSCoord
>
)
{
step
=
round
.
step
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
;
value
=
round
.
value
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
;
}
else
{
step
=
CSSPixel
:
:
FromAppUnits
(
round
.
step
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
)
;
value
=
CSSPixel
:
:
FromAppUnits
(
round
.
value
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
)
;
}
const
float
div
=
value
/
step
;
const
CSSCoord
lowerBound
=
std
:
:
floor
(
div
)
*
step
;
const
CSSCoord
upperBound
=
std
:
:
ceil
(
div
)
*
step
;
const
CSSCoord
result
=
[
&
]
{
switch
(
round
.
strategy
)
{
case
StyleRoundingStrategy
:
:
Nearest
:
if
(
value
-
lowerBound
<
upperBound
-
value
)
{
return
lowerBound
;
}
return
upperBound
;
case
StyleRoundingStrategy
:
:
Up
:
return
upperBound
;
case
StyleRoundingStrategy
:
:
Down
:
return
lowerBound
;
case
StyleRoundingStrategy
:
:
ToZero
:
return
std
:
:
abs
(
lowerBound
)
<
std
:
:
abs
(
upperBound
)
?
lowerBound
:
upperBound
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
rounding
strategy
"
)
;
return
CSSCoord
(
0
)
;
}
(
)
;
if
constexpr
(
std
:
:
is_same_v
<
ResultT
CSSCoord
>
)
{
return
result
;
}
else
{
return
CSSPixel
:
:
ToAppUnits
(
result
)
;
}
}
case
Tag
:
:
ModRem
:
{
const
auto
&
mod_rem
=
AsModRem
(
)
;
CSSCoord
dividend
divisor
;
if
constexpr
(
std
:
:
is_same_v
<
ResultT
CSSCoord
>
)
{
dividend
=
mod_rem
.
dividend
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
;
divisor
=
mod_rem
.
divisor
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
;
}
else
{
dividend
=
CSSPixel
:
:
FromAppUnits
(
mod_rem
.
dividend
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
)
;
divisor
=
CSSPixel
:
:
FromAppUnits
(
mod_rem
.
divisor
-
>
ResolveInternal
(
aPercentageBasis
aConverter
)
)
;
}
const
CSSCoord
result
=
mod_rem
.
op
=
=
StyleModRemOp
:
:
Mod
?
dividend
-
divisor
*
std
:
:
floor
(
dividend
/
divisor
)
:
dividend
-
divisor
*
std
:
:
trunc
(
dividend
/
divisor
)
;
if
constexpr
(
std
:
:
is_same_v
<
ResultT
CSSCoord
>
)
{
return
result
;
}
else
{
return
CSSPixel
:
:
ToAppUnits
(
result
)
;
}
}
case
Tag
:
:
MinMax
:
{
auto
children
=
AsMinMax
(
)
.
_0
.
AsSpan
(
)
;
StyleMinMaxOp
op
=
AsMinMax
(
)
.
_1
;
ResultT
result
=
children
[
0
]
.
ResolveInternal
(
aPercentageBasis
aConverter
)
;
for
(
auto
&
child
:
children
.
From
(
1
)
)
{
ResultT
candidate
=
child
.
ResolveInternal
(
aPercentageBasis
aConverter
)
;
if
(
op
=
=
StyleMinMaxOp
:
:
Max
)
{
result
=
std
:
:
max
(
result
candidate
)
;
}
else
{
result
=
std
:
:
min
(
result
candidate
)
;
}
}
return
result
;
}
case
Tag
:
:
Sum
:
{
ResultT
result
=
0
;
for
(
auto
&
child
:
AsSum
(
)
.
AsSpan
(
)
)
{
result
+
=
child
.
ResolveInternal
(
aPercentageBasis
aConverter
)
;
}
return
result
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
calc
node
"
)
;
return
0
;
}
template
<
>
CSSCoord
StyleCalcNode
:
:
ResolveToCSSPixels
(
CSSCoord
aBasis
)
const
{
CSSCoord
result
=
ResolveInternal
(
aBasis
[
]
(
CSSCoord
aPercent
)
{
return
aPercent
;
}
)
;
if
(
IsNaN
(
float
(
result
)
)
)
{
return
0
.
0f
;
}
return
result
;
}
template
<
>
nscoord
StyleCalcNode
:
:
Resolve
(
nscoord
aBasis
CoordPercentageRounder
aRounder
)
const
{
return
ResolveInternal
(
aBasis
aRounder
)
;
}
ContainSizeAxes
nsStyleDisplay
:
:
GetContainSizeAxes
(
const
nsIFrame
&
aFrame
)
const
{
if
(
MOZ_LIKELY
(
!
mEffectiveContainment
)
)
{
return
ContainSizeAxes
(
false
false
)
;
}
bool
isNonReplacedInline
=
aFrame
.
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
&
&
!
aFrame
.
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
;
if
(
isNonReplacedInline
|
|
PrecludesSizeContainment
(
)
)
{
return
ContainSizeAxes
(
false
false
)
;
}
if
(
aFrame
.
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
return
ContainSizeAxes
(
false
false
)
;
}
if
(
MOZ_LIKELY
(
!
(
mEffectiveContainment
&
StyleContain
:
:
SIZE
)
)
&
&
MOZ_UNLIKELY
(
aFrame
.
HidesContent
(
)
)
)
{
return
ContainSizeAxes
(
true
true
)
;
}
return
ContainSizeAxes
(
static_cast
<
bool
>
(
mEffectiveContainment
&
StyleContain
:
:
INLINE_SIZE
)
static_cast
<
bool
>
(
mEffectiveContainment
&
StyleContain
:
:
BLOCK_SIZE
)
)
;
}
static
nscoord
Resolve
(
const
StyleContainIntrinsicSize
&
aSize
nscoord
aNoneValue
const
nsIFrame
&
aFrame
LogicalAxis
aAxis
)
{
if
(
aSize
.
IsNone
(
)
)
{
return
aNoneValue
;
}
if
(
aSize
.
IsLength
(
)
)
{
return
aSize
.
AsLength
(
)
.
ToAppUnits
(
)
;
}
MOZ_ASSERT
(
aSize
.
IsAutoLength
(
)
)
;
if
(
const
auto
*
element
=
Element
:
:
FromNodeOrNull
(
aFrame
.
GetContent
(
)
)
)
{
Maybe
<
float
>
lastSize
=
aAxis
=
=
eLogicalAxisBlock
?
element
-
>
GetLastRememberedBSize
(
)
:
element
-
>
GetLastRememberedISize
(
)
;
if
(
lastSize
&
&
aFrame
.
HidesContent
(
)
)
{
return
CSSPixel
:
:
ToAppUnits
(
*
lastSize
)
;
}
}
return
aSize
.
AsAutoLength
(
)
.
ToAppUnits
(
)
;
}
Maybe
<
nscoord
>
ContainSizeAxes
:
:
ContainIntrinsicBSize
(
const
nsIFrame
&
aFrame
nscoord
aNoneValue
)
const
{
if
(
!
mBContained
)
{
return
Nothing
(
)
;
}
const
StyleContainIntrinsicSize
&
bSize
=
aFrame
.
StylePosition
(
)
-
>
ContainIntrinsicBSize
(
aFrame
.
GetWritingMode
(
)
)
;
return
Some
(
Resolve
(
bSize
aNoneValue
aFrame
eLogicalAxisBlock
)
)
;
}
Maybe
<
nscoord
>
ContainSizeAxes
:
:
ContainIntrinsicISize
(
const
nsIFrame
&
aFrame
nscoord
aNoneValue
)
const
{
if
(
!
mIContained
)
{
return
Nothing
(
)
;
}
const
StyleContainIntrinsicSize
&
iSize
=
aFrame
.
StylePosition
(
)
-
>
ContainIntrinsicISize
(
aFrame
.
GetWritingMode
(
)
)
;
return
Some
(
Resolve
(
iSize
aNoneValue
aFrame
eLogicalAxisInline
)
)
;
}
nsSize
ContainSizeAxes
:
:
ContainSize
(
const
nsSize
&
aUncontainedSize
const
nsIFrame
&
aFrame
)
const
{
if
(
!
IsAny
(
)
)
{
return
aUncontainedSize
;
}
if
(
aFrame
.
GetWritingMode
(
)
.
IsVertical
(
)
)
{
return
nsSize
(
ContainIntrinsicBSize
(
aFrame
)
.
valueOr
(
aUncontainedSize
.
Width
(
)
)
ContainIntrinsicISize
(
aFrame
)
.
valueOr
(
aUncontainedSize
.
Height
(
)
)
)
;
}
return
nsSize
(
ContainIntrinsicISize
(
aFrame
)
.
valueOr
(
aUncontainedSize
.
Width
(
)
)
ContainIntrinsicBSize
(
aFrame
)
.
valueOr
(
aUncontainedSize
.
Height
(
)
)
)
;
}
IntrinsicSize
ContainSizeAxes
:
:
ContainIntrinsicSize
(
const
IntrinsicSize
&
aUncontainedSize
const
nsIFrame
&
aFrame
)
const
{
if
(
!
IsAny
(
)
)
{
return
aUncontainedSize
;
}
IntrinsicSize
result
(
aUncontainedSize
)
;
const
bool
isVerticalWM
=
aFrame
.
GetWritingMode
(
)
.
IsVertical
(
)
;
if
(
Maybe
<
nscoord
>
containBSize
=
ContainIntrinsicBSize
(
aFrame
)
)
{
(
isVerticalWM
?
result
.
width
:
result
.
height
)
=
containBSize
;
}
if
(
Maybe
<
nscoord
>
containISize
=
ContainIntrinsicISize
(
aFrame
)
)
{
(
isVerticalWM
?
result
.
height
:
result
.
width
)
=
containISize
;
}
return
result
;
}
