#
ifndef
mozilla_ServoStyleConsts_h
#
error
"
This
file
is
only
meant
to
be
included
from
ServoStyleConsts
.
h
"
#
endif
#
ifndef
mozilla_ServoStyleConstsForwards_h
#
define
mozilla_ServoStyleConstsForwards_h
#
include
"
nsColor
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
mozilla
/
AtomArray
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ServoTypes
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsIURI
.
h
"
#
include
<
atomic
>
struct
RawServoAnimationValueTable
;
struct
RawServoAnimationValueMap
;
class
nsAtom
;
class
nsIFrame
;
class
nsINode
;
class
nsIContent
;
class
nsCSSPropertyIDSet
;
class
nsPresContext
;
class
nsSimpleContentList
;
class
imgRequestProxy
;
struct
nsCSSValueSharedList
;
struct
nsTimingFunction
;
class
gfxFontFeatureValueSet
;
struct
gfxFontFeature
;
namespace
mozilla
{
namespace
gfx
{
struct
FontVariation
;
}
}
typedef
mozilla
:
:
gfx
:
:
FontVariation
gfxFontVariation
;
enum
nsCSSUnit
:
uint32_t
;
enum
nsChangeHint
:
uint32_t
;
namespace
nsStyleTransformMatrix
{
enum
class
MatrixTransformOperator
:
uint8_t
;
}
template
<
typename
T
>
class
nsMainThreadPtrHolder
;
namespace
mozilla
{
class
ComputedStyle
;
using
Matrix4x4Components
=
float
[
16
]
;
using
StyleMatrix4x4Components
=
Matrix4x4Components
;
using
StyleNonZeroUsize
=
uintptr_t
;
struct
Keyframe
;
struct
PropertyStyleAnimationValuePair
;
using
ComputedKeyframeValues
=
nsTArray
<
PropertyStyleAnimationValuePair
>
;
class
ComputedStyle
;
class
SeenPtrs
;
class
SharedFontList
;
class
StyleSheet
;
class
WritingMode
;
class
ServoElementSnapshotTable
;
enum
class
StyleContentType
:
uint8_t
;
template
<
typename
T
>
struct
StyleForgottenArcSlicePtr
;
struct
AnimationPropertySegment
;
struct
ComputedTiming
;
struct
URLExtraData
;
enum
HalfCorner
:
uint8_t
;
enum
LogicalSide
:
uint8_t
;
enum
class
PseudoStyleType
:
uint8_t
;
enum
class
OriginFlags
:
uint8_t
;
namespace
css
{
class
Loader
;
class
LoaderReusableStyleSheets
;
class
SheetLoadData
;
using
SheetLoadDataHolder
=
nsMainThreadPtrHolder
<
SheetLoadData
>
;
enum
SheetParsingMode
:
uint8_t
;
}
namespace
dom
{
enum
class
IterationCompositeOperation
:
uint8_t
;
enum
class
CallerType
:
uint32_t
;
class
Element
;
class
Document
;
}
template
<
typename
T
>
struct
StyleBox
{
explicit
StyleBox
(
UniquePtr
<
T
>
aPtr
)
:
mRaw
(
aPtr
.
release
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mRaw
)
;
}
~
StyleBox
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mRaw
)
;
delete
mRaw
;
}
StyleBox
(
const
StyleBox
&
aOther
)
:
StyleBox
(
MakeUnique
<
T
>
(
*
aOther
)
)
{
}
StyleBox
&
operator
=
(
const
StyleBox
&
aOther
)
const
{
delete
mRaw
;
mRaw
=
MakeUnique
<
T
>
(
*
aOther
)
.
release
(
)
;
return
*
this
;
}
const
T
*
operator
-
>
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mRaw
)
;
return
mRaw
;
}
const
T
&
operator
*
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mRaw
)
;
return
*
mRaw
;
}
T
*
operator
-
>
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mRaw
)
;
return
mRaw
;
}
T
&
operator
*
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mRaw
)
;
return
*
mRaw
;
}
bool
operator
=
=
(
const
StyleBox
&
aOther
)
const
{
return
*
(
*
this
)
=
=
*
aOther
;
}
bool
operator
!
=
(
const
StyleBox
&
aOther
)
const
{
return
*
(
*
this
)
!
=
*
aOther
;
}
private
:
T
*
mRaw
;
}
;
using
StyleLoader
=
css
:
:
Loader
;
using
StyleLoaderReusableStyleSheets
=
css
:
:
LoaderReusableStyleSheets
;
using
StyleCallerType
=
dom
:
:
CallerType
;
using
StyleSheetParsingMode
=
css
:
:
SheetParsingMode
;
using
StyleSheetLoadData
=
css
:
:
SheetLoadData
;
using
StyleSheetLoadDataHolder
=
css
:
:
SheetLoadDataHolder
;
using
StyleGeckoMallocSizeOf
=
MallocSizeOf
;
using
StyleDomStyleSheet
=
StyleSheet
;
using
StyleRawGeckoNode
=
nsINode
;
using
StyleRawGeckoElement
=
dom
:
:
Element
;
using
StyleDocument
=
dom
:
:
Document
;
using
StyleComputedValues
=
ComputedStyle
;
using
StyleIterationCompositeOperation
=
dom
:
:
IterationCompositeOperation
;
using
StyleMatrixTransformOperator
=
nsStyleTransformMatrix
:
:
MatrixTransformOperator
;
#
define
SERVO_ARC_TYPE
(
name_
type_
)
using
Style
#
#
type_
=
type_
;
#
include
"
mozilla
/
ServoArcTypeList
.
h
"
#
undef
SERVO_ARC_TYPE
#
define
SERVO_BOXED_TYPE
(
name_
type_
)
using
Style
#
#
type_
=
type_
;
#
include
"
mozilla
/
ServoBoxedTypeList
.
h
"
#
undef
SERVO_BOXED_TYPE
using
StyleAtomicUsize
=
std
:
:
atomic
<
size_t
>
;
}
#
endif
