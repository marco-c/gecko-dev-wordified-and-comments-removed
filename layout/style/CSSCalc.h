#
ifndef
CSSCalc_h_
#
define
CSSCalc_h_
#
include
"
nsCSSValue
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
<
math
.
h
>
#
include
<
type_traits
>
namespace
mozilla
{
namespace
css
{
template
<
class
CalcOps
>
static
bool
ComputeCalc
(
typename
CalcOps
:
:
result_type
&
aResult
const
typename
CalcOps
:
:
input_type
&
aValue
CalcOps
&
aOps
)
{
switch
(
CalcOps
:
:
GetUnit
(
aValue
)
)
{
case
eCSSUnit_Calc
:
{
typename
CalcOps
:
:
input_array_type
*
arr
=
aValue
.
GetArrayValue
(
)
;
MOZ_ASSERT
(
arr
-
>
Count
(
)
=
=
1
"
unexpected
length
"
)
;
return
ComputeCalc
(
aResult
arr
-
>
Item
(
0
)
aOps
)
;
}
case
eCSSUnit_Calc_Plus
:
case
eCSSUnit_Calc_Minus
:
{
typename
CalcOps
:
:
input_array_type
*
arr
=
aValue
.
GetArrayValue
(
)
;
MOZ_ASSERT
(
arr
-
>
Count
(
)
=
=
2
"
unexpected
length
"
)
;
typename
CalcOps
:
:
result_type
lhs
rhs
;
if
(
!
ComputeCalc
(
lhs
arr
-
>
Item
(
0
)
aOps
)
|
|
!
ComputeCalc
(
rhs
arr
-
>
Item
(
1
)
aOps
)
)
{
return
false
;
}
aResult
=
aOps
.
MergeAdditive
(
CalcOps
:
:
GetUnit
(
aValue
)
lhs
rhs
)
;
return
true
;
}
case
eCSSUnit_Calc_Times_L
:
{
typename
CalcOps
:
:
input_array_type
*
arr
=
aValue
.
GetArrayValue
(
)
;
MOZ_ASSERT
(
arr
-
>
Count
(
)
=
=
2
"
unexpected
length
"
)
;
typename
CalcOps
:
:
coeff_type
lhs
=
aOps
.
ComputeCoefficient
(
arr
-
>
Item
(
0
)
)
;
typename
CalcOps
:
:
result_type
rhs
;
if
(
!
ComputeCalc
(
rhs
arr
-
>
Item
(
1
)
aOps
)
)
{
return
false
;
}
aResult
=
aOps
.
MergeMultiplicativeL
(
CalcOps
:
:
GetUnit
(
aValue
)
lhs
rhs
)
;
return
true
;
}
case
eCSSUnit_Calc_Times_R
:
case
eCSSUnit_Calc_Divided
:
{
typename
CalcOps
:
:
input_array_type
*
arr
=
aValue
.
GetArrayValue
(
)
;
MOZ_ASSERT
(
arr
-
>
Count
(
)
=
=
2
"
unexpected
length
"
)
;
typename
CalcOps
:
:
result_type
lhs
;
if
(
!
ComputeCalc
(
lhs
arr
-
>
Item
(
0
)
aOps
)
)
{
return
false
;
}
typename
CalcOps
:
:
coeff_type
rhs
=
aOps
.
ComputeCoefficient
(
arr
-
>
Item
(
1
)
)
;
aResult
=
aOps
.
MergeMultiplicativeR
(
CalcOps
:
:
GetUnit
(
aValue
)
lhs
rhs
)
;
return
true
;
}
default
:
{
return
aOps
.
ComputeLeafValue
(
aResult
aValue
)
;
}
}
}
struct
CSSValueInputCalcOps
{
typedef
nsCSSValue
input_type
;
typedef
nsCSSValue
:
:
Array
input_array_type
;
static
nsCSSUnit
GetUnit
(
const
nsCSSValue
&
aValue
)
{
return
aValue
.
GetUnit
(
)
;
}
}
;
struct
BasicCoordCalcOps
{
typedef
nscoord
result_type
;
typedef
float
coeff_type
;
result_type
MergeAdditive
(
nsCSSUnit
aCalcFunction
result_type
aValue1
result_type
aValue2
)
{
if
(
aCalcFunction
=
=
eCSSUnit_Calc_Plus
)
{
return
NSCoordSaturatingAdd
(
aValue1
aValue2
)
;
}
MOZ_ASSERT
(
aCalcFunction
=
=
eCSSUnit_Calc_Minus
"
unexpected
unit
"
)
;
return
NSCoordSaturatingSubtract
(
aValue1
aValue2
0
)
;
}
result_type
MergeMultiplicativeL
(
nsCSSUnit
aCalcFunction
coeff_type
aValue1
result_type
aValue2
)
{
MOZ_ASSERT
(
aCalcFunction
=
=
eCSSUnit_Calc_Times_L
"
unexpected
unit
"
)
;
return
NSCoordSaturatingMultiply
(
aValue2
aValue1
)
;
}
result_type
MergeMultiplicativeR
(
nsCSSUnit
aCalcFunction
result_type
aValue1
coeff_type
aValue2
)
{
MOZ_ASSERT
(
aCalcFunction
=
=
eCSSUnit_Calc_Times_R
|
|
aCalcFunction
=
=
eCSSUnit_Calc_Divided
"
unexpected
unit
"
)
;
if
(
aCalcFunction
=
=
eCSSUnit_Calc_Divided
)
{
aValue2
=
1
.
0f
/
aValue2
;
}
return
NSCoordSaturatingMultiply
(
aValue1
aValue2
)
;
}
}
;
struct
FloatCoeffsAlreadyNormalizedOps
:
public
CSSValueInputCalcOps
{
typedef
float
coeff_type
;
coeff_type
ComputeCoefficient
(
const
nsCSSValue
&
aValue
)
{
MOZ_ASSERT
(
aValue
.
GetUnit
(
)
=
=
eCSSUnit_Number
"
unexpected
unit
"
)
;
return
aValue
.
GetFloatValue
(
)
;
}
}
;
template
<
class
CalcOps
>
static
void
SerializeCalcInternal
(
const
typename
CalcOps
:
:
input_type
&
aValue
CalcOps
&
aOps
)
;
template
<
class
CalcOps
>
static
void
SerializeCalc
(
const
typename
CalcOps
:
:
input_type
&
aValue
CalcOps
&
aOps
)
{
aOps
.
Append
(
"
calc
(
"
)
;
nsCSSUnit
unit
=
CalcOps
:
:
GetUnit
(
aValue
)
;
if
(
unit
=
=
eCSSUnit_Calc
)
{
const
typename
CalcOps
:
:
input_array_type
*
array
=
aValue
.
GetArrayValue
(
)
;
MOZ_ASSERT
(
array
-
>
Count
(
)
=
=
1
"
unexpected
length
"
)
;
SerializeCalcInternal
(
array
-
>
Item
(
0
)
aOps
)
;
}
else
{
SerializeCalcInternal
(
aValue
aOps
)
;
}
aOps
.
Append
(
"
)
"
)
;
}
static
inline
bool
IsCalcAdditiveUnit
(
nsCSSUnit
aUnit
)
{
return
aUnit
=
=
eCSSUnit_Calc_Plus
|
|
aUnit
=
=
eCSSUnit_Calc_Minus
;
}
static
inline
bool
IsCalcMultiplicativeUnit
(
nsCSSUnit
aUnit
)
{
return
aUnit
=
=
eCSSUnit_Calc_Times_L
|
|
aUnit
=
=
eCSSUnit_Calc_Times_R
|
|
aUnit
=
=
eCSSUnit_Calc_Divided
;
}
template
<
class
CalcOps
>
void
SerializeCalcInternal
(
const
typename
CalcOps
:
:
input_type
&
aValue
CalcOps
&
aOps
)
{
nsCSSUnit
unit
=
CalcOps
:
:
GetUnit
(
aValue
)
;
if
(
IsCalcAdditiveUnit
(
unit
)
)
{
const
typename
CalcOps
:
:
input_array_type
*
array
=
aValue
.
GetArrayValue
(
)
;
MOZ_ASSERT
(
array
-
>
Count
(
)
=
=
2
"
unexpected
length
"
)
;
SerializeCalcInternal
(
array
-
>
Item
(
0
)
aOps
)
;
if
(
eCSSUnit_Calc_Plus
=
=
unit
)
{
aOps
.
Append
(
"
+
"
)
;
}
else
{
MOZ_ASSERT
(
eCSSUnit_Calc_Minus
=
=
unit
"
unexpected
unit
"
)
;
aOps
.
Append
(
"
-
"
)
;
}
bool
needParens
=
IsCalcAdditiveUnit
(
CalcOps
:
:
GetUnit
(
array
-
>
Item
(
1
)
)
)
;
if
(
needParens
)
{
aOps
.
Append
(
"
(
"
)
;
}
SerializeCalcInternal
(
array
-
>
Item
(
1
)
aOps
)
;
if
(
needParens
)
{
aOps
.
Append
(
"
)
"
)
;
}
}
else
if
(
IsCalcMultiplicativeUnit
(
unit
)
)
{
const
typename
CalcOps
:
:
input_array_type
*
array
=
aValue
.
GetArrayValue
(
)
;
MOZ_ASSERT
(
array
-
>
Count
(
)
=
=
2
"
unexpected
length
"
)
;
bool
needParens
=
IsCalcAdditiveUnit
(
CalcOps
:
:
GetUnit
(
array
-
>
Item
(
0
)
)
)
;
if
(
needParens
)
{
aOps
.
Append
(
"
(
"
)
;
}
if
(
unit
=
=
eCSSUnit_Calc_Times_L
)
{
aOps
.
AppendCoefficient
(
array
-
>
Item
(
0
)
)
;
}
else
{
SerializeCalcInternal
(
array
-
>
Item
(
0
)
aOps
)
;
}
if
(
needParens
)
{
aOps
.
Append
(
"
)
"
)
;
}
if
(
eCSSUnit_Calc_Times_L
=
=
unit
|
|
eCSSUnit_Calc_Times_R
=
=
unit
)
{
aOps
.
Append
(
"
*
"
)
;
}
else
{
MOZ_ASSERT
(
eCSSUnit_Calc_Divided
=
=
unit
"
unexpected
unit
"
)
;
aOps
.
Append
(
"
/
"
)
;
}
nsCSSUnit
subUnit
=
CalcOps
:
:
GetUnit
(
array
-
>
Item
(
1
)
)
;
needParens
=
IsCalcAdditiveUnit
(
subUnit
)
|
|
IsCalcMultiplicativeUnit
(
subUnit
)
;
if
(
needParens
)
{
aOps
.
Append
(
"
(
"
)
;
}
if
(
unit
=
=
eCSSUnit_Calc_Times_L
)
{
SerializeCalcInternal
(
array
-
>
Item
(
1
)
aOps
)
;
}
else
{
aOps
.
AppendCoefficient
(
array
-
>
Item
(
1
)
)
;
}
if
(
needParens
)
{
aOps
.
Append
(
"
)
"
)
;
}
}
else
{
aOps
.
AppendLeafValue
(
aValue
)
;
}
}
template
<
typename
type
nsCSSUnit
unit
>
struct
ReduceCalcOps
:
public
mozilla
:
:
css
:
:
CSSValueInputCalcOps
{
static_assert
(
(
std
:
:
is_same
<
type
int
>
:
:
value
&
&
unit
=
=
eCSSUnit_Integer
)
|
|
(
std
:
:
is_same
<
type
float
>
:
:
value
&
&
(
unit
=
=
eCSSUnit_Number
|
|
unit
=
=
eCSSUnit_Percent
)
)
"
ReduceCalcOps
:
Invalid
template
arguments
:
must
use
"
"
int
coefficient
with
eCSSUnit_Integer
or
"
"
float
coefficient
with
(
eCSSUnit_Number
or
eCSSUnit_Percent
)
"
)
;
typedef
type
result_type
;
typedef
type
coeff_type
;
result_type
MergeAdditive
(
nsCSSUnit
aCalcFunction
result_type
aValue1
result_type
aValue2
)
{
if
(
aCalcFunction
=
=
eCSSUnit_Calc_Plus
)
{
return
aValue1
+
aValue2
;
}
MOZ_ASSERT
(
aCalcFunction
=
=
eCSSUnit_Calc_Minus
"
unexpected
unit
"
)
;
return
aValue1
-
aValue2
;
}
result_type
MergeMultiplicativeL
(
nsCSSUnit
aCalcFunction
coeff_type
aValue1
result_type
aValue2
)
{
MOZ_ASSERT
(
aCalcFunction
=
=
eCSSUnit_Calc_Times_L
"
unexpected
unit
"
)
;
return
aValue1
*
aValue2
;
}
result_type
MergeMultiplicativeR
(
nsCSSUnit
aCalcFunction
result_type
aValue1
coeff_type
aValue2
)
{
if
(
aCalcFunction
=
=
eCSSUnit_Calc_Times_R
)
{
return
aValue1
*
aValue2
;
}
MOZ_ASSERT
(
aCalcFunction
=
=
eCSSUnit_Calc_Divided
"
unexpected
unit
"
)
;
MOZ_ASSERT
(
unit
!
=
eCSSUnit_Integer
"
We
should
catch
and
prevent
divisions
in
integer
"
"
calc
(
)
s
in
the
parser
"
)
;
return
aValue1
/
aValue2
;
}
bool
ComputeLeafValue
(
result_type
&
aResult
const
nsCSSValue
&
aValue
)
{
if
(
aValue
.
GetUnit
(
)
!
=
unit
)
{
return
false
;
}
aResult
=
unit
=
=
eCSSUnit_Percent
?
aValue
.
GetPercentValue
(
)
:
unit
=
=
eCSSUnit_Integer
?
aValue
.
GetIntValue
(
)
:
aValue
.
GetFloatValue
(
)
;
return
true
;
}
coeff_type
ComputeCoefficient
(
const
nsCSSValue
&
aValue
)
{
coeff_type
coeff
;
if
(
!
mozilla
:
:
css
:
:
ComputeCalc
(
coeff
aValue
*
this
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
unit
"
)
;
}
return
coeff
;
}
}
;
}
}
#
endif
