#
include
"
mozilla
/
dom
/
FontFaceImpl
.
h
"
#
include
<
algorithm
>
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
mozilla
/
dom
/
CSSFontFaceRule
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceBinding
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceSetImpl
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
UnionTypes
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsStyleUtil
.
h
"
namespace
mozilla
{
namespace
dom
{
class
FontFaceBufferSource
:
public
gfxFontFaceBufferSource
{
public
:
FontFaceBufferSource
(
uint8_t
*
aBuffer
uint32_t
aLength
)
:
mBuffer
(
aBuffer
)
mLength
(
aLength
)
{
}
void
TakeBuffer
(
uint8_t
*
&
aBuffer
uint32_t
&
aLength
)
override
{
MOZ_ASSERT
(
mBuffer
"
only
call
TakeBuffer
once
on
a
given
"
"
FontFaceBufferSource
object
"
)
;
aBuffer
=
mBuffer
;
aLength
=
mLength
;
mBuffer
=
nullptr
;
mLength
=
0
;
}
private
:
~
FontFaceBufferSource
(
)
override
{
if
(
mBuffer
)
{
free
(
mBuffer
)
;
}
}
uint8_t
*
mBuffer
;
uint32_t
mLength
;
}
;
FontFaceImpl
:
:
FontFaceImpl
(
FontFace
*
aOwner
FontFaceSetImpl
*
aFontFaceSet
)
:
mOwner
(
aOwner
)
mStatus
(
FontFaceLoadStatus
:
:
Unloaded
)
mSourceType
(
SourceType
(
0
)
)
mFontFaceSet
(
aFontFaceSet
)
mUnicodeRangeDirty
(
true
)
mInFontFaceSet
(
false
)
{
}
FontFaceImpl
:
:
~
FontFaceImpl
(
)
{
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
SetUserFontEntry
(
nullptr
)
;
}
void
FontFaceImpl
:
:
Destroy
(
)
{
mInFontFaceSet
=
false
;
SetUserFontEntry
(
nullptr
)
;
mOwner
=
nullptr
;
}
static
FontFaceLoadStatus
LoadStateToStatus
(
gfxUserFontEntry
:
:
UserFontLoadState
aLoadState
)
{
switch
(
aLoadState
)
{
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_NOT_LOADED
:
return
FontFaceLoadStatus
:
:
Unloaded
;
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_LOAD_PENDING
:
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_LOADING
:
return
FontFaceLoadStatus
:
:
Loading
;
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_LOADED
:
return
FontFaceLoadStatus
:
:
Loaded
;
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_FAILED
:
return
FontFaceLoadStatus
:
:
Error
;
}
MOZ_ASSERT_UNREACHABLE
(
"
invalid
aLoadState
value
"
)
;
return
FontFaceLoadStatus
:
:
Error
;
}
already_AddRefed
<
FontFaceImpl
>
FontFaceImpl
:
:
CreateForRule
(
FontFace
*
aOwner
FontFaceSetImpl
*
aFontFaceSet
RawServoFontFaceRule
*
aRule
)
{
RefPtr
<
FontFaceImpl
>
obj
=
new
FontFaceImpl
(
aOwner
aFontFaceSet
)
;
obj
-
>
mRule
=
aRule
;
obj
-
>
mSourceType
=
eSourceType_FontFaceRule
;
obj
-
>
mInFontFaceSet
=
true
;
return
obj
.
forget
(
)
;
}
void
FontFaceImpl
:
:
InitializeSourceURL
(
const
nsACString
&
aURL
)
{
MOZ_ASSERT
(
mOwner
)
;
mSourceType
=
eSourceType_URLs
;
IgnoredErrorResult
rv
;
SetDescriptor
(
eCSSFontDesc_Src
aURL
rv
)
;
if
(
rv
.
Failed
(
)
)
{
mOwner
-
>
MaybeReject
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
SetStatus
(
FontFaceLoadStatus
:
:
Error
)
;
}
}
void
FontFaceImpl
:
:
InitializeSourceBuffer
(
uint8_t
*
aBuffer
uint32_t
aLength
)
{
MOZ_ASSERT
(
mOwner
)
;
MOZ_ASSERT
(
!
mBufferSource
)
;
mSourceType
=
FontFaceImpl
:
:
eSourceType_Buffer
;
if
(
aBuffer
)
{
mBufferSource
=
new
FontFaceBufferSource
(
aBuffer
aLength
)
;
}
SetStatus
(
FontFaceLoadStatus
:
:
Loading
)
;
DoLoad
(
)
;
}
void
FontFaceImpl
:
:
GetFamily
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_Family
aResult
)
;
}
void
FontFaceImpl
:
:
SetFamily
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_Family
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetStyle
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_Style
aResult
)
;
}
void
FontFaceImpl
:
:
SetStyle
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
if
(
SetDescriptor
(
eCSSFontDesc_Style
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetWeight
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_Weight
aResult
)
;
}
void
FontFaceImpl
:
:
SetWeight
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_Weight
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetStretch
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_Stretch
aResult
)
;
}
void
FontFaceImpl
:
:
SetStretch
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_Stretch
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetUnicodeRange
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_UnicodeRange
aResult
)
;
}
void
FontFaceImpl
:
:
SetUnicodeRange
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_UnicodeRange
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetVariant
(
nsACString
&
aResult
)
{
aResult
.
AssignLiteral
(
"
normal
"
)
;
}
void
FontFaceImpl
:
:
SetVariant
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
}
void
FontFaceImpl
:
:
GetFeatureSettings
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_FontFeatureSettings
aResult
)
;
}
void
FontFaceImpl
:
:
SetFeatureSettings
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_FontFeatureSettings
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetVariationSettings
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_FontVariationSettings
aResult
)
;
}
void
FontFaceImpl
:
:
SetVariationSettings
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_FontVariationSettings
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetDisplay
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_Display
aResult
)
;
}
void
FontFaceImpl
:
:
SetDisplay
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
if
(
SetDescriptor
(
eCSSFontDesc_Display
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetAscentOverride
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_AscentOverride
aResult
)
;
}
void
FontFaceImpl
:
:
SetAscentOverride
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
if
(
SetDescriptor
(
eCSSFontDesc_AscentOverride
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetDescentOverride
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_DescentOverride
aResult
)
;
}
void
FontFaceImpl
:
:
SetDescentOverride
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
if
(
SetDescriptor
(
eCSSFontDesc_DescentOverride
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetLineGapOverride
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_LineGapOverride
aResult
)
;
}
void
FontFaceImpl
:
:
SetLineGapOverride
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
if
(
SetDescriptor
(
eCSSFontDesc_LineGapOverride
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
GetSizeAdjust
(
nsACString
&
aResult
)
{
GetDesc
(
eCSSFontDesc_SizeAdjust
aResult
)
;
}
void
FontFaceImpl
:
:
SetSizeAdjust
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
if
(
SetDescriptor
(
eCSSFontDesc_SizeAdjust
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFaceImpl
:
:
DescriptorUpdated
(
)
{
if
(
!
mUserFontEntry
)
{
return
;
}
RefPtr
<
gfxUserFontEntry
>
newEntry
=
mFontFaceSet
-
>
FindOrCreateUserFontEntryFromFontFace
(
this
)
;
SetUserFontEntry
(
newEntry
)
;
if
(
mInFontFaceSet
)
{
mFontFaceSet
-
>
MarkUserFontSetDirty
(
)
;
}
for
(
auto
&
set
:
mOtherFontFaceSets
)
{
set
-
>
MarkUserFontSetDirty
(
)
;
}
}
FontFaceLoadStatus
FontFaceImpl
:
:
Status
(
)
{
return
mStatus
;
}
void
FontFaceImpl
:
:
Load
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
mSourceType
=
=
eSourceType_Buffer
|
|
mStatus
!
=
FontFaceLoadStatus
:
:
Unloaded
)
{
return
;
}
SetStatus
(
FontFaceLoadStatus
:
:
Loading
)
;
DoLoad
(
)
;
}
gfxUserFontEntry
*
FontFaceImpl
:
:
CreateUserFontEntry
(
)
{
if
(
!
mUserFontEntry
)
{
MOZ_ASSERT
(
!
HasRule
(
)
"
Rule
backed
FontFace
objects
should
already
have
a
user
font
"
"
entry
by
the
time
Load
(
)
can
be
called
on
them
"
)
;
RefPtr
<
gfxUserFontEntry
>
newEntry
=
mFontFaceSet
-
>
FindOrCreateUserFontEntryFromFontFace
(
this
)
;
if
(
newEntry
)
{
SetUserFontEntry
(
newEntry
)
;
}
}
return
mUserFontEntry
;
}
void
FontFaceImpl
:
:
DoLoad
(
)
{
if
(
!
CreateUserFontEntry
(
)
)
{
return
;
}
mUserFontEntry
-
>
Load
(
)
;
}
void
FontFaceImpl
:
:
SetStatus
(
FontFaceLoadStatus
aStatus
)
{
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
if
(
mStatus
=
=
aStatus
)
{
return
;
}
if
(
aStatus
<
mStatus
)
{
return
;
}
mStatus
=
aStatus
;
if
(
mInFontFaceSet
)
{
mFontFaceSet
-
>
OnFontFaceStatusChanged
(
this
)
;
}
for
(
FontFaceSetImpl
*
otherSet
:
mOtherFontFaceSets
)
{
otherSet
-
>
OnFontFaceStatusChanged
(
this
)
;
}
if
(
NS_WARN_IF
(
!
mOwner
)
)
{
return
;
}
if
(
mStatus
=
=
FontFaceLoadStatus
:
:
Loaded
)
{
mOwner
-
>
MaybeResolve
(
)
;
}
else
if
(
mStatus
=
=
FontFaceLoadStatus
:
:
Error
)
{
if
(
mSourceType
=
=
eSourceType_Buffer
)
{
mOwner
-
>
MaybeReject
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
}
else
{
mOwner
-
>
MaybeReject
(
NS_ERROR_DOM_NETWORK_ERR
)
;
}
}
}
bool
FontFaceImpl
:
:
SetDescriptor
(
nsCSSFontDesc
aFontDesc
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
NS_ASSERTION
(
!
HasRule
(
)
"
we
don
'
t
handle
rule
backed
FontFace
objects
yet
"
)
;
if
(
HasRule
(
)
)
{
return
false
;
}
RefPtr
<
URLExtraData
>
url
=
mFontFaceSet
-
>
GetURLExtraData
(
)
;
bool
changed
;
if
(
!
Servo_FontFaceRule_SetDescriptor
(
GetData
(
)
aFontDesc
&
aValue
url
&
changed
)
)
{
aRv
.
ThrowSyntaxError
(
"
Invalid
font
descriptor
"
)
;
return
false
;
}
if
(
!
changed
)
{
return
false
;
}
if
(
aFontDesc
=
=
eCSSFontDesc_UnicodeRange
)
{
mUnicodeRangeDirty
=
true
;
}
return
true
;
}
bool
FontFaceImpl
:
:
SetDescriptors
(
const
nsACString
&
aFamily
const
FontFaceDescriptors
&
aDescriptors
)
{
MOZ_ASSERT
(
!
HasRule
(
)
)
;
MOZ_ASSERT
(
!
mDescriptors
)
;
mDescriptors
=
Servo_FontFaceRule_CreateEmpty
(
)
.
Consume
(
)
;
auto
setDesc
=
[
=
]
(
nsCSSFontDesc
aDesc
const
nsACString
&
aVal
)
-
>
bool
{
IgnoredErrorResult
rv
;
SetDescriptor
(
aDesc
aVal
rv
)
;
return
!
rv
.
Failed
(
)
;
}
;
if
(
!
setDesc
(
eCSSFontDesc_Family
aFamily
)
|
|
!
setDesc
(
eCSSFontDesc_Style
aDescriptors
.
mStyle
)
|
|
!
setDesc
(
eCSSFontDesc_Weight
aDescriptors
.
mWeight
)
|
|
!
setDesc
(
eCSSFontDesc_Stretch
aDescriptors
.
mStretch
)
|
|
!
setDesc
(
eCSSFontDesc_UnicodeRange
aDescriptors
.
mUnicodeRange
)
|
|
!
setDesc
(
eCSSFontDesc_FontFeatureSettings
aDescriptors
.
mFeatureSettings
)
|
|
(
StaticPrefs
:
:
layout_css_font_variations_enabled
(
)
&
&
!
setDesc
(
eCSSFontDesc_FontVariationSettings
aDescriptors
.
mVariationSettings
)
)
|
|
!
setDesc
(
eCSSFontDesc_Display
aDescriptors
.
mDisplay
)
|
|
(
StaticPrefs
:
:
layout_css_font_metrics_overrides_enabled
(
)
&
&
(
!
setDesc
(
eCSSFontDesc_AscentOverride
aDescriptors
.
mAscentOverride
)
|
|
!
setDesc
(
eCSSFontDesc_DescentOverride
aDescriptors
.
mDescentOverride
)
|
|
!
setDesc
(
eCSSFontDesc_LineGapOverride
aDescriptors
.
mLineGapOverride
)
)
)
|
|
(
StaticPrefs
:
:
layout_css_size_adjust_enabled
(
)
&
&
!
setDesc
(
eCSSFontDesc_SizeAdjust
aDescriptors
.
mSizeAdjust
)
)
)
{
mDescriptors
=
Servo_FontFaceRule_CreateEmpty
(
)
.
Consume
(
)
;
if
(
mOwner
)
{
mOwner
-
>
MaybeReject
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
}
SetStatus
(
FontFaceLoadStatus
:
:
Error
)
;
return
false
;
}
return
true
;
}
void
FontFaceImpl
:
:
GetDesc
(
nsCSSFontDesc
aDescID
nsACString
&
aResult
)
const
{
aResult
.
Truncate
(
)
;
Servo_FontFaceRule_GetDescriptorCssText
(
GetData
(
)
aDescID
&
aResult
)
;
if
(
aResult
.
IsEmpty
(
)
)
{
if
(
aDescID
=
=
eCSSFontDesc_UnicodeRange
)
{
aResult
.
AssignLiteral
(
"
U
+
0
-
10FFFF
"
)
;
}
else
if
(
aDescID
=
=
eCSSFontDesc_Display
)
{
aResult
.
AssignLiteral
(
"
auto
"
)
;
}
else
if
(
aDescID
!
=
eCSSFontDesc_Family
&
&
aDescID
!
=
eCSSFontDesc_Src
)
{
aResult
.
AssignLiteral
(
"
normal
"
)
;
}
}
}
void
FontFaceImpl
:
:
SetUserFontEntry
(
gfxUserFontEntry
*
aEntry
)
{
if
(
mUserFontEntry
)
{
mUserFontEntry
-
>
mFontFaces
.
RemoveElement
(
this
)
;
}
mUserFontEntry
=
static_cast
<
Entry
*
>
(
aEntry
)
;
if
(
mUserFontEntry
)
{
mUserFontEntry
-
>
mFontFaces
.
AppendElement
(
this
)
;
MOZ_ASSERT
(
mUserFontEntry
-
>
GetUserFontSet
(
)
=
=
mFontFaceSet
"
user
font
entry
must
be
associated
with
the
same
user
font
set
"
"
as
the
FontFace
"
)
;
FontFaceLoadStatus
newStatus
=
LoadStateToStatus
(
mUserFontEntry
-
>
LoadState
(
)
)
;
if
(
newStatus
>
mStatus
)
{
SetStatus
(
newStatus
)
;
}
}
}
Maybe
<
StyleComputedFontWeightRange
>
FontFaceImpl
:
:
GetFontWeight
(
)
const
{
StyleComputedFontWeightRange
range
;
if
(
!
Servo_FontFaceRule_GetFontWeight
(
GetData
(
)
&
range
)
)
{
return
Nothing
(
)
;
}
return
Some
(
range
)
;
}
Maybe
<
StyleComputedFontStretchRange
>
FontFaceImpl
:
:
GetFontStretch
(
)
const
{
StyleComputedFontStretchRange
range
;
if
(
!
Servo_FontFaceRule_GetFontStretch
(
GetData
(
)
&
range
)
)
{
return
Nothing
(
)
;
}
return
Some
(
range
)
;
}
Maybe
<
StyleComputedFontStyleDescriptor
>
FontFaceImpl
:
:
GetFontStyle
(
)
const
{
auto
descriptor
=
StyleComputedFontStyleDescriptor
:
:
Normal
(
)
;
if
(
!
Servo_FontFaceRule_GetFontStyle
(
GetData
(
)
&
descriptor
)
)
{
return
Nothing
(
)
;
}
return
Some
(
descriptor
)
;
}
Maybe
<
StyleFontDisplay
>
FontFaceImpl
:
:
GetFontDisplay
(
)
const
{
StyleFontDisplay
display
;
if
(
!
Servo_FontFaceRule_GetFontDisplay
(
GetData
(
)
&
display
)
)
{
return
Nothing
(
)
;
}
return
Some
(
display
)
;
}
Maybe
<
StyleFontLanguageOverride
>
FontFaceImpl
:
:
GetFontLanguageOverride
(
)
const
{
StyleFontLanguageOverride
langOverride
;
if
(
!
Servo_FontFaceRule_GetFontLanguageOverride
(
GetData
(
)
&
langOverride
)
)
{
return
Nothing
(
)
;
}
return
Some
(
langOverride
)
;
}
Maybe
<
StylePercentage
>
FontFaceImpl
:
:
GetAscentOverride
(
)
const
{
StylePercentage
ascent
{
0
}
;
if
(
!
Servo_FontFaceRule_GetAscentOverride
(
GetData
(
)
&
ascent
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ascent
)
;
}
Maybe
<
StylePercentage
>
FontFaceImpl
:
:
GetDescentOverride
(
)
const
{
StylePercentage
descent
{
0
}
;
if
(
!
Servo_FontFaceRule_GetDescentOverride
(
GetData
(
)
&
descent
)
)
{
return
Nothing
(
)
;
}
return
Some
(
descent
)
;
}
Maybe
<
StylePercentage
>
FontFaceImpl
:
:
GetLineGapOverride
(
)
const
{
StylePercentage
lineGap
{
0
}
;
if
(
!
Servo_FontFaceRule_GetLineGapOverride
(
GetData
(
)
&
lineGap
)
)
{
return
Nothing
(
)
;
}
return
Some
(
lineGap
)
;
}
Maybe
<
StylePercentage
>
FontFaceImpl
:
:
GetSizeAdjust
(
)
const
{
StylePercentage
sizeAdjust
;
if
(
!
Servo_FontFaceRule_GetSizeAdjust
(
GetData
(
)
&
sizeAdjust
)
)
{
return
Nothing
(
)
;
}
return
Some
(
sizeAdjust
)
;
}
bool
FontFaceImpl
:
:
HasLocalSrc
(
)
const
{
AutoTArray
<
StyleFontFaceSourceListComponent
8
>
components
;
GetSources
(
components
)
;
for
(
auto
&
component
:
components
)
{
if
(
component
.
tag
=
=
StyleFontFaceSourceListComponent
:
:
Tag
:
:
Local
)
{
return
true
;
}
}
return
false
;
}
void
FontFaceImpl
:
:
GetFontFeatureSettings
(
nsTArray
<
gfxFontFeature
>
&
aFeatures
)
const
{
Servo_FontFaceRule_GetFeatureSettings
(
GetData
(
)
&
aFeatures
)
;
}
void
FontFaceImpl
:
:
GetFontVariationSettings
(
nsTArray
<
gfxFontVariation
>
&
aVariations
)
const
{
Servo_FontFaceRule_GetVariationSettings
(
GetData
(
)
&
aVariations
)
;
}
void
FontFaceImpl
:
:
GetSources
(
nsTArray
<
StyleFontFaceSourceListComponent
>
&
aSources
)
const
{
Servo_FontFaceRule_GetSources
(
GetData
(
)
&
aSources
)
;
}
nsAtom
*
FontFaceImpl
:
:
GetFamilyName
(
)
const
{
return
Servo_FontFaceRule_GetFamilyName
(
GetData
(
)
)
;
}
void
FontFaceImpl
:
:
DisconnectFromRule
(
)
{
MOZ_ASSERT
(
HasRule
(
)
)
;
mDescriptors
=
Servo_FontFaceRule_Clone
(
mRule
)
.
Consume
(
)
;
mRule
=
nullptr
;
mInFontFaceSet
=
false
;
}
bool
FontFaceImpl
:
:
HasFontData
(
)
const
{
return
mSourceType
=
=
eSourceType_Buffer
&
&
mBufferSource
;
}
already_AddRefed
<
gfxFontFaceBufferSource
>
FontFaceImpl
:
:
TakeBufferSource
(
)
{
MOZ_ASSERT
(
mBufferSource
)
;
return
mBufferSource
.
forget
(
)
;
}
bool
FontFaceImpl
:
:
IsInFontFaceSet
(
FontFaceSetImpl
*
aFontFaceSet
)
const
{
if
(
mFontFaceSet
=
=
aFontFaceSet
)
{
return
mInFontFaceSet
;
}
return
mOtherFontFaceSets
.
Contains
(
aFontFaceSet
)
;
}
void
FontFaceImpl
:
:
AddFontFaceSet
(
FontFaceSetImpl
*
aFontFaceSet
)
{
MOZ_ASSERT
(
!
IsInFontFaceSet
(
aFontFaceSet
)
)
;
if
(
mFontFaceSet
=
=
aFontFaceSet
)
{
mInFontFaceSet
=
true
;
}
else
{
mOtherFontFaceSets
.
AppendElement
(
aFontFaceSet
)
;
}
}
void
FontFaceImpl
:
:
RemoveFontFaceSet
(
FontFaceSetImpl
*
aFontFaceSet
)
{
MOZ_ASSERT
(
IsInFontFaceSet
(
aFontFaceSet
)
)
;
if
(
mFontFaceSet
=
=
aFontFaceSet
)
{
mInFontFaceSet
=
false
;
}
else
{
mOtherFontFaceSets
.
RemoveElement
(
aFontFaceSet
)
;
}
}
gfxCharacterMap
*
FontFaceImpl
:
:
GetUnicodeRangeAsCharacterMap
(
)
{
if
(
!
mUnicodeRangeDirty
)
{
return
mUnicodeRange
;
}
size_t
len
;
const
StyleUnicodeRange
*
rangesPtr
=
Servo_FontFaceRule_GetUnicodeRanges
(
GetData
(
)
&
len
)
;
Span
<
const
StyleUnicodeRange
>
ranges
(
rangesPtr
len
)
;
if
(
!
ranges
.
IsEmpty
(
)
)
{
RefPtr
<
gfxCharacterMap
>
charMap
=
new
gfxCharacterMap
(
)
;
for
(
auto
&
range
:
ranges
)
{
charMap
-
>
SetRange
(
range
.
start
range
.
end
)
;
}
charMap
-
>
Compact
(
)
;
mUnicodeRange
=
gfxPlatformFontList
:
:
PlatformFontList
(
)
-
>
FindCharMap
(
charMap
)
;
}
else
{
mUnicodeRange
=
nullptr
;
}
mUnicodeRangeDirty
=
false
;
return
mUnicodeRange
;
}
void
FontFaceImpl
:
:
Entry
:
:
SetLoadState
(
UserFontLoadState
aLoadState
)
{
gfxUserFontEntry
:
:
SetLoadState
(
aLoadState
)
;
for
(
size_t
i
=
0
;
i
<
mFontFaces
.
Length
(
)
;
i
+
+
)
{
mFontFaces
[
i
]
-
>
SetStatus
(
LoadStateToStatus
(
aLoadState
)
)
;
}
}
void
FontFaceImpl
:
:
Entry
:
:
GetUserFontSets
(
nsTArray
<
gfxUserFontSet
*
>
&
aResult
)
{
aResult
.
Clear
(
)
;
for
(
FontFaceImpl
*
f
:
mFontFaces
)
{
if
(
f
-
>
mInFontFaceSet
)
{
aResult
.
AppendElement
(
f
-
>
mFontFaceSet
)
;
}
for
(
FontFaceSetImpl
*
s
:
f
-
>
mOtherFontFaceSets
)
{
aResult
.
AppendElement
(
s
)
;
}
}
aResult
.
Sort
(
)
;
auto
it
=
std
:
:
unique
(
aResult
.
begin
(
)
aResult
.
end
(
)
)
;
aResult
.
TruncateLength
(
it
-
aResult
.
begin
(
)
)
;
}
}
}
