const
is_chrome_window
=
window
.
location
.
protocol
=
=
=
"
chrome
:
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
var
expected_values
=
[
[
"
color
"
null
8
]
[
"
color
-
index
"
null
0
]
[
"
aspect
-
ratio
"
null
window
.
innerWidth
+
"
/
"
+
window
.
innerHeight
]
[
"
device
-
aspect
-
ratio
"
screen
.
width
+
"
/
"
+
screen
.
height
window
.
innerWidth
+
"
/
"
+
window
.
innerHeight
]
[
"
device
-
height
"
screen
.
height
+
"
px
"
window
.
innerHeight
+
"
px
"
]
[
"
device
-
width
"
screen
.
width
+
"
px
"
window
.
innerWidth
+
"
px
"
]
[
"
grid
"
null
0
]
[
"
height
"
window
.
innerHeight
+
"
px
"
window
.
innerHeight
+
"
px
"
]
[
"
monochrome
"
null
0
]
[
"
orientation
"
null
window
.
innerWidth
>
window
.
innerHeight
?
"
landscape
"
:
"
portrait
"
]
[
"
resolution
"
null
"
96dpi
"
]
[
"
resolution
"
[
0
.
999
*
window
.
devicePixelRatio
+
"
dppx
"
1
.
001
*
window
.
devicePixelRatio
+
"
dppx
"
]
"
1dppx
"
]
[
"
width
"
window
.
innerWidth
+
"
px
"
window
.
innerWidth
+
"
px
"
]
[
"
-
moz
-
device
-
pixel
-
ratio
"
window
.
devicePixelRatio
1
]
[
"
-
moz
-
device
-
orientation
"
screen
.
width
>
screen
.
height
?
"
landscape
"
:
"
portrait
"
window
.
innerWidth
>
window
.
innerHeight
?
"
landscape
"
:
"
portrait
"
]
]
;
var
suppressed_toggles
=
[
"
-
moz
-
mac
-
graphite
-
theme
"
"
-
moz
-
scrollbar
-
end
-
backward
"
"
-
moz
-
scrollbar
-
end
-
forward
"
"
-
moz
-
scrollbar
-
start
-
backward
"
"
-
moz
-
scrollbar
-
start
-
forward
"
"
-
moz
-
scrollbar
-
thumb
-
proportional
"
"
-
moz
-
touch
-
enabled
"
"
-
moz
-
windows
-
compositor
"
"
-
moz
-
windows
-
default
-
theme
"
"
-
moz
-
windows
-
glass
"
"
-
moz
-
gtk
-
csd
-
available
"
"
-
moz
-
gtk
-
csd
-
minimize
-
button
"
"
-
moz
-
gtk
-
csd
-
maximize
-
button
"
"
-
moz
-
gtk
-
csd
-
close
-
button
"
]
;
var
toggles_enabled_in_content
=
[
"
-
moz
-
touch
-
enabled
"
]
;
var
windows_versions
=
[
"
windows
-
win7
"
"
windows
-
win8
"
"
windows
-
win10
"
]
;
var
OS
=
SpecialPowers
.
Services
.
appinfo
.
OS
;
if
(
OS
=
=
=
"
WINNT
"
)
{
suppressed_toggles
.
push
(
"
-
moz
-
windows
-
classic
"
)
;
}
var
keyValMatches
=
(
key
val
)
=
>
matchMedia
(
"
(
"
+
key
+
"
:
"
+
val
+
"
)
"
)
.
matches
;
var
testMatch
=
function
(
key
val
)
{
if
(
val
=
=
=
null
)
{
return
;
}
else
if
(
Array
.
isArray
(
val
)
)
{
ok
(
keyValMatches
(
"
min
-
"
+
key
val
[
0
]
)
&
&
keyValMatches
(
"
max
-
"
+
key
val
[
1
]
)
"
Expected
"
+
key
+
"
between
"
+
val
[
0
]
+
"
and
"
+
val
[
1
]
)
;
}
else
{
ok
(
keyValMatches
(
key
val
)
"
Expected
"
+
key
+
"
:
"
+
val
)
;
}
}
;
var
testToggles
=
function
(
resisting
)
{
suppressed_toggles
.
forEach
(
function
(
key
)
{
var
exists
=
keyValMatches
(
key
0
)
|
|
keyValMatches
(
key
1
)
;
if
(
!
toggles_enabled_in_content
.
includes
(
key
)
&
&
!
is_chrome_window
)
{
ok
(
!
exists
key
+
"
should
not
exist
.
"
)
;
}
else
{
ok
(
exists
key
+
"
should
exist
.
"
)
;
if
(
resisting
)
{
ok
(
keyValMatches
(
key
0
)
&
&
!
keyValMatches
(
key
1
)
"
Should
always
match
as
false
"
)
;
}
}
}
)
;
}
;
var
testWindowsSpecific
=
function
(
resisting
queryName
possibleValues
)
{
let
foundValue
=
null
;
possibleValues
.
forEach
(
function
(
val
)
{
if
(
keyValMatches
(
queryName
val
)
)
{
foundValue
=
val
;
}
}
)
;
if
(
resisting
|
|
!
is_chrome_window
)
{
ok
(
!
foundValue
queryName
+
"
should
have
no
match
"
)
;
}
else
{
ok
(
foundValue
foundValue
?
(
"
Match
found
:
'
"
+
queryName
+
"
:
"
+
foundValue
+
"
'
"
)
:
"
Should
have
a
match
for
'
"
+
queryName
+
"
'
"
)
;
}
}
;
var
generateHtmlLines
=
function
(
resisting
)
{
let
fragment
=
document
.
createDocumentFragment
(
)
;
expected_values
.
forEach
(
function
(
[
key
offVal
onVal
]
)
{
let
val
=
resisting
?
onVal
:
offVal
;
if
(
val
)
{
let
div
=
document
.
createElement
(
"
div
"
)
;
div
.
setAttribute
(
"
class
"
"
spoof
"
)
;
div
.
setAttribute
(
"
id
"
key
)
;
div
.
textContent
=
key
;
fragment
.
appendChild
(
div
)
;
}
}
)
;
suppressed_toggles
.
forEach
(
function
(
key
)
{
let
div
=
document
.
createElement
(
"
div
"
)
;
div
.
setAttribute
(
"
class
"
"
suppress
"
)
;
div
.
setAttribute
(
"
id
"
key
)
;
div
.
textContent
=
key
;
fragment
.
appendChild
(
div
)
;
}
)
;
if
(
OS
=
=
=
"
WINNT
"
)
{
let
div
=
document
.
createElement
(
"
div
"
)
;
div
.
setAttribute
(
"
class
"
"
windows
"
)
;
div
.
setAttribute
(
"
id
"
"
-
moz
-
os
-
version
"
)
;
div
.
textContent
=
"
-
moz
-
os
-
version
"
;
fragment
.
appendChild
(
div
)
;
}
return
fragment
;
}
;
var
cssLine
=
function
(
query
clazz
id
color
)
{
return
"
media
"
+
query
+
"
{
.
"
+
clazz
+
"
#
"
+
id
+
"
{
background
-
color
:
"
+
color
+
"
;
}
}
\
n
"
;
}
;
var
constructQuery
=
function
(
key
val
)
{
return
Array
.
isArray
(
val
)
?
"
(
min
-
"
+
key
+
"
:
"
+
val
[
0
]
+
"
)
and
(
max
-
"
+
key
+
"
:
"
+
val
[
1
]
+
"
)
"
:
"
(
"
+
key
+
"
:
"
+
val
+
"
)
"
;
}
;
var
mediaQueryCSSLine
=
function
(
key
val
color
)
{
if
(
val
=
=
=
null
)
{
return
"
"
;
}
return
cssLine
(
constructQuery
(
key
val
)
"
spoof
"
key
color
)
;
}
;
var
suppressedMediaQueryCSSLine
=
function
(
key
color
suppressed
)
{
let
query
=
"
(
"
+
key
+
"
:
0
)
(
"
+
key
+
"
:
1
)
"
;
return
cssLine
(
query
"
suppress
"
key
color
)
;
}
;
var
generateCSSLines
=
function
(
resisting
)
{
let
lines
=
"
.
spoof
{
background
-
color
:
red
;
}
\
n
"
;
expected_values
.
forEach
(
function
(
[
key
offVal
onVal
]
)
{
lines
+
=
mediaQueryCSSLine
(
key
resisting
?
onVal
:
offVal
"
green
"
)
;
}
)
;
lines
+
=
"
.
suppress
{
background
-
color
:
"
+
(
resisting
?
"
green
"
:
"
red
"
)
+
"
;
}
\
n
"
;
suppressed_toggles
.
forEach
(
function
(
key
)
{
if
(
!
toggles_enabled_in_content
.
includes
(
key
)
&
&
!
resisting
&
&
!
is_chrome_window
)
{
lines
+
=
"
#
"
+
key
+
"
{
background
-
color
:
green
;
}
\
n
"
;
}
else
{
lines
+
=
suppressedMediaQueryCSSLine
(
key
"
green
"
)
;
}
}
)
;
if
(
OS
=
=
=
"
WINNT
"
)
{
lines
+
=
"
.
windows
{
background
-
color
:
"
+
(
resisting
?
"
green
"
:
"
red
"
)
+
"
;
}
\
n
"
;
lines
+
=
windows_versions
.
map
(
val
=
>
"
(
-
moz
-
os
-
version
:
"
+
val
+
"
)
"
)
.
join
(
"
"
)
+
"
{
#
-
moz
-
os
-
version
{
background
-
color
:
"
+
(
resisting
?
"
red
"
:
"
green
"
)
+
"
;
}
}
\
n
"
;
}
return
lines
;
}
;
var
green
=
(
function
(
)
{
let
temp
=
document
.
createElement
(
"
span
"
)
;
temp
.
style
.
backgroundColor
=
"
green
"
;
return
getComputedStyle
(
temp
)
.
backgroundColor
;
}
)
(
)
;
var
testCSS
=
function
(
resisting
)
{
document
.
getElementById
(
"
display
"
)
.
appendChild
(
generateHtmlLines
(
resisting
)
)
;
document
.
getElementById
(
"
test
-
css
"
)
.
textContent
=
generateCSSLines
(
resisting
)
;
let
cssTestDivs
=
document
.
querySelectorAll
(
"
.
spoof
.
suppress
"
)
;
for
(
let
div
of
cssTestDivs
)
{
let
color
=
window
.
getComputedStyle
(
div
)
.
backgroundColor
;
ok
(
color
=
=
=
green
"
CSS
for
'
"
+
div
.
id
+
"
'
"
)
;
}
}
;
var
testOSXFontSmoothing
=
function
(
resisting
)
{
let
div
=
document
.
createElement
(
"
div
"
)
;
div
.
style
.
MozOsxFontSmoothing
=
"
unset
"
;
let
readBack
=
window
.
getComputedStyle
(
div
)
.
MozOsxFontSmoothing
;
let
smoothingPref
=
SpecialPowers
.
getBoolPref
(
"
layout
.
css
.
osx
-
font
-
smoothing
.
enabled
"
false
)
;
is
(
readBack
resisting
?
"
"
:
(
smoothingPref
?
"
auto
"
:
"
"
)
"
-
moz
-
osx
-
font
-
smoothing
"
)
;
}
;
var
sleep
=
function
(
timeoutMs
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
window
.
setTimeout
(
resolve
)
;
}
)
;
}
;
var
testMediaQueriesInPictureElements
=
async
function
(
resisting
)
{
let
picture
=
document
.
createElementNS
(
HTML_NS
"
picture
"
)
;
for
(
let
[
key
offVal
onVal
]
of
expected_values
)
{
let
expected
=
resisting
?
onVal
:
offVal
;
if
(
expected
)
{
let
query
=
constructQuery
(
key
expected
)
;
let
source
=
document
.
createElementNS
(
HTML_NS
"
source
"
)
;
source
.
setAttribute
(
"
srcset
"
"
/
tests
/
layout
/
style
/
test
/
chrome
/
match
.
png
"
)
;
source
.
setAttribute
(
"
media
"
query
)
;
let
image
=
document
.
createElementNS
(
HTML_NS
"
img
"
)
;
image
.
setAttribute
(
"
title
"
key
+
"
:
"
+
expected
)
;
image
.
setAttribute
(
"
class
"
"
testImage
"
)
;
image
.
setAttribute
(
"
src
"
"
/
tests
/
layout
/
style
/
test
/
chrome
/
mismatch
.
png
"
)
;
image
.
setAttribute
(
"
alt
"
key
)
;
picture
.
appendChild
(
source
)
;
picture
.
appendChild
(
image
)
;
}
}
document
.
getElementById
(
"
pictures
"
)
.
appendChild
(
picture
)
;
var
testImages
=
document
.
getElementsByClassName
(
"
testImage
"
)
;
await
sleep
(
0
)
;
for
(
let
testImage
of
testImages
)
{
ok
(
testImage
.
currentSrc
.
endsWith
(
"
/
match
.
png
"
)
"
Media
query
'
"
+
testImage
.
title
+
"
'
in
picture
should
match
.
"
)
;
}
}
;
var
pushPref
=
function
(
key
value
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
key
value
]
]
}
resolve
)
;
}
)
;
}
;
var
test
=
async
function
(
isContent
)
{
for
(
prefValue
of
[
false
true
]
)
{
await
pushPref
(
"
privacy
.
resistFingerprinting
"
prefValue
)
;
let
resisting
=
prefValue
&
&
isContent
;
expected_values
.
forEach
(
function
(
[
key
offVal
onVal
]
)
{
testMatch
(
key
resisting
?
onVal
:
offVal
)
;
}
)
;
testToggles
(
resisting
)
;
if
(
OS
=
=
=
"
WINNT
"
)
{
testWindowsSpecific
(
resisting
"
-
moz
-
os
-
version
"
windows_versions
)
;
}
testCSS
(
resisting
)
;
if
(
OS
=
=
=
"
Darwin
"
)
{
testOSXFontSmoothing
(
resisting
)
;
}
await
testMediaQueriesInPictureElements
(
resisting
)
;
}
}
;
