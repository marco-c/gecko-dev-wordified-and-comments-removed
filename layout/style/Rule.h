#
ifndef
mozilla_css_Rule_h___
#
define
mozilla_css_Rule_h___
#
include
"
mozilla
/
dom
/
CSSRuleBinding
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsWrapperCache
.
h
"
struct
nsRuleData
;
template
<
class
T
>
struct
already_AddRefed
;
class
nsHTMLCSSStyleSheet
;
namespace
mozilla
{
namespace
css
{
class
GroupRule
;
class
Rule
:
public
nsISupports
public
nsWrapperCache
{
protected
:
Rule
(
StyleSheet
*
aSheet
Rule
*
aParentRule
uint32_t
aLineNumber
uint32_t
aColumnNumber
)
:
mSheet
(
aSheet
)
mParentRule
(
aParentRule
)
mLineNumber
(
aLineNumber
)
mColumnNumber
(
aColumnNumber
)
{
#
ifdef
DEBUG
if
(
mParentRule
)
{
int16_t
type
=
mParentRule
-
>
Type
(
)
;
MOZ_ASSERT
(
type
=
=
dom
:
:
CSSRule_Binding
:
:
MEDIA_RULE
|
|
type
=
=
dom
:
:
CSSRule_Binding
:
:
DOCUMENT_RULE
|
|
type
=
=
dom
:
:
CSSRule_Binding
:
:
SUPPORTS_RULE
|
|
type
=
=
dom
:
:
CSSRule_Binding
:
:
KEYFRAMES_RULE
)
;
}
#
endif
}
Rule
(
const
Rule
&
aCopy
)
:
mSheet
(
aCopy
.
mSheet
)
mParentRule
(
aCopy
.
mParentRule
)
mLineNumber
(
aCopy
.
mLineNumber
)
mColumnNumber
(
aCopy
.
mColumnNumber
)
{
}
virtual
~
Rule
(
)
=
default
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS
(
Rule
)
virtual
bool
IsCCLeaf
(
)
const
MOZ_MUST_OVERRIDE
;
#
ifdef
DEBUG
virtual
void
List
(
FILE
*
out
=
stdout
int32_t
aIndent
=
0
)
const
=
0
;
#
endif
StyleSheet
*
GetStyleSheet
(
)
const
{
return
mSheet
;
}
dom
:
:
Document
*
GetComposedDoc
(
)
const
{
return
mSheet
?
mSheet
-
>
GetComposedDoc
(
)
:
nullptr
;
}
virtual
void
DropSheetReference
(
)
;
void
DropParentRuleReference
(
)
{
mParentRule
=
nullptr
;
}
void
DropReferences
(
)
{
DropSheetReference
(
)
;
DropParentRuleReference
(
)
;
}
uint32_t
GetLineNumber
(
)
const
{
return
mLineNumber
;
}
uint32_t
GetColumnNumber
(
)
const
{
return
mColumnNumber
;
}
bool
IsReadOnly
(
)
const
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
)
const
MOZ_MUST_OVERRIDE
=
0
;
virtual
uint16_t
Type
(
)
const
=
0
;
virtual
void
GetCssText
(
nsAString
&
aCssText
)
const
=
0
;
void
SetCssText
(
const
nsAString
&
aCssText
)
;
Rule
*
GetParentRule
(
)
const
;
StyleSheet
*
GetParentStyleSheet
(
)
const
{
return
GetStyleSheet
(
)
;
}
nsINode
*
GetParentObject
(
)
const
{
if
(
!
mSheet
)
{
return
nullptr
;
}
auto
*
associated
=
mSheet
-
>
GetAssociatedDocumentOrShadowRoot
(
)
;
return
associated
?
&
associated
-
>
AsNode
(
)
:
nullptr
;
}
protected
:
bool
IsKnownLive
(
)
const
;
void
UnlinkDeclarationWrapper
(
nsWrapperCache
&
aDecl
)
;
StyleSheet
*
MOZ_NON_OWNING_REF
mSheet
;
Rule
*
MOZ_NON_OWNING_REF
mParentRule
;
uint32_t
mLineNumber
;
uint32_t
mColumnNumber
;
}
;
}
}
#
endif
