#
ifndef
mozilla_css_Rule_h___
#
define
mozilla_css_Rule_h___
#
include
"
mozilla
/
dom
/
CSSRuleBinding
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsWrapperCache
.
h
"
template
<
class
T
>
struct
already_AddRefed
;
namespace
mozilla
{
enum
class
StyleCssRuleType
:
uint8_t
;
namespace
css
{
class
GroupRule
;
class
Rule
:
public
nsISupports
public
nsWrapperCache
public
SupportsWeakPtr
{
protected
:
Rule
(
StyleSheet
*
aSheet
Rule
*
aParentRule
uint32_t
aLineNumber
uint32_t
aColumnNumber
)
:
mSheet
(
aSheet
)
mParentRule
(
aParentRule
)
mLineNumber
(
aLineNumber
)
mColumnNumber
(
aColumnNumber
)
{
#
ifdef
DEBUG
AssertParentRuleType
(
)
;
#
endif
}
#
ifdef
DEBUG
void
AssertParentRuleType
(
)
;
#
endif
Rule
(
const
Rule
&
aCopy
)
:
mSheet
(
aCopy
.
mSheet
)
mParentRule
(
aCopy
.
mParentRule
)
mLineNumber
(
aCopy
.
mLineNumber
)
mColumnNumber
(
aCopy
.
mColumnNumber
)
{
}
virtual
~
Rule
(
)
=
default
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_WRAPPERCACHE_CLASS
(
Rule
)
virtual
bool
IsCCLeaf
(
)
const
MOZ_MUST_OVERRIDE
;
virtual
bool
IsGroupRule
(
)
const
{
return
false
;
}
#
ifdef
DEBUG
virtual
void
List
(
FILE
*
out
=
stdout
int32_t
aIndent
=
0
)
const
=
0
;
#
endif
StyleSheet
*
GetStyleSheet
(
)
const
{
return
mSheet
;
}
virtual
void
DropSheetReference
(
)
;
void
DropParentRuleReference
(
)
{
mParentRule
=
nullptr
;
}
void
DropReferences
(
)
{
DropSheetReference
(
)
;
DropParentRuleReference
(
)
;
}
uint32_t
GetLineNumber
(
)
const
{
return
mLineNumber
;
}
uint32_t
GetColumnNumber
(
)
const
{
return
mColumnNumber
;
}
bool
IsReadOnly
(
)
const
;
bool
IsIncompleteImportRule
(
)
const
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
)
const
MOZ_MUST_OVERRIDE
=
0
;
virtual
StyleCssRuleType
Type
(
)
const
=
0
;
uint16_t
TypeForBindings
(
)
const
{
auto
type
=
uint16_t
(
Type
(
)
)
;
return
type
>
15
?
0
:
type
;
}
virtual
void
GetCssText
(
nsACString
&
aCssText
)
const
=
0
;
void
SetCssText
(
const
nsACString
&
aCssText
)
;
Rule
*
GetParentRule
(
)
const
;
StyleSheet
*
GetParentStyleSheet
(
)
const
{
return
GetStyleSheet
(
)
;
}
nsINode
*
GetAssociatedDocumentOrShadowRoot
(
)
const
{
if
(
!
mSheet
)
{
return
nullptr
;
}
auto
*
associated
=
mSheet
-
>
GetAssociatedDocumentOrShadowRoot
(
)
;
return
associated
?
&
associated
-
>
AsNode
(
)
:
nullptr
;
}
nsISupports
*
GetParentObject
(
)
const
{
return
mSheet
;
}
struct
ContainingRuleState
{
uint32_t
mContainingTypes
=
0
;
Maybe
<
StyleCssRuleType
>
mParseRelativeType
;
static
ContainingRuleState
From
(
Rule
*
aRule
)
{
return
aRule
?
aRule
-
>
GetContainingRuleStateForParsing
(
)
:
ContainingRuleState
(
)
;
}
}
;
ContainingRuleState
GetContainingRuleStateForParsing
(
)
const
;
protected
:
bool
IsKnownLive
(
)
const
;
void
UnlinkDeclarationWrapper
(
nsWrapperCache
&
aDecl
)
;
StyleSheet
*
MOZ_NON_OWNING_REF
mSheet
;
Rule
*
MOZ_NON_OWNING_REF
mParentRule
;
uint32_t
mLineNumber
;
uint32_t
mColumnNumber
;
}
;
}
}
#
endif
