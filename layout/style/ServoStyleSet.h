#
ifndef
mozilla_ServoStyleSet_h
#
define
mozilla_ServoStyleSet_h
#
include
"
mozilla
/
AtomArray
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MediaFeatureChange
.
h
"
#
include
"
mozilla
/
PostTraversalTask
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
ServoElementSnapshot
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
SheetType
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Element
;
}
class
CSSStyleSheet
;
class
ServoRestyleManager
;
class
ServoStyleSheet
;
struct
Keyframe
;
class
ServoElementSnapshotTable
;
class
ServoStyleContext
;
class
ServoStyleRuleMap
;
}
class
nsCSSCounterStyleRule
;
class
nsIContent
;
class
nsIDocument
;
class
nsPresContext
;
struct
nsTimingFunction
;
struct
RawServoRuleNode
;
struct
TreeMatchContext
;
namespace
mozilla
{
enum
class
StylistState
:
uint8_t
{
NotDirty
=
0
StyleSheetsDirty
=
1
<
<
0
XBLStyleSheetsDirty
=
1
<
<
1
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
StylistState
)
enum
class
OriginFlags
:
uint8_t
{
UserAgent
=
0x01
User
=
0x02
Author
=
0x04
All
=
0x07
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
OriginFlags
)
class
ServoStyleSet
{
friend
class
ServoRestyleManager
;
typedef
ServoElementSnapshotTable
SnapshotTable
;
public
:
static
bool
IsInServoTraversal
(
)
{
return
mozilla
:
:
IsInServoTraversal
(
)
;
}
#
ifdef
DEBUG
static
bool
IsCurrentThreadInServoTraversal
(
)
;
#
endif
static
ServoStyleSet
*
Current
(
)
{
return
sInServoTraversal
;
}
enum
class
Kind
:
uint8_t
{
Master
ForXBL
}
;
explicit
ServoStyleSet
(
Kind
aKind
)
;
~
ServoStyleSet
(
)
;
static
UniquePtr
<
ServoStyleSet
>
CreateXBLServoStyleSet
(
nsPresContext
*
aPresContext
const
nsTArray
<
RefPtr
<
ServoStyleSheet
>
>
&
aNewSheets
)
;
void
Init
(
nsPresContext
*
aPresContext
)
;
void
BeginShutdown
(
)
{
}
void
Shutdown
(
)
;
void
RuleAdded
(
ServoStyleSheet
&
css
:
:
Rule
&
)
;
void
RuleRemoved
(
ServoStyleSheet
&
css
:
:
Rule
&
)
;
void
RuleChanged
(
ServoStyleSheet
&
aSheet
css
:
:
Rule
*
aRule
)
;
void
RecordStyleSheetChange
(
ServoStyleSheet
*
StyleSheet
:
:
ChangeType
)
{
}
void
InvalidateStyleForDocumentStateChanges
(
EventStates
aStatesChanged
)
;
void
RecordShadowStyleChange
(
dom
:
:
ShadowRoot
*
aShadowRoot
)
{
MarkOriginsDirty
(
OriginFlags
:
:
All
)
;
}
bool
StyleSheetsHaveChanged
(
)
const
{
return
StylistNeedsUpdate
(
)
;
}
nsRestyleHint
MediumFeaturesChanged
(
MediaFeatureChangeReason
)
;
nscoord
EvaluateSourceSizeList
(
const
RawServoSourceSizeList
*
aSourceSizeList
)
const
{
return
Servo_SourceSizeList_Evaluate
(
mRawSet
.
get
(
)
aSourceSizeList
)
;
}
void
InvalidateStyleForCSSRuleChanges
(
)
;
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
)
const
;
const
RawServoStyleSet
*
RawSet
(
)
const
{
return
mRawSet
.
get
(
)
;
}
bool
GetAuthorStyleDisabled
(
)
const
{
return
mAuthorStyleDisabled
;
}
void
SetAuthorStyleDisabled
(
bool
aStyleDisabled
)
;
void
BeginUpdate
(
)
;
nsresult
EndUpdate
(
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveStyleFor
(
dom
:
:
Element
*
aElement
ServoStyleContext
*
aParentContext
LazyComputeBehavior
aMayCompute
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveStyleForText
(
nsIContent
*
aTextNode
ServoStyleContext
*
aParentContext
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveStyleForFirstLetterContinuation
(
ServoStyleContext
*
aParentContext
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveStyleForPlaceholder
(
)
;
already_AddRefed
<
ServoStyleContext
>
ResolvePseudoElementStyle
(
dom
:
:
Element
*
aOriginatingElement
CSSPseudoElementType
aType
ServoStyleContext
*
aParentContext
dom
:
:
Element
*
aPseudoElement
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveStyleLazily
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
StyleRuleInclusion
aRules
=
StyleRuleInclusion
:
:
All
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveInheritingAnonymousBoxStyle
(
nsAtom
*
aPseudoTag
ServoStyleContext
*
aParentContext
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveNonInheritingAnonymousBoxStyle
(
nsAtom
*
aPseudoTag
)
;
#
ifdef
MOZ_XUL
already_AddRefed
<
ServoStyleContext
>
ResolveXULTreePseudoStyle
(
dom
:
:
Element
*
aParentElement
nsICSSAnonBoxPseudo
*
aPseudoTag
ServoStyleContext
*
aParentContext
const
AtomArray
&
aInputWord
)
;
#
endif
nsresult
AppendStyleSheet
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
;
nsresult
PrependStyleSheet
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
;
nsresult
RemoveStyleSheet
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
;
nsresult
ReplaceSheets
(
SheetType
aType
const
nsTArray
<
RefPtr
<
ServoStyleSheet
>
>
&
aNewSheets
)
;
nsresult
InsertStyleSheetBefore
(
SheetType
aType
ServoStyleSheet
*
aNewSheet
ServoStyleSheet
*
aReferenceSheet
)
;
int32_t
SheetCount
(
SheetType
aType
)
const
;
ServoStyleSheet
*
StyleSheetAt
(
SheetType
aType
int32_t
aIndex
)
const
;
void
AppendAllXBLStyleSheets
(
nsTArray
<
StyleSheet
*
>
&
aArray
)
const
;
template
<
typename
Func
>
void
EnumerateStyleSheetArrays
(
Func
aCallback
)
const
{
for
(
const
auto
&
sheetArray
:
mSheets
)
{
aCallback
(
sheetArray
)
;
}
}
nsresult
RemoveDocStyleSheet
(
ServoStyleSheet
*
aSheet
)
;
nsresult
AddDocStyleSheet
(
ServoStyleSheet
*
aSheet
nsIDocument
*
aDocument
)
;
already_AddRefed
<
ServoStyleContext
>
ProbePseudoElementStyle
(
dom
:
:
Element
*
aOriginatingElement
CSSPseudoElementType
aType
ServoStyleContext
*
aParentContext
)
;
bool
StyleDocument
(
ServoTraversalFlags
aFlags
)
;
void
StyleNewSubtree
(
dom
:
:
Element
*
aRoot
)
;
void
UpdateStylistIfNeeded
(
)
{
if
(
StylistNeedsUpdate
(
)
)
{
UpdateStylist
(
)
;
}
}
void
MaybeGCRuleTree
(
)
;
static
bool
MayTraverseFrom
(
const
dom
:
:
Element
*
aElement
)
;
#
ifdef
DEBUG
void
AssertTreeIsClean
(
)
;
#
else
void
AssertTreeIsClean
(
)
{
}
#
endif
void
ClearCachedStyleData
(
)
;
void
CompatibilityModeChanged
(
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveServoStyle
(
dom
:
:
Element
*
aElement
)
;
bool
GetKeyframesForName
(
nsAtom
*
aName
const
nsTimingFunction
&
aTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
;
nsTArray
<
ComputedKeyframeValues
>
GetComputedKeyframeValuesFor
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
dom
:
:
Element
*
aElement
const
ServoStyleContext
*
aContext
)
;
void
GetAnimationValues
(
RawServoDeclarationBlock
*
aDeclarations
dom
:
:
Element
*
aElement
const
ServoStyleContext
*
aContext
nsTArray
<
RefPtr
<
RawServoAnimationValue
>
>
&
aAnimationValues
)
;
bool
AppendFontFaceRules
(
nsTArray
<
nsFontFaceRuleContainer
>
&
aArray
)
;
nsCSSCounterStyleRule
*
CounterStyleRuleForName
(
nsAtom
*
aName
)
;
already_AddRefed
<
gfxFontFeatureValueSet
>
BuildFontFeatureValueSet
(
)
;
already_AddRefed
<
ServoStyleContext
>
GetBaseContextForElement
(
dom
:
:
Element
*
aElement
nsPresContext
*
aPresContext
const
ServoStyleContext
*
aStyle
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveServoStyleByAddingAnimation
(
dom
:
:
Element
*
aElement
const
ServoStyleContext
*
aStyle
RawServoAnimationValue
*
aAnimationValue
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveForDeclarations
(
const
ServoStyleContext
*
aParentOrNull
RawServoDeclarationBlockBorrowed
aDeclarations
)
;
already_AddRefed
<
RawServoAnimationValue
>
ComputeAnimationValue
(
dom
:
:
Element
*
aElement
RawServoDeclarationBlock
*
aDeclaration
const
ServoStyleContext
*
aContext
)
;
void
AppendTask
(
PostTraversalTask
aTask
)
{
MOZ_ASSERT
(
IsInServoTraversal
(
)
)
;
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
mPostTraversalTasks
.
AppendElement
(
aTask
)
;
}
bool
EnsureUniqueInnerOnCSSSheets
(
)
;
void
SetNeedsRestyleAfterEnsureUniqueInner
(
)
{
mNeedsRestyleAfterEnsureUniqueInner
=
true
;
}
ServoStyleRuleMap
*
StyleRuleMap
(
)
;
bool
MightHaveAttributeDependency
(
const
dom
:
:
Element
&
aElement
nsAtom
*
aAttribute
)
const
;
bool
HasStateDependency
(
const
dom
:
:
Element
&
aElement
EventStates
aState
)
const
;
bool
HasDocumentStateDependency
(
EventStates
aState
)
const
;
already_AddRefed
<
ServoStyleContext
>
ReparentStyleContext
(
ServoStyleContext
*
aStyleContext
ServoStyleContext
*
aNewParent
ServoStyleContext
*
aNewParentIgnoringFirstLine
ServoStyleContext
*
aNewLayoutParent
Element
*
aElement
)
;
bool
IsMaster
(
)
const
{
return
mKind
=
=
Kind
:
:
Master
;
}
bool
IsForXBL
(
)
const
{
return
mKind
=
=
Kind
:
:
ForXBL
;
}
private
:
friend
class
AutoSetInServoTraversal
;
friend
class
AutoPrepareTraversal
;
bool
ShouldTraverseInParallel
(
)
const
;
const
SnapshotTable
&
Snapshots
(
)
;
void
ResolveMappedAttrDeclarationBlocks
(
)
;
void
ClearNonInheritingStyleContexts
(
)
;
void
PreTraverse
(
ServoTraversalFlags
aFlags
dom
:
:
Element
*
aRoot
=
nullptr
)
;
void
PreTraverseSync
(
)
;
void
MarkOriginsDirty
(
OriginFlags
aChangedOrigins
)
;
void
SetStylistStyleSheetsDirty
(
)
;
void
SetStylistXBLStyleSheetsDirty
(
)
;
bool
StylistNeedsUpdate
(
)
const
{
return
mStylistState
!
=
StylistState
:
:
NotDirty
;
}
void
UpdateStylist
(
)
;
already_AddRefed
<
ServoStyleContext
>
ResolveStyleLazilyInternal
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
StyleRuleInclusion
aRules
=
StyleRuleInclusion
:
:
All
)
;
void
RunPostTraversalTasks
(
)
;
void
PrependSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
;
void
AppendSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
;
void
InsertSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
ServoStyleSheet
*
aBeforeSheet
)
;
void
RemoveSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
;
const
Kind
mKind
;
nsIDocument
*
mDocument
;
const
nsPresContext
*
GetPresContext
(
)
const
{
return
const_cast
<
ServoStyleSet
*
>
(
this
)
-
>
GetPresContext
(
)
;
}
nsPresContext
*
GetPresContext
(
)
;
UniquePtr
<
RawServoStyleSet
>
mRawSet
;
EnumeratedArray
<
SheetType
SheetType
:
:
Count
nsTArray
<
RefPtr
<
ServoStyleSheet
>
>
>
mSheets
;
bool
mAuthorStyleDisabled
;
StylistState
mStylistState
;
uint64_t
mUserFontSetUpdateGeneration
;
uint32_t
mUserFontCacheUpdateGeneration
;
bool
mNeedsRestyleAfterEnsureUniqueInner
;
EnumeratedArray
<
nsCSSAnonBoxes
:
:
NonInheriting
nsCSSAnonBoxes
:
:
NonInheriting
:
:
_Count
RefPtr
<
ServoStyleContext
>
>
mNonInheritingStyleContexts
;
nsTArray
<
PostTraversalTask
>
mPostTraversalTasks
;
UniquePtr
<
ServoStyleRuleMap
>
mStyleRuleMap
;
}
;
class
UACacheReporter
final
:
public
nsIMemoryReporter
{
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
private
:
~
UACacheReporter
(
)
{
}
}
;
}
#
endif
