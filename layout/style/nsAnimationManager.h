#
ifndef
nsAnimationManager_h_
#
define
nsAnimationManager_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
AnimationCommon
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
class
nsIGlobalObject
;
class
nsStyleContext
;
namespace
mozilla
{
namespace
css
{
class
Declaration
;
}
namespace
dom
{
class
Promise
;
}
struct
AnimationEventInfo
{
nsRefPtr
<
mozilla
:
:
dom
:
:
Element
>
mElement
;
mozilla
:
:
InternalAnimationEvent
mEvent
;
AnimationEventInfo
(
mozilla
:
:
dom
:
:
Element
*
aElement
const
nsSubstring
&
aAnimationName
EventMessage
aMessage
const
mozilla
:
:
StickyTimeDuration
&
aElapsedTime
nsCSSPseudoElements
:
:
Type
aPseudoType
)
:
mElement
(
aElement
)
mEvent
(
true
aMessage
)
{
mEvent
.
animationName
=
aAnimationName
;
mEvent
.
elapsedTime
=
aElapsedTime
.
ToSeconds
(
)
;
mEvent
.
pseudoElement
=
AnimationCollection
:
:
PseudoTypeAsString
(
aPseudoType
)
;
}
AnimationEventInfo
(
const
AnimationEventInfo
&
aOther
)
:
mElement
(
aOther
.
mElement
)
mEvent
(
true
aOther
.
mEvent
.
mMessage
)
{
mEvent
.
AssignAnimationEventData
(
aOther
.
mEvent
false
)
;
}
}
;
namespace
dom
{
class
CSSAnimation
final
:
public
Animation
{
public
:
explicit
CSSAnimation
(
nsIGlobalObject
*
aGlobal
const
nsSubstring
&
aAnimationName
)
:
dom
:
:
Animation
(
aGlobal
)
mAnimationName
(
aAnimationName
)
mIsStylePaused
(
false
)
mPauseShouldStick
(
false
)
mNeedsNewAnimationIndexWhenRun
(
false
)
mPreviousPhaseOrIteration
(
PREVIOUS_PHASE_BEFORE
)
{
MOZ_ASSERT
(
!
mAnimationName
.
IsEmpty
(
)
"
animation
-
name
should
not
be
empty
"
)
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
CSSAnimation
*
AsCSSAnimation
(
)
override
{
return
this
;
}
const
CSSAnimation
*
AsCSSAnimation
(
)
const
override
{
return
this
;
}
void
GetAnimationName
(
nsString
&
aRetVal
)
const
{
aRetVal
=
mAnimationName
;
}
const
nsString
&
AnimationName
(
)
const
{
return
mAnimationName
;
}
virtual
Promise
*
GetReady
(
ErrorResult
&
aRv
)
override
;
virtual
void
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
override
;
virtual
void
Pause
(
ErrorResult
&
aRv
)
override
;
virtual
AnimationPlayState
PlayStateFromJS
(
)
const
override
;
virtual
void
PlayFromJS
(
ErrorResult
&
aRv
)
override
;
void
PlayFromStyle
(
)
;
void
PauseFromStyle
(
)
;
void
CancelFromStyle
(
)
override
{
mOwningElement
=
OwningElementRef
(
)
;
Animation
:
:
CancelFromStyle
(
)
;
MOZ_ASSERT
(
mAnimationIndex
=
=
kNoIndex
)
;
}
void
Tick
(
)
override
;
void
QueueEvents
(
)
;
bool
HasEndEventToQueue
(
)
const
override
;
bool
IsStylePaused
(
)
const
{
return
mIsStylePaused
;
}
bool
HasLowerCompositeOrderThan
(
const
Animation
&
aOther
)
const
override
;
bool
IsUsingCustomCompositeOrder
(
)
const
override
{
return
mOwningElement
.
IsSet
(
)
;
}
void
SetAnimationIndex
(
uint64_t
aIndex
)
{
MOZ_ASSERT
(
IsUsingCustomCompositeOrder
(
)
)
;
mAnimationIndex
=
aIndex
;
}
void
CopyAnimationIndex
(
const
CSSAnimation
&
aOther
)
{
MOZ_ASSERT
(
IsUsingCustomCompositeOrder
(
)
&
&
aOther
.
IsUsingCustomCompositeOrder
(
)
)
;
mAnimationIndex
=
aOther
.
mAnimationIndex
;
}
void
SetOwningElement
(
const
OwningElementRef
&
aElement
)
{
mOwningElement
=
aElement
;
}
bool
mInEffectForCascadeResults
;
protected
:
virtual
~
CSSAnimation
(
)
{
MOZ_ASSERT
(
!
mOwningElement
.
IsSet
(
)
"
Owning
element
should
be
cleared
"
"
before
a
CSS
animation
is
destroyed
"
)
;
}
virtual
CommonAnimationManager
*
GetAnimationManager
(
)
const
override
;
nsString
mAnimationName
;
OwningElementRef
mOwningElement
;
bool
mIsStylePaused
;
bool
mPauseShouldStick
;
bool
mNeedsNewAnimationIndexWhenRun
;
enum
{
PREVIOUS_PHASE_BEFORE
=
uint64_t
(
-
1
)
PREVIOUS_PHASE_AFTER
=
uint64_t
(
-
2
)
}
;
uint64_t
mPreviousPhaseOrIteration
;
}
;
}
}
class
nsAnimationManager
final
:
public
mozilla
:
:
CommonAnimationManager
{
public
:
explicit
nsAnimationManager
(
nsPresContext
*
aPresContext
)
:
mozilla
:
:
CommonAnimationManager
(
aPresContext
)
{
}
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsAnimationManager
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
void
MaybeUpdateCascadeResults
(
mozilla
:
:
AnimationCollection
*
aCollection
)
;
virtual
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
MOZ_MUST_OVERRIDE
override
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
MOZ_MUST_OVERRIDE
override
;
nsIStyleRule
*
CheckAnimationRule
(
nsStyleContext
*
aStyleContext
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
void
QueueEvent
(
mozilla
:
:
AnimationEventInfo
&
&
aEventInfo
)
{
mEventDispatcher
.
QueueEvent
(
mozilla
:
:
Forward
<
mozilla
:
:
AnimationEventInfo
>
(
aEventInfo
)
)
;
}
void
DispatchEvents
(
)
{
mEventDispatcher
.
DispatchEvents
(
mPresContext
)
;
}
void
ClearEventQueue
(
)
{
mEventDispatcher
.
ClearEventQueue
(
)
;
}
void
StopAnimationsForElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsCSSPseudoElements
:
:
Type
aPseudoType
)
;
protected
:
virtual
~
nsAnimationManager
(
)
{
}
virtual
nsIAtom
*
GetAnimationsAtom
(
)
override
{
return
nsGkAtoms
:
:
animationsProperty
;
}
virtual
nsIAtom
*
GetAnimationsBeforeAtom
(
)
override
{
return
nsGkAtoms
:
:
animationsOfBeforeProperty
;
}
virtual
nsIAtom
*
GetAnimationsAfterAtom
(
)
override
{
return
nsGkAtoms
:
:
animationsOfAfterProperty
;
}
virtual
bool
IsAnimationManager
(
)
override
{
return
true
;
}
mozilla
:
:
DelayedEventDispatcher
<
mozilla
:
:
AnimationEventInfo
>
mEventDispatcher
;
private
:
void
BuildAnimations
(
nsStyleContext
*
aStyleContext
mozilla
:
:
dom
:
:
Element
*
aTarget
mozilla
:
:
dom
:
:
AnimationTimeline
*
aTimeline
mozilla
:
:
AnimationPtrArray
&
aAnimations
)
;
bool
BuildSegment
(
InfallibleTArray
<
mozilla
:
:
AnimationPropertySegment
>
&
aSegments
nsCSSProperty
aProperty
const
mozilla
:
:
StyleAnimation
&
aAnimation
float
aFromKey
nsStyleContext
*
aFromContext
mozilla
:
:
css
:
:
Declaration
*
aFromDeclaration
float
aToKey
nsStyleContext
*
aToContext
)
;
static
void
UpdateCascadeResults
(
nsStyleContext
*
aStyleContext
mozilla
:
:
AnimationCollection
*
aElementAnimations
)
;
}
;
#
endif
