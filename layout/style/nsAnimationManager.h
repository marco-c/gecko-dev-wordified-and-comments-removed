#
ifndef
nsAnimationManager_h_
#
define
nsAnimationManager_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
AnimationCommon
.
h
"
#
include
"
mozilla
/
dom
/
CSSAnimation
.
h
"
#
include
"
mozilla
/
Keyframe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTHashSet
.
h
"
struct
nsStyleDisplay
;
class
ServoCSSAnimationBuilder
;
namespace
mozilla
{
class
ComputedStyle
;
enum
class
PseudoStyleType
:
uint8_t
;
struct
NonOwningAnimationTarget
;
}
class
nsAnimationManager
final
:
public
mozilla
:
:
CommonAnimationManager
<
mozilla
:
:
dom
:
:
CSSAnimation
>
{
public
:
explicit
nsAnimationManager
(
nsPresContext
*
aPresContext
)
:
mozilla
:
:
CommonAnimationManager
<
mozilla
:
:
dom
:
:
CSSAnimation
>
(
aPresContext
)
{
}
typedef
mozilla
:
:
AnimationCollection
<
mozilla
:
:
dom
:
:
CSSAnimation
>
CSSAnimationCollection
;
typedef
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
CSSAnimation
>
>
OwningCSSAnimationPtrArray
;
~
nsAnimationManager
(
)
override
=
default
;
void
UpdateAnimations
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
PseudoStyleType
aPseudoType
const
mozilla
:
:
ComputedStyle
*
aComputedValues
)
;
template
<
class
IterType
class
TimingFunctionType
>
static
bool
FindMatchingKeyframe
(
IterType
&
&
aIter
double
aOffset
const
TimingFunctionType
&
aTimingFunctionToMatch
size_t
&
aIndex
)
{
aIndex
=
0
;
for
(
mozilla
:
:
Keyframe
&
keyframe
:
aIter
)
{
if
(
keyframe
.
mOffset
.
value
(
)
!
=
aOffset
)
{
break
;
}
if
(
keyframe
.
mTimingFunction
=
=
aTimingFunctionToMatch
)
{
return
true
;
}
+
+
aIndex
;
}
return
false
;
}
bool
AnimationMayBeReferenced
(
nsAtom
*
aName
)
const
{
return
mMaybeReferencedAnimations
.
Contains
(
aName
)
;
}
private
:
nsTHashSet
<
RefPtr
<
nsAtom
>
>
mMaybeReferencedAnimations
;
void
DoUpdateAnimations
(
const
mozilla
:
:
NonOwningAnimationTarget
&
aTarget
const
nsStyleDisplay
&
aStyleDisplay
ServoCSSAnimationBuilder
&
aBuilder
)
;
}
;
#
endif
