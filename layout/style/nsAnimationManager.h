#
ifndef
nsAnimationManager_h_
#
define
nsAnimationManager_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
AnimationCommon
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
Keyframe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsRFPService
.
h
"
class
nsIGlobalObject
;
class
nsStyleContext
;
class
ServoComputedData
;
struct
nsStyleDisplay
;
namespace
mozilla
{
namespace
css
{
class
Declaration
;
}
namespace
dom
{
class
KeyframeEffectReadOnly
;
class
Promise
;
}
class
GeckoStyleContext
;
class
ServoStyleContext
;
enum
class
CSSPseudoElementType
:
uint8_t
;
struct
NonOwningAnimationTarget
;
struct
AnimationEventInfo
{
RefPtr
<
dom
:
:
Element
>
mElement
;
RefPtr
<
dom
:
:
Animation
>
mAnimation
;
InternalAnimationEvent
mEvent
;
TimeStamp
mTimeStamp
;
AnimationEventInfo
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
EventMessage
aMessage
nsAtom
*
aAnimationName
const
StickyTimeDuration
&
aElapsedTime
const
TimeStamp
&
aTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mElement
(
aElement
)
mAnimation
(
aAnimation
)
mEvent
(
true
aMessage
)
mTimeStamp
(
aTimeStamp
)
{
aAnimationName
-
>
ToString
(
mEvent
.
mAnimationName
)
;
mEvent
.
mElapsedTime
=
nsRFPService
:
:
ReduceTimePrecisionAsSecs
(
aElapsedTime
.
ToSeconds
(
)
)
;
mEvent
.
mPseudoElement
=
AnimationCollection
<
dom
:
:
CSSAnimation
>
:
:
PseudoTypeAsString
(
aPseudoType
)
;
}
AnimationEventInfo
(
const
AnimationEventInfo
&
aOther
)
:
mElement
(
aOther
.
mElement
)
mAnimation
(
aOther
.
mAnimation
)
mEvent
(
true
aOther
.
mEvent
.
mMessage
)
mTimeStamp
(
aOther
.
mTimeStamp
)
{
mEvent
.
AssignAnimationEventData
(
aOther
.
mEvent
false
)
;
}
}
;
namespace
dom
{
class
CSSAnimation
final
:
public
Animation
{
public
:
explicit
CSSAnimation
(
nsIGlobalObject
*
aGlobal
nsAtom
*
aAnimationName
)
:
dom
:
:
Animation
(
aGlobal
)
mAnimationName
(
aAnimationName
)
mIsStylePaused
(
false
)
mPauseShouldStick
(
false
)
mNeedsNewAnimationIndexWhenRun
(
false
)
mPreviousPhase
(
ComputedTiming
:
:
AnimationPhase
:
:
Idle
)
mPreviousIteration
(
0
)
{
MOZ_ASSERT
(
mAnimationName
!
=
nsGkAtoms
:
:
_empty
"
animation
-
name
should
not
be
'
none
'
"
)
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
CSSAnimation
*
AsCSSAnimation
(
)
override
{
return
this
;
}
const
CSSAnimation
*
AsCSSAnimation
(
)
const
override
{
return
this
;
}
void
GetAnimationName
(
nsString
&
aRetVal
)
const
{
mAnimationName
-
>
ToString
(
aRetVal
)
;
}
nsAtom
*
AnimationName
(
)
const
{
return
mAnimationName
;
}
virtual
Promise
*
GetReady
(
ErrorResult
&
aRv
)
override
;
virtual
void
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
override
;
virtual
void
Pause
(
ErrorResult
&
aRv
)
override
;
AnimationPlayState
PlayStateFromJS
(
)
const
override
;
bool
PendingFromJS
(
)
const
override
;
void
PlayFromJS
(
ErrorResult
&
aRv
)
override
;
void
PlayFromStyle
(
)
;
void
PauseFromStyle
(
)
;
void
CancelFromStyle
(
)
override
{
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
true
;
Animation
:
:
CancelFromStyle
(
)
;
mOwningElement
=
OwningElementRef
(
)
;
}
void
Tick
(
)
override
;
void
QueueEvents
(
StickyTimeDuration
aActiveTime
=
StickyTimeDuration
(
)
)
;
bool
IsStylePaused
(
)
const
{
return
mIsStylePaused
;
}
bool
HasLowerCompositeOrderThan
(
const
CSSAnimation
&
aOther
)
const
;
void
SetAnimationIndex
(
uint64_t
aIndex
)
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
)
;
if
(
IsRelevant
(
)
&
&
mAnimationIndex
!
=
aIndex
)
{
nsNodeUtils
:
:
AnimationChanged
(
this
)
;
PostUpdate
(
)
;
}
mAnimationIndex
=
aIndex
;
}
void
SetOwningElement
(
const
OwningElementRef
&
aElement
)
{
mOwningElement
=
aElement
;
}
bool
IsTiedToMarkup
(
)
const
{
return
mOwningElement
.
IsSet
(
)
;
}
void
MaybeQueueCancelEvent
(
StickyTimeDuration
aActiveTime
)
override
{
QueueEvents
(
aActiveTime
)
;
}
protected
:
virtual
~
CSSAnimation
(
)
{
MOZ_ASSERT
(
!
mOwningElement
.
IsSet
(
)
"
Owning
element
should
be
cleared
"
"
before
a
CSS
animation
is
destroyed
"
)
;
}
void
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
override
;
TimeDuration
InitialAdvance
(
)
const
{
return
mEffect
?
std
:
:
max
(
TimeDuration
(
)
mEffect
-
>
SpecifiedTiming
(
)
.
Delay
(
)
*
-
1
)
:
TimeDuration
(
)
;
}
RefPtr
<
nsAtom
>
mAnimationName
;
OwningElementRef
mOwningElement
;
bool
mIsStylePaused
;
bool
mPauseShouldStick
;
bool
mNeedsNewAnimationIndexWhenRun
;
ComputedTiming
:
:
AnimationPhase
mPreviousPhase
;
uint64_t
mPreviousIteration
;
}
;
}
template
<
>
struct
AnimationTypeTraits
<
dom
:
:
CSSAnimation
>
{
static
nsAtom
*
ElementPropertyAtom
(
)
{
return
nsGkAtoms
:
:
animationsProperty
;
}
static
nsAtom
*
BeforePropertyAtom
(
)
{
return
nsGkAtoms
:
:
animationsOfBeforeProperty
;
}
static
nsAtom
*
AfterPropertyAtom
(
)
{
return
nsGkAtoms
:
:
animationsOfAfterProperty
;
}
}
;
}
class
nsAnimationManager
final
:
public
mozilla
:
:
CommonAnimationManager
<
mozilla
:
:
dom
:
:
CSSAnimation
>
{
public
:
explicit
nsAnimationManager
(
nsPresContext
*
aPresContext
)
:
mozilla
:
:
CommonAnimationManager
<
mozilla
:
:
dom
:
:
CSSAnimation
>
(
aPresContext
)
{
}
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
nsAnimationManager
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
nsAnimationManager
)
typedef
mozilla
:
:
AnimationCollection
<
mozilla
:
:
dom
:
:
CSSAnimation
>
CSSAnimationCollection
;
typedef
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
CSSAnimation
>
>
OwningCSSAnimationPtrArray
;
void
UpdateAnimations
(
mozilla
:
:
GeckoStyleContext
*
aStyleContext
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
void
UpdateAnimations
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
CSSPseudoElementType
aPseudoType
const
mozilla
:
:
ServoStyleContext
*
aComputedValues
)
;
void
QueueEvent
(
mozilla
:
:
AnimationEventInfo
&
&
aEventInfo
)
{
mEventDispatcher
.
QueueEvent
(
mozilla
:
:
Forward
<
mozilla
:
:
AnimationEventInfo
>
(
aEventInfo
)
)
;
}
void
DispatchEvents
(
)
{
RefPtr
<
nsAnimationManager
>
kungFuDeathGrip
(
this
)
;
mEventDispatcher
.
DispatchEvents
(
mPresContext
)
;
}
void
SortEvents
(
)
{
mEventDispatcher
.
SortEvents
(
)
;
}
void
ClearEventQueue
(
)
{
mEventDispatcher
.
ClearEventQueue
(
)
;
}
template
<
class
IterType
class
TimingFunctionType
>
static
bool
FindMatchingKeyframe
(
IterType
&
&
aIter
double
aOffset
const
TimingFunctionType
&
aTimingFunctionToMatch
size_t
&
aIndex
)
{
aIndex
=
0
;
for
(
mozilla
:
:
Keyframe
&
keyframe
:
aIter
)
{
if
(
keyframe
.
mOffset
.
value
(
)
!
=
aOffset
)
{
break
;
}
if
(
keyframe
.
mTimingFunction
=
=
aTimingFunctionToMatch
)
{
return
true
;
}
+
+
aIndex
;
}
return
false
;
}
protected
:
~
nsAnimationManager
(
)
override
=
default
;
private
:
template
<
class
BuilderType
>
void
DoUpdateAnimations
(
const
mozilla
:
:
NonOwningAnimationTarget
&
aTarget
const
nsStyleDisplay
&
aStyleDisplay
BuilderType
&
aBuilder
)
;
mozilla
:
:
DelayedEventDispatcher
<
mozilla
:
:
AnimationEventInfo
>
mEventDispatcher
;
}
;
#
endif
