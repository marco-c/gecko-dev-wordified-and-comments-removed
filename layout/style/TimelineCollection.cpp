#
include
"
TimelineCollection
.
h
"
#
include
"
mozilla
/
ElementAnimationData
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ScrollTimeline
.
h
"
#
include
"
mozilla
/
dom
/
ViewTimeline
.
h
"
#
include
<
type_traits
>
namespace
mozilla
{
template
<
class
TimelineType
>
TimelineCollection
<
TimelineType
>
:
:
~
TimelineCollection
(
)
{
MOZ_COUNT_DTOR
(
TimelineCollection
)
;
LinkedListElement
<
SelfType
>
:
:
remove
(
)
;
}
template
<
class
TimelineType
>
void
TimelineCollection
<
TimelineType
>
:
:
Destroy
(
)
{
auto
*
data
=
mElement
.
GetAnimationData
(
)
;
MOZ_ASSERT
(
data
)
;
if
constexpr
(
std
:
:
is_same_v
<
TimelineType
dom
:
:
ScrollTimeline
>
)
{
MOZ_ASSERT
(
data
-
>
GetScrollTimelineCollection
(
mPseudo
.
mType
)
=
=
this
)
;
data
-
>
ClearScrollTimelineCollectionFor
(
mPseudo
.
mType
)
;
}
else
if
constexpr
(
std
:
:
is_same_v
<
TimelineType
dom
:
:
ViewTimeline
>
)
{
MOZ_ASSERT
(
data
-
>
GetViewTimelineCollection
(
mPseudo
.
mType
)
=
=
this
)
;
data
-
>
ClearViewTimelineCollectionFor
(
mPseudo
.
mType
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
TimelienType
"
)
;
}
}
template
<
class
TimelineType
>
TimelineCollection
<
TimelineType
>
*
TimelineCollection
<
TimelineType
>
:
:
Get
(
const
dom
:
:
Element
*
aElement
const
PseudoStyleRequest
&
aPseudoRequest
)
{
MOZ_ASSERT
(
aElement
)
;
auto
*
data
=
aElement
-
>
GetAnimationData
(
)
;
if
(
!
data
)
{
return
nullptr
;
}
if
constexpr
(
std
:
:
is_same_v
<
TimelineType
dom
:
:
ScrollTimeline
>
)
{
return
data
-
>
GetScrollTimelineCollection
(
aPseudoRequest
.
mType
)
;
}
if
constexpr
(
std
:
:
is_same_v
<
TimelineType
dom
:
:
ViewTimeline
>
)
{
return
data
-
>
GetViewTimelineCollection
(
aPseudoRequest
.
mType
)
;
}
return
nullptr
;
}
template
class
TimelineCollection
<
dom
:
:
ScrollTimeline
>
;
template
class
TimelineCollection
<
dom
:
:
ViewTimeline
>
;
}
