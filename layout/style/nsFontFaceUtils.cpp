#
include
"
nsFontFaceUtils
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
SVGTextFrame
.
h
"
using
namespace
mozilla
;
enum
class
FontUsageKind
{
None
=
0
Frame
FrameAndFontMetrics
}
;
static
FontUsageKind
StyleFontUsage
(
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
const
gfxUserFontSet
*
aUserFontSet
const
gfxUserFontEntry
*
aFont
)
{
if
(
!
aComputedStyle
-
>
StyleFont
(
)
-
>
mFont
.
fontlist
.
Contains
(
aFont
-
>
FamilyName
(
)
)
)
{
return
FontUsageKind
:
:
None
;
}
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetFontMetricsForComputedStyle
(
aComputedStyle
aPresContext
1
.
0f
)
;
if
(
!
fm
-
>
GetThebesFontGroup
(
)
-
>
ContainsUserFont
(
aFont
)
)
{
return
FontUsageKind
:
:
None
;
}
if
(
aComputedStyle
-
>
DependsOnFontMetrics
(
)
)
{
MOZ_ASSERT
(
aPresContext
-
>
UsesExChUnits
(
)
)
;
return
FontUsageKind
:
:
FrameAndFontMetrics
;
}
return
FontUsageKind
:
:
Frame
;
}
static
FontUsageKind
FrameFontUsage
(
nsIFrame
*
aFrame
nsPresContext
*
aPresContext
const
gfxUserFontEntry
*
aFont
)
{
gfxUserFontSet
*
ufs
=
aPresContext
-
>
GetUserFontSet
(
)
;
FontUsageKind
kind
=
StyleFontUsage
(
aFrame
-
>
Style
(
)
aPresContext
ufs
aFont
)
;
if
(
kind
=
=
FontUsageKind
:
:
FrameAndFontMetrics
)
{
return
kind
;
}
int32_t
contextIndex
=
0
;
for
(
ComputedStyle
*
extraContext
;
(
extraContext
=
aFrame
-
>
GetAdditionalComputedStyle
(
contextIndex
)
)
;
+
+
contextIndex
)
{
kind
=
std
:
:
max
(
kind
StyleFontUsage
(
extraContext
aPresContext
ufs
aFont
)
)
;
if
(
kind
=
=
FontUsageKind
:
:
FrameAndFontMetrics
)
{
break
;
}
}
return
kind
;
}
static
void
ScheduleReflow
(
nsIPresShell
*
aShell
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
aFrame
;
if
(
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
nsSVGUtils
:
:
IsInSVGTextSubtree
(
f
)
)
{
if
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
{
while
(
f
)
{
if
(
!
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
{
if
(
NS_SUBTREE_DIRTY
(
f
)
)
{
return
;
}
if
(
f
-
>
GetStateBits
(
)
&
NS_STATE_IS_OUTER_SVG
|
|
!
(
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
nsSVGUtils
:
:
IsInSVGTextSubtree
(
f
)
)
)
{
break
;
}
f
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
f
=
f
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
f
"
should
have
found
an
ancestor
frame
to
reflow
"
)
;
}
}
aShell
-
>
FrameNeedsReflow
(
f
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
enum
class
ReflowAlreadyScheduled
{
No
Yes
}
;
void
nsFontFaceUtils
:
:
MarkDirtyForFontChange
(
nsIFrame
*
aSubtreeRoot
const
gfxUserFontEntry
*
aFont
)
{
MOZ_ASSERT
(
aFont
)
;
AutoTArray
<
nsIFrame
*
4
>
subtrees
;
subtrees
.
AppendElement
(
aSubtreeRoot
)
;
nsPresContext
*
pc
=
aSubtreeRoot
-
>
PresContext
(
)
;
nsIPresShell
*
ps
=
pc
-
>
PresShell
(
)
;
do
{
nsIFrame
*
subtreeRoot
=
subtrees
.
PopLastElement
(
)
;
AutoTArray
<
Pair
<
nsIFrame
*
ReflowAlreadyScheduled
>
32
>
stack
;
stack
.
AppendElement
(
MakePair
(
subtreeRoot
ReflowAlreadyScheduled
:
:
No
)
)
;
do
{
auto
pair
=
stack
.
PopLastElement
(
)
;
nsIFrame
*
f
=
pair
.
first
(
)
;
ReflowAlreadyScheduled
alreadyScheduled
=
pair
.
second
(
)
;
FontUsageKind
kind
=
FrameFontUsage
(
f
pc
aFont
)
;
if
(
kind
!
=
FontUsageKind
:
:
None
)
{
if
(
alreadyScheduled
=
=
ReflowAlreadyScheduled
:
:
No
)
{
ScheduleReflow
(
ps
f
)
;
alreadyScheduled
=
ReflowAlreadyScheduled
:
:
Yes
;
}
if
(
kind
=
=
FontUsageKind
:
:
FrameAndFontMetrics
)
{
MOZ_ASSERT
(
f
-
>
GetContent
(
)
&
&
f
-
>
GetContent
(
)
-
>
IsElement
(
)
"
How
could
we
target
a
non
-
element
with
selectors
?
"
)
;
f
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
Element
:
:
FromNode
(
f
-
>
GetContent
(
)
)
StyleRestyleHint_RECASCADE_SELF
nsChangeHint
(
0
)
)
;
}
}
if
(
alreadyScheduled
=
=
ReflowAlreadyScheduled
:
:
No
|
|
pc
-
>
UsesExChUnits
(
)
)
{
if
(
f
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
oof
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
f
)
;
if
(
!
nsLayoutUtils
:
:
IsProperAncestorFrame
(
subtreeRoot
oof
)
)
{
subtrees
.
AppendElement
(
oof
)
;
}
}
nsIFrame
:
:
ChildListIterator
lists
(
f
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
kid
=
childFrames
.
get
(
)
;
stack
.
AppendElement
(
MakePair
(
kid
alreadyScheduled
)
)
;
}
}
}
}
while
(
!
stack
.
IsEmpty
(
)
)
;
}
while
(
!
subtrees
.
IsEmpty
(
)
)
;
}
