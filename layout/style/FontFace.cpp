#
include
"
mozilla
/
dom
/
FontFace
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
dom
/
CSSFontFaceRule
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceBinding
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceSet
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
UnionTypes
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
namespace
mozilla
{
namespace
dom
{
class
FontFaceBufferSource
:
public
gfxFontFaceBufferSource
{
public
:
explicit
FontFaceBufferSource
(
FontFace
*
aFontFace
)
:
mFontFace
(
aFontFace
)
{
}
virtual
void
TakeBuffer
(
uint8_t
*
&
aBuffer
uint32_t
&
aLength
)
override
;
private
:
RefPtr
<
FontFace
>
mFontFace
;
}
;
void
FontFaceBufferSource
:
:
TakeBuffer
(
uint8_t
*
&
aBuffer
uint32_t
&
aLength
)
{
MOZ_ASSERT
(
mFontFace
"
only
call
TakeBuffer
once
on
a
given
"
"
FontFaceBufferSource
object
"
)
;
mFontFace
-
>
TakeBuffer
(
aBuffer
aLength
)
;
mFontFace
=
nullptr
;
}
template
<
typename
T
>
static
void
GetDataFrom
(
const
T
&
aObject
uint8_t
*
&
aBuffer
uint32_t
&
aLength
)
{
MOZ_ASSERT
(
!
aBuffer
)
;
aObject
.
ComputeLengthAndData
(
)
;
aBuffer
=
(
uint8_t
*
)
malloc
(
aObject
.
Length
(
)
)
;
if
(
!
aBuffer
)
{
return
;
}
memcpy
(
(
void
*
)
aBuffer
aObject
.
Data
(
)
aObject
.
Length
(
)
)
;
aLength
=
aObject
.
Length
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
FontFace
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
FontFace
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mParent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLoaded
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFontFaceSet
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOtherFontFaceSets
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
FontFace
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mParent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLoaded
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFontFaceSet
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOtherFontFaceSets
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
FontFace
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
FontFace
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
FontFace
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
FontFace
)
FontFace
:
:
FontFace
(
nsISupports
*
aParent
FontFaceSet
*
aFontFaceSet
)
:
mParent
(
aParent
)
mLoadedRejection
(
NS_OK
)
mStatus
(
FontFaceLoadStatus
:
:
Unloaded
)
mSourceType
(
SourceType
(
0
)
)
mSourceBuffer
(
nullptr
)
mSourceBufferLength
(
0
)
mFontFaceSet
(
aFontFaceSet
)
mUnicodeRangeDirty
(
true
)
mInFontFaceSet
(
false
)
{
}
FontFace
:
:
~
FontFace
(
)
{
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
SetUserFontEntry
(
nullptr
)
;
if
(
mSourceBuffer
)
{
free
(
mSourceBuffer
)
;
}
}
JSObject
*
FontFace
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
FontFace_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
static
FontFaceLoadStatus
LoadStateToStatus
(
gfxUserFontEntry
:
:
UserFontLoadState
aLoadState
)
{
switch
(
aLoadState
)
{
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_NOT_LOADED
:
return
FontFaceLoadStatus
:
:
Unloaded
;
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_LOAD_PENDING
:
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_LOADING
:
return
FontFaceLoadStatus
:
:
Loading
;
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_LOADED
:
return
FontFaceLoadStatus
:
:
Loaded
;
case
gfxUserFontEntry
:
:
UserFontLoadState
:
:
STATUS_FAILED
:
return
FontFaceLoadStatus
:
:
Error
;
}
MOZ_ASSERT_UNREACHABLE
(
"
invalid
aLoadState
value
"
)
;
return
FontFaceLoadStatus
:
:
Error
;
}
already_AddRefed
<
FontFace
>
FontFace
:
:
CreateForRule
(
nsISupports
*
aGlobal
FontFaceSet
*
aFontFaceSet
RawServoFontFaceRule
*
aRule
)
{
RefPtr
<
FontFace
>
obj
=
new
FontFace
(
aGlobal
aFontFaceSet
)
;
obj
-
>
mRule
=
aRule
;
obj
-
>
mSourceType
=
eSourceType_FontFaceRule
;
obj
-
>
mInFontFaceSet
=
true
;
return
obj
.
forget
(
)
;
}
already_AddRefed
<
FontFace
>
FontFace
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aFamily
const
StringOrArrayBufferOrArrayBufferView
&
aSource
const
FontFaceDescriptors
&
aDescriptors
ErrorResult
&
aRv
)
{
nsISupports
*
global
=
aGlobal
.
GetAsSupports
(
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
global
)
;
Document
*
doc
=
window
-
>
GetDoc
(
)
;
if
(
!
doc
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
FontFace
>
obj
=
new
FontFace
(
global
doc
-
>
Fonts
(
)
)
;
if
(
!
obj
-
>
SetDescriptors
(
aFamily
aDescriptors
)
)
{
return
obj
.
forget
(
)
;
}
obj
-
>
InitializeSource
(
aSource
)
;
return
obj
.
forget
(
)
;
}
void
FontFace
:
:
InitializeSource
(
const
StringOrArrayBufferOrArrayBufferView
&
aSource
)
{
if
(
aSource
.
IsString
(
)
)
{
IgnoredErrorResult
rv
;
SetDescriptor
(
eCSSFontDesc_Src
aSource
.
GetAsString
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
Reject
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
SetStatus
(
FontFaceLoadStatus
:
:
Error
)
;
return
;
}
mSourceType
=
eSourceType_URLs
;
return
;
}
mSourceType
=
FontFace
:
:
eSourceType_Buffer
;
if
(
aSource
.
IsArrayBuffer
(
)
)
{
GetDataFrom
(
aSource
.
GetAsArrayBuffer
(
)
mSourceBuffer
mSourceBufferLength
)
;
}
else
{
MOZ_ASSERT
(
aSource
.
IsArrayBufferView
(
)
)
;
GetDataFrom
(
aSource
.
GetAsArrayBufferView
(
)
mSourceBuffer
mSourceBufferLength
)
;
}
SetStatus
(
FontFaceLoadStatus
:
:
Loading
)
;
DoLoad
(
)
;
}
void
FontFace
:
:
GetFamily
(
nsString
&
aResult
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
GetDesc
(
eCSSFontDesc_Family
aResult
)
;
}
void
FontFace
:
:
SetFamily
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_Family
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFace
:
:
GetStyle
(
nsString
&
aResult
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
GetDesc
(
eCSSFontDesc_Style
aResult
)
;
}
void
FontFace
:
:
SetStyle
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_Style
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFace
:
:
GetWeight
(
nsString
&
aResult
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
GetDesc
(
eCSSFontDesc_Weight
aResult
)
;
}
void
FontFace
:
:
SetWeight
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_Weight
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFace
:
:
GetStretch
(
nsString
&
aResult
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
GetDesc
(
eCSSFontDesc_Stretch
aResult
)
;
}
void
FontFace
:
:
SetStretch
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_Stretch
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFace
:
:
GetUnicodeRange
(
nsString
&
aResult
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
GetDesc
(
eCSSFontDesc_UnicodeRange
aResult
)
;
}
void
FontFace
:
:
SetUnicodeRange
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_UnicodeRange
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFace
:
:
GetVariant
(
nsString
&
aResult
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
aResult
.
AssignLiteral
(
"
normal
"
)
;
}
void
FontFace
:
:
SetVariant
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
}
void
FontFace
:
:
GetFeatureSettings
(
nsString
&
aResult
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
GetDesc
(
eCSSFontDesc_FontFeatureSettings
aResult
)
;
}
void
FontFace
:
:
SetFeatureSettings
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_FontFeatureSettings
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFace
:
:
GetVariationSettings
(
nsString
&
aResult
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
GetDesc
(
eCSSFontDesc_FontVariationSettings
aResult
)
;
}
void
FontFace
:
:
SetVariationSettings
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_FontVariationSettings
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFace
:
:
GetDisplay
(
nsString
&
aResult
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
GetDesc
(
eCSSFontDesc_Display
aResult
)
;
}
void
FontFace
:
:
SetDisplay
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
if
(
SetDescriptor
(
eCSSFontDesc_Display
aValue
aRv
)
)
{
DescriptorUpdated
(
)
;
}
}
void
FontFace
:
:
DescriptorUpdated
(
)
{
if
(
!
mUserFontEntry
)
{
return
;
}
RefPtr
<
gfxUserFontEntry
>
newEntry
=
mFontFaceSet
-
>
FindOrCreateUserFontEntryFromFontFace
(
this
)
;
SetUserFontEntry
(
newEntry
)
;
if
(
mInFontFaceSet
)
{
mFontFaceSet
-
>
MarkUserFontSetDirty
(
)
;
}
for
(
auto
&
set
:
mOtherFontFaceSets
)
{
set
-
>
MarkUserFontSetDirty
(
)
;
}
}
FontFaceLoadStatus
FontFace
:
:
Status
(
)
{
return
mStatus
;
}
Promise
*
FontFace
:
:
Load
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
EnsurePromise
(
)
;
if
(
!
mLoaded
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
mSourceType
=
=
eSourceType_Buffer
|
|
mStatus
!
=
FontFaceLoadStatus
:
:
Unloaded
)
{
return
mLoaded
;
}
SetStatus
(
FontFaceLoadStatus
:
:
Loading
)
;
DoLoad
(
)
;
return
mLoaded
;
}
gfxUserFontEntry
*
FontFace
:
:
CreateUserFontEntry
(
)
{
if
(
!
mUserFontEntry
)
{
MOZ_ASSERT
(
!
HasRule
(
)
"
Rule
backed
FontFace
objects
should
already
have
a
user
font
"
"
entry
by
the
time
Load
(
)
can
be
called
on
them
"
)
;
RefPtr
<
gfxUserFontEntry
>
newEntry
=
mFontFaceSet
-
>
FindOrCreateUserFontEntryFromFontFace
(
this
)
;
if
(
newEntry
)
{
SetUserFontEntry
(
newEntry
)
;
}
}
return
mUserFontEntry
;
}
void
FontFace
:
:
DoLoad
(
)
{
if
(
!
CreateUserFontEntry
(
)
)
{
return
;
}
mUserFontEntry
-
>
Load
(
)
;
}
Promise
*
FontFace
:
:
GetLoaded
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mFontFaceSet
-
>
FlushUserFontSet
(
)
;
EnsurePromise
(
)
;
if
(
!
mLoaded
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
mLoaded
;
}
void
FontFace
:
:
SetStatus
(
FontFaceLoadStatus
aStatus
)
{
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
if
(
mStatus
=
=
aStatus
)
{
return
;
}
if
(
aStatus
<
mStatus
)
{
return
;
}
mStatus
=
aStatus
;
if
(
mInFontFaceSet
)
{
mFontFaceSet
-
>
OnFontFaceStatusChanged
(
this
)
;
}
for
(
FontFaceSet
*
otherSet
:
mOtherFontFaceSets
)
{
otherSet
-
>
OnFontFaceStatusChanged
(
this
)
;
}
if
(
mStatus
=
=
FontFaceLoadStatus
:
:
Loaded
)
{
if
(
mLoaded
)
{
DoResolve
(
)
;
}
}
else
if
(
mStatus
=
=
FontFaceLoadStatus
:
:
Error
)
{
if
(
mSourceType
=
=
eSourceType_Buffer
)
{
Reject
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
}
else
{
Reject
(
NS_ERROR_DOM_NETWORK_ERR
)
;
}
}
}
void
FontFace
:
:
DoResolve
(
)
{
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
if
(
ServoStyleSet
*
ss
=
ServoStyleSet
:
:
Current
(
)
)
{
ss
-
>
AppendTask
(
PostTraversalTask
:
:
ResolveFontFaceLoadedPromise
(
this
)
)
;
return
;
}
mLoaded
-
>
MaybeResolve
(
this
)
;
}
void
FontFace
:
:
DoReject
(
nsresult
aResult
)
{
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
if
(
ServoStyleSet
*
ss
=
ServoStyleSet
:
:
Current
(
)
)
{
ss
-
>
AppendTask
(
PostTraversalTask
:
:
RejectFontFaceLoadedPromise
(
this
aResult
)
)
;
return
;
}
mLoaded
-
>
MaybeReject
(
aResult
)
;
}
already_AddRefed
<
URLExtraData
>
FontFace
:
:
GetURLExtraData
(
)
const
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
mParent
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
global
-
>
PrincipalOrNull
(
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mParent
)
;
nsCOMPtr
<
nsIURI
>
docURI
=
window
-
>
GetDocumentURI
(
)
;
nsCOMPtr
<
nsIURI
>
base
=
window
-
>
GetDocBaseURI
(
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
mozilla
:
:
dom
:
:
ReferrerInfo
(
docURI
net
:
:
RP_Unset
)
;
RefPtr
<
URLExtraData
>
url
=
new
URLExtraData
(
base
referrerInfo
principal
)
;
return
url
.
forget
(
)
;
}
bool
FontFace
:
:
SetDescriptor
(
nsCSSFontDesc
aFontDesc
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
NS_ASSERTION
(
!
HasRule
(
)
"
we
don
'
t
handle
rule
backed
FontFace
objects
yet
"
)
;
if
(
HasRule
(
)
)
{
return
false
;
}
NS_ConvertUTF16toUTF8
value
(
aValue
)
;
RefPtr
<
URLExtraData
>
url
=
GetURLExtraData
(
)
;
bool
changed
;
if
(
!
Servo_FontFaceRule_SetDescriptor
(
GetData
(
)
aFontDesc
&
value
url
&
changed
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
if
(
!
changed
)
{
return
false
;
}
if
(
aFontDesc
=
=
eCSSFontDesc_UnicodeRange
)
{
mUnicodeRangeDirty
=
true
;
}
return
true
;
}
bool
FontFace
:
:
SetDescriptors
(
const
nsAString
&
aFamily
const
FontFaceDescriptors
&
aDescriptors
)
{
MOZ_ASSERT
(
!
HasRule
(
)
)
;
MOZ_ASSERT
(
!
mDescriptors
)
;
mDescriptors
=
Servo_FontFaceRule_CreateEmpty
(
)
.
Consume
(
)
;
auto
setDesc
=
[
=
]
(
nsCSSFontDesc
aDesc
const
nsAString
&
aVal
)
-
>
bool
{
IgnoredErrorResult
rv
;
SetDescriptor
(
aDesc
aVal
rv
)
;
return
!
rv
.
Failed
(
)
;
}
;
if
(
!
setDesc
(
eCSSFontDesc_Family
aFamily
)
|
|
!
setDesc
(
eCSSFontDesc_Style
aDescriptors
.
mStyle
)
|
|
!
setDesc
(
eCSSFontDesc_Weight
aDescriptors
.
mWeight
)
|
|
!
setDesc
(
eCSSFontDesc_Stretch
aDescriptors
.
mStretch
)
|
|
!
setDesc
(
eCSSFontDesc_UnicodeRange
aDescriptors
.
mUnicodeRange
)
|
|
!
setDesc
(
eCSSFontDesc_FontFeatureSettings
aDescriptors
.
mFeatureSettings
)
|
|
(
StaticPrefs
:
:
layout_css_font_variations_enabled
(
)
&
&
!
setDesc
(
eCSSFontDesc_FontVariationSettings
aDescriptors
.
mVariationSettings
)
)
|
|
!
setDesc
(
eCSSFontDesc_Display
aDescriptors
.
mDisplay
)
)
{
mDescriptors
=
Servo_FontFaceRule_CreateEmpty
(
)
.
Consume
(
)
;
Reject
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
SetStatus
(
FontFaceLoadStatus
:
:
Error
)
;
return
false
;
}
return
true
;
}
void
FontFace
:
:
GetDesc
(
nsCSSFontDesc
aDescID
nsString
&
aResult
)
const
{
aResult
.
Truncate
(
)
;
Servo_FontFaceRule_GetDescriptorCssText
(
GetData
(
)
aDescID
&
aResult
)
;
if
(
aResult
.
IsEmpty
(
)
)
{
if
(
aDescID
=
=
eCSSFontDesc_UnicodeRange
)
{
aResult
.
AssignLiteral
(
"
U
+
0
-
10FFFF
"
)
;
}
else
if
(
aDescID
=
=
eCSSFontDesc_Display
)
{
aResult
.
AssignLiteral
(
"
auto
"
)
;
}
else
if
(
aDescID
!
=
eCSSFontDesc_Family
&
&
aDescID
!
=
eCSSFontDesc_Src
)
{
aResult
.
AssignLiteral
(
"
normal
"
)
;
}
}
}
void
FontFace
:
:
SetUserFontEntry
(
gfxUserFontEntry
*
aEntry
)
{
if
(
mUserFontEntry
)
{
mUserFontEntry
-
>
mFontFaces
.
RemoveElement
(
this
)
;
}
mUserFontEntry
=
static_cast
<
Entry
*
>
(
aEntry
)
;
if
(
mUserFontEntry
)
{
mUserFontEntry
-
>
mFontFaces
.
AppendElement
(
this
)
;
MOZ_ASSERT
(
mUserFontEntry
-
>
GetUserFontSet
(
)
=
=
mFontFaceSet
-
>
GetUserFontSet
(
)
"
user
font
entry
must
be
associated
with
the
same
user
font
set
"
"
as
the
FontFace
"
)
;
FontFaceLoadStatus
newStatus
=
LoadStateToStatus
(
mUserFontEntry
-
>
LoadState
(
)
)
;
if
(
newStatus
>
mStatus
)
{
SetStatus
(
newStatus
)
;
}
}
}
Maybe
<
StyleComputedFontWeightRange
>
FontFace
:
:
GetFontWeight
(
)
const
{
StyleComputedFontWeightRange
range
;
if
(
!
Servo_FontFaceRule_GetFontWeight
(
GetData
(
)
&
range
)
)
{
return
Nothing
(
)
;
}
return
Some
(
range
)
;
}
Maybe
<
StyleComputedFontStretchRange
>
FontFace
:
:
GetFontStretch
(
)
const
{
StyleComputedFontStretchRange
range
;
if
(
!
Servo_FontFaceRule_GetFontStretch
(
GetData
(
)
&
range
)
)
{
return
Nothing
(
)
;
}
return
Some
(
range
)
;
}
Maybe
<
StyleComputedFontStyleDescriptor
>
FontFace
:
:
GetFontStyle
(
)
const
{
StyleComputedFontStyleDescriptor
descriptor
;
if
(
!
Servo_FontFaceRule_GetFontStyle
(
GetData
(
)
&
descriptor
)
)
{
return
Nothing
(
)
;
}
return
Some
(
descriptor
)
;
}
Maybe
<
StyleFontDisplay
>
FontFace
:
:
GetFontDisplay
(
)
const
{
StyleFontDisplay
display
;
if
(
!
Servo_FontFaceRule_GetFontDisplay
(
GetData
(
)
&
display
)
)
{
return
Nothing
(
)
;
}
return
Some
(
display
)
;
}
Maybe
<
StyleFontLanguageOverride
>
FontFace
:
:
GetFontLanguageOverride
(
)
const
{
StyleFontLanguageOverride
langOverride
;
if
(
!
Servo_FontFaceRule_GetFontLanguageOverride
(
GetData
(
)
&
langOverride
)
)
{
return
Nothing
(
)
;
}
return
Some
(
langOverride
)
;
}
bool
FontFace
:
:
HasLocalSrc
(
)
const
{
AutoTArray
<
StyleFontFaceSourceListComponent
8
>
components
;
GetSources
(
components
)
;
for
(
auto
&
component
:
components
)
{
if
(
component
.
tag
=
=
StyleFontFaceSourceListComponent
:
:
Tag
:
:
Local
)
{
return
true
;
}
}
return
false
;
}
void
FontFace
:
:
GetFontFeatureSettings
(
nsTArray
<
gfxFontFeature
>
&
aFeatures
)
const
{
Servo_FontFaceRule_GetFeatureSettings
(
GetData
(
)
&
aFeatures
)
;
}
void
FontFace
:
:
GetFontVariationSettings
(
nsTArray
<
gfxFontVariation
>
&
aVariations
)
const
{
Servo_FontFaceRule_GetVariationSettings
(
GetData
(
)
&
aVariations
)
;
}
void
FontFace
:
:
GetSources
(
nsTArray
<
StyleFontFaceSourceListComponent
>
&
aSources
)
const
{
Servo_FontFaceRule_GetSources
(
GetData
(
)
&
aSources
)
;
}
nsAtom
*
FontFace
:
:
GetFamilyName
(
)
const
{
return
Servo_FontFaceRule_GetFamilyName
(
GetData
(
)
)
;
}
void
FontFace
:
:
DisconnectFromRule
(
)
{
MOZ_ASSERT
(
HasRule
(
)
)
;
mDescriptors
=
Servo_FontFaceRule_Clone
(
mRule
)
.
Consume
(
)
;
mRule
=
nullptr
;
mInFontFaceSet
=
false
;
}
bool
FontFace
:
:
HasFontData
(
)
const
{
return
mSourceType
=
=
eSourceType_Buffer
&
&
mSourceBuffer
;
}
void
FontFace
:
:
TakeBuffer
(
uint8_t
*
&
aBuffer
uint32_t
&
aLength
)
{
MOZ_ASSERT
(
HasFontData
(
)
)
;
aBuffer
=
mSourceBuffer
;
aLength
=
mSourceBufferLength
;
mSourceBuffer
=
nullptr
;
mSourceBufferLength
=
0
;
}
already_AddRefed
<
gfxFontFaceBufferSource
>
FontFace
:
:
CreateBufferSource
(
)
{
RefPtr
<
FontFaceBufferSource
>
bufferSource
=
new
FontFaceBufferSource
(
this
)
;
return
bufferSource
.
forget
(
)
;
}
bool
FontFace
:
:
IsInFontFaceSet
(
FontFaceSet
*
aFontFaceSet
)
const
{
if
(
mFontFaceSet
=
=
aFontFaceSet
)
{
return
mInFontFaceSet
;
}
return
mOtherFontFaceSets
.
Contains
(
aFontFaceSet
)
;
}
void
FontFace
:
:
AddFontFaceSet
(
FontFaceSet
*
aFontFaceSet
)
{
MOZ_ASSERT
(
!
IsInFontFaceSet
(
aFontFaceSet
)
)
;
if
(
mFontFaceSet
=
=
aFontFaceSet
)
{
mInFontFaceSet
=
true
;
}
else
{
mOtherFontFaceSets
.
AppendElement
(
aFontFaceSet
)
;
}
}
void
FontFace
:
:
RemoveFontFaceSet
(
FontFaceSet
*
aFontFaceSet
)
{
MOZ_ASSERT
(
IsInFontFaceSet
(
aFontFaceSet
)
)
;
if
(
mFontFaceSet
=
=
aFontFaceSet
)
{
mInFontFaceSet
=
false
;
}
else
{
mOtherFontFaceSets
.
RemoveElement
(
aFontFaceSet
)
;
}
}
void
FontFace
:
:
Reject
(
nsresult
aResult
)
{
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
if
(
mLoaded
)
{
DoReject
(
aResult
)
;
}
else
if
(
mLoadedRejection
=
=
NS_OK
)
{
mLoadedRejection
=
aResult
;
}
}
void
FontFace
:
:
EnsurePromise
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mLoaded
)
{
return
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
mParent
)
;
if
(
global
&
&
FontFaceSet
:
:
PrefEnabled
(
)
)
{
ErrorResult
rv
;
mLoaded
=
Promise
:
:
Create
(
global
rv
)
;
if
(
mStatus
=
=
FontFaceLoadStatus
:
:
Loaded
)
{
mLoaded
-
>
MaybeResolve
(
this
)
;
}
else
if
(
mLoadedRejection
!
=
NS_OK
)
{
mLoaded
-
>
MaybeReject
(
mLoadedRejection
)
;
}
}
}
gfxCharacterMap
*
FontFace
:
:
GetUnicodeRangeAsCharacterMap
(
)
{
if
(
!
mUnicodeRangeDirty
)
{
return
mUnicodeRange
;
}
size_t
len
;
const
StyleUnicodeRange
*
rangesPtr
=
Servo_FontFaceRule_GetUnicodeRanges
(
GetData
(
)
&
len
)
;
Span
<
const
StyleUnicodeRange
>
ranges
(
rangesPtr
len
)
;
if
(
!
ranges
.
IsEmpty
(
)
)
{
mUnicodeRange
=
new
gfxCharacterMap
(
)
;
for
(
auto
&
range
:
ranges
)
{
mUnicodeRange
-
>
SetRange
(
range
.
start
range
.
end
)
;
}
}
else
{
mUnicodeRange
=
nullptr
;
}
mUnicodeRangeDirty
=
false
;
return
mUnicodeRange
;
}
void
FontFace
:
:
Entry
:
:
SetLoadState
(
UserFontLoadState
aLoadState
)
{
gfxUserFontEntry
:
:
SetLoadState
(
aLoadState
)
;
for
(
size_t
i
=
0
;
i
<
mFontFaces
.
Length
(
)
;
i
+
+
)
{
mFontFaces
[
i
]
-
>
SetStatus
(
LoadStateToStatus
(
aLoadState
)
)
;
}
}
void
FontFace
:
:
Entry
:
:
GetUserFontSets
(
nsTArray
<
gfxUserFontSet
*
>
&
aResult
)
{
aResult
.
Clear
(
)
;
for
(
FontFace
*
f
:
mFontFaces
)
{
if
(
f
-
>
mInFontFaceSet
)
{
aResult
.
AppendElement
(
f
-
>
mFontFaceSet
-
>
GetUserFontSet
(
)
)
;
}
for
(
FontFaceSet
*
s
:
f
-
>
mOtherFontFaceSets
)
{
aResult
.
AppendElement
(
s
-
>
GetUserFontSet
(
)
)
;
}
}
aResult
.
Sort
(
)
;
auto
it
=
std
:
:
unique
(
aResult
.
begin
(
)
aResult
.
end
(
)
)
;
aResult
.
TruncateLength
(
it
-
aResult
.
begin
(
)
)
;
}
}
}
