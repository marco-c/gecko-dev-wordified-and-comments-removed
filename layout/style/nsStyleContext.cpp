#
include
"
nsStyleContext
.
h
"
#
include
"
CSSVariableImageTable
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIStyleRule
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsRuleNode
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ArenaObjectID
.
h
"
#
include
"
mozilla
/
StyleSetHandle
.
h
"
#
include
"
mozilla
/
StyleSetHandleInlines
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
using
namespace
mozilla
;
#
ifdef
DEBUG
enum
DebugStyleStruct
{
#
define
STYLE_STRUCT
(
name
checkdata_cb
)
eDebugStyleStruct_
#
#
name
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
}
;
#
define
STYLE_STRUCT
(
name
checkdata_cb
)
\
static_assert
(
static_cast
<
int
>
(
eDebugStyleStruct_
#
#
name
)
=
=
\
static_cast
<
int
>
(
eStyleStruct_
#
#
name
)
\
"
Style
struct
IDs
are
not
declared
in
order
?
"
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
const
uint32_t
nsStyleContext
:
:
sDependencyTable
[
]
=
{
#
define
STYLE_STRUCT
(
name
checkdata_cb
)
#
define
STYLE_STRUCT_DEP
(
dep
)
NS_STYLE_INHERIT_BIT
(
dep
)
|
#
define
STYLE_STRUCT_END
(
)
0
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
#
undef
STYLE_STRUCT_DEP
#
undef
STYLE_STRUCT_END
}
;
static
bool
sExpensiveStyleStructAssertionsEnabled
;
#
endif
nsStyleContext
:
:
nsStyleContext
(
nsStyleContext
*
aParent
OwningStyleContextSource
&
&
aSource
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
)
:
mParent
(
aParent
)
mChild
(
nullptr
)
mEmptyChild
(
nullptr
)
mPseudoTag
(
aPseudoTag
)
mSource
(
Move
(
aSource
)
)
#
ifdef
MOZ_STYLO
mPresContext
(
nullptr
)
#
endif
mCachedResetData
(
nullptr
)
mBits
(
(
(
uint64_t
)
aPseudoType
)
<
<
NS_STYLE_CONTEXT_TYPE_SHIFT
)
mRefCnt
(
0
)
#
ifdef
DEBUG
mFrameRefCnt
(
0
)
mComputingStruct
(
nsStyleStructID_None
)
#
endif
{
}
nsStyleContext
:
:
nsStyleContext
(
nsStyleContext
*
aParent
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
already_AddRefed
<
nsRuleNode
>
aRuleNode
bool
aSkipParentDisplayBasedStyleFixup
)
:
nsStyleContext
(
aParent
OwningStyleContextSource
(
Move
(
aRuleNode
)
)
aPseudoTag
aPseudoType
)
{
#
ifdef
MOZ_STYLO
mPresContext
=
mSource
.
AsGeckoRuleNode
(
)
-
>
PresContext
(
)
;
#
endif
if
(
aParent
)
{
#
ifdef
DEBUG
nsRuleNode
*
r1
=
mParent
-
>
RuleNode
(
)
*
r2
=
mSource
.
AsGeckoRuleNode
(
)
;
while
(
r1
-
>
GetParent
(
)
)
r1
=
r1
-
>
GetParent
(
)
;
while
(
r2
-
>
GetParent
(
)
)
r2
=
r2
-
>
GetParent
(
)
;
NS_ASSERTION
(
r1
=
=
r2
"
must
be
in
the
same
rule
tree
as
parent
"
)
;
#
endif
}
else
{
PresContext
(
)
-
>
PresShell
(
)
-
>
StyleSet
(
)
-
>
RootStyleContextAdded
(
)
;
}
mSource
.
AsGeckoRuleNode
(
)
-
>
SetUsedDirectly
(
)
;
FinishConstruction
(
aSkipParentDisplayBasedStyleFixup
)
;
}
nsStyleContext
:
:
nsStyleContext
(
nsStyleContext
*
aParent
nsPresContext
*
aPresContext
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
already_AddRefed
<
ServoComputedValues
>
aComputedValues
bool
aSkipParentDisplayBasedStyleFixup
)
:
nsStyleContext
(
aParent
OwningStyleContextSource
(
Move
(
aComputedValues
)
)
aPseudoTag
aPseudoType
)
{
#
ifdef
MOZ_STYLO
mPresContext
=
aPresContext
;
#
endif
FinishConstruction
(
aSkipParentDisplayBasedStyleFixup
)
;
}
void
nsStyleContext
:
:
FinishConstruction
(
bool
aSkipParentDisplayBasedStyleFixup
)
{
static_assert
(
(
UINT64_MAX
>
>
NS_STYLE_CONTEXT_TYPE_SHIFT
)
>
=
static_cast
<
CSSPseudoElementTypeBase
>
(
CSSPseudoElementType
:
:
MAX
)
"
pseudo
element
bits
no
longer
fit
in
a
uint64_t
"
)
;
MOZ_ASSERT
(
!
mSource
.
IsNull
(
)
)
;
#
ifdef
DEBUG
static_assert
(
MOZ_ARRAY_LENGTH
(
nsStyleContext
:
:
sDependencyTable
)
=
=
nsStyleStructID_Length
"
Number
of
items
in
dependency
table
doesn
'
t
match
IDs
"
)
;
#
endif
mNextSibling
=
this
;
mPrevSibling
=
this
;
if
(
mParent
)
{
mParent
-
>
AddChild
(
this
)
;
}
SetStyleBits
(
)
;
if
(
!
mSource
.
IsServoComputedValues
(
)
)
{
ApplyStyleFixups
(
aSkipParentDisplayBasedStyleFixup
)
;
}
#
define
eStyleStruct_LastItem
(
nsStyleStructID_Length
-
1
)
NS_ASSERTION
(
NS_STYLE_INHERIT_MASK
&
NS_STYLE_INHERIT_BIT
(
LastItem
)
"
NS_STYLE_INHERIT_MASK
must
be
bigger
and
other
bits
shifted
"
)
;
#
undef
eStyleStruct_LastItem
}
nsStyleContext
:
:
~
nsStyleContext
(
)
{
NS_ASSERTION
(
(
nullptr
=
=
mChild
)
&
&
(
nullptr
=
=
mEmptyChild
)
"
destructing
context
with
children
"
)
;
#
ifdef
DEBUG
if
(
sExpensiveStyleStructAssertionsEnabled
)
{
nsStyleContext
*
root
=
this
;
while
(
root
-
>
mParent
)
{
root
=
root
-
>
mParent
;
}
root
-
>
AssertStructsNotUsedElsewhere
(
this
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
;
}
else
{
AssertStructsNotUsedElsewhere
(
this
2
)
;
}
#
endif
nsPresContext
*
presContext
=
PresContext
(
)
;
DebugOnly
<
nsStyleSet
*
>
geckoStyleSet
=
presContext
-
>
PresShell
(
)
-
>
StyleSet
(
)
-
>
GetAsGecko
(
)
;
NS_ASSERTION
(
!
geckoStyleSet
|
|
geckoStyleSet
-
>
GetRuleTree
(
)
=
=
mSource
.
AsGeckoRuleNode
(
)
-
>
RuleTree
(
)
|
|
geckoStyleSet
-
>
IsInRuleTreeReconstruct
(
)
"
destroying
style
context
from
old
rule
tree
too
late
"
)
;
if
(
mParent
)
{
mParent
-
>
RemoveChild
(
this
)
;
}
else
{
presContext
-
>
StyleSet
(
)
-
>
RootStyleContextRemoved
(
)
;
}
mCachedInheritedData
.
DestroyStructs
(
mBits
presContext
)
;
if
(
mCachedResetData
)
{
mCachedResetData
-
>
Destroy
(
mBits
presContext
)
;
}
CSSVariableImageTable
:
:
RemoveAll
(
this
)
;
}
#
ifdef
DEBUG
void
nsStyleContext
:
:
AssertStructsNotUsedElsewhere
(
nsStyleContext
*
aDestroyingContext
int32_t
aLevels
)
const
{
if
(
aLevels
=
=
0
)
{
return
;
}
void
*
data
;
if
(
mBits
&
NS_STYLE_IS_GOING_AWAY
)
{
return
;
}
if
(
this
!
=
aDestroyingContext
)
{
nsInheritedStyleData
&
destroyingInheritedData
=
aDestroyingContext
-
>
mCachedInheritedData
;
#
define
STYLE_STRUCT_INHERITED
(
name_
checkdata_cb
)
\
data
=
destroyingInheritedData
.
mStyleStructs
[
eStyleStruct_
#
#
name_
]
;
\
if
(
data
&
&
\
!
(
aDestroyingContext
-
>
mBits
&
NS_STYLE_INHERIT_BIT
(
name_
)
)
&
&
\
(
mCachedInheritedData
.
mStyleStructs
[
eStyleStruct_
#
#
name_
]
=
=
data
)
)
{
\
printf_stderr
(
"
style
struct
%
p
found
on
style
context
%
p
\
n
"
data
this
)
;
\
nsString
url
;
\
nsresult
rv
=
PresContext
(
)
-
>
Document
(
)
-
>
GetURL
(
url
)
;
\
if
(
NS_SUCCEEDED
(
rv
)
)
{
\
printf_stderr
(
"
in
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
url
)
.
get
(
)
)
;
\
}
\
MOZ_ASSERT
(
false
"
destroying
"
#
name_
"
style
struct
still
present
"
\
"
in
style
context
tree
"
)
;
\
}
#
define
STYLE_STRUCT_RESET
(
name_
checkdata_cb
)
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT_INHERITED
#
undef
STYLE_STRUCT_RESET
if
(
mCachedResetData
)
{
nsResetStyleData
*
destroyingResetData
=
aDestroyingContext
-
>
mCachedResetData
;
if
(
destroyingResetData
)
{
#
define
STYLE_STRUCT_INHERITED
(
name_
checkdata_cb_
)
#
define
STYLE_STRUCT_RESET
(
name_
checkdata_cb
)
\
data
=
destroyingResetData
-
>
mStyleStructs
[
eStyleStruct_
#
#
name_
]
;
\
if
(
data
&
&
\
!
(
aDestroyingContext
-
>
mBits
&
NS_STYLE_INHERIT_BIT
(
name_
)
)
&
&
\
(
mCachedResetData
-
>
mStyleStructs
[
eStyleStruct_
#
#
name_
]
=
=
data
)
)
{
\
printf_stderr
(
"
style
struct
%
p
found
on
style
context
%
p
\
n
"
data
\
this
)
;
\
nsString
url
;
\
nsresult
rv
=
PresContext
(
)
-
>
Document
(
)
-
>
GetURL
(
url
)
;
\
if
(
NS_SUCCEEDED
(
rv
)
)
{
\
printf_stderr
(
"
in
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
url
)
.
get
(
)
)
;
\
}
\
MOZ_ASSERT
(
false
"
destroying
"
#
name_
"
style
struct
still
present
"
\
"
in
style
context
tree
"
)
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT_INHERITED
#
undef
STYLE_STRUCT_RESET
}
}
}
if
(
mChild
)
{
const
nsStyleContext
*
child
=
mChild
;
do
{
child
-
>
AssertStructsNotUsedElsewhere
(
aDestroyingContext
aLevels
-
1
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
child
!
=
mChild
)
;
}
if
(
mEmptyChild
)
{
const
nsStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
AssertStructsNotUsedElsewhere
(
aDestroyingContext
aLevels
-
1
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
child
!
=
mEmptyChild
)
;
}
}
#
endif
void
nsStyleContext
:
:
AddChild
(
nsStyleContext
*
aChild
)
{
NS_ASSERTION
(
aChild
-
>
mPrevSibling
=
=
aChild
&
&
aChild
-
>
mNextSibling
=
=
aChild
"
child
already
in
a
child
list
"
)
;
nsStyleContext
*
*
listPtr
=
aChild
-
>
mSource
.
MatchesNoRules
(
)
?
&
mEmptyChild
:
&
mChild
;
nsStyleContext
*
list
=
*
listPtr
;
if
(
list
)
{
aChild
-
>
mNextSibling
=
list
;
aChild
-
>
mPrevSibling
=
list
-
>
mPrevSibling
;
list
-
>
mPrevSibling
-
>
mNextSibling
=
aChild
;
list
-
>
mPrevSibling
=
aChild
;
}
(
*
listPtr
)
=
aChild
;
}
void
nsStyleContext
:
:
RemoveChild
(
nsStyleContext
*
aChild
)
{
NS_PRECONDITION
(
nullptr
!
=
aChild
&
&
this
=
=
aChild
-
>
mParent
"
bad
argument
"
)
;
nsStyleContext
*
*
list
=
aChild
-
>
mSource
.
MatchesNoRules
(
)
?
&
mEmptyChild
:
&
mChild
;
if
(
aChild
-
>
mPrevSibling
!
=
aChild
)
{
if
(
(
*
list
)
=
=
aChild
)
{
(
*
list
)
=
(
*
list
)
-
>
mNextSibling
;
}
}
else
{
NS_ASSERTION
(
(
*
list
)
=
=
aChild
"
bad
sibling
pointers
"
)
;
(
*
list
)
=
nullptr
;
}
aChild
-
>
mPrevSibling
-
>
mNextSibling
=
aChild
-
>
mNextSibling
;
aChild
-
>
mNextSibling
-
>
mPrevSibling
=
aChild
-
>
mPrevSibling
;
aChild
-
>
mNextSibling
=
aChild
;
aChild
-
>
mPrevSibling
=
aChild
;
}
void
nsStyleContext
:
:
MoveTo
(
nsStyleContext
*
aNewParent
)
{
MOZ_ASSERT
(
aNewParent
!
=
mParent
)
;
#
define
CHECK_FLAG
(
bit_
)
\
MOZ_ASSERT
(
(
mParent
-
>
mBits
&
(
bit_
)
)
=
=
(
aNewParent
-
>
mBits
&
(
bit_
)
)
|
|
\
(
mBits
&
(
bit_
)
)
\
"
MoveTo
cannot
be
called
if
"
#
bit_
"
value
on
old
and
new
"
\
"
style
context
parents
do
not
match
unless
the
flag
is
set
"
\
"
on
this
style
context
"
)
;
CHECK_FLAG
(
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
)
CHECK_FLAG
(
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
)
CHECK_FLAG
(
NS_STYLE_HAS_TEXT_DECORATION_LINES
)
CHECK_FLAG
(
NS_STYLE_RELEVANT_LINK_VISITED
)
#
undef
CHECK_FLAG
MOZ_ASSERT
(
!
IsStyleIfVisited
(
)
)
;
MOZ_ASSERT
(
!
mParent
-
>
IsStyleIfVisited
(
)
)
;
MOZ_ASSERT
(
!
aNewParent
-
>
IsStyleIfVisited
(
)
)
;
MOZ_ASSERT
(
!
mStyleIfVisited
|
|
mStyleIfVisited
-
>
mParent
=
=
mParent
)
;
if
(
mParent
-
>
HasChildThatUsesResetStyle
(
)
)
{
aNewParent
-
>
AddStyleBit
(
NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE
)
;
}
mParent
-
>
RemoveChild
(
this
)
;
mParent
=
aNewParent
;
mParent
-
>
AddChild
(
this
)
;
if
(
mStyleIfVisited
)
{
mStyleIfVisited
-
>
mParent
-
>
RemoveChild
(
mStyleIfVisited
)
;
mStyleIfVisited
-
>
mParent
=
aNewParent
;
mStyleIfVisited
-
>
mParent
-
>
AddChild
(
mStyleIfVisited
)
;
}
}
already_AddRefed
<
nsStyleContext
>
nsStyleContext
:
:
FindChildWithRules
(
const
nsIAtom
*
aPseudoTag
NonOwningStyleContextSource
aSource
NonOwningStyleContextSource
aSourceIfVisited
bool
aRelevantLinkVisited
)
{
uint32_t
threshold
=
10
;
RefPtr
<
nsStyleContext
>
result
;
nsStyleContext
*
list
=
aSource
.
MatchesNoRules
(
)
?
mEmptyChild
:
mChild
;
if
(
list
)
{
nsStyleContext
*
child
=
list
;
do
{
if
(
child
-
>
mSource
.
AsRaw
(
)
=
=
aSource
&
&
child
-
>
mPseudoTag
=
=
aPseudoTag
&
&
!
child
-
>
IsStyleIfVisited
(
)
&
&
child
-
>
RelevantLinkVisited
(
)
=
=
aRelevantLinkVisited
)
{
bool
match
=
false
;
if
(
!
aSourceIfVisited
.
IsNull
(
)
)
{
match
=
child
-
>
GetStyleIfVisited
(
)
&
&
child
-
>
GetStyleIfVisited
(
)
-
>
mSource
.
AsRaw
(
)
=
=
aSourceIfVisited
;
}
else
{
match
=
!
child
-
>
GetStyleIfVisited
(
)
;
}
if
(
match
&
&
!
(
child
-
>
mBits
&
NS_STYLE_INELIGIBLE_FOR_SHARING
)
)
{
result
=
child
;
break
;
}
}
child
=
child
-
>
mNextSibling
;
threshold
-
-
;
if
(
threshold
=
=
0
)
break
;
}
while
(
child
!
=
list
)
;
}
if
(
result
)
{
if
(
result
!
=
list
)
{
RemoveChild
(
result
)
;
AddChild
(
result
)
;
}
result
-
>
mBits
|
=
NS_STYLE_IS_SHARED
;
}
return
result
.
forget
(
)
;
}
const
void
*
nsStyleContext
:
:
StyleData
(
nsStyleStructID
aSID
)
{
const
void
*
cachedData
=
GetCachedStyleData
(
aSID
)
;
if
(
cachedData
)
return
cachedData
;
const
void
*
newData
;
if
(
mSource
.
IsGeckoRuleNode
(
)
)
{
newData
=
mSource
.
AsGeckoRuleNode
(
)
-
>
GetStyleData
(
aSID
this
true
)
;
if
(
!
nsCachedStyleData
:
:
IsReset
(
aSID
)
)
{
mCachedInheritedData
.
mStyleStructs
[
aSID
]
=
const_cast
<
void
*
>
(
newData
)
;
}
}
else
{
newData
=
StyleStructFromServoComputedValues
(
aSID
)
;
switch
(
aSID
)
{
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
case
eStyleStruct_
#
#
name_
:
{
\
auto
data
=
static_cast
<
const
nsStyle
#
#
name_
*
>
(
newData
)
;
\
const_cast
<
nsStyle
#
#
name_
*
>
(
data
)
-
>
FinishStyle
(
PresContext
(
)
)
;
\
break
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
nsStyleStructID
value
"
)
;
break
;
}
AddStyleBit
(
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
;
SetStyle
(
aSID
const_cast
<
void
*
>
(
newData
)
)
;
}
return
newData
;
}
void
*
nsStyleContext
:
:
GetUniqueStyleData
(
const
nsStyleStructID
&
aSID
)
{
MOZ_ASSERT
(
!
mSource
.
IsServoComputedValues
(
)
"
Can
'
t
COW
-
mutate
servo
values
from
Gecko
!
"
)
;
const
void
*
current
=
StyleData
(
aSID
)
;
if
(
!
mChild
&
&
!
mEmptyChild
&
&
!
(
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
&
&
GetCachedStyleData
(
aSID
)
)
return
const_cast
<
void
*
>
(
current
)
;
void
*
result
;
nsPresContext
*
presContext
=
PresContext
(
)
;
switch
(
aSID
)
{
#
define
UNIQUE_CASE
(
c_
)
\
case
eStyleStruct_
#
#
c_
:
\
result
=
new
(
presContext
)
nsStyle
#
#
c_
(
\
*
static_cast
<
const
nsStyle
#
#
c_
*
>
(
current
)
)
;
\
break
;
UNIQUE_CASE
(
Font
)
UNIQUE_CASE
(
Display
)
UNIQUE_CASE
(
Text
)
UNIQUE_CASE
(
TextReset
)
UNIQUE_CASE
(
Visibility
)
#
undef
UNIQUE_CASE
default
:
NS_ERROR
(
"
Struct
type
not
supported
.
Please
find
another
way
to
do
this
if
you
can
!
"
)
;
return
nullptr
;
}
SetStyle
(
aSID
result
)
;
mBits
&
=
~
static_cast
<
uint64_t
>
(
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
;
return
result
;
}
void
*
nsStyleContext
:
:
CreateEmptyStyleData
(
const
nsStyleStructID
&
aSID
)
{
MOZ_ASSERT
(
!
mChild
&
&
!
mEmptyChild
&
&
!
(
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
&
&
!
GetCachedStyleData
(
aSID
)
"
This
style
should
not
have
been
computed
"
)
;
void
*
result
;
nsPresContext
*
presContext
=
PresContext
(
)
;
switch
(
aSID
)
{
#
define
UNIQUE_CASE
(
c_
)
\
case
eStyleStruct_
#
#
c_
:
\
result
=
new
(
presContext
)
nsStyle
#
#
c_
(
presContext
)
;
\
break
;
UNIQUE_CASE
(
Border
)
UNIQUE_CASE
(
Padding
)
#
undef
UNIQUE_CASE
default
:
NS_ERROR
(
"
Struct
type
not
supported
.
"
)
;
return
nullptr
;
}
SetStyle
(
aSID
result
)
;
return
result
;
}
void
nsStyleContext
:
:
SetStyle
(
nsStyleStructID
aSID
void
*
aStruct
)
{
NS_ASSERTION
(
aSID
>
=
0
&
&
aSID
<
nsStyleStructID_Length
"
out
of
bounds
"
)
;
void
*
*
dataSlot
;
if
(
nsCachedStyleData
:
:
IsReset
(
aSID
)
)
{
if
(
!
mCachedResetData
)
{
mCachedResetData
=
new
(
PresContext
(
)
)
nsResetStyleData
;
}
dataSlot
=
&
mCachedResetData
-
>
mStyleStructs
[
aSID
]
;
}
else
{
dataSlot
=
&
mCachedInheritedData
.
mStyleStructs
[
aSID
]
;
}
NS_ASSERTION
(
!
*
dataSlot
|
|
(
mBits
&
nsCachedStyleData
:
:
GetBitForSID
(
aSID
)
)
"
Going
to
leak
style
data
"
)
;
*
dataSlot
=
aStruct
;
}
static
bool
ShouldSuppressLineBreak
(
const
nsStyleContext
*
aContext
const
nsStyleDisplay
*
aDisplay
const
nsStyleContext
*
aParentContext
const
nsStyleDisplay
*
aParentDisplay
)
{
if
(
aDisplay
-
>
IsOutOfFlowStyle
(
)
)
{
return
false
;
}
if
(
aContext
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
AnonBox
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
aContext
-
>
GetPseudo
(
)
)
&
&
!
RubyUtils
:
:
IsRubyPseudo
(
aContext
-
>
GetPseudo
(
)
)
)
{
return
false
;
}
if
(
aParentContext
-
>
ShouldSuppressLineBreak
(
)
)
{
if
(
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Inline
|
|
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
|
|
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Ruby
|
|
aParentDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
)
{
return
true
;
}
}
if
(
(
aParentDisplay
-
>
IsRubyDisplayType
(
)
&
&
aDisplay
-
>
mDisplay
!
=
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
&
&
aDisplay
-
>
mDisplay
!
=
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
)
|
|
aDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyBase
|
|
aDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyText
)
{
return
true
;
}
return
false
;
}
static
bool
ShouldBlockifyChildren
(
const
nsStyleDisplay
*
aStyleDisp
)
{
auto
displayVal
=
aStyleDisp
-
>
mDisplay
;
return
mozilla
:
:
StyleDisplay
:
:
Flex
=
=
displayVal
|
|
mozilla
:
:
StyleDisplay
:
:
InlineFlex
=
=
displayVal
|
|
mozilla
:
:
StyleDisplay
:
:
Grid
=
=
displayVal
|
|
mozilla
:
:
StyleDisplay
:
:
InlineGrid
=
=
displayVal
;
}
void
nsStyleContext
:
:
SetStyleBits
(
)
{
if
(
mParent
&
&
mParent
-
>
HasTextDecorationLines
(
)
)
{
mBits
|
=
NS_STYLE_HAS_TEXT_DECORATION_LINES
;
}
else
{
if
(
StyleTextReset
(
)
-
>
HasTextDecorationLines
(
)
)
{
mBits
|
=
NS_STYLE_HAS_TEXT_DECORATION_LINES
;
}
}
if
(
(
mParent
&
&
mParent
-
>
HasPseudoElementData
(
)
)
|
|
IsPseudoElement
(
)
)
{
mBits
|
=
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
;
}
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
(
mParent
&
&
mParent
-
>
IsInDisplayNoneSubtree
(
)
)
|
|
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
None
)
{
mBits
|
=
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
;
}
}
void
nsStyleContext
:
:
ApplyStyleFixups
(
bool
aSkipParentDisplayBasedStyleFixup
)
{
MOZ_ASSERT
(
!
mSource
.
IsServoComputedValues
(
)
"
Can
'
t
do
Gecko
style
fixups
on
Servo
values
"
)
;
#
define
GET_UNIQUE_STYLE_DATA
(
name_
)
\
static_cast
<
nsStyle
#
#
name_
*
>
(
GetUniqueStyleData
(
eStyleStruct_
#
#
name_
)
)
if
(
mPseudoTag
=
=
nsCSSPseudoElements
:
:
firstLetter
)
{
const
nsStyleTextReset
*
textReset
=
StyleTextReset
(
)
;
if
(
textReset
-
>
mInitialLetterSize
!
=
0
.
0f
)
{
nsStyleContext
*
containerSC
=
mParent
;
const
nsStyleDisplay
*
containerDisp
=
containerSC
-
>
StyleDisplay
(
)
;
while
(
containerDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
if
(
!
containerSC
-
>
GetParent
(
)
)
{
break
;
}
containerSC
=
containerSC
-
>
GetParent
(
)
;
containerDisp
=
containerSC
-
>
StyleDisplay
(
)
;
}
nscoord
containerLH
=
ReflowInput
:
:
CalcLineHeight
(
nullptr
containerSC
NS_AUTOHEIGHT
1
.
0f
)
;
RefPtr
<
nsFontMetrics
>
containerFM
=
nsLayoutUtils
:
:
GetFontMetricsForStyleContext
(
containerSC
)
;
MOZ_ASSERT
(
containerFM
"
Should
have
fontMetrics
!
!
"
)
;
nscoord
containerCH
=
containerFM
-
>
CapHeight
(
)
;
RefPtr
<
nsFontMetrics
>
firstLetterFM
=
nsLayoutUtils
:
:
GetFontMetricsForStyleContext
(
this
)
;
MOZ_ASSERT
(
firstLetterFM
"
Should
have
fontMetrics
!
!
"
)
;
nscoord
firstLetterCH
=
firstLetterFM
-
>
CapHeight
(
)
;
nsStyleFont
*
mutableStyleFont
=
GET_UNIQUE_STYLE_DATA
(
Font
)
;
float
invCapHeightRatio
=
mutableStyleFont
-
>
mFont
.
size
/
NSCoordToFloat
(
firstLetterCH
)
;
mutableStyleFont
-
>
mFont
.
size
=
NSToCoordRound
(
(
(
textReset
-
>
mInitialLetterSize
-
1
)
*
containerLH
+
containerCH
)
*
invCapHeightRatio
)
;
}
}
if
(
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
mozText
&
&
mParent
&
&
mParent
-
>
StyleVisibility
(
)
-
>
mWritingMode
!
=
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
&
&
mParent
-
>
StyleText
(
)
-
>
mTextCombineUpright
=
=
NS_STYLE_TEXT_COMBINE_UPRIGHT_ALL
)
{
MOZ_ASSERT
(
!
PeekStyleVisibility
(
)
"
If
StyleVisibility
was
already
"
"
computed
some
properties
may
have
been
computed
"
"
incorrectly
based
on
the
old
writing
mode
value
"
)
;
nsStyleVisibility
*
mutableVis
=
GET_UNIQUE_STYLE_DATA
(
Visibility
)
;
mutableVis
-
>
mWritingMode
=
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
;
AddStyleBit
(
NS_STYLE_IS_TEXT_COMBINED
)
;
}
if
(
mPseudoTag
=
=
nsCSSAnonBoxes
:
:
viewport
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
mozilla
:
:
dom
:
:
Element
*
docElement
=
presContext
-
>
Document
(
)
-
>
GetRootElement
(
)
;
if
(
docElement
)
{
RefPtr
<
nsStyleContext
>
rootStyle
=
presContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
-
>
ResolveStyleFor
(
docElement
nullptr
)
;
auto
dir
=
rootStyle
-
>
StyleVisibility
(
)
-
>
mDirection
;
if
(
dir
!
=
StyleVisibility
(
)
-
>
mDirection
)
{
nsStyleVisibility
*
uniqueVisibility
=
GET_UNIQUE_STYLE_DATA
(
Visibility
)
;
uniqueVisibility
-
>
mDirection
=
dir
;
}
}
}
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Table
)
{
const
nsStyleText
*
text
=
StyleText
(
)
;
if
(
text
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_LEFT
|
|
text
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_CENTER
|
|
text
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_RIGHT
)
{
nsStyleText
*
uniqueText
=
GET_UNIQUE_STYLE_DATA
(
Text
)
;
uniqueText
-
>
mTextAlign
=
NS_STYLE_TEXT_ALIGN_START
;
}
}
if
(
!
mParent
)
{
auto
displayVal
=
disp
-
>
mDisplay
;
if
(
displayVal
!
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
nsRuleNode
:
:
EnsureBlockDisplay
(
displayVal
true
)
;
}
else
{
displayVal
=
mozilla
:
:
StyleDisplay
:
:
Block
;
}
if
(
displayVal
!
=
disp
-
>
mDisplay
)
{
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mOriginalDisplay
=
mutable_display
-
>
mDisplay
=
displayVal
;
}
}
if
(
!
aSkipParentDisplayBasedStyleFixup
&
&
mParent
)
{
nsStyleContext
*
containerContext
=
mParent
;
const
nsStyleDisplay
*
containerDisp
=
containerContext
-
>
StyleDisplay
(
)
;
while
(
containerDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
if
(
!
containerContext
-
>
GetParent
(
)
)
{
break
;
}
containerContext
=
containerContext
-
>
GetParent
(
)
;
containerDisp
=
containerContext
-
>
StyleDisplay
(
)
;
}
if
(
ShouldBlockifyChildren
(
containerDisp
)
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
GetPseudo
(
)
)
)
{
auto
displayVal
=
disp
-
>
mDisplay
;
nsRuleNode
:
:
EnsureBlockDisplay
(
displayVal
)
;
if
(
displayVal
!
=
disp
-
>
mDisplay
)
{
NS_ASSERTION
(
!
disp
-
>
IsAbsolutelyPositionedStyle
(
)
"
We
shouldn
'
t
be
changing
the
display
value
of
"
"
positioned
content
(
and
we
should
have
already
"
"
converted
its
display
value
to
be
block
-
level
.
.
.
)
"
)
;
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mDisplay
=
displayVal
;
}
}
}
if
(
mParent
&
&
:
:
ShouldSuppressLineBreak
(
this
disp
mParent
mParent
-
>
StyleDisplay
(
)
)
)
{
mBits
|
=
NS_STYLE_SUPPRESS_LINEBREAK
;
auto
displayVal
=
disp
-
>
mDisplay
;
nsRuleNode
:
:
EnsureInlineDisplay
(
displayVal
)
;
if
(
displayVal
!
=
disp
-
>
mDisplay
)
{
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mDisplay
=
displayVal
;
}
}
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
|
|
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
)
{
CreateEmptyStyleData
(
eStyleStruct_Border
)
;
CreateEmptyStyleData
(
eStyleStruct_Padding
)
;
}
if
(
disp
-
>
IsRubyDisplayType
(
)
)
{
const
nsStyleTextReset
*
textReset
=
StyleTextReset
(
)
;
uint8_t
unicodeBidi
=
textReset
-
>
mUnicodeBidi
;
if
(
unicodeBidi
=
=
NS_STYLE_UNICODE_BIDI_NORMAL
|
|
unicodeBidi
=
=
NS_STYLE_UNICODE_BIDI_EMBED
)
{
unicodeBidi
=
NS_STYLE_UNICODE_BIDI_ISOLATE
;
}
else
if
(
unicodeBidi
=
=
NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE
)
{
unicodeBidi
=
NS_STYLE_UNICODE_BIDI_ISOLATE_OVERRIDE
;
}
if
(
unicodeBidi
!
=
textReset
-
>
mUnicodeBidi
)
{
nsStyleTextReset
*
mutableTextReset
=
GET_UNIQUE_STYLE_DATA
(
TextReset
)
;
mutableTextReset
-
>
mUnicodeBidi
=
unicodeBidi
;
}
}
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Inline
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
mPseudoTag
)
&
&
mParent
)
{
auto
cbContext
=
mParent
;
while
(
cbContext
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
cbContext
=
cbContext
-
>
mParent
;
}
MOZ_ASSERT
(
cbContext
"
the
root
context
can
'
t
have
display
:
contents
"
)
;
if
(
StyleVisibility
(
)
-
>
mWritingMode
!
=
cbContext
-
>
StyleVisibility
(
)
-
>
mWritingMode
)
{
nsStyleDisplay
*
mutable_display
=
GET_UNIQUE_STYLE_DATA
(
Display
)
;
disp
=
mutable_display
;
mutable_display
-
>
mOriginalDisplay
=
mutable_display
-
>
mDisplay
=
mozilla
:
:
StyleDisplay
:
:
InlineBlock
;
}
}
StyleUserInterface
(
)
;
#
undef
GET_UNIQUE_STYLE_DATA
}
template
<
class
StyleContextLike
>
nsChangeHint
nsStyleContext
:
:
CalcStyleDifferenceInternal
(
StyleContextLike
*
aNewContext
nsChangeHint
aParentHintsNotHandledForDescendants
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
{
PROFILER_LABEL
(
"
nsStyleContext
"
"
CalcStyleDifference
"
js
:
:
ProfileEntry
:
:
Category
:
:
CSS
)
;
MOZ_ASSERT
(
NS_IsHintSubset
(
aParentHintsNotHandledForDescendants
nsChangeHint_Hints_NotHandledForDescendants
)
"
caller
is
passing
inherited
hints
but
shouldn
'
t
be
"
)
;
static_assert
(
nsStyleStructID_Length
<
=
32
"
aEqualStructs
is
not
big
enough
"
)
;
*
aEqualStructs
=
0
;
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
NS_ENSURE_TRUE
(
aNewContext
hint
)
;
bool
compare
=
StyleSource
(
)
!
=
aNewContext
-
>
StyleSource
(
)
;
DebugOnly
<
uint32_t
>
structsFound
=
0
;
const
nsStyleVariables
*
thisVariables
=
PeekStyleVariables
(
)
;
if
(
thisVariables
)
{
structsFound
|
=
NS_STYLE_INHERIT_BIT
(
Variables
)
;
const
nsStyleVariables
*
otherVariables
=
aNewContext
-
>
StyleVariables
(
)
;
if
(
thisVariables
-
>
mVariables
=
=
otherVariables
-
>
mVariables
)
{
*
aEqualStructs
|
=
NS_STYLE_INHERIT_BIT
(
Variables
)
;
}
else
{
compare
=
true
;
}
}
else
{
*
aEqualStructs
|
=
NS_STYLE_INHERIT_BIT
(
Variables
)
;
}
DebugOnly
<
int
>
styleStructCount
=
1
;
#
define
DO_STRUCT_DIFFERENCE
(
struct_
)
\
PR_BEGIN_MACRO
\
const
nsStyle
#
#
struct_
*
this
#
#
struct_
=
PeekStyle
#
#
struct_
(
)
;
\
if
(
this
#
#
struct_
)
{
\
structsFound
|
=
NS_STYLE_INHERIT_BIT
(
struct_
)
;
\
const
nsStyle
#
#
struct_
*
other
#
#
struct_
=
aNewContext
-
>
Style
#
#
struct_
(
)
;
\
nsChangeHint
maxDifference
=
nsStyle
#
#
struct_
:
:
MaxDifference
(
)
;
\
nsChangeHint
differenceAlwaysHandledForDescendants
=
\
nsStyle
#
#
struct_
:
:
DifferenceAlwaysHandledForDescendants
(
)
;
\
if
(
this
#
#
struct_
=
=
other
#
#
struct_
)
{
\
/
*
The
very
same
struct
so
we
know
that
there
will
be
no
*
/
\
/
*
differences
.
*
/
\
*
aEqualStructs
|
=
NS_STYLE_INHERIT_BIT
(
struct_
)
;
\
}
else
if
(
compare
|
|
\
(
(
maxDifference
&
~
differenceAlwaysHandledForDescendants
)
&
\
aParentHintsNotHandledForDescendants
)
)
{
\
nsChangeHint
difference
=
\
this
#
#
struct_
-
>
CalcDifference
(
*
other
#
#
struct_
EXTRA_DIFF_ARGS
)
;
\
NS_ASSERTION
(
NS_IsHintSubset
(
difference
maxDifference
)
\
"
CalcDifference
(
)
returned
bigger
hint
than
"
\
"
MaxDifference
(
)
"
)
;
\
hint
|
=
difference
;
\
if
(
!
difference
)
{
\
*
aEqualStructs
|
=
NS_STYLE_INHERIT_BIT
(
struct_
)
;
\
}
\
}
else
{
\
/
*
We
still
must
call
CalcDifference
to
see
if
there
were
any
*
/
\
/
*
changes
so
that
we
can
set
*
aEqualStructs
appropriately
.
*
/
\
nsChangeHint
difference
=
\
this
#
#
struct_
-
>
CalcDifference
(
*
other
#
#
struct_
EXTRA_DIFF_ARGS
)
;
\
NS_ASSERTION
(
NS_IsHintSubset
(
difference
maxDifference
)
\
"
CalcDifference
(
)
returned
bigger
hint
than
"
\
"
MaxDifference
(
)
"
)
;
\
if
(
!
difference
)
{
\
*
aEqualStructs
|
=
NS_STYLE_INHERIT_BIT
(
struct_
)
;
\
}
\
}
\
}
else
{
\
*
aEqualStructs
|
=
NS_STYLE_INHERIT_BIT
(
struct_
)
;
\
}
\
styleStructCount
+
+
;
\
PR_END_MACRO
#
define
EXTRA_DIFF_ARGS
DO_STRUCT_DIFFERENCE
(
Display
)
;
DO_STRUCT_DIFFERENCE
(
XUL
)
;
DO_STRUCT_DIFFERENCE
(
Column
)
;
DO_STRUCT_DIFFERENCE
(
Content
)
;
DO_STRUCT_DIFFERENCE
(
UserInterface
)
;
DO_STRUCT_DIFFERENCE
(
Visibility
)
;
DO_STRUCT_DIFFERENCE
(
Outline
)
;
DO_STRUCT_DIFFERENCE
(
TableBorder
)
;
DO_STRUCT_DIFFERENCE
(
Table
)
;
DO_STRUCT_DIFFERENCE
(
UIReset
)
;
DO_STRUCT_DIFFERENCE
(
Text
)
;
DO_STRUCT_DIFFERENCE
(
List
)
;
DO_STRUCT_DIFFERENCE
(
SVGReset
)
;
DO_STRUCT_DIFFERENCE
(
SVG
)
;
#
undef
EXTRA_DIFF_ARGS
#
define
EXTRA_DIFF_ARGS
PeekStyleVisibility
(
)
DO_STRUCT_DIFFERENCE
(
Position
)
;
#
undef
EXTRA_DIFF_ARGS
#
define
EXTRA_DIFF_ARGS
DO_STRUCT_DIFFERENCE
(
Font
)
;
DO_STRUCT_DIFFERENCE
(
Margin
)
;
DO_STRUCT_DIFFERENCE
(
Padding
)
;
DO_STRUCT_DIFFERENCE
(
Border
)
;
DO_STRUCT_DIFFERENCE
(
TextReset
)
;
DO_STRUCT_DIFFERENCE
(
Effects
)
;
DO_STRUCT_DIFFERENCE
(
Background
)
;
DO_STRUCT_DIFFERENCE
(
Color
)
;
#
undef
EXTRA_DIFF_ARGS
#
undef
DO_STRUCT_DIFFERENCE
MOZ_ASSERT
(
styleStructCount
=
=
nsStyleStructID_Length
"
missing
a
call
to
DO_STRUCT_DIFFERENCE
"
)
;
#
ifdef
DEBUG
#
define
STYLE_STRUCT
(
name_
callback_
)
\
MOZ_ASSERT
(
!
!
(
structsFound
&
NS_STYLE_INHERIT_BIT
(
name_
)
)
=
=
\
!
!
PeekStyle
#
#
name_
(
)
\
"
PeekStyleData
results
must
not
change
in
the
middle
of
"
\
"
difference
calculation
.
"
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
#
endif
*
aSamePointerStructs
=
0
;
#
define
STYLE_STRUCT
(
name_
callback_
)
\
{
\
const
nsStyle
#
#
name_
*
data
=
PeekStyle
#
#
name_
(
)
;
\
if
(
!
data
|
|
data
=
=
aNewContext
-
>
Style
#
#
name_
(
)
)
{
\
*
aSamePointerStructs
|
=
NS_STYLE_INHERIT_BIT
(
name_
)
;
\
}
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
nsStyleContext
*
thisVis
=
GetStyleIfVisited
(
)
*
otherVis
=
aNewContext
-
>
GetStyleIfVisited
(
)
;
if
(
!
thisVis
!
=
!
otherVis
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
else
if
(
thisVis
&
&
!
NS_IsHintSubset
(
nsChangeHint_RepaintFrame
hint
)
)
{
bool
change
=
false
;
#
define
STYLE_FIELD
(
name_
)
thisVisStruct
-
>
name_
!
=
otherVisStruct
-
>
name_
|
|
#
define
STYLE_STRUCT
(
name_
fields_
)
\
if
(
!
change
&
&
PeekStyle
#
#
name_
(
)
)
{
\
const
nsStyle
#
#
name_
*
thisVisStruct
=
thisVis
-
>
Style
#
#
name_
(
)
;
\
const
nsStyle
#
#
name_
*
otherVisStruct
=
otherVis
-
>
Style
#
#
name_
(
)
;
\
if
(
MOZ_FOR_EACH
(
STYLE_FIELD
(
)
fields_
)
false
)
{
\
change
=
true
;
\
}
\
}
#
include
"
nsCSSVisitedDependentPropList
.
h
"
#
undef
STYLE_STRUCT
#
undef
STYLE_FIELD
if
(
change
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
}
if
(
hint
&
nsChangeHint_UpdateContainingBlock
)
{
if
(
ThreadsafeStyleDisplay
(
)
-
>
IsAbsPosContainingBlockForAppropriateFrame
(
this
)
=
=
aNewContext
-
>
ThreadsafeStyleDisplay
(
)
-
>
IsAbsPosContainingBlockForAppropriateFrame
(
aNewContext
)
&
&
ThreadsafeStyleDisplay
(
)
-
>
IsFixedPosContainingBlockForAppropriateFrame
(
this
)
=
=
aNewContext
-
>
ThreadsafeStyleDisplay
(
)
-
>
IsFixedPosContainingBlockForAppropriateFrame
(
aNewContext
)
)
{
hint
&
=
~
nsChangeHint_UpdateContainingBlock
;
}
}
MOZ_ASSERT
(
NS_IsHintSubset
(
hint
nsChangeHint_AllHints
)
"
Added
a
new
hint
without
bumping
AllHints
?
"
)
;
return
hint
&
~
nsChangeHint_NeutralChange
;
}
nsChangeHint
nsStyleContext
:
:
CalcStyleDifference
(
nsStyleContext
*
aNewContext
nsChangeHint
aParentHintsNotHandledForDescendants
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
{
return
CalcStyleDifferenceInternal
(
aNewContext
aParentHintsNotHandledForDescendants
aEqualStructs
aSamePointerStructs
)
;
}
class
MOZ_STACK_CLASS
FakeStyleContext
{
public
:
explicit
FakeStyleContext
(
const
ServoComputedValues
*
aComputedValues
)
:
mComputedValues
(
aComputedValues
)
{
}
mozilla
:
:
NonOwningStyleContextSource
StyleSource
(
)
const
{
return
mozilla
:
:
NonOwningStyleContextSource
(
mComputedValues
)
;
}
nsStyleContext
*
GetStyleIfVisited
(
)
{
return
nullptr
;
}
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
const
nsStyle
#
#
name_
*
Style
#
#
name_
(
)
{
\
return
Servo_GetStyle
#
#
name_
(
mComputedValues
)
;
\
}
\
const
nsStyle
#
#
name_
*
ThreadsafeStyle
#
#
name_
(
)
{
\
return
Servo_GetStyle
#
#
name_
(
mComputedValues
)
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
private
:
const
ServoComputedValues
*
MOZ_NON_OWNING_REF
mComputedValues
;
}
;
nsChangeHint
nsStyleContext
:
:
CalcStyleDifference
(
const
ServoComputedValues
*
aNewComputedValues
nsChangeHint
aParentHintsNotHandledForDescendants
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
{
FakeStyleContext
newContext
(
aNewComputedValues
)
;
return
CalcStyleDifferenceInternal
(
&
newContext
aParentHintsNotHandledForDescendants
aEqualStructs
aSamePointerStructs
)
;
}
#
ifdef
DEBUG
void
nsStyleContext
:
:
List
(
FILE
*
out
int32_t
aIndent
bool
aListDescendants
)
{
nsAutoCString
str
;
int32_t
ix
;
for
(
ix
=
aIndent
;
-
-
ix
>
=
0
;
)
{
str
.
AppendLiteral
(
"
"
)
;
}
str
.
Append
(
nsPrintfCString
(
"
%
p
(
%
d
)
parent
=
%
p
"
(
void
*
)
this
mRefCnt
(
void
*
)
mParent
)
)
;
if
(
mPseudoTag
)
{
nsAutoString
buffer
;
mPseudoTag
-
>
ToString
(
buffer
)
;
AppendUTF16toUTF8
(
buffer
str
)
;
str
.
Append
(
'
'
)
;
}
if
(
mSource
.
IsServoComputedValues
(
)
)
{
fprintf_stderr
(
out
"
%
s
{
ServoComputedValues
}
\
n
"
str
.
get
(
)
)
;
}
else
if
(
mSource
.
IsGeckoRuleNode
(
)
)
{
fprintf_stderr
(
out
"
%
s
{
\
n
"
str
.
get
(
)
)
;
str
.
Truncate
(
)
;
nsRuleNode
*
ruleNode
=
mSource
.
AsGeckoRuleNode
(
)
;
while
(
ruleNode
)
{
nsIStyleRule
*
styleRule
=
ruleNode
-
>
GetRule
(
)
;
if
(
styleRule
)
{
styleRule
-
>
List
(
out
aIndent
+
1
)
;
}
ruleNode
=
ruleNode
-
>
GetParent
(
)
;
}
for
(
ix
=
aIndent
;
-
-
ix
>
=
0
;
)
{
str
.
AppendLiteral
(
"
"
)
;
}
fprintf_stderr
(
out
"
%
s
}
\
n
"
str
.
get
(
)
)
;
}
else
{
fprintf_stderr
(
out
"
%
s
{
}
\
n
"
str
.
get
(
)
)
;
}
if
(
aListDescendants
)
{
if
(
nullptr
!
=
mChild
)
{
nsStyleContext
*
child
=
mChild
;
do
{
child
-
>
List
(
out
aIndent
+
1
aListDescendants
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
nullptr
!
=
mEmptyChild
)
{
nsStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
List
(
out
aIndent
+
1
aListDescendants
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
}
#
endif
void
*
nsStyleContext
:
:
operator
new
(
size_t
sz
nsPresContext
*
aPresContext
)
{
return
aPresContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
eArenaObjectID_nsStyleContext
sz
)
;
}
void
nsStyleContext
:
:
Destroy
(
)
{
RefPtr
<
nsPresContext
>
presContext
=
PresContext
(
)
;
this
-
>
~
nsStyleContext
(
)
;
presContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
eArenaObjectID_nsStyleContext
this
)
;
}
already_AddRefed
<
nsStyleContext
>
NS_NewStyleContext
(
nsStyleContext
*
aParentContext
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
nsRuleNode
*
aRuleNode
bool
aSkipParentDisplayBasedStyleFixup
)
{
RefPtr
<
nsRuleNode
>
node
=
aRuleNode
;
RefPtr
<
nsStyleContext
>
context
=
new
(
aRuleNode
-
>
PresContext
(
)
)
nsStyleContext
(
aParentContext
aPseudoTag
aPseudoType
node
.
forget
(
)
aSkipParentDisplayBasedStyleFixup
)
;
return
context
.
forget
(
)
;
}
already_AddRefed
<
nsStyleContext
>
NS_NewStyleContext
(
nsStyleContext
*
aParentContext
nsPresContext
*
aPresContext
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
already_AddRefed
<
ServoComputedValues
>
aComputedValues
bool
aSkipParentDisplayBasedStyleFixup
)
{
RefPtr
<
nsStyleContext
>
context
=
new
(
aPresContext
)
nsStyleContext
(
aParentContext
aPresContext
aPseudoTag
aPseudoType
Move
(
aComputedValues
)
aSkipParentDisplayBasedStyleFixup
)
;
return
context
.
forget
(
)
;
}
nsIPresShell
*
nsStyleContext
:
:
Arena
(
)
{
return
PresContext
(
)
-
>
PresShell
(
)
;
}
template
<
typename
Func
>
static
nscolor
GetVisitedDependentColorInternal
(
nsStyleContext
*
aSc
Func
aColorFunc
)
{
nscolor
colors
[
2
]
;
colors
[
0
]
=
aColorFunc
(
aSc
)
;
if
(
nsStyleContext
*
visitedStyle
=
aSc
-
>
GetStyleIfVisited
(
)
)
{
colors
[
1
]
=
aColorFunc
(
visitedStyle
)
;
return
nsStyleContext
:
:
CombineVisitedColors
(
colors
aSc
-
>
RelevantLinkVisited
(
)
)
;
}
return
colors
[
0
]
;
}
static
nscolor
ExtractColor
(
nsStyleContext
*
aContext
const
nscolor
&
aColor
)
{
return
aColor
;
}
static
nscolor
ExtractColor
(
nsStyleContext
*
aContext
const
StyleComplexColor
&
aColor
)
{
return
aContext
-
>
StyleColor
(
)
-
>
CalcComplexColor
(
aColor
)
;
}
static
nscolor
ExtractColor
(
nsStyleContext
*
aContext
const
nsStyleSVGPaint
&
aPaintServer
)
{
return
aPaintServer
.
Type
(
)
=
=
eStyleSVGPaintType_Color
?
aPaintServer
.
GetColor
(
)
:
NS_RGBA
(
0
0
0
0
)
;
}
#
define
STYLE_FIELD
(
struct_
field_
)
aField
=
=
&
struct_
:
:
field_
|
|
#
define
STYLE_STRUCT
(
name_
fields_
)
\
template
<
>
nscolor
\
nsStyleContext
:
:
GetVisitedDependentColor
(
\
decltype
(
nsStyle
#
#
name_
:
:
MOZ_ARG_1
fields_
)
nsStyle
#
#
name_
:
:
*
aField
)
\
{
\
MOZ_ASSERT
(
MOZ_FOR_EACH
(
STYLE_FIELD
(
nsStyle
#
#
name_
)
fields_
)
false
\
"
Getting
visited
-
dependent
color
for
a
field
in
nsStyle
"
#
name_
\
"
which
is
not
listed
in
nsCSSVisitedDependentPropList
.
h
"
)
;
\
return
GetVisitedDependentColorInternal
(
this
\
[
aField
]
(
nsStyleContext
*
sc
)
{
\
return
ExtractColor
(
sc
sc
-
>
Style
#
#
name_
(
)
-
>
*
aField
)
;
\
}
)
;
\
}
#
include
"
nsCSSVisitedDependentPropList
.
h
"
#
undef
STYLE_STRUCT
#
undef
STYLE_FIELD
struct
ColorIndexSet
{
uint8_t
colorIndex
alphaIndex
;
}
;
static
const
ColorIndexSet
gVisitedIndices
[
2
]
=
{
{
0
0
}
{
1
0
}
}
;
nscolor
nsStyleContext
:
:
CombineVisitedColors
(
nscolor
*
aColors
bool
aLinkIsVisited
)
{
if
(
NS_GET_A
(
aColors
[
1
]
)
=
=
0
)
{
aLinkIsVisited
=
false
;
}
const
ColorIndexSet
&
set
=
gVisitedIndices
[
aLinkIsVisited
?
1
:
0
]
;
nscolor
colorColor
=
aColors
[
set
.
colorIndex
]
;
nscolor
alphaColor
=
aColors
[
set
.
alphaIndex
]
;
return
NS_RGBA
(
NS_GET_R
(
colorColor
)
NS_GET_G
(
colorColor
)
NS_GET_B
(
colorColor
)
NS_GET_A
(
alphaColor
)
)
;
}
#
ifdef
DEBUG
void
nsStyleContext
:
:
AssertStyleStructMaxDifferenceValid
(
)
{
#
define
STYLE_STRUCT
(
name
checkdata_cb
)
\
MOZ_ASSERT
(
NS_IsHintSubset
(
nsStyle
#
#
name
:
:
DifferenceAlwaysHandledForDescendants
(
)
\
nsStyle
#
#
name
:
:
MaxDifference
(
)
)
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
}
const
char
*
nsStyleContext
:
:
StructName
(
nsStyleStructID
aSID
)
{
switch
(
aSID
)
{
#
define
STYLE_STRUCT
(
name_
checkdata_cb
)
\
case
eStyleStruct_
#
#
name_
:
\
return
#
name_
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
default
:
return
"
Unknown
"
;
}
}
bool
nsStyleContext
:
:
LookupStruct
(
const
nsACString
&
aName
nsStyleStructID
&
aResult
)
{
if
(
false
)
;
#
define
STYLE_STRUCT
(
name_
checkdata_cb_
)
\
else
if
(
aName
.
EqualsLiteral
(
#
name_
)
)
\
aResult
=
eStyleStruct_
#
#
name_
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
else
return
false
;
return
true
;
}
#
endif
void
nsStyleContext
:
:
SwapStyleData
(
nsStyleContext
*
aNewContext
uint32_t
aStructs
)
{
static_assert
(
nsStyleStructID_Length
<
=
32
"
aStructs
is
not
big
enough
"
)
;
for
(
nsStyleStructID
i
=
nsStyleStructID_Inherited_Start
;
i
<
nsStyleStructID_Inherited_Start
+
nsStyleStructID_Inherited_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
!
(
aStructs
&
bit
)
)
{
continue
;
}
void
*
&
thisData
=
mCachedInheritedData
.
mStyleStructs
[
i
]
;
void
*
&
otherData
=
aNewContext
-
>
mCachedInheritedData
.
mStyleStructs
[
i
]
;
if
(
mBits
&
bit
)
{
if
(
thisData
=
=
otherData
)
{
thisData
=
nullptr
;
}
}
else
if
(
!
(
aNewContext
-
>
mBits
&
bit
)
&
&
thisData
&
&
otherData
)
{
std
:
:
swap
(
thisData
otherData
)
;
}
}
for
(
nsStyleStructID
i
=
nsStyleStructID_Reset_Start
;
i
<
nsStyleStructID_Reset_Start
+
nsStyleStructID_Reset_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
!
(
aStructs
&
bit
)
)
{
continue
;
}
if
(
!
mCachedResetData
)
{
mCachedResetData
=
new
(
PresContext
(
)
)
nsResetStyleData
;
}
if
(
!
aNewContext
-
>
mCachedResetData
)
{
aNewContext
-
>
mCachedResetData
=
new
(
PresContext
(
)
)
nsResetStyleData
;
}
void
*
&
thisData
=
mCachedResetData
-
>
mStyleStructs
[
i
]
;
void
*
&
otherData
=
aNewContext
-
>
mCachedResetData
-
>
mStyleStructs
[
i
]
;
if
(
mBits
&
bit
)
{
if
(
thisData
=
=
otherData
)
{
thisData
=
nullptr
;
}
}
else
if
(
!
(
aNewContext
-
>
mBits
&
bit
)
&
&
thisData
&
&
otherData
)
{
std
:
:
swap
(
thisData
otherData
)
;
}
}
}
void
nsStyleContext
:
:
ClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
{
if
(
mChild
)
{
nsStyleContext
*
child
=
mChild
;
do
{
child
-
>
DoClearCachedInheritedStyleDataOnDescendants
(
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
mEmptyChild
)
{
nsStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
DoClearCachedInheritedStyleDataOnDescendants
(
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
void
nsStyleContext
:
:
DoClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
{
NS_ASSERTION
(
mFrameRefCnt
=
=
0
"
frame
still
referencing
style
context
"
)
;
for
(
nsStyleStructID
i
=
nsStyleStructID_Inherited_Start
;
i
<
nsStyleStructID_Inherited_Start
+
nsStyleStructID_Inherited_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
aStructs
&
bit
)
{
if
(
!
(
mBits
&
bit
)
&
&
mCachedInheritedData
.
mStyleStructs
[
i
]
)
{
aStructs
&
=
~
bit
;
}
else
{
mCachedInheritedData
.
mStyleStructs
[
i
]
=
nullptr
;
}
}
}
if
(
mCachedResetData
)
{
for
(
nsStyleStructID
i
=
nsStyleStructID_Reset_Start
;
i
<
nsStyleStructID_Reset_Start
+
nsStyleStructID_Reset_Count
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
uint32_t
bit
=
nsCachedStyleData
:
:
GetBitForSID
(
i
)
;
if
(
aStructs
&
bit
)
{
if
(
!
(
mBits
&
bit
)
&
&
mCachedResetData
-
>
mStyleStructs
[
i
]
)
{
aStructs
&
=
~
bit
;
}
else
{
mCachedResetData
-
>
mStyleStructs
[
i
]
=
nullptr
;
}
}
}
}
if
(
aStructs
=
=
0
)
{
return
;
}
ClearCachedInheritedStyleDataOnDescendants
(
aStructs
)
;
}
void
nsStyleContext
:
:
SetIneligibleForSharing
(
)
{
if
(
mBits
&
NS_STYLE_INELIGIBLE_FOR_SHARING
)
{
return
;
}
mBits
|
=
NS_STYLE_INELIGIBLE_FOR_SHARING
;
if
(
mChild
)
{
nsStyleContext
*
child
=
mChild
;
do
{
child
-
>
SetIneligibleForSharing
(
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
mEmptyChild
)
{
nsStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
SetIneligibleForSharing
(
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
#
ifdef
RESTYLE_LOGGING
nsCString
nsStyleContext
:
:
GetCachedStyleDataAsString
(
uint32_t
aStructs
)
{
nsCString
structs
;
for
(
nsStyleStructID
i
=
nsStyleStructID
(
0
)
;
i
<
nsStyleStructID_Length
;
i
=
nsStyleStructID
(
i
+
1
)
)
{
if
(
aStructs
&
nsCachedStyleData
:
:
GetBitForSID
(
i
)
)
{
const
void
*
data
=
GetCachedStyleData
(
i
)
;
if
(
!
structs
.
IsEmpty
(
)
)
{
structs
.
Append
(
'
'
)
;
}
structs
.
AppendPrintf
(
"
%
s
=
%
p
"
StructName
(
i
)
data
)
;
if
(
HasCachedDependentStyleData
(
i
)
)
{
structs
.
AppendLiteral
(
"
(
dependent
)
"
)
;
}
else
{
structs
.
AppendLiteral
(
"
(
owned
)
"
)
;
}
}
}
return
structs
;
}
int32_t
&
nsStyleContext
:
:
LoggingDepth
(
)
{
static
int32_t
depth
=
0
;
return
depth
;
}
void
nsStyleContext
:
:
LogStyleContextTree
(
int32_t
aLoggingDepth
uint32_t
aStructs
)
{
LoggingDepth
(
)
=
aLoggingDepth
;
LogStyleContextTree
(
true
aStructs
)
;
}
void
nsStyleContext
:
:
LogStyleContextTree
(
bool
aFirst
uint32_t
aStructs
)
{
nsCString
structs
=
GetCachedStyleDataAsString
(
aStructs
)
;
if
(
!
structs
.
IsEmpty
(
)
)
{
structs
.
Append
(
'
'
)
;
}
nsCString
pseudo
;
if
(
mPseudoTag
)
{
nsAutoString
pseudoTag
;
mPseudoTag
-
>
ToString
(
pseudoTag
)
;
AppendUTF16toUTF8
(
pseudoTag
pseudo
)
;
pseudo
.
Append
(
'
'
)
;
}
nsCString
flags
;
if
(
IsStyleIfVisited
(
)
)
{
flags
.
AppendLiteral
(
"
IS_STYLE_IF_VISITED
"
)
;
}
if
(
HasChildThatUsesGrandancestorStyle
(
)
)
{
flags
.
AppendLiteral
(
"
CHILD_USES_GRANDANCESTOR_STYLE
"
)
;
}
if
(
IsShared
(
)
)
{
flags
.
AppendLiteral
(
"
IS_SHARED
"
)
;
}
nsCString
parent
;
if
(
aFirst
)
{
parent
.
AppendPrintf
(
"
parent
=
%
p
"
mParent
.
get
(
)
)
;
}
LOG_RESTYLE
(
"
%
p
(
%
d
)
%
s
%
s
%
s
%
s
"
this
mRefCnt
structs
.
get
(
)
pseudo
.
get
(
)
flags
.
get
(
)
parent
.
get
(
)
)
;
LOG_RESTYLE_INDENT
(
)
;
if
(
nullptr
!
=
mChild
)
{
nsStyleContext
*
child
=
mChild
;
do
{
child
-
>
LogStyleContextTree
(
false
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mChild
!
=
child
)
;
}
if
(
nullptr
!
=
mEmptyChild
)
{
nsStyleContext
*
child
=
mEmptyChild
;
do
{
child
-
>
LogStyleContextTree
(
false
aStructs
)
;
child
=
child
-
>
mNextSibling
;
}
while
(
mEmptyChild
!
=
child
)
;
}
}
#
endif
#
ifdef
DEBUG
void
nsStyleContext
:
:
Initialize
(
)
{
Preferences
:
:
AddBoolVarCache
(
&
sExpensiveStyleStructAssertionsEnabled
"
layout
.
css
.
expensive
-
style
-
struct
-
assertions
.
enabled
"
)
;
}
#
endif
