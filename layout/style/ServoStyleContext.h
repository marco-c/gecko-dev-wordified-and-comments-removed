#
ifndef
mozilla_ServoStyleContext_h
#
define
mozilla_ServoStyleContext_h
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
CachedAnonBoxStyles
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Element
;
}
MOZ_DEFINE_MALLOC_ENCLOSING_SIZE_OF
(
ServoComputedValuesMallocEnclosingSizeOf
)
class
ServoStyleContext
final
:
public
nsStyleContext
{
public
:
ServoStyleContext
(
nsPresContext
*
aPresContext
nsAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
ServoComputedDataForgotten
aComputedValues
)
;
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
const
ServoComputedData
*
ComputedData
(
)
const
{
return
&
mSource
;
}
void
AddRef
(
)
{
Servo_StyleContext_AddRef
(
this
)
;
}
void
Release
(
)
{
Servo_StyleContext_Release
(
this
)
;
}
ServoStyleContext
*
GetStyleIfVisited
(
)
const
{
return
ComputedData
(
)
-
>
visited_style
.
mPtr
;
}
bool
IsLazilyCascadedPseudoElement
(
)
const
{
return
IsPseudoElement
(
)
&
&
!
nsCSSPseudoElements
:
:
IsEagerlyCascadedInServo
(
GetPseudoType
(
)
)
;
}
ServoStyleContext
*
GetCachedInheritingAnonBoxStyle
(
nsAtom
*
aAnonBox
)
const
{
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsInheritingAnonBox
(
aAnonBox
)
)
;
if
(
IsInheritingAnonBox
(
)
)
{
return
nullptr
;
}
return
mInheritingAnonBoxStyles
.
Lookup
(
aAnonBox
)
;
}
void
SetCachedInheritedAnonBoxStyle
(
nsAtom
*
aAnonBox
ServoStyleContext
*
aStyle
)
{
MOZ_ASSERT
(
!
GetCachedInheritingAnonBoxStyle
(
aAnonBox
)
)
;
if
(
IsInheritingAnonBox
(
)
)
{
return
;
}
mInheritingAnonBoxStyles
.
Insert
(
aStyle
)
;
}
ServoStyleContext
*
GetCachedLazyPseudoStyle
(
CSSPseudoElementType
aPseudo
)
const
;
void
SetCachedLazyPseudoStyle
(
ServoStyleContext
*
aStyle
)
{
MOZ_ASSERT
(
aStyle
-
>
GetPseudo
(
)
&
&
!
aStyle
-
>
IsAnonBox
(
)
)
;
MOZ_ASSERT
(
!
GetCachedLazyPseudoStyle
(
aStyle
-
>
GetPseudoType
(
)
)
)
;
MOZ_ASSERT
(
!
aStyle
-
>
mNextLazyPseudoStyle
)
;
MOZ_ASSERT
(
!
IsLazilyCascadedPseudoElement
(
)
"
lazy
pseudos
can
'
t
inherit
lazy
pseudos
"
)
;
MOZ_ASSERT
(
aStyle
-
>
IsLazilyCascadedPseudoElement
(
)
)
;
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
aStyle
-
>
GetPseudoType
(
)
)
)
{
return
;
}
mNextLazyPseudoStyle
.
swap
(
aStyle
-
>
mNextLazyPseudoStyle
)
;
mNextLazyPseudoStyle
=
aStyle
;
}
inline
void
ResolveSameStructsAs
(
const
ServoStyleContext
*
aOther
)
;
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aCVsSize
)
const
{
*
aCVsSize
+
=
ServoComputedValuesMallocEnclosingSizeOf
(
this
)
;
mSource
.
AddSizeOfExcludingThis
(
aSizes
)
;
mInheritingAnonBoxStyles
.
AddSizeOfIncludingThis
(
aSizes
aCVsSize
)
;
if
(
mNextLazyPseudoStyle
&
&
!
aSizes
.
mState
.
HaveSeenPtr
(
mNextLazyPseudoStyle
)
)
{
mNextLazyPseudoStyle
-
>
AddSizeOfIncludingThis
(
aSizes
aCVsSize
)
;
}
}
private
:
nsPresContext
*
mPresContext
;
ServoComputedData
mSource
;
CachedAnonBoxStyles
mInheritingAnonBoxStyles
;
RefPtr
<
ServoStyleContext
>
mNextLazyPseudoStyle
;
}
;
}
#
endif
