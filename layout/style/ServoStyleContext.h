#
ifndef
mozilla_ServoStyleContext_h
#
define
mozilla_ServoStyleContext_h
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
namespace
dom
{
class
Element
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
ServoComputedValuesMallocSizeOf
)
class
ServoStyleContext
final
:
public
nsStyleContext
{
public
:
ServoStyleContext
(
nsPresContext
*
aPresContext
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
ServoComputedDataForgotten
aComputedValues
)
;
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
const
ServoComputedData
*
ComputedData
(
)
const
{
return
&
mSource
;
}
void
AddRef
(
)
{
Servo_StyleContext_AddRef
(
this
)
;
}
void
Release
(
)
{
Servo_StyleContext_Release
(
this
)
;
}
ServoStyleContext
*
GetStyleIfVisited
(
)
const
{
return
ComputedData
(
)
-
>
visited_style
.
mPtr
;
}
bool
IsLazilyCascadedPseudoElement
(
)
const
{
return
IsPseudoElement
(
)
&
&
!
nsCSSPseudoElements
:
:
IsEagerlyCascadedInServo
(
GetPseudoType
(
)
)
;
}
ServoStyleContext
*
GetCachedInheritingAnonBoxStyle
(
nsIAtom
*
aAnonBox
)
const
;
void
SetCachedInheritedAnonBoxStyle
(
nsIAtom
*
aAnonBox
ServoStyleContext
*
aStyle
)
{
MOZ_ASSERT
(
!
GetCachedInheritingAnonBoxStyle
(
aAnonBox
)
)
;
MOZ_ASSERT
(
!
aStyle
-
>
mNextInheritingAnonBoxStyle
)
;
if
(
IsInheritingAnonBox
(
)
)
{
return
;
}
mNextInheritingAnonBoxStyle
.
swap
(
aStyle
-
>
mNextInheritingAnonBoxStyle
)
;
mNextInheritingAnonBoxStyle
=
aStyle
;
}
ServoStyleContext
*
GetCachedLazyPseudoStyle
(
CSSPseudoElementType
aPseudo
)
const
;
void
SetCachedLazyPseudoStyle
(
ServoStyleContext
*
aStyle
)
{
MOZ_ASSERT
(
aStyle
-
>
GetPseudo
(
)
&
&
!
aStyle
-
>
IsAnonBox
(
)
)
;
MOZ_ASSERT
(
!
GetCachedLazyPseudoStyle
(
aStyle
-
>
GetPseudoType
(
)
)
)
;
MOZ_ASSERT
(
!
aStyle
-
>
mNextLazyPseudoStyle
)
;
MOZ_ASSERT
(
!
IsLazilyCascadedPseudoElement
(
)
"
lazy
pseudos
can
'
t
inherit
lazy
pseudos
"
)
;
MOZ_ASSERT
(
aStyle
-
>
IsLazilyCascadedPseudoElement
(
)
)
;
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
aStyle
-
>
GetPseudoType
(
)
)
)
{
return
;
}
mNextLazyPseudoStyle
.
swap
(
aStyle
-
>
mNextLazyPseudoStyle
)
;
mNextLazyPseudoStyle
=
aStyle
;
}
inline
void
ResolveSameStructsAs
(
const
ServoStyleContext
*
aOther
)
;
void
AddSizeOfIncludingThis
(
SizeOfState
&
aState
nsStyleSizes
&
aSizes
bool
aIsDOM
)
const
{
static_assert
(
alignof
(
ServoStyleContext
)
=
=
4
|
|
alignof
(
ServoStyleContext
)
=
=
8
"
alignment
will
break
AddSizeOfExcludingThis
(
)
"
)
;
const
char
*
p
=
reinterpret_cast
<
const
char
*
>
(
this
)
;
p
-
=
std
:
:
max
(
sizeof
(
size_t
)
alignof
(
ServoStyleContext
)
)
;
if
(
aIsDOM
)
{
aSizes
.
mComputedValuesDom
+
=
ServoComputedValuesMallocSizeOf
(
p
)
;
}
else
{
aSizes
.
mComputedValuesNonDom
+
=
ServoComputedValuesMallocSizeOf
(
p
)
;
}
mSource
.
AddSizeOfExcludingThis
(
aState
aSizes
)
;
}
private
:
nsPresContext
*
mPresContext
;
ServoComputedData
mSource
;
RefPtr
<
ServoStyleContext
>
mNextInheritingAnonBoxStyle
;
RefPtr
<
ServoStyleContext
>
mNextLazyPseudoStyle
;
}
;
}
#
endif
