#
ifndef
nsRuleProcessorData_h_
#
define
nsRuleProcessorData_h_
#
ifdef
MOZ_OLD_STYLE
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsRuleWalker
.
h
"
#
include
"
nsNthIndexCache
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
AtomArray
.
h
"
#
include
"
mozilla
/
BloomFilter
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
class
nsAtom
;
class
nsIContent
;
class
nsICSSPseudoComparator
;
struct
TreeMatchContext
;
class
MOZ_STACK_CLASS
AncestorFilter
{
friend
struct
TreeMatchContext
;
public
:
void
PushAncestor
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
void
PopAncestor
(
)
;
template
<
size_t
hashListLength
>
bool
MightHaveMatchingAncestor
(
const
uint32_t
*
aHashes
)
const
{
MOZ_ASSERT
(
mFilter
)
;
for
(
size_t
i
=
0
;
i
<
hashListLength
&
&
aHashes
[
i
]
;
+
+
i
)
{
if
(
!
mFilter
-
>
mightContain
(
aHashes
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
bool
HasFilter
(
)
const
{
return
mFilter
;
}
#
ifdef
DEBUG
void
AssertHasAllAncestors
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
const
;
#
endif
private
:
typedef
mozilla
:
:
BloomFilter
<
12
nsAtom
>
Filter
;
nsAutoPtr
<
Filter
>
mFilter
;
AutoTArray
<
uint32_t
16
>
mPopTargets
;
AutoTArray
<
uint32_t
50
>
mHashes
;
#
ifdef
DEBUG
nsTArray
<
mozilla
:
:
dom
:
:
Element
*
>
mElements
;
#
endif
}
;
struct
MOZ_STACK_CLASS
TreeMatchContext
{
void
ResetForVisitedMatching
(
)
{
NS_PRECONDITION
(
mForStyling
"
Why
is
this
being
called
?
"
)
;
mHaveRelevantLink
=
false
;
mVisitedHandling
=
nsRuleWalker
:
:
eRelevantLinkVisited
;
}
void
ResetForUnvisitedMatching
(
)
{
NS_PRECONDITION
(
mForStyling
"
Why
is
this
being
called
?
"
)
;
mHaveRelevantLink
=
false
;
mVisitedHandling
=
nsRuleWalker
:
:
eRelevantLinkUnvisited
;
}
void
SetHaveRelevantLink
(
)
{
mHaveRelevantLink
=
true
;
}
bool
HaveRelevantLink
(
)
const
{
return
mHaveRelevantLink
;
}
nsRuleWalker
:
:
VisitedHandlingType
VisitedHandling
(
)
const
{
return
mVisitedHandling
;
}
void
AddScopeElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
{
NS_PRECONDITION
(
mHaveSpecifiedScope
"
Should
be
set
before
calling
AddScopeElement
(
)
"
)
;
mScopes
.
AppendElement
(
aElement
)
;
}
bool
IsScopeElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
const
{
return
mScopes
.
Contains
(
aElement
)
;
}
void
SetHasSpecifiedScope
(
)
{
mHaveSpecifiedScope
=
true
;
}
bool
HasSpecifiedScope
(
)
const
{
return
mHaveSpecifiedScope
;
}
void
InitAncestors
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
class
MOZ_RAII
AutoAncestorPusher
{
public
:
explicit
AutoAncestorPusher
(
TreeMatchContext
*
aTreeMatchContext
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mPushedAncestor
(
false
)
mTreeMatchContext
(
aTreeMatchContext
)
mElement
(
nullptr
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
void
PushAncestor
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
{
if
(
!
mTreeMatchContext
)
{
MOZ_ASSERT
(
!
aElement
|
|
aElement
-
>
IsStyledByServo
(
)
)
;
return
;
}
MOZ_ASSERT
(
!
mElement
)
;
if
(
aElement
)
{
mElement
=
aElement
;
mPushedAncestor
=
true
;
mTreeMatchContext
-
>
mAncestorFilter
.
PushAncestor
(
aElement
)
;
}
}
void
PushAncestor
(
nsIContent
*
aContent
)
{
if
(
!
mTreeMatchContext
)
{
MOZ_ASSERT
(
!
aContent
|
|
aContent
-
>
IsStyledByServo
(
)
)
;
return
;
}
if
(
aContent
&
&
aContent
-
>
IsElement
(
)
)
{
PushAncestor
(
aContent
-
>
AsElement
(
)
)
;
}
}
~
AutoAncestorPusher
(
)
{
if
(
mPushedAncestor
)
{
mTreeMatchContext
-
>
mAncestorFilter
.
PopAncestor
(
)
;
}
}
private
:
bool
mPushedAncestor
;
TreeMatchContext
*
mTreeMatchContext
;
mozilla
:
:
dom
:
:
Element
*
mElement
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoParentDisplayBasedStyleFixupSkipper
{
public
:
explicit
AutoParentDisplayBasedStyleFixupSkipper
(
TreeMatchContext
&
aTreeMatchContext
bool
aSkipParentDisplayBasedStyleFixup
=
true
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mAutoRestorer
(
aTreeMatchContext
.
mSkippingParentDisplayBasedStyleFixup
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
aSkipParentDisplayBasedStyleFixup
)
{
aTreeMatchContext
.
mSkippingParentDisplayBasedStyleFixup
=
true
;
}
}
private
:
mozilla
:
:
AutoRestore
<
bool
>
mAutoRestorer
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
const
bool
mForStyling
;
private
:
bool
mHaveRelevantLink
;
bool
mHaveSpecifiedScope
;
nsRuleWalker
:
:
VisitedHandlingType
mVisitedHandling
;
AutoTArray
<
mozilla
:
:
dom
:
:
Element
*
1
>
mScopes
;
public
:
nsIDocument
*
const
mDocument
;
const
bool
mIsHTMLDocument
;
const
nsCompatibility
mCompatMode
;
nsNthIndexCache
mNthIndexCache
;
AncestorFilter
mAncestorFilter
;
bool
mUsingPrivateBrowsing
;
bool
mSkippingParentDisplayBasedStyleFixup
;
enum
MatchVisited
{
eNeverMatchVisited
eMatchVisitedDefault
}
;
AutoTArray
<
mozilla
:
:
dom
:
:
Element
*
1
>
mStyleScopes
;
TreeMatchContext
(
bool
aForStyling
nsRuleWalker
:
:
VisitedHandlingType
aVisitedHandling
nsIDocument
*
aDocument
MatchVisited
aMatchVisited
=
eMatchVisitedDefault
)
:
mForStyling
(
aForStyling
)
mHaveRelevantLink
(
false
)
mHaveSpecifiedScope
(
false
)
mVisitedHandling
(
aVisitedHandling
)
mDocument
(
aDocument
)
mIsHTMLDocument
(
aDocument
-
>
IsHTMLDocument
(
)
)
mCompatMode
(
aDocument
-
>
GetCompatibilityMode
(
)
)
mUsingPrivateBrowsing
(
false
)
mSkippingParentDisplayBasedStyleFixup
(
false
)
{
if
(
aMatchVisited
!
=
eNeverMatchVisited
)
{
nsILoadContext
*
loadContext
=
mDocument
-
>
GetLoadContext
(
)
;
if
(
loadContext
)
{
mUsingPrivateBrowsing
=
loadContext
-
>
UsePrivateBrowsing
(
)
;
}
}
else
{
MOZ_ASSERT
(
aVisitedHandling
=
=
nsRuleWalker
:
:
eRelevantLinkUnvisited
"
You
promised
you
'
d
never
try
to
match
:
visited
!
"
)
;
}
}
enum
ForFrameConstructionTag
{
ForFrameConstruction
}
;
TreeMatchContext
(
nsIDocument
*
aDocument
ForFrameConstructionTag
)
:
TreeMatchContext
(
true
nsRuleWalker
:
:
eRelevantLinkUnvisited
aDocument
)
{
}
}
;
struct
MOZ_STACK_CLASS
RuleProcessorData
{
RuleProcessorData
(
nsPresContext
*
aPresContext
nsRuleWalker
*
aRuleWalker
)
:
mPresContext
(
aPresContext
)
mRuleWalker
(
aRuleWalker
)
mScope
(
nullptr
)
{
NS_PRECONDITION
(
mPresContext
"
Must
have
prescontext
"
)
;
}
nsPresContext
*
const
mPresContext
;
nsRuleWalker
*
const
mRuleWalker
;
mozilla
:
:
dom
:
:
Element
*
mScope
;
}
;
struct
MOZ_STACK_CLASS
ElementDependentRuleProcessorData
:
public
RuleProcessorData
{
ElementDependentRuleProcessorData
(
nsPresContext
*
aPresContext
mozilla
:
:
dom
:
:
Element
*
aElement
nsRuleWalker
*
aRuleWalker
TreeMatchContext
&
aTreeMatchContext
)
:
RuleProcessorData
(
aPresContext
aRuleWalker
)
mElement
(
aElement
)
mTreeMatchContext
(
aTreeMatchContext
)
{
NS_ASSERTION
(
aElement
"
null
element
leaked
into
SelectorMatches
"
)
;
NS_ASSERTION
(
aElement
-
>
OwnerDoc
(
)
"
Document
-
less
node
here
?
"
)
;
NS_PRECONDITION
(
aTreeMatchContext
.
mForStyling
=
=
!
!
aRuleWalker
"
Should
be
styling
if
and
only
if
we
have
a
rule
walker
"
)
;
}
mozilla
:
:
dom
:
:
Element
*
const
mElement
;
TreeMatchContext
&
mTreeMatchContext
;
}
;
struct
MOZ_STACK_CLASS
ElementRuleProcessorData
:
public
ElementDependentRuleProcessorData
{
ElementRuleProcessorData
(
nsPresContext
*
aPresContext
mozilla
:
:
dom
:
:
Element
*
aElement
nsRuleWalker
*
aRuleWalker
TreeMatchContext
&
aTreeMatchContext
)
:
ElementDependentRuleProcessorData
(
aPresContext
aElement
aRuleWalker
aTreeMatchContext
)
{
NS_PRECONDITION
(
aTreeMatchContext
.
mForStyling
"
Styling
here
!
"
)
;
NS_PRECONDITION
(
aRuleWalker
"
Must
have
rule
walker
"
)
;
}
}
;
struct
MOZ_STACK_CLASS
PseudoElementRuleProcessorData
:
public
ElementDependentRuleProcessorData
{
PseudoElementRuleProcessorData
(
nsPresContext
*
aPresContext
mozilla
:
:
dom
:
:
Element
*
aParentElement
nsRuleWalker
*
aRuleWalker
mozilla
:
:
CSSPseudoElementType
aPseudoType
TreeMatchContext
&
aTreeMatchContext
mozilla
:
:
dom
:
:
Element
*
aPseudoElement
)
:
ElementDependentRuleProcessorData
(
aPresContext
aParentElement
aRuleWalker
aTreeMatchContext
)
mPseudoType
(
aPseudoType
)
mPseudoElement
(
aPseudoElement
)
{
NS_PRECONDITION
(
aPseudoType
<
mozilla
:
:
CSSPseudoElementType
:
:
Count
"
invalid
aPseudoType
value
"
)
;
NS_PRECONDITION
(
aTreeMatchContext
.
mForStyling
"
Styling
here
!
"
)
;
NS_PRECONDITION
(
aRuleWalker
"
Must
have
rule
walker
"
)
;
}
mozilla
:
:
CSSPseudoElementType
mPseudoType
;
mozilla
:
:
dom
:
:
Element
*
const
mPseudoElement
;
}
;
struct
MOZ_STACK_CLASS
AnonBoxRuleProcessorData
:
public
RuleProcessorData
{
AnonBoxRuleProcessorData
(
nsPresContext
*
aPresContext
nsAtom
*
aPseudoTag
nsRuleWalker
*
aRuleWalker
)
:
RuleProcessorData
(
aPresContext
aRuleWalker
)
mPseudoTag
(
aPseudoTag
)
{
NS_PRECONDITION
(
aPseudoTag
"
Must
have
pseudo
tag
"
)
;
NS_PRECONDITION
(
aRuleWalker
"
Must
have
rule
walker
"
)
;
}
nsAtom
*
mPseudoTag
;
}
;
#
ifdef
MOZ_XUL
struct
MOZ_STACK_CLASS
XULTreeRuleProcessorData
:
public
ElementDependentRuleProcessorData
{
XULTreeRuleProcessorData
(
nsPresContext
*
aPresContext
mozilla
:
:
dom
:
:
Element
*
aParentElement
nsRuleWalker
*
aRuleWalker
nsAtom
*
aPseudoTag
const
mozilla
:
:
AtomArray
&
aInputWord
TreeMatchContext
&
aTreeMatchContext
)
:
ElementDependentRuleProcessorData
(
aPresContext
aParentElement
aRuleWalker
aTreeMatchContext
)
mPseudoTag
(
aPseudoTag
)
mInputWord
(
aInputWord
)
{
NS_PRECONDITION
(
aPseudoTag
"
null
pointer
"
)
;
NS_PRECONDITION
(
aRuleWalker
"
Must
have
rule
walker
"
)
;
NS_PRECONDITION
(
aTreeMatchContext
.
mForStyling
"
Styling
here
!
"
)
;
}
nsAtom
*
mPseudoTag
;
const
mozilla
:
:
AtomArray
&
mInputWord
;
}
;
#
endif
struct
MOZ_STACK_CLASS
StateRuleProcessorData
:
public
ElementDependentRuleProcessorData
{
StateRuleProcessorData
(
nsPresContext
*
aPresContext
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
EventStates
aStateMask
TreeMatchContext
&
aTreeMatchContext
)
:
ElementDependentRuleProcessorData
(
aPresContext
aElement
nullptr
aTreeMatchContext
)
mStateMask
(
aStateMask
)
{
NS_PRECONDITION
(
!
aTreeMatchContext
.
mForStyling
"
Not
styling
here
!
"
)
;
}
const
mozilla
:
:
EventStates
mStateMask
;
}
;
struct
MOZ_STACK_CLASS
PseudoElementStateRuleProcessorData
:
public
StateRuleProcessorData
{
PseudoElementStateRuleProcessorData
(
nsPresContext
*
aPresContext
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
EventStates
aStateMask
mozilla
:
:
CSSPseudoElementType
aPseudoType
TreeMatchContext
&
aTreeMatchContext
mozilla
:
:
dom
:
:
Element
*
aPseudoElement
)
:
StateRuleProcessorData
(
aPresContext
aElement
aStateMask
aTreeMatchContext
)
mPseudoType
(
aPseudoType
)
mPseudoElement
(
aPseudoElement
)
{
NS_PRECONDITION
(
!
aTreeMatchContext
.
mForStyling
"
Not
styling
here
!
"
)
;
}
mozilla
:
:
CSSPseudoElementType
mPseudoType
;
mozilla
:
:
dom
:
:
Element
*
const
mPseudoElement
;
}
;
struct
MOZ_STACK_CLASS
AttributeRuleProcessorData
:
public
ElementDependentRuleProcessorData
{
AttributeRuleProcessorData
(
nsPresContext
*
aPresContext
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
bool
aAttrHasChanged
const
nsAttrValue
*
aOtherValue
TreeMatchContext
&
aTreeMatchContext
)
:
ElementDependentRuleProcessorData
(
aPresContext
aElement
nullptr
aTreeMatchContext
)
mNameSpaceID
(
aNameSpaceID
)
mAttribute
(
aAttribute
)
mOtherValue
(
aOtherValue
)
mModType
(
aModType
)
mAttrHasChanged
(
aAttrHasChanged
)
{
NS_PRECONDITION
(
!
aTreeMatchContext
.
mForStyling
"
Not
styling
here
!
"
)
;
}
int32_t
mNameSpaceID
;
nsAtom
*
mAttribute
;
const
nsAttrValue
*
mOtherValue
;
int32_t
mModType
;
bool
mAttrHasChanged
;
}
;
#
else
struct
TreeMatchContext
{
public
:
class
AutoAncestorPusher
{
public
:
explicit
AutoAncestorPusher
(
TreeMatchContext
*
aTreeMatchContext
)
{
}
void
PushAncestor
(
nsIContent
*
aContent
)
{
}
}
;
class
AutoParentDisplayBasedStyleFixupSkipper
{
public
:
explicit
AutoParentDisplayBasedStyleFixupSkipper
(
TreeMatchContext
&
aTreeMatchContext
bool
aSkipParentDisplayBasedStyleFixup
=
true
)
{
}
}
;
enum
ForFrameConstructionTag
{
ForFrameConstruction
}
;
TreeMatchContext
(
nsIDocument
*
aDocument
ForFrameConstructionTag
)
{
}
void
InitAncestors
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
{
}
}
;
#
endif
#
endif
