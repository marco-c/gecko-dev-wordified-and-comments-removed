#
include
"
TimelineManager
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
ElementAnimationData
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ScrollTimeline
.
h
"
#
include
"
nsPresContext
.
h
"
namespace
mozilla
{
using
dom
:
:
Element
;
using
dom
:
:
ScrollTimeline
;
template
<
typename
TimelineType
>
void
TryDestroyTimeline
(
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
auto
*
collection
=
TimelineCollection
<
TimelineType
>
:
:
Get
(
aElement
aPseudoType
)
;
if
(
!
collection
)
{
return
;
}
collection
-
>
Destroy
(
)
;
}
void
TimelineManager
:
:
UpdateTimelines
(
Element
*
aElement
PseudoStyleType
aPseudoType
const
ComputedStyle
*
aComputedStyle
ProgressTimelineType
aType
)
{
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
"
No
need
to
update
timelines
that
are
not
attached
to
the
document
tree
"
)
;
const
bool
shouldDestroyTimelines
=
!
aComputedStyle
|
|
aComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
None
;
switch
(
aType
)
{
case
ProgressTimelineType
:
:
Scroll
:
if
(
shouldDestroyTimelines
)
{
TryDestroyTimeline
<
ScrollTimeline
>
(
aElement
aPseudoType
)
;
return
;
}
DoUpdateTimelines
<
StyleScrollTimeline
ScrollTimeline
>
(
mPresContext
aElement
aPseudoType
aComputedStyle
-
>
StyleUIReset
(
)
-
>
mScrollTimelines
aComputedStyle
-
>
StyleUIReset
(
)
-
>
mScrollTimelineNameCount
)
;
break
;
case
ProgressTimelineType
:
:
View
:
break
;
}
}
template
<
typename
TimelineType
>
static
already_AddRefed
<
TimelineType
>
PopExistingTimeline
(
const
nsAtom
*
aName
TimelineCollection
<
TimelineType
>
*
aCollection
)
{
if
(
!
aCollection
)
{
return
nullptr
;
}
return
aCollection
-
>
Extract
(
aName
)
;
}
template
<
typename
StyleType
typename
TimelineType
>
static
auto
BuildTimelines
(
nsPresContext
*
aPresContext
Element
*
aElement
PseudoStyleType
aPseudoType
const
nsStyleAutoArray
<
StyleType
>
&
aTimelines
size_t
aTimelineCount
TimelineCollection
<
TimelineType
>
*
aCollection
)
{
typename
TimelineCollection
<
TimelineType
>
:
:
TimelineMap
result
;
for
(
size_t
idx
=
0
;
idx
<
aTimelineCount
;
+
+
idx
)
{
const
StyleType
&
timeline
=
aTimelines
[
idx
]
;
if
(
timeline
.
GetName
(
)
=
=
nsGkAtoms
:
:
_empty
)
{
continue
;
}
RefPtr
<
TimelineType
>
dest
=
PopExistingTimeline
(
timeline
.
GetName
(
)
aCollection
)
;
Element
*
e
=
AnimationUtils
:
:
GetElementForRestyle
(
aElement
aPseudoType
)
;
if
(
dest
)
{
dest
-
>
ReplacePropertiesWith
(
e
timeline
)
;
}
else
{
dest
=
TimelineType
:
:
MakeNamed
(
aPresContext
-
>
Document
(
)
e
timeline
)
;
}
MOZ_ASSERT
(
dest
)
;
Unused
<
<
result
.
InsertOrUpdate
(
timeline
.
GetName
(
)
dest
)
;
}
return
result
;
}
template
<
typename
TimelineType
>
static
TimelineCollection
<
TimelineType
>
&
EnsureTimelineCollection
(
Element
&
aElement
PseudoStyleType
aPseudoType
)
;
template
<
>
ScrollTimelineCollection
&
EnsureTimelineCollection
<
ScrollTimeline
>
(
Element
&
aElement
PseudoStyleType
aPseudoType
)
{
return
aElement
.
EnsureAnimationData
(
)
.
EnsureScrollTimelineCollection
(
aElement
aPseudoType
)
;
}
template
<
typename
StyleType
typename
TimelineType
>
void
TimelineManager
:
:
DoUpdateTimelines
(
nsPresContext
*
aPresContext
Element
*
aElement
PseudoStyleType
aPseudoType
const
nsStyleAutoArray
<
StyleType
>
&
aStyleTimelines
size_t
aTimelineCount
)
{
auto
*
collection
=
TimelineCollection
<
TimelineType
>
:
:
Get
(
aElement
aPseudoType
)
;
if
(
!
collection
&
&
aTimelineCount
=
=
1
&
&
aStyleTimelines
[
0
]
.
GetName
(
)
=
=
nsGkAtoms
:
:
_empty
)
{
return
;
}
auto
newTimelines
=
BuildTimelines
<
StyleType
TimelineType
>
(
aPresContext
aElement
aPseudoType
aStyleTimelines
aTimelineCount
collection
)
;
if
(
newTimelines
.
IsEmpty
(
)
)
{
if
(
collection
)
{
collection
-
>
Destroy
(
)
;
}
return
;
}
if
(
!
collection
)
{
collection
=
&
EnsureTimelineCollection
<
TimelineType
>
(
*
aElement
aPseudoType
)
;
if
(
!
collection
-
>
isInList
(
)
)
{
AddTimelineCollection
(
collection
)
;
}
}
collection
-
>
Swap
(
newTimelines
)
;
}
}
