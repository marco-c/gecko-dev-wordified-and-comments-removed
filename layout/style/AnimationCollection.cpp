#
include
"
mozilla
/
AnimationCollection
.
h
"
#
include
<
type_traits
>
#
include
"
mozilla
/
ElementAnimationData
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
dom
/
CSSAnimation
.
h
"
#
include
"
mozilla
/
dom
/
CSSTransition
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
namespace
mozilla
{
template
<
class
AnimationType
>
AnimationCollection
<
AnimationType
>
:
:
~
AnimationCollection
(
)
{
MOZ_COUNT_DTOR
(
AnimationCollection
)
;
const
PostRestyleMode
postRestyle
=
mCalledDestroy
?
PostRestyleMode
:
:
IfNeeded
:
PostRestyleMode
:
:
Never
;
{
nsAutoAnimationMutationBatch
mb
(
mElement
.
OwnerDoc
(
)
)
;
for
(
size_t
animIdx
=
mAnimations
.
Length
(
)
;
animIdx
-
-
!
=
0
;
)
{
mAnimations
[
animIdx
]
-
>
CancelFromStyle
(
postRestyle
)
;
}
}
LinkedListElement
<
SelfType
>
:
:
remove
(
)
;
}
template
<
class
AnimationType
>
void
AnimationCollection
<
AnimationType
>
:
:
Destroy
(
)
{
mCalledDestroy
=
true
;
auto
*
data
=
mElement
.
GetAnimationData
(
)
;
MOZ_ASSERT
(
data
)
;
const
PseudoStyleRequest
request
=
mPseudo
;
if
constexpr
(
std
:
:
is_same_v
<
AnimationType
dom
:
:
CSSAnimation
>
)
{
MOZ_ASSERT
(
data
-
>
GetAnimationCollection
(
request
)
=
=
this
)
;
data
-
>
ClearAnimationCollectionFor
(
request
)
;
}
else
{
MOZ_ASSERT
(
data
-
>
GetTransitionCollection
(
request
)
=
=
this
)
;
data
-
>
ClearTransitionCollectionFor
(
request
)
;
}
}
template
<
class
AnimationType
>
AnimationCollection
<
AnimationType
>
*
AnimationCollection
<
AnimationType
>
:
:
Get
(
const
dom
:
:
Element
*
aElement
const
PseudoStyleRequest
&
aRequest
)
{
auto
*
data
=
aElement
-
>
GetAnimationData
(
)
;
if
(
!
data
)
{
return
nullptr
;
}
if
constexpr
(
std
:
:
is_same_v
<
AnimationType
dom
:
:
CSSAnimation
>
)
{
return
data
-
>
GetAnimationCollection
(
aRequest
)
;
}
else
{
return
data
-
>
GetTransitionCollection
(
aRequest
)
;
}
}
template
<
class
AnimationType
>
AnimationCollection
<
AnimationType
>
*
AnimationCollection
<
AnimationType
>
:
:
Get
(
const
nsIFrame
*
aFrame
)
{
Maybe
<
NonOwningAnimationTarget
>
target
=
EffectCompositor
:
:
GetAnimationElementAndPseudoForFrame
(
aFrame
)
;
if
(
!
target
)
{
return
nullptr
;
}
return
Get
(
target
-
>
mElement
target
-
>
mPseudoRequest
)
;
}
template
class
AnimationCollection
<
dom
:
:
CSSAnimation
>
;
template
class
AnimationCollection
<
dom
:
:
CSSTransition
>
;
}
