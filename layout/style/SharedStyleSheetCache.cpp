#
include
"
SharedStyleSheetCache
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
css
/
SheetLoadData
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsXULPrototypeCache
.
h
"
extern
mozilla
:
:
LazyLogModule
sCssLoaderLog
;
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
mozilla
{
NS_IMPL_ISUPPORTS
(
SharedStyleSheetCache
nsIMemoryReporter
)
MOZ_DEFINE_MALLOC_SIZE_OF
(
SharedStyleSheetCacheMallocSizeOf
)
SharedStyleSheetCache
:
:
SharedStyleSheetCache
(
)
=
default
;
void
SharedStyleSheetCache
:
:
Init
(
)
{
RegisterWeakMemoryReporter
(
this
)
;
}
SharedStyleSheetCache
:
:
~
SharedStyleSheetCache
(
)
{
UnregisterWeakMemoryReporter
(
this
)
;
}
void
SharedStyleSheetCache
:
:
LoadCompleted
(
SharedStyleSheetCache
*
aCache
StyleSheetLoadData
&
aData
nsresult
aStatus
)
{
nsresult
cancelledStatus
=
aStatus
;
if
(
NS_FAILED
(
aStatus
)
)
{
css
:
:
Loader
:
:
MarkLoadTreeFailed
(
aData
)
;
}
else
{
cancelledStatus
=
NS_BINDING_ABORTED
;
css
:
:
SheetLoadData
*
data
=
&
aData
;
do
{
if
(
data
-
>
mIsCancelled
)
{
css
:
:
Loader
:
:
MarkLoadTreeFailed
(
*
data
data
-
>
mLoader
)
;
}
}
while
(
(
data
=
data
-
>
mNext
)
)
;
}
AutoTArray
<
RefPtr
<
css
:
:
SheetLoadData
>
8
>
datasToNotify
;
LoadCompletedInternal
(
aCache
aData
datasToNotify
)
;
for
(
RefPtr
<
css
:
:
SheetLoadData
>
&
data
:
datasToNotify
)
{
auto
status
=
data
-
>
mIsCancelled
?
cancelledStatus
:
aStatus
;
data
-
>
mLoader
-
>
NotifyObservers
(
*
data
status
)
;
}
}
void
SharedStyleSheetCache
:
:
InsertIfNeeded
(
css
:
:
SheetLoadData
&
aData
)
{
MOZ_ASSERT
(
aData
.
mLoader
-
>
IsDocumentAssociated
(
)
"
We
only
cache
document
-
associated
sheets
"
)
;
LOG
(
"
SharedStyleSheetCache
:
:
InsertIfNeeded
"
)
;
if
(
aData
.
mLoadFailed
)
{
LOG
(
"
Load
failed
bailing
"
)
;
return
;
}
if
(
aData
.
mSheetAlreadyComplete
)
{
LOG
(
"
Sheet
came
from
the
cache
bailing
"
)
;
return
;
}
if
(
!
aData
.
mURI
)
{
LOG
(
"
Inline
or
constructable
style
sheet
bailing
"
)
;
return
;
}
LOG
(
"
Putting
style
sheet
in
shared
cache
:
%
s
"
aData
.
mURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
;
Insert
(
aData
)
;
}
void
SharedStyleSheetCache
:
:
LoadCompletedInternal
(
SharedStyleSheetCache
*
aCache
css
:
:
SheetLoadData
&
aData
nsTArray
<
RefPtr
<
css
:
:
SheetLoadData
>
>
&
aDatasToNotify
)
{
if
(
aCache
)
{
aCache
-
>
LoadCompleted
(
aData
)
;
}
auto
*
data
=
&
aData
;
do
{
MOZ_DIAGNOSTIC_ASSERT
(
!
data
-
>
mSheetCompleteCalled
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
data
-
>
mSheetCompleteCalled
=
true
;
#
endif
if
(
!
data
-
>
mSheetAlreadyComplete
)
{
MOZ_ASSERT
(
data
-
>
mSheet
-
>
IsConstructed
(
)
|
|
!
data
-
>
mSheet
-
>
HasForcedUniqueInner
(
)
"
should
not
get
a
forced
unique
inner
during
parsing
"
)
;
const
bool
needInsertIntoTree
=
[
&
]
{
if
(
!
data
-
>
mLoader
-
>
GetDocument
(
)
)
{
return
false
;
}
if
(
data
-
>
IsPreload
(
)
)
{
return
false
;
}
if
(
data
-
>
mSheet
-
>
IsConstructed
(
)
)
{
return
false
;
}
if
(
data
-
>
mIsChildSheet
)
{
return
false
;
}
if
(
data
-
>
mOwningNodeBeforeLoadEvent
!
=
data
-
>
mSheet
-
>
GetOwnerNode
(
)
)
{
return
false
;
}
return
true
;
}
(
)
;
if
(
needInsertIntoTree
)
{
data
-
>
mLoader
-
>
InsertSheetInTree
(
*
data
-
>
mSheet
)
;
}
data
-
>
mSheet
-
>
SetComplete
(
)
;
data
-
>
ScheduleLoadEventIfNeeded
(
)
;
}
else
if
(
data
-
>
mSheet
-
>
IsApplicable
(
)
)
{
if
(
dom
:
:
Document
*
doc
=
data
-
>
mLoader
-
>
GetDocument
(
)
)
{
doc
-
>
PostStyleSheetApplicableStateChangeEvent
(
*
data
-
>
mSheet
)
;
}
}
aDatasToNotify
.
AppendElement
(
data
)
;
NS_ASSERTION
(
!
data
-
>
mParentData
|
|
data
-
>
mParentData
-
>
mPendingChildren
!
=
0
"
Broken
pending
child
count
on
our
parent
"
)
;
if
(
data
-
>
mParentData
&
&
-
-
(
data
-
>
mParentData
-
>
mPendingChildren
)
=
=
0
&
&
!
data
-
>
mParentData
-
>
mIsBeingParsed
)
{
LoadCompletedInternal
(
aCache
*
data
-
>
mParentData
aDatasToNotify
)
;
}
data
=
data
-
>
mNext
;
}
while
(
data
)
;
if
(
aCache
)
{
aCache
-
>
InsertIfNeeded
(
aData
)
;
}
}
NS_IMETHODIMP
SharedStyleSheetCache
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_COLLECT_REPORT
(
"
explicit
/
layout
/
style
-
sheet
-
cache
/
document
-
shared
"
KIND_HEAP
UNITS_BYTES
SizeOfIncludingThis
(
SharedStyleSheetCacheMallocSizeOf
)
"
Memory
used
for
SharedStyleSheetCache
to
share
style
"
"
sheets
across
documents
(
not
to
be
confused
with
"
"
GlobalStyleSheetCache
)
"
)
;
return
NS_OK
;
}
void
SharedStyleSheetCache
:
:
Clear
(
nsIPrincipal
*
aForPrincipal
const
nsACString
*
aBaseDomain
)
{
using
ContentParent
=
dom
:
:
ContentParent
;
if
(
XRE_IsParentProcess
(
)
)
{
auto
forPrincipal
=
aForPrincipal
?
Some
(
RefPtr
(
aForPrincipal
)
)
:
Nothing
(
)
;
auto
baseDomain
=
aBaseDomain
?
Some
(
nsCString
(
*
aBaseDomain
)
)
:
Nothing
(
)
;
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendClearStyleSheetCache
(
forPrincipal
baseDomain
)
;
}
}
if
(
sInstance
)
{
sInstance
-
>
ClearInProcess
(
aForPrincipal
aBaseDomain
)
;
}
}
}
#
undef
LOG
