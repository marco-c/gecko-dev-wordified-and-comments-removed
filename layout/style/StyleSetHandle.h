#
ifndef
mozilla_StyleSetHandle_h
#
define
mozilla_StyleSetHandle_h
#
include
"
mozilla
/
AtomArray
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ServoTypes
.
h
"
#
include
"
mozilla
/
SheetType
.
h
"
#
include
"
mozilla
/
StyleBackendType
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsTArray
.
h
"
class
nsBindingManager
;
class
nsCSSCounterStyleRule
;
struct
nsFontFaceRuleContainer
;
class
nsAtom
;
class
nsICSSAnonBoxPseudo
;
class
nsIContent
;
class
nsIDocument
;
class
nsStyleContext
;
class
nsStyleSet
;
class
nsPresContext
;
class
gfxFontFeatureValueSet
;
struct
TreeMatchContext
;
namespace
mozilla
{
class
CSSStyleSheet
;
class
ServoStyleSet
;
namespace
dom
{
class
Element
;
class
ShadowRoot
;
}
namespace
css
{
class
Rule
;
}
#
define
SERVO_BIT
0x1
class
StyleSetHandle
{
public
:
class
Ptr
{
public
:
friend
class
:
:
mozilla
:
:
StyleSetHandle
;
bool
IsGecko
(
)
const
{
#
ifdef
MOZ_OLD_STYLE
return
!
IsServo
(
)
;
#
else
return
false
;
#
endif
}
bool
IsServo
(
)
const
{
MOZ_ASSERT
(
mValue
"
StyleSetHandle
null
pointer
dereference
"
)
;
#
ifdef
MOZ_STYLO
return
mValue
&
SERVO_BIT
;
#
else
return
false
;
#
endif
}
StyleBackendType
BackendType
(
)
const
{
return
IsGecko
(
)
?
StyleBackendType
:
:
Gecko
:
StyleBackendType
:
:
Servo
;
}
#
ifdef
MOZ_OLD_STYLE
nsStyleSet
*
AsGecko
(
)
{
MOZ_ASSERT
(
IsGecko
(
)
)
;
return
reinterpret_cast
<
nsStyleSet
*
>
(
mValue
)
;
}
#
endif
ServoStyleSet
*
AsServo
(
)
{
MOZ_ASSERT
(
IsServo
(
)
)
;
return
reinterpret_cast
<
ServoStyleSet
*
>
(
mValue
&
~
SERVO_BIT
)
;
}
#
ifdef
MOZ_OLD_STYLE
nsStyleSet
*
GetAsGecko
(
)
{
return
IsGecko
(
)
?
AsGecko
(
)
:
nullptr
;
}
#
endif
ServoStyleSet
*
GetAsServo
(
)
{
return
IsServo
(
)
?
AsServo
(
)
:
nullptr
;
}
#
ifdef
MOZ_OLD_STYLE
const
nsStyleSet
*
AsGecko
(
)
const
{
return
const_cast
<
Ptr
*
>
(
this
)
-
>
AsGecko
(
)
;
}
#
endif
const
ServoStyleSet
*
AsServo
(
)
const
{
MOZ_ASSERT
(
IsServo
(
)
)
;
return
const_cast
<
Ptr
*
>
(
this
)
-
>
AsServo
(
)
;
}
#
ifdef
MOZ_OLD_STYLE
const
nsStyleSet
*
GetAsGecko
(
)
const
{
return
IsGecko
(
)
?
AsGecko
(
)
:
nullptr
;
}
#
endif
const
ServoStyleSet
*
GetAsServo
(
)
const
{
return
IsServo
(
)
?
AsServo
(
)
:
nullptr
;
}
inline
void
Delete
(
)
;
inline
void
Init
(
nsPresContext
*
aPresContext
)
;
inline
void
BeginShutdown
(
)
;
inline
void
Shutdown
(
)
;
inline
bool
GetAuthorStyleDisabled
(
)
const
;
inline
nsresult
SetAuthorStyleDisabled
(
bool
aStyleDisabled
)
;
inline
void
BeginUpdate
(
)
;
inline
nsresult
EndUpdate
(
)
;
inline
already_AddRefed
<
nsStyleContext
>
ResolveStyleFor
(
dom
:
:
Element
*
aElement
nsStyleContext
*
aParentContext
LazyComputeBehavior
aMayCompute
)
;
inline
already_AddRefed
<
nsStyleContext
>
ResolveStyleFor
(
dom
:
:
Element
*
aElement
nsStyleContext
*
aParentContext
LazyComputeBehavior
aMayCompute
TreeMatchContext
*
aTreeMatchContext
)
;
inline
already_AddRefed
<
nsStyleContext
>
ResolveStyleForText
(
nsIContent
*
aTextNode
nsStyleContext
*
aParentContext
)
;
inline
already_AddRefed
<
nsStyleContext
>
ResolveStyleForFirstLetterContinuation
(
nsStyleContext
*
aParentContext
)
;
inline
already_AddRefed
<
nsStyleContext
>
ResolveStyleForPlaceholder
(
)
;
inline
already_AddRefed
<
nsStyleContext
>
ResolvePseudoElementStyle
(
dom
:
:
Element
*
aParentElement
mozilla
:
:
CSSPseudoElementType
aType
nsStyleContext
*
aParentContext
dom
:
:
Element
*
aPseudoElement
)
;
inline
already_AddRefed
<
nsStyleContext
>
ResolveInheritingAnonymousBoxStyle
(
nsAtom
*
aPseudoTag
nsStyleContext
*
aParentContext
)
;
inline
already_AddRefed
<
nsStyleContext
>
ResolveNonInheritingAnonymousBoxStyle
(
nsAtom
*
aPseudoTag
)
;
#
ifdef
MOZ_XUL
inline
already_AddRefed
<
nsStyleContext
>
ResolveXULTreePseudoStyle
(
dom
:
:
Element
*
aParentElement
nsICSSAnonBoxPseudo
*
aPseudoTag
nsStyleContext
*
aParentContext
const
AtomArray
&
aInputWord
)
;
#
endif
inline
nsresult
AppendStyleSheet
(
SheetType
aType
StyleSheet
*
aSheet
)
;
inline
nsresult
PrependStyleSheet
(
SheetType
aType
StyleSheet
*
aSheet
)
;
inline
nsresult
RemoveStyleSheet
(
SheetType
aType
StyleSheet
*
aSheet
)
;
inline
nsresult
ReplaceSheets
(
SheetType
aType
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aNewSheets
)
;
inline
nsresult
InsertStyleSheetBefore
(
SheetType
aType
StyleSheet
*
aNewSheet
StyleSheet
*
aReferenceSheet
)
;
inline
int32_t
SheetCount
(
SheetType
aType
)
const
;
inline
StyleSheet
*
StyleSheetAt
(
SheetType
aType
int32_t
aIndex
)
const
;
inline
void
AppendAllXBLStyleSheets
(
nsTArray
<
StyleSheet
*
>
&
aArray
)
const
;
inline
nsresult
RemoveDocStyleSheet
(
StyleSheet
*
aSheet
)
;
inline
nsresult
AddDocStyleSheet
(
StyleSheet
*
aSheet
nsIDocument
*
aDocument
)
;
inline
void
RuleRemoved
(
StyleSheet
&
css
:
:
Rule
&
)
;
inline
void
RuleAdded
(
StyleSheet
&
css
:
:
Rule
&
)
;
inline
void
RuleChanged
(
StyleSheet
&
css
:
:
Rule
*
)
;
inline
void
RecordStyleSheetChange
(
StyleSheet
*
aSheet
StyleSheet
:
:
ChangeType
)
;
inline
void
RecordShadowStyleChange
(
mozilla
:
:
dom
:
:
ShadowRoot
*
aShadowRoot
)
;
inline
bool
StyleSheetsHaveChanged
(
)
const
;
inline
void
InvalidateStyleForCSSRuleChanges
(
)
;
inline
nsRestyleHint
MediumFeaturesChanged
(
bool
aViewportChanged
)
;
inline
already_AddRefed
<
nsStyleContext
>
ProbePseudoElementStyle
(
dom
:
:
Element
*
aParentElement
mozilla
:
:
CSSPseudoElementType
aType
nsStyleContext
*
aParentContext
)
;
inline
already_AddRefed
<
nsStyleContext
>
ProbePseudoElementStyle
(
dom
:
:
Element
*
aParentElement
mozilla
:
:
CSSPseudoElementType
aType
nsStyleContext
*
aParentContext
TreeMatchContext
*
aTreeMatchContext
)
;
inline
void
RootStyleContextAdded
(
)
;
inline
void
RootStyleContextRemoved
(
)
;
inline
bool
AppendFontFaceRules
(
nsTArray
<
nsFontFaceRuleContainer
>
&
aArray
)
;
inline
nsCSSCounterStyleRule
*
CounterStyleRuleForName
(
nsAtom
*
aName
)
;
inline
already_AddRefed
<
gfxFontFeatureValueSet
>
BuildFontFeatureValueSet
(
)
;
inline
bool
EnsureUniqueInnerOnCSSSheets
(
)
;
inline
void
SetNeedsRestyleAfterEnsureUniqueInner
(
)
;
private
:
uintptr_t
mValue
;
}
;
StyleSetHandle
(
)
{
mPtr
.
mValue
=
0
;
}
StyleSetHandle
(
const
StyleSetHandle
&
aOth
)
{
mPtr
.
mValue
=
aOth
.
mPtr
.
mValue
;
}
MOZ_IMPLICIT
StyleSetHandle
(
nsStyleSet
*
aSet
)
{
*
this
=
aSet
;
}
MOZ_IMPLICIT
StyleSetHandle
(
ServoStyleSet
*
aSet
)
{
*
this
=
aSet
;
}
StyleSetHandle
&
operator
=
(
nsStyleSet
*
aStyleSet
)
{
MOZ_ASSERT
(
!
(
reinterpret_cast
<
uintptr_t
>
(
aStyleSet
)
&
SERVO_BIT
)
"
least
significant
bit
shouldn
'
t
be
set
;
we
use
it
for
state
"
)
;
mPtr
.
mValue
=
reinterpret_cast
<
uintptr_t
>
(
aStyleSet
)
;
return
*
this
;
}
StyleSetHandle
&
operator
=
(
ServoStyleSet
*
aStyleSet
)
{
#
ifdef
MOZ_STYLO
MOZ_ASSERT
(
!
(
reinterpret_cast
<
uintptr_t
>
(
aStyleSet
)
&
SERVO_BIT
)
"
least
significant
bit
shouldn
'
t
be
set
;
we
use
it
for
state
"
)
;
mPtr
.
mValue
=
aStyleSet
?
(
reinterpret_cast
<
uintptr_t
>
(
aStyleSet
)
|
SERVO_BIT
)
:
0
;
return
*
this
;
#
else
MOZ_CRASH
(
"
should
not
have
a
ServoStyleSet
object
when
MOZ_STYLO
is
"
"
disabled
"
)
;
#
endif
}
explicit
operator
bool
(
)
const
{
return
!
!
mPtr
.
mValue
;
}
bool
operator
!
(
)
const
{
return
!
mPtr
.
mValue
;
}
bool
operator
=
=
(
const
StyleSetHandle
&
aOth
)
const
{
return
mPtr
.
mValue
=
=
aOth
.
mPtr
.
mValue
;
}
bool
operator
!
=
(
const
StyleSetHandle
&
aOth
)
const
{
return
!
(
*
this
=
=
aOth
)
;
}
Ptr
*
operator
-
>
(
)
{
return
&
mPtr
;
}
const
Ptr
*
operator
-
>
(
)
const
{
return
&
mPtr
;
}
private
:
Ptr
mPtr
;
}
;
#
undef
SERVO_BIT
}
#
endif
