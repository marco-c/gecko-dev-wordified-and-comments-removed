#
ifndef
mozilla_ServoStyleConstsInlines_h
#
define
mozilla_ServoStyleConstsInlines_h
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
<
type_traits
>
#
include
<
new
>
namespace
mozilla
{
template
<
typename
T
>
inline
StyleOwnedSlice
<
T
>
:
:
StyleOwnedSlice
(
const
StyleOwnedSlice
&
aOther
)
{
len
=
aOther
.
len
;
if
(
!
len
)
{
ptr
=
(
T
*
)
alignof
(
T
)
;
}
else
{
ptr
=
(
T
*
)
malloc
(
len
*
sizeof
(
T
)
)
;
size_t
i
=
0
;
for
(
const
T
&
elem
:
aOther
.
AsSpan
(
)
)
{
new
(
ptr
+
i
+
+
)
T
(
elem
)
;
}
}
}
template
<
typename
T
>
inline
StyleOwnedSlice
<
T
>
:
:
~
StyleOwnedSlice
(
)
{
if
(
!
len
)
{
return
;
}
for
(
size_t
i
:
IntegerRange
(
len
)
)
{
ptr
[
i
]
.
~
T
(
)
;
}
free
(
ptr
)
;
ptr
=
(
T
*
)
alignof
(
T
)
;
len
=
0
;
}
static
constexpr
const
size_t
kStaticRefcount
=
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
;
static
constexpr
const
size_t
kMaxRefcount
=
std
:
:
numeric_limits
<
intptr_t
>
:
:
max
(
)
;
static
constexpr
const
uint64_t
kArcSliceCanary
=
0xf3f3f3f3f3f3f3f3
;
#
define
ASSERT_CANARY
\
MOZ_DIAGNOSTIC_ASSERT
(
_0
.
ptr
-
>
data
.
header
.
header
=
=
kArcSliceCanary
"
Uh
?
"
)
;
template
<
typename
T
>
inline
StyleArcSlice
<
T
>
:
:
StyleArcSlice
(
)
{
_0
.
ptr
=
reinterpret_cast
<
decltype
(
_0
.
ptr
)
>
(
Servo_StyleArcSlice_EmptyPtr
(
)
)
;
}
template
<
typename
T
>
inline
StyleArcSlice
<
T
>
:
:
StyleArcSlice
(
const
StyleArcSlice
&
aOther
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aOther
.
_0
.
ptr
)
;
_0
.
ptr
=
aOther
.
_0
.
ptr
;
if
(
_0
.
ptr
-
>
count
.
load
(
std
:
:
memory_order_relaxed
)
!
=
kStaticRefcount
)
{
auto
old_size
=
_0
.
ptr
-
>
count
.
fetch_add
(
1
std
:
:
memory_order_relaxed
)
;
if
(
MOZ_UNLIKELY
(
old_size
>
kMaxRefcount
)
)
{
:
:
abort
(
)
;
}
}
ASSERT_CANARY
}
template
<
typename
T
>
inline
StyleArcSlice
<
T
>
:
:
StyleArcSlice
(
const
StyleForgottenArcSlicePtr
<
T
>
&
aPtr
)
{
_0
.
ptr
=
reinterpret_cast
<
decltype
(
_0
.
ptr
)
>
(
aPtr
.
_0
)
;
ASSERT_CANARY
}
template
<
typename
T
>
inline
size_t
StyleArcSlice
<
T
>
:
:
Length
(
)
const
{
ASSERT_CANARY
return
_0
.
ptr
-
>
data
.
header
.
length
;
}
template
<
typename
T
>
inline
bool
StyleArcSlice
<
T
>
:
:
IsEmpty
(
)
const
{
ASSERT_CANARY
return
Length
(
)
=
=
0
;
}
template
<
typename
T
>
inline
Span
<
const
T
>
StyleArcSlice
<
T
>
:
:
AsSpan
(
)
const
{
ASSERT_CANARY
return
MakeSpan
(
_0
.
ptr
-
>
data
.
slice
Length
(
)
)
;
}
template
<
typename
T
>
inline
bool
StyleArcSlice
<
T
>
:
:
operator
=
=
(
const
StyleArcSlice
&
aOther
)
const
{
ASSERT_CANARY
return
AsSpan
(
)
=
=
aOther
.
AsSpan
(
)
;
}
template
<
typename
T
>
inline
bool
StyleArcSlice
<
T
>
:
:
operator
!
=
(
const
StyleArcSlice
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
template
<
typename
T
>
inline
StyleArcSlice
<
T
>
:
:
~
StyleArcSlice
(
)
{
ASSERT_CANARY
if
(
_0
.
ptr
-
>
count
.
load
(
std
:
:
memory_order_relaxed
)
=
=
kStaticRefcount
)
{
return
;
}
if
(
_0
.
ptr
-
>
count
.
fetch_sub
(
1
std
:
:
memory_order_release
)
!
=
1
)
{
return
;
}
_0
.
ptr
-
>
count
.
load
(
std
:
:
memory_order_acquire
)
;
for
(
T
&
elem
:
MakeSpan
(
_0
.
ptr
-
>
data
.
slice
Length
(
)
)
)
{
elem
.
~
T
(
)
;
}
free
(
_0
.
ptr
)
;
}
#
undef
ASSERT_CANARY
inline
bool
StyleAtom
:
:
IsStatic
(
)
const
{
return
!
!
(
_0
&
1
)
;
}
inline
StyleAtom
:
:
~
StyleAtom
(
)
{
if
(
!
IsStatic
(
)
)
{
reinterpret_cast
<
nsAtom
*
>
(
_0
)
-
>
Release
(
)
;
}
}
inline
StyleAtom
:
:
StyleAtom
(
const
StyleAtom
&
aOther
)
:
_0
(
aOther
.
_0
)
{
if
(
!
IsStatic
(
)
)
{
reinterpret_cast
<
nsAtom
*
>
(
_0
)
-
>
AddRef
(
)
;
}
}
inline
nsDependentCSubstring
StyleOwnedStr
:
:
AsString
(
)
const
{
Span
<
const
uint8_t
>
s
=
_0
.
AsSpan
(
)
;
return
nsDependentCSubstring
(
reinterpret_cast
<
const
char
*
>
(
s
.
Elements
(
)
)
s
.
Length
(
)
)
;
}
}
#
endif
