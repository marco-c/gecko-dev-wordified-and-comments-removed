#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsStaticAtom
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsDOMString
.
h
"
using
namespace
mozilla
;
namespace
mozilla
{
namespace
detail
{
MOZ_PUSH_DISABLE_INTEGRAL_CONSTANT_OVERFLOW_WARNING
extern
constexpr
CSSPseudoElementAtoms
gCSSPseudoElementAtoms
=
{
#
define
CSS_PSEUDO_ELEMENT
(
name_
value_
flags_
)
\
NS_STATIC_ATOM_INIT_STRING
(
value_
)
#
include
"
nsCSSPseudoElementList
.
h
"
#
undef
CSS_PSEUDO_ELEMENT
#
define
CSS_PSEUDO_ELEMENT
(
name_
value_
flags_
)
\
NS_STATIC_ATOM_INIT_ATOM
(
CSSPseudoElementAtoms
name_
value_
)
#
include
"
nsCSSPseudoElementList
.
h
"
#
undef
CSS_PSEUDO_ELEMENT
}
;
MOZ_POP_DISABLE_INTEGRAL_CONSTANT_OVERFLOW_WARNING
}
}
#
define
CSS_PSEUDO_ELEMENT
(
name_
value_
flags_
)
\
NS_STATIC_ATOM_SUBCLASS_DEFN_PTR
(
\
nsICSSPseudoElement
nsCSSPseudoElements
name_
)
#
include
"
nsCSSPseudoElementList
.
h
"
#
undef
CSS_PSEUDO_ELEMENT
static
const
nsStaticAtomSetup
sCSSPseudoElementAtomSetup
[
]
=
{
#
define
CSS_PSEUDO_ELEMENT
(
name_
value_
flags_
)
\
NS_STATIC_ATOM_SUBCLASS_SETUP
(
\
detail
:
:
gCSSPseudoElementAtoms
nsCSSPseudoElements
name_
)
#
include
"
nsCSSPseudoElementList
.
h
"
#
undef
CSS_PSEUDO_ELEMENT
}
;
const
uint32_t
nsCSSPseudoElements
:
:
kPseudoElementFlags
[
]
=
{
#
define
CSS_PSEUDO_ELEMENT
(
name_
value_
flags_
)
\
flags_
#
include
"
nsCSSPseudoElementList
.
h
"
#
undef
CSS_PSEUDO_ELEMENT
}
;
void
nsCSSPseudoElements
:
:
RegisterStaticAtoms
(
)
{
NS_RegisterStaticAtoms
(
sCSSPseudoElementAtomSetup
)
;
}
bool
nsCSSPseudoElements
:
:
IsPseudoElement
(
nsAtom
*
aAtom
)
{
return
nsStaticAtomUtils
:
:
IsMember
(
aAtom
sCSSPseudoElementAtomSetup
)
;
}
bool
nsCSSPseudoElements
:
:
IsCSS2PseudoElement
(
nsAtom
*
aAtom
)
{
NS_ASSERTION
(
nsCSSPseudoElements
:
:
IsPseudoElement
(
aAtom
)
|
|
nsCSSAnonBoxes
:
:
IsAnonBox
(
aAtom
)
"
must
be
pseudo
element
or
anon
box
"
)
;
bool
result
=
aAtom
=
=
nsCSSPseudoElements
:
:
after
|
|
aAtom
=
=
nsCSSPseudoElements
:
:
before
|
|
aAtom
=
=
nsCSSPseudoElements
:
:
firstLetter
|
|
aAtom
=
=
nsCSSPseudoElements
:
:
firstLine
;
NS_ASSERTION
(
nsCSSAnonBoxes
:
:
IsAnonBox
(
aAtom
)
|
|
result
=
=
PseudoElementHasFlags
(
GetPseudoType
(
aAtom
EnabledState
:
:
eIgnoreEnabledState
)
CSS_PSEUDO_ELEMENT_IS_CSS2
)
"
result
doesn
'
t
match
flags
"
)
;
return
result
;
}
CSSPseudoElementType
nsCSSPseudoElements
:
:
GetPseudoType
(
nsAtom
*
aAtom
EnabledState
aEnabledState
)
{
Maybe
<
uint32_t
>
index
=
nsStaticAtomUtils
:
:
Lookup
(
aAtom
sCSSPseudoElementAtomSetup
)
;
if
(
index
.
isSome
(
)
)
{
auto
type
=
static_cast
<
Type
>
(
*
index
)
;
if
(
type
=
=
CSSPseudoElementType
:
:
mozPlaceholder
)
{
type
=
CSSPseudoElementType
:
:
placeholder
;
}
return
IsEnabled
(
type
aEnabledState
)
?
type
:
Type
:
:
NotPseudo
;
}
if
(
nsCSSAnonBoxes
:
:
IsAnonBox
(
aAtom
)
)
{
#
ifdef
MOZ_XUL
if
(
nsCSSAnonBoxes
:
:
IsTreePseudoElement
(
aAtom
)
)
{
return
Type
:
:
XULTree
;
}
#
endif
if
(
nsCSSAnonBoxes
:
:
IsNonInheritingAnonBox
(
aAtom
)
)
{
return
Type
:
:
NonInheritingAnonBox
;
}
return
Type
:
:
InheritingAnonBox
;
}
return
Type
:
:
NotPseudo
;
}
nsAtom
*
nsCSSPseudoElements
:
:
GetPseudoAtom
(
Type
aType
)
{
NS_ASSERTION
(
aType
<
Type
:
:
Count
"
Unexpected
type
"
)
;
return
*
sCSSPseudoElementAtomSetup
[
static_cast
<
CSSPseudoElementTypeBase
>
(
aType
)
]
.
mAtomp
;
}
already_AddRefed
<
nsAtom
>
nsCSSPseudoElements
:
:
GetPseudoAtom
(
const
nsAString
&
aPseudoElement
)
{
if
(
DOMStringIsNull
(
aPseudoElement
)
|
|
aPseudoElement
.
IsEmpty
(
)
|
|
aPseudoElement
.
First
(
)
!
=
char16_t
(
'
:
'
)
)
{
return
nullptr
;
}
nsAString
:
:
const_iterator
start
end
;
aPseudoElement
.
BeginReading
(
start
)
;
aPseudoElement
.
EndReading
(
end
)
;
NS_ASSERTION
(
start
!
=
end
"
aPseudoElement
is
not
empty
!
"
)
;
+
+
start
;
bool
haveTwoColons
=
true
;
if
(
start
=
=
end
|
|
*
start
!
=
char16_t
(
'
:
'
)
)
{
-
-
start
;
haveTwoColons
=
false
;
}
RefPtr
<
nsAtom
>
pseudo
=
NS_Atomize
(
Substring
(
start
end
)
)
;
MOZ_ASSERT
(
pseudo
)
;
if
(
!
haveTwoColons
&
&
(
!
IsPseudoElement
(
pseudo
)
|
|
!
IsCSS2PseudoElement
(
pseudo
)
)
)
{
return
nullptr
;
}
return
pseudo
.
forget
(
)
;
}
bool
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
const
Type
aType
)
{
return
PseudoElementHasFlags
(
aType
CSS_PSEUDO_ELEMENT_SUPPORTS_USER_ACTION_STATE
)
;
}
nsString
nsCSSPseudoElements
:
:
PseudoTypeAsString
(
Type
aPseudoType
)
{
switch
(
aPseudoType
)
{
case
CSSPseudoElementType
:
:
before
:
return
NS_LITERAL_STRING
(
"
:
:
before
"
)
;
case
CSSPseudoElementType
:
:
after
:
return
NS_LITERAL_STRING
(
"
:
:
after
"
)
;
default
:
MOZ_ASSERT
(
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
"
Unexpected
pseudo
type
"
)
;
return
EmptyString
(
)
;
}
}
