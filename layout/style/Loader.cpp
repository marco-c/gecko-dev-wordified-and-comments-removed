#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
SRILogHelper
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PreloadHashKey
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
URLPreloader
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsSyncLoadService
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsICSSLoaderObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
dom
/
MediaList
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
URL
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
ConsoleReportCollector
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
css
/
StreamLoader
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULPrototypeCache
.
h
"
#
endif
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
dom
/
SRICheck
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
using
namespace
mozilla
:
:
dom
;
#
define
SNIFFING_BUFFER_SIZE
1024
static
mozilla
:
:
LazyLogModule
sCssLoaderLog
(
"
nsCSSLoader
"
)
;
static
mozilla
:
:
LazyLogModule
gSriPRLog
(
"
SRI
"
)
;
#
define
LOG_ERROR
(
args
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Error
args
)
#
define
LOG_WARN
(
args
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Warning
args
)
#
define
LOG_DEBUG
(
args
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG
(
args
)
LOG_DEBUG
(
args
)
#
define
LOG_ERROR_ENABLED
(
)
\
MOZ_LOG_TEST
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Error
)
#
define
LOG_WARN_ENABLED
(
)
\
MOZ_LOG_TEST
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Warning
)
#
define
LOG_DEBUG_ENABLED
(
)
\
MOZ_LOG_TEST
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
)
#
define
LOG_ENABLED
(
)
LOG_DEBUG_ENABLED
(
)
#
define
LOG_URI
(
format
uri
)
\
PR_BEGIN_MACRO
\
NS_ASSERTION
(
uri
"
Logging
null
uri
"
)
;
\
if
(
LOG_ENABLED
(
)
)
{
\
LOG
(
(
format
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
\
}
\
PR_END_MACRO
static
const
char
*
const
gStateStrings
[
]
=
{
"
Unknown
"
"
NeedsParser
"
"
Pending
"
"
Loading
"
"
Complete
"
}
;
namespace
mozilla
{
class
SheetLoadDataHashKey
:
public
nsURIHashKey
{
using
IsPreload
=
css
:
:
Loader
:
:
IsPreload
;
public
:
typedef
SheetLoadDataHashKey
*
KeyType
;
typedef
const
SheetLoadDataHashKey
*
KeyTypePointer
;
explicit
SheetLoadDataHashKey
(
const
SheetLoadDataHashKey
*
aKey
)
:
nsURIHashKey
(
aKey
-
>
mKey
)
mPrincipal
(
aKey
-
>
mPrincipal
)
mReferrerInfo
(
aKey
-
>
mReferrerInfo
)
mCORSMode
(
aKey
-
>
mCORSMode
)
mParsingMode
(
aKey
-
>
mParsingMode
)
mSRIMetadata
(
aKey
-
>
mSRIMetadata
)
mIsLinkPreload
(
aKey
-
>
mIsLinkPreload
)
{
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
}
SheetLoadDataHashKey
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIReferrerInfo
*
aReferrerInfo
CORSMode
aCORSMode
css
:
:
SheetParsingMode
aParsingMode
const
SRIMetadata
&
aSRIMetadata
IsPreload
aIsPreload
)
:
nsURIHashKey
(
aURI
)
mPrincipal
(
aPrincipal
)
mReferrerInfo
(
aReferrerInfo
)
mCORSMode
(
aCORSMode
)
mParsingMode
(
aParsingMode
)
mSRIMetadata
(
aSRIMetadata
)
mIsLinkPreload
(
aIsPreload
=
=
IsPreload
:
:
FromLink
)
{
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
}
SheetLoadDataHashKey
(
SheetLoadDataHashKey
&
&
toMove
)
:
nsURIHashKey
(
std
:
:
move
(
toMove
)
)
mPrincipal
(
std
:
:
move
(
toMove
.
mPrincipal
)
)
mReferrerInfo
(
std
:
:
move
(
toMove
.
mReferrerInfo
)
)
mCORSMode
(
std
:
:
move
(
toMove
.
mCORSMode
)
)
mParsingMode
(
std
:
:
move
(
toMove
.
mParsingMode
)
)
mSRIMetadata
(
std
:
:
move
(
toMove
.
mSRIMetadata
)
)
mIsLinkPreload
(
std
:
:
move
(
toMove
.
mIsLinkPreload
)
)
{
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
}
explicit
SheetLoadDataHashKey
(
css
:
:
SheetLoadData
&
)
;
MOZ_COUNTED_DTOR
(
SheetLoadDataHashKey
)
SheetLoadDataHashKey
*
GetKey
(
)
const
{
return
const_cast
<
SheetLoadDataHashKey
*
>
(
this
)
;
}
const
SheetLoadDataHashKey
*
GetKeyPointer
(
)
const
{
return
this
;
}
bool
KeyEquals
(
const
SheetLoadDataHashKey
*
aKey
)
const
{
if
(
!
nsURIHashKey
:
:
KeyEquals
(
aKey
-
>
mKey
)
)
{
return
false
;
}
if
(
!
mPrincipal
!
=
!
aKey
-
>
mPrincipal
)
{
return
false
;
}
if
(
mCORSMode
!
=
aKey
-
>
mCORSMode
)
{
return
false
;
}
if
(
mParsingMode
!
=
aKey
-
>
mParsingMode
)
{
return
false
;
}
bool
eq
;
if
(
NS_FAILED
(
mReferrerInfo
-
>
Equals
(
aKey
-
>
mReferrerInfo
&
eq
)
)
|
|
!
eq
)
{
return
false
;
}
if
(
mPrincipal
&
&
!
mPrincipal
-
>
Equals
(
aKey
-
>
mPrincipal
)
)
{
return
false
;
}
if
(
mIsLinkPreload
!
=
aKey
-
>
mIsLinkPreload
)
{
const
SRIMetadata
&
linkPreloadMetadata
=
mIsLinkPreload
?
mSRIMetadata
:
aKey
-
>
mSRIMetadata
;
const
SRIMetadata
&
consumerPreloadMetadata
=
mIsLinkPreload
?
aKey
-
>
mSRIMetadata
:
mSRIMetadata
;
if
(
!
consumerPreloadMetadata
.
CanTrustBeDelegatedTo
(
linkPreloadMetadata
)
)
{
return
false
;
}
}
return
true
;
}
static
const
SheetLoadDataHashKey
*
KeyToPointer
(
SheetLoadDataHashKey
*
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
const
SheetLoadDataHashKey
*
aKey
)
{
return
nsURIHashKey
:
:
HashKey
(
aKey
-
>
mKey
)
;
}
nsIURI
*
GetURI
(
)
const
{
return
nsURIHashKey
:
:
GetKey
(
)
;
}
nsIPrincipal
*
GetPrincipal
(
)
const
{
return
mPrincipal
;
}
css
:
:
SheetParsingMode
ParsingMode
(
)
const
{
return
mParsingMode
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
protected
:
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsIReferrerInfo
>
mReferrerInfo
;
CORSMode
mCORSMode
;
css
:
:
SheetParsingMode
mParsingMode
;
SRIMetadata
mSRIMetadata
;
bool
mIsLinkPreload
;
}
;
SheetLoadDataHashKey
:
:
SheetLoadDataHashKey
(
css
:
:
SheetLoadData
&
aLoadData
)
:
nsURIHashKey
(
aLoadData
.
mURI
)
mPrincipal
(
aLoadData
.
mLoaderPrincipal
)
mReferrerInfo
(
aLoadData
.
ReferrerInfo
(
)
)
mCORSMode
(
aLoadData
.
mSheet
-
>
GetCORSMode
(
)
)
mParsingMode
(
aLoadData
.
mSheet
-
>
ParsingMode
(
)
)
mIsLinkPreload
(
aLoadData
.
IsLinkPreload
(
)
)
{
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
aLoadData
.
mSheet
-
>
GetIntegrity
(
mSRIMetadata
)
;
}
}
namespace
mozilla
{
namespace
css
{
NS_IMPL_ISUPPORTS
(
SheetLoadData
nsIRunnable
nsIThreadObserver
)
SheetLoadData
:
:
SheetLoadData
(
Loader
*
aLoader
const
nsAString
&
aTitle
nsIURI
*
aURI
StyleSheet
*
aSheet
bool
aSyncLoad
nsINode
*
aOwningNode
IsAlternate
aIsAlternate
MediaMatched
aMediaMatches
IsPreload
aIsPreload
nsICSSLoaderObserver
*
aObserver
nsIPrincipal
*
aLoaderPrincipal
nsIReferrerInfo
*
aReferrerInfo
nsINode
*
aRequestingNode
)
:
mLoader
(
aLoader
)
mTitle
(
aTitle
)
mEncoding
(
nullptr
)
mURI
(
aURI
)
mLineNumber
(
1
)
mSheet
(
aSheet
)
mNext
(
nullptr
)
mPendingChildren
(
0
)
mSyncLoad
(
aSyncLoad
)
mIsNonDocumentSheet
(
false
)
mIsLoading
(
false
)
mIsBeingParsed
(
false
)
mIsCancelled
(
false
)
mMustNotify
(
false
)
mWasAlternate
(
aIsAlternate
=
=
IsAlternate
:
:
Yes
)
mMediaMatched
(
aMediaMatches
=
=
MediaMatched
:
:
Yes
)
mUseSystemPrincipal
(
false
)
mSheetAlreadyComplete
(
false
)
mIsCrossOriginNoCORS
(
false
)
mBlockResourceTiming
(
false
)
mLoadFailed
(
false
)
mIsPreload
(
aIsPreload
)
mOwningNode
(
aOwningNode
)
mObserver
(
aObserver
)
mLoaderPrincipal
(
aLoaderPrincipal
)
mReferrerInfo
(
aReferrerInfo
)
mRequestingNode
(
aRequestingNode
)
mPreloadEncoding
(
nullptr
)
{
MOZ_ASSERT
(
!
mOwningNode
|
|
dom
:
:
LinkStyle
:
:
FromNode
(
*
mOwningNode
)
"
Must
implement
LinkStyle
"
)
;
MOZ_ASSERT
(
mLoader
"
Must
have
a
loader
!
"
)
;
}
SheetLoadData
:
:
SheetLoadData
(
Loader
*
aLoader
nsIURI
*
aURI
StyleSheet
*
aSheet
SheetLoadData
*
aParentData
nsICSSLoaderObserver
*
aObserver
nsIPrincipal
*
aLoaderPrincipal
nsIReferrerInfo
*
aReferrerInfo
nsINode
*
aRequestingNode
)
:
mLoader
(
aLoader
)
mEncoding
(
nullptr
)
mURI
(
aURI
)
mLineNumber
(
1
)
mSheet
(
aSheet
)
mNext
(
nullptr
)
mParentData
(
aParentData
)
mPendingChildren
(
0
)
mSyncLoad
(
aParentData
&
&
aParentData
-
>
mSyncLoad
)
mIsNonDocumentSheet
(
aParentData
&
&
aParentData
-
>
mIsNonDocumentSheet
)
mIsLoading
(
false
)
mIsBeingParsed
(
false
)
mIsCancelled
(
false
)
mMustNotify
(
false
)
mWasAlternate
(
false
)
mMediaMatched
(
true
)
mUseSystemPrincipal
(
aParentData
&
&
aParentData
-
>
mUseSystemPrincipal
)
mSheetAlreadyComplete
(
false
)
mIsCrossOriginNoCORS
(
false
)
mBlockResourceTiming
(
false
)
mLoadFailed
(
false
)
mIsPreload
(
IsPreload
:
:
No
)
mOwningNode
(
nullptr
)
mObserver
(
aObserver
)
mLoaderPrincipal
(
aLoaderPrincipal
)
mReferrerInfo
(
aReferrerInfo
)
mRequestingNode
(
aRequestingNode
)
mPreloadEncoding
(
nullptr
)
{
MOZ_ASSERT
(
mLoader
"
Must
have
a
loader
!
"
)
;
if
(
mParentData
)
{
+
+
mParentData
-
>
mPendingChildren
;
}
MOZ_ASSERT
(
!
mUseSystemPrincipal
|
|
mSyncLoad
"
Shouldn
'
t
use
system
principal
for
async
loads
"
)
;
}
SheetLoadData
:
:
SheetLoadData
(
Loader
*
aLoader
nsIURI
*
aURI
StyleSheet
*
aSheet
bool
aSyncLoad
UseSystemPrincipal
aUseSystemPrincipal
IsPreload
aIsPreload
const
Encoding
*
aPreloadEncoding
nsICSSLoaderObserver
*
aObserver
nsIPrincipal
*
aLoaderPrincipal
nsIReferrerInfo
*
aReferrerInfo
nsINode
*
aRequestingNode
)
:
mLoader
(
aLoader
)
mEncoding
(
nullptr
)
mURI
(
aURI
)
mLineNumber
(
1
)
mSheet
(
aSheet
)
mNext
(
nullptr
)
mPendingChildren
(
0
)
mSyncLoad
(
aSyncLoad
)
mIsNonDocumentSheet
(
true
)
mIsLoading
(
false
)
mIsBeingParsed
(
false
)
mIsCancelled
(
false
)
mMustNotify
(
false
)
mWasAlternate
(
false
)
mMediaMatched
(
true
)
mUseSystemPrincipal
(
aUseSystemPrincipal
=
=
UseSystemPrincipal
:
:
Yes
)
mSheetAlreadyComplete
(
false
)
mIsCrossOriginNoCORS
(
false
)
mBlockResourceTiming
(
false
)
mLoadFailed
(
false
)
mIsPreload
(
aIsPreload
)
mOwningNode
(
nullptr
)
mObserver
(
aObserver
)
mLoaderPrincipal
(
aLoaderPrincipal
)
mReferrerInfo
(
aReferrerInfo
)
mRequestingNode
(
aRequestingNode
)
mPreloadEncoding
(
aPreloadEncoding
)
{
MOZ_ASSERT
(
mLoader
"
Must
have
a
loader
!
"
)
;
MOZ_ASSERT
(
!
mUseSystemPrincipal
|
|
mSyncLoad
"
Shouldn
'
t
use
system
principal
for
async
loads
"
)
;
}
SheetLoadData
:
:
~
SheetLoadData
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mSheetCompleteCalled
|
|
mIntentionallyDropped
"
Should
always
call
SheetComplete
except
when
"
"
dropping
the
load
"
)
;
RefPtr
<
SheetLoadData
>
next
=
std
:
:
move
(
mNext
)
;
while
(
next
)
{
next
=
std
:
:
move
(
next
-
>
mNext
)
;
}
}
NS_IMETHODIMP
SheetLoadData
:
:
Run
(
)
{
mLoader
-
>
HandleLoadEvent
(
*
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SheetLoadData
:
:
OnDispatchedEvent
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
SheetLoadData
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aMayWait
)
{
FireLoadEvent
(
aThread
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SheetLoadData
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aEventWasProcessed
)
{
FireLoadEvent
(
aThread
)
;
return
NS_OK
;
}
void
SheetLoadData
:
:
FireLoadEvent
(
nsIThreadInternal
*
aThread
)
{
RefPtr
<
SheetLoadData
>
kungFuDeathGrip
(
this
)
;
aThread
-
>
RemoveObserver
(
this
)
;
nsCOMPtr
<
nsINode
>
node
=
mOwningNode
;
MOZ_ASSERT
(
node
"
How
did
that
happen
?
?
?
"
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
node
-
>
OwnerDoc
(
)
node
mLoadFailed
?
NS_LITERAL_STRING
(
"
error
"
)
:
NS_LITERAL_STRING
(
"
load
"
)
CanBubble
:
:
eNo
Cancelable
:
:
eNo
)
;
mLoader
-
>
UnblockOnload
(
true
)
;
}
void
SheetLoadData
:
:
ScheduleLoadEventIfNeeded
(
)
{
if
(
!
mOwningNode
)
{
return
;
}
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
nsCOMPtr
<
nsIThreadInternal
>
internalThread
=
do_QueryInterface
(
thread
)
;
if
(
NS_SUCCEEDED
(
internalThread
-
>
AddObserver
(
this
)
)
)
{
mLoader
-
>
BlockOnload
(
)
;
}
}
static
RefPtr
<
StyleSheet
>
CloneSheet
(
StyleSheet
&
aSheet
)
{
return
aSheet
.
Clone
(
nullptr
nullptr
nullptr
nullptr
)
;
}
bool
LoaderReusableStyleSheets
:
:
FindReusableStyleSheet
(
nsIURI
*
aURL
RefPtr
<
StyleSheet
>
&
aResult
)
{
MOZ_ASSERT
(
aURL
)
;
for
(
size_t
i
=
mReusableSheets
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
size_t
index
=
i
-
1
;
bool
sameURI
;
MOZ_ASSERT
(
mReusableSheets
[
index
]
-
>
GetOriginalURI
(
)
)
;
nsresult
rv
=
aURL
-
>
Equals
(
mReusableSheets
[
index
]
-
>
GetOriginalURI
(
)
&
sameURI
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
sameURI
)
{
aResult
=
mReusableSheets
[
index
]
;
mReusableSheets
.
RemoveElementAt
(
index
)
;
return
true
;
}
}
return
false
;
}
struct
Loader
:
:
Sheets
{
nsRefPtrHashtable
<
SheetLoadDataHashKey
StyleSheet
>
mCompleteSheets
;
nsRefPtrHashtable
<
SheetLoadDataHashKey
SheetLoadData
>
mPendingDatas
;
nsDataHashtable
<
SheetLoadDataHashKey
SheetLoadData
*
>
mLoadingDatas
;
nsRefPtrHashtable
<
nsStringHashKey
StyleSheet
>
mInlineSheets
;
RefPtr
<
StyleSheet
>
LookupInline
(
const
nsAString
&
)
;
using
CacheResult
=
std
:
:
tuple
<
RefPtr
<
StyleSheet
>
SheetState
>
;
CacheResult
Lookup
(
SheetLoadDataHashKey
&
bool
aSyncLoad
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
)
const
;
}
;
RefPtr
<
StyleSheet
>
Loader
:
:
Sheets
:
:
LookupInline
(
const
nsAString
&
aBuffer
)
{
auto
result
=
mInlineSheets
.
Lookup
(
aBuffer
)
;
if
(
!
result
)
{
return
nullptr
;
}
if
(
result
.
Data
(
)
-
>
HasModifiedRules
(
)
)
{
result
.
Remove
(
)
;
return
nullptr
;
}
return
result
.
Data
(
)
-
>
Clone
(
nullptr
nullptr
nullptr
nullptr
)
;
}
static
void
AssertComplete
(
const
StyleSheet
&
aSheet
)
{
MOZ_ASSERT
(
aSheet
.
IsComplete
(
)
"
Sheet
thinks
it
'
s
not
complete
while
we
think
it
is
"
)
;
}
static
void
AssertIncompleteSheetMatches
(
const
SheetLoadData
&
aData
const
SheetLoadDataHashKey
&
aKey
)
{
#
ifdef
DEBUG
bool
debugEqual
;
MOZ_ASSERT
(
(
!
aKey
.
GetPrincipal
(
)
&
&
!
aData
.
mLoaderPrincipal
)
|
|
(
aKey
.
GetPrincipal
(
)
&
&
aData
.
mLoaderPrincipal
&
&
NS_SUCCEEDED
(
aKey
.
GetPrincipal
(
)
-
>
Equals
(
aData
.
mLoaderPrincipal
&
debugEqual
)
)
&
&
debugEqual
)
"
Principals
should
be
the
same
"
)
;
#
endif
MOZ_ASSERT
(
!
aData
.
mSheet
-
>
HasForcedUniqueInner
(
)
"
CSSOM
shouldn
'
t
allow
access
to
incomplete
sheets
"
)
;
}
auto
Loader
:
:
Sheets
:
:
Lookup
(
SheetLoadDataHashKey
&
aKey
bool
aSyncLoad
)
-
>
CacheResult
{
nsIURI
*
uri
=
aKey
.
GetURI
(
)
;
#
ifdef
MOZ_XUL
if
(
IsChromeURI
(
uri
)
)
{
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
if
(
cache
&
&
cache
-
>
IsEnabled
(
)
)
{
if
(
StyleSheet
*
sheet
=
cache
-
>
GetStyleSheet
(
uri
)
)
{
LOG
(
(
"
From
XUL
cache
:
%
p
"
sheet
)
)
;
AssertComplete
(
*
sheet
)
;
if
(
!
sheet
-
>
HasModifiedRules
(
)
&
&
sheet
-
>
ParsingMode
(
)
=
=
aKey
.
ParsingMode
(
)
)
{
return
{
CloneSheet
(
*
sheet
)
SheetState
:
:
Complete
}
;
}
LOG
(
(
"
Not
cloning
due
to
forced
unique
inner
or
mismatched
"
"
parsing
mode
"
)
)
;
}
}
}
#
endif
if
(
auto
lookup
=
mCompleteSheets
.
Lookup
(
&
aKey
)
)
{
LOG
(
(
"
From
completed
:
%
p
"
lookup
.
Data
(
)
.
get
(
)
)
)
;
AssertComplete
(
*
lookup
.
Data
(
)
)
;
MOZ_ASSERT
(
lookup
.
Data
(
)
-
>
ParsingMode
(
)
=
=
aKey
.
ParsingMode
(
)
)
;
if
(
!
lookup
.
Data
(
)
-
>
HasModifiedRules
(
)
)
{
RefPtr
<
StyleSheet
>
&
cachedSheet
=
lookup
.
Data
(
)
;
RefPtr
<
StyleSheet
>
clone
=
CloneSheet
(
*
cachedSheet
)
;
MOZ_ASSERT
(
!
clone
-
>
HasForcedUniqueInner
(
)
)
;
MOZ_ASSERT
(
!
clone
-
>
HasModifiedRules
(
)
)
;
const
bool
oldSheetIsWorthKeeping
=
(
[
&
cachedSheet
]
{
if
(
cachedSheet
-
>
HasForcedUniqueInner
(
)
)
{
return
false
;
}
if
(
!
cachedSheet
-
>
GetOwnerNode
(
)
&
&
!
cachedSheet
-
>
GetParentSheet
(
)
)
{
return
false
;
}
return
true
;
}
(
)
)
;
if
(
!
oldSheetIsWorthKeeping
)
{
cachedSheet
=
clone
;
}
return
{
std
:
:
move
(
clone
)
SheetState
:
:
Complete
}
;
}
LOG
(
(
"
Not
cloning
due
to
modified
rules
"
)
)
;
lookup
.
Remove
(
)
;
}
if
(
aSyncLoad
)
{
return
{
}
;
}
if
(
SheetLoadData
*
data
=
mLoadingDatas
.
Get
(
&
aKey
)
)
{
LOG
(
(
"
From
loading
:
%
p
"
data
-
>
mSheet
.
get
(
)
)
)
;
AssertIncompleteSheetMatches
(
*
data
aKey
)
;
return
{
CloneSheet
(
*
data
-
>
mSheet
)
SheetState
:
:
Loading
}
;
}
if
(
SheetLoadData
*
data
=
mPendingDatas
.
GetWeak
(
&
aKey
)
)
{
LOG
(
(
"
From
pending
:
%
p
"
data
-
>
mSheet
.
get
(
)
)
)
;
AssertIncompleteSheetMatches
(
*
data
aKey
)
;
return
{
CloneSheet
(
*
data
-
>
mSheet
)
SheetState
:
:
Pending
}
;
}
return
{
}
;
}
size_t
Loader
:
:
Sheets
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mCompleteSheets
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mCompleteSheets
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
StyleSheet
*
sheet
=
iter
.
UserData
(
)
;
if
(
!
sheet
-
>
GetOwnerNode
(
)
&
&
!
sheet
-
>
GetParentSheet
(
)
)
{
n
+
=
sheet
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
n
+
=
mInlineSheets
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mInlineSheets
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
iter
.
Key
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
const
StyleSheet
*
sheet
=
iter
.
UserData
(
)
;
MOZ_ASSERT
(
!
sheet
-
>
GetParentSheet
(
)
"
How
did
an
import
rule
end
up
here
?
"
)
;
if
(
!
sheet
-
>
GetOwnerNode
(
)
)
{
n
+
=
sheet
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
return
n
;
}
Loader
:
:
Loader
(
)
:
mDocument
(
nullptr
)
mDatasToNotifyOn
(
0
)
mCompatMode
(
eCompatibility_FullStandards
)
mEnabled
(
true
)
mReporter
(
new
ConsoleReportCollector
(
)
)
{
}
Loader
:
:
Loader
(
DocGroup
*
aDocGroup
)
:
Loader
(
)
{
mDocGroup
=
aDocGroup
;
}
Loader
:
:
Loader
(
Document
*
aDocument
)
:
Loader
(
)
{
MOZ_ASSERT
(
aDocument
"
We
should
get
a
valid
document
from
the
caller
!
"
)
;
mDocument
=
aDocument
;
mCompatMode
=
aDocument
-
>
GetCompatibilityMode
(
)
;
}
Loader
:
:
~
Loader
(
)
{
NS_ASSERTION
(
!
mSheets
|
|
mSheets
-
>
mLoadingDatas
.
Count
(
)
=
=
0
"
How
did
we
get
destroyed
when
there
are
loading
data
?
"
)
;
NS_ASSERTION
(
!
mSheets
|
|
mSheets
-
>
mPendingDatas
.
Count
(
)
=
=
0
"
How
did
we
get
destroyed
when
there
are
pending
data
?
"
)
;
}
void
Loader
:
:
DropDocumentReference
(
void
)
{
mDocument
=
nullptr
;
if
(
mSheets
)
{
StartDeferredLoads
(
)
;
}
}
void
Loader
:
:
DocumentStyleSheetSetChanged
(
)
{
MOZ_ASSERT
(
mDocument
)
;
if
(
!
mSheets
)
{
return
;
}
LoadDataArray
arr
(
mSheets
-
>
mPendingDatas
.
Count
(
)
)
;
for
(
auto
iter
=
mSheets
-
>
mPendingDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
SheetLoadData
>
&
data
=
iter
.
Data
(
)
;
MOZ_ASSERT
(
data
"
Must
have
a
data
"
)
;
auto
isAlternate
=
data
-
>
mLoader
-
>
IsAlternateSheet
(
data
-
>
mTitle
true
)
;
if
(
isAlternate
=
=
IsAlternate
:
:
No
)
{
arr
.
AppendElement
(
std
:
:
move
(
data
)
)
;
iter
.
Remove
(
)
;
}
}
mDatasToNotifyOn
+
=
arr
.
Length
(
)
;
for
(
RefPtr
<
SheetLoadData
>
&
data
:
arr
)
{
-
-
mDatasToNotifyOn
;
LoadSheet
(
*
data
SheetState
:
:
NeedsParser
)
;
}
}
static
const
char
kCharsetSym
[
]
=
"
charset
\
"
"
;
static
bool
GetCharsetFromData
(
const
char
*
aStyleSheetData
uint32_t
aDataLength
nsACString
&
aCharset
)
{
aCharset
.
Truncate
(
)
;
if
(
aDataLength
<
=
sizeof
(
kCharsetSym
)
-
1
)
return
false
;
if
(
strncmp
(
aStyleSheetData
kCharsetSym
sizeof
(
kCharsetSym
)
-
1
)
)
{
return
false
;
}
for
(
uint32_t
i
=
sizeof
(
kCharsetSym
)
-
1
;
i
<
aDataLength
;
+
+
i
)
{
char
c
=
aStyleSheetData
[
i
]
;
if
(
c
=
=
'
"
'
)
{
+
+
i
;
if
(
i
<
aDataLength
&
&
aStyleSheetData
[
i
]
=
=
'
;
'
)
{
return
true
;
}
break
;
}
aCharset
.
Append
(
c
)
;
}
aCharset
.
Truncate
(
)
;
return
false
;
}
NotNull
<
const
Encoding
*
>
SheetLoadData
:
:
DetermineNonBOMEncoding
(
nsACString
const
&
aSegment
nsIChannel
*
aChannel
)
{
const
Encoding
*
encoding
;
nsAutoCString
label
;
if
(
aChannel
&
&
NS_SUCCEEDED
(
aChannel
-
>
GetContentCharset
(
label
)
)
)
{
encoding
=
Encoding
:
:
ForLabel
(
label
)
;
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
auto
sniffingLength
=
aSegment
.
Length
(
)
;
if
(
sniffingLength
>
SNIFFING_BUFFER_SIZE
)
{
sniffingLength
=
SNIFFING_BUFFER_SIZE
;
}
if
(
GetCharsetFromData
(
aSegment
.
BeginReading
(
)
sniffingLength
label
)
)
{
encoding
=
Encoding
:
:
ForLabel
(
label
)
;
if
(
encoding
=
=
UTF_16BE_ENCODING
|
|
encoding
=
=
UTF_16LE_ENCODING
)
{
return
UTF_8_ENCODING
;
}
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
if
(
mOwningNode
)
{
nsAutoString
label16
;
LinkStyle
:
:
FromNode
(
*
mOwningNode
)
-
>
GetCharset
(
label16
)
;
encoding
=
Encoding
:
:
ForLabel
(
label16
)
;
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
if
(
mPreloadEncoding
)
{
return
WrapNotNull
(
mPreloadEncoding
)
;
}
if
(
mParentData
)
{
encoding
=
mParentData
-
>
mEncoding
;
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
if
(
mLoader
-
>
mDocument
)
{
return
mLoader
-
>
mDocument
-
>
GetDocumentCharacterSet
(
)
;
}
return
UTF_8_ENCODING
;
}
static
nsresult
VerifySheetIntegrity
(
const
SRIMetadata
&
aMetadata
nsIChannel
*
aChannel
const
nsACString
&
aFirst
const
nsACString
&
aSecond
const
nsACString
&
aSourceFileURI
nsIConsoleReportCollector
*
aReporter
)
{
NS_ENSURE_ARG_POINTER
(
aReporter
)
;
if
(
MOZ_LOG_TEST
(
SRILogHelper
:
:
GetSriLog
(
)
LogLevel
:
:
Debug
)
)
{
nsAutoCString
requestURL
;
nsCOMPtr
<
nsIURI
>
originalURI
;
if
(
aChannel
&
&
NS_SUCCEEDED
(
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
)
&
&
originalURI
)
{
originalURI
-
>
GetAsciiSpec
(
requestURL
)
;
}
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
LogLevel
:
:
Debug
(
"
VerifySheetIntegrity
(
unichar
stream
)
"
)
)
;
}
SRICheckDataVerifier
verifier
(
aMetadata
aSourceFileURI
aReporter
)
;
nsresult
rv
=
verifier
.
Update
(
aFirst
.
Length
(
)
(
const
uint8_t
*
)
aFirst
.
BeginReading
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
verifier
.
Update
(
aSecond
.
Length
(
)
(
const
uint8_t
*
)
aSecond
.
BeginReading
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
verifier
.
Verify
(
aMetadata
aChannel
aSourceFileURI
aReporter
)
;
}
nsresult
SheetLoadData
:
:
VerifySheetReadyToParse
(
nsresult
aStatus
const
nsACString
&
aBytes1
const
nsACString
&
aBytes2
nsIChannel
*
aChannel
)
{
LOG
(
(
"
SheetLoadData
:
:
VerifySheetReadyToParse
"
)
)
;
NS_ASSERTION
(
!
mLoader
-
>
mSyncCallback
"
Synchronous
callback
from
necko
"
)
;
if
(
mIsCancelled
)
{
return
NS_OK
;
}
if
(
!
mLoader
-
>
mDocument
&
&
!
mIsNonDocumentSheet
)
{
LOG_WARN
(
(
"
No
document
and
not
non
-
document
sheet
;
dropping
load
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_BINDING_ABORTED
)
;
return
NS_OK
;
}
if
(
NS_FAILED
(
aStatus
)
)
{
LOG_WARN
(
(
"
Load
failed
:
status
0x
%
"
PRIx32
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
if
(
net
:
:
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aStatus
)
)
{
if
(
Document
*
doc
=
mLoader
-
>
GetDocument
(
)
)
{
for
(
SheetLoadData
*
data
=
this
;
data
;
data
=
data
-
>
mNext
)
{
doc
-
>
AddBlockedNodeByClassifier
(
nsIContent
:
:
FromNodeOrNull
(
data
-
>
mOwningNode
)
)
;
}
}
}
mLoader
-
>
SheetComplete
(
*
this
aStatus
)
;
return
NS_OK
;
}
if
(
!
aChannel
)
{
mLoader
-
>
SheetComplete
(
*
this
NS_OK
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
originalURI
;
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
nsCOMPtr
<
nsIURI
>
channelURI
;
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
if
(
!
channelURI
|
|
!
originalURI
)
{
NS_ERROR
(
"
Someone
just
violated
the
nsIRequest
contract
"
)
;
LOG_WARN
(
(
"
Channel
without
a
URI
.
Bad
!
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_ERROR_UNEXPECTED
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
nsresult
result
=
NS_ERROR_NOT_AVAILABLE
;
if
(
secMan
)
{
if
(
mUseSystemPrincipal
)
{
result
=
secMan
-
>
GetSystemPrincipal
(
getter_AddRefs
(
principal
)
)
;
}
else
{
result
=
secMan
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
principal
)
)
;
}
}
if
(
NS_FAILED
(
result
)
)
{
LOG_WARN
(
(
"
Couldn
'
t
get
principal
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
result
)
;
return
NS_OK
;
}
mSheet
-
>
SetPrincipal
(
principal
)
;
if
(
mLoaderPrincipal
&
&
mSheet
-
>
GetCORSMode
(
)
=
=
CORS_NONE
)
{
bool
subsumed
;
result
=
mLoaderPrincipal
-
>
Subsumes
(
principal
&
subsumed
)
;
if
(
NS_FAILED
(
result
)
|
|
!
subsumed
)
{
mIsCrossOriginNoCORS
=
true
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
result
=
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_SUCCEEDED
(
result
)
&
&
!
requestSucceeded
)
{
LOG
(
(
"
Load
returned
an
error
page
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
nsAutoCString
sourceMapURL
;
if
(
nsContentUtils
:
:
GetSourceMapURL
(
httpChannel
sourceMapURL
)
)
{
mSheet
-
>
SetSourceMapURL
(
NS_ConvertUTF8toUTF16
(
sourceMapURL
)
)
;
}
}
nsAutoCString
contentType
;
aChannel
-
>
GetContentType
(
contentType
)
;
bool
validType
=
contentType
.
EqualsLiteral
(
"
text
/
css
"
)
|
|
contentType
.
EqualsLiteral
(
UNKNOWN_CONTENT_TYPE
)
|
|
contentType
.
IsEmpty
(
)
;
if
(
!
validType
)
{
const
char
*
errorMessage
;
uint32_t
errorFlag
;
bool
sameOrigin
=
true
;
if
(
mLoaderPrincipal
)
{
bool
subsumed
;
result
=
mLoaderPrincipal
-
>
Subsumes
(
principal
&
subsumed
)
;
if
(
NS_FAILED
(
result
)
|
|
!
subsumed
)
{
sameOrigin
=
false
;
}
}
if
(
sameOrigin
&
&
mLoader
-
>
mCompatMode
=
=
eCompatibility_NavQuirks
)
{
errorMessage
=
"
MimeNotCssWarn
"
;
errorFlag
=
nsIScriptError
:
:
warningFlag
;
}
else
{
errorMessage
=
"
MimeNotCss
"
;
errorFlag
=
nsIScriptError
:
:
errorFlag
;
}
AutoTArray
<
nsString
2
>
strings
;
CopyUTF8toUTF16
(
channelURI
-
>
GetSpecOrDefault
(
)
*
strings
.
AppendElement
(
)
)
;
CopyASCIItoUTF16
(
contentType
*
strings
.
AppendElement
(
)
)
;
nsCOMPtr
<
nsIURI
>
referrer
=
ReferrerInfo
(
)
-
>
GetOriginalReferrer
(
)
;
nsContentUtils
:
:
ReportToConsole
(
errorFlag
NS_LITERAL_CSTRING
(
"
CSS
Loader
"
)
mLoader
-
>
mDocument
nsContentUtils
:
:
eCSS_PROPERTIES
errorMessage
strings
referrer
)
;
if
(
errorFlag
=
=
nsIScriptError
:
:
errorFlag
)
{
LOG_WARN
(
(
"
Ignoring
sheet
with
improper
MIME
type
%
s
"
contentType
.
get
(
)
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
}
SRIMetadata
sriMetadata
;
mSheet
-
>
GetIntegrity
(
sriMetadata
)
;
if
(
!
sriMetadata
.
IsEmpty
(
)
)
{
nsAutoCString
sourceUri
;
if
(
mLoader
-
>
mDocument
&
&
mLoader
-
>
mDocument
-
>
GetDocumentURI
(
)
)
{
mLoader
-
>
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
nsresult
rv
=
VerifySheetIntegrity
(
sriMetadata
aChannel
aBytes1
aBytes2
sourceUri
mLoader
-
>
mReporter
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
aChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
loadGroup
)
{
mLoader
-
>
mReporter
-
>
FlushConsoleReports
(
loadGroup
)
;
}
else
{
mLoader
-
>
mReporter
-
>
FlushConsoleReports
(
mLoader
-
>
mDocument
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Load
was
blocked
by
SRI
"
)
)
;
MOZ_LOG
(
gSriPRLog
LogLevel
:
:
Debug
(
"
css
:
:
Loader
:
:
OnStreamComplete
bad
metadata
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_ERROR_SRI_CORRUPT
)
;
return
NS_OK
;
}
}
mSheet
-
>
SetURIs
(
channelURI
originalURI
channelURI
)
;
ReferrerPolicy
policy
=
nsContentUtils
:
:
GetReferrerPolicyFromChannel
(
aChannel
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForExternalCSSResources
(
mSheet
policy
)
;
mSheet
-
>
SetReferrerInfo
(
referrerInfo
)
;
return
NS_OK_PARSE_SHEET
;
}
Loader
:
:
IsAlternate
Loader
:
:
IsAlternateSheet
(
const
nsAString
&
aTitle
bool
aHasAlternateRel
)
{
if
(
aTitle
.
IsEmpty
(
)
)
{
return
IsAlternate
:
:
No
;
}
if
(
mDocument
)
{
const
nsString
&
currentSheetSet
=
mDocument
-
>
GetCurrentStyleSheetSet
(
)
;
if
(
!
aHasAlternateRel
&
&
currentSheetSet
.
IsEmpty
(
)
)
{
mDocument
-
>
SetPreferredStyleSheetSet
(
aTitle
)
;
return
IsAlternate
:
:
No
;
}
if
(
aTitle
.
Equals
(
currentSheetSet
)
)
{
return
IsAlternate
:
:
No
;
}
}
return
IsAlternate
:
:
Yes
;
}
nsresult
Loader
:
:
CheckContentPolicy
(
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
nsIURI
*
aTargetURI
nsINode
*
aRequestingNode
const
nsAString
&
aNonce
IsPreload
aIsPreload
)
{
if
(
!
aLoadingPrincipal
)
{
return
NS_OK
;
}
nsContentPolicyType
contentPolicyType
=
aIsPreload
=
=
IsPreload
:
:
No
?
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
:
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
;
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
net
:
:
LoadInfo
(
aLoadingPrincipal
aTriggeringPrincipal
aRequestingNode
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
contentPolicyType
)
;
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
)
{
secCheckLoadInfo
-
>
SetCspNonce
(
aNonce
)
;
MOZ_ASSERT_IF
(
aIsPreload
!
=
IsPreload
:
:
No
aNonce
.
IsEmpty
(
)
)
;
}
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
aTargetURI
secCheckLoadInfo
NS_LITERAL_CSTRING
(
"
text
/
css
"
)
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
return
NS_OK
;
}
std
:
:
tuple
<
RefPtr
<
StyleSheet
>
Loader
:
:
SheetState
>
Loader
:
:
CreateSheet
(
nsIURI
*
aURI
nsIContent
*
aLinkingContent
nsIPrincipal
*
aLoaderPrincipal
css
:
:
SheetParsingMode
aParsingMode
CORSMode
aCORSMode
nsIReferrerInfo
*
aLoadingReferrerInfo
const
nsAString
&
aIntegrity
bool
aSyncLoad
IsPreload
aIsPreload
)
{
MOZ_ASSERT
(
aURI
"
This
path
is
not
taken
for
inline
stylesheets
"
)
;
LOG
(
(
"
css
:
:
Loader
:
:
CreateSheet
(
%
s
)
"
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
if
(
!
mSheets
)
{
mSheets
=
MakeUnique
<
Sheets
>
(
)
;
}
SRIMetadata
sriMetadata
;
if
(
!
aIntegrity
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gSriPRLog
LogLevel
:
:
Debug
(
"
css
:
:
Loader
:
:
CreateSheet
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
aIntegrity
)
.
get
(
)
)
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
&
&
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
SRICheck
:
:
IntegrityMetadata
(
aIntegrity
sourceUri
mReporter
&
sriMetadata
)
;
}
SheetLoadDataHashKey
key
(
aURI
aLoaderPrincipal
aLoadingReferrerInfo
aCORSMode
aParsingMode
sriMetadata
aIsPreload
)
;
auto
cacheResult
=
mSheets
-
>
Lookup
(
key
aSyncLoad
)
;
if
(
const
auto
&
[
styleSheet
sheetState
]
=
cacheResult
;
styleSheet
)
{
LOG
(
(
"
Hit
cache
with
state
:
%
s
"
gStateStrings
[
size_t
(
sheetState
)
]
)
)
;
return
cacheResult
;
}
nsIURI
*
sheetURI
=
aURI
;
nsIURI
*
baseURI
=
aURI
;
nsIURI
*
originalURI
=
aURI
;
auto
sheet
=
MakeRefPtr
<
StyleSheet
>
(
aParsingMode
aCORSMode
sriMetadata
)
;
sheet
-
>
SetURIs
(
sheetURI
originalURI
baseURI
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForExternalCSSResources
(
sheet
)
;
sheet
-
>
SetReferrerInfo
(
referrerInfo
)
;
LOG
(
(
"
Needs
parser
"
)
)
;
return
{
std
:
:
move
(
sheet
)
SheetState
:
:
NeedsParser
}
;
}
static
Loader
:
:
MediaMatched
MediaListMatches
(
const
MediaList
*
aMediaList
const
Document
*
aDocument
)
{
if
(
!
aMediaList
|
|
!
aDocument
)
{
return
Loader
:
:
MediaMatched
:
:
Yes
;
}
if
(
aMediaList
-
>
Matches
(
*
aDocument
)
)
{
return
Loader
:
:
MediaMatched
:
:
Yes
;
}
return
Loader
:
:
MediaMatched
:
:
No
;
}
Loader
:
:
MediaMatched
Loader
:
:
PrepareSheet
(
StyleSheet
&
aSheet
const
nsAString
&
aTitle
const
nsAString
&
aMediaString
MediaList
*
aMediaList
IsAlternate
aIsAlternate
IsExplicitlyEnabled
aIsExplicitlyEnabled
)
{
RefPtr
<
MediaList
>
mediaList
(
aMediaList
)
;
if
(
!
aMediaString
.
IsEmpty
(
)
)
{
NS_ASSERTION
(
!
aMediaList
"
must
not
provide
both
aMediaString
and
aMediaList
"
)
;
mediaList
=
MediaList
:
:
Create
(
aMediaString
)
;
}
aSheet
.
SetMedia
(
do_AddRef
(
mediaList
)
)
;
aSheet
.
SetTitle
(
aTitle
)
;
aSheet
.
SetEnabled
(
aIsAlternate
=
=
IsAlternate
:
:
No
|
|
aIsExplicitlyEnabled
=
=
IsExplicitlyEnabled
:
:
Yes
)
;
return
MediaListMatches
(
mediaList
mDocument
)
;
}
void
Loader
:
:
InsertSheetInTree
(
StyleSheet
&
aSheet
nsIContent
*
aLinkingContent
)
{
LOG
(
(
"
css
:
:
Loader
:
:
InsertSheetInTree
"
)
)
;
MOZ_ASSERT
(
mDocument
"
Must
have
a
document
to
insert
into
"
)
;
MOZ_ASSERT
(
!
aLinkingContent
|
|
aLinkingContent
-
>
IsInUncomposedDoc
(
)
|
|
aLinkingContent
-
>
IsInShadowTree
(
)
"
Why
would
we
insert
it
anywhere
?
"
)
;
if
(
auto
*
linkStyle
=
LinkStyle
:
:
FromNodeOrNull
(
aLinkingContent
)
)
{
linkStyle
-
>
SetStyleSheet
(
&
aSheet
)
;
}
ShadowRoot
*
shadow
=
aLinkingContent
?
aLinkingContent
-
>
GetContainingShadow
(
)
:
nullptr
;
auto
&
target
=
shadow
?
static_cast
<
DocumentOrShadowRoot
&
>
(
*
shadow
)
:
static_cast
<
DocumentOrShadowRoot
&
>
(
*
mDocument
)
;
int32_t
sheetCount
=
target
.
SheetCount
(
)
;
int32_t
insertionPoint
=
sheetCount
-
1
;
for
(
;
insertionPoint
>
=
0
;
-
-
insertionPoint
)
{
nsINode
*
sheetOwner
=
target
.
SheetAt
(
insertionPoint
)
-
>
GetOwnerNode
(
)
;
if
(
sheetOwner
&
&
!
aLinkingContent
)
{
continue
;
}
if
(
!
sheetOwner
)
{
break
;
}
MOZ_ASSERT
(
aLinkingContent
!
=
sheetOwner
"
Why
do
we
still
have
our
old
sheet
?
"
)
;
if
(
nsContentUtils
:
:
PositionIsBefore
(
sheetOwner
aLinkingContent
)
)
{
break
;
}
}
+
+
insertionPoint
;
if
(
shadow
)
{
shadow
-
>
InsertSheetAt
(
insertionPoint
aSheet
)
;
}
else
{
mDocument
-
>
InsertSheetAt
(
insertionPoint
aSheet
)
;
}
LOG
(
(
"
Inserting
into
target
(
doc
:
%
d
)
at
position
%
d
"
target
.
AsNode
(
)
.
IsDocument
(
)
insertionPoint
)
)
;
}
void
Loader
:
:
InsertChildSheet
(
StyleSheet
&
aSheet
StyleSheet
&
aParentSheet
)
{
LOG
(
(
"
css
:
:
Loader
:
:
InsertChildSheet
"
)
)
;
aSheet
.
SetEnabled
(
true
)
;
aParentSheet
.
AppendStyleSheet
(
aSheet
)
;
LOG
(
(
"
Inserting
into
parent
sheet
"
)
)
;
}
nsresult
Loader
:
:
LoadSheet
(
SheetLoadData
&
aLoadData
SheetState
aSheetState
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheet
"
)
)
;
MOZ_ASSERT
(
aLoadData
.
mURI
"
Need
a
URI
to
load
"
)
;
MOZ_ASSERT
(
aLoadData
.
mSheet
"
Need
a
sheet
to
load
into
"
)
;
MOZ_ASSERT
(
aSheetState
!
=
SheetState
:
:
Complete
"
Why
bother
?
"
)
;
MOZ_ASSERT
(
!
aLoadData
.
mUseSystemPrincipal
|
|
aLoadData
.
mSyncLoad
"
Shouldn
'
t
use
system
principal
for
async
loads
"
)
;
NS_ASSERTION
(
mSheets
"
mLoadingDatas
should
be
initialized
by
now
.
"
)
;
LOG_URI
(
"
Load
from
:
'
%
s
'
"
aLoadData
.
mURI
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mDocument
&
&
!
aLoadData
.
mIsNonDocumentSheet
)
{
LOG_WARN
(
(
"
No
document
and
not
non
-
document
sheet
;
pre
-
dropping
load
"
)
)
;
SheetComplete
(
aLoadData
NS_BINDING_ABORTED
)
;
return
NS_BINDING_ABORTED
;
}
SRIMetadata
sriMetadata
;
aLoadData
.
mSheet
-
>
GetIntegrity
(
sriMetadata
)
;
if
(
aLoadData
.
mSyncLoad
)
{
LOG
(
(
"
Synchronous
load
"
)
)
;
MOZ_ASSERT
(
!
aLoadData
.
mObserver
"
Observer
for
a
sync
load
?
"
)
;
MOZ_ASSERT
(
aSheetState
=
=
SheetState
:
:
NeedsParser
"
Sync
loads
can
'
t
reuse
existing
async
loads
"
)
;
auto
streamLoader
=
MakeRefPtr
<
StreamLoader
>
(
aLoadData
)
;
if
(
mDocument
)
{
net
:
:
PredictorLearn
(
aLoadData
.
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
mDocument
)
;
}
nsSecurityFlags
securityFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
|
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsContentPolicyType
contentPolicyType
=
aLoadData
.
mIsPreload
=
=
IsPreload
:
:
No
?
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
:
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
aLoadData
.
mRequestingNode
&
&
aLoadData
.
mLoaderPrincipal
)
{
rv
=
NS_NewChannelWithTriggeringPrincipal
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
aLoadData
.
mRequestingNode
aLoadData
.
mLoaderPrincipal
securityFlags
contentPolicyType
)
;
}
else
{
auto
result
=
URLPreloader
:
:
ReadURI
(
aLoadData
.
mURI
)
;
if
(
result
.
isOk
(
)
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
MOZ_TRY
(
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
result
.
unwrap
(
)
)
)
;
rv
=
NS_NewInputStreamChannel
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
stream
.
forget
(
)
nsContentUtils
:
:
GetSystemPrincipal
(
)
securityFlags
contentPolicyType
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
securityFlags
contentPolicyType
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
create
channel
"
)
)
;
streamLoader
-
>
ChannelOpenFailed
(
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
)
{
if
(
aLoadData
.
mRequestingNode
)
{
nsString
*
cspNonce
=
static_cast
<
nsString
*
>
(
aLoadData
.
mRequestingNode
-
>
GetProperty
(
nsGkAtoms
:
:
nonce
)
)
;
if
(
cspNonce
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
loadInfo
-
>
SetCspNonce
(
*
cspNonce
)
;
}
}
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
channel
-
>
Open
(
getter_AddRefs
(
stream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
open
URI
synchronously
"
)
)
;
streamLoader
-
>
ChannelOpenFailed
(
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
channel
-
>
SetContentCharset
(
NS_LITERAL_CSTRING
(
"
UTF
-
8
"
)
)
;
return
nsSyncLoadService
:
:
PushSyncStreamToListener
(
stream
.
forget
(
)
streamLoader
channel
)
;
}
SheetLoadData
*
existingData
=
nullptr
;
SheetLoadDataHashKey
key
(
aLoadData
)
;
if
(
aSheetState
=
=
SheetState
:
:
Loading
)
{
existingData
=
mSheets
-
>
mLoadingDatas
.
Get
(
&
key
)
;
NS_ASSERTION
(
existingData
"
CreateSheet
lied
about
the
state
"
)
;
}
else
if
(
aSheetState
=
=
SheetState
:
:
Pending
)
{
existingData
=
mSheets
-
>
mPendingDatas
.
GetWeak
(
&
key
)
;
NS_ASSERTION
(
existingData
"
CreateSheet
lied
about
the
state
"
)
;
}
if
(
existingData
)
{
LOG
(
(
"
Glomming
on
to
existing
load
"
)
)
;
SheetLoadData
*
data
=
existingData
;
while
(
data
-
>
mNext
)
{
data
=
data
-
>
mNext
;
}
data
-
>
mNext
=
&
aLoadData
;
if
(
aSheetState
=
=
SheetState
:
:
Pending
&
&
!
aLoadData
.
ShouldDefer
(
)
)
{
RefPtr
<
SheetLoadData
>
removedData
;
mSheets
-
>
mPendingDatas
.
Remove
(
&
key
getter_AddRefs
(
removedData
)
)
;
MOZ_ASSERT
(
removedData
=
=
existingData
"
Bad
loading
table
"
)
;
LOG
(
(
"
Forcing
load
of
pending
data
"
)
)
;
return
LoadSheet
(
*
removedData
SheetState
:
:
NeedsParser
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
;
if
(
mDocument
)
{
loadGroup
=
mDocument
-
>
GetDocumentLoadGroup
(
)
;
if
(
!
loadGroup
)
{
LOG_ERROR
(
(
"
Failed
to
query
loadGroup
from
document
"
)
)
;
SheetComplete
(
aLoadData
NS_ERROR_UNEXPECTED
)
;
return
NS_ERROR_UNEXPECTED
;
}
cookieJarSettings
=
mDocument
-
>
CookieJarSettings
(
)
;
}
#
ifdef
DEBUG
AutoRestore
<
bool
>
syncCallbackGuard
(
mSyncCallback
)
;
mSyncCallback
=
true
;
#
endif
CORSMode
ourCORSMode
=
aLoadData
.
mSheet
-
>
GetCORSMode
(
)
;
nsSecurityFlags
securityFlags
=
ourCORSMode
=
=
CORS_NONE
?
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
:
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
;
if
(
ourCORSMode
=
=
CORS_ANONYMOUS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
if
(
ourCORSMode
=
=
CORS_USE_CREDENTIALS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsContentPolicyType
contentPolicyType
=
aLoadData
.
mIsPreload
=
=
IsPreload
:
:
No
?
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
:
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
aLoadData
.
mRequestingNode
&
&
aLoadData
.
mLoaderPrincipal
)
{
rv
=
NS_NewChannelWithTriggeringPrincipal
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
aLoadData
.
mRequestingNode
aLoadData
.
mLoaderPrincipal
securityFlags
contentPolicyType
nullptr
loadGroup
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
securityFlags
contentPolicyType
cookieJarSettings
nullptr
loadGroup
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
create
channel
"
)
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
)
{
if
(
aLoadData
.
mRequestingNode
)
{
nsString
*
cspNonce
=
static_cast
<
nsString
*
>
(
aLoadData
.
mRequestingNode
-
>
GetProperty
(
nsGkAtoms
:
:
nonce
)
)
;
if
(
cspNonce
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
loadInfo
-
>
SetCspNonce
(
*
cspNonce
)
;
}
}
}
if
(
!
aLoadData
.
ShouldDefer
(
)
)
{
if
(
nsCOMPtr
<
nsIClassOfService
>
cos
=
do_QueryInterface
(
channel
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Leader
)
;
}
if
(
aLoadData
.
mIsPreload
=
=
IsPreload
:
:
FromLink
)
{
StreamLoader
:
:
PrioritizeAsPreload
(
channel
)
;
StreamLoader
:
:
AddLoadBackgroundFlag
(
channel
)
;
}
}
if
(
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
channel
)
)
{
if
(
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
aLoadData
.
ReferrerInfo
(
)
)
{
rv
=
httpChannel
-
>
SetReferrerInfo
(
referrerInfo
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
internalChannel
)
{
rv
=
internalChannel
-
>
SetIntegrityMetadata
(
sriMetadata
.
GetIntegrityString
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
nsCOMPtr
<
nsITimedChannel
>
timedChannel
=
do_QueryInterface
(
httpChannel
)
)
{
if
(
aLoadData
.
mParentData
)
{
timedChannel
-
>
SetInitiatorType
(
NS_LITERAL_STRING
(
"
css
"
)
)
;
if
(
aLoadData
.
mParentData
-
>
mIsCrossOriginNoCORS
|
|
aLoadData
.
mParentData
-
>
mBlockResourceTiming
)
{
aLoadData
.
mBlockResourceTiming
=
true
;
timedChannel
-
>
SetReportResourceTiming
(
false
)
;
}
}
else
{
timedChannel
-
>
SetInitiatorType
(
NS_LITERAL_STRING
(
"
link
"
)
)
;
}
}
}
channel
-
>
SetContentType
(
NS_LITERAL_CSTRING
(
"
text
/
css
"
)
)
;
auto
streamLoader
=
MakeRefPtr
<
StreamLoader
>
(
aLoadData
)
;
if
(
mDocument
)
{
net
:
:
PredictorLearn
(
aLoadData
.
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
mDocument
)
;
}
rv
=
channel
-
>
AsyncOpen
(
streamLoader
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
create
stream
loader
"
)
)
;
streamLoader
-
>
ChannelOpenFailed
(
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
nsCOMPtr
<
nsIHttpChannelInternal
>
hci
=
do_QueryInterface
(
channel
)
)
{
hci
-
>
DoDiagnosticAssertWhenOnStopNotCalledOnDestroy
(
)
;
}
#
endif
mSheets
-
>
mLoadingDatas
.
Put
(
&
key
&
aLoadData
)
;
aLoadData
.
mIsLoading
=
true
;
auto
preloadKey
=
PreloadHashKey
:
:
CreateAsStyle
(
aLoadData
)
;
streamLoader
-
>
NotifyOpen
(
&
preloadKey
channel
mDocument
aLoadData
.
mIsPreload
=
=
IsPreload
:
:
FromLink
)
;
return
NS_OK
;
}
Loader
:
:
Completed
Loader
:
:
ParseSheet
(
const
nsACString
&
aBytes
SheetLoadData
&
aLoadData
AllowAsyncParse
aAllowAsync
)
{
LOG
(
(
"
css
:
:
Loader
:
:
ParseSheet
"
)
)
;
AUTO_PROFILER_LABEL
(
"
css
:
:
Loader
:
:
ParseSheet
"
LAYOUT_CSSParsing
)
;
aLoadData
.
mIsBeingParsed
=
true
;
StyleSheet
*
sheet
=
aLoadData
.
mSheet
;
MOZ_ASSERT
(
sheet
)
;
if
(
aLoadData
.
mSyncLoad
|
|
aAllowAsync
=
=
AllowAsyncParse
:
:
No
)
{
sheet
-
>
ParseSheetSync
(
this
aBytes
&
aLoadData
aLoadData
.
mLineNumber
)
;
aLoadData
.
mIsBeingParsed
=
false
;
bool
noPendingChildren
=
aLoadData
.
mPendingChildren
=
=
0
;
MOZ_ASSERT_IF
(
aLoadData
.
mSyncLoad
noPendingChildren
)
;
if
(
noPendingChildren
)
{
SheetComplete
(
aLoadData
NS_OK
)
;
return
Completed
:
:
Yes
;
}
return
Completed
:
:
No
;
}
BlockOnload
(
)
;
nsCOMPtr
<
nsISerialEventTarget
>
target
=
DispatchTarget
(
)
;
sheet
-
>
ParseSheet
(
*
this
aBytes
aLoadData
)
-
>
Then
(
target
__func__
[
loadData
=
RefPtr
<
SheetLoadData
>
(
&
aLoadData
)
]
(
bool
aDummy
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
loadData
-
>
mLoader
-
>
UnblockOnload
(
false
)
;
loadData
-
>
SheetFinishedParsingAsync
(
)
;
}
[
]
{
MOZ_CRASH
(
"
rejected
parse
promise
"
)
;
}
)
;
return
Completed
:
:
No
;
}
void
Loader
:
:
SheetComplete
(
SheetLoadData
&
aLoadData
nsresult
aStatus
)
{
LOG
(
(
"
css
:
:
Loader
:
:
SheetComplete
status
:
0x
%
"
PRIx32
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
if
(
NS_FAILED
(
aStatus
)
)
{
MarkLoadTreeFailed
(
aLoadData
)
;
}
if
(
mDocument
)
{
mDocument
-
>
MaybeWarnAboutZoom
(
)
;
}
AutoTArray
<
RefPtr
<
SheetLoadData
>
8
>
datasToNotify
;
DoSheetComplete
(
aLoadData
datasToNotify
)
;
uint32_t
count
=
datasToNotify
.
Length
(
)
;
mDatasToNotifyOn
+
=
count
;
for
(
RefPtr
<
SheetLoadData
>
&
data
:
datasToNotify
)
{
-
-
mDatasToNotifyOn
;
MOZ_ASSERT
(
data
"
How
did
this
data
get
here
?
"
)
;
if
(
data
-
>
mObserver
)
{
LOG
(
(
"
Notifying
observer
%
p
for
data
%
p
.
deferred
:
%
d
"
data
-
>
mObserver
.
get
(
)
data
.
get
(
)
data
-
>
ShouldDefer
(
)
)
)
;
data
-
>
mObserver
-
>
StyleSheetLoaded
(
data
-
>
mSheet
data
-
>
ShouldDefer
(
)
aStatus
)
;
}
nsTObserverArray
<
nsCOMPtr
<
nsICSSLoaderObserver
>
>
:
:
ForwardIterator
iter
(
mObservers
)
;
nsCOMPtr
<
nsICSSLoaderObserver
>
obs
;
while
(
iter
.
HasMore
(
)
)
{
obs
=
iter
.
GetNext
(
)
;
LOG
(
(
"
Notifying
global
observer
%
p
for
data
%
p
.
deferred
:
%
d
"
obs
.
get
(
)
data
.
get
(
)
data
-
>
ShouldDefer
(
)
)
)
;
obs
-
>
StyleSheetLoaded
(
data
-
>
mSheet
data
-
>
ShouldDefer
(
)
aStatus
)
;
}
}
if
(
mSheets
&
&
mSheets
-
>
mLoadingDatas
.
Count
(
)
=
=
0
&
&
mSheets
-
>
mPendingDatas
.
Count
(
)
>
0
)
{
LOG
(
(
"
No
more
loading
sheets
;
starting
deferred
loads
"
)
)
;
StartDeferredLoads
(
)
;
}
}
void
Loader
:
:
DoSheetComplete
(
SheetLoadData
&
aLoadData
LoadDataArray
&
aDatasToNotify
)
{
LOG
(
(
"
css
:
:
Loader
:
:
DoSheetComplete
"
)
)
;
MOZ_ASSERT
(
aLoadData
.
mSheet
"
Must
have
a
sheet
"
)
;
NS_ASSERTION
(
mSheets
|
|
!
aLoadData
.
mURI
|
|
aLoadData
.
mSheet
-
>
IsConstructed
(
)
"
mLoadingDatas
should
be
initialized
by
now
.
"
)
;
if
(
aLoadData
.
mURI
)
{
LOG_URI
(
"
Finished
loading
:
'
%
s
'
"
aLoadData
.
mURI
)
;
if
(
aLoadData
.
mIsLoading
)
{
SheetLoadDataHashKey
key
(
aLoadData
)
;
Maybe
<
SheetLoadData
*
>
loadingData
=
mSheets
-
>
mLoadingDatas
.
GetAndRemove
(
&
key
)
;
MOZ_DIAGNOSTIC_ASSERT
(
loadingData
&
&
loadingData
.
value
(
)
=
=
&
aLoadData
)
;
Unused
<
<
loadingData
;
aLoadData
.
mIsLoading
=
false
;
}
}
SheetLoadData
*
data
=
&
aLoadData
;
do
{
MOZ_DIAGNOSTIC_ASSERT
(
!
data
-
>
mSheetCompleteCalled
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
data
-
>
mSheetCompleteCalled
=
true
;
#
endif
if
(
!
data
-
>
mSheetAlreadyComplete
)
{
MOZ_ASSERT
(
data
-
>
mSheet
-
>
IsConstructed
(
)
|
|
!
data
-
>
mSheet
-
>
HasForcedUniqueInner
(
)
"
should
not
get
a
forced
unique
inner
during
parsing
"
)
;
data
-
>
mSheet
-
>
SetComplete
(
)
;
data
-
>
ScheduleLoadEventIfNeeded
(
)
;
}
if
(
data
-
>
mMustNotify
&
&
(
data
-
>
mObserver
|
|
!
mObservers
.
IsEmpty
(
)
)
)
{
aDatasToNotify
.
AppendElement
(
data
)
;
}
NS_ASSERTION
(
!
data
-
>
mParentData
|
|
data
-
>
mParentData
-
>
mPendingChildren
!
=
0
"
Broken
pending
child
count
on
our
parent
"
)
;
if
(
data
-
>
mParentData
&
&
-
-
(
data
-
>
mParentData
-
>
mPendingChildren
)
=
=
0
&
&
!
data
-
>
mParentData
-
>
mIsBeingParsed
)
{
DoSheetComplete
(
*
data
-
>
mParentData
aDatasToNotify
)
;
}
data
=
data
-
>
mNext
;
}
while
(
data
)
;
if
(
!
aLoadData
.
mLoadFailed
&
&
aLoadData
.
mURI
&
&
!
aLoadData
.
mSheet
-
>
IsConstructed
(
)
)
{
data
=
&
aLoadData
;
StyleSheet
*
sheet
=
aLoadData
.
mSheet
;
do
{
if
(
data
-
>
mSheet
-
>
GetParentSheet
(
)
|
|
data
-
>
mSheet
-
>
GetOwnerNode
(
)
)
{
sheet
=
data
-
>
mSheet
;
break
;
}
data
=
data
-
>
mNext
;
}
while
(
data
)
;
#
ifdef
MOZ_XUL
if
(
IsChromeURI
(
aLoadData
.
mURI
)
)
{
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
if
(
cache
&
&
cache
-
>
IsEnabled
(
)
)
{
if
(
!
cache
-
>
GetStyleSheet
(
aLoadData
.
mURI
)
)
{
LOG
(
(
"
Putting
sheet
in
XUL
prototype
cache
"
)
)
;
NS_ASSERTION
(
sheet
-
>
IsComplete
(
)
"
Should
only
be
caching
complete
sheets
"
)
;
cache
-
>
PutStyleSheet
(
CloneSheet
(
*
sheet
)
)
;
}
}
}
else
{
#
endif
SheetLoadDataHashKey
key
(
aLoadData
)
;
MOZ_ASSERT
(
sheet
-
>
IsComplete
(
)
"
Should
only
be
caching
complete
sheets
"
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
for
(
const
auto
&
entry
:
mSheets
-
>
mCompleteSheets
)
{
MOZ_DIAGNOSTIC_ASSERT
(
entry
.
GetData
(
)
!
=
sheet
|
|
key
.
KeyEquals
(
entry
.
GetKey
(
)
)
"
Same
sheet
different
keys
?
"
)
;
}
#
endif
mSheets
-
>
mCompleteSheets
.
Put
(
&
key
RefPtr
{
sheet
}
)
;
#
ifdef
MOZ_XUL
}
#
endif
}
}
void
Loader
:
:
MarkLoadTreeFailed
(
SheetLoadData
&
aLoadData
)
{
if
(
aLoadData
.
mURI
)
{
LOG_URI
(
"
Load
failed
:
'
%
s
'
"
aLoadData
.
mURI
)
;
}
SheetLoadData
*
data
=
&
aLoadData
;
do
{
data
-
>
mLoadFailed
=
true
;
data
-
>
mSheet
-
>
MaybeRejectReplacePromise
(
)
;
if
(
data
-
>
mParentData
)
{
MarkLoadTreeFailed
(
*
data
-
>
mParentData
)
;
}
data
=
data
-
>
mNext
;
}
while
(
data
)
;
}
Result
<
Loader
:
:
LoadSheetResult
nsresult
>
Loader
:
:
LoadInlineStyle
(
const
SheetInfo
&
aInfo
const
nsAString
&
aBuffer
uint32_t
aLineNumber
nsICSSLoaderObserver
*
aObserver
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadInlineStyle
"
)
)
;
MOZ_ASSERT
(
aInfo
.
mContent
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
!
mDocument
)
{
return
Err
(
NS_ERROR_NOT_INITIALIZED
)
;
}
MOZ_ASSERT
(
LinkStyle
:
:
FromNodeOrNull
(
aInfo
.
mContent
)
"
Element
is
not
a
style
linking
element
!
"
)
;
auto
isAlternate
=
IsAlternateSheet
(
aInfo
.
mTitle
aInfo
.
mHasAlternateRel
)
;
LOG
(
(
"
Sheet
is
alternate
:
%
d
"
static_cast
<
int
>
(
isAlternate
)
)
)
;
nsIURI
*
baseURI
=
aInfo
.
mContent
-
>
GetBaseURI
(
)
;
nsIURI
*
sheetURI
=
aInfo
.
mContent
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
;
nsIURI
*
originalURI
=
nullptr
;
MOZ_ASSERT
(
aInfo
.
mIntegrity
.
IsEmpty
(
)
)
;
const
bool
isWorthCaching
=
aInfo
.
mContent
-
>
IsInShadowTree
(
)
;
RefPtr
<
StyleSheet
>
sheet
;
if
(
isWorthCaching
)
{
if
(
!
mSheets
)
{
mSheets
=
MakeUnique
<
Sheets
>
(
)
;
}
sheet
=
mSheets
-
>
LookupInline
(
aBuffer
)
;
}
const
bool
sheetFromCache
=
!
!
sheet
;
if
(
!
sheet
)
{
sheet
=
MakeRefPtr
<
StyleSheet
>
(
eAuthorSheetFeatures
aInfo
.
mCORSMode
SRIMetadata
{
}
)
;
sheet
-
>
SetURIs
(
sheetURI
originalURI
baseURI
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForInternalCSSResources
(
aInfo
.
mContent
-
>
OwnerDoc
(
)
)
;
sheet
-
>
SetReferrerInfo
(
referrerInfo
)
;
nsIPrincipal
*
principal
=
aInfo
.
mContent
-
>
NodePrincipal
(
)
;
if
(
aInfo
.
mTriggeringPrincipal
)
{
principal
=
BasePrincipal
:
:
Cast
(
aInfo
.
mTriggeringPrincipal
)
-
>
PrincipalToInherit
(
)
;
}
sheet
-
>
SetPrincipal
(
principal
)
;
}
auto
matched
=
PrepareSheet
(
*
sheet
aInfo
.
mTitle
aInfo
.
mMedia
nullptr
isAlternate
aInfo
.
mIsExplicitlyEnabled
)
;
InsertSheetInTree
(
*
sheet
aInfo
.
mContent
)
;
Completed
completed
;
if
(
sheetFromCache
)
{
MOZ_ASSERT
(
sheet
-
>
IsComplete
(
)
)
;
completed
=
Completed
:
:
Yes
;
}
else
{
auto
data
=
MakeRefPtr
<
SheetLoadData
>
(
this
aInfo
.
mTitle
nullptr
sheet
false
aInfo
.
mContent
isAlternate
matched
IsPreload
:
:
No
aObserver
nullptr
aInfo
.
mReferrerInfo
aInfo
.
mContent
)
;
data
-
>
mLineNumber
=
aLineNumber
;
NS_ConvertUTF16toUTF8
utf8
(
aBuffer
)
;
completed
=
ParseSheet
(
utf8
*
data
AllowAsyncParse
:
:
No
)
;
if
(
completed
=
=
Completed
:
:
Yes
)
{
if
(
isWorthCaching
)
{
mSheets
-
>
mInlineSheets
.
Put
(
aBuffer
std
:
:
move
(
sheet
)
)
;
}
}
else
{
data
-
>
mMustNotify
=
true
;
}
}
return
LoadSheetResult
{
completed
isAlternate
matched
}
;
}
Result
<
Loader
:
:
LoadSheetResult
nsresult
>
Loader
:
:
LoadStyleLink
(
const
SheetInfo
&
aInfo
nsICSSLoaderObserver
*
aObserver
)
{
MOZ_ASSERT
(
aInfo
.
mURI
"
Must
have
URL
to
load
"
)
;
LOG
(
(
"
css
:
:
Loader
:
:
LoadStyleLink
"
)
)
;
LOG_URI
(
"
Link
uri
:
'
%
s
'
"
aInfo
.
mURI
)
;
LOG
(
(
"
Link
title
:
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
aInfo
.
mTitle
)
.
get
(
)
)
)
;
LOG
(
(
"
Link
media
:
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
aInfo
.
mMedia
)
.
get
(
)
)
)
;
LOG
(
(
"
Link
alternate
rel
:
%
d
"
aInfo
.
mHasAlternateRel
)
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
!
mDocument
)
{
return
Err
(
NS_ERROR_NOT_INITIALIZED
)
;
}
nsIPrincipal
*
loadingPrincipal
=
aInfo
.
mContent
?
aInfo
.
mContent
-
>
NodePrincipal
(
)
:
mDocument
-
>
NodePrincipal
(
)
;
nsIPrincipal
*
principal
=
aInfo
.
mTriggeringPrincipal
?
aInfo
.
mTriggeringPrincipal
.
get
(
)
:
loadingPrincipal
;
nsINode
*
context
=
aInfo
.
mContent
;
if
(
!
context
)
{
context
=
mDocument
;
}
bool
syncLoad
=
aInfo
.
mContent
&
&
aInfo
.
mContent
-
>
IsInUAWidget
(
)
&
&
IsChromeURI
(
aInfo
.
mURI
)
;
LOG
(
(
"
Link
sync
load
:
'
%
s
'
"
syncLoad
?
"
true
"
:
"
false
"
)
)
;
MOZ_ASSERT_IF
(
syncLoad
!
aObserver
)
;
nsresult
rv
=
CheckContentPolicy
(
loadingPrincipal
principal
aInfo
.
mURI
context
aInfo
.
mNonce
IsPreload
:
:
No
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
if
(
aInfo
.
mContent
&
&
!
mDocument
-
>
IsLoadedAsData
(
)
)
{
RefPtr
<
AsyncEventDispatcher
>
loadBlockingAsyncDispatcher
=
new
LoadBlockingAsyncEventDispatcher
(
aInfo
.
mContent
NS_LITERAL_STRING
(
"
error
"
)
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eNo
)
;
loadBlockingAsyncDispatcher
-
>
PostDOMEvent
(
)
;
}
return
Err
(
rv
)
;
}
auto
isAlternate
=
IsAlternateSheet
(
aInfo
.
mTitle
aInfo
.
mHasAlternateRel
)
;
auto
[
sheet
state
]
=
CreateSheet
(
aInfo
principal
eAuthorSheetFeatures
syncLoad
IsPreload
:
:
No
)
;
LOG
(
(
"
Sheet
is
alternate
:
%
d
"
static_cast
<
int
>
(
isAlternate
)
)
)
;
auto
matched
=
PrepareSheet
(
*
sheet
aInfo
.
mTitle
aInfo
.
mMedia
nullptr
isAlternate
aInfo
.
mIsExplicitlyEnabled
)
;
InsertSheetInTree
(
*
sheet
aInfo
.
mContent
)
;
MOZ_ASSERT
(
!
aInfo
.
mContent
|
|
LinkStyle
:
:
FromNode
(
*
aInfo
.
mContent
)
"
If
there
is
any
node
it
should
be
a
LinkStyle
"
)
;
auto
data
=
MakeRefPtr
<
SheetLoadData
>
(
this
aInfo
.
mTitle
aInfo
.
mURI
sheet
syncLoad
aInfo
.
mContent
isAlternate
matched
IsPreload
:
:
No
aObserver
principal
aInfo
.
mReferrerInfo
context
)
;
if
(
state
=
=
SheetState
:
:
Complete
)
{
LOG
(
(
"
Sheet
already
complete
:
0x
%
p
"
sheet
.
get
(
)
)
)
;
if
(
aObserver
|
|
!
mObservers
.
IsEmpty
(
)
|
|
aInfo
.
mContent
)
{
rv
=
PostLoadEvent
(
std
:
:
move
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
}
else
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
data
-
>
mIntentionallyDropped
=
true
;
#
endif
}
return
LoadSheetResult
{
Completed
:
:
No
isAlternate
matched
}
;
}
auto
result
=
LoadSheetResult
{
Completed
:
:
No
isAlternate
matched
}
;
MOZ_ASSERT
(
result
.
ShouldBlock
(
)
=
=
!
data
-
>
ShouldDefer
(
)
"
These
should
better
match
!
"
)
;
if
(
!
syncLoad
&
&
state
=
=
SheetState
:
:
NeedsParser
&
&
mSheets
-
>
mLoadingDatas
.
Count
(
)
!
=
0
&
&
!
result
.
ShouldBlock
(
)
)
{
LOG
(
(
"
Deferring
sheet
load
"
)
)
;
SheetLoadDataHashKey
key
(
*
data
)
;
mSheets
-
>
mPendingDatas
.
Put
(
&
key
RefPtr
{
data
}
)
;
data
-
>
mMustNotify
=
true
;
return
result
;
}
rv
=
LoadSheet
(
*
data
state
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
if
(
!
syncLoad
)
{
data
-
>
mMustNotify
=
true
;
}
return
result
;
}
static
bool
HaveAncestorDataWithURI
(
SheetLoadData
&
aData
nsIURI
*
aURI
)
{
if
(
!
aData
.
mURI
)
{
MOZ_ASSERT
(
!
aData
.
mParentData
"
How
does
inline
style
have
a
parent
?
"
)
;
return
false
;
}
bool
equal
;
if
(
NS_FAILED
(
aData
.
mURI
-
>
Equals
(
aURI
&
equal
)
)
|
|
equal
)
{
return
true
;
}
SheetLoadData
*
data
=
&
aData
;
do
{
if
(
data
-
>
mParentData
&
&
HaveAncestorDataWithURI
(
*
data
-
>
mParentData
aURI
)
)
{
return
true
;
}
data
=
data
-
>
mNext
;
}
while
(
data
)
;
return
false
;
}
nsresult
Loader
:
:
LoadChildSheet
(
StyleSheet
&
aParentSheet
SheetLoadData
*
aParentData
nsIURI
*
aURL
dom
:
:
MediaList
*
aMedia
LoaderReusableStyleSheets
*
aReusableSheets
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadChildSheet
"
)
)
;
MOZ_ASSERT
(
aURL
"
Must
have
a
URI
to
load
"
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
LOG_URI
(
"
Child
uri
:
'
%
s
'
"
aURL
)
;
nsCOMPtr
<
nsINode
>
owningNode
;
if
(
aParentSheet
.
GetAssociatedDocumentOrShadowRoot
(
)
)
{
StyleSheet
*
topSheet
=
&
aParentSheet
;
while
(
StyleSheet
*
parent
=
topSheet
-
>
GetParentSheet
(
)
)
{
topSheet
=
parent
;
}
owningNode
=
topSheet
-
>
GetOwnerNode
(
)
;
}
nsINode
*
context
=
nullptr
;
nsIPrincipal
*
loadingPrincipal
=
nullptr
;
if
(
owningNode
)
{
context
=
owningNode
;
loadingPrincipal
=
owningNode
-
>
NodePrincipal
(
)
;
}
else
if
(
mDocument
)
{
context
=
mDocument
;
loadingPrincipal
=
mDocument
-
>
NodePrincipal
(
)
;
}
nsIPrincipal
*
principal
=
aParentSheet
.
Principal
(
)
;
nsresult
rv
=
CheckContentPolicy
(
loadingPrincipal
principal
aURL
context
EmptyString
(
)
IsPreload
:
:
No
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
if
(
aParentData
)
{
MarkLoadTreeFailed
(
*
aParentData
)
;
}
return
rv
;
}
nsCOMPtr
<
nsICSSLoaderObserver
>
observer
;
if
(
aParentData
)
{
LOG
(
(
"
Have
a
parent
load
"
)
)
;
if
(
HaveAncestorDataWithURI
(
*
aParentData
aURL
)
)
{
LOG_ERROR
(
(
"
import
cycle
detected
dropping
load
"
)
)
;
return
NS_OK
;
}
NS_ASSERTION
(
aParentData
-
>
mSheet
=
=
&
aParentSheet
"
Unexpected
call
to
LoadChildSheet
"
)
;
}
else
{
LOG
(
(
"
No
parent
load
;
must
be
CSSOM
"
)
)
;
observer
=
&
aParentSheet
;
}
RefPtr
<
StyleSheet
>
sheet
;
SheetState
state
;
if
(
aReusableSheets
&
&
aReusableSheets
-
>
FindReusableStyleSheet
(
aURL
sheet
)
)
{
state
=
SheetState
:
:
Complete
;
}
else
{
std
:
:
tie
(
sheet
state
)
=
CreateSheet
(
aURL
nullptr
principal
aParentSheet
.
ParsingMode
(
)
CORS_NONE
aParentSheet
.
GetReferrerInfo
(
)
EmptyString
(
)
aParentData
&
&
aParentData
-
>
mSyncLoad
IsPreload
:
:
No
)
;
PrepareSheet
(
*
sheet
EmptyString
(
)
EmptyString
(
)
aMedia
IsAlternate
:
:
No
IsExplicitlyEnabled
:
:
No
)
;
}
MOZ_ASSERT
(
sheet
)
;
InsertChildSheet
(
*
sheet
aParentSheet
)
;
if
(
state
=
=
SheetState
:
:
Complete
)
{
LOG
(
(
"
Sheet
already
complete
"
)
)
;
return
NS_OK
;
}
auto
data
=
MakeRefPtr
<
SheetLoadData
>
(
this
aURL
sheet
aParentData
observer
principal
aParentSheet
.
GetReferrerInfo
(
)
context
)
;
bool
syncLoad
=
data
-
>
mSyncLoad
;
rv
=
LoadSheet
(
*
data
state
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
syncLoad
)
{
data
-
>
mMustNotify
=
true
;
}
return
rv
;
}
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
Loader
:
:
LoadSheetSync
(
nsIURI
*
aURL
SheetParsingMode
aParsingMode
UseSystemPrincipal
aUseSystemPrincipal
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheetSync
"
)
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
nullptr
)
;
return
InternalLoadNonDocumentSheet
(
aURL
IsPreload
:
:
No
aParsingMode
aUseSystemPrincipal
nullptr
nullptr
referrerInfo
nullptr
CORS_NONE
EmptyString
(
)
)
;
}
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
Loader
:
:
LoadSheet
(
nsIURI
*
aURI
SheetParsingMode
aParsingMode
UseSystemPrincipal
aUseSystemPrincipal
nsICSSLoaderObserver
*
aObserver
)
{
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
nullptr
)
;
return
InternalLoadNonDocumentSheet
(
aURI
IsPreload
:
:
No
aParsingMode
aUseSystemPrincipal
nullptr
nullptr
referrerInfo
aObserver
CORS_NONE
EmptyString
(
)
)
;
}
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
Loader
:
:
LoadSheet
(
nsIURI
*
aURL
IsPreload
aIsPreload
nsIPrincipal
*
aOriginPrincipal
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
CORSMode
aCORSMode
const
nsAString
&
aIntegrity
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheet
(
aURL
aObserver
)
api
call
"
)
)
;
return
InternalLoadNonDocumentSheet
(
aURL
aIsPreload
eAuthorSheetFeatures
UseSystemPrincipal
:
:
No
aOriginPrincipal
aPreloadEncoding
aReferrerInfo
aObserver
aCORSMode
aIntegrity
)
;
}
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
Loader
:
:
InternalLoadNonDocumentSheet
(
nsIURI
*
aURL
IsPreload
aIsPreload
SheetParsingMode
aParsingMode
UseSystemPrincipal
aUseSystemPrincipal
nsIPrincipal
*
aOriginPrincipal
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
CORSMode
aCORSMode
const
nsAString
&
aIntegrity
)
{
MOZ_ASSERT
(
aURL
"
Must
have
a
URI
to
load
"
)
;
MOZ_ASSERT
(
aUseSystemPrincipal
=
=
UseSystemPrincipal
:
:
No
|
|
!
aObserver
"
Shouldn
'
t
load
system
-
principal
sheets
async
"
)
;
MOZ_ASSERT
(
aReferrerInfo
"
Must
have
referrerInfo
"
)
;
LOG_URI
(
"
Non
-
document
sheet
uri
:
'
%
s
'
"
aURL
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
(
aOriginPrincipal
&
&
mDocument
?
mDocument
-
>
NodePrincipal
(
)
:
nullptr
)
;
nsresult
rv
=
CheckContentPolicy
(
loadingPrincipal
aOriginPrincipal
aURL
mDocument
EmptyString
(
)
aIsPreload
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
bool
syncLoad
=
!
aObserver
;
auto
[
sheet
state
]
=
CreateSheet
(
aURL
nullptr
aOriginPrincipal
aParsingMode
aCORSMode
aReferrerInfo
aIntegrity
syncLoad
aIsPreload
)
;
PrepareSheet
(
*
sheet
EmptyString
(
)
EmptyString
(
)
nullptr
IsAlternate
:
:
No
IsExplicitlyEnabled
:
:
No
)
;
auto
data
=
MakeRefPtr
<
SheetLoadData
>
(
this
aURL
sheet
syncLoad
aUseSystemPrincipal
aIsPreload
aPreloadEncoding
aObserver
aOriginPrincipal
aReferrerInfo
mDocument
)
;
if
(
state
=
=
SheetState
:
:
Complete
)
{
LOG
(
(
"
Sheet
already
complete
"
)
)
;
if
(
aObserver
|
|
!
mObservers
.
IsEmpty
(
)
)
{
rv
=
PostLoadEvent
(
std
:
:
move
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
}
else
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
data
-
>
mIntentionallyDropped
=
true
;
#
endif
}
return
sheet
;
}
rv
=
LoadSheet
(
*
data
state
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
if
(
aObserver
)
{
data
-
>
mMustNotify
=
true
;
}
return
sheet
;
}
nsresult
Loader
:
:
PostLoadEvent
(
RefPtr
<
SheetLoadData
>
aLoadData
)
{
LOG
(
(
"
css
:
:
Loader
:
:
PostLoadEvent
"
)
)
;
mPostedEvents
.
AppendElement
(
aLoadData
)
;
nsresult
rv
;
RefPtr
<
SheetLoadData
>
runnable
(
aLoadData
)
;
if
(
mDocument
)
{
rv
=
mDocument
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
else
if
(
mDocGroup
)
{
rv
=
mDocGroup
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
else
{
rv
=
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
dispatch
stylesheet
load
event
"
)
;
mPostedEvents
.
RemoveElement
(
aLoadData
)
;
}
else
{
BlockOnload
(
)
;
aLoadData
-
>
mMustNotify
=
true
;
aLoadData
-
>
mSheetAlreadyComplete
=
true
;
MOZ_ASSERT
(
!
aLoadData
-
>
mLoadFailed
"
Why
are
we
marked
as
failed
?
"
)
;
aLoadData
-
>
ScheduleLoadEventIfNeeded
(
)
;
}
return
rv
;
}
void
Loader
:
:
HandleLoadEvent
(
SheetLoadData
&
aEvent
)
{
NS_ASSERTION
(
aEvent
.
mSheet
"
Must
have
sheet
"
)
;
mPostedEvents
.
RemoveElement
(
&
aEvent
)
;
if
(
!
aEvent
.
mIsCancelled
)
{
SheetComplete
(
aEvent
NS_OK
)
;
}
UnblockOnload
(
true
)
;
}
void
Loader
:
:
Stop
(
)
{
uint32_t
pendingCount
=
mSheets
?
mSheets
-
>
mPendingDatas
.
Count
(
)
:
0
;
uint32_t
loadingCount
=
mSheets
?
mSheets
-
>
mLoadingDatas
.
Count
(
)
:
0
;
LoadDataArray
arr
(
pendingCount
+
loadingCount
+
mPostedEvents
.
Length
(
)
)
;
if
(
pendingCount
)
{
for
(
auto
iter
=
mSheets
-
>
mPendingDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
SheetLoadData
>
&
data
=
iter
.
Data
(
)
;
data
-
>
mIsLoading
=
false
;
data
-
>
mIsCancelled
=
true
;
arr
.
AppendElement
(
std
:
:
move
(
data
)
)
;
}
mSheets
-
>
mPendingDatas
.
Clear
(
)
;
}
if
(
loadingCount
)
{
for
(
auto
iter
=
mSheets
-
>
mLoadingDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
SheetLoadData
*
data
=
iter
.
Data
(
)
;
data
-
>
mIsLoading
=
false
;
data
-
>
mIsCancelled
=
true
;
arr
.
AppendElement
(
data
)
;
}
mSheets
-
>
mLoadingDatas
.
Clear
(
)
;
}
for
(
RefPtr
<
SheetLoadData
>
&
data
:
mPostedEvents
)
{
data
-
>
mIsCancelled
=
true
;
arr
.
AppendElement
(
std
:
:
move
(
data
)
)
;
}
mPostedEvents
.
Clear
(
)
;
mDatasToNotifyOn
+
=
arr
.
Length
(
)
;
for
(
RefPtr
<
SheetLoadData
>
&
data
:
arr
)
{
-
-
mDatasToNotifyOn
;
SheetComplete
(
*
data
NS_BINDING_ABORTED
)
;
}
}
bool
Loader
:
:
HasPendingLoads
(
)
{
return
(
mSheets
&
&
mSheets
-
>
mLoadingDatas
.
Count
(
)
!
=
0
)
|
|
(
mSheets
&
&
mSheets
-
>
mPendingDatas
.
Count
(
)
!
=
0
)
|
|
mPostedEvents
.
Length
(
)
!
=
0
|
|
mDatasToNotifyOn
!
=
0
;
}
void
Loader
:
:
AddObserver
(
nsICSSLoaderObserver
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
"
Must
have
observer
"
)
;
mObservers
.
AppendElementUnlessExists
(
aObserver
)
;
}
void
Loader
:
:
RemoveObserver
(
nsICSSLoaderObserver
*
aObserver
)
{
mObservers
.
RemoveElement
(
aObserver
)
;
}
void
Loader
:
:
StartDeferredLoads
(
)
{
MOZ_ASSERT
(
mSheets
"
Don
'
t
call
me
!
"
)
;
LoadDataArray
arr
(
mSheets
-
>
mPendingDatas
.
Count
(
)
)
;
for
(
auto
iter
=
mSheets
-
>
mPendingDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
arr
.
AppendElement
(
iter
.
Data
(
)
)
;
iter
.
Remove
(
)
;
}
mDatasToNotifyOn
+
=
arr
.
Length
(
)
;
for
(
RefPtr
<
SheetLoadData
>
&
data
:
arr
)
{
-
-
mDatasToNotifyOn
;
LoadSheet
(
*
data
SheetState
:
:
NeedsParser
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Loader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Loader
)
if
(
tmp
-
>
mSheets
)
{
for
(
auto
iter
=
tmp
-
>
mSheets
-
>
mCompleteSheets
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
OOL
sheet
cache
in
Loader
"
)
;
cb
.
NoteXPCOMChild
(
iter
.
UserData
(
)
)
;
}
for
(
auto
iter
=
tmp
-
>
mSheets
-
>
mInlineSheets
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
Inline
sheet
cache
in
Loader
"
)
;
cb
.
NoteXPCOMChild
(
iter
.
UserData
(
)
)
;
}
}
nsTObserverArray
<
nsCOMPtr
<
nsICSSLoaderObserver
>
>
:
:
ForwardIterator
it
(
tmp
-
>
mObservers
)
;
while
(
it
.
HasMore
(
)
)
{
ImplCycleCollectionTraverse
(
cb
it
.
GetNext
(
)
"
mozilla
:
:
css
:
:
Loader
.
mObservers
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Loader
)
if
(
tmp
-
>
mSheets
)
{
tmp
-
>
mSheets
-
>
mCompleteSheets
.
Clear
(
)
;
tmp
-
>
mSheets
-
>
mInlineSheets
.
Clear
(
)
;
}
tmp
-
>
mObservers
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
Loader
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
Loader
Release
)
size_t
Loader
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
if
(
mSheets
)
{
n
+
=
mSheets
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
n
+
=
mObservers
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
void
Loader
:
:
BlockOnload
(
)
{
if
(
mDocument
)
{
mDocument
-
>
BlockOnload
(
)
;
}
}
void
Loader
:
:
UnblockOnload
(
bool
aFireSync
)
{
if
(
mDocument
)
{
mDocument
-
>
UnblockOnload
(
aFireSync
)
;
}
}
already_AddRefed
<
nsISerialEventTarget
>
Loader
:
:
DispatchTarget
(
)
{
nsCOMPtr
<
nsISerialEventTarget
>
target
;
if
(
mDocument
)
{
target
=
mDocument
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
}
else
if
(
mDocGroup
)
{
target
=
mDocGroup
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
}
else
{
target
=
GetMainThreadSerialEventTarget
(
)
;
}
return
target
.
forget
(
)
;
}
}
}
