#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
SRILogHelper
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PreloadHashKey
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
URLPreloader
.
h
"
#
include
"
nsIChildChannel
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsSyncLoadService
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsICookieJarSettings
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsICSSLoaderObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
dom
/
MediaList
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
URL
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
ConsoleReportCollector
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
css
/
StreamLoader
.
h
"
#
include
"
mozilla
/
SharedStyleSheetCache
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
nsXULPrototypeCache
.
h
"
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
dom
/
SRICheck
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
using
namespace
mozilla
:
:
dom
;
#
define
SNIFFING_BUFFER_SIZE
1024
extern
mozilla
:
:
LazyLogModule
sCssLoaderLog
;
mozilla
:
:
LazyLogModule
sCssLoaderLog
(
"
nsCSSLoader
"
)
;
static
mozilla
:
:
LazyLogModule
gSriPRLog
(
"
SRI
"
)
;
static
bool
IsPrivilegedURI
(
nsIURI
*
aURI
)
{
return
aURI
-
>
SchemeIs
(
"
chrome
"
)
|
|
aURI
-
>
SchemeIs
(
"
resource
"
)
;
}
#
define
LOG_ERROR
(
args
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Error
args
)
#
define
LOG_WARN
(
args
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Warning
args
)
#
define
LOG_DEBUG
(
args
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG
(
args
)
LOG_DEBUG
(
args
)
#
define
LOG_ERROR_ENABLED
(
)
\
MOZ_LOG_TEST
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Error
)
#
define
LOG_WARN_ENABLED
(
)
\
MOZ_LOG_TEST
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Warning
)
#
define
LOG_DEBUG_ENABLED
(
)
\
MOZ_LOG_TEST
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
)
#
define
LOG_ENABLED
(
)
LOG_DEBUG_ENABLED
(
)
#
define
LOG_URI
(
format
uri
)
\
PR_BEGIN_MACRO
\
NS_ASSERTION
(
uri
"
Logging
null
uri
"
)
;
\
if
(
LOG_ENABLED
(
)
)
{
\
LOG
(
(
format
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
\
}
\
PR_END_MACRO
static
const
char
*
const
gStateStrings
[
]
=
{
"
NeedsParser
"
"
Pending
"
"
Loading
"
"
Complete
"
}
;
namespace
mozilla
{
SheetLoadDataHashKey
:
:
SheetLoadDataHashKey
(
const
css
:
:
SheetLoadData
&
aLoadData
)
:
mURI
(
aLoadData
.
mURI
)
mPrincipal
(
aLoadData
.
mTriggeringPrincipal
)
mLoaderPrincipal
(
aLoadData
.
mLoader
-
>
LoaderPrincipal
(
)
)
mPartitionPrincipal
(
aLoadData
.
mLoader
-
>
PartitionedPrincipal
(
)
)
mEncodingGuess
(
aLoadData
.
mGuessedEncoding
)
mCORSMode
(
aLoadData
.
mSheet
-
>
GetCORSMode
(
)
)
mParsingMode
(
aLoadData
.
mSheet
-
>
ParsingMode
(
)
)
mCompatMode
(
aLoadData
.
mCompatMode
)
mIsLinkRelPreload
(
aLoadData
.
IsLinkRelPreload
(
)
)
{
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
MOZ_ASSERT
(
mURI
)
;
MOZ_ASSERT
(
mPrincipal
)
;
MOZ_ASSERT
(
mLoaderPrincipal
)
;
MOZ_ASSERT
(
mPartitionPrincipal
)
;
aLoadData
.
mSheet
-
>
GetIntegrity
(
mSRIMetadata
)
;
}
bool
SheetLoadDataHashKey
:
:
KeyEquals
(
const
SheetLoadDataHashKey
&
aKey
)
const
{
{
bool
eq
;
if
(
NS_FAILED
(
mURI
-
>
Equals
(
aKey
.
mURI
&
eq
)
)
|
|
!
eq
)
{
return
false
;
}
}
LOG_URI
(
"
KeyEquals
(
%
s
)
\
n
"
mURI
)
;
if
(
mParsingMode
!
=
aKey
.
mParsingMode
)
{
LOG
(
(
"
>
Parsing
mode
mismatch
\
n
"
)
)
;
return
false
;
}
if
(
IsPrivilegedURI
(
mURI
)
)
{
return
true
;
}
if
(
!
mPrincipal
-
>
Equals
(
aKey
.
mPrincipal
)
)
{
LOG
(
(
"
>
Principal
mismatch
\
n
"
)
)
;
return
false
;
}
if
(
mPrincipal
-
>
Equals
(
mLoaderPrincipal
)
|
|
aKey
.
mPrincipal
-
>
Equals
(
aKey
.
mLoaderPrincipal
)
)
{
if
(
!
mPartitionPrincipal
-
>
Equals
(
aKey
.
mPartitionPrincipal
)
)
{
LOG
(
(
"
>
Partition
principal
mismatch
\
n
"
)
)
;
return
false
;
}
}
if
(
mCORSMode
!
=
aKey
.
mCORSMode
)
{
LOG
(
(
"
>
CORS
mismatch
\
n
"
)
)
;
return
false
;
}
if
(
mCompatMode
!
=
aKey
.
mCompatMode
)
{
LOG
(
(
"
>
Quirks
mismatch
\
n
"
)
)
;
return
false
;
}
if
(
mEncodingGuess
!
=
aKey
.
mEncodingGuess
)
{
LOG
(
(
"
>
Encoding
guess
mismatch
\
n
"
)
)
;
return
false
;
}
if
(
mIsLinkRelPreload
!
=
aKey
.
mIsLinkRelPreload
)
{
const
auto
&
linkPreloadMetadata
=
mIsLinkRelPreload
?
mSRIMetadata
:
aKey
.
mSRIMetadata
;
const
auto
&
consumerPreloadMetadata
=
mIsLinkRelPreload
?
aKey
.
mSRIMetadata
:
mSRIMetadata
;
if
(
!
consumerPreloadMetadata
.
CanTrustBeDelegatedTo
(
linkPreloadMetadata
)
)
{
LOG
(
(
"
>
Preload
SRI
metadata
mismatch
\
n
"
)
)
;
return
false
;
}
}
return
true
;
}
namespace
css
{
static
NotNull
<
const
Encoding
*
>
GetFallbackEncoding
(
Loader
&
aLoader
nsINode
*
aOwningNode
const
Encoding
*
aPreloadOrParentDataEncoding
)
{
const
Encoding
*
encoding
;
if
(
aOwningNode
)
{
nsAutoString
label16
;
LinkStyle
:
:
FromNode
(
*
aOwningNode
)
-
>
GetCharset
(
label16
)
;
encoding
=
Encoding
:
:
ForLabel
(
label16
)
;
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
if
(
aPreloadOrParentDataEncoding
)
{
return
WrapNotNull
(
aPreloadOrParentDataEncoding
)
;
}
if
(
auto
*
doc
=
aLoader
.
GetDocument
(
)
)
{
return
doc
-
>
GetDocumentCharacterSet
(
)
;
}
return
UTF_8_ENCODING
;
}
NS_IMPL_ISUPPORTS
(
SheetLoadData
nsIRunnable
nsIThreadObserver
)
SheetLoadData
:
:
SheetLoadData
(
css
:
:
Loader
*
aLoader
const
nsAString
&
aTitle
nsIURI
*
aURI
StyleSheet
*
aSheet
bool
aSyncLoad
nsINode
*
aOwningNode
IsAlternate
aIsAlternate
MediaMatched
aMediaMatches
StylePreloadKind
aPreloadKind
nsICSSLoaderObserver
*
aObserver
nsIPrincipal
*
aTriggeringPrincipal
nsIReferrerInfo
*
aReferrerInfo
)
:
mLoader
(
aLoader
)
mTitle
(
aTitle
)
mEncoding
(
nullptr
)
mURI
(
aURI
)
mLineNumber
(
1
)
mSheet
(
aSheet
)
mPendingChildren
(
0
)
mSyncLoad
(
aSyncLoad
)
mIsNonDocumentSheet
(
false
)
mIsChildSheet
(
aSheet
-
>
GetParentSheet
(
)
)
mIsBeingParsed
(
false
)
mIsLoading
(
false
)
mIsCancelled
(
false
)
mMustNotify
(
false
)
mWasAlternate
(
aIsAlternate
=
=
IsAlternate
:
:
Yes
)
mMediaMatched
(
aMediaMatches
=
=
MediaMatched
:
:
Yes
)
mUseSystemPrincipal
(
false
)
mSheetAlreadyComplete
(
false
)
mIsCrossOriginNoCORS
(
false
)
mBlockResourceTiming
(
false
)
mLoadFailed
(
false
)
mPreloadKind
(
aPreloadKind
)
mOwningNodeBeforeLoadEvent
(
aOwningNode
)
mObserver
(
aObserver
)
mTriggeringPrincipal
(
aTriggeringPrincipal
)
mReferrerInfo
(
aReferrerInfo
)
mGuessedEncoding
(
GetFallbackEncoding
(
*
aLoader
aOwningNode
nullptr
)
)
mCompatMode
(
aLoader
-
>
CompatMode
(
aPreloadKind
)
)
{
MOZ_ASSERT
(
!
mOwningNodeBeforeLoadEvent
|
|
dom
:
:
LinkStyle
:
:
FromNode
(
*
mOwningNodeBeforeLoadEvent
)
"
Must
implement
LinkStyle
"
)
;
MOZ_ASSERT
(
mTriggeringPrincipal
)
;
MOZ_ASSERT
(
mLoader
"
Must
have
a
loader
!
"
)
;
}
SheetLoadData
:
:
SheetLoadData
(
css
:
:
Loader
*
aLoader
nsIURI
*
aURI
StyleSheet
*
aSheet
SheetLoadData
*
aParentData
nsICSSLoaderObserver
*
aObserver
nsIPrincipal
*
aTriggeringPrincipal
nsIReferrerInfo
*
aReferrerInfo
)
:
mLoader
(
aLoader
)
mEncoding
(
nullptr
)
mURI
(
aURI
)
mLineNumber
(
1
)
mSheet
(
aSheet
)
mParentData
(
aParentData
)
mPendingChildren
(
0
)
mSyncLoad
(
aParentData
&
&
aParentData
-
>
mSyncLoad
)
mIsNonDocumentSheet
(
aParentData
&
&
aParentData
-
>
mIsNonDocumentSheet
)
mIsChildSheet
(
aSheet
-
>
GetParentSheet
(
)
)
mIsBeingParsed
(
false
)
mIsLoading
(
false
)
mIsCancelled
(
false
)
mMustNotify
(
false
)
mWasAlternate
(
false
)
mMediaMatched
(
true
)
mUseSystemPrincipal
(
aParentData
&
&
aParentData
-
>
mUseSystemPrincipal
)
mSheetAlreadyComplete
(
false
)
mIsCrossOriginNoCORS
(
false
)
mBlockResourceTiming
(
false
)
mLoadFailed
(
false
)
mPreloadKind
(
StylePreloadKind
:
:
None
)
mObserver
(
aObserver
)
mTriggeringPrincipal
(
aTriggeringPrincipal
)
mReferrerInfo
(
aReferrerInfo
)
mGuessedEncoding
(
GetFallbackEncoding
(
*
aLoader
nullptr
aParentData
?
aParentData
-
>
mEncoding
:
nullptr
)
)
mCompatMode
(
aLoader
-
>
CompatMode
(
mPreloadKind
)
)
{
MOZ_ASSERT
(
mLoader
"
Must
have
a
loader
!
"
)
;
MOZ_ASSERT
(
mTriggeringPrincipal
)
;
MOZ_ASSERT
(
!
mUseSystemPrincipal
|
|
mSyncLoad
"
Shouldn
'
t
use
system
principal
for
async
loads
"
)
;
MOZ_ASSERT_IF
(
aParentData
mIsChildSheet
)
;
}
SheetLoadData
:
:
SheetLoadData
(
css
:
:
Loader
*
aLoader
nsIURI
*
aURI
StyleSheet
*
aSheet
bool
aSyncLoad
UseSystemPrincipal
aUseSystemPrincipal
StylePreloadKind
aPreloadKind
const
Encoding
*
aPreloadEncoding
nsICSSLoaderObserver
*
aObserver
nsIPrincipal
*
aTriggeringPrincipal
nsIReferrerInfo
*
aReferrerInfo
)
:
mLoader
(
aLoader
)
mEncoding
(
nullptr
)
mURI
(
aURI
)
mLineNumber
(
1
)
mSheet
(
aSheet
)
mPendingChildren
(
0
)
mSyncLoad
(
aSyncLoad
)
mIsNonDocumentSheet
(
true
)
mIsChildSheet
(
false
)
mIsBeingParsed
(
false
)
mIsLoading
(
false
)
mIsCancelled
(
false
)
mMustNotify
(
false
)
mWasAlternate
(
false
)
mMediaMatched
(
true
)
mUseSystemPrincipal
(
aUseSystemPrincipal
=
=
UseSystemPrincipal
:
:
Yes
)
mSheetAlreadyComplete
(
false
)
mIsCrossOriginNoCORS
(
false
)
mBlockResourceTiming
(
false
)
mLoadFailed
(
false
)
mPreloadKind
(
aPreloadKind
)
mObserver
(
aObserver
)
mTriggeringPrincipal
(
aTriggeringPrincipal
)
mReferrerInfo
(
aReferrerInfo
)
mGuessedEncoding
(
GetFallbackEncoding
(
*
aLoader
nullptr
aPreloadEncoding
)
)
mCompatMode
(
aLoader
-
>
CompatMode
(
aPreloadKind
)
)
{
MOZ_ASSERT
(
mTriggeringPrincipal
)
;
MOZ_ASSERT
(
mLoader
"
Must
have
a
loader
!
"
)
;
MOZ_ASSERT
(
!
mUseSystemPrincipal
|
|
mSyncLoad
"
Shouldn
'
t
use
system
principal
for
async
loads
"
)
;
MOZ_ASSERT
(
!
aSheet
-
>
GetParentSheet
(
)
"
Shouldn
'
t
be
used
for
child
loads
"
)
;
}
SheetLoadData
:
:
~
SheetLoadData
(
)
{
MOZ_RELEASE_ASSERT
(
mSheetCompleteCalled
|
|
mIntentionallyDropped
"
Should
always
call
SheetComplete
except
when
"
"
dropping
the
load
"
)
;
}
NS_IMETHODIMP
SheetLoadData
:
:
Run
(
)
{
mLoader
-
>
HandleLoadEvent
(
*
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SheetLoadData
:
:
OnDispatchedEvent
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
SheetLoadData
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aMayWait
)
{
FireLoadEvent
(
aThread
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SheetLoadData
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aEventWasProcessed
)
{
FireLoadEvent
(
aThread
)
;
return
NS_OK
;
}
RefPtr
<
StyleSheet
>
SheetLoadData
:
:
ValueForCache
(
)
const
{
return
mSheet
-
>
Clone
(
nullptr
nullptr
)
;
}
void
SheetLoadData
:
:
PrioritizeAsPreload
(
nsIChannel
*
aChannel
)
{
if
(
nsCOMPtr
<
nsISupportsPriority
>
sp
=
do_QueryInterface
(
aChannel
)
)
{
sp
-
>
AdjustPriority
(
nsISupportsPriority
:
:
PRIORITY_HIGHEST
)
;
}
}
void
SheetLoadData
:
:
PrioritizeAsPreload
(
)
{
PrioritizeAsPreload
(
Channel
(
)
)
;
}
void
SheetLoadData
:
:
FireLoadEvent
(
nsIThreadInternal
*
aThread
)
{
RefPtr
<
SheetLoadData
>
kungFuDeathGrip
(
this
)
;
aThread
-
>
RemoveObserver
(
this
)
;
nsCOMPtr
<
nsINode
>
node
=
std
:
:
move
(
mOwningNodeBeforeLoadEvent
)
;
MOZ_ASSERT
(
node
"
How
did
that
happen
?
?
?
"
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
node
-
>
OwnerDoc
(
)
node
mLoadFailed
?
u
"
error
"
_ns
:
u
"
load
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eNo
)
;
MOZ_ASSERT
(
BlocksLoadEvent
(
)
)
;
mLoader
-
>
UnblockOnload
(
true
)
;
}
void
SheetLoadData
:
:
StartPendingLoad
(
)
{
mLoader
-
>
LoadSheet
(
*
this
Loader
:
:
SheetState
:
:
NeedsParser
0
Loader
:
:
PendingLoad
:
:
Yes
)
;
}
void
SheetLoadData
:
:
ScheduleLoadEventIfNeeded
(
)
{
if
(
!
mOwningNodeBeforeLoadEvent
)
{
return
;
}
MOZ_ASSERT
(
BlocksLoadEvent
(
)
"
The
rel
=
preload
load
event
happens
elsewhere
"
)
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
nsCOMPtr
<
nsIThreadInternal
>
internalThread
=
do_QueryInterface
(
thread
)
;
if
(
NS_SUCCEEDED
(
internalThread
-
>
AddObserver
(
this
)
)
)
{
mLoader
-
>
BlockOnload
(
)
;
}
}
nsINode
*
SheetLoadData
:
:
GetRequestingNode
(
)
const
{
if
(
nsINode
*
node
=
mSheet
-
>
GetOwnerNodeOfOutermostSheet
(
)
)
{
return
node
;
}
return
mLoader
-
>
GetDocument
(
)
;
}
bool
LoaderReusableStyleSheets
:
:
FindReusableStyleSheet
(
nsIURI
*
aURL
RefPtr
<
StyleSheet
>
&
aResult
)
{
MOZ_ASSERT
(
aURL
)
;
for
(
size_t
i
=
mReusableSheets
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
size_t
index
=
i
-
1
;
bool
sameURI
;
MOZ_ASSERT
(
mReusableSheets
[
index
]
-
>
GetOriginalURI
(
)
)
;
nsresult
rv
=
aURL
-
>
Equals
(
mReusableSheets
[
index
]
-
>
GetOriginalURI
(
)
&
sameURI
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
sameURI
)
{
aResult
=
mReusableSheets
[
index
]
;
mReusableSheets
.
RemoveElementAt
(
index
)
;
return
true
;
}
}
return
false
;
}
Loader
:
:
Loader
(
)
:
mDocument
(
nullptr
)
mDocumentCompatMode
(
eCompatibility_FullStandards
)
mReporter
(
new
ConsoleReportCollector
(
)
)
{
}
Loader
:
:
Loader
(
DocGroup
*
aDocGroup
)
:
Loader
(
)
{
mDocGroup
=
aDocGroup
;
}
Loader
:
:
Loader
(
Document
*
aDocument
)
:
Loader
(
)
{
MOZ_ASSERT
(
aDocument
"
We
should
get
a
valid
document
from
the
caller
!
"
)
;
mDocument
=
aDocument
;
mIsDocumentAssociated
=
true
;
mDocumentCompatMode
=
aDocument
-
>
GetCompatibilityMode
(
)
;
mSheets
=
SharedStyleSheetCache
:
:
Get
(
)
;
RegisterInSheetCache
(
)
;
}
Loader
:
:
~
Loader
(
)
{
}
void
Loader
:
:
RegisterInSheetCache
(
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mSheets
)
;
mSheets
-
>
RegisterLoader
(
*
this
)
;
}
void
Loader
:
:
DeregisterFromSheetCache
(
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mSheets
)
;
mSheets
-
>
CancelLoadsForLoader
(
*
this
)
;
mSheets
-
>
UnregisterLoader
(
*
this
)
;
}
void
Loader
:
:
DropDocumentReference
(
)
{
if
(
mSheets
)
{
DeregisterFromSheetCache
(
)
;
}
mDocument
=
nullptr
;
}
void
Loader
:
:
DocumentStyleSheetSetChanged
(
)
{
MOZ_ASSERT
(
mDocument
)
;
mSheets
-
>
StartPendingLoadsForLoader
(
*
this
[
&
]
(
const
SheetLoadData
&
aData
)
{
return
IsAlternateSheet
(
aData
.
mTitle
true
)
!
=
IsAlternate
:
:
Yes
;
}
)
;
}
static
const
char
kCharsetSym
[
]
=
"
charset
\
"
"
;
static
bool
GetCharsetFromData
(
const
char
*
aStyleSheetData
uint32_t
aDataLength
nsACString
&
aCharset
)
{
aCharset
.
Truncate
(
)
;
if
(
aDataLength
<
=
sizeof
(
kCharsetSym
)
-
1
)
return
false
;
if
(
strncmp
(
aStyleSheetData
kCharsetSym
sizeof
(
kCharsetSym
)
-
1
)
)
{
return
false
;
}
for
(
uint32_t
i
=
sizeof
(
kCharsetSym
)
-
1
;
i
<
aDataLength
;
+
+
i
)
{
char
c
=
aStyleSheetData
[
i
]
;
if
(
c
=
=
'
"
'
)
{
+
+
i
;
if
(
i
<
aDataLength
&
&
aStyleSheetData
[
i
]
=
=
'
;
'
)
{
return
true
;
}
break
;
}
aCharset
.
Append
(
c
)
;
}
aCharset
.
Truncate
(
)
;
return
false
;
}
NotNull
<
const
Encoding
*
>
SheetLoadData
:
:
DetermineNonBOMEncoding
(
const
nsACString
&
aSegment
nsIChannel
*
aChannel
)
const
{
const
Encoding
*
encoding
;
nsAutoCString
label
;
if
(
aChannel
&
&
NS_SUCCEEDED
(
aChannel
-
>
GetContentCharset
(
label
)
)
)
{
encoding
=
Encoding
:
:
ForLabel
(
label
)
;
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
auto
sniffingLength
=
aSegment
.
Length
(
)
;
if
(
sniffingLength
>
SNIFFING_BUFFER_SIZE
)
{
sniffingLength
=
SNIFFING_BUFFER_SIZE
;
}
if
(
GetCharsetFromData
(
aSegment
.
BeginReading
(
)
sniffingLength
label
)
)
{
encoding
=
Encoding
:
:
ForLabel
(
label
)
;
if
(
encoding
=
=
UTF_16BE_ENCODING
|
|
encoding
=
=
UTF_16LE_ENCODING
)
{
return
UTF_8_ENCODING
;
}
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
return
mGuessedEncoding
;
}
static
nsresult
VerifySheetIntegrity
(
const
SRIMetadata
&
aMetadata
nsIChannel
*
aChannel
const
nsACString
&
aFirst
const
nsACString
&
aSecond
const
nsACString
&
aSourceFileURI
nsIConsoleReportCollector
*
aReporter
)
{
NS_ENSURE_ARG_POINTER
(
aReporter
)
;
if
(
MOZ_LOG_TEST
(
SRILogHelper
:
:
GetSriLog
(
)
LogLevel
:
:
Debug
)
)
{
nsAutoCString
requestURL
;
nsCOMPtr
<
nsIURI
>
originalURI
;
if
(
aChannel
&
&
NS_SUCCEEDED
(
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
)
&
&
originalURI
)
{
originalURI
-
>
GetAsciiSpec
(
requestURL
)
;
}
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
LogLevel
:
:
Debug
(
"
VerifySheetIntegrity
(
unichar
stream
)
"
)
)
;
}
SRICheckDataVerifier
verifier
(
aMetadata
aSourceFileURI
aReporter
)
;
nsresult
rv
=
verifier
.
Update
(
aFirst
.
Length
(
)
(
const
uint8_t
*
)
aFirst
.
BeginReading
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
verifier
.
Update
(
aSecond
.
Length
(
)
(
const
uint8_t
*
)
aSecond
.
BeginReading
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
verifier
.
Verify
(
aMetadata
aChannel
aSourceFileURI
aReporter
)
;
}
static
bool
AllLoadsCanceled
(
const
SheetLoadData
&
aData
)
{
const
SheetLoadData
*
data
=
&
aData
;
do
{
if
(
!
data
-
>
IsCancelled
(
)
)
{
return
false
;
}
}
while
(
(
data
=
data
-
>
mNext
)
)
;
return
true
;
}
nsresult
SheetLoadData
:
:
VerifySheetReadyToParse
(
nsresult
aStatus
const
nsACString
&
aBytes1
const
nsACString
&
aBytes2
nsIChannel
*
aChannel
)
{
LOG
(
(
"
SheetLoadData
:
:
VerifySheetReadyToParse
"
)
)
;
NS_ASSERTION
(
!
mLoader
-
>
mSyncCallback
"
Synchronous
callback
from
necko
"
)
;
if
(
AllLoadsCanceled
(
*
this
)
)
{
LOG_WARN
(
(
"
All
loads
are
canceled
dropping
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_BINDING_ABORTED
)
;
return
NS_OK
;
}
if
(
NS_FAILED
(
aStatus
)
)
{
LOG_WARN
(
(
"
Load
failed
:
status
0x
%
"
PRIx32
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
if
(
net
:
:
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aStatus
)
)
{
if
(
Document
*
doc
=
mLoader
-
>
GetDocument
(
)
)
{
for
(
SheetLoadData
*
data
=
this
;
data
;
data
=
data
-
>
mNext
)
{
doc
-
>
AddBlockedNodeByClassifier
(
nsIContent
:
:
FromNodeOrNull
(
data
-
>
mOwningNodeBeforeLoadEvent
)
)
;
}
}
}
mLoader
-
>
SheetComplete
(
*
this
aStatus
)
;
return
NS_OK
;
}
if
(
!
aChannel
)
{
mLoader
-
>
SheetComplete
(
*
this
NS_OK
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
originalURI
;
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
nsCOMPtr
<
nsIURI
>
channelURI
;
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
if
(
!
channelURI
|
|
!
originalURI
)
{
NS_ERROR
(
"
Someone
just
violated
the
nsIRequest
contract
"
)
;
LOG_WARN
(
(
"
Channel
without
a
URI
.
Bad
!
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_ERROR_UNEXPECTED
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
nsresult
result
=
NS_ERROR_NOT_AVAILABLE
;
if
(
secMan
)
{
if
(
mUseSystemPrincipal
)
{
result
=
secMan
-
>
GetSystemPrincipal
(
getter_AddRefs
(
principal
)
)
;
}
else
{
result
=
secMan
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
principal
)
)
;
}
}
if
(
NS_FAILED
(
result
)
)
{
LOG_WARN
(
(
"
Couldn
'
t
get
principal
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
result
)
;
return
NS_OK
;
}
mSheet
-
>
SetPrincipal
(
principal
)
;
if
(
mSheet
-
>
GetCORSMode
(
)
=
=
CORS_NONE
&
&
!
mTriggeringPrincipal
-
>
Subsumes
(
principal
)
)
{
mIsCrossOriginNoCORS
=
true
;
}
if
(
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
)
{
bool
requestSucceeded
;
result
=
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_SUCCEEDED
(
result
)
&
&
!
requestSucceeded
)
{
LOG
(
(
"
Load
returned
an
error
page
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
nsAutoCString
sourceMapURL
;
if
(
nsContentUtils
:
:
GetSourceMapURL
(
httpChannel
sourceMapURL
)
)
{
mSheet
-
>
SetSourceMapURL
(
NS_ConvertUTF8toUTF16
(
sourceMapURL
)
)
;
}
}
nsAutoCString
contentType
;
aChannel
-
>
GetContentType
(
contentType
)
;
bool
validType
=
contentType
.
EqualsLiteral
(
"
text
/
css
"
)
|
|
contentType
.
EqualsLiteral
(
UNKNOWN_CONTENT_TYPE
)
|
|
contentType
.
IsEmpty
(
)
;
if
(
!
validType
)
{
const
char
*
errorMessage
;
uint32_t
errorFlag
;
bool
sameOrigin
=
true
;
bool
subsumed
;
result
=
mTriggeringPrincipal
-
>
Subsumes
(
principal
&
subsumed
)
;
if
(
NS_FAILED
(
result
)
|
|
!
subsumed
)
{
sameOrigin
=
false
;
}
if
(
sameOrigin
&
&
mCompatMode
=
=
eCompatibility_NavQuirks
)
{
errorMessage
=
"
MimeNotCssWarn
"
;
errorFlag
=
nsIScriptError
:
:
warningFlag
;
}
else
{
errorMessage
=
"
MimeNotCss
"
;
errorFlag
=
nsIScriptError
:
:
errorFlag
;
}
AutoTArray
<
nsString
2
>
strings
;
CopyUTF8toUTF16
(
channelURI
-
>
GetSpecOrDefault
(
)
*
strings
.
AppendElement
(
)
)
;
CopyASCIItoUTF16
(
contentType
*
strings
.
AppendElement
(
)
)
;
nsCOMPtr
<
nsIURI
>
referrer
=
ReferrerInfo
(
)
-
>
GetOriginalReferrer
(
)
;
nsContentUtils
:
:
ReportToConsole
(
errorFlag
"
CSS
Loader
"
_ns
mLoader
-
>
mDocument
nsContentUtils
:
:
eCSS_PROPERTIES
errorMessage
strings
referrer
)
;
if
(
errorFlag
=
=
nsIScriptError
:
:
errorFlag
)
{
LOG_WARN
(
(
"
Ignoring
sheet
with
improper
MIME
type
%
s
"
contentType
.
get
(
)
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
}
SRIMetadata
sriMetadata
;
mSheet
-
>
GetIntegrity
(
sriMetadata
)
;
if
(
!
sriMetadata
.
IsEmpty
(
)
)
{
nsAutoCString
sourceUri
;
if
(
mLoader
-
>
mDocument
&
&
mLoader
-
>
mDocument
-
>
GetDocumentURI
(
)
)
{
mLoader
-
>
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
nsresult
rv
=
VerifySheetIntegrity
(
sriMetadata
aChannel
aBytes1
aBytes2
sourceUri
mLoader
-
>
mReporter
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
aChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
loadGroup
)
{
mLoader
-
>
mReporter
-
>
FlushConsoleReports
(
loadGroup
)
;
}
else
{
mLoader
-
>
mReporter
-
>
FlushConsoleReports
(
mLoader
-
>
mDocument
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Load
was
blocked
by
SRI
"
)
)
;
MOZ_LOG
(
gSriPRLog
LogLevel
:
:
Debug
(
"
css
:
:
Loader
:
:
OnStreamComplete
bad
metadata
"
)
)
;
mLoader
-
>
SheetComplete
(
*
this
NS_ERROR_SRI_CORRUPT
)
;
return
NS_OK
;
}
}
mSheet
-
>
SetURIs
(
channelURI
originalURI
channelURI
)
;
ReferrerPolicy
policy
=
nsContentUtils
:
:
GetReferrerPolicyFromChannel
(
aChannel
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForExternalCSSResources
(
mSheet
policy
)
;
mSheet
-
>
SetReferrerInfo
(
referrerInfo
)
;
return
NS_OK_PARSE_SHEET
;
}
Loader
:
:
IsAlternate
Loader
:
:
IsAlternateSheet
(
const
nsAString
&
aTitle
bool
aHasAlternateRel
)
{
if
(
aTitle
.
IsEmpty
(
)
)
{
return
IsAlternate
:
:
No
;
}
if
(
mDocument
)
{
const
nsString
&
currentSheetSet
=
mDocument
-
>
GetCurrentStyleSheetSet
(
)
;
if
(
!
aHasAlternateRel
&
&
currentSheetSet
.
IsEmpty
(
)
)
{
mDocument
-
>
SetPreferredStyleSheetSet
(
aTitle
)
;
return
IsAlternate
:
:
No
;
}
if
(
aTitle
.
Equals
(
currentSheetSet
)
)
{
return
IsAlternate
:
:
No
;
}
}
return
IsAlternate
:
:
Yes
;
}
nsresult
Loader
:
:
CheckContentPolicy
(
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
nsIURI
*
aTargetURI
nsINode
*
aRequestingNode
const
nsAString
&
aNonce
StylePreloadKind
aPreloadKind
)
{
if
(
!
mDocument
)
{
return
NS_OK
;
}
nsContentPolicyType
contentPolicyType
=
aPreloadKind
=
=
StylePreloadKind
:
:
None
?
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
:
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
;
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
net
:
:
LoadInfo
(
aLoadingPrincipal
aTriggeringPrincipal
aRequestingNode
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
contentPolicyType
)
;
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
)
{
secCheckLoadInfo
-
>
SetCspNonce
(
aNonce
)
;
MOZ_ASSERT_IF
(
aPreloadKind
!
=
StylePreloadKind
:
:
None
aNonce
.
IsEmpty
(
)
)
;
}
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
aTargetURI
secCheckLoadInfo
"
text
/
css
"
_ns
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
Loader
:
:
NotifyOnFailedCheckPolicy
"
[
targetURI
=
RefPtr
<
nsIURI
>
(
aTargetURI
)
requestingNode
=
RefPtr
<
nsINode
>
(
aRequestingNode
)
contentPolicyType
]
(
)
{
nsCOMPtr
<
nsIChannel
>
channel
;
NS_NewChannel
(
getter_AddRefs
(
channel
)
targetURI
requestingNode
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT
contentPolicyType
)
;
NS_SetRequestBlockingReason
(
channel
nsILoadInfo
:
:
BLOCKING_REASON_CONTENT_POLICY_GENERAL
)
;
nsCOMPtr
<
nsIObserverService
>
obsService
=
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
NotifyObservers
(
channel
"
http
-
on
-
failed
-
opening
-
request
"
nullptr
)
;
}
}
)
)
;
return
NS_ERROR_CONTENT_BLOCKED
;
}
return
NS_OK
;
}
static
void
RecordUseCountersIfNeeded
(
Document
*
aDoc
const
StyleUseCounters
*
aCounters
)
{
if
(
!
aDoc
|
|
!
aCounters
)
{
return
;
}
const
StyleUseCounters
*
docCounters
=
aDoc
-
>
GetStyleUseCounters
(
)
;
if
(
!
docCounters
)
{
return
;
}
Servo_UseCounters_Merge
(
docCounters
aCounters
)
;
aDoc
-
>
MaybeWarnAboutZoom
(
)
;
}
std
:
:
tuple
<
RefPtr
<
StyleSheet
>
Loader
:
:
SheetState
>
Loader
:
:
CreateSheet
(
nsIURI
*
aURI
nsIContent
*
aLinkingContent
nsIPrincipal
*
aTriggeringPrincipal
css
:
:
SheetParsingMode
aParsingMode
CORSMode
aCORSMode
const
Encoding
*
aPreloadOrParentDataEncoding
const
nsAString
&
aIntegrity
bool
aSyncLoad
StylePreloadKind
aPreloadKind
)
{
MOZ_ASSERT
(
aURI
"
This
path
is
not
taken
for
inline
stylesheets
"
)
;
LOG
(
(
"
css
:
:
Loader
:
:
CreateSheet
(
%
s
)
"
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
SRIMetadata
sriMetadata
;
if
(
!
aIntegrity
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gSriPRLog
LogLevel
:
:
Debug
(
"
css
:
:
Loader
:
:
CreateSheet
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
aIntegrity
)
.
get
(
)
)
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
&
&
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
SRICheck
:
:
IntegrityMetadata
(
aIntegrity
sourceUri
mReporter
&
sriMetadata
)
;
}
if
(
mSheets
)
{
SheetLoadDataHashKey
key
(
aURI
aTriggeringPrincipal
LoaderPrincipal
(
)
PartitionedPrincipal
(
)
GetFallbackEncoding
(
*
this
aLinkingContent
aPreloadOrParentDataEncoding
)
aCORSMode
aParsingMode
CompatMode
(
aPreloadKind
)
sriMetadata
aPreloadKind
)
;
auto
cacheResult
=
mSheets
-
>
Lookup
(
*
this
key
aSyncLoad
)
;
if
(
cacheResult
.
mState
!
=
CachedSubResourceState
:
:
Miss
)
{
SheetState
sheetState
=
SheetState
:
:
Complete
;
RefPtr
<
StyleSheet
>
sheet
;
if
(
cacheResult
.
mCompleteValue
)
{
sheet
=
cacheResult
.
mCompleteValue
-
>
Clone
(
nullptr
nullptr
)
;
mDocument
-
>
SetDidHitCompleteSheetCache
(
)
;
RecordUseCountersIfNeeded
(
mDocument
sheet
-
>
GetStyleUseCounters
(
)
)
;
mLoadsPerformed
.
PutEntry
(
key
)
;
}
else
{
MOZ_ASSERT
(
cacheResult
.
mLoadingOrPendingValue
)
;
sheet
=
cacheResult
.
mLoadingOrPendingValue
-
>
ValueForCache
(
)
;
sheetState
=
cacheResult
.
mState
=
=
CachedSubResourceState
:
:
Loading
?
SheetState
:
:
Loading
:
SheetState
:
:
Pending
;
}
LOG
(
(
"
Hit
cache
with
state
:
%
s
"
gStateStrings
[
size_t
(
sheetState
)
]
)
)
;
return
{
std
:
:
move
(
sheet
)
sheetState
}
;
}
}
nsIURI
*
sheetURI
=
aURI
;
nsIURI
*
baseURI
=
aURI
;
nsIURI
*
originalURI
=
aURI
;
auto
sheet
=
MakeRefPtr
<
StyleSheet
>
(
aParsingMode
aCORSMode
sriMetadata
)
;
sheet
-
>
SetURIs
(
sheetURI
originalURI
baseURI
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForExternalCSSResources
(
sheet
)
;
sheet
-
>
SetReferrerInfo
(
referrerInfo
)
;
LOG
(
(
"
Needs
parser
"
)
)
;
return
{
std
:
:
move
(
sheet
)
SheetState
:
:
NeedsParser
}
;
}
static
Loader
:
:
MediaMatched
MediaListMatches
(
const
MediaList
*
aMediaList
const
Document
*
aDocument
)
{
if
(
!
aMediaList
|
|
!
aDocument
)
{
return
Loader
:
:
MediaMatched
:
:
Yes
;
}
if
(
aMediaList
-
>
Matches
(
*
aDocument
)
)
{
return
Loader
:
:
MediaMatched
:
:
Yes
;
}
return
Loader
:
:
MediaMatched
:
:
No
;
}
Loader
:
:
MediaMatched
Loader
:
:
PrepareSheet
(
StyleSheet
&
aSheet
const
nsAString
&
aTitle
const
nsAString
&
aMediaString
MediaList
*
aMediaList
IsAlternate
aIsAlternate
IsExplicitlyEnabled
aIsExplicitlyEnabled
)
{
RefPtr
<
MediaList
>
mediaList
(
aMediaList
)
;
if
(
!
aMediaString
.
IsEmpty
(
)
)
{
NS_ASSERTION
(
!
aMediaList
"
must
not
provide
both
aMediaString
and
aMediaList
"
)
;
mediaList
=
MediaList
:
:
Create
(
NS_ConvertUTF16toUTF8
(
aMediaString
)
)
;
}
aSheet
.
SetMedia
(
do_AddRef
(
mediaList
)
)
;
aSheet
.
SetTitle
(
aTitle
)
;
aSheet
.
SetEnabled
(
aIsAlternate
=
=
IsAlternate
:
:
No
|
|
aIsExplicitlyEnabled
=
=
IsExplicitlyEnabled
:
:
Yes
)
;
return
MediaListMatches
(
mediaList
mDocument
)
;
}
void
Loader
:
:
InsertSheetInTree
(
StyleSheet
&
aSheet
)
{
LOG
(
(
"
css
:
:
Loader
:
:
InsertSheetInTree
"
)
)
;
MOZ_ASSERT
(
mDocument
"
Must
have
a
document
to
insert
into
"
)
;
nsINode
*
owningNode
=
aSheet
.
GetOwnerNode
(
)
;
MOZ_ASSERT
(
!
owningNode
|
|
owningNode
-
>
IsInUncomposedDoc
(
)
|
|
owningNode
-
>
IsInShadowTree
(
)
"
Why
would
we
insert
it
anywhere
?
"
)
;
ShadowRoot
*
shadow
=
owningNode
?
owningNode
-
>
GetContainingShadow
(
)
:
nullptr
;
auto
&
target
=
shadow
?
static_cast
<
DocumentOrShadowRoot
&
>
(
*
shadow
)
:
static_cast
<
DocumentOrShadowRoot
&
>
(
*
mDocument
)
;
int32_t
sheetCount
=
target
.
SheetCount
(
)
;
int32_t
insertionPoint
=
sheetCount
-
1
;
for
(
;
insertionPoint
>
=
0
;
-
-
insertionPoint
)
{
nsINode
*
sheetOwner
=
target
.
SheetAt
(
insertionPoint
)
-
>
GetOwnerNode
(
)
;
if
(
sheetOwner
&
&
!
owningNode
)
{
continue
;
}
if
(
!
sheetOwner
)
{
break
;
}
MOZ_ASSERT
(
owningNode
!
=
sheetOwner
"
Why
do
we
still
have
our
old
sheet
?
"
)
;
if
(
nsContentUtils
:
:
PositionIsBefore
(
sheetOwner
owningNode
)
)
{
break
;
}
}
+
+
insertionPoint
;
if
(
shadow
)
{
shadow
-
>
InsertSheetAt
(
insertionPoint
aSheet
)
;
}
else
{
mDocument
-
>
InsertSheetAt
(
insertionPoint
aSheet
)
;
}
LOG
(
(
"
Inserting
into
target
(
doc
:
%
d
)
at
position
%
d
"
target
.
AsNode
(
)
.
IsDocument
(
)
insertionPoint
)
)
;
}
void
Loader
:
:
InsertChildSheet
(
StyleSheet
&
aSheet
StyleSheet
&
aParentSheet
)
{
LOG
(
(
"
css
:
:
Loader
:
:
InsertChildSheet
"
)
)
;
aSheet
.
SetEnabled
(
true
)
;
aParentSheet
.
AppendStyleSheet
(
aSheet
)
;
LOG
(
(
"
Inserting
into
parent
sheet
"
)
)
;
}
nsresult
Loader
:
:
LoadSheet
(
SheetLoadData
&
aLoadData
SheetState
aSheetState
uint64_t
aEarlyHintPreloaderId
PendingLoad
aPendingLoad
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheet
"
)
)
;
MOZ_ASSERT
(
aLoadData
.
mURI
"
Need
a
URI
to
load
"
)
;
MOZ_ASSERT
(
aLoadData
.
mSheet
"
Need
a
sheet
to
load
into
"
)
;
MOZ_ASSERT
(
aSheetState
!
=
SheetState
:
:
Complete
"
Why
bother
?
"
)
;
MOZ_ASSERT
(
!
aLoadData
.
mUseSystemPrincipal
|
|
aLoadData
.
mSyncLoad
"
Shouldn
'
t
use
system
principal
for
async
loads
"
)
;
LOG_URI
(
"
Load
from
:
'
%
s
'
"
aLoadData
.
mURI
)
;
if
(
aPendingLoad
=
=
PendingLoad
:
:
No
)
{
if
(
aLoadData
.
BlocksLoadEvent
(
)
)
{
IncrementOngoingLoadCount
(
)
;
}
if
(
aLoadData
.
mParentData
)
{
+
+
aLoadData
.
mParentData
-
>
mPendingChildren
;
}
}
nsresult
rv
=
NS_OK
;
if
(
!
mDocument
&
&
!
aLoadData
.
mIsNonDocumentSheet
)
{
LOG_WARN
(
(
"
No
document
and
not
non
-
document
sheet
;
pre
-
dropping
load
"
)
)
;
SheetComplete
(
aLoadData
NS_BINDING_ABORTED
)
;
return
NS_BINDING_ABORTED
;
}
SRIMetadata
sriMetadata
;
aLoadData
.
mSheet
-
>
GetIntegrity
(
sriMetadata
)
;
nsINode
*
requestingNode
=
aLoadData
.
GetRequestingNode
(
)
;
if
(
aLoadData
.
mSyncLoad
)
{
LOG
(
(
"
Synchronous
load
"
)
)
;
MOZ_ASSERT
(
!
aLoadData
.
mObserver
"
Observer
for
a
sync
load
?
"
)
;
MOZ_ASSERT
(
aSheetState
=
=
SheetState
:
:
NeedsParser
"
Sync
loads
can
'
t
reuse
existing
async
loads
"
)
;
auto
streamLoader
=
MakeRefPtr
<
StreamLoader
>
(
aLoadData
)
;
if
(
mDocument
)
{
net
:
:
PredictorLearn
(
aLoadData
.
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
mDocument
)
;
}
nsSecurityFlags
securityFlags
=
nsContentSecurityManager
:
:
ComputeSecurityFlags
(
CORSMode
:
:
CORS_NONE
nsContentSecurityManager
:
:
CORSSecurityMapping
:
:
CORS_NONE_MAPS_TO_INHERITED_CONTEXT
)
;
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsContentPolicyType
contentPolicyType
=
aLoadData
.
mPreloadKind
=
=
StylePreloadKind
:
:
None
?
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
:
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
requestingNode
)
{
rv
=
NS_NewChannelWithTriggeringPrincipal
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
requestingNode
aLoadData
.
mTriggeringPrincipal
securityFlags
contentPolicyType
)
;
}
else
{
MOZ_ASSERT
(
aLoadData
.
mTriggeringPrincipal
-
>
Equals
(
LoaderPrincipal
(
)
)
)
;
auto
result
=
URLPreloader
:
:
ReadURI
(
aLoadData
.
mURI
)
;
if
(
result
.
isOk
(
)
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
MOZ_TRY
(
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
result
.
unwrap
(
)
)
)
;
rv
=
NS_NewInputStreamChannel
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
stream
.
forget
(
)
aLoadData
.
mTriggeringPrincipal
securityFlags
contentPolicyType
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
aLoadData
.
mTriggeringPrincipal
securityFlags
contentPolicyType
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
create
channel
"
)
)
;
streamLoader
-
>
ChannelOpenFailed
(
rv
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
)
{
if
(
requestingNode
)
{
nsString
*
cspNonce
=
static_cast
<
nsString
*
>
(
requestingNode
-
>
GetProperty
(
nsGkAtoms
:
:
nonce
)
)
;
if
(
cspNonce
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
loadInfo
-
>
SetCspNonce
(
*
cspNonce
)
;
}
}
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
channel
-
>
Open
(
getter_AddRefs
(
stream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
open
URI
synchronously
"
)
)
;
streamLoader
-
>
ChannelOpenFailed
(
rv
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
channel
-
>
SetContentCharset
(
"
UTF
-
8
"
_ns
)
;
return
nsSyncLoadService
:
:
PushSyncStreamToListener
(
stream
.
forget
(
)
streamLoader
channel
)
;
}
SheetLoadDataHashKey
key
(
aLoadData
)
;
auto
preloadKey
=
PreloadHashKey
:
:
CreateAsStyle
(
aLoadData
)
;
bool
coalescedLoad
=
false
;
if
(
mSheets
)
{
if
(
aSheetState
=
=
SheetState
:
:
NeedsParser
&
&
aPendingLoad
=
=
PendingLoad
:
:
No
&
&
aLoadData
.
ShouldDefer
(
)
&
&
mOngoingLoadCount
>
mPendingLoadCount
+
1
)
{
LOG
(
(
"
Deferring
sheet
load
"
)
)
;
+
+
mPendingLoadCount
;
mSheets
-
>
DeferLoad
(
key
aLoadData
)
;
return
NS_OK
;
}
auto
cacheState
=
[
&
aSheetState
]
{
switch
(
aSheetState
)
{
case
SheetState
:
:
Complete
:
return
CachedSubResourceState
:
:
Complete
;
case
SheetState
:
:
Pending
:
return
CachedSubResourceState
:
:
Pending
;
case
SheetState
:
:
Loading
:
return
CachedSubResourceState
:
:
Loading
;
case
SheetState
:
:
NeedsParser
:
return
CachedSubResourceState
:
:
Miss
;
}
MOZ_ASSERT_UNREACHABLE
(
"
wat
"
)
;
return
CachedSubResourceState
:
:
Miss
;
}
(
)
;
if
(
(
coalescedLoad
=
mSheets
-
>
CoalesceLoad
(
key
aLoadData
cacheState
)
)
)
{
if
(
aSheetState
=
=
SheetState
:
:
Pending
)
{
+
+
mPendingLoadCount
;
return
NS_OK
;
}
}
}
aLoadData
.
NotifyOpen
(
preloadKey
mDocument
aLoadData
.
IsLinkRelPreload
(
)
)
;
if
(
coalescedLoad
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
;
if
(
mDocument
)
{
loadGroup
=
mDocument
-
>
GetDocumentLoadGroup
(
)
;
if
(
!
loadGroup
)
{
LOG_ERROR
(
(
"
Failed
to
query
loadGroup
from
document
"
)
)
;
SheetComplete
(
aLoadData
NS_ERROR_UNEXPECTED
)
;
return
NS_ERROR_UNEXPECTED
;
}
cookieJarSettings
=
mDocument
-
>
CookieJarSettings
(
)
;
}
#
ifdef
DEBUG
AutoRestore
<
bool
>
syncCallbackGuard
(
mSyncCallback
)
;
mSyncCallback
=
true
;
#
endif
nsSecurityFlags
securityFlags
=
nsContentSecurityManager
:
:
ComputeSecurityFlags
(
aLoadData
.
mSheet
-
>
GetCORSMode
(
)
nsContentSecurityManager
:
:
CORSSecurityMapping
:
:
CORS_NONE_MAPS_TO_INHERITED_CONTEXT
)
;
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsContentPolicyType
contentPolicyType
=
aLoadData
.
mPreloadKind
=
=
StylePreloadKind
:
:
None
?
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
:
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
requestingNode
)
{
rv
=
NS_NewChannelWithTriggeringPrincipal
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
requestingNode
aLoadData
.
mTriggeringPrincipal
securityFlags
contentPolicyType
nullptr
loadGroup
)
;
}
else
{
MOZ_ASSERT
(
aLoadData
.
mTriggeringPrincipal
-
>
Equals
(
LoaderPrincipal
(
)
)
)
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aLoadData
.
mURI
aLoadData
.
mTriggeringPrincipal
securityFlags
contentPolicyType
cookieJarSettings
nullptr
loadGroup
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
create
channel
"
)
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
)
{
if
(
requestingNode
)
{
nsString
*
cspNonce
=
static_cast
<
nsString
*
>
(
requestingNode
-
>
GetProperty
(
nsGkAtoms
:
:
nonce
)
)
;
if
(
cspNonce
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
loadInfo
-
>
SetCspNonce
(
*
cspNonce
)
;
}
}
}
if
(
!
aLoadData
.
ShouldDefer
(
)
)
{
if
(
nsCOMPtr
<
nsIClassOfService
>
cos
=
do_QueryInterface
(
channel
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Leader
)
;
}
if
(
aLoadData
.
IsLinkRelPreload
(
)
)
{
SheetLoadData
:
:
PrioritizeAsPreload
(
channel
)
;
SheetLoadData
:
:
AddLoadBackgroundFlag
(
channel
)
;
}
}
if
(
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
channel
)
)
{
if
(
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
aLoadData
.
ReferrerInfo
(
)
)
{
rv
=
httpChannel
-
>
SetReferrerInfo
(
referrerInfo
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
internalChannel
)
{
rv
=
internalChannel
-
>
SetIntegrityMetadata
(
sriMetadata
.
GetIntegrityString
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
nsCOMPtr
<
nsITimedChannel
>
timedChannel
=
do_QueryInterface
(
httpChannel
)
)
{
if
(
aLoadData
.
mParentData
)
{
timedChannel
-
>
SetInitiatorType
(
u
"
css
"
_ns
)
;
if
(
aLoadData
.
mParentData
-
>
mIsCrossOriginNoCORS
|
|
aLoadData
.
mParentData
-
>
mBlockResourceTiming
)
{
aLoadData
.
mBlockResourceTiming
=
true
;
timedChannel
-
>
SetReportResourceTiming
(
false
)
;
}
}
else
if
(
aEarlyHintPreloaderId
)
{
timedChannel
-
>
SetInitiatorType
(
u
"
early
-
hints
"
_ns
)
;
}
else
{
timedChannel
-
>
SetInitiatorType
(
u
"
link
"
_ns
)
;
}
}
}
channel
-
>
SetContentType
(
"
text
/
css
"
_ns
)
;
auto
streamLoader
=
MakeRefPtr
<
StreamLoader
>
(
aLoadData
)
;
if
(
mDocument
)
{
net
:
:
PredictorLearn
(
aLoadData
.
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
mDocument
)
;
}
if
(
aEarlyHintPreloaderId
)
{
nsCOMPtr
<
nsIHttpChannelInternal
>
channelInternal
=
do_QueryInterface
(
channel
)
;
NS_ENSURE_TRUE
(
channelInternal
!
=
nullptr
NS_ERROR_FAILURE
)
;
rv
=
channelInternal
-
>
SetEarlyHintPreloaderId
(
aEarlyHintPreloaderId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
channel
-
>
AsyncOpen
(
streamLoader
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
create
stream
loader
"
)
)
;
streamLoader
-
>
ChannelOpenFailed
(
rv
)
;
aLoadData
.
NotifyStart
(
channel
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
nsCOMPtr
<
nsIHttpChannelInternal
>
hci
=
do_QueryInterface
(
channel
)
)
{
hci
-
>
DoDiagnosticAssertWhenOnStopNotCalledOnDestroy
(
)
;
}
#
endif
if
(
mSheets
)
{
mSheets
-
>
LoadStarted
(
key
aLoadData
)
;
}
return
NS_OK
;
}
Loader
:
:
Completed
Loader
:
:
ParseSheet
(
const
nsACString
&
aBytes
SheetLoadData
&
aLoadData
AllowAsyncParse
aAllowAsync
)
{
LOG
(
(
"
css
:
:
Loader
:
:
ParseSheet
"
)
)
;
if
(
aLoadData
.
mURI
)
{
LOG_URI
(
"
Load
succeeded
for
URI
:
'
%
s
'
parsing
"
aLoadData
.
mURI
)
;
}
AUTO_PROFILER_LABEL_CATEGORY_PAIR_RELEVANT_FOR_JS
(
LAYOUT_CSSParsing
)
;
+
+
mParsedSheetCount
;
aLoadData
.
mIsBeingParsed
=
true
;
StyleSheet
*
sheet
=
aLoadData
.
mSheet
;
MOZ_ASSERT
(
sheet
)
;
if
(
aLoadData
.
mSyncLoad
|
|
aAllowAsync
=
=
AllowAsyncParse
:
:
No
)
{
sheet
-
>
ParseSheetSync
(
this
aBytes
&
aLoadData
aLoadData
.
mLineNumber
)
;
aLoadData
.
mIsBeingParsed
=
false
;
bool
noPendingChildren
=
aLoadData
.
mPendingChildren
=
=
0
;
MOZ_ASSERT_IF
(
aLoadData
.
mSyncLoad
noPendingChildren
)
;
if
(
noPendingChildren
)
{
SheetComplete
(
aLoadData
NS_OK
)
;
return
Completed
:
:
Yes
;
}
return
Completed
:
:
No
;
}
nsCOMPtr
<
nsISerialEventTarget
>
target
=
DispatchTarget
(
)
;
sheet
-
>
ParseSheet
(
*
this
aBytes
aLoadData
)
-
>
Then
(
target
__func__
[
loadData
=
RefPtr
<
SheetLoadData
>
(
&
aLoadData
)
]
(
bool
aDummy
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
loadData
-
>
SheetFinishedParsingAsync
(
)
;
}
[
]
{
MOZ_CRASH
(
"
rejected
parse
promise
"
)
;
}
)
;
return
Completed
:
:
No
;
}
void
Loader
:
:
NotifyObservers
(
SheetLoadData
&
aData
nsresult
aStatus
)
{
RecordUseCountersIfNeeded
(
mDocument
aData
.
mSheet
-
>
GetStyleUseCounters
(
)
)
;
if
(
aData
.
mURI
)
{
mLoadsPerformed
.
PutEntry
(
SheetLoadDataHashKey
(
aData
)
)
;
aData
.
NotifyStop
(
aStatus
)
;
if
(
aData
.
BlocksLoadEvent
(
)
)
{
DecrementOngoingLoadCount
(
)
;
}
}
if
(
aData
.
mMustNotify
)
{
if
(
nsCOMPtr
<
nsICSSLoaderObserver
>
observer
=
std
:
:
move
(
aData
.
mObserver
)
)
{
LOG
(
(
"
Notifying
observer
%
p
for
data
%
p
.
deferred
:
%
d
"
observer
.
get
(
)
&
aData
aData
.
ShouldDefer
(
)
)
)
;
observer
-
>
StyleSheetLoaded
(
aData
.
mSheet
aData
.
ShouldDefer
(
)
aStatus
)
;
}
for
(
nsCOMPtr
<
nsICSSLoaderObserver
>
obs
:
mObservers
.
ForwardRange
(
)
)
{
LOG
(
(
"
Notifying
global
observer
%
p
for
data
%
p
.
deferred
:
%
d
"
obs
.
get
(
)
&
aData
aData
.
ShouldDefer
(
)
)
)
;
obs
-
>
StyleSheetLoaded
(
aData
.
mSheet
aData
.
ShouldDefer
(
)
aStatus
)
;
}
}
if
(
mPendingLoadCount
&
&
mPendingLoadCount
=
=
mOngoingLoadCount
)
{
LOG
(
(
"
No
more
loading
sheets
;
starting
deferred
loads
"
)
)
;
StartDeferredLoads
(
)
;
}
}
void
Loader
:
:
SheetComplete
(
SheetLoadData
&
aLoadData
nsresult
aStatus
)
{
LOG
(
(
"
css
:
:
Loader
:
:
SheetComplete
status
:
0x
%
"
PRIx32
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
SharedStyleSheetCache
:
:
LoadCompleted
(
mSheets
.
get
(
)
aLoadData
aStatus
)
;
}
void
Loader
:
:
MarkLoadTreeFailed
(
SheetLoadData
&
aLoadData
Loader
*
aOnlyForLoader
)
{
if
(
aLoadData
.
mURI
)
{
LOG_URI
(
"
Load
failed
:
'
%
s
'
"
aLoadData
.
mURI
)
;
}
SheetLoadData
*
data
=
&
aLoadData
;
do
{
if
(
!
aOnlyForLoader
|
|
aOnlyForLoader
=
=
data
-
>
mLoader
)
{
data
-
>
mLoadFailed
=
true
;
data
-
>
mSheet
-
>
MaybeRejectReplacePromise
(
)
;
}
if
(
data
-
>
mParentData
)
{
MarkLoadTreeFailed
(
*
data
-
>
mParentData
aOnlyForLoader
)
;
}
data
=
data
-
>
mNext
;
}
while
(
data
)
;
}
RefPtr
<
StyleSheet
>
Loader
:
:
LookupInlineSheetInCache
(
const
nsAString
&
aBuffer
)
{
auto
result
=
mInlineSheets
.
Lookup
(
aBuffer
)
;
if
(
!
result
)
{
return
nullptr
;
}
if
(
result
.
Data
(
)
-
>
HasModifiedRules
(
)
)
{
result
.
Remove
(
)
;
return
nullptr
;
}
return
result
.
Data
(
)
-
>
Clone
(
nullptr
nullptr
)
;
}
void
Loader
:
:
MaybeNotifyPreloadUsed
(
SheetLoadData
&
aData
)
{
if
(
!
mDocument
)
{
return
;
}
auto
key
=
PreloadHashKey
:
:
CreateAsStyle
(
aData
)
;
RefPtr
<
PreloaderBase
>
preload
=
mDocument
-
>
Preloads
(
)
.
LookupPreload
(
key
)
;
if
(
!
preload
)
{
return
;
}
preload
-
>
NotifyUsage
(
)
;
}
Result
<
Loader
:
:
LoadSheetResult
nsresult
>
Loader
:
:
LoadInlineStyle
(
const
SheetInfo
&
aInfo
const
nsAString
&
aBuffer
uint32_t
aLineNumber
nsICSSLoaderObserver
*
aObserver
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadInlineStyle
"
)
)
;
MOZ_ASSERT
(
aInfo
.
mContent
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
!
mDocument
)
{
return
Err
(
NS_ERROR_NOT_INITIALIZED
)
;
}
MOZ_ASSERT
(
LinkStyle
:
:
FromNodeOrNull
(
aInfo
.
mContent
)
"
Element
is
not
a
style
linking
element
!
"
)
;
auto
isAlternate
=
IsAlternateSheet
(
aInfo
.
mTitle
aInfo
.
mHasAlternateRel
)
;
LOG
(
(
"
Sheet
is
alternate
:
%
d
"
static_cast
<
int
>
(
isAlternate
)
)
)
;
nsIURI
*
baseURI
=
aInfo
.
mContent
-
>
GetBaseURI
(
)
;
nsIURI
*
sheetURI
=
aInfo
.
mContent
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
;
nsIURI
*
originalURI
=
nullptr
;
MOZ_ASSERT
(
aInfo
.
mIntegrity
.
IsEmpty
(
)
)
;
nsIPrincipal
*
loadingPrincipal
=
LoaderPrincipal
(
)
;
nsIPrincipal
*
principal
=
aInfo
.
mTriggeringPrincipal
?
aInfo
.
mTriggeringPrincipal
.
get
(
)
:
loadingPrincipal
;
const
bool
isWorthCaching
=
aInfo
.
mContent
-
>
IsInShadowTree
(
)
;
RefPtr
<
StyleSheet
>
sheet
;
if
(
isWorthCaching
)
{
sheet
=
LookupInlineSheetInCache
(
aBuffer
)
;
}
const
bool
sheetFromCache
=
!
!
sheet
;
if
(
!
sheet
)
{
sheet
=
MakeRefPtr
<
StyleSheet
>
(
eAuthorSheetFeatures
aInfo
.
mCORSMode
SRIMetadata
{
}
)
;
sheet
-
>
SetURIs
(
sheetURI
originalURI
baseURI
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForInternalCSSResources
(
aInfo
.
mContent
-
>
OwnerDoc
(
)
)
;
sheet
-
>
SetReferrerInfo
(
referrerInfo
)
;
nsIPrincipal
*
sheetPrincipal
=
principal
;
if
(
aInfo
.
mTriggeringPrincipal
)
{
sheetPrincipal
=
BasePrincipal
:
:
Cast
(
aInfo
.
mTriggeringPrincipal
)
-
>
PrincipalToInherit
(
)
;
}
sheet
-
>
SetPrincipal
(
sheetPrincipal
)
;
}
auto
matched
=
PrepareSheet
(
*
sheet
aInfo
.
mTitle
aInfo
.
mMedia
nullptr
isAlternate
aInfo
.
mIsExplicitlyEnabled
)
;
if
(
auto
*
linkStyle
=
LinkStyle
:
:
FromNodeOrNull
(
aInfo
.
mContent
)
)
{
linkStyle
-
>
SetStyleSheet
(
sheet
)
;
}
if
(
sheet
-
>
IsComplete
(
)
)
{
MOZ_ASSERT
(
sheet
-
>
GetOwnerNode
(
)
=
=
aInfo
.
mContent
)
;
InsertSheetInTree
(
*
sheet
)
;
}
Completed
completed
;
if
(
sheetFromCache
)
{
MOZ_ASSERT
(
sheet
-
>
IsComplete
(
)
)
;
completed
=
Completed
:
:
Yes
;
}
else
{
auto
data
=
MakeRefPtr
<
SheetLoadData
>
(
this
aInfo
.
mTitle
nullptr
sheet
false
aInfo
.
mContent
isAlternate
matched
StylePreloadKind
:
:
None
aObserver
principal
aInfo
.
mReferrerInfo
)
;
MOZ_ASSERT
(
data
-
>
GetRequestingNode
(
)
=
=
aInfo
.
mContent
)
;
data
-
>
mLineNumber
=
aLineNumber
;
NS_ConvertUTF16toUTF8
utf8
(
aBuffer
)
;
completed
=
ParseSheet
(
utf8
*
data
AllowAsyncParse
:
:
No
)
;
if
(
completed
=
=
Completed
:
:
Yes
)
{
if
(
isWorthCaching
)
{
mInlineSheets
.
InsertOrUpdate
(
aBuffer
std
:
:
move
(
sheet
)
)
;
}
}
else
{
data
-
>
mMustNotify
=
true
;
}
}
return
LoadSheetResult
{
completed
isAlternate
matched
}
;
}
Result
<
Loader
:
:
LoadSheetResult
nsresult
>
Loader
:
:
LoadStyleLink
(
const
SheetInfo
&
aInfo
nsICSSLoaderObserver
*
aObserver
)
{
MOZ_ASSERT
(
aInfo
.
mURI
"
Must
have
URL
to
load
"
)
;
LOG
(
(
"
css
:
:
Loader
:
:
LoadStyleLink
"
)
)
;
LOG_URI
(
"
Link
uri
:
'
%
s
'
"
aInfo
.
mURI
)
;
LOG
(
(
"
Link
title
:
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
aInfo
.
mTitle
)
.
get
(
)
)
)
;
LOG
(
(
"
Link
media
:
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
aInfo
.
mMedia
)
.
get
(
)
)
)
;
LOG
(
(
"
Link
alternate
rel
:
%
d
"
aInfo
.
mHasAlternateRel
)
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
!
mDocument
)
{
return
Err
(
NS_ERROR_NOT_INITIALIZED
)
;
}
MOZ_ASSERT_IF
(
aInfo
.
mContent
aInfo
.
mContent
-
>
NodePrincipal
(
)
=
=
mDocument
-
>
NodePrincipal
(
)
)
;
nsIPrincipal
*
loadingPrincipal
=
LoaderPrincipal
(
)
;
nsIPrincipal
*
principal
=
aInfo
.
mTriggeringPrincipal
?
aInfo
.
mTriggeringPrincipal
.
get
(
)
:
loadingPrincipal
;
nsINode
*
requestingNode
=
aInfo
.
mContent
?
static_cast
<
nsINode
*
>
(
aInfo
.
mContent
)
:
mDocument
;
const
bool
syncLoad
=
[
&
]
{
if
(
!
aInfo
.
mContent
)
{
return
false
;
}
const
bool
privilegedShadowTree
=
aInfo
.
mContent
-
>
IsInUAWidget
(
)
|
|
(
aInfo
.
mContent
-
>
IsInShadowTree
(
)
&
&
aInfo
.
mContent
-
>
IsInChromeDocument
(
)
)
;
if
(
!
privilegedShadowTree
)
{
return
false
;
}
if
(
!
IsPrivilegedURI
(
aInfo
.
mURI
)
)
{
return
false
;
}
return
true
;
}
(
)
;
LOG
(
(
"
Link
sync
load
:
'
%
s
'
"
syncLoad
?
"
true
"
:
"
false
"
)
)
;
MOZ_ASSERT_IF
(
syncLoad
!
aObserver
)
;
nsresult
rv
=
CheckContentPolicy
(
loadingPrincipal
principal
aInfo
.
mURI
requestingNode
aInfo
.
mNonce
StylePreloadKind
:
:
None
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
if
(
aInfo
.
mContent
&
&
!
mDocument
-
>
IsLoadedAsData
(
)
)
{
RefPtr
<
AsyncEventDispatcher
>
loadBlockingAsyncDispatcher
=
new
LoadBlockingAsyncEventDispatcher
(
aInfo
.
mContent
u
"
error
"
_ns
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eNo
)
;
loadBlockingAsyncDispatcher
-
>
PostDOMEvent
(
)
;
}
return
Err
(
rv
)
;
}
auto
isAlternate
=
IsAlternateSheet
(
aInfo
.
mTitle
aInfo
.
mHasAlternateRel
)
;
auto
[
sheet
state
]
=
CreateSheet
(
aInfo
eAuthorSheetFeatures
syncLoad
StylePreloadKind
:
:
None
)
;
LOG
(
(
"
Sheet
is
alternate
:
%
d
"
static_cast
<
int
>
(
isAlternate
)
)
)
;
auto
matched
=
PrepareSheet
(
*
sheet
aInfo
.
mTitle
aInfo
.
mMedia
nullptr
isAlternate
aInfo
.
mIsExplicitlyEnabled
)
;
if
(
auto
*
linkStyle
=
LinkStyle
:
:
FromNodeOrNull
(
aInfo
.
mContent
)
)
{
linkStyle
-
>
SetStyleSheet
(
sheet
)
;
}
if
(
sheet
-
>
IsComplete
(
)
)
{
MOZ_ASSERT
(
sheet
-
>
GetOwnerNode
(
)
=
=
aInfo
.
mContent
)
;
InsertSheetInTree
(
*
sheet
)
;
}
MOZ_ASSERT
(
!
aInfo
.
mContent
|
|
LinkStyle
:
:
FromNode
(
*
aInfo
.
mContent
)
"
If
there
is
any
node
it
should
be
a
LinkStyle
"
)
;
auto
data
=
MakeRefPtr
<
SheetLoadData
>
(
this
aInfo
.
mTitle
aInfo
.
mURI
sheet
syncLoad
aInfo
.
mContent
isAlternate
matched
StylePreloadKind
:
:
None
aObserver
principal
aInfo
.
mReferrerInfo
)
;
MOZ_ASSERT
(
data
-
>
GetRequestingNode
(
)
=
=
requestingNode
)
;
MaybeNotifyPreloadUsed
(
*
data
)
;
if
(
state
=
=
SheetState
:
:
Complete
)
{
LOG
(
(
"
Sheet
already
complete
:
0x
%
p
"
sheet
.
get
(
)
)
)
;
if
(
aObserver
|
|
!
mObservers
.
IsEmpty
(
)
|
|
aInfo
.
mContent
)
{
rv
=
PostLoadEvent
(
std
:
:
move
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
}
else
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
data
-
>
mIntentionallyDropped
=
true
;
#
endif
}
return
LoadSheetResult
{
Completed
:
:
No
isAlternate
matched
}
;
}
auto
result
=
LoadSheetResult
{
Completed
:
:
No
isAlternate
matched
}
;
MOZ_ASSERT
(
result
.
ShouldBlock
(
)
=
=
!
data
-
>
ShouldDefer
(
)
"
These
should
better
match
!
"
)
;
rv
=
LoadSheet
(
*
data
state
0
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
if
(
!
syncLoad
)
{
data
-
>
mMustNotify
=
true
;
}
return
result
;
}
static
bool
HaveAncestorDataWithURI
(
SheetLoadData
&
aData
nsIURI
*
aURI
)
{
if
(
!
aData
.
mURI
)
{
MOZ_ASSERT
(
!
aData
.
mParentData
"
How
does
inline
style
have
a
parent
?
"
)
;
return
false
;
}
bool
equal
;
if
(
NS_FAILED
(
aData
.
mURI
-
>
Equals
(
aURI
&
equal
)
)
|
|
equal
)
{
return
true
;
}
SheetLoadData
*
data
=
&
aData
;
do
{
if
(
data
-
>
mParentData
&
&
HaveAncestorDataWithURI
(
*
data
-
>
mParentData
aURI
)
)
{
return
true
;
}
data
=
data
-
>
mNext
;
}
while
(
data
)
;
return
false
;
}
nsresult
Loader
:
:
LoadChildSheet
(
StyleSheet
&
aParentSheet
SheetLoadData
*
aParentData
nsIURI
*
aURL
dom
:
:
MediaList
*
aMedia
LoaderReusableStyleSheets
*
aReusableSheets
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadChildSheet
"
)
)
;
MOZ_ASSERT
(
aURL
"
Must
have
a
URI
to
load
"
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
LOG_URI
(
"
Child
uri
:
'
%
s
'
"
aURL
)
;
nsCOMPtr
<
nsINode
>
owningNode
;
nsINode
*
requestingNode
=
aParentSheet
.
GetOwnerNodeOfOutermostSheet
(
)
;
if
(
requestingNode
)
{
MOZ_ASSERT
(
LoaderPrincipal
(
)
=
=
requestingNode
-
>
NodePrincipal
(
)
)
;
}
else
{
requestingNode
=
mDocument
;
}
nsIPrincipal
*
principal
=
aParentSheet
.
Principal
(
)
;
nsresult
rv
=
CheckContentPolicy
(
LoaderPrincipal
(
)
principal
aURL
requestingNode
u
"
"
_ns
StylePreloadKind
:
:
None
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
if
(
aParentData
)
{
MarkLoadTreeFailed
(
*
aParentData
)
;
}
return
rv
;
}
nsCOMPtr
<
nsICSSLoaderObserver
>
observer
;
if
(
aParentData
)
{
LOG
(
(
"
Have
a
parent
load
"
)
)
;
if
(
HaveAncestorDataWithURI
(
*
aParentData
aURL
)
)
{
LOG_ERROR
(
(
"
import
cycle
detected
dropping
load
"
)
)
;
return
NS_OK
;
}
NS_ASSERTION
(
aParentData
-
>
mSheet
=
=
&
aParentSheet
"
Unexpected
call
to
LoadChildSheet
"
)
;
}
else
{
LOG
(
(
"
No
parent
load
;
must
be
CSSOM
"
)
)
;
observer
=
&
aParentSheet
;
}
RefPtr
<
StyleSheet
>
sheet
;
SheetState
state
;
if
(
aReusableSheets
&
&
aReusableSheets
-
>
FindReusableStyleSheet
(
aURL
sheet
)
)
{
state
=
SheetState
:
:
Complete
;
}
else
{
std
:
:
tie
(
sheet
state
)
=
CreateSheet
(
aURL
nullptr
principal
aParentSheet
.
ParsingMode
(
)
CORS_NONE
aParentData
?
aParentData
-
>
mEncoding
:
nullptr
u
"
"
_ns
aParentData
&
&
aParentData
-
>
mSyncLoad
StylePreloadKind
:
:
None
)
;
PrepareSheet
(
*
sheet
u
"
"
_ns
u
"
"
_ns
aMedia
IsAlternate
:
:
No
IsExplicitlyEnabled
:
:
No
)
;
}
MOZ_ASSERT
(
sheet
)
;
InsertChildSheet
(
*
sheet
aParentSheet
)
;
auto
data
=
MakeRefPtr
<
SheetLoadData
>
(
this
aURL
sheet
aParentData
observer
principal
aParentSheet
.
GetReferrerInfo
(
)
)
;
MOZ_ASSERT
(
data
-
>
GetRequestingNode
(
)
=
=
requestingNode
)
;
MaybeNotifyPreloadUsed
(
*
data
)
;
if
(
state
=
=
SheetState
:
:
Complete
)
{
LOG
(
(
"
Sheet
already
complete
"
)
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
data
-
>
mIntentionallyDropped
=
true
;
#
endif
return
NS_OK
;
}
bool
syncLoad
=
data
-
>
mSyncLoad
;
rv
=
LoadSheet
(
*
data
state
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
syncLoad
)
{
data
-
>
mMustNotify
=
true
;
}
return
rv
;
}
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
Loader
:
:
LoadSheetSync
(
nsIURI
*
aURL
SheetParsingMode
aParsingMode
UseSystemPrincipal
aUseSystemPrincipal
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheetSync
"
)
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
nullptr
)
;
return
InternalLoadNonDocumentSheet
(
aURL
StylePreloadKind
:
:
None
aParsingMode
aUseSystemPrincipal
nullptr
referrerInfo
nullptr
CORS_NONE
u
"
"
_ns
0
)
;
}
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
Loader
:
:
LoadSheet
(
nsIURI
*
aURI
SheetParsingMode
aParsingMode
UseSystemPrincipal
aUseSystemPrincipal
nsICSSLoaderObserver
*
aObserver
)
{
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
nullptr
)
;
return
InternalLoadNonDocumentSheet
(
aURI
StylePreloadKind
:
:
None
aParsingMode
aUseSystemPrincipal
nullptr
referrerInfo
aObserver
CORS_NONE
u
"
"
_ns
0
)
;
}
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
Loader
:
:
LoadSheet
(
nsIURI
*
aURL
StylePreloadKind
aPreloadKind
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
uint64_t
aEarlyHintPreloaderId
CORSMode
aCORSMode
const
nsAString
&
aIntegrity
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheet
(
aURL
aObserver
)
api
call
"
)
)
;
return
InternalLoadNonDocumentSheet
(
aURL
aPreloadKind
eAuthorSheetFeatures
UseSystemPrincipal
:
:
No
aPreloadEncoding
aReferrerInfo
aObserver
aCORSMode
aIntegrity
aEarlyHintPreloaderId
)
;
}
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
Loader
:
:
InternalLoadNonDocumentSheet
(
nsIURI
*
aURL
StylePreloadKind
aPreloadKind
SheetParsingMode
aParsingMode
UseSystemPrincipal
aUseSystemPrincipal
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
CORSMode
aCORSMode
const
nsAString
&
aIntegrity
uint64_t
aEarlyHintPreloaderId
)
{
MOZ_ASSERT
(
aURL
"
Must
have
a
URI
to
load
"
)
;
MOZ_ASSERT
(
aUseSystemPrincipal
=
=
UseSystemPrincipal
:
:
No
|
|
!
aObserver
"
Shouldn
'
t
load
system
-
principal
sheets
async
"
)
;
MOZ_ASSERT
(
aReferrerInfo
"
Must
have
referrerInfo
"
)
;
LOG_URI
(
"
Non
-
document
sheet
uri
:
'
%
s
'
"
aURL
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
nsIPrincipal
*
loadingPrincipal
=
LoaderPrincipal
(
)
;
nsIPrincipal
*
triggeringPrincipal
=
loadingPrincipal
;
nsresult
rv
=
CheckContentPolicy
(
loadingPrincipal
triggeringPrincipal
aURL
mDocument
u
"
"
_ns
aPreloadKind
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
bool
syncLoad
=
!
aObserver
;
auto
[
sheet
state
]
=
CreateSheet
(
aURL
nullptr
triggeringPrincipal
aParsingMode
aCORSMode
aPreloadEncoding
aIntegrity
syncLoad
aPreloadKind
)
;
PrepareSheet
(
*
sheet
u
"
"
_ns
u
"
"
_ns
nullptr
IsAlternate
:
:
No
IsExplicitlyEnabled
:
:
No
)
;
auto
data
=
MakeRefPtr
<
SheetLoadData
>
(
this
aURL
sheet
syncLoad
aUseSystemPrincipal
aPreloadKind
aPreloadEncoding
aObserver
triggeringPrincipal
aReferrerInfo
)
;
MOZ_ASSERT
(
data
-
>
GetRequestingNode
(
)
=
=
mDocument
)
;
if
(
state
=
=
SheetState
:
:
Complete
)
{
LOG
(
(
"
Sheet
already
complete
"
)
)
;
if
(
aObserver
|
|
!
mObservers
.
IsEmpty
(
)
)
{
rv
=
PostLoadEvent
(
std
:
:
move
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
}
else
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
data
-
>
mIntentionallyDropped
=
true
;
#
endif
}
return
sheet
;
}
rv
=
LoadSheet
(
*
data
state
aEarlyHintPreloaderId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
if
(
aObserver
)
{
data
-
>
mMustNotify
=
true
;
}
return
sheet
;
}
nsresult
Loader
:
:
PostLoadEvent
(
RefPtr
<
SheetLoadData
>
aLoadData
)
{
LOG
(
(
"
css
:
:
Loader
:
:
PostLoadEvent
"
)
)
;
mPostedEvents
.
AppendElement
(
aLoadData
)
;
nsresult
rv
;
RefPtr
<
SheetLoadData
>
runnable
(
aLoadData
)
;
if
(
mDocument
)
{
rv
=
mDocument
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
else
if
(
mDocGroup
)
{
rv
=
mDocGroup
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
else
{
rv
=
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
dispatch
stylesheet
load
event
"
)
;
mPostedEvents
.
RemoveElement
(
aLoadData
)
;
}
else
{
if
(
aLoadData
-
>
BlocksLoadEvent
(
)
)
{
IncrementOngoingLoadCount
(
)
;
}
aLoadData
-
>
mMustNotify
=
true
;
aLoadData
-
>
mSheetAlreadyComplete
=
true
;
MOZ_ASSERT
(
!
aLoadData
-
>
mLoadFailed
"
Why
are
we
marked
as
failed
?
"
)
;
aLoadData
-
>
ScheduleLoadEventIfNeeded
(
)
;
}
return
rv
;
}
void
Loader
:
:
HandleLoadEvent
(
SheetLoadData
&
aEvent
)
{
NS_ASSERTION
(
aEvent
.
mSheet
"
Must
have
sheet
"
)
;
mPostedEvents
.
RemoveElement
(
&
aEvent
)
;
SheetComplete
(
aEvent
NS_OK
)
;
}
void
Loader
:
:
Stop
(
)
{
if
(
mSheets
)
{
mSheets
-
>
CancelLoadsForLoader
(
*
this
)
;
}
auto
arr
=
std
:
:
move
(
mPostedEvents
)
;
for
(
auto
&
data
:
arr
)
{
data
-
>
Cancel
(
)
;
}
}
bool
Loader
:
:
HasPendingLoads
(
)
{
return
mOngoingLoadCount
;
}
void
Loader
:
:
AddObserver
(
nsICSSLoaderObserver
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
"
Must
have
observer
"
)
;
mObservers
.
AppendElementUnlessExists
(
aObserver
)
;
}
void
Loader
:
:
RemoveObserver
(
nsICSSLoaderObserver
*
aObserver
)
{
mObservers
.
RemoveElement
(
aObserver
)
;
}
void
Loader
:
:
StartDeferredLoads
(
)
{
if
(
mSheets
&
&
mPendingLoadCount
)
{
mSheets
-
>
StartPendingLoadsForLoader
(
*
this
[
]
(
const
SheetLoadData
&
)
{
return
true
;
}
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Loader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Loader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSheets
)
;
for
(
const
auto
&
data
:
tmp
-
>
mInlineSheets
.
Values
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
Inline
sheet
cache
in
Loader
"
)
;
cb
.
NoteXPCOMChild
(
data
)
;
}
for
(
nsCOMPtr
<
nsICSSLoaderObserver
>
&
obs
:
tmp
-
>
mObservers
.
ForwardRange
(
)
)
{
ImplCycleCollectionTraverse
(
cb
obs
"
mozilla
:
:
css
:
:
Loader
.
mObservers
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocGroup
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Loader
)
if
(
tmp
-
>
mSheets
)
{
if
(
tmp
-
>
mDocument
)
{
tmp
-
>
DeregisterFromSheetCache
(
)
;
}
tmp
-
>
mSheets
=
nullptr
;
}
tmp
-
>
mInlineSheets
.
Clear
(
)
;
tmp
-
>
mObservers
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocGroup
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
size_t
Loader
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mObservers
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
n
+
=
mInlineSheets
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
entry
:
mInlineSheets
)
{
n
+
=
entry
.
GetKey
(
)
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
const
StyleSheet
*
sheet
=
entry
.
GetWeak
(
)
;
MOZ_ASSERT
(
!
sheet
-
>
GetParentSheet
(
)
"
How
did
an
import
rule
end
up
here
?
"
)
;
if
(
!
sheet
-
>
GetOwnerNode
(
)
)
{
n
+
=
sheet
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
return
n
;
}
nsIPrincipal
*
Loader
:
:
LoaderPrincipal
(
)
const
{
if
(
mDocument
)
{
return
mDocument
-
>
NodePrincipal
(
)
;
}
return
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
}
nsIPrincipal
*
Loader
:
:
PartitionedPrincipal
(
)
const
{
if
(
mDocument
&
&
StaticPrefs
:
:
privacy_partition_network_state
(
)
)
{
return
mDocument
-
>
PartitionedPrincipal
(
)
;
}
return
LoaderPrincipal
(
)
;
}
bool
Loader
:
:
ShouldBypassCache
(
)
const
{
if
(
!
mDocument
)
{
return
false
;
}
RefPtr
<
nsILoadGroup
>
lg
=
mDocument
-
>
GetDocumentLoadGroup
(
)
;
if
(
!
lg
)
{
return
false
;
}
nsLoadFlags
flags
;
if
(
NS_FAILED
(
lg
-
>
GetLoadFlags
(
&
flags
)
)
)
{
return
false
;
}
return
flags
&
(
nsIRequest
:
:
LOAD_BYPASS_CACHE
|
nsICachingChannel
:
:
LOAD_BYPASS_LOCAL_CACHE
)
;
}
void
Loader
:
:
BlockOnload
(
)
{
if
(
mDocument
)
{
mDocument
-
>
BlockOnload
(
)
;
}
}
void
Loader
:
:
UnblockOnload
(
bool
aFireSync
)
{
if
(
mDocument
)
{
mDocument
-
>
UnblockOnload
(
aFireSync
)
;
}
}
already_AddRefed
<
nsISerialEventTarget
>
Loader
:
:
DispatchTarget
(
)
{
nsCOMPtr
<
nsISerialEventTarget
>
target
;
if
(
mDocument
)
{
target
=
mDocument
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
}
else
if
(
mDocGroup
)
{
target
=
mDocGroup
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
}
else
{
target
=
GetMainThreadSerialEventTarget
(
)
;
}
return
target
.
forget
(
)
;
}
}
}
