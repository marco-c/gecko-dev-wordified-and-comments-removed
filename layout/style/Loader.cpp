#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
URLPreloader
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIUnicharStreamLoader
.
h
"
#
include
"
nsSyncLoadService
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIStyleSheetLinkingElement
.
h
"
#
include
"
nsICSSLoaderObserver
.
h
"
#
include
"
nsCSSParser
.
h
"
#
include
"
mozilla
/
css
/
ImportRule
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
dom
/
MediaList
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
URL
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
ConsoleReportCollector
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
css
/
StreamLoader
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULPrototypeCache
.
h
"
#
endif
#
include
"
nsError
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
mozilla
/
dom
/
SRICheck
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
using
namespace
mozilla
:
:
dom
;
#
define
SNIFFING_BUFFER_SIZE
1024
namespace
mozilla
{
namespace
css
{
#
include
"
mozilla
/
Logging
.
h
"
static
mozilla
:
:
LazyLogModule
sCssLoaderLog
(
"
nsCSSLoader
"
)
;
static
mozilla
:
:
LazyLogModule
gSriPRLog
(
"
SRI
"
)
;
#
define
LOG_ERROR
(
args
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Error
args
)
#
define
LOG_WARN
(
args
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Warning
args
)
#
define
LOG_DEBUG
(
args
)
MOZ_LOG
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG
(
args
)
LOG_DEBUG
(
args
)
#
define
LOG_ERROR_ENABLED
(
)
MOZ_LOG_TEST
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Error
)
#
define
LOG_WARN_ENABLED
(
)
MOZ_LOG_TEST
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Warning
)
#
define
LOG_DEBUG_ENABLED
(
)
MOZ_LOG_TEST
(
sCssLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
)
#
define
LOG_ENABLED
(
)
LOG_DEBUG_ENABLED
(
)
#
define
LOG_URI
(
format
uri
)
\
PR_BEGIN_MACRO
\
NS_ASSERTION
(
uri
"
Logging
null
uri
"
)
;
\
if
(
LOG_ENABLED
(
)
)
{
\
LOG
(
(
format
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
\
}
\
PR_END_MACRO
static
const
char
*
const
gStateStrings
[
]
=
{
"
eSheetStateUnknown
"
"
eSheetNeedsParser
"
"
eSheetPending
"
"
eSheetLoading
"
"
eSheetComplete
"
}
;
NS_IMPL_ISUPPORTS
(
SheetLoadData
nsIUnicharStreamLoaderObserver
nsIRunnable
nsIThreadObserver
)
SheetLoadData
:
:
SheetLoadData
(
Loader
*
aLoader
const
nsAString
&
aTitle
nsIURI
*
aURI
StyleSheet
*
aSheet
nsIStyleSheetLinkingElement
*
aOwningElement
bool
aIsAlternate
nsICSSLoaderObserver
*
aObserver
nsIPrincipal
*
aLoaderPrincipal
nsINode
*
aRequestingNode
)
:
mLoader
(
aLoader
)
mTitle
(
aTitle
)
mEncoding
(
nullptr
)
mURI
(
aURI
)
mLineNumber
(
1
)
mSheet
(
aSheet
)
mNext
(
nullptr
)
mPendingChildren
(
0
)
mSyncLoad
(
false
)
mIsNonDocumentSheet
(
false
)
mIsLoading
(
false
)
mIsCancelled
(
false
)
mMustNotify
(
false
)
mWasAlternate
(
aIsAlternate
)
mUseSystemPrincipal
(
false
)
mSheetAlreadyComplete
(
false
)
mIsCrossOriginNoCORS
(
false
)
mBlockResourceTiming
(
false
)
mOwningElement
(
aOwningElement
)
mObserver
(
aObserver
)
mLoaderPrincipal
(
aLoaderPrincipal
)
mRequestingNode
(
aRequestingNode
)
mPreloadEncoding
(
nullptr
)
{
NS_PRECONDITION
(
mLoader
"
Must
have
a
loader
!
"
)
;
}
SheetLoadData
:
:
SheetLoadData
(
Loader
*
aLoader
nsIURI
*
aURI
StyleSheet
*
aSheet
SheetLoadData
*
aParentData
nsICSSLoaderObserver
*
aObserver
nsIPrincipal
*
aLoaderPrincipal
nsINode
*
aRequestingNode
)
:
mLoader
(
aLoader
)
mEncoding
(
nullptr
)
mURI
(
aURI
)
mLineNumber
(
1
)
mSheet
(
aSheet
)
mNext
(
nullptr
)
mParentData
(
aParentData
)
mPendingChildren
(
0
)
mSyncLoad
(
false
)
mIsNonDocumentSheet
(
false
)
mIsLoading
(
false
)
mIsCancelled
(
false
)
mMustNotify
(
false
)
mWasAlternate
(
false
)
mUseSystemPrincipal
(
false
)
mSheetAlreadyComplete
(
false
)
mIsCrossOriginNoCORS
(
false
)
mBlockResourceTiming
(
false
)
mOwningElement
(
nullptr
)
mObserver
(
aObserver
)
mLoaderPrincipal
(
aLoaderPrincipal
)
mRequestingNode
(
aRequestingNode
)
mPreloadEncoding
(
nullptr
)
{
NS_PRECONDITION
(
mLoader
"
Must
have
a
loader
!
"
)
;
if
(
mParentData
)
{
mSyncLoad
=
mParentData
-
>
mSyncLoad
;
mIsNonDocumentSheet
=
mParentData
-
>
mIsNonDocumentSheet
;
mUseSystemPrincipal
=
mParentData
-
>
mUseSystemPrincipal
;
+
+
(
mParentData
-
>
mPendingChildren
)
;
}
MOZ_ASSERT
(
!
mUseSystemPrincipal
|
|
mSyncLoad
"
Shouldn
'
t
use
system
principal
for
async
loads
"
)
;
}
SheetLoadData
:
:
SheetLoadData
(
Loader
*
aLoader
nsIURI
*
aURI
StyleSheet
*
aSheet
bool
aSyncLoad
bool
aUseSystemPrincipal
const
Encoding
*
aPreloadEncoding
nsICSSLoaderObserver
*
aObserver
nsIPrincipal
*
aLoaderPrincipal
nsINode
*
aRequestingNode
)
:
mLoader
(
aLoader
)
mEncoding
(
nullptr
)
mURI
(
aURI
)
mLineNumber
(
1
)
mSheet
(
aSheet
)
mNext
(
nullptr
)
mPendingChildren
(
0
)
mSyncLoad
(
aSyncLoad
)
mIsNonDocumentSheet
(
true
)
mIsLoading
(
false
)
mIsCancelled
(
false
)
mMustNotify
(
false
)
mWasAlternate
(
false
)
mUseSystemPrincipal
(
aUseSystemPrincipal
)
mSheetAlreadyComplete
(
false
)
mIsCrossOriginNoCORS
(
false
)
mBlockResourceTiming
(
false
)
mOwningElement
(
nullptr
)
mObserver
(
aObserver
)
mLoaderPrincipal
(
aLoaderPrincipal
)
mRequestingNode
(
aRequestingNode
)
mPreloadEncoding
(
aPreloadEncoding
)
{
NS_PRECONDITION
(
mLoader
"
Must
have
a
loader
!
"
)
;
MOZ_ASSERT
(
!
mUseSystemPrincipal
|
|
mSyncLoad
"
Shouldn
'
t
use
system
principal
for
async
loads
"
)
;
}
SheetLoadData
:
:
~
SheetLoadData
(
)
{
NS_CSS_NS_RELEASE_LIST_MEMBER
(
SheetLoadData
this
mNext
)
;
}
NS_IMETHODIMP
SheetLoadData
:
:
Run
(
)
{
mLoader
-
>
HandleLoadEvent
(
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SheetLoadData
:
:
OnDispatchedEvent
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
SheetLoadData
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aMayWait
)
{
FireLoadEvent
(
aThread
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SheetLoadData
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aEventWasProcessed
)
{
FireLoadEvent
(
aThread
)
;
return
NS_OK
;
}
void
SheetLoadData
:
:
FireLoadEvent
(
nsIThreadInternal
*
aThread
)
{
RefPtr
<
SheetLoadData
>
kungFuDeathGrip
(
this
)
;
aThread
-
>
RemoveObserver
(
this
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
mOwningElement
)
;
NS_ASSERTION
(
node
"
How
did
that
happen
?
?
?
"
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
node
-
>
OwnerDoc
(
)
node
NS_SUCCEEDED
(
mStatus
)
?
NS_LITERAL_STRING
(
"
load
"
)
:
NS_LITERAL_STRING
(
"
error
"
)
false
false
)
;
if
(
mLoader
-
>
mDocument
)
{
mLoader
-
>
mDocument
-
>
UnblockOnload
(
true
)
;
}
}
void
SheetLoadData
:
:
ScheduleLoadEventIfNeeded
(
nsresult
aStatus
)
{
if
(
!
mOwningElement
)
{
return
;
}
mStatus
=
aStatus
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
nsCOMPtr
<
nsIThreadInternal
>
internalThread
=
do_QueryInterface
(
thread
)
;
if
(
NS_SUCCEEDED
(
internalThread
-
>
AddObserver
(
this
)
)
)
{
if
(
mLoader
-
>
mDocument
)
{
mLoader
-
>
mDocument
-
>
BlockOnload
(
)
;
}
}
}
bool
LoaderReusableStyleSheets
:
:
FindReusableStyleSheet
(
nsIURI
*
aURL
RefPtr
<
StyleSheet
>
&
aResult
)
{
MOZ_ASSERT
(
aURL
)
;
for
(
size_t
i
=
mReusableSheets
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
size_t
index
=
i
-
1
;
bool
sameURI
;
MOZ_ASSERT
(
mReusableSheets
[
index
]
-
>
GetOriginalURI
(
)
)
;
nsresult
rv
=
aURL
-
>
Equals
(
mReusableSheets
[
index
]
-
>
GetOriginalURI
(
)
&
sameURI
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
sameURI
)
{
aResult
=
mReusableSheets
[
index
]
;
mReusableSheets
.
RemoveElementAt
(
index
)
;
return
true
;
}
}
return
false
;
}
Loader
:
:
Loader
(
StyleBackendType
aType
DocGroup
*
aDocGroup
)
:
mDocument
(
nullptr
)
mDocGroup
(
aDocGroup
)
mDatasToNotifyOn
(
0
)
mCompatMode
(
eCompatibility_FullStandards
)
mStyleBackendType
(
Some
(
aType
)
)
mEnabled
(
true
)
mReporter
(
new
ConsoleReportCollector
(
)
)
#
ifdef
DEBUG
mSyncCallback
(
false
)
#
endif
{
}
Loader
:
:
Loader
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
mDatasToNotifyOn
(
0
)
mCompatMode
(
eCompatibility_FullStandards
)
mEnabled
(
true
)
mReporter
(
new
ConsoleReportCollector
(
)
)
#
ifdef
DEBUG
mSyncCallback
(
false
)
#
endif
{
MOZ_ASSERT
(
mDocument
"
We
should
get
a
valid
document
from
the
caller
!
"
)
;
mDocument
-
>
GetPreferredStyleSheetSet
(
mPreferredSheet
)
;
}
Loader
:
:
~
Loader
(
)
{
NS_ASSERTION
(
!
mSheets
|
|
mSheets
-
>
mLoadingDatas
.
Count
(
)
=
=
0
"
How
did
we
get
destroyed
when
there
are
loading
data
?
"
)
;
NS_ASSERTION
(
!
mSheets
|
|
mSheets
-
>
mPendingDatas
.
Count
(
)
=
=
0
"
How
did
we
get
destroyed
when
there
are
pending
data
?
"
)
;
}
void
Loader
:
:
DropDocumentReference
(
void
)
{
mDocument
=
nullptr
;
if
(
mSheets
)
{
StartAlternateLoads
(
)
;
}
}
nsresult
Loader
:
:
SetPreferredSheet
(
const
nsAString
&
aTitle
)
{
#
ifdef
DEBUG
if
(
mDocument
)
{
nsAutoString
currentPreferred
;
mDocument
-
>
GetLastStyleSheetSet
(
currentPreferred
)
;
if
(
DOMStringIsNull
(
currentPreferred
)
)
{
mDocument
-
>
GetPreferredStyleSheetSet
(
currentPreferred
)
;
}
NS_ASSERTION
(
currentPreferred
.
Equals
(
aTitle
)
"
Unexpected
argument
to
SetPreferredSheet
"
)
;
}
#
endif
mPreferredSheet
=
aTitle
;
if
(
mSheets
)
{
LoadDataArray
arr
(
mSheets
-
>
mPendingDatas
.
Count
(
)
)
;
for
(
auto
iter
=
mSheets
-
>
mPendingDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
SheetLoadData
*
data
=
iter
.
Data
(
)
;
MOZ_ASSERT
(
data
"
Must
have
a
data
"
)
;
if
(
!
data
-
>
mLoader
-
>
IsAlternate
(
data
-
>
mTitle
true
)
)
{
arr
.
AppendElement
(
data
)
;
iter
.
Remove
(
)
;
}
}
mDatasToNotifyOn
+
=
arr
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
arr
.
Length
(
)
;
+
+
i
)
{
-
-
mDatasToNotifyOn
;
LoadSheet
(
arr
[
i
]
eSheetNeedsParser
false
)
;
}
}
return
NS_OK
;
}
static
const
char
kCharsetSym
[
]
=
"
charset
\
"
"
;
static
bool
GetCharsetFromData
(
const
char
*
aStyleSheetData
uint32_t
aDataLength
nsACString
&
aCharset
)
{
aCharset
.
Truncate
(
)
;
if
(
aDataLength
<
=
sizeof
(
kCharsetSym
)
-
1
)
return
false
;
if
(
strncmp
(
aStyleSheetData
kCharsetSym
sizeof
(
kCharsetSym
)
-
1
)
)
{
return
false
;
}
for
(
uint32_t
i
=
sizeof
(
kCharsetSym
)
-
1
;
i
<
aDataLength
;
+
+
i
)
{
char
c
=
aStyleSheetData
[
i
]
;
if
(
c
=
=
'
"
'
)
{
+
+
i
;
if
(
i
<
aDataLength
&
&
aStyleSheetData
[
i
]
=
=
'
;
'
)
{
return
true
;
}
break
;
}
aCharset
.
Append
(
c
)
;
}
aCharset
.
Truncate
(
)
;
return
false
;
}
NotNull
<
const
Encoding
*
>
SheetLoadData
:
:
DetermineNonBOMEncoding
(
nsACString
const
&
aSegment
nsIChannel
*
aChannel
)
{
const
Encoding
*
encoding
;
nsAutoCString
label
;
if
(
aChannel
&
&
NS_SUCCEEDED
(
aChannel
-
>
GetContentCharset
(
label
)
)
)
{
encoding
=
Encoding
:
:
ForLabel
(
label
)
;
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
auto
sniffingLength
=
aSegment
.
Length
(
)
;
if
(
sniffingLength
>
SNIFFING_BUFFER_SIZE
)
{
sniffingLength
=
SNIFFING_BUFFER_SIZE
;
}
if
(
GetCharsetFromData
(
aSegment
.
BeginReading
(
)
sniffingLength
label
)
)
{
encoding
=
Encoding
:
:
ForLabel
(
label
)
;
if
(
encoding
=
=
UTF_16BE_ENCODING
|
|
encoding
=
=
UTF_16LE_ENCODING
)
{
return
UTF_8_ENCODING
;
}
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
if
(
mOwningElement
)
{
nsAutoString
label16
;
mOwningElement
-
>
GetCharset
(
label16
)
;
encoding
=
Encoding
:
:
ForLabel
(
label16
)
;
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
if
(
mPreloadEncoding
)
{
return
WrapNotNull
(
mPreloadEncoding
)
;
}
if
(
mParentData
)
{
encoding
=
mParentData
-
>
mEncoding
;
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
if
(
mLoader
-
>
mDocument
)
{
return
mLoader
-
>
mDocument
-
>
GetDocumentCharacterSet
(
)
;
}
return
UTF_8_ENCODING
;
}
NS_IMETHODIMP
SheetLoadData
:
:
OnDetermineCharset
(
nsIUnicharStreamLoader
*
aLoader
nsISupports
*
aContext
nsACString
const
&
aSegment
nsACString
&
aCharset
)
{
const
Encoding
*
encoding
;
size_t
bomLength
;
Tie
(
encoding
bomLength
)
=
Encoding
:
:
ForBOM
(
aSegment
)
;
Unused
<
<
bomLength
;
if
(
!
encoding
)
{
nsCOMPtr
<
nsIChannel
>
channel
;
aLoader
-
>
GetChannel
(
getter_AddRefs
(
channel
)
)
;
encoding
=
DetermineNonBOMEncoding
(
aSegment
channel
)
;
}
encoding
-
>
Name
(
aCharset
)
;
mEncoding
=
encoding
;
return
NS_OK
;
}
already_AddRefed
<
nsIURI
>
SheetLoadData
:
:
GetReferrerURI
(
)
{
nsCOMPtr
<
nsIURI
>
uri
;
if
(
mParentData
)
uri
=
mParentData
-
>
mSheet
-
>
GetSheetURI
(
)
;
if
(
!
uri
&
&
mLoader
-
>
mDocument
)
uri
=
mLoader
-
>
mDocument
-
>
GetDocumentURI
(
)
;
return
uri
.
forget
(
)
;
}
NS_IMETHODIMP
SheetLoadData
:
:
OnStreamComplete
(
nsIUnicharStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
const
nsAString
&
aBuffer
)
{
nsCOMPtr
<
nsIChannel
>
channel
;
aLoader
-
>
GetChannel
(
getter_AddRefs
(
channel
)
)
;
nsCString
bytes
;
aLoader
-
>
GetRawBuffer
(
bytes
)
;
nsresult
rv
=
VerifySheetReadyToParse
(
aStatus
bytes
channel
)
;
if
(
rv
!
=
NS_OK_PARSE_SHEET
)
{
return
rv
;
}
bool
completed
;
rv
=
mLoader
-
>
ParseSheet
(
aBuffer
Span
<
const
uint8_t
>
(
)
this
completed
)
;
NS_ASSERTION
(
completed
|
|
!
mSyncLoad
"
sync
load
did
not
complete
"
)
;
return
rv
;
}
nsresult
SheetLoadData
:
:
VerifySheetReadyToParse
(
nsresult
aStatus
const
nsACString
&
aBytes
nsIChannel
*
aChannel
)
{
LOG
(
(
"
SheetLoadData
:
:
OnStreamComplete
"
)
)
;
NS_ASSERTION
(
!
mLoader
-
>
mSyncCallback
"
Synchronous
callback
from
necko
"
)
;
if
(
mIsCancelled
)
{
return
NS_OK
;
}
if
(
!
mLoader
-
>
mDocument
&
&
!
mIsNonDocumentSheet
)
{
LOG_WARN
(
(
"
No
document
and
not
non
-
document
sheet
;
dropping
load
"
)
)
;
mLoader
-
>
SheetComplete
(
this
NS_BINDING_ABORTED
)
;
return
NS_OK
;
}
if
(
NS_FAILED
(
aStatus
)
)
{
LOG_WARN
(
(
"
Load
failed
:
status
0x
%
"
PRIx32
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
if
(
aStatus
=
=
NS_ERROR_TRACKING_URI
)
{
nsIDocument
*
doc
=
mLoader
-
>
GetDocument
(
)
;
if
(
doc
)
{
for
(
SheetLoadData
*
data
=
this
;
data
;
data
=
data
-
>
mNext
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
data
-
>
mOwningElement
)
;
doc
-
>
AddBlockedTrackingNode
(
content
)
;
}
}
}
mLoader
-
>
SheetComplete
(
this
aStatus
)
;
return
NS_OK
;
}
if
(
!
aChannel
)
{
mLoader
-
>
SheetComplete
(
this
NS_OK
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
originalURI
;
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
nsCOMPtr
<
nsIURI
>
channelURI
;
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
if
(
!
channelURI
|
|
!
originalURI
)
{
NS_ERROR
(
"
Someone
just
violated
the
nsIRequest
contract
"
)
;
LOG_WARN
(
(
"
Channel
without
a
URI
.
Bad
!
"
)
)
;
mLoader
-
>
SheetComplete
(
this
NS_ERROR_UNEXPECTED
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
nsresult
result
=
NS_ERROR_NOT_AVAILABLE
;
if
(
secMan
)
{
if
(
mUseSystemPrincipal
)
{
result
=
secMan
-
>
GetSystemPrincipal
(
getter_AddRefs
(
principal
)
)
;
}
else
{
result
=
secMan
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
principal
)
)
;
}
}
if
(
NS_FAILED
(
result
)
)
{
LOG_WARN
(
(
"
Couldn
'
t
get
principal
"
)
)
;
mLoader
-
>
SheetComplete
(
this
result
)
;
return
NS_OK
;
}
mSheet
-
>
SetPrincipal
(
principal
)
;
if
(
mLoaderPrincipal
&
&
mSheet
-
>
GetCORSMode
(
)
=
=
CORS_NONE
)
{
bool
subsumed
;
result
=
mLoaderPrincipal
-
>
Subsumes
(
principal
&
subsumed
)
;
if
(
NS_FAILED
(
result
)
|
|
!
subsumed
)
{
mIsCrossOriginNoCORS
=
true
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
result
=
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_SUCCEEDED
(
result
)
&
&
!
requestSucceeded
)
{
LOG
(
(
"
Load
returned
an
error
page
"
)
)
;
mLoader
-
>
SheetComplete
(
this
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
nsAutoCString
sourceMapURL
;
if
(
nsContentUtils
:
:
GetSourceMapURL
(
httpChannel
sourceMapURL
)
)
{
mSheet
-
>
SetSourceMapURL
(
NS_ConvertUTF8toUTF16
(
sourceMapURL
)
)
;
}
}
nsAutoCString
contentType
;
aChannel
-
>
GetContentType
(
contentType
)
;
bool
validType
=
contentType
.
EqualsLiteral
(
"
text
/
css
"
)
|
|
contentType
.
EqualsLiteral
(
UNKNOWN_CONTENT_TYPE
)
|
|
contentType
.
IsEmpty
(
)
;
if
(
!
validType
)
{
const
char
*
errorMessage
;
uint32_t
errorFlag
;
bool
sameOrigin
=
true
;
if
(
mLoaderPrincipal
)
{
bool
subsumed
;
result
=
mLoaderPrincipal
-
>
Subsumes
(
principal
&
subsumed
)
;
if
(
NS_FAILED
(
result
)
|
|
!
subsumed
)
{
sameOrigin
=
false
;
}
}
if
(
sameOrigin
&
&
mLoader
-
>
mCompatMode
=
=
eCompatibility_NavQuirks
)
{
errorMessage
=
"
MimeNotCssWarn
"
;
errorFlag
=
nsIScriptError
:
:
warningFlag
;
}
else
{
errorMessage
=
"
MimeNotCss
"
;
errorFlag
=
nsIScriptError
:
:
errorFlag
;
}
const
nsString
&
specUTF16
=
NS_ConvertUTF8toUTF16
(
channelURI
-
>
GetSpecOrDefault
(
)
)
;
const
nsString
&
ctypeUTF16
=
NS_ConvertASCIItoUTF16
(
contentType
)
;
const
char16_t
*
strings
[
]
=
{
specUTF16
.
get
(
)
ctypeUTF16
.
get
(
)
}
;
nsCOMPtr
<
nsIURI
>
referrer
=
GetReferrerURI
(
)
;
nsContentUtils
:
:
ReportToConsole
(
errorFlag
NS_LITERAL_CSTRING
(
"
CSS
Loader
"
)
mLoader
-
>
mDocument
nsContentUtils
:
:
eCSS_PROPERTIES
errorMessage
strings
ArrayLength
(
strings
)
referrer
)
;
if
(
errorFlag
=
=
nsIScriptError
:
:
errorFlag
)
{
LOG_WARN
(
(
"
Ignoring
sheet
with
improper
MIME
type
%
s
"
contentType
.
get
(
)
)
)
;
mLoader
-
>
SheetComplete
(
this
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
}
SRIMetadata
sriMetadata
;
mSheet
-
>
GetIntegrity
(
sriMetadata
)
;
if
(
sriMetadata
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
if
(
loadInfo
&
&
loadInfo
-
>
GetEnforceSRI
(
)
)
{
LOG
(
(
"
Load
was
blocked
by
SRI
"
)
)
;
MOZ_LOG
(
gSriPRLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
css
:
:
Loader
:
:
OnStreamComplete
required
SRI
not
found
"
)
)
;
mLoader
-
>
SheetComplete
(
this
NS_ERROR_SRI_CORRUPT
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
loadInfo
-
>
LoadingPrincipal
(
)
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
nsAutoCString
spec
;
mLoader
-
>
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
spec
)
;
csp
-
>
LogViolationDetails
(
nsIContentSecurityPolicy
:
:
VIOLATION_TYPE_REQUIRE_SRI_FOR_STYLE
NS_ConvertUTF8toUTF16
(
spec
)
EmptyString
(
)
0
EmptyString
(
)
EmptyString
(
)
)
;
return
NS_OK
;
}
}
else
{
nsAutoCString
sourceUri
;
if
(
mLoader
-
>
mDocument
&
&
mLoader
-
>
mDocument
-
>
GetDocumentURI
(
)
)
{
mLoader
-
>
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
nsresult
rv
=
SRICheck
:
:
VerifyIntegrity
(
sriMetadata
aChannel
aBytes
sourceUri
mLoader
-
>
mReporter
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
aChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
loadGroup
)
{
mLoader
-
>
mReporter
-
>
FlushConsoleReports
(
loadGroup
)
;
}
else
{
mLoader
-
>
mReporter
-
>
FlushConsoleReports
(
mLoader
-
>
mDocument
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Load
was
blocked
by
SRI
"
)
)
;
MOZ_LOG
(
gSriPRLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
css
:
:
Loader
:
:
OnStreamComplete
bad
metadata
"
)
)
;
mLoader
-
>
SheetComplete
(
this
NS_ERROR_SRI_CORRUPT
)
;
return
NS_OK
;
}
}
mSheet
-
>
SetURIs
(
channelURI
originalURI
channelURI
)
;
return
NS_OK_PARSE_SHEET
;
}
bool
Loader
:
:
IsAlternate
(
const
nsAString
&
aTitle
bool
aHasAlternateRel
)
{
if
(
aTitle
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
!
aHasAlternateRel
&
&
mDocument
&
&
mPreferredSheet
.
IsEmpty
(
)
)
{
mDocument
-
>
SetHeaderData
(
nsGkAtoms
:
:
headerDefaultStyle
aTitle
)
;
return
false
;
}
return
!
aTitle
.
Equals
(
mPreferredSheet
)
;
}
nsresult
Loader
:
:
ObsoleteSheet
(
nsIURI
*
aURI
)
{
if
(
!
mSheets
)
{
return
NS_OK
;
}
if
(
!
aURI
)
{
return
NS_ERROR_INVALID_ARG
;
}
for
(
auto
iter
=
mSheets
-
>
mCompleteSheets
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsIURI
*
sheetURI
=
iter
.
Key
(
)
-
>
GetURI
(
)
;
bool
areEqual
;
nsresult
rv
=
sheetURI
-
>
Equals
(
aURI
&
areEqual
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
areEqual
)
{
iter
.
Remove
(
)
;
}
}
return
NS_OK
;
}
nsresult
Loader
:
:
CheckContentPolicy
(
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
nsIURI
*
aTargetURI
nsISupports
*
aContext
bool
aIsPreload
)
{
if
(
!
aLoadingPrincipal
)
{
return
NS_OK
;
}
nsContentPolicyType
contentPolicyType
=
aIsPreload
?
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
;
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
contentPolicyType
aTargetURI
aLoadingPrincipal
aTriggeringPrincipal
aContext
NS_LITERAL_CSTRING
(
"
text
/
css
"
)
nullptr
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
return
NS_OK
;
}
nsresult
Loader
:
:
CreateSheet
(
nsIURI
*
aURI
nsIContent
*
aLinkingContent
nsIPrincipal
*
aLoaderPrincipal
css
:
:
SheetParsingMode
aParsingMode
CORSMode
aCORSMode
ReferrerPolicy
aReferrerPolicy
const
nsAString
&
aIntegrity
bool
aSyncLoad
bool
aHasAlternateRel
const
nsAString
&
aTitle
StyleSheetState
&
aSheetState
bool
*
aIsAlternate
RefPtr
<
StyleSheet
>
*
aSheet
)
{
LOG
(
(
"
css
:
:
Loader
:
:
CreateSheet
"
)
)
;
NS_PRECONDITION
(
aSheet
"
Null
out
param
!
"
)
;
if
(
!
mSheets
)
{
mSheets
=
new
Sheets
(
)
;
}
*
aSheet
=
nullptr
;
aSheetState
=
eSheetStateUnknown
;
*
aIsAlternate
=
IsAlternate
(
aTitle
aHasAlternateRel
)
;
if
(
aURI
)
{
aSheetState
=
eSheetComplete
;
RefPtr
<
StyleSheet
>
sheet
;
#
ifdef
MOZ_XUL
if
(
IsChromeURI
(
aURI
)
)
{
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
if
(
cache
&
&
cache
-
>
IsEnabled
(
)
)
{
sheet
=
cache
-
>
GetStyleSheet
(
aURI
GetStyleBackendType
(
)
)
;
LOG
(
(
"
From
XUL
cache
:
%
p
"
sheet
.
get
(
)
)
)
;
}
}
#
endif
bool
fromCompleteSheets
=
false
;
if
(
!
sheet
)
{
URIPrincipalReferrerPolicyAndCORSModeHashKey
key
(
aURI
aLoaderPrincipal
aCORSMode
aReferrerPolicy
)
;
StyleSheet
*
completeSheet
=
nullptr
;
mSheets
-
>
mCompleteSheets
.
Get
(
&
key
&
completeSheet
)
;
sheet
=
completeSheet
;
LOG
(
(
"
From
completed
:
%
p
"
sheet
.
get
(
)
)
)
;
fromCompleteSheets
=
!
!
sheet
;
}
if
(
sheet
)
{
NS_ASSERTION
(
sheet
-
>
IsComplete
(
)
"
Sheet
thinks
it
'
s
not
complete
while
we
think
it
is
"
)
;
if
(
sheet
-
>
HasForcedUniqueInner
(
)
)
{
LOG
(
(
"
Not
cloning
completed
sheet
%
p
because
it
has
a
"
"
forced
unique
inner
"
sheet
.
get
(
)
)
)
;
sheet
=
nullptr
;
fromCompleteSheets
=
false
;
}
}
if
(
!
sheet
&
&
!
aSyncLoad
)
{
aSheetState
=
eSheetLoading
;
SheetLoadData
*
loadData
=
nullptr
;
URIPrincipalReferrerPolicyAndCORSModeHashKey
key
(
aURI
aLoaderPrincipal
aCORSMode
aReferrerPolicy
)
;
mSheets
-
>
mLoadingDatas
.
Get
(
&
key
&
loadData
)
;
if
(
loadData
)
{
sheet
=
loadData
-
>
mSheet
;
LOG
(
(
"
From
loading
:
%
p
"
sheet
.
get
(
)
)
)
;
#
ifdef
DEBUG
bool
debugEqual
;
NS_ASSERTION
(
(
!
aLoaderPrincipal
&
&
!
loadData
-
>
mLoaderPrincipal
)
|
|
(
aLoaderPrincipal
&
&
loadData
-
>
mLoaderPrincipal
&
&
NS_SUCCEEDED
(
aLoaderPrincipal
-
>
Equals
(
loadData
-
>
mLoaderPrincipal
&
debugEqual
)
)
&
&
debugEqual
)
"
Principals
should
be
the
same
"
)
;
#
endif
}
if
(
!
sheet
)
{
aSheetState
=
eSheetPending
;
loadData
=
nullptr
;
mSheets
-
>
mPendingDatas
.
Get
(
&
key
&
loadData
)
;
if
(
loadData
)
{
sheet
=
loadData
-
>
mSheet
;
LOG
(
(
"
From
pending
:
%
p
"
sheet
.
get
(
)
)
)
;
#
ifdef
DEBUG
bool
debugEqual
;
NS_ASSERTION
(
(
!
aLoaderPrincipal
&
&
!
loadData
-
>
mLoaderPrincipal
)
|
|
(
aLoaderPrincipal
&
&
loadData
-
>
mLoaderPrincipal
&
&
NS_SUCCEEDED
(
aLoaderPrincipal
-
>
Equals
(
loadData
-
>
mLoaderPrincipal
&
debugEqual
)
)
&
&
debugEqual
)
"
Principals
should
be
the
same
"
)
;
#
endif
}
}
}
if
(
sheet
)
{
NS_ASSERTION
(
!
sheet
-
>
HasForcedUniqueInner
(
)
|
|
!
sheet
-
>
IsComplete
(
)
"
Unexpected
complete
sheet
with
forced
unique
inner
"
)
;
NS_ASSERTION
(
sheet
-
>
IsComplete
(
)
|
|
aSheetState
!
=
eSheetComplete
"
Sheet
thinks
it
'
s
not
complete
while
we
think
it
is
"
)
;
RefPtr
<
StyleSheet
>
clonedSheet
=
sheet
-
>
Clone
(
nullptr
nullptr
nullptr
nullptr
)
;
*
aSheet
=
Move
(
clonedSheet
)
;
if
(
*
aSheet
&
&
fromCompleteSheets
&
&
!
sheet
-
>
GetOwnerNode
(
)
&
&
!
sheet
-
>
GetParentSheet
(
)
)
{
URIPrincipalReferrerPolicyAndCORSModeHashKey
key
(
aURI
aLoaderPrincipal
aCORSMode
aReferrerPolicy
)
;
NS_ASSERTION
(
(
*
aSheet
)
-
>
IsComplete
(
)
"
Should
only
be
caching
complete
sheets
"
)
;
mSheets
-
>
mCompleteSheets
.
Put
(
&
key
*
aSheet
)
;
}
}
}
if
(
!
*
aSheet
)
{
aSheetState
=
eSheetNeedsParser
;
nsIURI
*
sheetURI
;
nsCOMPtr
<
nsIURI
>
baseURI
;
nsIURI
*
originalURI
;
if
(
!
aURI
)
{
NS_ASSERTION
(
aLinkingContent
"
Inline
stylesheet
without
linking
content
?
"
)
;
baseURI
=
aLinkingContent
-
>
GetBaseURI
(
)
;
sheetURI
=
aLinkingContent
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
;
originalURI
=
nullptr
;
}
else
{
baseURI
=
aURI
;
sheetURI
=
aURI
;
originalURI
=
aURI
;
}
SRIMetadata
sriMetadata
;
if
(
!
aIntegrity
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gSriPRLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
css
:
:
Loader
:
:
CreateSheet
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
aIntegrity
)
.
get
(
)
)
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
&
&
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
SRICheck
:
:
IntegrityMetadata
(
aIntegrity
sourceUri
mReporter
&
sriMetadata
)
;
}
if
(
GetStyleBackendType
(
)
=
=
StyleBackendType
:
:
Gecko
)
{
#
ifdef
MOZ_OLD_STYLE
*
aSheet
=
new
CSSStyleSheet
(
aParsingMode
aCORSMode
aReferrerPolicy
sriMetadata
)
;
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
else
{
*
aSheet
=
new
ServoStyleSheet
(
aParsingMode
aCORSMode
aReferrerPolicy
sriMetadata
)
;
}
(
*
aSheet
)
-
>
SetURIs
(
sheetURI
originalURI
baseURI
)
;
}
NS_ASSERTION
(
*
aSheet
"
We
should
have
a
sheet
by
now
!
"
)
;
NS_ASSERTION
(
aSheetState
!
=
eSheetStateUnknown
"
Have
to
set
a
state
!
"
)
;
LOG
(
(
"
State
:
%
s
"
gStateStrings
[
aSheetState
]
)
)
;
return
NS_OK
;
}
void
Loader
:
:
PrepareSheet
(
StyleSheet
*
aSheet
const
nsAString
&
aTitle
const
nsAString
&
aMediaString
MediaList
*
aMediaList
Element
*
aScopeElement
bool
aIsAlternate
)
{
NS_PRECONDITION
(
aSheet
"
Must
have
a
sheet
!
"
)
;
RefPtr
<
MediaList
>
mediaList
(
aMediaList
)
;
if
(
!
aMediaString
.
IsEmpty
(
)
)
{
NS_ASSERTION
(
!
aMediaList
"
must
not
provide
both
aMediaString
and
aMediaList
"
)
;
mediaList
=
MediaList
:
:
Create
(
GetStyleBackendType
(
)
aMediaString
)
;
}
aSheet
-
>
SetMedia
(
mediaList
)
;
aSheet
-
>
SetTitle
(
aTitle
)
;
aSheet
-
>
SetEnabled
(
!
aIsAlternate
)
;
if
(
aSheet
-
>
IsGecko
(
)
)
{
#
ifdef
MOZ_OLD_STYLE
aSheet
-
>
AsGecko
(
)
-
>
SetScopeElement
(
aScopeElement
)
;
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
else
{
if
(
aScopeElement
)
{
NS_WARNING
(
"
stylo
:
scoped
style
sheets
not
supported
"
)
;
}
}
}
nsresult
Loader
:
:
InsertSheetInDoc
(
StyleSheet
*
aSheet
nsIContent
*
aLinkingContent
nsIDocument
*
aDocument
)
{
LOG
(
(
"
css
:
:
Loader
:
:
InsertSheetInDoc
"
)
)
;
NS_PRECONDITION
(
aSheet
"
Nothing
to
insert
"
)
;
NS_PRECONDITION
(
aDocument
"
Must
have
a
document
to
insert
into
"
)
;
int32_t
sheetCount
=
aDocument
-
>
SheetCount
(
)
;
int32_t
insertionPoint
;
for
(
insertionPoint
=
sheetCount
-
1
;
insertionPoint
>
=
0
;
-
-
insertionPoint
)
{
StyleSheet
*
curSheet
=
aDocument
-
>
SheetAt
(
insertionPoint
)
;
NS_ASSERTION
(
curSheet
"
There
must
be
a
sheet
here
!
"
)
;
nsCOMPtr
<
nsINode
>
sheetOwner
=
curSheet
-
>
GetOwnerNode
(
)
;
if
(
sheetOwner
&
&
!
aLinkingContent
)
{
continue
;
}
if
(
!
sheetOwner
)
{
break
;
}
NS_ASSERTION
(
aLinkingContent
!
=
sheetOwner
"
Why
do
we
still
have
our
old
sheet
?
"
)
;
if
(
nsContentUtils
:
:
PositionIsBefore
(
sheetOwner
aLinkingContent
)
)
{
break
;
}
}
+
+
insertionPoint
;
nsCOMPtr
<
nsIStyleSheetLinkingElement
>
linkingElement
=
do_QueryInterface
(
aLinkingContent
)
;
if
(
linkingElement
)
{
linkingElement
-
>
SetStyleSheet
(
aSheet
)
;
}
aDocument
-
>
BeginUpdate
(
UPDATE_STYLE
)
;
aDocument
-
>
InsertStyleSheetAt
(
aSheet
insertionPoint
)
;
aDocument
-
>
EndUpdate
(
UPDATE_STYLE
)
;
LOG
(
(
"
Inserting
into
document
at
position
%
d
"
insertionPoint
)
)
;
return
NS_OK
;
}
nsresult
Loader
:
:
InsertChildSheet
(
StyleSheet
*
aSheet
StyleSheet
*
aParentSheet
ImportRule
*
aGeckoParentRule
)
{
LOG
(
(
"
css
:
:
Loader
:
:
InsertChildSheet
"
)
)
;
MOZ_ASSERT
(
aSheet
"
Nothing
to
insert
"
)
;
MOZ_ASSERT
(
aParentSheet
"
Need
a
parent
to
insert
into
"
)
;
MOZ_ASSERT
(
aSheet
-
>
IsGecko
(
)
=
=
!
!
aGeckoParentRule
)
;
aSheet
-
>
SetEnabled
(
true
)
;
if
(
aGeckoParentRule
)
{
#
ifdef
MOZ_OLD_STYLE
aGeckoParentRule
-
>
SetSheet
(
aSheet
-
>
AsGecko
(
)
)
;
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
aParentSheet
-
>
PrependStyleSheet
(
aSheet
)
;
LOG
(
(
"
Inserting
into
parent
sheet
"
)
)
;
return
NS_OK
;
}
nsresult
Loader
:
:
LoadSheet
(
SheetLoadData
*
aLoadData
StyleSheetState
aSheetState
bool
aIsPreload
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheet
"
)
)
;
NS_PRECONDITION
(
aLoadData
"
Need
a
load
data
"
)
;
NS_PRECONDITION
(
aLoadData
-
>
mURI
"
Need
a
URI
to
load
"
)
;
NS_PRECONDITION
(
aLoadData
-
>
mSheet
"
Need
a
sheet
to
load
into
"
)
;
NS_PRECONDITION
(
aSheetState
!
=
eSheetComplete
"
Why
bother
?
"
)
;
NS_PRECONDITION
(
!
aLoadData
-
>
mUseSystemPrincipal
|
|
aLoadData
-
>
mSyncLoad
"
Shouldn
'
t
use
system
principal
for
async
loads
"
)
;
NS_ASSERTION
(
mSheets
"
mLoadingDatas
should
be
initialized
by
now
.
"
)
;
LOG_URI
(
"
Load
from
:
'
%
s
'
"
aLoadData
-
>
mURI
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mDocument
&
&
!
aLoadData
-
>
mIsNonDocumentSheet
)
{
LOG_WARN
(
(
"
No
document
and
not
non
-
document
sheet
;
pre
-
dropping
load
"
)
)
;
SheetComplete
(
aLoadData
NS_BINDING_ABORTED
)
;
return
NS_BINDING_ABORTED
;
}
SRIMetadata
sriMetadata
;
aLoadData
-
>
mSheet
-
>
GetIntegrity
(
sriMetadata
)
;
if
(
aLoadData
-
>
mSyncLoad
)
{
LOG
(
(
"
Synchronous
load
"
)
)
;
NS_ASSERTION
(
!
aLoadData
-
>
mObserver
"
Observer
for
a
sync
load
?
"
)
;
NS_ASSERTION
(
aSheetState
=
=
eSheetNeedsParser
"
Sync
loads
can
'
t
reuse
existing
async
loads
"
)
;
nsCOMPtr
<
nsIStreamListener
>
streamLoader
;
if
(
aLoadData
-
>
mSheet
-
>
IsGecko
(
)
)
{
nsCOMPtr
<
nsIUnicharStreamLoader
>
unicharStreamLoader
;
rv
=
NS_NewUnicharStreamLoader
(
getter_AddRefs
(
unicharStreamLoader
)
aLoadData
)
;
streamLoader
=
unicharStreamLoader
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
create
stream
loader
for
sync
load
"
)
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
}
else
{
streamLoader
=
new
StreamLoader
(
aLoadData
)
;
}
if
(
mDocument
)
{
mozilla
:
:
net
:
:
PredictorLearn
(
aLoadData
-
>
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
mDocument
)
;
}
nsSecurityFlags
securityFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
|
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsContentPolicyType
contentPolicyType
=
aIsPreload
?
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
aLoadData
-
>
mRequestingNode
&
&
aLoadData
-
>
mLoaderPrincipal
)
{
rv
=
NS_NewChannelWithTriggeringPrincipal
(
getter_AddRefs
(
channel
)
aLoadData
-
>
mURI
aLoadData
-
>
mRequestingNode
aLoadData
-
>
mLoaderPrincipal
securityFlags
contentPolicyType
)
;
}
else
{
auto
result
=
URLPreloader
:
:
ReadURI
(
aLoadData
-
>
mURI
)
;
if
(
result
.
isOk
(
)
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
MOZ_TRY
(
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
result
.
unwrap
(
)
)
)
;
rv
=
NS_NewInputStreamChannel
(
getter_AddRefs
(
channel
)
aLoadData
-
>
mURI
stream
.
forget
(
)
nsContentUtils
:
:
GetSystemPrincipal
(
)
securityFlags
contentPolicyType
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aLoadData
-
>
mURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
securityFlags
contentPolicyType
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
create
channel
"
)
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
channel
-
>
Open2
(
getter_AddRefs
(
stream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
open
URI
synchronously
"
)
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
channel
-
>
SetContentCharset
(
NS_LITERAL_CSTRING
(
"
UTF
-
8
"
)
)
;
return
nsSyncLoadService
:
:
PushSyncStreamToListener
(
stream
.
forget
(
)
streamLoader
channel
)
;
}
SheetLoadData
*
existingData
=
nullptr
;
URIPrincipalReferrerPolicyAndCORSModeHashKey
key
(
aLoadData
-
>
mURI
aLoadData
-
>
mLoaderPrincipal
aLoadData
-
>
mSheet
-
>
GetCORSMode
(
)
aLoadData
-
>
mSheet
-
>
GetReferrerPolicy
(
)
)
;
if
(
aSheetState
=
=
eSheetLoading
)
{
mSheets
-
>
mLoadingDatas
.
Get
(
&
key
&
existingData
)
;
NS_ASSERTION
(
existingData
"
CreateSheet
lied
about
the
state
"
)
;
}
else
if
(
aSheetState
=
=
eSheetPending
)
{
mSheets
-
>
mPendingDatas
.
Get
(
&
key
&
existingData
)
;
NS_ASSERTION
(
existingData
"
CreateSheet
lied
about
the
state
"
)
;
}
if
(
existingData
)
{
LOG
(
(
"
Glomming
on
to
existing
load
"
)
)
;
SheetLoadData
*
data
=
existingData
;
while
(
data
-
>
mNext
)
{
data
=
data
-
>
mNext
;
}
data
-
>
mNext
=
aLoadData
;
if
(
aSheetState
=
=
eSheetPending
&
&
!
aLoadData
-
>
mWasAlternate
)
{
#
ifdef
DEBUG
SheetLoadData
*
removedData
;
NS_ASSERTION
(
mSheets
-
>
mPendingDatas
.
Get
(
&
key
&
removedData
)
&
&
removedData
=
=
existingData
"
Bad
pending
table
.
"
)
;
#
endif
mSheets
-
>
mPendingDatas
.
Remove
(
&
key
)
;
LOG
(
(
"
Forcing
load
of
pending
data
"
)
)
;
return
LoadSheet
(
existingData
eSheetNeedsParser
aIsPreload
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
if
(
mDocument
)
{
loadGroup
=
mDocument
-
>
GetDocumentLoadGroup
(
)
;
if
(
!
loadGroup
)
{
LOG_ERROR
(
(
"
Failed
to
query
loadGroup
from
document
"
)
)
;
SheetComplete
(
aLoadData
NS_ERROR_UNEXPECTED
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
#
ifdef
DEBUG
mSyncCallback
=
true
;
#
endif
CORSMode
ourCORSMode
=
aLoadData
-
>
mSheet
-
>
GetCORSMode
(
)
;
nsSecurityFlags
securityFlags
=
ourCORSMode
=
=
CORS_NONE
?
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
:
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
;
if
(
ourCORSMode
=
=
CORS_ANONYMOUS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
if
(
ourCORSMode
=
=
CORS_USE_CREDENTIALS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsContentPolicyType
contentPolicyType
=
aIsPreload
?
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
aLoadData
-
>
mRequestingNode
&
&
aLoadData
-
>
mLoaderPrincipal
)
{
rv
=
NS_NewChannelWithTriggeringPrincipal
(
getter_AddRefs
(
channel
)
aLoadData
-
>
mURI
aLoadData
-
>
mRequestingNode
aLoadData
-
>
mLoaderPrincipal
securityFlags
contentPolicyType
nullptr
loadGroup
nullptr
nsIChannel
:
:
LOAD_NORMAL
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aLoadData
-
>
mURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
securityFlags
contentPolicyType
nullptr
loadGroup
nullptr
nsIChannel
:
:
LOAD_NORMAL
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
#
ifdef
DEBUG
mSyncCallback
=
false
;
#
endif
LOG_ERROR
(
(
"
Failed
to
create
channel
"
)
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
if
(
!
aLoadData
-
>
mWasAlternate
)
{
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
channel
)
)
;
if
(
cos
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Leader
)
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
httpChannel
)
{
rv
=
httpChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Accept
"
)
NS_LITERAL_CSTRING
(
"
text
/
css
*
/
*
;
q
=
0
.
1
"
)
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
referrerURI
=
aLoadData
-
>
GetReferrerURI
(
)
;
if
(
referrerURI
)
{
rv
=
httpChannel
-
>
SetReferrerWithPolicy
(
referrerURI
aLoadData
-
>
mSheet
-
>
GetReferrerPolicy
(
)
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
internalChannel
)
{
rv
=
internalChannel
-
>
SetIntegrityMetadata
(
sriMetadata
.
GetIntegrityString
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
timedChannel
)
{
if
(
aLoadData
-
>
mParentData
)
{
timedChannel
-
>
SetInitiatorType
(
NS_LITERAL_STRING
(
"
css
"
)
)
;
if
(
aLoadData
-
>
mParentData
-
>
mIsCrossOriginNoCORS
|
|
aLoadData
-
>
mParentData
-
>
mBlockResourceTiming
)
{
aLoadData
-
>
mBlockResourceTiming
=
true
;
timedChannel
-
>
SetReportResourceTiming
(
false
)
;
}
}
else
{
timedChannel
-
>
SetInitiatorType
(
NS_LITERAL_STRING
(
"
link
"
)
)
;
}
}
}
channel
-
>
SetContentType
(
NS_LITERAL_CSTRING
(
"
text
/
css
"
)
)
;
nsCOMPtr
<
nsIStreamListener
>
streamLoader
;
if
(
aLoadData
-
>
mSheet
-
>
IsGecko
(
)
)
{
nsCOMPtr
<
nsIUnicharStreamLoader
>
unicharStreamLoader
;
rv
=
NS_NewUnicharStreamLoader
(
getter_AddRefs
(
unicharStreamLoader
)
aLoadData
)
;
streamLoader
=
unicharStreamLoader
;
if
(
NS_FAILED
(
rv
)
)
{
#
ifdef
DEBUG
mSyncCallback
=
false
;
#
endif
LOG_ERROR
(
(
"
Failed
to
create
stream
loader
"
)
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
}
else
{
streamLoader
=
new
StreamLoader
(
aLoadData
)
;
}
if
(
mDocument
)
{
mozilla
:
:
net
:
:
PredictorLearn
(
aLoadData
-
>
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
mDocument
)
;
}
rv
=
channel
-
>
AsyncOpen2
(
streamLoader
)
;
#
ifdef
DEBUG
mSyncCallback
=
false
;
#
endif
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Failed
to
create
stream
loader
"
)
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
mSheets
-
>
mLoadingDatas
.
Put
(
&
key
aLoadData
)
;
aLoadData
-
>
mIsLoading
=
true
;
return
NS_OK
;
}
nsresult
Loader
:
:
ParseSheet
(
const
nsAString
&
aUTF16
Span
<
const
uint8_t
>
aUTF8
SheetLoadData
*
aLoadData
bool
&
aCompleted
)
{
LOG
(
(
"
css
:
:
Loader
:
:
ParseSheet
"
)
)
;
NS_PRECONDITION
(
aLoadData
"
Must
have
load
data
"
)
;
NS_PRECONDITION
(
aLoadData
-
>
mSheet
"
Must
have
sheet
to
parse
into
"
)
;
aCompleted
=
false
;
mParsingDatas
.
AppendElement
(
aLoadData
)
;
nsIURI
*
sheetURI
=
aLoadData
-
>
mSheet
-
>
GetSheetURI
(
)
;
nsIURI
*
baseURI
=
aLoadData
-
>
mSheet
-
>
GetBaseURI
(
)
;
nsresult
rv
;
if
(
aLoadData
-
>
mSheet
-
>
IsGecko
(
)
)
{
#
ifdef
MOZ_OLD_STYLE
nsCSSParser
parser
(
this
aLoadData
-
>
mSheet
-
>
AsGecko
(
)
)
;
rv
=
parser
.
ParseSheet
(
aUTF16
sheetURI
baseURI
aLoadData
-
>
mSheet
-
>
Principal
(
)
aLoadData
-
>
mLineNumber
)
;
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
else
{
rv
=
aLoadData
-
>
mSheet
-
>
AsServo
(
)
-
>
ParseSheet
(
this
aUTF8
.
IsEmpty
(
)
?
NS_ConvertUTF16toUTF8
(
aUTF16
)
:
aUTF8
sheetURI
baseURI
aLoadData
-
>
mSheet
-
>
Principal
(
)
aLoadData
-
>
mLineNumber
GetCompatibilityMode
(
)
)
;
}
mParsingDatas
.
RemoveElementAt
(
mParsingDatas
.
Length
(
)
-
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG_ERROR
(
(
"
Low
-
level
error
in
parser
!
"
)
)
;
SheetComplete
(
aLoadData
rv
)
;
return
rv
;
}
NS_ASSERTION
(
aLoadData
-
>
mPendingChildren
=
=
0
|
|
!
aLoadData
-
>
mSyncLoad
"
Sync
load
has
leftover
pending
children
!
"
)
;
if
(
aLoadData
-
>
mPendingChildren
=
=
0
)
{
LOG
(
(
"
No
pending
kids
from
parse
"
)
)
;
aCompleted
=
true
;
SheetComplete
(
aLoadData
NS_OK
)
;
}
return
NS_OK
;
}
void
Loader
:
:
SheetComplete
(
SheetLoadData
*
aLoadData
nsresult
aStatus
)
{
LOG
(
(
"
css
:
:
Loader
:
:
SheetComplete
"
)
)
;
AutoTArray
<
RefPtr
<
SheetLoadData
>
8
>
datasToNotify
;
DoSheetComplete
(
aLoadData
aStatus
datasToNotify
)
;
uint32_t
count
=
datasToNotify
.
Length
(
)
;
mDatasToNotifyOn
+
=
count
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
-
-
mDatasToNotifyOn
;
SheetLoadData
*
data
=
datasToNotify
[
i
]
;
NS_ASSERTION
(
data
&
&
data
-
>
mMustNotify
"
How
did
this
data
get
here
?
"
)
;
if
(
data
-
>
mObserver
)
{
LOG
(
(
"
Notifying
observer
%
p
for
data
%
p
.
wasAlternate
:
%
d
"
data
-
>
mObserver
.
get
(
)
data
data
-
>
mWasAlternate
)
)
;
data
-
>
mObserver
-
>
StyleSheetLoaded
(
data
-
>
mSheet
data
-
>
mWasAlternate
aStatus
)
;
}
nsTObserverArray
<
nsCOMPtr
<
nsICSSLoaderObserver
>
>
:
:
ForwardIterator
iter
(
mObservers
)
;
nsCOMPtr
<
nsICSSLoaderObserver
>
obs
;
while
(
iter
.
HasMore
(
)
)
{
obs
=
iter
.
GetNext
(
)
;
LOG
(
(
"
Notifying
global
observer
%
p
for
data
%
p
.
wasAlternate
:
%
d
"
obs
.
get
(
)
data
data
-
>
mWasAlternate
)
)
;
obs
-
>
StyleSheetLoaded
(
data
-
>
mSheet
data
-
>
mWasAlternate
aStatus
)
;
}
}
if
(
mSheets
-
>
mLoadingDatas
.
Count
(
)
=
=
0
&
&
mSheets
-
>
mPendingDatas
.
Count
(
)
>
0
)
{
LOG
(
(
"
No
more
loading
sheets
;
starting
alternates
"
)
)
;
StartAlternateLoads
(
)
;
}
}
void
Loader
:
:
DoSheetComplete
(
SheetLoadData
*
aLoadData
nsresult
aStatus
LoadDataArray
&
aDatasToNotify
)
{
LOG
(
(
"
css
:
:
Loader
:
:
DoSheetComplete
"
)
)
;
NS_PRECONDITION
(
aLoadData
"
Must
have
a
load
data
!
"
)
;
NS_PRECONDITION
(
aLoadData
-
>
mSheet
"
Must
have
a
sheet
"
)
;
NS_ASSERTION
(
mSheets
"
mLoadingDatas
should
be
initialized
by
now
.
"
)
;
LOG
(
(
"
Load
completed
status
:
0x
%
"
PRIx32
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
if
(
aLoadData
-
>
mURI
)
{
LOG_URI
(
"
Finished
loading
:
'
%
s
'
"
aLoadData
-
>
mURI
)
;
if
(
aLoadData
-
>
mIsLoading
)
{
URIPrincipalReferrerPolicyAndCORSModeHashKey
key
(
aLoadData
-
>
mURI
aLoadData
-
>
mLoaderPrincipal
aLoadData
-
>
mSheet
-
>
GetCORSMode
(
)
aLoadData
-
>
mSheet
-
>
GetReferrerPolicy
(
)
)
;
#
ifdef
DEBUG
SheetLoadData
*
loadingData
;
NS_ASSERTION
(
mSheets
-
>
mLoadingDatas
.
Get
(
&
key
&
loadingData
)
&
&
loadingData
=
=
aLoadData
"
Bad
loading
table
"
)
;
#
endif
mSheets
-
>
mLoadingDatas
.
Remove
(
&
key
)
;
aLoadData
-
>
mIsLoading
=
false
;
}
}
SheetLoadData
*
data
=
aLoadData
;
while
(
data
)
{
if
(
!
data
-
>
mSheetAlreadyComplete
)
{
MOZ_ASSERT
(
!
data
-
>
mSheet
-
>
HasForcedUniqueInner
(
)
"
should
not
get
a
forced
unique
inner
during
parsing
"
)
;
data
-
>
mSheet
-
>
SetComplete
(
)
;
data
-
>
ScheduleLoadEventIfNeeded
(
aStatus
)
;
}
if
(
data
-
>
mMustNotify
&
&
(
data
-
>
mObserver
|
|
!
mObservers
.
IsEmpty
(
)
)
)
{
aDatasToNotify
.
AppendElement
(
data
)
;
}
NS_ASSERTION
(
!
data
-
>
mParentData
|
|
data
-
>
mParentData
-
>
mPendingChildren
!
=
0
"
Broken
pending
child
count
on
our
parent
"
)
;
if
(
data
-
>
mParentData
&
&
-
-
(
data
-
>
mParentData
-
>
mPendingChildren
)
=
=
0
&
&
!
mParsingDatas
.
Contains
(
data
-
>
mParentData
)
)
{
DoSheetComplete
(
data
-
>
mParentData
aStatus
aDatasToNotify
)
;
}
data
=
data
-
>
mNext
;
}
if
(
NS_SUCCEEDED
(
aStatus
)
&
&
aLoadData
-
>
mURI
)
{
data
=
aLoadData
;
StyleSheet
*
sheet
=
aLoadData
-
>
mSheet
;
while
(
data
)
{
if
(
data
-
>
mSheet
-
>
GetParentSheet
(
)
|
|
data
-
>
mSheet
-
>
GetOwnerNode
(
)
)
{
sheet
=
data
-
>
mSheet
;
break
;
}
data
=
data
-
>
mNext
;
}
#
ifdef
MOZ_XUL
if
(
IsChromeURI
(
aLoadData
-
>
mURI
)
)
{
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
if
(
cache
&
&
cache
-
>
IsEnabled
(
)
)
{
if
(
!
cache
-
>
GetStyleSheet
(
aLoadData
-
>
mURI
GetStyleBackendType
(
)
)
)
{
LOG
(
(
"
Putting
sheet
in
XUL
prototype
cache
"
)
)
;
NS_ASSERTION
(
sheet
-
>
IsComplete
(
)
"
Should
only
be
caching
complete
sheets
"
)
;
cache
-
>
PutStyleSheet
(
sheet
GetStyleBackendType
(
)
)
;
}
}
}
else
{
#
endif
URIPrincipalReferrerPolicyAndCORSModeHashKey
key
(
aLoadData
-
>
mURI
aLoadData
-
>
mLoaderPrincipal
aLoadData
-
>
mSheet
-
>
GetCORSMode
(
)
aLoadData
-
>
mSheet
-
>
GetReferrerPolicy
(
)
)
;
NS_ASSERTION
(
sheet
-
>
IsComplete
(
)
"
Should
only
be
caching
complete
sheets
"
)
;
mSheets
-
>
mCompleteSheets
.
Put
(
&
key
sheet
)
;
#
ifdef
MOZ_XUL
}
#
endif
}
NS_RELEASE
(
aLoadData
)
;
}
nsresult
Loader
:
:
LoadInlineStyle
(
nsIContent
*
aElement
const
nsAString
&
aBuffer
nsIPrincipal
*
aTriggeringPrincipal
uint32_t
aLineNumber
const
nsAString
&
aTitle
const
nsAString
&
aMedia
ReferrerPolicy
aReferrerPolicy
Element
*
aScopeElement
nsICSSLoaderObserver
*
aObserver
bool
*
aCompleted
bool
*
aIsAlternate
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadInlineStyle
"
)
)
;
MOZ_ASSERT
(
mParsingDatas
.
IsEmpty
(
)
"
We
'
re
in
the
middle
of
a
parse
?
"
)
;
*
aCompleted
=
true
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIStyleSheetLinkingElement
>
owningElement
(
do_QueryInterface
(
aElement
)
)
;
NS_ASSERTION
(
owningElement
"
Element
is
not
a
style
linking
element
!
"
)
;
StyleSheetState
state
;
RefPtr
<
StyleSheet
>
sheet
;
nsresult
rv
=
CreateSheet
(
nullptr
aElement
nullptr
eAuthorSheetFeatures
CORS_NONE
aReferrerPolicy
EmptyString
(
)
false
false
aTitle
state
aIsAlternate
&
sheet
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
state
=
=
eSheetNeedsParser
"
Inline
sheets
should
not
be
cached
"
)
;
LOG
(
(
"
Sheet
is
alternate
:
%
d
"
*
aIsAlternate
)
)
;
PrepareSheet
(
sheet
aTitle
aMedia
nullptr
aScopeElement
*
aIsAlternate
)
;
if
(
aElement
-
>
HasFlag
(
NODE_IS_IN_SHADOW_TREE
)
)
{
ShadowRoot
*
containingShadow
=
aElement
-
>
GetContainingShadow
(
)
;
MOZ_ASSERT
(
containingShadow
)
;
containingShadow
-
>
InsertSheet
(
sheet
aElement
)
;
}
else
{
rv
=
InsertSheetInDoc
(
sheet
aElement
mDocument
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsIPrincipal
*
principal
=
aElement
-
>
NodePrincipal
(
)
;
if
(
aTriggeringPrincipal
)
{
principal
=
BasePrincipal
:
:
Cast
(
aTriggeringPrincipal
)
-
>
PrincipalToInherit
(
)
;
}
SheetLoadData
*
data
=
new
SheetLoadData
(
this
aTitle
nullptr
sheet
owningElement
*
aIsAlternate
aObserver
nullptr
static_cast
<
nsINode
*
>
(
aElement
)
)
;
sheet
-
>
SetPrincipal
(
principal
)
;
NS_ADDREF
(
data
)
;
data
-
>
mLineNumber
=
aLineNumber
;
rv
=
ParseSheet
(
aBuffer
Span
<
const
uint8_t
>
(
)
data
*
aCompleted
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
*
aCompleted
)
{
data
-
>
mMustNotify
=
true
;
}
return
rv
;
}
nsresult
Loader
:
:
LoadStyleLink
(
nsIContent
*
aElement
nsIURI
*
aURL
nsIPrincipal
*
aTriggeringPrincipal
const
nsAString
&
aTitle
const
nsAString
&
aMedia
bool
aHasAlternateRel
CORSMode
aCORSMode
ReferrerPolicy
aReferrerPolicy
const
nsAString
&
aIntegrity
nsICSSLoaderObserver
*
aObserver
bool
*
aIsAlternate
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadStyleLink
"
)
)
;
NS_PRECONDITION
(
aURL
"
Must
have
URL
to
load
"
)
;
NS_ASSERTION
(
mParsingDatas
.
Length
(
)
=
=
0
"
We
'
re
in
the
middle
of
a
parse
?
"
)
;
LOG_URI
(
"
Link
uri
:
'
%
s
'
"
aURL
)
;
LOG
(
(
"
Link
title
:
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
aTitle
)
.
get
(
)
)
)
;
LOG
(
(
"
Link
media
:
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
aMedia
)
.
get
(
)
)
)
;
LOG
(
(
"
Link
alternate
rel
:
%
d
"
aHasAlternateRel
)
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_INITIALIZED
)
;
nsIPrincipal
*
loadingPrincipal
=
aElement
?
aElement
-
>
NodePrincipal
(
)
:
mDocument
-
>
NodePrincipal
(
)
;
nsIPrincipal
*
principal
=
aTriggeringPrincipal
?
aTriggeringPrincipal
:
loadingPrincipal
;
nsISupports
*
context
=
aElement
;
if
(
!
context
)
{
context
=
mDocument
;
}
nsresult
rv
=
CheckContentPolicy
(
loadingPrincipal
principal
aURL
context
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
if
(
aElement
&
&
!
mDocument
-
>
IsLoadedAsData
(
)
)
{
RefPtr
<
AsyncEventDispatcher
>
loadBlockingAsyncDispatcher
=
new
LoadBlockingAsyncEventDispatcher
(
aElement
NS_LITERAL_STRING
(
"
error
"
)
false
false
)
;
loadBlockingAsyncDispatcher
-
>
PostDOMEvent
(
)
;
}
return
rv
;
}
StyleSheetState
state
;
RefPtr
<
StyleSheet
>
sheet
;
rv
=
CreateSheet
(
aURL
aElement
principal
eAuthorSheetFeatures
aCORSMode
aReferrerPolicy
aIntegrity
false
aHasAlternateRel
aTitle
state
aIsAlternate
&
sheet
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
Sheet
is
alternate
:
%
d
"
*
aIsAlternate
)
)
;
PrepareSheet
(
sheet
aTitle
aMedia
nullptr
nullptr
*
aIsAlternate
)
;
rv
=
InsertSheetInDoc
(
sheet
aElement
mDocument
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIStyleSheetLinkingElement
>
owningElement
(
do_QueryInterface
(
aElement
)
)
;
if
(
state
=
=
eSheetComplete
)
{
LOG
(
(
"
Sheet
already
complete
:
0x
%
p
"
sheet
.
get
(
)
)
)
;
if
(
aObserver
|
|
!
mObservers
.
IsEmpty
(
)
|
|
owningElement
)
{
rv
=
PostLoadEvent
(
aURL
sheet
aObserver
*
aIsAlternate
owningElement
)
;
return
rv
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
requestingNode
=
do_QueryInterface
(
context
)
;
SheetLoadData
*
data
=
new
SheetLoadData
(
this
aTitle
aURL
sheet
owningElement
*
aIsAlternate
aObserver
principal
requestingNode
)
;
NS_ADDREF
(
data
)
;
if
(
aURL
&
&
state
=
=
eSheetNeedsParser
&
&
mSheets
-
>
mLoadingDatas
.
Count
(
)
!
=
0
&
&
*
aIsAlternate
)
{
LOG
(
(
"
Deferring
alternate
sheet
load
"
)
)
;
URIPrincipalReferrerPolicyAndCORSModeHashKey
key
(
data
-
>
mURI
data
-
>
mLoaderPrincipal
data
-
>
mSheet
-
>
GetCORSMode
(
)
data
-
>
mSheet
-
>
GetReferrerPolicy
(
)
)
;
mSheets
-
>
mPendingDatas
.
Put
(
&
key
data
)
;
data
-
>
mMustNotify
=
true
;
return
NS_OK
;
}
rv
=
LoadSheet
(
data
state
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
data
-
>
mMustNotify
=
true
;
return
rv
;
}
static
bool
HaveAncestorDataWithURI
(
SheetLoadData
*
aData
nsIURI
*
aURI
)
{
if
(
!
aData
-
>
mURI
)
{
MOZ_ASSERT
(
!
aData
-
>
mParentData
"
How
does
inline
style
have
a
parent
?
"
)
;
return
false
;
}
bool
equal
;
if
(
NS_FAILED
(
aData
-
>
mURI
-
>
Equals
(
aURI
&
equal
)
)
|
|
equal
)
{
return
true
;
}
while
(
aData
)
{
if
(
aData
-
>
mParentData
&
&
HaveAncestorDataWithURI
(
aData
-
>
mParentData
aURI
)
)
{
return
true
;
}
aData
=
aData
-
>
mNext
;
}
return
false
;
}
nsresult
Loader
:
:
LoadChildSheet
(
StyleSheet
*
aParentSheet
nsIURI
*
aURL
dom
:
:
MediaList
*
aMedia
ImportRule
*
aGeckoParentRule
LoaderReusableStyleSheets
*
aReusableSheets
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadChildSheet
"
)
)
;
NS_PRECONDITION
(
aURL
"
Must
have
a
URI
to
load
"
)
;
NS_PRECONDITION
(
aParentSheet
"
Must
have
a
parent
sheet
"
)
;
MOZ_ASSERT
(
aParentSheet
-
>
IsGecko
(
)
=
=
!
!
aGeckoParentRule
)
;
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
LOG_URI
(
"
Child
uri
:
'
%
s
'
"
aURL
)
;
nsCOMPtr
<
nsINode
>
owningNode
;
if
(
aParentSheet
-
>
GetAssociatedDocument
(
)
)
{
StyleSheet
*
topSheet
=
aParentSheet
;
while
(
StyleSheet
*
parent
=
topSheet
-
>
GetParentSheet
(
)
)
{
topSheet
=
parent
;
}
owningNode
=
topSheet
-
>
GetOwnerNode
(
)
;
}
nsISupports
*
context
=
nullptr
;
nsIPrincipal
*
loadingPrincipal
=
nullptr
;
if
(
owningNode
)
{
context
=
owningNode
;
loadingPrincipal
=
owningNode
-
>
NodePrincipal
(
)
;
}
else
if
(
mDocument
)
{
context
=
mDocument
;
loadingPrincipal
=
mDocument
-
>
NodePrincipal
(
)
;
}
nsIPrincipal
*
principal
=
aParentSheet
-
>
Principal
(
)
;
nsresult
rv
=
CheckContentPolicy
(
loadingPrincipal
principal
aURL
context
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SheetLoadData
*
parentData
=
nullptr
;
nsCOMPtr
<
nsICSSLoaderObserver
>
observer
;
int32_t
count
=
mParsingDatas
.
Length
(
)
;
if
(
count
>
0
)
{
LOG
(
(
"
Have
a
parent
load
"
)
)
;
parentData
=
mParsingDatas
.
ElementAt
(
count
-
1
)
;
if
(
HaveAncestorDataWithURI
(
parentData
aURL
)
)
{
LOG_ERROR
(
(
"
import
cycle
detected
dropping
load
"
)
)
;
return
NS_OK
;
}
NS_ASSERTION
(
parentData
-
>
mSheet
=
=
aParentSheet
"
Unexpected
call
to
LoadChildSheet
"
)
;
}
else
{
LOG
(
(
"
No
parent
load
;
must
be
CSSOM
"
)
)
;
observer
=
aParentSheet
;
}
RefPtr
<
StyleSheet
>
sheet
;
StyleSheetState
state
;
if
(
aReusableSheets
&
&
aReusableSheets
-
>
FindReusableStyleSheet
(
aURL
sheet
)
)
{
if
(
aParentSheet
-
>
IsGecko
(
)
)
{
#
ifdef
MOZ_OLD_STYLE
aGeckoParentRule
-
>
SetSheet
(
sheet
-
>
AsGecko
(
)
)
;
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
state
=
eSheetComplete
;
}
else
{
bool
isAlternate
;
const
nsAString
&
empty
=
EmptyString
(
)
;
rv
=
CreateSheet
(
aURL
nullptr
principal
aParentSheet
-
>
ParsingMode
(
)
CORS_NONE
aParentSheet
-
>
GetReferrerPolicy
(
)
EmptyString
(
)
parentData
?
parentData
-
>
mSyncLoad
:
false
false
empty
state
&
isAlternate
&
sheet
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PrepareSheet
(
sheet
empty
empty
aMedia
nullptr
isAlternate
)
;
}
rv
=
InsertChildSheet
(
sheet
aParentSheet
aGeckoParentRule
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
state
=
=
eSheetComplete
)
{
LOG
(
(
"
Sheet
already
complete
"
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
requestingNode
=
do_QueryInterface
(
context
)
;
SheetLoadData
*
data
=
new
SheetLoadData
(
this
aURL
sheet
parentData
observer
principal
requestingNode
)
;
NS_ADDREF
(
data
)
;
bool
syncLoad
=
data
-
>
mSyncLoad
;
rv
=
LoadSheet
(
data
state
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
syncLoad
)
{
data
-
>
mMustNotify
=
true
;
}
return
rv
;
}
nsresult
Loader
:
:
LoadSheetSync
(
nsIURI
*
aURL
SheetParsingMode
aParsingMode
bool
aUseSystemPrincipal
RefPtr
<
StyleSheet
>
*
aSheet
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheetSync
"
)
)
;
return
InternalLoadNonDocumentSheet
(
aURL
false
aParsingMode
aUseSystemPrincipal
nullptr
nullptr
aSheet
nullptr
)
;
}
nsresult
Loader
:
:
LoadSheet
(
nsIURI
*
aURL
SheetParsingMode
aParsingMode
bool
aUseSystemPrincipal
nsICSSLoaderObserver
*
aObserver
RefPtr
<
StyleSheet
>
*
aSheet
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheet
(
aURL
aParsingMode
aUseSystemPrincipal
aObserver
aSheet
)
"
)
)
;
return
InternalLoadNonDocumentSheet
(
aURL
false
aParsingMode
aUseSystemPrincipal
nullptr
nullptr
aSheet
aObserver
)
;
}
nsresult
Loader
:
:
LoadSheet
(
nsIURI
*
aURL
nsIPrincipal
*
aOriginPrincipal
nsICSSLoaderObserver
*
aObserver
RefPtr
<
StyleSheet
>
*
aSheet
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheet
(
aURL
aObserver
aSheet
)
api
call
"
)
)
;
NS_PRECONDITION
(
aSheet
"
aSheet
is
null
"
)
;
return
InternalLoadNonDocumentSheet
(
aURL
false
eAuthorSheetFeatures
false
aOriginPrincipal
nullptr
aSheet
aObserver
)
;
}
nsresult
Loader
:
:
LoadSheet
(
nsIURI
*
aURL
bool
aIsPreload
nsIPrincipal
*
aOriginPrincipal
const
Encoding
*
aPreloadEncoding
nsICSSLoaderObserver
*
aObserver
CORSMode
aCORSMode
ReferrerPolicy
aReferrerPolicy
const
nsAString
&
aIntegrity
)
{
LOG
(
(
"
css
:
:
Loader
:
:
LoadSheet
(
aURL
aObserver
)
api
call
"
)
)
;
return
InternalLoadNonDocumentSheet
(
aURL
aIsPreload
eAuthorSheetFeatures
false
aOriginPrincipal
aPreloadEncoding
nullptr
aObserver
aCORSMode
aReferrerPolicy
aIntegrity
)
;
}
nsresult
Loader
:
:
InternalLoadNonDocumentSheet
(
nsIURI
*
aURL
bool
aIsPreload
SheetParsingMode
aParsingMode
bool
aUseSystemPrincipal
nsIPrincipal
*
aOriginPrincipal
const
Encoding
*
aPreloadEncoding
RefPtr
<
StyleSheet
>
*
aSheet
nsICSSLoaderObserver
*
aObserver
CORSMode
aCORSMode
ReferrerPolicy
aReferrerPolicy
const
nsAString
&
aIntegrity
)
{
NS_PRECONDITION
(
aURL
"
Must
have
a
URI
to
load
"
)
;
NS_PRECONDITION
(
aSheet
|
|
aObserver
"
Sheet
and
observer
can
'
t
both
be
null
"
)
;
NS_PRECONDITION
(
!
aUseSystemPrincipal
|
|
!
aObserver
"
Shouldn
'
t
load
system
-
principal
sheets
async
"
)
;
NS_ASSERTION
(
mParsingDatas
.
Length
(
)
=
=
0
"
We
'
re
in
the
middle
of
a
parse
?
"
)
;
LOG_URI
(
"
Non
-
document
sheet
uri
:
'
%
s
'
"
aURL
)
;
if
(
aSheet
)
{
*
aSheet
=
nullptr
;
}
if
(
!
mEnabled
)
{
LOG_WARN
(
(
"
Not
enabled
"
)
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
(
aOriginPrincipal
&
&
mDocument
?
mDocument
-
>
NodePrincipal
(
)
:
nullptr
)
;
nsresult
rv
=
CheckContentPolicy
(
loadingPrincipal
aOriginPrincipal
aURL
mDocument
aIsPreload
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
StyleSheetState
state
;
bool
isAlternate
;
RefPtr
<
StyleSheet
>
sheet
;
bool
syncLoad
=
(
aObserver
=
=
nullptr
)
;
const
nsAString
&
empty
=
EmptyString
(
)
;
rv
=
CreateSheet
(
aURL
nullptr
aOriginPrincipal
aParsingMode
aCORSMode
aReferrerPolicy
aIntegrity
syncLoad
false
empty
state
&
isAlternate
&
sheet
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PrepareSheet
(
sheet
empty
empty
nullptr
nullptr
isAlternate
)
;
if
(
state
=
=
eSheetComplete
)
{
LOG
(
(
"
Sheet
already
complete
"
)
)
;
if
(
aObserver
|
|
!
mObservers
.
IsEmpty
(
)
)
{
rv
=
PostLoadEvent
(
aURL
sheet
aObserver
false
nullptr
)
;
}
if
(
aSheet
)
{
sheet
.
swap
(
*
aSheet
)
;
}
return
rv
;
}
SheetLoadData
*
data
=
new
SheetLoadData
(
this
aURL
sheet
syncLoad
aUseSystemPrincipal
aPreloadEncoding
aObserver
aOriginPrincipal
mDocument
)
;
NS_ADDREF
(
data
)
;
rv
=
LoadSheet
(
data
state
aIsPreload
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aSheet
)
{
sheet
.
swap
(
*
aSheet
)
;
}
if
(
aObserver
)
{
data
-
>
mMustNotify
=
true
;
}
return
rv
;
}
nsresult
Loader
:
:
PostLoadEvent
(
nsIURI
*
aURI
StyleSheet
*
aSheet
nsICSSLoaderObserver
*
aObserver
bool
aWasAlternate
nsIStyleSheetLinkingElement
*
aElement
)
{
LOG
(
(
"
css
:
:
Loader
:
:
PostLoadEvent
"
)
)
;
NS_PRECONDITION
(
aSheet
"
Must
have
sheet
"
)
;
NS_PRECONDITION
(
aObserver
|
|
!
mObservers
.
IsEmpty
(
)
|
|
aElement
"
Must
have
observer
or
element
"
)
;
RefPtr
<
SheetLoadData
>
evt
=
new
SheetLoadData
(
this
EmptyString
(
)
aURI
aSheet
aElement
aWasAlternate
aObserver
nullptr
mDocument
)
;
if
(
!
mPostedEvents
.
AppendElement
(
evt
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsresult
rv
;
RefPtr
<
SheetLoadData
>
runnable
(
evt
)
;
if
(
mDocument
)
{
rv
=
mDocument
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
else
if
(
mDocGroup
)
{
rv
=
mDocGroup
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
else
{
rv
=
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
dispatch
stylesheet
load
event
"
)
;
mPostedEvents
.
RemoveElement
(
evt
)
;
}
else
{
if
(
mDocument
)
{
mDocument
-
>
BlockOnload
(
)
;
}
evt
-
>
mMustNotify
=
true
;
evt
-
>
mSheetAlreadyComplete
=
true
;
evt
-
>
ScheduleLoadEventIfNeeded
(
NS_OK
)
;
}
return
rv
;
}
void
Loader
:
:
HandleLoadEvent
(
SheetLoadData
*
aEvent
)
{
NS_ASSERTION
(
aEvent
-
>
mSheet
"
Must
have
sheet
"
)
;
mPostedEvents
.
RemoveElement
(
aEvent
)
;
if
(
!
aEvent
-
>
mIsCancelled
)
{
NS_ADDREF
(
aEvent
)
;
SheetComplete
(
aEvent
NS_OK
)
;
}
if
(
mDocument
)
{
mDocument
-
>
UnblockOnload
(
true
)
;
}
}
static
void
StopLoadingSheets
(
nsDataHashtable
<
URIPrincipalReferrerPolicyAndCORSModeHashKey
SheetLoadData
*
>
&
aDatas
Loader
:
:
LoadDataArray
&
aArr
)
{
for
(
auto
iter
=
aDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
SheetLoadData
*
data
=
iter
.
Data
(
)
;
MOZ_ASSERT
(
data
"
Must
have
a
data
!
"
)
;
data
-
>
mIsLoading
=
false
;
data
-
>
mIsCancelled
=
true
;
aArr
.
AppendElement
(
data
)
;
iter
.
Remove
(
)
;
}
}
nsresult
Loader
:
:
Stop
(
)
{
uint32_t
pendingCount
=
mSheets
?
mSheets
-
>
mPendingDatas
.
Count
(
)
:
0
;
uint32_t
loadingCount
=
mSheets
?
mSheets
-
>
mLoadingDatas
.
Count
(
)
:
0
;
LoadDataArray
arr
(
pendingCount
+
loadingCount
+
mPostedEvents
.
Length
(
)
)
;
if
(
pendingCount
)
{
StopLoadingSheets
(
mSheets
-
>
mPendingDatas
arr
)
;
}
if
(
loadingCount
)
{
StopLoadingSheets
(
mSheets
-
>
mLoadingDatas
arr
)
;
}
uint32_t
i
;
for
(
i
=
0
;
i
<
mPostedEvents
.
Length
(
)
;
+
+
i
)
{
SheetLoadData
*
data
=
mPostedEvents
[
i
]
;
data
-
>
mIsCancelled
=
true
;
if
(
arr
.
AppendElement
(
data
)
)
{
NS_ADDREF
(
data
)
;
}
#
ifdef
DEBUG
else
{
NS_NOTREACHED
(
"
We
preallocated
this
memory
.
.
.
shouldn
'
t
really
fail
"
"
except
we
never
check
that
preallocation
succeeds
.
"
)
;
}
#
endif
}
mPostedEvents
.
Clear
(
)
;
mDatasToNotifyOn
+
=
arr
.
Length
(
)
;
for
(
i
=
0
;
i
<
arr
.
Length
(
)
;
+
+
i
)
{
-
-
mDatasToNotifyOn
;
SheetComplete
(
arr
[
i
]
NS_BINDING_ABORTED
)
;
}
return
NS_OK
;
}
bool
Loader
:
:
HasPendingLoads
(
)
{
return
(
mSheets
&
&
mSheets
-
>
mLoadingDatas
.
Count
(
)
!
=
0
)
|
|
(
mSheets
&
&
mSheets
-
>
mPendingDatas
.
Count
(
)
!
=
0
)
|
|
mPostedEvents
.
Length
(
)
!
=
0
|
|
mDatasToNotifyOn
!
=
0
;
}
nsresult
Loader
:
:
AddObserver
(
nsICSSLoaderObserver
*
aObserver
)
{
NS_PRECONDITION
(
aObserver
"
Must
have
observer
"
)
;
if
(
mObservers
.
AppendElementUnlessExists
(
aObserver
)
)
{
return
NS_OK
;
}
return
NS_ERROR_OUT_OF_MEMORY
;
}
void
Loader
:
:
RemoveObserver
(
nsICSSLoaderObserver
*
aObserver
)
{
mObservers
.
RemoveElement
(
aObserver
)
;
}
void
Loader
:
:
StartAlternateLoads
(
)
{
NS_PRECONDITION
(
mSheets
"
Don
'
t
call
me
!
"
)
;
LoadDataArray
arr
(
mSheets
-
>
mPendingDatas
.
Count
(
)
)
;
for
(
auto
iter
=
mSheets
-
>
mPendingDatas
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
arr
.
AppendElement
(
iter
.
Data
(
)
)
;
iter
.
Remove
(
)
;
}
mDatasToNotifyOn
+
=
arr
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
arr
.
Length
(
)
;
+
+
i
)
{
-
-
mDatasToNotifyOn
;
LoadSheet
(
arr
[
i
]
eSheetNeedsParser
false
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Loader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Loader
)
if
(
tmp
-
>
mSheets
)
{
for
(
auto
iter
=
tmp
-
>
mSheets
-
>
mCompleteSheets
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
Sheet
cache
nsCSSLoader
"
)
;
cb
.
NoteXPCOMChild
(
iter
.
UserData
(
)
)
;
}
}
nsTObserverArray
<
nsCOMPtr
<
nsICSSLoaderObserver
>
>
:
:
ForwardIterator
it
(
tmp
-
>
mObservers
)
;
while
(
it
.
HasMore
(
)
)
{
ImplCycleCollectionTraverse
(
cb
it
.
GetNext
(
)
"
mozilla
:
:
css
:
:
Loader
.
mObservers
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Loader
)
if
(
tmp
-
>
mSheets
)
{
tmp
-
>
mSheets
-
>
mCompleteSheets
.
Clear
(
)
;
}
tmp
-
>
mObservers
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
Loader
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
Loader
Release
)
size_t
Loader
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
if
(
mSheets
)
{
n
+
=
mSheets
-
>
mCompleteSheets
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mSheets
-
>
mCompleteSheets
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
StyleSheet
*
sheet
=
iter
.
UserData
(
)
;
n
+
=
(
sheet
-
>
GetOwnerNode
(
)
|
|
sheet
-
>
GetParentSheet
(
)
)
?
0
:
sheet
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
n
+
=
mObservers
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
StyleBackendType
Loader
:
:
GetStyleBackendType
(
)
const
{
MOZ_ASSERT
(
mStyleBackendType
|
|
mDocument
"
you
must
construct
a
Loader
with
a
document
or
set
a
"
"
StyleBackendType
on
it
before
calling
GetStyleBackendType
"
)
;
if
(
mStyleBackendType
)
{
return
*
mStyleBackendType
;
}
return
mDocument
-
>
GetStyleBackendType
(
)
;
}
}
}
