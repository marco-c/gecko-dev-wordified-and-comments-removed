#
ifndef
mozilla_css_Loader_h
#
define
mozilla_css_Loader_h
#
include
<
tuple
>
#
include
<
utility
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
dom
/
LinkStyle
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
class
nsICSSLoaderObserver
;
class
nsIConsoleReportCollector
;
class
nsIContent
;
class
nsIPrincipal
;
namespace
mozilla
{
class
SharedStyleSheetCache
;
class
SheetLoadDataHashKey
;
class
StyleSheet
;
namespace
dom
{
class
DocGroup
;
class
Element
;
}
class
SheetLoadDataHashKey
:
public
PLDHashEntryHdr
{
public
:
enum
class
IsPreload
:
uint8_t
{
No
FromParser
FromLink
}
;
using
KeyType
=
const
SheetLoadDataHashKey
&
;
using
KeyTypePointer
=
const
SheetLoadDataHashKey
*
;
explicit
SheetLoadDataHashKey
(
const
SheetLoadDataHashKey
*
aKey
)
:
mURI
(
aKey
-
>
mURI
)
mPrincipal
(
aKey
-
>
mPrincipal
)
mLoaderPrincipal
(
aKey
-
>
mLoaderPrincipal
)
mReferrerInfo
(
aKey
-
>
mReferrerInfo
)
mEncodingGuess
(
aKey
-
>
mEncodingGuess
)
mCORSMode
(
aKey
-
>
mCORSMode
)
mParsingMode
(
aKey
-
>
mParsingMode
)
mCompatMode
(
aKey
-
>
mCompatMode
)
mSRIMetadata
(
aKey
-
>
mSRIMetadata
)
mIsLinkPreload
(
aKey
-
>
mIsLinkPreload
)
{
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
}
SheetLoadDataHashKey
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aLoaderPrincipal
nsIReferrerInfo
*
aReferrerInfo
NotNull
<
const
Encoding
*
>
aEncodingGuess
CORSMode
aCORSMode
css
:
:
SheetParsingMode
aParsingMode
nsCompatibility
aCompatMode
const
dom
:
:
SRIMetadata
&
aSRIMetadata
IsPreload
aIsPreload
)
:
mURI
(
aURI
)
mPrincipal
(
aPrincipal
)
mLoaderPrincipal
(
aLoaderPrincipal
)
mReferrerInfo
(
aReferrerInfo
)
mEncodingGuess
(
aEncodingGuess
)
mCORSMode
(
aCORSMode
)
mParsingMode
(
aParsingMode
)
mCompatMode
(
aCompatMode
)
mSRIMetadata
(
aSRIMetadata
)
mIsLinkPreload
(
aIsPreload
=
=
IsPreload
:
:
FromLink
)
{
MOZ_ASSERT
(
aURI
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aLoaderPrincipal
)
;
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
}
SheetLoadDataHashKey
(
SheetLoadDataHashKey
&
&
toMove
)
:
mURI
(
std
:
:
move
(
toMove
.
mURI
)
)
mPrincipal
(
std
:
:
move
(
toMove
.
mPrincipal
)
)
mLoaderPrincipal
(
std
:
:
move
(
toMove
.
mLoaderPrincipal
)
)
mReferrerInfo
(
std
:
:
move
(
toMove
.
mReferrerInfo
)
)
mEncodingGuess
(
std
:
:
move
(
toMove
.
mEncodingGuess
)
)
mCORSMode
(
std
:
:
move
(
toMove
.
mCORSMode
)
)
mParsingMode
(
std
:
:
move
(
toMove
.
mParsingMode
)
)
mCompatMode
(
std
:
:
move
(
toMove
.
mCompatMode
)
)
mSRIMetadata
(
std
:
:
move
(
toMove
.
mSRIMetadata
)
)
mIsLinkPreload
(
std
:
:
move
(
toMove
.
mIsLinkPreload
)
)
{
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
}
explicit
SheetLoadDataHashKey
(
const
css
:
:
SheetLoadData
&
)
;
MOZ_COUNTED_DTOR
(
SheetLoadDataHashKey
)
const
SheetLoadDataHashKey
&
GetKey
(
)
const
{
return
*
this
;
}
const
SheetLoadDataHashKey
*
GetKeyPointer
(
)
const
{
return
this
;
}
bool
KeyEquals
(
const
SheetLoadDataHashKey
*
aKey
)
const
{
return
KeyEquals
(
*
aKey
)
;
}
bool
KeyEquals
(
const
SheetLoadDataHashKey
&
aKey
)
const
{
{
bool
eq
;
if
(
NS_FAILED
(
mURI
-
>
Equals
(
aKey
.
mURI
&
eq
)
)
|
|
!
eq
)
{
return
false
;
}
}
if
(
!
mPrincipal
-
>
Equals
(
aKey
.
mPrincipal
)
)
{
return
false
;
}
if
(
mCORSMode
!
=
aKey
.
mCORSMode
)
{
return
false
;
}
if
(
mParsingMode
!
=
aKey
.
mParsingMode
)
{
return
false
;
}
if
(
mCompatMode
!
=
aKey
.
mCompatMode
)
{
return
false
;
}
if
(
mEncodingGuess
!
=
aKey
.
mEncodingGuess
)
{
return
false
;
}
if
(
mReferrerInfo
-
>
ReferrerPolicy
(
)
!
=
aKey
.
mReferrerInfo
-
>
ReferrerPolicy
(
)
)
{
return
false
;
}
if
(
mIsLinkPreload
!
=
aKey
.
mIsLinkPreload
)
{
const
auto
&
linkPreloadMetadata
=
mIsLinkPreload
?
mSRIMetadata
:
aKey
.
mSRIMetadata
;
const
auto
&
consumerPreloadMetadata
=
mIsLinkPreload
?
aKey
.
mSRIMetadata
:
mSRIMetadata
;
if
(
!
consumerPreloadMetadata
.
CanTrustBeDelegatedTo
(
linkPreloadMetadata
)
)
{
return
false
;
}
}
return
true
;
}
static
const
SheetLoadDataHashKey
*
KeyToPointer
(
const
SheetLoadDataHashKey
&
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
const
SheetLoadDataHashKey
*
aKey
)
{
return
nsURIHashKey
:
:
HashKey
(
aKey
-
>
mURI
)
;
}
nsIURI
*
URI
(
)
const
{
return
mURI
;
}
nsIPrincipal
*
Principal
(
)
const
{
return
mPrincipal
;
}
nsIPrincipal
*
LoaderPrincipal
(
)
const
{
return
mLoaderPrincipal
;
}
css
:
:
SheetParsingMode
ParsingMode
(
)
const
{
return
mParsingMode
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
protected
:
const
nsCOMPtr
<
nsIURI
>
mURI
;
const
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
const
nsCOMPtr
<
nsIPrincipal
>
mLoaderPrincipal
;
const
nsCOMPtr
<
nsIReferrerInfo
>
mReferrerInfo
;
const
NotNull
<
const
Encoding
*
>
mEncodingGuess
;
const
CORSMode
mCORSMode
;
const
css
:
:
SheetParsingMode
mParsingMode
;
const
nsCompatibility
mCompatMode
;
dom
:
:
SRIMetadata
mSRIMetadata
;
const
bool
mIsLinkPreload
;
}
;
namespace
css
{
class
SheetLoadData
;
class
ImportRule
;
class
MOZ_RAII
LoaderReusableStyleSheets
{
public
:
LoaderReusableStyleSheets
(
)
=
default
;
bool
FindReusableStyleSheet
(
nsIURI
*
aURL
RefPtr
<
StyleSheet
>
&
aResult
)
;
void
AddReusableSheet
(
StyleSheet
*
aSheet
)
{
mReusableSheets
.
AppendElement
(
aSheet
)
;
}
private
:
LoaderReusableStyleSheets
(
const
LoaderReusableStyleSheets
&
)
=
delete
;
LoaderReusableStyleSheets
&
operator
=
(
const
LoaderReusableStyleSheets
&
)
=
delete
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
mReusableSheets
;
}
;
class
Loader
final
{
using
ReferrerPolicy
=
dom
:
:
ReferrerPolicy
;
public
:
using
Completed
=
dom
:
:
LinkStyle
:
:
Completed
;
using
HasAlternateRel
=
dom
:
:
LinkStyle
:
:
HasAlternateRel
;
using
IsAlternate
=
dom
:
:
LinkStyle
:
:
IsAlternate
;
using
IsInline
=
dom
:
:
LinkStyle
:
:
IsInline
;
using
IsExplicitlyEnabled
=
dom
:
:
LinkStyle
:
:
IsExplicitlyEnabled
;
using
MediaMatched
=
dom
:
:
LinkStyle
:
:
MediaMatched
;
using
LoadSheetResult
=
dom
:
:
LinkStyle
:
:
Update
;
using
SheetInfo
=
dom
:
:
LinkStyle
:
:
SheetInfo
;
Loader
(
)
;
explicit
Loader
(
dom
:
:
DocGroup
*
)
;
explicit
Loader
(
dom
:
:
Document
*
)
;
private
:
~
Loader
(
)
;
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
Loader
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
Loader
)
void
DropDocumentReference
(
)
;
void
DeregisterFromSheetCache
(
)
;
void
RegisterInSheetCache
(
)
;
void
SetCompatibilityMode
(
nsCompatibility
aCompatMode
)
{
mCompatMode
=
aCompatMode
;
}
nsCompatibility
GetCompatibilityMode
(
)
{
return
mCompatMode
;
}
void
DocumentStyleSheetSetChanged
(
)
;
Result
<
LoadSheetResult
nsresult
>
LoadInlineStyle
(
const
SheetInfo
&
const
nsAString
&
aBuffer
uint32_t
aLineNumber
nsICSSLoaderObserver
*
aObserver
)
;
Result
<
LoadSheetResult
nsresult
>
LoadStyleLink
(
const
SheetInfo
&
nsICSSLoaderObserver
*
aObserver
)
;
nsresult
LoadChildSheet
(
StyleSheet
&
aParentSheet
SheetLoadData
*
aParentData
nsIURI
*
aURL
dom
:
:
MediaList
*
aMedia
LoaderReusableStyleSheets
*
aSavedSheets
)
;
enum
class
UseSystemPrincipal
{
No
Yes
}
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
LoadSheetSync
(
nsIURI
*
SheetParsingMode
=
eAuthorSheetFeatures
UseSystemPrincipal
=
UseSystemPrincipal
:
:
No
)
;
using
IsPreload
=
SheetLoadDataHashKey
:
:
IsPreload
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
LoadSheet
(
nsIURI
*
aURI
IsPreload
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
CORSMode
=
CORS_NONE
const
nsAString
&
aIntegrity
=
EmptyString
(
)
)
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
LoadSheet
(
nsIURI
*
SheetParsingMode
UseSystemPrincipal
nsICSSLoaderObserver
*
)
;
void
Stop
(
)
;
bool
GetEnabled
(
)
{
return
mEnabled
;
}
void
SetEnabled
(
bool
aEnabled
)
{
mEnabled
=
aEnabled
;
}
uint32_t
ParsedSheetCount
(
)
const
{
return
mParsedSheetCount
;
}
dom
:
:
Document
*
GetDocument
(
)
const
{
return
mDocument
;
}
bool
HasPendingLoads
(
)
;
void
AddObserver
(
nsICSSLoaderObserver
*
aObserver
)
;
void
RemoveObserver
(
nsICSSLoaderObserver
*
aObserver
)
;
IsAlternate
IsAlternateSheet
(
const
nsAString
&
aTitle
bool
aHasAlternateRel
)
;
typedef
nsTArray
<
RefPtr
<
SheetLoadData
>
>
LoadDataArray
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
enum
class
SheetState
:
uint8_t
{
NeedsParser
=
0
Pending
Loading
Complete
}
;
nsIPrincipal
*
LoaderPrincipal
(
)
const
;
private
:
friend
class
mozilla
:
:
SharedStyleSheetCache
;
friend
class
SheetLoadData
;
friend
class
StreamLoader
;
void
BlockOnload
(
)
;
void
UnblockOnload
(
bool
aFireSync
)
;
already_AddRefed
<
nsISerialEventTarget
>
DispatchTarget
(
)
;
nsresult
CheckContentPolicy
(
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
nsIURI
*
aTargetURI
nsINode
*
aRequestingNode
const
nsAString
&
aNonce
IsPreload
)
;
std
:
:
tuple
<
RefPtr
<
StyleSheet
>
SheetState
>
CreateSheet
(
const
SheetInfo
&
aInfo
css
:
:
SheetParsingMode
aParsingMode
bool
aSyncLoad
IsPreload
aIsPreload
)
{
nsIPrincipal
*
triggeringPrincipal
=
aInfo
.
mTriggeringPrincipal
?
aInfo
.
mTriggeringPrincipal
.
get
(
)
:
LoaderPrincipal
(
)
;
return
CreateSheet
(
aInfo
.
mURI
aInfo
.
mContent
triggeringPrincipal
aParsingMode
aInfo
.
mCORSMode
aInfo
.
mReferrerInfo
nullptr
aInfo
.
mIntegrity
aSyncLoad
aIsPreload
)
;
}
std
:
:
tuple
<
RefPtr
<
StyleSheet
>
SheetState
>
CreateSheet
(
nsIURI
*
aURI
nsIContent
*
aLinkingContent
nsIPrincipal
*
aTriggeringPrincipal
css
:
:
SheetParsingMode
CORSMode
nsIReferrerInfo
*
aLoadingReferrerInfo
const
Encoding
*
aPreloadOrParentDataEncoding
const
nsAString
&
aIntegrity
bool
aSyncLoad
IsPreload
aIsPreload
)
;
MediaMatched
PrepareSheet
(
StyleSheet
&
const
nsAString
&
aTitle
const
nsAString
&
aMediaString
dom
:
:
MediaList
*
IsAlternate
IsExplicitlyEnabled
)
;
void
InsertSheetInTree
(
StyleSheet
&
aSheet
nsIContent
*
aLinkingContent
)
;
void
InsertChildSheet
(
StyleSheet
&
aSheet
StyleSheet
&
aParentSheet
)
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
InternalLoadNonDocumentSheet
(
nsIURI
*
aURL
IsPreload
SheetParsingMode
aParsingMode
UseSystemPrincipal
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
CORSMode
aCORSMode
const
nsAString
&
aIntegrity
)
;
RefPtr
<
StyleSheet
>
LookupInlineSheetInCache
(
const
nsAString
&
)
;
nsresult
PostLoadEvent
(
RefPtr
<
SheetLoadData
>
)
;
void
StartDeferredLoads
(
)
;
void
HandleLoadEvent
(
SheetLoadData
&
)
;
nsresult
LoadSheet
(
SheetLoadData
&
SheetState
)
;
enum
class
AllowAsyncParse
{
Yes
No
}
;
Completed
ParseSheet
(
const
nsACString
&
SheetLoadData
&
AllowAsyncParse
)
;
void
SheetComplete
(
SheetLoadData
&
nsresult
)
;
void
NotifyObservers
(
SheetLoadData
&
nsresult
)
;
static
void
MarkLoadTreeFailed
(
SheetLoadData
&
Loader
*
aOnlyForLoader
=
nullptr
)
;
nsRefPtrHashtable
<
nsStringHashKey
StyleSheet
>
mInlineSheets
;
nsTHashtable
<
const
SheetLoadDataHashKey
>
mLoadsPerformed
;
RefPtr
<
SharedStyleSheetCache
>
mSheets
;
LoadDataArray
mPostedEvents
;
nsTObserverArray
<
nsCOMPtr
<
nsICSSLoaderObserver
>
>
mObservers
;
dom
:
:
Document
*
MOZ_NON_OWNING_REF
mDocument
;
RefPtr
<
dom
:
:
DocGroup
>
mDocGroup
;
nsCompatibility
mCompatMode
;
nsCOMPtr
<
nsIConsoleReportCollector
>
mReporter
;
uint32_t
mOngoingLoadCount
=
0
;
uint32_t
mPendingLoadCount
=
0
;
uint32_t
mParsedSheetCount
=
0
;
bool
mEnabled
=
true
;
#
ifdef
DEBUG
bool
mSyncCallback
=
false
;
#
endif
}
;
}
}
#
endif
