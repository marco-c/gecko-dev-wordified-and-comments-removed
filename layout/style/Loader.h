#
ifndef
mozilla_css_Loader_h
#
define
mozilla_css_Loader_h
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsIStyleSheetLinkingElement
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
class
nsICSSLoaderObserver
;
class
nsIConsoleReportCollector
;
class
nsIContent
;
namespace
mozilla
{
namespace
dom
{
class
DocGroup
;
class
Element
;
}
}
namespace
mozilla
{
namespace
css
{
class
SheetLoadData
;
class
ImportRule
;
class
MOZ_RAII
LoaderReusableStyleSheets
{
public
:
LoaderReusableStyleSheets
(
)
{
}
bool
FindReusableStyleSheet
(
nsIURI
*
aURL
RefPtr
<
StyleSheet
>
&
aResult
)
;
void
AddReusableSheet
(
StyleSheet
*
aSheet
)
{
mReusableSheets
.
AppendElement
(
aSheet
)
;
}
private
:
LoaderReusableStyleSheets
(
const
LoaderReusableStyleSheets
&
)
=
delete
;
LoaderReusableStyleSheets
&
operator
=
(
const
LoaderReusableStyleSheets
&
)
=
delete
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
mReusableSheets
;
}
;
class
Loader
final
{
using
ReferrerPolicy
=
dom
:
:
ReferrerPolicy
;
public
:
typedef
nsIStyleSheetLinkingElement
:
:
Completed
Completed
;
typedef
nsIStyleSheetLinkingElement
:
:
HasAlternateRel
HasAlternateRel
;
typedef
nsIStyleSheetLinkingElement
:
:
IsAlternate
IsAlternate
;
typedef
nsIStyleSheetLinkingElement
:
:
IsInline
IsInline
;
typedef
nsIStyleSheetLinkingElement
:
:
IsExplicitlyEnabled
IsExplicitlyEnabled
;
typedef
nsIStyleSheetLinkingElement
:
:
MediaMatched
MediaMatched
;
typedef
nsIStyleSheetLinkingElement
:
:
Update
LoadSheetResult
;
typedef
nsIStyleSheetLinkingElement
:
:
SheetInfo
SheetInfo
;
Loader
(
)
;
explicit
Loader
(
dom
:
:
DocGroup
*
)
;
explicit
Loader
(
dom
:
:
Document
*
)
;
private
:
~
Loader
(
)
;
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
Loader
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
Loader
)
void
DropDocumentReference
(
)
;
void
SetCompatibilityMode
(
nsCompatibility
aCompatMode
)
{
mCompatMode
=
aCompatMode
;
}
nsCompatibility
GetCompatibilityMode
(
)
{
return
mCompatMode
;
}
void
DocumentStyleSheetSetChanged
(
)
;
Result
<
LoadSheetResult
nsresult
>
LoadInlineStyle
(
const
SheetInfo
&
const
nsAString
&
aBuffer
uint32_t
aLineNumber
nsICSSLoaderObserver
*
aObserver
)
;
Result
<
LoadSheetResult
nsresult
>
LoadStyleLink
(
const
SheetInfo
&
nsICSSLoaderObserver
*
aObserver
)
;
nsresult
LoadChildSheet
(
StyleSheet
&
aParentSheet
SheetLoadData
*
aParentData
nsIURI
*
aURL
dom
:
:
MediaList
*
aMedia
LoaderReusableStyleSheets
*
aSavedSheets
)
;
enum
class
UseSystemPrincipal
{
No
Yes
}
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
LoadSheetSync
(
nsIURI
*
SheetParsingMode
=
eAuthorSheetFeatures
UseSystemPrincipal
=
UseSystemPrincipal
:
:
No
)
;
enum
class
IsPreload
{
No
FromParser
FromLink
}
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
LoadSheet
(
nsIURI
*
aURI
IsPreload
nsIPrincipal
*
aOriginPrincipal
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
CORSMode
aCORSMode
=
CORS_NONE
const
nsAString
&
aIntegrity
=
EmptyString
(
)
)
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
LoadSheet
(
nsIURI
*
SheetParsingMode
UseSystemPrincipal
nsICSSLoaderObserver
*
)
;
void
Stop
(
)
;
bool
GetEnabled
(
)
{
return
mEnabled
;
}
void
SetEnabled
(
bool
aEnabled
)
{
mEnabled
=
aEnabled
;
}
dom
:
:
Document
*
GetDocument
(
)
const
{
return
mDocument
;
}
bool
HasPendingLoads
(
)
;
void
AddObserver
(
nsICSSLoaderObserver
*
aObserver
)
;
void
RemoveObserver
(
nsICSSLoaderObserver
*
aObserver
)
;
IsAlternate
IsAlternateSheet
(
const
nsAString
&
aTitle
bool
aHasAlternateRel
)
;
typedef
nsTArray
<
RefPtr
<
SheetLoadData
>
>
LoadDataArray
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
friend
class
SheetLoadData
;
friend
class
StreamLoader
;
void
BlockOnload
(
)
;
void
UnblockOnload
(
bool
aFireSync
)
;
already_AddRefed
<
nsISerialEventTarget
>
DispatchTarget
(
)
;
nsresult
CheckContentPolicy
(
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
nsIURI
*
aTargetURI
nsINode
*
aRequestingNode
IsPreload
)
;
enum
class
SheetState
:
uint8_t
{
Unknown
=
0
NeedsParser
Pending
Loading
Complete
}
;
Tuple
<
RefPtr
<
StyleSheet
>
SheetState
>
CreateSheet
(
const
SheetInfo
&
aInfo
nsIPrincipal
*
aLoaderPrincipal
css
:
:
SheetParsingMode
aParsingMode
bool
aSyncLoad
)
{
return
CreateSheet
(
aInfo
.
mURI
aInfo
.
mContent
aLoaderPrincipal
aParsingMode
aInfo
.
mCORSMode
aInfo
.
mReferrerInfo
aInfo
.
mIntegrity
aSyncLoad
)
;
}
Tuple
<
RefPtr
<
StyleSheet
>
SheetState
>
CreateSheet
(
nsIURI
*
aURI
nsIContent
*
aLinkingContent
nsIPrincipal
*
aLoaderPrincipal
css
:
:
SheetParsingMode
CORSMode
nsIReferrerInfo
*
aLoadingReferrerInfo
const
nsAString
&
aIntegrity
bool
aSyncLoad
)
;
MediaMatched
PrepareSheet
(
StyleSheet
&
const
nsAString
&
aTitle
const
nsAString
&
aMediaString
dom
:
:
MediaList
*
IsAlternate
IsExplicitlyEnabled
)
;
void
InsertSheetInTree
(
StyleSheet
&
aSheet
nsIContent
*
aLinkingContent
)
;
void
InsertChildSheet
(
StyleSheet
&
aSheet
StyleSheet
&
aParentSheet
)
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
InternalLoadNonDocumentSheet
(
nsIURI
*
aURL
IsPreload
SheetParsingMode
aParsingMode
UseSystemPrincipal
nsIPrincipal
*
aOriginPrincipal
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
CORSMode
aCORSMode
const
nsAString
&
aIntegrity
)
;
nsresult
PostLoadEvent
(
nsIURI
*
aURI
StyleSheet
*
aSheet
nsICSSLoaderObserver
*
aObserver
IsAlternate
aWasAlternate
MediaMatched
aMediaMatched
nsIReferrerInfo
*
aReferrerInfo
nsIStyleSheetLinkingElement
*
aElement
)
;
void
StartDeferredLoads
(
)
;
void
HandleLoadEvent
(
SheetLoadData
&
)
;
nsresult
LoadSheet
(
SheetLoadData
&
SheetState
IsPreload
)
;
enum
class
AllowAsyncParse
{
Yes
No
}
;
Completed
ParseSheet
(
const
nsACString
&
SheetLoadData
&
AllowAsyncParse
)
;
void
SheetComplete
(
SheetLoadData
&
nsresult
aStatus
)
;
void
DoSheetComplete
(
SheetLoadData
&
LoadDataArray
&
aDatasToNotify
)
;
void
MarkLoadTreeFailed
(
SheetLoadData
&
)
;
struct
Sheets
;
UniquePtr
<
Sheets
>
mSheets
;
LoadDataArray
mPostedEvents
;
nsTObserverArray
<
nsCOMPtr
<
nsICSSLoaderObserver
>
>
mObservers
;
dom
:
:
Document
*
MOZ_NON_OWNING_REF
mDocument
;
RefPtr
<
dom
:
:
DocGroup
>
mDocGroup
;
uint32_t
mDatasToNotifyOn
;
nsCompatibility
mCompatMode
;
bool
mEnabled
;
nsCOMPtr
<
nsIConsoleReportCollector
>
mReporter
;
#
ifdef
DEBUG
bool
mSyncCallback
=
false
;
#
endif
}
;
}
}
#
endif
