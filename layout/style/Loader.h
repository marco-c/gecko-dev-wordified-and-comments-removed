#
ifndef
mozilla_css_Loader_h
#
define
mozilla_css_Loader_h
#
include
<
tuple
>
#
include
<
utility
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
css
/
StylePreloadKind
.
h
"
#
include
"
mozilla
/
dom
/
LinkStyle
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
class
nsICSSLoaderObserver
;
class
nsIConsoleReportCollector
;
class
nsIContent
;
class
nsIPrincipal
;
namespace
mozilla
{
class
PreloadHashKey
;
class
SharedStyleSheetCache
;
class
SheetLoadDataHashKey
;
class
StyleSheet
;
namespace
dom
{
class
DocGroup
;
class
Element
;
}
class
SheetLoadDataHashKey
:
public
PLDHashEntryHdr
{
public
:
using
KeyType
=
const
SheetLoadDataHashKey
&
;
using
KeyTypePointer
=
const
SheetLoadDataHashKey
*
;
explicit
SheetLoadDataHashKey
(
const
SheetLoadDataHashKey
*
aKey
)
:
mURI
(
aKey
-
>
mURI
)
mPrincipal
(
aKey
-
>
mPrincipal
)
mLoaderPrincipal
(
aKey
-
>
mLoaderPrincipal
)
mPartitionPrincipal
(
aKey
-
>
mPartitionPrincipal
)
mEncodingGuess
(
aKey
-
>
mEncodingGuess
)
mCORSMode
(
aKey
-
>
mCORSMode
)
mParsingMode
(
aKey
-
>
mParsingMode
)
mCompatMode
(
aKey
-
>
mCompatMode
)
mSRIMetadata
(
aKey
-
>
mSRIMetadata
)
mIsLinkRelPreload
(
aKey
-
>
mIsLinkRelPreload
)
{
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
}
SheetLoadDataHashKey
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aLoaderPrincipal
nsIPrincipal
*
aPartitionPrincipal
NotNull
<
const
Encoding
*
>
aEncodingGuess
CORSMode
aCORSMode
css
:
:
SheetParsingMode
aParsingMode
nsCompatibility
aCompatMode
const
dom
:
:
SRIMetadata
&
aSRIMetadata
css
:
:
StylePreloadKind
aPreloadKind
)
:
mURI
(
aURI
)
mPrincipal
(
aPrincipal
)
mLoaderPrincipal
(
aLoaderPrincipal
)
mPartitionPrincipal
(
aPartitionPrincipal
)
mEncodingGuess
(
aEncodingGuess
)
mCORSMode
(
aCORSMode
)
mParsingMode
(
aParsingMode
)
mCompatMode
(
aCompatMode
)
mSRIMetadata
(
aSRIMetadata
)
mIsLinkRelPreload
(
IsLinkRelPreload
(
aPreloadKind
)
)
{
MOZ_ASSERT
(
aURI
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aLoaderPrincipal
)
;
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
}
SheetLoadDataHashKey
(
SheetLoadDataHashKey
&
&
toMove
)
:
mURI
(
std
:
:
move
(
toMove
.
mURI
)
)
mPrincipal
(
std
:
:
move
(
toMove
.
mPrincipal
)
)
mLoaderPrincipal
(
std
:
:
move
(
toMove
.
mLoaderPrincipal
)
)
mPartitionPrincipal
(
std
:
:
move
(
toMove
.
mPartitionPrincipal
)
)
mEncodingGuess
(
std
:
:
move
(
toMove
.
mEncodingGuess
)
)
mCORSMode
(
std
:
:
move
(
toMove
.
mCORSMode
)
)
mParsingMode
(
std
:
:
move
(
toMove
.
mParsingMode
)
)
mCompatMode
(
std
:
:
move
(
toMove
.
mCompatMode
)
)
mSRIMetadata
(
std
:
:
move
(
toMove
.
mSRIMetadata
)
)
mIsLinkRelPreload
(
std
:
:
move
(
toMove
.
mIsLinkRelPreload
)
)
{
MOZ_COUNT_CTOR
(
SheetLoadDataHashKey
)
;
}
explicit
SheetLoadDataHashKey
(
const
css
:
:
SheetLoadData
&
)
;
MOZ_COUNTED_DTOR
(
SheetLoadDataHashKey
)
const
SheetLoadDataHashKey
&
GetKey
(
)
const
{
return
*
this
;
}
const
SheetLoadDataHashKey
*
GetKeyPointer
(
)
const
{
return
this
;
}
bool
KeyEquals
(
const
SheetLoadDataHashKey
*
aKey
)
const
{
return
KeyEquals
(
*
aKey
)
;
}
bool
KeyEquals
(
const
SheetLoadDataHashKey
&
)
const
;
static
const
SheetLoadDataHashKey
*
KeyToPointer
(
const
SheetLoadDataHashKey
&
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
const
SheetLoadDataHashKey
*
aKey
)
{
return
nsURIHashKey
:
:
HashKey
(
aKey
-
>
mURI
)
;
}
nsIURI
*
URI
(
)
const
{
return
mURI
;
}
nsIPrincipal
*
Principal
(
)
const
{
return
mPrincipal
;
}
nsIPrincipal
*
LoaderPrincipal
(
)
const
{
return
mLoaderPrincipal
;
}
nsIPrincipal
*
PartitionPrincipal
(
)
const
{
return
mPartitionPrincipal
;
}
css
:
:
SheetParsingMode
ParsingMode
(
)
const
{
return
mParsingMode
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
protected
:
const
nsCOMPtr
<
nsIURI
>
mURI
;
const
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
const
nsCOMPtr
<
nsIPrincipal
>
mLoaderPrincipal
;
const
nsCOMPtr
<
nsIPrincipal
>
mPartitionPrincipal
;
const
NotNull
<
const
Encoding
*
>
mEncodingGuess
;
const
CORSMode
mCORSMode
;
const
css
:
:
SheetParsingMode
mParsingMode
;
const
nsCompatibility
mCompatMode
;
dom
:
:
SRIMetadata
mSRIMetadata
;
const
bool
mIsLinkRelPreload
;
}
;
namespace
css
{
class
SheetLoadData
;
class
ImportRule
;
class
MOZ_RAII
LoaderReusableStyleSheets
{
public
:
LoaderReusableStyleSheets
(
)
=
default
;
bool
FindReusableStyleSheet
(
nsIURI
*
aURL
RefPtr
<
StyleSheet
>
&
aResult
)
;
void
AddReusableSheet
(
StyleSheet
*
aSheet
)
{
mReusableSheets
.
AppendElement
(
aSheet
)
;
}
private
:
LoaderReusableStyleSheets
(
const
LoaderReusableStyleSheets
&
)
=
delete
;
LoaderReusableStyleSheets
&
operator
=
(
const
LoaderReusableStyleSheets
&
)
=
delete
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
mReusableSheets
;
}
;
class
Loader
final
{
using
ReferrerPolicy
=
dom
:
:
ReferrerPolicy
;
public
:
using
Completed
=
dom
:
:
LinkStyle
:
:
Completed
;
using
HasAlternateRel
=
dom
:
:
LinkStyle
:
:
HasAlternateRel
;
using
IsAlternate
=
dom
:
:
LinkStyle
:
:
IsAlternate
;
using
IsInline
=
dom
:
:
LinkStyle
:
:
IsInline
;
using
IsExplicitlyEnabled
=
dom
:
:
LinkStyle
:
:
IsExplicitlyEnabled
;
using
MediaMatched
=
dom
:
:
LinkStyle
:
:
MediaMatched
;
using
LoadSheetResult
=
dom
:
:
LinkStyle
:
:
Update
;
using
SheetInfo
=
dom
:
:
LinkStyle
:
:
SheetInfo
;
Loader
(
)
;
explicit
Loader
(
dom
:
:
DocGroup
*
)
;
explicit
Loader
(
dom
:
:
Document
*
)
;
private
:
~
Loader
(
)
;
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
Loader
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
Loader
)
void
DropDocumentReference
(
)
;
void
DeregisterFromSheetCache
(
)
;
void
RegisterInSheetCache
(
)
;
void
SetCompatibilityMode
(
nsCompatibility
aCompatMode
)
{
mDocumentCompatMode
=
aCompatMode
;
}
using
StylePreloadKind
=
css
:
:
StylePreloadKind
;
nsCompatibility
CompatMode
(
StylePreloadKind
aPreloadKind
)
const
{
if
(
aPreloadKind
=
=
StylePreloadKind
:
:
FromLinkRelPreloadHeader
)
{
return
eCompatibility_FullStandards
;
}
return
mDocumentCompatMode
;
}
void
DocumentStyleSheetSetChanged
(
)
;
Result
<
LoadSheetResult
nsresult
>
LoadInlineStyle
(
const
SheetInfo
&
const
nsAString
&
aBuffer
uint32_t
aLineNumber
nsICSSLoaderObserver
*
aObserver
)
;
Result
<
LoadSheetResult
nsresult
>
LoadStyleLink
(
const
SheetInfo
&
nsICSSLoaderObserver
*
aObserver
)
;
nsresult
LoadChildSheet
(
StyleSheet
&
aParentSheet
SheetLoadData
*
aParentData
nsIURI
*
aURL
dom
:
:
MediaList
*
aMedia
LoaderReusableStyleSheets
*
aSavedSheets
)
;
void
DidHitCompleteSheetCache
(
const
SheetLoadDataHashKey
&
const
StyleUseCounters
*
aCounters
)
;
enum
class
UseSystemPrincipal
{
No
Yes
}
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
LoadSheetSync
(
nsIURI
*
SheetParsingMode
=
eAuthorSheetFeatures
UseSystemPrincipal
=
UseSystemPrincipal
:
:
No
)
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
LoadSheet
(
nsIURI
*
aURI
StylePreloadKind
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
CORSMode
=
CORS_NONE
const
nsAString
&
aIntegrity
=
u
"
"
_ns
)
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
LoadSheet
(
nsIURI
*
SheetParsingMode
UseSystemPrincipal
nsICSSLoaderObserver
*
)
;
void
Stop
(
)
;
bool
GetEnabled
(
)
{
return
mEnabled
;
}
void
SetEnabled
(
bool
aEnabled
)
{
mEnabled
=
aEnabled
;
}
uint32_t
ParsedSheetCount
(
)
const
{
return
mParsedSheetCount
;
}
dom
:
:
Document
*
GetDocument
(
)
const
{
return
mDocument
;
}
bool
HasPendingLoads
(
)
;
void
AddObserver
(
nsICSSLoaderObserver
*
aObserver
)
;
void
RemoveObserver
(
nsICSSLoaderObserver
*
aObserver
)
;
IsAlternate
IsAlternateSheet
(
const
nsAString
&
aTitle
bool
aHasAlternateRel
)
;
typedef
nsTArray
<
RefPtr
<
SheetLoadData
>
>
LoadDataArray
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
enum
class
SheetState
:
uint8_t
{
NeedsParser
=
0
Pending
Loading
Complete
}
;
nsIPrincipal
*
LoaderPrincipal
(
)
const
;
nsIPrincipal
*
PartitionedPrincipal
(
)
const
;
bool
ShouldBypassCache
(
)
const
;
private
:
friend
class
mozilla
:
:
SharedStyleSheetCache
;
friend
class
SheetLoadData
;
friend
class
StreamLoader
;
void
IncrementOngoingLoadCount
(
)
{
if
(
!
mOngoingLoadCount
+
+
)
{
BlockOnload
(
)
;
}
}
void
DecrementOngoingLoadCount
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOngoingLoadCount
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mOngoingLoadCount
>
mPendingLoadCount
)
;
if
(
!
-
-
mOngoingLoadCount
)
{
UnblockOnload
(
false
)
;
}
}
void
BlockOnload
(
)
;
void
UnblockOnload
(
bool
aFireSync
)
;
already_AddRefed
<
nsISerialEventTarget
>
DispatchTarget
(
)
;
nsresult
CheckContentPolicy
(
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
nsIURI
*
aTargetURI
nsINode
*
aRequestingNode
const
nsAString
&
aNonce
StylePreloadKind
)
;
std
:
:
tuple
<
RefPtr
<
StyleSheet
>
SheetState
>
CreateSheet
(
const
SheetInfo
&
aInfo
css
:
:
SheetParsingMode
aParsingMode
bool
aSyncLoad
css
:
:
StylePreloadKind
aPreloadKind
)
{
nsIPrincipal
*
triggeringPrincipal
=
aInfo
.
mTriggeringPrincipal
?
aInfo
.
mTriggeringPrincipal
.
get
(
)
:
LoaderPrincipal
(
)
;
return
CreateSheet
(
aInfo
.
mURI
aInfo
.
mContent
triggeringPrincipal
aParsingMode
aInfo
.
mCORSMode
nullptr
aInfo
.
mIntegrity
aSyncLoad
aPreloadKind
)
;
}
std
:
:
tuple
<
RefPtr
<
StyleSheet
>
SheetState
>
CreateSheet
(
nsIURI
*
aURI
nsIContent
*
aLinkingContent
nsIPrincipal
*
aTriggeringPrincipal
css
:
:
SheetParsingMode
CORSMode
const
Encoding
*
aPreloadOrParentDataEncoding
const
nsAString
&
aIntegrity
bool
aSyncLoad
StylePreloadKind
)
;
MediaMatched
PrepareSheet
(
StyleSheet
&
const
nsAString
&
aTitle
const
nsAString
&
aMediaString
dom
:
:
MediaList
*
IsAlternate
IsExplicitlyEnabled
)
;
void
InsertSheetInTree
(
StyleSheet
&
aSheet
nsINode
*
aOwningNode
)
;
void
InsertChildSheet
(
StyleSheet
&
aSheet
StyleSheet
&
aParentSheet
)
;
Result
<
RefPtr
<
StyleSheet
>
nsresult
>
InternalLoadNonDocumentSheet
(
nsIURI
*
aURL
StylePreloadKind
SheetParsingMode
aParsingMode
UseSystemPrincipal
const
Encoding
*
aPreloadEncoding
nsIReferrerInfo
*
aReferrerInfo
nsICSSLoaderObserver
*
aObserver
CORSMode
aCORSMode
const
nsAString
&
aIntegrity
)
;
RefPtr
<
StyleSheet
>
LookupInlineSheetInCache
(
const
nsAString
&
)
;
nsresult
PostLoadEvent
(
RefPtr
<
SheetLoadData
>
)
;
void
StartDeferredLoads
(
)
;
void
HandleLoadEvent
(
SheetLoadData
&
)
;
enum
class
PendingLoad
{
No
Yes
}
;
nsresult
LoadSheet
(
SheetLoadData
&
SheetState
PendingLoad
=
PendingLoad
:
:
No
)
;
enum
class
AllowAsyncParse
{
Yes
No
}
;
Completed
ParseSheet
(
const
nsACString
&
SheetLoadData
&
AllowAsyncParse
)
;
void
SheetComplete
(
SheetLoadData
&
nsresult
)
;
void
NotifyObservers
(
SheetLoadData
&
nsresult
)
;
static
void
MarkLoadTreeFailed
(
SheetLoadData
&
Loader
*
aOnlyForLoader
=
nullptr
)
;
void
MaybeNotifyPreloadUsed
(
SheetLoadData
&
)
;
nsRefPtrHashtable
<
nsStringHashKey
StyleSheet
>
mInlineSheets
;
nsTHashtable
<
const
SheetLoadDataHashKey
>
mLoadsPerformed
;
RefPtr
<
SharedStyleSheetCache
>
mSheets
;
LoadDataArray
mPostedEvents
;
nsTObserverArray
<
nsCOMPtr
<
nsICSSLoaderObserver
>
>
mObservers
;
dom
:
:
Document
*
MOZ_NON_OWNING_REF
mDocument
;
RefPtr
<
dom
:
:
DocGroup
>
mDocGroup
;
nsCompatibility
mDocumentCompatMode
;
nsCOMPtr
<
nsIConsoleReportCollector
>
mReporter
;
uint32_t
mOngoingLoadCount
=
0
;
uint32_t
mPendingLoadCount
=
0
;
uint32_t
mParsedSheetCount
=
0
;
bool
mEnabled
=
true
;
#
ifdef
DEBUG
bool
mSyncCallback
=
false
;
#
endif
}
;
}
}
#
endif
