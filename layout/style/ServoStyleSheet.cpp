#
include
"
mozilla
/
ServoStyleSheet
.
h
"
#
include
"
mozilla
/
css
/
Rule
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoCSSRuleList
.
h
"
#
include
"
mozilla
/
ServoImportRule
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
css
/
GroupRule
.
h
"
#
include
"
mozilla
/
dom
/
CSSRuleList
.
h
"
#
include
"
mozilla
/
dom
/
MediaList
.
h
"
#
include
"
nsIStyleSheetLinkingElement
.
h
"
#
include
"
ErrorReporter
.
h
"
#
include
"
Loader
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
void
ServoStyleSheet
:
:
BuildChildListAfterInnerClone
(
)
{
MOZ_ASSERT
(
Inner
(
)
-
>
mSheets
.
Length
(
)
=
=
1
"
Should
'
ve
just
cloned
"
)
;
MOZ_ASSERT
(
Inner
(
)
-
>
mSheets
[
0
]
=
=
this
)
;
MOZ_ASSERT
(
!
Inner
(
)
-
>
mFirstChild
)
;
auto
*
contents
=
Inner
(
)
-
>
mContents
.
get
(
)
;
RefPtr
<
ServoCssRules
>
rules
=
Servo_StyleSheet_GetRules
(
contents
)
.
Consume
(
)
;
uint32_t
index
=
0
;
while
(
true
)
{
uint32_t
line
column
;
RefPtr
<
RawServoImportRule
>
import
=
Servo_CssRules_GetImportRuleAt
(
rules
index
&
line
&
column
)
.
Consume
(
)
;
if
(
!
import
)
{
break
;
}
auto
*
sheet
=
const_cast
<
ServoStyleSheet
*
>
(
Servo_ImportRule_GetSheet
(
import
)
)
;
MOZ_ASSERT
(
sheet
)
;
PrependStyleSheetSilently
(
sheet
)
;
index
+
+
;
}
}
already_AddRefed
<
ServoStyleSheet
>
ServoStyleSheet
:
:
CreateEmptyChildSheet
(
already_AddRefed
<
dom
:
:
MediaList
>
aMediaList
)
const
{
RefPtr
<
ServoStyleSheet
>
child
=
new
ServoStyleSheet
(
ParsingMode
(
)
CORSMode
:
:
CORS_NONE
GetReferrerPolicy
(
)
SRIMetadata
(
)
)
;
child
-
>
mMedia
=
aMediaList
;
return
child
.
forget
(
)
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
ServoStyleSheetMallocSizeOf
)
MOZ_DEFINE_MALLOC_ENCLOSING_SIZE_OF
(
ServoStyleSheetMallocEnclosingSizeOf
)
static
bool
AllowParallelParse
(
css
:
:
Loader
*
aLoader
nsIURI
*
aSheetURI
)
{
if
(
!
StaticPrefs
:
:
layout_css_parsing_parallel
(
)
)
{
return
false
;
}
nsIDocument
*
doc
=
aLoader
-
>
GetDocument
(
)
;
if
(
doc
&
&
css
:
:
ErrorReporter
:
:
ShouldReportErrors
(
*
doc
)
)
{
return
false
;
}
if
(
dom
:
:
IsChromeURI
(
aSheetURI
)
)
{
return
false
;
}
return
true
;
}
RefPtr
<
StyleSheetParsePromise
>
ServoStyleSheet
:
:
ParseSheet
(
css
:
:
Loader
*
aLoader
const
nsACString
&
aBytes
css
:
:
SheetLoadData
*
aLoadData
)
{
MOZ_ASSERT
(
aLoader
)
;
MOZ_ASSERT
(
aLoadData
)
;
MOZ_ASSERT
(
mParsePromise
.
IsEmpty
(
)
)
;
RefPtr
<
StyleSheetParsePromise
>
p
=
mParsePromise
.
Ensure
(
__func__
)
;
Inner
(
)
-
>
mURLData
=
new
URLExtraData
(
GetBaseURI
(
)
GetSheetURI
(
)
Principal
(
)
)
;
if
(
!
AllowParallelParse
(
aLoader
GetSheetURI
(
)
)
)
{
RefPtr
<
RawServoStyleSheetContents
>
contents
=
Servo_StyleSheet_FromUTF8Bytes
(
aLoader
this
aLoadData
&
aBytes
mParsingMode
Inner
(
)
-
>
mURLData
aLoadData
-
>
mLineNumber
aLoader
-
>
GetCompatibilityMode
(
)
nullptr
)
.
Consume
(
)
;
FinishAsyncParse
(
contents
.
forget
(
)
)
;
}
else
{
RefPtr
<
css
:
:
SheetLoadDataHolder
>
loadDataHolder
=
new
css
:
:
SheetLoadDataHolder
(
__func__
aLoadData
)
;
Servo_StyleSheet_FromUTF8BytesAsync
(
loadDataHolder
Inner
(
)
-
>
mURLData
&
aBytes
mParsingMode
aLoadData
-
>
mLineNumber
aLoader
-
>
GetCompatibilityMode
(
)
)
;
}
return
Move
(
p
)
;
}
void
ServoStyleSheet
:
:
FinishAsyncParse
(
already_AddRefed
<
RawServoStyleSheetContents
>
aSheetContents
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mParsePromise
.
IsEmpty
(
)
)
;
Inner
(
)
-
>
mContents
=
aSheetContents
;
FinishParse
(
)
;
mParsePromise
.
Resolve
(
true
__func__
)
;
}
void
ServoStyleSheet
:
:
ParseSheetSync
(
css
:
:
Loader
*
aLoader
const
nsACString
&
aBytes
css
:
:
SheetLoadData
*
aLoadData
uint32_t
aLineNumber
css
:
:
LoaderReusableStyleSheets
*
aReusableSheets
)
{
nsCompatibility
compatMode
=
aLoader
?
aLoader
-
>
GetCompatibilityMode
(
)
:
eCompatibility_FullStandards
;
Inner
(
)
-
>
mURLData
=
new
URLExtraData
(
GetBaseURI
(
)
GetSheetURI
(
)
Principal
(
)
)
;
Inner
(
)
-
>
mContents
=
Servo_StyleSheet_FromUTF8Bytes
(
aLoader
this
aLoadData
&
aBytes
mParsingMode
Inner
(
)
-
>
mURLData
aLineNumber
compatMode
aReusableSheets
)
.
Consume
(
)
;
FinishParse
(
)
;
}
void
ServoStyleSheet
:
:
FinishParse
(
)
{
nsString
sourceMapURL
;
Servo_StyleSheet_GetSourceMapURL
(
Inner
(
)
-
>
mContents
&
sourceMapURL
)
;
SetSourceMapURLFromComment
(
sourceMapURL
)
;
nsString
sourceURL
;
Servo_StyleSheet_GetSourceURL
(
Inner
(
)
-
>
mContents
&
sourceURL
)
;
SetSourceURL
(
sourceURL
)
;
}
nsresult
ServoStyleSheet
:
:
ReparseSheet
(
const
nsAString
&
aInput
)
{
if
(
!
mInner
-
>
mComplete
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
RefPtr
<
css
:
:
Loader
>
loader
;
if
(
mDocument
)
{
loader
=
mDocument
-
>
CSSLoader
(
)
;
NS_ASSERTION
(
loader
"
Document
with
no
CSS
loader
!
"
)
;
}
else
{
loader
=
new
css
:
:
Loader
;
}
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
WillDirty
(
)
;
css
:
:
LoaderReusableStyleSheets
reusableSheets
;
for
(
StyleSheet
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
mNext
)
{
if
(
child
-
>
GetOriginalURI
(
)
)
{
reusableSheets
.
AddReusableSheet
(
child
)
;
}
}
for
(
StyleSheet
*
child
=
GetFirstChild
(
)
;
child
;
)
{
StyleSheet
*
next
=
child
-
>
mNext
;
child
-
>
mParent
=
nullptr
;
child
-
>
SetAssociatedDocument
(
nullptr
NotOwnedByDocument
)
;
child
-
>
mNext
=
nullptr
;
child
=
next
;
}
Inner
(
)
-
>
mFirstChild
=
nullptr
;
uint32_t
lineNumber
=
1
;
if
(
mOwningNode
)
{
nsCOMPtr
<
nsIStyleSheetLinkingElement
>
link
=
do_QueryInterface
(
mOwningNode
)
;
if
(
link
)
{
lineNumber
=
link
-
>
GetLineNumber
(
)
;
}
}
{
ServoCSSRuleList
*
ruleList
=
GetCssRulesInternal
(
)
;
MOZ_ASSERT
(
ruleList
)
;
uint32_t
ruleCount
=
ruleList
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
ruleCount
;
+
+
i
)
{
css
:
:
Rule
*
rule
=
ruleList
-
>
GetRule
(
i
)
;
MOZ_ASSERT
(
rule
)
;
if
(
rule
-
>
Type
(
)
=
=
CSSRuleBinding
:
:
IMPORT_RULE
&
&
RuleHasPendingChildSheet
(
rule
)
)
{
continue
;
}
RuleRemoved
(
*
rule
)
;
}
}
DropRuleList
(
)
;
ParseSheetSync
(
loader
NS_ConvertUTF16toUTF8
(
aInput
)
nullptr
lineNumber
&
reusableSheets
)
;
{
ServoCSSRuleList
*
ruleList
=
GetCssRulesInternal
(
)
;
MOZ_ASSERT
(
ruleList
)
;
uint32_t
ruleCount
=
ruleList
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
ruleCount
;
+
+
i
)
{
css
:
:
Rule
*
rule
=
ruleList
-
>
GetRule
(
i
)
;
MOZ_ASSERT
(
rule
)
;
if
(
rule
-
>
Type
(
)
=
=
CSSRuleBinding
:
:
IMPORT_RULE
&
&
RuleHasPendingChildSheet
(
rule
)
)
{
continue
;
}
RuleAdded
(
*
rule
)
;
}
}
ClearModifiedRules
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ServoStyleSheet
:
:
StyleSheetLoaded
(
StyleSheet
*
aSheet
bool
aWasAlternate
nsresult
aStatus
)
{
ServoStyleSheet
*
sheet
=
aSheet
-
>
AsServo
(
)
;
if
(
!
sheet
-
>
GetParentSheet
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
this
=
=
sheet
-
>
GetParentSheet
(
)
"
We
are
being
notified
of
a
sheet
load
for
a
sheet
that
is
not
our
child
!
"
)
;
if
(
NS_SUCCEEDED
(
aStatus
)
)
{
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
RuleAdded
(
*
sheet
-
>
GetOwnerRule
(
)
)
;
}
return
NS_OK
;
}
void
ServoStyleSheet
:
:
DropRuleList
(
)
{
if
(
mRuleList
)
{
mRuleList
-
>
DropReference
(
)
;
mRuleList
=
nullptr
;
}
}
already_AddRefed
<
StyleSheet
>
ServoStyleSheet
:
:
Clone
(
StyleSheet
*
aCloneParent
dom
:
:
CSSImportRule
*
aCloneOwnerRule
nsIDocument
*
aCloneDocument
nsINode
*
aCloneOwningNode
)
const
{
RefPtr
<
StyleSheet
>
clone
=
new
ServoStyleSheet
(
*
this
static_cast
<
ServoStyleSheet
*
>
(
aCloneParent
)
aCloneOwnerRule
aCloneDocument
aCloneOwningNode
)
;
return
clone
.
forget
(
)
;
}
ServoCSSRuleList
*
ServoStyleSheet
:
:
GetCssRulesInternal
(
)
{
if
(
!
mRuleList
)
{
EnsureUniqueInner
(
)
;
RefPtr
<
ServoCssRules
>
rawRules
=
Servo_StyleSheet_GetRules
(
Inner
(
)
-
>
mContents
)
.
Consume
(
)
;
MOZ_ASSERT
(
rawRules
)
;
mRuleList
=
new
ServoCSSRuleList
(
rawRules
.
forget
(
)
this
)
;
}
return
mRuleList
;
}
uint32_t
ServoStyleSheet
:
:
InsertRuleInternal
(
const
nsAString
&
aRule
uint32_t
aIndex
ErrorResult
&
aRv
)
{
GetCssRulesInternal
(
)
;
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
aRv
=
mRuleList
-
>
InsertRule
(
aRule
aIndex
)
;
if
(
aRv
.
Failed
(
)
)
{
return
0
;
}
css
:
:
Rule
*
rule
=
mRuleList
-
>
GetRule
(
aIndex
)
;
if
(
rule
-
>
Type
(
)
!
=
CSSRuleBinding
:
:
IMPORT_RULE
|
|
!
RuleHasPendingChildSheet
(
rule
)
)
{
RuleAdded
(
*
rule
)
;
}
return
aIndex
;
}
void
ServoStyleSheet
:
:
DeleteRuleInternal
(
uint32_t
aIndex
ErrorResult
&
aRv
)
{
GetCssRulesInternal
(
)
;
if
(
aIndex
>
=
mRuleList
-
>
Length
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
RefPtr
<
css
:
:
Rule
>
rule
=
mRuleList
-
>
GetRule
(
aIndex
)
;
aRv
=
mRuleList
-
>
DeleteRule
(
aIndex
)
;
MOZ_ASSERT
(
!
aRv
.
ErrorCodeIs
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
"
IndexSizeError
should
have
been
handled
earlier
"
)
;
if
(
!
aRv
.
Failed
(
)
)
{
RuleRemoved
(
*
rule
)
;
}
}
nsresult
ServoStyleSheet
:
:
InsertRuleIntoGroupInternal
(
const
nsAString
&
aRule
css
:
:
GroupRule
*
aGroup
uint32_t
aIndex
)
{
auto
rules
=
static_cast
<
ServoCSSRuleList
*
>
(
aGroup
-
>
CssRules
(
)
)
;
MOZ_ASSERT
(
rules
-
>
GetParentRule
(
)
=
=
aGroup
)
;
return
rules
-
>
InsertRule
(
aRule
aIndex
)
;
}
OriginFlags
ServoStyleSheet
:
:
GetOrigin
(
)
{
return
static_cast
<
OriginFlags
>
(
Servo_StyleSheet_GetOrigin
(
Inner
(
)
-
>
mContents
)
)
;
}
}
