#
ifndef
nsStyleStruct_h___
#
define
nsStyleStruct_h___
#
include
"
mozilla
/
ArenaObjectID
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CSSVariableValues
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
SheetType
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StyleComplexColor
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsMargin
.
h
"
#
include
"
nsFont
.
h
"
#
include
"
nsStyleAutoArray
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
Orientation
.
h
"
#
include
"
CounterStyleManager
.
h
"
#
include
<
cstddef
>
#
include
<
utility
>
#
include
"
X11UndefineNone
.
h
"
class
nsIFrame
;
class
nsIURI
;
class
nsStyleContext
;
class
nsTextFrame
;
class
imgIContainer
;
struct
nsStyleVisibility
;
namespace
mozilla
{
namespace
dom
{
class
ImageTracker
;
}
}
#
include
"
nsStyleStructFwd
.
h
"
#
define
NS_STYLE_INHERIT_MASK
0x000ffffff
#
define
NS_STYLE_INHERITED_STRUCT_MASK
\
(
(
nsStyleStructID_size_t
(
1
)
<
<
nsStyleStructID_Inherited_Count
)
-
1
)
#
define
NS_STYLE_RESET_STRUCT_MASK
\
(
(
(
nsStyleStructID_size_t
(
1
)
<
<
nsStyleStructID_Reset_Count
)
-
1
)
\
<
<
nsStyleStructID_Inherited_Count
)
#
define
NS_STYLE_HAS_TEXT_DECORATION_LINES
0x001000000
#
define
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
0x002000000
#
define
NS_STYLE_RELEVANT_LINK_VISITED
0x004000000
#
define
NS_STYLE_IS_STYLE_IF_VISITED
0x008000000
#
define
NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE
0x010000000
#
define
NS_STYLE_IS_SHARED
0x020000000
#
define
NS_STYLE_IS_GOING_AWAY
0x040000000
#
define
NS_STYLE_SUPPRESS_LINEBREAK
0x080000000
#
define
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
0x100000000
#
define
NS_STYLE_INELIGIBLE_FOR_SHARING
0x200000000
#
define
NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE
0x400000000
#
define
NS_STYLE_IS_TEXT_COMBINED
0x800000000
#
define
NS_STYLE_CONTEXT_IS_GECKO
0x1000000000
#
define
NS_STYLE_CONTEXT_TYPE_SHIFT
37
#
define
NS_RULE_NODE_IS_ANIMATION_RULE
0x01000000
#
define
NS_RULE_NODE_USED_DIRECTLY
0x04000000
#
define
NS_RULE_NODE_IS_IMPORTANT
0x08000000
#
define
NS_RULE_NODE_LEVEL_MASK
0xf0000000
#
define
NS_RULE_NODE_LEVEL_SHIFT
28
#
define
NS_RULE_NODE_HAS_ANIMATION_DATA
0x80000000
static_assert
(
int
(
mozilla
:
:
SheetType
:
:
Count
)
-
1
<
=
(
NS_RULE_NODE_LEVEL_MASK
>
>
NS_RULE_NODE_LEVEL_SHIFT
)
"
NS_RULE_NODE_LEVEL_MASK
cannot
fit
SheetType
"
)
;
static_assert
(
NS_STYLE_INHERIT_MASK
=
=
(
1
<
<
nsStyleStructID_Length
)
-
1
"
NS_STYLE_INHERIT_MASK
is
not
correct
"
)
;
static_assert
(
(
NS_RULE_NODE_IS_ANIMATION_RULE
&
NS_STYLE_INHERIT_MASK
)
=
=
0
"
NS_RULE_NODE_IS_ANIMATION_RULE
must
not
overlap
the
style
struct
bits
.
"
)
;
namespace
mozilla
{
struct
Position
{
using
Coord
=
nsStyleCoord
:
:
CalcValue
;
Coord
mXPosition
mYPosition
;
Position
(
)
{
}
void
SetInitialPercentValues
(
float
aPercentVal
)
;
void
SetInitialZeroValues
(
)
;
bool
DependsOnPositioningAreaSize
(
)
const
{
return
mXPosition
.
mPercent
!
=
0
.
0f
|
|
mYPosition
.
mPercent
!
=
0
.
0f
;
}
bool
operator
=
=
(
const
Position
&
aOther
)
const
{
return
mXPosition
=
=
aOther
.
mXPosition
&
&
mYPosition
=
=
aOther
.
mYPosition
;
}
bool
operator
!
=
(
const
Position
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
}
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleFont
{
nsStyleFont
(
const
nsFont
&
aFont
const
nsPresContext
*
aContext
)
;
nsStyleFont
(
const
nsStyleFont
&
aStyleFont
)
;
explicit
nsStyleFont
(
const
nsPresContext
*
aContext
)
;
~
nsStyleFont
(
)
{
MOZ_COUNT_DTOR
(
nsStyleFont
)
;
}
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleFont
&
aNewData
)
const
;
static
nscoord
ZoomText
(
const
nsPresContext
*
aPresContext
nscoord
aSize
)
;
static
nscoord
UnZoomText
(
nsPresContext
*
aPresContext
nscoord
aSize
)
;
static
already_AddRefed
<
nsAtom
>
GetLanguage
(
const
nsPresContext
*
aPresContext
)
;
void
*
operator
new
(
size_t
sz
nsStyleFont
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleFont
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
;
void
EnableZoom
(
nsPresContext
*
aContext
bool
aEnable
)
;
nsFont
mFont
;
nscoord
mSize
;
float
mFontSizeFactor
;
nscoord
mFontSizeOffset
;
uint8_t
mFontSizeKeyword
;
uint8_t
mGenericID
;
int8_t
mScriptLevel
;
uint8_t
mMathVariant
;
uint8_t
mMathDisplay
;
uint8_t
mMinFontSizeRatio
;
bool
mExplicitLanguage
;
bool
mAllowZoom
;
nscoord
mScriptUnconstrainedSize
;
nscoord
mScriptMinSize
;
float
mScriptSizeMultiplier
;
RefPtr
<
nsAtom
>
mLanguage
;
}
;
struct
nsStyleGradientStop
{
nsStyleCoord
mLocation
;
nscolor
mColor
;
bool
mIsInterpolationHint
;
bool
operator
=
=
(
const
nsStyleGradientStop
&
)
const
=
delete
;
bool
operator
!
=
(
const
nsStyleGradientStop
&
)
const
=
delete
;
}
;
class
nsStyleGradient
final
{
public
:
nsStyleGradient
(
)
;
uint8_t
mShape
;
uint8_t
mSize
;
bool
mRepeating
;
bool
mLegacySyntax
;
bool
mMozLegacySyntax
;
nsStyleCoord
mBgPosX
;
nsStyleCoord
mBgPosY
;
nsStyleCoord
mAngle
;
nsStyleCoord
mRadiusX
;
nsStyleCoord
mRadiusY
;
nsTArray
<
nsStyleGradientStop
>
mStops
;
bool
operator
=
=
(
const
nsStyleGradient
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleGradient
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
bool
IsOpaque
(
)
;
bool
HasCalc
(
)
;
uint32_t
Hash
(
PLDHashNumber
aHash
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsStyleGradient
)
private
:
~
nsStyleGradient
(
)
{
}
nsStyleGradient
(
const
nsStyleGradient
&
aOther
)
=
delete
;
nsStyleGradient
&
operator
=
(
const
nsStyleGradient
&
aOther
)
=
delete
;
}
;
class
nsStyleImageRequest
{
public
:
typedef
mozilla
:
:
css
:
:
URLValueData
URLValueData
;
enum
class
Mode
:
uint8_t
{
Track
=
0x1
Discard
=
0x2
}
;
nsStyleImageRequest
(
Mode
aModeFlags
imgRequestProxy
*
aRequestProxy
mozilla
:
:
css
:
:
ImageValue
*
aImageValue
mozilla
:
:
dom
:
:
ImageTracker
*
aImageTracker
)
;
nsStyleImageRequest
(
Mode
aModeFlags
mozilla
:
:
css
:
:
ImageValue
*
aImageValue
)
;
bool
Resolve
(
nsPresContext
*
aPresContext
)
;
bool
IsResolved
(
)
const
{
return
mResolved
;
}
imgRequestProxy
*
get
(
)
{
MOZ_ASSERT
(
IsResolved
(
)
"
Resolve
(
)
must
be
called
first
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mRequestProxy
.
get
(
)
;
}
const
imgRequestProxy
*
get
(
)
const
{
return
const_cast
<
nsStyleImageRequest
*
>
(
this
)
-
>
get
(
)
;
}
bool
DefinitelyEquals
(
const
nsStyleImageRequest
&
aOther
)
const
;
mozilla
:
:
css
:
:
ImageValue
*
GetImageValue
(
)
const
{
return
mImageValue
;
}
already_AddRefed
<
nsIURI
>
GetImageURI
(
)
const
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsStyleImageRequest
)
;
private
:
~
nsStyleImageRequest
(
)
;
nsStyleImageRequest
&
operator
=
(
const
nsStyleImageRequest
&
aOther
)
=
delete
;
void
MaybeTrackAndLock
(
)
;
RefPtr
<
imgRequestProxy
>
mRequestProxy
;
RefPtr
<
mozilla
:
:
css
:
:
ImageValue
>
mImageValue
;
RefPtr
<
mozilla
:
:
dom
:
:
ImageTracker
>
mImageTracker
;
RefPtr
<
mozilla
:
:
dom
:
:
DocGroup
>
mDocGroup
;
Mode
mModeFlags
;
bool
mResolved
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
nsStyleImageRequest
:
:
Mode
)
enum
nsStyleImageType
{
eStyleImageType_Null
eStyleImageType_Image
eStyleImageType_Gradient
eStyleImageType_Element
eStyleImageType_URL
}
;
struct
CachedBorderImageData
{
~
CachedBorderImageData
(
)
{
PurgeCachedImages
(
)
;
}
void
SetCachedSVGViewportSize
(
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
)
;
const
mozilla
:
:
Maybe
<
nsSize
>
&
GetCachedSVGViewportSize
(
)
;
void
PurgeCachedImages
(
)
;
void
SetSubImage
(
uint8_t
aIndex
imgIContainer
*
aSubImage
)
;
imgIContainer
*
GetSubImage
(
uint8_t
aIndex
)
;
private
:
mozilla
:
:
Maybe
<
nsSize
>
mCachedSVGViewportSize
;
nsCOMArray
<
imgIContainer
>
mSubImages
;
}
;
struct
nsStyleImage
{
typedef
mozilla
:
:
css
:
:
URLValue
URLValue
;
typedef
mozilla
:
:
css
:
:
URLValueData
URLValueData
;
nsStyleImage
(
)
;
~
nsStyleImage
(
)
;
nsStyleImage
(
const
nsStyleImage
&
aOther
)
;
nsStyleImage
&
operator
=
(
const
nsStyleImage
&
aOther
)
;
void
SetNull
(
)
;
void
SetImageRequest
(
already_AddRefed
<
nsStyleImageRequest
>
aImage
)
;
void
SetGradientData
(
nsStyleGradient
*
aGradient
)
;
void
SetElementId
(
already_AddRefed
<
nsAtom
>
aElementId
)
;
void
SetCropRect
(
mozilla
:
:
UniquePtr
<
nsStyleSides
>
aCropRect
)
;
void
SetURLValue
(
already_AddRefed
<
URLValue
>
aData
)
;
void
ResolveImage
(
nsPresContext
*
aContext
)
{
MOZ_ASSERT
(
mType
!
=
eStyleImageType_Image
|
|
mImage
)
;
if
(
mType
=
=
eStyleImageType_Image
&
&
!
mImage
-
>
IsResolved
(
)
)
{
mImage
-
>
Resolve
(
aContext
)
;
}
}
nsStyleImageType
GetType
(
)
const
{
return
mType
;
}
nsStyleImageRequest
*
GetImageRequest
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleImageType_Image
"
Data
is
not
an
image
!
"
)
;
MOZ_ASSERT
(
mImage
)
;
return
mImage
;
}
imgRequestProxy
*
GetImageData
(
)
const
{
return
GetImageRequest
(
)
-
>
get
(
)
;
}
nsStyleGradient
*
GetGradientData
(
)
const
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Gradient
"
Data
is
not
a
gradient
!
"
)
;
return
mGradient
;
}
bool
IsResolved
(
)
const
{
return
mType
!
=
eStyleImageType_Image
|
|
GetImageRequest
(
)
-
>
IsResolved
(
)
;
}
const
nsAtom
*
GetElementId
(
)
const
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Element
"
Data
is
not
an
element
!
"
)
;
return
mElementId
;
}
const
mozilla
:
:
UniquePtr
<
nsStyleSides
>
&
GetCropRect
(
)
const
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Image
"
Only
image
data
can
have
a
crop
rect
"
)
;
return
mCropRect
;
}
already_AddRefed
<
nsIURI
>
GetImageURI
(
)
const
;
URLValueData
*
GetURLValue
(
)
const
;
bool
ComputeActualCropRect
(
nsIntRect
&
aActualCropRect
bool
*
aIsEntireImage
=
nullptr
)
const
;
bool
StartDecoding
(
)
const
;
bool
IsOpaque
(
)
const
;
bool
IsComplete
(
)
const
;
bool
IsLoaded
(
)
const
;
bool
IsEmpty
(
)
const
{
return
mType
=
=
eStyleImageType_Null
;
}
bool
operator
=
=
(
const
nsStyleImage
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleImage
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
bool
ImageDataEquals
(
const
nsStyleImage
&
aOther
)
const
{
return
GetType
(
)
=
=
eStyleImageType_Image
&
&
aOther
.
GetType
(
)
=
=
eStyleImageType_Image
&
&
GetImageData
(
)
=
=
aOther
.
GetImageData
(
)
;
}
inline
void
SetSubImage
(
uint8_t
aIndex
imgIContainer
*
aSubImage
)
const
;
inline
imgIContainer
*
GetSubImage
(
uint8_t
aIndex
)
const
;
void
PurgeCacheForViewportChange
(
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasIntrinsicRatio
)
const
;
private
:
void
DoCopy
(
const
nsStyleImage
&
aOther
)
;
void
EnsureCachedBIData
(
)
const
;
mozilla
:
:
UniquePtr
<
CachedBorderImageData
>
mCachedBIData
;
nsStyleImageType
mType
;
union
{
nsStyleImageRequest
*
mImage
;
nsStyleGradient
*
mGradient
;
URLValue
*
mURLValue
;
nsAtom
*
mElementId
;
}
;
mozilla
:
:
UniquePtr
<
nsStyleSides
>
mCropRect
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleColor
{
explicit
nsStyleColor
(
const
nsPresContext
*
aContext
)
;
nsStyleColor
(
const
nsStyleColor
&
aOther
)
;
~
nsStyleColor
(
)
{
MOZ_COUNT_DTOR
(
nsStyleColor
)
;
}
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
nscolor
CalcComplexColor
(
const
mozilla
:
:
StyleComplexColor
&
aColor
)
const
{
return
mozilla
:
:
LinearBlendColors
(
aColor
.
mColor
mColor
aColor
.
mForegroundRatio
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleColor
&
aNewData
)
const
;
void
*
operator
new
(
size_t
sz
nsStyleColor
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleColor
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleColor
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleColor
this
)
;
}
nscolor
mColor
;
}
;
struct
nsStyleImageLayers
{
enum
{
shorthand
=
0
color
image
repeat
positionX
positionY
clip
origin
size
attachment
maskMode
composite
}
;
enum
class
LayerType
:
uint8_t
{
Background
=
0
Mask
}
;
explicit
nsStyleImageLayers
(
LayerType
aType
)
;
nsStyleImageLayers
(
const
nsStyleImageLayers
&
aSource
)
;
~
nsStyleImageLayers
(
)
{
MOZ_COUNT_DTOR
(
nsStyleImageLayers
)
;
}
static
bool
IsInitialPositionForLayerType
(
mozilla
:
:
Position
aPosition
LayerType
aType
)
;
struct
Size
{
struct
Dimension
:
public
nsStyleCoord
:
:
CalcValue
{
nscoord
ResolveLengthPercentage
(
nscoord
aAvailable
)
const
{
double
d
=
double
(
mPercent
)
*
double
(
aAvailable
)
+
double
(
mLength
)
;
if
(
d
<
0
.
0
)
{
return
0
;
}
return
NSToCoordRoundWithClamp
(
float
(
d
)
)
;
}
}
;
Dimension
mWidth
mHeight
;
bool
IsInitialValue
(
)
const
{
return
mWidthType
=
=
eAuto
&
&
mHeightType
=
=
eAuto
;
}
nscoord
ResolveWidthLengthPercentage
(
const
nsSize
&
aBgPositioningArea
)
const
{
MOZ_ASSERT
(
mWidthType
=
=
eLengthPercentage
"
resolving
non
-
length
/
percent
dimension
!
"
)
;
return
mWidth
.
ResolveLengthPercentage
(
aBgPositioningArea
.
width
)
;
}
nscoord
ResolveHeightLengthPercentage
(
const
nsSize
&
aBgPositioningArea
)
const
{
MOZ_ASSERT
(
mHeightType
=
=
eLengthPercentage
"
resolving
non
-
length
/
percent
dimension
!
"
)
;
return
mHeight
.
ResolveLengthPercentage
(
aBgPositioningArea
.
height
)
;
}
enum
DimensionType
{
eContain
eCover
eAuto
eLengthPercentage
eDimensionType_COUNT
}
;
uint8_t
mWidthType
mHeightType
;
bool
DependsOnPositioningAreaSize
(
const
nsStyleImage
&
aImage
)
const
;
Size
(
)
{
}
void
SetInitialValues
(
)
;
bool
operator
=
=
(
const
Size
&
aOther
)
const
;
bool
operator
!
=
(
const
Size
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
Repeat
{
mozilla
:
:
StyleImageLayerRepeat
mXRepeat
mYRepeat
;
Repeat
(
)
{
}
bool
IsInitialValue
(
)
const
{
return
mXRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
&
&
mYRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
;
}
bool
DependsOnPositioningAreaSize
(
)
const
{
return
mXRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Space
|
|
mYRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Space
;
}
void
SetInitialValues
(
)
{
mXRepeat
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
;
mYRepeat
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
;
}
bool
operator
=
=
(
const
Repeat
&
aOther
)
const
{
return
mXRepeat
=
=
aOther
.
mXRepeat
&
&
mYRepeat
=
=
aOther
.
mYRepeat
;
}
bool
operator
!
=
(
const
Repeat
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
Layer
{
typedef
mozilla
:
:
StyleGeometryBox
StyleGeometryBox
;
nsStyleImage
mImage
;
mozilla
:
:
Position
mPosition
;
Size
mSize
;
StyleGeometryBox
mClip
;
MOZ_INIT_OUTSIDE_CTOR
StyleGeometryBox
mOrigin
;
uint8_t
mAttachment
;
uint8_t
mBlendMode
;
uint8_t
mComposite
;
uint8_t
mMaskMode
;
Repeat
mRepeat
;
Layer
(
)
;
~
Layer
(
)
;
void
Initialize
(
LayerType
aType
)
;
void
ResolveImage
(
nsPresContext
*
aContext
)
{
if
(
mImage
.
GetType
(
)
=
=
eStyleImageType_Image
)
{
mImage
.
ResolveImage
(
aContext
)
;
}
}
bool
RenderingMightDependOnPositioningAreaSizeChange
(
)
const
;
nsChangeHint
CalcDifference
(
const
Layer
&
aNewLayer
)
const
;
bool
operator
=
=
(
const
Layer
&
aOther
)
const
;
bool
operator
!
=
(
const
Layer
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
uint32_t
mAttachmentCount
mClipCount
mOriginCount
mRepeatCount
mPositionXCount
mPositionYCount
mImageCount
mSizeCount
mMaskModeCount
mBlendModeCount
mCompositeCount
;
nsStyleAutoArray
<
Layer
>
mLayers
;
const
Layer
&
BottomLayer
(
)
const
{
return
mLayers
[
mImageCount
-
1
]
;
}
void
ResolveImages
(
nsPresContext
*
aContext
)
{
for
(
uint32_t
i
=
0
;
i
<
mImageCount
;
+
+
i
)
{
mLayers
[
i
]
.
ResolveImage
(
aContext
)
;
}
}
void
FillAllLayers
(
uint32_t
aMaxItemCount
)
;
nsChangeHint
CalcDifference
(
const
nsStyleImageLayers
&
aNewLayers
nsStyleImageLayers
:
:
LayerType
aType
)
const
;
nsStyleImageLayers
&
operator
=
(
const
nsStyleImageLayers
&
aOther
)
;
nsStyleImageLayers
&
operator
=
(
nsStyleImageLayers
&
&
aOther
)
;
bool
operator
=
=
(
const
nsStyleImageLayers
&
aOther
)
const
;
static
const
nsCSSPropertyID
kBackgroundLayerTable
[
]
;
static
const
nsCSSPropertyID
kMaskLayerTable
[
]
;
#
define
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
var_
layers_
)
\
for
(
uint32_t
var_
=
(
layers_
)
.
mImageCount
;
var_
-
-
!
=
0
;
)
#
define
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT_WITH_RANGE
(
var_
layers_
start_
count_
)
\
NS_ASSERTION
(
(
int32_t
)
(
start_
)
>
=
0
&
&
(
uint32_t
)
(
start_
)
<
(
layers_
)
.
mImageCount
"
Invalid
layer
start
!
"
)
;
\
NS_ASSERTION
(
(
count_
)
>
0
&
&
(
count_
)
<
=
(
start_
)
+
1
"
Invalid
layer
range
!
"
)
;
\
for
(
uint32_t
var_
=
(
start_
)
+
1
;
var_
-
-
!
=
(
uint32_t
)
(
(
start_
)
+
1
-
(
count_
)
)
;
)
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleBackground
{
explicit
nsStyleBackground
(
const
nsPresContext
*
aContext
)
;
nsStyleBackground
(
const
nsStyleBackground
&
aOther
)
;
~
nsStyleBackground
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
;
const
static
bool
kHasFinishStyle
=
true
;
void
*
operator
new
(
size_t
sz
nsStyleBackground
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleBackground
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
;
nsChangeHint
CalcDifference
(
const
nsStyleBackground
&
aNewData
)
const
;
nscolor
BackgroundColor
(
const
nsIFrame
*
aFrame
)
const
;
nscolor
BackgroundColor
(
nsStyleContext
*
aContext
)
const
;
bool
IsTransparent
(
const
nsIFrame
*
aFrame
)
const
;
bool
IsTransparent
(
nsStyleContext
*
aContext
)
const
;
bool
HasFixedBackground
(
nsIFrame
*
aFrame
)
const
;
inline
bool
HasLocalBackground
(
)
const
;
const
nsStyleImageLayers
:
:
Layer
&
BottomLayer
(
)
const
{
return
mImage
.
BottomLayer
(
)
;
}
nsStyleImageLayers
mImage
;
mozilla
:
:
StyleComplexColor
mBackgroundColor
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleMargin
{
explicit
nsStyleMargin
(
const
nsPresContext
*
aContext
)
;
nsStyleMargin
(
const
nsStyleMargin
&
aMargin
)
;
~
nsStyleMargin
(
)
{
MOZ_COUNT_DTOR
(
nsStyleMargin
)
;
}
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleMargin
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleMargin
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
;
nsChangeHint
CalcDifference
(
const
nsStyleMargin
&
aNewData
)
const
;
bool
GetMargin
(
nsMargin
&
aMargin
)
const
{
if
(
!
mMargin
.
ConvertsToLength
(
)
)
{
return
false
;
}
NS_FOR_CSS_SIDES
(
side
)
{
aMargin
.
Side
(
side
)
=
mMargin
.
ToLength
(
side
)
;
}
return
true
;
}
inline
bool
HasBlockAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
bool
HasInlineAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
;
nsStyleSides
mMargin
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStylePadding
{
explicit
nsStylePadding
(
const
nsPresContext
*
aContext
)
;
nsStylePadding
(
const
nsStylePadding
&
aPadding
)
;
~
nsStylePadding
(
)
{
MOZ_COUNT_DTOR
(
nsStylePadding
)
;
}
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStylePadding
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStylePadding
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
;
nsChangeHint
CalcDifference
(
const
nsStylePadding
&
aNewData
)
const
;
nsStyleSides
mPadding
;
bool
IsWidthDependent
(
)
const
{
return
!
mPadding
.
ConvertsToLength
(
)
;
}
bool
GetPadding
(
nsMargin
&
aPadding
)
const
{
if
(
!
mPadding
.
ConvertsToLength
(
)
)
{
return
false
;
}
NS_FOR_CSS_SIDES
(
side
)
{
aPadding
.
Side
(
side
)
=
std
:
:
max
(
mPadding
.
ToLength
(
side
)
0
)
;
}
return
true
;
}
}
;
struct
nsCSSShadowItem
{
nscoord
mXOffset
;
nscoord
mYOffset
;
nscoord
mRadius
;
nscoord
mSpread
;
nscolor
mColor
;
bool
mHasColor
;
bool
mInset
;
nsCSSShadowItem
(
)
:
mHasColor
(
false
)
{
MOZ_COUNT_CTOR
(
nsCSSShadowItem
)
;
}
~
nsCSSShadowItem
(
)
{
MOZ_COUNT_DTOR
(
nsCSSShadowItem
)
;
}
bool
operator
=
=
(
const
nsCSSShadowItem
&
aOther
)
const
{
return
(
mXOffset
=
=
aOther
.
mXOffset
&
&
mYOffset
=
=
aOther
.
mYOffset
&
&
mRadius
=
=
aOther
.
mRadius
&
&
mHasColor
=
=
aOther
.
mHasColor
&
&
mSpread
=
=
aOther
.
mSpread
&
&
mInset
=
=
aOther
.
mInset
&
&
(
!
mHasColor
|
|
mColor
=
=
aOther
.
mColor
)
)
;
}
bool
operator
!
=
(
const
nsCSSShadowItem
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
class
nsCSSShadowArray
final
{
public
:
void
*
operator
new
(
size_t
aBaseSize
uint32_t
aArrayLen
)
{
return
:
:
operator
new
(
aBaseSize
+
(
aArrayLen
-
1
)
*
sizeof
(
nsCSSShadowItem
)
)
;
}
void
operator
delete
(
void
*
aPtr
)
{
:
:
operator
delete
(
aPtr
)
;
}
explicit
nsCSSShadowArray
(
uint32_t
aArrayLen
)
:
mLength
(
aArrayLen
)
{
for
(
uint32_t
i
=
1
;
i
<
mLength
;
+
+
i
)
{
new
(
&
mArray
[
i
]
)
nsCSSShadowItem
(
)
;
}
}
private
:
~
nsCSSShadowArray
(
)
{
for
(
uint32_t
i
=
1
;
i
<
mLength
;
+
+
i
)
{
mArray
[
i
]
.
~
nsCSSShadowItem
(
)
;
}
}
public
:
uint32_t
Length
(
)
const
{
return
mLength
;
}
nsCSSShadowItem
*
ShadowAt
(
uint32_t
i
)
{
MOZ_ASSERT
(
i
<
mLength
"
Accessing
too
high
an
index
in
the
text
shadow
array
!
"
)
;
return
&
mArray
[
i
]
;
}
const
nsCSSShadowItem
*
ShadowAt
(
uint32_t
i
)
const
{
MOZ_ASSERT
(
i
<
mLength
"
Accessing
too
high
an
index
in
the
text
shadow
array
!
"
)
;
return
&
mArray
[
i
]
;
}
bool
HasShadowWithInset
(
bool
aInset
)
{
for
(
uint32_t
i
=
0
;
i
<
mLength
;
+
+
i
)
{
if
(
mArray
[
i
]
.
mInset
=
=
aInset
)
{
return
true
;
}
}
return
false
;
}
bool
operator
=
=
(
const
nsCSSShadowArray
&
aOther
)
const
{
if
(
mLength
!
=
aOther
.
Length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
mLength
;
+
+
i
)
{
if
(
ShadowAt
(
i
)
!
=
aOther
.
ShadowAt
(
i
)
)
{
return
false
;
}
}
return
true
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsCSSShadowArray
)
private
:
uint32_t
mLength
;
nsCSSShadowItem
mArray
[
1
]
;
}
;
#
define
NS_ROUND_BORDER_TO_PIXELS
(
l
tpp
)
\
(
(
l
)
=
=
0
)
?
0
:
std
:
:
max
(
(
tpp
)
(
l
)
/
(
tpp
)
*
(
tpp
)
)
#
define
NS_ROUND_OFFSET_TO_PIXELS
(
l
tpp
)
\
(
(
(
l
)
=
=
0
)
?
0
:
\
(
(
l
)
>
0
)
?
std
:
:
max
(
(
tpp
)
(
(
l
)
+
(
(
tpp
)
/
2
)
)
/
(
tpp
)
*
(
tpp
)
)
:
\
std
:
:
min
(
-
(
tpp
)
(
(
l
)
-
(
(
tpp
)
/
2
)
)
/
(
tpp
)
*
(
tpp
)
)
)
static
bool
IsVisibleBorderStyle
(
uint8_t
aStyle
)
{
return
(
aStyle
!
=
NS_STYLE_BORDER_STYLE_NONE
&
&
aStyle
!
=
NS_STYLE_BORDER_STYLE_HIDDEN
)
;
}
struct
nsBorderColors
{
nsBorderColors
(
)
=
default
;
nsBorderColors
(
const
nsBorderColors
&
aOther
)
{
NS_FOR_CSS_SIDES
(
side
)
{
mColors
[
side
]
=
aOther
.
mColors
[
side
]
;
}
}
const
nsTArray
<
nscolor
>
&
operator
[
]
(
mozilla
:
:
Side
aSide
)
const
{
return
mColors
[
aSide
]
;
}
nsTArray
<
nscolor
>
mColors
[
4
]
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleBorder
{
explicit
nsStyleBorder
(
const
nsPresContext
*
aContext
)
;
nsStyleBorder
(
const
nsStyleBorder
&
aBorder
)
;
~
nsStyleBorder
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
;
const
static
bool
kHasFinishStyle
=
true
;
void
*
operator
new
(
size_t
sz
nsStyleBorder
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleBorder
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
;
nsChangeHint
CalcDifference
(
const
nsStyleBorder
&
aNewData
)
const
;
void
EnsureBorderColors
(
)
{
if
(
!
mBorderColors
)
{
mBorderColors
.
reset
(
new
nsBorderColors
)
;
}
}
void
ClearBorderColors
(
mozilla
:
:
Side
aSide
)
{
if
(
mBorderColors
)
{
mBorderColors
-
>
mColors
[
aSide
]
.
Clear
(
)
;
}
}
bool
HasVisibleStyle
(
mozilla
:
:
Side
aSide
)
const
{
return
IsVisibleBorderStyle
(
mBorderStyle
[
aSide
]
)
;
}
void
SetBorderWidth
(
mozilla
:
:
Side
aSide
nscoord
aBorderWidth
)
{
nscoord
roundedWidth
=
NS_ROUND_BORDER_TO_PIXELS
(
aBorderWidth
mTwipsPerPixel
)
;
mBorder
.
Side
(
aSide
)
=
roundedWidth
;
if
(
HasVisibleStyle
(
aSide
)
)
{
mComputedBorder
.
Side
(
aSide
)
=
roundedWidth
;
}
}
const
nsMargin
&
GetComputedBorder
(
)
const
{
return
mComputedBorder
;
}
bool
HasBorder
(
)
const
{
return
mComputedBorder
!
=
nsMargin
(
0
0
0
0
)
|
|
!
mBorderImageSource
.
IsEmpty
(
)
;
}
nscoord
GetComputedBorderWidth
(
mozilla
:
:
Side
aSide
)
const
{
return
GetComputedBorder
(
)
.
Side
(
aSide
)
;
}
uint8_t
GetBorderStyle
(
mozilla
:
:
Side
aSide
)
const
{
NS_ASSERTION
(
aSide
<
=
mozilla
:
:
eSideLeft
"
bad
side
"
)
;
return
mBorderStyle
[
aSide
]
;
}
void
SetBorderStyle
(
mozilla
:
:
Side
aSide
uint8_t
aStyle
)
{
NS_ASSERTION
(
aSide
<
=
mozilla
:
:
eSideLeft
"
bad
side
"
)
;
mBorderStyle
[
aSide
]
=
aStyle
;
mComputedBorder
.
Side
(
aSide
)
=
(
HasVisibleStyle
(
aSide
)
?
mBorder
.
Side
(
aSide
)
:
0
)
;
}
inline
bool
IsBorderImageLoaded
(
)
const
{
return
mBorderImageSource
.
IsLoaded
(
)
;
}
void
ResolveImage
(
nsPresContext
*
aContext
)
{
if
(
mBorderImageSource
.
GetType
(
)
=
=
eStyleImageType_Image
)
{
mBorderImageSource
.
ResolveImage
(
aContext
)
;
}
}
nsMargin
GetImageOutset
(
)
const
;
imgIRequest
*
GetBorderImageRequest
(
)
const
{
if
(
mBorderImageSource
.
GetType
(
)
=
=
eStyleImageType_Image
)
{
return
mBorderImageSource
.
GetImageData
(
)
;
}
return
nullptr
;
}
public
:
mozilla
:
:
UniquePtr
<
nsBorderColors
>
mBorderColors
;
nsStyleCorners
mBorderRadius
;
nsStyleImage
mBorderImageSource
;
nsStyleSides
mBorderImageSlice
;
nsStyleSides
mBorderImageWidth
;
nsStyleSides
mBorderImageOutset
;
uint8_t
mBorderImageFill
;
uint8_t
mBorderImageRepeatH
;
uint8_t
mBorderImageRepeatV
;
mozilla
:
:
StyleFloatEdge
mFloatEdge
;
mozilla
:
:
StyleBoxDecorationBreak
mBoxDecorationBreak
;
protected
:
uint8_t
mBorderStyle
[
4
]
;
public
:
union
{
struct
{
mozilla
:
:
StyleComplexColor
mBorderTopColor
;
mozilla
:
:
StyleComplexColor
mBorderRightColor
;
mozilla
:
:
StyleComplexColor
mBorderBottomColor
;
mozilla
:
:
StyleComplexColor
mBorderLeftColor
;
}
;
mozilla
:
:
StyleComplexColor
mBorderColor
[
4
]
;
}
;
static
mozilla
:
:
StyleComplexColor
nsStyleBorder
:
:
*
BorderColorFieldFor
(
mozilla
:
:
Side
aSide
)
{
switch
(
aSide
)
{
case
mozilla
:
:
eSideTop
:
return
&
nsStyleBorder
:
:
mBorderTopColor
;
case
mozilla
:
:
eSideRight
:
return
&
nsStyleBorder
:
:
mBorderRightColor
;
case
mozilla
:
:
eSideBottom
:
return
&
nsStyleBorder
:
:
mBorderBottomColor
;
case
mozilla
:
:
eSideLeft
:
return
&
nsStyleBorder
:
:
mBorderLeftColor
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
side
"
)
;
return
nullptr
;
}
protected
:
nsMargin
mComputedBorder
;
nsMargin
mBorder
;
private
:
nscoord
mTwipsPerPixel
;
nsStyleBorder
&
operator
=
(
const
nsStyleBorder
&
aOther
)
=
delete
;
}
;
#
define
ASSERT_BORDER_COLOR_FIELD
(
side_
)
\
static_assert
(
offsetof
(
nsStyleBorder
mBorder
#
#
side_
#
#
Color
)
=
=
\
offsetof
(
nsStyleBorder
mBorderColor
)
+
\
size_t
(
mozilla
:
:
eSide
#
#
side_
)
*
\
sizeof
(
mozilla
:
:
StyleComplexColor
)
\
"
mBorder
"
#
side_
"
Color
must
be
at
same
offset
"
\
"
as
mBorderColor
[
mozilla
:
:
eSide
"
#
side_
"
]
"
)
ASSERT_BORDER_COLOR_FIELD
(
Top
)
;
ASSERT_BORDER_COLOR_FIELD
(
Right
)
;
ASSERT_BORDER_COLOR_FIELD
(
Bottom
)
;
ASSERT_BORDER_COLOR_FIELD
(
Left
)
;
#
undef
ASSERT_BORDER_COLOR_FIELD
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleOutline
{
explicit
nsStyleOutline
(
const
nsPresContext
*
aContext
)
;
nsStyleOutline
(
const
nsStyleOutline
&
aOutline
)
;
~
nsStyleOutline
(
)
{
MOZ_COUNT_DTOR
(
nsStyleOutline
)
;
}
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleOutline
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleOutline
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleOutline
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleOutline
this
)
;
}
void
RecalcData
(
)
;
nsChangeHint
CalcDifference
(
const
nsStyleOutline
&
aNewData
)
const
;
nsStyleCorners
mOutlineRadius
;
nscoord
mOutlineWidth
;
nscoord
mOutlineOffset
;
mozilla
:
:
StyleComplexColor
mOutlineColor
;
uint8_t
mOutlineStyle
;
nscoord
GetOutlineWidth
(
)
const
{
return
mActualOutlineWidth
;
}
bool
ShouldPaintOutline
(
)
const
{
return
mOutlineStyle
=
=
NS_STYLE_BORDER_STYLE_AUTO
|
|
(
GetOutlineWidth
(
)
>
0
&
&
mOutlineStyle
!
=
NS_STYLE_BORDER_STYLE_NONE
)
;
}
protected
:
nscoord
mActualOutlineWidth
;
nscoord
mTwipsPerPixel
;
}
;
class
nsStyleQuoteValues
{
public
:
typedef
nsTArray
<
std
:
:
pair
<
nsString
nsString
>
>
QuotePairArray
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsStyleQuoteValues
)
;
QuotePairArray
mQuotePairs
;
private
:
~
nsStyleQuoteValues
(
)
{
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleList
{
explicit
nsStyleList
(
const
nsPresContext
*
aContext
)
;
nsStyleList
(
const
nsStyleList
&
aStyleList
)
;
~
nsStyleList
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
;
const
static
bool
kHasFinishStyle
=
true
;
void
*
operator
new
(
size_t
sz
nsStyleList
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleList
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleList
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleList
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleList
&
aNewData
const
nsStyleDisplay
*
aOldDisplay
)
const
;
static
void
Shutdown
(
)
{
sInitialQuotes
=
nullptr
;
sNoneQuotes
=
nullptr
;
}
imgRequestProxy
*
GetListStyleImage
(
)
const
{
return
mListStyleImage
?
mListStyleImage
-
>
get
(
)
:
nullptr
;
}
already_AddRefed
<
nsIURI
>
GetListStyleImageURI
(
)
const
;
const
nsStyleQuoteValues
:
:
QuotePairArray
&
GetQuotePairs
(
)
const
;
void
SetQuotesInherit
(
const
nsStyleList
*
aOther
)
;
void
SetQuotesInitial
(
)
;
void
SetQuotesNone
(
)
;
void
SetQuotes
(
nsStyleQuoteValues
:
:
QuotePairArray
&
&
aValues
)
;
uint8_t
mListStylePosition
;
RefPtr
<
nsStyleImageRequest
>
mListStyleImage
;
mozilla
:
:
CounterStylePtr
mCounterStyle
;
private
:
RefPtr
<
nsStyleQuoteValues
>
mQuotes
;
nsStyleList
&
operator
=
(
const
nsStyleList
&
aOther
)
=
delete
;
public
:
nsRect
mImageRegion
;
private
:
static
mozilla
:
:
StaticRefPtr
<
nsStyleQuoteValues
>
sInitialQuotes
;
static
mozilla
:
:
StaticRefPtr
<
nsStyleQuoteValues
>
sNoneQuotes
;
}
;
struct
nsStyleGridLine
{
bool
mHasSpan
;
int32_t
mInteger
;
nsString
mLineName
;
static
const
int32_t
kMinLine
=
-
10000
;
static
const
int32_t
kMaxLine
=
10000
;
nsStyleGridLine
(
)
:
mHasSpan
(
false
)
mInteger
(
0
)
{
}
nsStyleGridLine
(
const
nsStyleGridLine
&
aOther
)
{
(
*
this
)
=
aOther
;
}
void
operator
=
(
const
nsStyleGridLine
&
aOther
)
{
mHasSpan
=
aOther
.
mHasSpan
;
mInteger
=
aOther
.
mInteger
;
mLineName
=
aOther
.
mLineName
;
}
bool
operator
!
=
(
const
nsStyleGridLine
&
aOther
)
const
{
return
mHasSpan
!
=
aOther
.
mHasSpan
|
|
mInteger
!
=
aOther
.
mInteger
|
|
mLineName
!
=
aOther
.
mLineName
;
}
void
SetToInteger
(
uint32_t
value
)
{
mHasSpan
=
false
;
mInteger
=
value
;
mLineName
.
Truncate
(
)
;
}
void
SetAuto
(
)
{
mHasSpan
=
false
;
mInteger
=
0
;
mLineName
.
Truncate
(
)
;
}
bool
IsAuto
(
)
const
{
bool
haveInitialValues
=
mInteger
=
=
0
&
&
mLineName
.
IsEmpty
(
)
;
MOZ_ASSERT
(
!
(
haveInitialValues
&
&
mHasSpan
)
"
should
not
have
'
span
'
when
other
components
are
"
"
at
their
initial
values
"
)
;
return
haveInitialValues
;
}
}
;
struct
nsStyleGridTemplate
{
nsTArray
<
nsTArray
<
nsString
>
>
mLineNameLists
;
nsTArray
<
nsStyleCoord
>
mMinTrackSizingFunctions
;
nsTArray
<
nsStyleCoord
>
mMaxTrackSizingFunctions
;
nsTArray
<
nsString
>
mRepeatAutoLineNameListBefore
;
nsTArray
<
nsString
>
mRepeatAutoLineNameListAfter
;
int16_t
mRepeatAutoIndex
;
bool
mIsAutoFill
:
1
;
bool
mIsSubgrid
:
1
;
nsStyleGridTemplate
(
)
:
mRepeatAutoIndex
(
-
1
)
mIsAutoFill
(
false
)
mIsSubgrid
(
false
)
{
}
inline
bool
operator
=
=
(
const
nsStyleGridTemplate
&
aOther
)
const
{
return
mIsSubgrid
=
=
aOther
.
mIsSubgrid
&
&
mLineNameLists
=
=
aOther
.
mLineNameLists
&
&
mMinTrackSizingFunctions
=
=
aOther
.
mMinTrackSizingFunctions
&
&
mMaxTrackSizingFunctions
=
=
aOther
.
mMaxTrackSizingFunctions
&
&
mIsAutoFill
=
=
aOther
.
mIsAutoFill
&
&
mRepeatAutoIndex
=
=
aOther
.
mRepeatAutoIndex
&
&
mRepeatAutoLineNameListBefore
=
=
aOther
.
mRepeatAutoLineNameListBefore
&
&
mRepeatAutoLineNameListAfter
=
=
aOther
.
mRepeatAutoLineNameListAfter
;
}
bool
HasRepeatAuto
(
)
const
{
return
mRepeatAutoIndex
!
=
-
1
;
}
bool
IsRepeatAutoIndex
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
uint32_t
(
2
*
nsStyleGridLine
:
:
kMaxLine
)
)
;
return
int32_t
(
aIndex
)
=
=
mRepeatAutoIndex
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStylePosition
{
explicit
nsStylePosition
(
const
nsPresContext
*
aContext
)
;
nsStylePosition
(
const
nsStylePosition
&
aOther
)
;
~
nsStylePosition
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStylePosition
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStylePosition
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStylePosition
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStylePosition
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStylePosition
&
aNewData
const
nsStyleVisibility
*
aOldStyleVisibility
)
const
;
uint8_t
UsedAlignSelf
(
nsStyleContext
*
aParent
)
const
;
uint8_t
UsedJustifySelf
(
nsStyleContext
*
aParent
)
const
;
mozilla
:
:
Position
mObjectPosition
;
nsStyleSides
mOffset
;
nsStyleCoord
mWidth
;
nsStyleCoord
mMinWidth
;
nsStyleCoord
mMaxWidth
;
nsStyleCoord
mHeight
;
nsStyleCoord
mMinHeight
;
nsStyleCoord
mMaxHeight
;
nsStyleCoord
mFlexBasis
;
nsStyleCoord
mGridAutoColumnsMin
;
nsStyleCoord
mGridAutoColumnsMax
;
nsStyleCoord
mGridAutoRowsMin
;
nsStyleCoord
mGridAutoRowsMax
;
uint8_t
mGridAutoFlow
;
mozilla
:
:
StyleBoxSizing
mBoxSizing
;
uint16_t
mAlignContent
;
uint8_t
mAlignItems
;
uint8_t
mAlignSelf
;
uint16_t
mJustifyContent
;
uint8_t
mSpecifiedJustifyItems
;
uint8_t
mJustifyItems
;
uint8_t
mJustifySelf
;
uint8_t
mFlexDirection
;
uint8_t
mFlexWrap
;
uint8_t
mObjectFit
;
int32_t
mOrder
;
float
mFlexGrow
;
float
mFlexShrink
;
nsStyleCoord
mZIndex
;
mozilla
:
:
UniquePtr
<
nsStyleGridTemplate
>
mGridTemplateColumns
;
mozilla
:
:
UniquePtr
<
nsStyleGridTemplate
>
mGridTemplateRows
;
RefPtr
<
mozilla
:
:
css
:
:
GridTemplateAreasValue
>
mGridTemplateAreas
;
nsStyleGridLine
mGridColumnStart
;
nsStyleGridLine
mGridColumnEnd
;
nsStyleGridLine
mGridRowStart
;
nsStyleGridLine
mGridRowEnd
;
nsStyleCoord
mGridColumnGap
;
nsStyleCoord
mGridRowGap
;
bool
WidthDependsOnContainer
(
)
const
{
return
mWidth
.
GetUnit
(
)
=
=
eStyleUnit_Auto
|
|
WidthCoordDependsOnContainer
(
mWidth
)
;
}
bool
MinWidthDependsOnContainer
(
)
const
{
return
WidthCoordDependsOnContainer
(
mMinWidth
)
;
}
bool
MaxWidthDependsOnContainer
(
)
const
{
return
WidthCoordDependsOnContainer
(
mMaxWidth
)
;
}
bool
HeightDependsOnContainer
(
)
const
{
return
mHeight
.
GetUnit
(
)
=
=
eStyleUnit_Auto
|
|
HeightCoordDependsOnContainer
(
mHeight
)
;
}
bool
MinHeightDependsOnContainer
(
)
const
{
return
HeightCoordDependsOnContainer
(
mMinHeight
)
;
}
bool
MaxHeightDependsOnContainer
(
)
const
{
return
HeightCoordDependsOnContainer
(
mMaxHeight
)
;
}
bool
OffsetHasPercent
(
mozilla
:
:
Side
aSide
)
const
{
return
mOffset
.
Get
(
aSide
)
.
HasPercent
(
)
;
}
inline
nsStyleCoord
&
ISize
(
mozilla
:
:
WritingMode
aWM
)
;
inline
nsStyleCoord
&
MinISize
(
mozilla
:
:
WritingMode
aWM
)
;
inline
nsStyleCoord
&
MaxISize
(
mozilla
:
:
WritingMode
aWM
)
;
inline
nsStyleCoord
&
BSize
(
mozilla
:
:
WritingMode
aWM
)
;
inline
nsStyleCoord
&
MinBSize
(
mozilla
:
:
WritingMode
aWM
)
;
inline
nsStyleCoord
&
MaxBSize
(
mozilla
:
:
WritingMode
aWM
)
;
inline
const
nsStyleCoord
&
ISize
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
const
nsStyleCoord
&
MinISize
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
const
nsStyleCoord
&
MaxISize
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
const
nsStyleCoord
&
BSize
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
const
nsStyleCoord
&
MinBSize
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
const
nsStyleCoord
&
MaxBSize
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
bool
ISizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
bool
MinISizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
bool
MaxISizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
bool
BSizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
bool
MinBSizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
bool
MaxBSizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
;
const
nsStyleGridTemplate
&
GridTemplateColumns
(
)
const
;
const
nsStyleGridTemplate
&
GridTemplateRows
(
)
const
;
private
:
static
bool
WidthCoordDependsOnContainer
(
const
nsStyleCoord
&
aCoord
)
;
static
bool
HeightCoordDependsOnContainer
(
const
nsStyleCoord
&
aCoord
)
{
return
aCoord
.
HasPercent
(
)
;
}
}
;
struct
nsStyleTextOverflowSide
{
nsStyleTextOverflowSide
(
)
:
mType
(
NS_STYLE_TEXT_OVERFLOW_CLIP
)
{
}
bool
operator
=
=
(
const
nsStyleTextOverflowSide
&
aOther
)
const
{
return
mType
=
=
aOther
.
mType
&
&
(
mType
!
=
NS_STYLE_TEXT_OVERFLOW_STRING
|
|
mString
=
=
aOther
.
mString
)
;
}
bool
operator
!
=
(
const
nsStyleTextOverflowSide
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsString
mString
;
uint8_t
mType
;
}
;
struct
nsStyleTextOverflow
{
nsStyleTextOverflow
(
)
:
mLogicalDirections
(
true
)
{
}
bool
operator
=
=
(
const
nsStyleTextOverflow
&
aOther
)
const
{
return
mLeft
=
=
aOther
.
mLeft
&
&
mRight
=
=
aOther
.
mRight
;
}
bool
operator
!
=
(
const
nsStyleTextOverflow
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
const
nsStyleTextOverflowSide
&
GetLeft
(
uint8_t
aDirection
)
const
{
NS_ASSERTION
(
aDirection
=
=
NS_STYLE_DIRECTION_LTR
|
|
aDirection
=
=
NS_STYLE_DIRECTION_RTL
"
bad
direction
"
)
;
return
!
mLogicalDirections
|
|
aDirection
=
=
NS_STYLE_DIRECTION_LTR
?
mLeft
:
mRight
;
}
const
nsStyleTextOverflowSide
&
GetRight
(
uint8_t
aDirection
)
const
{
NS_ASSERTION
(
aDirection
=
=
NS_STYLE_DIRECTION_LTR
|
|
aDirection
=
=
NS_STYLE_DIRECTION_RTL
"
bad
direction
"
)
;
return
!
mLogicalDirections
|
|
aDirection
=
=
NS_STYLE_DIRECTION_LTR
?
mRight
:
mLeft
;
}
const
nsStyleTextOverflowSide
*
GetFirstValue
(
)
const
{
return
mLogicalDirections
?
&
mRight
:
&
mLeft
;
}
const
nsStyleTextOverflowSide
*
GetSecondValue
(
)
const
{
return
mLogicalDirections
?
nullptr
:
&
mRight
;
}
nsStyleTextOverflowSide
mLeft
;
nsStyleTextOverflowSide
mRight
;
bool
mLogicalDirections
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleTextReset
{
explicit
nsStyleTextReset
(
const
nsPresContext
*
aContext
)
;
nsStyleTextReset
(
const
nsStyleTextReset
&
aOther
)
;
~
nsStyleTextReset
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleTextReset
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleTextReset
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleTextReset
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleTextReset
this
)
;
}
bool
HasTextDecorationLines
(
)
const
{
return
mTextDecorationLine
!
=
NS_STYLE_TEXT_DECORATION_LINE_NONE
&
&
mTextDecorationLine
!
=
NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL
;
}
nsChangeHint
CalcDifference
(
const
nsStyleTextReset
&
aNewData
)
const
;
nsStyleTextOverflow
mTextOverflow
;
uint8_t
mTextDecorationLine
;
uint8_t
mTextDecorationStyle
;
uint8_t
mUnicodeBidi
;
nscoord
mInitialLetterSink
;
float
mInitialLetterSize
;
mozilla
:
:
StyleComplexColor
mTextDecorationColor
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleText
{
explicit
nsStyleText
(
const
nsPresContext
*
aContext
)
;
nsStyleText
(
const
nsStyleText
&
aOther
)
;
~
nsStyleText
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleText
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleText
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleText
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleText
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleText
&
aNewData
)
const
;
uint8_t
mTextAlign
;
uint8_t
mTextAlignLast
;
bool
mTextAlignTrue
:
1
;
bool
mTextAlignLastTrue
:
1
;
mozilla
:
:
StyleTextJustify
mTextJustify
;
uint8_t
mTextTransform
;
mozilla
:
:
StyleWhiteSpace
mWhiteSpace
;
uint8_t
mWordBreak
;
uint8_t
mOverflowWrap
;
mozilla
:
:
StyleHyphens
mHyphens
;
uint8_t
mRubyAlign
;
uint8_t
mRubyPosition
;
uint8_t
mTextSizeAdjust
;
uint8_t
mTextCombineUpright
;
uint8_t
mControlCharacterVisibility
;
uint8_t
mTextEmphasisPosition
;
uint8_t
mTextEmphasisStyle
;
uint8_t
mTextRendering
;
mozilla
:
:
StyleComplexColor
mTextEmphasisColor
;
mozilla
:
:
StyleComplexColor
mWebkitTextFillColor
;
mozilla
:
:
StyleComplexColor
mWebkitTextStrokeColor
;
nsStyleCoord
mTabSize
;
nsStyleCoord
mWordSpacing
;
nsStyleCoord
mLetterSpacing
;
nsStyleCoord
mLineHeight
;
nsStyleCoord
mTextIndent
;
nscoord
mWebkitTextStrokeWidth
;
RefPtr
<
nsCSSShadowArray
>
mTextShadow
;
nsString
mTextEmphasisStyleString
;
bool
WhiteSpaceIsSignificant
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreSpace
;
}
bool
NewlineIsSignificantStyle
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
;
}
bool
WhiteSpaceOrNewlineIsSignificant
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreSpace
;
}
bool
TabIsSignificant
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
;
}
bool
WhiteSpaceCanWrapStyle
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Normal
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
;
}
bool
WordCanWrapStyle
(
)
const
{
return
WhiteSpaceCanWrapStyle
(
)
&
&
mOverflowWrap
=
=
NS_STYLE_OVERFLOWWRAP_BREAK_WORD
;
}
bool
HasTextEmphasis
(
)
const
{
return
!
mTextEmphasisStyleString
.
IsEmpty
(
)
;
}
bool
HasWebkitTextStroke
(
)
const
{
return
mWebkitTextStrokeWidth
>
0
;
}
inline
bool
HasTextShadow
(
)
const
;
inline
nsCSSShadowArray
*
GetTextShadow
(
)
const
;
inline
bool
NewlineIsSignificant
(
const
nsTextFrame
*
aContextFrame
)
const
;
inline
bool
WhiteSpaceCanWrap
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
WordCanWrap
(
const
nsIFrame
*
aContextFrame
)
const
;
mozilla
:
:
LogicalSide
TextEmphasisSide
(
mozilla
:
:
WritingMode
aWM
)
const
;
}
;
struct
nsStyleImageOrientation
{
static
nsStyleImageOrientation
CreateAsAngleAndFlip
(
double
aRadians
bool
aFlip
)
{
uint8_t
orientation
(
0
)
;
double
roundedAngle
=
fmod
(
aRadians
2
*
M_PI
)
;
if
(
roundedAngle
<
0
)
{
roundedAngle
=
roundedAngle
+
2
*
M_PI
;
}
if
(
roundedAngle
<
0
.
25
*
M_PI
)
{
orientation
=
ANGLE_0
;
}
else
if
(
roundedAngle
<
0
.
75
*
M_PI
)
{
orientation
=
ANGLE_90
;
}
else
if
(
roundedAngle
<
1
.
25
*
M_PI
)
{
orientation
=
ANGLE_180
;
}
else
if
(
roundedAngle
<
1
.
75
*
M_PI
)
{
orientation
=
ANGLE_270
;
}
else
{
orientation
=
ANGLE_0
;
}
if
(
aFlip
)
{
orientation
|
=
FLIP_MASK
;
}
return
nsStyleImageOrientation
(
orientation
)
;
}
static
nsStyleImageOrientation
CreateAsOrientationAndFlip
(
uint8_t
aOrientation
bool
aFlip
)
{
MOZ_ASSERT
(
aOrientation
<
=
ANGLE_270
)
;
if
(
aFlip
)
{
aOrientation
|
=
FLIP_MASK
;
}
return
nsStyleImageOrientation
(
aOrientation
)
;
}
static
nsStyleImageOrientation
CreateAsFlip
(
)
{
return
nsStyleImageOrientation
(
FLIP_MASK
)
;
}
static
nsStyleImageOrientation
CreateAsFromImage
(
)
{
return
nsStyleImageOrientation
(
FROM_IMAGE_MASK
)
;
}
nsStyleImageOrientation
(
)
:
mOrientation
(
0
)
{
}
bool
IsDefault
(
)
const
{
return
mOrientation
=
=
0
;
}
bool
IsFlipped
(
)
const
{
return
mOrientation
&
FLIP_MASK
;
}
bool
IsFromImage
(
)
const
{
return
mOrientation
&
FROM_IMAGE_MASK
;
}
bool
SwapsWidthAndHeight
(
)
const
{
uint8_t
angle
=
mOrientation
&
ORIENTATION_MASK
;
return
(
angle
=
=
ANGLE_90
)
|
|
(
angle
=
=
ANGLE_270
)
;
}
mozilla
:
:
image
:
:
Angle
Angle
(
)
const
{
switch
(
mOrientation
&
ORIENTATION_MASK
)
{
case
ANGLE_0
:
return
mozilla
:
:
image
:
:
Angle
:
:
D0
;
case
ANGLE_90
:
return
mozilla
:
:
image
:
:
Angle
:
:
D90
;
case
ANGLE_180
:
return
mozilla
:
:
image
:
:
Angle
:
:
D180
;
case
ANGLE_270
:
return
mozilla
:
:
image
:
:
Angle
:
:
D270
;
default
:
NS_NOTREACHED
(
"
Unexpected
angle
"
)
;
return
mozilla
:
:
image
:
:
Angle
:
:
D0
;
}
}
nsStyleCoord
AngleAsCoord
(
)
const
{
switch
(
mOrientation
&
ORIENTATION_MASK
)
{
case
ANGLE_0
:
return
nsStyleCoord
(
0
.
0f
eStyleUnit_Degree
)
;
case
ANGLE_90
:
return
nsStyleCoord
(
90
.
0f
eStyleUnit_Degree
)
;
case
ANGLE_180
:
return
nsStyleCoord
(
180
.
0f
eStyleUnit_Degree
)
;
case
ANGLE_270
:
return
nsStyleCoord
(
270
.
0f
eStyleUnit_Degree
)
;
default
:
NS_NOTREACHED
(
"
Unexpected
angle
"
)
;
return
nsStyleCoord
(
)
;
}
}
bool
operator
=
=
(
const
nsStyleImageOrientation
&
aOther
)
const
{
return
aOther
.
mOrientation
=
=
mOrientation
;
}
bool
operator
!
=
(
const
nsStyleImageOrientation
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
protected
:
enum
Bits
{
ORIENTATION_MASK
=
0x1
|
0x2
FLIP_MASK
=
0x4
FROM_IMAGE_MASK
=
0x8
}
;
enum
Angles
{
ANGLE_0
=
0
ANGLE_90
=
1
ANGLE_180
=
2
ANGLE_270
=
3
}
;
explicit
nsStyleImageOrientation
(
uint8_t
aOrientation
)
:
mOrientation
(
aOrientation
)
{
}
uint8_t
mOrientation
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleVisibility
{
explicit
nsStyleVisibility
(
const
nsPresContext
*
aContext
)
;
nsStyleVisibility
(
const
nsStyleVisibility
&
aVisibility
)
;
~
nsStyleVisibility
(
)
{
MOZ_COUNT_DTOR
(
nsStyleVisibility
)
;
}
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleVisibility
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleVisibility
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleVisibility
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleVisibility
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleVisibility
&
aNewData
)
const
;
nsStyleImageOrientation
mImageOrientation
;
uint8_t
mDirection
;
uint8_t
mVisible
;
uint8_t
mImageRendering
;
uint8_t
mWritingMode
;
uint8_t
mTextOrientation
;
uint8_t
mColorAdjust
;
bool
IsVisible
(
)
const
{
return
(
mVisible
=
=
NS_STYLE_VISIBILITY_VISIBLE
)
;
}
bool
IsVisibleOrCollapsed
(
)
const
{
return
(
(
mVisible
=
=
NS_STYLE_VISIBILITY_VISIBLE
)
|
|
(
mVisible
=
=
NS_STYLE_VISIBILITY_COLLAPSE
)
)
;
}
}
;
struct
nsTimingFunction
{
enum
class
Type
{
Ease
Linear
EaseIn
EaseOut
EaseInOut
StepStart
StepEnd
CubicBezier
Frames
}
;
static
bool
IsSplineType
(
Type
aType
)
{
return
aType
!
=
Type
:
:
StepStart
&
&
aType
!
=
Type
:
:
StepEnd
&
&
aType
!
=
Type
:
:
Frames
;
}
explicit
nsTimingFunction
(
int32_t
aTimingFunctionType
=
NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE
)
{
AssignFromKeyword
(
aTimingFunctionType
)
;
}
nsTimingFunction
(
float
x1
float
y1
float
x2
float
y2
)
:
mType
(
Type
:
:
CubicBezier
)
{
mFunc
.
mX1
=
x1
;
mFunc
.
mY1
=
y1
;
mFunc
.
mX2
=
x2
;
mFunc
.
mY2
=
y2
;
}
enum
class
Keyword
{
Implicit
Explicit
}
;
nsTimingFunction
(
Type
aType
uint32_t
aStepsOrFrames
)
:
mType
(
aType
)
{
MOZ_ASSERT
(
mType
=
=
Type
:
:
StepStart
|
|
mType
=
=
Type
:
:
StepEnd
|
|
mType
=
=
Type
:
:
Frames
"
wrong
type
"
)
;
mStepsOrFrames
=
aStepsOrFrames
;
}
nsTimingFunction
(
const
nsTimingFunction
&
aOther
)
{
*
this
=
aOther
;
}
Type
mType
;
union
{
struct
{
float
mX1
;
float
mY1
;
float
mX2
;
float
mY2
;
}
mFunc
;
struct
{
uint32_t
mStepsOrFrames
;
}
;
}
;
nsTimingFunction
&
operator
=
(
const
nsTimingFunction
&
aOther
)
{
if
(
&
aOther
=
=
this
)
{
return
*
this
;
}
mType
=
aOther
.
mType
;
if
(
HasSpline
(
)
)
{
mFunc
.
mX1
=
aOther
.
mFunc
.
mX1
;
mFunc
.
mY1
=
aOther
.
mFunc
.
mY1
;
mFunc
.
mX2
=
aOther
.
mFunc
.
mX2
;
mFunc
.
mY2
=
aOther
.
mFunc
.
mY2
;
}
else
{
mStepsOrFrames
=
aOther
.
mStepsOrFrames
;
}
return
*
this
;
}
bool
operator
=
=
(
const
nsTimingFunction
&
aOther
)
const
{
if
(
mType
!
=
aOther
.
mType
)
{
return
false
;
}
if
(
HasSpline
(
)
)
{
return
mFunc
.
mX1
=
=
aOther
.
mFunc
.
mX1
&
&
mFunc
.
mY1
=
=
aOther
.
mFunc
.
mY1
&
&
mFunc
.
mX2
=
=
aOther
.
mFunc
.
mX2
&
&
mFunc
.
mY2
=
=
aOther
.
mFunc
.
mY2
;
}
return
mStepsOrFrames
=
=
aOther
.
mStepsOrFrames
;
}
bool
operator
!
=
(
const
nsTimingFunction
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
bool
HasSpline
(
)
const
{
return
IsSplineType
(
mType
)
;
}
private
:
void
AssignFromKeyword
(
int32_t
aTimingFunctionType
)
;
}
;
namespace
mozilla
{
struct
StyleTransition
{
StyleTransition
(
)
{
}
explicit
StyleTransition
(
const
StyleTransition
&
aCopy
)
;
void
SetInitialValues
(
)
;
const
nsTimingFunction
&
GetTimingFunction
(
)
const
{
return
mTimingFunction
;
}
float
GetDelay
(
)
const
{
return
mDelay
;
}
float
GetDuration
(
)
const
{
return
mDuration
;
}
nsCSSPropertyID
GetProperty
(
)
const
{
return
mProperty
;
}
nsAtom
*
GetUnknownProperty
(
)
const
{
return
mUnknownProperty
;
}
float
GetCombinedDuration
(
)
const
{
return
std
:
:
max
(
mDuration
0
.
0f
)
+
mDelay
;
}
void
SetTimingFunction
(
const
nsTimingFunction
&
aTimingFunction
)
{
mTimingFunction
=
aTimingFunction
;
}
void
SetDelay
(
float
aDelay
)
{
mDelay
=
aDelay
;
}
void
SetDuration
(
float
aDuration
)
{
mDuration
=
aDuration
;
}
void
SetProperty
(
nsCSSPropertyID
aProperty
)
{
NS_ASSERTION
(
aProperty
!
=
eCSSProperty_UNKNOWN
&
&
aProperty
!
=
eCSSPropertyExtra_variable
"
invalid
property
"
)
;
mProperty
=
aProperty
;
}
void
SetUnknownProperty
(
nsCSSPropertyID
aProperty
const
nsAString
&
aPropertyString
)
;
void
SetUnknownProperty
(
nsCSSPropertyID
aProperty
nsAtom
*
aPropertyString
)
;
void
CopyPropertyFrom
(
const
StyleTransition
&
aOther
)
{
mProperty
=
aOther
.
mProperty
;
mUnknownProperty
=
aOther
.
mUnknownProperty
;
}
nsTimingFunction
&
TimingFunctionSlot
(
)
{
return
mTimingFunction
;
}
bool
operator
=
=
(
const
StyleTransition
&
aOther
)
const
;
bool
operator
!
=
(
const
StyleTransition
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTimingFunction
mTimingFunction
;
float
mDuration
;
float
mDelay
;
nsCSSPropertyID
mProperty
;
RefPtr
<
nsAtom
>
mUnknownProperty
;
}
;
struct
StyleAnimation
{
StyleAnimation
(
)
{
}
explicit
StyleAnimation
(
const
StyleAnimation
&
aCopy
)
;
void
SetInitialValues
(
)
;
const
nsTimingFunction
&
GetTimingFunction
(
)
const
{
return
mTimingFunction
;
}
float
GetDelay
(
)
const
{
return
mDelay
;
}
float
GetDuration
(
)
const
{
return
mDuration
;
}
nsAtom
*
GetName
(
)
const
{
return
mName
;
}
dom
:
:
PlaybackDirection
GetDirection
(
)
const
{
return
mDirection
;
}
dom
:
:
FillMode
GetFillMode
(
)
const
{
return
mFillMode
;
}
uint8_t
GetPlayState
(
)
const
{
return
mPlayState
;
}
float
GetIterationCount
(
)
const
{
return
mIterationCount
;
}
void
SetTimingFunction
(
const
nsTimingFunction
&
aTimingFunction
)
{
mTimingFunction
=
aTimingFunction
;
}
void
SetDelay
(
float
aDelay
)
{
mDelay
=
aDelay
;
}
void
SetDuration
(
float
aDuration
)
{
mDuration
=
aDuration
;
}
void
SetName
(
already_AddRefed
<
nsAtom
>
aName
)
{
mName
=
aName
;
}
void
SetName
(
nsAtom
*
aName
)
{
mName
=
aName
;
}
void
SetDirection
(
dom
:
:
PlaybackDirection
aDirection
)
{
mDirection
=
aDirection
;
}
void
SetFillMode
(
dom
:
:
FillMode
aFillMode
)
{
mFillMode
=
aFillMode
;
}
void
SetPlayState
(
uint8_t
aPlayState
)
{
mPlayState
=
aPlayState
;
}
void
SetIterationCount
(
float
aIterationCount
)
{
mIterationCount
=
aIterationCount
;
}
nsTimingFunction
&
TimingFunctionSlot
(
)
{
return
mTimingFunction
;
}
bool
operator
=
=
(
const
StyleAnimation
&
aOther
)
const
;
bool
operator
!
=
(
const
StyleAnimation
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTimingFunction
mTimingFunction
;
float
mDuration
;
float
mDelay
;
RefPtr
<
nsAtom
>
mName
;
dom
:
:
PlaybackDirection
mDirection
;
dom
:
:
FillMode
mFillMode
;
uint8_t
mPlayState
;
float
mIterationCount
;
}
;
class
StyleBasicShape
final
{
public
:
explicit
StyleBasicShape
(
StyleBasicShapeType
type
)
:
mType
(
type
)
mFillRule
(
StyleFillRule
:
:
Nonzero
)
{
mPosition
.
SetInitialPercentValues
(
0
.
5f
)
;
}
StyleBasicShapeType
GetShapeType
(
)
const
{
return
mType
;
}
nsCSSKeyword
GetShapeTypeName
(
)
const
;
StyleFillRule
GetFillRule
(
)
const
{
return
mFillRule
;
}
void
SetFillRule
(
StyleFillRule
aFillRule
)
{
MOZ_ASSERT
(
mType
=
=
StyleBasicShapeType
:
:
Polygon
"
expected
polygon
"
)
;
mFillRule
=
aFillRule
;
}
Position
&
GetPosition
(
)
{
MOZ_ASSERT
(
mType
=
=
StyleBasicShapeType
:
:
Circle
|
|
mType
=
=
StyleBasicShapeType
:
:
Ellipse
"
expected
circle
or
ellipse
"
)
;
return
mPosition
;
}
const
Position
&
GetPosition
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleBasicShapeType
:
:
Circle
|
|
mType
=
=
StyleBasicShapeType
:
:
Ellipse
"
expected
circle
or
ellipse
"
)
;
return
mPosition
;
}
bool
HasRadius
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleBasicShapeType
:
:
Inset
"
expected
inset
"
)
;
nsStyleCoord
zero
;
zero
.
SetCoordValue
(
0
)
;
NS_FOR_CSS_HALF_CORNERS
(
corner
)
{
if
(
mRadius
.
Get
(
corner
)
!
=
zero
)
{
return
true
;
}
}
return
false
;
}
nsStyleCorners
&
GetRadius
(
)
{
MOZ_ASSERT
(
mType
=
=
StyleBasicShapeType
:
:
Inset
"
expected
inset
"
)
;
return
mRadius
;
}
const
nsStyleCorners
&
GetRadius
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleBasicShapeType
:
:
Inset
"
expected
inset
"
)
;
return
mRadius
;
}
nsTArray
<
nsStyleCoord
>
&
Coordinates
(
)
{
return
mCoordinates
;
}
const
nsTArray
<
nsStyleCoord
>
&
Coordinates
(
)
const
{
return
mCoordinates
;
}
bool
operator
=
=
(
const
StyleBasicShape
&
aOther
)
const
{
return
mType
=
=
aOther
.
mType
&
&
mFillRule
=
=
aOther
.
mFillRule
&
&
mCoordinates
=
=
aOther
.
mCoordinates
&
&
mPosition
=
=
aOther
.
mPosition
&
&
mRadius
=
=
aOther
.
mRadius
;
}
bool
operator
!
=
(
const
StyleBasicShape
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
StyleBasicShapeType
mType
;
StyleFillRule
mFillRule
;
nsTArray
<
nsStyleCoord
>
mCoordinates
;
Position
mPosition
;
nsStyleCorners
mRadius
;
}
;
struct
StyleShapeSource
final
{
StyleShapeSource
(
)
=
default
;
StyleShapeSource
(
const
StyleShapeSource
&
aSource
)
;
~
StyleShapeSource
(
)
{
}
StyleShapeSource
&
operator
=
(
const
StyleShapeSource
&
aOther
)
;
bool
operator
=
=
(
const
StyleShapeSource
&
aOther
)
const
;
bool
operator
!
=
(
const
StyleShapeSource
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
StyleShapeSourceType
GetType
(
)
const
{
return
mType
;
}
css
:
:
URLValue
*
GetURL
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
URL
"
Wrong
shape
source
type
!
"
)
;
return
mShapeImage
?
static_cast
<
css
:
:
URLValue
*
>
(
mShapeImage
-
>
GetURLValue
(
)
)
:
nullptr
;
}
void
SetURL
(
css
:
:
URLValue
*
aValue
)
;
const
UniquePtr
<
nsStyleImage
>
&
GetShapeImage
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Image
"
Wrong
shape
source
type
!
"
)
;
return
mShapeImage
;
}
void
SetShapeImage
(
UniquePtr
<
nsStyleImage
>
aShapeImage
)
;
const
UniquePtr
<
StyleBasicShape
>
&
GetBasicShape
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Shape
"
Wrong
shape
source
type
!
"
)
;
return
mBasicShape
;
}
void
SetBasicShape
(
UniquePtr
<
StyleBasicShape
>
aBasicShape
StyleGeometryBox
aReferenceBox
)
;
StyleGeometryBox
GetReferenceBox
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Box
|
|
mType
=
=
StyleShapeSourceType
:
:
Shape
"
Wrong
shape
source
type
!
"
)
;
return
mReferenceBox
;
}
void
SetReferenceBox
(
StyleGeometryBox
aReferenceBox
)
;
private
:
void
*
operator
new
(
size_t
)
=
delete
;
void
DoCopy
(
const
StyleShapeSource
&
aOther
)
;
mozilla
:
:
UniquePtr
<
StyleBasicShape
>
mBasicShape
;
mozilla
:
:
UniquePtr
<
nsStyleImage
>
mShapeImage
;
StyleShapeSourceType
mType
=
StyleShapeSourceType
:
:
None
;
StyleGeometryBox
mReferenceBox
=
StyleGeometryBox
:
:
NoBox
;
}
;
}
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleDisplay
{
typedef
mozilla
:
:
StyleGeometryBox
StyleGeometryBox
;
explicit
nsStyleDisplay
(
const
nsPresContext
*
aContext
)
;
nsStyleDisplay
(
const
nsStyleDisplay
&
aOther
)
;
~
nsStyleDisplay
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
;
const
static
bool
kHasFinishStyle
=
true
;
void
*
operator
new
(
size_t
sz
nsStyleDisplay
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleDisplay
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleDisplay
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleDisplay
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleDisplay
&
aNewData
)
const
;
RefPtr
<
mozilla
:
:
css
:
:
URLValue
>
mBinding
;
mozilla
:
:
StyleDisplay
mDisplay
;
mozilla
:
:
StyleDisplay
mOriginalDisplay
;
uint8_t
mContain
;
uint8_t
mAppearance
;
uint8_t
mPosition
;
mozilla
:
:
StyleFloat
mFloat
;
mozilla
:
:
StyleFloat
mOriginalFloat
;
mozilla
:
:
StyleClear
mBreakType
;
uint8_t
mBreakInside
;
bool
mBreakBefore
;
bool
mBreakAfter
;
uint8_t
mOverflowX
;
uint8_t
mOverflowY
;
uint8_t
mOverflowClipBoxBlock
;
uint8_t
mOverflowClipBoxInline
;
uint8_t
mResize
;
mozilla
:
:
StyleOrient
mOrient
;
uint8_t
mIsolation
;
uint8_t
mTopLayer
;
uint8_t
mWillChangeBitField
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mWillChange
;
uint8_t
mTouchAction
;
uint8_t
mScrollBehavior
;
mozilla
:
:
StyleOverscrollBehavior
mOverscrollBehaviorX
;
mozilla
:
:
StyleOverscrollBehavior
mOverscrollBehaviorY
;
uint8_t
mScrollSnapTypeX
;
uint8_t
mScrollSnapTypeY
;
nsStyleCoord
mScrollSnapPointsX
;
nsStyleCoord
mScrollSnapPointsY
;
mozilla
:
:
Position
mScrollSnapDestination
;
nsTArray
<
mozilla
:
:
Position
>
mScrollSnapCoordinate
;
uint8_t
mBackfaceVisibility
;
uint8_t
mTransformStyle
;
StyleGeometryBox
mTransformBox
;
RefPtr
<
nsCSSValueSharedList
>
mSpecifiedTransform
;
nsStyleCoord
mTransformOrigin
[
3
]
;
nsStyleCoord
mChildPerspective
;
nsStyleCoord
mPerspectiveOrigin
[
2
]
;
nsStyleCoord
mVerticalAlign
;
nsStyleAutoArray
<
mozilla
:
:
StyleTransition
>
mTransitions
;
uint32_t
mTransitionTimingFunctionCount
mTransitionDurationCount
mTransitionDelayCount
mTransitionPropertyCount
;
nsStyleAutoArray
<
mozilla
:
:
StyleAnimation
>
mAnimations
;
uint32_t
mAnimationTimingFunctionCount
mAnimationDurationCount
mAnimationDelayCount
mAnimationNameCount
mAnimationDirectionCount
mAnimationFillModeCount
mAnimationPlayStateCount
mAnimationIterationCountCount
;
float
mShapeImageThreshold
=
0
.
0f
;
mozilla
:
:
StyleShapeSource
mShapeOutside
;
bool
IsBlockInsideStyle
(
)
const
{
return
mozilla
:
:
StyleDisplay
:
:
Block
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
ListItem
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineBlock
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableCaption
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
FlowRoot
=
=
mDisplay
;
}
bool
IsBlockOutsideStyle
(
)
const
{
return
mozilla
:
:
StyleDisplay
:
:
Block
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Flex
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
WebkitBox
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Grid
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
ListItem
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Table
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
FlowRoot
=
=
mDisplay
;
}
static
bool
IsDisplayTypeInlineOutside
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
mozilla
:
:
StyleDisplay
:
:
Inline
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineBlock
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineTable
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
MozInlineBox
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineFlex
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
WebkitInlineBox
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineGrid
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
MozInlineGrid
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
MozInlineStack
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Ruby
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBase
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyText
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Contents
=
=
aDisplay
;
}
bool
IsInlineOutsideStyle
(
)
const
{
return
IsDisplayTypeInlineOutside
(
mDisplay
)
;
}
bool
IsOriginalDisplayInlineOutsideStyle
(
)
const
{
return
IsDisplayTypeInlineOutside
(
mOriginalDisplay
)
;
}
bool
IsInnerTableStyle
(
)
const
{
return
mozilla
:
:
StyleDisplay
:
:
TableCaption
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableCell
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableRow
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableRowGroup
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableHeaderGroup
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableFooterGroup
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableColumn
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
=
=
mDisplay
;
}
bool
IsFloatingStyle
(
)
const
{
return
mozilla
:
:
StyleFloat
:
:
None
!
=
mFloat
;
}
bool
IsAbsolutelyPositionedStyle
(
)
const
{
return
NS_STYLE_POSITION_ABSOLUTE
=
=
mPosition
|
|
NS_STYLE_POSITION_FIXED
=
=
mPosition
;
}
bool
IsRelativelyPositionedStyle
(
)
const
{
return
NS_STYLE_POSITION_RELATIVE
=
=
mPosition
|
|
NS_STYLE_POSITION_STICKY
=
=
mPosition
;
}
bool
IsPositionForcingStackingContext
(
)
const
{
return
NS_STYLE_POSITION_STICKY
=
=
mPosition
|
|
NS_STYLE_POSITION_FIXED
=
=
mPosition
;
}
static
bool
IsRubyDisplayType
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
mozilla
:
:
StyleDisplay
:
:
Ruby
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBase
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyText
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
=
=
aDisplay
;
}
bool
IsRubyDisplayType
(
)
const
{
return
IsRubyDisplayType
(
mDisplay
)
;
}
bool
IsOutOfFlowStyle
(
)
const
{
return
(
IsAbsolutelyPositionedStyle
(
)
|
|
IsFloatingStyle
(
)
)
;
}
bool
IsScrollableOverflow
(
)
const
{
return
mOverflowX
!
=
NS_STYLE_OVERFLOW_VISIBLE
&
&
mOverflowX
!
=
NS_STYLE_OVERFLOW_CLIP
;
}
bool
IsContainPaint
(
)
const
{
return
NS_STYLE_CONTAIN_PAINT
&
mContain
;
}
bool
HasTransformStyle
(
)
const
{
return
mSpecifiedTransform
!
=
nullptr
|
|
mTransformStyle
=
=
NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D
|
|
(
mWillChangeBitField
&
NS_STYLE_WILL_CHANGE_TRANSFORM
)
;
}
bool
HasPerspectiveStyle
(
)
const
{
return
mChildPerspective
.
GetUnit
(
)
=
=
eStyleUnit_Coord
;
}
bool
BackfaceIsHidden
(
)
const
{
return
mBackfaceVisibility
=
=
NS_STYLE_BACKFACE_VISIBILITY_HIDDEN
;
}
inline
bool
IsBlockInside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsBlockOutside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsInlineOutside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsOriginalDisplayInlineOutside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
mozilla
:
:
StyleDisplay
GetDisplay
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsFloating
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsRelativelyPositioned
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsAbsolutelyPositioned
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsAbsPosContainingBlock
(
const
nsIFrame
*
aContextFrame
)
const
;
template
<
class
StyleContextLike
>
inline
bool
IsAbsPosContainingBlockForAppropriateFrame
(
StyleContextLike
*
aStyleContext
)
const
;
inline
bool
HasTransform
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsFixedPosContainingBlock
(
const
nsIFrame
*
aContextFrame
)
const
;
template
<
class
StyleContextLike
>
inline
bool
IsFixedPosContainingBlockForAppropriateFrame
(
StyleContextLike
*
aStyleContext
)
const
;
private
:
template
<
class
StyleContextLike
>
inline
bool
HasAbsPosContainingBlockStyleInternal
(
StyleContextLike
*
aStyleContext
)
const
;
template
<
class
StyleContextLike
>
inline
bool
HasFixedPosContainingBlockStyleInternal
(
StyleContextLike
*
aStyleContext
)
const
;
public
:
inline
mozilla
:
:
StyleFloat
PhysicalFloats
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
mozilla
:
:
StyleClear
PhysicalBreakType
(
mozilla
:
:
WritingMode
aWM
)
const
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleTable
{
explicit
nsStyleTable
(
const
nsPresContext
*
aContext
)
;
nsStyleTable
(
const
nsStyleTable
&
aOther
)
;
~
nsStyleTable
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleTable
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleTable
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleTable
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleTable
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleTable
&
aNewData
)
const
;
uint8_t
mLayoutStrategy
;
int32_t
mSpan
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleTableBorder
{
explicit
nsStyleTableBorder
(
const
nsPresContext
*
aContext
)
;
nsStyleTableBorder
(
const
nsStyleTableBorder
&
aOther
)
;
~
nsStyleTableBorder
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleTableBorder
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleTableBorder
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleTableBorder
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleTableBorder
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleTableBorder
&
aNewData
)
const
;
nscoord
mBorderSpacingCol
;
nscoord
mBorderSpacingRow
;
uint8_t
mBorderCollapse
;
uint8_t
mCaptionSide
;
uint8_t
mEmptyCells
;
}
;
enum
nsStyleContentType
{
eStyleContentType_String
=
1
eStyleContentType_Image
=
10
eStyleContentType_Attr
=
20
eStyleContentType_Counter
=
30
eStyleContentType_Counters
=
31
eStyleContentType_OpenQuote
=
40
eStyleContentType_CloseQuote
=
41
eStyleContentType_NoOpenQuote
=
42
eStyleContentType_NoCloseQuote
=
43
eStyleContentType_AltContent
=
50
eStyleContentType_Uninitialized
}
;
class
nsStyleContentData
{
public
:
nsStyleContentData
(
)
:
mType
(
eStyleContentType_Uninitialized
)
{
MOZ_COUNT_CTOR
(
nsStyleContentData
)
;
mContent
.
mString
=
nullptr
;
}
nsStyleContentData
(
const
nsStyleContentData
&
)
;
~
nsStyleContentData
(
)
;
nsStyleContentData
&
operator
=
(
const
nsStyleContentData
&
aOther
)
;
bool
operator
=
=
(
const
nsStyleContentData
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleContentData
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsStyleContentType
GetType
(
)
const
{
return
mType
;
}
char16_t
*
GetString
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleContentType_String
|
|
mType
=
=
eStyleContentType_Attr
)
;
return
mContent
.
mString
;
}
struct
CounterFunction
{
nsString
mIdent
;
nsString
mSeparator
;
mozilla
:
:
CounterStylePtr
mCounterStyle
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CounterFunction
)
bool
operator
=
=
(
const
CounterFunction
&
aOther
)
const
;
bool
operator
!
=
(
const
CounterFunction
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
~
CounterFunction
(
)
{
}
}
;
CounterFunction
*
GetCounters
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleContentType_Counter
|
|
mType
=
=
eStyleContentType_Counters
)
;
MOZ_ASSERT
(
mContent
.
mCounters
-
>
mCounterStyle
.
IsResolved
(
)
"
Counter
style
should
have
been
resolved
"
)
;
return
mContent
.
mCounters
;
}
nsStyleImageRequest
*
GetImageRequest
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleContentType_Image
)
;
return
mContent
.
mImage
;
}
imgRequestProxy
*
GetImage
(
)
const
{
return
GetImageRequest
(
)
-
>
get
(
)
;
}
void
SetKeyword
(
nsStyleContentType
aType
)
{
MOZ_ASSERT
(
aType
=
=
eStyleContentType_OpenQuote
|
|
aType
=
=
eStyleContentType_CloseQuote
|
|
aType
=
=
eStyleContentType_NoOpenQuote
|
|
aType
=
=
eStyleContentType_NoCloseQuote
|
|
aType
=
=
eStyleContentType_AltContent
)
;
MOZ_ASSERT
(
mType
=
=
eStyleContentType_Uninitialized
"
should
only
initialize
nsStyleContentData
once
"
)
;
mType
=
aType
;
}
void
SetString
(
nsStyleContentType
aType
const
char16_t
*
aString
)
{
MOZ_ASSERT
(
aType
=
=
eStyleContentType_String
|
|
aType
=
=
eStyleContentType_Attr
)
;
MOZ_ASSERT
(
aString
)
;
MOZ_ASSERT
(
mType
=
=
eStyleContentType_Uninitialized
"
should
only
initialize
nsStyleContentData
once
"
)
;
mType
=
aType
;
mContent
.
mString
=
NS_strdup
(
aString
)
;
}
void
SetCounters
(
nsStyleContentType
aType
already_AddRefed
<
CounterFunction
>
aCounterFunction
)
{
MOZ_ASSERT
(
aType
=
=
eStyleContentType_Counter
|
|
aType
=
=
eStyleContentType_Counters
)
;
MOZ_ASSERT
(
mType
=
=
eStyleContentType_Uninitialized
"
should
only
initialize
nsStyleContentData
once
"
)
;
mType
=
aType
;
mContent
.
mCounters
=
aCounterFunction
.
take
(
)
;
MOZ_ASSERT
(
mContent
.
mCounters
)
;
}
void
SetImageRequest
(
already_AddRefed
<
nsStyleImageRequest
>
aRequest
)
{
MOZ_ASSERT
(
mType
=
=
eStyleContentType_Uninitialized
"
should
only
initialize
nsStyleContentData
once
"
)
;
mType
=
eStyleContentType_Image
;
mContent
.
mImage
=
aRequest
.
take
(
)
;
MOZ_ASSERT
(
mContent
.
mImage
)
;
}
void
Resolve
(
nsPresContext
*
aPresContext
)
;
private
:
nsStyleContentType
mType
;
union
{
char16_t
*
mString
;
nsStyleImageRequest
*
mImage
;
CounterFunction
*
mCounters
;
}
mContent
;
}
;
struct
nsStyleCounterData
{
nsString
mCounter
;
int32_t
mValue
;
bool
operator
=
=
(
const
nsStyleCounterData
&
aOther
)
const
{
return
mValue
=
=
aOther
.
mValue
&
&
mCounter
=
=
aOther
.
mCounter
;
}
bool
operator
!
=
(
const
nsStyleCounterData
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleContent
{
explicit
nsStyleContent
(
const
nsPresContext
*
aContext
)
;
nsStyleContent
(
const
nsStyleContent
&
aContent
)
;
~
nsStyleContent
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
;
const
static
bool
kHasFinishStyle
=
true
;
void
*
operator
new
(
size_t
sz
nsStyleContent
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleContent
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
;
nsChangeHint
CalcDifference
(
const
nsStyleContent
&
aNewData
)
const
;
uint32_t
ContentCount
(
)
const
{
return
mContents
.
Length
(
)
;
}
const
nsStyleContentData
&
ContentAt
(
uint32_t
aIndex
)
const
{
return
mContents
[
aIndex
]
;
}
nsStyleContentData
&
ContentAt
(
uint32_t
aIndex
)
{
return
mContents
[
aIndex
]
;
}
void
AllocateContents
(
uint32_t
aCount
)
{
mContents
.
Clear
(
)
;
mContents
.
SetLength
(
aCount
)
;
}
uint32_t
CounterIncrementCount
(
)
const
{
return
mIncrements
.
Length
(
)
;
}
const
nsStyleCounterData
&
CounterIncrementAt
(
uint32_t
aIndex
)
const
{
return
mIncrements
[
aIndex
]
;
}
void
AllocateCounterIncrements
(
uint32_t
aCount
)
{
mIncrements
.
Clear
(
)
;
mIncrements
.
SetLength
(
aCount
)
;
}
void
SetCounterIncrementAt
(
uint32_t
aIndex
const
nsString
&
aCounter
int32_t
aIncrement
)
{
mIncrements
[
aIndex
]
.
mCounter
=
aCounter
;
mIncrements
[
aIndex
]
.
mValue
=
aIncrement
;
}
uint32_t
CounterResetCount
(
)
const
{
return
mResets
.
Length
(
)
;
}
const
nsStyleCounterData
&
CounterResetAt
(
uint32_t
aIndex
)
const
{
return
mResets
[
aIndex
]
;
}
void
AllocateCounterResets
(
uint32_t
aCount
)
{
mResets
.
Clear
(
)
;
mResets
.
SetLength
(
aCount
)
;
}
void
SetCounterResetAt
(
uint32_t
aIndex
const
nsString
&
aCounter
int32_t
aValue
)
{
mResets
[
aIndex
]
.
mCounter
=
aCounter
;
mResets
[
aIndex
]
.
mValue
=
aValue
;
}
protected
:
nsTArray
<
nsStyleContentData
>
mContents
;
nsTArray
<
nsStyleCounterData
>
mIncrements
;
nsTArray
<
nsStyleCounterData
>
mResets
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleUIReset
{
explicit
nsStyleUIReset
(
const
nsPresContext
*
aContext
)
;
nsStyleUIReset
(
const
nsStyleUIReset
&
aOther
)
;
~
nsStyleUIReset
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleUIReset
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleUIReset
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleUIReset
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleUIReset
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleUIReset
&
aNewData
)
const
;
mozilla
:
:
StyleUserSelect
mUserSelect
;
uint8_t
mForceBrokenImageIcon
;
uint8_t
mIMEMode
;
mozilla
:
:
StyleWindowDragging
mWindowDragging
;
uint8_t
mWindowShadow
;
float
mWindowOpacity
;
RefPtr
<
nsCSSValueSharedList
>
mSpecifiedWindowTransform
;
nsStyleCoord
mWindowTransformOrigin
[
2
]
;
}
;
struct
nsCursorImage
{
bool
mHaveHotspot
;
float
mHotspotX
mHotspotY
;
RefPtr
<
nsStyleImageRequest
>
mImage
;
nsCursorImage
(
)
;
nsCursorImage
(
const
nsCursorImage
&
aOther
)
;
nsCursorImage
&
operator
=
(
const
nsCursorImage
&
aOther
)
;
bool
operator
=
=
(
const
nsCursorImage
&
aOther
)
const
;
bool
operator
!
=
(
const
nsCursorImage
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
imgRequestProxy
*
GetImage
(
)
const
{
return
mImage
-
>
get
(
)
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleUserInterface
{
explicit
nsStyleUserInterface
(
const
nsPresContext
*
aContext
)
;
nsStyleUserInterface
(
const
nsStyleUserInterface
&
aOther
)
;
~
nsStyleUserInterface
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
;
const
static
bool
kHasFinishStyle
=
true
;
void
*
operator
new
(
size_t
sz
nsStyleUserInterface
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleUserInterface
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleUserInterface
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleUserInterface
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleUserInterface
&
aNewData
)
const
;
mozilla
:
:
StyleUserInput
mUserInput
;
mozilla
:
:
StyleUserModify
mUserModify
;
mozilla
:
:
StyleUserFocus
mUserFocus
;
uint8_t
mPointerEvents
;
uint8_t
mCursor
;
nsTArray
<
nsCursorImage
>
mCursorImages
;
mozilla
:
:
StyleComplexColor
mCaretColor
;
inline
uint8_t
GetEffectivePointerEvents
(
nsIFrame
*
aFrame
)
const
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleXUL
{
explicit
nsStyleXUL
(
const
nsPresContext
*
aContext
)
;
nsStyleXUL
(
const
nsStyleXUL
&
aSource
)
;
~
nsStyleXUL
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleXUL
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleXUL
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleXUL
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleXUL
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleXUL
&
aNewData
)
const
;
float
mBoxFlex
;
uint32_t
mBoxOrdinal
;
mozilla
:
:
StyleBoxAlign
mBoxAlign
;
mozilla
:
:
StyleBoxDirection
mBoxDirection
;
mozilla
:
:
StyleBoxOrient
mBoxOrient
;
mozilla
:
:
StyleBoxPack
mBoxPack
;
mozilla
:
:
StyleStackSizing
mStackSizing
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleColumn
{
explicit
nsStyleColumn
(
const
nsPresContext
*
aContext
)
;
nsStyleColumn
(
const
nsStyleColumn
&
aSource
)
;
~
nsStyleColumn
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleColumn
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleColumn
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleColumn
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleColumn
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleColumn
&
aNewData
)
const
;
static
const
uint32_t
kMaxColumnCount
=
1000
;
uint32_t
mColumnCount
;
nsStyleCoord
mColumnWidth
;
nsStyleCoord
mColumnGap
;
mozilla
:
:
StyleComplexColor
mColumnRuleColor
;
uint8_t
mColumnRuleStyle
;
uint8_t
mColumnFill
;
uint8_t
mColumnSpan
;
void
SetColumnRuleWidth
(
nscoord
aWidth
)
{
mColumnRuleWidth
=
NS_ROUND_BORDER_TO_PIXELS
(
aWidth
mTwipsPerPixel
)
;
}
nscoord
GetComputedColumnRuleWidth
(
)
const
{
return
(
IsVisibleBorderStyle
(
mColumnRuleStyle
)
?
mColumnRuleWidth
:
0
)
;
}
protected
:
nscoord
mColumnRuleWidth
;
nscoord
mTwipsPerPixel
;
}
;
enum
nsStyleSVGPaintType
:
uint8_t
{
eStyleSVGPaintType_None
=
1
eStyleSVGPaintType_Color
eStyleSVGPaintType_Server
eStyleSVGPaintType_ContextFill
eStyleSVGPaintType_ContextStroke
}
;
enum
nsStyleSVGFallbackType
:
uint8_t
{
eStyleSVGFallbackType_NotSet
eStyleSVGFallbackType_None
eStyleSVGFallbackType_Color
}
;
enum
nsStyleSVGOpacitySource
:
uint8_t
{
eStyleSVGOpacitySource_Normal
eStyleSVGOpacitySource_ContextFillOpacity
eStyleSVGOpacitySource_ContextStrokeOpacity
}
;
class
nsStyleSVGPaint
{
public
:
explicit
nsStyleSVGPaint
(
nsStyleSVGPaintType
aType
=
nsStyleSVGPaintType
(
0
)
)
;
nsStyleSVGPaint
(
const
nsStyleSVGPaint
&
aSource
)
;
~
nsStyleSVGPaint
(
)
;
nsStyleSVGPaint
&
operator
=
(
const
nsStyleSVGPaint
&
aOther
)
;
nsStyleSVGPaintType
Type
(
)
const
{
return
mType
;
}
void
SetNone
(
)
;
void
SetColor
(
nscolor
aColor
)
;
void
SetPaintServer
(
mozilla
:
:
css
:
:
URLValue
*
aPaintServer
nsStyleSVGFallbackType
aFallbackType
nscolor
aFallbackColor
)
;
void
SetPaintServer
(
mozilla
:
:
css
:
:
URLValue
*
aPaintServer
)
{
SetPaintServer
(
aPaintServer
eStyleSVGFallbackType_NotSet
NS_RGB
(
0
0
0
)
)
;
}
void
SetContextValue
(
nsStyleSVGPaintType
aType
nsStyleSVGFallbackType
aFallbackType
nscolor
aFallbackColor
)
;
void
SetContextValue
(
nsStyleSVGPaintType
aType
)
{
SetContextValue
(
aType
eStyleSVGFallbackType_NotSet
NS_RGB
(
0
0
0
)
)
;
}
nscolor
GetColor
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleSVGPaintType_Color
)
;
return
mPaint
.
mColor
;
}
mozilla
:
:
css
:
:
URLValue
*
GetPaintServer
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleSVGPaintType_Server
)
;
return
mPaint
.
mPaintServer
;
}
nsStyleSVGFallbackType
GetFallbackType
(
)
const
{
return
mFallbackType
;
}
nscolor
GetFallbackColor
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleSVGPaintType_Server
|
|
mType
=
=
eStyleSVGPaintType_ContextFill
|
|
mType
=
=
eStyleSVGPaintType_ContextStroke
)
;
return
mFallbackColor
;
}
bool
operator
=
=
(
const
nsStyleSVGPaint
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleSVGPaint
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
void
Reset
(
)
;
void
Assign
(
const
nsStyleSVGPaint
&
aOther
)
;
union
{
nscolor
mColor
;
mozilla
:
:
css
:
:
URLValue
*
mPaintServer
;
}
mPaint
;
nsStyleSVGPaintType
mType
;
nsStyleSVGFallbackType
mFallbackType
;
nscolor
mFallbackColor
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleSVG
{
explicit
nsStyleSVG
(
const
nsPresContext
*
aContext
)
;
nsStyleSVG
(
const
nsStyleSVG
&
aSource
)
;
~
nsStyleSVG
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleSVG
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleSVG
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleSVG
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleSVG
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleSVG
&
aNewData
)
const
;
nsStyleSVGPaint
mFill
;
nsStyleSVGPaint
mStroke
;
RefPtr
<
mozilla
:
:
css
:
:
URLValue
>
mMarkerEnd
;
RefPtr
<
mozilla
:
:
css
:
:
URLValue
>
mMarkerMid
;
RefPtr
<
mozilla
:
:
css
:
:
URLValue
>
mMarkerStart
;
nsTArray
<
nsStyleCoord
>
mStrokeDasharray
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mContextProps
;
nsStyleCoord
mStrokeDashoffset
;
nsStyleCoord
mStrokeWidth
;
float
mFillOpacity
;
float
mStrokeMiterlimit
;
float
mStrokeOpacity
;
mozilla
:
:
StyleFillRule
mClipRule
;
uint8_t
mColorInterpolation
;
uint8_t
mColorInterpolationFilters
;
mozilla
:
:
StyleFillRule
mFillRule
;
uint8_t
mPaintOrder
;
uint8_t
mShapeRendering
;
uint8_t
mStrokeLinecap
;
uint8_t
mStrokeLinejoin
;
uint8_t
mTextAnchor
;
uint8_t
mContextPropsBits
;
bool
ExposesContextProperties
(
)
const
{
return
bool
(
mContextPropsBits
)
;
}
nsStyleSVGOpacitySource
FillOpacitySource
(
)
const
{
uint8_t
value
=
(
mContextFlags
&
FILL_OPACITY_SOURCE_MASK
)
>
>
FILL_OPACITY_SOURCE_SHIFT
;
return
nsStyleSVGOpacitySource
(
value
)
;
}
nsStyleSVGOpacitySource
StrokeOpacitySource
(
)
const
{
uint8_t
value
=
(
mContextFlags
&
STROKE_OPACITY_SOURCE_MASK
)
>
>
STROKE_OPACITY_SOURCE_SHIFT
;
return
nsStyleSVGOpacitySource
(
value
)
;
}
bool
StrokeDasharrayFromObject
(
)
const
{
return
mContextFlags
&
STROKE_DASHARRAY_CONTEXT
;
}
bool
StrokeDashoffsetFromObject
(
)
const
{
return
mContextFlags
&
STROKE_DASHOFFSET_CONTEXT
;
}
bool
StrokeWidthFromObject
(
)
const
{
return
mContextFlags
&
STROKE_WIDTH_CONTEXT
;
}
void
SetFillOpacitySource
(
nsStyleSVGOpacitySource
aValue
)
{
mContextFlags
=
(
mContextFlags
&
~
FILL_OPACITY_SOURCE_MASK
)
|
(
aValue
<
<
FILL_OPACITY_SOURCE_SHIFT
)
;
}
void
SetStrokeOpacitySource
(
nsStyleSVGOpacitySource
aValue
)
{
mContextFlags
=
(
mContextFlags
&
~
STROKE_OPACITY_SOURCE_MASK
)
|
(
aValue
<
<
STROKE_OPACITY_SOURCE_SHIFT
)
;
}
void
SetStrokeDasharrayFromObject
(
bool
aValue
)
{
mContextFlags
=
(
mContextFlags
&
~
STROKE_DASHARRAY_CONTEXT
)
|
(
aValue
?
STROKE_DASHARRAY_CONTEXT
:
0
)
;
}
void
SetStrokeDashoffsetFromObject
(
bool
aValue
)
{
mContextFlags
=
(
mContextFlags
&
~
STROKE_DASHOFFSET_CONTEXT
)
|
(
aValue
?
STROKE_DASHOFFSET_CONTEXT
:
0
)
;
}
void
SetStrokeWidthFromObject
(
bool
aValue
)
{
mContextFlags
=
(
mContextFlags
&
~
STROKE_WIDTH_CONTEXT
)
|
(
aValue
?
STROKE_WIDTH_CONTEXT
:
0
)
;
}
bool
HasMarker
(
)
const
{
return
mMarkerStart
|
|
mMarkerMid
|
|
mMarkerEnd
;
}
bool
HasStroke
(
)
const
{
return
mStroke
.
Type
(
)
!
=
eStyleSVGPaintType_None
&
&
mStrokeOpacity
>
0
;
}
bool
HasFill
(
)
const
{
return
mFill
.
Type
(
)
!
=
eStyleSVGPaintType_None
&
&
mFillOpacity
>
0
;
}
private
:
static
const
uint8_t
FILL_OPACITY_SOURCE_MASK
=
0x03
;
static
const
uint8_t
STROKE_OPACITY_SOURCE_MASK
=
0x0C
;
static
const
uint8_t
STROKE_DASHARRAY_CONTEXT
=
0x10
;
static
const
uint8_t
STROKE_DASHOFFSET_CONTEXT
=
0x20
;
static
const
uint8_t
STROKE_WIDTH_CONTEXT
=
0x40
;
static
const
uint8_t
FILL_OPACITY_SOURCE_SHIFT
=
0
;
static
const
uint8_t
STROKE_OPACITY_SOURCE_SHIFT
=
2
;
uint8_t
mContextFlags
;
}
;
struct
nsStyleFilter
{
nsStyleFilter
(
)
;
nsStyleFilter
(
const
nsStyleFilter
&
aSource
)
;
~
nsStyleFilter
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
nsStyleFilter
&
operator
=
(
const
nsStyleFilter
&
aOther
)
;
bool
operator
=
=
(
const
nsStyleFilter
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleFilter
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
uint32_t
GetType
(
)
const
{
return
mType
;
}
const
nsStyleCoord
&
GetFilterParameter
(
)
const
{
NS_ASSERTION
(
mType
!
=
NS_STYLE_FILTER_DROP_SHADOW
&
&
mType
!
=
NS_STYLE_FILTER_URL
&
&
mType
!
=
NS_STYLE_FILTER_NONE
"
wrong
filter
type
"
)
;
return
mFilterParameter
;
}
void
SetFilterParameter
(
const
nsStyleCoord
&
aFilterParameter
int32_t
aType
)
;
mozilla
:
:
css
:
:
URLValue
*
GetURL
(
)
const
{
MOZ_ASSERT
(
mType
=
=
NS_STYLE_FILTER_URL
"
wrong
filter
type
"
)
;
return
mURL
;
}
bool
SetURL
(
mozilla
:
:
css
:
:
URLValue
*
aValue
)
;
nsCSSShadowArray
*
GetDropShadow
(
)
const
{
NS_ASSERTION
(
mType
=
=
NS_STYLE_FILTER_DROP_SHADOW
"
wrong
filter
type
"
)
;
return
mDropShadow
;
}
void
SetDropShadow
(
nsCSSShadowArray
*
aDropShadow
)
;
private
:
void
ReleaseRef
(
)
;
uint32_t
mType
;
nsStyleCoord
mFilterParameter
;
union
{
mozilla
:
:
css
:
:
URLValue
*
mURL
;
nsCSSShadowArray
*
mDropShadow
;
}
;
}
;
template
<
>
struct
nsTArray_CopyChooser
<
nsStyleFilter
>
{
typedef
nsTArray_CopyWithConstructors
<
nsStyleFilter
>
Type
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleSVGReset
{
explicit
nsStyleSVGReset
(
const
nsPresContext
*
aContext
)
;
nsStyleSVGReset
(
const
nsStyleSVGReset
&
aSource
)
;
~
nsStyleSVGReset
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
;
const
static
bool
kHasFinishStyle
=
true
;
void
*
operator
new
(
size_t
sz
nsStyleSVGReset
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleSVGReset
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
;
nsChangeHint
CalcDifference
(
const
nsStyleSVGReset
&
aNewData
)
const
;
bool
HasClipPath
(
)
const
{
return
mClipPath
.
GetType
(
)
!
=
mozilla
:
:
StyleShapeSourceType
:
:
None
;
}
bool
HasMask
(
)
const
;
bool
HasNonScalingStroke
(
)
const
{
return
mVectorEffect
=
=
NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE
;
}
nsStyleImageLayers
mMask
;
mozilla
:
:
StyleShapeSource
mClipPath
;
nscolor
mStopColor
;
nscolor
mFloodColor
;
nscolor
mLightingColor
;
float
mStopOpacity
;
float
mFloodOpacity
;
uint8_t
mDominantBaseline
;
uint8_t
mVectorEffect
;
uint8_t
mMaskType
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleVariables
{
nsStyleVariables
(
)
;
explicit
nsStyleVariables
(
const
nsPresContext
*
aContext
)
;
nsStyleVariables
(
const
nsStyleVariables
&
aSource
)
;
~
nsStyleVariables
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleVariables
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleVariables
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleVariables
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleVariables
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleVariables
&
aNewData
)
const
;
mozilla
:
:
CSSVariableValues
mVariables
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleEffects
{
explicit
nsStyleEffects
(
const
nsPresContext
*
aContext
)
;
nsStyleEffects
(
const
nsStyleEffects
&
aSource
)
;
~
nsStyleEffects
(
)
;
void
FinishStyle
(
nsPresContext
*
aPresContext
)
{
}
const
static
bool
kHasFinishStyle
=
false
;
void
*
operator
new
(
size_t
sz
nsStyleEffects
*
aSelf
)
{
return
aSelf
;
}
void
*
operator
new
(
size_t
sz
nsPresContext
*
aContext
)
{
return
aContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleEffects
sz
)
;
}
void
Destroy
(
nsPresContext
*
aContext
)
{
this
-
>
~
nsStyleEffects
(
)
;
aContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
mozilla
:
:
eArenaObjectID_nsStyleEffects
this
)
;
}
nsChangeHint
CalcDifference
(
const
nsStyleEffects
&
aNewData
)
const
;
bool
HasFilters
(
)
const
{
return
!
mFilters
.
IsEmpty
(
)
;
}
nsTArray
<
nsStyleFilter
>
mFilters
;
RefPtr
<
nsCSSShadowArray
>
mBoxShadow
;
nsRect
mClip
;
float
mOpacity
;
uint8_t
mClipFlags
;
uint8_t
mMixBlendMode
;
}
;
#
define
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
T1
T2
)
\
static_assert
(
sizeof
(
T1
)
=
=
sizeof
(
T2
)
\
"
Size
mismatch
between
"
#
T1
"
and
"
#
T2
)
;
\
static_assert
(
alignof
(
T1
)
=
=
alignof
(
T2
)
\
"
Align
mismatch
between
"
#
T1
"
and
"
#
T2
)
;
\
#
define
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
T1
T2
field
)
\
static_assert
(
offsetof
(
T1
field
)
=
=
offsetof
(
T2
field
)
\
"
Field
offset
mismatch
of
"
#
field
"
between
"
#
T1
"
and
"
#
T2
)
;
\
/
*
*
*
These
*
_Simple
types
are
used
to
map
Gecko
types
to
layout
-
equivalent
but
*
simpler
Rust
types
to
aid
Rust
binding
generation
.
*
*
If
something
in
this
types
or
the
assertions
below
needs
to
change
ask
*
bholley
heycam
or
emilio
before
!
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsPoint
"
>
*
/
struct
nsPoint_Simple
{
nscoord
x
y
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsPoint
nsPoint_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsPoint
nsPoint_Simple
x
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsPoint
nsPoint_Simple
y
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsMargin
"
>
*
/
struct
nsMargin_Simple
{
nscoord
top
right
bottom
left
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsMargin
nsMargin_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
top
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
right
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
bottom
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
left
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsRect
"
>
*
/
struct
nsRect_Simple
{
nscoord
x
y
width
height
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsRect
nsRect_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
x
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
y
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
width
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
height
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsSize
"
>
*
/
struct
nsSize_Simple
{
nscoord
width
height
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsSize
nsSize_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsSize
nsSize_Simple
width
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsSize
nsSize_Simple
height
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
mozilla
:
:
UniquePtr
"
>
*
*
TODO
(
Emilio
)
:
This
is
a
workaround
and
we
should
be
able
to
get
rid
of
this
*
one
.
*
/
template
<
typename
T
>
struct
UniquePtr_Simple
{
T
*
mPtr
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
mozilla
:
:
UniquePtr
<
int
>
UniquePtr_Simple
<
int
>
)
;
/
*
*
*
<
div
rustbindgen
replaces
=
"
nsTArray
"
>
<
/
div
>
*
/
template
<
typename
T
>
class
nsTArray_Simple
{
T
*
mBuffer
;
public
:
~
nsTArray_Simple
(
)
{
}
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsTArray
<
nsStyleImageLayers
:
:
Layer
>
nsTArray_Simple
<
nsStyleImageLayers
:
:
Layer
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsTArray
<
mozilla
:
:
StyleTransition
>
nsTArray_Simple
<
mozilla
:
:
StyleTransition
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsTArray
<
mozilla
:
:
StyleAnimation
>
nsTArray_Simple
<
mozilla
:
:
StyleAnimation
>
)
;
/
*
*
*
<
div
rustbindgen
replaces
=
"
nsCOMArray
"
>
<
/
div
>
*
*
mozilla
:
:
ArrayIterator
doesn
'
t
work
well
with
bindgen
.
*
/
template
<
typename
T
>
class
nsCOMArray_Simple
{
nsTArray
<
nsISupports
*
>
mBuffer
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsCOMArray
<
nsIContent
>
nsCOMArray_Simple
<
nsIContent
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsCOMArray
<
nsINode
>
nsCOMArray_Simple
<
nsINode
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsCOMArray
<
imgIContainer
>
nsCOMArray_Simple
<
imgIContainer
>
)
;
#
endif
