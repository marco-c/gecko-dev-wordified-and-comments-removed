#
ifndef
nsStyleStruct_h___
#
define
nsStyleStruct_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
SheetType
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StyleComplexColor
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsMargin
.
h
"
#
include
"
nsFont
.
h
"
#
include
"
nsStyleAutoArray
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsTimingFunction
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
Orientation
.
h
"
#
include
"
CounterStyleManager
.
h
"
#
include
<
cstddef
>
#
include
<
utility
>
#
include
"
X11UndefineNone
.
h
"
class
nsIFrame
;
class
nsIURI
;
class
nsTextFrame
;
class
imgIContainer
;
class
nsPresContext
;
struct
nsStyleDisplay
;
struct
nsStyleVisibility
;
namespace
mozilla
{
class
ComputedStyle
;
namespace
dom
{
class
ImageTracker
;
}
}
namespace
mozilla
{
using
Position
=
StylePosition
;
template
<
>
inline
bool
StylePosition
:
:
DependsOnPositioningAreaSize
(
)
const
{
return
horizontal
.
HasPercent
(
)
|
|
vertical
.
HasPercent
(
)
;
}
template
<
>
inline
Position
Position
:
:
FromPercentage
(
float
aPercent
)
{
return
{
LengthPercentage
:
:
FromPercentage
(
aPercent
)
LengthPercentage
:
:
FromPercentage
(
aPercent
)
}
;
}
}
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleFont
{
nsStyleFont
(
const
nsStyleFont
&
aStyleFont
)
;
explicit
nsStyleFont
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
~
nsStyleFont
(
)
{
MOZ_COUNT_DTOR
(
nsStyleFont
)
;
}
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleFont
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleFont
&
aNewData
)
const
;
static
nscoord
ZoomText
(
const
mozilla
:
:
dom
:
:
Document
&
nscoord
aSize
)
;
nsFont
mFont
;
nscoord
mSize
;
float
mFontSizeFactor
;
nscoord
mFontSizeOffset
;
uint8_t
mFontSizeKeyword
;
uint8_t
mGenericID
;
int8_t
mScriptLevel
;
uint8_t
mMathVariant
;
uint8_t
mMathDisplay
;
uint8_t
mMinFontSizeRatio
;
bool
mExplicitLanguage
;
bool
mAllowZoom
;
nscoord
mScriptUnconstrainedSize
;
nscoord
mScriptMinSize
;
float
mScriptSizeMultiplier
;
RefPtr
<
nsAtom
>
mLanguage
;
}
;
struct
nsStyleGradientStop
{
nsStyleCoord
mLocation
;
mozilla
:
:
StyleComplexColor
mColor
;
bool
mIsInterpolationHint
;
bool
operator
=
=
(
const
nsStyleGradientStop
&
)
const
=
delete
;
bool
operator
!
=
(
const
nsStyleGradientStop
&
)
const
=
delete
;
}
;
class
nsStyleGradient
final
{
public
:
nsStyleGradient
(
)
;
uint8_t
mShape
;
uint8_t
mSize
;
bool
mRepeating
;
bool
mLegacySyntax
;
bool
mMozLegacySyntax
;
nsStyleCoord
mBgPosX
;
nsStyleCoord
mBgPosY
;
nsStyleCoord
mAngle
;
nsStyleCoord
mRadiusX
;
nsStyleCoord
mRadiusY
;
nsTArray
<
nsStyleGradientStop
>
mStops
;
bool
operator
=
=
(
const
nsStyleGradient
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleGradient
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
bool
IsOpaque
(
)
;
bool
HasCalc
(
)
;
uint32_t
Hash
(
PLDHashNumber
aHash
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsStyleGradient
)
private
:
~
nsStyleGradient
(
)
{
}
nsStyleGradient
(
const
nsStyleGradient
&
aOther
)
=
delete
;
nsStyleGradient
&
operator
=
(
const
nsStyleGradient
&
aOther
)
=
delete
;
}
;
class
nsStyleImageRequest
{
public
:
enum
class
Mode
:
uint8_t
{
Track
=
0x1
Discard
=
0x2
}
;
nsStyleImageRequest
(
Mode
aModeFlags
mozilla
:
:
css
:
:
URLValue
*
aImageValue
)
;
bool
Resolve
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleImageRequest
*
aOldImageRequest
)
;
bool
IsResolved
(
)
const
{
return
mResolved
;
}
imgRequestProxy
*
get
(
)
{
MOZ_ASSERT
(
IsResolved
(
)
"
Resolve
(
)
must
be
called
first
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mRequestProxy
.
get
(
)
;
}
const
imgRequestProxy
*
get
(
)
const
{
return
const_cast
<
nsStyleImageRequest
*
>
(
this
)
-
>
get
(
)
;
}
bool
DefinitelyEquals
(
const
nsStyleImageRequest
&
aOther
)
const
;
mozilla
:
:
css
:
:
URLValue
*
GetImageValue
(
)
const
{
return
mImageValue
;
}
already_AddRefed
<
nsIURI
>
GetImageURI
(
)
const
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsStyleImageRequest
)
;
private
:
~
nsStyleImageRequest
(
)
;
nsStyleImageRequest
&
operator
=
(
const
nsStyleImageRequest
&
aOther
)
=
delete
;
void
MaybeTrackAndLock
(
)
;
RefPtr
<
imgRequestProxy
>
mRequestProxy
;
RefPtr
<
mozilla
:
:
css
:
:
URLValue
>
mImageValue
;
RefPtr
<
mozilla
:
:
dom
:
:
ImageTracker
>
mImageTracker
;
RefPtr
<
mozilla
:
:
dom
:
:
DocGroup
>
mDocGroup
;
Mode
mModeFlags
;
bool
mResolved
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
nsStyleImageRequest
:
:
Mode
)
enum
nsStyleImageType
{
eStyleImageType_Null
eStyleImageType_Image
eStyleImageType_Gradient
eStyleImageType_Element
eStyleImageType_URL
}
;
struct
CachedBorderImageData
{
~
CachedBorderImageData
(
)
{
PurgeCachedImages
(
)
;
}
void
SetCachedSVGViewportSize
(
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
)
;
const
mozilla
:
:
Maybe
<
nsSize
>
&
GetCachedSVGViewportSize
(
)
;
void
PurgeCachedImages
(
)
;
void
SetSubImage
(
uint8_t
aIndex
imgIContainer
*
aSubImage
)
;
imgIContainer
*
GetSubImage
(
uint8_t
aIndex
)
;
private
:
mozilla
:
:
Maybe
<
nsSize
>
mCachedSVGViewportSize
;
nsCOMArray
<
imgIContainer
>
mSubImages
;
}
;
struct
nsStyleImage
{
typedef
mozilla
:
:
css
:
:
URLValue
URLValue
;
nsStyleImage
(
)
;
~
nsStyleImage
(
)
;
nsStyleImage
(
const
nsStyleImage
&
aOther
)
;
nsStyleImage
&
operator
=
(
const
nsStyleImage
&
aOther
)
;
void
SetNull
(
)
;
void
SetImageRequest
(
already_AddRefed
<
nsStyleImageRequest
>
aImage
)
;
void
SetGradientData
(
nsStyleGradient
*
aGradient
)
;
void
SetElementId
(
already_AddRefed
<
nsAtom
>
aElementId
)
;
void
SetCropRect
(
mozilla
:
:
UniquePtr
<
nsStyleSides
>
aCropRect
)
;
void
SetURLValue
(
already_AddRefed
<
const
URLValue
>
aURLValue
)
;
void
ResolveImage
(
mozilla
:
:
dom
:
:
Document
&
aDocument
const
nsStyleImage
*
aOldImage
)
{
MOZ_ASSERT
(
mType
!
=
eStyleImageType_Image
|
|
mImage
)
;
if
(
mType
=
=
eStyleImageType_Image
&
&
!
mImage
-
>
IsResolved
(
)
)
{
const
nsStyleImageRequest
*
oldRequest
=
(
aOldImage
&
&
aOldImage
-
>
GetType
(
)
=
=
eStyleImageType_Image
)
?
aOldImage
-
>
ImageRequest
(
)
:
nullptr
;
mImage
-
>
Resolve
(
aDocument
oldRequest
)
;
}
}
nsStyleImageType
GetType
(
)
const
{
return
mType
;
}
nsStyleImageRequest
*
ImageRequest
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleImageType_Image
"
Data
is
not
an
image
!
"
)
;
MOZ_ASSERT
(
mImage
)
;
return
mImage
;
}
imgRequestProxy
*
GetImageData
(
)
const
{
return
ImageRequest
(
)
-
>
get
(
)
;
}
nsStyleGradient
*
GetGradientData
(
)
const
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Gradient
"
Data
is
not
a
gradient
!
"
)
;
return
mGradient
;
}
bool
IsResolved
(
)
const
{
return
mType
!
=
eStyleImageType_Image
|
|
ImageRequest
(
)
-
>
IsResolved
(
)
;
}
const
nsAtom
*
GetElementId
(
)
const
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Element
"
Data
is
not
an
element
!
"
)
;
return
mElementId
;
}
const
mozilla
:
:
UniquePtr
<
nsStyleSides
>
&
GetCropRect
(
)
const
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Image
"
Only
image
data
can
have
a
crop
rect
"
)
;
return
mCropRect
;
}
already_AddRefed
<
nsIURI
>
GetImageURI
(
)
const
;
const
URLValue
*
GetURLValue
(
)
const
;
bool
ComputeActualCropRect
(
nsIntRect
&
aActualCropRect
bool
*
aIsEntireImage
=
nullptr
)
const
;
bool
StartDecoding
(
)
const
;
bool
IsOpaque
(
)
const
;
bool
IsComplete
(
)
const
;
bool
IsLoaded
(
)
const
;
bool
IsEmpty
(
)
const
{
return
mType
=
=
eStyleImageType_Null
;
}
bool
operator
=
=
(
const
nsStyleImage
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleImage
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
bool
ImageDataEquals
(
const
nsStyleImage
&
aOther
)
const
{
return
GetType
(
)
=
=
eStyleImageType_Image
&
&
aOther
.
GetType
(
)
=
=
eStyleImageType_Image
&
&
GetImageData
(
)
=
=
aOther
.
GetImageData
(
)
;
}
inline
void
SetSubImage
(
uint8_t
aIndex
imgIContainer
*
aSubImage
)
const
;
inline
imgIContainer
*
GetSubImage
(
uint8_t
aIndex
)
const
;
void
PurgeCacheForViewportChange
(
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasIntrinsicRatio
)
const
;
private
:
void
DoCopy
(
const
nsStyleImage
&
aOther
)
;
void
EnsureCachedBIData
(
)
const
;
mozilla
:
:
UniquePtr
<
CachedBorderImageData
>
mCachedBIData
;
nsStyleImageType
mType
;
union
{
nsStyleImageRequest
*
mImage
;
nsStyleGradient
*
mGradient
;
const
URLValue
*
mURLValue
;
nsAtom
*
mElementId
;
}
;
mozilla
:
:
UniquePtr
<
nsStyleSides
>
mCropRect
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleColor
{
explicit
nsStyleColor
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleColor
(
const
nsStyleColor
&
aOther
)
;
~
nsStyleColor
(
)
{
MOZ_COUNT_DTOR
(
nsStyleColor
)
;
}
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleColor
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleColor
&
aNewData
)
const
;
nscolor
mColor
;
}
;
struct
nsStyleImageLayers
{
enum
{
shorthand
=
0
color
image
repeat
positionX
positionY
clip
origin
size
attachment
maskMode
composite
}
;
enum
class
LayerType
:
uint8_t
{
Background
=
0
Mask
}
;
explicit
nsStyleImageLayers
(
LayerType
aType
)
;
nsStyleImageLayers
(
const
nsStyleImageLayers
&
aSource
)
;
~
nsStyleImageLayers
(
)
{
MOZ_COUNT_DTOR
(
nsStyleImageLayers
)
;
}
static
bool
IsInitialPositionForLayerType
(
mozilla
:
:
Position
aPosition
LayerType
aType
)
;
struct
Repeat
{
mozilla
:
:
StyleImageLayerRepeat
mXRepeat
mYRepeat
;
Repeat
(
)
{
}
bool
IsInitialValue
(
)
const
{
return
mXRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
&
&
mYRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
;
}
bool
DependsOnPositioningAreaSize
(
)
const
{
return
mXRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Space
|
|
mYRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Space
;
}
void
SetInitialValues
(
)
{
mXRepeat
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
;
mYRepeat
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
;
}
bool
operator
=
=
(
const
Repeat
&
aOther
)
const
{
return
mXRepeat
=
=
aOther
.
mXRepeat
&
&
mYRepeat
=
=
aOther
.
mYRepeat
;
}
bool
operator
!
=
(
const
Repeat
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
Layer
{
typedef
mozilla
:
:
StyleGeometryBox
StyleGeometryBox
;
typedef
mozilla
:
:
StyleImageLayerAttachment
StyleImageLayerAttachment
;
typedef
mozilla
:
:
StyleBackgroundSize
StyleBackgroundSize
;
nsStyleImage
mImage
;
mozilla
:
:
Position
mPosition
;
StyleBackgroundSize
mSize
;
StyleGeometryBox
mClip
;
MOZ_INIT_OUTSIDE_CTOR
StyleGeometryBox
mOrigin
;
StyleImageLayerAttachment
mAttachment
;
uint8_t
mBlendMode
;
uint8_t
mComposite
;
mozilla
:
:
StyleMaskMode
mMaskMode
;
Repeat
mRepeat
;
Layer
(
)
;
~
Layer
(
)
;
void
Initialize
(
LayerType
aType
)
;
void
ResolveImage
(
mozilla
:
:
dom
:
:
Document
&
aDocument
const
Layer
*
aOldLayer
)
{
mImage
.
ResolveImage
(
aDocument
aOldLayer
?
&
aOldLayer
-
>
mImage
:
nullptr
)
;
}
bool
RenderingMightDependOnPositioningAreaSizeChange
(
)
const
;
nsChangeHint
CalcDifference
(
const
Layer
&
aNewLayer
)
const
;
bool
operator
=
=
(
const
Layer
&
aOther
)
const
;
bool
operator
!
=
(
const
Layer
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
uint32_t
mAttachmentCount
;
uint32_t
mClipCount
;
uint32_t
mOriginCount
;
uint32_t
mRepeatCount
;
uint32_t
mPositionXCount
;
uint32_t
mPositionYCount
;
uint32_t
mImageCount
;
uint32_t
mSizeCount
;
uint32_t
mMaskModeCount
;
uint32_t
mBlendModeCount
;
uint32_t
mCompositeCount
;
nsStyleAutoArray
<
Layer
>
mLayers
;
const
Layer
&
BottomLayer
(
)
const
{
return
mLayers
[
mImageCount
-
1
]
;
}
void
ResolveImages
(
mozilla
:
:
dom
:
:
Document
&
aDocument
const
nsStyleImageLayers
*
aOldLayers
)
{
for
(
uint32_t
i
=
0
;
i
<
mImageCount
;
+
+
i
)
{
const
Layer
*
oldLayer
=
(
aOldLayers
&
&
aOldLayers
-
>
mLayers
.
Length
(
)
>
i
)
?
&
aOldLayers
-
>
mLayers
[
i
]
:
nullptr
;
mLayers
[
i
]
.
ResolveImage
(
aDocument
oldLayer
)
;
}
}
void
FillAllLayers
(
uint32_t
aMaxItemCount
)
;
nsChangeHint
CalcDifference
(
const
nsStyleImageLayers
&
aNewLayers
nsStyleImageLayers
:
:
LayerType
aType
)
const
;
nsStyleImageLayers
&
operator
=
(
const
nsStyleImageLayers
&
aOther
)
;
nsStyleImageLayers
&
operator
=
(
nsStyleImageLayers
&
&
aOther
)
;
bool
operator
=
=
(
const
nsStyleImageLayers
&
aOther
)
const
;
static
const
nsCSSPropertyID
kBackgroundLayerTable
[
]
;
static
const
nsCSSPropertyID
kMaskLayerTable
[
]
;
#
define
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
var_
layers_
)
\
for
(
uint32_t
var_
=
(
layers_
)
.
mImageCount
;
var_
-
-
!
=
0
;
)
#
define
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT_WITH_RANGE
(
var_
layers_
\
start_
count_
)
\
NS_ASSERTION
(
\
(
int32_t
)
(
start_
)
>
=
0
&
&
(
uint32_t
)
(
start_
)
<
(
layers_
)
.
mImageCount
\
"
Invalid
layer
start
!
"
)
;
\
NS_ASSERTION
(
(
count_
)
>
0
&
&
(
count_
)
<
=
(
start_
)
+
1
\
"
Invalid
layer
range
!
"
)
;
\
for
(
uint32_t
var_
=
(
start_
)
+
1
;
\
var_
-
-
!
=
(
uint32_t
)
(
(
start_
)
+
1
-
(
count_
)
)
;
)
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleBackground
{
explicit
nsStyleBackground
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleBackground
(
const
nsStyleBackground
&
aOther
)
;
~
nsStyleBackground
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleBackground
*
)
;
const
static
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleBackground
&
aNewData
)
const
;
nscolor
BackgroundColor
(
const
nsIFrame
*
aFrame
)
const
;
nscolor
BackgroundColor
(
mozilla
:
:
ComputedStyle
*
aStyle
)
const
;
bool
IsTransparent
(
const
nsIFrame
*
aFrame
)
const
;
bool
IsTransparent
(
mozilla
:
:
ComputedStyle
*
aStyle
)
const
;
bool
HasFixedBackground
(
nsIFrame
*
aFrame
)
const
;
inline
bool
HasLocalBackground
(
)
const
;
const
nsStyleImageLayers
:
:
Layer
&
BottomLayer
(
)
const
{
return
mImage
.
BottomLayer
(
)
;
}
nsStyleImageLayers
mImage
;
mozilla
:
:
StyleComplexColor
mBackgroundColor
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleMargin
{
explicit
nsStyleMargin
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleMargin
(
const
nsStyleMargin
&
aMargin
)
;
~
nsStyleMargin
(
)
{
MOZ_COUNT_DTOR
(
nsStyleMargin
)
;
}
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleMargin
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleMargin
&
aNewData
)
const
;
bool
GetMargin
(
nsMargin
&
aMargin
)
const
{
bool
convertsToLength
=
mMargin
.
All
(
[
]
(
const
auto
&
aLength
)
{
return
aLength
.
ConvertsToLength
(
)
;
}
)
;
if
(
!
convertsToLength
)
{
return
false
;
}
NS_FOR_CSS_SIDES
(
side
)
{
aMargin
.
Side
(
side
)
=
mMargin
.
Get
(
side
)
.
AsLengthPercentage
(
)
.
ToLength
(
)
;
}
return
true
;
}
inline
bool
HasBlockAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
bool
HasInlineAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
;
mozilla
:
:
StyleRect
<
mozilla
:
:
LengthPercentageOrAuto
>
mMargin
;
mozilla
:
:
StyleRect
<
mozilla
:
:
StyleLength
>
mScrollMargin
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStylePadding
{
explicit
nsStylePadding
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStylePadding
(
const
nsStylePadding
&
aPadding
)
;
~
nsStylePadding
(
)
{
MOZ_COUNT_DTOR
(
nsStylePadding
)
;
}
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStylePadding
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStylePadding
&
aNewData
)
const
;
mozilla
:
:
StyleRect
<
mozilla
:
:
NonNegativeLengthPercentage
>
mPadding
;
mozilla
:
:
StyleRect
<
mozilla
:
:
NonNegativeLengthPercentageOrAuto
>
mScrollPadding
;
inline
bool
IsWidthDependent
(
)
const
{
return
!
mPadding
.
All
(
[
]
(
const
auto
&
aLength
)
{
return
aLength
.
ConvertsToLength
(
)
;
}
)
;
}
bool
GetPadding
(
nsMargin
&
aPadding
)
const
{
if
(
IsWidthDependent
(
)
)
{
return
false
;
}
NS_FOR_CSS_SIDES
(
side
)
{
aPadding
.
Side
(
side
)
=
std
:
:
max
(
mPadding
.
Get
(
side
)
.
ToLength
(
)
0
)
;
}
return
true
;
}
}
;
struct
nsCSSShadowItem
{
nscoord
mXOffset
;
nscoord
mYOffset
;
nscoord
mRadius
;
nscoord
mSpread
;
mozilla
:
:
StyleComplexColor
mColor
;
bool
mInset
;
nsCSSShadowItem
(
)
:
mXOffset
(
0
)
mYOffset
(
0
)
mRadius
(
0
)
mSpread
(
0
)
mColor
(
mozilla
:
:
StyleComplexColor
:
:
CurrentColor
(
)
)
mInset
(
false
)
{
MOZ_COUNT_CTOR
(
nsCSSShadowItem
)
;
}
~
nsCSSShadowItem
(
)
{
MOZ_COUNT_DTOR
(
nsCSSShadowItem
)
;
}
bool
operator
=
=
(
const
nsCSSShadowItem
&
aOther
)
const
{
return
(
mXOffset
=
=
aOther
.
mXOffset
&
&
mYOffset
=
=
aOther
.
mYOffset
&
&
mRadius
=
=
aOther
.
mRadius
&
&
mSpread
=
=
aOther
.
mSpread
&
&
mInset
=
=
aOther
.
mInset
&
&
mColor
=
=
aOther
.
mColor
)
;
}
bool
operator
!
=
(
const
nsCSSShadowItem
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
class
nsCSSShadowArray
final
{
public
:
void
*
operator
new
(
size_t
aBaseSize
uint32_t
aArrayLen
)
{
return
:
:
operator
new
(
aBaseSize
+
(
aArrayLen
-
1
)
*
sizeof
(
nsCSSShadowItem
)
)
;
}
void
operator
delete
(
void
*
aPtr
)
{
:
:
operator
delete
(
aPtr
)
;
}
explicit
nsCSSShadowArray
(
uint32_t
aArrayLen
)
:
mLength
(
aArrayLen
)
{
for
(
uint32_t
i
=
1
;
i
<
mLength
;
+
+
i
)
{
new
(
&
mArray
[
i
]
)
nsCSSShadowItem
(
)
;
}
}
private
:
~
nsCSSShadowArray
(
)
{
for
(
uint32_t
i
=
1
;
i
<
mLength
;
+
+
i
)
{
mArray
[
i
]
.
~
nsCSSShadowItem
(
)
;
}
}
public
:
uint32_t
Length
(
)
const
{
return
mLength
;
}
nsCSSShadowItem
*
ShadowAt
(
uint32_t
i
)
{
MOZ_ASSERT
(
i
<
mLength
"
Accessing
too
high
an
index
in
the
text
shadow
array
!
"
)
;
return
&
mArray
[
i
]
;
}
const
nsCSSShadowItem
*
ShadowAt
(
uint32_t
i
)
const
{
MOZ_ASSERT
(
i
<
mLength
"
Accessing
too
high
an
index
in
the
text
shadow
array
!
"
)
;
return
&
mArray
[
i
]
;
}
bool
HasShadowWithInset
(
bool
aInset
)
{
for
(
uint32_t
i
=
0
;
i
<
mLength
;
+
+
i
)
{
if
(
mArray
[
i
]
.
mInset
=
=
aInset
)
{
return
true
;
}
}
return
false
;
}
bool
operator
=
=
(
const
nsCSSShadowArray
&
aOther
)
const
{
if
(
mLength
!
=
aOther
.
Length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
mLength
;
+
+
i
)
{
if
(
ShadowAt
(
i
)
!
=
aOther
.
ShadowAt
(
i
)
)
{
return
false
;
}
}
return
true
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsCSSShadowArray
)
private
:
uint32_t
mLength
;
nsCSSShadowItem
mArray
[
1
]
;
}
;
#
define
NS_ROUND_BORDER_TO_PIXELS
(
l
tpp
)
\
(
(
l
)
=
=
0
)
?
0
:
std
:
:
max
(
(
tpp
)
(
l
)
/
(
tpp
)
*
(
tpp
)
)
static
bool
IsVisibleBorderStyle
(
mozilla
:
:
StyleBorderStyle
aStyle
)
{
return
(
aStyle
!
=
mozilla
:
:
StyleBorderStyle
:
:
None
&
&
aStyle
!
=
mozilla
:
:
StyleBorderStyle
:
:
Hidden
)
;
}
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleBorder
{
explicit
nsStyleBorder
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleBorder
(
const
nsStyleBorder
&
aBorder
)
;
~
nsStyleBorder
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleBorder
*
)
;
const
static
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleBorder
&
aNewData
)
const
;
bool
HasVisibleStyle
(
mozilla
:
:
Side
aSide
)
const
{
return
IsVisibleBorderStyle
(
mBorderStyle
[
aSide
]
)
;
}
void
SetBorderWidth
(
mozilla
:
:
Side
aSide
nscoord
aBorderWidth
)
{
nscoord
roundedWidth
=
NS_ROUND_BORDER_TO_PIXELS
(
aBorderWidth
mTwipsPerPixel
)
;
mBorder
.
Side
(
aSide
)
=
roundedWidth
;
if
(
HasVisibleStyle
(
aSide
)
)
{
mComputedBorder
.
Side
(
aSide
)
=
roundedWidth
;
}
}
const
nsMargin
&
GetComputedBorder
(
)
const
{
return
mComputedBorder
;
}
bool
HasBorder
(
)
const
{
return
mComputedBorder
!
=
nsMargin
(
0
0
0
0
)
|
|
!
mBorderImageSource
.
IsEmpty
(
)
;
}
nscoord
GetComputedBorderWidth
(
mozilla
:
:
Side
aSide
)
const
{
return
GetComputedBorder
(
)
.
Side
(
aSide
)
;
}
mozilla
:
:
StyleBorderStyle
GetBorderStyle
(
mozilla
:
:
Side
aSide
)
const
{
NS_ASSERTION
(
aSide
<
=
mozilla
:
:
eSideLeft
"
bad
side
"
)
;
return
mBorderStyle
[
aSide
]
;
}
void
SetBorderStyle
(
mozilla
:
:
Side
aSide
mozilla
:
:
StyleBorderStyle
aStyle
)
{
NS_ASSERTION
(
aSide
<
=
mozilla
:
:
eSideLeft
"
bad
side
"
)
;
mBorderStyle
[
aSide
]
=
aStyle
;
mComputedBorder
.
Side
(
aSide
)
=
(
HasVisibleStyle
(
aSide
)
?
mBorder
.
Side
(
aSide
)
:
0
)
;
}
inline
bool
IsBorderImageLoaded
(
)
const
{
return
mBorderImageSource
.
IsLoaded
(
)
;
}
nsMargin
GetImageOutset
(
)
const
;
imgIRequest
*
GetBorderImageRequest
(
)
const
{
if
(
mBorderImageSource
.
GetType
(
)
=
=
eStyleImageType_Image
)
{
return
mBorderImageSource
.
GetImageData
(
)
;
}
return
nullptr
;
}
public
:
nsStyleCorners
mBorderRadius
;
nsStyleImage
mBorderImageSource
;
nsStyleSides
mBorderImageWidth
;
mozilla
:
:
StyleNonNegativeLengthOrNumberRect
mBorderImageOutset
;
mozilla
:
:
StyleBorderImageSlice
mBorderImageSlice
;
mozilla
:
:
StyleBorderImageRepeat
mBorderImageRepeatH
;
mozilla
:
:
StyleBorderImageRepeat
mBorderImageRepeatV
;
mozilla
:
:
StyleFloatEdge
mFloatEdge
;
mozilla
:
:
StyleBoxDecorationBreak
mBoxDecorationBreak
;
protected
:
mozilla
:
:
StyleBorderStyle
mBorderStyle
[
4
]
;
public
:
mozilla
:
:
StyleComplexColor
mBorderTopColor
;
mozilla
:
:
StyleComplexColor
mBorderRightColor
;
mozilla
:
:
StyleComplexColor
mBorderBottomColor
;
mozilla
:
:
StyleComplexColor
mBorderLeftColor
;
mozilla
:
:
StyleComplexColor
&
BorderColorFor
(
mozilla
:
:
Side
aSide
)
{
switch
(
aSide
)
{
case
mozilla
:
:
eSideTop
:
return
mBorderTopColor
;
case
mozilla
:
:
eSideRight
:
return
mBorderRightColor
;
case
mozilla
:
:
eSideBottom
:
return
mBorderBottomColor
;
case
mozilla
:
:
eSideLeft
:
return
mBorderLeftColor
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
side
"
)
;
return
mBorderTopColor
;
}
const
mozilla
:
:
StyleComplexColor
&
BorderColorFor
(
mozilla
:
:
Side
aSide
)
const
{
switch
(
aSide
)
{
case
mozilla
:
:
eSideTop
:
return
mBorderTopColor
;
case
mozilla
:
:
eSideRight
:
return
mBorderRightColor
;
case
mozilla
:
:
eSideBottom
:
return
mBorderBottomColor
;
case
mozilla
:
:
eSideLeft
:
return
mBorderLeftColor
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
side
"
)
;
return
mBorderTopColor
;
}
static
mozilla
:
:
StyleComplexColor
nsStyleBorder
:
:
*
BorderColorFieldFor
(
mozilla
:
:
Side
aSide
)
{
switch
(
aSide
)
{
case
mozilla
:
:
eSideTop
:
return
&
nsStyleBorder
:
:
mBorderTopColor
;
case
mozilla
:
:
eSideRight
:
return
&
nsStyleBorder
:
:
mBorderRightColor
;
case
mozilla
:
:
eSideBottom
:
return
&
nsStyleBorder
:
:
mBorderBottomColor
;
case
mozilla
:
:
eSideLeft
:
return
&
nsStyleBorder
:
:
mBorderLeftColor
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
side
"
)
;
return
nullptr
;
}
protected
:
nsMargin
mComputedBorder
;
nsMargin
mBorder
;
private
:
nscoord
mTwipsPerPixel
;
nsStyleBorder
&
operator
=
(
const
nsStyleBorder
&
aOther
)
=
delete
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleOutline
{
explicit
nsStyleOutline
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleOutline
(
const
nsStyleOutline
&
aOutline
)
;
~
nsStyleOutline
(
)
{
MOZ_COUNT_DTOR
(
nsStyleOutline
)
;
}
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleOutline
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleOutline
&
aNewData
)
const
;
nsStyleCorners
mOutlineRadius
;
nscoord
mOutlineWidth
;
nscoord
mOutlineOffset
;
mozilla
:
:
StyleComplexColor
mOutlineColor
;
mozilla
:
:
StyleOutlineStyle
mOutlineStyle
;
nscoord
GetOutlineWidth
(
)
const
{
return
mActualOutlineWidth
;
}
bool
ShouldPaintOutline
(
)
const
{
if
(
mOutlineStyle
.
IsAuto
(
)
)
{
return
true
;
}
if
(
GetOutlineWidth
(
)
>
0
)
{
MOZ_ASSERT
(
mOutlineStyle
.
border_style
.
_0
!
=
mozilla
:
:
StyleBorderStyle
:
:
None
"
outline
-
style
:
none
implies
outline
-
width
of
zero
"
)
;
return
true
;
}
return
false
;
}
protected
:
nscoord
mActualOutlineWidth
;
nscoord
mTwipsPerPixel
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleList
{
explicit
nsStyleList
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleList
(
const
nsStyleList
&
aStyleList
)
;
~
nsStyleList
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleList
*
)
;
const
static
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleList
&
aNewData
const
nsStyleDisplay
&
aOldDisplay
)
const
;
imgRequestProxy
*
GetListStyleImage
(
)
const
{
return
mListStyleImage
?
mListStyleImage
-
>
get
(
)
:
nullptr
;
}
already_AddRefed
<
nsIURI
>
GetListStyleImageURI
(
)
const
;
uint8_t
mListStylePosition
;
RefPtr
<
nsStyleImageRequest
>
mListStyleImage
;
mozilla
:
:
CounterStylePtr
mCounterStyle
;
private
:
nsStyleList
&
operator
=
(
const
nsStyleList
&
aOther
)
=
delete
;
public
:
RefPtr
<
RawServoQuotes
>
mQuotes
;
nsRect
mImageRegion
;
}
;
struct
nsStyleGridLine
{
bool
mHasSpan
;
int32_t
mInteger
;
nsString
mLineName
;
static
const
int32_t
kMinLine
=
-
10000
;
static
const
int32_t
kMaxLine
=
10000
;
nsStyleGridLine
(
)
:
mHasSpan
(
false
)
mInteger
(
0
)
{
}
nsStyleGridLine
(
const
nsStyleGridLine
&
aOther
)
{
(
*
this
)
=
aOther
;
}
void
operator
=
(
const
nsStyleGridLine
&
aOther
)
{
mHasSpan
=
aOther
.
mHasSpan
;
mInteger
=
aOther
.
mInteger
;
mLineName
=
aOther
.
mLineName
;
}
bool
operator
!
=
(
const
nsStyleGridLine
&
aOther
)
const
{
return
mHasSpan
!
=
aOther
.
mHasSpan
|
|
mInteger
!
=
aOther
.
mInteger
|
|
mLineName
!
=
aOther
.
mLineName
;
}
bool
IsAuto
(
)
const
{
bool
haveInitialValues
=
mInteger
=
=
0
&
&
mLineName
.
IsEmpty
(
)
;
MOZ_ASSERT
(
!
(
haveInitialValues
&
&
mHasSpan
)
"
should
not
have
'
span
'
when
other
components
are
"
"
at
their
initial
values
"
)
;
return
haveInitialValues
;
}
}
;
struct
nsStyleGridTemplate
{
nsTArray
<
nsTArray
<
nsString
>
>
mLineNameLists
;
nsTArray
<
nsStyleCoord
>
mMinTrackSizingFunctions
;
nsTArray
<
nsStyleCoord
>
mMaxTrackSizingFunctions
;
nsTArray
<
nsString
>
mRepeatAutoLineNameListBefore
;
nsTArray
<
nsString
>
mRepeatAutoLineNameListAfter
;
int16_t
mRepeatAutoIndex
;
bool
mIsAutoFill
:
1
;
bool
mIsSubgrid
:
1
;
nsStyleGridTemplate
(
)
:
mRepeatAutoIndex
(
-
1
)
mIsAutoFill
(
false
)
mIsSubgrid
(
false
)
{
}
inline
bool
operator
=
=
(
const
nsStyleGridTemplate
&
aOther
)
const
{
return
mIsSubgrid
=
=
aOther
.
mIsSubgrid
&
&
mLineNameLists
=
=
aOther
.
mLineNameLists
&
&
mMinTrackSizingFunctions
=
=
aOther
.
mMinTrackSizingFunctions
&
&
mMaxTrackSizingFunctions
=
=
aOther
.
mMaxTrackSizingFunctions
&
&
mIsAutoFill
=
=
aOther
.
mIsAutoFill
&
&
mRepeatAutoIndex
=
=
aOther
.
mRepeatAutoIndex
&
&
mRepeatAutoLineNameListBefore
=
=
aOther
.
mRepeatAutoLineNameListBefore
&
&
mRepeatAutoLineNameListAfter
=
=
aOther
.
mRepeatAutoLineNameListAfter
;
}
bool
HasRepeatAuto
(
)
const
{
return
mRepeatAutoIndex
!
=
-
1
;
}
bool
IsRepeatAutoIndex
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
uint32_t
(
2
*
nsStyleGridLine
:
:
kMaxLine
)
)
;
return
int32_t
(
aIndex
)
=
=
mRepeatAutoIndex
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStylePosition
{
using
LengthPercentageOrAuto
=
mozilla
:
:
LengthPercentageOrAuto
;
using
Position
=
mozilla
:
:
Position
;
template
<
typename
T
>
using
StyleRect
=
mozilla
:
:
StyleRect
<
T
>
;
using
StyleSize
=
mozilla
:
:
StyleSize
;
using
StyleMaxSize
=
mozilla
:
:
StyleMaxSize
;
using
StyleFlexBasis
=
mozilla
:
:
StyleFlexBasis
;
using
WritingMode
=
mozilla
:
:
WritingMode
;
explicit
nsStylePosition
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStylePosition
(
const
nsStylePosition
&
aOther
)
;
~
nsStylePosition
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStylePosition
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStylePosition
&
aNewData
const
nsStyleVisibility
&
aOldStyleVisibility
)
const
;
uint8_t
UsedAlignSelf
(
mozilla
:
:
ComputedStyle
*
aParent
)
const
;
uint8_t
UsedJustifySelf
(
mozilla
:
:
ComputedStyle
*
aParent
)
const
;
Position
mObjectPosition
;
StyleRect
<
LengthPercentageOrAuto
>
mOffset
;
StyleSize
mWidth
;
StyleSize
mMinWidth
;
StyleMaxSize
mMaxWidth
;
StyleSize
mHeight
;
StyleSize
mMinHeight
;
StyleMaxSize
mMaxHeight
;
StyleFlexBasis
mFlexBasis
;
nsStyleCoord
mGridAutoColumnsMin
;
nsStyleCoord
mGridAutoColumnsMax
;
nsStyleCoord
mGridAutoRowsMin
;
nsStyleCoord
mGridAutoRowsMax
;
uint8_t
mGridAutoFlow
;
mozilla
:
:
StyleBoxSizing
mBoxSizing
;
uint16_t
mAlignContent
;
uint8_t
mAlignItems
;
uint8_t
mAlignSelf
;
uint16_t
mJustifyContent
;
uint8_t
mSpecifiedJustifyItems
;
uint8_t
mJustifyItems
;
uint8_t
mJustifySelf
;
mozilla
:
:
StyleFlexDirection
mFlexDirection
;
uint8_t
mFlexWrap
;
uint8_t
mObjectFit
;
int32_t
mOrder
;
float
mFlexGrow
;
float
mFlexShrink
;
mozilla
:
:
StyleZIndex
mZIndex
;
mozilla
:
:
UniquePtr
<
nsStyleGridTemplate
>
mGridTemplateColumns
;
mozilla
:
:
UniquePtr
<
nsStyleGridTemplate
>
mGridTemplateRows
;
RefPtr
<
mozilla
:
:
css
:
:
GridTemplateAreasValue
>
mGridTemplateAreas
;
nsStyleGridLine
mGridColumnStart
;
nsStyleGridLine
mGridColumnEnd
;
nsStyleGridLine
mGridRowStart
;
nsStyleGridLine
mGridRowEnd
;
nsStyleCoord
mColumnGap
;
nsStyleCoord
mRowGap
;
bool
OffsetHasPercent
(
mozilla
:
:
Side
aSide
)
const
{
return
mOffset
.
Get
(
aSide
)
.
HasPercent
(
)
;
}
inline
const
StyleSize
&
ISize
(
WritingMode
)
const
;
inline
const
StyleSize
&
MinISize
(
WritingMode
)
const
;
inline
const
StyleMaxSize
&
MaxISize
(
WritingMode
)
const
;
inline
const
StyleSize
&
BSize
(
WritingMode
)
const
;
inline
const
StyleSize
&
MinBSize
(
WritingMode
)
const
;
inline
const
StyleMaxSize
&
MaxBSize
(
WritingMode
)
const
;
inline
bool
ISizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
MinISizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
MaxISizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
BSizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
MinBSizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
MaxBSizeDependsOnContainer
(
WritingMode
)
const
;
const
nsStyleGridTemplate
&
GridTemplateColumns
(
)
const
;
const
nsStyleGridTemplate
&
GridTemplateRows
(
)
const
;
private
:
template
<
typename
SizeOrMaxSize
>
static
bool
ISizeCoordDependsOnContainer
(
const
SizeOrMaxSize
&
aCoord
)
{
if
(
aCoord
.
IsLengthPercentage
(
)
)
{
return
aCoord
.
AsLengthPercentage
(
)
.
HasPercent
(
)
;
}
if
(
!
aCoord
.
IsExtremumLength
(
)
)
{
return
false
;
}
auto
keyword
=
aCoord
.
AsExtremumLength
(
)
;
return
keyword
=
=
mozilla
:
:
StyleExtremumLength
:
:
MozFitContent
|
|
keyword
=
=
mozilla
:
:
StyleExtremumLength
:
:
MozAvailable
;
}
template
<
typename
SizeOrMaxSize
>
static
bool
BSizeCoordDependsOnContainer
(
const
SizeOrMaxSize
&
aCoord
)
{
return
aCoord
.
IsLengthPercentage
(
)
&
&
aCoord
.
AsLengthPercentage
(
)
.
HasPercent
(
)
;
}
}
;
struct
nsStyleTextOverflowSide
{
nsStyleTextOverflowSide
(
)
:
mType
(
NS_STYLE_TEXT_OVERFLOW_CLIP
)
{
}
bool
operator
=
=
(
const
nsStyleTextOverflowSide
&
aOther
)
const
{
return
mType
=
=
aOther
.
mType
&
&
(
mType
!
=
NS_STYLE_TEXT_OVERFLOW_STRING
|
|
mString
=
=
aOther
.
mString
)
;
}
bool
operator
!
=
(
const
nsStyleTextOverflowSide
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsString
mString
;
uint8_t
mType
;
}
;
struct
nsStyleTextOverflow
{
nsStyleTextOverflow
(
)
:
mLogicalDirections
(
true
)
{
}
bool
operator
=
=
(
const
nsStyleTextOverflow
&
aOther
)
const
{
return
mLeft
=
=
aOther
.
mLeft
&
&
mRight
=
=
aOther
.
mRight
;
}
bool
operator
!
=
(
const
nsStyleTextOverflow
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
const
nsStyleTextOverflowSide
&
GetLeft
(
uint8_t
aDirection
)
const
{
NS_ASSERTION
(
aDirection
=
=
NS_STYLE_DIRECTION_LTR
|
|
aDirection
=
=
NS_STYLE_DIRECTION_RTL
"
bad
direction
"
)
;
return
!
mLogicalDirections
|
|
aDirection
=
=
NS_STYLE_DIRECTION_LTR
?
mLeft
:
mRight
;
}
const
nsStyleTextOverflowSide
&
GetRight
(
uint8_t
aDirection
)
const
{
NS_ASSERTION
(
aDirection
=
=
NS_STYLE_DIRECTION_LTR
|
|
aDirection
=
=
NS_STYLE_DIRECTION_RTL
"
bad
direction
"
)
;
return
!
mLogicalDirections
|
|
aDirection
=
=
NS_STYLE_DIRECTION_LTR
?
mRight
:
mLeft
;
}
const
nsStyleTextOverflowSide
*
GetFirstValue
(
)
const
{
return
mLogicalDirections
?
&
mRight
:
&
mLeft
;
}
const
nsStyleTextOverflowSide
*
GetSecondValue
(
)
const
{
return
mLogicalDirections
?
nullptr
:
&
mRight
;
}
nsStyleTextOverflowSide
mLeft
;
nsStyleTextOverflowSide
mRight
;
bool
mLogicalDirections
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleTextReset
{
explicit
nsStyleTextReset
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleTextReset
(
const
nsStyleTextReset
&
aOther
)
;
~
nsStyleTextReset
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleTextReset
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
bool
HasTextDecorationLines
(
)
const
{
return
mTextDecorationLine
!
=
NS_STYLE_TEXT_DECORATION_LINE_NONE
&
&
mTextDecorationLine
!
=
NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL
;
}
nsChangeHint
CalcDifference
(
const
nsStyleTextReset
&
aNewData
)
const
;
nsStyleTextOverflow
mTextOverflow
;
uint8_t
mTextDecorationLine
;
uint8_t
mTextDecorationStyle
;
uint8_t
mUnicodeBidi
;
nscoord
mInitialLetterSink
;
float
mInitialLetterSize
;
mozilla
:
:
StyleComplexColor
mTextDecorationColor
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleText
{
explicit
nsStyleText
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleText
(
const
nsStyleText
&
aOther
)
;
~
nsStyleText
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleText
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleText
&
aNewData
)
const
;
uint8_t
mTextAlign
;
uint8_t
mTextAlignLast
;
mozilla
:
:
StyleTextJustify
mTextJustify
;
uint8_t
mTextTransform
;
mozilla
:
:
StyleWhiteSpace
mWhiteSpace
;
uint8_t
mWordBreak
;
mozilla
:
:
StyleOverflowWrap
mOverflowWrap
;
mozilla
:
:
StyleHyphens
mHyphens
;
uint8_t
mRubyAlign
;
uint8_t
mRubyPosition
;
uint8_t
mTextSizeAdjust
;
uint8_t
mTextCombineUpright
;
uint8_t
mControlCharacterVisibility
;
uint8_t
mTextEmphasisPosition
;
uint8_t
mTextEmphasisStyle
;
mozilla
:
:
StyleTextRendering
mTextRendering
;
mozilla
:
:
StyleComplexColor
mTextEmphasisColor
;
mozilla
:
:
StyleComplexColor
mWebkitTextFillColor
;
mozilla
:
:
StyleComplexColor
mWebkitTextStrokeColor
;
mozilla
:
:
StyleNonNegativeLengthOrNumber
mMozTabSize
;
nsStyleCoord
mWordSpacing
;
nsStyleCoord
mLetterSpacing
;
nsStyleCoord
mLineHeight
;
mozilla
:
:
LengthPercentage
mTextIndent
;
nscoord
mWebkitTextStrokeWidth
;
RefPtr
<
nsCSSShadowArray
>
mTextShadow
;
nsString
mTextEmphasisStyleString
;
bool
WhiteSpaceIsSignificant
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreSpace
;
}
bool
NewlineIsSignificantStyle
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
;
}
bool
WhiteSpaceOrNewlineIsSignificant
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreSpace
;
}
bool
TabIsSignificant
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
;
}
bool
WhiteSpaceCanWrapStyle
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Normal
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
;
}
bool
WordCanWrapStyle
(
)
const
{
if
(
!
WhiteSpaceCanWrapStyle
(
)
)
{
return
false
;
}
return
mOverflowWrap
=
=
mozilla
:
:
StyleOverflowWrap
:
:
BreakWord
|
|
mOverflowWrap
=
=
mozilla
:
:
StyleOverflowWrap
:
:
Anywhere
;
}
bool
HasTextEmphasis
(
)
const
{
return
!
mTextEmphasisStyleString
.
IsEmpty
(
)
;
}
bool
HasWebkitTextStroke
(
)
const
{
return
mWebkitTextStrokeWidth
>
0
;
}
inline
bool
HasTextShadow
(
)
const
;
inline
nsCSSShadowArray
*
GetTextShadow
(
)
const
;
inline
bool
NewlineIsSignificant
(
const
nsTextFrame
*
aContextFrame
)
const
;
inline
bool
WhiteSpaceCanWrap
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
WordCanWrap
(
const
nsIFrame
*
aContextFrame
)
const
;
mozilla
:
:
LogicalSide
TextEmphasisSide
(
mozilla
:
:
WritingMode
aWM
)
const
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleVisibility
{
explicit
nsStyleVisibility
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleVisibility
(
const
nsStyleVisibility
&
aVisibility
)
;
~
nsStyleVisibility
(
)
{
MOZ_COUNT_DTOR
(
nsStyleVisibility
)
;
}
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleVisibility
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleVisibility
&
aNewData
)
const
;
mozilla
:
:
StyleImageOrientation
mImageOrientation
;
uint8_t
mDirection
;
uint8_t
mVisible
;
uint8_t
mImageRendering
;
uint8_t
mWritingMode
;
uint8_t
mTextOrientation
;
mozilla
:
:
StyleColorAdjust
mColorAdjust
;
bool
IsVisible
(
)
const
{
return
(
mVisible
=
=
NS_STYLE_VISIBILITY_VISIBLE
)
;
}
bool
IsVisibleOrCollapsed
(
)
const
{
return
(
(
mVisible
=
=
NS_STYLE_VISIBILITY_VISIBLE
)
|
|
(
mVisible
=
=
NS_STYLE_VISIBILITY_COLLAPSE
)
)
;
}
}
;
namespace
mozilla
{
struct
StyleTransition
{
StyleTransition
(
)
{
}
explicit
StyleTransition
(
const
StyleTransition
&
aCopy
)
;
void
SetInitialValues
(
)
;
const
nsTimingFunction
&
GetTimingFunction
(
)
const
{
return
mTimingFunction
;
}
float
GetDelay
(
)
const
{
return
mDelay
;
}
float
GetDuration
(
)
const
{
return
mDuration
;
}
nsCSSPropertyID
GetProperty
(
)
const
{
return
mProperty
;
}
nsAtom
*
GetUnknownProperty
(
)
const
{
return
mUnknownProperty
;
}
bool
operator
=
=
(
const
StyleTransition
&
aOther
)
const
;
bool
operator
!
=
(
const
StyleTransition
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTimingFunction
mTimingFunction
;
float
mDuration
;
float
mDelay
;
nsCSSPropertyID
mProperty
;
RefPtr
<
nsAtom
>
mUnknownProperty
;
}
;
struct
StyleAnimation
{
StyleAnimation
(
)
{
}
explicit
StyleAnimation
(
const
StyleAnimation
&
aCopy
)
;
void
SetInitialValues
(
)
;
const
nsTimingFunction
&
GetTimingFunction
(
)
const
{
return
mTimingFunction
;
}
float
GetDelay
(
)
const
{
return
mDelay
;
}
float
GetDuration
(
)
const
{
return
mDuration
;
}
nsAtom
*
GetName
(
)
const
{
return
mName
;
}
dom
:
:
PlaybackDirection
GetDirection
(
)
const
{
return
mDirection
;
}
dom
:
:
FillMode
GetFillMode
(
)
const
{
return
mFillMode
;
}
StyleAnimationPlayState
GetPlayState
(
)
const
{
return
mPlayState
;
}
float
GetIterationCount
(
)
const
{
return
mIterationCount
;
}
void
SetName
(
already_AddRefed
<
nsAtom
>
aName
)
{
mName
=
aName
;
}
void
SetName
(
nsAtom
*
aName
)
{
mName
=
aName
;
}
bool
operator
=
=
(
const
StyleAnimation
&
aOther
)
const
;
bool
operator
!
=
(
const
StyleAnimation
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTimingFunction
mTimingFunction
;
float
mDuration
;
float
mDelay
;
RefPtr
<
nsAtom
>
mName
;
dom
:
:
PlaybackDirection
mDirection
;
dom
:
:
FillMode
mFillMode
;
StyleAnimationPlayState
mPlayState
;
float
mIterationCount
;
}
;
class
StyleBasicShape
final
{
public
:
explicit
StyleBasicShape
(
StyleBasicShapeType
type
)
:
mType
(
type
)
mFillRule
(
StyleFillRule
:
:
Nonzero
)
mPosition
(
Position
:
:
FromPercentage
(
0
.
5f
)
)
{
}
StyleBasicShapeType
GetShapeType
(
)
const
{
return
mType
;
}
nsCSSKeyword
GetShapeTypeName
(
)
const
;
StyleFillRule
GetFillRule
(
)
const
{
return
mFillRule
;
}
const
mozilla
:
:
Position
&
GetPosition
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleBasicShapeType
:
:
Circle
|
|
mType
=
=
StyleBasicShapeType
:
:
Ellipse
"
expected
circle
or
ellipse
"
)
;
return
mPosition
;
}
bool
HasRadius
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleBasicShapeType
:
:
Inset
"
expected
inset
"
)
;
nsStyleCoord
zero
;
zero
.
SetCoordValue
(
0
)
;
NS_FOR_CSS_HALF_CORNERS
(
corner
)
{
if
(
mRadius
.
Get
(
corner
)
!
=
zero
)
{
return
true
;
}
}
return
false
;
}
const
nsStyleCorners
&
GetRadius
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleBasicShapeType
:
:
Inset
"
expected
inset
"
)
;
return
mRadius
;
}
const
nsTArray
<
nsStyleCoord
>
&
Coordinates
(
)
const
{
return
mCoordinates
;
}
bool
operator
=
=
(
const
StyleBasicShape
&
aOther
)
const
{
return
mType
=
=
aOther
.
mType
&
&
mFillRule
=
=
aOther
.
mFillRule
&
&
mCoordinates
=
=
aOther
.
mCoordinates
&
&
mPosition
=
=
aOther
.
mPosition
&
&
mRadius
=
=
aOther
.
mRadius
;
}
bool
operator
!
=
(
const
StyleBasicShape
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
StyleBasicShapeType
mType
;
StyleFillRule
mFillRule
;
nsTArray
<
nsStyleCoord
>
mCoordinates
;
mozilla
:
:
Position
mPosition
;
nsStyleCorners
mRadius
;
}
;
struct
StyleSVGPath
final
{
const
nsTArray
<
StylePathCommand
>
&
Path
(
)
const
{
return
mPath
;
}
StyleFillRule
FillRule
(
)
const
{
return
mFillRule
;
}
bool
operator
=
=
(
const
StyleSVGPath
&
aOther
)
const
{
return
mPath
=
=
aOther
.
mPath
&
&
mFillRule
=
=
aOther
.
mFillRule
;
}
bool
operator
!
=
(
const
StyleSVGPath
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTArray
<
StylePathCommand
>
mPath
;
StyleFillRule
mFillRule
=
StyleFillRule
:
:
Nonzero
;
}
;
struct
StyleShapeSource
final
{
StyleShapeSource
(
)
;
StyleShapeSource
(
const
StyleShapeSource
&
aSource
)
;
~
StyleShapeSource
(
)
;
StyleShapeSource
&
operator
=
(
const
StyleShapeSource
&
aOther
)
;
bool
operator
=
=
(
const
StyleShapeSource
&
aOther
)
const
;
bool
operator
!
=
(
const
StyleShapeSource
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
StyleShapeSourceType
GetType
(
)
const
{
return
mType
;
}
const
css
:
:
URLValue
&
URL
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
URL
"
Wrong
shape
source
type
!
"
)
;
MOZ_ASSERT
(
mShapeImage
&
&
mShapeImage
-
>
GetURLValue
(
)
)
;
return
*
mShapeImage
-
>
GetURLValue
(
)
;
}
void
SetURL
(
const
css
:
:
URLValue
&
aURLValue
)
;
const
nsStyleImage
&
ShapeImage
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Image
"
Wrong
shape
source
type
!
"
)
;
MOZ_ASSERT
(
mShapeImage
)
;
return
*
mShapeImage
;
}
imgIRequest
*
GetShapeImageData
(
)
const
;
void
SetShapeImage
(
UniquePtr
<
nsStyleImage
>
aShapeImage
)
;
const
StyleBasicShape
&
BasicShape
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Shape
"
Wrong
shape
source
type
!
"
)
;
MOZ_ASSERT
(
mBasicShape
)
;
return
*
mBasicShape
;
}
void
SetBasicShape
(
UniquePtr
<
StyleBasicShape
>
aBasicShape
StyleGeometryBox
aReferenceBox
)
;
StyleGeometryBox
GetReferenceBox
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Box
|
|
mType
=
=
StyleShapeSourceType
:
:
Shape
"
Wrong
shape
source
type
!
"
)
;
return
mReferenceBox
;
}
void
SetReferenceBox
(
StyleGeometryBox
aReferenceBox
)
;
const
StyleSVGPath
&
Path
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Path
"
Wrong
shape
source
type
!
"
)
;
MOZ_ASSERT
(
mSVGPath
)
;
return
*
mSVGPath
;
}
void
SetPath
(
UniquePtr
<
StyleSVGPath
>
aPath
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
StyleShapeSource
*
aOldShapeSource
)
;
private
:
void
*
operator
new
(
size_t
)
=
delete
;
void
DoCopy
(
const
StyleShapeSource
&
aOther
)
;
void
DoDestroy
(
)
;
union
{
mozilla
:
:
UniquePtr
<
StyleBasicShape
>
mBasicShape
;
mozilla
:
:
UniquePtr
<
nsStyleImage
>
mShapeImage
;
mozilla
:
:
UniquePtr
<
StyleSVGPath
>
mSVGPath
;
}
;
StyleShapeSourceType
mType
=
StyleShapeSourceType
:
:
None
;
StyleGeometryBox
mReferenceBox
=
StyleGeometryBox
:
:
NoBox
;
}
;
struct
StyleMotion
final
{
bool
operator
=
=
(
const
StyleMotion
&
aOther
)
const
{
return
mOffsetPath
=
=
aOther
.
mOffsetPath
;
}
bool
operator
!
=
(
const
StyleMotion
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
const
StyleShapeSource
&
OffsetPath
(
)
const
{
return
mOffsetPath
;
}
bool
HasPath
(
)
const
{
return
mOffsetPath
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
Path
;
}
private
:
StyleShapeSource
mOffsetPath
;
}
;
}
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleDisplay
{
typedef
mozilla
:
:
StyleGeometryBox
StyleGeometryBox
;
explicit
nsStyleDisplay
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleDisplay
(
const
nsStyleDisplay
&
aOther
)
;
~
nsStyleDisplay
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleDisplay
*
)
;
const
static
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleDisplay
&
aNewData
)
const
;
bool
TransformChanged
(
const
nsStyleDisplay
&
aNewData
)
const
;
RefPtr
<
mozilla
:
:
css
:
:
URLValue
>
mBinding
;
mozilla
:
:
StyleDisplay
mDisplay
;
mozilla
:
:
StyleDisplay
mOriginalDisplay
;
uint8_t
mContain
;
mozilla
:
:
StyleAppearance
mAppearance
;
uint8_t
mPosition
;
mozilla
:
:
StyleFloat
mFloat
;
mozilla
:
:
StyleFloat
mOriginalFloat
;
mozilla
:
:
StyleClear
mBreakType
;
mozilla
:
:
StyleBreakWithin
mBreakInside
;
mozilla
:
:
StyleBreakBetween
mBreakBefore
;
mozilla
:
:
StyleBreakBetween
mBreakAfter
;
mozilla
:
:
StyleOverflow
mOverflowX
;
mozilla
:
:
StyleOverflow
mOverflowY
;
mozilla
:
:
StyleOverflowClipBox
mOverflowClipBoxBlock
;
mozilla
:
:
StyleOverflowClipBox
mOverflowClipBoxInline
;
mozilla
:
:
StyleResize
mResize
;
mozilla
:
:
StyleOrient
mOrient
;
uint8_t
mIsolation
;
uint8_t
mTopLayer
;
uint8_t
mWillChangeBitField
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mWillChange
;
uint8_t
mTouchAction
;
uint8_t
mScrollBehavior
;
mozilla
:
:
StyleOverscrollBehavior
mOverscrollBehaviorX
;
mozilla
:
:
StyleOverscrollBehavior
mOverscrollBehaviorY
;
mozilla
:
:
StyleOverflowAnchor
mOverflowAnchor
;
mozilla
:
:
StyleScrollSnapAlign
mScrollSnapAlign
;
mozilla
:
:
StyleScrollSnapType
mScrollSnapTypeX
;
mozilla
:
:
StyleScrollSnapType
mScrollSnapTypeY
;
nsStyleCoord
mScrollSnapPointsX
;
nsStyleCoord
mScrollSnapPointsY
;
mozilla
:
:
Position
mScrollSnapDestination
;
nsTArray
<
mozilla
:
:
Position
>
mScrollSnapCoordinate
;
uint8_t
mBackfaceVisibility
;
uint8_t
mTransformStyle
;
StyleGeometryBox
mTransformBox
;
RefPtr
<
nsCSSValueSharedList
>
mSpecifiedTransform
;
RefPtr
<
nsCSSValueSharedList
>
mSpecifiedRotate
;
RefPtr
<
nsCSSValueSharedList
>
mSpecifiedTranslate
;
RefPtr
<
nsCSSValueSharedList
>
mSpecifiedScale
;
RefPtr
<
nsCSSValueSharedList
>
mIndividualTransform
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
StyleMotion
>
mMotion
;
mozilla
:
:
StyleTransformOrigin
mTransformOrigin
;
mozilla
:
:
StylePerspective
mChildPerspective
;
mozilla
:
:
Position
mPerspectiveOrigin
;
nsStyleCoord
mVerticalAlign
;
nsStyleAutoArray
<
mozilla
:
:
StyleTransition
>
mTransitions
;
uint32_t
mTransitionTimingFunctionCount
;
uint32_t
mTransitionDurationCount
;
uint32_t
mTransitionDelayCount
;
uint32_t
mTransitionPropertyCount
;
nsCSSPropertyID
GetTransitionProperty
(
uint32_t
aIndex
)
const
{
return
mTransitions
[
aIndex
%
mTransitionPropertyCount
]
.
GetProperty
(
)
;
}
float
GetTransitionDelay
(
uint32_t
aIndex
)
const
{
return
mTransitions
[
aIndex
%
mTransitionDelayCount
]
.
GetDelay
(
)
;
}
float
GetTransitionDuration
(
uint32_t
aIndex
)
const
{
return
mTransitions
[
aIndex
%
mTransitionDurationCount
]
.
GetDuration
(
)
;
}
const
nsTimingFunction
&
GetTransitionTimingFunction
(
uint32_t
aIndex
)
const
{
return
mTransitions
[
aIndex
%
mTransitionTimingFunctionCount
]
.
GetTimingFunction
(
)
;
}
float
GetTransitionCombinedDuration
(
uint32_t
aIndex
)
const
{
return
std
:
:
max
(
mTransitions
[
aIndex
%
mTransitionDurationCount
]
.
GetDuration
(
)
0
.
0f
)
+
mTransitions
[
aIndex
%
mTransitionDelayCount
]
.
GetDelay
(
)
;
}
nsStyleAutoArray
<
mozilla
:
:
StyleAnimation
>
mAnimations
;
uint32_t
mAnimationTimingFunctionCount
;
uint32_t
mAnimationDurationCount
;
uint32_t
mAnimationDelayCount
;
uint32_t
mAnimationNameCount
;
uint32_t
mAnimationDirectionCount
;
uint32_t
mAnimationFillModeCount
;
uint32_t
mAnimationPlayStateCount
;
uint32_t
mAnimationIterationCountCount
;
nsAtom
*
GetAnimationName
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationNameCount
]
.
GetName
(
)
;
}
float
GetAnimationDelay
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationDelayCount
]
.
GetDelay
(
)
;
}
float
GetAnimationDuration
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationDurationCount
]
.
GetDuration
(
)
;
}
mozilla
:
:
dom
:
:
PlaybackDirection
GetAnimationDirection
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationDirectionCount
]
.
GetDirection
(
)
;
}
mozilla
:
:
dom
:
:
FillMode
GetAnimationFillMode
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationFillModeCount
]
.
GetFillMode
(
)
;
}
mozilla
:
:
StyleAnimationPlayState
GetAnimationPlayState
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationPlayStateCount
]
.
GetPlayState
(
)
;
}
float
GetAnimationIterationCount
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationIterationCountCount
]
.
GetIterationCount
(
)
;
}
const
nsTimingFunction
&
GetAnimationTimingFunction
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationTimingFunctionCount
]
.
GetTimingFunction
(
)
;
}
float
mShapeImageThreshold
=
0
.
0f
;
mozilla
:
:
NonNegativeLengthPercentage
mShapeMargin
;
mozilla
:
:
StyleShapeSource
mShapeOutside
;
bool
HasAppearance
(
)
const
{
return
mAppearance
!
=
mozilla
:
:
StyleAppearance
:
:
None
;
}
bool
IsBlockInsideStyle
(
)
const
{
return
mozilla
:
:
StyleDisplay
:
:
Block
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
ListItem
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineBlock
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableCaption
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
FlowRoot
=
=
mDisplay
;
}
bool
IsBlockOutsideStyle
(
)
const
{
return
mozilla
:
:
StyleDisplay
:
:
Block
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Flex
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
WebkitBox
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Grid
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
ListItem
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Table
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
FlowRoot
=
=
mDisplay
;
}
static
bool
IsDisplayTypeInlineOutside
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
mozilla
:
:
StyleDisplay
:
:
Inline
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineBlock
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineTable
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
MozInlineBox
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineFlex
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
WebkitInlineBox
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
InlineGrid
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
MozInlineGrid
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
MozInlineStack
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Ruby
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBase
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyText
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
Contents
=
=
aDisplay
;
}
bool
IsInlineOutsideStyle
(
)
const
{
return
IsDisplayTypeInlineOutside
(
mDisplay
)
;
}
bool
IsOriginalDisplayInlineOutsideStyle
(
)
const
{
return
IsDisplayTypeInlineOutside
(
mOriginalDisplay
)
;
}
bool
IsInnerTableStyle
(
)
const
{
return
mozilla
:
:
StyleDisplay
:
:
TableCell
=
=
mDisplay
|
|
IsInternalTableStyleExceptCell
(
)
;
}
bool
IsInternalTableStyleExceptCell
(
)
const
{
return
mozilla
:
:
StyleDisplay
:
:
TableRow
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableRowGroup
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableHeaderGroup
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableFooterGroup
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableColumn
=
=
mDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
=
=
mDisplay
;
}
bool
IsFloatingStyle
(
)
const
{
return
mozilla
:
:
StyleFloat
:
:
None
!
=
mFloat
;
}
bool
IsAbsolutelyPositionedStyle
(
)
const
{
return
NS_STYLE_POSITION_ABSOLUTE
=
=
mPosition
|
|
NS_STYLE_POSITION_FIXED
=
=
mPosition
;
}
bool
IsRelativelyPositionedStyle
(
)
const
{
return
NS_STYLE_POSITION_RELATIVE
=
=
mPosition
|
|
NS_STYLE_POSITION_STICKY
=
=
mPosition
;
}
bool
IsStickyPositionedStyle
(
)
const
{
return
NS_STYLE_POSITION_STICKY
=
=
mPosition
;
}
bool
IsPositionForcingStackingContext
(
)
const
{
return
NS_STYLE_POSITION_STICKY
=
=
mPosition
|
|
NS_STYLE_POSITION_FIXED
=
=
mPosition
;
}
static
bool
IsRubyDisplayType
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
mozilla
:
:
StyleDisplay
:
:
Ruby
=
=
aDisplay
|
|
IsInternalRubyDisplayType
(
aDisplay
)
;
}
static
bool
IsInternalRubyDisplayType
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
mozilla
:
:
StyleDisplay
:
:
RubyBase
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyText
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
=
=
aDisplay
;
}
bool
IsRubyDisplayType
(
)
const
{
return
IsRubyDisplayType
(
mDisplay
)
;
}
bool
IsInternalRubyDisplayType
(
)
const
{
return
IsInternalRubyDisplayType
(
mDisplay
)
;
}
bool
IsOutOfFlowStyle
(
)
const
{
return
(
IsAbsolutelyPositionedStyle
(
)
|
|
IsFloatingStyle
(
)
)
;
}
bool
IsScrollableOverflow
(
)
const
{
return
mOverflowX
!
=
mozilla
:
:
StyleOverflow
:
:
Visible
&
&
mOverflowX
!
=
mozilla
:
:
StyleOverflow
:
:
MozHiddenUnscrollable
;
}
bool
IsContainPaint
(
)
const
{
return
(
NS_STYLE_CONTAIN_PAINT
&
mContain
)
&
&
!
IsInternalRubyDisplayType
(
)
&
&
!
IsInternalTableStyleExceptCell
(
)
;
}
bool
IsContainLayout
(
)
const
{
return
(
NS_STYLE_CONTAIN_LAYOUT
&
mContain
)
&
&
!
IsInternalRubyDisplayType
(
)
&
&
!
IsInternalTableStyleExceptCell
(
)
;
}
bool
IsContainSize
(
)
const
{
return
(
NS_STYLE_CONTAIN_SIZE
&
mContain
)
&
&
!
IsInternalRubyDisplayType
(
)
&
&
(
mozilla
:
:
StyleDisplay
:
:
Table
!
=
mDisplay
)
&
&
!
IsInnerTableStyle
(
)
;
}
bool
HasTransformStyle
(
)
const
{
return
mSpecifiedTransform
|
|
mSpecifiedRotate
|
|
mSpecifiedTranslate
|
|
mSpecifiedScale
|
|
mTransformStyle
=
=
NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D
|
|
(
mWillChangeBitField
&
NS_STYLE_WILL_CHANGE_TRANSFORM
)
|
|
(
mMotion
&
&
mMotion
-
>
HasPath
(
)
)
;
}
bool
HasIndividualTransform
(
)
const
{
return
mSpecifiedRotate
|
|
mSpecifiedTranslate
|
|
mSpecifiedScale
;
}
bool
HasPerspectiveStyle
(
)
const
{
return
!
mChildPerspective
.
IsNone
(
)
;
}
bool
BackfaceIsHidden
(
)
const
{
return
mBackfaceVisibility
=
=
NS_STYLE_BACKFACE_VISIBILITY_HIDDEN
;
}
static
bool
ShouldBreak
(
mozilla
:
:
StyleBreakBetween
aBreak
)
{
switch
(
aBreak
)
{
case
mozilla
:
:
StyleBreakBetween
:
:
Left
:
case
mozilla
:
:
StyleBreakBetween
:
:
Right
:
case
mozilla
:
:
StyleBreakBetween
:
:
Page
:
case
mozilla
:
:
StyleBreakBetween
:
:
Always
:
return
true
;
case
mozilla
:
:
StyleBreakBetween
:
:
Auto
:
case
mozilla
:
:
StyleBreakBetween
:
:
Avoid
:
return
false
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
break
kind
"
)
;
return
false
;
}
}
bool
BreakBefore
(
)
const
{
return
ShouldBreak
(
mBreakBefore
)
;
}
bool
BreakAfter
(
)
const
{
return
ShouldBreak
(
mBreakAfter
)
;
}
inline
bool
IsBlockInside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsBlockOutside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsInlineOutside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsOriginalDisplayInlineOutside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
mozilla
:
:
StyleDisplay
GetDisplay
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsFloating
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsRelativelyPositioned
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsStickyPositioned
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsAbsolutelyPositioned
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
HasTransform
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
HasPerspective
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsAbsPosContainingBlock
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsAbsPosContainingBlockForNonSVGTextFrames
(
)
const
;
inline
bool
IsFixedPosContainingBlock
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsFixedPosContainingBlockForNonSVGTextFrames
(
const
mozilla
:
:
ComputedStyle
&
)
const
;
inline
bool
IsFixedPosContainingBlockForContainLayoutAndPaintSupportingFrames
(
)
const
;
inline
bool
IsFixedPosContainingBlockForTransformSupportingFrames
(
)
const
;
already_AddRefed
<
nsCSSValueSharedList
>
GetCombinedTransform
(
)
const
{
return
mIndividualTransform
?
do_AddRef
(
mIndividualTransform
)
:
nullptr
;
}
void
GenerateCombinedIndividualTransform
(
)
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleTable
{
explicit
nsStyleTable
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleTable
(
const
nsStyleTable
&
aOther
)
;
~
nsStyleTable
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleTable
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleTable
&
aNewData
)
const
;
uint8_t
mLayoutStrategy
;
int32_t
mSpan
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleTableBorder
{
explicit
nsStyleTableBorder
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleTableBorder
(
const
nsStyleTableBorder
&
aOther
)
;
~
nsStyleTableBorder
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleTableBorder
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleTableBorder
&
aNewData
)
const
;
nscoord
mBorderSpacingCol
;
nscoord
mBorderSpacingRow
;
uint8_t
mBorderCollapse
;
uint8_t
mCaptionSide
;
uint8_t
mEmptyCells
;
}
;
struct
nsStyleContentAttr
{
RefPtr
<
nsAtom
>
mName
;
RefPtr
<
nsAtom
>
mNamespaceURL
;
bool
operator
=
=
(
const
nsStyleContentAttr
&
aOther
)
const
{
return
mName
=
=
aOther
.
mName
&
&
mNamespaceURL
=
=
aOther
.
mNamespaceURL
;
}
}
;
class
nsStyleContentData
{
using
StyleContentType
=
mozilla
:
:
StyleContentType
;
public
:
nsStyleContentData
(
)
:
mType
(
StyleContentType
:
:
Uninitialized
)
{
MOZ_COUNT_CTOR
(
nsStyleContentData
)
;
mContent
.
mString
=
nullptr
;
}
nsStyleContentData
(
const
nsStyleContentData
&
)
;
~
nsStyleContentData
(
)
;
nsStyleContentData
&
operator
=
(
const
nsStyleContentData
&
aOther
)
;
bool
operator
=
=
(
const
nsStyleContentData
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleContentData
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
StyleContentType
GetType
(
)
const
{
return
mType
;
}
char16_t
*
GetString
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleContentType
:
:
String
)
;
return
mContent
.
mString
;
}
const
nsStyleContentAttr
*
GetAttr
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleContentType
:
:
Attr
)
;
MOZ_ASSERT
(
mContent
.
mAttr
)
;
return
mContent
.
mAttr
;
}
struct
CounterFunction
{
nsString
mIdent
;
nsString
mSeparator
;
mozilla
:
:
CounterStylePtr
mCounterStyle
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CounterFunction
)
bool
operator
=
=
(
const
CounterFunction
&
aOther
)
const
;
bool
operator
!
=
(
const
CounterFunction
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
~
CounterFunction
(
)
{
}
}
;
CounterFunction
*
GetCounters
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleContentType
:
:
Counter
|
|
mType
=
=
StyleContentType
:
:
Counters
)
;
return
mContent
.
mCounters
;
}
nsStyleImageRequest
*
ImageRequest
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleContentType
:
:
Image
)
;
MOZ_ASSERT
(
mContent
.
mImage
)
;
return
mContent
.
mImage
;
}
imgRequestProxy
*
GetImage
(
)
const
{
return
ImageRequest
(
)
-
>
get
(
)
;
}
void
SetCounters
(
StyleContentType
aType
already_AddRefed
<
CounterFunction
>
aCounterFunction
)
{
MOZ_ASSERT
(
aType
=
=
StyleContentType
:
:
Counter
|
|
aType
=
=
StyleContentType
:
:
Counters
)
;
MOZ_ASSERT
(
mType
=
=
StyleContentType
:
:
Uninitialized
"
should
only
initialize
nsStyleContentData
once
"
)
;
mType
=
aType
;
mContent
.
mCounters
=
aCounterFunction
.
take
(
)
;
MOZ_ASSERT
(
mContent
.
mCounters
)
;
}
void
SetImageRequest
(
already_AddRefed
<
nsStyleImageRequest
>
aRequest
)
{
MOZ_ASSERT
(
mType
=
=
StyleContentType
:
:
Uninitialized
"
should
only
initialize
nsStyleContentData
once
"
)
;
mType
=
StyleContentType
:
:
Image
;
mContent
.
mImage
=
aRequest
.
take
(
)
;
MOZ_ASSERT
(
mContent
.
mImage
)
;
}
void
Resolve
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleContentData
*
)
;
private
:
StyleContentType
mType
;
union
{
char16_t
*
mString
;
nsStyleContentAttr
*
mAttr
;
nsStyleImageRequest
*
mImage
;
CounterFunction
*
mCounters
;
}
mContent
;
}
;
struct
nsStyleCounterData
{
nsString
mCounter
;
int32_t
mValue
;
bool
operator
=
=
(
const
nsStyleCounterData
&
aOther
)
const
{
return
mValue
=
=
aOther
.
mValue
&
&
mCounter
=
=
aOther
.
mCounter
;
}
bool
operator
!
=
(
const
nsStyleCounterData
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleContent
{
explicit
nsStyleContent
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleContent
(
const
nsStyleContent
&
aContent
)
;
~
nsStyleContent
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleContent
*
)
;
const
static
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleContent
&
aNewData
)
const
;
uint32_t
ContentCount
(
)
const
{
return
mContents
.
Length
(
)
;
}
const
nsStyleContentData
&
ContentAt
(
uint32_t
aIndex
)
const
{
return
mContents
[
aIndex
]
;
}
nsStyleContentData
&
ContentAt
(
uint32_t
aIndex
)
{
return
mContents
[
aIndex
]
;
}
void
AllocateContents
(
uint32_t
aCount
)
{
mContents
.
Clear
(
)
;
mContents
.
SetLength
(
aCount
)
;
}
uint32_t
CounterIncrementCount
(
)
const
{
return
mIncrements
.
Length
(
)
;
}
const
nsStyleCounterData
&
CounterIncrementAt
(
uint32_t
aIndex
)
const
{
return
mIncrements
[
aIndex
]
;
}
void
AllocateCounterIncrements
(
uint32_t
aCount
)
{
mIncrements
.
Clear
(
)
;
mIncrements
.
SetLength
(
aCount
)
;
}
void
SetCounterIncrementAt
(
uint32_t
aIndex
const
nsString
&
aCounter
int32_t
aIncrement
)
{
mIncrements
[
aIndex
]
.
mCounter
=
aCounter
;
mIncrements
[
aIndex
]
.
mValue
=
aIncrement
;
}
uint32_t
CounterResetCount
(
)
const
{
return
mResets
.
Length
(
)
;
}
const
nsStyleCounterData
&
CounterResetAt
(
uint32_t
aIndex
)
const
{
return
mResets
[
aIndex
]
;
}
void
AllocateCounterResets
(
uint32_t
aCount
)
{
mResets
.
Clear
(
)
;
mResets
.
SetLength
(
aCount
)
;
}
void
SetCounterResetAt
(
uint32_t
aIndex
const
nsString
&
aCounter
int32_t
aValue
)
{
mResets
[
aIndex
]
.
mCounter
=
aCounter
;
mResets
[
aIndex
]
.
mValue
=
aValue
;
}
protected
:
nsTArray
<
nsStyleContentData
>
mContents
;
nsTArray
<
nsStyleCounterData
>
mIncrements
;
nsTArray
<
nsStyleCounterData
>
mResets
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleUIReset
{
explicit
nsStyleUIReset
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleUIReset
(
const
nsStyleUIReset
&
aOther
)
;
~
nsStyleUIReset
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleUIReset
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleUIReset
&
aNewData
)
const
;
mozilla
:
:
StyleUserSelect
mUserSelect
;
mozilla
:
:
StyleScrollbarWidth
mScrollbarWidth
;
uint8_t
mForceBrokenImageIcon
;
uint8_t
mIMEMode
;
mozilla
:
:
StyleWindowDragging
mWindowDragging
;
uint8_t
mWindowShadow
;
float
mWindowOpacity
;
RefPtr
<
nsCSSValueSharedList
>
mSpecifiedWindowTransform
;
mozilla
:
:
StyleTransformOrigin
mWindowTransformOrigin
;
}
;
struct
nsCursorImage
{
bool
mHaveHotspot
;
float
mHotspotX
mHotspotY
;
RefPtr
<
nsStyleImageRequest
>
mImage
;
nsCursorImage
(
)
;
nsCursorImage
(
const
nsCursorImage
&
aOther
)
;
nsCursorImage
&
operator
=
(
const
nsCursorImage
&
aOther
)
;
bool
operator
=
=
(
const
nsCursorImage
&
aOther
)
const
;
bool
operator
!
=
(
const
nsCursorImage
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
imgRequestProxy
*
GetImage
(
)
const
{
return
mImage
-
>
get
(
)
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleUI
{
explicit
nsStyleUI
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleUI
(
const
nsStyleUI
&
aOther
)
;
~
nsStyleUI
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleUI
*
)
;
const
static
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleUI
&
aNewData
)
const
;
mozilla
:
:
StyleUserInput
mUserInput
;
mozilla
:
:
StyleUserModify
mUserModify
;
mozilla
:
:
StyleUserFocus
mUserFocus
;
uint8_t
mPointerEvents
;
mozilla
:
:
StyleCursorKind
mCursor
;
nsTArray
<
nsCursorImage
>
mCursorImages
;
mozilla
:
:
StyleComplexColor
mCaretColor
;
mozilla
:
:
StyleComplexColor
mScrollbarFaceColor
;
mozilla
:
:
StyleComplexColor
mScrollbarTrackColor
;
inline
uint8_t
GetEffectivePointerEvents
(
nsIFrame
*
aFrame
)
const
;
bool
HasCustomScrollbars
(
)
const
{
return
!
mScrollbarFaceColor
.
IsAuto
(
)
|
|
!
mScrollbarTrackColor
.
IsAuto
(
)
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleXUL
{
explicit
nsStyleXUL
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleXUL
(
const
nsStyleXUL
&
aSource
)
;
~
nsStyleXUL
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleXUL
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleXUL
&
aNewData
)
const
;
float
mBoxFlex
;
uint32_t
mBoxOrdinal
;
mozilla
:
:
StyleBoxAlign
mBoxAlign
;
mozilla
:
:
StyleBoxDirection
mBoxDirection
;
mozilla
:
:
StyleBoxOrient
mBoxOrient
;
mozilla
:
:
StyleBoxPack
mBoxPack
;
mozilla
:
:
StyleStackSizing
mStackSizing
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleColumn
{
explicit
nsStyleColumn
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleColumn
(
const
nsStyleColumn
&
aSource
)
;
~
nsStyleColumn
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleColumn
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleColumn
&
aNewData
)
const
;
static
const
uint32_t
kMaxColumnCount
=
1000
;
static
const
uint32_t
kColumnCountAuto
=
0
;
uint32_t
mColumnCount
=
kColumnCountAuto
;
nsStyleCoord
mColumnWidth
;
mozilla
:
:
StyleComplexColor
mColumnRuleColor
;
mozilla
:
:
StyleBorderStyle
mColumnRuleStyle
;
mozilla
:
:
StyleColumnFill
mColumnFill
=
mozilla
:
:
StyleColumnFill
:
:
Balance
;
mozilla
:
:
StyleColumnSpan
mColumnSpan
=
mozilla
:
:
StyleColumnSpan
:
:
None
;
nscoord
GetComputedColumnRuleWidth
(
)
const
{
return
(
IsVisibleBorderStyle
(
mColumnRuleStyle
)
?
mColumnRuleWidth
:
0
)
;
}
bool
IsColumnContainerStyle
(
)
const
{
return
(
mColumnCount
!
=
kColumnCountAuto
|
|
mColumnWidth
.
GetUnit
(
)
!
=
eStyleUnit_Auto
)
;
}
bool
IsColumnSpanStyle
(
)
const
{
return
mColumnSpan
=
=
mozilla
:
:
StyleColumnSpan
:
:
All
;
}
protected
:
nscoord
mColumnRuleWidth
;
nscoord
mTwipsPerPixel
;
}
;
enum
nsStyleSVGPaintType
:
uint8_t
{
eStyleSVGPaintType_None
=
1
eStyleSVGPaintType_Color
eStyleSVGPaintType_Server
eStyleSVGPaintType_ContextFill
eStyleSVGPaintType_ContextStroke
}
;
enum
nsStyleSVGFallbackType
:
uint8_t
{
eStyleSVGFallbackType_NotSet
eStyleSVGFallbackType_None
eStyleSVGFallbackType_Color
}
;
enum
nsStyleSVGOpacitySource
:
uint8_t
{
eStyleSVGOpacitySource_Normal
eStyleSVGOpacitySource_ContextFillOpacity
eStyleSVGOpacitySource_ContextStrokeOpacity
}
;
class
nsStyleSVGPaint
{
public
:
explicit
nsStyleSVGPaint
(
nsStyleSVGPaintType
aType
=
nsStyleSVGPaintType
(
0
)
)
;
nsStyleSVGPaint
(
const
nsStyleSVGPaint
&
aSource
)
;
~
nsStyleSVGPaint
(
)
;
nsStyleSVGPaint
&
operator
=
(
const
nsStyleSVGPaint
&
aOther
)
;
nsStyleSVGPaintType
Type
(
)
const
{
return
mType
;
}
void
SetNone
(
)
;
void
SetColor
(
mozilla
:
:
StyleComplexColor
aColor
)
;
void
SetPaintServer
(
mozilla
:
:
css
:
:
URLValue
*
aPaintServer
nsStyleSVGFallbackType
aFallbackType
mozilla
:
:
StyleComplexColor
aFallbackColor
)
;
void
SetPaintServer
(
mozilla
:
:
css
:
:
URLValue
*
aPaintServer
)
{
SetPaintServer
(
aPaintServer
eStyleSVGFallbackType_NotSet
mozilla
:
:
StyleComplexColor
:
:
Black
(
)
)
;
}
void
SetContextValue
(
nsStyleSVGPaintType
aType
nsStyleSVGFallbackType
aFallbackType
mozilla
:
:
StyleComplexColor
aFallbackColor
)
;
void
SetContextValue
(
nsStyleSVGPaintType
aType
)
{
SetContextValue
(
aType
eStyleSVGFallbackType_NotSet
mozilla
:
:
StyleComplexColor
:
:
Black
(
)
)
;
}
nscolor
GetColor
(
mozilla
:
:
ComputedStyle
*
aComputedStyle
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleSVGPaintType_Color
)
;
return
mPaint
.
mColor
.
CalcColor
(
aComputedStyle
)
;
}
mozilla
:
:
css
:
:
URLValue
*
GetPaintServer
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleSVGPaintType_Server
)
;
return
mPaint
.
mPaintServer
;
}
nsStyleSVGFallbackType
GetFallbackType
(
)
const
{
return
mFallbackType
;
}
nscolor
GetFallbackColor
(
mozilla
:
:
ComputedStyle
*
aComputedStyle
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleSVGPaintType_Server
|
|
mType
=
=
eStyleSVGPaintType_ContextFill
|
|
mType
=
=
eStyleSVGPaintType_ContextStroke
)
;
return
mFallbackColor
.
CalcColor
(
aComputedStyle
)
;
}
bool
operator
=
=
(
const
nsStyleSVGPaint
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleSVGPaint
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
void
Reset
(
)
;
void
Assign
(
const
nsStyleSVGPaint
&
aOther
)
;
union
ColorOrPaintServer
{
mozilla
:
:
StyleComplexColor
mColor
;
mozilla
:
:
css
:
:
URLValue
*
mPaintServer
;
explicit
ColorOrPaintServer
(
mozilla
:
:
StyleComplexColor
c
)
:
mColor
(
c
)
{
}
}
;
ColorOrPaintServer
mPaint
;
nsStyleSVGPaintType
mType
;
nsStyleSVGFallbackType
mFallbackType
;
mozilla
:
:
StyleComplexColor
mFallbackColor
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleSVG
{
explicit
nsStyleSVG
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleSVG
(
const
nsStyleSVG
&
aSource
)
;
~
nsStyleSVG
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleSVG
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleSVG
&
aNewData
)
const
;
nsStyleSVGPaint
mFill
;
nsStyleSVGPaint
mStroke
;
RefPtr
<
mozilla
:
:
css
:
:
URLValue
>
mMarkerEnd
;
RefPtr
<
mozilla
:
:
css
:
:
URLValue
>
mMarkerMid
;
RefPtr
<
mozilla
:
:
css
:
:
URLValue
>
mMarkerStart
;
nsTArray
<
nsStyleCoord
>
mStrokeDasharray
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mContextProps
;
nsStyleCoord
mStrokeDashoffset
;
nsStyleCoord
mStrokeWidth
;
float
mFillOpacity
;
float
mStrokeMiterlimit
;
float
mStrokeOpacity
;
mozilla
:
:
StyleFillRule
mClipRule
;
uint8_t
mColorInterpolation
;
uint8_t
mColorInterpolationFilters
;
mozilla
:
:
StyleFillRule
mFillRule
;
uint8_t
mPaintOrder
;
uint8_t
mShapeRendering
;
uint8_t
mStrokeLinecap
;
uint8_t
mStrokeLinejoin
;
uint8_t
mTextAnchor
;
uint8_t
mContextPropsBits
;
bool
ExposesContextProperties
(
)
const
{
return
bool
(
mContextPropsBits
)
;
}
nsStyleSVGOpacitySource
FillOpacitySource
(
)
const
{
uint8_t
value
=
(
mContextFlags
&
FILL_OPACITY_SOURCE_MASK
)
>
>
FILL_OPACITY_SOURCE_SHIFT
;
return
nsStyleSVGOpacitySource
(
value
)
;
}
nsStyleSVGOpacitySource
StrokeOpacitySource
(
)
const
{
uint8_t
value
=
(
mContextFlags
&
STROKE_OPACITY_SOURCE_MASK
)
>
>
STROKE_OPACITY_SOURCE_SHIFT
;
return
nsStyleSVGOpacitySource
(
value
)
;
}
bool
StrokeDasharrayFromObject
(
)
const
{
return
mContextFlags
&
STROKE_DASHARRAY_CONTEXT
;
}
bool
StrokeDashoffsetFromObject
(
)
const
{
return
mContextFlags
&
STROKE_DASHOFFSET_CONTEXT
;
}
bool
StrokeWidthFromObject
(
)
const
{
return
mContextFlags
&
STROKE_WIDTH_CONTEXT
;
}
bool
HasMarker
(
)
const
{
return
mMarkerStart
|
|
mMarkerMid
|
|
mMarkerEnd
;
}
bool
HasStroke
(
)
const
{
return
mStroke
.
Type
(
)
!
=
eStyleSVGPaintType_None
&
&
mStrokeOpacity
>
0
;
}
bool
HasFill
(
)
const
{
return
mFill
.
Type
(
)
!
=
eStyleSVGPaintType_None
&
&
mFillOpacity
>
0
;
}
private
:
static
const
uint8_t
FILL_OPACITY_SOURCE_MASK
=
0x03
;
static
const
uint8_t
STROKE_OPACITY_SOURCE_MASK
=
0x0C
;
static
const
uint8_t
STROKE_DASHARRAY_CONTEXT
=
0x10
;
static
const
uint8_t
STROKE_DASHOFFSET_CONTEXT
=
0x20
;
static
const
uint8_t
STROKE_WIDTH_CONTEXT
=
0x40
;
static
const
uint8_t
FILL_OPACITY_SOURCE_SHIFT
=
0
;
static
const
uint8_t
STROKE_OPACITY_SOURCE_SHIFT
=
2
;
uint8_t
mContextFlags
;
}
;
struct
nsStyleFilter
{
nsStyleFilter
(
)
;
nsStyleFilter
(
const
nsStyleFilter
&
aSource
)
;
~
nsStyleFilter
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleFilter
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsStyleFilter
&
operator
=
(
const
nsStyleFilter
&
aOther
)
;
bool
operator
=
=
(
const
nsStyleFilter
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleFilter
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
uint32_t
GetType
(
)
const
{
return
mType
;
}
const
nsStyleCoord
&
GetFilterParameter
(
)
const
{
NS_ASSERTION
(
mType
!
=
NS_STYLE_FILTER_DROP_SHADOW
&
&
mType
!
=
NS_STYLE_FILTER_URL
&
&
mType
!
=
NS_STYLE_FILTER_NONE
"
wrong
filter
type
"
)
;
return
mFilterParameter
;
}
void
SetFilterParameter
(
const
nsStyleCoord
&
aFilterParameter
int32_t
aType
)
;
mozilla
:
:
css
:
:
URLValue
*
GetURL
(
)
const
{
MOZ_ASSERT
(
mType
=
=
NS_STYLE_FILTER_URL
"
wrong
filter
type
"
)
;
return
mURL
;
}
bool
SetURL
(
mozilla
:
:
css
:
:
URLValue
*
aValue
)
;
nsCSSShadowArray
*
GetDropShadow
(
)
const
{
NS_ASSERTION
(
mType
=
=
NS_STYLE_FILTER_DROP_SHADOW
"
wrong
filter
type
"
)
;
return
mDropShadow
;
}
void
SetDropShadow
(
nsCSSShadowArray
*
aDropShadow
)
;
private
:
void
ReleaseRef
(
)
;
uint32_t
mType
;
nsStyleCoord
mFilterParameter
;
union
{
mozilla
:
:
css
:
:
URLValue
*
mURL
;
nsCSSShadowArray
*
mDropShadow
;
}
;
}
;
template
<
>
struct
nsTArray_CopyChooser
<
nsStyleFilter
>
{
typedef
nsTArray_CopyWithConstructors
<
nsStyleFilter
>
Type
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleSVGReset
{
explicit
nsStyleSVGReset
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleSVGReset
(
const
nsStyleSVGReset
&
aSource
)
;
~
nsStyleSVGReset
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleSVGReset
*
)
;
const
static
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleSVGReset
&
aNewData
)
const
;
bool
HasClipPath
(
)
const
{
return
mClipPath
.
GetType
(
)
!
=
mozilla
:
:
StyleShapeSourceType
:
:
None
;
}
bool
HasMask
(
)
const
;
bool
HasNonScalingStroke
(
)
const
{
return
mVectorEffect
=
=
NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE
;
}
nsStyleImageLayers
mMask
;
mozilla
:
:
StyleShapeSource
mClipPath
;
mozilla
:
:
StyleComplexColor
mStopColor
;
mozilla
:
:
StyleComplexColor
mFloodColor
;
mozilla
:
:
StyleComplexColor
mLightingColor
;
float
mStopOpacity
;
float
mFloodOpacity
;
uint8_t
mDominantBaseline
;
uint8_t
mVectorEffect
;
uint8_t
mMaskType
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleEffects
{
explicit
nsStyleEffects
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleEffects
(
const
nsStyleEffects
&
aSource
)
;
~
nsStyleEffects
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleEffects
*
)
{
}
const
static
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleEffects
&
aNewData
)
const
;
bool
HasFilters
(
)
const
{
return
!
mFilters
.
IsEmpty
(
)
;
}
nsTArray
<
nsStyleFilter
>
mFilters
;
RefPtr
<
nsCSSShadowArray
>
mBoxShadow
;
nsRect
mClip
;
float
mOpacity
;
uint8_t
mClipFlags
;
uint8_t
mMixBlendMode
;
}
;
#
define
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
T1
T2
)
\
static_assert
(
sizeof
(
T1
)
=
=
sizeof
(
T2
)
\
"
Size
mismatch
between
"
#
T1
"
and
"
#
T2
)
;
\
static_assert
(
alignof
(
T1
)
=
=
alignof
(
T2
)
\
"
Align
mismatch
between
"
#
T1
"
and
"
#
T2
)
;
#
define
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
T1
T2
field
)
\
static_assert
(
offsetof
(
T1
field
)
=
=
offsetof
(
T2
field
)
\
"
Field
offset
mismatch
of
"
#
field
"
between
"
#
T1
\
"
and
"
#
T2
)
;
/
*
*
*
These
*
_Simple
types
are
used
to
map
Gecko
types
to
layout
-
equivalent
but
*
simpler
Rust
types
to
aid
Rust
binding
generation
.
*
*
If
something
in
this
types
or
the
assertions
below
needs
to
change
ask
*
bholley
heycam
or
emilio
before
!
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsPoint
"
>
*
/
struct
nsPoint_Simple
{
nscoord
x
y
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsPoint
nsPoint_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsPoint
nsPoint_Simple
x
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsPoint
nsPoint_Simple
y
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsMargin
"
>
*
/
struct
nsMargin_Simple
{
nscoord
top
right
bottom
left
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsMargin
nsMargin_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
top
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
right
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
bottom
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
left
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsRect
"
>
*
/
struct
nsRect_Simple
{
nscoord
x
y
width
height
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsRect
nsRect_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
x
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
y
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
width
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
height
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsSize
"
>
*
/
struct
nsSize_Simple
{
nscoord
width
height
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsSize
nsSize_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsSize
nsSize_Simple
width
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsSize
nsSize_Simple
height
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
mozilla
:
:
UniquePtr
"
>
*
*
TODO
(
Emilio
)
:
This
is
a
workaround
and
we
should
be
able
to
get
rid
of
this
*
one
.
*
/
template
<
typename
T
>
struct
UniquePtr_Simple
{
T
*
mPtr
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
mozilla
:
:
UniquePtr
<
int
>
UniquePtr_Simple
<
int
>
)
;
/
*
*
*
<
div
rustbindgen
replaces
=
"
nsTArray
"
>
<
/
div
>
*
/
template
<
typename
T
>
class
nsTArray_Simple
{
T
*
mBuffer
;
public
:
~
nsTArray_Simple
(
)
{
}
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsTArray
<
nsStyleImageLayers
:
:
Layer
>
nsTArray_Simple
<
nsStyleImageLayers
:
:
Layer
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsTArray
<
mozilla
:
:
StyleTransition
>
nsTArray_Simple
<
mozilla
:
:
StyleTransition
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsTArray
<
mozilla
:
:
StyleAnimation
>
nsTArray_Simple
<
mozilla
:
:
StyleAnimation
>
)
;
/
*
*
*
<
div
rustbindgen
replaces
=
"
nsCOMArray
"
>
<
/
div
>
*
*
mozilla
:
:
ArrayIterator
doesn
'
t
work
well
with
bindgen
.
*
/
template
<
typename
T
>
class
nsCOMArray_Simple
{
nsTArray
<
nsISupports
*
>
mBuffer
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsCOMArray
<
nsIContent
>
nsCOMArray_Simple
<
nsIContent
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsCOMArray
<
nsINode
>
nsCOMArray_Simple
<
nsINode
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsCOMArray
<
imgIContainer
>
nsCOMArray_Simple
<
imgIContainer
>
)
;
#
endif
