#
ifndef
nsStyleStruct_h___
#
define
nsStyleStruct_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StyleColorInlines
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsMargin
.
h
"
#
include
"
nsFont
.
h
"
#
include
"
nsStyleAutoArray
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsTimingFunction
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
Orientation
.
h
"
#
include
"
CounterStyleManager
.
h
"
#
include
<
cstddef
>
#
include
<
utility
>
#
include
"
X11UndefineNone
.
h
"
class
nsIFrame
;
class
nsIURI
;
class
nsTextFrame
;
class
imgIContainer
;
class
nsPresContext
;
struct
nsStyleDisplay
;
struct
nsStyleVisibility
;
namespace
mozilla
{
class
ComputedStyle
;
namespace
dom
{
class
ImageTracker
;
}
}
namespace
mozilla
{
using
Position
=
StylePosition
;
template
<
>
inline
bool
StylePosition
:
:
HasPercent
(
)
const
{
return
horizontal
.
HasPercent
(
)
|
|
vertical
.
HasPercent
(
)
;
}
template
<
>
inline
bool
StylePosition
:
:
DependsOnPositioningAreaSize
(
)
const
{
return
HasPercent
(
)
;
}
template
<
>
inline
Position
Position
:
:
FromPercentage
(
float
aPercent
)
{
return
{
LengthPercentage
:
:
FromPercentage
(
aPercent
)
LengthPercentage
:
:
FromPercentage
(
aPercent
)
}
;
}
}
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleFont
{
nsStyleFont
(
const
nsStyleFont
&
aStyleFont
)
;
explicit
nsStyleFont
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
~
nsStyleFont
(
)
{
MOZ_COUNT_DTOR
(
nsStyleFont
)
;
}
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleFont
&
aNewData
)
const
;
static
nscoord
ZoomText
(
const
mozilla
:
:
dom
:
:
Document
&
nscoord
aSize
)
;
nsFont
mFont
;
nscoord
mSize
;
float
mFontSizeFactor
;
nscoord
mFontSizeOffset
;
uint8_t
mFontSizeKeyword
;
mozilla
:
:
StyleGenericFontFamily
mGenericID
;
int8_t
mScriptLevel
;
uint8_t
mMathVariant
;
uint8_t
mMathDisplay
;
uint8_t
mMinFontSizeRatio
;
bool
mExplicitLanguage
;
bool
mAllowZoom
;
nscoord
mScriptUnconstrainedSize
;
nscoord
mScriptMinSize
;
float
mScriptSizeMultiplier
;
RefPtr
<
nsAtom
>
mLanguage
;
}
;
class
nsStyleImageRequest
{
public
:
enum
class
Mode
:
uint8_t
{
Track
=
0x1
Discard
=
0x2
}
;
nsStyleImageRequest
(
Mode
aModeFlags
const
mozilla
:
:
StyleComputedImageUrl
&
)
;
void
Resolve
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleImageRequest
*
aOldImageRequest
)
;
bool
IsResolved
(
)
const
{
return
mResolved
;
}
imgRequestProxy
*
get
(
)
{
MOZ_ASSERT
(
IsResolved
(
)
"
Resolve
(
)
must
be
called
first
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mRequestProxy
.
get
(
)
;
}
const
imgRequestProxy
*
get
(
)
const
{
return
const_cast
<
nsStyleImageRequest
*
>
(
this
)
-
>
get
(
)
;
}
bool
DefinitelyEquals
(
const
nsStyleImageRequest
&
aOther
)
const
;
const
mozilla
:
:
StyleComputedImageUrl
&
GetImageValue
(
)
const
{
return
mImageURL
;
}
already_AddRefed
<
nsIURI
>
GetImageURI
(
)
const
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsStyleImageRequest
)
;
private
:
~
nsStyleImageRequest
(
)
;
nsStyleImageRequest
&
operator
=
(
const
nsStyleImageRequest
&
aOther
)
=
delete
;
void
MaybeTrackAndLock
(
)
;
RefPtr
<
imgRequestProxy
>
mRequestProxy
;
mozilla
:
:
StyleComputedImageUrl
mImageURL
;
RefPtr
<
mozilla
:
:
dom
:
:
ImageTracker
>
mImageTracker
;
RefPtr
<
mozilla
:
:
dom
:
:
DocGroup
>
mDocGroup
;
Mode
mModeFlags
;
bool
mResolved
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
nsStyleImageRequest
:
:
Mode
)
enum
nsStyleImageType
{
eStyleImageType_Null
eStyleImageType_Image
eStyleImageType_Gradient
eStyleImageType_Element
}
;
struct
CachedBorderImageData
{
~
CachedBorderImageData
(
)
{
PurgeCachedImages
(
)
;
}
void
SetCachedSVGViewportSize
(
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
)
;
const
mozilla
:
:
Maybe
<
nsSize
>
&
GetCachedSVGViewportSize
(
)
;
void
PurgeCachedImages
(
)
;
void
SetSubImage
(
uint8_t
aIndex
imgIContainer
*
aSubImage
)
;
imgIContainer
*
GetSubImage
(
uint8_t
aIndex
)
;
private
:
mozilla
:
:
Maybe
<
nsSize
>
mCachedSVGViewportSize
;
nsCOMArray
<
imgIContainer
>
mSubImages
;
}
;
struct
nsStyleImage
{
using
CropRect
=
mozilla
:
:
StyleRect
<
mozilla
:
:
StyleNumberOrPercentage
>
;
nsStyleImage
(
)
;
~
nsStyleImage
(
)
;
nsStyleImage
(
const
nsStyleImage
&
aOther
)
;
nsStyleImage
&
operator
=
(
const
nsStyleImage
&
aOther
)
;
void
SetNull
(
)
;
void
SetImageRequest
(
already_AddRefed
<
nsStyleImageRequest
>
aImage
)
;
void
SetGradientData
(
mozilla
:
:
UniquePtr
<
mozilla
:
:
StyleGradient
>
)
;
void
SetElementId
(
already_AddRefed
<
nsAtom
>
aElementId
)
;
void
SetCropRect
(
mozilla
:
:
UniquePtr
<
CropRect
>
aCropRect
)
;
void
ResolveImage
(
mozilla
:
:
dom
:
:
Document
&
aDocument
const
nsStyleImage
*
aOldImage
)
{
MOZ_ASSERT
(
mType
!
=
eStyleImageType_Image
|
|
mImage
)
;
if
(
mType
=
=
eStyleImageType_Image
&
&
!
mImage
-
>
IsResolved
(
)
)
{
const
nsStyleImageRequest
*
oldRequest
=
(
aOldImage
&
&
aOldImage
-
>
GetType
(
)
=
=
eStyleImageType_Image
)
?
aOldImage
-
>
ImageRequest
(
)
:
nullptr
;
mImage
-
>
Resolve
(
aDocument
oldRequest
)
;
}
}
nsStyleImageType
GetType
(
)
const
{
return
mType
;
}
nsStyleImageRequest
*
ImageRequest
(
)
const
{
MOZ_ASSERT
(
mType
=
=
eStyleImageType_Image
"
Data
is
not
an
image
!
"
)
;
MOZ_ASSERT
(
mImage
)
;
return
mImage
;
}
imgRequestProxy
*
GetImageData
(
)
const
{
return
ImageRequest
(
)
-
>
get
(
)
;
}
const
mozilla
:
:
StyleGradient
&
GetGradient
(
)
const
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Gradient
"
Data
is
not
a
gradient
!
"
)
;
return
*
mGradient
;
}
bool
IsResolved
(
)
const
{
return
mType
!
=
eStyleImageType_Image
|
|
ImageRequest
(
)
-
>
IsResolved
(
)
;
}
const
nsAtom
*
GetElementId
(
)
const
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Element
"
Data
is
not
an
element
!
"
)
;
return
mElementId
;
}
const
CropRect
*
GetCropRect
(
)
const
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Image
"
Only
image
data
can
have
a
crop
rect
"
)
;
return
mCropRect
.
get
(
)
;
}
already_AddRefed
<
nsIURI
>
GetImageURI
(
)
const
;
const
mozilla
:
:
StyleComputedImageUrl
*
GetURLValue
(
)
const
;
bool
ComputeActualCropRect
(
nsIntRect
&
aActualCropRect
bool
*
aIsEntireImage
=
nullptr
)
const
;
bool
StartDecoding
(
)
const
;
bool
IsOpaque
(
)
const
;
bool
IsComplete
(
)
const
;
bool
IsSizeAvailable
(
)
const
;
bool
IsEmpty
(
)
const
{
return
mType
=
=
eStyleImageType_Null
;
}
bool
operator
=
=
(
const
nsStyleImage
&
aOther
)
const
;
bool
operator
!
=
(
const
nsStyleImage
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
bool
ImageDataEquals
(
const
nsStyleImage
&
aOther
)
const
{
return
GetType
(
)
=
=
eStyleImageType_Image
&
&
aOther
.
GetType
(
)
=
=
eStyleImageType_Image
&
&
GetImageData
(
)
=
=
aOther
.
GetImageData
(
)
;
}
inline
void
SetSubImage
(
uint8_t
aIndex
imgIContainer
*
aSubImage
)
const
;
inline
imgIContainer
*
GetSubImage
(
uint8_t
aIndex
)
const
;
void
PurgeCacheForViewportChange
(
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasIntrinsicRatio
)
const
;
private
:
void
DoCopy
(
const
nsStyleImage
&
aOther
)
;
void
EnsureCachedBIData
(
)
const
;
mozilla
:
:
UniquePtr
<
CachedBorderImageData
>
mCachedBIData
;
nsStyleImageType
mType
;
union
{
nsStyleImageRequest
*
mImage
;
mozilla
:
:
StyleGradient
*
mGradient
;
nsAtom
*
mElementId
;
}
;
mozilla
:
:
UniquePtr
<
CropRect
>
mCropRect
;
}
;
struct
nsStyleImageLayers
{
enum
{
shorthand
=
0
color
image
repeat
positionX
positionY
clip
origin
size
attachment
maskMode
composite
}
;
enum
class
LayerType
:
uint8_t
{
Background
=
0
Mask
}
;
explicit
nsStyleImageLayers
(
LayerType
aType
)
;
nsStyleImageLayers
(
const
nsStyleImageLayers
&
aSource
)
;
~
nsStyleImageLayers
(
)
{
MOZ_COUNT_DTOR
(
nsStyleImageLayers
)
;
}
static
bool
IsInitialPositionForLayerType
(
mozilla
:
:
Position
aPosition
LayerType
aType
)
;
struct
Repeat
{
mozilla
:
:
StyleImageLayerRepeat
mXRepeat
mYRepeat
;
Repeat
(
)
{
}
bool
IsInitialValue
(
)
const
{
return
mXRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
&
&
mYRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
;
}
bool
DependsOnPositioningAreaSize
(
)
const
{
return
mXRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Space
|
|
mYRepeat
=
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Space
;
}
void
SetInitialValues
(
)
{
mXRepeat
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
;
mYRepeat
=
mozilla
:
:
StyleImageLayerRepeat
:
:
Repeat
;
}
bool
operator
=
=
(
const
Repeat
&
aOther
)
const
{
return
mXRepeat
=
=
aOther
.
mXRepeat
&
&
mYRepeat
=
=
aOther
.
mYRepeat
;
}
bool
operator
!
=
(
const
Repeat
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
Layer
{
typedef
mozilla
:
:
StyleGeometryBox
StyleGeometryBox
;
typedef
mozilla
:
:
StyleImageLayerAttachment
StyleImageLayerAttachment
;
typedef
mozilla
:
:
StyleBackgroundSize
StyleBackgroundSize
;
nsStyleImage
mImage
;
mozilla
:
:
Position
mPosition
;
StyleBackgroundSize
mSize
;
StyleGeometryBox
mClip
;
MOZ_INIT_OUTSIDE_CTOR
StyleGeometryBox
mOrigin
;
StyleImageLayerAttachment
mAttachment
;
uint8_t
mBlendMode
;
uint8_t
mComposite
;
mozilla
:
:
StyleMaskMode
mMaskMode
;
Repeat
mRepeat
;
Layer
(
)
;
~
Layer
(
)
;
void
Initialize
(
LayerType
aType
)
;
void
ResolveImage
(
mozilla
:
:
dom
:
:
Document
&
aDocument
const
Layer
*
aOldLayer
)
{
mImage
.
ResolveImage
(
aDocument
aOldLayer
?
&
aOldLayer
-
>
mImage
:
nullptr
)
;
}
bool
RenderingMightDependOnPositioningAreaSizeChange
(
)
const
;
nsChangeHint
CalcDifference
(
const
Layer
&
aNewLayer
)
const
;
bool
operator
=
=
(
const
Layer
&
aOther
)
const
;
bool
operator
!
=
(
const
Layer
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
uint32_t
mAttachmentCount
;
uint32_t
mClipCount
;
uint32_t
mOriginCount
;
uint32_t
mRepeatCount
;
uint32_t
mPositionXCount
;
uint32_t
mPositionYCount
;
uint32_t
mImageCount
;
uint32_t
mSizeCount
;
uint32_t
mMaskModeCount
;
uint32_t
mBlendModeCount
;
uint32_t
mCompositeCount
;
nsStyleAutoArray
<
Layer
>
mLayers
;
const
Layer
&
BottomLayer
(
)
const
{
return
mLayers
[
mImageCount
-
1
]
;
}
void
ResolveImages
(
mozilla
:
:
dom
:
:
Document
&
aDocument
const
nsStyleImageLayers
*
aOldLayers
)
{
for
(
uint32_t
i
=
0
;
i
<
mImageCount
;
+
+
i
)
{
const
Layer
*
oldLayer
=
(
aOldLayers
&
&
aOldLayers
-
>
mLayers
.
Length
(
)
>
i
)
?
&
aOldLayers
-
>
mLayers
[
i
]
:
nullptr
;
mLayers
[
i
]
.
ResolveImage
(
aDocument
oldLayer
)
;
}
}
void
FillAllLayers
(
uint32_t
aMaxItemCount
)
;
nsChangeHint
CalcDifference
(
const
nsStyleImageLayers
&
aNewLayers
nsStyleImageLayers
:
:
LayerType
aType
)
const
;
nsStyleImageLayers
&
operator
=
(
const
nsStyleImageLayers
&
aOther
)
;
nsStyleImageLayers
&
operator
=
(
nsStyleImageLayers
&
&
aOther
)
;
bool
operator
=
=
(
const
nsStyleImageLayers
&
aOther
)
const
;
static
const
nsCSSPropertyID
kBackgroundLayerTable
[
]
;
static
const
nsCSSPropertyID
kMaskLayerTable
[
]
;
#
define
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
var_
layers_
)
\
for
(
uint32_t
var_
=
(
layers_
)
.
mImageCount
;
var_
-
-
!
=
0
;
)
#
define
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT_WITH_RANGE
(
var_
layers_
\
start_
count_
)
\
NS_ASSERTION
(
\
(
int32_t
)
(
start_
)
>
=
0
&
&
(
uint32_t
)
(
start_
)
<
(
layers_
)
.
mImageCount
\
"
Invalid
layer
start
!
"
)
;
\
NS_ASSERTION
(
(
count_
)
>
0
&
&
(
count_
)
<
=
(
start_
)
+
1
\
"
Invalid
layer
range
!
"
)
;
\
for
(
uint32_t
var_
=
(
start_
)
+
1
;
\
var_
-
-
!
=
(
uint32_t
)
(
(
start_
)
+
1
-
(
count_
)
)
;
)
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleBackground
{
explicit
nsStyleBackground
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleBackground
(
const
nsStyleBackground
&
aOther
)
;
~
nsStyleBackground
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleBackground
*
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleBackground
&
aNewData
)
const
;
nscolor
BackgroundColor
(
const
nsIFrame
*
aFrame
)
const
;
nscolor
BackgroundColor
(
mozilla
:
:
ComputedStyle
*
aStyle
)
const
;
bool
IsTransparent
(
const
nsIFrame
*
aFrame
)
const
;
bool
IsTransparent
(
mozilla
:
:
ComputedStyle
*
aStyle
)
const
;
bool
HasFixedBackground
(
nsIFrame
*
aFrame
)
const
;
inline
bool
HasLocalBackground
(
)
const
;
const
nsStyleImageLayers
:
:
Layer
&
BottomLayer
(
)
const
{
return
mImage
.
BottomLayer
(
)
;
}
nsStyleImageLayers
mImage
;
mozilla
:
:
StyleColor
mBackgroundColor
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleMargin
{
explicit
nsStyleMargin
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleMargin
(
const
nsStyleMargin
&
aMargin
)
;
~
nsStyleMargin
(
)
{
MOZ_COUNT_DTOR
(
nsStyleMargin
)
;
}
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleMargin
&
aNewData
)
const
;
bool
GetMargin
(
nsMargin
&
aMargin
)
const
{
bool
convertsToLength
=
mMargin
.
All
(
[
]
(
const
auto
&
aLength
)
{
return
aLength
.
ConvertsToLength
(
)
;
}
)
;
if
(
!
convertsToLength
)
{
return
false
;
}
NS_FOR_CSS_SIDES
(
side
)
{
aMargin
.
Side
(
side
)
=
mMargin
.
Get
(
side
)
.
AsLengthPercentage
(
)
.
ToLength
(
)
;
}
return
true
;
}
nsMargin
GetScrollMargin
(
)
const
{
return
nsMargin
(
mScrollMargin
.
Get
(
mozilla
:
:
eSideTop
)
.
ToAppUnits
(
)
mScrollMargin
.
Get
(
mozilla
:
:
eSideRight
)
.
ToAppUnits
(
)
mScrollMargin
.
Get
(
mozilla
:
:
eSideBottom
)
.
ToAppUnits
(
)
mScrollMargin
.
Get
(
mozilla
:
:
eSideLeft
)
.
ToAppUnits
(
)
)
;
}
inline
bool
HasBlockAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
;
inline
bool
HasInlineAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
;
mozilla
:
:
StyleRect
<
mozilla
:
:
LengthPercentageOrAuto
>
mMargin
;
mozilla
:
:
StyleRect
<
mozilla
:
:
StyleLength
>
mScrollMargin
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStylePadding
{
explicit
nsStylePadding
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStylePadding
(
const
nsStylePadding
&
aPadding
)
;
~
nsStylePadding
(
)
{
MOZ_COUNT_DTOR
(
nsStylePadding
)
;
}
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStylePadding
&
aNewData
)
const
;
mozilla
:
:
StyleRect
<
mozilla
:
:
NonNegativeLengthPercentage
>
mPadding
;
mozilla
:
:
StyleRect
<
mozilla
:
:
NonNegativeLengthPercentageOrAuto
>
mScrollPadding
;
inline
bool
IsWidthDependent
(
)
const
{
return
!
mPadding
.
All
(
[
]
(
const
auto
&
aLength
)
{
return
aLength
.
ConvertsToLength
(
)
;
}
)
;
}
bool
GetPadding
(
nsMargin
&
aPadding
)
const
{
if
(
IsWidthDependent
(
)
)
{
return
false
;
}
NS_FOR_CSS_SIDES
(
side
)
{
aPadding
.
Side
(
side
)
=
std
:
:
max
(
mPadding
.
Get
(
side
)
.
ToLength
(
)
0
)
;
}
return
true
;
}
}
;
#
define
NS_ROUND_BORDER_TO_PIXELS
(
l
tpp
)
\
(
(
l
)
=
=
0
)
?
0
:
std
:
:
max
(
(
tpp
)
(
l
)
/
(
tpp
)
*
(
tpp
)
)
static
bool
IsVisibleBorderStyle
(
mozilla
:
:
StyleBorderStyle
aStyle
)
{
return
(
aStyle
!
=
mozilla
:
:
StyleBorderStyle
:
:
None
&
&
aStyle
!
=
mozilla
:
:
StyleBorderStyle
:
:
Hidden
)
;
}
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleBorder
{
explicit
nsStyleBorder
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleBorder
(
const
nsStyleBorder
&
aBorder
)
;
~
nsStyleBorder
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleBorder
*
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleBorder
&
aNewData
)
const
;
bool
HasVisibleStyle
(
mozilla
:
:
Side
aSide
)
const
{
return
IsVisibleBorderStyle
(
mBorderStyle
[
aSide
]
)
;
}
void
SetBorderWidth
(
mozilla
:
:
Side
aSide
nscoord
aBorderWidth
)
{
nscoord
roundedWidth
=
NS_ROUND_BORDER_TO_PIXELS
(
aBorderWidth
mTwipsPerPixel
)
;
mBorder
.
Side
(
aSide
)
=
roundedWidth
;
if
(
HasVisibleStyle
(
aSide
)
)
{
mComputedBorder
.
Side
(
aSide
)
=
roundedWidth
;
}
}
const
nsMargin
&
GetComputedBorder
(
)
const
{
return
mComputedBorder
;
}
bool
HasBorder
(
)
const
{
return
mComputedBorder
!
=
nsMargin
(
0
0
0
0
)
|
|
!
mBorderImageSource
.
IsEmpty
(
)
;
}
nscoord
GetComputedBorderWidth
(
mozilla
:
:
Side
aSide
)
const
{
return
GetComputedBorder
(
)
.
Side
(
aSide
)
;
}
mozilla
:
:
StyleBorderStyle
GetBorderStyle
(
mozilla
:
:
Side
aSide
)
const
{
NS_ASSERTION
(
aSide
<
=
mozilla
:
:
eSideLeft
"
bad
side
"
)
;
return
mBorderStyle
[
aSide
]
;
}
void
SetBorderStyle
(
mozilla
:
:
Side
aSide
mozilla
:
:
StyleBorderStyle
aStyle
)
{
NS_ASSERTION
(
aSide
<
=
mozilla
:
:
eSideLeft
"
bad
side
"
)
;
mBorderStyle
[
aSide
]
=
aStyle
;
mComputedBorder
.
Side
(
aSide
)
=
(
HasVisibleStyle
(
aSide
)
?
mBorder
.
Side
(
aSide
)
:
0
)
;
}
inline
bool
IsBorderImageSizeAvailable
(
)
const
{
return
mBorderImageSource
.
IsSizeAvailable
(
)
;
}
nsMargin
GetImageOutset
(
)
const
;
imgIRequest
*
GetBorderImageRequest
(
)
const
{
if
(
mBorderImageSource
.
GetType
(
)
=
=
eStyleImageType_Image
)
{
return
mBorderImageSource
.
GetImageData
(
)
;
}
return
nullptr
;
}
public
:
mozilla
:
:
StyleBorderRadius
mBorderRadius
;
nsStyleImage
mBorderImageSource
;
mozilla
:
:
StyleBorderImageWidth
mBorderImageWidth
;
mozilla
:
:
StyleNonNegativeLengthOrNumberRect
mBorderImageOutset
;
mozilla
:
:
StyleBorderImageSlice
mBorderImageSlice
;
mozilla
:
:
StyleBorderImageRepeat
mBorderImageRepeatH
;
mozilla
:
:
StyleBorderImageRepeat
mBorderImageRepeatV
;
mozilla
:
:
StyleFloatEdge
mFloatEdge
;
mozilla
:
:
StyleBoxDecorationBreak
mBoxDecorationBreak
;
protected
:
mozilla
:
:
StyleBorderStyle
mBorderStyle
[
4
]
;
public
:
mozilla
:
:
StyleColor
mBorderTopColor
;
mozilla
:
:
StyleColor
mBorderRightColor
;
mozilla
:
:
StyleColor
mBorderBottomColor
;
mozilla
:
:
StyleColor
mBorderLeftColor
;
mozilla
:
:
StyleColor
&
BorderColorFor
(
mozilla
:
:
Side
aSide
)
{
switch
(
aSide
)
{
case
mozilla
:
:
eSideTop
:
return
mBorderTopColor
;
case
mozilla
:
:
eSideRight
:
return
mBorderRightColor
;
case
mozilla
:
:
eSideBottom
:
return
mBorderBottomColor
;
case
mozilla
:
:
eSideLeft
:
return
mBorderLeftColor
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
side
"
)
;
return
mBorderTopColor
;
}
const
mozilla
:
:
StyleColor
&
BorderColorFor
(
mozilla
:
:
Side
aSide
)
const
{
switch
(
aSide
)
{
case
mozilla
:
:
eSideTop
:
return
mBorderTopColor
;
case
mozilla
:
:
eSideRight
:
return
mBorderRightColor
;
case
mozilla
:
:
eSideBottom
:
return
mBorderBottomColor
;
case
mozilla
:
:
eSideLeft
:
return
mBorderLeftColor
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
side
"
)
;
return
mBorderTopColor
;
}
static
mozilla
:
:
StyleColor
nsStyleBorder
:
:
*
BorderColorFieldFor
(
mozilla
:
:
Side
aSide
)
{
switch
(
aSide
)
{
case
mozilla
:
:
eSideTop
:
return
&
nsStyleBorder
:
:
mBorderTopColor
;
case
mozilla
:
:
eSideRight
:
return
&
nsStyleBorder
:
:
mBorderRightColor
;
case
mozilla
:
:
eSideBottom
:
return
&
nsStyleBorder
:
:
mBorderBottomColor
;
case
mozilla
:
:
eSideLeft
:
return
&
nsStyleBorder
:
:
mBorderLeftColor
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
side
"
)
;
return
nullptr
;
}
protected
:
nsMargin
mComputedBorder
;
nsMargin
mBorder
;
private
:
nscoord
mTwipsPerPixel
;
nsStyleBorder
&
operator
=
(
const
nsStyleBorder
&
aOther
)
=
delete
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleOutline
{
explicit
nsStyleOutline
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleOutline
(
const
nsStyleOutline
&
aOutline
)
;
~
nsStyleOutline
(
)
{
MOZ_COUNT_DTOR
(
nsStyleOutline
)
;
}
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleOutline
&
aNewData
)
const
;
mozilla
:
:
StyleBorderRadius
mOutlineRadius
;
nscoord
mOutlineWidth
;
mozilla
:
:
Length
mOutlineOffset
;
mozilla
:
:
StyleColor
mOutlineColor
;
mozilla
:
:
StyleOutlineStyle
mOutlineStyle
;
nscoord
GetOutlineWidth
(
)
const
{
return
mActualOutlineWidth
;
}
bool
ShouldPaintOutline
(
)
const
{
if
(
mOutlineStyle
.
IsAuto
(
)
)
{
return
true
;
}
if
(
GetOutlineWidth
(
)
>
0
)
{
MOZ_ASSERT
(
mOutlineStyle
.
AsBorderStyle
(
)
!
=
mozilla
:
:
StyleBorderStyle
:
:
None
"
outline
-
style
:
none
implies
outline
-
width
of
zero
"
)
;
return
true
;
}
return
false
;
}
protected
:
nscoord
mActualOutlineWidth
;
nscoord
mTwipsPerPixel
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleList
{
explicit
nsStyleList
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleList
(
const
nsStyleList
&
aStyleList
)
;
~
nsStyleList
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleList
*
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleList
&
aNewData
const
nsStyleDisplay
&
aOldDisplay
)
const
;
imgRequestProxy
*
GetListStyleImage
(
)
const
{
return
mListStyleImage
?
mListStyleImage
-
>
get
(
)
:
nullptr
;
}
nsRect
GetImageRegion
(
)
const
{
if
(
!
mImageRegion
.
IsRect
(
)
)
{
return
nsRect
(
)
;
}
return
mImageRegion
.
AsRect
(
)
.
ToLayoutRect
(
0
)
;
}
already_AddRefed
<
nsIURI
>
GetListStyleImageURI
(
)
const
;
uint8_t
mListStylePosition
;
RefPtr
<
nsStyleImageRequest
>
mListStyleImage
;
mozilla
:
:
CounterStylePtr
mCounterStyle
;
private
:
nsStyleList
&
operator
=
(
const
nsStyleList
&
aOther
)
=
delete
;
public
:
mozilla
:
:
StyleQuotes
mQuotes
;
mozilla
:
:
StyleClipRectOrAuto
mImageRegion
;
mozilla
:
:
StyleMozListReversed
mMozListReversed
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStylePosition
{
using
LengthPercentageOrAuto
=
mozilla
:
:
LengthPercentageOrAuto
;
using
Position
=
mozilla
:
:
Position
;
template
<
typename
T
>
using
StyleRect
=
mozilla
:
:
StyleRect
<
T
>
;
using
StyleSize
=
mozilla
:
:
StyleSize
;
using
StyleMaxSize
=
mozilla
:
:
StyleMaxSize
;
using
StyleFlexBasis
=
mozilla
:
:
StyleFlexBasis
;
using
WritingMode
=
mozilla
:
:
WritingMode
;
using
StyleImplicitGridTracks
=
mozilla
:
:
StyleImplicitGridTracks
;
explicit
nsStylePosition
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStylePosition
(
const
nsStylePosition
&
aOther
)
;
~
nsStylePosition
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStylePosition
&
aNewData
const
nsStyleVisibility
&
aOldStyleVisibility
)
const
;
bool
NeedsHypotheticalPositionIfAbsPos
(
)
const
{
return
(
mOffset
.
Get
(
mozilla
:
:
eSideRight
)
.
IsAuto
(
)
&
&
mOffset
.
Get
(
mozilla
:
:
eSideLeft
)
.
IsAuto
(
)
)
|
|
(
mOffset
.
Get
(
mozilla
:
:
eSideTop
)
.
IsAuto
(
)
&
&
mOffset
.
Get
(
mozilla
:
:
eSideBottom
)
.
IsAuto
(
)
)
;
}
uint8_t
UsedAlignSelf
(
mozilla
:
:
ComputedStyle
*
aParent
)
const
;
uint8_t
UsedJustifySelf
(
mozilla
:
:
ComputedStyle
*
aParent
)
const
;
Position
mObjectPosition
;
StyleRect
<
LengthPercentageOrAuto
>
mOffset
;
StyleSize
mWidth
;
StyleSize
mMinWidth
;
StyleMaxSize
mMaxWidth
;
StyleSize
mHeight
;
StyleSize
mMinHeight
;
StyleMaxSize
mMaxHeight
;
StyleFlexBasis
mFlexBasis
;
StyleImplicitGridTracks
mGridAutoColumns
;
StyleImplicitGridTracks
mGridAutoRows
;
float
mAspectRatio
;
uint8_t
mGridAutoFlow
;
mozilla
:
:
StyleBoxSizing
mBoxSizing
;
uint16_t
mAlignContent
;
uint8_t
mAlignItems
;
uint8_t
mAlignSelf
;
uint16_t
mJustifyContent
;
uint8_t
mSpecifiedJustifyItems
;
uint8_t
mJustifyItems
;
uint8_t
mJustifySelf
;
mozilla
:
:
StyleFlexDirection
mFlexDirection
;
mozilla
:
:
StyleFlexWrap
mFlexWrap
;
mozilla
:
:
StyleObjectFit
mObjectFit
;
int32_t
mOrder
;
float
mFlexGrow
;
float
mFlexShrink
;
mozilla
:
:
StyleZIndex
mZIndex
;
mozilla
:
:
StyleGridTemplateComponent
mGridTemplateColumns
;
mozilla
:
:
StyleGridTemplateComponent
mGridTemplateRows
;
mozilla
:
:
StyleGridTemplateAreas
mGridTemplateAreas
;
mozilla
:
:
StyleGridLine
mGridColumnStart
;
mozilla
:
:
StyleGridLine
mGridColumnEnd
;
mozilla
:
:
StyleGridLine
mGridRowStart
;
mozilla
:
:
StyleGridLine
mGridRowEnd
;
mozilla
:
:
NonNegativeLengthPercentageOrNormal
mColumnGap
;
mozilla
:
:
NonNegativeLengthPercentageOrNormal
mRowGap
;
bool
OffsetHasPercent
(
mozilla
:
:
Side
aSide
)
const
{
return
mOffset
.
Get
(
aSide
)
.
HasPercent
(
)
;
}
inline
const
StyleSize
&
ISize
(
WritingMode
)
const
;
inline
const
StyleSize
&
MinISize
(
WritingMode
)
const
;
inline
const
StyleMaxSize
&
MaxISize
(
WritingMode
)
const
;
inline
const
StyleSize
&
BSize
(
WritingMode
)
const
;
inline
const
StyleSize
&
MinBSize
(
WritingMode
)
const
;
inline
const
StyleMaxSize
&
MaxBSize
(
WritingMode
)
const
;
inline
bool
ISizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
MinISizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
MaxISizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
BSizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
MinBSizeDependsOnContainer
(
WritingMode
)
const
;
inline
bool
MaxBSizeDependsOnContainer
(
WritingMode
)
const
;
private
:
template
<
typename
SizeOrMaxSize
>
static
bool
ISizeCoordDependsOnContainer
(
const
SizeOrMaxSize
&
aCoord
)
{
if
(
aCoord
.
IsLengthPercentage
(
)
)
{
return
aCoord
.
AsLengthPercentage
(
)
.
HasPercent
(
)
;
}
if
(
!
aCoord
.
IsExtremumLength
(
)
)
{
return
false
;
}
auto
keyword
=
aCoord
.
AsExtremumLength
(
)
;
return
keyword
=
=
mozilla
:
:
StyleExtremumLength
:
:
MozFitContent
|
|
keyword
=
=
mozilla
:
:
StyleExtremumLength
:
:
MozAvailable
;
}
template
<
typename
SizeOrMaxSize
>
static
bool
BSizeCoordDependsOnContainer
(
const
SizeOrMaxSize
&
aCoord
)
{
return
aCoord
.
IsLengthPercentage
(
)
&
&
aCoord
.
AsLengthPercentage
(
)
.
HasPercent
(
)
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleTextReset
{
explicit
nsStyleTextReset
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleTextReset
(
const
nsStyleTextReset
&
aOther
)
;
~
nsStyleTextReset
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
bool
HasTextDecorationLines
(
)
const
{
return
mTextDecorationLine
!
=
mozilla
:
:
StyleTextDecorationLine
:
:
NONE
&
&
mTextDecorationLine
!
=
mozilla
:
:
StyleTextDecorationLine
:
:
COLOR_OVERRIDE
;
}
nsChangeHint
CalcDifference
(
const
nsStyleTextReset
&
aNewData
)
const
;
mozilla
:
:
StyleTextOverflow
mTextOverflow
;
mozilla
:
:
StyleTextDecorationLine
mTextDecorationLine
;
uint8_t
mTextDecorationStyle
;
uint8_t
mUnicodeBidi
;
nscoord
mInitialLetterSink
;
float
mInitialLetterSize
;
mozilla
:
:
StyleColor
mTextDecorationColor
;
mozilla
:
:
StyleTextDecorationLength
mTextDecorationThickness
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleText
{
explicit
nsStyleText
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleText
(
const
nsStyleText
&
aOther
)
;
~
nsStyleText
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleText
&
aNewData
)
const
;
mozilla
:
:
StyleRGBA
mColor
;
mozilla
:
:
StyleTextTransform
mTextTransform
;
uint8_t
mTextAlign
;
uint8_t
mTextAlignLast
;
mozilla
:
:
StyleTextJustify
mTextJustify
;
mozilla
:
:
StyleWhiteSpace
mWhiteSpace
;
mozilla
:
:
StyleLineBreak
mLineBreak
=
mozilla
:
:
StyleLineBreak
:
:
Auto
;
private
:
mozilla
:
:
StyleWordBreak
mWordBreak
=
mozilla
:
:
StyleWordBreak
:
:
Normal
;
mozilla
:
:
StyleOverflowWrap
mOverflowWrap
=
mozilla
:
:
StyleOverflowWrap
:
:
Normal
;
public
:
mozilla
:
:
StyleHyphens
mHyphens
;
mozilla
:
:
StyleRubyAlign
mRubyAlign
;
mozilla
:
:
StyleRubyPosition
mRubyPosition
;
mozilla
:
:
StyleTextSizeAdjust
mTextSizeAdjust
;
uint8_t
mTextCombineUpright
;
uint8_t
mControlCharacterVisibility
;
uint8_t
mTextEmphasisPosition
;
mozilla
:
:
StyleTextRendering
mTextRendering
;
mozilla
:
:
StyleColor
mTextEmphasisColor
;
mozilla
:
:
StyleColor
mWebkitTextFillColor
;
mozilla
:
:
StyleColor
mWebkitTextStrokeColor
;
mozilla
:
:
StyleNonNegativeLengthOrNumber
mMozTabSize
;
mozilla
:
:
LengthPercentage
mWordSpacing
;
mozilla
:
:
StyleLetterSpacing
mLetterSpacing
;
mozilla
:
:
StyleLineHeight
mLineHeight
;
mozilla
:
:
LengthPercentage
mTextIndent
;
mozilla
:
:
StyleTextDecorationLength
mTextUnderlineOffset
;
mozilla
:
:
StyleTextDecorationSkipInk
mTextDecorationSkipInk
;
mozilla
:
:
StyleTextUnderlinePosition
mTextUnderlinePosition
;
nscoord
mWebkitTextStrokeWidth
;
mozilla
:
:
StyleArcSlice
<
mozilla
:
:
StyleSimpleShadow
>
mTextShadow
;
mozilla
:
:
StyleTextEmphasisStyle
mTextEmphasisStyle
;
mozilla
:
:
StyleWordBreak
EffectiveWordBreak
(
)
const
{
if
(
mWordBreak
=
=
mozilla
:
:
StyleWordBreak
:
:
BreakWord
)
{
return
mozilla
:
:
StyleWordBreak
:
:
Normal
;
}
return
mWordBreak
;
}
mozilla
:
:
StyleOverflowWrap
EffectiveOverflowWrap
(
)
const
{
if
(
mWordBreak
=
=
mozilla
:
:
StyleWordBreak
:
:
BreakWord
)
{
return
mozilla
:
:
StyleOverflowWrap
:
:
Anywhere
;
}
return
mOverflowWrap
;
}
bool
WhiteSpaceIsSignificant
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
BreakSpaces
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreSpace
;
}
bool
NewlineIsSignificantStyle
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
BreakSpaces
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
;
}
bool
WhiteSpaceOrNewlineIsSignificant
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
BreakSpaces
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreSpace
;
}
bool
TabIsSignificant
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Pre
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
BreakSpaces
;
}
bool
WhiteSpaceCanWrapStyle
(
)
const
{
return
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
Normal
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
BreakSpaces
|
|
mWhiteSpace
=
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
;
}
bool
WordCanWrapStyle
(
)
const
{
if
(
!
WhiteSpaceCanWrapStyle
(
)
)
{
return
false
;
}
auto
owrap
=
EffectiveOverflowWrap
(
)
;
return
owrap
=
=
mozilla
:
:
StyleOverflowWrap
:
:
BreakWord
|
|
owrap
=
=
mozilla
:
:
StyleOverflowWrap
:
:
Anywhere
;
}
bool
HasEffectiveTextEmphasis
(
)
const
{
if
(
mTextEmphasisStyle
.
IsNone
(
)
)
{
return
false
;
}
if
(
mTextEmphasisStyle
.
IsString
(
)
&
&
mTextEmphasisStyle
.
AsString
(
)
.
AsString
(
)
.
IsEmpty
(
)
)
{
return
false
;
}
return
true
;
}
bool
HasWebkitTextStroke
(
)
const
{
return
mWebkitTextStrokeWidth
>
0
;
}
bool
HasTextShadow
(
)
const
{
return
!
mTextShadow
.
IsEmpty
(
)
;
}
inline
bool
NewlineIsSignificant
(
const
nsTextFrame
*
aContextFrame
)
const
;
inline
bool
WhiteSpaceCanWrap
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
WordCanWrap
(
const
nsIFrame
*
aContextFrame
)
const
;
mozilla
:
:
LogicalSide
TextEmphasisSide
(
mozilla
:
:
WritingMode
aWM
)
const
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleVisibility
{
explicit
nsStyleVisibility
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleVisibility
(
const
nsStyleVisibility
&
aVisibility
)
;
~
nsStyleVisibility
(
)
{
MOZ_COUNT_DTOR
(
nsStyleVisibility
)
;
}
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleVisibility
&
aNewData
)
const
;
mozilla
:
:
StyleImageOrientation
mImageOrientation
;
uint8_t
mDirection
;
mozilla
:
:
StyleVisibility
mVisible
;
uint8_t
mImageRendering
;
uint8_t
mWritingMode
;
mozilla
:
:
StyleTextOrientation
mTextOrientation
;
mozilla
:
:
StyleColorAdjust
mColorAdjust
;
bool
IsVisible
(
)
const
{
return
mVisible
=
=
mozilla
:
:
StyleVisibility
:
:
Visible
;
}
bool
IsVisibleOrCollapsed
(
)
const
{
return
mVisible
=
=
mozilla
:
:
StyleVisibility
:
:
Visible
|
|
mVisible
=
=
mozilla
:
:
StyleVisibility
:
:
Collapse
;
}
}
;
namespace
mozilla
{
inline
StyleTextTransform
StyleTextTransform
:
:
None
(
)
{
return
StyleTextTransform
{
StyleTextTransformCase
:
:
None
StyleTextTransformOther
(
)
}
;
}
inline
bool
StyleTextTransform
:
:
IsNone
(
)
const
{
return
*
this
=
=
None
(
)
;
}
inline
bool
StyleTextUnderlinePosition
:
:
IsAuto
(
)
const
{
return
*
this
=
=
AUTO
;
}
inline
bool
StyleTextUnderlinePosition
:
:
IsUnder
(
)
const
{
return
bool
(
*
this
&
StyleTextUnderlinePosition
:
:
UNDER
)
;
}
inline
bool
StyleTextUnderlinePosition
:
:
IsLeft
(
)
const
{
return
bool
(
*
this
&
StyleTextUnderlinePosition
:
:
LEFT
)
;
}
inline
bool
StyleTextUnderlinePosition
:
:
IsRight
(
)
const
{
return
bool
(
*
this
&
StyleTextUnderlinePosition
:
:
RIGHT
)
;
}
struct
StyleTransition
{
StyleTransition
(
)
{
}
explicit
StyleTransition
(
const
StyleTransition
&
aCopy
)
;
void
SetInitialValues
(
)
;
const
nsTimingFunction
&
GetTimingFunction
(
)
const
{
return
mTimingFunction
;
}
float
GetDelay
(
)
const
{
return
mDelay
;
}
float
GetDuration
(
)
const
{
return
mDuration
;
}
nsCSSPropertyID
GetProperty
(
)
const
{
return
mProperty
;
}
nsAtom
*
GetUnknownProperty
(
)
const
{
return
mUnknownProperty
;
}
bool
operator
=
=
(
const
StyleTransition
&
aOther
)
const
;
bool
operator
!
=
(
const
StyleTransition
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTimingFunction
mTimingFunction
;
float
mDuration
;
float
mDelay
;
nsCSSPropertyID
mProperty
;
RefPtr
<
nsAtom
>
mUnknownProperty
;
}
;
struct
StyleAnimation
{
StyleAnimation
(
)
{
}
explicit
StyleAnimation
(
const
StyleAnimation
&
aCopy
)
;
void
SetInitialValues
(
)
;
const
nsTimingFunction
&
GetTimingFunction
(
)
const
{
return
mTimingFunction
;
}
float
GetDelay
(
)
const
{
return
mDelay
;
}
float
GetDuration
(
)
const
{
return
mDuration
;
}
nsAtom
*
GetName
(
)
const
{
return
mName
;
}
dom
:
:
PlaybackDirection
GetDirection
(
)
const
{
return
mDirection
;
}
dom
:
:
FillMode
GetFillMode
(
)
const
{
return
mFillMode
;
}
StyleAnimationPlayState
GetPlayState
(
)
const
{
return
mPlayState
;
}
float
GetIterationCount
(
)
const
{
return
mIterationCount
;
}
void
SetName
(
already_AddRefed
<
nsAtom
>
aName
)
{
mName
=
aName
;
}
void
SetName
(
nsAtom
*
aName
)
{
mName
=
aName
;
}
bool
operator
=
=
(
const
StyleAnimation
&
aOther
)
const
;
bool
operator
!
=
(
const
StyleAnimation
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTimingFunction
mTimingFunction
;
float
mDuration
;
float
mDelay
;
RefPtr
<
nsAtom
>
mName
;
dom
:
:
PlaybackDirection
mDirection
;
dom
:
:
FillMode
mFillMode
;
StyleAnimationPlayState
mPlayState
;
float
mIterationCount
;
}
;
struct
StyleSVGPath
final
{
StyleSVGPath
(
StyleForgottenArcSlicePtr
<
StylePathCommand
>
aPath
StyleFillRule
aFill
)
:
mPath
(
aPath
)
mFillRule
(
aFill
)
{
}
Span
<
const
StylePathCommand
>
Path
(
)
const
{
return
mPath
.
AsSpan
(
)
;
}
StyleFillRule
FillRule
(
)
const
{
return
mFillRule
;
}
bool
operator
=
=
(
const
StyleSVGPath
&
aOther
)
const
{
return
mPath
=
=
aOther
.
mPath
&
&
mFillRule
=
=
aOther
.
mFillRule
;
}
bool
operator
!
=
(
const
StyleSVGPath
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
StyleArcSlice
<
StylePathCommand
>
mPath
;
StyleFillRule
mFillRule
=
StyleFillRule
:
:
Nonzero
;
}
;
struct
StyleShapeSource
final
{
StyleShapeSource
(
)
;
StyleShapeSource
(
const
StyleShapeSource
&
aSource
)
;
~
StyleShapeSource
(
)
;
StyleShapeSource
&
operator
=
(
const
StyleShapeSource
&
aOther
)
;
bool
operator
=
=
(
const
StyleShapeSource
&
aOther
)
const
;
bool
operator
!
=
(
const
StyleShapeSource
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
StyleShapeSourceType
GetType
(
)
const
{
return
mType
;
}
const
nsStyleImage
&
ShapeImage
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Image
"
Wrong
shape
source
type
!
"
)
;
MOZ_ASSERT
(
mShapeImage
)
;
return
*
mShapeImage
;
}
imgIRequest
*
GetShapeImageData
(
)
const
;
void
SetShapeImage
(
UniquePtr
<
nsStyleImage
>
aShapeImage
)
;
const
mozilla
:
:
StyleBasicShape
&
BasicShape
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Shape
"
Wrong
shape
source
type
!
"
)
;
MOZ_ASSERT
(
mBasicShape
)
;
return
*
mBasicShape
;
}
void
SetBasicShape
(
UniquePtr
<
mozilla
:
:
StyleBasicShape
>
aBasicShape
StyleGeometryBox
aReferenceBox
)
;
StyleGeometryBox
GetReferenceBox
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Box
|
|
mType
=
=
StyleShapeSourceType
:
:
Shape
"
Wrong
shape
source
type
!
"
)
;
return
mReferenceBox
;
}
void
SetReferenceBox
(
StyleGeometryBox
aReferenceBox
)
;
const
StyleSVGPath
&
Path
(
)
const
{
MOZ_ASSERT
(
mType
=
=
StyleShapeSourceType
:
:
Path
"
Wrong
shape
source
type
!
"
)
;
MOZ_ASSERT
(
mSVGPath
)
;
return
*
mSVGPath
;
}
void
SetPath
(
UniquePtr
<
StyleSVGPath
>
aPath
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
StyleShapeSource
*
aOldShapeSource
)
;
private
:
void
*
operator
new
(
size_t
)
=
delete
;
void
DoCopy
(
const
StyleShapeSource
&
aOther
)
;
void
DoDestroy
(
)
;
union
{
mozilla
:
:
UniquePtr
<
mozilla
:
:
StyleBasicShape
>
mBasicShape
;
mozilla
:
:
UniquePtr
<
nsStyleImage
>
mShapeImage
;
mozilla
:
:
UniquePtr
<
StyleSVGPath
>
mSVGPath
;
}
;
StyleShapeSourceType
mType
=
StyleShapeSourceType
:
:
None
;
StyleGeometryBox
mReferenceBox
=
StyleGeometryBox
:
:
NoBox
;
}
;
}
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleDisplay
{
typedef
mozilla
:
:
StyleGeometryBox
StyleGeometryBox
;
explicit
nsStyleDisplay
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleDisplay
(
const
nsStyleDisplay
&
aOther
)
;
~
nsStyleDisplay
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleDisplay
*
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleDisplay
&
aNewData
const
nsStylePosition
&
aOldPosition
)
const
;
nsStyleAutoArray
<
mozilla
:
:
StyleTransition
>
mTransitions
;
uint32_t
mTransitionTimingFunctionCount
;
uint32_t
mTransitionDurationCount
;
uint32_t
mTransitionDelayCount
;
uint32_t
mTransitionPropertyCount
;
nsStyleAutoArray
<
mozilla
:
:
StyleAnimation
>
mAnimations
;
uint32_t
mAnimationTimingFunctionCount
;
uint32_t
mAnimationDurationCount
;
uint32_t
mAnimationDelayCount
;
uint32_t
mAnimationNameCount
;
uint32_t
mAnimationDirectionCount
;
uint32_t
mAnimationFillModeCount
;
uint32_t
mAnimationPlayStateCount
;
uint32_t
mAnimationIterationCountCount
;
mozilla
:
:
StyleWillChange
mWillChange
;
mozilla
:
:
StyleDisplay
mDisplay
;
mozilla
:
:
StyleDisplay
mOriginalDisplay
;
mozilla
:
:
StyleContain
mContain
;
mozilla
:
:
StyleAppearance
mAppearance
;
uint8_t
mPosition
;
mozilla
:
:
StyleFloat
mFloat
;
mozilla
:
:
StyleClear
mBreakType
;
mozilla
:
:
StyleBreakWithin
mBreakInside
;
mozilla
:
:
StyleBreakBetween
mBreakBefore
;
mozilla
:
:
StyleBreakBetween
mBreakAfter
;
mozilla
:
:
StyleOverflow
mOverflowX
;
mozilla
:
:
StyleOverflow
mOverflowY
;
mozilla
:
:
StyleOverflowClipBox
mOverflowClipBoxBlock
;
mozilla
:
:
StyleOverflowClipBox
mOverflowClipBoxInline
;
mozilla
:
:
StyleResize
mResize
;
mozilla
:
:
StyleOrient
mOrient
;
mozilla
:
:
StyleIsolation
mIsolation
;
mozilla
:
:
StyleTopLayer
mTopLayer
;
mozilla
:
:
StyleTouchAction
mTouchAction
;
uint8_t
mScrollBehavior
;
mozilla
:
:
StyleOverscrollBehavior
mOverscrollBehaviorX
;
mozilla
:
:
StyleOverscrollBehavior
mOverscrollBehaviorY
;
mozilla
:
:
StyleOverflowAnchor
mOverflowAnchor
;
mozilla
:
:
StyleScrollSnapAlign
mScrollSnapAlign
;
mozilla
:
:
StyleScrollSnapType
mScrollSnapType
;
uint32_t
mLineClamp
;
mozilla
:
:
StyleTransform
mTransform
;
mozilla
:
:
StyleRotate
mRotate
;
mozilla
:
:
StyleTranslate
mTranslate
;
mozilla
:
:
StyleScale
mScale
;
uint8_t
mBackfaceVisibility
;
uint8_t
mTransformStyle
;
StyleGeometryBox
mTransformBox
;
mozilla
:
:
StyleOffsetPath
mOffsetPath
;
mozilla
:
:
LengthPercentage
mOffsetDistance
;
mozilla
:
:
StyleOffsetRotate
mOffsetRotate
;
mozilla
:
:
StylePositionOrAuto
mOffsetAnchor
;
mozilla
:
:
StyleTransformOrigin
mTransformOrigin
;
mozilla
:
:
StylePerspective
mChildPerspective
;
mozilla
:
:
Position
mPerspectiveOrigin
;
mozilla
:
:
StyleVerticalAlign
mVerticalAlign
;
nsCSSPropertyID
GetTransitionProperty
(
uint32_t
aIndex
)
const
{
return
mTransitions
[
aIndex
%
mTransitionPropertyCount
]
.
GetProperty
(
)
;
}
float
GetTransitionDelay
(
uint32_t
aIndex
)
const
{
return
mTransitions
[
aIndex
%
mTransitionDelayCount
]
.
GetDelay
(
)
;
}
float
GetTransitionDuration
(
uint32_t
aIndex
)
const
{
return
mTransitions
[
aIndex
%
mTransitionDurationCount
]
.
GetDuration
(
)
;
}
const
nsTimingFunction
&
GetTransitionTimingFunction
(
uint32_t
aIndex
)
const
{
return
mTransitions
[
aIndex
%
mTransitionTimingFunctionCount
]
.
GetTimingFunction
(
)
;
}
float
GetTransitionCombinedDuration
(
uint32_t
aIndex
)
const
{
return
std
:
:
max
(
mTransitions
[
aIndex
%
mTransitionDurationCount
]
.
GetDuration
(
)
0
.
0f
)
+
mTransitions
[
aIndex
%
mTransitionDelayCount
]
.
GetDelay
(
)
;
}
nsAtom
*
GetAnimationName
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationNameCount
]
.
GetName
(
)
;
}
float
GetAnimationDelay
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationDelayCount
]
.
GetDelay
(
)
;
}
float
GetAnimationDuration
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationDurationCount
]
.
GetDuration
(
)
;
}
mozilla
:
:
dom
:
:
PlaybackDirection
GetAnimationDirection
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationDirectionCount
]
.
GetDirection
(
)
;
}
mozilla
:
:
dom
:
:
FillMode
GetAnimationFillMode
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationFillModeCount
]
.
GetFillMode
(
)
;
}
mozilla
:
:
StyleAnimationPlayState
GetAnimationPlayState
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationPlayStateCount
]
.
GetPlayState
(
)
;
}
float
GetAnimationIterationCount
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationIterationCountCount
]
.
GetIterationCount
(
)
;
}
const
nsTimingFunction
&
GetAnimationTimingFunction
(
uint32_t
aIndex
)
const
{
return
mAnimations
[
aIndex
%
mAnimationTimingFunctionCount
]
.
GetTimingFunction
(
)
;
}
float
mShapeImageThreshold
=
0
.
0f
;
mozilla
:
:
NonNegativeLengthPercentage
mShapeMargin
;
mozilla
:
:
StyleShapeSource
mShapeOutside
;
bool
HasAppearance
(
)
const
{
return
mAppearance
!
=
mozilla
:
:
StyleAppearance
:
:
None
;
}
static
mozilla
:
:
StyleDisplayOutside
DisplayOutside
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
mozilla
:
:
StyleDisplayOutside
(
(
uint16_t
(
aDisplay
)
>
>
mozilla
:
:
STYLE_DISPLAY_INSIDE_BITS
)
&
uint16_t
(
(
(
1
<
<
mozilla
:
:
STYLE_DISPLAY_OUTSIDE_BITS
)
-
1
)
)
)
;
}
mozilla
:
:
StyleDisplayOutside
DisplayOutside
(
)
const
{
return
DisplayOutside
(
mDisplay
)
;
}
static
mozilla
:
:
StyleDisplayInside
DisplayInside
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
mozilla
:
:
StyleDisplayInside
(
uint16_t
(
aDisplay
)
&
uint16_t
(
(
(
1
<
<
mozilla
:
:
STYLE_DISPLAY_INSIDE_BITS
)
-
1
)
)
)
;
}
mozilla
:
:
StyleDisplayInside
DisplayInside
(
)
const
{
return
DisplayInside
(
mDisplay
)
;
}
static
bool
IsListItem
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
!
!
(
uint16_t
(
aDisplay
)
&
mozilla
:
:
STYLE_DISPLAY_LIST_ITEM_BIT
)
;
}
bool
IsListItem
(
)
const
{
return
IsListItem
(
mDisplay
)
;
}
static
bool
IsInlineFlow
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
DisplayOutside
(
aDisplay
)
=
=
mozilla
:
:
StyleDisplayOutside
:
:
Inline
&
&
DisplayInside
(
aDisplay
)
=
=
mozilla
:
:
StyleDisplayInside
:
:
Flow
;
}
bool
IsInlineFlow
(
)
const
{
return
IsInlineFlow
(
mDisplay
)
;
}
bool
IsInlineInsideStyle
(
)
const
{
auto
inside
=
DisplayInside
(
)
;
return
IsInlineFlow
(
)
|
|
inside
=
=
mozilla
:
:
StyleDisplayInside
:
:
Ruby
|
|
inside
=
=
mozilla
:
:
StyleDisplayInside
:
:
RubyBase
|
|
inside
=
=
mozilla
:
:
StyleDisplayInside
:
:
RubyBaseContainer
|
|
inside
=
=
mozilla
:
:
StyleDisplayInside
:
:
RubyText
|
|
inside
=
=
mozilla
:
:
StyleDisplayInside
:
:
RubyTextContainer
;
}
bool
IsBlockOutsideStyle
(
)
const
{
return
DisplayOutside
(
)
=
=
mozilla
:
:
StyleDisplayOutside
:
:
Block
;
}
static
bool
IsDisplayTypeInlineOutside
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
auto
outside
=
DisplayOutside
(
aDisplay
)
;
if
(
outside
=
=
mozilla
:
:
StyleDisplayOutside
:
:
Inline
)
{
return
true
;
}
if
(
outside
=
=
mozilla
:
:
StyleDisplayOutside
:
:
Block
)
{
return
false
;
}
return
mozilla
:
:
StyleDisplay
:
:
MozInlineBox
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBase
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyText
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
=
=
aDisplay
;
}
bool
IsInlineOutsideStyle
(
)
const
{
return
IsDisplayTypeInlineOutside
(
mDisplay
)
;
}
bool
IsOriginalDisplayInlineOutside
(
)
const
{
return
IsDisplayTypeInlineOutside
(
mOriginalDisplay
)
;
}
bool
IsInnerTableStyle
(
)
const
{
return
DisplayOutside
(
)
=
=
mozilla
:
:
StyleDisplayOutside
:
:
InternalTable
;
}
bool
IsInternalTableStyleExceptCell
(
)
const
{
return
IsInnerTableStyle
(
)
&
&
mozilla
:
:
StyleDisplay
:
:
TableCell
!
=
mDisplay
;
}
bool
IsFloatingStyle
(
)
const
{
return
mozilla
:
:
StyleFloat
:
:
None
!
=
mFloat
;
}
bool
IsAbsolutelyPositionedStyle
(
)
const
{
return
NS_STYLE_POSITION_ABSOLUTE
=
=
mPosition
|
|
NS_STYLE_POSITION_FIXED
=
=
mPosition
;
}
bool
IsRelativelyPositionedStyle
(
)
const
{
return
NS_STYLE_POSITION_RELATIVE
=
=
mPosition
|
|
NS_STYLE_POSITION_STICKY
=
=
mPosition
;
}
bool
IsStickyPositionedStyle
(
)
const
{
return
NS_STYLE_POSITION_STICKY
=
=
mPosition
;
}
bool
IsPositionForcingStackingContext
(
)
const
{
return
NS_STYLE_POSITION_STICKY
=
=
mPosition
|
|
NS_STYLE_POSITION_FIXED
=
=
mPosition
;
}
static
bool
IsRubyDisplayType
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
DisplayInside
(
aDisplay
)
=
=
mozilla
:
:
StyleDisplayInside
:
:
Ruby
|
|
IsInternalRubyDisplayType
(
aDisplay
)
;
}
static
bool
IsInternalRubyDisplayType
(
mozilla
:
:
StyleDisplay
aDisplay
)
{
return
mozilla
:
:
StyleDisplay
:
:
RubyBase
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyBaseContainer
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyText
=
=
aDisplay
|
|
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
=
=
aDisplay
;
}
bool
IsRubyDisplayType
(
)
const
{
return
IsRubyDisplayType
(
mDisplay
)
;
}
bool
IsInternalRubyDisplayType
(
)
const
{
return
IsInternalRubyDisplayType
(
mDisplay
)
;
}
bool
IsOutOfFlowStyle
(
)
const
{
return
(
IsAbsolutelyPositionedStyle
(
)
|
|
IsFloatingStyle
(
)
)
;
}
bool
IsScrollableOverflow
(
)
const
{
return
mOverflowX
!
=
mozilla
:
:
StyleOverflow
:
:
Visible
&
&
mOverflowX
!
=
mozilla
:
:
StyleOverflow
:
:
MozHiddenUnscrollable
;
}
bool
IsContainPaint
(
)
const
{
return
(
mContain
&
mozilla
:
:
StyleContain
:
:
PAINT
)
&
&
!
IsInternalRubyDisplayType
(
)
&
&
!
IsInternalTableStyleExceptCell
(
)
;
}
bool
IsContainLayout
(
)
const
{
return
(
mContain
&
mozilla
:
:
StyleContain
:
:
LAYOUT
)
&
&
!
IsInternalRubyDisplayType
(
)
&
&
!
IsInternalTableStyleExceptCell
(
)
;
}
bool
IsContainSize
(
)
const
{
return
(
mContain
&
mozilla
:
:
StyleContain
:
:
SIZE
)
&
&
!
IsInternalRubyDisplayType
(
)
&
&
DisplayInside
(
)
!
=
mozilla
:
:
StyleDisplayInside
:
:
Table
&
&
!
IsInnerTableStyle
(
)
;
}
bool
HasTransformStyle
(
)
const
{
return
HasTransformProperty
(
)
|
|
HasIndividualTransform
(
)
|
|
mTransformStyle
=
=
NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D
|
|
(
mWillChange
.
bits
&
mozilla
:
:
StyleWillChangeBits
:
:
TRANSFORM
)
|
|
!
mOffsetPath
.
IsNone
(
)
;
}
bool
HasTransformProperty
(
)
const
{
return
!
mTransform
.
_0
.
IsEmpty
(
)
;
}
bool
HasIndividualTransform
(
)
const
{
return
!
mRotate
.
IsNone
(
)
|
|
!
mTranslate
.
IsNone
(
)
|
|
!
mScale
.
IsNone
(
)
;
}
bool
HasPerspectiveStyle
(
)
const
{
return
!
mChildPerspective
.
IsNone
(
)
;
}
bool
BackfaceIsHidden
(
)
const
{
return
mBackfaceVisibility
=
=
NS_STYLE_BACKFACE_VISIBILITY_HIDDEN
;
}
static
bool
ShouldBreak
(
mozilla
:
:
StyleBreakBetween
aBreak
)
{
switch
(
aBreak
)
{
case
mozilla
:
:
StyleBreakBetween
:
:
Left
:
case
mozilla
:
:
StyleBreakBetween
:
:
Right
:
case
mozilla
:
:
StyleBreakBetween
:
:
Page
:
case
mozilla
:
:
StyleBreakBetween
:
:
Always
:
return
true
;
case
mozilla
:
:
StyleBreakBetween
:
:
Auto
:
case
mozilla
:
:
StyleBreakBetween
:
:
Avoid
:
return
false
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
break
kind
"
)
;
return
false
;
}
}
bool
BreakBefore
(
)
const
{
return
ShouldBreak
(
mBreakBefore
)
;
}
bool
BreakAfter
(
)
const
{
return
ShouldBreak
(
mBreakAfter
)
;
}
inline
bool
IsBlockOutside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsInlineOutside
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
mozilla
:
:
StyleDisplay
GetDisplay
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsFloating
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsRelativelyPositioned
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsStickyPositioned
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsAbsolutelyPositioned
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
HasTransform
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
HasPerspective
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsAbsPosContainingBlock
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsAbsPosContainingBlockForNonSVGTextFrames
(
)
const
;
inline
bool
IsFixedPosContainingBlock
(
const
nsIFrame
*
aContextFrame
)
const
;
inline
bool
IsFixedPosContainingBlockForNonSVGTextFrames
(
const
mozilla
:
:
ComputedStyle
&
)
const
;
inline
bool
IsFixedPosContainingBlockForContainLayoutAndPaintSupportingFrames
(
)
const
;
inline
bool
IsFixedPosContainingBlockForTransformSupportingFrames
(
)
const
;
void
GenerateCombinedIndividualTransform
(
)
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleTable
{
explicit
nsStyleTable
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleTable
(
const
nsStyleTable
&
aOther
)
;
~
nsStyleTable
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleTable
&
aNewData
)
const
;
uint8_t
mLayoutStrategy
;
int32_t
mXSpan
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleTableBorder
{
explicit
nsStyleTableBorder
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleTableBorder
(
const
nsStyleTableBorder
&
aOther
)
;
~
nsStyleTableBorder
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleTableBorder
&
aNewData
)
const
;
nscoord
mBorderSpacingCol
;
nscoord
mBorderSpacingRow
;
mozilla
:
:
StyleBorderCollapse
mBorderCollapse
;
uint8_t
mCaptionSide
;
uint8_t
mEmptyCells
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleContent
{
using
CounterPair
=
mozilla
:
:
StyleGenericCounterPair
<
int32_t
>
;
explicit
nsStyleContent
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleContent
(
const
nsStyleContent
&
aContent
)
;
~
nsStyleContent
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
size_t
ContentCount
(
)
const
{
return
mContent
.
IsItems
(
)
?
mContent
.
AsItems
(
)
.
Length
(
)
:
0
;
}
const
mozilla
:
:
StyleContentItem
&
ContentAt
(
size_t
aIndex
)
const
{
return
mContent
.
AsItems
(
)
.
AsSpan
(
)
[
aIndex
]
;
}
nsChangeHint
CalcDifference
(
const
nsStyleContent
&
aNewData
)
const
;
mozilla
:
:
StyleContent
mContent
;
mozilla
:
:
StyleCounterIncrement
mCounterIncrement
;
mozilla
:
:
StyleCounterSetOrReset
mCounterReset
;
mozilla
:
:
StyleCounterSetOrReset
mCounterSet
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleUIReset
{
explicit
nsStyleUIReset
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleUIReset
(
const
nsStyleUIReset
&
aOther
)
;
~
nsStyleUIReset
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleUIReset
&
aNewData
)
const
;
mozilla
:
:
StyleUserSelect
mUserSelect
;
mozilla
:
:
StyleScrollbarWidth
mScrollbarWidth
;
uint8_t
mForceBrokenImageIcon
;
mozilla
:
:
StyleImeMode
mIMEMode
;
mozilla
:
:
StyleWindowDragging
mWindowDragging
;
mozilla
:
:
StyleWindowShadow
mWindowShadow
;
float
mWindowOpacity
;
mozilla
:
:
StyleTransform
mMozWindowTransform
;
mozilla
:
:
StyleTransformOrigin
mWindowTransformOrigin
;
}
;
struct
nsCursorImage
{
bool
mHaveHotspot
;
float
mHotspotX
mHotspotY
;
RefPtr
<
nsStyleImageRequest
>
mImage
;
nsCursorImage
(
)
;
nsCursorImage
(
const
nsCursorImage
&
aOther
)
;
nsCursorImage
&
operator
=
(
const
nsCursorImage
&
aOther
)
;
bool
operator
=
=
(
const
nsCursorImage
&
aOther
)
const
;
bool
operator
!
=
(
const
nsCursorImage
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
imgRequestProxy
*
GetImage
(
)
const
{
return
mImage
-
>
get
(
)
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleUI
{
explicit
nsStyleUI
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleUI
(
const
nsStyleUI
&
aOther
)
;
~
nsStyleUI
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleUI
*
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleUI
&
aNewData
)
const
;
mozilla
:
:
StyleUserInput
mUserInput
;
mozilla
:
:
StyleUserModify
mUserModify
;
mozilla
:
:
StyleUserFocus
mUserFocus
;
mozilla
:
:
StylePointerEvents
mPointerEvents
;
mozilla
:
:
StyleCursorKind
mCursor
;
nsTArray
<
nsCursorImage
>
mCursorImages
;
mozilla
:
:
StyleColorOrAuto
mCaretColor
;
mozilla
:
:
StyleScrollbarColor
mScrollbarColor
;
inline
mozilla
:
:
StylePointerEvents
GetEffectivePointerEvents
(
nsIFrame
*
aFrame
)
const
;
bool
HasCustomScrollbars
(
)
const
{
return
!
mScrollbarColor
.
IsAuto
(
)
;
}
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleXUL
{
explicit
nsStyleXUL
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleXUL
(
const
nsStyleXUL
&
aSource
)
;
~
nsStyleXUL
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleXUL
&
aNewData
)
const
;
float
mBoxFlex
;
int32_t
mBoxOrdinal
;
mozilla
:
:
StyleBoxAlign
mBoxAlign
;
mozilla
:
:
StyleBoxDirection
mBoxDirection
;
mozilla
:
:
StyleBoxOrient
mBoxOrient
;
mozilla
:
:
StyleBoxPack
mBoxPack
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleColumn
{
explicit
nsStyleColumn
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleColumn
(
const
nsStyleColumn
&
aSource
)
;
~
nsStyleColumn
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleColumn
&
aNewData
)
const
;
static
const
uint32_t
kMaxColumnCount
=
1000
;
static
const
uint32_t
kColumnCountAuto
=
0
;
uint32_t
mColumnCount
=
kColumnCountAuto
;
mozilla
:
:
NonNegativeLengthOrAuto
mColumnWidth
;
mozilla
:
:
StyleColor
mColumnRuleColor
;
mozilla
:
:
StyleBorderStyle
mColumnRuleStyle
;
mozilla
:
:
StyleColumnFill
mColumnFill
=
mozilla
:
:
StyleColumnFill
:
:
Balance
;
mozilla
:
:
StyleColumnSpan
mColumnSpan
=
mozilla
:
:
StyleColumnSpan
:
:
None
;
nscoord
GetComputedColumnRuleWidth
(
)
const
{
return
(
IsVisibleBorderStyle
(
mColumnRuleStyle
)
?
mColumnRuleWidth
:
0
)
;
}
bool
IsColumnContainerStyle
(
)
const
{
return
mColumnCount
!
=
kColumnCountAuto
|
|
!
mColumnWidth
.
IsAuto
(
)
;
}
bool
IsColumnSpanStyle
(
)
const
{
return
mColumnSpan
=
=
mozilla
:
:
StyleColumnSpan
:
:
All
;
}
protected
:
nscoord
mColumnRuleWidth
;
nscoord
mTwipsPerPixel
;
}
;
enum
nsStyleSVGOpacitySource
:
uint8_t
{
eStyleSVGOpacitySource_Normal
eStyleSVGOpacitySource_ContextFillOpacity
eStyleSVGOpacitySource_ContextStrokeOpacity
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleSVG
{
explicit
nsStyleSVG
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleSVG
(
const
nsStyleSVG
&
aSource
)
;
~
nsStyleSVG
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleSVG
&
aNewData
)
const
;
mozilla
:
:
StyleSVGPaint
mFill
;
mozilla
:
:
StyleSVGPaint
mStroke
;
mozilla
:
:
StyleUrlOrNone
mMarkerEnd
;
mozilla
:
:
StyleUrlOrNone
mMarkerMid
;
mozilla
:
:
StyleUrlOrNone
mMarkerStart
;
nsTArray
<
mozilla
:
:
NonNegativeLengthPercentage
>
mStrokeDasharray
;
mozilla
:
:
StyleMozContextProperties
mMozContextProperties
;
mozilla
:
:
LengthPercentage
mStrokeDashoffset
;
mozilla
:
:
NonNegativeLengthPercentage
mStrokeWidth
;
float
mFillOpacity
;
float
mStrokeMiterlimit
;
float
mStrokeOpacity
;
mozilla
:
:
StyleFillRule
mClipRule
;
uint8_t
mColorInterpolation
;
uint8_t
mColorInterpolationFilters
;
mozilla
:
:
StyleFillRule
mFillRule
;
mozilla
:
:
StyleSVGPaintOrder
mPaintOrder
;
mozilla
:
:
StyleShapeRendering
mShapeRendering
;
mozilla
:
:
StyleStrokeLinecap
mStrokeLinecap
;
mozilla
:
:
StyleStrokeLinejoin
mStrokeLinejoin
;
uint8_t
mDominantBaseline
;
mozilla
:
:
StyleTextAnchor
mTextAnchor
;
bool
ExposesContextProperties
(
)
const
{
return
bool
(
mMozContextProperties
.
bits
)
;
}
nsStyleSVGOpacitySource
FillOpacitySource
(
)
const
{
uint8_t
value
=
(
mContextFlags
&
FILL_OPACITY_SOURCE_MASK
)
>
>
FILL_OPACITY_SOURCE_SHIFT
;
return
nsStyleSVGOpacitySource
(
value
)
;
}
nsStyleSVGOpacitySource
StrokeOpacitySource
(
)
const
{
uint8_t
value
=
(
mContextFlags
&
STROKE_OPACITY_SOURCE_MASK
)
>
>
STROKE_OPACITY_SOURCE_SHIFT
;
return
nsStyleSVGOpacitySource
(
value
)
;
}
bool
StrokeDasharrayFromObject
(
)
const
{
return
mContextFlags
&
STROKE_DASHARRAY_CONTEXT
;
}
bool
StrokeDashoffsetFromObject
(
)
const
{
return
mContextFlags
&
STROKE_DASHOFFSET_CONTEXT
;
}
bool
StrokeWidthFromObject
(
)
const
{
return
mContextFlags
&
STROKE_WIDTH_CONTEXT
;
}
bool
HasMarker
(
)
const
{
return
mMarkerStart
.
IsUrl
(
)
|
|
mMarkerMid
.
IsUrl
(
)
|
|
mMarkerEnd
.
IsUrl
(
)
;
}
bool
HasStroke
(
)
const
{
return
!
mStroke
.
kind
.
IsNone
(
)
&
&
mStrokeOpacity
>
0
;
}
bool
HasFill
(
)
const
{
return
!
mFill
.
kind
.
IsNone
(
)
&
&
mFillOpacity
>
0
;
}
private
:
static
const
uint8_t
FILL_OPACITY_SOURCE_MASK
=
0x03
;
static
const
uint8_t
STROKE_OPACITY_SOURCE_MASK
=
0x0C
;
static
const
uint8_t
STROKE_DASHARRAY_CONTEXT
=
0x10
;
static
const
uint8_t
STROKE_DASHOFFSET_CONTEXT
=
0x20
;
static
const
uint8_t
STROKE_WIDTH_CONTEXT
=
0x40
;
static
const
uint8_t
FILL_OPACITY_SOURCE_SHIFT
=
0
;
static
const
uint8_t
STROKE_OPACITY_SOURCE_SHIFT
=
2
;
uint8_t
mContextFlags
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleSVGReset
{
explicit
nsStyleSVGReset
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleSVGReset
(
const
nsStyleSVGReset
&
aSource
)
;
~
nsStyleSVGReset
(
)
;
void
TriggerImageLoads
(
mozilla
:
:
dom
:
:
Document
&
const
nsStyleSVGReset
*
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
true
;
nsChangeHint
CalcDifference
(
const
nsStyleSVGReset
&
aNewData
)
const
;
bool
HasClipPath
(
)
const
{
return
mClipPath
.
GetType
(
)
!
=
mozilla
:
:
StyleShapeSourceType
:
:
None
;
}
bool
HasMask
(
)
const
;
bool
HasNonScalingStroke
(
)
const
{
return
mVectorEffect
=
=
NS_STYLE_VECTOR_EFFECT_NON_SCALING_STROKE
;
}
mozilla
:
:
LengthPercentage
mX
;
mozilla
:
:
LengthPercentage
mY
;
mozilla
:
:
LengthPercentage
mCx
;
mozilla
:
:
LengthPercentage
mCy
;
mozilla
:
:
NonNegativeLengthPercentageOrAuto
mRx
;
mozilla
:
:
NonNegativeLengthPercentageOrAuto
mRy
;
mozilla
:
:
NonNegativeLengthPercentage
mR
;
nsStyleImageLayers
mMask
;
mozilla
:
:
StyleShapeSource
mClipPath
;
mozilla
:
:
StyleColor
mStopColor
;
mozilla
:
:
StyleColor
mFloodColor
;
mozilla
:
:
StyleColor
mLightingColor
;
float
mStopOpacity
;
float
mFloodOpacity
;
uint8_t
mVectorEffect
;
uint8_t
mMaskType
;
}
;
struct
MOZ_NEEDS_MEMMOVABLE_MEMBERS
nsStyleEffects
{
explicit
nsStyleEffects
(
const
mozilla
:
:
dom
:
:
Document
&
)
;
nsStyleEffects
(
const
nsStyleEffects
&
aSource
)
;
~
nsStyleEffects
(
)
;
static
constexpr
bool
kHasTriggerImageLoads
=
false
;
nsChangeHint
CalcDifference
(
const
nsStyleEffects
&
aNewData
)
const
;
bool
HasFilters
(
)
const
{
return
!
mFilters
.
IsEmpty
(
)
;
}
bool
HasBackdropFilters
(
)
const
{
return
!
mBackdropFilters
.
IsEmpty
(
)
;
}
bool
HasBoxShadowWithInset
(
bool
aInset
)
const
{
for
(
auto
&
shadow
:
mBoxShadow
.
AsSpan
(
)
)
{
if
(
shadow
.
inset
=
=
aInset
)
{
return
true
;
}
}
return
false
;
}
bool
HasMixBlendMode
(
)
const
{
return
mMixBlendMode
!
=
NS_STYLE_BLEND_NORMAL
;
}
mozilla
:
:
StyleOwnedSlice
<
mozilla
:
:
StyleFilter
>
mFilters
;
mozilla
:
:
StyleOwnedSlice
<
mozilla
:
:
StyleBoxShadow
>
mBoxShadow
;
mozilla
:
:
StyleOwnedSlice
<
mozilla
:
:
StyleFilter
>
mBackdropFilters
;
mozilla
:
:
StyleClipRectOrAuto
mClip
;
float
mOpacity
;
uint8_t
mMixBlendMode
;
}
;
#
define
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
T1
T2
)
\
static_assert
(
sizeof
(
T1
)
=
=
sizeof
(
T2
)
\
"
Size
mismatch
between
"
#
T1
"
and
"
#
T2
)
;
\
static_assert
(
alignof
(
T1
)
=
=
alignof
(
T2
)
\
"
Align
mismatch
between
"
#
T1
"
and
"
#
T2
)
;
#
define
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
T1
T2
field
)
\
static_assert
(
offsetof
(
T1
field
)
=
=
offsetof
(
T2
field
)
\
"
Field
offset
mismatch
of
"
#
field
"
between
"
#
T1
\
"
and
"
#
T2
)
;
/
*
*
*
These
*
_Simple
types
are
used
to
map
Gecko
types
to
layout
-
equivalent
but
*
simpler
Rust
types
to
aid
Rust
binding
generation
.
*
*
If
something
in
this
types
or
the
assertions
below
needs
to
change
ask
*
bholley
heycam
or
emilio
before
!
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsPoint
"
>
*
/
struct
nsPoint_Simple
{
nscoord
x
y
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsPoint
nsPoint_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsPoint
nsPoint_Simple
x
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsPoint
nsPoint_Simple
y
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsMargin
"
>
*
/
struct
nsMargin_Simple
{
nscoord
top
right
bottom
left
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsMargin
nsMargin_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
top
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
right
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
bottom
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsMargin
nsMargin_Simple
left
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsRect
"
>
*
/
struct
nsRect_Simple
{
nscoord
x
y
width
height
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsRect
nsRect_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
x
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
y
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
width
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsRect
nsRect_Simple
height
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
nsSize
"
>
*
/
struct
nsSize_Simple
{
nscoord
width
height
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsSize
nsSize_Simple
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsSize
nsSize_Simple
width
)
;
STATIC_ASSERT_FIELD_OFFSET_MATCHES
(
nsSize
nsSize_Simple
height
)
;
/
*
*
*
<
div
rustbindgen
=
"
true
"
replaces
=
"
mozilla
:
:
UniquePtr
"
>
*
*
TODO
(
Emilio
)
:
This
is
a
workaround
and
we
should
be
able
to
get
rid
of
this
*
one
.
*
/
template
<
typename
T
>
struct
UniquePtr_Simple
{
T
*
mPtr
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
mozilla
:
:
UniquePtr
<
int
>
UniquePtr_Simple
<
int
>
)
;
/
*
*
*
<
div
rustbindgen
replaces
=
"
nsTArray
"
>
<
/
div
>
*
/
template
<
typename
T
>
class
nsTArray_Simple
{
T
*
mBuffer
;
public
:
~
nsTArray_Simple
(
)
{
}
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsTArray
<
nsStyleImageLayers
:
:
Layer
>
nsTArray_Simple
<
nsStyleImageLayers
:
:
Layer
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsTArray
<
mozilla
:
:
StyleTransition
>
nsTArray_Simple
<
mozilla
:
:
StyleTransition
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsTArray
<
mozilla
:
:
StyleAnimation
>
nsTArray_Simple
<
mozilla
:
:
StyleAnimation
>
)
;
/
*
*
*
<
div
rustbindgen
replaces
=
"
nsCOMArray
"
>
<
/
div
>
*
*
mozilla
:
:
ArrayIterator
doesn
'
t
work
well
with
bindgen
.
*
/
template
<
typename
T
>
class
nsCOMArray_Simple
{
nsTArray
<
nsISupports
*
>
mBuffer
;
}
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsCOMArray
<
nsIContent
>
nsCOMArray_Simple
<
nsIContent
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsCOMArray
<
nsINode
>
nsCOMArray_Simple
<
nsINode
>
)
;
STATIC_ASSERT_TYPE_LAYOUTS_MATCH
(
nsCOMArray
<
imgIContainer
>
nsCOMArray_Simple
<
imgIContainer
>
)
;
#
endif
