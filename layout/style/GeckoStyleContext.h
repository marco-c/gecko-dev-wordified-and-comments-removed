#
ifndef
mozilla_GeckoStyleContext_h
#
define
mozilla_GeckoStyleContext_h
#
include
"
nsStyleContext
.
h
"
namespace
mozilla
{
class
GeckoStyleContext
final
:
public
nsStyleContext
{
public
:
static
already_AddRefed
<
GeckoStyleContext
>
TakeRef
(
already_AddRefed
<
nsStyleContext
>
aStyleContext
)
{
auto
*
context
=
aStyleContext
.
take
(
)
;
MOZ_ASSERT
(
context
)
;
return
already_AddRefed
<
GeckoStyleContext
>
(
context
-
>
AsGecko
(
)
)
;
}
GeckoStyleContext
(
GeckoStyleContext
*
aParent
nsAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
already_AddRefed
<
nsRuleNode
>
aRuleNode
bool
aSkipParentDisplayBasedStyleFixup
)
;
void
*
operator
new
(
size_t
sz
nsPresContext
*
aPresContext
)
;
nsPresContext
*
PresContext
(
)
const
{
return
RuleNode
(
)
-
>
PresContext
(
)
;
}
void
AddChild
(
GeckoStyleContext
*
aChild
)
;
void
RemoveChild
(
GeckoStyleContext
*
aChild
)
;
GeckoStyleContext
*
GetParent
(
)
const
{
return
mParent
;
}
bool
IsLinkContext
(
)
const
{
return
GetStyleIfVisited
(
)
&
&
GetStyleIfVisited
(
)
-
>
GetParent
(
)
=
=
GetParent
(
)
;
}
void
MoveTo
(
GeckoStyleContext
*
aNewParent
)
;
void
*
GetUniqueStyleData
(
const
nsStyleStructID
&
aSID
)
;
void
*
CreateEmptyStyleData
(
const
nsStyleStructID
&
aSID
)
;
void
SetStyleIfVisited
(
already_AddRefed
<
GeckoStyleContext
>
aStyleIfVisited
)
;
GeckoStyleContext
*
GetStyleIfVisited
(
)
const
{
return
mStyleIfVisited
;
}
;
#
ifdef
DEBUG
static
void
Initialize
(
)
;
#
endif
void
EnsureSameStructsCached
(
nsStyleContext
*
aOldContext
)
;
void
SetIneligibleForSharing
(
)
;
void
ClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
;
already_AddRefed
<
GeckoStyleContext
>
FindChildWithRules
(
const
nsAtom
*
aPseudoTag
nsRuleNode
*
aSource
nsRuleNode
*
aSourceIfVisited
bool
aRelevantLinkVisited
)
;
void
SetStyle
(
nsStyleStructID
aSID
void
*
aStruct
)
;
const
void
*
NS_FASTCALL
StyleData
(
nsStyleStructID
aSID
)
MOZ_NONNULL_RETURN
;
#
ifdef
DEBUG
void
ListDescendants
(
FILE
*
out
int32_t
aIndent
)
;
#
endif
#
ifdef
RESTYLE_LOGGING
bool
ShouldLogRestyle
(
)
{
return
true
;
}
void
LogStyleContextTree
(
int32_t
aLoggingDepth
uint32_t
aStructs
)
;
void
LogStyleContextTree
(
bool
aFirst
uint32_t
aStructs
)
;
int32_t
&
LoggingDepth
(
)
;
nsCString
GetCachedStyleDataAsString
(
uint32_t
aStructs
)
;
#
endif
void
ApplyStyleFixups
(
bool
aSkipParentDisplayBasedStyleFixup
)
;
bool
HasNoChildren
(
)
const
;
nsRuleNode
*
RuleNode
(
)
const
{
MOZ_ASSERT
(
mRuleNode
)
;
return
mRuleNode
;
}
bool
HasSingleReference
(
)
const
{
NS_ASSERTION
(
mRefCnt
!
=
0
"
do
not
call
HasSingleReference
on
a
newly
created
"
"
nsStyleContext
with
no
references
yet
"
)
;
return
mRefCnt
=
=
1
;
}
void
AddRef
(
)
{
if
(
mRefCnt
=
=
UINT32_MAX
)
{
NS_WARNING
(
"
refcount
overflow
leaking
object
"
)
;
return
;
}
+
+
mRefCnt
;
NS_LOG_ADDREF
(
this
mRefCnt
"
nsStyleContext
"
sizeof
(
nsStyleContext
)
)
;
return
;
}
void
Release
(
)
{
if
(
mRefCnt
=
=
UINT32_MAX
)
{
NS_WARNING
(
"
refcount
overflow
leaking
object
"
)
;
return
;
}
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
mRefCnt
"
nsStyleContext
"
)
;
if
(
mRefCnt
=
=
0
)
{
Destroy
(
)
;
return
;
}
return
;
}
~
GeckoStyleContext
(
)
;
void
SwapStyleData
(
GeckoStyleContext
*
aNewContext
uint32_t
aStructs
)
;
void
DestroyCachedStructs
(
nsPresContext
*
aPresContext
)
;
const
void
*
GetCachedStyleData
(
nsStyleStructID
aSID
)
{
const
void
*
cachedData
;
if
(
nsCachedStyleData
:
:
IsReset
(
aSID
)
)
{
if
(
mCachedResetData
)
{
cachedData
=
mCachedResetData
-
>
mStyleStructs
[
aSID
]
;
}
else
{
cachedData
=
nullptr
;
}
}
else
{
cachedData
=
mCachedInheritedData
.
mStyleStructs
[
aSID
]
;
}
return
cachedData
;
}
nsResetStyleData
*
mCachedResetData
;
nsInheritedStyleData
mCachedInheritedData
;
uint32_t
mRefCnt
;
#
ifdef
DEBUG
void
AssertStructsNotUsedElsewhere
(
GeckoStyleContext
*
aDestroyingContext
int32_t
aLevels
)
const
;
#
endif
private
:
void
DoClearCachedInheritedStyleDataOnDescendants
(
uint32_t
aStructs
)
;
void
Destroy
(
)
;
void
SetStyleBits
(
)
;
void
FinishConstruction
(
)
;
GeckoStyleContext
*
mChild
;
GeckoStyleContext
*
mEmptyChild
;
GeckoStyleContext
*
mPrevSibling
;
GeckoStyleContext
*
mNextSibling
;
RefPtr
<
nsRuleNode
>
mRuleNode
;
RefPtr
<
GeckoStyleContext
>
mParent
;
RefPtr
<
GeckoStyleContext
>
mStyleIfVisited
;
#
ifdef
DEBUG
public
:
struct
AutoCheckDependency
{
GeckoStyleContext
*
mStyleContext
;
nsStyleStructID
mOuterSID
;
AutoCheckDependency
(
GeckoStyleContext
*
aContext
nsStyleStructID
aInnerSID
)
:
mStyleContext
(
aContext
)
{
mOuterSID
=
aContext
-
>
mComputingStruct
;
MOZ_ASSERT
(
mOuterSID
=
=
nsStyleStructID_None
|
|
DependencyAllowed
(
mOuterSID
aInnerSID
)
"
Undeclared
dependency
see
generate
-
stylestructlist
.
py
"
)
;
aContext
-
>
mComputingStruct
=
aInnerSID
;
}
~
AutoCheckDependency
(
)
{
mStyleContext
-
>
mComputingStruct
=
mOuterSID
;
}
}
;
void
FrameAddRef
(
)
{
+
+
mFrameRefCnt
;
}
void
FrameRelease
(
)
{
-
-
mFrameRefCnt
;
}
uint32_t
FrameRefCnt
(
)
const
{
return
mFrameRefCnt
;
}
private
:
nsStyleStructID
mComputingStruct
;
uint32_t
mFrameRefCnt
;
#
define
AUTO_CHECK_DEPENDENCY
(
gecko_
sid_
)
\
mozilla
:
:
GeckoStyleContext
:
:
AutoCheckDependency
checkNesting_
(
gecko_
sid_
)
#
else
#
define
AUTO_CHECK_DEPENDENCY
(
gecko_
sid_
)
#
endif
}
;
}
#
endif
