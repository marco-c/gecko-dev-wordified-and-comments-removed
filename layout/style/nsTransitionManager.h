#
ifndef
nsTransitionManager_h_
#
define
nsTransitionManager_h_
#
include
"
mozilla
/
ComputedTiming
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectReadOnly
.
h
"
#
include
"
AnimationCommon
.
h
"
#
include
"
nsCSSProps
.
h
"
class
nsIGlobalObject
;
class
nsStyleContext
;
class
nsPresContext
;
class
nsCSSPropertyIDSet
;
namespace
mozilla
{
enum
class
CSSPseudoElementType
:
uint8_t
;
class
GeckoStyleContext
;
struct
Keyframe
;
struct
StyleTransition
;
class
ServoStyleContext
;
}
namespace
mozilla
{
struct
ElementPropertyTransition
:
public
dom
:
:
KeyframeEffectReadOnly
{
ElementPropertyTransition
(
nsIDocument
*
aDocument
Maybe
<
OwningAnimationTarget
>
&
aTarget
const
TimingParams
&
aTiming
AnimationValue
aStartForReversingTest
double
aReversePortion
const
KeyframeEffectParams
&
aEffectOptions
)
:
dom
:
:
KeyframeEffectReadOnly
(
aDocument
aTarget
aTiming
aEffectOptions
)
mStartForReversingTest
(
aStartForReversingTest
)
mReversePortion
(
aReversePortion
)
{
}
ElementPropertyTransition
*
AsTransition
(
)
override
{
return
this
;
}
const
ElementPropertyTransition
*
AsTransition
(
)
const
override
{
return
this
;
}
nsCSSPropertyID
TransitionProperty
(
)
const
{
MOZ_ASSERT
(
mKeyframes
.
Length
(
)
=
=
2
"
Transitions
should
have
exactly
two
animation
keyframes
.
"
"
Perhaps
we
are
using
an
un
-
initialized
transition
?
"
)
;
MOZ_ASSERT
(
mKeyframes
[
0
]
.
mPropertyValues
.
Length
(
)
=
=
1
"
Transitions
should
have
exactly
one
property
in
their
first
"
"
frame
"
)
;
return
mKeyframes
[
0
]
.
mPropertyValues
[
0
]
.
mProperty
;
}
AnimationValue
ToValue
(
)
const
{
if
(
mProperties
.
Length
(
)
<
1
|
|
mProperties
[
0
]
.
mSegments
.
Length
(
)
<
1
)
{
NS_WARNING
(
"
Failed
to
generate
transition
property
values
"
)
;
return
AnimationValue
(
)
;
}
return
mProperties
[
0
]
.
mSegments
[
0
]
.
mToValue
;
}
AnimationValue
mStartForReversingTest
;
double
mReversePortion
;
double
CurrentValuePortion
(
)
const
;
void
UpdateStartValueFromReplacedTransition
(
)
;
struct
ReplacedTransitionProperties
{
TimeDuration
mStartTime
;
double
mPlaybackRate
;
TimingParams
mTiming
;
Maybe
<
ComputedTimingFunction
>
mTimingFunction
;
AnimationValue
mFromValue
mToValue
;
}
;
Maybe
<
ReplacedTransitionProperties
>
mReplacedTransition
;
}
;
namespace
dom
{
class
CSSTransition
final
:
public
Animation
{
public
:
explicit
CSSTransition
(
nsIGlobalObject
*
aGlobal
)
:
dom
:
:
Animation
(
aGlobal
)
mPreviousTransitionPhase
(
TransitionPhase
:
:
Idle
)
mNeedsNewAnimationIndexWhenRun
(
false
)
mTransitionProperty
(
eCSSProperty_UNKNOWN
)
{
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
CSSTransition
*
AsCSSTransition
(
)
override
{
return
this
;
}
const
CSSTransition
*
AsCSSTransition
(
)
const
override
{
return
this
;
}
void
GetTransitionProperty
(
nsString
&
aRetVal
)
const
;
AnimationPlayState
PlayStateFromJS
(
)
const
override
;
bool
PendingFromJS
(
)
const
override
;
void
PlayFromJS
(
ErrorResult
&
aRv
)
override
;
void
PlayFromStyle
(
)
{
ErrorResult
rv
;
PlayNoUpdate
(
rv
Animation
:
:
LimitBehavior
:
:
Continue
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Unexpected
exception
playing
transition
"
)
;
}
void
CancelFromStyle
(
)
override
{
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
true
;
Animation
:
:
CancelFromStyle
(
)
;
mOwningElement
=
OwningElementRef
(
)
;
}
void
SetEffectFromStyle
(
AnimationEffectReadOnly
*
aEffect
)
;
void
Tick
(
)
override
;
nsCSSPropertyID
TransitionProperty
(
)
const
;
AnimationValue
ToValue
(
)
const
;
bool
HasLowerCompositeOrderThan
(
const
CSSTransition
&
aOther
)
const
;
EffectCompositor
:
:
CascadeLevel
CascadeLevel
(
)
const
override
{
return
IsTiedToMarkup
(
)
?
EffectCompositor
:
:
CascadeLevel
:
:
Transitions
:
EffectCompositor
:
:
CascadeLevel
:
:
Animations
;
}
void
SetCreationSequence
(
uint64_t
aIndex
)
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
)
;
mAnimationIndex
=
aIndex
;
}
void
SetOwningElement
(
const
OwningElementRef
&
aElement
)
{
mOwningElement
=
aElement
;
}
bool
IsTiedToMarkup
(
)
const
{
return
mOwningElement
.
IsSet
(
)
;
}
static
Nullable
<
TimeDuration
>
GetCurrentTimeAt
(
const
DocumentTimeline
&
aTimeline
const
TimeStamp
&
aBaseTime
const
TimeDuration
&
aStartTime
double
aPlaybackRate
)
;
void
MaybeQueueCancelEvent
(
const
StickyTimeDuration
&
aActiveTime
)
override
{
QueueEvents
(
aActiveTime
)
;
}
protected
:
virtual
~
CSSTransition
(
)
{
MOZ_ASSERT
(
!
mOwningElement
.
IsSet
(
)
"
Owning
element
should
be
cleared
"
"
before
a
CSS
transition
is
destroyed
"
)
;
}
void
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
override
;
void
QueueEvents
(
const
StickyTimeDuration
&
activeTime
=
StickyTimeDuration
(
)
)
;
enum
class
TransitionPhase
;
OwningElementRef
mOwningElement
;
enum
class
TransitionPhase
{
Idle
=
static_cast
<
int
>
(
ComputedTiming
:
:
AnimationPhase
:
:
Idle
)
Before
=
static_cast
<
int
>
(
ComputedTiming
:
:
AnimationPhase
:
:
Before
)
Active
=
static_cast
<
int
>
(
ComputedTiming
:
:
AnimationPhase
:
:
Active
)
After
=
static_cast
<
int
>
(
ComputedTiming
:
:
AnimationPhase
:
:
After
)
Pending
}
;
TransitionPhase
mPreviousTransitionPhase
;
bool
mNeedsNewAnimationIndexWhenRun
;
nsCSSPropertyID
mTransitionProperty
;
AnimationValue
mTransitionToValue
;
}
;
}
template
<
>
struct
AnimationTypeTraits
<
dom
:
:
CSSTransition
>
{
static
nsAtom
*
ElementPropertyAtom
(
)
{
return
nsGkAtoms
:
:
transitionsProperty
;
}
static
nsAtom
*
BeforePropertyAtom
(
)
{
return
nsGkAtoms
:
:
transitionsOfBeforeProperty
;
}
static
nsAtom
*
AfterPropertyAtom
(
)
{
return
nsGkAtoms
:
:
transitionsOfAfterProperty
;
}
}
;
struct
TransitionEventInfo
{
RefPtr
<
dom
:
:
Element
>
mElement
;
RefPtr
<
dom
:
:
Animation
>
mAnimation
;
InternalTransitionEvent
mEvent
;
TimeStamp
mTimeStamp
;
TransitionEventInfo
(
const
NonOwningAnimationTarget
&
aTarget
EventMessage
aMessage
nsCSSPropertyID
aProperty
double
aElapsedTime
const
TimeStamp
&
aTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mElement
(
aTarget
.
mElement
)
mAnimation
(
aAnimation
)
mEvent
(
true
aMessage
)
mTimeStamp
(
aTimeStamp
)
{
mEvent
.
mPropertyName
=
NS_ConvertUTF8toUTF16
(
nsCSSProps
:
:
GetStringValue
(
aProperty
)
)
;
mEvent
.
mElapsedTime
=
aElapsedTime
;
mEvent
.
mPseudoElement
=
AnimationCollection
<
dom
:
:
CSSTransition
>
:
:
PseudoTypeAsString
(
aTarget
.
mPseudoType
)
;
}
TransitionEventInfo
(
const
TransitionEventInfo
&
aOther
)
:
mElement
(
aOther
.
mElement
)
mAnimation
(
aOther
.
mAnimation
)
mEvent
(
aOther
.
mEvent
)
mTimeStamp
(
aOther
.
mTimeStamp
)
{
mEvent
.
AssignTransitionEventData
(
aOther
.
mEvent
false
)
;
}
}
;
}
class
nsTransitionManager
final
:
public
mozilla
:
:
CommonAnimationManager
<
mozilla
:
:
dom
:
:
CSSTransition
mozilla
:
:
TransitionEventInfo
>
{
public
:
explicit
nsTransitionManager
(
nsPresContext
*
aPresContext
)
:
mozilla
:
:
CommonAnimationManager
<
mozilla
:
:
dom
:
:
CSSTransition
mozilla
:
:
TransitionEventInfo
>
(
aPresContext
)
mInAnimationOnlyStyleUpdate
(
false
)
{
}
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
nsTransitionManager
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
nsTransitionManager
)
typedef
mozilla
:
:
AnimationCollection
<
mozilla
:
:
dom
:
:
CSSTransition
>
CSSTransitionCollection
;
void
StyleContextChanged
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
GeckoStyleContext
*
aOldStyleContext
RefPtr
<
mozilla
:
:
GeckoStyleContext
>
*
aNewStyleContext
)
;
bool
UpdateTransitions
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
CSSPseudoElementType
aPseudoType
const
mozilla
:
:
ServoStyleContext
*
aOldStyle
const
mozilla
:
:
ServoStyleContext
*
aNewStyle
)
;
void
PruneCompletedTransitions
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
CSSPseudoElementType
aPseudoType
mozilla
:
:
GeckoStyleContext
*
aNewStyleContext
)
;
void
SetInAnimationOnlyStyleUpdate
(
bool
aInAnimationOnlyUpdate
)
{
mInAnimationOnlyStyleUpdate
=
aInAnimationOnlyUpdate
;
}
bool
InAnimationOnlyStyleUpdate
(
)
const
{
return
mInAnimationOnlyStyleUpdate
;
}
void
DispatchEvents
(
)
{
RefPtr
<
nsTransitionManager
>
kungFuDeathGrip
(
this
)
;
mEventDispatcher
.
DispatchEvents
(
mPresContext
)
;
}
protected
:
virtual
~
nsTransitionManager
(
)
{
}
typedef
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
CSSTransition
>
>
OwningCSSTransitionPtrArray
;
template
<
typename
StyleType
>
bool
DoUpdateTransitions
(
const
nsStyleDisplay
&
aDisp
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
CSSPseudoElementType
aPseudoType
CSSTransitionCollection
*
&
aElementTransitions
StyleType
aOldStyle
StyleType
aNewStyle
)
;
template
<
typename
StyleType
>
void
ConsiderInitiatingTransition
(
nsCSSPropertyID
aProperty
const
nsStyleDisplay
&
aStyleDisplay
uint32_t
transitionIdx
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
CSSPseudoElementType
aPseudoType
CSSTransitionCollection
*
&
aElementTransitions
StyleType
aOldStyle
StyleType
aNewStyle
bool
*
aStartedAny
nsCSSPropertyIDSet
*
aWhichStarted
)
;
bool
mInAnimationOnlyStyleUpdate
;
}
;
#
endif
