#
ifndef
nsTransitionManager_h_
#
define
nsTransitionManager_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
AnimationCommon
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
class
nsIGlobalObject
;
class
nsStyleContext
;
class
nsPresContext
;
class
nsCSSPropertySet
;
namespace
mozilla
{
struct
StyleTransition
;
}
namespace
mozilla
{
struct
ElementPropertyTransition
:
public
dom
:
:
KeyframeEffectReadOnly
{
ElementPropertyTransition
(
nsIDocument
*
aDocument
dom
:
:
Element
*
aTarget
nsCSSPseudoElements
:
:
Type
aPseudoType
const
AnimationTiming
&
aTiming
)
:
dom
:
:
KeyframeEffectReadOnly
(
aDocument
aTarget
aPseudoType
aTiming
)
{
}
ElementPropertyTransition
*
AsTransition
(
)
override
{
return
this
;
}
const
ElementPropertyTransition
*
AsTransition
(
)
const
override
{
return
this
;
}
nsCSSProperty
TransitionProperty
(
)
const
{
MOZ_ASSERT
(
Properties
(
)
.
Length
(
)
=
=
1
"
Transitions
should
have
exactly
one
animation
property
.
"
"
Perhaps
we
are
using
an
un
-
initialized
transition
?
"
)
;
return
Properties
(
)
[
0
]
.
mProperty
;
}
StyleAnimationValue
mStartForReversingTest
;
double
mReversePortion
;
double
CurrentValuePortion
(
)
const
;
}
;
namespace
dom
{
class
CSSTransition
final
:
public
Animation
{
public
:
explicit
CSSTransition
(
nsIGlobalObject
*
aGlobal
)
:
dom
:
:
Animation
(
aGlobal
)
mWasFinishedOnLastTick
(
false
)
mNeedsNewAnimationIndexWhenRun
(
false
)
{
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
CSSTransition
*
AsCSSTransition
(
)
override
{
return
this
;
}
const
CSSTransition
*
AsCSSTransition
(
)
const
override
{
return
this
;
}
void
GetTransitionProperty
(
nsString
&
aRetVal
)
const
;
virtual
AnimationPlayState
PlayStateFromJS
(
)
const
override
;
virtual
void
PlayFromJS
(
ErrorResult
&
aRv
)
override
;
void
PlayFromStyle
(
)
{
ErrorResult
rv
;
DoPlay
(
rv
Animation
:
:
LimitBehavior
:
:
Continue
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Unexpected
exception
playing
transition
"
)
;
}
void
CancelFromStyle
(
)
override
{
mOwningElement
=
OwningElementRef
(
)
;
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
true
;
Animation
:
:
CancelFromStyle
(
)
;
}
void
Tick
(
)
override
;
nsCSSProperty
TransitionProperty
(
)
const
;
bool
HasLowerCompositeOrderThan
(
const
Animation
&
aOther
)
const
override
;
void
SetCreationSequence
(
uint64_t
aIndex
)
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
)
;
mAnimationIndex
=
aIndex
;
}
void
SetOwningElement
(
const
OwningElementRef
&
aElement
)
{
mOwningElement
=
aElement
;
}
bool
IsTiedToMarkup
(
)
const
{
return
mOwningElement
.
IsSet
(
)
;
}
protected
:
virtual
~
CSSTransition
(
)
{
MOZ_ASSERT
(
!
mOwningElement
.
IsSet
(
)
"
Owning
element
should
be
cleared
"
"
before
a
CSS
transition
is
destroyed
"
)
;
}
CommonAnimationManager
*
GetAnimationManager
(
)
const
override
;
void
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
override
;
void
QueueEvents
(
)
;
OwningElementRef
mOwningElement
;
bool
mWasFinishedOnLastTick
;
bool
mNeedsNewAnimationIndexWhenRun
;
}
;
}
struct
TransitionEventInfo
{
nsRefPtr
<
dom
:
:
Element
>
mElement
;
nsRefPtr
<
dom
:
:
Animation
>
mAnimation
;
InternalTransitionEvent
mEvent
;
TimeStamp
mTimeStamp
;
TransitionEventInfo
(
dom
:
:
Element
*
aElement
nsCSSPseudoElements
:
:
Type
aPseudoType
nsCSSProperty
aProperty
TimeDuration
aDuration
const
TimeStamp
&
aTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mElement
(
aElement
)
mAnimation
(
aAnimation
)
mEvent
(
true
eTransitionEnd
)
mTimeStamp
(
aTimeStamp
)
{
mEvent
.
propertyName
=
NS_ConvertUTF8toUTF16
(
nsCSSProps
:
:
GetStringValue
(
aProperty
)
)
;
mEvent
.
elapsedTime
=
aDuration
.
ToSeconds
(
)
;
mEvent
.
pseudoElement
=
AnimationCollection
:
:
PseudoTypeAsString
(
aPseudoType
)
;
}
TransitionEventInfo
(
const
TransitionEventInfo
&
aOther
)
:
mElement
(
aOther
.
mElement
)
mAnimation
(
aOther
.
mAnimation
)
mEvent
(
true
eTransitionEnd
)
mTimeStamp
(
aOther
.
mTimeStamp
)
{
mEvent
.
AssignTransitionEventData
(
aOther
.
mEvent
false
)
;
}
}
;
}
class
nsTransitionManager
final
:
public
mozilla
:
:
CommonAnimationManager
{
public
:
explicit
nsTransitionManager
(
nsPresContext
*
aPresContext
)
:
mozilla
:
:
CommonAnimationManager
(
aPresContext
)
mInAnimationOnlyStyleUpdate
(
false
)
{
}
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsTransitionManager
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
typedef
mozilla
:
:
AnimationCollection
AnimationCollection
;
void
StyleContextChanged
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsStyleContext
*
aOldStyleContext
nsRefPtr
<
nsStyleContext
>
*
aNewStyleContext
)
;
void
PruneCompletedTransitions
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsCSSPseudoElements
:
:
Type
aPseudoType
nsStyleContext
*
aNewStyleContext
)
;
void
UpdateCascadeResultsWithTransitions
(
AnimationCollection
*
aTransitions
)
;
void
UpdateCascadeResultsWithAnimations
(
AnimationCollection
*
aAnimations
)
;
void
UpdateCascadeResultsWithAnimationsToBeDestroyed
(
const
AnimationCollection
*
aAnimations
)
;
void
UpdateCascadeResults
(
AnimationCollection
*
aTransitions
AnimationCollection
*
aAnimations
)
;
void
SetInAnimationOnlyStyleUpdate
(
bool
aInAnimationOnlyUpdate
)
{
mInAnimationOnlyStyleUpdate
=
aInAnimationOnlyUpdate
;
}
bool
InAnimationOnlyStyleUpdate
(
)
const
{
return
mInAnimationOnlyStyleUpdate
;
}
virtual
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
MOZ_MUST_OVERRIDE
override
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
MOZ_MUST_OVERRIDE
override
;
void
QueueEvent
(
mozilla
:
:
TransitionEventInfo
&
&
aEventInfo
)
{
mEventDispatcher
.
QueueEvent
(
mozilla
:
:
Forward
<
mozilla
:
:
TransitionEventInfo
>
(
aEventInfo
)
)
;
}
void
DispatchEvents
(
)
{
mEventDispatcher
.
DispatchEvents
(
mPresContext
)
;
}
void
SortEvents
(
)
{
mEventDispatcher
.
SortEvents
(
)
;
}
void
ClearEventQueue
(
)
{
mEventDispatcher
.
ClearEventQueue
(
)
;
}
protected
:
virtual
~
nsTransitionManager
(
)
{
}
virtual
nsIAtom
*
GetAnimationsAtom
(
)
override
{
return
nsGkAtoms
:
:
transitionsProperty
;
}
virtual
nsIAtom
*
GetAnimationsBeforeAtom
(
)
override
{
return
nsGkAtoms
:
:
transitionsOfBeforeProperty
;
}
virtual
nsIAtom
*
GetAnimationsAfterAtom
(
)
override
{
return
nsGkAtoms
:
:
transitionsOfAfterProperty
;
}
private
:
void
ConsiderStartingTransition
(
nsCSSProperty
aProperty
const
mozilla
:
:
StyleTransition
&
aTransition
mozilla
:
:
dom
:
:
Element
*
aElement
AnimationCollection
*
&
aElementTransitions
nsStyleContext
*
aOldStyleContext
nsStyleContext
*
aNewStyleContext
bool
*
aStartedAny
nsCSSPropertySet
*
aWhichStarted
)
;
bool
mInAnimationOnlyStyleUpdate
;
mozilla
:
:
DelayedEventDispatcher
<
mozilla
:
:
TransitionEventInfo
>
mEventDispatcher
;
}
;
#
endif
