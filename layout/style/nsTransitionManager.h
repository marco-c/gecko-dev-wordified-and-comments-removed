#
ifndef
nsTransitionManager_h_
#
define
nsTransitionManager_h_
#
include
"
mozilla
/
ComputedTiming
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
AnimationCommon
.
h
"
#
include
"
nsISupportsImpl
.
h
"
class
nsIGlobalObject
;
class
nsPresContext
;
class
nsCSSPropertyIDSet
;
namespace
mozilla
{
class
ComputedStyle
;
enum
class
PseudoStyleType
:
uint8_t
;
struct
Keyframe
;
struct
StyleTransition
;
}
namespace
mozilla
{
struct
ElementPropertyTransition
:
public
dom
:
:
KeyframeEffect
{
ElementPropertyTransition
(
dom
:
:
Document
*
aDocument
Maybe
<
OwningAnimationTarget
>
&
aTarget
TimingParams
&
&
aTiming
AnimationValue
aStartForReversingTest
double
aReversePortion
const
KeyframeEffectParams
&
aEffectOptions
)
:
dom
:
:
KeyframeEffect
(
aDocument
aTarget
std
:
:
move
(
aTiming
)
aEffectOptions
)
mStartForReversingTest
(
aStartForReversingTest
)
mReversePortion
(
aReversePortion
)
{
}
ElementPropertyTransition
*
AsTransition
(
)
override
{
return
this
;
}
const
ElementPropertyTransition
*
AsTransition
(
)
const
override
{
return
this
;
}
nsCSSPropertyID
TransitionProperty
(
)
const
{
MOZ_ASSERT
(
mKeyframes
.
Length
(
)
=
=
2
"
Transitions
should
have
exactly
two
animation
keyframes
.
"
"
Perhaps
we
are
using
an
un
-
initialized
transition
?
"
)
;
MOZ_ASSERT
(
mKeyframes
[
0
]
.
mPropertyValues
.
Length
(
)
=
=
1
"
Transitions
should
have
exactly
one
property
in
their
first
"
"
frame
"
)
;
return
mKeyframes
[
0
]
.
mPropertyValues
[
0
]
.
mProperty
;
}
AnimationValue
ToValue
(
)
const
{
if
(
mProperties
.
Length
(
)
<
1
|
|
mProperties
[
0
]
.
mSegments
.
Length
(
)
<
1
)
{
NS_WARNING
(
"
Failed
to
generate
transition
property
values
"
)
;
return
AnimationValue
(
)
;
}
return
mProperties
[
0
]
.
mSegments
[
0
]
.
mToValue
;
}
AnimationValue
mStartForReversingTest
;
double
mReversePortion
;
double
CurrentValuePortion
(
)
const
;
void
UpdateStartValueFromReplacedTransition
(
)
;
struct
ReplacedTransitionProperties
{
TimeDuration
mStartTime
;
double
mPlaybackRate
;
TimingParams
mTiming
;
Maybe
<
ComputedTimingFunction
>
mTimingFunction
;
AnimationValue
mFromValue
mToValue
;
}
;
Maybe
<
ReplacedTransitionProperties
>
mReplacedTransition
;
}
;
namespace
dom
{
class
CSSTransition
final
:
public
Animation
{
public
:
explicit
CSSTransition
(
nsIGlobalObject
*
aGlobal
)
:
dom
:
:
Animation
(
aGlobal
)
mPreviousTransitionPhase
(
TransitionPhase
:
:
Idle
)
mNeedsNewAnimationIndexWhenRun
(
false
)
mTransitionProperty
(
eCSSProperty_UNKNOWN
)
{
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
CSSTransition
*
AsCSSTransition
(
)
override
{
return
this
;
}
const
CSSTransition
*
AsCSSTransition
(
)
const
override
{
return
this
;
}
void
GetTransitionProperty
(
nsString
&
aRetVal
)
const
;
AnimationPlayState
PlayStateFromJS
(
)
const
override
;
bool
PendingFromJS
(
)
const
override
;
void
PlayFromJS
(
ErrorResult
&
aRv
)
override
;
void
PlayFromStyle
(
)
{
ErrorResult
rv
;
PlayNoUpdate
(
rv
Animation
:
:
LimitBehavior
:
:
Continue
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Unexpected
exception
playing
transition
"
)
;
}
void
CancelFromStyle
(
)
override
{
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
true
;
Animation
:
:
CancelFromStyle
(
)
;
mOwningElement
=
OwningElementRef
(
)
;
}
void
SetEffectFromStyle
(
AnimationEffect
*
aEffect
)
;
void
Tick
(
)
override
;
nsCSSPropertyID
TransitionProperty
(
)
const
;
AnimationValue
ToValue
(
)
const
;
bool
HasLowerCompositeOrderThan
(
const
CSSTransition
&
aOther
)
const
;
EffectCompositor
:
:
CascadeLevel
CascadeLevel
(
)
const
override
{
return
IsTiedToMarkup
(
)
?
EffectCompositor
:
:
CascadeLevel
:
:
Transitions
:
EffectCompositor
:
:
CascadeLevel
:
:
Animations
;
}
void
SetCreationSequence
(
uint64_t
aIndex
)
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
)
;
mAnimationIndex
=
aIndex
;
}
void
SetOwningElement
(
const
OwningElementRef
&
aElement
)
{
mOwningElement
=
aElement
;
}
bool
IsTiedToMarkup
(
)
const
{
return
mOwningElement
.
IsSet
(
)
;
}
static
Nullable
<
TimeDuration
>
GetCurrentTimeAt
(
const
DocumentTimeline
&
aTimeline
const
TimeStamp
&
aBaseTime
const
TimeDuration
&
aStartTime
double
aPlaybackRate
)
;
void
MaybeQueueCancelEvent
(
const
StickyTimeDuration
&
aActiveTime
)
override
{
QueueEvents
(
aActiveTime
)
;
}
protected
:
virtual
~
CSSTransition
(
)
{
MOZ_ASSERT
(
!
mOwningElement
.
IsSet
(
)
"
Owning
element
should
be
cleared
"
"
before
a
CSS
transition
is
destroyed
"
)
;
}
void
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
override
;
void
QueueEvents
(
const
StickyTimeDuration
&
activeTime
=
StickyTimeDuration
(
)
)
;
enum
class
TransitionPhase
;
OwningElementRef
mOwningElement
;
enum
class
TransitionPhase
{
Idle
=
static_cast
<
int
>
(
ComputedTiming
:
:
AnimationPhase
:
:
Idle
)
Before
=
static_cast
<
int
>
(
ComputedTiming
:
:
AnimationPhase
:
:
Before
)
Active
=
static_cast
<
int
>
(
ComputedTiming
:
:
AnimationPhase
:
:
Active
)
After
=
static_cast
<
int
>
(
ComputedTiming
:
:
AnimationPhase
:
:
After
)
Pending
}
;
TransitionPhase
mPreviousTransitionPhase
;
bool
mNeedsNewAnimationIndexWhenRun
;
nsCSSPropertyID
mTransitionProperty
;
AnimationValue
mTransitionToValue
;
}
;
}
template
<
>
struct
AnimationTypeTraits
<
dom
:
:
CSSTransition
>
{
static
nsAtom
*
ElementPropertyAtom
(
)
{
return
nsGkAtoms
:
:
transitionsProperty
;
}
static
nsAtom
*
BeforePropertyAtom
(
)
{
return
nsGkAtoms
:
:
transitionsOfBeforeProperty
;
}
static
nsAtom
*
AfterPropertyAtom
(
)
{
return
nsGkAtoms
:
:
transitionsOfAfterProperty
;
}
}
;
}
class
nsTransitionManager
final
:
public
mozilla
:
:
CommonAnimationManager
<
mozilla
:
:
dom
:
:
CSSTransition
>
{
public
:
explicit
nsTransitionManager
(
nsPresContext
*
aPresContext
)
:
mozilla
:
:
CommonAnimationManager
<
mozilla
:
:
dom
:
:
CSSTransition
>
(
aPresContext
)
{
}
~
nsTransitionManager
(
)
final
=
default
;
typedef
mozilla
:
:
AnimationCollection
<
mozilla
:
:
dom
:
:
CSSTransition
>
CSSTransitionCollection
;
bool
UpdateTransitions
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
PseudoStyleType
aPseudoType
const
mozilla
:
:
ComputedStyle
&
aOldStyle
const
mozilla
:
:
ComputedStyle
&
aNewStyle
)
;
protected
:
typedef
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
CSSTransition
>
>
OwningCSSTransitionPtrArray
;
bool
DoUpdateTransitions
(
const
nsStyleDisplay
&
aDisp
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
PseudoStyleType
aPseudoType
CSSTransitionCollection
*
&
aElementTransitions
const
mozilla
:
:
ComputedStyle
&
aOldStyle
const
mozilla
:
:
ComputedStyle
&
aNewStyle
)
;
bool
ConsiderInitiatingTransition
(
nsCSSPropertyID
aProperty
const
nsStyleDisplay
&
aStyleDisplay
uint32_t
transitionIdx
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
PseudoStyleType
aPseudoType
CSSTransitionCollection
*
&
aElementTransitions
const
mozilla
:
:
ComputedStyle
&
aOldStyle
const
mozilla
:
:
ComputedStyle
&
aNewStyle
nsCSSPropertyIDSet
&
aPropertiesChecked
)
;
}
;
#
endif
