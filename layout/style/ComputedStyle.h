#
ifndef
_ComputedStyle_h_
#
define
_ComputedStyle_h_
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CachedInheritingStyles
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PseudoStyleType
.
h
"
#
include
"
mozilla
/
ServoComputedData
.
h
"
#
include
"
mozilla
/
ServoComputedDataInlines
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsStyleStructFwd
.
h
"
enum
nsChangeHint
:
uint32_t
;
class
nsWindowSizes
;
#
define
STYLE_STRUCT
(
name_
)
struct
nsStyle
#
#
name_
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
extern
"
C
"
{
void
Gecko_ComputedStyle_Destroy
(
mozilla
:
:
ComputedStyle
*
)
;
}
namespace
mozilla
{
namespace
dom
{
class
Document
;
}
class
ComputedStyle
{
using
Flag
=
StyleComputedValueFlags
;
const
StyleComputedValueFlags
&
Flags
(
)
const
{
return
mSource
.
flags
;
}
public
:
ComputedStyle
(
PseudoStyleType
aPseudoType
ServoComputedDataForgotten
aComputedValues
)
;
void
GetComputedPropertyValue
(
nsCSSPropertyID
aId
nsACString
&
aOut
)
const
{
Servo_GetPropertyValue
(
this
aId
&
aOut
)
;
}
ComputedStyle
*
GetStyleIfVisited
(
)
const
{
return
mSource
.
visited_style
.
mPtr
;
}
bool
IsLazilyCascadedPseudoElement
(
)
const
{
return
IsPseudoElement
(
)
&
&
!
nsCSSPseudoElements
:
:
IsEagerlyCascadedInServo
(
GetPseudoType
(
)
)
;
}
PseudoStyleType
GetPseudoType
(
)
const
{
return
mPseudoType
;
}
bool
IsPseudoElement
(
)
const
{
return
PseudoStyle
:
:
IsPseudoElement
(
mPseudoType
)
;
}
bool
IsInheritingAnonBox
(
)
const
{
return
PseudoStyle
:
:
IsInheritingAnonBox
(
mPseudoType
)
;
}
bool
IsNonInheritingAnonBox
(
)
const
{
return
PseudoStyle
:
:
IsNonInheritingAnonBox
(
mPseudoType
)
;
}
bool
IsWrapperAnonBox
(
)
const
{
return
PseudoStyle
:
:
IsWrapperAnonBox
(
mPseudoType
)
;
}
bool
IsAnonBox
(
)
const
{
return
PseudoStyle
:
:
IsAnonBox
(
mPseudoType
)
;
}
bool
IsPseudoOrAnonBox
(
)
const
{
return
mPseudoType
!
=
PseudoStyleType
:
:
NotPseudo
;
}
bool
HasAuthorSpecifiedBorderOrBackground
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
HAS_AUTHOR_SPECIFIED_BORDER_BACKGROUND
)
;
}
bool
HasTextDecorationLines
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
HAS_TEXT_DECORATION_LINES
)
;
}
bool
ShouldSuppressLineBreak
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
SHOULD_SUPPRESS_LINEBREAK
)
;
}
bool
IsTextCombined
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
IS_TEXT_COMBINED
)
;
}
bool
DependsOnSelfFontMetrics
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
DEPENDS_ON_SELF_FONT_METRICS
)
;
}
bool
DependsOnInheritedFontMetrics
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
DEPENDS_ON_INHERITED_FONT_METRICS
)
;
}
bool
HasPseudoElementData
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
IS_IN_PSEUDO_ELEMENT_SUBTREE
)
;
}
bool
RelevantLinkVisited
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
IS_RELEVANT_LINK_VISITED
)
;
}
bool
IsRootElementStyle
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
IS_ROOT_ELEMENT_STYLE
)
;
}
bool
IsInOpacityZeroSubtree
(
)
const
{
return
bool
(
Flags
(
)
&
Flag
:
:
IS_IN_OPACITY_ZERO_SUBTREE
)
;
}
ComputedStyle
*
GetCachedInheritingAnonBoxStyle
(
PseudoStyleType
aPseudoType
)
const
{
MOZ_ASSERT
(
PseudoStyle
:
:
IsInheritingAnonBox
(
aPseudoType
)
)
;
return
mCachedInheritingStyles
.
Lookup
(
aPseudoType
)
;
}
void
SetCachedInheritedAnonBoxStyle
(
ComputedStyle
*
aStyle
)
{
mCachedInheritingStyles
.
Insert
(
aStyle
)
;
}
ComputedStyle
*
GetCachedLazyPseudoStyle
(
PseudoStyleType
aPseudo
)
const
;
void
SetCachedLazyPseudoStyle
(
ComputedStyle
*
aStyle
)
{
MOZ_ASSERT
(
aStyle
-
>
IsPseudoElement
(
)
)
;
MOZ_ASSERT
(
!
GetCachedLazyPseudoStyle
(
aStyle
-
>
GetPseudoType
(
)
)
)
;
MOZ_ASSERT
(
aStyle
-
>
IsLazilyCascadedPseudoElement
(
)
)
;
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
aStyle
-
>
GetPseudoType
(
)
)
)
{
return
;
}
mCachedInheritingStyles
.
Insert
(
aStyle
)
;
}
#
define
STYLE_STRUCT
(
name_
)
\
inline
const
nsStyle
#
#
name_
*
Style
#
#
name_
(
)
const
MOZ_NONNULL_RETURN
{
\
return
mSource
.
GetStyle
#
#
name_
(
)
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
inline
mozilla
:
:
StylePointerEvents
PointerEvents
(
)
const
;
inline
mozilla
:
:
StyleUserSelect
UserSelect
(
)
const
;
nsChangeHint
CalcStyleDifference
(
const
ComputedStyle
&
aNewContext
uint32_t
*
aEqualStructs
)
const
;
#
ifdef
DEBUG
bool
EqualForCachedAnonymousContentStyle
(
const
ComputedStyle
&
)
const
;
#
endif
public
:
template
<
typename
T
typename
S
>
nscolor
GetVisitedDependentColor
(
T
S
:
:
*
aField
)
const
;
static
nscolor
CombineVisitedColors
(
nscolor
*
aColors
bool
aLinkIsVisited
)
;
inline
void
StartImageLoads
(
dom
:
:
Document
&
const
ComputedStyle
*
aOldStyle
=
nullptr
)
;
#
ifdef
DEBUG
void
List
(
FILE
*
out
int32_t
aIndent
)
;
static
const
char
*
StructName
(
StyleStructID
aSID
)
;
static
Maybe
<
StyleStructID
>
LookupStruct
(
const
nsACString
&
aName
)
;
#
endif
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aCVsSize
)
const
;
StyleWritingMode
WritingMode
(
)
const
{
return
{
mSource
.
WritingMode
(
)
.
mBits
}
;
}
protected
:
friend
void
:
:
Gecko_ComputedStyle_Destroy
(
ComputedStyle
*
)
;
~
ComputedStyle
(
)
=
default
;
ServoComputedData
mSource
;
CachedInheritingStyles
mCachedInheritingStyles
;
const
PseudoStyleType
mPseudoType
;
}
;
}
#
endif
