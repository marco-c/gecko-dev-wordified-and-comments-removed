#
ifndef
_ComputedStyle_h_
#
define
_ComputedStyle_h_
#
include
"
nsIMemoryReporter
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ArenaObjectID
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RestyleLogging
.
h
"
#
include
"
mozilla
/
ServoTypes
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
StyleComplexColor
.
h
"
#
include
"
mozilla
/
CachedInheritingStyles
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsStyleStructFwd
.
h
"
#
define
NS_STYLE_INHERIT_MASK
0x000ffffff
#
define
NS_STYLE_INHERITED_STRUCT_MASK
\
(
(
nsStyleStructID_size_t
(
1
)
<
<
nsStyleStructID_Inherited_Count
)
-
1
)
#
define
NS_STYLE_RESET_STRUCT_MASK
\
(
(
(
nsStyleStructID_size_t
(
1
)
<
<
nsStyleStructID_Reset_Count
)
-
1
)
\
<
<
nsStyleStructID_Inherited_Count
)
#
define
NS_STYLE_HAS_TEXT_DECORATION_LINES
0x001000000
#
define
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
0x002000000
#
define
NS_STYLE_RELEVANT_LINK_VISITED
0x004000000
#
define
NS_STYLE_IS_STYLE_IF_VISITED
0x008000000
#
define
NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE
0x010000000
#
define
NS_STYLE_IS_SHARED
0x020000000
#
define
NS_STYLE_IS_GOING_AWAY
0x040000000
#
define
NS_STYLE_SUPPRESS_LINEBREAK
0x080000000
#
define
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
0x100000000
#
define
NS_STYLE_INELIGIBLE_FOR_SHARING
0x200000000
#
define
NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE
0x400000000
#
define
NS_STYLE_IS_TEXT_COMBINED
0x800000000
#
define
NS_STYLE_CONTEXT_IS_GECKO
0x1000000000
#
define
NS_STYLE_CONTEXT_TYPE_SHIFT
37
class
nsAtom
;
enum
nsChangeHint
:
uint32_t
;
class
nsIPresShell
;
class
nsPresContext
;
class
nsWindowSizes
;
#
define
STYLE_STRUCT
(
name_
)
struct
nsStyle
#
#
name_
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
extern
"
C
"
{
void
Servo_ComputedStyle_AddRef
(
const
mozilla
:
:
ComputedStyle
*
aStyle
)
;
void
Servo_ComputedStyle_Release
(
const
mozilla
:
:
ComputedStyle
*
aStyle
)
;
void
Gecko_ComputedStyle_Destroy
(
mozilla
:
:
ComputedStyle
*
)
;
}
namespace
mozilla
{
enum
class
CSSPseudoElementType
:
uint8_t
;
class
ComputedStyle
;
class
ComputedStyle
{
public
:
ComputedStyle
(
nsPresContext
*
aPresContext
nsAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
ServoComputedDataForgotten
aComputedValues
)
;
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
const
ServoComputedData
*
ComputedData
(
)
const
{
return
&
mSource
;
}
static
mozilla
:
:
ArenaObjectID
ArenaObjectID
(
)
{
return
mozilla
:
:
eArenaObjectID_GeckoComputedStyle
;
}
nsIPresShell
*
Arena
(
)
;
void
AddRef
(
)
{
Servo_ComputedStyle_AddRef
(
this
)
;
}
void
Release
(
)
{
Servo_ComputedStyle_Release
(
this
)
;
}
ComputedStyle
*
GetStyleIfVisited
(
)
const
{
return
ComputedData
(
)
-
>
visited_style
.
mPtr
;
}
bool
IsLazilyCascadedPseudoElement
(
)
const
{
return
IsPseudoElement
(
)
&
&
!
nsCSSPseudoElements
:
:
IsEagerlyCascadedInServo
(
GetPseudoType
(
)
)
;
}
nsAtom
*
GetPseudo
(
)
const
{
return
mPseudoTag
;
}
mozilla
:
:
CSSPseudoElementType
GetPseudoType
(
)
const
{
return
static_cast
<
mozilla
:
:
CSSPseudoElementType
>
(
mBits
>
>
NS_STYLE_CONTEXT_TYPE_SHIFT
)
;
}
bool
IsInheritingAnonBox
(
)
const
{
return
GetPseudoType
(
)
=
=
mozilla
:
:
CSSPseudoElementType
:
:
InheritingAnonBox
;
}
bool
IsNonInheritingAnonBox
(
)
const
{
return
GetPseudoType
(
)
=
=
mozilla
:
:
CSSPseudoElementType
:
:
NonInheritingAnonBox
;
}
bool
IsWrapperAnonBox
(
)
const
{
return
nsCSSAnonBoxes
:
:
IsWrapperAnonBox
(
GetPseudo
(
)
)
;
}
bool
IsAnonBox
(
)
const
{
return
IsInheritingAnonBox
(
)
|
|
IsNonInheritingAnonBox
(
)
;
}
bool
IsPseudoElement
(
)
const
{
return
mPseudoTag
&
&
!
IsAnonBox
(
)
;
}
bool
HasTextDecorationLines
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_HAS_TEXT_DECORATION_LINES
)
;
}
bool
ShouldSuppressLineBreak
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_SUPPRESS_LINEBREAK
)
;
}
bool
IsInDisplayNoneSubtree
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
)
;
}
bool
IsTextCombined
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IS_TEXT_COMBINED
)
;
}
bool
HasPseudoElementData
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
)
;
}
bool
HasChildThatUsesResetStyle
(
)
const
{
return
mBits
&
NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE
;
}
bool
RelevantLinkVisited
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_RELEVANT_LINK_VISITED
)
;
}
inline
bool
IsLinkContext
(
)
const
;
bool
IsStyleIfVisited
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IS_STYLE_IF_VISITED
)
;
}
void
SetIsStyleIfVisited
(
)
{
mBits
|
=
NS_STYLE_IS_STYLE_IF_VISITED
;
}
bool
HasChildThatUsesGrandancestorStyle
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE
)
;
}
bool
IsShared
(
)
const
{
return
!
!
(
mBits
&
NS_STYLE_IS_SHARED
)
;
}
bool
HasCachedDependentStyleData
(
nsStyleStructID
aSID
)
{
return
mBits
&
GetBitForSID
(
aSID
)
;
}
ComputedStyle
*
GetCachedInheritingAnonBoxStyle
(
nsAtom
*
aAnonBox
)
const
{
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsInheritingAnonBox
(
aAnonBox
)
)
;
return
mCachedInheritingStyles
.
Lookup
(
aAnonBox
)
;
}
void
SetCachedInheritedAnonBoxStyle
(
nsAtom
*
aAnonBox
ComputedStyle
*
aStyle
)
{
MOZ_ASSERT
(
!
GetCachedInheritingAnonBoxStyle
(
aAnonBox
)
)
;
mCachedInheritingStyles
.
Insert
(
aStyle
)
;
}
ComputedStyle
*
GetCachedLazyPseudoStyle
(
CSSPseudoElementType
aPseudo
)
const
;
void
SetCachedLazyPseudoStyle
(
ComputedStyle
*
aStyle
)
{
MOZ_ASSERT
(
aStyle
-
>
GetPseudo
(
)
&
&
!
aStyle
-
>
IsAnonBox
(
)
)
;
MOZ_ASSERT
(
!
GetCachedLazyPseudoStyle
(
aStyle
-
>
GetPseudoType
(
)
)
)
;
MOZ_ASSERT
(
!
IsLazilyCascadedPseudoElement
(
)
"
lazy
pseudos
can
'
t
inherit
lazy
pseudos
"
)
;
MOZ_ASSERT
(
aStyle
-
>
IsLazilyCascadedPseudoElement
(
)
)
;
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
aStyle
-
>
GetPseudoType
(
)
)
)
{
return
;
}
mCachedInheritingStyles
.
Insert
(
aStyle
)
;
}
void
AddStyleBit
(
const
uint64_t
&
aBit
)
{
mBits
|
=
aBit
;
}
#
define
STYLE_STRUCT
(
name_
)
\
inline
const
nsStyle
#
#
name_
*
Style
#
#
name_
(
)
MOZ_NONNULL_RETURN
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
#
define
STYLE_STRUCT
(
name_
)
\
inline
const
nsStyle
#
#
name_
*
ThreadsafeStyle
#
#
name_
(
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
#
define
STYLE_STRUCT
(
name_
)
\
inline
const
nsStyle
#
#
name_
*
PeekStyle
#
#
name_
(
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
nsChangeHint
CalcStyleDifference
(
ComputedStyle
*
aNewContext
uint32_t
*
aEqualStructs
)
;
public
:
template
<
typename
T
typename
S
>
nscolor
GetVisitedDependentColor
(
T
S
:
:
*
aField
)
;
static
nscolor
CombineVisitedColors
(
nscolor
*
aColors
bool
aLinkIsVisited
)
;
inline
void
StartBackgroundImageLoads
(
)
;
static
bool
IsReset
(
const
nsStyleStructID
aSID
)
{
MOZ_ASSERT
(
0
<
=
aSID
&
&
aSID
<
nsStyleStructID_Length
"
must
be
an
inherited
or
reset
SID
"
)
;
return
nsStyleStructID_Reset_Start
<
=
aSID
;
}
static
bool
IsInherited
(
const
nsStyleStructID
aSID
)
{
return
!
IsReset
(
aSID
)
;
}
static
uint32_t
GetBitForSID
(
const
nsStyleStructID
aSID
)
{
return
1
<
<
aSID
;
}
#
ifdef
DEBUG
void
List
(
FILE
*
out
int32_t
aIndent
)
;
static
const
char
*
StructName
(
nsStyleStructID
aSID
)
;
static
bool
LookupStruct
(
const
nsACString
&
aName
nsStyleStructID
&
aResult
)
;
#
endif
inline
void
ResolveSameStructsAs
(
const
ComputedStyle
*
aOther
)
;
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aCVsSize
)
const
;
protected
:
friend
void
:
:
Gecko_ComputedStyle_Destroy
(
ComputedStyle
*
)
;
~
ComputedStyle
(
)
=
default
;
nsPresContext
*
mPresContext
;
ServoComputedData
mSource
;
CachedInheritingStyles
mCachedInheritingStyles
;
#
define
STYLE_STRUCT_INHERITED
(
name_
)
\
template
<
bool
aComputeData
>
\
const
nsStyle
#
#
name_
*
DoGetStyle
#
#
name_
(
)
;
#
define
STYLE_STRUCT_RESET
(
name_
)
\
template
<
bool
aComputeData
>
\
const
nsStyle
#
#
name_
*
DoGetStyle
#
#
name_
(
)
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT_RESET
#
undef
STYLE_STRUCT_INHERITED
RefPtr
<
nsAtom
>
mPseudoTag
;
uint64_t
mBits
;
}
;
}
#
endif
