#
ifndef
_ComputedStyle_h_
#
define
_ComputedStyle_h_
#
include
"
nsIMemoryReporter
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ArenaObjectID
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CachedInheritingStyles
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ServoComputedData
.
h
"
#
include
"
mozilla
/
ServoTypes
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
StyleComplexColor
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsStyleStructFwd
.
h
"
class
nsAtom
;
enum
nsChangeHint
:
uint32_t
;
class
nsIPresShell
;
class
nsPresContext
;
class
nsWindowSizes
;
#
define
STYLE_STRUCT
(
name_
)
struct
nsStyle
#
#
name_
;
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
extern
"
C
"
{
void
Servo_ComputedStyle_AddRef
(
const
mozilla
:
:
ComputedStyle
*
aStyle
)
;
void
Servo_ComputedStyle_Release
(
const
mozilla
:
:
ComputedStyle
*
aStyle
)
;
void
Gecko_ComputedStyle_Destroy
(
mozilla
:
:
ComputedStyle
*
)
;
}
namespace
mozilla
{
namespace
dom
{
class
Document
;
}
enum
class
CSSPseudoElementType
:
uint8_t
;
class
ComputedStyle
;
enum
class
ComputedStyleBit
:
uint8_t
{
HasTextDecorationLines
=
1
<
<
0
HasPseudoElementData
=
1
<
<
1
SuppressLineBreak
=
1
<
<
2
IsTextCombined
=
1
<
<
3
RelevantLinkVisited
=
1
<
<
4
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
ComputedStyleBit
)
class
ComputedStyle
{
using
Bit
=
ComputedStyleBit
;
public
:
ComputedStyle
(
nsPresContext
*
aPresContext
nsAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
ServoComputedDataForgotten
aComputedValues
)
;
nsPresContext
*
PresContextForFrame
(
)
const
{
return
mPresContext
;
}
static
mozilla
:
:
ArenaObjectID
ArenaObjectID
(
)
{
return
mozilla
:
:
eArenaObjectID_GeckoComputedStyle
;
}
nsIPresShell
*
Arena
(
)
;
void
AddRef
(
)
{
Servo_ComputedStyle_AddRef
(
this
)
;
}
void
Release
(
)
{
Servo_ComputedStyle_Release
(
this
)
;
}
ComputedStyle
*
GetStyleIfVisited
(
)
const
{
return
mSource
.
visited_style
.
mPtr
;
}
bool
IsLazilyCascadedPseudoElement
(
)
const
{
return
IsPseudoElement
(
)
&
&
!
nsCSSPseudoElements
:
:
IsEagerlyCascadedInServo
(
GetPseudoType
(
)
)
;
}
nsAtom
*
GetPseudo
(
)
const
{
return
mPseudoTag
;
}
mozilla
:
:
CSSPseudoElementType
GetPseudoType
(
)
const
{
return
mPseudoType
;
}
bool
IsInheritingAnonBox
(
)
const
{
return
GetPseudoType
(
)
=
=
mozilla
:
:
CSSPseudoElementType
:
:
InheritingAnonBox
;
}
bool
IsNonInheritingAnonBox
(
)
const
{
return
GetPseudoType
(
)
=
=
mozilla
:
:
CSSPseudoElementType
:
:
NonInheritingAnonBox
;
}
bool
IsWrapperAnonBox
(
)
const
{
return
nsCSSAnonBoxes
:
:
IsWrapperAnonBox
(
GetPseudo
(
)
)
;
}
bool
IsAnonBox
(
)
const
{
return
IsInheritingAnonBox
(
)
|
|
IsNonInheritingAnonBox
(
)
;
}
bool
IsPseudoElement
(
)
const
{
return
mPseudoTag
&
&
!
IsAnonBox
(
)
;
}
bool
HasTextDecorationLines
(
)
const
{
return
bool
(
mBits
&
Bit
:
:
HasTextDecorationLines
)
;
}
bool
ShouldSuppressLineBreak
(
)
const
{
return
bool
(
mBits
&
Bit
:
:
SuppressLineBreak
)
;
}
bool
IsTextCombined
(
)
const
{
return
bool
(
mBits
&
Bit
:
:
IsTextCombined
)
;
}
bool
HasPseudoElementData
(
)
const
{
return
bool
(
mBits
&
Bit
:
:
HasPseudoElementData
)
;
}
bool
RelevantLinkVisited
(
)
const
{
return
bool
(
mBits
&
Bit
:
:
RelevantLinkVisited
)
;
}
ComputedStyle
*
GetCachedInheritingAnonBoxStyle
(
nsAtom
*
aAnonBox
)
const
{
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsInheritingAnonBox
(
aAnonBox
)
)
;
return
mCachedInheritingStyles
.
Lookup
(
aAnonBox
)
;
}
void
SetCachedInheritedAnonBoxStyle
(
nsAtom
*
aAnonBox
ComputedStyle
*
aStyle
)
{
MOZ_ASSERT
(
!
GetCachedInheritingAnonBoxStyle
(
aAnonBox
)
)
;
mCachedInheritingStyles
.
Insert
(
aStyle
)
;
}
ComputedStyle
*
GetCachedLazyPseudoStyle
(
CSSPseudoElementType
aPseudo
)
const
;
void
SetCachedLazyPseudoStyle
(
ComputedStyle
*
aStyle
)
{
MOZ_ASSERT
(
aStyle
-
>
GetPseudo
(
)
&
&
!
aStyle
-
>
IsAnonBox
(
)
)
;
MOZ_ASSERT
(
!
GetCachedLazyPseudoStyle
(
aStyle
-
>
GetPseudoType
(
)
)
)
;
MOZ_ASSERT
(
!
IsLazilyCascadedPseudoElement
(
)
"
lazy
pseudos
can
'
t
inherit
lazy
pseudos
"
)
;
MOZ_ASSERT
(
aStyle
-
>
IsLazilyCascadedPseudoElement
(
)
)
;
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
aStyle
-
>
GetPseudoType
(
)
)
)
{
return
;
}
mCachedInheritingStyles
.
Insert
(
aStyle
)
;
}
#
define
STYLE_STRUCT
(
name_
)
\
inline
const
nsStyle
#
#
name_
*
Style
#
#
name_
(
)
const
MOZ_NONNULL_RETURN
{
\
return
mSource
.
GetStyle
#
#
name_
(
)
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
nsChangeHint
CalcStyleDifference
(
const
ComputedStyle
&
aNewContext
uint32_t
*
aEqualStructs
)
const
;
public
:
template
<
typename
T
typename
S
>
nscolor
GetVisitedDependentColor
(
T
S
:
:
*
aField
)
;
static
nscolor
CombineVisitedColors
(
nscolor
*
aColors
bool
aLinkIsVisited
)
;
inline
void
StartImageLoads
(
dom
:
:
Document
&
const
ComputedStyle
*
aOldStyle
=
nullptr
)
;
#
ifdef
DEBUG
void
List
(
FILE
*
out
int32_t
aIndent
)
;
static
const
char
*
StructName
(
StyleStructID
aSID
)
;
static
Maybe
<
StyleStructID
>
LookupStruct
(
const
nsACString
&
aName
)
;
#
endif
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aCVsSize
)
const
;
protected
:
friend
void
:
:
Gecko_ComputedStyle_Destroy
(
ComputedStyle
*
)
;
~
ComputedStyle
(
)
=
default
;
nsPresContext
*
const
mPresContext
;
ServoComputedData
mSource
;
CachedInheritingStyles
mCachedInheritingStyles
;
const
RefPtr
<
nsAtom
>
mPseudoTag
;
const
Bit
mBits
;
const
CSSPseudoElementType
mPseudoType
;
}
;
}
#
endif
