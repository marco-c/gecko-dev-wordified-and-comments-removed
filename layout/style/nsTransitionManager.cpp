#
include
"
nsTransitionManager
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
mozilla
/
dom
/
CSSTransitionBinding
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsRuleProcessorData
.
h
"
#
include
"
nsRuleWalker
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
Layers
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsRFPService
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
RestyleManagerInlines
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
dom
:
:
Animation
;
using
mozilla
:
:
dom
:
:
AnimationPlayState
;
using
mozilla
:
:
dom
:
:
CSSTransition
;
using
mozilla
:
:
dom
:
:
KeyframeEffectReadOnly
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
double
ElementPropertyTransition
:
:
CurrentValuePortion
(
)
const
{
MOZ_ASSERT
(
!
GetLocalTime
(
)
.
IsNull
(
)
"
Getting
the
value
portion
of
an
animation
that
'
s
not
being
"
"
sampled
"
)
;
TimingParams
timingToUse
=
SpecifiedTiming
(
)
;
timingToUse
.
SetFill
(
dom
:
:
FillMode
:
:
Both
)
;
ComputedTiming
computedTiming
=
GetComputedTiming
(
&
timingToUse
)
;
MOZ_ASSERT
(
!
computedTiming
.
mProgress
.
IsNull
(
)
"
Got
a
null
progress
for
a
fill
mode
of
'
both
'
"
)
;
MOZ_ASSERT
(
mKeyframes
.
Length
(
)
=
=
2
"
Should
have
two
animation
keyframes
for
a
transition
"
)
;
return
ComputedTimingFunction
:
:
GetPortion
(
mKeyframes
[
0
]
.
mTimingFunction
computedTiming
.
mProgress
.
Value
(
)
computedTiming
.
mBeforeFlag
)
;
}
void
ElementPropertyTransition
:
:
UpdateStartValueFromReplacedTransition
(
)
{
if
(
!
mReplacedTransition
)
{
return
;
}
MOZ_ASSERT
(
nsCSSProps
:
:
PropHasFlags
(
TransitionProperty
(
)
CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR
)
"
The
transition
property
should
be
able
to
be
run
on
the
"
"
compositor
"
)
;
MOZ_ASSERT
(
mTarget
&
&
mTarget
-
>
mElement
-
>
OwnerDoc
(
)
"
We
should
have
a
valid
document
at
this
moment
"
)
;
dom
:
:
DocumentTimeline
*
timeline
=
mTarget
-
>
mElement
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
;
ComputedTiming
computedTiming
=
GetComputedTimingAt
(
dom
:
:
CSSTransition
:
:
GetCurrentTimeAt
(
*
timeline
TimeStamp
:
:
Now
(
)
mReplacedTransition
-
>
mStartTime
mReplacedTransition
-
>
mPlaybackRate
)
mReplacedTransition
-
>
mTiming
mReplacedTransition
-
>
mPlaybackRate
)
;
if
(
!
computedTiming
.
mProgress
.
IsNull
(
)
)
{
double
valuePosition
=
ComputedTimingFunction
:
:
GetPortion
(
mReplacedTransition
-
>
mTimingFunction
computedTiming
.
mProgress
.
Value
(
)
computedTiming
.
mBeforeFlag
)
;
MOZ_ASSERT
(
mProperties
.
Length
(
)
=
=
1
&
&
mProperties
[
0
]
.
mSegments
.
Length
(
)
=
=
1
"
The
transition
should
have
one
property
and
one
segment
"
)
;
MOZ_ASSERT
(
mKeyframes
.
Length
(
)
=
=
2
"
Transitions
should
have
exactly
two
animation
keyframes
"
)
;
MOZ_ASSERT
(
mKeyframes
[
0
]
.
mPropertyValues
.
Length
(
)
=
=
1
"
Transitions
should
have
exactly
one
property
in
their
first
"
"
frame
"
)
;
const
AnimationValue
&
replacedFrom
=
mReplacedTransition
-
>
mFromValue
;
const
AnimationValue
&
replacedTo
=
mReplacedTransition
-
>
mToValue
;
AnimationValue
startValue
;
if
(
mDocument
-
>
IsStyledByServo
(
)
)
{
startValue
.
mServo
=
Servo_AnimationValues_Interpolate
(
replacedFrom
.
mServo
replacedTo
.
mServo
valuePosition
)
.
Consume
(
)
;
if
(
startValue
.
mServo
)
{
mKeyframes
[
0
]
.
mPropertyValues
[
0
]
.
mServoDeclarationBlock
=
Servo_AnimationValue_Uncompute
(
startValue
.
mServo
)
.
Consume
(
)
;
mProperties
[
0
]
.
mSegments
[
0
]
.
mFromValue
=
Move
(
startValue
)
;
}
}
else
if
(
StyleAnimationValue
:
:
Interpolate
(
mProperties
[
0
]
.
mProperty
replacedFrom
.
mGecko
replacedTo
.
mGecko
valuePosition
startValue
.
mGecko
)
)
{
nsCSSValue
cssValue
;
DebugOnly
<
bool
>
uncomputeResult
=
StyleAnimationValue
:
:
UncomputeValue
(
mProperties
[
0
]
.
mProperty
startValue
.
mGecko
cssValue
)
;
MOZ_ASSERT
(
uncomputeResult
"
UncomputeValue
should
not
fail
"
)
;
mKeyframes
[
0
]
.
mPropertyValues
[
0
]
.
mValue
=
cssValue
;
mProperties
[
0
]
.
mSegments
[
0
]
.
mFromValue
=
Move
(
startValue
)
;
}
}
mReplacedTransition
.
reset
(
)
;
}
JSObject
*
CSSTransition
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
CSSTransitionBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
CSSTransition
:
:
GetTransitionProperty
(
nsString
&
aRetVal
)
const
{
MOZ_ASSERT
(
eCSSProperty_UNKNOWN
!
=
mTransitionProperty
"
Transition
Property
should
be
initialized
"
)
;
aRetVal
=
NS_ConvertUTF8toUTF16
(
nsCSSProps
:
:
GetStringValue
(
mTransitionProperty
)
)
;
}
AnimationPlayState
CSSTransition
:
:
PlayStateFromJS
(
)
const
{
FlushStyle
(
)
;
return
Animation
:
:
PlayStateFromJS
(
)
;
}
bool
CSSTransition
:
:
PendingFromJS
(
)
const
{
if
(
Pending
(
)
)
{
FlushStyle
(
)
;
}
return
Animation
:
:
PendingFromJS
(
)
;
}
void
CSSTransition
:
:
PlayFromJS
(
ErrorResult
&
aRv
)
{
FlushStyle
(
)
;
Animation
:
:
PlayFromJS
(
aRv
)
;
}
void
CSSTransition
:
:
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
if
(
mNeedsNewAnimationIndexWhenRun
&
&
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
false
;
}
Animation
:
:
UpdateTiming
(
aSeekFlag
aSyncNotifyFlag
)
;
}
void
CSSTransition
:
:
QueueEvents
(
const
StickyTimeDuration
&
aActiveTime
)
{
if
(
!
mOwningElement
.
IsSet
(
)
)
{
return
;
}
nsPresContext
*
presContext
=
mOwningElement
.
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
static
constexpr
StickyTimeDuration
zeroDuration
=
StickyTimeDuration
(
)
;
TransitionPhase
currentPhase
;
StickyTimeDuration
intervalStartTime
;
StickyTimeDuration
intervalEndTime
;
if
(
!
mEffect
)
{
currentPhase
=
GetAnimationPhaseWithoutEffect
<
TransitionPhase
>
(
*
this
)
;
}
else
{
ComputedTiming
computedTiming
=
mEffect
-
>
GetComputedTiming
(
)
;
currentPhase
=
static_cast
<
TransitionPhase
>
(
computedTiming
.
mPhase
)
;
intervalStartTime
=
std
:
:
max
(
std
:
:
min
(
StickyTimeDuration
(
-
mEffect
-
>
SpecifiedTiming
(
)
.
Delay
(
)
)
computedTiming
.
mActiveDuration
)
zeroDuration
)
;
intervalEndTime
=
std
:
:
max
(
std
:
:
min
(
(
EffectEnd
(
)
-
mEffect
-
>
SpecifiedTiming
(
)
.
Delay
(
)
)
computedTiming
.
mActiveDuration
)
zeroDuration
)
;
}
TimeStamp
zeroTimeStamp
=
AnimationTimeToTimeStamp
(
zeroDuration
)
;
TimeStamp
startTimeStamp
=
ElapsedTimeToTimeStamp
(
intervalStartTime
)
;
TimeStamp
endTimeStamp
=
ElapsedTimeToTimeStamp
(
intervalEndTime
)
;
if
(
mPendingState
!
=
PendingState
:
:
NotPending
&
&
(
mPreviousTransitionPhase
=
=
TransitionPhase
:
:
Idle
|
|
mPreviousTransitionPhase
=
=
TransitionPhase
:
:
Pending
)
)
{
currentPhase
=
TransitionPhase
:
:
Pending
;
}
AutoTArray
<
AnimationEventInfo
3
>
events
;
auto
appendTransitionEvent
=
[
&
]
(
EventMessage
aMessage
const
StickyTimeDuration
&
aElapsedTime
const
TimeStamp
&
aTimeStamp
)
{
double
elapsedTime
=
aElapsedTime
.
ToSeconds
(
)
;
if
(
aMessage
=
=
eTransitionCancel
)
{
elapsedTime
=
nsRFPService
:
:
ReduceTimePrecisionAsSecs
(
elapsedTime
)
;
}
events
.
AppendElement
(
AnimationEventInfo
(
TransitionProperty
(
)
mOwningElement
.
Target
(
)
aMessage
elapsedTime
aTimeStamp
this
)
)
;
}
;
if
(
(
mPreviousTransitionPhase
!
=
TransitionPhase
:
:
Idle
&
&
mPreviousTransitionPhase
!
=
TransitionPhase
:
:
After
)
&
&
currentPhase
=
=
TransitionPhase
:
:
Idle
)
{
TimeStamp
activeTimeStamp
=
ElapsedTimeToTimeStamp
(
aActiveTime
)
;
appendTransitionEvent
(
eTransitionCancel
aActiveTime
activeTimeStamp
)
;
}
switch
(
mPreviousTransitionPhase
)
{
case
TransitionPhase
:
:
Idle
:
if
(
currentPhase
=
=
TransitionPhase
:
:
Pending
|
|
currentPhase
=
=
TransitionPhase
:
:
Before
)
{
appendTransitionEvent
(
eTransitionRun
intervalStartTime
zeroTimeStamp
)
;
}
else
if
(
currentPhase
=
=
TransitionPhase
:
:
Active
)
{
appendTransitionEvent
(
eTransitionRun
intervalStartTime
zeroTimeStamp
)
;
appendTransitionEvent
(
eTransitionStart
intervalStartTime
startTimeStamp
)
;
}
else
if
(
currentPhase
=
=
TransitionPhase
:
:
After
)
{
appendTransitionEvent
(
eTransitionRun
intervalStartTime
zeroTimeStamp
)
;
appendTransitionEvent
(
eTransitionStart
intervalStartTime
startTimeStamp
)
;
appendTransitionEvent
(
eTransitionEnd
intervalEndTime
endTimeStamp
)
;
}
break
;
case
TransitionPhase
:
:
Pending
:
case
TransitionPhase
:
:
Before
:
if
(
currentPhase
=
=
TransitionPhase
:
:
Active
)
{
appendTransitionEvent
(
eTransitionStart
intervalStartTime
startTimeStamp
)
;
}
else
if
(
currentPhase
=
=
TransitionPhase
:
:
After
)
{
appendTransitionEvent
(
eTransitionStart
intervalStartTime
startTimeStamp
)
;
appendTransitionEvent
(
eTransitionEnd
intervalEndTime
endTimeStamp
)
;
}
break
;
case
TransitionPhase
:
:
Active
:
if
(
currentPhase
=
=
TransitionPhase
:
:
After
)
{
appendTransitionEvent
(
eTransitionEnd
intervalEndTime
endTimeStamp
)
;
}
else
if
(
currentPhase
=
=
TransitionPhase
:
:
Before
)
{
appendTransitionEvent
(
eTransitionEnd
intervalStartTime
startTimeStamp
)
;
}
break
;
case
TransitionPhase
:
:
After
:
if
(
currentPhase
=
=
TransitionPhase
:
:
Active
)
{
appendTransitionEvent
(
eTransitionStart
intervalEndTime
startTimeStamp
)
;
}
else
if
(
currentPhase
=
=
TransitionPhase
:
:
Before
)
{
appendTransitionEvent
(
eTransitionStart
intervalEndTime
startTimeStamp
)
;
appendTransitionEvent
(
eTransitionEnd
intervalStartTime
endTimeStamp
)
;
}
break
;
}
mPreviousTransitionPhase
=
currentPhase
;
if
(
!
events
.
IsEmpty
(
)
)
{
presContext
-
>
TransitionManager
(
)
-
>
QueueEvents
(
Move
(
events
)
)
;
}
}
void
CSSTransition
:
:
Tick
(
)
{
Animation
:
:
Tick
(
)
;
QueueEvents
(
)
;
}
nsCSSPropertyID
CSSTransition
:
:
TransitionProperty
(
)
const
{
MOZ_ASSERT
(
eCSSProperty_UNKNOWN
!
=
mTransitionProperty
"
Transition
property
should
be
initialized
"
)
;
return
mTransitionProperty
;
}
AnimationValue
CSSTransition
:
:
ToValue
(
)
const
{
MOZ_ASSERT
(
!
mTransitionToValue
.
IsNull
(
)
"
Transition
ToValue
should
be
initialized
"
)
;
return
mTransitionToValue
;
}
bool
CSSTransition
:
:
HasLowerCompositeOrderThan
(
const
CSSTransition
&
aOther
)
const
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
&
&
aOther
.
IsTiedToMarkup
(
)
"
Should
only
be
called
for
CSS
transitions
that
are
sorted
"
"
as
CSS
transitions
(
i
.
e
.
tied
to
CSS
markup
)
"
)
;
if
(
&
aOther
=
=
this
)
{
return
false
;
}
if
(
!
mOwningElement
.
Equals
(
aOther
.
mOwningElement
)
)
{
return
mOwningElement
.
LessThan
(
aOther
.
mOwningElement
)
;
}
if
(
mAnimationIndex
!
=
aOther
.
mAnimationIndex
)
{
return
mAnimationIndex
<
aOther
.
mAnimationIndex
;
}
return
nsCSSProps
:
:
GetStringValue
(
TransitionProperty
(
)
)
<
nsCSSProps
:
:
GetStringValue
(
aOther
.
TransitionProperty
(
)
)
;
}
Nullable
<
TimeDuration
>
CSSTransition
:
:
GetCurrentTimeAt
(
const
dom
:
:
DocumentTimeline
&
aTimeline
const
TimeStamp
&
aBaseTime
const
TimeDuration
&
aStartTime
double
aPlaybackRate
)
{
Nullable
<
TimeDuration
>
result
;
Nullable
<
TimeDuration
>
timelineTime
=
aTimeline
.
ToTimelineTime
(
aBaseTime
)
;
if
(
!
timelineTime
.
IsNull
(
)
)
{
result
.
SetValue
(
(
timelineTime
.
Value
(
)
-
aStartTime
)
.
MultDouble
(
aPlaybackRate
)
)
;
}
return
result
;
}
void
CSSTransition
:
:
SetEffectFromStyle
(
dom
:
:
AnimationEffectReadOnly
*
aEffect
)
{
Animation
:
:
SetEffectNoUpdate
(
aEffect
)
;
ElementPropertyTransition
*
pt
=
aEffect
?
aEffect
-
>
AsTransition
(
)
:
nullptr
;
if
(
eCSSProperty_UNKNOWN
=
=
mTransitionProperty
&
&
pt
)
{
mTransitionProperty
=
pt
-
>
TransitionProperty
(
)
;
mTransitionToValue
=
pt
-
>
ToValue
(
)
;
}
}
NS_IMPL_CYCLE_COLLECTION
(
nsTransitionManager
mEventDispatcher
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
nsTransitionManager
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
nsTransitionManager
Release
)
static
inline
bool
ExtractNonDiscreteComputedValue
(
nsCSSPropertyID
aProperty
GeckoStyleContext
*
aStyleContext
AnimationValue
&
aAnimationValue
)
{
return
(
nsCSSProps
:
:
kAnimTypeTable
[
aProperty
]
!
=
eStyleAnimType_Discrete
|
|
aProperty
=
=
eCSSProperty_visibility
)
&
&
StyleAnimationValue
:
:
ExtractComputedValue
(
aProperty
aStyleContext
aAnimationValue
.
mGecko
)
;
}
static
inline
bool
ExtractNonDiscreteComputedValue
(
nsCSSPropertyID
aProperty
const
ServoStyleContext
*
aComputedStyle
AnimationValue
&
aAnimationValue
)
{
if
(
Servo_Property_IsDiscreteAnimatable
(
aProperty
)
&
&
aProperty
!
=
eCSSProperty_visibility
)
{
return
false
;
}
aAnimationValue
.
mServo
=
Servo_ComputedValues_ExtractAnimationValue
(
aComputedStyle
aProperty
)
.
Consume
(
)
;
return
!
!
aAnimationValue
.
mServo
;
}
void
nsTransitionManager
:
:
StyleContextChanged
(
dom
:
:
Element
*
aElement
GeckoStyleContext
*
aOldStyleContext
RefPtr
<
GeckoStyleContext
>
*
aNewStyleContext
)
{
GeckoStyleContext
*
newStyleContext
=
*
aNewStyleContext
;
NS_PRECONDITION
(
aOldStyleContext
-
>
GetPseudo
(
)
=
=
newStyleContext
-
>
GetPseudo
(
)
"
pseudo
type
mismatch
"
)
;
if
(
mInAnimationOnlyStyleUpdate
)
{
return
;
}
if
(
!
mPresContext
-
>
IsDynamic
(
)
)
{
return
;
}
if
(
aOldStyleContext
-
>
HasPseudoElementData
(
)
!
=
newStyleContext
-
>
HasPseudoElementData
(
)
)
{
return
;
}
const
nsStyleDisplay
*
disp
=
newStyleContext
-
>
StyleDisplay
(
)
;
CSSPseudoElementType
pseudoType
=
newStyleContext
-
>
GetPseudoType
(
)
;
if
(
pseudoType
!
=
CSSPseudoElementType
:
:
NotPseudo
)
{
if
(
pseudoType
!
=
CSSPseudoElementType
:
:
before
&
&
pseudoType
!
=
CSSPseudoElementType
:
:
after
)
{
return
;
}
NS_ASSERTION
(
(
pseudoType
=
=
CSSPseudoElementType
:
:
before
&
&
aElement
-
>
IsGeneratedContentContainerForBefore
(
)
)
|
|
(
pseudoType
=
=
CSSPseudoElementType
:
:
after
&
&
aElement
-
>
IsGeneratedContentContainerForAfter
(
)
)
"
Unexpected
aElement
coming
through
"
)
;
aElement
=
aElement
-
>
GetParent
(
)
-
>
AsElement
(
)
;
}
CSSTransitionCollection
*
collection
=
CSSTransitionCollection
:
:
GetAnimationCollection
(
aElement
pseudoType
)
;
if
(
!
collection
&
&
disp
-
>
mTransitionPropertyCount
=
=
1
&
&
disp
-
>
GetTransitionCombinedDuration
(
0
)
<
=
0
.
0f
)
{
return
;
}
MOZ_ASSERT
(
mPresContext
-
>
RestyleManager
(
)
-
>
IsGecko
(
)
"
ServoRestyleManager
should
not
use
nsTransitionManager
"
"
for
transitions
"
)
;
if
(
collection
&
&
collection
-
>
mCheckGeneration
=
=
mPresContext
-
>
RestyleManager
(
)
-
>
GetAnimationGeneration
(
)
)
{
return
;
}
if
(
newStyleContext
-
>
GetParent
(
)
&
&
newStyleContext
-
>
GetParent
(
)
-
>
HasPseudoElementData
(
)
)
{
return
;
}
NS_WARNING_ASSERTION
(
!
mPresContext
-
>
EffectCompositor
(
)
-
>
HasThrottledStyleUpdates
(
)
"
throttled
animations
not
up
to
date
"
)
;
RefPtr
<
GeckoStyleContext
>
afterChangeStyle
;
if
(
collection
)
{
MOZ_ASSERT
(
mPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ServoStyleSets
should
not
use
nsTransitionManager
"
"
for
transitions
"
)
;
nsStyleSet
*
styleSet
=
mPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
;
afterChangeStyle
=
styleSet
-
>
ResolveStyleByRemovingAnimation
(
aElement
newStyleContext
eRestyle_CSSTransitions
)
;
}
else
{
afterChangeStyle
=
newStyleContext
;
}
nsAutoAnimationMutationBatch
mb
(
aElement
-
>
OwnerDoc
(
)
)
;
DebugOnly
<
bool
>
startedAny
=
false
;
if
(
!
afterChangeStyle
-
>
IsInDisplayNoneSubtree
(
)
)
{
startedAny
=
DoUpdateTransitions
(
*
disp
aElement
afterChangeStyle
-
>
GetPseudoType
(
)
collection
aOldStyleContext
-
>
AsGecko
(
)
afterChangeStyle
-
>
AsGecko
(
)
)
;
}
MOZ_ASSERT
(
!
startedAny
|
|
collection
"
must
have
element
transitions
if
we
started
any
transitions
"
)
;
EffectCompositor
:
:
CascadeLevel
cascadeLevel
=
EffectCompositor
:
:
CascadeLevel
:
:
Transitions
;
if
(
collection
)
{
collection
-
>
UpdateCheckGeneration
(
mPresContext
)
;
mPresContext
-
>
EffectCompositor
(
)
-
>
MaybeUpdateAnimationRule
(
aElement
pseudoType
cascadeLevel
newStyleContext
)
;
}
*
aNewStyleContext
=
afterChangeStyle
;
if
(
collection
)
{
mPresContext
-
>
EffectCompositor
(
)
-
>
PostRestyleForAnimation
(
aElement
pseudoType
cascadeLevel
)
;
}
}
bool
nsTransitionManager
:
:
UpdateTransitions
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
const
ServoStyleContext
*
aOldStyle
const
ServoStyleContext
*
aNewStyle
)
{
if
(
!
mPresContext
-
>
IsDynamic
(
)
)
{
return
false
;
}
CSSTransitionCollection
*
collection
=
CSSTransitionCollection
:
:
GetAnimationCollection
(
aElement
aPseudoType
)
;
const
nsStyleDisplay
*
disp
=
aNewStyle
-
>
ComputedData
(
)
-
>
GetStyleDisplay
(
)
;
return
DoUpdateTransitions
(
*
disp
aElement
aPseudoType
collection
aOldStyle
aNewStyle
)
;
}
template
<
typename
StyleType
>
bool
nsTransitionManager
:
:
DoUpdateTransitions
(
const
nsStyleDisplay
&
aDisp
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
CSSTransitionCollection
*
&
aElementTransitions
StyleType
aOldStyle
StyleType
aNewStyle
)
{
MOZ_ASSERT
(
!
aElementTransitions
|
|
aElementTransitions
-
>
mElement
=
=
aElement
"
Element
mismatch
"
)
;
bool
startedAny
=
false
;
nsCSSPropertyIDSet
whichStarted
;
for
(
uint32_t
i
=
aDisp
.
mTransitionPropertyCount
;
i
-
-
!
=
0
;
)
{
if
(
aDisp
.
GetTransitionCombinedDuration
(
i
)
>
0
.
0f
)
{
nsCSSPropertyID
property
=
aDisp
.
GetTransitionProperty
(
i
)
;
if
(
property
=
=
eCSSPropertyExtra_no_properties
|
|
property
=
=
eCSSPropertyExtra_variable
|
|
property
=
=
eCSSProperty_UNKNOWN
)
{
}
else
if
(
property
=
=
eCSSPropertyExtra_all_properties
)
{
for
(
nsCSSPropertyID
p
=
nsCSSPropertyID
(
0
)
;
p
<
eCSSProperty_COUNT_no_shorthands
;
p
=
nsCSSPropertyID
(
p
+
1
)
)
{
ConsiderInitiatingTransition
(
p
aDisp
i
aElement
aPseudoType
aElementTransitions
aOldStyle
aNewStyle
&
startedAny
&
whichStarted
)
;
}
}
else
if
(
nsCSSProps
:
:
IsShorthand
(
property
)
)
{
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
subprop
property
CSSEnabledState
:
:
eForAllContent
)
{
ConsiderInitiatingTransition
(
*
subprop
aDisp
i
aElement
aPseudoType
aElementTransitions
aOldStyle
aNewStyle
&
startedAny
&
whichStarted
)
;
}
}
else
{
ConsiderInitiatingTransition
(
property
aDisp
i
aElement
aPseudoType
aElementTransitions
aOldStyle
aNewStyle
&
startedAny
&
whichStarted
)
;
}
}
}
if
(
aElementTransitions
)
{
bool
checkProperties
=
aDisp
.
GetTransitionProperty
(
0
)
!
=
eCSSPropertyExtra_all_properties
;
nsCSSPropertyIDSet
allTransitionProperties
;
if
(
checkProperties
)
{
for
(
uint32_t
i
=
aDisp
.
mTransitionPropertyCount
;
i
-
-
!
=
0
;
)
{
nsCSSPropertyID
property
=
aDisp
.
GetTransitionProperty
(
i
)
;
if
(
property
=
=
eCSSPropertyExtra_no_properties
|
|
property
=
=
eCSSPropertyExtra_variable
|
|
property
=
=
eCSSProperty_UNKNOWN
)
{
}
else
if
(
property
=
=
eCSSPropertyExtra_all_properties
)
{
for
(
nsCSSPropertyID
p
=
nsCSSPropertyID
(
0
)
;
p
<
eCSSProperty_COUNT_no_shorthands
;
p
=
nsCSSPropertyID
(
p
+
1
)
)
{
allTransitionProperties
.
AddProperty
(
p
)
;
}
}
else
if
(
nsCSSProps
:
:
IsShorthand
(
property
)
)
{
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
subprop
property
CSSEnabledState
:
:
eForAllContent
)
{
allTransitionProperties
.
AddProperty
(
*
subprop
)
;
}
}
else
{
allTransitionProperties
.
AddProperty
(
property
)
;
}
}
}
OwningCSSTransitionPtrArray
&
animations
=
aElementTransitions
-
>
mAnimations
;
size_t
i
=
animations
.
Length
(
)
;
MOZ_ASSERT
(
i
!
=
0
"
empty
transitions
list
?
"
)
;
AnimationValue
currentValue
;
do
{
-
-
i
;
CSSTransition
*
anim
=
animations
[
i
]
;
if
(
(
checkProperties
&
&
!
allTransitionProperties
.
HasProperty
(
anim
-
>
TransitionProperty
(
)
)
)
|
|
!
ExtractNonDiscreteComputedValue
(
anim
-
>
TransitionProperty
(
)
aNewStyle
currentValue
)
|
|
currentValue
!
=
anim
-
>
ToValue
(
)
)
{
if
(
anim
-
>
HasCurrentEffect
(
)
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
effectSet
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
}
anim
-
>
CancelFromStyle
(
)
;
animations
.
RemoveElementAt
(
i
)
;
}
}
while
(
i
!
=
0
)
;
if
(
animations
.
IsEmpty
(
)
)
{
aElementTransitions
-
>
Destroy
(
)
;
aElementTransitions
=
nullptr
;
}
}
return
startedAny
;
}
static
Keyframe
&
AppendKeyframe
(
double
aOffset
nsCSSPropertyID
aProperty
AnimationValue
&
&
aValue
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
Keyframe
&
frame
=
*
aKeyframes
.
AppendElement
(
)
;
frame
.
mOffset
.
emplace
(
aOffset
)
;
if
(
aValue
.
mServo
)
{
RefPtr
<
RawServoDeclarationBlock
>
decl
=
Servo_AnimationValue_Uncompute
(
aValue
.
mServo
)
.
Consume
(
)
;
frame
.
mPropertyValues
.
AppendElement
(
Move
(
PropertyValuePair
(
aProperty
Move
(
decl
)
)
)
)
;
}
else
{
nsCSSValue
propertyValue
;
DebugOnly
<
bool
>
uncomputeResult
=
StyleAnimationValue
:
:
UncomputeValue
(
aProperty
Move
(
aValue
.
mGecko
)
propertyValue
)
;
MOZ_ASSERT
(
uncomputeResult
"
Unable
to
get
specified
value
from
computed
value
"
)
;
frame
.
mPropertyValues
.
AppendElement
(
Move
(
PropertyValuePair
(
aProperty
Move
(
propertyValue
)
)
)
)
;
}
return
frame
;
}
static
nsTArray
<
Keyframe
>
GetTransitionKeyframes
(
nsCSSPropertyID
aProperty
AnimationValue
&
&
aStartValue
AnimationValue
&
&
aEndValue
const
nsTimingFunction
&
aTimingFunction
)
{
nsTArray
<
Keyframe
>
keyframes
(
2
)
;
Keyframe
&
fromFrame
=
AppendKeyframe
(
0
.
0
aProperty
Move
(
aStartValue
)
keyframes
)
;
if
(
aTimingFunction
.
mType
!
=
nsTimingFunction
:
:
Type
:
:
Linear
)
{
fromFrame
.
mTimingFunction
.
emplace
(
)
;
fromFrame
.
mTimingFunction
-
>
Init
(
aTimingFunction
)
;
}
AppendKeyframe
(
1
.
0
aProperty
Move
(
aEndValue
)
keyframes
)
;
return
keyframes
;
}
static
bool
IsTransitionable
(
nsCSSPropertyID
aProperty
bool
aIsServo
)
{
if
(
aIsServo
)
{
return
Servo_Property_IsTransitionable
(
aProperty
)
;
}
return
nsCSSProps
:
:
kAnimTypeTable
[
aProperty
]
!
=
eStyleAnimType_None
;
}
template
<
typename
StyleType
>
void
nsTransitionManager
:
:
ConsiderInitiatingTransition
(
nsCSSPropertyID
aProperty
const
nsStyleDisplay
&
aStyleDisplay
uint32_t
transitionIdx
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
CSSTransitionCollection
*
&
aElementTransitions
StyleType
aOldStyle
StyleType
aNewStyle
bool
*
aStartedAny
nsCSSPropertyIDSet
*
aWhichStarted
)
{
MOZ_ASSERT
(
!
nsCSSProps
:
:
IsShorthand
(
aProperty
)
"
property
out
of
range
"
)
;
NS_ASSERTION
(
!
aElementTransitions
|
|
aElementTransitions
-
>
mElement
=
=
aElement
"
Element
mismatch
"
)
;
if
(
!
nsCSSProps
:
:
IsEnabled
(
aProperty
CSSEnabledState
:
:
eForAllContent
)
)
{
return
;
}
if
(
aWhichStarted
-
>
HasProperty
(
aProperty
)
)
{
return
;
}
if
(
!
IsTransitionable
(
aProperty
aElement
-
>
IsStyledByServo
(
)
)
)
{
return
;
}
dom
:
:
DocumentTimeline
*
timeline
=
aElement
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
;
AnimationValue
startValue
endValue
;
bool
haveValues
=
ExtractNonDiscreteComputedValue
(
aProperty
aOldStyle
startValue
)
&
&
ExtractNonDiscreteComputedValue
(
aProperty
aNewStyle
endValue
)
;
bool
haveChange
=
startValue
!
=
endValue
;
bool
shouldAnimate
=
haveValues
&
&
haveChange
&
&
startValue
.
IsInterpolableWith
(
aProperty
endValue
)
;
bool
haveCurrentTransition
=
false
;
size_t
currentIndex
=
nsTArray
<
ElementPropertyTransition
>
:
:
NoIndex
;
const
ElementPropertyTransition
*
oldPT
=
nullptr
;
if
(
aElementTransitions
)
{
OwningCSSTransitionPtrArray
&
animations
=
aElementTransitions
-
>
mAnimations
;
for
(
size_t
i
=
0
i_end
=
animations
.
Length
(
)
;
i
<
i_end
;
+
+
i
)
{
if
(
animations
[
i
]
-
>
TransitionProperty
(
)
=
=
aProperty
)
{
haveCurrentTransition
=
true
;
currentIndex
=
i
;
oldPT
=
animations
[
i
]
-
>
GetEffect
(
)
?
animations
[
i
]
-
>
GetEffect
(
)
-
>
AsTransition
(
)
:
nullptr
;
break
;
}
}
}
if
(
haveCurrentTransition
&
&
haveValues
&
&
aElementTransitions
-
>
mAnimations
[
currentIndex
]
-
>
ToValue
(
)
=
=
endValue
)
{
return
;
}
if
(
!
shouldAnimate
)
{
if
(
haveCurrentTransition
)
{
OwningCSSTransitionPtrArray
&
animations
=
aElementTransitions
-
>
mAnimations
;
animations
[
currentIndex
]
-
>
CancelFromStyle
(
)
;
oldPT
=
nullptr
;
animations
.
RemoveElementAt
(
currentIndex
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
effectSet
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
if
(
animations
.
IsEmpty
(
)
)
{
aElementTransitions
-
>
Destroy
(
)
;
aElementTransitions
=
nullptr
;
}
}
return
;
}
const
nsTimingFunction
&
tf
=
aStyleDisplay
.
GetTransitionTimingFunction
(
transitionIdx
)
;
float
delay
=
aStyleDisplay
.
GetTransitionDelay
(
transitionIdx
)
;
float
duration
=
aStyleDisplay
.
GetTransitionDuration
(
transitionIdx
)
;
if
(
duration
<
0
.
0
)
{
duration
=
0
.
0
;
}
AnimationValue
startForReversingTest
=
startValue
;
double
reversePortion
=
1
.
0
;
if
(
haveCurrentTransition
&
&
aElementTransitions
-
>
mAnimations
[
currentIndex
]
-
>
HasCurrentEffect
(
)
&
&
oldPT
&
&
oldPT
-
>
mStartForReversingTest
=
=
endValue
)
{
double
valuePortion
=
oldPT
-
>
CurrentValuePortion
(
)
*
oldPT
-
>
mReversePortion
+
(
1
.
0
-
oldPT
-
>
mReversePortion
)
;
if
(
valuePortion
<
0
.
0
)
{
valuePortion
=
-
valuePortion
;
}
if
(
valuePortion
>
1
.
0
)
{
valuePortion
=
1
.
0
;
}
if
(
delay
<
0
.
0f
)
{
delay
*
=
valuePortion
;
}
duration
*
=
valuePortion
;
startForReversingTest
=
oldPT
-
>
ToValue
(
)
;
reversePortion
=
valuePortion
;
}
TimingParams
timing
=
TimingParamsFromCSSParams
(
duration
delay
1
.
0
dom
:
:
PlaybackDirection
:
:
Normal
dom
:
:
FillMode
:
:
Backwards
)
;
Maybe
<
OwningAnimationTarget
>
target
;
target
.
emplace
(
aElement
aPseudoType
)
;
KeyframeEffectParams
effectOptions
;
RefPtr
<
ElementPropertyTransition
>
pt
=
new
ElementPropertyTransition
(
aElement
-
>
OwnerDoc
(
)
target
timing
startForReversingTest
reversePortion
effectOptions
)
;
pt
-
>
SetKeyframes
(
GetTransitionKeyframes
(
aProperty
Move
(
startValue
)
Move
(
endValue
)
tf
)
aNewStyle
)
;
RefPtr
<
CSSTransition
>
animation
=
new
CSSTransition
(
mPresContext
-
>
Document
(
)
-
>
GetScopeObject
(
)
)
;
animation
-
>
SetOwningElement
(
OwningElementRef
(
*
aElement
aPseudoType
)
)
;
animation
-
>
SetTimelineNoUpdate
(
timeline
)
;
animation
-
>
SetCreationSequence
(
mPresContext
-
>
RestyleManager
(
)
-
>
GetAnimationGeneration
(
)
)
;
animation
-
>
SetEffectFromStyle
(
pt
)
;
animation
-
>
PlayFromStyle
(
)
;
if
(
!
aElementTransitions
)
{
bool
createdCollection
=
false
;
aElementTransitions
=
CSSTransitionCollection
:
:
GetOrCreateAnimationCollection
(
aElement
aPseudoType
&
createdCollection
)
;
if
(
!
aElementTransitions
)
{
MOZ_ASSERT
(
!
createdCollection
"
outparam
should
agree
with
return
value
"
)
;
NS_WARNING
(
"
allocating
collection
failed
"
)
;
return
;
}
if
(
createdCollection
)
{
AddElementCollection
(
aElementTransitions
)
;
}
}
OwningCSSTransitionPtrArray
&
animations
=
aElementTransitions
-
>
mAnimations
;
#
ifdef
DEBUG
for
(
size_t
i
=
0
i_end
=
animations
.
Length
(
)
;
i
<
i_end
;
+
+
i
)
{
MOZ_ASSERT
(
i
=
=
currentIndex
|
|
animations
[
i
]
-
>
TransitionProperty
(
)
!
=
aProperty
"
duplicate
transitions
for
property
"
)
;
}
#
endif
if
(
haveCurrentTransition
)
{
if
(
oldPT
&
&
oldPT
-
>
IsCurrent
(
)
&
&
oldPT
-
>
IsRunningOnCompositor
(
)
&
&
!
oldPT
-
>
GetAnimation
(
)
-
>
GetStartTime
(
)
.
IsNull
(
)
&
&
timeline
=
=
oldPT
-
>
GetAnimation
(
)
-
>
GetTimeline
(
)
)
{
const
AnimationPropertySegment
&
segment
=
oldPT
-
>
Properties
(
)
[
0
]
.
mSegments
[
0
]
;
pt
-
>
mReplacedTransition
.
emplace
(
ElementPropertyTransition
:
:
ReplacedTransitionProperties
(
{
oldPT
-
>
GetAnimation
(
)
-
>
GetStartTime
(
)
.
Value
(
)
oldPT
-
>
GetAnimation
(
)
-
>
PlaybackRate
(
)
oldPT
-
>
SpecifiedTiming
(
)
segment
.
mTimingFunction
segment
.
mFromValue
segment
.
mToValue
}
)
)
;
}
animations
[
currentIndex
]
-
>
CancelFromStyle
(
)
;
oldPT
=
nullptr
;
animations
[
currentIndex
]
=
animation
;
}
else
{
if
(
!
animations
.
AppendElement
(
animation
)
)
{
NS_WARNING
(
"
out
of
memory
"
)
;
return
;
}
}
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
effectSet
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
*
aStartedAny
=
true
;
aWhichStarted
-
>
AddProperty
(
aProperty
)
;
}
void
nsTransitionManager
:
:
PruneCompletedTransitions
(
mozilla
:
:
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
GeckoStyleContext
*
aNewStyleContext
)
{
MOZ_ASSERT
(
!
aElement
-
>
IsGeneratedContentContainerForBefore
(
)
&
&
!
aElement
-
>
IsGeneratedContentContainerForAfter
(
)
)
;
CSSTransitionCollection
*
collection
=
CSSTransitionCollection
:
:
GetAnimationCollection
(
aElement
aPseudoType
)
;
if
(
!
collection
)
{
return
;
}
OwningCSSTransitionPtrArray
&
animations
=
collection
-
>
mAnimations
;
size_t
i
=
animations
.
Length
(
)
;
MOZ_ASSERT
(
i
!
=
0
"
empty
transitions
list
?
"
)
;
do
{
-
-
i
;
CSSTransition
*
anim
=
animations
[
i
]
;
if
(
anim
-
>
HasCurrentEffect
(
)
)
{
continue
;
}
AnimationValue
currentValue
;
if
(
!
ExtractNonDiscreteComputedValue
(
anim
-
>
TransitionProperty
(
)
aNewStyleContext
currentValue
)
|
|
currentValue
!
=
anim
-
>
ToValue
(
)
)
{
anim
-
>
CancelFromStyle
(
)
;
animations
.
RemoveElementAt
(
i
)
;
}
}
while
(
i
!
=
0
)
;
if
(
collection
-
>
mAnimations
.
IsEmpty
(
)
)
{
collection
-
>
Destroy
(
)
;
collection
=
nullptr
;
}
}
