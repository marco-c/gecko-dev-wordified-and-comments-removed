#
include
"
nsTransitionManager
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
Layers
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsRFPService
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
using
mozilla
:
:
dom
:
:
CSSTransition
;
using
mozilla
:
:
dom
:
:
DocumentTimeline
;
using
mozilla
:
:
dom
:
:
KeyframeEffect
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
static
inline
bool
ExtractNonDiscreteComputedValue
(
nsCSSPropertyID
aProperty
const
ComputedStyle
&
aComputedStyle
AnimationValue
&
aAnimationValue
)
{
if
(
Servo_Property_IsDiscreteAnimatable
(
aProperty
)
&
&
aProperty
!
=
eCSSProperty_visibility
)
{
return
false
;
}
aAnimationValue
.
mServo
=
Servo_ComputedValues_ExtractAnimationValue
(
&
aComputedStyle
aProperty
)
.
Consume
(
)
;
return
!
!
aAnimationValue
.
mServo
;
}
bool
nsTransitionManager
:
:
UpdateTransitions
(
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
const
ComputedStyle
&
aOldStyle
const
ComputedStyle
&
aNewStyle
)
{
if
(
!
mPresContext
-
>
IsDynamic
(
)
)
{
return
false
;
}
if
(
aNewStyle
.
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
{
StopAnimationsForElement
(
aElement
aPseudoType
)
;
return
false
;
}
CSSTransitionCollection
*
collection
=
CSSTransitionCollection
:
:
GetAnimationCollection
(
aElement
aPseudoType
)
;
return
DoUpdateTransitions
(
*
aNewStyle
.
StyleUIReset
(
)
aElement
aPseudoType
collection
aOldStyle
aNewStyle
)
;
}
bool
nsTransitionManager
:
:
DoUpdateTransitions
(
const
nsStyleUIReset
&
aStyle
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
CSSTransitionCollection
*
&
aElementTransitions
const
ComputedStyle
&
aOldStyle
const
ComputedStyle
&
aNewStyle
)
{
MOZ_ASSERT
(
!
aElementTransitions
|
|
aElementTransitions
-
>
mElement
=
=
aElement
"
Element
mismatch
"
)
;
bool
startedAny
=
false
;
nsCSSPropertyIDSet
propertiesChecked
;
for
(
uint32_t
i
=
aStyle
.
mTransitionPropertyCount
;
i
-
-
;
)
{
if
(
i
=
=
0
&
&
aStyle
.
GetTransitionCombinedDuration
(
i
)
<
=
0
.
0f
)
{
continue
;
}
nsCSSPropertyID
property
=
aStyle
.
GetTransitionProperty
(
i
)
;
if
(
property
=
=
eCSSPropertyExtra_no_properties
|
|
property
=
=
eCSSPropertyExtra_variable
|
|
property
=
=
eCSSProperty_UNKNOWN
)
{
continue
;
}
if
(
property
=
=
eCSSPropertyExtra_all_properties
)
{
for
(
nsCSSPropertyID
p
=
nsCSSPropertyID
(
0
)
;
p
<
eCSSProperty_COUNT_no_shorthands
;
p
=
nsCSSPropertyID
(
p
+
1
)
)
{
if
(
!
nsCSSProps
:
:
IsEnabled
(
p
CSSEnabledState
:
:
ForAllContent
)
)
{
continue
;
}
startedAny
|
=
ConsiderInitiatingTransition
(
p
aStyle
i
aElement
aPseudoType
aElementTransitions
aOldStyle
aNewStyle
propertiesChecked
)
;
}
}
else
if
(
nsCSSProps
:
:
IsShorthand
(
property
)
)
{
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
subprop
property
CSSEnabledState
:
:
ForAllContent
)
{
startedAny
|
=
ConsiderInitiatingTransition
(
*
subprop
aStyle
i
aElement
aPseudoType
aElementTransitions
aOldStyle
aNewStyle
propertiesChecked
)
;
}
}
else
{
startedAny
|
=
ConsiderInitiatingTransition
(
property
aStyle
i
aElement
aPseudoType
aElementTransitions
aOldStyle
aNewStyle
propertiesChecked
)
;
}
}
if
(
aElementTransitions
)
{
bool
checkProperties
=
aStyle
.
GetTransitionProperty
(
0
)
!
=
eCSSPropertyExtra_all_properties
;
nsCSSPropertyIDSet
allTransitionProperties
;
if
(
checkProperties
)
{
for
(
uint32_t
i
=
aStyle
.
mTransitionPropertyCount
;
i
-
-
!
=
0
;
)
{
nsCSSPropertyID
property
=
aStyle
.
GetTransitionProperty
(
i
)
;
if
(
property
=
=
eCSSPropertyExtra_no_properties
|
|
property
=
=
eCSSPropertyExtra_variable
|
|
property
=
=
eCSSProperty_UNKNOWN
)
{
}
else
if
(
property
=
=
eCSSPropertyExtra_all_properties
)
{
for
(
nsCSSPropertyID
p
=
nsCSSPropertyID
(
0
)
;
p
<
eCSSProperty_COUNT_no_shorthands
;
p
=
nsCSSPropertyID
(
p
+
1
)
)
{
allTransitionProperties
.
AddProperty
(
nsCSSProps
:
:
Physicalize
(
p
aNewStyle
)
)
;
}
}
else
if
(
nsCSSProps
:
:
IsShorthand
(
property
)
)
{
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
subprop
property
CSSEnabledState
:
:
ForAllContent
)
{
auto
p
=
nsCSSProps
:
:
Physicalize
(
*
subprop
aNewStyle
)
;
allTransitionProperties
.
AddProperty
(
p
)
;
}
}
else
{
allTransitionProperties
.
AddProperty
(
nsCSSProps
:
:
Physicalize
(
property
aNewStyle
)
)
;
}
}
}
OwningCSSTransitionPtrArray
&
animations
=
aElementTransitions
-
>
mAnimations
;
size_t
i
=
animations
.
Length
(
)
;
MOZ_ASSERT
(
i
!
=
0
"
empty
transitions
list
?
"
)
;
AnimationValue
currentValue
;
do
{
-
-
i
;
CSSTransition
*
anim
=
animations
[
i
]
;
if
(
(
checkProperties
&
&
!
allTransitionProperties
.
HasProperty
(
anim
-
>
TransitionProperty
(
)
)
)
|
|
!
ExtractNonDiscreteComputedValue
(
anim
-
>
TransitionProperty
(
)
aNewStyle
currentValue
)
|
|
currentValue
!
=
anim
-
>
ToValue
(
)
)
{
if
(
anim
-
>
HasCurrentEffect
(
)
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
effectSet
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
}
anim
-
>
CancelFromStyle
(
PostRestyleMode
:
:
IfNeeded
)
;
animations
.
RemoveElementAt
(
i
)
;
}
}
while
(
i
!
=
0
)
;
if
(
animations
.
IsEmpty
(
)
)
{
aElementTransitions
-
>
Destroy
(
)
;
aElementTransitions
=
nullptr
;
}
}
return
startedAny
;
}
static
Keyframe
&
AppendKeyframe
(
double
aOffset
nsCSSPropertyID
aProperty
AnimationValue
&
&
aValue
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
Keyframe
&
frame
=
*
aKeyframes
.
AppendElement
(
)
;
frame
.
mOffset
.
emplace
(
aOffset
)
;
MOZ_ASSERT
(
aValue
.
mServo
)
;
RefPtr
<
RawServoDeclarationBlock
>
decl
=
Servo_AnimationValue_Uncompute
(
aValue
.
mServo
)
.
Consume
(
)
;
frame
.
mPropertyValues
.
AppendElement
(
PropertyValuePair
(
aProperty
std
:
:
move
(
decl
)
)
)
;
return
frame
;
}
static
nsTArray
<
Keyframe
>
GetTransitionKeyframes
(
nsCSSPropertyID
aProperty
AnimationValue
&
&
aStartValue
AnimationValue
&
&
aEndValue
)
{
nsTArray
<
Keyframe
>
keyframes
(
2
)
;
AppendKeyframe
(
0
.
0
aProperty
std
:
:
move
(
aStartValue
)
keyframes
)
;
AppendKeyframe
(
1
.
0
aProperty
std
:
:
move
(
aEndValue
)
keyframes
)
;
return
keyframes
;
}
static
bool
IsTransitionable
(
nsCSSPropertyID
aProperty
)
{
return
Servo_Property_IsTransitionable
(
aProperty
)
;
}
static
Maybe
<
CSSTransition
:
:
ReplacedTransitionProperties
>
GetReplacedTransitionProperties
(
const
CSSTransition
*
aTransition
const
DocumentTimeline
*
aTimelineToMatch
)
{
Maybe
<
CSSTransition
:
:
ReplacedTransitionProperties
>
result
;
if
(
!
aTransition
|
|
!
aTransition
-
>
HasCurrentEffect
(
)
|
|
!
aTransition
-
>
IsRunningOnCompositor
(
)
|
|
aTransition
-
>
GetStartTime
(
)
.
IsNull
(
)
)
{
return
result
;
}
if
(
aTransition
-
>
GetTimeline
(
)
!
=
aTimelineToMatch
)
{
return
result
;
}
const
KeyframeEffect
*
keyframeEffect
=
aTransition
-
>
GetEffect
(
)
?
aTransition
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
:
nullptr
;
if
(
!
keyframeEffect
)
{
return
result
;
}
if
(
keyframeEffect
-
>
Properties
(
)
.
Length
(
)
!
=
1
|
|
keyframeEffect
-
>
Properties
(
)
[
0
]
.
mSegments
.
Length
(
)
!
=
1
|
|
keyframeEffect
-
>
Properties
(
)
[
0
]
.
mProperty
!
=
aTransition
-
>
TransitionProperty
(
)
)
{
return
result
;
}
const
AnimationPropertySegment
&
segment
=
keyframeEffect
-
>
Properties
(
)
[
0
]
.
mSegments
[
0
]
;
result
.
emplace
(
CSSTransition
:
:
ReplacedTransitionProperties
(
{
aTransition
-
>
GetStartTime
(
)
.
Value
(
)
aTransition
-
>
PlaybackRate
(
)
keyframeEffect
-
>
SpecifiedTiming
(
)
segment
.
mTimingFunction
segment
.
mFromValue
segment
.
mToValue
}
)
)
;
return
result
;
}
bool
nsTransitionManager
:
:
ConsiderInitiatingTransition
(
nsCSSPropertyID
aProperty
const
nsStyleUIReset
&
aStyle
uint32_t
transitionIdx
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
CSSTransitionCollection
*
&
aElementTransitions
const
ComputedStyle
&
aOldStyle
const
ComputedStyle
&
aNewStyle
nsCSSPropertyIDSet
&
aPropertiesChecked
)
{
MOZ_ASSERT
(
!
nsCSSProps
:
:
IsShorthand
(
aProperty
)
"
property
out
of
range
"
)
;
NS_ASSERTION
(
!
aElementTransitions
|
|
aElementTransitions
-
>
mElement
=
=
aElement
"
Element
mismatch
"
)
;
aProperty
=
nsCSSProps
:
:
Physicalize
(
aProperty
aNewStyle
)
;
if
(
aPropertiesChecked
.
HasProperty
(
aProperty
)
)
{
return
false
;
}
aPropertiesChecked
.
AddProperty
(
aProperty
)
;
if
(
!
IsTransitionable
(
aProperty
)
)
{
return
false
;
}
float
delay
=
aStyle
.
GetTransitionDelay
(
transitionIdx
)
;
float
duration
=
std
:
:
max
(
aStyle
.
GetTransitionDuration
(
transitionIdx
)
0
.
0f
)
;
if
(
delay
+
duration
<
=
0
.
0f
)
{
return
false
;
}
dom
:
:
DocumentTimeline
*
timeline
=
aElement
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
;
AnimationValue
startValue
endValue
;
bool
haveValues
=
ExtractNonDiscreteComputedValue
(
aProperty
aOldStyle
startValue
)
&
&
ExtractNonDiscreteComputedValue
(
aProperty
aNewStyle
endValue
)
;
bool
haveChange
=
startValue
!
=
endValue
;
bool
shouldAnimate
=
haveValues
&
&
haveChange
&
&
startValue
.
IsInterpolableWith
(
aProperty
endValue
)
;
bool
haveCurrentTransition
=
false
;
size_t
currentIndex
=
nsTArray
<
KeyframeEffect
>
:
:
NoIndex
;
const
CSSTransition
*
oldTransition
=
nullptr
;
if
(
aElementTransitions
)
{
OwningCSSTransitionPtrArray
&
animations
=
aElementTransitions
-
>
mAnimations
;
for
(
size_t
i
=
0
i_end
=
animations
.
Length
(
)
;
i
<
i_end
;
+
+
i
)
{
if
(
animations
[
i
]
-
>
TransitionProperty
(
)
=
=
aProperty
)
{
haveCurrentTransition
=
true
;
currentIndex
=
i
;
oldTransition
=
animations
[
i
]
;
break
;
}
}
}
if
(
haveCurrentTransition
&
&
haveValues
&
&
aElementTransitions
-
>
mAnimations
[
currentIndex
]
-
>
ToValue
(
)
=
=
endValue
)
{
return
false
;
}
if
(
!
shouldAnimate
)
{
if
(
haveCurrentTransition
)
{
OwningCSSTransitionPtrArray
&
animations
=
aElementTransitions
-
>
mAnimations
;
animations
[
currentIndex
]
-
>
CancelFromStyle
(
PostRestyleMode
:
:
IfNeeded
)
;
oldTransition
=
nullptr
;
animations
.
RemoveElementAt
(
currentIndex
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
effectSet
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
if
(
animations
.
IsEmpty
(
)
)
{
aElementTransitions
-
>
Destroy
(
)
;
aElementTransitions
=
nullptr
;
}
}
return
false
;
}
AnimationValue
startForReversingTest
=
startValue
;
double
reversePortion
=
1
.
0
;
if
(
haveCurrentTransition
&
&
aElementTransitions
-
>
mAnimations
[
currentIndex
]
-
>
HasCurrentEffect
(
)
&
&
oldTransition
&
&
oldTransition
-
>
StartForReversingTest
(
)
=
=
endValue
)
{
double
valuePortion
=
oldTransition
-
>
CurrentValuePortion
(
)
*
oldTransition
-
>
ReversePortion
(
)
+
(
1
.
0
-
oldTransition
-
>
ReversePortion
(
)
)
;
if
(
valuePortion
<
0
.
0
)
{
valuePortion
=
-
valuePortion
;
}
if
(
valuePortion
>
1
.
0
)
{
valuePortion
=
1
.
0
;
}
if
(
delay
<
0
.
0f
)
{
delay
*
=
valuePortion
;
}
duration
*
=
valuePortion
;
startForReversingTest
=
oldTransition
-
>
ToValue
(
)
;
reversePortion
=
valuePortion
;
}
TimingParams
timing
=
TimingParamsFromCSSParams
(
duration
delay
1
.
0
dom
:
:
PlaybackDirection
:
:
Normal
dom
:
:
FillMode
:
:
Backwards
)
;
const
nsTimingFunction
&
tf
=
aStyle
.
GetTransitionTimingFunction
(
transitionIdx
)
;
if
(
!
tf
.
IsLinear
(
)
)
{
timing
.
SetTimingFunction
(
Some
(
ComputedTimingFunction
(
tf
)
)
)
;
}
KeyframeEffectParams
effectOptions
;
RefPtr
<
KeyframeEffect
>
keyframeEffect
=
new
KeyframeEffect
(
aElement
-
>
OwnerDoc
(
)
OwningAnimationTarget
(
aElement
aPseudoType
)
std
:
:
move
(
timing
)
effectOptions
)
;
keyframeEffect
-
>
SetKeyframes
(
GetTransitionKeyframes
(
aProperty
std
:
:
move
(
startValue
)
std
:
:
move
(
endValue
)
)
&
aNewStyle
)
;
if
(
NS_WARN_IF
(
MOZ_UNLIKELY
(
!
keyframeEffect
-
>
IsValidTransition
(
)
)
)
)
{
return
false
;
}
RefPtr
<
CSSTransition
>
animation
=
new
CSSTransition
(
mPresContext
-
>
Document
(
)
-
>
GetScopeObject
(
)
)
;
animation
-
>
SetOwningElement
(
OwningElementRef
(
*
aElement
aPseudoType
)
)
;
animation
-
>
SetTimelineNoUpdate
(
timeline
)
;
animation
-
>
SetCreationSequence
(
mPresContext
-
>
RestyleManager
(
)
-
>
GetAnimationGeneration
(
)
)
;
animation
-
>
SetEffectFromStyle
(
keyframeEffect
)
;
animation
-
>
SetReverseParameters
(
std
:
:
move
(
startForReversingTest
)
reversePortion
)
;
animation
-
>
PlayFromStyle
(
)
;
if
(
!
aElementTransitions
)
{
bool
createdCollection
=
false
;
aElementTransitions
=
CSSTransitionCollection
:
:
GetOrCreateAnimationCollection
(
aElement
aPseudoType
&
createdCollection
)
;
if
(
!
aElementTransitions
)
{
MOZ_ASSERT
(
!
createdCollection
"
outparam
should
agree
with
return
value
"
)
;
NS_WARNING
(
"
allocating
collection
failed
"
)
;
return
false
;
}
if
(
createdCollection
)
{
AddElementCollection
(
aElementTransitions
)
;
}
}
OwningCSSTransitionPtrArray
&
animations
=
aElementTransitions
-
>
mAnimations
;
#
ifdef
DEBUG
for
(
size_t
i
=
0
i_end
=
animations
.
Length
(
)
;
i
<
i_end
;
+
+
i
)
{
MOZ_ASSERT
(
i
=
=
currentIndex
|
|
animations
[
i
]
-
>
TransitionProperty
(
)
!
=
aProperty
"
duplicate
transitions
for
property
"
)
;
}
#
endif
if
(
haveCurrentTransition
)
{
auto
replacedTransitionProperties
=
GetReplacedTransitionProperties
(
oldTransition
timeline
)
;
if
(
replacedTransitionProperties
)
{
animation
-
>
SetReplacedTransition
(
std
:
:
move
(
replacedTransitionProperties
.
ref
(
)
)
)
;
}
animations
[
currentIndex
]
-
>
CancelFromStyle
(
PostRestyleMode
:
:
IfNeeded
)
;
oldTransition
=
nullptr
;
animations
[
currentIndex
]
=
animation
;
}
else
{
animations
.
AppendElement
(
animation
)
;
}
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
effectSet
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
return
true
;
}
