#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsDOMCSSValueList
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsGridContainerFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsROCSSPrimitiveValue
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsCSSKeywords
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsDOMCSSDeclaration
.
h
"
#
include
"
nsStyleTransformMatrix
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
prtime
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
mozilla
/
AppUnits
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
if
defined
(
DEBUG_bzbarsky
)
|
|
defined
(
DEBUG_caillon
)
#
define
DEBUG_ComputedDOMStyle
#
endif
already_AddRefed
<
nsComputedDOMStyle
>
NS_NewComputedDOMStyle
(
dom
:
:
Element
*
aElement
const
nsAString
&
aPseudoElt
Document
*
aDocument
nsComputedDOMStyle
:
:
StyleType
aStyleType
)
{
RefPtr
<
nsComputedDOMStyle
>
computedStyle
=
new
nsComputedDOMStyle
(
aElement
aPseudoElt
aDocument
aStyleType
)
;
return
computedStyle
.
forget
(
)
;
}
static
nsDOMCSSValueList
*
GetROCSSValueList
(
bool
aCommaDelimited
)
{
return
new
nsDOMCSSValueList
(
aCommaDelimited
)
;
}
template
<
typename
T
>
already_AddRefed
<
CSSValue
>
GetBackgroundList
(
T
nsStyleImageLayers
:
:
Layer
:
:
*
aMember
uint32_t
nsStyleImageLayers
:
:
*
aCount
const
nsStyleImageLayers
&
aLayers
const
nsCSSKTableEntry
aTable
[
]
)
{
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
true
)
;
for
(
uint32_t
i
=
0
i_end
=
aLayers
.
*
aCount
;
i
<
i_end
;
+
+
i
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetIdent
(
nsCSSProps
:
:
ValueToKeywordEnum
(
aLayers
.
mLayers
[
i
]
.
*
aMember
aTable
)
)
;
valueList
-
>
AppendCSSValue
(
val
.
forget
(
)
)
;
}
return
valueList
.
forget
(
)
;
}
static
bool
ElementNeedsRestyle
(
Element
*
aElement
nsAtom
*
aPseudo
)
{
const
Document
*
doc
=
aElement
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
false
;
}
ServoStyleSet
*
styleSet
=
presShell
-
>
StyleSet
(
)
;
if
(
styleSet
-
>
StyleSheetsHaveChanged
(
)
)
{
return
true
;
}
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
MOZ_ASSERT
(
presContext
)
;
if
(
presContext
-
>
HasPendingMediaQueryUpdates
(
)
)
{
return
true
;
}
if
(
aElement
-
>
MayHaveAnimations
(
)
&
&
aPseudo
)
{
if
(
aPseudo
=
=
nsCSSPseudoElements
:
:
before
(
)
)
{
if
(
EffectSet
:
:
GetEffectSet
(
aElement
PseudoStyleType
:
:
before
)
)
{
return
true
;
}
}
else
if
(
aPseudo
=
=
nsCSSPseudoElements
:
:
after
(
)
)
{
if
(
EffectSet
:
:
GetEffectSet
(
aElement
PseudoStyleType
:
:
after
)
)
{
return
true
;
}
}
else
if
(
aPseudo
=
=
nsCSSPseudoElements
:
:
marker
(
)
)
{
if
(
EffectSet
:
:
GetEffectSet
(
aElement
PseudoStyleType
:
:
marker
)
)
{
return
true
;
}
}
}
RestyleManager
*
restyleManager
=
presContext
-
>
RestyleManager
(
)
;
restyleManager
-
>
ProcessAllPendingAttributeAndStateInvalidations
(
)
;
if
(
!
presContext
-
>
EffectCompositor
(
)
-
>
HasPendingStyleUpdates
(
)
&
&
!
doc
-
>
GetServoRestyleRoot
(
)
)
{
return
false
;
}
return
restyleManager
-
>
HasPendingRestyleAncestor
(
aElement
)
;
}
struct
ComputedStyleMap
{
friend
class
nsComputedDOMStyle
;
struct
Entry
{
typedef
already_AddRefed
<
CSSValue
>
(
nsComputedDOMStyle
:
:
*
ComputeMethod
)
(
)
;
nsCSSPropertyID
mProperty
;
ComputeMethod
mGetter
;
bool
IsLayoutFlushNeeded
(
)
const
{
return
nsCSSProps
:
:
PropHasFlags
(
mProperty
CSSPropFlags
:
:
GetCSNeedsLayoutFlush
)
;
}
bool
IsEnabled
(
)
const
{
return
nsCSSProps
:
:
IsEnabled
(
mProperty
CSSEnabledState
:
:
ForAllContent
)
;
}
}
;
#
include
"
nsComputedDOMStyleGenerated
.
inc
"
uint32_t
Length
(
)
{
Update
(
)
;
return
mExposedPropertyCount
;
}
nsCSSPropertyID
PropertyAt
(
uint32_t
aIndex
)
{
Update
(
)
;
return
kEntries
[
EntryIndex
(
aIndex
)
]
.
mProperty
;
}
const
Entry
*
FindEntryForProperty
(
nsCSSPropertyID
aPropID
)
{
Update
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mExposedPropertyCount
;
i
+
+
)
{
const
Entry
*
entry
=
&
kEntries
[
EntryIndex
(
i
)
]
;
if
(
entry
-
>
mProperty
=
=
aPropID
)
{
return
entry
;
}
}
return
nullptr
;
}
void
MarkDirty
(
)
{
mExposedPropertyCount
=
0
;
}
uint32_t
mExposedPropertyCount
;
uint32_t
mIndexMap
[
ArrayLength
(
kEntries
)
]
;
private
:
bool
IsDirty
(
)
{
return
mExposedPropertyCount
=
=
0
;
}
void
Update
(
)
;
uint32_t
EntryIndex
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mExposedPropertyCount
)
;
return
mIndexMap
[
aIndex
]
;
}
}
;
constexpr
ComputedStyleMap
:
:
Entry
ComputedStyleMap
:
:
kEntries
[
ArrayLength
(
kEntries
)
]
;
void
ComputedStyleMap
:
:
Update
(
)
{
if
(
!
IsDirty
(
)
)
{
return
;
}
uint32_t
index
=
0
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kEntries
)
;
i
+
+
)
{
if
(
kEntries
[
i
]
.
IsEnabled
(
)
)
{
mIndexMap
[
index
+
+
]
=
i
;
}
}
mExposedPropertyCount
=
index
;
}
nsComputedDOMStyle
:
:
nsComputedDOMStyle
(
dom
:
:
Element
*
aElement
const
nsAString
&
aPseudoElt
Document
*
aDocument
StyleType
aStyleType
)
:
mDocumentWeak
(
nullptr
)
mOuterFrame
(
nullptr
)
mInnerFrame
(
nullptr
)
mPresShell
(
nullptr
)
mStyleType
(
aStyleType
)
mExposeVisitedStyle
(
false
)
mResolvedComputedStyle
(
false
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aDocument
)
;
mDocumentWeak
=
do_GetWeakReference
(
aDocument
)
;
mElement
=
aElement
;
mPseudo
=
nsCSSPseudoElements
:
:
GetPseudoAtom
(
aPseudoElt
)
;
}
nsComputedDOMStyle
:
:
~
nsComputedDOMStyle
(
)
{
MOZ_ASSERT
(
!
mResolvedComputedStyle
"
Should
have
called
ClearComputedStyle
(
)
during
last
release
.
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsComputedDOMStyle
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsComputedDOMStyle
)
tmp
-
>
ClearComputedStyle
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsComputedDOMStyle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
nsComputedDOMStyle
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsComputedDOMStyle
)
return
tmp
-
>
HasKnownLiveWrapper
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsComputedDOMStyle
)
return
tmp
-
>
HasKnownLiveWrapper
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsComputedDOMStyle
)
return
tmp
-
>
HasKnownLiveWrapper
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsComputedDOMStyle
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
nsDOMCSSDeclaration
)
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_ADDREF
(
nsComputedDOMStyle
)
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsComputedDOMStyle
ClearComputedStyle
(
)
)
nsresult
nsComputedDOMStyle
:
:
GetPropertyValue
(
const
nsCSSPropertyID
aPropID
nsAString
&
aValue
)
{
return
GetPropertyValue
(
NS_ConvertASCIItoUTF16
(
nsCSSProps
:
:
GetStringValue
(
aPropID
)
)
aValue
)
;
}
nsresult
nsComputedDOMStyle
:
:
SetPropertyValue
(
const
nsCSSPropertyID
aPropID
const
nsAString
&
aValue
nsIPrincipal
*
aSubjectPrincipal
)
{
return
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
;
}
void
nsComputedDOMStyle
:
:
GetCssText
(
nsAString
&
aCssText
)
{
aCssText
.
Truncate
(
)
;
}
void
nsComputedDOMStyle
:
:
SetCssText
(
const
nsAString
&
aCssText
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aRv
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
)
;
}
uint32_t
nsComputedDOMStyle
:
:
Length
(
)
{
UpdateCurrentStyleSources
(
false
)
;
if
(
!
mComputedStyle
)
{
return
0
;
}
uint32_t
length
=
GetComputedStyleMap
(
)
-
>
Length
(
)
+
Servo_GetCustomPropertiesCount
(
mComputedStyle
)
;
ClearCurrentStyleSources
(
)
;
return
length
;
}
css
:
:
Rule
*
nsComputedDOMStyle
:
:
GetParentRule
(
)
{
return
nullptr
;
}
NS_IMETHODIMP
nsComputedDOMStyle
:
:
GetPropertyValue
(
const
nsAString
&
aPropertyName
nsAString
&
aReturn
)
{
aReturn
.
Truncate
(
)
;
nsCSSPropertyID
prop
=
nsCSSProps
:
:
LookupProperty
(
aPropertyName
)
;
const
ComputedStyleMap
:
:
Entry
*
entry
=
nullptr
;
if
(
prop
!
=
eCSSPropertyExtra_variable
)
{
entry
=
GetComputedStyleMap
(
)
-
>
FindEntryForProperty
(
prop
)
;
if
(
!
entry
)
{
return
NS_OK
;
}
}
const
bool
layoutFlushIsNeeded
=
entry
&
&
entry
-
>
IsLayoutFlushNeeded
(
)
;
UpdateCurrentStyleSources
(
layoutFlushIsNeeded
)
;
if
(
!
mComputedStyle
)
{
return
NS_OK
;
}
auto
cleanup
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
ClearCurrentStyleSources
(
)
;
}
)
;
if
(
!
entry
)
{
MOZ_ASSERT
(
nsCSSProps
:
:
IsCustomPropertyName
(
aPropertyName
)
)
;
const
nsAString
&
name
=
Substring
(
aPropertyName
CSS_CUSTOM_NAME_PREFIX_LENGTH
)
;
Servo_GetCustomPropertyValue
(
mComputedStyle
&
name
&
aReturn
)
;
return
NS_OK
;
}
if
(
nsCSSProps
:
:
PropHasFlags
(
prop
CSSPropFlags
:
:
IsLogical
)
)
{
MOZ_ASSERT
(
entry
)
;
MOZ_ASSERT
(
entry
-
>
mGetter
=
=
&
nsComputedDOMStyle
:
:
DummyGetter
)
;
prop
=
Servo_ResolveLogicalProperty
(
prop
mComputedStyle
)
;
entry
=
GetComputedStyleMap
(
)
-
>
FindEntryForProperty
(
prop
)
;
MOZ_ASSERT
(
layoutFlushIsNeeded
=
=
entry
-
>
IsLayoutFlushNeeded
(
)
"
Logical
and
physical
property
don
'
t
agree
on
whether
layout
is
"
"
needed
"
)
;
}
if
(
!
nsCSSProps
:
:
PropHasFlags
(
prop
CSSPropFlags
:
:
SerializedByServo
)
)
{
if
(
RefPtr
<
CSSValue
>
value
=
(
this
-
>
*
entry
-
>
mGetter
)
(
)
)
{
ErrorResult
rv
;
nsString
text
;
value
-
>
GetCssText
(
text
rv
)
;
aReturn
.
Assign
(
text
)
;
return
rv
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
MOZ_ASSERT
(
entry
-
>
mGetter
=
=
&
nsComputedDOMStyle
:
:
DummyGetter
)
;
Servo_GetPropertyValue
(
mComputedStyle
prop
&
aReturn
)
;
return
NS_OK
;
}
already_AddRefed
<
ComputedStyle
>
nsComputedDOMStyle
:
:
GetComputedStyle
(
Element
*
aElement
nsAtom
*
aPseudo
StyleType
aStyleType
)
{
if
(
Document
*
doc
=
aElement
-
>
GetComposedDoc
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Style
)
;
}
return
GetComputedStyleNoFlush
(
aElement
aPseudo
aStyleType
)
;
}
static
bool
MustReresolveStyle
(
const
mozilla
:
:
ComputedStyle
*
aStyle
)
{
MOZ_ASSERT
(
aStyle
)
;
return
aStyle
-
>
HasPseudoElementData
(
)
&
&
!
aStyle
-
>
IsPseudoElement
(
)
;
}
static
inline
PseudoStyleType
GetPseudoType
(
nsAtom
*
aPseudo
)
{
if
(
!
aPseudo
)
{
return
PseudoStyleType
:
:
NotPseudo
;
}
return
nsCSSPseudoElements
:
:
GetPseudoType
(
aPseudo
CSSEnabledState
:
:
ForAllContent
)
;
}
already_AddRefed
<
ComputedStyle
>
nsComputedDOMStyle
:
:
DoGetComputedStyleNoFlush
(
Element
*
aElement
nsAtom
*
aPseudo
PresShell
*
aPresShell
StyleType
aStyleType
)
{
MOZ_ASSERT
(
aElement
"
NULL
element
"
)
;
PresShell
*
presShell
=
nsContentUtils
:
:
GetPresShellForContent
(
aElement
)
;
bool
inDocWithShell
=
true
;
if
(
!
presShell
)
{
inDocWithShell
=
false
;
presShell
=
aPresShell
;
if
(
!
presShell
)
{
return
nullptr
;
}
}
PseudoStyleType
pseudoType
=
GetPseudoType
(
aPseudo
)
;
if
(
aPseudo
&
&
!
PseudoStyle
:
:
IsPseudoElement
(
pseudoType
)
)
{
return
nullptr
;
}
if
(
!
aElement
-
>
IsInComposedDoc
(
)
)
{
return
nullptr
;
}
if
(
inDocWithShell
&
&
aStyleType
=
=
eAll
&
&
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
Element
*
element
=
nullptr
;
if
(
aPseudo
=
=
nsCSSPseudoElements
:
:
before
(
)
)
{
element
=
nsLayoutUtils
:
:
GetBeforePseudo
(
aElement
)
;
}
else
if
(
aPseudo
=
=
nsCSSPseudoElements
:
:
after
(
)
)
{
element
=
nsLayoutUtils
:
:
GetAfterPseudo
(
aElement
)
;
}
else
if
(
aPseudo
=
=
nsCSSPseudoElements
:
:
marker
(
)
)
{
element
=
nsLayoutUtils
:
:
GetMarkerPseudo
(
aElement
)
;
}
else
if
(
!
aPseudo
)
{
element
=
aElement
;
}
if
(
element
)
{
if
(
nsIFrame
*
styleFrame
=
nsLayoutUtils
:
:
GetStyleFrame
(
element
)
)
{
ComputedStyle
*
result
=
styleFrame
-
>
Style
(
)
;
if
(
!
MustReresolveStyle
(
result
)
)
{
RefPtr
<
ComputedStyle
>
ret
=
result
;
return
ret
.
forget
(
)
;
}
}
}
}
ServoStyleSet
*
styleSet
=
presShell
-
>
StyleSet
(
)
;
StyleRuleInclusion
rules
=
aStyleType
=
=
eDefaultOnly
?
StyleRuleInclusion
:
:
DefaultOnly
:
StyleRuleInclusion
:
:
All
;
RefPtr
<
ComputedStyle
>
result
=
styleSet
-
>
ResolveStyleLazily
(
*
aElement
pseudoType
rules
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
ComputedStyle
>
nsComputedDOMStyle
:
:
GetUnanimatedComputedStyleNoFlush
(
Element
*
aElement
nsAtom
*
aPseudo
)
{
RefPtr
<
ComputedStyle
>
style
=
GetComputedStyleNoFlush
(
aElement
aPseudo
)
;
if
(
!
style
)
{
return
nullptr
;
}
PseudoStyleType
pseudoType
=
GetPseudoType
(
aPseudo
)
;
PresShell
*
presShell
=
aElement
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
presShell
"
How
in
the
world
did
we
get
a
style
a
few
lines
above
?
"
)
;
Element
*
elementOrPseudoElement
=
EffectCompositor
:
:
GetElementToRestyle
(
aElement
pseudoType
)
;
if
(
!
elementOrPseudoElement
)
{
return
nullptr
;
}
return
presShell
-
>
StyleSet
(
)
-
>
GetBaseContextForElement
(
elementOrPseudoElement
style
)
;
}
nsMargin
nsComputedDOMStyle
:
:
GetAdjustedValuesForBoxSizing
(
)
{
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
nsMargin
adjustment
;
if
(
stylePos
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
adjustment
=
mInnerFrame
-
>
GetUsedBorderAndPadding
(
)
;
}
return
adjustment
;
}
static
void
AddImageURL
(
nsIURI
&
aURI
nsTArray
<
nsString
>
&
aURLs
)
{
nsAutoCString
spec
;
nsresult
rv
=
aURI
.
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
aURLs
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
spec
)
)
;
}
static
void
AddImageURL
(
const
StyleComputedUrl
&
aURL
nsTArray
<
nsString
>
&
aURLs
)
{
if
(
aURL
.
IsLocalRef
(
)
)
{
return
;
}
if
(
nsIURI
*
uri
=
aURL
.
GetURI
(
)
)
{
AddImageURL
(
*
uri
aURLs
)
;
}
}
static
void
AddImageURL
(
const
nsStyleImageRequest
&
aRequest
nsTArray
<
nsString
>
&
aURLs
)
{
AddImageURL
(
aRequest
.
GetImageValue
(
)
aURLs
)
;
}
static
void
AddImageURL
(
const
nsStyleImage
&
aImage
nsTArray
<
nsString
>
&
aURLs
)
{
if
(
auto
*
urlValue
=
aImage
.
GetURLValue
(
)
)
{
AddImageURL
(
*
urlValue
aURLs
)
;
}
}
static
void
AddImageURL
(
const
StyleShapeSource
&
aShapeSource
nsTArray
<
nsString
>
&
aURLs
)
{
switch
(
aShapeSource
.
GetType
(
)
)
{
case
StyleShapeSourceType
:
:
Image
:
AddImageURL
(
aShapeSource
.
ShapeImage
(
)
aURLs
)
;
break
;
default
:
break
;
}
}
static
void
AddImageURLs
(
const
nsStyleImageLayers
&
aLayers
nsTArray
<
nsString
>
&
aURLs
)
{
for
(
auto
i
:
IntegerRange
(
aLayers
.
mLayers
.
Length
(
)
)
)
{
AddImageURL
(
aLayers
.
mLayers
[
i
]
.
mImage
aURLs
)
;
}
}
static
void
CollectImageURLsForProperty
(
nsCSSPropertyID
aProp
const
ComputedStyle
&
aStyle
nsTArray
<
nsString
>
&
aURLs
)
{
if
(
nsCSSProps
:
:
IsShorthand
(
aProp
)
)
{
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
p
aProp
CSSEnabledState
:
:
ForAllContent
)
{
CollectImageURLsForProperty
(
*
p
aStyle
aURLs
)
;
}
return
;
}
switch
(
aProp
)
{
case
eCSSProperty_cursor
:
for
(
auto
&
image
:
aStyle
.
StyleUI
(
)
-
>
mCursorImages
)
{
AddImageURL
(
*
image
.
mImage
aURLs
)
;
}
break
;
case
eCSSProperty_background_image
:
AddImageURLs
(
aStyle
.
StyleBackground
(
)
-
>
mImage
aURLs
)
;
break
;
case
eCSSProperty_mask_clip
:
AddImageURLs
(
aStyle
.
StyleSVGReset
(
)
-
>
mMask
aURLs
)
;
break
;
case
eCSSProperty_list_style_image
:
if
(
nsStyleImageRequest
*
image
=
aStyle
.
StyleList
(
)
-
>
mListStyleImage
)
{
AddImageURL
(
*
image
aURLs
)
;
}
break
;
case
eCSSProperty_border_image_source
:
AddImageURL
(
aStyle
.
StyleBorder
(
)
-
>
mBorderImageSource
aURLs
)
;
break
;
case
eCSSProperty_clip_path
:
AddImageURL
(
aStyle
.
StyleSVGReset
(
)
-
>
mClipPath
aURLs
)
;
break
;
case
eCSSProperty_shape_outside
:
AddImageURL
(
aStyle
.
StyleDisplay
(
)
-
>
mShapeOutside
aURLs
)
;
break
;
default
:
break
;
}
}
void
nsComputedDOMStyle
:
:
GetCSSImageURLs
(
const
nsAString
&
aPropertyName
nsTArray
<
nsString
>
&
aImageURLs
mozilla
:
:
ErrorResult
&
aRv
)
{
nsCSSPropertyID
prop
=
nsCSSProps
:
:
LookupProperty
(
aPropertyName
)
;
if
(
prop
=
=
eCSSProperty_UNKNOWN
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
;
}
UpdateCurrentStyleSources
(
false
)
;
if
(
!
mComputedStyle
)
{
return
;
}
CollectImageURLsForProperty
(
prop
*
mComputedStyle
aImageURLs
)
;
ClearCurrentStyleSources
(
)
;
}
DeclarationBlock
*
nsComputedDOMStyle
:
:
GetOrCreateCSSDeclaration
(
Operation
aOperation
DeclarationBlock
*
*
aCreated
)
{
MOZ_CRASH
(
"
called
nsComputedDOMStyle
:
:
GetCSSDeclaration
"
)
;
}
nsresult
nsComputedDOMStyle
:
:
SetCSSDeclaration
(
DeclarationBlock
*
MutationClosureData
*
)
{
MOZ_CRASH
(
"
called
nsComputedDOMStyle
:
:
SetCSSDeclaration
"
)
;
}
Document
*
nsComputedDOMStyle
:
:
DocToUpdate
(
)
{
MOZ_CRASH
(
"
called
nsComputedDOMStyle
:
:
DocToUpdate
"
)
;
}
nsDOMCSSDeclaration
:
:
ParsingEnvironment
nsComputedDOMStyle
:
:
GetParsingEnvironment
(
nsIPrincipal
*
aSubjectPrincipal
)
const
{
MOZ_CRASH
(
"
called
nsComputedDOMStyle
:
:
GetParsingEnvironment
"
)
;
}
void
nsComputedDOMStyle
:
:
ClearComputedStyle
(
)
{
if
(
mResolvedComputedStyle
)
{
mResolvedComputedStyle
=
false
;
mElement
-
>
RemoveMutationObserver
(
this
)
;
}
mComputedStyle
=
nullptr
;
}
void
nsComputedDOMStyle
:
:
SetResolvedComputedStyle
(
RefPtr
<
ComputedStyle
>
&
&
aContext
uint64_t
aGeneration
)
{
if
(
!
mResolvedComputedStyle
)
{
mResolvedComputedStyle
=
true
;
mElement
-
>
AddMutationObserver
(
this
)
;
}
mComputedStyle
=
aContext
;
mComputedStyleGeneration
=
aGeneration
;
mPresShellId
=
mPresShell
-
>
GetPresShellId
(
)
;
}
void
nsComputedDOMStyle
:
:
SetFrameComputedStyle
(
mozilla
:
:
ComputedStyle
*
aStyle
uint64_t
aGeneration
)
{
ClearComputedStyle
(
)
;
mComputedStyle
=
aStyle
;
mComputedStyleGeneration
=
aGeneration
;
mPresShellId
=
mPresShell
-
>
GetPresShellId
(
)
;
}
bool
nsComputedDOMStyle
:
:
NeedsToFlushStyle
(
)
const
{
if
(
ElementNeedsRestyle
(
mElement
mPseudo
)
)
{
return
true
;
}
Document
*
doc
=
mElement
-
>
OwnerDoc
(
)
;
while
(
doc
-
>
StyleOrLayoutObservablyDependsOnParentDocumentLayout
(
)
)
{
Document
*
parentDocument
=
doc
-
>
GetInProcessParentDocument
(
)
;
Element
*
element
=
parentDocument
-
>
FindContentForSubDocument
(
doc
)
;
if
(
ElementNeedsRestyle
(
element
nullptr
)
)
{
return
true
;
}
doc
=
parentDocument
;
}
return
false
;
}
void
nsComputedDOMStyle
:
:
UpdateCurrentStyleSources
(
bool
aNeedsLayoutFlush
)
{
nsCOMPtr
<
Document
>
document
=
do_QueryReferent
(
mDocumentWeak
)
;
if
(
!
document
)
{
ClearComputedStyle
(
)
;
return
;
}
const
bool
needsToFlush
=
aNeedsLayoutFlush
|
|
NeedsToFlushStyle
(
)
;
if
(
needsToFlush
)
{
document
-
>
FlushPendingNotifications
(
aNeedsLayoutFlush
?
FlushType
:
:
Layout
:
FlushType
:
:
Style
)
;
}
#
ifdef
DEBUG
mFlushedPendingReflows
=
aNeedsLayoutFlush
;
#
endif
RefPtr
<
PresShell
>
presShellForContent
=
nsContentUtils
:
:
GetPresShellForContent
(
mElement
)
;
if
(
presShellForContent
&
&
presShellForContent
-
>
GetDocument
(
)
!
=
document
)
{
presShellForContent
-
>
GetDocument
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Style
)
;
if
(
presShellForContent
-
>
IsDestroying
(
)
)
{
presShellForContent
=
nullptr
;
}
}
mPresShell
=
document
-
>
GetPresShell
(
)
;
if
(
!
mPresShell
|
|
!
mPresShell
-
>
GetPresContext
(
)
)
{
ClearComputedStyle
(
)
;
return
;
}
uint64_t
currentGeneration
=
mPresShell
-
>
GetPresContext
(
)
-
>
GetUndisplayedRestyleGeneration
(
)
;
if
(
mComputedStyle
)
{
if
(
mComputedStyleGeneration
=
=
currentGeneration
&
&
mPresShellId
=
=
mPresShell
-
>
GetPresShellId
(
)
&
&
mElement
-
>
IsInComposedDoc
(
)
)
{
return
;
}
mComputedStyle
=
nullptr
;
}
if
(
mStyleType
=
=
eAll
&
&
!
mElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
mOuterFrame
=
nullptr
;
if
(
!
mPseudo
)
{
mOuterFrame
=
mElement
-
>
GetPrimaryFrame
(
)
;
}
else
{
nsAtom
*
property
=
nullptr
;
if
(
mPseudo
=
=
nsCSSPseudoElements
:
:
before
(
)
)
{
property
=
nsGkAtoms
:
:
beforePseudoProperty
;
}
else
if
(
mPseudo
=
=
nsCSSPseudoElements
:
:
after
(
)
)
{
property
=
nsGkAtoms
:
:
afterPseudoProperty
;
}
else
if
(
mPseudo
=
=
nsCSSPseudoElements
:
:
marker
(
)
)
{
property
=
nsGkAtoms
:
:
markerPseudoProperty
;
}
if
(
property
)
{
auto
*
pseudo
=
static_cast
<
Element
*
>
(
mElement
-
>
GetProperty
(
property
)
)
;
mOuterFrame
=
pseudo
?
pseudo
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
}
mInnerFrame
=
mOuterFrame
;
if
(
mOuterFrame
)
{
LayoutFrameType
type
=
mOuterFrame
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
TableWrapper
)
{
mInnerFrame
=
mOuterFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
NS_ASSERTION
(
mInnerFrame
"
table
wrapper
must
have
an
inner
"
)
;
NS_ASSERTION
(
!
mInnerFrame
-
>
GetNextSibling
(
)
"
table
wrapper
frames
should
have
just
one
child
"
"
the
inner
table
"
)
;
}
SetFrameComputedStyle
(
mInnerFrame
-
>
Style
(
)
currentGeneration
)
;
NS_ASSERTION
(
mComputedStyle
"
Frame
without
style
?
"
)
;
}
}
if
(
!
mComputedStyle
|
|
MustReresolveStyle
(
mComputedStyle
)
)
{
RefPtr
<
ComputedStyle
>
resolvedComputedStyle
=
DoGetComputedStyleNoFlush
(
mElement
mPseudo
presShellForContent
?
presShellForContent
.
get
(
)
:
mPresShell
mStyleType
)
;
if
(
!
resolvedComputedStyle
)
{
ClearComputedStyle
(
)
;
return
;
}
NS_ASSERTION
(
!
needsToFlush
|
|
currentGeneration
=
=
mPresShell
-
>
GetPresContext
(
)
-
>
GetUndisplayedRestyleGeneration
(
)
"
why
should
we
have
flushed
style
again
?
"
)
;
SetResolvedComputedStyle
(
std
:
:
move
(
resolvedComputedStyle
)
currentGeneration
)
;
NS_ASSERTION
(
mPseudo
|
|
!
mComputedStyle
-
>
HasPseudoElementData
(
)
"
should
not
have
pseudo
-
element
data
"
)
;
}
MOZ_ASSERT
(
!
mExposeVisitedStyle
|
|
nsContentUtils
:
:
IsCallerChrome
(
)
"
mExposeVisitedStyle
set
incorrectly
"
)
;
if
(
mExposeVisitedStyle
&
&
mComputedStyle
-
>
RelevantLinkVisited
(
)
)
{
if
(
ComputedStyle
*
styleIfVisited
=
mComputedStyle
-
>
GetStyleIfVisited
(
)
)
{
mComputedStyle
=
styleIfVisited
;
}
}
}
void
nsComputedDOMStyle
:
:
ClearCurrentStyleSources
(
)
{
if
(
!
mResolvedComputedStyle
|
|
mOuterFrame
)
{
ClearComputedStyle
(
)
;
}
mOuterFrame
=
nullptr
;
mInnerFrame
=
nullptr
;
mPresShell
=
nullptr
;
}
NS_IMETHODIMP
nsComputedDOMStyle
:
:
RemoveProperty
(
const
nsAString
&
aPropertyName
nsAString
&
aReturn
)
{
return
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
;
}
void
nsComputedDOMStyle
:
:
GetPropertyPriority
(
const
nsAString
&
aPropertyName
nsAString
&
aReturn
)
{
aReturn
.
Truncate
(
)
;
}
NS_IMETHODIMP
nsComputedDOMStyle
:
:
SetProperty
(
const
nsAString
&
aPropertyName
const
nsAString
&
aValue
const
nsAString
&
aPriority
nsIPrincipal
*
aSubjectPrincipal
)
{
return
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
;
}
void
nsComputedDOMStyle
:
:
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
nsAString
&
aPropName
)
{
ComputedStyleMap
*
map
=
GetComputedStyleMap
(
)
;
uint32_t
length
=
map
-
>
Length
(
)
;
if
(
aIndex
<
length
)
{
aFound
=
true
;
CopyASCIItoUTF16
(
nsCSSProps
:
:
GetStringValue
(
map
-
>
PropertyAt
(
aIndex
)
)
aPropName
)
;
return
;
}
UpdateCurrentStyleSources
(
false
)
;
if
(
!
mComputedStyle
)
{
aFound
=
false
;
return
;
}
uint32_t
count
=
Servo_GetCustomPropertiesCount
(
mComputedStyle
)
;
const
uint32_t
index
=
aIndex
-
length
;
if
(
index
<
count
)
{
aFound
=
true
;
nsString
varName
;
Servo_GetCustomPropertyNameAt
(
mComputedStyle
index
&
varName
)
;
aPropName
.
AssignLiteral
(
"
-
-
"
)
;
aPropName
.
Append
(
varName
)
;
}
else
{
aFound
=
false
;
}
ClearCurrentStyleSources
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBottom
(
)
{
return
GetOffsetWidthFor
(
eSideBottom
)
;
}
void
nsComputedDOMStyle
:
:
SetToRGBAColor
(
nsROCSSPrimitiveValue
*
aValue
nscolor
aColor
)
{
nsAutoString
string
;
nsStyleUtil
:
:
GetSerializedColorValue
(
aColor
string
)
;
aValue
-
>
SetString
(
string
)
;
}
void
nsComputedDOMStyle
:
:
SetValueFromComplexColor
(
nsROCSSPrimitiveValue
*
aValue
const
mozilla
:
:
StyleColor
&
aColor
)
{
SetToRGBAColor
(
aValue
aColor
.
CalcColor
(
*
mComputedStyle
)
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetColumnRuleWidth
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetAppUnits
(
StyleColumn
(
)
-
>
GetComputedColumnRuleWidth
(
)
)
;
return
val
.
forget
(
)
;
}
static
Position
MaybeResolvePositionForTransform
(
const
LengthPercentage
&
aX
const
LengthPercentage
&
aY
nsIFrame
*
aInnerFrame
)
{
if
(
!
aInnerFrame
)
{
return
{
aX
aY
}
;
}
nsStyleTransformMatrix
:
:
TransformReferenceBox
refBox
(
aInnerFrame
)
;
CSSPoint
p
=
nsStyleTransformMatrix
:
:
Convert2DPosition
(
aX
aY
refBox
)
;
return
{
LengthPercentage
:
:
FromPixels
(
p
.
x
)
LengthPercentage
:
:
FromPixels
(
p
.
y
)
}
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetTransformOrigin
(
)
{
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
const
auto
&
origin
=
StyleDisplay
(
)
-
>
mTransformOrigin
;
RefPtr
<
nsROCSSPrimitiveValue
>
width
=
new
nsROCSSPrimitiveValue
;
auto
position
=
MaybeResolvePositionForTransform
(
origin
.
horizontal
origin
.
vertical
mInnerFrame
)
;
SetValueToPosition
(
position
valueList
)
;
if
(
!
origin
.
depth
.
IsZero
(
)
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
depth
=
new
nsROCSSPrimitiveValue
;
depth
-
>
SetAppUnits
(
origin
.
depth
.
ToAppUnits
(
)
)
;
valueList
-
>
AppendCSSValue
(
depth
.
forget
(
)
)
;
}
return
valueList
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPerspectiveOrigin
(
)
{
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
const
auto
&
origin
=
StyleDisplay
(
)
-
>
mPerspectiveOrigin
;
auto
position
=
MaybeResolvePositionForTransform
(
origin
.
horizontal
origin
.
vertical
mInnerFrame
)
;
SetValueToPosition
(
position
valueList
)
;
return
valueList
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetTransform
(
)
{
const
nsStyleDisplay
*
display
=
StyleDisplay
(
)
;
return
GetTransformValue
(
display
-
>
mTransform
)
;
}
already_AddRefed
<
nsROCSSPrimitiveValue
>
nsComputedDOMStyle
:
:
MatrixToCSSValue
(
const
mozilla
:
:
gfx
:
:
Matrix4x4
&
matrix
)
{
bool
is3D
=
!
matrix
.
Is2D
(
)
;
nsAutoString
resultString
(
NS_LITERAL_STRING
(
"
matrix
"
)
)
;
if
(
is3D
)
{
resultString
.
AppendLiteral
(
"
3d
"
)
;
}
resultString
.
Append
(
'
(
'
)
;
resultString
.
AppendFloat
(
matrix
.
_11
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_12
)
;
resultString
.
AppendLiteral
(
"
"
)
;
if
(
is3D
)
{
resultString
.
AppendFloat
(
matrix
.
_13
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_14
)
;
resultString
.
AppendLiteral
(
"
"
)
;
}
resultString
.
AppendFloat
(
matrix
.
_21
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_22
)
;
resultString
.
AppendLiteral
(
"
"
)
;
if
(
is3D
)
{
resultString
.
AppendFloat
(
matrix
.
_23
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_24
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_31
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_32
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_33
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_34
)
;
resultString
.
AppendLiteral
(
"
"
)
;
}
resultString
.
AppendFloat
(
matrix
.
_41
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_42
)
;
if
(
is3D
)
{
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_43
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_44
)
;
}
resultString
.
Append
(
'
)
'
)
;
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetString
(
resultString
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetOsxFontSmoothing
(
)
{
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
mPresShell
-
>
GetPresContext
(
)
-
>
GetDocShell
(
)
)
)
return
nullptr
;
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetIdent
(
nsCSSProps
:
:
ValueToKeywordEnum
(
StyleFont
(
)
-
>
mFont
.
smoothing
nsCSSProps
:
:
kFontSmoothingKTable
)
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetImageLayerPosition
(
const
nsStyleImageLayers
&
aLayers
)
{
if
(
aLayers
.
mPositionXCount
!
=
aLayers
.
mPositionYCount
)
{
return
nullptr
;
}
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
true
)
;
for
(
uint32_t
i
=
0
i_end
=
aLayers
.
mPositionXCount
;
i
<
i_end
;
+
+
i
)
{
RefPtr
<
nsDOMCSSValueList
>
itemList
=
GetROCSSValueList
(
false
)
;
SetValueToPosition
(
aLayers
.
mLayers
[
i
]
.
mPosition
itemList
)
;
valueList
-
>
AppendCSSValue
(
itemList
.
forget
(
)
)
;
}
return
valueList
.
forget
(
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToPosition
(
const
Position
&
aPosition
nsDOMCSSValueList
*
aValueList
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
valX
=
new
nsROCSSPrimitiveValue
;
SetValueToLengthPercentage
(
valX
aPosition
.
horizontal
false
)
;
aValueList
-
>
AppendCSSValue
(
valX
.
forget
(
)
)
;
RefPtr
<
nsROCSSPrimitiveValue
>
valY
=
new
nsROCSSPrimitiveValue
;
SetValueToLengthPercentage
(
valY
aPosition
.
vertical
false
)
;
aValueList
-
>
AppendCSSValue
(
valY
.
forget
(
)
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToURLValue
(
const
StyleComputedUrl
*
aURL
nsROCSSPrimitiveValue
*
aValue
)
{
if
(
!
aURL
)
{
aValue
-
>
SetIdent
(
eCSSKeyword_none
)
;
return
;
}
if
(
!
aURL
-
>
IsLocalRef
(
)
)
{
if
(
nsIURI
*
uri
=
aURL
-
>
GetURI
(
)
)
{
aValue
-
>
SetURI
(
uri
)
;
return
;
}
}
NS_ConvertUTF8toUTF16
source
(
aURL
-
>
SpecifiedSerialization
(
)
)
;
nsAutoString
url
;
url
.
AppendLiteral
(
u
"
url
(
"
)
;
nsStyleUtil
:
:
AppendEscapedCSSString
(
source
url
'
"
'
)
;
url
.
Append
(
'
)
'
)
;
aValue
-
>
SetString
(
url
)
;
}
void
nsComputedDOMStyle
:
:
AppendGridLineNames
(
nsString
&
aResult
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
aLineNames
)
{
uint32_t
numLines
=
aLineNames
.
Length
(
)
;
if
(
numLines
=
=
0
)
{
return
;
}
for
(
uint32_t
i
=
0
;
;
)
{
nsStyleUtil
:
:
AppendEscapedCSSIdent
(
nsDependentAtomString
(
aLineNames
[
i
]
)
aResult
)
;
if
(
+
+
i
=
=
numLines
)
{
break
;
}
aResult
.
Append
(
'
'
)
;
}
}
void
nsComputedDOMStyle
:
:
AppendGridLineNames
(
nsDOMCSSValueList
*
aValueList
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
aLineNames
bool
aSuppressEmptyList
)
{
if
(
aLineNames
.
IsEmpty
(
)
&
&
aSuppressEmptyList
)
{
return
;
}
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
nsAutoString
lineNamesString
;
lineNamesString
.
Assign
(
'
[
'
)
;
AppendGridLineNames
(
lineNamesString
aLineNames
)
;
lineNamesString
.
Append
(
'
]
'
)
;
val
-
>
SetString
(
lineNamesString
)
;
aValueList
-
>
AppendCSSValue
(
val
.
forget
(
)
)
;
}
void
nsComputedDOMStyle
:
:
AppendGridLineNames
(
nsDOMCSSValueList
*
aValueList
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
aLineNames1
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
aLineNames2
)
{
if
(
aLineNames1
.
IsEmpty
(
)
&
&
aLineNames2
.
IsEmpty
(
)
)
{
return
;
}
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
nsAutoString
lineNamesString
;
lineNamesString
.
Assign
(
'
[
'
)
;
if
(
!
aLineNames1
.
IsEmpty
(
)
)
{
AppendGridLineNames
(
lineNamesString
aLineNames1
)
;
}
if
(
!
aLineNames2
.
IsEmpty
(
)
)
{
if
(
!
aLineNames1
.
IsEmpty
(
)
)
{
lineNamesString
.
Append
(
'
'
)
;
}
AppendGridLineNames
(
lineNamesString
aLineNames2
)
;
}
lineNamesString
.
Append
(
'
]
'
)
;
val
-
>
SetString
(
lineNamesString
)
;
aValueList
-
>
AppendCSSValue
(
val
.
forget
(
)
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToTrackBreadth
(
nsROCSSPrimitiveValue
*
aValue
const
StyleTrackBreadth
&
aBreadth
)
{
using
Tag
=
StyleTrackBreadth
:
:
Tag
;
switch
(
aBreadth
.
tag
)
{
case
Tag
:
:
MinContent
:
return
aValue
-
>
SetIdent
(
eCSSKeyword_min_content
)
;
case
Tag
:
:
MaxContent
:
return
aValue
-
>
SetIdent
(
eCSSKeyword_max_content
)
;
case
Tag
:
:
Auto
:
return
aValue
-
>
SetIdent
(
eCSSKeyword_auto
)
;
case
Tag
:
:
Breadth
:
return
SetValueToLengthPercentage
(
aValue
aBreadth
.
AsBreadth
(
)
true
)
;
case
Tag
:
:
Fr
:
{
nsAutoString
tmpStr
;
nsStyleUtil
:
:
AppendCSSNumber
(
aBreadth
.
AsFr
(
)
tmpStr
)
;
tmpStr
.
AppendLiteral
(
"
fr
"
)
;
return
aValue
-
>
SetString
(
tmpStr
)
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
breadth
value
"
)
;
return
;
}
}
already_AddRefed
<
nsROCSSPrimitiveValue
>
nsComputedDOMStyle
:
:
GetGridTrackBreadth
(
const
StyleTrackBreadth
&
aBreadth
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
SetValueToTrackBreadth
(
val
aBreadth
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
nsROCSSPrimitiveValue
>
nsComputedDOMStyle
:
:
GetGridTrackSize
(
const
StyleTrackSize
&
aTrackSize
)
{
if
(
aTrackSize
.
IsFitContent
(
)
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
nsAutoString
argumentStr
fitContentStr
;
fitContentStr
.
AppendLiteral
(
"
fit
-
content
(
"
)
;
MOZ_ASSERT
(
aTrackSize
.
AsFitContent
(
)
.
IsBreadth
(
)
"
unexpected
unit
for
fit
-
content
(
)
argument
value
"
)
;
SetValueToLengthPercentage
(
val
aTrackSize
.
AsFitContent
(
)
.
AsBreadth
(
)
true
)
;
val
-
>
GetCssText
(
argumentStr
)
;
fitContentStr
.
Append
(
argumentStr
)
;
fitContentStr
.
Append
(
char16_t
(
'
)
'
)
)
;
val
-
>
SetString
(
fitContentStr
)
;
return
val
.
forget
(
)
;
}
if
(
aTrackSize
.
IsBreadth
(
)
)
{
return
GetGridTrackBreadth
(
aTrackSize
.
AsBreadth
(
)
)
;
}
MOZ_ASSERT
(
aTrackSize
.
IsMinmax
(
)
)
;
auto
&
min
=
aTrackSize
.
AsMinmax
(
)
.
_0
;
auto
&
max
=
aTrackSize
.
AsMinmax
(
)
.
_1
;
if
(
min
=
=
max
)
{
return
GetGridTrackBreadth
(
min
)
;
}
if
(
min
.
IsAuto
(
)
&
&
max
.
IsFr
(
)
)
{
return
GetGridTrackBreadth
(
max
)
;
}
nsAutoString
argumentStr
minmaxStr
;
minmaxStr
.
AppendLiteral
(
"
minmax
(
"
)
;
{
RefPtr
<
nsROCSSPrimitiveValue
>
argValue
=
GetGridTrackBreadth
(
min
)
;
argValue
-
>
GetCssText
(
argumentStr
)
;
minmaxStr
.
Append
(
argumentStr
)
;
argumentStr
.
Truncate
(
)
;
}
minmaxStr
.
AppendLiteral
(
"
"
)
;
{
RefPtr
<
nsROCSSPrimitiveValue
>
argValue
=
GetGridTrackBreadth
(
max
)
;
argValue
-
>
GetCssText
(
argumentStr
)
;
minmaxStr
.
Append
(
argumentStr
)
;
}
minmaxStr
.
Append
(
char16_t
(
'
)
'
)
)
;
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetString
(
minmaxStr
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetGridTemplateColumnsRows
(
const
nsStyleGridTemplate
&
aTrackList
const
ComputedGridTrackInfo
*
aTrackInfo
)
{
if
(
aTrackList
.
mIsSubgrid
)
{
NS_ASSERTION
(
aTrackList
.
mTrackSizingFunctions
.
IsEmpty
(
)
"
Unexpected
sizing
functions
with
subgrid
"
)
;
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
RefPtr
<
nsROCSSPrimitiveValue
>
subgridKeyword
=
new
nsROCSSPrimitiveValue
;
subgridKeyword
-
>
SetIdent
(
eCSSKeyword_subgrid
)
;
valueList
-
>
AppendCSSValue
(
subgridKeyword
.
forget
(
)
)
;
for
(
uint32_t
i
=
0
len
=
aTrackList
.
mLineNameLists
.
Length
(
)
;
;
+
+
i
)
{
if
(
MOZ_UNLIKELY
(
aTrackList
.
IsRepeatAutoIndex
(
i
)
)
)
{
MOZ_ASSERT
(
aTrackList
.
mIsAutoFill
"
subgrid
can
only
have
'
auto
-
fill
'
"
)
;
MOZ_ASSERT
(
aTrackList
.
mRepeatAutoLineNameListAfter
.
IsEmpty
(
)
"
mRepeatAutoLineNameListAfter
isn
'
t
used
for
subgrid
"
)
;
RefPtr
<
nsROCSSPrimitiveValue
>
start
=
new
nsROCSSPrimitiveValue
;
start
-
>
SetString
(
NS_LITERAL_STRING
(
"
repeat
(
auto
-
fill
"
)
)
;
valueList
-
>
AppendCSSValue
(
start
.
forget
(
)
)
;
AppendGridLineNames
(
valueList
aTrackList
.
mRepeatAutoLineNameListBefore
false
)
;
RefPtr
<
nsROCSSPrimitiveValue
>
end
=
new
nsROCSSPrimitiveValue
;
end
-
>
SetString
(
NS_LITERAL_STRING
(
"
)
"
)
)
;
valueList
-
>
AppendCSSValue
(
end
.
forget
(
)
)
;
}
if
(
i
=
=
len
)
{
break
;
}
AppendGridLineNames
(
valueList
aTrackList
.
mLineNameLists
[
i
]
false
)
;
}
return
valueList
.
forget
(
)
;
}
uint32_t
numSizes
=
aTrackList
.
mTrackSizingFunctions
.
Length
(
)
;
if
(
aTrackInfo
)
{
DebugOnly
<
bool
>
isAutoFill
=
aTrackList
.
HasRepeatAuto
(
)
&
&
aTrackList
.
mIsAutoFill
;
DebugOnly
<
bool
>
isAutoFit
=
aTrackList
.
HasRepeatAuto
(
)
&
&
!
aTrackList
.
mIsAutoFill
;
DebugOnly
<
uint32_t
>
numExplicitTracks
=
aTrackInfo
-
>
mNumExplicitTracks
;
MOZ_ASSERT
(
numExplicitTracks
=
=
numSizes
|
|
(
isAutoFill
&
&
numExplicitTracks
>
=
numSizes
)
|
|
(
isAutoFit
&
&
numExplicitTracks
+
1
>
=
numSizes
)
"
expected
all
explicit
tracks
(
or
possibly
one
less
if
there
'
s
"
"
an
'
auto
-
fit
'
track
since
that
can
collapse
away
)
"
)
;
numSizes
=
aTrackInfo
-
>
mSizes
.
Length
(
)
;
}
if
(
numSizes
=
=
0
&
&
!
aTrackList
.
HasRepeatAuto
(
)
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetIdent
(
eCSSKeyword_none
)
;
return
val
.
forget
(
)
;
}
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
if
(
aTrackInfo
)
{
const
nsTArray
<
nscoord
>
&
trackSizes
=
aTrackInfo
-
>
mSizes
;
const
uint32_t
numExplicitTracks
=
aTrackInfo
-
>
mNumExplicitTracks
;
const
uint32_t
numLeadingImplicitTracks
=
aTrackInfo
-
>
mNumLeadingImplicitTracks
;
MOZ_ASSERT
(
numSizes
>
=
numLeadingImplicitTracks
+
numExplicitTracks
)
;
for
(
uint32_t
i
=
0
;
i
<
numLeadingImplicitTracks
;
+
+
i
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetAppUnits
(
trackSizes
[
i
]
)
;
valueList
-
>
AppendCSSValue
(
val
.
forget
(
)
)
;
}
if
(
numExplicitTracks
|
|
aTrackList
.
HasRepeatAuto
(
)
)
{
int32_t
endOfRepeat
=
0
;
int32_t
offsetToLastRepeat
=
0
;
if
(
aTrackList
.
HasRepeatAuto
(
)
)
{
offsetToLastRepeat
=
numExplicitTracks
+
1
-
aTrackList
.
mLineNameLists
.
Length
(
)
;
endOfRepeat
=
aTrackList
.
mRepeatAutoIndex
+
offsetToLastRepeat
+
1
;
}
uint32_t
repeatIndex
=
0
;
uint32_t
numRepeatTracks
=
aTrackInfo
-
>
mRemovedRepeatTracks
.
Length
(
)
;
enum
LinePlacement
{
LinesPrecede
LinesFollow
LinesBetween
}
;
auto
AppendRemovedAutoFits
=
[
this
aTrackInfo
&
valueList
aTrackList
&
repeatIndex
numRepeatTracks
]
(
LinePlacement
aPlacement
)
{
bool
atLeastOneTrackReported
=
false
;
while
(
repeatIndex
<
numRepeatTracks
&
&
aTrackInfo
-
>
mRemovedRepeatTracks
[
repeatIndex
]
)
{
if
(
(
aPlacement
=
=
LinesPrecede
)
|
|
(
(
aPlacement
=
=
LinesBetween
)
&
&
atLeastOneTrackReported
)
)
{
AppendGridLineNames
(
valueList
aTrackList
.
mRepeatAutoLineNameListAfter
aTrackList
.
mRepeatAutoLineNameListBefore
)
;
}
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetAppUnits
(
0
)
;
valueList
-
>
AppendCSSValue
(
val
.
forget
(
)
)
;
atLeastOneTrackReported
=
true
;
if
(
aPlacement
=
=
LinesFollow
)
{
AppendGridLineNames
(
valueList
aTrackList
.
mRepeatAutoLineNameListAfter
aTrackList
.
mRepeatAutoLineNameListBefore
)
;
}
repeatIndex
+
+
;
}
repeatIndex
+
+
;
}
;
for
(
int32_t
i
=
0
;
;
i
+
+
)
{
if
(
aTrackList
.
HasRepeatAuto
(
)
)
{
if
(
i
=
=
aTrackList
.
mRepeatAutoIndex
)
{
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
lineNames
=
aTrackList
.
mLineNameLists
[
i
]
;
if
(
i
=
=
endOfRepeat
)
{
AppendGridLineNames
(
valueList
lineNames
aTrackList
.
mRepeatAutoLineNameListBefore
)
;
AppendRemovedAutoFits
(
LinesBetween
)
;
AppendGridLineNames
(
valueList
aTrackList
.
mRepeatAutoLineNameListAfter
aTrackList
.
mLineNameLists
[
i
+
1
]
)
;
}
else
{
AppendGridLineNames
(
valueList
lineNames
aTrackList
.
mRepeatAutoLineNameListBefore
)
;
AppendRemovedAutoFits
(
LinesFollow
)
;
}
}
else
if
(
i
=
=
endOfRepeat
)
{
AppendRemovedAutoFits
(
LinesPrecede
)
;
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
lineNames
=
aTrackList
.
mLineNameLists
[
aTrackList
.
mRepeatAutoIndex
+
1
]
;
AppendGridLineNames
(
valueList
aTrackList
.
mRepeatAutoLineNameListAfter
lineNames
)
;
}
else
if
(
i
>
aTrackList
.
mRepeatAutoIndex
&
&
i
<
endOfRepeat
)
{
AppendGridLineNames
(
valueList
aTrackList
.
mRepeatAutoLineNameListAfter
aTrackList
.
mRepeatAutoLineNameListBefore
)
;
AppendRemovedAutoFits
(
LinesFollow
)
;
}
else
{
uint32_t
j
=
i
>
endOfRepeat
?
i
-
offsetToLastRepeat
:
i
;
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
lineNames
=
aTrackList
.
mLineNameLists
[
j
]
;
AppendGridLineNames
(
valueList
lineNames
)
;
}
}
else
{
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
lineNames
=
aTrackList
.
mLineNameLists
[
i
]
;
AppendGridLineNames
(
valueList
lineNames
)
;
}
if
(
uint32_t
(
i
)
=
=
numExplicitTracks
)
{
break
;
}
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetAppUnits
(
trackSizes
[
i
+
numLeadingImplicitTracks
]
)
;
valueList
-
>
AppendCSSValue
(
val
.
forget
(
)
)
;
}
}
for
(
uint32_t
i
=
numLeadingImplicitTracks
+
numExplicitTracks
;
i
<
numSizes
;
+
+
i
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetAppUnits
(
trackSizes
[
i
]
)
;
valueList
-
>
AppendCSSValue
(
val
.
forget
(
)
)
;
}
}
else
{
for
(
uint32_t
i
=
0
;
;
i
+
+
)
{
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
lineNames
=
aTrackList
.
mLineNameLists
[
i
]
;
if
(
!
lineNames
.
IsEmpty
(
)
)
{
AppendGridLineNames
(
valueList
lineNames
)
;
}
if
(
i
=
=
numSizes
)
{
break
;
}
if
(
MOZ_UNLIKELY
(
aTrackList
.
IsRepeatAutoIndex
(
i
)
)
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
start
=
new
nsROCSSPrimitiveValue
;
start
-
>
SetString
(
aTrackList
.
mIsAutoFill
?
NS_LITERAL_STRING
(
"
repeat
(
auto
-
fill
"
)
:
NS_LITERAL_STRING
(
"
repeat
(
auto
-
fit
"
)
)
;
valueList
-
>
AppendCSSValue
(
start
.
forget
(
)
)
;
if
(
!
aTrackList
.
mRepeatAutoLineNameListBefore
.
IsEmpty
(
)
)
{
AppendGridLineNames
(
valueList
aTrackList
.
mRepeatAutoLineNameListBefore
)
;
}
valueList
-
>
AppendCSSValue
(
GetGridTrackSize
(
aTrackList
.
mTrackSizingFunctions
[
i
]
)
)
;
if
(
!
aTrackList
.
mRepeatAutoLineNameListAfter
.
IsEmpty
(
)
)
{
AppendGridLineNames
(
valueList
aTrackList
.
mRepeatAutoLineNameListAfter
)
;
}
RefPtr
<
nsROCSSPrimitiveValue
>
end
=
new
nsROCSSPrimitiveValue
;
end
-
>
SetString
(
NS_LITERAL_STRING
(
"
)
"
)
)
;
valueList
-
>
AppendCSSValue
(
end
.
forget
(
)
)
;
}
else
{
valueList
-
>
AppendCSSValue
(
GetGridTrackSize
(
aTrackList
.
mTrackSizingFunctions
[
i
]
)
)
;
}
}
}
return
valueList
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetGridTemplateColumns
(
)
{
const
ComputedGridTrackInfo
*
info
=
nullptr
;
nsGridContainerFrame
*
gridFrame
=
nsGridContainerFrame
:
:
GetGridFrameWithComputedInfo
(
mInnerFrame
)
;
if
(
gridFrame
)
{
info
=
gridFrame
-
>
GetComputedTemplateColumns
(
)
;
}
return
GetGridTemplateColumnsRows
(
StylePosition
(
)
-
>
GridTemplateColumns
(
)
info
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetGridTemplateRows
(
)
{
const
ComputedGridTrackInfo
*
info
=
nullptr
;
nsGridContainerFrame
*
gridFrame
=
nsGridContainerFrame
:
:
GetGridFrameWithComputedInfo
(
mInnerFrame
)
;
if
(
gridFrame
)
{
info
=
gridFrame
-
>
GetComputedTemplateRows
(
)
;
}
return
GetGridTemplateColumnsRows
(
StylePosition
(
)
-
>
GridTemplateRows
(
)
info
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPaddingTop
(
)
{
return
GetPaddingWidthFor
(
eSideTop
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPaddingBottom
(
)
{
return
GetPaddingWidthFor
(
eSideBottom
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPaddingLeft
(
)
{
return
GetPaddingWidthFor
(
eSideLeft
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPaddingRight
(
)
{
return
GetPaddingWidthFor
(
eSideRight
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderSpacing
(
)
{
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
RefPtr
<
nsROCSSPrimitiveValue
>
xSpacing
=
new
nsROCSSPrimitiveValue
;
RefPtr
<
nsROCSSPrimitiveValue
>
ySpacing
=
new
nsROCSSPrimitiveValue
;
const
nsStyleTableBorder
*
border
=
StyleTableBorder
(
)
;
xSpacing
-
>
SetAppUnits
(
border
-
>
mBorderSpacingCol
)
;
ySpacing
-
>
SetAppUnits
(
border
-
>
mBorderSpacingRow
)
;
valueList
-
>
AppendCSSValue
(
xSpacing
.
forget
(
)
)
;
valueList
-
>
AppendCSSValue
(
ySpacing
.
forget
(
)
)
;
return
valueList
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderTopWidth
(
)
{
return
GetBorderWidthFor
(
eSideTop
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderBottomWidth
(
)
{
return
GetBorderWidthFor
(
eSideBottom
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderLeftWidth
(
)
{
return
GetBorderWidthFor
(
eSideLeft
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderRightWidth
(
)
{
return
GetBorderWidthFor
(
eSideRight
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMarginTopWidth
(
)
{
return
GetMarginWidthFor
(
eSideTop
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMarginBottomWidth
(
)
{
return
GetMarginWidthFor
(
eSideBottom
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMarginLeftWidth
(
)
{
return
GetMarginWidthFor
(
eSideLeft
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMarginRightWidth
(
)
{
return
GetMarginWidthFor
(
eSideRight
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetLineHeight
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
{
nscoord
lineHeight
;
if
(
GetLineHeightCoord
(
lineHeight
)
)
{
val
-
>
SetAppUnits
(
lineHeight
)
;
return
val
.
forget
(
)
;
}
}
auto
&
lh
=
StyleText
(
)
-
>
mLineHeight
;
if
(
lh
.
IsLength
(
)
)
{
val
-
>
SetAppUnits
(
lh
.
AsLength
(
)
.
ToAppUnits
(
)
)
;
}
else
if
(
lh
.
IsNumber
(
)
)
{
val
-
>
SetNumber
(
lh
.
AsNumber
(
)
)
;
}
else
if
(
lh
.
IsMozBlockHeight
(
)
)
{
val
-
>
SetIdent
(
eCSSKeyword__moz_block_height
)
;
}
else
{
MOZ_ASSERT
(
lh
.
IsNormal
(
)
)
;
val
-
>
SetIdent
(
eCSSKeyword_normal
)
;
}
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetTextDecoration
(
)
{
const
nsStyleTextReset
*
textReset
=
StyleTextReset
(
)
;
bool
isInitialStyle
=
textReset
-
>
mTextDecorationStyle
=
=
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
;
const
mozilla
:
:
StyleColor
&
color
=
textReset
-
>
mTextDecorationColor
;
RefPtr
<
nsROCSSPrimitiveValue
>
textDecorationLine
=
new
nsROCSSPrimitiveValue
;
{
nsAutoString
decorationLine
;
Servo_GetPropertyValue
(
mComputedStyle
eCSSProperty_text_decoration_line
&
decorationLine
)
;
textDecorationLine
-
>
SetString
(
decorationLine
)
;
}
if
(
isInitialStyle
&
&
color
.
IsCurrentColor
(
)
)
{
return
textDecorationLine
.
forget
(
)
;
}
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
valueList
-
>
AppendCSSValue
(
textDecorationLine
.
forget
(
)
)
;
if
(
!
isInitialStyle
)
{
valueList
-
>
AppendCSSValue
(
DoGetTextDecorationStyle
(
)
)
;
}
if
(
!
color
.
IsCurrentColor
(
)
)
{
valueList
-
>
AppendCSSValue
(
DoGetTextDecorationColor
(
)
)
;
}
return
valueList
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetTextDecorationColor
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
SetValueFromComplexColor
(
val
StyleTextReset
(
)
-
>
mTextDecorationColor
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetTextDecorationStyle
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetIdent
(
nsCSSProps
:
:
ValueToKeywordEnum
(
StyleTextReset
(
)
-
>
mTextDecorationStyle
nsCSSProps
:
:
kTextDecorationStyleKTable
)
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetHeight
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
bool
calcHeight
=
false
;
if
(
mInnerFrame
)
{
calcHeight
=
true
;
const
nsStyleDisplay
*
displayData
=
StyleDisplay
(
)
;
if
(
displayData
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Inline
&
&
!
mInnerFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
)
{
calcHeight
=
false
;
}
}
if
(
calcHeight
)
{
AssertFlushedPendingReflows
(
)
;
nsMargin
adjustedValues
=
GetAdjustedValuesForBoxSizing
(
)
;
val
-
>
SetAppUnits
(
mInnerFrame
-
>
GetContentRect
(
)
.
height
+
adjustedValues
.
TopBottom
(
)
)
;
}
else
{
SetValueToSize
(
val
StylePosition
(
)
-
>
mHeight
)
;
}
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetWidth
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
bool
calcWidth
=
false
;
if
(
mInnerFrame
)
{
calcWidth
=
true
;
const
nsStyleDisplay
*
displayData
=
StyleDisplay
(
)
;
if
(
displayData
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Inline
&
&
!
mInnerFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
)
{
calcWidth
=
false
;
}
}
if
(
calcWidth
)
{
AssertFlushedPendingReflows
(
)
;
nsMargin
adjustedValues
=
GetAdjustedValuesForBoxSizing
(
)
;
val
-
>
SetAppUnits
(
mInnerFrame
-
>
GetContentRect
(
)
.
width
+
adjustedValues
.
LeftRight
(
)
)
;
}
else
{
SetValueToSize
(
val
StylePosition
(
)
-
>
mWidth
)
;
}
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMaxHeight
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
SetValueToMaxSize
(
val
StylePosition
(
)
-
>
mMaxHeight
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMaxWidth
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
SetValueToMaxSize
(
val
StylePosition
(
)
-
>
mMaxWidth
)
;
return
val
.
forget
(
)
;
}
bool
nsComputedDOMStyle
:
:
ShouldHonorMinSizeAutoInAxis
(
PhysicalAxis
aAxis
)
{
return
mOuterFrame
&
&
mOuterFrame
-
>
IsFlexOrGridItem
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMinHeight
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
StyleSize
minHeight
=
StylePosition
(
)
-
>
mMinHeight
;
if
(
minHeight
.
IsAuto
(
)
&
&
!
ShouldHonorMinSizeAutoInAxis
(
eAxisVertical
)
)
{
minHeight
=
StyleSize
:
:
LengthPercentage
(
LengthPercentage
:
:
Zero
(
)
)
;
}
SetValueToSize
(
val
minHeight
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMinWidth
(
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
StyleSize
minWidth
=
StylePosition
(
)
-
>
mMinWidth
;
if
(
minWidth
.
IsAuto
(
)
&
&
!
ShouldHonorMinSizeAutoInAxis
(
eAxisHorizontal
)
)
{
minWidth
=
StyleSize
:
:
LengthPercentage
(
LengthPercentage
:
:
Zero
(
)
)
;
}
SetValueToSize
(
val
minWidth
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetLeft
(
)
{
return
GetOffsetWidthFor
(
eSideLeft
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetRight
(
)
{
return
GetOffsetWidthFor
(
eSideRight
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetTop
(
)
{
return
GetOffsetWidthFor
(
eSideTop
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetOffsetWidthFor
(
mozilla
:
:
Side
aSide
)
{
const
nsStyleDisplay
*
display
=
StyleDisplay
(
)
;
AssertFlushedPendingReflows
(
)
;
uint8_t
position
=
display
-
>
mPosition
;
if
(
!
mOuterFrame
)
{
position
=
NS_STYLE_POSITION_STATIC
;
}
switch
(
position
)
{
case
NS_STYLE_POSITION_STATIC
:
return
GetStaticOffset
(
aSide
)
;
case
NS_STYLE_POSITION_STICKY
:
return
GetNonStaticPositionOffset
(
aSide
false
&
nsComputedDOMStyle
:
:
GetScrollFrameContentWidth
&
nsComputedDOMStyle
:
:
GetScrollFrameContentHeight
)
;
case
NS_STYLE_POSITION_ABSOLUTE
:
case
NS_STYLE_POSITION_FIXED
:
return
GetAbsoluteOffset
(
aSide
)
;
case
NS_STYLE_POSITION_RELATIVE
:
return
GetNonStaticPositionOffset
(
aSide
true
&
nsComputedDOMStyle
:
:
GetCBContentWidth
&
nsComputedDOMStyle
:
:
GetCBContentHeight
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
position
"
)
;
return
nullptr
;
}
}
static_assert
(
eSideTop
=
=
0
&
&
eSideRight
=
=
1
&
&
eSideBottom
=
=
2
&
&
eSideLeft
=
=
3
"
box
side
constants
not
as
expected
for
NS_OPPOSITE_SIDE
"
)
;
#
define
NS_OPPOSITE_SIDE
(
s_
)
mozilla
:
:
Side
(
(
(
s_
)
+
2
)
&
3
)
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetNonStaticPositionOffset
(
mozilla
:
:
Side
aSide
bool
aResolveAuto
PercentageBaseGetter
aWidthGetter
PercentageBaseGetter
aHeightGetter
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
const
nsStylePosition
*
positionData
=
StylePosition
(
)
;
int32_t
sign
=
1
;
LengthPercentageOrAuto
coord
=
positionData
-
>
mOffset
.
Get
(
aSide
)
;
if
(
coord
.
IsAuto
(
)
)
{
if
(
!
aResolveAuto
)
{
val
-
>
SetIdent
(
eCSSKeyword_auto
)
;
return
val
.
forget
(
)
;
}
coord
=
positionData
-
>
mOffset
.
Get
(
NS_OPPOSITE_SIDE
(
aSide
)
)
;
sign
=
-
1
;
}
PercentageBaseGetter
baseGetter
=
(
aSide
=
=
eSideLeft
|
|
aSide
=
=
eSideRight
)
?
aWidthGetter
:
aHeightGetter
;
val
-
>
SetAppUnits
(
sign
*
StyleCoordToNSCoord
(
coord
baseGetter
0
false
)
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetAbsoluteOffset
(
mozilla
:
:
Side
aSide
)
{
const
auto
&
offset
=
StylePosition
(
)
-
>
mOffset
;
const
auto
&
coord
=
offset
.
Get
(
aSide
)
;
const
auto
&
oppositeCoord
=
offset
.
Get
(
NS_OPPOSITE_SIDE
(
aSide
)
)
;
if
(
coord
.
IsAuto
(
)
|
|
oppositeCoord
.
IsAuto
(
)
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetAppUnits
(
GetUsedAbsoluteOffset
(
aSide
)
)
;
return
val
.
forget
(
)
;
}
return
GetNonStaticPositionOffset
(
aSide
false
&
nsComputedDOMStyle
:
:
GetCBPaddingRectWidth
&
nsComputedDOMStyle
:
:
GetCBPaddingRectHeight
)
;
}
nscoord
nsComputedDOMStyle
:
:
GetUsedAbsoluteOffset
(
mozilla
:
:
Side
aSide
)
{
MOZ_ASSERT
(
mOuterFrame
"
need
a
frame
so
we
can
call
GetContainingBlock
(
)
"
)
;
nsIFrame
*
container
=
mOuterFrame
-
>
GetContainingBlock
(
)
;
nsMargin
margin
=
mOuterFrame
-
>
GetUsedMargin
(
)
;
nsMargin
border
=
container
-
>
GetUsedBorder
(
)
;
nsMargin
scrollbarSizes
(
0
0
0
0
)
;
nsRect
rect
=
mOuterFrame
-
>
GetRect
(
)
;
nsRect
containerRect
=
container
-
>
GetRect
(
)
;
if
(
container
-
>
IsViewportFrame
(
)
)
{
nsIFrame
*
scrollingChild
=
container
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
scrollingChild
)
;
if
(
scrollFrame
)
{
scrollbarSizes
=
scrollFrame
-
>
GetActualScrollbarSizes
(
)
;
}
}
else
if
(
container
-
>
IsGridContainerFrame
(
)
&
&
(
mOuterFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
)
{
containerRect
=
nsGridContainerFrame
:
:
GridItemCB
(
mOuterFrame
)
;
rect
.
MoveBy
(
-
containerRect
.
x
-
containerRect
.
y
)
;
}
nscoord
offset
=
0
;
switch
(
aSide
)
{
case
eSideTop
:
offset
=
rect
.
y
-
margin
.
top
-
border
.
top
-
scrollbarSizes
.
top
;
break
;
case
eSideRight
:
offset
=
containerRect
.
width
-
rect
.
width
-
rect
.
x
-
margin
.
right
-
border
.
right
-
scrollbarSizes
.
right
;
break
;
case
eSideBottom
:
offset
=
containerRect
.
height
-
rect
.
height
-
rect
.
y
-
margin
.
bottom
-
border
.
bottom
-
scrollbarSizes
.
bottom
;
break
;
case
eSideLeft
:
offset
=
rect
.
x
-
margin
.
left
-
border
.
left
-
scrollbarSizes
.
left
;
break
;
default
:
NS_ERROR
(
"
Invalid
side
"
)
;
break
;
}
return
offset
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetStaticOffset
(
mozilla
:
:
Side
aSide
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
SetValueToLengthPercentageOrAuto
(
val
StylePosition
(
)
-
>
mOffset
.
Get
(
aSide
)
false
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetPaddingWidthFor
(
mozilla
:
:
Side
aSide
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
if
(
!
mInnerFrame
)
{
SetValueToLengthPercentage
(
val
StylePadding
(
)
-
>
mPadding
.
Get
(
aSide
)
true
)
;
}
else
{
AssertFlushedPendingReflows
(
)
;
val
-
>
SetAppUnits
(
mInnerFrame
-
>
GetUsedPadding
(
)
.
Side
(
aSide
)
)
;
}
return
val
.
forget
(
)
;
}
bool
nsComputedDOMStyle
:
:
GetLineHeightCoord
(
nscoord
&
aCoord
)
{
AssertFlushedPendingReflows
(
)
;
nscoord
blockHeight
=
NS_UNCONSTRAINEDSIZE
;
const
auto
&
lh
=
StyleText
(
)
-
>
mLineHeight
;
if
(
lh
.
IsNormal
(
)
&
&
StaticPrefs
:
:
layout_css_line_height_normal_as_resolved_value_enabled
(
)
)
{
return
false
;
}
if
(
lh
.
IsMozBlockHeight
(
)
)
{
if
(
!
mInnerFrame
)
{
return
false
;
}
if
(
nsLayoutUtils
:
:
IsNonWrapperBlock
(
mInnerFrame
)
)
{
blockHeight
=
mInnerFrame
-
>
GetContentRect
(
)
.
height
;
}
else
{
GetCBContentHeight
(
blockHeight
)
;
}
}
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
;
aCoord
=
ReflowInput
:
:
CalcLineHeight
(
mElement
mComputedStyle
presContext
blockHeight
1
.
0f
)
;
const
nsStyleFont
*
font
=
StyleFont
(
)
;
float
fCoord
=
float
(
aCoord
)
;
if
(
font
-
>
mAllowZoom
)
{
fCoord
/
=
presContext
-
>
EffectiveTextZoom
(
)
;
}
if
(
font
-
>
mFont
.
size
!
=
font
-
>
mSize
)
{
fCoord
=
fCoord
*
(
float
(
font
-
>
mSize
)
/
float
(
font
-
>
mFont
.
size
)
)
;
}
aCoord
=
NSToCoordRound
(
fCoord
)
;
return
true
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetBorderWidthFor
(
mozilla
:
:
Side
aSide
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
nscoord
width
;
if
(
mInnerFrame
)
{
AssertFlushedPendingReflows
(
)
;
width
=
mInnerFrame
-
>
GetUsedBorder
(
)
.
Side
(
aSide
)
;
}
else
{
width
=
StyleBorder
(
)
-
>
GetComputedBorderWidth
(
aSide
)
;
}
val
-
>
SetAppUnits
(
width
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetBorderColorFor
(
mozilla
:
:
Side
aSide
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
SetValueFromComplexColor
(
val
StyleBorder
(
)
-
>
BorderColorFor
(
aSide
)
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetMarginWidthFor
(
mozilla
:
:
Side
aSide
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
if
(
!
mInnerFrame
)
{
SetValueToLengthPercentageOrAuto
(
val
StyleMargin
(
)
-
>
mMargin
.
Get
(
aSide
)
false
)
;
}
else
{
AssertFlushedPendingReflows
(
)
;
val
-
>
SetAppUnits
(
mOuterFrame
-
>
GetUsedMargin
(
)
.
Side
(
aSide
)
)
;
NS_ASSERTION
(
mOuterFrame
=
=
mInnerFrame
|
|
mInnerFrame
-
>
GetUsedMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
Inner
tables
must
have
zero
margins
"
)
;
}
return
val
.
forget
(
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToExtremumLength
(
nsROCSSPrimitiveValue
*
aValue
StyleExtremumLength
aSize
)
{
switch
(
aSize
)
{
case
StyleExtremumLength
:
:
MaxContent
:
return
aValue
-
>
SetIdent
(
eCSSKeyword_max_content
)
;
case
StyleExtremumLength
:
:
MinContent
:
return
aValue
-
>
SetIdent
(
eCSSKeyword_min_content
)
;
case
StyleExtremumLength
:
:
MozAvailable
:
return
aValue
-
>
SetIdent
(
eCSSKeyword__moz_available
)
;
case
StyleExtremumLength
:
:
MozFitContent
:
return
aValue
-
>
SetIdent
(
eCSSKeyword__moz_fit_content
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
extremum
length
?
"
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToSize
(
nsROCSSPrimitiveValue
*
aValue
const
StyleSize
&
aSize
)
{
if
(
aSize
.
IsAuto
(
)
)
{
return
aValue
-
>
SetIdent
(
eCSSKeyword_auto
)
;
}
if
(
aSize
.
IsExtremumLength
(
)
)
{
return
SetValueToExtremumLength
(
aValue
aSize
.
AsExtremumLength
(
)
)
;
}
MOZ_ASSERT
(
aSize
.
IsLengthPercentage
(
)
)
;
SetValueToLengthPercentage
(
aValue
aSize
.
AsLengthPercentage
(
)
true
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToMaxSize
(
nsROCSSPrimitiveValue
*
aValue
const
StyleMaxSize
&
aSize
)
{
if
(
aSize
.
IsNone
(
)
)
{
return
aValue
-
>
SetIdent
(
eCSSKeyword_none
)
;
}
if
(
aSize
.
IsExtremumLength
(
)
)
{
return
SetValueToExtremumLength
(
aValue
aSize
.
AsExtremumLength
(
)
)
;
}
MOZ_ASSERT
(
aSize
.
IsLengthPercentage
(
)
)
;
SetValueToLengthPercentage
(
aValue
aSize
.
AsLengthPercentage
(
)
true
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToLengthPercentageOrAuto
(
nsROCSSPrimitiveValue
*
aValue
const
LengthPercentageOrAuto
&
aSize
bool
aClampNegativeCalc
)
{
if
(
aSize
.
IsAuto
(
)
)
{
return
aValue
-
>
SetIdent
(
eCSSKeyword_auto
)
;
}
SetValueToLengthPercentage
(
aValue
aSize
.
AsLengthPercentage
(
)
aClampNegativeCalc
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToLengthPercentage
(
nsROCSSPrimitiveValue
*
aValue
const
mozilla
:
:
LengthPercentage
&
aLength
bool
aClampNegativeCalc
)
{
if
(
aLength
.
ConvertsToLength
(
)
)
{
nscoord
result
=
aLength
.
ToLength
(
)
;
if
(
aClampNegativeCalc
)
{
result
=
std
:
:
max
(
result
0
)
;
}
return
aValue
-
>
SetAppUnits
(
result
)
;
}
if
(
aLength
.
ConvertsToPercentage
(
)
)
{
float
result
=
aLength
.
ToPercentage
(
)
;
if
(
aClampNegativeCalc
)
{
result
=
std
:
:
max
(
result
0
.
0f
)
;
}
return
aValue
-
>
SetPercent
(
result
)
;
}
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
nsAutoString
tmp
result
;
result
.
AppendLiteral
(
"
calc
(
"
)
;
val
-
>
SetAppUnits
(
CSSPixel
:
:
ToAppUnits
(
aLength
.
LengthInCSSPixels
(
)
)
)
;
val
-
>
GetCssText
(
tmp
)
;
result
.
Append
(
tmp
)
;
if
(
aLength
.
HasPercent
(
)
)
{
result
.
AppendLiteral
(
"
+
"
)
;
val
-
>
SetPercent
(
aLength
.
Percentage
(
)
)
;
val
-
>
GetCssText
(
tmp
)
;
result
.
Append
(
tmp
)
;
}
result
.
Append
(
'
)
'
)
;
aValue
-
>
SetString
(
result
)
;
}
nscoord
nsComputedDOMStyle
:
:
StyleCoordToNSCoord
(
const
LengthPercentage
&
aCoord
PercentageBaseGetter
aPercentageBaseGetter
nscoord
aDefaultValue
bool
aClampNegativeCalc
)
{
MOZ_ASSERT
(
aPercentageBaseGetter
"
Must
have
a
percentage
base
getter
"
)
;
if
(
aCoord
.
ConvertsToLength
(
)
)
{
return
aCoord
.
ToLength
(
)
;
}
nscoord
percentageBase
;
if
(
(
this
-
>
*
aPercentageBaseGetter
)
(
percentageBase
)
)
{
nscoord
result
=
aCoord
.
Resolve
(
percentageBase
)
;
if
(
aClampNegativeCalc
&
&
result
<
0
)
{
NS_WARNING_ASSERTION
(
percentageBase
>
=
0
"
percentage
base
value
overflowed
to
become
"
"
negative
for
a
property
"
"
that
disallows
negative
values
"
)
;
MOZ_ASSERT
(
aCoord
.
was_calc
|
|
(
aCoord
.
HasPercent
(
)
&
&
percentageBase
<
0
)
"
parser
should
have
rejected
value
"
)
;
result
=
0
;
}
return
result
;
}
return
aDefaultValue
;
}
bool
nsComputedDOMStyle
:
:
GetCBContentWidth
(
nscoord
&
aWidth
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aWidth
=
mOuterFrame
-
>
GetContainingBlock
(
)
-
>
GetContentRect
(
)
.
width
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetCBContentHeight
(
nscoord
&
aHeight
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aHeight
=
mOuterFrame
-
>
GetContainingBlock
(
)
-
>
GetContentRect
(
)
.
height
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetCBPaddingRectWidth
(
nscoord
&
aWidth
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aWidth
=
mOuterFrame
-
>
GetContainingBlock
(
)
-
>
GetPaddingRect
(
)
.
width
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetCBPaddingRectHeight
(
nscoord
&
aHeight
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aHeight
=
mOuterFrame
-
>
GetContainingBlock
(
)
-
>
GetPaddingRect
(
)
.
height
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetScrollFrameContentWidth
(
nscoord
&
aWidth
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
nsIScrollableFrame
*
scrollableFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
mOuterFrame
-
>
GetParent
(
)
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
!
scrollableFrame
)
{
return
false
;
}
aWidth
=
scrollableFrame
-
>
GetScrolledFrame
(
)
-
>
GetContentRectRelativeToSelf
(
)
.
width
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetScrollFrameContentHeight
(
nscoord
&
aHeight
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
nsIScrollableFrame
*
scrollableFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
mOuterFrame
-
>
GetParent
(
)
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
!
scrollableFrame
)
{
return
false
;
}
aHeight
=
scrollableFrame
-
>
GetScrolledFrame
(
)
-
>
GetContentRectRelativeToSelf
(
)
.
height
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetFrameBorderRectWidth
(
nscoord
&
aWidth
)
{
if
(
!
mInnerFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aWidth
=
mInnerFrame
-
>
GetSize
(
)
.
width
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetFrameBorderRectHeight
(
nscoord
&
aHeight
)
{
if
(
!
mInnerFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aHeight
=
mInnerFrame
-
>
GetSize
(
)
.
height
;
return
true
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetTransformValue
(
const
StyleTransform
&
aTransform
)
{
if
(
aTransform
.
IsNone
(
)
)
{
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
val
-
>
SetIdent
(
eCSSKeyword_none
)
;
return
val
.
forget
(
)
;
}
nsStyleTransformMatrix
:
:
TransformReferenceBox
refBox
(
mInnerFrame
nsSize
(
0
0
)
)
;
gfx
:
:
Matrix4x4
matrix
=
nsStyleTransformMatrix
:
:
ReadTransforms
(
aTransform
refBox
float
(
mozilla
:
:
AppUnitsPerCSSPixel
(
)
)
)
;
return
MatrixToCSSValue
(
matrix
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMask
(
)
{
const
nsStyleSVGReset
*
svg
=
StyleSVGReset
(
)
;
const
nsStyleImageLayers
:
:
Layer
&
firstLayer
=
svg
-
>
mMask
.
mLayers
[
0
]
;
if
(
svg
-
>
mMask
.
mImageCount
>
1
|
|
firstLayer
.
mClip
!
=
StyleGeometryBox
:
:
BorderBox
|
|
firstLayer
.
mOrigin
!
=
StyleGeometryBox
:
:
BorderBox
|
|
firstLayer
.
mComposite
!
=
NS_STYLE_MASK_COMPOSITE_ADD
|
|
firstLayer
.
mMaskMode
!
=
StyleMaskMode
:
:
MatchSource
|
|
!
nsStyleImageLayers
:
:
IsInitialPositionForLayerType
(
firstLayer
.
mPosition
nsStyleImageLayers
:
:
LayerType
:
:
Mask
)
|
|
!
firstLayer
.
mRepeat
.
IsInitialValue
(
)
|
|
!
firstLayer
.
mSize
.
IsInitialValue
(
)
|
|
!
(
firstLayer
.
mImage
.
GetType
(
)
=
=
eStyleImageType_Null
|
|
firstLayer
.
mImage
.
GetType
(
)
=
=
eStyleImageType_Image
)
)
{
return
nullptr
;
}
RefPtr
<
nsROCSSPrimitiveValue
>
val
=
new
nsROCSSPrimitiveValue
;
SetValueToURLValue
(
firstLayer
.
mImage
.
GetURLValue
(
)
val
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DummyGetter
(
)
{
MOZ_CRASH
(
"
DummyGetter
is
not
supposed
to
be
invoked
"
)
;
}
static
void
MarkComputedStyleMapDirty
(
const
char
*
aPref
ComputedStyleMap
*
aData
)
{
aData
-
>
MarkDirty
(
)
;
}
void
nsComputedDOMStyle
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
NS_ASSERTION
(
mElement
=
=
aContent
"
didn
'
t
we
register
mElement
?
"
)
;
NS_ASSERTION
(
mResolvedComputedStyle
"
should
have
only
registered
an
observer
when
"
"
mResolvedComputedStyle
is
true
"
)
;
ClearComputedStyle
(
)
;
}
ComputedStyleMap
*
nsComputedDOMStyle
:
:
GetComputedStyleMap
(
)
{
static
ComputedStyleMap
map
{
}
;
return
&
map
;
}
static
StaticAutoPtr
<
nsTArray
<
const
char
*
>
>
gCallbackPrefs
;
void
nsComputedDOMStyle
:
:
RegisterPrefChangeCallbacks
(
)
{
AutoTArray
<
const
char
*
64
>
prefs
;
for
(
const
auto
*
p
=
nsCSSProps
:
:
kPropertyPrefTable
;
p
-
>
mPropID
!
=
eCSSProperty_UNKNOWN
;
p
+
+
)
{
if
(
!
prefs
.
ContainsSorted
(
p
-
>
mPref
)
)
{
prefs
.
InsertElementSorted
(
p
-
>
mPref
)
;
}
}
prefs
.
AppendElement
(
nullptr
)
;
MOZ_ASSERT
(
!
gCallbackPrefs
)
;
gCallbackPrefs
=
new
nsTArray
<
const
char
*
>
(
std
:
:
move
(
prefs
)
)
;
Preferences
:
:
RegisterCallbacks
(
MarkComputedStyleMapDirty
gCallbackPrefs
-
>
Elements
(
)
GetComputedStyleMap
(
)
)
;
}
void
nsComputedDOMStyle
:
:
UnregisterPrefChangeCallbacks
(
)
{
if
(
!
gCallbackPrefs
)
{
return
;
}
Preferences
:
:
UnregisterCallbacks
(
MarkComputedStyleMapDirty
gCallbackPrefs
-
>
Elements
(
)
GetComputedStyleMap
(
)
)
;
gCallbackPrefs
=
nullptr
;
}
