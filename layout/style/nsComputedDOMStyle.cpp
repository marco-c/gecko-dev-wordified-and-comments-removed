#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsDOMCSSValueList
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsGridContainerFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsROCSSPrimitiveValue
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsDOMCSSDeclaration
.
h
"
#
include
"
nsStyleTransformMatrix
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
prtime
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
mozilla
/
AppUnits
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
nsPrintfCString
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
already_AddRefed
<
nsComputedDOMStyle
>
NS_NewComputedDOMStyle
(
dom
:
:
Element
*
aElement
const
nsAString
&
aPseudoElt
Document
*
aDocument
nsComputedDOMStyle
:
:
StyleType
aStyleType
mozilla
:
:
ErrorResult
&
)
{
auto
[
pseudo
functionalPseudoParameter
]
=
nsCSSPseudoElements
:
:
ParsePseudoElement
(
aPseudoElt
CSSEnabledState
:
:
ForAllContent
)
;
auto
returnEmpty
=
nsComputedDOMStyle
:
:
AlwaysReturnEmptyStyle
:
:
No
;
if
(
!
pseudo
)
{
if
(
!
aPseudoElt
.
IsEmpty
(
)
&
&
aPseudoElt
.
First
(
)
=
=
u
'
:
'
)
{
returnEmpty
=
nsComputedDOMStyle
:
:
AlwaysReturnEmptyStyle
:
:
Yes
;
}
pseudo
.
emplace
(
PseudoStyleType
:
:
NotPseudo
)
;
}
return
MakeAndAddRef
<
nsComputedDOMStyle
>
(
aElement
*
pseudo
functionalPseudoParameter
aDocument
aStyleType
returnEmpty
)
;
}
static
nsDOMCSSValueList
*
GetROCSSValueList
(
bool
aCommaDelimited
)
{
return
new
nsDOMCSSValueList
(
aCommaDelimited
)
;
}
static
const
Element
*
GetRenderedElement
(
const
Element
*
aElement
PseudoStyleType
aPseudo
)
{
if
(
aPseudo
=
=
PseudoStyleType
:
:
NotPseudo
)
{
return
aElement
;
}
if
(
aPseudo
=
=
PseudoStyleType
:
:
before
)
{
return
nsLayoutUtils
:
:
GetBeforePseudo
(
aElement
)
;
}
if
(
aPseudo
=
=
PseudoStyleType
:
:
after
)
{
return
nsLayoutUtils
:
:
GetAfterPseudo
(
aElement
)
;
}
if
(
aPseudo
=
=
PseudoStyleType
:
:
marker
)
{
return
nsLayoutUtils
:
:
GetMarkerPseudo
(
aElement
)
;
}
return
nullptr
;
}
static
bool
ElementNeedsRestyle
(
Element
*
aElement
PseudoStyleType
aPseudo
bool
aMayNeedToFlushLayout
)
{
const
Document
*
doc
=
aElement
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
false
;
}
ServoStyleSet
*
styleSet
=
presShell
-
>
StyleSet
(
)
;
if
(
styleSet
-
>
StyleSheetsHaveChanged
(
)
)
{
return
true
;
}
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
MOZ_ASSERT
(
presContext
)
;
if
(
presContext
-
>
HasPendingMediaQueryUpdates
(
)
)
{
return
true
;
}
if
(
aElement
-
>
MayHaveAnimations
(
)
&
&
aPseudo
!
=
PseudoStyleType
:
:
NotPseudo
&
&
AnimationUtils
:
:
IsSupportedPseudoForAnimations
(
aPseudo
)
)
{
if
(
EffectSet
:
:
Get
(
aElement
aPseudo
)
)
{
return
true
;
}
}
RestyleManager
*
restyleManager
=
presContext
-
>
RestyleManager
(
)
;
restyleManager
-
>
ProcessAllPendingAttributeAndStateInvalidations
(
)
;
if
(
!
presContext
-
>
EffectCompositor
(
)
-
>
HasPendingStyleUpdates
(
)
&
&
!
doc
-
>
GetServoRestyleRoot
(
)
)
{
return
false
;
}
const
Element
*
styledElement
=
GetRenderedElement
(
aElement
aPseudo
)
;
return
Servo_HasPendingRestyleAncestor
(
styledElement
?
styledElement
:
aElement
aMayNeedToFlushLayout
)
;
}
struct
ComputedStyleMap
{
friend
class
nsComputedDOMStyle
;
struct
Entry
{
using
ComputeMethod
=
already_AddRefed
<
CSSValue
>
(
nsComputedDOMStyle
:
:
*
)
(
)
;
nsCSSPropertyID
mProperty
;
bool
mCanBeExposed
=
false
;
ComputeMethod
mGetter
=
nullptr
;
bool
IsEnumerable
(
)
const
{
return
IsEnabled
(
)
&
&
!
nsCSSProps
:
:
IsShorthand
(
mProperty
)
;
}
bool
IsEnabled
(
)
const
{
return
mCanBeExposed
&
&
nsCSSProps
:
:
IsEnabled
(
mProperty
CSSEnabledState
:
:
ForAllContent
)
;
}
}
;
#
include
"
nsComputedDOMStyleGenerated
.
inc
"
uint32_t
Length
(
)
{
Update
(
)
;
return
mEnumerablePropertyCount
;
}
nsCSSPropertyID
PropertyAt
(
uint32_t
aIndex
)
{
Update
(
)
;
return
kEntries
[
EntryIndex
(
aIndex
)
]
.
mProperty
;
}
const
Entry
*
FindEntryForProperty
(
nsCSSPropertyID
aPropID
)
{
if
(
size_t
(
aPropID
)
>
=
ArrayLength
(
kEntryIndices
)
)
{
MOZ_ASSERT
(
aPropID
=
=
eCSSProperty_UNKNOWN
)
;
return
nullptr
;
}
MOZ_ASSERT
(
kEntryIndices
[
aPropID
]
<
ArrayLength
(
kEntries
)
)
;
const
auto
&
entry
=
kEntries
[
kEntryIndices
[
aPropID
]
]
;
if
(
!
entry
.
IsEnabled
(
)
)
{
return
nullptr
;
}
return
&
entry
;
}
void
MarkDirty
(
)
{
mEnumerablePropertyCount
=
0
;
}
uint32_t
mEnumerablePropertyCount
=
0
;
uint32_t
mIndexMap
[
ArrayLength
(
kEntries
)
]
;
private
:
bool
IsDirty
(
)
{
return
mEnumerablePropertyCount
=
=
0
;
}
void
Update
(
)
;
uint32_t
EntryIndex
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mEnumerablePropertyCount
)
;
return
mIndexMap
[
aIndex
]
;
}
}
;
constexpr
ComputedStyleMap
:
:
Entry
ComputedStyleMap
:
:
kEntries
[
ArrayLength
(
kEntries
)
]
;
constexpr
size_t
ComputedStyleMap
:
:
kEntryIndices
[
ArrayLength
(
kEntries
)
]
;
void
ComputedStyleMap
:
:
Update
(
)
{
if
(
!
IsDirty
(
)
)
{
return
;
}
uint32_t
index
=
0
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kEntries
)
;
i
+
+
)
{
if
(
kEntries
[
i
]
.
IsEnumerable
(
)
)
{
mIndexMap
[
index
+
+
]
=
i
;
}
}
mEnumerablePropertyCount
=
index
;
}
nsComputedDOMStyle
:
:
nsComputedDOMStyle
(
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudo
nsAtom
*
aFunctionalPseudoParameter
Document
*
aDocument
StyleType
aStyleType
AlwaysReturnEmptyStyle
aAlwaysEmpty
)
:
mDocumentWeak
(
nullptr
)
mOuterFrame
(
nullptr
)
mInnerFrame
(
nullptr
)
mPresShell
(
nullptr
)
mPseudo
(
aPseudo
)
mFunctionalPseudoParameter
(
aFunctionalPseudoParameter
)
mStyleType
(
aStyleType
)
mAlwaysReturnEmpty
(
aAlwaysEmpty
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aDocument
)
;
mDocumentWeak
=
aDocument
;
mElement
=
aElement
;
SetEnabledCallbacks
(
nsIMutationObserver
:
:
kParentChainChanged
)
;
}
nsComputedDOMStyle
:
:
~
nsComputedDOMStyle
(
)
{
MOZ_ASSERT
(
!
mResolvedComputedStyle
"
Should
have
called
ClearComputedStyle
(
)
during
last
release
.
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
nsComputedDOMStyle
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsComputedDOMStyle
)
tmp
-
>
ClearComputedStyle
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsComputedDOMStyle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsComputedDOMStyle
)
if
(
!
tmp
-
>
GetWrapperPreserveColor
(
)
)
{
return
!
tmp
-
>
mElement
|
|
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
CanSkip
(
tmp
-
>
mElement
true
)
;
}
return
tmp
-
>
HasKnownLiveWrapper
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsComputedDOMStyle
)
if
(
!
tmp
-
>
GetWrapperPreserveColor
(
)
)
{
return
!
tmp
-
>
mElement
|
|
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
CanSkipInCC
(
tmp
-
>
mElement
)
;
}
return
tmp
-
>
HasKnownLiveWrapper
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsComputedDOMStyle
)
if
(
!
tmp
-
>
GetWrapperPreserveColor
(
)
)
{
return
!
tmp
-
>
mElement
|
|
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
CanSkipThis
(
tmp
-
>
mElement
)
;
}
return
tmp
-
>
HasKnownLiveWrapper
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsComputedDOMStyle
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
nsDOMCSSDeclaration
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsComputedDOMStyle
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsComputedDOMStyle
ClearComputedStyle
(
)
)
void
nsComputedDOMStyle
:
:
GetPropertyValue
(
const
nsCSSPropertyID
aPropID
nsACString
&
aValue
)
{
return
GetPropertyValue
(
aPropID
EmptyCString
(
)
aValue
)
;
}
void
nsComputedDOMStyle
:
:
SetPropertyValue
(
const
nsCSSPropertyID
aPropID
const
nsACString
&
aValue
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aRv
)
{
aRv
.
ThrowNoModificationAllowedError
(
nsPrintfCString
(
"
Can
'
t
set
value
for
property
'
%
s
'
in
computed
style
"
PromiseFlatCString
(
nsCSSProps
:
:
GetStringValue
(
aPropID
)
)
.
get
(
)
)
)
;
}
void
nsComputedDOMStyle
:
:
GetCssText
(
nsACString
&
aCssText
)
{
aCssText
.
Truncate
(
)
;
}
void
nsComputedDOMStyle
:
:
SetCssText
(
const
nsACString
&
aCssText
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aRv
)
{
aRv
.
ThrowNoModificationAllowedError
(
"
Can
'
t
set
cssText
on
computed
style
"
)
;
}
uint32_t
nsComputedDOMStyle
:
:
Length
(
)
{
UpdateCurrentStyleSources
(
eCSSPropertyExtra_variable
)
;
if
(
!
mComputedStyle
)
{
return
0
;
}
uint32_t
length
=
GetComputedStyleMap
(
)
-
>
Length
(
)
+
Servo_GetCustomPropertiesCount
(
mComputedStyle
)
;
ClearCurrentStyleSources
(
)
;
return
length
;
}
css
:
:
Rule
*
nsComputedDOMStyle
:
:
GetParentRule
(
)
{
return
nullptr
;
}
void
nsComputedDOMStyle
:
:
GetPropertyValue
(
const
nsACString
&
aPropertyName
nsACString
&
aReturn
)
{
nsCSSPropertyID
prop
=
nsCSSProps
:
:
LookupProperty
(
aPropertyName
)
;
GetPropertyValue
(
prop
aPropertyName
aReturn
)
;
}
void
nsComputedDOMStyle
:
:
GetPropertyValue
(
nsCSSPropertyID
aPropID
const
nsACString
&
aMaybeCustomPropertyName
nsACString
&
aReturn
)
{
MOZ_ASSERT
(
aReturn
.
IsEmpty
(
)
)
;
const
ComputedStyleMap
:
:
Entry
*
entry
=
nullptr
;
if
(
aPropID
!
=
eCSSPropertyExtra_variable
)
{
entry
=
GetComputedStyleMap
(
)
-
>
FindEntryForProperty
(
aPropID
)
;
if
(
!
entry
)
{
return
;
}
}
UpdateCurrentStyleSources
(
aPropID
)
;
if
(
!
mComputedStyle
)
{
return
;
}
auto
cleanup
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
ClearCurrentStyleSources
(
)
;
}
)
;
if
(
!
entry
)
{
MOZ_ASSERT
(
nsCSSProps
:
:
IsCustomPropertyName
(
aMaybeCustomPropertyName
)
)
;
const
nsACString
&
name
=
Substring
(
aMaybeCustomPropertyName
CSS_CUSTOM_NAME_PREFIX_LENGTH
)
;
Servo_GetCustomPropertyValue
(
mComputedStyle
&
name
mPresShell
-
>
StyleSet
(
)
-
>
RawData
(
)
&
aReturn
)
;
return
;
}
if
(
nsCSSProps
:
:
PropHasFlags
(
aPropID
CSSPropFlags
:
:
IsLogical
)
)
{
MOZ_ASSERT
(
entry
)
;
MOZ_ASSERT
(
entry
-
>
mGetter
=
=
&
nsComputedDOMStyle
:
:
DummyGetter
)
;
DebugOnly
<
nsCSSPropertyID
>
logicalProp
=
aPropID
;
aPropID
=
Servo_ResolveLogicalProperty
(
aPropID
mComputedStyle
)
;
entry
=
GetComputedStyleMap
(
)
-
>
FindEntryForProperty
(
aPropID
)
;
MOZ_ASSERT
(
NeedsToFlushLayout
(
logicalProp
)
=
=
NeedsToFlushLayout
(
aPropID
)
"
Logical
and
physical
property
don
'
t
agree
on
whether
layout
is
"
"
needed
"
)
;
}
if
(
!
nsCSSProps
:
:
PropHasFlags
(
aPropID
CSSPropFlags
:
:
SerializedByServo
)
)
{
if
(
RefPtr
<
CSSValue
>
value
=
(
this
-
>
*
entry
-
>
mGetter
)
(
)
)
{
nsAutoString
text
;
value
-
>
GetCssText
(
text
)
;
CopyUTF16toUTF8
(
text
aReturn
)
;
}
return
;
}
MOZ_ASSERT
(
entry
-
>
mGetter
=
=
&
nsComputedDOMStyle
:
:
DummyGetter
)
;
Servo_GetResolvedValue
(
mComputedStyle
aPropID
mPresShell
-
>
StyleSet
(
)
-
>
RawData
(
)
mElement
&
aReturn
)
;
}
already_AddRefed
<
const
ComputedStyle
>
nsComputedDOMStyle
:
:
GetComputedStyle
(
Element
*
aElement
PseudoStyleType
aPseudo
nsAtom
*
aFunctionalPseudoParameter
StyleType
aStyleType
)
{
if
(
Document
*
doc
=
aElement
-
>
GetComposedDoc
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Style
)
;
}
return
GetComputedStyleNoFlush
(
aElement
aPseudo
aFunctionalPseudoParameter
aStyleType
)
;
}
static
bool
MustReresolveStyle
(
const
ComputedStyle
*
aStyle
)
{
MOZ_ASSERT
(
aStyle
)
;
return
aStyle
-
>
HasPseudoElementData
(
)
&
&
!
aStyle
-
>
IsPseudoElement
(
)
;
}
static
bool
IsInFlatTree
(
const
Element
&
aElement
)
{
const
auto
*
topmost
=
&
aElement
;
while
(
true
)
{
if
(
topmost
-
>
HasServoData
(
)
)
{
return
true
;
}
const
Element
*
parent
=
topmost
-
>
GetFlattenedTreeParentElement
(
)
;
if
(
!
parent
)
{
break
;
}
topmost
=
parent
;
}
auto
*
root
=
topmost
-
>
GetFlattenedTreeParentNode
(
)
;
return
root
&
&
root
-
>
IsDocument
(
)
;
}
already_AddRefed
<
const
ComputedStyle
>
nsComputedDOMStyle
:
:
DoGetComputedStyleNoFlush
(
const
Element
*
aElement
PseudoStyleType
aPseudo
nsAtom
*
aFunctionalPseudoParameter
PresShell
*
aPresShell
StyleType
aStyleType
)
{
MOZ_ASSERT
(
aElement
"
NULL
element
"
)
;
PresShell
*
presShell
=
nsContentUtils
:
:
GetPresShellForContent
(
aElement
)
;
bool
inDocWithShell
=
true
;
if
(
!
presShell
)
{
inDocWithShell
=
false
;
presShell
=
aPresShell
;
if
(
!
presShell
)
{
return
nullptr
;
}
}
MOZ_ASSERT
(
aPseudo
=
=
PseudoStyleType
:
:
NotPseudo
|
|
PseudoStyle
:
:
IsPseudoElement
(
aPseudo
)
)
;
if
(
!
aElement
-
>
IsInComposedDoc
(
)
)
{
return
nullptr
;
}
if
(
!
IsInFlatTree
(
*
aElement
)
)
{
return
nullptr
;
}
if
(
inDocWithShell
&
&
aStyleType
=
=
StyleType
:
:
All
&
&
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
if
(
const
Element
*
element
=
GetRenderedElement
(
aElement
aPseudo
)
)
{
if
(
element
-
>
HasServoData
(
)
)
{
const
ComputedStyle
*
result
=
Servo_Element_GetMaybeOutOfDateStyle
(
element
)
;
return
do_AddRef
(
result
)
;
}
}
}
ServoStyleSet
*
styleSet
=
presShell
-
>
StyleSet
(
)
;
StyleRuleInclusion
rules
=
aStyleType
=
=
StyleType
:
:
DefaultOnly
?
StyleRuleInclusion
:
:
DefaultOnly
:
StyleRuleInclusion
:
:
All
;
RefPtr
<
ComputedStyle
>
result
=
styleSet
-
>
ResolveStyleLazily
(
*
aElement
aPseudo
aFunctionalPseudoParameter
rules
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
const
ComputedStyle
>
nsComputedDOMStyle
:
:
GetUnanimatedComputedStyleNoFlush
(
Element
*
aElement
PseudoStyleType
aPseudo
nsAtom
*
aFunctionalPseudoParameter
)
{
RefPtr
<
const
ComputedStyle
>
style
=
GetComputedStyleNoFlush
(
aElement
aPseudo
aFunctionalPseudoParameter
)
;
if
(
!
style
)
{
return
nullptr
;
}
PresShell
*
presShell
=
aElement
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
presShell
"
How
in
the
world
did
we
get
a
style
a
few
lines
above
?
"
)
;
Element
*
elementOrPseudoElement
=
AnimationUtils
:
:
GetElementForRestyle
(
aElement
aPseudo
)
;
if
(
!
elementOrPseudoElement
)
{
return
nullptr
;
}
return
presShell
-
>
StyleSet
(
)
-
>
GetBaseContextForElement
(
elementOrPseudoElement
style
)
;
}
nsMargin
nsComputedDOMStyle
:
:
GetAdjustedValuesForBoxSizing
(
)
{
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
nsMargin
adjustment
;
if
(
stylePos
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
adjustment
=
mInnerFrame
-
>
GetUsedBorderAndPadding
(
)
;
}
return
adjustment
;
}
static
void
AddImageURL
(
nsIURI
&
aURI
nsTArray
<
nsCString
>
&
aURLs
)
{
nsCString
spec
;
nsresult
rv
=
aURI
.
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
aURLs
.
AppendElement
(
std
:
:
move
(
spec
)
)
;
}
static
void
AddImageURL
(
const
StyleComputedUrl
&
aURL
nsTArray
<
nsCString
>
&
aURLs
)
{
if
(
aURL
.
IsLocalRef
(
)
)
{
return
;
}
if
(
nsIURI
*
uri
=
aURL
.
GetURI
(
)
)
{
AddImageURL
(
*
uri
aURLs
)
;
}
}
static
void
AddImageURL
(
const
StyleImage
&
aImage
nsTArray
<
nsCString
>
&
aURLs
)
{
if
(
auto
*
urlValue
=
aImage
.
GetImageRequestURLValue
(
)
)
{
AddImageURL
(
*
urlValue
aURLs
)
;
}
}
static
void
AddImageURL
(
const
StyleShapeOutside
&
aShapeOutside
nsTArray
<
nsCString
>
&
aURLs
)
{
if
(
aShapeOutside
.
IsImage
(
)
)
{
AddImageURL
(
aShapeOutside
.
AsImage
(
)
aURLs
)
;
}
}
static
void
AddImageURL
(
const
StyleClipPath
&
aClipPath
nsTArray
<
nsCString
>
&
aURLs
)
{
if
(
aClipPath
.
IsUrl
(
)
)
{
AddImageURL
(
aClipPath
.
AsUrl
(
)
aURLs
)
;
}
}
static
void
AddImageURLs
(
const
nsStyleImageLayers
&
aLayers
nsTArray
<
nsCString
>
&
aURLs
)
{
for
(
auto
i
:
IntegerRange
(
aLayers
.
mLayers
.
Length
(
)
)
)
{
AddImageURL
(
aLayers
.
mLayers
[
i
]
.
mImage
aURLs
)
;
}
}
static
void
CollectImageURLsForProperty
(
nsCSSPropertyID
aProp
const
ComputedStyle
&
aStyle
nsTArray
<
nsCString
>
&
aURLs
)
{
if
(
nsCSSProps
:
:
IsShorthand
(
aProp
)
)
{
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
p
aProp
CSSEnabledState
:
:
ForAllContent
)
{
CollectImageURLsForProperty
(
*
p
aStyle
aURLs
)
;
}
return
;
}
switch
(
aProp
)
{
case
eCSSProperty_cursor
:
for
(
auto
&
image
:
aStyle
.
StyleUI
(
)
-
>
Cursor
(
)
.
images
.
AsSpan
(
)
)
{
AddImageURL
(
image
.
image
aURLs
)
;
}
break
;
case
eCSSProperty_background_image
:
AddImageURLs
(
aStyle
.
StyleBackground
(
)
-
>
mImage
aURLs
)
;
break
;
case
eCSSProperty_mask_clip
:
AddImageURLs
(
aStyle
.
StyleSVGReset
(
)
-
>
mMask
aURLs
)
;
break
;
case
eCSSProperty_list_style_image
:
{
const
auto
&
image
=
aStyle
.
StyleList
(
)
-
>
mListStyleImage
;
if
(
image
.
IsUrl
(
)
)
{
AddImageURL
(
image
.
AsUrl
(
)
aURLs
)
;
}
break
;
}
case
eCSSProperty_border_image_source
:
AddImageURL
(
aStyle
.
StyleBorder
(
)
-
>
mBorderImageSource
aURLs
)
;
break
;
case
eCSSProperty_clip_path
:
AddImageURL
(
aStyle
.
StyleSVGReset
(
)
-
>
mClipPath
aURLs
)
;
break
;
case
eCSSProperty_shape_outside
:
AddImageURL
(
aStyle
.
StyleDisplay
(
)
-
>
mShapeOutside
aURLs
)
;
break
;
default
:
break
;
}
}
float
nsComputedDOMStyle
:
:
UsedFontSize
(
)
{
UpdateCurrentStyleSources
(
eCSSProperty_font_size
)
;
if
(
!
mComputedStyle
)
{
return
-
1
.
0
;
}
return
mComputedStyle
-
>
StyleFont
(
)
-
>
mFont
.
size
.
ToCSSPixels
(
)
;
}
void
nsComputedDOMStyle
:
:
GetCSSImageURLs
(
const
nsACString
&
aPropertyName
nsTArray
<
nsCString
>
&
aImageURLs
mozilla
:
:
ErrorResult
&
aRv
)
{
nsCSSPropertyID
prop
=
nsCSSProps
:
:
LookupProperty
(
aPropertyName
)
;
if
(
prop
=
=
eCSSProperty_UNKNOWN
)
{
aRv
.
ThrowSyntaxError
(
"
Invalid
property
name
'
"
_ns
+
aPropertyName
+
"
'
"
_ns
)
;
return
;
}
UpdateCurrentStyleSources
(
prop
)
;
if
(
!
mComputedStyle
)
{
return
;
}
CollectImageURLsForProperty
(
prop
*
mComputedStyle
aImageURLs
)
;
ClearCurrentStyleSources
(
)
;
}
DeclarationBlock
*
nsComputedDOMStyle
:
:
GetOrCreateCSSDeclaration
(
Operation
aOperation
DeclarationBlock
*
*
aCreated
)
{
MOZ_CRASH
(
"
called
nsComputedDOMStyle
:
:
GetCSSDeclaration
"
)
;
}
nsresult
nsComputedDOMStyle
:
:
SetCSSDeclaration
(
DeclarationBlock
*
MutationClosureData
*
)
{
MOZ_CRASH
(
"
called
nsComputedDOMStyle
:
:
SetCSSDeclaration
"
)
;
}
Document
*
nsComputedDOMStyle
:
:
DocToUpdate
(
)
{
MOZ_CRASH
(
"
called
nsComputedDOMStyle
:
:
DocToUpdate
"
)
;
}
nsDOMCSSDeclaration
:
:
ParsingEnvironment
nsComputedDOMStyle
:
:
GetParsingEnvironment
(
nsIPrincipal
*
aSubjectPrincipal
)
const
{
MOZ_CRASH
(
"
called
nsComputedDOMStyle
:
:
GetParsingEnvironment
"
)
;
}
void
nsComputedDOMStyle
:
:
ClearComputedStyle
(
)
{
if
(
mResolvedComputedStyle
)
{
mResolvedComputedStyle
=
false
;
mElement
-
>
RemoveMutationObserver
(
this
)
;
}
mComputedStyle
=
nullptr
;
}
void
nsComputedDOMStyle
:
:
SetResolvedComputedStyle
(
RefPtr
<
const
ComputedStyle
>
&
&
aContext
uint64_t
aGeneration
)
{
if
(
!
mResolvedComputedStyle
)
{
mResolvedComputedStyle
=
true
;
mElement
-
>
AddMutationObserver
(
this
)
;
}
mComputedStyle
=
aContext
;
mComputedStyleGeneration
=
aGeneration
;
mPresShellId
=
mPresShell
-
>
GetPresShellId
(
)
;
}
void
nsComputedDOMStyle
:
:
SetFrameComputedStyle
(
mozilla
:
:
ComputedStyle
*
aStyle
uint64_t
aGeneration
)
{
ClearComputedStyle
(
)
;
mComputedStyle
=
aStyle
;
mComputedStyleGeneration
=
aGeneration
;
mPresShellId
=
mPresShell
-
>
GetPresShellId
(
)
;
}
static
bool
MayNeedToFlushLayout
(
nsCSSPropertyID
aPropID
)
{
switch
(
aPropID
)
{
case
eCSSProperty_width
:
case
eCSSProperty_height
:
case
eCSSProperty_block_size
:
case
eCSSProperty_inline_size
:
case
eCSSProperty_line_height
:
case
eCSSProperty_grid_template_rows
:
case
eCSSProperty_grid_template_columns
:
case
eCSSProperty_perspective_origin
:
case
eCSSProperty_transform_origin
:
case
eCSSProperty_transform
:
case
eCSSProperty_border_top_width
:
case
eCSSProperty_border_bottom_width
:
case
eCSSProperty_border_left_width
:
case
eCSSProperty_border_right_width
:
case
eCSSProperty_border_block_start_width
:
case
eCSSProperty_border_block_end_width
:
case
eCSSProperty_border_inline_start_width
:
case
eCSSProperty_border_inline_end_width
:
case
eCSSProperty_top
:
case
eCSSProperty_right
:
case
eCSSProperty_bottom
:
case
eCSSProperty_left
:
case
eCSSProperty_inset_block_start
:
case
eCSSProperty_inset_block_end
:
case
eCSSProperty_inset_inline_start
:
case
eCSSProperty_inset_inline_end
:
case
eCSSProperty_padding_top
:
case
eCSSProperty_padding_right
:
case
eCSSProperty_padding_bottom
:
case
eCSSProperty_padding_left
:
case
eCSSProperty_padding_block_start
:
case
eCSSProperty_padding_block_end
:
case
eCSSProperty_padding_inline_start
:
case
eCSSProperty_padding_inline_end
:
case
eCSSProperty_margin_top
:
case
eCSSProperty_margin_right
:
case
eCSSProperty_margin_bottom
:
case
eCSSProperty_margin_left
:
case
eCSSProperty_margin_block_start
:
case
eCSSProperty_margin_block_end
:
case
eCSSProperty_margin_inline_start
:
case
eCSSProperty_margin_inline_end
:
return
true
;
default
:
return
false
;
}
}
bool
nsComputedDOMStyle
:
:
NeedsToFlushStyle
(
nsCSSPropertyID
aPropID
)
const
{
bool
mayNeedToFlushLayout
=
MayNeedToFlushLayout
(
aPropID
)
;
if
(
ElementNeedsRestyle
(
mElement
mPseudo
mayNeedToFlushLayout
)
)
{
return
true
;
}
Document
*
doc
=
mElement
-
>
OwnerDoc
(
)
;
while
(
doc
-
>
StyleOrLayoutObservablyDependsOnParentDocumentLayout
(
)
)
{
if
(
Element
*
element
=
doc
-
>
GetEmbedderElement
(
)
)
{
if
(
ElementNeedsRestyle
(
element
PseudoStyleType
:
:
NotPseudo
mayNeedToFlushLayout
)
)
{
return
true
;
}
}
doc
=
doc
-
>
GetInProcessParentDocument
(
)
;
}
return
false
;
}
static
bool
IsNonReplacedInline
(
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
StyleDisplay
(
)
-
>
IsInlineFlow
(
)
&
&
!
aFrame
-
>
IsReplaced
(
)
&
&
!
aFrame
-
>
IsFieldSetFrame
(
)
&
&
!
aFrame
-
>
IsBlockFrame
(
)
&
&
!
aFrame
-
>
IsScrollContainerFrame
(
)
&
&
!
aFrame
-
>
IsColumnSetWrapperFrame
(
)
;
}
static
Side
SideForPaddingOrMarginOrInsetProperty
(
nsCSSPropertyID
aPropID
)
{
switch
(
aPropID
)
{
case
eCSSProperty_top
:
case
eCSSProperty_margin_top
:
case
eCSSProperty_padding_top
:
return
eSideTop
;
case
eCSSProperty_right
:
case
eCSSProperty_margin_right
:
case
eCSSProperty_padding_right
:
return
eSideRight
;
case
eCSSProperty_bottom
:
case
eCSSProperty_margin_bottom
:
case
eCSSProperty_padding_bottom
:
return
eSideBottom
;
case
eCSSProperty_left
:
case
eCSSProperty_margin_left
:
case
eCSSProperty_padding_left
:
return
eSideLeft
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
property
"
)
;
return
eSideTop
;
}
}
static
bool
PaddingNeedsUsedValue
(
const
LengthPercentage
&
aValue
const
ComputedStyle
&
aStyle
)
{
return
!
aValue
.
ConvertsToLength
(
)
|
|
aStyle
.
StyleDisplay
(
)
-
>
HasAppearance
(
)
;
}
bool
nsComputedDOMStyle
:
:
NeedsToFlushLayout
(
nsCSSPropertyID
aPropID
)
const
{
MOZ_ASSERT
(
aPropID
!
=
eCSSProperty_UNKNOWN
)
;
if
(
aPropID
=
=
eCSSPropertyExtra_variable
)
{
return
false
;
}
nsIFrame
*
outerFrame
=
GetOuterFrame
(
)
;
if
(
!
outerFrame
)
{
return
false
;
}
nsIFrame
*
frame
=
nsLayoutUtils
:
:
GetStyleFrame
(
outerFrame
)
;
auto
*
style
=
frame
-
>
Style
(
)
;
if
(
nsCSSProps
:
:
PropHasFlags
(
aPropID
CSSPropFlags
:
:
IsLogical
)
)
{
aPropID
=
Servo_ResolveLogicalProperty
(
aPropID
style
)
;
}
switch
(
aPropID
)
{
case
eCSSProperty_width
:
case
eCSSProperty_height
:
return
!
IsNonReplacedInline
(
frame
)
;
case
eCSSProperty_line_height
:
return
frame
-
>
StyleFont
(
)
-
>
mLineHeight
.
IsMozBlockHeight
(
)
;
case
eCSSProperty_grid_template_rows
:
case
eCSSProperty_grid_template_columns
:
return
!
!
nsGridContainerFrame
:
:
GetGridContainerFrame
(
frame
)
;
case
eCSSProperty_perspective_origin
:
return
style
-
>
StyleDisplay
(
)
-
>
mPerspectiveOrigin
.
HasPercent
(
)
;
case
eCSSProperty_transform_origin
:
return
style
-
>
StyleDisplay
(
)
-
>
mTransformOrigin
.
HasPercent
(
)
;
case
eCSSProperty_transform
:
return
style
-
>
StyleDisplay
(
)
-
>
mTransform
.
HasPercent
(
)
;
case
eCSSProperty_border_top_width
:
case
eCSSProperty_border_bottom_width
:
case
eCSSProperty_border_left_width
:
case
eCSSProperty_border_right_width
:
return
style
-
>
StyleDisplay
(
)
-
>
HasAppearance
(
)
;
case
eCSSProperty_top
:
case
eCSSProperty_right
:
case
eCSSProperty_bottom
:
case
eCSSProperty_left
:
return
style
-
>
StyleDisplay
(
)
-
>
mPosition
!
=
StylePositionProperty
:
:
Static
;
case
eCSSProperty_padding_top
:
case
eCSSProperty_padding_right
:
case
eCSSProperty_padding_bottom
:
case
eCSSProperty_padding_left
:
{
Side
side
=
SideForPaddingOrMarginOrInsetProperty
(
aPropID
)
;
return
PaddingNeedsUsedValue
(
style
-
>
StylePadding
(
)
-
>
mPadding
.
Get
(
side
)
*
style
)
;
}
case
eCSSProperty_margin_top
:
case
eCSSProperty_margin_right
:
case
eCSSProperty_margin_bottom
:
case
eCSSProperty_margin_left
:
{
Side
side
=
SideForPaddingOrMarginOrInsetProperty
(
aPropID
)
;
return
!
style
-
>
StyleMargin
(
)
-
>
GetMargin
(
side
)
.
ConvertsToLength
(
)
;
}
default
:
return
false
;
}
}
bool
nsComputedDOMStyle
:
:
NeedsToFlushLayoutForContainerQuery
(
)
const
{
const
auto
*
outerFrame
=
GetOuterFrame
(
)
;
if
(
!
outerFrame
)
{
return
false
;
}
const
auto
*
innerFrame
=
nsLayoutUtils
:
:
GetStyleFrame
(
outerFrame
)
;
MOZ_ASSERT
(
innerFrame
"
No
valid
inner
frame
?
"
)
;
return
innerFrame
-
>
HasUnreflowedContainerQueryAncestor
(
)
;
}
void
nsComputedDOMStyle
:
:
Flush
(
Document
&
aDocument
FlushType
aFlushType
)
{
MOZ_ASSERT
(
mElement
-
>
IsInComposedDoc
(
)
)
;
MOZ_ASSERT
(
mDocumentWeak
=
=
&
aDocument
)
;
if
(
MOZ_UNLIKELY
(
&
aDocument
!
=
mElement
-
>
OwnerDoc
(
)
)
)
{
aDocument
.
FlushPendingNotifications
(
aFlushType
)
;
}
mElement
-
>
GetPrimaryFrame
(
aFlushType
)
;
}
nsIFrame
*
nsComputedDOMStyle
:
:
GetOuterFrame
(
)
const
{
if
(
mPseudo
=
=
PseudoStyleType
:
:
NotPseudo
)
{
return
mElement
-
>
GetPrimaryFrame
(
)
;
}
nsAtom
*
property
=
nullptr
;
if
(
mPseudo
=
=
PseudoStyleType
:
:
before
)
{
property
=
nsGkAtoms
:
:
beforePseudoProperty
;
}
else
if
(
mPseudo
=
=
PseudoStyleType
:
:
after
)
{
property
=
nsGkAtoms
:
:
afterPseudoProperty
;
}
else
if
(
mPseudo
=
=
PseudoStyleType
:
:
marker
)
{
property
=
nsGkAtoms
:
:
markerPseudoProperty
;
}
if
(
!
property
)
{
return
nullptr
;
}
auto
*
pseudo
=
static_cast
<
Element
*
>
(
mElement
-
>
GetProperty
(
property
)
)
;
return
pseudo
?
pseudo
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
void
nsComputedDOMStyle
:
:
UpdateCurrentStyleSources
(
nsCSSPropertyID
aPropID
)
{
nsCOMPtr
<
Document
>
document
(
mDocumentWeak
)
;
if
(
!
document
)
{
ClearComputedStyle
(
)
;
return
;
}
if
(
!
mElement
-
>
IsInComposedDoc
(
)
)
{
ClearComputedStyle
(
)
;
return
;
}
if
(
mAlwaysReturnEmpty
=
=
AlwaysReturnEmptyStyle
:
:
Yes
)
{
ClearComputedStyle
(
)
;
return
;
}
DebugOnly
<
bool
>
didFlush
=
false
;
if
(
NeedsToFlushStyle
(
aPropID
)
)
{
didFlush
=
true
;
Flush
(
*
document
FlushType
:
:
Frames
)
;
}
const
bool
needsToFlushLayoutForProp
=
NeedsToFlushLayout
(
aPropID
)
;
if
(
needsToFlushLayoutForProp
|
|
NeedsToFlushLayoutForContainerQuery
(
)
)
{
MOZ_ASSERT_IF
(
needsToFlushLayoutForProp
MayNeedToFlushLayout
(
aPropID
)
)
;
didFlush
=
true
;
Flush
(
*
document
FlushType
:
:
Layout
)
;
#
ifdef
DEBUG
mFlushedPendingReflows
=
true
;
#
endif
}
else
{
#
ifdef
DEBUG
mFlushedPendingReflows
=
false
;
#
endif
}
mPresShell
=
document
-
>
GetPresShell
(
)
;
if
(
!
mPresShell
|
|
!
mPresShell
-
>
GetPresContext
(
)
)
{
ClearComputedStyle
(
)
;
return
;
}
uint64_t
currentGeneration
=
mPresShell
-
>
GetPresContext
(
)
-
>
GetUndisplayedRestyleGeneration
(
)
;
if
(
mComputedStyle
&
&
mComputedStyleGeneration
=
=
currentGeneration
&
&
mPresShellId
=
=
mPresShell
-
>
GetPresShellId
(
)
)
{
return
;
}
mComputedStyle
=
nullptr
;
if
(
mStyleType
=
=
StyleType
:
:
All
&
&
!
mElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
mOuterFrame
=
GetOuterFrame
(
)
;
mInnerFrame
=
mOuterFrame
;
if
(
mOuterFrame
)
{
mInnerFrame
=
nsLayoutUtils
:
:
GetStyleFrame
(
mOuterFrame
)
;
SetFrameComputedStyle
(
mInnerFrame
-
>
Style
(
)
currentGeneration
)
;
NS_ASSERTION
(
mComputedStyle
"
Frame
without
style
?
"
)
;
}
}
if
(
!
mComputedStyle
|
|
MustReresolveStyle
(
mComputedStyle
)
)
{
PresShell
*
presShellForContent
=
mElement
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
RefPtr
<
const
ComputedStyle
>
resolvedComputedStyle
=
DoGetComputedStyleNoFlush
(
mElement
mPseudo
mFunctionalPseudoParameter
presShellForContent
?
presShellForContent
:
mPresShell
mStyleType
)
;
if
(
!
resolvedComputedStyle
)
{
ClearComputedStyle
(
)
;
return
;
}
NS_ASSERTION
(
!
didFlush
|
|
currentGeneration
=
=
mPresShell
-
>
GetPresContext
(
)
-
>
GetUndisplayedRestyleGeneration
(
)
"
why
should
we
have
flushed
style
again
?
"
)
;
SetResolvedComputedStyle
(
std
:
:
move
(
resolvedComputedStyle
)
currentGeneration
)
;
NS_ASSERTION
(
mPseudo
!
=
PseudoStyleType
:
:
NotPseudo
|
|
!
mComputedStyle
-
>
HasPseudoElementData
(
)
"
should
not
have
pseudo
-
element
data
"
)
;
}
MOZ_ASSERT
(
!
mExposeVisitedStyle
|
|
nsContentUtils
:
:
IsCallerChrome
(
)
"
mExposeVisitedStyle
set
incorrectly
"
)
;
if
(
mExposeVisitedStyle
&
&
mComputedStyle
-
>
RelevantLinkVisited
(
)
)
{
if
(
const
auto
*
styleIfVisited
=
mComputedStyle
-
>
GetStyleIfVisited
(
)
)
{
mComputedStyle
=
styleIfVisited
;
}
}
}
void
nsComputedDOMStyle
:
:
ClearCurrentStyleSources
(
)
{
if
(
!
mResolvedComputedStyle
|
|
mOuterFrame
)
{
ClearComputedStyle
(
)
;
}
mOuterFrame
=
nullptr
;
mInnerFrame
=
nullptr
;
mPresShell
=
nullptr
;
}
void
nsComputedDOMStyle
:
:
RemoveProperty
(
const
nsACString
&
aPropertyName
nsACString
&
aReturn
ErrorResult
&
aRv
)
{
aRv
.
ThrowNoModificationAllowedError
(
"
Can
'
t
remove
property
'
"
_ns
+
aPropertyName
+
"
'
from
computed
style
"
_ns
)
;
}
void
nsComputedDOMStyle
:
:
GetPropertyPriority
(
const
nsACString
&
aPropertyName
nsACString
&
aReturn
)
{
aReturn
.
Truncate
(
)
;
}
void
nsComputedDOMStyle
:
:
SetProperty
(
const
nsACString
&
aPropertyName
const
nsACString
&
aValue
const
nsACString
&
aPriority
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aRv
)
{
aRv
.
ThrowNoModificationAllowedError
(
"
Can
'
t
set
value
for
property
'
"
_ns
+
aPropertyName
+
"
'
in
computed
style
"
_ns
)
;
}
void
nsComputedDOMStyle
:
:
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
nsACString
&
aPropName
)
{
ComputedStyleMap
*
map
=
GetComputedStyleMap
(
)
;
uint32_t
length
=
map
-
>
Length
(
)
;
if
(
aIndex
<
length
)
{
aFound
=
true
;
aPropName
.
Assign
(
nsCSSProps
:
:
GetStringValue
(
map
-
>
PropertyAt
(
aIndex
)
)
)
;
return
;
}
UpdateCurrentStyleSources
(
eCSSPropertyExtra_variable
)
;
if
(
!
mComputedStyle
)
{
aFound
=
false
;
return
;
}
uint32_t
count
=
Servo_GetCustomPropertiesCount
(
mComputedStyle
)
;
const
uint32_t
index
=
aIndex
-
length
;
if
(
index
<
count
)
{
aFound
=
true
;
aPropName
.
AssignLiteral
(
"
-
-
"
)
;
if
(
nsAtom
*
atom
=
Servo_GetCustomPropertyNameAt
(
mComputedStyle
index
)
)
{
aPropName
.
Append
(
nsAtomCString
(
atom
)
)
;
}
}
else
{
aFound
=
false
;
}
ClearCurrentStyleSources
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBottom
(
)
{
return
GetOffsetWidthFor
(
eSideBottom
)
;
}
static
Position
MaybeResolvePositionForTransform
(
const
LengthPercentage
&
aX
const
LengthPercentage
&
aY
nsIFrame
*
aInnerFrame
)
{
if
(
!
aInnerFrame
)
{
return
{
aX
aY
}
;
}
nsStyleTransformMatrix
:
:
TransformReferenceBox
refBox
(
aInnerFrame
)
;
CSSPoint
p
=
nsStyleTransformMatrix
:
:
Convert2DPosition
(
aX
aY
refBox
)
;
return
{
LengthPercentage
:
:
FromPixels
(
p
.
x
)
LengthPercentage
:
:
FromPixels
(
p
.
y
)
}
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetTransformOrigin
(
)
{
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
const
auto
&
origin
=
StyleDisplay
(
)
-
>
mTransformOrigin
;
auto
position
=
MaybeResolvePositionForTransform
(
origin
.
horizontal
origin
.
vertical
mInnerFrame
)
;
SetValueToPosition
(
position
valueList
)
;
if
(
!
origin
.
depth
.
IsZero
(
)
)
{
valueList
-
>
AppendCSSValue
(
PixelsToCSSValue
(
origin
.
depth
.
ToCSSPixels
(
)
)
)
;
}
return
valueList
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPerspectiveOrigin
(
)
{
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
const
auto
&
origin
=
StyleDisplay
(
)
-
>
mPerspectiveOrigin
;
auto
position
=
MaybeResolvePositionForTransform
(
origin
.
horizontal
origin
.
vertical
mInnerFrame
)
;
SetValueToPosition
(
position
valueList
)
;
return
valueList
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetTransform
(
)
{
const
nsStyleDisplay
*
display
=
StyleDisplay
(
)
;
return
GetTransformValue
(
display
-
>
mTransform
)
;
}
already_AddRefed
<
nsROCSSPrimitiveValue
>
nsComputedDOMStyle
:
:
MatrixToCSSValue
(
const
mozilla
:
:
gfx
:
:
Matrix4x4
&
matrix
)
{
bool
is3D
=
!
matrix
.
Is2D
(
)
;
nsAutoString
resultString
(
u
"
matrix
"
_ns
)
;
if
(
is3D
)
{
resultString
.
AppendLiteral
(
"
3d
"
)
;
}
resultString
.
Append
(
'
(
'
)
;
resultString
.
AppendFloat
(
matrix
.
_11
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_12
)
;
resultString
.
AppendLiteral
(
"
"
)
;
if
(
is3D
)
{
resultString
.
AppendFloat
(
matrix
.
_13
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_14
)
;
resultString
.
AppendLiteral
(
"
"
)
;
}
resultString
.
AppendFloat
(
matrix
.
_21
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_22
)
;
resultString
.
AppendLiteral
(
"
"
)
;
if
(
is3D
)
{
resultString
.
AppendFloat
(
matrix
.
_23
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_24
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_31
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_32
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_33
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_34
)
;
resultString
.
AppendLiteral
(
"
"
)
;
}
resultString
.
AppendFloat
(
matrix
.
_41
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_42
)
;
if
(
is3D
)
{
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_43
)
;
resultString
.
AppendLiteral
(
"
"
)
;
resultString
.
AppendFloat
(
matrix
.
_44
)
;
}
resultString
.
Append
(
'
)
'
)
;
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
val
-
>
SetString
(
resultString
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
nsROCSSPrimitiveValue
>
nsComputedDOMStyle
:
:
AppUnitsToCSSValue
(
nscoord
aAppUnits
)
{
return
PixelsToCSSValue
(
CSSPixel
:
:
FromAppUnits
(
aAppUnits
)
)
;
}
already_AddRefed
<
nsROCSSPrimitiveValue
>
nsComputedDOMStyle
:
:
PixelsToCSSValue
(
float
aPixels
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToPixels
(
val
aPixels
)
;
return
val
.
forget
(
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToPixels
(
nsROCSSPrimitiveValue
*
aValue
float
aPixels
)
{
MOZ_ASSERT
(
mComputedStyle
)
;
aValue
-
>
SetPixels
(
mComputedStyle
-
>
EffectiveZoom
(
)
.
Unzoom
(
aPixels
)
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMozOsxFontSmoothing
(
)
{
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
mPresShell
-
>
GetPresContext
(
)
-
>
GetDocShell
(
)
RFPTarget
:
:
DOMStyleOsxFontSmoothing
)
)
{
return
nullptr
;
}
nsAutoCString
result
;
mComputedStyle
-
>
GetComputedPropertyValue
(
eCSSProperty__moz_osx_font_smoothing
result
)
;
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
val
-
>
SetString
(
result
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetImageLayerPosition
(
const
nsStyleImageLayers
&
aLayers
)
{
if
(
aLayers
.
mPositionXCount
!
=
aLayers
.
mPositionYCount
)
{
return
nullptr
;
}
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
true
)
;
for
(
uint32_t
i
=
0
i_end
=
aLayers
.
mPositionXCount
;
i
<
i_end
;
+
+
i
)
{
RefPtr
<
nsDOMCSSValueList
>
itemList
=
GetROCSSValueList
(
false
)
;
SetValueToPosition
(
aLayers
.
mLayers
[
i
]
.
mPosition
itemList
)
;
valueList
-
>
AppendCSSValue
(
itemList
.
forget
(
)
)
;
}
return
valueList
.
forget
(
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToPosition
(
const
Position
&
aPosition
nsDOMCSSValueList
*
aValueList
)
{
auto
valX
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToLengthPercentage
(
valX
aPosition
.
horizontal
false
)
;
aValueList
-
>
AppendCSSValue
(
valX
.
forget
(
)
)
;
auto
valY
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToLengthPercentage
(
valY
aPosition
.
vertical
false
)
;
aValueList
-
>
AppendCSSValue
(
valY
.
forget
(
)
)
;
}
enum
class
Brackets
{
No
Yes
}
;
static
void
AppendGridLineNames
(
nsACString
&
aResult
Span
<
const
StyleCustomIdent
>
aLineNames
Brackets
aBrackets
)
{
if
(
aLineNames
.
IsEmpty
(
)
)
{
if
(
aBrackets
=
=
Brackets
:
:
Yes
)
{
aResult
.
AppendLiteral
(
"
[
]
"
)
;
}
return
;
}
uint32_t
numLines
=
aLineNames
.
Length
(
)
;
if
(
aBrackets
=
=
Brackets
:
:
Yes
)
{
aResult
.
Append
(
'
[
'
)
;
}
for
(
uint32_t
i
=
0
;
;
)
{
nsAutoString
name
;
nsStyleUtil
:
:
AppendEscapedCSSIdent
(
nsDependentAtomString
(
aLineNames
[
i
]
.
AsAtom
(
)
)
name
)
;
AppendUTF16toUTF8
(
name
aResult
)
;
if
(
+
+
i
=
=
numLines
)
{
break
;
}
aResult
.
Append
(
'
'
)
;
}
if
(
aBrackets
=
=
Brackets
:
:
Yes
)
{
aResult
.
Append
(
'
]
'
)
;
}
}
static
void
AppendGridLineNames
(
nsDOMCSSValueList
*
aValueList
Span
<
const
StyleCustomIdent
>
aLineNames
bool
aSuppressEmptyList
=
true
)
{
if
(
aLineNames
.
IsEmpty
(
)
&
&
aSuppressEmptyList
)
{
return
;
}
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
nsAutoCString
lineNamesString
;
AppendGridLineNames
(
lineNamesString
aLineNames
Brackets
:
:
Yes
)
;
val
-
>
SetString
(
lineNamesString
)
;
aValueList
-
>
AppendCSSValue
(
val
.
forget
(
)
)
;
}
static
void
AppendGridLineNames
(
nsDOMCSSValueList
*
aValueList
Span
<
const
StyleCustomIdent
>
aLineNames1
Span
<
const
StyleCustomIdent
>
aLineNames2
)
{
if
(
aLineNames1
.
IsEmpty
(
)
&
&
aLineNames2
.
IsEmpty
(
)
)
{
return
;
}
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
nsAutoCString
lineNamesString
;
lineNamesString
.
Assign
(
'
[
'
)
;
if
(
!
aLineNames1
.
IsEmpty
(
)
)
{
AppendGridLineNames
(
lineNamesString
aLineNames1
Brackets
:
:
No
)
;
}
if
(
!
aLineNames2
.
IsEmpty
(
)
)
{
if
(
!
aLineNames1
.
IsEmpty
(
)
)
{
lineNamesString
.
Append
(
'
'
)
;
}
AppendGridLineNames
(
lineNamesString
aLineNames2
Brackets
:
:
No
)
;
}
lineNamesString
.
Append
(
'
]
'
)
;
val
-
>
SetString
(
lineNamesString
)
;
aValueList
-
>
AppendCSSValue
(
val
.
forget
(
)
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToTrackBreadth
(
nsROCSSPrimitiveValue
*
aValue
const
StyleTrackBreadth
&
aBreadth
)
{
using
Tag
=
StyleTrackBreadth
:
:
Tag
;
switch
(
aBreadth
.
tag
)
{
case
Tag
:
:
MinContent
:
return
aValue
-
>
SetString
(
"
min
-
content
"
)
;
case
Tag
:
:
MaxContent
:
return
aValue
-
>
SetString
(
"
max
-
content
"
)
;
case
Tag
:
:
Auto
:
return
aValue
-
>
SetString
(
"
auto
"
)
;
case
Tag
:
:
Breadth
:
return
SetValueToLengthPercentage
(
aValue
aBreadth
.
AsBreadth
(
)
true
)
;
case
Tag
:
:
Fr
:
{
nsAutoString
tmpStr
;
nsStyleUtil
:
:
AppendCSSNumber
(
aBreadth
.
AsFr
(
)
tmpStr
)
;
tmpStr
.
AppendLiteral
(
"
fr
"
)
;
return
aValue
-
>
SetString
(
tmpStr
)
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
breadth
value
"
)
;
return
;
}
}
already_AddRefed
<
nsROCSSPrimitiveValue
>
nsComputedDOMStyle
:
:
GetGridTrackBreadth
(
const
StyleTrackBreadth
&
aBreadth
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToTrackBreadth
(
val
aBreadth
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
nsROCSSPrimitiveValue
>
nsComputedDOMStyle
:
:
GetGridTrackSize
(
const
StyleTrackSize
&
aTrackSize
)
{
if
(
aTrackSize
.
IsFitContent
(
)
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
MOZ_ASSERT
(
aTrackSize
.
AsFitContent
(
)
.
IsBreadth
(
)
"
unexpected
unit
for
fit
-
content
(
)
argument
value
"
)
;
SetValueFromFitContentFunction
(
val
aTrackSize
.
AsFitContent
(
)
.
AsBreadth
(
)
)
;
return
val
.
forget
(
)
;
}
if
(
aTrackSize
.
IsBreadth
(
)
)
{
return
GetGridTrackBreadth
(
aTrackSize
.
AsBreadth
(
)
)
;
}
MOZ_ASSERT
(
aTrackSize
.
IsMinmax
(
)
)
;
const
auto
&
min
=
aTrackSize
.
AsMinmax
(
)
.
_0
;
const
auto
&
max
=
aTrackSize
.
AsMinmax
(
)
.
_1
;
if
(
min
=
=
max
)
{
return
GetGridTrackBreadth
(
min
)
;
}
if
(
min
.
IsAuto
(
)
&
&
max
.
IsFr
(
)
)
{
return
GetGridTrackBreadth
(
max
)
;
}
nsAutoString
argumentStr
minmaxStr
;
minmaxStr
.
AppendLiteral
(
"
minmax
(
"
)
;
{
RefPtr
<
nsROCSSPrimitiveValue
>
argValue
=
GetGridTrackBreadth
(
min
)
;
argValue
-
>
GetCssText
(
argumentStr
)
;
minmaxStr
.
Append
(
argumentStr
)
;
argumentStr
.
Truncate
(
)
;
}
minmaxStr
.
AppendLiteral
(
"
"
)
;
{
RefPtr
<
nsROCSSPrimitiveValue
>
argValue
=
GetGridTrackBreadth
(
max
)
;
argValue
-
>
GetCssText
(
argumentStr
)
;
minmaxStr
.
Append
(
argumentStr
)
;
}
minmaxStr
.
Append
(
char16_t
(
'
)
'
)
)
;
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
val
-
>
SetString
(
minmaxStr
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetGridTemplateColumnsRows
(
const
StyleGridTemplateComponent
&
aTrackList
const
ComputedGridTrackInfo
&
aTrackInfo
)
{
if
(
aTrackInfo
.
mIsMasonry
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
val
-
>
SetString
(
"
masonry
"
)
;
return
val
.
forget
(
)
;
}
if
(
aTrackInfo
.
mIsSubgrid
)
{
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
auto
subgridKeyword
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
subgridKeyword
-
>
SetString
(
"
subgrid
"
)
;
valueList
-
>
AppendCSSValue
(
subgridKeyword
.
forget
(
)
)
;
for
(
const
auto
&
lineNames
:
aTrackInfo
.
mResolvedLineNames
)
{
AppendGridLineNames
(
valueList
lineNames
false
)
;
}
uint32_t
line
=
aTrackInfo
.
mResolvedLineNames
.
Length
(
)
;
uint32_t
lastLine
=
aTrackInfo
.
mNumExplicitTracks
+
1
;
const
Span
<
const
StyleCustomIdent
>
empty
;
for
(
;
line
<
lastLine
;
+
+
line
)
{
AppendGridLineNames
(
valueList
empty
false
)
;
}
return
valueList
.
forget
(
)
;
}
const
bool
serializeImplicit
=
StaticPrefs
:
:
layout_css_serialize_grid_implicit_tracks
(
)
;
const
nsTArray
<
nscoord
>
&
trackSizes
=
aTrackInfo
.
mSizes
;
const
uint32_t
numExplicitTracks
=
aTrackInfo
.
mNumExplicitTracks
;
const
uint32_t
numLeadingImplicitTracks
=
aTrackInfo
.
mNumLeadingImplicitTracks
;
uint32_t
numSizes
=
trackSizes
.
Length
(
)
;
MOZ_ASSERT
(
numSizes
>
=
numLeadingImplicitTracks
+
numExplicitTracks
)
;
const
bool
hasTracksToSerialize
=
serializeImplicit
?
!
!
numSizes
:
!
!
numExplicitTracks
;
const
bool
hasRepeatAuto
=
aTrackList
.
HasRepeatAuto
(
)
;
if
(
!
hasTracksToSerialize
&
&
!
hasRepeatAuto
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
val
-
>
SetString
(
"
none
"
)
;
return
val
.
forget
(
)
;
}
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
if
(
serializeImplicit
)
{
for
(
uint32_t
i
=
0
;
i
<
numLeadingImplicitTracks
;
+
+
i
)
{
valueList
-
>
AppendCSSValue
(
AppUnitsToCSSValue
(
trackSizes
[
i
]
)
)
;
}
}
if
(
hasRepeatAuto
)
{
const
auto
*
const
autoRepeatValue
=
aTrackList
.
GetRepeatAutoValue
(
)
;
const
auto
repeatLineNames
=
autoRepeatValue
-
>
line_names
.
AsSpan
(
)
;
MOZ_ASSERT
(
repeatLineNames
.
Length
(
)
>
=
2
)
;
MOZ_ASSERT
(
repeatLineNames
.
Length
(
)
=
=
autoRepeatValue
-
>
track_sizes
.
len
+
1
)
;
const
uint32_t
numRepeatTracks
=
std
:
:
min
(
aTrackInfo
.
mRemovedRepeatTracks
.
Length
(
)
autoRepeatValue
-
>
track_sizes
.
len
)
;
MOZ_ASSERT
(
repeatLineNames
.
Length
(
)
>
=
numRepeatTracks
+
1
)
;
const
uint32_t
totalNumRepeatTracks
=
aTrackInfo
.
mRemovedRepeatTracks
.
Length
(
)
;
const
uint32_t
repeatStart
=
aTrackInfo
.
mRepeatFirstTrack
;
const
auto
explicitTrackSizeBegin
=
trackSizes
.
cbegin
(
)
+
numLeadingImplicitTracks
;
const
auto
explicitTrackSizeEnd
=
explicitTrackSizeBegin
+
numExplicitTracks
;
auto
trackSizeIter
=
explicitTrackSizeBegin
;
for
(
uint32_t
i
=
0
;
i
<
repeatStart
;
i
+
+
)
{
AppendGridLineNames
(
valueList
aTrackInfo
.
mResolvedLineNames
[
i
]
)
;
valueList
-
>
AppendCSSValue
(
AppUnitsToCSSValue
(
*
trackSizeIter
+
+
)
)
;
}
auto
lineNameIter
=
aTrackInfo
.
mResolvedLineNames
.
cbegin
(
)
+
repeatStart
;
AppendGridLineNames
(
valueList
*
lineNameIter
+
+
)
;
{
const
nscoord
firstRepeatTrackSize
=
(
!
aTrackInfo
.
mRemovedRepeatTracks
[
0
]
)
?
*
trackSizeIter
+
+
:
0
;
valueList
-
>
AppendCSSValue
(
AppUnitsToCSSValue
(
firstRepeatTrackSize
)
)
;
}
for
(
uint32_t
i
=
1
;
i
<
totalNumRepeatTracks
;
i
+
+
)
{
const
uint32_t
repeatIndex
=
i
%
numRepeatTracks
;
if
(
repeatIndex
=
=
0
)
{
AppendGridLineNames
(
valueList
repeatLineNames
[
numRepeatTracks
]
.
AsSpan
(
)
repeatLineNames
[
0
]
.
AsSpan
(
)
)
;
}
else
{
AppendGridLineNames
(
valueList
repeatLineNames
[
repeatIndex
]
.
AsSpan
(
)
)
;
}
MOZ_ASSERT
(
aTrackInfo
.
mRemovedRepeatTracks
[
i
]
|
|
trackSizeIter
!
=
explicitTrackSizeEnd
)
;
const
nscoord
repeatTrackSize
=
(
!
aTrackInfo
.
mRemovedRepeatTracks
[
i
]
)
?
*
trackSizeIter
+
+
:
0
;
valueList
-
>
AppendCSSValue
(
AppUnitsToCSSValue
(
repeatTrackSize
)
)
;
}
lineNameIter
+
=
numRepeatTracks
-
1
;
while
(
trackSizeIter
!
=
explicitTrackSizeEnd
)
{
AppendGridLineNames
(
valueList
*
lineNameIter
+
+
)
;
valueList
-
>
AppendCSSValue
(
AppUnitsToCSSValue
(
*
trackSizeIter
+
+
)
)
;
}
AppendGridLineNames
(
valueList
*
lineNameIter
+
+
)
;
}
else
if
(
numExplicitTracks
>
0
)
{
for
(
uint32_t
i
=
0
;
;
i
+
+
)
{
AppendGridLineNames
(
valueList
aTrackInfo
.
mResolvedLineNames
[
i
]
)
;
if
(
i
=
=
numExplicitTracks
)
{
break
;
}
valueList
-
>
AppendCSSValue
(
AppUnitsToCSSValue
(
trackSizes
[
i
+
numLeadingImplicitTracks
]
)
)
;
}
}
if
(
serializeImplicit
)
{
for
(
uint32_t
i
=
numLeadingImplicitTracks
+
numExplicitTracks
;
i
<
numSizes
;
+
+
i
)
{
valueList
-
>
AppendCSSValue
(
AppUnitsToCSSValue
(
trackSizes
[
i
]
)
)
;
}
}
return
valueList
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetGridTemplateColumns
(
)
{
nsGridContainerFrame
*
gridFrame
=
nsGridContainerFrame
:
:
GetGridFrameWithComputedInfo
(
mInnerFrame
)
;
if
(
!
gridFrame
)
{
nsAutoCString
string
;
mComputedStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_grid_template_columns
string
)
;
auto
value
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
value
-
>
SetString
(
string
)
;
return
value
.
forget
(
)
;
}
const
ComputedGridTrackInfo
*
info
=
gridFrame
-
>
GetComputedTemplateColumns
(
)
;
return
GetGridTemplateColumnsRows
(
StylePosition
(
)
-
>
mGridTemplateColumns
*
info
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetGridTemplateRows
(
)
{
nsGridContainerFrame
*
gridFrame
=
nsGridContainerFrame
:
:
GetGridFrameWithComputedInfo
(
mInnerFrame
)
;
if
(
!
gridFrame
)
{
nsAutoCString
string
;
mComputedStyle
-
>
GetComputedPropertyValue
(
eCSSProperty_grid_template_rows
string
)
;
auto
value
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
value
-
>
SetString
(
string
)
;
return
value
.
forget
(
)
;
}
const
ComputedGridTrackInfo
*
info
=
gridFrame
-
>
GetComputedTemplateRows
(
)
;
return
GetGridTemplateColumnsRows
(
StylePosition
(
)
-
>
mGridTemplateRows
*
info
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPaddingTop
(
)
{
return
GetPaddingWidthFor
(
eSideTop
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPaddingBottom
(
)
{
return
GetPaddingWidthFor
(
eSideBottom
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPaddingLeft
(
)
{
return
GetPaddingWidthFor
(
eSideLeft
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetPaddingRight
(
)
{
return
GetPaddingWidthFor
(
eSideRight
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderSpacing
(
)
{
RefPtr
<
nsDOMCSSValueList
>
valueList
=
GetROCSSValueList
(
false
)
;
const
nsStyleTableBorder
*
border
=
StyleTableBorder
(
)
;
valueList
-
>
AppendCSSValue
(
PixelsToCSSValue
(
border
-
>
mBorderSpacing
.
width
.
ToCSSPixels
(
)
)
)
;
valueList
-
>
AppendCSSValue
(
PixelsToCSSValue
(
border
-
>
mBorderSpacing
.
height
.
ToCSSPixels
(
)
)
)
;
return
valueList
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderTopWidth
(
)
{
return
GetBorderWidthFor
(
eSideTop
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderBottomWidth
(
)
{
return
GetBorderWidthFor
(
eSideBottom
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderLeftWidth
(
)
{
return
GetBorderWidthFor
(
eSideLeft
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetBorderRightWidth
(
)
{
return
GetBorderWidthFor
(
eSideRight
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMarginTop
(
)
{
return
GetMarginFor
(
eSideTop
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMarginBottom
(
)
{
return
GetMarginFor
(
eSideBottom
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMarginLeft
(
)
{
return
GetMarginFor
(
eSideLeft
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMarginRight
(
)
{
return
GetMarginFor
(
eSideRight
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetHeight
(
)
{
if
(
mInnerFrame
&
&
!
IsNonReplacedInline
(
mInnerFrame
)
)
{
AssertFlushedPendingReflows
(
)
;
const
nsMargin
adjustedValues
=
GetAdjustedValuesForBoxSizing
(
)
;
return
AppUnitsToCSSValue
(
mInnerFrame
-
>
GetContentRect
(
)
.
height
+
adjustedValues
.
TopBottom
(
)
)
;
}
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToSize
(
val
StylePosition
(
)
-
>
mHeight
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetWidth
(
)
{
if
(
mInnerFrame
&
&
!
IsNonReplacedInline
(
mInnerFrame
)
)
{
AssertFlushedPendingReflows
(
)
;
nsMargin
adjustedValues
=
GetAdjustedValuesForBoxSizing
(
)
;
return
AppUnitsToCSSValue
(
mInnerFrame
-
>
GetContentRect
(
)
.
width
+
adjustedValues
.
LeftRight
(
)
)
;
}
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToSize
(
val
StylePosition
(
)
-
>
mWidth
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMaxHeight
(
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToMaxSize
(
val
StylePosition
(
)
-
>
mMaxHeight
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMaxWidth
(
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToMaxSize
(
val
StylePosition
(
)
-
>
mMaxWidth
)
;
return
val
.
forget
(
)
;
}
bool
nsComputedDOMStyle
:
:
ShouldHonorMinSizeAutoInAxis
(
PhysicalAxis
aAxis
)
{
return
mOuterFrame
&
&
mOuterFrame
-
>
IsFlexOrGridItem
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMinHeight
(
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
StyleSize
minHeight
=
StylePosition
(
)
-
>
mMinHeight
;
if
(
minHeight
.
IsAuto
(
)
&
&
!
ShouldHonorMinSizeAutoInAxis
(
PhysicalAxis
:
:
Vertical
)
)
{
minHeight
=
StyleSize
:
:
LengthPercentage
(
LengthPercentage
:
:
Zero
(
)
)
;
}
SetValueToSize
(
val
minHeight
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetMinWidth
(
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
StyleSize
minWidth
=
StylePosition
(
)
-
>
mMinWidth
;
if
(
minWidth
.
IsAuto
(
)
&
&
!
ShouldHonorMinSizeAutoInAxis
(
PhysicalAxis
:
:
Horizontal
)
)
{
minWidth
=
StyleSize
:
:
LengthPercentage
(
LengthPercentage
:
:
Zero
(
)
)
;
}
SetValueToSize
(
val
minWidth
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetLeft
(
)
{
return
GetOffsetWidthFor
(
eSideLeft
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetRight
(
)
{
return
GetOffsetWidthFor
(
eSideRight
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DoGetTop
(
)
{
return
GetOffsetWidthFor
(
eSideTop
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetOffsetWidthFor
(
mozilla
:
:
Side
aSide
)
{
const
nsStyleDisplay
*
display
=
StyleDisplay
(
)
;
mozilla
:
:
StylePositionProperty
position
=
display
-
>
mPosition
;
if
(
!
mOuterFrame
)
{
position
=
StylePositionProperty
:
:
Static
;
}
switch
(
position
)
{
case
StylePositionProperty
:
:
Static
:
return
GetStaticOffset
(
aSide
)
;
case
StylePositionProperty
:
:
Sticky
:
return
GetNonStaticPositionOffset
(
aSide
false
&
nsComputedDOMStyle
:
:
GetScrollFrameContentWidth
&
nsComputedDOMStyle
:
:
GetScrollFrameContentHeight
)
;
case
StylePositionProperty
:
:
Absolute
:
case
StylePositionProperty
:
:
Fixed
:
return
GetAbsoluteOffset
(
aSide
)
;
case
StylePositionProperty
:
:
Relative
:
return
GetNonStaticPositionOffset
(
aSide
true
&
nsComputedDOMStyle
:
:
GetCBContentWidth
&
nsComputedDOMStyle
:
:
GetCBContentHeight
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
position
"
)
;
return
nullptr
;
}
}
static_assert
(
eSideTop
=
=
0
&
&
eSideRight
=
=
1
&
&
eSideBottom
=
=
2
&
&
eSideLeft
=
=
3
"
box
side
constants
not
as
expected
for
NS_OPPOSITE_SIDE
"
)
;
#
define
NS_OPPOSITE_SIDE
(
s_
)
mozilla
:
:
Side
(
(
(
s_
)
+
2
)
&
3
)
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetNonStaticPositionOffset
(
mozilla
:
:
Side
aSide
bool
aResolveAuto
PercentageBaseGetter
aWidthGetter
PercentageBaseGetter
aHeightGetter
)
{
const
nsStylePosition
*
positionData
=
StylePosition
(
)
;
int32_t
sign
=
1
;
auto
coord
=
positionData
-
>
GetInset
(
aSide
)
;
if
(
!
coord
.
IsLengthPercentage
(
)
)
{
if
(
!
aResolveAuto
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
val
-
>
SetString
(
"
auto
"
)
;
return
val
.
forget
(
)
;
}
coord
=
positionData
-
>
GetInset
(
NS_OPPOSITE_SIDE
(
aSide
)
)
;
sign
=
-
1
;
}
if
(
!
coord
.
IsLengthPercentage
(
)
)
{
return
PixelsToCSSValue
(
0
.
0f
)
;
}
const
auto
&
lp
=
coord
.
AsLengthPercentage
(
)
;
if
(
lp
.
ConvertsToLength
(
)
)
{
return
PixelsToCSSValue
(
sign
*
lp
.
ToLengthInCSSPixels
(
)
)
;
}
PercentageBaseGetter
baseGetter
=
(
aSide
=
=
eSideLeft
|
|
aSide
=
=
eSideRight
)
?
aWidthGetter
:
aHeightGetter
;
nscoord
percentageBase
;
if
(
!
(
this
-
>
*
baseGetter
)
(
percentageBase
)
)
{
return
PixelsToCSSValue
(
0
.
0f
)
;
}
nscoord
result
=
lp
.
Resolve
(
percentageBase
)
;
return
AppUnitsToCSSValue
(
sign
*
result
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetAbsoluteOffset
(
mozilla
:
:
Side
aSide
)
{
const
auto
&
coord
=
StylePosition
(
)
-
>
GetInset
(
aSide
)
;
const
auto
&
oppositeCoord
=
StylePosition
(
)
-
>
GetInset
(
NS_OPPOSITE_SIDE
(
aSide
)
)
;
if
(
coord
.
IsAuto
(
)
|
|
oppositeCoord
.
IsAuto
(
)
)
{
return
AppUnitsToCSSValue
(
GetUsedAbsoluteOffset
(
aSide
)
)
;
}
return
GetNonStaticPositionOffset
(
aSide
false
&
nsComputedDOMStyle
:
:
GetCBPaddingRectWidth
&
nsComputedDOMStyle
:
:
GetCBPaddingRectHeight
)
;
}
nscoord
nsComputedDOMStyle
:
:
GetUsedAbsoluteOffset
(
mozilla
:
:
Side
aSide
)
{
MOZ_ASSERT
(
mOuterFrame
"
need
a
frame
so
we
can
call
GetContainingBlock
(
)
"
)
;
nsIFrame
*
container
=
mOuterFrame
-
>
GetContainingBlock
(
)
;
nsMargin
margin
=
mOuterFrame
-
>
GetUsedMargin
(
)
;
nsMargin
border
=
container
-
>
GetUsedBorder
(
)
;
nsMargin
scrollbarSizes
(
0
0
0
0
)
;
nsRect
rect
=
mOuterFrame
-
>
GetRect
(
)
;
nsRect
containerRect
=
container
-
>
GetRect
(
)
;
if
(
container
-
>
IsViewportFrame
(
)
)
{
nsIFrame
*
scrollingChild
=
container
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
ScrollContainerFrame
*
scrollContainerFrame
=
do_QueryFrame
(
scrollingChild
)
;
if
(
scrollContainerFrame
)
{
scrollbarSizes
=
scrollContainerFrame
-
>
GetActualScrollbarSizes
(
)
;
}
const
ViewportFrame
*
viewportFrame
=
do_QueryFrame
(
container
)
;
MOZ_ASSERT
(
viewportFrame
)
;
containerRect
.
SizeTo
(
viewportFrame
-
>
AdjustViewportSizeForFixedPosition
(
containerRect
)
)
;
}
else
if
(
container
-
>
IsGridContainerFrame
(
)
&
&
mOuterFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
containerRect
=
nsGridContainerFrame
:
:
GridItemCB
(
mOuterFrame
)
;
rect
.
MoveBy
(
-
containerRect
.
x
-
containerRect
.
y
)
;
}
nscoord
offset
=
0
;
switch
(
aSide
)
{
case
eSideTop
:
offset
=
rect
.
y
-
margin
.
top
-
border
.
top
-
scrollbarSizes
.
top
;
break
;
case
eSideRight
:
offset
=
containerRect
.
width
-
rect
.
width
-
rect
.
x
-
margin
.
right
-
border
.
right
-
scrollbarSizes
.
right
;
break
;
case
eSideBottom
:
offset
=
containerRect
.
height
-
rect
.
height
-
rect
.
y
-
margin
.
bottom
-
border
.
bottom
-
scrollbarSizes
.
bottom
;
break
;
case
eSideLeft
:
offset
=
rect
.
x
-
margin
.
left
-
border
.
left
-
scrollbarSizes
.
left
;
break
;
default
:
NS_ERROR
(
"
Invalid
side
"
)
;
break
;
}
return
offset
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetStaticOffset
(
mozilla
:
:
Side
aSide
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToInset
(
val
StylePosition
(
)
-
>
GetInset
(
aSide
)
)
;
return
val
.
forget
(
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetPaddingWidthFor
(
mozilla
:
:
Side
aSide
)
{
const
auto
&
padding
=
StylePadding
(
)
-
>
mPadding
.
Get
(
aSide
)
;
if
(
!
mInnerFrame
|
|
!
PaddingNeedsUsedValue
(
padding
*
mComputedStyle
)
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToLengthPercentage
(
val
padding
true
)
;
return
val
.
forget
(
)
;
}
AssertFlushedPendingReflows
(
)
;
return
AppUnitsToCSSValue
(
mInnerFrame
-
>
GetUsedPadding
(
)
.
Side
(
aSide
)
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetBorderWidthFor
(
mozilla
:
:
Side
aSide
)
{
nscoord
width
;
if
(
mInnerFrame
&
&
mComputedStyle
-
>
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
AssertFlushedPendingReflows
(
)
;
width
=
mInnerFrame
-
>
GetUsedBorder
(
)
.
Side
(
aSide
)
;
}
else
{
width
=
StyleBorder
(
)
-
>
GetComputedBorderWidth
(
aSide
)
;
}
return
AppUnitsToCSSValue
(
width
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetMarginFor
(
Side
aSide
)
{
const
auto
&
margin
=
StyleMargin
(
)
-
>
GetMargin
(
aSide
)
;
if
(
!
mInnerFrame
|
|
margin
.
ConvertsToLength
(
)
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
SetValueToMargin
(
val
margin
)
;
return
val
.
forget
(
)
;
}
AssertFlushedPendingReflows
(
)
;
NS_ASSERTION
(
mOuterFrame
=
=
mInnerFrame
|
|
mInnerFrame
-
>
GetUsedMargin
(
)
=
=
nsMargin
(
)
"
Inner
tables
must
have
zero
margins
"
)
;
return
AppUnitsToCSSValue
(
mOuterFrame
-
>
GetUsedMargin
(
)
.
Side
(
aSide
)
)
;
}
static
void
SetValueToExtremumLength
(
nsROCSSPrimitiveValue
*
aValue
nsIFrame
:
:
ExtremumLength
aSize
)
{
switch
(
aSize
)
{
case
nsIFrame
:
:
ExtremumLength
:
:
MaxContent
:
return
aValue
-
>
SetString
(
"
max
-
content
"
)
;
case
nsIFrame
:
:
ExtremumLength
:
:
MinContent
:
return
aValue
-
>
SetString
(
"
min
-
content
"
)
;
case
nsIFrame
:
:
ExtremumLength
:
:
MozAvailable
:
return
aValue
-
>
SetString
(
"
-
moz
-
available
"
)
;
case
nsIFrame
:
:
ExtremumLength
:
:
Stretch
:
{
if
(
!
StaticPrefs
:
:
layout_css_stretch_size_keyword_enabled
(
)
&
&
StaticPrefs
:
:
layout_css_webkit_fill_available_enabled
(
)
)
{
return
aValue
-
>
SetString
(
"
-
webkit
-
fill
-
available
"
)
;
}
return
aValue
-
>
SetString
(
"
stretch
"
)
;
}
case
nsIFrame
:
:
ExtremumLength
:
:
FitContent
:
return
aValue
-
>
SetString
(
"
fit
-
content
"
)
;
case
nsIFrame
:
:
ExtremumLength
:
:
FitContentFunction
:
MOZ_ASSERT_UNREACHABLE
(
"
fit
-
content
(
)
should
be
handled
separately
"
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
extremum
length
?
"
)
;
}
void
nsComputedDOMStyle
:
:
SetValueFromFitContentFunction
(
nsROCSSPrimitiveValue
*
aValue
const
LengthPercentage
&
aLength
)
{
nsAutoString
argumentStr
;
SetValueToLengthPercentage
(
aValue
aLength
true
)
;
aValue
-
>
GetCssText
(
argumentStr
)
;
nsAutoString
fitContentStr
;
fitContentStr
.
AppendLiteral
(
"
fit
-
content
(
"
)
;
fitContentStr
.
Append
(
argumentStr
)
;
fitContentStr
.
Append
(
u
'
)
'
)
;
aValue
-
>
SetString
(
fitContentStr
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToSize
(
nsROCSSPrimitiveValue
*
aValue
const
StyleSize
&
aSize
)
{
if
(
aSize
.
IsAuto
(
)
)
{
return
aValue
-
>
SetString
(
"
auto
"
)
;
}
if
(
aSize
.
IsFitContentFunction
(
)
)
{
return
SetValueFromFitContentFunction
(
aValue
aSize
.
AsFitContentFunction
(
)
)
;
}
if
(
auto
length
=
nsIFrame
:
:
ToExtremumLength
(
aSize
)
)
{
return
SetValueToExtremumLength
(
aValue
*
length
)
;
}
MOZ_ASSERT
(
aSize
.
IsLengthPercentage
(
)
)
;
SetValueToLengthPercentage
(
aValue
aSize
.
AsLengthPercentage
(
)
true
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToMaxSize
(
nsROCSSPrimitiveValue
*
aValue
const
StyleMaxSize
&
aSize
)
{
if
(
aSize
.
IsNone
(
)
)
{
return
aValue
-
>
SetString
(
"
none
"
)
;
}
if
(
aSize
.
IsFitContentFunction
(
)
)
{
return
SetValueFromFitContentFunction
(
aValue
aSize
.
AsFitContentFunction
(
)
)
;
}
if
(
auto
length
=
nsIFrame
:
:
ToExtremumLength
(
aSize
)
)
{
return
SetValueToExtremumLength
(
aValue
*
length
)
;
}
MOZ_ASSERT
(
aSize
.
IsLengthPercentage
(
)
)
;
SetValueToLengthPercentage
(
aValue
aSize
.
AsLengthPercentage
(
)
true
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToLengthPercentageOrAuto
(
nsROCSSPrimitiveValue
*
aValue
const
LengthPercentageOrAuto
&
aSize
bool
aClampNegativeCalc
)
{
if
(
aSize
.
IsAuto
(
)
)
{
return
aValue
-
>
SetString
(
"
auto
"
)
;
}
SetValueToLengthPercentage
(
aValue
aSize
.
AsLengthPercentage
(
)
aClampNegativeCalc
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToInset
(
nsROCSSPrimitiveValue
*
aValue
const
mozilla
:
:
StyleInset
&
aInset
)
{
if
(
!
aInset
.
IsLengthPercentage
(
)
)
{
aValue
-
>
SetString
(
"
auto
"
)
;
return
;
}
SetValueToLengthPercentage
(
aValue
aInset
.
AsLengthPercentage
(
)
false
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToMargin
(
nsROCSSPrimitiveValue
*
aValue
const
mozilla
:
:
StyleMargin
&
aMargin
)
{
if
(
!
aMargin
.
IsLengthPercentage
(
)
)
{
aValue
-
>
SetString
(
"
auto
"
)
;
return
;
}
SetValueToLengthPercentage
(
aValue
aMargin
.
AsLengthPercentage
(
)
false
)
;
}
void
nsComputedDOMStyle
:
:
SetValueToLengthPercentage
(
nsROCSSPrimitiveValue
*
aValue
const
mozilla
:
:
LengthPercentage
&
aLength
bool
aClampNegativeCalc
)
{
if
(
aLength
.
ConvertsToLength
(
)
)
{
CSSCoord
length
=
aLength
.
ToLengthInCSSPixels
(
)
;
if
(
aClampNegativeCalc
)
{
length
=
std
:
:
max
(
float
(
length
)
0
.
0f
)
;
}
return
SetValueToPixels
(
aValue
length
)
;
}
if
(
aLength
.
ConvertsToPercentage
(
)
)
{
float
result
=
aLength
.
ToPercentage
(
)
;
if
(
aClampNegativeCalc
)
{
result
=
std
:
:
max
(
result
0
.
0f
)
;
}
return
aValue
-
>
SetPercent
(
result
)
;
}
nsAutoCString
result
;
Servo_LengthPercentage_ToCss
(
&
aLength
&
result
)
;
aValue
-
>
SetString
(
result
)
;
}
bool
nsComputedDOMStyle
:
:
GetCBContentWidth
(
nscoord
&
aWidth
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aWidth
=
mOuterFrame
-
>
GetContainingBlock
(
)
-
>
GetContentRect
(
)
.
width
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetCBContentHeight
(
nscoord
&
aHeight
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aHeight
=
mOuterFrame
-
>
GetContainingBlock
(
)
-
>
GetContentRect
(
)
.
height
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetCBPaddingRectWidth
(
nscoord
&
aWidth
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aWidth
=
mOuterFrame
-
>
GetContainingBlock
(
)
-
>
GetPaddingRect
(
)
.
width
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetCBPaddingRectHeight
(
nscoord
&
aHeight
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aHeight
=
mOuterFrame
-
>
GetContainingBlock
(
)
-
>
GetPaddingRect
(
)
.
height
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetScrollFrameContentWidth
(
nscoord
&
aWidth
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
ScrollContainerFrame
*
scrollContainerFrame
=
nsLayoutUtils
:
:
GetNearestScrollContainerFrame
(
mOuterFrame
-
>
GetParent
(
)
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
!
scrollContainerFrame
)
{
return
false
;
}
aWidth
=
scrollContainerFrame
-
>
GetScrolledFrame
(
)
-
>
GetContentRectRelativeToSelf
(
)
.
width
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetScrollFrameContentHeight
(
nscoord
&
aHeight
)
{
if
(
!
mOuterFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
ScrollContainerFrame
*
scrollContainerFrame
=
nsLayoutUtils
:
:
GetNearestScrollContainerFrame
(
mOuterFrame
-
>
GetParent
(
)
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
!
scrollContainerFrame
)
{
return
false
;
}
aHeight
=
scrollContainerFrame
-
>
GetScrolledFrame
(
)
-
>
GetContentRectRelativeToSelf
(
)
.
height
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetFrameBorderRectWidth
(
nscoord
&
aWidth
)
{
if
(
!
mInnerFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aWidth
=
mInnerFrame
-
>
GetSize
(
)
.
width
;
return
true
;
}
bool
nsComputedDOMStyle
:
:
GetFrameBorderRectHeight
(
nscoord
&
aHeight
)
{
if
(
!
mInnerFrame
)
{
return
false
;
}
AssertFlushedPendingReflows
(
)
;
aHeight
=
mInnerFrame
-
>
GetSize
(
)
.
height
;
return
true
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
GetTransformValue
(
const
StyleTransform
&
aTransform
)
{
if
(
aTransform
.
IsNone
(
)
)
{
auto
val
=
MakeRefPtr
<
nsROCSSPrimitiveValue
>
(
)
;
val
-
>
SetString
(
"
none
"
)
;
return
val
.
forget
(
)
;
}
nsStyleTransformMatrix
:
:
TransformReferenceBox
refBox
(
mInnerFrame
nsRect
(
)
)
;
gfx
:
:
Matrix4x4
matrix
=
nsStyleTransformMatrix
:
:
ReadTransforms
(
aTransform
refBox
float
(
mozilla
:
:
AppUnitsPerCSSPixel
(
)
)
)
;
return
MatrixToCSSValue
(
matrix
)
;
}
already_AddRefed
<
CSSValue
>
nsComputedDOMStyle
:
:
DummyGetter
(
)
{
MOZ_CRASH
(
"
DummyGetter
is
not
supposed
to
be
invoked
"
)
;
}
static
void
MarkComputedStyleMapDirty
(
const
char
*
aPref
void
*
aMap
)
{
static_cast
<
ComputedStyleMap
*
>
(
aMap
)
-
>
MarkDirty
(
)
;
}
void
nsComputedDOMStyle
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
NS_ASSERTION
(
mElement
=
=
aContent
"
didn
'
t
we
register
mElement
?
"
)
;
NS_ASSERTION
(
mResolvedComputedStyle
"
should
have
only
registered
an
observer
when
"
"
mResolvedComputedStyle
is
true
"
)
;
ClearComputedStyle
(
)
;
}
ComputedStyleMap
*
nsComputedDOMStyle
:
:
GetComputedStyleMap
(
)
{
static
ComputedStyleMap
map
{
}
;
return
&
map
;
}
static
StaticAutoPtr
<
nsTArray
<
const
char
*
>
>
gCallbackPrefs
;
void
nsComputedDOMStyle
:
:
RegisterPrefChangeCallbacks
(
)
{
AutoTArray
<
const
char
*
64
>
prefs
;
for
(
const
auto
*
p
=
nsCSSProps
:
:
kPropertyPrefTable
;
p
-
>
mPropID
!
=
eCSSProperty_UNKNOWN
;
p
+
+
)
{
if
(
!
prefs
.
ContainsSorted
(
p
-
>
mPref
)
)
{
prefs
.
InsertElementSorted
(
p
-
>
mPref
)
;
}
}
prefs
.
AppendElement
(
nullptr
)
;
MOZ_ASSERT
(
!
gCallbackPrefs
)
;
gCallbackPrefs
=
new
nsTArray
<
const
char
*
>
(
std
:
:
move
(
prefs
)
)
;
Preferences
:
:
RegisterCallbacks
(
MarkComputedStyleMapDirty
gCallbackPrefs
-
>
Elements
(
)
GetComputedStyleMap
(
)
)
;
}
void
nsComputedDOMStyle
:
:
UnregisterPrefChangeCallbacks
(
)
{
if
(
!
gCallbackPrefs
)
{
return
;
}
Preferences
:
:
UnregisterCallbacks
(
MarkComputedStyleMapDirty
gCallbackPrefs
-
>
Elements
(
)
GetComputedStyleMap
(
)
)
;
gCallbackPrefs
=
nullptr
;
}
