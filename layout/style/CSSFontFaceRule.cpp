#
include
"
mozilla
/
dom
/
CSSFontFaceRule
.
h
"
#
include
"
mozilla
/
dom
/
CSSFontFaceRuleBinding
.
h
"
#
include
"
mozilla
/
dom
/
CSSStyleDeclarationBinding
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
nsCSSProps
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_INTERFACE_MAP_BEGIN
(
CSSFontFaceRuleDecl
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsICSSDeclaration
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsCycleCollectionISupports
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsXPCOMCycleCollectionParticipant
)
)
)
{
return
ContainingRule
(
)
-
>
QueryInterface
(
aIID
aInstancePtr
)
;
}
else
NS_INTERFACE_MAP_END
NS_IMPL_ADDREF_USING_AGGREGATOR
(
CSSFontFaceRuleDecl
ContainingRule
(
)
)
NS_IMPL_RELEASE_USING_AGGREGATOR
(
CSSFontFaceRuleDecl
ContainingRule
(
)
)
void
CSSFontFaceRuleDecl
:
:
GetPropertyValue
(
nsCSSFontDesc
aFontDescID
nsAString
&
aResult
)
const
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
Servo_FontFaceRule_GetDescriptorCssText
(
mRawRule
aFontDescID
&
aResult
)
;
}
void
CSSFontFaceRuleDecl
:
:
GetCssText
(
nsAString
&
aCssText
)
{
aCssText
.
Truncate
(
)
;
Servo_FontFaceRule_GetDeclCssText
(
mRawRule
&
aCssText
)
;
}
void
CSSFontFaceRuleDecl
:
:
SetCssText
(
const
nsAString
&
aCssText
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
ContainingRule
(
)
-
>
IsReadOnly
(
)
)
{
return
;
}
aRv
.
ThrowNotSupportedError
(
"
Can
'
t
set
cssText
on
CSSFontFaceRule
declarations
"
)
;
}
NS_IMETHODIMP
CSSFontFaceRuleDecl
:
:
GetPropertyValue
(
const
nsACString
&
aPropName
nsAString
&
aResult
)
{
aResult
.
Truncate
(
)
;
nsCSSFontDesc
descID
=
nsCSSProps
:
:
LookupFontDesc
(
aPropName
)
;
if
(
descID
!
=
eCSSFontDesc_UNKNOWN
)
{
GetPropertyValue
(
descID
aResult
)
;
}
return
NS_OK
;
}
void
CSSFontFaceRuleDecl
:
:
RemoveProperty
(
const
nsACString
&
aPropName
nsAString
&
aResult
ErrorResult
&
aRv
)
{
nsCSSFontDesc
descID
=
nsCSSProps
:
:
LookupFontDesc
(
aPropName
)
;
NS_ASSERTION
(
descID
>
=
eCSSFontDesc_UNKNOWN
&
&
descID
<
eCSSFontDesc_COUNT
"
LookupFontDesc
returned
value
out
of
range
"
)
;
if
(
ContainingRule
(
)
-
>
IsReadOnly
(
)
)
{
return
;
}
aResult
.
Truncate
(
)
;
if
(
descID
!
=
eCSSFontDesc_UNKNOWN
)
{
GetPropertyValue
(
descID
aResult
)
;
Servo_FontFaceRule_ResetDescriptor
(
mRawRule
descID
)
;
}
}
void
CSSFontFaceRuleDecl
:
:
GetPropertyPriority
(
const
nsACString
&
aPropName
nsAString
&
aResult
)
{
aResult
.
Truncate
(
)
;
}
void
CSSFontFaceRuleDecl
:
:
SetProperty
(
const
nsACString
&
aPropName
const
nsACString
&
aValue
const
nsAString
&
aPriority
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
ContainingRule
(
)
-
>
IsReadOnly
(
)
)
{
return
;
}
aRv
.
ThrowNotSupportedError
(
"
Can
'
t
set
properties
on
CSSFontFaceRule
declarations
"
)
;
}
uint32_t
CSSFontFaceRuleDecl
:
:
Length
(
)
{
return
Servo_FontFaceRule_Length
(
mRawRule
)
;
}
void
CSSFontFaceRuleDecl
:
:
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
nsACString
&
aResult
)
{
nsCSSFontDesc
id
=
Servo_FontFaceRule_IndexGetter
(
mRawRule
aIndex
)
;
if
(
id
!
=
eCSSFontDesc_UNKNOWN
)
{
aFound
=
true
;
aResult
.
Assign
(
nsCSSProps
:
:
GetStringValue
(
id
)
)
;
}
else
{
aFound
=
false
;
}
}
css
:
:
Rule
*
CSSFontFaceRuleDecl
:
:
GetParentRule
(
)
{
return
ContainingRule
(
)
;
}
nsINode
*
CSSFontFaceRuleDecl
:
:
GetParentObject
(
)
{
return
ContainingRule
(
)
-
>
GetParentObject
(
)
;
}
JSObject
*
CSSFontFaceRuleDecl
:
:
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
CSSStyleDeclaration_Binding
:
:
Wrap
(
cx
this
aGivenProto
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
CSSFontFaceRule
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
CSSFontFaceRule
mozilla
:
:
css
:
:
Rule
)
tmp
-
>
mDecl
.
TraceWrapper
(
aCallbacks
aClosure
)
;
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
CSSFontFaceRule
)
tmp
-
>
UnlinkDeclarationWrapper
(
tmp
-
>
mDecl
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END_INHERITED
(
mozilla
:
:
css
:
:
Rule
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
CSSFontFaceRule
mozilla
:
:
css
:
:
Rule
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
bool
CSSFontFaceRule
:
:
IsCCLeaf
(
)
const
{
if
(
!
Rule
:
:
IsCCLeaf
(
)
)
{
return
false
;
}
return
!
mDecl
.
PreservingWrapper
(
)
;
}
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
CSSFontFaceRule
mozilla
:
:
css
:
:
Rule
)
#
ifdef
DEBUG
void
CSSFontFaceRule
:
:
List
(
FILE
*
out
int32_t
aIndent
)
const
{
nsAutoCString
str
;
for
(
int32_t
i
=
0
;
i
<
aIndent
;
i
+
+
)
{
str
.
AppendLiteral
(
"
"
)
;
}
Servo_FontFaceRule_Debug
(
Raw
(
)
&
str
)
;
fprintf_stderr
(
out
"
%
s
\
n
"
str
.
get
(
)
)
;
}
#
endif
uint16_t
CSSFontFaceRule
:
:
Type
(
)
const
{
return
CSSRule_Binding
:
:
FONT_FACE_RULE
;
}
void
CSSFontFaceRule
:
:
GetCssText
(
nsAString
&
aCssText
)
const
{
aCssText
.
Truncate
(
)
;
Servo_FontFaceRule_GetCssText
(
Raw
(
)
&
aCssText
)
;
}
nsICSSDeclaration
*
CSSFontFaceRule
:
:
Style
(
)
{
return
&
mDecl
;
}
size_t
CSSFontFaceRule
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
JSObject
*
CSSFontFaceRule
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
CSSFontFaceRule_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
