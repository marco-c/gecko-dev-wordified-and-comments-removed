#
include
"
mozilla
/
css
/
StreamLoader
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIStreamTransportService
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
<
limits
>
namespace
mozilla
:
:
css
{
StreamLoader
:
:
StreamLoader
(
SheetLoadData
&
aSheetLoadData
)
:
mSheetLoadData
(
&
aSheetLoadData
)
mStatus
(
NS_OK
)
{
}
StreamLoader
:
:
~
StreamLoader
(
)
{
#
ifdef
NIGHTLY_BUILD
MOZ_RELEASE_ASSERT
(
mOnStopRequestCalled
|
|
mChannelOpenFailed
)
;
#
endif
}
NS_IMPL_ISUPPORTS
(
StreamLoader
nsIStreamListener
nsIThreadRetargetableStreamListener
)
NS_IMETHODIMP
StreamLoader
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
)
;
mSheetLoadData
-
>
NotifyStart
(
aRequest
)
;
if
(
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
)
{
int64_t
length
;
nsresult
rv
=
channel
-
>
GetContentLength
(
&
length
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
length
>
0
)
{
CheckedInt
<
nsACString
:
:
size_type
>
checkedLength
(
length
)
;
if
(
!
checkedLength
.
isValid
(
)
)
{
return
(
mStatus
=
NS_ERROR_OUT_OF_MEMORY
)
;
}
if
(
!
mBytes
.
SetCapacity
(
checkedLength
.
value
(
)
fallible
)
)
{
return
(
mStatus
=
NS_ERROR_OUT_OF_MEMORY
)
;
}
}
}
if
(
nsCOMPtr
<
nsIThreadRetargetableRequest
>
rr
=
do_QueryInterface
(
aRequest
)
)
{
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
;
RefPtr
queue
=
TaskQueue
:
:
Create
(
sts
.
forget
(
)
"
css
:
:
StreamLoader
Delivery
Queue
"
)
;
rr
-
>
RetargetDeliveryTo
(
queue
)
;
}
mSheetLoadData
-
>
mExpirationTime
=
[
&
]
{
auto
info
=
nsContentUtils
:
:
GetSubresourceCacheValidationInfo
(
aRequest
mSheetLoadData
-
>
mURI
)
;
if
(
info
.
mMustRevalidate
|
|
!
info
.
mExpirationTime
)
{
return
nsContentUtils
:
:
SecondsFromPRTime
(
PR_Now
(
)
)
-
1
;
}
return
*
info
.
mExpirationTime
;
}
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StreamLoader
:
:
CheckListenerChain
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
StreamLoader
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatus
)
{
#
ifdef
NIGHTLY_BUILD
MOZ_RELEASE_ASSERT
(
!
mOnStopRequestCalled
)
;
mOnStopRequestCalled
=
true
;
#
endif
nsresult
rv
=
mStatus
;
nsCString
utf8String
;
{
nsCString
bytes
=
std
:
:
move
(
mBytes
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
if
(
NS_FAILED
(
mStatus
)
)
{
mSheetLoadData
-
>
VerifySheetReadyToParse
(
mStatus
"
"
_ns
"
"
_ns
channel
)
;
return
mStatus
;
}
rv
=
mSheetLoadData
-
>
VerifySheetReadyToParse
(
aStatus
mBOMBytes
bytes
channel
)
;
if
(
rv
!
=
NS_OK_PARSE_SHEET
)
{
return
rv
;
}
if
(
mEncodingFromBOM
.
isNothing
(
)
)
{
HandleBOM
(
)
;
MOZ_ASSERT
(
mEncodingFromBOM
.
isSome
(
)
)
;
}
const
Encoding
*
encoding
=
mEncodingFromBOM
.
value
(
)
;
if
(
!
encoding
)
{
encoding
=
mSheetLoadData
-
>
DetermineNonBOMEncoding
(
bytes
channel
)
;
}
mSheetLoadData
-
>
mEncoding
=
encoding
;
size_t
validated
=
0
;
if
(
encoding
=
=
UTF_8_ENCODING
)
{
validated
=
Encoding
:
:
UTF8ValidUpTo
(
bytes
)
;
}
if
(
validated
=
=
bytes
.
Length
(
)
)
{
utf8String
=
std
:
:
move
(
bytes
)
;
}
else
{
rv
=
encoding
-
>
DecodeWithoutBOMHandling
(
bytes
utf8String
validated
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
mSheetLoadData
-
>
mLoader
-
>
ParseSheet
(
utf8String
*
mSheetLoadData
Loader
:
:
AllowAsyncParse
:
:
Yes
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StreamLoader
:
:
OnDataAvailable
(
nsIRequest
*
nsIInputStream
*
aInputStream
uint64_t
uint32_t
aCount
)
{
if
(
NS_FAILED
(
mStatus
)
)
{
return
mStatus
;
}
uint32_t
dummy
;
return
aInputStream
-
>
ReadSegments
(
WriteSegmentFun
this
aCount
&
dummy
)
;
}
NS_IMETHODIMP
StreamLoader
:
:
OnDataFinished
(
nsresult
aStatus
)
{
return
NS_OK
;
}
void
StreamLoader
:
:
HandleBOM
(
)
{
MOZ_ASSERT
(
mEncodingFromBOM
.
isNothing
(
)
)
;
MOZ_ASSERT
(
mBytes
.
IsEmpty
(
)
)
;
auto
[
encoding
bomLength
]
=
Encoding
:
:
ForBOM
(
mBOMBytes
)
;
mEncodingFromBOM
.
emplace
(
encoding
)
;
mBytes
.
Append
(
Substring
(
mBOMBytes
bomLength
)
)
;
mBOMBytes
.
Truncate
(
bomLength
)
;
}
nsresult
StreamLoader
:
:
WriteSegmentFun
(
nsIInputStream
*
void
*
aClosure
const
char
*
aSegment
uint32_t
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
*
aWriteCount
=
0
;
StreamLoader
*
self
=
static_cast
<
StreamLoader
*
>
(
aClosure
)
;
if
(
NS_FAILED
(
self
-
>
mStatus
)
)
{
return
self
-
>
mStatus
;
}
if
(
self
-
>
mEncodingFromBOM
.
isNothing
(
)
)
{
size_t
bytesToCopy
=
std
:
:
min
<
size_t
>
(
3
-
self
-
>
mBOMBytes
.
Length
(
)
aCount
)
;
self
-
>
mBOMBytes
.
Append
(
aSegment
bytesToCopy
)
;
aSegment
+
=
bytesToCopy
;
*
aWriteCount
+
=
bytesToCopy
;
aCount
-
=
bytesToCopy
;
if
(
self
-
>
mBOMBytes
.
Length
(
)
=
=
3
)
{
self
-
>
HandleBOM
(
)
;
}
else
{
return
NS_OK
;
}
}
if
(
!
self
-
>
mBytes
.
Append
(
aSegment
aCount
fallible
)
)
{
self
-
>
mBytes
.
Truncate
(
)
;
return
(
self
-
>
mStatus
=
NS_ERROR_OUT_OF_MEMORY
)
;
}
*
aWriteCount
+
=
aCount
;
return
NS_OK
;
}
}
