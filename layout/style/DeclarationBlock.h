#
ifndef
mozilla_DeclarationBlock_h
#
define
mozilla_DeclarationBlock_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsString
.
h
"
class
nsHTMLCSSStyleSheet
;
namespace
mozilla
{
namespace
css
{
class
Declaration
;
class
Rule
;
}
class
DeclarationBlock
final
{
DeclarationBlock
(
const
DeclarationBlock
&
aCopy
)
:
mRaw
(
Servo_DeclarationBlock_Clone
(
aCopy
.
mRaw
)
.
Consume
(
)
)
mImmutable
(
false
)
mIsDirty
(
false
)
{
mContainer
.
mRaw
=
0
;
}
public
:
explicit
DeclarationBlock
(
already_AddRefed
<
RawServoDeclarationBlock
>
aRaw
)
:
mRaw
(
aRaw
)
mImmutable
(
false
)
mIsDirty
(
false
)
{
mContainer
.
mRaw
=
0
;
}
DeclarationBlock
(
)
:
DeclarationBlock
(
Servo_DeclarationBlock_CreateEmpty
(
)
.
Consume
(
)
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DeclarationBlock
)
already_AddRefed
<
DeclarationBlock
>
Clone
(
)
const
{
return
do_AddRef
(
new
DeclarationBlock
(
*
this
)
)
;
}
bool
IsMutable
(
)
const
{
return
!
mImmutable
;
}
void
AssertMutable
(
)
const
{
MOZ_ASSERT
(
IsMutable
(
)
"
someone
forgot
to
call
EnsureMutable
"
)
;
MOZ_ASSERT
(
!
OwnerIsReadOnly
(
)
"
User
Agent
sheets
shouldn
'
t
be
modified
"
)
;
}
void
SetImmutable
(
)
{
mImmutable
=
true
;
}
bool
IsDirty
(
)
const
{
return
mIsDirty
;
}
void
SetDirty
(
)
{
mIsDirty
=
true
;
}
void
UnsetDirty
(
)
{
mIsDirty
=
false
;
}
already_AddRefed
<
DeclarationBlock
>
EnsureMutable
(
)
{
MOZ_ASSERT
(
!
OwnerIsReadOnly
(
)
)
;
if
(
!
IsDirty
(
)
)
{
return
Clone
(
)
;
}
if
(
!
IsMutable
(
)
)
{
return
Clone
(
)
;
}
return
do_AddRef
(
this
)
;
}
void
SetOwningRule
(
css
:
:
Rule
*
aRule
)
{
MOZ_ASSERT
(
!
mContainer
.
mOwningRule
|
|
!
aRule
"
should
never
overwrite
one
rule
with
another
"
)
;
mContainer
.
mOwningRule
=
aRule
;
}
css
:
:
Rule
*
GetOwningRule
(
)
const
{
if
(
mContainer
.
mRaw
&
0x1
)
{
return
nullptr
;
}
return
mContainer
.
mOwningRule
;
}
void
SetHTMLCSSStyleSheet
(
nsHTMLCSSStyleSheet
*
aHTMLCSSStyleSheet
)
{
MOZ_ASSERT
(
!
mContainer
.
mHTMLCSSStyleSheet
|
|
!
aHTMLCSSStyleSheet
"
should
never
overwrite
one
sheet
with
another
"
)
;
mContainer
.
mHTMLCSSStyleSheet
=
aHTMLCSSStyleSheet
;
if
(
aHTMLCSSStyleSheet
)
{
mContainer
.
mRaw
|
=
uintptr_t
(
1
)
;
}
}
nsHTMLCSSStyleSheet
*
GetHTMLCSSStyleSheet
(
)
const
{
if
(
!
(
mContainer
.
mRaw
&
0x1
)
)
{
return
nullptr
;
}
auto
c
=
mContainer
;
c
.
mRaw
&
=
~
uintptr_t
(
1
)
;
return
c
.
mHTMLCSSStyleSheet
;
}
bool
IsReadOnly
(
)
const
;
size_t
SizeofIncludingThis
(
MallocSizeOf
)
;
static
already_AddRefed
<
DeclarationBlock
>
FromCssText
(
const
nsACString
&
aCssText
URLExtraData
*
aExtraData
nsCompatibility
aMode
css
:
:
Loader
*
aLoader
uint16_t
aRuleType
)
{
RefPtr
<
RawServoDeclarationBlock
>
raw
=
Servo_ParseStyleAttribute
(
&
aCssText
aExtraData
aMode
aLoader
aRuleType
)
.
Consume
(
)
;
return
MakeAndAddRef
<
DeclarationBlock
>
(
raw
.
forget
(
)
)
;
}
static
already_AddRefed
<
DeclarationBlock
>
FromCssText
(
const
nsAString
&
aCssText
URLExtraData
*
aExtraData
nsCompatibility
aMode
css
:
:
Loader
*
aLoader
uint16_t
aRuleType
)
{
NS_ConvertUTF16toUTF8
value
(
aCssText
)
;
return
FromCssText
(
value
aExtraData
aMode
aLoader
aRuleType
)
;
}
RawServoDeclarationBlock
*
Raw
(
)
const
{
return
mRaw
;
}
RawServoDeclarationBlock
*
const
*
RefRaw
(
)
const
{
static_assert
(
sizeof
(
RefPtr
<
RawServoDeclarationBlock
>
)
=
=
sizeof
(
RawServoDeclarationBlock
*
)
"
RefPtr
should
just
be
a
pointer
"
)
;
return
reinterpret_cast
<
RawServoDeclarationBlock
*
const
*
>
(
&
mRaw
)
;
}
const
StyleStrong
<
RawServoDeclarationBlock
>
*
RefRawStrong
(
)
const
{
static_assert
(
sizeof
(
RefPtr
<
RawServoDeclarationBlock
>
)
=
=
sizeof
(
RawServoDeclarationBlock
*
)
"
RefPtr
should
just
be
a
pointer
"
)
;
static_assert
(
sizeof
(
RefPtr
<
RawServoDeclarationBlock
>
)
=
=
sizeof
(
StyleStrong
<
RawServoDeclarationBlock
>
)
"
RawServoDeclarationBlockStrong
should
be
the
same
as
RefPtr
"
)
;
return
reinterpret_cast
<
const
StyleStrong
<
RawServoDeclarationBlock
>
*
>
(
&
mRaw
)
;
}
void
ToString
(
nsACString
&
aResult
)
const
{
Servo_DeclarationBlock_GetCssText
(
mRaw
&
aResult
)
;
}
uint32_t
Count
(
)
const
{
return
Servo_DeclarationBlock_Count
(
mRaw
)
;
}
bool
GetNthProperty
(
uint32_t
aIndex
nsACString
&
aReturn
)
const
{
aReturn
.
Truncate
(
)
;
return
Servo_DeclarationBlock_GetNthProperty
(
mRaw
aIndex
&
aReturn
)
;
}
void
GetPropertyValue
(
const
nsACString
&
aProperty
nsACString
&
aValue
)
const
{
Servo_DeclarationBlock_GetPropertyValue
(
mRaw
&
aProperty
&
aValue
)
;
}
void
GetPropertyValueByID
(
nsCSSPropertyID
aPropID
nsACString
&
aValue
)
const
{
Servo_DeclarationBlock_GetPropertyValueById
(
mRaw
aPropID
&
aValue
)
;
}
bool
GetPropertyIsImportant
(
const
nsACString
&
aProperty
)
const
{
return
Servo_DeclarationBlock_GetPropertyIsImportant
(
mRaw
&
aProperty
)
;
}
bool
RemoveProperty
(
const
nsACString
&
aProperty
DeclarationBlockMutationClosure
aClosure
=
{
}
)
{
AssertMutable
(
)
;
return
Servo_DeclarationBlock_RemoveProperty
(
mRaw
&
aProperty
aClosure
)
;
}
bool
RemovePropertyByID
(
nsCSSPropertyID
aProperty
DeclarationBlockMutationClosure
aClosure
=
{
}
)
{
AssertMutable
(
)
;
return
Servo_DeclarationBlock_RemovePropertyById
(
mRaw
aProperty
aClosure
)
;
}
private
:
~
DeclarationBlock
(
)
=
default
;
bool
OwnerIsReadOnly
(
)
const
;
union
{
uintptr_t
mRaw
;
css
:
:
Rule
*
mOwningRule
;
nsHTMLCSSStyleSheet
*
mHTMLCSSStyleSheet
;
}
mContainer
;
RefPtr
<
RawServoDeclarationBlock
>
mRaw
;
bool
mImmutable
;
Atomic
<
bool
MemoryOrdering
:
:
Relaxed
>
mIsDirty
;
}
;
}
#
endif
