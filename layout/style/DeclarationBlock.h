#
ifndef
mozilla_DeclarationBlock_h
#
define
mozilla_DeclarationBlock_h
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
StyleBackendType
.
h
"
class
nsHTMLCSSStyleSheet
;
namespace
mozilla
{
class
ServoDeclarationBlock
;
namespace
css
{
class
Declaration
;
class
Rule
;
}
class
DeclarationBlock
{
protected
:
explicit
DeclarationBlock
(
StyleBackendType
aType
)
:
mImmutable
(
false
)
mType
(
aType
)
{
mContainer
.
mRaw
=
0
;
}
DeclarationBlock
(
const
DeclarationBlock
&
aCopy
)
:
DeclarationBlock
(
aCopy
.
mType
)
{
}
public
:
MOZ_DECL_STYLO_METHODS
(
css
:
:
Declaration
ServoDeclarationBlock
)
inline
MozExternalRefCountType
AddRef
(
)
;
inline
MozExternalRefCountType
Release
(
)
;
bool
IsMutable
(
)
const
{
return
!
mImmutable
;
}
void
AssertMutable
(
)
const
{
MOZ_ASSERT
(
IsMutable
(
)
"
someone
forgot
to
call
EnsureMutable
"
)
;
}
void
SetImmutable
(
)
const
{
mImmutable
=
true
;
}
void
SetOwningRule
(
css
:
:
Rule
*
aRule
)
{
MOZ_ASSERT
(
!
mContainer
.
mOwningRule
|
|
!
aRule
"
should
never
overwrite
one
rule
with
another
"
)
;
mContainer
.
mOwningRule
=
aRule
;
}
css
:
:
Rule
*
GetOwningRule
(
)
const
{
if
(
mContainer
.
mRaw
&
0x1
)
{
return
nullptr
;
}
return
mContainer
.
mOwningRule
;
}
void
SetHTMLCSSStyleSheet
(
nsHTMLCSSStyleSheet
*
aHTMLCSSStyleSheet
)
{
MOZ_ASSERT
(
!
mContainer
.
mHTMLCSSStyleSheet
|
|
!
aHTMLCSSStyleSheet
"
should
never
overwrite
one
sheet
with
another
"
)
;
mContainer
.
mHTMLCSSStyleSheet
=
aHTMLCSSStyleSheet
;
if
(
aHTMLCSSStyleSheet
)
{
mContainer
.
mRaw
|
=
uintptr_t
(
1
)
;
}
}
nsHTMLCSSStyleSheet
*
GetHTMLCSSStyleSheet
(
)
const
{
if
(
!
(
mContainer
.
mRaw
&
0x1
)
)
{
return
nullptr
;
}
auto
c
=
mContainer
;
c
.
mRaw
&
=
~
uintptr_t
(
1
)
;
return
c
.
mHTMLCSSStyleSheet
;
}
private
:
union
{
uintptr_t
mRaw
;
css
:
:
Rule
*
mOwningRule
;
nsHTMLCSSStyleSheet
*
mHTMLCSSStyleSheet
;
}
mContainer
;
mutable
bool
mImmutable
;
const
StyleBackendType
mType
;
}
;
}
#
endif
