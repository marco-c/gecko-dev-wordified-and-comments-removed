#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsCSSPseudoClasses
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsStaticAtom
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsIMozBrowserFrame
.
h
"
#
include
"
nsStyleUtil
.
h
"
using
namespace
mozilla
;
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
static_assert
(
!
(
(
flags_
)
&
CSS_PSEUDO_CLASS_ENABLED_IN_CHROME
)
|
|
\
(
(
flags_
)
&
CSS_PSEUDO_CLASS_ENABLED_IN_UA_SHEETS
)
\
"
Pseudo
-
class
'
"
#
name_
"
'
is
enabled
in
chrome
so
it
"
\
"
should
also
be
enabled
in
UA
sheets
"
)
;
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
namespace
detail
{
struct
CSSPseudoClassAtoms
{
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
NS_STATIC_ATOM_DECL_STRING
(
name_
value_
)
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
NS_STATIC_ATOM_DECL_ATOM
(
name_
)
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
}
;
MOZ_PUSH_DISABLE_INTEGRAL_CONSTANT_OVERFLOW_WARNING
static
constexpr
CSSPseudoClassAtoms
sCSSPseudoClassAtoms
=
{
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
NS_STATIC_ATOM_INIT_STRING
(
value_
)
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
NS_STATIC_ATOM_INIT_ATOM
(
CSSPseudoClassAtoms
name_
value_
)
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
}
;
MOZ_POP_DISABLE_INTEGRAL_CONSTANT_OVERFLOW_WARNING
}
class
CSSPseudoClassAtoms
{
public
:
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
NS_STATIC_ATOM_DECL_PTR
(
name_
)
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
}
;
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
NS_STATIC_ATOM_DEFN_PTR
(
CSSPseudoClassAtoms
name_
)
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
static
const
nsStaticAtomSetup
sCSSPseudoClassAtomSetup
[
]
=
{
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
NS_STATIC_ATOM_SETUP
(
\
:
:
detail
:
:
sCSSPseudoClassAtoms
CSSPseudoClassAtoms
name_
)
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
}
;
const
uint32_t
nsCSSPseudoClasses
:
:
kPseudoClassFlags
[
]
=
{
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
flags_
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
}
;
bool
nsCSSPseudoClasses
:
:
sPseudoClassEnabled
[
]
=
{
#
define
IS_ENABLED_BY_DEFAULT
(
flags_
)
\
(
!
(
(
flags_
)
&
CSS_PSEUDO_CLASS_ENABLED_MASK
)
)
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
IS_ENABLED_BY_DEFAULT
(
flags_
)
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
#
undef
IS_ENABLED_BY_DEFAULT
}
;
void
nsCSSPseudoClasses
:
:
RegisterStaticAtoms
(
)
{
NS_RegisterStaticAtoms
(
sCSSPseudoClassAtomSetup
)
;
#
define
CSS_PSEUDO_CLASS
(
name_
value_
flags_
pref_
)
\
if
(
pref_
[
0
]
)
{
\
auto
idx
=
static_cast
<
CSSPseudoElementTypeBase
>
(
Type
:
:
name_
)
;
\
Preferences
:
:
AddBoolVarCache
(
&
sPseudoClassEnabled
[
idx
]
pref_
)
;
\
}
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_PSEUDO_CLASS
}
bool
nsCSSPseudoClasses
:
:
HasStringArg
(
Type
aType
)
{
return
aType
=
=
Type
:
:
lang
|
|
aType
=
=
Type
:
:
mozLocaleDir
|
|
aType
=
=
Type
:
:
dir
;
}
bool
nsCSSPseudoClasses
:
:
HasNthPairArg
(
Type
aType
)
{
return
aType
=
=
Type
:
:
nthChild
|
|
aType
=
=
Type
:
:
nthLastChild
|
|
aType
=
=
Type
:
:
nthOfType
|
|
aType
=
=
Type
:
:
nthLastOfType
;
}
void
nsCSSPseudoClasses
:
:
PseudoTypeToString
(
Type
aType
nsAString
&
aString
)
{
MOZ_ASSERT
(
aType
<
Type
:
:
Count
"
Unexpected
type
"
)
;
auto
idx
=
static_cast
<
CSSPseudoClassTypeBase
>
(
aType
)
;
(
*
sCSSPseudoClassAtomSetup
[
idx
]
.
mAtomp
)
-
>
ToString
(
aString
)
;
}
CSSPseudoClassType
nsCSSPseudoClasses
:
:
GetPseudoType
(
nsAtom
*
aAtom
EnabledState
aEnabledState
)
{
Maybe
<
uint32_t
>
index
=
nsStaticAtomUtils
:
:
Lookup
(
aAtom
sCSSPseudoClassAtomSetup
)
;
if
(
index
.
isSome
(
)
)
{
Type
type
=
Type
(
*
index
)
;
if
(
IsEnabled
(
type
aEnabledState
)
)
{
return
type
;
}
}
return
Type
:
:
NotPseudo
;
}
bool
nsCSSPseudoClasses
:
:
IsUserActionPseudoClass
(
Type
aType
)
{
return
aType
=
=
Type
:
:
hover
|
|
aType
=
=
Type
:
:
active
|
|
aType
=
=
Type
:
:
focus
;
}
bool
nsCSSPseudoClasses
:
:
LangPseudoMatches
(
const
mozilla
:
:
dom
:
:
Element
*
aElement
const
nsAtom
*
aOverrideLang
bool
aHasOverrideLang
const
char16_t
*
aString
const
nsIDocument
*
aDocument
)
{
NS_ASSERTION
(
aString
"
null
lang
parameter
"
)
;
if
(
!
aString
|
|
!
*
aString
)
{
return
false
;
}
if
(
auto
*
language
=
aHasOverrideLang
?
aOverrideLang
:
aElement
-
>
GetLang
(
)
)
{
return
nsStyleUtil
:
:
DashMatchCompare
(
nsDependentAtomString
(
language
)
nsDependentString
(
aString
)
nsASCIICaseInsensitiveStringComparator
(
)
)
;
}
if
(
!
aDocument
)
{
return
false
;
}
nsAutoString
language
;
aDocument
-
>
GetContentLanguage
(
language
)
;
nsDependentString
langString
(
aString
)
;
language
.
StripWhitespace
(
)
;
for
(
auto
const
&
lang
:
language
.
Split
(
char16_t
(
'
'
)
)
)
{
if
(
nsStyleUtil
:
:
DashMatchCompare
(
lang
langString
nsASCIICaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSSPseudoClasses
:
:
StringPseudoMatches
(
const
mozilla
:
:
dom
:
:
Element
*
aElement
CSSPseudoClassType
aPseudo
const
char16_t
*
aString
const
nsIDocument
*
aDocument
EventStates
aStateMask
bool
*
const
aDependence
)
{
switch
(
aPseudo
)
{
case
CSSPseudoClassType
:
:
mozLocaleDir
:
{
const
bool
docIsRTL
=
aDocument
-
>
GetDocumentState
(
)
.
HasState
(
NS_DOCUMENT_STATE_RTL_LOCALE
)
;
nsDependentString
dirString
(
aString
)
;
if
(
dirString
.
EqualsLiteral
(
"
rtl
"
)
)
{
if
(
!
docIsRTL
)
{
return
false
;
}
}
else
if
(
dirString
.
EqualsLiteral
(
"
ltr
"
)
)
{
if
(
docIsRTL
)
{
return
false
;
}
}
else
{
return
false
;
}
}
break
;
case
CSSPseudoClassType
:
:
dir
:
{
if
(
aDependence
)
{
EventStates
states
=
sPseudoClassStateDependences
[
static_cast
<
CSSPseudoClassTypeBase
>
(
aPseudo
)
]
;
if
(
aStateMask
.
HasAtLeastOneOfStates
(
states
)
)
{
*
aDependence
=
true
;
return
false
;
}
}
EventStates
state
=
aElement
-
>
StyleState
(
)
;
nsDependentString
dirString
(
aString
)
;
if
(
dirString
.
EqualsLiteral
(
"
rtl
"
)
)
{
if
(
!
state
.
HasState
(
NS_EVENT_STATE_RTL
)
)
{
return
false
;
}
}
else
if
(
dirString
.
EqualsLiteral
(
"
ltr
"
)
)
{
if
(
!
state
.
HasState
(
NS_EVENT_STATE_LTR
)
)
{
return
false
;
}
}
else
{
return
false
;
}
}
break
;
case
CSSPseudoClassType
:
:
lang
:
if
(
LangPseudoMatches
(
aElement
nullptr
false
aString
aDocument
)
)
{
break
;
}
return
false
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Called
StringPseudoMatches
(
)
with
unknown
string
-
like
pseudo
"
)
;
}
return
true
;
}
Maybe
<
bool
>
nsCSSPseudoClasses
:
:
MatchesElement
(
Type
aType
const
dom
:
:
Element
*
aElement
)
{
switch
(
aType
)
{
case
CSSPseudoClassType
:
:
mozNativeAnonymous
:
return
Some
(
aElement
-
>
IsInNativeAnonymousSubtree
(
)
)
;
case
CSSPseudoClassType
:
:
mozUseShadowTreeRoot
:
return
Some
(
aElement
-
>
IsRootOfUseElementShadowTree
(
)
)
;
case
CSSPseudoClassType
:
:
mozTableBorderNonzero
:
{
if
(
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
Some
(
false
)
;
}
const
nsAttrValue
*
val
=
aElement
-
>
GetParsedAttr
(
nsGkAtoms
:
:
border
)
;
return
Some
(
val
&
&
(
val
-
>
Type
(
)
!
=
nsAttrValue
:
:
eInteger
|
|
val
-
>
GetIntegerValue
(
)
!
=
0
)
)
;
}
case
CSSPseudoClassType
:
:
mozBrowserFrame
:
{
nsIMozBrowserFrame
*
browserFrame
=
const_cast
<
Element
*
>
(
aElement
)
-
>
GetAsMozBrowserFrame
(
)
;
return
Some
(
browserFrame
&
&
browserFrame
-
>
GetReallyIsBrowser
(
)
)
;
}
default
:
return
Nothing
(
)
;
}
}
const
EventStates
nsCSSPseudoClasses
:
:
sPseudoClassStateDependences
[
size_t
(
CSSPseudoClassType
:
:
Count
)
+
2
]
=
{
#
define
CSS_PSEUDO_CLASS
(
_name
_value
_flags
_pref
)
\
EventStates
(
)
#
define
CSS_STATE_DEPENDENT_PSEUDO_CLASS
(
_name
_value
_flags
_pref
_states
)
\
_states
#
include
"
nsCSSPseudoClassList
.
h
"
#
undef
CSS_STATE_DEPENDENT_PSEUDO_CLASS
#
undef
CSS_PSEUDO_CLASS
EventStates
(
)
EventStates
(
)
}
;
