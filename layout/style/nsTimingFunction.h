#
ifndef
nsTimingFunction_h
#
define
nsTimingFunction_h
#
include
"
nsStyleConsts
.
h
"
struct
nsTimingFunction
{
enum
class
Type
{
Ease
Linear
EaseIn
EaseOut
EaseInOut
StepStart
StepEnd
CubicBezier
}
;
static
bool
IsSplineType
(
Type
aType
)
{
return
aType
!
=
Type
:
:
StepStart
&
&
aType
!
=
Type
:
:
StepEnd
;
}
explicit
nsTimingFunction
(
int32_t
aTimingFunctionType
=
NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE
)
:
mType
(
Type
:
:
Ease
)
mFunc
{
}
{
AssignFromKeyword
(
aTimingFunctionType
)
;
}
nsTimingFunction
(
float
x1
float
y1
float
x2
float
y2
)
:
mType
(
Type
:
:
CubicBezier
)
{
mFunc
.
mX1
=
x1
;
mFunc
.
mY1
=
y1
;
mFunc
.
mX2
=
x2
;
mFunc
.
mY2
=
y2
;
}
enum
class
Keyword
{
Implicit
Explicit
}
;
nsTimingFunction
(
Type
aType
uint32_t
aSteps
)
:
mType
(
aType
)
{
MOZ_ASSERT
(
mType
=
=
Type
:
:
StepStart
|
|
mType
=
=
Type
:
:
StepEnd
"
wrong
type
"
)
;
mSteps
=
aSteps
;
}
nsTimingFunction
(
const
nsTimingFunction
&
aOther
)
{
*
this
=
aOther
;
}
Type
mType
;
union
{
struct
{
float
mX1
;
float
mY1
;
float
mX2
;
float
mY2
;
}
mFunc
;
struct
{
uint32_t
mSteps
;
}
;
}
;
nsTimingFunction
&
operator
=
(
const
nsTimingFunction
&
aOther
)
{
if
(
&
aOther
=
=
this
)
{
return
*
this
;
}
mType
=
aOther
.
mType
;
if
(
HasSpline
(
)
)
{
mFunc
.
mX1
=
aOther
.
mFunc
.
mX1
;
mFunc
.
mY1
=
aOther
.
mFunc
.
mY1
;
mFunc
.
mX2
=
aOther
.
mFunc
.
mX2
;
mFunc
.
mY2
=
aOther
.
mFunc
.
mY2
;
}
else
{
mSteps
=
aOther
.
mSteps
;
}
return
*
this
;
}
bool
operator
=
=
(
const
nsTimingFunction
&
aOther
)
const
{
if
(
mType
!
=
aOther
.
mType
)
{
return
false
;
}
if
(
HasSpline
(
)
)
{
return
mFunc
.
mX1
=
=
aOther
.
mFunc
.
mX1
&
&
mFunc
.
mY1
=
=
aOther
.
mFunc
.
mY1
&
&
mFunc
.
mX2
=
=
aOther
.
mFunc
.
mX2
&
&
mFunc
.
mY2
=
=
aOther
.
mFunc
.
mY2
;
}
return
mSteps
=
=
aOther
.
mSteps
;
}
bool
operator
!
=
(
const
nsTimingFunction
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
bool
HasSpline
(
)
const
{
return
IsSplineType
(
mType
)
;
}
private
:
void
AssignFromKeyword
(
int32_t
aTimingFunctionType
)
;
}
;
#
endif
