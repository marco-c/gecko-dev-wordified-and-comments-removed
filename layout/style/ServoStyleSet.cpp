#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
mozilla
/
AutoRestyleTimelineMarker
.
h
"
#
include
"
mozilla
/
DocumentStyleRootIterator
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoRestyleManager
.
h
"
#
include
"
mozilla
/
ServoStyleRuleMap
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
mozilla
/
dom
/
AnonymousContent
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceSet
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
RestyleManagerInlines
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSRuleProcessor
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsHTMLStyleSheet
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsIDocumentInlines
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsSMILAnimationController
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
gfxUserFontSet
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
ServoStyleSet
*
ServoStyleSet
:
:
sInServoTraversal
=
nullptr
;
namespace
mozilla
{
class
MOZ_RAII
AutoSetInServoTraversal
{
public
:
explicit
AutoSetInServoTraversal
(
ServoStyleSet
*
aSet
)
:
mSet
(
aSet
)
{
MOZ_ASSERT
(
!
ServoStyleSet
:
:
sInServoTraversal
)
;
MOZ_ASSERT
(
aSet
)
;
ServoStyleSet
:
:
sInServoTraversal
=
aSet
;
}
~
AutoSetInServoTraversal
(
)
{
MOZ_ASSERT
(
ServoStyleSet
:
:
sInServoTraversal
)
;
ServoStyleSet
:
:
sInServoTraversal
=
nullptr
;
mSet
-
>
RunPostTraversalTasks
(
)
;
}
private
:
ServoStyleSet
*
mSet
;
}
;
class
MOZ_RAII
AutoPrepareTraversal
{
public
:
explicit
AutoPrepareTraversal
(
ServoStyleSet
*
aSet
)
:
mTimelineMarker
(
aSet
-
>
mPresContext
-
>
GetDocShell
(
)
false
)
mSetInServoTraversal
(
aSet
)
{
MOZ_ASSERT
(
!
aSet
-
>
StylistNeedsUpdate
(
)
)
;
}
private
:
AutoRestyleTimelineMarker
mTimelineMarker
;
AutoSetInServoTraversal
mSetInServoTraversal
;
}
;
}
ServoStyleSet
:
:
ServoStyleSet
(
)
:
mPresContext
(
nullptr
)
mAuthorStyleDisabled
(
false
)
mStylistState
(
StylistState
:
:
NotDirty
)
mUserFontSetUpdateGeneration
(
0
)
mUserFontCacheUpdateGeneration
(
0
)
mNeedsRestyleAfterEnsureUniqueInner
(
false
)
{
}
ServoStyleSet
:
:
~
ServoStyleSet
(
)
{
for
(
auto
&
sheetArray
:
mSheets
)
{
for
(
auto
&
sheet
:
sheetArray
)
{
sheet
-
>
DropStyleSet
(
this
)
;
}
}
}
void
ServoStyleSet
:
:
Init
(
nsPresContext
*
aPresContext
nsBindingManager
*
aBindingManager
)
{
mPresContext
=
aPresContext
;
mRawSet
.
reset
(
Servo_StyleSet_Init
(
aPresContext
)
)
;
mBindingManager
=
aBindingManager
;
mPresContext
-
>
DeviceContext
(
)
-
>
InitFontCache
(
)
;
for
(
auto
&
sheetArray
:
mSheets
)
{
for
(
auto
&
sheet
:
sheetArray
)
{
MOZ_ASSERT
(
sheet
-
>
RawContents
(
)
"
We
should
only
append
non
-
null
raw
sheets
.
"
)
;
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
sheet
)
;
}
}
SetStylistStyleSheetsDirty
(
)
;
}
void
ServoStyleSet
:
:
BeginShutdown
(
)
{
nsIDocument
*
doc
=
mPresContext
-
>
Document
(
)
;
if
(
mStyleRuleMap
)
{
doc
-
>
RemoveObserver
(
mStyleRuleMap
)
;
doc
-
>
CSSLoader
(
)
-
>
RemoveObserver
(
mStyleRuleMap
)
;
mStyleRuleMap
=
nullptr
;
}
}
void
ServoStyleSet
:
:
Shutdown
(
)
{
ClearNonInheritingStyleContexts
(
)
;
mRawSet
=
nullptr
;
}
void
ServoStyleSet
:
:
InvalidateStyleForCSSRuleChanges
(
)
{
MOZ_ASSERT
(
StylistNeedsUpdate
(
)
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
AsServo
(
)
-
>
PostRestyleEventForCSSRuleChanges
(
)
;
}
nsRestyleHint
ServoStyleSet
:
:
MediumFeaturesChanged
(
bool
aViewportChanged
)
{
bool
viewportUnitsUsed
=
false
;
const
bool
rulesChanged
=
Servo_StyleSet_MediumFeaturesChanged
(
mRawSet
.
get
(
)
&
viewportUnitsUsed
)
;
if
(
rulesChanged
)
{
ForceAllStyleDirty
(
)
;
return
eRestyle_Subtree
;
}
if
(
viewportUnitsUsed
&
&
aViewportChanged
)
{
return
eRestyle_ForceDescendants
;
}
return
nsRestyleHint
(
0
)
;
}
size_t
ServoStyleSet
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
if
(
mStyleRuleMap
)
{
n
+
=
mStyleRuleMap
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
bool
ServoStyleSet
:
:
GetAuthorStyleDisabled
(
)
const
{
return
mAuthorStyleDisabled
;
}
nsresult
ServoStyleSet
:
:
SetAuthorStyleDisabled
(
bool
aStyleDisabled
)
{
if
(
mAuthorStyleDisabled
=
=
aStyleDisabled
)
{
return
NS_OK
;
}
mAuthorStyleDisabled
=
aStyleDisabled
;
ForceAllStyleDirty
(
)
;
return
NS_OK
;
}
void
ServoStyleSet
:
:
BeginUpdate
(
)
{
}
nsresult
ServoStyleSet
:
:
EndUpdate
(
)
{
return
NS_OK
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveStyleFor
(
Element
*
aElement
ServoStyleContext
*
aParentContext
LazyComputeBehavior
aMayCompute
)
{
RefPtr
<
ServoStyleContext
>
computedValues
;
if
(
aMayCompute
=
=
LazyComputeBehavior
:
:
Allow
)
{
PreTraverseSync
(
)
;
return
ResolveStyleLazilyInternal
(
aElement
CSSPseudoElementType
:
:
NotPseudo
nullptr
aParentContext
)
;
}
return
ResolveServoStyle
(
aElement
ServoTraversalFlags
:
:
Empty
)
;
}
class
MOZ_STACK_CLASS
AutoClearStaleData
{
public
:
explicit
AutoClearStaleData
(
Element
*
aElement
)
#
ifdef
DEBUG
:
mElement
(
aElement
)
#
endif
{
aElement
-
>
OwnerDoc
(
)
-
>
ClearStaleServoDataFromDocument
(
)
;
}
~
AutoClearStaleData
(
)
{
#
ifdef
DEBUG
if
(
mElement
-
>
OwnerDoc
(
)
-
>
HasShellOrBFCacheEntry
(
)
)
{
return
;
}
for
(
Element
*
e
=
mElement
;
e
;
e
=
e
-
>
GetParentElement
(
)
)
{
MOZ_ASSERT
(
!
e
-
>
HasServoData
(
)
"
expected
element
to
be
unstyled
"
)
;
}
#
endif
}
private
:
#
ifdef
DEBUG
Element
*
mElement
;
#
endif
}
;
const
ServoElementSnapshotTable
&
ServoStyleSet
:
:
Snapshots
(
)
{
return
mPresContext
-
>
RestyleManager
(
)
-
>
AsServo
(
)
-
>
Snapshots
(
)
;
}
void
ServoStyleSet
:
:
ResolveMappedAttrDeclarationBlocks
(
)
{
if
(
nsHTMLStyleSheet
*
sheet
=
mPresContext
-
>
Document
(
)
-
>
GetAttributeStyleSheet
(
)
)
{
sheet
-
>
CalculateMappedServoDeclarations
(
mPresContext
)
;
}
mPresContext
-
>
Document
(
)
-
>
ResolveScheduledSVGPresAttrs
(
)
;
}
void
ServoStyleSet
:
:
PreTraverseSync
(
)
{
mozilla
:
:
Unused
<
<
mPresContext
-
>
Document
(
)
-
>
GetRootElement
(
)
;
ResolveMappedAttrDeclarationBlocks
(
)
;
nsCSSRuleProcessor
:
:
InitSystemMetrics
(
)
;
LookAndFeel
:
:
NativeInit
(
)
;
mPresContext
-
>
Document
(
)
-
>
GetDocumentState
(
)
;
if
(
gfxUserFontSet
*
userFontSet
=
mPresContext
-
>
Document
(
)
-
>
GetUserFontSet
(
)
)
{
uint64_t
generation
=
userFontSet
-
>
GetGeneration
(
)
;
if
(
generation
!
=
mUserFontSetUpdateGeneration
)
{
mPresContext
-
>
DeviceContext
(
)
-
>
UpdateFontCacheUserFonts
(
userFontSet
)
;
mUserFontSetUpdateGeneration
=
generation
;
}
FontFaceSet
*
fontFaceSet
=
static_cast
<
FontFaceSet
:
:
UserFontSet
*
>
(
userFontSet
)
-
>
GetFontFaceSet
(
)
;
fontFaceSet
-
>
UpdateStandardFontLoadPrincipal
(
)
;
bool
principalChanged
=
fontFaceSet
-
>
HasStandardFontLoadPrincipalChanged
(
)
;
uint32_t
cacheGeneration
=
gfxUserFontSet
:
:
UserFontCache
:
:
Generation
(
)
;
if
(
principalChanged
)
{
gfxUserFontSet
:
:
UserFontCache
:
:
ClearAllowedFontSets
(
userFontSet
)
;
}
if
(
cacheGeneration
!
=
mUserFontCacheUpdateGeneration
|
|
principalChanged
)
{
gfxUserFontSet
:
:
UserFontCache
:
:
UpdateAllowedFontSets
(
userFontSet
)
;
mUserFontCacheUpdateGeneration
=
cacheGeneration
;
}
}
UpdateStylistIfNeeded
(
)
;
mPresContext
-
>
CacheAllLangs
(
)
;
}
void
ServoStyleSet
:
:
PreTraverse
(
Element
*
aRoot
EffectCompositor
:
:
AnimationRestyleType
aRestyleType
)
{
PreTraverseSync
(
)
;
nsSMILAnimationController
*
smilController
=
mPresContext
-
>
Document
(
)
-
>
GetAnimationController
(
)
;
if
(
aRoot
)
{
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverseInSubtree
(
aRoot
aRestyleType
)
;
if
(
smilController
)
{
smilController
-
>
PreTraverseInSubtree
(
aRoot
)
;
}
}
else
{
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverse
(
aRestyleType
)
;
if
(
smilController
)
{
smilController
-
>
PreTraverse
(
)
;
}
}
}
bool
ServoStyleSet
:
:
PrepareAndTraverseSubtree
(
RawGeckoElementBorrowed
aRoot
ServoTraversalFlags
aFlags
)
{
MOZ_ASSERT
(
MayTraverseFrom
(
const_cast
<
Element
*
>
(
aRoot
)
)
)
;
AutoPrepareTraversal
guard
(
this
)
;
const
SnapshotTable
&
snapshots
=
Snapshots
(
)
;
bool
isInitial
=
!
aRoot
-
>
HasServoData
(
)
;
bool
postTraversalRequired
=
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
aFlags
)
;
MOZ_ASSERT
(
!
isInitial
|
|
!
postTraversalRequired
)
;
if
(
aFlags
&
ServoTraversalFlags
:
:
AnimationOnly
)
{
return
postTraversalRequired
;
}
EffectCompositor
*
compositor
=
mPresContext
-
>
EffectCompositor
(
)
;
auto
restyleType
=
EffectCompositor
:
:
AnimationRestyleType
:
:
Throttled
;
if
(
compositor
-
>
PreTraverse
(
restyleType
)
)
{
if
(
isInitial
)
{
aFlags
|
=
ServoTraversalFlags
:
:
Forgetful
|
ServoTraversalFlags
:
:
ClearAnimationOnlyDirtyDescendants
;
}
postTraversalRequired
=
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
aFlags
)
;
MOZ_ASSERT_IF
(
isInitial
!
postTraversalRequired
)
;
}
return
postTraversalRequired
;
}
static
inline
already_AddRefed
<
ServoStyleContext
>
ResolveStyleForTextOrFirstLetterContinuation
(
RawServoStyleSetBorrowed
aStyleSet
ServoStyleContext
&
aParent
nsIAtom
*
aAnonBox
)
{
MOZ_ASSERT
(
aAnonBox
=
=
nsCSSAnonBoxes
:
:
mozText
|
|
aAnonBox
=
=
nsCSSAnonBoxes
:
:
firstLetterContinuation
)
;
auto
inheritTarget
=
aAnonBox
=
=
nsCSSAnonBoxes
:
:
mozText
?
InheritTarget
:
:
Text
:
InheritTarget
:
:
FirstLetterContinuation
;
RefPtr
<
ServoStyleContext
>
style
=
aParent
.
GetCachedInheritingAnonBoxStyle
(
aAnonBox
)
;
if
(
!
style
)
{
style
=
Servo_ComputedValues_Inherit
(
aStyleSet
aAnonBox
&
aParent
inheritTarget
)
.
Consume
(
)
;
MOZ_ASSERT
(
style
)
;
aParent
.
SetCachedInheritedAnonBoxStyle
(
aAnonBox
style
)
;
}
return
style
.
forget
(
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveStyleForText
(
nsIContent
*
aTextNode
ServoStyleContext
*
aParentContext
)
{
MOZ_ASSERT
(
aTextNode
&
&
aTextNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
MOZ_ASSERT
(
aTextNode
-
>
GetParent
(
)
)
;
MOZ_ASSERT
(
aParentContext
)
;
return
ResolveStyleForTextOrFirstLetterContinuation
(
mRawSet
.
get
(
)
*
aParentContext
nsCSSAnonBoxes
:
:
mozText
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveStyleForFirstLetterContinuation
(
ServoStyleContext
*
aParentContext
)
{
MOZ_ASSERT
(
aParentContext
)
;
return
ResolveStyleForTextOrFirstLetterContinuation
(
mRawSet
.
get
(
)
*
aParentContext
nsCSSAnonBoxes
:
:
firstLetterContinuation
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveStyleForPlaceholder
(
)
{
RefPtr
<
ServoStyleContext
>
&
cache
=
mNonInheritingStyleContexts
[
nsCSSAnonBoxes
:
:
NonInheriting
:
:
oofPlaceholder
]
;
if
(
cache
)
{
RefPtr
<
ServoStyleContext
>
retval
=
cache
;
return
retval
.
forget
(
)
;
}
RefPtr
<
ServoStyleContext
>
computedValues
=
Servo_ComputedValues_Inherit
(
mRawSet
.
get
(
)
nsCSSAnonBoxes
:
:
oofPlaceholder
nullptr
InheritTarget
:
:
PlaceholderFrame
)
.
Consume
(
)
;
MOZ_ASSERT
(
computedValues
)
;
cache
=
computedValues
;
return
computedValues
.
forget
(
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolvePseudoElementStyle
(
Element
*
aOriginatingElement
CSSPseudoElementType
aType
ServoStyleContext
*
aParentContext
Element
*
aPseudoElement
)
{
UpdateStylistIfNeeded
(
)
;
MOZ_ASSERT
(
aType
<
CSSPseudoElementType
:
:
Count
)
;
RefPtr
<
ServoStyleContext
>
computedValues
;
if
(
aPseudoElement
)
{
MOZ_ASSERT
(
aType
=
=
aPseudoElement
-
>
GetPseudoElementType
(
)
)
;
computedValues
=
Servo_ResolveStyle
(
aPseudoElement
mRawSet
.
get
(
)
ServoTraversalFlags
:
:
Empty
)
.
Consume
(
)
;
}
else
{
bool
cacheable
=
!
nsCSSPseudoElements
:
:
IsEagerlyCascadedInServo
(
aType
)
&
&
aParentContext
;
computedValues
=
cacheable
?
aParentContext
-
>
GetCachedLazyPseudoStyle
(
aType
)
:
nullptr
;
if
(
!
computedValues
)
{
computedValues
=
Servo_ResolvePseudoStyle
(
aOriginatingElement
aType
false
aParentContext
mRawSet
.
get
(
)
)
.
Consume
(
)
;
if
(
cacheable
)
{
aParentContext
-
>
SetCachedLazyPseudoStyle
(
computedValues
)
;
}
}
}
MOZ_ASSERT
(
computedValues
)
;
return
computedValues
.
forget
(
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveStyleLazily
(
Element
*
aElement
CSSPseudoElementType
aPseudoType
nsIAtom
*
aPseudoTag
StyleRuleInclusion
aRuleInclusion
)
{
bool
ignoreExistingStyles
=
aElement
-
>
OwnerDoc
(
)
-
>
GetBFCacheEntry
(
)
;
AutoClearStaleData
guard
(
aElement
)
;
PreTraverseSync
(
)
;
return
ResolveStyleLazilyInternal
(
aElement
aPseudoType
aPseudoTag
nullptr
aRuleInclusion
ignoreExistingStyles
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveInheritingAnonymousBoxStyle
(
nsIAtom
*
aPseudoTag
ServoStyleContext
*
aParentContext
)
{
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsAnonBox
(
aPseudoTag
)
&
&
!
nsCSSAnonBoxes
:
:
IsNonInheritingAnonBox
(
aPseudoTag
)
)
;
RefPtr
<
ServoStyleContext
>
style
=
nullptr
;
if
(
aParentContext
)
{
style
=
aParentContext
-
>
GetCachedInheritingAnonBoxStyle
(
aPseudoTag
)
;
}
if
(
!
style
)
{
UpdateStylistIfNeeded
(
)
;
style
=
Servo_ComputedValues_GetForAnonymousBox
(
aParentContext
aPseudoTag
mRawSet
.
get
(
)
)
.
Consume
(
)
;
MOZ_ASSERT
(
style
)
;
if
(
aParentContext
)
{
aParentContext
-
>
SetCachedInheritedAnonBoxStyle
(
aPseudoTag
style
)
;
}
}
return
style
.
forget
(
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveNonInheritingAnonymousBoxStyle
(
nsIAtom
*
aPseudoTag
)
{
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsAnonBox
(
aPseudoTag
)
&
&
nsCSSAnonBoxes
:
:
IsNonInheritingAnonBox
(
aPseudoTag
)
)
;
MOZ_ASSERT
(
aPseudoTag
!
=
nsCSSAnonBoxes
:
:
pageContent
"
If
nsCSSAnonBoxes
:
:
pageContent
ends
up
non
-
inheriting
check
"
"
whether
we
need
to
do
anything
to
move
the
"
"
page
handling
from
ResolveInheritingAnonymousBoxStyle
to
"
"
ResolveNonInheritingAnonymousBoxStyle
"
)
;
nsCSSAnonBoxes
:
:
NonInheriting
type
=
nsCSSAnonBoxes
:
:
NonInheritingTypeForPseudoTag
(
aPseudoTag
)
;
RefPtr
<
ServoStyleContext
>
&
cache
=
mNonInheritingStyleContexts
[
type
]
;
if
(
cache
)
{
RefPtr
<
ServoStyleContext
>
retval
=
cache
;
return
retval
.
forget
(
)
;
}
UpdateStylistIfNeeded
(
)
;
MOZ_ASSERT
(
!
nsCSSAnonBoxes
:
:
IsNonInheritingAnonBox
(
nsCSSAnonBoxes
:
:
viewport
)
"
viewport
needs
fixup
to
handle
blockifying
it
"
)
;
RefPtr
<
ServoStyleContext
>
computedValues
=
Servo_ComputedValues_GetForAnonymousBox
(
nullptr
aPseudoTag
mRawSet
.
get
(
)
)
.
Consume
(
)
;
#
ifdef
DEBUG
if
(
!
computedValues
)
{
nsString
pseudo
;
aPseudoTag
-
>
ToString
(
pseudo
)
;
NS_ERROR
(
nsPrintfCString
(
"
stylo
:
could
not
get
anon
-
box
:
%
s
"
NS_ConvertUTF16toUTF8
(
pseudo
)
.
get
(
)
)
.
get
(
)
)
;
MOZ_CRASH
(
)
;
}
#
endif
cache
=
computedValues
;
return
computedValues
.
forget
(
)
;
}
nsresult
ServoStyleSet
:
:
AppendStyleSheet
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
MOZ_ASSERT
(
aSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
MOZ_ASSERT
(
aSheet
-
>
RawContents
(
)
"
Raw
sheet
should
be
in
place
before
insertion
.
"
)
;
RemoveSheetOfType
(
aType
aSheet
)
;
AppendSheetOfType
(
aType
aSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
aSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
}
return
NS_OK
;
}
nsresult
ServoStyleSet
:
:
PrependStyleSheet
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
MOZ_ASSERT
(
aSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
MOZ_ASSERT
(
aSheet
-
>
RawContents
(
)
"
Raw
sheet
should
be
in
place
before
insertion
.
"
)
;
RemoveSheetOfType
(
aType
aSheet
)
;
PrependSheetOfType
(
aType
aSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_PrependStyleSheet
(
mRawSet
.
get
(
)
aSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
}
return
NS_OK
;
}
nsresult
ServoStyleSet
:
:
RemoveStyleSheet
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
RemoveSheetOfType
(
aType
aSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_RemoveStyleSheet
(
mRawSet
.
get
(
)
aSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
}
return
NS_OK
;
}
nsresult
ServoStyleSet
:
:
ReplaceSheets
(
SheetType
aType
const
nsTArray
<
RefPtr
<
ServoStyleSheet
>
>
&
aNewSheets
)
{
SetStylistStyleSheetsDirty
(
)
;
for
(
const
auto
&
sheet
:
mSheets
[
aType
]
)
{
sheet
-
>
DropStyleSet
(
this
)
;
if
(
mRawSet
)
{
Servo_StyleSet_RemoveStyleSheet
(
mRawSet
.
get
(
)
sheet
)
;
}
}
mSheets
[
aType
]
.
Clear
(
)
;
for
(
auto
&
sheet
:
aNewSheets
)
{
AppendSheetOfType
(
aType
sheet
)
;
if
(
mRawSet
)
{
MOZ_ASSERT
(
sheet
-
>
RawContents
(
)
"
Raw
sheet
should
be
in
place
before
replacement
.
"
)
;
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
sheet
)
;
}
}
return
NS_OK
;
}
nsresult
ServoStyleSet
:
:
InsertStyleSheetBefore
(
SheetType
aType
ServoStyleSheet
*
aNewSheet
ServoStyleSheet
*
aReferenceSheet
)
{
MOZ_ASSERT
(
aNewSheet
)
;
MOZ_ASSERT
(
aReferenceSheet
)
;
MOZ_ASSERT
(
aNewSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
aNewSheet
!
=
aReferenceSheet
"
Can
'
t
place
sheet
before
itself
.
"
)
;
MOZ_ASSERT
(
aNewSheet
-
>
RawContents
(
)
"
Raw
sheet
should
be
in
place
before
insertion
.
"
)
;
MOZ_ASSERT
(
aReferenceSheet
-
>
RawContents
(
)
"
Reference
sheet
should
have
a
raw
sheet
.
"
)
;
RemoveSheetOfType
(
aType
aNewSheet
)
;
InsertSheetOfType
(
aType
aNewSheet
aReferenceSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_InsertStyleSheetBefore
(
mRawSet
.
get
(
)
aNewSheet
aReferenceSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
}
return
NS_OK
;
}
void
ServoStyleSet
:
:
UpdateStyleSheet
(
ServoStyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
}
int32_t
ServoStyleSet
:
:
SheetCount
(
SheetType
aType
)
const
{
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
return
mSheets
[
aType
]
.
Length
(
)
;
}
ServoStyleSheet
*
ServoStyleSet
:
:
StyleSheetAt
(
SheetType
aType
int32_t
aIndex
)
const
{
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
return
mSheets
[
aType
]
[
aIndex
]
;
}
void
ServoStyleSet
:
:
AppendAllXBLStyleSheets
(
nsTArray
<
StyleSheet
*
>
&
aArray
)
const
{
if
(
mBindingManager
)
{
mBindingManager
-
>
AppendAllSheets
(
aArray
)
;
}
}
nsresult
ServoStyleSet
:
:
RemoveDocStyleSheet
(
ServoStyleSheet
*
aSheet
)
{
return
RemoveStyleSheet
(
SheetType
:
:
Doc
aSheet
)
;
}
nsresult
ServoStyleSet
:
:
AddDocStyleSheet
(
ServoStyleSheet
*
aSheet
nsIDocument
*
aDocument
)
{
MOZ_ASSERT
(
aSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
aSheet
-
>
RawContents
(
)
"
Raw
sheet
should
be
in
place
by
this
point
.
"
)
;
RefPtr
<
StyleSheet
>
strong
(
aSheet
)
;
RemoveSheetOfType
(
SheetType
:
:
Doc
aSheet
)
;
size_t
index
=
aDocument
-
>
FindDocStyleSheetInsertionPoint
(
mSheets
[
SheetType
:
:
Doc
]
aSheet
)
;
if
(
index
<
mSheets
[
SheetType
:
:
Doc
]
.
Length
(
)
)
{
ServoStyleSheet
*
beforeSheet
=
mSheets
[
SheetType
:
:
Doc
]
[
index
]
;
InsertSheetOfType
(
SheetType
:
:
Doc
aSheet
beforeSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_InsertStyleSheetBefore
(
mRawSet
.
get
(
)
aSheet
beforeSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
}
}
else
{
AppendSheetOfType
(
SheetType
:
:
Doc
aSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
aSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
}
}
return
NS_OK
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ProbePseudoElementStyle
(
Element
*
aOriginatingElement
CSSPseudoElementType
aType
ServoStyleContext
*
aParentContext
)
{
UpdateStylistIfNeeded
(
)
;
MOZ_ASSERT
(
aType
<
CSSPseudoElementType
:
:
Count
)
;
bool
cacheable
=
!
nsCSSPseudoElements
:
:
IsEagerlyCascadedInServo
(
aType
)
&
&
aParentContext
;
RefPtr
<
ServoStyleContext
>
computedValues
=
cacheable
?
aParentContext
-
>
GetCachedLazyPseudoStyle
(
aType
)
:
nullptr
;
if
(
!
computedValues
)
{
computedValues
=
Servo_ResolvePseudoStyle
(
aOriginatingElement
aType
true
nullptr
mRawSet
.
get
(
)
)
.
Consume
(
)
;
if
(
!
computedValues
)
{
return
nullptr
;
}
if
(
cacheable
)
{
aParentContext
-
>
SetCachedLazyPseudoStyle
(
computedValues
)
;
}
}
bool
isBeforeOrAfter
=
aType
=
=
CSSPseudoElementType
:
:
before
|
|
aType
=
=
CSSPseudoElementType
:
:
after
;
if
(
isBeforeOrAfter
)
{
const
nsStyleDisplay
*
display
=
computedValues
-
>
ComputedData
(
)
-
>
GetStyleDisplay
(
)
;
const
nsStyleContent
*
content
=
computedValues
-
>
ComputedData
(
)
-
>
GetStyleContent
(
)
;
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
None
|
|
content
-
>
ContentCount
(
)
=
=
0
)
{
return
nullptr
;
}
}
return
computedValues
.
forget
(
)
;
}
nsRestyleHint
ServoStyleSet
:
:
HasStateDependentStyle
(
dom
:
:
Element
*
aElement
EventStates
aStateMask
)
{
NS_WARNING
(
"
stylo
:
HasStateDependentStyle
always
returns
zero
!
"
)
;
return
nsRestyleHint
(
0
)
;
}
nsRestyleHint
ServoStyleSet
:
:
HasStateDependentStyle
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
dom
:
:
Element
*
aPseudoElement
EventStates
aStateMask
)
{
NS_WARNING
(
"
stylo
:
HasStateDependentStyle
always
returns
zero
!
"
)
;
return
nsRestyleHint
(
0
)
;
}
bool
ServoStyleSet
:
:
StyleDocument
(
ServoTraversalFlags
aFlags
)
{
if
(
!
!
(
aFlags
&
ServoTraversalFlags
:
:
AnimationOnly
)
)
{
PreTraverse
(
nullptr
EffectCompositor
:
:
AnimationRestyleType
:
:
Full
)
;
}
else
{
PreTraverse
(
)
;
}
bool
postTraversalRequired
=
false
;
DocumentStyleRootIterator
iter
(
mPresContext
-
>
Document
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
if
(
PrepareAndTraverseSubtree
(
root
aFlags
)
)
{
postTraversalRequired
=
true
;
}
}
return
postTraversalRequired
;
}
void
ServoStyleSet
:
:
StyleNewSubtree
(
Element
*
aRoot
)
{
MOZ_ASSERT
(
!
aRoot
-
>
HasServoData
(
)
"
Should
have
called
StyleNewChildren
"
)
;
PreTraverseSync
(
)
;
AutoPrepareTraversal
guard
(
this
)
;
const
SnapshotTable
&
snapshots
=
Snapshots
(
)
;
DebugOnly
<
bool
>
postTraversalRequired
=
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
ServoTraversalFlags
:
:
Empty
)
;
MOZ_ASSERT
(
!
postTraversalRequired
)
;
auto
type
=
EffectCompositor
:
:
AnimationRestyleType
:
:
Throttled
;
if
(
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverseInSubtree
(
aRoot
type
)
)
{
postTraversalRequired
=
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
ServoTraversalFlags
:
:
AnimationOnly
|
ServoTraversalFlags
:
:
Forgetful
|
ServoTraversalFlags
:
:
ClearAnimationOnlyDirtyDescendants
)
;
MOZ_ASSERT
(
!
postTraversalRequired
)
;
}
}
void
ServoStyleSet
:
:
StyleNewChildren
(
Element
*
aParent
)
{
MOZ_ASSERT
(
aParent
-
>
HasServoData
(
)
"
Should
have
called
StyleNewSubtree
"
)
;
PreTraverseSync
(
)
;
AutoPrepareTraversal
guard
(
this
)
;
bool
hadDirtyDescendants
=
aParent
-
>
HasDirtyDescendantsForServo
(
)
;
aParent
-
>
SetHasDirtyDescendantsForServo
(
)
;
const
SnapshotTable
&
snapshots
=
Snapshots
(
)
;
Servo_TraverseSubtree
(
aParent
mRawSet
.
get
(
)
&
snapshots
ServoTraversalFlags
:
:
UnstyledOnly
)
;
if
(
!
hadDirtyDescendants
)
{
aParent
-
>
UnsetHasDirtyDescendantsForServo
(
)
;
}
}
void
ServoStyleSet
:
:
StyleNewlyBoundElement
(
Element
*
aElement
)
{
if
(
MOZ_LIKELY
(
aElement
-
>
HasServoData
(
)
)
)
{
StyleNewChildren
(
aElement
)
;
}
else
{
StyleNewSubtree
(
aElement
)
;
}
}
void
ServoStyleSet
:
:
StyleSubtreeForReconstruct
(
Element
*
aRoot
)
{
PreTraverse
(
aRoot
)
;
MOZ_ASSERT
(
MayTraverseFrom
(
aRoot
)
)
;
MOZ_ASSERT
(
aRoot
-
>
HasServoData
(
)
)
;
AutoPrepareTraversal
guard
(
this
)
;
const
SnapshotTable
&
snapshots
=
Snapshots
(
)
;
auto
flags
=
ServoTraversalFlags
:
:
Forgetful
|
ServoTraversalFlags
:
:
AggressivelyForgetful
|
ServoTraversalFlags
:
:
ClearDirtyDescendants
|
ServoTraversalFlags
:
:
ClearAnimationOnlyDirtyDescendants
;
DebugOnly
<
bool
>
postTraversalRequired
=
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
flags
)
;
MOZ_ASSERT
(
!
postTraversalRequired
)
;
auto
type
=
EffectCompositor
:
:
AnimationRestyleType
:
:
Throttled
;
if
(
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverseInSubtree
(
aRoot
type
)
)
{
postTraversalRequired
=
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
flags
)
;
MOZ_ASSERT
(
!
postTraversalRequired
)
;
}
}
void
ServoStyleSet
:
:
ForceAllStyleDirty
(
)
{
SetStylistStyleSheetsDirty
(
)
;
Servo_StyleSet_NoteStyleSheetsChanged
(
mRawSet
.
get
(
)
mAuthorStyleDisabled
)
;
}
void
ServoStyleSet
:
:
RecordStyleSheetChange
(
ServoStyleSheet
*
aSheet
StyleSheet
:
:
ChangeType
aChangeType
)
{
SetStylistStyleSheetsDirty
(
)
;
switch
(
aChangeType
)
{
case
StyleSheet
:
:
ChangeType
:
:
RuleAdded
:
case
StyleSheet
:
:
ChangeType
:
:
RuleRemoved
:
case
StyleSheet
:
:
ChangeType
:
:
RuleChanged
:
return
ForceAllStyleDirty
(
)
;
case
StyleSheet
:
:
ChangeType
:
:
ApplicableStateChanged
:
case
StyleSheet
:
:
ChangeType
:
:
Added
:
case
StyleSheet
:
:
ChangeType
:
:
Removed
:
return
;
}
}
#
ifdef
DEBUG
void
ServoStyleSet
:
:
AssertTreeIsClean
(
)
{
DocumentStyleRootIterator
iter
(
mPresContext
-
>
Document
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
Servo_AssertTreeIsClean
(
root
)
;
}
}
#
endif
bool
ServoStyleSet
:
:
GetKeyframesForName
(
const
nsString
&
aName
const
nsTimingFunction
&
aTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
UpdateStylistIfNeeded
(
)
;
NS_ConvertUTF16toUTF8
name
(
aName
)
;
return
Servo_StyleSet_GetKeyframesForName
(
mRawSet
.
get
(
)
&
name
&
aTimingFunction
&
aKeyframes
)
;
}
nsTArray
<
ComputedKeyframeValues
>
ServoStyleSet
:
:
GetComputedKeyframeValuesFor
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
Element
*
aElement
const
ServoStyleContext
*
aContext
)
{
MOZ_RELEASE_ASSERT
(
!
aElement
-
>
OwnerDoc
(
)
-
>
GetBFCacheEntry
(
)
)
;
AutoClearStaleData
guard
(
aElement
)
;
nsTArray
<
ComputedKeyframeValues
>
result
(
aKeyframes
.
Length
(
)
)
;
result
.
AppendElements
(
aKeyframes
.
Length
(
)
)
;
Servo_GetComputedKeyframeValues
(
&
aKeyframes
aElement
aContext
mRawSet
.
get
(
)
&
result
)
;
return
result
;
}
void
ServoStyleSet
:
:
GetAnimationValues
(
RawServoDeclarationBlock
*
aDeclarations
Element
*
aElement
const
ServoStyleContext
*
aStyleContext
nsTArray
<
RefPtr
<
RawServoAnimationValue
>
>
&
aAnimationValues
)
{
MOZ_RELEASE_ASSERT
(
!
aElement
-
>
OwnerDoc
(
)
-
>
GetBFCacheEntry
(
)
)
;
AutoClearStaleData
guard
(
aElement
)
;
Servo_GetAnimationValues
(
aDeclarations
aElement
aStyleContext
mRawSet
.
get
(
)
&
aAnimationValues
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
GetBaseContextForElement
(
Element
*
aElement
ServoStyleContext
*
aParentContext
nsPresContext
*
aPresContext
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
const
ServoStyleContext
*
aStyle
)
{
MOZ_RELEASE_ASSERT
(
!
aElement
-
>
OwnerDoc
(
)
-
>
GetBFCacheEntry
(
)
"
GetBaseContextForElement
does
not
support
documents
in
the
"
"
bfcache
"
)
;
AutoClearStaleData
guard
(
aElement
)
;
return
Servo_StyleSet_GetBaseComputedValuesForElement
(
mRawSet
.
get
(
)
aElement
aStyle
&
Snapshots
(
)
aPseudoType
)
.
Consume
(
)
;
}
already_AddRefed
<
RawServoAnimationValue
>
ServoStyleSet
:
:
ComputeAnimationValue
(
Element
*
aElement
RawServoDeclarationBlock
*
aDeclarations
const
ServoStyleContext
*
aContext
)
{
MOZ_RELEASE_ASSERT
(
!
aElement
-
>
OwnerDoc
(
)
-
>
GetBFCacheEntry
(
)
)
;
AutoClearStaleData
guard
(
aElement
)
;
return
Servo_AnimationValue_Compute
(
aElement
aDeclarations
aContext
mRawSet
.
get
(
)
)
.
Consume
(
)
;
}
bool
ServoStyleSet
:
:
EnsureUniqueInnerOnCSSSheets
(
)
{
AutoTArray
<
StyleSheet
*
32
>
queue
;
for
(
auto
&
entryArray
:
mSheets
)
{
for
(
auto
&
sheet
:
entryArray
)
{
queue
.
AppendElement
(
sheet
)
;
}
}
while
(
!
queue
.
IsEmpty
(
)
)
{
uint32_t
idx
=
queue
.
Length
(
)
-
1
;
StyleSheet
*
sheet
=
queue
[
idx
]
;
queue
.
RemoveElementAt
(
idx
)
;
sheet
-
>
EnsureUniqueInner
(
)
;
sheet
-
>
AppendAllChildSheets
(
queue
)
;
}
bool
res
=
mNeedsRestyleAfterEnsureUniqueInner
;
mNeedsRestyleAfterEnsureUniqueInner
=
false
;
return
res
;
}
void
ServoStyleSet
:
:
ClearCachedStyleData
(
)
{
ClearNonInheritingStyleContexts
(
)
;
Servo_StyleSet_RebuildCachedData
(
mRawSet
.
get
(
)
)
;
}
void
ServoStyleSet
:
:
CompatibilityModeChanged
(
)
{
Servo_StyleSet_CompatModeChanged
(
mRawSet
.
get
(
)
)
;
}
inline
static
void
UpdateBodyTextColorIfNeeded
(
const
Element
&
aElement
ServoStyleContext
&
aStyleContext
nsPresContext
&
aPresContext
)
{
if
(
aPresContext
.
CompatibilityMode
(
)
!
=
eCompatibility_NavQuirks
)
{
return
;
}
if
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
;
}
nsIDocument
*
doc
=
aElement
.
GetUncomposedDoc
(
)
;
if
(
!
doc
|
|
doc
-
>
GetBodyElement
(
)
!
=
&
aElement
)
{
return
;
}
MOZ_ASSERT
(
!
aStyleContext
.
GetPseudo
(
)
)
;
aPresContext
.
SetBodyTextColor
(
aStyleContext
.
ComputedData
(
)
-
>
GetStyleColor
(
)
-
>
mColor
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveServoStyle
(
Element
*
aElement
ServoTraversalFlags
aFlags
)
{
UpdateStylistIfNeeded
(
)
;
RefPtr
<
ServoStyleContext
>
result
=
Servo_ResolveStyle
(
aElement
mRawSet
.
get
(
)
aFlags
)
.
Consume
(
)
;
UpdateBodyTextColorIfNeeded
(
*
aElement
*
result
*
mPresContext
)
;
return
result
.
forget
(
)
;
}
void
ServoStyleSet
:
:
ClearNonInheritingStyleContexts
(
)
{
for
(
RefPtr
<
ServoStyleContext
>
&
ptr
:
mNonInheritingStyleContexts
)
{
ptr
=
nullptr
;
}
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveStyleLazilyInternal
(
Element
*
aElement
CSSPseudoElementType
aPseudoType
nsIAtom
*
aPseudoTag
const
ServoStyleContext
*
aParentContext
StyleRuleInclusion
aRuleInclusion
bool
aIgnoreExistingStyles
)
{
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverse
(
aElement
aPseudoType
)
;
MOZ_ASSERT
(
!
StylistNeedsUpdate
(
)
)
;
AutoSetInServoTraversal
guard
(
this
)
;
Element
*
elementForStyleResolution
=
aElement
;
CSSPseudoElementType
pseudoTypeForStyleResolution
=
aPseudoType
;
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
if
(
Element
*
pseudo
=
nsLayoutUtils
:
:
GetBeforePseudo
(
aElement
)
)
{
elementForStyleResolution
=
pseudo
;
pseudoTypeForStyleResolution
=
CSSPseudoElementType
:
:
NotPseudo
;
}
}
else
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
if
(
Element
*
pseudo
=
nsLayoutUtils
:
:
GetAfterPseudo
(
aElement
)
)
{
elementForStyleResolution
=
pseudo
;
pseudoTypeForStyleResolution
=
CSSPseudoElementType
:
:
NotPseudo
;
}
}
RefPtr
<
ServoStyleContext
>
computedValues
=
Servo_ResolveStyleLazily
(
elementForStyleResolution
pseudoTypeForStyleResolution
aRuleInclusion
&
Snapshots
(
)
mRawSet
.
get
(
)
aIgnoreExistingStyles
)
.
Consume
(
)
;
if
(
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverse
(
aElement
aPseudoType
)
)
{
computedValues
=
Servo_ResolveStyleLazily
(
elementForStyleResolution
pseudoTypeForStyleResolution
aRuleInclusion
&
Snapshots
(
)
mRawSet
.
get
(
)
aIgnoreExistingStyles
)
.
Consume
(
)
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
UpdateBodyTextColorIfNeeded
(
*
aElement
*
computedValues
*
mPresContext
)
;
}
return
computedValues
.
forget
(
)
;
}
bool
ServoStyleSet
:
:
AppendFontFaceRules
(
nsTArray
<
nsFontFaceRuleContainer
>
&
aArray
)
{
UpdateStylistIfNeeded
(
)
;
Servo_StyleSet_GetFontFaceRules
(
mRawSet
.
get
(
)
&
aArray
)
;
return
true
;
}
nsCSSCounterStyleRule
*
ServoStyleSet
:
:
CounterStyleRuleForName
(
nsIAtom
*
aName
)
{
return
Servo_StyleSet_GetCounterStyleRule
(
mRawSet
.
get
(
)
aName
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ResolveForDeclarations
(
const
ServoStyleContext
*
aParentOrNull
RawServoDeclarationBlockBorrowed
aDeclarations
)
{
UpdateStylistIfNeeded
(
)
;
return
Servo_StyleSet_ResolveForDeclarations
(
mRawSet
.
get
(
)
aParentOrNull
aDeclarations
)
.
Consume
(
)
;
}
void
ServoStyleSet
:
:
UpdateStylist
(
)
{
MOZ_ASSERT
(
StylistNeedsUpdate
(
)
)
;
Element
*
root
=
mPresContext
-
>
Document
(
)
-
>
GetDocumentElement
(
)
;
Servo_StyleSet_FlushStyleSheets
(
mRawSet
.
get
(
)
root
)
;
mStylistState
=
StylistState
:
:
NotDirty
;
}
void
ServoStyleSet
:
:
MaybeGCRuleTree
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Servo_MaybeGCRuleTree
(
mRawSet
.
get
(
)
)
;
}
bool
ServoStyleSet
:
:
MayTraverseFrom
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
)
;
Element
*
parent
=
aElement
-
>
GetFlattenedTreeParentElementForStyle
(
)
;
if
(
!
parent
)
{
return
true
;
}
if
(
!
parent
-
>
HasServoData
(
)
)
{
return
false
;
}
RefPtr
<
ServoStyleContext
>
sc
=
Servo_ResolveStyleAllowStale
(
parent
)
.
Consume
(
)
;
return
sc
-
>
StyleDisplay
(
)
-
>
mDisplay
!
=
StyleDisplay
:
:
None
;
}
void
ServoStyleSet
:
:
PrependSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
aSheet
-
>
AddStyleSet
(
this
)
;
mSheets
[
aType
]
.
InsertElementAt
(
0
aSheet
)
;
}
void
ServoStyleSet
:
:
AppendSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
aSheet
-
>
AddStyleSet
(
this
)
;
mSheets
[
aType
]
.
AppendElement
(
aSheet
)
;
}
void
ServoStyleSet
:
:
InsertSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
ServoStyleSheet
*
aBeforeSheet
)
{
for
(
uint32_t
i
=
0
;
i
<
mSheets
[
aType
]
.
Length
(
)
;
+
+
i
)
{
if
(
mSheets
[
aType
]
[
i
]
=
=
aBeforeSheet
)
{
aSheet
-
>
AddStyleSet
(
this
)
;
mSheets
[
aType
]
.
InsertElementAt
(
i
aSheet
)
;
return
;
}
}
}
void
ServoStyleSet
:
:
RemoveSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
for
(
uint32_t
i
=
0
;
i
<
mSheets
[
aType
]
.
Length
(
)
;
+
+
i
)
{
if
(
mSheets
[
aType
]
[
i
]
=
=
aSheet
)
{
aSheet
-
>
DropStyleSet
(
this
)
;
mSheets
[
aType
]
.
RemoveElementAt
(
i
)
;
}
}
}
void
ServoStyleSet
:
:
RunPostTraversalTasks
(
)
{
MOZ_ASSERT
(
!
IsInServoTraversal
(
)
)
;
if
(
mPostTraversalTasks
.
IsEmpty
(
)
)
{
return
;
}
nsTArray
<
PostTraversalTask
>
tasks
;
tasks
.
SwapElements
(
mPostTraversalTasks
)
;
for
(
auto
&
task
:
tasks
)
{
task
.
Run
(
)
;
}
}
ServoStyleRuleMap
*
ServoStyleSet
:
:
StyleRuleMap
(
)
{
if
(
!
mStyleRuleMap
)
{
mStyleRuleMap
=
new
ServoStyleRuleMap
(
this
)
;
nsIDocument
*
doc
=
mPresContext
-
>
Document
(
)
;
doc
-
>
AddObserver
(
mStyleRuleMap
)
;
doc
-
>
CSSLoader
(
)
-
>
AddObserver
(
mStyleRuleMap
)
;
}
return
mStyleRuleMap
;
}
bool
ServoStyleSet
:
:
MightHaveAttributeDependency
(
const
Element
&
aElement
nsIAtom
*
aAttribute
)
const
{
return
Servo_StyleSet_MightHaveAttributeDependency
(
mRawSet
.
get
(
)
&
aElement
aAttribute
)
;
}
bool
ServoStyleSet
:
:
HasStateDependency
(
const
Element
&
aElement
EventStates
aState
)
const
{
return
Servo_StyleSet_HasStateDependency
(
mRawSet
.
get
(
)
&
aElement
aState
.
ServoValue
(
)
)
;
}
already_AddRefed
<
ServoStyleContext
>
ServoStyleSet
:
:
ReparentStyleContext
(
ServoStyleContext
*
aStyleContext
ServoStyleContext
*
aNewParent
ServoStyleContext
*
aNewParentIgnoringFirstLine
ServoStyleContext
*
aNewLayoutParent
Element
*
aElement
)
{
return
Servo_ReparentStyle
(
aStyleContext
aNewParent
aNewParentIgnoringFirstLine
aNewLayoutParent
aElement
mRawSet
.
get
(
)
)
.
Consume
(
)
;
}
