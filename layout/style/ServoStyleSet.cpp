#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoStyleSetInlines
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
mozilla
/
AutoRestyleTimelineMarker
.
h
"
#
include
"
mozilla
/
DocumentStyleRootIterator
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ServoStyleRuleMap
.
h
"
#
include
"
mozilla
/
ServoTypes
.
h
"
#
include
"
mozilla
/
SMILAnimationController
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
mozilla
/
dom
/
AnonymousContent
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceSet
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsHTMLStyleSheet
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsMediaFeatures
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
GeckoProfiler
.
h
"
namespace
mozilla
{
using
namespace
dom
;
#
ifdef
DEBUG
bool
ServoStyleSet
:
:
IsCurrentThreadInServoTraversal
(
)
{
return
sInServoTraversal
&
&
(
NS_IsMainThread
(
)
|
|
Servo_IsWorkerThread
(
)
)
;
}
#
endif
constexpr
const
StyleOrigin
ServoStyleSet
:
:
kOrigins
[
]
;
ServoStyleSet
*
sInServoTraversal
=
nullptr
;
class
MOZ_RAII
AutoSetInServoTraversal
{
public
:
explicit
AutoSetInServoTraversal
(
ServoStyleSet
*
aSet
)
:
mSet
(
aSet
)
{
MOZ_ASSERT
(
!
sInServoTraversal
)
;
MOZ_ASSERT
(
aSet
)
;
sInServoTraversal
=
aSet
;
}
~
AutoSetInServoTraversal
(
)
{
MOZ_ASSERT
(
sInServoTraversal
)
;
sInServoTraversal
=
nullptr
;
mSet
-
>
RunPostTraversalTasks
(
)
;
}
private
:
ServoStyleSet
*
mSet
;
}
;
class
MOZ_RAII
AutoPrepareTraversal
{
public
:
explicit
AutoPrepareTraversal
(
ServoStyleSet
*
aSet
)
:
mTimelineMarker
(
aSet
-
>
mDocument
-
>
GetDocShell
(
)
false
)
mSetInServoTraversal
(
aSet
)
{
MOZ_ASSERT
(
!
aSet
-
>
StylistNeedsUpdate
(
)
)
;
}
private
:
AutoRestyleTimelineMarker
mTimelineMarker
;
AutoSetInServoTraversal
mSetInServoTraversal
;
}
;
ServoStyleSet
:
:
ServoStyleSet
(
Document
&
aDocument
)
:
mDocument
(
&
aDocument
)
{
PreferenceSheet
:
:
EnsureInitialized
(
)
;
PodArrayZero
(
mCachedAnonymousContentStyleIndexes
)
;
mRawSet
.
reset
(
Servo_StyleSet_Init
(
&
aDocument
)
)
;
}
ServoStyleSet
:
:
~
ServoStyleSet
(
)
{
MOZ_ASSERT
(
!
IsInServoTraversal
(
)
)
;
EnumerateStyleSheets
(
[
&
]
(
StyleSheet
&
aSheet
)
{
aSheet
.
DropStyleSet
(
this
)
;
}
)
;
}
nsPresContext
*
ServoStyleSet
:
:
GetPresContext
(
)
{
return
mDocument
-
>
GetPresContext
(
)
;
}
template
<
typename
Functor
>
void
EnumerateShadowRoots
(
const
Document
&
aDoc
const
Functor
&
aCb
)
{
const
Document
:
:
ShadowRootSet
&
shadowRoots
=
aDoc
.
ComposedShadowRoots
(
)
;
for
(
auto
iter
=
shadowRoots
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ShadowRoot
*
root
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
MOZ_ASSERT
(
root
)
;
MOZ_DIAGNOSTIC_ASSERT
(
root
-
>
IsInComposedDoc
(
)
)
;
aCb
(
*
root
)
;
}
}
void
ServoStyleSet
:
:
ShellDetachedFromDocument
(
)
{
ClearNonInheritingComputedStyles
(
)
;
mCachedAnonymousContentStyles
.
Clear
(
)
;
PodArrayZero
(
mCachedAnonymousContentStyleIndexes
)
;
mStyleRuleMap
=
nullptr
;
for
(
const
Origin
origin
:
kOrigins
)
{
for
(
size_t
count
=
SheetCount
(
origin
)
;
count
-
-
;
)
{
RemoveStyleSheet
(
origin
SheetAt
(
origin
count
)
)
;
}
}
UpdateStylistIfNeeded
(
)
;
MaybeGCRuleTree
(
)
;
}
void
ServoStyleSet
:
:
RecordShadowStyleChange
(
ShadowRoot
&
aShadowRoot
)
{
SetStylistShadowDOMStyleSheetsDirty
(
)
;
if
(
nsPresContext
*
pc
=
GetPresContext
(
)
)
{
pc
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
aShadowRoot
.
Host
(
)
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
}
}
void
ServoStyleSet
:
:
InvalidateStyleForDocumentStateChanges
(
EventStates
aStatesChanged
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
!
aStatesChanged
.
IsEmpty
(
)
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
!
pc
)
{
return
;
}
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
!
root
)
{
return
;
}
AutoTArray
<
const
RawServoAuthorStyles
*
20
>
nonDocumentStyles
;
EnumerateShadowRoots
(
*
mDocument
[
&
]
(
ShadowRoot
&
aShadowRoot
)
{
if
(
auto
*
authorStyles
=
aShadowRoot
.
GetServoStyles
(
)
)
{
nonDocumentStyles
.
AppendElement
(
authorStyles
)
;
}
}
)
;
Servo_InvalidateStyleForDocStateChanges
(
root
mRawSet
.
get
(
)
&
nonDocumentStyles
aStatesChanged
.
ServoValue
(
)
)
;
}
static
const
MediaFeatureChangeReason
kMediaFeaturesAffectingDefaultStyle
=
MediaFeatureChangeReason
:
:
ZoomChange
|
MediaFeatureChangeReason
:
:
ResolutionChange
;
RestyleHint
ServoStyleSet
:
:
MediumFeaturesChanged
(
MediaFeatureChangeReason
aReason
)
{
AutoTArray
<
RawServoAuthorStyles
*
20
>
nonDocumentStyles
;
EnumerateShadowRoots
(
*
mDocument
[
&
]
(
ShadowRoot
&
aShadowRoot
)
{
if
(
auto
*
authorStyles
=
aShadowRoot
.
GetServoStyles
(
)
)
{
nonDocumentStyles
.
AppendElement
(
authorStyles
)
;
}
}
)
;
bool
mayAffectDefaultStyle
=
bool
(
aReason
&
kMediaFeaturesAffectingDefaultStyle
)
;
const
MediumFeaturesChangedResult
result
=
Servo_StyleSet_MediumFeaturesChanged
(
mRawSet
.
get
(
)
&
nonDocumentStyles
mayAffectDefaultStyle
)
;
const
bool
rulesChanged
=
result
.
mAffectsDocumentRules
|
|
result
.
mAffectsNonDocumentRules
;
if
(
result
.
mAffectsDocumentRules
)
{
SetStylistStyleSheetsDirty
(
)
;
}
if
(
result
.
mAffectsNonDocumentRules
)
{
SetStylistShadowDOMStyleSheetsDirty
(
)
;
}
if
(
rulesChanged
)
{
return
RestyleHint
:
:
RestyleSubtree
(
)
;
}
const
bool
viewportChanged
=
bool
(
aReason
&
MediaFeatureChangeReason
:
:
ViewportChange
)
;
if
(
result
.
mUsesViewportUnits
&
&
viewportChanged
)
{
return
RestyleHint
:
:
RecascadeSubtree
(
)
;
}
return
RestyleHint
{
0
}
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
ServoStyleSetMallocSizeOf
)
MOZ_DEFINE_MALLOC_ENCLOSING_SIZE_OF
(
ServoStyleSetMallocEnclosingSizeOf
)
void
ServoStyleSet
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
)
const
{
MallocSizeOf
mallocSizeOf
=
aSizes
.
mState
.
mMallocSizeOf
;
aSizes
.
mLayoutStyleSetsOther
+
=
mallocSizeOf
(
this
)
;
if
(
mRawSet
)
{
aSizes
.
mLayoutStyleSetsOther
+
=
mallocSizeOf
(
mRawSet
.
get
(
)
)
;
ServoStyleSetSizes
sizes
;
Servo_StyleSet_AddSizeOfExcludingThis
(
ServoStyleSetMallocSizeOf
ServoStyleSetMallocEnclosingSizeOf
&
sizes
mRawSet
.
get
(
)
)
;
MOZ_RELEASE_ASSERT
(
sizes
.
mPrecomputedPseudos
=
=
0
)
;
aSizes
.
mLayoutStyleSetsStylistRuleTree
+
=
sizes
.
mRuleTree
;
aSizes
.
mLayoutStyleSetsStylistElementAndPseudosMaps
+
=
sizes
.
mElementAndPseudosMaps
;
aSizes
.
mLayoutStyleSetsStylistInvalidationMap
+
=
sizes
.
mInvalidationMap
;
aSizes
.
mLayoutStyleSetsStylistRevalidationSelectors
+
=
sizes
.
mRevalidationSelectors
;
aSizes
.
mLayoutStyleSetsStylistOther
+
=
sizes
.
mOther
;
}
if
(
mStyleRuleMap
)
{
aSizes
.
mLayoutStyleSetsOther
+
=
mStyleRuleMap
-
>
SizeOfIncludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
}
}
void
ServoStyleSet
:
:
SetAuthorStyleDisabled
(
bool
aStyleDisabled
)
{
if
(
mAuthorStyleDisabled
=
=
aStyleDisabled
)
{
return
;
}
mAuthorStyleDisabled
=
aStyleDisabled
;
if
(
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
)
{
if
(
nsPresContext
*
pc
=
GetPresContext
(
)
)
{
pc
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
root
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
}
}
Servo_StyleSet_SetAuthorStyleDisabled
(
mRawSet
.
get
(
)
mAuthorStyleDisabled
)
;
SetStylistStyleSheetsDirty
(
)
;
}
const
ServoElementSnapshotTable
&
ServoStyleSet
:
:
Snapshots
(
)
{
MOZ_ASSERT
(
GetPresContext
(
)
"
Styling
a
document
without
a
shell
?
"
)
;
return
GetPresContext
(
)
-
>
RestyleManager
(
)
-
>
Snapshots
(
)
;
}
void
ServoStyleSet
:
:
ResolveMappedAttrDeclarationBlocks
(
)
{
if
(
nsHTMLStyleSheet
*
sheet
=
mDocument
-
>
GetAttributeStyleSheet
(
)
)
{
sheet
-
>
CalculateMappedServoDeclarations
(
)
;
}
mDocument
-
>
ResolveScheduledSVGPresAttrs
(
)
;
}
void
ServoStyleSet
:
:
PreTraverseSync
(
)
{
Unused
<
<
mDocument
-
>
GetRootElement
(
)
;
mDocument
-
>
FlushUserFontSet
(
)
;
ResolveMappedAttrDeclarationBlocks
(
)
;
nsMediaFeatures
:
:
InitSystemMetrics
(
)
;
LookAndFeel
:
:
NativeInit
(
)
;
mDocument
-
>
CacheAllKnownLangPrefs
(
)
;
if
(
gfxUserFontSet
*
userFontSet
=
mDocument
-
>
GetUserFontSet
(
)
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
MOZ_ASSERT
(
presContext
"
For
now
we
don
'
t
call
into
here
without
a
pres
context
"
)
;
uint64_t
generation
=
userFontSet
-
>
GetGeneration
(
)
;
if
(
generation
!
=
mUserFontSetUpdateGeneration
)
{
mDocument
-
>
GetFonts
(
)
-
>
CacheFontLoadability
(
)
;
presContext
-
>
DeviceContext
(
)
-
>
UpdateFontCacheUserFonts
(
userFontSet
)
;
mUserFontSetUpdateGeneration
=
generation
;
}
}
MOZ_ASSERT
(
!
StylistNeedsUpdate
(
)
)
;
}
void
ServoStyleSet
:
:
PreTraverse
(
ServoTraversalFlags
aFlags
Element
*
aRoot
)
{
PreTraverseSync
(
)
;
SMILAnimationController
*
smilController
=
mDocument
-
>
HasAnimationController
(
)
?
mDocument
-
>
GetAnimationController
(
)
:
nullptr
;
MOZ_ASSERT
(
GetPresContext
(
)
)
;
if
(
aRoot
)
{
GetPresContext
(
)
-
>
EffectCompositor
(
)
-
>
PreTraverseInSubtree
(
aFlags
aRoot
)
;
if
(
smilController
)
{
smilController
-
>
PreTraverseInSubtree
(
aRoot
)
;
}
}
else
{
GetPresContext
(
)
-
>
EffectCompositor
(
)
-
>
PreTraverse
(
aFlags
)
;
if
(
smilController
)
{
smilController
-
>
PreTraverse
(
)
;
}
}
}
static
inline
already_AddRefed
<
ComputedStyle
>
ResolveStyleForTextOrFirstLetterContinuation
(
const
RawServoStyleSet
*
aStyleSet
ComputedStyle
&
aParent
PseudoStyleType
aType
)
{
MOZ_ASSERT
(
aType
=
=
PseudoStyleType
:
:
mozText
|
|
aType
=
=
PseudoStyleType
:
:
firstLetterContinuation
)
;
auto
inheritTarget
=
aType
=
=
PseudoStyleType
:
:
mozText
?
InheritTarget
:
:
Text
:
InheritTarget
:
:
FirstLetterContinuation
;
RefPtr
<
ComputedStyle
>
style
=
aParent
.
GetCachedInheritingAnonBoxStyle
(
aType
)
;
if
(
!
style
)
{
style
=
Servo_ComputedValues_Inherit
(
aStyleSet
aType
&
aParent
inheritTarget
)
.
Consume
(
)
;
MOZ_ASSERT
(
style
)
;
aParent
.
SetCachedInheritedAnonBoxStyle
(
style
)
;
}
return
style
.
forget
(
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolveStyleForText
(
nsIContent
*
aTextNode
ComputedStyle
*
aParentStyle
)
{
MOZ_ASSERT
(
aTextNode
&
&
aTextNode
-
>
IsText
(
)
)
;
MOZ_ASSERT
(
aTextNode
-
>
GetParent
(
)
)
;
MOZ_ASSERT
(
aParentStyle
)
;
return
ResolveStyleForTextOrFirstLetterContinuation
(
mRawSet
.
get
(
)
*
aParentStyle
PseudoStyleType
:
:
mozText
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolveStyleForFirstLetterContinuation
(
ComputedStyle
*
aParentStyle
)
{
MOZ_ASSERT
(
aParentStyle
)
;
return
ResolveStyleForTextOrFirstLetterContinuation
(
mRawSet
.
get
(
)
*
aParentStyle
PseudoStyleType
:
:
firstLetterContinuation
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolveStyleForPlaceholder
(
)
{
RefPtr
<
ComputedStyle
>
&
cache
=
mNonInheritingComputedStyles
[
nsCSSAnonBoxes
:
:
NonInheriting
:
:
oofPlaceholder
]
;
if
(
cache
)
{
RefPtr
<
ComputedStyle
>
retval
=
cache
;
return
retval
.
forget
(
)
;
}
RefPtr
<
ComputedStyle
>
computedValues
=
Servo_ComputedValues_Inherit
(
mRawSet
.
get
(
)
PseudoStyleType
:
:
oofPlaceholder
nullptr
InheritTarget
:
:
PlaceholderFrame
)
.
Consume
(
)
;
MOZ_ASSERT
(
computedValues
)
;
cache
=
computedValues
;
return
computedValues
.
forget
(
)
;
}
static
inline
bool
LazyPseudoIsCacheable
(
PseudoStyleType
aType
const
Element
&
aOriginatingElement
ComputedStyle
*
aParentStyle
)
{
return
aParentStyle
&
&
!
nsCSSPseudoElements
:
:
IsEagerlyCascadedInServo
(
aType
)
&
&
aOriginatingElement
.
HasServoData
(
)
&
&
!
Servo_Element_IsPrimaryStyleReusedViaRuleNode
(
&
aOriginatingElement
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolvePseudoElementStyle
(
const
Element
&
aOriginatingElement
PseudoStyleType
aType
ComputedStyle
*
aParentStyle
IsProbe
aIsProbe
)
{
UpdateStylistIfNeeded
(
)
;
MOZ_ASSERT
(
PseudoStyle
:
:
IsPseudoElement
(
aType
)
)
;
const
bool
cacheable
=
LazyPseudoIsCacheable
(
aType
aOriginatingElement
aParentStyle
)
;
RefPtr
<
ComputedStyle
>
style
=
cacheable
?
aParentStyle
-
>
GetCachedLazyPseudoStyle
(
aType
)
:
nullptr
;
const
bool
isProbe
=
aIsProbe
=
=
IsProbe
:
:
Yes
;
if
(
!
style
)
{
style
=
Servo_ResolvePseudoStyle
(
&
aOriginatingElement
aType
isProbe
isProbe
?
nullptr
:
aParentStyle
mRawSet
.
get
(
)
)
.
Consume
(
)
;
if
(
!
style
)
{
MOZ_ASSERT
(
isProbe
)
;
return
nullptr
;
}
if
(
cacheable
)
{
aParentStyle
-
>
SetCachedLazyPseudoStyle
(
style
)
;
}
}
MOZ_ASSERT
(
style
)
;
if
(
isProbe
&
&
!
GeneratedContentPseudoExists
(
*
aParentStyle
*
style
)
)
{
return
nullptr
;
}
return
style
.
forget
(
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolveInheritingAnonymousBoxStyle
(
PseudoStyleType
aType
ComputedStyle
*
aParentStyle
)
{
MOZ_ASSERT
(
PseudoStyle
:
:
IsInheritingAnonBox
(
aType
)
)
;
MOZ_ASSERT_IF
(
aParentStyle
!
StylistNeedsUpdate
(
)
)
;
UpdateStylistIfNeeded
(
)
;
RefPtr
<
ComputedStyle
>
style
=
nullptr
;
if
(
aParentStyle
)
{
style
=
aParentStyle
-
>
GetCachedInheritingAnonBoxStyle
(
aType
)
;
}
if
(
!
style
)
{
style
=
Servo_ComputedValues_GetForAnonymousBox
(
aParentStyle
aType
mRawSet
.
get
(
)
)
.
Consume
(
)
;
MOZ_ASSERT
(
style
)
;
if
(
aParentStyle
)
{
aParentStyle
-
>
SetCachedInheritedAnonBoxStyle
(
style
)
;
}
}
return
style
.
forget
(
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolveNonInheritingAnonymousBoxStyle
(
PseudoStyleType
aType
)
{
MOZ_ASSERT
(
PseudoStyle
:
:
IsNonInheritingAnonBox
(
aType
)
)
;
MOZ_ASSERT
(
aType
!
=
PseudoStyleType
:
:
pageContent
"
If
pageContent
ends
up
non
-
inheriting
check
"
"
whether
we
need
to
do
anything
to
move
the
"
"
page
handling
from
ResolveInheritingAnonymousBoxStyle
to
"
"
ResolveNonInheritingAnonymousBoxStyle
"
)
;
nsCSSAnonBoxes
:
:
NonInheriting
type
=
nsCSSAnonBoxes
:
:
NonInheritingTypeForPseudoType
(
aType
)
;
RefPtr
<
ComputedStyle
>
&
cache
=
mNonInheritingComputedStyles
[
type
]
;
if
(
cache
)
{
RefPtr
<
ComputedStyle
>
retval
=
cache
;
return
retval
.
forget
(
)
;
}
UpdateStylistIfNeeded
(
)
;
MOZ_ASSERT
(
!
PseudoStyle
:
:
IsNonInheritingAnonBox
(
PseudoStyleType
:
:
viewport
)
"
viewport
needs
fixup
to
handle
blockifying
it
"
)
;
RefPtr
<
ComputedStyle
>
computedValues
=
Servo_ComputedValues_GetForAnonymousBox
(
nullptr
aType
mRawSet
.
get
(
)
)
.
Consume
(
)
;
MOZ_ASSERT
(
computedValues
)
;
cache
=
computedValues
;
return
computedValues
.
forget
(
)
;
}
#
ifdef
MOZ_XUL
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolveXULTreePseudoStyle
(
dom
:
:
Element
*
aParentElement
nsCSSAnonBoxPseudoStaticAtom
*
aPseudoTag
ComputedStyle
*
aParentStyle
const
AtomArray
&
aInputWord
)
{
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsTreePseudoElement
(
aPseudoTag
)
)
;
MOZ_ASSERT
(
aParentStyle
)
;
MOZ_ASSERT
(
!
StylistNeedsUpdate
(
)
)
;
return
Servo_ComputedValues_ResolveXULTreePseudoStyle
(
aParentElement
aPseudoTag
aParentStyle
&
aInputWord
mRawSet
.
get
(
)
)
.
Consume
(
)
;
}
#
endif
void
ServoStyleSet
:
:
AppendStyleSheet
(
StyleOrigin
aOrigin
StyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
MOZ_ASSERT
(
aSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
aSheet
-
>
RawContents
(
)
"
Raw
sheet
should
be
in
place
before
insertion
.
"
)
;
aSheet
-
>
AddStyleSet
(
this
)
;
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
aSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
SheetAdded
(
*
aSheet
)
;
}
}
void
ServoStyleSet
:
:
RemoveStyleSheet
(
StyleOrigin
aOrigin
StyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
aSheet
-
>
DropStyleSet
(
this
)
;
Servo_StyleSet_RemoveStyleSheet
(
mRawSet
.
get
(
)
aSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
SheetRemoved
(
*
aSheet
)
;
}
}
void
ServoStyleSet
:
:
InsertStyleSheetBefore
(
Origin
aOrigin
StyleSheet
*
aNewSheet
StyleSheet
*
aReferenceSheet
)
{
MOZ_ASSERT
(
aNewSheet
)
;
MOZ_ASSERT
(
aReferenceSheet
)
;
MOZ_ASSERT
(
aNewSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
aNewSheet
!
=
aReferenceSheet
"
Can
'
t
place
sheet
before
itself
.
"
)
;
MOZ_ASSERT
(
aNewSheet
-
>
RawContents
(
)
"
Raw
sheet
should
be
in
place
before
insertion
.
"
)
;
MOZ_ASSERT
(
aReferenceSheet
-
>
RawContents
(
)
"
Reference
sheet
should
have
a
raw
sheet
.
"
)
;
aNewSheet
-
>
AddStyleSet
(
this
)
;
Servo_StyleSet_InsertStyleSheetBefore
(
mRawSet
.
get
(
)
aNewSheet
aReferenceSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
SheetAdded
(
*
aNewSheet
)
;
}
}
size_t
ServoStyleSet
:
:
SheetCount
(
Origin
aOrigin
)
const
{
return
Servo_StyleSet_GetSheetCount
(
mRawSet
.
get
(
)
aOrigin
)
;
}
StyleSheet
*
ServoStyleSet
:
:
SheetAt
(
Origin
aOrigin
size_t
aIndex
)
const
{
return
const_cast
<
StyleSheet
*
>
(
Servo_StyleSet_GetSheetAt
(
mRawSet
.
get
(
)
aOrigin
aIndex
)
)
;
}
void
ServoStyleSet
:
:
AppendAllNonDocumentAuthorSheets
(
nsTArray
<
StyleSheet
*
>
&
aArray
)
const
{
EnumerateShadowRoots
(
*
mDocument
[
&
]
(
ShadowRoot
&
aShadowRoot
)
{
for
(
auto
index
:
IntegerRange
(
aShadowRoot
.
SheetCount
(
)
)
)
{
aArray
.
AppendElement
(
aShadowRoot
.
SheetAt
(
index
)
)
;
}
}
)
;
}
void
ServoStyleSet
:
:
AddDocStyleSheet
(
StyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
aSheet
-
>
RawContents
(
)
"
Raw
sheet
should
be
in
place
by
this
point
.
"
)
;
RefPtr
<
StyleSheet
>
strong
(
aSheet
)
;
size_t
index
=
mDocument
-
>
FindDocStyleSheetInsertionPoint
(
*
aSheet
)
;
aSheet
-
>
AddStyleSet
(
this
)
;
if
(
index
<
SheetCount
(
Origin
:
:
Author
)
)
{
StyleSheet
*
beforeSheet
=
SheetAt
(
Origin
:
:
Author
index
)
;
Servo_StyleSet_InsertStyleSheetBefore
(
mRawSet
.
get
(
)
aSheet
beforeSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
}
else
{
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
aSheet
)
;
SetStylistStyleSheetsDirty
(
)
;
}
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
SheetAdded
(
*
aSheet
)
;
}
}
bool
ServoStyleSet
:
:
GeneratedContentPseudoExists
(
const
ComputedStyle
&
aParentStyle
const
ComputedStyle
&
aPseudoStyle
)
{
auto
type
=
aPseudoStyle
.
GetPseudoType
(
)
;
MOZ_ASSERT
(
type
!
=
PseudoStyleType
:
:
NotPseudo
)
;
if
(
type
=
=
PseudoStyleType
:
:
marker
)
{
if
(
!
aParentStyle
.
StyleDisplay
(
)
-
>
IsListItem
(
)
)
{
return
false
;
}
if
(
aPseudoStyle
.
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
{
return
false
;
}
}
if
(
type
=
=
PseudoStyleType
:
:
before
|
|
type
=
=
PseudoStyleType
:
:
after
)
{
if
(
aPseudoStyle
.
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
{
return
false
;
}
if
(
!
aPseudoStyle
.
StyleContent
(
)
-
>
ContentCount
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
ServoStyleSet
:
:
StyleDocument
(
ServoTraversalFlags
aFlags
)
{
AUTO_PROFILER_LABEL_CATEGORY_PAIR
(
LAYOUT_StyleComputation
)
;
MOZ_ASSERT
(
GetPresContext
(
)
"
Styling
a
document
without
a
shell
?
"
)
;
if
(
!
mDocument
-
>
GetServoRestyleRoot
(
)
)
{
return
false
;
}
PreTraverse
(
aFlags
)
;
AutoPrepareTraversal
guard
(
this
)
;
const
SnapshotTable
&
snapshots
=
Snapshots
(
)
;
bool
postTraversalRequired
=
false
;
Element
*
rootElement
=
mDocument
-
>
GetRootElement
(
)
;
MOZ_ASSERT_IF
(
rootElement
rootElement
-
>
HasServoData
(
)
)
;
if
(
ShouldTraverseInParallel
(
)
)
{
aFlags
|
=
ServoTraversalFlags
:
:
ParallelTraversal
;
}
DocumentStyleRootIterator
iter
(
mDocument
-
>
GetServoRestyleRoot
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
MOZ_ASSERT
(
MayTraverseFrom
(
root
)
)
;
Element
*
parent
=
root
-
>
GetFlattenedTreeParentElementForStyle
(
)
;
MOZ_ASSERT_IF
(
parent
!
parent
-
>
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
)
)
;
postTraversalRequired
|
=
Servo_TraverseSubtree
(
root
mRawSet
.
get
(
)
&
snapshots
aFlags
)
;
postTraversalRequired
|
=
root
-
>
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
|
NODE_NEEDS_FRAME
)
;
if
(
parent
)
{
MOZ_ASSERT
(
root
=
=
mDocument
-
>
GetServoRestyleRoot
(
)
)
;
if
(
parent
-
>
HasDirtyDescendantsForServo
(
)
)
{
uint32_t
existingBits
=
mDocument
-
>
GetServoRestyleRootDirtyBits
(
)
;
parent
-
>
SetFlags
(
existingBits
)
;
mDocument
-
>
SetServoRestyleRoot
(
parent
existingBits
|
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
)
;
postTraversalRequired
=
true
;
}
}
}
if
(
GetPresContext
(
)
-
>
EffectCompositor
(
)
-
>
PreTraverse
(
aFlags
)
)
{
nsINode
*
styleRoot
=
mDocument
-
>
GetServoRestyleRoot
(
)
;
Element
*
root
=
styleRoot
-
>
IsElement
(
)
?
styleRoot
-
>
AsElement
(
)
:
rootElement
;
postTraversalRequired
|
=
Servo_TraverseSubtree
(
root
mRawSet
.
get
(
)
&
snapshots
aFlags
)
;
postTraversalRequired
|
=
root
-
>
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
|
NODE_NEEDS_FRAME
)
;
}
return
postTraversalRequired
;
}
void
ServoStyleSet
:
:
StyleNewSubtree
(
Element
*
aRoot
)
{
MOZ_ASSERT
(
GetPresContext
(
)
)
;
MOZ_ASSERT
(
!
aRoot
-
>
HasServoData
(
)
)
;
MOZ_ASSERT
(
aRoot
-
>
GetFlattenedTreeParentNodeForStyle
(
)
"
Not
in
the
flat
tree
?
Fishy
!
"
)
;
PreTraverseSync
(
)
;
AutoPrepareTraversal
guard
(
this
)
;
const
SnapshotTable
&
snapshots
=
Snapshots
(
)
;
auto
flags
=
ServoTraversalFlags
:
:
Empty
;
if
(
ShouldTraverseInParallel
(
)
)
{
flags
|
=
ServoTraversalFlags
:
:
ParallelTraversal
;
}
DebugOnly
<
bool
>
postTraversalRequired
=
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
flags
)
;
MOZ_ASSERT
(
!
postTraversalRequired
)
;
if
(
GetPresContext
(
)
-
>
EffectCompositor
(
)
-
>
PreTraverseInSubtree
(
flags
aRoot
)
)
{
postTraversalRequired
=
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
ServoTraversalFlags
:
:
AnimationOnly
|
ServoTraversalFlags
:
:
FinalAnimationTraversal
)
;
MOZ_ASSERT
(
!
postTraversalRequired
)
;
}
}
void
ServoStyleSet
:
:
MarkOriginsDirty
(
OriginFlags
aChangedOrigins
)
{
SetStylistStyleSheetsDirty
(
)
;
Servo_StyleSet_NoteStyleSheetsChanged
(
mRawSet
.
get
(
)
aChangedOrigins
)
;
}
void
ServoStyleSet
:
:
SetStylistStyleSheetsDirty
(
)
{
mStylistState
|
=
StylistState
:
:
StyleSheetsDirty
;
if
(
nsPresContext
*
presContext
=
GetPresContext
(
)
)
{
presContext
-
>
RestyleManager
(
)
-
>
IncrementUndisplayedRestyleGeneration
(
)
;
}
}
void
ServoStyleSet
:
:
SetStylistShadowDOMStyleSheetsDirty
(
)
{
mStylistState
|
=
StylistState
:
:
ShadowDOMStyleSheetsDirty
;
if
(
nsPresContext
*
presContext
=
GetPresContext
(
)
)
{
presContext
-
>
RestyleManager
(
)
-
>
IncrementUndisplayedRestyleGeneration
(
)
;
}
}
static
OriginFlags
ToOriginFlags
(
StyleOrigin
aOrigin
)
{
switch
(
aOrigin
)
{
case
StyleOrigin
:
:
UserAgent
:
return
OriginFlags
:
:
UserAgent
;
case
StyleOrigin
:
:
User
:
return
OriginFlags
:
:
User
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unknown
origin
?
"
)
;
case
StyleOrigin
:
:
Author
:
return
OriginFlags
:
:
Author
;
}
}
void
ServoStyleSet
:
:
ImportRuleLoaded
(
dom
:
:
CSSImportRule
&
StyleSheet
&
aSheet
)
{
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
SheetAdded
(
aSheet
)
;
}
if
(
!
aSheet
.
IsApplicable
(
)
)
{
return
;
}
MarkOriginsDirty
(
ToOriginFlags
(
aSheet
.
GetOrigin
(
)
)
)
;
}
void
ServoStyleSet
:
:
RuleAdded
(
StyleSheet
&
aSheet
css
:
:
Rule
&
aRule
)
{
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
RuleAdded
(
aSheet
aRule
)
;
}
if
(
!
aSheet
.
IsApplicable
(
)
|
|
aRule
.
IsIncompleteImportRule
(
)
)
{
return
;
}
MarkOriginsDirty
(
ToOriginFlags
(
aSheet
.
GetOrigin
(
)
)
)
;
}
void
ServoStyleSet
:
:
RuleRemoved
(
StyleSheet
&
aSheet
css
:
:
Rule
&
aRule
)
{
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
RuleRemoved
(
aSheet
aRule
)
;
}
if
(
!
aSheet
.
IsApplicable
(
)
)
{
return
;
}
MarkOriginsDirty
(
ToOriginFlags
(
aSheet
.
GetOrigin
(
)
)
)
;
}
void
ServoStyleSet
:
:
RuleChanged
(
StyleSheet
&
aSheet
css
:
:
Rule
*
aRule
)
{
if
(
!
aSheet
.
IsApplicable
(
)
)
{
return
;
}
MarkOriginsDirty
(
ToOriginFlags
(
aSheet
.
GetOrigin
(
)
)
)
;
}
#
ifdef
DEBUG
void
ServoStyleSet
:
:
AssertTreeIsClean
(
)
{
DocumentStyleRootIterator
iter
(
mDocument
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
Servo_AssertTreeIsClean
(
root
)
;
}
}
#
endif
bool
ServoStyleSet
:
:
GetKeyframesForName
(
const
Element
&
aElement
const
ComputedStyle
&
aStyle
nsAtom
*
aName
const
nsTimingFunction
&
aTimingFunction
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
MOZ_ASSERT
(
!
StylistNeedsUpdate
(
)
)
;
return
Servo_StyleSet_GetKeyframesForName
(
mRawSet
.
get
(
)
&
aElement
&
aStyle
aName
&
aTimingFunction
&
aKeyframes
)
;
}
nsTArray
<
ComputedKeyframeValues
>
ServoStyleSet
:
:
GetComputedKeyframeValuesFor
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
Element
*
aElement
const
ComputedStyle
*
aStyle
)
{
nsTArray
<
ComputedKeyframeValues
>
result
(
aKeyframes
.
Length
(
)
)
;
result
.
AppendElements
(
aKeyframes
.
Length
(
)
)
;
Servo_GetComputedKeyframeValues
(
&
aKeyframes
aElement
aStyle
mRawSet
.
get
(
)
&
result
)
;
return
result
;
}
void
ServoStyleSet
:
:
GetAnimationValues
(
RawServoDeclarationBlock
*
aDeclarations
Element
*
aElement
const
ComputedStyle
*
aComputedStyle
nsTArray
<
RefPtr
<
RawServoAnimationValue
>
>
&
aAnimationValues
)
{
Servo_GetAnimationValues
(
aDeclarations
aElement
aComputedStyle
mRawSet
.
get
(
)
&
aAnimationValues
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
GetBaseContextForElement
(
Element
*
aElement
const
ComputedStyle
*
aStyle
)
{
return
Servo_StyleSet_GetBaseComputedValuesForElement
(
mRawSet
.
get
(
)
aElement
aStyle
&
Snapshots
(
)
)
.
Consume
(
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolveServoStyleByAddingAnimation
(
Element
*
aElement
const
ComputedStyle
*
aStyle
RawServoAnimationValue
*
aAnimationValue
)
{
return
Servo_StyleSet_GetComputedValuesByAddingAnimation
(
mRawSet
.
get
(
)
aElement
aStyle
&
Snapshots
(
)
aAnimationValue
)
.
Consume
(
)
;
}
already_AddRefed
<
RawServoAnimationValue
>
ServoStyleSet
:
:
ComputeAnimationValue
(
Element
*
aElement
RawServoDeclarationBlock
*
aDeclarations
const
ComputedStyle
*
aStyle
)
{
return
Servo_AnimationValue_Compute
(
aElement
aDeclarations
aStyle
mRawSet
.
get
(
)
)
.
Consume
(
)
;
}
bool
ServoStyleSet
:
:
EnsureUniqueInnerOnCSSSheets
(
)
{
using
SheetOwner
=
Variant
<
ServoStyleSet
*
ShadowRoot
*
>
;
AutoTArray
<
Pair
<
StyleSheet
*
SheetOwner
>
32
>
queue
;
EnumerateStyleSheets
(
[
&
]
(
StyleSheet
&
aSheet
)
{
queue
.
AppendElement
(
MakePair
(
&
aSheet
SheetOwner
{
this
}
)
)
;
}
)
;
EnumerateShadowRoots
(
*
mDocument
[
&
]
(
ShadowRoot
&
aShadowRoot
)
{
for
(
auto
index
:
IntegerRange
(
aShadowRoot
.
SheetCount
(
)
)
)
{
queue
.
AppendElement
(
MakePair
(
aShadowRoot
.
SheetAt
(
index
)
SheetOwner
{
&
aShadowRoot
}
)
)
;
}
}
)
;
while
(
!
queue
.
IsEmpty
(
)
)
{
uint32_t
idx
=
queue
.
Length
(
)
-
1
;
auto
*
sheet
=
queue
[
idx
]
.
first
(
)
;
SheetOwner
owner
=
queue
[
idx
]
.
second
(
)
;
queue
.
RemoveElementAt
(
idx
)
;
if
(
sheet
-
>
IsComplete
(
)
)
{
sheet
-
>
EnsureUniqueInner
(
)
;
}
for
(
StyleSheet
*
child
:
sheet
-
>
ChildSheets
(
)
)
{
queue
.
AppendElement
(
MakePair
(
child
owner
)
)
;
}
}
if
(
mNeedsRestyleAfterEnsureUniqueInner
)
{
MarkOriginsDirty
(
OriginFlags
:
:
All
)
;
ForceDirtyAllShadowStyles
(
)
;
}
bool
res
=
mNeedsRestyleAfterEnsureUniqueInner
;
mNeedsRestyleAfterEnsureUniqueInner
=
false
;
return
res
;
}
void
ServoStyleSet
:
:
ClearCachedStyleData
(
)
{
ClearNonInheritingComputedStyles
(
)
;
Servo_StyleSet_RebuildCachedData
(
mRawSet
.
get
(
)
)
;
mCachedAnonymousContentStyles
.
Clear
(
)
;
PodArrayZero
(
mCachedAnonymousContentStyleIndexes
)
;
}
void
ServoStyleSet
:
:
ForceDirtyAllShadowStyles
(
)
{
bool
anyShadow
=
false
;
EnumerateShadowRoots
(
*
mDocument
[
&
]
(
ShadowRoot
&
aShadowRoot
)
{
if
(
auto
*
authorStyles
=
aShadowRoot
.
GetServoStyles
(
)
)
{
anyShadow
=
true
;
Servo_AuthorStyles_ForceDirty
(
authorStyles
)
;
}
}
)
;
if
(
anyShadow
)
{
SetStylistShadowDOMStyleSheetsDirty
(
)
;
}
}
void
ServoStyleSet
:
:
CompatibilityModeChanged
(
)
{
Servo_StyleSet_CompatModeChanged
(
mRawSet
.
get
(
)
)
;
SetStylistStyleSheetsDirty
(
)
;
ForceDirtyAllShadowStyles
(
)
;
}
void
ServoStyleSet
:
:
ClearNonInheritingComputedStyles
(
)
{
for
(
RefPtr
<
ComputedStyle
>
&
ptr
:
mNonInheritingComputedStyles
)
{
ptr
=
nullptr
;
}
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolveStyleLazily
(
Element
&
aElement
PseudoStyleType
aPseudoType
StyleRuleInclusion
aRuleInclusion
)
{
PreTraverseSync
(
)
;
MOZ_ASSERT
(
GetPresContext
(
)
"
For
now
no
style
resolution
without
a
pres
context
"
)
;
MOZ_ASSERT
(
!
StylistNeedsUpdate
(
)
)
;
AutoSetInServoTraversal
guard
(
this
)
;
Element
*
elementForStyleResolution
=
&
aElement
;
PseudoStyleType
pseudoTypeForStyleResolution
=
aPseudoType
;
if
(
aPseudoType
=
=
PseudoStyleType
:
:
before
)
{
if
(
Element
*
pseudo
=
nsLayoutUtils
:
:
GetBeforePseudo
(
&
aElement
)
)
{
elementForStyleResolution
=
pseudo
;
pseudoTypeForStyleResolution
=
PseudoStyleType
:
:
NotPseudo
;
}
}
else
if
(
aPseudoType
=
=
PseudoStyleType
:
:
after
)
{
if
(
Element
*
pseudo
=
nsLayoutUtils
:
:
GetAfterPseudo
(
&
aElement
)
)
{
elementForStyleResolution
=
pseudo
;
pseudoTypeForStyleResolution
=
PseudoStyleType
:
:
NotPseudo
;
}
}
else
if
(
aPseudoType
=
=
PseudoStyleType
:
:
marker
)
{
if
(
Element
*
pseudo
=
nsLayoutUtils
:
:
GetMarkerPseudo
(
&
aElement
)
)
{
elementForStyleResolution
=
pseudo
;
pseudoTypeForStyleResolution
=
PseudoStyleType
:
:
NotPseudo
;
}
}
return
Servo_ResolveStyleLazily
(
elementForStyleResolution
pseudoTypeForStyleResolution
aRuleInclusion
&
Snapshots
(
)
mRawSet
.
get
(
)
)
.
Consume
(
)
;
}
void
ServoStyleSet
:
:
AppendFontFaceRules
(
nsTArray
<
nsFontFaceRuleContainer
>
&
aArray
)
{
UpdateStylistIfNeeded
(
)
;
Servo_StyleSet_GetFontFaceRules
(
mRawSet
.
get
(
)
&
aArray
)
;
}
const
RawServoCounterStyleRule
*
ServoStyleSet
:
:
CounterStyleRuleForName
(
nsAtom
*
aName
)
{
MOZ_ASSERT
(
!
StylistNeedsUpdate
(
)
)
;
return
Servo_StyleSet_GetCounterStyleRule
(
mRawSet
.
get
(
)
aName
)
;
}
already_AddRefed
<
gfxFontFeatureValueSet
>
ServoStyleSet
:
:
BuildFontFeatureValueSet
(
)
{
MOZ_ASSERT
(
!
StylistNeedsUpdate
(
)
)
;
RefPtr
<
gfxFontFeatureValueSet
>
set
=
Servo_StyleSet_BuildFontFeatureValueSet
(
mRawSet
.
get
(
)
)
;
return
set
.
forget
(
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ResolveForDeclarations
(
const
ComputedStyle
*
aParentOrNull
const
RawServoDeclarationBlock
*
aDeclarations
)
{
return
Servo_StyleSet_ResolveForDeclarations
(
mRawSet
.
get
(
)
aParentOrNull
aDeclarations
)
.
Consume
(
)
;
}
void
ServoStyleSet
:
:
UpdateStylist
(
)
{
MOZ_ASSERT
(
StylistNeedsUpdate
(
)
)
;
if
(
mStylistState
&
StylistState
:
:
StyleSheetsDirty
)
{
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
const
ServoElementSnapshotTable
*
snapshots
=
nullptr
;
if
(
nsPresContext
*
pc
=
GetPresContext
(
)
)
{
snapshots
=
&
pc
-
>
RestyleManager
(
)
-
>
Snapshots
(
)
;
}
Servo_StyleSet_FlushStyleSheets
(
mRawSet
.
get
(
)
root
snapshots
)
;
}
if
(
MOZ_UNLIKELY
(
mStylistState
&
StylistState
:
:
ShadowDOMStyleSheetsDirty
)
)
{
EnumerateShadowRoots
(
*
mDocument
[
&
]
(
ShadowRoot
&
aShadowRoot
)
{
if
(
auto
*
authorStyles
=
aShadowRoot
.
GetServoStyles
(
)
)
{
Servo_AuthorStyles_Flush
(
authorStyles
mRawSet
.
get
(
)
)
;
}
}
)
;
}
mStylistState
=
StylistState
:
:
NotDirty
;
}
void
ServoStyleSet
:
:
MaybeGCRuleTree
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Servo_MaybeGCRuleTree
(
mRawSet
.
get
(
)
)
;
}
bool
ServoStyleSet
:
:
MayTraverseFrom
(
const
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
)
;
nsINode
*
parent
=
aElement
-
>
GetFlattenedTreeParentNodeForStyle
(
)
;
if
(
!
parent
)
{
return
false
;
}
if
(
!
parent
-
>
IsElement
(
)
)
{
MOZ_ASSERT
(
parent
-
>
IsDocument
(
)
)
;
return
true
;
}
if
(
!
parent
-
>
AsElement
(
)
-
>
HasServoData
(
)
)
{
return
false
;
}
return
!
Servo_Element_IsDisplayNone
(
parent
-
>
AsElement
(
)
)
;
}
bool
ServoStyleSet
:
:
ShouldTraverseInParallel
(
)
const
{
MOZ_ASSERT
(
mDocument
-
>
GetPresShell
(
)
"
Styling
a
document
without
a
shell
?
"
)
;
if
(
!
mDocument
-
>
GetPresShell
(
)
-
>
IsActive
(
)
)
{
return
false
;
}
#
ifdef
MOZ_GECKO_PROFILER
if
(
profiler_feature_active
(
ProfilerFeature
:
:
SequentialStyle
)
)
{
return
false
;
}
#
endif
return
true
;
}
void
ServoStyleSet
:
:
RunPostTraversalTasks
(
)
{
MOZ_ASSERT
(
!
IsInServoTraversal
(
)
)
;
if
(
mPostTraversalTasks
.
IsEmpty
(
)
)
{
return
;
}
nsTArray
<
PostTraversalTask
>
tasks
;
tasks
.
SwapElements
(
mPostTraversalTasks
)
;
for
(
auto
&
task
:
tasks
)
{
task
.
Run
(
)
;
}
}
ServoStyleRuleMap
*
ServoStyleSet
:
:
StyleRuleMap
(
)
{
if
(
!
mStyleRuleMap
)
{
mStyleRuleMap
=
MakeUnique
<
ServoStyleRuleMap
>
(
)
;
}
mStyleRuleMap
-
>
EnsureTable
(
*
this
)
;
return
mStyleRuleMap
.
get
(
)
;
}
bool
ServoStyleSet
:
:
MightHaveAttributeDependency
(
const
Element
&
aElement
nsAtom
*
aAttribute
)
const
{
return
Servo_StyleSet_MightHaveAttributeDependency
(
mRawSet
.
get
(
)
&
aElement
aAttribute
)
;
}
bool
ServoStyleSet
:
:
HasStateDependency
(
const
Element
&
aElement
EventStates
aState
)
const
{
return
Servo_StyleSet_HasStateDependency
(
mRawSet
.
get
(
)
&
aElement
aState
.
ServoValue
(
)
)
;
}
bool
ServoStyleSet
:
:
HasDocumentStateDependency
(
EventStates
aState
)
const
{
return
Servo_StyleSet_HasDocumentStateDependency
(
mRawSet
.
get
(
)
aState
.
ServoValue
(
)
)
;
}
already_AddRefed
<
ComputedStyle
>
ServoStyleSet
:
:
ReparentComputedStyle
(
ComputedStyle
*
aComputedStyle
ComputedStyle
*
aNewParent
ComputedStyle
*
aNewParentIgnoringFirstLine
ComputedStyle
*
aNewLayoutParent
Element
*
aElement
)
{
return
Servo_ReparentStyle
(
aComputedStyle
aNewParent
aNewParentIgnoringFirstLine
aNewLayoutParent
aElement
mRawSet
.
get
(
)
)
.
Consume
(
)
;
}
NS_IMPL_ISUPPORTS
(
UACacheReporter
nsIMemoryReporter
)
MOZ_DEFINE_MALLOC_SIZE_OF
(
ServoUACacheMallocSizeOf
)
MOZ_DEFINE_MALLOC_ENCLOSING_SIZE_OF
(
ServoUACacheMallocEnclosingSizeOf
)
NS_IMETHODIMP
UACacheReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
ServoStyleSetSizes
sizes
;
Servo_UACache_AddSizeOf
(
ServoUACacheMallocSizeOf
ServoUACacheMallocEnclosingSizeOf
&
sizes
)
;
#
define
REPORT
(
_path
_amount
_desc
)
\
do
{
\
size_t
__amount
=
_amount
;
/
*
evaluate
_amount
only
once
*
/
\
if
(
__amount
>
0
)
{
\
MOZ_COLLECT_REPORT
(
_path
KIND_HEAP
UNITS_BYTES
__amount
_desc
)
;
\
}
\
}
while
(
0
)
MOZ_RELEASE_ASSERT
(
sizes
.
mRuleTree
=
=
0
)
;
REPORT
(
"
explicit
/
layout
/
servo
-
ua
-
cache
/
precomputed
-
pseudos
"
sizes
.
mPrecomputedPseudos
"
Memory
used
by
precomputed
pseudo
-
element
declarations
within
the
"
"
UA
cache
.
"
)
;
REPORT
(
"
explicit
/
layout
/
servo
-
ua
-
cache
/
element
-
and
-
pseudos
-
maps
"
sizes
.
mElementAndPseudosMaps
"
Memory
used
by
element
and
pseudos
maps
within
the
UA
cache
.
"
)
;
REPORT
(
"
explicit
/
layout
/
servo
-
ua
-
cache
/
invalidation
-
map
"
sizes
.
mInvalidationMap
"
Memory
used
by
invalidation
maps
within
the
UA
cache
.
"
)
;
REPORT
(
"
explicit
/
layout
/
servo
-
ua
-
cache
/
revalidation
-
selectors
"
sizes
.
mRevalidationSelectors
"
Memory
used
by
selectors
for
cache
revalidation
within
the
UA
"
"
cache
.
"
)
;
REPORT
(
"
explicit
/
layout
/
servo
-
ua
-
cache
/
other
"
sizes
.
mOther
"
Memory
used
by
other
data
within
the
UA
cache
"
)
;
return
NS_OK
;
}
}
