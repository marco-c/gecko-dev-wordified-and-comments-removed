#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
gfxPlatformFontList
.
h
"
#
include
"
mozilla
/
DocumentStyleRootIterator
.
h
"
#
include
"
mozilla
/
ServoRestyleManager
.
h
"
#
include
"
mozilla
/
dom
/
AnonymousContent
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
RestyleManagerInlines
.
h
"
#
include
"
mozilla
/
ServoComputedValuesWithParent
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSRuleProcessor
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsHTMLStyleSheet
.
h
"
#
include
"
nsIDocumentInlines
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsSMILAnimationController
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsStyleSet
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
inline
uint64_t
UniqueIDForSheet
(
ServoStyleSheet
*
aSheet
)
{
return
reinterpret_cast
<
uint64_t
>
(
aSheet
)
;
}
ServoStyleSet
:
:
ServoStyleSet
(
)
:
mPresContext
(
nullptr
)
mAllowResolveStaleStyles
(
false
)
mAuthorStyleDisabled
(
false
)
mStylistState
(
StylistState
:
:
NotDirty
)
mNeedsRestyleAfterEnsureUniqueInner
(
false
)
{
}
ServoStyleSet
:
:
~
ServoStyleSet
(
)
{
for
(
auto
&
sheetArray
:
mSheets
)
{
for
(
auto
&
sheet
:
sheetArray
)
{
sheet
-
>
DropStyleSet
(
this
)
;
}
}
}
void
ServoStyleSet
:
:
Init
(
nsPresContext
*
aPresContext
)
{
mPresContext
=
aPresContext
;
mRawSet
.
reset
(
Servo_StyleSet_Init
(
aPresContext
)
)
;
mPresContext
-
>
DeviceContext
(
)
-
>
InitFontCache
(
)
;
for
(
auto
&
sheetArray
:
mSheets
)
{
for
(
auto
&
sheet
:
sheetArray
)
{
MOZ_ASSERT
(
sheet
-
>
RawSheet
(
)
"
We
should
only
append
non
-
null
raw
sheets
.
"
)
;
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
sheet
-
>
RawSheet
(
)
UniqueIDForSheet
(
sheet
)
)
;
}
}
}
void
ServoStyleSet
:
:
BeginShutdown
(
)
{
nsIDocument
*
doc
=
mPresContext
-
>
Document
(
)
;
DocumentStyleRootIterator
iter
(
doc
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
ServoRestyleManager
:
:
ClearServoDataFromSubtree
(
root
)
;
}
for
(
RefPtr
<
AnonymousContent
>
&
ac
:
doc
-
>
GetAnonymousContents
(
)
)
{
ServoRestyleManager
:
:
ClearServoDataFromSubtree
(
ac
-
>
GetContentNode
(
)
)
;
}
}
void
ServoStyleSet
:
:
Shutdown
(
)
{
ClearNonInheritingStyleContexts
(
)
;
mRawSet
=
nullptr
;
}
void
ServoStyleSet
:
:
InvalidateStyleForCSSRuleChanges
(
)
{
if
(
Element
*
root
=
mPresContext
-
>
Document
(
)
-
>
GetRootElement
(
)
)
{
mPresContext
-
>
RestyleManager
(
)
-
>
PostRestyleEventForCSSRuleChanges
(
root
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
}
}
size_t
ServoStyleSet
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
return
n
;
}
bool
ServoStyleSet
:
:
GetAuthorStyleDisabled
(
)
const
{
return
mAuthorStyleDisabled
;
}
nsresult
ServoStyleSet
:
:
SetAuthorStyleDisabled
(
bool
aStyleDisabled
)
{
if
(
mAuthorStyleDisabled
=
=
aStyleDisabled
)
{
return
NS_OK
;
}
mAuthorStyleDisabled
=
aStyleDisabled
;
if
(
mAuthorStyleDisabled
)
{
NoteStyleSheetsChanged
(
)
;
}
return
NS_OK
;
}
void
ServoStyleSet
:
:
BeginUpdate
(
)
{
}
nsresult
ServoStyleSet
:
:
EndUpdate
(
)
{
return
NS_OK
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
ResolveStyleFor
(
Element
*
aElement
nsStyleContext
*
aParentContext
LazyComputeBehavior
aMayCompute
)
{
return
GetContext
(
aElement
aParentContext
nullptr
CSSPseudoElementType
:
:
NotPseudo
aMayCompute
)
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
GetContext
(
nsIContent
*
aContent
nsStyleContext
*
aParentContext
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
LazyComputeBehavior
aMayCompute
)
{
MOZ_ASSERT
(
aContent
-
>
IsElement
(
)
)
;
Element
*
element
=
aContent
-
>
AsElement
(
)
;
RefPtr
<
ServoComputedValues
>
computedValues
;
if
(
aMayCompute
=
=
LazyComputeBehavior
:
:
Allow
)
{
PreTraverseSync
(
)
;
computedValues
=
ResolveStyleLazily
(
element
CSSPseudoElementType
:
:
NotPseudo
)
;
}
else
{
computedValues
=
ResolveServoStyle
(
element
)
;
}
MOZ_ASSERT
(
computedValues
)
;
return
GetContext
(
computedValues
.
forget
(
)
aParentContext
aPseudoTag
aPseudoType
element
)
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
GetContext
(
already_AddRefed
<
ServoComputedValues
>
aComputedValues
nsStyleContext
*
aParentContext
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
Element
*
aElementForAnimation
)
{
RefPtr
<
nsStyleContext
>
result
=
NS_NewStyleContext
(
aParentContext
mPresContext
aPseudoTag
aPseudoType
Move
(
aComputedValues
)
)
;
if
(
aElementForAnimation
&
&
aElementForAnimation
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
&
&
mPresContext
-
>
CompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
)
{
nsIDocument
*
doc
=
aElementForAnimation
-
>
GetUncomposedDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetBodyElement
(
)
=
=
aElementForAnimation
)
{
mPresContext
-
>
SetBodyTextColor
(
result
-
>
StyleColor
(
)
-
>
mColor
)
;
}
}
return
result
.
forget
(
)
;
}
const
ServoElementSnapshotTable
&
ServoStyleSet
:
:
Snapshots
(
)
{
return
mPresContext
-
>
RestyleManager
(
)
-
>
AsServo
(
)
-
>
Snapshots
(
)
;
}
void
ServoStyleSet
:
:
ResolveMappedAttrDeclarationBlocks
(
)
{
if
(
nsHTMLStyleSheet
*
sheet
=
mPresContext
-
>
Document
(
)
-
>
GetAttributeStyleSheet
(
)
)
{
sheet
-
>
CalculateMappedServoDeclarations
(
mPresContext
)
;
}
mPresContext
-
>
Document
(
)
-
>
ResolveScheduledSVGPresAttrs
(
)
;
}
void
ServoStyleSet
:
:
PreTraverseSync
(
)
{
ResolveMappedAttrDeclarationBlocks
(
)
;
nsCSSRuleProcessor
:
:
InitSystemMetrics
(
)
;
mPresContext
-
>
Document
(
)
-
>
GetDocumentState
(
)
;
mPresContext
-
>
Document
(
)
-
>
GetUserFontSet
(
)
;
UpdateStylistIfNeeded
(
)
;
mPresContext
-
>
CacheAllLangs
(
)
;
}
void
ServoStyleSet
:
:
PreTraverse
(
Element
*
aRoot
EffectCompositor
:
:
AnimationRestyleType
aRestyleType
)
{
PreTraverseSync
(
)
;
nsSMILAnimationController
*
smilController
=
mPresContext
-
>
Document
(
)
-
>
GetAnimationController
(
)
;
if
(
aRoot
)
{
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverseInSubtree
(
aRoot
aRestyleType
)
;
if
(
smilController
)
{
smilController
-
>
PreTraverseInSubtree
(
aRoot
)
;
}
}
else
{
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverse
(
aRestyleType
)
;
if
(
smilController
)
{
smilController
-
>
PreTraverse
(
)
;
}
}
}
bool
ServoStyleSet
:
:
PrepareAndTraverseSubtree
(
RawGeckoElementBorrowed
aRoot
TraversalRootBehavior
aRootBehavior
TraversalRestyleBehavior
aRestyleBehavior
)
{
mozilla
:
:
Unused
<
<
aRoot
-
>
OwnerDoc
(
)
-
>
GetRootElement
(
)
;
MOZ_ASSERT
(
!
StylistNeedsUpdate
(
)
)
;
AutoSetInServoTraversal
guard
(
this
)
;
const
SnapshotTable
&
snapshots
=
Snapshots
(
)
;
bool
isInitial
=
!
aRoot
-
>
HasServoData
(
)
;
bool
forReconstruct
=
aRestyleBehavior
=
=
TraversalRestyleBehavior
:
:
ForReconstruct
;
bool
forAnimationOnly
=
aRestyleBehavior
=
=
TraversalRestyleBehavior
:
:
ForAnimationOnly
;
bool
postTraversalRequired
=
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
aRootBehavior
aRestyleBehavior
)
;
MOZ_ASSERT_IF
(
isInitial
|
|
forReconstruct
!
postTraversalRequired
)
;
if
(
forAnimationOnly
)
{
return
postTraversalRequired
;
}
auto
root
=
const_cast
<
Element
*
>
(
aRoot
)
;
EffectCompositor
*
compositor
=
mPresContext
-
>
EffectCompositor
(
)
;
EffectCompositor
:
:
AnimationRestyleType
restyleType
=
EffectCompositor
:
:
AnimationRestyleType
:
:
Throttled
;
if
(
forReconstruct
?
compositor
-
>
PreTraverseInSubtree
(
root
restyleType
)
:
compositor
-
>
PreTraverse
(
restyleType
)
)
{
if
(
Servo_TraverseSubtree
(
aRoot
mRawSet
.
get
(
)
&
snapshots
aRootBehavior
aRestyleBehavior
)
)
{
MOZ_ASSERT
(
!
forReconstruct
)
;
if
(
isInitial
)
{
MOZ_ASSERT
(
!
postTraversalRequired
)
;
ServoRestyleManager
:
:
ClearRestyleStateFromSubtree
(
root
)
;
}
else
{
postTraversalRequired
=
true
;
}
}
}
return
postTraversalRequired
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
ResolveStyleForText
(
nsIContent
*
aTextNode
nsStyleContext
*
aParentContext
)
{
MOZ_ASSERT
(
aTextNode
&
&
aTextNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
MOZ_ASSERT
(
aTextNode
-
>
GetParent
(
)
)
;
MOZ_ASSERT
(
aParentContext
)
;
const
ServoComputedValues
*
parentComputedValues
=
aParentContext
-
>
StyleSource
(
)
.
AsServoComputedValues
(
)
;
RefPtr
<
ServoComputedValues
>
computedValues
=
Servo_ComputedValues_Inherit
(
mRawSet
.
get
(
)
parentComputedValues
InheritTarget
:
:
Text
)
.
Consume
(
)
;
return
GetContext
(
computedValues
.
forget
(
)
aParentContext
nsCSSAnonBoxes
:
:
mozText
CSSPseudoElementType
:
:
InheritingAnonBox
nullptr
)
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
ResolveStyleForFirstLetterContinuation
(
nsStyleContext
*
aParentContext
)
{
const
ServoComputedValues
*
parent
=
aParentContext
-
>
StyleSource
(
)
.
AsServoComputedValues
(
)
;
RefPtr
<
ServoComputedValues
>
computedValues
=
Servo_ComputedValues_Inherit
(
mRawSet
.
get
(
)
parent
InheritTarget
:
:
FirstLetterContinuation
)
.
Consume
(
)
;
MOZ_ASSERT
(
computedValues
)
;
return
GetContext
(
computedValues
.
forget
(
)
aParentContext
nsCSSAnonBoxes
:
:
firstLetterContinuation
CSSPseudoElementType
:
:
InheritingAnonBox
nullptr
)
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
ResolveStyleForPlaceholder
(
)
{
RefPtr
<
nsStyleContext
>
&
cache
=
mNonInheritingStyleContexts
[
nsCSSAnonBoxes
:
:
NonInheriting
:
:
oofPlaceholder
]
;
if
(
cache
)
{
RefPtr
<
nsStyleContext
>
retval
=
cache
;
return
retval
.
forget
(
)
;
}
RefPtr
<
ServoComputedValues
>
computedValues
=
Servo_ComputedValues_Inherit
(
mRawSet
.
get
(
)
nullptr
InheritTarget
:
:
PlaceholderFrame
)
.
Consume
(
)
;
MOZ_ASSERT
(
computedValues
)
;
RefPtr
<
nsStyleContext
>
retval
=
GetContext
(
computedValues
.
forget
(
)
nullptr
nsCSSAnonBoxes
:
:
oofPlaceholder
CSSPseudoElementType
:
:
NonInheritingAnonBox
nullptr
)
;
cache
=
retval
;
return
retval
.
forget
(
)
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
ResolvePseudoElementStyle
(
Element
*
aOriginatingElement
CSSPseudoElementType
aType
nsStyleContext
*
aParentContext
Element
*
aPseudoElement
)
{
UpdateStylistIfNeeded
(
)
;
MOZ_ASSERT
(
aType
<
CSSPseudoElementType
:
:
Count
)
;
RefPtr
<
ServoComputedValues
>
computedValues
;
if
(
aPseudoElement
)
{
MOZ_ASSERT
(
aType
=
=
aPseudoElement
-
>
GetPseudoElementType
(
)
)
;
computedValues
=
Servo_ResolveStyle
(
aPseudoElement
mRawSet
.
get
(
)
mAllowResolveStaleStyles
)
.
Consume
(
)
;
}
else
{
computedValues
=
Servo_ResolvePseudoStyle
(
aOriginatingElement
aType
false
mRawSet
.
get
(
)
)
.
Consume
(
)
;
}
MOZ_ASSERT
(
computedValues
)
;
bool
isBeforeOrAfter
=
aType
=
=
CSSPseudoElementType
:
:
before
|
|
aType
=
=
CSSPseudoElementType
:
:
after
;
nsIAtom
*
pseudoTag
=
nsCSSPseudoElements
:
:
GetPseudoAtom
(
aType
)
;
return
GetContext
(
computedValues
.
forget
(
)
aParentContext
pseudoTag
aType
isBeforeOrAfter
?
aOriginatingElement
:
nullptr
)
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
ResolveTransientStyle
(
Element
*
aElement
nsIAtom
*
aPseudoTag
CSSPseudoElementType
aPseudoType
StyleRuleInclusion
aRuleInclusion
)
{
RefPtr
<
ServoComputedValues
>
computedValues
=
ResolveTransientServoStyle
(
aElement
aPseudoType
aRuleInclusion
)
;
return
GetContext
(
computedValues
.
forget
(
)
nullptr
aPseudoTag
aPseudoType
nullptr
)
;
}
already_AddRefed
<
ServoComputedValues
>
ServoStyleSet
:
:
ResolveTransientServoStyle
(
Element
*
aElement
CSSPseudoElementType
aPseudoType
StyleRuleInclusion
aRuleInclusion
)
{
PreTraverseSync
(
)
;
return
ResolveStyleLazily
(
aElement
aPseudoType
aRuleInclusion
)
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
ResolveInheritingAnonymousBoxStyle
(
nsIAtom
*
aPseudoTag
nsStyleContext
*
aParentContext
)
{
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsAnonBox
(
aPseudoTag
)
&
&
!
nsCSSAnonBoxes
:
:
IsNonInheritingAnonBox
(
aPseudoTag
)
)
;
UpdateStylistIfNeeded
(
)
;
bool
skipFixup
=
nsCSSAnonBoxes
:
:
AnonBoxSkipsParentDisplayBasedStyleFixup
(
aPseudoTag
)
;
const
ServoComputedValues
*
parentStyle
=
aParentContext
?
aParentContext
-
>
StyleSource
(
)
.
AsServoComputedValues
(
)
:
nullptr
;
RefPtr
<
ServoComputedValues
>
computedValues
=
Servo_ComputedValues_GetForAnonymousBox
(
parentStyle
aPseudoTag
skipFixup
mRawSet
.
get
(
)
)
.
Consume
(
)
;
#
ifdef
DEBUG
if
(
!
computedValues
)
{
nsString
pseudo
;
aPseudoTag
-
>
ToString
(
pseudo
)
;
NS_ERROR
(
nsPrintfCString
(
"
stylo
:
could
not
get
anon
-
box
:
%
s
"
NS_ConvertUTF16toUTF8
(
pseudo
)
.
get
(
)
)
.
get
(
)
)
;
MOZ_CRASH
(
)
;
}
#
endif
return
GetContext
(
computedValues
.
forget
(
)
aParentContext
aPseudoTag
CSSPseudoElementType
:
:
InheritingAnonBox
nullptr
)
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
ResolveNonInheritingAnonymousBoxStyle
(
nsIAtom
*
aPseudoTag
)
{
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsAnonBox
(
aPseudoTag
)
&
&
nsCSSAnonBoxes
:
:
IsNonInheritingAnonBox
(
aPseudoTag
)
)
;
MOZ_ASSERT
(
aPseudoTag
!
=
nsCSSAnonBoxes
:
:
pageContent
"
If
nsCSSAnonBoxes
:
:
pageContent
ends
up
non
-
inheriting
check
"
"
whether
we
need
to
do
anything
to
move
the
"
"
page
handling
from
ResolveInheritingAnonymousBoxStyle
to
"
"
ResolveNonInheritingAnonymousBoxStyle
"
)
;
nsCSSAnonBoxes
:
:
NonInheriting
type
=
nsCSSAnonBoxes
:
:
NonInheritingTypeForPseudoTag
(
aPseudoTag
)
;
RefPtr
<
nsStyleContext
>
&
cache
=
mNonInheritingStyleContexts
[
type
]
;
if
(
cache
)
{
RefPtr
<
nsStyleContext
>
retval
=
cache
;
return
retval
.
forget
(
)
;
}
UpdateStylistIfNeeded
(
)
;
MOZ_ASSERT
(
!
nsCSSAnonBoxes
:
:
IsNonInheritingAnonBox
(
nsCSSAnonBoxes
:
:
viewport
)
"
viewport
needs
fixup
to
handle
blockifying
it
"
)
;
RefPtr
<
ServoComputedValues
>
computedValues
=
Servo_ComputedValues_GetForAnonymousBox
(
nullptr
aPseudoTag
true
mRawSet
.
get
(
)
)
.
Consume
(
)
;
#
ifdef
DEBUG
if
(
!
computedValues
)
{
nsString
pseudo
;
aPseudoTag
-
>
ToString
(
pseudo
)
;
NS_ERROR
(
nsPrintfCString
(
"
stylo
:
could
not
get
anon
-
box
:
%
s
"
NS_ConvertUTF16toUTF8
(
pseudo
)
.
get
(
)
)
.
get
(
)
)
;
MOZ_CRASH
(
)
;
}
#
endif
RefPtr
<
nsStyleContext
>
retval
=
GetContext
(
computedValues
.
forget
(
)
nullptr
aPseudoTag
CSSPseudoElementType
:
:
NonInheritingAnonBox
nullptr
)
;
cache
=
retval
;
return
retval
.
forget
(
)
;
}
nsresult
ServoStyleSet
:
:
AppendStyleSheet
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
MOZ_ASSERT
(
aSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
MOZ_ASSERT
(
aSheet
-
>
RawSheet
(
)
"
Raw
sheet
should
be
in
place
before
insertion
.
"
)
;
RemoveSheetOfType
(
aType
aSheet
)
;
AppendSheetOfType
(
aType
aSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
aSheet
-
>
RawSheet
(
)
UniqueIDForSheet
(
aSheet
)
)
;
SetStylistStyleSheetsDirty
(
)
;
}
return
NS_OK
;
}
nsresult
ServoStyleSet
:
:
PrependStyleSheet
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
MOZ_ASSERT
(
aSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
MOZ_ASSERT
(
aSheet
-
>
RawSheet
(
)
"
Raw
sheet
should
be
in
place
before
insertion
.
"
)
;
RemoveSheetOfType
(
aType
aSheet
)
;
PrependSheetOfType
(
aType
aSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_PrependStyleSheet
(
mRawSet
.
get
(
)
aSheet
-
>
RawSheet
(
)
UniqueIDForSheet
(
aSheet
)
)
;
SetStylistStyleSheetsDirty
(
)
;
}
return
NS_OK
;
}
nsresult
ServoStyleSet
:
:
RemoveStyleSheet
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
RemoveSheetOfType
(
aType
aSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_RemoveStyleSheet
(
mRawSet
.
get
(
)
UniqueIDForSheet
(
aSheet
)
)
;
SetStylistStyleSheetsDirty
(
)
;
}
return
NS_OK
;
}
nsresult
ServoStyleSet
:
:
ReplaceSheets
(
SheetType
aType
const
nsTArray
<
RefPtr
<
ServoStyleSheet
>
>
&
aNewSheets
)
{
SetStylistStyleSheetsDirty
(
)
;
for
(
const
auto
&
sheet
:
mSheets
[
aType
]
)
{
sheet
-
>
DropStyleSet
(
this
)
;
if
(
mRawSet
)
{
Servo_StyleSet_RemoveStyleSheet
(
mRawSet
.
get
(
)
UniqueIDForSheet
(
sheet
)
)
;
}
}
mSheets
[
aType
]
.
Clear
(
)
;
for
(
auto
&
sheet
:
aNewSheets
)
{
AppendSheetOfType
(
aType
sheet
)
;
if
(
mRawSet
)
{
MOZ_ASSERT
(
sheet
-
>
RawSheet
(
)
"
Raw
sheet
should
be
in
place
before
replacement
.
"
)
;
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
sheet
-
>
RawSheet
(
)
UniqueIDForSheet
(
sheet
)
)
;
}
}
return
NS_OK
;
}
nsresult
ServoStyleSet
:
:
InsertStyleSheetBefore
(
SheetType
aType
ServoStyleSheet
*
aNewSheet
ServoStyleSheet
*
aReferenceSheet
)
{
MOZ_ASSERT
(
aNewSheet
)
;
MOZ_ASSERT
(
aReferenceSheet
)
;
MOZ_ASSERT
(
aNewSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
aNewSheet
!
=
aReferenceSheet
"
Can
'
t
place
sheet
before
itself
.
"
)
;
MOZ_ASSERT
(
aNewSheet
-
>
RawSheet
(
)
"
Raw
sheet
should
be
in
place
before
insertion
.
"
)
;
MOZ_ASSERT
(
aReferenceSheet
-
>
RawSheet
(
)
"
Reference
sheet
should
have
a
raw
sheet
.
"
)
;
RemoveSheetOfType
(
aType
aNewSheet
)
;
InsertSheetOfType
(
aType
aNewSheet
aReferenceSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_InsertStyleSheetBefore
(
mRawSet
.
get
(
)
aNewSheet
-
>
RawSheet
(
)
UniqueIDForSheet
(
aNewSheet
)
UniqueIDForSheet
(
aReferenceSheet
)
)
;
SetStylistStyleSheetsDirty
(
)
;
}
return
NS_OK
;
}
int32_t
ServoStyleSet
:
:
SheetCount
(
SheetType
aType
)
const
{
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
return
mSheets
[
aType
]
.
Length
(
)
;
}
ServoStyleSheet
*
ServoStyleSet
:
:
StyleSheetAt
(
SheetType
aType
int32_t
aIndex
)
const
{
MOZ_ASSERT
(
nsStyleSet
:
:
IsCSSSheetType
(
aType
)
)
;
return
mSheets
[
aType
]
[
aIndex
]
;
}
nsresult
ServoStyleSet
:
:
RemoveDocStyleSheet
(
ServoStyleSheet
*
aSheet
)
{
return
RemoveStyleSheet
(
SheetType
:
:
Doc
aSheet
)
;
}
nsresult
ServoStyleSet
:
:
AddDocStyleSheet
(
ServoStyleSheet
*
aSheet
nsIDocument
*
aDocument
)
{
MOZ_ASSERT
(
aSheet
-
>
IsApplicable
(
)
)
;
MOZ_ASSERT
(
aSheet
-
>
RawSheet
(
)
"
Raw
sheet
should
be
in
place
by
this
point
.
"
)
;
RefPtr
<
StyleSheet
>
strong
(
aSheet
)
;
RemoveSheetOfType
(
SheetType
:
:
Doc
aSheet
)
;
size_t
index
=
aDocument
-
>
FindDocStyleSheetInsertionPoint
(
mSheets
[
SheetType
:
:
Doc
]
aSheet
)
;
if
(
index
<
mSheets
[
SheetType
:
:
Doc
]
.
Length
(
)
)
{
ServoStyleSheet
*
beforeSheet
=
mSheets
[
SheetType
:
:
Doc
]
[
index
]
;
InsertSheetOfType
(
SheetType
:
:
Doc
aSheet
beforeSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_InsertStyleSheetBefore
(
mRawSet
.
get
(
)
aSheet
-
>
RawSheet
(
)
UniqueIDForSheet
(
aSheet
)
UniqueIDForSheet
(
beforeSheet
)
)
;
SetStylistStyleSheetsDirty
(
)
;
}
}
else
{
AppendSheetOfType
(
SheetType
:
:
Doc
aSheet
)
;
if
(
mRawSet
)
{
Servo_StyleSet_AppendStyleSheet
(
mRawSet
.
get
(
)
aSheet
-
>
RawSheet
(
)
UniqueIDForSheet
(
aSheet
)
)
;
SetStylistStyleSheetsDirty
(
)
;
}
}
return
NS_OK
;
}
already_AddRefed
<
nsStyleContext
>
ServoStyleSet
:
:
ProbePseudoElementStyle
(
Element
*
aOriginatingElement
CSSPseudoElementType
aType
nsStyleContext
*
aParentContext
Element
*
aPseudoElement
)
{
UpdateStylistIfNeeded
(
)
;
if
(
aPseudoElement
)
{
NS_ERROR
(
"
stylo
:
We
don
'
t
support
CSS_PSEUDO_ELEMENT_SUPPORTS_USER_ACTION_STATE
yet
"
)
;
}
MOZ_ASSERT
(
aType
<
CSSPseudoElementType
:
:
Count
)
;
RefPtr
<
ServoComputedValues
>
computedValues
=
Servo_ResolvePseudoStyle
(
aOriginatingElement
aType
true
mRawSet
.
get
(
)
)
.
Consume
(
)
;
if
(
!
computedValues
)
{
return
nullptr
;
}
bool
isBeforeOrAfter
=
aType
=
=
CSSPseudoElementType
:
:
before
|
|
aType
=
=
CSSPseudoElementType
:
:
after
;
if
(
isBeforeOrAfter
)
{
const
nsStyleDisplay
*
display
=
Servo_GetStyleDisplay
(
computedValues
)
;
const
nsStyleContent
*
content
=
Servo_GetStyleContent
(
computedValues
)
;
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
None
|
|
content
-
>
ContentCount
(
)
=
=
0
)
{
return
nullptr
;
}
}
nsIAtom
*
pseudoTag
=
nsCSSPseudoElements
:
:
GetPseudoAtom
(
aType
)
;
return
GetContext
(
computedValues
.
forget
(
)
aParentContext
pseudoTag
aType
isBeforeOrAfter
?
aOriginatingElement
:
nullptr
)
;
}
nsRestyleHint
ServoStyleSet
:
:
HasStateDependentStyle
(
dom
:
:
Element
*
aElement
EventStates
aStateMask
)
{
NS_WARNING
(
"
stylo
:
HasStateDependentStyle
always
returns
zero
!
"
)
;
return
nsRestyleHint
(
0
)
;
}
nsRestyleHint
ServoStyleSet
:
:
HasStateDependentStyle
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
dom
:
:
Element
*
aPseudoElement
EventStates
aStateMask
)
{
NS_WARNING
(
"
stylo
:
HasStateDependentStyle
always
returns
zero
!
"
)
;
return
nsRestyleHint
(
0
)
;
}
bool
ServoStyleSet
:
:
StyleDocument
(
TraversalRestyleBehavior
aRestyleBehavior
)
{
MOZ_ASSERT
(
aRestyleBehavior
=
=
TraversalRestyleBehavior
:
:
Normal
|
|
aRestyleBehavior
=
=
TraversalRestyleBehavior
:
:
ForCSSRuleChanges
"
StyleDocument
(
)
should
be
only
called
for
normal
traversal
or
CSS
rule
"
"
changes
"
)
;
PreTraverse
(
)
;
bool
postTraversalRequired
=
false
;
DocumentStyleRootIterator
iter
(
mPresContext
-
>
Document
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
if
(
PrepareAndTraverseSubtree
(
root
TraversalRootBehavior
:
:
Normal
aRestyleBehavior
)
)
{
postTraversalRequired
=
true
;
}
}
return
postTraversalRequired
;
}
bool
ServoStyleSet
:
:
StyleDocumentForAnimationOnly
(
)
{
PreTraverse
(
nullptr
EffectCompositor
:
:
AnimationRestyleType
:
:
Full
)
;
bool
postTraversalRequired
=
false
;
DocumentStyleRootIterator
iter
(
mPresContext
-
>
Document
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
if
(
PrepareAndTraverseSubtree
(
root
TraversalRootBehavior
:
:
Normal
TraversalRestyleBehavior
:
:
ForAnimationOnly
)
)
{
postTraversalRequired
=
true
;
}
}
return
postTraversalRequired
;
}
void
ServoStyleSet
:
:
StyleNewSubtree
(
Element
*
aRoot
)
{
MOZ_ASSERT
(
!
aRoot
-
>
HasServoData
(
)
)
;
PreTraverse
(
)
;
DebugOnly
<
bool
>
postTraversalRequired
=
PrepareAndTraverseSubtree
(
aRoot
TraversalRootBehavior
:
:
Normal
TraversalRestyleBehavior
:
:
Normal
)
;
MOZ_ASSERT
(
!
postTraversalRequired
)
;
}
void
ServoStyleSet
:
:
StyleNewChildren
(
Element
*
aParent
)
{
PreTraverse
(
)
;
PrepareAndTraverseSubtree
(
aParent
TraversalRootBehavior
:
:
UnstyledChildrenOnly
TraversalRestyleBehavior
:
:
Normal
)
;
}
void
ServoStyleSet
:
:
StyleSubtreeForReconstruct
(
Element
*
aRoot
)
{
PreTraverse
(
aRoot
)
;
DebugOnly
<
bool
>
postTraversalRequired
=
PrepareAndTraverseSubtree
(
aRoot
TraversalRootBehavior
:
:
Normal
TraversalRestyleBehavior
:
:
ForReconstruct
)
;
MOZ_ASSERT
(
!
postTraversalRequired
)
;
}
void
ServoStyleSet
:
:
NoteStyleSheetsChanged
(
)
{
SetStylistStyleSheetsDirty
(
)
;
Servo_StyleSet_NoteStyleSheetsChanged
(
mRawSet
.
get
(
)
mAuthorStyleDisabled
)
;
}
#
ifdef
DEBUG
void
ServoStyleSet
:
:
AssertTreeIsClean
(
)
{
DocumentStyleRootIterator
iter
(
mPresContext
-
>
Document
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
Servo_AssertTreeIsClean
(
root
)
;
}
}
#
endif
bool
ServoStyleSet
:
:
GetKeyframesForName
(
const
nsString
&
aName
const
nsTimingFunction
&
aTimingFunction
const
ServoComputedValues
*
aComputedValues
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
UpdateStylistIfNeeded
(
)
;
NS_ConvertUTF16toUTF8
name
(
aName
)
;
return
Servo_StyleSet_GetKeyframesForName
(
mRawSet
.
get
(
)
&
name
&
aTimingFunction
aComputedValues
&
aKeyframes
)
;
}
nsTArray
<
ComputedKeyframeValues
>
ServoStyleSet
:
:
GetComputedKeyframeValuesFor
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
dom
:
:
Element
*
aElement
const
ServoComputedValuesWithParent
&
aServoValues
)
{
nsTArray
<
ComputedKeyframeValues
>
result
(
aKeyframes
.
Length
(
)
)
;
result
.
AppendElements
(
aKeyframes
.
Length
(
)
)
;
Servo_GetComputedKeyframeValues
(
&
aKeyframes
aServoValues
.
mCurrentStyle
aServoValues
.
mParentStyle
mRawSet
.
get
(
)
&
result
)
;
return
result
;
}
already_AddRefed
<
ServoComputedValues
>
ServoStyleSet
:
:
GetBaseComputedValuesForElement
(
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
{
return
Servo_StyleSet_GetBaseComputedValuesForElement
(
mRawSet
.
get
(
)
aElement
&
Snapshots
(
)
aPseudoType
)
.
Consume
(
)
;
}
already_AddRefed
<
RawServoAnimationValue
>
ServoStyleSet
:
:
ComputeAnimationValue
(
RawServoDeclarationBlock
*
aDeclarations
const
ServoComputedValuesWithParent
&
aComputedValues
)
{
return
Servo_AnimationValue_Compute
(
aDeclarations
aComputedValues
.
mCurrentStyle
aComputedValues
.
mParentStyle
mRawSet
.
get
(
)
)
.
Consume
(
)
;
}
bool
ServoStyleSet
:
:
EnsureUniqueInnerOnCSSSheets
(
)
{
AutoTArray
<
StyleSheet
*
32
>
queue
;
for
(
auto
&
entryArray
:
mSheets
)
{
for
(
auto
&
sheet
:
entryArray
)
{
queue
.
AppendElement
(
sheet
)
;
}
}
while
(
!
queue
.
IsEmpty
(
)
)
{
uint32_t
idx
=
queue
.
Length
(
)
-
1
;
StyleSheet
*
sheet
=
queue
[
idx
]
;
queue
.
RemoveElementAt
(
idx
)
;
sheet
-
>
EnsureUniqueInner
(
)
;
sheet
-
>
AppendAllChildSheets
(
queue
)
;
}
bool
res
=
mNeedsRestyleAfterEnsureUniqueInner
;
mNeedsRestyleAfterEnsureUniqueInner
=
false
;
return
res
;
}
void
ServoStyleSet
:
:
RebuildData
(
)
{
ClearNonInheritingStyleContexts
(
)
;
Servo_StyleSet_RebuildData
(
mRawSet
.
get
(
)
)
;
mStylistState
=
StylistState
:
:
NotDirty
;
}
void
ServoStyleSet
:
:
ClearDataAndMarkDeviceDirty
(
)
{
ClearNonInheritingStyleContexts
(
)
;
Servo_StyleSet_Clear
(
mRawSet
.
get
(
)
)
;
mStylistState
=
StylistState
:
:
FullyDirty
;
}
already_AddRefed
<
ServoComputedValues
>
ServoStyleSet
:
:
ResolveServoStyle
(
Element
*
aElement
)
{
UpdateStylistIfNeeded
(
)
;
return
Servo_ResolveStyle
(
aElement
mRawSet
.
get
(
)
mAllowResolveStaleStyles
)
.
Consume
(
)
;
}
void
ServoStyleSet
:
:
ClearNonInheritingStyleContexts
(
)
{
for
(
RefPtr
<
nsStyleContext
>
&
ptr
:
mNonInheritingStyleContexts
)
{
ptr
=
nullptr
;
}
}
already_AddRefed
<
ServoComputedValues
>
ServoStyleSet
:
:
ResolveStyleLazily
(
Element
*
aElement
CSSPseudoElementType
aPseudoType
StyleRuleInclusion
aRuleInclusion
)
{
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverse
(
aElement
aPseudoType
)
;
MOZ_ASSERT
(
!
StylistNeedsUpdate
(
)
)
;
AutoSetInServoTraversal
guard
(
this
)
;
Element
*
elementForStyleResolution
=
aElement
;
CSSPseudoElementType
pseudoTypeForStyleResolution
=
aPseudoType
;
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
if
(
Element
*
pseudo
=
nsLayoutUtils
:
:
GetBeforePseudo
(
aElement
)
)
{
elementForStyleResolution
=
pseudo
;
pseudoTypeForStyleResolution
=
CSSPseudoElementType
:
:
NotPseudo
;
}
}
else
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
if
(
Element
*
pseudo
=
nsLayoutUtils
:
:
GetAfterPseudo
(
aElement
)
)
{
elementForStyleResolution
=
pseudo
;
pseudoTypeForStyleResolution
=
CSSPseudoElementType
:
:
NotPseudo
;
}
}
RefPtr
<
ServoComputedValues
>
computedValues
=
Servo_ResolveStyleLazily
(
elementForStyleResolution
pseudoTypeForStyleResolution
aRuleInclusion
&
Snapshots
(
)
mRawSet
.
get
(
)
)
.
Consume
(
)
;
if
(
mPresContext
-
>
EffectCompositor
(
)
-
>
PreTraverse
(
aElement
aPseudoType
)
)
{
computedValues
=
Servo_ResolveStyleLazily
(
elementForStyleResolution
pseudoTypeForStyleResolution
aRuleInclusion
&
Snapshots
(
)
mRawSet
.
get
(
)
)
.
Consume
(
)
;
}
return
computedValues
.
forget
(
)
;
}
bool
ServoStyleSet
:
:
AppendFontFaceRules
(
nsTArray
<
nsFontFaceRuleContainer
>
&
aArray
)
{
UpdateStylistIfNeeded
(
)
;
Servo_StyleSet_GetFontFaceRules
(
mRawSet
.
get
(
)
&
aArray
)
;
return
true
;
}
nsCSSCounterStyleRule
*
ServoStyleSet
:
:
CounterStyleRuleForName
(
nsIAtom
*
aName
)
{
return
Servo_StyleSet_GetCounterStyleRule
(
mRawSet
.
get
(
)
aName
)
;
}
already_AddRefed
<
ServoComputedValues
>
ServoStyleSet
:
:
ResolveForDeclarations
(
ServoComputedValuesBorrowedOrNull
aParentOrNull
RawServoDeclarationBlockBorrowed
aDeclarations
)
{
UpdateStylistIfNeeded
(
)
;
return
Servo_StyleSet_ResolveForDeclarations
(
mRawSet
.
get
(
)
aParentOrNull
aDeclarations
)
.
Consume
(
)
;
}
void
ServoStyleSet
:
:
UpdateStylist
(
)
{
MOZ_ASSERT
(
StylistNeedsUpdate
(
)
)
;
if
(
mStylistState
=
=
StylistState
:
:
FullyDirty
)
{
RebuildData
(
)
;
}
else
{
Servo_StyleSet_FlushStyleSheets
(
mRawSet
.
get
(
)
)
;
}
mStylistState
=
StylistState
:
:
NotDirty
;
}
void
ServoStyleSet
:
:
PrependSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
aSheet
-
>
AddStyleSet
(
this
)
;
mSheets
[
aType
]
.
InsertElementAt
(
0
aSheet
)
;
}
void
ServoStyleSet
:
:
AppendSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
aSheet
-
>
AddStyleSet
(
this
)
;
mSheets
[
aType
]
.
AppendElement
(
aSheet
)
;
}
void
ServoStyleSet
:
:
InsertSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
ServoStyleSheet
*
aBeforeSheet
)
{
for
(
uint32_t
i
=
0
;
i
<
mSheets
[
aType
]
.
Length
(
)
;
+
+
i
)
{
if
(
mSheets
[
aType
]
[
i
]
=
=
aBeforeSheet
)
{
aSheet
-
>
AddStyleSet
(
this
)
;
mSheets
[
aType
]
.
InsertElementAt
(
i
aSheet
)
;
return
;
}
}
}
void
ServoStyleSet
:
:
RemoveSheetOfType
(
SheetType
aType
ServoStyleSheet
*
aSheet
)
{
for
(
uint32_t
i
=
0
;
i
<
mSheets
[
aType
]
.
Length
(
)
;
+
+
i
)
{
if
(
mSheets
[
aType
]
[
i
]
=
=
aSheet
)
{
aSheet
-
>
DropStyleSet
(
this
)
;
mSheets
[
aType
]
.
RemoveElementAt
(
i
)
;
}
}
}
void
ServoStyleSet
:
:
RunPostTraversalTasks
(
)
{
MOZ_ASSERT
(
!
IsInServoTraversal
(
)
)
;
if
(
mPostTraversalTasks
.
IsEmpty
(
)
)
{
return
;
}
nsTArray
<
PostTraversalTask
>
tasks
;
tasks
.
SwapElements
(
mPostTraversalTasks
)
;
for
(
auto
&
task
:
tasks
)
{
task
.
Run
(
)
;
}
}
ServoStyleSet
*
ServoStyleSet
:
:
sInServoTraversal
=
nullptr
;
