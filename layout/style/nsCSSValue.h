#
ifndef
nsCSSValue_h___
#
define
nsCSSValue_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ServoTypes
.
h
"
#
include
"
mozilla
/
SheetType
.
h
"
#
include
"
mozilla
/
URLExtraData
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCSSKeywords
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
"
gfxFontFamilyList
.
h
"
#
include
<
type_traits
>
class
imgRequestProxy
;
class
nsAtom
;
class
nsIContent
;
class
nsIDocument
;
class
nsIPrincipal
;
class
nsIURI
;
class
nsPresContext
;
template
<
class
T
>
class
nsPtrHashKey
;
struct
RustString
;
namespace
mozilla
{
class
CSSStyleSheet
;
}
#
define
NS_CSS_DELETE_LIST_MEMBER
(
type_
ptr_
member_
)
\
{
\
type_
*
cur
=
(
ptr_
)
-
>
member_
;
\
(
ptr_
)
-
>
member_
=
nullptr
;
\
while
(
cur
)
{
\
type_
*
dlm_next
=
cur
-
>
member_
;
\
cur
-
>
member_
=
nullptr
;
\
delete
cur
;
\
cur
=
dlm_next
;
\
}
\
}
#
define
NS_CSS_NS_RELEASE_LIST_MEMBER
(
type_
ptr_
member_
)
\
{
\
type_
*
cur
=
(
ptr_
)
-
>
member_
;
\
(
ptr_
)
-
>
member_
=
nullptr
;
\
while
(
cur
)
{
\
type_
*
dlm_next
=
cur
-
>
member_
;
\
cur
-
>
member_
=
nullptr
;
\
NS_RELEASE
(
cur
)
;
\
cur
=
dlm_next
;
\
}
\
}
#
define
NS_CSS_CLONE_LIST_MEMBER
(
type_
from_
member_
to_
args_
)
\
{
\
type_
*
dest
=
(
to_
)
;
\
(
to_
)
-
>
member_
=
nullptr
;
\
for
(
const
type_
*
src
=
(
from_
)
-
>
member_
;
src
;
src
=
src
-
>
member_
)
{
\
type_
*
clm_clone
=
src
-
>
Clone
args_
;
\
if
(
!
clm_clone
)
{
\
delete
(
to_
)
;
\
return
nullptr
;
\
}
\
dest
-
>
member_
=
clm_clone
;
\
dest
=
clm_clone
;
\
}
\
}
namespace
mozilla
{
namespace
css
{
struct
URLValueData
{
protected
:
URLValueData
(
ServoRawOffsetArc
<
RustString
>
aString
already_AddRefed
<
URLExtraData
>
aExtraData
CORSMode
aCORSMode
)
;
URLValueData
(
already_AddRefed
<
nsIURI
>
aURI
ServoRawOffsetArc
<
RustString
>
aString
already_AddRefed
<
URLExtraData
>
aExtraData
CORSMode
aCORSMode
)
;
public
:
bool
Equals
(
const
URLValueData
&
aOther
)
const
;
bool
DefinitelyEqualURIs
(
const
URLValueData
&
aOther
)
const
;
bool
DefinitelyEqualURIsAndPrincipal
(
const
URLValueData
&
aOther
)
const
;
nsIURI
*
GetURI
(
)
const
;
bool
IsLocalRef
(
)
const
;
bool
HasRef
(
)
const
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
URLValueData
)
already_AddRefed
<
nsIURI
>
ResolveLocalRef
(
nsIURI
*
aURI
)
const
;
already_AddRefed
<
nsIURI
>
ResolveLocalRef
(
nsIContent
*
aContent
)
const
;
void
GetSourceString
(
nsString
&
aRef
)
const
;
bool
EqualsExceptRef
(
nsIURI
*
aURI
)
const
;
bool
IsStringEmpty
(
)
const
{
return
GetString
(
)
.
IsEmpty
(
)
;
}
nsDependentCSubstring
GetString
(
)
const
;
private
:
mutable
nsCOMPtr
<
nsIURI
>
mURI
;
public
:
RefPtr
<
URLExtraData
>
mExtraData
;
private
:
mutable
bool
mURIResolved
;
mutable
Maybe
<
bool
>
mIsLocalRef
;
mozilla
:
:
ServoRawOffsetArc
<
RustString
>
mString
;
protected
:
const
CORSMode
mCORSMode
;
virtual
~
URLValueData
(
)
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
URLValueData
(
const
URLValueData
&
aOther
)
=
delete
;
URLValueData
&
operator
=
(
const
URLValueData
&
aOther
)
=
delete
;
friend
struct
ImageValue
;
}
;
struct
URLValue
final
:
public
URLValueData
{
URLValue
(
ServoRawOffsetArc
<
RustString
>
aString
already_AddRefed
<
URLExtraData
>
aExtraData
)
:
URLValueData
(
aString
std
:
:
move
(
aExtraData
)
CORSMode
:
:
CORS_NONE
)
{
}
URLValue
(
const
URLValue
&
)
=
delete
;
URLValue
&
operator
=
(
const
URLValue
&
)
=
delete
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
}
;
struct
ImageValue
final
:
public
URLValueData
{
ImageValue
(
nsIURI
*
aURI
const
nsAString
&
aString
already_AddRefed
<
URLExtraData
>
aExtraData
nsIDocument
*
aDocument
CORSMode
aCORSMode
)
;
ImageValue
(
nsIURI
*
aURI
ServoRawOffsetArc
<
RustString
>
aString
already_AddRefed
<
URLExtraData
>
aExtraData
nsIDocument
*
aDocument
CORSMode
aCORSMode
)
;
ImageValue
(
const
nsAString
&
aString
already_AddRefed
<
URLExtraData
>
aExtraData
CORSMode
aCORSMode
)
;
ImageValue
(
ServoRawOffsetArc
<
RustString
>
aURIString
already_AddRefed
<
URLExtraData
>
aExtraData
CORSMode
aCORSMode
)
;
ImageValue
(
const
ImageValue
&
)
=
delete
;
ImageValue
&
operator
=
(
const
ImageValue
&
)
=
delete
;
imgRequestProxy
*
LoadImage
(
nsIDocument
*
aDocument
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
uint64_t
LoadID
(
)
const
{
return
mLoadID
;
}
protected
:
~
ImageValue
(
)
;
private
:
uint64_t
mLoadID
=
0
;
}
;
struct
GridNamedArea
{
nsString
mName
;
uint32_t
mColumnStart
;
uint32_t
mColumnEnd
;
uint32_t
mRowStart
;
uint32_t
mRowEnd
;
}
;
struct
GridTemplateAreasValue
final
{
nsTArray
<
GridNamedArea
>
mNamedAreas
;
nsTArray
<
nsString
>
mTemplates
;
uint32_t
mNColumns
;
uint32_t
NRows
(
)
const
{
return
mTemplates
.
Length
(
)
;
}
GridTemplateAreasValue
(
)
:
mNColumns
(
0
)
{
}
bool
operator
=
=
(
const
GridTemplateAreasValue
&
aOther
)
const
{
return
mTemplates
=
=
aOther
.
mTemplates
;
}
bool
operator
!
=
(
const
GridTemplateAreasValue
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
GridTemplateAreasValue
)
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
~
GridTemplateAreasValue
(
)
{
}
GridTemplateAreasValue
(
const
GridTemplateAreasValue
&
aOther
)
=
delete
;
GridTemplateAreasValue
&
operator
=
(
const
GridTemplateAreasValue
&
aOther
)
=
delete
;
}
;
}
}
enum
nsCSSUnit
{
eCSSUnit_Null
=
0
eCSSUnit_Auto
=
1
eCSSUnit_Inherit
=
2
eCSSUnit_Initial
=
3
eCSSUnit_Unset
=
4
eCSSUnit_None
=
5
eCSSUnit_Normal
=
6
eCSSUnit_System_Font
=
7
eCSSUnit_All
=
8
eCSSUnit_Dummy
=
9
eCSSUnit_DummyInherit
=
10
eCSSUnit_String
=
11
eCSSUnit_Ident
=
12
eCSSUnit_Attr
=
14
eCSSUnit_Local_Font
=
15
eCSSUnit_Font_Format
=
16
eCSSUnit_Element
=
17
eCSSUnit_Array
=
20
eCSSUnit_Counter
=
21
eCSSUnit_Counters
=
22
eCSSUnit_Cubic_Bezier
=
23
eCSSUnit_Steps
=
24
eCSSUnit_Symbols
=
25
eCSSUnit_Function
=
26
eCSSUnit_Calc
=
30
eCSSUnit_Calc_Plus
=
31
eCSSUnit_Calc_Minus
=
32
eCSSUnit_Calc_Times_L
=
33
eCSSUnit_Calc_Times_R
=
34
eCSSUnit_Calc_Divided
=
35
eCSSUnit_URL
=
40
eCSSUnit_Pair
=
50
eCSSUnit_List
=
53
eCSSUnit_ListDep
=
54
eCSSUnit_SharedList
=
55
eCSSUnit_PairList
=
56
eCSSUnit_PairListDep
=
57
eCSSUnit_FontFamilyList
=
58
eCSSUnit_AtomIdent
=
60
eCSSUnit_Integer
=
70
eCSSUnit_Enumerated
=
71
eCSSUnit_Percent
=
100
eCSSUnit_Number
=
101
eCSSUnit_ViewportWidth
=
700
eCSSUnit_ViewportHeight
=
701
eCSSUnit_ViewportMin
=
702
eCSSUnit_ViewportMax
=
703
eCSSUnit_EM
=
800
eCSSUnit_XHeight
=
801
eCSSUnit_Char
=
802
eCSSUnit_RootEM
=
803
eCSSUnit_Point
=
900
eCSSUnit_Inch
=
901
eCSSUnit_Millimeter
=
902
eCSSUnit_Centimeter
=
903
eCSSUnit_Pica
=
904
eCSSUnit_Quarter
=
905
eCSSUnit_Pixel
=
906
eCSSUnit_Degree
=
1000
eCSSUnit_Grad
=
1001
eCSSUnit_Radian
=
1002
eCSSUnit_Turn
=
1003
eCSSUnit_Hertz
=
2000
eCSSUnit_Kilohertz
=
2001
eCSSUnit_Seconds
=
3000
eCSSUnit_Milliseconds
=
3001
eCSSUnit_FlexFraction
=
4000
}
;
struct
nsCSSValuePair
;
struct
nsCSSValuePair_heap
;
struct
nsCSSValueList
;
struct
nsCSSValueList_heap
;
struct
nsCSSValueSharedList
;
struct
nsCSSValuePairList
;
struct
nsCSSValuePairList_heap
;
class
nsCSSValue
{
public
:
struct
Array
;
friend
struct
Array
;
friend
struct
mozilla
:
:
css
:
:
URLValueData
;
friend
struct
mozilla
:
:
css
:
:
ImageValue
;
explicit
nsCSSValue
(
nsCSSUnit
aUnit
=
eCSSUnit_Null
)
:
mUnit
(
aUnit
)
{
MOZ_ASSERT
(
aUnit
<
=
eCSSUnit_DummyInherit
"
not
a
valueless
unit
"
)
;
}
nsCSSValue
(
int32_t
aValue
nsCSSUnit
aUnit
)
;
nsCSSValue
(
float
aValue
nsCSSUnit
aUnit
)
;
nsCSSValue
(
const
nsString
&
aValue
nsCSSUnit
aUnit
)
;
nsCSSValue
(
Array
*
aArray
nsCSSUnit
aUnit
)
;
explicit
nsCSSValue
(
mozilla
:
:
css
:
:
URLValue
*
aValue
)
;
explicit
nsCSSValue
(
mozilla
:
:
css
:
:
ImageValue
*
aValue
)
;
explicit
nsCSSValue
(
mozilla
:
:
SharedFontList
*
aValue
)
;
nsCSSValue
(
const
nsCSSValue
&
aCopy
)
;
nsCSSValue
(
nsCSSValue
&
&
aOther
)
:
mUnit
(
aOther
.
mUnit
)
mValue
(
aOther
.
mValue
)
{
aOther
.
mUnit
=
eCSSUnit_Null
;
}
template
<
typename
T
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_enum
<
T
>
:
:
value
>
:
:
type
>
explicit
nsCSSValue
(
T
aValue
)
:
mUnit
(
eCSSUnit_Enumerated
)
{
static_assert
(
mozilla
:
:
EnumTypeFitsWithin
<
T
int32_t
>
:
:
value
"
aValue
must
be
an
enum
that
fits
within
mValue
.
mInt
"
)
;
mValue
.
mInt
=
static_cast
<
int32_t
>
(
aValue
)
;
}
~
nsCSSValue
(
)
{
Reset
(
)
;
}
nsCSSValue
&
operator
=
(
const
nsCSSValue
&
aCopy
)
;
nsCSSValue
&
operator
=
(
nsCSSValue
&
&
aCopy
)
;
bool
operator
=
=
(
const
nsCSSValue
&
aOther
)
const
;
bool
operator
!
=
(
const
nsCSSValue
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsCSSUnit
GetUnit
(
)
const
{
return
mUnit
;
}
bool
IsLengthUnit
(
)
const
{
return
eCSSUnit_ViewportWidth
<
=
mUnit
&
&
mUnit
<
=
eCSSUnit_Pixel
;
}
bool
IsLengthPercentCalcUnit
(
)
const
{
return
IsLengthUnit
(
)
|
|
mUnit
=
=
eCSSUnit_Percent
|
|
IsCalcUnit
(
)
;
}
bool
IsRelativeLengthUnit
(
)
const
{
return
eCSSUnit_EM
<
=
mUnit
&
&
mUnit
<
=
eCSSUnit_RootEM
;
}
static
bool
IsPixelLengthUnit
(
nsCSSUnit
aUnit
)
{
return
eCSSUnit_Point
<
=
aUnit
&
&
aUnit
<
=
eCSSUnit_Pixel
;
}
bool
IsPixelLengthUnit
(
)
const
{
return
IsPixelLengthUnit
(
mUnit
)
;
}
static
bool
IsPercentLengthUnit
(
nsCSSUnit
aUnit
)
{
return
aUnit
=
=
eCSSUnit_Percent
;
}
bool
IsPercentLengthUnit
(
)
{
return
IsPercentLengthUnit
(
mUnit
)
;
}
static
bool
IsFloatUnit
(
nsCSSUnit
aUnit
)
{
return
eCSSUnit_Number
<
=
aUnit
;
}
bool
IsAngularUnit
(
)
const
{
return
eCSSUnit_Degree
<
=
mUnit
&
&
mUnit
<
=
eCSSUnit_Turn
;
}
bool
IsFrequencyUnit
(
)
const
{
return
eCSSUnit_Hertz
<
=
mUnit
&
&
mUnit
<
=
eCSSUnit_Kilohertz
;
}
bool
IsTimeUnit
(
)
const
{
return
eCSSUnit_Seconds
<
=
mUnit
&
&
mUnit
<
=
eCSSUnit_Milliseconds
;
}
bool
IsCalcUnit
(
)
const
{
return
eCSSUnit_Calc
<
=
mUnit
&
&
mUnit
<
=
eCSSUnit_Calc_Divided
;
}
bool
UnitHasStringValue
(
)
const
{
return
eCSSUnit_String
<
=
mUnit
&
&
mUnit
<
=
eCSSUnit_Element
;
}
bool
UnitHasArrayValue
(
)
const
{
return
eCSSUnit_Array
<
=
mUnit
&
&
mUnit
<
=
eCSSUnit_Calc_Divided
;
}
int32_t
GetIntValue
(
)
const
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_Integer
|
|
mUnit
=
=
eCSSUnit_Enumerated
"
not
an
int
value
"
)
;
return
mValue
.
mInt
;
}
nsCSSKeyword
GetKeywordValue
(
)
const
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_Enumerated
"
not
a
keyword
value
"
)
;
return
static_cast
<
nsCSSKeyword
>
(
mValue
.
mInt
)
;
}
float
GetPercentValue
(
)
const
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_Percent
"
not
a
percent
value
"
)
;
return
mValue
.
mFloat
;
}
float
GetFloatValue
(
)
const
{
MOZ_ASSERT
(
eCSSUnit_Number
<
=
mUnit
"
not
a
float
value
"
)
;
MOZ_ASSERT
(
!
mozilla
:
:
IsNaN
(
mValue
.
mFloat
)
)
;
return
mValue
.
mFloat
;
}
float
GetAngleValue
(
)
const
{
MOZ_ASSERT
(
eCSSUnit_Degree
<
=
mUnit
&
&
mUnit
<
=
eCSSUnit_Turn
"
not
an
angle
value
"
)
;
return
mValue
.
mFloat
;
}
double
GetAngleValueInRadians
(
)
const
;
double
GetAngleValueInDegrees
(
)
const
;
nsAString
&
GetStringValue
(
nsAString
&
aBuffer
)
const
{
MOZ_ASSERT
(
UnitHasStringValue
(
)
"
not
a
string
value
"
)
;
aBuffer
.
Truncate
(
)
;
uint32_t
len
=
NS_strlen
(
GetBufferValue
(
mValue
.
mString
)
)
;
mValue
.
mString
-
>
ToString
(
len
aBuffer
)
;
return
aBuffer
;
}
const
char16_t
*
GetStringBufferValue
(
)
const
{
MOZ_ASSERT
(
UnitHasStringValue
(
)
"
not
a
string
value
"
)
;
return
GetBufferValue
(
mValue
.
mString
)
;
}
Array
*
GetArrayValue
(
)
const
{
MOZ_ASSERT
(
UnitHasArrayValue
(
)
"
not
an
array
value
"
)
;
return
mValue
.
mArray
;
}
nsIURI
*
GetURLValue
(
)
const
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_URL
"
not
a
URL
value
"
)
;
return
mValue
.
mURL
-
>
GetURI
(
)
;
}
nsCSSValueSharedList
*
GetSharedListValue
(
)
const
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_SharedList
"
not
a
shared
list
value
"
)
;
return
mValue
.
mSharedList
;
}
mozilla
:
:
NotNull
<
mozilla
:
:
SharedFontList
*
>
GetFontFamilyListValue
(
)
const
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_FontFamilyList
"
not
a
font
family
list
value
"
)
;
NS_ASSERTION
(
mValue
.
mFontFamilyList
!
=
nullptr
"
font
family
list
value
should
never
be
null
"
)
;
return
mozilla
:
:
WrapNotNull
(
mValue
.
mFontFamilyList
)
;
}
inline
nsCSSValuePair
&
GetPairValue
(
)
;
inline
const
nsCSSValuePair
&
GetPairValue
(
)
const
;
inline
nsCSSValueList
*
GetListValue
(
)
;
inline
const
nsCSSValueList
*
GetListValue
(
)
const
;
inline
nsCSSValuePairList
*
GetPairListValue
(
)
;
inline
const
nsCSSValuePairList
*
GetPairListValue
(
)
const
;
mozilla
:
:
css
:
:
URLValue
*
GetURLStructValue
(
)
const
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_URL
"
not
a
URL
value
"
)
;
return
mValue
.
mURL
;
}
imgRequestProxy
*
GetImageValue
(
nsIDocument
*
aDocument
)
const
;
already_AddRefed
<
imgRequestProxy
>
GetPossiblyStaticImageValue
(
nsIDocument
*
aDocument
nsPresContext
*
aPresContext
)
const
;
nscoord
GetPixelLength
(
)
const
;
nsAtom
*
GetAtomValue
(
)
const
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_AtomIdent
)
;
return
mValue
.
mAtom
;
}
void
Reset
(
)
{
if
(
mUnit
!
=
eCSSUnit_Null
)
DoReset
(
)
;
}
private
:
void
DoReset
(
)
;
public
:
void
SetIntValue
(
int32_t
aValue
nsCSSUnit
aUnit
)
;
template
<
typename
T
typename
=
typename
std
:
:
enable_if
<
std
:
:
is_enum
<
T
>
:
:
value
>
:
:
type
>
void
SetEnumValue
(
T
aValue
)
{
static_assert
(
mozilla
:
:
EnumTypeFitsWithin
<
T
int32_t
>
:
:
value
"
aValue
must
be
an
enum
that
fits
within
mValue
.
mInt
"
)
;
SetIntValue
(
static_cast
<
int32_t
>
(
aValue
)
eCSSUnit_Enumerated
)
;
}
void
SetPercentValue
(
float
aValue
)
;
void
SetFloatValue
(
float
aValue
nsCSSUnit
aUnit
)
;
void
SetStringValue
(
const
nsString
&
aValue
nsCSSUnit
aUnit
)
;
void
SetAtomIdentValue
(
already_AddRefed
<
nsAtom
>
aValue
)
;
void
SetIntegerCoordValue
(
nscoord
aCoord
)
;
void
SetArrayValue
(
nsCSSValue
:
:
Array
*
aArray
nsCSSUnit
aUnit
)
;
void
SetURLValue
(
mozilla
:
:
css
:
:
URLValue
*
aURI
)
;
void
SetFontFamilyListValue
(
already_AddRefed
<
mozilla
:
:
SharedFontList
>
aFontListValue
)
;
void
SetPairValue
(
const
nsCSSValuePair
*
aPair
)
;
void
SetPairValue
(
const
nsCSSValue
&
xValue
const
nsCSSValue
&
yValue
)
;
void
SetSharedListValue
(
nsCSSValueSharedList
*
aList
)
;
void
SetNoneValue
(
)
;
nsStyleCoord
:
:
CalcValue
GetCalcValue
(
)
const
;
void
SetCalcValue
(
const
nsStyleCoord
:
:
CalcValue
&
)
;
nsCSSValueList
*
SetListValue
(
)
;
nsCSSValuePairList
*
SetPairListValue
(
)
;
static
already_AddRefed
<
nsStringBuffer
>
BufferFromString
(
const
nsString
&
aValue
)
;
void
AtomizeIdentValue
(
)
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
static
void
AppendAlignJustifyValueToString
(
int32_t
aValue
nsAString
&
aResult
)
;
private
:
static
const
char16_t
*
GetBufferValue
(
nsStringBuffer
*
aBuffer
)
{
return
static_cast
<
char16_t
*
>
(
aBuffer
-
>
Data
(
)
)
;
}
protected
:
nsCSSUnit
mUnit
;
union
{
int32_t
mInt
;
float
mFloat
;
nsStringBuffer
*
MOZ_OWNING_REF
mString
;
nsAtom
*
MOZ_OWNING_REF
mAtom
;
Array
*
MOZ_OWNING_REF
mArray
;
mozilla
:
:
css
:
:
URLValue
*
MOZ_OWNING_REF
mURL
;
nsCSSValuePair_heap
*
MOZ_OWNING_REF
mPair
;
nsCSSValueList_heap
*
MOZ_OWNING_REF
mList
;
nsCSSValueList
*
mListDependent
;
nsCSSValueSharedList
*
MOZ_OWNING_REF
mSharedList
;
nsCSSValuePairList_heap
*
MOZ_OWNING_REF
mPairList
;
nsCSSValuePairList
*
mPairListDependent
;
mozilla
:
:
SharedFontList
*
MOZ_OWNING_REF
mFontFamilyList
;
}
mValue
;
}
;
struct
nsCSSValue
:
:
Array
final
{
static
Array
*
Create
(
size_t
aItemCount
)
{
return
new
(
aItemCount
)
Array
(
aItemCount
)
;
}
nsCSSValue
&
operator
[
]
(
size_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
<
mCount
"
out
of
range
"
)
;
return
mArray
[
aIndex
]
;
}
const
nsCSSValue
&
operator
[
]
(
size_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mCount
"
out
of
range
"
)
;
return
mArray
[
aIndex
]
;
}
nsCSSValue
&
Item
(
size_t
aIndex
)
{
return
(
*
this
)
[
aIndex
]
;
}
const
nsCSSValue
&
Item
(
size_t
aIndex
)
const
{
return
(
*
this
)
[
aIndex
]
;
}
size_t
Count
(
)
const
{
return
mCount
;
}
nsCSSValue
*
ItemStorage
(
)
{
return
this
-
>
First
(
)
;
}
bool
operator
=
=
(
const
Array
&
aOther
)
const
{
if
(
mCount
!
=
aOther
.
mCount
)
return
false
;
for
(
size_t
i
=
0
;
i
<
mCount
;
+
+
i
)
if
(
(
*
this
)
[
i
]
!
=
aOther
[
i
]
)
return
false
;
return
true
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Array
)
;
private
:
const
size_t
mCount
;
nsCSSValue
mArray
[
1
]
;
void
*
operator
new
(
size_t
aSelfSize
size_t
aItemCount
)
CPP_THROW_NEW
{
MOZ_ASSERT
(
aItemCount
>
0
"
cannot
have
a
0
item
count
"
)
;
return
:
:
operator
new
(
aSelfSize
+
sizeof
(
nsCSSValue
)
*
(
aItemCount
-
1
)
)
;
}
void
operator
delete
(
void
*
aPtr
)
{
:
:
operator
delete
(
aPtr
)
;
}
nsCSSValue
*
First
(
)
{
return
mArray
;
}
const
nsCSSValue
*
First
(
)
const
{
return
mArray
;
}
#
define
CSSVALUE_LIST_FOR_EXTRA_VALUES
(
var
)
\
for
(
nsCSSValue
*
var
=
First
(
)
+
1
*
var
#
#
_end
=
First
(
)
+
mCount
;
\
var
!
=
var
#
#
_end
;
+
+
var
)
explicit
Array
(
size_t
aItemCount
)
:
mRefCnt
(
0
)
mCount
(
aItemCount
)
{
CSSVALUE_LIST_FOR_EXTRA_VALUES
(
val
)
{
new
(
val
)
nsCSSValue
(
)
;
}
}
~
Array
(
)
{
CSSVALUE_LIST_FOR_EXTRA_VALUES
(
val
)
{
val
-
>
~
nsCSSValue
(
)
;
}
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
#
undef
CSSVALUE_LIST_FOR_EXTRA_VALUES
private
:
Array
(
const
Array
&
aOther
)
=
delete
;
Array
&
operator
=
(
const
Array
&
aOther
)
=
delete
;
}
;
struct
nsCSSValueList
{
nsCSSValueList
(
)
:
mNext
(
nullptr
)
{
MOZ_COUNT_CTOR
(
nsCSSValueList
)
;
}
~
nsCSSValueList
(
)
;
nsCSSValueList
*
Clone
(
)
const
;
void
CloneInto
(
nsCSSValueList
*
aList
)
const
;
static
bool
Equal
(
const
nsCSSValueList
*
aList1
const
nsCSSValueList
*
aList2
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
nsCSSValue
mValue
;
nsCSSValueList
*
mNext
;
private
:
nsCSSValueList
(
const
nsCSSValueList
&
aCopy
)
:
mValue
(
aCopy
.
mValue
)
mNext
(
nullptr
)
{
MOZ_COUNT_CTOR
(
nsCSSValueList
)
;
}
bool
operator
=
=
(
nsCSSValueList
const
&
aOther
)
const
=
delete
;
bool
operator
!
=
(
const
nsCSSValueList
&
aOther
)
const
=
delete
;
}
;
struct
nsCSSValueList_heap
final
:
public
nsCSSValueList
{
NS_INLINE_DECL_REFCOUNTING
(
nsCSSValueList_heap
)
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
~
nsCSSValueList_heap
(
)
{
}
}
;
struct
nsCSSValueSharedList
final
{
nsCSSValueSharedList
(
)
:
mHead
(
nullptr
)
{
}
explicit
nsCSSValueSharedList
(
nsCSSValueList
*
aList
)
:
mHead
(
aList
)
{
}
private
:
~
nsCSSValueSharedList
(
)
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
nsCSSValueSharedList
)
bool
operator
=
=
(
nsCSSValueSharedList
const
&
aOther
)
const
;
bool
operator
!
=
(
const
nsCSSValueSharedList
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
nsCSSValueList
*
mHead
;
}
;
inline
nsCSSValueList
*
nsCSSValue
:
:
GetListValue
(
)
{
if
(
mUnit
=
=
eCSSUnit_List
)
return
mValue
.
mList
;
else
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_ListDep
"
not
a
list
value
"
)
;
return
mValue
.
mListDependent
;
}
}
inline
const
nsCSSValueList
*
nsCSSValue
:
:
GetListValue
(
)
const
{
if
(
mUnit
=
=
eCSSUnit_List
)
return
mValue
.
mList
;
else
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_ListDep
"
not
a
list
value
"
)
;
return
mValue
.
mListDependent
;
}
}
struct
nsCSSValuePair
{
nsCSSValuePair
(
)
{
MOZ_COUNT_CTOR
(
nsCSSValuePair
)
;
}
explicit
nsCSSValuePair
(
nsCSSUnit
aUnit
)
:
mXValue
(
aUnit
)
mYValue
(
aUnit
)
{
MOZ_COUNT_CTOR
(
nsCSSValuePair
)
;
}
nsCSSValuePair
(
const
nsCSSValue
&
aXValue
const
nsCSSValue
&
aYValue
)
:
mXValue
(
aXValue
)
mYValue
(
aYValue
)
{
MOZ_COUNT_CTOR
(
nsCSSValuePair
)
;
}
nsCSSValuePair
(
const
nsCSSValuePair
&
aCopy
)
:
mXValue
(
aCopy
.
mXValue
)
mYValue
(
aCopy
.
mYValue
)
{
MOZ_COUNT_CTOR
(
nsCSSValuePair
)
;
}
~
nsCSSValuePair
(
)
{
MOZ_COUNT_DTOR
(
nsCSSValuePair
)
;
}
nsCSSValuePair
&
operator
=
(
const
nsCSSValuePair
&
aOther
)
{
mXValue
=
aOther
.
mXValue
;
mYValue
=
aOther
.
mYValue
;
return
*
this
;
}
bool
operator
=
=
(
const
nsCSSValuePair
&
aOther
)
const
{
return
mXValue
=
=
aOther
.
mXValue
&
&
mYValue
=
=
aOther
.
mYValue
;
}
bool
operator
!
=
(
const
nsCSSValuePair
&
aOther
)
const
{
return
mXValue
!
=
aOther
.
mXValue
|
|
mYValue
!
=
aOther
.
mYValue
;
}
bool
BothValuesEqualTo
(
const
nsCSSValue
&
aValue
)
const
{
return
mXValue
=
=
aValue
&
&
mYValue
=
=
aValue
;
}
void
SetBothValuesTo
(
const
nsCSSValue
&
aValue
)
{
mXValue
=
aValue
;
mYValue
=
aValue
;
}
void
Reset
(
)
{
mXValue
.
Reset
(
)
;
mYValue
.
Reset
(
)
;
}
bool
HasValue
(
)
const
{
return
mXValue
.
GetUnit
(
)
!
=
eCSSUnit_Null
|
|
mYValue
.
GetUnit
(
)
!
=
eCSSUnit_Null
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
nsCSSValue
mXValue
;
nsCSSValue
mYValue
;
}
;
struct
nsCSSValuePair_heap
final
:
public
nsCSSValuePair
{
nsCSSValuePair_heap
(
const
nsCSSValue
&
aXValue
const
nsCSSValue
&
aYValue
)
:
nsCSSValuePair
(
aXValue
aYValue
)
{
}
NS_INLINE_DECL_REFCOUNTING
(
nsCSSValuePair_heap
)
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
~
nsCSSValuePair_heap
(
)
{
}
}
;
inline
nsCSSValuePair
&
nsCSSValue
:
:
GetPairValue
(
)
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_Pair
"
not
a
pair
value
"
)
;
return
*
mValue
.
mPair
;
}
inline
const
nsCSSValuePair
&
nsCSSValue
:
:
GetPairValue
(
)
const
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_Pair
"
not
a
pair
value
"
)
;
return
*
mValue
.
mPair
;
}
struct
nsCSSValuePairList
{
nsCSSValuePairList
(
)
:
mNext
(
nullptr
)
{
MOZ_COUNT_CTOR
(
nsCSSValuePairList
)
;
}
~
nsCSSValuePairList
(
)
;
nsCSSValuePairList
*
Clone
(
)
const
;
static
bool
Equal
(
const
nsCSSValuePairList
*
aList1
const
nsCSSValuePairList
*
aList2
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
nsCSSValue
mXValue
;
nsCSSValue
mYValue
;
nsCSSValuePairList
*
mNext
;
private
:
nsCSSValuePairList
(
const
nsCSSValuePairList
&
aCopy
)
:
mXValue
(
aCopy
.
mXValue
)
mYValue
(
aCopy
.
mYValue
)
mNext
(
nullptr
)
{
MOZ_COUNT_CTOR
(
nsCSSValuePairList
)
;
}
bool
operator
=
=
(
const
nsCSSValuePairList
&
aOther
)
const
=
delete
;
bool
operator
!
=
(
const
nsCSSValuePairList
&
aOther
)
const
=
delete
;
}
;
struct
nsCSSValuePairList_heap
final
:
public
nsCSSValuePairList
{
NS_INLINE_DECL_REFCOUNTING
(
nsCSSValuePairList_heap
)
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
~
nsCSSValuePairList_heap
(
)
{
}
}
;
inline
nsCSSValuePairList
*
nsCSSValue
:
:
GetPairListValue
(
)
{
if
(
mUnit
=
=
eCSSUnit_PairList
)
return
mValue
.
mPairList
;
else
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_PairListDep
"
not
a
pairlist
value
"
)
;
return
mValue
.
mPairListDependent
;
}
}
inline
const
nsCSSValuePairList
*
nsCSSValue
:
:
GetPairListValue
(
)
const
{
if
(
mUnit
=
=
eCSSUnit_PairList
)
return
mValue
.
mPairList
;
else
{
MOZ_ASSERT
(
mUnit
=
=
eCSSUnit_PairListDep
"
not
a
pairlist
value
"
)
;
return
mValue
.
mPairListDependent
;
}
}
#
endif
