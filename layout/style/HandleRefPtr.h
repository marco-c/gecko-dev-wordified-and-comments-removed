#
include
<
algorithm
>
#
include
"
mozilla
/
Assertions
.
h
"
#
ifndef
mozilla_HandleRefPtr_h
#
define
mozilla_HandleRefPtr_h
namespace
mozilla
{
template
<
typename
T
>
class
HandleRefPtr
{
public
:
HandleRefPtr
(
)
{
}
HandleRefPtr
(
HandleRefPtr
<
T
>
&
aRhs
)
{
assign
(
aRhs
.
mHandle
)
;
}
HandleRefPtr
(
HandleRefPtr
<
T
>
&
&
aRhs
)
{
std
:
:
swap
(
mHandle
aRhs
.
mHandle
)
;
}
MOZ_IMPLICIT
HandleRefPtr
(
T
aRhs
)
{
assign
(
aRhs
)
;
}
HandleRefPtr
<
T
>
&
operator
=
(
HandleRefPtr
<
T
>
&
aRhs
)
{
assign
(
aRhs
.
mHandle
)
;
return
*
this
;
}
HandleRefPtr
<
T
>
&
operator
=
(
T
aRhs
)
{
assign
(
aRhs
)
;
return
*
this
;
}
~
HandleRefPtr
(
)
{
assign
(
nullptr
)
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mHandle
;
}
bool
operator
!
(
)
const
{
return
!
mHandle
;
}
operator
T
(
)
const
{
return
mHandle
;
}
T
operator
-
>
(
)
const
{
return
mHandle
;
}
void
swap
(
HandleRefPtr
<
T
>
&
aOther
)
{
std
:
:
swap
(
mHandle
aOther
.
mHandle
)
;
}
private
:
void
assign
(
T
aPtr
)
{
if
(
aPtr
)
{
aPtr
-
>
AddRef
(
)
;
}
std
:
:
swap
(
mHandle
aPtr
)
;
if
(
aPtr
)
{
aPtr
-
>
Release
(
)
;
}
}
T
mHandle
;
}
;
template
<
typename
T
>
inline
bool
operator
=
=
(
const
HandleRefPtr
<
T
>
&
aLHS
const
HandleRefPtr
<
T
>
&
aRHS
)
{
return
static_cast
<
T
>
(
aLHS
)
=
=
static_cast
<
T
>
(
aRHS
)
;
}
template
<
typename
T
>
inline
bool
operator
=
=
(
const
HandleRefPtr
<
T
>
&
aLHS
T
aRHS
)
{
return
static_cast
<
T
>
(
aLHS
)
=
=
aRHS
;
}
template
<
typename
T
>
inline
bool
operator
=
=
(
T
aLHS
const
HandleRefPtr
<
T
>
&
aRHS
)
{
return
aLHS
=
=
static_cast
<
T
>
(
aRHS
)
;
}
template
<
typename
T
>
inline
bool
operator
!
=
(
const
HandleRefPtr
<
T
>
&
aLHS
const
HandleRefPtr
<
T
>
&
aRHS
)
{
return
!
(
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
inline
bool
operator
!
=
(
const
HandleRefPtr
<
T
>
&
aLHS
T
aRHS
)
{
return
!
(
aLHS
=
=
aRHS
)
;
}
template
<
typename
T
>
inline
bool
operator
!
=
(
T
aLHS
const
HandleRefPtr
<
T
>
&
aRHS
)
{
return
!
(
aLHS
=
=
aRHS
)
;
}
}
#
endif
