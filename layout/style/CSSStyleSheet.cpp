#
include
"
mozilla
/
CSSStyleSheet
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsCSSRuleProcessor
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
css
/
NameSpaceRule
.
h
"
#
include
"
mozilla
/
css
/
GroupRule
.
h
"
#
include
"
mozilla
/
css
/
ImportRule
.
h
"
#
include
"
nsCSSRules
.
h
"
#
include
"
nsMediaList
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIDOMCSSStyleSheet
.
h
"
#
include
"
mozilla
/
dom
/
CSSRuleList
.
h
"
#
include
"
nsIDOMMediaList
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsCSSParser
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsICSSLoaderObserver
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsXMLNameSpaceMap
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsRuleNode
.
h
"
#
include
"
nsMediaFeatures
.
h
"
#
include
"
nsDOMClassInfoID
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsNullPrincipal
.
h
"
#
include
"
mozilla
/
RuleProcessorCache
.
h
"
#
include
"
nsIStyleSheetLinkingElement
.
h
"
#
include
"
nsDOMWindowUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
CSSRuleListImpl
final
:
public
CSSRuleList
{
public
:
explicit
CSSRuleListImpl
(
CSSStyleSheet
*
aStyleSheet
)
;
virtual
CSSStyleSheet
*
GetParentObject
(
)
override
;
virtual
css
:
:
Rule
*
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
override
;
virtual
uint32_t
Length
(
)
override
;
void
DropReference
(
)
{
mStyleSheet
=
nullptr
;
}
protected
:
virtual
~
CSSRuleListImpl
(
)
;
CSSStyleSheet
*
mStyleSheet
;
}
;
CSSRuleListImpl
:
:
CSSRuleListImpl
(
CSSStyleSheet
*
aStyleSheet
)
{
mStyleSheet
=
aStyleSheet
;
}
CSSRuleListImpl
:
:
~
CSSRuleListImpl
(
)
{
}
CSSStyleSheet
*
CSSRuleListImpl
:
:
GetParentObject
(
)
{
return
mStyleSheet
;
}
uint32_t
CSSRuleListImpl
:
:
Length
(
)
{
if
(
!
mStyleSheet
)
{
return
0
;
}
return
AssertedCast
<
uint32_t
>
(
mStyleSheet
-
>
StyleRuleCount
(
)
)
;
}
css
:
:
Rule
*
CSSRuleListImpl
:
:
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
{
aFound
=
false
;
if
(
mStyleSheet
)
{
mStyleSheet
-
>
EnsureUniqueInner
(
)
;
css
:
:
Rule
*
rule
=
mStyleSheet
-
>
GetStyleRuleAt
(
aIndex
)
;
if
(
rule
)
{
aFound
=
true
;
return
rule
;
}
}
return
nullptr
;
}
namespace
mozilla
{
CSSStyleSheetInner
:
:
CSSStyleSheetInner
(
CORSMode
aCORSMode
ReferrerPolicy
aReferrerPolicy
const
SRIMetadata
&
aIntegrity
)
:
StyleSheetInfo
(
aCORSMode
aReferrerPolicy
aIntegrity
)
{
MOZ_COUNT_CTOR
(
CSSStyleSheetInner
)
;
}
static
bool
SetStyleSheetReference
(
css
:
:
Rule
*
aRule
void
*
aSheet
)
{
if
(
aRule
)
{
aRule
-
>
SetStyleSheet
(
static_cast
<
CSSStyleSheet
*
>
(
aSheet
)
)
;
}
return
true
;
}
struct
ChildSheetListBuilder
{
RefPtr
<
StyleSheet
>
*
sheetSlot
;
StyleSheet
*
parent
;
void
SetParentLinks
(
StyleSheet
*
aSheet
)
{
aSheet
-
>
mParent
=
parent
;
aSheet
-
>
SetAssociatedDocument
(
parent
-
>
mDocument
parent
-
>
mDocumentAssociationMode
)
;
}
static
void
ReparentChildList
(
StyleSheet
*
aPrimarySheet
StyleSheet
*
aFirstChild
)
{
for
(
StyleSheet
*
child
=
aFirstChild
;
child
;
child
=
child
-
>
mNext
)
{
child
-
>
mParent
=
aPrimarySheet
;
child
-
>
SetAssociatedDocument
(
aPrimarySheet
-
>
mDocument
aPrimarySheet
-
>
mDocumentAssociationMode
)
;
}
}
}
;
bool
CSSStyleSheet
:
:
RebuildChildList
(
css
:
:
Rule
*
aRule
void
*
aBuilder
)
{
int32_t
type
=
aRule
-
>
GetType
(
)
;
if
(
type
<
css
:
:
Rule
:
:
IMPORT_RULE
)
{
return
true
;
}
if
(
type
!
=
css
:
:
Rule
:
:
IMPORT_RULE
)
{
return
false
;
}
ChildSheetListBuilder
*
builder
=
static_cast
<
ChildSheetListBuilder
*
>
(
aBuilder
)
;
nsCOMPtr
<
nsIDOMCSSImportRule
>
importRule
(
do_QueryInterface
(
aRule
)
)
;
NS_ASSERTION
(
importRule
"
GetType
lied
"
)
;
nsCOMPtr
<
nsIDOMCSSStyleSheet
>
childSheet
;
importRule
-
>
GetStyleSheet
(
getter_AddRefs
(
childSheet
)
)
;
RefPtr
<
CSSStyleSheet
>
sheet
=
do_QueryObject
(
childSheet
)
;
if
(
!
sheet
)
{
return
true
;
}
(
*
builder
-
>
sheetSlot
)
=
sheet
;
builder
-
>
SetParentLinks
(
*
builder
-
>
sheetSlot
)
;
builder
-
>
sheetSlot
=
&
(
*
builder
-
>
sheetSlot
)
-
>
mNext
;
return
true
;
}
size_t
CSSStyleSheet
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
StyleSheet
:
:
SizeOfIncludingThis
(
aMallocSizeOf
)
;
const
CSSStyleSheet
*
s
=
this
;
while
(
s
)
{
if
(
mInner
-
>
mSheets
.
LastElement
(
)
=
=
s
)
{
n
+
=
Inner
(
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
s
=
s
-
>
mNext
?
s
-
>
mNext
-
>
AsGecko
(
)
:
nullptr
;
}
return
n
;
}
CSSStyleSheetInner
:
:
CSSStyleSheetInner
(
CSSStyleSheetInner
&
aCopy
CSSStyleSheet
*
aPrimarySheet
)
:
StyleSheetInfo
(
aCopy
aPrimarySheet
)
{
MOZ_COUNT_CTOR
(
CSSStyleSheetInner
)
;
aCopy
.
mOrderedRules
.
EnumerateForwards
(
css
:
:
GroupRule
:
:
CloneRuleInto
&
mOrderedRules
)
;
mOrderedRules
.
EnumerateForwards
(
SetStyleSheetReference
aPrimarySheet
)
;
ChildSheetListBuilder
builder
=
{
&
mFirstChild
aPrimarySheet
}
;
mOrderedRules
.
EnumerateForwards
(
CSSStyleSheet
:
:
RebuildChildList
&
builder
)
;
RebuildNameSpaces
(
)
;
}
CSSStyleSheetInner
:
:
~
CSSStyleSheetInner
(
)
{
MOZ_COUNT_DTOR
(
CSSStyleSheetInner
)
;
mOrderedRules
.
EnumerateForwards
(
SetStyleSheetReference
nullptr
)
;
}
CSSStyleSheetInner
*
CSSStyleSheetInner
:
:
CloneFor
(
CSSStyleSheet
*
aPrimarySheet
)
{
return
new
CSSStyleSheetInner
(
*
this
aPrimarySheet
)
;
}
void
CSSStyleSheetInner
:
:
RemoveSheet
(
StyleSheet
*
aSheet
)
{
if
(
(
aSheet
=
=
mSheets
.
ElementAt
(
0
)
)
&
&
(
mSheets
.
Length
(
)
>
1
)
)
{
mOrderedRules
.
EnumerateForwards
(
SetStyleSheetReference
mSheets
[
1
]
)
;
ChildSheetListBuilder
:
:
ReparentChildList
(
mSheets
[
1
]
mFirstChild
)
;
}
StyleSheetInfo
:
:
RemoveSheet
(
aSheet
)
;
}
static
void
AddNamespaceRuleToMap
(
css
:
:
Rule
*
aRule
nsXMLNameSpaceMap
*
aMap
)
{
NS_ASSERTION
(
aRule
-
>
GetType
(
)
=
=
css
:
:
Rule
:
:
NAMESPACE_RULE
"
Bogus
rule
type
"
)
;
RefPtr
<
css
:
:
NameSpaceRule
>
nameSpaceRule
=
do_QueryObject
(
aRule
)
;
nsAutoString
urlSpec
;
nameSpaceRule
-
>
GetURLSpec
(
urlSpec
)
;
aMap
-
>
AddPrefix
(
nameSpaceRule
-
>
GetPrefix
(
)
urlSpec
)
;
}
static
bool
CreateNameSpace
(
css
:
:
Rule
*
aRule
void
*
aNameSpacePtr
)
{
int32_t
type
=
aRule
-
>
GetType
(
)
;
if
(
css
:
:
Rule
:
:
NAMESPACE_RULE
=
=
type
)
{
AddNamespaceRuleToMap
(
aRule
static_cast
<
nsXMLNameSpaceMap
*
>
(
aNameSpacePtr
)
)
;
return
true
;
}
return
(
css
:
:
Rule
:
:
CHARSET_RULE
=
=
type
|
|
css
:
:
Rule
:
:
IMPORT_RULE
=
=
type
)
;
}
void
CSSStyleSheetInner
:
:
RebuildNameSpaces
(
)
{
if
(
NS_SUCCEEDED
(
CreateNamespaceMap
(
)
)
)
{
mOrderedRules
.
EnumerateForwards
(
CreateNameSpace
mNameSpaceMap
)
;
}
}
nsresult
CSSStyleSheetInner
:
:
CreateNamespaceMap
(
)
{
mNameSpaceMap
=
nsXMLNameSpaceMap
:
:
Create
(
false
)
;
NS_ENSURE_TRUE
(
mNameSpaceMap
NS_ERROR_OUT_OF_MEMORY
)
;
mNameSpaceMap
-
>
AddPrefix
(
nullptr
kNameSpaceID_Unknown
)
;
return
NS_OK
;
}
size_t
CSSStyleSheetInner
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mOrderedRules
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
size_t
i
=
0
;
i
<
mOrderedRules
.
Length
(
)
;
i
+
+
)
{
n
+
=
mOrderedRules
[
i
]
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
n
+
=
mFirstChild
?
mFirstChild
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
:
0
;
return
n
;
}
CSSStyleSheet
:
:
CSSStyleSheet
(
css
:
:
SheetParsingMode
aParsingMode
CORSMode
aCORSMode
ReferrerPolicy
aReferrerPolicy
)
:
StyleSheet
(
StyleBackendType
:
:
Gecko
aParsingMode
)
mOwnerRule
(
nullptr
)
mDirty
(
false
)
mInRuleProcessorCache
(
false
)
mScopeElement
(
nullptr
)
mRuleProcessors
(
nullptr
)
{
mInner
=
new
CSSStyleSheetInner
(
aCORSMode
aReferrerPolicy
SRIMetadata
(
)
)
;
mInner
-
>
AddSheet
(
this
)
;
}
CSSStyleSheet
:
:
CSSStyleSheet
(
css
:
:
SheetParsingMode
aParsingMode
CORSMode
aCORSMode
ReferrerPolicy
aReferrerPolicy
const
SRIMetadata
&
aIntegrity
)
:
StyleSheet
(
StyleBackendType
:
:
Gecko
aParsingMode
)
mOwnerRule
(
nullptr
)
mDirty
(
false
)
mInRuleProcessorCache
(
false
)
mScopeElement
(
nullptr
)
mRuleProcessors
(
nullptr
)
{
mInner
=
new
CSSStyleSheetInner
(
aCORSMode
aReferrerPolicy
aIntegrity
)
;
mInner
-
>
AddSheet
(
this
)
;
}
CSSStyleSheet
:
:
CSSStyleSheet
(
const
CSSStyleSheet
&
aCopy
CSSStyleSheet
*
aParentToUse
css
:
:
ImportRule
*
aOwnerRuleToUse
nsIDocument
*
aDocumentToUse
nsINode
*
aOwningNodeToUse
)
:
StyleSheet
(
aCopy
aDocumentToUse
aOwningNodeToUse
)
mOwnerRule
(
aOwnerRuleToUse
)
mDirty
(
aCopy
.
mDirty
)
mInRuleProcessorCache
(
false
)
mScopeElement
(
nullptr
)
mRuleProcessors
(
nullptr
)
{
MOZ_ASSERT
(
mInner
"
We
should
have
an
mInner
after
copy
.
"
)
;
MOZ_ASSERT
(
mInner
-
>
mSheets
.
Contains
(
this
)
"
Our
mInner
should
include
us
.
"
)
;
mParent
=
aParentToUse
;
if
(
mDirty
)
{
NS_ASSERTION
(
mInner
-
>
mComplete
"
Why
have
rules
been
accessed
on
an
incomplete
sheet
?
"
)
;
EnsureUniqueInner
(
)
;
}
}
CSSStyleSheet
:
:
~
CSSStyleSheet
(
)
{
UnparentChildren
(
)
;
DropRuleCollection
(
)
;
if
(
mRuleProcessors
)
{
NS_ASSERTION
(
mRuleProcessors
-
>
Length
(
)
=
=
0
"
destructing
sheet
with
rule
processor
reference
"
)
;
delete
mRuleProcessors
;
}
if
(
mInRuleProcessorCache
)
{
RuleProcessorCache
:
:
RemoveSheet
(
this
)
;
}
}
void
CSSStyleSheet
:
:
DropRuleCollection
(
)
{
if
(
mRuleCollection
)
{
mRuleCollection
-
>
DropReference
(
)
;
mRuleCollection
=
nullptr
;
}
}
void
CSSStyleSheet
:
:
UnlinkInner
(
)
{
if
(
mInner
-
>
mSheets
.
Length
(
)
!
=
1
)
{
return
;
}
Inner
(
)
-
>
mOrderedRules
.
EnumerateForwards
(
SetStyleSheetReference
nullptr
)
;
Inner
(
)
-
>
mOrderedRules
.
Clear
(
)
;
RefPtr
<
StyleSheet
>
child
;
child
.
swap
(
SheetInfo
(
)
.
mFirstChild
)
;
while
(
child
)
{
MOZ_ASSERT
(
child
-
>
mParent
=
=
this
"
We
have
a
unique
inner
!
"
)
;
child
-
>
mParent
=
nullptr
;
child
-
>
mDocument
=
nullptr
;
RefPtr
<
StyleSheet
>
next
;
next
.
swap
(
child
-
>
mNext
)
;
child
.
swap
(
next
)
;
}
}
void
CSSStyleSheet
:
:
TraverseInner
(
nsCycleCollectionTraversalCallback
&
cb
)
{
if
(
mInner
-
>
mSheets
.
Length
(
)
!
=
1
)
{
return
;
}
StyleSheet
*
childSheet
=
GetFirstChild
(
)
;
while
(
childSheet
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
child
sheet
"
)
;
cb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsIDOMCSSStyleSheet
*
childSheet
)
)
;
childSheet
=
childSheet
-
>
mNext
;
}
const
nsCOMArray
<
css
:
:
Rule
>
&
rules
=
Inner
(
)
-
>
mOrderedRules
;
for
(
int32_t
i
=
0
count
=
rules
.
Count
(
)
;
i
<
count
;
+
+
i
)
{
if
(
!
rules
[
i
]
-
>
IsCCLeaf
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mOrderedRules
[
i
]
"
)
;
cb
.
NoteXPCOMChild
(
rules
[
i
]
)
;
}
}
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
CSSStyleSheet
)
NS_INTERFACE_MAP_ENTRY
(
nsICSSLoaderObserver
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
StyleSheet
)
if
(
aIID
.
Equals
(
NS_GET_IID
(
CSSStyleSheet
)
)
)
foundInterface
=
reinterpret_cast
<
nsISupports
*
>
(
this
)
;
else
NS_INTERFACE_MAP_END_INHERITING
(
StyleSheet
)
NS_IMPL_ADDREF_INHERITED
(
CSSStyleSheet
StyleSheet
)
NS_IMPL_RELEASE_INHERITED
(
CSSStyleSheet
StyleSheet
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
CSSStyleSheet
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
CSSStyleSheet
)
tmp
-
>
DropRuleCollection
(
)
;
tmp
-
>
UnlinkInner
(
)
;
tmp
-
>
mScopeElement
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END_INHERITED
(
StyleSheet
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
CSSStyleSheet
StyleSheet
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRuleCollection
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScopeElement
)
tmp
-
>
TraverseInner
(
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
nsresult
CSSStyleSheet
:
:
AddRuleProcessor
(
nsCSSRuleProcessor
*
aProcessor
)
{
if
(
!
mRuleProcessors
)
{
mRuleProcessors
=
new
AutoTArray
<
nsCSSRuleProcessor
*
8
>
(
)
;
if
(
!
mRuleProcessors
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
NS_ASSERTION
(
mRuleProcessors
-
>
NoIndex
=
=
mRuleProcessors
-
>
IndexOf
(
aProcessor
)
"
processor
already
registered
"
)
;
mRuleProcessors
-
>
AppendElement
(
aProcessor
)
;
return
NS_OK
;
}
nsresult
CSSStyleSheet
:
:
DropRuleProcessor
(
nsCSSRuleProcessor
*
aProcessor
)
{
if
(
!
mRuleProcessors
)
return
NS_ERROR_FAILURE
;
return
mRuleProcessors
-
>
RemoveElement
(
aProcessor
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
CSSStyleSheet
:
:
AddStyleSet
(
nsStyleSet
*
aStyleSet
)
{
NS_ASSERTION
(
!
mStyleSets
.
Contains
(
aStyleSet
)
"
style
set
already
registered
"
)
;
mStyleSets
.
AppendElement
(
aStyleSet
)
;
}
void
CSSStyleSheet
:
:
DropStyleSet
(
nsStyleSet
*
aStyleSet
)
{
DebugOnly
<
bool
>
found
=
mStyleSets
.
RemoveElement
(
aStyleSet
)
;
NS_ASSERTION
(
found
"
didn
'
t
find
style
set
"
)
;
}
bool
CSSStyleSheet
:
:
UseForPresentation
(
nsPresContext
*
aPresContext
nsMediaQueryResultCacheKey
&
aKey
)
const
{
if
(
mMedia
)
{
return
mMedia
-
>
Matches
(
aPresContext
&
aKey
)
;
}
return
true
;
}
bool
CSSStyleSheet
:
:
HasRules
(
)
const
{
return
StyleRuleCount
(
)
!
=
0
;
}
void
CSSStyleSheet
:
:
EnabledStateChangedInternal
(
)
{
ClearRuleCascades
(
)
;
}
uint64_t
CSSStyleSheet
:
:
FindOwningWindowInnerID
(
)
const
{
uint64_t
windowID
=
0
;
if
(
mDocument
)
{
windowID
=
mDocument
-
>
InnerWindowID
(
)
;
}
if
(
windowID
=
=
0
&
&
mOwningNode
)
{
windowID
=
mOwningNode
-
>
OwnerDoc
(
)
-
>
InnerWindowID
(
)
;
}
if
(
windowID
=
=
0
&
&
mOwnerRule
)
{
RefPtr
<
StyleSheet
>
sheet
=
static_cast
<
css
:
:
Rule
*
>
(
mOwnerRule
)
-
>
GetStyleSheet
(
)
;
if
(
sheet
)
{
windowID
=
sheet
-
>
AsGecko
(
)
-
>
FindOwningWindowInnerID
(
)
;
}
}
if
(
windowID
=
=
0
&
&
mParent
)
{
CSSStyleSheet
*
parentAsCSS
=
mParent
-
>
AsGecko
(
)
;
windowID
=
parentAsCSS
-
>
FindOwningWindowInnerID
(
)
;
}
return
windowID
;
}
void
CSSStyleSheet
:
:
AppendStyleRule
(
css
:
:
Rule
*
aRule
)
{
NS_PRECONDITION
(
nullptr
!
=
aRule
"
null
arg
"
)
;
WillDirty
(
)
;
Inner
(
)
-
>
mOrderedRules
.
AppendObject
(
aRule
)
;
aRule
-
>
SetStyleSheet
(
this
)
;
DidDirty
(
)
;
if
(
css
:
:
Rule
:
:
NAMESPACE_RULE
=
=
aRule
-
>
GetType
(
)
)
{
#
ifdef
DEBUG
nsresult
rv
=
#
endif
RegisterNamespaceRule
(
aRule
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RegisterNamespaceRule
returned
error
"
)
;
}
}
int32_t
CSSStyleSheet
:
:
StyleRuleCount
(
)
const
{
return
Inner
(
)
-
>
mOrderedRules
.
Count
(
)
;
}
css
:
:
Rule
*
CSSStyleSheet
:
:
GetStyleRuleAt
(
int32_t
aIndex
)
const
{
return
Inner
(
)
-
>
mOrderedRules
.
SafeObjectAt
(
aIndex
)
;
}
void
CSSStyleSheet
:
:
EnsureUniqueInner
(
)
{
mDirty
=
true
;
MOZ_ASSERT
(
mInner
-
>
mSheets
.
Length
(
)
!
=
0
"
unexpected
number
of
outers
"
)
;
if
(
mInner
-
>
mSheets
.
Length
(
)
=
=
1
)
{
return
;
}
CSSStyleSheetInner
*
clone
=
Inner
(
)
-
>
CloneFor
(
this
)
;
MOZ_ASSERT
(
clone
)
;
mInner
-
>
RemoveSheet
(
this
)
;
mInner
=
clone
;
ClearRuleCascades
(
)
;
for
(
nsStyleSet
*
styleSet
:
mStyleSets
)
{
styleSet
-
>
SetNeedsRestyleAfterEnsureUniqueInner
(
)
;
}
}
void
CSSStyleSheet
:
:
AppendAllChildSheets
(
nsTArray
<
CSSStyleSheet
*
>
&
aArray
)
{
for
(
StyleSheet
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
mNext
)
{
aArray
.
AppendElement
(
child
-
>
AsGecko
(
)
)
;
}
}
already_AddRefed
<
CSSStyleSheet
>
CSSStyleSheet
:
:
Clone
(
CSSStyleSheet
*
aCloneParent
css
:
:
ImportRule
*
aCloneOwnerRule
nsIDocument
*
aCloneDocument
nsINode
*
aCloneOwningNode
)
const
{
RefPtr
<
CSSStyleSheet
>
clone
=
new
CSSStyleSheet
(
*
this
aCloneParent
aCloneOwnerRule
aCloneDocument
aCloneOwningNode
)
;
return
clone
.
forget
(
)
;
}
#
ifdef
DEBUG
static
void
ListRules
(
const
nsCOMArray
<
css
:
:
Rule
>
&
aRules
FILE
*
aOut
int32_t
aIndent
)
{
for
(
int32_t
index
=
aRules
.
Count
(
)
-
1
;
index
>
=
0
;
-
-
index
)
{
aRules
.
ObjectAt
(
index
)
-
>
List
(
aOut
aIndent
)
;
}
}
void
CSSStyleSheet
:
:
List
(
FILE
*
out
int32_t
aIndent
)
const
{
StyleSheet
:
:
List
(
out
aIndent
)
;
fprintf_stderr
(
out
"
%
s
"
"
Rules
in
source
order
:
\
n
"
)
;
ListRules
(
Inner
(
)
-
>
mOrderedRules
out
aIndent
)
;
}
#
endif
void
CSSStyleSheet
:
:
ClearRuleCascades
(
)
{
for
(
nsStyleSet
*
styleSet
:
mStyleSets
)
{
styleSet
-
>
ClearSelectors
(
)
;
}
bool
removedSheetFromRuleProcessorCache
=
false
;
if
(
mRuleProcessors
)
{
nsCSSRuleProcessor
*
*
iter
=
mRuleProcessors
-
>
Elements
(
)
*
*
end
=
iter
+
mRuleProcessors
-
>
Length
(
)
;
for
(
;
iter
!
=
end
;
+
+
iter
)
{
if
(
!
removedSheetFromRuleProcessorCache
&
&
(
*
iter
)
-
>
IsShared
(
)
)
{
RuleProcessorCache
:
:
RemoveSheet
(
this
)
;
removedSheetFromRuleProcessorCache
=
true
;
}
(
*
iter
)
-
>
ClearRuleCascades
(
)
;
}
}
if
(
mParent
)
{
CSSStyleSheet
*
parent
=
(
CSSStyleSheet
*
)
mParent
;
parent
-
>
ClearRuleCascades
(
)
;
}
}
void
CSSStyleSheet
:
:
WillDirty
(
)
{
if
(
mInner
-
>
mComplete
)
{
EnsureUniqueInner
(
)
;
}
}
void
CSSStyleSheet
:
:
DidDirty
(
)
{
MOZ_ASSERT
(
!
mInner
-
>
mComplete
|
|
mDirty
"
caller
must
have
called
WillDirty
(
)
"
)
;
ClearRuleCascades
(
)
;
}
nsresult
CSSStyleSheet
:
:
RegisterNamespaceRule
(
css
:
:
Rule
*
aRule
)
{
if
(
!
Inner
(
)
-
>
mNameSpaceMap
)
{
nsresult
rv
=
Inner
(
)
-
>
CreateNamespaceMap
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
AddNamespaceRuleToMap
(
aRule
Inner
(
)
-
>
mNameSpaceMap
)
;
return
NS_OK
;
}
css
:
:
Rule
*
CSSStyleSheet
:
:
GetDOMOwnerRule
(
)
const
{
return
mOwnerRule
;
}
CSSRuleList
*
CSSStyleSheet
:
:
GetCssRulesInternal
(
ErrorResult
&
aRv
)
{
if
(
!
mRuleCollection
)
{
mRuleCollection
=
new
CSSRuleListImpl
(
this
)
;
}
return
mRuleCollection
;
}
static
bool
RuleHasPendingChildSheet
(
css
:
:
Rule
*
cssRule
)
{
nsCOMPtr
<
nsIDOMCSSImportRule
>
importRule
(
do_QueryInterface
(
cssRule
)
)
;
NS_ASSERTION
(
importRule
"
Rule
which
has
type
IMPORT_RULE
and
does
not
implement
nsIDOMCSSImportRule
!
"
)
;
nsCOMPtr
<
nsIDOMCSSStyleSheet
>
childSheet
;
importRule
-
>
GetStyleSheet
(
getter_AddRefs
(
childSheet
)
)
;
RefPtr
<
CSSStyleSheet
>
cssSheet
=
do_QueryObject
(
childSheet
)
;
return
cssSheet
!
=
nullptr
&
&
!
cssSheet
-
>
IsComplete
(
)
;
}
uint32_t
CSSStyleSheet
:
:
InsertRuleInternal
(
const
nsAString
&
aRule
uint32_t
aIndex
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mInner
-
>
mComplete
)
;
WillDirty
(
)
;
if
(
aIndex
>
uint32_t
(
Inner
(
)
-
>
mOrderedRules
.
Count
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
0
;
}
NS_ASSERTION
(
uint32_t
(
Inner
(
)
-
>
mOrderedRules
.
Count
(
)
)
<
=
INT32_MAX
"
Too
many
style
rules
!
"
)
;
RefPtr
<
css
:
:
Loader
>
loader
;
if
(
mDocument
)
{
loader
=
mDocument
-
>
CSSLoader
(
)
;
NS_ASSERTION
(
loader
"
Document
with
no
CSS
loader
!
"
)
;
}
nsCSSParser
css
(
loader
this
)
;
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
RefPtr
<
css
:
:
Rule
>
rule
;
aRv
=
css
.
ParseRule
(
aRule
mInner
-
>
mSheetURI
mInner
-
>
mBaseURI
mInner
-
>
mPrincipal
getter_AddRefs
(
rule
)
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
0
;
}
int32_t
newType
=
rule
-
>
GetType
(
)
;
css
:
:
Rule
*
nextRule
=
Inner
(
)
-
>
mOrderedRules
.
SafeObjectAt
(
aIndex
)
;
if
(
nextRule
)
{
int32_t
nextType
=
nextRule
-
>
GetType
(
)
;
if
(
nextType
=
=
css
:
:
Rule
:
:
CHARSET_RULE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
0
;
}
if
(
nextType
=
=
css
:
:
Rule
:
:
IMPORT_RULE
&
&
newType
!
=
css
:
:
Rule
:
:
CHARSET_RULE
&
&
newType
!
=
css
:
:
Rule
:
:
IMPORT_RULE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
0
;
}
if
(
nextType
=
=
css
:
:
Rule
:
:
NAMESPACE_RULE
&
&
newType
!
=
css
:
:
Rule
:
:
CHARSET_RULE
&
&
newType
!
=
css
:
:
Rule
:
:
IMPORT_RULE
&
&
newType
!
=
css
:
:
Rule
:
:
NAMESPACE_RULE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
0
;
}
}
if
(
aIndex
!
=
0
)
{
if
(
newType
=
=
css
:
:
Rule
:
:
CHARSET_RULE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
0
;
}
css
:
:
Rule
*
prevRule
=
Inner
(
)
-
>
mOrderedRules
.
SafeObjectAt
(
aIndex
-
1
)
;
int32_t
prevType
=
prevRule
-
>
GetType
(
)
;
if
(
newType
=
=
css
:
:
Rule
:
:
IMPORT_RULE
&
&
prevType
!
=
css
:
:
Rule
:
:
CHARSET_RULE
&
&
prevType
!
=
css
:
:
Rule
:
:
IMPORT_RULE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
0
;
}
if
(
newType
=
=
css
:
:
Rule
:
:
NAMESPACE_RULE
&
&
prevType
!
=
css
:
:
Rule
:
:
CHARSET_RULE
&
&
prevType
!
=
css
:
:
Rule
:
:
IMPORT_RULE
&
&
prevType
!
=
css
:
:
Rule
:
:
NAMESPACE_RULE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
0
;
}
}
if
(
!
Inner
(
)
-
>
mOrderedRules
.
InsertObjectAt
(
rule
aIndex
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
0
;
}
DidDirty
(
)
;
rule
-
>
SetStyleSheet
(
this
)
;
int32_t
type
=
rule
-
>
GetType
(
)
;
if
(
type
=
=
css
:
:
Rule
:
:
NAMESPACE_RULE
)
{
aRv
=
RegisterNamespaceRule
(
rule
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
0
;
}
}
if
(
(
type
!
=
css
:
:
Rule
:
:
IMPORT_RULE
|
|
!
RuleHasPendingChildSheet
(
rule
)
)
&
&
mDocument
)
{
mDocument
-
>
StyleRuleAdded
(
this
rule
)
;
}
return
aIndex
;
}
void
CSSStyleSheet
:
:
DeleteRuleInternal
(
uint32_t
aIndex
ErrorResult
&
aRv
)
{
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
WillDirty
(
)
;
if
(
aIndex
>
=
uint32_t
(
Inner
(
)
-
>
mOrderedRules
.
Count
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
NS_ASSERTION
(
uint32_t
(
Inner
(
)
-
>
mOrderedRules
.
Count
(
)
)
<
=
INT32_MAX
"
Too
many
style
rules
!
"
)
;
RefPtr
<
css
:
:
Rule
>
rule
=
Inner
(
)
-
>
mOrderedRules
.
ObjectAt
(
aIndex
)
;
if
(
rule
)
{
Inner
(
)
-
>
mOrderedRules
.
RemoveObjectAt
(
aIndex
)
;
rule
-
>
SetStyleSheet
(
nullptr
)
;
DidDirty
(
)
;
if
(
mDocument
)
{
mDocument
-
>
StyleRuleRemoved
(
this
rule
)
;
}
}
}
nsresult
CSSStyleSheet
:
:
DeleteRuleFromGroup
(
css
:
:
GroupRule
*
aGroup
uint32_t
aIndex
)
{
NS_ENSURE_ARG_POINTER
(
aGroup
)
;
NS_ASSERTION
(
mInner
-
>
mComplete
"
No
deleting
from
an
incomplete
sheet
!
"
)
;
RefPtr
<
css
:
:
Rule
>
rule
=
aGroup
-
>
GetStyleRuleAt
(
aIndex
)
;
NS_ENSURE_TRUE
(
rule
NS_ERROR_ILLEGAL_VALUE
)
;
if
(
this
!
=
rule
-
>
GetStyleSheet
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
WillDirty
(
)
;
nsresult
result
=
aGroup
-
>
DeleteStyleRuleAt
(
aIndex
)
;
NS_ENSURE_SUCCESS
(
result
result
)
;
rule
-
>
SetStyleSheet
(
nullptr
)
;
DidDirty
(
)
;
if
(
mDocument
)
{
mDocument
-
>
StyleRuleRemoved
(
this
rule
)
;
}
return
NS_OK
;
}
nsresult
CSSStyleSheet
:
:
InsertRuleIntoGroup
(
const
nsAString
&
aRule
css
:
:
GroupRule
*
aGroup
uint32_t
aIndex
uint32_t
*
_retval
)
{
NS_ASSERTION
(
mInner
-
>
mComplete
"
No
inserting
into
an
incomplete
sheet
!
"
)
;
if
(
this
!
=
aGroup
-
>
GetStyleSheet
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
css
:
:
Loader
>
loader
;
if
(
mDocument
)
{
loader
=
mDocument
-
>
CSSLoader
(
)
;
NS_ASSERTION
(
loader
"
Document
with
no
CSS
loader
!
"
)
;
}
nsCSSParser
css
(
loader
this
)
;
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
WillDirty
(
)
;
RefPtr
<
css
:
:
Rule
>
rule
;
nsresult
result
=
css
.
ParseRule
(
aRule
mInner
-
>
mSheetURI
mInner
-
>
mBaseURI
mInner
-
>
mPrincipal
getter_AddRefs
(
rule
)
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
switch
(
rule
-
>
GetType
(
)
)
{
case
css
:
:
Rule
:
:
STYLE_RULE
:
case
css
:
:
Rule
:
:
MEDIA_RULE
:
case
css
:
:
Rule
:
:
FONT_FACE_RULE
:
case
css
:
:
Rule
:
:
PAGE_RULE
:
case
css
:
:
Rule
:
:
KEYFRAMES_RULE
:
case
css
:
:
Rule
:
:
COUNTER_STYLE_RULE
:
case
css
:
:
Rule
:
:
DOCUMENT_RULE
:
case
css
:
:
Rule
:
:
SUPPORTS_RULE
:
break
;
case
css
:
:
Rule
:
:
CHARSET_RULE
:
case
css
:
:
Rule
:
:
IMPORT_RULE
:
case
css
:
:
Rule
:
:
NAMESPACE_RULE
:
return
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
;
default
:
NS_NOTREACHED
(
"
unexpected
rule
type
"
)
;
return
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
;
}
result
=
aGroup
-
>
InsertStyleRuleAt
(
aIndex
rule
)
;
NS_ENSURE_SUCCESS
(
result
result
)
;
DidDirty
(
)
;
if
(
mDocument
)
{
mDocument
-
>
StyleRuleAdded
(
this
rule
)
;
}
*
_retval
=
aIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
CSSStyleSheet
:
:
StyleSheetLoaded
(
StyleSheet
*
aSheet
bool
aWasAlternate
nsresult
aStatus
)
{
MOZ_ASSERT
(
aSheet
-
>
IsGecko
(
)
"
why
we
were
called
back
with
a
ServoStyleSheet
?
"
)
;
CSSStyleSheet
*
sheet
=
aSheet
-
>
AsGecko
(
)
;
if
(
sheet
-
>
GetParentSheet
(
)
=
=
nullptr
)
{
return
NS_OK
;
}
NS_ASSERTION
(
this
=
=
sheet
-
>
GetParentSheet
(
)
"
We
are
being
notified
of
a
sheet
load
for
a
sheet
that
is
not
our
child
!
"
)
;
if
(
mDocument
&
&
NS_SUCCEEDED
(
aStatus
)
)
{
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
mDocument
-
>
StyleRuleAdded
(
this
sheet
-
>
GetOwnerRule
(
)
)
;
}
return
NS_OK
;
}
nsresult
CSSStyleSheet
:
:
ReparseSheet
(
const
nsAString
&
aInput
)
{
if
(
!
mInner
-
>
mComplete
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
RefPtr
<
css
:
:
Loader
>
loader
;
if
(
mDocument
)
{
loader
=
mDocument
-
>
CSSLoader
(
)
;
NS_ASSERTION
(
loader
"
Document
with
no
CSS
loader
!
"
)
;
}
else
{
loader
=
new
css
:
:
Loader
(
StyleBackendType
:
:
Gecko
)
;
}
mozAutoDocUpdate
updateBatch
(
mDocument
UPDATE_STYLE
true
)
;
WillDirty
(
)
;
css
:
:
LoaderReusableStyleSheets
reusableSheets
;
int
ruleCount
;
while
(
(
ruleCount
=
Inner
(
)
-
>
mOrderedRules
.
Count
(
)
)
!
=
0
)
{
RefPtr
<
css
:
:
Rule
>
rule
=
Inner
(
)
-
>
mOrderedRules
.
ObjectAt
(
ruleCount
-
1
)
;
Inner
(
)
-
>
mOrderedRules
.
RemoveObjectAt
(
ruleCount
-
1
)
;
rule
-
>
SetStyleSheet
(
nullptr
)
;
if
(
rule
-
>
GetType
(
)
=
=
css
:
:
Rule
:
:
IMPORT_RULE
)
{
nsCOMPtr
<
nsIDOMCSSImportRule
>
importRule
(
do_QueryInterface
(
rule
)
)
;
NS_ASSERTION
(
importRule
"
GetType
lied
"
)
;
nsCOMPtr
<
nsIDOMCSSStyleSheet
>
childSheet
;
importRule
-
>
GetStyleSheet
(
getter_AddRefs
(
childSheet
)
)
;
RefPtr
<
CSSStyleSheet
>
cssSheet
=
do_QueryObject
(
childSheet
)
;
if
(
cssSheet
&
&
cssSheet
-
>
GetOriginalURI
(
)
)
{
reusableSheets
.
AddReusableSheet
(
cssSheet
)
;
}
}
if
(
mDocument
)
{
mDocument
-
>
StyleRuleRemoved
(
this
rule
)
;
}
}
for
(
StyleSheet
*
child
=
GetFirstChild
(
)
;
child
;
)
{
NS_ASSERTION
(
child
-
>
mParent
=
=
this
"
Child
sheet
is
not
parented
to
this
!
"
)
;
StyleSheet
*
next
=
child
-
>
mNext
;
child
-
>
mParent
=
nullptr
;
child
-
>
mDocument
=
nullptr
;
child
-
>
mNext
=
nullptr
;
child
=
next
;
}
SheetInfo
(
)
.
mFirstChild
=
nullptr
;
Inner
(
)
-
>
mNameSpaceMap
=
nullptr
;
uint32_t
lineNumber
=
1
;
if
(
mOwningNode
)
{
nsCOMPtr
<
nsIStyleSheetLinkingElement
>
link
=
do_QueryInterface
(
mOwningNode
)
;
if
(
link
)
{
lineNumber
=
link
-
>
GetLineNumber
(
)
;
}
}
nsCSSParser
parser
(
loader
this
)
;
nsresult
rv
=
parser
.
ParseSheet
(
aInput
mInner
-
>
mSheetURI
mInner
-
>
mBaseURI
mInner
-
>
mPrincipal
lineNumber
&
reusableSheets
)
;
DidDirty
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mDocument
)
{
for
(
int32_t
index
=
0
;
index
<
Inner
(
)
-
>
mOrderedRules
.
Count
(
)
;
+
+
index
)
{
RefPtr
<
css
:
:
Rule
>
rule
=
Inner
(
)
-
>
mOrderedRules
.
ObjectAt
(
index
)
;
if
(
rule
-
>
GetType
(
)
=
=
css
:
:
Rule
:
:
IMPORT_RULE
&
&
RuleHasPendingChildSheet
(
rule
)
)
{
continue
;
}
mDocument
-
>
StyleRuleAdded
(
this
rule
)
;
}
}
return
NS_OK
;
}
}
