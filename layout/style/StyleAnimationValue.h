#
ifndef
mozilla_StyleAnimationValue_h_
#
define
mozilla_StyleAnimationValue_h_
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
mozilla
/
DbgMacro
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
"
nsStyleTransformMatrix
.
h
"
class
nsIFrame
;
class
gfx3DMatrix
;
namespace
mozilla
{
class
ComputedStyle
;
namespace
css
{
class
StyleRule
;
}
namespace
dom
{
class
Element
;
}
namespace
layers
{
class
Animatable
;
}
enum
class
PseudoStyleType
:
uint8_t
;
struct
PropertyStyleAnimationValuePair
;
struct
AnimationValue
{
explicit
AnimationValue
(
const
RefPtr
<
RawServoAnimationValue
>
&
aValue
)
:
mServo
(
aValue
)
{
}
AnimationValue
(
)
=
default
;
AnimationValue
(
const
AnimationValue
&
aOther
)
:
mServo
(
aOther
.
mServo
)
{
}
AnimationValue
(
AnimationValue
&
&
aOther
)
:
mServo
(
std
:
:
move
(
aOther
.
mServo
)
)
{
}
AnimationValue
&
operator
=
(
const
AnimationValue
&
aOther
)
{
if
(
this
!
=
&
aOther
)
{
mServo
=
aOther
.
mServo
;
}
return
*
this
;
}
AnimationValue
&
operator
=
(
AnimationValue
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Do
not
move
itself
"
)
;
if
(
this
!
=
&
aOther
)
{
mServo
=
std
:
:
move
(
aOther
.
mServo
)
;
}
return
*
this
;
}
bool
operator
=
=
(
const
AnimationValue
&
aOther
)
const
;
bool
operator
!
=
(
const
AnimationValue
&
aOther
)
const
;
bool
IsNull
(
)
const
{
return
!
mServo
;
}
float
GetOpacity
(
)
const
;
nscolor
GetColor
(
nscolor
aForegroundColor
)
const
;
const
mozilla
:
:
StyleTransform
&
GetTransformProperty
(
)
const
;
const
mozilla
:
:
StyleScale
&
GetScaleProperty
(
)
const
;
const
mozilla
:
:
StyleTranslate
&
GetTranslateProperty
(
)
const
;
const
mozilla
:
:
StyleRotate
&
GetRotateProperty
(
)
const
;
mozilla
:
:
gfx
:
:
Size
GetScaleValue
(
const
nsIFrame
*
aFrame
)
const
;
void
SerializeSpecifiedValue
(
nsCSSPropertyID
aProperty
nsAString
&
aString
)
const
;
bool
IsInterpolableWith
(
nsCSSPropertyID
aProperty
const
AnimationValue
&
aToValue
)
const
;
double
ComputeDistance
(
nsCSSPropertyID
aProperty
const
AnimationValue
&
aOther
ComputedStyle
*
aComputedStyle
)
const
;
static
AnimationValue
FromString
(
nsCSSPropertyID
aProperty
const
nsAString
&
aValue
dom
:
:
Element
*
aElement
)
;
static
already_AddRefed
<
RawServoAnimationValue
>
FromAnimatable
(
nsCSSPropertyID
aProperty
const
layers
:
:
Animatable
&
aAnimatable
)
;
RefPtr
<
RawServoAnimationValue
>
mServo
;
}
;
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aOut
const
AnimationValue
&
aValue
)
{
MOZ_ASSERT
(
aValue
.
mServo
)
;
nsString
s
;
Servo_AnimationValue_Dump
(
aValue
.
mServo
&
s
)
;
return
aOut
<
<
s
;
}
struct
PropertyStyleAnimationValuePair
{
nsCSSPropertyID
mProperty
;
AnimationValue
mValue
;
}
;
}
#
endif
