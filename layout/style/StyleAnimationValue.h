#
ifndef
mozilla_StyleAnimationValue_h_
#
define
mozilla_StyleAnimationValue_h_
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
"
nsStyleTransformMatrix
.
h
"
class
nsIFrame
;
class
gfx3DMatrix
;
namespace
mozilla
{
class
ComputedStyle
;
namespace
css
{
class
StyleRule
;
}
namespace
dom
{
class
Element
;
}
enum
class
PseudoStyleType
:
uint8_t
;
struct
PropertyStyleAnimationValuePair
;
struct
AnimationValue
{
explicit
AnimationValue
(
const
RefPtr
<
RawServoAnimationValue
>
&
aValue
)
:
mServo
(
aValue
)
{
}
AnimationValue
(
)
=
default
;
AnimationValue
(
const
AnimationValue
&
aOther
)
:
mServo
(
aOther
.
mServo
)
{
}
AnimationValue
(
AnimationValue
&
&
aOther
)
:
mServo
(
std
:
:
move
(
aOther
.
mServo
)
)
{
}
AnimationValue
&
operator
=
(
const
AnimationValue
&
aOther
)
{
if
(
this
!
=
&
aOther
)
{
mServo
=
aOther
.
mServo
;
}
return
*
this
;
}
AnimationValue
&
operator
=
(
AnimationValue
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Do
not
move
itself
"
)
;
if
(
this
!
=
&
aOther
)
{
mServo
=
std
:
:
move
(
aOther
.
mServo
)
;
}
return
*
this
;
}
bool
operator
=
=
(
const
AnimationValue
&
aOther
)
const
;
bool
operator
!
=
(
const
AnimationValue
&
aOther
)
const
;
bool
IsNull
(
)
const
{
return
!
mServo
;
}
float
GetOpacity
(
)
const
;
nscolor
GetColor
(
nscolor
aForegroundColor
)
const
;
already_AddRefed
<
const
nsCSSValueSharedList
>
GetTransformList
(
)
const
;
mozilla
:
:
gfx
:
:
Size
GetScaleValue
(
const
nsIFrame
*
aFrame
)
const
;
void
SerializeSpecifiedValue
(
nsCSSPropertyID
aProperty
nsAString
&
aString
)
const
;
bool
IsInterpolableWith
(
nsCSSPropertyID
aProperty
const
AnimationValue
&
aToValue
)
const
;
double
ComputeDistance
(
nsCSSPropertyID
aProperty
const
AnimationValue
&
aOther
ComputedStyle
*
aComputedStyle
)
const
;
static
AnimationValue
FromString
(
nsCSSPropertyID
aProperty
const
nsAString
&
aValue
dom
:
:
Element
*
aElement
)
;
static
AnimationValue
Opacity
(
float
aOpacity
)
;
static
AnimationValue
Transform
(
nsCSSValueSharedList
&
aList
)
;
static
already_AddRefed
<
nsCSSValue
:
:
Array
>
AppendTransformFunction
(
nsCSSKeyword
aTransformFunction
nsCSSValueList
*
*
&
aListTail
)
;
RefPtr
<
RawServoAnimationValue
>
mServo
;
}
;
struct
PropertyStyleAnimationValuePair
{
nsCSSPropertyID
mProperty
;
AnimationValue
mValue
;
}
;
}
#
endif
