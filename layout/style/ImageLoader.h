#
ifndef
mozilla_css_ImageLoader_h___
#
define
mozilla_css_ImageLoader_h___
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
class
imgIContainer
;
class
nsIFrame
;
class
nsPresContext
;
class
nsIURI
;
class
nsIPrincipal
;
namespace
mozilla
{
namespace
dom
{
class
Document
;
}
namespace
css
{
struct
URLValue
;
class
ImageLoader
final
:
public
imgINotificationObserver
{
public
:
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
typedef
uint32_t
FrameFlags
;
enum
{
REQUEST_REQUIRES_REFLOW
=
1u
<
<
0
REQUEST_HAS_BLOCKED_ONLOAD
=
1u
<
<
1
}
;
explicit
ImageLoader
(
dom
:
:
Document
*
aDocument
)
:
mDocument
(
aDocument
)
mInClone
(
false
)
{
MOZ_ASSERT
(
mDocument
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_IMGINOTIFICATIONOBSERVER
void
DropDocumentReference
(
)
;
imgRequestProxy
*
RegisterCSSImage
(
URLValue
*
aImage
)
;
void
AssociateRequestToFrame
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
FrameFlags
aFlags
)
;
void
DisassociateRequestFromFrame
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
)
;
void
DropRequestsForFrame
(
nsIFrame
*
aFrame
)
;
void
SetAnimationMode
(
uint16_t
aMode
)
;
void
ClearFrames
(
nsPresContext
*
aPresContext
)
;
static
void
LoadImage
(
URLValue
*
aImage
dom
:
:
Document
*
aLoadingDoc
)
;
static
void
DeregisterCSSImageFromAllLoaders
(
URLValue
*
aImage
)
;
void
FlushUseCounters
(
)
;
private
:
struct
ImageReflowCallback
final
:
public
nsIReflowCallback
{
RefPtr
<
ImageLoader
>
mLoader
;
WeakFrame
mFrame
;
nsCOMPtr
<
imgIRequest
>
const
mRequest
;
ImageReflowCallback
(
ImageLoader
*
aLoader
nsIFrame
*
aFrame
imgIRequest
*
aRequest
)
:
mLoader
(
aLoader
)
mFrame
(
aFrame
)
mRequest
(
aRequest
)
{
}
bool
ReflowFinished
(
)
override
;
void
ReflowCallbackCanceled
(
)
override
;
}
;
~
ImageLoader
(
)
{
}
struct
FrameWithFlags
{
explicit
FrameWithFlags
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mFlags
(
0
)
{
MOZ_ASSERT
(
mFrame
)
;
}
nsIFrame
*
const
mFrame
;
FrameFlags
mFlags
;
}
;
class
FrameOnlyComparator
{
public
:
bool
Equals
(
const
FrameWithFlags
&
aElem1
const
FrameWithFlags
&
aElem2
)
const
{
return
aElem1
.
mFrame
=
=
aElem2
.
mFrame
;
}
bool
LessThan
(
const
FrameWithFlags
&
aElem1
const
FrameWithFlags
&
aElem2
)
const
{
return
aElem1
.
mFrame
<
aElem2
.
mFrame
;
}
}
;
typedef
nsTArray
<
FrameWithFlags
>
FrameSet
;
typedef
nsTArray
<
nsCOMPtr
<
imgIRequest
>
>
RequestSet
;
typedef
nsClassHashtable
<
nsISupportsHashKey
FrameSet
>
RequestToFrameMap
;
typedef
nsClassHashtable
<
nsPtrHashKey
<
nsIFrame
>
RequestSet
>
FrameToRequestMap
;
nsPresContext
*
GetPresContext
(
)
;
void
RequestPaintIfNeeded
(
FrameSet
*
aFrameSet
imgIRequest
*
aRequest
bool
aForcePaint
)
;
void
UnblockOnloadIfNeeded
(
nsIFrame
*
aFrame
imgIRequest
*
aRequest
)
;
void
RequestReflowIfNeeded
(
FrameSet
*
aFrameSet
imgIRequest
*
aRequest
)
;
void
RequestReflowOnFrame
(
FrameWithFlags
*
aFwf
imgIRequest
*
aRequest
)
;
nsresult
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
;
nsresult
OnFrameComplete
(
imgIRequest
*
aRequest
)
;
nsresult
OnImageIsAnimated
(
imgIRequest
*
aRequest
)
;
nsresult
OnFrameUpdate
(
imgIRequest
*
aRequest
)
;
nsresult
OnLoadComplete
(
imgIRequest
*
aRequest
)
;
void
RemoveRequestToFrameMapping
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
)
;
void
RemoveFrameToRequestMapping
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
)
;
static
void
DeregisterCSSImageFromAllLoaders
(
uint64_t
aLoadID
)
;
RequestToFrameMap
mRequestToFrameMap
;
FrameToRequestMap
mFrameToRequestMap
;
dom
:
:
Document
*
mDocument
;
nsRefPtrHashtable
<
nsUint64HashKey
imgRequestProxy
>
mRegisteredImages
;
bool
mInClone
;
struct
ImageTableEntry
{
nsTHashtable
<
nsPtrHashKey
<
ImageLoader
>
>
mImageLoaders
;
RefPtr
<
imgRequestProxy
>
mCanonicalRequest
;
}
;
static
nsClassHashtable
<
nsUint64HashKey
ImageTableEntry
>
*
sImages
;
}
;
}
}
#
endif
