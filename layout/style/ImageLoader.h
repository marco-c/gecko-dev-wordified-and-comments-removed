#
ifndef
mozilla_css_ImageLoader_h___
#
define
mozilla_css_ImageLoader_h___
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
class
imgIContainer
;
class
nsIFrame
;
class
nsPresContext
;
class
nsIURI
;
class
nsIPrincipal
;
namespace
mozilla
{
struct
MediaFeatureChange
;
namespace
dom
{
class
Document
;
}
namespace
css
{
class
ImageLoader
final
{
public
:
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
typedef
uint32_t
FrameFlags
;
enum
{
REQUEST_REQUIRES_REFLOW
=
1u
<
<
0
REQUEST_HAS_BLOCKED_ONLOAD
=
1u
<
<
1
}
;
explicit
ImageLoader
(
dom
:
:
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
MOZ_ASSERT
(
mDocument
)
;
}
NS_INLINE_DECL_REFCOUNTING
(
ImageLoader
)
void
DropDocumentReference
(
)
;
void
AssociateRequestToFrame
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
FrameFlags
aFlags
)
;
void
DisassociateRequestFromFrame
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
)
;
void
DropRequestsForFrame
(
nsIFrame
*
aFrame
)
;
void
SetAnimationMode
(
uint16_t
aMode
)
;
void
ClearFrames
(
nsPresContext
*
aPresContext
)
;
static
already_AddRefed
<
imgRequestProxy
>
LoadImage
(
const
StyleComputedImageUrl
&
dom
:
:
Document
&
)
;
static
void
NoteSharedLoad
(
imgRequestProxy
*
)
;
static
void
UnloadImage
(
imgRequestProxy
*
)
;
void
Notify
(
imgIRequest
*
int32_t
aType
const
nsIntRect
*
aData
)
;
private
:
void
DeregisterImageRequest
(
imgIRequest
*
nsPresContext
*
)
;
struct
ImageReflowCallback
final
:
public
nsIReflowCallback
{
RefPtr
<
ImageLoader
>
mLoader
;
WeakFrame
mFrame
;
nsCOMPtr
<
imgIRequest
>
const
mRequest
;
ImageReflowCallback
(
ImageLoader
*
aLoader
nsIFrame
*
aFrame
imgIRequest
*
aRequest
)
:
mLoader
(
aLoader
)
mFrame
(
aFrame
)
mRequest
(
aRequest
)
{
}
bool
ReflowFinished
(
)
override
;
void
ReflowCallbackCanceled
(
)
override
;
}
;
~
ImageLoader
(
)
=
default
;
struct
FrameWithFlags
{
explicit
FrameWithFlags
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mFlags
(
0
)
{
MOZ_ASSERT
(
mFrame
)
;
}
nsIFrame
*
const
mFrame
;
FrameFlags
mFlags
;
}
;
class
FrameOnlyComparator
{
public
:
bool
Equals
(
const
FrameWithFlags
&
aElem1
const
FrameWithFlags
&
aElem2
)
const
{
return
aElem1
.
mFrame
=
=
aElem2
.
mFrame
;
}
bool
LessThan
(
const
FrameWithFlags
&
aElem1
const
FrameWithFlags
&
aElem2
)
const
{
return
aElem1
.
mFrame
<
aElem2
.
mFrame
;
}
}
;
typedef
nsTArray
<
FrameWithFlags
>
FrameSet
;
typedef
nsTArray
<
nsCOMPtr
<
imgIRequest
>
>
RequestSet
;
typedef
nsClassHashtable
<
nsISupportsHashKey
FrameSet
>
RequestToFrameMap
;
typedef
nsClassHashtable
<
nsPtrHashKey
<
nsIFrame
>
RequestSet
>
FrameToRequestMap
;
nsPresContext
*
GetPresContext
(
)
;
void
RequestPaintIfNeeded
(
FrameSet
*
aFrameSet
imgIRequest
*
aRequest
bool
aForcePaint
)
;
void
UnblockOnloadIfNeeded
(
nsIFrame
*
aFrame
imgIRequest
*
aRequest
)
;
void
RequestReflowIfNeeded
(
FrameSet
*
aFrameSet
imgIRequest
*
aRequest
)
;
void
RequestReflowOnFrame
(
FrameWithFlags
*
aFwf
imgIRequest
*
aRequest
)
;
void
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
;
void
OnFrameComplete
(
imgIRequest
*
aRequest
)
;
void
OnImageIsAnimated
(
imgIRequest
*
aRequest
)
;
void
OnFrameUpdate
(
imgIRequest
*
aRequest
)
;
void
OnLoadComplete
(
imgIRequest
*
aRequest
)
;
void
RemoveRequestToFrameMapping
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
)
;
void
RemoveFrameToRequestMapping
(
imgIRequest
*
aRequest
nsIFrame
*
aFrame
)
;
RequestToFrameMap
mRequestToFrameMap
;
FrameToRequestMap
mFrameToRequestMap
;
dom
:
:
Document
*
mDocument
;
}
;
}
}
#
endif
