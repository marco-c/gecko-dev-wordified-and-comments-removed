#
ifndef
RETAINEDDISPLAYLISTBUILDER_H_
#
define
RETAINEDDISPLAYLISTBUILDER_H_
#
include
"
nsDisplayList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
class
nsWindowSizes
;
namespace
mozilla
{
class
nsDisplayItem
;
class
nsDisplayList
;
struct
RetainedDisplayListData
{
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
DisplayListData
RetainedDisplayListData
)
enum
class
FrameFlag
:
uint8_t
{
Modified
HasProps
HadWillChange
}
;
using
FrameFlags
=
mozilla
:
:
EnumSet
<
FrameFlag
uint8_t
>
;
RetainedDisplayListData
(
)
:
mModifiedFramesCount
(
0
)
{
}
void
AddModifiedFrame
(
nsIFrame
*
aFrame
)
;
void
Clear
(
)
{
mFrames
.
Clear
(
)
;
mModifiedFramesCount
=
0
;
}
FrameFlags
&
Flags
(
nsIFrame
*
aFrame
)
{
return
mFrames
.
LookupOrInsert
(
aFrame
)
;
}
FrameFlags
GetFlags
(
nsIFrame
*
aFrame
)
const
{
return
mFrames
.
Get
(
aFrame
)
;
}
bool
IsModified
(
nsIFrame
*
aFrame
)
const
{
return
GetFlags
(
aFrame
)
.
contains
(
FrameFlag
:
:
Modified
)
;
}
bool
HasProps
(
nsIFrame
*
aFrame
)
const
{
return
GetFlags
(
aFrame
)
.
contains
(
FrameFlag
:
:
HasProps
)
;
}
bool
HadWillChange
(
nsIFrame
*
aFrame
)
const
{
return
GetFlags
(
aFrame
)
.
contains
(
FrameFlag
:
:
HadWillChange
)
;
}
auto
ConstIterator
(
)
{
return
mFrames
.
ConstIter
(
)
;
}
uint32_t
ModifiedFramesCount
(
)
const
{
return
mModifiedFramesCount
;
}
bool
Remove
(
nsIFrame
*
aFrame
)
{
return
mFrames
.
Remove
(
aFrame
)
;
}
private
:
nsTHashMap
<
nsPtrHashKey
<
nsIFrame
>
FrameFlags
>
mFrames
;
uint32_t
mModifiedFramesCount
;
}
;
RetainedDisplayListData
*
GetRetainedDisplayListData
(
nsIFrame
*
aRootFrame
)
;
RetainedDisplayListData
*
GetOrSetRetainedDisplayListData
(
nsIFrame
*
aRootFrame
)
;
enum
class
PartialUpdateResult
{
Failed
NoChange
Updated
}
;
enum
class
PartialUpdateFailReason
{
NA
EmptyList
RebuildLimit
FrameType
Disabled
Content
VisibleRect
}
;
struct
RetainedDisplayListMetrics
{
RetainedDisplayListMetrics
(
)
{
Reset
(
)
;
}
void
Reset
(
)
{
mNewItems
=
0
;
mRebuiltItems
=
0
;
mRemovedItems
=
0
;
mReusedItems
=
0
;
mTotalItems
=
0
;
mPartialBuildDuration
=
0
;
mFullBuildDuration
=
0
;
mPartialUpdateFailReason
=
PartialUpdateFailReason
:
:
NA
;
mPartialUpdateResult
=
PartialUpdateResult
:
:
NoChange
;
}
void
StartBuild
(
)
{
mStartTime
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
}
void
EndFullBuild
(
)
{
mFullBuildDuration
=
Elapsed
(
)
;
}
void
EndPartialBuild
(
PartialUpdateResult
aResult
)
{
mPartialBuildDuration
=
Elapsed
(
)
;
mPartialUpdateResult
=
aResult
;
}
double
Elapsed
(
)
{
return
(
mozilla
:
:
TimeStamp
:
:
Now
(
)
-
mStartTime
)
.
ToMilliseconds
(
)
;
}
const
char
*
FailReasonString
(
)
const
{
switch
(
mPartialUpdateFailReason
)
{
case
PartialUpdateFailReason
:
:
NA
:
return
"
N
/
A
"
;
case
PartialUpdateFailReason
:
:
EmptyList
:
return
"
Empty
list
"
;
case
PartialUpdateFailReason
:
:
RebuildLimit
:
return
"
Rebuild
limit
"
;
case
PartialUpdateFailReason
:
:
FrameType
:
return
"
Frame
type
"
;
case
PartialUpdateFailReason
:
:
Disabled
:
return
"
Disabled
"
;
case
PartialUpdateFailReason
:
:
Content
:
return
"
Content
"
;
case
PartialUpdateFailReason
:
:
VisibleRect
:
return
"
VisibleRect
"
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Enum
value
not
handled
!
"
)
;
}
}
unsigned
int
mNewItems
;
unsigned
int
mRebuiltItems
;
unsigned
int
mRemovedItems
;
unsigned
int
mReusedItems
;
unsigned
int
mTotalItems
;
mozilla
:
:
TimeStamp
mStartTime
;
double
mPartialBuildDuration
;
double
mFullBuildDuration
;
PartialUpdateFailReason
mPartialUpdateFailReason
;
PartialUpdateResult
mPartialUpdateResult
;
}
;
struct
RetainedDisplayListBuilder
{
RetainedDisplayListBuilder
(
nsIFrame
*
aReferenceFrame
nsDisplayListBuilderMode
aMode
bool
aBuildCaret
)
:
mBuilder
(
aReferenceFrame
aMode
aBuildCaret
true
)
mList
(
&
mBuilder
)
{
}
~
RetainedDisplayListBuilder
(
)
{
mList
.
DeleteAll
(
&
mBuilder
)
;
}
nsDisplayListBuilder
*
Builder
(
)
{
return
&
mBuilder
;
}
nsDisplayList
*
List
(
)
{
return
&
mList
;
}
RetainedDisplayListMetrics
*
Metrics
(
)
{
return
&
mMetrics
;
}
PartialUpdateResult
AttemptPartialUpdate
(
nscolor
aBackstop
)
;
void
ClearFramesWithProps
(
)
;
void
ClearReuseableDisplayItems
(
)
{
mBuilder
.
ClearReuseableDisplayItems
(
)
;
}
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
)
const
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
Cached
RetainedDisplayListBuilder
)
private
:
void
IncrementSubDocPresShellPaintCount
(
nsDisplayItem
*
aItem
)
;
void
InvalidateCaretFramesIfNeeded
(
)
;
bool
ShouldBuildPartial
(
nsTArray
<
nsIFrame
*
>
&
aModifiedFrames
)
;
bool
PreProcessDisplayList
(
RetainedDisplayList
*
aList
nsIFrame
*
aAGR
PartialUpdateResult
&
aUpdated
nsIFrame
*
aAsyncAncestor
const
ActiveScrolledRoot
*
aAsyncAncestorASR
nsIFrame
*
aOuterFrame
=
nullptr
uint32_t
aCallerKey
=
0
uint32_t
aNestingDepth
=
0
bool
aKeepLinked
=
false
)
;
bool
MergeDisplayLists
(
nsDisplayList
*
aNewList
RetainedDisplayList
*
aOldList
RetainedDisplayList
*
aOutList
mozilla
:
:
Maybe
<
const
mozilla
:
:
ActiveScrolledRoot
*
>
&
aOutContainerASR
nsDisplayItem
*
aOuterItem
=
nullptr
)
;
bool
ComputeRebuildRegion
(
nsTArray
<
nsIFrame
*
>
&
aModifiedFrames
nsRect
*
aOutDirty
nsIFrame
*
*
aOutModifiedAGR
nsTArray
<
nsIFrame
*
>
&
aOutFramesWithProps
)
;
bool
ProcessFrame
(
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aStopAtFrame
nsTArray
<
nsIFrame
*
>
&
aOutFramesWithProps
const
bool
aStopAtStackingContext
nsRect
*
aOutDirty
nsIFrame
*
*
aOutModifiedAGR
)
;
nsIFrame
*
RootReferenceFrame
(
)
{
return
mBuilder
.
RootReferenceFrame
(
)
;
}
bool
TrySimpleUpdate
(
const
nsTArray
<
nsIFrame
*
>
&
aModifiedFrames
nsTArray
<
nsIFrame
*
>
&
aOutFramesWithProps
)
;
friend
class
MergeState
;
nsDisplayListBuilder
mBuilder
;
RetainedDisplayList
mList
;
WeakFrame
mPreviousCaret
;
RetainedDisplayListMetrics
mMetrics
;
}
;
namespace
RDLUtils
{
void
AssertFrameSubtreeUnmodified
(
const
nsIFrame
*
aFrame
)
;
void
AssertDisplayItemUnmodified
(
nsDisplayItem
*
aItem
)
;
void
AssertDisplayListUnmodified
(
nsDisplayList
*
aList
)
;
}
}
#
endif
