#
ifndef
nsImageRenderer_h__
#
define
nsImageRenderer_h__
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
Units
.
h
"
class
gfxDrawable
;
namespace
mozilla
{
namespace
layers
{
class
StackingContextHelper
;
class
WebRenderParentCommand
;
class
WebRenderDisplayItemLayer
;
class
WebRenderLayerManager
;
}
namespace
wr
{
class
DisplayListBuilder
;
class
IpcResourceUpdateQueue
;
}
struct
CSSSizeOrRatio
{
CSSSizeOrRatio
(
)
:
mRatio
(
0
0
)
mHasWidth
(
false
)
mHasHeight
(
false
)
{
}
bool
CanComputeConcreteSize
(
)
const
{
return
mHasWidth
+
mHasHeight
+
HasRatio
(
)
>
=
2
;
}
bool
IsConcrete
(
)
const
{
return
mHasWidth
&
&
mHasHeight
;
}
bool
HasRatio
(
)
const
{
return
mRatio
.
width
>
0
&
&
mRatio
.
height
>
0
;
}
bool
IsEmpty
(
)
const
{
return
(
mHasWidth
&
&
mWidth
<
=
0
)
|
|
(
mHasHeight
&
&
mHeight
<
=
0
)
|
|
mRatio
.
width
<
=
0
|
|
mRatio
.
height
<
=
0
;
}
nsSize
ComputeConcreteSize
(
)
const
;
void
SetWidth
(
nscoord
aWidth
)
{
mWidth
=
aWidth
;
mHasWidth
=
true
;
if
(
mHasHeight
)
{
mRatio
=
nsSize
(
mWidth
mHeight
)
;
}
}
void
SetHeight
(
nscoord
aHeight
)
{
mHeight
=
aHeight
;
mHasHeight
=
true
;
if
(
mHasWidth
)
{
mRatio
=
nsSize
(
mWidth
mHeight
)
;
}
}
void
SetSize
(
const
nsSize
&
aSize
)
{
mWidth
=
aSize
.
width
;
mHeight
=
aSize
.
height
;
mHasWidth
=
true
;
mHasHeight
=
true
;
mRatio
=
aSize
;
}
void
SetRatio
(
const
nsSize
&
aRatio
)
{
MOZ_ASSERT
(
!
mHasWidth
|
|
!
mHasHeight
"
Probably
shouldn
'
t
be
setting
a
ratio
if
we
have
a
concrete
size
"
)
;
mRatio
=
aRatio
;
}
nsSize
mRatio
;
nscoord
mWidth
;
nscoord
mHeight
;
bool
mHasWidth
;
bool
mHasHeight
;
}
;
class
nsImageRenderer
{
public
:
typedef
mozilla
:
:
image
:
:
DrawResult
DrawResult
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
enum
{
FLAG_SYNC_DECODE_IMAGES
=
0x01
FLAG_PAINTING_TO_WINDOW
=
0x02
}
;
enum
FitType
{
CONTAIN
COVER
}
;
nsImageRenderer
(
nsIFrame
*
aForFrame
const
nsStyleImage
*
aImage
uint32_t
aFlags
)
;
~
nsImageRenderer
(
)
;
bool
PrepareImage
(
)
;
mozilla
:
:
CSSSizeOrRatio
ComputeIntrinsicSize
(
)
;
static
void
ComputeObjectAnchorPoint
(
const
mozilla
:
:
Position
&
aPos
const
nsSize
&
aOriginBounds
const
nsSize
&
aImageSize
nsPoint
*
aTopLeft
nsPoint
*
aAnchorPoint
)
;
static
nsSize
ComputeConstrainedSize
(
const
nsSize
&
aConstrainingSize
const
nsSize
&
aIntrinsicRatio
FitType
aFitType
)
;
static
nsSize
ComputeConcreteSize
(
const
mozilla
:
:
CSSSizeOrRatio
&
aSpecifiedSize
const
mozilla
:
:
CSSSizeOrRatio
&
aIntrinsicSize
const
nsSize
&
aDefaultSize
)
;
void
SetPreferredSize
(
const
mozilla
:
:
CSSSizeOrRatio
&
aIntrinsicSize
const
nsSize
&
aDefaultSize
)
;
DrawResult
DrawLayer
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
const
nsSize
&
aRepeatSize
float
aOpacity
)
;
DrawResult
BuildWebRenderDisplayItemsForLayer
(
nsPresContext
*
aPresContext
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResource
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
nsTArray
<
layers
:
:
WebRenderParentCommand
>
&
aParentCommands
mozilla
:
:
layers
:
:
WebRenderDisplayItemLayer
*
aLayer
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayItem
*
aItem
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
const
nsSize
&
aRepeatSize
float
aOpacity
)
;
DrawResult
DrawBorderImageComponent
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aFill
const
mozilla
:
:
CSSIntRect
&
aSrc
uint8_t
aHFill
uint8_t
aVFill
const
nsSize
&
aUnitSize
uint8_t
aIndex
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasIntrinsicRatio
)
;
bool
IsRasterImage
(
)
;
bool
IsAnimatedImage
(
)
;
already_AddRefed
<
imgIContainer
>
GetImage
(
)
;
bool
IsImageContainerAvailable
(
layers
:
:
LayerManager
*
aManager
uint32_t
aFlags
)
;
bool
IsReady
(
)
const
{
return
mPrepareResult
=
=
DrawResult
:
:
SUCCESS
;
}
DrawResult
PrepareResult
(
)
const
{
return
mPrepareResult
;
}
void
SetExtendMode
(
mozilla
:
:
gfx
:
:
ExtendMode
aMode
)
{
mExtendMode
=
aMode
;
}
void
SetMaskOp
(
uint8_t
aMaskOp
)
{
mMaskOp
=
aMaskOp
;
}
void
PurgeCacheForViewportChange
(
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasRatio
)
;
nsStyleImageType
GetType
(
)
const
{
return
mType
;
}
already_AddRefed
<
nsStyleGradient
>
GetGradientData
(
)
;
private
:
DrawResult
Draw
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsSize
&
aRepeatSize
const
mozilla
:
:
CSSIntRect
&
aSrc
float
aOpacity
=
1
.
0
)
;
DrawResult
BuildWebRenderDisplayItems
(
nsPresContext
*
aPresContext
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
nsTArray
<
layers
:
:
WebRenderParentCommand
>
&
aParentCommands
mozilla
:
:
layers
:
:
WebRenderDisplayItemLayer
*
aLayer
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayItem
*
aItem
const
nsRect
&
aDirtyRect
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsSize
&
aRepeatSize
const
mozilla
:
:
CSSIntRect
&
aSrc
float
aOpacity
=
1
.
0
)
;
already_AddRefed
<
gfxDrawable
>
DrawableForElement
(
const
nsRect
&
aImageRect
gfxContext
&
aContext
)
;
nsIFrame
*
mForFrame
;
const
nsStyleImage
*
mImage
;
nsStyleImageType
mType
;
nsCOMPtr
<
imgIContainer
>
mImageContainer
;
RefPtr
<
nsStyleGradient
>
mGradientData
;
nsIFrame
*
mPaintServerFrame
;
nsLayoutUtils
:
:
SurfaceFromElementResult
mImageElementSurface
;
DrawResult
mPrepareResult
;
nsSize
mSize
;
uint32_t
mFlags
;
mozilla
:
:
gfx
:
:
ExtendMode
mExtendMode
;
uint8_t
mMaskOp
;
}
;
}
#
endif
