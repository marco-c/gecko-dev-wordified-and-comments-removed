#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
dom
/
ProfileTimelineMarkerBinding
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
BasicLayers
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
LayerTreeInvalidation
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
MatrixStack
.
h
"
#
include
"
MaskLayerImageCache
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
Units
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
mozilla
/
LayerTimelineMarker
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
layers
/
ShadowLayers
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
TextureWrapperImage
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderUserData
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
<
algorithm
>
#
include
<
functional
>
#
include
<
deque
>
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gfx
;
DECLARE_USE_COPY_CONSTRUCTORS
(
mozilla
:
:
PaintedLayerData
)
;
namespace
mozilla
{
class
PaintedDisplayItemLayerUserData
;
static
nsTHashtable
<
nsPtrHashKey
<
DisplayItemData
>
>
*
sAliveDisplayItemDatas
;
uint8_t
gPaintedDisplayItemLayerUserData
;
uint8_t
gColorLayerUserData
;
uint8_t
gImageLayerUserData
;
uint8_t
gLayerManagerUserData
;
uint8_t
gMaskLayerUserData
;
uint8_t
gCSSMaskLayerUserData
;
static
MaskLayerImageCache
*
gMaskLayerImageCache
=
nullptr
;
static
inline
MaskLayerImageCache
*
GetMaskLayerImageCache
(
)
{
if
(
!
gMaskLayerImageCache
)
{
gMaskLayerImageCache
=
new
MaskLayerImageCache
(
)
;
}
return
gMaskLayerImageCache
;
}
struct
DisplayItemEntry
{
DisplayItemEntry
(
nsDisplayItem
*
aItem
DisplayItemEntryType
aType
)
:
mItem
(
aItem
)
mType
(
aType
)
{
}
nsDisplayItem
*
mItem
;
DisplayItemEntryType
mType
;
}
;
static
bool
IsEffectEndMarker
(
DisplayItemEntryType
aType
)
{
return
aType
=
=
DisplayItemEntryType
:
:
POP_OPACITY
|
|
aType
=
=
DisplayItemEntryType
:
:
POP_TRANSFORM
;
}
enum
class
MarkerType
{
StartMarker
EndMarker
}
;
template
<
MarkerType
markerType
>
static
bool
AddMarkerIfNeeded
(
nsDisplayItem
*
aItem
std
:
:
deque
<
DisplayItemEntry
>
&
aMarkers
)
{
const
DisplayItemType
type
=
aItem
-
>
GetType
(
)
;
if
(
type
!
=
DisplayItemType
:
:
TYPE_OPACITY
&
&
type
!
=
DisplayItemType
:
:
TYPE_TRANSFORM
)
{
return
false
;
}
DisplayItemEntryType
marker
;
#
define
GET_MARKER
(
start_marker
end_marker
)
\
std
:
:
conditional
<
markerType
=
=
MarkerType
:
:
StartMarker
\
std
:
:
integral_constant
<
DisplayItemEntryType
start_marker
>
\
std
:
:
integral_constant
<
DisplayItemEntryType
end_marker
>
\
>
:
:
type
:
:
value
;
switch
(
type
)
{
case
DisplayItemType
:
:
TYPE_OPACITY
:
marker
=
GET_MARKER
(
DisplayItemEntryType
:
:
PUSH_OPACITY
DisplayItemEntryType
:
:
POP_OPACITY
)
;
break
;
case
DisplayItemType
:
:
TYPE_TRANSFORM
:
marker
=
GET_MARKER
(
DisplayItemEntryType
:
:
PUSH_TRANSFORM
DisplayItemEntryType
:
:
POP_TRANSFORM
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
display
item
type
!
"
)
;
break
;
}
aMarkers
.
emplace_back
(
aItem
marker
)
;
return
true
;
}
class
FLBDisplayItemIterator
:
protected
FlattenedDisplayItemIterator
{
public
:
FLBDisplayItemIterator
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
ContainerState
*
aState
)
:
FlattenedDisplayItemIterator
(
aBuilder
aList
false
)
mState
(
aState
)
mStoreMarker
(
false
)
{
MOZ_ASSERT
(
mState
)
;
ResolveFlattening
(
)
;
}
DisplayItemEntry
GetNextEntry
(
)
{
if
(
!
mMarkers
.
empty
(
)
)
{
DisplayItemEntry
entry
=
mMarkers
.
front
(
)
;
mMarkers
.
pop_front
(
)
;
return
entry
;
}
nsDisplayItem
*
next
=
GetNext
(
)
;
return
DisplayItemEntry
{
next
DisplayItemEntryType
:
:
ITEM
}
;
}
nsDisplayItem
*
GetNext
(
)
;
bool
HasNext
(
)
const
{
return
FlattenedDisplayItemIterator
:
:
HasNext
(
)
|
|
!
mMarkers
.
empty
(
)
;
}
nsDisplayItem
*
PeekNext
(
)
{
return
mNext
;
}
private
:
bool
ShouldFlattenNextItem
(
)
override
;
void
StartNested
(
nsDisplayItem
*
aItem
)
override
{
if
(
!
mStoreMarker
)
{
return
;
}
if
(
AddMarkerIfNeeded
<
MarkerType
:
:
StartMarker
>
(
aItem
mMarkers
)
)
{
mActiveMarkers
.
AppendElement
(
aItem
)
;
}
mStoreMarker
=
false
;
}
void
EndNested
(
nsDisplayItem
*
aItem
)
override
{
if
(
mActiveMarkers
.
IsEmpty
(
)
|
|
mActiveMarkers
.
LastElement
(
)
!
=
aItem
)
{
return
;
}
if
(
AddMarkerIfNeeded
<
MarkerType
:
:
EndMarker
>
(
aItem
mMarkers
)
)
{
mActiveMarkers
.
RemoveLastElement
(
)
;
}
}
bool
NextItemWantsInactiveLayer
(
)
;
std
:
:
deque
<
DisplayItemEntry
>
mMarkers
;
AutoTArray
<
nsDisplayItem
*
4
>
mActiveMarkers
;
ContainerState
*
mState
;
bool
mStoreMarker
;
}
;
DisplayItemData
:
:
DisplayItemData
(
LayerManagerData
*
aParent
uint32_t
aKey
Layer
*
aLayer
nsIFrame
*
aFrame
)
:
mRefCnt
(
0
)
mParent
(
aParent
)
mLayer
(
aLayer
)
mDisplayItemKey
(
aKey
)
mItem
(
nullptr
)
mUsed
(
true
)
mIsInvalid
(
false
)
mReusedItem
(
false
)
{
MOZ_COUNT_CTOR
(
DisplayItemData
)
;
if
(
!
sAliveDisplayItemDatas
)
{
sAliveDisplayItemDatas
=
new
nsTHashtable
<
nsPtrHashKey
<
DisplayItemData
>
>
(
)
;
}
MOZ_RELEASE_ASSERT
(
!
sAliveDisplayItemDatas
-
>
Contains
(
this
)
)
;
sAliveDisplayItemDatas
-
>
PutEntry
(
this
)
;
MOZ_RELEASE_ASSERT
(
mLayer
)
;
if
(
aFrame
)
{
AddFrame
(
aFrame
)
;
}
}
void
DisplayItemData
:
:
AddFrame
(
nsIFrame
*
aFrame
)
{
MOZ_RELEASE_ASSERT
(
mLayer
)
;
MOZ_RELEASE_ASSERT
(
!
mFrameList
.
Contains
(
aFrame
)
)
;
mFrameList
.
AppendElement
(
aFrame
)
;
SmallPointerArray
<
DisplayItemData
>
&
array
=
aFrame
-
>
DisplayItemData
(
)
;
array
.
AppendElement
(
this
)
;
}
void
DisplayItemData
:
:
RemoveFrame
(
nsIFrame
*
aFrame
)
{
MOZ_RELEASE_ASSERT
(
mLayer
)
;
bool
result
=
mFrameList
.
RemoveElement
(
aFrame
)
;
MOZ_RELEASE_ASSERT
(
result
"
Can
'
t
remove
a
frame
that
wasn
'
t
added
!
"
)
;
SmallPointerArray
<
DisplayItemData
>
&
array
=
aFrame
-
>
DisplayItemData
(
)
;
array
.
RemoveElement
(
this
)
;
}
void
DisplayItemData
:
:
EndUpdate
(
)
{
MOZ_RELEASE_ASSERT
(
mLayer
)
;
mIsInvalid
=
false
;
mUsed
=
false
;
mReusedItem
=
false
;
}
void
DisplayItemData
:
:
EndUpdate
(
nsAutoPtr
<
nsDisplayItemGeometry
>
aGeometry
)
{
MOZ_RELEASE_ASSERT
(
mLayer
)
;
MOZ_ASSERT
(
mItem
)
;
MOZ_ASSERT
(
mGeometry
|
|
aGeometry
)
;
if
(
aGeometry
)
{
mGeometry
=
aGeometry
;
}
mClip
=
mItem
-
>
GetClip
(
)
;
mChangedFrameInvalidations
.
SetEmpty
(
)
;
EndUpdate
(
)
;
}
void
DisplayItemData
:
:
BeginUpdate
(
Layer
*
aLayer
LayerState
aState
bool
aFirstUpdate
nsDisplayItem
*
aItem
)
{
BeginUpdate
(
aLayer
aState
aItem
(
aItem
&
&
!
aFirstUpdate
)
?
aItem
-
>
IsReused
(
)
:
false
aItem
?
aItem
-
>
HasMergedFrames
(
)
:
false
)
;
}
void
DisplayItemData
:
:
BeginUpdate
(
Layer
*
aLayer
LayerState
aState
nsDisplayItem
*
aItem
bool
aIsReused
bool
aIsMerged
)
{
MOZ_RELEASE_ASSERT
(
mLayer
)
;
MOZ_RELEASE_ASSERT
(
aLayer
)
;
mLayer
=
aLayer
;
mOptLayer
=
nullptr
;
mInactiveManager
=
nullptr
;
mLayerState
=
aState
;
mUsed
=
true
;
if
(
aLayer
-
>
AsPaintedLayer
(
)
)
{
if
(
aItem
!
=
mItem
)
{
aItem
-
>
SetDisplayItemData
(
this
aLayer
-
>
Manager
(
)
)
;
}
else
{
MOZ_ASSERT
(
aItem
-
>
GetDisplayItemData
(
)
=
=
this
)
;
}
mReusedItem
=
aIsReused
;
}
if
(
!
aItem
)
{
return
;
}
if
(
!
aIsMerged
&
&
mFrameList
.
Length
(
)
=
=
1
)
{
MOZ_ASSERT
(
mFrameList
[
0
]
=
=
aItem
-
>
Frame
(
)
)
;
return
;
}
AutoTArray
<
nsIFrame
*
4
>
copy
(
mFrameList
)
;
if
(
!
copy
.
RemoveElement
(
aItem
-
>
Frame
(
)
)
)
{
AddFrame
(
aItem
-
>
Frame
(
)
)
;
mChangedFrameInvalidations
.
Or
(
mChangedFrameInvalidations
aItem
-
>
Frame
(
)
-
>
GetVisualOverflowRect
(
)
)
;
}
AutoTArray
<
nsIFrame
*
4
>
mergedFrames
;
aItem
-
>
GetMergedFrames
(
&
mergedFrames
)
;
for
(
uint32_t
i
=
0
;
i
<
mergedFrames
.
Length
(
)
;
+
+
i
)
{
if
(
!
copy
.
RemoveElement
(
mergedFrames
[
i
]
)
)
{
AddFrame
(
mergedFrames
[
i
]
)
;
mChangedFrameInvalidations
.
Or
(
mChangedFrameInvalidations
mergedFrames
[
i
]
-
>
GetVisualOverflowRect
(
)
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
copy
.
Length
(
)
;
i
+
+
)
{
RemoveFrame
(
copy
[
i
]
)
;
mChangedFrameInvalidations
.
Or
(
mChangedFrameInvalidations
copy
[
i
]
-
>
GetVisualOverflowRect
(
)
)
;
}
}
static
const
nsIFrame
*
sDestroyedFrame
=
nullptr
;
DisplayItemData
:
:
~
DisplayItemData
(
)
{
MOZ_COUNT_DTOR
(
DisplayItemData
)
;
if
(
mItem
)
{
MOZ_ASSERT
(
mItem
-
>
GetDisplayItemData
(
)
=
=
this
)
;
mItem
-
>
SetDisplayItemData
(
nullptr
nullptr
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mFrameList
.
Length
(
)
;
i
+
+
)
{
nsIFrame
*
frame
=
mFrameList
[
i
]
;
if
(
frame
=
=
sDestroyedFrame
)
{
continue
;
}
SmallPointerArray
<
DisplayItemData
>
&
array
=
frame
-
>
DisplayItemData
(
)
;
array
.
RemoveElement
(
this
)
;
}
MOZ_RELEASE_ASSERT
(
sAliveDisplayItemDatas
)
;
nsPtrHashKey
<
mozilla
:
:
DisplayItemData
>
*
entry
=
sAliveDisplayItemDatas
-
>
GetEntry
(
this
)
;
MOZ_RELEASE_ASSERT
(
entry
)
;
sAliveDisplayItemDatas
-
>
RemoveEntry
(
entry
)
;
if
(
sAliveDisplayItemDatas
-
>
Count
(
)
=
=
0
)
{
delete
sAliveDisplayItemDatas
;
sAliveDisplayItemDatas
=
nullptr
;
}
}
void
DisplayItemData
:
:
ClearAnimationCompositorState
(
)
{
if
(
mDisplayItemKey
!
=
static_cast
<
uint32_t
>
(
DisplayItemType
:
:
TYPE_TRANSFORM
)
&
&
mDisplayItemKey
!
=
static_cast
<
uint32_t
>
(
DisplayItemType
:
:
TYPE_OPACITY
)
)
{
return
;
}
for
(
nsIFrame
*
frame
:
mFrameList
)
{
nsCSSPropertyID
prop
=
mDisplayItemKey
=
=
static_cast
<
uint32_t
>
(
DisplayItemType
:
:
TYPE_TRANSFORM
)
?
eCSSProperty_transform
:
eCSSProperty_opacity
;
EffectCompositor
:
:
ClearIsRunningOnCompositor
(
frame
prop
)
;
}
}
const
nsRegion
&
DisplayItemData
:
:
GetChangedFrameInvalidations
(
)
{
return
mChangedFrameInvalidations
;
}
DisplayItemData
*
DisplayItemData
:
:
AssertDisplayItemData
(
DisplayItemData
*
aData
)
{
MOZ_RELEASE_ASSERT
(
aData
)
;
MOZ_RELEASE_ASSERT
(
sAliveDisplayItemDatas
&
&
sAliveDisplayItemDatas
-
>
Contains
(
aData
)
)
;
MOZ_RELEASE_ASSERT
(
aData
-
>
mLayer
)
;
return
aData
;
}
class
LayerManagerData
:
public
LayerUserData
{
public
:
explicit
LayerManagerData
(
LayerManager
*
aManager
)
:
mLayerManager
(
aManager
)
#
ifdef
DEBUG_DISPLAY_ITEM_DATA
mParent
(
nullptr
)
#
endif
mInvalidateAllLayers
(
false
)
{
MOZ_COUNT_CTOR
(
LayerManagerData
)
;
}
~
LayerManagerData
(
)
{
MOZ_COUNT_DTOR
(
LayerManagerData
)
;
}
#
ifdef
DEBUG_DISPLAY_ITEM_DATA
void
Dump
(
const
char
*
aPrefix
=
"
"
)
{
printf_stderr
(
"
%
sLayerManagerData
%
p
\
n
"
aPrefix
this
)
;
for
(
auto
&
data
:
mDisplayItems
)
{
nsAutoCString
prefix
;
prefix
+
=
aPrefix
;
prefix
+
=
"
"
;
const
char
*
layerState
;
switch
(
data
-
>
mLayerState
)
{
case
LAYER_NONE
:
layerState
=
"
LAYER_NONE
"
;
break
;
case
LAYER_INACTIVE
:
layerState
=
"
LAYER_INACTIVE
"
;
break
;
case
LAYER_ACTIVE
:
layerState
=
"
LAYER_ACTIVE
"
;
break
;
case
LAYER_ACTIVE_FORCE
:
layerState
=
"
LAYER_ACTIVE_FORCE
"
;
break
;
case
LAYER_ACTIVE_EMPTY
:
layerState
=
"
LAYER_ACTIVE_EMPTY
"
;
break
;
case
LAYER_SVG_EFFECTS
:
layerState
=
"
LAYER_SVG_EFFECTS
"
;
break
;
}
uint32_t
mask
=
(
1
<
<
TYPE_BITS
)
-
1
;
nsAutoCString
str
;
str
+
=
prefix
;
str
+
=
nsPrintfCString
(
"
Frame
%
p
"
data
-
>
mFrameList
[
0
]
)
;
str
+
=
nsDisplayItem
:
:
DisplayItemTypeName
(
static_cast
<
nsDisplayItem
:
:
Type
>
(
data
-
>
mDisplayItemKey
&
mask
)
)
;
if
(
(
data
-
>
mDisplayItemKey
>
>
TYPE_BITS
)
)
{
str
+
=
nsPrintfCString
(
"
(
%
i
)
"
data
-
>
mDisplayItemKey
>
>
TYPE_BITS
)
;
}
str
+
=
nsPrintfCString
(
"
%
s
Layer
%
p
"
layerState
data
-
>
mLayer
.
get
(
)
)
;
if
(
data
-
>
mOptLayer
)
{
str
+
=
nsPrintfCString
(
"
OptLayer
%
p
"
data
-
>
mOptLayer
.
get
(
)
)
;
}
if
(
data
-
>
mInactiveManager
)
{
str
+
=
nsPrintfCString
(
"
InactiveLayerManager
%
p
"
data
-
>
mInactiveManager
.
get
(
)
)
;
}
str
+
=
"
\
n
"
;
printf_stderr
(
"
%
s
"
str
.
get
(
)
)
;
if
(
data
-
>
mInactiveManager
)
{
prefix
+
=
"
"
;
printf_stderr
(
"
%
sDumping
inactive
layer
info
:
\
n
"
prefix
.
get
(
)
)
;
LayerManagerData
*
lmd
=
static_cast
<
LayerManagerData
*
>
(
data
-
>
mInactiveManager
-
>
GetUserData
(
&
gLayerManagerUserData
)
)
;
lmd
-
>
Dump
(
prefix
.
get
(
)
)
;
}
}
}
#
endif
LayerManager
*
mLayerManager
;
#
ifdef
DEBUG_DISPLAY_ITEM_DATA
LayerManagerData
*
mParent
;
#
endif
std
:
:
vector
<
RefPtr
<
DisplayItemData
>
>
mDisplayItems
;
bool
mInvalidateAllLayers
;
}
;
void
FrameLayerBuilder
:
:
DestroyDisplayItemDataFor
(
nsIFrame
*
aFrame
)
{
RemoveFrameFromLayerManager
(
aFrame
aFrame
-
>
DisplayItemData
(
)
)
;
aFrame
-
>
DisplayItemData
(
)
.
Clear
(
)
;
aFrame
-
>
DeleteProperty
(
WebRenderUserDataProperty
:
:
Key
(
)
)
;
}
static
nsIntRegion
TransformWithNode
(
const
TransformClipNode
*
aNode
const
nsIntRegion
&
aRegion
const
int32_t
aA2D
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aRegion
.
IsEmpty
(
)
)
{
return
aRegion
;
}
nsIntRegion
result
=
aRegion
;
while
(
aNode
)
{
const
Matrix4x4Flagged
&
transform
=
aNode
-
>
Transform
(
)
;
result
=
result
.
Transform
(
transform
.
GetMatrix
(
)
)
;
if
(
aNode
-
>
Clip
(
)
)
{
const
nsRect
&
clip
=
*
aNode
-
>
Clip
(
)
;
const
gfx
:
:
IntRect
clipRect
=
clip
.
ToNearestPixels
(
aA2D
)
;
result
.
AndWith
(
clipRect
)
;
}
aNode
=
aNode
-
>
Parent
(
)
;
}
return
result
;
}
static
void
TransformRect
(
const
TransformClipNode
*
aNode
gfx
:
:
Rect
&
aRect
const
int32_t
aA2D
)
{
while
(
aNode
)
{
const
Matrix4x4Flagged
&
transform
=
aNode
-
>
Transform
(
)
;
gfx
:
:
Rect
maxBounds
=
gfx
:
:
Rect
:
:
MaxIntRect
(
)
;
if
(
aNode
-
>
Clip
(
)
)
{
const
nsRect
&
clip
=
*
aNode
-
>
Clip
(
)
;
maxBounds
=
IntRectToRect
(
clip
.
ToNearestPixels
(
aA2D
)
)
;
}
aRect
=
transform
.
TransformAndClipBounds
(
aRect
maxBounds
)
;
aNode
=
aNode
-
>
Parent
(
)
;
}
}
static
nsRect
TransformWithNode
(
const
TransformClipNode
*
aNode
const
nsRect
&
aRect
const
int32_t
aA2D
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aRect
.
IsEmpty
(
)
)
{
return
aRect
;
}
gfx
:
:
Rect
result
(
NSAppUnitsToFloatPixels
(
aRect
.
x
aA2D
)
NSAppUnitsToFloatPixels
(
aRect
.
y
aA2D
)
NSAppUnitsToFloatPixels
(
aRect
.
width
aA2D
)
NSAppUnitsToFloatPixels
(
aRect
.
height
aA2D
)
)
;
TransformRect
(
aNode
result
aA2D
)
;
return
nsRect
(
NSFloatPixelsToAppUnits
(
result
.
x
aA2D
)
NSFloatPixelsToAppUnits
(
result
.
y
aA2D
)
NSFloatPixelsToAppUnits
(
result
.
width
aA2D
)
NSFloatPixelsToAppUnits
(
result
.
height
aA2D
)
)
;
}
static
gfx
:
:
IntRect
TransformWithNode
(
const
TransformClipNode
*
aNode
const
gfx
:
:
IntRect
&
aRect
const
int32_t
aA2D
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aRect
.
IsEmpty
(
)
)
{
return
aRect
;
}
gfx
:
:
Rect
result
(
IntRectToRect
(
aRect
)
)
;
TransformRect
(
aNode
result
aA2D
)
;
return
RoundedToInt
(
result
)
;
}
class
PaintedLayerData
{
public
:
PaintedLayerData
(
)
:
mAnimatedGeometryRoot
(
nullptr
)
mASR
(
nullptr
)
mClipChain
(
nullptr
)
mReferenceFrame
(
nullptr
)
mLayer
(
nullptr
)
mSolidColor
(
NS_RGBA
(
0
0
0
0
)
)
mIsSolidColorInVisibleRegion
(
false
)
mNeedComponentAlpha
(
false
)
mForceTransparentSurface
(
false
)
mHideAllLayersBelow
(
false
)
mOpaqueForAnimatedGeometryRootParent
(
false
)
mDisableFlattening
(
false
)
mBackfaceHidden
(
false
)
mShouldPaintOnContentSide
(
false
)
mDTCRequiresTargetConfirmation
(
false
)
mImage
(
nullptr
)
mItemClip
(
nullptr
)
mNewChildLayersIndex
(
-
1
)
#
ifdef
DEBUG
mTransformLevel
(
0
)
#
endif
{
}
~
PaintedLayerData
(
)
{
MOZ_ASSERT
(
mTransformLevel
=
=
0
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
nsCString
mLog
;
#
define
FLB_LOG_PAINTED_LAYER_DECISION
(
pld
.
.
.
)
\
if
(
gfxPrefs
:
:
LayersDumpDecision
(
)
)
{
\
pld
-
>
mLog
.
AppendPrintf
(
"
\
t
\
t
\
t
\
t
"
)
;
\
pld
-
>
mLog
.
AppendPrintf
(
__VA_ARGS__
)
;
\
}
#
else
#
define
FLB_LOG_PAINTED_LAYER_DECISION
(
.
.
.
)
#
endif
void
Accumulate
(
ContainerState
*
aState
nsDisplayItem
*
aItem
const
nsIntRect
&
aVisibleRect
const
nsRect
&
aContentRect
const
DisplayItemClip
&
aClip
LayerState
aLayerState
nsDisplayList
*
aList
DisplayItemEntryType
aType
nsTArray
<
size_t
>
&
aOpacityIndices
const
RefPtr
<
TransformClipNode
>
&
aTransform
)
;
void
UpdateEffectStatus
(
DisplayItemEntryType
aType
nsTArray
<
size_t
>
&
aOpacityIndices
)
;
AnimatedGeometryRoot
*
GetAnimatedGeometryRoot
(
)
{
return
mAnimatedGeometryRoot
;
}
nsRegion
CombinedTouchActionRegion
(
)
;
void
AccumulateHitTestInfo
(
ContainerState
*
aState
nsDisplayCompositorHitTestInfo
*
aItem
TransformClipNode
*
aTransform
)
;
bool
CanOptimizeToImageLayer
(
nsDisplayListBuilder
*
aBuilder
)
;
already_AddRefed
<
ImageContainer
>
GetContainerForImageLayer
(
nsDisplayListBuilder
*
aBuilder
)
;
bool
VisibleAboveRegionIntersects
(
const
nsIntRegion
&
aRegion
)
const
{
return
!
mVisibleAboveRegion
.
Intersect
(
aRegion
)
.
IsEmpty
(
)
;
}
bool
VisibleRegionIntersects
(
const
nsIntRegion
&
aRegion
)
const
{
return
!
mVisibleRegion
.
Intersect
(
aRegion
)
.
IsEmpty
(
)
;
}
nsIntRegion
mVisibleRegion
;
nsIntRegion
mOpaqueRegion
;
nsRegion
mHitRegion
;
nsRegion
mMaybeHitRegion
;
nsRegion
mDispatchToContentHitRegion
;
nsRegion
mNoActionRegion
;
nsRegion
mHorizontalPanRegion
;
nsRegion
mVerticalPanRegion
;
bool
mCollapsedTouchActions
=
false
;
nsIntRect
mScaledHitRegionBounds
;
nsIntRect
mScaledMaybeHitRegionBounds
;
AnimatedGeometryRoot
*
mAnimatedGeometryRoot
;
const
ActiveScrolledRoot
*
mASR
;
const
DisplayItemClipChain
*
mClipChain
;
nsPoint
mAnimatedGeometryRootOffset
;
const
nsIFrame
*
mReferenceFrame
;
PaintedLayer
*
mLayer
;
nscolor
mSolidColor
;
bool
mIsSolidColorInVisibleRegion
;
bool
mNeedComponentAlpha
;
bool
mForceTransparentSurface
;
bool
mHideAllLayersBelow
;
bool
mOpaqueForAnimatedGeometryRootParent
;
bool
mDisableFlattening
;
bool
mBackfaceHidden
;
bool
mShouldPaintOnContentSide
;
bool
mDTCRequiresTargetConfirmation
;
nsDisplayImageContainer
*
mImage
;
const
DisplayItemClip
*
mItemClip
;
int32_t
mNewChildLayersIndex
;
nsIntRegion
mVisibleAboveRegion
;
std
:
:
vector
<
AssignedDisplayItem
>
mAssignedDisplayItems
;
#
ifdef
DEBUG
int
mTransformLevel
;
#
endif
}
;
struct
NewLayerEntry
{
NewLayerEntry
(
)
:
mAnimatedGeometryRoot
(
nullptr
)
mASR
(
nullptr
)
mClipChain
(
nullptr
)
mScrollMetadataASR
(
nullptr
)
mLayerContentsVisibleRect
(
0
0
-
1
-
1
)
mLayerState
(
LAYER_INACTIVE
)
mHideAllLayersBelow
(
false
)
mOpaqueForAnimatedGeometryRootParent
(
false
)
mPropagateComponentAlphaFlattening
(
true
)
mUntransformedVisibleRegion
(
false
)
mIsFixedToRootScrollFrame
(
false
)
{
}
RefPtr
<
Layer
>
mLayer
;
AnimatedGeometryRoot
*
mAnimatedGeometryRoot
;
const
ActiveScrolledRoot
*
mASR
;
const
DisplayItemClipChain
*
mClipChain
;
const
ActiveScrolledRoot
*
mScrollMetadataASR
;
UniquePtr
<
ScrollMetadata
>
mBaseScrollMetadata
;
nsIntRegion
mVisibleRegion
;
nsIntRegion
mOpaqueRegion
;
nsIntRect
mLayerContentsVisibleRect
;
LayerState
mLayerState
;
bool
mHideAllLayersBelow
;
bool
mOpaqueForAnimatedGeometryRootParent
;
bool
mPropagateComponentAlphaFlattening
;
bool
mUntransformedVisibleRegion
;
bool
mIsFixedToRootScrollFrame
;
}
;
class
PaintedLayerDataTree
;
class
PaintedLayerDataNode
{
public
:
PaintedLayerDataNode
(
PaintedLayerDataTree
&
aTree
PaintedLayerDataNode
*
aParent
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
;
~
PaintedLayerDataNode
(
)
;
AnimatedGeometryRoot
*
GetAnimatedGeometryRoot
(
)
const
{
return
mAnimatedGeometryRoot
;
}
bool
Intersects
(
const
nsIntRect
&
aRect
)
const
{
return
!
mHasClip
|
|
mClipRect
.
Intersects
(
aRect
)
;
}
PaintedLayerDataNode
*
AddChildNodeFor
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
;
template
<
typename
NewPaintedLayerCallbackType
>
PaintedLayerData
*
FindPaintedLayerFor
(
const
nsIntRect
&
aVisibleRect
bool
aBackfaceHidden
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aClipChain
NewPaintedLayerCallbackType
aNewPaintedLayerCallback
)
;
enum
{
ABOVE_TOP
=
-
1
}
;
nscolor
FindOpaqueBackgroundColor
(
const
nsIntRegion
&
aRegion
int32_t
aUnderIndex
=
ABOVE_TOP
)
const
;
nscolor
FindOpaqueBackgroundColorCoveringEverything
(
)
const
;
void
AddToVisibleAboveRegion
(
const
nsIntRect
&
aRect
)
;
void
SetAllDrawingAbove
(
)
;
void
Finish
(
bool
aParentNeedsAccurateVisibleAboveRegion
)
;
void
FinishChildrenIntersecting
(
const
nsIntRect
&
aRect
)
;
void
FinishAllChildren
(
)
{
FinishAllChildren
(
true
)
;
}
protected
:
void
PopAllPaintedLayerData
(
)
;
void
FinishAllChildren
(
bool
aThisNodeNeedsAccurateVisibleAboveRegion
)
;
nscolor
FindOpaqueBackgroundColorInParentNode
(
)
const
;
PaintedLayerDataTree
&
mTree
;
PaintedLayerDataNode
*
mParent
;
AnimatedGeometryRoot
*
mAnimatedGeometryRoot
;
AutoTArray
<
PaintedLayerData
3
>
mPaintedLayerDataStack
;
nsTArray
<
UniquePtr
<
PaintedLayerDataNode
>
>
mChildren
;
nsIntRegion
mVisibleAboveBackgroundRegion
;
nsIntRect
mClipRect
;
bool
mHasClip
;
bool
mAllDrawingAboveBackground
;
}
;
class
ContainerState
;
class
PaintedLayerDataTree
{
public
:
PaintedLayerDataTree
(
ContainerState
&
aContainerState
nscolor
&
aBackgroundColor
)
:
mContainerState
(
aContainerState
)
mContainerUniformBackgroundColor
(
aBackgroundColor
)
mForInactiveLayer
(
false
)
{
}
~
PaintedLayerDataTree
(
)
{
MOZ_ASSERT
(
!
mRoot
)
;
MOZ_ASSERT
(
mNodes
.
Count
(
)
=
=
0
)
;
}
void
InitializeForInactiveLayer
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
;
void
AddingOwnLayer
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
nsIntRect
*
aRect
nscolor
*
aOutUniformBackgroundColor
)
;
template
<
typename
NewPaintedLayerCallbackType
>
PaintedLayerData
*
FindPaintedLayerFor
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aClipChain
const
nsIntRect
&
aVisibleRect
const
bool
aBackfaceHidden
NewPaintedLayerCallbackType
aNewPaintedLayerCallback
)
;
void
Finish
(
)
;
AnimatedGeometryRoot
*
GetParentAnimatedGeometryRoot
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
;
bool
IsClippedWithRespectToParentAnimatedGeometryRoot
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
nsIntRect
*
aOutClip
)
;
void
NodeWasFinished
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
;
nsDisplayListBuilder
*
Builder
(
)
const
;
ContainerState
&
ContState
(
)
const
{
return
mContainerState
;
}
nscolor
UniformBackgroundColor
(
)
const
{
return
mContainerUniformBackgroundColor
;
}
protected
:
void
FinishPotentiallyIntersectingNodes
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
nsIntRect
*
aRect
)
;
PaintedLayerDataNode
*
EnsureNodeFor
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
;
PaintedLayerDataNode
*
FindNodeForAncestorAnimatedGeometryRoot
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
AnimatedGeometryRoot
*
*
aOutAncestorChild
)
;
ContainerState
&
mContainerState
;
Maybe
<
PaintedLayerDataNode
>
mRoot
;
nscolor
mContainerUniformBackgroundColor
;
nsDataHashtable
<
nsPtrHashKey
<
AnimatedGeometryRoot
>
PaintedLayerDataNode
*
>
mNodes
;
bool
mForInactiveLayer
;
}
;
class
ContainerState
{
public
:
ContainerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
FrameLayerBuilder
*
aLayerBuilder
nsIFrame
*
aContainerFrame
nsDisplayItem
*
aContainerItem
const
nsRect
&
aContainerBounds
ContainerLayer
*
aContainerLayer
const
ContainerLayerParameters
&
aParameters
nscolor
aBackgroundColor
const
ActiveScrolledRoot
*
aContainerASR
const
ActiveScrolledRoot
*
aContainerScrollMetadataASR
const
ActiveScrolledRoot
*
aContainerCompositorASR
)
:
mBuilder
(
aBuilder
)
mManager
(
aManager
)
mLayerBuilder
(
aLayerBuilder
)
mContainerFrame
(
aContainerFrame
)
mContainerLayer
(
aContainerLayer
)
mContainerBounds
(
aContainerBounds
)
mContainerASR
(
aContainerASR
)
mContainerScrollMetadataASR
(
aContainerScrollMetadataASR
)
mContainerCompositorASR
(
aContainerCompositorASR
)
mParameters
(
aParameters
)
mPaintedLayerDataTree
(
*
this
aBackgroundColor
)
mLastDisplayPortAGR
(
nullptr
)
{
nsPresContext
*
presContext
=
aContainerFrame
-
>
PresContext
(
)
;
mAppUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
mContainerReferenceFrame
=
const_cast
<
nsIFrame
*
>
(
aContainerItem
?
aContainerItem
-
>
ReferenceFrameForChildren
(
)
:
mBuilder
-
>
FindReferenceFrameFor
(
mContainerFrame
)
)
;
bool
isAtRoot
=
!
aContainerItem
|
|
(
aContainerItem
-
>
Frame
(
)
=
=
mBuilder
-
>
RootReferenceFrame
(
)
)
;
MOZ_ASSERT
(
!
isAtRoot
|
|
mContainerReferenceFrame
=
=
mBuilder
-
>
RootReferenceFrame
(
)
)
;
mContainerAnimatedGeometryRoot
=
isAtRoot
?
aBuilder
-
>
GetRootAnimatedGeometryRoot
(
)
:
aContainerItem
-
>
GetAnimatedGeometryRoot
(
)
;
MOZ_ASSERT
(
!
mBuilder
-
>
IsPaintingToWindow
(
)
|
|
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
mBuilder
-
>
RootReferenceFrame
(
)
*
mContainerAnimatedGeometryRoot
)
)
;
mSnappingEnabled
=
aManager
-
>
IsSnappingEffectiveTransforms
(
)
&
&
!
mParameters
.
AllowResidualTranslation
(
)
;
CollectOldLayers
(
)
;
}
void
ProcessDisplayItems
(
nsDisplayList
*
aList
)
;
void
Finish
(
uint32_t
*
aTextContentFlags
const
nsIntRect
&
aContainerPixelBounds
nsDisplayList
*
aChildItems
)
;
nscoord
GetAppUnitsPerDevPixel
(
)
{
return
mAppUnitsPerDevPixel
;
}
nsIntRect
ScaleToNearestPixels
(
const
nsRect
&
aRect
)
const
{
return
aRect
.
ScaleToNearestPixels
(
mParameters
.
mXScale
mParameters
.
mYScale
mAppUnitsPerDevPixel
)
;
}
nsIntRegion
ScaleRegionToNearestPixels
(
const
nsRegion
&
aRegion
)
const
{
return
aRegion
.
ScaleToNearestPixels
(
mParameters
.
mXScale
mParameters
.
mYScale
mAppUnitsPerDevPixel
)
;
}
nsIntRect
ScaleToOutsidePixels
(
const
nsRect
&
aRect
bool
aSnap
=
false
)
const
{
if
(
aSnap
&
&
mSnappingEnabled
)
{
return
ScaleToNearestPixels
(
aRect
)
;
}
return
aRect
.
ScaleToOutsidePixels
(
mParameters
.
mXScale
mParameters
.
mYScale
mAppUnitsPerDevPixel
)
;
}
nsIntRegion
ScaleToOutsidePixels
(
const
nsRegion
&
aRegion
bool
aSnap
=
false
)
const
{
if
(
aSnap
&
&
mSnappingEnabled
)
{
return
ScaleRegionToNearestPixels
(
aRegion
)
;
}
return
aRegion
.
ScaleToOutsidePixels
(
mParameters
.
mXScale
mParameters
.
mYScale
mAppUnitsPerDevPixel
)
;
}
nsIntRect
ScaleToInsidePixels
(
const
nsRect
&
aRect
bool
aSnap
=
false
)
const
{
if
(
aSnap
&
&
mSnappingEnabled
)
{
return
ScaleToNearestPixels
(
aRect
)
;
}
return
aRect
.
ScaleToInsidePixels
(
mParameters
.
mXScale
mParameters
.
mYScale
mAppUnitsPerDevPixel
)
;
}
nsIntRegion
ScaleRegionToInsidePixels
(
const
nsRegion
&
aRegion
bool
aSnap
=
false
)
const
{
if
(
aSnap
&
&
mSnappingEnabled
)
{
return
ScaleRegionToNearestPixels
(
aRegion
)
;
}
return
aRegion
.
ScaleToInsidePixels
(
mParameters
.
mXScale
mParameters
.
mYScale
mAppUnitsPerDevPixel
)
;
}
nsIntRegion
ScaleRegionToOutsidePixels
(
const
nsRegion
&
aRegion
bool
aSnap
=
false
)
const
{
if
(
aSnap
&
&
mSnappingEnabled
)
{
return
ScaleRegionToNearestPixels
(
aRegion
)
;
}
return
aRegion
.
ScaleToOutsidePixels
(
mParameters
.
mXScale
mParameters
.
mYScale
mAppUnitsPerDevPixel
)
;
}
nsIFrame
*
GetContainerFrame
(
)
const
{
return
mContainerFrame
;
}
nsDisplayListBuilder
*
Builder
(
)
const
{
return
mBuilder
;
}
bool
IsInInactiveLayer
(
)
const
{
return
mLayerBuilder
-
>
GetContainingPaintedLayerData
(
)
;
}
void
SetOuterVisibleRegionForLayer
(
Layer
*
aLayer
const
nsIntRegion
&
aOuterVisibleRegion
const
nsIntRect
*
aLayerContentsVisibleRect
=
nullptr
bool
aOuterUntransformed
=
false
)
const
;
nscolor
FindOpaqueBackgroundColorInLayer
(
const
PaintedLayerData
*
aData
const
nsIntRect
&
aRect
bool
*
aOutIntersectsLayer
)
const
;
template
<
typename
FindOpaqueBackgroundColorCallbackType
>
void
FinishPaintedLayerData
(
PaintedLayerData
&
aData
FindOpaqueBackgroundColorCallbackType
aFindOpaqueBackgroundColor
)
;
protected
:
friend
class
PaintedLayerData
;
friend
class
FLBDisplayItemIterator
;
LayerManager
:
:
PaintedLayerCreationHint
GetLayerCreationHint
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
;
already_AddRefed
<
PaintedLayer
>
CreatePaintedLayer
(
PaintedLayerData
*
aData
)
;
already_AddRefed
<
PaintedLayer
>
AttemptToRecyclePaintedLayer
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
nsDisplayItem
*
aItem
const
nsPoint
&
aTopLeft
const
nsIFrame
*
aReferenceFrame
)
;
PaintedDisplayItemLayerUserData
*
RecyclePaintedLayer
(
PaintedLayer
*
aLayer
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
bool
&
didResetScrollPositionForLayerPixelAlignment
)
;
void
PreparePaintedLayerForUse
(
PaintedLayer
*
aLayer
PaintedDisplayItemLayerUserData
*
aData
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
nsIFrame
*
aReferenceFrame
const
nsPoint
&
aTopLeft
bool
aDidResetScrollPositionForLayerPixelAlignment
)
;
already_AddRefed
<
Layer
>
PrepareImageLayer
(
PaintedLayerData
*
aData
)
;
already_AddRefed
<
Layer
>
PrepareColorLayer
(
PaintedLayerData
*
aData
)
;
already_AddRefed
<
ColorLayer
>
CreateOrRecycleColorLayer
(
PaintedLayer
*
aPainted
)
;
already_AddRefed
<
ImageLayer
>
CreateOrRecycleImageLayer
(
PaintedLayer
*
aPainted
)
;
struct
MaskLayerKey
;
template
<
typename
UserData
>
already_AddRefed
<
ImageLayer
>
CreateOrRecycleMaskImageLayerFor
(
const
MaskLayerKey
&
aKey
UserData
*
(
*
aGetUserData
)
(
Layer
*
aLayer
)
void
(
*
aSetDefaultUserData
)
(
Layer
*
aLayer
)
)
;
void
CollectOldLayers
(
)
;
void
InvalidateForLayerChange
(
nsDisplayItem
*
aItem
PaintedLayer
*
aNewLayer
DisplayItemData
*
aData
)
;
bool
ItemCoversScrollableArea
(
nsDisplayItem
*
aItem
const
nsRegion
&
aOpaque
)
;
void
SetupScrollingMetadata
(
NewLayerEntry
*
aEntry
)
;
void
PostprocessRetainedLayers
(
nsIntRegion
*
aOpaqueRegionForContainer
)
;
nsIntRegion
ComputeOpaqueRect
(
nsDisplayItem
*
aItem
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClip
&
aClip
nsDisplayList
*
aList
bool
*
aHideAllLayersBelow
bool
*
aOpaqueForAnimatedGeometryRootParent
)
;
void
NewPaintedLayerData
(
PaintedLayerData
*
aData
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aClipChain
const
ActiveScrolledRoot
*
aScrollMetadataASR
const
nsPoint
&
aTopLeft
const
nsIFrame
*
aReferenceFrame
const
bool
aBackfaceHidden
)
;
void
SetupMaskLayer
(
Layer
*
aLayer
const
DisplayItemClip
&
aClip
)
;
Maybe
<
size_t
>
SetupMaskLayerForScrolledClip
(
Layer
*
aLayer
const
DisplayItemClip
&
aClip
)
;
void
SetupMaskLayerForCSSMask
(
Layer
*
aLayer
nsDisplayMask
*
aMaskItem
)
;
already_AddRefed
<
Layer
>
CreateMaskLayer
(
Layer
*
aLayer
const
DisplayItemClip
&
aClip
const
Maybe
<
size_t
>
&
aForAncestorMaskLayer
)
;
nsRect
GetDisplayPortForAnimatedGeometryRoot
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
;
nsDisplayListBuilder
*
mBuilder
;
LayerManager
*
mManager
;
FrameLayerBuilder
*
mLayerBuilder
;
nsIFrame
*
mContainerFrame
;
nsIFrame
*
mContainerReferenceFrame
;
AnimatedGeometryRoot
*
mContainerAnimatedGeometryRoot
;
ContainerLayer
*
mContainerLayer
;
nsRect
mContainerBounds
;
const
ActiveScrolledRoot
*
mContainerASR
;
const
ActiveScrolledRoot
*
mContainerScrollMetadataASR
;
const
ActiveScrolledRoot
*
mContainerCompositorASR
;
#
ifdef
DEBUG
nsRect
mAccumulatedChildBounds
;
#
endif
ContainerLayerParameters
mParameters
;
nsIntRegion
mInvalidPaintedContent
;
PaintedLayerDataTree
mPaintedLayerDataTree
;
typedef
AutoTArray
<
NewLayerEntry
1
>
AutoLayersArray
;
AutoLayersArray
mNewChildLayers
;
nsTHashtable
<
nsRefPtrHashKey
<
PaintedLayer
>
>
mPaintedLayersAvailableForRecycling
;
nscoord
mAppUnitsPerDevPixel
;
bool
mSnappingEnabled
;
struct
MaskLayerKey
{
MaskLayerKey
(
)
:
mLayer
(
nullptr
)
{
}
MaskLayerKey
(
Layer
*
aLayer
const
Maybe
<
size_t
>
&
aAncestorIndex
)
:
mLayer
(
aLayer
)
mAncestorIndex
(
aAncestorIndex
)
{
}
PLDHashNumber
Hash
(
)
const
{
return
(
NS_PTR_TO_UINT32
(
mLayer
)
>
>
2
)
+
(
mAncestorIndex
?
(
*
mAncestorIndex
+
1
)
:
0
)
;
}
bool
operator
=
=
(
const
MaskLayerKey
&
aOther
)
const
{
return
mLayer
=
=
aOther
.
mLayer
&
&
mAncestorIndex
=
=
aOther
.
mAncestorIndex
;
}
Layer
*
mLayer
;
Maybe
<
size_t
>
mAncestorIndex
;
}
;
nsDataHashtable
<
nsGenericHashKey
<
MaskLayerKey
>
RefPtr
<
ImageLayer
>
>
mRecycledMaskImageLayers
;
AnimatedGeometryRoot
*
mLastDisplayPortAGR
;
nsRect
mLastDisplayPortRect
;
struct
CachedScrollMetadata
{
const
ActiveScrolledRoot
*
mASR
;
const
DisplayItemClip
*
mClip
;
Maybe
<
ScrollMetadata
>
mMetadata
;
CachedScrollMetadata
(
)
:
mASR
(
nullptr
)
mClip
(
nullptr
)
{
}
}
;
CachedScrollMetadata
mCachedScrollMetadata
;
}
;
nsDisplayItem
*
FLBDisplayItemIterator
:
:
GetNext
(
)
{
MOZ_ASSERT
(
mMarkers
.
empty
(
)
)
;
nsDisplayItem
*
next
=
mNext
;
if
(
next
)
{
nsDisplayItem
*
peek
=
next
-
>
GetAbove
(
)
;
if
(
peek
&
&
next
-
>
CanMerge
(
peek
)
)
{
AutoTArray
<
nsDisplayItem
*
2
>
mergedItems
{
next
peek
}
;
while
(
(
peek
=
peek
-
>
GetAbove
(
)
)
)
{
if
(
!
next
-
>
CanMerge
(
peek
)
)
{
break
;
}
mergedItems
.
AppendElement
(
peek
)
;
}
MOZ_ASSERT
(
mergedItems
.
Length
(
)
>
1
)
;
next
=
mState
-
>
mBuilder
-
>
MergeItems
(
mergedItems
)
;
}
mNext
=
peek
;
ResolveFlattening
(
)
;
}
return
next
;
}
bool
FLBDisplayItemIterator
:
:
NextItemWantsInactiveLayer
(
)
{
LayerState
layerState
=
mNext
-
>
GetLayerState
(
mState
-
>
mBuilder
mState
-
>
mManager
mState
-
>
mParameters
)
;
return
layerState
=
=
LayerState
:
:
LAYER_INACTIVE
;
}
bool
FLBDisplayItemIterator
:
:
ShouldFlattenNextItem
(
)
{
if
(
!
mNext
)
{
return
false
;
}
if
(
!
mNext
-
>
ShouldFlattenAway
(
mBuilder
)
)
{
return
false
;
}
const
DisplayItemType
type
=
mNext
-
>
GetType
(
)
;
if
(
type
!
=
DisplayItemType
:
:
TYPE_OPACITY
&
&
type
!
=
DisplayItemType
:
:
TYPE_TRANSFORM
)
{
return
true
;
}
if
(
type
=
=
DisplayItemType
:
:
TYPE_OPACITY
)
{
nsDisplayOpacity
*
opacity
=
static_cast
<
nsDisplayOpacity
*
>
(
mNext
)
;
if
(
opacity
-
>
OpacityAppliedToChildren
(
)
)
{
return
true
;
}
}
if
(
mState
-
>
IsInInactiveLayer
(
)
|
|
!
NextItemWantsInactiveLayer
(
)
)
{
return
false
;
}
mStoreMarker
=
true
;
return
true
;
}
class
PaintedDisplayItemLayerUserData
:
public
LayerUserData
{
public
:
PaintedDisplayItemLayerUserData
(
)
:
mForcedBackgroundColor
(
NS_RGBA
(
0
0
0
0
)
)
mXScale
(
1
.
f
)
mYScale
(
1
.
f
)
mAppUnitsPerDevPixel
(
0
)
mTranslation
(
0
0
)
mAnimatedGeometryRootPosition
(
0
0
)
mLastItemCount
(
0
)
mContainerLayerFrame
(
nullptr
)
mHasExplicitLastPaintOffset
(
false
)
mDisabledAlpha
(
false
)
{
}
NS_INLINE_DECL_REFCOUNTING
(
PaintedDisplayItemLayerUserData
)
;
nscolor
mForcedBackgroundColor
;
float
mXScale
mYScale
;
nscoord
mAppUnitsPerDevPixel
;
nsIntPoint
mTranslation
;
gfxPoint
mAnimatedGeometryRootPosition
;
nsIntRegion
mRegionToInvalidate
;
nsPoint
mLastAnimatedGeometryRootOrigin
;
nsPoint
mAnimatedGeometryRootOrigin
;
RefPtr
<
ColorLayer
>
mColorLayer
;
RefPtr
<
ImageLayer
>
mImageLayer
;
nsIntRegion
mVisibilityComputedRegion
;
nsRect
mPreviousRecomputeVisibilityRect
;
size_t
mLastItemCount
;
nsIntPoint
mLastPaintOffset
;
std
:
:
vector
<
AssignedDisplayItem
>
mItems
;
nsIFrame
*
mContainerLayerFrame
;
bool
mHasExplicitLastPaintOffset
;
bool
mDisabledAlpha
;
protected
:
~
PaintedDisplayItemLayerUserData
(
)
=
default
;
}
;
FrameLayerBuilder
:
:
FrameLayerBuilder
(
)
:
mRetainingManager
(
nullptr
)
mDisplayListBuilder
(
nullptr
)
mContainingPaintedLayer
(
nullptr
)
mInactiveLayerClip
(
nullptr
)
mInvalidateAllLayers
(
false
)
mInLayerTreeCompressionMode
(
false
)
mIsInactiveLayerManager
(
false
)
{
MOZ_COUNT_CTOR
(
FrameLayerBuilder
)
;
}
FrameLayerBuilder
:
:
~
FrameLayerBuilder
(
)
{
GetMaskLayerImageCache
(
)
-
>
Sweep
(
)
;
for
(
PaintedDisplayItemLayerUserData
*
userData
:
mPaintedLayerItems
)
{
userData
-
>
mItems
.
clear
(
)
;
userData
-
>
mContainerLayerFrame
=
nullptr
;
}
MOZ_COUNT_DTOR
(
FrameLayerBuilder
)
;
}
void
FrameLayerBuilder
:
:
AddPaintedLayerItemsEntry
(
PaintedDisplayItemLayerUserData
*
aData
)
{
mPaintedLayerItems
.
AppendElement
(
aData
)
;
}
struct
MaskLayerUserData
:
public
LayerUserData
{
MaskLayerUserData
(
)
:
mScaleX
(
-
1
.
0f
)
mScaleY
(
-
1
.
0f
)
mAppUnitsPerDevPixel
(
-
1
)
{
}
MaskLayerUserData
(
const
DisplayItemClip
&
aClip
int32_t
aAppUnitsPerDevPixel
const
ContainerLayerParameters
&
aParams
)
:
mScaleX
(
aParams
.
mXScale
)
mScaleY
(
aParams
.
mYScale
)
mOffset
(
aParams
.
mOffset
)
mAppUnitsPerDevPixel
(
aAppUnitsPerDevPixel
)
{
aClip
.
AppendRoundedRects
(
&
mRoundedClipRects
)
;
}
void
operator
=
(
MaskLayerUserData
&
&
aOther
)
{
mScaleX
=
aOther
.
mScaleX
;
mScaleY
=
aOther
.
mScaleY
;
mOffset
=
aOther
.
mOffset
;
mAppUnitsPerDevPixel
=
aOther
.
mAppUnitsPerDevPixel
;
mRoundedClipRects
.
SwapElements
(
aOther
.
mRoundedClipRects
)
;
}
bool
operator
=
=
(
const
MaskLayerUserData
&
aOther
)
const
{
return
mRoundedClipRects
=
=
aOther
.
mRoundedClipRects
&
&
mScaleX
=
=
aOther
.
mScaleX
&
&
mScaleY
=
=
aOther
.
mScaleY
&
&
mOffset
=
=
aOther
.
mOffset
&
&
mAppUnitsPerDevPixel
=
=
aOther
.
mAppUnitsPerDevPixel
;
}
MaskLayerImageCache
:
:
MaskLayerImageKeyRef
mImageKey
;
nsTArray
<
DisplayItemClip
:
:
RoundedRect
>
mRoundedClipRects
;
float
mScaleX
mScaleY
;
nsIntPoint
mOffset
;
int32_t
mAppUnitsPerDevPixel
;
}
;
struct
CSSMaskLayerUserData
:
public
LayerUserData
{
CSSMaskLayerUserData
(
)
:
mMaskStyle
(
nsStyleImageLayers
:
:
LayerType
:
:
Mask
)
{
}
CSSMaskLayerUserData
(
nsIFrame
*
aFrame
const
nsIntRect
&
aMaskBounds
const
nsPoint
&
aMaskLayerOffset
)
:
mMaskBounds
(
aMaskBounds
)
mMaskStyle
(
aFrame
-
>
StyleSVGReset
(
)
-
>
mMask
)
mMaskLayerOffset
(
aMaskLayerOffset
)
{
}
void
operator
=
(
CSSMaskLayerUserData
&
&
aOther
)
{
mMaskBounds
=
aOther
.
mMaskBounds
;
mMaskStyle
=
std
:
:
move
(
aOther
.
mMaskStyle
)
;
mMaskLayerOffset
=
aOther
.
mMaskLayerOffset
;
}
bool
operator
=
=
(
const
CSSMaskLayerUserData
&
aOther
)
const
{
if
(
!
mMaskBounds
.
IsEqualInterior
(
aOther
.
mMaskBounds
)
)
{
return
false
;
}
if
(
mMaskLayerOffset
!
=
aOther
.
mMaskLayerOffset
)
{
return
false
;
}
return
mMaskStyle
=
=
aOther
.
mMaskStyle
;
}
private
:
nsIntRect
mMaskBounds
;
nsStyleImageLayers
mMaskStyle
;
nsPoint
mMaskLayerOffset
;
}
;
class
MaskImageData
{
public
:
MaskImageData
(
const
gfx
:
:
IntSize
&
aSize
LayerManager
*
aLayerManager
)
:
mTextureClientLocked
(
false
)
mSize
(
aSize
)
mLayerManager
(
aLayerManager
)
{
MOZ_ASSERT
(
!
mSize
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mLayerManager
)
;
}
~
MaskImageData
(
)
{
if
(
mTextureClientLocked
)
{
MOZ_ASSERT
(
mTextureClient
)
;
mDrawTarget
=
nullptr
;
mTextureClient
-
>
Unlock
(
)
;
}
}
gfx
:
:
DrawTarget
*
CreateDrawTarget
(
)
{
if
(
mDrawTarget
)
{
return
mDrawTarget
;
}
if
(
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_BASIC
)
{
mDrawTarget
=
mLayerManager
-
>
CreateOptimalMaskDrawTarget
(
mSize
)
;
return
mDrawTarget
;
}
MOZ_ASSERT
(
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_CLIENT
|
|
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_WR
)
;
KnowsCompositor
*
knowsCompositor
=
mLayerManager
-
>
AsKnowsCompositor
(
)
;
if
(
!
knowsCompositor
)
{
return
nullptr
;
}
mTextureClient
=
TextureClient
:
:
CreateForDrawing
(
knowsCompositor
SurfaceFormat
:
:
A8
mSize
BackendSelector
:
:
Content
TextureFlags
:
:
DISALLOW_BIGIMAGE
TextureAllocationFlags
:
:
ALLOC_CLEAR_BUFFER
)
;
if
(
!
mTextureClient
)
{
return
nullptr
;
}
mTextureClientLocked
=
mTextureClient
-
>
Lock
(
OpenMode
:
:
OPEN_READ_WRITE
)
;
if
(
!
mTextureClientLocked
)
{
return
nullptr
;
}
mDrawTarget
=
mTextureClient
-
>
BorrowDrawTarget
(
)
;
return
mDrawTarget
;
}
already_AddRefed
<
ImageContainer
>
CreateImageAndImageContainer
(
)
{
RefPtr
<
ImageContainer
>
container
=
LayerManager
:
:
CreateImageContainer
(
)
;
RefPtr
<
Image
>
image
=
CreateImage
(
)
;
if
(
!
image
)
{
return
nullptr
;
}
container
-
>
SetCurrentImageInTransaction
(
image
)
;
return
container
.
forget
(
)
;
}
private
:
already_AddRefed
<
Image
>
CreateImage
(
)
{
if
(
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_BASIC
&
&
mDrawTarget
)
{
RefPtr
<
SourceSurface
>
surface
=
mDrawTarget
-
>
Snapshot
(
)
;
RefPtr
<
SourceSurfaceImage
>
image
=
new
SourceSurfaceImage
(
mSize
surface
)
;
image
-
>
SetTextureFlags
(
TextureFlags
:
:
DISALLOW_BIGIMAGE
)
;
return
image
.
forget
(
)
;
}
if
(
(
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_CLIENT
|
|
mLayerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_WR
)
&
&
mTextureClient
&
&
mDrawTarget
)
{
RefPtr
<
TextureWrapperImage
>
image
=
new
TextureWrapperImage
(
mTextureClient
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
0
0
)
mSize
)
)
;
return
image
.
forget
(
)
;
}
return
nullptr
;
}
bool
mTextureClientLocked
;
gfx
:
:
IntSize
mSize
;
LayerManager
*
mLayerManager
;
RefPtr
<
gfx
:
:
DrawTarget
>
mDrawTarget
;
RefPtr
<
TextureClient
>
mTextureClient
;
}
;
static
PaintedDisplayItemLayerUserData
*
GetPaintedDisplayItemLayerUserData
(
Layer
*
aLayer
)
{
return
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
aLayer
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
}
void
FrameLayerBuilder
:
:
Shutdown
(
)
{
if
(
gMaskLayerImageCache
)
{
delete
gMaskLayerImageCache
;
gMaskLayerImageCache
=
nullptr
;
}
}
void
FrameLayerBuilder
:
:
Init
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
PaintedLayerData
*
aLayerData
bool
aIsInactiveLayerManager
const
DisplayItemClip
*
aInactiveLayerClip
)
{
mDisplayListBuilder
=
aBuilder
;
mRootPresContext
=
aBuilder
-
>
RootReferenceFrame
(
)
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
;
mContainingPaintedLayer
=
aLayerData
;
mIsInactiveLayerManager
=
aIsInactiveLayerManager
;
mInactiveLayerClip
=
aInactiveLayerClip
;
aManager
-
>
SetUserData
(
&
gLayerManagerLayerBuilder
this
)
;
}
void
FrameLayerBuilder
:
:
FlashPaint
(
gfxContext
*
aContext
)
{
float
r
=
float
(
rand
(
)
)
/
RAND_MAX
;
float
g
=
float
(
rand
(
)
)
/
RAND_MAX
;
float
b
=
float
(
rand
(
)
)
/
RAND_MAX
;
aContext
-
>
SetColor
(
Color
(
r
g
b
0
.
4f
)
)
;
aContext
-
>
Paint
(
)
;
}
DisplayItemData
*
FrameLayerBuilder
:
:
GetDisplayItemData
(
nsIFrame
*
aFrame
uint32_t
aKey
)
{
const
SmallPointerArray
<
DisplayItemData
>
&
array
=
aFrame
-
>
DisplayItemData
(
)
;
for
(
uint32_t
i
=
0
;
i
<
array
.
Length
(
)
;
i
+
+
)
{
DisplayItemData
*
item
=
DisplayItemData
:
:
AssertDisplayItemData
(
array
.
ElementAt
(
i
)
)
;
if
(
item
-
>
mDisplayItemKey
=
=
aKey
&
&
item
-
>
mLayer
-
>
Manager
(
)
=
=
mRetainingManager
)
{
return
item
;
}
}
return
nullptr
;
}
#
ifdef
MOZ_DUMP_PAINTING
static
nsACString
&
AppendToString
(
nsACString
&
s
const
nsIntRect
&
r
const
char
*
pfx
=
"
"
const
char
*
sfx
=
"
"
)
{
s
+
=
pfx
;
s
+
=
nsPrintfCString
(
"
(
x
=
%
d
y
=
%
d
w
=
%
d
h
=
%
d
)
"
r
.
x
r
.
y
r
.
width
r
.
height
)
;
return
s
+
=
sfx
;
}
static
nsACString
&
AppendToString
(
nsACString
&
s
const
nsIntRegion
&
r
const
char
*
pfx
=
"
"
const
char
*
sfx
=
"
"
)
{
s
+
=
pfx
;
s
+
=
"
<
"
;
for
(
auto
iter
=
r
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
AppendToString
(
s
iter
.
Get
(
)
)
+
=
"
;
"
;
}
s
+
=
"
>
"
;
return
s
+
=
sfx
;
}
#
endif
static
void
InvalidatePostTransformRegion
(
PaintedLayer
*
aLayer
const
nsIntRegion
&
aRegion
const
nsIntPoint
&
aTranslation
TransformClipNode
*
aTransform
)
{
nsIntRegion
rgn
=
aRegion
;
if
(
aTransform
)
{
PaintedDisplayItemLayerUserData
*
data
=
GetPaintedDisplayItemLayerUserData
(
aLayer
)
;
rgn
=
TransformWithNode
(
aTransform
rgn
data
-
>
mAppUnitsPerDevPixel
)
;
}
rgn
.
MoveBy
(
-
aTranslation
)
;
aLayer
-
>
InvalidateRegion
(
rgn
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
nsAutoCString
str
;
AppendToString
(
str
rgn
)
;
printf_stderr
(
"
Invalidating
layer
%
p
:
%
s
\
n
"
aLayer
str
.
get
(
)
)
;
}
#
endif
}
static
void
InvalidatePostTransformRegion
(
PaintedLayer
*
aLayer
const
nsRect
&
aRect
const
DisplayItemClip
&
aClip
const
nsIntPoint
&
aTranslation
TransformClipNode
*
aTransform
)
{
PaintedDisplayItemLayerUserData
*
data
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
aLayer
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
nsRect
rect
=
aClip
.
ApplyNonRoundedIntersection
(
aRect
)
;
nsIntRect
pixelRect
=
rect
.
ScaleToOutsidePixels
(
data
-
>
mXScale
data
-
>
mYScale
data
-
>
mAppUnitsPerDevPixel
)
;
InvalidatePostTransformRegion
(
aLayer
pixelRect
aTranslation
aTransform
)
;
}
static
nsIntPoint
GetTranslationForPaintedLayer
(
PaintedLayer
*
aLayer
)
{
PaintedDisplayItemLayerUserData
*
data
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
aLayer
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
NS_ASSERTION
(
data
"
Must
be
a
tracked
painted
layer
!
"
)
;
return
data
-
>
mTranslation
;
}
void
FrameLayerBuilder
:
:
RemoveFrameFromLayerManager
(
const
nsIFrame
*
aFrame
SmallPointerArray
<
DisplayItemData
>
&
aArray
)
{
MOZ_RELEASE_ASSERT
(
!
sDestroyedFrame
)
;
sDestroyedFrame
=
aFrame
;
nsTArray
<
RefPtr
<
DisplayItemData
>
>
arrayCopy
;
for
(
DisplayItemData
*
data
:
aArray
)
{
arrayCopy
.
AppendElement
(
data
)
;
}
#
ifdef
DEBUG_DISPLAY_ITEM_DATA
if
(
aArray
-
>
Length
(
)
)
{
LayerManagerData
*
rootData
=
aArray
-
>
ElementAt
(
0
)
-
>
mParent
;
while
(
rootData
-
>
mParent
)
{
rootData
=
rootData
-
>
mParent
;
}
printf_stderr
(
"
Removing
frame
%
p
-
dumping
display
data
\
n
"
aFrame
)
;
rootData
-
>
Dump
(
)
;
}
#
endif
for
(
DisplayItemData
*
data
:
aArray
)
{
PaintedLayer
*
t
=
data
-
>
mLayer
?
data
-
>
mLayer
-
>
AsPaintedLayer
(
)
:
nullptr
;
if
(
t
)
{
PaintedDisplayItemLayerUserData
*
paintedData
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
t
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
if
(
paintedData
&
&
data
-
>
mGeometry
)
{
nsRegion
old
=
data
-
>
mGeometry
-
>
ComputeInvalidationRegion
(
)
;
nsIntRegion
rgn
=
old
.
ScaleToOutsidePixels
(
paintedData
-
>
mXScale
paintedData
-
>
mYScale
paintedData
-
>
mAppUnitsPerDevPixel
)
;
if
(
data
-
>
mTransform
)
{
rgn
=
TransformWithNode
(
data
-
>
mTransform
rgn
paintedData
-
>
mAppUnitsPerDevPixel
)
;
}
rgn
.
MoveBy
(
-
GetTranslationForPaintedLayer
(
t
)
)
;
paintedData
-
>
mRegionToInvalidate
.
Or
(
paintedData
-
>
mRegionToInvalidate
rgn
)
;
paintedData
-
>
mRegionToInvalidate
.
SimplifyOutward
(
8
)
;
}
}
auto
it
=
std
:
:
find
(
data
-
>
mParent
-
>
mDisplayItems
.
begin
(
)
data
-
>
mParent
-
>
mDisplayItems
.
end
(
)
data
)
;
MOZ_ASSERT
(
it
!
=
data
-
>
mParent
-
>
mDisplayItems
.
end
(
)
)
;
std
:
:
iter_swap
(
it
data
-
>
mParent
-
>
mDisplayItems
.
end
(
)
-
1
)
;
data
-
>
mParent
-
>
mDisplayItems
.
pop_back
(
)
;
}
arrayCopy
.
Clear
(
)
;
sDestroyedFrame
=
nullptr
;
}
void
FrameLayerBuilder
:
:
DidBeginRetainedLayerTransaction
(
LayerManager
*
aManager
)
{
mRetainingManager
=
aManager
;
LayerManagerData
*
data
=
static_cast
<
LayerManagerData
*
>
(
aManager
-
>
GetUserData
(
&
gLayerManagerUserData
)
)
;
if
(
data
)
{
mInvalidateAllLayers
=
data
-
>
mInvalidateAllLayers
;
}
else
{
data
=
new
LayerManagerData
(
aManager
)
;
aManager
-
>
SetUserData
(
&
gLayerManagerUserData
data
)
;
}
}
void
FrameLayerBuilder
:
:
DidEndTransaction
(
)
{
GetMaskLayerImageCache
(
)
-
>
Sweep
(
)
;
}
void
FrameLayerBuilder
:
:
WillEndTransaction
(
)
{
if
(
!
mRetainingManager
)
{
return
;
}
LayerManagerData
*
data
=
static_cast
<
LayerManagerData
*
>
(
mRetainingManager
-
>
GetUserData
(
&
gLayerManagerUserData
)
)
;
NS_ASSERTION
(
data
"
Must
have
data
!
"
)
;
auto
iter
=
data
-
>
mDisplayItems
.
begin
(
)
;
while
(
iter
!
=
data
-
>
mDisplayItems
.
end
(
)
)
{
DisplayItemData
*
did
=
iter
-
>
get
(
)
;
if
(
!
did
-
>
mUsed
)
{
PaintedLayer
*
t
=
did
-
>
mLayer
-
>
AsPaintedLayer
(
)
;
if
(
t
&
&
did
-
>
mGeometry
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Invalidating
unused
display
item
(
%
i
)
belonging
to
frame
%
p
from
layer
%
p
\
n
"
did
-
>
mDisplayItemKey
did
-
>
mFrameList
[
0
]
t
)
;
}
#
endif
InvalidatePostTransformRegion
(
t
did
-
>
mGeometry
-
>
ComputeInvalidationRegion
(
)
did
-
>
mClip
GetLastPaintOffset
(
t
)
did
-
>
mTransform
)
;
}
did
-
>
ClearAnimationCompositorState
(
)
;
if
(
iter
!
=
data
-
>
mDisplayItems
.
end
(
)
-
1
)
{
std
:
:
iter_swap
(
iter
data
-
>
mDisplayItems
.
end
(
)
-
1
)
;
data
-
>
mDisplayItems
.
pop_back
(
)
;
}
else
{
data
-
>
mDisplayItems
.
pop_back
(
)
;
break
;
}
}
else
{
ComputeGeometryChangeForItem
(
did
)
;
iter
+
+
;
}
}
data
-
>
mInvalidateAllLayers
=
false
;
}
DisplayItemData
*
FrameLayerBuilder
:
:
GetDisplayItemDataForManager
(
nsDisplayItem
*
aItem
LayerManager
*
aManager
)
{
const
SmallPointerArray
<
DisplayItemData
>
&
array
=
aItem
-
>
Frame
(
)
-
>
DisplayItemData
(
)
;
for
(
uint32_t
i
=
0
;
i
<
array
.
Length
(
)
;
i
+
+
)
{
DisplayItemData
*
item
=
DisplayItemData
:
:
AssertDisplayItemData
(
array
.
ElementAt
(
i
)
)
;
if
(
item
-
>
mDisplayItemKey
=
=
aItem
-
>
GetPerFrameKey
(
)
&
&
item
-
>
mLayer
-
>
Manager
(
)
=
=
aManager
)
{
return
item
;
}
}
return
nullptr
;
}
bool
FrameLayerBuilder
:
:
HasRetainedDataFor
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
)
{
const
SmallPointerArray
<
DisplayItemData
>
&
array
=
aFrame
-
>
DisplayItemData
(
)
;
for
(
uint32_t
i
=
0
;
i
<
array
.
Length
(
)
;
i
+
+
)
{
if
(
DisplayItemData
:
:
AssertDisplayItemData
(
array
.
ElementAt
(
i
)
)
-
>
mDisplayItemKey
=
=
aDisplayItemKey
)
{
return
true
;
}
}
if
(
RefPtr
<
WebRenderUserData
>
data
=
GetWebRenderUserData
<
WebRenderFallbackData
>
(
aFrame
aDisplayItemKey
)
)
{
return
true
;
}
return
false
;
}
DisplayItemData
*
FrameLayerBuilder
:
:
GetOldLayerForFrame
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
DisplayItemData
*
aOldData
LayerManager
*
aOldLayerManager
)
{
if
(
!
mRetainingManager
|
|
mInvalidateAllLayers
)
return
nullptr
;
MOZ_ASSERT
(
!
aOldData
|
|
aOldLayerManager
"
You
must
provide
aOldLayerManager
to
check
aOldData
'
s
validity
.
"
)
;
MOZ_ASSERT_IF
(
aOldData
aOldLayerManager
=
=
aOldData
-
>
mLayer
-
>
Manager
(
)
)
;
DisplayItemData
*
data
=
aOldData
;
if
(
!
data
|
|
aOldLayerManager
!
=
mRetainingManager
)
{
data
=
GetDisplayItemData
(
aFrame
aDisplayItemKey
)
;
}
MOZ_ASSERT
(
data
=
=
GetDisplayItemData
(
aFrame
aDisplayItemKey
)
)
;
return
data
;
}
Layer
*
FrameLayerBuilder
:
:
GetOldLayerFor
(
nsDisplayItem
*
aItem
nsDisplayItemGeometry
*
*
aOldGeometry
DisplayItemClip
*
*
aOldClip
)
{
uint32_t
key
=
aItem
-
>
GetPerFrameKey
(
)
;
nsIFrame
*
frame
=
aItem
-
>
Frame
(
)
;
DisplayItemData
*
oldData
=
GetOldLayerForFrame
(
frame
key
)
;
if
(
oldData
)
{
if
(
aOldGeometry
)
{
*
aOldGeometry
=
oldData
-
>
mGeometry
.
get
(
)
;
}
if
(
aOldClip
)
{
*
aOldClip
=
&
oldData
-
>
mClip
;
}
return
oldData
-
>
mLayer
;
}
return
nullptr
;
}
DisplayItemData
*
FrameLayerBuilder
:
:
GetOldDataFor
(
nsDisplayItem
*
aItem
)
{
const
SmallPointerArray
<
DisplayItemData
>
&
array
=
aItem
-
>
Frame
(
)
-
>
DisplayItemData
(
)
;
for
(
uint32_t
i
=
0
;
i
<
array
.
Length
(
)
;
i
+
+
)
{
DisplayItemData
*
data
=
DisplayItemData
:
:
AssertDisplayItemData
(
array
.
ElementAt
(
i
)
)
;
if
(
data
-
>
mDisplayItemKey
=
=
aItem
-
>
GetPerFrameKey
(
)
)
{
return
data
;
}
}
return
nullptr
;
}
static
void
ResetLayerStateForRecycling
(
Layer
*
aLayer
)
{
aLayer
-
>
SetMaskLayer
(
nullptr
)
;
aLayer
-
>
SetAncestorMaskLayers
(
{
}
)
;
}
already_AddRefed
<
ColorLayer
>
ContainerState
:
:
CreateOrRecycleColorLayer
(
PaintedLayer
*
aPainted
)
{
PaintedDisplayItemLayerUserData
*
data
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
aPainted
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
RefPtr
<
ColorLayer
>
layer
=
data
-
>
mColorLayer
;
if
(
layer
)
{
ResetLayerStateForRecycling
(
layer
)
;
layer
-
>
ClearExtraDumpInfo
(
)
;
}
else
{
layer
=
mManager
-
>
CreateColorLayer
(
)
;
if
(
!
layer
)
return
nullptr
;
data
-
>
mColorLayer
=
layer
;
layer
-
>
SetUserData
(
&
gColorLayerUserData
nullptr
)
;
data
-
>
mImageLayer
=
nullptr
;
}
return
layer
.
forget
(
)
;
}
already_AddRefed
<
ImageLayer
>
ContainerState
:
:
CreateOrRecycleImageLayer
(
PaintedLayer
*
aPainted
)
{
PaintedDisplayItemLayerUserData
*
data
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
aPainted
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
RefPtr
<
ImageLayer
>
layer
=
data
-
>
mImageLayer
;
if
(
layer
)
{
ResetLayerStateForRecycling
(
layer
)
;
layer
-
>
ClearExtraDumpInfo
(
)
;
}
else
{
layer
=
mManager
-
>
CreateImageLayer
(
)
;
if
(
!
layer
)
return
nullptr
;
data
-
>
mImageLayer
=
layer
;
layer
-
>
SetUserData
(
&
gImageLayerUserData
nullptr
)
;
data
-
>
mColorLayer
=
nullptr
;
}
return
layer
.
forget
(
)
;
}
template
<
typename
UserData
>
already_AddRefed
<
ImageLayer
>
ContainerState
:
:
CreateOrRecycleMaskImageLayerFor
(
const
MaskLayerKey
&
aKey
UserData
*
(
*
aGetUserData
)
(
Layer
*
aLayer
)
void
(
*
aSetDefaultUserData
)
(
Layer
*
aLayer
)
)
{
RefPtr
<
ImageLayer
>
result
=
mRecycledMaskImageLayers
.
Get
(
aKey
)
;
if
(
result
&
&
aGetUserData
(
result
.
get
(
)
)
)
{
mRecycledMaskImageLayers
.
Remove
(
aKey
)
;
aKey
.
mLayer
-
>
ClearExtraDumpInfo
(
)
;
}
else
{
result
=
mManager
-
>
CreateImageLayer
(
)
;
if
(
!
result
)
{
return
nullptr
;
}
aSetDefaultUserData
(
result
)
;
}
return
result
.
forget
(
)
;
}
static
const
double
SUBPIXEL_OFFSET_EPSILON
=
0
.
02
;
static
int32_t
RoundToMatchResidual
(
double
aValue
double
aOldResidual
)
{
int32_t
v
=
NSToIntRoundUp
(
aValue
)
;
double
residual
=
aValue
-
v
;
if
(
aOldResidual
<
0
)
{
if
(
residual
>
0
&
&
fabs
(
residual
-
1
.
0
-
aOldResidual
)
<
SUBPIXEL_OFFSET_EPSILON
)
{
return
int32_t
(
ceil
(
aValue
)
)
;
}
}
else
if
(
aOldResidual
>
0
)
{
if
(
residual
<
0
&
&
fabs
(
residual
+
1
.
0
-
aOldResidual
)
<
SUBPIXEL_OFFSET_EPSILON
)
{
return
int32_t
(
floor
(
aValue
)
)
;
}
}
return
v
;
}
static
void
ResetScrollPositionForLayerPixelAlignment
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
{
nsIScrollableFrame
*
sf
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
*
aAnimatedGeometryRoot
)
;
if
(
sf
)
{
sf
-
>
ResetScrollPositionForLayerPixelAlignment
(
)
;
}
}
static
void
InvalidateEntirePaintedLayer
(
PaintedLayer
*
aLayer
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
char
*
aReason
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Invalidating
entire
layer
%
p
:
%
s
\
n
"
aLayer
aReason
)
;
}
#
endif
aLayer
-
>
InvalidateWholeLayer
(
)
;
aLayer
-
>
SetInvalidRectToVisibleRegion
(
)
;
ResetScrollPositionForLayerPixelAlignment
(
aAnimatedGeometryRoot
)
;
}
LayerManager
:
:
PaintedLayerCreationHint
ContainerState
:
:
GetLayerCreationHint
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
{
if
(
mParameters
.
mLayerCreationHint
=
=
LayerManager
:
:
SCROLLABLE
)
{
return
LayerManager
:
:
SCROLLABLE
;
}
for
(
AnimatedGeometryRoot
*
agr
=
aAnimatedGeometryRoot
;
agr
&
&
agr
!
=
mContainerAnimatedGeometryRoot
;
agr
=
agr
-
>
mParentAGR
)
{
nsIFrame
*
fParent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
*
agr
)
;
if
(
!
fParent
)
{
break
;
}
nsIScrollableFrame
*
scrollable
=
do_QueryFrame
(
fParent
)
;
if
(
scrollable
)
{
return
LayerManager
:
:
SCROLLABLE
;
}
}
return
LayerManager
:
:
NONE
;
}
already_AddRefed
<
PaintedLayer
>
ContainerState
:
:
AttemptToRecyclePaintedLayer
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
nsDisplayItem
*
aItem
const
nsPoint
&
aTopLeft
const
nsIFrame
*
aReferenceFrame
)
{
Layer
*
oldLayer
=
mLayerBuilder
-
>
GetOldLayerFor
(
aItem
)
;
if
(
!
oldLayer
|
|
!
oldLayer
-
>
AsPaintedLayer
(
)
)
{
return
nullptr
;
}
if
(
!
mPaintedLayersAvailableForRecycling
.
EnsureRemoved
(
oldLayer
-
>
AsPaintedLayer
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
PaintedLayer
>
layer
=
oldLayer
-
>
AsPaintedLayer
(
)
;
if
(
!
layer
-
>
IsOptimizedFor
(
GetLayerCreationHint
(
aAnimatedGeometryRoot
)
)
)
{
return
nullptr
;
}
bool
didResetScrollPositionForLayerPixelAlignment
=
false
;
PaintedDisplayItemLayerUserData
*
data
=
RecyclePaintedLayer
(
layer
aAnimatedGeometryRoot
didResetScrollPositionForLayerPixelAlignment
)
;
PreparePaintedLayerForUse
(
layer
data
aAnimatedGeometryRoot
aReferenceFrame
aTopLeft
didResetScrollPositionForLayerPixelAlignment
)
;
return
layer
.
forget
(
)
;
}
void
ReleaseLayerUserData
(
void
*
aData
)
{
PaintedDisplayItemLayerUserData
*
userData
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
aData
)
;
userData
-
>
Release
(
)
;
}
already_AddRefed
<
PaintedLayer
>
ContainerState
:
:
CreatePaintedLayer
(
PaintedLayerData
*
aData
)
{
LayerManager
:
:
PaintedLayerCreationHint
creationHint
=
GetLayerCreationHint
(
aData
-
>
mAnimatedGeometryRoot
)
;
RefPtr
<
PaintedLayer
>
layer
=
mManager
-
>
CreatePaintedLayerWithHint
(
creationHint
)
;
if
(
!
layer
)
{
return
nullptr
;
}
RefPtr
<
PaintedDisplayItemLayerUserData
>
userData
=
new
PaintedDisplayItemLayerUserData
(
)
;
userData
-
>
mDisabledAlpha
=
mParameters
.
mDisableSubpixelAntialiasingInDescendants
;
userData
.
get
(
)
-
>
AddRef
(
)
;
layer
-
>
SetUserData
(
&
gPaintedDisplayItemLayerUserData
userData
ReleaseLayerUserData
)
;
ResetScrollPositionForLayerPixelAlignment
(
aData
-
>
mAnimatedGeometryRoot
)
;
PreparePaintedLayerForUse
(
layer
userData
aData
-
>
mAnimatedGeometryRoot
aData
-
>
mReferenceFrame
aData
-
>
mAnimatedGeometryRootOffset
true
)
;
return
layer
.
forget
(
)
;
}
PaintedDisplayItemLayerUserData
*
ContainerState
:
:
RecyclePaintedLayer
(
PaintedLayer
*
aLayer
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
bool
&
didResetScrollPositionForLayerPixelAlignment
)
{
ResetLayerStateForRecycling
(
aLayer
)
;
aLayer
-
>
ClearExtraDumpInfo
(
)
;
PaintedDisplayItemLayerUserData
*
data
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
aLayer
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
NS_ASSERTION
(
data
"
Recycled
PaintedLayers
must
have
user
data
"
)
;
if
(
!
FuzzyEqual
(
data
-
>
mXScale
mParameters
.
mXScale
0
.
00001f
)
|
|
!
FuzzyEqual
(
data
-
>
mYScale
mParameters
.
mYScale
0
.
00001f
)
|
|
data
-
>
mAppUnitsPerDevPixel
!
=
mAppUnitsPerDevPixel
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Recycled
layer
%
p
changed
scale
\
n
"
aLayer
)
;
}
#
endif
InvalidateEntirePaintedLayer
(
aLayer
aAnimatedGeometryRoot
"
recycled
layer
changed
state
"
)
;
didResetScrollPositionForLayerPixelAlignment
=
true
;
}
if
(
!
data
-
>
mRegionToInvalidate
.
IsEmpty
(
)
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Invalidating
deleted
frame
content
from
layer
%
p
\
n
"
aLayer
)
;
}
#
endif
aLayer
-
>
InvalidateRegion
(
data
-
>
mRegionToInvalidate
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
nsAutoCString
str
;
AppendToString
(
str
data
-
>
mRegionToInvalidate
)
;
printf_stderr
(
"
Invalidating
layer
%
p
:
%
s
\
n
"
aLayer
str
.
get
(
)
)
;
}
#
endif
data
-
>
mRegionToInvalidate
.
SetEmpty
(
)
;
}
return
data
;
}
void
ContainerState
:
:
PreparePaintedLayerForUse
(
PaintedLayer
*
aLayer
PaintedDisplayItemLayerUserData
*
aData
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
nsIFrame
*
aReferenceFrame
const
nsPoint
&
aTopLeft
bool
didResetScrollPositionForLayerPixelAlignment
)
{
aData
-
>
mXScale
=
mParameters
.
mXScale
;
aData
-
>
mYScale
=
mParameters
.
mYScale
;
aData
-
>
mLastAnimatedGeometryRootOrigin
=
aData
-
>
mAnimatedGeometryRootOrigin
;
aData
-
>
mAnimatedGeometryRootOrigin
=
aTopLeft
;
aData
-
>
mAppUnitsPerDevPixel
=
mAppUnitsPerDevPixel
;
aLayer
-
>
SetAllowResidualTranslation
(
mParameters
.
AllowResidualTranslation
(
)
)
;
aData
-
>
mLastPaintOffset
=
GetTranslationForPaintedLayer
(
aLayer
)
;
aData
-
>
mHasExplicitLastPaintOffset
=
true
;
nsPoint
offset
=
(
*
aAnimatedGeometryRoot
)
-
>
GetOffsetToCrossDoc
(
aReferenceFrame
)
;
nscoord
appUnitsPerDevPixel
=
(
*
aAnimatedGeometryRoot
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxPoint
scaledOffset
(
NSAppUnitsToDoublePixels
(
offset
.
x
appUnitsPerDevPixel
)
*
mParameters
.
mXScale
NSAppUnitsToDoublePixels
(
offset
.
y
appUnitsPerDevPixel
)
*
mParameters
.
mYScale
)
;
nsIntPoint
pixOffset
(
RoundToMatchResidual
(
scaledOffset
.
x
aData
-
>
mAnimatedGeometryRootPosition
.
x
)
RoundToMatchResidual
(
scaledOffset
.
y
aData
-
>
mAnimatedGeometryRootPosition
.
y
)
)
;
aData
-
>
mTranslation
=
pixOffset
;
pixOffset
+
=
mParameters
.
mOffset
;
Matrix
matrix
=
Matrix
:
:
Translation
(
pixOffset
.
x
pixOffset
.
y
)
;
aLayer
-
>
SetBaseTransform
(
Matrix4x4
:
:
From2D
(
matrix
)
)
;
aData
-
>
mVisibilityComputedRegion
.
SetEmpty
(
)
;
gfxPoint
animatedGeometryRootTopLeft
=
scaledOffset
-
ThebesPoint
(
matrix
.
GetTranslation
(
)
)
+
mParameters
.
mOffset
;
const
bool
disableAlpha
=
mParameters
.
mDisableSubpixelAntialiasingInDescendants
;
if
(
aData
-
>
mDisabledAlpha
!
=
disableAlpha
)
{
aData
-
>
mAnimatedGeometryRootPosition
=
animatedGeometryRootTopLeft
;
InvalidateEntirePaintedLayer
(
aLayer
aAnimatedGeometryRoot
"
change
of
subpixel
-
AA
"
)
;
aData
-
>
mDisabledAlpha
=
disableAlpha
;
return
;
}
#
ifndef
MOZ_WIDGET_ANDROID
if
(
!
animatedGeometryRootTopLeft
.
WithinEpsilonOf
(
aData
-
>
mAnimatedGeometryRootPosition
SUBPIXEL_OFFSET_EPSILON
)
)
{
aData
-
>
mAnimatedGeometryRootPosition
=
animatedGeometryRootTopLeft
;
InvalidateEntirePaintedLayer
(
aLayer
aAnimatedGeometryRoot
"
subpixel
offset
"
)
;
}
else
if
(
didResetScrollPositionForLayerPixelAlignment
)
{
aData
-
>
mAnimatedGeometryRootPosition
=
animatedGeometryRootTopLeft
;
}
#
else
Unused
<
<
didResetScrollPositionForLayerPixelAlignment
;
#
endif
}
#
if
defined
(
DEBUG
)
|
|
defined
(
MOZ_DUMP_PAINTING
)
static
int32_t
AppUnitsPerDevPixel
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_ZOOM
)
{
return
static_cast
<
nsDisplayZoom
*
>
(
aItem
)
-
>
GetParentAppUnitsPerDevPixel
(
)
;
}
return
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
}
#
endif
static
void
SetOuterVisibleRegion
(
Layer
*
aLayer
nsIntRegion
*
aOuterVisibleRegion
const
nsIntRect
*
aLayerContentsVisibleRect
=
nullptr
bool
aOuterUntransformed
=
false
)
{
Matrix4x4
transform
=
aLayer
-
>
GetTransform
(
)
;
Matrix
transform2D
;
if
(
aOuterUntransformed
)
{
if
(
aLayerContentsVisibleRect
)
{
aOuterVisibleRegion
-
>
And
(
*
aOuterVisibleRegion
*
aLayerContentsVisibleRect
)
;
}
}
else
if
(
transform
.
Is2D
(
&
transform2D
)
&
&
!
transform2D
.
HasNonIntegerTranslation
(
)
)
{
aOuterVisibleRegion
-
>
MoveBy
(
-
int
(
transform2D
.
_31
)
-
int
(
transform2D
.
_32
)
)
;
if
(
aLayerContentsVisibleRect
)
{
aOuterVisibleRegion
-
>
And
(
*
aOuterVisibleRegion
*
aLayerContentsVisibleRect
)
;
}
}
else
{
nsIntRect
outerRect
=
aOuterVisibleRegion
-
>
GetBounds
(
)
;
Rect
outerVisible
(
outerRect
.
x
outerRect
.
y
outerRect
.
width
outerRect
.
height
)
;
transform
.
Invert
(
)
;
Rect
layerContentsVisible
(
-
float
(
INT32_MAX
)
/
2
-
float
(
INT32_MAX
)
/
2
float
(
INT32_MAX
)
float
(
INT32_MAX
)
)
;
if
(
aLayerContentsVisibleRect
)
{
NS_ASSERTION
(
aLayerContentsVisibleRect
-
>
width
>
=
0
&
&
aLayerContentsVisibleRect
-
>
height
>
=
0
"
Bad
layer
contents
rectangle
"
)
;
layerContentsVisible
=
Rect
(
aLayerContentsVisibleRect
-
>
x
aLayerContentsVisibleRect
-
>
y
aLayerContentsVisibleRect
-
>
width
aLayerContentsVisibleRect
-
>
height
)
;
}
gfxRect
layerVisible
=
ThebesRect
(
transform
.
ProjectRectBounds
(
outerVisible
layerContentsVisible
)
)
;
layerVisible
.
RoundOut
(
)
;
nsIntRect
visRect
;
if
(
gfxUtils
:
:
GfxRectToIntRect
(
layerVisible
&
visRect
)
)
{
*
aOuterVisibleRegion
=
visRect
;
}
else
{
aOuterVisibleRegion
-
>
SetEmpty
(
)
;
}
}
aLayer
-
>
SetVisibleRegion
(
LayerIntRegion
:
:
FromUnknownRegion
(
*
aOuterVisibleRegion
)
)
;
}
void
ContainerState
:
:
SetOuterVisibleRegionForLayer
(
Layer
*
aLayer
const
nsIntRegion
&
aOuterVisibleRegion
const
nsIntRect
*
aLayerContentsVisibleRect
bool
aOuterUntransformed
)
const
{
nsIntRegion
visRegion
=
aOuterVisibleRegion
;
if
(
!
aOuterUntransformed
)
{
visRegion
.
MoveBy
(
mParameters
.
mOffset
)
;
}
SetOuterVisibleRegion
(
aLayer
&
visRegion
aLayerContentsVisibleRect
aOuterUntransformed
)
;
}
nscolor
ContainerState
:
:
FindOpaqueBackgroundColorInLayer
(
const
PaintedLayerData
*
aData
const
nsIntRect
&
aRect
bool
*
aOutIntersectsLayer
)
const
{
*
aOutIntersectsLayer
=
true
;
nsIntRect
deviceRect
=
aRect
;
nsRect
appUnitRect
=
ToAppUnits
(
deviceRect
mAppUnitsPerDevPixel
)
;
appUnitRect
.
ScaleInverseRoundOut
(
mParameters
.
mXScale
mParameters
.
mYScale
)
;
for
(
auto
&
assignedItem
:
Reversed
(
aData
-
>
mAssignedDisplayItems
)
)
{
if
(
assignedItem
.
mType
!
=
DisplayItemEntryType
:
:
ITEM
)
{
continue
;
}
nsDisplayItem
*
item
=
assignedItem
.
mItem
;
bool
snap
;
nsRect
bounds
=
item
-
>
GetBounds
(
mBuilder
&
snap
)
;
if
(
snap
&
&
mSnappingEnabled
)
{
nsIntRect
snappedBounds
=
ScaleToNearestPixels
(
bounds
)
;
if
(
!
snappedBounds
.
Intersects
(
deviceRect
)
)
continue
;
if
(
!
snappedBounds
.
Contains
(
deviceRect
)
)
return
NS_RGBA
(
0
0
0
0
)
;
}
else
{
if
(
!
bounds
.
Intersects
(
appUnitRect
)
)
continue
;
if
(
!
bounds
.
Contains
(
appUnitRect
)
)
return
NS_RGBA
(
0
0
0
0
)
;
}
if
(
item
-
>
IsInvisibleInRect
(
appUnitRect
)
)
{
continue
;
}
if
(
item
-
>
GetClip
(
)
.
IsRectAffectedByClip
(
deviceRect
mParameters
.
mXScale
mParameters
.
mYScale
mAppUnitsPerDevPixel
)
)
{
return
NS_RGBA
(
0
0
0
0
)
;
}
if
(
!
assignedItem
.
mHasOpacity
&
&
!
assignedItem
.
mHasTransform
)
{
Maybe
<
nscolor
>
color
=
item
-
>
IsUniform
(
mBuilder
)
;
if
(
color
&
&
NS_GET_A
(
*
color
)
=
=
255
)
{
return
*
color
;
}
}
return
NS_RGBA
(
0
0
0
0
)
;
}
*
aOutIntersectsLayer
=
false
;
return
NS_RGBA
(
0
0
0
0
)
;
}
nscolor
PaintedLayerDataNode
:
:
FindOpaqueBackgroundColor
(
const
nsIntRegion
&
aTargetVisibleRegion
int32_t
aUnderIndex
)
const
{
if
(
aUnderIndex
=
=
ABOVE_TOP
)
{
aUnderIndex
=
mPaintedLayerDataStack
.
Length
(
)
;
}
for
(
int32_t
i
=
aUnderIndex
-
1
;
i
>
=
0
;
-
-
i
)
{
const
PaintedLayerData
*
candidate
=
&
mPaintedLayerDataStack
[
i
]
;
if
(
candidate
-
>
VisibleAboveRegionIntersects
(
aTargetVisibleRegion
)
)
{
return
NS_RGBA
(
0
0
0
0
)
;
}
if
(
!
candidate
-
>
VisibleRegionIntersects
(
aTargetVisibleRegion
)
)
{
continue
;
}
bool
intersectsLayer
=
true
;
nsIntRect
rect
=
aTargetVisibleRegion
.
GetBounds
(
)
;
nscolor
color
=
mTree
.
ContState
(
)
.
FindOpaqueBackgroundColorInLayer
(
candidate
rect
&
intersectsLayer
)
;
if
(
!
intersectsLayer
)
{
continue
;
}
return
color
;
}
if
(
mAllDrawingAboveBackground
|
|
!
mVisibleAboveBackgroundRegion
.
Intersect
(
aTargetVisibleRegion
)
.
IsEmpty
(
)
)
{
return
NS_RGBA
(
0
0
0
0
)
;
}
return
FindOpaqueBackgroundColorInParentNode
(
)
;
}
nscolor
PaintedLayerDataNode
:
:
FindOpaqueBackgroundColorCoveringEverything
(
)
const
{
if
(
!
mPaintedLayerDataStack
.
IsEmpty
(
)
|
|
mAllDrawingAboveBackground
|
|
!
mVisibleAboveBackgroundRegion
.
IsEmpty
(
)
)
{
return
NS_RGBA
(
0
0
0
0
)
;
}
return
FindOpaqueBackgroundColorInParentNode
(
)
;
}
nscolor
PaintedLayerDataNode
:
:
FindOpaqueBackgroundColorInParentNode
(
)
const
{
if
(
mParent
)
{
if
(
mHasClip
)
{
return
mParent
-
>
FindOpaqueBackgroundColor
(
mClipRect
)
;
}
return
mParent
-
>
FindOpaqueBackgroundColorCoveringEverything
(
)
;
}
return
mTree
.
UniformBackgroundColor
(
)
;
}
bool
PaintedLayerData
:
:
CanOptimizeToImageLayer
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
!
mImage
)
{
return
false
;
}
return
mImage
-
>
CanOptimizeToImageLayer
(
mLayer
-
>
Manager
(
)
aBuilder
)
;
}
already_AddRefed
<
ImageContainer
>
PaintedLayerData
:
:
GetContainerForImageLayer
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
!
mImage
)
{
return
nullptr
;
}
return
mImage
-
>
GetContainer
(
mLayer
-
>
Manager
(
)
aBuilder
)
;
}
PaintedLayerDataNode
:
:
PaintedLayerDataNode
(
PaintedLayerDataTree
&
aTree
PaintedLayerDataNode
*
aParent
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
:
mTree
(
aTree
)
mParent
(
aParent
)
mAnimatedGeometryRoot
(
aAnimatedGeometryRoot
)
mAllDrawingAboveBackground
(
false
)
{
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
mTree
.
Builder
(
)
-
>
RootReferenceFrame
(
)
*
mAnimatedGeometryRoot
)
)
;
mHasClip
=
mTree
.
IsClippedWithRespectToParentAnimatedGeometryRoot
(
mAnimatedGeometryRoot
&
mClipRect
)
;
}
PaintedLayerDataNode
:
:
~
PaintedLayerDataNode
(
)
{
MOZ_ASSERT
(
mPaintedLayerDataStack
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mChildren
.
IsEmpty
(
)
)
;
}
PaintedLayerDataNode
*
PaintedLayerDataNode
:
:
AddChildNodeFor
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
{
MOZ_ASSERT
(
aAnimatedGeometryRoot
-
>
mParentAGR
=
=
mAnimatedGeometryRoot
)
;
UniquePtr
<
PaintedLayerDataNode
>
child
=
MakeUnique
<
PaintedLayerDataNode
>
(
mTree
this
aAnimatedGeometryRoot
)
;
mChildren
.
AppendElement
(
std
:
:
move
(
child
)
)
;
return
mChildren
.
LastElement
(
)
.
get
(
)
;
}
template
<
typename
NewPaintedLayerCallbackType
>
PaintedLayerData
*
PaintedLayerDataNode
:
:
FindPaintedLayerFor
(
const
nsIntRect
&
aVisibleRect
const
bool
aBackfaceHidden
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aClipChain
NewPaintedLayerCallbackType
aNewPaintedLayerCallback
)
{
if
(
!
mPaintedLayerDataStack
.
IsEmpty
(
)
)
{
PaintedLayerData
*
lowestUsableLayer
=
nullptr
;
for
(
auto
&
data
:
Reversed
(
mPaintedLayerDataStack
)
)
{
if
(
data
.
mVisibleAboveRegion
.
Intersects
(
aVisibleRect
)
)
{
break
;
}
if
(
data
.
mBackfaceHidden
=
=
aBackfaceHidden
&
&
data
.
mASR
=
=
aASR
&
&
data
.
mClipChain
=
=
aClipChain
)
{
lowestUsableLayer
=
&
data
;
}
if
(
!
mTree
.
ContState
(
)
.
IsInInactiveLayer
(
)
&
&
(
data
.
mScaledHitRegionBounds
.
Intersects
(
aVisibleRect
)
|
|
data
.
mScaledMaybeHitRegionBounds
.
Intersects
(
aVisibleRect
)
)
)
{
break
;
}
if
(
data
.
mVisibleRegion
.
Intersects
(
aVisibleRect
)
)
{
break
;
}
else
if
(
gfxPrefs
:
:
LayoutSmallerPaintedLayers
(
)
)
{
lowestUsableLayer
=
nullptr
;
}
}
if
(
lowestUsableLayer
)
{
return
lowestUsableLayer
;
}
}
PaintedLayerData
*
data
=
mPaintedLayerDataStack
.
AppendElement
(
)
;
aNewPaintedLayerCallback
(
data
)
;
return
data
;
}
void
PaintedLayerDataNode
:
:
FinishChildrenIntersecting
(
const
nsIntRect
&
aRect
)
{
for
(
int32_t
i
=
mChildren
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
mChildren
[
i
]
-
>
Intersects
(
aRect
)
)
{
mChildren
[
i
]
-
>
Finish
(
true
)
;
mChildren
.
RemoveElementAt
(
i
)
;
}
}
}
void
PaintedLayerDataNode
:
:
FinishAllChildren
(
bool
aThisNodeNeedsAccurateVisibleAboveRegion
)
{
for
(
int32_t
i
=
mChildren
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
mChildren
[
i
]
-
>
Finish
(
aThisNodeNeedsAccurateVisibleAboveRegion
)
;
}
mChildren
.
Clear
(
)
;
}
void
PaintedLayerDataNode
:
:
Finish
(
bool
aParentNeedsAccurateVisibleAboveRegion
)
{
FinishAllChildren
(
false
)
;
PopAllPaintedLayerData
(
)
;
if
(
mParent
&
&
aParentNeedsAccurateVisibleAboveRegion
)
{
if
(
mHasClip
)
{
mParent
-
>
AddToVisibleAboveRegion
(
mClipRect
)
;
}
else
{
mParent
-
>
SetAllDrawingAbove
(
)
;
}
}
mTree
.
NodeWasFinished
(
mAnimatedGeometryRoot
)
;
}
void
PaintedLayerDataNode
:
:
AddToVisibleAboveRegion
(
const
nsIntRect
&
aRect
)
{
nsIntRegion
&
visibleAboveRegion
=
mPaintedLayerDataStack
.
IsEmpty
(
)
?
mVisibleAboveBackgroundRegion
:
mPaintedLayerDataStack
.
LastElement
(
)
.
mVisibleAboveRegion
;
visibleAboveRegion
.
Or
(
visibleAboveRegion
aRect
)
;
visibleAboveRegion
.
SimplifyOutward
(
8
)
;
}
void
PaintedLayerDataNode
:
:
SetAllDrawingAbove
(
)
{
PopAllPaintedLayerData
(
)
;
mAllDrawingAboveBackground
=
true
;
mVisibleAboveBackgroundRegion
.
SetEmpty
(
)
;
}
void
PaintedLayerDataNode
:
:
PopAllPaintedLayerData
(
)
{
for
(
int32_t
index
=
mPaintedLayerDataStack
.
Length
(
)
-
1
;
index
>
=
0
;
index
-
-
)
{
PaintedLayerData
&
data
=
mPaintedLayerDataStack
[
index
]
;
mTree
.
ContState
(
)
.
FinishPaintedLayerData
(
data
[
this
&
data
index
]
(
)
{
return
this
-
>
FindOpaqueBackgroundColor
(
data
.
mVisibleRegion
index
)
;
}
)
;
}
mPaintedLayerDataStack
.
Clear
(
)
;
}
void
PaintedLayerDataTree
:
:
InitializeForInactiveLayer
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
{
mForInactiveLayer
=
true
;
mRoot
.
emplace
(
*
this
nullptr
aAnimatedGeometryRoot
)
;
}
nsDisplayListBuilder
*
PaintedLayerDataTree
:
:
Builder
(
)
const
{
return
mContainerState
.
Builder
(
)
;
}
void
PaintedLayerDataTree
:
:
Finish
(
)
{
if
(
mRoot
)
{
mRoot
-
>
Finish
(
false
)
;
}
MOZ_ASSERT
(
mNodes
.
Count
(
)
=
=
0
)
;
mRoot
.
reset
(
)
;
}
void
PaintedLayerDataTree
:
:
NodeWasFinished
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
{
mNodes
.
Remove
(
aAnimatedGeometryRoot
)
;
}
void
PaintedLayerDataTree
:
:
AddingOwnLayer
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
nsIntRect
*
aRect
nscolor
*
aOutUniformBackgroundColor
)
{
PaintedLayerDataNode
*
node
=
nullptr
;
if
(
mForInactiveLayer
)
{
node
=
mRoot
.
ptr
(
)
;
}
else
{
FinishPotentiallyIntersectingNodes
(
aAnimatedGeometryRoot
aRect
)
;
node
=
EnsureNodeFor
(
aAnimatedGeometryRoot
)
;
}
if
(
aRect
)
{
if
(
aOutUniformBackgroundColor
)
{
*
aOutUniformBackgroundColor
=
node
-
>
FindOpaqueBackgroundColor
(
*
aRect
)
;
}
node
-
>
AddToVisibleAboveRegion
(
*
aRect
)
;
}
else
{
if
(
aOutUniformBackgroundColor
)
{
*
aOutUniformBackgroundColor
=
node
-
>
FindOpaqueBackgroundColorCoveringEverything
(
)
;
}
node
-
>
SetAllDrawingAbove
(
)
;
}
}
template
<
typename
NewPaintedLayerCallbackType
>
PaintedLayerData
*
PaintedLayerDataTree
:
:
FindPaintedLayerFor
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aClipChain
const
nsIntRect
&
aVisibleRect
const
bool
aBackfaceHidden
NewPaintedLayerCallbackType
aNewPaintedLayerCallback
)
{
const
nsIntRect
*
bounds
=
&
aVisibleRect
;
PaintedLayerDataNode
*
node
=
nullptr
;
if
(
mForInactiveLayer
)
{
node
=
mRoot
.
ptr
(
)
;
}
else
{
FinishPotentiallyIntersectingNodes
(
aAnimatedGeometryRoot
bounds
)
;
node
=
EnsureNodeFor
(
aAnimatedGeometryRoot
)
;
}
PaintedLayerData
*
data
=
node
-
>
FindPaintedLayerFor
(
aVisibleRect
aBackfaceHidden
aASR
aClipChain
aNewPaintedLayerCallback
)
;
return
data
;
}
void
PaintedLayerDataTree
:
:
FinishPotentiallyIntersectingNodes
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
nsIntRect
*
aRect
)
{
AnimatedGeometryRoot
*
ancestorThatIsChildOfCommonAncestor
=
nullptr
;
PaintedLayerDataNode
*
ancestorNode
=
FindNodeForAncestorAnimatedGeometryRoot
(
aAnimatedGeometryRoot
&
ancestorThatIsChildOfCommonAncestor
)
;
if
(
!
ancestorNode
)
{
MOZ_ASSERT
(
!
mRoot
)
;
return
;
}
if
(
ancestorNode
-
>
GetAnimatedGeometryRoot
(
)
=
=
aAnimatedGeometryRoot
)
{
MOZ_ASSERT
(
!
ancestorThatIsChildOfCommonAncestor
)
;
if
(
aRect
)
{
ancestorNode
-
>
FinishChildrenIntersecting
(
*
aRect
)
;
}
else
{
ancestorNode
-
>
FinishAllChildren
(
)
;
}
return
;
}
MOZ_ASSERT
(
ancestorThatIsChildOfCommonAncestor
)
;
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
*
ancestorThatIsChildOfCommonAncestor
*
aAnimatedGeometryRoot
)
)
;
MOZ_ASSERT
(
ancestorThatIsChildOfCommonAncestor
-
>
mParentAGR
=
=
ancestorNode
-
>
GetAnimatedGeometryRoot
(
)
)
;
MOZ_ASSERT
(
!
mNodes
.
Get
(
ancestorThatIsChildOfCommonAncestor
)
)
;
nsIntRect
clip
;
if
(
IsClippedWithRespectToParentAnimatedGeometryRoot
(
ancestorThatIsChildOfCommonAncestor
&
clip
)
)
{
ancestorNode
-
>
FinishChildrenIntersecting
(
clip
)
;
}
else
{
ancestorNode
-
>
FinishAllChildren
(
)
;
}
}
PaintedLayerDataNode
*
PaintedLayerDataTree
:
:
EnsureNodeFor
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
{
MOZ_ASSERT
(
aAnimatedGeometryRoot
)
;
PaintedLayerDataNode
*
node
=
mNodes
.
Get
(
aAnimatedGeometryRoot
)
;
if
(
node
)
{
return
node
;
}
AnimatedGeometryRoot
*
parentAnimatedGeometryRoot
=
aAnimatedGeometryRoot
-
>
mParentAGR
;
if
(
!
parentAnimatedGeometryRoot
)
{
MOZ_ASSERT
(
!
mRoot
)
;
MOZ_ASSERT
(
*
aAnimatedGeometryRoot
=
=
Builder
(
)
-
>
RootReferenceFrame
(
)
)
;
mRoot
.
emplace
(
*
this
nullptr
aAnimatedGeometryRoot
)
;
node
=
mRoot
.
ptr
(
)
;
}
else
{
PaintedLayerDataNode
*
parentNode
=
EnsureNodeFor
(
parentAnimatedGeometryRoot
)
;
MOZ_ASSERT
(
parentNode
)
;
node
=
parentNode
-
>
AddChildNodeFor
(
aAnimatedGeometryRoot
)
;
}
MOZ_ASSERT
(
node
)
;
mNodes
.
Put
(
aAnimatedGeometryRoot
node
)
;
return
node
;
}
bool
PaintedLayerDataTree
:
:
IsClippedWithRespectToParentAnimatedGeometryRoot
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
nsIntRect
*
aOutClip
)
{
if
(
mForInactiveLayer
)
{
return
false
;
}
nsIScrollableFrame
*
scrollableFrame
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
*
aAnimatedGeometryRoot
)
;
if
(
!
scrollableFrame
)
{
return
false
;
}
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
scrollableFrame
)
;
nsRect
scrollPort
=
scrollableFrame
-
>
GetScrollPortRect
(
)
+
Builder
(
)
-
>
ToReferenceFrame
(
scrollFrame
)
;
*
aOutClip
=
mContainerState
.
ScaleToNearestPixels
(
scrollPort
)
;
return
true
;
}
PaintedLayerDataNode
*
PaintedLayerDataTree
:
:
FindNodeForAncestorAnimatedGeometryRoot
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
AnimatedGeometryRoot
*
*
aOutAncestorChild
)
{
if
(
!
aAnimatedGeometryRoot
)
{
return
nullptr
;
}
PaintedLayerDataNode
*
node
=
mNodes
.
Get
(
aAnimatedGeometryRoot
)
;
if
(
node
)
{
return
node
;
}
*
aOutAncestorChild
=
aAnimatedGeometryRoot
;
return
FindNodeForAncestorAnimatedGeometryRoot
(
aAnimatedGeometryRoot
-
>
mParentAGR
aOutAncestorChild
)
;
}
static
bool
CanOptimizeAwayPaintedLayer
(
PaintedLayerData
*
aData
FrameLayerBuilder
*
aLayerBuilder
)
{
if
(
!
aLayerBuilder
-
>
IsBuildingRetainedLayers
(
)
)
{
return
false
;
}
if
(
aData
-
>
mLayer
-
>
GetValidRegion
(
)
.
IsEmpty
(
)
)
{
return
true
;
}
return
aLayerBuilder
-
>
CheckInLayerTreeCompressionMode
(
)
;
}
#
ifdef
DEBUG
static
int32_t
FindIndexOfLayerIn
(
nsTArray
<
NewLayerEntry
>
&
aArray
Layer
*
aLayer
)
{
for
(
uint32_t
i
=
0
;
i
<
aArray
.
Length
(
)
;
+
+
i
)
{
if
(
aArray
[
i
]
.
mLayer
=
=
aLayer
)
{
return
i
;
}
}
return
-
1
;
}
#
endif
already_AddRefed
<
Layer
>
ContainerState
:
:
PrepareImageLayer
(
PaintedLayerData
*
aData
)
{
RefPtr
<
ImageContainer
>
imageContainer
=
aData
-
>
GetContainerForImageLayer
(
mBuilder
)
;
if
(
!
imageContainer
)
{
return
nullptr
;
}
RefPtr
<
ImageLayer
>
imageLayer
=
CreateOrRecycleImageLayer
(
aData
-
>
mLayer
)
;
imageLayer
-
>
SetContainer
(
imageContainer
)
;
aData
-
>
mImage
-
>
ConfigureLayer
(
imageLayer
mParameters
)
;
imageLayer
-
>
SetPostScale
(
mParameters
.
mXScale
mParameters
.
mYScale
)
;
if
(
aData
-
>
mItemClip
-
>
HasClip
(
)
)
{
ParentLayerIntRect
clip
=
ViewAs
<
ParentLayerPixel
>
(
ScaleToNearestPixels
(
aData
-
>
mItemClip
-
>
GetClipRect
(
)
)
)
;
clip
.
MoveBy
(
ViewAs
<
ParentLayerPixel
>
(
mParameters
.
mOffset
)
)
;
imageLayer
-
>
SetClipRect
(
Some
(
clip
)
)
;
}
else
{
imageLayer
-
>
SetClipRect
(
Nothing
(
)
)
;
}
FLB_LOG_PAINTED_LAYER_DECISION
(
aData
"
Selected
image
layer
=
%
p
\
n
"
imageLayer
.
get
(
)
)
;
return
imageLayer
.
forget
(
)
;
}
already_AddRefed
<
Layer
>
ContainerState
:
:
PrepareColorLayer
(
PaintedLayerData
*
aData
)
{
RefPtr
<
ColorLayer
>
colorLayer
=
CreateOrRecycleColorLayer
(
aData
-
>
mLayer
)
;
colorLayer
-
>
SetColor
(
Color
:
:
FromABGR
(
aData
-
>
mSolidColor
)
)
;
colorLayer
-
>
SetBaseTransform
(
aData
-
>
mLayer
-
>
GetBaseTransform
(
)
)
;
colorLayer
-
>
SetPostScale
(
aData
-
>
mLayer
-
>
GetPostXScale
(
)
aData
-
>
mLayer
-
>
GetPostYScale
(
)
)
;
nsIntRect
visibleRect
=
aData
-
>
mVisibleRegion
.
GetBounds
(
)
;
visibleRect
.
MoveBy
(
-
GetTranslationForPaintedLayer
(
aData
-
>
mLayer
)
)
;
colorLayer
-
>
SetBounds
(
visibleRect
)
;
colorLayer
-
>
SetClipRect
(
Nothing
(
)
)
;
FLB_LOG_PAINTED_LAYER_DECISION
(
aData
"
Selected
color
layer
=
%
p
\
n
"
colorLayer
.
get
(
)
)
;
return
colorLayer
.
forget
(
)
;
}
static
void
SetBackfaceHiddenForLayer
(
bool
aBackfaceHidden
Layer
*
aLayer
)
{
if
(
aBackfaceHidden
)
{
aLayer
-
>
SetContentFlags
(
aLayer
-
>
GetContentFlags
(
)
|
Layer
:
:
CONTENT_BACKFACE_HIDDEN
)
;
}
else
{
aLayer
-
>
SetContentFlags
(
aLayer
-
>
GetContentFlags
(
)
&
~
Layer
:
:
CONTENT_BACKFACE_HIDDEN
)
;
}
}
template
<
typename
FindOpaqueBackgroundColorCallbackType
>
void
ContainerState
:
:
FinishPaintedLayerData
(
PaintedLayerData
&
aData
FindOpaqueBackgroundColorCallbackType
aFindOpaqueBackgroundColor
)
{
PaintedLayerData
*
data
=
&
aData
;
if
(
!
data
-
>
mLayer
)
{
RefPtr
<
PaintedLayer
>
paintedLayer
=
CreatePaintedLayer
(
data
)
;
data
-
>
mLayer
=
paintedLayer
;
NS_ASSERTION
(
FindIndexOfLayerIn
(
mNewChildLayers
paintedLayer
)
<
0
"
Layer
already
in
list
?
?
?
"
)
;
mNewChildLayers
[
data
-
>
mNewChildLayersIndex
]
.
mLayer
=
paintedLayer
.
forget
(
)
;
}
PaintedDisplayItemLayerUserData
*
userData
=
GetPaintedDisplayItemLayerUserData
(
data
-
>
mLayer
)
;
NS_ASSERTION
(
userData
"
where
did
our
user
data
go
?
"
)
;
userData
-
>
mLastItemCount
=
data
-
>
mAssignedDisplayItems
.
size
(
)
;
NewLayerEntry
*
newLayerEntry
=
&
mNewChildLayers
[
data
-
>
mNewChildLayersIndex
]
;
RefPtr
<
Layer
>
layer
;
bool
canOptimizeToImageLayer
=
data
-
>
CanOptimizeToImageLayer
(
mBuilder
)
;
FLB_LOG_PAINTED_LAYER_DECISION
(
data
"
Selecting
layer
for
pld
=
%
p
\
n
"
data
)
;
FLB_LOG_PAINTED_LAYER_DECISION
(
data
"
Solid
=
%
i
hasImage
=
%
c
canOptimizeAwayPaintedLayer
=
%
i
\
n
"
data
-
>
mIsSolidColorInVisibleRegion
canOptimizeToImageLayer
?
'
y
'
:
'
n
'
CanOptimizeAwayPaintedLayer
(
data
mLayerBuilder
)
)
;
if
(
(
data
-
>
mIsSolidColorInVisibleRegion
|
|
canOptimizeToImageLayer
)
&
&
CanOptimizeAwayPaintedLayer
(
data
mLayerBuilder
)
)
{
NS_ASSERTION
(
!
(
data
-
>
mIsSolidColorInVisibleRegion
&
&
canOptimizeToImageLayer
)
"
Can
'
t
be
a
solid
color
as
well
as
an
image
!
"
)
;
layer
=
canOptimizeToImageLayer
?
PrepareImageLayer
(
data
)
:
PrepareColorLayer
(
data
)
;
if
(
layer
)
{
NS_ASSERTION
(
FindIndexOfLayerIn
(
mNewChildLayers
layer
)
<
0
"
Layer
already
in
list
?
?
?
"
)
;
NS_ASSERTION
(
newLayerEntry
-
>
mLayer
=
=
data
-
>
mLayer
"
Painted
layer
at
wrong
index
"
)
;
NewLayerEntry
*
paintedLayerEntry
=
newLayerEntry
;
newLayerEntry
=
&
mNewChildLayers
[
data
-
>
mNewChildLayersIndex
+
1
]
;
NS_ASSERTION
(
!
newLayerEntry
-
>
mLayer
"
Slot
already
occupied
?
"
)
;
newLayerEntry
-
>
mLayer
=
layer
;
newLayerEntry
-
>
mAnimatedGeometryRoot
=
data
-
>
mAnimatedGeometryRoot
;
newLayerEntry
-
>
mASR
=
paintedLayerEntry
-
>
mASR
;
newLayerEntry
-
>
mClipChain
=
paintedLayerEntry
-
>
mClipChain
;
newLayerEntry
-
>
mScrollMetadataASR
=
paintedLayerEntry
-
>
mScrollMetadataASR
;
ParentLayerIntRect
emptyRect
;
data
-
>
mLayer
-
>
SetClipRect
(
Some
(
emptyRect
)
)
;
data
-
>
mLayer
-
>
SetVisibleRegion
(
LayerIntRegion
(
)
)
;
data
-
>
mLayer
-
>
InvalidateWholeLayer
(
)
;
data
-
>
mLayer
-
>
SetEventRegions
(
EventRegions
(
)
)
;
}
}
if
(
!
layer
)
{
layer
=
data
-
>
mLayer
;
layer
-
>
SetClipRect
(
Nothing
(
)
)
;
FLB_LOG_PAINTED_LAYER_DECISION
(
data
"
Selected
painted
layer
=
%
p
\
n
"
layer
.
get
(
)
)
;
}
for
(
auto
&
item
:
data
-
>
mAssignedDisplayItems
)
{
MOZ_ASSERT
(
item
.
mItem
-
>
GetType
(
)
!
=
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
)
;
if
(
IsEffectEndMarker
(
item
.
mType
)
)
{
continue
;
}
InvalidateForLayerChange
(
item
.
mItem
data
-
>
mLayer
item
.
mDisplayItemData
)
;
mLayerBuilder
-
>
AddPaintedDisplayItem
(
data
item
*
this
layer
)
;
item
.
mDisplayItemData
=
nullptr
;
}
if
(
mLayerBuilder
-
>
IsBuildingRetainedLayers
(
)
)
{
newLayerEntry
-
>
mVisibleRegion
=
data
-
>
mVisibleRegion
;
newLayerEntry
-
>
mOpaqueRegion
=
data
-
>
mOpaqueRegion
;
newLayerEntry
-
>
mHideAllLayersBelow
=
data
-
>
mHideAllLayersBelow
;
newLayerEntry
-
>
mOpaqueForAnimatedGeometryRootParent
=
data
-
>
mOpaqueForAnimatedGeometryRootParent
;
}
else
{
SetOuterVisibleRegionForLayer
(
layer
data
-
>
mVisibleRegion
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
!
data
-
>
mLog
.
IsEmpty
(
)
)
{
if
(
PaintedLayerData
*
containingPld
=
mLayerBuilder
-
>
GetContainingPaintedLayerData
(
)
)
{
containingPld
-
>
mLayer
-
>
AddExtraDumpInfo
(
nsCString
(
data
-
>
mLog
)
)
;
}
else
{
layer
-
>
AddExtraDumpInfo
(
nsCString
(
data
-
>
mLog
)
)
;
}
}
#
endif
mLayerBuilder
-
>
AddPaintedLayerItemsEntry
(
userData
)
;
nsIntRegion
transparentRegion
;
transparentRegion
.
Sub
(
data
-
>
mVisibleRegion
data
-
>
mOpaqueRegion
)
;
bool
isOpaque
=
transparentRegion
.
IsEmpty
(
)
;
if
(
layer
=
=
data
-
>
mLayer
)
{
nscolor
backgroundColor
=
NS_RGBA
(
0
0
0
0
)
;
if
(
!
isOpaque
)
{
backgroundColor
=
aFindOpaqueBackgroundColor
(
)
;
if
(
NS_GET_A
(
backgroundColor
)
=
=
255
)
{
isOpaque
=
true
;
}
}
if
(
userData
-
>
mForcedBackgroundColor
!
=
backgroundColor
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Forced
background
color
has
changed
from
#
%
08X
to
#
%
08X
on
layer
%
p
\
n
"
userData
-
>
mForcedBackgroundColor
backgroundColor
data
-
>
mLayer
)
;
nsAutoCString
str
;
AppendToString
(
str
data
-
>
mLayer
-
>
GetValidRegion
(
)
)
;
printf_stderr
(
"
Invalidating
layer
%
p
:
%
s
\
n
"
data
-
>
mLayer
str
.
get
(
)
)
;
}
#
endif
data
-
>
mLayer
-
>
InvalidateWholeLayer
(
)
;
}
userData
-
>
mForcedBackgroundColor
=
backgroundColor
;
}
else
{
SetupMaskLayer
(
layer
*
data
-
>
mItemClip
)
;
}
uint32_t
flags
=
0
;
nsIWidget
*
widget
=
mContainerReferenceFrame
-
>
PresContext
(
)
-
>
GetRootWidget
(
)
;
bool
hidpi
=
false
&
&
widget
&
&
widget
-
>
GetDefaultScale
(
)
.
scale
>
=
2
;
if
(
hidpi
)
{
flags
|
=
Layer
:
:
CONTENT_DISABLE_SUBPIXEL_AA
;
}
if
(
isOpaque
&
&
!
data
-
>
mForceTransparentSurface
)
{
flags
|
=
Layer
:
:
CONTENT_OPAQUE
;
}
else
if
(
data
-
>
mNeedComponentAlpha
&
&
!
hidpi
)
{
flags
|
=
Layer
:
:
CONTENT_COMPONENT_ALPHA
;
}
if
(
data
-
>
mDisableFlattening
)
{
flags
|
=
Layer
:
:
CONTENT_DISABLE_FLATTENING
;
}
layer
-
>
SetContentFlags
(
flags
)
;
userData
-
>
mItems
=
std
:
:
move
(
data
-
>
mAssignedDisplayItems
)
;
userData
-
>
mContainerLayerFrame
=
GetContainerFrame
(
)
;
PaintedLayerData
*
containingPaintedLayerData
=
mLayerBuilder
-
>
GetContainingPaintedLayerData
(
)
;
const
DisplayItemClip
*
inactiveLayerClip
=
mLayerBuilder
-
>
GetInactiveLayerClip
(
)
;
if
(
containingPaintedLayerData
)
{
if
(
!
data
-
>
mDispatchToContentHitRegion
.
GetBounds
(
)
.
IsEmpty
(
)
)
{
nsRect
rect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
mContainerReferenceFrame
data
-
>
mDispatchToContentHitRegion
.
GetBounds
(
)
containingPaintedLayerData
-
>
mReferenceFrame
)
;
if
(
inactiveLayerClip
)
{
rect
=
inactiveLayerClip
-
>
ApplyNonRoundedIntersection
(
rect
)
;
}
containingPaintedLayerData
-
>
mDispatchToContentHitRegion
.
Or
(
containingPaintedLayerData
-
>
mDispatchToContentHitRegion
rect
)
;
containingPaintedLayerData
-
>
mDispatchToContentHitRegion
.
SimplifyOutward
(
8
)
;
if
(
data
-
>
mDTCRequiresTargetConfirmation
)
{
containingPaintedLayerData
-
>
mDTCRequiresTargetConfirmation
=
true
;
}
}
if
(
!
data
-
>
mMaybeHitRegion
.
GetBounds
(
)
.
IsEmpty
(
)
)
{
nsRect
rect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
mContainerReferenceFrame
data
-
>
mMaybeHitRegion
.
GetBounds
(
)
containingPaintedLayerData
-
>
mReferenceFrame
)
;
if
(
inactiveLayerClip
)
{
rect
=
inactiveLayerClip
-
>
ApplyNonRoundedIntersection
(
rect
)
;
}
containingPaintedLayerData
-
>
mMaybeHitRegion
.
Or
(
containingPaintedLayerData
-
>
mMaybeHitRegion
rect
)
;
containingPaintedLayerData
-
>
mMaybeHitRegion
.
SimplifyOutward
(
8
)
;
}
Maybe
<
Matrix4x4Flagged
>
matrixCache
;
nsLayoutUtils
:
:
TransformToAncestorAndCombineRegions
(
data
-
>
mHitRegion
mContainerReferenceFrame
containingPaintedLayerData
-
>
mReferenceFrame
&
containingPaintedLayerData
-
>
mHitRegion
&
containingPaintedLayerData
-
>
mMaybeHitRegion
&
matrixCache
inactiveLayerClip
)
;
bool
alreadyHadRegions
=
!
containingPaintedLayerData
-
>
mNoActionRegion
.
IsEmpty
(
)
|
|
!
containingPaintedLayerData
-
>
mHorizontalPanRegion
.
IsEmpty
(
)
|
|
!
containingPaintedLayerData
-
>
mVerticalPanRegion
.
IsEmpty
(
)
;
nsLayoutUtils
:
:
TransformToAncestorAndCombineRegions
(
data
-
>
mNoActionRegion
mContainerReferenceFrame
containingPaintedLayerData
-
>
mReferenceFrame
&
containingPaintedLayerData
-
>
mNoActionRegion
&
containingPaintedLayerData
-
>
mDispatchToContentHitRegion
&
matrixCache
inactiveLayerClip
)
;
nsLayoutUtils
:
:
TransformToAncestorAndCombineRegions
(
data
-
>
mHorizontalPanRegion
mContainerReferenceFrame
containingPaintedLayerData
-
>
mReferenceFrame
&
containingPaintedLayerData
-
>
mHorizontalPanRegion
&
containingPaintedLayerData
-
>
mDispatchToContentHitRegion
&
matrixCache
inactiveLayerClip
)
;
nsLayoutUtils
:
:
TransformToAncestorAndCombineRegions
(
data
-
>
mVerticalPanRegion
mContainerReferenceFrame
containingPaintedLayerData
-
>
mReferenceFrame
&
containingPaintedLayerData
-
>
mVerticalPanRegion
&
containingPaintedLayerData
-
>
mDispatchToContentHitRegion
&
matrixCache
inactiveLayerClip
)
;
if
(
alreadyHadRegions
)
{
containingPaintedLayerData
-
>
mDispatchToContentHitRegion
.
OrWith
(
containingPaintedLayerData
-
>
CombinedTouchActionRegion
(
)
)
;
}
}
else
{
EventRegions
regions
(
ScaleRegionToOutsidePixels
(
data
-
>
mHitRegion
)
ScaleRegionToOutsidePixels
(
data
-
>
mMaybeHitRegion
)
ScaleRegionToOutsidePixels
(
data
-
>
mDispatchToContentHitRegion
)
ScaleRegionToOutsidePixels
(
data
-
>
mNoActionRegion
)
ScaleRegionToOutsidePixels
(
data
-
>
mHorizontalPanRegion
)
ScaleRegionToOutsidePixels
(
data
-
>
mVerticalPanRegion
)
data
-
>
mDTCRequiresTargetConfirmation
)
;
Matrix
mat
=
layer
-
>
GetTransform
(
)
.
As2D
(
)
;
mat
.
Invert
(
)
;
regions
.
ApplyTranslationAndScale
(
mat
.
_31
mat
.
_32
mat
.
_11
mat
.
_22
)
;
layer
-
>
SetEventRegions
(
regions
)
;
}
SetBackfaceHiddenForLayer
(
data
-
>
mBackfaceHidden
data
-
>
mLayer
)
;
if
(
layer
!
=
data
-
>
mLayer
)
{
SetBackfaceHiddenForLayer
(
data
-
>
mBackfaceHidden
layer
)
;
}
}
static
bool
IsItemAreaInWindowOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
const
nsRect
&
aComponentAlphaBounds
)
{
if
(
!
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
IsChrome
(
)
)
{
return
true
;
}
if
(
aItem
-
>
ReferenceFrame
(
)
!
=
aBuilder
-
>
RootReferenceFrame
(
)
)
{
return
false
;
}
return
aBuilder
-
>
GetWindowOpaqueRegion
(
)
.
Contains
(
aComponentAlphaBounds
)
;
}
void
PaintedLayerData
:
:
UpdateEffectStatus
(
DisplayItemEntryType
aType
nsTArray
<
size_t
>
&
aOpacityIndices
)
{
switch
(
aType
)
{
case
DisplayItemEntryType
:
:
PUSH_OPACITY
:
aOpacityIndices
.
AppendElement
(
mAssignedDisplayItems
.
size
(
)
)
;
break
;
case
DisplayItemEntryType
:
:
POP_OPACITY
:
MOZ_ASSERT
(
!
aOpacityIndices
.
IsEmpty
(
)
)
;
aOpacityIndices
.
RemoveLastElement
(
)
;
break
;
#
ifdef
DEBUG
case
DisplayItemEntryType
:
:
POP_TRANSFORM
:
MOZ_ASSERT
(
mTransformLevel
>
=
0
)
;
mTransformLevel
-
-
;
break
;
case
DisplayItemEntryType
:
:
PUSH_TRANSFORM
:
mTransformLevel
+
+
;
break
;
#
endif
default
:
break
;
}
}
void
PaintedLayerData
:
:
Accumulate
(
ContainerState
*
aState
nsDisplayItem
*
aItem
const
nsIntRect
&
aVisibleRect
const
nsRect
&
aContentRect
const
DisplayItemClip
&
aClip
LayerState
aLayerState
nsDisplayList
*
aList
DisplayItemEntryType
aType
nsTArray
<
size_t
>
&
aOpacityIndices
const
RefPtr
<
TransformClipNode
>
&
aTransform
)
{
FLB_LOG_PAINTED_LAYER_DECISION
(
this
"
Accumulating
dp
=
%
s
(
%
p
)
f
=
%
p
against
pld
=
%
p
\
n
"
aItem
-
>
Name
(
)
aItem
aItem
-
>
Frame
(
)
this
)
;
const
bool
hasOpacity
=
aOpacityIndices
.
Length
(
)
>
0
;
const
DisplayItemClip
*
oldClip
=
mItemClip
;
mItemClip
=
&
aClip
;
UpdateEffectStatus
(
aType
aOpacityIndices
)
;
if
(
IsEffectEndMarker
(
aType
)
)
{
mAssignedDisplayItems
.
emplace_back
(
aItem
aLayerState
nullptr
aContentRect
aType
hasOpacity
aTransform
)
;
return
;
}
bool
clipMatches
=
(
oldClip
=
=
mItemClip
)
|
|
(
oldClip
&
&
*
oldClip
=
=
*
mItemClip
)
;
DisplayItemData
*
currentData
=
aItem
-
>
HasMergedFrames
(
)
?
nullptr
:
aItem
-
>
GetDisplayItemData
(
)
;
DisplayItemData
*
oldData
=
aState
-
>
mLayerBuilder
-
>
GetOldLayerForFrame
(
aItem
-
>
Frame
(
)
aItem
-
>
GetPerFrameKey
(
)
currentData
aItem
-
>
GetDisplayItemDataLayerManager
(
)
)
;
if
(
currentData
)
{
currentData
-
>
mTransform
=
nullptr
;
}
if
(
oldData
)
{
oldData
-
>
mTransform
=
nullptr
;
}
mAssignedDisplayItems
.
emplace_back
(
aItem
aLayerState
oldData
aContentRect
aType
hasOpacity
aTransform
)
;
if
(
aState
-
>
mBuilder
-
>
NeedToForceTransparentSurfaceForItem
(
aItem
)
)
{
mForceTransparentSurface
=
true
;
}
nsRect
componentAlphaBounds
;
if
(
aState
-
>
mParameters
.
mDisableSubpixelAntialiasingInDescendants
)
{
aItem
-
>
DisableComponentAlpha
(
)
;
}
else
{
componentAlphaBounds
=
aItem
-
>
GetComponentAlphaBounds
(
aState
-
>
mBuilder
)
;
if
(
!
componentAlphaBounds
.
IsEmpty
(
)
)
{
for
(
size_t
i
:
aOpacityIndices
)
{
AssignedDisplayItem
&
item
=
mAssignedDisplayItems
[
i
]
;
MOZ_ASSERT
(
item
.
mType
=
=
DisplayItemEntryType
:
:
PUSH_OPACITY
|
|
item
.
mType
=
=
DisplayItemEntryType
:
:
PUSH_OPACITY_WITH_BG
)
;
item
.
mType
=
DisplayItemEntryType
:
:
PUSH_OPACITY_WITH_BG
;
}
}
}
if
(
aItem
-
>
MustPaintOnContentSide
(
)
)
{
mShouldPaintOnContentSide
=
true
;
}
if
(
aTransform
&
&
aType
=
=
DisplayItemEntryType
:
:
ITEM
)
{
return
;
}
if
(
!
mIsSolidColorInVisibleRegion
&
&
mOpaqueRegion
.
Contains
(
aVisibleRect
)
&
&
mVisibleRegion
.
Contains
(
aVisibleRect
)
&
&
!
mImage
)
{
return
;
}
nsIntRegion
opaquePixels
;
if
(
!
hasOpacity
)
{
opaquePixels
=
aState
-
>
ComputeOpaqueRect
(
aItem
mAnimatedGeometryRoot
mASR
aClip
aList
&
mHideAllLayersBelow
&
mOpaqueForAnimatedGeometryRootParent
)
;
opaquePixels
.
AndWith
(
aVisibleRect
)
;
}
if
(
nsIntRegion
(
aVisibleRect
)
.
Contains
(
mVisibleRegion
)
&
&
opaquePixels
.
Contains
(
mVisibleRegion
)
&
&
aItem
-
>
SupportsOptimizingToImage
(
)
)
{
mImage
=
static_cast
<
nsDisplayImageContainer
*
>
(
aItem
)
;
FLB_LOG_PAINTED_LAYER_DECISION
(
this
"
Tracking
image
:
nsDisplayImageContainer
covers
the
layer
\
n
"
)
;
}
else
if
(
mImage
)
{
FLB_LOG_PAINTED_LAYER_DECISION
(
this
"
No
longer
tracking
image
\
n
"
)
;
mImage
=
nullptr
;
}
bool
isFirstVisibleItem
=
mVisibleRegion
.
IsEmpty
(
)
;
Maybe
<
nscolor
>
uniformColor
;
if
(
!
hasOpacity
)
{
uniformColor
=
aItem
-
>
IsUniform
(
aState
-
>
mBuilder
)
;
}
if
(
!
uniformColor
|
|
NS_GET_A
(
*
uniformColor
)
>
0
)
{
if
(
uniformColor
)
{
bool
snap
;
nsRect
bounds
=
aItem
-
>
GetBounds
(
aState
-
>
mBuilder
&
snap
)
;
if
(
!
aState
-
>
ScaleToInsidePixels
(
bounds
snap
)
.
Contains
(
aVisibleRect
)
)
{
uniformColor
=
Nothing
(
)
;
FLB_LOG_PAINTED_LAYER_DECISION
(
this
"
Display
item
does
not
cover
the
visible
rect
\
n
"
)
;
}
}
if
(
uniformColor
)
{
if
(
isFirstVisibleItem
)
{
mSolidColor
=
*
uniformColor
;
mIsSolidColorInVisibleRegion
=
true
;
}
else
if
(
mIsSolidColorInVisibleRegion
&
&
mVisibleRegion
.
IsEqual
(
nsIntRegion
(
aVisibleRect
)
)
&
&
clipMatches
)
{
mSolidColor
=
NS_ComposeColors
(
mSolidColor
*
uniformColor
)
;
}
else
{
FLB_LOG_PAINTED_LAYER_DECISION
(
this
"
Layer
not
a
solid
color
:
Can
'
t
blend
colors
togethers
\
n
"
)
;
mIsSolidColorInVisibleRegion
=
false
;
}
}
else
{
FLB_LOG_PAINTED_LAYER_DECISION
(
this
"
Layer
is
not
a
solid
color
:
Display
item
is
not
uniform
over
the
visible
bound
\
n
"
)
;
mIsSolidColorInVisibleRegion
=
false
;
}
mVisibleRegion
.
Or
(
mVisibleRegion
aVisibleRect
)
;
mVisibleRegion
.
SimplifyOutward
(
4
)
;
}
if
(
!
opaquePixels
.
IsEmpty
(
)
)
{
for
(
auto
iter
=
opaquePixels
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsIntRegion
tmp
;
tmp
.
Or
(
mOpaqueRegion
iter
.
Get
(
)
)
;
if
(
tmp
.
GetNumRects
(
)
<
=
4
|
|
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
IsChrome
(
)
)
{
mOpaqueRegion
=
std
:
:
move
(
tmp
)
;
}
}
}
if
(
!
aState
-
>
mParameters
.
mDisableSubpixelAntialiasingInDescendants
&
&
!
componentAlphaBounds
.
IsEmpty
(
)
)
{
nsIntRect
componentAlphaRect
=
aState
-
>
ScaleToOutsidePixels
(
componentAlphaBounds
false
)
.
Intersect
(
aVisibleRect
)
;
if
(
!
mOpaqueRegion
.
Contains
(
componentAlphaRect
)
)
{
if
(
IsItemAreaInWindowOpaqueRegion
(
aState
-
>
mBuilder
aItem
componentAlphaBounds
.
Intersect
(
aItem
-
>
GetBuildingRect
(
)
)
)
)
{
mNeedComponentAlpha
=
true
;
}
else
{
aItem
-
>
DisableComponentAlpha
(
)
;
}
}
}
if
(
aState
-
>
mParameters
.
mInActiveTransformedSubtree
&
&
(
mNeedComponentAlpha
|
|
!
componentAlphaBounds
.
IsEmpty
(
)
)
)
{
mDisableFlattening
=
true
;
}
}
nsRegion
PaintedLayerData
:
:
CombinedTouchActionRegion
(
)
{
nsRegion
result
;
result
.
Or
(
mHorizontalPanRegion
mVerticalPanRegion
)
;
result
.
OrWith
(
mNoActionRegion
)
;
return
result
;
}
void
PaintedLayerData
:
:
AccumulateHitTestInfo
(
ContainerState
*
aState
nsDisplayCompositorHitTestInfo
*
aItem
TransformClipNode
*
aTransform
)
{
FLB_LOG_PAINTED_LAYER_DECISION
(
this
"
Accumulating
hit
test
info
%
p
against
pld
=
%
p
\
n
"
aItem
this
)
;
const
mozilla
:
:
DisplayItemClip
&
clip
=
aItem
-
>
GetClip
(
)
;
nsRect
area
=
clip
.
ApplyNonRoundedIntersection
(
aItem
-
>
Area
(
)
)
;
if
(
aTransform
)
{
area
=
TransformWithNode
(
aTransform
area
aState
-
>
mAppUnitsPerDevPixel
)
;
}
const
mozilla
:
:
gfx
:
:
CompositorHitTestInfo
hitTestInfo
=
aItem
-
>
HitTestInfo
(
)
;
bool
hasRoundedCorners
=
clip
.
GetRoundedRectCount
(
)
>
0
;
nsIFrame
*
frame
=
aItem
-
>
Frame
(
)
;
bool
simpleRegions
=
frame
-
>
HasAnyStateBits
(
NS_FRAME_SIMPLE_EVENT_REGIONS
)
;
if
(
!
simpleRegions
)
{
if
(
nsLayoutUtils
:
:
HasNonZeroCorner
(
frame
-
>
StyleBorder
(
)
-
>
mBorderRadius
)
)
{
hasRoundedCorners
=
true
;
}
else
{
frame
-
>
AddStateBits
(
NS_FRAME_SIMPLE_EVENT_REGIONS
)
;
}
}
if
(
hasRoundedCorners
|
|
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
mMaybeHitRegion
.
OrWith
(
area
)
;
}
else
{
mHitRegion
.
OrWith
(
area
)
;
}
if
(
aItem
-
>
HitTestInfo
(
)
&
CompositorHitTestInfo
:
:
eDispatchToContent
)
{
mDispatchToContentHitRegion
.
OrWith
(
area
)
;
if
(
aItem
-
>
HitTestInfo
(
)
&
CompositorHitTestInfo
:
:
eRequiresTargetConfirmation
)
{
mDTCRequiresTargetConfirmation
=
true
;
}
}
auto
touchFlags
=
hitTestInfo
&
CompositorHitTestInfo
:
:
eTouchActionMask
;
if
(
touchFlags
)
{
if
(
mCollapsedTouchActions
)
{
mDispatchToContentHitRegion
.
OrWith
(
area
)
;
}
else
if
(
touchFlags
=
=
CompositorHitTestInfo
:
:
eTouchActionMask
)
{
mNoActionRegion
.
OrWith
(
area
)
;
}
else
{
if
(
touchFlags
!
=
CompositorHitTestInfo
:
:
eTouchActionDoubleTapZoomDisabled
)
{
if
(
!
(
hitTestInfo
&
CompositorHitTestInfo
:
:
eTouchActionPanXDisabled
)
)
{
mHorizontalPanRegion
.
OrWith
(
area
)
;
}
if
(
!
(
hitTestInfo
&
CompositorHitTestInfo
:
:
eTouchActionPanYDisabled
)
)
{
mVerticalPanRegion
.
OrWith
(
area
)
;
}
}
else
{
}
}
}
if
(
!
mCollapsedTouchActions
)
{
const
int
alreadyHadRegions
=
mNoActionRegion
.
GetNumRects
(
)
+
mHorizontalPanRegion
.
GetNumRects
(
)
+
mVerticalPanRegion
.
GetNumRects
(
)
;
if
(
alreadyHadRegions
>
1
)
{
mDispatchToContentHitRegion
.
OrWith
(
CombinedTouchActionRegion
(
)
)
;
mNoActionRegion
.
SetEmpty
(
)
;
mHorizontalPanRegion
.
SetEmpty
(
)
;
mVerticalPanRegion
.
SetEmpty
(
)
;
mCollapsedTouchActions
=
true
;
}
}
mMaybeHitRegion
.
SimplifyOutward
(
8
)
;
mDispatchToContentHitRegion
.
SimplifyOutward
(
8
)
;
mScaledHitRegionBounds
=
aState
-
>
ScaleToOutsidePixels
(
mHitRegion
.
GetBounds
(
)
)
;
mScaledMaybeHitRegionBounds
=
aState
-
>
ScaleToOutsidePixels
(
mMaybeHitRegion
.
GetBounds
(
)
)
;
}
void
ContainerState
:
:
NewPaintedLayerData
(
PaintedLayerData
*
aData
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aClipChain
const
ActiveScrolledRoot
*
aScrollMetadataASR
const
nsPoint
&
aTopLeft
const
nsIFrame
*
aReferenceFrame
const
bool
aBackfaceHidden
)
{
aData
-
>
mAnimatedGeometryRoot
=
aAnimatedGeometryRoot
;
aData
-
>
mASR
=
aASR
;
aData
-
>
mClipChain
=
aClipChain
;
aData
-
>
mAnimatedGeometryRootOffset
=
aTopLeft
;
aData
-
>
mReferenceFrame
=
aReferenceFrame
;
aData
-
>
mBackfaceHidden
=
aBackfaceHidden
;
aData
-
>
mNewChildLayersIndex
=
mNewChildLayers
.
Length
(
)
;
NewLayerEntry
*
newLayerEntry
=
mNewChildLayers
.
AppendElement
(
)
;
newLayerEntry
-
>
mAnimatedGeometryRoot
=
aAnimatedGeometryRoot
;
newLayerEntry
-
>
mASR
=
aASR
;
newLayerEntry
-
>
mScrollMetadataASR
=
aScrollMetadataASR
;
newLayerEntry
-
>
mClipChain
=
aClipChain
;
mNewChildLayers
.
AppendElement
(
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
static
void
DumpPaintedImage
(
nsDisplayItem
*
aItem
SourceSurface
*
aSurface
)
{
nsCString
string
(
aItem
-
>
Name
(
)
)
;
string
.
Append
(
'
-
'
)
;
string
.
AppendInt
(
(
uint64_t
)
aItem
)
;
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
"
<
script
>
array
[
\
"
%
s
\
"
]
=
\
"
"
string
.
BeginReading
(
)
)
;
gfxUtils
:
:
DumpAsDataURI
(
aSurface
gfxUtils
:
:
sDumpPaintFile
)
;
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
"
\
"
;
<
/
script
>
\
n
"
)
;
}
#
endif
static
void
PaintInactiveLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
nsDisplayItem
*
aItem
gfxContext
*
aContext
gfxContext
*
aCtx
)
{
BasicLayerManager
*
basic
=
static_cast
<
BasicLayerManager
*
>
(
aManager
)
;
RefPtr
<
gfxContext
>
context
=
aContext
;
#
ifdef
MOZ_DUMP_PAINTING
int32_t
appUnitsPerDevPixel
=
AppUnitsPerDevPixel
(
aItem
)
;
nsIntRect
itemVisibleRect
=
aItem
-
>
GetPaintRect
(
)
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
;
RefPtr
<
DrawTarget
>
tempDT
;
if
(
gfxEnv
:
:
DumpPaint
(
)
)
{
tempDT
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
itemVisibleRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
tempDT
)
{
context
=
gfxContext
:
:
CreateOrNull
(
tempDT
)
;
if
(
!
context
)
{
gfxDevCrash
(
LogReason
:
:
InvalidContext
)
<
<
"
PaintInactive
context
problem
"
<
<
gfx
:
:
hexa
(
tempDT
)
;
return
;
}
context
-
>
SetMatrix
(
Matrix
:
:
Translation
(
-
itemVisibleRect
.
x
-
itemVisibleRect
.
y
)
)
;
}
}
#
endif
basic
-
>
BeginTransaction
(
)
;
basic
-
>
SetTarget
(
context
)
;
if
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_MASK
)
{
static_cast
<
nsDisplayMask
*
>
(
aItem
)
-
>
PaintAsLayer
(
aBuilder
aCtx
basic
)
;
if
(
basic
-
>
InTransaction
(
)
)
{
basic
-
>
AbortTransaction
(
)
;
}
}
else
if
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_FILTER
)
{
static_cast
<
nsDisplayFilter
*
>
(
aItem
)
-
>
PaintAsLayer
(
aBuilder
aCtx
basic
)
;
if
(
basic
-
>
InTransaction
(
)
)
{
basic
-
>
AbortTransaction
(
)
;
}
}
else
{
basic
-
>
EndTransaction
(
FrameLayerBuilder
:
:
DrawPaintedLayer
aBuilder
)
;
}
FrameLayerBuilder
*
builder
=
static_cast
<
FrameLayerBuilder
*
>
(
basic
-
>
GetUserData
(
&
gLayerManagerLayerBuilder
)
)
;
if
(
builder
)
{
builder
-
>
DidEndTransaction
(
)
;
}
basic
-
>
SetTarget
(
nullptr
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxEnv
:
:
DumpPaint
(
)
&
&
tempDT
)
{
RefPtr
<
SourceSurface
>
surface
=
tempDT
-
>
Snapshot
(
)
;
DumpPaintedImage
(
aItem
surface
)
;
DrawTarget
*
drawTarget
=
aContext
-
>
GetDrawTarget
(
)
;
Rect
rect
(
itemVisibleRect
.
x
itemVisibleRect
.
y
itemVisibleRect
.
width
itemVisibleRect
.
height
)
;
drawTarget
-
>
DrawSurface
(
surface
rect
Rect
(
Point
(
0
0
)
rect
.
Size
(
)
)
)
;
aItem
-
>
SetPainted
(
)
;
}
#
endif
}
nsRect
ContainerState
:
:
GetDisplayPortForAnimatedGeometryRoot
(
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
)
{
if
(
mLastDisplayPortAGR
=
=
aAnimatedGeometryRoot
)
{
return
mLastDisplayPortRect
;
}
mLastDisplayPortAGR
=
aAnimatedGeometryRoot
;
nsIScrollableFrame
*
sf
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
*
aAnimatedGeometryRoot
)
;
if
(
sf
=
=
nullptr
|
|
nsLayoutUtils
:
:
UsesAsyncScrolling
(
*
aAnimatedGeometryRoot
)
)
{
mLastDisplayPortRect
=
nsRect
(
)
;
return
mLastDisplayPortRect
;
}
bool
usingDisplayport
=
nsLayoutUtils
:
:
GetDisplayPort
(
(
*
aAnimatedGeometryRoot
)
-
>
GetContent
(
)
&
mLastDisplayPortRect
RelativeTo
:
:
ScrollFrame
)
;
if
(
!
usingDisplayport
)
{
mLastDisplayPortRect
=
sf
-
>
GetScrollPortRect
(
)
;
}
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
sf
)
;
mLastDisplayPortRect
+
=
scrollFrame
-
>
GetOffsetToCrossDoc
(
mContainerReferenceFrame
)
;
return
mLastDisplayPortRect
;
}
nsIntRegion
ContainerState
:
:
ComputeOpaqueRect
(
nsDisplayItem
*
aItem
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClip
&
aClip
nsDisplayList
*
aList
bool
*
aHideAllLayersBelow
bool
*
aOpaqueForAnimatedGeometryRootParent
)
{
bool
snapOpaque
;
nsRegion
opaque
=
aItem
-
>
GetOpaqueRegion
(
mBuilder
&
snapOpaque
)
;
if
(
opaque
.
IsEmpty
(
)
)
{
return
nsIntRegion
(
)
;
}
nsIntRegion
opaquePixels
;
nsRegion
opaqueClipped
;
for
(
auto
iter
=
opaque
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
opaqueClipped
.
Or
(
opaqueClipped
aClip
.
ApproximateIntersectInward
(
iter
.
Get
(
)
)
)
;
}
if
(
aAnimatedGeometryRoot
=
=
mContainerAnimatedGeometryRoot
&
&
aASR
=
=
mContainerASR
&
&
opaqueClipped
.
Contains
(
mContainerBounds
)
)
{
*
aHideAllLayersBelow
=
true
;
aList
-
>
SetIsOpaque
(
)
;
}
if
(
!
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
mContainerFrame
)
)
{
mBuilder
-
>
AddWindowOpaqueRegion
(
opaqueClipped
)
;
}
opaquePixels
=
ScaleRegionToInsidePixels
(
opaqueClipped
snapOpaque
)
;
if
(
IsInInactiveLayer
(
)
)
{
return
opaquePixels
;
}
const
nsRect
&
displayport
=
GetDisplayPortForAnimatedGeometryRoot
(
aAnimatedGeometryRoot
)
;
if
(
!
displayport
.
IsEmpty
(
)
&
&
opaquePixels
.
Contains
(
ScaleRegionToNearestPixels
(
displayport
)
)
)
{
*
aOpaqueForAnimatedGeometryRootParent
=
true
;
}
return
opaquePixels
;
}
Maybe
<
size_t
>
ContainerState
:
:
SetupMaskLayerForScrolledClip
(
Layer
*
aLayer
const
DisplayItemClip
&
aClip
)
{
if
(
aClip
.
GetRoundedRectCount
(
)
>
0
)
{
Maybe
<
size_t
>
maskLayerIndex
=
Some
(
aLayer
-
>
GetAncestorMaskLayerCount
(
)
)
;
if
(
RefPtr
<
Layer
>
maskLayer
=
CreateMaskLayer
(
aLayer
aClip
maskLayerIndex
)
)
{
aLayer
-
>
AddAncestorMaskLayer
(
maskLayer
)
;
return
maskLayerIndex
;
}
}
return
Nothing
(
)
;
}
static
const
ActiveScrolledRoot
*
GetASRForPerspective
(
const
ActiveScrolledRoot
*
aASR
nsIFrame
*
aPerspectiveFrame
)
{
for
(
const
ActiveScrolledRoot
*
asr
=
aASR
;
asr
;
asr
=
asr
-
>
mParent
)
{
nsIFrame
*
scrolledFrame
=
asr
-
>
mScrollableFrame
-
>
GetScrolledFrame
(
)
;
if
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
scrolledFrame
aPerspectiveFrame
)
)
{
return
asr
;
}
}
return
nullptr
;
}
static
CSSMaskLayerUserData
*
GetCSSMaskLayerUserData
(
Layer
*
aMaskLayer
)
{
if
(
!
aMaskLayer
)
{
return
nullptr
;
}
return
static_cast
<
CSSMaskLayerUserData
*
>
(
aMaskLayer
-
>
GetUserData
(
&
gCSSMaskLayerUserData
)
)
;
}
static
void
SetCSSMaskLayerUserData
(
Layer
*
aMaskLayer
)
{
MOZ_ASSERT
(
aMaskLayer
)
;
aMaskLayer
-
>
SetUserData
(
&
gCSSMaskLayerUserData
new
CSSMaskLayerUserData
(
)
)
;
}
void
ContainerState
:
:
SetupMaskLayerForCSSMask
(
Layer
*
aLayer
nsDisplayMask
*
aMaskItem
)
{
RefPtr
<
ImageLayer
>
maskLayer
=
CreateOrRecycleMaskImageLayerFor
(
MaskLayerKey
(
aLayer
Nothing
(
)
)
GetCSSMaskLayerUserData
SetCSSMaskLayerUserData
)
;
CSSMaskLayerUserData
*
oldUserData
=
GetCSSMaskLayerUserData
(
maskLayer
.
get
(
)
)
;
MOZ_ASSERT
(
oldUserData
)
;
bool
snap
;
nsRect
bounds
=
aMaskItem
-
>
GetBounds
(
mBuilder
&
snap
)
;
nsIntRect
itemRect
=
ScaleToOutsidePixels
(
bounds
snap
)
;
Matrix4x4
matrix
;
matrix
.
PreTranslate
(
itemRect
.
x
itemRect
.
y
0
)
;
matrix
.
PreTranslate
(
mParameters
.
mOffset
.
x
mParameters
.
mOffset
.
y
0
)
;
maskLayer
-
>
SetBaseTransform
(
matrix
)
;
nsPoint
maskLayerOffset
=
aMaskItem
-
>
ToReferenceFrame
(
)
-
bounds
.
TopLeft
(
)
;
CSSMaskLayerUserData
newUserData
(
aMaskItem
-
>
Frame
(
)
itemRect
maskLayerOffset
)
;
nsRect
dirtyRect
;
if
(
!
aMaskItem
-
>
IsInvalid
(
dirtyRect
)
&
&
*
oldUserData
=
=
newUserData
)
{
aLayer
-
>
SetMaskLayer
(
maskLayer
)
;
return
;
}
int32_t
maxSize
=
mManager
-
>
GetMaxTextureSize
(
)
;
IntSize
surfaceSize
(
std
:
:
min
(
itemRect
.
width
maxSize
)
std
:
:
min
(
itemRect
.
height
maxSize
)
)
;
if
(
surfaceSize
.
IsEmpty
(
)
)
{
return
;
}
MaskImageData
imageData
(
surfaceSize
mManager
)
;
RefPtr
<
DrawTarget
>
dt
=
imageData
.
CreateDrawTarget
(
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
NS_WARNING
(
"
Could
not
create
DrawTarget
for
mask
layer
.
"
)
;
return
;
}
RefPtr
<
gfxContext
>
maskCtx
=
gfxContext
:
:
CreateOrNull
(
dt
)
;
maskCtx
-
>
SetMatrix
(
Matrix
:
:
Translation
(
-
itemRect
.
TopLeft
(
)
)
)
;
maskCtx
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
mParameters
.
mXScale
mParameters
.
mYScale
)
)
;
bool
isPaintFinished
=
aMaskItem
-
>
PaintMask
(
mBuilder
maskCtx
)
;
RefPtr
<
ImageContainer
>
imgContainer
=
imageData
.
CreateImageAndImageContainer
(
)
;
if
(
!
imgContainer
)
{
return
;
}
maskLayer
-
>
SetContainer
(
imgContainer
)
;
if
(
isPaintFinished
)
{
*
oldUserData
=
std
:
:
move
(
newUserData
)
;
}
aLayer
-
>
SetMaskLayer
(
maskLayer
)
;
}
static
bool
IsScrollThumbLayer
(
nsDisplayItem
*
aItem
)
{
return
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_OWN_LAYER
&
&
static_cast
<
nsDisplayOwnLayer
*
>
(
aItem
)
-
>
IsScrollThumbLayer
(
)
;
}
template
<
typename
ClearFn
typename
SelectFn
>
static
void
ProcessDisplayItemMarker
(
DisplayItemEntryType
aMarker
ClearFn
ClearLayerSelectionIfNeeded
SelectFn
SelectLayerIfNeeded
)
{
switch
(
aMarker
)
{
case
DisplayItemEntryType
:
:
PUSH_TRANSFORM
:
case
DisplayItemEntryType
:
:
PUSH_OPACITY
:
SelectLayerIfNeeded
(
)
;
break
;
case
DisplayItemEntryType
:
:
POP_TRANSFORM
:
case
DisplayItemEntryType
:
:
POP_OPACITY
:
ClearLayerSelectionIfNeeded
(
)
;
break
;
default
:
break
;
}
}
void
ContainerState
:
:
ProcessDisplayItems
(
nsDisplayList
*
aList
)
{
AUTO_PROFILER_LABEL
(
"
ContainerState
:
:
ProcessDisplayItems
"
GRAPHICS
)
;
nsPoint
topLeft
(
0
0
)
;
int32_t
maxLayers
=
gfxPrefs
:
:
MaxActiveLayers
(
)
;
int
layerCount
=
0
;
if
(
!
mManager
-
>
IsWidgetLayerManager
(
)
)
{
mPaintedLayerDataTree
.
InitializeForInactiveLayer
(
mContainerAnimatedGeometryRoot
)
;
}
AnimatedGeometryRoot
*
lastAnimatedGeometryRoot
=
nullptr
;
nsPoint
lastTopLeft
;
PaintedLayerData
*
selectedLayer
=
nullptr
;
AutoTArray
<
size_t
2
>
opacityIndices
;
AnimatedGeometryRoot
*
containerAGR
=
nullptr
;
const
ActiveScrolledRoot
*
containerASR
=
nullptr
;
RefPtr
<
TransformClipNode
>
transformNode
=
nullptr
;
const
auto
InTransform
=
[
&
]
(
)
{
return
transformNode
;
}
;
const
auto
InOpacity
=
[
&
]
(
)
{
return
selectedLayer
&
&
opacityIndices
.
Length
(
)
>
0
;
}
;
FLBDisplayItemIterator
iter
(
mBuilder
aList
this
)
;
while
(
iter
.
HasNext
(
)
)
{
DisplayItemEntry
e
=
iter
.
GetNextEntry
(
)
;
DisplayItemEntryType
marker
=
e
.
mType
;
nsDisplayItem
*
item
=
e
.
mItem
;
MOZ_ASSERT
(
item
)
;
DisplayItemType
itemType
=
item
-
>
GetType
(
)
;
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
)
{
nsDisplayCompositorHitTestInfo
*
hitTestInfo
=
static_cast
<
nsDisplayCompositorHitTestInfo
*
>
(
item
)
;
if
(
hitTestInfo
-
>
Area
(
)
.
IsEmpty
(
)
)
{
continue
;
}
if
(
InTransform
(
)
|
|
InOpacity
(
)
)
{
MOZ_ASSERT
(
selectedLayer
)
;
selectedLayer
-
>
AccumulateHitTestInfo
(
this
hitTestInfo
transformNode
)
;
continue
;
}
}
MOZ_ASSERT
(
item
-
>
GetType
(
)
!
=
DisplayItemType
:
:
TYPE_WRAP_LIST
)
;
NS_ASSERTION
(
mAppUnitsPerDevPixel
=
=
AppUnitsPerDevPixel
(
item
)
"
items
in
a
container
layer
should
all
have
the
same
app
units
per
dev
pixel
"
)
;
if
(
mBuilder
-
>
NeedToForceTransparentSurfaceForItem
(
item
)
)
{
aList
-
>
SetNeedsTransparentSurface
(
)
;
}
if
(
mParameters
.
mForEventsAndPluginsOnly
&
&
!
item
-
>
GetChildren
(
)
&
&
(
itemType
!
=
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
&
&
itemType
!
=
DisplayItemType
:
:
TYPE_PLUGIN
)
)
{
continue
;
}
LayerState
layerState
=
LAYER_NONE
;
if
(
marker
=
=
DisplayItemEntryType
:
:
ITEM
)
{
layerState
=
item
-
>
GetLayerState
(
mBuilder
mManager
mParameters
)
;
if
(
layerState
=
=
LAYER_INACTIVE
&
&
nsDisplayItem
:
:
ForceActiveLayers
(
)
)
{
layerState
=
LAYER_ACTIVE
;
}
}
bool
forceInactive
=
false
;
AnimatedGeometryRoot
*
animatedGeometryRoot
;
const
ActiveScrolledRoot
*
itemASR
=
nullptr
;
const
DisplayItemClipChain
*
layerClipChain
=
nullptr
;
if
(
mManager
-
>
IsWidgetLayerManager
(
)
&
&
!
InTransform
(
)
)
{
animatedGeometryRoot
=
item
-
>
GetAnimatedGeometryRoot
(
)
;
itemASR
=
item
-
>
GetActiveScrolledRoot
(
)
;
const
DisplayItemClipChain
*
itemClipChain
=
item
-
>
GetClipChain
(
)
;
if
(
itemClipChain
&
&
itemClipChain
-
>
mASR
=
=
itemASR
&
&
itemType
!
=
DisplayItemType
:
:
TYPE_STICKY_POSITION
)
{
layerClipChain
=
itemClipChain
-
>
mParent
;
}
else
{
layerClipChain
=
itemClipChain
;
}
}
else
if
(
InTransform
(
)
)
{
animatedGeometryRoot
=
containerAGR
;
itemASR
=
containerASR
;
if
(
marker
!
=
DisplayItemEntryType
:
:
POP_TRANSFORM
)
{
item
-
>
FuseClipChainUpTo
(
mBuilder
containerASR
)
;
}
}
else
{
animatedGeometryRoot
=
mContainerAnimatedGeometryRoot
;
itemASR
=
mContainerASR
;
item
-
>
FuseClipChainUpTo
(
mBuilder
mContainerASR
)
;
}
if
(
animatedGeometryRoot
=
=
lastAnimatedGeometryRoot
)
{
topLeft
=
lastTopLeft
;
}
else
{
lastTopLeft
=
topLeft
=
(
*
animatedGeometryRoot
)
-
>
GetOffsetToCrossDoc
(
mContainerReferenceFrame
)
;
lastAnimatedGeometryRoot
=
animatedGeometryRoot
;
}
const
ActiveScrolledRoot
*
scrollMetadataASR
=
layerClipChain
?
ActiveScrolledRoot
:
:
PickDescendant
(
itemASR
layerClipChain
-
>
mASR
)
:
itemASR
;
const
bool
prerenderedTransform
=
itemType
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
MayBeAnimated
(
mBuilder
)
;
bool
snap
;
nsRect
itemContent
=
item
-
>
GetBounds
(
mBuilder
&
snap
)
;
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
)
{
nsDisplayCompositorHitTestInfo
*
hitInfo
=
static_cast
<
nsDisplayCompositorHitTestInfo
*
>
(
item
)
;
itemContent
=
hitInfo
-
>
Area
(
)
;
}
nsIntRect
itemDrawRect
=
ScaleToOutsidePixels
(
itemContent
snap
)
;
const
DisplayItemClip
&
itemClip
=
item
-
>
GetClip
(
)
;
ParentLayerIntRect
clipRect
;
if
(
itemClip
.
HasClip
(
)
)
{
const
nsRect
&
itemClipRect
=
itemClip
.
GetClipRect
(
)
;
itemContent
.
IntersectRect
(
itemContent
itemClipRect
)
;
clipRect
=
ViewAs
<
ParentLayerPixel
>
(
ScaleToNearestPixels
(
itemClipRect
)
)
;
if
(
!
prerenderedTransform
&
&
!
IsScrollThumbLayer
(
item
)
)
{
itemDrawRect
.
IntersectRect
(
itemDrawRect
clipRect
.
ToUnknownRect
(
)
)
;
}
clipRect
.
MoveBy
(
ViewAs
<
ParentLayerPixel
>
(
mParameters
.
mOffset
)
)
;
}
if
(
marker
=
=
DisplayItemEntryType
:
:
POP_TRANSFORM
)
{
MOZ_ASSERT
(
transformNode
)
;
transformNode
=
transformNode
-
>
Parent
(
)
;
}
if
(
transformNode
)
{
MOZ_ASSERT
(
transformNode
)
;
itemContent
=
TransformWithNode
(
transformNode
itemContent
mAppUnitsPerDevPixel
)
;
itemDrawRect
=
TransformWithNode
(
transformNode
itemDrawRect
mAppUnitsPerDevPixel
)
;
}
#
ifdef
DEBUG
nsRect
bounds
=
itemContent
;
const
bool
inEffect
=
InTransform
(
)
|
|
InOpacity
(
)
;
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
|
|
inEffect
)
{
bounds
.
SetEmpty
(
)
;
}
if
(
!
bounds
.
IsEmpty
(
)
&
&
itemASR
!
=
mContainerASR
)
{
if
(
Maybe
<
nsRect
>
clip
=
item
-
>
GetClipWithRespectToASR
(
mBuilder
mContainerASR
)
)
{
bounds
=
clip
.
ref
(
)
;
}
}
(
(
nsRect
&
)
mAccumulatedChildBounds
)
.
UnionRect
(
mAccumulatedChildBounds
bounds
)
;
#
endif
nsIntRect
itemVisibleRect
=
itemDrawRect
;
if
(
!
prerenderedTransform
)
{
nsRect
itemBuildingRect
=
item
-
>
GetBuildingRect
(
)
;
if
(
transformNode
)
{
itemBuildingRect
=
TransformWithNode
(
transformNode
itemBuildingRect
mAppUnitsPerDevPixel
)
;
}
itemVisibleRect
=
itemVisibleRect
.
Intersect
(
ScaleToOutsidePixels
(
itemBuildingRect
false
)
)
;
}
if
(
maxLayers
!
=
-
1
&
&
layerCount
>
=
maxLayers
)
{
forceInactive
=
true
;
}
bool
treatInactiveItemAsActive
=
(
layerState
=
=
LAYER_INACTIVE
&
&
mLayerBuilder
-
>
GetContainingPaintedLayerData
(
)
)
;
if
(
layerState
=
=
LAYER_ACTIVE_FORCE
|
|
treatInactiveItemAsActive
|
|
(
!
forceInactive
&
&
(
layerState
=
=
LAYER_ACTIVE_EMPTY
|
|
layerState
=
=
LAYER_ACTIVE
)
)
)
{
layerCount
+
+
;
MOZ_ASSERT
(
selectedLayer
=
=
nullptr
)
;
MOZ_ASSERT
(
marker
=
=
DisplayItemEntryType
:
:
ITEM
)
;
NS_ASSERTION
(
layerState
!
=
LAYER_ACTIVE_EMPTY
|
|
itemVisibleRect
.
IsEmpty
(
)
"
State
is
LAYER_ACTIVE_EMPTY
but
visible
rect
is
not
.
"
)
;
DisplayItemData
*
oldData
=
mLayerBuilder
-
>
GetOldLayerForFrame
(
item
-
>
Frame
(
)
item
-
>
GetPerFrameKey
(
)
)
;
InvalidateForLayerChange
(
item
nullptr
oldData
)
;
if
(
itemVisibleRect
.
IsEmpty
(
)
&
&
!
item
-
>
ShouldBuildLayerEvenIfInvisible
(
mBuilder
)
)
{
continue
;
}
bool
mayDrawOutOfOrder
=
itemType
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
(
item
-
>
Frame
(
)
-
>
Combines3DTransformWithAncestors
(
)
|
|
item
-
>
Frame
(
)
-
>
Extend3DContext
(
)
)
;
nscolor
uniformColor
=
NS_RGBA
(
0
0
0
0
)
;
nscolor
*
uniformColorPtr
=
(
mayDrawOutOfOrder
|
|
IsInInactiveLayer
(
)
)
?
nullptr
:
&
uniformColor
;
nsIntRect
clipRectUntyped
;
nsIntRect
*
clipPtr
=
nullptr
;
if
(
itemClip
.
HasClip
(
)
)
{
clipRectUntyped
=
clipRect
.
ToUnknownRect
(
)
;
clipPtr
=
&
clipRectUntyped
;
}
bool
hasScrolledClip
=
layerClipChain
&
&
layerClipChain
-
>
mClip
.
HasClip
(
)
&
&
(
!
ActiveScrolledRoot
:
:
IsAncestor
(
layerClipChain
-
>
mASR
itemASR
)
|
|
itemType
=
=
DisplayItemType
:
:
TYPE_STICKY_POSITION
)
;
if
(
hasScrolledClip
)
{
const
ActiveScrolledRoot
*
clipASR
=
layerClipChain
-
>
mASR
;
AnimatedGeometryRoot
*
clipAGR
=
mBuilder
-
>
AnimatedGeometryRootForASR
(
clipASR
)
;
nsIntRect
scrolledClipRect
=
ScaleToNearestPixels
(
layerClipChain
-
>
mClip
.
GetClipRect
(
)
)
+
mParameters
.
mOffset
;
mPaintedLayerDataTree
.
AddingOwnLayer
(
clipAGR
&
scrolledClipRect
uniformColorPtr
)
;
}
else
if
(
item
-
>
ShouldFixToViewport
(
mBuilder
)
&
&
itemClip
.
HasClip
(
)
&
&
item
-
>
AnimatedGeometryRootForScrollMetadata
(
)
!
=
animatedGeometryRoot
&
&
!
nsLayoutUtils
:
:
UsesAsyncScrolling
(
item
-
>
Frame
(
)
)
)
{
AnimatedGeometryRoot
*
clipAGR
=
item
-
>
AnimatedGeometryRootForScrollMetadata
(
)
;
nsIntRect
scrolledClipRect
=
ScaleToNearestPixels
(
itemClip
.
GetClipRect
(
)
)
+
mParameters
.
mOffset
;
mPaintedLayerDataTree
.
AddingOwnLayer
(
clipAGR
&
scrolledClipRect
uniformColorPtr
)
;
}
else
if
(
IsScrollThumbLayer
(
item
)
&
&
mManager
-
>
IsWidgetLayerManager
(
)
)
{
mPaintedLayerDataTree
.
AddingOwnLayer
(
animatedGeometryRoot
-
>
mParentAGR
clipPtr
uniformColorPtr
)
;
}
else
if
(
prerenderedTransform
&
&
mManager
-
>
IsWidgetLayerManager
(
)
)
{
if
(
animatedGeometryRoot
-
>
mParentAGR
)
{
mPaintedLayerDataTree
.
AddingOwnLayer
(
animatedGeometryRoot
-
>
mParentAGR
clipPtr
uniformColorPtr
)
;
}
else
{
mPaintedLayerDataTree
.
AddingOwnLayer
(
animatedGeometryRoot
nullptr
uniformColorPtr
)
;
}
}
else
{
mPaintedLayerDataTree
.
AddingOwnLayer
(
animatedGeometryRoot
&
itemVisibleRect
uniformColorPtr
)
;
}
ContainerLayerParameters
params
=
mParameters
;
params
.
mBackgroundColor
=
uniformColor
;
params
.
mLayerCreationHint
=
GetLayerCreationHint
(
animatedGeometryRoot
)
;
params
.
mScrollMetadataASR
=
ActiveScrolledRoot
:
:
PickDescendant
(
mContainerScrollMetadataASR
scrollMetadataASR
)
;
params
.
mCompositorASR
=
params
.
mScrollMetadataASR
!
=
mContainerScrollMetadataASR
?
params
.
mScrollMetadataASR
:
mContainerCompositorASR
;
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_FIXED_POSITION
)
{
params
.
mCompositorASR
=
itemASR
;
}
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_PERSPECTIVE
)
{
scrollMetadataASR
=
GetASRForPerspective
(
scrollMetadataASR
item
-
>
Frame
(
)
-
>
GetContainingBlock
(
nsIFrame
:
:
SKIP_SCROLLED_FRAME
)
)
;
params
.
mScrollMetadataASR
=
scrollMetadataASR
;
itemASR
=
scrollMetadataASR
;
}
nsIntRect
layerContentsVisibleRect
(
0
0
-
1
-
1
)
;
params
.
mLayerContentsVisibleRect
=
&
layerContentsVisibleRect
;
const
DisplayItemClip
*
originalInactiveClip
=
nullptr
;
DisplayItemClip
combinedInactiveClip
;
if
(
treatInactiveItemAsActive
)
{
originalInactiveClip
=
mLayerBuilder
-
>
GetInactiveLayerClip
(
)
;
if
(
originalInactiveClip
)
{
combinedInactiveClip
=
*
originalInactiveClip
;
}
DisplayItemClip
nestedClip
=
item
-
>
GetClip
(
)
;
if
(
nestedClip
.
HasClip
(
)
)
{
nsRect
nestedClipRect
=
nestedClip
.
NonRoundedIntersection
(
)
;
nestedClipRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
item
-
>
ReferenceFrame
(
)
nestedClipRect
mLayerBuilder
-
>
GetContainingPaintedLayerData
(
)
-
>
mReferenceFrame
)
;
nestedClip
.
SetTo
(
nestedClipRect
)
;
combinedInactiveClip
.
IntersectWith
(
nestedClip
)
;
mLayerBuilder
-
>
SetInactiveLayerClip
(
&
combinedInactiveClip
)
;
}
}
RefPtr
<
Layer
>
ownLayer
=
item
-
>
BuildLayer
(
mBuilder
mManager
params
)
;
if
(
treatInactiveItemAsActive
)
{
mLayerBuilder
-
>
SetInactiveLayerClip
(
originalInactiveClip
)
;
}
if
(
!
ownLayer
)
{
continue
;
}
NS_ASSERTION
(
!
ownLayer
-
>
AsPaintedLayer
(
)
"
Should
never
have
created
a
dedicated
Painted
layer
!
"
)
;
if
(
item
-
>
BackfaceIsHidden
(
)
)
{
ownLayer
-
>
SetContentFlags
(
ownLayer
-
>
GetContentFlags
(
)
|
Layer
:
:
CONTENT_BACKFACE_HIDDEN
)
;
}
else
{
ownLayer
-
>
SetContentFlags
(
ownLayer
-
>
GetContentFlags
(
)
&
~
Layer
:
:
CONTENT_BACKFACE_HIDDEN
)
;
}
nsRect
invalid
;
if
(
item
-
>
IsInvalid
(
invalid
)
)
{
ownLayer
-
>
SetInvalidRectToVisibleRegion
(
)
;
}
if
(
!
ownLayer
-
>
AsContainerLayer
(
)
)
{
ownLayer
-
>
SetPostScale
(
mParameters
.
mXScale
mParameters
.
mYScale
)
;
}
NS_ASSERTION
(
ownLayer
-
>
Manager
(
)
=
=
mManager
"
Wrong
manager
"
)
;
NS_ASSERTION
(
!
ownLayer
-
>
HasUserData
(
&
gLayerManagerUserData
)
"
We
shouldn
'
t
have
a
FrameLayerBuilder
-
managed
layer
here
!
"
)
;
NS_ASSERTION
(
itemClip
.
HasClip
(
)
|
|
itemClip
.
GetRoundedRectCount
(
)
=
=
0
"
If
we
have
rounded
rects
we
must
have
a
clip
rect
"
)
;
ownLayer
-
>
SetClipRect
(
Nothing
(
)
)
;
ownLayer
-
>
SetScrolledClip
(
Nothing
(
)
)
;
ownLayer
-
>
SetAncestorMaskLayers
(
{
}
)
;
if
(
itemClip
.
HasClip
(
)
)
{
ownLayer
-
>
SetClipRect
(
Some
(
clipRect
)
)
;
if
(
itemClip
.
GetRoundedRectCount
(
)
>
0
)
{
SetupMaskLayer
(
ownLayer
itemClip
)
;
}
}
if
(
hasScrolledClip
)
{
const
DisplayItemClip
&
scrolledClip
=
layerClipChain
-
>
mClip
;
LayerClip
scrolledLayerClip
;
scrolledLayerClip
.
SetClipRect
(
ViewAs
<
ParentLayerPixel
>
(
ScaleToNearestPixels
(
scrolledClip
.
GetClipRect
(
)
)
+
mParameters
.
mOffset
)
)
;
if
(
scrolledClip
.
GetRoundedRectCount
(
)
>
0
)
{
scrolledLayerClip
.
SetMaskLayerIndex
(
SetupMaskLayerForScrolledClip
(
ownLayer
.
get
(
)
scrolledClip
)
)
;
}
ownLayer
-
>
SetScrolledClip
(
Some
(
scrolledLayerClip
)
)
;
}
if
(
item
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_MASK
)
{
MOZ_ASSERT
(
itemClip
.
GetRoundedRectCount
(
)
=
=
0
)
;
nsDisplayMask
*
maskItem
=
static_cast
<
nsDisplayMask
*
>
(
item
)
;
SetupMaskLayerForCSSMask
(
ownLayer
maskItem
)
;
if
(
iter
.
PeekNext
(
)
&
&
iter
.
PeekNext
(
)
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_SCROLL_INFO_LAYER
)
{
iter
.
GetNext
(
)
;
}
}
nsIntRegion
itemVisibleRegion
=
itemVisibleRect
;
nsRegion
tightBounds
=
item
-
>
GetTightBounds
(
mBuilder
&
snap
)
;
if
(
!
tightBounds
.
IsEmpty
(
)
)
{
itemVisibleRegion
.
AndWith
(
ScaleToOutsidePixels
(
tightBounds
snap
)
)
;
}
ContainerLayer
*
oldContainer
=
ownLayer
-
>
GetParent
(
)
;
if
(
oldContainer
&
&
oldContainer
!
=
mContainerLayer
)
{
oldContainer
-
>
RemoveChild
(
ownLayer
)
;
}
NS_ASSERTION
(
FindIndexOfLayerIn
(
mNewChildLayers
ownLayer
)
<
0
"
Layer
already
in
list
?
?
?
"
)
;
NewLayerEntry
*
newLayerEntry
=
mNewChildLayers
.
AppendElement
(
)
;
newLayerEntry
-
>
mLayer
=
ownLayer
;
newLayerEntry
-
>
mAnimatedGeometryRoot
=
animatedGeometryRoot
;
newLayerEntry
-
>
mASR
=
itemASR
;
newLayerEntry
-
>
mScrollMetadataASR
=
scrollMetadataASR
;
newLayerEntry
-
>
mClipChain
=
layerClipChain
;
newLayerEntry
-
>
mLayerState
=
layerState
;
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_FIXED_POSITION
)
{
newLayerEntry
-
>
mIsFixedToRootScrollFrame
=
item
-
>
Frame
(
)
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
NS_STYLE_POSITION_FIXED
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
item
-
>
Frame
(
)
)
;
}
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
|
|
layerState
=
=
LAYER_ACTIVE_FORCE
)
{
newLayerEntry
-
>
mPropagateComponentAlphaFlattening
=
false
;
}
float
contentXScale
=
1
.
0f
;
float
contentYScale
=
1
.
0f
;
if
(
ContainerLayer
*
ownContainer
=
ownLayer
-
>
AsContainerLayer
(
)
)
{
contentXScale
=
1
/
ownContainer
-
>
GetPreXScale
(
)
;
contentYScale
=
1
/
ownContainer
-
>
GetPreYScale
(
)
;
}
NS_ASSERTION
(
itemType
!
=
DisplayItemType
:
:
TYPE_TRANSFORM
|
|
layerContentsVisibleRect
.
width
>
=
0
"
Transform
items
must
set
layerContentsVisibleRect
!
"
)
;
if
(
mLayerBuilder
-
>
IsBuildingRetainedLayers
(
)
)
{
newLayerEntry
-
>
mLayerContentsVisibleRect
=
layerContentsVisibleRect
;
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_PERSPECTIVE
|
|
(
itemType
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
(
item
-
>
Frame
(
)
-
>
Extend3DContext
(
)
|
|
item
-
>
Frame
(
)
-
>
Combines3DTransformWithAncestors
(
)
|
|
item
-
>
Frame
(
)
-
>
HasPerspective
(
)
)
)
)
{
newLayerEntry
-
>
mUntransformedVisibleRegion
=
true
;
newLayerEntry
-
>
mVisibleRegion
=
item
-
>
GetBuildingRectForChildren
(
)
.
ScaleToOutsidePixels
(
contentXScale
contentYScale
mAppUnitsPerDevPixel
)
;
}
else
{
newLayerEntry
-
>
mVisibleRegion
=
itemVisibleRegion
;
}
newLayerEntry
-
>
mOpaqueRegion
=
ComputeOpaqueRect
(
item
animatedGeometryRoot
itemASR
itemClip
aList
&
newLayerEntry
-
>
mHideAllLayersBelow
&
newLayerEntry
-
>
mOpaqueForAnimatedGeometryRootParent
)
;
}
else
{
bool
useChildrenVisible
=
itemType
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
(
item
-
>
Frame
(
)
-
>
IsPreserve3DLeaf
(
)
|
|
item
-
>
Frame
(
)
-
>
HasPerspective
(
)
)
;
const
nsIntRegion
&
visible
=
useChildrenVisible
?
item
-
>
GetBuildingRectForChildren
(
)
.
ScaleToOutsidePixels
(
contentXScale
contentYScale
mAppUnitsPerDevPixel
)
:
itemVisibleRegion
;
SetOuterVisibleRegionForLayer
(
ownLayer
visible
layerContentsVisibleRect
.
width
>
=
0
?
&
layerContentsVisibleRect
:
nullptr
useChildrenVisible
)
;
}
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_SCROLL_INFO_LAYER
)
{
nsDisplayScrollInfoLayer
*
scrollItem
=
static_cast
<
nsDisplayScrollInfoLayer
*
>
(
item
)
;
newLayerEntry
-
>
mOpaqueForAnimatedGeometryRootParent
=
false
;
newLayerEntry
-
>
mBaseScrollMetadata
=
scrollItem
-
>
ComputeScrollMetadata
(
ownLayer
-
>
Manager
(
)
mParameters
)
;
}
else
if
(
(
itemType
=
=
DisplayItemType
:
:
TYPE_SUBDOCUMENT
|
|
itemType
=
=
DisplayItemType
:
:
TYPE_ZOOM
|
|
itemType
=
=
DisplayItemType
:
:
TYPE_RESOLUTION
)
&
&
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
)
{
newLayerEntry
-
>
mBaseScrollMetadata
=
static_cast
<
nsDisplaySubDocument
*
>
(
item
)
-
>
ComputeScrollMetadata
(
ownLayer
-
>
Manager
(
)
mParameters
)
;
}
if
(
ownLayer
-
>
Manager
(
)
=
=
mLayerBuilder
-
>
GetRetainingLayerManager
(
)
)
{
oldData
=
mLayerBuilder
-
>
GetOldLayerForFrame
(
item
-
>
Frame
(
)
item
-
>
GetPerFrameKey
(
)
)
;
mLayerBuilder
-
>
StoreDataForFrame
(
item
ownLayer
layerState
oldData
)
;
}
}
else
{
const
bool
backfaceHidden
=
item
-
>
In3DContextAndBackfaceIsHidden
(
)
;
const
nsIFrame
*
referenceFrame
=
item
-
>
ReferenceFrame
(
)
;
PaintedLayerData
*
paintedLayerData
=
selectedLayer
;
if
(
!
paintedLayerData
)
{
paintedLayerData
=
mPaintedLayerDataTree
.
FindPaintedLayerFor
(
animatedGeometryRoot
itemASR
layerClipChain
itemVisibleRect
backfaceHidden
[
&
]
(
PaintedLayerData
*
aData
)
{
NewPaintedLayerData
(
aData
animatedGeometryRoot
itemASR
layerClipChain
scrollMetadataASR
topLeft
referenceFrame
backfaceHidden
)
;
}
)
;
}
MOZ_ASSERT
(
paintedLayerData
)
;
if
(
itemType
=
=
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
)
{
nsDisplayCompositorHitTestInfo
*
hitTestInfo
=
static_cast
<
nsDisplayCompositorHitTestInfo
*
>
(
item
)
;
MOZ_ASSERT
(
!
transformNode
)
;
paintedLayerData
-
>
AccumulateHitTestInfo
(
this
hitTestInfo
nullptr
)
;
}
else
{
paintedLayerData
-
>
Accumulate
(
this
item
itemVisibleRect
itemContent
itemClip
layerState
aList
marker
opacityIndices
transformNode
)
;
if
(
!
paintedLayerData
-
>
mLayer
)
{
RefPtr
<
PaintedLayer
>
layer
=
AttemptToRecyclePaintedLayer
(
animatedGeometryRoot
item
topLeft
referenceFrame
)
;
if
(
layer
)
{
paintedLayerData
-
>
mLayer
=
layer
;
PaintedDisplayItemLayerUserData
*
userData
=
GetPaintedDisplayItemLayerUserData
(
layer
)
;
paintedLayerData
-
>
mAssignedDisplayItems
.
reserve
(
userData
-
>
mLastItemCount
)
;
NS_ASSERTION
(
FindIndexOfLayerIn
(
mNewChildLayers
layer
)
<
0
"
Layer
already
in
list
?
?
?
"
)
;
mNewChildLayers
[
paintedLayerData
-
>
mNewChildLayersIndex
]
.
mLayer
=
layer
.
forget
(
)
;
}
}
}
const
auto
ClearLayerSelectionIfNeeded
=
[
&
]
(
)
{
if
(
!
InOpacity
(
)
&
&
!
InTransform
(
)
)
{
selectedLayer
=
nullptr
;
containerAGR
=
nullptr
;
containerASR
=
nullptr
;
}
}
;
const
auto
SelectLayerIfNeeded
=
[
&
]
(
)
{
if
(
!
selectedLayer
)
{
selectedLayer
=
paintedLayerData
;
containerAGR
=
item
-
>
GetAnimatedGeometryRoot
(
)
;
containerASR
=
item
-
>
GetActiveScrolledRoot
(
)
;
}
}
;
if
(
marker
=
=
DisplayItemEntryType
:
:
PUSH_TRANSFORM
)
{
nsDisplayTransform
*
transform
=
static_cast
<
nsDisplayTransform
*
>
(
item
)
;
const
Matrix4x4Flagged
&
matrix
=
transform
-
>
GetTransformForRendering
(
)
;
Maybe
<
nsRect
>
clip
;
if
(
itemClip
.
HasClip
(
)
)
{
clip
.
emplace
(
itemClip
.
NonRoundedIntersection
(
)
)
;
}
transformNode
=
new
TransformClipNode
(
transformNode
matrix
clip
)
;
}
ProcessDisplayItemMarker
(
marker
ClearLayerSelectionIfNeeded
SelectLayerIfNeeded
)
;
}
nsDisplayList
*
childItems
=
item
-
>
GetSameCoordinateSystemChildren
(
)
;
if
(
childItems
&
&
childItems
-
>
NeedsTransparentSurface
(
)
)
{
aList
-
>
SetNeedsTransparentSurface
(
)
;
}
}
MOZ_ASSERT
(
selectedLayer
=
=
nullptr
)
;
}
void
ContainerState
:
:
InvalidateForLayerChange
(
nsDisplayItem
*
aItem
PaintedLayer
*
aNewLayer
DisplayItemData
*
aData
)
{
NS_ASSERTION
(
aItem
-
>
GetPerFrameKey
(
)
"
Display
items
that
render
using
Thebes
must
have
a
key
"
)
;
Layer
*
oldLayer
=
aData
?
aData
-
>
mLayer
.
get
(
)
:
nullptr
;
if
(
aNewLayer
!
=
oldLayer
&
&
oldLayer
)
{
PaintedLayer
*
t
=
oldLayer
-
>
AsPaintedLayer
(
)
;
if
(
t
&
&
aData
-
>
mGeometry
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Display
item
type
%
s
(
%
p
)
changed
layers
%
p
to
%
p
!
\
n
"
aItem
-
>
Name
(
)
aItem
-
>
Frame
(
)
t
aNewLayer
)
;
}
#
endif
InvalidatePostTransformRegion
(
t
aData
-
>
mGeometry
-
>
ComputeInvalidationRegion
(
)
aData
-
>
mClip
mLayerBuilder
-
>
GetLastPaintOffset
(
t
)
aData
-
>
mTransform
)
;
}
aData
-
>
mGeometry
=
nullptr
;
}
}
void
FrameLayerBuilder
:
:
ComputeGeometryChangeForItem
(
DisplayItemData
*
aData
)
{
nsDisplayItem
*
item
=
aData
-
>
mItem
;
PaintedLayer
*
paintedLayer
=
aData
-
>
mLayer
-
>
AsPaintedLayer
(
)
;
if
(
aData
-
>
mOptLayer
|
|
!
item
|
|
!
paintedLayer
)
{
aData
-
>
EndUpdate
(
)
;
return
;
}
nsAutoPtr
<
nsDisplayItemGeometry
>
geometry
;
if
(
aData
-
>
mReusedItem
&
&
aData
-
>
mGeometry
)
{
aData
-
>
EndUpdate
(
)
;
return
;
}
PaintedDisplayItemLayerUserData
*
layerData
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
aData
-
>
mLayer
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
nsPoint
shift
=
layerData
-
>
mAnimatedGeometryRootOrigin
-
layerData
-
>
mLastAnimatedGeometryRootOrigin
;
if
(
aData
-
>
mTransform
)
{
shift
=
nsPoint
(
)
;
}
const
DisplayItemClip
&
clip
=
item
-
>
GetClip
(
)
;
nsRect
invalid
;
nsRegion
combined
;
if
(
!
aData
-
>
mGeometry
)
{
geometry
=
item
-
>
AllocateGeometry
(
mDisplayListBuilder
)
;
combined
=
clip
.
ApplyNonRoundedIntersection
(
geometry
-
>
ComputeInvalidationRegion
(
)
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Display
item
type
%
s
(
%
p
)
added
to
layer
%
p
!
\
n
"
item
-
>
Name
(
)
item
-
>
Frame
(
)
aData
-
>
mLayer
.
get
(
)
)
;
}
#
endif
}
else
if
(
aData
-
>
mIsInvalid
|
|
(
item
-
>
IsInvalid
(
invalid
)
&
&
invalid
.
IsEmpty
(
)
)
)
{
geometry
=
item
-
>
AllocateGeometry
(
mDisplayListBuilder
)
;
combined
=
aData
-
>
mClip
.
ApplyNonRoundedIntersection
(
aData
-
>
mGeometry
-
>
ComputeInvalidationRegion
(
)
)
;
combined
.
MoveBy
(
shift
)
;
combined
.
Or
(
combined
clip
.
ApplyNonRoundedIntersection
(
geometry
-
>
ComputeInvalidationRegion
(
)
)
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Display
item
type
%
s
(
%
p
)
(
in
layer
%
p
)
belongs
to
an
invalidated
frame
!
\
n
"
item
-
>
Name
(
)
item
-
>
Frame
(
)
aData
-
>
mLayer
.
get
(
)
)
;
}
#
endif
}
else
{
const
nsRegion
&
changedFrameInvalidations
=
aData
-
>
GetChangedFrameInvalidations
(
)
;
aData
-
>
mGeometry
-
>
MoveBy
(
shift
)
;
item
-
>
ComputeInvalidationRegion
(
mDisplayListBuilder
aData
-
>
mGeometry
&
combined
)
;
if
(
!
combined
.
IsEmpty
(
)
|
|
aData
-
>
mLayerState
=
=
LAYER_INACTIVE
|
|
item
-
>
NeedsGeometryUpdates
(
)
)
{
geometry
=
item
-
>
AllocateGeometry
(
mDisplayListBuilder
)
;
}
aData
-
>
mClip
.
AddOffsetAndComputeDifference
(
shift
aData
-
>
mGeometry
-
>
ComputeInvalidationRegion
(
)
clip
geometry
?
geometry
-
>
ComputeInvalidationRegion
(
)
:
aData
-
>
mGeometry
-
>
ComputeInvalidationRegion
(
)
&
combined
)
;
combined
.
Or
(
combined
invalid
)
;
combined
.
Or
(
combined
changedFrameInvalidations
)
;
nsRegion
clipRegion
;
if
(
clip
.
ComputeRegionInClips
(
&
aData
-
>
mClip
shift
&
clipRegion
)
)
{
combined
.
And
(
combined
clipRegion
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
if
(
!
combined
.
IsEmpty
(
)
)
{
printf_stderr
(
"
Display
item
type
%
s
(
%
p
)
(
in
layer
%
p
)
changed
geometry
!
\
n
"
item
-
>
Name
(
)
item
-
>
Frame
(
)
aData
-
>
mLayer
.
get
(
)
)
;
}
}
#
endif
}
if
(
!
combined
.
IsEmpty
(
)
)
{
InvalidatePostTransformRegion
(
paintedLayer
combined
.
ScaleToOutsidePixels
(
layerData
-
>
mXScale
layerData
-
>
mYScale
layerData
-
>
mAppUnitsPerDevPixel
)
layerData
-
>
mTranslation
aData
-
>
mTransform
)
;
}
aData
-
>
EndUpdate
(
geometry
)
;
}
void
FrameLayerBuilder
:
:
AddPaintedDisplayItem
(
PaintedLayerData
*
aLayerData
AssignedDisplayItem
&
aItem
ContainerState
&
aContainerState
Layer
*
aLayer
)
{
PaintedLayer
*
layer
=
aLayerData
-
>
mLayer
;
PaintedDisplayItemLayerUserData
*
paintedData
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
layer
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
RefPtr
<
BasicLayerManager
>
tempManager
;
nsIntRect
intClip
;
bool
hasClip
=
false
;
if
(
aItem
.
mLayerState
!
=
LAYER_NONE
)
{
if
(
aItem
.
mDisplayItemData
)
{
tempManager
=
aItem
.
mDisplayItemData
-
>
mInactiveManager
;
nsRegion
clip
;
if
(
aItem
.
mItem
-
>
GetClip
(
)
.
ComputeRegionInClips
(
&
aItem
.
mDisplayItemData
-
>
GetClip
(
)
aLayerData
-
>
mAnimatedGeometryRootOffset
-
paintedData
-
>
mLastAnimatedGeometryRootOrigin
&
clip
)
)
{
intClip
=
clip
.
GetBounds
(
)
.
ScaleToOutsidePixels
(
paintedData
-
>
mXScale
paintedData
-
>
mYScale
paintedData
-
>
mAppUnitsPerDevPixel
)
;
}
}
if
(
!
tempManager
)
{
tempManager
=
new
BasicLayerManager
(
BasicLayerManager
:
:
BLM_INACTIVE
)
;
}
}
if
(
layer
-
>
Manager
(
)
=
=
mRetainingManager
)
{
DisplayItemData
*
data
=
aItem
.
mDisplayItemData
;
if
(
data
&
&
!
data
-
>
mUsed
)
{
data
-
>
BeginUpdate
(
layer
aItem
.
mLayerState
aItem
.
mItem
aItem
.
mReused
aItem
.
mMerged
)
;
}
else
{
if
(
data
&
&
data
-
>
mUsed
)
{
aItem
.
mItem
-
>
SetDisplayItemData
(
nullptr
nullptr
)
;
}
data
=
StoreDataForFrame
(
aItem
.
mItem
layer
aItem
.
mLayerState
nullptr
)
;
}
data
-
>
mInactiveManager
=
tempManager
;
if
(
aLayer
!
=
layer
)
{
data
-
>
mOptLayer
=
aLayer
;
}
data
-
>
mTransform
=
aItem
.
mTransform
;
}
if
(
tempManager
)
{
FLB_LOG_PAINTED_LAYER_DECISION
(
aLayerData
"
Creating
nested
FLB
for
item
%
p
\
n
"
aItem
.
mItem
)
;
FrameLayerBuilder
*
layerBuilder
=
new
FrameLayerBuilder
(
)
;
layerBuilder
-
>
Init
(
mDisplayListBuilder
tempManager
aLayerData
true
&
aItem
.
mItem
-
>
GetClip
(
)
)
;
tempManager
-
>
BeginTransaction
(
)
;
if
(
mRetainingManager
)
{
layerBuilder
-
>
DidBeginRetainedLayerTransaction
(
tempManager
)
;
}
UniquePtr
<
LayerProperties
>
props
(
LayerProperties
:
:
CloneFrom
(
tempManager
-
>
GetRoot
(
)
)
)
;
RefPtr
<
Layer
>
tmpLayer
=
aItem
.
mItem
-
>
BuildLayer
(
mDisplayListBuilder
tempManager
ContainerLayerParameters
(
)
)
;
if
(
!
tmpLayer
)
{
tempManager
-
>
EndTransaction
(
nullptr
nullptr
)
;
tempManager
-
>
SetUserData
(
&
gLayerManagerLayerBuilder
nullptr
)
;
aItem
.
mItem
=
nullptr
;
return
;
}
bool
snap
;
nsRect
visibleRect
=
aItem
.
mItem
-
>
GetBuildingRect
(
)
.
Intersect
(
aItem
.
mItem
-
>
GetBounds
(
mDisplayListBuilder
&
snap
)
)
;
nsIntRegion
rgn
=
visibleRect
.
ToOutsidePixels
(
paintedData
-
>
mAppUnitsPerDevPixel
)
;
nsRegion
tightBounds
=
aItem
.
mItem
-
>
GetTightBounds
(
mDisplayListBuilder
&
snap
)
;
if
(
!
tightBounds
.
IsEmpty
(
)
)
{
rgn
.
AndWith
(
tightBounds
.
ToOutsidePixels
(
paintedData
-
>
mAppUnitsPerDevPixel
)
)
;
}
SetOuterVisibleRegion
(
tmpLayer
&
rgn
)
;
DisplayItemData
*
data
=
nullptr
;
if
(
mRetainingManager
)
{
#
ifdef
DEBUG_DISPLAY_ITEM_DATA
LayerManagerData
*
parentLmd
=
static_cast
<
LayerManagerData
*
>
(
layer
-
>
Manager
(
)
-
>
GetUserData
(
&
gLayerManagerUserData
)
)
;
LayerManagerData
*
lmd
=
static_cast
<
LayerManagerData
*
>
(
tempManager
-
>
GetUserData
(
&
gLayerManagerUserData
)
)
;
lmd
-
>
mParent
=
parentLmd
;
#
endif
data
=
layerBuilder
-
>
GetDisplayItemDataForManager
(
aItem
.
mItem
tempManager
)
;
data
=
layerBuilder
-
>
StoreDataForFrame
(
aItem
.
mItem
tmpLayer
LAYER_ACTIVE
data
)
;
data
-
>
mTransform
=
aItem
.
mTransform
;
}
tempManager
-
>
SetRoot
(
tmpLayer
)
;
layerBuilder
-
>
WillEndTransaction
(
)
;
tempManager
-
>
AbortTransaction
(
)
;
if
(
gfxUtils
:
:
DumpDisplayList
(
)
|
|
gfxEnv
:
:
DumpPaint
(
)
)
{
fprintf_stderr
(
gfxUtils
:
:
sDumpPaintFile
"
Basic
layer
tree
for
painting
contents
of
display
item
%
s
(
%
p
)
:
\
n
"
aItem
.
mItem
-
>
Name
(
)
aItem
.
mItem
-
>
Frame
(
)
)
;
std
:
:
stringstream
stream
;
tempManager
-
>
Dump
(
stream
"
"
gfxEnv
:
:
DumpPaintToFile
(
)
)
;
fprint_stderr
(
gfxUtils
:
:
sDumpPaintFile
stream
)
;
}
nsIntPoint
offset
=
GetLastPaintOffset
(
layer
)
-
GetTranslationForPaintedLayer
(
layer
)
;
props
-
>
MoveBy
(
-
offset
)
;
tmpLayer
-
>
ComputeEffectiveTransforms
(
Matrix4x4
(
)
)
;
nsIntRegion
invalid
;
if
(
!
props
-
>
ComputeDifferences
(
tmpLayer
invalid
nullptr
)
)
{
nsRect
visible
=
aItem
.
mItem
-
>
Frame
(
)
-
>
GetVisualOverflowRect
(
)
;
invalid
=
visible
.
ToOutsidePixels
(
paintedData
-
>
mAppUnitsPerDevPixel
)
;
}
if
(
aItem
.
mLayerState
=
=
LAYER_SVG_EFFECTS
)
{
invalid
=
nsSVGIntegrationUtils
:
:
AdjustInvalidAreaForSVGEffects
(
aItem
.
mItem
-
>
Frame
(
)
aItem
.
mItem
-
>
ToReferenceFrame
(
)
invalid
)
;
}
if
(
!
invalid
.
IsEmpty
(
)
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Inactive
LayerManager
(
%
p
)
for
display
item
%
s
(
%
p
)
has
an
invalid
region
-
invalidating
layer
%
p
\
n
"
tempManager
.
get
(
)
aItem
.
mItem
-
>
Name
(
)
aItem
.
mItem
-
>
Frame
(
)
layer
)
;
}
#
endif
invalid
.
ScaleRoundOut
(
paintedData
-
>
mXScale
paintedData
-
>
mYScale
)
;
if
(
hasClip
)
{
invalid
.
And
(
invalid
intClip
)
;
}
InvalidatePostTransformRegion
(
layer
invalid
GetTranslationForPaintedLayer
(
layer
)
data
?
data
-
>
mTransform
.
get
(
)
:
nullptr
)
;
}
}
aItem
.
mInactiveLayerManager
=
tempManager
;
}
DisplayItemData
*
FrameLayerBuilder
:
:
StoreDataForFrame
(
nsDisplayItem
*
aItem
Layer
*
aLayer
LayerState
aState
DisplayItemData
*
aData
)
{
if
(
aData
)
{
if
(
!
aData
-
>
mUsed
)
{
aData
-
>
BeginUpdate
(
aLayer
aState
false
aItem
)
;
}
return
aData
;
}
LayerManagerData
*
lmd
=
static_cast
<
LayerManagerData
*
>
(
mRetainingManager
-
>
GetUserData
(
&
gLayerManagerUserData
)
)
;
RefPtr
<
DisplayItemData
>
data
=
new
(
aItem
-
>
Frame
(
)
-
>
PresContext
(
)
)
DisplayItemData
(
lmd
aItem
-
>
GetPerFrameKey
(
)
aLayer
)
;
data
-
>
BeginUpdate
(
aLayer
aState
true
aItem
)
;
lmd
-
>
mDisplayItems
.
push_back
(
data
)
;
return
data
;
}
void
FrameLayerBuilder
:
:
StoreDataForFrame
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
Layer
*
aLayer
LayerState
aState
)
{
DisplayItemData
*
oldData
=
GetDisplayItemData
(
aFrame
aDisplayItemKey
)
;
if
(
oldData
&
&
oldData
-
>
mFrameList
.
Length
(
)
=
=
1
)
{
oldData
-
>
BeginUpdate
(
aLayer
aState
false
)
;
return
;
}
LayerManagerData
*
lmd
=
static_cast
<
LayerManagerData
*
>
(
mRetainingManager
-
>
GetUserData
(
&
gLayerManagerUserData
)
)
;
RefPtr
<
DisplayItemData
>
data
=
new
(
aFrame
-
>
PresContext
(
)
)
DisplayItemData
(
lmd
aDisplayItemKey
aLayer
aFrame
)
;
data
-
>
BeginUpdate
(
aLayer
aState
true
)
;
lmd
-
>
mDisplayItems
.
push_back
(
data
)
;
}
AssignedDisplayItem
:
:
AssignedDisplayItem
(
nsDisplayItem
*
aItem
LayerState
aLayerState
DisplayItemData
*
aData
const
nsRect
&
aContentRect
DisplayItemEntryType
aType
const
bool
aHasOpacity
const
RefPtr
<
TransformClipNode
>
&
aTransform
)
:
mItem
(
aItem
)
mLayerState
(
aLayerState
)
mDisplayItemData
(
aData
)
mContentRect
(
aContentRect
)
mTransform
(
aTransform
)
mType
(
aType
)
mReused
(
aItem
-
>
IsReused
(
)
)
mMerged
(
aItem
-
>
HasMergedFrames
(
)
)
mHasOpacity
(
aHasOpacity
)
mHasTransform
(
aTransform
)
mHasPaintRect
(
aItem
-
>
HasPaintRect
(
)
)
{
}
AssignedDisplayItem
:
:
~
AssignedDisplayItem
(
)
{
if
(
mInactiveLayerManager
)
{
mInactiveLayerManager
-
>
SetUserData
(
&
gLayerManagerLayerBuilder
nullptr
)
;
}
}
nsIntPoint
FrameLayerBuilder
:
:
GetLastPaintOffset
(
PaintedLayer
*
aLayer
)
{
PaintedDisplayItemLayerUserData
*
layerData
=
GetPaintedDisplayItemLayerUserData
(
aLayer
)
;
MOZ_ASSERT
(
layerData
)
;
if
(
layerData
-
>
mHasExplicitLastPaintOffset
)
{
return
layerData
-
>
mLastPaintOffset
;
}
return
GetTranslationForPaintedLayer
(
aLayer
)
;
}
bool
FrameLayerBuilder
:
:
CheckInLayerTreeCompressionMode
(
)
{
if
(
mInLayerTreeCompressionMode
)
{
return
true
;
}
mRootPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
-
>
SchedulePaint
(
nsIFrame
:
:
PAINT_DELAYED_COMPRESS
false
)
;
return
false
;
}
void
ContainerState
:
:
CollectOldLayers
(
)
{
for
(
Layer
*
layer
=
mContainerLayer
-
>
GetFirstChild
(
)
;
layer
;
layer
=
layer
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
!
layer
-
>
HasUserData
(
&
gMaskLayerUserData
)
"
Mask
layers
should
not
be
part
of
the
layer
tree
.
"
)
;
if
(
layer
-
>
HasUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
{
NS_ASSERTION
(
layer
-
>
AsPaintedLayer
(
)
"
Wrong
layer
type
"
)
;
mPaintedLayersAvailableForRecycling
.
PutEntry
(
static_cast
<
PaintedLayer
*
>
(
layer
)
)
;
}
if
(
Layer
*
maskLayer
=
layer
-
>
GetMaskLayer
(
)
)
{
NS_ASSERTION
(
maskLayer
-
>
GetType
(
)
=
=
Layer
:
:
TYPE_IMAGE
"
Could
not
recycle
mask
layer
unsupported
layer
type
.
"
)
;
mRecycledMaskImageLayers
.
Put
(
MaskLayerKey
(
layer
Nothing
(
)
)
static_cast
<
ImageLayer
*
>
(
maskLayer
)
)
;
}
for
(
size_t
i
=
0
;
i
<
layer
-
>
GetAncestorMaskLayerCount
(
)
;
i
+
+
)
{
Layer
*
maskLayer
=
layer
-
>
GetAncestorMaskLayerAt
(
i
)
;
NS_ASSERTION
(
maskLayer
-
>
GetType
(
)
=
=
Layer
:
:
TYPE_IMAGE
"
Could
not
recycle
mask
layer
unsupported
layer
type
.
"
)
;
mRecycledMaskImageLayers
.
Put
(
MaskLayerKey
(
layer
Some
(
i
)
)
static_cast
<
ImageLayer
*
>
(
maskLayer
)
)
;
}
}
}
struct
OpaqueRegionEntry
{
AnimatedGeometryRoot
*
mAnimatedGeometryRoot
;
const
ActiveScrolledRoot
*
mASR
;
nsIntRegion
mOpaqueRegion
;
}
;
static
OpaqueRegionEntry
*
FindOpaqueRegionEntry
(
nsTArray
<
OpaqueRegionEntry
>
&
aEntries
AnimatedGeometryRoot
*
aAnimatedGeometryRoot
const
ActiveScrolledRoot
*
aASR
)
{
for
(
uint32_t
i
=
0
;
i
<
aEntries
.
Length
(
)
;
+
+
i
)
{
OpaqueRegionEntry
*
d
=
&
aEntries
[
i
]
;
if
(
d
-
>
mAnimatedGeometryRoot
=
=
aAnimatedGeometryRoot
&
&
d
-
>
mASR
=
=
aASR
)
{
return
d
;
}
}
return
nullptr
;
}
static
const
ActiveScrolledRoot
*
FindDirectChildASR
(
const
ActiveScrolledRoot
*
aParent
const
ActiveScrolledRoot
*
aDescendant
)
{
MOZ_ASSERT
(
aDescendant
"
can
'
t
start
at
the
root
when
looking
for
a
child
"
)
;
MOZ_ASSERT
(
ActiveScrolledRoot
:
:
IsAncestor
(
aParent
aDescendant
)
)
;
const
ActiveScrolledRoot
*
directChild
=
aDescendant
;
while
(
directChild
-
>
mParent
!
=
aParent
)
{
directChild
=
directChild
-
>
mParent
;
MOZ_RELEASE_ASSERT
(
directChild
"
this
must
not
be
null
"
)
;
}
return
directChild
;
}
static
void
FixUpFixedPositionLayer
(
Layer
*
aLayer
const
ActiveScrolledRoot
*
aTargetASR
const
ActiveScrolledRoot
*
aLeafScrollMetadataASR
const
ActiveScrolledRoot
*
aContainerScrollMetadataASR
const
ActiveScrolledRoot
*
aContainerCompositorASR
bool
aIsFixedToRootScrollFrame
)
{
if
(
!
aLayer
-
>
GetIsFixedPosition
(
)
)
{
return
;
}
const
ActiveScrolledRoot
*
compositorASR
=
aLeafScrollMetadataASR
=
=
aContainerScrollMetadataASR
?
aContainerCompositorASR
:
aLeafScrollMetadataASR
;
if
(
compositorASR
&
&
aTargetASR
!
=
compositorASR
)
{
aLayer
-
>
SetFixedPositionData
(
FindDirectChildASR
(
aTargetASR
compositorASR
)
-
>
GetViewId
(
)
aLayer
-
>
GetFixedPositionAnchor
(
)
aLayer
-
>
GetFixedPositionSides
(
)
)
;
}
else
{
aLayer
-
>
SetIsFixedPosition
(
aIsFixedToRootScrollFrame
)
;
}
}
void
ContainerState
:
:
SetupScrollingMetadata
(
NewLayerEntry
*
aEntry
)
{
if
(
!
mBuilder
-
>
IsPaintingToWindow
(
)
)
{
return
;
}
const
ActiveScrolledRoot
*
startASR
=
aEntry
-
>
mScrollMetadataASR
;
const
ActiveScrolledRoot
*
stopASR
=
mContainerScrollMetadataASR
;
if
(
!
ActiveScrolledRoot
:
:
IsAncestor
(
stopASR
startASR
)
)
{
if
(
ActiveScrolledRoot
:
:
IsAncestor
(
startASR
stopASR
)
)
{
startASR
=
stopASR
;
}
else
{
do
{
stopASR
=
stopASR
-
>
mParent
;
}
while
(
!
ActiveScrolledRoot
:
:
IsAncestor
(
stopASR
startASR
)
)
;
}
}
FixUpFixedPositionLayer
(
aEntry
-
>
mLayer
aEntry
-
>
mASR
startASR
mContainerScrollMetadataASR
mContainerCompositorASR
aEntry
-
>
mIsFixedToRootScrollFrame
)
;
AutoTArray
<
ScrollMetadata
2
>
metricsArray
;
if
(
aEntry
-
>
mBaseScrollMetadata
)
{
metricsArray
.
AppendElement
(
*
aEntry
-
>
mBaseScrollMetadata
)
;
MOZ_ASSERT
(
!
aEntry
-
>
mBaseScrollMetadata
-
>
HasMaskLayer
(
)
)
;
}
nsTArray
<
RefPtr
<
Layer
>
>
maskLayers
(
aEntry
-
>
mLayer
-
>
GetAllAncestorMaskLayers
(
)
)
;
const
DisplayItemClipChain
*
clipChain
=
aEntry
-
>
mClipChain
;
for
(
const
ActiveScrolledRoot
*
asr
=
startASR
;
asr
!
=
stopASR
;
asr
=
asr
-
>
mParent
)
{
if
(
!
asr
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
have
encountered
stopASR
on
the
way
up
.
"
)
;
break
;
}
if
(
clipChain
&
&
clipChain
-
>
mASR
=
=
asr
)
{
clipChain
=
clipChain
-
>
mParent
;
}
nsIScrollableFrame
*
scrollFrame
=
asr
-
>
mScrollableFrame
;
const
DisplayItemClip
*
clip
=
(
clipChain
&
&
clipChain
-
>
mASR
=
=
asr
-
>
mParent
)
?
&
clipChain
-
>
mClip
:
nullptr
;
scrollFrame
-
>
ClipLayerToDisplayPort
(
aEntry
-
>
mLayer
clip
mParameters
)
;
Maybe
<
ScrollMetadata
>
metadata
;
if
(
mCachedScrollMetadata
.
mASR
=
=
asr
&
&
mCachedScrollMetadata
.
mClip
=
=
clip
)
{
metadata
=
mCachedScrollMetadata
.
mMetadata
;
}
else
{
metadata
=
scrollFrame
-
>
ComputeScrollMetadata
(
aEntry
-
>
mLayer
-
>
Manager
(
)
mContainerReferenceFrame
mParameters
clip
)
;
mCachedScrollMetadata
.
mASR
=
asr
;
mCachedScrollMetadata
.
mClip
=
clip
;
mCachedScrollMetadata
.
mMetadata
=
metadata
;
}
if
(
!
metadata
)
{
continue
;
}
if
(
clip
&
&
clip
-
>
HasClip
(
)
&
&
clip
-
>
GetRoundedRectCount
(
)
>
0
)
{
Maybe
<
size_t
>
nextIndex
=
Some
(
maskLayers
.
Length
(
)
)
;
RefPtr
<
Layer
>
maskLayer
=
CreateMaskLayer
(
aEntry
-
>
mLayer
*
clip
nextIndex
)
;
if
(
maskLayer
)
{
MOZ_ASSERT
(
metadata
-
>
HasScrollClip
(
)
)
;
metadata
-
>
ScrollClip
(
)
.
SetMaskLayerIndex
(
nextIndex
)
;
maskLayers
.
AppendElement
(
maskLayer
)
;
}
}
metricsArray
.
AppendElement
(
*
metadata
)
;
}
aEntry
-
>
mLayer
-
>
SetScrollMetadata
(
metricsArray
)
;
aEntry
-
>
mLayer
-
>
SetAncestorMaskLayers
(
maskLayers
)
;
}
static
inline
Maybe
<
ParentLayerIntRect
>
GetStationaryClipInContainer
(
Layer
*
aLayer
)
{
if
(
size_t
metricsCount
=
aLayer
-
>
GetScrollMetadataCount
(
)
)
{
return
aLayer
-
>
GetScrollMetadata
(
metricsCount
-
1
)
.
GetClipRect
(
)
;
}
return
aLayer
-
>
GetClipRect
(
)
;
}
void
ContainerState
:
:
PostprocessRetainedLayers
(
nsIntRegion
*
aOpaqueRegionForContainer
)
{
AutoTArray
<
OpaqueRegionEntry
4
>
opaqueRegions
;
bool
hideAll
=
false
;
int32_t
opaqueRegionForContainer
=
-
1
;
for
(
int32_t
i
=
mNewChildLayers
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
NewLayerEntry
*
e
=
&
mNewChildLayers
.
ElementAt
(
i
)
;
if
(
!
e
-
>
mLayer
)
{
continue
;
}
OpaqueRegionEntry
*
data
=
FindOpaqueRegionEntry
(
opaqueRegions
e
-
>
mAnimatedGeometryRoot
e
-
>
mASR
)
;
SetupScrollingMetadata
(
e
)
;
if
(
hideAll
)
{
e
-
>
mVisibleRegion
.
SetEmpty
(
)
;
}
else
if
(
!
e
-
>
mLayer
-
>
IsScrollbarContainer
(
)
)
{
Maybe
<
ParentLayerIntRect
>
clipRect
=
GetStationaryClipInContainer
(
e
-
>
mLayer
)
;
if
(
clipRect
&
&
opaqueRegionForContainer
>
=
0
&
&
opaqueRegions
[
opaqueRegionForContainer
]
.
mOpaqueRegion
.
Contains
(
clipRect
-
>
ToUnknownRect
(
)
)
)
{
e
-
>
mVisibleRegion
.
SetEmpty
(
)
;
}
else
if
(
data
)
{
e
-
>
mVisibleRegion
.
Sub
(
e
-
>
mVisibleRegion
data
-
>
mOpaqueRegion
)
;
}
}
SetOuterVisibleRegionForLayer
(
e
-
>
mLayer
e
-
>
mVisibleRegion
e
-
>
mLayerContentsVisibleRect
.
width
>
=
0
?
&
e
-
>
mLayerContentsVisibleRect
:
nullptr
e
-
>
mUntransformedVisibleRegion
)
;
if
(
!
e
-
>
mOpaqueRegion
.
IsEmpty
(
)
)
{
AnimatedGeometryRoot
*
animatedGeometryRootToCover
=
e
-
>
mAnimatedGeometryRoot
;
const
ActiveScrolledRoot
*
asrToCover
=
e
-
>
mASR
;
if
(
e
-
>
mOpaqueForAnimatedGeometryRootParent
&
&
e
-
>
mAnimatedGeometryRoot
-
>
mParentAGR
=
=
mContainerAnimatedGeometryRoot
)
{
animatedGeometryRootToCover
=
mContainerAnimatedGeometryRoot
;
asrToCover
=
mContainerASR
;
data
=
FindOpaqueRegionEntry
(
opaqueRegions
animatedGeometryRootToCover
asrToCover
)
;
}
if
(
!
data
)
{
if
(
animatedGeometryRootToCover
=
=
mContainerAnimatedGeometryRoot
&
&
asrToCover
=
=
mContainerASR
)
{
NS_ASSERTION
(
opaqueRegionForContainer
=
=
-
1
"
Already
found
it
?
"
)
;
opaqueRegionForContainer
=
opaqueRegions
.
Length
(
)
;
}
data
=
opaqueRegions
.
AppendElement
(
)
;
data
-
>
mAnimatedGeometryRoot
=
animatedGeometryRootToCover
;
data
-
>
mASR
=
asrToCover
;
}
nsIntRegion
clippedOpaque
=
e
-
>
mOpaqueRegion
;
Maybe
<
ParentLayerIntRect
>
clipRect
=
e
-
>
mLayer
-
>
GetCombinedClipRect
(
)
;
if
(
clipRect
)
{
clippedOpaque
.
AndWith
(
clipRect
-
>
ToUnknownRect
(
)
)
;
}
if
(
e
-
>
mLayer
-
>
GetScrolledClip
(
)
)
{
clippedOpaque
.
SetEmpty
(
)
;
}
else
if
(
e
-
>
mHideAllLayersBelow
)
{
hideAll
=
true
;
}
data
-
>
mOpaqueRegion
.
Or
(
data
-
>
mOpaqueRegion
clippedOpaque
)
;
}
if
(
e
-
>
mLayer
-
>
GetType
(
)
=
=
Layer
:
:
TYPE_READBACK
)
{
opaqueRegions
.
Clear
(
)
;
opaqueRegionForContainer
=
-
1
;
}
}
if
(
opaqueRegionForContainer
>
=
0
)
{
aOpaqueRegionForContainer
-
>
Or
(
*
aOpaqueRegionForContainer
opaqueRegions
[
opaqueRegionForContainer
]
.
mOpaqueRegion
)
;
}
}
void
ContainerState
:
:
Finish
(
uint32_t
*
aTextContentFlags
const
nsIntRect
&
aContainerPixelBounds
nsDisplayList
*
aChildItems
)
{
mPaintedLayerDataTree
.
Finish
(
)
;
if
(
!
mParameters
.
mForEventsAndPluginsOnly
&
&
!
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
)
{
NS_ASSERTION
(
mContainerBounds
.
IsEqualInterior
(
mAccumulatedChildBounds
)
"
Bounds
computation
mismatch
"
)
;
}
if
(
mLayerBuilder
-
>
IsBuildingRetainedLayers
(
)
)
{
nsIntRegion
containerOpaqueRegion
;
PostprocessRetainedLayers
(
&
containerOpaqueRegion
)
;
if
(
containerOpaqueRegion
.
Contains
(
aContainerPixelBounds
)
)
{
aChildItems
-
>
SetIsOpaque
(
)
;
}
}
uint32_t
textContentFlags
=
0
;
Layer
*
layer
=
nullptr
;
Layer
*
prevChild
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mNewChildLayers
.
Length
(
)
;
+
+
i
prevChild
=
layer
)
{
if
(
!
mNewChildLayers
[
i
]
.
mLayer
)
{
continue
;
}
layer
=
mNewChildLayers
[
i
]
.
mLayer
;
if
(
!
layer
-
>
GetVisibleRegion
(
)
.
IsEmpty
(
)
)
{
textContentFlags
|
=
layer
-
>
GetContentFlags
(
)
&
(
Layer
:
:
CONTENT_COMPONENT_ALPHA
|
Layer
:
:
CONTENT_COMPONENT_ALPHA_DESCENDANT
|
Layer
:
:
CONTENT_DISABLE_FLATTENING
)
;
}
if
(
!
layer
-
>
GetParent
(
)
)
{
mContainerLayer
-
>
InsertAfter
(
layer
prevChild
)
;
}
else
{
NS_ASSERTION
(
layer
-
>
GetParent
(
)
=
=
mContainerLayer
"
Layer
shouldn
'
t
be
the
child
of
some
other
container
"
)
;
if
(
layer
-
>
GetPrevSibling
(
)
!
=
prevChild
)
{
mContainerLayer
-
>
RepositionChild
(
layer
prevChild
)
;
}
}
}
if
(
!
layer
)
{
layer
=
mContainerLayer
-
>
GetFirstChild
(
)
;
}
else
{
layer
=
layer
-
>
GetNextSibling
(
)
;
}
while
(
layer
)
{
Layer
*
layerToRemove
=
layer
;
layer
=
layer
-
>
GetNextSibling
(
)
;
mContainerLayer
-
>
RemoveChild
(
layerToRemove
)
;
}
*
aTextContentFlags
=
textContentFlags
;
}
static
void
RestrictScaleToMaxLayerSize
(
Size
&
aScale
const
nsRect
&
aVisibleRect
nsIFrame
*
aContainerFrame
Layer
*
aContainerLayer
)
{
if
(
!
aContainerLayer
-
>
Manager
(
)
-
>
IsWidgetLayerManager
(
)
)
{
return
;
}
nsIntRect
pixelSize
=
aVisibleRect
.
ScaleToOutsidePixels
(
aScale
.
width
aScale
.
height
aContainerFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
int32_t
maxLayerSize
=
aContainerLayer
-
>
GetMaxLayerSize
(
)
;
if
(
pixelSize
.
width
>
maxLayerSize
)
{
float
scale
=
(
float
)
pixelSize
.
width
/
maxLayerSize
;
scale
=
gfxUtils
:
:
ClampToScaleFactor
(
scale
)
;
aScale
.
width
/
=
scale
;
}
if
(
pixelSize
.
height
>
maxLayerSize
)
{
float
scale
=
(
float
)
pixelSize
.
height
/
maxLayerSize
;
scale
=
gfxUtils
:
:
ClampToScaleFactor
(
scale
)
;
aScale
.
height
/
=
scale
;
}
}
static
nsSize
ComputeDesiredDisplaySizeForAnimation
(
nsIFrame
*
aContainerFrame
)
{
nsPresContext
*
presContext
=
aContainerFrame
-
>
PresContext
(
)
;
nsIWidget
*
widget
=
aContainerFrame
-
>
GetNearestWidget
(
)
;
if
(
widget
)
{
return
LayoutDevicePixel
:
:
ToAppUnits
(
widget
-
>
GetClientSize
(
)
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
}
else
{
return
presContext
-
>
GetVisibleArea
(
)
.
Size
(
)
;
}
}
static
bool
ChooseScaleAndSetTransform
(
FrameLayerBuilder
*
aLayerBuilder
nsDisplayListBuilder
*
aDisplayListBuilder
nsIFrame
*
aContainerFrame
nsDisplayItem
*
aContainerItem
const
nsRect
&
aVisibleRect
const
Matrix4x4
*
aTransform
const
ContainerLayerParameters
&
aIncomingScale
ContainerLayer
*
aLayer
ContainerLayerParameters
&
aOutgoingScale
)
{
nsIntPoint
offset
;
Matrix4x4
transform
=
Matrix4x4
:
:
Scaling
(
aIncomingScale
.
mXScale
aIncomingScale
.
mYScale
1
.
0
)
;
if
(
aTransform
)
{
transform
=
(
*
aTransform
)
*
transform
;
transform
.
NudgeToIntegersFixedEpsilon
(
)
;
}
Matrix
transform2d
;
if
(
aContainerFrame
&
&
aLayerBuilder
-
>
GetContainingPaintedLayerData
(
)
&
&
(
!
aTransform
|
|
(
aTransform
-
>
Is2D
(
&
transform2d
)
&
&
!
transform2d
.
HasNonTranslation
(
)
)
)
)
{
nsPoint
appUnitOffset
=
aDisplayListBuilder
-
>
ToReferenceFrame
(
aContainerFrame
)
;
nscoord
appUnitsPerDevPixel
=
aContainerFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
offset
=
nsIntPoint
(
NS_lround
(
NSAppUnitsToDoublePixels
(
appUnitOffset
.
x
appUnitsPerDevPixel
)
*
aIncomingScale
.
mXScale
)
NS_lround
(
NSAppUnitsToDoublePixels
(
appUnitOffset
.
y
appUnitsPerDevPixel
)
*
aIncomingScale
.
mYScale
)
)
;
}
transform
.
PostTranslate
(
offset
.
x
+
aIncomingScale
.
mOffset
.
x
offset
.
y
+
aIncomingScale
.
mOffset
.
y
0
)
;
if
(
transform
.
IsSingular
(
)
)
{
return
false
;
}
bool
canDraw2D
=
transform
.
CanDraw2D
(
&
transform2d
)
;
Size
scale
;
if
(
canDraw2D
&
&
!
aContainerFrame
-
>
Combines3DTransformWithAncestors
(
)
&
&
!
aContainerFrame
-
>
HasPerspective
(
)
)
{
if
(
aContainerItem
&
&
aContainerItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
EffectCompositor
:
:
HasAnimationsForCompositor
(
aContainerFrame
eCSSProperty_transform
)
)
{
nsSize
displaySize
=
ComputeDesiredDisplaySizeForAnimation
(
aContainerFrame
)
;
nsSize
scaledVisibleSize
=
nsSize
(
aVisibleRect
.
Width
(
)
*
aIncomingScale
.
mXScale
aVisibleRect
.
Height
(
)
*
aIncomingScale
.
mYScale
)
;
scale
=
nsLayoutUtils
:
:
ComputeSuitableScaleForAnimation
(
aContainerFrame
scaledVisibleSize
displaySize
)
;
float
incomingScale
=
std
:
:
max
(
aIncomingScale
.
mXScale
aIncomingScale
.
mYScale
)
;
scale
.
width
*
=
incomingScale
;
scale
.
height
*
=
incomingScale
;
}
else
{
scale
=
transform2d
.
ScaleFactors
(
true
)
;
Matrix
frameTransform
;
if
(
ActiveLayerTracker
:
:
IsScaleSubjectToAnimation
(
aContainerFrame
)
)
{
scale
.
width
=
gfxUtils
:
:
ClampToScaleFactor
(
scale
.
width
)
;
scale
.
height
=
gfxUtils
:
:
ClampToScaleFactor
(
scale
.
height
)
;
nsSize
maxScale
(
4
4
)
;
if
(
!
aVisibleRect
.
IsEmpty
(
)
)
{
nsSize
displaySize
=
ComputeDesiredDisplaySizeForAnimation
(
aContainerFrame
)
;
maxScale
=
Max
(
maxScale
displaySize
/
aVisibleRect
.
Size
(
)
)
;
}
if
(
scale
.
width
>
maxScale
.
width
)
{
scale
.
width
=
gfxUtils
:
:
ClampToScaleFactor
(
maxScale
.
width
true
)
;
}
if
(
scale
.
height
>
maxScale
.
height
)
{
scale
.
height
=
gfxUtils
:
:
ClampToScaleFactor
(
maxScale
.
height
true
)
;
}
}
else
{
}
}
if
(
fabs
(
scale
.
width
)
<
1e
-
8
|
|
fabs
(
scale
.
height
)
<
1e
-
8
)
{
scale
=
Size
(
1
.
0
1
.
0
)
;
}
if
(
aTransform
&
&
!
gfxPrefs
:
:
LayersTilesEnabled
(
)
)
{
RestrictScaleToMaxLayerSize
(
scale
aVisibleRect
aContainerFrame
aLayer
)
;
}
}
else
{
scale
=
Size
(
1
.
0
1
.
0
)
;
}
aLayer
-
>
SetBaseTransform
(
transform
)
;
aLayer
-
>
SetPreScale
(
1
.
0f
/
scale
.
width
1
.
0f
/
scale
.
height
)
;
aLayer
-
>
SetInheritedScale
(
aIncomingScale
.
mXScale
aIncomingScale
.
mYScale
)
;
aOutgoingScale
=
ContainerLayerParameters
(
scale
.
width
scale
.
height
-
offset
aIncomingScale
)
;
if
(
aTransform
)
{
aOutgoingScale
.
mInTransformedSubtree
=
true
;
if
(
ActiveLayerTracker
:
:
IsStyleAnimated
(
aDisplayListBuilder
aContainerFrame
eCSSProperty_transform
)
)
{
aOutgoingScale
.
mInActiveTransformedSubtree
=
true
;
}
}
if
(
(
aLayerBuilder
-
>
IsBuildingRetainedLayers
(
)
&
&
(
!
canDraw2D
|
|
transform2d
.
HasNonIntegerTranslation
(
)
)
)
|
|
aContainerFrame
-
>
Extend3DContext
(
)
|
|
aContainerFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
aContainerFrame
-
>
HasAnimationOfTransform
(
)
)
{
aOutgoingScale
.
mDisableSubpixelAntialiasingInDescendants
=
true
;
}
return
true
;
}
already_AddRefed
<
ContainerLayer
>
FrameLayerBuilder
:
:
BuildContainerLayerFor
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
nsIFrame
*
aContainerFrame
nsDisplayItem
*
aContainerItem
nsDisplayList
*
aChildren
const
ContainerLayerParameters
&
aParameters
const
Matrix4x4
*
aTransform
uint32_t
aFlags
)
{
uint32_t
containerDisplayItemKey
=
aContainerItem
?
aContainerItem
-
>
GetPerFrameKey
(
)
:
0
;
NS_ASSERTION
(
aContainerFrame
"
Container
display
items
here
should
have
a
frame
"
)
;
NS_ASSERTION
(
!
aContainerItem
|
|
aContainerItem
-
>
Frame
(
)
=
=
aContainerFrame
"
Container
display
item
must
match
given
frame
"
)
;
if
(
!
aParameters
.
mXScale
|
|
!
aParameters
.
mYScale
)
{
return
nullptr
;
}
RefPtr
<
ContainerLayer
>
containerLayer
;
if
(
aManager
=
=
mRetainingManager
)
{
Layer
*
oldLayer
=
nullptr
;
if
(
aContainerItem
)
{
oldLayer
=
GetOldLayerFor
(
aContainerItem
)
;
}
else
{
DisplayItemData
*
data
=
GetOldLayerForFrame
(
aContainerFrame
containerDisplayItemKey
)
;
if
(
data
)
{
oldLayer
=
data
-
>
mLayer
;
}
}
if
(
oldLayer
)
{
NS_ASSERTION
(
oldLayer
-
>
Manager
(
)
=
=
aManager
"
Wrong
manager
"
)
;
if
(
oldLayer
-
>
HasUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
{
}
else
{
NS_ASSERTION
(
oldLayer
-
>
GetType
(
)
=
=
Layer
:
:
TYPE_CONTAINER
"
Wrong
layer
type
"
)
;
containerLayer
=
static_cast
<
ContainerLayer
*
>
(
oldLayer
)
;
ResetLayerStateForRecycling
(
containerLayer
)
;
}
}
}
if
(
!
containerLayer
)
{
containerLayer
=
aManager
-
>
CreateContainerLayer
(
)
;
if
(
!
containerLayer
)
return
nullptr
;
}
if
(
aContainerItem
&
&
aContainerItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_SCROLL_INFO_LAYER
)
{
NS_ASSERTION
(
aChildren
-
>
IsEmpty
(
)
"
Should
have
no
children
"
)
;
return
containerLayer
.
forget
(
)
;
}
const
ActiveScrolledRoot
*
containerASR
=
aContainerItem
?
aContainerItem
-
>
GetActiveScrolledRoot
(
)
:
nullptr
;
const
ActiveScrolledRoot
*
containerScrollMetadataASR
=
aParameters
.
mScrollMetadataASR
;
const
ActiveScrolledRoot
*
containerCompositorASR
=
aParameters
.
mCompositorASR
;
if
(
!
aContainerItem
&
&
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
)
{
containerASR
=
aBuilder
-
>
ActiveScrolledRootForRootScrollframe
(
)
;
containerScrollMetadataASR
=
containerASR
;
containerCompositorASR
=
containerASR
;
}
ContainerLayerParameters
scaleParameters
;
nsRect
bounds
=
aChildren
-
>
GetClippedBoundsWithRespectToASR
(
aBuilder
containerASR
)
;
nsRect
childrenVisible
=
aContainerItem
?
aContainerItem
-
>
GetBuildingRectForChildren
(
)
:
aContainerFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
if
(
!
ChooseScaleAndSetTransform
(
this
aBuilder
aContainerFrame
aContainerItem
bounds
.
Intersect
(
childrenVisible
)
aTransform
aParameters
containerLayer
scaleParameters
)
)
{
return
nullptr
;
}
if
(
mRetainingManager
)
{
if
(
aContainerItem
)
{
DisplayItemData
*
data
=
GetDisplayItemDataForManager
(
aContainerItem
mRetainingManager
)
;
StoreDataForFrame
(
aContainerItem
containerLayer
LAYER_ACTIVE
data
)
;
}
else
{
StoreDataForFrame
(
aContainerFrame
containerDisplayItemKey
containerLayer
LAYER_ACTIVE
)
;
}
}
nsIntRect
pixBounds
;
nscoord
appUnitsPerDevPixel
;
nscolor
backgroundColor
=
NS_RGBA
(
0
0
0
0
)
;
if
(
aFlags
&
CONTAINER_ALLOW_PULL_BACKGROUND_COLOR
)
{
backgroundColor
=
aParameters
.
mBackgroundColor
;
}
uint32_t
flags
;
ContainerState
state
(
aBuilder
aManager
aManager
-
>
GetLayerBuilder
(
)
aContainerFrame
aContainerItem
bounds
containerLayer
scaleParameters
backgroundColor
containerASR
containerScrollMetadataASR
containerCompositorASR
)
;
state
.
ProcessDisplayItems
(
aChildren
)
;
pixBounds
=
state
.
ScaleToOutsidePixels
(
bounds
false
)
;
appUnitsPerDevPixel
=
state
.
GetAppUnitsPerDevPixel
(
)
;
state
.
Finish
(
&
flags
pixBounds
aChildren
)
;
if
(
flags
&
Layer
:
:
CONTENT_COMPONENT_ALPHA
)
{
flags
|
=
Layer
:
:
CONTENT_COMPONENT_ALPHA_DESCENDANT
;
}
if
(
aChildren
-
>
IsOpaque
(
)
&
&
!
aChildren
-
>
NeedsTransparentSurface
(
)
)
{
bounds
.
ScaleRoundIn
(
scaleParameters
.
mXScale
scaleParameters
.
mYScale
)
;
if
(
bounds
.
Contains
(
ToAppUnits
(
pixBounds
appUnitsPerDevPixel
)
)
)
{
flags
&
=
~
Layer
:
:
CONTENT_COMPONENT_ALPHA
;
flags
|
=
Layer
:
:
CONTENT_OPAQUE
;
}
}
containerLayer
-
>
SetContentFlags
(
flags
)
;
if
(
!
aContainerItem
)
{
containerLayer
-
>
SetVisibleRegion
(
LayerIntRegion
:
:
FromUnknownRegion
(
pixBounds
)
)
;
}
if
(
aParameters
.
mLayerContentsVisibleRect
)
{
*
aParameters
.
mLayerContentsVisibleRect
=
pixBounds
+
scaleParameters
.
mOffset
;
}
nsPresContext
:
:
ClearNotifySubDocInvalidationData
(
containerLayer
)
;
return
containerLayer
.
forget
(
)
;
}
Layer
*
FrameLayerBuilder
:
:
GetLeafLayerFor
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
{
Layer
*
layer
=
GetOldLayerFor
(
aItem
)
;
if
(
!
layer
)
return
nullptr
;
if
(
layer
-
>
HasUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
{
return
nullptr
;
}
ResetLayerStateForRecycling
(
layer
)
;
return
layer
;
}
void
FrameLayerBuilder
:
:
InvalidateAllLayers
(
LayerManager
*
aManager
)
{
LayerManagerData
*
data
=
static_cast
<
LayerManagerData
*
>
(
aManager
-
>
GetUserData
(
&
gLayerManagerUserData
)
)
;
if
(
data
)
{
data
-
>
mInvalidateAllLayers
=
true
;
}
}
void
FrameLayerBuilder
:
:
InvalidateAllLayersForFrame
(
nsIFrame
*
aFrame
)
{
const
SmallPointerArray
<
DisplayItemData
>
&
array
=
aFrame
-
>
DisplayItemData
(
)
;
for
(
uint32_t
i
=
0
;
i
<
array
.
Length
(
)
;
i
+
+
)
{
DisplayItemData
:
:
AssertDisplayItemData
(
array
.
ElementAt
(
i
)
)
-
>
mParent
-
>
mInvalidateAllLayers
=
true
;
}
}
Layer
*
FrameLayerBuilder
:
:
GetDedicatedLayer
(
nsIFrame
*
aFrame
DisplayItemType
aDisplayItemKey
)
{
const
SmallPointerArray
<
DisplayItemData
>
&
array
=
aFrame
-
>
DisplayItemData
(
)
;
;
for
(
uint32_t
i
=
0
;
i
<
array
.
Length
(
)
;
i
+
+
)
{
DisplayItemData
*
element
=
DisplayItemData
:
:
AssertDisplayItemData
(
array
.
ElementAt
(
i
)
)
;
if
(
!
element
-
>
mParent
-
>
mLayerManager
-
>
IsWidgetLayerManager
(
)
)
{
continue
;
}
if
(
GetDisplayItemTypeFromKey
(
element
-
>
mDisplayItemKey
)
=
=
aDisplayItemKey
)
{
if
(
element
-
>
mOptLayer
)
{
return
element
-
>
mOptLayer
;
}
Layer
*
layer
=
element
-
>
mLayer
;
if
(
!
layer
-
>
HasUserData
(
&
gColorLayerUserData
)
&
&
!
layer
-
>
HasUserData
(
&
gImageLayerUserData
)
&
&
!
layer
-
>
HasUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
{
return
layer
;
}
}
}
return
nullptr
;
}
gfxSize
FrameLayerBuilder
:
:
GetPaintedLayerScaleForFrame
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
need
a
frame
"
)
;
nsPresContext
*
presCtx
=
aFrame
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
;
if
(
!
presCtx
)
{
presCtx
=
aFrame
-
>
PresContext
(
)
;
MOZ_ASSERT
(
presCtx
)
;
}
nsIFrame
*
root
=
presCtx
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
MOZ_ASSERT
(
root
)
;
float
resolution
=
presCtx
-
>
PresShell
(
)
-
>
GetResolution
(
)
;
Matrix4x4Flagged
transform
=
Matrix4x4
:
:
Scaling
(
resolution
resolution
1
.
0
)
;
if
(
aFrame
!
=
root
)
{
transform
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
aFrame
root
)
*
transform
;
}
Matrix
transform2d
;
if
(
transform
.
CanDraw2D
(
&
transform2d
)
)
{
return
ThebesMatrix
(
transform2d
)
.
ScaleFactors
(
true
)
;
}
return
gfxSize
(
1
.
0
1
.
0
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
static
void
DebugPaintItem
(
DrawTarget
&
aDrawTarget
nsPresContext
*
aPresContext
nsDisplayItem
*
aItem
nsDisplayListBuilder
*
aBuilder
)
{
bool
snap
;
Rect
bounds
=
NSRectToRect
(
aItem
-
>
GetBounds
(
aBuilder
&
snap
)
aPresContext
-
>
AppUnitsPerDevPixel
(
)
)
;
RefPtr
<
DrawTarget
>
tempDT
=
aDrawTarget
.
CreateSimilarDrawTarget
(
IntSize
:
:
Truncate
(
bounds
.
width
bounds
.
height
)
SurfaceFormat
:
:
B8G8R8A8
)
;
RefPtr
<
gfxContext
>
context
=
gfxContext
:
:
CreateOrNull
(
tempDT
)
;
if
(
!
context
)
{
gfxDevCrash
(
LogReason
:
:
InvalidContext
)
<
<
"
DebugPaintItem
context
problem
"
<
<
gfx
:
:
hexa
(
tempDT
)
;
return
;
}
context
-
>
SetMatrix
(
Matrix
:
:
Translation
(
-
bounds
.
x
-
bounds
.
y
)
)
;
aItem
-
>
Paint
(
aBuilder
context
)
;
RefPtr
<
SourceSurface
>
surface
=
tempDT
-
>
Snapshot
(
)
;
DumpPaintedImage
(
aItem
surface
)
;
aDrawTarget
.
DrawSurface
(
surface
bounds
Rect
(
Point
(
0
0
)
bounds
.
Size
(
)
)
)
;
aItem
-
>
SetPainted
(
)
;
}
#
endif
void
FrameLayerBuilder
:
:
RecomputeVisibilityForItems
(
std
:
:
vector
<
AssignedDisplayItem
>
&
aItems
nsDisplayListBuilder
*
aBuilder
const
nsIntRegion
&
aRegionToDraw
nsRect
&
aPreviousRectToDraw
const
nsIntPoint
&
aOffset
int32_t
aAppUnitsPerDevPixel
float
aXScale
float
aYScale
)
{
uint32_t
i
;
nsRegion
visible
=
aRegionToDraw
.
ToAppUnits
(
aAppUnitsPerDevPixel
)
;
visible
.
MoveBy
(
NSIntPixelsToAppUnits
(
aOffset
.
x
aAppUnitsPerDevPixel
)
NSIntPixelsToAppUnits
(
aOffset
.
y
aAppUnitsPerDevPixel
)
)
;
visible
.
ScaleInverseRoundOut
(
aXScale
aYScale
)
;
nsRect
previousRectToDraw
=
aPreviousRectToDraw
;
aPreviousRectToDraw
=
visible
.
GetBounds
(
)
;
for
(
i
=
aItems
.
size
(
)
;
i
>
0
;
-
-
i
)
{
AssignedDisplayItem
*
cdi
=
&
aItems
[
i
-
1
]
;
if
(
!
cdi
-
>
mItem
)
{
continue
;
}
if
(
cdi
-
>
mHasPaintRect
&
&
!
cdi
-
>
mContentRect
.
Intersects
(
visible
.
GetBounds
(
)
)
&
&
!
cdi
-
>
mContentRect
.
Intersects
(
previousRectToDraw
)
)
{
continue
;
}
if
(
IsEffectEndMarker
(
cdi
-
>
mType
)
|
|
cdi
-
>
mHasOpacity
|
|
cdi
-
>
mHasTransform
)
{
continue
;
}
const
DisplayItemClip
&
clip
=
cdi
-
>
mItem
-
>
GetClip
(
)
;
NS_ASSERTION
(
AppUnitsPerDevPixel
(
cdi
-
>
mItem
)
=
=
aAppUnitsPerDevPixel
"
a
painted
layer
should
contain
items
only
at
the
same
zoom
"
)
;
MOZ_ASSERT
(
clip
.
HasClip
(
)
|
|
clip
.
GetRoundedRectCount
(
)
=
=
0
"
If
we
have
rounded
rects
we
must
have
a
clip
rect
"
)
;
if
(
!
clip
.
IsRectAffectedByClip
(
visible
.
GetBounds
(
)
)
)
{
cdi
-
>
mItem
-
>
RecomputeVisibility
(
aBuilder
&
visible
)
;
continue
;
}
nsRegion
clipped
;
clipped
.
And
(
visible
clip
.
NonRoundedIntersection
(
)
)
;
nsRegion
finalClipped
=
clipped
;
cdi
-
>
mItem
-
>
RecomputeVisibility
(
aBuilder
&
finalClipped
)
;
if
(
clip
.
GetRoundedRectCount
(
)
=
=
0
)
{
nsRegion
removed
;
removed
.
Sub
(
clipped
finalClipped
)
;
nsRegion
newVisible
;
newVisible
.
Sub
(
visible
removed
)
;
if
(
newVisible
.
GetNumRects
(
)
<
=
15
)
{
visible
=
std
:
:
move
(
newVisible
)
;
}
}
}
}
static
void
PushOpacity
(
gfxContext
*
aContext
const
nsRect
&
aPaintRect
AssignedDisplayItem
&
aItem
const
int32_t
aAUPDP
)
{
MOZ_ASSERT
(
aItem
.
mType
=
=
DisplayItemEntryType
:
:
PUSH_OPACITY
|
|
aItem
.
mType
=
=
DisplayItemEntryType
:
:
PUSH_OPACITY_WITH_BG
)
;
MOZ_ASSERT
(
aItem
.
mItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_OPACITY
)
;
aContext
-
>
Save
(
)
;
DisplayItemClip
clip
;
clip
.
SetTo
(
aPaintRect
)
;
clip
.
IntersectWith
(
aItem
.
mItem
-
>
GetClip
(
)
)
;
clip
.
ApplyTo
(
aContext
aAUPDP
)
;
nsDisplayOpacity
*
opacityItem
=
static_cast
<
nsDisplayOpacity
*
>
(
aItem
.
mItem
)
;
const
float
opacity
=
opacityItem
-
>
GetOpacity
(
)
;
if
(
aItem
.
mType
=
=
DisplayItemEntryType
:
:
PUSH_OPACITY_WITH_BG
)
{
aContext
-
>
PushGroupAndCopyBackground
(
gfxContentType
:
:
COLOR_ALPHA
opacity
)
;
}
else
{
aContext
-
>
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
opacity
)
;
}
}
static
void
PushTransform
(
gfxContext
*
aContext
nsDisplayListBuilder
*
aBuilder
AssignedDisplayItem
&
aItem
const
int32_t
aAUPDP
MatrixStack4x4
&
aMatrixStack
const
Matrix4x4Flagged
&
aBaseMatrix
)
{
MOZ_ASSERT
(
aItem
.
mType
=
=
DisplayItemEntryType
:
:
PUSH_TRANSFORM
)
;
MOZ_ASSERT
(
aItem
.
mItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
)
;
nsDisplayTransform
*
transform
=
static_cast
<
nsDisplayTransform
*
>
(
aItem
.
mItem
)
;
if
(
transform
-
>
ShouldSkipTransform
(
aBuilder
)
)
{
aMatrixStack
.
Push
(
Matrix4x4Flagged
(
)
)
;
}
else
{
aMatrixStack
.
Push
(
transform
-
>
GetTransformForRendering
(
)
)
;
}
gfx
:
:
Matrix4x4Flagged
matrix
=
aMatrixStack
.
CurrentMatrix
(
)
*
aBaseMatrix
;
gfx
:
:
Matrix
matrix2d
;
DebugOnly
<
bool
>
ok
=
matrix
.
CanDraw2D
(
&
matrix2d
)
;
MOZ_ASSERT
(
ok
)
;
aContext
-
>
Save
(
)
;
const
DisplayItemClip
&
itemClip
=
aItem
.
mItem
-
>
GetClip
(
)
;
if
(
itemClip
.
HasClip
(
)
)
{
itemClip
.
ApplyTo
(
aContext
aAUPDP
)
;
}
aContext
-
>
SetMatrix
(
matrix2d
)
;
}
struct
ItemClipTracker
{
explicit
ItemClipTracker
(
gfxContext
*
aContext
const
int32_t
aAppUnitsPerDevPixel
)
:
mContext
(
aContext
)
mHasClip
(
false
)
mAppUnitsPerDevPixel
(
aAppUnitsPerDevPixel
)
{
}
bool
HasClip
(
)
const
{
return
mHasClip
;
}
bool
HasClip
(
const
DisplayItemClip
*
aClip
)
const
{
MOZ_ASSERT
(
aClip
&
&
aClip
-
>
HasClip
(
)
)
;
return
mHasClip
&
&
mCurrentClip
=
=
*
aClip
;
}
void
Restore
(
)
{
if
(
mCurrentClip
.
HasClip
(
)
)
{
mCurrentClip
=
DisplayItemClip
:
:
NoClip
(
)
;
}
if
(
!
HasClip
(
)
)
{
return
;
}
mContext
-
>
Restore
(
)
;
mHasClip
=
false
;
}
;
void
ChangeClipIfNeeded
(
const
DisplayItemClip
*
aClip
)
{
MOZ_ASSERT
(
aClip
&
&
aClip
-
>
HasClip
(
)
)
;
if
(
HasClip
(
aClip
)
)
{
return
;
}
Restore
(
)
;
mContext
-
>
Save
(
)
;
mHasClip
=
true
;
mCurrentClip
=
*
aClip
;
mCurrentClip
.
ApplyTo
(
mContext
mAppUnitsPerDevPixel
)
;
mContext
-
>
NewPath
(
)
;
}
private
:
gfxContext
*
mContext
;
bool
mHasClip
;
const
int32_t
mAppUnitsPerDevPixel
;
DisplayItemClip
mCurrentClip
;
}
;
static
void
UpdateEffectTracking
(
int
&
aOpacityLevel
int
&
aTransformLevel
const
DisplayItemEntryType
aType
)
{
switch
(
aType
)
{
case
DisplayItemEntryType
:
:
PUSH_OPACITY
:
case
DisplayItemEntryType
:
:
PUSH_OPACITY_WITH_BG
:
aOpacityLevel
+
+
;
break
;
case
DisplayItemEntryType
:
:
POP_OPACITY
:
aOpacityLevel
-
-
;
break
;
case
DisplayItemEntryType
:
:
PUSH_TRANSFORM
:
aTransformLevel
+
+
;
break
;
case
DisplayItemEntryType
:
:
POP_TRANSFORM
:
aTransformLevel
-
-
;
break
;
default
:
break
;
}
MOZ_ASSERT
(
aOpacityLevel
>
=
0
&
&
aTransformLevel
>
=
0
)
;
}
static
const
DisplayItemClip
*
GetItemClip
(
const
nsDisplayItem
*
aItem
DisplayItemClip
&
aOutClip
)
{
const
DisplayItemClip
&
clip
=
aItem
-
>
GetClip
(
)
;
if
(
!
clip
.
HasClip
(
)
)
{
return
nullptr
;
}
if
(
clip
.
GetRoundedRectCount
(
)
>
0
&
&
!
clip
.
IsRectClippedByRoundedCorner
(
aItem
-
>
GetPaintRect
(
)
)
)
{
aOutClip
=
clip
;
aOutClip
.
RemoveRoundedCorners
(
)
;
return
&
aOutClip
;
}
return
&
clip
;
}
void
FrameLayerBuilder
:
:
PaintItems
(
std
:
:
vector
<
AssignedDisplayItem
>
&
aItems
const
nsIntRect
&
aRect
gfxContext
*
aContext
nsDisplayListBuilder
*
aBuilder
nsPresContext
*
aPresContext
const
nsIntPoint
&
aOffset
float
aXScale
float
aYScale
)
{
DrawTarget
&
aDrawTarget
=
*
aContext
-
>
GetDrawTarget
(
)
;
int32_t
appUnitsPerDevPixel
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
boundRect
=
ToAppUnits
(
aRect
appUnitsPerDevPixel
)
;
boundRect
.
MoveBy
(
NSIntPixelsToAppUnits
(
aOffset
.
x
appUnitsPerDevPixel
)
NSIntPixelsToAppUnits
(
aOffset
.
y
appUnitsPerDevPixel
)
)
;
boundRect
.
ScaleInverseRoundOut
(
aXScale
aYScale
)
;
#
ifdef
DEBUG
int
opacityLevel
=
0
;
int
transformLevel
=
0
;
#
endif
int
emptyEffectLevel
=
0
;
DisplayItemClip
temporaryClip
;
ItemClipTracker
itemClipTracker
(
aContext
appUnitsPerDevPixel
)
;
MatrixStack4x4
matrixStack
;
const
Matrix4x4Flagged
base
=
Matrix4x4
:
:
From2D
(
aContext
-
>
CurrentMatrix
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aItems
.
size
(
)
;
+
+
i
)
{
AssignedDisplayItem
&
cdi
=
aItems
[
i
]
;
nsDisplayItem
*
item
=
cdi
.
mItem
;
if
(
!
item
)
{
MOZ_ASSERT
(
cdi
.
mType
=
=
DisplayItemEntryType
:
:
ITEM
)
;
continue
;
}
nsRect
visibleRect
=
item
-
>
GetPaintRect
(
)
;
if
(
matrixStack
.
HasTransform
(
)
)
{
MOZ_ASSERT
(
transformLevel
>
0
)
;
if
(
IsEffectEndMarker
(
cdi
.
mType
)
)
{
visibleRect
=
boundRect
;
}
else
{
const
Matrix4x4Flagged
&
matrix
=
matrixStack
.
CurrentMatrix
(
)
;
visibleRect
=
nsLayoutUtils
:
:
MatrixTransformRect
(
visibleRect
matrix
appUnitsPerDevPixel
)
;
}
}
const
nsRect
paintRect
=
visibleRect
.
Intersect
(
boundRect
)
;
if
(
paintRect
.
IsEmpty
(
)
|
|
emptyEffectLevel
>
0
)
{
UpdateEffectTracking
(
emptyEffectLevel
emptyEffectLevel
cdi
.
mType
)
;
continue
;
}
#
ifdef
MOZ_DUMP_PAINTING
AUTO_PROFILER_LABEL_DYNAMIC_CSTR
(
"
FrameLayerBuilder
:
:
PaintItems
"
GRAPHICS
item
-
>
Name
(
)
)
;
#
else
AUTO_PROFILER_LABEL
(
"
FrameLayerBuilder
:
:
PaintItems
"
GRAPHICS
)
;
#
endif
MOZ_ASSERT
(
(
opacityLevel
=
=
0
&
&
!
cdi
.
mHasOpacity
)
|
|
(
opacityLevel
>
0
&
&
cdi
.
mHasOpacity
)
|
|
(
transformLevel
=
=
0
&
&
!
cdi
.
mHasTransform
)
|
|
(
transformLevel
>
0
&
&
cdi
.
mHasTransform
)
)
;
if
(
cdi
.
mType
!
=
DisplayItemEntryType
:
:
ITEM
)
{
itemClipTracker
.
Restore
(
)
;
}
if
(
cdi
.
mType
=
=
DisplayItemEntryType
:
:
PUSH_OPACITY
|
|
cdi
.
mType
=
=
DisplayItemEntryType
:
:
PUSH_OPACITY_WITH_BG
)
{
PushOpacity
(
aContext
item
-
>
GetPaintRect
(
)
cdi
appUnitsPerDevPixel
)
;
}
if
(
cdi
.
mType
=
=
DisplayItemEntryType
:
:
POP_OPACITY
)
{
MOZ_ASSERT
(
item
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_OPACITY
)
;
MOZ_ASSERT
(
opacityLevel
>
0
)
;
aContext
-
>
PopGroupAndBlend
(
)
;
aContext
-
>
Restore
(
)
;
}
if
(
cdi
.
mType
=
=
DisplayItemEntryType
:
:
PUSH_TRANSFORM
)
{
PushTransform
(
aContext
aBuilder
cdi
appUnitsPerDevPixel
matrixStack
base
)
;
}
if
(
cdi
.
mType
=
=
DisplayItemEntryType
:
:
POP_TRANSFORM
)
{
matrixStack
.
Pop
(
)
;
aContext
-
>
Restore
(
)
;
}
if
(
cdi
.
mType
!
=
DisplayItemEntryType
:
:
ITEM
)
{
#
ifdef
DEBUG
UpdateEffectTracking
(
opacityLevel
transformLevel
cdi
.
mType
)
;
#
endif
continue
;
}
const
DisplayItemClip
*
itemClip
=
GetItemClip
(
item
temporaryClip
)
;
bool
itemPaintsOwnClip
=
false
;
if
(
itemClip
&
&
!
itemClipTracker
.
HasClip
(
itemClip
)
)
{
itemClipTracker
.
Restore
(
)
;
itemPaintsOwnClip
=
item
-
>
CanPaintWithClip
(
*
itemClip
)
;
if
(
!
itemPaintsOwnClip
)
{
itemClipTracker
.
ChangeClipIfNeeded
(
itemClip
)
;
}
}
if
(
!
itemClip
)
{
itemClipTracker
.
Restore
(
)
;
}
if
(
cdi
.
mInactiveLayerManager
)
{
bool
saved
=
aDrawTarget
.
GetPermitSubpixelAA
(
)
;
PaintInactiveLayer
(
aBuilder
cdi
.
mInactiveLayerManager
item
aContext
aContext
)
;
aDrawTarget
.
SetPermitSubpixelAA
(
saved
)
;
}
else
{
nsIFrame
*
frame
=
item
-
>
Frame
(
)
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
frame
-
>
AddStateBits
(
NS_FRAME_PAINTED_THEBES
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxEnv
:
:
DumpPaintItems
(
)
)
{
DebugPaintItem
(
aDrawTarget
aPresContext
item
aBuilder
)
;
}
else
#
endif
if
(
itemPaintsOwnClip
)
{
MOZ_ASSERT
(
itemClip
)
;
item
-
>
PaintWithClip
(
aBuilder
aContext
*
itemClip
)
;
}
else
{
item
-
>
Paint
(
aBuilder
aContext
)
;
}
}
}
itemClipTracker
.
Restore
(
)
;
MOZ_ASSERT
(
opacityLevel
=
=
0
)
;
MOZ_ASSERT
(
transformLevel
=
=
0
)
;
MOZ_ASSERT
(
emptyEffectLevel
=
=
0
)
;
}
static
bool
ShouldDrawRectsSeparately
(
DrawTarget
*
aDrawTarget
DrawRegionClip
aClip
)
{
if
(
!
gfxPrefs
:
:
LayoutPaintRectsSeparately
(
)
|
|
aClip
=
=
DrawRegionClip
:
:
NONE
)
{
return
false
;
}
return
!
aDrawTarget
-
>
SupportsRegionClipping
(
)
;
}
static
void
DrawForcedBackgroundColor
(
DrawTarget
&
aDrawTarget
const
IntRect
&
aBounds
nscolor
aBackgroundColor
)
{
if
(
NS_GET_A
(
aBackgroundColor
)
>
0
)
{
ColorPattern
color
(
ToDeviceColor
(
aBackgroundColor
)
)
;
aDrawTarget
.
FillRect
(
Rect
(
aBounds
)
color
)
;
}
}
void
FrameLayerBuilder
:
:
DrawPaintedLayer
(
PaintedLayer
*
aLayer
gfxContext
*
aContext
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aDirtyRegion
DrawRegionClip
aClip
const
nsIntRegion
&
aRegionToInvalidate
void
*
aCallbackData
)
{
DrawTarget
&
aDrawTarget
=
*
aContext
-
>
GetDrawTarget
(
)
;
AUTO_PROFILER_LABEL
(
"
FrameLayerBuilder
:
:
DrawPaintedLayer
"
GRAPHICS
)
;
nsDisplayListBuilder
*
builder
=
static_cast
<
nsDisplayListBuilder
*
>
(
aCallbackData
)
;
FrameLayerBuilder
*
layerBuilder
=
aLayer
-
>
Manager
(
)
-
>
GetLayerBuilder
(
)
;
NS_ASSERTION
(
layerBuilder
"
Unexpectedly
null
layer
builder
!
"
)
;
PaintedDisplayItemLayerUserData
*
userData
=
static_cast
<
PaintedDisplayItemLayerUserData
*
>
(
aLayer
-
>
GetUserData
(
&
gPaintedDisplayItemLayerUserData
)
)
;
NS_ASSERTION
(
userData
"
where
did
our
user
data
go
?
"
)
;
if
(
!
userData
-
>
mContainerLayerFrame
)
{
return
;
}
bool
shouldDrawRectsSeparately
=
ShouldDrawRectsSeparately
(
&
aDrawTarget
aClip
)
;
if
(
!
shouldDrawRectsSeparately
)
{
if
(
aClip
=
=
DrawRegionClip
:
:
DRAW
)
{
gfxUtils
:
:
ClipToRegion
(
aContext
aRegionToDraw
)
;
}
DrawForcedBackgroundColor
(
aDrawTarget
aRegionToDraw
.
GetBounds
(
)
userData
-
>
mForcedBackgroundColor
)
;
}
gfxContextMatrixAutoSaveRestore
saveMatrix
(
aContext
)
;
nsIntPoint
offset
=
GetTranslationForPaintedLayer
(
aLayer
)
;
nsPresContext
*
presContext
=
userData
-
>
mContainerLayerFrame
-
>
PresContext
(
)
;
if
(
!
userData
-
>
mVisibilityComputedRegion
.
Contains
(
aDirtyRegion
)
&
&
!
layerBuilder
-
>
GetContainingPaintedLayerData
(
)
)
{
int32_t
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
RecomputeVisibilityForItems
(
userData
-
>
mItems
builder
aDirtyRegion
userData
-
>
mPreviousRecomputeVisibilityRect
offset
appUnitsPerDevPixel
userData
-
>
mXScale
userData
-
>
mYScale
)
;
userData
-
>
mVisibilityComputedRegion
=
aDirtyRegion
;
}
if
(
shouldDrawRectsSeparately
)
{
for
(
auto
iter
=
aRegionToDraw
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsIntRect
&
iterRect
=
iter
.
Get
(
)
;
gfxContextAutoSaveRestore
save
(
aContext
)
;
aContext
-
>
NewPath
(
)
;
aContext
-
>
Rectangle
(
ThebesRect
(
iterRect
)
)
;
aContext
-
>
Clip
(
)
;
DrawForcedBackgroundColor
(
aDrawTarget
iterRect
userData
-
>
mForcedBackgroundColor
)
;
aContext
-
>
SetMatrixDouble
(
aContext
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
aLayer
-
>
GetResidualTranslation
(
)
-
gfxPoint
(
offset
.
x
offset
.
y
)
)
.
PreScale
(
userData
-
>
mXScale
userData
-
>
mYScale
)
)
;
layerBuilder
-
>
PaintItems
(
userData
-
>
mItems
iterRect
aContext
builder
presContext
offset
userData
-
>
mXScale
userData
-
>
mYScale
)
;
if
(
gfxPrefs
:
:
GfxLoggingPaintedPixelCountEnabled
(
)
)
{
aLayer
-
>
Manager
(
)
-
>
AddPaintedPixelCount
(
iterRect
.
Area
(
)
)
;
}
}
}
else
{
aContext
-
>
SetMatrixDouble
(
aContext
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
aLayer
-
>
GetResidualTranslation
(
)
-
gfxPoint
(
offset
.
x
offset
.
y
)
)
.
PreScale
(
userData
-
>
mXScale
userData
-
>
mYScale
)
)
;
layerBuilder
-
>
PaintItems
(
userData
-
>
mItems
aRegionToDraw
.
GetBounds
(
)
aContext
builder
presContext
offset
userData
-
>
mXScale
userData
-
>
mYScale
)
;
if
(
gfxPrefs
:
:
GfxLoggingPaintedPixelCountEnabled
(
)
)
{
aLayer
-
>
Manager
(
)
-
>
AddPaintedPixelCount
(
aRegionToDraw
.
GetBounds
(
)
.
Area
(
)
)
;
}
}
bool
isActiveLayerManager
=
!
aLayer
-
>
Manager
(
)
-
>
IsInactiveLayerManager
(
)
;
if
(
presContext
-
>
GetPaintFlashing
(
)
&
&
isActiveLayerManager
)
{
gfxContextAutoSaveRestore
save
(
aContext
)
;
if
(
shouldDrawRectsSeparately
)
{
if
(
aClip
=
=
DrawRegionClip
:
:
DRAW
)
{
gfxUtils
:
:
ClipToRegion
(
aContext
aRegionToDraw
)
;
}
}
FlashPaint
(
aContext
)
;
}
if
(
presContext
-
>
GetDocShell
(
)
&
&
isActiveLayerManager
)
{
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
presContext
-
>
GetDocShell
(
)
)
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
if
(
timelines
&
&
timelines
-
>
HasConsumer
(
docShell
)
)
{
timelines
-
>
AddMarkerForDocShell
(
docShell
MakeUnique
<
LayerTimelineMarker
>
(
aRegionToDraw
)
)
;
}
}
if
(
!
aRegionToInvalidate
.
IsEmpty
(
)
)
{
aLayer
-
>
AddInvalidRect
(
aRegionToInvalidate
.
GetBounds
(
)
)
;
}
}
void
FrameLayerBuilder
:
:
DumpRetainedLayerTree
(
LayerManager
*
aManager
std
:
:
stringstream
&
aStream
bool
aDumpHtml
)
{
aManager
-
>
Dump
(
aStream
"
"
aDumpHtml
)
;
}
nsDisplayItemGeometry
*
FrameLayerBuilder
:
:
GetMostRecentGeometry
(
nsDisplayItem
*
aItem
)
{
typedef
SmallPointerArray
<
DisplayItemData
>
DataArray
;
const
DataArray
&
dataArray
=
aItem
-
>
Frame
(
)
-
>
DisplayItemData
(
)
;
uint32_t
itemPerFrameKey
=
aItem
-
>
GetPerFrameKey
(
)
;
for
(
uint32_t
i
=
0
;
i
<
dataArray
.
Length
(
)
;
i
+
+
)
{
DisplayItemData
*
data
=
DisplayItemData
:
:
AssertDisplayItemData
(
dataArray
.
ElementAt
(
i
)
)
;
if
(
data
-
>
GetDisplayItemKey
(
)
=
=
itemPerFrameKey
)
{
return
data
-
>
GetGeometry
(
)
;
}
}
if
(
RefPtr
<
WebRenderFallbackData
>
data
=
GetWebRenderUserData
<
WebRenderFallbackData
>
(
aItem
-
>
Frame
(
)
itemPerFrameKey
)
)
{
return
data
-
>
GetGeometry
(
)
;
}
return
nullptr
;
}
static
gfx
:
:
Rect
CalculateBounds
(
const
nsTArray
<
DisplayItemClip
:
:
RoundedRect
>
&
aRects
int32_t
aAppUnitsPerDevPixel
)
{
nsRect
bounds
=
aRects
[
0
]
.
mRect
;
for
(
uint32_t
i
=
1
;
i
<
aRects
.
Length
(
)
;
+
+
i
)
{
bounds
.
UnionRect
(
bounds
aRects
[
i
]
.
mRect
)
;
}
return
gfx
:
:
Rect
(
bounds
.
ToNearestPixels
(
aAppUnitsPerDevPixel
)
)
;
}
void
ContainerState
:
:
SetupMaskLayer
(
Layer
*
aLayer
const
DisplayItemClip
&
aClip
)
{
if
(
aClip
.
GetRoundedRectCount
(
)
=
=
0
)
{
return
;
}
RefPtr
<
Layer
>
maskLayer
=
CreateMaskLayer
(
aLayer
aClip
Nothing
(
)
)
;
if
(
!
maskLayer
)
{
return
;
}
aLayer
-
>
SetMaskLayer
(
maskLayer
)
;
}
static
MaskLayerUserData
*
GetMaskLayerUserData
(
Layer
*
aMaskLayer
)
{
if
(
!
aMaskLayer
)
{
return
nullptr
;
}
return
static_cast
<
MaskLayerUserData
*
>
(
aMaskLayer
-
>
GetUserData
(
&
gMaskLayerUserData
)
)
;
}
static
void
SetMaskLayerUserData
(
Layer
*
aMaskLayer
)
{
MOZ_ASSERT
(
aMaskLayer
)
;
aMaskLayer
-
>
SetUserData
(
&
gMaskLayerUserData
new
MaskLayerUserData
(
)
)
;
}
already_AddRefed
<
Layer
>
ContainerState
:
:
CreateMaskLayer
(
Layer
*
aLayer
const
DisplayItemClip
&
aClip
const
Maybe
<
size_t
>
&
aForAncestorMaskLayer
)
{
MOZ_ASSERT
(
!
aLayer
-
>
GetUserData
(
&
gCSSMaskLayerUserData
)
"
A
layer
contains
round
clips
should
not
have
css
-
mask
on
it
.
"
)
;
RefPtr
<
ImageLayer
>
maskLayer
=
CreateOrRecycleMaskImageLayerFor
(
MaskLayerKey
(
aLayer
aForAncestorMaskLayer
)
GetMaskLayerUserData
SetMaskLayerUserData
)
;
MaskLayerUserData
*
userData
=
GetMaskLayerUserData
(
maskLayer
.
get
(
)
)
;
int32_t
A2D
=
mContainerFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
MaskLayerUserData
newData
(
aClip
A2D
mParameters
)
;
if
(
*
userData
=
=
newData
)
{
return
maskLayer
.
forget
(
)
;
}
gfx
:
:
Rect
boundingRect
=
CalculateBounds
(
newData
.
mRoundedClipRects
newData
.
mAppUnitsPerDevPixel
)
;
boundingRect
.
Scale
(
mParameters
.
mXScale
mParameters
.
mYScale
)
;
if
(
boundingRect
.
IsEmpty
(
)
)
{
return
nullptr
;
}
uint32_t
maxSize
=
mManager
-
>
GetMaxTextureSize
(
)
;
NS_ASSERTION
(
maxSize
>
0
"
Invalid
max
texture
size
"
)
;
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
gfx
:
:
Size
surfaceSize
(
std
:
:
min
<
gfx
:
:
Float
>
(
GetAlignedStride
<
4
>
(
NSToIntCeil
(
boundingRect
.
Width
(
)
)
1
)
maxSize
)
std
:
:
min
<
gfx
:
:
Float
>
(
boundingRect
.
Height
(
)
maxSize
)
)
;
#
else
gfx
:
:
Size
surfaceSize
(
std
:
:
min
<
gfx
:
:
Float
>
(
boundingRect
.
Width
(
)
maxSize
)
std
:
:
min
<
gfx
:
:
Float
>
(
boundingRect
.
Height
(
)
maxSize
)
)
;
#
endif
gfx
:
:
Matrix
maskTransform
=
Matrix
:
:
Scaling
(
surfaceSize
.
width
/
boundingRect
.
Width
(
)
surfaceSize
.
height
/
boundingRect
.
Height
(
)
)
;
if
(
surfaceSize
.
IsEmpty
(
)
)
{
return
nullptr
;
}
gfx
:
:
Point
p
=
boundingRect
.
TopLeft
(
)
;
maskTransform
.
PreTranslate
(
-
p
.
x
-
p
.
y
)
;
gfx
:
:
Matrix
imageTransform
=
maskTransform
;
imageTransform
.
PreScale
(
mParameters
.
mXScale
mParameters
.
mYScale
)
;
nsAutoPtr
<
MaskLayerImageCache
:
:
MaskLayerImageKey
>
newKey
(
new
MaskLayerImageCache
:
:
MaskLayerImageKey
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
newData
.
mRoundedClipRects
.
Length
(
)
;
+
+
i
)
{
newKey
-
>
mRoundedClipRects
.
AppendElement
(
MaskLayerImageCache
:
:
PixelRoundedRect
(
newData
.
mRoundedClipRects
[
i
]
mContainerFrame
-
>
PresContext
(
)
)
)
;
newKey
-
>
mRoundedClipRects
[
i
]
.
ScaleAndTranslate
(
imageTransform
)
;
}
newKey
-
>
mKnowsCompositor
=
mManager
-
>
AsKnowsCompositor
(
)
;
const
MaskLayerImageCache
:
:
MaskLayerImageKey
*
lookupKey
=
newKey
;
RefPtr
<
ImageContainer
>
container
=
GetMaskLayerImageCache
(
)
-
>
FindImageFor
(
&
lookupKey
)
;
if
(
!
container
)
{
IntSize
surfaceSizeInt
(
NSToIntCeil
(
surfaceSize
.
width
)
NSToIntCeil
(
surfaceSize
.
height
)
)
;
MaskImageData
imageData
(
surfaceSizeInt
mManager
)
;
RefPtr
<
DrawTarget
>
dt
=
imageData
.
CreateDrawTarget
(
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
NS_WARNING
(
"
Could
not
create
DrawTarget
for
mask
layer
.
"
)
;
return
nullptr
;
}
RefPtr
<
gfxContext
>
context
=
gfxContext
:
:
CreateOrNull
(
dt
)
;
MOZ_ASSERT
(
context
)
;
context
-
>
Multiply
(
ThebesMatrix
(
imageTransform
)
)
;
aClip
.
FillIntersectionOfRoundedRectClips
(
context
Color
(
1
.
f
1
.
f
1
.
f
1
.
f
)
newData
.
mAppUnitsPerDevPixel
)
;
MOZ_ASSERT
(
aLayer
-
>
Manager
(
)
=
=
mManager
)
;
container
=
imageData
.
CreateImageAndImageContainer
(
)
;
NS_ASSERTION
(
container
"
Could
not
create
image
container
for
mask
layer
.
"
)
;
if
(
!
container
)
{
return
nullptr
;
}
GetMaskLayerImageCache
(
)
-
>
PutImage
(
newKey
.
forget
(
)
container
)
;
}
maskLayer
-
>
SetContainer
(
container
)
;
maskTransform
.
Invert
(
)
;
Matrix4x4
matrix
=
Matrix4x4
:
:
From2D
(
maskTransform
)
;
matrix
.
PreTranslate
(
mParameters
.
mOffset
.
x
mParameters
.
mOffset
.
y
0
)
;
maskLayer
-
>
SetBaseTransform
(
matrix
)
;
*
userData
=
std
:
:
move
(
newData
)
;
userData
-
>
mImageKey
.
Reset
(
lookupKey
)
;
return
maskLayer
.
forget
(
)
;
}
}
