#
include
<
ctime
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
BorderConsts
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
ImageOps
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsCSSColorUtils
.
h
"
#
include
"
nsITheme
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsCSSRenderingBorders
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfxGradientCache
.
h
"
#
include
"
nsInlineFrame
.
h
"
#
include
"
nsRubyTextContainerFrame
.
h
"
#
include
<
algorithm
>
#
include
"
SVGImageContext
.
h
"
#
include
"
TextDrawTarget
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
mozilla
:
:
CSSSizeOrRatio
;
using
mozilla
:
:
dom
:
:
Document
;
static
int
gFrameTreeLockCount
=
0
;
struct
InlineBackgroundData
{
InlineBackgroundData
(
)
:
mFrame
(
nullptr
)
mLineContainer
(
nullptr
)
mContinuationPoint
(
0
)
mUnbrokenMeasure
(
0
)
mLineContinuationPoint
(
0
)
mPIStartBorderData
{
}
mBidiEnabled
(
false
)
mVertical
(
false
)
{
}
~
InlineBackgroundData
(
)
=
default
;
void
Reset
(
)
{
mBoundingBox
.
SetRect
(
0
0
0
0
)
;
mContinuationPoint
=
mLineContinuationPoint
=
mUnbrokenMeasure
=
0
;
mFrame
=
mLineContainer
=
nullptr
;
mPIStartBorderData
.
Reset
(
)
;
}
nsRect
GetContinuousRect
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
static_cast
<
nsInlineFrame
*
>
(
do_QueryFrame
(
aFrame
)
)
)
;
SetFrame
(
aFrame
)
;
nscoord
pos
;
if
(
mBidiEnabled
)
{
pos
=
mLineContinuationPoint
;
bool
isRtlBlock
=
(
mLineContainer
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_RTL
)
;
nscoord
curOffset
=
mVertical
?
aFrame
-
>
GetOffsetTo
(
mLineContainer
)
.
y
:
aFrame
-
>
GetOffsetTo
(
mLineContainer
)
.
x
;
nsIFrame
*
inlineFrame
=
aFrame
-
>
GetPrevContinuation
(
)
;
while
(
inlineFrame
&
&
!
inlineFrame
-
>
GetNextInFlow
(
)
&
&
AreOnSameLine
(
aFrame
inlineFrame
)
)
{
nscoord
frameOffset
=
mVertical
?
inlineFrame
-
>
GetOffsetTo
(
mLineContainer
)
.
y
:
inlineFrame
-
>
GetOffsetTo
(
mLineContainer
)
.
x
;
if
(
isRtlBlock
=
=
(
frameOffset
>
=
curOffset
)
)
{
pos
+
=
mVertical
?
inlineFrame
-
>
GetSize
(
)
.
height
:
inlineFrame
-
>
GetSize
(
)
.
width
;
}
inlineFrame
=
inlineFrame
-
>
GetPrevContinuation
(
)
;
}
inlineFrame
=
aFrame
-
>
GetNextContinuation
(
)
;
while
(
inlineFrame
&
&
!
inlineFrame
-
>
GetPrevInFlow
(
)
&
&
AreOnSameLine
(
aFrame
inlineFrame
)
)
{
nscoord
frameOffset
=
mVertical
?
inlineFrame
-
>
GetOffsetTo
(
mLineContainer
)
.
y
:
inlineFrame
-
>
GetOffsetTo
(
mLineContainer
)
.
x
;
if
(
isRtlBlock
=
=
(
frameOffset
>
=
curOffset
)
)
{
pos
+
=
mVertical
?
inlineFrame
-
>
GetSize
(
)
.
height
:
inlineFrame
-
>
GetSize
(
)
.
width
;
}
inlineFrame
=
inlineFrame
-
>
GetNextContinuation
(
)
;
}
if
(
isRtlBlock
)
{
pos
+
=
mVertical
?
aFrame
-
>
GetSize
(
)
.
height
:
aFrame
-
>
GetSize
(
)
.
width
;
pos
=
mUnbrokenMeasure
-
pos
;
}
}
else
{
pos
=
mContinuationPoint
;
}
return
mVertical
?
nsRect
(
0
-
pos
mFrame
-
>
GetSize
(
)
.
width
mUnbrokenMeasure
)
:
nsRect
(
-
pos
0
mUnbrokenMeasure
mFrame
-
>
GetSize
(
)
.
height
)
;
}
nsRect
GetBorderContinuousRect
(
nsIFrame
*
aFrame
nsRect
aBorderArea
)
{
PhysicalInlineStartBorderData
saved
(
mPIStartBorderData
)
;
nsRect
joinedBorderArea
=
GetContinuousRect
(
aFrame
)
;
if
(
!
saved
.
mIsValid
|
|
saved
.
mFrame
!
=
mPIStartBorderData
.
mFrame
)
{
if
(
aFrame
=
=
mPIStartBorderData
.
mFrame
)
{
if
(
mVertical
)
{
mPIStartBorderData
.
SetCoord
(
joinedBorderArea
.
y
)
;
}
else
{
mPIStartBorderData
.
SetCoord
(
joinedBorderArea
.
x
)
;
}
}
else
if
(
mPIStartBorderData
.
mFrame
)
{
if
(
mVertical
)
{
mPIStartBorderData
.
SetCoord
(
GetContinuousRect
(
mPIStartBorderData
.
mFrame
)
.
y
)
;
}
else
{
mPIStartBorderData
.
SetCoord
(
GetContinuousRect
(
mPIStartBorderData
.
mFrame
)
.
x
)
;
}
}
}
else
{
mPIStartBorderData
.
mCoord
=
saved
.
mCoord
;
}
if
(
mVertical
)
{
if
(
joinedBorderArea
.
y
>
mPIStartBorderData
.
mCoord
)
{
joinedBorderArea
.
y
=
-
(
mUnbrokenMeasure
+
joinedBorderArea
.
y
-
aBorderArea
.
height
)
;
}
else
{
joinedBorderArea
.
y
-
=
mPIStartBorderData
.
mCoord
;
}
}
else
{
if
(
joinedBorderArea
.
x
>
mPIStartBorderData
.
mCoord
)
{
joinedBorderArea
.
x
=
-
(
mUnbrokenMeasure
+
joinedBorderArea
.
x
-
aBorderArea
.
width
)
;
}
else
{
joinedBorderArea
.
x
-
=
mPIStartBorderData
.
mCoord
;
}
}
return
joinedBorderArea
;
}
nsRect
GetBoundingRect
(
nsIFrame
*
aFrame
)
{
SetFrame
(
aFrame
)
;
nsRect
boundingBox
(
mBoundingBox
)
;
nsPoint
point
=
mFrame
-
>
GetPosition
(
)
;
boundingBox
.
MoveBy
(
-
point
.
x
-
point
.
y
)
;
return
boundingBox
;
}
protected
:
struct
PhysicalInlineStartBorderData
{
nsIFrame
*
mFrame
;
nscoord
mCoord
;
bool
mIsValid
;
void
Reset
(
)
{
mFrame
=
nullptr
;
mIsValid
=
false
;
}
void
SetCoord
(
nscoord
aCoord
)
{
mCoord
=
aCoord
;
mIsValid
=
true
;
}
}
;
nsIFrame
*
mFrame
;
nsIFrame
*
mLineContainer
;
nsRect
mBoundingBox
;
nscoord
mContinuationPoint
;
nscoord
mUnbrokenMeasure
;
nscoord
mLineContinuationPoint
;
PhysicalInlineStartBorderData
mPIStartBorderData
;
bool
mBidiEnabled
;
bool
mVertical
;
void
SetFrame
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
Need
a
frame
"
)
;
NS_ASSERTION
(
gFrameTreeLockCount
>
0
"
Can
'
t
call
this
when
frame
tree
is
not
locked
"
)
;
if
(
aFrame
=
=
mFrame
)
{
return
;
}
nsIFrame
*
prevContinuation
=
GetPrevContinuation
(
aFrame
)
;
if
(
!
prevContinuation
|
|
mFrame
!
=
prevContinuation
)
{
Reset
(
)
;
Init
(
aFrame
)
;
return
;
}
mContinuationPoint
+
=
mVertical
?
mFrame
-
>
GetSize
(
)
.
height
:
mFrame
-
>
GetSize
(
)
.
width
;
if
(
mBidiEnabled
&
&
(
aFrame
-
>
GetPrevInFlow
(
)
|
|
!
AreOnSameLine
(
mFrame
aFrame
)
)
)
{
mLineContinuationPoint
=
mContinuationPoint
;
}
mFrame
=
aFrame
;
}
nsIFrame
*
GetPrevContinuation
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
prevCont
=
aFrame
-
>
GetPrevContinuation
(
)
;
if
(
!
prevCont
&
&
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
nsIFrame
*
block
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
if
(
block
)
{
NS_ASSERTION
(
!
block
-
>
GetPrevContinuation
(
)
"
Incorrect
value
for
IBSplitPrevSibling
"
)
;
prevCont
=
block
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
NS_ASSERTION
(
prevCont
"
How
did
that
happen
?
"
)
;
}
}
return
prevCont
;
}
nsIFrame
*
GetNextContinuation
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
nextCont
=
aFrame
-
>
GetNextContinuation
(
)
;
if
(
!
nextCont
&
&
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
aFrame
=
aFrame
-
>
FirstContinuation
(
)
;
nsIFrame
*
block
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
if
(
block
)
{
nextCont
=
block
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
NS_ASSERTION
(
nextCont
"
How
did
that
happen
?
"
)
;
}
}
return
nextCont
;
}
void
Init
(
nsIFrame
*
aFrame
)
{
mPIStartBorderData
.
Reset
(
)
;
mBidiEnabled
=
aFrame
-
>
PresContext
(
)
-
>
BidiEnabled
(
)
;
if
(
mBidiEnabled
)
{
mLineContainer
=
aFrame
;
while
(
mLineContainer
&
&
mLineContainer
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
mLineContainer
=
mLineContainer
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
mLineContainer
"
Cannot
find
line
containing
frame
.
"
)
;
MOZ_ASSERT
(
mLineContainer
!
=
aFrame
"
line
container
frame
"
"
should
be
an
ancestor
of
the
target
frame
.
"
)
;
}
mVertical
=
aFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
;
nsIFrame
*
inlineFrame
=
GetPrevContinuation
(
aFrame
)
;
while
(
inlineFrame
)
{
if
(
!
mPIStartBorderData
.
mFrame
&
&
!
(
mVertical
?
inlineFrame
-
>
GetSkipSides
(
)
.
Top
(
)
:
inlineFrame
-
>
GetSkipSides
(
)
.
Left
(
)
)
)
{
mPIStartBorderData
.
mFrame
=
inlineFrame
;
}
nsRect
rect
=
inlineFrame
-
>
GetRect
(
)
;
mContinuationPoint
+
=
mVertical
?
rect
.
height
:
rect
.
width
;
if
(
mBidiEnabled
&
&
!
AreOnSameLine
(
aFrame
inlineFrame
)
)
{
mLineContinuationPoint
+
=
mVertical
?
rect
.
height
:
rect
.
width
;
}
mUnbrokenMeasure
+
=
mVertical
?
rect
.
height
:
rect
.
width
;
mBoundingBox
.
UnionRect
(
mBoundingBox
rect
)
;
inlineFrame
=
GetPrevContinuation
(
inlineFrame
)
;
}
inlineFrame
=
aFrame
;
while
(
inlineFrame
)
{
if
(
!
mPIStartBorderData
.
mFrame
&
&
!
(
mVertical
?
inlineFrame
-
>
GetSkipSides
(
)
.
Top
(
)
:
inlineFrame
-
>
GetSkipSides
(
)
.
Left
(
)
)
)
{
mPIStartBorderData
.
mFrame
=
inlineFrame
;
}
nsRect
rect
=
inlineFrame
-
>
GetRect
(
)
;
mUnbrokenMeasure
+
=
mVertical
?
rect
.
height
:
rect
.
width
;
mBoundingBox
.
UnionRect
(
mBoundingBox
rect
)
;
inlineFrame
=
GetNextContinuation
(
inlineFrame
)
;
}
mFrame
=
aFrame
;
}
bool
AreOnSameLine
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
if
(
nsBlockFrame
*
blockFrame
=
do_QueryFrame
(
mLineContainer
)
)
{
bool
isValid1
isValid2
;
nsBlockInFlowLineIterator
it1
(
blockFrame
aFrame1
&
isValid1
)
;
nsBlockInFlowLineIterator
it2
(
blockFrame
aFrame2
&
isValid2
)
;
return
isValid1
&
&
isValid2
&
&
it1
.
GetContainer
(
)
=
=
it2
.
GetContainer
(
)
&
&
it1
.
GetLine
(
)
=
=
it2
.
GetLine
(
)
;
}
if
(
nsRubyTextContainerFrame
*
rtcFrame
=
do_QueryFrame
(
mLineContainer
)
)
{
nsBlockFrame
*
block
=
nsLayoutUtils
:
:
FindNearestBlockAncestor
(
rtcFrame
)
;
for
(
nsIFrame
*
frame
=
rtcFrame
-
>
FirstContinuation
(
)
;
frame
;
frame
=
frame
-
>
GetNextContinuation
(
)
)
{
bool
isDescendant1
=
nsLayoutUtils
:
:
IsProperAncestorFrame
(
frame
aFrame1
block
)
;
bool
isDescendant2
=
nsLayoutUtils
:
:
IsProperAncestorFrame
(
frame
aFrame2
block
)
;
if
(
isDescendant1
&
&
isDescendant2
)
{
return
true
;
}
if
(
isDescendant1
|
|
isDescendant2
)
{
return
false
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
None
of
the
frames
is
a
descendant
of
this
rtc
?
"
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Do
we
have
any
other
type
of
line
container
?
"
)
;
return
false
;
}
}
;
static
InlineBackgroundData
*
gInlineBGData
=
nullptr
;
void
nsCSSRendering
:
:
Init
(
)
{
NS_ASSERTION
(
!
gInlineBGData
"
Init
called
twice
"
)
;
gInlineBGData
=
new
InlineBackgroundData
(
)
;
}
void
nsCSSRendering
:
:
Shutdown
(
)
{
delete
gInlineBGData
;
gInlineBGData
=
nullptr
;
}
static
nscolor
MakeBevelColor
(
mozilla
:
:
Side
whichSide
StyleBorderStyle
style
nscolor
aBorderColor
)
{
nscolor
colors
[
2
]
;
nscolor
theColor
;
NS_GetSpecial3DColors
(
colors
aBorderColor
)
;
if
(
(
style
=
=
StyleBorderStyle
:
:
Outset
)
|
|
(
style
=
=
StyleBorderStyle
:
:
Ridge
)
)
{
switch
(
whichSide
)
{
case
eSideBottom
:
whichSide
=
eSideTop
;
break
;
case
eSideRight
:
whichSide
=
eSideLeft
;
break
;
case
eSideTop
:
whichSide
=
eSideBottom
;
break
;
case
eSideLeft
:
whichSide
=
eSideRight
;
break
;
}
}
switch
(
whichSide
)
{
case
eSideBottom
:
theColor
=
colors
[
1
]
;
break
;
case
eSideRight
:
theColor
=
colors
[
1
]
;
break
;
case
eSideTop
:
theColor
=
colors
[
0
]
;
break
;
case
eSideLeft
:
default
:
theColor
=
colors
[
0
]
;
break
;
}
return
theColor
;
}
static
bool
GetRadii
(
nsIFrame
*
aForFrame
const
nsStyleBorder
&
aBorder
const
nsRect
&
aOrigBorderArea
const
nsRect
&
aBorderArea
nscoord
aRadii
[
8
]
)
{
bool
haveRoundedCorners
;
nsSize
sz
=
aBorderArea
.
Size
(
)
;
nsSize
frameSize
=
aForFrame
-
>
GetSize
(
)
;
if
(
&
aBorder
=
=
aForFrame
-
>
StyleBorder
(
)
&
&
frameSize
=
=
aOrigBorderArea
.
Size
(
)
)
{
haveRoundedCorners
=
aForFrame
-
>
GetBorderRadii
(
sz
sz
Sides
(
)
aRadii
)
;
}
else
{
haveRoundedCorners
=
nsIFrame
:
:
ComputeBorderRadii
(
aBorder
.
mBorderRadius
frameSize
sz
Sides
(
)
aRadii
)
;
}
return
haveRoundedCorners
;
}
static
bool
GetRadii
(
nsIFrame
*
aForFrame
const
nsStyleBorder
&
aBorder
const
nsRect
&
aOrigBorderArea
const
nsRect
&
aBorderArea
RectCornerRadii
*
aBgRadii
)
{
nscoord
radii
[
8
]
;
bool
haveRoundedCorners
=
GetRadii
(
aForFrame
aBorder
aOrigBorderArea
aBorderArea
radii
)
;
if
(
haveRoundedCorners
)
{
auto
d2a
=
aForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsCSSRendering
:
:
ComputePixelRadii
(
radii
d2a
aBgRadii
)
;
}
return
haveRoundedCorners
;
}
static
nsRect
JoinBoxesForBlockAxisSlice
(
nsIFrame
*
aFrame
const
nsRect
&
aBorderArea
)
{
nsRect
borderArea
=
aBorderArea
;
nscoord
bSize
=
0
;
auto
wm
=
aFrame
-
>
GetWritingMode
(
)
;
nsIFrame
*
f
=
aFrame
-
>
GetNextContinuation
(
)
;
for
(
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
MOZ_ASSERT
(
!
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
"
anonymous
ib
-
split
block
shouldn
'
t
have
border
/
background
"
)
;
bSize
+
=
f
-
>
BSize
(
wm
)
;
}
(
wm
.
IsVertical
(
)
?
borderArea
.
width
:
borderArea
.
height
)
+
=
bSize
;
bSize
=
0
;
f
=
aFrame
-
>
GetPrevContinuation
(
)
;
for
(
;
f
;
f
=
f
-
>
GetPrevContinuation
(
)
)
{
MOZ_ASSERT
(
!
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
"
anonymous
ib
-
split
block
shouldn
'
t
have
border
/
background
"
)
;
bSize
+
=
f
-
>
BSize
(
wm
)
;
}
(
wm
.
IsVertical
(
)
?
borderArea
.
x
:
borderArea
.
y
)
-
=
bSize
;
(
wm
.
IsVertical
(
)
?
borderArea
.
width
:
borderArea
.
height
)
+
=
bSize
;
return
borderArea
;
}
enum
InlineBoxOrder
{
eForBorder
eForBackground
}
;
static
nsRect
JoinBoxesForSlice
(
nsIFrame
*
aFrame
const
nsRect
&
aBorderArea
InlineBoxOrder
aOrder
)
{
if
(
static_cast
<
nsInlineFrame
*
>
(
do_QueryFrame
(
aFrame
)
)
)
{
return
(
aOrder
=
=
eForBorder
?
gInlineBGData
-
>
GetBorderContinuousRect
(
aFrame
aBorderArea
)
:
gInlineBGData
-
>
GetContinuousRect
(
aFrame
)
)
+
aBorderArea
.
TopLeft
(
)
;
}
return
JoinBoxesForBlockAxisSlice
(
aFrame
aBorderArea
)
;
}
bool
nsCSSRendering
:
:
IsBoxDecorationSlice
(
const
nsStyleBorder
&
aStyleBorder
)
{
return
aStyleBorder
.
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
;
}
nsRect
nsCSSRendering
:
:
BoxDecorationRectForBorder
(
nsIFrame
*
aFrame
const
nsRect
&
aBorderArea
Sides
aSkipSides
const
nsStyleBorder
*
aStyleBorder
)
{
if
(
!
aStyleBorder
)
{
aStyleBorder
=
aFrame
-
>
StyleBorder
(
)
;
}
return
IsBoxDecorationSlice
(
*
aStyleBorder
)
&
&
!
aSkipSides
.
IsEmpty
(
)
?
:
:
JoinBoxesForSlice
(
aFrame
aBorderArea
eForBorder
)
:
aBorderArea
;
}
nsRect
nsCSSRendering
:
:
BoxDecorationRectForBackground
(
nsIFrame
*
aFrame
const
nsRect
&
aBorderArea
Sides
aSkipSides
const
nsStyleBorder
*
aStyleBorder
)
{
if
(
!
aStyleBorder
)
{
aStyleBorder
=
aFrame
-
>
StyleBorder
(
)
;
}
return
IsBoxDecorationSlice
(
*
aStyleBorder
)
&
&
!
aSkipSides
.
IsEmpty
(
)
?
:
:
JoinBoxesForSlice
(
aFrame
aBorderArea
eForBackground
)
:
aBorderArea
;
}
void
nsCSSRendering
:
:
ComputePixelRadii
(
const
nscoord
*
aAppUnitsRadii
nscoord
aAppUnitsPerPixel
RectCornerRadii
*
oBorderRadii
)
{
Float
radii
[
8
]
;
NS_FOR_CSS_HALF_CORNERS
(
corner
)
radii
[
corner
]
=
Float
(
aAppUnitsRadii
[
corner
]
)
/
aAppUnitsPerPixel
;
(
*
oBorderRadii
)
[
C_TL
]
=
Size
(
radii
[
eCornerTopLeftX
]
radii
[
eCornerTopLeftY
]
)
;
(
*
oBorderRadii
)
[
C_TR
]
=
Size
(
radii
[
eCornerTopRightX
]
radii
[
eCornerTopRightY
]
)
;
(
*
oBorderRadii
)
[
C_BR
]
=
Size
(
radii
[
eCornerBottomRightX
]
radii
[
eCornerBottomRightY
]
)
;
(
*
oBorderRadii
)
[
C_BL
]
=
Size
(
radii
[
eCornerBottomLeftX
]
radii
[
eCornerBottomLeftY
]
)
;
}
ImgDrawResult
nsCSSRendering
:
:
PaintBorder
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
ComputedStyle
*
aComputedStyle
PaintBorderFlags
aFlags
Sides
aSkipSides
)
{
AUTO_PROFILER_LABEL
(
"
nsCSSRendering
:
:
PaintBorder
"
GRAPHICS
)
;
ComputedStyle
*
styleIfVisited
=
aComputedStyle
-
>
GetStyleIfVisited
(
)
;
const
nsStyleBorder
*
styleBorder
=
aComputedStyle
-
>
StyleBorder
(
)
;
if
(
!
styleIfVisited
)
{
return
PaintBorderWithStyleBorder
(
aPresContext
aRenderingContext
aForFrame
aDirtyRect
aBorderArea
*
styleBorder
aComputedStyle
aFlags
aSkipSides
)
;
}
nsStyleBorder
newStyleBorder
(
*
styleBorder
)
;
NS_FOR_CSS_SIDES
(
side
)
{
nscolor
color
=
aComputedStyle
-
>
GetVisitedDependentColor
(
nsStyleBorder
:
:
BorderColorFieldFor
(
side
)
)
;
newStyleBorder
.
BorderColorFor
(
side
)
=
StyleComplexColor
:
:
FromColor
(
color
)
;
}
return
PaintBorderWithStyleBorder
(
aPresContext
aRenderingContext
aForFrame
aDirtyRect
aBorderArea
newStyleBorder
aComputedStyle
aFlags
aSkipSides
)
;
}
Maybe
<
nsCSSBorderRenderer
>
nsCSSRendering
:
:
CreateBorderRenderer
(
nsPresContext
*
aPresContext
DrawTarget
*
aDrawTarget
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
ComputedStyle
*
aComputedStyle
bool
*
aOutBorderIsEmpty
Sides
aSkipSides
)
{
ComputedStyle
*
styleIfVisited
=
aComputedStyle
-
>
GetStyleIfVisited
(
)
;
const
nsStyleBorder
*
styleBorder
=
aComputedStyle
-
>
StyleBorder
(
)
;
if
(
!
styleIfVisited
)
{
return
CreateBorderRendererWithStyleBorder
(
aPresContext
aDrawTarget
aForFrame
aDirtyRect
aBorderArea
*
styleBorder
aComputedStyle
aOutBorderIsEmpty
aSkipSides
)
;
}
nsStyleBorder
newStyleBorder
(
*
styleBorder
)
;
NS_FOR_CSS_SIDES
(
side
)
{
nscolor
color
=
aComputedStyle
-
>
GetVisitedDependentColor
(
nsStyleBorder
:
:
BorderColorFieldFor
(
side
)
)
;
newStyleBorder
.
BorderColorFor
(
side
)
=
StyleComplexColor
:
:
FromColor
(
color
)
;
}
return
CreateBorderRendererWithStyleBorder
(
aPresContext
aDrawTarget
aForFrame
aDirtyRect
aBorderArea
newStyleBorder
aComputedStyle
aOutBorderIsEmpty
aSkipSides
)
;
}
ImgDrawResult
nsCSSRendering
:
:
CreateWebRenderCommandsForBorder
(
nsDisplayItem
*
aItem
nsIFrame
*
aForFrame
const
nsRect
&
aBorderArea
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
const
nsStyleBorder
*
styleBorder
=
aForFrame
-
>
Style
(
)
-
>
StyleBorder
(
)
;
return
nsCSSRendering
:
:
CreateWebRenderCommandsForBorderWithStyleBorder
(
aItem
aForFrame
aBorderArea
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
*
styleBorder
)
;
}
ImgDrawResult
nsCSSRendering
:
:
CreateWebRenderCommandsForBorderWithStyleBorder
(
nsDisplayItem
*
aItem
nsIFrame
*
aForFrame
const
nsRect
&
aBorderArea
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
const
nsStyleBorder
&
aStyleBorder
)
{
{
bool
borderIsEmpty
=
false
;
Maybe
<
nsCSSBorderRenderer
>
br
=
nsCSSRendering
:
:
CreateBorderRendererWithStyleBorder
(
aForFrame
-
>
PresContext
(
)
nullptr
aForFrame
nsRect
(
)
aBorderArea
aStyleBorder
aForFrame
-
>
Style
(
)
&
borderIsEmpty
aForFrame
-
>
GetSkipSides
(
)
)
;
if
(
borderIsEmpty
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
if
(
br
)
{
br
-
>
CreateWebRenderCommands
(
aItem
aBuilder
aResources
aSc
)
;
return
ImgDrawResult
:
:
SUCCESS
;
}
}
const
nsStyleImage
*
image
=
&
aStyleBorder
.
mBorderImageSource
;
if
(
!
image
)
{
return
ImgDrawResult
:
:
NOT_SUPPORTED
;
}
bool
imageTypeSupported
=
false
;
if
(
!
imageTypeSupported
)
{
return
ImgDrawResult
:
:
NOT_SUPPORTED
;
}
if
(
aStyleBorder
.
mBorderImageRepeatH
=
=
StyleBorderImageRepeat
:
:
Round
|
|
aStyleBorder
.
mBorderImageRepeatH
=
=
StyleBorderImageRepeat
:
:
Space
|
|
aStyleBorder
.
mBorderImageRepeatV
=
=
StyleBorderImageRepeat
:
:
Round
|
|
aStyleBorder
.
mBorderImageRepeatV
=
=
StyleBorderImageRepeat
:
:
Space
)
{
return
ImgDrawResult
:
:
NOT_SUPPORTED
;
}
uint32_t
flags
=
0
;
if
(
aDisplayListBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
flags
|
=
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
;
}
image
:
:
ImgDrawResult
result
;
Maybe
<
nsCSSBorderImageRenderer
>
bir
=
nsCSSBorderImageRenderer
:
:
CreateBorderImageRenderer
(
aForFrame
-
>
PresContext
(
)
aForFrame
aBorderArea
aStyleBorder
aItem
-
>
GetPaintRect
(
)
aForFrame
-
>
GetSkipSides
(
)
flags
&
result
)
;
if
(
!
bir
)
{
return
result
;
}
return
bir
-
>
CreateWebRenderCommands
(
aItem
aForFrame
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
)
;
}
static
nsCSSBorderRenderer
ConstructBorderRenderer
(
nsPresContext
*
aPresContext
ComputedStyle
*
aComputedStyle
DrawTarget
*
aDrawTarget
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
const
nsStyleBorder
&
aStyleBorder
Sides
aSkipSides
bool
*
aNeedsClip
)
{
nsMargin
border
=
aStyleBorder
.
GetComputedBorder
(
)
;
nsRect
joinedBorderArea
=
nsCSSRendering
:
:
BoxDecorationRectForBorder
(
aForFrame
aBorderArea
aSkipSides
&
aStyleBorder
)
;
RectCornerRadii
bgRadii
;
:
:
GetRadii
(
aForFrame
aStyleBorder
aBorderArea
joinedBorderArea
&
bgRadii
)
;
PrintAsFormatString
(
"
joinedBorderArea
:
%
d
%
d
%
d
%
d
\
n
"
joinedBorderArea
.
x
joinedBorderArea
.
y
joinedBorderArea
.
width
joinedBorderArea
.
height
)
;
if
(
nsCSSRendering
:
:
IsBoxDecorationSlice
(
aStyleBorder
)
)
{
if
(
joinedBorderArea
.
IsEqualEdges
(
aBorderArea
)
)
{
border
.
ApplySkipSides
(
aSkipSides
)
;
}
else
{
*
aNeedsClip
=
true
;
}
}
else
{
MOZ_ASSERT
(
joinedBorderArea
.
IsEqualEdges
(
aBorderArea
)
"
Should
use
aBorderArea
for
box
-
decoration
-
break
:
clone
"
)
;
MOZ_ASSERT
(
aForFrame
-
>
GetSkipSides
(
)
.
IsEmpty
(
)
|
|
IS_TRUE_OVERFLOW_CONTAINER
(
aForFrame
)
|
|
aForFrame
-
>
IsColumnSetFrame
(
)
"
Should
not
skip
sides
for
box
-
decoration
-
break
:
clone
except
"
"
:
:
first
-
letter
/
line
continuations
or
other
frame
types
that
"
"
don
'
t
have
borders
but
those
shouldn
'
t
reach
this
point
.
"
"
Overflow
containers
do
reach
this
point
though
as
does
"
"
column
-
rule
drawing
(
which
always
involves
a
columnset
)
.
"
)
;
border
.
ApplySkipSides
(
aSkipSides
)
;
}
nscoord
oneDevPixel
=
aPresContext
-
>
DevPixelsToAppUnits
(
1
)
;
Rect
joinedBorderAreaPx
=
NSRectToRect
(
joinedBorderArea
oneDevPixel
)
;
Float
borderWidths
[
4
]
=
{
Float
(
border
.
top
)
/
oneDevPixel
Float
(
border
.
right
)
/
oneDevPixel
Float
(
border
.
bottom
)
/
oneDevPixel
Float
(
border
.
left
)
/
oneDevPixel
}
;
Rect
dirtyRect
=
NSRectToRect
(
aDirtyRect
oneDevPixel
)
;
StyleBorderStyle
borderStyles
[
4
]
;
nscolor
borderColors
[
4
]
;
NS_FOR_CSS_SIDES
(
i
)
{
borderStyles
[
i
]
=
aStyleBorder
.
GetBorderStyle
(
i
)
;
borderColors
[
i
]
=
aStyleBorder
.
BorderColorFor
(
i
)
.
CalcColor
(
aComputedStyle
)
;
}
PrintAsFormatString
(
"
borderStyles
:
%
d
%
d
%
d
%
d
\
n
"
static_cast
<
int
>
(
borderStyles
[
0
]
)
static_cast
<
int
>
(
borderStyles
[
1
]
)
static_cast
<
int
>
(
borderStyles
[
2
]
)
static_cast
<
int
>
(
borderStyles
[
3
]
)
)
;
Document
*
document
=
nullptr
;
nsIContent
*
content
=
aForFrame
-
>
GetContent
(
)
;
if
(
content
)
{
document
=
content
-
>
OwnerDoc
(
)
;
}
return
nsCSSBorderRenderer
(
aPresContext
document
aDrawTarget
dirtyRect
joinedBorderAreaPx
borderStyles
borderWidths
bgRadii
borderColors
!
aForFrame
-
>
BackfaceIsHidden
(
)
*
aNeedsClip
?
Some
(
NSRectToRect
(
aBorderArea
oneDevPixel
)
)
:
Nothing
(
)
)
;
}
ImgDrawResult
nsCSSRendering
:
:
PaintBorderWithStyleBorder
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
const
nsStyleBorder
&
aStyleBorder
ComputedStyle
*
aComputedStyle
PaintBorderFlags
aFlags
Sides
aSkipSides
)
{
DrawTarget
&
aDrawTarget
=
*
aRenderingContext
.
GetDrawTarget
(
)
;
PrintAsStringNewline
(
"
+
+
PaintBorder
"
)
;
const
nsStyleDisplay
*
displayData
=
aComputedStyle
-
>
StyleDisplay
(
)
;
if
(
displayData
-
>
HasAppearance
(
)
)
{
nsITheme
*
theme
=
aPresContext
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
aPresContext
aForFrame
displayData
-
>
mAppearance
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
}
if
(
!
aStyleBorder
.
mBorderImageSource
.
IsEmpty
(
)
)
{
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
uint32_t
irFlags
=
0
;
if
(
aFlags
&
PaintBorderFlags
:
:
SYNC_DECODE_IMAGES
)
{
irFlags
|
=
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
;
}
Maybe
<
nsCSSBorderImageRenderer
>
renderer
=
nsCSSBorderImageRenderer
:
:
CreateBorderImageRenderer
(
aPresContext
aForFrame
aBorderArea
aStyleBorder
aDirtyRect
aSkipSides
irFlags
&
result
)
;
if
(
renderer
)
{
MOZ_ASSERT
(
result
=
=
ImgDrawResult
:
:
SUCCESS
)
;
return
renderer
-
>
DrawBorderImage
(
aPresContext
aRenderingContext
aForFrame
aDirtyRect
)
;
}
}
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
if
(
aStyleBorder
.
mBorderImageSource
.
GetType
(
)
!
=
eStyleImageType_Null
)
{
result
=
ImgDrawResult
:
:
NOT_READY
;
}
nsMargin
border
=
aStyleBorder
.
GetComputedBorder
(
)
;
if
(
0
=
=
border
.
left
&
&
0
=
=
border
.
right
&
&
0
=
=
border
.
top
&
&
0
=
=
border
.
bottom
)
{
return
result
;
}
bool
needsClip
=
false
;
nsCSSBorderRenderer
br
=
ConstructBorderRenderer
(
aPresContext
aComputedStyle
&
aDrawTarget
aForFrame
aDirtyRect
aBorderArea
aStyleBorder
aSkipSides
&
needsClip
)
;
if
(
needsClip
)
{
aDrawTarget
.
PushClipRect
(
NSRectToSnappedRect
(
aBorderArea
aForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
aDrawTarget
)
)
;
}
br
.
DrawBorders
(
)
;
if
(
needsClip
)
{
aDrawTarget
.
PopClip
(
)
;
}
PrintAsStringNewline
(
)
;
return
result
;
}
Maybe
<
nsCSSBorderRenderer
>
nsCSSRendering
:
:
CreateBorderRendererWithStyleBorder
(
nsPresContext
*
aPresContext
DrawTarget
*
aDrawTarget
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
const
nsStyleBorder
&
aStyleBorder
ComputedStyle
*
aComputedStyle
bool
*
aOutBorderIsEmpty
Sides
aSkipSides
)
{
const
nsStyleDisplay
*
displayData
=
aComputedStyle
-
>
StyleDisplay
(
)
;
if
(
displayData
-
>
HasAppearance
(
)
)
{
nsITheme
*
theme
=
aPresContext
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
aPresContext
aForFrame
displayData
-
>
mAppearance
)
)
{
return
Nothing
(
)
;
}
}
if
(
aStyleBorder
.
mBorderImageSource
.
GetType
(
)
!
=
eStyleImageType_Null
)
{
return
Nothing
(
)
;
}
nsMargin
border
=
aStyleBorder
.
GetComputedBorder
(
)
;
if
(
0
=
=
border
.
left
&
&
0
=
=
border
.
right
&
&
0
=
=
border
.
top
&
&
0
=
=
border
.
bottom
)
{
if
(
aOutBorderIsEmpty
)
{
*
aOutBorderIsEmpty
=
true
;
}
return
Nothing
(
)
;
}
bool
needsClip
=
false
;
nsCSSBorderRenderer
br
=
ConstructBorderRenderer
(
aPresContext
aComputedStyle
aDrawTarget
aForFrame
aDirtyRect
aBorderArea
aStyleBorder
aSkipSides
&
needsClip
)
;
return
Some
(
br
)
;
}
static
nsRect
GetOutlineInnerRect
(
nsIFrame
*
aFrame
)
{
nsRect
*
savedOutlineInnerRect
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
OutlineInnerRectProperty
(
)
)
;
if
(
savedOutlineInnerRect
)
{
return
*
savedOutlineInnerRect
;
}
NS_ERROR
(
"
we
should
have
saved
a
frame
property
"
)
;
return
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
;
}
Maybe
<
nsCSSBorderRenderer
>
nsCSSRendering
:
:
CreateBorderRendererForOutline
(
nsPresContext
*
aPresContext
gfxContext
*
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
ComputedStyle
*
aComputedStyle
)
{
nscoord
twipsRadii
[
8
]
;
const
nsStyleOutline
*
ourOutline
=
aComputedStyle
-
>
StyleOutline
(
)
;
if
(
!
ourOutline
-
>
ShouldPaintOutline
(
)
)
{
return
Nothing
(
)
;
}
nsRect
innerRect
;
if
(
#
ifdef
MOZ_XUL
aComputedStyle
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
XULTree
#
else
false
#
endif
)
{
innerRect
=
aBorderArea
;
}
else
{
innerRect
=
GetOutlineInnerRect
(
aForFrame
)
+
aBorderArea
.
TopLeft
(
)
;
}
nscoord
offset
=
ourOutline
-
>
mOutlineOffset
;
innerRect
.
Inflate
(
offset
offset
)
;
if
(
innerRect
.
Contains
(
aDirtyRect
)
)
return
Nothing
(
)
;
nscoord
width
=
ourOutline
-
>
GetOutlineWidth
(
)
;
nsRect
outerRect
=
innerRect
;
outerRect
.
Inflate
(
width
width
)
;
nsIFrame
:
:
ComputeBorderRadii
(
ourOutline
-
>
mOutlineRadius
aBorderArea
.
Size
(
)
outerRect
.
Size
(
)
Sides
(
)
twipsRadii
)
;
nscoord
oneDevPixel
=
aPresContext
-
>
DevPixelsToAppUnits
(
1
)
;
Rect
oRect
(
NSRectToRect
(
outerRect
oneDevPixel
)
)
;
nsMargin
outlineMargin
(
width
width
width
width
)
;
RectCornerRadii
outlineRadii
;
ComputePixelRadii
(
twipsRadii
oneDevPixel
&
outlineRadii
)
;
StyleBorderStyle
outlineStyle
;
if
(
ourOutline
-
>
mOutlineStyle
.
IsAuto
(
)
)
{
if
(
nsLayoutUtils
:
:
IsOutlineStyleAutoEnabled
(
)
)
{
nsITheme
*
theme
=
aPresContext
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
aPresContext
aForFrame
StyleAppearance
:
:
FocusOutline
)
)
{
theme
-
>
DrawWidgetBackground
(
aRenderingContext
aForFrame
StyleAppearance
:
:
FocusOutline
innerRect
aDirtyRect
)
;
return
Nothing
(
)
;
}
}
if
(
width
=
=
0
)
{
return
Nothing
(
)
;
}
outlineStyle
=
StyleBorderStyle
:
:
Solid
;
}
else
{
MOZ_ASSERT
(
ourOutline
-
>
mOutlineStyle
.
IsBorderStyle
(
)
)
;
outlineStyle
=
ourOutline
-
>
mOutlineStyle
.
border_style
.
_0
;
}
StyleBorderStyle
outlineStyles
[
4
]
=
{
outlineStyle
outlineStyle
outlineStyle
outlineStyle
}
;
nscolor
outlineColor
=
aComputedStyle
-
>
GetVisitedDependentColor
(
&
nsStyleOutline
:
:
mOutlineColor
)
;
nscolor
outlineColors
[
4
]
=
{
outlineColor
outlineColor
outlineColor
outlineColor
}
;
Float
outlineWidths
[
4
]
=
{
Float
(
width
)
/
oneDevPixel
Float
(
width
)
/
oneDevPixel
Float
(
width
)
/
oneDevPixel
Float
(
width
)
/
oneDevPixel
}
;
Rect
dirtyRect
=
NSRectToRect
(
aDirtyRect
oneDevPixel
)
;
Document
*
document
=
nullptr
;
nsIContent
*
content
=
aForFrame
-
>
GetContent
(
)
;
if
(
content
)
{
document
=
content
-
>
OwnerDoc
(
)
;
}
DrawTarget
*
dt
=
aRenderingContext
?
aRenderingContext
-
>
GetDrawTarget
(
)
:
nullptr
;
nsCSSBorderRenderer
br
(
aPresContext
document
dt
dirtyRect
oRect
outlineStyles
outlineWidths
outlineRadii
outlineColors
!
aForFrame
-
>
BackfaceIsHidden
(
)
Nothing
(
)
)
;
return
Some
(
br
)
;
}
void
nsCSSRendering
:
:
PaintOutline
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
ComputedStyle
*
aComputedStyle
)
{
Maybe
<
nsCSSBorderRenderer
>
br
=
CreateBorderRendererForOutline
(
aPresContext
&
aRenderingContext
aForFrame
aDirtyRect
aBorderArea
aComputedStyle
)
;
if
(
!
br
)
{
return
;
}
br
-
>
DrawBorders
(
)
;
PrintAsStringNewline
(
)
;
}
void
nsCSSRendering
:
:
PaintFocus
(
nsPresContext
*
aPresContext
DrawTarget
*
aDrawTarget
const
nsRect
&
aFocusRect
nscolor
aColor
)
{
nscoord
oneCSSPixel
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
nscoord
oneDevPixel
=
aPresContext
-
>
DevPixelsToAppUnits
(
1
)
;
Rect
focusRect
(
NSRectToRect
(
aFocusRect
oneDevPixel
)
)
;
RectCornerRadii
focusRadii
;
{
nscoord
twipsRadii
[
8
]
=
{
0
0
0
0
0
0
0
0
}
;
ComputePixelRadii
(
twipsRadii
oneDevPixel
&
focusRadii
)
;
}
Float
focusWidths
[
4
]
=
{
Float
(
oneCSSPixel
)
/
oneDevPixel
Float
(
oneCSSPixel
)
/
oneDevPixel
Float
(
oneCSSPixel
)
/
oneDevPixel
Float
(
oneCSSPixel
)
/
oneDevPixel
}
;
StyleBorderStyle
focusStyles
[
4
]
=
{
StyleBorderStyle
:
:
Dotted
StyleBorderStyle
:
:
Dotted
StyleBorderStyle
:
:
Dotted
StyleBorderStyle
:
:
Dotted
}
;
nscolor
focusColors
[
4
]
=
{
aColor
aColor
aColor
aColor
}
;
nsCSSBorderRenderer
br
(
aPresContext
nullptr
aDrawTarget
focusRect
focusRect
focusStyles
focusWidths
focusRadii
focusColors
true
Nothing
(
)
)
;
br
.
DrawBorders
(
)
;
PrintAsStringNewline
(
)
;
}
static
void
ComputeObjectAnchorCoord
(
const
LengthPercentage
&
aCoord
const
nscoord
aOriginBounds
const
nscoord
aImageSize
nscoord
*
aTopLeftCoord
nscoord
*
aAnchorPointCoord
)
{
nscoord
extraSpace
=
aOriginBounds
-
aImageSize
;
*
aAnchorPointCoord
=
aCoord
.
Resolve
(
aOriginBounds
NSToCoordRoundWithClamp
)
;
*
aTopLeftCoord
=
aCoord
.
Resolve
(
extraSpace
NSToCoordRoundWithClamp
)
;
}
void
nsImageRenderer
:
:
ComputeObjectAnchorPoint
(
const
Position
&
aPos
const
nsSize
&
aOriginBounds
const
nsSize
&
aImageSize
nsPoint
*
aTopLeft
nsPoint
*
aAnchorPoint
)
{
ComputeObjectAnchorCoord
(
aPos
.
horizontal
aOriginBounds
.
width
aImageSize
.
width
&
aTopLeft
-
>
x
&
aAnchorPoint
-
>
x
)
;
ComputeObjectAnchorCoord
(
aPos
.
vertical
aOriginBounds
.
height
aImageSize
.
height
&
aTopLeft
-
>
y
&
aAnchorPoint
-
>
y
)
;
}
nsIFrame
*
nsCSSRendering
:
:
FindNonTransparentBackgroundFrame
(
nsIFrame
*
aFrame
bool
aStartAtParent
)
{
NS_ASSERTION
(
aFrame
"
Cannot
find
NonTransparentBackgroundFrame
in
a
null
frame
"
)
;
nsIFrame
*
frame
=
nullptr
;
if
(
aStartAtParent
)
{
frame
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
aFrame
)
;
}
if
(
!
frame
)
{
frame
=
aFrame
;
}
while
(
frame
)
{
if
(
NS_GET_A
(
frame
-
>
StyleBackground
(
)
-
>
BackgroundColor
(
frame
)
)
>
0
)
{
break
;
}
if
(
frame
-
>
IsThemed
(
)
)
break
;
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
frame
)
;
if
(
!
parent
)
break
;
frame
=
parent
;
}
return
frame
;
}
bool
nsCSSRendering
:
:
IsCanvasFrame
(
nsIFrame
*
aFrame
)
{
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
return
frameType
=
=
LayoutFrameType
:
:
Canvas
|
|
frameType
=
=
LayoutFrameType
:
:
Root
|
|
frameType
=
=
LayoutFrameType
:
:
PageContent
|
|
frameType
=
=
LayoutFrameType
:
:
Viewport
;
}
nsIFrame
*
nsCSSRendering
:
:
FindBackgroundStyleFrame
(
nsIFrame
*
aForFrame
)
{
const
nsStyleBackground
*
result
=
aForFrame
-
>
StyleBackground
(
)
;
if
(
!
result
-
>
IsTransparent
(
aForFrame
)
)
{
return
aForFrame
;
}
nsIContent
*
content
=
aForFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
aForFrame
;
}
Document
*
document
=
content
-
>
OwnerDoc
(
)
;
dom
:
:
Element
*
bodyContent
=
document
-
>
GetBodyElement
(
)
;
if
(
!
bodyContent
)
{
return
aForFrame
;
}
nsIFrame
*
bodyFrame
=
bodyContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
bodyFrame
)
{
return
aForFrame
;
}
return
nsLayoutUtils
:
:
GetStyleFrame
(
bodyFrame
)
;
}
ComputedStyle
*
nsCSSRendering
:
:
FindRootFrameBackground
(
nsIFrame
*
aForFrame
)
{
return
FindBackgroundStyleFrame
(
aForFrame
)
-
>
Style
(
)
;
}
inline
bool
FindElementBackground
(
nsIFrame
*
aForFrame
nsIFrame
*
aRootElementFrame
)
{
if
(
aForFrame
=
=
aRootElementFrame
)
{
return
false
;
}
nsIContent
*
content
=
aForFrame
-
>
GetContent
(
)
;
if
(
!
content
|
|
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
!
=
nsGkAtoms
:
:
body
)
return
true
;
if
(
aForFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
)
return
true
;
Document
*
document
=
content
-
>
OwnerDoc
(
)
;
dom
:
:
Element
*
bodyContent
=
document
-
>
GetBodyElement
(
)
;
if
(
bodyContent
!
=
content
)
return
true
;
if
(
!
aRootElementFrame
)
return
true
;
const
nsStyleBackground
*
htmlBG
=
aRootElementFrame
-
>
StyleBackground
(
)
;
return
!
htmlBG
-
>
IsTransparent
(
aRootElementFrame
)
;
}
bool
nsCSSRendering
:
:
FindBackgroundFrame
(
nsIFrame
*
aForFrame
nsIFrame
*
*
aBackgroundFrame
)
{
nsIFrame
*
rootElementFrame
=
aForFrame
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
GetRootElementStyleFrame
(
)
;
if
(
IsCanvasFrame
(
aForFrame
)
)
{
*
aBackgroundFrame
=
FindCanvasBackgroundFrame
(
aForFrame
rootElementFrame
)
;
return
true
;
}
*
aBackgroundFrame
=
aForFrame
;
return
FindElementBackground
(
aForFrame
rootElementFrame
)
;
}
bool
nsCSSRendering
:
:
FindBackground
(
nsIFrame
*
aForFrame
ComputedStyle
*
*
aBackgroundSC
)
{
nsIFrame
*
backgroundFrame
=
nullptr
;
if
(
FindBackgroundFrame
(
aForFrame
&
backgroundFrame
)
)
{
*
aBackgroundSC
=
backgroundFrame
-
>
Style
(
)
;
return
true
;
}
return
false
;
}
void
nsCSSRendering
:
:
BeginFrameTreesLocked
(
)
{
+
+
gFrameTreeLockCount
;
}
void
nsCSSRendering
:
:
EndFrameTreesLocked
(
)
{
NS_ASSERTION
(
gFrameTreeLockCount
>
0
"
Unbalanced
EndFrameTreeLocked
"
)
;
-
-
gFrameTreeLockCount
;
if
(
gFrameTreeLockCount
=
=
0
)
{
gInlineBGData
-
>
Reset
(
)
;
}
}
bool
nsCSSRendering
:
:
HasBoxShadowNativeTheme
(
nsIFrame
*
aFrame
bool
&
aMaybeHasBorderRadius
)
{
const
nsStyleDisplay
*
styleDisplay
=
aFrame
-
>
StyleDisplay
(
)
;
nsITheme
:
:
Transparency
transparency
;
if
(
aFrame
-
>
IsThemed
(
styleDisplay
&
transparency
)
)
{
aMaybeHasBorderRadius
=
false
;
return
transparency
!
=
nsITheme
:
:
eOpaque
;
}
aMaybeHasBorderRadius
=
true
;
return
false
;
}
gfx
:
:
Color
nsCSSRendering
:
:
GetShadowColor
(
nsCSSShadowItem
*
aShadow
nsIFrame
*
aFrame
float
aOpacity
)
{
nscolor
shadowColor
=
aShadow
-
>
mColor
.
CalcColor
(
aFrame
)
;
Color
color
=
Color
:
:
FromABGR
(
shadowColor
)
;
color
.
a
*
=
aOpacity
;
return
color
;
}
nsRect
nsCSSRendering
:
:
GetShadowRect
(
const
nsRect
&
aFrameArea
bool
aNativeTheme
nsIFrame
*
aForFrame
)
{
nsRect
frameRect
=
aNativeTheme
?
aForFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
aFrameArea
.
TopLeft
(
)
:
aFrameArea
;
Sides
skipSides
=
aForFrame
-
>
GetSkipSides
(
)
;
frameRect
=
BoxDecorationRectForBorder
(
aForFrame
frameRect
skipSides
)
;
return
frameRect
;
}
bool
nsCSSRendering
:
:
GetBorderRadii
(
const
nsRect
&
aFrameRect
const
nsRect
&
aBorderRect
nsIFrame
*
aFrame
RectCornerRadii
&
aOutRadii
)
{
const
nscoord
oneDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
DevPixelsToAppUnits
(
1
)
;
nscoord
twipsRadii
[
8
]
;
NS_ASSERTION
(
aBorderRect
.
Size
(
)
=
=
aFrame
-
>
VisualBorderRectRelativeToSelf
(
)
.
Size
(
)
"
unexpected
size
"
)
;
nsSize
sz
=
aFrameRect
.
Size
(
)
;
bool
hasBorderRadius
=
aFrame
-
>
GetBorderRadii
(
sz
sz
Sides
(
)
twipsRadii
)
;
if
(
hasBorderRadius
)
{
ComputePixelRadii
(
twipsRadii
oneDevPixel
&
aOutRadii
)
;
}
return
hasBorderRadius
;
}
void
nsCSSRendering
:
:
PaintBoxShadowOuter
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aFrameArea
const
nsRect
&
aDirtyRect
float
aOpacity
)
{
DrawTarget
&
aDrawTarget
=
*
aRenderingContext
.
GetDrawTarget
(
)
;
nsCSSShadowArray
*
shadows
=
aForFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
;
if
(
!
shadows
)
return
;
bool
hasBorderRadius
;
bool
nativeTheme
=
HasBoxShadowNativeTheme
(
aForFrame
hasBorderRadius
)
;
const
nsStyleDisplay
*
styleDisplay
=
aForFrame
-
>
StyleDisplay
(
)
;
nsRect
frameRect
=
GetShadowRect
(
aFrameArea
nativeTheme
aForFrame
)
;
RectCornerRadii
borderRadii
;
const
nscoord
oneDevPixel
=
aPresContext
-
>
DevPixelsToAppUnits
(
1
)
;
if
(
hasBorderRadius
)
{
nscoord
twipsRadii
[
8
]
;
NS_ASSERTION
(
aFrameArea
.
Size
(
)
=
=
aForFrame
-
>
VisualBorderRectRelativeToSelf
(
)
.
Size
(
)
"
unexpected
size
"
)
;
nsSize
sz
=
frameRect
.
Size
(
)
;
hasBorderRadius
=
aForFrame
-
>
GetBorderRadii
(
sz
sz
Sides
(
)
twipsRadii
)
;
if
(
hasBorderRadius
)
{
ComputePixelRadii
(
twipsRadii
oneDevPixel
&
borderRadii
)
;
}
}
gfxRect
skipGfxRect
=
ThebesRect
(
NSRectToRect
(
frameRect
oneDevPixel
)
)
;
skipGfxRect
.
Round
(
)
;
bool
useSkipGfxRect
=
true
;
if
(
nativeTheme
)
{
useSkipGfxRect
=
!
aForFrame
-
>
IsLeaf
(
)
;
nsRect
paddingRect
=
aForFrame
-
>
GetPaddingRectRelativeToSelf
(
)
+
aFrameArea
.
TopLeft
(
)
;
skipGfxRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
paddingRect
oneDevPixel
)
;
}
else
if
(
hasBorderRadius
)
{
skipGfxRect
.
Deflate
(
gfxMargin
(
std
:
:
max
(
borderRadii
[
C_TL
]
.
height
borderRadii
[
C_TR
]
.
height
)
0
std
:
:
max
(
borderRadii
[
C_BL
]
.
height
borderRadii
[
C_BR
]
.
height
)
0
)
)
;
}
for
(
uint32_t
i
=
shadows
-
>
Length
(
)
;
i
>
0
;
-
-
i
)
{
nsCSSShadowItem
*
shadowItem
=
shadows
-
>
ShadowAt
(
i
-
1
)
;
if
(
shadowItem
-
>
mInset
)
continue
;
nsRect
shadowRect
=
frameRect
;
shadowRect
.
MoveBy
(
shadowItem
-
>
mXOffset
shadowItem
-
>
mYOffset
)
;
if
(
!
nativeTheme
)
{
shadowRect
.
Inflate
(
shadowItem
-
>
mSpread
shadowItem
-
>
mSpread
)
;
}
nsRect
shadowRectPlusBlur
=
shadowRect
;
nscoord
blurRadius
=
shadowItem
-
>
mRadius
;
shadowRectPlusBlur
.
Inflate
(
nsContextBoxBlur
:
:
GetBlurRadiusMargin
(
blurRadius
oneDevPixel
)
)
;
Rect
shadowGfxRectPlusBlur
=
NSRectToRect
(
shadowRectPlusBlur
oneDevPixel
)
;
shadowGfxRectPlusBlur
.
RoundOut
(
)
;
MaybeSnapToDevicePixels
(
shadowGfxRectPlusBlur
aDrawTarget
true
)
;
Color
gfxShadowColor
=
GetShadowColor
(
shadowItem
aForFrame
aOpacity
)
;
if
(
nativeTheme
)
{
nsContextBoxBlur
blurringArea
;
gfxContext
*
shadowContext
=
blurringArea
.
Init
(
shadowRect
shadowItem
-
>
mSpread
blurRadius
oneDevPixel
&
aRenderingContext
aDirtyRect
useSkipGfxRect
?
&
skipGfxRect
:
nullptr
nsContextBoxBlur
:
:
FORCE_MASK
)
;
if
(
!
shadowContext
)
continue
;
MOZ_ASSERT
(
shadowContext
=
=
blurringArea
.
GetContext
(
)
)
;
aRenderingContext
.
Save
(
)
;
aRenderingContext
.
SetColor
(
gfxShadowColor
)
;
gfxContextMatrixAutoSaveRestore
save
(
shadowContext
)
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
nsPoint
(
shadowItem
-
>
mXOffset
shadowItem
-
>
mYOffset
)
aPresContext
-
>
AppUnitsPerDevPixel
(
)
)
;
shadowContext
-
>
SetMatrixDouble
(
shadowContext
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
devPixelOffset
)
)
;
nsRect
nativeRect
=
aDirtyRect
;
nativeRect
.
MoveBy
(
-
nsPoint
(
shadowItem
-
>
mXOffset
shadowItem
-
>
mYOffset
)
)
;
nativeRect
.
IntersectRect
(
frameRect
nativeRect
)
;
aPresContext
-
>
GetTheme
(
)
-
>
DrawWidgetBackground
(
shadowContext
aForFrame
styleDisplay
-
>
mAppearance
aFrameArea
nativeRect
)
;
blurringArea
.
DoPaint
(
)
;
aRenderingContext
.
Restore
(
)
;
}
else
{
aRenderingContext
.
Save
(
)
;
{
Rect
innerClipRect
=
NSRectToRect
(
frameRect
oneDevPixel
)
;
if
(
!
MaybeSnapToDevicePixels
(
innerClipRect
aDrawTarget
true
)
)
{
innerClipRect
.
Round
(
)
;
}
RefPtr
<
PathBuilder
>
builder
=
aDrawTarget
.
CreatePathBuilder
(
FillRule
:
:
FILL_EVEN_ODD
)
;
AppendRectToPath
(
builder
shadowGfxRectPlusBlur
)
;
if
(
hasBorderRadius
)
{
AppendRoundedRectToPath
(
builder
innerClipRect
borderRadii
)
;
}
else
{
AppendRectToPath
(
builder
innerClipRect
)
;
}
RefPtr
<
Path
>
path
=
builder
-
>
Finish
(
)
;
aRenderingContext
.
Clip
(
path
)
;
}
nsRect
fragmentClip
=
shadowRectPlusBlur
;
Sides
skipSides
=
aForFrame
-
>
GetSkipSides
(
)
;
if
(
!
skipSides
.
IsEmpty
(
)
)
{
if
(
skipSides
.
Left
(
)
)
{
nscoord
xmost
=
fragmentClip
.
XMost
(
)
;
fragmentClip
.
x
=
aFrameArea
.
x
;
fragmentClip
.
width
=
xmost
-
fragmentClip
.
x
;
}
if
(
skipSides
.
Right
(
)
)
{
nscoord
xmost
=
fragmentClip
.
XMost
(
)
;
nscoord
overflow
=
xmost
-
aFrameArea
.
XMost
(
)
;
if
(
overflow
>
0
)
{
fragmentClip
.
width
-
=
overflow
;
}
}
if
(
skipSides
.
Top
(
)
)
{
nscoord
ymost
=
fragmentClip
.
YMost
(
)
;
fragmentClip
.
y
=
aFrameArea
.
y
;
fragmentClip
.
height
=
ymost
-
fragmentClip
.
y
;
}
if
(
skipSides
.
Bottom
(
)
)
{
nscoord
ymost
=
fragmentClip
.
YMost
(
)
;
nscoord
overflow
=
ymost
-
aFrameArea
.
YMost
(
)
;
if
(
overflow
>
0
)
{
fragmentClip
.
height
-
=
overflow
;
}
}
}
fragmentClip
=
fragmentClip
.
Intersect
(
aDirtyRect
)
;
aRenderingContext
.
Clip
(
NSRectToSnappedRect
(
fragmentClip
aForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
aDrawTarget
)
)
;
RectCornerRadii
clipRectRadii
;
if
(
hasBorderRadius
)
{
Float
spreadDistance
=
Float
(
shadowItem
-
>
mSpread
)
/
oneDevPixel
;
Float
borderSizes
[
4
]
;
borderSizes
[
eSideLeft
]
=
spreadDistance
;
borderSizes
[
eSideTop
]
=
spreadDistance
;
borderSizes
[
eSideRight
]
=
spreadDistance
;
borderSizes
[
eSideBottom
]
=
spreadDistance
;
nsCSSBorderRenderer
:
:
ComputeOuterRadii
(
borderRadii
borderSizes
&
clipRectRadii
)
;
}
nsContextBoxBlur
:
:
BlurRectangle
(
&
aRenderingContext
shadowRect
oneDevPixel
hasBorderRadius
?
&
clipRectRadii
:
nullptr
blurRadius
gfxShadowColor
aDirtyRect
skipGfxRect
)
;
aRenderingContext
.
Restore
(
)
;
}
}
}
nsRect
nsCSSRendering
:
:
GetBoxShadowInnerPaddingRect
(
nsIFrame
*
aFrame
const
nsRect
&
aFrameArea
)
{
Sides
skipSides
=
aFrame
-
>
GetSkipSides
(
)
;
nsRect
frameRect
=
BoxDecorationRectForBorder
(
aFrame
aFrameArea
skipSides
)
;
nsRect
paddingRect
=
frameRect
;
nsMargin
border
=
aFrame
-
>
GetUsedBorder
(
)
;
paddingRect
.
Deflate
(
border
)
;
return
paddingRect
;
}
bool
nsCSSRendering
:
:
ShouldPaintBoxShadowInner
(
nsIFrame
*
aFrame
)
{
nsCSSShadowArray
*
shadows
=
aFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
;
if
(
!
shadows
)
return
false
;
if
(
aFrame
-
>
IsThemed
(
)
&
&
aFrame
-
>
GetContent
(
)
&
&
!
nsContentUtils
:
:
IsChromeDoc
(
aFrame
-
>
GetContent
(
)
-
>
GetComposedDoc
(
)
)
)
{
return
false
;
}
return
true
;
}
bool
nsCSSRendering
:
:
GetShadowInnerRadii
(
nsIFrame
*
aFrame
const
nsRect
&
aFrameArea
RectCornerRadii
&
aOutInnerRadii
)
{
nscoord
twipsRadii
[
8
]
;
nsRect
frameRect
=
BoxDecorationRectForBorder
(
aFrame
aFrameArea
aFrame
-
>
GetSkipSides
(
)
)
;
nsSize
sz
=
frameRect
.
Size
(
)
;
nsMargin
border
=
aFrame
-
>
GetUsedBorder
(
)
;
aFrame
-
>
GetBorderRadii
(
sz
sz
Sides
(
)
twipsRadii
)
;
const
nscoord
oneDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
DevPixelsToAppUnits
(
1
)
;
RectCornerRadii
borderRadii
;
const
bool
hasBorderRadius
=
GetBorderRadii
(
frameRect
aFrameArea
aFrame
borderRadii
)
;
if
(
hasBorderRadius
)
{
ComputePixelRadii
(
twipsRadii
oneDevPixel
&
borderRadii
)
;
Float
borderSizes
[
4
]
=
{
Float
(
border
.
top
)
/
oneDevPixel
Float
(
border
.
right
)
/
oneDevPixel
Float
(
border
.
bottom
)
/
oneDevPixel
Float
(
border
.
left
)
/
oneDevPixel
}
;
nsCSSBorderRenderer
:
:
ComputeInnerRadii
(
borderRadii
borderSizes
&
aOutInnerRadii
)
;
}
return
hasBorderRadius
;
}
void
nsCSSRendering
:
:
PaintBoxShadowInner
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aFrameArea
)
{
if
(
!
ShouldPaintBoxShadowInner
(
aForFrame
)
)
{
return
;
}
nsCSSShadowArray
*
shadows
=
aForFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
;
NS_ASSERTION
(
aForFrame
-
>
IsFieldSetFrame
(
)
|
|
aFrameArea
.
Size
(
)
=
=
aForFrame
-
>
GetSize
(
)
"
unexpected
size
"
)
;
nsRect
paddingRect
=
GetBoxShadowInnerPaddingRect
(
aForFrame
aFrameArea
)
;
RectCornerRadii
innerRadii
;
bool
hasBorderRadius
=
GetShadowInnerRadii
(
aForFrame
aFrameArea
innerRadii
)
;
const
nscoord
oneDevPixel
=
aPresContext
-
>
DevPixelsToAppUnits
(
1
)
;
for
(
uint32_t
i
=
shadows
-
>
Length
(
)
;
i
>
0
;
-
-
i
)
{
nsCSSShadowItem
*
shadowItem
=
shadows
-
>
ShadowAt
(
i
-
1
)
;
if
(
!
shadowItem
-
>
mInset
)
continue
;
nscoord
blurRadius
=
shadowItem
-
>
mRadius
;
nsMargin
blurMargin
=
nsContextBoxBlur
:
:
GetBlurRadiusMargin
(
blurRadius
oneDevPixel
)
;
nsRect
shadowPaintRect
=
paddingRect
;
shadowPaintRect
.
Inflate
(
blurMargin
)
;
int32_t
spreadDistance
=
shadowItem
-
>
mSpread
/
oneDevPixel
;
nscoord
spreadDistanceAppUnits
=
aPresContext
-
>
DevPixelsToAppUnits
(
spreadDistance
)
;
nsRect
shadowClipRect
=
paddingRect
;
shadowClipRect
.
MoveBy
(
shadowItem
-
>
mXOffset
shadowItem
-
>
mYOffset
)
;
shadowClipRect
.
Deflate
(
spreadDistanceAppUnits
spreadDistanceAppUnits
)
;
Rect
shadowClipGfxRect
=
NSRectToRect
(
shadowClipRect
oneDevPixel
)
;
shadowClipGfxRect
.
Round
(
)
;
RectCornerRadii
clipRectRadii
;
if
(
hasBorderRadius
)
{
Float
borderSizes
[
4
]
=
{
0
0
0
0
}
;
if
(
innerRadii
[
C_TL
]
.
width
>
0
|
|
innerRadii
[
C_BL
]
.
width
>
0
)
{
borderSizes
[
eSideLeft
]
=
spreadDistance
;
}
if
(
innerRadii
[
C_TL
]
.
height
>
0
|
|
innerRadii
[
C_TR
]
.
height
>
0
)
{
borderSizes
[
eSideTop
]
=
spreadDistance
;
}
if
(
innerRadii
[
C_TR
]
.
width
>
0
|
|
innerRadii
[
C_BR
]
.
width
>
0
)
{
borderSizes
[
eSideRight
]
=
spreadDistance
;
}
if
(
innerRadii
[
C_BL
]
.
height
>
0
|
|
innerRadii
[
C_BR
]
.
height
>
0
)
{
borderSizes
[
eSideBottom
]
=
spreadDistance
;
}
nsCSSBorderRenderer
:
:
ComputeInnerRadii
(
innerRadii
borderSizes
&
clipRectRadii
)
;
}
nsRect
skipRect
=
shadowClipRect
;
skipRect
.
Deflate
(
blurMargin
)
;
gfxRect
skipGfxRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
skipRect
oneDevPixel
)
;
if
(
hasBorderRadius
)
{
skipGfxRect
.
Deflate
(
gfxMargin
(
std
:
:
max
(
clipRectRadii
[
C_TL
]
.
height
clipRectRadii
[
C_TR
]
.
height
)
0
std
:
:
max
(
clipRectRadii
[
C_BL
]
.
height
clipRectRadii
[
C_BR
]
.
height
)
0
)
)
;
}
DrawTarget
*
drawTarget
=
aRenderingContext
.
GetDrawTarget
(
)
;
Rect
shadowGfxRect
=
NSRectToRect
(
paddingRect
oneDevPixel
)
;
shadowGfxRect
.
Round
(
)
;
Color
shadowColor
=
GetShadowColor
(
shadowItem
aForFrame
1
.
0
)
;
aRenderingContext
.
Save
(
)
;
if
(
hasBorderRadius
)
{
RefPtr
<
Path
>
roundedRect
=
MakePathForRoundedRect
(
*
drawTarget
shadowGfxRect
innerRadii
)
;
aRenderingContext
.
Clip
(
roundedRect
)
;
}
else
{
aRenderingContext
.
Clip
(
shadowGfxRect
)
;
}
nsContextBoxBlur
insetBoxBlur
;
gfxRect
destRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
shadowPaintRect
oneDevPixel
)
;
Point
shadowOffset
(
shadowItem
-
>
mXOffset
/
oneDevPixel
shadowItem
-
>
mYOffset
/
oneDevPixel
)
;
insetBoxBlur
.
InsetBoxBlur
(
&
aRenderingContext
ToRect
(
destRect
)
shadowClipGfxRect
shadowColor
blurRadius
spreadDistanceAppUnits
oneDevPixel
hasBorderRadius
clipRectRadii
ToRect
(
skipGfxRect
)
shadowOffset
)
;
aRenderingContext
.
Restore
(
)
;
}
}
nsCSSRendering
:
:
PaintBGParams
nsCSSRendering
:
:
PaintBGParams
:
:
ForAllLayers
(
nsPresContext
&
aPresCtx
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
nsIFrame
*
aFrame
uint32_t
aPaintFlags
float
aOpacity
)
{
MOZ_ASSERT
(
aFrame
)
;
PaintBGParams
result
(
aPresCtx
aDirtyRect
aBorderArea
aFrame
aPaintFlags
-
1
CompositionOp
:
:
OP_OVER
aOpacity
)
;
return
result
;
}
nsCSSRendering
:
:
PaintBGParams
nsCSSRendering
:
:
PaintBGParams
:
:
ForSingleLayer
(
nsPresContext
&
aPresCtx
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
nsIFrame
*
aFrame
uint32_t
aPaintFlags
int32_t
aLayer
CompositionOp
aCompositionOp
float
aOpacity
)
{
MOZ_ASSERT
(
aFrame
&
&
(
aLayer
!
=
-
1
)
)
;
PaintBGParams
result
(
aPresCtx
aDirtyRect
aBorderArea
aFrame
aPaintFlags
aLayer
aCompositionOp
aOpacity
)
;
return
result
;
}
ImgDrawResult
nsCSSRendering
:
:
PaintStyleImageLayer
(
const
PaintBGParams
&
aParams
gfxContext
&
aRenderingCtx
)
{
AUTO_PROFILER_LABEL
(
"
nsCSSRendering
:
:
PaintStyleImageLayer
"
GRAPHICS
)
;
MOZ_ASSERT
(
aParams
.
frame
"
Frame
is
expected
to
be
provided
to
PaintStyleImageLayer
"
)
;
ComputedStyle
*
sc
;
if
(
!
FindBackground
(
aParams
.
frame
&
sc
)
)
{
if
(
!
aParams
.
frame
-
>
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
nsIContent
*
content
=
aParams
.
frame
-
>
GetContent
(
)
;
if
(
!
content
|
|
content
-
>
GetParent
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
sc
=
aParams
.
frame
-
>
Style
(
)
;
}
return
PaintStyleImageLayerWithSC
(
aParams
aRenderingCtx
sc
*
aParams
.
frame
-
>
StyleBorder
(
)
)
;
}
bool
nsCSSRendering
:
:
CanBuildWebRenderDisplayItemsForStyleImageLayer
(
LayerManager
*
aManager
nsPresContext
&
aPresCtx
nsIFrame
*
aFrame
const
nsStyleBackground
*
aBackgroundStyle
int32_t
aLayer
uint32_t
aPaintFlags
)
{
if
(
!
aBackgroundStyle
)
{
return
false
;
}
MOZ_ASSERT
(
aFrame
&
&
aLayer
>
=
0
&
&
(
uint32_t
)
aLayer
<
aBackgroundStyle
-
>
mImage
.
mLayers
.
Length
(
)
)
;
const
nsStyleDisplay
*
displayData
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
displayData
-
>
HasAppearance
(
)
)
{
nsITheme
*
theme
=
aPresCtx
.
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
&
aPresCtx
aFrame
displayData
-
>
mAppearance
)
)
{
return
false
;
}
}
const
nsStyleImage
*
styleImage
=
&
aBackgroundStyle
-
>
mImage
.
mLayers
[
aLayer
]
.
mImage
;
if
(
styleImage
-
>
GetType
(
)
=
=
eStyleImageType_Image
)
{
if
(
styleImage
-
>
GetCropRect
(
)
)
{
return
false
;
}
imgRequestProxy
*
requestProxy
=
styleImage
-
>
GetImageData
(
)
;
if
(
!
requestProxy
)
{
return
false
;
}
uint32_t
imageFlags
=
imgIContainer
:
:
FLAG_NONE
;
if
(
aPaintFlags
&
nsCSSRendering
:
:
PAINTBG_SYNC_DECODE_IMAGES
)
{
imageFlags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
nsCOMPtr
<
imgIContainer
>
srcImage
;
requestProxy
-
>
GetImage
(
getter_AddRefs
(
srcImage
)
)
;
if
(
!
srcImage
|
|
!
srcImage
-
>
IsImageContainerAvailable
(
aManager
imageFlags
)
)
{
return
false
;
}
return
true
;
}
if
(
styleImage
-
>
GetType
(
)
=
=
eStyleImageType_Gradient
)
{
return
true
;
}
return
false
;
}
ImgDrawResult
nsCSSRendering
:
:
BuildWebRenderDisplayItemsForStyleImageLayer
(
const
PaintBGParams
&
aParams
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
)
{
MOZ_ASSERT
(
aParams
.
frame
"
Frame
is
expected
to
be
provided
to
"
"
BuildWebRenderDisplayItemsForStyleImageLayer
"
)
;
ComputedStyle
*
sc
;
if
(
!
FindBackground
(
aParams
.
frame
&
sc
)
)
{
if
(
!
aParams
.
frame
-
>
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
nsIContent
*
content
=
aParams
.
frame
-
>
GetContent
(
)
;
if
(
!
content
|
|
content
-
>
GetParent
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
sc
=
aParams
.
frame
-
>
Style
(
)
;
}
return
BuildWebRenderDisplayItemsForStyleImageLayerWithSC
(
aParams
aBuilder
aResources
aSc
aManager
aItem
sc
*
aParams
.
frame
-
>
StyleBorder
(
)
)
;
}
static
bool
IsOpaqueBorderEdge
(
const
nsStyleBorder
&
aBorder
mozilla
:
:
Side
aSide
)
{
if
(
aBorder
.
GetComputedBorder
(
)
.
Side
(
aSide
)
=
=
0
)
return
true
;
switch
(
aBorder
.
GetBorderStyle
(
aSide
)
)
{
case
StyleBorderStyle
:
:
Solid
:
case
StyleBorderStyle
:
:
Groove
:
case
StyleBorderStyle
:
:
Ridge
:
case
StyleBorderStyle
:
:
Inset
:
case
StyleBorderStyle
:
:
Outset
:
break
;
default
:
return
false
;
}
if
(
aBorder
.
mBorderImageSource
.
GetType
(
)
!
=
eStyleImageType_Null
)
return
false
;
StyleComplexColor
color
=
aBorder
.
BorderColorFor
(
aSide
)
;
return
!
color
.
MaybeTransparent
(
)
;
}
static
bool
IsOpaqueBorder
(
const
nsStyleBorder
&
aBorder
)
{
NS_FOR_CSS_SIDES
(
i
)
{
if
(
!
IsOpaqueBorderEdge
(
aBorder
i
)
)
return
false
;
}
return
true
;
}
static
inline
void
SetupDirtyRects
(
const
nsRect
&
aBGClipArea
const
nsRect
&
aCallerDirtyRect
nscoord
aAppUnitsPerPixel
nsRect
*
aDirtyRect
gfxRect
*
aDirtyRectGfx
)
{
aDirtyRect
-
>
IntersectRect
(
aBGClipArea
aCallerDirtyRect
)
;
*
aDirtyRectGfx
=
nsLayoutUtils
:
:
RectToGfxRect
(
*
aDirtyRect
aAppUnitsPerPixel
)
;
NS_WARNING_ASSERTION
(
aDirtyRect
-
>
IsEmpty
(
)
|
|
!
aDirtyRectGfx
-
>
IsEmpty
(
)
"
converted
dirty
rect
should
not
be
empty
"
)
;
MOZ_ASSERT
(
!
aDirtyRect
-
>
IsEmpty
(
)
|
|
aDirtyRectGfx
-
>
IsEmpty
(
)
"
second
should
be
empty
if
first
is
"
)
;
}
static
bool
IsSVGStyleGeometryBox
(
StyleGeometryBox
aBox
)
{
return
(
aBox
=
=
StyleGeometryBox
:
:
FillBox
|
|
aBox
=
=
StyleGeometryBox
:
:
StrokeBox
|
|
aBox
=
=
StyleGeometryBox
:
:
ViewBox
)
;
}
static
bool
IsHTMLStyleGeometryBox
(
StyleGeometryBox
aBox
)
{
return
(
aBox
=
=
StyleGeometryBox
:
:
ContentBox
|
|
aBox
=
=
StyleGeometryBox
:
:
PaddingBox
|
|
aBox
=
=
StyleGeometryBox
:
:
BorderBox
|
|
aBox
=
=
StyleGeometryBox
:
:
MarginBox
)
;
}
static
StyleGeometryBox
ComputeBoxValue
(
nsIFrame
*
aForFrame
StyleGeometryBox
aBox
)
{
if
(
!
(
aForFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
if
(
IsSVGStyleGeometryBox
(
aBox
)
)
{
return
StyleGeometryBox
:
:
BorderBox
;
}
}
else
{
if
(
IsHTMLStyleGeometryBox
(
aBox
)
)
{
return
StyleGeometryBox
:
:
FillBox
;
}
}
return
aBox
;
}
bool
nsCSSRendering
:
:
ImageLayerClipState
:
:
IsValid
(
)
const
{
if
(
!
mDirtyRectInDevPx
.
IsEmpty
(
)
&
&
mDirtyRectInAppUnits
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
mHasRoundedCorners
=
=
mClippedRadii
.
IsEmpty
(
)
)
{
return
false
;
}
return
true
;
}
void
nsCSSRendering
:
:
GetImageLayerClip
(
const
nsStyleImageLayers
:
:
Layer
&
aLayer
nsIFrame
*
aForFrame
const
nsStyleBorder
&
aBorder
const
nsRect
&
aBorderArea
const
nsRect
&
aCallerDirtyRect
bool
aWillPaintBorder
nscoord
aAppUnitsPerPixel
ImageLayerClipState
*
aClipState
)
{
StyleGeometryBox
layerClip
=
ComputeBoxValue
(
aForFrame
aLayer
.
mClip
)
;
if
(
IsSVGStyleGeometryBox
(
layerClip
)
)
{
MOZ_ASSERT
(
aForFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
aForFrame
-
>
IsSVGOuterSVGFrame
(
)
)
;
nsRect
clipArea
=
nsLayoutUtils
:
:
ComputeGeometryBox
(
aForFrame
layerClip
)
;
nsRect
strokeBox
=
(
layerClip
=
=
StyleGeometryBox
:
:
StrokeBox
)
?
clipArea
:
nsLayoutUtils
:
:
ComputeGeometryBox
(
aForFrame
StyleGeometryBox
:
:
StrokeBox
)
;
nsRect
clipAreaRelativeToStrokeBox
=
clipArea
-
strokeBox
.
TopLeft
(
)
;
aClipState
-
>
mBGClipArea
=
clipAreaRelativeToStrokeBox
+
aBorderArea
.
TopLeft
(
)
;
SetupDirtyRects
(
aClipState
-
>
mBGClipArea
aCallerDirtyRect
aAppUnitsPerPixel
&
aClipState
-
>
mDirtyRectInAppUnits
&
aClipState
-
>
mDirtyRectInDevPx
)
;
MOZ_ASSERT
(
aClipState
-
>
IsValid
(
)
)
;
return
;
}
if
(
layerClip
=
=
StyleGeometryBox
:
:
NoClip
)
{
aClipState
-
>
mBGClipArea
=
aCallerDirtyRect
;
SetupDirtyRects
(
aClipState
-
>
mBGClipArea
aCallerDirtyRect
aAppUnitsPerPixel
&
aClipState
-
>
mDirtyRectInAppUnits
&
aClipState
-
>
mDirtyRectInDevPx
)
;
MOZ_ASSERT
(
aClipState
-
>
IsValid
(
)
)
;
return
;
}
MOZ_ASSERT
(
!
aForFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
aForFrame
-
>
IsSVGOuterSVGFrame
(
)
)
;
Sides
skipSides
=
aForFrame
-
>
GetSkipSides
(
)
;
nsRect
clipBorderArea
=
BoxDecorationRectForBorder
(
aForFrame
aBorderArea
skipSides
&
aBorder
)
;
bool
haveRoundedCorners
=
false
;
LayoutFrameType
fType
=
aForFrame
-
>
Type
(
)
;
if
(
fType
!
=
LayoutFrameType
:
:
TableColGroup
&
&
fType
!
=
LayoutFrameType
:
:
TableCol
&
&
fType
!
=
LayoutFrameType
:
:
TableRow
&
&
fType
!
=
LayoutFrameType
:
:
TableRowGroup
)
{
haveRoundedCorners
=
GetRadii
(
aForFrame
aBorder
aBorderArea
clipBorderArea
aClipState
-
>
mRadii
)
;
}
bool
isSolidBorder
=
aWillPaintBorder
&
&
IsOpaqueBorder
(
aBorder
)
;
if
(
isSolidBorder
&
&
layerClip
=
=
StyleGeometryBox
:
:
BorderBox
)
{
layerClip
=
haveRoundedCorners
?
StyleGeometryBox
:
:
MozAlmostPadding
:
StyleGeometryBox
:
:
PaddingBox
;
}
aClipState
-
>
mBGClipArea
=
clipBorderArea
;
if
(
aForFrame
-
>
IsScrollFrame
(
)
&
&
StyleImageLayerAttachment
:
:
Local
=
=
aLayer
.
mAttachment
)
{
if
(
layerClip
=
=
StyleGeometryBox
:
:
ContentBox
)
{
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
aForFrame
)
;
aClipState
-
>
mHasAdditionalBGClipArea
=
true
;
aClipState
-
>
mAdditionalBGClipArea
=
nsRect
(
aClipState
-
>
mBGClipArea
.
TopLeft
(
)
+
scrollableFrame
-
>
GetScrolledFrame
(
)
-
>
GetPosition
(
)
+
scrollableFrame
-
>
GetScrollRange
(
)
.
TopLeft
(
)
scrollableFrame
-
>
GetScrolledRect
(
)
.
Size
(
)
)
;
nsMargin
padding
=
aForFrame
-
>
GetUsedPadding
(
)
;
padding
.
bottom
=
0
;
padding
.
ApplySkipSides
(
skipSides
)
;
aClipState
-
>
mAdditionalBGClipArea
.
Deflate
(
padding
)
;
}
layerClip
=
StyleGeometryBox
:
:
PaddingBox
;
}
MOZ_ASSERT
(
layerClip
!
=
StyleGeometryBox
:
:
MarginBox
"
StyleGeometryBox
:
:
MarginBox
rendering
is
not
supported
yet
.
\
n
"
)
;
if
(
layerClip
!
=
StyleGeometryBox
:
:
BorderBox
&
&
layerClip
!
=
StyleGeometryBox
:
:
Text
)
{
nsMargin
border
=
aForFrame
-
>
GetUsedBorder
(
)
;
if
(
layerClip
=
=
StyleGeometryBox
:
:
MozAlmostPadding
)
{
border
.
top
=
std
:
:
max
(
0
border
.
top
-
aAppUnitsPerPixel
)
;
border
.
right
=
std
:
:
max
(
0
border
.
right
-
aAppUnitsPerPixel
)
;
border
.
bottom
=
std
:
:
max
(
0
border
.
bottom
-
aAppUnitsPerPixel
)
;
border
.
left
=
std
:
:
max
(
0
border
.
left
-
aAppUnitsPerPixel
)
;
}
else
if
(
layerClip
!
=
StyleGeometryBox
:
:
PaddingBox
)
{
NS_ASSERTION
(
layerClip
=
=
StyleGeometryBox
:
:
ContentBox
"
unexpected
background
-
clip
"
)
;
border
+
=
aForFrame
-
>
GetUsedPadding
(
)
;
}
border
.
ApplySkipSides
(
skipSides
)
;
aClipState
-
>
mBGClipArea
.
Deflate
(
border
)
;
if
(
haveRoundedCorners
)
{
nsIFrame
:
:
InsetBorderRadii
(
aClipState
-
>
mRadii
border
)
;
}
}
if
(
haveRoundedCorners
)
{
auto
d2a
=
aForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsCSSRendering
:
:
ComputePixelRadii
(
aClipState
-
>
mRadii
d2a
&
aClipState
-
>
mClippedRadii
)
;
aClipState
-
>
mHasRoundedCorners
=
!
aClipState
-
>
mClippedRadii
.
IsEmpty
(
)
;
}
if
(
!
haveRoundedCorners
&
&
aClipState
-
>
mHasAdditionalBGClipArea
)
{
aClipState
-
>
mBGClipArea
=
aClipState
-
>
mBGClipArea
.
Intersect
(
aClipState
-
>
mAdditionalBGClipArea
)
;
aClipState
-
>
mHasAdditionalBGClipArea
=
false
;
}
SetupDirtyRects
(
aClipState
-
>
mBGClipArea
aCallerDirtyRect
aAppUnitsPerPixel
&
aClipState
-
>
mDirtyRectInAppUnits
&
aClipState
-
>
mDirtyRectInDevPx
)
;
MOZ_ASSERT
(
aClipState
-
>
IsValid
(
)
)
;
}
static
void
SetupImageLayerClip
(
nsCSSRendering
:
:
ImageLayerClipState
&
aClipState
gfxContext
*
aCtx
nscoord
aAppUnitsPerPixel
gfxContextAutoSaveRestore
*
aAutoSR
)
{
if
(
aClipState
.
mDirtyRectInDevPx
.
IsEmpty
(
)
)
{
return
;
}
if
(
aClipState
.
mCustomClip
)
{
return
;
}
if
(
aClipState
.
mHasAdditionalBGClipArea
)
{
gfxRect
bgAreaGfx
=
nsLayoutUtils
:
:
RectToGfxRect
(
aClipState
.
mAdditionalBGClipArea
aAppUnitsPerPixel
)
;
bgAreaGfx
.
Round
(
)
;
gfxUtils
:
:
ConditionRect
(
bgAreaGfx
)
;
aAutoSR
-
>
EnsureSaved
(
aCtx
)
;
aCtx
-
>
SnappedClip
(
bgAreaGfx
)
;
}
if
(
aClipState
.
mHasRoundedCorners
)
{
Rect
bgAreaGfx
=
NSRectToRect
(
aClipState
.
mBGClipArea
aAppUnitsPerPixel
)
;
bgAreaGfx
.
Round
(
)
;
if
(
bgAreaGfx
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
converted
background
area
should
not
be
empty
"
)
;
aClipState
.
mDirtyRectInDevPx
.
SizeTo
(
gfxSize
(
0
.
0
0
.
0
)
)
;
return
;
}
aAutoSR
-
>
EnsureSaved
(
aCtx
)
;
RefPtr
<
Path
>
roundedRect
=
MakePathForRoundedRect
(
*
aCtx
-
>
GetDrawTarget
(
)
bgAreaGfx
aClipState
.
mClippedRadii
)
;
aCtx
-
>
Clip
(
roundedRect
)
;
}
}
static
void
DrawBackgroundColor
(
nsCSSRendering
:
:
ImageLayerClipState
&
aClipState
gfxContext
*
aCtx
nscoord
aAppUnitsPerPixel
)
{
if
(
aClipState
.
mDirtyRectInDevPx
.
IsEmpty
(
)
)
{
return
;
}
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
if
(
!
aClipState
.
mHasRoundedCorners
|
|
aClipState
.
mCustomClip
)
{
aCtx
-
>
NewPath
(
)
;
aCtx
-
>
SnappedRectangle
(
aClipState
.
mDirtyRectInDevPx
)
;
aCtx
-
>
Fill
(
)
;
return
;
}
Rect
bgAreaGfx
=
NSRectToRect
(
aClipState
.
mBGClipArea
aAppUnitsPerPixel
)
;
bgAreaGfx
.
Round
(
)
;
if
(
bgAreaGfx
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
converted
background
area
should
not
be
empty
"
)
;
aClipState
.
mDirtyRectInDevPx
.
SizeTo
(
gfxSize
(
0
.
0
0
.
0
)
)
;
return
;
}
aCtx
-
>
Save
(
)
;
gfxRect
dirty
=
ThebesRect
(
bgAreaGfx
)
.
Intersect
(
aClipState
.
mDirtyRectInDevPx
)
;
aCtx
-
>
SnappedClip
(
dirty
)
;
if
(
aClipState
.
mHasAdditionalBGClipArea
)
{
gfxRect
bgAdditionalAreaGfx
=
nsLayoutUtils
:
:
RectToGfxRect
(
aClipState
.
mAdditionalBGClipArea
aAppUnitsPerPixel
)
;
bgAdditionalAreaGfx
.
Round
(
)
;
gfxUtils
:
:
ConditionRect
(
bgAdditionalAreaGfx
)
;
aCtx
-
>
SnappedClip
(
bgAdditionalAreaGfx
)
;
}
RefPtr
<
Path
>
roundedRect
=
MakePathForRoundedRect
(
*
drawTarget
bgAreaGfx
aClipState
.
mClippedRadii
)
;
aCtx
-
>
SetPath
(
roundedRect
)
;
aCtx
-
>
Fill
(
)
;
aCtx
-
>
Restore
(
)
;
}
static
Maybe
<
nscolor
>
CalcScrollbarColor
(
nsIFrame
*
aFrame
StyleComplexColor
nsStyleUI
:
:
*
aColor
)
{
ComputedStyle
*
scrollbarStyle
=
nsLayoutUtils
:
:
StyleForScrollbar
(
aFrame
)
;
auto
color
=
scrollbarStyle
-
>
StyleUI
(
)
-
>
*
aColor
;
if
(
color
.
IsAuto
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
color
.
CalcColor
(
scrollbarStyle
)
)
;
}
static
nscolor
GetBackgroundColor
(
nsIFrame
*
aFrame
ComputedStyle
*
aComputedStyle
)
{
Maybe
<
nscolor
>
overrideColor
=
Nothing
(
)
;
switch
(
aComputedStyle
-
>
StyleDisplay
(
)
-
>
mAppearance
)
{
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
overrideColor
=
CalcScrollbarColor
(
aFrame
&
nsStyleUI
:
:
mScrollbarFaceColor
)
;
break
;
case
StyleAppearance
:
:
ScrollbarVertical
:
case
StyleAppearance
:
:
ScrollbarHorizontal
:
case
StyleAppearance
:
:
Scrollcorner
:
overrideColor
=
CalcScrollbarColor
(
aFrame
&
nsStyleUI
:
:
mScrollbarTrackColor
)
;
break
;
default
:
break
;
}
if
(
overrideColor
.
isSome
(
)
)
{
return
*
overrideColor
;
}
return
aComputedStyle
-
>
GetVisitedDependentColor
(
&
nsStyleBackground
:
:
mBackgroundColor
)
;
}
nscolor
nsCSSRendering
:
:
DetermineBackgroundColor
(
nsPresContext
*
aPresContext
ComputedStyle
*
aComputedStyle
nsIFrame
*
aFrame
bool
&
aDrawBackgroundImage
bool
&
aDrawBackgroundColor
)
{
aDrawBackgroundImage
=
true
;
aDrawBackgroundColor
=
true
;
const
nsStyleVisibility
*
visibility
=
aComputedStyle
-
>
StyleVisibility
(
)
;
if
(
visibility
-
>
mColorAdjust
!
=
StyleColorAdjust
:
:
Exact
&
&
aFrame
-
>
HonorPrintBackgroundSettings
(
)
)
{
aDrawBackgroundImage
=
aPresContext
-
>
GetBackgroundImageDraw
(
)
;
aDrawBackgroundColor
=
aPresContext
-
>
GetBackgroundColorDraw
(
)
;
}
const
nsStyleBackground
*
bg
=
aComputedStyle
-
>
StyleBackground
(
)
;
nscolor
bgColor
;
if
(
aDrawBackgroundColor
)
{
bgColor
=
GetBackgroundColor
(
aFrame
aComputedStyle
)
;
if
(
NS_GET_A
(
bgColor
)
=
=
0
)
{
aDrawBackgroundColor
=
false
;
}
}
else
{
bgColor
=
NS_RGB
(
255
255
255
)
;
if
(
aDrawBackgroundImage
|
|
!
bg
-
>
IsTransparent
(
aComputedStyle
)
)
{
aDrawBackgroundColor
=
true
;
}
else
{
bgColor
=
NS_RGBA
(
0
0
0
0
)
;
}
}
nsStyleImageLayers
:
:
Repeat
repeat
=
bg
-
>
BottomLayer
(
)
.
mRepeat
;
bool
xFullRepeat
=
repeat
.
mXRepeat
=
=
StyleImageLayerRepeat
:
:
Repeat
|
|
repeat
.
mXRepeat
=
=
StyleImageLayerRepeat
:
:
Round
;
bool
yFullRepeat
=
repeat
.
mYRepeat
=
=
StyleImageLayerRepeat
:
:
Repeat
|
|
repeat
.
mYRepeat
=
=
StyleImageLayerRepeat
:
:
Round
;
if
(
aDrawBackgroundColor
&
&
xFullRepeat
&
&
yFullRepeat
&
&
bg
-
>
BottomLayer
(
)
.
mImage
.
IsOpaque
(
)
&
&
bg
-
>
BottomLayer
(
)
.
mBlendMode
=
=
NS_STYLE_BLEND_NORMAL
)
{
aDrawBackgroundColor
=
false
;
}
return
bgColor
;
}
static
CompositionOp
DetermineCompositionOp
(
const
nsCSSRendering
:
:
PaintBGParams
&
aParams
const
nsStyleImageLayers
&
aLayers
uint32_t
aLayerIndex
)
{
if
(
aParams
.
layer
>
=
0
)
{
return
aParams
.
compositionOp
;
}
const
nsStyleImageLayers
:
:
Layer
&
layer
=
aLayers
.
mLayers
[
aLayerIndex
]
;
if
(
aParams
.
paintFlags
&
nsCSSRendering
:
:
PAINTBG_MASK_IMAGE
)
{
if
(
aLayerIndex
=
=
(
aLayers
.
mImageCount
-
1
)
)
{
return
CompositionOp
:
:
OP_OVER
;
}
return
nsCSSRendering
:
:
GetGFXCompositeMode
(
layer
.
mComposite
)
;
}
return
nsCSSRendering
:
:
GetGFXBlendMode
(
layer
.
mBlendMode
)
;
}
ImgDrawResult
nsCSSRendering
:
:
PaintStyleImageLayerWithSC
(
const
PaintBGParams
&
aParams
gfxContext
&
aRenderingCtx
ComputedStyle
*
aBackgroundSC
const
nsStyleBorder
&
aBorder
)
{
MOZ_ASSERT
(
aParams
.
frame
"
Frame
is
expected
to
be
provided
to
PaintStyleImageLayerWithSC
"
)
;
MOZ_ASSERT
(
aParams
.
layer
!
=
-
1
|
|
aParams
.
compositionOp
=
=
CompositionOp
:
:
OP_OVER
)
;
const
nsStyleDisplay
*
displayData
=
aParams
.
frame
-
>
StyleDisplay
(
)
;
if
(
displayData
-
>
HasAppearance
(
)
)
{
nsITheme
*
theme
=
aParams
.
presCtx
.
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
&
aParams
.
presCtx
aParams
.
frame
displayData
-
>
mAppearance
)
)
{
nsRect
drawing
(
aParams
.
borderArea
)
;
theme
-
>
GetWidgetOverflow
(
aParams
.
presCtx
.
DeviceContext
(
)
aParams
.
frame
displayData
-
>
mAppearance
&
drawing
)
;
drawing
.
IntersectRect
(
drawing
aParams
.
dirtyRect
)
;
theme
-
>
DrawWidgetBackground
(
&
aRenderingCtx
aParams
.
frame
displayData
-
>
mAppearance
aParams
.
borderArea
drawing
)
;
return
ImgDrawResult
:
:
SUCCESS
;
}
}
bool
isCanvasFrame
=
IsCanvasFrame
(
aParams
.
frame
)
;
bool
drawBackgroundImage
;
bool
drawBackgroundColor
;
nscolor
bgColor
=
DetermineBackgroundColor
(
&
aParams
.
presCtx
aBackgroundSC
aParams
.
frame
drawBackgroundImage
drawBackgroundColor
)
;
bool
paintMask
=
(
aParams
.
paintFlags
&
PAINTBG_MASK_IMAGE
)
;
const
nsStyleImageLayers
&
layers
=
paintMask
?
aBackgroundSC
-
>
StyleSVGReset
(
)
-
>
mMask
:
aBackgroundSC
-
>
StyleBackground
(
)
-
>
mImage
;
if
(
(
drawBackgroundColor
&
&
aParams
.
layer
>
=
0
)
|
|
paintMask
)
{
drawBackgroundColor
=
false
;
}
if
(
!
drawBackgroundImage
&
&
!
drawBackgroundColor
)
return
ImgDrawResult
:
:
SUCCESS
;
nscoord
appUnitsPerPixel
=
aParams
.
presCtx
.
AppUnitsPerDevPixel
(
)
;
ImageLayerClipState
clipState
;
if
(
aParams
.
bgClipRect
)
{
clipState
.
mBGClipArea
=
*
aParams
.
bgClipRect
;
clipState
.
mCustomClip
=
true
;
clipState
.
mHasRoundedCorners
=
false
;
SetupDirtyRects
(
clipState
.
mBGClipArea
aParams
.
dirtyRect
appUnitsPerPixel
&
clipState
.
mDirtyRectInAppUnits
&
clipState
.
mDirtyRectInDevPx
)
;
}
else
{
GetImageLayerClip
(
layers
.
BottomLayer
(
)
aParams
.
frame
aBorder
aParams
.
borderArea
aParams
.
dirtyRect
(
aParams
.
paintFlags
&
PAINTBG_WILL_PAINT_BORDER
)
appUnitsPerPixel
&
clipState
)
;
}
if
(
drawBackgroundColor
&
&
!
isCanvasFrame
)
{
aRenderingCtx
.
SetColor
(
Color
:
:
FromABGR
(
bgColor
)
)
;
}
if
(
!
drawBackgroundImage
)
{
if
(
!
isCanvasFrame
)
{
DrawBackgroundColor
(
clipState
&
aRenderingCtx
appUnitsPerPixel
)
;
}
return
ImgDrawResult
:
:
SUCCESS
;
}
if
(
layers
.
mImageCount
<
1
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
MOZ_ASSERT
(
(
aParams
.
layer
<
0
)
|
|
(
layers
.
mImageCount
>
uint32_t
(
aParams
.
layer
)
)
)
;
bool
drawAllLayers
=
(
aParams
.
layer
<
0
)
;
if
(
aBackgroundSC
!
=
aParams
.
frame
-
>
Style
(
)
)
{
uint32_t
startLayer
=
drawAllLayers
?
layers
.
mImageCount
-
1
:
aParams
.
layer
;
uint32_t
count
=
drawAllLayers
?
layers
.
mImageCount
:
1
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT_WITH_RANGE
(
i
layers
startLayer
count
)
{
aParams
.
frame
-
>
AssociateImage
(
layers
.
mLayers
[
i
]
.
mImage
&
aParams
.
presCtx
0
)
;
}
}
if
(
drawBackgroundColor
&
&
!
isCanvasFrame
)
{
DrawBackgroundColor
(
clipState
&
aRenderingCtx
appUnitsPerPixel
)
;
}
Sides
skipSides
=
aParams
.
frame
-
>
GetSkipSides
(
)
;
nsRect
paintBorderArea
=
BoxDecorationRectForBackground
(
aParams
.
frame
aParams
.
borderArea
skipSides
&
aBorder
)
;
nsRect
clipBorderArea
=
BoxDecorationRectForBorder
(
aParams
.
frame
aParams
.
borderArea
skipSides
&
aBorder
)
;
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
StyleGeometryBox
currentBackgroundClip
=
StyleGeometryBox
:
:
BorderBox
;
uint32_t
count
=
drawAllLayers
?
layers
.
mImageCount
:
layers
.
mImageCount
-
aParams
.
layer
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT_WITH_RANGE
(
i
layers
layers
.
mImageCount
-
1
count
)
{
gfxContextAutoSaveRestore
autoSR
;
const
nsStyleImageLayers
:
:
Layer
&
layer
=
layers
.
mLayers
[
i
]
;
if
(
!
aParams
.
bgClipRect
)
{
bool
isBottomLayer
=
(
i
=
=
layers
.
mImageCount
-
1
)
;
if
(
currentBackgroundClip
!
=
layer
.
mClip
|
|
isBottomLayer
)
{
currentBackgroundClip
=
layer
.
mClip
;
ImageLayerClipState
currentLayerClipState
;
if
(
isBottomLayer
)
{
currentLayerClipState
=
clipState
;
}
else
{
GetImageLayerClip
(
layer
aParams
.
frame
aBorder
aParams
.
borderArea
aParams
.
dirtyRect
(
aParams
.
paintFlags
&
PAINTBG_WILL_PAINT_BORDER
)
appUnitsPerPixel
&
currentLayerClipState
)
;
}
SetupImageLayerClip
(
currentLayerClipState
&
aRenderingCtx
appUnitsPerPixel
&
autoSR
)
;
if
(
!
clipBorderArea
.
IsEqualEdges
(
aParams
.
borderArea
)
)
{
gfxRect
clip
=
nsLayoutUtils
:
:
RectToGfxRect
(
aParams
.
borderArea
appUnitsPerPixel
)
;
autoSR
.
EnsureSaved
(
&
aRenderingCtx
)
;
aRenderingCtx
.
SnappedClip
(
clip
)
;
}
}
}
if
(
aParams
.
layer
>
=
0
&
&
i
!
=
(
uint32_t
)
aParams
.
layer
)
{
continue
;
}
nsBackgroundLayerState
state
=
PrepareImageLayer
(
&
aParams
.
presCtx
aParams
.
frame
aParams
.
paintFlags
paintBorderArea
clipState
.
mBGClipArea
layer
nullptr
)
;
result
&
=
state
.
mImageRenderer
.
PrepareResult
(
)
;
if
(
clipState
.
mDirtyRectInDevPx
.
IsEmpty
(
)
)
{
continue
;
}
if
(
!
state
.
mFillArea
.
IsEmpty
(
)
)
{
CompositionOp
co
=
DetermineCompositionOp
(
aParams
layers
i
)
;
if
(
co
!
=
CompositionOp
:
:
OP_OVER
)
{
NS_ASSERTION
(
aRenderingCtx
.
CurrentOp
(
)
=
=
CompositionOp
:
:
OP_OVER
"
It
is
assumed
the
initial
op
is
OP_OVER
when
it
is
"
"
restored
later
"
)
;
aRenderingCtx
.
SetOp
(
co
)
;
}
result
&
=
state
.
mImageRenderer
.
DrawLayer
(
&
aParams
.
presCtx
aRenderingCtx
state
.
mDestArea
state
.
mFillArea
state
.
mAnchor
+
paintBorderArea
.
TopLeft
(
)
clipState
.
mDirtyRectInAppUnits
state
.
mRepeatSize
aParams
.
opacity
)
;
if
(
co
!
=
CompositionOp
:
:
OP_OVER
)
{
aRenderingCtx
.
SetOp
(
CompositionOp
:
:
OP_OVER
)
;
}
}
}
return
result
;
}
ImgDrawResult
nsCSSRendering
:
:
BuildWebRenderDisplayItemsForStyleImageLayerWithSC
(
const
PaintBGParams
&
aParams
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
ComputedStyle
*
aBackgroundSC
const
nsStyleBorder
&
aBorder
)
{
MOZ_ASSERT
(
!
(
aParams
.
paintFlags
&
PAINTBG_MASK_IMAGE
)
)
;
nscoord
appUnitsPerPixel
=
aParams
.
presCtx
.
AppUnitsPerDevPixel
(
)
;
ImageLayerClipState
clipState
;
clipState
.
mBGClipArea
=
*
aParams
.
bgClipRect
;
clipState
.
mCustomClip
=
true
;
clipState
.
mHasRoundedCorners
=
false
;
SetupDirtyRects
(
clipState
.
mBGClipArea
aParams
.
dirtyRect
appUnitsPerPixel
&
clipState
.
mDirtyRectInAppUnits
&
clipState
.
mDirtyRectInDevPx
)
;
Sides
skipSides
=
aParams
.
frame
-
>
GetSkipSides
(
)
;
nsRect
paintBorderArea
=
BoxDecorationRectForBackground
(
aParams
.
frame
aParams
.
borderArea
skipSides
&
aBorder
)
;
const
nsStyleImageLayers
&
layers
=
aBackgroundSC
-
>
StyleBackground
(
)
-
>
mImage
;
const
nsStyleImageLayers
:
:
Layer
&
layer
=
layers
.
mLayers
[
aParams
.
layer
]
;
if
(
clipState
.
mDirtyRectInDevPx
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
nsBackgroundLayerState
state
=
PrepareImageLayer
(
&
aParams
.
presCtx
aParams
.
frame
aParams
.
paintFlags
paintBorderArea
clipState
.
mBGClipArea
layer
nullptr
)
;
result
&
=
state
.
mImageRenderer
.
PrepareResult
(
)
;
aParams
.
frame
-
>
AssociateImage
(
layer
.
mImage
&
aParams
.
presCtx
0
)
;
if
(
!
state
.
mFillArea
.
IsEmpty
(
)
)
{
return
state
.
mImageRenderer
.
BuildWebRenderDisplayItemsForLayer
(
&
aParams
.
presCtx
aBuilder
aResources
aSc
aManager
aItem
state
.
mDestArea
state
.
mFillArea
state
.
mAnchor
+
paintBorderArea
.
TopLeft
(
)
clipState
.
mDirtyRectInAppUnits
state
.
mRepeatSize
aParams
.
opacity
)
;
}
return
result
;
}
nsRect
nsCSSRendering
:
:
ComputeImageLayerPositioningArea
(
nsPresContext
*
aPresContext
nsIFrame
*
aForFrame
const
nsRect
&
aBorderArea
const
nsStyleImageLayers
:
:
Layer
&
aLayer
nsIFrame
*
*
aAttachedToFrame
bool
*
aOutIsTransformedFixed
)
{
nsRect
positionArea
;
StyleGeometryBox
layerOrigin
=
ComputeBoxValue
(
aForFrame
aLayer
.
mOrigin
)
;
if
(
IsSVGStyleGeometryBox
(
layerOrigin
)
)
{
MOZ_ASSERT
(
aForFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
aForFrame
-
>
IsSVGOuterSVGFrame
(
)
)
;
*
aAttachedToFrame
=
aForFrame
;
positionArea
=
nsLayoutUtils
:
:
ComputeGeometryBox
(
aForFrame
layerOrigin
)
;
nsPoint
toStrokeBoxOffset
=
nsPoint
(
0
0
)
;
if
(
layerOrigin
!
=
StyleGeometryBox
:
:
StrokeBox
)
{
nsRect
strokeBox
=
nsLayoutUtils
:
:
ComputeGeometryBox
(
aForFrame
StyleGeometryBox
:
:
StrokeBox
)
;
toStrokeBoxOffset
=
positionArea
.
TopLeft
(
)
-
strokeBox
.
TopLeft
(
)
;
}
return
nsRect
(
toStrokeBoxOffset
positionArea
.
Size
(
)
)
;
}
MOZ_ASSERT
(
!
aForFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
aForFrame
-
>
IsSVGOuterSVGFrame
(
)
)
;
LayoutFrameType
frameType
=
aForFrame
-
>
Type
(
)
;
nsIFrame
*
geometryFrame
=
aForFrame
;
if
(
MOZ_UNLIKELY
(
frameType
=
=
LayoutFrameType
:
:
Scroll
&
&
StyleImageLayerAttachment
:
:
Local
=
=
aLayer
.
mAttachment
)
)
{
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
aForFrame
)
;
positionArea
=
nsRect
(
scrollableFrame
-
>
GetScrolledFrame
(
)
-
>
GetPosition
(
)
+
scrollableFrame
-
>
GetScrollRange
(
)
.
TopLeft
(
)
scrollableFrame
-
>
GetScrolledRect
(
)
.
Size
(
)
)
;
if
(
layerOrigin
=
=
StyleGeometryBox
:
:
BorderBox
)
{
nsMargin
border
=
geometryFrame
-
>
GetUsedBorder
(
)
;
border
.
ApplySkipSides
(
geometryFrame
-
>
GetSkipSides
(
)
)
;
positionArea
.
Inflate
(
border
)
;
positionArea
.
Inflate
(
scrollableFrame
-
>
GetActualScrollbarSizes
(
)
)
;
}
else
if
(
layerOrigin
!
=
StyleGeometryBox
:
:
PaddingBox
)
{
nsMargin
padding
=
geometryFrame
-
>
GetUsedPadding
(
)
;
padding
.
ApplySkipSides
(
geometryFrame
-
>
GetSkipSides
(
)
)
;
positionArea
.
Deflate
(
padding
)
;
NS_ASSERTION
(
layerOrigin
=
=
StyleGeometryBox
:
:
ContentBox
"
unknown
background
-
origin
value
"
)
;
}
*
aAttachedToFrame
=
aForFrame
;
return
positionArea
;
}
if
(
MOZ_UNLIKELY
(
frameType
=
=
LayoutFrameType
:
:
Canvas
)
)
{
geometryFrame
=
aForFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
geometryFrame
)
{
positionArea
=
geometryFrame
-
>
GetRect
(
)
;
}
}
else
{
positionArea
=
nsRect
(
nsPoint
(
0
0
)
aBorderArea
.
Size
(
)
)
;
}
MOZ_ASSERT
(
aLayer
.
mOrigin
!
=
StyleGeometryBox
:
:
MarginBox
"
StyleGeometryBox
:
:
MarginBox
rendering
is
not
supported
yet
.
\
n
"
)
;
if
(
layerOrigin
!
=
StyleGeometryBox
:
:
BorderBox
&
&
geometryFrame
)
{
nsMargin
border
=
geometryFrame
-
>
GetUsedBorder
(
)
;
if
(
layerOrigin
!
=
StyleGeometryBox
:
:
PaddingBox
)
{
border
+
=
geometryFrame
-
>
GetUsedPadding
(
)
;
NS_ASSERTION
(
layerOrigin
=
=
StyleGeometryBox
:
:
ContentBox
"
unknown
background
-
origin
value
"
)
;
}
positionArea
.
Deflate
(
border
)
;
}
nsIFrame
*
attachedToFrame
=
aForFrame
;
if
(
StyleImageLayerAttachment
:
:
Fixed
=
=
aLayer
.
mAttachment
)
{
attachedToFrame
=
aPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
NS_ASSERTION
(
attachedToFrame
"
no
root
frame
"
)
;
nsIFrame
*
pageContentFrame
=
nullptr
;
if
(
aPresContext
-
>
IsPaginated
(
)
)
{
pageContentFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aForFrame
LayoutFrameType
:
:
PageContent
)
;
if
(
pageContentFrame
)
{
attachedToFrame
=
pageContentFrame
;
}
}
if
(
nsLayoutUtils
:
:
IsTransformed
(
aForFrame
attachedToFrame
)
)
{
attachedToFrame
=
aForFrame
;
*
aOutIsTransformedFixed
=
true
;
}
else
{
positionArea
=
nsRect
(
-
aForFrame
-
>
GetOffsetTo
(
attachedToFrame
)
attachedToFrame
-
>
GetSize
(
)
)
;
if
(
!
pageContentFrame
)
{
nsIScrollableFrame
*
scrollableFrame
=
aPresContext
-
>
PresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
scrollableFrame
)
{
nsMargin
scrollbars
=
scrollableFrame
-
>
GetActualScrollbarSizes
(
)
;
positionArea
.
Deflate
(
scrollbars
)
;
}
}
}
}
*
aAttachedToFrame
=
attachedToFrame
;
return
positionArea
;
}
nscoord
nsCSSRendering
:
:
ComputeRoundedSize
(
nscoord
aCurrentSize
nscoord
aPositioningSize
)
{
float
repeatCount
=
NS_roundf
(
float
(
aPositioningSize
)
/
float
(
aCurrentSize
)
)
;
if
(
repeatCount
<
1
.
0f
)
{
return
aPositioningSize
;
}
return
nscoord
(
NS_lround
(
float
(
aPositioningSize
)
/
repeatCount
)
)
;
}
static
nsSize
ComputeDrawnSizeForBackground
(
const
CSSSizeOrRatio
&
aIntrinsicSize
const
nsSize
&
aBgPositioningArea
const
nsStyleImageLayers
:
:
Size
&
aLayerSize
StyleImageLayerRepeat
aXRepeat
StyleImageLayerRepeat
aYRepeat
)
{
nsSize
imageSize
;
if
(
aLayerSize
.
mWidthType
=
=
nsStyleImageLayers
:
:
Size
:
:
eContain
|
|
aLayerSize
.
mWidthType
=
=
nsStyleImageLayers
:
:
Size
:
:
eCover
)
{
nsImageRenderer
:
:
FitType
fitType
=
aLayerSize
.
mWidthType
=
=
nsStyleImageLayers
:
:
Size
:
:
eCover
?
nsImageRenderer
:
:
COVER
:
nsImageRenderer
:
:
CONTAIN
;
imageSize
=
nsImageRenderer
:
:
ComputeConstrainedSize
(
aBgPositioningArea
aIntrinsicSize
.
mRatio
fitType
)
;
}
else
{
CSSSizeOrRatio
specifiedSize
;
if
(
aLayerSize
.
mWidthType
=
=
nsStyleImageLayers
:
:
Size
:
:
eLengthPercentage
)
{
specifiedSize
.
SetWidth
(
aLayerSize
.
ResolveWidthLengthPercentage
(
aBgPositioningArea
)
)
;
}
if
(
aLayerSize
.
mHeightType
=
=
nsStyleImageLayers
:
:
Size
:
:
eLengthPercentage
)
{
specifiedSize
.
SetHeight
(
aLayerSize
.
ResolveHeightLengthPercentage
(
aBgPositioningArea
)
)
;
}
imageSize
=
nsImageRenderer
:
:
ComputeConcreteSize
(
specifiedSize
aIntrinsicSize
aBgPositioningArea
)
;
}
bool
isRepeatRoundInBothDimensions
=
aXRepeat
=
=
StyleImageLayerRepeat
:
:
Round
&
&
aYRepeat
=
=
StyleImageLayerRepeat
:
:
Round
;
if
(
imageSize
.
width
&
&
aXRepeat
=
=
StyleImageLayerRepeat
:
:
Round
)
{
imageSize
.
width
=
nsCSSRendering
:
:
ComputeRoundedSize
(
imageSize
.
width
aBgPositioningArea
.
width
)
;
if
(
!
isRepeatRoundInBothDimensions
&
&
aLayerSize
.
mHeightType
=
=
nsStyleImageLayers
:
:
Size
:
:
DimensionType
:
:
eAuto
)
{
if
(
aIntrinsicSize
.
mRatio
.
width
)
{
float
scale
=
float
(
aIntrinsicSize
.
mRatio
.
height
)
/
aIntrinsicSize
.
mRatio
.
width
;
imageSize
.
height
=
NSCoordSaturatingNonnegativeMultiply
(
imageSize
.
width
scale
)
;
}
}
}
if
(
imageSize
.
height
&
&
aYRepeat
=
=
StyleImageLayerRepeat
:
:
Round
)
{
imageSize
.
height
=
nsCSSRendering
:
:
ComputeRoundedSize
(
imageSize
.
height
aBgPositioningArea
.
height
)
;
if
(
!
isRepeatRoundInBothDimensions
&
&
aLayerSize
.
mWidthType
=
=
nsStyleImageLayers
:
:
Size
:
:
DimensionType
:
:
eAuto
)
{
if
(
aIntrinsicSize
.
mRatio
.
height
)
{
float
scale
=
float
(
aIntrinsicSize
.
mRatio
.
width
)
/
aIntrinsicSize
.
mRatio
.
height
;
imageSize
.
width
=
NSCoordSaturatingNonnegativeMultiply
(
imageSize
.
height
scale
)
;
}
}
}
return
imageSize
;
}
static
nscoord
ComputeSpacedRepeatSize
(
nscoord
aImageDimension
nscoord
aAvailableSpace
bool
&
aRepeat
)
{
float
ratio
=
static_cast
<
float
>
(
aAvailableSpace
)
/
aImageDimension
;
if
(
ratio
<
2
.
0f
)
{
aRepeat
=
false
;
return
aImageDimension
;
}
aRepeat
=
true
;
return
(
aAvailableSpace
-
aImageDimension
)
/
(
NSToIntFloor
(
ratio
)
-
1
)
;
}
nscoord
nsCSSRendering
:
:
ComputeBorderSpacedRepeatSize
(
nscoord
aImageDimension
nscoord
aAvailableSpace
nscoord
&
aSpace
)
{
int32_t
count
=
aImageDimension
?
(
aAvailableSpace
/
aImageDimension
)
:
0
;
aSpace
=
(
aAvailableSpace
-
aImageDimension
*
count
)
/
(
count
+
1
)
;
return
aSpace
+
aImageDimension
;
}
nsBackgroundLayerState
nsCSSRendering
:
:
PrepareImageLayer
(
nsPresContext
*
aPresContext
nsIFrame
*
aForFrame
uint32_t
aFlags
const
nsRect
&
aBorderArea
const
nsRect
&
aBGClipRect
const
nsStyleImageLayers
:
:
Layer
&
aLayer
bool
*
aOutIsTransformedFixed
)
{
uint32_t
irFlags
=
0
;
if
(
aFlags
&
nsCSSRendering
:
:
PAINTBG_SYNC_DECODE_IMAGES
)
{
irFlags
|
=
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
;
}
if
(
aFlags
&
nsCSSRendering
:
:
PAINTBG_TO_WINDOW
)
{
irFlags
|
=
nsImageRenderer
:
:
FLAG_PAINTING_TO_WINDOW
;
}
nsBackgroundLayerState
state
(
aForFrame
&
aLayer
.
mImage
irFlags
)
;
if
(
!
state
.
mImageRenderer
.
PrepareImage
(
)
)
{
if
(
aOutIsTransformedFixed
&
&
StyleImageLayerAttachment
:
:
Fixed
=
=
aLayer
.
mAttachment
)
{
nsIFrame
*
attachedToFrame
=
aPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
NS_ASSERTION
(
attachedToFrame
"
no
root
frame
"
)
;
nsIFrame
*
pageContentFrame
=
nullptr
;
if
(
aPresContext
-
>
IsPaginated
(
)
)
{
pageContentFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aForFrame
LayoutFrameType
:
:
PageContent
)
;
if
(
pageContentFrame
)
{
attachedToFrame
=
pageContentFrame
;
}
}
*
aOutIsTransformedFixed
=
nsLayoutUtils
:
:
IsTransformed
(
aForFrame
attachedToFrame
)
;
}
return
state
;
}
nsIFrame
*
attachedToFrame
=
aForFrame
;
bool
transformedFixed
=
false
;
nsRect
positionArea
=
ComputeImageLayerPositioningArea
(
aPresContext
aForFrame
aBorderArea
aLayer
&
attachedToFrame
&
transformedFixed
)
;
if
(
aOutIsTransformedFixed
)
{
*
aOutIsTransformedFixed
=
transformedFixed
;
}
nsRect
bgClipRect
=
aBGClipRect
;
if
(
StyleImageLayerAttachment
:
:
Fixed
=
=
aLayer
.
mAttachment
&
&
!
transformedFixed
&
&
(
aFlags
&
nsCSSRendering
:
:
PAINTBG_TO_WINDOW
)
)
{
bgClipRect
=
positionArea
+
aBorderArea
.
TopLeft
(
)
;
}
StyleImageLayerRepeat
repeatX
=
aLayer
.
mRepeat
.
mXRepeat
;
StyleImageLayerRepeat
repeatY
=
aLayer
.
mRepeat
.
mYRepeat
;
CSSSizeOrRatio
intrinsicSize
=
state
.
mImageRenderer
.
ComputeIntrinsicSize
(
)
;
nsSize
bgPositionSize
=
positionArea
.
Size
(
)
;
nsSize
imageSize
=
ComputeDrawnSizeForBackground
(
intrinsicSize
bgPositionSize
aLayer
.
mSize
repeatX
repeatY
)
;
if
(
imageSize
.
width
<
=
0
|
|
imageSize
.
height
<
=
0
)
return
state
;
state
.
mImageRenderer
.
SetPreferredSize
(
intrinsicSize
imageSize
)
;
nsPoint
imageTopLeft
;
nsImageRenderer
:
:
ComputeObjectAnchorPoint
(
aLayer
.
mPosition
bgPositionSize
imageSize
&
imageTopLeft
&
state
.
mAnchor
)
;
state
.
mRepeatSize
=
imageSize
;
if
(
repeatX
=
=
StyleImageLayerRepeat
:
:
Space
)
{
bool
isRepeat
;
state
.
mRepeatSize
.
width
=
ComputeSpacedRepeatSize
(
imageSize
.
width
bgPositionSize
.
width
isRepeat
)
;
if
(
isRepeat
)
{
imageTopLeft
.
x
=
0
;
state
.
mAnchor
.
x
=
0
;
}
else
{
repeatX
=
StyleImageLayerRepeat
:
:
NoRepeat
;
}
}
if
(
repeatY
=
=
StyleImageLayerRepeat
:
:
Space
)
{
bool
isRepeat
;
state
.
mRepeatSize
.
height
=
ComputeSpacedRepeatSize
(
imageSize
.
height
bgPositionSize
.
height
isRepeat
)
;
if
(
isRepeat
)
{
imageTopLeft
.
y
=
0
;
state
.
mAnchor
.
y
=
0
;
}
else
{
repeatY
=
StyleImageLayerRepeat
:
:
NoRepeat
;
}
}
imageTopLeft
+
=
positionArea
.
TopLeft
(
)
;
state
.
mAnchor
+
=
positionArea
.
TopLeft
(
)
;
state
.
mDestArea
=
nsRect
(
imageTopLeft
+
aBorderArea
.
TopLeft
(
)
imageSize
)
;
state
.
mFillArea
=
state
.
mDestArea
;
ExtendMode
repeatMode
=
ExtendMode
:
:
CLAMP
;
if
(
repeatX
=
=
StyleImageLayerRepeat
:
:
Repeat
|
|
repeatX
=
=
StyleImageLayerRepeat
:
:
Round
|
|
repeatX
=
=
StyleImageLayerRepeat
:
:
Space
)
{
state
.
mFillArea
.
x
=
bgClipRect
.
x
;
state
.
mFillArea
.
width
=
bgClipRect
.
width
;
repeatMode
=
ExtendMode
:
:
REPEAT_X
;
}
if
(
repeatY
=
=
StyleImageLayerRepeat
:
:
Repeat
|
|
repeatY
=
=
StyleImageLayerRepeat
:
:
Round
|
|
repeatY
=
=
StyleImageLayerRepeat
:
:
Space
)
{
state
.
mFillArea
.
y
=
bgClipRect
.
y
;
state
.
mFillArea
.
height
=
bgClipRect
.
height
;
if
(
repeatMode
=
=
ExtendMode
:
:
REPEAT_X
)
{
repeatMode
=
ExtendMode
:
:
REPEAT
;
}
else
{
repeatMode
=
ExtendMode
:
:
REPEAT_Y
;
}
}
state
.
mImageRenderer
.
SetExtendMode
(
repeatMode
)
;
state
.
mImageRenderer
.
SetMaskOp
(
aLayer
.
mMaskMode
)
;
state
.
mFillArea
.
IntersectRect
(
state
.
mFillArea
bgClipRect
)
;
return
state
;
}
nsRect
nsCSSRendering
:
:
GetBackgroundLayerRect
(
nsPresContext
*
aPresContext
nsIFrame
*
aForFrame
const
nsRect
&
aBorderArea
const
nsRect
&
aClipRect
const
nsStyleImageLayers
:
:
Layer
&
aLayer
uint32_t
aFlags
)
{
Sides
skipSides
=
aForFrame
-
>
GetSkipSides
(
)
;
nsRect
borderArea
=
BoxDecorationRectForBackground
(
aForFrame
aBorderArea
skipSides
)
;
nsBackgroundLayerState
state
=
PrepareImageLayer
(
aPresContext
aForFrame
aFlags
borderArea
aClipRect
aLayer
)
;
return
state
.
mFillArea
;
}
static
nscoord
RoundIntToPixel
(
nscoord
aValue
nscoord
aOneDevPixel
bool
aRoundDown
=
false
)
{
if
(
aOneDevPixel
<
=
0
)
return
aValue
;
nscoord
halfPixel
=
NSToCoordRound
(
aOneDevPixel
/
2
.
0f
)
;
nscoord
extra
=
aValue
%
aOneDevPixel
;
nscoord
finalValue
=
(
!
aRoundDown
&
&
(
extra
>
=
halfPixel
)
)
?
aValue
+
(
aOneDevPixel
-
extra
)
:
aValue
-
extra
;
return
finalValue
;
}
static
nscoord
RoundFloatToPixel
(
float
aValue
nscoord
aOneDevPixel
bool
aRoundDown
=
false
)
{
return
RoundIntToPixel
(
NSToCoordRound
(
aValue
)
aOneDevPixel
aRoundDown
)
;
}
static
void
SetPoly
(
const
Rect
&
aRect
Point
*
poly
)
{
poly
[
0
]
.
x
=
aRect
.
x
;
poly
[
0
]
.
y
=
aRect
.
y
;
poly
[
1
]
.
x
=
aRect
.
x
+
aRect
.
width
;
poly
[
1
]
.
y
=
aRect
.
y
;
poly
[
2
]
.
x
=
aRect
.
x
+
aRect
.
width
;
poly
[
2
]
.
y
=
aRect
.
y
+
aRect
.
height
;
poly
[
3
]
.
x
=
aRect
.
x
;
poly
[
3
]
.
y
=
aRect
.
y
+
aRect
.
height
;
}
static
void
DrawDashedSegment
(
DrawTarget
&
aDrawTarget
nsRect
aRect
nscoord
aDashLength
nscolor
aColor
int32_t
aAppUnitsPerDevPixel
bool
aHorizontal
)
{
ColorPattern
color
(
ToDeviceColor
(
aColor
)
)
;
DrawOptions
drawOptions
(
1
.
f
CompositionOp
:
:
OP_OVER
AntialiasMode
:
:
NONE
)
;
StrokeOptions
strokeOptions
;
Float
dash
[
2
]
;
dash
[
0
]
=
Float
(
aDashLength
)
/
aAppUnitsPerDevPixel
;
dash
[
1
]
=
dash
[
0
]
;
strokeOptions
.
mDashPattern
=
dash
;
strokeOptions
.
mDashLength
=
MOZ_ARRAY_LENGTH
(
dash
)
;
if
(
aHorizontal
)
{
nsPoint
left
=
(
aRect
.
TopLeft
(
)
+
aRect
.
BottomLeft
(
)
)
/
2
;
nsPoint
right
=
(
aRect
.
TopRight
(
)
+
aRect
.
BottomRight
(
)
)
/
2
;
strokeOptions
.
mLineWidth
=
Float
(
aRect
.
height
)
/
aAppUnitsPerDevPixel
;
StrokeLineWithSnapping
(
left
right
aAppUnitsPerDevPixel
aDrawTarget
color
strokeOptions
drawOptions
)
;
}
else
{
nsPoint
top
=
(
aRect
.
TopLeft
(
)
+
aRect
.
TopRight
(
)
)
/
2
;
nsPoint
bottom
=
(
aRect
.
BottomLeft
(
)
+
aRect
.
BottomRight
(
)
)
/
2
;
strokeOptions
.
mLineWidth
=
Float
(
aRect
.
width
)
/
aAppUnitsPerDevPixel
;
StrokeLineWithSnapping
(
top
bottom
aAppUnitsPerDevPixel
aDrawTarget
color
strokeOptions
drawOptions
)
;
}
}
static
void
DrawSolidBorderSegment
(
DrawTarget
&
aDrawTarget
nsRect
aRect
nscolor
aColor
int32_t
aAppUnitsPerDevPixel
mozilla
:
:
Side
aStartBevelSide
=
mozilla
:
:
eSideTop
nscoord
aStartBevelOffset
=
0
mozilla
:
:
Side
aEndBevelSide
=
mozilla
:
:
eSideTop
nscoord
aEndBevelOffset
=
0
)
{
ColorPattern
color
(
ToDeviceColor
(
aColor
)
)
;
DrawOptions
drawOptions
(
1
.
f
CompositionOp
:
:
OP_OVER
AntialiasMode
:
:
NONE
)
;
nscoord
oneDevPixel
=
NSIntPixelsToAppUnits
(
1
aAppUnitsPerDevPixel
)
;
if
(
(
aRect
.
width
=
=
oneDevPixel
)
|
|
(
aRect
.
height
=
=
oneDevPixel
)
|
|
(
(
0
=
=
aStartBevelOffset
)
&
&
(
0
=
=
aEndBevelOffset
)
)
)
{
aDrawTarget
.
FillRect
(
NSRectToSnappedRect
(
aRect
aAppUnitsPerDevPixel
aDrawTarget
)
color
drawOptions
)
;
}
else
{
Point
poly
[
4
]
;
SetPoly
(
NSRectToSnappedRect
(
aRect
aAppUnitsPerDevPixel
aDrawTarget
)
poly
)
;
Float
startBevelOffset
=
NSAppUnitsToFloatPixels
(
aStartBevelOffset
aAppUnitsPerDevPixel
)
;
switch
(
aStartBevelSide
)
{
case
eSideTop
:
poly
[
0
]
.
x
+
=
startBevelOffset
;
break
;
case
eSideBottom
:
poly
[
3
]
.
x
+
=
startBevelOffset
;
break
;
case
eSideRight
:
poly
[
1
]
.
y
+
=
startBevelOffset
;
break
;
case
eSideLeft
:
poly
[
0
]
.
y
+
=
startBevelOffset
;
}
Float
endBevelOffset
=
NSAppUnitsToFloatPixels
(
aEndBevelOffset
aAppUnitsPerDevPixel
)
;
switch
(
aEndBevelSide
)
{
case
eSideTop
:
poly
[
1
]
.
x
-
=
endBevelOffset
;
break
;
case
eSideBottom
:
poly
[
2
]
.
x
-
=
endBevelOffset
;
break
;
case
eSideRight
:
poly
[
2
]
.
y
-
=
endBevelOffset
;
break
;
case
eSideLeft
:
poly
[
3
]
.
y
-
=
endBevelOffset
;
}
RefPtr
<
PathBuilder
>
builder
=
aDrawTarget
.
CreatePathBuilder
(
)
;
builder
-
>
MoveTo
(
poly
[
0
]
)
;
builder
-
>
LineTo
(
poly
[
1
]
)
;
builder
-
>
LineTo
(
poly
[
2
]
)
;
builder
-
>
LineTo
(
poly
[
3
]
)
;
builder
-
>
Close
(
)
;
RefPtr
<
Path
>
path
=
builder
-
>
Finish
(
)
;
aDrawTarget
.
Fill
(
path
color
drawOptions
)
;
}
}
static
void
GetDashInfo
(
nscoord
aBorderLength
nscoord
aDashLength
nscoord
aOneDevPixel
int32_t
&
aNumDashSpaces
nscoord
&
aStartDashLength
nscoord
&
aEndDashLength
)
{
aNumDashSpaces
=
0
;
if
(
aStartDashLength
+
aDashLength
+
aEndDashLength
>
=
aBorderLength
)
{
aStartDashLength
=
aBorderLength
;
aEndDashLength
=
0
;
}
else
{
aNumDashSpaces
=
(
aBorderLength
-
aDashLength
)
/
(
2
*
aDashLength
)
;
nscoord
extra
=
aBorderLength
-
aStartDashLength
-
aEndDashLength
-
(
(
(
2
*
aNumDashSpaces
)
-
1
)
*
aDashLength
)
;
if
(
extra
>
0
)
{
nscoord
half
=
RoundIntToPixel
(
extra
/
2
aOneDevPixel
)
;
aStartDashLength
+
=
half
;
aEndDashLength
+
=
(
extra
-
half
)
;
}
}
}
void
nsCSSRendering
:
:
DrawTableBorderSegment
(
DrawTarget
&
aDrawTarget
StyleBorderStyle
aBorderStyle
nscolor
aBorderColor
const
nsRect
&
aBorder
int32_t
aAppUnitsPerDevPixel
mozilla
:
:
Side
aStartBevelSide
nscoord
aStartBevelOffset
mozilla
:
:
Side
aEndBevelSide
nscoord
aEndBevelOffset
)
{
bool
horizontal
=
(
(
eSideTop
=
=
aStartBevelSide
)
|
|
(
eSideBottom
=
=
aStartBevelSide
)
)
;
nscoord
oneDevPixel
=
NSIntPixelsToAppUnits
(
1
aAppUnitsPerDevPixel
)
;
if
(
(
oneDevPixel
>
=
aBorder
.
width
)
|
|
(
oneDevPixel
>
=
aBorder
.
height
)
|
|
(
StyleBorderStyle
:
:
Dashed
=
=
aBorderStyle
)
|
|
(
StyleBorderStyle
:
:
Dotted
=
=
aBorderStyle
)
)
{
aStartBevelOffset
=
0
;
aEndBevelOffset
=
0
;
}
switch
(
aBorderStyle
)
{
case
StyleBorderStyle
:
:
None
:
case
StyleBorderStyle
:
:
Hidden
:
break
;
case
StyleBorderStyle
:
:
Dotted
:
case
StyleBorderStyle
:
:
Dashed
:
{
nscoord
dashLength
=
(
StyleBorderStyle
:
:
Dashed
=
=
aBorderStyle
)
?
DASH_LENGTH
:
DOT_LENGTH
;
dashLength
*
=
(
horizontal
)
?
aBorder
.
height
:
aBorder
.
width
;
nscoord
minDashLength
=
(
StyleBorderStyle
:
:
Dashed
=
=
aBorderStyle
)
?
RoundFloatToPixel
(
(
(
float
)
dashLength
)
/
2
.
0f
aAppUnitsPerDevPixel
)
:
dashLength
;
minDashLength
=
std
:
:
max
(
minDashLength
oneDevPixel
)
;
nscoord
numDashSpaces
=
0
;
nscoord
startDashLength
=
minDashLength
;
nscoord
endDashLength
=
minDashLength
;
if
(
horizontal
)
{
GetDashInfo
(
aBorder
.
width
dashLength
aAppUnitsPerDevPixel
numDashSpaces
startDashLength
endDashLength
)
;
nsRect
rect
(
aBorder
.
x
aBorder
.
y
startDashLength
aBorder
.
height
)
;
DrawSolidBorderSegment
(
aDrawTarget
rect
aBorderColor
aAppUnitsPerDevPixel
)
;
rect
.
x
+
=
startDashLength
+
dashLength
;
rect
.
width
=
aBorder
.
width
-
(
startDashLength
+
endDashLength
+
dashLength
)
;
DrawDashedSegment
(
aDrawTarget
rect
dashLength
aBorderColor
aAppUnitsPerDevPixel
horizontal
)
;
rect
.
x
+
=
rect
.
width
;
rect
.
width
=
endDashLength
;
DrawSolidBorderSegment
(
aDrawTarget
rect
aBorderColor
aAppUnitsPerDevPixel
)
;
}
else
{
GetDashInfo
(
aBorder
.
height
dashLength
aAppUnitsPerDevPixel
numDashSpaces
startDashLength
endDashLength
)
;
nsRect
rect
(
aBorder
.
x
aBorder
.
y
aBorder
.
width
startDashLength
)
;
DrawSolidBorderSegment
(
aDrawTarget
rect
aBorderColor
aAppUnitsPerDevPixel
)
;
rect
.
y
+
=
rect
.
height
+
dashLength
;
rect
.
height
=
aBorder
.
height
-
(
startDashLength
+
endDashLength
+
dashLength
)
;
DrawDashedSegment
(
aDrawTarget
rect
dashLength
aBorderColor
aAppUnitsPerDevPixel
horizontal
)
;
rect
.
y
+
=
rect
.
height
;
rect
.
height
=
endDashLength
;
DrawSolidBorderSegment
(
aDrawTarget
rect
aBorderColor
aAppUnitsPerDevPixel
)
;
}
}
break
;
default
:
AutoTArray
<
SolidBeveledBorderSegment
3
>
segments
;
GetTableBorderSolidSegments
(
segments
aBorderStyle
aBorderColor
aBorder
aAppUnitsPerDevPixel
aStartBevelSide
aStartBevelOffset
aEndBevelSide
aEndBevelOffset
)
;
for
(
const
auto
&
segment
:
segments
)
{
DrawSolidBorderSegment
(
aDrawTarget
segment
.
mRect
segment
.
mColor
aAppUnitsPerDevPixel
segment
.
mStartBevel
.
mSide
segment
.
mStartBevel
.
mOffset
segment
.
mEndBevel
.
mSide
segment
.
mEndBevel
.
mOffset
)
;
}
break
;
}
}
void
nsCSSRendering
:
:
GetTableBorderSolidSegments
(
nsTArray
<
SolidBeveledBorderSegment
>
&
aSegments
StyleBorderStyle
aBorderStyle
nscolor
aBorderColor
const
nsRect
&
aBorder
int32_t
aAppUnitsPerDevPixel
mozilla
:
:
Side
aStartBevelSide
nscoord
aStartBevelOffset
mozilla
:
:
Side
aEndBevelSide
nscoord
aEndBevelOffset
)
{
const
bool
horizontal
=
eSideTop
=
=
aStartBevelSide
|
|
eSideBottom
=
=
aStartBevelSide
;
const
nscoord
oneDevPixel
=
NSIntPixelsToAppUnits
(
1
aAppUnitsPerDevPixel
)
;
switch
(
aBorderStyle
)
{
case
StyleBorderStyle
:
:
None
:
case
StyleBorderStyle
:
:
Hidden
:
return
;
case
StyleBorderStyle
:
:
Dotted
:
case
StyleBorderStyle
:
:
Dashed
:
MOZ_ASSERT_UNREACHABLE
(
"
Caller
should
have
checked
"
)
;
return
;
case
StyleBorderStyle
:
:
Groove
:
case
StyleBorderStyle
:
:
Ridge
:
if
(
(
horizontal
&
&
(
oneDevPixel
>
=
aBorder
.
height
)
)
|
|
(
!
horizontal
&
&
(
oneDevPixel
>
=
aBorder
.
width
)
)
)
{
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
aBorder
aBorderColor
{
aStartBevelSide
aStartBevelOffset
}
{
aEndBevelSide
aEndBevelOffset
}
}
)
;
}
else
{
nscoord
startBevel
=
(
aStartBevelOffset
>
0
)
?
RoundFloatToPixel
(
0
.
5f
*
(
float
)
aStartBevelOffset
aAppUnitsPerDevPixel
true
)
:
0
;
nscoord
endBevel
=
(
aEndBevelOffset
>
0
)
?
RoundFloatToPixel
(
0
.
5f
*
(
float
)
aEndBevelOffset
aAppUnitsPerDevPixel
true
)
:
0
;
mozilla
:
:
Side
ridgeGrooveSide
=
(
horizontal
)
?
eSideTop
:
eSideLeft
;
nscolor
bevelColor
=
MakeBevelColor
(
ridgeGrooveSide
aBorderStyle
aBorderColor
)
;
nsRect
rect
(
aBorder
)
;
nscoord
half
;
if
(
horizontal
)
{
half
=
RoundFloatToPixel
(
0
.
5f
*
(
float
)
aBorder
.
height
aAppUnitsPerDevPixel
)
;
rect
.
height
=
half
;
if
(
eSideTop
=
=
aStartBevelSide
)
{
rect
.
x
+
=
startBevel
;
rect
.
width
-
=
startBevel
;
}
if
(
eSideTop
=
=
aEndBevelSide
)
{
rect
.
width
-
=
endBevel
;
}
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
rect
bevelColor
{
aStartBevelSide
startBevel
}
{
aEndBevelSide
endBevel
}
}
)
;
}
else
{
half
=
RoundFloatToPixel
(
0
.
5f
*
(
float
)
aBorder
.
width
aAppUnitsPerDevPixel
)
;
rect
.
width
=
half
;
if
(
eSideLeft
=
=
aStartBevelSide
)
{
rect
.
y
+
=
startBevel
;
rect
.
height
-
=
startBevel
;
}
if
(
eSideLeft
=
=
aEndBevelSide
)
{
rect
.
height
-
=
endBevel
;
}
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
rect
bevelColor
{
aStartBevelSide
startBevel
}
{
aEndBevelSide
endBevel
}
}
)
;
}
rect
=
aBorder
;
ridgeGrooveSide
=
(
eSideTop
=
=
ridgeGrooveSide
)
?
eSideBottom
:
eSideRight
;
bevelColor
=
MakeBevelColor
(
ridgeGrooveSide
aBorderStyle
aBorderColor
)
;
if
(
horizontal
)
{
rect
.
y
=
rect
.
y
+
half
;
rect
.
height
=
aBorder
.
height
-
half
;
if
(
eSideBottom
=
=
aStartBevelSide
)
{
rect
.
x
+
=
startBevel
;
rect
.
width
-
=
startBevel
;
}
if
(
eSideBottom
=
=
aEndBevelSide
)
{
rect
.
width
-
=
endBevel
;
}
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
rect
bevelColor
{
aStartBevelSide
startBevel
}
{
aEndBevelSide
endBevel
}
}
)
;
}
else
{
rect
.
x
=
rect
.
x
+
half
;
rect
.
width
=
aBorder
.
width
-
half
;
if
(
eSideRight
=
=
aStartBevelSide
)
{
rect
.
y
+
=
aStartBevelOffset
-
startBevel
;
rect
.
height
-
=
startBevel
;
}
if
(
eSideRight
=
=
aEndBevelSide
)
{
rect
.
height
-
=
endBevel
;
}
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
rect
bevelColor
{
aStartBevelSide
startBevel
}
{
aEndBevelSide
endBevel
}
}
)
;
}
}
break
;
case
StyleBorderStyle
:
:
Double
:
if
(
(
aBorder
.
width
>
2
*
oneDevPixel
|
|
horizontal
)
&
&
(
aBorder
.
height
>
2
*
oneDevPixel
|
|
!
horizontal
)
)
{
nscoord
startBevel
=
(
aStartBevelOffset
>
0
)
?
RoundFloatToPixel
(
0
.
333333f
*
(
float
)
aStartBevelOffset
aAppUnitsPerDevPixel
)
:
0
;
nscoord
endBevel
=
(
aEndBevelOffset
>
0
)
?
RoundFloatToPixel
(
0
.
333333f
*
(
float
)
aEndBevelOffset
aAppUnitsPerDevPixel
)
:
0
;
if
(
horizontal
)
{
nscoord
thirdHeight
=
RoundFloatToPixel
(
0
.
333333f
*
(
float
)
aBorder
.
height
aAppUnitsPerDevPixel
)
;
nsRect
topRect
(
aBorder
.
x
aBorder
.
y
aBorder
.
width
thirdHeight
)
;
if
(
eSideTop
=
=
aStartBevelSide
)
{
topRect
.
x
+
=
aStartBevelOffset
-
startBevel
;
topRect
.
width
-
=
aStartBevelOffset
-
startBevel
;
}
if
(
eSideTop
=
=
aEndBevelSide
)
{
topRect
.
width
-
=
aEndBevelOffset
-
endBevel
;
}
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
topRect
aBorderColor
{
aStartBevelSide
startBevel
}
{
aEndBevelSide
endBevel
}
}
)
;
nscoord
heightOffset
=
aBorder
.
height
-
thirdHeight
;
nsRect
bottomRect
(
aBorder
.
x
aBorder
.
y
+
heightOffset
aBorder
.
width
aBorder
.
height
-
heightOffset
)
;
if
(
eSideBottom
=
=
aStartBevelSide
)
{
bottomRect
.
x
+
=
aStartBevelOffset
-
startBevel
;
bottomRect
.
width
-
=
aStartBevelOffset
-
startBevel
;
}
if
(
eSideBottom
=
=
aEndBevelSide
)
{
bottomRect
.
width
-
=
aEndBevelOffset
-
endBevel
;
}
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
bottomRect
aBorderColor
{
aStartBevelSide
startBevel
}
{
aEndBevelSide
endBevel
}
}
)
;
}
else
{
nscoord
thirdWidth
=
RoundFloatToPixel
(
0
.
333333f
*
(
float
)
aBorder
.
width
aAppUnitsPerDevPixel
)
;
nsRect
leftRect
(
aBorder
.
x
aBorder
.
y
thirdWidth
aBorder
.
height
)
;
if
(
eSideLeft
=
=
aStartBevelSide
)
{
leftRect
.
y
+
=
aStartBevelOffset
-
startBevel
;
leftRect
.
height
-
=
aStartBevelOffset
-
startBevel
;
}
if
(
eSideLeft
=
=
aEndBevelSide
)
{
leftRect
.
height
-
=
aEndBevelOffset
-
endBevel
;
}
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
leftRect
aBorderColor
{
aStartBevelSide
startBevel
}
{
aEndBevelSide
endBevel
}
}
)
;
nscoord
widthOffset
=
aBorder
.
width
-
thirdWidth
;
nsRect
rightRect
(
aBorder
.
x
+
widthOffset
aBorder
.
y
aBorder
.
width
-
widthOffset
aBorder
.
height
)
;
if
(
eSideRight
=
=
aStartBevelSide
)
{
rightRect
.
y
+
=
aStartBevelOffset
-
startBevel
;
rightRect
.
height
-
=
aStartBevelOffset
-
startBevel
;
}
if
(
eSideRight
=
=
aEndBevelSide
)
{
rightRect
.
height
-
=
aEndBevelOffset
-
endBevel
;
}
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
rightRect
aBorderColor
{
aStartBevelSide
startBevel
}
{
aEndBevelSide
endBevel
}
}
)
;
}
break
;
}
MOZ_FALLTHROUGH
;
case
StyleBorderStyle
:
:
Solid
:
aSegments
.
AppendElement
(
SolidBeveledBorderSegment
{
aBorder
aBorderColor
{
aStartBevelSide
aStartBevelOffset
}
{
aEndBevelSide
aEndBevelOffset
}
}
)
;
break
;
case
StyleBorderStyle
:
:
Outset
:
case
StyleBorderStyle
:
:
Inset
:
MOZ_ASSERT_UNREACHABLE
(
"
inset
outset
should
have
been
converted
to
groove
ridge
"
)
;
break
;
}
}
Rect
nsCSSRendering
:
:
ExpandPaintingRectForDecorationLine
(
nsIFrame
*
aFrame
const
uint8_t
aStyle
const
Rect
&
aClippedRect
const
Float
aICoordInFrame
const
Float
aCycleLength
bool
aVertical
)
{
switch
(
aStyle
)
{
case
NS_STYLE_TEXT_DECORATION_STYLE_DOTTED
:
case
NS_STYLE_TEXT_DECORATION_STYLE_DASHED
:
case
NS_STYLE_TEXT_DECORATION_STYLE_WAVY
:
break
;
default
:
NS_ERROR
(
"
Invalid
style
was
specified
"
)
;
return
aClippedRect
;
}
nsBlockFrame
*
block
=
nullptr
;
nscoord
framePosInBlockAppUnits
=
0
;
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
block
=
do_QueryFrame
(
f
)
;
if
(
block
)
{
break
;
}
framePosInBlockAppUnits
+
=
aVertical
?
f
-
>
GetNormalPosition
(
)
.
y
:
f
-
>
GetNormalPosition
(
)
.
x
;
}
NS_ENSURE_TRUE
(
block
aClippedRect
)
;
nsPresContext
*
pc
=
aFrame
-
>
PresContext
(
)
;
Float
framePosInBlock
=
Float
(
pc
-
>
AppUnitsToGfxUnits
(
framePosInBlockAppUnits
)
)
;
int32_t
rectPosInBlock
=
int32_t
(
NS_round
(
framePosInBlock
+
aICoordInFrame
)
)
;
int32_t
extraStartEdge
=
rectPosInBlock
-
(
rectPosInBlock
/
int32_t
(
aCycleLength
)
*
aCycleLength
)
;
Rect
rect
(
aClippedRect
)
;
if
(
aVertical
)
{
rect
.
y
-
=
extraStartEdge
;
rect
.
height
+
=
extraStartEdge
;
}
else
{
rect
.
x
-
=
extraStartEdge
;
rect
.
width
+
=
extraStartEdge
;
}
return
rect
;
}
void
nsCSSRendering
:
:
PaintDecorationLine
(
nsIFrame
*
aFrame
DrawTarget
&
aDrawTarget
const
PaintDecorationLineParams
&
aParams
)
{
NS_ASSERTION
(
aParams
.
style
!
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
"
aStyle
is
none
"
)
;
Rect
rect
=
ToRect
(
GetTextDecorationRectInternal
(
aParams
.
pt
aParams
)
)
;
if
(
rect
.
IsEmpty
(
)
|
|
!
rect
.
Intersects
(
aParams
.
dirtyRect
)
)
{
return
;
}
if
(
aParams
.
decoration
!
=
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
&
&
aParams
.
decoration
!
=
NS_STYLE_TEXT_DECORATION_LINE_OVERLINE
&
&
aParams
.
decoration
!
=
NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH
)
{
NS_ERROR
(
"
Invalid
decoration
value
!
"
)
;
return
;
}
Float
lineThickness
=
std
:
:
max
(
NS_round
(
aParams
.
lineSize
.
height
)
1
.
0
)
;
Color
color
=
ToDeviceColor
(
aParams
.
color
)
;
ColorPattern
colorPat
(
color
)
;
StrokeOptions
strokeOptions
(
lineThickness
)
;
DrawOptions
drawOptions
;
Float
dash
[
2
]
;
AutoPopClips
autoPopClips
(
&
aDrawTarget
)
;
mozilla
:
:
layout
:
:
TextDrawTarget
*
textDrawer
=
nullptr
;
if
(
aDrawTarget
.
GetBackendType
(
)
=
=
BackendType
:
:
WEBRENDER_TEXT
)
{
textDrawer
=
static_cast
<
mozilla
:
:
layout
:
:
TextDrawTarget
*
>
(
&
aDrawTarget
)
;
}
switch
(
aParams
.
style
)
{
case
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
:
case
NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE
:
break
;
case
NS_STYLE_TEXT_DECORATION_STYLE_DASHED
:
{
autoPopClips
.
PushClipRect
(
rect
)
;
Float
dashWidth
=
lineThickness
*
DOT_LENGTH
*
DASH_LENGTH
;
dash
[
0
]
=
dashWidth
;
dash
[
1
]
=
dashWidth
;
strokeOptions
.
mDashPattern
=
dash
;
strokeOptions
.
mDashLength
=
MOZ_ARRAY_LENGTH
(
dash
)
;
strokeOptions
.
mLineCap
=
CapStyle
:
:
BUTT
;
rect
=
ExpandPaintingRectForDecorationLine
(
aFrame
aParams
.
style
rect
aParams
.
icoordInFrame
dashWidth
*
2
aParams
.
vertical
)
;
rect
.
width
+
=
dashWidth
;
break
;
}
case
NS_STYLE_TEXT_DECORATION_STYLE_DOTTED
:
{
autoPopClips
.
PushClipRect
(
rect
)
;
Float
dashWidth
=
lineThickness
*
DOT_LENGTH
;
if
(
lineThickness
>
2
.
0
)
{
dash
[
0
]
=
0
.
f
;
dash
[
1
]
=
dashWidth
*
2
.
f
;
strokeOptions
.
mLineCap
=
CapStyle
:
:
ROUND
;
}
else
{
dash
[
0
]
=
dashWidth
;
dash
[
1
]
=
dashWidth
;
}
strokeOptions
.
mDashPattern
=
dash
;
strokeOptions
.
mDashLength
=
MOZ_ARRAY_LENGTH
(
dash
)
;
rect
=
ExpandPaintingRectForDecorationLine
(
aFrame
aParams
.
style
rect
aParams
.
icoordInFrame
dashWidth
*
2
aParams
.
vertical
)
;
rect
.
width
+
=
dashWidth
;
break
;
}
case
NS_STYLE_TEXT_DECORATION_STYLE_WAVY
:
autoPopClips
.
PushClipRect
(
rect
)
;
if
(
lineThickness
>
2
.
0
)
{
drawOptions
.
mAntialiasMode
=
AntialiasMode
:
:
SUBPIXEL
;
}
else
{
drawOptions
.
mAntialiasMode
=
AntialiasMode
:
:
NONE
;
}
break
;
default
:
NS_ERROR
(
"
Invalid
style
value
!
"
)
;
return
;
}
if
(
aParams
.
vertical
)
{
rect
.
x
+
=
lineThickness
/
2
;
}
else
{
rect
.
y
+
=
lineThickness
/
2
;
}
switch
(
aParams
.
style
)
{
case
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
:
case
NS_STYLE_TEXT_DECORATION_STYLE_DOTTED
:
case
NS_STYLE_TEXT_DECORATION_STYLE_DASHED
:
{
Point
p1
=
rect
.
TopLeft
(
)
;
Point
p2
=
aParams
.
vertical
?
rect
.
BottomLeft
(
)
:
rect
.
TopRight
(
)
;
if
(
textDrawer
)
{
textDrawer
-
>
AppendDecoration
(
p1
p2
lineThickness
aParams
.
vertical
color
aParams
.
style
)
;
}
else
{
aDrawTarget
.
StrokeLine
(
p1
p2
colorPat
strokeOptions
drawOptions
)
;
}
return
;
}
case
NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE
:
{
Point
p1a
=
rect
.
TopLeft
(
)
;
Point
p2a
=
aParams
.
vertical
?
rect
.
BottomLeft
(
)
:
rect
.
TopRight
(
)
;
if
(
aParams
.
vertical
)
{
rect
.
width
-
=
lineThickness
;
}
else
{
rect
.
height
-
=
lineThickness
;
}
Point
p1b
=
aParams
.
vertical
?
rect
.
TopRight
(
)
:
rect
.
BottomLeft
(
)
;
Point
p2b
=
rect
.
BottomRight
(
)
;
if
(
textDrawer
)
{
textDrawer
-
>
AppendDecoration
(
p1a
p2a
lineThickness
aParams
.
vertical
color
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
)
;
textDrawer
-
>
AppendDecoration
(
p1b
p2b
lineThickness
aParams
.
vertical
color
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
)
;
}
else
{
aDrawTarget
.
StrokeLine
(
p1a
p2a
colorPat
strokeOptions
drawOptions
)
;
aDrawTarget
.
StrokeLine
(
p1b
p2b
colorPat
strokeOptions
drawOptions
)
;
}
return
;
}
case
NS_STYLE_TEXT_DECORATION_STYLE_WAVY
:
{
Float
&
rectICoord
=
aParams
.
vertical
?
rect
.
y
:
rect
.
x
;
Float
&
rectISize
=
aParams
.
vertical
?
rect
.
height
:
rect
.
width
;
const
Float
rectBSize
=
aParams
.
vertical
?
rect
.
width
:
rect
.
height
;
const
Float
adv
=
rectBSize
-
lineThickness
;
const
Float
flatLengthAtVertex
=
std
:
:
max
(
(
lineThickness
-
1
.
0
)
*
2
.
0
1
.
0
)
;
const
Float
cycleLength
=
2
*
(
adv
+
flatLengthAtVertex
)
;
rect
=
ExpandPaintingRectForDecorationLine
(
aFrame
aParams
.
style
rect
aParams
.
icoordInFrame
cycleLength
aParams
.
vertical
)
;
if
(
textDrawer
)
{
Float
&
rectBCoord
=
aParams
.
vertical
?
rect
.
x
:
rect
.
y
;
rectBCoord
-
=
lineThickness
/
2
;
textDrawer
-
>
AppendWavyDecoration
(
rect
lineThickness
aParams
.
vertical
color
)
;
return
;
}
const
Float
dirtyRectICoord
=
aParams
.
vertical
?
aParams
.
dirtyRect
.
y
:
aParams
.
dirtyRect
.
x
;
int32_t
skipCycles
=
floor
(
(
dirtyRectICoord
-
rectICoord
)
/
cycleLength
)
;
if
(
skipCycles
>
0
)
{
rectICoord
+
=
skipCycles
*
cycleLength
;
rectISize
-
=
skipCycles
*
cycleLength
;
}
rectICoord
+
=
lineThickness
/
2
.
0
;
Point
pt
(
rect
.
TopLeft
(
)
)
;
Float
&
ptICoord
=
aParams
.
vertical
?
pt
.
y
:
pt
.
x
;
Float
&
ptBCoord
=
aParams
.
vertical
?
pt
.
x
:
pt
.
y
;
if
(
aParams
.
vertical
)
{
ptBCoord
+
=
adv
;
}
Float
iCoordLimit
=
ptICoord
+
rectISize
+
lineThickness
;
const
Float
dirtyRectIMost
=
aParams
.
vertical
?
aParams
.
dirtyRect
.
YMost
(
)
:
aParams
.
dirtyRect
.
XMost
(
)
;
skipCycles
=
floor
(
(
iCoordLimit
-
dirtyRectIMost
)
/
cycleLength
)
;
if
(
skipCycles
>
0
)
{
iCoordLimit
-
=
skipCycles
*
cycleLength
;
}
RefPtr
<
PathBuilder
>
builder
=
aDrawTarget
.
CreatePathBuilder
(
)
;
RefPtr
<
Path
>
path
;
ptICoord
-
=
lineThickness
;
builder
-
>
MoveTo
(
pt
)
;
ptICoord
=
rectICoord
;
builder
-
>
LineTo
(
pt
)
;
bool
goDown
=
aParams
.
vertical
?
false
:
true
;
uint32_t
iter
=
0
;
while
(
ptICoord
<
iCoordLimit
)
{
if
(
+
+
iter
>
1000
)
{
path
=
builder
-
>
Finish
(
)
;
aDrawTarget
.
Stroke
(
path
colorPat
strokeOptions
drawOptions
)
;
builder
=
aDrawTarget
.
CreatePathBuilder
(
)
;
builder
-
>
MoveTo
(
pt
)
;
iter
=
0
;
}
ptICoord
+
=
adv
;
ptBCoord
+
=
goDown
?
adv
:
-
adv
;
builder
-
>
LineTo
(
pt
)
;
ptICoord
+
=
flatLengthAtVertex
;
builder
-
>
LineTo
(
pt
)
;
goDown
=
!
goDown
;
}
path
=
builder
-
>
Finish
(
)
;
aDrawTarget
.
Stroke
(
path
colorPat
strokeOptions
drawOptions
)
;
return
;
}
default
:
NS_ERROR
(
"
Invalid
style
value
!
"
)
;
}
}
Rect
nsCSSRendering
:
:
DecorationLineToPath
(
const
PaintDecorationLineParams
&
aParams
)
{
NS_ASSERTION
(
aParams
.
style
!
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
"
aStyle
is
none
"
)
;
Rect
path
;
Rect
rect
=
ToRect
(
GetTextDecorationRectInternal
(
aParams
.
pt
aParams
)
)
;
if
(
rect
.
IsEmpty
(
)
|
|
!
rect
.
Intersects
(
aParams
.
dirtyRect
)
)
{
return
path
;
}
if
(
aParams
.
decoration
!
=
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
&
&
aParams
.
decoration
!
=
NS_STYLE_TEXT_DECORATION_LINE_OVERLINE
&
&
aParams
.
decoration
!
=
NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH
)
{
NS_ERROR
(
"
Invalid
decoration
value
!
"
)
;
return
path
;
}
if
(
aParams
.
style
!
=
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
)
{
return
path
;
}
Float
lineThickness
=
std
:
:
max
(
NS_round
(
aParams
.
lineSize
.
height
)
1
.
0
)
;
if
(
aParams
.
vertical
)
{
rect
.
x
+
=
lineThickness
/
2
;
path
=
Rect
(
rect
.
TopLeft
(
)
-
Point
(
lineThickness
/
2
0
.
0
)
Size
(
lineThickness
rect
.
Height
(
)
)
)
;
}
else
{
rect
.
y
+
=
lineThickness
/
2
;
path
=
Rect
(
rect
.
TopLeft
(
)
-
Point
(
0
.
0
lineThickness
/
2
)
Size
(
rect
.
Width
(
)
lineThickness
)
)
;
}
return
path
;
}
nsRect
nsCSSRendering
:
:
GetTextDecorationRect
(
nsPresContext
*
aPresContext
const
DecorationRectParams
&
aParams
)
{
NS_ASSERTION
(
aPresContext
"
aPresContext
is
null
"
)
;
NS_ASSERTION
(
aParams
.
style
!
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
"
aStyle
is
none
"
)
;
gfxRect
rect
=
GetTextDecorationRectInternal
(
Point
(
0
0
)
aParams
)
;
nsRect
r
;
r
.
x
=
aPresContext
-
>
GfxUnitsToAppUnits
(
rect
.
X
(
)
)
;
r
.
y
=
aPresContext
-
>
GfxUnitsToAppUnits
(
rect
.
Y
(
)
)
;
r
.
width
=
aPresContext
-
>
GfxUnitsToAppUnits
(
rect
.
Width
(
)
)
;
r
.
height
=
aPresContext
-
>
GfxUnitsToAppUnits
(
rect
.
Height
(
)
)
;
return
r
;
}
gfxRect
nsCSSRendering
:
:
GetTextDecorationRectInternal
(
const
Point
&
aPt
const
DecorationRectParams
&
aParams
)
{
NS_ASSERTION
(
aParams
.
style
<
=
NS_STYLE_TEXT_DECORATION_STYLE_WAVY
"
Invalid
aStyle
value
"
)
;
if
(
aParams
.
style
=
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
)
return
gfxRect
(
0
0
0
0
)
;
bool
canLiftUnderline
=
aParams
.
descentLimit
>
=
0
.
0
;
gfxFloat
iCoord
=
aParams
.
vertical
?
aPt
.
y
:
aPt
.
x
;
gfxFloat
bCoord
=
aParams
.
vertical
?
aPt
.
x
:
aPt
.
y
;
const
gfxFloat
left
=
floor
(
iCoord
+
0
.
5
)
right
=
floor
(
iCoord
+
aParams
.
lineSize
.
width
+
0
.
5
)
;
gfxRect
r
(
left
0
right
-
left
0
)
;
gfxFloat
lineThickness
=
NS_round
(
aParams
.
lineSize
.
height
)
;
lineThickness
=
std
:
:
max
(
lineThickness
1
.
0
)
;
gfxFloat
ascent
=
NS_round
(
aParams
.
ascent
)
;
gfxFloat
descentLimit
=
floor
(
aParams
.
descentLimit
)
;
gfxFloat
suggestedMaxRectHeight
=
std
:
:
max
(
std
:
:
min
(
ascent
descentLimit
)
1
.
0
)
;
r
.
height
=
lineThickness
;
if
(
aParams
.
style
=
=
NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE
)
{
gfxFloat
gap
=
NS_round
(
lineThickness
/
2
.
0
)
;
gap
=
std
:
:
max
(
gap
1
.
0
)
;
r
.
height
=
lineThickness
*
2
.
0
+
gap
;
if
(
canLiftUnderline
)
{
if
(
r
.
Height
(
)
>
suggestedMaxRectHeight
)
{
r
.
height
=
std
:
:
max
(
suggestedMaxRectHeight
lineThickness
*
2
.
0
+
1
.
0
)
;
}
}
}
else
if
(
aParams
.
style
=
=
NS_STYLE_TEXT_DECORATION_STYLE_WAVY
)
{
r
.
height
=
lineThickness
>
2
.
0
?
lineThickness
*
4
.
0
:
lineThickness
*
3
.
0
;
if
(
canLiftUnderline
)
{
if
(
r
.
Height
(
)
>
suggestedMaxRectHeight
)
{
r
.
height
=
std
:
:
max
(
suggestedMaxRectHeight
lineThickness
*
2
.
0
)
;
}
}
}
gfxFloat
baseline
=
floor
(
bCoord
+
aParams
.
ascent
+
0
.
5
)
;
gfxFloat
offset
=
0
.
0
;
switch
(
aParams
.
decoration
)
{
case
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
:
offset
=
aParams
.
offset
;
if
(
canLiftUnderline
)
{
if
(
descentLimit
<
-
offset
+
r
.
Height
(
)
)
{
gfxFloat
offsetBottomAligned
=
-
descentLimit
+
r
.
Height
(
)
;
gfxFloat
offsetTopAligned
=
0
.
0
;
offset
=
std
:
:
min
(
offsetBottomAligned
offsetTopAligned
)
;
}
}
break
;
case
NS_STYLE_TEXT_DECORATION_LINE_OVERLINE
:
offset
=
aParams
.
offset
-
lineThickness
+
r
.
Height
(
)
;
break
;
case
NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH
:
{
gfxFloat
extra
=
floor
(
r
.
Height
(
)
/
2
.
0
+
0
.
5
)
;
extra
=
std
:
:
max
(
extra
lineThickness
)
;
offset
=
aParams
.
offset
-
lineThickness
+
extra
;
break
;
}
default
:
NS_ERROR
(
"
Invalid
decoration
value
!
"
)
;
}
if
(
aParams
.
vertical
)
{
Swap
(
r
.
x
r
.
y
)
;
Swap
(
r
.
width
r
.
height
)
;
if
(
aParams
.
sidewaysLeft
)
{
r
.
x
=
baseline
-
floor
(
offset
+
0
.
5
)
;
}
else
{
r
.
x
=
baseline
+
floor
(
offset
-
r
.
Width
(
)
+
0
.
5
)
;
}
}
else
{
r
.
y
=
baseline
-
floor
(
offset
+
0
.
5
)
;
}
return
r
;
}
#
define
MAX_BLUR_RADIUS
300
#
define
MAX_SPREAD_RADIUS
50
static
inline
gfxPoint
ComputeBlurStdDev
(
nscoord
aBlurRadius
int32_t
aAppUnitsPerDevPixel
gfxFloat
aScaleX
gfxFloat
aScaleY
)
{
gfxFloat
blurStdDev
=
gfxFloat
(
aBlurRadius
)
/
gfxFloat
(
aAppUnitsPerDevPixel
)
;
return
gfxPoint
(
std
:
:
min
(
(
blurStdDev
*
aScaleX
)
gfxFloat
(
MAX_BLUR_RADIUS
)
)
/
2
.
0
std
:
:
min
(
(
blurStdDev
*
aScaleY
)
gfxFloat
(
MAX_BLUR_RADIUS
)
)
/
2
.
0
)
;
}
static
inline
IntSize
ComputeBlurRadius
(
nscoord
aBlurRadius
int32_t
aAppUnitsPerDevPixel
gfxFloat
aScaleX
=
1
.
0
gfxFloat
aScaleY
=
1
.
0
)
{
gfxPoint
scaledBlurStdDev
=
ComputeBlurStdDev
(
aBlurRadius
aAppUnitsPerDevPixel
aScaleX
aScaleY
)
;
return
gfxAlphaBoxBlur
:
:
CalculateBlurRadius
(
scaledBlurStdDev
)
;
}
gfxContext
*
nsContextBoxBlur
:
:
Init
(
const
nsRect
&
aRect
nscoord
aSpreadRadius
nscoord
aBlurRadius
int32_t
aAppUnitsPerDevPixel
gfxContext
*
aDestinationCtx
const
nsRect
&
aDirtyRect
const
gfxRect
*
aSkipRect
uint32_t
aFlags
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
mContext
=
nullptr
;
return
nullptr
;
}
IntSize
blurRadius
;
IntSize
spreadRadius
;
GetBlurAndSpreadRadius
(
aDestinationCtx
-
>
GetDrawTarget
(
)
aAppUnitsPerDevPixel
aBlurRadius
aSpreadRadius
blurRadius
spreadRadius
)
;
mDestinationCtx
=
aDestinationCtx
;
if
(
blurRadius
.
width
<
=
0
&
&
blurRadius
.
height
<
=
0
&
&
spreadRadius
.
width
<
=
0
&
&
spreadRadius
.
height
<
=
0
&
&
!
(
aFlags
&
FORCE_MASK
)
)
{
mContext
=
aDestinationCtx
;
return
mContext
;
}
gfxRect
rect
=
nsLayoutUtils
:
:
RectToGfxRect
(
aRect
aAppUnitsPerDevPixel
)
;
gfxRect
dirtyRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
aDirtyRect
aAppUnitsPerDevPixel
)
;
dirtyRect
.
RoundOut
(
)
;
gfxMatrix
transform
=
aDestinationCtx
-
>
CurrentMatrixDouble
(
)
;
rect
=
transform
.
TransformBounds
(
rect
)
;
mPreTransformed
=
!
transform
.
IsIdentity
(
)
;
dirtyRect
=
transform
.
TransformBounds
(
dirtyRect
)
;
bool
useHardwareAccel
=
!
(
aFlags
&
DISABLE_HARDWARE_ACCELERATION_BLUR
)
;
if
(
aSkipRect
)
{
gfxRect
skipRect
=
transform
.
TransformBounds
(
*
aSkipRect
)
;
mContext
=
mAlphaBoxBlur
.
Init
(
aDestinationCtx
rect
spreadRadius
blurRadius
&
dirtyRect
&
skipRect
useHardwareAccel
)
;
}
else
{
mContext
=
mAlphaBoxBlur
.
Init
(
aDestinationCtx
rect
spreadRadius
blurRadius
&
dirtyRect
nullptr
useHardwareAccel
)
;
}
if
(
mContext
)
{
mContext
-
>
Multiply
(
transform
)
;
}
return
mContext
;
}
void
nsContextBoxBlur
:
:
DoPaint
(
)
{
if
(
mContext
=
=
mDestinationCtx
)
{
return
;
}
gfxContextMatrixAutoSaveRestore
saveMatrix
(
mDestinationCtx
)
;
if
(
mPreTransformed
)
{
mDestinationCtx
-
>
SetMatrix
(
Matrix
(
)
)
;
}
mAlphaBoxBlur
.
Paint
(
mDestinationCtx
)
;
}
gfxContext
*
nsContextBoxBlur
:
:
GetContext
(
)
{
return
mContext
;
}
nsMargin
nsContextBoxBlur
:
:
GetBlurRadiusMargin
(
nscoord
aBlurRadius
int32_t
aAppUnitsPerDevPixel
)
{
IntSize
blurRadius
=
ComputeBlurRadius
(
aBlurRadius
aAppUnitsPerDevPixel
)
;
nsMargin
result
;
result
.
top
=
result
.
bottom
=
blurRadius
.
height
*
aAppUnitsPerDevPixel
;
result
.
left
=
result
.
right
=
blurRadius
.
width
*
aAppUnitsPerDevPixel
;
return
result
;
}
void
nsContextBoxBlur
:
:
BlurRectangle
(
gfxContext
*
aDestinationCtx
const
nsRect
&
aRect
int32_t
aAppUnitsPerDevPixel
RectCornerRadii
*
aCornerRadii
nscoord
aBlurRadius
const
Color
&
aShadowColor
const
nsRect
&
aDirtyRect
const
gfxRect
&
aSkipRect
)
{
DrawTarget
&
aDestDrawTarget
=
*
aDestinationCtx
-
>
GetDrawTarget
(
)
;
if
(
aRect
.
IsEmpty
(
)
)
{
return
;
}
Rect
shadowGfxRect
=
NSRectToRect
(
aRect
aAppUnitsPerDevPixel
)
;
if
(
aBlurRadius
<
=
0
)
{
ColorPattern
color
(
ToDeviceColor
(
aShadowColor
)
)
;
if
(
aCornerRadii
)
{
RefPtr
<
Path
>
roundedRect
=
MakePathForRoundedRect
(
aDestDrawTarget
shadowGfxRect
*
aCornerRadii
)
;
aDestDrawTarget
.
Fill
(
roundedRect
color
)
;
}
else
{
aDestDrawTarget
.
FillRect
(
shadowGfxRect
color
)
;
}
return
;
}
gfxFloat
scaleX
=
1
;
gfxFloat
scaleY
=
1
;
gfxMatrix
transform
=
aDestinationCtx
-
>
CurrentMatrixDouble
(
)
;
if
(
!
transform
.
HasNonAxisAlignedTransform
(
)
&
&
transform
.
_11
>
0
.
0
&
&
transform
.
_22
>
0
.
0
)
{
scaleX
=
transform
.
_11
;
scaleY
=
transform
.
_22
;
aDestinationCtx
-
>
SetMatrix
(
Matrix
(
)
)
;
}
else
{
transform
=
gfxMatrix
(
)
;
}
gfxPoint
blurStdDev
=
ComputeBlurStdDev
(
aBlurRadius
aAppUnitsPerDevPixel
scaleX
scaleY
)
;
gfxRect
dirtyRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
aDirtyRect
aAppUnitsPerDevPixel
)
;
dirtyRect
.
RoundOut
(
)
;
gfxRect
shadowThebesRect
=
transform
.
TransformBounds
(
ThebesRect
(
shadowGfxRect
)
)
;
dirtyRect
=
transform
.
TransformBounds
(
dirtyRect
)
;
gfxRect
skipRect
=
transform
.
TransformBounds
(
aSkipRect
)
;
if
(
aCornerRadii
)
{
aCornerRadii
-
>
Scale
(
scaleX
scaleY
)
;
}
gfxAlphaBoxBlur
:
:
BlurRectangle
(
aDestinationCtx
shadowThebesRect
aCornerRadii
blurStdDev
aShadowColor
dirtyRect
skipRect
)
;
}
void
nsContextBoxBlur
:
:
GetBlurAndSpreadRadius
(
DrawTarget
*
aDestDrawTarget
int32_t
aAppUnitsPerDevPixel
nscoord
aBlurRadius
nscoord
aSpreadRadius
IntSize
&
aOutBlurRadius
IntSize
&
aOutSpreadRadius
bool
aConstrainSpreadRadius
)
{
Matrix
transform
=
aDestDrawTarget
-
>
GetTransform
(
)
;
gfxFloat
scaleX
scaleY
;
if
(
transform
.
HasNonAxisAlignedTransform
(
)
|
|
transform
.
_11
<
=
0
.
0
|
|
transform
.
_22
<
=
0
.
0
)
{
scaleX
=
1
;
scaleY
=
1
;
}
else
{
scaleX
=
transform
.
_11
;
scaleY
=
transform
.
_22
;
}
aOutBlurRadius
=
ComputeBlurRadius
(
aBlurRadius
aAppUnitsPerDevPixel
scaleX
scaleY
)
;
aOutSpreadRadius
=
IntSize
(
int32_t
(
aSpreadRadius
*
scaleX
/
aAppUnitsPerDevPixel
)
int32_t
(
aSpreadRadius
*
scaleY
/
aAppUnitsPerDevPixel
)
)
;
if
(
aConstrainSpreadRadius
)
{
aOutSpreadRadius
.
width
=
std
:
:
min
(
aOutSpreadRadius
.
width
int32_t
(
MAX_SPREAD_RADIUS
)
)
;
aOutSpreadRadius
.
height
=
std
:
:
min
(
aOutSpreadRadius
.
height
int32_t
(
MAX_SPREAD_RADIUS
)
)
;
}
}
bool
nsContextBoxBlur
:
:
InsetBoxBlur
(
gfxContext
*
aDestinationCtx
Rect
aDestinationRect
Rect
aShadowClipRect
Color
&
aShadowColor
nscoord
aBlurRadiusAppUnits
nscoord
aSpreadDistanceAppUnits
int32_t
aAppUnitsPerDevPixel
bool
aHasBorderRadius
RectCornerRadii
&
aInnerClipRectRadii
Rect
aSkipRect
Point
aShadowOffset
)
{
if
(
aDestinationRect
.
IsEmpty
(
)
)
{
mContext
=
nullptr
;
return
false
;
}
gfxContextAutoSaveRestore
autoRestore
(
aDestinationCtx
)
;
IntSize
blurRadius
;
IntSize
spreadRadius
;
bool
constrainSpreadRadius
=
false
;
GetBlurAndSpreadRadius
(
aDestinationCtx
-
>
GetDrawTarget
(
)
aAppUnitsPerDevPixel
aBlurRadiusAppUnits
aSpreadDistanceAppUnits
blurRadius
spreadRadius
constrainSpreadRadius
)
;
gfx
:
:
Size
scale
=
aDestinationCtx
-
>
CurrentMatrix
(
)
.
ScaleFactors
(
true
)
;
Matrix
transform
=
aDestinationCtx
-
>
CurrentMatrix
(
)
;
if
(
!
transform
.
HasNonAxisAlignedTransform
(
)
&
&
transform
.
_11
>
0
.
0
&
&
transform
.
_22
>
0
.
0
)
{
aDestinationCtx
-
>
SetMatrix
(
Matrix
(
)
)
;
}
else
{
transform
=
Matrix
(
)
;
}
Rect
transformedDestRect
=
transform
.
TransformBounds
(
aDestinationRect
)
;
Rect
transformedShadowClipRect
=
transform
.
TransformBounds
(
aShadowClipRect
)
;
Rect
transformedSkipRect
=
transform
.
TransformBounds
(
aSkipRect
)
;
transformedDestRect
.
Round
(
)
;
transformedShadowClipRect
.
Round
(
)
;
transformedSkipRect
.
RoundIn
(
)
;
for
(
size_t
i
=
0
;
i
<
4
;
i
+
+
)
{
aInnerClipRectRadii
[
i
]
.
width
=
std
:
:
floor
(
scale
.
width
*
aInnerClipRectRadii
[
i
]
.
width
)
;
aInnerClipRectRadii
[
i
]
.
height
=
std
:
:
floor
(
scale
.
height
*
aInnerClipRectRadii
[
i
]
.
height
)
;
}
mAlphaBoxBlur
.
BlurInsetBox
(
aDestinationCtx
transformedDestRect
transformedShadowClipRect
blurRadius
aShadowColor
aHasBorderRadius
?
&
aInnerClipRectRadii
:
nullptr
transformedSkipRect
aShadowOffset
)
;
return
true
;
}
