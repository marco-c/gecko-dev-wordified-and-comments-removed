#
ifndef
nsCSSRenderingGradients_h__
#
define
nsCSSRenderingGradients_h__
#
include
"
gfxRect
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
webrender
/
webrender_ffi
.
h
"
class
gfxPattern
;
namespace
mozilla
{
namespace
layers
{
class
StackingContextHelper
;
}
namespace
wr
{
class
DisplayListBuilder
;
}
struct
ColorStop
{
ColorStop
(
)
:
mPosition
(
0
)
mIsMidpoint
(
false
)
{
}
ColorStop
(
double
aPosition
bool
aIsMidPoint
const
StyleAbsoluteColor
&
aColor
)
:
mPosition
(
aPosition
)
mIsMidpoint
(
aIsMidPoint
)
mColor
(
aColor
)
{
}
double
mPosition
;
bool
mIsMidpoint
;
StyleAbsoluteColor
mColor
;
}
;
template
<
class
T
>
class
MOZ_STACK_CLASS
ColorStopInterpolator
{
public
:
ColorStopInterpolator
(
const
nsTArray
<
ColorStop
>
&
aStops
const
StyleColorInterpolationMethod
&
aStyleColorInterpolationMethod
bool
aExtendLastStop
)
:
mStyleColorInterpolationMethod
(
aStyleColorInterpolationMethod
)
mStops
(
aStops
)
mExtendLastStop
(
aExtendLastStop
)
{
}
void
CreateStops
(
)
{
uint32_t
iterStops
=
mStops
.
Length
(
)
-
(
mExtendLastStop
?
0
:
1
)
;
for
(
uint32_t
i
=
0
;
i
<
iterStops
;
i
+
+
)
{
auto
nextindex
=
i
+
1
<
mStops
.
Length
(
)
?
i
+
1
:
i
;
const
auto
&
start
=
mStops
[
i
]
;
const
auto
&
end
=
mStops
[
nextindex
]
;
float
startPosition
=
start
.
mPosition
;
float
endPosition
=
end
.
mPosition
;
if
(
i
=
=
mStops
.
Length
(
)
-
1
&
&
mExtendLastStop
)
{
endPosition
=
1
.
0f
;
}
uint32_t
extraStops
=
(
uint32_t
)
(
floor
(
endPosition
*
kFullRangeExtraStops
)
-
floor
(
startPosition
*
kFullRangeExtraStops
)
)
;
extraStops
=
std
:
:
clamp
(
extraStops
1U
kFullRangeExtraStops
)
;
float
step
=
1
.
0f
/
(
float
)
extraStops
;
for
(
uint32_t
extraStop
=
0
;
extraStop
<
=
extraStops
;
extraStop
+
+
)
{
auto
progress
=
(
float
)
extraStop
*
step
;
auto
position
=
startPosition
+
progress
*
(
endPosition
-
startPosition
)
;
StyleAbsoluteColor
color
=
Servo_InterpolateColor
(
mStyleColorInterpolationMethod
&
end
.
mColor
&
start
.
mColor
progress
)
;
static_cast
<
T
*
>
(
this
)
-
>
CreateStop
(
float
(
position
)
gfx
:
:
ToDeviceColor
(
color
)
)
;
}
}
}
protected
:
StyleColorInterpolationMethod
mStyleColorInterpolationMethod
;
const
nsTArray
<
ColorStop
>
&
mStops
;
bool
mExtendLastStop
;
inline
static
const
uint32_t
kFullRangeExtraStops
=
128
;
}
;
class
nsCSSGradientRenderer
final
{
public
:
static
nsCSSGradientRenderer
Create
(
nsPresContext
*
aPresContext
ComputedStyle
*
aComputedStyle
const
StyleGradient
&
aGradient
const
nsSize
&
aIntrinsiceSize
)
;
void
Paint
(
gfxContext
&
aContext
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsSize
&
aRepeatSize
const
mozilla
:
:
CSSIntRect
&
aSrc
const
nsRect
&
aDirtyRect
float
aOpacity
=
1
.
0
)
;
void
BuildWebRenderParameters
(
float
aOpacity
wr
:
:
ExtendMode
&
aMode
nsTArray
<
wr
:
:
GradientStop
>
&
aStops
LayoutDevicePoint
&
aLineStart
LayoutDevicePoint
&
aLineEnd
LayoutDeviceSize
&
aGradientRadius
LayoutDevicePoint
&
aGradientCenter
float
&
aGradientAngle
)
;
void
BuildWebRenderDisplayItems
(
wr
:
:
DisplayListBuilder
&
aBuilder
const
layers
:
:
StackingContextHelper
&
aSc
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsSize
&
aRepeatSize
const
mozilla
:
:
CSSIntRect
&
aSrc
bool
aIsBackfaceVisible
float
aOpacity
=
1
.
0
)
;
private
:
nsCSSGradientRenderer
(
)
:
mPresContext
(
nullptr
)
mGradient
(
nullptr
)
mRadiusX
(
0
.
0
)
mRadiusY
(
0
.
0
)
mAngle
(
0
.
0
)
{
}
bool
TryPaintTilesWithExtendMode
(
gfxContext
&
aContext
gfxPattern
*
aGradientPattern
nscoord
aXStart
nscoord
aYStart
const
gfxRect
&
aDirtyAreaToFill
const
nsRect
&
aDest
const
nsSize
&
aRepeatSize
bool
aForceRepeatToCoverTiles
)
;
nsPresContext
*
mPresContext
;
const
StyleGradient
*
mGradient
;
nsTArray
<
ColorStop
>
mStops
;
gfxPoint
mLineStart
mLineEnd
;
double
mRadiusX
mRadiusY
;
gfxPoint
mCenter
;
float
mAngle
;
}
;
}
#
endif
