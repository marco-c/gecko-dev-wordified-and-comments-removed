#
ifndef
MOZILLA_PAINTING_TRANSFORMCLIPNODE_H
#
define
MOZILLA_PAINTING_TRANSFORMCLIPNODE_H
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsRegionFwd
.
h
"
namespace
mozilla
{
class
TransformClipNode
{
NS_INLINE_DECL_REFCOUNTING
(
TransformClipNode
)
;
public
:
TransformClipNode
(
const
RefPtr
<
TransformClipNode
>
&
aParent
const
gfx
:
:
Matrix4x4Flagged
&
aTransform
const
Maybe
<
gfx
:
:
IntRect
>
&
aClip
)
:
mParent
(
aParent
)
mTransform
(
aTransform
)
mClip
(
aClip
)
{
MOZ_COUNT_CTOR
(
TransformClipNode
)
;
}
const
RefPtr
<
TransformClipNode
>
&
Parent
(
)
const
{
return
mParent
;
}
nsRect
TransformRect
(
const
nsRect
&
aRect
const
int32_t
aA2D
)
const
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
aRect
;
}
gfx
:
:
Rect
result
(
NSAppUnitsToFloatPixels
(
aRect
.
x
aA2D
)
NSAppUnitsToFloatPixels
(
aRect
.
y
aA2D
)
NSAppUnitsToFloatPixels
(
aRect
.
width
aA2D
)
NSAppUnitsToFloatPixels
(
aRect
.
height
aA2D
)
)
;
TransformRect
(
result
)
;
return
nsRect
(
NSFloatPixelsToAppUnits
(
result
.
x
aA2D
)
NSFloatPixelsToAppUnits
(
result
.
y
aA2D
)
NSFloatPixelsToAppUnits
(
result
.
width
aA2D
)
NSFloatPixelsToAppUnits
(
result
.
height
aA2D
)
)
;
}
gfx
:
:
IntRect
TransformRect
(
const
gfx
:
:
IntRect
&
aRect
)
const
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
aRect
;
}
gfx
:
:
Rect
result
(
IntRectToRect
(
aRect
)
)
;
TransformRect
(
result
)
;
return
RoundedToInt
(
result
)
;
}
nsIntRegion
TransformRegion
(
const
nsIntRegion
&
aRegion
)
{
if
(
aRegion
.
IsEmpty
(
)
)
{
return
aRegion
;
}
nsIntRegion
result
=
aRegion
;
const
TransformClipNode
*
node
=
this
;
while
(
node
)
{
const
gfx
:
:
Matrix4x4Flagged
&
transform
=
node
-
>
Transform
(
)
;
result
=
result
.
Transform
(
transform
.
GetMatrix
(
)
)
;
if
(
node
-
>
Clip
(
)
)
{
const
gfx
:
:
IntRect
clipRect
=
*
node
-
>
Clip
(
)
;
result
.
AndWith
(
clipRect
)
;
}
node
=
node
-
>
Parent
(
)
;
}
return
result
;
}
protected
:
const
Maybe
<
gfx
:
:
IntRect
>
&
Clip
(
)
const
{
return
mClip
;
}
const
gfx
:
:
Matrix4x4Flagged
&
Transform
(
)
const
{
return
mTransform
;
}
void
TransformRect
(
gfx
:
:
Rect
&
aRect
)
const
{
const
TransformClipNode
*
node
=
this
;
while
(
node
)
{
const
gfx
:
:
Matrix4x4Flagged
&
transform
=
node
-
>
Transform
(
)
;
gfx
:
:
Rect
maxBounds
=
gfx
:
:
Rect
:
:
MaxIntRect
(
)
;
if
(
node
-
>
Clip
(
)
)
{
maxBounds
=
IntRectToRect
(
*
node
-
>
Clip
(
)
)
;
}
aRect
=
transform
.
TransformAndClipBounds
(
aRect
maxBounds
)
;
node
=
node
-
>
Parent
(
)
;
}
}
private
:
MOZ_COUNTED_DTOR
(
TransformClipNode
)
const
RefPtr
<
TransformClipNode
>
mParent
;
const
gfx
:
:
Matrix4x4Flagged
mTransform
;
const
Maybe
<
gfx
:
:
IntRect
>
mClip
;
}
;
}
#
endif
