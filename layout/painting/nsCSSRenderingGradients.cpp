#
include
"
nsCSSRenderingGradients
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsCSSColorUtils
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsRenderingContext
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfxGradientCache
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
Units
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
static
gfxFloat
ConvertGradientValueToPixels
(
const
nsStyleCoord
&
aCoord
gfxFloat
aFillLength
int32_t
aAppUnitsPerPixel
)
{
switch
(
aCoord
.
GetUnit
(
)
)
{
case
eStyleUnit_Percent
:
return
aCoord
.
GetPercentValue
(
)
*
aFillLength
;
case
eStyleUnit_Coord
:
return
NSAppUnitsToFloatPixels
(
aCoord
.
GetCoordValue
(
)
aAppUnitsPerPixel
)
;
case
eStyleUnit_Calc
:
{
const
nsStyleCoord
:
:
Calc
*
calc
=
aCoord
.
GetCalcValue
(
)
;
return
calc
-
>
mPercent
*
aFillLength
+
NSAppUnitsToFloatPixels
(
calc
-
>
mLength
aAppUnitsPerPixel
)
;
}
default
:
NS_WARNING
(
"
Unexpected
coord
unit
"
)
;
return
0
;
}
}
static
gfxPoint
ComputeGradientLineEndFromAngle
(
const
gfxPoint
&
aStart
double
aAngle
const
gfxSize
&
aBoxSize
)
{
double
dx
=
cos
(
-
aAngle
)
;
double
dy
=
sin
(
-
aAngle
)
;
gfxPoint
farthestCorner
(
dx
>
0
?
aBoxSize
.
width
:
0
dy
>
0
?
aBoxSize
.
height
:
0
)
;
gfxPoint
delta
=
farthestCorner
-
aStart
;
double
u
=
delta
.
x
*
dy
-
delta
.
y
*
dx
;
return
farthestCorner
+
gfxPoint
(
-
u
*
dy
u
*
dx
)
;
}
static
void
ComputeLinearGradientLine
(
nsPresContext
*
aPresContext
nsStyleGradient
*
aGradient
const
gfxSize
&
aBoxSize
gfxPoint
*
aLineStart
gfxPoint
*
aLineEnd
)
{
if
(
aGradient
-
>
mBgPosX
.
GetUnit
(
)
=
=
eStyleUnit_None
)
{
double
angle
;
if
(
aGradient
-
>
mAngle
.
IsAngleValue
(
)
)
{
angle
=
aGradient
-
>
mAngle
.
GetAngleValueInRadians
(
)
;
if
(
!
aGradient
-
>
mLegacySyntax
)
{
angle
=
M_PI_2
-
angle
;
}
}
else
{
angle
=
-
M_PI_2
;
}
gfxPoint
center
(
aBoxSize
.
width
/
2
aBoxSize
.
height
/
2
)
;
*
aLineEnd
=
ComputeGradientLineEndFromAngle
(
center
angle
aBoxSize
)
;
*
aLineStart
=
gfxPoint
(
aBoxSize
.
width
aBoxSize
.
height
)
-
*
aLineEnd
;
}
else
if
(
!
aGradient
-
>
mLegacySyntax
)
{
float
xSign
=
aGradient
-
>
mBgPosX
.
GetPercentValue
(
)
*
2
-
1
;
float
ySign
=
1
-
aGradient
-
>
mBgPosY
.
GetPercentValue
(
)
*
2
;
double
angle
=
atan2
(
ySign
*
aBoxSize
.
width
xSign
*
aBoxSize
.
height
)
;
gfxPoint
center
(
aBoxSize
.
width
/
2
aBoxSize
.
height
/
2
)
;
*
aLineEnd
=
ComputeGradientLineEndFromAngle
(
center
angle
aBoxSize
)
;
*
aLineStart
=
gfxPoint
(
aBoxSize
.
width
aBoxSize
.
height
)
-
*
aLineEnd
;
}
else
{
int32_t
appUnitsPerPixel
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
*
aLineStart
=
gfxPoint
(
ConvertGradientValueToPixels
(
aGradient
-
>
mBgPosX
aBoxSize
.
width
appUnitsPerPixel
)
ConvertGradientValueToPixels
(
aGradient
-
>
mBgPosY
aBoxSize
.
height
appUnitsPerPixel
)
)
;
if
(
aGradient
-
>
mAngle
.
IsAngleValue
(
)
)
{
MOZ_ASSERT
(
aGradient
-
>
mLegacySyntax
)
;
double
angle
=
aGradient
-
>
mAngle
.
GetAngleValueInRadians
(
)
;
*
aLineEnd
=
ComputeGradientLineEndFromAngle
(
*
aLineStart
angle
aBoxSize
)
;
}
else
{
*
aLineEnd
=
gfxPoint
(
aBoxSize
.
width
aBoxSize
.
height
)
-
*
aLineStart
;
}
}
}
static
void
ComputeRadialGradientLine
(
nsPresContext
*
aPresContext
nsStyleGradient
*
aGradient
const
gfxSize
&
aBoxSize
gfxPoint
*
aLineStart
gfxPoint
*
aLineEnd
double
*
aRadiusX
double
*
aRadiusY
)
{
if
(
aGradient
-
>
mBgPosX
.
GetUnit
(
)
=
=
eStyleUnit_None
)
{
*
aLineStart
=
gfxPoint
(
aBoxSize
.
width
/
2
aBoxSize
.
height
/
2
)
;
}
else
{
int32_t
appUnitsPerPixel
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
*
aLineStart
=
gfxPoint
(
ConvertGradientValueToPixels
(
aGradient
-
>
mBgPosX
aBoxSize
.
width
appUnitsPerPixel
)
ConvertGradientValueToPixels
(
aGradient
-
>
mBgPosY
aBoxSize
.
height
appUnitsPerPixel
)
)
;
}
double
radiusX
radiusY
;
double
leftDistance
=
Abs
(
aLineStart
-
>
x
)
;
double
rightDistance
=
Abs
(
aBoxSize
.
width
-
aLineStart
-
>
x
)
;
double
topDistance
=
Abs
(
aLineStart
-
>
y
)
;
double
bottomDistance
=
Abs
(
aBoxSize
.
height
-
aLineStart
-
>
y
)
;
switch
(
aGradient
-
>
mSize
)
{
case
NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE
:
radiusX
=
std
:
:
min
(
leftDistance
rightDistance
)
;
radiusY
=
std
:
:
min
(
topDistance
bottomDistance
)
;
if
(
aGradient
-
>
mShape
=
=
NS_STYLE_GRADIENT_SHAPE_CIRCULAR
)
{
radiusX
=
radiusY
=
std
:
:
min
(
radiusX
radiusY
)
;
}
break
;
case
NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER
:
{
double
offsetX
=
std
:
:
min
(
leftDistance
rightDistance
)
;
double
offsetY
=
std
:
:
min
(
topDistance
bottomDistance
)
;
if
(
aGradient
-
>
mShape
=
=
NS_STYLE_GRADIENT_SHAPE_CIRCULAR
)
{
radiusX
=
radiusY
=
NS_hypot
(
offsetX
offsetY
)
;
}
else
{
radiusX
=
offsetX
*
M_SQRT2
;
radiusY
=
offsetY
*
M_SQRT2
;
}
break
;
}
case
NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE
:
radiusX
=
std
:
:
max
(
leftDistance
rightDistance
)
;
radiusY
=
std
:
:
max
(
topDistance
bottomDistance
)
;
if
(
aGradient
-
>
mShape
=
=
NS_STYLE_GRADIENT_SHAPE_CIRCULAR
)
{
radiusX
=
radiusY
=
std
:
:
max
(
radiusX
radiusY
)
;
}
break
;
case
NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER
:
{
double
offsetX
=
std
:
:
max
(
leftDistance
rightDistance
)
;
double
offsetY
=
std
:
:
max
(
topDistance
bottomDistance
)
;
if
(
aGradient
-
>
mShape
=
=
NS_STYLE_GRADIENT_SHAPE_CIRCULAR
)
{
radiusX
=
radiusY
=
NS_hypot
(
offsetX
offsetY
)
;
}
else
{
radiusX
=
offsetX
*
M_SQRT2
;
radiusY
=
offsetY
*
M_SQRT2
;
}
break
;
}
case
NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE
:
{
int32_t
appUnitsPerPixel
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
radiusX
=
ConvertGradientValueToPixels
(
aGradient
-
>
mRadiusX
aBoxSize
.
width
appUnitsPerPixel
)
;
radiusY
=
ConvertGradientValueToPixels
(
aGradient
-
>
mRadiusY
aBoxSize
.
height
appUnitsPerPixel
)
;
break
;
}
default
:
radiusX
=
radiusY
=
0
;
MOZ_ASSERT
(
false
"
unknown
radial
gradient
sizing
method
"
)
;
}
*
aRadiusX
=
radiusX
;
*
aRadiusY
=
radiusY
;
double
angle
;
if
(
aGradient
-
>
mAngle
.
IsAngleValue
(
)
)
{
angle
=
aGradient
-
>
mAngle
.
GetAngleValueInRadians
(
)
;
}
else
{
angle
=
0
.
0
;
}
*
aLineEnd
=
*
aLineStart
+
gfxPoint
(
radiusX
*
cos
(
-
angle
)
radiusY
*
sin
(
-
angle
)
)
;
}
static
float
Interpolate
(
float
aF1
float
aF2
float
aFrac
)
{
return
aF1
+
aFrac
*
(
aF2
-
aF1
)
;
}
static
Color
InterpolateColor
(
const
Color
&
aC1
const
Color
&
aC2
float
aFrac
)
{
double
other
=
1
-
aFrac
;
return
Color
(
aC2
.
r
*
aFrac
+
aC1
.
r
*
other
aC2
.
g
*
aFrac
+
aC1
.
g
*
other
aC2
.
b
*
aFrac
+
aC1
.
b
*
other
aC2
.
a
*
aFrac
+
aC1
.
a
*
other
)
;
}
static
nscoord
FindTileStart
(
nscoord
aDirtyCoord
nscoord
aTilePos
nscoord
aTileDim
)
{
NS_ASSERTION
(
aTileDim
>
0
"
Non
-
positive
tile
dimension
"
)
;
double
multiples
=
floor
(
double
(
aDirtyCoord
-
aTilePos
)
/
aTileDim
)
;
return
NSToCoordRound
(
multiples
*
aTileDim
+
aTilePos
)
;
}
static
gfxFloat
LinearGradientStopPositionForPoint
(
const
gfxPoint
&
aGradientStart
const
gfxPoint
&
aGradientEnd
const
gfxPoint
&
aPoint
)
{
gfxPoint
d
=
aGradientEnd
-
aGradientStart
;
gfxPoint
p
=
aPoint
-
aGradientStart
;
double
numerator
=
d
.
x
*
p
.
x
+
d
.
y
*
p
.
y
;
double
denominator
=
d
.
x
*
d
.
x
+
d
.
y
*
d
.
y
;
return
numerator
/
denominator
;
}
static
bool
RectIsBeyondLinearGradientEdge
(
const
gfxRect
&
aRect
const
gfxMatrix
&
aPatternMatrix
const
nsTArray
<
ColorStop
>
&
aStops
const
gfxPoint
&
aGradientStart
const
gfxPoint
&
aGradientEnd
Color
*
aOutEdgeColor
)
{
gfxFloat
topLeft
=
LinearGradientStopPositionForPoint
(
aGradientStart
aGradientEnd
aPatternMatrix
.
Transform
(
aRect
.
TopLeft
(
)
)
)
;
gfxFloat
topRight
=
LinearGradientStopPositionForPoint
(
aGradientStart
aGradientEnd
aPatternMatrix
.
Transform
(
aRect
.
TopRight
(
)
)
)
;
gfxFloat
bottomLeft
=
LinearGradientStopPositionForPoint
(
aGradientStart
aGradientEnd
aPatternMatrix
.
Transform
(
aRect
.
BottomLeft
(
)
)
)
;
gfxFloat
bottomRight
=
LinearGradientStopPositionForPoint
(
aGradientStart
aGradientEnd
aPatternMatrix
.
Transform
(
aRect
.
BottomRight
(
)
)
)
;
const
ColorStop
&
firstStop
=
aStops
[
0
]
;
if
(
topLeft
<
firstStop
.
mPosition
&
&
topRight
<
firstStop
.
mPosition
&
&
bottomLeft
<
firstStop
.
mPosition
&
&
bottomRight
<
firstStop
.
mPosition
)
{
*
aOutEdgeColor
=
firstStop
.
mColor
;
return
true
;
}
const
ColorStop
&
lastStop
=
aStops
.
LastElement
(
)
;
if
(
topLeft
>
=
lastStop
.
mPosition
&
&
topRight
>
=
lastStop
.
mPosition
&
&
bottomLeft
>
=
lastStop
.
mPosition
&
&
bottomRight
>
=
lastStop
.
mPosition
)
{
*
aOutEdgeColor
=
lastStop
.
mColor
;
return
true
;
}
return
false
;
}
static
void
ResolveMidpoints
(
nsTArray
<
ColorStop
>
&
stops
)
{
for
(
size_t
x
=
1
;
x
<
stops
.
Length
(
)
-
1
;
)
{
if
(
!
stops
[
x
]
.
mIsMidpoint
)
{
x
+
+
;
continue
;
}
Color
color1
=
stops
[
x
-
1
]
.
mColor
;
Color
color2
=
stops
[
x
+
1
]
.
mColor
;
float
offset1
=
stops
[
x
-
1
]
.
mPosition
;
float
offset2
=
stops
[
x
+
1
]
.
mPosition
;
float
offset
=
stops
[
x
]
.
mPosition
;
if
(
offset
-
offset1
=
=
offset2
-
offset
)
{
stops
.
RemoveElementAt
(
x
)
;
continue
;
}
if
(
offset1
=
=
offset
)
{
stops
[
x
]
.
mColor
=
color2
;
stops
[
x
]
.
mIsMidpoint
=
false
;
continue
;
}
if
(
offset2
=
=
offset
)
{
stops
[
x
]
.
mColor
=
color1
;
stops
[
x
]
.
mIsMidpoint
=
false
;
continue
;
}
float
midpoint
=
(
offset
-
offset1
)
/
(
offset2
-
offset1
)
;
ColorStop
newStops
[
9
]
;
if
(
midpoint
>
.
5f
)
{
for
(
size_t
y
=
0
;
y
<
7
;
y
+
+
)
{
newStops
[
y
]
.
mPosition
=
offset1
+
(
offset
-
offset1
)
*
(
7
+
y
)
/
13
;
}
newStops
[
7
]
.
mPosition
=
offset
+
(
offset2
-
offset
)
/
3
;
newStops
[
8
]
.
mPosition
=
offset
+
(
offset2
-
offset
)
*
2
/
3
;
}
else
{
newStops
[
0
]
.
mPosition
=
offset1
+
(
offset
-
offset1
)
/
3
;
newStops
[
1
]
.
mPosition
=
offset1
+
(
offset
-
offset1
)
*
2
/
3
;
for
(
size_t
y
=
0
;
y
<
7
;
y
+
+
)
{
newStops
[
y
+
2
]
.
mPosition
=
offset
+
(
offset2
-
offset
)
*
y
/
13
;
}
}
for
(
size_t
y
=
0
;
y
<
9
;
y
+
+
)
{
float
relativeOffset
=
(
newStops
[
y
]
.
mPosition
-
offset1
)
/
(
offset2
-
offset1
)
;
float
multiplier
=
powf
(
relativeOffset
logf
(
.
5f
)
/
logf
(
midpoint
)
)
;
gfx
:
:
Float
red
=
color1
.
r
+
multiplier
*
(
color2
.
r
-
color1
.
r
)
;
gfx
:
:
Float
green
=
color1
.
g
+
multiplier
*
(
color2
.
g
-
color1
.
g
)
;
gfx
:
:
Float
blue
=
color1
.
b
+
multiplier
*
(
color2
.
b
-
color1
.
b
)
;
gfx
:
:
Float
alpha
=
color1
.
a
+
multiplier
*
(
color2
.
a
-
color1
.
a
)
;
newStops
[
y
]
.
mColor
=
Color
(
red
green
blue
alpha
)
;
}
stops
.
ReplaceElementsAt
(
x
1
newStops
9
)
;
x
+
=
9
;
}
}
static
Color
Premultiply
(
const
Color
&
aColor
)
{
gfx
:
:
Float
a
=
aColor
.
a
;
return
Color
(
aColor
.
r
*
a
aColor
.
g
*
a
aColor
.
b
*
a
a
)
;
}
static
Color
Unpremultiply
(
const
Color
&
aColor
)
{
gfx
:
:
Float
a
=
aColor
.
a
;
return
(
a
>
0
.
f
)
?
Color
(
aColor
.
r
/
a
aColor
.
g
/
a
aColor
.
b
/
a
a
)
:
aColor
;
}
static
Color
TransparentColor
(
Color
aColor
)
{
aColor
.
a
=
0
;
return
aColor
;
}
static
const
float
kAlphaIncrementPerGradientStep
=
0
.
1f
;
static
void
ResolvePremultipliedAlpha
(
nsTArray
<
ColorStop
>
&
aStops
)
{
for
(
size_t
x
=
1
;
x
<
aStops
.
Length
(
)
;
x
+
+
)
{
const
ColorStop
leftStop
=
aStops
[
x
-
1
]
;
const
ColorStop
rightStop
=
aStops
[
x
]
;
if
(
leftStop
.
mColor
.
a
=
=
rightStop
.
mColor
.
a
)
{
continue
;
}
if
(
leftStop
.
mColor
.
a
=
=
0
)
{
aStops
[
x
-
1
]
.
mColor
=
TransparentColor
(
rightStop
.
mColor
)
;
continue
;
}
if
(
rightStop
.
mColor
.
a
=
=
0
)
{
ColorStop
newStop
=
rightStop
;
newStop
.
mColor
=
TransparentColor
(
leftStop
.
mColor
)
;
aStops
.
InsertElementAt
(
x
newStop
)
;
x
+
+
;
continue
;
}
if
(
leftStop
.
mColor
.
a
!
=
1
.
0f
|
|
rightStop
.
mColor
.
a
!
=
1
.
0f
)
{
Color
premulLeftColor
=
Premultiply
(
leftStop
.
mColor
)
;
Color
premulRightColor
=
Premultiply
(
rightStop
.
mColor
)
;
size_t
stepCount
=
NSToIntFloor
(
fabsf
(
leftStop
.
mColor
.
a
-
rightStop
.
mColor
.
a
)
/
kAlphaIncrementPerGradientStep
)
;
for
(
size_t
y
=
1
;
y
<
stepCount
;
y
+
+
)
{
float
frac
=
static_cast
<
float
>
(
y
)
/
stepCount
;
ColorStop
newStop
(
Interpolate
(
leftStop
.
mPosition
rightStop
.
mPosition
frac
)
false
Unpremultiply
(
InterpolateColor
(
premulLeftColor
premulRightColor
frac
)
)
)
;
aStops
.
InsertElementAt
(
x
newStop
)
;
x
+
+
;
}
}
}
}
static
ColorStop
InterpolateColorStop
(
const
ColorStop
&
aFirst
const
ColorStop
&
aSecond
double
aPosition
const
Color
&
aDefault
)
{
MOZ_ASSERT
(
aFirst
.
mPosition
<
=
aPosition
)
;
MOZ_ASSERT
(
aPosition
<
=
aSecond
.
mPosition
)
;
double
delta
=
aSecond
.
mPosition
-
aFirst
.
mPosition
;
if
(
delta
<
1e
-
6
)
{
return
ColorStop
(
aPosition
false
aDefault
)
;
}
return
ColorStop
(
aPosition
false
Unpremultiply
(
InterpolateColor
(
Premultiply
(
aFirst
.
mColor
)
Premultiply
(
aSecond
.
mColor
)
(
aPosition
-
aFirst
.
mPosition
)
/
delta
)
)
)
;
}
static
void
ClampColorStops
(
nsTArray
<
ColorStop
>
&
aStops
)
{
MOZ_ASSERT
(
aStops
.
Length
(
)
>
0
)
;
if
(
aStops
.
Length
(
)
<
2
|
|
aStops
[
0
]
.
mPosition
>
1
|
|
aStops
.
LastElement
(
)
.
mPosition
<
0
)
{
Color
c
=
aStops
[
0
]
.
mPosition
>
1
?
aStops
[
0
]
.
mColor
:
aStops
.
LastElement
(
)
.
mColor
;
aStops
.
Clear
(
)
;
aStops
.
AppendElement
(
ColorStop
(
0
false
c
)
)
;
return
;
}
for
(
size_t
i
=
aStops
.
Length
(
)
-
1
;
i
>
0
;
i
-
-
)
{
if
(
aStops
[
i
-
1
]
.
mPosition
<
1
&
&
aStops
[
i
]
.
mPosition
>
=
1
)
{
aStops
[
i
]
=
InterpolateColorStop
(
aStops
[
i
-
1
]
aStops
[
i
]
1
aStops
[
i
-
1
]
.
mColor
)
;
aStops
.
RemoveElementsAt
(
i
+
1
aStops
.
Length
(
)
-
(
i
+
1
)
)
;
}
if
(
aStops
[
i
-
1
]
.
mPosition
<
=
0
&
&
aStops
[
i
]
.
mPosition
>
0
)
{
aStops
[
i
-
1
]
=
InterpolateColorStop
(
aStops
[
i
-
1
]
aStops
[
i
]
0
aStops
[
i
]
.
mColor
)
;
aStops
.
RemoveElementsAt
(
0
i
-
1
)
;
break
;
}
}
MOZ_ASSERT
(
aStops
[
0
]
.
mPosition
>
=
-
1e6
)
;
MOZ_ASSERT
(
aStops
.
LastElement
(
)
.
mPosition
-
1
<
=
1e6
)
;
if
(
aStops
[
0
]
.
mPosition
>
0
)
{
aStops
.
InsertElementAt
(
0
ColorStop
(
0
false
aStops
[
0
]
.
mColor
)
)
;
}
if
(
aStops
.
LastElement
(
)
.
mPosition
<
1
)
{
aStops
.
AppendElement
(
ColorStop
(
1
false
aStops
.
LastElement
(
)
.
mColor
)
)
;
}
}
namespace
mozilla
{
Maybe
<
nsCSSGradientRenderer
>
nsCSSGradientRenderer
:
:
Create
(
nsPresContext
*
aPresContext
nsStyleGradient
*
aGradient
const
nsRect
&
aDest
const
nsRect
&
aFillArea
const
nsSize
&
aRepeatSize
const
CSSIntRect
&
aSrc
const
nsSize
&
aIntrinsicSize
)
{
if
(
aDest
.
IsEmpty
(
)
|
|
aFillArea
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
nscoord
appUnitsPerDevPixel
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
gfxSize
srcSize
=
gfxSize
(
gfxFloat
(
aIntrinsicSize
.
width
)
/
appUnitsPerDevPixel
gfxFloat
(
aIntrinsicSize
.
height
)
/
appUnitsPerDevPixel
)
;
bool
cellContainsFill
=
aDest
.
Contains
(
aFillArea
)
;
gfxPoint
lineStart
lineEnd
;
double
radiusX
=
0
radiusY
=
0
;
if
(
aGradient
-
>
mShape
=
=
NS_STYLE_GRADIENT_SHAPE_LINEAR
)
{
ComputeLinearGradientLine
(
aPresContext
aGradient
srcSize
&
lineStart
&
lineEnd
)
;
}
else
{
ComputeRadialGradientLine
(
aPresContext
aGradient
srcSize
&
lineStart
&
lineEnd
&
radiusX
&
radiusY
)
;
}
if
(
!
lineStart
.
IsFinite
(
)
|
|
!
lineEnd
.
IsFinite
(
)
)
{
lineStart
=
lineEnd
=
gfxPoint
(
0
0
)
;
}
gfxFloat
lineLength
=
NS_hypot
(
lineEnd
.
x
-
lineStart
.
x
lineEnd
.
y
-
lineStart
.
y
)
;
MOZ_ASSERT
(
aGradient
-
>
mStops
.
Length
(
)
>
=
2
"
The
parser
should
reject
gradients
with
less
than
two
stops
"
)
;
nsTArray
<
ColorStop
>
stops
;
int32_t
firstUnsetPosition
=
-
1
;
for
(
uint32_t
i
=
0
;
i
<
aGradient
-
>
mStops
.
Length
(
)
;
+
+
i
)
{
const
nsStyleGradientStop
&
stop
=
aGradient
-
>
mStops
[
i
]
;
double
position
;
switch
(
stop
.
mLocation
.
GetUnit
(
)
)
{
case
eStyleUnit_None
:
if
(
i
=
=
0
)
{
position
=
0
.
0
;
}
else
if
(
i
=
=
aGradient
-
>
mStops
.
Length
(
)
-
1
)
{
position
=
1
.
0
;
}
else
{
if
(
firstUnsetPosition
<
0
)
{
firstUnsetPosition
=
i
;
}
stops
.
AppendElement
(
ColorStop
(
0
stop
.
mIsInterpolationHint
Color
:
:
FromABGR
(
stop
.
mColor
)
)
)
;
continue
;
}
break
;
case
eStyleUnit_Percent
:
position
=
stop
.
mLocation
.
GetPercentValue
(
)
;
break
;
case
eStyleUnit_Coord
:
position
=
lineLength
<
1e
-
6
?
0
.
0
:
stop
.
mLocation
.
GetCoordValue
(
)
/
appUnitsPerDevPixel
/
lineLength
;
break
;
case
eStyleUnit_Calc
:
nsStyleCoord
:
:
Calc
*
calc
;
calc
=
stop
.
mLocation
.
GetCalcValue
(
)
;
position
=
calc
-
>
mPercent
+
(
(
lineLength
<
1e
-
6
)
?
0
.
0
:
(
NSAppUnitsToFloatPixels
(
calc
-
>
mLength
appUnitsPerDevPixel
)
/
lineLength
)
)
;
break
;
default
:
MOZ_ASSERT
(
false
"
Unknown
stop
position
type
"
)
;
}
if
(
i
>
0
)
{
double
previousPosition
=
firstUnsetPosition
>
0
?
stops
[
firstUnsetPosition
-
1
]
.
mPosition
:
stops
[
i
-
1
]
.
mPosition
;
position
=
std
:
:
max
(
position
previousPosition
)
;
}
stops
.
AppendElement
(
ColorStop
(
position
stop
.
mIsInterpolationHint
Color
:
:
FromABGR
(
stop
.
mColor
)
)
)
;
if
(
firstUnsetPosition
>
0
)
{
double
p
=
stops
[
firstUnsetPosition
-
1
]
.
mPosition
;
double
d
=
(
stops
[
i
]
.
mPosition
-
p
)
/
(
i
-
firstUnsetPosition
+
1
)
;
for
(
uint32_t
j
=
firstUnsetPosition
;
j
<
i
;
+
+
j
)
{
p
+
=
d
;
stops
[
j
]
.
mPosition
=
p
;
}
firstUnsetPosition
=
-
1
;
}
}
bool
forceRepeatToCoverTiles
=
aGradient
-
>
mShape
=
=
NS_STYLE_GRADIENT_SHAPE_LINEAR
&
&
(
lineStart
.
x
=
=
lineEnd
.
x
)
!
=
(
lineStart
.
y
=
=
lineEnd
.
y
)
&
&
aRepeatSize
.
width
=
=
aDest
.
width
&
&
aRepeatSize
.
height
=
=
aDest
.
height
&
&
!
aGradient
-
>
mRepeating
&
&
!
aSrc
.
IsEmpty
(
)
&
&
!
cellContainsFill
;
bool
forceRepeatToCoverTilesFlip
=
false
;
if
(
forceRepeatToCoverTiles
)
{
double
rectLen
;
double
offset
;
if
(
lineStart
.
x
>
lineEnd
.
x
|
|
lineStart
.
y
>
lineEnd
.
y
)
{
std
:
:
swap
(
lineStart
lineEnd
)
;
forceRepeatToCoverTilesFlip
=
true
;
}
gfxRect
srcRectDev
=
nsLayoutUtils
:
:
RectToGfxRect
(
CSSPixel
:
:
ToAppUnits
(
aSrc
)
appUnitsPerDevPixel
)
;
if
(
lineStart
.
x
!
=
lineEnd
.
x
)
{
rectLen
=
srcRectDev
.
width
;
offset
=
(
srcRectDev
.
x
-
lineStart
.
x
)
/
lineLength
;
lineStart
.
x
=
srcRectDev
.
x
;
lineEnd
.
x
=
srcRectDev
.
XMost
(
)
;
}
else
{
rectLen
=
srcRectDev
.
height
;
offset
=
(
srcRectDev
.
y
-
lineStart
.
y
)
/
lineLength
;
lineStart
.
y
=
srcRectDev
.
y
;
lineEnd
.
y
=
srcRectDev
.
YMost
(
)
;
}
double
scale
=
lineLength
/
rectLen
;
for
(
size_t
i
=
0
;
i
<
stops
.
Length
(
)
;
i
+
+
)
{
stops
[
i
]
.
mPosition
=
(
stops
[
i
]
.
mPosition
-
offset
)
*
fabs
(
scale
)
;
}
ClampColorStops
(
stops
)
;
lineLength
=
rectLen
;
}
double
firstStop
=
stops
[
0
]
.
mPosition
;
if
(
aGradient
-
>
mShape
!
=
NS_STYLE_GRADIENT_SHAPE_LINEAR
&
&
firstStop
<
0
.
0
)
{
if
(
aGradient
-
>
mRepeating
)
{
double
lastStop
=
stops
[
stops
.
Length
(
)
-
1
]
.
mPosition
;
double
stopDelta
=
lastStop
-
firstStop
;
if
(
stopDelta
>
=
1e
-
6
)
{
double
instanceCount
=
ceil
(
-
firstStop
/
stopDelta
)
;
double
offset
=
instanceCount
*
stopDelta
;
for
(
uint32_t
i
=
0
;
i
<
stops
.
Length
(
)
;
i
+
+
)
{
stops
[
i
]
.
mPosition
+
=
offset
;
}
}
}
else
{
for
(
uint32_t
i
=
0
;
i
<
stops
.
Length
(
)
;
i
+
+
)
{
double
pos
=
stops
[
i
]
.
mPosition
;
if
(
pos
<
0
.
0
)
{
stops
[
i
]
.
mPosition
=
0
.
0
;
if
(
i
<
stops
.
Length
(
)
-
1
)
{
double
nextPos
=
stops
[
i
+
1
]
.
mPosition
;
if
(
nextPos
>
=
0
.
0
&
&
nextPos
-
pos
>
=
1e
-
6
)
{
float
frac
=
float
(
(
0
.
0
-
pos
)
/
(
nextPos
-
pos
)
)
;
stops
[
i
]
.
mColor
=
InterpolateColor
(
stops
[
i
]
.
mColor
stops
[
i
+
1
]
.
mColor
frac
)
;
}
}
}
}
}
firstStop
=
stops
[
0
]
.
mPosition
;
MOZ_ASSERT
(
firstStop
>
=
0
.
0
"
Failed
to
fix
stop
offsets
"
)
;
}
double
lastStop
=
stops
[
stops
.
Length
(
)
-
1
]
.
mPosition
;
double
stopDelta
=
lastStop
-
firstStop
;
bool
zeroRadius
=
aGradient
-
>
mShape
!
=
NS_STYLE_GRADIENT_SHAPE_LINEAR
&
&
(
radiusX
<
1e
-
6
|
|
radiusY
<
1e
-
6
)
;
if
(
stopDelta
<
1e
-
6
|
|
lineLength
<
1e
-
6
|
|
zeroRadius
)
{
if
(
aGradient
-
>
mRepeating
|
|
zeroRadius
)
{
radiusX
=
radiusY
=
0
.
0
;
}
Color
firstColor
(
stops
[
0
]
.
mColor
)
;
Color
lastColor
(
stops
.
LastElement
(
)
.
mColor
)
;
stops
.
Clear
(
)
;
if
(
!
aGradient
-
>
mRepeating
&
&
!
zeroRadius
)
{
stops
.
AppendElement
(
ColorStop
(
firstStop
false
firstColor
)
)
;
}
stops
.
AppendElement
(
ColorStop
(
firstStop
false
lastColor
)
)
;
}
ResolveMidpoints
(
stops
)
;
nsCSSGradientRenderer
renderer
;
renderer
.
mPresContext
=
aPresContext
;
renderer
.
mGradient
=
aGradient
;
renderer
.
mSrc
=
aSrc
;
renderer
.
mDest
=
aDest
;
renderer
.
mFillArea
=
aFillArea
;
renderer
.
mRepeatSize
=
aRepeatSize
;
renderer
.
mStops
=
std
:
:
move
(
stops
)
;
renderer
.
mLineStart
=
lineStart
;
renderer
.
mLineEnd
=
lineEnd
;
renderer
.
mRadiusX
=
radiusX
;
renderer
.
mRadiusY
=
radiusY
;
renderer
.
mForceRepeatToCoverTiles
=
forceRepeatToCoverTiles
;
renderer
.
mForceRepeatToCoverTilesFlip
=
forceRepeatToCoverTilesFlip
;
return
Some
(
renderer
)
;
}
void
nsCSSGradientRenderer
:
:
Paint
(
gfxContext
&
aContext
const
nsRect
&
aDirtyRect
float
aOpacity
)
{
PROFILER_LABEL
(
"
nsCSSRendering
"
"
PaintGradient
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
GRADIENT_DURATION
Telemetry
:
:
Microsecond
>
gradientTimer
;
nscoord
appUnitsPerDevPixel
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
double
firstStop
=
mStops
[
0
]
.
mPosition
;
double
lastStop
=
mStops
[
mStops
.
Length
(
)
-
1
]
.
mPosition
;
if
(
mGradient
-
>
mShape
!
=
NS_STYLE_GRADIENT_SHAPE_LINEAR
&
&
!
mGradient
-
>
mRepeating
)
{
firstStop
=
0
;
}
double
stopScale
;
double
stopOrigin
=
firstStop
;
double
stopEnd
=
lastStop
;
double
stopDelta
=
lastStop
-
firstStop
;
if
(
!
mGradient
-
>
mRepeating
|
|
stopDelta
=
=
0
.
0
)
{
stopOrigin
=
std
:
:
min
(
stopOrigin
0
.
0
)
;
stopEnd
=
std
:
:
max
(
stopEnd
1
.
0
)
;
}
stopScale
=
1
.
0
/
(
stopEnd
-
stopOrigin
)
;
gfxMatrix
matrix
;
if
(
mForceRepeatToCoverTilesFlip
)
{
matrix
.
Scale
(
-
1
-
1
)
;
}
RefPtr
<
gfxPattern
>
gradientPattern
;
gfxPoint
gradientStart
;
gfxPoint
gradientEnd
;
if
(
mGradient
-
>
mShape
=
=
NS_STYLE_GRADIENT_SHAPE_LINEAR
)
{
gradientStart
=
mLineStart
+
(
mLineEnd
-
mLineStart
)
*
stopOrigin
;
gradientEnd
=
mLineStart
+
(
mLineEnd
-
mLineStart
)
*
stopEnd
;
if
(
stopDelta
=
=
0
.
0
)
{
gradientEnd
=
gradientStart
+
(
mLineEnd
-
mLineStart
)
;
}
gradientPattern
=
new
gfxPattern
(
gradientStart
.
x
gradientStart
.
y
gradientEnd
.
x
gradientEnd
.
y
)
;
}
else
{
NS_ASSERTION
(
firstStop
>
=
0
.
0
"
Negative
stops
not
allowed
for
radial
gradients
"
)
;
double
innerRadius
=
mRadiusX
*
stopOrigin
;
double
outerRadius
=
mRadiusX
*
stopEnd
;
if
(
stopDelta
=
=
0
.
0
)
{
outerRadius
=
innerRadius
+
1
;
}
gradientPattern
=
new
gfxPattern
(
mLineStart
.
x
mLineStart
.
y
innerRadius
mLineStart
.
x
mLineStart
.
y
outerRadius
)
;
if
(
mRadiusX
!
=
mRadiusY
)
{
matrix
.
Translate
(
mLineStart
)
;
matrix
.
Scale
(
1
.
0
mRadiusX
/
mRadiusY
)
;
matrix
.
Translate
(
-
mLineStart
)
;
}
}
matrix
.
Translate
(
gfxPoint
(
mPresContext
-
>
CSSPixelsToDevPixels
(
mSrc
.
x
)
mPresContext
-
>
CSSPixelsToDevPixels
(
mSrc
.
y
)
)
)
;
matrix
.
Scale
(
gfxFloat
(
mPresContext
-
>
CSSPixelsToAppUnits
(
mSrc
.
width
)
)
/
mDest
.
width
gfxFloat
(
mPresContext
-
>
CSSPixelsToAppUnits
(
mSrc
.
height
)
)
/
mDest
.
height
)
;
gradientPattern
-
>
SetMatrix
(
matrix
)
;
ResolvePremultipliedAlpha
(
mStops
)
;
bool
isRepeat
=
mGradient
-
>
mRepeating
|
|
mForceRepeatToCoverTiles
;
nsTArray
<
gfx
:
:
GradientStop
>
rawStops
(
mStops
.
Length
(
)
)
;
rawStops
.
SetLength
(
mStops
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mStops
.
Length
(
)
;
i
+
+
)
{
rawStops
[
i
]
.
color
=
mStops
[
i
]
.
mColor
;
rawStops
[
i
]
.
color
.
a
*
=
aOpacity
;
rawStops
[
i
]
.
offset
=
stopScale
*
(
mStops
[
i
]
.
mPosition
-
stopOrigin
)
;
}
RefPtr
<
mozilla
:
:
gfx
:
:
GradientStops
>
gs
=
gfxGradientCache
:
:
GetOrCreateGradientStops
(
aContext
.
GetDrawTarget
(
)
rawStops
isRepeat
?
gfx
:
:
ExtendMode
:
:
REPEAT
:
gfx
:
:
ExtendMode
:
:
CLAMP
)
;
gradientPattern
-
>
SetColorStops
(
gs
)
;
nsRect
dirty
;
if
(
!
dirty
.
IntersectRect
(
aDirtyRect
mFillArea
)
)
return
;
gfxRect
areaToFill
=
nsLayoutUtils
:
:
RectToGfxRect
(
mFillArea
appUnitsPerDevPixel
)
;
gfxRect
dirtyAreaToFill
=
nsLayoutUtils
:
:
RectToGfxRect
(
dirty
appUnitsPerDevPixel
)
;
dirtyAreaToFill
.
RoundOut
(
)
;
gfxMatrix
ctm
=
aContext
.
CurrentMatrix
(
)
;
bool
isCTMPreservingAxisAlignedRectangles
=
ctm
.
PreservesAxisAlignedRectangles
(
)
;
nscoord
xStart
=
FindTileStart
(
dirty
.
x
mDest
.
x
mRepeatSize
.
width
)
;
nscoord
yStart
=
FindTileStart
(
dirty
.
y
mDest
.
y
mRepeatSize
.
height
)
;
nscoord
xEnd
=
mForceRepeatToCoverTiles
?
xStart
+
mDest
.
width
:
dirty
.
XMost
(
)
;
nscoord
yEnd
=
mForceRepeatToCoverTiles
?
yStart
+
mDest
.
height
:
dirty
.
YMost
(
)
;
for
(
nscoord
y
=
yStart
;
y
<
yEnd
;
y
+
=
mRepeatSize
.
height
)
{
for
(
nscoord
x
=
xStart
;
x
<
xEnd
;
x
+
=
mRepeatSize
.
width
)
{
gfxRect
tileRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
nsRect
(
x
y
mDest
.
width
mDest
.
height
)
appUnitsPerDevPixel
)
;
gfxRect
fillRect
=
mForceRepeatToCoverTiles
?
areaToFill
:
tileRect
.
Intersect
(
areaToFill
)
;
gfxPoint
snappedFillRectTopLeft
=
fillRect
.
TopLeft
(
)
;
gfxPoint
snappedFillRectTopRight
=
fillRect
.
TopRight
(
)
;
gfxPoint
snappedFillRectBottomRight
=
fillRect
.
BottomRight
(
)
;
if
(
isCTMPreservingAxisAlignedRectangles
&
&
aContext
.
UserToDevicePixelSnapped
(
snappedFillRectTopLeft
true
)
&
&
aContext
.
UserToDevicePixelSnapped
(
snappedFillRectBottomRight
true
)
&
&
aContext
.
UserToDevicePixelSnapped
(
snappedFillRectTopRight
true
)
)
{
if
(
snappedFillRectTopLeft
.
x
=
=
snappedFillRectBottomRight
.
x
|
|
snappedFillRectTopLeft
.
y
=
=
snappedFillRectBottomRight
.
y
)
{
continue
;
}
gfxMatrix
transform
=
gfxUtils
:
:
TransformRectToRect
(
fillRect
snappedFillRectTopLeft
snappedFillRectTopRight
snappedFillRectBottomRight
)
;
aContext
.
SetMatrix
(
transform
)
;
}
aContext
.
NewPath
(
)
;
aContext
.
Rectangle
(
fillRect
)
;
gfxRect
dirtyFillRect
=
fillRect
.
Intersect
(
dirtyAreaToFill
)
;
gfxRect
fillRectRelativeToTile
=
dirtyFillRect
-
tileRect
.
TopLeft
(
)
;
Color
edgeColor
;
if
(
mGradient
-
>
mShape
=
=
NS_STYLE_GRADIENT_SHAPE_LINEAR
&
&
!
isRepeat
&
&
RectIsBeyondLinearGradientEdge
(
fillRectRelativeToTile
matrix
mStops
gradientStart
gradientEnd
&
edgeColor
)
)
{
edgeColor
.
a
*
=
aOpacity
;
aContext
.
SetColor
(
edgeColor
)
;
}
else
{
aContext
.
SetMatrix
(
aContext
.
CurrentMatrix
(
)
.
Copy
(
)
.
Translate
(
tileRect
.
TopLeft
(
)
)
)
;
aContext
.
SetPattern
(
gradientPattern
)
;
}
aContext
.
Fill
(
)
;
aContext
.
SetMatrix
(
ctm
)
;
}
}
}
void
nsCSSGradientRenderer
:
:
BuildWebRenderParameters
(
float
aOpacity
WrGradientExtendMode
&
aMode
nsTArray
<
WrGradientStop
>
&
aStops
LayoutDevicePoint
&
aLineStart
LayoutDevicePoint
&
aLineEnd
LayoutDeviceSize
&
aGradientRadius
)
{
bool
isRepeat
=
mGradient
-
>
mRepeating
|
|
mForceRepeatToCoverTiles
;
aMode
=
isRepeat
?
WrGradientExtendMode
:
:
Repeat
:
WrGradientExtendMode
:
:
Clamp
;
aStops
.
SetLength
(
mStops
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mStops
.
Length
(
)
;
i
+
+
)
{
Float
alpha
=
mStops
[
i
]
.
mColor
.
a
*
aOpacity
;
aStops
[
i
]
.
color
.
r
=
mStops
[
i
]
.
mColor
.
r
*
alpha
;
aStops
[
i
]
.
color
.
g
=
mStops
[
i
]
.
mColor
.
g
*
alpha
;
aStops
[
i
]
.
color
.
b
=
mStops
[
i
]
.
mColor
.
b
*
alpha
;
aStops
[
i
]
.
color
.
a
=
alpha
;
aStops
[
i
]
.
offset
=
mStops
[
i
]
.
mPosition
;
}
aLineStart
=
LayoutDevicePoint
(
mLineStart
.
x
mLineStart
.
y
)
;
aLineEnd
=
LayoutDevicePoint
(
mLineEnd
.
x
mLineEnd
.
y
)
;
aGradientRadius
=
LayoutDeviceSize
(
mRadiusX
mRadiusY
)
;
}
void
nsCSSGradientRenderer
:
:
BuildWebRenderDisplayItems
(
wr
:
:
DisplayListBuilder
&
aBuilder
layers
:
:
WebRenderDisplayItemLayer
*
aLayer
float
aOpacity
)
{
WrGradientExtendMode
extendMode
;
nsTArray
<
WrGradientStop
>
stops
;
LayoutDevicePoint
lineStart
;
LayoutDevicePoint
lineEnd
;
LayoutDeviceSize
gradientRadius
;
BuildWebRenderParameters
(
aOpacity
extendMode
stops
lineStart
lineEnd
gradientRadius
)
;
nscoord
appUnitsPerDevPixel
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
clipBounds
=
LayoutDevicePixel
:
:
FromAppUnits
(
mFillArea
appUnitsPerDevPixel
)
;
LayoutDeviceRect
firstTileBounds
=
LayoutDevicePixel
:
:
FromAppUnits
(
mDest
appUnitsPerDevPixel
)
;
LayoutDeviceSize
tileRepeat
=
LayoutDevicePixel
:
:
FromAppUnits
(
mRepeatSize
appUnitsPerDevPixel
)
;
LayoutDevicePoint
tileToClip
=
clipBounds
.
BottomRight
(
)
-
firstTileBounds
.
TopLeft
(
)
;
LayoutDeviceRect
gradientBounds
=
LayoutDeviceRect
(
firstTileBounds
.
TopLeft
(
)
LayoutDeviceSize
(
tileToClip
.
x
tileToClip
.
y
)
)
;
LayoutDeviceSize
tileSpacing
=
tileRepeat
-
firstTileBounds
.
Size
(
)
;
clipBounds
=
LayoutDeviceRect
:
:
FromUnknownRect
(
aLayer
-
>
RelativeToParent
(
clipBounds
.
ToUnknownRect
(
)
)
)
;
firstTileBounds
=
LayoutDeviceRect
:
:
FromUnknownRect
(
aLayer
-
>
RelativeToParent
(
firstTileBounds
.
ToUnknownRect
(
)
)
)
;
gradientBounds
=
LayoutDeviceRect
:
:
FromUnknownRect
(
aLayer
-
>
RelativeToParent
(
gradientBounds
.
ToUnknownRect
(
)
)
)
;
if
(
mGradient
-
>
mShape
=
=
NS_STYLE_GRADIENT_SHAPE_LINEAR
)
{
aBuilder
.
PushLinearGradient
(
mozilla
:
:
wr
:
:
ToWrRect
(
gradientBounds
)
aBuilder
.
BuildClipRegion
(
mozilla
:
:
wr
:
:
ToWrRect
(
clipBounds
)
)
mozilla
:
:
wr
:
:
ToWrPoint
(
lineStart
)
mozilla
:
:
wr
:
:
ToWrPoint
(
lineEnd
)
stops
extendMode
mozilla
:
:
wr
:
:
ToWrSize
(
firstTileBounds
.
Size
(
)
)
mozilla
:
:
wr
:
:
ToWrSize
(
tileSpacing
)
)
;
}
else
{
aBuilder
.
PushRadialGradient
(
mozilla
:
:
wr
:
:
ToWrRect
(
gradientBounds
)
aBuilder
.
BuildClipRegion
(
mozilla
:
:
wr
:
:
ToWrRect
(
clipBounds
)
)
mozilla
:
:
wr
:
:
ToWrPoint
(
lineStart
)
mozilla
:
:
wr
:
:
ToWrSize
(
gradientRadius
)
stops
extendMode
mozilla
:
:
wr
:
:
ToWrSize
(
firstTileBounds
.
Size
(
)
)
mozilla
:
:
wr
:
:
ToWrSize
(
tileSpacing
)
)
;
}
}
}
