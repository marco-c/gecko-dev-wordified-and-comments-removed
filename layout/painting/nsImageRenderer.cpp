#
include
"
nsImageRenderer
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
ImageOps
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
mozilla
/
image
/
WebRenderImageProvider
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsCSSRenderingGradients
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
mozilla
/
StaticPrefs_image
.
h
"
#
include
"
mozilla
/
ISVGDisplayableFrame
.
h
"
#
include
"
mozilla
/
SVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
SVGPaintServerFrame
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
layers
;
nsSize
CSSSizeOrRatio
:
:
ComputeConcreteSize
(
)
const
{
NS_ASSERTION
(
CanComputeConcreteSize
(
)
"
Cannot
compute
"
)
;
if
(
mHasWidth
&
&
mHasHeight
)
{
return
nsSize
(
mWidth
mHeight
)
;
}
if
(
mHasWidth
)
{
return
nsSize
(
mWidth
mRatio
.
Inverted
(
)
.
ApplyTo
(
mWidth
)
)
;
}
MOZ_ASSERT
(
mHasHeight
)
;
return
nsSize
(
mRatio
.
ApplyTo
(
mHeight
)
mHeight
)
;
}
nsImageRenderer
:
:
nsImageRenderer
(
nsIFrame
*
aForFrame
const
StyleImage
*
aImage
uint32_t
aFlags
)
:
mForFrame
(
aForFrame
)
mImage
(
&
aImage
-
>
FinalImage
(
)
)
mImageResolution
(
aImage
-
>
GetResolution
(
)
)
mType
(
mImage
-
>
tag
)
mImageContainer
(
nullptr
)
mGradientData
(
nullptr
)
mPaintServerFrame
(
nullptr
)
mPrepareResult
(
ImgDrawResult
:
:
NOT_READY
)
mSize
(
0
0
)
mFlags
(
aFlags
)
mExtendMode
(
ExtendMode
:
:
CLAMP
)
mMaskOp
(
StyleMaskMode
:
:
MatchSource
)
{
}
bool
nsImageRenderer
:
:
PrepareImage
(
)
{
if
(
mImage
-
>
IsNone
(
)
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
const
bool
isImageRequest
=
mImage
-
>
IsImageRequestType
(
)
;
MOZ_ASSERT_IF
(
!
isImageRequest
!
mImage
-
>
GetImageRequest
(
)
)
;
imgRequestProxy
*
request
=
nullptr
;
if
(
isImageRequest
)
{
request
=
mImage
-
>
GetImageRequest
(
)
;
if
(
!
request
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
}
if
(
!
mImage
-
>
IsComplete
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
isImageRequest
)
;
bool
frameComplete
=
request
-
>
StartDecodingWithResult
(
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
)
;
if
(
mFlags
&
nsImageRenderer
:
:
FLAG_PAINTING_TO_WINDOW
)
{
request
-
>
BoostPriority
(
imgIRequest
:
:
CATEGORY_DISPLAY
)
;
}
if
(
!
frameComplete
&
&
!
mImage
-
>
IsComplete
(
)
)
{
uint32_t
imageStatus
=
0
;
request
-
>
GetImageStatus
(
&
imageStatus
)
;
if
(
imageStatus
&
imgIRequest
:
:
STATUS_ERROR
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
const
bool
syncDecodeWillComplete
=
(
mFlags
&
FLAG_SYNC_DECODE_IMAGES
)
&
&
(
imageStatus
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
)
;
if
(
!
syncDecodeWillComplete
)
{
mPrepareResult
=
ImgDrawResult
:
:
NOT_READY
;
return
false
;
}
}
}
if
(
isImageRequest
)
{
nsCOMPtr
<
imgIContainer
>
srcImage
;
DebugOnly
<
nsresult
>
rv
=
request
-
>
GetImage
(
getter_AddRefs
(
srcImage
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
&
&
srcImage
"
If
GetImage
(
)
is
failing
mImage
-
>
IsComplete
(
)
"
"
should
have
returned
false
"
)
;
if
(
srcImage
)
{
srcImage
=
nsLayoutUtils
:
:
OrientImage
(
srcImage
mForFrame
-
>
StyleVisibility
(
)
-
>
mImageOrientation
)
;
}
if
(
!
mImage
-
>
IsRect
(
)
)
{
mImageContainer
.
swap
(
srcImage
)
;
}
else
{
auto
croprect
=
mImage
-
>
ComputeActualCropRect
(
)
;
if
(
!
croprect
|
|
croprect
-
>
mRect
.
IsEmpty
(
)
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
if
(
croprect
-
>
mIsEntireImage
)
{
mImageContainer
.
swap
(
srcImage
)
;
}
else
{
nsCOMPtr
<
imgIContainer
>
subImage
=
ImageOps
:
:
Clip
(
srcImage
croprect
-
>
mRect
Nothing
(
)
)
;
mImageContainer
.
swap
(
subImage
)
;
}
}
mPrepareResult
=
ImgDrawResult
:
:
SUCCESS
;
}
else
if
(
mImage
-
>
IsGradient
(
)
)
{
mGradientData
=
&
*
mImage
-
>
AsGradient
(
)
;
mPrepareResult
=
ImgDrawResult
:
:
SUCCESS
;
}
else
if
(
mImage
-
>
IsElement
(
)
)
{
dom
:
:
Element
*
paintElement
=
SVGObserverUtils
:
:
GetAndObserveBackgroundImage
(
mForFrame
-
>
FirstContinuation
(
)
mImage
-
>
AsElement
(
)
.
AsAtom
(
)
)
;
mImageElementSurface
=
nsLayoutUtils
:
:
SurfaceFromElement
(
paintElement
)
;
if
(
!
mImageElementSurface
.
GetSourceSurface
(
)
)
{
nsIFrame
*
paintServerFrame
=
paintElement
?
paintElement
-
>
GetPrimaryFrame
(
)
:
nullptr
;
if
(
!
paintServerFrame
|
|
(
paintServerFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
static_cast
<
SVGPaintServerFrame
*
>
(
do_QueryFrame
(
paintServerFrame
)
)
&
&
!
static_cast
<
ISVGDisplayableFrame
*
>
(
do_QueryFrame
(
paintServerFrame
)
)
)
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
mPaintServerFrame
=
paintServerFrame
;
}
mPrepareResult
=
ImgDrawResult
:
:
SUCCESS
;
}
else
if
(
mImage
-
>
IsCrossFade
(
)
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
else
{
MOZ_ASSERT
(
mImage
-
>
IsNone
(
)
"
Unknown
image
type
?
"
)
;
}
return
IsReady
(
)
;
}
CSSSizeOrRatio
nsImageRenderer
:
:
ComputeIntrinsicSize
(
)
{
NS_ASSERTION
(
IsReady
(
)
"
Ensure
PrepareImage
(
)
has
returned
true
"
"
before
calling
me
"
)
;
CSSSizeOrRatio
result
;
switch
(
mType
)
{
case
StyleImage
:
:
Tag
:
:
Rect
:
case
StyleImage
:
:
Tag
:
:
Url
:
{
bool
haveWidth
haveHeight
;
CSSIntSize
imageIntSize
;
nsLayoutUtils
:
:
ComputeSizeForDrawing
(
mImageContainer
mImageResolution
imageIntSize
result
.
mRatio
haveWidth
haveHeight
)
;
if
(
haveWidth
)
{
result
.
SetWidth
(
CSSPixel
:
:
ToAppUnits
(
imageIntSize
.
width
)
)
;
}
if
(
haveHeight
)
{
result
.
SetHeight
(
CSSPixel
:
:
ToAppUnits
(
imageIntSize
.
height
)
)
;
}
if
(
!
haveHeight
&
&
haveWidth
&
&
result
.
mRatio
)
{
nscoord
intrinsicHeight
=
result
.
mRatio
.
Inverted
(
)
.
ApplyTo
(
imageIntSize
.
width
)
;
result
.
SetHeight
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
intrinsicHeight
)
)
;
}
else
if
(
haveHeight
&
&
!
haveWidth
&
&
result
.
mRatio
)
{
nscoord
intrinsicWidth
=
result
.
mRatio
.
ApplyTo
(
imageIntSize
.
height
)
;
result
.
SetWidth
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
intrinsicWidth
)
)
;
}
break
;
}
case
StyleImage
:
:
Tag
:
:
Element
:
{
if
(
mPaintServerFrame
)
{
if
(
!
mPaintServerFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
int32_t
appUnitsPerDevPixel
=
mForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
result
.
SetSize
(
IntSizeToAppUnits
(
SVGIntegrationUtils
:
:
GetContinuationUnionSize
(
mPaintServerFrame
)
.
ToNearestPixels
(
appUnitsPerDevPixel
)
appUnitsPerDevPixel
)
)
;
}
}
else
{
NS_ASSERTION
(
mImageElementSurface
.
GetSourceSurface
(
)
"
Surface
should
be
ready
.
"
)
;
IntSize
surfaceSize
=
mImageElementSurface
.
mSize
;
result
.
SetSize
(
nsSize
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
surfaceSize
.
width
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
surfaceSize
.
height
)
)
)
;
}
break
;
}
case
StyleImage
:
:
Tag
:
:
ImageSet
:
MOZ_FALLTHROUGH_ASSERT
(
"
image
-
set
should
be
resolved
already
"
)
;
case
StyleImage
:
:
Tag
:
:
CrossFade
:
case
StyleImage
:
:
Tag
:
:
Gradient
:
case
StyleImage
:
:
Tag
:
:
None
:
break
;
}
return
result
;
}
nsSize
nsImageRenderer
:
:
ComputeConcreteSize
(
const
CSSSizeOrRatio
&
aSpecifiedSize
const
CSSSizeOrRatio
&
aIntrinsicSize
const
nsSize
&
aDefaultSize
)
{
if
(
aSpecifiedSize
.
IsConcrete
(
)
)
{
return
aSpecifiedSize
.
ComputeConcreteSize
(
)
;
}
MOZ_ASSERT
(
!
aSpecifiedSize
.
mHasWidth
|
|
!
aSpecifiedSize
.
mHasHeight
)
;
if
(
!
aSpecifiedSize
.
mHasWidth
&
&
!
aSpecifiedSize
.
mHasHeight
)
{
if
(
aIntrinsicSize
.
CanComputeConcreteSize
(
)
)
{
return
aIntrinsicSize
.
ComputeConcreteSize
(
)
;
}
if
(
aIntrinsicSize
.
mHasWidth
)
{
return
nsSize
(
aIntrinsicSize
.
mWidth
aDefaultSize
.
height
)
;
}
if
(
aIntrinsicSize
.
mHasHeight
)
{
return
nsSize
(
aDefaultSize
.
width
aIntrinsicSize
.
mHeight
)
;
}
return
ComputeConstrainedSize
(
aDefaultSize
aIntrinsicSize
.
mRatio
CONTAIN
)
;
}
MOZ_ASSERT
(
aSpecifiedSize
.
mHasWidth
|
|
aSpecifiedSize
.
mHasHeight
)
;
if
(
aSpecifiedSize
.
mHasWidth
)
{
nscoord
height
;
if
(
aIntrinsicSize
.
HasRatio
(
)
)
{
height
=
aIntrinsicSize
.
mRatio
.
Inverted
(
)
.
ApplyTo
(
aSpecifiedSize
.
mWidth
)
;
}
else
if
(
aIntrinsicSize
.
mHasHeight
)
{
height
=
aIntrinsicSize
.
mHeight
;
}
else
{
height
=
aDefaultSize
.
height
;
}
return
nsSize
(
aSpecifiedSize
.
mWidth
height
)
;
}
MOZ_ASSERT
(
aSpecifiedSize
.
mHasHeight
)
;
nscoord
width
;
if
(
aIntrinsicSize
.
HasRatio
(
)
)
{
width
=
aIntrinsicSize
.
mRatio
.
ApplyTo
(
aSpecifiedSize
.
mHeight
)
;
}
else
if
(
aIntrinsicSize
.
mHasWidth
)
{
width
=
aIntrinsicSize
.
mWidth
;
}
else
{
width
=
aDefaultSize
.
width
;
}
return
nsSize
(
width
aSpecifiedSize
.
mHeight
)
;
}
nsSize
nsImageRenderer
:
:
ComputeConstrainedSize
(
const
nsSize
&
aConstrainingSize
const
AspectRatio
&
aIntrinsicRatio
FitType
aFitType
)
{
if
(
!
aIntrinsicRatio
)
{
return
aConstrainingSize
;
}
const
float
constraintWidth
=
float
(
aConstrainingSize
.
width
)
;
const
float
hypotheticalWidth
=
aIntrinsicRatio
.
ApplyToFloat
(
aConstrainingSize
.
height
)
;
nsSize
size
;
if
(
(
aFitType
=
=
CONTAIN
)
=
=
(
constraintWidth
<
hypotheticalWidth
)
)
{
size
.
width
=
aConstrainingSize
.
width
;
size
.
height
=
aIntrinsicRatio
.
Inverted
(
)
.
ApplyTo
(
aConstrainingSize
.
width
)
;
if
(
aFitType
=
=
CONTAIN
&
&
aConstrainingSize
.
height
-
size
.
height
<
AppUnitsPerCSSPixel
(
)
)
{
size
.
height
=
aConstrainingSize
.
height
;
}
}
else
{
size
.
height
=
aConstrainingSize
.
height
;
size
.
width
=
aIntrinsicRatio
.
ApplyTo
(
aConstrainingSize
.
height
)
;
if
(
aFitType
=
=
CONTAIN
&
&
aConstrainingSize
.
width
-
size
.
width
<
AppUnitsPerCSSPixel
(
)
)
{
size
.
width
=
aConstrainingSize
.
width
;
}
}
return
size
;
}
void
nsImageRenderer
:
:
SetPreferredSize
(
const
CSSSizeOrRatio
&
aIntrinsicSize
const
nsSize
&
aDefaultSize
)
{
mSize
.
width
=
aIntrinsicSize
.
mHasWidth
?
aIntrinsicSize
.
mWidth
:
aDefaultSize
.
width
;
mSize
.
height
=
aIntrinsicSize
.
mHasHeight
?
aIntrinsicSize
.
mHeight
:
aDefaultSize
.
height
;
}
static
uint32_t
ConvertImageRendererToDrawFlags
(
uint32_t
aImageRendererFlags
)
{
uint32_t
drawFlags
=
imgIContainer
:
:
FLAG_NONE
;
if
(
aImageRendererFlags
&
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
)
{
drawFlags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
if
(
aImageRendererFlags
&
(
nsImageRenderer
:
:
FLAG_PAINTING_TO_WINDOW
|
nsImageRenderer
:
:
FLAG_HIGH_QUALITY_SCALING
)
)
{
drawFlags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
return
drawFlags
;
}
ImgDrawResult
nsImageRenderer
:
:
Draw
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsSize
&
aRepeatSize
const
CSSIntRect
&
aSrc
float
aOpacity
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
if
(
aDest
.
IsEmpty
(
)
|
|
aFill
.
IsEmpty
(
)
|
|
mSize
.
width
<
=
0
|
|
mSize
.
height
<
=
0
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
SamplingFilter
samplingFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
mForFrame
)
;
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
RefPtr
<
gfxContext
>
ctx
=
&
aRenderingContext
;
IntRect
tmpDTRect
;
if
(
ctx
-
>
CurrentOp
(
)
!
=
CompositionOp
:
:
OP_OVER
|
|
mMaskOp
=
=
StyleMaskMode
:
:
Luminance
)
{
gfxRect
clipRect
=
ctx
-
>
GetClipExtents
(
gfxContext
:
:
eDeviceSpace
)
;
tmpDTRect
=
RoundedOut
(
ToRect
(
clipRect
)
)
;
if
(
tmpDTRect
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
RefPtr
<
DrawTarget
>
tempDT
=
ctx
-
>
GetDrawTarget
(
)
-
>
CreateSimilarDrawTarget
(
tmpDTRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
tempDT
|
|
!
tempDT
-
>
IsValid
(
)
)
{
gfxDevCrash
(
LogReason
:
:
InvalidContext
)
<
<
"
ImageRenderer
:
:
Draw
problem
"
<
<
gfx
:
:
hexa
(
tempDT
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
tempDT
-
>
SetTransform
(
ctx
-
>
GetDrawTarget
(
)
-
>
GetTransform
(
)
*
Matrix
:
:
Translation
(
-
tmpDTRect
.
TopLeft
(
)
)
)
;
ctx
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
tempDT
)
;
if
(
!
ctx
)
{
gfxDevCrash
(
LogReason
:
:
InvalidContext
)
<
<
"
ImageRenderer
:
:
Draw
problem
"
<
<
gfx
:
:
hexa
(
tempDT
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
}
switch
(
mType
)
{
case
StyleImage
:
:
Tag
:
:
Rect
:
case
StyleImage
:
:
Tag
:
:
Url
:
{
result
=
nsLayoutUtils
:
:
DrawBackgroundImage
(
*
ctx
mForFrame
aPresContext
mImageContainer
samplingFilter
aDest
aFill
aRepeatSize
aAnchor
aDirtyRect
ConvertImageRendererToDrawFlags
(
mFlags
)
mExtendMode
aOpacity
)
;
break
;
}
case
StyleImage
:
:
Tag
:
:
Gradient
:
{
nsCSSGradientRenderer
renderer
=
nsCSSGradientRenderer
:
:
Create
(
aPresContext
mForFrame
-
>
Style
(
)
*
mGradientData
mSize
)
;
renderer
.
Paint
(
*
ctx
aDest
aFill
aRepeatSize
aSrc
aDirtyRect
aOpacity
)
;
break
;
}
case
StyleImage
:
:
Tag
:
:
Element
:
{
RefPtr
<
gfxDrawable
>
drawable
=
DrawableForElement
(
aDest
*
ctx
)
;
if
(
!
drawable
)
{
NS_WARNING
(
"
Could
not
create
drawable
for
element
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
nsCOMPtr
<
imgIContainer
>
image
(
ImageOps
:
:
CreateFromDrawable
(
drawable
)
)
;
result
=
nsLayoutUtils
:
:
DrawImage
(
*
ctx
mForFrame
-
>
Style
(
)
aPresContext
image
samplingFilter
aDest
aFill
aAnchor
aDirtyRect
ConvertImageRendererToDrawFlags
(
mFlags
)
aOpacity
)
;
break
;
}
case
StyleImage
:
:
Tag
:
:
ImageSet
:
MOZ_FALLTHROUGH_ASSERT
(
"
image
-
set
should
be
resolved
already
"
)
;
case
StyleImage
:
:
Tag
:
:
CrossFade
:
case
StyleImage
:
:
Tag
:
:
None
:
break
;
}
if
(
!
tmpDTRect
.
IsEmpty
(
)
)
{
DrawTarget
*
dt
=
aRenderingContext
.
GetDrawTarget
(
)
;
Matrix
oldTransform
=
dt
-
>
GetTransform
(
)
;
dt
-
>
SetTransform
(
Matrix
(
)
)
;
if
(
mMaskOp
=
=
StyleMaskMode
:
:
Luminance
)
{
RefPtr
<
SourceSurface
>
surf
=
ctx
-
>
GetDrawTarget
(
)
-
>
IntoLuminanceSource
(
LuminanceType
:
:
LUMINANCE
1
.
0f
)
;
dt
-
>
MaskSurface
(
ColorPattern
(
DeviceColor
(
0
0
0
1
.
0f
)
)
surf
tmpDTRect
.
TopLeft
(
)
DrawOptions
(
1
.
0f
aRenderingContext
.
CurrentOp
(
)
)
)
;
}
else
{
RefPtr
<
SourceSurface
>
surf
=
ctx
-
>
GetDrawTarget
(
)
-
>
Snapshot
(
)
;
dt
-
>
DrawSurface
(
surf
Rect
(
tmpDTRect
.
x
tmpDTRect
.
y
tmpDTRect
.
width
tmpDTRect
.
height
)
Rect
(
0
0
tmpDTRect
.
width
tmpDTRect
.
height
)
DrawSurfaceOptions
(
SamplingFilter
:
:
POINT
)
DrawOptions
(
1
.
0f
aRenderingContext
.
CurrentOp
(
)
)
)
;
}
dt
-
>
SetTransform
(
oldTransform
)
;
}
if
(
!
mImage
-
>
IsComplete
(
)
)
{
result
&
=
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
;
}
return
result
;
}
ImgDrawResult
nsImageRenderer
:
:
BuildWebRenderDisplayItems
(
nsPresContext
*
aPresContext
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
const
nsRect
&
aDirtyRect
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsSize
&
aRepeatSize
const
CSSIntRect
&
aSrc
float
aOpacity
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
NOT_READY
;
}
if
(
aDest
.
IsEmpty
(
)
|
|
aFill
.
IsEmpty
(
)
|
|
mSize
.
width
<
=
0
|
|
mSize
.
height
<
=
0
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
ImgDrawResult
drawResult
=
ImgDrawResult
:
:
SUCCESS
;
switch
(
mType
)
{
case
StyleImage
:
:
Tag
:
:
Gradient
:
{
nsCSSGradientRenderer
renderer
=
nsCSSGradientRenderer
:
:
Create
(
aPresContext
mForFrame
-
>
Style
(
)
*
mGradientData
mSize
)
;
renderer
.
BuildWebRenderDisplayItems
(
aBuilder
aSc
aDest
aFill
aRepeatSize
aSrc
!
aItem
-
>
BackfaceIsHidden
(
)
aOpacity
)
;
break
;
}
case
StyleImage
:
:
Tag
:
:
Rect
:
case
StyleImage
:
:
Tag
:
:
Url
:
{
ExtendMode
extendMode
=
mExtendMode
;
if
(
aDest
.
Contains
(
aFill
)
)
{
extendMode
=
ExtendMode
:
:
CLAMP
;
}
uint32_t
containerFlags
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
mFlags
&
(
nsImageRenderer
:
:
FLAG_PAINTING_TO_WINDOW
|
nsImageRenderer
:
:
FLAG_HIGH_QUALITY_SCALING
)
)
{
containerFlags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
if
(
mFlags
&
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
)
{
containerFlags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
if
(
extendMode
=
=
ExtendMode
:
:
CLAMP
&
&
StaticPrefs
:
:
image_svg_blob_image
(
)
&
&
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
containerFlags
|
=
imgIContainer
:
:
FLAG_RECORD_BLOB
;
}
CSSIntSize
destCSSSize
{
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aDest
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aDest
.
height
)
}
;
Maybe
<
SVGImageContext
>
svgContext
(
Some
(
SVGImageContext
(
Some
(
destCSSSize
)
)
)
)
;
Maybe
<
ImageIntRegion
>
region
;
const
int32_t
appUnitsPerDevPixel
=
mForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
destRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
aDest
appUnitsPerDevPixel
)
;
LayoutDeviceRect
clipRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
aFill
appUnitsPerDevPixel
)
;
auto
stretchSize
=
wr
:
:
ToLayoutSize
(
destRect
.
Size
(
)
)
;
gfx
:
:
IntSize
decodeSize
=
nsLayoutUtils
:
:
ComputeImageContainerDrawingParameters
(
mImageContainer
mForFrame
destRect
clipRect
aSc
containerFlags
svgContext
region
)
;
RefPtr
<
image
:
:
WebRenderImageProvider
>
provider
;
drawResult
=
mImageContainer
-
>
GetImageProvider
(
aManager
-
>
LayerManager
(
)
decodeSize
svgContext
region
containerFlags
getter_AddRefs
(
provider
)
)
;
Maybe
<
wr
:
:
ImageKey
>
key
=
aManager
-
>
CommandBuilder
(
)
.
CreateImageProviderKey
(
aItem
provider
drawResult
aResources
)
;
if
(
key
.
isNothing
(
)
)
{
break
;
}
auto
rendering
=
wr
:
:
ToImageRendering
(
aItem
-
>
Frame
(
)
-
>
UsedImageRendering
(
)
)
;
wr
:
:
LayoutRect
clip
=
wr
:
:
ToLayoutRect
(
clipRect
)
;
wr
:
:
LayoutRect
dest
=
region
?
clip
:
wr
:
:
ToLayoutRect
(
destRect
)
;
if
(
extendMode
=
=
ExtendMode
:
:
CLAMP
)
{
aBuilder
.
PushImage
(
dest
clip
!
aItem
-
>
BackfaceIsHidden
(
)
false
rendering
key
.
value
(
)
true
wr
:
:
ColorF
{
1
.
0f
1
.
0f
1
.
0f
aOpacity
}
)
;
}
else
{
nsPoint
firstTilePos
=
nsLayoutUtils
:
:
GetBackgroundFirstTilePos
(
aDest
.
TopLeft
(
)
aFill
.
TopLeft
(
)
aRepeatSize
)
;
LayoutDeviceRect
fillRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
nsRect
(
firstTilePos
.
x
firstTilePos
.
y
aFill
.
XMost
(
)
-
firstTilePos
.
x
aFill
.
YMost
(
)
-
firstTilePos
.
y
)
appUnitsPerDevPixel
)
;
wr
:
:
LayoutRect
fill
=
wr
:
:
ToLayoutRect
(
fillRect
)
;
switch
(
extendMode
)
{
case
ExtendMode
:
:
REPEAT_Y
:
fill
.
min
.
x
=
dest
.
min
.
x
;
fill
.
max
.
x
=
dest
.
max
.
x
;
stretchSize
.
width
=
dest
.
width
(
)
;
break
;
case
ExtendMode
:
:
REPEAT_X
:
fill
.
min
.
y
=
dest
.
min
.
y
;
fill
.
max
.
y
=
dest
.
max
.
y
;
stretchSize
.
height
=
dest
.
height
(
)
;
break
;
default
:
break
;
}
LayoutDeviceSize
gapSize
=
LayoutDeviceSize
:
:
FromAppUnits
(
aRepeatSize
-
aDest
.
Size
(
)
appUnitsPerDevPixel
)
;
aBuilder
.
PushRepeatingImage
(
fill
clip
!
aItem
-
>
BackfaceIsHidden
(
)
stretchSize
wr
:
:
ToLayoutSize
(
gapSize
)
rendering
key
.
value
(
)
true
wr
:
:
ColorF
{
1
.
0f
1
.
0f
1
.
0f
aOpacity
}
)
;
}
break
;
}
default
:
break
;
}
if
(
!
mImage
-
>
IsComplete
(
)
&
&
drawResult
=
=
ImgDrawResult
:
:
SUCCESS
)
{
return
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
;
}
return
drawResult
;
}
already_AddRefed
<
gfxDrawable
>
nsImageRenderer
:
:
DrawableForElement
(
const
nsRect
&
aImageRect
gfxContext
&
aContext
)
{
NS_ASSERTION
(
mType
=
=
StyleImage
:
:
Tag
:
:
Element
"
DrawableForElement
only
makes
sense
if
backed
by
an
element
"
)
;
if
(
mPaintServerFrame
)
{
int32_t
appUnitsPerDevPixel
=
mForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
destRect
=
aImageRect
-
aImageRect
.
TopLeft
(
)
;
nsIntSize
roundedOut
=
destRect
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
.
Size
(
)
;
IntSize
imageSize
(
roundedOut
.
width
roundedOut
.
height
)
;
RefPtr
<
gfxDrawable
>
drawable
;
SurfaceFormat
format
=
aContext
.
GetDrawTarget
(
)
-
>
GetFormat
(
)
;
if
(
aContext
.
GetDrawTarget
(
)
-
>
CanCreateSimilarDrawTarget
(
imageSize
format
)
)
{
drawable
=
SVGIntegrationUtils
:
:
DrawableFromPaintServer
(
mPaintServerFrame
mForFrame
mSize
imageSize
aContext
.
GetDrawTarget
(
)
aContext
.
CurrentMatrixDouble
(
)
SVGIntegrationUtils
:
:
FLAG_SYNC_DECODE_IMAGES
)
;
}
return
drawable
.
forget
(
)
;
}
NS_ASSERTION
(
mImageElementSurface
.
GetSourceSurface
(
)
"
Surface
should
be
ready
.
"
)
;
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxSurfaceDrawable
(
mImageElementSurface
.
GetSourceSurface
(
)
.
get
(
)
mImageElementSurface
.
mSize
)
;
return
drawable
.
forget
(
)
;
}
ImgDrawResult
nsImageRenderer
:
:
DrawLayer
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
const
nsSize
&
aRepeatSize
float
aOpacity
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
if
(
aDest
.
IsEmpty
(
)
|
|
aFill
.
IsEmpty
(
)
|
|
mSize
.
width
<
=
0
|
|
mSize
.
height
<
=
0
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
return
Draw
(
aPresContext
aRenderingContext
aDirty
aDest
aFill
aAnchor
aRepeatSize
CSSIntRect
(
0
0
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
height
)
)
aOpacity
)
;
}
ImgDrawResult
nsImageRenderer
:
:
BuildWebRenderDisplayItemsForLayer
(
nsPresContext
*
aPresContext
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
const
nsSize
&
aRepeatSize
float
aOpacity
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
mPrepareResult
;
}
CSSIntRect
srcRect
(
0
0
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
height
)
)
;
if
(
aDest
.
IsEmpty
(
)
|
|
aFill
.
IsEmpty
(
)
|
|
srcRect
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
return
BuildWebRenderDisplayItems
(
aPresContext
aBuilder
aResources
aSc
aManager
aItem
aDirty
aDest
aFill
aAnchor
aRepeatSize
srcRect
aOpacity
)
;
}
static
nsRect
ComputeTile
(
nsRect
&
aFill
StyleBorderImageRepeat
aHFill
StyleBorderImageRepeat
aVFill
const
nsSize
&
aUnitSize
nsSize
&
aRepeatSize
)
{
nsRect
tile
;
switch
(
aHFill
)
{
case
StyleBorderImageRepeat
:
:
Stretch
:
tile
.
x
=
aFill
.
x
;
tile
.
width
=
aFill
.
width
;
aRepeatSize
.
width
=
tile
.
width
;
break
;
case
StyleBorderImageRepeat
:
:
Repeat
:
tile
.
x
=
aFill
.
x
+
aFill
.
width
/
2
-
aUnitSize
.
width
/
2
;
tile
.
width
=
aUnitSize
.
width
;
aRepeatSize
.
width
=
tile
.
width
;
break
;
case
StyleBorderImageRepeat
:
:
Round
:
tile
.
x
=
aFill
.
x
;
tile
.
width
=
nsCSSRendering
:
:
ComputeRoundedSize
(
aUnitSize
.
width
aFill
.
width
)
;
aRepeatSize
.
width
=
tile
.
width
;
break
;
case
StyleBorderImageRepeat
:
:
Space
:
{
nscoord
space
;
aRepeatSize
.
width
=
nsCSSRendering
:
:
ComputeBorderSpacedRepeatSize
(
aUnitSize
.
width
aFill
.
width
space
)
;
tile
.
x
=
aFill
.
x
+
space
;
tile
.
width
=
aUnitSize
.
width
;
aFill
.
x
=
tile
.
x
;
aFill
.
width
=
aFill
.
width
-
space
*
2
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unrecognized
border
-
image
fill
style
"
)
;
}
switch
(
aVFill
)
{
case
StyleBorderImageRepeat
:
:
Stretch
:
tile
.
y
=
aFill
.
y
;
tile
.
height
=
aFill
.
height
;
aRepeatSize
.
height
=
tile
.
height
;
break
;
case
StyleBorderImageRepeat
:
:
Repeat
:
tile
.
y
=
aFill
.
y
+
aFill
.
height
/
2
-
aUnitSize
.
height
/
2
;
tile
.
height
=
aUnitSize
.
height
;
aRepeatSize
.
height
=
tile
.
height
;
break
;
case
StyleBorderImageRepeat
:
:
Round
:
tile
.
y
=
aFill
.
y
;
tile
.
height
=
nsCSSRendering
:
:
ComputeRoundedSize
(
aUnitSize
.
height
aFill
.
height
)
;
aRepeatSize
.
height
=
tile
.
height
;
break
;
case
StyleBorderImageRepeat
:
:
Space
:
{
nscoord
space
;
aRepeatSize
.
height
=
nsCSSRendering
:
:
ComputeBorderSpacedRepeatSize
(
aUnitSize
.
height
aFill
.
height
space
)
;
tile
.
y
=
aFill
.
y
+
space
;
tile
.
height
=
aUnitSize
.
height
;
aFill
.
y
=
tile
.
y
;
aFill
.
height
=
aFill
.
height
-
space
*
2
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unrecognized
border
-
image
fill
style
"
)
;
}
return
tile
;
}
static
bool
RequiresScaling
(
const
nsRect
&
aFill
StyleBorderImageRepeat
aHFill
StyleBorderImageRepeat
aVFill
const
nsSize
&
aUnitSize
)
{
return
(
aHFill
!
=
StyleBorderImageRepeat
:
:
Stretch
|
|
aVFill
!
=
StyleBorderImageRepeat
:
:
Stretch
)
&
&
(
aUnitSize
.
width
!
=
aFill
.
width
|
|
aUnitSize
.
height
!
=
aFill
.
height
)
;
}
ImgDrawResult
nsImageRenderer
:
:
DrawBorderImageComponent
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aFill
const
CSSIntRect
&
aSrc
StyleBorderImageRepeat
aHFill
StyleBorderImageRepeat
aVFill
const
nsSize
&
aUnitSize
uint8_t
aIndex
const
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasIntrinsicRatio
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
aFill
.
IsEmpty
(
)
|
|
aSrc
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
const
bool
isRequestBacked
=
mType
=
=
StyleImage
:
:
Tag
:
:
Url
|
|
mType
=
=
StyleImage
:
:
Tag
:
:
Rect
;
MOZ_ASSERT
(
isRequestBacked
=
=
mImage
-
>
IsImageRequestType
(
)
)
;
if
(
isRequestBacked
|
|
mType
=
=
StyleImage
:
:
Tag
:
:
Element
)
{
nsCOMPtr
<
imgIContainer
>
subImage
;
uint32_t
drawFlags
=
ConvertImageRendererToDrawFlags
(
mFlags
)
|
imgIContainer
:
:
FLAG_FORCE_PRESERVEASPECTRATIO_NONE
;
if
(
!
aHasIntrinsicRatio
)
{
drawFlags
=
drawFlags
|
imgIContainer
:
:
FLAG_FORCE_UNIFORM_SCALING
;
}
nsIntRect
srcRect
(
aSrc
.
x
aSrc
.
y
aSrc
.
width
aSrc
.
height
)
;
if
(
isRequestBacked
)
{
CachedBorderImageData
*
cachedData
=
mForFrame
-
>
GetProperty
(
nsIFrame
:
:
CachedBorderImageDataProperty
(
)
)
;
if
(
!
cachedData
)
{
cachedData
=
new
CachedBorderImageData
(
)
;
mForFrame
-
>
AddProperty
(
nsIFrame
:
:
CachedBorderImageDataProperty
(
)
cachedData
)
;
}
if
(
!
(
subImage
=
cachedData
-
>
GetSubImage
(
aIndex
)
)
)
{
subImage
=
ImageOps
:
:
Clip
(
mImageContainer
srcRect
aSVGViewportSize
)
;
cachedData
-
>
SetSubImage
(
aIndex
subImage
)
;
}
}
else
{
RefPtr
<
gfxDrawable
>
drawable
=
DrawableForElement
(
nsRect
(
nsPoint
(
)
mSize
)
aRenderingContext
)
;
if
(
!
drawable
)
{
NS_WARNING
(
"
Could
not
create
drawable
for
element
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
nsCOMPtr
<
imgIContainer
>
image
(
ImageOps
:
:
CreateFromDrawable
(
drawable
)
)
;
subImage
=
ImageOps
:
:
Clip
(
image
srcRect
aSVGViewportSize
)
;
}
MOZ_ASSERT
(
!
aSVGViewportSize
|
|
subImage
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
;
SamplingFilter
samplingFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
mForFrame
)
;
if
(
!
RequiresScaling
(
aFill
aHFill
aVFill
aUnitSize
)
)
{
ImgDrawResult
result
=
nsLayoutUtils
:
:
DrawSingleImage
(
aRenderingContext
aPresContext
subImage
samplingFilter
aFill
aDirtyRect
Nothing
(
)
drawFlags
)
;
if
(
!
mImage
-
>
IsComplete
(
)
)
{
result
&
=
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
;
}
return
result
;
}
nsSize
repeatSize
;
nsRect
fillRect
(
aFill
)
;
nsRect
tile
=
ComputeTile
(
fillRect
aHFill
aVFill
aUnitSize
repeatSize
)
;
ImgDrawResult
result
=
nsLayoutUtils
:
:
DrawBackgroundImage
(
aRenderingContext
mForFrame
aPresContext
subImage
samplingFilter
tile
fillRect
repeatSize
tile
.
TopLeft
(
)
aDirtyRect
drawFlags
ExtendMode
:
:
CLAMP
1
.
0
)
;
if
(
!
mImage
-
>
IsComplete
(
)
)
{
result
&
=
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
;
}
return
result
;
}
nsSize
repeatSize
(
aFill
.
Size
(
)
)
;
nsRect
fillRect
(
aFill
)
;
nsRect
destTile
=
RequiresScaling
(
fillRect
aHFill
aVFill
aUnitSize
)
?
ComputeTile
(
fillRect
aHFill
aVFill
aUnitSize
repeatSize
)
:
fillRect
;
return
Draw
(
aPresContext
aRenderingContext
aDirtyRect
destTile
fillRect
destTile
.
TopLeft
(
)
repeatSize
aSrc
)
;
}
ImgDrawResult
nsImageRenderer
:
:
DrawShapeImage
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
NOT_READY
;
}
if
(
mSize
.
width
<
=
0
|
|
mSize
.
height
<
=
0
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
if
(
mImage
-
>
IsImageRequestType
(
)
)
{
uint32_t
drawFlags
=
ConvertImageRendererToDrawFlags
(
mFlags
)
|
imgIContainer
:
:
FRAME_FIRST
;
nsRect
dest
(
nsPoint
(
0
0
)
mSize
)
;
return
nsLayoutUtils
:
:
DrawSingleImage
(
aRenderingContext
aPresContext
mImageContainer
SamplingFilter
:
:
POINT
dest
dest
Nothing
(
)
drawFlags
)
;
}
if
(
mImage
-
>
IsGradient
(
)
)
{
nsCSSGradientRenderer
renderer
=
nsCSSGradientRenderer
:
:
Create
(
aPresContext
mForFrame
-
>
Style
(
)
*
mGradientData
mSize
)
;
nsRect
dest
(
nsPoint
(
0
0
)
mSize
)
;
renderer
.
Paint
(
aRenderingContext
dest
dest
mSize
CSSIntRect
:
:
FromAppUnitsRounded
(
dest
)
dest
1
.
0
)
;
return
ImgDrawResult
:
:
SUCCESS
;
}
return
ImgDrawResult
:
:
BAD_IMAGE
;
}
bool
nsImageRenderer
:
:
IsRasterImage
(
)
{
return
mImageContainer
&
&
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_RASTER
;
}
already_AddRefed
<
imgIContainer
>
nsImageRenderer
:
:
GetImage
(
)
{
return
do_AddRef
(
mImageContainer
)
;
}
void
nsImageRenderer
:
:
PurgeCacheForViewportChange
(
const
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasIntrinsicRatio
)
{
if
(
mImageContainer
&
&
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
if
(
auto
*
cachedData
=
mForFrame
-
>
GetProperty
(
nsIFrame
:
:
CachedBorderImageDataProperty
(
)
)
)
{
cachedData
-
>
PurgeCacheForViewportChange
(
aSVGViewportSize
aHasIntrinsicRatio
)
;
}
}
}
