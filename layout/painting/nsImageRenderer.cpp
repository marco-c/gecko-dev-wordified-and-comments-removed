#
include
"
nsImageRenderer
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
ImageOps
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsCSSRenderingGradients
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsSVGDisplayableFrame
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
layers
;
nsSize
CSSSizeOrRatio
:
:
ComputeConcreteSize
(
)
const
{
NS_ASSERTION
(
CanComputeConcreteSize
(
)
"
Cannot
compute
"
)
;
if
(
mHasWidth
&
&
mHasHeight
)
{
return
nsSize
(
mWidth
mHeight
)
;
}
if
(
mHasWidth
)
{
nscoord
height
=
NSCoordSaturatingNonnegativeMultiply
(
mWidth
double
(
mRatio
.
height
)
/
mRatio
.
width
)
;
return
nsSize
(
mWidth
height
)
;
}
MOZ_ASSERT
(
mHasHeight
)
;
nscoord
width
=
NSCoordSaturatingNonnegativeMultiply
(
mHeight
double
(
mRatio
.
width
)
/
mRatio
.
height
)
;
return
nsSize
(
width
mHeight
)
;
}
nsImageRenderer
:
:
nsImageRenderer
(
nsIFrame
*
aForFrame
const
nsStyleImage
*
aImage
uint32_t
aFlags
)
:
mForFrame
(
aForFrame
)
mImage
(
aImage
)
mType
(
aImage
-
>
GetType
(
)
)
mImageContainer
(
nullptr
)
mGradientData
(
nullptr
)
mPaintServerFrame
(
nullptr
)
mPrepareResult
(
ImgDrawResult
:
:
NOT_READY
)
mSize
(
0
0
)
mFlags
(
aFlags
)
mExtendMode
(
ExtendMode
:
:
CLAMP
)
mMaskOp
(
NS_STYLE_MASK_MODE_MATCH_SOURCE
)
{
}
static
bool
ShouldTreatAsCompleteDueToSyncDecode
(
const
nsStyleImage
*
aImage
uint32_t
aFlags
)
{
if
(
!
(
aFlags
&
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
)
)
{
return
false
;
}
if
(
aImage
-
>
GetType
(
)
!
=
eStyleImageType_Image
)
{
return
false
;
}
imgRequestProxy
*
req
=
aImage
-
>
GetImageData
(
)
;
if
(
!
req
)
{
return
false
;
}
uint32_t
status
=
0
;
if
(
NS_FAILED
(
req
-
>
GetImageStatus
(
&
status
)
)
)
{
return
false
;
}
if
(
status
&
imgIRequest
:
:
STATUS_ERROR
)
{
nsCOMPtr
<
imgIContainer
>
image
;
req
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
return
bool
(
image
)
;
}
if
(
!
(
status
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
)
)
{
return
false
;
}
return
true
;
}
bool
nsImageRenderer
:
:
PrepareImage
(
)
{
if
(
mImage
-
>
IsEmpty
(
)
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
if
(
!
mImage
-
>
IsComplete
(
)
)
{
bool
frameComplete
=
mImage
-
>
StartDecoding
(
)
;
if
(
!
(
frameComplete
|
|
mImage
-
>
IsComplete
(
)
)
&
&
!
ShouldTreatAsCompleteDueToSyncDecode
(
mImage
mFlags
)
)
{
mPrepareResult
=
ImgDrawResult
:
:
NOT_READY
;
return
false
;
}
}
switch
(
mType
)
{
case
eStyleImageType_Image
:
{
MOZ_ASSERT
(
mImage
-
>
GetImageData
(
)
"
must
have
image
data
since
we
checked
IsEmpty
above
"
)
;
nsCOMPtr
<
imgIContainer
>
srcImage
;
DebugOnly
<
nsresult
>
rv
=
mImage
-
>
GetImageData
(
)
-
>
GetImage
(
getter_AddRefs
(
srcImage
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
&
&
srcImage
"
If
GetImage
(
)
is
failing
mImage
-
>
IsComplete
(
)
"
"
should
have
returned
false
"
)
;
if
(
!
mImage
-
>
GetCropRect
(
)
)
{
mImageContainer
.
swap
(
srcImage
)
;
}
else
{
nsIntRect
actualCropRect
;
bool
isEntireImage
;
bool
success
=
mImage
-
>
ComputeActualCropRect
(
actualCropRect
&
isEntireImage
)
;
if
(
!
success
|
|
actualCropRect
.
IsEmpty
(
)
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
if
(
isEntireImage
)
{
mImageContainer
.
swap
(
srcImage
)
;
}
else
{
nsCOMPtr
<
imgIContainer
>
subImage
=
ImageOps
:
:
Clip
(
srcImage
actualCropRect
Nothing
(
)
)
;
mImageContainer
.
swap
(
subImage
)
;
}
}
mPrepareResult
=
ImgDrawResult
:
:
SUCCESS
;
break
;
}
case
eStyleImageType_Gradient
:
mGradientData
=
mImage
-
>
GetGradientData
(
)
;
mPrepareResult
=
ImgDrawResult
:
:
SUCCESS
;
break
;
case
eStyleImageType_Element
:
{
nsAutoString
elementId
=
NS_LITERAL_STRING
(
"
#
"
)
+
nsDependentAtomString
(
mImage
-
>
GetElementId
(
)
)
;
nsCOMPtr
<
nsIURI
>
targetURI
;
nsCOMPtr
<
nsIURI
>
base
=
mForFrame
-
>
GetContent
(
)
-
>
GetBaseURI
(
)
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
targetURI
)
elementId
mForFrame
-
>
GetContent
(
)
-
>
GetUncomposedDoc
(
)
base
)
;
nsSVGPaintingProperty
*
property
=
SVGObserverUtils
:
:
GetPaintingPropertyForURI
(
targetURI
mForFrame
-
>
FirstContinuation
(
)
SVGObserverUtils
:
:
BackgroundImageProperty
(
)
)
;
if
(
!
property
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
mImageElementSurface
=
nsLayoutUtils
:
:
SurfaceFromElement
(
property
-
>
GetReferencedElement
(
)
)
;
if
(
!
mImageElementSurface
.
GetSourceSurface
(
)
)
{
nsIFrame
*
paintServerFrame
=
property
-
>
GetReferencedFrame
(
)
;
if
(
!
paintServerFrame
|
|
(
paintServerFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
paintServerFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGPaintServer
)
&
&
!
static_cast
<
nsSVGDisplayableFrame
*
>
(
do_QueryFrame
(
paintServerFrame
)
)
)
)
{
mPrepareResult
=
ImgDrawResult
:
:
BAD_IMAGE
;
return
false
;
}
mPaintServerFrame
=
paintServerFrame
;
}
mPrepareResult
=
ImgDrawResult
:
:
SUCCESS
;
break
;
}
case
eStyleImageType_Null
:
default
:
break
;
}
return
IsReady
(
)
;
}
CSSSizeOrRatio
nsImageRenderer
:
:
ComputeIntrinsicSize
(
)
{
NS_ASSERTION
(
IsReady
(
)
"
Ensure
PrepareImage
(
)
has
returned
true
"
"
before
calling
me
"
)
;
CSSSizeOrRatio
result
;
switch
(
mType
)
{
case
eStyleImageType_Image
:
{
bool
haveWidth
haveHeight
;
CSSIntSize
imageIntSize
;
nsLayoutUtils
:
:
ComputeSizeForDrawing
(
mImageContainer
imageIntSize
result
.
mRatio
haveWidth
haveHeight
)
;
if
(
haveWidth
)
{
result
.
SetWidth
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
imageIntSize
.
width
)
)
;
}
if
(
haveHeight
)
{
result
.
SetHeight
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
imageIntSize
.
height
)
)
;
}
if
(
!
haveHeight
&
&
haveWidth
&
&
result
.
mRatio
.
width
!
=
0
)
{
nscoord
intrinsicHeight
=
NSCoordSaturatingNonnegativeMultiply
(
imageIntSize
.
width
float
(
result
.
mRatio
.
height
)
/
float
(
result
.
mRatio
.
width
)
)
;
result
.
SetHeight
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
intrinsicHeight
)
)
;
}
else
if
(
haveHeight
&
&
!
haveWidth
&
&
result
.
mRatio
.
height
!
=
0
)
{
nscoord
intrinsicWidth
=
NSCoordSaturatingNonnegativeMultiply
(
imageIntSize
.
height
float
(
result
.
mRatio
.
width
)
/
float
(
result
.
mRatio
.
height
)
)
;
result
.
SetWidth
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
intrinsicWidth
)
)
;
}
break
;
}
case
eStyleImageType_Element
:
{
if
(
mPaintServerFrame
)
{
if
(
!
mPaintServerFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
int32_t
appUnitsPerDevPixel
=
mForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
result
.
SetSize
(
IntSizeToAppUnits
(
nsSVGIntegrationUtils
:
:
GetContinuationUnionSize
(
mPaintServerFrame
)
.
ToNearestPixels
(
appUnitsPerDevPixel
)
appUnitsPerDevPixel
)
)
;
}
}
else
{
NS_ASSERTION
(
mImageElementSurface
.
GetSourceSurface
(
)
"
Surface
should
be
ready
.
"
)
;
IntSize
surfaceSize
=
mImageElementSurface
.
mSize
;
result
.
SetSize
(
nsSize
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
surfaceSize
.
width
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
surfaceSize
.
height
)
)
)
;
}
break
;
}
case
eStyleImageType_Gradient
:
case
eStyleImageType_Null
:
default
:
break
;
}
return
result
;
}
nsSize
nsImageRenderer
:
:
ComputeConcreteSize
(
const
CSSSizeOrRatio
&
aSpecifiedSize
const
CSSSizeOrRatio
&
aIntrinsicSize
const
nsSize
&
aDefaultSize
)
{
if
(
aSpecifiedSize
.
IsConcrete
(
)
)
{
return
aSpecifiedSize
.
ComputeConcreteSize
(
)
;
}
MOZ_ASSERT
(
!
aSpecifiedSize
.
mHasWidth
|
|
!
aSpecifiedSize
.
mHasHeight
)
;
if
(
!
aSpecifiedSize
.
mHasWidth
&
&
!
aSpecifiedSize
.
mHasHeight
)
{
if
(
aIntrinsicSize
.
CanComputeConcreteSize
(
)
)
{
return
aIntrinsicSize
.
ComputeConcreteSize
(
)
;
}
if
(
aIntrinsicSize
.
mHasWidth
)
{
return
nsSize
(
aIntrinsicSize
.
mWidth
aDefaultSize
.
height
)
;
}
if
(
aIntrinsicSize
.
mHasHeight
)
{
return
nsSize
(
aDefaultSize
.
width
aIntrinsicSize
.
mHeight
)
;
}
return
ComputeConstrainedSize
(
aDefaultSize
aIntrinsicSize
.
mRatio
CONTAIN
)
;
}
MOZ_ASSERT
(
aSpecifiedSize
.
mHasWidth
|
|
aSpecifiedSize
.
mHasHeight
)
;
if
(
aSpecifiedSize
.
mHasWidth
)
{
nscoord
height
;
if
(
aIntrinsicSize
.
HasRatio
(
)
)
{
height
=
NSCoordSaturatingNonnegativeMultiply
(
aSpecifiedSize
.
mWidth
double
(
aIntrinsicSize
.
mRatio
.
height
)
/
aIntrinsicSize
.
mRatio
.
width
)
;
}
else
if
(
aIntrinsicSize
.
mHasHeight
)
{
height
=
aIntrinsicSize
.
mHeight
;
}
else
{
height
=
aDefaultSize
.
height
;
}
return
nsSize
(
aSpecifiedSize
.
mWidth
height
)
;
}
MOZ_ASSERT
(
aSpecifiedSize
.
mHasHeight
)
;
nscoord
width
;
if
(
aIntrinsicSize
.
HasRatio
(
)
)
{
width
=
NSCoordSaturatingNonnegativeMultiply
(
aSpecifiedSize
.
mHeight
double
(
aIntrinsicSize
.
mRatio
.
width
)
/
aIntrinsicSize
.
mRatio
.
height
)
;
}
else
if
(
aIntrinsicSize
.
mHasWidth
)
{
width
=
aIntrinsicSize
.
mWidth
;
}
else
{
width
=
aDefaultSize
.
width
;
}
return
nsSize
(
width
aSpecifiedSize
.
mHeight
)
;
}
nsSize
nsImageRenderer
:
:
ComputeConstrainedSize
(
const
nsSize
&
aConstrainingSize
const
nsSize
&
aIntrinsicRatio
FitType
aFitType
)
{
if
(
aIntrinsicRatio
.
width
<
=
0
&
&
aIntrinsicRatio
.
height
<
=
0
)
{
return
aConstrainingSize
;
}
float
scaleX
=
double
(
aConstrainingSize
.
width
)
/
aIntrinsicRatio
.
width
;
float
scaleY
=
double
(
aConstrainingSize
.
height
)
/
aIntrinsicRatio
.
height
;
nsSize
size
;
if
(
(
aFitType
=
=
CONTAIN
)
=
=
(
scaleX
<
scaleY
)
)
{
size
.
width
=
aConstrainingSize
.
width
;
size
.
height
=
NSCoordSaturatingNonnegativeMultiply
(
aIntrinsicRatio
.
height
scaleX
)
;
if
(
aFitType
=
=
CONTAIN
&
&
aConstrainingSize
.
height
-
size
.
height
<
AppUnitsPerCSSPixel
(
)
)
{
size
.
height
=
aConstrainingSize
.
height
;
}
}
else
{
size
.
width
=
NSCoordSaturatingNonnegativeMultiply
(
aIntrinsicRatio
.
width
scaleY
)
;
if
(
aFitType
=
=
CONTAIN
&
&
aConstrainingSize
.
width
-
size
.
width
<
AppUnitsPerCSSPixel
(
)
)
{
size
.
width
=
aConstrainingSize
.
width
;
}
size
.
height
=
aConstrainingSize
.
height
;
}
return
size
;
}
void
nsImageRenderer
:
:
SetPreferredSize
(
const
CSSSizeOrRatio
&
aIntrinsicSize
const
nsSize
&
aDefaultSize
)
{
mSize
.
width
=
aIntrinsicSize
.
mHasWidth
?
aIntrinsicSize
.
mWidth
:
aDefaultSize
.
width
;
mSize
.
height
=
aIntrinsicSize
.
mHasHeight
?
aIntrinsicSize
.
mHeight
:
aDefaultSize
.
height
;
}
static
uint32_t
ConvertImageRendererToDrawFlags
(
uint32_t
aImageRendererFlags
)
{
uint32_t
drawFlags
=
imgIContainer
:
:
FLAG_NONE
;
if
(
aImageRendererFlags
&
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
)
{
drawFlags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
if
(
aImageRendererFlags
&
nsImageRenderer
:
:
FLAG_PAINTING_TO_WINDOW
)
{
drawFlags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
return
drawFlags
;
}
ImgDrawResult
nsImageRenderer
:
:
Draw
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsSize
&
aRepeatSize
const
CSSIntRect
&
aSrc
float
aOpacity
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
if
(
aDest
.
IsEmpty
(
)
|
|
aFill
.
IsEmpty
(
)
|
|
mSize
.
width
<
=
0
|
|
mSize
.
height
<
=
0
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
SamplingFilter
samplingFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
mForFrame
)
;
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
RefPtr
<
gfxContext
>
ctx
=
&
aRenderingContext
;
IntRect
tmpDTRect
;
if
(
ctx
-
>
CurrentOp
(
)
!
=
CompositionOp
:
:
OP_OVER
|
|
mMaskOp
=
=
NS_STYLE_MASK_MODE_LUMINANCE
)
{
gfxRect
clipRect
=
ctx
-
>
GetClipExtents
(
gfxContext
:
:
eDeviceSpace
)
;
tmpDTRect
=
RoundedOut
(
ToRect
(
clipRect
)
)
;
if
(
tmpDTRect
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
RefPtr
<
DrawTarget
>
tempDT
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateSimilarSoftwareDrawTarget
(
ctx
-
>
GetDrawTarget
(
)
tmpDTRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
tempDT
|
|
!
tempDT
-
>
IsValid
(
)
)
{
gfxDevCrash
(
LogReason
:
:
InvalidContext
)
<
<
"
ImageRenderer
:
:
Draw
problem
"
<
<
gfx
:
:
hexa
(
tempDT
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
tempDT
-
>
SetTransform
(
ctx
-
>
GetDrawTarget
(
)
-
>
GetTransform
(
)
*
Matrix
:
:
Translation
(
-
tmpDTRect
.
TopLeft
(
)
)
)
;
ctx
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
tempDT
)
;
if
(
!
ctx
)
{
gfxDevCrash
(
LogReason
:
:
InvalidContext
)
<
<
"
ImageRenderer
:
:
Draw
problem
"
<
<
gfx
:
:
hexa
(
tempDT
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
}
switch
(
mType
)
{
case
eStyleImageType_Image
:
{
CSSIntSize
imageSize
(
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
height
)
)
;
result
=
nsLayoutUtils
:
:
DrawBackgroundImage
(
*
ctx
mForFrame
aPresContext
mImageContainer
imageSize
samplingFilter
aDest
aFill
aRepeatSize
aAnchor
aDirtyRect
ConvertImageRendererToDrawFlags
(
mFlags
)
mExtendMode
aOpacity
)
;
break
;
}
case
eStyleImageType_Gradient
:
{
nsCSSGradientRenderer
renderer
=
nsCSSGradientRenderer
:
:
Create
(
aPresContext
mForFrame
-
>
Style
(
)
mGradientData
mSize
)
;
renderer
.
Paint
(
*
ctx
aDest
aFill
aRepeatSize
aSrc
aDirtyRect
aOpacity
)
;
break
;
}
case
eStyleImageType_Element
:
{
RefPtr
<
gfxDrawable
>
drawable
=
DrawableForElement
(
aDest
*
ctx
)
;
if
(
!
drawable
)
{
NS_WARNING
(
"
Could
not
create
drawable
for
element
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
nsCOMPtr
<
imgIContainer
>
image
(
ImageOps
:
:
CreateFromDrawable
(
drawable
)
)
;
result
=
nsLayoutUtils
:
:
DrawImage
(
*
ctx
mForFrame
-
>
Style
(
)
aPresContext
image
samplingFilter
aDest
aFill
aAnchor
aDirtyRect
ConvertImageRendererToDrawFlags
(
mFlags
)
aOpacity
)
;
break
;
}
case
eStyleImageType_Null
:
default
:
break
;
}
if
(
!
tmpDTRect
.
IsEmpty
(
)
)
{
DrawTarget
*
dt
=
aRenderingContext
.
GetDrawTarget
(
)
;
Matrix
oldTransform
=
dt
-
>
GetTransform
(
)
;
dt
-
>
SetTransform
(
Matrix
(
)
)
;
if
(
mMaskOp
=
=
NS_STYLE_MASK_MODE_LUMINANCE
)
{
RefPtr
<
SourceSurface
>
surf
=
ctx
-
>
GetDrawTarget
(
)
-
>
IntoLuminanceSource
(
LuminanceType
:
:
LUMINANCE
1
.
0f
)
;
dt
-
>
MaskSurface
(
ColorPattern
(
Color
(
0
0
0
1
.
0f
)
)
surf
tmpDTRect
.
TopLeft
(
)
DrawOptions
(
1
.
0f
aRenderingContext
.
CurrentOp
(
)
)
)
;
}
else
{
RefPtr
<
SourceSurface
>
surf
=
ctx
-
>
GetDrawTarget
(
)
-
>
Snapshot
(
)
;
dt
-
>
DrawSurface
(
surf
Rect
(
tmpDTRect
.
x
tmpDTRect
.
y
tmpDTRect
.
width
tmpDTRect
.
height
)
Rect
(
0
0
tmpDTRect
.
width
tmpDTRect
.
height
)
DrawSurfaceOptions
(
SamplingFilter
:
:
POINT
)
DrawOptions
(
1
.
0f
aRenderingContext
.
CurrentOp
(
)
)
)
;
}
dt
-
>
SetTransform
(
oldTransform
)
;
}
if
(
!
mImage
-
>
IsComplete
(
)
)
{
result
&
=
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
;
}
return
result
;
}
ImgDrawResult
nsImageRenderer
:
:
BuildWebRenderDisplayItems
(
nsPresContext
*
aPresContext
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayItem
*
aItem
const
nsRect
&
aDirtyRect
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsSize
&
aRepeatSize
const
CSSIntRect
&
aSrc
float
aOpacity
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
NOT_READY
;
}
if
(
aDest
.
IsEmpty
(
)
|
|
aFill
.
IsEmpty
(
)
|
|
mSize
.
width
<
=
0
|
|
mSize
.
height
<
=
0
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
switch
(
mType
)
{
case
eStyleImageType_Gradient
:
{
nsCSSGradientRenderer
renderer
=
nsCSSGradientRenderer
:
:
Create
(
aPresContext
mForFrame
-
>
Style
(
)
mGradientData
mSize
)
;
renderer
.
BuildWebRenderDisplayItems
(
aBuilder
aSc
aDest
aFill
aRepeatSize
aSrc
!
aItem
-
>
BackfaceIsHidden
(
)
aOpacity
)
;
break
;
}
case
eStyleImageType_Image
:
{
uint32_t
containerFlags
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
mFlags
&
nsImageRenderer
:
:
FLAG_PAINTING_TO_WINDOW
)
{
containerFlags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
if
(
mFlags
&
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
)
{
containerFlags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
CSSIntSize
imageSize
(
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
height
)
)
;
Maybe
<
SVGImageContext
>
svgContext
(
Some
(
SVGImageContext
(
Some
(
imageSize
)
)
)
)
;
const
int32_t
appUnitsPerDevPixel
=
mForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
destRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
aDest
appUnitsPerDevPixel
)
;
gfx
:
:
IntSize
decodeSize
=
nsLayoutUtils
:
:
ComputeImageContainerDrawingParameters
(
mImageContainer
mForFrame
destRect
aSc
containerFlags
svgContext
)
;
RefPtr
<
layers
:
:
ImageContainer
>
container
=
mImageContainer
-
>
GetImageContainerAtSize
(
aManager
decodeSize
svgContext
containerFlags
)
;
if
(
!
container
)
{
NS_WARNING
(
"
Failed
to
get
image
container
"
)
;
return
ImgDrawResult
:
:
NOT_READY
;
}
mozilla
:
:
wr
:
:
ImageRendering
rendering
=
wr
:
:
ToImageRendering
(
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
aItem
-
>
Frame
(
)
)
)
;
gfx
:
:
IntSize
size
;
Maybe
<
wr
:
:
ImageKey
>
key
=
aManager
-
>
CommandBuilder
(
)
.
CreateImageKey
(
aItem
container
aBuilder
aResources
rendering
aSc
size
Nothing
(
)
)
;
if
(
key
.
isNothing
(
)
)
{
return
ImgDrawResult
:
:
NOT_READY
;
}
nsPoint
firstTilePos
=
nsLayoutUtils
:
:
GetBackgroundFirstTilePos
(
aDest
.
TopLeft
(
)
aFill
.
TopLeft
(
)
aRepeatSize
)
;
LayoutDeviceRect
fillRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
nsRect
(
firstTilePos
.
x
firstTilePos
.
y
aFill
.
XMost
(
)
-
firstTilePos
.
x
aFill
.
YMost
(
)
-
firstTilePos
.
y
)
appUnitsPerDevPixel
)
;
wr
:
:
LayoutRect
fill
=
wr
:
:
ToRoundedLayoutRect
(
fillRect
)
;
wr
:
:
LayoutRect
clip
=
wr
:
:
ToRoundedLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
aFill
appUnitsPerDevPixel
)
)
;
LayoutDeviceSize
gapSize
=
LayoutDeviceSize
:
:
FromAppUnits
(
aRepeatSize
-
aDest
.
Size
(
)
appUnitsPerDevPixel
)
;
aBuilder
.
PushImage
(
fill
clip
!
aItem
-
>
BackfaceIsHidden
(
)
wr
:
:
ToLayoutSize
(
destRect
.
Size
(
)
)
wr
:
:
ToLayoutSize
(
gapSize
)
rendering
key
.
value
(
)
)
;
break
;
}
default
:
break
;
}
return
mImage
-
>
IsComplete
(
)
?
ImgDrawResult
:
:
SUCCESS
:
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
;
}
already_AddRefed
<
gfxDrawable
>
nsImageRenderer
:
:
DrawableForElement
(
const
nsRect
&
aImageRect
gfxContext
&
aContext
)
{
NS_ASSERTION
(
mType
=
=
eStyleImageType_Element
"
DrawableForElement
only
makes
sense
if
backed
by
an
element
"
)
;
if
(
mPaintServerFrame
)
{
int32_t
appUnitsPerDevPixel
=
mForFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
destRect
=
aImageRect
-
aImageRect
.
TopLeft
(
)
;
nsIntSize
roundedOut
=
destRect
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
.
Size
(
)
;
IntSize
imageSize
(
roundedOut
.
width
roundedOut
.
height
)
;
RefPtr
<
gfxDrawable
>
drawable
=
nsSVGIntegrationUtils
:
:
DrawableFromPaintServer
(
mPaintServerFrame
mForFrame
mSize
imageSize
aContext
.
GetDrawTarget
(
)
aContext
.
CurrentMatrixDouble
(
)
nsSVGIntegrationUtils
:
:
FLAG_SYNC_DECODE_IMAGES
)
;
return
drawable
.
forget
(
)
;
}
NS_ASSERTION
(
mImageElementSurface
.
GetSourceSurface
(
)
"
Surface
should
be
ready
.
"
)
;
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxSurfaceDrawable
(
mImageElementSurface
.
GetSourceSurface
(
)
.
get
(
)
mImageElementSurface
.
mSize
)
;
return
drawable
.
forget
(
)
;
}
ImgDrawResult
nsImageRenderer
:
:
DrawLayer
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
const
nsSize
&
aRepeatSize
float
aOpacity
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
if
(
aDest
.
IsEmpty
(
)
|
|
aFill
.
IsEmpty
(
)
|
|
mSize
.
width
<
=
0
|
|
mSize
.
height
<
=
0
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
return
Draw
(
aPresContext
aRenderingContext
aDirty
aDest
aFill
aAnchor
aRepeatSize
CSSIntRect
(
0
0
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
height
)
)
aOpacity
)
;
}
ImgDrawResult
nsImageRenderer
:
:
BuildWebRenderDisplayItemsForLayer
(
nsPresContext
*
aPresContext
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayItem
*
aItem
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
const
nsSize
&
aRepeatSize
float
aOpacity
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
mPrepareResult
;
}
if
(
aDest
.
IsEmpty
(
)
|
|
aFill
.
IsEmpty
(
)
|
|
mSize
.
width
<
=
0
|
|
mSize
.
height
<
=
0
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
return
BuildWebRenderDisplayItems
(
aPresContext
aBuilder
aResources
aSc
aManager
aItem
aDirty
aDest
aFill
aAnchor
aRepeatSize
CSSIntRect
(
0
0
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
mSize
.
height
)
)
aOpacity
)
;
}
static
nsRect
ComputeTile
(
nsRect
&
aFill
StyleBorderImageRepeat
aHFill
StyleBorderImageRepeat
aVFill
const
nsSize
&
aUnitSize
nsSize
&
aRepeatSize
)
{
nsRect
tile
;
switch
(
aHFill
)
{
case
StyleBorderImageRepeat
:
:
Stretch
:
tile
.
x
=
aFill
.
x
;
tile
.
width
=
aFill
.
width
;
aRepeatSize
.
width
=
tile
.
width
;
break
;
case
StyleBorderImageRepeat
:
:
Repeat
:
tile
.
x
=
aFill
.
x
+
aFill
.
width
/
2
-
aUnitSize
.
width
/
2
;
tile
.
width
=
aUnitSize
.
width
;
aRepeatSize
.
width
=
tile
.
width
;
break
;
case
StyleBorderImageRepeat
:
:
Round
:
tile
.
x
=
aFill
.
x
;
tile
.
width
=
nsCSSRendering
:
:
ComputeRoundedSize
(
aUnitSize
.
width
aFill
.
width
)
;
aRepeatSize
.
width
=
tile
.
width
;
break
;
case
StyleBorderImageRepeat
:
:
Space
:
{
nscoord
space
;
aRepeatSize
.
width
=
nsCSSRendering
:
:
ComputeBorderSpacedRepeatSize
(
aUnitSize
.
width
aFill
.
width
space
)
;
tile
.
x
=
aFill
.
x
+
space
;
tile
.
width
=
aUnitSize
.
width
;
aFill
.
x
=
tile
.
x
;
aFill
.
width
=
aFill
.
width
-
space
*
2
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unrecognized
border
-
image
fill
style
"
)
;
}
switch
(
aVFill
)
{
case
StyleBorderImageRepeat
:
:
Stretch
:
tile
.
y
=
aFill
.
y
;
tile
.
height
=
aFill
.
height
;
aRepeatSize
.
height
=
tile
.
height
;
break
;
case
StyleBorderImageRepeat
:
:
Repeat
:
tile
.
y
=
aFill
.
y
+
aFill
.
height
/
2
-
aUnitSize
.
height
/
2
;
tile
.
height
=
aUnitSize
.
height
;
aRepeatSize
.
height
=
tile
.
height
;
break
;
case
StyleBorderImageRepeat
:
:
Round
:
tile
.
y
=
aFill
.
y
;
tile
.
height
=
nsCSSRendering
:
:
ComputeRoundedSize
(
aUnitSize
.
height
aFill
.
height
)
;
aRepeatSize
.
height
=
tile
.
height
;
break
;
case
StyleBorderImageRepeat
:
:
Space
:
{
nscoord
space
;
aRepeatSize
.
height
=
nsCSSRendering
:
:
ComputeBorderSpacedRepeatSize
(
aUnitSize
.
height
aFill
.
height
space
)
;
tile
.
y
=
aFill
.
y
+
space
;
tile
.
height
=
aUnitSize
.
height
;
aFill
.
y
=
tile
.
y
;
aFill
.
height
=
aFill
.
height
-
space
*
2
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unrecognized
border
-
image
fill
style
"
)
;
}
return
tile
;
}
static
bool
RequiresScaling
(
const
nsRect
&
aFill
StyleBorderImageRepeat
aHFill
StyleBorderImageRepeat
aVFill
const
nsSize
&
aUnitSize
)
{
return
(
aHFill
!
=
StyleBorderImageRepeat
:
:
Stretch
|
|
aVFill
!
=
StyleBorderImageRepeat
:
:
Stretch
)
&
&
(
aUnitSize
.
width
!
=
aFill
.
width
|
|
aUnitSize
.
height
!
=
aFill
.
height
)
;
}
ImgDrawResult
nsImageRenderer
:
:
DrawBorderImageComponent
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aFill
const
CSSIntRect
&
aSrc
StyleBorderImageRepeat
aHFill
StyleBorderImageRepeat
aVFill
const
nsSize
&
aUnitSize
uint8_t
aIndex
const
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasIntrinsicRatio
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
aFill
.
IsEmpty
(
)
|
|
aSrc
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
if
(
mType
=
=
eStyleImageType_Image
|
|
mType
=
=
eStyleImageType_Element
)
{
nsCOMPtr
<
imgIContainer
>
subImage
;
uint32_t
drawFlags
=
ConvertImageRendererToDrawFlags
(
mFlags
)
|
imgIContainer
:
:
FLAG_FORCE_PRESERVEASPECTRATIO_NONE
;
if
(
!
aHasIntrinsicRatio
)
{
drawFlags
=
drawFlags
|
imgIContainer
:
:
FLAG_FORCE_UNIFORM_SCALING
;
}
nsIntRect
srcRect
(
aSrc
.
x
aSrc
.
y
aSrc
.
width
aSrc
.
height
)
;
if
(
mType
=
=
eStyleImageType_Image
)
{
if
(
(
subImage
=
mImage
-
>
GetSubImage
(
aIndex
)
)
=
=
nullptr
)
{
subImage
=
ImageOps
:
:
Clip
(
mImageContainer
srcRect
aSVGViewportSize
)
;
mImage
-
>
SetSubImage
(
aIndex
subImage
)
;
}
}
else
{
RefPtr
<
gfxDrawable
>
drawable
=
DrawableForElement
(
nsRect
(
nsPoint
(
)
mSize
)
aRenderingContext
)
;
if
(
!
drawable
)
{
NS_WARNING
(
"
Could
not
create
drawable
for
element
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
nsCOMPtr
<
imgIContainer
>
image
(
ImageOps
:
:
CreateFromDrawable
(
drawable
)
)
;
subImage
=
ImageOps
:
:
Clip
(
image
srcRect
aSVGViewportSize
)
;
}
MOZ_ASSERT
(
!
aSVGViewportSize
|
|
subImage
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
;
SamplingFilter
samplingFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
mForFrame
)
;
if
(
!
RequiresScaling
(
aFill
aHFill
aVFill
aUnitSize
)
)
{
ImgDrawResult
result
=
nsLayoutUtils
:
:
DrawSingleImage
(
aRenderingContext
aPresContext
subImage
samplingFilter
aFill
aDirtyRect
Nothing
(
)
drawFlags
)
;
if
(
!
mImage
-
>
IsComplete
(
)
)
{
result
&
=
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
;
}
return
result
;
}
nsSize
repeatSize
;
nsRect
fillRect
(
aFill
)
;
nsRect
tile
=
ComputeTile
(
fillRect
aHFill
aVFill
aUnitSize
repeatSize
)
;
CSSIntSize
imageSize
(
srcRect
.
width
srcRect
.
height
)
;
ImgDrawResult
result
=
nsLayoutUtils
:
:
DrawBackgroundImage
(
aRenderingContext
mForFrame
aPresContext
subImage
imageSize
samplingFilter
tile
fillRect
repeatSize
tile
.
TopLeft
(
)
aDirtyRect
drawFlags
ExtendMode
:
:
CLAMP
1
.
0
)
;
if
(
!
mImage
-
>
IsComplete
(
)
)
{
result
&
=
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
;
}
return
result
;
}
nsSize
repeatSize
(
aFill
.
Size
(
)
)
;
nsRect
fillRect
(
aFill
)
;
nsRect
destTile
=
RequiresScaling
(
fillRect
aHFill
aVFill
aUnitSize
)
?
ComputeTile
(
fillRect
aHFill
aVFill
aUnitSize
repeatSize
)
:
fillRect
;
return
Draw
(
aPresContext
aRenderingContext
aDirtyRect
destTile
fillRect
destTile
.
TopLeft
(
)
repeatSize
aSrc
)
;
}
ImgDrawResult
nsImageRenderer
:
:
DrawShapeImage
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
)
{
if
(
!
IsReady
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Ensure
PrepareImage
(
)
has
returned
true
before
"
"
calling
me
"
)
;
return
ImgDrawResult
:
:
NOT_READY
;
}
if
(
mSize
.
width
<
=
0
|
|
mSize
.
height
<
=
0
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
switch
(
mType
)
{
case
eStyleImageType_Image
:
{
uint32_t
drawFlags
=
ConvertImageRendererToDrawFlags
(
mFlags
)
|
imgIContainer
:
:
FRAME_FIRST
;
nsRect
dest
(
nsPoint
(
0
0
)
mSize
)
;
result
=
nsLayoutUtils
:
:
DrawSingleImage
(
aRenderingContext
aPresContext
mImageContainer
SamplingFilter
:
:
POINT
dest
dest
Nothing
(
)
drawFlags
nullptr
nullptr
)
;
break
;
}
case
eStyleImageType_Gradient
:
{
nsCSSGradientRenderer
renderer
=
nsCSSGradientRenderer
:
:
Create
(
aPresContext
mForFrame
-
>
Style
(
)
mGradientData
mSize
)
;
nsRect
dest
(
nsPoint
(
0
0
)
mSize
)
;
renderer
.
Paint
(
aRenderingContext
dest
dest
mSize
CSSIntRect
:
:
FromAppUnitsRounded
(
dest
)
dest
1
.
0
)
;
break
;
}
default
:
result
=
ImgDrawResult
:
:
BAD_IMAGE
;
break
;
}
return
result
;
}
bool
nsImageRenderer
:
:
IsRasterImage
(
)
{
if
(
mType
!
=
eStyleImageType_Image
|
|
!
mImageContainer
)
return
false
;
return
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_RASTER
;
}
bool
nsImageRenderer
:
:
IsAnimatedImage
(
)
{
if
(
mType
!
=
eStyleImageType_Image
|
|
!
mImageContainer
)
return
false
;
bool
animated
=
false
;
if
(
NS_SUCCEEDED
(
mImageContainer
-
>
GetAnimated
(
&
animated
)
)
&
&
animated
)
return
true
;
return
false
;
}
already_AddRefed
<
imgIContainer
>
nsImageRenderer
:
:
GetImage
(
)
{
if
(
mType
!
=
eStyleImageType_Image
|
|
!
mImageContainer
)
{
return
nullptr
;
}
nsCOMPtr
<
imgIContainer
>
image
=
mImageContainer
;
return
image
.
forget
(
)
;
}
bool
nsImageRenderer
:
:
IsImageContainerAvailable
(
layers
:
:
LayerManager
*
aManager
uint32_t
aFlags
)
{
if
(
!
mImageContainer
)
{
return
false
;
}
return
mImageContainer
-
>
IsImageContainerAvailable
(
aManager
aFlags
)
;
}
void
nsImageRenderer
:
:
PurgeCacheForViewportChange
(
const
Maybe
<
nsSize
>
&
aSVGViewportSize
const
bool
aHasIntrinsicRatio
)
{
if
(
mImageContainer
&
&
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
mImage
-
>
PurgeCacheForViewportChange
(
aSVGViewportSize
aHasIntrinsicRatio
)
;
}
}
already_AddRefed
<
nsStyleGradient
>
nsImageRenderer
:
:
GetGradientData
(
)
{
RefPtr
<
nsStyleGradient
>
res
=
mGradientData
;
return
res
.
forget
(
)
;
}
